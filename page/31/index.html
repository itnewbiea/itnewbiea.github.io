<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f6960b504ba60c3ebbf5629ba8bcea/" rel="bookmark">
			Qt for Android设置安卓程序默认横屏&#43;全屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的qt版本是5.14.1，网上查到的方法是，把编译出的build文件夹中的AndroidManifest.xml文件复制出来然后修改，然后把修改后的xml文件加入pro文件，语法为ANDROID_PACKAGE_SOURCE_DIR = $$PWD/AndroidManifest.xml（具体；路径要按照xml文件相对于pro文件的相对路径如实填写）
以上方法我测试过会报错，无法编译出apk。
又看到一个方法：直接在项目-&gt;安卓build-&gt;Build Andriod Apk详情-&gt;create Template，如下图
点击上图的create template创建模板按钮后，QT也会在pro文件中自动添加以下内容：
以上内容在工程目录树中，呈现为下图的样子：
由以上两图可见，自动生成的文件中，有一个就是AndroidManifest.xml。这个文件在qt中可以用可视化的方式编辑，如上图所示，也可以直接以txt文本的方式编辑，如下图所示。
可视化编辑模式下，可编辑的东西很少，就是上图所显示的这些东西，有趣的是可以直接设置3个图标：高分辨率图标、中分辨率图标、低分辨率图标。
然后以文本模式打开它，如下图红线所示的地方，修改为 landscape 就可以实现app启动时横屏
所谓全屏，就是app启动后，顶部的状态栏也要隐藏掉。方法还是修改这个xml文件，继续在上一步的lanscape后再加一句全屏，如下所示。注意中间用空格隔开。
android:screenOrientation="landscape" android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
Qt android 设置系统状态栏为全透明，半透明、全屏，设置状态栏颜色，修改程序图标_qt 状态栏颜色-CSDN博客
Qt for Android之AndroidManifest.xml详解_qt manifest-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15c674f54f4df208668398719363ba8/" rel="bookmark">
			RuntimeError: Expected to have finished reduction in the prior iteration before starting a new one.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch多卡训练时，报错：
RuntimeError: Expected to have finished reduction in the prior iteration before starting a new one. This error indicates that your module has parameters that were not used in producing loss. You can enable unused parameter detection by passing the keyword argument `find_unused_parameters=True` to `torch.nn.parallel.DistributedDataParallel`, and by
making sure all `forward` function outputs participate in calculating loss.
If you already have done the above, then the distributed data parallel module wasn't able to locate the output tensors in the return value of your module's `forward` function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b15c674f54f4df208668398719363ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866aed64f8b70db0e59fd47734191607/" rel="bookmark">
			Spring 6（二）【IOC原理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 IOC 是Spring的两大核心概念之一，它是一种思想，需要极其熟练的掌握。
今日摘录：
低能无聊的人太多。说他们勤勉，不过是因困为不会合理分配时间；说他们积极，不过是逃避其他困难工作而已。即便说工作只是生存手段，也没见他们有什么拿得出手的爱好或特长。我真是每天都在失望。低能无聊的人要是边不满边骂着自己的低能无聊却不愿做出任何改变，那就真是自寻烦恼自掘坟墓了。
——东野圭吾《变身》
1、IOC IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。
1.1、控制反转 控制反转不是技术，而是一种思想。
控制反转是为了降低程序耦合度，提高程序扩展力。
控制反转，反转的是什么？
将对象的创建权利交出去，交给第三方容器（IOC 容器）负责。
将对象和对象之间关系的维护权交出去，交给第三方容器负责。
控制反转这种思想如何实现呢？
DI（Dependency Injection）：依赖注入
依赖注入（DI）：
指Spring创建对象的过程中，将对象依赖属性通过配置进行注入
依赖注入常见的实现方式包括两种：
第一种：set注入
第二种：构造器注入
所以，IOC 就是一种控制反转的思想， 而 DI 是对 IOC的一种具体实现。
1.2、获取 Bean 的 3 种方式 其实也就是 getBean() 的三种传参方式，下面对我们上一节的 User 类进行测试。
&lt;bean id="user" class="com.lyh.study.User"/&gt; 1.2.1、getBean（String id） 因为返回的是一个 Object 类型所以需要强转一下。 @Test public void testHelloWorld1(){ ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = (User)ac.getBean("user"); user.add(); } 1.2.2、 getBean（Class&lt;? extends Object&gt; requiredType） 因为传入的就是一个类，所以可以自动推断出返回的类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/866aed64f8b70db0e59fd47734191607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b00434facc850c7740de2a87d50c402/" rel="bookmark">
			AI项目十八：YOLOV8自训练关键点检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处。
记录学习YOLOV8过程，自训练关键点检测模型。
清华源：-i https://mirror.baidu.com/pypi/simple
1、yolov8安装 git clone https://github.com/ultralytics/ultralytics ​ cd ultralytics ​ pip install -e . 安装成功后，使用命令 yolo 简单看下版本
(yolov8) llh@anhao:/$ yolo version ​ 8.0.206 2、简单测试 下载权重文件
GitHub - ultralytics/ultralytics: NEW - YOLOv8 🚀 in PyTorch &gt; ONNX &gt; OpenVINO &gt; CoreML &gt; TFLite
直接点击下载。
获取测试图片的文件在ultralytics\assets目录有，使用的是的里面的bus.jpg测试。
使用 yolo 命令进行测试
yolo detect predict model=./yolov8n.pt source=./bus.jpg 输出在runs/detect/predict/目录下。
3、安装labelme pip install labelme 直接在终端运行labelme打开软件
先取消“保存图片数据”（减少标注文件大小）；在文件下
打开文件目录
接下来标注
先标注检测框，检测框用Create Rectangle(Ctrl+N)
填写类别名称
填写group_id，用于匹配后续标注的关键点，以当前画面中出现的顺序标注即可。
标注关键点,检测关键点用Create Point
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b00434facc850c7740de2a87d50c402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29bbb660cf4a3f41b2d81c2d9ea3bc4f/" rel="bookmark">
			【DataSophon】大数据服务组件之Flink升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦄 个人主页——🎐开着拖拉机回家_Linux,大数据运维-CSDN博客 🎐✨🍁
🪁🍁🪁🍁🪁🍁🪁🍁 🪁🍁🪁🍁🪁🍁🪁 🪁🍁🪁🍁🪁🍁🪁🍁🪁🍁🪁🍁
感谢点赞和关注 ，每天进步一点点！加油！
目录
一、DataSophon是什么
1.1 DataSophon概述
1.2 架构概览
1.3 设计思想
二、解压新旧组件安装包
三、 修改安装包中文件和目录
四、重新生成安装包
3.1 重新打包
3.2 生成加密码
3.3 生成md5加密文件
五、 删除已装的组件包flink(ALL)
六、修改service_ddl.json
七、修改env环境变量(ALL)
7.1修改环境变量配置参数(ALL)
7.2 重启manager服务
八、重新安装服务
九、测试验证
一、DataSophon是什么 1.1 DataSophon概述 DataSophon也是个类似的管理平台，只不过与智子不同的是，智子的目的是锁死人类的基础科学阻碍人类技术爆炸，而DataSophon是致力于自动化监控、运维、管理大数据基础组件和节点的，帮助您快速构建起稳定，高效的大数据集群服务。
主要特性有:
快速部署,可快速完成300个节点的大数据集群部署兼容复杂环境,极少的依赖使其很容易适配各种复杂环境监控指标全面丰富，基于生产实践展示用户最关心的监控指标灵活便捷的告警服务，可实现用户自定义告警组和告警指标可扩展性强，用户可通过配置的方式集成或升级大数据组件 官方地址：DataSophon | DataSophon
GITHUB地址：datasophon/README_CN.md at dev · datavane/datasophon
1.2 架构概览 1.3 设计思想 为设计出轻量级，高性能，高可扩的，可满足国产化环境要求的大数据集群管理平台。需满足以下设计要求：
（1）一次编译，处处运行，项目部署仅依赖java环境，无其他系统环境依赖。
（2）DataSophon工作端占用资源少，不占用大数据计算节点资源。
（3）可扩展性高，可通过配置的方式集成托管第三方组件。
二、解压新旧组件安装包 flink-1.6.2升级到flink-1.6.3，安装包下载
https://mirrors.tuna.tsinghua.edu.cn/apache/ https://archive.apache.org/dist/flink/flink-1.6.3/ 解压
tar -zxvf flink-1.16.3-bin-scala_2.12.tgz -C /opt/datasophon/DDP/packages 三、 修改安装包中文件和目录 cd /opt/datasophon/DDP/packages chown -R root:root flink-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29bbb660cf4a3f41b2d81c2d9ea3bc4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67a98d1d3cfa7968c9e4274a24ed7ce/" rel="bookmark">
			如何从 iPhone 上恢复已删除的照片教程分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您是否错误地删除了 iPhone 上的错误照片？或者您可能已将手机恢复出厂设置，但现在所有照片都消失了？如果您现在遇到这样的情况，我们可以为您提供解决方案。
在本文中，我们将向您展示七种数据恢复方法，可以帮助您恢复 iPhone 上已删除的照片。
如何在 iPhone 上查找已删除的照片 默认情况下，iPhone 将照片和图像存储在名为照片的本机应用中。该应用程序预装在所有 iPhone 中，用户无法删除，因为它是此类数据的主要存储位置。此外，应用程序本身包含不同的文件夹，用于组织所有内容。
您可以使用 iPhone 上的“照片”应用搜索任何照片。做到这一点非常容易，因为应用程序中的所有照片都根据不同的标准分组到文件夹中。如果您至少记得有关您要查找的照片的一些信息，您应该能够在几秒钟内找到它。
以下是如何在 iPhone 上的“照片”应用中搜索照片的方法：
检查“图库”标签：您可以在此处根据照片的拍摄日期或添加到手机的日期查看照片。浏览“相册”标签中的文件夹：此标签将根据自拍、肖像、屏幕截图、导入、动画、最近照片等类别对您的所有照片进行分组.使用“照片”应用中的搜索工具：点按应用程序右下角的放大镜图标可使用关键字搜索一张或多张照片，查看按类别分组的照片到拍摄地点、查看与特定人物的照片等。 如何恢复 iPhone 上已删除的照片 这里有七种最有效的数据恢复解决方案，可以帮助您恢复 iPhone 上已删除的照片。
选项 1：检查最近删除的文件夹 从 iPhone 上的“照片”应用中删除照片后，它不会立即从其中删除。首先，您的手机将其移至应用程序内名为 Recently Deleted 的文件夹中。通过此文件夹，您可以查看 iPhone 上已删除的照片，而无需备份。
注意：已删除的照片将在添加到“最近删除”文件夹 30 天后手动从该文件夹中删除。
请按照以下步骤查找 iPhone 上最近删除的照片并恢复它们：
打开 iPhone 上的照片应用。
转到相册标签。
向下滚动找到最近删除文件夹并点按将其打开。最近删除的文件夹照片应用程序 iPhone
点按选择并选择您想要恢复的照片。
准备就绪后，点按恢复。恢复已删除的照片 iPhone
选项 2：使用数据恢复软件 如果您要查找的照片不再位于“最近删除”文件夹中，您最好的选择是使用专用数据恢复软件 将其带回来。但这里的关键是尽快开始恢复过程，因为您的目标是不让手机上的 iOS 用其他数据覆盖已删除的照片。
市场上没有那么多应用程序可以恢复iPhone上已删除的照片。在这种情况下选择数据恢复工具时，我们的建议是奇客数据恢复iOS版。
奇客iPhone数据恢复软件——具有业界最高的恢复成功率软件支持从 iPhone、iPad、iTunes 和 iCloud 恢复照片、视频、联系人、消息、笔记、通话记录等，支持最新的iPhone13与iOS15系统。https://www.geekersoft.cn/phone-rescue.html此应用程序是少数具有在 iPhone 上执行数据恢复功能的应用程序之一。此外，它不仅可以恢复手机中的照片，还可以恢复各种其他文件类型（文档、视频、笔记、电子邮件文件等）。 ）。
请按照以下步骤使用 奇客数据恢复iOS版恢复 iPhone 上意外删除的照片：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e67a98d1d3cfa7968c9e4274a24ed7ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d436fe8a4400c0c7f9614181e2afb25/" rel="bookmark">
			LeetCode（69）对称二叉树【二叉树】【简单】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.题目2.答案3.提交结果截图 链接： 对称二叉树
1.题目 给你一个二叉树的根节点 root ， 检查它是否轴对称。
示例 1：
输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2：
输入：root = [1,2,2,null,3,null,3] 输出：false 提示：
树中节点数目在范围 [1, 1000] 内-100 &lt;= Node.val &lt;= 100 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？
2.答案 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d436fe8a4400c0c7f9614181e2afb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8348f5ad4b4ddcce5ea9994ee1d27c/" rel="bookmark">
			基于 WebSocket 打造聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 WebSocket？ WebSocket 是一种基于TCP连接上进行 全双工 通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
二、WebSocket 的应用场景 WebSocket 的特点，决定了他在一些 实时双向通信、低延迟、推送等功能的应用场景下的独特优势。
在WebSocket 出现之前，Web 程序想要进行实时通信是非常麻烦的，因为 HTTP 是一种无状态、无连接、单向的应用层协议，它无法实现服务器主动向客户端推送消息，并且这种单向请求的特点，注定了客户端实时获取服务端的变化就非常麻烦，通常情况下，需要客户端频繁的对服务器进行轮询，这种方式不仅效率低，实时性不好，而且这种频繁的请求和响应对服务器来说也是一种负担。
三、WebSocket API 1、客户端/浏览器 API 由于 WebSocket 协议是 HTML5开始支持的，所以想要使用 WebSocket 协议，首先保证浏览器支持 HTML5.
websocket 对象创建
let ws = new WebSocket(URL); 注：这里的 url 格式为 协议://ip地址:端口号/访问路径。协议名称固定为 ws
websocket 事件
事件事件处理程序描述openws.onopen连接建立时触发messagews.onmessage客户端接收服务端数据时触发errorws.onerror通信发生错误时触发closews.onclose连接关闭时触发 websocket 方法
方法描述ws.send()使用连接发送数据到服务器ws.close()关闭连接 2、服务端 API Tomcat 从 7.0.5 版本开始支持 WebSocket，所以使用时注意 Tomcat 版本不能低于 7.0.5。在Java中，Endpoint 表示服务器 Websocket 连接的一端，可以视之为处理WebSocket消息的接口。Java 中可以通过两种方式定义Endpoint：
编程式：通过继承 javax.websocket.Endpoint并实现其方法。注解式：通过添加 @ServerEndpoint 等相关注解。 Endpoint 实例在 WebSocket 握手时创建，并在客户端与服务端连接过程中有效，在连接关闭时结束，在Endpoint接口中就定义了其生命周期的相关方法：
方法注解描述onOpen@OnOpen注解所标识的方法连接建立时触发onError@OnError注解所标识的方法通信发生错误时触发onClose@OnClose注解所标识的方法连接关闭时触发 在 onOpen 方法中，将创建一个 Session 对象，表示当前 WebSocket 连接的会话，Session对象提供了一组方法，用于管理WebSocket连接和事件。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc8348f5ad4b4ddcce5ea9994ee1d27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831dfcc514826547823ecf03b1e1ff94/" rel="bookmark">
			详细学习Pyqt5的9种显示控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyqt5相关文章:
快速掌握Pyqt5的三种主窗口
快速掌握Pyqt5的2种弹簧
快速掌握Pyqt5的5种布局
快速弄懂Pyqt5的5种项目视图（Item View）
快速弄懂Pyqt5的4种项目部件（Item Widget）
快速掌握Pyqt5的6种按钮
快速掌握Pyqt5的10种容器（Containers）
快速掌握Pyqt5的20种输入控件（Input Widgets）
快速掌握Pyqt5的9种显示控件
详细学习Pyqt5中的5种布局方式
详细学习Pyqt5中的6种按钮
详细学习Pyqt5中的2种弹簧
详细学习Pyqt5的5种项目视图（Item View）
详细学习Pyqt5的4种项目部件（Item Widget）
详细学习Pyqt5的20种输入控件（Input Widgets）
详细学习Pyqt5的9种显示控件
详细学习Pyqt5的10种容器（Containers）
详细学习PyQt5与数据库交互
详细学习PyQt5中的多线程
快速学习PyQt5的动画和图形效果
快速学习PyQt5的高级自定义控件
快速学会绘制Pyqt5中的所有图（上）
快速学会绘制Pyqt5中的所有图（下）
通过“待办事项列表项目”快速学习Pyqt5的一些特性
待续。。。
在PyQt5界面设计中，显示控件扮演着至关重要的角色。它们不仅负责向用户展示信息、图像、或其他多媒体内容，而且在很大程度上决定了应用程序的用户体验和交互效果。通过精心设计和使用这些控件，可以创建出直观、易于操作且视觉上吸引人的界面。
在本文中，我们将探讨一系列重要的PyQt5显示控件，每个控件都有其独特的功能和应用场景：
QLabel：用于显示文本或图像，是最基础的显示控件之一。QTextBrowser：提供丰富文本的显示，支持超链接和HTML格式。QGraphicsView：用于展示复杂的2D图形界面，适用于游戏、图形编辑等程序。QCalendarWidget：提供一个交互式的日历控件，允许用户选择日期。QLCDNumber：用于显示液晶风格的数字，常用于计时器、状态指示等。QProgressBar：展示任务进度，给用户反馈任务完成度。QFrame：用于添加框架、分割线，帮助划分界面区域。QOpenGLWidget：集成OpenGL用于高性能图形渲染，适用于3D图形和动画。QQuickWidget：用于集成QML界面，实现更加动态和现代的用户界面设计。 了解这些控件如何工作及其适用场景，对于设计高效、美观的用户界面至关重要。接下来，我们将逐一深入探讨每个控件的特点和使用方法。
1. QLabel - 文本和图像的展示 QLabel 是 PyQt5 中最常用的控件之一，主要用于显示文本和图像。它提供了一种简单而灵活的方式来向用户展示信息，同时也支持基本的文本格式化。
基本功能
展示文本：QLabel 可以显示普通文本、富文本或者 HTML。它支持文本的多种格式化，比如字体大小、颜色和对齐方式。展示图像：QLabel 也可以用来展示图像。它可以显示各种格式的图像，包括 PNG、JPEG 和 GIF。 自定义外观和行为
文本和图像对齐：可以设置 QLabel 的对齐方式，如左对齐、居中或右对齐。字体样式：可以自定义字体大小、粗细、颜色等。交互反馈：虽然 QLabel 通常用于显示信息，但它也可以配置为响应用户交互，例如当鼠标悬停或点击时改变样式。 代码示例
下面的示例将展示如何在 PyQt5 应用中使用 QLabel 来显示文本和图像。
import sys from PyQt5.QtWidgets import QApplication, QLabel, QWidget, QVBoxLayout from PyQt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831dfcc514826547823ecf03b1e1ff94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac96207ef1970207390452230dafca16/" rel="bookmark">
			快速学会绘制Pyqt5中的所有图（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyqt5相关文章:
快速掌握Pyqt5的三种主窗口
快速掌握Pyqt5的2种弹簧
快速掌握Pyqt5的5种布局
快速弄懂Pyqt5的5种项目视图（Item View）
快速弄懂Pyqt5的4种项目部件（Item Widget）
快速掌握Pyqt5的6种按钮
快速掌握Pyqt5的10种容器（Containers）
快速掌握Pyqt5的20种输入控件（Input Widgets）
快速掌握Pyqt5的9种显示控件
详细学习Pyqt5中的5种布局方式
详细学习Pyqt5中的6种按钮
详细学习Pyqt5中的2种弹簧
详细学习Pyqt5的5种项目视图（Item View）
详细学习Pyqt5的4种项目部件（Item Widget）
详细学习Pyqt5的20种输入控件（Input Widgets）
详细学习Pyqt5的9种显示控件
详细学习Pyqt5的10种容器（Containers）
详细学习PyQt5与数据库交互
详细学习PyQt5中的多线程
快速学习PyQt5的动画和图形效果
快速学习PyQt5的高级自定义控件
快速学会绘制Pyqt5中的所有图（上）
快速学会绘制Pyqt5中的所有图（下）
通过“待办事项列表项目”快速学习Pyqt5的一些特性
待续。。。
雷达图 PyQtGraph 并不直接支持雷达图（也称为蜘蛛网图或极坐标图），但您可以使用 PyQt 的绘图能力手动创建一个。要在 PyQt 中绘制雷达图，您需要使用 QPainter 类来在 QWidget 或类似对象上进行自定义绘图。
以下是一个使用 PyQt5 创建简单雷达图的示例：
编写代码绘制雷达图:
import sys import math from PyQt5.QtWidgets import QApplication, QWidget from PyQt5.QtGui import QPainter, QPolygon, QPen from PyQt5.QtCore import Qt, QPoint class RadarWidget(QWidget): def __init__(self, data): super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac96207ef1970207390452230dafca16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a94fe6bbac67e2788e49ef4b082b4c/" rel="bookmark">
			快速学习C&#43;&#43;中的模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模板是一个让C++支持范型编程的重要功能，它本质上是一个万能变量适配器；vector,pair等都是使用模板实现的
模板是C++的一个强大特性，它允许您编写通用的代码来处理不同的数据类型。您可以有函数模板和类模板。
函数模板: 函数模板允许您创建一个函数，该函数可以处理多种数据类型的输入。
template &lt;typename T&gt; T max(T a, T b) { return (a &gt; b) ? a : b; } int main() { std::cout &lt;&lt; max(3, 5) &lt;&lt; std::endl; // 对于int类型 std::cout &lt;&lt; max(4.5, 3.5) &lt;&lt; std::endl; // 对于double类型 return 0; } 在上面的代码中，max函数的返回类型和其参数类型都是由模板参数T决定的。当你使用不同的数据类型调用max时，编译器会为每种数据类型生成一个版本的函数。
类模板: 类模板允许您定义一个能够处理多种数据类型的类。
template &lt;typename T&gt; class Box { private: T content; public: Box(T content) : content(content) {} T getContent() const { return content; } }; int main() { Box&lt;int&gt; intBox(42); Box&lt;std::string&gt; stringBox("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99a94fe6bbac67e2788e49ef4b082b4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430578236d2c265509d6a76a6a62acaf/" rel="bookmark">
			Python基础08-文件操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、文章目录 Python基础08-文件操作详解 1、文件操作概述 （1）文件是什么 内存中存放的数据在计算机关机后就会消失。要长久保存数据，就要使用硬盘、光盘、U 盘等设备。为了便于数据的管理和检索，引入了**“文件”**的概念。
一篇文章、一段视频、一个可执行程序，都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中的数据。一般来说，==文件可分为文本文件、视频文件、音频文件、图像文件、可执行文件等多种类别。
（2）文件有哪些操作 在日常生活中，文件操作主要包括打开、关闭、读、写、备份等操作。 （3）文件操作的作用 文件操作的作用就是把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力。简单来说就是实现数据的持久化保存！ 2、文件的基本操作 （1）文件的操作步骤 ① 打开文件② 读写文件③ 关闭文件 （2）open()打开函数 在Python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法：open(name, mode)
name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。mode：设置打开文件的模式(访问模式)：只读、写入、追加等。 文件路径：① 绝对路径 ② 相对路径
① 绝对路径：绝对路径表示绝对概念，一般都是从盘符开始，然后一级一级向下查找（不能越级），直到找到我们要访问的文件即可。② 相对路径：相对路径表示相对概念，不需要从盘符开始，首先需要找到一个参考点（就是Python文件本身） 同级关系：我们要访问的文件与Python代码处于同一个目录，平行关系，同级关系的访问可以使用./文件名称或者直接写文件名称即可上级关系：如果我们要访问的文件在当前Python代码的上一级目录，则我们可以通过../来访问上一级路径（如果是多级，也可以通过…/…/…/去一层一层向上访问下级关系：如果我们要访问的文件在与Python代码同级的某个文件夹中，则我们可以通过文件夹名称/来访问某个目录下的文件 （3）mode访问模式详解 （4）写操作快速入门 ''' 文件操作三步走：① 打开文件 ② 读写文件 ③ 关闭文件 ① 打开文件 =&gt; open(name, mode) name = 代表要打开的文件路径 + 名称 mode代表访问模式，只需要记住三种模式即可 =&gt; r/w/a r : read，只读模式，代表只能对文件进行读取，属于默认模式，如果要访问的文件不存在，则直接报错！ w : write，只写模式，代表只能对文件进行写入操作，如果访问的文件不存在，则系统会自动创建，但是写入文件时， 它首先要把文件内容清空，然后再写入新内容。 a : append，追加模式（只写模式的一种），与w类似，如果访问的文件不存在，也可以自动创建该文件。 但是在写入数据到文件时，其并不会清空文件的原有内容。 注意：open方法操作完成后，返回的是一个文件对象（对象的概念后面会学，也可以叫做文件句柄） 以后的读写都需要依赖这个对象（句柄） ② 写内容到文件 =&gt; f.write(content) =&gt; f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430578236d2c265509d6a76a6a62acaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea6aeb69468c483c25a08bd14b2b3098/" rel="bookmark">
			Python基础07-模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、文章目录 Python基础07-模块 1、模块是什么 Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。模块能定义函数，类和变量，模块里也能包含可执行的代码。 2、模块的分类 在Python中，模块通常可以分为两大类：内置模块(目前使用的) 和 自定义模块 3、模块的导入方式 （1）import模块名 基本语法：
import 模块名称 或 import 模块名称1, 模块名称2, ... 使用模块中封装好的方法：
模块名称.方法() 案例：使用import导入math模块
import math # 求数字9的平方根 = 3 print(math.sqrt(9)) （2）import 模块名 as 别名 在有些情况下，如导入的模块名称过长，建议使用as关键字对其重命名操作，以后在调用这个模块时，我们就可以使用别名进行操作。 import time as t # 调用方式 t.sleep(10) （3）from 模块名 import * 提问：已经有了import导入模块，为什么还需要使用from 模块名 import 功能名这样的导入方式？
答：import代表导入某个或多个模块中的所有功能，但是有些情况下，我们只希望使用这个模块下的某些方法，而不需要全部导入。这个时候就建议采用from 模块名 import 功能名
from 模块名 import * 导入这个导入方式代表导入这个模块的所有功能（等价于import 模块名）
（4）from 模块名 import 功能名（推荐） ''' 导入方式： from 模块名称 import * 代表导入这个模块中所有函数 from 模块名称 import 函数1, 函数2, 函数3 代表仅导入函数123 调用方式：不需要模块名称，直接使用函数名称即可 ''' # from math import * # 或 from math import sqrt, floor # 调用方式 print(sqrt(9)) print(floor(10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea6aeb69468c483c25a08bd14b2b3098/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c601ef9675ddf914de19e98e5beaccdf/" rel="bookmark">
			Python基础06-异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、文章目录 Python基础06-异常 1、异常的基本概念 （1）异常是什么 当检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的"异常"。 （2）异常演示 例如：除数为0异常（数学中，除法运算除数是不能为0的）。 # 1、除数为0异常（数学中，除法运算除数是不能为0的） print(10/0) 2、异常的捕获方法 （1）捕获常规异常 基本语法：
try: 可能发生错误的代码 except: 如果出现异常执行的代码 ''' 在Python中，我们可以通过try...except捕获异常 try: 可能出现异常的代码 except: 如果try语句中的代码出现了异常，则立即执行except缩进代码 优势：提高程序的健壮性 ''' num = int(input('请输入要进行除法运算的数字：')) try: result = 10 / num print(result) except: print('已经捕获到异常，执行B方案！') （2）捕获异常并输出错误信息 无论我们在except后面定义多少个异常类型，实际应用中，也可能会出现无法捕获的未知异常。这个时候，我们考虑使用Exception异常类型捕获可能遇到的所有未知异常： ''' 在实际工作中，不仅需要对异常进行捕获，还需要把异常信息写入到日志文件（具体是什么错误找到） try: 可能出现异常的代码 except Exception as e: print(e) # 代表出错的异常信息 =&gt; 实际工作以后，写入日志文件中 ''' try: f = open('python.txt', 'r') except Exception as e: print(f'-- 日志: {e} --') print('找到错误的同时，执行B方案！') （3）捕获指定异常 基本语法：如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。 try: print(name) except NameError: print('name变量名称未定义错误') （4）捕获多个异常 try: print(1/0) except (NameError, ZeroDivisionError): print('ZeroDivision错误.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c601ef9675ddf914de19e98e5beaccdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc8de3c38fb99c6133e8449b31e4fd0/" rel="bookmark">
			打包速度优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack打包耗时分析优化 如何分析 speed-measure-webpack-plugin
它分析 webpack 的总打包耗时以及每个 plugin 和 loader 的打包耗时，从而让我们对打包时间较长的部分进行针对性优化
使用时要注意它与 mini-css-extract-plugin 的版本兼容问题，容易报错
You forgot to add 'mini-css-extract-plugin' plugin ProgressPlugin
webpack5内置的插件 ProgressPlugin 不仅可以看打包进度，还可以分析打包时间，只要将profile设置为true
new ProgressPlugin({ profile: true, }) 优化方案 开启热模块替换 HotModuleReplacement（HMR/热更新）用于在运行时更新代码，而不需要进行完全的页面刷新或重新加载页面
webpack-dev-server搭配HotModuleReplacementPlugin 实现热更新
devServer: { hot: true, // 开启HMR功能 } 基本原理
1》当运行的时候，修改webpack.config.js的entry,插入两个runtime文件，一个用于与服务端进行通信websoket,另外一个用于模块的更新检查（监听文件变化）；启动http和websoket服务，进行编译
启动本地server，让浏览器可以请求本地的静态资源启动websocket服务，用于浏览器和本地node服务器进行通信 2》当用户访问页面时，浏览器会与服务端简历websocket连接；随后服务端向浏览器发送hash 和 ok ,用来通知浏览器当前最新编译版本的hash值和告诉浏览器拉取代码。同时服务端，会根据路由，将内存中的文件返回，此时浏览器保存hash,页面内容出现。
hash事件，更新最新一次打包后的 hash 值；ok事件，进行热更新检查 3》当修改本地代码时，会触发重新编译，并且（ webpackDevMiddleWare ）会将编译的产物保存到内存中，同时（ HotModuleReplacementPlugin ）会生成两个补丁包，这两个补丁包一个是用来告诉浏览器哪个chunk变更了，一个是用来告诉浏览器变更模块及内容。当重新编译完成，向浏览器发送hash 和 ok，浏览器收到后会执行module.hot.check进行模块热检查 ，向服务端获取两个补丁文件，进行更新
Include/Exclude 减小查找文件的范围，提高效率
{ test: /\.vue$/, use: ['thread-loader', 'vue-loader'], include: [path.resolve('src')], // 添加配置 exclude: /node_modules\/(?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc8de3c38fb99c6133e8449b31e4fd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c5a192fb3aa07ecfb162f3eaf4db99/" rel="bookmark">
			UWB物资标签物资追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UWB（Ultra-Wideband，超宽带）技术在物联网领域的应用日益广泛，其中，UWB物资标签作为其重要组成部分，在实现物资追踪、管理和定位方面发挥着关键作用。本文将详细介绍UWB物资标签的工作原理、特点、应用领域以及优势。
首先介绍其工作原理，UWB物资标签基于超宽带技术，通过发送短脉冲信号并测量信号的到达时间来实现高精度的定位。这种技术支持标签在复杂的环境中进行准确的位置测量，甚至在多径传播情况下也能取得良好的效果。标签通过与基站或其他标签进行通信，实时传输数据，从而实现对物资的全面监控。
UWB定位系统特点，1、高精度定位： UWB技术具有极高的定位精度，能够在几十厘米的范围内准确追踪物资位置。
2、实时通信： UWB物资标签支持快速的实时通信，使得物资状态能够及时更新。
3、低功耗： 大多数UWB物资标签采用低功耗设计，通过优化通信协议和硬件结构，延长标签的使用寿命。
4、抗干扰能力强： UWB技术对于信号干扰的抗性较强，适用于复杂的室内和工业环境。
应用领域介绍：物流和供应链管理： UWB物资标签可用于跟踪货物在整个供应链中的运输和存储过程，提高物流效率。在工业生产中，UWB标签可以用于追踪生产线上的物资和设备，提高生产效益，UWB物资标签可用于追踪医疗设备、药品和患者，提高医疗资源的利用效率。UWB技术在室内定位方面有独特优势，可用于实现室内导航、人员定位等应用。
UWB定位技术的优势介绍，1高精度： 提供亚米级别的高精度定位。2实时性： 可以实现快速的实时数据传输和更新。3标签支持： 支持同时追踪多个物资标签。4灵活性： 适用于各种不同环境和行业。
UWB物资标签通过其高精度的定位能力、实时通信特性和多领域的应用优势，成为物流、制造、医疗等领域的重要工具。随着技术的不断发展，UWB物资标签将在物联网应用中发挥越来越重要的作用，为各行各业提供更加智能和高效的物资管理解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ff91216b96cde0740b38a9de843e60/" rel="bookmark">
			2023年中国法拍房用户画像和数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		法拍房主要平台
法拍房主要平台有3家，分别是阿里、京东和北交互联平台。目前官方认定纳入网络司法拍卖的平台共有7家，其中阿里资产·司法拍卖平台的挂拍量最大。
阿里法拍房
阿里法拍房数据显示2017年，全国法拍房9000套；2018年，法拍房数量2万套；2019年，法拍房数量50万套；2020年，法拍房数量133万套；2021年，法拍房数量168万套。2021年6月之后，阿里拍卖便不再发布法拍房的月报或周报；
导入python代码即可绘制下图
import pandas as pd import matplotlib as plt 全国司法拍卖房
据统计，2023年1-9月全国司法拍卖房产市场挂拍量为373313套；成交量为107656套，成交率为28.84%，平均成交折扣率为80.19%。
与2022年1-9月相比，全国法拍房挂拍量同比增长13.44%，成交量同比增长11.28%，成交金额同比上涨1.79%，平均成交折扣率同比下降15.39个百分点。
2023年1-9月全国司法拍卖房产市场数据
成都法拍房数量最多
下图是法拍房数量最多的十个城市，成都位于榜首。
法拍房只是一个相对数量而已，我们做数据分析不要从一个数量指标去衡量好坏，最好用多个指标评估，特别是衍生变量效果最好。
例如成都人口2126.8万人，重庆人口3213.3万人，人口多，房屋也多，挂牌量自然也多。结合流拍率来分析，成都，郑州，南宁，昆明，贵阳，哈尔滨，沈阳流拍率非常高。流拍率高，挂牌量高，双高说明这些城市经济有很大隐患，或者是这些城市法拍法规不够完善，居民法拍有很大顾虑。
这些挂牌量高、且成交均价大多都不到1w/平的城市，流拍率基本都在60%。而且围观看热闹的居多，真正报名的人几乎没有。由此可见，当下的法拍市场倒是有点像二手市场。那些挂牌较少的高能级城市，即使成交价比较高但还是物以稀为贵，越贵越稀缺的，反而更能吸引人竞拍。
当然法拍数量多就不一定代表这个城市房子不值钱，还需要参考其他指标。如果法拍数量多，成交率低，那么这些城市房子就真的不值钱。
如上图，除郑州外，今年以来拿下法拍住宅挂牌前5的城市，全都集中在南方地区。前两名被川渝地区承包，并且成都还反超了重庆。说起来重庆也算是法拍界的老大哥了。2021年底，重庆法拍住宅挂拍量就突破了4万套，常年稳居全国第一。而曾经仅次于重庆的成都，如今单就法拍住宅来说，反而超过了重庆。或许也和当下的成都楼市有关。从债务关系来看，重庆和成都破产企业和家庭越来越多。
要知道法拍房的主要来源，其实就是债务纠纷。据最高法院统计，2023年1月，全国在审破产案件企业数2335个，其中浙江破产企业数量达391个。这样不难理解，为什么我们看到今年温州、杭州、宁波的法拍住宅挂牌量也都不低。
昆明法拍房数量激增
如下图最近法拍挂牌激增的昆明。在整个2022年，昆明共挂拍1.1万套，同比激增达161.9%。而在今年上半年，昆明的法拍市场住宅挂牌同样坐在了第5的位置。
上海法拍成交率最高，流拍率最低
首先我们先来看看，法拍成交率最高的是哪些城市：
法拍房成交率Top6排名的：上海、杭州、苏州，温州，北京，深圳。
比如排在第一位的上海成交均价在6.3w/平左右，价格遥遥领先其他城市，但是它的流拍率却是最低（成交率最高）。
成交折扣率在7折-9折之间的上海法拍住宅，占比最多，高达85%。
综合上图，上海、杭州、苏州，温州四个城市房屋置业是最保值的。最保值的老大哥非上海莫属，黄浦江可谓寸土寸金。
法拍法律执行情况
根据之情律师介绍，江浙沪的法拍房执行力度强、执行速度快，从诉讼到挂牌仅需4个月。长三角地区的法院严格执行腾退后再进行法拍，因此通常不会出现后续腾退执行难的情况。法拍房最大顾虑就是债务纠纷，用户买了法拍房也不一定住的进去。长三角地区的法院严格执行腾退后再进行法拍，这就免去买家后顾之忧。
兰州流拍率最高
下图可见法拍流失率最高的城市主要分布在西部，东北，西南地区。兰州法拍流失率有的夸张。
百度搜索了一下，兰州法拍流失率较低确实属实。
学区房价格下降
每到3、4月都是学区房成交的旺季，而今年学区房房价可不太乐观，就连上海对口明珠小学的最强学区房——朱家滩小区，也从15w/平的挂牌价，一路跌到成交均价在10w/平，跌超30%。
学区房市场的回落，也让不少人动了趁机捡漏的心思。
就比如同样也是杭州顶级学区房的中大文锦苑，曾经因为对口“学军小学本部+十三中”，早在2018年时，就曾卖出过15w/平的超级单价。
而最近接连成交两套法拍房，尤其是3月10日成交的一套97.04平的房源，折合起拍单价仅约5.82w/平。
如此性价比的价格，自然能引来10人报名，39次出价。
背后也和当下的楼市情绪相关。
上亿的豪宅、捡漏的学区房，为什么突然冒出来这么多法拍房源？
除了企业破产产生的债务纠纷外，现在的楼市走向也确实对法拍房数量上涨有一定刺激作用。
第一，应该是来自房价下跌的影响。
从数据来看，今年6月，二手房价下降城市有63个，创最多下调城市记录。
法拍的住宅增多
而最近有个不太一样的变化引起我注意的——拿出来法拍的住宅越来越多了。这意味着越来越多的家庭走向破产。房子在中国人心里不只是房子，而是一个温暖的家，一家人勒紧裤腰带也要还清房贷。只可惜离婚率居高不下，通货膨胀，电信诈骗疯狂肆虐，p2p暴雷，股市不景气，教育和医疗开支升高，可支配收入降低等多种因子正在推动住宅法拍房越来越多。
单从数量上说，2023年1-6月法拍房总挂牌量30.4万套，而其中住宅占比最高，高达59%，并且这样的趋势还在上涨。
居民扛不住，房子免费送？
国内还是有很多改善性住房需求。此外不久前我看到这样一则消息：房屋免费送，不要钱，首付别人已经付了，只需要把剩下几十年银行按揭贷款还了即可。
不少业主开始免费送房子，条件只有一个，接下剩余的房贷。
因为这位业主的这套房子购于2017年，包括28万元首付+90万元按揭贷款，面积69平，折合单价1.7w/平。
如今小区均价只要1.25w/平。
首付跌没了不说，房贷本金还剩80万。但小区同面积的挂牌价，有的已经低过80万了。
这样的房子继续还贷，其实就相当于纯粹亏钱。
此外，如今二手房的流动性正在走低。
根据研究院数据，全国50个重点城市的二手房成交周期已经延长到了65天。并且据上海证券报报道，现在购房者中大部分客户会把时间花在谈价格、谈成交周期上，市场成交率也只有20%至30%。
一方面房价在降低，另一方面房子还不好卖出去，或许这样的情绪下，自然也会让很多购房者失去继续还贷的动力。
当然，毕竟法拍房一直以来都算是一个特殊渠道，如果我们真的看到了较为优质的法拍房时，也需要警惕背后的债务纠纷问题。
上亿房源也在被拍卖
首先值得注意的是，今年不少上亿元的豪宅都开始挂牌法拍了。
就拿一线城市来说，我整理了今年部分1亿以上的法拍房：
不仅有很多大面积的上亿豪宅在法拍，甚至就这样的高价下，不少小区还能做到多套房源出售。
比如在上海，近期以1.58亿天价，刷新7月成交记录的绿城黄浦湾楼王。
这是一套高区江景大平层，在7月1日经过39轮出价，最终以较起拍价溢价26.4%成交，单价超34w/平。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ff91216b96cde0740b38a9de843e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557095551db5fca6878dfff6ca4e0622/" rel="bookmark">
			connect: Network is unreachable问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：查看ifcfg-ens33配置文件
cd /etc/sysconfig/network-scripts/
cat ifcfg-ens33
发现问题：GATEWAY写错成GATWAY
第二步：修改
vim ifcfg-ens33
第三步：检测是否成功
ping baidu.com
成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24102e0e71b48ed97de97d39459b594/" rel="bookmark">
			李宏毅机器学习第二十一周周报GAN理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 week21 Theory behind GAN摘要Abstract一、李宏毅机器学习——Theory behind GAN1. Generation2. 最大似然估计3. Generator3. Discriminator 二、文献阅读1. 题目2. abstract3. 网络架构3.1 Sequence Generative Adversarial Nets3.2 SeqGAN via Policy Gradient3.3 The Generative Model for Sequences3.4 The Discriminative Model for Sequences(CNN) 4. 文献解读4.1 Introduction4.2 创新点4.3 实验过程4.3.1 训练设置4.3.2 实验结果4.3.3 相关实验结果 4.4 结论 三、实验内容1. Pytorch实现CycleGAN1.1 任务概况1.2实验代码1.2.1 models1.2.2 datasets1.2.3 utils1.2.4 train1.2.5 test 2. SeqGAN2.1 生成器2.2 分辨器2.3 rollout2.4 target_lstm 小结参考文献 week21 Theory behind GAN 摘要 本文主要讨论了GAN的理论知识。本文介绍了在GAN模型之前用于处理生成式任务的最大似然估计。在此基础上，本文分别阐述了生成器与分辨器的原理以及训练目标最大化与JS散度的关系。其次本文展示了题为SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient的论文主要内容。这篇论文提出了SeqGAN，该模型补充了该网络在序列化数据处理领域的空白。该文在中国诗、奥巴马演讲、音乐等数据集上进行实验，从数据角度证明了该网络的优越性。最后，本文基于pytorch实现了CycleGAN并用于解决分类facades数据集的图像转换问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24102e0e71b48ed97de97d39459b594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a27f2aacd91f6bb2f0d3b03a4207f9/" rel="bookmark">
			图文—神经网络组成（卷积层、池化层、全链接层、激活函数）与发展史（LeNet、AlexNet、VGG、ResNet、GAN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 先有个全面的了解，再进行后面细节学习神经网络的组成单个神经元的构成卷积层池化层全连接层输出层损失函数四种激活函数 神经网络的发展Imagenet比赛1. 1998—LeNet-52. 2012—AlexNet3. 2013—OverFeat4. 2014—VGG5. 2015— ResNet6. 2018—GAN 生成式对抗网络6.1描述无聊，直接上项目7. DCGAN深度卷积生成对抗网络 说明：建议神经网络初学者食用。因为介绍的比较系统，所以文字很多，请耐心通读，相信你会有不同的收获。
先有个全面的了解，再进行后面细节学习 不同深度的网络学习不同的特征
神经网络的组成 单个神经元的构成 一个神经元接收多方输入的特征值（拟合神经元细胞），然后分别对特征值进行相应的加权求和，以及加上偏置量，最后通过非线性函数变换得到输出结果。多个简单的神经元之间相互连接就组成了一套完整的神经网络系统。
由于输入的特征包含许多干扰因素，所以我们将低维空间映射到高维空间，将线性不可变的部分变成线性可分（即激活函数的方式）降低干扰因素。为了降低无关因素所对应的权值和增大具有差异性特征的权值，我们根据输出结果计算误差，反向修改各个参数，尽量降低甚至排除无关因素或是噪音对识别结果造成的影响。
卷积层 卷积层：主要功能是对输入的图像进行特征提取和整合
卷积层的多少就会得到不同的特征
low/high-level feature map：即低阶/高阶特征。这是随着卷积网络的加深对不同深度的 feature map的取名。低阶特征可以理解为颜色、边缘等特征，就好比是一个图片中车的轮廓。 高阶特征可以理解为是更加抽象的特征，相当于更加细化的，比如说车中车轮，以及车轮中的车胎等。而通过卷积网络深度的增加，提取到的最后的高阶特征就是组成元素的基本组成单位：比如点、线、弧等。而最后的全连接层的目的其实就是进行这些高阶特征的特征组合。对于使用梯度下降，反向传播的描述
由于每次面对识别图像的不确定性，我们不能对参数进行指定性的初始化，只能采取随机生成的方式（梯度下降时，随机初始化参数）。同样，卷积核取多大值以及梯度下降算法选择怎样的起始点都是不确定的。要想修改参数，我们需要用 BP 算法不断进行反向迭代。伴随着迭代次数的不断增加梯度下降算法会逐渐减小，网络模型慢慢的达到最优化的状态，这也意味着一个高效的卷积神经网络就此生成了。因为神经网络每次训练的参数都是随机生成而不是指定的，产生最优网络模型时的迭代次数也不是一个定值，需要进行大量的实验，从而确定迭代次数的值使得网络模型性能最优。由于迭代次数是不确定的，这就给问题的解决带来很多障碍。 池化层 最大池化：其实就是降低维度，提取图像的主要特征纹理信息。
平均池化：取一个区域的平均值，用来保留图像的背景信息。
池化层（pooling layer）和卷积层之间是紧密相连的，一般卷积层之后会紧跟一个池化层。池化层的本质是一种形式的降采样，本身并不会改变三维矩阵的深度。池化层可以有效的缩减数据空间的大小，减小参数的运算量。最大池化层（max pooling）和平均池化层（average pooling）是常用的池化操作。池化层不仅可以加快计算速度而且可以防止过拟合。池化层的过滤器（卷积核）是需要人工进行设定的，我们需要人工设置过滤器的尺寸、移动的步长和填充方式等 。Pool1 选用的最大池化，可以减小卷积层参数误差所造成的估计均值的偏移，更多的保留纹理信息。经过多轮卷积之后，Pool5 中选用平均池化，可以减小领域大小受限造成的估计值方差增大，更多的保留图像的背景信息。
1优点++2存在问题++GAPGlobal Average Pooling
主要是用来解决全连接的问题，其主要是是将最后一层的特征图进行整张图的一个均值池化，每个通道压缩成一个实数（特征点），将这些特征点组成最后的特征向量，最后进行softmax中进行计算, 这样计算的话，也就是用GAP代替了原来的FC(红绿线压缩时会丢失空间信息),global average pooling层是没有参数的,可以减少过拟合，也可保留一定的空间信息。
虽然全连接层的删除使得模型变得更加稳定，但是却大大降低了收敛速度。
GAP和GMP—全局平均池化和全局最大池化
GAP和GMP都是将参数的数量进行缩减，这样一方面可以避免过拟合，另一方面这也更符合CNN的工作结构，把每个feature map和类别输出进行了关联，而不是feature map的整合直接和类别输出进行关联。
差别在于，GMP只取每个feature map中的最重要的region，这样会导致，一个feature map中哪怕只有一个region是和某个类相关的，这个feature map都会对最终的预测产生很大的影响。而GAP则是每个region都进行了考虑，这样可以保证不会被一两个很特殊的region干扰。 GAP1++GAP2++可能导致特征不稳定+GAP强《Learning Deep Features for Discriminative Localization》+2 全连接层 FC层：在进行信息整合的过程中，会丢失空间信息
C5 层和 F6 层都是全连接层，在样本空间中映射前面池化层和卷积层学习到的特征。全连接层的主要作用是将学到的“分布式特征表示”映射到样本标记空间。全连接层的神经元与其上一层的所有神经元进行全连接，全连接层在整个卷积神经网络整合最具有区分性的信息，整个网络模型中最后一层的全连接层的输出一般会被输入到 softmax 层对特征进行分类。我们可以将卷积层和池化层看成自动图像特征提取的过程。在特征提取完成之后，仍然需要使用全连接层来完成分类任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a27f2aacd91f6bb2f0d3b03a4207f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c3838a5d26259eb64b38ae003b80e6/" rel="bookmark">
			C#基础知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 课程一、C#基础1.C#编译环境、基础语法2.Winform-后续未学完 课程二、Timothy C#底层讲解一、类成员0常量1字段2属性（get、set决定属性私密性）3索引器5方法5.1值参数（创建副本，方法内对值的操作，不会影响原来变量的值）5.2引用参数（传的是地址，方法内对值的操作，出了方法后原来的值也被修改）5.3 输出参数(普通方法一次调用只产出一个返回值，但希望一次调用返回多个输出值，所以用输出参数)5.4 数组参数 parmas(可供函数输出多个值)5.5 具名参数(调用方法时，参数带有名字，位置随意)5.6 可选参数(方法定义声明时，有默认值)5.7 扩展方法(this参数) 二、委托1委托(c# Action,Func常规委托)2委托声明 （delegate自定义委托）3委托使用（把方法当做参数会给另一个方法：模板法，回调法）4委托高级使用（多播委托\异步委托调用） 二、委托v2三、事件1事件定义2事件应用（5要素）3事件自定义 四、类1构造器、析构器2.类修饰符（public\internal\abstract）3类的继承 五、接口、抽象类六、反射、依赖注入六、反射V2课程-Typeof七、泛型V1课程（这里代码多练习）7.1枚举和结构体类型 七、泛型V2课程7.1泛型类、泛型方法的申明与特化7.2泛型约束 八、其他知识点1.Marshal.SizeOf和sizeof的区别2.Var关键字3.lambda表达式（必须配合委托和事件）1.C#垃圾回收 八、核心代码汇总数据类型九、C#小功能1.将dataGridView1表格中的数据以BinaryWriter方式写到本地2.类库生成dll并导入使用3.动态链接库 vs 静态链接库4.dll隐式调用vs显式调用 课程一、C#基础 视频
1.C#编译环境、基础语法 F12查看函数被引用的地方，ctrl +减号 返回 F10，debug时的一步步调试 alt+s左键 选几行中的某些字段 calculator.repoort() 加括号表示调用方法 calculator.repoort 表示方法名
1.查看变量类型 Debug.WriteLine(array3.GetType().ToString()) 2.抛出异常 try { 可能会出现异常的代码块; } //try和catch之间不能有其它的代码 catch { 出现异常后要执行的代码块; } 3.查看两变量或对象是否是一个值？ Console.WriteLine{"{0}",stu.GetHashCode()}; 4.将文件中一个变量名统一修改成另外一个 对一个修改完后，按 ctrl+点 实现 5.类是典型的引用类型 6.Action action1 = new Action(stu1.dohomework); stu1.dohomework 是函数名 7.1.类中定义方法时，后面不用加; 只有执行的语句要加;2.stu1.dohomework()是方法的调用 stu1.dohomework 是函数名 public double Price { get; set; } Action action1 = new Action(stu1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c3838a5d26259eb64b38ae003b80e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d05071bf943cec113806dc17c295cc3/" rel="bookmark">
			C#实现访问OPC UA服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPC UA服务器支持三种认证方式，分别是匿名认证、用户认证和证书认证。其中匿名认证安全等级最低，访问不做任何校验。用户认证访问时，OPC UA客户端需要提供用户名及密码认证，只有用户名和密码正确才允许访问。
而证书认证，首先需要将客户端公钥证书提供给OPC UA服务器。然后客户端使用其公钥和私钥证书认证，认证成功后才能访问。
C#访问OPC UA服务器步骤如下：
1. 下载安装OPC UA服务器
OPC UA服务器下载及说明：EasyOPC
2. 连接OPC UA服务器
首先通过NuGet引入最新版OpcUaHelper。
匿名认证：
OpcUaClient opcUaClient = new OpcUaHelper.OpcUaClient(); opcUaClient.ConnectServer("opc.tcp://127.0.0.1:4840").Wait(); 用户认证：
OpcUaClient opcUaClient = new OpcUaHelper.OpcUaClient(); //用户及密码验证 opcUaClient.UserIdentity = new UserIdentity("test", "123456"); opcUaClient.ConnectServer("opc.tcp://127.0.0.1:4840").Wait(); 证书认证
3. 读取OPC UA节点
//读节点值 Double Temp = opcUaClient.ReadNode&lt;Double&gt;("ns=2;s=factory_1/line1/Temp"); 4. 写OPC UA节点
//写节点值 opcUaClient.WriteNode&lt;Double&gt;("ns=2;s=factory_1/line1/Temp", 10.20); 5. 订阅OPC UA节点
订阅节点值发生改变，就会执行订阅事件
//订阅节点，ns=2;s=factory_1/line1/Temp 节点值发生改变执行事件 opcUaClient.AddSubscription("temp_subscription", "ns=2;s=factory_1/line1/Temp", (string key, MonitoredItem item, MonitoredItemNotificationEventArgs eventArgs) =&gt; { var itemNotification = (MonitoredItemNotification)eventArgs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d05071bf943cec113806dc17c295cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd1e3492997bc375397313096a21227/" rel="bookmark">
			使用ps修改图片大小不影响清晰度的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ps修改图片大小不影响清晰度的方法
初衷-.-
已于 2022-03-27 12:51:51 修改
阅读量1w
收藏 7
点赞数 1
分类专栏： photoshop 文章标签： photoshop
版权
photoshop
专栏收录该内容
2 篇文章0 订阅
订阅专栏
提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录
使用ps修改证件照
一、分辨率应该怎么调
二、修改一寸证件照
1.导入图片
总结
使用ps修改证件照
提示：这里可以添加本文要记录的大概内容：
提示：以下是本篇文章正文内容，下面案例可供参考
一、分辨率应该怎么调
图片越大，分辨率越小
图片越小，分辨率越大
二、修改一寸证件照
1.导入图片
当前图片大小
如果直接更改图片大小和分辨率
1寸照片大小为2.5-3.5，分辨率为300
修改后为
对比图：下图为***没有转换为智能对象 *后，修改图片大小和分辨率效果图
图片明显变得模糊，
这里，我们应该先将**图片转换为智能对象 ***，再对图片大小和分辨率进行修改，我们会发现图片没有变得模糊。
对比图：下图为转换为智能对象后，修改图片大小和分辨率效果图
总结
再修改图片大小，并且不影响清晰度得情况下，我们可以先将图片转换为智能对象，再对图片进行修改，我们会发现图片在转换为智能对象后，不会影响清晰度。
————————————————
版权声明：本文为CSDN博主「初衷-.-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44110967/article/details/123770979
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac320347df42bd38240279675f7be21/" rel="bookmark">
			C#动态生成带参数的小程序二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景 在微信小程序管理后台，我们可以生成下载标准的小程序二维码，提供主程序入口功能。在实际应用开发中，小程序二维码是可以携带参数的，可以动态进行生成，如如下场景：
1、不同参数决定的显示界面不同。
2、不同参数决定的功能不同。
3、由于小程序审核机制，我们将不同的应用集成在一个小程序里，通过不同的参数进行入口控制。
关键代码 操作界面 我们以一种验证、绑定手机的小程序功能为例，该小程序可以生成动态校验码，以实现实际业务应用的其它场景。界面中我们设计了提示信息Label，生成按钮 Button 和扫码图片 Image 等Asp.net控件。
示例界面如下，通过点击按钮，动态生成二维码图片，该参数将引导用户进入动态码生成功能：
​​ 示例UI代码如下：
&lt;div class="user-box"&gt; &lt;span&gt;验证手机&lt;/span&gt;&lt;br&gt; &lt;br&gt; &lt;div class="query-box"&gt; &lt;label&gt; 扫描二维码获取动态校验码&lt;/label&gt; &lt;br&gt; &lt;label&gt; 建议您PC注册,如果微信,可常按并选择前往图中包含的小程序打开(某些手机系统可能不支持此操作)&lt;/label&gt;&lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;asp:Button ID="createCode" Text="新注册或换手机号点这里生成以获取动态校验码" Visible="true" CssClass="form-control" runat="server" OnClick="createCode_Click"&gt;&lt;/asp:Button&gt; &lt;/div&gt; &lt;div class="user-box" id="ecodepanel" align="center" visible="false" runat="server"&gt; &lt;br /&gt; &lt;asp:Image ID="ecode" Width="200px" Height="200px" Visible="false" runat="server"&gt;&lt;/asp:Image&gt; &lt;br&gt; &lt;span style='color: silver'&gt;&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;/div&gt; 服务端点击事件 点击按钮，通过设置参数值，并访问腾讯API，生成小程序二维码，转换为图片BASE64编码，如果生成成功则显示在Image控件里，点击事件的，示例代码如下：
protected void createCode_Click(object sender, EventArgs e) { string paras = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac320347df42bd38240279675f7be21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5f7ba07e7fa8589943bb9623a01f79/" rel="bookmark">
			SaaS行业分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是SaaS ?SaaS的标准定义什么是软件即服务？SaaS与传统软件的区别 ？ SaaS行业分析你知道最赚钱的行业是什么？互联网带给企业的变化 SaaS与PaaS、IaaS的区别？IaaS（Infrastructure as a Service）基础设施即服务Paas（Platform as a Service）平台即服务SaaS（Software as a Service）软件即服务 SaaS的分类TOC的SaaSTOB的SaaS SaaS的优势SaaS给企业带来什么好处？SaaS的主要特征 ？为什么大家喜欢SaaS ？ 什么是SaaS ? SaaS的标准定义 SaasS（Software as a Service ）
软件即服务 将软件部署在云端，通过订阅进行收费的商业模式
什么是软件即服务？ 例如：之前打车司机提供服务
现在打车通过滴滴打车，感觉像是滴滴提供服务，其实是司机提供服务，弱化司机提供服务，这就是软件即服务。
SaaS与传统软件的区别 ？ 传统软件 &gt; 下载本地运行
SasS软件 &gt; 浏览器访问使用 &gt; 每次都是最新版本&gt;卸载直接关闭
SaaS行业分析 你知道最赚钱的行业是什么？ 美国最赚钱的行业是saas
美国是SaaS产业发展的标杆市场
1999年以后成立的美国上市SaaS公司共有41家，其上市年份主要集中在2011-2018年；
每个领域均会出现多家上市公司；从成立到上市大约平均花费9年的时间（且呈现逐步缩短的趋势），上市是收入中位数在1.3亿美金；
中国最赚钱的行业是银行业
SaaS在中国市场存在着巨大的机会！
互联网带给企业的变化 随着OFO摩拜的结束，中国的互联网的上半场已经结束了（TOC）
互联网带给企业的变化是很少的（TOB）例如：企业怎么打车？企业怎样用携程订酒店？
TOB的SaaS在中国市场存在着巨大的机会！
SaaS与PaaS、IaaS的区别？ IaaS（Infrastructure as a Service）基础设施即服务 您好，我们已经为您准备好了所有您下厨需要的基础设施，您只需要提供食材等，并进行制作就可以了。
Paas（Platform as a Service）平台即服务 您好，我们已经为您准备好了所有您下厨需要的基础设施，以及您需要的各类食材和调味品，您只需要按照您的想法制作就可以了。
SaaS（Software as a Service）软件即服务 您好，请问您想吃点什么，我们很快给您送到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5f7ba07e7fa8589943bb9623a01f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ced481d9a19479652d62fc8a1640d5/" rel="bookmark">
			SQL学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【参考文献】
本·福达：《SQL必知必会》，第5版，刘晓霞、 钟鸣译，北京：人民邮电出版社，2020年
基本概念 DBMS：database management system（数据库管理系统）
提取信息 SELECT 多条 SQL 语句必须以分号（ ； ）分隔。 SQL 语句不区分大小写，因此 SELECT 与 select 是相同的 SQL 语句可以写成长长的一行，也可以分写在多行。 SELECT * FROM Products; 星号（*）通配符可以做到检索所有的列。 SQL应用案例：提取北宋政区 在CHGIS的数据中，需要提取北宋（960-1127）时期的政区。画分析草图，可以知道，如果按照Begin Year 和 End Year ( 用a b c d e f表示)作为筛选标准，一共有6种可能的情况，其中4种情况的年代符合北宋的时间区间。
b1&lt;960 and 960 &lt;b2 &lt; 1127
c1&lt;960 and 1127&lt;c2
960&lt;d1&lt;1127 and 960&lt;d2&lt;1127
960&lt;e1&lt;1127 and 1127&lt;e2
不符合的是：
a1&lt;a2&lt;960 （北宋前的政区）
1127&lt;f1&lt;f2 （北宋后的政区）
根据以上的分析，写如下SQL语句。
SELECT * FROM v6_time_pref_utf_wgs84 WHERE: ("BEG_YR" &lt;=960) AND (960 &lt;= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ced481d9a19479652d62fc8a1640d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82cedb076ce1d26bb853b23ea21d924/" rel="bookmark">
			ebay刷题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PASS区 组合验证二叉搜索树二叉树的层序遍历寻找旋转排序数组中的最小值二叉树的右视图岛屿数量课程表2二叉搜索树中第K小的元素设计一个支持增量操作的栈除自身以外数组的乘积腐烂的橘子绝对差不超过限制的最长连续子数组 PASS但非最优 旋转数组前 K 个高频元素 非PASS区 旋转图像字母异位词分组组合总和 Ⅳ二叉树中序遍历迭代法被围绕的区域加油站课程表O(1) 时间插入、删除和获取随机元素移掉K位数字从二叉搜索树到更大和树零钱兑换 II 二刷 旋转图像字母异位词分组 string可以转[]byte去sort/map可以用数组作key加油站 循环比较考验代码功底课程表 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2342ece73417ae03e3814a86d14948d3/" rel="bookmark">
			冗余备份网络——VRRP基本概念讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
VRRP作用
VRRP的基本概念
基本信息
VRRP版本
VRRP状态
VRRP主备切换
VRRP基本工作原理
VRRP报文
VRRP作用 VRRP为虚拟路由冗余协议（与之有类似作用的还有HSRP、GLBP等协议）
冗余备份组网——HSRP和GLBP协议-CSDN博客
VRRP通过将多个设备接口划分在一起，组成一个备份组（有主备关系---优先级高的为主）
备份组有一个虚拟IP地址来作为终端的网关地址（并且该虚拟IP地址有个虚拟MAC地址），终端在访问网络时通过虚拟的网关地址可以实现通过多个接口路径去访问网络，提高业务的可靠性；这一过程对终端来说是透明的，感知不到的
VRRP和HSRP的区别
主备设备的称呼不一样（VRRP的主设备为Master、备设备为Backup）VRRP使用的虚拟IP地址可以是虚拟IP地址，也可以是某个接口的物理IP地址；HSRP的虚拟IP地址不能是某个接口的物理IP地址HSRP每台设备都会发送Hello包，在VRRP中主备选举完成后，只有主设备才会发送VRRP报文（因此频率比较快）VRRP默认抢占是开启的VRRP报文发送的目的地址为224.0.0.18；HSRP目的地址为组播地址224.0.0.2 VRRP的基本概念 基本信息 基于IP协议112
目的IP：224.0.0.18
虚拟MAC地址： 0000-5E00-01{VRID}（主备的虚拟MAC是一致的）
虚拟MAC地址的作用
首先主备的虚拟网关IP地址是一样的，我们通过虚拟MAC可以使得主备设备关于虚拟网关地址有相同的MAC地址（即：当主备故障后，针对于用户主机来说，数据封装的MAC和IP地址都没有变化）
优先级
优先级0~255（缺省100）
255---虚拟地址拥有者，直接为Master（即-虚拟接口的IP地址和物理IP地址一样，那这个IP地址所属的设备就为该备份组的主设备）
0-------不参与选举。主备切换时，主发给备的报文中优先级会设置为0，让备切换为主设备
VRRP主设备退组时（即主删除VRRP的配置），发送VRRP报文，优先级为0；
当跟踪上行接口Down时，发送的VRRP报文优先级不为0
主备关系（备份组）
优先级高的为主；优先级相同，比较接口IP地址，IP地址大的为主
主备关系是针对VRRP备份组（vrid）来说的，并且是可以抢占的（缺省抢占开启）
同一设备，可能在备份组 1 中是主设备，也有可能在备份组 2 中是备设备；备份组的创建数量为1~255个
一个VRRP备份组中可以有多台VRRP设备，1个为主，其余为备
VRRP定时器
通告间隔定时器： 默认1s
超时定时器：超时时间等于（3*通告间隔）+偏移时间
偏移时间： 用来避免Master设备出现故障时，备份组中的多个Backup设备在同一时间同时转变为Master设备，导致备份组中存在多台Maste设备
V2版本的偏移时间等于（256-本地优先级）/256
V3版本的偏移时间等于（256-本地优先级）* VRRP通告间隔 / 256
抢占延迟定时器： 默认0s，进行主备切换时的延迟--一般建议调大一点
发送免费ARP报文时间间隔： 默认120s发送一次
VRRP认证方式
无认证方式： 对VRRP通告报文不进行任何认证处理
明文认证方式：将VRRP认证方式和认证字段填充到通告报文中发送给对端，收到的设备将报文的认证方式与填充字段与本端配置的认证方式和填充字段进行对比
MD5认证方式：将认证字段通过md5进行加密填充到通告报文中发送给对端，收到通告报文的设备会将认证方式和解密后的字段与本端配置的对比
VRRP版本 V2、V3
区别：
支持网络类型不同：V2只适用于IPV4，V3适用ipv6和ipv4
是否支持认证功能：V2支持认证，V3不支持认证
通告报文的时间间隔：V2支持的定时器是秒级，V3支持的是厘秒级
VRRP状态 Initalize：初始化状态（设备优先级为255，直接为master，其余情况都是先转为Backup再转为Master）
Master： 活动状态（定时发送Vrrp通告报文、以虚拟MAC地址响应对虚拟IP地址的ARP请求、转发目的MAC地址为虚拟MAC地址的IP报文）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2342ece73417ae03e3814a86d14948d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83c14ac4394806ed252b73954a75867e/" rel="bookmark">
			python 划分时间段的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dt.to_period 是 pandas 库中的一个函数，用于将时间戳数据转换为周期（Period）数据。周期数据是一种表示时间跨度的数据类型，可以表示年、季度、月份、周等。
import pandas as pd # 创建一个包含时间戳的 DataFrame df = pd.DataFrame({'date': ['2021-01-01', '2021-02-01', '2021-03-01']}) # 将时间戳列转换为年份周期 df['period年'] = pd.to_datetime(df['date']).dt.to_period('Y') df['period年月'] = pd.to_datetime(df['date']).dt.to_period('M') print(df) 结果：
就是他可以直接搞一个年月的时间段出来，感觉比dt.year和dt.month拿出来再拼起来。
它返回的格式也和dt.year不一样
使用 dt.year 方法得到的结果是一个整数的 Series 对象，表示每个日期的年份信息。使用 dt.to_period('Y') 方法得到的结果是一个 PeriodIndex 对象，其中的每个元素都是一个 Period 对象，表示每个日期所属的年份。 如果 data_csv['创建时间'] 列中包含了缺失值（NaN），则在计算年份时，缺失值会被视为 float 类型的特殊值。data_csv['创建时间'].dt.year 返回的结果是 float64 类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7987d8a23585d6d6481d8879f332bb/" rel="bookmark">
			python 将复杂日期格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原数据
A.D. 1996-Dec-20 03:59:19.0000 平常要将其转为%Y-%m-%d %H:%M:%S格式的时候，我会一步步提取，最后拼接。
现在使用pandas.to_datetime()直接进行格式化
import pandas as pd df['new_date'] = pd.to_datetime(df['old_date'], format=" A.D. %Y-%b-%d %H:%M:%S.%f") 看下效果
非常之好！！
还有一个参数errors='coerce'，它的的作用是将无法解析为日期时间的值转换为缺失值（NaT），而不是抛出错误。
如果想要在数据中找到没有转成功的数据行，可以用isna()判断
data_csv[data_csv['创建时间'].isna()] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e60832a3dc3d9bfd02469e863cec104/" rel="bookmark">
			注解 @Resource 与 @Autowired 比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
@Resource 注解
@Autowired 注解
功能对比
结论
@Resource 注解 @Resource注解是由JSR-250规范提出的，主要用于Java EE应用程序中。它可以用于字段、类型和方法，主要是通过名称来解析依赖关系。如果没有指定名称，那么将通过类型来自动注入。
@Autowired 注解 @Autowired注解是Spring框架特有的，主要用于自动装配Bean。它默认按类型进行依赖注入。如果有多个相同类型的Bean，可以结合@Qualifier注解来指定注入哪一个Bean。
功能对比 依赖解析方式：
@Resource默认通过名称进行解析，如果未指定名称，则通过类型进行匹配。@Autowired默认通过类型进行解析，当有多个相同类型的Bean时，可以通过@Qualifier指定具体的Bean。 所属规范：
@Resource来自于JSR-250规范，是Java标准的一部分，不依赖于Spring框架。@Autowired是Spring框架的一部分，与Spring框架紧密相关。 使用场景：
@Resource可以用在任何Java EE兼容的应用程序中。@Autowired主要用于Spring框架中的依赖注入。 结论 @Resource和@Autowired都是用于依赖注入的注解，但它们属于不同的规范和框架。@Resource注解更加通用，适用于任何遵循Java EE规范的环境，而@Autowired注解则是Spring框架中的特性，提供了更加灵活的依赖注入方式。开发者可以根据应用程序的具体需求和所使用的技术栈来选择合适的注解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c95e05146bb80723fc9ca1f58f9f4a9/" rel="bookmark">
			【k8s】--insecure-registry详解 ( 访问仓库、https、http)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、--insecure-registry是什么二、如何使用--insecure-registry三、--insecure-registry的安全风险四、--insecure-registry的替代方案五、总结参考 一、–insecure-registry是什么 --insecure-registry是docker中用来设置与docker registry通信的安全限制的一个参数，如果设置为true或1，意味着Docker将会在与这个registry通信时跨过证书问题，不再验证registry的TLS认证证书，可以忽略证书错误，从而绕过Docker安全机制。
这个描述很奇怪，https一般是服务器端开启的，客户端必须按照Https访问。除非docker服务器端同时开启了https、http，然后客户端默认禁用http，而--insecure-registry 允许本地开启http
这个参数的使用主要是为了方便在开发过程中迅速测试镜像，或者当运行docker的主机不具备安全加密能力的时候，可以选择打开这个开关。
在正式的生产环境中，一般情况下禁用这个选项，因为这个选项的打开为我们的系统带来很大的安全隐患。
二、如何使用–insecure-registry 使用–insecure-registry，我们可以在运行docker命令时添加这个参数。
docker run --rm --insecure-registry registry.local:5000 busybox 在上面的命令中，我们通过--insecure-registry参数指定了registry的地址为registry.local:5000，这意味着docker将会忽略registry.local:5000的SSL证书认证。
在Docker 1.13.1及之后的版本中，可以使用以下的方式来配置–insecure-registry的默认值：
{ "insecure-registries" : ["registry.local:5000"] } 这个配置文件需要保存为 /etc/docker/daemon.json。
需要注意的是，在Windows操作系统中，这个配置文件需要在C:\ProgramData\Docker\config目录下创建。
记得使用 service docker restart 重启docker服务
上述方法只能对单个服务器生效，如果想对所有的生效，可以使用 “insecure-registries” : [ “0.0.0.0/0” ] 三、–insecure-registry的安全风险 虽然使用--insecure-registry参数可以帮助我们快速测试镜像，但是打开这个选项也带来了很大的安全风险。
当我们忽略SSL证书时，意味着所有与该registry通信的数据都是明文传输，容易受到中间人攻击。黑客可以通过在通信过程中截取传输的数据，来获取敏感信息或者篡改数据。
同时，如果registry服务器本身被黑客攻击，会助长黑客利用中间人攻击的可能性，可以通过域名欺骗等方式进行攻击。
四、–insecure-registry的替代方案 如果我们有必要经常使用–insecure-registry，可以选择使用内部CA证书，将证书写入docker TLS认证证书池中，实现相对的安全性。这个过程需要创建自签名证书来为docker registry签名。
下面是一个创建自签名证书的例子：
openssl genrsa -out key.pem 2048 openssl req -new -key key.pem -out csr.pem openssl x509 -req -in csr.pem -signkey key.pem -out cert.crt 执行完上面的命令，会生成三个文件：key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c95e05146bb80723fc9ca1f58f9f4a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e224ed8bce6e5dab970df7d6fa87250d/" rel="bookmark">
			【C&#43;&#43;精品题目速刷】双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【C++精品题目速刷】双指针 一、移动零1、题目链接表述2、题目解析3、代码 二、复写零1、题目链接表述2、题目解析3、代码 三、快乐数1、题目链接表述2、题目解析3、代码 四、盛最多水的容器1、题目链接表述2、题目解析3、代码 五、查找总价格为目标值的两个商品1、题目链接表述2、题目解析3、代码 六、有效三角形的个数1、题目链接表述2、题目解析3、代码 七、三数之和1、题目链接表述2、题目解析3、代码 八、四数之和1、题目链接表述2、题目解析3、代码 一、移动零 1、题目链接表述 移动零
2、题目解析 我们直接利用样例进行解析：
指针1的dest先从-1开始，指针2的cur从0下标开始，每当cur所指向的数不为0的时候，则dest++并将dest和cur所指向的值进行交换，直到cur走到大于整个数组。
3、代码 二、复写零 1、题目链接表述 复写零
2、题目解析 用样例来进行解释：
特殊情况：
3、代码 三、快乐数 1、题目链接表述 快乐数
2、题目解析 只有如下两种情况：
为什么一定是有环的呢？我们通过鸽巢原理来进行解析一下：
利用快慢指针，找最后交点的环是不是1即可，是1的话就返回是快乐数，不是1的话就返回不是快乐数。
3、代码 四、盛最多水的容器 1、题目链接表述 盛最多水的容器
2、题目解析 所以我们用下面的值进行解析：
v中取最大值即可。
3、代码 五、查找总价格为目标值的两个商品 1、题目链接表述 查找总价格为目标target的数组
2、题目解析 3、代码 六、有效三角形的个数 1、题目链接表述 有效三角形的个数leetcode链接
2、题目解析 3、代码 七、三数之和 1、题目链接表述 三数之和leetcode链接
2、题目解析 主要思路为固定一个值，从左往右走这个值，再在每个固定值中进行双指针的操作，注意的点在于当找到相同的值的时候，此时我们需要去重操作，操作方法是要将重复的数指针往中间移动，并且要注意越界的行为，所以就需要我们继续在while中控制left&lt;right。
3、代码 八、四数之和 1、题目链接表述 四数之和leetcode链接
2、题目解析 3、代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6c185ef4aa02752d0b885aa2c9f035/" rel="bookmark">
			超详细的性能测试需求分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、客户方提出
客户方能提出明确的性能需求，说明对方很重视性能测试，这样的企业一般是金融、电信、银行、医疗器械等；他们一般对系统的性能要求非常高，对性能也非常了解。提出需求也比较明确。
曾经有一个银行项目，已经到最后的性能测试极端，因为数据库设计不合理，导致性能出现很大的问题，最终不得不把整合项目作废，对于这样的项目，其实从分析设计阶段就应该考虑系统的性能问题。性能测试也一样，对于某些项目来说越早进行越好。当然，前期的性能测试为单元性能测试、接口性能测试，有别系统性能测试。
有时候也会碰到不懂装懂的客户，提出一些无理的需求，比如只能2000人使用的OA系统，客户要求并发用户2000，这显然是不合理的需求。这个就要看你怎么给客户沟通了。但是，千万别伪造数据欺骗客户。
2、根据历史数据分析
对于一些面向用户的独特产品，比较难定位市场的大小，可以先上一运营一段时间，通过运营可以搜集客户资料，比如，每月、每星期、每天的峰值业务量是多少。用户以 什么样的速度在递增中。用户对系统的哪些功能模块使用的最多，他们所点的比例等等。
收集到这些数据之后，我们就可评估系统的系统需求指标，从而进行性能测试。
3、需求分析与定位
这里根据前期的需求分析与定位，来分析确定系统性能指标。例如某省幼儿园管理系统。统计全省有多少家幼儿园，系统的使用时间为幼儿到校之后，管理人员对幼儿的到校情况进行录入，以及幼儿的午饭，放学情况的录入时间。经过与需求人员交流分析也能得到比较明确的性能指标。
4、参考历史项目或其它同行业的项目
如果公司之前有类似的项目经验，根据项目大小及上次性能测试的一些指标。从根据项目的规模可以制定出相应的性能指标。
即使本公司没有类似的项目，但其它公司有类似的项目，例如做IPTV或者DVB计费系统的测试，可以参考电信计费系统的需求——虽然不能完全照搬数据，但是可以通过其他行业成熟的需求来了解需要测试的项目有哪些，应该考虑到的情况有哪些种。 5、参考其它资料数据
如果你做的是非常独特的产品，市场上没有此类型的产品，而且需求及市场也难以估计，那么只能从与产品相关的资料中寻找痕迹了。不过，相信这样不确定性的产品，老板要承担的风险也是挺大的。^_^
需要说明的是，我上面介绍的方面并非是独立的，可以综合的使用，你可以根据客户提出的指标，再根据历史数据以及参考同类型项目来进行。这样可以更确定你的性能指标是客户（或自己）真正需要的、最符合项目需求的。
在这我为大家准备了一份软件测试视频教程（含面试、接口、自动化、性能测试等），就在下方，需要的可以直接去观看，也可以直接【点击文末小卡片免费领取资料文档】
软件测试视频教程观看处：
Jmeter性能测试、接口自动化测试全集！字节大佬分享，永久白嫖！
性能测试点的选取
发生频率非常高的（例如：某邮箱核心业务系统中的登录、收发邮件等业务，它们在每天的业务总量中占到90%以上）关键程度非常高的（产品经理认为绝对不能出现问题的，如登录等）资源占用非常严重的（导致磁盘I/O非常大的，例如某个业务进行结果提交时需要向数十个表存取数据，或者一个查询提交请求时会检索出大量的数据记录） 对性能需求点的描述
准确 如**系统必须在不超过 10 秒的响应时间内,处理 20 起登录任务。再如发邮件时间最大不超过5秒以及平均时间在2秒以内。
一致 用户和性能测试工程师对有关术语的理解要一致，如：并发用户数、在线用户数、注册用户数：
特定 性能测试的需求一定是有条件的。
检查系统后台关键业务数据10G、操作数据量为20K, 1500 个用户、500 个并发用户运行的负载下，连续运行12小时过程中,业务操作是否满足性能需求。
常见性能需求
1、WEB首页打开速度5s以下，web登陆速度 15s以下。
2、邮件服务支持50万个在线用户
3、计费话单成功率达到99.999%以上。
4、在100个并发用户的高峰期，邮箱的基本功能，处理能力至少达到10TPS
5、系统能在高于实际系统运行压力1倍的情况下，稳定的运行12小时 6、这个系统能否支撑200万的vu（每天登录系统的人次） vu----Virtual user(虚拟用户) "不成文"的性能需求指标：　响应时间：根据国外的一些资料，一般操作的响应时间为2，5，8秒，2秒内优秀，5秒内良好，8秒内可接受，其它一些特殊的操作，如上传，下载可以依据用户体验的情况，延长响应时间。
Peter bickford 在调查用户反应时发现：在连续27次即使反馈之后，第28次操作进，计算机让用户等待2分钟，结果半数人在第8.5秒左右就走开或者按下种启键。使用了鼠标指针变成漏斗提示的界面会把用户的等待时间延长到20秒左右，使用动画的鼠标指针漏斗提示界面则会让用户的等待时间超过1分钟，而进度条则可以让用户等待到最后。Peter bickford的调查结果被广泛用到web软件系统的性能需求的响应时间定义中。
第三方研究表明，如果网页是逐步加载的，先出现横幅，再出现文字，最后出现图像。在这样的条件下，用户会忍受更长的等待时间，用户会把延迟在39秒内的也标识为“good”，超过56秒的才认为是“poor”的。
80/20原则：又称帕累托效应，比如，某一些系统一天中80%的访问量集中在20%的时间内。
如何根据性能需求进行测试
其实我们上面得到的需求指标仍然是不明确的：
是验证当前硬件和软件配置能否支撑200万vu？
是测试当前的硬件和软件配置最多能支撑多少vu?
是帮助开发寻找性能瓶颈？
根据需求进行性能测试的过程：
首先，请你们当前软件和硬件配置下验证能否支撑200万vu。如果可以支撑200万，再增加到300万看是否可以支撑。如果不能达到200万，那么就需要寻找一下是否有性能瓶颈，将主要的性能瓶颈解决后，再看一下是否可以支撑200万，如果可以支撑，输出测试结果。仍然不能，请评估需要添加多少硬件设备。
通过上面流程的分析，那么我们对于需求实施过程就非常明确了。
下面看来分析某邮箱系统的需求：
按照 某某 邮箱20000万注册用户，其中日活跃用户数为1.5%的规模计算：
日活跃用户=20000*1.5%=300万
日活跃用户人均每天发6封邮件，用户使用客户端收发邮件比例20%，则：
每天发邮件投递量=300万*6*20%=360万封
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b6c185ef4aa02752d0b885aa2c9f035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4917c3c65085e4bfb410a6dd157ccd0b/" rel="bookmark">
			springboot&#43;vue项目在国产机东方通部署详细教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、部署东方通TongWeb二、部署TongHttpServer三、springboot多模块后端打包四、vue前端打包（TongWeb部署）五、TongWeb部署（前后端一样） 一、部署东方通TongWeb 上传安装包：TongWeb7.0.4.9_Enterprise_Linux.tar.gz
解压：tar -xvf TongWeb7.0.4.9_Enterprise_Linux.tar.gz
证书：提供的license 文件是企业版的，企业版支持以 war 包方式部署应用。 解压后，将license.dat 放在安装的根目录下
进入bin目录启动：./startserverbg.sh
访问页面：http://ip:9060/console
ps：默认账号密码thanos/thanos123.com，首次登陆需要修改账号密码
二、部署TongHttpServer ps1：TongHttpServer实际上就是nginx在国产机上的替代品，除了名字意外，其他的原理跟nginx是一样的
pa2：nginx也可以直接部署在国产机上，且操作比部署linux上简单。即不需要安装gcc等插件，直接下载，解压，安装，编译即可！详情可见https://blog.csdn.net/weixin_40496191/article/details/121028500
由于我是拿linux验证的，国产机其实也差不多，我这里使用的安装包是：TongHttpServer_6.0.0.2_x86_64.tar.gz
解压：tar -xvf TongHttpServer_6.0.0.2_x86_64.tar.gz
将证书文件license.dat拷贝到TongHttpServer的解压文件夹里面
在THS/bin目录下，执行命令查看license信息：./start.sh -l
启动指令：./start.sh
停止指令：./start.sh stop
配置文件：/TongHttpServer/THS/conf/httpserver.conf
使用：跟nginx的使用方法一样。相关反向代理直接在httpserver.conf，然后重启TongHttpServer即可！
三、springboot多模块后端打包 需要改的配置
1）主要启动模块pom文件添加配置
&lt;packaging&gt;war&lt;/packaging&gt; 2）启动类添加SpringApplicationBuilder方法
@Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(WebApplication.class); } 剩下的就是解决bug
遇到的坑1：在filter过滤器引入变量的时候，使用@Value导致引入的变量都为null
ps：所有的filter类有涉及@Value的都要改，因为东方通中，filter加载在spring之前，都需要改成静态加载方式才能够读取到
public static String whiteUrl; @Value("${FormXssFilter.url}") public void setWhiteUrl(String whiteUrl) { FormXssFilter.whiteUrl=whiteUrl; } 遇到的坑2：遇到ZonedDate转换错误的，需要加下以下这个类
package com.ffcs.biyiict.config; import java.sql.*; import java.time.ZoneId; import java.time.ZonedDateTime; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4917c3c65085e4bfb410a6dd157ccd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0f9e2dadb399a02efb1a1ae1d08f1a/" rel="bookmark">
			Uniapp小程序通过camera组件实现视频拍摄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uni中可以通过调用api的方式去拍摄或者是选择相册的视频，但是在这里我们不采取这种方式，因为调用api的方式，必须跳转，而我们需要在页面中实现，下面看下具体步骤吧...
&lt;camera v-if="!srcUrl &amp;&amp; showCamera" device-position="back" flash="auto" binderror="onCameraError" style="width: 100%; height: 400rpx;"&gt;&lt;/camera&gt; &lt;video v-if="srcUrl" id="myVideo" :src="srcUrl" controls&gt;&lt;/video&gt; &lt;view @click="startShoot"&gt; 开始 &lt;/view&gt; &lt;view&gt; ------------------------------------------ ------------------------------------------ &lt;/view&gt; &lt;view @click="stopShoot"&gt; 结束 &lt;/view&gt; data() { return { cameraContext: null, showCamera: false, srcUrl: null, timer: null, totalSeconds: 0 }; } 接下来看下，怎么样实现拍摄
onReady() { this.cameraContext = uni.createCameraContext() } methods: { // 开始拍摄 startShoot() { this.totalSeconds = 0 this.showCamera = true this.cameraContext.startRecord({ timeoutCallback: () =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e0f9e2dadb399a02efb1a1ae1d08f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e6555c133e9b4e3260c4328d1e4c48/" rel="bookmark">
			Linux入门攻坚——8、磁盘管理——btrfs文件系统及压缩解压缩和归档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Btrfs（B-tree），支持CoW，写时复制；
核心特性：
多物理卷支持：btrfs可由多个底层物理卷组成：支持RAID,以联机添加、移除，修改
写时复制更新机制（CoW）：复制、更新及替换指针，而非“就地”更新；
数据及元数据校验码：checksum
子卷：sub_volume
快照：支持快照的快照；
透明压缩：
Centos6上默认没有安装。
centos7上：
使用btrfs --help可以查看帮助。
文件系统创建：
mkfs.btrfs
-L 'LABEL' ：
-d &lt;type&gt; ：raid0，raid1raid5，raid6，raid10，single
-m &lt;profile&gt;：raid0，raid1，raid5，raid6，raid10，single，dup
-O &lt;feature&gt;
-O list-all：列出支持的所有feature；
systemctl set-default multi-user.target 设置默认字符界面启动
不需要分区，直接将磁盘做成btrfs系统 ，添加三块磁盘：
直接格式化btrfs：
属性查看：
btrfs filesystem show
使用blkid查看：
UUID相同，说明都是同一个btree卷，但是子卷是不同的。所以btrfs支持多物理卷。
查看卷标：
挂载文件系统：
mount -t btrfs /dev/sdb MOUNT_POINT
挂载的设备可以是btr卷中的任意一个物理卷名，如这里的/dev/dec，也可以使用/dev/sdd，结果一样，mount显示的挂载设备是序列号最小的物理卷。
使用/dev/sdd挂载，结果一样：
透明压缩机制：
mount -o compress={lzo | zlib} DEVICE MOUNT_POINT
特性中多了compress=lzo。压缩解压缩是自动且对用户是透明的。
btrfs系统原生支持RAID。
直接联机修改大小：
btrfs filesystem resize [-|+]size MOUNT_POINT
使用max，直接调整到最大物理卷容量。
添加新的物理设备：
btrfs device add DEVICE MOUNT_POINT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e6555c133e9b4e3260c4328d1e4c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ee453a96e8c7a07fd25f0017da7200/" rel="bookmark">
			商用机器人，不好用是原罪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热潮褪去后，所有的问题都汇总成一个词，不好用。
从炙手可热到“大玩具”
一款产品好用与否，更多时候人们不会关心它先进的技术、工艺、用料，也不会考虑所谓的潮流趋势或前景，只会用最朴素的直观感受告诉你，好用或不好用。而此刻，商用机器人得到的评价是商场、超市中的“大玩具”。
从市场角度出发，商用机器人是被资本催熟的赛道，在市场规模狂飙的同时，没有人去关心其中有多少泡沫，但随着市场回归冷静，被刻意忽略的本质问题重新裸露出来，机器人并没有发挥出期待中的价值，较高的成本和较差的功能表现让它成为了一个鸡肋。
好用的标准是什么？
从商业本质来说，终端客户并不在乎机器人有多先进或有多潮流，他们在乎的是能否带来利益提升，在提升体验的同时做经济转化。因此，围绕这个目标，机器人好用与否的标准也就有了相应维度，如安全性能、使用便捷性、作业稳定性、成本等。而从市场反馈来看，不好用的原因也基本集中在环境适应能力差、部署维护麻烦、安全效果差几方面。
定位效果不稳定，精度低、易丢失，环境适应能力差，稍微变化便不可控。由于应用场景的多样化和复杂度不断提升，且不同场景有着独特性，对于机器人的要求也千差万别，这就需要机器人更加强大的适应性。目前商用机器人的导航方案大多为以激光雷达为核心，在水平方向发生环境变化时，会产生匹配丢失问题，算法的定位精度和稳定性也会受到动态物体的影响，同时这类方案不具备实时地图更新能力，这也是场景发生变化机器人便不可控的主要原因，由此也导致机器人作业效率不稳定。
部署维护麻烦，无法开机即用。机器人部署需要专门的现场部署工程师逐个区域进行SLAM建图、目标点标注、测试等专业操作，加上后续的培训，整个环节较为繁琐，需要花费一定的时间。部署顺利的情况下，商用机器人的部署最快也需要1.5个工作日。不过，由于现实情况更多复杂多样，受限于传统marker定位与激光定位的技术局限性，在空间大、吊顶高、光环境复杂的商场、超市等场景中，存在贴码成本高、高空间难贴码、改造空间布局等情况，且容易发生因环境变化定位失准的问题，从而大大延长部署时间，此外，后续一但场景的空间布局发生改变，机器人却不能实时自主更新地图，依然需要工程师重新部署，无论对于厂商还是终端用户，最终落地成本都较高。
安全性能差。一方面，目前机器人的技术方案主要是借助激光、ToF、结构光、双目等传感器采集场景内障碍物的点云信息，构建场景栅格地图，然后对障碍物进行避障，此类方案虽然能够满足机器人的避障需求，但也仅仅“刚刚能用”， 对传感器依赖严重，成本较高，对动静态、低矮、悬空障碍物不能全部有效检测，尤其最主流的激光雷达方案，由于激光雷达信息量丰富度不足，无法结合深度学习信息进行智能化升级，难以实现智能化避障，基本不具备主动安全能力。
另一方面，大多数机器人不具备缺乏完善的安全策略，整体系统联动性、可拓展性差，仅固定几种安全场景，单独场景单独处理，安全覆盖率低，导致整体安全性能表现不理想。
好用与否，需要解决根本原因
事实上可以看出，这些通病并不是泾渭分明，而是一个茎上开出的几朵花，导航技术是根本原因。作为国内头部机器人AI技术公司，INDEMIND见证并参与了机器人导航技术从弱到强的发展历程，对于这些技术通病有着深刻认知，并为此进行了长达5年的死磕。
与现有方案的技术路线不同，INDEMIND走的是视觉路线。自主研发的商用机器人导航方案「商用机器人AI Kit」，基于独有的立体视觉技术，采用以视觉传感器为主导的标准化、模块化的多传感器融合架构，通过遵循INDEMIND的标准定义接口，可快速加入IMU、里程计、激光雷达、GNSS等多种传感器，实现“积木式”加装，满足商用机器人导航定位、智能避障、路径规划、决策交互等核心功能的开发，能够广泛应用于商用清洁、酒店配送、送餐、巡检等商用服务机器人平台。
在功能表现上，基于视觉的多传感器融合SLAM，机器人支持全场景二维地图、三维地图及语义地图实时自主创建，支持地图动态更新及智能禁区，且建图精度可达厘米级，最大支持60000㎡，同时定位精度也达到厘米级，&lt;5cm（RMS）。在此基础上，机器人不再需要提前预部署，甚至不再需要工程师参与，已能实现实际意义上的无部署开机即用。搭载INDEMIND「商用机器人AI Kit」的机器人无需贴码，新设备，新场景，可开机即用，整体现场部署时间可减少80-90%。
安全方面，INDEMIND针对机器人安全问题开发了一套系统化的安全决策技术体系。在技术实现上，通过从传感器、识别算法、语义地图、策略执行4个层面出发，建立各单元联动机制，充分释放系统硬件潜力，显著提升了机器人的安全表现。
需要提到的是，INDEMIND基于设备端、云端智能决策平台、大数据平台三端专门建立的一套智能决策引擎，能够基于关键数据不断更新算法模型，持续提升场景处理和问题应对能力。借助微秒级的智能决策引擎，机器人能够稳定检测各类障碍物，支持低矮障碍物避障（地插、桌椅底座等）；高反障碍物避障（玻璃、镜面等）；全高障碍物避障（桌面、警戒线等），同时机器人还能够实时进行潜在风险判断（行人等），根据风险分类，提前做出规避策略，实现主动安全，保障机器人在复杂环境下安全运行。
此外，基于超过100个使用场景的海量数据，INDEMIND对于清洁、配送、导览、安防等多种工作场景有着深度理解，并基于此针对各类场景做了整体化策略（如扶梯识别及规避的安全策略、行人识别及规避的安全策略、玻璃场景识别及规避的安全策略、玻璃场景识别及规避的安全策略等），无需再根据不同场景做针对性处理，缩短安全决策流程，大大提升机器人的适应能力及作业效率。
对于任何产品而言，如果难以获得市场的长期认可，没有人会在意你的技术、工艺、用料，也不会在意你一时精心营销的潮流趋势，不好用就是原罪。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd20147f64e7dd723a5ef75c21d7515/" rel="bookmark">
			对比超融合与 “VMware &#43; FC SAN” 传统架构：4 大差异与 5 大优势（更新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超融合基础设施 (Hyperconverged Infrastructure) 已逐渐成为 IT 基础设施市场上的主流方案，并积累了越来越多的用户。很多企业已将超融合应用于各种业务场景，但由于超融合和原有架构差异较大，市场存在各种角度的观点和声音，许多用户提出如下疑问和顾虑：
为什么要上超融合？超融合与传统架构对比，最核心的区别到底是什么？超融合的价值把就是把所有功能都融合一起？超融合是基于服务器构建的，性能、可靠性是否足以支撑核心业务？听说超融合带来的好处就是便宜？采用超融合，IT 使用、维护甚至采购模式都有很大变化，是否真值得去“折腾”一回？ 以下通过详细的对比和分析，我们将解答超融合与传统架构的详细差异点，以及这种新型架构为何能在可靠性、性能、可扩展性和易管理性方面带来提升。
一、架构和资源管理模式对比 以 SmartX 超融合产品为例，先对比下超融合和传统架构的部署区别和资源管理模式区别。
图 1：传统架构和超融合的部署区别
图 2：传统架构和超融合的资源管理模式区别
相比传统 FC SAN 架构，超融合有了显著变化，我们总结了两者的 4 大差异：
不再使用专有的存储硬件和网络，而是使用标准和易于维护的服务器与万兆以太网交换机；核心是分布式存储，每个服务器就是一个存储控制器。需要说明的是，其中每个节点都需要配置 SSD 盘作为缓存，缓存容量远大于传统存储的易失性内存，且多节点并发带来更强的聚合性能。逻辑上看，存储不再是由 RAID 构成的不同存储空间，而是一个统一可弹性扩展的存储池，并且具备更强的扩展能力；分布式存储带来的另一个好处，是在统一的资源池内性能和容量都可以按需配置，而且数据可以自动均衡；计算虚拟化和存储部署于同一服务器节点。 二、分布式存储 + 虚拟化融合部署才是超融合本质 对于超融合，由于其独特的名称，使很多用户产生一种误解：超融合的核心在于融合，因此融合的功能越多越好。但通过以上架构对比我们看到，超融合的变革首先是分布式存储对传统存储的替代，其他更多优势（例如基于 x86 服务器构建、并发与易于扩展）都是这种替代带来的。
当然，分布式存储和虚拟化这种独有的部署模式，进一步简化了用户的 IT 架构，降低了使用成本和运维难度，这些价值也大大加速了用户对分布式存储模式的接受。
三、超融合会为 IT 基础设施带来哪些提升？为什么？ 通过不同产品的局部升级，超融合对 IT 基础设施带来的提升是全面的，以下将逐一解释。
1、有效提升可靠性 很多企业用户对于软件定义数据中心架构有一个常见疑惑：x86 服务器构建的系统可靠吗？虽然 x86 服务器本身存在单点故障，但超融合是以集群方式工作的；而且其核心分布式存储系统首先要解决的问题，就是利用多副本等技术，构建具备更高可靠性的大规模系统。这些技术都是构建软件定义数据中心的核心。
不仅如此，分布式存储相对比传统集中式存储在可靠性方面还有以下诸多优势，对比详情如下：
除此以外，SmartX、Nutanix、VMware 等厂商都提供了具备数据校验、机架感知、双活、异地备份等特性的企业级存储服务，以及和第三方产品整合的企业级高可用和数据保护解决方案。
2、并发性能大幅提升，I/O 延迟降低 以下以 SmartX 超融合软件 SMTX OS 介绍超融合如何提升性能并降低访问延迟。
其中，分布式架构提升了系统整体的聚合性能；SSD 缓存机制提升了单节点访问性能；I/O 本地化机制是超融合部署模式下才具备的优势，可以进一步降低访问延迟。需要注意的是，I/O 本地化主要是 SmartX、Nutanix 支持，基于 Ceph 等开源产品构建的超融合是不能支持的。
举一个具体的例子，由于双控成为瓶颈，HP 3PAR 8440 在 8 块 SSD 基本已经到达最大性能，但该读写性能仅使用 3 个 SmartX 超融合节点即可达到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd20147f64e7dd723a5ef75c21d7515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3797f30d1c536c545ff5a8c8266717b5/" rel="bookmark">
			React中简单实现路由守卫（主要演示其原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由守卫在后台管理系统两种经典的跳转情况：
如果访问的是登录页面， 并且有token， 跳转到首页 如果访问的不是登录页面，并且没有token， 跳转到登录页 其余的都可以正常放行 下面简单实现React路由守卫功能（代码比较简单，主要演示其原理）
具体代码如下：
import { useEffect } from 'react' import { useRoutes, useLocation,useNavigate } from "react-router-dom" import router from "./router" import { message } from "antd" // 去往登录页的组件 function ToLogin(){ const navigateTo = useNavigate() useEffect(()=&gt;{ navigateTo("/login"); message.warning("您还没有登录，请登录后再访问！"); },[]) return &lt;div&gt;&lt;/div&gt; } // 去往首页的组件 function ToPage1(){ const navigateTo = useNavigate() useEffect(()=&gt;{ navigateTo("/home"); message.warning("您已经登录过了！"); },[]) return &lt;div&gt;&lt;/div&gt; } // 手写封装路由守卫 function BeforeRouterEnter(){ const outlet = useRoutes(router); const location = useLocation() let token = localStorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3797f30d1c536c545ff5a8c8266717b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a235921cbddd0a4d09cd3597be6a27c2/" rel="bookmark">
			基于PyCharm实现串口GUI编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具效果如下如所示
下面简单介绍一下操作流程
1.打开PyCharm软件
2.创建一个工程
3.给该工程命名
4.在main.py里面黏贴如下的代码
# This is a sample Python script. # Press Shift+F10 to execute it or replace it with your code. # Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings. import serial import threading import time from tkinter import * from tkinter.ttk import * from tkinter import messagebox def open_serial(a,b,c,d,e): global ser print("串口号:",a) print("波特率:",int(b)) print("数据位:",c) print("停止位:",d) print("检验位:",e) bytesize = serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a235921cbddd0a4d09cd3597be6a27c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cab2616ab3861395b9c82d029191cd/" rel="bookmark">
			Wddm内存段翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自https://learn.microsoft.com/zh-cn/windows-hardware/drivers/display/handling-memory-segments,并加上自己理解 部分缩写
vidmm:video memory managerkmd：可以看作mini port driverumd:user model driver
WDDM Segment 创建 Segmentmemory segment和aperture segment（都为线性)memory segemntaperture segment分割memory-Space segment为bank将虚拟地址映射到内存段指定segment给DMA Buffer当创建allocation指定 segment 在vidmm可以管理GPU的地址空间之前，miniportDriver必须使用内存段向vidmm描述Gpu的地址空间(这里应该指的是PA),MiniPortDriver创建内存段以统一和抽象Video memory，驱动可以根据硬件支持的内存类中配置内存段，（例如帧缓存或者系统内存段）
​ 在驱动初始化期间，驱动一定要返回segment 类型列表，它描述了vidmm 如何管理内存资源，驱动指定它支持的段类型，并通过响应对其DxgkDdiQueryAdapterInfo的调用来描述每个类型，即使用DXGK_SEGMENTDESCRIRPTOR来描述每个段。
创建 Segment ​ 在DxgkDdiQueryAdapterInfo这个函数中，我们一般是使用 DXGKARG_QUERYADAPTERINFO 结构的 Type 成员来表示我们要表示的信息类型，而与memory segment相关的是DXGKQAITYPE_QUERYSEGMENT4。
​ 图形子系统调用驱动的DxgkDdiQueryAdapterInfo两次以获取segment信息，第一次将DXGK_QUERYSEGMENTOUT4的 pSegmentDescriptor 成员设置为 NULL ，用来检测驱动支持的segment数量，第二次则检索每个段的详细信息，即详细填充DXGK_QUERYSEGMENTOUT4的pSegmentDesciptor，一个segment对应一个pSegmentDesciptor，（PS：DXGK_QUERYSEGMENTOUT4填充在DXGKARG_QUERYADAPTERINFO的pOutputData里。同时在第二次调用时候，我们还应该为Paging buffer 分配内存，填充PagingBufferPrivateDataSize、PagingBufferSegmentId和PagingBufferSize，其中PagingBufferSegmentID必须是aperture segment。)
DXGK_SEGMENTDESCRIPTOR4的一些重要成员 Flags.Aperture：/*aperture segment还是memory segment，aperture segment没有保存allocation内容的物理页，当vidmm将allocation paging到memory segment中，mm就需要将分配的内容从system memory backing store 传输到segment位置，如果vidmm将allocation paging到aperture segment中，mm就需要将分配backing store 的物理页映射到这个segment中，如果指定了这个flag，还需要在DxgkDdiBuildPagingBuffer中实现map/unmap-aperture-segment。*/ Flags.CacheCoherent：//指示aperture segment是否可以与映射到aperture中的可缓存页面保持缓存一致性，对于memory segment没有意义 Flags.CpuVisible //对于aperture segment没有意义，标志memory segment是否能被CPU访问 Flags.PitchAlignment //指定一个allocation映射到segment中是否需要对齐，vidmm使用DXGK_ALLOCATIONINFO结构的Size成员来为分配一个back store给allocation，然而，vidmm使用PictchAlignedSize为段分配资源，这种通常back store和segment有不同的大小，这时驱动程序必须确定如何正确地移动分配中的数据。这种类型的段不能用于移除。 Flags.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1cab2616ab3861395b9c82d029191cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ecff4e30996f9037dcba45b32283100/" rel="bookmark">
			【K8S】docker打过tag标签后向镜像仓库推送镜像(push)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料1 首先，确保你已经登录到 Docker 仓库。可以使用以下命令登录到 Docker 仓库： docker login 2.然后，使用以下命令将本地的 Docker 镜像标记为指定的仓库和标签：
docker tag &lt;本地镜像名称&gt;:&lt;标签&gt; &lt;仓库地址&gt;/&lt;镜像名称&gt;:&lt;标签&gt; 例如，如果你的本地镜像名称是 my-image，仓库地址是 my-registry.com，镜像名称是 my-image，标签是 latest，则命令如下：
docker tag my-image my-registry.com/my-image:latest //本地镜像是latest，可以不带tag，会自动带上latest 想给本地镜像打tag，可以不带仓库地址；如果要想推送到仓库，就必须带仓库地址，因为后面的docker push 命令，会默认把 第一个斜线 前面的内容当做仓库，如果没有仓库地址，会带上默认的仓库地址，类似 “https://index.docker.io/v1” ，后果是这个地址要么不通，要么你上传到错误地方了
3.最后，使用以下命令将标记的镜像推送到指定的仓库：
docker push &lt;仓库地址&gt;/&lt;镜像名称&gt;:&lt;标签&gt; 例如，如果你的仓库地址是 my-registry.com，镜像名称是 my-image，标签是 latest，则命令如下：
docker push my-registry.com/my-image:latest 2. 资料2 推送镜像 在推送前，必须给镜像打标签，否则推送失败，其实打标签就是定义一个版本标识
我们看下未打标签推送的提示信息，其中swr:6666指向镜像仓库：
$ docker push swr:6666/ems/mytest:v2 The push refers to a repository [swr:6666/ems/mytest] An image does not exist locally with the tag: swr:6666/ems/mytest An image does not exist locally with the tag，此时不存在v2这个版本号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ecff4e30996f9037dcba45b32283100/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c79f7ffb43dab1e4a5917d330067de/" rel="bookmark">
			Linux系统进入单用户模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 系统进入单用户模式 文章目录 Linux 系统进入单用户模式前言一、CentOS操作系统进入单用户模式1.1 重启进入grub界面1.2 修改grub配置1.3 进入单用户模式 二、Debian操作系统进入单用户模式2.1 重启进入grub界面2.2 修改grub配置2.3 进入单用户模式 三、Ubuntu操作系统进入单用户模式3.1 重启进入grub界面3.2 修改grub配置3.3 进入单用户模式 总结 前言 在单用户模式下，您能修改系统的关键配置，因此建议您在必要场景中设置该模式，并谨慎操作。
Linux系统的单用户模式是系统启动方式之一，您可以通过Linux系统的系统引导器（GRUB）进入单用户模式。进入单用户模式后，操作者拥有系统管理员权限并能修改全部系统配置信息。该模式常用于以下场景：
修改系统密码排查启动故障修复系统异常维护硬盘分区 一、CentOS操作系统进入单用户模式 1.1 重启进入grub界面 运行reboot重启系统，并在重启过程中出现选择启动系统界面时按下键盘e键，跳转至启动项配置界面。
1.2 修改grub配置 使用键盘的方向键，移动光标至 linux 开头的一行，并在本行中将ro至末尾的内容替换为 rw init=/bin/sh crashkernel=auto 。
1.3 进入单用户模式 按下键盘的ctrl+x组合键或按F10键。系统会直接进入单用户模式。该模式下可以执行 以下操作修改root密码：
# passwd # ... # logout 二、Debian操作系统进入单用户模式 2.1 重启进入grub界面 运行reboot重启系统，并在重启过程中出现选择启动系统界面时按下键盘e键，跳转至启动项配置界面。
2.2 修改grub配置 使用键盘的方向键，移动光标至 linux 开头的一行，并在本行末尾添加 single 。
2.3 进入单用户模式 按下键盘的ctrl+x组合键或按F10键。系统会直接进入单用户模式。该模式下可以执行 以下操作修改root密码：
# passwd # ... # logout 三、Ubuntu操作系统进入单用户模式 3.1 重启进入grub界面 运行reboot重启系统，并在重启过程中出现选择启动系统界面时选择GRUB页面第二行的高级选项，并按下键盘的enter键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c79f7ffb43dab1e4a5917d330067de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26bc30c2d4d95b983663093dd6a4576/" rel="bookmark">
			Windows下ping IP&#43;端口的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种方法：
1. windows 开通 telnet 参考：
https://zhuanlan.zhihu.com/p/570982111
2. 安装插件 参考：Windows下ping IP+端口的方法
推荐使用第二种。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1321dc38f42245a644724b2121c1b3bc/" rel="bookmark">
			【Node】Express模块set、engine、all、use等常用接口解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Express用作node后端框架时，一般我们通过如下方式，在app.js中引入express模块
var app = express(); 引入完毕后，可以用app提供的各个接口引入各个中间件、路由配置、模板引擎等，在app上配置的参数都属于全局配置。接下来对常用的API做出介绍
一、app.all和app.use 1、app.use app.use可以为全局引入模块，比如app.use(cors())引入CORS模块允许跨域访问,app.use(cookieParser())引入cookie-parser模块后可以在请求响应中使用模块提供的便利的cookie处理、配置接口app.use为路径配置中间件或者处理程序，格式如app.use(path,[middleware/routerProcesser])。在app.js中，需要通过全局配置路径处理程序，来为接到的网络请求分配处理程序，处理程序一般使用express.router()模块，在routes文件夹下做出详细定义。app.use的执行顺序为书写顺序 2、app.all app.all属于路由处理器接口，它顾名思义，all是路由中指代所有的请求方式，如all('/a'),能同时覆盖：get('/a') 、post('/a')、 put('/a') 等。
常用的场景：
路径的任意方式，配置统一的响应头：
app.all('/*', function (req, res, next) { res.header("Access-Control-Allow-Origin", 'http://localhost:3000'); // 设置允许访问的域名 res.header("Access-Control-Allow-Headers", "X-Requested-With, Content-Type, withCredentials "); // 设置请求头格式和类型 res.header("Access-Control-Allow-Methods", "PUT, POST, GET, DELETE, OPTIONS"); // 允许支持的请求方式 res.header("Access-Control-Allow-Credentials", true); // 允许后端发送cookie next(); }); 3、两者的区别 功能定位不同：app.use偏中间件处理，app.all偏路径配置路径匹配方式不同：app.use实际匹配的路径（可接受的路径）是 use中定义的path+middleware中配置的路径；而app.all中对路径的接受采用严格匹配的方式，如果要多匹配，则需要设置通配符* 以下为例子： 二、app.set app.set()函数用于将设置名称分配给value。您可以存储所需的任何值，但可以使用某些名称来配置服务器的行为。
app.set(name, value) 常用场景：设置模板文件夹以及其模板引擎
app.set('views', __dirname + '/views')； app.set('view engine', 'jade')； 上面两行是设置views文件夹，即模板文件夹，__dirname是node.js里面的全局变量，即取得执行的js所在的路径，另外__dirname是目前执行的js文件名。所以，app.set(‘views’, __dirname + ‘/views’);是设置views的文件夹。
而app.set(‘view engine’, ‘jade’);是设置express.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1321dc38f42245a644724b2121c1b3bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21c78e28bc9f9798dce15311cd9f54b/" rel="bookmark">
			SpringBoot运维中的高级配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🙈作者简介：练习时长两年半的Java up主
🙉个人主页：程序员老茶
🙊 ps:点赞👍是免费的，却可以让写博客的作者开心好久好久😎
📚系列专栏：Java全栈，计算机系列（火速更新中）
💭 格言：种一棵树最好的时间是十年前，其次是现在
🏡动动小手，点个关注不迷路，感谢宝子们一键三连
目录 课程名：Java内容/作用：知识点/设计/实验/作业/练习学习：SpringBoot运维中的高级配置SpringBoot运维中的高级配置1. 临时属性设置1.1 属性加载优先级1.2 开发环境中使用临时属性 2. 配置文件分类3. 自定义配置文件 课程名：Java 内容/作用：知识点/设计/实验/作业/练习 学习：SpringBoot运维中的高级配置 SpringBoot运维中的高级配置 ​ 关于配置在之前讲过一部分，之前的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在后面的学习中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在实际开发实用中还有对应的配置高级知识要进行学习。
1. 临时属性设置 ​ 目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。
​ SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。
java –jar springboot.jar –-server.port=80 ​ 上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。
​ 如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。
java –jar springboot.jar –-server.port=80 --logging.level.root=debug 1.1 属性加载优先级 ​ 现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。
地址：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config
​ 我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。
​ 比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。
​ 看到小伙伴学习之前内容的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。
总结
使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性临时属性添加方式：java –jar 工程名.jar –-属性名=值多个临时属性之间使用空格分隔临时属性必须是当前boot工程支持的属性，否则设置无效 1.2 开发环境中使用临时属性 ​ 临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。
​ 打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。
​ 做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21c78e28bc9f9798dce15311cd9f54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad017efa6ac850396b7ab498e9879d65/" rel="bookmark">
			计算机网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常见协议汇总
在计算机网络中，不同协议之间存在着层次化的关系。下面是HTTP、TCP以及其他几种常见协议之间的关系：
HTTP（Hypertext Transfer Protocol）：HTTP 是应用层协议，用于在客户端和服务器之间传输超文本。
TCP（Transmission Control Protocol）：TCP 是传输层协议，负责提供可靠的、面向连接的数据传输服务。
IP（Internet Protocol）：IP 是网络层协议，用于在网络中实现主机之间的通信。TCP 协议依赖于 IP 协议进行数据包的传输。
Ethernet：Ethernet 是一种广泛使用的局域网技术，它定义了物理层和数据链路层的规范。TCP/IP 协议栈常用 Ethernet 作为物理层和数据链路层的实现。
DNS（Domain Name System）：DNS 是应用层协议，用于将域名转换为对应的 IP 地址。HTTP 请求在发送之前会通过 DNS 解析获取目标服务器的 IP 地址。
UDP（User Datagram Protocol）：UDP 是传输层协议，与 TCP 类似，但是不提供可靠性和流量控制机制。UDP 适用于实时传输和对传输可靠性要求较低的场景。
SSL/TLS（Secure Sockets Layer/Transport Layer Security）：SSL/TLS 是一种安全协议，用于在通信过程中加密数据。HTTP 可以通过 SSL/TLS 来建立安全的 HTTPS 连接。
这些协议之间存在层次化的关系。应用层协议（如 HTTP、DNS）依赖于传输层协议（如 TCP、UDP），而传输层协议依赖于网络层协议（如 IP）。同时，物理层和数据链路层的协议（如 Ethernet）提供了底层的物理连接和数据传输支持。通过这些协议的组合，实现了计算机网络中各个层次的功能和通信需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8434a47c8dbc31f4ab7ee0ead97ff96/" rel="bookmark">
			基于亚马逊云科技新功能：Amazon SageMaker Canvas无代码机器学习—以构建货物的交付状态检测模型实战为例深度剖析以突显其特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		授权说明：本篇文章授权活动官方亚马逊云科技文章转发、改写权，包括不限于在亚马逊云科技开发者社区、 知乎、自媒体平台、第三方开发者媒体等亚马逊云科技官方渠道。 目录 🚀一. Amazon SageMaker 🔎1.1 新功能发布：Amazon SageMaker Canvas 🔎1.2 Amazon SageMaker Canvas特点
🚀二.Amazon SageMaker Canvas无需代码生成准确的 ML 预测
🔎2.1 项目背景
🔎2.2 前期步骤
🦋2.3 导入数据集
🦋2.3 模型创建
🦋2.4 模型优化
🦋2.5 模型预测
🚀三.总结与心得
🔎3.1心得
🔎3.2 总结
🚀附录
亚马逊云科技2023 re:Invent全球大会是亚马逊云科技举办的一场技术盛会，旨在探讨云计算、大数据、人工智能等前沿技术趋势和应用场景。在大会上，亚马逊云科技将发布一系列新产品和新技术，以及针对不同行业和场景的解决方案，帮助客户更好地利用云计算和大数据技术，提升业务效率和创新能力。
各位读者大家好，我是一见已难忘。在本次大会中，亚马逊云科技发布 Amazon SageMaker 五项新功能，用于模型的扩展。今天我们就来深度体验学习一下Amazon SageMaker Canvas无需代码生成准确的 ML 预测，构建货物的交付状态检测模型，并且让其准确度在百分之80以上！
🚀一. Amazon SageMaker Amazon SageMaker是亚马逊云科技提供的一项机器学习（ML）服务。它旨在帮助开发人员和数据科学家轻松构建、训练和部署机器学习模型。SageMaker提供了一个端到端的机器学习平台，涵盖了从数据准备和模型训练到模型部署和推理的整个机器学习工作流程。
Amazon SageMaker 官网：Amazon SageMaker 机器学习_机器学习模型构建训练部署-亚马逊云科技云服务
🔎1.1 新功能发布：Amazon SageMaker Canvas Amazon SageMaker Canvas 是 Amazon SageMaker 的一项全新功能，让业务分析师能够使用可视化点击式界面创建准确的机器学习 (ML) 模型并生成预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8434a47c8dbc31f4ab7ee0ead97ff96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f484e86202fdd1188248cf3d63d9aa3/" rel="bookmark">
			网络基础试题选择题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择题 OSI模型中，表示层的作用是？
A) 数据链路B) 数据传输C) 数据格式转换D) 物理连接 IP地址的IPv4版本中，一般由几个十进制数构成？
A) 2B) 4C) 6D) 8 在HTTP协议中，常用的请求方法是？
A) GETB) POSTC) PUTD) DELETE 下列哪个协议用于安全的远程登录？
A) HTTPB) FTPC) SSHD) Telnet 在计算机网络中，常用的局域网技术是？
A) WANB) MANC) LAND) PAN DNS的作用是？
A) 网络拓扑发现B) IP地址转换C) 数据加密D) 文件传输 下列哪个协议是用于电子邮件传输的？
A) FTPB) SMTPC) DHCPD) SNMP 在TCP/IP协议中，IP层的作用是？
A) 数据封装B) 数据传输C) 数据路由D) 数据校验 以下哪个是用于网页浏览的协议？
A) FTPB) HTTPC) SNMPD) POP3 下列哪个设备常用于连接不同局域网的网络？
A) RouterB) SwitchC) HubD) Bridge HTTP状态码200表示？
A) 请求成功B) 未授权C) 服务器错误D) 页面未找到 在计算机网络中，什么是MAC地址？
A) 计算机的IP地址B) 计算机的物理地址C) 计算机的主机名D) 计算机的域名 下列哪个是网络层协议？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f484e86202fdd1188248cf3d63d9aa3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/30/">«</a>
	<span class="pagination__item pagination__item--current">31/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/32/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>