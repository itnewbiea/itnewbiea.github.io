<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea073cb1ab0df820948e0ef4264982f/" rel="bookmark">
			ApiFox 基本使用教程（浅尝辄止，非广）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述新建接口请求方法请求路径 &amp; 请求参数请求体请求头响应体 接口测试自动生成合适的测试数据保存测试用例 Mock 概述 官网：https://www.apifox.cn/
ApiFox 集 API 文档、API 调试、API Mock、API 自动化测试 功能于一体，
Apifox = Postman + Swagger + Mock + JMeter
新建接口 在一个接口中，ApiFox 允许你添加以下部分：
接口名称、分组、状态、责任人、服务、标签、说明请求方法（GET、POST、PATCH、PUT、DELETE、HEAD 等）请求路径（比如 /hello/world/{world_id}?offset=0&amp;limit=25）请求参数（Query 与 Path）请求体请求头CookieAuthSSL 设置、自动重定向响应结果（返回结果） 请求方法 ApiFox 支持定义 GET、POST、PUT、DELETE、OPTIONS、HEAD、PATCH、TRACE、CONNECT、COPY、LINK、UNLINK、PURGE、LOCK、UNLOCK、MKCOL、MOVE、PROPFIND、REPORT、VIEW 方法。
请求路径 &amp; 请求参数 请求路径中填写 ip:port 或 ip:port/project_name 之后的路径
在请求路径中，可以添加请求参数（Query Parameters）和路径参数（Path Parameters），例如 /hello/world/{world_id}?offset=0&amp;limit=25，其中的请求参数 offset、limit 与路径参数 world_id 都会在请求参数部分自动出现：
请求体 对于每个请求体中的字段，可以设置其数据类型、Mock 正则式、高级设置（如下图，可以设置默认值、枚举、数值范围等，可以通过编辑源码直接进行规则设置）：
请求头 可以对每个接口设置请求头字段
响应体 响应体的字段设置类似于请求体
接口测试 对于后端来说，其除了是接口文档外，还是接口测试工具（参考 Postman）。
自动生成合适的测试数据 我们可以像使用 Postman 一样在接口测试中添加 Params、Body、Headers 等测试数据，但是其强大在于我们可以根据在前文的「请求体」中设置的 Mock 正则、默认值、枚举等信息自动生成接口测试数据！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea073cb1ab0df820948e0ef4264982f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8624322a14afe7da477b0cc0b4f85a9/" rel="bookmark">
			Element Ui 级联选择器获取选中子节点的所有数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次写这种需求，花了两个小时时间，为了这个第一次做一个记录，如有更好的方法可评论告知 [抱拳]
这是要获取的数据，这是一个行业的选择，选中的结果是每一种行业的最后一级
需求就是图中所表达的，选中最后一级数据进行渲染，并且拿到最后一级的除了Value与Label的其他值
使用的是Element ui 中的级联选择器进行开发
HTML代码
使用options绑定我们的树形结构使用props属性配置所需要参数使用ref获取dom元素绑定change事件使用getCheckedNodes方法获取选中子节点的数据并进行赋值 js数据展示
js样式
可复制代码
html
&lt;el-form-item label="行业：" prop="industryCode"&gt; &lt;el-cascader v-model="ruleForm.industryCode" style="width:433px;" :show-all-levels="false" placeholder="请选择行业类型" :options="industryList" :props="defaultParams"&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; data
industryList: [], // 树形结构行业列表的所有数据 IndustryQualification: '', // 树形结构中的其他字段 defaultParams: { // 树形结构的展示字段 multiple: false, emitPath: false, label: 'industryName', value: 'industryCode', children: 'subIndustryList' }, js
handleChange (val) { let nodesInfo = this.$refs['cascader'].getCheckedNodes() console.log('nodesInfo&gt;&gt;&gt;&gt;&gt;', nodesInfo) // 获取选中的子节点的全部字段 this.IndustryQualification = nodesInfo[0].data.industryQualification // 获取子节点中想要的字段 }, getList () { // 查询行业列表 adIndustryList().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8624322a14afe7da477b0cc0b4f85a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ca763aa61fd9be86224a748a263280/" rel="bookmark">
			根据txt批量找出文件夹里面的图片python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据txt批量找出文件夹里面的图片python import re from PIL import Image import numpy as np import os data = [] path1 = r'G:\pachong\TEST_0526\2.txt' # txt文件路径 path_img1 = r'G:\pachong\TEST_0526\2' # 原图像文件路径 path_img2 = r'G:\pachong\TEST_0526\222' # 保存图像新路径 with open(path1, 'r') as fr: data = fr.readlines() # data = ''.join(data).strip('\n').splitlines() data = ''.join(data).split('/') data.sort(key=str, reverse=False) data_new = "/".join(set(data)).split('/') data = data_new # print("".join(set(data))) # ''.join() list转为str # s.strip(rm) 删除s中开头结尾处的rm字符 # .splitlines() 将字符串返回列表 # print(data) for name in data: # name1 = name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ca763aa61fd9be86224a748a263280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a8d6592395d87768e0487cbc29f6f2/" rel="bookmark">
			代码经验---java获取cpu个数-docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般在做多线程（cpu密集计算型的功能）的时候，会设置线程数，
（当然这里如果是io密集型的，一般会设置cpu的倍数，其实是有计算公式的，这里不考虑io密集型）
这个线程数一般会设置为硬件的核数，
如果虚拟机是8核，线程数就可以设置为8核。
那怎么获取核数呢？
Runtime.getRuntime().availableProcessors()
但是这个方法有一个问题，
如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数。
就是说比如我的虚拟机是8核，但是只给这个容器分了1核，
那这个方法还是拿的是8，那其实我这个容器是处理不过来的。
因此docker部署的话，还是建议手动设置一个值吧；
这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0eeceb97a0406c370d40fed93628c03/" rel="bookmark">
			由于缺少调试目标 E:a\b\c\串口配置工具\bin\Debug\串口配置工具.exe“,visual Studio无法开始调试。请生成项目并重试，或者相应OutputPath和AssemblyNa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做一个窗体程序时候出现这个错误
我的项目名称是串口配置工具，建议为英文来命名。
项目名称下面有这两个
发现
没有这个串口配置工具.exe
然后再这个
这里面发现这个串口配置工具.exe
最后直接.exe文件把这个复制到 项目名称/bin/Debug 下面
于是就可以正常点击编译调试项目了。
注意：记得在每次调试工程之后，把obj/debug目录下的工程的exe文件替换到bin/debug 目录下的工程的exe文件😂
或者直接修改项目输出路径
把它改成obj\debug\ 总的来说，这个问题还是输出路径的问题，你喜欢用哪种就用哪种。
觉得有帮助的，麻烦点赞支持一下吧！😄
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bcd241c618a385231ede124b2d7c317/" rel="bookmark">
			【rt-thread难点指南】以太网配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【rt-thread难点指南】以太网配置 本文以以太网口LAN8720A、MCU型号为stm32f407为例，介绍以太网配置步骤。如果有问题或建议，欢迎留言或邮件automationcarlo@163.com沟通。
一、cubemx配置 1.通过rt-studio打开cubemx 2.打开connectivity，选择ETH 3.选择mode为RMII 4.选择自己板子对应的引脚 具体引脚自己参考自己板子的原理图，这里以我的板子原理图为例。注意PD3为以太网接口复位引脚，这里先不对其进行配置。
修改Ethernet MAC Address 可以修改mac地址，这里保持默认。
保持默认
5.选择不要生成main() 6.生成代码 cubemx其余选项不用管，点击生成代码
二、rt-studio配置 1.点击确认，并编译 我们编译直接过了，你编译没过也不要紧，跟着步骤来就行/
2.配置board.h 按照英文提示去掉注释
/*-------------------------- ETH CONFIG BEGIN --------------------------*/ /** if you want to use eth you can use the following instructions. * * STEP 1, define macro related to the eth * such as BSP_USING_ETH * * STEP 2, copy your eth init function from stm32xxxx_hal_msp.c generated by stm32cubemx to the end if board.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bcd241c618a385231ede124b2d7c317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebec19aaa98912ed4921a792b628b1d4/" rel="bookmark">
			C&#43;17 新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;any&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; struct Point { int x; int y; }; Point func() { return {1, 2}; } template &lt;typename ... Ts&gt; auto sum(Ts ... ts) { return (ts + ...); } int main() { // c++17 类型自动推导 vector a = {1, 2, 3}; // 结构化绑定, pair, array, struct pair b(1, 2.3f); auto&amp;&amp; [i, j] = b; i = 2; cout &lt;&lt; b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebec19aaa98912ed4921a792b628b1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95710d395fcf9949b76bc0b336c57afd/" rel="bookmark">
			element UI 表格做下滑滚动效果，请求接口数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		element UI 表格做下滑滚动效果，请求接口数据，内容记录
import { ElMessage } from "element-plus"; // vue3.0 引入方式 // 定义横向滚动条的初始值 let arr = [0]; // 表格无限滚动加载 const InfiniteScroll = function(fn, obj , cls, index) { let table_body = document.getElementsByClassName(cls)[index]; table_body.addEventListener("scroll", () =&gt; { arr.push(table_body.scrollLeft); if(arr[arr.length-1] != arr[arr.length-2]) { arr = [arr[arr.length-1]]; return; } else { arr = [arr[arr.length-1]]; }; const scrollDistance = table_body.scrollHeight - table_body.scrollTop - table_body.clientHeight; if(scrollDistance &lt;= 0) { if(!obj.loading) { obj.loading = true; obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95710d395fcf9949b76bc0b336c57afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afceb651bd5bf3beefa96c7707a94fe/" rel="bookmark">
			现在都在考华为认证，含金量高不高呢？该如何备考？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.证书的含金量 (1)华为认证是厂商认证的，你拿到了这个证书进某些大厂是更容易的，毕竟是认可这个证书的，这个含金量肯定高呀。
点击进入一起分享交流https://jq.qq.com/?_wv=1027&amp;k=PRePdt85
(2)华为认证是华为很多年数字人才培养经验和对ICT行业发展的深刻理解，其中包含了三个不同认证初级工程师(HCIA)高级工程师(HCIP)和专家(HCIE)。
华为认证HCIP HCIE交流群：751160076 ​(3)拿到华为认证后，你可以从事的工作岗位有很多。比如高级网络工程师，系统集成工程师，云计算运维工程师等。
(4)还能提高你的竞争力。我们通常说的持证上岗，不论是什么证书，在一定程度上都能起到提高就业竞争力的作用。试想一下，两个具有工作经验、业务水平等的人，一个有证书一个没有证书，HR会选择谁？
2.如何备考？ (1)首先找好你想备考的方向，是考HCIP还是HCIE。
(2)然后选择是自学还是报培训班学， 我是推荐你去报培训班学习的这样省事。 首先聊自学 1.自学需要制定好计划，做好充足的准备。而且自学需要有恒心和毅力，有自控能力和自律性。2、自学要目标准确不能三分钟热度，看书几分钟就去打游戏看电视去了。自学考验的是你自己的自控能力。如果你不能达到以上的条件，劝你还是放弃自学。
华为认证HCIP HCIE交流群：751160076 (3)咱们来聊报培训班，报培训班学习首先能省下你大量找资料，找考试大纲的时间。因为一般培训班的老师都给你准备好了。 然后老师还能给你制定好学习计划，从那个方向出发都给你安排好了，这样你就能专注于学习，遇到难题或者疑问也有老师给你解答。 但是报培训班的话是要付出一小笔金钱的，这就要看个人舍不舍得这笔钱了。毕竟能少走很多弯路学习的更快。
​3.报名流程 (1)注册华为账号
(2)进入华为人才在线网站
(3)点击考试预约-Pearson VUE考试预约
(4)选择你要考的考试科目
(5)选择你想要去参加考试的考场
(6)最后就是支付考试费用啦
(7)去线下考试记得带好两种证件一类：身份证，驾驶证，护照。二类：信用卡，学生证，工作证。
证件搭配需符合：一类证件+一类证件或一类证件+二类证件
最好是提前15分钟到达。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08c9a707052285980cac1ad4d423732/" rel="bookmark">
			vue项目访问服务器时：WebSocket connection to ‘wss://XXXX/‘的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于WebSocke的介绍：新手入门：websocket
简单来说，WebSocket 为web应用程序客户端和服务端之间（客户端服务端）提供了一种全双工通信机制，报错是因为发送报文的过程出现问题。
我的报错如下：
程序可以正常运行使用，但一直打印报错太难受了，问了一下同事，也查了一下（百度）。
我的想法：服务器地址通过nginx代理访问，所以要么就解决Nginx通过在客户端和后端服务器之间的通信问题，要么就直接让我的前端不给后端发送信息。
解决方式：
1、修改nginx配置：
location /api/ { proxy_pass http://test.com; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; } 2、修改vue项目中的WebsocketMixin.js文件，注释初始化方法
以上是我今天偶然遇到的问题和解决方法，记录一下，如果有错误的地方欢迎指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10758edc623721540a05346997f0adb8/" rel="bookmark">
			Linux C/C&#43;&#43;面试题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux C/C++面试题汇总 前言计算机基础程序的内存空间进程和线程相关 关键字conststaticvolatile C/C++指针 前言 最近面试的比较多，看了很多关于面试的内容，有些平时工作用的比较少或者没有主要到的地方，长时间不看就会忘记，如果下次面试还需要再次找这些东西比较麻烦，所以写此篇文章就是为了方便以后面试，也给一些即将面试的人提供一些帮助。以后如果面试有新的值得关注的问题作者会及时更新。
计算机基础 程序的内存空间 堆栈段（stack）：
由编译器自动分配和释放，存放函数的参数和局部变量。操作方式类似于数据结构中的栈。
堆（heap）：
由程序员分配和释放。如果程序员没有释放，在程序结束时由操作系统释放。堆得操作方式和数据结构中的堆不同，堆空间的操作方式类似于链表。
BSS：
存放未初始化的全局变量和static静态变量。
数据段（data）：
存放初始化之后的全局变量和static静态变量
代码段：
以二进制格式存放程序和函数主体。
进程和线程相关 进程有独立的地址空间，是资源分配的最小单位。线程没有独立的地址空间，是系统调度的最小单位（执行运算的最小单位）。一个程序最少有一个进程，一个进程最少有一个线程。线程的崩溃基本上会导致进程的崩溃，所以多进程比多线程的程序健壮性更好 ，多线程开销小，效率高，但是不便于资源的保护和管理。多进程相反进程有独立的内存，多线程共享这个进程的内存，所以多线程编程极大的提高了程序的运行效率，在多核CPU的系统中多线程可以充分利用CPU多核运算的能力。 关键字 在面试中经常会背问道关键字，如果能答出关键字的所有功能会加分。
const const关键字最常被问道的功能就是以下几点：
必须被初始化const修饰的变量只能被读不能修改修饰指针变量时到底是指针变量不可被修改还是指针所指向的内容不可被修改const修饰成员函数只能调用const成员函数和修改mutable（mutable 是为了突破 const 的限制而设置的）修饰的成员变量，不可以修改普通成员变量 static static关键字最常被问道的功能就是以下几点：
static变量存储在数据段中，如果没有显示初始化会被自动初始化为0static修饰局部变量变量只初始化一次，在程序结束时候才释放static限制内容的作用域，static修饰的全局变量和函数本文件可见，考虑到程序的安全性如果程序中使用全局变量应该优先使用staticstatic修饰的成员函数和成员变量不new也可以使用（类名.变量名或者类名.方法名），所有该类的对象共有的。类的静态成员可以不可以使用类的非静态成员，而类的非静态成员可以使用类的静态成员。静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。非静态成员函数有 this 指针，而静态成员函数没有 this 指针。 volatile volatile关键字修饰的变量告诉编译器不要堆该变量进行编译优化，因为随时可能出现变化，如果要对该变量进行操作要从内存中获取改变量的值而不是从寄存器中获取该变量的值。
C/C++ 指针 用变量 a 给出下面的定义
a) 一个整型数（An integer）
b)一个指向整型数的指针（ A pointer to an integer）
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to
an intege）r
d)一个有 10 个整型数的数组（ An array of 10 integers）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10758edc623721540a05346997f0adb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792d9aa456b485f76e87e88260c8d6d9/" rel="bookmark">
			Hive行列转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多行转多列 姓名(name)学科(subject)成绩(score)A语文70A数学80A英语90B语文75B数学85B英语95 行列转换思路分析及实现
多行转多列
如果需要将上⾯的样例表转换为
姓名 | 语⽂成绩 | 数学成绩 | 英语成绩
这样的格式，就是 多行转多列
思路：
涉及到行转成列，肯定是会按照某⼀列或者某⼏列的值进⾏分组来压缩⾏数，所以会⽤到group by。
分组之后需要⽤到聚合函数，由于多列中的每列只关⼼⾃⼰对应的数据，所以要使⽤case语句进⾏选择，⾄于聚合函数，只要数据能保证唯一性，max、min、avg(数值类型)等都可以
样例SQL
select name ,max(case subject when '数学' then score else 0 end) math ,max(case subject when '英语' then score else 0 end) english ,max(case subject when '语文' then score else 0 end) chinese from ts group by name; 输出过程
namechinesemathenglishAmax(70,0,0)max(80,0,0)max(90,0,0)Bmax(75,0,0)max(85,0,0)max(95,0,0) 输出结果
namechinesemathenglishA708090B758595 2.多列转多行 将上⾯⾏转多列的结果再转回成原始表结构的过程，就是多列转⾏
思路
列转⾏，会涉及到⾏数的增加，所以会⽤到UDTF(一进多出)，⽽UDTF只是针对某⼀列的，要把这列扩展后⽣成的多⾏数据和源表中的各列拼接在⼀起，需要⽤到lateral view语法；
需要将多列⾥各列的列名（业务含义），在新数据中当做⼀个标识列，⽽与lateral view联合使⽤的explode函数是⽀持Map类型的，所以要先将原表⾥的多列变换成Map类型的⼀列，然后再⽤lateral view拆开。
样例SQL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792d9aa456b485f76e87e88260c8d6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e6f537f8c997d5a2a229dab22dbd99/" rel="bookmark">
			Electron.NET开发入门（Linux &amp;&amp; Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先决条件 使用Electron.NET进行开发，不论是在Windows系统下，还是在Linux系统下，确保计算机已安装：
Node.jsNPMdotnet CLI Electron.NET 全局工具： ElectronNET.CLI.NET 5.0以上的SDK Windows系统下环境搭建 操作系统及IDE Windows 7及以上，X86/X64架构的即可。
IDE使用的是 Visual Studio 2019
安装步骤 Node.js及npm的安装 下载地址 选择与自己电脑对应的(32位/64位)Windows安装包(.msi)下载即可，一般默认选择的是最新版本。下载完成之后 双击 .msi 文件，运行，一路next下去，直到安装完成。
检测是否安装成功 win+r 输入cmd 打开命令行，输入node -v查看是否安装成功，输入npm -v查看集成的 npm是否正确安装。如果命令都输出对应的版本号，如下图，表示安装成功了。如果提示系统未识别的指令，则将node.exe文件所在路径添加到系统的环境变量中。
基本设置 下载npm的原因是通过他去下载功能丰富的各种组件，npm的全局模块和缓存模块默认是在C盘，为了便于管理，我们需要新建两个文件夹 ：node_global(全局模块)和node_cache(缓存模块)。 这里注意两个文件夹的名字必须是这个，否则后期可能会报错。同样是在命令行窗口中设置npm的全局模块和缓存模块。
C:\Users\Administrator&gt;npm config set prefix "创建的node_global文件夹所在路径" #设置全局模块 ​ C:\Users\Administrator&gt;npm config set cache "创建的node_cache文件夹所在路径" #设置缓存模块 ​ C:\Users\Administrator&gt;npm config get prefix #查看全局模块所在路径 ​ C:\Users\Administrator&gt;npm config get cache #查看缓存模块所在路径 npm镜像源设置 npm的下载源默认是一个国外的网站，下载速度比较慢.为了提高下载速度。解决方案之一是 将下载源设置成淘宝源。另一种方式使用cnpm下载。设置npm源的几种方式
# the original source https://registry.npmjs.org/ ​ npm config set registry https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70e6f537f8c997d5a2a229dab22dbd99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bcf5034b62d74798e92afc38862ba2a/" rel="bookmark">
			理解Nodejs的单线程实现高并发原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组成和架构 Nodejs 的特点是事件驱动、非阻塞I/O、高效、轻量。
我们首先看下 Nodejs 的架构。
最上层的是 Nodejs标准库，由JavaScript实现的api库，位置在 lib 目录。
然后是 Node bindings，JavaScript 和 C/C++ 之间通信和交换数据的桥梁，实现于 node.cc。
最下层是由 C/C++ 实现：
1. V8 解析引擎，为 Javascript 提供了在非浏览器端运行的环境；
2. Libuv为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力。
3. C-ares提供了异步处理 DNS 相关的能力
4. http_parser、OpenSSL、zli 等，提供包括 http 解析、SSL、数据压缩等能力。
比如，使用 Nodejs标准库与操作系统交互。
编写JavaScript代码：
import fs from 'fs'; fs.open('./test.txt', "w", function(err, fd) { //..do something }); 当我们调用 fs.open 时：
/** lib/fs.js */ async function open(path, flags, mode) { mode = modeNum(mode, 0o666); path = getPathFromURL(path); validatePath(path); validateUint32(mode, 'mode'); return new FileHandle( await binding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bcf5034b62d74798e92afc38862ba2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdc16850aee3020da43406539e6c79f/" rel="bookmark">
			Java Socket聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Socket聊天室 1 创建登录判断类UserLogin2 创建登录服务器LoginServer3 创建聊天服务器ChatServer4 创建客户端Client5 创建服务器用于处理聊天的线程类ChatThread6 创建客户端Client用于发送消息的线程类WriteThread7 创建客户端Client用于接收消息的线程类ReadThread8 测试8.1 登录8.2 群聊8.2 单聊 1 创建登录判断类UserLogin import java.util.HashSet; import java.util.Set; public class UserLogin { public static boolean login(String username) { Set&lt;String&gt; set = initUser(); // set中含有该username则登录成功 return set.contains(username); } public static Set&lt;String&gt; initUser() { Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("111"); set.add("222"); set.add("333"); set.add("444"); set.add("555"); return set; } } 2 创建登录服务器LoginServer import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class LoginServer { public static void main(String[] args) { int port = 6666; try (ServerSocket serverSocket = new ServerSocket(port)) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbdc16850aee3020da43406539e6c79f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398fae1fc42fa3cfa7c33b3ec34d25eb/" rel="bookmark">
			简单的数字验证码功能（Spring boot &#43; vue.js ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端使用VUE+elementUI在表单中添加验证码的按钮和输入框，登录时先验证验证码，验证通过后才会验证登录密码。
//验证验证码的 const verificationCode =reactive({ answer: '', //答案 formula: '', //验证码的公式 }) //获取验证码 const getVerificationCode = () =&gt; { axios.get("/api/auth/generateVerification").then(res =&gt; { console.log(res.data); if(res.data.code === 200){ verificationCode.formula = res.data.object; }else ElMessage.error(res.data.message); }) } getVerificationCode();//初始化获取验证码 后端springboot+redis
package com.example.tourismmanagement.controller; import com.example.tourismmanagement.entity.dto.VerificationDTO; import com.example.tourismmanagement.utils.IpUtil; import com.example.tourismmanagement.vo.Result; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.bind.annotation.*; import javax.servlet.http.HttpServletRequest; import java.util.Objects; import java.util.concurrent.TimeUnit; /** * @Author linht * @Date 2022/5/20 15:17 **/ @Slf4j @RestController @RequestMapping("/auth") public class AuthController { @Autowired StringRedisTemplate stringRedisTemplate; //生成数字验证码 @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/398fae1fc42fa3cfa7c33b3ec34d25eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d8bc67028fdf9d05e91c63440b410f/" rel="bookmark">
			学习元宇宙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与上次提到的web3.0相比，元宇宙是一个更为重要的概念，今天写个文章学习一下元宇宙。我发现学一个东西的时候，写一写、说一说要远比读一读、听一听有效的多。
元宇宙这个名字有点吓人，metaverse这个词本身就有点夸张了，翻译为元宇宙则更进一步的夸张，导致很多人现在不太敢说这个词，因为它给人一种忽悠人的感觉。其实它本质上就是提了很多年的虚拟世界，可以把它理解为一种连接在互联网上、可供人们沉浸式体验的虚拟世界。
但它确实很重要，扎克伯格已经梭哈元宇宙了，并把公司名改成了meta。元宇宙被认为是未来的互联网交互方式，认为是从文本互联网到多媒体互联网到短视频互联网之后的又一次升级，其特点是沉浸式体验。这种沉浸式体验确实更接近人类从环境接收信息的自然方式，而不是现在通过一个平面（如屏幕）来接收信息。这可能会极大改变娱乐业的形态，比如看元宇宙电影时能够比看3D电影更进一步，我们不是坐在那里看立体影像在你眼前流过，而是我们可以站起来、走一走、甚至飞起来，我们完全自由的决定我们要观察故事的角度、位置。电影中我们还只是一个观察者，而在元宇宙游戏中，我们还能和元宇宙交互，影响剧情的发展。除了娱乐业之外，还可以有很多其他用途。在医学上能够为病人远程做手术，甚至我设想未来也可以把CT检查结果进一步转化成3D虚拟实体，并进行虚拟解剖，详细观察病灶状况。在远程教育上，全世界的学生都可以到斯坦福大学的课堂上听课。在工业设计上，我们不再只是在一个平面图纸上画零件图。虚拟3D通话和虚拟3D会议也都会带来更好的体验。等等。
元宇宙至少需要两个核心技术的支撑：一个是3D虚拟场景的生成，第二个是3D虚拟场景的进入。场景生成就是生成数字化的立体、逼真、细腻的3D视频场景，这个技术目前仍在快速发展中，难点包括怎么样让虚拟场景更流畅、分辨率更高、物体运动更逼真（符合基本物理规律，如水的流动，球的运动，等等），实现这些需要更快的通信速度（5G仍不太够，可能需要6G、7G），更好的算法和更快的芯片计算能力。AI算法应当能为元宇宙提供很大的推动作用，比如AI算法能够实现优秀的数据压缩和还原能力，用有限的特征词就可以描述和生成一个物体，这大大降低了需要远程传输的数据量。随着技术进步，这些应该会逐渐解决，在一二十年内有较大概率会逐步实现。
3D虚拟场景的进入首先是视觉显示，目前最主流的方式是头显，就是像个眼罩一样套在头上，但头显还是存在很多问题，戴会儿大了容易头晕，对视力有伤害，而且完全看不到现实世界的话有些安全隐患也让人会有点心慌，所以它未必就是未来的主要元宇宙显示方式。另一种可能的方式是全息投影，但目前全息成像的亮度都太低，只能在非常昏暗的室内有效果，而且设备也非常昂贵。其实我觉得眼下液晶屏也可以用的，大不了用一个环形的液晶屏以解决视角的问题，只要把3D场景做的更好，人脑应该也能沉浸进去（人脑的适应能力很强大），在未来一二十年仍看不到有什么优秀的3D虚拟场景显示方案，很可能液晶屏仍是主流。听觉的问题则比较好解决，现在的耳机技术已经能够支撑身临其境的体验。然而人有六根，眼耳鼻舌身意，其他的各种感觉，嗅觉、味觉、触觉和意识目前还都难以远程传递，我觉得可见的未来也难以有这些方面大的突破。
总结一下，元宇宙是下一步互联网信息交互方式的重要发展方向，3D视觉的生成和显示技术是其中的关键技术，学习AI+3D视觉将会是一个有前途的方向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b967c7e837bd72257ee3bfafabedf459/" rel="bookmark">
			Ubuntu下安装PCL1.12.1点云库经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu下安装PCL点云库经验分享 内容简介安装ubuntuVMware全屏下不完全显示换国内镜像源安装VTK问题一问题二 安装PCL配置vscodec_cpp_properties.jsonlaunch.jsontasks.json CMake编译xshell连接ubuntu总结 内容简介 本文主要分享我在Ubuntu下安装PCL点云库的经验，这里我用的ubuntu是22.04版本，依赖库基本都下载的新的，VTK版本是8.2（建议不要使用更新版本），PCL版本是1.12.1。
安装ubuntu 这里建议安装虚拟机，可以参照ubuntu20.04安装教程进行安装，需要注意的是安装时候要分配足够的磁盘空间，因为如果后面扩展磁盘空间的话会比较麻烦，扩展硬盘空间可以参照扩展磁盘进行操作，建议不要走到这一步。
VMware全屏下不完全显示 这里参考VMware虚拟机不能全屏的解决办法进行操作，也就是将设置中的分辨率改一下。
换国内镜像源 有了ubuntu之后首先要做的就是换上国内的镜像源，这里可以参照Ubuntu换源的两种方法进行操作，这样能使我们的下载速度得到明显提升。
安装VTK 这里参照Ubuntu18安装VTK8.2进行操作，但是make时候出现了问题。
问题一 [ 87%] Linking C shared library ../../../lib/libvtkexodusII-8.2.so /usr/bin/ld: CMakeFiles/vtkexodusII.dir/src/ex_open_par.c.o:/home/littlez/下载/Software/VTK-8.2.0/ThirdParty/exodusII/vtkexodusII/src/ex_open_par.c:477: multiple definition of `exodus_unused_symbol_dummy_1'; CMakeFiles/vtkexodusII.dir/src/ex_create_par.c.o:/home/littlez/下载/Software/VTK-8.2.0/ThirdParty/exodusII/vtkexodusII/src/ex_create_par.c:617: first defined here collect2: error: ld returned 1 exit status make[2]: *** [ThirdParty/exodusII/vtkexodusII/CMakeFiles/vtkexodusII.dir/build.make:4436：lib/libvtkexodusII-8.2.so.1] 错误 1 make[1]: *** [CMakeFiles/Makefile2:5836：ThirdParty/exodusII/vtkexodusII/CMakeFiles/vtkexodusII.dir/all] 错误 2 make: *** [Makefile:136：all] 错误 2 可以看到这是multiple definition of ‘exodus_unused_symbol_dummy_1’，处理办法也是简单粗暴，找到其中一个定义，然后注释掉。
问题二 [ 99%] Building CXX object Rendering/Qt/CMakeFiles/vtkRenderingQt.dir/vtkQtLabelRenderStrategy.cxx.o /home/littlez/下载/Software/VTK-8.2.0/Rendering/Qt/vtkQtLabelRenderStrategy.cxx: In member function ‘virtual void vtkQtLabelRenderStrategy::ComputeLabelBounds(vtkTextProperty*, vtkUnicodeString, double*)’: /home/littlez/下载/Software/VTK-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b967c7e837bd72257ee3bfafabedf459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e9dfb757353c3d03aaa551fad56598/" rel="bookmark">
			【React项目】使用npm install出现npm ERR cb() never called 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近由于疫情原因，所以开始了线上办公，但是开发环境的搭建真的是让人头皮发麻。
毕竟之前用的是公司的电脑，现在把项目迁移到自己的电脑上，不仅是项目出问题了，整个人都不好了！！！
我在使用npm install本来是想下载项目依赖，但是突然出现了npm ERR! cb() never called!这么一个报错（完整的报错如下），这不是莫名奇妙嘛，因为在公司不报错的啊，真让人摸不着头脑。
npm ERR! cb() never called! npm ERR! This is an error with npm itself. Please report this error at: npm ERR! &lt;https://npm.community&gt; npm ERR! A complete log of this run can be found in: npm ERR! /Users/apple/.npm/_logs/2021-09-01T12_38_19_323Z-debug.log 但是既然出了问题，还是要解决的， 所以只能找“度娘”咯！
为了解决这个问题，我也是跟着百度一顿操作，大多数的解决方案都是：清缓存，修改npm版本等等。但是我的问题好像不是地球人出现的，因为我尝试了数位博主的解决方案，就是解决不了，真的很无语。。。
下面的是我整理的解决这种报错，基本上涵盖了所有博主提供的方案：
方案一：清缓存 1、首先，以管理员模式打开cmd清除你的npm缓存：
执行命令：npm cache clean -f
2、清除完缓存后，安装最新版本的Node helper
执行命令：npm install -g n
注意：如果出现以下报错，需要执行另外一段命令
执行命令：npm install -g n --force
3、告诉助手（n）安装最新的稳定版Node：n stable 4、完成上一个命令后，您将获得最新信息。让我们再次运行安装： npm install
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e9dfb757353c3d03aaa551fad56598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f858871554b77330354c5474ccb574cc/" rel="bookmark">
			吃瓜教程 —— 第三章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三. 线性模型 1. 基本形式 给定由d个属性描述的示例 x = (x_1;x_2;…;x_d)，其中x_i在第i个属性上的取值，线性模型表示为
一般情况下用向量的形式，则表示成
只要能够确定出 w 和 b 的值就可以确定这个线性模型了
2. 线性回归 线性回归是什么？
线性回归是通过学习一个线性模型，来预测出其对应的连续值，通过对预测值和真实值之间，尽可能缩小其欧氏距离，即使得 f (x_i ) ≈ y_i
2.1 最小二乘法 使用均方误差最小化来进行模型求解的，形如
2.2 极大似然估计 假设线性回归模型如下所示，
其中 ϵ 符合
然后将 ϵ 用 y-(wx+b) 进行代替后，得到的式子为
代入极大似然估计后，得到如下所示，
由于极大似然函数不好求，因此对上述的式子进行取对数，最终得出
其中使用了 ln(ab)=lna+lnb 的性质
2.3 求解 w 和 b 的值 加上 argmin 后就变成
其中 argmin 表示当这个式子取最小的时候，w 和 b的取值是多少
由于上述的式子中存在着两个参数一个是 w ，一个是 b，因此对上述的式子，根据数分的知识，要求出其值，则分别对两个参数求偏导，令导数为0，即可求出连个参数的值
最终得出
w 的求解公式为
b 的求解公式是
2.4 Hessian矩阵 用于判断这个函数是否为一个凸函数的办法，Hessian矩阵形如下所示，
Hessian矩阵是针对于一个函数对其求二阶偏导，得出的一个矩阵，当这个矩阵为半正定的时候便可以说明这个函数为凸函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f858871554b77330354c5474ccb574cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a378bf210725feade3e6560d6bc68e/" rel="bookmark">
			docker-compose部署elasticsearch-exporter和kafka-exporter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker-compose部署elasticsearch-exporter和kafka-exporter version: '3' services: elasticsearch-exporter: image: bitnami/elasticsearch-exporter:latest commmand: - '--es.uri:http://elasticsearch:9200' restart: always ports: - "9114:9114" kafka-exporter: image: bitnami/kafka-exporter:latest command: - '--kafka.server=192.168.1.36:9092' - '--kafka.server=192.168.1.36:9092' restart: always port: - "9308:9308" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e002abdd738ba3e1fbc8e3ca28984c88/" rel="bookmark">
			[MIT]微积分重点 第十七课 六函数、六法则和六定理 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.六函数 积分六函数导数 x n + 1 / ( n + 1 ) x^{n+1}/(n+1) xn+1/(n+1) x n x^n xn n x n − 1 nx^{n-1} nxn−1 − cos ⁡ x -\cos x −cosx sin ⁡ x \sin x sinx cos ⁡ x \cos x cosx sin ⁡ x \sin x sinx cos ⁡ x \cos x cosx − sin ⁡ x -\sin x −sinx e c x / c \rm e^{cx}/c ecx/c e c x \rm e^{cx} ecx c e c x c\rm e^{cx} cecx x ln ⁡ x − x x\ln x - x xlnx−x ln ⁡ x \ln x lnx 1 / x 1/x 1/x斜坡函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e002abdd738ba3e1fbc8e3ca28984c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33b641d941d62f9d24748ff3d5d2fef/" rel="bookmark">
			ESP8266 MQTT开发IOT系列教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESP8266 MQTT开发IOT教程 使用esp8266 01s 12f等wifi模块、MQTT的通讯协议 arduino IDE开发IOT应用教程
更多学习知识 访问 niehen.cn
ESP开发学习基础知识 基础知识包括对esp模块的认识与了解 mqtt协议的了解，arduino IDE运用代码编写等等。
arduino基础学习esp系列模块的介绍mqtt协议的介绍与使用利用mqtt esp模块 基于arduino IDE开发方法esp模块的AT指令 刷固件esp模块睡眠模式使用esp8266-01s介绍与使用esp8266-12f介绍与使用NodeMcu介绍与使用 esp开发IOT应用 基于esp8266的模块以及其他模块根据实际的应用场景与需求制作的物联网应用
基于FRID arduino 继电器 电磁锁开发的FRID门禁系统esp32-cam获取视频流图像处理基于步进电机 esp8266 mqtt开发的自动窗帘控制基于DHT11 Esp8266 mqtt获取室内温湿度基于CCS811 esp8266 mqtt 获取室内空气质量基于红外模块 esp8266 mqtt开发的智能遥控控制基于ws2812 esp8266 mqtt开发的智能多级照明灯基于ws2812 esp8266 mqtt开发的智能多模式氛围灯基于mp3player esp8266 mqtt开发的智能语音播报系统IOT综合应用之智慧教室项目开发 如果以上内容对你有帮助或是对IOT开发感兴趣，欢迎关注我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210e441a6480bdff3dc105bd993d08e0/" rel="bookmark">
			Autodesk Maya Unreal LiveLink 构建踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Autodesk Maya Unreal LiveLink 构建踩坑记录 之前由Epic维护的Livelink插件现在被Autodesk维护的插件代替了,因为涉及到对插件的修改,所以需要重新构建,以下是踩坑记录
1.系统和工具要求 官方建议是VS2017/2019和Win 10,我这边用的2019
2.需要准备一份源码版本的unrealEngine,我这边用的是4.27.2. 3.clone LiveLink的存储库 在Autodesk的github可以找到Livelink的存储库,地址:https://github.com/Autodesk/LiveLink
Clone之后找到UnrealEngine/Engine目录并在下面新建Restricted文件夹,然后在Restricted文件夹下新建NotForLicensees文件夹,最后将Clone 的Livelink复制到NotForLicensees文件夹下.
4.安装第三方库 MayaSDK 首先在这个地址:https://www.autodesk.com/developer-network/platform-technologies/maya下载对应版本的MayaSDK,然后第一个坑就来了,官方写的查找SDK的环境变量的名称是MAYA_WND_DIR_xxxx
但cs文件中的名称是MAYA_WIN_DIR_xxxx如果按照官方的设置,在编译时会报错,xxxx代表Maya版本,建议直接把devkitBase这个文件夹放到c盘根目录,这样环境变量就设置为
MAYA_WIN_DIR_2019:C:\devkitBase
然后第二个坑就来了如果直接使用下载来的SDK的目录结构,在Include文件的时候会提示找不到,所以需要把devkitBase文件夹下的include和lib文件移动到devkit文件夹下才可以.
rapidjson 在这里:https://github.com/Tencent/rapidjson/tree/v1.1.0下载rapidjson,并把include/rapidjson目录复制到
Engine\Restricted\NotForLicensees\ThirdParty目录下如果没有就手动创建目录,此时你的Engine/Restricted/NotForLicensees目录应该看起来如下图
最后打开cmd,cd 到Engine\Restricted\NotForLicensees\Source\Programs\MayaUnrealLiveLinkPlugin文件夹下,使用命令 BuildMayaUnrealLiveLinkPlugin.Bat [Maya版本] Win64来编译,如:BuildMayaUnrealLiveLinkPlugin.Bat 2019 Win64
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbda12a9a906bdbfa27d71f7ec73de58/" rel="bookmark">
			『Python爬虫』抓包工具 Fiddler 入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今Python爬虫越来越火，有想学好Python爬虫的小伙伴可以前往gzh【Python编程学习圈】领取系统的学习资料以及教程视频，还分享有大量的技术干货文章可以阅读学习，欢迎大家关注学习。
传统的抓包工具，如：Fiddler、Charles、Wireshark、Tcpdump，大家肯定都不陌生了；
今天我们就来聊一聊这款常用的抓包工具：Fiddler；
fiddler简介 Fiddler是个蛮好用的抓包工具，也是比较好用的web代理调试工具之一；
它能记录并检查所有客户端与服务端的HTTP/HTTPS请求，能够设置断点，篡改及伪造Request/Response的数据；
修改hosts、限制网速、http请求性能统计、简单并发、接口测试、辅助自动化测试等等，也可以用来检测网络安全。
Fiddler与其他抓包工具 ① Firebug
虽然它可以抓包，但对于分析http请求的详细信息不够强大，模拟http请求的功能也不够。
且firebug常常是需要“无刷新修改”，如果刷新了页面，所有的修改都不会保存；
② Wireshark：
通用的抓包工具，能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容。
但如果是TCP、UDP协议可以用wireshark；
③ Httpwatch
也是比较常用的http抓包工具，但是只支持IE和firefox浏览器（其他浏览器可能会有相应的插件）；
而Fiddler 是一个使用本地 127.0.0.1:8888 的 HTTP 代理，任何能够设置 HTTP 代理为 127.0.0.1:8888 的浏览器和应用程序都可以使用 Fiddler。
爬虫与Fiddler：
在一些稍复杂的网络请求中，我们直接看网址的变化是看不出规律的，如果要自动爬取，就必须通过程序构造这些请求，并分析这些请求的规律。
进行登录时，很多网页的真实登录处理并不是我们看到的网址，这些网址一般需要通过工具进行分析得出。
分析过程中，抓包软件的配合会变得更加方便。
Fiddler的工作原理 Fiddler是以代理WEB服务器的形式工作的，它默认使用代理地址**:127.0.0.1**， 端口**:8888**。 当Fiddler开启时会自动设置代理， 退出的时候它会自动注销代理，这样就不会影响别的程序。
不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。
解决的办法是重新启动下Fiddler；
Fiddler界面 Fiddler想要抓到数据包，要确保Capture Traffic是开启，在File –&gt; Capture Traffic。
开启后再左下角会有显示，当然也可以直接点击界面底栏左下角的图标来关闭/开启抓包功能。
左边面板
左边web session面板的字段及图标含义；
右边面板
右边是详情和数据统计面板；
1）Statistics
关于HTTP请求的性能（例如发送/接受字节数，发送/接收时间，还有粗略统计世界各地访问该服务器所花费的时间）以及数据分析。
2）Inspectors
是用于查看会话的内容，上半部分是请求的内容，下半部分是响应的内容；
提供headers、textview、hexview,Raw等多种方式查看单条http请求的请求报文的信息。
3）AutoResponder 可用于拦截某一请求，即按自己添加的指定规则重定向到本地的资源或Fiddler资源，从而代替服务器响应。
4）Composer 自定义请求发送服务器，Parsed模式下你只需要提供简单的URLS地址即可；
5）Filters 即过滤规则，通过设置过滤规则来过滤所需的http请求，勾选Use Filters开启过滤器。
内外网过滤：
对host过滤：
输入多个HOST，多个之前用半角逗号或者回车分隔；
支持通配符：*,baidu.com；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbda12a9a906bdbfa27d71f7ec73de58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a82cb1389ea78fb72e5599199cef6b/" rel="bookmark">
			USB转RS422带隔离电路设计(CAIS3082W替代方案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USB转RS422带隔离电路设计(CAIS3082W替代方案) 文章目录 USB转RS422带隔离电路设计(CAIS3082W替代方案)1. 设计思路2. 设计理由3. 设计原理图4. 效果图5. 其他 水一篇文章，赚点原力 1. 设计思路 本设计采用cp2102+CAIS3082W的方案设计
整体设计方案如下：
2. 设计理由 相比于ch340系列的usb转串口，cp2102的优势是在插在一个电脑上的不同USB口，在电脑端识别出来的COM口号是不变的，这样当你同时接入多个模块，每回拔插就不用去找对应的串口了。
CAIS3082W是川土微电子发布的一款国产的RS422隔离芯片，在当今芯片暴涨的2022年，这颗芯片只需要不超过5块钱，可以说是完美的422替代品。经过合理的设计，其实CAIS3082W应该也可以作为RS485隔离芯片。当然这家公司也推出了专门的RS485隔离芯片型号为CAIS3082WX，买的时候千万别买错了。
其实设计它的根本原因是想做一个CAIS3082W评估板，来验证它的可靠性，主要的目的是评估CAIS3082W而设计
为防止买错，我在此处贴出我当时购买芯片的链接：
我在某宝cp2102购买链接：https://m.tb.cn/h.fHdfmmB?tk=2Jdx29oKiwP
我在某宝CAIS3082W购买链接：https://m.tb.cn/h.fs2DSKV?tk=IkYI29oq27e
3. 设计原理图 我把这个完整的设计pcb已经开源了，开源地址;
截图看一下：
USB部分：
CP2302部分：
RS422部分：
4. 效果图 3d效果图：
实际效果图：
5. 其他 对于电容隔离的芯片来说，除了隔离信号，往往还需要隔离电源，这里推荐一款电源隔离模块型号B0505S-1WR3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e4bbef5c2f4564401140de876bdc33/" rel="bookmark">
			【前端】语义化标签详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 语义，语义化，HTML HTML描述的是网页内容的含义，即，语义。
语义化HTML，就是用最恰当的HTML元素，标记内容。
语义化标签，也即，有含义的标签。
2 意义 提升可访问性和互操作性（内容对于借助辅助技术的残障访问者是可访问的，同时对于台式机、手机、平板电脑及其他设备上的浏览器都是可访问的）。提升搜索引擎优化（SEO）的效果。使维护代码和添加样式变得容易。（通常）使代码更少，页面加载更快。 3 常用标签语义 h1~h6：heading，标题p：paragraph，段落em：empasis，强调a：anchor，锚，链接div：division，块级元素，通用容器，无任何语义span：短语内容，通用容器，无任何语义header：页面的介绍展示区域，通常包括网站logo、主导航、全站链接以及搜索框nav：页面的导航链接部分区域main：页面的主要内容，一个页面只能使用一次。article：页面独立的内容，它可以有自己的header、footer、sections等section：标记文档的各个部分，例如长表单文章的章节或主要部分aside：侧边栏footer：文档的底部信息small：小号字体strong：强调文本figure：图figcaption：figure的唯一标题 4 补充 4.1 header 用在页面中，是页眉/页头。同时，也可以使用在article中。当header作为页眉时，在内部可以包含nav元素，作为导航性链接。不能在header内嵌套header或footer。如果只用h1-h6就能满足需求，就没必要用header包裹h1-h6。header与h1-h6的语义目的是不同的，不能互换。 4.2 nav 一般，在用ul和ol元素对全局导航、链接进行结构化时，在外面，包上一个nav。这种nav通常在header元素里面。nav能帮助识别页面的主导航。对辅助性页脚（使用条款、隐私政策），不要用nav；对导航页脚（商店位置、招聘信息），推荐用nav。nav不能嵌套在address中。 4.3 main mian元素包围着代表页面主题的内容。一般会加上在main开始标签中加上role="main"一个页面只能用一次mainmain不能在article、aside、footer、header、nav中。 4.4 section 与div区别：div无任何语义与article区别：section本质上组织性和结构性更强，article则是自包含的容器何时使用：记住定义中的“具有相似主题的一组内容” 5 注意 html关注的是内容，而不是样式。em、strong、small、cite等，不要为了他们的样式而去使用，应当把浏览器的样式当做一种附带，而不是目的，html要关注语义，样式是css的事。html5强调元素的语义，而b和i是html5之前时代的产物，那时候没有css，b和i本质上是用于表现的，请慎用。 6 参考 什么是语义化标签，常见的语义化标签介绍《HTML5与CSS3基础教程（第8版）》 7 其他 【前端】HTML5与CSS3学习笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34fa1878b529d279bab4c8f2fa9e38b/" rel="bookmark">
			VS2022&#43;Qt的环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为一些原因，再次接触到了Qt，Qt原生的IDE又太过憨批，这里就搭配宇宙第一IDE VS2022配置一下Qt，在这里写一期配置，希望对大家有点帮助。
说起来，这玩意是叫Qt，不是QT，更不是qt！
前置环境 我的环境是Windows 10，默认已经安装了visual studio 2022，如果没有安装VS2022直接进官网下载安装就完事了，无脑点点点，很简单。最后需要确保你安装了左边的C++桌面开发以及右边MSVC v142（VS2019的生成工具）
安装Qt 进入Qt官网
进入下载页面
这里我们本着支持开源精神 qiong ，选择开源版
拉下来，选择下载
点进去，点击download
然后应该会自动弹出下载
由于官方源因为众所周知的原因贼慢，我们这里使用国内镜像
下载后找到这个exe所在目录
如果你有windows terminal的话直接在该文件夹的空白处右键终端打开
没有的话自己开一个powershell或者cmd打开这个目录就行了
输入命令：
installer(.exe) --mirror https://mirrors.bfsu.edu.cn/qt 注意：这个installer(.exe)是你下的这个exe的名字，比如我这里叫qt-unified-windows-x86-4.3.0-1-online.exe，那我就输入.\qt-unified-windows-x86-4.3.0-1-online.exe --mirror https://mirrors.bfsu.edu.cn/qt，为什么要加个.\呢？相信这点也不用我解释了。
登录Qt账户，没有的自己注册一个，怎么注册都不会就洗洗睡吧
注册密码是大小写＋数字
开源协议，同意一下
一路下一步，是否接受改进协议，爱选啥选啥
指定安装路径，C盘小的小朋友酌情改改路径吧，这玩意还是能占几十个g的
选择版本，这里我选6.3.0
一大堆许可协议，选择经典“我已阅读”
一路下一步，等待下载安装，这个是我换源前的下载速度，这个数字动的倒是挺快，仔细一看，单位字节(
下载完后安装也要老半天，经过相当漫长的等待，终于全部搞定了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ed1a518fbaad008ee0746b30b8fee7/" rel="bookmark">
			【matlab图像处理】图像直方图操作和matlab画图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国史之【平王东迁】：
公元前771年，因镐京曾遭地震，残破不堪，又接近戎、狄等外患威胁，周平王遂在郑、秦、晋等诸侯的护卫下，将国都东迁至洛邑，东周历史由此开始。
——来源：全历史APP
【路漫漫其修远兮，吾将上下而求索】
今天介绍图像的直方图操作以及用matlab画条形图、杆图和折线图。本内容参考自《实用MATLAB图像和视频处理》第9章。
对于matlab2021的安装，可以参考公众号【CV之道】的文章：【matlab安装】手把手图文并茂安装matlab2021（win10版） 1、图像直方图显示 在matlab中，显示一幅图像的直方图，可以使用函数imhist。废话少说，直接看代码：
% 显示直方图 I = imread('circuit.tif'); figure, subplot(2,2,1), imshow(I), title('原图') % 划分为256个灰度级 subplot(2,2,2), imhist(I,256), axis tight, title('直方图') 上面256个灰度级是默认的参数，就是绘制256个直方条的直方图。我们看一下绘制为64和32的效果： % 划分为64个灰度级 subplot(2,2,3), imhist(I,64), axis tight, title('直方图64级') % 划分为256个灰度级 subplot(2,2,4), imhist(I,32), axis tight, title('直方图32级') 可以看到，整体变稀疏了，但是分布整体还是在的。值得注意的是，使用了axis tight这个参数，表示y轴的范围来自数据的范围。
可以看到，划分为256级的时候，y轴最大为2000。划为32级的时候，y轴最大为8000。因为总的像素数不变，划分级数更少，表明每个级数所包含的像素个数增多了。
2、条形图归一化y轴 我们可以探索一下这个问题，对y轴范围进行归一化。
% 归一化 c = imhist(I, 32); % numel(I)表示该图像的像素数，这里是280x272=76160 c_norm = c / numel(I); figure, subplot(1,2,1); % 定制条形图 bar_1 = bar(c); set(gca, 'XLim', [0 32], 'YLim', [0 max(c)]); % gca是当前轴，设置轴范围 set(gca, 'XTick', [0:8:32], 'YTick', [linspace(0,7000,8) max(c)]); % 设置轴显示数据范围 set(bar_1, 'FaceColor', 'r'), title('条形图'); % 设置颜色和标题 % 显示归一化的图 subplot(1,2,2); bar_2 = bar(c_norm); set(gca, 'XTick', [0:8:32], 'YTick', [linspace(0,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ed1a518fbaad008ee0746b30b8fee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639eb017282c03d8da78fce26cf58ca5/" rel="bookmark">
			2022李宏毅机器学习深度学习学习笔记第五周--BERT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、pre-train 模型二、How to fine-tune总结 前言 介绍什么是pre-train模型，有了模型后怎么做fine-tune以及pre-train模型怎么被训练出来。
一、pre-train 模型 pre-train 模型希望把输入的每一个token表示成一个embedding vector，vector包含了token的语义，意思相近的token要有比较相近的embedding ，embedding 里面的某些维度可以看出语义的关联性。
contextualized word embedding和过去模型的不同之处就是过去的模型输入一个token输出一个embedding，现在的是吃一整个句子，把一整个句子都看过以后，了解了上下文才给每个token输出一个embedding。
他的模型架构如下：
怎么让BERT模型变小呢？
除了用一些network压缩方法让network变小以外，network architecture 设计的目标是为了让机器可以读非常长的序列。
比如Transformer-XL可以读将近一本书的token，Reformer和Longformer要做的是减少self-attention（n*n）带来的计算量。
二、How to fine-tune fine-tune部分旨在根据预训练的model添加部分层从而可以解决下游任务，我们有了一个pre-trained model以后，我们希望在它上面再叠一层Task-specific的部分，接下来这个模型就可以用在特定的模型上。
先看一下NLP任务的分类：
根据输入分两类，根据输出分四类，
输入：
输入为一个句子，把输入丢到pre-trained model就可以了，如果输入是多个句子，第一个句子是问题。第二个是文件，在两个句子中间加分隔符SEP。
输出：
1.机器读一整个句子，输出一个class
在输入的时候加一个CLS，在pre-trained的时候要告诉机器看到CLS要产生跟整个句子有关的embedding ，把输出丢到模型中，模型在做分类的问题。在训练的时候没有cls的输入，就把所有输出都读进Task Specific进行分类。
2.每一个token都给他一个class
3.从输入做copy，比如Extraction-based QA
4.General Sequence,怎么把pre-trained的模型用在seq2seq模型里面。
版本一
第四个任务就是生成任务，BERT可以作为一个encoder，需要我们自己去设计一个decoder，但是decoder是没有经过预训练的。
版本二
也可以让pre-training模型当作decoder来使用，其方法就是输入一个[sep]之后让model输出一个东西，再将模型的输出作为模型的输入，以此类推，不断的得到输出结果。
假设有一些Task-specific模型怎么去fine-tune模型。
1.pre-trained模型训练完后就固定住了，变成一个Feature Extractor。
2，把pre-trained和Task-specific的部分接在一起，在fine-tune的时候不止调Task-specific也调pre-trained的模型。
再去微调整个模型，从上图可以看到pre-trained的模型在不同的任务中通过fine-tune以后都会变得不一样，每个任务都需要存一个新的model ，往往非常巨大，就有了Adaptor。只调pre-trained的一部分就好了，在pre-trained model中加入一些Apt，只调Apt的部分。
Weighted features
把不同层的features乘上weight加起来，再把每一层合起来的丢到任务中，w1\w2可以跟着task specific一起被学出来。
为什么需要pre-trained的模型？
pre-trained的模型带给我们比较好的performance，
黑线代表人类的能力，每个点代表每个模型在不同任务上的performance，蓝线代表不同任务的平均。机器以及可以与人相提并论了。
总结 本章在了解了BERT的内容后，具体了解了预训练和微调的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f530bb23b407b58051f1d856a97837ec/" rel="bookmark">
			Error: Module build failed (from ./node_modules/@dcloudio/webpack-uni-mp-loader/lib/style.js):Error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看pages.json里pages字段内的路由配置是否正确
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f073de3dd4d7c3022fa661b07c12e50/" rel="bookmark">
			Spring 自动装配详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是自动装配 1、自动装配是使用spring满足bean依赖的一种方法
2、spring会在应用上下文中为某个bean寻找其依赖的bean。
二、自动装配的方法有哪些 1、在xml中显式配置；
2、在java中显式配置；
3、隐式的bean发现机制和自动装配。
三、学习环境的搭建 1、创建三个实体类
Dog，Cat，People
package com.lisi.pojo; public class Dog { public void shout(){ System.out.println("汪汪汪"); } } package com.lisi.pojo; public class Cat { public void shout(){ System.out.println("喵喵喵"); } } package com.lisi.pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f073de3dd4d7c3022fa661b07c12e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a3a1d5f475dc785403a8aa76984c58/" rel="bookmark">
			Typora收费了，再找找免费的Markdown编辑器吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从去年11月Typora推出了 1.0 正式版，并宣布开始收费＄14.99，且最多只支持 3 台设备，也可以使用信用卡和支付宝支付89元。去年推出1.0，但还有beta版本可以蹭，可是最近却发现软件被强制升级停用了。只能下载新版本，然后有15天的试用期。
难道，以后真的下不了用不了beta版本。今天上https://typoraio.cn/releases/all找Old Beta，是下载不了的。
要不要买？毕竟用了好多年，处出感情了，爱了它的极简轻便。
目前我还不打算购买，三台机器的授权是满足不了我的需求的。另外，有个小担心：此次费用支付后，可能后面还需要支付额外费用。虽然作者说了不会使用订阅模式，但是谁知道呢，后面又来个主版本更新，变卦了，毕竟一个beta版都开发了这么多年。
现在只能先物色新的免费Markdown编辑器了。
查了下，近期打算试用下这么几个，如果好用再给大家推荐：
Notable
项目地址：https://github.com/notable/notable
Mark Text
官网：https://marktext.app/
项目地址：https://github.com/marktext/marktext
Haroopad
官网：http://pad.haroopress.com/
项目地址：https://github.com/rhiokim/haroopad
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a796e06a82f337d60835bdaf6d1411/" rel="bookmark">
			【数据结构入门实验】二叉树的建立和遍历完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容： 1 ．二叉树的建立与遍历（验证性实验） 问题描述 建立一棵二叉树，并对其进行遍历（先序、中序和后序），打印输出遍历结果。 基本要求 从键盘接受输入（先序），以二叉链表作为存储结构，建立二叉树（以先序来建立），并采用递归 算法对其进行遍历（先序、中序和后序），将遍历结果打印输出。 测试数据 ABC □□ DE □ G □□ F □□□ （其中 □ 表示空格字符），则输出结果为：先序为 ABCDEGF ，中序为 CBEGDFA ， z 后序为 CGBFDBA 。 实验分析： 实验要求采用的是先序建立二叉树，在此可以使用一个递归的方式去建立，但是由于指针传递的问题，在此使用二级指针，原因的话可以见我写的另一篇文章：
（极易错）链表指针函数传递问题，含线性表入门实验--约瑟夫环问题c语言代码 三个遍历函数也使用递归，比较简单就不多说了，如果是0基础的话可以简单了解一下三种遍历的大致描述：
先序：规则是若二叉树若为空,则空操作返回,否则先访问根结点,然后遍历左子树,然后再遍历右子树
中序：若树为空,则空操作返回,否则从根结点开始,中序遍历根结点的左子树,然后就是访问根结点,最后中序遍历右子树
后序：若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点
代码： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; typedef struct BiTree { char data; struct BiTree *lchild; struct BiTree *rchild; }BiTree,*BiTreePtr; bool CreatBiTree(BiTreePtr *T) { char ch; scanf("%c",&amp;ch); if(ch==' ') (*T)=NULL; else { if(!((*T)=(BiTreePtr)malloc(sizeof(BiTree)))) exit(1); (*T)-&gt;data=ch; CreatBiTree(&amp;((*T)-&gt;lchild)); CreatBiTree(&amp;((*T)-&gt;rchild)); } return true; } bool PreOrderTraverse(BiTreePtr T) { if(T) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a796e06a82f337d60835bdaf6d1411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a427270def2f56f6bad724724a0f58e8/" rel="bookmark">
			C&#43;&#43;小知识点（一）：基类指针指向派生类对象、派生类指针指向基类对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基类指针指向派生类对象、派生类指针指向基类对象 以下代码运行后的输出结果是（）
#include using namespace std; class A { public: void virtual print() { cout &lt;&lt; "A" &lt;&lt; endl; } }; class B : public A { public: void virtual print() { cout &lt;&lt; "B" &lt;&lt; endl; } }; int main() { A* pA = new A(); pA-&gt;print(); B* pB = (B*)pA; pB-&gt;print(); delete pA, pB; pA = new B(); pA-&gt;print(); pB = (B*)pA; pB-&gt;print(); } using namespace std; class A{ public:void virtual print(){ cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a427270def2f56f6bad724724a0f58e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb24ce186a0e78886ec2ed1028e98d6/" rel="bookmark">
			git系列之git初始化配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询git配置 git config -l git代理 设置http代理
git config --global http.proxy http://127.0.0.1:8080 git config --global https.proxy https://127.0.0.1:8080 设置socks5代理
git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 取消代理
git config --global --unset http.proxy git config --global --unset https.proxy 密钥 生成单个密钥 生成密钥命令，如下
ssh-keygen -t rsa -C "xxxxx@xxxxx.com" 将密钥的公钥copy到git站点的配置
测试是否成功
ssh -T git@github.com 生成多个密钥 生成两个不同的密钥命令，如下
ssh-keygen -t rsa -C "xxxxxxx@qq.com" -f "id_rsa_github" ssh-keygen -t rsa -C "xxxxxxx@qq.com" -f "id_rsa_gitee" 配置C:\Users\登录用户名\.ssh\config，不同的git地址路由到对应的密钥
# github Host github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb24ce186a0e78886ec2ed1028e98d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db303ab2099b264b2ba094bc7e18bf59/" rel="bookmark">
			postman开发全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种视图查看body：
Pretty
格式化了JSON和XML，方便查看。 点击里面的URL，postman会创建一个request： 点击左边的三角可以折叠展开： postman自动格式化body必须保证返回了正确的Content-Type.如果API没有返回，则可以点击”Force JSON“来设置。 Raw
是text。 preview
有的浏览器会返回HTML的错误，对于找问题比较方便。由于sandbox的限制，js和图片不会显示在这里的iframe中。你可以maximize该body窗口方便查看结果。
Headers key-value形式展示。鼠标悬停在headers标签上，有详细的HTTP说明。 cookies
可以显示browser cookies，需要开启Interceptor。 身份验证Authentication
postman有一个helpers可以帮助我们简化一些重复和复杂的任务。当前的一套helpers可以帮助你解决一些authentication protocols的问题。 Basic Auth
填写用户名和密码，点击Refresh headers Digest Auth
要比Basic Auth复杂的多。使用当前填写的值生成authorization header。所以在生成header之前要确保设置的正确性。如果当前的header已经存在，postman会移除之前的header。 OAuth 1.0a
postman的OAuth helper让你签署支持OAuth 1.0基于身份验证的请求。OAuth不用获取access token,你需要去API提供者获取的。OAuth 1.0可以在header或者查询参数中设置value。 OAuth 2.0
postman支持获得OAuth 2.0 token并添加到requests中。 模拟上传
先设置post，并将url填好。
1、设置请求头 2、设置请求体 比如后台PHP服务器接受upload字段的文件：
echo $_FILES["upload"]; 1 Android代码传递示例：
//此处重点：name为后台给的字段，filename为上传的文件名
sb.append("Content-Disposition: form-data; name=\"upload\";filename=\"head.jpg\"" + LINE_END);
//此处重点：上传的为JPG图片，那么图片Content-Type为 image/jpeg
sb.append("Content-Type: image/jpeg; charset=" + CHARSET + LINE_END);
3、发送请求 点击send即可。
postman中 form-data、x-www-form-urlencoded、raw、binary的区别 1、form-data: 就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来说明文件类型；content-disposition，用来说明字段的一些信息；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db303ab2099b264b2ba094bc7e18bf59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5176bc8ff3d5af6881382f0902199dff/" rel="bookmark">
			Python面试，这16个问题你一定要熟知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）Python 是如何进行内存管理的？ 答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制
⒈对象的引用计数机制
Python 内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。引用计数增加的情况：
❶一个对象分配一个新名称
❷将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况：
❶使用 del 语句对对象别名显示的销毁
❷引用超出作用域或被重新赋值
sys.getrefcount( )函数可以获得对象的当前引用计数
多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。
⒉垃圾回收
❶当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
❷当两个对象 a 和 b 相互引用时，del 语句可以减少 a 和 b 的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，
因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。
⒊内存池机制
Python 提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
❶Pymalloc 机制。为了加速 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。
❷Python 中所有小于 256 个字节的对象都使用 pymalloc 实现的分配器，而大的对象则使用系统的 malloc。
❸对于 Python 对象，如整数，浮点数和 List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
（二）什么是 lambda 函数？它有什么好处? 答：lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用， 也就是指匿名函数
lambda 函数：首要用途是指点短小的回调函数lambda [arguments]:expression
&gt;&gt;&gt; a=lambdax,y:x+y
&gt;&gt;&gt; a(3,11)
（三）Python 里面如何实现 tuple 和 list 的转换？ 答：直接使用 tuple 和 list 函数就行了，type()可以判断对象的类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5176bc8ff3d5af6881382f0902199dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45191892e99c9b6740672dfbc6ee36d0/" rel="bookmark">
			win10开启SSH服务通过内网穿透技术实现远程SSH访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤1：启动win10的SSH服务 参考：Win10系统自带的SSH2服务怎么启动?_我的麦的博客-CSDN博客_系统自带ssh
1、进入到Windows10系统，选择"开始菜单"-&gt;"设置"选项。
2、打开"Windows设置"对话框，选择"应用"菜单选项。
3、会弹出"应用和功能"对话框，再选择"可选功能"菜单项。
4、再选择"添加功能"按钮菜单。
5、在"添加可选功能"操作窗口，勾选中"OpenSSH服务器"前面的复选框，再点击"安装"按钮。
6、稍等片刻，等待"OpenSSH"服务器组件的安装完成。
7、在Windows10命令终端输入“services.msc”打开系统的"系统服务"，将"OpenSSH Authentication agent"和"OpenSSH SSH Server"服务设置为"启动"状态。
8、在cmd窗口，执行"netstat -an|findstr ":22""指令，可查看默认的SSH2服务的TCP 22端口正在运行。如果命令提示不可用可以参考本文附录1 处理。
netstat -an|findstr ":22" 步骤2：实现内网穿透 1、下载花生壳并且安装
2、创建内网穿透
windows端口占用查看：
netstat -na 步骤3：检查 在cmd命令终端输入如下命令弹出SSH端口则说明开启成功。
telnet 127.0.0.1 22 步骤4：连接 使用xshell工具进行连接
xshell地址：
Xshell下载-Xshell6免费版下载【官方版】-华军软件园
附录 附录1 解决‘telnet‘不是内部或外部命令，也不是可运行的程序 windows10 中telnet默认是关闭的，需要打开才能使用。
进入“控制面板\程序”，点击 “启用或关闭windows功能”
勾选 Telnet客户端 后点击确定， 等几分钟，保存所有电脑文件后在 重启电脑。就可以了!
指令格式为: telnet url地址 port端口
windows端口占用查看 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7276a7538dc9506511edc5c83c1d634d/" rel="bookmark">
			层标准化详解（Layer Normalization）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么Batch Normaization难以应用于RNNs？ Batch Normalization使用mini-batch的均值和标准差对深度神经网络的隐藏层输入进行标准化，可有效地提升训练速度。对于前向神经网络应用Batch Norm，使用简单SGD优化器，训练速度也能有较大提升。
BN的效果受制于batch的大小，小batch未必能取得预期效果；
对于前向神经网络可以很直接地应用BN，因为其每一层具有固定的神经元数量，可直接地存储每层网络各神经元的均值、方差统计信息以应用于模型预测，但在RNNs网络中，不同的mini-batch可能具有不同的输入序列长度（深度），计算统计信息比较困难，而且测试序列长度不能大于最大训练序列长度；
Barch Normalization也很难应用于在线学习模型，以及小mini-batch的分布式模型；
torch内部有两种BatchNorm，分别是BatchNorm1D和BatchNorm2D，BatchNorm1D作用于2维张量（B*D，存储D个统计量），BatchNorm2D作用于4维张量（B*C*W*H，存储C个统计量）
NLP任务中的张量多为3维，B*N*D，需存储序列长度上的统计量，而不同batch的序列长度不一致，不好统计，而且推理阶段的序列长度不能大于训练时所用的最大长度。
如何对RNNs网络进行标准化？ 网络层的输出经过线性变换作为下层网络的输入，网络输出直接影响下层网络输入分布，这是一种协变量转移的现象。我们可以通过 固定网络层的输入分布（固定输入的均值和方差） 来降低协变量转移的影响。
BN对同一mini-batch中对不同特征进行标准化（纵向规范化：每一个特征都有自己的分布），受限于batch size，难以处理动态神经网络中的变长序列的mini-bach。
RNNs不同时间步共享权重参数，使得RNNs可以处理不同长度的序列，RNNs使用 Layer Normalization 对不同时间步进行标准化（横向标准化：每一个时间步都有自己的分布），从而可以处理单一样本、变长序列，而且 训练和测试处理方式一致。
Batch Normalization和Layer Normalization的应用
对于CNNs图像x=shape(batch_size, channels, height, weight)，则 bn_mean=np.mean(x, axis=(0, 2, 3)), shape=(1, channels, 1, 1) 对于RNNs序列x=shape(batch_size, seq_len, hidden_size), 则 ln_mean=np.mean(x, axis=2)， shape=(batch_size, seq_len, 1) 对于前向神经网络的第 l l l隐藏层（等价于RNNs时刻 l l l对应的隐藏层），令 a l \boldsymbol a^l al表示输入向量（前层网络输出加权后的向量）， H H H表示隐藏单元数量，则 Layer Normalization 的均值和方差统计量为
μ l = 1 H ∑ i = 1 H a i l , σ l = 1 H ∑ i = 1 H ( a i l − μ l ) 2 \mu^l = \frac{1}{H}\sum_{i=1}^Ha^l_i,\quad \sigma^l=\sqrt{\frac{1}{H}\sum_{i=1}^H(a^l_i-\mu^l)^2} μl=H1​i=1∑H​ail​,σl=H1​i=1∑H​(ail​−μl)2 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7276a7538dc9506511edc5c83c1d634d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0548eeb2ed640d7f699a8b19de5d3de/" rel="bookmark">
			1、MPC 算法（模型预测控制算法（MPC算法）轨迹跟踪控制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MPC 跟踪圆形轨迹/直线轨迹MPC 跟踪双移线轨迹MPC 进行局部路径规划+轨迹跟踪MPC跟踪直线轨迹N MPC 对直线轨迹进行跟踪MPC 算法跟踪五次多项式曲线 以上为目录
推荐学习的软件：matlab （2019a）+carsim（2016）
无人驾驶知识架构：
第一层：全局路径规划 二 环境感知 三 行为和轨迹规划 四 轨迹追踪
全局路径规划 模块：规划出一条从当前位置到目标点之间成本最低的可行路线
算法：蚁群算法，遗传算法 a star算法
环境感知模块：毫米波 激光雷达 相机 GPS等
检测到周围的环境信息，路面 静态物体 动态物体
行为决策和轨迹规划模块：确定车辆的具体行为动作及可行的参考轨迹
轨迹跟踪模块：也就是执行模块，保证车辆在
车辆领域基本知识和定义（定义）
坐标系的知识：（右手定则来判断Z轴的正向）
三个角度的具体定义：
质心侧偏角：车辆质心速度方向与车辆纵轴方向的夹角 β
横摆角：车辆纵轴方向与大地坐标系X轴正向之间的夹角 航向角：车辆质心速度与大地坐标系x轴正向之间的夹角
课程内容：以MPC算法的理论基础为依据（状态空间方程，输出方程），借助线性误差模型帮助大家理解MPC算法
问题1：我们的运动学方程可不可以直接写成线性的状态空间方程？
问题2：怎么样把非线性的系统写成线性的状态空间方程？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42377452fe3fc0706e122eb8c77358f0/" rel="bookmark">
			Centos7脚本安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 创建shell脚本 1.1 脚本名字Install_mysql.sh vim install_mysql.sh
1.2 写入脚本内容 1.2.1 按字母i进入编辑模式 1.2.2 脚本内容 数据库密码为123456
mysql配置修改为可远程连接
#!/usr/bin/sh echo -e "\033[35m ------------------安装mysql-------------------- \033[0m" #查看有没有 rpm -aq| grep mariadb #卸载 rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 #创建mysql目录 mkdir -p /opt/mysql-5.7.28 #进入mysql安装目录 cd /opt/mysql-5.7.28 #安装wget，安装过的也无所谓 yum install -y wget #通过wget下载 wget https://cdn.mysql.com/archives/mysql-5.7/mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar #解压下载的tar包 tar -xvf mysql-5.7.28-1.el7.x86_64.rpm-bundle.tar # 安装 rpm -ivh mysql-community-common-5.7.28-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-5.7.28-1.el7.x86_64.rpm rpm -ivh mysql-community-client-5.7.28-1.el7.x86_64.rpm rpm -ivh mysql-community-server-5.7.28-1.el7.x86_64.rpm --force --nodeps # 启动mysql systemctl start mysqld #systemctl enable mysqld #获取密码 tmppasswd=`grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42377452fe3fc0706e122eb8c77358f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9862e038a87711fd7f4a9e7a953ad8a/" rel="bookmark">
			Unity Shader - Ray Marching Study Summary - 学习汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自学记录用
Ray Marching 字面意思就是：光线步进。
详细一些的说明：屏幕中每个像素放射一条射线，作为 光路逆向追踪，将光线所按照特定的步长来前进（步进），直到碰撞到SDFs函数几何体（SDFs是：(Signed Distance Fields的简写)），或是超出指定的最远距离，就停止步进。
根据碰撞后的几何体表面，得到世界坐标，计算出法线、等信息来做光照运算。
上面说的 光路逆向追踪，因为通常是我们相机或是眼睛是接收光线信息的，但根据光路可逆原理，所以我们从接收方发射射线，来模拟光线在接触到表面信息后的反射，折射，透射，散射，吸收等现象。
Ray Marching 的潜力，目前来说，手机硬件跑的话，还是比较耗的，PC上也耗。
但随着硬件不断升级，我相信有一天，会出现用SDFs函数建模的软件。
而现在的建模软件：3D MAX, Maya, ZBrush, Blender， 等，都是使用顶点来建模了。
SDFs这种建模才算真正的优美，使用的是一些距离函数模型（距离交集、并集、等），同样可以制作出千变万化的模型。
但是顶点建模的方式应该是不会淘汰的，因为有些简单渲染效果的，还是可以用的。
实例 Unity Shader - Ray Marching - T1 - SimpleSphereUnity Shader - Ray Marching - T2 - SimpleSphereAndPlaneUnity Shader - Ray Marching - T3 - GetSurfaceNormalsUnity Shader - Ray Marching - T4 - LightingSurfaceUnity Shader - Ray Marching - T5 - ShadowUnity Shader - Ray Marching - T6 - SoftShadowUnity Shader - Ray Marching - T7 - AO后续有空会回到继续学习：分材质着色后续有空会回到继续加上：ambient,specular,reflection,refraction,等效果后续有空会回到继续学习：体积光后续有空会回到继续学习：体积雾后续有空会回到继续学习：动态模糊 References ShaderToy里最佩服的人：IQ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9862e038a87711fd7f4a9e7a953ad8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d75281161ec3c3cc3da38f56d463d4d/" rel="bookmark">
			代码块（初始化块）和final关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码块作用：用来初始化类、对象。
2.代码块如果有修饰的话，只能用static修饰
3.分类：分为静态代码块和非静态代码块
4.静态代码块（可以定义多个静态代码块，按静态代码块定义的先后顺序执行）
&gt;内部可以有输出语句
&gt;随着类的加载而执行，因为类只加载一次，所以静态代码块也只执行一次
&gt;作用：对类的静态属性进行重新赋值
&gt;静态代码块只能调用静态的属性和静态的方法
5.非静态代码块（由于静态代码块是随着类的加载而执行的，而非静态代码块则是在类加载后执行的，因此非静态代码块是在静态代码块之后执行）
&gt;内部可以有输出语句
&gt;随着对象的创建而执行，因为可以创建多个对象，所以非静态代码块可以执行多次
&gt;作用：可以在创建对象时，对对象的属性进行初始化
&gt;非静态代码块除了调用非静态的属性和非静态的方法外还可以调用静态属性和静态方法
代码块在构造器之前执行
final：最终的
1.final可以修饰类、属性、方法
2.final修饰类则这个类就不能被其他类继承
3.final修饰方法则这个方法也就无法被重写
4.final修饰变量则这个变量就是常量无法被修改
4.1final修饰的变量为属性时：可以考虑的赋值位置有：显示初始化，代码块中初始化、构造器中初始化（一般是在显示初始化时赋值，当如果是final修饰后的常量在每个对象中都不相同时，则说明是在构造器中进行赋值，每个构造器中赋的值不同，通过调用不同的构造器来使创建的对象，final修饰的常量不同）
4.2final修饰的变量为局部变量时： 局部变量为常量无法修改（特别是当修饰的局部变量为形参时。我们是在调用时赋值，一旦在调用时赋值就说明无法修改，不能再在方法中修改）
static final：修饰属性：全局常量（static final还可以用来修饰方法）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ccf38bcd48da010b941989258e8246a/" rel="bookmark">
			OpenCV实现单目摄像头对图像目标测距
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用opencv对单目摄像头中的目标实现测量距离（python实现） 1.方法介绍： 根据相似三角形的方法：
F = P×D / W , 其中W为物体的实际宽度，D为物体平面与相机平面的距离，照片上物体的像素宽度为P，相机焦距为F
D = F×W / P ，这样知道相机的内参焦距就可以求得物体平面与相机平面的距离D
2.代码： import cv2 import imutils import numpy as np from imutils import paths # 获取目标的轮廓信息 def find_marker(image): gray = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) # 颜色空间转换函数，RGB和BGR颜色空间转换 opencv默认的颜色空间是BGR gray = cv2.GaussianBlur(gray, (5, 5), 0) # 高斯滤波，对图像进行滤波操作 ，（5,5）表示高斯核的大小 ，0 表示标准差取0 edged = cv2.Canny(gray, 35, 125) # canny 算子 边缘检测 35是阈值1， 125是阈值2，大的阈值用于检测图像中的明显边缘，小的阈值用于将不明显的边缘检测连接起来 cnts = cv2.findContours(edged.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE) # 找到详细的轮廓点， RETR_LIST 以列表的形式输出轮廓信息 # CHAIN_APPROX_SIMPLE： 压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标 cnts = imutils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ccf38bcd48da010b941989258e8246a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05dfadc2f1dbcb7ee449209bdad4f623/" rel="bookmark">
			CSAPP大作业程序人生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机系统
大作业
题 目 程序人生-Hello’s P2P 专 业 计算学部 学　号 班 级 学 生 指 导 教 师 吴锐 计算机科学与技术学院
2022年5月
摘 要
本文通过分析一个简单地hello程序，通过分析其预处理，编译，汇编，链接，进程，内存管理，I/O管理几大模块，即分析了hello的从编译到执行结束输出的过程，又将CSAPP所学的内容串联了起来
关键词：预处理；编译；汇编；链接；进程；内存管理；I/O管理 （摘要0分，缺失-1分，根据内容精彩称都酌情加分0-1分）
目 录
第1章 概述 1.1 Hello简介 1.2 环境与工具 1.3 中间结果 1.4 本章小结 第2章 预处理 2.1 预处理的概念与作用 2.2在Ubuntu下预处理的命令 2.3 Hello的预处理结果解析 2.4 本章小结 第3章 编译 3.1 编译的概念与作用 3.2 在Ubuntu下编译的命令 3.3 Hello的编译结果解析 3.4 本章小结 第4章 汇编 4.1 汇编的概念与作用 4.2 在Ubuntu下汇编的命令 4.3 可重定位目标elf格式 4.4 Hello.o的结果解析 4.5 本章小结 第5章 链接 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05dfadc2f1dbcb7ee449209bdad4f623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24bc402241b55e686712e47f59bd537/" rel="bookmark">
			什么是索引下推
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 索引条件下推优化（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询。
不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 网上搜了下相关的文章不少都将Index Condition Pushdown 称为索引下推优化，我认为还是索引条件下推优化更合适一些，因为这个优化技术关键的操作就是将与索引相关的条件由MySQL服务器向下传递至存储引擎，由此减少IO次数。MySQL服务器到存储引擎是向下，传递的是与索引列相关的查询条件，所以还是索引条件下推优化更容易理解一些。
适用条件 需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。引用子查询的条件不能下推。调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程。触发条件不能下推。 工作过程 既然是优化，我们要清楚优化了些什么就要了解原本是如何工作的，所以分为两部分来描述工作过程。
不使用索引条件下推优化时的查询过程
获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。
然后通过where条件判断当前数据是否符合条件，符合返回数据。
使用索引条件下推优化时的查询过程
获取下一行的索引信息。
检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。
用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。
EXPLAN分析 当使用explan进行分析时，如果使用了索引条件下推，Extra会显示Using index condition。并不是Using index因为并不能确定利用索引条件下推查询出的数据就是符合要求的数据，还需要通过其他的查询条件来判断。
图一：不使用ICP技术（过程使用数字符号标示，如①②③等）
过程解释： ①：MySQL Server发出读取数据的命令，这是在执行器中执行如下代码段，通过函数指针和handle接口调用存储引擎的索引读或全表表读。此处进行的是索引读。
if (in_first_read) { in_first_read= false; error= (*qep_tab-&gt;read_first_record)(qep_tab); //设定合适的读取函数，如设定索引读函数/全表扫描函数 } else error= info-&gt;read_record(info); ②、③：进入存储引擎，读取索引树，在索引树上查找，把满足条件的（经过查找，红色的满足）从表记录中读出（步骤④，通常有IO），从存储引擎返回⑤标识的结果。此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要进行进行步骤④，通常有IO。
⑥：从存储引擎返回查找到的多条元组给MySQL Server，MySQL Server在⑦得到较多的元组。
⑦–⑧：⑦到⑧依据WHERE子句条件进行过滤，得到满足条件的元组。注意在MySQL Server层得到较多元组，然后才过滤，最终得到的是少量的、符合条件的元组。
图二：使用ICP技术（过程使用数字符号标示，如①②③等）
过程解释： ①：MySQL Server发出读取数据的命令，过程同图一。
②、③：进入存储引擎，读取索引树，在索引树上查找，把满足已经下推的条件的（经过查找，红色的满足）从表记录中读出（步骤④，通常有IO），从存储引擎返回⑤标识的结果。
此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要在③这个阶段依据下推的条件进行进行判断，不满足条件的，不去读取表中的数据，直接在索引树上进行下一个索引项的判断，直到有满足条件的，才进行步骤④，这样，较没有ICP的方式，IO量减少。
⑥：从存储引擎返回查找到的少量元组给MySQL Server，MySQL Server在⑦得到少量的元组。因此比较图一无ICP的方式，返回给MySQL Server层的即是少量的、符合条件的元组。
另外，图中的部件层次关系，不再进行解释。
示例 假设有一张people表,包含字段name、address、first_name
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24bc402241b55e686712e47f59bd537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd911127701faf1cae9b8dd35bc80a4b/" rel="bookmark">
			我在体面的那几年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自我爱吃西红柿的投稿，大家对付着看一下。
"XX给不了你多少钱,但是能给你体面",这句话奠定了体面厂的由来。我当年入职的时候，不是因为这句话进来的，而是觉得在安防行业，也做到了第一，其他厂家也很难望其项背了，此外有个机会，给我转型的机会，让我转变当时比较窘迫的局面。
1.体面boy体面的一天 早上9点之前，到食堂吃饭，有15元的补贴。吃完早餐，然后就去工位，看看邮箱，有没有区域售后或者技术支持发来的现场问题，如果有的话，优先处理。如果没有，就继续开始昨天的工作，要么做客户端开发，要么就是后端服务开发，定制boy，你都得会，这样才是全面人才，比较符合岗位的需求。有时候会有项目经理来问问项目进度，有的人，喜欢一天问三四遍，有的啥也不问，就在最后一天问你。有时候摸摸鱼，就到了中午，看了一下手表，差不多11点半，这个时候可以出去吃饭了，想了一下到底是二楼还是三楼呢！想不好，就看看能挤上去那层的电梯吧，和同事一起吃饭，吃完饭了，围着办公楼溜达溜达，聊聊天，有时候抱怨着，有时候感觉自己为啥不能升职的那么快呢！哈哈哈哈，这就是人生呀！
溜达了一会，感觉时间差不多了，可以上楼了，这个时候电梯最堵了，只能选择坐倒梯。上了楼，拿出我的躺椅，睡在躺椅上，有时候没那么累，就看看手机，要是太累了，直接就睡着了。不过这个时候，有时候也有些傻逼，在洗手，大中午的打电话等可以创造噪声的活动，感觉人生就是这么无奈。只能在这嘈杂环境中，进行午休，甚是难受。时间很快就到了下午一点半，闹钟响了，收拾一下躺椅，然后去个厕所。回来赶紧开始干活，要是安排了会议，还需要去扯扯皮，没会议就按照项目需求表进行项目开发，或者写写项目需求文档，设计文档或系统集成测试用例，或代码审核，这个代码审核一定要进行审核，否则就会给你警告。代码审核，对于体面boy没啥意义，就是走个样子。下午集中精力干干活，有时候摸摸鱼。
晚饭时间到了，下去吃饭了，吃完饭继续遛弯，和关系比较好的，继续聊聊，多溜达几圈，毕竟还要加班，下班太早，不是啥好事。有时候，也遇到了同组同事说，今天怎么这么早走了。妈的，干完了不走，难道像你一样，坐在椅子上刷抖音，看新闻吗？要啥没啥，回到出租屋，还得开空调，还不如等到8点半，拿个体面值。我的内心在挣扎，有时候在想，为啥我要加那么多班，我自己也不怎么体面，还得住在那闭塞的出租屋里面。老子今天累了，感觉回家，就想躺在床上休息一会。可是好担心，小组长给的绩效。有时候，小组长问怎么回去那么早，都不知道怎么回答。到底是啥时候下班比较合适，走早了，次日早上问我，昨天是不是工作不饱和呀，走晚了，然后走到你的面前问我，是不是遇到什么困难了，能力不足之类的,自己真的不知道啥时候下班比较好，不知道这屁股啥时候挪来办公椅子才是正确的。
2.绩效考核 271的考核方式，在体面从来没有正式承认过，但是实际上一年四个季度，加上年终考核，总计五次绩效考核。为啥不承认呢，因为我们是国企控股呀，怎么可能存在这样的绩效考核呢！这个考核制度中，最搞笑的事情是，评分与你的绩效考核等级并没啥关系，即使你的评分在90分以上，但是你的绩效考核结果可能还是合格或者待提升。这绩效考核待提升比例需要按照部门来进行分配，即使你们整个组都挺好的，但是也要分个高低出来。比如你的态度不行了，你的这个文档出错太多了，你的现场问题太多了，哈哈哈哈，你能想象到的理由，都有可能是你拿到待提升的理由。等你拿到了待提升，下面就开始绩效考核，每隔一段时间，输出一篇总结，这是必不可少的，等到下个季度绩效考核，也许你就会发现，其实这个季度与上个季度，没啥鸡毛差别，给你待提升，真的是有指标呀！很多时候，领导觉得你行，你真的行，不行也行呀！下面简单说说绩效考核等级以及晋升制度。
优秀：基本工资+绩效工资*1.3
良好：基本工资+绩效工资*1.2
合格：基本工资+绩效工资
待提升：基本工资+绩效工资*0.8
这个天才的设计，加上一年五次季度考核，还有就是你离职的当月是没有绩效的，是不是很体面呀！对了，公积金缴纳是按照你的基本工资作为基数来缴纳的，不存在全额（基本工资+绩效工资）。你想想这里面有啥妙处在吗？就是你两年的时间里面，公积金可能都不会变动，是不是很体面了。这薪资制度设计的是不是很拿捏人性呢！五次考核，让你不敢动弹，要不然只要前面四次绩效考核一般，你的年终考核一般就不会太好了，辛辛苦苦干一年，然后就是白干了。
下面说说，岗位晋升，这里面有个岗位任职资格与岗位晋升的关系，并不是直接画等号的。任职资格是你岗位晋升的必要不充分条件，换言之，就是你有资格任职，但是没有实缺给你，你的岗位级别就是保持不变了。任职资格，需要准备一大堆材料来证明，你行哟，真的行，这里面也考核你的表达能力以及材料书写能力，你的PPT能力很重要的，别人问你问题，对答如流，基本上那这任职资格差不多就搞定了。听了我说的，是不是感觉很轻巧，对呀，实际操作上是由指标考核的，同等级任职资格，人数不能通过的太多了，没那么多的萝卜坑了。实际就是为了稳定你而已，给你一个希望，总体上，不如直接给你加薪水来的直接。不过有些待得时间长的人，人脉广， 升职的也相对较快。
3.加班强度 3.1工作日加班 加班强度，不同部门加班不一样，有的部门不加班，比如行政部门，以及财务部门，人家在四楼，就是大老爷，每次给自己排用餐时间，基本上都是第一个，不管怎么排列。这就是人生呀！不管你们部门怎么样，该加班就加班，要么摸摸鱼做做样子也要做加班，领个体面值再回家。给大家看看餐补的情况，以前是15元每次，现在是20元了。
看到这张图，也许大家能看出来体面boy在公司的时间有多久了吧，也许在公司摸鱼，可是你不摸鱼，早点走了，你的小组长会问你早点走呢！如果，你是负责海外的，时差比较大的情况下，那时间会更晚，因为海外研发同事可能在11点多找你呢！开会或者聊聊现场问题，毕竟要把任务完成呢！特别是今年以来，任务多，开发人员也少了，这么长时间在公司，可是公司又不是你家。没了生活，也没女朋友，也没时间陪家人，还有的时候，身体直接报警，肥胖以及幽梦螺杆菌伴随着你。体面厂开发在于安防行业是一个碎片化的场景，琐碎的事情太多了。让你不得不加班，当然最核心的问题是，你的小组长想让你通过加班，来控制你的时间，让你没时间学习，也没时间去跳槽，也没时间进行思考。
3.2大小周加班 疫情之前，喜欢在小周周六组织活动，团建，或者吃饭之类的，或者简单写写文档，感觉还不错。疫情来了，就没那么轻松了，团建的钱少了，任务也多了， 挤压了周六的休息时间。其实工作日加班就够了，没必要搞个小周，设计出来的小周，就是更多的压榨，让你更疲惫，没精力做其他的事情。工作日加班时间就很长了，周六你还没有休息时间，想想也是挺可怜的。人生的意义，不仅仅在于工作，还有更美好的事情等着你去探索呢！
4.培训 体面boy平常也会写有些培训的材料，大部分局限于业务知识相关的，比如你在做某个项目遇到的问题，以及我在遇到这个问题是如何思考的，但是新的知识基本上没有，所以你也不用想自己可以学习到多少。本质上，体面厂是以安防业务驱动的，你只要把业务做好，不出来，就可以基本上安稳在体面，也就是脉脉上常说的，我的小组长也没啥能力，一天天不干活，自己累死累活，还没啥好绩效的问题。薪水低，加班多，吸引过来的人，基本上不是同行业的人员，业务背景知识薄弱，对接其他人员，你自己比不过别人，再加上容易出错，这加班时间不就多了。体面boy也想着改变，可是基本上不太可能，除非你是研究院的，可能稍微好点，其他的就熬时间，熬资历吧！
5.股权激励 “拿到股权，等到抛售时候，迎娶白富美，登上人生巅峰，想想还是挺激动的”。如果你的股价在15元，70元的时候抛售，这中间的利差有多大，不言自喻了吧！现在的激励是29元，几年的解禁时间，捆绑在公司之下，2022年5月13日收盘价，如下图所示。
这股价，基本上可以达到了全民激励了吧，自己掏钱就可以购买了，不受公司的约束，就看你自己的钱包鼓不鼓，有多少钱了。有钱下周自然可以购买了，无拘无束的感觉特别好。其实很早就有人预测了股价，毕阿姨说的很委婉，应该是知道股价会下降的很厉害，就说可以一些很好听的话。结果大家也看到了，现在的股价与当时巅峰时期，差不多腰斩了。很多人，股权激励的时候，不得不买，不买就说明你想跑路了，哈哈哈哈，人生的选择是不是有点难。
6.竞业协议 没想到，这么快，就到了写竞业协议的事情了。看下图就知道了，其他的就不多说了，懂得人自然懂。竞业协议不是每个岗位都会启动的，可以根据 领导协商的，可以不启动的。
7.杂事 7.1服务器部署环境 体面厂很多海外业务是部署在windows操作系统上的，美其名曰，windows更稳定，有商业技术支持，海外用户更容易接受。这的确是windows操作系统系统的一个优势，微软定期打补丁，这个无可置疑。不过对研发人员就不是那么友好了，国内服务器跑的大多是Linux，如果你出去面试，别人看到你的简历上服务大部分是部署在windows操作系统上的，那么你的简历，有很大的概率会被pass掉。现在是2022年了，还在搞这一套，也就基本上绑定在一家公司上，可是公司不是慈善家，等不需要你的时候，一脚就把你踹开了，没啥不可能，以前不能，不代表以后不可能。
7.2公司食堂 以前食堂味道还不错，不过最近几年真的是每况愈下，一天不如一天了。对了，价格也开始涨上来了。
7.3 其他 有些事情不太方便说，不过可以私底下打听，或者去脉脉问问
8.感悟 1.公司不可能让每个人都舒服，如果舒服的话，我想这个不可能存在，即使你自己在家里面，也会被唠叨的，做好自己的心理预期管理，接受自己能接受的，不能忍受的，就赶紧跑路。
2.知识储备，关于这方面可以多看看极客时间的课程，有部分内容还是很不错的，可以看看。
3.摸鱼的时候，不要总想着摸鱼，自己知道想要的是啥，要想钱，就去找钱多的公司
4.时刻准备着，形势不对赶紧溜
5.如果你总是让自己处于很辛苦的状态，可是辛苦并不是你赚钱的前提条件，吃苦耐劳，那是老黄牛，如果你赚钱很轻松的话，为啥那么辛苦呢，可以多雇佣这样的老黄牛，你不必成为老黄牛呀！
6.体面需要大量的应届生就可以了，可是次年你不是应届生了，这个时候，你的优势在哪里呢？可以多想想，位子就那么多，你得想想是有坑留给你，让你做那个位子。
7.杭州房价不低，那点薪水，可真的不够用呢，不能总是租房子住吧，看自己选择
8.任何时候，都不要想着通过跳楼等自杀的方式来解决问题，因为解决不了，公司第一时间就是撇清关系，说你是有抑郁症等心理疾病等。
可以关注我的公众号 游学四方
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8c6645fb4e55fa6ca55eb8026e7fe6/" rel="bookmark">
			小程序，渲染层报错参数错误：LatLng.lat取值应在[-90,90]区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查longitude、latitude是否写反了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56217c03444e42a4c8e445b3f82dbd70/" rel="bookmark">
			matlab中geoshow函数的使用/属性设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 geoshow函数一般是用来在地图上进行画图的，可以进行画点、画线、画多边形等操作。自己会用到这几种绘画，做个记录。
举例有这样的经纬度坐标点：
lati = (30:51); lon1 = (120:130); longi = [lon1 lon1]; 可以直接用geoshow进行画点：
geoshow(lati ,longi,'DisplayType','point') 补充背景的地图部分：
worldmap('World'); worldmap([20 60],[100 140]); load coast %载入海岸线 plotm(lat,long) 呈现出来的效果为：
可以看到geoshow函数的DisplayType属性可以对所画形式进行更改，参考该函数的文档https://www.mathworks.com/help/map/ref/geoshow.html?s_tid=srchtitle_geoshow_1，有以下几种：
仍以画点为例，可以改变点型和颜色：
geoshow(lati,longi,'DisplayType','point','Marker','*','MarkerEdgeColor','black'); 除了画点之外，还可以画多边形并填充：
geoshow(flip(lati),flip(longi),'DisplayType','polygon','FaceColor','red') 这里做多边形填充的话需要flip一下，不然画出来的图是和下图填充部分相反的样子。
这部分关于颜色、透明度的设置方法应该是和其他一些画图函数是类似的。
画线：
geoshow(flip(lati),flip(longi),'DisplayType','line','Color','red','lineWidth',2) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/141/">«</a>
	<span class="pagination__item pagination__item--current">142/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/143/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>