<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9d6fa6146407634ba1101cb7a018ba/" rel="bookmark">
			php yield 数据库接口,php 通过 yield 实现协程有什么使用场景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协程可以用在，异步网络 IO 的时候，使其成为非阻塞的。
比如你在一个 http 请求里面，你需要请求外面的接口，那么会有下面的场景。
你的前置 server 是 nginx，nginx 是非阻塞异步的，但是 php-fpm 是同步阻塞的。那么当你在请求外面接口的时候，这个任务就会被阻塞。(这里补充一下，php-fpm 的 Worker 进程是同步阻塞的)
假设你使用协程，那么当你在请求接口的时候，你的这个任务就可以暂停，保存上下文。然后呢，当你的接口返回了之后，重新调起这个任务继续执行。你的进程就不必耗在这一个任务上了，可以去处理其它的 http 请求了。这样是不是并发量就高了？
同理，当你的请求在查询数据库的时候，也是一个 IO 请求，也是同步的。协程就可以让你这些 IO 编程异步非阻塞的，从而增大你的并发量。这主要是让你的 CPU 可以在等待 IO 的时候，可以处理别的事情。所有的 IO 请求都可以通过协程做到这一点。
你的这篇文章我看过，是很好的一篇文章。这里作者用 yield 实现了一个任务调度，就是干我上面说的那些事情的。你也可以看看鸟哥翻译的 http://www.laruence.com/2015/...，可以说是对你看到的这个翻译的一个补充。他通过 yield 实现了一个异步非阻塞的服务器，当然只是一个 demo 啦。有个例子看起来应该会好一点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9d147b1fabb51ad97525d080fa1036/" rel="bookmark">
			php ajax access,转载：解决Ajax跨域 Access to XMLHttpRequest问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误提示
Access to XMLHttpRequest at 'http://localhost:8080/api/user/login' from origin 'http://localhost
解决方案
1、HTML部分
ajax 请求加入 contentType: "application/x-www-form-urlencoded"
请求如下：$.ajax({
type: "post",
url: 'url',
contentType: "application/x-www-form-urlencoded",
data: {"gameCode": 106, type: "2",version:1,uid:1},
dataType: "json",
success: function (data,status) {
console.log(data);
}
});
2、PHP部分
PHP 文件中加入请求头部 header ('Access-Control-Allow-Origin: *') ;&lt;?php header('Access-Control-Allow-Origin: *');
$arr = [
array('id'=&gt;1,'title'=&gt;'one1'),
array('id'=&gt;2,'title'=&gt;'one2'),
array('id'=&gt;3,'title'=&gt;'one3'),
array('id'=&gt;4,'title'=&gt;'one4'),
];
echo json_encode($arr);
?&gt;
3、请求数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991bd706fcd0f8194d62b29825d70dfd/" rel="bookmark">
			metersphere如何实现常规接口测试，以及接口自动化场景分离实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步了解metersphere接口定义和接口自动化两个模块 在第一次使用最新版本metersphere，首先了解接口定义和接口自动化两个模块，自我理解总结：
接口定义：让我们定义接口，并对接口编写对应case；基本一个项目下面接口不可重复；此处也提供我们进行单个接口测试接口自动化：即针对定义的接口，以及case，按照场景组装自动化场景；当然你也可以在场景中自定义接口在使用metersphere前，需了解其内核基于jmeter【目前主流性能和接口测试工具之一】，我们如果在掌握jmeter前提下，学习此平台，事半功倍 其他功能可通过官网了解：https://www.fit2cloud.com/metersphere/index.html
开始我们接口测试 以下我们以登录接口和新增接口作为案列：
未完待续！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbede6df8080c3d31abb8457cdb3652/" rel="bookmark">
			【运筹学】指派问题、匈牙利法总结 ( 指派问题 | 克尼格定理 | 匈牙利法 | 行列出现 0 元素 | 试指派 | 打 √ | 直线覆盖 ) ★★★
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、克尼格定理二、匈牙利法引入三、指派问题求解步骤四、匈牙利法示例 11、第一步 : 使行列出现 0 0 0 元素示例2、第二步 : 试指派操作示例 ( 方法一 :克尼格定理 )3、打 √ ( 方法二 : 直线覆盖 )4、直线覆盖 ( 方法二 : 直线覆盖 ) 五、匈牙利法示例 21、第一步 : 变换系数矩阵 ( 每行每列都出现 0 元素 )2、第二步 : 试指派 ( 找独立 0 元素 ) 六、匈牙利法示例 31、使用匈牙利法求解下面的指派问题2、第一步 : 变换系数矩阵 ( 每行每列都出现 0 元素 )3、第二步 : 试指派 ( 找独立 0 元素 )4、第二步 : 试指派 ( 打 √ )5、第二步 : 试指派 ( 直线覆盖 )6、第二步 : 试指派 ( 第二轮 ) 一、克尼格定理 匈牙利法 主要用于解决指派问题 , 其主要依据是 克尼格定理 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbbede6df8080c3d31abb8457cdb3652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918df18eec60f1ba7d5215345eac8ec2/" rel="bookmark">
			小试牛刀kettle---CSV文件到XLS文件的转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一步：拉取文件格式第二步：输入端第三步:输出端第四步:启动第五步：是可以进行多次转换的 第一步：拉取文件格式 鼠标左击，然后拉取到空表位置，即如图所示。
输出的话，是Excel输出，也是左击鼠标，然后拖到中间位置。
按住shift键，然后鼠标左击CSV文件，然后拖到Excel输出的位置。于是图中就有了一个蓝线。
第二步：输入端 然后左击CSV文件，点击主输入步骤。
既然是CSV文件，列的分割符就是逗号(以逗号为分割的就是CSV文件)，
还可以预览一下数据。
预览完之后，发现正确读取数据，那么就点击确定。
上面的步骤的话，就是CSV输入文件做好了。
第三步:输出端 接下来就是做的是输出，左键双击Excel输出。
需要注意的是:文件名后的.xls去掉，否则的话就是.xls.xls，和文件的扩展名重复了。
注意一定要获取字段，不做这一步的话，就是空的转换。
点击完之后的结果。
点击最小宽度，进行设置格式。
格式设置完之后，最后点击确定。
第四步:启动 然后在运行之前，进行Ctrl +c，进行保存转换的代码。
就叫个01_快速体验file.xls。
步骤度量可以看一看。
点击预览数据的话，是一样的，因为只是格式的转换，数据是一样的。
这里的日志，没有飘红的话，都是正确的。
只显示错误日志。
设置日志的级别。
查看是否成功。
然后发现转换成功。
第五步：是可以进行多次转换的 然后打开之前保存的文件，发现有了小数位。
需要注意的是，再次运行的时候，要把这个结果文件，关掉才行，要不然的话，会报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78c3e0a8507f9411958acd96cfa1666/" rel="bookmark">
			不能在此路径中使用此配置节。如果在父级别上锁定了该节,便会出现这种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不能在此路径中使用此配置节。如果在父级别上锁定了该节,便会出现这种情况 不能在此路径中使用此配置节。如果在父级别上锁定了该节,便会出现这种情况。锁定
在全新安装的IIS7下搭建网站，访问页面时出现错误信息如下：
配置错误 不能在此路径中使用此配置节。如果在父级别上锁定了该节，便会出现这种情况。锁定是默认设置的(overrideModeDefault="Deny")，或者是通过包含 overrideMode="Deny" 或旧有的 allowOverride="false" 的位置标记明确设置的。 配置文件 \\?\X(盘符):\目录名\目录名\web.config
win10安装iis默认是IIS10，出现这些错误是因为以前搭的网站是IIS6版本的，所以安装IIS的时候要全勾选！！！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a7c365520996d39283c0fbb139e1f9/" rel="bookmark">
			@JsonIgnore不生效时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用
@JSONField(serialize = false)加载字段上，返回前端时会自动屏蔽掉这个字段 Fastjson的SerializerFeature序列化属性
QuoteFieldNames———-输出key时是否使用双引号,默认为true。
WriteMapNullValue——–是否输出值为null的字段,默认为false。
WriteNullNumberAsZero—-数值字段如果为null,输出为0,而非null。
WriteNullListAsEmpty—–List字段如果为null,输出为[],而非null。
WriteNullStringAsEmpty—字符类型字段如果为null,输出为”“,而非null。
WriteNullBooleanAsFalse–Boolean字段如果为null,输出为false,而非null。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2816f8fbd329ff1ed05bb8af013864d1/" rel="bookmark">
			获取应用签名信息和签名哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:获取签名的信息 keytool -v -list -keystore E:\projects\MyApplication\app\ddd.jks keyAlias 'demo' keyPassword '123456' storeFile file('demo.jks') storePassword '123456' 随后输入你的密钥库口令,我的秘钥库口令是123456,再次回车得到的结果: 密钥库类型: JKS 密钥库提供方: SUN 您的密钥库包含 1 个条目 别名: key01 创建日期: 2021-3-9 条目类型: PrivateKeyEntry 证书链长度: 1 证书[1]: 所有者: CN=ceshi, OU=ceshi, O=ceshi, L=ceshi, ST=ceshi, C=ceshi 发布者: CN=ceshi, OU=ceshi, O=ceshi, L=ceshi, ST=ceshi, C=ceshi 序列号: 334f3a98 有效期开始日期: Tue Mar 09 17:37:56 CST 2021, 截止日期: Thu Feb 13 17:37:56 CST 2121 证书指纹: MD5: 2C:F6:D8:5C:0D:27:88:84:9C:F4:1D:32:FB:59:4A:11 SHA1: BF:53:61:D0:44:2C:0E:AC:1A:00:66:41:84:F7:21:9E:AE:74:D7:0B SHA256: BC:92:F4:E3:EC:40:C4:28:FC:0A:5D:9D:50:8F:B4:FF:31:15:26:8E:4E:DC:76:36:A3:77:D8:09:C7:FB:ED:2A 签名算法名称: SHA256withRSA 版本: 3 扩展: #1: ObjectId: 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2816f8fbd329ff1ed05bb8af013864d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb1f9171f4372d59cd00425c360b0c1/" rel="bookmark">
			字符串正则做到每10个字符换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var str = "测试 ceshi 巴拉巴拉 娃哈哈 噼里啪啦 叽里呱啦"; str=str.replace(/[^\x00-\xff]/g,"$&amp;\x01").replace(/.{10}\x01?/g,"$&amp;\n").replace(/\x01/g,""); console.log(str);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed62a1ee0d683c4e2f192cdaed213b8/" rel="bookmark">
			Python学习第一天_安装学习软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python学习第一天 个人简介安装学习软件安装前先了解Python与Anaconda的区别本次我们一共安装两个软件 Anaconda安装安装过程检查Anaconda是否安装成功 Python开发工具——PyCharmPyCharm下载PyCharm安装PyCharm汉化 运行第一个Python程序PyCharm设置（个人推荐） 个人简介 本文由JAVA小白：林夕—梦雪编写
林夕—梦雪（本人）为自学者
如有错误请练习修改
欢迎各位道友提出建议
QQ:2190287907
安装学习软件 不管学习什么编程语言我们都需要安装学习软件
友情提醒：安装文件夹最好是英文名
安装前先了解Python与Anaconda的区别 Python：Python基本编译环境
Anaconda：是Python的发行版
…里面包含了Python和其需要的库文件
…所以学习可以只安装Anaconda即可
本次我们一共安装两个软件 分别是Python运行环境Anaconda和Python开发工具PyCharm
Anaconda安装 Anaconda官网：https://www.anaconda.com/
点击此跳转到Anaconda官网
进入官网后按下面的步骤进行下载并安装
如果有这个弹出则选保存
找到Anaconda安装文件后双击安装
安装过程 检查Anaconda是否安装成功 同时按住Win+R键，调出运行窗口
打开cmd窗口，输入python按回车，测试是否有Python运行环境
重新打开cmd窗口，输入conda --version
查看是否有conda环境（安装成不成主要看它）
最后在输入conda info，查看Anaconda是否配置完成
如果按照教程走就不会有其他的问题
安装完环境后接下来就是安装开发工具了
Python开发工具——PyCharm PyCharm下载 PyCharm官网
https://www.jetbrains.com/pycharm/
![版本](https://img-blog.csdnimg.cn/20210310035848743.png?x-oss-process=image/watermark,type_ZmFuZ3poZ
看需求选版本下载
这边先以免费教育版举例
点击免费教育版进入教育版下载界面
PyCharm安装 现在在我们的桌面就有了一个PyCharm软件
让我们双击运行一下它
现在我们就已经安装完成了
不过这个界面全是英语
对于像我这样的英语菜鸡来说不是很友好
所以接下来我们要进行汉化
把它变成中文的界面
PyCharm汉化 运行第一个Python程序 PyCharm设置（个人推荐） 然后调整显示范围
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2a403e33303ebb39df8eed1bf91523/" rel="bookmark">
			linux 的php怎么安装目录,linux如何查找php安装目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux中可以通过执行“ind / -name php”命令查找php安装目录，其源代码安装路径是“/usr/local/lib”，php配置文件的路径是“/usr/local/lib/php.ini”。
今天想要找到PHP的安装目录，找了网上说的默认目录(如下)，发现都没有，使用Linux指令“find / -name php”大致找到了范围，推荐遇到和我同样情况的linux菜鸟使用。
以下是默认路径：
apache:
1.用RPM包安装
安装路径： /etc/httpd
apache配置文件:/etc/httpd/conf/httpd.conf
Apache模块路径：/usr/sbin/apachectl
web目录:/var/www/html
2.如果采用源代码安装
/usr/local/apache2
php:
1.RPM包安装
安装路径：/etc/
php的配置文件:/etc/php.ini
2.源代码安装
安装路径：/usr/local/lib
php配置文件: /usr/local/lib/php.ini
或/usr/local/php/etc/php.ini
mysql:
1.RPM包安装
安装路径：/usr/share/mysql
mysqldump文件位置：/usr/bin/mysqldump
mysqli配置文件: /etc/my.cnf或/usr/share/mysql/my.cnf
mysql数据目录：/var/lib/mysql
源代码安装：/usr/local/mysql
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11368549218aab3473244f1e6e5eded/" rel="bookmark">
			php文章归档怎么做,php归档格式phar文件详解 | 木凡博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		phar (“Php ARchive”) 是PHP里类似于JAR的一种打包文件。如果你使用的是PHP5.3或更高版本，那么phar后缀文件是默认开启支持的，你不需要任何其他的安装就可以使用它。
phar归档文件有三种格式：tar归档、zip归档、phar归档，前两种执行需要php安装phar 扩展支持，用的也比较少，这里主要讲phar归档格式。
phar文件缺省状态是只读的，使用phar文件不需要任何的配置，部署非常方便。因为我们要创建phar文件，所以需要允许写入phar文件，这需要修改一下php.ini。找到phar.readonly将其修改为phar.readonly = off，注意不要忘记去掉前面的注释分号;。
一、创建phar文件
我们建立项目文件夹project，目录内结构如下：
static
-common.js
-app.css
lib
-liba.php
template
-msg.html
index.php
common.php
1
2
3
4
5
6
7
8
9
static
-common.js
-app.css
lib
-liba.php
template
-msg.html
index.php
common.php
项目文件有了，现在我们开始创建phar文件。首先在project同级目录下创建文件build.php，用于产生phar格式文件。内容如下：
PHP
/**
* @Author 木凡
* @DateTime 2020-04-24T15:03:49+0800
* @Domian http://mounui.com
*/
// 产生一个myphar.phar文件
$phar = new Phar('myphar.phar');
// 添加project里面的所有文件到myphar.phar文件
$phar-&gt;buildFromDirectory(dirname(__FILE__) . '/project');
// 设置执行时的入口文件，这里都设置为index.php。注意：如果项目不具备单一执行入口则不宜使用phar归档文件
$phar-&gt;setStub($phar-&gt;createDefaultStub('index.php'));
1
2
3
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c11368549218aab3473244f1e6e5eded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae2b4e392eaff1fff1716bacb3ade8c/" rel="bookmark">
			php manager如何安装目录,linux如何查看php安装目录？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux查看php安装目录的方法：1、Linux的php安装目录在没有设置自定义安装的情况下，一般默认的安装路径是在【/var/www】里面；2、使用Linux的命令进行查找，代码为【find / -name "*www*"】。
linux查看php安装目录的方法：
Linux的php安装目录在没有设置自定义安装的情况下，一般默认的安装路径是在/var/www里面，如果是自定义安装，只能回想经常安装在哪里，在慢慢寻找，还可以用Linux的命令进行查找，查找的命令：find / -name "*www*"。
扩展资料
Linux常用命令
1、cd /home 进入 '/ home' 目录' 。
2、cd .. 返回上一级目录 。
3、cd ../.. 返回上两级目录 。
4、cd 进入个人的主目录 。
5、cd ~user1 进入个人的主目录 。
6、cd - 返回上次所在的目录 。
7、pwd 显示工作路径 。
8、ls 查看目录中的文件 。
9、ls -F 查看目录中的文件 。
10、ls -l 显示文件和目录的详细资料 。
11、ls -a 显示隐藏文件 。
12、ls *[0-9]* 显示包含数字的文件名和目录名 。
13、tree 显示文件和目录由根目录开始的树形结构。
14、rm -f file1 删除一个叫做 'file1' 的文件' 。
15、rmdir dir1 删除一个叫做 'dir1' 的目录' 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae2b4e392eaff1fff1716bacb3ade8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ddce0da3785ee53fe7a52d872c06c5c/" rel="bookmark">
			Qml与C&#43;&#43;交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qml与C++交互 文档如是说，使用C ++代码中定义的功能可以轻松扩展QML。
由于QML引擎与Qt元对象系统的紧密集成，可以从QML代码访问由QObject派生的类适当公开的任何功能。
这使得C ++类的属性和方法可以直接从QML访问，通常很少或无需修改。
QML引擎能够通过元对象系统内省QObject实例。
这意味着，
任何QML代码都可以访问QObject派生类实例的以下成员： 属性（使用Q_PROPERTY注册的属性）方法（需注册为public slots或是标记为Q_INVOKABLE）信号
（此外，如果已使用Q_ENUMS声明枚举，则可以使用枚举。） 通常，无论是否已向QML类型系统注册了QObject派生类，都可以从QML访问它们。
但是，如果QML引擎要访问其他类型信息（例如，如果要将类本身用作方法参数或属性，或者要将其中一个枚举类型用于以这种方式使用），那么该类可能需要注册。
QML中调用C++类型 例子 颜色改变例子
新建一个ColorMaker类
colormaker.h文件如下：
#ifndef COLORMAKER_H #define COLORMAKER_H #include &lt;QObject&gt; #include &lt;QColor&gt; #include &lt;QTimerEvent&gt; class ColorMaker : public QObject { Q_OBJECT Q_ENUMS(GenerateAlgorithm) Q_PROPERTY(QColor color READ getColor WRITE setColor NOTIFY colorChanged) Q_PROPERTY(QColor timeColor READ timeColor) public: explicit ColorMaker(QObject *parent = 0); enum GenerateAlgorithm { RandomRGB, RandomRed, RandomBlue, RandomGreen, LinearIncrease }; QColor getColor() const; void setColor(const QColor &amp;color); QColor timeColor() const; Q_INVOKABLE GenerateAlgorithm algorithm() const; Q_INVOKABLE void setAlgorithm(GenerateAlgorithm algorithm); signals: void colorChanged(const QColor &amp;color); void currentTime(const QString &amp;timeStr); public slots: void start(); void stop(); protected: void timerEvent(QTimerEvent *e); private: GenerateAlgorithm m_algorithm; QColor m_currentColor; int m_nColorTimer; }; #endif // COLORMAKER_H colormaker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ddce0da3785ee53fe7a52d872c06c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d02b3df515f45dd439f8aabd1d99fdd/" rel="bookmark">
			迁移到行业标准格式PKCS12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决android创建签名,报"迁移到行业标准格式PKCS12"的问题
解决办法,使用命令创建
keytool -genkey -alias 填你的alias -keypass 你的alias密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore E:\projects\HEIF-converter-master\MyApplication\app\ddd.jks -storepass 你的签名密码 需要修改的就是
1.alias
2.alias密码
3.你的这个签名保存的路径,全路径
4.你的签名密码
回车后:
您的名字与姓氏是什么? [Unknown]: ceshi 您的组织单位名称是什么? [Unknown]: ceshi 您的组织名称是什么? [Unknown]: ceshi 您所在的城市或区域名称是什么? [Unknown]: ceshi 您所在的省/市/自治区名称是什么? [Unknown]: ceshi 该单位的双字母国家/地区代码是什么? [Unknown]: ceshi CN=ceshi, OU=ceshi, O=ceshi, L=ceshi, ST=ceshi, C=ceshi是否正确? [否]: y 都回车填好后,就可以在你填写的全路径下,看到生成的签名了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbd650714231c52b09b5a7c8f0c04d4/" rel="bookmark">
			QML鼠标事件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QML鼠标事件处理 鼠标事件分为click，doubleClick，drag，hover等 笔记内容在QmlBook In Chinese.pdf文件的55页左右 click事件： Image { id: root source: "images/background.PNG" Image { id: pole anchors.horizontalCenter: parent.horizontalCenter anchors.bottom: parent.bottom anchors.bottomMargin: 50 source: "images/pole.PNG" } Image { id: wheel anchors.horizontalCenter: parent.horizontalCenter source: "images/pinwheel.PNG" Behavior on rotation { NumberAnimation { duration: 500 } } } MouseArea { anchors.fill: pole onClicked: wheel.rotation += 180 } } 使用MouseArea指定点击区域，其中，
anchors.fill设置点击的范围（对象），
onclicked设置点击后的进行的操作
pressed和released事件 Rectangle { width: 400 height: 200 color: "lightblue" Text { anchors.horizontalCenter: parent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbd650714231c52b09b5a7c8f0c04d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6895b2544b98282ac7f62d894df9687/" rel="bookmark">
			QML-键盘按键事件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键盘按键事件处理 键盘事件分为通用事件和专用事件
键盘按键事件主要是键盘的左右上下按键，enter，tab键等
按键导航 1.Tab键使用：组件之间的导航，使用tab键进行导航 Rectangle { id: rect1 width: 200 height: 112 color: "lightblue" TextInput { id: name anchors.left: parent.left y: 16 anchors.right: parent.right text: "Field 1" font.pixelSize: 32 color: focus ? "black" : "blue" focus: false //true KeyNavigation.tab: age } TextInput { id: age anchors.left: parent.left y: 64 anchors.right: parent.right text: "Field 2" font.pixelSize: 32 color: focus ? "black" : "gray" KeyNavigation.backtab: name } } KeyNavigation.tab: age，按下tab键，将焦点导航到id为age的组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6895b2544b98282ac7f62d894df9687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeebb0bb7fdb510e9b3ff4852154b042/" rel="bookmark">
			Java 多关键字排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承 Comparable接口
一开始默认可以在类内部重写排序规则：
首先继承排序接口：Comparable&lt;Person&gt;
int compare(Person p1, Person p2) 返回一个基本类型的整型， 返回负数表示：p1 小于 p2， 返回0 表示： p1 和 p2相等， 返回正数表示：p1 大于 p2 所以重写排序规则的时候很灵活。如果类型是数字的话，可以直接用前一个减后一个， 其他类型用 compareTo 函数。 如果从大到小排就 return 的时候把 p1 and p2 调换一下。 package com.ytc.alpha; import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; public class Person implements Comparable&lt;Person&gt;{ private String name; private Integer age; public Person(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeebb0bb7fdb510e9b3ff4852154b042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d279922e29ae90dd3b4729f90b0dabf4/" rel="bookmark">
			新希望面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.hashmap 源码
2.arraylist 源码
3.stringbuffer 源码
4.synchronized 源码
5.线程池
6.rabbitmq
7.redis 缓存一致性
8.eureka 原理
9.fegin 原理
9.线程池和线程的区别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888b8496d8dbd514ff6f03024c393a71/" rel="bookmark">
			LLVM语言参考手册之标识符、类型与常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考网站：LLVM语言参考手册
摘要 LLVM是基于静态单赋值(SSA)的表示形式。之所以为单赋值，每个名字在SSA中仅被赋值一次。它可提供类型安全性，低级操作，灵活性并能清晰地表示“所有”高级语言的功能。它是在LLVM编译策略的所有阶段中使用的通用代码表示形式。
LLVM代码表示以三种不同的形式来使用：作为内存中的编译器IR，作为磁盘上的位代码表示（适用于即时编译器的快速加载）以及作为人类可读的程序集语言表示。这使LLVM可以为有效的编译器转换和分析提供强大的中间表示，同时提供调试和可视化转换的自然方法。LLVM的三种不同形式都是等效的。
1 标识符 两种基本类型：全局和本地。全局标识符(函数、全局变量)用’@‘字符开头；本地标识符(寄存器名称、类型)用’%'字符开头。
此外，还有三种不同的标识符格式：
命名值以带有前缀的字符串表示。例如%foo，@DivisionByZero， %a.really.long.identifier。实际使用的正则表达式为“ [%@][-a-zA-Z . ] [ − a − z A − Z ._][-a-zA-Z .]​[−a−zA−Z._0-9]*”。在名称中需要其他字符的标识符可以用引号引起来。可以使用"\xx"wherexx是十六进制字符的ASCII码对特殊字符进行转义。这样，任何字符都可以用在名称值中，甚至可以用引号引起来。该"\01"前缀可用于全局值以抑制重整。未命名的值以带有前缀的无符号数字表示。例如%12，@2，%44。常量。 LLVM要求值以前缀开头有两个原因：编译器无需担心带有保留字的名称冲突，并且将来可以扩展保留字的集合而不会带来任何损失。此外，未命名的标识符使编译器可以快速提出一个临时变量，而不必避免符号表冲突。
LLVM中的保留字与其他语言中的保留字非常相似。有一些关键字用于不同的操作码（“，add”，“ bitcast，”ret等），原始类型名称（“，void”，“i32等等”）等。这些保留字不能与变量名冲突，因为它们都不以前缀字符（’%‘或’@’）开头。
2 类型 LLVM类型系统是中间表示形式的最重要特征之一。类型化使许多优化可以直接在中间表示上执行，而不必在转换之前对另一方面进行额外的分析。
2.1 空类型(void type) 不代表任何值且没有大小
2.2 函数类型(function type) 由返回类型和形参类型列表组成。
2.3 first class type 该类型的值是唯一可以通过指令生成的值。
2.3.1 single value types (1) integer type:为所需的整数类型指定任意位宽度
examples:
i32 表示一个32位整数
i1942652表示一个超过1百万的超级大整数
(2) floating-point types
TypeDescriptionhalf16-bit floating-point valuebfloat16-bit “brain” floating-point value (7-bit significand). Provides the same number of exponent bits as float, so that it matches its dynamic range, but with greatly reduced precision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888b8496d8dbd514ff6f03024c393a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba20527b7279fbec1253d535f8677c0/" rel="bookmark">
			【PHP】CentOS 7使用yum安装php8.0及以上版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Centos7及以上版本中，默认的PHP版本为5，目前8.0版本业已正式发布了，若使用yum进行安装需要更换yum源。
步骤
查看是否有安装过PHP及已安装的版本： php -v 卸载已安装的低版本PHP: yum remove -y php* 安装yum工具类： yum install -y yum-utils 更换yum源： sudo yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm sudo yum install https://rpms.remirepo.net/enterprise/remi-release-7.rpm 为PHP 8启用流模块： sudo yum-config-manager --disable 'remi-php*' sudo yum-config-manager --enable remi-php80 安装PHP 8及扩展： sudo yum install -y php sudo yum install -y php-{extension_name} 查看是否安装： php -v 若：
则安装成功。注：安装完成后记得重启apache或nginx服务器。
测试PHP：
新建index.php文件： vi /var/www/html/index.php 在编辑状态下输入以下代码：
&lt;?php phpinfo(); 保存文件，您现在可以在Web浏览器中通过访问服务器的域名或公共IP地址（后跟/info.php）来查看此页面： http://your_domain_or_IP-address/info.php
若能正常访问则恭喜你已经成功安装了PHP 8了。
活动 阿里云活动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be9c082e685a7e49ef0182016c407d8/" rel="bookmark">
			Python文件操作之图片文件的读取与写入（复制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #二进制只读（照片是二进制存储） photo=open(r'C:\Users\Mxeron\Desktop\photo1.jpg','rb') #二进制写（这里没有photo2这个文件，它会自动创建） photo2=open('photo2.jpg','wb') photo2.write(photo.read()) photo.close() photo2.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d26511c696f06c16aa61cefdb24cfd5/" rel="bookmark">
			win10 wsl2 docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于在最新的win10 发行版中，更新的wsl2支持了GPU cuda 计算。而在最新的docker 中也支持了将wsl2 作为后端引擎，
这样一来，直接在win10 下安装docker，并下载启动镜像就能调用GPU。
只能说这一波操作太6， 微软牛逼，docker 牛逼！
具体做法如下，首先升级win10 到最新版，接着安装从docker 官网安装docker for windows
安装完成之后，打开docker 然后选择
即可。
随后即可在命令行中用docker 命令拉去docker镜像
docker pull nvidia:10.2
然后启动
使用下面的命令
docker run -d -it --name="centos" --gpus all mytorch:v1 /bin/bash
即可调用到GPU，
随后安装pytorch
pip install torch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bb467920d18bc972ffeaf9b1af4f76/" rel="bookmark">
			Spring事务传播属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献
Spring事务传播属性和隔离级别 https://www.cnblogs.com/eunice-sun/p/11024584.html
spring事务传播机制总结 https://blog.csdn.net/m18330808841/article/details/109543815
spring boot @Transactional注解事务不回滚不起作用无效 https://blog.csdn.net/zdyueguanyun/article/details/80236401?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control
正文
扫盲示例
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo-order&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo-order&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; application.properties
spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58bb467920d18bc972ffeaf9b1af4f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4442992d5f1ca67170516f2dc19347/" rel="bookmark">
			CVPR 2021 | 即插即用！ CA：新注意力机制，助力分类/检测/分割涨点！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
本文转载自：AI人工智能初学者
Coordinate Attention for Efficient Mobile Network Design论文：https://arxiv.org/abs/2103.02907代码链接（刚刚开源）：https://github.com/Andrew-Qibin/CoordAttention
本文提出Coordinate Attention，CA，可以插入到Mobile Network中，可以使MobileNetV2、EfficientNet等网络涨点，性能优于SE、CBAM等注意力模块，同时还可以提高检测、分割任务的性能，代码即将开源！
作者单位：南洋理工大学
1 简介 Mobile Network设计的最新研究成果表明，通道注意力（例如，SE注意力）对于提升模型性能具有显著效果，但它们通常会忽略位置信息，而位置信息对于生成空间选择性attention maps是非常重要。
因此在本文中，作者通过将位置信息嵌入到通道注意力中提出了一种新颖的移动网络注意力机制，将其称为“Coordinate Attention”。
与通过2维全局池化将特征张量转换为单个特征向量的通道注意力不同，coordinate注意力将通道注意力分解为两个1维特征编码过程，分别沿2个空间方向聚合特征。这样，可以沿一个空间方向捕获远程依赖关系，同时可以沿另一空间方向保留精确的位置信息。然后将生成的特征图分别编码为一对方向感知和位置敏感的attention map，可以将其互补地应用于输入特征图，以增强关注对象的表示。
本文所提的Coordinate注意力很简单，可以灵活地插入到经典的移动网络中，例如MobileNetV2，MobileNeXt和EfficientNet，而且几乎没有计算开销。大量实验表明，Coordinate注意力不仅有益于ImageNet分类，而且更有趣的是，它在下游任务（如目标检测和语义分割）中表现也很好。
2 相关工作 2.1 Mobile Network 最近的很多关于Mobile Network的工作大多数都是基于深度可分离卷积和inverted残差模块：
HBONet：在每个inverted残差模块中引入下采样操作，用于建模具有代表性的空间信息。
ShuffleNetV2：在inverted残差模块之前和之后使用通道分割模块和通道shuffle模块。
MobileNetV3：结合神经网络结构搜索算法，寻找最优激活函数和不同深度的inverted残差块的扩展比。
MixNet、EfficientNet和ProxylessNAS：也采用不同的搜索策略来搜索深度可分卷积的最优核大小或标量，从而从扩展比、输入分辨率、网络深度和宽度等方面控制网络权值。
最近，有学者重新思考了基于深度可分离卷积的方法，专门设计了基于Mobile Network的bottleneck结构，并基于此设计MobileNeXt。
2.2 注意力机制 想必大家都已经知道注意力机制在各种计算机视觉任务中都是有帮助，如图像分类和图像分割。其中最为经典和被熟知的便是SENet，它通过简单地squeeze每个2维特征图，进而有效地构建通道之间的相互依赖关系。
CBAM进一步推进了这一思想，通过大尺度核卷积引入空间信息编码。后来的研究如GENet、GALA、AA、TA，通过采用不同的空间注意力机制或设计高级注意力块，扩展了这一理念。
Non-local/self-attention Network则着重于构建spatial或channel注意力。典型的例子包括NLNet、GCNet、A2Net、SCNet、gsopnet和CCNet，它们都利用Non-local机制来捕获不同类型的空间信息。然而，由于self-attention模块内部计算量大，常被用于大型模型中，不适用于Mobile Network。
与Non-local/self-attention的方法不同，CA方法考虑了一种更有效的方法来捕获位置信息和通道关系，以增强Mobile Network的特征表示。通过将二维全局池操作分解为两个一维编码过程，本文方法比其他具有轻量级属性的注意力方法(如SENet、CBAM和TA)运行得更好。
3 Coordinate Attention 一个coordinate attention块可以被看作是一个计算单元，旨在增强Mobile Network中特征的表达能力。它可以将任何中间特征张量作为输入并通过转换输出了与 张量具有相同size同时具有增强表征的 。为了更加清晰的描述CA注意力，这里先对SE block进行讨论。
3.1 Revisit SE Block 在结构上，SE block可分解为Squeeze和Excitation 2步，分别用于全局信息嵌入和通道关系的自适应Re-weight。
Squeeze 在输入 的条件下，第 通道的squeeze步长可表示为:
式中， 是与第 通道相关的输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4442992d5f1ca67170516f2dc19347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18f21097226be4ddb0204bbcd013b0f/" rel="bookmark">
			不使用任何框架实现CNN网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 问题描述二、 设计简要描述三、程序清单四、结果分析五、调试报告六、实验小结 一、 问题描述 基于Numpy和函数im2col与col2im来实现一个简单的卷积神经网络，将其用于手写体识别。
二、 设计简要描述 机器学习的三个基本步骤——
程序设计思路——(此图放大可看清)
三、程序清单 1．卷积层实现
import numpy as np from main import im2col, col2im class Convolution: def __init__(self, W, b, stride=1, pad=0): self.W = W self.b = b self.stride = stride self.pad = pad # 中间数据（backward时使用） self.x = None self.col = None self.col_W = None # 权重和偏置参数的梯度 self.dW = None self.db = None def forward(self, x): FN, C, FH, FW = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18f21097226be4ddb0204bbcd013b0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7c6e7edc2fe8fdc052e0f4c627832a/" rel="bookmark">
			【自然语言处理入门笔记】—— 二元语法与中文分词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章学习了语言模型，为了学习语言模型参数，标注了微型语料库，在该语料库上使用极大似然估计法估计了二元语法模型的参数，捕捉了词语二元接续的统计知识，此外尝试了平滑策略缓解数据稀疏的问题，为了搜索最大概率的分词序列，将中文分词转化为有向无环图上的最短路径问题，为了高效求解词网上的最短路，学习并实现了维特比算法。此外还有模型调整的手段。但 OOV 召回仍然是 n 元语法模型的短板。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d3b12c926c6be03d494bbe004b8dfa/" rel="bookmark">
			js正则表达式验证用户名密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.js正则表达式用法 参考: https://www.runoob.com/js/js-regexp.html
2.验证用户名/密码 var pat=/[\w\u4e00-\u9fa5]{6,12}/ var username="我是用户名2fjlj" var r=pat.exec(username) if(r!=null){ if(r.length==username.length){ alert("用户名合法") } else{ alert("用户名必须为6-12位字母/数字/中文") } } else{ alert("用户名必须为6-12位字母/数字/中文") } JS的正则表达式 强：字母+数字+特殊字符 ^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)(?![a-zA-z\d]+$)(?![a-zA-z!@#$%^&amp;*]+$)(?![\d!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$ 中：字母+数字，字母+特殊字符，数字+特殊字符 ^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$ 弱：纯数字，纯字母，纯特殊字符 ^(?:\d+|[a-zA-Z]+|[!@#$%^&amp;*]+)$ //校验是否全由数字组成 function isDigit(s) { var patrn=/^[0-9]{1,20}$/; if (!patrn.exec(s)) return false return true } //校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串 function isRegisterUserName(s) { var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/; if (!patrn.exec(s)) return false return true } function isRegisterUserName(s) { var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/; if (!patrn.exec(s)) return false return true } //校验用户姓名：只能输入1-30个以字母开头的字串 Javascript代码 function isTrueName(s) { var patrn=/^[a-zA-Z]{1,30}$/; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d3b12c926c6be03d494bbe004b8dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb4e162f4e8dcd5c1eafe99679ebd21/" rel="bookmark">
			以代码流程方式探索Spring源码(九)--Bean实例化3--populateBean--IOC和DI执行的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以代码流程方式探索Spring源码--Bean实例化3--populateBean--IOC和DI执行的地方 入口:populateBean()对InstantiationAwareBeanPostProcessor的使用通过BeanPostProcessor进行属性依赖注入AutowiredAnnotationBeanPostProcessor的应用CommonAnnotationBeanPostProcessor的应用 入口:populateBean() 收集注解后，会对条件合适的bean进行三级缓存操作，这一步先跳过，与循环依赖一起研究。
目前我们已经通过实例化方法创建了我们的bean实例，但是是一个裸实例，存在于堆内存，但是没有属性值，在populateBean方法中进行属性的填充，这个时候回发生DI（依赖注入）。
对InstantiationAwareBeanPostProcessor的使用 首先依次执行实现了InstantiationAwareBeanPostProcessor的BeanPostProcessor的postProcessAfterInstantiation方法。因为这一步是发生的依赖注入之前的，所以可以自己实现一个B eanPostProcessor在对应的方法中返回false，这个地方就会直接短路return，从而不会执行依赖注入。
举个栗子：在这个地方可以针对某些具体的bean决定要不要执行依赖注入，还可进行其余的扩展。
通过BeanPostProcessor进行属性依赖注入 该处主要是对两个BeanPostProcessor的应用：
1、AutowiredAnnotationBeanPostProcessor
2、CommonAnnotationBeanPostProcessor
AutowiredAnnotationBeanPostProcessor的应用 先调用findAutowiringMetadata（）方法寻找有@Autowired注解的属性和方法。这次进入方法的时候可以直接从缓存中取了。因为我们在之前的注解收集阶段已经把相关的属性和方法解析为InjectionMetadata放在缓存中了。
在进行inject的时候，对于引用类型的注入，会触发对应Bean的实例化操作，即调用getBean()方法。
下面是对Field的注入
这个地方会出里@Value注解
先获取候选的Bean，单例情况下，候选Bean只有一个，走else分支，然后解析该Bean。
解析其实就是getBean()。
对方法上面的@Autowired注解的处理也是类似的，先处理参数，如果参数需要注入，同样会调用getBean()方法。
CommonAnnotationBeanPostProcessor的应用 最后才会进行xml文件中配置的属性依赖注入。过时的操作就不赘述了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f52e3d65c6067e50a41e8715d6359c/" rel="bookmark">
			docker连不上宿主机mysql_Docker从宿主机挂载卷到Mysql镜像之坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想实现容器内数据持久化，于是把宿主机的mysql数据挂载到了容器内，结果，后来发现mysql show databases都提示ERROR 1018 (HY000): Can't read dir of '.' (errno: 13 - Permission denied)
百度了下说是人为操作修改了mysql datadir的权限，还好之前看到过一篇帖子说，挂载了之后要手动修改回原来的root用户和组。chown -R mysql:mysql /var/lib/mysql #/your/path/to/datadir
我的/var/lib/mysql是我的mysql datadir，你的不一定和我一样，可以通过以下命令进入mysql中查询：mysql&gt; show variables like '%dir%';
+-----------------------------------------+----------------------------+
| Variable_name | Value |
+-----------------------------------------+----------------------------+
| basedir | /usr/ |
| binlog_direct_non_transactional_updates | OFF |
| character_sets_dir | /usr/share/mysql/charsets/ |
| datadir | /var/lib/mysql/ |
| ignore_db_dirs | |
| innodb_data_home_dir | |
| innodb_log_group_home_dir | ./ |
| innodb_max_dirty_pages_pct | 75.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f52e3d65c6067e50a41e8715d6359c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6c9003d0d77a829042740b70e5160c/" rel="bookmark">
			降维可视化（tSNE、UMAP、hypertools等）代码及效果对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习和深度学习领域，特征往往是高维度的，然而不幸的是，我们的电脑屏幕是二维的，我们的人眼也只能观察最多三维，所以必须对特征进行降维之后才能可视化。
一、准备工作：提取MNIST在LeNet5中的特征 方法很简单，我们在第一节的代码上修改，我们取出倒数第二个全连接层的输出特征，有84维。代码如下，多输出一个emb。
def forward(self, x): x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) x = F.max_pool2d(F.relu(self.conv2(x)), (2, 2)) x = x.view(-1, self.num_flat_features(x)) x = F.relu(self.fc1(x)) emb = F.relu(self.fc2(x)) x = self.fc3(emb) return emb,x 然后用训练好的模型过一遍数据集，得到数据集所有样本的嵌入向量embs，同时也收集labels用于后面按类别画图：
model.eval() embs = [] labels = [] for data, target in test_loader: data, target = data.cuda(), target.cuda() emb,output = model(data) embs.append(emb.data.cpu().numpy()) labels.append(target.data.cpu().numpy()) embs = np.concatenate(embs) labels = np.concatenate(labels) 二、使用sklearn中的t-SNE可视化 使用tSNE可视化不用更改网络结构，直接对原网络得到的输出进行处理即可，sklearn中已经封装好此功能：
from sklearn.manifold import TSNE tsne = TSNE(n_components=2, learning_rate=200, metric='cosine',n_jobs=-1) tsne.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c6c9003d0d77a829042740b70e5160c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89384bbca660ea6054367dc0bbb27d9a/" rel="bookmark">
			flink动态表中的窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 flink动态表中的窗口滚动窗口TableAPI方式 滑动窗口TableAPI方式 会话窗口TableAPI方式 FlinkSQL方式 接下来就是具体的例子Group Windows(1)ProcessTime1)TimeWindow1&gt;Tumble2&gt;Slide3&gt;Session 2) CountWindow(计数窗口没有sql写法)1&gt;Tumble_Count2&gt;Slide_Count (2)EventTime1)TimeWindow1&gt;Tumble2&gt;Slide3&gt;Session 2)CountWindow overwindow(没有滚动、滑动那一套)(1)ProcessTime(2)EventTime flink动态表中的窗口 Flink Window作用GroupWindow对window中的数据按照字段进行分组OverWindow在整个Window窗口的条件下，对数据进行统计操作等 Table API和SQL需要引入的依赖有两个：planner和bridge。
&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-java-bridge_2.12&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt; &lt;/dependency&gt; 滚动窗口 TableAPI方式 滚动窗口（Tumbling windows）要用Tumble类来定义，另外还有三个方法：
over：定义窗口长度
on：用来分组（按时间间隔）或者排序（按行数）的时间字段
as：别名，必须出现在后面的groupBy中
// Tumbling Event-time Window .window(Tumble.over("10.minutes").on("rowtime").as("w")) // Tumbling Processing-time Window .window(Tumble.over("10.minutes").on("proctime").as("w")) // Tumbling Row-count Window .window(Tumble.over("10.rows").on("proctime").as("w")) 滑动窗口 TableAPI方式 滑动窗口（Sliding windows）要用Slide类来定义，另外还有四个方法：
over：定义窗口长度
every：定义滑动步长
on：用来分组（按时间间隔）或者排序（按行数）的时间字段
as：别名，必须出现在后面的groupBy中
// Sliding Event-time Window .window(Slide.over("10.minutes").every("5.minutes").on("rowtime").as("w")) // Sliding Processing-time window .window(Slide.over("10.minutes").every("5.minutes").on("proctime").as("w")) // Sliding Row-count window .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89384bbca660ea6054367dc0bbb27d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab263b6623e88a10b946b7bf17a9307d/" rel="bookmark">
			C#跨窗体传值的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 转自：https://www.cnblogs.com/xh6300/p/6063649.html 创建一个Winform窗体应用程序项目，然后添加一个Form2窗体。
单击Form1中的button1，弹出Form2，然后要做的就是在Form1中的textBox1和Form2中的textBox2中传值。
为了方便起见，将Form1称作父窗体，将Form2称作子窗体。
相对来说，将父窗体的值传到子窗体较为容易实现。下面分别进行说明。
一、父窗体传值给子窗体。
方法1：通过Form类构造方法的重载传参。
Form1类中代码：
using System; using System.Windows.Forms; namespace WindowsForms跨窗体传值大全 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { Form2 f2 = new Form2(textBox1.Text); f2.ShowDialog(); } } } Form2类中代码：
using System; using System.Windows.Forms; namespace WindowsForms跨窗体传值大全 { public partial class Form2 : Form { public Form2() { InitializeComponent(); } public Form2(string str) { InitializeComponent(); textBox2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab263b6623e88a10b946b7bf17a9307d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f068c5238bb51c998eb3062577b553b2/" rel="bookmark">
			QT：QSS样式总结（后续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
只在本类中应用qss，子类不继承qss样式
当使用同一个类，想要一部分的部件是指定的qss样式
当使用同一个类，想要设置指定对象名称的qss样式
QListWidget
QTableWidget
QPushButton
只在本类中应用qss，子类不继承qss样式 很多情况下，给QWidget设置了qss，你会发现继承自QWidget的部件好像都继承了它的qss，如果不想继承的话，如下例一样设置qss即可！
//qss设置 .QPushButton{ border:1px solid rgb(143,143,143); background-color:white; color:black; } 当使用同一个类，想要一部分的部件是指定的qss样式 如下例代码，使用 [ ] 括起来的，使用键值对的方式。 ps：这里可以设置多个为指定的qss样式，只需要部件设置Property，和qss设置的匹配就可以
//qss设置 QPushButton[type=memberBtn]{ border:1px solid rgb(143,143,143); background-color:white; color:black; } //然后设置其属性为这个 QPushButton* btn = new QPushButton(this); btn-&gt;setProperty("type", "memberBtn"); 当使用同一个类，想要设置指定对象名称的qss样式 如下例代码，使用 # 符号，后面跟着objectName； ps：注意这里是指部件设置了objectName的部件才会生效qss。部件的objectName不能重复
//qss设置 QPushButton#memberBtn{ border:1px solid rgb(143,143,143); background-color:white; color:black; } //设置指定的部件应用 QPushbutton* btn = new QPushbutton(this); btn-&gt;setObjectName("memberBtn"); QListWidget QListWidget { outline:0px; //去除item选中时的虚线框 } QListWidget::item { height:40; //item高度 } QListWidget::item:hover { background: red; //悬停时item背景颜色 } QListWidget::item:selected { background: rgb(170, 170, 170);//选择item后的背景颜色 border:1px solid white; //选择item后的边框效果：大小，样式，颜色 } QTableWidget QHeaderView::section { color:black; //设置表头文字颜色 background-color:#D7D7D7; //设置表头背景颜色 border:1px solid #AAAAAA; //设置表头边框 } QPushButton QPushButton { color: white; //文字颜色 background: rgb(85, 85, 85); //按钮背景 border-radius: 4px; //边框半径，边框圆角效果 } QPushButton:hover { color: white; //悬停在按钮上的文字颜色 background: rgb(85, 85, 85); //悬停在按钮上的按钮背景 } QPushButton::pressed { padding-left: 2px; //左内边距，效果看上去文字产生的细微移动，达到用户按下的效果增强 padding-top: 2px; //右内边距 } QPushButton:checked { background:rgb(220,220,220);//按钮选中状态背景色，需要代码设置setCheckable(true)才能生效 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7007a643437c71bb1383f55d5768f1/" rel="bookmark">
			卷积和反卷积核计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 卷积 输出:
o u t _ s i z e = i n _ s i z e + 2 × p a d d i n g − k e r n e l _ s i z e s t r i d e + 1 out\_size = \frac{in\_size+2\times padding - kernel\_size}{stride} + 1 out_size=stridein_size+2×padding−kernel_size​+1
如果想让输入和输出大小一样，则stride必须为1，并且:
p a d d i n g = k e r n e l _ s i z e − 1 2 padding = \frac{kernel\_size-1}{2} padding=2kernel_size−1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7007a643437c71bb1383f55d5768f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c920c53d7828ee1a10a28ad0a6bc3d/" rel="bookmark">
			java host头攻击漏洞_URL存在http host头攻击漏洞-修复方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Nginx的修复方案
#注意Nginx的配置文件格式，空格之类的会影响规则
if ( $host !~* " 10.4.15.1| 10.9.4.9 " ) {
return 403;
}
基于tocmat的修复方案
经测试，最低支持Tomcat6.0.x以上版本的修复。
修复方式
打开tomcat的conf目录中的server.xml文件，将Host节点做如下配置：
unpackWARs="true" autoDeploy="true"
xmlValidation="false" xmlNamespaceAware="false"&gt;
10.1.8.158
prefix="localhost_access_log." suffix=".txt" resolveHosts="false"
pattern="%a %A %b %B %h %H %l %m %p %s %S %t %u %U %v %D %T" /&gt;
基于Filter的修复方案
修复方式
在工程的web.xml中配置下面代码中的拦截器，注意该拦截器一定要放在第一个执行。
最低支持Tomcat7.0.x以上版本的修复
范例代码
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
/**
* @author Shmily
*/
public class HostCleanFilter implements Filter {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c920c53d7828ee1a10a28ad0a6bc3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71eb29f5b5cee778bbeb48121a75a598/" rel="bookmark">
			入门级CC(Smart3D)照片建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、准备和设置 1、准备 单反相机：（没有相机用手机拍照也可以测试）
软件：CC(ContextCapture)，版本：CCCenter-partial-10.16.0.75.x64-en.msi
软件下载地址，也阔以自己在网上下载：
链接：https://pan.baidu.com/s/1m-TktbSsysCWFyI5q3bjfw
提取码：5lsc
素材下载地址：
链接：https://pan.baidu.com/s/1y8wu9f6KpjCg4zZBThmgzw
提取码：r5gh
2、拍照 尽量多拍几张，保证重叠度在65%之上吧，不管是俯拍还是斜拍，重叠度都要够
3、引擎设置等等 4、打开ContextCapture Center Engine，用于跑模型的引擎 开启之后，里面长这样
5、新建工程 工程名称和目录尽量都是中文，不容易出错
6、设置 这个目录和之前的引擎设置是一样的
二、数据和模型生成 1、导入照片 2、空三计算 一切设置默认
浏览一下空三成果，照片基本上是能够匹配上的
3、重建项目 调整下模型范围，左键放到框架上，按住移动即可，左键点到别处可以旋转
4、生成 一切设置默认
这个格式后续可以直接打开浏览
5、浏览模型 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6038342a394accf987bc4d7aa063be/" rel="bookmark">
			Spring5.0源码深度解析（注解驱动）-整体流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在基本所有的java应用都是面向Spring编程，那么Spring是如何加载Bean的？又是怎么解析@Configuration、@OnConditionalXXX、@Service、@Component、@Autowired、@Resource、@import等注解的？SpringAop的流程？ 本文主要从源码的角度深入剖析这些问题。
测试代码
public class MyApplication { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(TxConfig.class); String[] names = context.getBeanDefinitionNames(); Arrays.stream(names).forEach(s-&gt; System.out.println("bean："+s)); TxService bean = context.getBean(TxService.class); bean.doTx(); } } @Configuration @ComponentScan public class TxConfig { @Bean public TxService txService() { return new TxServiceImpl(); } } 总体来说，Spring对bean的装配分两个阶段，BeanDefinition加载和创建Bean实例，先来看下BeanDefinition加载。
BeanDefinition加载
public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) { this(); register(annotatedClasses); refresh(); } public AnnotationConfigApplicationContext() { // 构造方法中初始化reader 和 scanner this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this); } // 父类构造方法初始化beanFactory public GenericApplicationContext() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6038342a394accf987bc4d7aa063be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d14daf55abbe11f506607f3835adc1a/" rel="bookmark">
			【自然语言处理入门笔记】—— 词典分词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此章节实现了字典树、首字散列之后二分的 BinTrie、双数组字典树、AC 自动机以及基于双数组字典树的 AC 自动机，以上数据结构还可用于关键词过滤、简繁转换和拼音转换。但目前的词典分词实现还有准确率不高、无法区分歧义和召回新词等缺点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54df8677bd5ff97725facc2dc0450d2c/" rel="bookmark">
			信息学奥赛一本通_1.6编程基础之一维数组_05:年龄与疾病
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 05:年龄与疾病 总时间限制: 1000ms
内存限制: 65536kB
描述 某医院想统计一下某项疾病的获得与否与年龄是否有关，需要对以前的诊断记录进行整理，按照0-18、19-35、36-60、61以上（含61）四个年龄段统计的患病人数占总患病人数的比例。
输入 共2行，第一行为过往病人的数目n（0 &lt; n &lt;= 100)，第二行为每个病人患病时的年龄。
输出 按照0-18、19-35、36-60、61以上（含61）四个年龄段输出该段患病人数占总患病人数的比例，以百分比的形式输出，精确到小数点后两位。每个年龄段占一行，共四行。
样例输入 10 1 11 21 31 41 51 61 71 81 91 样例输出 20.00% 20.00% 20.00% 40.00% #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int main(){ int n,age[100],t1,t2,t3,t4; t1=t2=t3=t4=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;age[i]; if(age[i]&gt;=0&amp;&amp;age[i]&lt;=18){ t1++; }else if(age[i]&gt;=19&amp;&amp;age[i]&lt;=35){ t2++; }else if(age[i]&gt;=36&amp;&amp;age[i]&lt;=60){ t3++; }else if(age[i]&gt;=61){ t4++; } } cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)t1/n*100&lt;&lt;"%"&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)t2/n*100&lt;&lt;"%"&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)t3/n*100&lt;&lt;"%"&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)t4/n*100&lt;&lt;"%"&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e558c3874b13827d4a143acf4c367f72/" rel="bookmark">
			信息学奥赛一本通_1.6编程基础之一维数组_06:校门外的树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 06:校门外的树 总时间限制: 1000ms
内存限制: 65536kB
描述 某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。
由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。
输入 第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。
对于20%的数据，区域之间没有重合的部分；
对于其它的数据，区域之间有重合的情况。
输出 包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。
样例输入 500 3 150 300 100 200 470 471 样例输出 298 来源 NOIP2005复赛 普及组 第二题
#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int main(){ int L,M,x,y,a[10000],s=0; cin&gt;&gt;L&gt;&gt;M; for(int i=0;i&lt;=L;i++){ a[i]=1; } for(int i=0;i&lt;M;i++){ cin&gt;&gt;x&gt;&gt;y; for(int j=x;j&lt;=y;j++) a[j]=0; } for(int i=0;i&lt;=L;i++){ if(a[i]==1) s++; } cout&lt;&lt;s; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39abf2f770d6b9a1c3389ce3c784e7e7/" rel="bookmark">
			信息学奥赛一本通_1.6编程基础之一维数组_07:有趣的跳跃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		07:有趣的跳跃 总时间限制: 1000ms
内存限制: 65536kB
描述
一个长度为n（n&gt;0）的序列中存在“有趣的跳跃”当前仅当相邻元素的差的绝对值经过排序后正好是从1到(n-1)。例如，1 4 2 3存在“有趣的跳跃”，因为差的绝对值分别为3,2,1。当然，任何只包含单个元素的序列一定存在“有趣的跳跃”。你需要写一个程序判定给定序列是否存在“有趣的跳跃”。
输入
一行，第一个数是n（0 &lt; n &lt; 3000），为序列长度，接下来有n个整数，依次为序列中各元素，各元素的绝对值均不超过1,000,000,000。
输出
一行，若该序列存在“有趣的跳跃”，输出"Jolly"，否则输出"Not jolly"。
样例输入
4 1 4 2 3 样例输出
Jolly 来源
Waterloo local 2000.09.30
#include&lt;iostream&gt; #include&lt;cmath&gt; //abs标准库 #include&lt;algorithm&gt; //sort标准库 using namespace std; int a[1001],c[1001]; //定义数组，开大点防止溢出 （放在主函数前面定义，值默认为0） int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } for(int i=1;i&lt;n;i++) { c[i]=abs(a[i]-a[i+1]); //计算的差的绝对值 } sort(c+1,c+n); //排序 for(int i=1;i&lt;n;i++) { if(c[i]!=i) { cout&lt;&lt;"Not jolly"&lt;&lt;endl; //判断差是否在[1,n-1]之间 return 0; } } cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39abf2f770d6b9a1c3389ce3c784e7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cff98675e9d829cf58b0e8e8698ebf/" rel="bookmark">
			import cv2后ImportError: /usr/lib/x86_64-linux-gnu/libstdc&#43;&#43;.so.6: version `GLIBCXX_3.4.22‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卸载了opencv3.3重新用conda装了opencv3.4之后发现import cv2出现了
ImportError: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.22‘ not found
的错误
解决办法：
参考文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee08d6552e58c291494e5b052b2a337/" rel="bookmark">
			信息学奥赛一本通_1.6编程基础之一维数组_09:向量点积计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 09:向量点积计算 总时间限制: 1000ms
内存限制: 65536kB
描述 在线性代数、计算几何中，向量点积是一种十分重要的运算。
给定两个n维向量a=(a1,a2,...,an)和b=(b1,b2,...,bn)，求点积a·b=a1b1+a2b2+...+anbn。
输入 第一行是一个整数n。1 &lt;= n &lt;= 1000。
第二行包含n个整数a1,a2,...,an。
第三行包含n个整数b1,b2,...,bn。
相邻整数之间用单个空格隔开。每个整数的绝对值都不超过1000。
输出 一个整数，即两个向量的点积结果。
样例输入 3 1 4 6 2 1 5 样例输出 36 #include&lt;iostream&gt; using namespace std; int main(){ int n,a[1000],b[1000]; long long c[1000],s=0;//避免值太大溢出 cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;n;i++){ cin&gt;&gt;b[i]; } for(int i=0;i&lt;n;i++){ c[i]=a[i]*b[i]; s+=c[i]; } cout&lt;&lt;s&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c8fdfeb32b8f4bde8d7a1850e27a35/" rel="bookmark">
			信息学奥赛一本通_1.6编程基础之一维数组_08:石头剪刀布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		08:石头剪刀布 总时间限制: 1000ms
内存限制: 65536kB
描述 石头剪刀布是常见的猜拳游戏。石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。
一天，小A和小B正好在玩石头剪刀布。已知他们的出拳都是有周期性规律的，比如：“石头-布-石头-剪刀-石头-布-石头-剪刀……”，就是以“石头-布-石头-剪刀”为周期不断循环的。请问，小A和小B比了N轮之后，谁赢的轮数多？
输入 输入包含三行。
第一行包含三个整数：N，NA，NB，分别表示比了N轮，小A出拳的周期长度，小B出拳的周期长度。0 &lt; N,NA,NB &lt; 100。
第二行包含NA个整数，表示小A出拳的规律。
第三行包含NB个整数，表示小B出拳的规律。
其中，0表示“石头”，2表示“剪刀”，5表示“布”。相邻两个整数之间用单个空格隔开。
输出 输出一行，如果小A赢的轮数多，输出A；如果小B赢的轮数多，输出B；如果两人打平，输出draw。
样例输入 10 3 4 0 2 5 0 5 0 2 样例输出 A 提示 对于测试数据，猜拳过程为：
A：0 2 5 0 2 5 0 2 5 0
B：0 5 0 2 0 5 0 2 0 5
A赢了4轮，B赢了2轮，双方打平4轮，所以A赢的轮数多。
#include&lt;iostream&gt; using namespace std; int main(){ int n,na,nb,a[100],b[100],x=0,y=0; cin&gt;&gt;n&gt;&gt;na&gt;&gt;nb; for(int i=0;i&lt;na;i++){ cin&gt;&gt;a[i]; for(int j=0;j&lt;n;j=j+na) a[na+j+i]=a[i];//循环赋值 } for(int i=0;i&lt;nb;i++){ cin&gt;&gt;b[i]; for(int j=0;j&lt;n;j=j+nb) b[nb+j+i]=b[i]; } for(int i=0;i&lt;n;i++){ if((a[i]==0&amp;&amp;b[i]==2)||(a[i]==2&amp;&amp;b[i]==5)||(a[i]==5&amp;&amp;b[i]==0))//a获胜 x++; if((b[i]==0&amp;&amp;a[i]==2)||(b[i]==2&amp;&amp;a[i]==5)||(b[i]==5&amp;&amp;a[i]==0))//b获胜 y++; } if(x&gt;y) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c8fdfeb32b8f4bde8d7a1850e27a35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb05f92ed06b0770dd9fc73ecfe8f34/" rel="bookmark">
			Spring-IOC初学-03-IOC创建对象的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 几种构造方式(还有几种详见文档)： https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans
里面搜索：基于构造函数的依赖关系注入就可以搜到以下方法
1.
&lt;property name="name" value="lyc"&gt;&lt;/property&gt; public class Userdaoimpl implements Userdao{ private String name; //以下几点内容对应添加到此处 public String getName() { return name; } ​ public void setName(String name) { this.name = name; } ​ public void getUser() { System.out.println("用户获取数据"+name); } } 2.
&lt;constructor-arg type="int" value="7500000"/&gt; public Userdaoimpl(int i) { System.out.println(i); } 3.
&lt;constructor-arg type="java.lang.String" value="42"/&gt; public Userdaoimpl(String s) { System.out.println(s); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610f76084fc04abc09427520883ebcb6/" rel="bookmark">
			15.Idea搭建Flink项目Java和Scala混合项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink实战 1. 创建项目步骤2. 添加pom.xml3. 编写代码进行测试4. 在idea中调试flink spark 程序 1. 创建项目步骤 安装scala 2.11.8在idea中安装scala插件，并且导入scala
创建普通的maven项目，创建scala相关文件夹，并且标记source 和 test
给这个module添加scala依赖
2. 添加pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xiaofan&lt;/groupId&gt; &lt;artifactId&gt;FlinkDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;flink.version&gt;1.11.3&lt;/flink.version&gt; &lt;scala.binary.version&gt;2.11&lt;/scala.binary.version&gt; &lt;lombok.version&gt;1.18.16&lt;/lombok.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--scala依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;2.11.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--flink java--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_2.11&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--scala编译插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.scala-tools&lt;/groupId&gt; &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt; &lt;version&gt;2.15.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;scala-compile-first&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;includes&gt; &lt;include&gt;**/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610f76084fc04abc09427520883ebcb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ee733aaf7daa71845e8aabbd95fb39/" rel="bookmark">
			EFCore使用MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EFCore使用SQL Server应该是鼻祖了吧，哈哈！不过使用MySQL的就比较少见了，至少官网是没有引导的。因为不是MySQL微软的东西嘛，当然推崇SQL Server了；不过MySQL相对SQL Server更为轻量一些，我们就来简单整理下吧！Model层NuGet包如下：
1、Microsoft.EntityFrameworkCore.Design
2、Microsoft.EntityFrameworkCore.Tools
3、MySql.EntityFrameworkCore
4、Microsoft.EntityFrameworkCore
5、Microsoft.EntityFrameworkCore.Relational
对了，MySQL还可以安装连接Visual Studio和.NET的组件，需要注意的是，目前直连Visual Studio的版本仅支持到Visual Studio 2017，Visual Studio 2019暂时还没有相关的组件，不过并不影响使用。
编写SysContext
public class SysContext : DbContext { public SysContext(DbContextOptions&lt;SysContext&gt; options) : base(options) { } public DbSet&lt;Student&gt; Student { get; set; } } 编写一个实体类，做一下简单Code First验证：
public class Student { [Key] public string Id { get; set; } public string Name { get; set; } public string Number { get; set; } public string Address { get; set; } } 同样，Web层也NuGet相同的包！在Startup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4ee733aaf7daa71845e8aabbd95fb39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8efaf33cf6f2c44257fa462901086af3/" rel="bookmark">
			Java实现18位身份证号码的校验码计算校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我国第二代公民身份号码是特征组合码，由前十七位数字本体码和最后一位数字校验码组成。排列顺序从左至右依次为六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。本文只介绍最后一位数字校验码的计算校验。
校验码算法 将本体码各位数字乘以对应加权因子并求和，除以11得到余数，根据余数通过校验码对照表查得校验码。
加权因子：
校验码：
算法举例：
本体码为：11010519491231002
第一步： 各位数与对应加权因子乘积求和1*7+1*9+0*10+1*5+***=167
第二步：对求和进行除11得余数167%11=2
第三步：根据余数2对照校验码得X
因此完整身份证号为：11010519491231002X
代码实现 由校验码算法，我自己写了以下代码
public class TimTest { // Java实现18位身份证号码的校验码计算校验 public static void main(String[] args) { // 从百度百科中找到的身份证号码例子 String idCard = "53010219200508011X"; System.out.println(idCardVerify(idCard) ? "身份证号码校验通过" : "身份证号码不合法"); } static boolean idCardVerify(String idCard) { // 仅适用于18位标准身份证号码 if (idCard.length() != 18) { return false; } // 使身份证号码中的字母升大写 idCard = idCard.toUpperCase(); char[] idCardChars = idCard.toCharArray(); // 重点1：加权因子计算 final int[] factors = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2}; int sumFactor = 0; for (int i = 0; i &lt; factors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8efaf33cf6f2c44257fa462901086af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130094fe7fe19d21e017636e8fb13317/" rel="bookmark">
			利润计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业发放的奖金根据利润提成。利润低于或等于100000元的，奖金可提10%; 利润高于100000元，低于200000元（100000&lt;I≤200000）时，低于100000元的部分按10％提成，高于100000元的部分，可提成 7.5%; 200000&lt;I≤400000时，低于200000元部分仍按上述办法提成，（下同），高于200000元的部分按5％提成； 400000&lt;I≤600000元时，高于400000元的部分按3％提成； 600000&lt;I≤1000000时，高于600000元的部分按1.5%提成； I&gt;1000000时，超过1000000元的部分按1%提成。从键盘输入当月利润I,求应发奖金总数 程序
#include&lt;stdio.h&gt;
int main(){
int i,j;
scanf("%d",&amp;i);
if(i&lt;=100000)
j=i0.1;
else if(i&gt;100000&amp;&amp;i&lt;=200000)
j=i0.1+(i-100000)0.75;
else if(i&gt;200000&amp;&amp;i&lt;=400000)
j=i0.1+(i-100000)*0.75+(i-200000)0.5;
else if(i&gt;400000&amp;&amp;i&lt;=600000)
j=i0.1+(i-100000)*0.75+(i-200000)*0.5+(i-400000)0.3;
else if(i&gt;600000&amp;&amp;i&lt;=1000000)
j=i0.1+(i-100000)*0.75+(i-200000)*0.5+(i-400000)*0.3+(i-600000)0.15;
else
j=i0.1+(i-100000)*0.75+(i-200000)*0.5+(i-400000)*0.3+(i-600000)*0.15+(i-1000000)*0.1;
printf("%d\n",j);
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/189/">«</a>
	<span class="pagination__item pagination__item--current">190/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/191/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>