<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88a84cf83cadbce2b81f0adf49d0107/" rel="bookmark">
			OFDM符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OFDM (Orthogonal Frequency Division Multiplexing) ，即正交频分复用，是一种用于数字通信的调制技术，它将数据流分为多个子载波，每个子载波都以不同的频率传输数据，被广泛应用于现代数字通信系统中，如Wi-Fi，DAB，DVB，LTE，5G NR等。OFDM 符号是 OFDM 技术中的一个重要组成部分，它是在子载波上传输信息的基本单位。
OFDM 符号由一组正交的子载波组成，每个子载波上携带独立的信息。因为子载波之间正交，所以它们可以在同一频段上同时传输信息，从而实现了高效的频谱利用。OFDM 符号通常使用快速傅里叶变换（FFT）来实现，将时域的数据序列转换为频域的子载波信号。
OFDM 符号的特点是抗多径衰落和频偏干扰能力强，同时也容易实现频率同步。OFDM 技术已经成为现代数字通信系统中的一种关键技术，为高速数据传输提供了有效的解决方案。
OFDM符号有3个不同的特性，分别是正交、频分、复用。
标题1. OFDM的基本原理和概念 三级标题1.1. 子载波和符号 1.1.1. 子载波
子载波（subcarrier）是数字通信中的一个概念，它是在正交频分复用（OFDM）系统中使用的一种调制技术。在OFDM系统中，将宽带信号分成多个独立的子信道，每个子信道都可以看作是一个独立的信号载波，称为子载波。
在OFDM系统中，将频率范围分成多个子载波，每个子载波都有一个固定的频率和相位，可以独立传输数据，如5G NR系统中，将100MHz的带宽，按照15KHz的子载波带宽进行分配，可以分成3000都个子载波，而4G LTE 20MHz系统中的子载波仅有372个。每个子载波的频带宽度比整个带宽窄很多，这样可以减少频带的浪费，并且在接收端可以更容易地进行信号分离和恢复。
OFDM系统中使用的子载波数量往往非常大，因此可以同时传输多个独立的数据流。这种技术在现代数字通信中得到了广泛的应用，例如在Wi-Fi、LTE、数字电视等领域。
子载波的波形图如下图所示：
1.1.2. 符号
从时域上来看，ODFM符号就是一个时间长度。利用了OFDMA原理中的串并变换技术，原本高速的串行数据被转换成低速的并行数据发送，原来传N个符号（数字映射后的符号，譬如每个QPSK符号包含2个比特）的时间，现在相当于只传一个符号（但由于并行传输，N个子载波上各传一个，相当于同时传N个，只是这N个子载波之间互相独立，并且所代表的数据仅是原始数据中的一小部分）。所用的这个时间成为OFDM符号长度，或OFDM符号周期。
在实际中，为了消除符号间的干扰，还要在符号间插入循环嵌缀（CP），即经过IFFT之后的发送数据经过并串变换，把位于最末的CP长度的符号拷贝到OFDM符号的起始端，用于消除符号间干扰。这时，实际的每个OFDM符号的长度变为T_symbol+T_cp,你所看到的IFFT长度+CP长度是以OFDM符号周期为单位的表示方法。
1.1.3. 子载波间隔与符号长度之间的关系
OFDM技术中，符号长度（也称为时域上的时间长度）为T的子载波在频域上是一个Sinc函数，在1/T处过零。为了满足正交性，各个子载波的峰值应该对应于其他子载波的过零点。因此，子载波的间隔应为1/T。例如，在5G NR中，子载波的间隔为15kHz，因此OFDM的符号长度为1/15kHz=66.7us。这个长度是子载波的调制符号时间，也是器件物理处理的时间。
三级标题1.2. 正交性和频域均衡 正交性是OFDM系统中的一个重要特性，它是指在一个OFDM符号中，不同子载波之间的频率间隔是相等的，同时它们之间也是正交的。这意味着，当一个符号通过正交调制发送到接收端时，每个子载波的频率仅受到该子载波上的数据影响，而不会受到其他子载波的影响。这种正交性减少了多径干扰，同时也允许同时传输多个数据流。
频域均衡是OFDM系统中的另一个重要特性，它是指在接收端，对不同子载波的信号进行均衡处理，以消除各个子载波之间的干扰和失真。因为不同子载波的信号经过传输之后可能会出现频率偏移和衰减，导致不同子载波之间的信号强度不均衡，进而导致接收到的信号失真。频域均衡可以通过在接收端对不同子载波进行加权处理来实现，使得各个子载波之间的信号强度平衡，从而提高信号质量和可靠性。
三级标题1.3. 快速傅里叶变换（FFT）和逆变换（IFFT） 快速傅里叶变换（FFT）和逆变换（IFFT）是信号处理领域中广泛使用的算法。FFT将时域信号转换为频域信号，而IFFT将频域信号转换回时域信号。
傅里叶变换是一种将时域信号转换为频域信号的方法，它可以将信号分解为一系列正弦波和余弦波的和。FFT是一种用于计算傅里叶变换的快速算法，它可以大大减少计算复杂度，因此在实际应用中得到广泛使用。
逆傅里叶变换是一种将频域信号转换回时域信号的方法，它将傅里叶变换的结果重新组合成原始信号。IFFT是一种用于计算逆傅里叶变换的快速算法，与FFT类似，可以大大减少计算复杂度。
FFT和IFFT可以应用于许多领域，包括音频处理、图像处理、信号处理等等。例如，在音频处理中，FFT可以用于将音频信号转换为频谱图，而IFFT可以用于将频谱图转换回音频信号。
标题2. OFDM的优缺点和应用 三级标题2.1. 高频带利用率和频谱效率 OFDM的另一个优点是它能够提高频谱效率。通过将高速数据分割成多个低速子载波并分配到不同的频率上，OFDM能够在相同的带宽内传输更多的数据，从而提高频谱效率。
三级标题2.2. 抗多径干扰能力 OFDM的主要优点之一是它能够有效地抵抗多径衰落，即信号被反射、折射和干扰的情况。这是因为OFDM使用多个独立的子载波进行数据传输，这些子载波之间正交，因此彼此独立，使得信号在多径传播环境中也能够更加稳定地传输。
三级标题2.3. 复杂性和功率效率 OFDM技术的复杂性主要在于需要进行频域均衡、同步、多路径干扰等方面的处理，这些处理需要复杂的算法和硬件实现。例如，在OFDM接收端，需要进行FFT（快速傅里叶变换）来将子载波从频域转换到时域，进行时域均衡和解调。
OFDM技术的功率效率在很大程度上受到峰均功率比（PAPR）的影响。由于OFDM中每个子载波可以独立调制，因此可能会出现部分子载波幅度增强的情况，导致整个信号的PAPR增加。高PAPR会使功率放大器的非线性失真，降低功率效率。为了解决PAPR问题，OFDM技术通常采用一些技术，如信号削峰技术、部分传输序列（PTS）技术和选择性映射技术，来减小PAPR。
三级标题2.4. 无线通信和数字电视等应用场景 OFDM技术被广泛应用于Wi-Fi、4G LTE、5G等无线通信标准中，成为实现高速数据传输和频谱利用率的重要技术。
在数字电视中，OFDM技术也得到了广泛的应用。数字电视信号需要在有限的频谱范围内传输大量的音视频数据，OFDM技术可以将频段分成多个子载波，每个子载波只携带一部分数据，因此可以提高频谱效率。OFDM技术被应用于各种数字电视标准中，如欧洲的DVB-T、美国的ATSC和中国的DTMB等。
除此之外，OFDM技术还被广泛应用于无线局域网（WLAN）、数字音频广播、航空通信、有线电视和数字语音等领域。由于OFDM技术的高效性和灵活性，它已经成为数字通信领域的核心技术之一。
三级标题2.5. OFDM的缺点 (1) 噪声增益：由于OFDM使用了多个子载波来传输数据，因此在接收端，多个子载波叠加在一起，这样可能会导致噪声的增益。这意味着即使在低信噪比环境下，OFDM系统也可能无法提供良好的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88a84cf83cadbce2b81f0adf49d0107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f592f427357b5f88acded5951c49ac1/" rel="bookmark">
			层次分析法在matlab上的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		层次分析法（The analytic hierarchy process）简称AHP，在20世纪70年代中期由美国运筹学家托马斯.塞蒂（T.L.saaty）正式提出。它是一种定性和定量相结合的、系统化、层次化的分析方法。由于它在处理复杂的决策问题上的实用性和有效性，很快在世界范围得到重视。它的应用已遍及经济计划和管理、能源政策和分配、行为科学、军事指挥、运输、农业、教育、人才、医疗和环境等领域。
计算步骤 1、建立层次结构模型。在深入分析实际问题的基础上，将有关的各个因素按照不同属性自上而下地分解成若干层次，同一层的诸因素从属于上一层的因素或对上层因素有影响，同时又支配下一层的因素或受到下层因素的作用。最上层为目标层，通常只有1个因素，最下层通常为方案或对象层，中间可以有一个或几个层次，通常为准则或指标层。当准则过多时(譬如多于9个)应进一步分解出子准则层。
2、构造成对比较阵。从层次结构模型的第2层开始，对于从属于(或影响)上一层每个因素的同一层诸因素，用成对比较法和1—9比较尺度构造成对比较阵，直到最下层。
3、计算权向量并做一致性检验。对于每一个成对比较阵计算最大特征根及对应特征向量，利用一致性指标、随机一致性指标和一致性比率做一致性检验。若检验通过，特征向量(归一化后)即为权向量：若不通过，需重新构造成对比较阵。
4、计算组合权向量并做组合一致性检验。计算最下层对目标的组合权向量，并根据公式做组合一致性检验，若检验通过，则可按照组合权向量表示的结果进行决策，否则需要重新考虑模型或重新构造那些一致性比率较大的成对比较阵。
案例 （1）建立层次结构模型
层次分析法的基本思路与人对一个复杂的决策问题的思维、判断过程大体上是一样的。不妨用选拔干部为例：对三个干部候选人y1、y2 、y3，按选拔干部的五个标准：品德、才能、资历、年龄和群众关系，构成如下层次分析模型： 假设有三个干部候选人y1、y2 、y3，按选拔干部的五个标准：品德，才能，资历，年龄和群众关系，构成如下层次分析模型
（2）构造判断矩阵
在确定各层次各因素之间的权重时，如果只是定性的结果，则常常不容易被别人接受，因而Saaty等人提出：一致矩阵法，即：不把所有因素放在一起比较，而是两两相互比较。对比时采用相对尺度，以尽可能减少性质不同因素相互比较的困难，以提高准确度。
比较第 i 个元素与第 j 个元素相对上一层某个因素的重要性时，使用数量化的相对权重aij来描述。设共有 n 个元素参与比较，则称为成对比较矩阵。
成对比较矩阵中aij的取值可参考 Satty 的提议，按下述标度进行赋值。aij在 1-9 及其倒数中间取值。
aij = 1，元素 i 与元素 j 对上一层次因素的重要性相同； aij = 3，元素 i 比元素 j 略重要； aij = 5，元素 i 比元素 j 重要； aij = 7， 元素 i 比元素 j 重要得多； aij = 9，元素 i 比元素 j 的极其重要； aij = 2n，n=1,2,3,4，元素 i 与 j 的重要性介于aij = 2n − 1与aij = 2n + 1之间； ，n=1,2,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f592f427357b5f88acded5951c49ac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f839d51920eda65a47954179323d8f8c/" rel="bookmark">
			vue项目对接海康威视监控视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目对接海康威视监控视频 海康视频WEB插件下载
在 public 文件夹内的index.html 移入以下js
&lt;script type="text/javascript" src="js/jquery-1.12.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/jsencrypt.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/web-control_1.2.5.min.js"&gt;&lt;/script&gt; 页面
&lt;template&gt; &lt;div class="app-container" id="videoPlayerBox" ref="videoPlayerBox"&gt; &lt;el-row :gutter="10" style="margin-bottom: 20px"&gt; &lt;el-col :span="1.5"&gt; &lt;el-input clearable v-model.trim="queryParams.cameraName" placeholder="请输入监控名称" size="small" maxlength="50" @keyup.enter.native="previewVideo" /&gt; &lt;/el-col&gt; &lt;el-col :span="1.5"&gt; &lt;el-button icon="el-icon-search" size="small" type="primary" @click="getCodeList"&gt;查询&lt;/el-button&gt; &lt;/el-col&gt; &lt;el-col :span="1.5"&gt; &lt;el-button :disabled="isPlay" icon="el-icon-switch-button" plain size="small" type="primary" @click="previewVideo" :class="isPlay == false ? 'el_btn_primary' : ''"&gt;开始预览 &lt;/el-button&gt; &lt;/el-col&gt; &lt;el-col :span="1.5"&gt; &lt;el-button :disabled="!isPlay" :class="!isPlay == true?'':'el_btn_danger'" icon="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f839d51920eda65a47954179323d8f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b66d703010045730fa0392c03abc0a2/" rel="bookmark">
			vue表格数据打印功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装 npm install vue-print-nb --save 2.引入 // 安装好以后在main.js文件中引入 import Print from 'vue-print-nb' Vue.use(Print); //注册 3.使用 3.1直接使用id，不对最终打印的表格进行样式修改 template // 通过ID直接打印 &lt;div id="print_demo" &gt; &lt;p&gt;打印内容&lt;/p&gt; &lt;/div&gt; &lt;button v-print="'#print_demo'"&gt;打印&lt;/button&gt; 3.2使用printObj，可以对打印的表格进行样式调整 template // 使用printObj &lt;button v-print="printObj"&gt;打印&lt;/button&gt; &lt;div id="print_demo" style="background:red;"&gt; &lt;p&gt;打印内容&lt;/p&gt; &lt;/div&gt; script export default { data() { return { printObj: { id: "print_demo", popTitle: '打印的标题', extraCss: 'https://www.google.com,https://www.google.com', extraHead: '&lt;meta http-equiv="Content-Language"content="zh-cn"/&gt;' } }; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b25eeeb90cc9496623b676fa03af0b/" rel="bookmark">
			操作系统——核酸检测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做核酸检测前个人需要向核酸检测系统申报本人信息，填写本人姓名、身份证号、住址、电话等信息后提交，生成申报二维码，个人可以保存二维码备用。系统将所有申报信息保存在申报表persons.txt中。用于存放采集样本的每个试管都有条形码标识。核酸检测时，拿到一个新的试管时扫描试管上的条形码，试管的编号、采集地址、采集员、被采人本管序号、采集日期时间作为一条记录被添加到采集信息表sample.txt中。当被采人接受采集时，由扫码器扫描被采人的申报二维码，被采人的信息记录被从申报表persons.txt中检索出来添加到sample.txt中当前记录的被采人身份证号、被采人姓名、被采人本管序号、采集日期时间字段。一个试管可以容纳10个人的采样。采样结束，采集样品由专人检测。每个人的检测结果被添加到sample.txt中该人的检验员、检测日期时间、检测结果字段。个人可以凭身份证号查询自己的检测结果，检测结果显示自己的姓名、检测日期时间、检测结果。请编写Shell脚本实现如下功能：
（1）被采集人个人信息申报功能。填写个人信息，将个人信息保存在申报表persons.txt中。显示该表中的信息。
（2）核酸检测样本信息记录功能。每当采集核酸样本时，采样时，被采人提供身份证号，记录容纳该样本的试管信息、采集人信息和被采人信息及采集地址、采集日期时间等信息到采集信息表sample.txt中。显示该表中的信息。
（3）核酸样本检测结果记录功能。将检测结果记录到sample.txt中的检测结果和检测日期时间字段。显示该表中的信息。
（4）个人检测结果查询功能。个人输入身份证号或姓名，从sample.txt中查询和显示本人的检测结果信息。（50分）
#!/bin/bash #变量池 #用于返回查询身份证号的信息是否存在 SEARCHFLAG1=; #用于返回查询身份证号的信息所在行 SEARCHINFO1=; #试管编号 TUBEID=0; #试管是否封装 TUBEFLAG=0; #试管编号是否存在 TUBESEARCHFLAG=0; #试管是否被检测 TUBECHECK=0; #按照yyyy-mm-dd MM:SS获取当前时间 nowtime=0; #获取当前时间 function getNowTime(){ nowtime=$(date --date='0 days ago' "+%Y-%m-%d %H:%M:%S"); } #市民身份登录 #查询person.txt中的信息 function searchPerson(){ SEARCHFLAG1=$(sed -n "/$1/=" person.txt); SEARCHINFO1=$(sed -n "/$1/p" person.txt); } #查询sample.txt中的信息 function searchSample(){ TUBESEARCHFLAG=$(sed -n "/$1/p" sample.txt); } #个人信息登记 function addPersonalInfo(){ local ID_Num; local name; local Address; local phoneNumber; while [[ 1 ]] do read -p "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b25eeeb90cc9496623b676fa03af0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5c2f19753b5a2d5a3b4d2919fde529/" rel="bookmark">
			JavaScript直接通过id获取对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		id属性具有唯一标识性，可以直接通过id获取对象
通过id获取对象正常写法：
doucument.getElementById("id值")；
简便写法：
id值
例子：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box2{ width: 200px; height: 200px; border: 2px solid; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box2"&gt;&lt;/div&gt; &lt;script&gt; box2.onclick = function(){ box2.innerHTML = "123" } box2.innerHTML = "456" &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 发现依然能够操作dom
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f162c49e194ed7214d0555db4546415a/" rel="bookmark">
			vite项目修改依赖不更新，清除依赖缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有些时候我们会直接修改依赖文件，但修改后没有更新，大多数情况下就是被缓存了
解决方法
1、手动删除node_modules/.vite
Vite 会将预构建的依赖缓存到 node_modules/.vite;然后手动删除即可
2、强制vite重新构建依赖
用 --force 命令行选项启动开发服务器
“scripts”: {
“dev”: “vite --force”
},
vite的缓存只会在以下情况发生时重新构建
package.json 中的 dependencies 列表包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml可能在 vite.config.js 相关字段中配置过的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833ced1e8db3e9b77ca8fa4b2c60d0f5/" rel="bookmark">
			线性代数知识点总结（干货满满）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 行列式1.1 余子式与代数余子式1.2 行列式计算1.3 克莱姆法则 2. 矩阵2.1 矩阵的运算2.1.1 加法运算2.1.2 数乘运算2.1.3 矩阵的乘法2.1.4 矩阵的幂运算 2.2 矩阵的转置2.3 方阵的行列式2.4 伴随矩阵2.5 逆矩阵2.5.1 逆矩阵性质2.5.2 逆矩阵的求法2.5.3 逆矩阵的应用 2.6 矩阵的初等变换2.6.1 初等矩阵 2.7 初等变换的应用2.7.1 求逆矩阵2.1.2 求解矩阵方程 2.9 行最简矩阵与矩阵的秩2.9.1 行最简矩阵2.9.2 矩阵的秩2.9.3 分块矩阵 3. 向量组的线性相关性3.1 向量组的线性关系3.1.1 线性组合与线性表示3.1.2 线性相关与线性无关3.1.3 线性相关性结论(重要) 3.2 向量组的秩3.2.1 向量组的极大无关组3.2.2 向量组的秩的定义 3.3 *向量空间 4. 线性方程组4.1 消元法解线性方程组4.2 非齐次线性方程组解的判定4.3 齐次线性方程组解的判定4.4 齐次线性方程组的解的结构4.5 非齐次线性方程组的解的结构 5. 矩阵相似与对角化5.1 特征值与特征向量5.2 特征值与特征向量的若干结论5.2.1 求特征值和特征向量的一般方法 5.3 相似矩阵与可对角化的条件5.3.1 矩阵可对角化 5.4 向量的内积与正交矩阵5.4.1 内积5.4.2 正交向量组 6. 二次型6.1 可逆变换6.2 二次型的标准型6.2.1 配方法化二次型为标准型6.2.2 初等变换化二次型为标准型 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833ced1e8db3e9b77ca8fa4b2c60d0f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c199afda6f6dcfc8bb36eb0be4a928/" rel="bookmark">
			对Transformer模型的常见问题和理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对Transformer模型的常见问题和理解 基础问题 什么是Transformer模型？ Transformer是一种基于注意力机制（Attention Mechanism）的神经网络模型，由Google于######年提出。它在自然语言处理领域中取得了极大的成功，成为自然语言处理领域的一个重要里程碑。
Transformer模型通过自注意力机制和编码器-解码器结构，能够在序列到序列（Seq###eq）任务中表现出色。自注意力机制可以在不同位置对序列中的每个元素赋予不同的重要性，而编码器-解码器结构则允许模型在输入序列上进行编码，然后在输出序列上进行解码，从而生成目标序列。
相比于传统的循环神经网络（RNN）和卷积神经网络（CNN），Transformer模型的一个重要优点是可以并行计算，从而大大加速了模型训练的速度。同时，Transformer模型也解决了RNN模型的长期依赖问题，并且能够处理长序列的输入。因此，Transformer模型成为了自然语言处理领域中最流行的模型之一。
Transformer模型的主要组成部分是什么？ Transformer模型主要编码器和解码器两部分组成，其中编码器和解码器均由NN网络和Attention机制组成，其中主要组成部分的解释：
Self-Attention层：Self-Attention层是Transformer模型的核心组成部分，用于计算输入序列中每个位置的上下文向量表示。它可以为输入序列中的每个位置分配不同的权重，以便模型可以更好地捕捉序列中的关系。编码器和解码器：Transformer模型采用编码器-解码器结构，其中编码器用于将输入序列映射到高维空间，而解码器则用于生成目标序列。这种结构类似于Seq2Seq模型，但与传统的Seq2Seq模型不同的是，Transformer模型中的编码器和解码器都是由多层Self-Attention层和前馈神经网络层组成的。Multi-Head Attention机制：为了更好地捕捉序列中的关系，Transformer模型采用了Multi-Head Attention机制。Multi-Head Attention允许模型在不同的子空间中计算注意力，从而更好地捕捉序列中的不同方面的信息。前馈神经网络层：前馈神经网络层由两个全连接层和一个激活函数组成。它用于对序列中的每个位置进行非线性变换，从而帮助模型更好地学习序列中的关系。残差连接和层归一化：为了更好地训练深层神经网络，Transformer模型采用了残差连接和层归一化。残差连接允许模型跨越多个层进行信息传递，而层归一化可以加速模型训练并提高模型的泛化能力。位置编码：由于Transformer模型中不包括循环或卷积操作，因此需要一种方法来表示输入序列中的位置信息。位置编码通过为每个位置分配一个唯一的向量表示，可以帮助模型学习序列中的顺序关系。 Transformer模型的核心思想是什么？ Transformer模型的核心思想是使用自注意力机制（Self-Attention Mechanism）来实现对输入序列的建模。自注意力机制允许模型为序列中的每个位置分配不同的权重，以便模型可以更好地捕捉序列中的关系。相比于传统的循环神经网络（RNN）和卷积神经网络（CNN），自注意力机制具有以下几个优点：
并行计算：自注意力机制允许模型并行计算，从而加速了模型的训练速度。长期依赖：自注意力机制允许模型直接考虑序列中任意两个位置之间的关系，因此可以更好地捕捉序列中的长期依赖关系。全局信息：自注意力机制允许模型在整个序列上进行建模，从而可以更好地捕捉全局信息。 除了自注意力机制之外，Transformer模型还采用了残差连接和层归一化等技术，以便更好地训练深层神经网络，并取得更好的效果。Transformer模型已经在自然语言处理领域中取得了极大的成功，并成为了自然语言处理领域中最流行的模型之一。
什么是Attention机制？ Attention机制是一种用于神经网络中的加权汇聚的技术，旨在使网络能够更好地关注输入中的重要部分。在神经网络中，Attention机制通常用于自然语言处理和计算机视觉等任务，其中输入可以是文本序列、图像或音频信号等。
具体来说，Attention机制根据输入的不同部分之间的相关性来计算每个部分的权重，并将这些权重应用于输入的汇聚中。这样，网络可以更好地关注输入中的重要部分，并忽略不相关的部分。在自然语言处理任务中，例如机器翻译，Attention机制可以用于计算源语言和目标语言中单词之间的关联，并在生成翻译时将这些关联考虑在内。在计算机视觉任务中，例如图像分类和目标检测，Attention机制可以用于计算图像中不同区域的重要性，并将这些重要性应用于最终的分类或检测结果中。
总的来说，Attention机制是一种灵活且强大的技术，可以帮助神经网络更好地处理输入中的重要信息，从而提高网络的性能。该技术已经被广泛应用于自然语言处理和计算机视觉等领域，成为了现代神经网络中不可或缺的一部分。
什么是自注意力机制（Self-Attention Mechanism）？ 自注意力机制（Self-Attention Mechanism）是一种用于计算序列中每个位置的上下文向量表示的技术。它可以为输入序列中的每个位置分配不同的权重，以便模型可以更好地捕捉序列中的关系。自注意力机制最初是在Transformer模型中提出的，但现在已经被广泛应用于自然语言处理、计算机视觉等领域。
自注意力机制的计算过程如下：
对于给定的输入序列，首先计算每个位置的Query向量、Key向量和Value向量。对于每个位置，计算它与其他位置之间的相似度得分，通常使用点积或双线性函数等方法计算。相似度得分标准化为权重，通常使用Softmax函数进行标准化，以确保所有权重之和为1。使用权重对Value向量进行加权求和，得到该位置的上下文向量表示。将所有位置的上下文向量表示拼接起来，作为模型的输出。 自注意力机制的优点在于它能够处理任意长度的输入序列，并且可以直接计算序列中任意两个位置之间的关系。相比于传统的循环神经网络（RNN）和卷积神经网络（CNN），自注意力机制具有更好的并行计算性能和更好的长期依赖性能。
Transformer模型与传统的循环神经网络（RNN）和卷积神经网络（CNN）有什么区别？ 与传统的循环神经网络（RNN）和卷积神经网络（CNN）相比，Transformer模型有以下几个区别：
自注意力机制 vs. RNN/CNN：Transformer模型使用自注意力机制来实现对输入序列的建模，而不是使用循环神经网络（RNN）或卷积神经网络（CNN）。自注意力机制允许模型为序列中的每个位置分配不同的权重，以便模型可以更好地捕捉序列中的关系。相比于RNN和CNN，自注意力机制具有更好的并行计算性能和更好的长期依赖性能。
并行计算 vs. 顺序计算：由于自注意力机制的并行计算性能更好，因此Transformer模型可以更快地训练和推理，而不需要按顺序处理序列。
非线性变换 vs. 线性变换：Transformer模型使用非线性变换来映射输入和输出，而不是使用线性变换。这使得模型可以更好地处理复杂的输入和输出。
残差连接和层归一化 vs. 长短时记忆（LSTM）：Transformer模型使用残差连接和层归一化等技术来训练深层神经网络，并取得更好的效果，而不是使用LSTM来处理长期依赖关系。
总的来说，Transformer模型是一种新型的神经网络模型，它采用了自注意力机制、残差连接和层归一化等技术，并取得了在自然语言处理等领域的非常好的效果。相比于传统的RNN和CNN，Transformer模型具有更好的并行计算性能和更好的长期依赖性能，并且能够处理任意长度的输入序列。
什么是编码器和解码器？ 编码器和解码器是一种常用的神经网络架构，在自然语言处理和语音识别等领域中被广泛应用。
编码器通常用于将输入序列（例如文本、音频信号等）转换为一种更高级别的表示，该表示包含输入序列的语义信息。编码器可以是任何类型的神经网络，例如循环神经网络（RNN）、卷积神经网络（CNN）或Transformer模型。在自然语言处理任务中，例如机器翻译，编码器通常用于将源语言句子转换为一种称为“上下文向量”的表示，该表示包含源语言句子的语义信息。
解码器通常用于根据编码器生成的上下文向量，生成输出序列（例如目标语言句子）。解码器也可以是任何类型的神经网络，例如循环神经网络、卷积神经网络或Transformer模型。在机器翻译任务中，解码器通常使用编码器生成的上下文向量作为输入，并根据目标语言中的上下文生成目标语言句子。
编码器和解码器通常是通过共享参数来训练的，这使得网络可以有效地将输入序列转换为输出序列。这种结构已经被广泛应用于自然语言处理和语音识别等任务，并在很多领域中获得了成功。
Transformer模型是如何进行训练的？ Transformer模型通常使用监督学习方法进行训练，即使用带有标签的数据来训练模型。在机器翻译任务中，例如，模型的训练数据通常是一个源语言句子和一个目标语言句子的配对。下面是Transformer模型的训练过程：
输入表示：首先，源语言句子和目标语言句子都会被分别经过一个嵌入层，将它们转换为向量形式。
位置编码：对于每个输入向量，还需要添加一个位置编码，以便Transformer模型能够处理序列中的顺序信息。位置编码通常是一组正弦和余弦函数，可以让模型有效地学习序列中不同位置之间的关系。
编码器和解码器：模型包含一个编码器和一个解码器，它们分别是由多个编码层和解码层组成的。编码器的任务是将输入序列转换为一种更高级别的表示，该表示包含输入序列的语义信息。解码器的任务是根据编码器生成的上下文向量生成输出序列。
自注意力和前向传播：每个编码层和解码层都包含自注意力和前向传播两个子层。自注意力子层可以帮助模型更好地关注输入序列中的相关部分，前向传播子层则可以学习输入和输出之间的非线性映射关系。
损失函数和优化器：在训练过程中，使用带有标签的数据计算模型的预测输出和真实输出之间的差异，并将其作为损失函数。然后，使用优化器来更新模型的参数，使其能够更好地拟合训练数据。
推理过程：在训练完成后，可以使用模型进行推理，即给定一个新的输入序列，模型可以生成相应的输出序列。在推理过程中，输入序列会经过编码器，生成一个上下文向量。然后，该上下文向量将被用作解码器的初始隐藏状态，生成输出序列。
Transformer模型是使用监督学习方法进行训练的，并且使用自注意力机制和前向传播网络对输入序列进行编码和解码。该模型已经在自然语言处理和计算机视觉等领域中获得了广泛的应用。
Transformer模型有哪些应用场景？ Transformer模型由于其强大的建模能力和高效的训练方法，在自然语言处理和计算机视觉等领域中已经被广泛应用。以下是一些Transformer模型的应用场景：
机器翻译：Transformer模型已经在机器翻译领域中取得了显著的成功，尤其是在大规模多语种翻译任务中。通过训练Transformer模型，可以将一个源语言句子自动翻译为一个目标语言句子。
语言建模：由于Transformer模型具有强大的序列建模能力，因此可以应用于语言建模任务。在这种情况下，模型的目标是对给定的文本序列进行建模，以预测下一个单词或字符。
问答系统：Transformer模型也可以用于问答系统，其中模型的任务是回答给定问题的答案。在这种情况下，模型首先需要将问题和相关文本进行编码，然后生成答案。
文本分类：另一个常见的应用场景是文本分类任务，其中模型的任务是将输入文本分为不同的类别。在这种情况下，可以使用Transformer模型来将输入文本转换为一个向量表示，然后将其输入到分类器中进行分类。
计算机视觉：Transformer模型也可以应用于计算机视觉任务，例如图像分类和目标检测。在这种情况下，可以使用Transformer模型对图像进行编码，以提取其特征表示，然后将其输入到分类器或检测器中进行分类或检测。
Transformer模型已经被证明在多个领域中具有广泛的应用前景，可以用于各种序列建模和特征提取任务。
Transformer模型有哪些优点和缺点？ Transformer模型具有以下优点：
并行化：相对于循环神经网络（RNN）和卷积神经网络（CNN），Transformer模型可以更容易地进行并行化处理，这使得它能够更快地训练和推理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c199afda6f6dcfc8bb36eb0be4a928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edd067546d80c2cb9ae55927e6673f1/" rel="bookmark">
			Markdown快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown快速入门 什么是Markdown Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。
由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。 如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。
所以markdown主要是用于云笔记，博客等的快速撰写。
本人使用的编辑软件是typora
Markdown标题 1、使用=和-标记一级和二级标题 我展示的是一级标题 ============== 我展示的是二级标题 -------------- 显示效果如下图：
1、使用#号标记 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 Markdown段落格式 1、段落的换行 Markdown 段落的换行是使用两个以上空格加上回车
当然也可以在段落后面使用一个空行来表示重新开始一个段落。
2、字体 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 3、分割线 在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：
*** * * * ***** - - - ---------- 4、删除线 在文字的两端加上两个波浪线 ~~ ,会出现删除线效果
5、下划线 下划线可以通过 HTML 的 &lt;u&gt;标签来实现：
&lt;u&gt;有下划线的文本&lt;/u&gt; 显示效果如下所示：
6、脚本 脚注是用于对文本的补充说明
[^要注明的文本] 实例演示了脚注的用法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edd067546d80c2cb9ae55927e6673f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63e315643b21f2d132393e99614f91b/" rel="bookmark">
			MySQL的备份与还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的备份与还原 1、创建一个新表并插入原表所有数据2、创建一个新表，只插入指定字段3、关闭服务冷备份还原 (复制文件夹)4、通过 mysqldump 命令备份还原新数据库4.1、单一数据库4.2、多个数据库4.3 还原 5、mysqlhotcopy工具快速备份 1、创建一个新表并插入原表所有数据 create table Person-bak as select from Person 2、创建一个新表，只插入指定字段 create table Person-bak as select id,personName from Person 需要注意，原表的主外键设置并不会复制到新表中
#eg:
create table person3 as select * from person; create table person3 as select id,name from person;	select * from person3 3、关闭服务冷备份还原 (复制文件夹) 停止服务
拷贝Data文件夹到备份目录
开启服务
删除数据测试 delete from person where id&gt;1;
关闭服务
拷贝‘备份的data文件夹’覆盖需要还原的Data文件夹
启动服务
select * from person
4、通过 mysqldump 命令备份还原新数据库 4.1、单一数据库 mysqldump基本语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63e315643b21f2d132393e99614f91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/604cf9ba172a1ef5fbd09f05ccdf2259/" rel="bookmark">
			GateWay网关自定义过滤器实现token校验完成统一鉴权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础知识 gateWay---API网关，也可以称为业务网关，主要服务于微服务的；
(1) 三大组件 路由（Route) 构建网关的基本模块，由id(唯一标示)、目标URI、一组断言、一组过滤器组成，如果断言为true，则匹配该路由
断言（Predicate） 可以使用它匹配来自HTTP请求的任何内容，例如headers或参数
多滤器（Filter） Gate中的Filter分为两种类型，Gateway Filter和Global Filter；过滤器Filter将会对请求和响应进行修改处理
(2)运行流程 (3) 搭建网关服务 引入网关依赖和nacos服务发现依赖 &lt;!--网关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos 服务发现依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编写路由配置和nacos地址 cloud: gateway: globalcors: #全局的跨域处理 add-to-simple-url-handler-mapping: true #解决optoins请求被拦截的问题 corsConfigurations: '[/**]': #允许在请求中携带的头信息 allowedHeaders: "*" #允许哪些网站跨域 allowedOrigins: "*" allowed-methods: #允许跨域请求的方式 - GET - POST - DELETE - PUT - OPTION routes: #网关路由配置 #探花系统 - id: tanhua-app-server uri: lb://tanhua-app-server #路由的目标地址，lb是负载均衡:服务名称 predicates: #路由断言，判断请求是否符合路由的规则 - Path=/app/** filters: #过滤器 - StripPrefix= 1 #去掉url部分前缀 #后台系统 - id: tanhua-admin uri: lb://tanhua-admin predicates: - Path=/admin/** filters: - StripPrefix= 1 三、实现步骤 （1）自定义过滤器 需要实现两个接口（GlobaFilter、Ordered）；重写两个方法filter( )---负责鉴权的业务逻辑，getOrdered()---设置过滤器执行的顺序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/604cf9ba172a1ef5fbd09f05ccdf2259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0d9bd3d80b311927529b482c3c2606/" rel="bookmark">
			登录RabbitMQ Management时提示不是私密连接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况：我是使用虚拟机docker安装的：
docker run \ -e RABBITMQ_DEFAULT_USER=itcast \ -e RABBITMQ_DEFAULT_PASS=123321 \ -v mq-plugins:/plugins \ --name mq \ --hostname mq1 \ -p 15672:15672 \ -p 5672:5672 \ -d \ rabbitmq 之后登录访问RabbitMQ管理页面后就弹出身份验证：
之前通过重装解决，这次又遇到且重装也没解决问题，排查后发现是安装启动mq时用户没创建成功。
进入docker容器查看用户
docker exec -it 自己的mq的名字 bash rabbitmqctl list_users 发现只有一个本guest用户，原来是自己的用户创建失败了，于是重新添加一个用户
rabbitmqctl add_user 用户名 密码 rabbitmqctl set_user_tags 用户名 administrator 顺便给这个用户设置权限
然后浏览器访问RabbitMQ Management登录这个用户后, 成功成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca75bf129910b81132731b9b8920ffde/" rel="bookmark">
			西门子PLC S7-200SMART Modbus TCP通讯的步骤和要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Modbus TCP是一个非常传统，应用广泛的通讯协议，很多智能设备都支持该协议。西门子S7-200SMART及1200、1500系列都免费支持（300和400还是要高昂收费），并且做成了标准库，使用起来非常方便，下面简单介绍一下客户端的配置步骤，服务器的配置更加简单，可以自行摸索：
1、引用库
直接将MBUS_CLIENT拖拽到MAIN程序里，前端设置好启动条件，查询频率（Req端，上升沿触发）。然后设置通讯各通讯参数。不理解的可以按F1查看详细说明。
提醒一下：与MODBUS RTU相比，这儿没有了速率、校验等问题，但是也要设置好对方的IP地址、端口（一般是502）、信息所在的地址区，以及读回来的数据存储位置（这是VB10开始的20个字节，因为40001的单位是两字节的字）。
2、给引用的库配置工作存储区
看上图标识为3的条目，调出配置界面，如果不清楚存储区使用情况，则可以点击“建议地址”。
3、修改读取设备的ID号
读取设备有个ID号，这个参数是隐含的，也要确保与设备保持一致，请到Modbus TCP Client的符号表里查看地址，并通过程序赋一个初始值即可。
4、其他说明
1）以上只是配置了一个读取模块，如果有多个地址区域，可以配置多个读取模块进行读取和写入。
2）读回来的连续数据区，要自己进行变量拆分，如果协议不统一，可能还需要自己颠倒字节顺序。通讯不是个容易的事情，因此，不要急躁。
3）PLC-Recorder是个专业的录波软件，广泛应用于各工业场合，其支持Modbus TCP协议，可以连接各种智能设备，参数配置也比较丰富，能适应各种变化。
2023年3月2日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0795e21fccd02837041da19c1b5ab219/" rel="bookmark">
			阿白数模笔记之灰色-马尔科夫模型（Grey Markov model）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言（preface）
GM(1,1)
简介(brief introdution)
①级比检验（Grade ratio test）
②建立GM(1,1)模型
Ⅰ、邻值生成序列（Adjacent value generating sequence ）
Ⅱ、回归分析（regression analysis）
Ⅲ、残差检验（Residual test）
Markov chain
① 转移概率矩阵（Transition probability matrix）
②状态分布向量(state vector)
③平稳分布向量(steady-state vector)
灰色马尔可夫模型（Grey Markov model）
①对y0建立GM(1,1)得到e1
Ⅰ、Grade ratio test
Ⅱ、Accumulative generation sequence
Ⅱ、Regression analysis&amp;Residual test
②对abs(e1)建立GM(1,1)
Ⅰ、Grade ratio test
Ⅱ、Accumulative generation sequence
Ⅱ、Regression analysis&amp;Residual test
③修正（revise）
Ⅰ、转移概率矩阵
Ⅱ、初始分布与预测
Ⅲ、修正效果
④总结（summary）
参考文章（Reference articles）
前言（preface） 在学习模拟退火算法时(Simulated Annealing，SA)发现了一个新名词——马尔科夫链（Markov chain）,所以就先学习了Markov chain的相关知识，本文主要介绍GM(1,1)，Markov chain，并将Grey Markov model应用到实例。
GM(1,1) 简介(brief introdution) 黑色未知，白色已知，而灰色是介于黑白之间的，意味着部分数据已知，而数据间有内在联系，但内在函数关系未知。GM(1,1)适用的情况大致满足以下条件：一、数据量少，二、短期预测，三、指数增长。下面是原数据和经过生成后的数据折线图，发现处理后的数据具有更明显的规律。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0795e21fccd02837041da19c1b5ab219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a50c89e8ecce285fcafdc758b78c41/" rel="bookmark">
			idea启动报Plugin Error错误的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开项目突然显示error.log如下：
Plugin Error
Problems found loading plugins:
Plugin "GlassFish Integration" was not loaded: required plugin "Java EE: EJB, JPA, Servlets" is disabled.
Plugin "JBoss Integration" was not loaded: required plugin "Java EE: EJB, JPA, Servlets" is disabled.
Plugin "JSR45 Integration" was not loaded: required plugin "Java EE: EJB, JPA, Servlets" is disabled.
Plugin "Jetty Integration" was not loaded: required plugin "Java EE: EJB, JPA, Servlets" is disabled.
Plugin "Resin Integration"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a50c89e8ecce285fcafdc758b78c41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eff4472f1fe2bcb4581c7c65fb1faca/" rel="bookmark">
			Win11系统软件无法拖拽发送文件的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、按下快捷键“win+r”，输入：regedit 2、打开注册表之后依次展开： HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System。
3、在右边找到“EnableLUA”，双击之后就在弹出的窗口中将数据数值由1改成0即可。 4、最后重启电脑再打开微信就可以拖拽文件进行发送了。 转载自：https://www.cnblogs.com/lijin-note/p/16542536.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4583e41ab4ea3b2ba690303a9bf80962/" rel="bookmark">
			How bad are small triangles on GPU and why?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.g-truc.net/post-0662.html
25/06/2014 How bad are small triangles on GPU and why? RSS Feed ~ Comment: by email - on Twitter ~ Share: Twitter - Facebook - Linked In - Google+ - Permanent link Small triangles is bad for performance and this is not something new. In this post, we are just looking at some numbers to quantity these bad performance.
We are using a simple scenario where the framebuffer is filled with tiles of variable sizes, each tile being composed of two triangles and no tile is overlapping another.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4583e41ab4ea3b2ba690303a9bf80962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4896f017ec4cffe481bc02e5a75071ae/" rel="bookmark">
			Android FFmpeg Camera2 推流直播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 自己花了点时间实现了一个使用FFmpeg将Camera2视频数据推送到RTMP服务的简单Demo，在这里分享下，里面用到知识很多都是之前博客中用到的，难度不大。
效果图 1、 定义方法 定义了三个JNI方法
public class FFmpegHandler { private FFmpegHandler() { } private static class SingletonInstance { private static final FFmpegHandler INSTANCE = new FFmpegHandler(); } public static FFmpegHandler getInstance() { return SingletonInstance.INSTANCE; } static { System.loadLibrary("ffmpeg-handler"); } //初始化参数 public native int init(String outUrl); //推流，将Y、U、V数据分开传递 public native int pushCameraData(byte[] buffer,int ylen,byte[] ubuffer,int ulen,byte[] vbuffer,int vlen); //结束 public native int close(); } 2、Camera2实时数据 具体使用可查看Android音视频(一) Camera2 API采集数据
将ImageReader作为预览请求的Target之一，这样我们就可以将预览的数据拿到在onImageAvailable中进行处理推送。
mImageReader = ImageReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4896f017ec4cffe481bc02e5a75071ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f808696222ebd581acd6020e6e0f24/" rel="bookmark">
			Java中的死锁及其解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的死锁及其解决方案 在Java中，锁是很常见的一个工具，常见的用法就是在高并发场景下保证线程安全，但是使用不当也会造成死锁，给我们带来一些不必要的麻烦，本文分析死锁及其产生原因，并作出相应的解决方案。
死锁产生的四个必要条件 1）互斥条件：进程对所分配到的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
2）请求和保持条件：进程已经获得了至少一个资源，但又对其他资源发出请求，而该资源已被其他进程占有，此时该进程的请求被阻塞，但又对自己获得的资源保持不放。
3）不可剥夺条件：进程已获得的资源在未使用完毕之前，不可被其他进程强行剥夺，只能由自己释放。
4）环路等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。
生活示例 死锁就好比两个人去过独木桥，小庞从桥左边出发，小贾从桥右边出发，然后到了桥中间，小庞要去右边，小贾要去左边，但两者都互不想让，最终只能在桥中间站着，造成死循环，谁也过不了河的结果。
对象A先持有锁1，然后对象B持有锁2，此时对象A要去获取锁2，但是锁2此时在对象B手里，对象B要去获取锁1，锁1在对象A手里，对象A，B互不相让，最终导致死链现象，出现死锁。
死锁代码 方式1，继承Runnable接口实现 package com.wwy.lock; import java.util.concurrent.TimeUnit; public class DieLock { public static void main(String[] args) { Object A = new Object(); Object B = new Object(); //线程1 /** * ()-&gt;{} 此为jdk8新增的新特性 但要求目标接口只有一个抽象方法，而Runnable恰好符合此条件 */ Thread thread1 = new Thread(()-&gt;{ synchronized (A){ System.out.println("线程1此时获取锁A"); try { /** * TimeUnit是一个时间工具类，更好的帮助我们定义休眠时间 *TimeUnit.DAYS //天 * TimeUnit.HOURS //小时 * TimeUnit.MINUTES //分钟 * TimeUnit.SECONDS //秒 * TimeUnit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f808696222ebd581acd6020e6e0f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474e49d81bf4ed94dfc796ee9fff1236/" rel="bookmark">
			银河麒麟在线和离线安装jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,在线安装arm版jdk 先看下jdk是否已经安装java -version
查询下jdk源
sudo apt search openjdk* 安装openjdk
apt-get install openjdk-8-jdk 卸载jdk apt-get remove openjdk-8-jdk
如果报错误了执行下sudo apt --fix-broken install
2，离线安装arm版jdk 在有网的情况下，将openjdk的依赖的deb都下载下来
创建一个目录存放deb包
mkdir jdr cd jdr 在此目录下执行
apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances --no-pre-depends openjdk-8-jdk | grep -v arm64 | grep "^\w") 执行完毕之后，发现里面有一个openjdk11，所以在上面的目录里，删除了下面这个deb，再在此目录下运行所有的deb包，
openjdk-11-jre-headless_11.0.11+9-0kylin2~20.04k1_arm64.deb
sudo dpkg -i *.deb 卸载openjdk
sudo dpkg -P openjdk-8-jdk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc9c1bc4263044c5c35ebc4d51a3f05/" rel="bookmark">
			使用docker发布.net应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤：
创建.NET应用样例
创建包含生成.NET镜像所需引导的Dockerfile
构建一个镜像并基于此创建一个容器
设置容器数据卷和网络设置
使用Docker Compose编排容器
使用容器构建开发坏境
创建镜像 先决条件：
了解Docker的基础概念。
总览：
一个镜像包含了运行一个应用所需的一切：代码、二进制文件、运行时、依赖以及其他所需的文件系统。
完成本次学习需要：
安装.NET SDK 6.0或更新版本；
本地运行Docker；
一个编译器；
应用样例：
使用.NET模板创建一个简单的应用作为样例。在本地创建dotnet-docker文件夹。打开一个命令行来对文件夹进行修改。运行以下命令基于ASP.NET core Web App模板创建一个C#应用。
mkdir dotnet-docker cd dotnet-docker dotnet new webapp -n myWebApp -o src --no-https 创建成功后出现：
已成功创建模板“ASP.NET Core Web 应用”。 此模板包含除 Microsoft 以外其他方的技术，请参阅 https://aka.ms/aspnetcore/7.0-third-party-notices 以获取详细信息。 上述指令将会创建一个新的文件夹--src。
测试应用：
打开命令行进入src文件夹并使用dotnet run指令。
dotnet run --urls http://localhost:5000 运行成功后出现下方信息：
Building... info: Microsoft.Hosting.Lifetime[0] Now listening on: http://localhost:5000 info: Microsoft.Hosting.Lifetime[0] Application started. Press Ctrl+C to shut down.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc9c1bc4263044c5c35ebc4d51a3f05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84422744aecb299ca57f5a5c95289b92/" rel="bookmark">
			webrtc拥塞控制算法对比-GCC vs BBR vs PCC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 现有集成在webrtc中的拥塞控制算法有三种, 分别是: 谷歌自研发的gcc, 谷歌自研发的BBR算法, 斯坦福大学提出的基于机器学习凸优化的PCC算法. 本文将探讨一下三个算法的区别和优缺点。
2.背景 迈聆会议从17年到现在, 一直使用的是基于谷歌的gcc算法自研的Omcc算法(optimization of Mindlinker in network congestion controller), 经过这么多年的优化, 在现有表现上已经可以在大部分网络场景下准确预估带宽. Omcc算法已经可以做到抗50%丢包, 抗800ms抖动, 抗2s延时, 在300k-10mbps带宽范围下也可以准确预估带宽值, 在保障低延时的情况下, 能够尽可能提高带宽利用率。
本文将讨论webrtc自带的三种算法的优缺点, 并给出部分测试报告。
3.GCC算法 gcc算法是webrtc默认的算法. 其具体原理本文不再赘述, 已经有各种参考资料去详细讲解了gcc算法的原理.
3.1 gcc算法优点 灵敏度高, 能够及时响应, 提前避免拥塞. 基于抖动和基于丢包的预估值可以很好的预测网络拥塞.
3.2 现有GCC算法所面临的问题和难点 1.带宽对发送数据量的强相关
对于GCC算法, 其网络模型是依靠丢包和抖动去检测网络的拥塞, 从而及时响应网络的动态变化. 原版的GCC算法所能允许的丢包非常小, 丢包大于10%就断崖式下跌带宽. 所能允许的抖动和延时也不高. 通过我们现在的优化之后, 丢包上限达到了50%, 延时增长不是那么敏感, 抗抖动范围也会更高. 但这样带来的结果是, 在带宽预估的稳定性和准确性上面很难做好. GCC算法的逻辑是和数据发送量强相关的, 网络好时发送量多, 带宽预估才会上去. 发送100kbps的码率, 带宽预估很难超过200kbps. 此外, 现有有些发送逻辑是需要去降低发送量, 从而给用户节省带宽的, 比如桌面共享场景下静止画面和动态画面数据量可以从20kbps波动到4mbps.剧烈波动的发送量导致在某些场景下带宽预估的剧烈波动. 波动这么剧烈的场景下, 怎样在既保持带宽预估稳定的同时又不降低发送量呢, 此问题在现有webrtc的策略下很难去解决.
2.带宽恢复速度
GCC算法的核心是慢升快降, 在网络拥塞的时候指数下降带宽, 在网络恢复后, 龟速上涨带宽. 带宽缓慢恢复对于网络来说是一件好事, 但是, 低带宽恢复高带宽需要非常多的时间, 对用户体验不太好.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84422744aecb299ca57f5a5c95289b92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec15e95cfe2861567bbb1ed7d38c89a4/" rel="bookmark">
			前端项目部署更新后，不清缓存也能得到最新静态资源文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们得知道，SPA应用打包后的js、css等信息全都在index.html文件中导入，我们每次打包的时候，这些静态资源文件会携带一个hash值，如果hash值不变的话，又存在缓存的话就会走强缓存或者协商缓存，导致静态资源不是最新的。那么如何能达到项目上线后不清缓存页面也能获取到最新静态资源呢？
那么解决方案也有很多种，我这边采用的比较简单粗暴，每次打包都给文件后面加一个时间戳，那么每次刷新页面的时候index.html里导入的静态资源就会找不到缓存，这时候就会从服务器请求最新资源。
如何配置打包文件带时间戳呢？使用chainWebpack或者configureWebpack。
chainWebpack是vuecli提供的操作webpack的语法糖，作用和configureWebpack一样，都是修改webpack配置，
首先配置js打包名称， planA: 使用chainWebpack，chainWebpack是一个对象。
chainWebpack: (config) =&gt; { config.output.filename(`js/js[name].${timeStamp}.js`).chunkFilename(`js/chunk.[id].${timeStamp}.js`); } planB: 使用configureWebpack，configureWebpack是一个对象或者函数，如果你需要基于环境有条件地配置行为，或者想要直接修改配置，那就换成一个函数。
configureWebpack: (config) =&gt; { if (process.env.NODE_ENV === 'production') { config.optimization.minimizer[0].options.terserOptions.compress.drop_console = true; config.output.filename = `js/js[name].${timeStamp}.js`; config.output.chunkFilename = `js/chunk.[id].${timeStamp}.js`; } }, 或者使用对象
configureWebpack: { output: { // 输出重构 打包编译后的js文件名称,添加时间戳. filename: `js/js[name].${timeStamp}.js`, chunkFilename: `js/chunk.[id].${timeStamp}.js`, } }, 2.配置css资源
...configureWebpack, css: { extract: { // 打包后css文件名称添加时间戳 filename: `css/[name].${timeStamp}.css`, chunkFilename: `css/chunk.[id].${timeStamp}.css`, } }, 打包完的文件包含一个app，此时我们导出vuecli webpack配置vue inspect &gt; output.js，可以看到有个app
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ee58df0b21cca57ce3716a76efbfe5/" rel="bookmark">
			以太网调试经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MDC时钟捕获 在bringup时，首先需要确认MDC/MDIO控制通道是否正常，通过捕获MDC时钟以确认MDC/MDIO的工作状态是否正常，MDC时钟频率由具体的PHY芯片决定，不同的PHY芯片支持的MDC时钟频率范围不通。
注意1：MDC时钟频率不固定且值一般不大，仅几兆而已，使用示波器抓取波形时要注意参数的设置，参数设置不当时MDC波形容易被忽略，从导致对当前MAC工作状态的误判。
注意2：MDC时钟波形只在MDC/MDIO上有数据通信时才有，所以抓取波形最好使用触发方式，否则很容易抓不到波形导致对当前MAC工作状态的误判。
以下是MDC时钟的波形：
2.PHY ADDR配置 通常PHY ADDR都是通过硬件加上下拉电阻进行配置，将硬件配置的PHY ADDR加到设备树或MAC驱动代码中，如果PHY ADDR配置错误，MDC/MDIO通信是无法成功的。
注意：当设备树或MAC驱动代码中配置了PHY ADDR，MDC/MDIO通信依旧无法成功，可以通过软件方式轮询0~31这个32个PHY ADDR上的PHY的可操作寄存器，如此也可以找到PHY ADDR，将该PHY ADDR重新配置到设备树中或代码中。
3.PHY_ID配置 PHY_ID是固化在PHY芯片里的，MAC驱动会通过PHY_ID来匹配对应的PHY driver，如果PHY_ID配置错误，ping 其他网络设备也是无法成功的；PHY_ID可以在设备树中进行配置，也可以在代码中通过MDC/MDIO读写PHY寄存器获取。
注意：代码中默认获取PHY_ID的方式是通过读写0~15这个16个通用寄存器实现的，但不是所有厂家的PHY芯片都支持0~15这16个通用寄存器，如果使用代码自动获取PHY_ID需要开发人员修改驱动代码进行适配。
以marvell 88q1110为例，代码中需要添加以下代码进行适配：
4. clause 22 与 clause 45 clause 22和clause 45协议可以在设备树中进行配置，高通8155平台默认是不支持clause 45协议读写的，如果需要使用clause 45协议操作PHY芯片，需要对读写接口进行适配。
5.MAC工作状态 MAC工作状态主要关注点为speed和duplex，通常情况下，MAC会根据自动协商的结果去设置MAC的speed和duplex，所以一般情况下speed和duplex是不需要另外配置的，这是一个自动的过程。
注意1：MAC和PHY芯片一般都是默认开启自动协商功能的，但不是绝对的，所以bringup时一定要确认MAC和PHY芯片是否支持自动协商功能的使用。比如dp83tc811和88q1110都具备自动协商能力，但是自动协商功能不能使用，所以MAC无法获取PHY的协商结果，MAC会一直工作在10M状态。
注意2：可以通过fixed-link的方式来绕过自动协商的流程，将MAC配置为一种固定的工作状态，比如88q1110只能工作在100M状态，那么MAC就不会有工作在10M和1000M的场景，直接将MAC配置在100M和全双工模式即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7749aa86c391e1689fd8609eb4ba692/" rel="bookmark">
			工业缺陷检测项目实战(一)——基于opencv的工件缺陷检测C&#43;&#43;和python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于opencv的工件缺陷检测C++和python实现 作为研究生，每一个项目都很重要，这里给大家分享一个好入门项目，代码纯自己写，网上都是python的，但是有些企业要求C++编写项目，所以希望大家能学到东西。
一. 问题陈述
工件的展示，这是一个视频，然后工件一个个经过，要检测出哪个工件有缺陷，并且分类缺陷的种类。可以看到缺陷是不止一种。
二. 代码步骤
1.读取图像，转为灰度图并二值化
cvtColor(img, gray, COLOR_BGR2GRAY); threshold(gray, thresh, 127, 255, THRESH_TOZERO_INV);、 2.寻找轮廓
std::vector&lt;Vec4i&gt; hireachy; std::vector&lt;std::vector&lt;Point&gt;&gt; contours; findContours(thresh, contours, hireachy, RETR_LIST, CHAIN_APPROX_NONE); 3.遍历轮廓，对工件圈进行统计，防止重复标记
原理是计算图像矩，可以确定图像的灰度中心，根据每个时刻每个工件的中心位置的变换，可以判断画面里是否出现新的工件。同时，也要记得更新每个时刻每个工件的位置。具体代码实现可以参考完整工程文件。这里贴出部分：
for (size_t cnt = 0; cnt &lt; contours.size(); cnt++) { double area = contourArea(contours[cnt]); //求轮廓面积(大约的) if (area &gt; 18000 &amp; area &lt; 28000) //把工件圈出来 { mu[cnt] = moments(contours[cnt], false); //计算图像矩，表示工件的位置 //计算图像质心位置 double cx = mu[cnt].m10 / mu[cnt].m00; double cy = mu[cnt].m01 / mu[cnt].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7749aa86c391e1689fd8609eb4ba692/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a9450da111d744f17e85c16b2447737/" rel="bookmark">
			解决vue3没有this造成的无法使用vue2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue2项目中可以使用this.$router.push等方法进行路由的跳转，但是在Vue3的setup函数里，并没有this这个概念，因此如何使用路由方法
1.// 在新的vue-router里面尤大加入了一些方法，比如这里代替this的useRouter，具体使用如下：
//引入路由函数
import { useRouter } from "vue-router";
//使用
setup() {
//初始化路由
const router = useRouter();
router.push({
path: "/"
});
return {};
}
2.在vue2中可以通过this来访问到$refs，vue3中由于没有this所以获取不到了，但是官网中提供了方法来获取:
&lt;template&gt;
&lt;h2 ref="root"&gt;姓名&lt;/h2&gt;
&lt;/template&gt;
&lt;script&gt;
import { onMounted, ref } from 'vue'
export default {
name: 'test9',
setup(){
const root = ref(null)
onMounted(()=&gt;{
console.log(root.value);
})
return {
root
}
},
}
&lt;/script&gt;
//第二种方法，也可以通过getCurrentInstance来获取
&lt;template&gt;
&lt;h2 ref="root"&gt;姓名&lt;/h2&gt;
&lt;/template&gt;
&lt;script&gt;
import { onMounted, ref, getCurrentInstance } from 'vue'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a9450da111d744f17e85c16b2447737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94c5d2e2d446af84f647fbc88da9db1/" rel="bookmark">
			如何用Python进行股票预测，数据分析带你从小白开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在开始这个话题之前请先记住一句友情提醒：股市有风险，投资需谨慎
我们写这个文章并不是鼓励大家去入市，小编本人也不买股票。我们只是在探索Python在股票分析和预测上面能发挥什么样的作用！
对于和数据打交道的数据科学家来说，预测证券市场走势远比炒股本身来得更有趣。他们这样做的目的很大程度上不是为了获取物质回报，而是挑战自己！那么在这个起起伏伏，众多因素叠加的证券市场是否存在一种模型可以学习既定的模式至少让我们可以比那些商科毕业的操盘手厉害呢。
言归正传，做数据分析的流程都差不多：数据集的获取和加工、模型的选择和调参、算法编写。
说起数据分析自然离不开“三件套”：Numpy Pandas Matplotlib。我们这就开始我们的股票分析操作吧
环境配置：
代码部分：
导入相关的库并设置参数，这里我们选择特斯拉这支股票
加载数据：
我们获取从2001年开始到现在的股票历史数据
数据分析：
从生成的图中我们可以看到：从图一我们可以看到特斯拉股票在2020年以前变化不大，大概在2020年下半年开始突然暴涨。这个让我们很容易联想到新能源有兴趣或者关注的可以查看当年的新闻报道，也是在这一年特斯拉股票暴涨了743%，同时也让CEO马斯克身价飙涨了1000亿美元。图3的价格变动趋势图也证实了这一点。至于交易量和交易量变动表也是同样如此。这几个图在股票交易软件里面应该都能看得到，但是使用Python的好处是你可以把多只股票放在一起比较来看！
长期投资利润：
时间机器产生利润：
我们直接看结果
我们可以看到在不同的年份买入和卖出所获取利润情况（请注意这一假设的前提是我们有一台机器并且使用它 在我们确切知道股票价格什么时候会涨什么时候会跌的情况下 我们投资了所有的买入和卖出所产生的总利润）
基于模型预测的利润：
我们的思路是这样，我们设计一个模型它会比“长期投资的利润和最大程度设置时间机器的利润”给我们带来更好的结果。我们这样做的原因是因为我们希望确定股票最佳的买入和卖出点。我们绝对不是为了打败长期投资者，我们只是想尽可能的控制交易风险。
从这张图我们可以看到股票价格波动最剧烈的范围，这对于那些长期持有的人来说如果股票一直在上涨那自然无所谓，但是对于那些投资短线的人来说意味着这支股票有更大的操作空间，当然风险也更大！
通过调用我们所编写的类，我们可以看到股票实际变动、模型预测、置信区间之间的关系。这个可以方便我们更好的调整我们的模型进行预测。
股票评估预测：
通过上面的分析我们可以看到我们所采用的测试数据的绝对误差还是挺高的，让我们试着调整下参数以获得更好的测试数据结果
从结果上看我们可以看到，采用测试数据平均误差是$228.87而采用我们训练的模型所预测的数据平均误差是$52.24这意味着我们的训练的模型所产生的误差已经得到了很大的优化。此外我们也可以看到在预测股票价格上涨上面准确率为47.95%而在预测股票价格下跌上面的准确率为38.27%
在调整了参数得到的预测结果：
可以看到我们的模型预测的结果大部分都越来越准确，我们通过表格来直观的感受下。
预测类型模型一模型二预测和实际价格差$907.55$179.79平均错误$17.87 $451.56$108.10 $301.74上涨概率47.95%45.86%下跌概率38.27%40.34%实际值/置信区间80%0.00%2.37% 在我们不断的优化模型参数并经过一定量的训练之后我们的模型在涨跌趋势的预测上准确率可以进一步提升（有兴趣的可以联系小编获取代码研究几支股票试一试）
在实际测试中我们可以发现如果我们使用我们的模型推荐来买入/卖出 我们在去年可以获得大概23%的利润，实际上这个也是我们从长期投资中获得的回报。但是这个模型的意义在于减少持仓时间来最小化风险。而且股票的分析只是其中一块，最终我们要么通过人去实现买卖要么通过算法自动化帮我们去处理繁琐的买卖，而这正是编程所擅长的，至少在时间上有绝对的优势！
诚然我们用Python来对股票进行数据分析，实现预测和评估的目的主要是展示这种应用能力。就像在疫苗研发、芯片研发、机械制造等领域所能做的一样。都是为了更好的完成工作。
Python经验分享 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 三、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。（文末领读者福利）
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。（文末领读者福利）
五、Python练习题 检查学习结果。
六、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。 （文末领取哦）
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55a5da74f765f7dd9f41e3b680ced16/" rel="bookmark">
			Hbase环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前，在本机已经搭建好hadoop与zookeeper集群环境，现开始搭建Hbase分布式环境，步骤如下：
（1）解压hbase-1.3.3-bin.tar.gz到/opt/目录下
tar -zxvf /export/softwares/hbase-1.3.3-bin.tar.gz -C /opt
（2）修改hbase-1.3.3-bin 的名称为 hbase
mv /opt/hbase-1.3.3 /opt/hbase
（3）配置/etc/profile添加hbase的环境变量，并刷新该环境变量
vi /etc/profile
添加如下配置信息
export HBASE_HOME=/opt/hbase
export PATH=$PATH:$HBASE_HOME/bin
（4）配置conf目录下的hbase-site.xml
vi /opt/hbase/conf/hbase-site.xml
添加如下配置信息
&lt;property&gt;
&lt;name&gt;hbase.rootdir&lt;/name&gt;
&lt;value&gt;hdfs://node01:9000/hbase&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
&lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.master.port&lt;/name&gt;
&lt;value&gt;16000&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
&lt;value&gt;node01:2181,node02:2181,node03:2181&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.rootdir&lt;/name&gt;
&lt;value&gt;file:///usr/local/hbase/hbase-tmp&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
&lt;value&gt;/opt/zookeeper/zkdata1&lt;/value&gt;
&lt;/property&gt;
（5）配置conf目录下的hbase-env.sh文件
vi /opt/hbase/conf/hbase-env.sh
添加如下配置信息
export JAVA_HOME=/opt/jdk
export HBASE_MANAGES_ZK=false
（6）配置conf目录下的regionservers文件
vi /opt/hbase/conf/regionservers
添加如下配置信息 node01
node02
node03
（7）将Hadoop配置文件core-site.xml和hdfs-site.xml复制到Hbase的conf目录
cp /opt/hadoop/etc/hadoop/core-site.xml /opt/hbase/conf/
cp /opt/hadoop/etc/hadoop/hdfs-site.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55a5da74f765f7dd9f41e3b680ced16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef78873edf81159725b4ef92b9e73400/" rel="bookmark">
			有符号二进制加减法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		补码 补码没有符号位，都是数值位！补码的意义：找到一个正数来表示原来的负数，让减法变为加法！
原码、反码、补码转换 正数：原码=反码=补码
负数：
原码除符号位不变，其他二进制位取反，得到反码
反码+1得到补码（符号位参与计算）
补码-1得到反码（符号位参与计算，可以理解补码没有符号位，都是数值位，因为补码的意义在于找到一个正数来代替原来的负数）
反码除符号位不变，其他二进制取反，得到原码
有符号二进制加减法（原码、反码、补码） 二进制加减法的符号位都是参与计算的。
二进制原码加减法 使用二进制原码进行加法是OK的，但是原码在做减法运算时，要比较两个数的绝对值，判断最终的符号，以绝对值大的数 减去 绝对值小的数，最终得到结果，过程太复杂。
如果计算机采用原码做加减法，并让符号位参与计算，对减法来说，结果是不正确的，例如：求2-1？
2的二进制为：00000010
-1的二进制为：10000001
那么：2-1=2+(-1)=00000010+10000001=10000011=-3
计算结果显然不正确。
计算机中使用的当然不是原码去表示一个数，而是补码。
二进制反码加减法 为了解决原码减法出现的问题，出现了反码计算减法，虽然反码的结果是正确的，但问题出现在“0”这个特殊值，例如 1-1=[0000 00001]反 + [1111 1110]反 = [1000 0000]原 = -0。
虽然+0和-0是一样的，但带符号的0是没有意义的，而且会出现[0000 0000]原和[1000 0000]原 两个编码表示0。
二进制补码加减法 反码计算出现了两个0的问题，于是出现了补码，可以解决0符号的问题。
以二进制数A和B为例，计算步骤：
1.转成补码后直接相加，符号位也参与运算，如果符号位产生了进位，必须舍去进位，得到的结果仍是补码
2.如果符号位是0，表示正数，即最终结果
3.如果符号位是1，表示负数，必须把补码转成原码才能得到正确的值（补码-1，然后取反）
以十进制数A和B为例，计算步骤：
1.求绝对值A+绝对值B的和，判断几位二进制位表示数值位，此外还有一个符号位，例如7+4=11，需要4个二进制位和1个符号位，一共5个二进制位
2.参见以“二进制数A和B为例的计算步骤”
案例 案例1：求7+4？ 解：
7+4=11，需要5个二进制位
原码：0 0111 + 0 0100
反码：0 0111 + 0 0100
补码：0 0111 + 0 0100 = 0 1011
结果：11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef78873edf81159725b4ef92b9e73400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfccc041df4d9488e1367b262390dcf9/" rel="bookmark">
			FreeSWITCH的acl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		acl.conf.xml的开始几行就给出了注释，说这些acl会自动创建：
rfc1918.auto - RFC1918 Space
nat.auto - RFC1918 Excluding your local lan.
localnet.auto - ACL for your local lan.
loopback.auto - ACL for your local lan.
上面每个项目都非常清楚。
可惜还是有少数人不去留意这些，导致一些低级错误。
我曾经碰到过一个故障，就是originate sofia/internal/1234@ip_addr呼叫公网地址，fs应该给ext-sip-ip和ext-rtp-ip，但是没有这么做，呼叫任何地址都给local_ip_v4，查了半天才知道这哥们覆盖了loopback.auto，他是这样定义的：
&lt;list name="loopback.auto" default="allow"&gt; &lt;/list&gt; 这样测试：
fs_cli -x 'acl 127.0.0.1 loopback.auto' true # 这个没问题 fs_cli -x 'acl 113.113.113.113 loopback.auto' true # 但明显是个nat地址，怎么会是回环地址呢？ mod_sofia是这样检查nat的：
int sofia_glue_check_nat(sofia_profile_t *profile, const char *network_ip) { switch_assert(network_ip); return (profile-&gt;extsipip &amp;&amp; !switch_check_network_list_ip(network_ip, "loopback.auto") &amp;&amp; !switch_check_network_list_ip(network_ip, profile-&gt;local_network)); } profile已经定义了extsipip，地址不是loopback.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfccc041df4d9488e1367b262390dcf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc994807ef2f8b2bfffe0913e2c6eff/" rel="bookmark">
			CentOS 7清理删除卸载 Docker环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 杀死所有运行容器
docker kill $(docker ps -a -q) 删除所有容器
docker rm $(docker ps -a -q) 删除所有镜像
docker rmi $(docker images -q) 停止docker服务
systemctl stop docekr 删除存储目录
rm -rf /etc/docker rm -rf /run/docker rm -rf /var/lib/dockershim rm -rf /var/lib/docker 如果发现删除不掉，需要先 umount，如 umount /var/lib/docker/devicemapper 卸载docekr
查看已安装的docker包
yum list installed | grep docker 卸载相关包
yum remove docker-ce-* 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505b9b8dd859c332417151a181f7e057/" rel="bookmark">
			二进制的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 计算机最喜欢的数字就是 0 和 1，在 CPU 的世界中，它只认识这两个数字，即使是强大的操作系统，也都是由 0 和 1 组成的。
作为一名软件开发者，入门学习的内容可能就是认识这 2 个既简单、又强大的数字。但是大部分人，对于二进制、二进制计算、原码、反码以及补码的认识，仍处于机械的强制记忆阶段。尤其是对一些编码和计算，仍然处于模糊的认识阶段，例如：
CPU 是如何表示负数的？
为什么补码可以用来表示负数？
一个 8 位的二进制数，最小值为什么是 -128，而不是 -127？
CPU 中的加法器，为什么可以连同符号位一起运算？
这篇文章我们就来聊聊这个最最基础的内容，帮助你来理解二进制计算的相关内容，看完这篇文章之后，不仅知其然，更能知其所以然！
PS: 这里有点高调了，最终的所以然部分，应该涉及到数学证明这一层次了，本文并不会涉及到求证过程。
二、从十进制到二进制 1. 十进制
作为数学计算能力强大的中国，10 以内的加减法，应该是在幼儿园阶段就完成了。如果你不属于这个范围，说明你上的是假幼儿园。
我们来快速复习一下关于十进制运算的一些基本知识:
每一个数位上包括的数字为 0 到 9；
每一个数位上的数，是它右侧数位的 10 倍；
两个数相加时，相同数位上的数相加之和如果大于等于 10，就向前进 1 位，即：满十进一；
具体来看就是：
从右数第一个位数(个位)上的数字代表多少个 1；
从右数第二个位数(十位)上的数字代表多少个 10；
从右数第三个位数(百位)上的数字代表多少个 100；
从右数第四个位数(千位)上的数字代表多少个 1000；
十进制的数，可以使用后缀字母 D 来表示，也可以省略。例如：十进制的 1234 这个数字，个位上的数是 4， 十位上的数是 3， 百位上的数是 2，千位上的数是 1（一般是从最右侧的个位说起），每一个数位上的数比它右侧大十倍。 如下图：
十进制数据，也称作基于十的表示法。
2. 二进制
那么对于二进制呢？直接套用上面十进制的概念，然后把 10 换成 2 即可(目前先忽略符号位)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505b9b8dd859c332417151a181f7e057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3f884b22260c067b61d9afb57d4495/" rel="bookmark">
			MySQL 中创建非 root 用户（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、使用root账号登录MySQL服务器： mysql -u root -p 2、使用命令创建一个新的用户帐户CREATE USER。 例如，以下命令创建一个
用户：newuser密码：xxxxxx CREATE USER 'newuser'@'localhost' IDENTIFIED BY 'xxxxxx'; 注意：
该@'localhost’命令的一部分指定仅允许用户从本地主机进行连接。如果你想允许来自任何主机的连接，你可以使用’newuser’@‘%’。 CREATE USER 'newuser'@'%' IDENTIFIED BY 'xxxxxxx';	#任何主机的连接 4、使用命令向新用户授予权限GRANT。 例如，以下命令授予对名为 test 的数据库的所有mydatabase权限newuser：
GRANT ALL PRIVILEGES ON test.* TO 'newuser'@'localhost'; 5、最后，刷新权限以使更改立即生效。 FLUSH PRIVILEGES; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55b85ae1b17fbdaf6b729a7d4ca4c66/" rel="bookmark">
			【数电基础】——逻辑代数运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概念 1.基本逻辑概念
2.基本逻辑电路（与或非）
逻辑与运算 与门电路：
逻辑或运算 或门电路：
​逻辑非运算（逻辑反）
非门电路​编辑
3.复合逻辑电路（运算）
与非逻辑运算 或非逻辑运算
异或逻辑运算
同或逻辑运算
2.二选一数据选择器
3.三态门输出电路（有使能信号）
4.逻辑代数的基本定律 5.逻辑代数的基本规则 ​6. 逻辑函数的两种标准形式​编辑
7.逻辑函数的代数化简化
8.有效逻辑电平
1.概念 1.基本逻辑概念 二值数字逻辑：0和1表示两种对立的事务状态（逻辑0和逻辑1）
高电平（接电源）：表示逻辑1和二进制1
低电平（接地）：表示逻辑0和二进制0
逻辑代数：按照一定逻辑规律进行运算的代数，主要研究逻辑函数和逻辑变量之间的因果关系，而不是数量之间的运算。
逻辑变量常用大写字母A B C表示，逻辑变量的取值要么是1，要么是0
逻辑运算：条件和结果的状态分别用逻辑1和0表示.
逻辑函数以及表示方法：
逻辑函数及其表示方法：
逻辑真值表
逻辑函数表达式（简称逻辑表达式或函数式）
逻辑图
波形图
卡诺图
硬件描述语言
举例：
1.逻辑真值表
2.真值表
3.逻辑函数表达式
2.基本逻辑电路（与或非） 逻辑与运算 与门电路： 逻辑或运算 或门电路： 逻辑非运算（逻辑反） 非门电路 3.复合逻辑电路（运算） 与非逻辑运算 或非逻辑运算 有1为0，全0为1
异或逻辑运算 不同为1，相同为0
同或逻辑运算 相同为1，不同为0
2.二选一数据选择器 3.三态门输出电路（有使能信号） 4.逻辑代数的基本定律 对逻辑电路进行化简，变换，分析和设计 证明：
5.逻辑代数的基本规则 6. 逻辑函数的两种标准形式 7.逻辑函数的代数化简化 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55b85ae1b17fbdaf6b729a7d4ca4c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd10afd948706bd8111779f7a3fbea8f/" rel="bookmark">
			js获取对象数组中的id集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js获取对象数组中的id集合
const ids = Array.from(this.checkList,({ id }) =&gt; id); // ["16921C72E0C64002","16898B37FC66E002"] const ids = this.checkList.map(item =&gt; Object.assign({}, {'id': item.id})); // [{"id":"16921C72E0C64002"},{"id":"16898B37FC66E002"}] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602e67055034b5e68bcc17f6b49d0faf/" rel="bookmark">
			react黑马前端学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React 一、React概述 1.1简介 react是一个用于构建用户界面的js库
用户界面：HTML页面
React主要用来写HTML页面或者构建Web应用
如果从MVC的角度来看，React仅仅是视图层，也就是只负责视图的渲染，而并非提供了完整的M和C的功能。
React起源于Facebook的内部项目，后来又用来架设Instagram的网站，并于2013年5月开源
1.2React特点 1、声明式 只需要描述UI（html）看起来是什么样，就跟写HTMl一样（JSX）
React负责渲染UI，并在数据变化时更新UI
const jsx=&lt;div className='app'&gt; &lt;h1&gt;hello react! 动态变化数据:{count}&lt;/h1&gt; &lt;/div&gt; 2、基于组件 组件是react最重要的内容
组件表示页面中的部分内容
组合、复用多个组件，可以实现完整的页面功能
3、应用广 web移动端vr应用 ​ …
1.3React的安装 vscode中在终端选项中新建终端
cd命令选择在当前文件夹中安装，命令：npm i react react-dom
来创建两个包
react 包是核心，提供创建元素、组件等功能react-dom包提供DOM相关功能 二、React的基本使用 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J34I2z2P-1677566304596)(C:\Users\ZYJ\AppData\Roaming\Typora\typora-user-images\image-20230215185607422.png)]
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- 1、引入js文件 --&gt; &lt;script src="./node_modules/react/umd/react.development.js"&gt;&lt;/script&gt; &lt;script src="./node_modules/react-dom/umd/react-dom.development.js"&gt;&lt;/script&gt; &lt;script&gt; // 2、创建react元素 //参数一、元素名称 // 参数二、元素属性 // 参数三、元素子节点 const title = React.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602e67055034b5e68bcc17f6b49d0faf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f85375828c0b60c406e96fd10a301f/" rel="bookmark">
			使用Java实现高效的字符串匹配算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：字符串匹配是计算机领域中的一个重要问题，有着广泛的应用场景。在本篇博客文章中，我们将介绍几种高效的字符串匹配算法，并给出使用Java语言实现的代码示例，希望能对读者理解和应用这些算法有所帮助。
一、KMP算法
KMP算法（Knuth-Morris-Pratt算法）是一种经典的字符串匹配算法，它的核心思想是根据模式串的前缀和后缀的相同部分，尽可能地减少匹配的次数。具体来说，KMP算法通过构建模式串的前缀匹配表（也称为“失配函数”），来实现在匹配过程中跳过一些无需匹配的位置。这样可以有效地减少比较次数，提高匹配效率。
以下是KMP算法的Java实现代码示例：
public static int kmp(String text, String pattern) { int n = text.length(), m = pattern.length(); int[] fail = new int[m]; Arrays.fill(fail, -1); for (int i = 1, j = -1; i &lt; m; i++) { while (j &gt;= 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j + 1)) { j = fail[j]; } if (pattern.charAt(i) == pattern.charAt(j + 1)) { j++; } fail[i] = j; } for (int i = 0, j = -1; i &lt; n; i++) { while (j &gt;= 0 &amp;&amp; text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f85375828c0b60c406e96fd10a301f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8f03c39fdaa36afb1db3ff09ba1193/" rel="bookmark">
			Ubuntu Netplan修改网卡配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Netplan —— 抽象网络配置生成器 ，是一个用于配置 Linux 网络的简单工具。 通过 Netplan ，你只需用一个 YAML 文件描述每个网络接口需要配置成即可。
Ubuntu网卡的默认配置是DHCP，但是你作为服务器使用时往往需要固定IP地址，通过网络连接里面修改的IP地址，往往重启之后，就又新增了网络的新连接而且又是DHCP类型，导致其不能固化，所以使用Netplan可以将其改为static，这样可以保证不论是重启网络或者是重启服务器时，启动之后可以正常的工作。
更改yaml配置文件，sudo vim /etc/netplan/config.yaml：
network: version: 2 renderer: NetworkManager ethernets: enP3p49s0: addresses: [192.168.77.133/24] gateway4: 192.168.77.1 nameservers: addresses: [192.168.77.1, 114.114.114.114] 保存配置以后，执行 sudo netplan apply生效。
查看配置ifconfig 或者ip route。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f3f9c489f9f12e8f96fcbe05e64749/" rel="bookmark">
			【项目展示】简单OpenGL项目-飞机驾驶游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 项目为大三的课程作业，主要工作为编写了向量类、矩阵类、欧拉角类、四元数类，提供对其的基本操作以及相互之间的转换，然后在编写的类的基础上使用OpenGL在空间中绘制管道、视角控制及操作飞机在管道中飞行，绘制包围盒及进行碰撞检测
展示 读取数据绘制管道构成文字，以及在场景中漫游：
切换至飞机视角并操控飞机：
显示两种包围盒以及飞机与管道的碰撞：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541c6470c303809768855b562b53bcba/" rel="bookmark">
			一文读懂数据中台架构体系（收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号：互联网架构师，后台回复 2T获取2TB学习资源！
上一篇：Alibaba开源内网高并发编程手册.pdf
当前，大部分企业不再建设从源数据采集到分析应用的烟囱式系统，更倾向于数据集中采集、存储，并应用分层建设。这种方式一方面有利于应用系统的快速部署，另一方面也保证了数据的集中管理与运营，体现数据的资产、资源属性。
数据中台的出现弥补了数据开发和应用开发之间由于开发速度不匹配而出现的响应力不足等缺陷问题。
数据中台是国内学者提出的概念，起始于阿里的“大中台、小前台”概念。阿里的中台是从管理的角度出发，以中台事业部集中数据搜索，技术及产品，数据共享等多个部门的功能。其他组织或企业建设数据中台不一定需要成立中台事业部，但是数据集中治理与提升数据价值转换效率的思路是一致的。
— 01 —
数据中台通用体系架构
不同的企业对数据有不同的需求。企业数据应用不断更新迭代，企业的中台系统也需要不断变化。
从数据处理与数据治理两个维度出发，可以设计一个解耦的数据中台体系架构。该数据中台体系架构具有一定的柔性，可按照企业应用需求进行组合，或者对单个模块进行扩充，能满足大多数企业数据中台建设的需求。
数据中台体系架构示例
数据中台的通用体系架构如图 2 所示。该中台体系架构以减少功能冗余和提高功能复用为原则，把数据中台解耦为 6 个可以分别独立建设、演进的功能子系统。
数据结构与数据处理子系统是数据中台体系架构的核心，数据治理是提升数据价值的重要手段。该数据中台体系架构的通用性表现在以下几点。
该数据中台体系架构综合考虑了数据中台的各种要素，参考这个架构进行建设可以有效提升数据资产价值，提供数据及服务的共享。
参考这个数据中台体系架构，企业可以一次规划、分步实施。首先建设处理子系统及数据存储子系统，然后根据业务发展需求，逐步补充数据采集、数据安全及数据治理子系统。
该数据中台由 6 个解耦的子系统组成。企业在立项建设时可以灵活组合，每个子系统单独招标建设，也可以把多个子系统合并招标建设。数据中台通用体系架构包含数据存储框架、数据采集框架、数据处理框架、数据治理框架、数据安全框架及数据运营框架等 6 大部分。
1、数据存储框架
数据中台的核心是数据，数据通过采集系统获取，然后数据经过处理框架加工，并接受数据治理框架的管理，同时也要接受数据安全管理框架的管理，最后开放的价值数据将通过数据运营框架对外提供数据服务。
数据中台的数据架构应该独立规划，并采用合理的技术架构对不同类型的数据进行存储。
数据存储框架中，无论数据采用对象存储、块存储还是数据库存储技术，各种中台数据可按照上图所示分类管理。
源数据主要由采集框架进行管理，数据治理框架按照数据特征把数据简单分为结构化和非结构化数据两大类，而规范化分域数据则是数据治理框架对全量数据的规范化分域整理。宽表数据是数据关联的结果，利用宽表数据可以对人、事、地、物、组等对象进行完整的数据画像，同时宽表数据也可以作为上层模型数据的中间层数据。
元数据和标签数据都是对数据的描述，其中元数据用来对数据的客观属性进行表示，标签数据更倾向于管理者对数据的主观表述及等级划分，比如质量等级标签、安全标签、属性标签等。主数据需要在各系统间频繁更新、交换，且需要独立的存储空间进行维护管理。
2、数据采集框架
数据中台的采集框架应对纳入数据中台的各种源数据进行统一采集管理。数据采集框架中应提供多种数据采集方式，如文件传输协议采集、数据库采集、接口应用程序接入采集、流式采集及网络爬虫采集。
同时采集框架应按照数据采集规范对源数据进行预处理，从而去除明显不需要的数据及多余数据，并对采集过程进行管理。虽然数据中台的体系架构没有统一模板，但各企业数据采集框架基本一致。
3、数据处理框架
数据处理是每个数据应用的基本环节之一，经典的数据抽取、转换和加载（ETL）处理流程在数据采集预处理、数据整合、数据建模等多个地方均要使用。单独建设数据处理框架有利于数据处理工具组件的集中开发与管理，也有利于数据中台数据处理任务的协调与调度。
数据处理框架专门负责数据处理相关的任务，包括批处理、流处理、人工智能分析、数据清洗、数据交换及查询，此外数据处理的相关工具组件可在处理框架中配置。任务调度模块在数据处理框架中处于居中指挥的作用，并对运行的数据处理任务进行监控及异常处理等操作。
4、数据治理框架
广义的数据治理不仅包含提升数据价值的内容，如数据管理、数据目录、数据质量等，也包含数据安全管理及数据共享服务。
数据安全管理与数据价值提升是一个矛盾体，如果由一个厂商或开发团队进行数据安全管理及数据价值提升相关软件的开发，则开发者的操作难免有所偏向，而且矛盾不容易公开，少了冲突也就少了优质的解决方案。
另外，数据共享与数据治理的其他内容也存在相同的问题。因此，本文建议数据中台的数据治理框架中不包含数据安全与共享的相关内容。
数据治理框架包含数据目录、数据管理、模型管理和数据质量 4 个模块：
数据地图、数据资产目录、知识图谱及数据血缘的主要作用是展示数据的属性及相互关系，因此都纳入数据目录模块。
数据模型能提高数据中台对外部应用需求的反应能力，固化的中间模型数据需要专门管理。模型管理包括模型目录、模型血缘及模型地图等。
数据管理又可以细分为元数据管理、主数据管理、标签数据管理及源数据管理。
数据质量管理模块按照制定的数据标准及数据稽核规则对数据中台中的数据进行质量管理。
5、数据安全框架
数据已经成为数据资产，数据安全框架是数据中台必不可少的组成部分。数据安全叠加在数据中台其他功能框架之上，数据采集、处理、交换、共享等每个环节均必须实施安全控制策略。安全框架可以分为日志管理、用户认证、权限管理及加解密等几个功能模块。
此外，安全全门户也可以对外提供安全能力封装，展示数据中台的安全态势及安全视图。
6、数据运营框架
数据中台的核心功能是综合众多数据应用的数据处理及数据治理功能，集中建设、集中管理、减少冗余、增加复用。数据中台的最终目的还是为其他应用或开发者提供数据服务，而对外数据服务功能将直接面向不确定的外部对象。
因此单独建设数据运营，一方面有利于针对外部用户提供针对性功能；另一方面，数据运营模块作为用户与数据中台核心数据服务之间的中间层，可以有效隔离外部用户直接控制、接触核心数据及应用，可保护数据中台的安全性及内部功能的稳定性。
综合以上因素，数据运营应配置运营门户、能力开放、数据开放及运营监控等功能：
运营门户：对数据中台管理者提供管理门户，对开发者提供开发者门户。
对内部应用提供内部应用门户，对外部应用提供外部应用门户。运营门户针对不同的用户提供不同的通道并开放不同的数据中台能力。
能力开放：把数据中台的数据处理能力、数据分析能力等经过适当的封装后对用户提供服务，可以是微服务，也可以是 API 接口，或者直接提供二次开发能力。
数据开放：通过数据目录，数据/模型展示（可视化、数据视图等）为其他数据应用系统提供数据服务。
运营监控：对数据中台的总体运营情况进行监控管理，包括硬件环境、软件环境，并且确定监控指标，按需求提供运营日报，处理告警信息。
— 02 —
数据中台典型架构
数据中台的目标是让数据持续用起来，通过数据中台提供的工具、方法和运行机制，把数据变为一种服务能力，让数据更方便地被业务所使用。下图所示为数据中台总体架构图，数据中台是在底层存储计算平台与上层的数据应用之间的一整套体系。
数据中台总体架构图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541c6470c303809768855b562b53bcba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a642d4408c6e18ea167998e1a33ea41d/" rel="bookmark">
			onnx网络中指定层的结果/中间层结果获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 有时候我们需要对模型推理的中间层结果进行对比分析，这时候如何方便快捷地将指定中间层的结果保存下来就很重要了。具体方法如下： 核心：在模型推理之前将指定的中间层/所有的层放到输出节点中 代码 from onnx import load_model, save_model import onnx import onnxruntime as rt import torch import numpy as np from collections import OrderedDict # 该设置可以将每层tensor完整地输出，而非输出部分（即省略中间，只显示收尾） # tips：终端中通常不能全部显示大尺寸的tensor，可以重定向到文本中~ np.set_printoptions(threshold=np.inf) def to_numpy(tensor): return tensor.detach().cpu().numpy() if tensor.requires_grad else tensor.cpu().numpy() def read_file(N, C, H, W, bin_path): input_size = N * C * H * W file = open(bin_path, "rb") data = np.fromfile(file, dtype=np.uint8) data = data.astype(np.float32) / 255 data_tensor = torch.from_numpy(data[0:input_size]) return data_tensor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a642d4408c6e18ea167998e1a33ea41d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218593c664e574e1c9a9de84c013687a/" rel="bookmark">
			java中的强制线程(插队)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 线程插队就是说的是主线程执行过程中不让其先执行，让我们想执行的线程进行执行。
线程插队用到的函数是Thread里面的Join()函数
代码如下:
package ThreadStudy.TestThread; //线程强制//插队 public class TestJoin implements Runnable { @Override public void run() { for (int i = 0; i &lt; 200; i++) { System.out.println("我是线程vip请让路"+i); } } public static void main(String[] args) throws InterruptedException { TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin);//创建的线程 thread.start();//开启线程 for (int i = 0; i &lt; 500; i++) { if (i==200){ thread.join();//如果主线程执行到200的时候会被停止,然后会执行自己创建的线程 } System.out.println("main"+i);//主线程执行的代码 } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c7da2aeffffb956ae8fa63903f186f/" rel="bookmark">
			java中的线程礼让
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要注意的是线程礼让根据CPU的调度进行礼让，有点时候可能不会成功，但是大部分情况会成功的。
Thread里面有一个礼让函数yield();
线程礼让是让各个线程先运行,运行完之后才会停止全部线程。
如下图所示：
测试代码
代码如下：
package ThreadStudy.TestThread; //线程礼让,可以礼让成功,但是需要看CPU心情 public class TestYield { public static void main(String[] args) { Yield yield = new Yield(); Thread thread = new Thread(yield,"a");//创建线程a Thread thread1 = new Thread(yield,"b");//创建线程b thread.start();//开启线程 thread1.start();//开启线程 } } class Yield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+"线程开始"); Thread.yield();//线程礼让,等待线程a开启之后才会线程停止 System.out.println(Thread.currentThread().getName()+"线程停止"); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a6d269957548326e83225f5de9fda9c/" rel="bookmark">
			【高性能计算】TVM使用TE手动优化矩阵乘法算法解析与代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 注：本文主要介绍、解释TVM的矩阵优化思想、代码，需要配合代码注释一起阅读。
矩阵乘法是计算密集型运算。为了获得良好的 CPU 性能，有两个重要的优化措施：
提高内存访问的高速缓存命中率。复杂的数值计算和热点内存（hot-spot memory）访问都可以通过高缓存命中率（high cache hit rate）来加速。这就要求我们将原内存（origin ）访问模式转化为符合高速缓存策略的模式。
SIMD（单指令多数据），也被称为矢量处理单元。在每个周期中，SIMD 可以处理一小批数据，而不是处理一个单一的值。这就要求我们将循环体中的数据访问模式转化为统一模式，以便编译器后端可以将其降低到 SIMD。
1- 基于TVM和Numpy的基线实现 这是numpy 实现矩阵乘法的实现代码，作为实现比较的基础benchmark，他的速度并不会很慢，这是因为其本身就采用了加速矩阵数学计算的算法实现。
import tvm import tvm.testing from tvm import te import numpy # The size of the matrix # (M, K) x (K, N) # You are free to try out different shapes, sometimes TVM optimization outperforms numpy with MKL. M = 1024 K = 1024 N = 1024 # The default tensor data type in tvm dtype = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a6d269957548326e83225f5de9fda9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f20dc75f65574f829476d495af82ea/" rel="bookmark">
			今天终于知道了，阿里巴巴 P8、P9 及以上到底是什么水平？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做人做事不能万事向钱看，但是钱这个东西很多时候都反映了事物的价值以及一个人的能力水平。
比如阿里P8、P9 这些拿着高薪的程序员他们的技术水平就一直是大家好奇的。
今天在逛某乎的时候就恰好看见了一个几百万人关注的问题：
阿里的高p们动辄百万以上年薪，他们到底水平有多高？阿里巴巴 P8、P9 及以上到底是什么水平？
阿里高P技术之谜 阿里巴巴的科技创新力在所有的互联网公司中差不多一直都是领头羊的地位，使用的技术也一直都走在前沿。在行业内，很多互联网公司都将阿里作为自己的标杆，阿里的人才标准是很多程序员的发展目标和学习方向。越来越多的打工人都希望能够进阿里“搬砖”。
值得一提的是阿里程序员们除了完成自己的本分工作以外，还会抽出时间去琢磨新技术并进行开源分享，为开发社区做出了很多贡献。阿里的技术人员们在网上的存在感也远远高于百度腾讯的高级技术人员，如章文嵩、褚霸还有各位有名的dba们就不一一列举了。
普通的技术人员应聘阿里绝大部分都是p6、7水平，但是要再上的话有一层鸿沟隔离，不管是晋升制度上还是个人能力上都有很大的差距。
在这里，我觉得很有必要说一下阿里的升职几大因素的排序。
阿里升职因素的排序 首先我们来看一张阿里高P职级官方描述的表格：
首先，他们的专业能力，技术方面是绝对过关的，起码不会差。
P8P9再往上已经不仅仅是专业能力问题，因为P8及以上专业能力都不会差，主要是对业务的敏感度，专业的影响力，能够引领团队做出更大的事情等等。
换句话说，级别越高，在专业知识和能力之外，基石能力越重要，基石能力是指无论什么岗位都需要掌握的通用能力，例如沟通能力、组织能力、逻辑能力、风险控制能力等等。
每升一级都是一个坎。很多朋友P7升P8、P8升P9，中间遇到困难，往往犯的错误就是只看到专业技能的方面，忽视了自己的基石能力。从P7开始，就不能只看专业知识和技能了。
另外还有一个容易忽视的地方：影响力。包括内部的影响力，影响自己的团队、合作的团队，也包括外部的影响力，在行业内通过专业能力建立影响力。这些都很重要。你得擅长把做的东西讲出来，让更多的人知道。很多人都是只会做不会讲，还认为自己这样是踏实，其实这是能力缺失，没有展现自己的意识和方法。
此外还有一些潜在的因素，例如自己在内部的生态位，选择合适的业务和老板等等。职场上的各种利益关系、人际关系，如果你觉得没有，只能说明你的重要性还不够高，或者你的职场基石能力不够，连这些都没发现。
下面说一下在阿里，或者说大公司要想升职需要做些什么。
赶风口 在阿里赶风口，就是去一个风口上的事业部，搞新业务、重点业务。
比如前些年的支付宝、盒马（非技术）。阿里升P8，P9难不难？难！很多人应该都听说过6升7通过率，7升8通过率，于是根据金字塔结构，推导出8升9应该难爆了。 事实是：最近几年，支付宝P8升P9的成功率大概在5/8，这个通过率可还行？
造风 造风也就是通常说的“搞事情”。搞大了就是行业变革，搞小了也是升职项目。
阿里内部绝大多数高P升职应该靠的就是这种，领导们争夺地盘也要靠下面小弟”搞事情“，所以社招面试P7就得考察这点能力。
拼实力 活还是需要人做的，你的硬实力(技术 or 项目管理)够强，升到P8问题不大。造成外面小白觉得阿里P8，P9技术很屌，也是因为这帮人存在。！幸存者偏差嘛，你们在网上看到的阿里技术大牛只占阿里所有P8，P9中的1%，剩下99%都是”平凡无奇“的技术普通人。由于我自己所在的BU不强势，所以从来没见过硬实力P9。
机遇 领导关照！也就是裙带关系、向上管理。比如百度哈工大帮，网易浙大老白兔帮等等，阿里一样。
熬 这也是阿里佛系躺平员工的正常路子。现在熬起来挺慢的，个人能力不强，遇到的业务又渣渣的话，硕士毕业熬3-4年升P6，再熬3-4年升P7。
总的来说，年轻的p9（35以内）技术型的p9普遍还是能力很强。他们大部分的70后p9都是管理型的，老阿里的话（5年以上的），一半左右都是老油条了，建议尽量远离。
总结 要想成为高P，首先是技术。底层原理这些是必须要了解和熟悉的。这里免费分享给想要钻一下底层源码，想要进阶学习的朋友们一份学习资料500页+详细完整版的《Android Framework源码解析》。
由于篇幅原因，本文精选几个章节，详细版扫码免费领取
第一章 系统启动流程分析 第一节 Android启动概览第二节 init.rc解析第三节 Zygote第四节 面试题 第二章 跨进程通信IPC解析 第一节 Sercice 还可以这么理解第二节 Binder基础第三节 Binder应用第四节 AIDL应用（上）第五节 AIDL应用（下）第六节 Messenger原理及应用第七节 服务端回调第八节 获取服务（IBinder）第九节 Binder面试题全解析 第三章 Handler源码解析 第一节 源码分析第二节 难点问题第三节Handler常问面试题 第四章 AMS 源码解析 第一节 引言第二节 Android架构第三节 通信方式第四节 系统启动系列第五节 AMS第六节 AMS 面试题解析 第五章 WMS源码解析 第一节 WMS与activity启动流程第二节 WMS绘制原理第三节 WMS角色与实例化过程第四节 WMS工作原理… 第六章 Surface源码解析 第一节 创建流程及软硬件绘制第二节 双缓冲及SurfaceView解析第三节 Android图形系统综述… 第七章 基于Android12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f20dc75f65574f829476d495af82ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8251398ef0f375ae39404c5699e234/" rel="bookmark">
			华为面试题就这？00后卷王直接拿下30k华为offer......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先说一下我的情况，某211本计算机，之前在深圳那边做了大约半年多少儿编程老师，之后内部平调回长沙这边，回来之后发现有点难，这边可能是业绩难做，虚假承诺很厉害，要给那些家长虚假承诺去骗人家，技术上也没啥提升，工资自然也不会有提升（不说提升了，不降就是幸运的了），后面就辞职了，然后自学一段时间就面华为od（现在这环境，我这情况这样很满足了）。
前期准备 因为之前也带学生打csp，所以对我来说做题不算很难的事情，把华为hj103刷穿了，自己另外刷了一些动态规划的题目。
之后问hr要了机考链接，稍微把之前刷的题过了一遍，找了些真题做了一下，就去考了。也是绝了，考试之前专门和家里面的人打了电话说不要给我打电话，免得影响考试，结果那天晚上社区的人来查什么天然气使用情况，咚咚咚地敲门，给我整得有点紧张。
面试过程 说说题目： 第一题
是一道模拟题，给你一个数字n和接下来的n行字符串，字符串是考勤记录，让你判断哪些记录是异常的。就这么一个题，我不知道是读题有问题还是怎么的，只能过30%多的样例，磨了几十分钟，放弃掉开始做第二第三题。
第二题
第一个字符是R，第二是是BR，第三个是RBBR，第四个是RBBRRBBR.......问你给你一个数字n和一个数字k，表示第n个字符串的第k个字符，这个字符是什么，是B则输出blue，是R则输出red
这是一个典型的dp，但是直接写的话，空间复杂度是2^n，需要用二分优化一下，简单。
第三题
给你一堆数字，问你其中能组成直角三角形的最大组合数，需要用搜索回溯做。
接下来就是性格测试，按照乐观、乐于助人、愿意加班去选就行了，后来性格测试也过了。
结果过了之后hr说这边没hc了，问我去不去西安，我选择了不去。后面又告诉我有一个hc，让我抓紧准备。
一面过了，感觉还是蛮简单的，可能人家面试官知道我是转行的，没有问很深的问题为难我吧。
开始面试，直接发了一道题过来，让我先做。
题目是这样的：
源数组a，将a中所有元素乘以2之后添加进a，则这个a就叫双倍数组，给你一个数组a，判断它是不是双倍数组，如果是则输出源数组，不是则输出空数组。
思路：
接受输入，存入a，拷贝一份存入b，另外开两个数组single，double用于筛选之后的存储，以i遍历b，如果i*2在a中，则从a中弹出i和i*2，并将其分别添加进single和double中。
遍历完成之后，a如果为空，说明所有的元素都被筛选出来了，则a是一个双倍数组，将single输出，否则输出空数组。
需要特别注意的是0的筛选，因为0*2还是0，可以提前写个特判处理下。
做完之后面试官简单看了下，让我说了下思路。然后就是自我介绍，我简单介绍了一下自己写的两个自动化程序，和一个之前带学生参加比赛写的Python程序，面试官看完表示比较满意，说可以和测试工作结合起来，后面问了一个场景题目，延伸问题的时候就提到了我会一点自动化的技能跟测试工作的联系。
问了：你觉得功能测试，按照你的理解，工作内容包括哪些？
说实话，我感觉这个问题对我来说实在太抽象了，就把测试流程答了一遍。然后面试官可能觉得答得不好，但是不想给我太负面的评价，支支吾吾说了个：你这答得确实比较基础
问了：黑盒测试和白盒测试的区别
这个简单，黑盒能看到功能、UI，看不到代码，白盒可以看到代码。
问了：假设我们公司现在开发一个类似于微信的软件1.0版本，现在要你测试这个功能：打开聊天窗口，输入文本，限制字数在200字以内，问你怎么提取测试点。
这个场景题我答的也不算很好，想到了使用等价类划分法进行测试样例的设计，有效等价类就是打开聊天窗口，输入一段200字以内的文本，无效等价类包括打开聊天窗口，输入非文本信息，比如尝试粘贴图片；打开聊天窗口，输入文本信息，字数超过200字；
后来经过面试官提醒，说了需要做兼容性测试，测试在不同系统上，pc和移动端，功能是否正常，还有前置条件要保证网络正常。
然后继续问：你觉得会的自动化技能怎么跟这个测试场景联系起来，怎么做自动化测试。
因为我刚才展示的自动化程序里面有一个就是自动回复微信消息的，跟这个很像，就答了刚才那个程序稍稍改一下就可以用来做这个测试工作，另外需要添加的功能应该是需要读取excel表格中的数据，用于测试。
问了：接口测试的工具你了解哪些
这我也不太知道，就说了一个postman还有jmeter
然后就是反问环节，问我有啥要问的。
我问了，对于软件测试这个岗位而言，我还有哪些需要提升的地方。
如果入职，咱们公司有哪些措施帮助和监督新人成长
随着技术的提升会有调薪吗？
总的来说，做题和展示我的代码的环节我觉得还是表现得不错的，但是后面问的一些跟测试关系比较深的问题答的都不算特别好。
哦对了，还有一个插曲，问了我一个linux命令
问如果想把一个文件移动到另一个文件夹里面去，用什么命令
我张口就来：rm！！！
说完之后，我感觉对方似乎愣了一下
我自己也反应过来，口快说错了，马上纠正说是move，命令是mv
该说不说，面试的小乌龙也太好笑了吧！
总结 最后感谢每一个阅读我文章的人，一点小心意，虽然不是啥值钱的，需要的话直接拿走： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291ba499e487084dcbc8d3c56e7a8f16/" rel="bookmark">
			laravel相关开发框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMS（内容管理系统）：
Bootstrap CMS —— Laravel 5.1驱动的功能强大的CMS（已停止更新）
October —— 基于Laravel 5，致力于让开发工作变得简单的CMS（最高支持版本：5.5）
PyroCMS —— MVC架构的PHP内容管理系统，3.0以前基于CodeIgniter，目前基于Laravel（最高支持版本：5.8）
LavaLite —— 基于Laravel &amp; Bootstrap 3的内容管理系统（最高支持版本：5.8）
TypiCMS —— 基于 Laravel 构建的、支持多语言的内容管理系统（最高支持版本：6.0）
Laravel and AngularJS CMS —— 基于Laravel 5.1和AngularJS的CMS（长期未更新）
Microweber —— 基于 Laravel 拖拽式生成 CMS 及在线商店利器（最高支持版本：5.4）
AsgardCMS —— 基于 Laravel 构建的、支持模块化和多语言的CMS（最高支持版本：5.5）
CoasterCMS —— 基于Laravel 构建的下一代CMS（最高支持版本：5.4，长期未更新）
BorgertCMS —— 基于 Laravel 开发的开源模块化 CMS（最高支持版本：5.6）
WebEdCMS —— 基于 Laravel 开发的开源CMS系统（最高支持版本：5.5，已停止更新）
CRM（客户关系管理系统）：
Flarepoint —— 基于 Laravel 构建的免费开源CRM平台（最高支持版本：5.4）
Monica —— 基于 Laravel 构建的开源个人关系管理应用（最高支持版本：5.8，个人 CRM）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291ba499e487084dcbc8d3c56e7a8f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b893c4be5ad90912ada7bc2f05ce71b/" rel="bookmark">
			快手电商新增商品信息诊断规则，对商家有何影响？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、2022年快手短剧日活跃用户达2.6亿 新榜讯&amp;nbsp;近日，快手数据显示，2022年快手短剧日活跃用户达2.6亿，现在的付费用户数对比2022年4月增长超过480%，快手已经是最大的短剧消费市场。此外，2023年快手小游戏日活跃用户峰值超过1000万，快手原生小游戏的完播率比行业平均高2倍以上。此外，2022年快手房产业务的总交易额超过100亿。在招聘领域，2023年初，每天有超过50万份应聘简历通过快手投递给用人单位。
2、快手磁力大会提出“全店ROI”经营理念新榜讯&amp;nbsp;2月22日，快手“2023•增量效应”磁力大会在北京召开，聚焦释放商业新增量、全面提效两大方向，并率先在短视频/直播行业提出“全店ROI”这一新型经营理念，鼓励商业客户在快手生态里深度经营。快手透露，区别于传统电商的做法，快手全店ROI以客户的整体生意增长为目标，依托于客户在快手沉淀的内容、粉丝和人群资产，通过算法和模型对快手全域流量进行组合投放，进而保障客户在快手整体经营ROI目标的达成，实现从品宣到效果再到销售的全链路转化。其核心价值是给到所有在快手经营的商家一个确定性的抓手。 3、快手委任赵华夏为联席公司秘书 新榜讯&amp;nbsp;2月20日，快手发布公告称，贾弘毅因工作安排调整辞任公司联席公司秘书，自2023年2月20日生效。该公司董事会进一步宣布已委任赵华夏接替贾弘毅出任公司联席公司秘书，自2023年2月20日生效。苏嘉敏将继续担任公司另一联席公司秘书。 4.&amp;nbsp;快手电商新增商品信息诊断规则 据电商报&amp;nbsp;近日，快手电商公布《商品信息诊断规则》新增公告。公告称，商家商品发布工具“商品信息质量分”拟升级为“商品信息诊断”，商品发品页面由“商品信息质量分”自动更换为“商品信息诊断”，该功能预计2月23日起全面上线。据悉，此次调整核心两点：一是升级商品信息评估方式，商品信息分工具由规则计分制改为规则诊断分档，诊断结果作用于商品搜索和推荐等；二是完善商品信息诊断维度。 5.&amp;nbsp;新东方在线：拟实行股份奖励计划，授权限额约1.01亿股 新榜讯&amp;nbsp;2月21日，新东方在线发布公告称，新东方在线董事会已议决建议采纳一项首次公开发售后股份奖励计划。该计划拟授权限额约1.01亿股，占公司已发行股份的10%，旨在提供吸引人才，向其提供薪酬、激励等。此次股权激励的对象，包括公司员工、董事及高级管理人员，以及关联实体参与者、服务提供者。
6、快手电商公布“新商家斗金计划”，最高奖励50万 &amp;nbsp;新榜讯&amp;nbsp;近日，快手电商推出“新商家斗金计划”，面向全新主体新商家，将从2月13日持续至3月31日，在2月1日前无动销且店铺类型为B店的快手商家，可通过线上报名的方式参与，满足要求的商家最高可获得50万奖励。&amp;nbsp;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e5f3c10db39476494d8f284a6db4b7/" rel="bookmark">
			Unity Matrix.TRS 大概源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private Matrix4x4 TRS(Vector3 position, Quaternion rotation, Vector3 scale) { float num = rotation.x * 2f; float num2 = rotation.y * 2f; float num3 = rotation.z * 2f; float num4 = rotation.x * num; float num5 = rotation.y * num2; float num6 = rotation.z * num3; float num7 = rotation.x * num2; float num8 = rotation.x * num3; float num9 = rotation.y * num3; float num10 = rotation.w * num; float num11 = rotation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e5f3c10db39476494d8f284a6db4b7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/98/">«</a>
	<span class="pagination__item pagination__item--current">99/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/100/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>