<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ff1df3f11f18696e07422a62f00e850/" rel="bookmark">
			数据类型及深拷贝、浅拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据与变量 数据类型 类型分类 简单数据类型（基本类型）
1）布尔值Boolean: true / false
2）数值型Number: 所有数字
3）字符串String: 带引号
4）Undefined
5）Null
复杂数据类型（引用类型）
对象 Object
数组 Array
函数 Function
数据类型检测 typeOf 返回相关数据类型的字符串
可以检测 Boolean Number String Undefined Function
不能检测 Null ,返回Object
instanceOf 返回布尔值
用来检测Object的具体类型
全等号=== 要检测的数据必须具有唯一性
可以检测 undefined 和 null
Object.prototype.toString.call(数据） 可以检测所有的数据类型
深拷贝与浅拷贝 深拷贝
简单数据类型存在栈中，将一个存着简单数据类型的变量赋值给另一个变量时，会复制一份值，且在内存中重新开辟一个空间，将值保存；两者相互独立，修改一个，另外一个不会跟着变；
浅拷贝
复杂数据类型的变量名存在栈中，值存在堆中，栈中的变量名通过引用地址指堆中的值；将一个存着复杂数据类型的变量赋值给另一个变量时，会赋值一份引用地址，新的变量就会指向变量，修改一个变量，就修改了堆中的值，由于都是同一个地址，指向同一个值，所以另一个也会随之变化；
复杂数据的深拷贝与浅拷贝对比 （1）浅拷贝：浅拷贝一个变化另外一个也会随着变化， 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用，
（2）深拷贝：相互独立，深拷贝一个变化另外一个不会变； 创建一个新的对象或数组，将原对象的各项属性和属性值（数组的所有元素）拷贝过来，是“值”而不是“引用”
深拷贝的实现 1 JSON序列化与反序列化
JSON.parse(JSON.string(变量))，
这也是我用得最多的
JSON.stringfy 将数据转化为简单数据类型—JSON字符串，然后通过 JSON.parse() 将它转化为普通的对象或数组
2 jQuery的extend
$.extend( [deep ], target, object )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ff1df3f11f18696e07422a62f00e850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5667791b477ff521d035ea4c35e95e00/" rel="bookmark">
			C&#43;&#43;对象指针-指向对象的指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 对象指针 学习C语言的时候，我们已经学习了指针的相关知识。例如：
int a;
int* pa = &amp;a;
此时，我们定义一个int类型的变量a，同时，定义一个int类型的指针变量pa，并把变量a的地址赋给指针变量pa，那么，指针变量pa就指向了变量a。
同样的道理，C++定义的类，就是一个有效的数据类型，如同int, float, double这样的数据类型。所以，可以定义C++类对象的指针变量，与C语言中定义int, float, struct结构体等类型的指针变量一样。
1.1 指向对象的指针 在建立对象的时候，编译系统会为每一个对象分配一个存储空间，用来存放对象的成员。可以定义一个指针变量，用来存放对象的地址。如下是一个测试例子：
程序运行结果如下：
在这个例子中，定义了一个student类对象，如下：
student stud("wkf","www.mylinux.vip",13926572996); //定义对象
然后，定义一个student类型的指针对象，如下：
student* ps;
此时，ps是一个指针对象，它可以指向一个student类型的对象。所以，可以把stud对象的地址赋给指针对象ps，如下：
ps = &amp;stud;
最终，指针对象ps指向stud对象。然后，通过指针对象ps调用print()函数，就是调用
stud对象的print()函数。所以，输出的是stud对象的信息。
定义指向类对象的指针变量的一般形式为：
类名 *对象指针名；
可以通过对象指针访问对象和成员的函数，如：
*ps //使用*号运算符对指针对象ps降级，获取指针对象ps指向的对象。即stud对象；
(*ps).name //获取ps指向stud对象的name成员，即stud.name成员；
ps-&gt;name //通过指针ps访问所指向的stud对象的name成员，即stud.name成员；
(*ps).print(); //使用*号运算符对指针对象ps降级，获取指针对象ps指向的对象。即stud对象，相应调用stud.print()函数，就是通过stud对象调用。
ps-&gt;print(); //通过指针ps访问所指向的stud对象的print()函数，相当于stud.print()调用；
所以，通过类指针对象访问成员变量和成员函数，访问的方式与C语言的struct结构体一样。
韦凯峰 Linux C/C++ 程序设计教程，Linux 系统编程，Openwrt 系统开发，微信:13926572996,QQ:1523520001,博客:www.mylinux.vip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c6490d4ae5bba4fa126b3e2881246f/" rel="bookmark">
			Khadas VIM3开发板固件烧写记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为工作原因接触到khadas的VIM3开发板，在这里记录一下烧写系统的过程。其官方文档中有详细的烧写过程，主要以官方文档为主。
前期准备 需要的物料 一台显示器一套无线鼠标一根USB-c的数据线【手机的数据线】5V电源【手机的充电器】 固件下载 本人选择的是Ubuntu桌面系统，系统安装在开发板上的emmc里。
官方固件下载地址【https://docs.khadas.com/zh-cn/firmware/】
点击链接，左侧选择VIM3-&gt;Ubuntu，接着如图所示：
文件大约790M左右，下载会有点久。
烧写软件下载 烧写工具下载链接：【https://dl.khadas.com/Tools/USB_Burning_Tool_v2.2.0.zip】
下载好烧写工具后安装打开，将数据线一端接上电脑，另一端接上板子的USB-C口中先按住电源键，再短按一下复位键，约4~5秒后开发板就进入烧写模式，此时松开。烧写工具显示已连接开发板。点击烧录工具的文件，选择导入烧录包，选择刚刚下载的固件文件（固件需要解压），然后烧录配置默认，点击开始等待烧录完成。烧录完成后，点击停止，关闭软件接上显示器与鼠标，开始你的表演~
下图为烧写软件的界面
配置 说是配置其实是为了连接网络和做串口连接设置，有屏幕和键盘好连接网络用ssh登录上去。
但是本人没有想到不用屏幕和键鼠连接到网络的，要是有看官知道的话烦请在评论区告诉本人一下！谢谢！
【串口调试配置】
串口模块与开发板的连接如下图【官方提供的图】
接下来是在板子上的操作
安装minicom
sudo apt-get install minicom
添加权限
sudo usermod -a -G dialout $(whoami)
打开minicom
这里有个坑，官方文档上是这么写的
minicom -D /dev/ttyUSB0 -b 115200
这里的坑计时要先查看自己的串口先才能
ls /dev/ttyS*
然后修改一下打开minicom的命令
本人的是这样的，
minicom -D /dev/ttyS3 -b 115200
然后接好USB转串口模块的线，插入电脑，打开putty.exe.
选择session,Sertal,找到自己的串口号，波特率115200，连接，成功~
如有错误或者不对的地方，请看官指正，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccc54f8a081339c541e8625c27f9451/" rel="bookmark">
			9. Python三大程序基本结构介绍——循环结构（for和while循环）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、for循环语句（遍历循环）
1. 语法介绍 2. 实际运用
代码实例1：通过遍历循环计算1到100的累加和
代码实例2：计算循环次数
代码实例3：遍历打印元素
二、while循环语句（无限循环）
1. 语法介绍 2. 实际运用
代码实例 1：计算循环次数
代码实例2：计算1到100的累加和
三、其它语句
1. break语句
2. continue语句
3. pass语句
在程序设计过程中，经常需要将一些代码按照要求重复执行多次，这时就需要用到循环结构。循环语句是在满足一定条件下，重复执行一段代码，由循环体（不停重复的内容）和循环条件（什么情况下执行循环）两部分组成。
Python有两种类型的循环结构，分别是for循环和while循环。循环语句中，使用continue语句跳过本次循环后面的语句，进行下一次循环；使用break语句彻底跳出循环。for循环是确定次数的循环，while循环是非确定次数的循环。
一、for循环语句（遍历循环） 1. 语法介绍 for循环语句的重要程度可以说仅次于If语句了，它的底层逻辑是循环，While的底层逻辑也是循环，不过还是for用的更加普遍些。for循环语句由for和in组成，从遍历结构中逐一获得元素进行循环。for循环遍历可用于任何遍历结构：计算循环、字符串遍历循环、列表遍历循环、文件遍历循环、元组遍历循环、集合遍历循环、字典遍历循环等。 具体语法格式如下：
# 语法结构 for i in 区域: # i只是一个代号，表示循环变量 代码 2. 实际运用 代码实例1：通过遍历循环计算1到100的累加和 # 通过遍历循环计算1到100的累加和 s = 0 for i in range(1, 101): s += i print(s) 代码实例2：计算循环次数 for i in range(1,6): print(i) 代码实例3：遍历打印元素 class1 = ['丁一', '王二麻子', '张三', '李四', '赵五'] for i in class1: print(i) 二、while循环语句（无限循环） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fccc54f8a081339c541e8625c27f9451/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66210ba8bf668375307515916acb5e48/" rel="bookmark">
			a-modal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a-modal的样式调整 a-modal宽和高的设置 主要是通过a-modal自带的width和bodyStyle来设置
注意：a-modal的父盒子是body
// 现在我要点击按钮，弹出对话框，对话框展示的是文本信息，我们也可以添加下载文本功能 &lt;template&gt; &lt;div id="hello"&gt; &lt;div style="margin-top:50px"&gt; &lt;button @click="openDialog"&gt;打开对话框&lt;/button&gt; &lt;/div&gt; // 从这里这里开始就是a-modal的使用了 &lt;a-modal v-model="visible" :width="1000" :bodyStyle="{ height: '600px', overflowY: 'auto', paddingBottom: '20px' }" centered :footer="null" &gt; &lt;h1&gt; 我是标题 &lt;/h1&gt; &lt;div class="dialogText"&gt;{{ dialogText }}&lt;/div&gt; &lt;a-button icon="arrow-down" type="primary" size="small"&gt; 下载 &lt;/a-button&gt; &lt;/a-modal&gt; // a-modal到这里结束 &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import '@/mock/index.js' export default { data() { return { dialogText: '', // 我这里使用了mock来模拟了对话框展示的文字 visible: false } }, methods: { // mock模拟获取对话框数据 async getDialogData() { const data = await this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66210ba8bf668375307515916acb5e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6b13ce165eb7b93d596a089092d2f4/" rel="bookmark">
			蜻蜓算法(DA)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蜻蜓群的目的：捕食（静态群）和迁移（动态群）
五种行为：
1.Separation：个体之间避免碰撞
S i = − ∑ j = 1 N X − X j S_i=-\sum_{j=1}^NX-X_j Si​=−∑j=1N​X−Xj​
X 表 示 当 前 个 体 ， X j 是 第 j 个 邻 近 个 体 的 位 置 。 N 为 邻 近 个 体 数 量 X表示当前个体，X_j是第j个邻近个体的位置。 N为邻近个体数量 X表示当前个体，Xj​是第j个邻近个体的位置。N为邻近个体数量
2.Alignment：与邻近个体速度保持一致
A i = ∑ j = 1 N V j N A_i=\frac{\sum_{j=1}^NV_j}{N} Ai​=N∑j=1N​Vj​​
V j 表 示 第 j 个 个 体 的 速 度 V_j表示第j个个体的速度 Vj​表示第j个个体的速度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d6b13ce165eb7b93d596a089092d2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6443c5fef5952827a82c27d80f94b87c/" rel="bookmark">
			浙大三维视觉团队提出 Neural Body，单目RGB视频重建人体三维模型，无需预训练网络...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝字
关注我们
AI TIME欢迎每一位AI爱好者的加入！
今天，我们介绍一篇2021 CVPR的人体自由视角合成的论文：Neural Body: Implicit Neural Representations with Structured Latent Codes for Novel View Synthesis of Dynamic Humans，该论文由浙江大学CAD&amp;CG国家重点实验室/浙大三维视觉实验室提出。
1.论文链接：arxiv.org/abs/2012.1583
2.论文代码：github.com/zju3dv/neura
3.Project page: zju3dv.github.io/neural
论文的两个demo
1. 从稀疏视角视频中生成的自由视角视频
2. 从单目视频重建出3D human shape
一、引言
1.1 论文的问题描述
论文希望生成动态人体的自由视角视频，这有很多应用，包括电影工业，体育直播和远程视频会议。大家在春晚或一些综艺类节目应该已经见过子弹时间的特效。
1.2 当前方法在这个问题的局限性
现在效果最好的视角合成方法主要是NeRF [3] 这个方向的论文，但他们有两个问题：
需要非常稠密视角来训练视角合成网络。比如NeRF论文中，一般用了100多个视角来训练网络。
NeRF的训练视角
对于静态物体，这是可以做到的，一般是对着静止的物体拍一圈图片。但如果对于动态场景来说，我们无法要求演员静止来让我们给他拍一圈图。为了拍摄稠密多视角视频，之前的方法需要昂贵的相机阵列来进行捕捉。这套设备特别昂贵，而且还很不方便，一般只在电影拍摄时用到。
http://henrybetts.co.uk/an-attempt-at-bullet-time/
NeRF只能处理静态场景。现在大部分视角合成工作是对于每个静态场景训一个网络，对于动态场景，上百帧需要训上百个网络，这成本很高。
1.3 我们的观察和对问题的解决
在稀疏视角下，单帧的信息不足以恢复正确的3D scene representation。论文的key idea是是通过整合时序信息来获得足够多的3D shape observation。大家平时应该能有这种感觉，观看一个动态的物体更能想象他的3维形状。我们论文用的就是这个intuition。
这里整合时序信息的实现用的是latent variable model。具体来说，我们定义了一组隐变量，从同一组隐变量中生成不同帧的场景，这样就把不同帧观察到的信息和一组隐变量关联在了一起。经过训练，我们就能把视频各个帧的信息整合到这组隐变量中，也就整合了时序信息。
二、 论文方法
2.1 Prerequisite: Neural radiance fields
论文使用neural radiance field (NeRF) [3] 来表示一个3维场景。对于一个场景的任意一点，NeRF取出3维坐标和视角方向，输入到一个MLP中，输出color和density。这个表示能通过volume rendering从图片中很好的优化场景的3D模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6443c5fef5952827a82c27d80f94b87c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24829ec810281e9db16b485654877c6d/" rel="bookmark">
			Latex/CSDN字母输入对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN支持语法就是Latex语法
目录： 1 希腊字母对应表 1 希腊字母对应表 希腊字母输出格式：
$/alpha/$ 即可输出： α \alpha α
字母表如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6585717f785a77af13dbe8042998fa96/" rel="bookmark">
			如何入坑Electron开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍
作为一个跨平台的桌面应用开发框架，Electron 的迷人之处在于，它是建立在 Chromium 和 Node.js 之上的 —— 二位分工明确，一个负责界面，一个负责背后的逻辑，典型的「你负责貌美如花，我负责赚钱养家」。
上面这张图很好的说明了 Electron 的强大之处。
也不难理解，为什么 Electron 能开发跨平台的桌面应用了。
但是，不同系统间还是会有很大的差异，需要相应地做一些额外处理，使得打包出的应用在不同系统下都能正常运转。但相比于 80% 都能完全复用的代码，这些成本几乎可以忽略不计。
所以，对 Web 前端开发者来说，用 Electron 开发多平台客户端的成本非常低。
而且，Electron 是基于 Node.js 的，这就意味着，Node 这个大生态下的模块，Electron 都可以用。
同时，跨平台也让 Electron 可同时开发 Web 应用和桌面应用，无论是 UI，还是代码，很多资源都可以共享，大幅减少了开发者的工作量。
作为目前非常热门的技术，很多应用都是用 Electron 开发的，比如字节跳动的飞书、Slack、VS Code、Atom、Skype、WhatsApp、支付宝小程序 IDE（蚂蚁开发者工具）等。
与此同时，包括蚂蚁金服、小米、华为、GitHub、微软在内的很多大厂都在使用 Electron。因此，学好 Electron 是你日后跳槽加薪的加分项，毕竟，大厂都在用。
‍
‍
如何深入理解，并高效使用 Electron？
用 Electron 写一个简单的桌面端应用并不难，有一定 JavaScript 基础的话，可能只要半小时。但要做一个项目，就没那么容易了：
第一，涉及技能栈众多。我们不仅要了解 Electron、客户端知识，还要在客户端中使用 Node.js，甚至是集成 C++、Rust 等三方库，涉及多进程等概念，对基础薄弱的前端工程师来说有些难度。
第二，基建缺乏，工程化建设难以落地。Electron 基建在大部分公司都比较缺乏，依赖 Web、手机客户端的基建无法满足 Electron 业务，比如在 Mac 端打包可以依赖 iOS 持续集成，但 Windows 端则不行，类似场景非常之多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6585717f785a77af13dbe8042998fa96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42471c38012ab77e1596cdb6f5271a18/" rel="bookmark">
			面试官：说说Node中的EventEmitter? 如何实现一个EventEmitter?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是什么 我们了解到，Node采用了事件驱动机制，而EventEmitter就是Node实现事件驱动的基础
在EventEmitter的基础上，Node几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作
Node.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件
这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上
二、使用方法 Node的events模块只提供了一个EventEmitter类，这个类实现了Node异步事件驱动架构的基本模式——观察者模式
在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们
基本代码如下所示：
const EventEmitter = require('events') class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter() function callback() { console.log('触发了event事件！') } myEmitter.on('event', callback) myEmitter.emit('event') myEmitter.removeListener('event', callback); 通过实例对象的on方法注册一个名为event的事件，通过emit方法触发该事件，而removeListener用于取消事件的监听
关于其常见的方法如下：
emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部
emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部
emitter.emit(eventName[, ...args])：触发类型为 eventName 的监听事件
emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件
emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除
emitter.removeAllListeners([eventName])：移除全部类型为 eventName 的监听事件
三、实现过程 通过上面的方法了解，EventEmitter是一个构造函数，内部存在一个包含所有事件的对象
class EventEmitter { constructor() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42471c38012ab77e1596cdb6f5271a18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a2e229c22c48e558215ae91791bc4a/" rel="bookmark">
			a-table及相关组件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a-table及相关组件的使用 基础的渲染 &lt;a-table :dataSource="tableList" :columns="tableColumns"&gt;&lt;/a-table&gt; 参数名类型说明dataSource数组数据来源，数组中的每一个对象都是一行的数据columns数组用来指定每一列的标题（表头）bordered布尔值是否显示表格边框，默认为竖向的边框pagination布尔值默认采用他的分页，如果觉得不好用可以自己写rowKey具有唯一性给每一行一个特殊标记，不给同时没给key(每一列的特殊标记)浏览器会报错rowClassName函数对行进行处理，function(record,index){} &lt;template&gt; &lt;div&gt; &lt;div class="box" style="width:600px;margin:50px"&gt; &lt;a-table :dataSource="tableList" :columns="tableColumns" bordered :pagination="false" :rowClassName="rowClassName" &gt; &lt;template slot="selfDefineTitle"&gt; &lt;span&gt;修后的标题(姓名列)&lt;/span&gt; &lt;/template&gt; &lt;template slot="dealAge" slot-scope="text, record, index"&gt; &lt;!-- 默认有三个参数，text为传给该列每个单元格中的数据，record为每一行的数据，index为改行索引 --&gt; &lt;span&gt;{{ index + '-' + '年龄为：' + text }}&lt;/span&gt; &lt;/template&gt; &lt;/a-table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableList: [ { id: 1, name: '张三', age: 20, hometown: '北京' }, { id: 2, name: '李四', age: 20, hometown: '上海' }, { id: 3, name: '王五', age: 23, hometown: '深圳' } ], tableColumns: [ { title: '序号', // 每一列对应的标题 dataIndex: 'id', // 每一列对应的数据源中的数据 width: 30, // 每一列的宽度 align: 'center' // 每一列的对齐方式,left/center/right }, { // title: '姓名', slots: { // 给每一列的表头（标题）进行处理 title: 'selfDefineTitle' }, dataIndex: 'name', width: 100 }, { title: '年龄', dataIndex: 'age', scopedSlots: { // 对表格中的该列数据进行处理 customRender: 'dealAge' }, width: 100 }, { title: '家庭住址', dataIndex: 'hometown', width: 100 } ], rowClassName: (record, index) =&gt; { let rowClassName = 'green' if (index % 2 === 0) { rowClassName = 'blue' } return rowClassName } } } } &lt;/script&gt; &lt;style&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a2e229c22c48e558215ae91791bc4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c7816c9bb647923a15080ecfaed8fa/" rel="bookmark">
			R语言数据基础离散化（分箱）之——手动定义间断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言本身提供手动定义间断点进行离散化的函数 cut
cut(x, breaks, labels = NULL,
include.lowest = FALSE, right = TRUE, dig.lab = 3, ordered_result = FALSE, ...) 示例代码如下：
library(infotheo) data.restable &lt;- read.csv('data/ChinaFeatures.csv') res &lt;- cut(data.restable$lat,c(18.7,23.75,28.75,33.75),c(1:3)) 其将data.restable表lat列离散化，数值范围为
(18.7-23.75] ——&gt; 1
(23.75-28.75] ——&gt; 2
(28.75-33.75] ——&gt; 3
注意其边界，含右不含左。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ddf1aa163e764b3cc4a8ac009bf126/" rel="bookmark">
			asp.net过滤html,Asp.Net中过滤所有的Html标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在制作一个显示文章列表的页面，从数据库中读出文章标题及部分内容显示到页面上，可以让读者在列表中就可以了解到该文章的大概。完成后却发现了一个问题，就是在翻页后有些页面显示的不完整了，或者页面布局全变乱了，但有几页却没有。查看有问题页面的源代码，发现原来是因为文章内容中包含了HTML代码，然后我在读取部分内容的时候就简单的在数据库中用了left函数，所以导致读出了未封闭的HTML标签了，显示到页面上后和页面自身的HTML标签一结合，布局就全乱了。
原因找出来了，就寻找解决问题的方法.
解决方法一:将读出来的内容经过HTML编码后再输出到页面上，该方法虽不会引起界面布局错乱的问题，但浏览者会看到一大串HTML标签，毕竟不是很友好。于是该方法淘汰。
解决方法二:过滤掉读出内容所有HTML标签，这样即不会让浏览者看到不应该看到的HTML标签，也不会引发页面布局错乱.
下面贴出过滤掉所有HTML标签的方法，供大家参考：
/// /// 过滤所有的Html标签
/// /// /// public static string RemoveHTML(string Htmlstring)
{
Htmlstring = Regex.Replace(Htmlstring, @"", "",RegexOptions.IgnoreCase);
Htmlstring = Regex.Replace(Htmlstring, @"]*) &gt;", "", RegexOptions.IgnoreCase);
Htmlstring = Regex.Replace(Htmlstring, @"([\r\n])[\s]+", "", RegexOptions.IgnoreCase);
Htmlstring = Regex.Replace(Htmlstring, @"-- &gt;", "", RegexOptions.IgnoreCase);
Htmlstring = Regex.Replace(Htmlstring, @"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e8faf95e9249c000ef6cbe048af89e/" rel="bookmark">
			getRequestDispatcher()用法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ServletContext.getRequestDispatcher(String url)中的url只能使用绝对路径；
而ServletRequest.getRequestDispatcher(String url)中的url可以使用相对路径。因为ServletRequest具有相对路径的概念；
而ServletContext对象无次概念。
RequestDispatcher对象从客户端获取请求request，并把它们传递给服务器上的servlet,html或jsp。它有两个方法:
1.void forward(ServletRequest request,ServletResponse response)
用来传递request的，可以一个Servlet接收request请求，另一个Servlet用这个request请 求来产生response。request传递的请求，response是客户端返回的信息。forward要在response到达客户端之前调用，也 就是 before response body output has been flushed。如果不是的话，它会报出异常。
2.void include(ServletRequest request,ServletResponse response)
用来记录保留request和response，以后不能再修改response里表示状态的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7867d4b8ead7fcf94064a3b724fd280/" rel="bookmark">
			Docker_tls加密通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TLS 一.TLS1.docker容器与虚拟机区别1）隔离与共享2）性能与损耗 2.docker存在的安全问题1）Docker自身漏洞2）docker源码问题 3.docker架构缺陷与安全机制1）容器之间的局域网攻击2）DDos攻击耗尽资源3）有漏洞的系统调用4）共享root用户权限 二.docker安全基线标准1.内核级别2.主机级别3.网络级别4.镜像级别5.容器级别6.其他设置 三.docker-TLS加密通信1.加密通信流程2.密钥3.签名4.hash值5.证书6.通讯加密1）生成ca密钥2)生成ca证书3）生成服务器私钥4）生成服务器证书5）生成客户端密钥6）生成客户端证书7）删除多余文件8） 配置docker，指定tls证书的路径、开放的端口、通信的进程等9）将 /tls/ca.pem /tls/cert.pem /tls/key.pem 三个文件复制到另一台主机 10）本地验证 一.TLS 1.docker容器与虚拟机区别 1）隔离与共享 docker 底层的技术–cgroup namespaces Hypervisordocker 底层 aufs(堆叠的文件系统) bootfs rootfs lxc base image GFS VM实现的是操作系统的之前/级别的隔离
共享的是一套物理资源(宿主机内核驱动提供的 kvm qemu）
docker容器通过隔离的方式，将文件系统、进程、设备、网络等资源进行隔离
让容器之间互不影响，容器与宿主机共享内核、文件系统、硬件等资源 2）性能与损耗 与虚拟机相比，容器资源损耗要少(90%),同样的宿主机下，能够建立容器的数量要比虚拟机多，但是虚拟机的安全性要比容器稍好
2.docker存在的安全问题 1）Docker自身漏洞 k8s------生产环境----1.15 1.20+run time --k8s之后会使用自身的一套运行时技术
攻击的方式：代码执行(cron）、权限提升、信息泄露、权限绕过
2）docker源码问题 docker提供了 docker hub 可让用户上传创建的镜像 1.黑客上传恶意镜像
2.镜像使用有漏洞的软件，docker hub 上能下载的镜像里面75%都装了漏洞软件
需要检查里面软件版本信息
3.中间人攻击篡改镜像 镜像在传输过程中可能被篡改
3.docker架构缺陷与安全机制 docker本身架构与机制可能产生问题 1）容器之间的局域网攻击 主机上容器之间可构成局域网，ARP欺骗，嗅探。广播风暴等攻击
2）DDos攻击耗尽资源 cgroups安全机制就是要防止此类攻击的，不要为单一的容器分配过多的资源即可避免此类问题
3）有漏洞的系统调用 docker与虚拟机的一个重要的区别就是要防止此类攻击，不要为单一的容器分配过多的资源即可避免此类的问题 VM:KVM集成在内核，逻辑分割物理资源/抽象化物理资源，拦截一些敏感指定
(I/O），转给Qemu进行处理
操作系统隔离，安全性更高
4）共享root用户权限 如果root用户权限运行容器，容器内的root用户也就有了宿主机的root权限 二.docker安全基线标准 下面从内核、主机、网络、镜像、容器等总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7867d4b8ead7fcf94064a3b724fd280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c53dbd4e9f09afe5b01f1a67f78fc2/" rel="bookmark">
			Android Studio顶部标题栏修改名称和删除教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习Android studio 初期遇到一个问题，顶部标题栏的名字是项目名字（app名字）并且不可编辑。非常的不方便，怎么修改或者删除呢。 顶部标题栏即图中框起来部分
先说怎么删除这个顶部标题栏吧 第一步：
打开 res -&gt; values -&gt; styles.xml ；如图所示的部分就是修改主题的地方。
有些可能没有styles.xm文件那就打开 res -&gt; values -&gt; themes-&gt;themes.xml
第二步：
将文件中parent 中的Theme.AppCompat.Light.DarkActionBar修改为 Theme.AppCompat.Light.NoActionBar。
&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; 完成后再重新启动项目顶部标题就没有了。
接下来再说怎么修改顶部标题栏的名字（即app名字） 第一步：
打开 res -&gt; values -&gt; strings.xml 文件
第二步：
在strings.xml文件中将图里框起来的地方修改即可
我这原来是“MyApplication” 我改成了“个人主页”，但是项目名称没有变
重新启动后模拟器中app的名字也相对应的改了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e361fc1446ebb116b5922528752103/" rel="bookmark">
			async正确用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介async 是用来修饰方法，如果单独出现，方法会警告,没有什么作用await在方法体内部，只能放在async修饰的方法内，必须放在task前面async/await方法里面如果没有返回值，默认返回一个Task，或者void(推荐用Task，而不是void，因为在调用方法后还可以进行await/wait)方法内带async+await时，返回值要多一层Task&lt;&gt;（固定写法） 简介 本篇介绍如何正确的使用async，及一些注意事项 async 是用来修饰方法，如果单独出现，方法会警告,没有什么作用 CS1998:此异步方法缺少" await"运算符，将以同步方式运行。请考虑使用"await"运算符等待非阻止的API调用，或者使用" await Task.Run(…)"在后台线程上执行占用大量CPU的工作
async一般搭配await使用，如果我们只写async 来修饰方法会提示以上信息，原因也很简单，你只是告诉程序这是个异步方法，无论是否有返回信息，程序是不确定能否在主线程运算完并且异步可以正常运算完的情况，所以只能用主线程同步执行，但主/子线程执行顺序是不确定的。但async修饰后的方法和普通方法还是有些区别，主要区别在IL层面
await在方法体内部，只能放在async修饰的方法内，必须放在task前面 async/await方法里面如果没有返回值，默认返回一个Task，或者void(推荐用Task，而不是void，因为在调用方法后还可以进行await/wait) private async static Task Test() { Console.WriteLine($"当前主线程id={Thread.CurrentThread.ManagedThreadId.ToString("00")}"); { Task&lt;long&gt; t = SumAsync(); Console.WriteLine($"Main Thread Task ManagedThreadId={Thread.CurrentThread.ManagedThreadId}"); long lResult = t.Result;//访问result,阻塞式 主线程等待所有的任务挖成 //如果访问Result，就相当于是同步方法！ t.Wait();//等价于上一行,阻塞式--同步 //await t;//非阻塞， } Console.WriteLine($"Main Thread Task ManagedThreadId={Thread.CurrentThread.ManagedThreadId}"); Console.Read(); } /// &lt;summary&gt; /// 带返回值的Task /// 要使用返回值就一定要等子线程计算完毕 /// &lt;/summary&gt; /// &lt;returns&gt;async 就只返回long&lt;/returns&gt; private static async Task&lt;long&gt; SumAsync() { Console.WriteLine($"SumAsync 111 start ManagedThreadId={Thread.CurrentThread.ManagedThreadId}"); long result = 0; await Task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e361fc1446ebb116b5922528752103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbaccafa5f940cf367da2376261bba3/" rel="bookmark">
			HTML简易自适应布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
第一步：在body下先建三个块级，代码如下：
&lt;div class="one"&gt;第1个元素中的内容&lt;/div&gt; &lt;div class="two"&gt;第2个元素中的内容&lt;/div&gt; &lt;div class="three"&gt;第3个元素中的内容&lt;/div&gt; 第二步：设置全局边框，代码如下：
* { margin: 0;/*被设置的对象相对四周的边距是0*/ padding: 0;/*内边距为0*/ } 第三步：设置块级的高度以及水平方向布局，代码如下：
div { /*&lt;div&gt; 定义文档中的分区或节*/ height: 100px; float: left;/*float(浮动):用于元素水平方向的布局*/ } 第四步：设置每个块级的宽度以及背景颜色，代码如下：
.one { width: 30%; background-color: #b6a2dc; } .two { width: 40%; background-color: #9ee2ac; } .three { width: 30%; background-color: #f69654; } 每个块级的宽度，所占比例、背景颜色可自己去调 。
全文代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;自适应布局&lt;/title&gt; &lt;style&gt; * { margin: 0;/*被设置的对象相对四周的边距是0*/ padding: 0;/*内边距为0*/ } div { /*&lt;div&gt; 定义文档中的分区或节*/ height: 100px; float: left;/*float(浮动):用于元素水平方向的布局*/ } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acbaccafa5f940cf367da2376261bba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3209b620da64b16642d30d0a0d9cbf3/" rel="bookmark">
			STM32F405串口通信数据出错的可能性之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F405开发板程序发送0x10 上位机接收0x20、0x30等错误数据 主程序和硬件都没有问题 经检查是从官网下载的固件库中stm32f4xx.h中144行的HSE_VALUE（外部时钟）默认为25000000，而开发板的外部晶振为8mhz， 将此值修改为8000000即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0f3e9828e768db2a714ee5d80c5230/" rel="bookmark">
			html5 基础代码,{HTML5}基础核心-第一节-上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​一．代码风格
jQuery语法：
基础语法：
$(selector ).action();
//$：美元符号用来定义jQuery
//选择符(selector) “查询”和“查找”HTML元素
//jQuery的action()执行对元素的操作
例如：
$(this).hide()
//隐藏当前元素
$(‘p’).hide() //隐藏p元素
在jQuery程序中，$就是jQuery的一个简写形式，例如：
$(function() {}); //执行一个匿名函数
$(‘#box’); //进行执行的ID元素选择
$(‘#box’).css(‘color’,‘red’); //执行功能函数,为#box添加行间样式
上面的三段代码也可以写成如下形式：
jQuery(function() {}); // jQuery与$是相等、恒等的
jQuery(‘#box’);
jQuery(‘#box’).css(‘color’,‘red’);
jQuery注释：单行使用“//...”，多行使用“/* ... */”。
//$('#box').css('color','red');
二．加载模式
之前的代码一直在使用$(function () {});这段代码进行首尾包裹，那么为什么必须要包裹这段代码呢？原因是我们jQuery库文件是在body元素之前加载的，必须等待所有的DOM元素加载后，延迟支持DOM操作，否则就无法获取到。
在延迟等待加载，JavaScript提供了一个事件为load，方法如下：
window.οnlοad= function () {}; //JavaScript等待加载
$(document).ready(function() {});
//jQuery等待加载
在实际应用中，很少直接去使用window.onload，因为他需要等待图片之类的大型元素加载完毕后才能执行JS代码。所以，最头疼的就是网速较慢的情况下，页面已经全面展开，图片还在缓慢加载，这时页面上任何的JS交互功能全部处在假死状态。并且只能执行单次在多次开发和团队开发中会带来困难。​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb79852ec59150d46687c72f5ee9373/" rel="bookmark">
			1、j-link报The connected j-link is defective. proper operation cannot be guarantee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、解决方案 1、j-link报The connected j-link is defective. proper operation cannot be guaranteed
在更新完j-link的驱动之后报错 The connected j-link is defective. proper operation cannot be guaranteed。
经过查找资料之后发现是j-link固件和j-link驱动程序不兼容引起的问题。可以升级j-link固件或者降低j-link驱动程序的版本来解决。我这边使用的是升级j-link固件解决问题。
升级前：
升级后
二、如果keil驱动无法更新 如果碰到安装其他版本j-link后，keil的j-link驱动还没有更新
安装如下版本驱动后，但是keil还是没有可选的驱动
则可以将j-link驱动下的JLinkARM.dll文件放到keil segger 目录下
复制 j-link安装目录下的 JLinkARM.dll
将JLinkARM.dll 放到 keil安装目录下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae1357abf67169e2ee76d9ca6247bb6/" rel="bookmark">
			毕竟眉湖六月中：朴素贝叶斯算法及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毕竟眉湖六月中，风光不与四时同。 图书馆路上随手拍的
正文：
我们都对贝叶斯理论了解一二，但啥是朴素贝叶斯？何谓朴素？见下图：
以下是朴素贝叶斯算法的流程：
但在实际的运用中，我们使用的数据集有可能是偏倚的或者数据集包含的实例较少。简单的来说，当我们通过掷筛子来统计每个点数的频率来判断这个骰子是否被动过手脚。当我们测试了六次，发现三点出现频率为0，那么就说这个骰子被动了手脚，显然这是不准确的，这就需要我们在掷筛子前，令所有点数出现的频率不为0，来避免此种状况的出现。
在朴素贝叶斯算法时，我们便做如下处理：
我们本次仍然使用Mnist数据集来进行算法的训练和测试。以下为代码：
import time import numpy as np def calculate_py(train_set): py=[0,0,0,0,0,0,0,0,0,0] for i in range(train_set.shape[0]): py[train_set[i][0]]+=1 return py def calculate_pxy(train_set,py): pxy_array=np.ones((10, 784, 256)) for i in range(train_set.shape[0]): for j in range(train_set.shape[1]-1): pxy_array[train_set[i][0]][j][train_set[i][j+1]]+=1 for i in range(10): pxy_array[i]=pxy_array[i][0:][0:]/(py[i]+256) return pxy_array def predict(pxy_array,test_set): calculate_result=np.ones((test_set.shape[0],10)) for i in range(test_set.shape[0]): for k in range(10): calculate_result[i][k]*=py_i[k] for j in range(test_set.shape[1]-1): calculate_result[i][k]*=pxy_array[k][j][test_set[i][j+1]] predict_result=np.argmax(calculate_result,axis=1) return predict_result def calculate_accuracy_rate(test_set,predict_result): cnt=0 for i in range(test_set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae1357abf67169e2ee76d9ca6247bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543c29e02b00c9ef1f25aa036479add4/" rel="bookmark">
			table中td,th不能设置margin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先，我们需要知道的是：我们可以对表格table设置margin，而不能设置padding;对单元格td设置padding，而不能设置margin。所以说，我们不能对单元格td设置margin属性来调整单元格与单元格之间的距离，但是我们可以使用一下方法来达到同样的效果。
设置padding
就像刚才所说的那样，我们可以对单元格td设置padding属性来调整单元格之间的间隔 td{padding:5px 10px;} 使用标签
我们可以在单元格td内添加标签，然后对标签设置margin属性 p{margin:5px 10px;} 对表格table设置border-spacing(IE不支持)
先让我们简单了解一下border-spacing属性。border-spacing:length;设置单元格td的边在横向和纵向上的间距。当您指定一个length值时，这个值将作用于横向和纵向上的间距;当您指定两个length值时，第一个将作用于横向间距，第二个值将作用于纵向间距。 table{border-spacing:5px 10px;} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4362de5adf46f10b4521b27d4ca107b1/" rel="bookmark">
			报错 An error happened during template parsing (template: “ServletContext resource [/shiroTest.html]“)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用thymeleaf视图解析器 这是因为模板解析器出现了错误
刚上手thymeleaf不会用
解决办法：
在方法上面加上@ResponseBody
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27bb89e737cc2c5fd39acc5addd02c7/" rel="bookmark">
			目标检测算法——Fast R-CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Fast R-CNN简介2.Fast R-CNN处理过程1）候选区域的生成2）投影特征图获得相应的特征矩阵3）ROI层缩放4）展平特征图利用全连接层得到预测结果。 3.Fast R-CNN损失函数4.Fast R-CNN总框架 1.Fast R-CNN简介 Fast R-CNN
其论文的名字就是 Fast R-CNN，原文链接。Fast R-CNN与R-CNN相同，同样使用VGG16作为网络的backbone，与R-CNN相比训练时间快9倍，测试推理时间快213倍，准确率从62%提升至66%(再Pascal VOC数据集上)。
Fast R-CNN 算法流程可分为3个步骤
一张图像生成1K~2K个 候选区域(使用Selective Search方法将图像输入网络得到相应的特征图，将SS算法生成的候选框投影到特征图上获得相应的特征矩阵将每个特征矩阵通过ROI(Region of Interest) pooling层缩放到 7x7 大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果 2.Fast R-CNN处理过程 1）候选区域的生成 与R-CNN一样，利用Selective Search算法通过图像分割的方法得到一些原始区域，然后使用一些合并策略将这些区域合并，得到一个层次化的区域结构，而这些结构就包含着可能需要的物体。
但是，Fast R-CNN与R-CNN不同的是，这些生成出来的候选区域不需要每一个都丢到卷积神经网络里面提取特征，而且只需要在特征图上映射便可，见下一个步骤。
2）投影特征图获得相应的特征矩阵 Fast-RCNN没有像RCNN一样，其不限制输入的图像的尺寸，其将整张图像送入网络，得到了一个特征图。紧接着从特征图像上提取相应的候选区域。这些候选区域的特征不需要再重复计算，简洁了不少的时间。
但是这其中涉及训练数据正负样本采样的问题。不过Fast R-CNN与Faster R-CNN处理得不同，也可以不用太过的在意。
在Fast R-CNN中，并不适用SS算法提供的所有的候选区域，SS算法会差不多得到2000个候选框，但是训练的过程中其实只需要使用其中的一部分就可以了，Fast R-CNN中好像只挑选了其中的64个。其中还是分为正样本与负样本，正样本指的是在候选框中确实存在所需检测目标的样本；而负样本指的是候选框中没有所需检测的目标，也就是只有背景。
视频up主所理解的一个意思是，当数据不平衡时，数据会有所偏向。如果全部只有正样本，那么网络就会有很大的一个概率认为候选区域是我们需要的一个检测目标，这样就会有问题，所以存在正负样品。
正样本的定义为候选框与真实的目标边界框的iou大于0.5；负样本的定义为候选框与所有真实的目标边界框的iou值最大的区间为0.1-0.5。重点是其实没有完全适应SS算法提供的所以的边界框。
3）ROI层缩放 有了训练样本之后，将训练样本的候选框通过ROI Pooling层缩放到统一的尺寸。
ROI Pooling层的具体做法是，将候选框所框选的训练样本，这是一个比较抽象的特征信息。将其划分为77，也就是49等份。划分之后，对每一个区域做一个最大池化下采样操作，也就是MaxPooling操作。如此对49等分的候选区域操作，便得到了一个77的特征矩阵。
也就是说，无论候选区域的特征矩阵是怎么样的尺寸，都被缩放到一个77的大小，这样就可以不去限制输入图像的尺寸了。因为，作进一步的工作的是输入图像的候选区域，而候选区域总是能被缩放为77的尺寸的，所以也就和输入图像的尺寸无关。
在R-CNN当中，其使用的卷积神经网络要求输入是227*227大小，但是Fast R-CNN就不需要考虑这个因素。
4）展平特征图利用全连接层得到预测结果。 概率分类器
输出N+1个类别的概率（N为检测目标的种类, 1为背景）共N+1个节点。
其中的第0个节点表示的背景的概率。剩下的20个是其他所需检测的类别概率。这个概率是经过softmax处理之后的，是满足一个概率分布的，其和为1.而既然现在是需要预测21个类别的概率，所以目标概率预测的全连接层为21个节点。
边界框回归器
输出对应N+1个类别的候选边界框回归参数(d x , d y , d w , d h )。需要注意，这是每一个类别都有这4个参数。所以共(N+1)x4个节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a27bb89e737cc2c5fd39acc5addd02c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550c99f4061193c04103aae52a4daa12/" rel="bookmark">
			vue3没有this怎么办?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue3中,新的组合式API中没有this,那我们如果需要用到this怎么办?
解决方法: getCurrentInstance 方法获取当前组件的实例，然后通过 ctx 或 proxy 属性获得当前上下文，这样我们就能在setup中使用router和vuex了
import { getCurrentInstance } from "vue"; export default { setup() { let { proxy } = getCurrentInstance(); proxy.$axios(...) proxy.$router(...) } } 但是 但是,不建议使用,如果要使用router和vuex,推荐这样用:
import { computed } from 'vue' import { useStore } from 'vuex' import { useRoute, useRouter } from 'vue-router' export default { setup () { const store = useStore() const route = useRoute() const router = useRouter() return { // 在 computed 函数中访问 state count: computed(() =&gt; store.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550c99f4061193c04103aae52a4daa12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991f18922b1d47b2f8829df18eadeb32/" rel="bookmark">
			html中单选按钮设置监听事件,浅谈监听单选框radio改变事件(和layui中单选按钮改变事件)，单选框radio...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈监听单选框radio改变事件(和layui中单选按钮改变事件)，单选框radio
若是只引用jquery的话，监听单选按钮改变事件如下：
男
女
$(document).ready(function() {
$('input[type=radio][name=sex]').change(function() {
if (this.value == '1') {
alert("这是个男孩");
} else if (this.value == '2') {
alert("这是个女孩");
}
});
});
注意：如果是引用了layui的样式和方法，则上面的监听事件失效，被layui接管了，所以应该如下写法：
layui.use(['form', 'element', 'laydate'], function(){
var jQuery = layui.jquery
,layer = layui.layer
,form = layui.form()
,element = layui.element();
form.on("radio(sex)", function (data) {
var sex = data.value;
if (this.value == '1') {
alert("这是个男孩");
} else if (this.value == '2') {
alert("这是个女孩");
}
});
});
以上这篇浅谈监听单选框radio改变事件(和layui中单选按钮改变事件)就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持3672js教程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991f18922b1d47b2f8829df18eadeb32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2acea83d454ef396f6b5bc5384c72f/" rel="bookmark">
			js中存取cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以单独写一个js脚本，定义一个对象。
分为两种情况，一种是写，一种是读。代码实现如下：
var Cookie = { set: function (key, value, exdays) { let exdate = new Date() // 获取时间 exdate.setTime(exdate.getTime() + 24 * 60 * 60 * 1000 * exdays) // 保存的天数 // 字符串拼接cookie // eslint-disable-next-line camelcase window.document.cookie = key + '=' + value + ';path=/;expires=' + exdate.toGMTString() }, get: function (key) { if (document.cookie.length &gt; 0) { var arr = document.cookie.split('; ') // 这里显示的格式需要切割一下自己可输出看下 for (let i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2acea83d454ef396f6b5bc5384c72f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80dfcb15ba35e579d19defa9afae2b17/" rel="bookmark">
			网格缺陷检测(二值化阈值分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本篇来用OpenCV实现Halcon中一个简单的网格缺陷检测实例。 Halcon中对应的例子为novelty_detection_dyn_threshold.hdev。并对二值化中的三种阈值处理进行介绍和比较：
全局阈值二值化(含OTSU方法) 自适应阈值二值化
双阈值二值化 阈值处理分析 1️⃣全局阈值二值化-threshold() OpenCV的threshold函数一般是给定一个阈值，对超过或者低于这个阈值的像素进行处理，函数如下：
threshold( InputArray src, // 输入图像 OutputArray dst, // 输出图像 double thresh, // 阈值 double maxValue, // 最大值(对于三通道图像一般是255) int thresholdType // 阈值化操作的类型 ) 阈值化操作的类型常用两种： THRESH_BINARY //黑背景找白目标(即超过设定阈值的值置255，其他为0) THRESH_BINARY_INV //白背景找黑目标(即超过设定阈值的值置0，其他为255) 全局阈值类似一刀切的概念。对于整体图像来说，找到一个合适的阈值，将图像分为0(黑色)和255(白色)。
2️⃣自适应阈值二值化-adaptiveThreshold() 对于亮度分布差异较大的图像，因为常常无法找到一个合适的阈值。因此我们需要一种改进的阈值化算法，即自适应阈值化。
adaptiveThreshold( InputArray src, // 输入图像 OutputArray dst, // 输出图像 double maxValue, // 最大值 int adaptiveMethod, // 自适应方法，平均或高斯 int thresholdType // 阈值化类型 int blockSize, // 块大小(大小必须为奇数) double C // 常量(即偏移值调整量) ) //adaptiveThreshold()支持两种自适应方法: ADAPTIVE_THRESH_MEAN_C //平均:阈值是邻域的平均值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80dfcb15ba35e579d19defa9afae2b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a1273b9aa6c18de77cab67fa7fecbc/" rel="bookmark">
			nutz跳转html,视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是视图？
视图的任务就是将入口函数的返回值(一个Java对象)渲染到 HTTP 响应流中。
现在 Nutz.Mvc 自带的主要视图有JSP － 采用 JSP 模板输出网页
Redirect － 客户端重定向
Forward － 服务器端中转
Json － 将对象输出成 Json 字符串
void - 什么都不做
Raw - 二进制输出,图片输出,文件下载等
当然你还可以根据需要开发你自己的视图实现类，定制自己的视图也非常简单，请参看
本文 #定制自己的视图 一节
快速入门:
// 重定向
@Ok("&gt;&gt;:/user/login.html") // 浏览器重定向到 /user/login.html
@Ok("-&gt;:/user/home.html") // forward,内部重定向到 /user/home.html
// 跳转到jsp页面
@Ok("jsp:jsp.user.home") // 内部跳转到 /WEB-INF/jsp/user/home.jsp
@Ok("jsp:/user/login.jsp") // 内部跳转到 /user/login.jsp
// 把入口方法返回值转为json字符串写入响应
@Ok("json")
@Ok("json:full")
@Ok("json:{locked:'password|salt'}")
// 直接设置为一个http status
@Ok("http:200")
@Fail("http:500")
// 任性返回任意文本
@Ok("raw")
// 返回图片对象,自动转为指定格式
@Ok("raw:png") // 返回值需要时BufferedImage
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09a1273b9aa6c18de77cab67fa7fecbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff777489b03f5c2db6281d5f4516114f/" rel="bookmark">
			oracle数据库：集合操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合操作就是通过一些关键字，将多个结果集进行拼接操作。比如在A表查了一个结果集A1,在B表查了一个结果集B1，那么可以对A1和B1进行并集和交集等操作。
Union , 并集（去重），对两个结果集进行并集操作，不包括重复行，同时进行默认的排序规则（asc）Union All , 全集（不去重），对两个结果集进行并集操作，包括重复行，不进行排序Intersect ,交集（找出重复），对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序。Minus，差集（减去重复），对两个结果集进行差集操作，不包括重复行，同时进行默认规则排序。 进行集合操作有个条件，就是两个结果集 字段个数和字段类型一一对应
这里以虚表dual为例子：
select 'a','b' from dual; select 'c','d' from dual; 这两条语句分别在虚表中查询出一个一行两列的结果集，并且结果集的类型都是carchar，可以来进行集合操作。
并集操作：
select 'a','b' from dual union select 'c','d' from dual; 结果如下：
在虚表中出现了两行两列，并且分别是两个结果集的内容。也可以使用多个union实现多个集合的并集：
select 'a','b' from dual union select 'c','d' from dual union select 'a','c' from dual union select 'c','d' from dual; 注意，这里面一共4个结果集，其中有两个结果集是一模一样的，为了看看union的去重效果
如上图所示，并集结果中并没有重复的行。
例2：union all：
select 'a','b' from dual union select 'c','d' from dual union select 'a','c' from dual union all select 'c','d' from dual; 注意上面的代码，在重复结果的前面使用的是union all
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff777489b03f5c2db6281d5f4516114f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f04b4d5990ca737c90cde5de5ea15b/" rel="bookmark">
			html表格添加序号,通过layui给数据表格添加序号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体方法如下：
(学习视频分享：编程视频)
1、第一种需求，只给当前页加序号
(1)给你的数据加上 templet属性
,cols: [[ {field:'tourPlayerId', width:80, title: 'ID1', sort: true,fixed: 'left',} ,{field:'zizeng', width:80, title: '排名',fixed: 'left',templet:'#zizeng'}
(2)在table的下面加上
{{d.LAY_TABLE_INDEX+1}}
这样的话 下一页里面的排序不会连着上一页的，只会重新从1开始排序
2、第二种方法，包括分页的数据也加上序号
加上type属性，
设定列类型。可选值有：normal(常规列，无需设定)、 checkbox (复选框列)、 space (空列)、 numbers (序号列)。 注意：该参数为 layui 2.2.0 新增 。而如果是之前的版本，复选框列采用 checkbox: true、空列采用 space: true
所以你这里只需要用到type:'numbers'就可以了，
效果如下：
相关推荐：layui教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21cc952c43cacf8bb9b8ec4f4e4c78f2/" rel="bookmark">
			html 获取微信支付接口,h5外部浏览器跳转微信支付链接api接口免费代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何让h5网页外浏览器跳转微信支付链接呢，这里分析了部分微信接口，可以用原生的公众号支付接口来搭建平台，代码如下
跳转中 //演示地址：http://vip.kakuapi.com/wxpay.php
正在前往微信支付 点击跳转支付1元
手机浏览器打开测试，外部跳转微信内支付接口api代搭建，代收款，演示页面 // if(/baiduboxapp/i.test(navigator.userAgent)) {
// window.location.replace("https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2610485677896432d48b563a1503978300&amp;package=3772979676&amp;redirect_url=http%3A%2F%2Fh5.tzwapi.com%2F");
// } else {
// window.location.replace("https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2610485677896432d48b563a1503978300&amp;package=3772979676&amp;redirect_url=http%3A%2F%2Fh5.tzwapi.com%2F");
// }
标签：bin,微信,跳转,接口,h5,支付,com
来源： https://www.cnblogs.com/ticket/p/11248895.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bada70ea58138c72ca265662877e78a/" rel="bookmark">
			用CSS 实现百叶窗效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; * { margin: 0; padding: 0; } body{ background-color: #cccccc; background: url(img/triangles.png) repeat; } .container{ width: 805px; height: 320px; overflow: hidden; margin: 100px auto; -webkit-box-shadow: 0 0 5px #000; } .container li{ width:160px; display: block; position: relative; float: left;	border-left: 1px solid #888;	-webkit-box-shadow: 0 0 25px #000; -webkit-transition: all 0.5s; } .container ul:hover li {width: 40px;} .container ul li:hover {width: 640px;} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bada70ea58138c72ca265662877e78a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f097442aab18ba2b3feae209148a1f55/" rel="bookmark">
			html 图片纵向列表,HTML &#43; JS 列表显示图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梦里花落0921
大概看了一下，可以这样:index.htmlnbsp;html&gt;
Page Title main.css html, body {
width: 100%;
height: 100%;
margin: 0;
padding: 0;
}
#main {
width: 800px;
height: 100%;
margin: auto;
}
.info_table {
width: 100%;
height: 60px;
display: -webkit-flex; /* Safari */
display: flex;
flex-direction: row;
flex-wrap: nowrap;
justify-content: center;
}
.info_person {
width: 20%;
height: 100%;
flex-grow:1;
}
.person_img {
width: 100%;
height: 90%;
}
.person_msg {
/* 自己调整 */
height: 20%;
width: 100%;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f097442aab18ba2b3feae209148a1f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c6804e2f2eb496871e9eeb5d20775fc/" rel="bookmark">
			CSS 高度塌陷解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浮动主要造成了父元素高度塌陷，以至于父元素很多像背景颜色，边框等都不能正确的显示出来以及同级子元素的位置 我们先来看一下正常高度塌陷效果
.wrapper-min{ width: 300px; border: 3px solid black; background-color: yellow; } .wrapperdzy{ width: 50px; height: 50px; } .wrapper-dyz1{ background-color: red; float: left; } .wrapper-dyz2{ background-color: blue; float: right; } &lt;div class="wrapper-min"&gt; &lt;div class="wrapperdzy wrapper-dyz1"&gt;&lt;/div&gt; &lt;div class="wrapperdzy wrapper-dyz2"&gt;&lt;/div&gt; 塌陷图片如下：
解决浮动的负面影响
①、给父元素定义高度
.wrapper-min{ height:50px } 效果图片
②、给父元素加上定义伪类：after
.wrapper-min:after{ content:""; display:block; clear:both; } 效果图
③、给父元素加上overflow：auto
.wrapper-min{ overflow: auto; } 效果图如下:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7062041ffd39c49c842d9329710b4d3/" rel="bookmark">
			Mybatis-plus将查询结果封装到指定实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景:
需要将岗位角色与广告配置建立多对多的关系,通过多选岗位角色作为条件来查询广告配置
在网上看了几篇类似的文章,感觉都不太靠谱,自己总结一下
关键记录下Mybatis-plus中foreach和collection的使用 还有判断集合使用 list.size &gt; 0
废话不多说,直接上代码
实体类
//广告类 @TableName(value = "TB_ADVERTISEMENT") public class Advertisement { @TableId(value = "ID") private Long id; private String name; private String place; private String url; private String orderNum; private List&lt;JobRole&gt; jobRoles; //get.. set.. toString.. } //岗位角色类 @TableName(value = "TB_JOB_ROLE") public class JobRole { @TableId(value = "ID") private Long id; private String name; //get.. set.. toString.. } //广告和岗位角色关联关系中间表 @TableName(value = "TB_AD_JOB_ROLE") public class AdJobRole { @TableId(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7062041ffd39c49c842d9329710b4d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9247e409990cbcce06139072af7fed74/" rel="bookmark">
			html隐藏input边框线,css如何去掉input的边框？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML(标准通用标记语言的一个应用)或XML(标准通用标记语言的一个子集)等文件样式的计算机语言。
css去掉input边框代码：input {
border: 0; // 去除未选中状态边框
outline: none; // 去除选中状态边框
background-color: rgba(0, 0, 0, 0);// 透明背景
}
border 简写属性在一个声明设置所有的边框属性。
可以按顺序设置如下属性：border-width：规定边框的宽度。
border-style：规定边框的样式。
border-color：规定边框的颜色。
outline (轮廓)是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
注释：轮廓线不会占据空间，也不一定是矩形。
outline 简写属性在一个声明中设置所有的轮廓属性。
可以按顺序设置如下属性：outline-color：规定边框的颜色。
outline-style：规定边框的样式。
outline-width：规定边框的宽度。
css去掉input边框示例：
Document input {
border: 0; // 去除未选中状态边框
outline: none; // 去除选中状态边框
background-color: rgba(0, 0, 0, 0);// 透明背景
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34fc390e4b687f6c5c3f867f0d5feb3/" rel="bookmark">
			WPF Prism框架之区域(Region)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Region定义 1、Xaml方式注册一个区域
&lt;ContentControl x:Name="cc" prism:RegionManager.RegionName="ContentRegion"/&gt; 2、后台代码注册一个区域
public MainWindow(IRegionManager regionManager) { InitializeComponent(); RegionManager.SetRegionName(this.cc, "ContentRegion"); /// 将相关View指定到特定的Region /// 第一个参数：Region的名称 /// 第二个参数：View的类型 regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA)); } RegionAdapter介绍 Prism框架中内置的RegionAdapter：
ContentControl——对应ContentControlRegionAdapterItemsControl——对应ItemsControlRegionAdapterListView、ListBox、ComboBox——对应SelectorRegionAdapterTabControl——TabControlRegionAdapter 其他的容器或者控件，需自定义RegionAdapter（继承RegionAdapterBase&lt; T &gt;）,并在App.cs类中注册。
1、自定义的StackPanelRegionAdapter如下：
public class StackPanelRegionAdapter : RegionAdapterBase&lt;StackPanel&gt; { public StackPanelRegionAdapter(IRegionBehaviorFactory regionBehaviorFactory) : base(regionBehaviorFactory) { } protected override void Adapt(IRegion region, StackPanel regionTarget) { region.Views.CollectionChanged += (se, ev) =&gt; { if (ev.Action == NotifyCollectionChangedAction.Add) { foreach (UIElement item in ev.NewItems) { regionTarget.Children.Add(item); } } }; } protected override IRegion CreateRegion() =&gt; new AllActiveRegion(); } 2、在App类中ConfigureRegionAdapterMappings方法中关联RegionAdapter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34fc390e4b687f6c5c3f867f0d5feb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40a763db99209e4c90792296ac37f98/" rel="bookmark">
			JAVA代码实现字符串匹配（一）——BF、KMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说，直接进入主题：
题目描述：给定两个字符串text和pattern，请你在text字符串中找出pattern字符串出现的第一个位置（下标从0开始），如果不存在，则返回-1;
LeetCode字符串匹配的题目：https://leetcode-cn.com/problems/implement-strstr/
举个例子：
字符串text（以下简称T，也叫主串）T = “ABABABABCABAAB”；
字符串pattern（以下简称P，也叫模式串）P = “ABABCABAA”；
字符串匹配的问题有很多种方法，最简单的就是暴力匹配（BF），也是最容易想到的。首先还是得先介绍以下BF法，只有清楚了BF的缺点才能更好的理解后续的优化算法。
1. 暴力匹配（BF）
。。。
首先，将T和P左对齐，定义指针i用于遍历T，指针j用于遍历P，每次比较指针i和j所指的元素是否相同，相同就同时移动两个指针，当碰到不同时（也就是“坏字符”），将j指针回到P的起始位置，i指针移动到上一次的起始位置的下一位：
以此类推，直到j指针移动到P的最后一位，说明在T中找到了P的位置，此时i的位置指向了T中P字符串的末尾，因此起始位置应该是i-j；
/** 1. BF 2. @param ts 主串 3. @param ps 模式串 4. @return 如果找到，返回在主串中第一个字符出现的下标，否则为-1 */ public static int bf(String ts, String ps) { char[] t = ts.toCharArray(); char[] p = ps.toCharArray(); int i = 0; // 主串的位置 int j = 0; // 模式串的位置 while (i &lt; t.length &amp;&amp; j &lt; p.length) { if (t[i] == p[j]) { // 当两个字符相同，就比较下一个 i++; j++; } else { i = i - j + 1; // 一旦不匹配，i后退 j = 0; // j归0 } } if (j == p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40a763db99209e4c90792296ac37f98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ed8989b70dca62c23ebbae87bf45b6/" rel="bookmark">
			HTML5用什么语言编写,编写HTML5的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我们用HTML5编写一个网页
与传统的HTML和XHTML相比，HTML5有各种新增和改进。但是，如果您到目前为止直接编写HTML(XHTML)源代码，那么编写HTML 5并不困难。这一次，我们引入以下两点作为描述HTML 5源代码的基础。(1)源HTML5的整体结构(其中，关于什么如何为写)(2)(用于从常规的HTML和XHTML的不同点)如何写报头部分首先，我将介绍HTML5源的整体结构我会的。
HTML5源码的整体构成
HTML5的描述方式与传统的HTML·XHTML大致相同。有许多额外的点/变化点，但基本上，
我可以写得更简洁元素和属性的数量增加了，可行表达式的数量也增加了思考很好。一般来说，你会写下具有以下感觉的来源。
▲HTML5源的基本结构与传统的HTML·XHTML相同。
是“DOCTYPE声明”是第1行开头，在下面的html元素，和“如描述头页面信息(头元件)”，“描述了页面(body元素)的内容主体部分”被输入是的。对于使用HTML 4.01，XHTML 1.1等编写网页的人来说，它似乎与过去几乎没有变化。HTML5不是一种“全新的语言”，它是一种“版本升级语言”，它保持与过去的兼容性，因此基本部分是相同的。因此，HTML5中没有什么难写的。尽管HTML的结构是相同的，
添加了元素和属性规格已更改的元素和属性不推荐使用的元素和属性有。他们通过，或增添实用功能的网页，你有更准确的这么希望的表达，可实现(※关于HTML5，文章“的好处HTML5的？而” HTML4“和” XHTML1“有什么区别？ “)。这就是说，它不是绝对的新要利用版本HTML5 HTML5不能写无。因为您不需要从头开始使用所有内容，所以首先应该从旧的书写风格中加入感兴趣的新规范。
如何描述HTML 5的标题部分
在HTML的开头，“DOCTYPE声明”和“头元素”是必要的。与传统的HTML和XHTML相比，在HTML 5中描述它们的方式变得更加简单。下面将编写“XHTML 1.1中的示例”和“HTML 5中的示例”，因此请进行比较。XHTML 1.1中标题部分的示例
页面标题
HTML 5中标题部分的示例
页面标题
所描述的内容没有区别，但是简化了描述方法。虽然上面的head元素只描述页面标题和字符代码，但当然你可以编写样式表，脚本，其他元元素等(如果需要，你可以用传统的HTML编写它们·它与XHTML相同)。■第一行：DOCTYPE声明
在HTML 5中，HTML开头描述的“DOCTYPE声明”非常简洁。表示语言版本和DTD的URI的字符串不见了，只显示“是HTML”。使用HTML 5编写HTML时，您只需要首先编写上述简短的DOCTYPE声明。■第二行：html元素
在XHTML中，html元素需要xmlns属性，但在HTML 5中不需要。要通过添加lang属性来指示描述语言，请执行以下操作。
lang =“ja”&gt;
对于属性值，请为日语写“ja”，为英语写“en”。第4行：字符代码
使用元素显示字符代码没有区别，但最好使用charset属性对其进行描述，因此可以稍后对其进行描述。■如何编写空元素是“空元素”，没有可以使用HTML和XHTML编写的元素的结束标记。在XHTML中编写空元素时，必须使用“/&gt;”关闭标记的末尾。相反，在HTML中，必须以“&gt;”结束而不带斜杠标记。在HTML 5中，(/&gt;或&gt;&gt;可用于任何一个(&gt;空元素标记的末尾)。因此，上面的元素，
你可以写，
/&gt;
你可以写它。
用HTML5编写的网页模板
▲用HTML 5编写的200多个模板集合
不是从1编写HTML 5源，而是基于已经完成的模板更容易编写。用HTML5编写的网页模板集合也在增加，因此最好也参考它们。这次我们将介绍“ 免费HTML 5模板 ”。发布了200多个模板，所有模板都在HTML 5中描述。
▲每个HTML5模板都可以在现场显示并下载。
虽然它是英文网站，但(1)从“模板组合”菜单中选择所需的设计，然后单击“更多信息”链接。(2)单击“查看演示”以确认显示。通过...操作简单，您可以查看各种模板。使用“在此下载”按钮，您还可以以ZIP压缩文件的形式下载一整套模板，以便您轻松使用它。
HTML5可以轻松编写
正如我所提到的，编写HTML5的基本方法与传统的HTML和XHTML几乎相同。对于已经使用HTML或XHTML编写过网页的人来说，没有什么困难。请务必尝试在HTML5中创建网页。
举报/反馈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b52424dbd95872061e7ac83223e5b0a/" rel="bookmark">
			vuex的五个核心属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VueX 是一个专门为 Vue.js 应用设计的状态管理构架，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。
Vuex有五个核心概念：
state, getters, mutations, actions, modules。
1. state：提供唯一的公共数据源,所有共享数据都要统一放到Store的State中进行存储
2. geeter：从基本数据(state)派生的数据，相当于state的计算属性
3. mutation：用于变更Store中的数据，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。
回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数,只能通过mutation变更store数据,不可以直接操作Store中的数据。
4. action：和mutation的功能大致相同，不同之处在于 1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。
5. modules：模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。
Vuex的用法：
安装 npm install vuex --save src里面创建store文件夹 创建index.js配置vuex import Vue from "vue"; import Vuex from "vuex"; Vue.use(Vuex); export default new Vuex.Store({ state: { //存放的内容所有组件都可以访问,类似于data name:"张三' }, mutations: {}, actions: {}, modules: {}, }); 在main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b52424dbd95872061e7ac83223e5b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93b8353982d7627d8b26a18b182c296/" rel="bookmark">
			Vue中使用把汉字转化为拼音字母
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 源码git地址 https://github.com/waterchestnut/pinyin.git
安装 npm install js-pinyin import pinyin from 'js-pinyin' 使用示例 import pinyin from 'js-pinyin' pinyin.setOptions({checkPolyphone: false, charCase: 0}); console.log(pinyin.getFullChars('管理员')); console.log(pinyin.getCamelChars('管理员')); console.log(pinyin.getCamelChars('1234')); console.log(pinyin.getCamelChars('english')); 程序中调用 &lt;el-form-item label="名称" prop="Name"&gt; &lt;el-input v-model="form.Name" placeholder="名称" size="small" id="Name" @input="createpy()"/&gt; &lt;/el-form-item&gt; &lt;script&gt; methods: { createpy(){ let pinyin = require('js-pinyin') pinyin.setOptions({checkPolyphone: false, charCase: 0}) this.form.NamePy=pinyin.getCamelChars(this.form.Name) } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd49034f06122b3e6ab7968a413d5ad/" rel="bookmark">
			char data[0]在结构体末尾的巧妙用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		char data[0]在结构体末尾的巧妙用法 在公司的项目代码中看见一个有趣的结构体如下： typedef struct{ int Head; char data[0]; }Msg; 当时看到也是一脸雾水，后来在网上查找资料，发现了这一用法的奇妙之处。
这一用法有如下好处：
在结构体中但是并不占用内存。巧妙地将消息头和消息体连接在一起，并且可以直接取到消息体的首地址。 这种用法一般都在消息传输时候定义消息头，里面包含后面消息体的长度，在接收完消息后可以按照解析完的消息头中的信息（比如消息长度、类型）去解析消息体，有可能消息体存在多种类型，可以用到不同的结构体转译比较灵活。用起来十分方便。但是必须将指针定义在结构体的末尾，类型随意，由于C中传输消息主要就是用字符串所以这里写成了char data[0]。
可能有的读者会问为什么不用下面这种情况：
typedef struct{ int Head; char *data; }Msg; 其实下面这种情况也可以但是，但是使用指针和data[0]有一下区别：
地址的连续性，data[0]和结构体是一个连续的存储空间，使用指针就不是连续的。连续的存储空间通过不同的强转使用起来比较灵活。data[0]不占用任何内存，*data占用4字节 。C++的类中可以使用 *data但是不要使用data[0]，因为这样使用可能会导致类中的一些看不到的东西被覆盖。 注意：
在使用data[0]在结构体末尾时如果使用结构体指针申请内存时，要申请结构体长度+data[0]长度的内存，释放内存时只需要将结构体指针释放即可完成所有内存释放。
以上内容均是作者查阅资料加自己理解，如有疑问，望读者不吝赐教，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce1ca0a5c5a8f07a15781542edd11d1/" rel="bookmark">
			flex布局小结（二）--容器的属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flex布局小结（二）--容器的属性 简述flex-directionflex-wrapflex-flow:justify-contentalign-items属性align-content理解注意 简述 flex布局中根据属性设置对象的不同可分为两大部分：即容器的属性和项目的属性。
flex容器一般设置有6大属性：
flex-direction: :设置主轴的方向，默认主轴方向为水平从左向右flex-wrap::设置是否换行，当项目宽度大于项目宽度时默认不换行flex-flow: flex-direction和flex-wrap的合(简)写。justify-content:处理主轴的富余空间（项目在主轴上的排列方式）align-items:设置项目在交叉轴上的排列方式align-content:定义了多根轴线（多行项目）的对齐方式。
flex-direction flex-direction: :用来设置主轴的方向。
属性的值有：row(默认) | row-reverse | column | column-reverse.
row : 默认值，默认主轴方向水平向右。（row：名词，行，排） row-reverse :设置主轴方向水平向左。（reverse /rɪˈvɜːs/ ： 颠倒，反转） column:设置主轴的方向为垂直向下（column:纵队，列） column-reverse:设置主轴的方向为垂直向上（反转列） flex-wrap flex-wrap::设置是否换行，属性的取值为nowrap(默认) | wrap | wrap-reverse
当项目的宽度总和大于容器的宽度时，项目默认不换行，而是在同一行上按比例缩小宽度。
&lt;style&gt; .main { display: flex; justify-content: flex-end; align-items: flex-end; height: 650px; } .box { display: flex; width: 200px; height: 150px; border: 1px solid skyblue; flex-wrap: nowrap; } .son1 { width: 100px; height: 40px; background: skyblue; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce1ca0a5c5a8f07a15781542edd11d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8038b13766f0c82a8520d38cc3ad314/" rel="bookmark">
			定位具体规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定位 相对定位 相对于自己原来的位置
绝对定位 1 绝对定位的定位规则：相对与最近一级有定位（绝对定位，相对定位，固定定位）的祖先元素
2 具体值的定位原则：首先找到具有定位的祖先元素，然后该元素的最外边(可能是上top/下bottom/左left/右right)，包含margin值，距离祖先盒子的内边（对应的上下左右），包含padding,不含border的距离为这个值
eg: 给了绝对定位，top值为10px;那么这个盒子顶部的最外边缘，将距离有定位的祖先元素的顶部内边缘10px
3 正负问题：我们知道了为0时候的位置，边界；那么绝对定位的盒子相对于边界往相对定位盒子的里面移动为正，相反为负；（就是说，我们可以先找到边界值，为零时候的样子，然后，如果值为正，绝对定位的盒子向方位词（top/bottom/left/right）相反的方向移动，为负则往相同方向移动）
eg：top:10px;那么绝对定位的盒子的最上边缘一定在具有定位祖先元素的上边缘（含padding,不含border）的下方(为正)；且距离为10px
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .dad { position: relative; width: 200px; height: 200px; border: 10px solid green; } .son { position: absolute; right: -100px; bottom: 100px; width: 100px; height: 100px; background-color: skyblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="dad"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 效果图1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8038b13766f0c82a8520d38cc3ad314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4730b22017603fa8f433e3b5a392a40/" rel="bookmark">
			[护网杯 2018]easy_tornado1 write up
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[护网杯 2018]easy_tornado1 write up 本题所需知识点：SSTI、文件包含
1 题解 点开题目，发现有3个链接
分别点开三个链接
file?filename=/flag.txt&amp;filehash=5cb650c67b3f3eb1c3382db985cba60d
file?/filename=/welcome.txt&amp;filehash=453823f83be22fbffa0f5ba9f7e7e8ba
file?filename=/hints.txt&amp;filehash=60fa05c4aee970c0ac37c763f48d27c7
发现存在文件包含漏洞，尝试将flag.txt换成/fllllllllllllag
error?msg=Error
filename参数改变，filehash也要随之改变，filehash = md5(cookie_secret+md5(filename))，filename有了，就差个cookie_secret
百度搜索下tornado，Tornado是一个基于Python的Web服务框架和异步网络库，看了后端语言是python了
然后就无思路了ORZ。。。。搜索相关资料得知，error?msg=Error这里存在SSTI，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity。
由welcome.txt的render也能得知，render是python的一个渲染函数，服务端在响应 http 请求的时候，去向模板中渲染数据，可以把视图响应给客户端，验证了SSTI的猜测。
构造链接
error?msg={{123}} 输出123
构造
error?msg={{123}} 输出ORZ
构造
error?msg={{datetime}} 输出
由文档tornado.web — RequestHandler 和 Application 类 — Tornado 4.3 文档和
tornado.web — RequestHandler and Application classes — Tornado 6.2.dev1 documentation和
Templates and UI — Tornado 6.2.dev1 documentation
得知，cookie_secret保存在settings里，handler是别名，指向RequestHandler而RequestHandler.settings又指向self.application.settings，所以handler.settings就指向RequestHandler.application.settings了。
构造payload
error?msg={{handler.settings}} 不过这里我有疑问，将payload中的handler.settings换成self.application.settings或RequestHandler.application.settings的话，会报错，希望有大佬来解答。
获取到cookie_secret
编写python脚本获取filehash，也可以手工在加密网站上加密。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4730b22017603fa8f433e3b5a392a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a721674bf50f21c912acabd2f4a745ce/" rel="bookmark">
			ROS避坑报错E: Unable to correct problems, you have held broken
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你之前安装过ROS系统然后卸载了再次安装ROS系统的时候可能会遇到依赖问题，然后会发现很多依赖无法安装，报错E: Unable to correct problems, you have held broken packages
解决方法
用aptitude自动解决依赖问题
sudo apt-get install aptitude 然后
sudo aptitude install &lt;package&gt; 然后会跳出来一堆解决方案，自己查看解决方案是否安装了你需要的包
是就按y，不是就一直按n，直到找到你要的包为止。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb39aaf4ac696eac08ec9ed9a75615f7/" rel="bookmark">
			QT：只允许在自定义标题栏中鼠标拖动控制窗口位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
说明
效果展示
代码
说明 在使用了自定义的标题栏，想要实现鼠标只能在标题栏中拖动窗口，在其它地方拖动不了窗口的效果。
我们这里是在标题栏类的鼠标事件中处理拖动窗口的事情。
实现过程：标题栏类中的鼠标事件获取了拖动位置后，通过移动标题栏的父类部件，从而实现窗口拖动。
效果展示 代码 主窗口代码
#include "widget.h" #include "ui_widget.h" #include &lt;QLabel&gt; #include &lt;QLayout&gt; #include "my_title_bar.h" Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); //标题栏 MyTitleBar* title_bar = new MyTitleBar(this); //设置背景色 title_bar-&gt;setStyleSheet("MyTitleBar{background-color: gray;}"); //设置窗口属性和布局 this-&gt;setWindowFlags(Qt::FramelessWindowHint);//去除标题栏 QVBoxLayout* main_vlayout = new QVBoxLayout(this); this-&gt;setLayout(main_vlayout); main_vlayout-&gt;setMargin(0); main_vlayout-&gt;setSpacing(0); main_vlayout-&gt;addWidget(title_bar, 1); main_vlayout-&gt;addStretch(9); } Widget::~Widget() { delete ui; } 标题栏代码
#ifndef MYTITLEBAR_H #define MYTITLEBAR_H #include &lt;QLabel&gt; #include &lt;QMouseEvent&gt; class MyTitleBar : public QLabel { Q_OBJECT public: explicit MyTitleBar(QWidget *parent = 0) : QLabel(parent) { } protected: void mousePressEvent(QMouseEvent* ev) override { QWidget* parent_widget = this-&gt;parentWidget(); start_move_pos_ = ev-&gt;globalPos() - parent_widget -&gt;frameGeometry().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb39aaf4ac696eac08ec9ed9a75615f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06a423884ef75e7652365c5c4829074/" rel="bookmark">
			无线网络数据传输的相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键单位 子载波、物理资源块（PRB）之间的关系详情见LTE中物理资源块的进一步认识
帧
数据发送流程 消息-》信源编码-》信道编码-》调制-》多天线发射信号-》无线信道-》多天线接收信号-》解调-》信道译码-》信源译码-》消息
调制之前或解调之后的信号，称为“基带信号”，一般都在低频范围内，这时候每个波形承载的信息量越大，其数据带宽越宽；
经过调制之后的信号称为“频带信号”，其中数据带宽没有发生改变，只是信号更容易在线路中传送。
对于一次传输，接收端在解调解码之后，如何判断这次接收到的数据是正确的还是错误的呢?
一种常用的方法，就是在原有信息比特的基础上添加一些额外的比特，使得这些额外的比特还原有比特之间有某种联系，满足某种规则，通过这样方式进行校验。
常用的校验方式有很多、奇偶校验、循环冗余校验CRC。在LTE里，上下行数据传输采用的检查纠错方式是HARQ
LTE是集中控制式系统，所有管理功能都集中在网络侧，更具体的是集中在基站侧，终端用户根据基站的安排来相应的行动，用户需要参考基站的时间轴和基站达成一致。因此需要对网络侧无线帧时间轴进行了解，
传统的通信需要依赖于电磁信号波形的完整性来携带信息，对于越来越广泛使用的数字通信系统过来说，传递信息不是完全靠电磁波形来携带信息的，也就不需要接收端知道接收到的电磁波信号的精确形式。
对于数字通信系统，不管怎么设计信号，采用什么调制解码方式和复用思想，数据的解调基本上可以认为是接收端对接收到的信号的采样，需要知道对通信有用的特征量是如何变化的，比如说功率。
两种数据帧结构 FDD 频分双工，又叫全双工，需要两个独立的信道，一个用来向下传送，一个用来向上传送，中间存在一个保护频道防止干扰。GSM（2G）、CDMA（2.5G）、CDMA2000（中国电信部署的 3G）、WCDMA（中国联通部署的 3G） 系统都是典型的 FDD 系统。
FDD 必须使用成对的收发频率。在支持以语音为代表的对称业务时能充分利用上下行的频谱，但在进行以 IP 为代表非对称的数据交换业务时，频谱的利用率则大为降低，约为对称业务时的 60%。
TDD 时分双工，又叫半双工，只需要一个信道，因为发射机和接收机不会同时操作，他们之间不会产生干扰。TD-SCDMA（中国移动部署的 3G）就是典型的 TDD 系统。
TDD 则不需要成对的频率，通信网络可根据实际情况灵活地变换信道上下行的切换点，能有效地提高系统传输不对称业务时的频谱利用率。
下面的这个图表示的是TDD上下行无线帧配置
两者之间的区别 虽然看上去 TDD 和 FDD 区别很大，但是从整个系统来说，FD-LTE 和 TD-LTE 的区别很小。EPC 完全一样，E-UTRAN 接口协议上也绝大部分都是相同的。TDD 和 FDD，区别就在于物理层（Physical Layer，PHY），即无线帧的区别。
在 LTE 里，无论是 FDD 还是 TDD，它的时间基本单位都是采样周期 Ts，值固定等于：32.55ns。无线帧也是数据传输的载体单位，长度为 10ms。
注意，数据帧是由 0、1 构成的，通过比特来传输数据。而无线帧则是由无线电波构成的，由无线电波来传输数据。
https://blog.csdn.net/Jmilk/article/details/103510462这篇博客上详细介绍了
FDD帧的结构，一个无线帧分为10个子帧，每个子帧又分为2个时隙，每个时隙又由7个Symbol组成，Symbol可以理解为持续一段时间的信号
TDD帧的结构，一个无线帧可以分为10个长度为1ms的子帧作为数据调度和传输的单位（TTI），其中子帧1和子帧6可配置为特殊子帧，该子帧包含三个特殊时隙DwPTS，GP 和 UpPTS。
这篇博客介绍了5G/4G：空口帧结构之帧、子帧、时隙、符号、RB。
该标准规定最小可分配频率单元由12个子载波组成，称为物力资源块（PRB）。因此SCS越小PRB越窄。
时隙是数据调度的最小单位
需要上下行时隙、帧配比，由于上下行配比主要由上下行业务，覆盖决定，建议全网配比一致。不同市场的帧配比建议应根据运营商的业务、策略、建网要求等综合决定
数据传输 上行数据传输 上行和数据传输的相关物理信道有两个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e06a423884ef75e7652365c5c4829074/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/183/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>