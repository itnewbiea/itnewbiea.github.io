<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a195917d993f8b39887e4a5b7f0325f1/" rel="bookmark">
			Android Studio 编译出现Theme.AppCompat.Light not found的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个问题实际是V7包的问题；排除这个问题从以下几点入手： 1、查看是否依赖V7包，（已经依赖的可以尝试删除再次导入）
com.android.support:appcompat-v7:VERSIONCODE 2，查看最低的SDK：
minSdkVersion ： 14 3，可以修改主项目下的build.gradle的gradle版本：
建议以上三个步骤，每走一步重新编译一下，看下问题是否解决；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366794272e9a4d74bd4a489e5dcd344f/" rel="bookmark">
			建造者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是建造者模式 Builder模式也叫建造者模式或者生成器模式，是由GoF提出的23种设计模式中的一种。
Builder模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，它把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建复合属性的对象。
二、代码演示 建造者模式用于创建复杂对象，关注于创建复杂对象的步骤过程。
在本例中，我们的目标是创建一个Product类的对象，创建对象本身是较为简单的，比如我们常用的工厂模式，可以翻阅之前的博客笔记，也就是new一下直接返回，因为工厂模式关注的是创建不同产品不同类型的对象，而不关注于其中某一个对象本身创建的过程。
建造者模式就是用来解决创建对象过程比较繁琐的对象，关注于创建对象的步骤、即为对象步骤化的装配组件。
目标：创建一个Product类的对象 package com.helius.service; /** * @Author Helius * @Create 2019-09-25-21:37 */ public class Product { private String buildA; private String buildB; private String buildC; private String buildD; public String getBuildA() { return buildA; } public void setBuildA(String buildA) { this.buildA = buildA; } public String getBuildB() { return buildB; } public void setBuildB(String buildB) { this.buildB = buildB; } public String getBuildC() { return buildC; } public void setBuildC(String buildC) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366794272e9a4d74bd4a489e5dcd344f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c00c6aa964721e3c1b5d76b171d02fc8/" rel="bookmark">
			JavaScript 实现导出 CSV 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过接口拿到的数据结构如上所示，现在要通过 JavaScript 将数据导出：
&lt;script type="text/javascript" src="json2csv.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var title = Object.keys(jsonData.list[0]); var csv = json2csv({data: jsonData.list, fields: title}); // 实现方法一： var exportFun = function(content, filename) { var eLink = document.createElement('a'); eLink.download = filename; eLink.style.display = 'none'; // 字符内容转成blob地址 var blob = new Blob([content]); eLink.href = URL.createObjectURL(blob); // 触发点击 document.body.appendChild(eLink); eLink.click(); // 移除 document.body.removeChild(eLink); }; if('download' in document.createElement('a')) { exportFun(csv, 'test.csv'); } else { alert('浏览器不支持'); } /*// 实现方法二： const BOM = '\uFEFF'; function exportCsv(data, filename) { if(navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c00c6aa964721e3c1b5d76b171d02fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e8ddc7f008669c95975bd32122e8a3/" rel="bookmark">
			导入sql时出现Invalid default value for &#39;create_time&#39;报错处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当运行SQL会出现：[Err] 1067 - Invalid default value for 'create_time'，是因为Mysql版本不同，如果版本不 &lt; 5.6请去的话报错的处理方法如下：
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' (修改前)
`create_time` datetime DEFAULT NULL COMMENT '创建时间' (修改后)
按照上述全局替换即可运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e53dbc01a54765b56a7ed8dca9370ed/" rel="bookmark">
			react在修改state中的数组和对象数据的时候（setState）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在修改状态数据（state）的时候，我们要遵循react的规则,使用setState()方法去修改
此时修改的数据是一个数组或者是一个对象的时候，setState中传递一个对象是不能够满足的，此时就需要给setState中传递函数了！
此时函数中的参数state就是我们组件中的state数据，可以在方法中把参数中state改变后通过k:v return出来
handlerWorkType(item, index) { this.setState((state) =&gt; { for(let i = 0; i &lt; state.submitWorksList.length; i++) { if(state.submitWorksList[i] == item.id) { state.submitWorksList.splice(i, 1) state.worksTypeList[index].activeShow = false return { submitWorksList: state.submitWorksList, worksTypeList: state.worksTypeList } } } state.submitWorksList.push(item.id) state.worksTypeList[index].activeShow = true return { submitWorksList: state.submitWorksList, worksTypeList: state.worksTypeList } }) } 需要注意:
必须要在数据修改之后在通过k:v对return;
避免调用其它方法，将其它方法的返回值赋值给我们的变量；得不偿失！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4644e4bc2a331bc2301392deb4941286/" rel="bookmark">
			递归算法求n个不同字符的所有全排序列（无脑简单的理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是一道典型的数据结构考研题，个人感觉树上讲的很好，但是我又不太理解，去搜各种博客也都是直接抄书，现在自己理解了，就把我的想法说一下，理解这个题的前提是要理解好递归思想。
首先从小的来说
一个数字（1）：不需要排列：1
两个数字（1，2），共两种：1，2；2，1
三个数字（1，2，3），共六种：1，2，3 ¥¥¥1，3，2¥¥¥2，3，1¥¥¥2，1，3¥¥¥3，1，2¥¥¥3，2，1（；、都不太显眼哈～）
这个时候我们就发现他其实就是3*2种情况，即三个数字就是我先挑出一个数字例如1，则对2，3排列的规则，不就是用两个数字的规则嘛，产生的就是123和132.
再往下看四个数字。共4*6种情况，这里我就不全写出来了，以一个例子说明下，我选择4作为第一个数字他一定是4123，4132，4231，4213，4312，4321，绿色部分全是三个数字的情况，同理 我选择3作为第一个数字则对（1，2，4）采取三个数字的排序规则，一样会产生3xxx的六个数字，这时候我其实已经发现递归规律了。我每次选出一个数字作为第一位，剩余数字按照上一次的规则进行排序，n个数字都作为第一位则所有情况都出来了。
思想解释明白是关键，代码csnd上有很多，大家也可以参考别人的，我直接抄书了～
#include&lt;stdio.h&gt; void perm(int a[],int k,int n){ int i; if(k==0) { for(i=0;i&lt;n;i++) printf("%c",a[i]); } else { //对n个排头进行遍历 for(i=0;i&lt;=k;i++) { //找个数，对其他数进行递归 int t; t=a[k]; a[k]=a[i]; a[i]=t; perm(a,k-1,n); t=a[k]; a[k]=a[i]; a[i]=t;//还原数组 } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1aa8d5017c734f8a77896199ce4522a/" rel="bookmark">
			GitChat，一个记录技术和躺着赚零花钱的免费平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
NEW项目十：疫情下的口罩检测：一文入门 Pytorch
NEW项目九：小白和你聊秋招
NEW项目八：用 PyTorch 框架做深度学习会如此简单
项目一：一个项目带你快速入门 Qt Creator
项目二：手把手实践 YOLO 深度残差神经网络拐点检测
项目三：从凸优化理解高维特征下的深度学习
项目四：YOLO V3 一步步训练自己的目标检测
项目五：机器学习必备的5个脚本工具详解
项目六：YOLO V1和YOLO V3深度学习目标检测补遗更新
项目七：一线城市初次租房防坑指南
NEW项目十：疫情下的口罩检测：一文入门 Pytorch 疫情下，人人都戴上了口罩。尤其是出入地铁站、火车站、商场等人流密集的场所，不戴口罩是不允许进入的。口罩检测成了当下较为应景的深度学习实战项目。
本次 Chat，采用 Facebook 人工智能研究院（FAIR）开源的深度学习框架 Pytorch。将从以下几个点，尽可能详尽的手把手带你一步一步实现口罩检测任务。
数据介绍、数据准备和 Pytorch 数据处理该任务下的 ResNet-Pytorch 网络模型定义损失函数、优化器、学习率定义不要太简单训练模型（CPU or GPU）、单图测试和Camera测试总结 学完本 Chat，你将对深度学习框架 Pytorch 的整个流程和使用有了初步的认识。可进一步优化口罩检测，使之成为一个可以上线的应用。
直达链接：疫情下的口罩检测：一文入门 Pytorch
NEW项目九：小白和你聊秋招 和标题一样，应届生，坐标深圳，刚刚入职科技创业型公司上班一个月。不是什么大公司，也没有大名响当当的导师团队，但是真心喜欢。所以，我想和你聊5毛钱的秋招，不知道你愿不愿意。主要分享内容如下：
金九银十，秋招真的是这样吗八月了，我现在在做什么，和即将要准备些什么实习、比赛经历、项目经历写到简历里要注意些啥呢我要去投大公司吗？创业型的小公司要不要投、怎么投、哪里投呢十月底了，我怎么还没有 offer，要不要继承家里的企业，这样的我究竟我还能做什么哎，那就这样吧，我还是好好准备年后的春招吧。 就上面这样，5毛钱纯分享。如果你正在准备秋招，赶紧上车吧。保证绝对个人经历，回过头来看一年前的自己，原来有那么多事情可以做的更好，欢迎你来。
Gitchat地址：小白和你聊秋招
NEW项目八：用 PyTorch 框架做深度学习会如此简单 PyTorch 是深度学习众多开源框架中的一种，由 Facebook 于 2017 年基于 Torch 构建而成，是一个以 Python 优先的深度学习框架，同时还支持动态神经网络，以其灵活、简洁和易用性吸引了数据科学专业人士和深度学习从业者的关注。
本文将围绕真实场景项目中图像分类入手，从以下几个方面展开：
PyTorch 是什么基于 Aanconda Python3 的 PyTorch 安装有监督学习和神经网络优化数据三分类任务加深对 PyTorch 和神经网络的理解实战场景识别项目监控数据/模型--TensorboardX 可视化 本文适合深度学习小白入门进阶，苦恼于 TensorFlow 的繁琐，想快速的掌握一个深度学习框架的学生和从业者。学完本文，可以对 PyTorch 框架有个较好的理解，有助于更深层次的学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1aa8d5017c734f8a77896199ce4522a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7723231872e7c9cb35967bebc802b95/" rel="bookmark">
			Unity官网打不开，试试新地址吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年6月份发现unity官网进不去了（unity3d.com unity.com/cn/ ），下载历史版本的地址也打不开
网上也有很多人求助。
新域名如下，不需要挂vpn
新地址：https://unity.cn/
历史版本下载：https://unity.cn/releases
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58b08cf3d3c71041904413245433394/" rel="bookmark">
			中国最顶级的一批程序员，从首富到首负！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过去的20年 是程序员快意恩仇的江湖时代 通过代码，实现梦想和财富 有人痴迷于技术，做出一夜成名的产品 有人将技术变现，创办企业成功上市 这些早一代的程序员们创造的奇迹 引发了一浪高过一浪的互联网热潮 上一篇为大家展示了↓↓ 《技术领域有着巨大影响力的程序员》 点击标题可迅速查看↑↑ 这一篇将为大家带来 《商业领域有着巨大影响力的程序员》 （小编补充：排序并不按个人成就，如果你的偶像排在后面了，别纠结别激动！！！） 能做出好产品 又能引领企业走向巅峰的人，很厉害 01.WPS之父-求伯君 求伯君，浙江绍兴人。 1998年，一个人，一年时间，写出了和微软抗争了十多年的国产办公软件“WPS1.0”。 年仅25岁，他就成为了程序员出身最富有的创业者，他的名字早已写进中国软件的历史！是那个时代最让程序员们振奋的“英雄”，无可争议的成为“中国第一程序员”！ 个人历程： 1964年，出生于浙江绍兴一个贫苦农民家庭； 1984年，国防科大信息系统专业，分配到河北某仪器厂； 1986年，仪器厂辞职，加入北京四通公司； 1988年，加入香港金山公司； 1994年，在珠海创立珠海金山电脑公司； 2011年，从金山退休，副董事长雷军接任。 个人成就： WPS之父：以一己之力写出WPS1.0，填补了我国中文字处理软件的空白； 创立了中国第一个电脑游戏《中关村启示录》； 金山之主：带领金山上市，成为当时最富有的程序员； IT导师：金山中，走出了雷军、王峰、冯鑫、尚进等，被称之为“旧金山”的IT创业者…… 民族软件导师：中央电视台《东方时空》在比尔·盖茨来中国的当天，请求伯君谈民族软件以及WPS97如何抗击Word。 评价： 雷军：写求伯君的文章虽然很多，但令人满意的还没有。 网友：走进当年的IT圈，到处都是求伯君2.0版。 02.小米-雷军 雷军，湖北仙桃人。 写过加密软件、杀毒软件、财务软件、CAD软件、中文系统，焊过电路板，干过黑客，大学没毕业，就靠开发软件成了百万富翁，业界公认的劳模。 做发布小米1.0需要拍视频，陈年、李学凌在内的一帮兄弟都为他出镜，砸掉苹果用小米。 个人历程： 1969年，出生于湖北仙桃； 1991年，毕业于武汉大学计算机系； 1992年，进入金山软件做程序员； 2010年，创办小米科技； 2011年，后接任求伯君任金山CEO。 个人成就： 与同事合著《深入DOS编程》、《深入Windows编程》等书； 个人信仰： 20年前我是一名软件工程师，到今天依然是！ 外界评价：
求伯君：其实雷军是大家口中程序员的一个最佳典范，永远的精力充沛，时刻都想着去 build，并且能够及时的修复过程中的 bug，有着这么严谨的程序员思维，这也是他现在这么成功的原因。
猎豹CEO傅盛：雷军无论多成功，永远一副低姿态。第一次见他，他手里拿个小本，问我当时做360安全软件的成功经验，我说什么，他就用笔都记下来。
03.百度-李彦宏 李彦宏，山西阳泉人。 学霸级的人物，持有“超链分析”技术专利，甚至奠定了现代搜索引擎的发展方向。 年少钟爱戏曲，一度被剧团相中，但在中学时还是回归课堂，以阳泉市第一名考上北大！ 个人历程：
1968年，出生于山西阳泉，他在家中是五个孩子中的唯一男孩，少年时钟爱戏曲，曾被剧团录取；
1991年，毕业于北大信息管理系，随后赴美完成计算机硕士学位；
1994年，进入华尔街道·琼斯公司，担任金融信息系统设计工作；
1997年，进入硅谷著名搜索引擎公司Infoseek(搜信)公司；
2001年，回国创立百度； 2011年，成为大陆地区的首富。 个人成就：
曾经为道.琼斯公司设计的实时金融系统，仍被广泛地应用于华尔街各大公司的网站；
最先创建了ESP技术，并将它成功地应用于Infoseek/GO.COM的搜索引擎中； 拥有“超链分析”技术专利，是奠定整个现代搜索引擎发展趋势和方向的基础发明之一。 （李彦宏称之为搜索引擎第二定律，利用检索关键词在一篇文章中出现的频率多少进行网页排序的技术，被称为第一定律） 个人信仰： 技术本身并不是唯一的决定性因素，商战策略才是真正决胜千里的因素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58b08cf3d3c71041904413245433394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6822550bab8476d83df5c24cbb292927/" rel="bookmark">
			闭包与作用域再次深究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到一个有意思的函数
function test (arr) { var temp = [] for (var i =0; i&lt;arr.length; i++) { (function() { var j = i; temp[i] = function () { return j } })() } return temp }　那么以下的结果会打印出什么呢？
var arr = [1,2,3,4,5] var arrFn = test(arr) console.log(arrFn[0])　结果是：0；
那么继续test函数换成以下两种又会是什么结果呢？
function test2 (arr) { var temp = [] for (var i =0; i&lt;arr.length; i++) { temp[i] = function () { return i } } return temp } function test3 (arr) { var temp = [] for (var i =0; i&lt;arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6822550bab8476d83df5c24cbb292927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb58fda65ed318eb12febc7a19ed0bb/" rel="bookmark">
			Java中文乱码字符集解决大全-(转)阿童沐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来用的方法:过滤器
get传//获取request中的参数(包含中文的参数)，并转换为utf-8 value = new String(value.getBytes(“iso-8859-1”), “utf-8”);
request.setCharacterEncoding(“utf-8”);
response.setContentType(“text/html;charset=utf-8”);
response.setCharacterEncoding(“utf-8”);//服务器端编码
&lt;%@ page pageEncoding="utf-8" contentType="text/html; charset=ISO-8859-1"%&gt;//ISO-8859-1 网页信息 导致乱码 &lt;% response.setCharacterEncoding("utf-8"); //修正 可以正确显示 %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Test Character&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="chartest" method="POST" target="_self"&gt; id:&lt;input name="id" type="text" value="" size="30"&gt; name:&lt;input name="name" type="text" value="" size="30"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; public class CharTest extends HttpServlet { @Override public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // TODO Auto-generated method stub req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb58fda65ed318eb12febc7a19ed0bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8ff6bdd9c81255e08f56cfcfe7f2f6/" rel="bookmark">
			【转】Linux 进程终止后自动重启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#! /bin/bash ps -ef | grep python3 a.py | grep -v grep | grep python3 if [ $? -ne 0 ] then cd /opt/a.py &amp;&amp; python3 a.py else echo "running" fi 之后写一个定时脚本2分钟捕捉一次
2 * * * * /opt/a.sh 作　者：咸鱼Chen 出　处：https://www.cnblogs.com/nickchen121
转载于:https://www.cnblogs.com/zhangzhijian/p/11571776.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44cbb2d3caf1da9f2f65e4aac23814c/" rel="bookmark">
			IOS13系统升级带来的H5兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20号新推送的IOS13给很多app厂商和RD带来了便秘的感觉，目前复现的问题如下，后续还会持续更新：
1.H5 hybrid输入框导致的页面上移，卡住不动。收起减半后，页面出现半截白屏。（IOS12 + IOS13）
IOS12会在键盘弹出时将页面上推，并压缩body的高度。
IOS13会在键盘弹出时将页面上推，但html，body的高度全部不变。
目前移动端的输入框不外乎一下三种：
（1）原生input
（2）可编辑DIV
（3）自家或他家的富文本编辑器
我司目前使用第二种方案，即可编辑DIV+本地原声虚拟键盘（后续会改为原声H5键盘），可从两个层面解决上述问题。
首先需要在根节点最底部添加一个占位的DIV，并且设置不可见。
&lt;div id="app"&gt; &lt;div v-if="loadingFlag &amp;&amp; !timeoutFlag" class="hw-box"&gt; &lt;hw-entrance class="do-entrance"&gt;&lt;/hw-entrance&gt; &lt;/div&gt; &lt;!-- IOS13用于兼容处理键盘弹出后页面上拉的问题 --&gt; &lt;div id="bottomBackToView"&gt;&lt;/div&gt; &lt;/div&gt; 接下来要添加样式：
#app #bottomBackToView{ display: block; width: 100%; height: 0; opacity: 0; } H5层面：通过监听焦点移除设置
oDom.addEventListener('blur', function () { document.body.scrollTop = 0; // IOS12 document.body.style.height = document.body.clientHeight; // IOS12 backView.scrollIntoView(); // IOS13用于兼容处理键盘弹出后页面上拉的问题 }) 上述解决方法在非可编辑DIV的方案中也许时能够解决问题的，但是在Hybrid H5中可编辑DIV还有其他各种兼容性问题，在此，我们的最终解决方案时需要IOS配合解决的，利用IOS监听键盘收起然后做对应的处理：
bridgeClass.jsEventHook.keyboardWillHide = function() { if (!switchFlag) { document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c44cbb2d3caf1da9f2f65e4aac23814c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae3db119196816fa2c35060685de1b0/" rel="bookmark">
			移动端屏幕适配——通用适配方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html字体大小随屏幕大小的改变而改变，封装函数如下：
通用适配中解决了边框1px的问题。
(function(){ 'use strict'; // dpr-&gt;scale = 1/dpr var docEl = document.documentElement, viewportEl = document.querySelector('meta[name="viewport"]'), dpr = window.devicePixelRatio || 1, maxWidth = 540, minWidth = 320; dpr = dpr &gt;= 3?3 : (dpr&gt;=2?2 :1); docEl.setAttribute('data-dpr',dpr); docEl.setAttribute('max-width',dpr); docEl.setAttribute('min-width',dpr); var scale = 1/dpr, content = 'width=device-width,initial-scale='+ scale +',maximum-scale='+ scale +',minimum-scale='+ scale +',user-scalable=no'; if(viewportEl){ viewportEl.setAttribute('content',content); }else{ viewportEl = document.createElement('meta'); viewportEl.setAttribute('name','viewport'); viewportEl.setAttribute('content',content); document.head.appendChild(viewportEl); } setRemUnit(); window.addEventListener('resize',setRemUnit); function setRemUnit(){ var ratio = 18.75; var viewWidth = docEl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae3db119196816fa2c35060685de1b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df8b46b86ee033b8931dc1d8a082bad/" rel="bookmark">
			中文情感分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情感分析在NLP领域中是应用很广泛的技术，一般用深度学习来解决这一类的问题。其实我的理解就是情感分析就是一个分类问题。这里我爬取了京东小米9的用户评论，正面和负面的评价各1000条，爬虫和整体的代码我放在了 GitHub 。然后我把预训练的词向量文件放在了 百度网盘，提取码：rxci。
我们一起来看看数据长得啥样，首先是小米9正面的评价：
然后是小米9负面的评价：
从这些数据印证了一句话，幸福的人都是相似的,不幸的人各有各的不幸。可以看到正类的评价里面基本上都是说小米9外观好看性能好，很容易就找到正类的特征词了。但是我们来看负类的小米9评价，基本上每一条负面评价吐槽的点都不一样，有对客服不满意的，有对小米活动失望的，有对没有优惠不满意的。有的正常看来似乎没有什么不满意，但是还是打了低分。这样的数据我感觉其实对结果是有一定影响的，我们如果想得到效果更好的模型，我们其实可以对数据进行筛选。好了，为了方便，我就直接用这个数据进行训练了。
首先我们逐行读取数据集，分别读取话术和标签。然后读入已经训练好的词向量 sgns.zhihu.bigram，这个训练好的词向量是一个长度为300维的。如下图所示，比如深圳这个词的300维词向量：
然后同时可以计算两个词的相似度：
同时也可以找出某一个词的最相似的 n 个词：
从上面的图可以看出，这个词向量训练的是不错的，和烤肉相似的都是一些吃的。然后我们可以用训练集构建词典，代码如下所示：
train_tokens = [] for text in train_texts_orig: # 去掉标点 text = re.sub("[\s+\.\!\/_,$%^*(+\"\']+|[+——！，。？、~@#￥%……&amp;*（）]+", "",text) # 结巴分词 cut = jieba.cut(text) # 结巴分词的输出结果为一个生成器 # 把生成器转换为list cut_list = [ i for i in cut ] for i, word in enumerate(cut_list): try: # 将词转换为索引index cut_list[i] = cn_model.vocab[word].index except KeyError: # 如果词不在字典中，则输出0 cut_list[i] = 0 train_tokens.append(cut_list) 这里我们定义一下输入token的长度：
我们长度定98就可以覆盖了95%以上的话术长度了。然后不足98的我们在前面补0：
然后我们处理好训练集之后，我们可以开始定义网络了，这里我们用双向LSTM加一个输出层，网络结构非常简单，代码如下所示：
model = Sequential() model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df8b46b86ee033b8931dc1d8a082bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b39ead133325afe3058bf82ba7986e/" rel="bookmark">
			Win10任务栏调整小工具（任务栏改到左侧且设置窄）——实测好用的7 taskbar tweaker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为用多了Ubuntu的左侧任务栏，再用win10总觉得任务栏在下面不好用，再加上现在16:9的宽屏越来越主流，任务栏在下面把实际有效工作区域进一步缩小了，尤其是编辑查看长文档和代码的时候。所以想到把任务栏放到左边，但是win10的系统对任务栏放到左侧做了最小宽度限制，所以只能是下图这样的：
网上有的说是日期的长度和图标的大小，上面可以看到，我已经修改了短日期的格式（不显示年），也试过用小图标，都是最窄只能这样，看着不协调。
后来在知乎上看到有人介绍一个系统小工具，就实测了一下
工具名称是：7 taskbar tweaker
7 taskbar tweaker的CSDN本地下载地址
安装打开以后，界面如图：
同时上图也可以看出我在设置以后，左侧的任务栏已经变得很窄了，左下方通知栏基本上都是一行一个了（这里我启用了系统的任务栏小图标了的），启动方式如下图：
可以看出，任务栏靠左也是通过这里调整的。
重点来啦！重点来啦！重点来啦！
光是这样其实还做不到任务栏宽度调整突破系统最小宽度限制的，要想能够突破系统的最小宽度限制，要设置高级选项：
如上图，右键点击任务栏通知区域的7TT，在弹出的菜单里选高级选项，弹出如下界面：
在高级选项里面找到no_width_limit这一项，这一项默认的是0，改成1。
确定以后，在去拖动任务栏，就会发现，原本拖窄到一定程度就不能再拖的，可以继续拖动变得更窄了，直到跟程序图标宽度一样就拖不了了。
7 taskbar tweaker的CSDN本地下载地址
以下内容更新于2020年12月31日
之前提供的版本可以在有些版本win10系统中会出现不兼容情况（最近新买了联想笔记本遇到的，另外，那那个联想自带的电源管理任务图标本身超宽了，需要隐藏才可以最窄），其实可以用，但是会弹个有情提示（作者还是很良心的），想重新上传一个新版本的但是上传不了，以下更新这个工具开发作者的主页和源码地址，可以下载最新版本，感兴趣的开发同学也可以学习学习源码
点击进入开发作者主页
点击进入git代码页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48bce0e1c3fc4dbd7741051ce44f95c2/" rel="bookmark">
			为什么要用@Param
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文转载自https://blog.csdn.net/sinat_33010325/article/details/84261662
目录
1.关于@Param
2.原始的方法
3.使用@Param
4.后记
1.关于@Param
@Param是MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应，一般在2=&lt;参数数&lt;=5时使用最佳。
2.原始的方法
当只有一个参数时，没什么好说的，传进去一个值也只有一个参数可以匹配。当存在多个参数时，传进去的值就区分不开了，这时可以考虑用Map，例如接口
public List&lt;Role&gt; findRoleByMap(Map&lt;String, Object&gt; parameter); xml文件 ---------------（1）
&lt;select id="findRoleByMap" parameterType="map" resultType="role"&gt; SELECT id,name FROM t_role WHERE roleName=#{roleName} AND note=#{note} &lt;select&gt; 测试文件
RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); Map&lt;String, Object&gt; parameter = new HashMap&lt;&gt;(); parameter.put("roleName", "剑士"); parameter.put("note", "决战紫禁之巅"); List&lt;Role&gt; roles = roleMapper.findRolesByMap(parameter); 3.使用@Param
很明显上面的缺点就在于可读性差，每次必须阅读他的键，才能明白其中的作用，并且不能限定其传递的数据类型，下面是使用@Param的情况，需要将接口改为
public List&lt;Role&gt; findRoleByAnnotation(@Param("roleName") String roleName, @Param("note") String note); 这样我们就可以直接传入对应的值了。
当然也可以使用Java Bean来传递多个参数，定义一个POJO
public class RoleParam { private String roleName; private String note; /*getter和setter*/ } 此时接口就变为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48bce0e1c3fc4dbd7741051ce44f95c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933e1e29c069173bd521f97983134bc9/" rel="bookmark">
			Precision@N
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Precision@N这个指标最初是针对信息检索领域的。
一般来说，搜索结果前几项的准确性比较重要，假设说，搜索出来的前几条结果就是和搜索词不相关的，即使后面的结果都是相关的，那么这个信息检索系统也是不能令人满意的。因此，需要一些指标来度量前几个结果的准确率，P@N就是这样一种指标，它的意思就是Precision at top-N，就是搜索结果前N个的准确率，通过N比较小，因为就是要度量搜索结果前几条的准确率，如P@5，P@10。写成公式就是下面这样：
P @ N = 与 检 索 相 关 / N P@N = 与检索相关/N P@N=与检索相关/N
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9630bce249285e0cc820e5365869d428/" rel="bookmark">
			说好不哭！又炫又酷又炸的数据可视化前端开发揭秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网在各行各业的影响不断深入，数据规模越来越大，各企业也越来越重视数据的价值。作为一家专业的数据智能公司，个推从消息推送服务起家，经过多年的持续耕耘，积累沉淀了海量数据，在数据可视化领域也开展了深入的探索和实践。
个推的数据可视化探索和应用由需求出发，从基于开源平台到结合个性化需求进行定制化开发，打造出个推实时消息推送下发图，人群分布热力图等优秀数据可视化作品。这一过程中，个推积累沉淀了大量的数据可视化组件，打磨了自己的数据可视化技术能力。其中，个推热力图正应用在智慧城市、人口空间规划、公共服务等领域，为其提供强大的数据支撑。
个推消息下发图
个推打造的湖滨商圈区域人口热力图
本文就和大家分享一下个推的数据可视化实践、遇到的问题及解决思路，希望大家能从中有所受益。
一、数据可视化的构成
数据可视化由四类可视化元素构成：背景信息、标尺、坐标系、视觉暗示。
1.1 背景信息
背景信息就是标题、度量单位、注释等附加类的信息。主要是为了帮助大屏受众更好地理解相关背景信息，即5W信息：何人（who）、何事（what）、何时（when）、何地（where）、为何（why）。
1.2 标尺
标尺主要用来衡量不同方向和维度上的数据大小，常用的有数字标尺、分类标尺、时间标尺等，类似我们熟悉的刻度。
1.3 坐标系
坐标系有一个结构化的空间，还有指定图形和颜色画在哪里的规则，用于编码数据的时候，将物体放到该空间中的某一特定位置，它赋予X、Y坐标或经纬度以意义。常见的坐标系有直角坐标系、极坐标系、地理坐标系。饼图里面用的是极坐标系；柱状图里面有X轴、Y轴，就是直角坐标系；热力图里面用的则是地理坐标图。
1.4 视觉暗示
视觉暗示则是用来编码数据的元素，如位置、长度、大小、方向等。1985年，贝尔实验室发布了视觉元素的暗示排序清单。如清单所示，从上往下，大脑感知系统对这些符号、位置感知有不同的敏感程度，从最高到最低依次是：位置、长度、角度、方向、形状、面积/体积、色相与饱和度。
贝尔实验室于1985年发布的视觉元素暗示排序清单
二、数据可视化的应用
根据不同的数据结构类型，数据可视化的应用也不同，常用的有统计数据图表、关系数据图表、地理空间数据图表。
2.1 统计数据图表
常用的统计数据图表有线形图、柱状图、饼图、雷达图。其中，线形图中的视觉元素为方向，我们从中感知到的是变化趋势；柱状图中的视觉元素为长度，我们从中感知到的是数据所代表的值的大小；而饼图和雷达图中的视觉元素则分别是角度和面积。
2.2 关系数据图表
常用的关系数据图表有关系图、流程图、树图和桑基图。关系数据图表最重要的就是关系。从渲染层面来说，关系图存在两个最重要的难点：布局和聚类。布局意即如何分布要展现的数据，关系图、流程图、树图等，都只是布局不同；聚类则是要将真实的关系进行聚类模拟和可视化呈现出来，比如，哪些实体属于同一类别、相距比较近、或有从属关系等。
2.3 地理空间数据图表
地理空间数据可视化图表有散点图、路径图、热力图、下发图等。地理空间数据图表的特点就是基于地理坐标系。
现在业内对地理空间数据可视化的研究非常多，像高德地图的Loca、Uber联合mapbox推出的kepler.gl等，都是非常优秀的地理空间数据可视化应用案例。
英国某城市间工作跟住宅的通勤地图 运用了方向和颜色的视觉暗示
kepler.gl中展示的某城市地震密度图 运用了位置、时间和颜色的视觉暗示
除以上四种常用的数据可视化图表之外，其实还有很多其他类型的图表，像词云图、时间序列数据图等，这里就不再一一赘述。
三、地图的基本原理
在对地理空间数据进行可视化的实践中，对地图的渲染是非常重要的一步。
地图渲染步骤
上面这张图清晰地呈现了地图渲染的步骤：
· 首先，将地球通过墨卡托投影变成平面地图；
· 然后，将平面地图根据现实场景，分成一层层不同精度的地图，排列成为一个金字塔状；
· 最终，将拼凑起这张地图的细节分割成为一张张地图瓦片。
地图渲染涉及到两个重要名词：地图投影和地图瓦片，下面对这两个名词进行了详细解释：
3.1 地图投影
按照投影形式的不同，地图投影有圆锥投影、圆柱投影、方位投影三种；根据投影方向的位置又可以分为正轴投影、横轴投影、斜轴投影三种。这里要说的是，因为投影，地图就不可能被精准还原，投影展开后的平面地图肯定会有一个变形，根据变形又可以分为等角投影、等面积投影、任意投影等。
根据不同的地图使用场景，需要选择不同的投影算法，现在很多投影算法都是现成的，不需要自己手动写。其中，等角投影是用得比较普遍的一种，其中的墨卡托投影，则是现在地图厂商使用较多的一种地图投影算法。
不同的地图投影方式
3.2 地图瓦片
经过Web墨卡托投影后，地图就变为平面的一张地图。因为有时候我们需要看宏观的地图信息（如世界地图里每个国家的国界），有时候又要看很微观的地图信息（如导航时道路的路况信息）。为此，我们需要对这张地图进行等级切分。
地图瓦片的金字塔坐标体系
在最高级（zoom=0），需要的信息最少，只需保留最重要的宏观信息，因此用一张256x256像素的图片表示即可；在下一级（zoom=1），信息量变多，用一张512x512像素的图片表示；以此类推，级别越低的像素越高，下一级的像素是当前级的4倍。这样，从最高层级往下到最低层级就形成了一个金字塔坐标体系。
对每张图片，我们将其切分为256x256的图片，成为瓦片（Tile）。这样，在最高级（zoom=0）时，只有一个瓦片；在下一级（zoom=1）时，有4个瓦片；在下一级（zoom=2）时，有16个瓦片，以此类推。
四、个推数据可视化实践
个推的数据可视化建设有下发图、热力图等。
1) 个推消息下发图 实时展现了个推当天累计消息下发量、应用下发群体画像（包括性别比例、年龄段分布、当日应用下发城市Top5等）。
个推消息下发图
2) 个推区域人口热力图 则对区域人口分布、人口性别比例、人口年龄段等进行了数据可视化呈现。
个推打造的湖滨商圈区域人口热力图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9630bce249285e0cc820e5365869d428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf537e306edb948d9915f17842521817/" rel="bookmark">
			oracle给用户授权存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/fab356d68ae2
grant connect,resource to xinomonitor;
发现不能进行断点调试，然后授如下权限
grant debug any procedure to xinomonitor;
grant debug connect session to xinomonitor;
转载于:https://www.cnblogs.com/Struts-pring/p/11541861.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f678caec6869b732ac35d0547d9f892/" rel="bookmark">
			程序员成长之旅——日期类的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员成长之旅——日期类的实现 Date.hDate.cpp Date.h #define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;iostream&gt; using namespace std; class Date { /*一年一共有365天或者366天，平年有365天，闰年有366天，闰年每隔4年一次。100年不闰，400年一闰 平年的2月是28天，闰年2月是29天。 4月、6月、9月、11月各是30天.。 1月、3月、5月、7月、8月、10月、12月各是31天。*/ public: int GetMonthDay(int year, int month); void Print(); //	// 拷贝 赋值 析构 / 都要去练习写一下 Date(int year = 2019, int month = 1, int day = 1); 拷贝构造函数 //Date (const Date&amp; s) //{ //	_year = s._year; //	_day = s._day; //	_month = s._month; //} 析构函数 //~Date() //{} bool operator&lt;(const Date&amp; d); bool operator&gt;(const Date&amp; d); bool operator&lt;=(const Date&amp; d); bool operator&gt;=(const Date&amp; d); bool operator==(const Date&amp; d); bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f678caec6869b732ac35d0547d9f892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bbf63726a62ed43cb7cefe948edd91/" rel="bookmark">
			PHP模拟javascript的位移运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主这几天在捣鼓爬虫，不可避免的需要去模拟一些网站变态的加密算法（顺便吐槽一句：你们这些网站真的很不友善！）。 既然是加密算法那么位运算就是不可或缺的了。相比较javascript而言，PHP没有&gt;&gt;&gt;这种无符号右移的运算符，而且就算是普通的&lt;&lt;左移和&gt;&gt;右移运算符，PHP算出来的结果也会不同于javascript。所以只能打模拟js位移运算符的主意了。 上网爬了一圈，在stackoverflow上发现一篇帖子（传送门）在聊这个问题，帖子里有贴一些&gt;&gt;&gt;运算符实现的代码。遗憾的是我没能看懂，只能自己来撸一个了（已回复该帖，有缘的朋友给个up吧）。 然后的然后就有了下面的代码。各位如果有同样的困惑尽管拿去用（每个函数都配合nodejs做了10w+次的测试，应该没问题）。 /** * &gt;&gt;&gt; javascript operator in php x86_64 * @param int $v * @param int $n * @return int */ function rrr($v, $n) { return ($v &amp; 0xFFFFFFFF) &gt;&gt; ($n &amp; 0x1F); } /** * &gt;&gt; javascript operator in php x86_64 * @param int $v * @param int $n * @return int */ function rr($v, $n) { $v = $v &amp; 0x80000000 ? $v | 0xFFFFFFFF00000000 : $v &amp; 0xFFFFFFFF; return $v &gt;&gt; ($n &amp; 0x1F); } /** * &lt;&lt; javascript operator in php x86_64 * @param int $v * @param int $n * @return int */ function ll($v, $n) { $t = ($v &amp; 0xFFFFFFFF) &lt;&lt; ($n &amp; 0x1F); return $t &amp; 0x80000000 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bbf63726a62ed43cb7cefe948edd91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c36eaf385befa36e6358bc407e338f1/" rel="bookmark">
			常用的编码(持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rot
ROT5 是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。下面分别说说它们的编码方式： ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。 ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。 ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码。栏栅密码
所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 转载于:https://www.cnblogs.com/thenbz3/p/11532738.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a6b662e6f12095abf7b60ba72dcdfc/" rel="bookmark">
			十种算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源于： http://www.myexception.cn/other/1825523.html
算法一：快速排序算法
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
算法步骤：
1 从数列中挑出一个元素，称为 “基准”（pivot），
2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
算法二：堆排序算法
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
堆排序的平均时间复杂度为Ο(nlogn) 。
算法步骤：
创建一个堆H[0..n-1]
把堆首（最大值）和堆尾互换
3. 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
4. 重复步骤2，直到堆的尺寸为1
算法三：归并排序
归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。
算法步骤：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针达到序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾
算法四：二分查找算法
二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。
算法五：BFPRT(线性查找算法)
BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。
算法步骤：
1. 将n个元素每5个一组，分成n/5(上界)组。
2. 取出每一组的中位数，任意排序方法，比如插入排序。
3. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。
4. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a6b662e6f12095abf7b60ba72dcdfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7c5fa88bbabcac0b53f05d30d843de/" rel="bookmark">
			软件测试中单元测试，集成测试，系统测试，验收测试的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件测试按照研发阶段一般分为5个部分：单元测试、集成测试、确认测试、系统测试、验收测试，下面将不同阶段需要的一些工作内容做一下梳理希望可以帮助到大家。
单元测试（是指对软件中的最小可测试单元进行检查和验证，测试方法：白盒测试）
单元测试又称为模块测试，是针对软件设计的最小单位程序模块进行正确性检查的测试工作，单元测试需要从程序内部结构出发设计测试用例，多个模块可以平行地独立进行单元测试。
一、单元测试的内容：
1、模块接口测试
应对通过所测模块的数据流进行测试
调用所测模块时的输入参数与模块的形式参数的个数、属性和顺序是否匹配
所测模块调用子模块时，输入子模块的参数与子模块的形式参数在个数、属性和顺序上是否匹配。
输出给标准函数的参数的个数、属性和顺序是否正确。
全局变量的定义在各个模块中是否一致。
当模块通过外部设备进行输入/输出操作，文件属性是否正确、open和close语句是否正确，规定的I/O格式说明与I/O语句是否匹配；缓冲区容量是否与记录长度匹配，在读写之前是否打开了文件，读写之后是否关闭了文件，对I/O错误是否做了处理。
2、 局部数据结构测试
局部数据结构是最常见的错误来源
不一致的数据类型
不正确或不一致的数据说明
使用尚未赋值或尚未初始化的变量
错误的初始值或错误的缺省值
3、 路径测试
运算的优先次序、常见的比较和控制流
4、错误处理测试
遇见出错的条件，并设置适当的出错处理
5、边界测试
例如循环的次数，最大或最小值
二、单元测试步骤：
利用设计文档设计测试用例；
创建被测模块的桩模块或驱动模块；
利用被测试模块、驱动模块和桩模块来建立测试环境，进行测试
驱动模块：相当于所测模块的主程序，它接收测试数据，把这些数据传送给所测模块，最后再输出实际结果
桩模块：用以代替所测模块调用的子模块。
集成测试（也叫组装测试或联合测试，测试方法：灰盒测试）
在单元测试的基础上，需要将所有模块按照概要设计说明书和详细设计说明书的要求进行组装。
在把各个模块连接起来的时候，穿越各个模块的接口的数据时候会丢失
一个模块的功能是否会对另一个模块的功能产生不利的影响
各个子功能组装完成后，能否达到预期的父功能
全局数据结构是否有问题
单个模块产生的误差累计起来是否会放大
模块组装成系统的方式：一次性组装方式和增殖式组装方式
一、一次性组装方式
先对模块分别进行测试，再把所有模块组装进行测试
缺点：发现错误不容易定位 二、增值式组装测试
先对一个个模块进行模块测试，然后将这些模块逐步组装成系统，分为两种方式：自顶向下的增殖方式和自底向上的增殖方式
1、自顶向下的增殖方式（不需要驱动模块）
将模块铵系统程序结构，严控制层次自顶向下进行组装。
首先以主模块作为被测模块兼驱动模块，所有直属主模块的下属模块全部用桩模块代替，对主模块进行测试。再采用深度优先或广度优先的策略，用实际模块代替桩模块，再用桩模块代替它们的直接下属模块，与已经测试的模块构成新的子系统。然后进行回归测试。
2、自底向上的增殖方式（不需要驱动模块）
由驱动模块控制最底层模块的并行测试。
3、混合增殖式
自顶向下增殖方式：
优点：能够较早的发现主要控制方面的问题
缺点：需要建立桩模块，增加了一些附加的测试，涉及算法和输入输出的模块一般在底层，这些底层模块要到组装和测试的后期才能发现。一旦发现问题就会出现过多的回归测试。
自底向上增殖方式：
优点：不需要建立桩模块，建立驱动模块要比建立桩模块要简单得多，同时涉及到算法已近输入输出的模块要先测试，把最容易出现问题的部分在早期解决。
缺点：程序一直未能作为一个实体存在，直到最后一个模块加上才能形成一个实体,控制方面最后才能接触。
三、集成测试完成的标志：
1、成功执行了测试计划中规定的所有集成测试
2、修改了所发现的错误
3、测试结果通过专门小组的评审
4、集成测试需要提交的测试报告：
5、集成测试计划、集成测试规格说明书以及集成测试分析报告
四、集成测试策略： 1) 大爆炸集成 2) 自顶向下集成 3) 自底向上集成 4) 三明治（混合式）集成 5) 基干集成 6) 分层集成 7) 基于功能的集成 8) 基于消息的集成 9) 基于进度的集成 10) 基于风险的集成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7c5fa88bbabcac0b53f05d30d843de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75d7a51082c67f0ab28f28ac66bfbe2/" rel="bookmark">
			hive中提高代码运行效率的参数配置及代码优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天整理下平时hive中用以提高代码运行效率的几个参数，和大家分享一下：
1、set mapreduce.map.memory.mb=5120;
此参数是设置每个map使用内存的大小，默认1024M，这个参数是控制map数量的关键参数。如果需要处理的文件较多或 较大时，则分开处理效率会较快，如果文件较少或较小时会造成map资源的浪费。 2、set mapreduce.reduce.memory.mb=10240;
此参数是每个MapReduce作业的reduce任务可申请的内存资源数量，默认1024M，这个参数是控制reduce数量的关键参数。 3、set mapreduce.map.java.opts=-Xmx4096m;
在执行map任务的时发生java heap space问题任务会被杀掉。其可以配置比mapreduce.map.memory.mb的内存还要大，当 设置的比物理可用内存还要大时，会使用虚拟内存。当设置内存数大于虚拟可用内存时会因为申请了超过门限的内存而被 yarn干掉。 4、set mapreduce.reduce.java.opts =-Xmx9000m;
这个参数设置同set mapreduce.map.java.opts 5、set mapreduce.task.timeout=1800000;
这个参数主要是控制job执行的时间。 6、set hive.exec.parallel=true;
此参数是开启并发执行。当某个job中可能含有众多的阶段，其中某些没有依赖关系的阶段可以并发执行，开启并发执行后job 任务可以更快的完成。 7、在执行hive SQL进行多个表连接时，应是小表连大表。原因是：hive在对每行记录操作时会把其他表先缓存起来，直到扫描 最后的表进行计算。
8、在使用三个以上的表进行join操作时，如果每个on使用相同的字段连接时只会产生一个MapReduce。
9、在执行SQL时如用distinct进行去重时，应尽量避免而选择groupby来进行替代。
10、当遇到一个大表去连接一个小表时，可以使用mapjoin将小表加载到内存中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660ef22f3844b1ffa407639c8cc24742/" rel="bookmark">
			input输入框禁止修改的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单：
&lt;form action="form_action.asp" method="get"&gt;
&lt;input type="text" name="fname" /&gt;
&lt;input type="text" name="lname" disabled="disabled"/&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
其他其它办法：
1. &lt;input type="text" value="哈哈哈" readonly="readonly"&gt;
2. &lt;input type="text" value="哈哈哈" disabled="disabled"&gt;
3. &lt;input type="text" maxlength="0"&gt;
4. &lt;input type="text" value="哈哈哈" οnfοcus="this.blur();"&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02caa99bc80cadc4492edffda275725/" rel="bookmark">
			文件权限chmod与chown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件权限:
r: read 读
w：write 写
x: exe 可执行
d: 文件夹
l: 链接文件
-: 普通文件
b: block 块设备
c: char 字符设备
用户 用户所属组的其他用户 其他任何用户
user group other all 所有用户
chmod [ugoa] [±=] [rwx] 文件或文件夹
设置文件权限：
chmod u+w b.txt 当前用户添加写权限
chmod g+w,o+w b.txt 给组内其他用户添加写和other用户添加xie权限
chmod a=rw b.txt 所有用户添加 读写权限
chmod o-rw b.txt 删除其他用户的读写权限
八进制方式:
r : 4
w : 2
x : 1
6 4 4
4+2
user group other
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02caa99bc80cadc4492edffda275725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1af5da3c54d7d523c89e735cc4005a/" rel="bookmark">
			linux Ubuntu终端快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终端操作快捷键:
Tab 自动补全
Ctrl+a 光标移动到开始位置
Ctrl+e 光标移动到最末尾
Ctrl+k 删除此处至末尾的所有内容
Ctrl+u 删除此处至开始的所有内容
Ctrl+d 删除当前字符
Ctrl+h 删除当前字符前一个字符
Ctrl+w 删除此处到左边的单词
Ctrl+y 粘贴由 Ctrl+u ， Ctrl+d ， Ctrl+w 删除的单词
Ctrl+l 相当于clear，即清屏
Ctrl+r 查找历史命令
Ctrl+b 向回移动光标
Ctrl+f 向前移动光标
Ctrl+t 将光标位置的字符和前一个字符进行位置交换
Ctrl+&amp; 恢复 ctrl+h 或者 ctrl+d 或者 ctrl+w 删除的内容
Ctrl+S 暂停屏幕输出
Ctrl+Q 继续屏幕输出
Ctrl+Left-Arrow 光标移动到上一个单词的词首
Ctrl+Right-Arrow 光标移动到下一个单词的词尾
Ctrl+p 向上显示缓存命令
Ctrl+n 向下显示缓存命令
Ctrl+d 关闭终端
Ctrl+xx 在EOL和当前光标位置移动
Ctrl+x@ 显示可能hostname补全
Ctrl+c 终止进程/命令
Shift +上或下 终端上下滚动
Shift+PgUp/PgDn 终端上下翻页滚动
Ctrl+Shift+n 新终端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be1af5da3c54d7d523c89e735cc4005a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fac855e7d256fc5a9c3b98dc7971225/" rel="bookmark">
			MongoDB tar包安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB tar包安装 2019年01月08日 11:31:57 qq_35285375 阅读数 141
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/qq_35285375/article/details/86062078
1、登录mongodb官网，下载安装包
https://www.mongodb.com/download-center/community
2.解压
tar -zxvf mongodb-linux-x86_64-amazon-3.6.9.tgz 3.修改文件夹名称
mv mongodb-linux-x86_64-amazon-3.6.9 mongodb
4、在/usr/local/mongodb下创建文件
mkdir -p data/db
mkdir logs
5、在/usr/local/mongodb/bin下新建配置
vi mongodb.conf
dbpath = /usr/local/mongodb/data/db
logpath = /usr/local/mongodb/logs/mongodb.log
port = 27017
fork = true
6、环境变量配置
vi /etc/profile
export MONGODB_HOME=/usr/local/mongodb
export PATH=$PATH:$MONGODB_HOME/bin
#保存后，重启系统配置
source /etc/profile
7、在/usr/local/mongodb/bin下
mongod -f mongodb.conf 或 ./mongod -f mongodb.conf
转载于:https://my.oschina.net/u/3367404/blog/3103016
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2e934e8ee6828eaaf28e7f8713ee14/" rel="bookmark">
			如何将多个文件夹中的文件合并到一个文件夹中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Question to say "I can!" 如何将多个文件夹中的文件合并到一个文件夹中 2011-11-27 这个算是小小的技巧吧！有两种方法，一种是传统的命令行，另一种是用搜索。
1.问：我下载了一个书籍的压缩包，可是有许多文件夹，但每个文件夹只有一个txt文件。我怎么把他们一次合并到一个文件夹？
答：把你解压后的文件夹，放在D盘的根目录下，文件夹命名为 1 然后 按下面做，开始--运行--输入CMD 回车 在提示符里面输入： for /r d:\1 %f in (*.txt) do copy "%f" d:\1 回车 就行了。它会把你的TXT文档复制到1这个文件夹下。这个前提是各个文件夹中的TXT文档，不能有重命的。
2.问：我下载了一系列壁纸，有30个文件夹，每个里面有2副图片，怎么把这些图片整到一个文件夹中啊，别给我说一个一个剪切？
答：先把他们移动到一个大的文件夹下面，然后用搜索，包含文字为 .JPG 也就是你图片的格式，他就会把所有的图片全部找出来，然后一次性剪切与粘贴。这样就出来了。
显示，第二种会方便一些。
转载于:https://www.cnblogs.com/zhou0818/p/11505850.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c5e2abcdc80d003ef3f93a2612b6d5/" rel="bookmark">
			支付宝支付(2)之公钥证书方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇介绍了最常用的普通公钥方式整合app支付宝支付,此篇主要介绍公钥证书方式，实际项目中因为业务的特殊性两种支付方式统一用同一套接口，根据不同参数对差异部分进行区分，这里为更清楚的介绍整合方法便提炼出另一套接口，大同小异，可以根据实际情况处理：
支付宝支付(1)之普通公钥方式
一、签名 参考链接：https://docs.open.alipay.com/291/105971/
跟上一篇不同的是这次选择公钥证书方式：
按照文档一步步就可以生成公钥证书及私钥等相关文件
需要将这三个文件上传到服务器，使用中都是使用的文件根路径
依赖跟工具类等其他文件跟普通公钥一样，这里无需再重复，直接上重点
二、生成APP支付订单信息 //构造client CertAlipayRequest certAlipayRequest = new CertAlipayRequest(); //设置网关地址 certAlipayRequest.setServerUrl("https://openapi.alipay.com/gateway.do"); //设置应用Id certAlipayRequest.setAppId(app_id); //设置应用私钥 certAlipayRequest.setPrivateKey(privateKey); //设置请求格式，固定值json certAlipayRequest.setFormat("json"); //设置字符集 certAlipayRequest.setCharset(charset); //设置签名类型 certAlipayRequest.setSignType(sign_type); //设置应用公钥证书路径 certAlipayRequest.setCertPath(app_cert_path); //设置支付宝公钥证书路径 certAlipayRequest.setAlipayPublicCertPath(alipay_cert_path); //设置支付宝根证书路径 certAlipayRequest.setRootCertPath(alipay_root_cert_path); //构造client AlipayClient alipayClient = new DefaultAlipayClient(certAlipayRequest); //实例化具体API对应的request类,类名称和接口名称对应,当前调用接口名称：alipay.trade.app.pay AlipayTradeAppPayRequest request = new AlipayTradeAppPayRequest(); //SDK已经封装掉了公共参数，这里只需要传入业务参数。以下方法为sdk的model入参方式(model和biz_content同时存在的情况下取biz_content)。 AlipayTradeAppPayModel model = new AlipayTradeAppPayModel(); model.setBody("我是测试数据"); model.setSubject("App支付测试Java"); model.setOutTradeNo(outtradeno); model.setTimeoutExpress("30m"); model.setTotalAmount("0.01"); model.setProductCode("QUICK_MSECURITY_PAY"); request.setBizModel(model); request.setNotifyUrl("商户外网可以访问的异步地址"); try { //这里和普通的接口调用不同，使用的是sdkExecute AlipayTradeAppPayResponse response = alipayClient.sdkExecute(request); System.out.println(response.getBody());//就是orderString 可以直接给客户端请求，无需再做处理。 } catch (AlipayApiException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c5e2abcdc80d003ef3f93a2612b6d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9301db3725e564816f97b69b4a1be935/" rel="bookmark">
			在本地数据库目录或系统数据库目录中已经存在数据库别名&#34;*&#34;的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原博客连接:https://www.cnblogs.com/sideny/p/3382613.html 在创建数据库时遇到数据库别名已存在的问题时,如图:
可以尝试这样解决:
1. 首先用命令查看在系统数据库目录（System Database Directory）中有没有该数据库，如果有，应该在确定该数据库是没有用的数据库之后用 db2 drop database 数据库名将其删除。
&lt;!-- 看在系统数据库目录（System Database Directory）中有没有该数据库 --&gt; db2 list database directory &lt;!-- 存在的话就执行下面指令 --&gt; db2 drop database 数据库名 2. 如果没有，再用 db2 list database directory on 数据库所在目录 看在本地数据库目录（Local Database Directory）中有没有该数据库，location指定数据库的位置（如Windows下的C: ,Unix下的/home/db2inst1）。如果有，先用 db2 catalog database 数据库名 on location将数据库编目到节点上，再对其进行删除处理。
整体解决过程:
1.首先用db2 list database directory查看系统数据库目录，为空，说明不在系统数据库目录中。 2.在用db2 list database directory on location(这里是盘符c:，先尝试用localhost和127.0.0.1都不识别)，然后发现有sample和source的别名。说明在本地数据库目录中。 3.catalog database source on c: 4.drop database source 5.catalog database sample on c: 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9301db3725e564816f97b69b4a1be935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a15b448773cc331fbfc520628f1f14a/" rel="bookmark">
			php单用户登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理：同一账号在多个设备上登录，前者被后者顶下线；假设账号在设备A登录，该账号又在设备B登录，此时设备A登录的账号被顶下线
思路分析
1、用户登录成功后将当前时间存入session中，以及制作个token值存入该用户数据库中；
2、在验证用户是否登录的模块中，若用户已登录，将用户数据库中的token取出，并且制作一个最新的token，两者判断是否相等，若不相等，用户下线；
代码实现
1、在登录成功的代码模块下操作；
// 登录验证 $user = DB::table('user')-&gt;where(['username' =&gt; 账号, 'password' =&gt; 密码])-&gt;first(); if ($user) { # 登录成功 $time = time(); $token = md5($user['id'].$time); // 制作 token 用md5加密 DB::table('user')-&gt;where(['id'=&gt;$user['id']])-&gt;update(['token' =&gt; $token]);//将token存入当前用户数据中 session(['token_time'=&gt;$time]);//将当前时间存入session中 session(['user'=&gt;$user]);//将用户信息存入session中 } else { # 登录失败逻辑处理 } 2、在判断用户是否已经登录的代码模块下操作；
$userInfo = session('user');//从session中获取用户信息 if ($userInfo) { # 存在用户信息 $token_time = session('token_time');//从session中获取time $last_token = md5($userInfo['id'].$token_time);//制作当前的token值 $token=DB::table('user')-&gt;where('id', $userInfo['id'])-&gt;value('token');//获取该用户数据中的token if($last_token!=$token){ //若当前的token值与数据中的token值不相等，则将用户信息清空，用户被顶下线 $userInfo=null; } }else{ # 不存在用户信息逻辑处理（跳转到登录界面） } 原文：添加链接描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8126c534b040c555227cfb9deb2ba3bd/" rel="bookmark">
			java基础 —— System类的概述和方法使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System类的概述和方法使用 A:System类的概述 System 类包含一些有用的类字段和方法。它不能被实例化。 B:成员方法 public static void gc()public static void exit(int status)public static long currentTimeMillis()pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) C:案例演示 System类的成员方法使用 2.System类常用的方法：
(1) arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
①参数详解：
src：原数组。 srcPos：原数组中的起始位置，也就是从原数组的哪一位开始拷贝。 dest：目标数组。 destPos：目标数据中的起始位置，也就是从目标数组的哪一个位置开始存储要拷贝的元素。 length：要复制的数组元素的数量。 public class Demo1 { public static void main(String[] args) { int[] srcArr = {10,12,14,16,19}; //把srcArr的数组元素拷贝 到destArr数组中。 int[] destArr = new int[4]; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8126c534b040c555227cfb9deb2ba3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da15157b54b01251c5e532e22f56bd15/" rel="bookmark">
			sql语句练习50题(Mysql版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表名和字段
–1.学生表 Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别 –2.课程表 Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号 –3.教师表 Teacher(t_id,t_name) –教师编号,教师姓名 –4.成绩表 Score(s_id,c_id,s_score) –学生编号,课程编号,分数
测试数据
--建表 --学生表 CREATE TABLE `Student`( `s_id` VARCHAR(20), `s_name` VARCHAR(20) NOT NULL DEFAULT '', `s_birth` VARCHAR(20) NOT NULL DEFAULT '', `s_sex` VARCHAR(10) NOT NULL DEFAULT '', PRIMARY KEY(`s_id`) ); --课程表 CREATE TABLE `Course`( `c_id` VARCHAR(20), `c_name` VARCHAR(20) NOT NULL DEFAULT '', `t_id` VARCHAR(20) NOT NULL, PRIMARY KEY(`c_id`) ); --教师表 CREATE TABLE `Teacher`( `t_id` VARCHAR(20), `t_name` VARCHAR(20) NOT NULL DEFAULT '', PRIMARY KEY(`t_id`) ); --成绩表 CREATE TABLE `Score`( `s_id` VARCHAR(20), `c_id` VARCHAR(20), `s_score` INT(3), PRIMARY KEY(`s_id`,`c_id`) ); --插入学生表测试数据 insert into Student values('01' , '赵雷' , '1990-01-01' , '男'); insert into Student values('02' , '钱电' , '1990-12-21' , '男'); insert into Student values('03' , '孙风' , '1990-05-20' , '男'); insert into Student values('04' , '李云' , '1990-08-06' , '男'); insert into Student values('05' , '周梅' , '1991-12-01' , '女'); insert into Student values('06' , '吴兰' , '1992-03-01' , '女'); insert into Student values('07' , '郑竹' , '1989-07-01' , '女'); insert into Student values('08' , '王菊' , '1990-01-20' , '女'); --课程表测试数据 insert into Course values('01' , '语文' , '02'); insert into Course values('02' , '数学' , '01'); insert into Course values('03' , '英语' , '03'); --教师表测试数据 insert into Teacher values('01' , '张三'); insert into Teacher values('02' , '李四'); insert into Teacher values('03' , '王五'); --成绩表测试数据 insert into Score values('01' , '01' , 80); insert into Score values('01' , '02' , 90); insert into Score values('01' , '03' , 99); insert into Score values('02' , '01' , 70); insert into Score values('02' , '02' , 60); insert into Score values('02' , '03' , 80); insert into Score values('03' , '01' , 80); insert into Score values('03' , '02' , 80); insert into Score values('03' , '03' , 80); insert into Score values('04' , '01' , 50); insert into Score values('04' , '02' , 30); insert into Score values('04' , '03' , 20); insert into Score values('05' , '01' , 76); insert into Score values('05' , '02' , 87); insert into Score values('06' , '01' , 31); insert into Score values('06' , '03' , 34); insert into Score values('07' , '02' , 89); insert into Score values('07' , '03' , 98); 表数据如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da15157b54b01251c5e532e22f56bd15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e132a51cd0486351ec6ed03f2b40be/" rel="bookmark">
			go语言解析 map[string]interface{} 数据格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意事项
map记得分配内存
解析出来的int类型会变成float64类型
注意判断不为nil后再转换类型
package main
import (
"fmt"
"encoding/json"
)
func main() {
var m map[string]interface{} //声明变量，不分配内存
m = make(map[string]interface{}) //必可不少，分配内存
m["name"] = "simon"
var age int = 12
m["age"] = age
m["addr"] = "China"
print_map(m)
fmt.Println()
data, err:=json.Marshal(m)
fmt.Println("err:", err)
fmt.Println(data)
fmt.Println()
m1 := make(map[string]interface{})
err = json.Unmarshal(data, &amp;m1)
fmt.Println("err:", err)
fmt.Println(m1)
print_map(m1)
fmt.Println()
if m1["name"]!= nil {
fmt.Println(m1["name"].(string))
}
if m1["type"]!= nil {
fmt.Println(m1["type"].(string))
} else {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e132a51cd0486351ec6ed03f2b40be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4d95a89eb5f21d0819b877badc281dd/" rel="bookmark">
			数据更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据更新 一、 插入数据1. 插入元组2. 插入子查询结果 二、修改数据1. 修改某一个元组的值2. 修改多个元组的值3. 带子查询的修改语句 三、删除数据1. 删除某一个元组的值2. 删除多个元组的值3. 带子查询的删除语句 一、 插入数据 SQL 的数据插入语句 insert 通常有两种形式，一种是插入一个元组，另一种是插入子查询结果。后者可以一次插入多个元组。
1. 插入元组 插入元组的 insert 语句格式为
insert into &lt;表名&gt; [(&lt;属性列 1&gt;[,&lt;属性列 2&gt;]...)] values (&lt;常量 1&gt;[,&lt;常量 2&gt;]...); 其功能是将新元组插入指定表中。其中新元组的 属性列1 的值为 常量1 ，属性列2 的值为 常量2 ，…
into 子句中没有出现的属性列，新元组在这些列上将取空值，但必须注意的是，在表定义时说明了 not all 的属性列不能取空值，否则会出错
如果 into 子句中没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值
例1：将一个新学生元组 （学号：201215128，姓名：陈东，性别：男，所在系：CS，年龄：18）插入到 Student 表中。 insert into Student (Sno,Sname,Ssex,Sdept,Sage) values ('201215128','陈东','男','CS',18); 在 into 子句中指出了表名 Student ，并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与 create table 时表的顺序（建表时列的顺序）不一样，values 子句对新元组的各属性赋值，字符串常数要用单引号（英文符号）括起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4d95a89eb5f21d0819b877badc281dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff38ab0024f7d4c664cbf5d3d29b74e3/" rel="bookmark">
			介绍Jackson JsonNode和ObjectNode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍Jackson JsonNode和ObjectNode Jackson JsonNode类，完整路径为com.fasterxml.jackson.databind.JsonNode，是Jackson的json树模型(对象图模型)。Jackson能读JSON至JsonNode实例，写JsonNode到JSON。本文不涉及json序列化或反序列化，主要介绍如何从头构建JsonNode对象图，之后你可以序列化为json。
1. JsonNode vs. ObjectNode The Jackson JsonNode对象不可变，这意味着不能直接构建JsonNode实例的对象图，但你可以创建JsonNode 的子类ObjectNode实例的对象图。作为JsonNode 的子类，ObjectNode可以在任何使用了JsonNode之处使用。后面你会看到如何构建ObjectNode对象图。
2. 操作JsonNode 2.1. 从json中读JsonNode 为了使用Jackson读json为JsonNode，需要创建Jackson ObjectMapper 实例。然后调用其readTree()方法，使用源json作为参数，请看示例：
String json = "{ \"f1\" : \"v1\" } "; ObjectMapper objectMapper = new ObjectMapper(); JsonNode jsonNode = objectMapper.readTree(json); System.out.println(jsonNode.get("f1").asText()); 实际项目中ObjectMapper不应每次都创建，比如从spring容器中注入。
2.2. 写JsonNode至json 使用Jackson写JsonNode至json，也需要ObjectMapper对象。调用writeValueAsString()方法，或其他适合你的写方法(writeValue)，请看示例：
ObjectMapper objectMapper = new ObjectMapper(); JsonNode jsonNode = readJsonIntoJsonNode(); String json = objectMapper.writeValueAsString(jsonNode); readJsonIntoJsonNode()方法是我创建用于解析json字符串值JsonNode的方法，为了生成JsonNode去写。该方法抽取内容在本例中不是重点，你仅需了解产生了一个JsonNode对象。重要的是调用了ObjectWriter的writeValueAsString()方法将JsonNode写入JSON字符串。ObjectMapper提供了很多写方法，用于不同目的写操作，读者可以查看相应文档或源码。
2.3. 获取JsonNode 字段 和json对象一样，JsonNode可以多个字段。假设我们解析下面json值JsonNode:
{ "field1" : "value1", "field2" : 999 } json有两个字段，如果你用jsonNode表示上面json对象，则可以获得其两个字段：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff38ab0024f7d4c664cbf5d3d29b74e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2782a3767c3e68835091cde49a01a18c/" rel="bookmark">
			ArcGIS统计各面块中点的平均值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以面状渔网为例
目的：统计渔网中各个面所包含的点的某一字段的平均值，如下图所示
工具：分析工具—&gt;统计分析—&gt;交集制表
计算到这一步，通过属性表“添加字段”、“字段计算器”即可求得平均值~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c405c327ed184f12de91469c3d24ef30/" rel="bookmark">
			vue的$message（提示框换行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直在搜怎么让提示框的文字换行，网上搜到的基本都是使用 ‘ /n ’,使用无效，也试了css换行，本来想用弹窗自己编辑html内容，还好回去官网看了一下；
let arr = ['测试一', '测试二', '测试三']; let str = arr.join(' &lt;br/&gt; '); this.$message({ dangerouslyUseHTMLString: true, message: str, type: 'warning' }); 使用上面简单的属性 dangerouslyUseHTMLString: true,就可以实现换行； 喝水不忘挖井人，感谢element ui 真的方便； 随笔小记 长点记性； 转载于:https://www.cnblogs.com/wangxiaoer5200/p/11491816.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd452a5ad54ed9448322cd074be07830/" rel="bookmark">
			Mongoose 增删改查 --------删
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里提供三种方案来实现 删除数据 //第一种方案 通过manModel上的remove()来删除数据 //Model.remove(conditions, [callback])
var mongoose = require('mongoose')
mongoose.connect('mongodb://127.0.0.1:27017/vue-admin',function(err){
if(err){
console.log('数据库连接失败')
}else{
//数据库连接成功
var schema = new mongoose.Schema({name:String,age:Number});
var manModel = mongoose.Model('manModel',schema);
manModel.remove(function(err){
//删除所有数据
})
}
})
//第二种方案 通过manModel上的deleteOne()来删除数据
//Model.deleteOne(conditions, [callback])
var mongoose = require('mongoose')
mongoose.connect('mongodb://127.0.0.1:27017/vue-admin',function(err){
if(err){
console.log('数据库连接失败')
}else{
//数据库连接成功
var schema = new mongoose.Schema({name:String,age:Number});
var manModel = mongoose.Model('manModel',schema);
manModel.deleteOne({name:'xmgdty'},function(err){
//删除符合条件的第一个数据
})
}
})
//第三种方案 通过文档的remove()方法来删除数据
//doc.remove([callback])
var mongoose = require('mongoose')
mongoose.connect('mongodb://127.0.0.1:27017/vue-admin',function(err){
if(err){
console.log('数据库连接失败')
}else{
//数据库连接成功
var schema = new mongoose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd452a5ad54ed9448322cd074be07830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e947457c76cab0a9c5a27b1795e0ac/" rel="bookmark">
			进阶的爬虫系列 ——贴吧爬取术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进阶的爬虫系列
——不得不说的贴吧爬取术
感谢各位能点开我的这篇博文，才开始写，这个算是很简单的爬虫，文中如有错误和不足欢迎各位大神多多包涵指正，大家的建议是我不断前行的动力，废话不多说我们直接进入主题。
目标：爬取贴吧数据 步骤： 首先我们进入百度贴吧的页面，通过进入不同的贴吧以及翻页解析其url的变化规律 通过观察我们可以看出 “kw=”的后面是接的贴吧的名字，而“pn=”的后面是接的页数，从0开始，每翻一页pn对应的数值会加50。发现规律以后我们就可以通过url中贴吧名字及页数这两个点用循环遍历爬取页面数据。
然后我们明确业务逻辑: 定义一个类——&gt;初始化——&gt;构造url列表——&gt;遍历，发送请求，获取响应——&gt;保存 根据业务逻辑构建初始代码如下：
# coding=utf-8
class Tieba:
def __init__(self,tieba_name):
self.url_temp ="https://tieba.baidu.com/f?kw=" + tieba_name + "&amp;ie=utf-8&amp;pn={}"
self.headers = {
"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36"
}
def get_url_list(self):
# 构造url列表
pass
def parse_url(self,url):
# 发送请求，获取响应
pass
def save_html(self,html_str,page_num):
# 保存html字符串
pass
def run(self):#实现主要逻辑
#1.构造url列表
#2.遍历，发送请求，获取响应
#3.保存
pass
if __name__ == '__main__':
tieba = Tieba('李毅')
tieba.run()
1.初始化url路径，和请求头
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e947457c76cab0a9c5a27b1795e0ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6099c0a105b4918da61f1eaff301264a/" rel="bookmark">
			[转]计算机四级网络工程师思维导图--常考重点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文在我的博客原文链接：https://sublimerui.top/archives/767f2af2.html
计算机四级网络工程师考试快开始了。
这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~
此部分为整体归纳出来的常考重点~
相关总结链接（更细致具体），点这里喔~：
[转]计算机四级网络工程师思维导图–操作系统部分[转]计算机四级网络工程师思维导图–计算机网络部分 PS:
思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~图片高清，但文字较小也很长，可以点击图片后放大学习哦~ 一、操作系统 二、计算机网络 感谢你的耐心阅读呀(๑◡๑)，总结不易，收藏点个赞呗~
你的支持就是我前进的动力呀~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321f7ce0330a14883562a229b1acb96c/" rel="bookmark">
			c#同时上传文件和参数，Java接收的完整教程，炒鸡简单！网上的教程弱爆了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作需求，需要在c#端将文件和数据进行上传，Java端接收文件上传到oss，将数据处理到数据库。
这个教程，秒杀市面百分九十九的帖子，绝对是楼主精心打造！
一、网上的一般做法 网上搜出来的教程，基本都是只上传文件的，但对于如何把数据和文件一起上传，那能找到的资料就很少了，不过不管是单独传文件，还是文件带数据，原理都一样，都是模拟浏览器行为，构造请求头和请求参数上传，对于带文件的，需要指定contentType，然后通过流的方式进行上传。
这种方法，不是很方便，因为既要带文件，又要带数据，尤其如果数据是跟文件相关的时候，不好处理，Java中数据的接收方法如下:
c#中的发送数据如下：
1.完整的c#代码如下： using System; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Net; using System.Text; using NUnit.Framework; using System.Drawing; namespace TestProject1 { /// &lt;summary&gt; /// 实现文件和参数一起提交 /// &lt;/summary&gt; public static class FormUpload { /// &lt;summary&gt; /// 字符编码格式 /// &lt;/summary&gt; private static readonly Encoding encoding = Encoding.UTF8; private const string DefaultUserAgent = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"; public static String ImageFile2Base64(String imageFile) { Image image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/321f7ce0330a14883562a229b1acb96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c5b6f6b3cd8d9616980a276370213b/" rel="bookmark">
			MQTT抓包数据及分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT抓包数据及分析 最近在使用MQTT对接云平台，由于之前一直没有接触过MQTT，网上的找的资料大部分都只是通过文字来进行表述的，对我这种小白来说说，总感觉不够直观，因此特地汇总了我从网上找的一些资料，通过Wireshark抓取本地数据包来分析MQTT协议。
以下是我找到的一些资料的连接，感谢诸位。
1、[MQTT中文文档]：(https://blog.csdn.net/xuwenwen_2013/article/details/78912362)
2、[通过wireshark抓取本地数据包]：(https://www.cnblogs.com/lidabo/p/8024218.html)
3、EQM的安装
4、MQTT.fx的使用
这些工具可以去对应的链接中获取，在我的下载中也打包了所有的工具，分析的MQTT版本为MQTTV3.1.1.1,具体的协议格式和协议说明可以查看相关资料，这里只展示wireshark的抓包数据和数据的解析。
以下是具体的数据包和对应的wireshark的协议解析
1、连接请求
2、连接应答
3、主题订阅：
4、主题订阅回应
5消息发布
6 消息发布应答
7、消息接收：
8、消息释放
9发布完成
10、断开连接：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409615bf22da09a4640f6781f964cc67/" rel="bookmark">
			android架构组件之paging源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RecyclerView使用paging就是多了对数据的拉取，使得RecyclerView的数据和显示更加的解耦，RecyclerView对paging的使用多了如下几步：
instance = CustomAdapter.getInstance(this); factory = new CustomPageDataSourceFactory&lt;&gt;(); build = new LivePagedListBuilder&lt;Integer, String&gt;(factory, new PagedList.Config.Builder().setPageSize(20).setInitialLoadSizeHint(20) .setPrefetchDistance(3).build()).setInitialLoadKey(4).build(); build.observe(this, it -&gt; instance.submitList(it)); 也就是将数据设置到adapter中，看到这，我们该想paging的源码该从哪里入手呢？想想就应该知道应该是从LivePagedListBuilder入手，好的，那就从LivePagedListBuilder的build（）方法中去看看：
LivePagedListBuilder的build()方法：
public LiveData&lt;PagedList&lt;Value&gt;&gt; build() { return create(mInitialLoadKey, mConfig, mBoundaryCallback, mDataSourceFactory, ArchTaskExecutor.getMainThreadExecutor(), mFetchExecutor); } 就是简单调用了它的create()方法，那就看下它的create（）方法：
private static &lt;Key, Value&gt; LiveData&lt;PagedList&lt;Value&gt;&gt; create( @Nullable final Key initialLoadKey,//ItemKeyedDataSource会用到 @NonNull final PagedList.Config config,//加载数据时的一些配置信息，比如初始加载多少，每页加载多少 @Nullable final PagedList.BoundaryCallback boundaryCallback, @NonNull final DataSource.Factory&lt;Key, Value&gt; dataSourceFactory, @NonNull final Executor notifyExecutor, @NonNull final Executor fetchExecutor//获取数据的线程池) { return new ComputableLiveData&lt;PagedList&lt;Value&gt;&gt;(fetchExecutor) { @Nullable private PagedList&lt;Value&gt; mList; @Nullable private DataSource&lt;Key, Value&gt; mDataSource; private final DataSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409615bf22da09a4640f6781f964cc67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53635893aedfee77ae8a083bdfe940cf/" rel="bookmark">
			Go1.13 errors包用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go1.13 errors包用法 go 1.13 加入了 errors 包,主要有:
AsIsNewUnwrap 定义 As(err error, target interface{}) bool 在err的链中找到与目标匹配的第一个错误，如果有则返回true，否则返回false
Is(err error, target error) bool 判断两个error是否相等
New(text string) error 返回一个新的error对象，即使内容一样也是两个不同的对象
Unwarp(err error) error 如果传入的err对象中有%w关键字的格式化类容，则会在返回值中解析出这个原始error，多层嵌套只返回第一个，否则返回nil
示例代码 package main import ( "errors" "fmt" "os" ) func main() { // As fmt.Println("-------As--------") if _, err := os.Open("non-existing"); err != nil { var pathError *os.PathError if errors.As(err, &amp;pathError) { fmt.Println("Failed at path:", pathError.Path) } else { fmt.Println(err) } } // New fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53635893aedfee77ae8a083bdfe940cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d36028f619dcf7a7c9eaee7f33b9916/" rel="bookmark">
			烟花完整版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #container{ width: 80%; height: 600px; border: 2px solid red; background: #000; margin:20px auto; cursor: pointer; position: relative; left: 0; top: 0; overflow: hidden; } .fire{ width: 10px; height:10px; position: absolute; bottom: 0; } .small-fire{ width: 10px; height:10px; position: absolute; border-radius: 50%; } &lt;/style&gt; &lt;script src="../public.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; // for(){ // ali[i] = i // ali[i].onclick = function(){ // this // } // } // 范围随机数 function Fire(options) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d36028f619dcf7a7c9eaee7f33b9916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f916d69c2985e3ada5b11c3c81d9e6e/" rel="bookmark">
			qt  tableview中setModel()报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "openhistogram.h" OpenHistogram::OpenHistogram(QWidget *parent) : QWidget(parent) { ui.setupUi(this); init_histogram(); } OpenHistogram::~OpenHistogram() { if (thresholdParam) { delete thresholdParam; } } int OpenHistogram::init_histogram() { thresholdParam = new QStandardItemModel(this); thresholdParam-&gt;setColumnCount(5); //设置参数表为2行 thresholdParam-&gt;setHeaderData(0, Qt::Horizontal, QString("select algorthm")); thresholdParam-&gt;setHeaderData(1, Qt::Horizontal, QString("min")); thresholdParam-&gt;setHeaderData(2, Qt::Horizontal, QString("max")); thresholdParam-&gt;setHeaderData(3, Qt::Horizontal, QString("other")); thresholdParam-&gt;setRowCount(2); thresholdParam-&gt;setHeaderData(1,Qt::Vertical,QString("algorthm")); QStandardItem *cur_item = new QStandardItem[2]; //设置参数表为5列 ui.thresholdParaView-&gt;setModel(thresholdParam); return 1; } ui.thresholdParaView-&gt;setModel(thresholdParam);
这一行会报错，可能有三方面导致
1、 ui.setupUi(this);要写在 init_histogram();之前
2、 要对thresholdParam 实例化
3、 要对thresholdParam 释放
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/228/">«</a>
	<span class="pagination__item pagination__item--current">229/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/230/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>