<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612d03c6444ca1be301c3d73f223ecfa/" rel="bookmark">
			【C# 窗体 超市购物买单系统】简单版和进阶版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C# 窗体 超市购物买单系统】 简单版 功能简介：
填入商品，显示在 DataGridView 表格里面添加按钮，通过 单价 * 数量 ，计算消费金额输入付款金额，完成支付按钮计算 实付 和 找零 界面展示：
DataGridView 显示界面设置
点击添加修改页眉 和 名称右边 Width 设置单列展示宽度（逐一设置） 代码展示:
public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button2_Click(object sender, EventArgs e) { float cost = float.Parse(textBox4.Text.Trim()); label9.Text = Convert.ToString(cost); if (cost &gt;= sum) { cost -= sum; label7.Text = Convert.ToString(cost); } else MessageBox.Show("金额不足", "warning", MessageBoxButtons.OK, MessageBoxIcon.Information); } int k = 0; float sum = 0; private void button1_Click(object sender, EventArgs e) { if (textBox1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612d03c6444ca1be301c3d73f223ecfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9876d8158378bd1bdbedbc932ee5ce1a/" rel="bookmark">
			npm（yarn）安装及问题小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装node1.下载node.js 二、配置npm1.更改npm包默认存储位置2.配置代理（*）3.配置环境变量 三、yarn安装配置四、安装问题小记 前言 安装npm、yarn之前要先安装node：node —&gt; npm —&gt; yarn
一、安装node 1.下载node.js 1）下载执行安装即可：https://nodejs.org/en/
2）记住node的安装目录，最好别放C盘- -。等下有用。例如我的nodejs的安装目录是：E:\nodejs
3）查看安装是否成功：
node -v 成功会显示版本号：
二、配置npm 1.更改npm包默认存储位置 可以不更改，默认全局仓库就是存在C盘：C:\Users\Administrator\AppData\Roaming\npm 但是，随着npm下载模块的增多，挤占C盘空间啊喂0.0，所以如果C盘空间不充足，建议修改。
假设我的nodejs的安装目录是：E:\nodejs
首先在 E:\nodejs 下新建两个文件夹
node_global
node_cache更改全局仓库、依赖包缓存位置为我们设置的文件夹
命令行执行：
a. 设置全局仓库位置： npm config set prefix "E:\nodejs\node_global" b. 设置默认缓存位置：
npm config set cache "E:\nodejs\node_cache" 查看设置是否成功 a. 命令行输入，查看全局仓库位置：
npm list -global 设置正确，则会显示你更改过后的目录下，且下面列表为 empty
b. 然后命令行继续操作，全局安装随便一个包
npm install express -g c.再命令行输入，查看全局仓库位置，及缓存的包：
npm list -global 设置正确，则会显示你更改过后的目录下，且下面列表中有 express 这个包
2.配置代理（*） 如果你上网不需要代理proxy，请略过此处 = =。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9876d8158378bd1bdbedbc932ee5ce1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf8e133dbbf250dd8885b1b2fef2f1eb/" rel="bookmark">
			servlet请求的转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、请求的转发 在服务器里面资源跳转的方式。将请求再转发到其他地址，转发过程中使用的是同一个request请求，转发后浏览器地址栏内容不变。 请求转发的过程发生在服务器内部，只能从当前应用内部查找相应的转发资源，而不能转发到其它应用的资源。
转发时(共享同一个request和response)，两个servlet的访问顺序，传参:
1)访问顺序: 第1个GET方式，第2个走的是doGet()。 第1个POST方式，第2个走的是doPost()。
2)在第1个servlet转发代码之后，不能再调用类似 转发或重定向 的代码。否则会500异常，因为转发之后，不能再回到此处进行跳转到别的页面
3)读取页面参数: 由于是共享同一个request，请求页面的参数在两个servlet当中都可以读取出来。---请求页面中，GET方式的参数是在地址栏中通过"?name=Jack&amp;age=22"上传,POST方式是通过&lt;input&gt;组件上传的。
4)两个servlet之间传参: 在第1个中request.setAttribute()，在第2个中request.getAttribute();
2、实现方法 转发通过方法forward(request,response)实现，他能将request对象转发到其他的servlet程序内，它能够共享request对象里面的资源。
具体实现方式如下：
req.getRequestDispatcher("/002").forward(request,response);
通过方法setAttribute（），可以将一个servlet程序内的资源转发到另一个servlet程序内，实现资源共享。
3、实例 servlet1：
public class RequestForwardServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType("text/html;charset=utf-8"); request.setAttribute("username", "周星星"); RequestDispatcher dispatcher = request.getRequestDispatcher("/ResultServlet"); dispatcher.forward(request, response); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } servlet2
public class ResultServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException { response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf8e133dbbf250dd8885b1b2fef2f1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33693f39944a7d08cb68948d437440a/" rel="bookmark">
			我的maven导入模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、javaweb阶段 （一）servlet &lt;!--ServletAPI--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; （二）数据库连接 1、jdbc &lt;!-- jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; 2、德鲁伊 &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; 3、dbutils &lt;!--dbutils--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; （三）thymeleaf &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; 二、Spring5 （一）Spring5 &lt;!--spring和th整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; （二）aspectj &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; （三）jdbc &lt;!-- jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; （四）德鲁伊 &lt;!-- druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33693f39944a7d08cb68948d437440a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e37bab6d3c49dc123eead9bb7617ba5/" rel="bookmark">
			oracle计算占比和环比增长率案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在数据库做统计分析的时候，我们可能需要结合不同的需求计算数据的汇总、平均、占比、环比、同步等等，那么在通过sql硬编码前我们是否应该考虑数据的各种问题，以及在编写代码时，我们是否应该通过各种函数进行数据预处理，避免最终预览数据时出现各种错误呢？
需求： 根据科室、时间维度分组， 对不同科室人数、科室总金额进行统计汇总，以及计算科室不同药品的使用情况 如：各药品的占比、环比增长率等等？
1)对科室、时间维度进行分组，对人数进行count,对总金额进行sum
注：使用group by +聚合函数即可（sum、count、…）等
2)对药品的使用情况 进行占比分析、环比增长率
注：药品占比分析 某类型药费用总额/费用总额 * 100
需考虑情况：某类型药费用总额 或 费用总额 为 0的情况
解读环比增长率：环比增长率=（本期数-上期数）÷上期数×100%
药品环比增长率 （本月费用总额-上月费用总额）上月费用总额*100
需考虑3种情况：
1) 本月费用总额、上月费用总额 同时为 0 如 （0-0）/0 则提示ORA-01476
2) 本月费用总额、上月费用总额 不为0但是数据相等 （1000-1000）/1000=0
3) 本月费用总额不为0、上月费用总额为0 （1000-0）/0 则提示ORA-01476
所以需要针对该3种情况进行处理，可通过case when 函数 案例基础数据准备 建表使用中文命名字段是为了方便大家阅读，实际工作情况下 不推荐此骚操作。
CREATE TABLE MY_TABLE_TEST ( "结算时间" VARCHAR2(255), "科室代码" VARCHAR2(255), "科室名称" VARCHAR2(255), "人次" NUMBER, "次均费用" NUMBER, "费用明细" NUMBER, "中药" NUMBER, "中成药费" NUMBER, "西药" NUMBER, "耗材" NUMBER ); INSERT INTO MY_TABLE_TEST("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e37bab6d3c49dc123eead9bb7617ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7dfb97ceb7240da89dc98890cd7a48/" rel="bookmark">
			（八）k8s安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、机制说明 Kubernetes 作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。API Server 是集群内部各个组件通信的中介，也是外部控制的入口。所以 Kubernetes 的安全机制基本就是围绕保护 API Server 来设计的。Kubernetes 使用了认证（Authentication）、鉴权（Authorization）、准入控制（AdmissionControl）三步来保证API Server的安全
从上面这张图我们可以看出，无论是用户还是我们k8s内部的pod都需要走这个流程。先认证，再判断你是否有权限，最后放行。
2、认证 （Authentication） 默认提供了三种认证方式，如下：
HTTP Token 认证：通过一个 Token 来识别合法用户 （服务器单向检测客户端） HTTP Token 的认证是用一个很长的特殊编码方式的并且难以被模仿的字符串 - Token 来表达客户的一种方式。Token 是一个很长的很复杂的字符串，每一个 Token 对应一个用户名存储在 API Server 能访问的文件中。当客户端发起 API 调用请求时，需要在 HTTP Header 里放入 Token，服务端检验token是否正确
HTTP Base 认证：通过 用户名+密码 的方式认证 （服务器单向检测客户端） 用户名+：+密码 用 BASE64 算法进行编码后的字符串放在 HTTP Request 中的 Heather
Authorization 域里发送给服务端，服务端收到后进行编码，获取用户名及密码
最严格的 HTTPS 证书认证：基于 CA 根证书签名的客户端身份认证方式 （服务器和客户端互相检测对象是否正常），这个是k8s默认采用的方式 2.1、HTTPS 证书认证流程 HTTPS 证书认证，其认证流程如下，其实就是双方都要从第三方获取证书，认证的时候再发给对方去检查。
2.2、需要认证的节点 上图包含两种类型
Kubenetes 组件对 API Server 的访问：kubectl、Controller Manager、Scheduler、kubelet、kube-proxyKubernetes 管理的 Pod 对容器的访问：Pod（dashborad 也是以 Pod 形式运行） 换句话说就是这样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7dfb97ceb7240da89dc98890cd7a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a202e56df19058f4e58cfa9579db0c5/" rel="bookmark">
			关于Loglet Lab4的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Loglet Lab 4使用网址如上
在进行专利的技术生命周期划分的时候，可以使用网页版的Loglet Lab网页版进行数据导入。
首先，选择Library合适的模型
选最后一种
然后在首页编辑数据
在这选择预测一阶段，还是二阶段，还是三阶段
这里是结果导出
最下边，把图像导出.jpeg格式插入即可。 个人运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ef78a24837e7b0c8b3e1ba84a9407db/" rel="bookmark">
			高速USB转8串口产品设计-TTL串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于480Mbps 高速USB转8路串口芯片CH348，可以为各类主机扩展出8个独立的串口。使用厂商提供的VCP串口驱动程序，可支持Windows、Linux、Android、macOS等操作系统。使用单个CH348芯片即可实现USB一拖八串口转接产品，高速USB收发器和控制器、高速全双工串口控制器、以及每个UART内置独立的大容量收发FIFO，可轻松满足各类串口波特率下的连续稳定通信。
芯片提供的串口默认为TTL电平，可直接设计TTL串口产品，也可以外加RS232/RS485/RS422等电平转换芯片实现其他接口类型的USB转多串口产品。
CH348主芯片提供2种封装，LQFP48的CH348Q和LQFP100的CH348L，因TTL串口产品大部分应用场合仅需要提供串口TXD发送和RXD接收通道，因此设计时选择任何一款均可满足，若产品有5线串口和9线串口要求，则需要选择大封装全MODEM信号的CH348L芯片。
产品特点
支持各种常规串口波特率及最高6Mbps波特率，在高波特率下通讯连续、高效、稳定；多系统兼容，支持Windows/Linux/macOS/Android等操作系统，兼容各类串口软件；各串口均内置独立收发FIFO，独立工作，互不影响；支持全MODEM联络信号RTS、DTR、DCD、RI、DSR、CTS，可兼做GPIO用于MCU下载，IO控制等；支持串口CTS和RTS硬件自动流控，高速连续通讯无丢包；内置Unique ID，模块插入任意USB口，串口号均可保持固定，无需手动查找串口，使用更便捷；芯片内置EEPROM，支持配置芯片VID、PID、最大电流值、厂商和产品信息字符串等参数。可实现定制化的厂商信息； CH348L实现的全功能8路TTL串口产品参考设计
CH348Q实现的简版8路TTL串口产品参考设计
USB转8串口芯片CH348技术手册：CH348DS1.PDF - 南京沁恒微电子股份有限公司
参考设计及说明下载链接：CH348EVT.ZIP - 南京沁恒微电子股份有限公司
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a280562af57091c4fe7731ae89a308/" rel="bookmark">
			【编程之路（007）扫雷游戏】（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
菜单的打印
初始化棋盘
棋盘的打印
布置雷区 确定周围雷数量值
标记雷
取消标记
递归展开空白安全区
统计被正确标记的雷数
扫雷的具体过程
源码
引言 扫雷这个游戏想必大家都不陌生。如果你知道扫雷游戏的规则，那么你可以跳过这一段，直接到main函数的整体逻辑这里开始。如果你还不知道扫雷怎么玩，我也给你复制好了游戏规则。
胜利条件：
在一个9*9方块矩阵中随机布置一定量的地雷10个。由玩家逐个翻开方块，以找出所有地雷为最终游戏目标。如果玩家翻开的方块有地雷，则游戏结束。
游戏主区域由很多个方格组成。使用鼠标左键随机点击一个方格，方格即被打开并显示出方格中的数字；方格中数字则表示其周围的8个方格隐藏了几颗雷。
在判断出不是雷的方块上按下左键（我们的是输入坐标），可以打开该方块。如果方块上出现数字，则该数字表示其周围3×3区域中的地雷数，一般为8个格子，对于边块为5个格子，对于角块为3个格子。所以扫雷中最大的数字为8；如果方块上为空（相当于0），则可以递归地打开与空相邻的方块；如果不幸触雷，则游戏结束。
main函数的整体逻辑
int main() { srand((unsigned int)time(NULL));//暂时不管 int choice = 0; do { printf(" 游戏介绍： \n"); printf("输入 1 为开始游戏，输入 0 为退出游戏\n"); printf("游戏最终的胜利即为把全部的雷标记出来\n"); menu(); printf("请选择\n"); scanf("%d", &amp;choice); switch (choice) { case 1: { game(); break; } case 0: { printf("游戏退出\n"); break; } default: { printf("选择错误，重新选择\n"); break; } } } while (choice); return 0; } 这里的逻辑与上一篇三子棋【编程之路（006）三子棋游戏】（C语言实现）_p_fly的博客-CSDN博客一样，也很简单，如果不太明白，可以点击链接进去看看。接下来我们便实现游戏各个函数的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a280562af57091c4fe7731ae89a308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac60286310b3f2a481c3ac47a20ada8/" rel="bookmark">
			Vue电商后台管理系统功能展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目技术：html、css、javascript、node.js、vue、mysql项目描述：电商后台管理系统，主要功能包括：用户账号管理、商品分类、商品信息、订单、数据统计等业务功能。采用前后端分离的开发模式，其中前端项目是基于Vue技术栈的SPA项目，通过API接口连接服务器，访问mysql数据库。成品效果展示： 一、登陆界面 二、登陆校验规则 三、登陆成功后，保存Token 四、用户管理页面 五、添加用户功能（采用正则表达式进行校验） 六、添加用户成功，弹出消息框 7、分页功能 8、搜索功能 9、点击开关按钮，更新状态 10、删除功能 11、修改功能（跟添加一样，添加校验规则） 登陆页面功能代码详情：https://blog.csdn.net/weixin_45065754/article/details/123433168用户管理页面功能代码详情：https://blog.csdn.net/weixin_45065754/article/details/123458165Gitte项目代码：https://gitee.com/jasmine-qiqi/vue_shop 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0fcf3194a912fedcef2bc862669468/" rel="bookmark">
			【OpenCV学习】初识OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈据说，看我文章时 关注、点赞、收藏 的 帅哥美女们 心情都会不自觉的好起来。
前言：
🧡作者简介：大家好我是 user_from_future ，意思是 “ 来自未来的用户 ” ，寓意着未来的自己一定很棒~
✨个人主页：点我直达，在这里肯定能找到你想要的~
👍专栏介绍：OpenCV从入门到放弃 ，一个学习OpenCV的专栏~
初识OpenCV 安装 OpenCV启动 Jupyter创建和销毁窗口图片在 OpenCV 中的表现 安装 OpenCV 博主学习的是通过虚拟环境来学习 OpenCV ，使用 3.4.1.15 这个版本。因为在 3.4.2 版本之后有些算法申请了专利，就用不了。
但 3.4.1.15 这个版本目前最高只支持到 Python3.6 ，博主就另外又安装了 Python3.6.8 作为学习 OpenCV 使用。
在 opencv-python 模块的下载页面查找，可以明显发现其 3.4.1.15 版本只支持 Python2.7 、 Python3.4 、 Python3.5 、 Python3.6 这些版本，我们能挑到的最高版本是 Python3.6.8 。
在官网 Python官网下载 中找到 Python3.6.8 版本。
先创建并进入虚拟环境：先要使用 Python3.6.8 安装 pip install virtualenv ，才能创建虚拟环境，然后进入环境的 Scripts 目录，输入 activate 激活当前环境，出现 (OpenCV) 就代表成功进入当前环境了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0fcf3194a912fedcef2bc862669468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74f70a468ee6e233c539a297b44cad8/" rel="bookmark">
			判断一个数是否为2的幂次方(位运算)C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++ 判断一个数是否为2的幂次方(位运算) 题目描述：给定一个数判断是否为2的幂次方 1.基本方法 通过for循环取余除2判断为2的幂次方
代码实现：
bool isPowerOfTwo(int n) { if(n&lt;1){ return false; } while(n&gt;=1){ if(n ==1 || n==2){ return true; } if(n%2 !=0){ return false; } n = n/2; } return false; } 2.位运算 利用位运算按位与&amp;判断
按位与运算规则：
将两个数按二进制进行“与”运算，eg:
0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1;
两个数对应位置同时为“1”，结果才为“1”，否则为0
这里利用（n&amp;n-1）判断，比如：
5&amp;4 即101&amp;100 = 1
6&amp;5 即110&amp;101 = 4
8&amp;7 即1000&amp;0111 = 0
原理：如果一个数是2的幂次方，那么它的二进制编码只有最高位为1，对其减1，使得最高位变为0，其余为1，两者&amp;运算结果为0。
代码实现：
bool isPowerOfTwo(int n) { if(n &lt;1){ return false; }else if((n&amp;n-1) == 0){ return true; }else{ return false; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbae9be3662dac465541ded7829b4bf/" rel="bookmark">
			ibatis.binding.BindingException:Invalid bound statement （not found）:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述： 项目中创建mapper接口，编写xml文件sql语句，执行出现错误-----
无效的绑定语句（未找到）
二、问题原因 1.（少数) xml文件中方法的id名与mapper中的方法名不对应
2. 这个错误是由maven默认加载机制造成问题
众所周知，利用mp代码生成器，mapper层如下，有xml文件，有接口。
但在target文件中，则没有xml文件，-------&gt;maven加载时候，把java文件夹里面.java类型文件进行编译，如果其他类型文件，不会加载
三、解决方法 1.复制xml文件 到target目录中
2.把xml文件放到resources目录中
3.（推荐）通过配置实现
①pom.xml 中加入
&lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; ②application.properties 中加入
#配置mapper xml文件的路径 mybatis-plus.mapper-locations=classpath:com/sxy/eduservice/mapper/xml/*.xml 重新打包即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2c5dddb658b4072302ad2db05d194c/" rel="bookmark">
			机器学习之二分类模型评价指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习之二分类模型评价指标 一、二分类模型衡量指标1.1 混淆矩阵：Confusion matrix1.1.1 原理1.1.2 实现 1.2 精确度：Accuracy1.2.1 原理1.2.2 实现 1.3 准确率：Precision1.3.1 原理1.3.2 实现 1.4 召回率：Recall1.4.1 原理1.4.2 实现 1.5 F1-Score1.5.1 原理1.5.2 实现 1.6 PR曲线1.6.1 原理1.6.1 实现 1.7 ROC曲线1.7.1 原理1.7.2 实现 1.8 AUC值1.8.1 原理1.8.2 实现 1.9 KS值1.9.1 原理1.9.2 实现 一、二分类模型衡量指标 1.1 混淆矩阵：Confusion matrix 1.1.1 原理 P（Positive） ：代表1N（Negative） ：代表0T（True） ：代表预测正确F（False） ：代表预测错误 1.1.2 实现 from sklearn.metrics import confusion_matrix confusion_matrix(y_true,y_pred,labels=None,sample_weight = None) ''' y_true：真实的label，一维数组，列名 y_pred：预测值的label，一维数组，行名 labels：默认不指定，此时y_true,y_pred去并集，做升序，做label sample_weight：样本权重 返回结果：返回混淆矩阵 ''' import numpy as np from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f2c5dddb658b4072302ad2db05d194c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c73bb856a79eb338159f67300489c42/" rel="bookmark">
			(zichao)SpringMVC笔记（仅作简单整理，未深入探究）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、SpringMVC简介（一）什么是MVC1、MVC2、MVC的工作流程 （二）什么是SpringMVC（三）SpringMVC的特点 二、构建开发环境（一）创建maven工程（二）配置web.xml（三）创建请求控制器（四）创建springMVC的配置文件（五）测试HelloWorld 三、@RequestMapping注解（一）@RequestMapping注解的功能（二）@RequestMapping注解的位置（三）@RequestMapping注解的value属性（四）@RequestMapping注解的method属性（五）@RequestMapping注解的params属性（六）@RequestMapping注解的headers属性（七）SpringMVC支持ant风格的路径（八）SpringMVC支持路径中的占位符（重点） 四、SpringMVC获取请求参数（一）通过ServletAPI获取（二）通过控制器方法的形参获取请求参数（三）@RequestParam（四）@RequestHeader（五）@CookieValue（六）通过POJO获取请求参数（七）解决获取请求参数的乱码问题 五、域对象共享数据（一）使用ServletAPI向request域对象共享数据（二）使用ModelAndView向request域对象共享数据（三）使用Model向request域对象共享数据（四）使用map向request域对象共享数据（五）使用ModelMap向request域对象共享数据（六）向session域共享数据（七）向application域共享数据 六、SpringMVC的视图（一）ThymeleafView（二）转发视图（三）重定向视图（四）视图控制器view-controller 七、RESTful（一）1、RESTful简介1、资源2、资源的表述3、状态转移 （二）RESTful的实现（三）HiddenHttpMethodFilter 八、HttpMessageConverter（一）@RequestBody（二）RequestEntity（三）@ResponseBody（四）SpringMVC处理json（五）@RestController注解（六）ResponseEntity 九、文件上传和下载（一）文件下载（二）文件上传 十、拦截器（一）拦截器的配置（二）拦截器的三个抽象方法（三）多个拦截器的执行顺序 十一、注解配置SpringMVC（一）创建初始化类，代替web.xml（二）创建SpringConfig配置类，代替spring的配置文件（三）创建WebConfig配置类，代替SpringMVC的配置文件 一、SpringMVC简介 （一）什么是MVC 1、MVC 是一种软件架构的思想，将软件按照模型、视图、控制器来划分
M：Model，模型层，指工程中的JavaBean，作用是处理数据V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 而JavaBean也分为两类：
一类称为实体类Bean：专门存储业务数据的，如 Student、User 等一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 2、MVC的工作流程 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器
（二）什么是SpringMVC SpringMVC是Spring的一个后续产品，是Spring的一个子项目
SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、
WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目
表述层开发的首选方案。
注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 servlet
（三）SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案代码清新简洁，大幅度提升开发效率内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可性能卓著，尤其适合现代大型、超大型互联网项目要求 二、构建开发环境 （一）创建maven工程 添加web模块打包方式：war引入依赖 （二）配置web.xml 注册SpringMVC的前端控制器DispatcherServlet
&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servletclass&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c73bb856a79eb338159f67300489c42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea231c4ee38fcae4a25663050f936cd9/" rel="bookmark">
			Error: Cannot retrieve repository metadata (repomd.xml) for repository: base. Please verify its path
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum安装软件报错 [root@localhost local]# yum -y install gcc
Loaded plugins: fastestmirror, refresh-packagekit, security
Determining fastest mirrors
YumRepo Error: All mirror URLs are not using ftp, http[s] or file.
Eg. Invalid release/repo/arch combination/
removing mirrorlist with no valid mirrors: /var/cache/yum/x86_64/6/base/mirrorlist.txt
Error: Cannot find a valid baseurl for repo: base
查找解决办法时说是repomd文件没有找到，这会导致yum命令无法检索存储库元数据(或者理解为找不到库)；即需要让yum命令能找到这个文件，
解决办法：更换yum源
mv /etc/yum.repos.d/* /tmp/ 备份源文件
cd /etc/yum.repos.d/
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
下载yum源文件
vim CentOS-Base.repo 修改文件中的源地址
改为vault.centos.org
改为https://vault.centos.org/6.5/os/x86_64/
sudo yum clean all &amp;&amp; yum makecache
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea231c4ee38fcae4a25663050f936cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02845b97818bc07e326b70d769874c7d/" rel="bookmark">
			ajax的各个参数详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery中的ajax方法参数总是记不住，这里记录一下。
1.url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。
2.type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。
3.timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。
4.async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
5.cache: 要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。
6.data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　processData选项。对象必须为key/value格式，例如{foo1:"bar1",foo2:"bar2"}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:["bar1","bar2"]}转换为&amp;foo=bar1&amp;foo=bar2。
7.dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：
xml：返回XML文档，可用JQuery处理。
html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。
script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。
json：返回JSON数据。
jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。
text：返回纯文本字符串。
8.beforeSend：
要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。
function(XMLHttpRequest){
this; //调用本次ajax请求时传递的options参数
}
9.complete：
要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。
function(XMLHttpRequest, textStatus){
this; //调用本次ajax请求时传递的options参数
}
10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。
(1)由服务器返回，并根据dataType参数进行处理后的数据。
(2)描述状态的字符串。
function(data, textStatus){
//data可能是xmlDoc、jsonObj、html、text等等
this; //调用本次ajax请求时传递的options参数
}
11.error:
要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：
function(XMLHttpRequest, textStatus, errorThrown){
//通常情况下textStatus和errorThrown只有其中一个包含信息
this; //调用本次ajax请求时传递的options参数
}
12.contentType：
要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为"application/x-www-form-urlencoded"。该默认值适合大多数应用场合。
13.dataFilter：
要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。
function(data, type){
//返回处理后的数据
return data;
}
14.dataFilter：
要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。
function(data, type){
//返回处理后的数据
return data;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02845b97818bc07e326b70d769874c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e69a0ad330912823d0719e759ed86c/" rel="bookmark">
			电商精准营销—数据预处理概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#coding:utf8 import pandas as pd # 导入pandas库 import numpy as np # 导入numpy库 def choose_data(data): #选择变量'user_id', 'time', 'model_id', 'type', 'cate', 'brand',选取time在2016-02-01及以后的数据（包含2016-02-01）且type=6，数据类型如下： # user_id sku_id time model_id type cate brand # 0 266079 138778 2016-01-31 23:59:02 NaN 1 8 403 # 1 266079 138778 2016-01-31 23:59:03 0.0 6 8 403 # 2 200719 61226 2016-01-31 23:59:07 NaN 1 8 30 # 3 200719 61226 2016-01-31 23:59:08 0.0 6 8 30 # 4 263587 72348 2016-01-31 23:59:08 NaN 1 5 159 ########## Begin ########## data_time=pd_datetime[date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e69a0ad330912823d0719e759ed86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b3fdadc85db20340c3c8ed77b9d3d3/" rel="bookmark">
			RTD2556/RTD2556T,支持输入HDMI,DP,输出LVDS,EDP，2.5K分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.工作电压3.3V&amp; 1.1V &amp;2.5V , LQFP156P,22MM*16MM
2.RTD2556T支持FRC/OD等功能，可以180度翻转画面
3.配8MbitSPI NOR FLASH
4.有OSD功能，16色（24bit），可支持旋转90/180/270
5.HDMI1.4 &amp;DP1.1 &amp; HDCP1.4
最全的瑞昱显示解决方案
———————————————
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10c49623a302851468f3c188bae68e7/" rel="bookmark">
			AI画图 Disco-diffusion 本地搭建测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Disco-Diffusion5.2 本地搭建测试记录 Disco Diffusion基于CLIP-Guided Diffusion网络实现文本输入，美图输出，还可以选不同的画家风格。具体技术实现不在这里讲了可以参考官方文档后面的资源部分。或者看论文。
友情论文秃头链接：https://arxiv.org/abs/2105.05233https://arxiv.org/abs/2105.05233
好了下面开始Debug，先上一组自己生成的图，图下面是生成图像用的文字说明，制定画家和场景关键词描述就可以出图。
artstation,Greg Rutkowski,city,dream,universe,original,time,cloud,future,night
A cyberpunk city with a spaceship in the sky
artstation,Greg Rutkowski,sea,dikel,ship,industrialization,cloud,time,future,afternoon
通过更改笔记本中文字重新运行就可以生成不同风格的图片，我用的是RTX3090的卡，生成图像分辨率为1280*768，其它配置用的默认，大概25-30分钟一张图，比Colab普通版快3倍左右。想看其它小伙伴生成的图可以去Discord，有挺多好看的图片。
https://discord.gg/XGZrFFCRfNhttps://discord.gg/XGZrFFCRfN
一、项目官方文档 官方英文文档
​​​​​​https://docs.google.com/document/d/1l8s7uS2dGqjztYSjPpzlmXLjl5PM3IGkRWI3IiCuK7g/edithttps://docs.google.com/document/d/1l8s7uS2dGqjztYSjPpzlmXLjl5PM3IGkRWI3IiCuK7g/edit
简单机翻了一下的文档
Docshttps://u64b10hj3j.feishu.cn/docs/doccn8fbnQ6MnkCAFQpcjADO7Ae
项目Github地址
GitHub - alembics/disco-diffusionContribute to alembics/disco-diffusion development by creating an account on GitHub.https://github.com/alembics/disco-diffusion
官方演示Colab
https://colab.research.google.com/github/alembics/disco-diffusion/blob/main/Disco_Diffusion.ipynbhttps://colab.research.google.com/github/alembics/disco-diffusion/blob/main/Disco_Diffusion.ipynb
二、本地安装测试 2.1 文件克隆 git clone https://github.com/openai/guided-diffusion.git 直接克隆之后文件夹和模型都不全，需要运行Disco_Diffusion.ipynb进行环境安装
完整一些的目录大概是这样的
2.2 环境搭建 项目要用pytorch，自己搭很多库，最好直接用Anaconda
Anaconda | The World's Most Popular Data Science Platform
运行项目笔记本，前几步问题不大，用conda环境，python版本选3.9就可以，3.10也行。
第二个单元会提示没检测到colab，模型会选用本地的models文件夹
第三个单元检测一些必须的依赖包，没装成的直接pip装就行
然后是这一步，会把缺的文件补上，下载可能会有点慢耐心等等，或者自己手动克隆也行，这一步必须要确保文件夹都下载了不然后面会很多问题
之后是torch和一些其他包引用，这里面有坑就是有些import会出错，因为文件夹嵌套的原因，需要手动改一下，比如MiDaS文件夹以及里面要用的midas_utils.py，文件夹和笔记本中名称大小写要一致不然找不到那个文件夹和里面脚本。
接下里两步也是下载文件夹和配环境
之后的几个单元格很长是一些函数定义，直接运行即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10c49623a302851468f3c188bae68e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e000dfe49ac9684803b7e9e409e39401/" rel="bookmark">
			Java执行Scala编译的jar包时，提示Exception in thread “main“ java.lang.NoClassDefFoundError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚接触Spark，踩了一些当时觉得比较奇怪的坑，所幸摸索了一套有个人特色的解决方案，并以此管窥了一下Scala和Java这两种语言，特此归纳并记录。
下面的命令是在Windows 10+的Powershell下的，不过对其他平台应该也大同小异。
问题描述 直接运行Spark的examples或者其他Scala编译出的jar包，会报错：
&amp;"G:\Program Files\Java\jdk1.7.0_80\bin\java.exe" -classpath "G:\GreenSoftwares\spark-2.1.0-bin-hadoop2.7\examples\jars\spark-examples_2.11-2.1.0.jar" org.apache.spark.examples.SparkPi 100 报错信息基本是找不到Scala相关的类和函数：
Exception in thread "main" java.lang.NoClassDefFoundError: scala/collection/Seq at org.apache.spark.examples.SparkPi.main(SparkPi.scala) Caused by: java.lang.ClassNotFoundException: scala.collection.Seq at java.net.URLClassLoader$1.run(URLClassLoader.java:366) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:425) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:358) ... 1 more 但是，通过spark-submit可以成功运行，如：
spark-submit.cmd --master 'local[*]' --class org.apache.spark.examples.SparkPi .\spark-examples_2.11-2.1.0.jar 1000 通过IDEA一般也能成功执行到里面的前几句，之后会报错需要提供spark master URL，说明至少能跑了。
解决方案 这是因为class path缺少scala相关的jar包，因此参考IDEA运行参数，如果非要通过Java直接执行，前文的命令应改为
java -cp &lt;一堆scala相关的jar包，中间用英文分号（;）隔开;spark-examples_2.11-2.1.0.jar&gt; org.apache.spark.examples.SparkPi 1000 例如（下面-classpath非常长，而且基本是和我的环境相关的路径，直接复制肯定没用）：
&amp;"G:\Program Files\Java\jdk1.7.0_80\bin\java.exe" -classpath "G:\Program Files\Java\jdk1.7.0_80\jre\lib\charsets.jar;G:\Program Files\Java\jdk1.7.0_80\jre\lib\deploy.jar;G:\Program Files\Java\jdk1.7.0_80\jre\lib\ext\access-bridge-64.jar;G:\Program Files\Java\jdk1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e000dfe49ac9684803b7e9e409e39401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0c8fc6f54ceb78cfe72c4c8baf379b/" rel="bookmark">
			【C语言升级练everyday】——扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习编程语言需要兴趣，一个有趣的代码可能会成为你持之以恒学习的动力。故此，小编编写此文章，希望学习C语言的小新们能够保持对编程的兴趣与热爱！ 那么，现在就让我们进入今天的扫雷世界。 描述： 输入' 0 '和' -1 '形成 n行*m列的雷矩阵（“-1”表示雷），输出时按 扫雷规则 显示雷以及除雷以外的数组元素（该数组元素的值等于以该元素为中心的九宫格包含的雷的个数）。
输入描述：
第一行输入行数n及列数m的值。第二行输入矩阵包含的' 0 '和' -1 '。
输出描述：
输出的扫雷矩阵的每一行每一列都是一个数字，每个数字的含义是与当前位置相邻的8个格子中，有多少个雷（在下图中，雷用*表示）；
若当前位置就是雷的话，仍输出雷 “-1”。
关键点：1.涉及到矩阵边界雷得识别需限制条件；
2.九宫格遍历（可由两个for循环解决，也可用若干个if语句解决，但此方法比较繁琐）；
初始的雷矩阵如下：
扫雷 1-1 1 0 0 0 2 2 2 1 1 1 1-1 2 2-1 1 2 3-1 2 1 1 1-1 2 2 1 1 1 1 1 1-1 1 代码如下：
#include&lt;stdio.h&gt; int main() { int n,m; printf("输入n与m的值："); scanf("%d%d",&amp;n,&amp;m); int i,j; int k,l; int a[n][m]; int count; getchar(); //消耗换行符 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0c8fc6f54ceb78cfe72c4c8baf379b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3076b0e2c2a345feb3e54aad684b9ab1/" rel="bookmark">
			2021-7-20 Cityscape 数据集从19分类到4分类BiSeNetv1-v2训练验证和测试一条龙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 训练分类16到9的结果 迭代了2000次之后，IOU差不多到0.6-0.7这样子~网络选用BiSeNetV1做的，
迭代四万次之后的模型测试结果：
2. 网络替换成 BiSeNet V2再次进行训练和测试 迭代次数8万次网络 Bisenet V2分类类别：n_cat=4 (树木、草地、道路和背景) 如下图是 BiSeNet V2迭代2千次的结果：
接下来是Bisenet V2迭代十万次，服务器还在疯狂加班中……最高到达m-IOU=0.828
这是原网络BisenetV2做的迭代八万次的效果，最高到达m-IOU=0.78
测试结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ade040b4f809e8b784d1fe27ac42a4/" rel="bookmark">
			golang高级进阶（二）：goroutine性能、channel管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、goroutine性能对比
1. 素数算法
2. for获取1-120000素数的执行时间
3. 添加goroutine后，获取执行时间
二、Channel管道
1. 定义管道
2. 管道基本操作
3. 管道类型
4. 管道阻塞
5. 循环取管道值
6. 结合goroutine实现管道一直运行
三、结合goroutine和channel统计1-120000的素数
一、goroutine性能对比 1. 素数算法 package main import "fmt" func main() { // 获取1-100之间的素数：除了1和它本身整除外不能被任何数整除，1不是素数 for i := 2; i &lt;= 100; i++ { var flag bool = true // 假设是素数 for j := 2; j &lt; i; j++ { // j从2开始，是因为1可以被0除外的所有数整除 if i%j == 0 { flag = false } } if flag { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ade040b4f809e8b784d1fe27ac42a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166fc5eac49e038d7e467735da7596d8/" rel="bookmark">
			原生js实现table 横向纵向全选功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要实现这种功能，很明显用elment ui实现不了。element ui 纵向需要prop名字不一样才能展示，很明显，我这个一层二层是名字一样的数组
期望后台返回数组
是这种格式。
所有需要自己用table tr td 去画表格，而且使用element ui 的checkbox我实现不了纵向全选，所有全部使用了原生js。
//templat部分 &lt;table class="table-style"&gt; //纵向全选表头 &lt;th v-for="(item,index) in thList" :key="'th'+index"&gt; &lt;div v-show="index!==0"&gt; &lt;input type="checkbox" class="check" @click="verCheck(index)"/&gt; &lt;span&gt;全选&lt;/span&gt; &lt;/div&gt; &lt;/th&gt; &lt;div&gt;&lt;/div&gt; &lt;tr v-for="(item,xIndex) in trList" :key="xIndex" class="check-unit"&gt; //横向表头 &lt;td&gt; &lt;input type="checkbox" class="check" @click="transverseClick(xIndex)"/&gt; {{item.floor}}层 &lt;/td&gt; //单元表格 &lt;td v-for="(citem,yIndex) in item.unitList" :key="citem.keys" &gt; &lt;div&gt; &lt;input type="checkbox" class="check" @click="(e)=&gt;unitCheckClick(e,xIndex,yIndex)" :class="['verCheck'+yIndex,'tran'+xIndex]"/&gt; {{citem.unit}} &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; data() { return { trList: [ { floor: 1, key: 1, unitList: [ { keys: 1, unit: '101', area: '90m²', house: '2室1厅1卫1阳台' }, { keys: 2, unit: '102', area: '90m²', house: '2室1厅1卫1阳台' }, { keys: 3, unit: '103', area: '90m', house: '2室1厅1卫1阳台' }, { keys: 4, unit: '104', area: '90m', house: '2室1厅1卫1阳台' }, { keys: 5, unit: '105', area: '90m', house: '2室1厅1卫1阳台' }, { keys: 6, unit: '106', area: '90m', house: '2室1厅1卫1阳台' } ] }, { floor: 2, key: 2, unitList: [ { keys: 1, unit: '201', area: '90m', house: '2室1厅1卫1阳台' }, { keys: 2, unit: '202', area: '90m', house: '2室1厅1卫1阳台' } ] }, { floor: 3, key: 3, unitList: [ { keys: 1, unit: '301', area: '90m', house: '2室1厅1卫1阳台' } ] } ], thList: [],//表头全选数组 checkedUitList: [] // 被选中单元列表 } }, methods: { // 填充无单元信息表格 fillTd() { let max = 0 max = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166fc5eac49e038d7e467735da7596d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb23206e7e51a3f32813dfcccede2606/" rel="bookmark">
			(zichao)VUE3基础（仅作简单整理，未深入探究）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、创建Vue3.0工程二、setup（一）理解：（二）作用（三）setup函数的两种返回值：（四）注意点（五）声明一个setup 三、ref函数（一）作用（二）语法（三）操作数据（四）注意 四、reactive函数（一）作用（二）语法（三）深层次的 五、setup的两个注意点（一）setup执行的时机（二）setup的参数1、props2、context 六、计算属性（一）写法 七、watch函数（一）写法（二）watchEffect函数 八、生命周期九、自定义hook函数十、toRef和toRefs十一、其它 Composition API（一）shallowReactive 与 shallowRef（二）readonly 与 shallowReadonly（三）toRaw 与 markRaw（四）provide 与 inject1、作用2、实现 十二、响应式数据的判断十三、新的组件（一）Fragment（二）Teleport十四、其他（一）全局API的转移（二）过度类名的更改（三）移除过滤器（filter） 一、创建Vue3.0工程 //查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version //安装或者升级你的@vue/cli npm install -g @vue/cli //创建 vue create vue_test //启动 cd vue_test npm run serve 二、setup （一）理解： Vue3.0中一个新的配置项，值为一个函数。
（二）作用 setup是所有父亲，组件中所用到的：数据、方法等等，均要配置在setup中。
（三）setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）
（四）注意点 尽量不要与Vue2.x配置混用，如果有重名, setup优先。setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） （五）声明一个setup setup(){ //数据 let name = '张三' let age = 18 let a = 200 //方法 function sayHello(){ alert(`我叫${name}，我${age}岁了，你好啊！`) } //返回一个对象（常用） return { name, age, sayHello, a } } 三、ref函数 （一）作用 定义一个响应式的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb23206e7e51a3f32813dfcccede2606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f798e559d1d1812fd719c7cd356847/" rel="bookmark">
			(zichao)VUE2基础_2（仅作简单整理，未深入探究）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、使用Vue脚手架（一）说明（二）具体步骤（三）模板项目的结构（四）main.js和以前的不同之处1、引入Vue2、render函数 二、ref属性三、props配置（一）作用（二）用法 四、混合（一）定义一个混合（二）局部引用（三）全局引用 五、插件六、scoped七、本地存储（一）localStorage（二）sessionStorage 八、自定义事件（一）props实现（二）子给父传递数据（使用@或v-on）（三）给父传递数据（使用ref） 九、全局事件总线（一）创建事件总线（二）接收数据（三）发送数据（四）解绑事件 十、$nextTick十一、过度和动画（一）原理（二）过渡的相关类名（三）引入外部动画 十二、插槽（一）默认插槽（二）具名插槽（三）作用域插槽 十三、Vuex（一）概念（二）搭建vuex环境1、创建文件：2、引入 （三）基本使用1、 初始化数据2、组件中读取vuex中的数据3. 组件中修改vuex中的数据 （四）getters的使用1、概念2、配置3、读取 （五）简洁获取state数据1、mapState方法2、mapGetters方法 （六）简洁设置方法1、mapActions2、mapMutations方法 （七）模块化+命名空间1、修改store.js2、开启命名空间后，组件中读取state数据3、开启命名空间后，组件中读取getters数据4、开启命名空间后，组件中调用dispatch5、开启命名空间后，组件中调用commit 十四、路由（一）理解（二）基本使用1、安装vue-router2. 应用插件：3、编写router配置项4、实现切换和指定展示位置5、注意 （三）多级路由1、配置路由规则2、跳转 （四）路由的query参数1、传递参数2、接收参数 （五）命名路由1、 作用2、 使用3、简化跳转 （六）路由的params参数1、 配置路由2、传递参数3、接收参数： （七）路由的props配置（八）``````的replace属性（九）编程式路由导航1、作用2、具体编码 （十）缓存路由组件1、 作用2、具体编码： （十一）两个新的生命周期钩子1、 activated2、deactivated （十二）路由守卫1、 作用：对路由进行权限控制2、分类：全局守卫、独享守卫、组件内守卫3、全局守卫:4、独享守卫5、组件内 （十三）路由器的两种工作模式 一、使用Vue脚手架 （一）说明 Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）。最新的版本是 4.x。文档: https://cli.vuejs.org/zh/。 （二）具体步骤 （仅第一次执行）：全局安装@vue/cli。 npm install -g @vue/cli 切换到你要创建项目的目录，然后使用命令创建项目 vue create xxxx 启动项目 npm run ***.js （三）模板项目的结构 ── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f798e559d1d1812fd719c7cd356847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a601d4070e030458234919ddab75da00/" rel="bookmark">
			MySQL生成百万条数据超详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章是关于MySQL生成百万条数据的全部过程，每一步都有具体的sql，并且每一步都有具体的注释，详细步骤如下：
1、创建数据库
CREATE DATABASE `test_bai` -- 创建数据库 USE `test_bai` -- 切换对应的数据库 2、创建表
CREATE TABLE `app_user`( `id` INT NOT NULL AUTO_INCREMENT COMMENT '主键', `name` VARCHAR(50) DEFAULT '' COMMENT '用户名称', `email` VARCHAR(50) NOT NULL COMMENT '邮箱', `phone` VARCHAR(20) DEFAULT '' COMMENT '手机号', `gender` TINYINT DEFAULT '0' COMMENT '性别（0-男 ： 1-女）', `password` VARCHAR(100) NOT NULL COMMENT '密码', `age` TINYINT DEFAULT '0' COMMENT '年龄', `create_time` DATETIME DEFAULT NOW(), `update_time` DATETIME DEFAULT NOW(), PRIMARY KEY (`id`) )ENGINE = INNODB DEFAULT CHARSET = utf8 COMMENT='app用户表' 3、书写新增100万条数据的函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a601d4070e030458234919ddab75da00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9849086d52a3b22a9bfbc487cc08fda0/" rel="bookmark">
			【查找算法】6种常见的查找算法简述及Python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一个甜甜的大橙子🍊，欢迎关注✉️！
我相信技术的力量💪
努力将所学分享给大家😎
你的点赞❤️分享🚀收藏📖就是对我最大的鼓励👏！
文章目录 1.顺序查找算法2.二分查找算法3.插补查找算法4.哈希查找算法5.分块查找算法6.斐波那契查找算法7.查找算法的时间复杂度8.如何解决散列表冲突 首先我们生成一个随机数列，用于执行查找算法。
# 生成随机数列 import random data = [0]*50 for i in range(50): data[i] = random.randint(1,100) print('the random data is:') for i in range(10): for j in range(5): print('%2d[%3d] ' % (i*5+j+1,data[i*5+j]), end='') print('\n') the random data is: 1[ 1] 2[ 68] 3[ 14] 4[ 83] 5[ 94] 6[ 71] 7[ 13] 8[ 47] 9[ 43] 10[ 43] 11[ 43] 12[ 29] 13[ 65] 14[ 47] 15[ 31] 16[100] 17[ 5] 18[ 77] 19[ 99] 20[ 46] 21[ 17] 22[ 56] 23[ 38] 24[ 65] 25[ 4] 26[ 14] 27[ 4] 28[ 68] 29[ 61] 30[ 42] 31[ 97] 32[ 81] 33[ 68] 34[ 91] 35[ 47] 36[ 31] 37[ 51] 38[ 16] 39[ 18] 40[ 10] 41[ 14] 42[ 63] 43[ 47] 44[ 47] 45[ 86] 46[ 58] 47[ 86] 48[ 23] 49[ 37] 50[ 59] 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9849086d52a3b22a9bfbc487cc08fda0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77bfe8797e753d434cd71345908cbe2/" rel="bookmark">
			vue-element-admin项目安装依赖报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现。可以帮助你快速搭建企业级中后台产品原型。
但再安装依赖时出了一些问题
报错如下
npm ERR! code ENOENT npm ERR! syscall spawn git npm ERR! path git npm ERR! errno -4058 npm ERR! enoent Error while executing: npm ERR! enoent undefined ls-remote -h -t ssh://git@github.com/sohee-lee7/Squire.git npm ERR! enoent npm ERR! enoent npm ERR! enoent spawn git ENOENT npm ERR! enoent This is related to npm not being able to find a file. npm ERR! enoent 解决方案
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77bfe8797e753d434cd71345908cbe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a49cc4c2de4954157ee8914a17e2d5/" rel="bookmark">
			Hadoop中小文件过多的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小文件优化的方向：
（1）在数据采集的时候，就将小文件或小批数据合成大文件再上传HDFS。
（2）在业务处理之前，在HDFS上使用 M ap R educe程序对小文件进行合并。
（3）在 M ap R educe处理时，可采用 CombineTextInputFormat 提高效率。
（ 4 ）开启uber模式，实现jvm重用 问题定义
HDFS上的小文件是指文件大小明显小于HDFS上块（block）大小（默认64MB）的文件。在hdfs上大量存储小文件会给hadoop的扩展性和性能带来严重问题。
原因
首先，在HDFS中，任何一个文件，目录或者block在NameNode节点的内存中均以一个对象表示（元数据）（Every file, directory and block in HDFS is represented as an object in the namenode’s memory），而这受到NameNode物理内存容量的限制。每个元数据对象约占150byte，所以如果有1千万个小文件，每个文件占用一个block，则NameNode大约需要2G空间。如果存储1亿个文件，则NameNode需要20G空间，这毫无疑问1亿个小文件是不可取的。
其次，处理小文件并非Hadoop的设计目标，HDFS的设计目标是流式访问大数据集（TB级别）。因而，在HDFS中存储大量小文件是很低效的。访问大量小文件经常会导致大量的寻找，以及不断的从一个DatanNde跳到另一个DataNode去检索小文件（Reading through small files normally causes lots of seeks and lots of hopping from datanode to datanode to retrieve each small file），这都不是一个很有效的访问模式，严重影响性能。
最后，处理大量小文件速度远远小于处理同等大小的大文件的速度。每一个小文件要占用一个slot，而task启动将耗费大量时间甚至大部分时间都耗费在启动task和释放task上。
MapReduce上的小文件问题
Map任务（task）一般一次处理一个块大小的输入（input）（默认使用FileInputFormat）。如果文件非常小，并且拥有大量的这种小文件，那么每一个map task都仅仅处理非常小的input数据，因此会产生大量的map tasks，每一个map task都会额外增加bookkeeping开销（each of which imposes extra bookkeeping overhead）。一个1GB的文件，拆分成16个块大小文件（默认block size为64M），相对于拆分成10000个100KB的小文件，后者每一个小文件启动一个map task，那么job的时间将会十倍甚至百倍慢于前者。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a49cc4c2de4954157ee8914a17e2d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ddfd298f4e072642d85a383e8c9219/" rel="bookmark">
			读取zs数据 dataset 训练一维卷积模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		trainer.py
from bdb import set_trace import torch from torch import nn from nets import ConvNet, LstmNet from dataset import tempDataset import os from torch.utils.data import Dataset, DataLoader class Trainer: def __init__(self, save_path, dataset_path, isLstm=False): self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu") self.save_path = save_path self.isLstm = isLstm self.dataset = tempDataset(dataset_path) if isLstm: self.net = LstmNet().to(self.device) else: self.net = ConvNet().to(self.device) self.loss_fn = nn.MSELoss() self.optimizer = torch.optim.Adam(self.net.parameters(), lr=0.0001) # if not os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ddfd298f4e072642d85a383e8c9219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34e2a6fde0623c574a8e89ff4f458a6/" rel="bookmark">
			Javascript基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
初识JS
JS引用
输入输出
变量应用
数据类型
理论
数字型 Number
字符串型 String
布尔型 Boolean
其他型 Undefined 、 Null
注意：可使用 typeof 来测试其类型
类型转换
运算符
自增运算符
== 与 ===
逻辑与或
优先级
初识JS 内含：运行在客户端的脚本语言；划分： ECMAScript — —基础语法；DOM — —文档对象模型；BOM — —浏览器对象模型。 JS引用 行内式 例如：οnclick=" alert (' 内容 ') ";内嵌式 例如：写在 &lt;script&gt; 标签内部；外部文件 例如：&lt;script src="外部" &gt; &lt;script&gt;; 输入输出 输入框 形式：prompt(' '); 注意：输入的值通常为字符串型；弹出警示框 （输出展示给用户） 形式：alert(' ');控制台输出 （程序员测试使用） 形式：console.log(' ');打印返回元素对象 （程序员测试使用） 形式：console.dir(' '); 变量应用 定义变量 var 变量名 = 值 ;更新变量 以新覆盖旧变量命名 可用 _、$等，采用驼峰命名法变量本质 是内存中存放数据的容器 数据类型 理论 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34e2a6fde0623c574a8e89ff4f458a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5ab079ca329ed7565b1c9eedddb3f5/" rel="bookmark">
			python开发photoshop将图片导出为tiff
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python开发photoshop将图片导出为tiff # -*- coding:utf-8 -*- # @Time : 2022/5/7 15:50 # @Author : xuyongsai # @Email : 1815222521@qq.com # @File : PhotoShop.py # @Software: PyCharm # @Version : 1.0 import os import sys reload(sys) sys.setdefaultencoding('utf8') from comtypes.client import CreateObject class pdfConverter: def __init__(self): # word文档转化为pdf文档时使用的格式为17 # self.wdFormatPDF = 17 # self.wdToPDF = CreateObject("Word.Application") # ppt文档转化为pdf文档时使用的格式为32 # self.pptFormatPDF = 32 # self.pptToPDF = CreateObject("Powerpoint.Application") # self.pptToPDF.Visible = 1 # ppt文档转化为pdf文档时使用的格式为32 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5ab079ca329ed7565b1c9eedddb3f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c70c98d018e912d4d12ee15cee0aa5/" rel="bookmark">
			Jenkins&#43;Jmeter&#43;Ant 生成接口测试报告并发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jenkins 是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作；
Jmeter 可以做接口测试，也可以做压力测试，而且是开源软件；
Ant 是基于Java的构建工具，完成脚本执行并收集结果生成报告，可以跨平台。
目录 一. Jmeter + Ant 生成接口测试报告1. Ant安装与环境配置2. Ant配置jmeter3. 修改Ant报告样式 二. Jenkins展示Ant测试报告三. Jenkins 发送测试报告邮件1. 邮箱开启SMTP服务2. jenkins全局邮件配置3. 测试能否收到jenkins发送的邮件4. 单独项目邮件配置 注：以下操作均基于Windows环境，且已经安装配置好Jmeter。
一. Jmeter + Ant 生成接口测试报告 1. Ant安装与环境配置 下载Ant，地址：http://ant.apache.org/bindownload.cgi
安装Ant，将下载后的压缩包直接解压到本地，我这里是解压到在D盘新建的ant目录下；
配置环境变量，在系统变量下新建变量ANT_HOME，值填ant的解压路径D:\ant\apache-ant-1.10.12；在系统变量Path下添加%ANT_HOME%\bin；
验证安装结果，打开cmd，输入ant -v，如返回版本信息则证明安装成功；
2. Ant配置jmeter 将jmeter extras目录下的ant-jmeter-1.1.1.jar文件拷贝到ant安装目录的lib文件夹中；
在桌面新建的txt文件，并将文件改名为build.xml，修改文件里的内容如下： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project name="ant-jmeter-test" default="run" basedir="."&gt; &lt;tstamp&gt; &lt;format property="time" pattern="yyyyMMddhhmm" /&gt; &lt;/tstamp&gt; &lt;!-- 需要改成自己本地的 Jmeter 目录--&gt; &lt;property name="jmeter.home" value="D:\apache-jmeter-5.4.3" /&gt; &lt;!-- jmeter生成jtl格式的结果报告的路径--&gt; &lt;property name="jmeter.result.jtl.dir" value="D:\ant\jtl-report" /&gt; &lt;!-- jmeter生成html格式的结果报告的路径--&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c70c98d018e912d4d12ee15cee0aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7b11bebeecbb90bbfa57ddbf386003/" rel="bookmark">
			开了vp*未关闭软件关机电脑无法连接网络解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 win+R 输入
inetcpl.cpl 接下来依次点击
连接-局域网设置
勾选 使用自动配置脚本 取消勾选为LAN使用代理服务器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34cdcea638ce04e3bc5da6405ee0ef4/" rel="bookmark">
			关于sql server 2019 安装目录所在分区自动写满的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于sql server 2019 安装目录所在分区自动写满的问题 解决方案[[1]]停止PolyBase 相关服务如需长时间运行PolyBase相关服务 解决方案[1] 找到sql server 2019 的安装目录，如：X:\Microsoft Sql Server。其中，X:\是根目录。在sql server 2019 的安装目录X:\Microsoft Sql Server下，找到路径：
MSSQL15.MSSQLSERVER\Log\PolyBase\dump
删除除.log文件外的所有文件。这些文件是PolyBase 相关服务产生的日志，单个将近500MB。 停止PolyBase 相关服务 1.PolyBase用于Sql Server 与外部数据源的通信 。所以，不做分布式开发，不需要启动PolyBase相关服务。
2. Sql Server 服务是Sql Server Polybase 数据移动服务（用于管理 SQL Server 和外部数据源之间的通信和数据传输） 和Sql Server Polybase 引擎服务（用于创建、协调和执行针对外部数据源的并行查询计划）的依赖项，这两个服务不停止，Sql Server服务将无法停止。
3. Sql Server Polybase 数据移动服务 和Sql Server Polybase 引擎服务如果设为自动，则运行后，将无法通过手动停止。
4. 如果要阻止PolyBase 服务写入日志，应当停止Sql Server Polybase 数据移动服务 和Sql Server Polybase 引擎服务.
5. 如果Sql Server Polybase 数据移动服务 和Sql Server Polybase 引擎服务已设为自动，则应先分别将其属性设为手动，然后重启计算机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34cdcea638ce04e3bc5da6405ee0ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d1280898a22bc620e4195d9de77662/" rel="bookmark">
			OD&#43;IDA动静结合反编译C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求
流程
1.内存搜索
2.定位内存位置
3.搜索引用内存地址的代码
4.给该位置下断点
5.内存代码和exe静态程序地址的映射
6.使用静态反编译出C++代码
小技巧：静态编译工具定位到起始位置 总结
需求 C++编译出来的hello world函数，如果没有源码，如何定位还原到exe当中的汇编代码位置？软件逆向动静态结合如何操作？
流程 1.内存搜索 输入你所看到的字符串：
2.定位内存位置 3.搜索引用内存地址的代码 4.给该位置下断点 5.内存代码和exe静态程序地址的映射 IDA(Ghidra)导出的EXE程序地址是0x401000，而使用OD(X32dbg)动态调试看到的地址是0xEA1000，目前看到的helloword程序，是原样搬过去一一对应的。那么看到内存地址把EA改为40，就是静态程序地址了。
磁盘地址和内存镜像的对应关系 6.使用静态反编译出C++代码 在IDA（Ghidra）中，可以对汇编代码进行反编译，它们的功能还是很强大的。
小技巧：静态编译工具定位到起始位置 在IDA中，通过view--&gt;open subviews---&gt;Segments,可以看到真实程序起始点：
但是程序起始端，并不一定是main，要看一下点跳转。另外一种方法是，在function windows里，启动Quick filter来查找特定函数：
弹出搜索框，输入main（或你想找的函数）：
Ghidra的界面这些入口位置就直接在主界面有，按照下面的两个方法都可以找到程序起始点：
总结 通过正向编译，知道要找的东西，在逆向过程中，就可以有的放矢的去观察，了解工具的使用方法和编译原理，数据的追踪线路，再去查找无源码的程序，就有思路了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e5b7bde5129a1218bf9c16aa41ed1e/" rel="bookmark">
			lqr控制和模糊控制三级倒立摆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最优状态合成技术设计
利用最优控制器设计中得到的利用matlab计算出增益矩阵K。 K=[-24.4949 268.8171 -409.6073 1020.9366 -36.4773 13.9474 -23.6236 161.8276]
利用K对三级倒立摆的8个状态变量进行合成，使其合成两个变量，即将合成综合变量E，合成综合变量变化率EC。 利用矩阵X的2-范数构造融合函数
将输入变量x进行降维处理后的E，EC： 三级倒立摆模糊控制器的设计
根据经过状态变量融合后的三级倒立摆系统的输入变量为2个，即E，EC，我们选择使用二维模糊控制器对系统进行控制，然后按照之前介绍的设计模糊控制器的主要步骤进行以下步骤：
（1）确定模糊子集，选择隶属函数。对于输入变量E、EC，输出变量Y选择论域范围均为［-6,6］。每个变量的论域分为7个模糊子集，分别表示为NL，NM，NS，ZE，PS，PM，PL，依次表示“负大”，“负中”，“负小”，“零”，“正大”，“正中”，“正小”这七个语言值。隶属函数均选择“三角形”的隶属函数，并且论域上均作等距划分
（2）制定模糊规则。根据输入输出论域的模糊语言变量的划分，设计模糊规则如表。
模糊规则表
EC E
NL
NM
NS
ZE
PS
PM
PL
NL
NL
NL
NM
NM
NS
NS
ZE
NM
NL
NM
NM
NS
NS
ZE
PS
NS
NM
NM
NS
NS
ZE
PS
PS
ZE
NM
NS
NS
ZE
PS
PS
PM
PS
NS
NS
ZE
PS
PS
PM
PM
PM
NS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e5b7bde5129a1218bf9c16aa41ed1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe1a0a13bfea4b08adcfe882a7642a2/" rel="bookmark">
			Spring Boot使用qq邮箱实现验证码发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取授权码 登录qq邮箱，点击【设置】——》》【账户】
下滑至下图所示位置，点击开启，按要求发送短信验证码
！！！
记录图中的授权码，下面一步会用到
2、配置yml文件 spring: mail: # 配置 SMTP 服务器地址 host: smtp.qq.com # 发送者邮箱 username: xxxxxxxxx@qq.com # 配置密码，注意不是真正的密码，而是刚刚申请到的授权码 password: ********** # 端口号465或587 port: 587 # 默认的邮件编码为UTF-8 default-encoding: UTF-8 # 配置SSL 加密工厂 properties: mail: smtp: socketFactoryClass: javax.net.ssl.SSLSocketFactory #表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误 debug: true 3、添加并刷新maven依赖 &lt;!--qq邮箱--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; 4、编写controller层 import org.springframework.beans.factory.annotation.Value; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import java.util.Random; @RestController @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe1a0a13bfea4b08adcfe882a7642a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338f0c6e8d2e74bc69b48b50c447c92d/" rel="bookmark">
			Spring Boot 中常用的工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 springboot内置工具类 二、 BeanUtils工具 BeanUtil是一个常用的在对象之间复制数据的工具类，著名的web开发框架struts就是依赖于它进行ActionForm的创建。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9ab2fc82f359de70b4161cfb0ccc5a/" rel="bookmark">
			org.apache.ibatis.binding.BindingException: Invalid bound statement (not found):的三种解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用mybatis-plus自定义SQL的时候，没有使用注解方式，而是将SQL语句写在mappper.xml文件中，就报了这个错：org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 说某个方法没找到。
原因：maven默认加载机制，只会把src/main/java文件夹中的java类型文件进行加载，其他类型文件不会加载
解决方式：
方式一：手动复制xml文件到target目录 方式二：将xml文件放到resources目录下 注意：xml目录放到resources目录后，mapper目录下的xml目录就不需要了，记得删除。
方式三：通过配置文件 1、在pom文件中添加如下代码：将xml也打包到项目中
&lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2、在properties配置文件中添加如下配置
#配置mapper xml文件的路径 mybatis-plus.mapper-locations=classpath:com/guli/edu/mapper/xml/*.xml 你更喜欢哪一种解决方式呢？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b17157f44f3f283f1f1d09173d3270/" rel="bookmark">
			Dockerfile文件解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先来看一个简单的 Dockerfile #这个Dockerfile作用是打一个python3项目环境 FROM python:3-alpine WORKDIR /app ADD . /app RUN pip3 install -r requirements.txt -i https://pypi.douban.com/simple CMD ["python3", "main.py"] #这个Dockerfile作用Dockerfile部署django项目 FROM centos:7 MAINTAINER annlin ADD requeriments.txt /home WORKDIR /home RUN yum update &amp;&amp; yum -y install mysql &amp;&amp; yum -y install python3-pip &amp;&amp; pip3 install -r requirements.txt ADD autoTest /home/ WORKDIR /home/autoTest EXPOSE 8000 ENTRYPOINT uwsgi --ini uwsgi.ini 二、Dockerfile 编写规则 指令大小写不敏感，为了区分习惯上用大写Dockerfile 非注释行第一行必须是 FROM文件名必须是 DockerfileDockerfile 指定一个专门的目录为工作空间所有引入映射的文件必须在这个工作空间目录下Dockerfile 工作空间目录下支持隐藏文件(.dockeringore)(.dockeringore)作用是用于存放不需要打包导入镜像的文件，根目录就是工作空间目录每一条指令都会生成一个镜像层，镜像层多了执行效率就慢，能写成一条指定的就写成一条 三、Dockerfile 指令详解 1、FROM：基础镜像 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b17157f44f3f283f1f1d09173d3270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2c7f95590d2fb9b6ce6dc3470ed611/" rel="bookmark">
			创建ingress报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建ingress报错
Error from server (InternalError): error when creating “nginx-ingress.yaml”: Internal error occurred: failed calling webhook “validate.nginx.ingress.kubernetes.io”: Post “https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s”: x509: certificate has expired or is not yet valid
# Find name of the ingress-nginx-admission resource kubectl get -A ValidatingWebhookConfiguration # Delete it kubectl delete -A ValidatingWebhookConfiguration &lt;name&gt; # Example: kubectl delete -A ValidatingWebhookConfiguration foobar-ingress-nginx-admission 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b5c2d483b272c95624a7c297a86143/" rel="bookmark">
			修复Chroot环境下APT包管理对systemd环境识别问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，转载请注明出处。
前言 近期在折腾Chroot环境下的设备时，发现软件包无法更新，得到以下错误：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (Reading database ... 77272 files and directories currently installed.) Preparing to unpack .../mariadb-server-10.3_1%3a10.3.34-0ubuntu0.20.04.1_arm64.deb ... Running in chroot, ignoring request. /usr/sbin/invoke-rc.d: 551: rc-service: not found invoke-rc.d: initscript mysql, action "stop" failed. dpkg: warning: old mariadb-server-10.3 package pre-removal script subprocess returned error exit status 127 dpkg: trying script from the new package instead .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b5c2d483b272c95624a7c297a86143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2247833fbbc9369485fe2af576f10423/" rel="bookmark">
			智能优化算法——遗传算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法 一种仿生全局优化算法
模拟生物的遗传进化原理，通过选择、交叉与变异等操作机制，使种群中个体的适应性不断提高
1、基本思想及应用领域 核心思想：物竞天择，适者生存 优点： 良好的并行性（操作对象是一组可行解，搜索轨道有多条） 强大的通用性（只需要利用目标的取值信息，无需梯度等高价值信息） 良好的全局优化性和鲁棒性 良好的可操作性 缺点： 未成熟收敛问题 收敛速度较慢，算法实时性欠佳 应用领域： （1）函数优化（经典优化）
（2）组合优化（旅行商问题——已成为衡量算法优劣的标准、背包问题、装箱问题等）
（3）生产调度问题
（4）自动控制
（5）机器人智能控制（移动机器人路径规划、关节机器人运动轨迹规划、机器人逆运动学求解）
（6）图像处理和模式识别（图像恢复、图像边缘特征提取、几何形状识别）
（7）机器学习（将GA用于知识获取，构建基于GA的机器学习系统）
2、基本流程 3、遗传算法中的若干概念 个体：表示可行解 种群：表示可行解集 适应度函数：衡量某个个体的适应度高低 编码【关键步骤】：将一个待求解的问题的实际可行解从其解空间转换到遗传算法所能处理的搜索空间（即个体空间）的过程，就叫编码 常用的遗传算法编码方法：二进制编码、浮点数编码等 二进制编码比浮点数编码搜索能力强，但是浮点数编码比二进制编码在变异操作上能够保持更好的种群多样性。 解码：编码的逆过程，将遗传算法所搜索到的最优个体的染色体转换成待求解问题的实际最优解的过程 确定各遗传具体操作方法： （1）选择算子和选择操作 个体选择概率常用分配方法：一般用第一种
按比例的适应度分配（选择的蒙特卡罗方法） 利用比例于各个个体适应度的概率决定其子孙的遗留可能性
若某个个体 i，其适应度为 fi，则其被选取的概率表示为，
显然选择概率越大的个体，能多次被选中，他的遗传因子就会在种群中扩大。
基于排序的适应度分配 在基于排序的适应度分配中，种群按目标值进行排序。适应度仅仅取决于个体在种群中的序位，而不是实际的目标值。
排序方法表现出更好的鲁棒性，能在一定程度上客服比例适应度计算的尺度问题和过早收敛问题。
（2）常用的选择算法 详细介绍 轮盘赌选择法、随机遍历抽样法、局部选择法、截断选择法、锦标赛选择法
（3）交叉率及交叉操作（基因重组） 交叉是遗传算法获取新的优良个体的最重要的手段，决定了遗传算法的全局搜索能力。交叉率的选择决定了交叉的频率。
较大的交叉率使各代充分交叉，但群体中的优良模式遭到破坏的可能性增大，以致产生较大的代沟，从而使搜索走向随机化；
交叉率越低，产生的代沟越小，就会使得更多的个体直接复制到下一代，遗传搜索可能陷入停滞状态，一般建议取值范围0.4~0.9
常用的交叉方法：单点交叉、多点交叉、均匀交叉、部分匹配交叉、顺序交叉、洗牌交叉等 单点交叉：
（4）变异率及变异操作 一般来说，随机产生的概率大于变异率就会触发变异操作
变异率一般可取0.001~0.1。变异率不能取得太大，如果大于0.5，遗传算法就会退化为随机搜索。
常用的变异操作：实值变异法和二进制变异法
（5）确定遗传算法的有关运行参数，包括群体规模、迭代次数（100·500）、选择算子、交叉率、变异率等 群体规模：一般为20~100
（1）取值较小，提高运算和收敛速度，但会降低群体多样性，可能会引起早熟现象
（2）取值较大，含有较多模式，可以提高GA搜索质量，但是计算量增大，收敛速度降低
4、会出现的问题 （1）未成熟收敛
当遗传算法还没找到全局最优解或者满意解时，群体中不能再产生性能超过父代的后代，群体中的各个个体非常相似。未成熟收敛的重要特征是群体中个体结构的多样性急剧减少。这种现象很常见
（2）原因：
理论上考虑的选择、交叉和变异操作都是绝对精确的，他们相互协调，能搜索到整个解空间，但实际不然；
存在随机误差（主要是取样误差和选择误差）；
所求解的问题是遗传算法欺骗问题；
（3）解决：
重新启动、匹配策略、重组策略、替代策略
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d95dbb087260ffba35774a36cf754358/" rel="bookmark">
			(zichao)ES6笔记（仅作简单整理，未深入探究）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、ECMASript（一）什么是 ECMA（二）什么是 ECMAScript（三）为什么要学习 ES6 二、let 关键字和const 关键字（一）let 关键字（二）const 关键字 三、变量的解构赋值（一）数组的解构赋值（二）对象的解构赋值 四、模板字符串五、简化对象写法六、箭头函数八、rest 参数九、spread 扩展运算符十、Symbol（一）Symbol 基本使用（二）Symbol 内置值 十一、迭代器十二、生成器十三、Promise十四、Set和Map（一）Set（二）Map 十五、class 类十六、数值扩展（一）二进制和八进制（二）Number.isFinite() 与 Number.isNaN()（三）Number.parseInt() 与 Number.parseFloat()（四）Math.trunc（五）Number.isInteger 十七、对象扩展十八、模块化（一）模块化的好处（二）模块化规范产品（三）ES6 模块化语法 一、ECMASript （一）什么是 ECMA ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。
（二）什么是 ECMAScript ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。
（三）为什么要学习 ES6 ES6 的版本变动内容最多，具有里程碑意义ES6 加入许多新的语法特性，编程实现更简单、高效ES6 是前端发展趋势，就业必备技能 二、let 关键字和const 关键字 （一）let 关键字 let 关键字用来声明变量，使用 let 声明的变量有几个特点
不允许重复声明块儿级作用域不存在变量提升不影响作用域链 总结：以后声明变量使用 let 就对了
（二）const 关键字 const 关键字用来声明常量，const 声明有以下特点
声明必须赋初始值标识符一般为大写不允许重复声明值不允许修改块儿级作用域对象属性修改和数组元素变化不会出发 const 错误 总结：声明对象类型使用 const，非对象类型声明选择 let
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d95dbb087260ffba35774a36cf754358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38caa9a4346e37a2b12cd525e17491f/" rel="bookmark">
			vue3 子组件向父组件传递参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.父传子
父组件：在子组件上通过 v-bind绑定属性
子组件：先定义下基本类型，然后通过setup的第一个参数取获取传过来的值
2.子传父
父组件：在子组件上绑定一个事件，并定义回调
子组件：通过setup的第二个参数去接受，第二个参数包含了（attrs，emit，slots），这里我们用到第二个emit去传值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c08f2f217760648145d35d29215fc4/" rel="bookmark">
			前端面试题目总结（HTML、CSS、JS、VUE、HTTP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HMTL 1、行内元素、块级元素、空元素 (1)行内元素：&lt;span&gt;、&lt;a&gt;、&lt;img&gt;、&lt;input&gt;、&lt;strong&gt;
(2)块级元素：&lt;div&gt;、&lt;h1-6&gt;、&lt;p&gt;、&lt;table&gt;、&lt;form&gt;
(3)空元素：&lt;br&gt;、&lt;hr&gt;、&lt;meta&gt;
如何设计元素之间的转换?
(1)display:block转为块元素，独占一行，行宽高、外边距、内边距都可以设置
(2)display:inline-block：转为行内块元素，和相邻的行内元素在一行上，
但是中间会有空白的间隙，行宽高、外边距、内边距都可以设置
(3)display:inline：转为行内元素，不占独立成行，仅靠字体大小或图像大小支撑，
宽高不能设置，水平方向可以设置内外边距，垂直方向不可以
2、link和@import的区别 (1)引用区别：link属于html标签，@import在css中使用表示导入外部样式表
(2)最大的区别就是：因为link是一个标签，所以页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载
(3)兼容问题：link是HTML标签，无兼容问题。而import只在IE5以上才能识别
3、titile与h1的区别、b与strong的区别、i与em的区别 (1)title是网页标题、h1是内容。在做网站的SEO（Search Engine Optimization）搜索引擎优化中，titile优先于h1。
(2)语义化，b只是一个加粗的标签没有特殊含义，strong也是一个加粗标签但有特殊含义（强调在阅读器、SEO中显示出来）。
(3)语义化，i和em都是倾斜，i没有特殊含义，而em有特殊含义，i一般来做图标。
4、img标签的titile和alt的区别 (1)titile：鼠标移入显示的问题。alt：图片没有加载显示文字
(2)在SEO中alt属性是可以解决蜘蛛抓取不到图片的问题
5、png、jpg、png、gif什么时候用 (1)jpg、jpeg：适合大图片（缩小会失帧）
(2)png：适合小图标（缩小不容易失帧）
(3)gif：动图
6、HTML5新特性 HTML5就是超文本语言的第五次重大修改
第一个是语义化标签，header、nav、section、article、aside、footer，这样编程会更规范清晰，而且引擎搜索优化会更加方便
第二个是表单功能增强，类型email、number、range、search、date等、属性required、multiple等
第三个是音视频标签，viedo是音频、audio是视频
第四个是Canvas画布和SVG矢量图
第五个是拖放，Drag和Drop，任何元素都可以拖放
第六个是本地存储，localStroage和sessionStorage
2、CSS 1、两种盒子模型 一种是标准盒子模型（content-box），一种是IE盒子模型（border-box）
主要区别是宽度和高度，
标准盒子模型的宽度就是内容（content）的宽度。
IE盒子模型的宽度就是（content+padding+border）的宽度。
如果想转换为IE盒子模型，可以使用：box-sizing:border-box；
2、实现水平垂直居中的方式 1、flex布局：justify-content水平居中，align-items垂直居中
2、grid布局：justify-content水平居中，align-items垂直居中
3、容器relative+内容absolute+transform
3、什么是BFC BFC是Block-formattng-context的简写，就是块级格式化上下文。
简单来说，BFC是一个完全独立的空间，就是让空间里的子元素不会影响到外面的布局。
如何触发BFC？
1、float:left/right/top/bottom
2、overflow:hidden
3、display:inline-block/flex
4、position:absolute/fixed
BFC解决的问题：
1、使用float脱离文档流，高度塌陷
2、解决margain边框重叠
3、阻止元素被浮动元素覆盖
4、position定位 (1)static(默认)，没有定位，元素不需要定位的时候，就默认即可。
(2)fixed(固定)，相对于浏览器窗口,适用于顶部导航栏，或者返回顶部
(3)absolute(绝对)，相对于第一个relative父元素，适合解决abosulte脱离文档流覆盖问题
(4)relative(相对)，相对于自身定位
aboslute与relative的区别：
(1)realtive不脱离文档流，absolute脱离文档流。所以realtive适合做absolute的容器
(2)relative只有两个值（left、right、top、bottom）如果同时存在，left会取代right，top取代bottom。而absolute可以取四个值
5、display:none与visibility:hidden的区别 (1)占位区别：display:none不占位置，visibility:hidden占位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c08f2f217760648145d35d29215fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748b4447e4de80bb9f2a6af85787168f/" rel="bookmark">
			google 原生控件TabLayout 文字单行显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似于上面的图中,文字过长的,如果不做处理的话,其实是会两行显示,看源码,默认的最大行数是2
所以直接用反射,修改这个变量
val tab = tab_layout.newTab().setText("哈哈") try { // 单行显示 val view = tab.view val clas = view.javaClass val field = clas.getDeclaredField("defaultMaxLines") field.isAccessible = true field.setInt(view, 1) } catch (e: Exception) {} tab_layout.addTab(tab) 在添加tab的时候去修改这个字段,最重要的还得设置最大的宽度
app:tabMaxWidth="100dp" 以下是我的有关xml代码
&lt;com.google.android.material.tabs.TabLayout android:id="@+id/tab_layout" app:tabMode="scrollable" app:tabIndicatorGravity="top" app:tabIndicatorFullWidth="false" app:tabMaxWidth="100dp" app:tabIndicator="@drawable/common_tab_indicator" app:tabIndicatorColor="@color/color_22C05E" app:tabTextColor="@color/color_484848" app:tabSelectedTextColor="@color/color_22C05E" app:tabTextAppearance="@style/CommonTabTextStyle" app:tabRippleColor="@android:color/transparent" app:tabBackground="@android:color/transparent" android:layout_width="match_parent" android:layout_height="44dp"/&gt; common_tab_indicator &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:width="30dp" android:height="4dp" android:gravity="center"&gt; &lt;shape&gt; &lt;corners android:radius="2dp" /&gt; &lt;!--color无效，源码用tabIndicatorColor--&gt; &lt;solid android:color="@color/colorPrimary" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; CommonTabTextStyle &lt;style name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/748b4447e4de80bb9f2a6af85787168f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/143/">«</a>
	<span class="pagination__item pagination__item--current">144/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/145/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>