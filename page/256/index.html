<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355255fa2e1e4800ad347d819900cc6d/" rel="bookmark">
			锦上添花：C &#43;&#43;标准库应该包含什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是对盖伊·戴维森（Guy Davidson）的文章“不包括电池：C ++标准库中应包含的内容”的答复。 ”。 在过去的几年中，一直在推动将图形库包含在C ++标准中。 这有点像开罗。 或SDL。 当前形式的提案在这里 。 在目前的状态下，图书馆提案可以在预先分配的表面上绘制一些形状，对图像有一定的支持，并且有一些课程项目可以添加文本，也许可以以鼠标/键盘处理的形式进行输入。 图书馆的主要目标似乎是教学。 提出的论点是，对于孩子来说，在屏幕上闪闪发光的小精灵很酷很酷。 当然，已经存在执行此操作的库，还有更多，但是您会看到，C ++没有像样的，惯用的软件包管理器，因此，当然，一些著名的委员会成员得出的结论是，C ++标准应该提供2D图形库。的盒子。 我确实认为这是一条不应走的路，这样做最多是在浪费时间。 让我来告诉你为什么。 但是，首先，需要进行一些澄清。 盖伊·戴维森（Guy Davidson）和其他人为此付出了大量的工作，时间和精力。 推动该提案通过标准化的人们比我以前的专家要多得多。 我没有为C ++做任何贡献，所以接下来的事情只是一个人的意见。 我还想明确指出，我对该图书馆没有负面意见。 我的问题是，此时需要包含2D绘画库，即C ++标准中的任何绘画库。 希望我不会被误解！ 无论如何，让我们开始吧。 C ++标准库不是库。 C ++标准的确切含义是：规范明确的文档，以最详细，明确的方式描述C ++的含义以及其工作方式。 目标是任何人都可以通过实现该规范来自己实现C ++编译器。 但是，恰恰是该规范不够具体，或者实施得不太正确，或者执行得很周到，因此各种C ++编译器最终在行为上各不相同。 有时根本无法实施，因为执行实施的人员和执行规范的人员忘记了彼此交谈。 现在，该规范的很大一部分描述了标准模板库，这是每个符合要求的编译器附带的库。 该规范至少存在5种实现，由许多实体维护。 有些是开源的，有些则不是。 它们每个都在选定的平台和系统子集中工作。 即使它们位于任何C ++程序的最底层，也像其他任何库一样，也容易出现错误。 在这种情况下，C ++标准库中应该包含或不应该包含什么是一个非常重要的问题。 与编译器捆绑在一起的标准配件是什么？ 大多数人需要什么才能使C ++高效？ 盖伊的文章描述了一个人可以拥有的职位。 也许我们什么都不需要？ 也许我们需要一些词汇类型？ 也许是容器？ 也许不会 ？ 我们需要文件系统支持吗？ 插座？ json吗？ XML？ rpg制作工具？ sql？ HTML？ javascript vm吗？ 2D图形？ 3D图形？ 肥皂 ？ IPC？ 窗口化？ 应该定义pi吗？ 那websockets呢？ FTP？ ssh？ VR？ AR？ 加密货币？ ssl？ 我们需要ssl但不需要其他加密货币吗？ 深度学习？ 声音？ 3D音效？ 视频解码？ gif？ 显然，我们需要画一条线。 某个地方？ 在哪 让我们看看.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/355255fa2e1e4800ad347d819900cc6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a210ef4e18cf49915e12650e452f7e1/" rel="bookmark">
			51单片机实现LED流水灯(数组方式和位运算方式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /* 名称:51单片机实现LED流水灯(数组方式和位运算方式)
说明:今天又重新开始系统的学习51了，LED就算个开端吧。 要注意两点: 1、sfr和sbit是C语言扩展出来的关键字。其中sfr用于对特殊功能寄存器进行声明，sbit用于对某些特殊功能寄存器的某位进行声明。这里和宏定义很相似，但是不能用宏定义进行替换，对于前者是因为51单片机的寄存器存在于内部空间0x80-0xFF，这空间属于直接寻址，51特殊功能寄存只能直接寻址，不能间接寻址。如果用宏定义的话，在翻译成汇编时就会认为是通过总线访问对应的外部地址了。对于后者，sbit是定义一个标志位，也叫位变量。而类似于#define key1 P3^0就说不通了。
2.对于一般的二极管LED来说，驱动其发光的电流一般为5-30mA。所以一般的发光二极管都接成灌电流的形式,(即电流是流入单片机的,使其对应位为低电平)。但是我用的开发板用的却不是这种形式，(在这里是高电平对应的二极管工作。)但是51单片机IO口输出的电流大小只有1-2mA，为什么足以驱动二极管发光呢(私自以为是中间接了一些能够放大电流的东西)？ */
#include &lt;reg52.h&gt; #define uchar unsigned char //延时函数 void delay_ms(unsigned int n) { unsigned int i=0,j=0; for(i=0;i&lt;n;i++) for(j=0;j&lt;123;j++); } //以数组方式实现流水灯 void LEDlightByArray() { uchar _data[8] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; uchar i = 0; while(1) { for(i = 0;i&lt;8;++i) { P2 = _data[i]; delay_ms(1000); } } } //利用位运算实现流水灯 void LEDlightByBitOpe() { uchar i = 0; while(1) { P2 = 0x01; for(i = 0;i&lt;8;++i) { delay_ms(1000); P2 = P2&lt;&lt;1; } } } int main() { //LEDlightByArray(); LEDlightByBitOpe(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0bbf058a3a8568591a4f275fd817cf/" rel="bookmark">
			微信小程序视图示例之view/scroll-view示例中缺少css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在参考微信小程序的视图示例时，发现给的示例view和scroll-view缺少对应的css，整理一下给有需要的同学参考下：
View 对应官方文档: https://mp.weixin.qq.com/debug/wxadoc/dev/component/view.html
直接使用view示例代码，发现不能达到预期效果，如图中左边所示：
是因为示例中只有wxml代码，相应的wxss代码没有给出，
.flex-wrp { white-space: nowrap; display:flex; } .section__title { background: #fbf9fe; width: 100%; height: 50px; } .flex-item { width: 150px; height: 150px; } .bc_green { background: green; } .bc_red { background: red; } .bc_blue { background: blue; } 添加对应的wxss后，则效果如下：
Scroll-View 对应官方文档: https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html
直接使用示例代码缺少css文件，效果如下：
添加对应的wxss文件：
.btn-area button { width: 100%; } .section__title { background: #fbf9fe; width: 100%; height: 50px; } .scroll-view-item { width: 100%; height: 100px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0bbf058a3a8568591a4f275fd817cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7771bc0f0108c00d62b4529a3e89e3/" rel="bookmark">
			java面试官如何面试别人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java面试官如何面试别人(一) java面试官的“面试心得” 在公司当技术面试官几年间，从应届生到工作十几年的应聘者都遇到过。先表达一下我自己对面试的观点： 1.笔试、面试去评价一个人肯定是不够准确的，了解一个人最准确的方式就是“路遥知马力，日久见人心”。通过一、二个小时内的做题、交流，只是没有其他办法下进行的无奈之举，所以通过了面试不代表有多成功，没通过也不代表有多失败。 2.好的面试官本身交谈的时候就不应当把自己一个居高临下的角色上，应当把自己和应聘者当做两个做技术的人平等的交流，把自己当作权威往往就会受到观点的角度、语言表达、工作领域的惯性的制约。 3.好的考察题目则是大家能经常接触，不同层次的人能有不同层次的答案，能从问题引申出后面继续讨论的话题。 举个例子抛砖引玉，下面这个问题是我以前常问的，从应届生到工作十几年的人都问过： 引用 “地球人都知道，Java有个东西叫垃圾收集器，它让创建的对象不需要像c/cpp那样delete、free掉，你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情?” 我自己分析一下这个问题，首先是“什么时候”，不同层次的回答从低到高排列： 1.系统空闲的时候。 分析：这种回答大约占30%，遇到的话一般我就会准备转向别的话题，譬如算法、譬如SSH看看能否发掘一些他擅长的其他方面。 2.系统自身决定，不可预测的时间/调用System.gc()的时候。 分析：这种回答大约占55%，大部分应届生都能回答到这个答案，起码不能算错误是吧，后续应当细分一下到底是语言表述导致答案太笼统，还是本身就只有这样一个模糊的认识。 3.能说出新生代、老年代结构，能提出minor gc/full gc 分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。这部分不足10%。 4.能说明minorgc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。 分析：列举一些我期望的回答：eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc;gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过 MaxTenuringThreshold控制进入老年前生存次数等……能回答道这个阶段就会给我带来比较高的期望了，当然面试的时候正常人都不会记得每 个参数的拼写，我自己写这段话的时候也是翻过手册的。回答道这部分的小于2%。 PS：加起来不到100%，是因为有确实少数直接说不知道，或者直接拒绝回答的= =# 分析第二个问题：“对什么东西”： 1.不使用的对象。 分析：相当于没有回答，问题就是在问什么对象才是“不使用的对象”。大约占30%。 2.超出作用域的对象/引用计数为空的对象。 分析：这2个回答站了60%，相当高的比例，估计学校教java的时候老师就是这样教的。第一个回答没有解决我的疑问，gc到底怎么判断哪些对象在不在作 用域的?至于引用计数来判断对象是否可收集的，我可以会补充一个下面这个例子让面试者分析一下obj1、obj2是否会被GC掉? class C{ publicObject x; } C obj1、obj2= new C(); obj1.x = obj2; obj2.x = obj1; obj1、obj2= null; 3.从gcroot开始搜索，搜索不到的对象。 分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。 PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。 4.从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。 最后由一个问题：“做什么事情”，这个问发挥的空间就太大了，不同年代、不同收集器的动作非常多。 1.删除不使用的对象，腾出内存空间。 分析：同问题2第一点。40%。 2.补充一些诸如停止其他线程执行、运行finalize等的说明。 分析：起码把问题具体化了一些，如果像答案1那样我很难在回答中找到话题继续展开，大约占40%的人。 补充一点题外话，面试时我最怕遇到的回答就是“这个问题我说不上来，但是遇到的时候我上网搜一下能做出来”。做程序开发确实不是去锻炼茴香豆的“茴”有几 种写法，不死记硬背我同意，我不会纠语法、单词，但是多少你说个思路呀，要直接回答一个上网搜，我完全没办法从中获取可以评价应聘者的信息，也很难从回答 中继续发掘话题展开讨论。建议大家尽量回答引向自己熟悉的，可讨论的领域，展现给面试官最擅长的一面。 3.能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。 分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。 4.除了3外，还能讲清楚串行、并行(整理/不整理碎片)、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。 分析：同上面2个问题的第四点。 最后介绍一下自己的背景，在一间不大不小的上市软件公司担任平台架构师，有3年左右的面试官经验，工作主要方向是大规模企业级应用，参与过若干个亿元级的项目的底层架构工作。 java面试官如何面试别人(二) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7771bc0f0108c00d62b4529a3e89e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e711f722e05b22b5292e9881149cf7/" rel="bookmark">
			Mysql查询某字段值重复的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询user表中，user_name字段值重复的数据及重复次数
select user_name,count(*) as count from user group by user_name having count&gt;1; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e08b7a67d4f4e4f19d8b7e798de0582/" rel="bookmark">
			Unity 中的半透明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说Unity中的渲染顺序，在Unity中改变渲染顺序的方式有四层，第一层为Camera的depth，第二层为Sorting Layers, Canvas可直接在面板中调节，其他的可能需要在脚本中设置，第三层为shader中的渲染队列，第四层为Pass（Pass的顺序在不同情况下有差别）。
再说半透明，最重要的是渲染顺序，只要渲染顺序正确，透明材质是可以不用关闭深度写入的，即使是多个半透明物体也是一样，另外当多个物体处于相同的渲染队列时，Unity中的透明渲染队列是由后往前渲染的，其余队列都是由前往后渲染。
若是进行双面渲染，要注意的是，若是在一个Pass中完成时会发生渲染顺序混乱的现象，正确的做法是放在两个Pass中，先渲染背面，在渲染正面。
事实上唯一能够最完美解决半透明物体渲染问题的方法是进行片元级的深度排序，不然总是会出现渲染顺序的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4aa89120d8e477fb7741711e5226c7/" rel="bookmark">
			推荐一个文件内容/文件夹的比对软件-WinMerge，附简单用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常对照课件和视频学习的过程中，会遇到一种情况，明明与视频上面敲的一模一样，但是运行就是报错。
这里推荐一个文档对比软件，非常好用。
软件名称：WinMerge
最新版本：WinMerge-2.14.0
作者：Dean P.Grimm
下载地址：http://winmerge.org/
软件特性：可以对比两个文件内容的不同之处，支持行定位和行内定位。
可以对比两个文件夹内有哪些不同的文件。
支持中文界面。
*图片字看不清楚的话，可以使用ctrl加上+进行放大*
0.软件版权信息
1.打开软件界面
2.点击左上角 文件-新建，将自己的文本粘贴进去
3. 点击默认的与对比程序
4.软件会首先会定位到有问题的行，点击图中标记的当前不同按钮（快捷键Alt+Enter）
5.这时软件会在最下方帮你对比两侧代码行内不同的地方
6.在视图-语法高亮 里面，可以设置不同的编程语言，进行语法高亮的显示
7.软件的另外一种用法，点击 文件-打开
8.这里可以浏览文件夹，添加要对比的文件或者文件夹目录，这里就不做详细介绍
9.介绍一下其他辅助功能，软件可以设置不同的字体。
10.还可以生成html报告（类似检测报告），报告中会把不同的地方高亮显示。
11.网页版报告。
12.还有其他辅助的功能，这里就不一一介绍，要是大家有其他工具或者用法，欢迎讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a30fc61c932acad73f522233ff6a902/" rel="bookmark">
			ansible使用playbook批量添加用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 使用playbook添加用户，并添加到组，可以使用sudo
首先先生成密码
pip install passlib python -c "from passlib.hash import sha512_crypt; import getpass; print sha512_crypt.encrypt(getpass.getpass())" 输入密码后，把生成的字符串替换即可
cat useradd.yml --- - hosts: all vars: user: id10086 group: sa password: "$6$rounds=656000$8co.J2OcJlhs3dtX$3UgoddDYZ.z4V.UB6tAbcsIYSquWUKCjt7nM6dc8iPBPLvOeqQezhd0aJj8S3dG4jFUmgbhx/coFfzE70No0." remote_user: root tasks: - name: Add group {{ group }} group: name={{ group }} - name: Add user {{ user }} user: name={{user}} password={{ password }} groups={{ group }} - name: you can use sudo lineinfile: dest=/etc/sudoers state=present line='{{item}}' validate='visudo -cf %s' with_items: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a30fc61c932acad73f522233ff6a902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa708c71d705846b3e2b9f51eb922d48/" rel="bookmark">
			软件开发效率提高反思总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在项目进度进入到前中期，基本框架都稳定了，目前主要在做业务方面的完善。最近的开发效率不如一开始高，这两天总结思考了以下几点：
1、理清业务逻辑、清楚的知道怎么实现功能、要用什么控件、算法，可以的话用思维导图整理（推荐百度脑图），最后在去写代码实现、测试、验证是否完善。
这样做的原理在于：当我们脑海中有明确的画面时，去把画面呈现还原是很简单的。人执行力强的原因就在于在执行过程中不存在未知、不确定因素，一切都是已知的，哗哗地去干就自然执行力强了。在写代码时，当你全部清楚所有的代码怎么写，把它写出来是很easy的事情。俗话说磨刀不误砍柴工。
2、在用vuejs做前端组件化开发时，父组件传给子组件的对象尽可能的少，可以的话最多只传一个对象，在子组件中在进行对象的一系列的操作。
这样做的好处在于：可以简化组件之间的复杂度、容易梳理清逻辑、简化代码、提高代码质量。一开始我也是传了好几个对象，后面业务复杂起来，代码就臃肿混乱，现在是全面改了。
这次就先总结这两点，能不能理解认同取决于每个人的认知高度、是否经历过类似的事情，希望与你共同成长！
以下是一些常用简便方法汇总：
1.开发工具模版配置 已经习惯使用intellij idea 做开发，idea有很多很好的特性能提高开发效率，配置一些常用的模版，就是一个很好的方法。 把常用的，比如log的声明，foreach循环，都可以配置成模版，这样能快速的写出一些常见结构的代码。 2.热部署 热部署HotSwap是一个好东西，不过目前官方的热部署只能支持对body的修改，不能支持对方法签名，类名的修改。使用热部署，我们能方便的调试一些东西，减少部署所花费的时间。可以使用阿里中间件团队提供的HotSwap插件，这个插件支持方法名修改，可以在网上搜到这个插件。 3.常用linux命令配置别名 对于常用的linux命令，我没可以在~/.bash_profile中配置别名，比如有些很长，我没可以配置一个比较简短的别名，能缩短很多时间。比如： alias login="ssh -l root@ip" alias ll ="ls -rtl" 这样我们能方便的把一些长命令缩短，不用担心忘记那些命令了。 4.常用host做配置 我们可能要经常登录一些服务器，如果用ip登录，会比较麻烦，而且ip很难记住，我们在host中自己添加一些映射，就能简单的登录到具体ip。 10.189.111.111 test 5.使用expect免密码登录 例子： [python] view plain copy #!/usr/bin/expect set timeout 30 spawn ssh -l username ip expect "password:" send "password\r" interact 在username中放上自己的username，ip放上自己的ip，password放上自己的密码就可以不用手动输入密码了。 6.使用ssh面密码登录 上面那种方法在本机比较好，但是很多公司有跳板机，我们必须登录到跳板机才能登录到服务器上，如果我们也在跳板机上像上面那么做，会泄漏自己的密码。 我们可以做ssh面密码登录。 方法如下： 1.生成公钥私钥： ssh-keygen -t rsa 输入上面命令后一路回车 2.查看： ls ~/.ssh/ 可以查看生成的公钥私钥：id_rsa id_rsa.pub 3.拷贝到需要免密码登录的机器上： scp ~/.ssh/id_rsa username@ip:~/.ssh/authorized_keys 这样，下次登录，直接 ssh 加上 ip ，就不需要输入密码了，这样不需要在脚本中暴露密码。 思考与行动：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa708c71d705846b3e2b9f51eb922d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96f42dc8017aa757ff050944c1e9c8a/" rel="bookmark">
			技术干货 | 如何做好文本关键词提取？从三种算法说起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据猿导读】 不管是基于文本的推荐还是基于文本的搜索，对于文本关键词的依赖也很大，关键词提取的准确程度直接关系到推荐系统或者搜索系统的最终效果。因此，关键词提取在文本挖掘领域是一个很重要的部分
作者 | 韩信
官网 | www.datayuan.cn
微信公众号ID | datayuancn
在自然语言处理领域，处理海量的文本文件最关键的是要把用户最关心的问题提取出来。而无论是对于长文本还是短文本，往往可以通过几个关键词窥探整个文本的主题思想。与此同时，不管是基于文本的推荐还是基于文本的搜索，对于文本关键词的依赖也很大，关键词提取的准确程度直接关系到推荐系统或者搜索系统的最终效果。因此，关键词提取在文本挖掘领域是一个很重要的部分。
关于文本的关键词提取方法分为有监督、半监督和无监督三种：
1.有监督的关键词抽取算法
它是建关键词抽取算法看作是二分类问题，判断文档中的词或者短语是或者不是关键词。既然是分类问题，就需要提供已经标注好的训练语料，利用训练语料训练关键词提取模型，根据模型对需要抽取关键词的文档进行关键词抽取
2.半监督的关键词提取算法
只需要少量的训练数据，利用这些训练数据构建关键词抽取模型，然后使用模型对新的文本进行关键词提取，对于这些关键词进行人工过滤，将过滤得到的关键词加入训练集，重新训练模型。
3.无监督的方法
不需要人工标注的语料，利用某些方法发现文本中比较重要的词作为关键词，进行关键词抽取。
有监督的文本关键词提取算法需要高昂的人工成本，因此现有的文本关键词提取主要采用适用性较强的无监督关键词抽取。其文本关键词抽取流程如下：
图 1 无监督文本关键词抽取流程图
无监督关键词抽取算法可以分为三大类，基于统计特征的关键词抽取、基于词图模型的关键词抽取和基于主题模型的关键词抽取。
NO.1文本关键词提取算法——基于统计特征的关键词提取算法
基于于统计特征的关键词抽取算法的思想是利用文档中词语的统计信息抽取文档的关键词。通常将文本经过预处理得到候选词语的集合，然后采用特征值量化的方式从候选集合中得到关键词。基于统计特征的关键词抽取方法的关键是采用什么样的特征值量化指标的方式，目前常用的有三类：
1基于词权重的特征量化
基于词权重的特征量化主要包括词性、词频、逆向文档频率、相对词频、词长等。
2基于词的文档位置的特征量化
这种特征量化方式是根据文章不同位置的句子对文档的重要性不同的假设来进行的。通常，文章的前N个词、后N个词、段首、段尾、标题、引言等位置的词具有代表性，这些词作为关键词可以表达整个的主题。
3基于词的关联信息的特征量化
词的关联信息是指词与词、词与文档的关联程度信息，包括互信息、hits值、贡献度、依存度、TF-IDF值等。
下面介绍几种常用的特征值量化指标。
词性
词性时通过分词、语法分析后得到的结果。现有的关键词中，绝大多数关键词为名词或者动名词。一般情况下，名词与其他词性相比更能表达一篇文章的主要思想。但是，词性作为特征量化的指标，一般与其他指标结合使用。
词频
词频表示一个词在文本中出现的频率。一般我们认为，如果一个词在文本中出现的越是频繁，那么这个词就越有可能作为文章的核心词。词频简单地统计了词在文本中出现的次数，但是，只依靠词频所得到的关键词有很大的不确定性，对于长度比较长的文本，这个方法会有很大的噪音。
位置信息
一般情况下，词出现的位置对于词来说有着很大的价值。例如，标题、摘要本身就是作者概括出的文章的中心思想，因此出现在这些地方的词具有一定的代表性，更可能成为关键词。但是，因为每个作者的习惯不同，写作方式不同，关键句子的位置也会有所不同，所以这也是一种很宽泛的得到关键词的方法，一般情况下不会单独使用。
互信息
互信息是信息论中概念，是变量之间相互依赖的度量。互信息并不局限于实值随机变量，它更加一般且决定着联合分布 p(X,Y) 和分解的边缘分布的乘积 p(X)p(Y) 的相似程度。互信息的计算公式如下：
其中，p(x,y)是X和Y的联合概率分布函数，p(x)和p(y)分别为X和Y的边缘概率分布函数。
当使用互信息作为关键词提取的特征量化时，应用文本的正文和标题构造PAT树，然后计算字符串左右的互信息。
词跨度
词跨度是指一个词或者短语字文中首次出现和末次出现之间的距离，词跨度越大说明这个词对文本越重要，可以反映文本的主题。一个词的跨度计算公式如下：
其中，Lasti表示词i在文本中最后出现的位置，firsti表示词 i 在文本中第一次出现的位置，sum表示文本中词的总数。
词跨度被作为提取关键词的方法是因为在现实中，文本中总是有很多噪声（指不是关键词的那些词），使用词跨度可以减少这些噪声。
TF-IDF值
一个词的TF是指这个词在文档中出现的频率，假设一个词w在文本中出现了m次，而文本中词的总数为n，那么一个词的IDF是根据语料库得出的，表示这个词在整个语料库中出现的频率。假设整个语料库中，包含词w的文本一共有M篇，语料库中的文本一共有N篇，则
由此可得词w的TF-IDF值为：
TF-IDF的优点是实现简单，相对容易理解。但是，TFIDF算法提取关键词的缺点也很明显，严重依赖语料库，需要选取质量较高且和所处理文本相符的语料库进行训练。另外，对于IDF来说，它本身是一种试图抑制噪声的加权，本身倾向于文本中频率小的词，这使得TF-IDF算法的精度不高。TF-IDF算法还有一个缺点就是不能反应词的位置信息，在对关键词进行提取的时候，词的位置信息，例如文本的标题、文本的首句和尾句等含有较重要的信息，应该赋予较高的权重。
基于统计特征的关键词提取算法通过上面的一些特征量化指标将关键词进行排序，获取TopK个词作为关键词。
基于统计特征的关键词的重点在于特征量化指标的计算，不同的量化指标得到的结果也不尽相同。同时，不同的量化指标作为也有其各自的优缺点，在实际应用中，通常是采用不同的量化指标相结合的方式得到Topk个词作为关键词。
NO.2文本关键词提取算法——基于词图模型的关键词抽取算法
基于词图模型的关键词抽取首先要构建文档的语言网络图，然后对语言进行网络图分析，在这个图上寻找具有重要作用的词或者短语，这些短语就是文档的关键词。语言网络图中节点基本上都是词，根据词的链接方式不同，语言网络的主要形式分为四种：共现网络图、语法网络图、语义网络图和其他网络图。
在语言网络图的构建过程中，都是以预处理过后的词作为节点，词与词之间的关系作为边。语言网络图中，边与边之间的权重一般用词之间的关联度来表示。在使用语言网络图获得关键词的时候，需要评估各个节点的重要性，然后根据重要性将节点进行排序，选取TopK个节点所代表的词作为关键词。节点的重要性计算方法有以下几种方法。
1.综合特征法
综合特征法也叫社会网络中心性分析方法，这种方法的核心思想是节点中重要性等于节点的显著性，以不破坏网络的整体性为基础。此方法就是从网络的局部属性和全局属性角度去定量分析网络结构的拓扑性质，常用的定量计算方法如下。
度
节点的度是指与该节点直接向量的节点数目，表示的是节点的局部影响力，对于非加权网络，节点的度为： 对于加权网络，节点的度又称为节点的强度，计算公式为：
接近性
节点的接近性是指节点到其他节点的最短路径之和的倒数，表示的是信息传播的紧密程度，其计算公式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96f42dc8017aa757ff050944c1e9c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d89f2ee615129477f9105ecd615ea7d/" rel="bookmark">
			12个数据可视化工具，人人都能做出超炫图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语：今天我们带来一篇来自 Adobe 工程师 Rohit Boggarapu 的文章。他在文章中介绍了一些适合网页开发者的数据可视化和绘图工具，让你不必再花大力气与枯燥的数据抗争。部分工具不要求写代码也可以使用！
我们诠释数据的方式和数据本身之间存在着巨大的鸿沟。尤其是当我们唯一的选择是盯着表格中一列列不知所云的数字时。这可能是最无聊的一种格式了。
没有哪个网页开发者会喜欢电子表格。好消息是，现在我们有了许多更加优雅的方式来呈现数据，再也没有必要使用静态的 Excel 图表了。
在为你的项目选择合适的绘图工具时，要考虑到许多事情。本文将为你分析适合网页开发者的 12 个最好的工具，让你不再花费大把时间跟数据做斗争，而是开始轻松地绘制漂亮的图表。虽然本文推荐的工具是面向网页开发者的，但其中一些并不需要会写代码就能使用。许多工具都有着丰富的交互式例子，即使是新手也能轻松地通过改动代码来创建自定义图表。
1. Google Charts
文档和帮助信息丰富的 Google Charts 对于刚刚入门 JavaScript 绘图的人来说是极佳的选择。它的文档里到处都是带注释的代码和逐步的讲解，可以直接用来把 HTML5 / SVG 图标嵌入到你的网页中。
如果你需要更进阶的自定义功能或是 Google 原始提供的 18 类以外的图表，下面会介绍一些有着更多类别和特性的选择。
适合人群：追求灵活性和良好文档的严肃开发者。
2. MetricsGraphics
MetricsGraphics 是一个在 D3.js 的基础上专为可视化时间序列数据而开发的绘图库。虽然它只支持线图、散点图、柱状图、直方图和数据表格，但它在这几类图表上的表现非常强。
跟 Google Charts 一样（MetricsGraphics 是 Mozilla 的产品），丰富的文档和例子使得它很容易上手。比如这个非常有趣的关于 UFO 目击事件的交互式例子。
同时它也是一个非常简易和轻量级的选择。
适合人群：追求快速美观同时又不需要写一堆杂乱代码的开发者。
3. FusionCharts
FusionCharts 支持 vanilla JavaScript、jQuery、Angular 等一系列高人气的库和框架。它内置 90 多种图表和超过 1000 种地图，相比 Google Charts 和 MetricsGraphics 要完整得多。你可以在这里查看它所支持的全部图表类型。
考虑到应用或是网站的拓展性，如果你选择了一个功能不完整的绘图库，这就有可能在将来发展成一个问题。而像 Microsoft、Google 和 IBM 这样的公司都在使用 FusionCharts，这说明它是一个能满足企业级拓展性需求的工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d89f2ee615129477f9105ecd615ea7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5f2b634598c9f8d2cea0a464a2cd14/" rel="bookmark">
			ubuntu下PyCharm导入ros库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		然后，正文来了，我将在下面介绍2点环境配置，1.launch文件的关联，2.roslib的导入
launch文件的关联 pycharm自己是不支持launch文件的，但是我们还是希望用ide实现编写，例如这样： 具体做法就是在file／settings里面打开filetypes
然后在registered patterns里面添加*.launch文件，点ok完成launch文件的关联
2.roslib的导入
这里介绍pycharm要如何和终端环境bashrc中配置的那样直接关联/opt/ros/indigo/setup.bash。
首先打开终端，然后输入：
[html] view plain copy gedit ~/.local/share/applications/jetbrains-pycharm-ce.desktop #当前用户可用 [html] view plain copy gedit /usr/share/applications/jetbrains-pycharm-ce.desktop #全部用户可用 然后会出现一个有以下内容的文档：
[plain] view plain copy [Desktop Entry] Version=1.0 Type=Application Name=PyCharm Community Edition Icon=/home/howe/Downloads/pycharm-community-2017.1/bin/pycharm.png Exec="/home/howe/Downloads/pycharm-community-2017.1/bin/pycharm.sh" %f Comment=The Drive to Develop Categories=Development;IDE; Terminal=false StartupWMClass=jetbrains-pycharm-ce 如果是空白文档，那么就是文件开错了，输入： [plain] view plain copy gedit /usr/share/applications/ 然后tab自动补全以下。 接着修改其中的Exec变量，在‘=’后面添加bash -i -c，改完如下：
[plain] view plain copy Exec= bash -i -c "/home/ubu/tools/pycharm-professional-2016.2.3/bin/pycharm.sh" %f 保存并退出。 添加 bash -i -c 是为了在通过快捷方式启动PyCharm的同时加载~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5f2b634598c9f8d2cea0a464a2cd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82cb1bf9cc9a2794060d594662778605/" rel="bookmark">
			【算法】动态规划法——最长公共子序列（LCS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【fishing-pan：https://blog.csdn.net/u013921430转载请注明出处】 前言 这篇是自己写的第一篇关于算法方面的博客，写他是因为自己今天打开笔记，刚好看到了它，就这么简单。
这篇博客主要想讲讲动态规划法，然后以LCS问题为例展开来说一下怎么利用动态规划法求解它，下面是自己的一些理解和总结，有不对的地方还请大家指正。
动态规划法 动态规划法（dynamic programming）通常用于求解最优化问题（optimization problem），它适用于那些子问题相互重叠的情况，即子问题不独立，不同的子问题具有公共的子子问题（就是子问题的子问题）。这显然与分治法是不同的，分治法将问题划分为不重叠的子问题，然后分别求解这些子问题，最后将这些问题合并得到最终的解。
对于具有公共子问题的情况，分治法会做很多不必要的工作，它会多次求解同一子子问题。动态规划法却不一样，对每个子子问题它只会求解一次，将其保存在一个表格中，避免了不必要的重复计算。
如之前所说，动态规划法用于求解最优化问题，这就意味着可能这个问题，有很多解，但是呢，不一定都是最优解。利用动态规划法求出来的是这个问题的一个最优解（an optimal solution），记住这里求解的只是最优解（the optimal solution）中的一个，因为最优解可能有多个。
设计一个问题的动态规划算法主要有一下的几步
（1） 找出最优解的性质，刻画其结构特征；
（2） 递归的定义最优解的值；
（3） 以自底向上的方式计算出最优值；
（4） 根据计算最优解时得到的信息，构造一个最优解。
如果你只需要一个最优解的值，而不是这个结本身，就不需要第（4）步。如果你需要得到这个解本身，也就是说你需要执行第（4）步，这往往需要我们在第（3）步中记录一些额外的信息，以方便第（4）步的求解。
下面让我们来看看LCS问题如何利用动态规划法求解。
最长公共子序列的动态规划法实现 最长公共子序列（longest-common-subsequence, LCS） （1）子序列：一个序列X ＝ x1x2...xn,中任意删除若干项，剩余的序列叫做A的一个子序列。也可以认为是从序列A按原顺序保留任意若干项得到的序列。
例如：对序列 1,3,5,4,2,6,8,7来说，序列3,4,8,7 是它的一个子序列。对于一个长度为n的序列，它一共有2^n 个子序列，有(2^n – 1)个非空子序列。在这里需要提醒大家，子序列不是子集，它和原始序列的元素顺序是相关的。
（2）公共子序列：如果序列Z既是序列X的子序列，同时也是序列Y的子序列，则称它为序列X和序列Y的公共子序列。空序列是任何两个序列的公共子序列。
（3）最长公共子序列：X和Y的公共子序列中长度最长的（包含元素最多的）叫做X和Y的最长公共子序列。
这个问题如果用穷举法时间，最终求出最长公共子序列时，时间复杂度是Ο（2mn），是指数级别的复杂度，对于长序列是不适用的。因此我们使用动态规划法来求解。
刻画最长公共子序列问题的最优子结构 设X=x1x2…xm和Y=y1y2…yn是两个序列，Z=z1z2…zk是这两个序列的一个最长公共子序列。
1. 如果xm=yn，那么zk=xm=yn，且Zk-1是Xm-1，Yn-1的一个最长公共子序列；
2. 如果xm≠yn，那么zk≠xm，意味着Z是Xm-1，Y的一个最长公共子序列；
3. 如果xm≠yn，那么zk≠yn，意味着Z是X，Yn-1的一个最长公共子序列。
从上面三种情况可以看出，两个序列的LCS包含两个序列的前缀的LCS。因此，LCS问题具有最优子结构特征。
递归的定义最优值 从最优子结构可以看出，如果xm=yn，那么我们应该求解Xm-1，Yn-1的一个LCS，并且将xm=yn加入到这个LCS的末尾，这样得到的一个新的LCS就是所求。
如果xm≠yn，我们需要求解两个子问题，分别求Xm-1，Y的一个LCS和X，Yn-1的一个LCS。两个LCS中较长者就是X和Y的一个LCS。
可以看出LCS问题具有重叠子问题性质。为了求X和Y的一个LCS，我们需要分别求出Xm-1，Y的一个LCS和X，Yn-1的一个LCS，这几个字问题又包含了求出Xm-1，Yn-1的一个LCS的子子问题。（有点绕了。。。晕没晕。。。。）
根据上面的分析，我们可以得出下面的公式；
计算最优解的值 根据上面的，我们很容易就可以写出递归计算LCS问题的程序，通过这个程序我们可以求出各个子问题的LCS的值，此外，为了求解最优解本身，我们好需要一个表b，b[i，j]记录使C[i，j]取值的最优子结构。
C++代码如下；
int **Lcs_length(string X,string Y,int **B) { int x_len = X.length(); int y_len = Y.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82cb1bf9cc9a2794060d594662778605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39b309d80eb99366393e5d5d634cddc/" rel="bookmark">
			用STM32F103RCT6&#43;无源蜂鸣器&#43;4×4矩阵键盘实现电子琴的实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用了STM32CubeMX及Keil（HAL库） 材料：stm32开发板、无源蜂鸣器、4×4矩阵键盘、杜邦线、st-link 实验原理： 1、音高和矩形波周期有关 ，音强和占空比有关（？），通过设置TIM2为PWM，对应按键信息设置不同的方波周期，占空比恒为50%（音量不变），通过CH1(PA0)输出，PA0接无源蜂鸣器正极，无源蜂鸣器另一端接地，于是发出不同频率的声音(周期的数值是网上搜的。。。其中c应该是中央c) 2、只用了4×4的3×3的部分。。。（只发9个音。。。），采用轮询输入
实验设计：
PA0接无源蜂鸣器正极，无源蜂鸣器另一端接地
其它连线如图
对应的声音的按键如上图 按下按键发出声音 释放按键停止发声 STM32CubeMX中的主要的设置： 主要代码（以下只有USER CODE BEGIN里的代码）： main.c：
/* USER CODE BEGIN PV */ /* Private variables ---------------------------------------------------------*/ const int tones[] = { 1915, 1700, 1519, 1432, 1275, 1136, 1014, 956,853 }; //大概发出{ 'c', 'd', 'e', 'f', 'g', 'a', 'b', 'C','D' }; const uint16_t keys[]={GPIO_PIN_4,GPIO_PIN_5,GPIO_PIN_6}; //为了让下面的代码更少而写的数组。。。 /* USER CODE END PV */ /* USER CODE BEGIN PFP */ /* Private function prototypes -----------------------------------------------*/ void beeping(uint16_t pin,uint8_t times); /* USER CODE END PFP */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ //判断3行中是否有按键被按下 if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_4)==0){ beeping(GPIO_PIN_4,0); } else if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5)==0){ beeping(GPIO_PIN_5,1); } else if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_6)==0){ beeping(GPIO_PIN_6,2); } } /* USER CODE END 3 */ /* USER CODE BEGIN 4 */ //发声函数 void beeping(uint16_t pin,uint8_t times){ uint8_t i,key='n'; for(i=0;i&lt;3;i++){//检查是否按下了9个发声按键 HAL_GPIO_TogglePin(GPIOA,keys[i]); if(HAL_GPIO_ReadPin(GPIOC,pin)==1){ key=i+times*3; HAL_GPIO_TogglePin(GPIOA,keys[i]); break; } HAL_GPIO_TogglePin(GPIOA,keys[i]); } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39b309d80eb99366393e5d5d634cddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdd103129e65678ec54d3023ac3d41b/" rel="bookmark">
			react实现前后台数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天总结一下前端使用react框架，后台使用mybatis集成springBoot结合使用的要点以及我认为重要的点。
注意：我的程序代码：JDK是1.8版本，前端用的是es6版本的（与es5区别：定义函数的格式不同等等）
一、mybatis集成springBoot的注意事项
1、需要自己写SQL语句--先建好所需要的数据库表（可以使用逆向工程生成mapper.xml文件，实体类，dao接口），不过最好是自己写SQL语句
2、使用myBatis时，dao层不需要写实现类，只需写对应的接口类即可。
注意：接口类中的方法名和mapper.xml中的SQL语句的id值必须一致
mapper.xml文件：
dao接口层：
二、前后台交互（react作为前端框架，springBoot作为后台框架）
1.后台必须注意Controller层中的@RequestMapping("/xx")
2.react代码中：package.json文件中添加（防止跨域）： "proxy":"http://127.0.0.1:8080"--类似这样的后台域名
3.react中表格的字段对应于实体类中的属性，必须保持一致
4.在react代码中添加与后台交互数据的代码：
// 请求后台数据 componentWillMount(){ /* 查询数据的格式 */ let filter={ object:{ object:{ } } } var getInformation ={ method:"POST", headers:{ "Content-Type":"application/json" }, /* json格式转换 */ body:JSON.stringify(filter) } //注意：/org/find的方法名对应于后台Controller层中的RequestMapping fetch("/org/find",getInformation) .then(response =&gt; response.json()) .then(json =&gt;{ // 返回的数据类型 this.setState({ object:json.object.list }) }) } 上述代码是关于查询页面的函数，其中增加、修改、删除一般情况下点击按钮保存，数据保存到数据库并能显示到页面，进而达到更新数据，就会显示所操作的所有数据。
以上是我的总结，希望可以提出宝贵的意见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1523064dc96f0bfbb82253e36cb0b4d/" rel="bookmark">
			TCP协议中的源地址和目的地址是内网地址还是外网地址的测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.服务端和客户端都是内网的情况下，显然源地址和目的地址都是内网地址。
2.当服务端是公网，客户端是内网的情况下，服务端是怎么找到客户端的？
当客户端给服务端发消息时,TCP包里面的ip刚开始是内网地址，到达网关时，内网地址替换成网关地址（外网地址），网关自己做好保存（哪个端口 对应哪个内网地址） 然后在将数据包传送到服务端；服务端向客户端传送数据时TCP包里面先是客户端的最外层网关的IP即网关外网地址，然后找到外网端口对应哪个内网ip 即可找到客户端 一下是抓的包 服务端是公网IP 客户端内网地址固定为192.168.1.x 抓图如下： 看到的是外网地址（网关地址）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0abdcf49429cc66da647ba5954023ca/" rel="bookmark">
			C语言字符串输入及输出的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串数组+初始化
char s1[]="array"; //字符数组 char s2[6]="array"; //数组长度=字符串长度+1，因为字符串末尾会自动添‘\0‘ printf("%s,%c\n",s1,s2[2]); //array，r 2.字符串指针+初始化
char *sp="pointer"; //字符指针 printf("%s,%c,%c\n",sp,*sp,*(sp+2)); //pointer,p,i 3.数组+scanf char s1[6];	scanf("%s\n",s1); printf("%s,%c\n",s1,s1[2]); //array，r 4.指针+scanf #include &lt;stdio.h&gt; #include&lt;stdlib.h&gt; //该头文件别忘加，否则使用malloc会报错 int main(){ char *sp; sp=(char *)malloc(sizeof(char)); scanf("%s\n",sp); printf("%s,%c\n",sp,*sp);//pointer,p return 0; } 5.指针+数组+scanf char str[60], *sp=str;//将数组的首地址str赋给指针变量sp scanf("%s\n",sp); printf("%s,%c,%c\n",sp,*sp,*(sp+3));//pointer,p,n printf("%s,%c,%c\n",str,str[0],str[3]);//pointer,p,n 6.注意：如下方法控制台运行会终止 char *sp;//sp未初始化指向不明 scanf("%s\n",sp); printf("%s\n",sp); 7.用scanf和gets（ 字符数组名或指针）进行输入的区别： char str1[60],str2[60]; gets(str1); //gets()函数将接收输入的整个字符串直到遇到换行为止 printf("%s\n",str1); scanf("%s\n",str2);//scanf如果输入了空格会认为字符串结束，空格后的字符将作为下一个输入项处理 printf("%s\n",str2); 8.使用while(scanf("%d",&amp;n)!=EOF){ }实现多组测试数据输入，而不在输入完一组数据后退出控制台
char s1[60],s2[60]; int cnt; //用来测试scanf返回被输入函数成功赋值的变量个数 while((cnt=scanf("%s%s",s1,s2))!=EOF){ //当按下ctr+z终止输入时，scanf会返回EOF(-1)\n printf("scanf返回了%d, s1是%s，s2是%s, 这行输出下方可以继续进行输入\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0abdcf49429cc66da647ba5954023ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4115175a15413a95a8467c93ea94028/" rel="bookmark">
			GRPC的四种服务类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上次简单介绍了grpc的使用方法，并创建了一个方法调用，在grpc中有四种服务类型，下面分别进行介绍
简单rpc 这就是一般的rpc调用，一个请求对象对应一个返回对象
proto语法： rpc simpleHello(Person) returns (Result) {} service代码 @Override public void simpleHello(ProtoObj.Person request, io.grpc.stub.StreamObserver&lt;ProtoObj.Result&gt; responseObserver) { //返回结果 responseObserver.onNext(ProtoObj.Result.newBuilder().setString("hello, "+request.getMyName()).build()); responseObserver.onCompleted(); } client代码 @Test public void simple() throws InterruptedException { final ManagedChannel channel = ManagedChannelBuilder.forAddress("127.0.0.1", 8080).usePlaintext(true).build(); //定义同步阻塞的stub HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel); ProtoObj.Person person = ProtoObj.Person.newBuilder().setMyName("World").build(); //simple System.out.println("---simple rpc---"); System.out.println(blockingStub.simpleHello(person).getString()); channel.shutdown(); } 输出 ---simple rpc--- hello, World 服务端流式rpc 一个请求对象，服务端可以传回多个结果对象
proto语法 rpc serverStreamHello(Person) returns (stream Result) {} service代码 @Override public void serverStreamHello(ProtoObj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4115175a15413a95a8467c93ea94028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd90ad565862e575e1e23c0e5f5cd5f4/" rel="bookmark">
			linux C&#43;&#43;下捕获崩溃日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;signal.h&gt; #include &lt;time.h&gt; #include &lt;execinfo.h&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;sys/stat.h&gt; const int MAX_STACK_FRAMES = 128; void sig_crash(int sig) { FILE* fd; struct stat buf; stat("./crash.log", &amp;buf); if(buf.st_size &gt; 10*1000*1000){ // 超过10兆则清空内容 fd = fopen("./crash.log", "w"); } else { fd = fopen("./crash.log", "at"); } if (NULL == fd) { exit(0); } try { char szLine[512] = {0, }; time_t t = time(NULL); tm* now = localtime(&amp;t); int nLen1 = sprintf(szLine, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd90ad565862e575e1e23c0e5f5cd5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13ae4480de286720d988c2f11b37fdd/" rel="bookmark">
			JSON与Protocol Buffers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON与Protocol Buffers同为序列化数据的存储格式。
性能比较，视平台、语言、数据结构复杂程度的不同，Protocol Buffers与JSON相比，性能可能会从慢15倍到快5倍。值得指出的是，在Android系统中，Protocol Buffers反序列化数据会比JSON快大约3倍[1]。
JSON数据格式有一个缺点：冗余太大，如：
[{ " Name " : " Jane " , " Gender " : 0 }, { " Name " : " Waith " , " Gender " : 1 }] 每一条数据都要包括"Name"与"Gender"，据统计，JSON格式的数据至少有1/5是无效的。
与JSON不同，Protocol Buffers用二进制编码数据，而且数据的格式是事先通过一个后缀名为.proto的文件指定的，如：
message Person {
required string Name = 2 ;
optional int32 Gender = 3 ;
} 这样Protocol Buffers的数据会比JSON小不少，在一些场景，比如内存里要存储更多的数据时，用Protocol Buffers会更合适。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e553ba1f242f4c19ef3bac74f850211/" rel="bookmark">
			Mac下Python的MySQL-python模块的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用Python连接MySQL（版本5.7）数据库时需要用到MySQL模块，但是Python并没有自带MySQL模块，需要自行安装，也就是MySQL for Python（MySQL-python）python3 将其模块改名为MySQLClient。
在终端输入：（默认你已经安装了MySQL、pip）
echo 'export PATH="/usr/local/opt/mysql@5.7/bin:$PATH"' &gt;&gt; ~/.bash_profile 重新打开一个终端：
pip install MySQL-python 如果遇到：error:command'cc' failed with exit status 1
这个问题，就用下面这个命令： xcode-select --install 等待几分钟安装成功后，再输入： pip install MySQL-python 终端输入：
python &gt;&gt;&gt;import MySQLdb 没有报错就可以了。。。。。。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a4dec99bf998a2c2ebe32d15e4043f/" rel="bookmark">
			技术人员的成长之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为技术人员，有时会对前进的方向感到迷茫，主要是由于缺乏一个稍微长远的规划，按部就班的工作，无法产生量变到质变的成长。
对于技术人员来说，一般可以分为五级：
1 新手：只能按照指令一步步地走。新手没有接触过当前行业，所以只能按照指令一步步地走完过程。
2 初级：能够完成一个局部工作。不需要给出指令，只需要给出一个局部工作的目标，初级可以完成这一局部工作，但初级没有形成全局概念，不知道自己所做的内容在全局所占据的份量有多重。
3 中级：能够完成全局工作。这一层面的技术人员，对于一个领域的方方页面都能够了解，在给定目标的情况下，可以独立完成一个项目，可以带人，不会频繁求助高级。
4 高级：具备主动性，能够根据环境纠正自己的目标和手段。高级能够站在一个中立的层面考虑什么应该做，什么不应该做，怎么样代价最小，需要权衡付出与收益。
5 专家：凭直觉工作，每击必中要害。在长期的解决问题过程中，专家形成了丰富的经验积累，可以快速抓住问题的关键点。
以上的分级，有一个重要的分水岭——中级跨向高级。中级及以下（以下统称中级）都是为别人而开发，高级及以上（以下统高级）都是为自己而开发。所以，在主动性，做事目的、手段方面，中级与高级都存在着本质的区别。以下就来看看这三方面的区别。
由被动到主动
人做事的时候，有着内在的动力来推动。作为中级，事情都是由别人安排的，自己不愿意主动承担责任。类似于这样的说话方式，会出现在中级身上：
l 怎么需求又变了，能不能把需求确定了再做
l 这样做不行的，框架已经定好了，只能按那样的方式来做
l 我辛辛苦苦写的这么多代码，又白费了
l 这个还是不要改了吧，改起来很难的，我担心出问题
l 这个问题不是我这边出的，是XXX那边的接口问题
以上可以看到，中级作为一个被动完成任务的状态，会尽量让事情少摊到自己身上。并且会多有抱怨，因为对于中级来讲，一个不断改变的需求产生的原因总是别人的原因，与自己无关，自己只是一个代码的实现者。我们可以看看高级对应的说话方式大概会是怎么样：
l 这个需求为什么要改成这样，能跟我详细说明一下不，我看看是不是值得改一下
l 我跟架构组沟通一下，这样改一下应该可以让整个项目变得更加简单
l 我先做的这个原型，代价很小，我们已经确认了原型，现在我开始写代码做实现
l 我觉得这样改可以让整个项目更加简单，当然，直接一刀切会有很大的影响，我们看看怎么切过来
l 这的确是个问题，我来跟进一下，找一下原因
高级作为一个主动解决问题的人，会考虑到业务方的需求，对所需要付出的代价做一些权衡，不会推脱问题，会将问题先收下来，进一步去找问题的原因，会尽量让一个项目变得简单可理解，勇于根据现实的改变来调整当前的目标和技术手段。
从积极性方面来讲，一种主动积极的心态才能为自己创造更多的机会。中级被动的状态，把复杂的事情推脱掉，进而也阻断了自己解决复杂问题的机会，从而能力不能得到提升。中级会一个误区，认为可以自己通过看书，看视频来获得提升。但可以说，最有效的提升方式，就是通过实际地解决问题，让自己的能力得到提升。看书、看视频在能力提升方面起的作用是，在实际解决问题的过程中，会给一个思路，让人把问题给总结起来，加深对解决问题的理解，能够让解决特殊问题变为解决比较普遍的问题。
所以，如果中级没有在主动性方面有一个根本性的转变，中级就会停留在原地。同时，有了转变，就能够有着越来越多的机会提升自己，进而与中级快速拉开距离。这样的距离，就是一个分水岭，中级还是那个中级，但高级很快就不是那个高级了。
完成任务到表达自我
针对于同一个目标，中级与高级的处理方式有着不同的态度。中级是为了完成任务，所以接受到的目标越是清晰，越是不变，对自己来讲越是有利。实际上，我们所面对的大多数都是中级，这就迫使高级人员需要将目标描述得清晰、可视化。
高级对待同一个目标的态度是，这又是一次提升自我我机会，我要挖掘这一次机会的所有价值。目标不清晰，没有关系，我可以通过沟通来将目标弄清楚，这样可以锻炼我的沟通能力。框架有问题，没有关系，我可以尝试着做一定的修改，看看是不是那样做可以简化项目，这可以锻炼我的抽象能力。我一定要将这个项目做得很完美，无论是用户体验，还是代码格式，我都要写好，这样才能挖掘这一次机会的所有价值。咦，我发现代码有很多是重复的，嗯，我需要写一个代码生成器，生成那些重复的代码。我发现所有的 Dao 都有 insert/update/delete/select 方法，我可以写一个通用的 Dao，利用 java 的继承机制，这些方法就不会再写了。达成目标，就是把我方方面面的想法都表现出来的过程。这就是高级的表达自我的过程。
一个给定的项目，都有着现实的价值，也就是说，一个项目都有着对应的用户群体，做好一个项目，就是拿现实的、客观的评判标准来评判自己的想法是不是对的，自己做的事情是不是有价值的。中级不会考虑到这一个层面，所以中级只是简单地完成任务。高级则会考虑这个项目的价值在哪里，高级自己可以借助这一个项目过程印证自己的哪些想法。
被工具使用到使用工具
在确定目标之后，中级会使用自己熟悉的工具和手段来达成目标。中级作为一个胜任者，对于一个明确的目标，有着很熟悉的工具和手段，是可以完成目标的。同时， 中级的极限也就是针对具体的目标，采用熟悉的手段达成目标 。
高级对于一个目标的认知是，通过一个有价值的目标来确认自己的想法，所以不会受限于工具与手段，并且为了让自己的抽象能力得到提升，更愿意花时间去研究新工具、新手段，进而让解决问题的方式变得更加简单。高级会重视生产力这一概念，提升自己的生产能力。提升生产能力，主要就是提升个人使用工具的能力。
抛开工具，人与人之间差别是不大的。人与人的差别大距离拉开，就在于不同的人使用的工具不同，或者对同一个工具的使用有效程度不同。这里要注意：工具除了包含了扩展行动能力的交通工具，扩展表现能力的PPT、Word，扩展编码速度的Eclipse、Idea等， 最重要的是，工具也包含了扩展思维能力的思维模式 。
实际上，人每使用一种新的工具，都要有与之相应的思维模式来匹配。比如，作为开发人员，不能用 Eclipse 的快捷键来对 Idea 起作用，要从 Eclipse 转到 Idea ，就需要把之前的一切思维习惯都改变掉。以下将介绍中级向高级转变的方法，本质上就是提供新的思维模式工具，让开发人员在使用新的思维模式工具的过程中，让自己产生改变。
摘自：https://www.cnblogs.com/1si2/p/devroad.html
转载于:https://www.cnblogs.com/aurain/p/8402107.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43ae115f877ae43b556a52131429c1a/" rel="bookmark">
			Linux ls -l 各字段解释，硬链接软连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自http://hi.baidu.com/yzzcheng/item/1a2141878447891dc31627f5
以root的家目录为例: 可以看到，用ls -l命令查看某一个目录会得到一个7个字段的列表。 第1行:总计(total) Total后面的数字是指当前目录下所有文件所占用的空间总和。可以使用ls –lh查看，也可使用ls –alh查看。
第1字段: 文件属性字段 -rw-r–r– 1 root root 762 07-29 18:19 exit 文件属性字段总共有10个字母组成；第一个字符代表文件的类型。 字母“-”表示该文件是一个普通文件 字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写 注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息 字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式 字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节) 字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。 字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。 字母“s”表示该文件为sock文件。与shell编程有关的文件。 在此重申下文件链接这个重要概念： 链接文件的概念类似于windows里的快捷方式。多个链接文件同时指向一个“源文件”。链接文件分为硬链接或符号链接两种。 在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号inode 。软连接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的（那就和windows 下的快捷方式的那个文件有很接近的意味）。软连接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软连接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，但删除原来的文件，则相应的软连接不可用（cat那个软链接文件，则提示“没有该文件或目录“） 硬连接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。相反都是软连接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软连接将变得毫无意义。而硬链接删除源文件的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收，因此文件的内容不会被删除，相当于删除了一个索引。 硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。 软链接可以跨文件系统，硬链接不可以；软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；软链接可以对目录进行连接，硬链接不可以。两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。使用 -s 开关可以创建软链接 第1字符的后面9个字母表示该文件或目录的权限位。 r表是读 (Read) 、w表示写 (Write) 、x表示执行 (eXecute) 其中前三个表示文件拥有者的权限，中间三个表示文件所属组拥有的权限，最后三个表示其他用户拥有的权限。 比如： -rw-r–r– 1 root root 762 07-29 18:19 exit 表示文件的拥有者root对文件有读写权限，其他人(同组用户和其他用户只有读的权限) 另外，权限组还有一些特殊的表示法： [root@localhost ~]# ll /usr/X11R6/bin/XFree86 -rws–x–x 1 root root 1960262 2003-02-28 /usr/X11R6/bin/XFree86 s表示这个是网络接口程序”s”是socket的缩写。该程序在运行过程中会打开一个网络接口。 其他UNIX类系统如FreeBSD中还有t权限，表示一个临时(temporary)文件 ls -l /tmp可以看到这样的权限：drwxrwxrwt 它的最后一位是字母”t”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a43ae115f877ae43b556a52131429c1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cfe0efd0fb39f1330169ce6d46ba86/" rel="bookmark">
			MATLAB基础二——提取矩阵元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		###MATLAB基础二
首先产生5阶两位随机整数矩阵A，再产生均值为0.6、方差为0.1的5阶正态分布随机矩阵B，最后验证(A+B)I=IA+BI（I为单位矩阵）。
rand函数：产生（0，1）开区间均匀分布的随机数x。
fix(a+(b-a+1)x)：产生[a,b]区间上均匀分布的随机整数。
randn函数：产生均值为0、方差为1的标准正态分布随机数x*。
μ+σx：得到均值为μ、方差为σ²的随机数。 &gt;&gt;A=fix(10+(99-10+1)*rand(5))
A =
83 18 24 22 69
91 35 97 47 13
21 59 96 92 86
92 96 53 81 94
66 96 82 96 71
&gt;&gt; B=0.6+sqrt(0.1)randn(5)
B =
0.9272 0.8809 1.0549 0.5677 0.5905
0.8299 0.2373 0.7028 0.5236 0.5479
0.5040 0.2620 0.3613 0.7009 0.7985
0.6929 0.3440 1.0333 0.6989 0.9457
0.3510 -0.3311 0.0588 0.3265 0.9508
&gt;&gt; C=eye(5)
C =
1 0 0 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97cfe0efd0fb39f1330169ce6d46ba86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72e3e000247119c1020aa2a80f94b45/" rel="bookmark">
			IndexError: list index out of range的错误原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1种可能情况 list[index]index超出范围,也就是常说的数组越界 第2种可能情况 list是一个空的 没有一个元素 进行list[0]就会出现该错误，这在爬虫问题中很常见，比如有个列表爬去下来为空，统一处理就会报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e4138cc6b89868b46713906cfab9be/" rel="bookmark">
			提醒是要对预测输出y做出ravel()转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D:\Python27\lib\site-packages\sklearn\utils\validation.py:578: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True)
#clf.fit(X.T,Y.T); clf.fit(X.T,Y.T.ravel()); 提醒是要对预测输出y做出ravel()转换，例如下面操作： 注意ravel和reshape的区别（一个参数的时候没区别，都是转换成不规范形式）
#coding:utf-8 import numpy as np a=np.array([[1,2,3],[4,5,6]]) print a #2*3 b=a.reshape(-1,1) c=a.reshape(1,-1) d=a.ravel() e=a.reshape(6) #一个参数的时候只能是总数 print b.shape #6*1 [[1],[2],[3],[4],[5],[6]] print c.shape #1*6 [[1 2 3 4 5 6]] print d.shape #(6,) [1 2 3 4 5 6] print d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e4138cc6b89868b46713906cfab9be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6c5456c7d556cfc17835cea440da3f/" rel="bookmark">
			selenium总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.获取标签的内容 for(WebElement item:selectList)
{ String text=item.getAttribute("textContent");
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f5e46b15427d05859295cdabbf1dff/" rel="bookmark">
			DataBinding 与 ListView 、RecyclerView 实现数据双向绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ListView 布局较简单两个Button 一个ListView
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/btn_add" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加数据" /&gt; &lt;Button android:id="@+id/btn_update" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="修改数据" /&gt; &lt;/LinearLayout&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/ListView&gt; &lt;/LinearLayout&gt; Student对象
public class Student { public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public ObservableInt age = new ObservableInt(); public ObservableBoolean isBoy = new ObservableBoolean(); public Student(String name,int age,boolean isBoy){ this.name.set(name); this.age.set(age); this.isBoy.set(isBoy); } } item_student_layout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f5e46b15427d05859295cdabbf1dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca23c1cf3dd0280177617ede08f59d0/" rel="bookmark">
			L2、L3网络传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是L2网络传输模型？大家都知道传统的OSI模型将网络传输分为9层：
其中L2网络传输就是物理层链路层，L3就是物理层、链路层、网络层
L2网络传输：
这种技术是普遍用于局域网的技术，各个主机之间通过链路层连接在一起，通过mac识别主机的身份，最常用的就是交换机
如上图所示，图中是两个电脑连一个交换机，我举一个A像B发数据的例子：
A将数据发送给交换机，交换机将收到的数据广播出去，广播到所有网络接口对应的主机上面，主机物理层收到数据，在链路层进行MAC地址匹配，找到目的MAC地址的主机也就是主机B，主机B接收到数据（交换机具有学习能力，大家有兴趣可以百度）。
L3网络传输：
L3网络是经过路由器之间进行通信的，如果是局域网之间进行通信，那么就是A向路由器发数据，路由器根据IP地址将找到对应主机，将数据传输给对应主机
假如访问的外网也就是说不通网段的网，这里我们举例A向E发数据，首先A将数据传输给路由器，路由器发现IP不是自己网段的，就找对应IP地址网关，最终找到路由器2，路由器2找对对应IP的主机，也就是将数据传送给E。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c696e2fdd16e01c057ad889d9e8c5e88/" rel="bookmark">
			直观梳理深度学习：计算机视觉基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自新智元微信公众号，作者是来自南京大学计算机系机器学习与数据挖掘所(LAMDA)张皓。本文写得很简洁，故转载之，可以当做一篇简要的论文综述。
引言
深度学习目前已成为发展最快、最令人兴奋的机器学习领域之一，许多卓有建树的论文已经发表，而且已有很多高质量的开源深度学习框架可供使用。然而，论文通常非常简明扼要并假设读者已对深度学习有相当的理解，这使得初学者经常卡在一些概念的理解上，读论文似懂非懂，十分吃力。另一方面，即使有了简单易用的深度学习框架，如果对深度学习常见概念和基本思路不了解，面对现实任务时不知道如何设计、诊断、及调试网络，最终仍会束手无策。
本系列文章旨在直观系统地梳理深度学习各领域常见概念与基本思想，使读者对深度学习的重要概念与思想有一直观理解，做到“知其然，又知其所以然”，从而降低后续理解论文及实际应用的难度。本系列文章力图用简练的语言加以描述，避免数学公式和繁杂细节。本文是该系列文章中的第二篇，旨在介绍深度学习在计算机视觉领域四大基本任务中的应用，包括分类(图a)、定位、检测(图b)、语义分割(图c)、和实例分割(图d)。后续文章将关注深度学习在计算机视觉领域的其他任务的应用，以及自然语言处理和语音识别。
计算机视觉(computer vision)简介
计算机视觉旨在识别和理解图像/视频中的内容。其诞生于1966年MIT AI Group的"the summer vision project"。当时，人工智能其他分支的研究已经有一些初步成果。由于人类可以很轻易地进行视觉认知，MIT的教授们希望通过一个暑期项目解决计算机视觉问题。当然，计算机视觉没有被一个暑期内解决，但计算机视觉经过50余年发展已成为一个十分活跃的研究领域。如今，互联网上超过70%的数据是图像/视频，全世界的监控摄像头数目已超过人口数，每天有超过八亿小时的监控视频数据生成。如此大的数据量亟待自动化的视觉理解与分析技术。
计算机视觉的难点在于语义鸿沟。这个现象不仅出现在计算机视觉领域，Moravec悖论发现，高级的推理只需要非常少的计算资源，而低级的对外界的感知却需要极大的计算资源。要让计算机如成人般地下棋是相对容易的，但是要让电脑有如一岁小孩般的感知和行动能力却是相当困难甚至是不可能的。
语义鸿沟(semantic gap) 人类可以轻松地从图像中识别出目标，而计算机看到的图像只是一组0到255之间的整数。
计算机视觉任务的其他困难 拍摄视角变化、目标占据图像的比例变化、光照变化、背景融合、目标形变、遮挡等。
计算机视觉的顶级会议和期刊 顶级会议有CVPR、ICCV、和ECCV，此外ICLR也有不少计算机视觉论文。顶级期刊有IJCV和TPAMI。由于计算机视觉领域发展十分迅速，不论身处学术界或产业界，通过阅读顶级会议和期刊论文了解计算机视觉的最近研究成果都十分必要。
卷积神经网络(convolutional neural networks, CNN)
经典的多层感知机由一系列全连接层组成，卷积神经网络中除全连接层外，还有卷积层和汇合(pooling)层。
(1) 卷积层
为什么要用卷积层 输入图像通常很维数很高，例如，1,000×1,000大小的彩色图像对应于三百万维特征。因此，继续沿用多层感知机中的全连接层会导致庞大的参数量。大参数量需要繁重的计算，而更重要的是，大参数量会有更高的过拟合风险。卷积是局部连接、共享参数版的全连接层。这两个特性使参数量大大降低。卷积层中的权值通常被成为滤波器(filter)或卷积核(convolution kernel)。
局部连接 在全连接层中，每个输出通过权值(weight)和所有输入相连。而在视觉识别中，关键性的图像特征、边缘、角点等只占据了整张图像的一小部分，图像中相距很远的两个像素之间有相互影响的可能性很小。因此，在卷积层中，每个输出神经元在通道方向保持全连接，而在空间方向上只和一小部分输入神经元相连。
共享参数 如果一组权值可以在图像中某个区域提取出有效的表示，那么它们也能在图像的另外区域中提取出有效的表示。也就是说，如果一个模式(pattern)出现在图像中的某个区域，那么它们也可以出现在图像中的其他任何区域。因此，卷积层不同空间位置的神经元共享权值，用于发现图像中不同空间位置的模式。共享参数是深度学习一个重要的思想，其在减少网络参数的同时仍然能保持很高的网络容量(capacity)。卷积层在空间方向共享参数，而循环神经网络(recurrent neural networks)在时间方向共享参数。
卷积层的作用 通过卷积，我们可以捕获图像的局部信息。通过多层卷积层堆叠，各层提取到特征逐渐由边缘、纹理、方向等低层级特征过度到文字、车轮、人脸等高层级特征。
卷积层中的卷积和数学教材中的卷积是什么关系 基本没有关系。卷积层中的卷积实质是输入和权值的互相关(cross-correlation)函数，而不是数学教材中的卷积。
描述卷积的四个量 一个卷积层的配置由如下四个量确定。1. 滤波器个数。使用一个滤波器对输入进行卷积会得到一个二维的特征图(feature map)。我们可以用时使用多个滤波器对输入进行卷积，以得到多个特征图。2. 感受野(receptive field) F，即滤波器空间局部连接大小。3. 零填补(zero-padding) P。随着卷积的进行，图像大小将缩小，图像边缘的信息将逐渐丢失。因此，在卷积前，我们在图像上下左右填补一些0，使得我们可以控制输出特征图的大小。4. 步长(stride) S。滤波器在输入每移动S个位置计算一个输出神经元。
卷积输入输出的大小关系 假设输入高和宽为H和W，输出高和宽为H'和W', 则H'=(H-F+2P)/S+1, W'=(W-F+2P)/S+1. 当S=1时，通过设定P=(F-1)/2, 可以保证输入输出空间大小相同。例如，3*3的卷积需要填补一个像素使得输入输出空间大小不变。
应该使用多大的滤波器 尽量使用小的滤波器，如3×3卷积。通过堆叠多层3×3卷积，可以取得与大滤波器相同的感受野，例如三层3×3卷积等效于一层7×7卷积的感受野。但使用小滤波器有以下两点好处。1. 更少的参数量。假设通道数为D，三层3×3卷积的参数量为3×(D×D×3×3)=27D2, 而一层7×7卷积的参数量为D×D×7×7=49D2。2. 更多非线性。由于每层卷积层后都有非线性激活函数，三层3×3卷积一共经过三次非线性激活函数，而一层7×7卷积只经过一次。
1×1卷积 旨在对每个空间位置的D维向量做一个相同的线性变换。通常用于增加非线性，或降维，这相当于在通道数方向上进行了压缩。1×1卷积是减少网络计算量和参数的重要方式。
全连接层的卷积层等效 由于全连接层和卷积层都是做点乘，这两种操作可以相互等效。全连接层的卷积层等效只需要设定好卷积层的四个量：滤波器个数等于原全连接层输出神经元个数、感受野等于输入的空间大小、没有零填补、步长为1。
为什么要将全连接层等效为卷积层 全连接层只能处理固定大小的输入，而卷积层可以处理任意大小输入。假设训练图像大小是224×224，而当测试图像大小是256×256。如果不进行全连接层的卷积层等效，我们需要从测试图像中裁剪出多个224×224区域分别前馈网络。而进行卷积层等效后，我们只需要将256×256输入前馈网络一次，即可达到多次前馈224×224区域的效果。
卷积结果的两种视角 卷积结果是一个D×H×W的三维张量。其可以被认为是有D个通道，每个通道是一个二维的特征图，从输入中捕获了某种特定的特征。也可以被认为是有H×W个空间位置，每个空间位置是一个D维的描述向量，描述了对应感受野的图像局部区域的语义特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c696e2fdd16e01c057ad889d9e8c5e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ee39fdb2ec869e26fcc90f3818d4f52/" rel="bookmark">
			FLASH相关知识扫盲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##简述
在flash的动态存储（单链表方式）中，遇到flash坏块问题，从中引申出许多不熟的知识点，在此梳理标记。其大致过程，经过和同事及朋友的沟通，nand flash的坏块处理方法如下：flash寄存器标志位检测、采用文件系统管理、共用好块池机制及写读匹配（快速检索到坏块位置），而nor flash的坏块问题上是不存在的。
##nand flash 坏块处理
共用好块池机制：首先，使用一个统一的备用好块池，为所有存放在 NAND 中的模块提供可替换的好块。这样，就不需要在每个模块后面放置一个保留区，提高了 NAND 的空间利用率。
##nor flash (W25Q64)
W25Q64是华邦公司推出的大容量SPI FLASH（nor flash）产品，其容量为64Mb。该25Q系列的器件在灵活性和性能方面远远超过普通的串行闪存器件。W25Q64将8M字节的容量分为128个块，每个块大小为64K字节，每个块又分为16个扇区，每个扇区4K个字节。W25Q64的最小擦除单位为一个扇区，也就是每次必须擦除4K个字节。所以，这需要给W25Q64开辟一个至少4K的缓存区，这样必须要求芯片有4K以上的SRAM才能有很好的操作。
##扇区（sector）和块（block）
sector:硬件（磁盘）上的最小的操作单位,是操作系统和块设备（硬件、磁盘）之间传送数据的单位
block由一个或多个sector组成，是软件（OS、文件系统）中最小的操作单位；操作系统的虚拟文件系统从硬件设备上读取一个block,实际为从硬件设备读取一个或多个sector.对于文件管理来说，每个文件对应的多个block可能是不连续的;block最终要映射到sector上，所以block的大小一般是sector的整数倍。不同的文件系统block可使用不同的大小，操作系统会在内存中开辟内存，存放block到所谓的block buffer中。
扇区组成物理块，物理块对应逻辑块，逻辑块与文件相对应。
扇区是硬件被操作时软件使用的最小的操作单元，就是一个扇区一个扇区进行操作（扇区的大小在存储设备生产时就设计好）。
##nor flash 和nand flash 的区别
简单说明：NAND FLASH内部结构是用与非门组成存储单元的。有非易失性，读写速度快，而且比较容易做到大容量。目前单片NAND FLASH存储容量可以达到8Gbit（1GByte)。NOR FLASH也有非易失性。随机存储速度比NAND FLASH 快得多。所以一般用NOR FLASH 用做内存片，或者叫做数据缓冲。而NAND FLASH则一般用来做存储数据用。比方说，U盘.MP3等。
详细说明：
FLASH存储器又称闪存，主要有两种：NorFlash和NandFlash，下面我们从多个角度来对比介绍一下。在实际开发中，设计者可以根据产品需求来进行闪存的合理选择。
###1、接口对比
NorFlash带有通用的SRAM接口，可以轻松地挂接在CPU的地址、数据总线上，对CPU的接口要求低。NorFlash的特点是芯片内执行(XIP,eXecute In Place)，这样应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。如uboot中的ro段可以直接在NorFlash上运行，只需要把rw和zi段拷贝到RAM中运行即可。
NandFlash器件使用复杂的I/O口来串行地存取数据，8个引脚用来传送控制、地址和数据信息。由于时序较为复杂，所以一般CPU最好集成NAND控制器。另外由于NandFlash没有挂接在地址总线上，所以如果想用NandFlash作为系统的启动盘，就需要CPU具备特殊的功能，如s3c2410在被选择为NandFlash启动方式时会在上电时自动读取NandFlash的4k数据到地址0的SRAM中。如果CPU不具备这种特殊功能，用户不能直接运行NandFlash上的代码，那可以采取其他方式，比如好多使用NandFlash的开发板除了使用NandFlash以外，还用上了一块小的NorFlash来运行启动代码。
###2、容量和成本对比
相比起NandFlash来说，NorFlash的容量要小，一般在1~16MByte左右，一些新工艺采用了芯片叠加技术可以把NorFlash的容量做得大一些。在价格方面，NorFlash相比NandFlash来说较高，如目前市场上一片4Mbyte的AM29lv320 NorFlash零售价在20元左右，而一片128MByte的k9f1g08 NandFlash零售价在30元左右。
NandFlash生产过程更为简单，NAND结构可以在给定的模具尺寸内提供更高的容量，这样也就相应地降低了价格。
###3、可靠性性对比
NAND器件中的坏块是随机分布的，以前也曾有过消除坏块的努力，但发现成品率太低，代价太高，根本不划算。NAND器件需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用。在已制成的器件中，如果通过可靠的方法不能进行这项处理，将导致高故障率。而坏块问题在NorFlash上是不存在的。
在Flash的位翻转（一个bit位发生翻转）现象上，NAND的出现几率要比NorFlash大得多。这个问题在Flash存储关键文件时是致命的，所以在使用NandFlash时建议同时使用EDC/ECC等校验算法。
###4、寿命对比
在NAND闪存中每个块的最大擦写次数是一百万次，而NOR的擦写次数是十万次。闪存的使用寿命同时和文件系统的机制也有关，要求文件系统具有损耗平衡功能。
###5、升级对比
NorFlash的升级较为麻烦，因为不同容量的NorFlash的地址线需求不一样，所以在更换不同容量的NorFlash芯片时不方便。通常我们会通过在电路板的地址线上做一些跳接电阻来解决这样的问题，针对不同容量的NorFlash。
而不同容量的NandFlash的接口是固定的，所以升级简单。
###6、读写性能对比
写操作：任何flash器件的写入操作都只能在空或已擦除的单元内进行。NAND器件执行擦除操作是十分简单的，而NOR则要求在进行擦除前先要将目标块内所有的位都写为1。擦除NOR器件时是以64～128KB的块进行的，执行一个擦除/写入操作的时间约为5s。擦除NAND器件是以8～32KB的块进行的，执行一个擦除/写入操作最多只需要4ms。
读操作：NOR的读速度比NAND稍快一些。
###7、文件系统比较
Linux系统中采用MTD来管理不同类型的Flash芯片，包括NandFlash和NorFlash。支持在Flash上运行的常用文件系统有cramfs、jffs、jffs2、yaffs、yaffs2等。cramfs文件系统是只读文件系统。如果想在Flash上实现读写操作，通常在NorFlash上我们会选取jffs及jffs2文件系统，在NandFlash上选用yaffs或yaffs2文件系统。Yaffs2文件系统支持大页（大于512字节/页）的NandFlash存储器。
参考：
http://www.51hei.com/mcu/4121.html
https://zhidao.baidu.com/question/489331805743624212.html
http://blog.csdn.net/luopingfeng/article/details/23621229
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d38857cd5516ebd67b5b0043320ce1b/" rel="bookmark">
			在添加方法时，报错Uncaught TypeError: Illegal invocation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是第一次遇到这样的错误记录一下。
1.js报错：Uncaught TypeError: Illegal invocation
2. at buildParams (http://www.sxxskw.com/MyNosql/cmp/js/jquery-1.8.3.js:7271:4) at Function.jQuery.param (http://www.sxxskw.com/MyNosql/cmp/js/jquery-1.8.3.js:7238:4)
大概意思是参数传错了。
仔细检查代码，原来是把对象，当做参数传了，所以一直报错，添加不成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d3e78174a1b9e54827e28565f8ec02/" rel="bookmark">
			Numpy中的concatenate函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		concatenate(x,axis=0)
这个函数用于将多个数组进行连接，这与stack函数很容易混淆，他们之间的区别是concatenate会把当前要匹配的元素降一维，即去掉最外面那一层括号。举个例子：
axis=0 a = np.arange(8).reshape(2,2,2) b = np.arange(8).reshape(2,2,2) c=np.concatenate((a, b), axis=axis) d=np.stack((a, b), axis=axis) print(c) print(c.shape) print(d) print(d.shape) 输出 [[[0 1] [2 3]] [[4 5] [6 7]] [[0 1] [2 3]] [[4 5] [6 7]]] (4, 2, 2) [[[[0 1] [2 3]] [[4 5] [6 7]]] [[[0 1] [2 3]] [[4 5] [6 7]]]] (2, 2, 2, 2) 由此可推：
当axis=1时，c.shape为（2,4,2），d.shape为（2,2,2,2）
当axis=2时，c.shape为（2,2,4），d.shape为（2,2,2,2）
另外一个区别是，stark能够对最低维度的元素进行匹配，而concatenate是不行的，因为最低维度已经不能再降维了，因此这里stark的axis可以等于3，而concatenate不行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8241e55495c53cf30f5c2d48ffd0eb/" rel="bookmark">
			NOR flash 坏块处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 最近在处理FLASH的链表动态存储，同事提出flash中的坏块需处理，在此标记学习。
笔记 在NOR flash中，存储单元是互相并联的，每个存储单元的字线、源线分别相连。而在NAND flash中，存储单元是互相串联的，每个存储单元的字线、源线首尾相接。
可靠性比较。闪存的可靠性通常可以分为使用寿命、坏块处理两个方面。闪存的使用寿命，指的是闪存中每个单元块进行重复编程和檫除的最大次数。当超出规定的最大次数，闪存就可能工作异常。通常NOR flash的最大檫写次数是十万次，而NAND flash是一百万次。闪存内的坏块处理，是指生产出的闪存并不是完美的，总会有某些比特或者某些区域不可使用，这时候就要对闪存进行坏块处理。针对个别比特的失效，一般通过冗余比特替换或者错误检查和纠正的方法来进行纠正。冗余比特替换，是指在芯片设计时，每组存储单元会有若干个冗余比特，当该组存储单元存在失效的比特，就可以用冗余比特加以替换。冗余比特替换的方法常用于NOR flash中。错误检查和纠正（ECC），是指芯片中每组存储单元会有若干个比特用做数据的校验，当该组存储单元存在失效的比特则通过相应的数据校验算法，还原中真实的数据。错误检查和纠正的方法常用于NAND flash中。当失效的比特很多且连续时，失效的比特所在的区域会被认识是集体失效。在NOR flash中，失效的区域通常也会被冗余的存储单元块替换掉，而在NAND flash中，失效的区域会被标记为不可用。这是因为在应用中，NOR flash通常被认为是完美的，不允许出失效，而对于NAND flash来说，一点比例的失效是不可以接受的。
应用中比较。在应用中，NOR flash由于功能丰富，不需要其他的软件支持，就可以被系统直接寻址，并在内部直接运行操作代码。而NAND flash的功能相对简单，通常需要搭配相应的控制芯片和驱动程序，才能对其进行操作。
关注：http://www.docin.com/p-894327497.html 参考： http://blog.csdn.net/linweig/article/details/5030724 http://blog.csdn.net/xiaofei0859/article/details/49869585
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498afc39544026ee040d82f6063cfc00/" rel="bookmark">
			Linux环境下运行matlab以及执行m文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux下安装完matlab后，会在/usr/local/bin/下生成matlab文件，可以使用matlab命令。
在命令行下执行：
$ matlab -help
可以得到帮助文件：
Usage: matlab [-h|-help] | [-n | -e] [-arch | v=variant | v=arch/variant] [-c licensefile] [-display Xdisplay | -nodisplay] [-nosplash] [-mwvisual visualid] [-debug] [-softwareopengl] [-desktop | -nodesktop | -nojvm] [-r MATLAB_command] [-logfile log] [-Ddebugger [options]] -h|-help - Display arguments. -n - Display final environment variables, arguments, and other diagnostic information. MATLAB is not run. -e - Display ALL the environment variables and their values to standard output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498afc39544026ee040d82f6063cfc00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f99d4c046d98bf98e9d0b2b3b70b3d/" rel="bookmark">
			使用Idea更新数据库表的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tags: IDEA
我们在做案例的时候，经常需要改变数据表中的数据来进行简单测试。
那我们在Idea下是如何修改数据表的数据的呢？？？我们可以看下面的图片
只要选择updata就行了，后面再按自动提交的标志：
如果您觉得这篇文章帮助到了您，可以给作者一点鼓励
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11817d865d1306cd019240265d1ec65/" rel="bookmark">
			java swing mysql 实现的家庭收支管理系统项目源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ﻿﻿ 大家好，今天给大家演示一下一款由Java swing mysql实现的简单的家庭收支情况管理系统，也可以叫个人消费情况记录软件，功能比较紧凑简单，数据库采用的是mysql，非常适合Java初学者和学生党参看学习，下面我们来看看如何配置运行。
1. 将项目导入到eclipse（myeclipse也可以）。
2. 因为这个系统在我电脑上开发过，所以导入后发现没有任何错误提示，但是当在别的电脑导入的适合需要配置一下几个地方，不然由于电脑环境不一样会导致出错，下面我来演示配置哪几个地方。
3. 接下来我们配置数据库连接信息，在jdbcutil文件里面；
4. 接下来我们来导入数据库文件，我们用的是navicat数据库管理工具，非常好用，建议大家也使用。
5. 首先我们在navicat里面创建一个数据库：familyaccount，创建好后双击打开这个数据库，然后在这个数据库上右键-&gt;运行sql文件；
6. 运行完后刷新下就会出现数据表，下面我们万事俱备，只差运行了。
7. 打开LogOnFrm这个类，右键运行。
运行后的主界面如下：
用户名密码都是1，我们输入后看看：
登录后的主界面：
添加收支：
接下来我们来看看收支管理：
项目添加，就是类似收支、支出、旅游这种类型的添加：
项目管理：
以上就是系统的所有功能了，非常简单，适合Java初学者和学生拿来参考学习。
对这个项目感兴趣的童鞋可以按照下面方式获取源码。
获取地址：https://pan.baidu.com/s/1kV1R3Pd
若上述地址失效请加我：
V X：qixinfang002，（加的时候备注项目名称）
更多Java项目：http://blog.csdn.net/llqqxf
Java经典项目（视频开发教程+项目源码）：
http://blog.csdn.net/llqqxf/article/details/75007430
【沐伊科技教程源码】http://www.dwntme.com/h.ZZBvt22 点击链接，再选择浏览器打开；或复制这条信息￥1mhM0lk9iXJ￥后打开手淘
﻿﻿ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a23e7065ee593982202ffa6e01239e/" rel="bookmark">
			Unity3D  FPS 第一人称视角移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次写博客，有什么不足之处请多多原谅，本章的主要讲的是fps的第一人称视角，我们要知道，第一人称视角在unity3d里怎么实现，主要有两个，一个是主角和另一个是摄像机。
（如果你们认真看完这个教程fps第一人称视角是完全可以学会的。不要跳行看，看完这个教程一个小时都不到。我相信有人连这个都没看直接看下面 首先上图：
Ethan这个主角是unity自带的模型，Main Camera是一个摄像机。（图片我没处理（你以为我不想啊博客没有截屏我有ps但是我已经懒得处理了）自已放大看）
第一步：将摄像机移到主角身上作为一个子级物体（然后在Scene面板，将移动摄像机到主角面前如我上面那图）。如我上图那样子。（这时候陈独秀同学会问：上面图那么大你要我怎么找啊）陈独秀你给我过来我一巴掌你，你不会看Create面板吗？就是那个黑色箭头那个面板。对你没看错。就是黑色箭头那里。（虽然画的丑了点，但是你们看明白就行了）
第二步：在主角身上添加一个Character Controller组件。（陈独秀：这什么鬼组件，在哪里啊），呵呵，Character Controller这个组件是角色控制器的意思。位置：在我上面图片右下角那里有一个Add Component在physics里面。
然后可以写（复制）代码了是不是很开心。（开心个鬼看到代码就直接复制粘贴你们nb，不修改，你们复制下面的代码能运行我拜你为师）（照着下面照片的代码抄的同学注意了最后面一行还有一个}）
对没错就是上面那个那些代码。就50行不到就ok了，完成第一人称视角。（陈独秀：解析呢。都没有解析学个毛啊）
唉陈独秀同学就是这么心急。我一行一行给你们解析清楚ok(说是这么说反正你们又不顺着网线来打我)；
ps： 别复制下面代码。
CharacterController playerController; //这行代码是声明一个CharacterController类； Vector3 direction; //声明3维向量； public float speed = 1; //主角的移动速度 public float jumpPower = 5; //主角跳的高度 public float gravity = 7f; //重力 public float mousespeed = 5f; //鼠标快慢 public float minmouseY = -45f; //限制鼠标y轴（你们想一想眼睛能看到后面的吗？可以的话你nb） public float maxmouseY = 45f; float RotationY = 0f; float RotationX = 0f;这两个存放的是鼠标输入 public Transform agretctCamera; //这个必须在Create面板拖放Main Camera（也就是摄像机）这个位置里否则没有效果，这个类是存放的是摄像机位置； // Use this for initialization void Start () { //这个函数就不说明了，看到这里的都是基础过关了吧？ playerController = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a23e7065ee593982202ffa6e01239e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db505616f727ba9cfcf4302470d79a74/" rel="bookmark">
			基于OpenCV的静态图像人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于OpenCV的人脸识别，主要是用到了训练好的haarcascade_frontalface_default.xml文件，
这是OpenCV自带的开源库文件，只需要加载进程序之中即可。
程序如下：
#include &lt;opencv2\opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; //训练文件路径 //Note：路径需要用双右下划线，即"\\" string xmlPath = "F:\\OpenCV\\opencv\\build\\etc\\haarcascades\\haarcascade_frontalface_default.xml"; int main(int argc,char** atgv) { Mat img = imread("face.jpg"); imshow("input image", img); CascadeClassifier detector; detector.load(xmlPath); if (!detector.load(xmlPath)) //加载训练文件 { cout &lt;&lt; "不能加载指定的xml文件" &lt;&lt; endl; return -1; } vector&lt;Rect&gt; faces; detector.detectMultiScale(img, faces, 1.1, 3, 0, Size(30, 30)); for (size_t t = 0; t &lt; faces.size(); t++){ rectangle(img, faces[t], Scalar(0, 0, 255), 2, 8); } imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db505616f727ba9cfcf4302470d79a74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50730503199a80dd70cd953136d7eea7/" rel="bookmark">
			信息检索P@10、MAP、NDCG，及同一指标计算的差别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题源于我在重现一篇信息检索方面顶会论文实验的时候，始终计算不出与论文中相同的实验结果。论文的实验用到了P@10，MAP,NDCG@10三种指标。我先是用了Galago提供的计算工具，发现除P@10一项指标结果一致外，MAP,NDCG@10两项都有很大的不同。经过观察发现虽然实验结果的数据不同，但是实验结果的趋势是相同的（实验是对几种排名算法进行评比，尽管得到了不同的数据，但是用这些数据对算法进行排名，算法的好坏同样能比较出来）。有趣的是，
我同样使用了Galago提供的MAP，NDCG计算工具，对这篇论文引用的另外一篇论文同样的复现了一下实验，结果是完全一致。因此我认为虽然使用了同一种，但是对这种指标的计算存在的一些差别，哪怕同样是同一领域顶级会议的两篇论文，计算方式也不尽相同。接着我就开始自己编写计算MAP,NDCG的代码，不断的去修改尝试，终于试出了差别在哪了。
1、P@10 在说同一指标计算的差别之前，我先顺带说一下信息检索的几个常用评价指标。 P@10意思是：返回前10个结果的精确度。P英文为 Precision。直接看下图例子。 准确的说，这里演示的是P@5。一次查询中返回了上图所示的5个答案，其中第1、3、5个答案是正确的，第2、4个答案是错误的，因此这次查询的P@5=0.6。 对于一个系统而言，评价它的精确度，常用多个不同种类的查询进行测试，对每个查询分别计算P@10，取这些查询P@10的平均值作为系统的P@10。这个计算比较固定，没有什么歧义，所以各个论文中对于P@10的计算方式我看到的都是一样的。 2、MAP MAP因为为Mean Average Precision，就是说对一个叫Average Precision（AP）的东西取平均值。检测一个系统的性能，常用多个不同种类的查询对它进行测试，每个查询的结果都能计算出一个AP值，把所有AP取平均值就是系统的MAP。 那么问题就变成了如何对一次查询结果计算AP值。AP值其实是对P@n的一个扩展。上述的P@10是吧n固定为10，而AP的计算是平均P@1,P@2......P@n所有的值。 感谢网友提醒，之前对AP平均的对象说明不严谨。AP是对 每个相关文档出现时的 精度 做平均，而不是对从1到n每个精度求和算平均。查阅了论文有如下定义： 上图中的公式，r是每个相关文档的排名，R是相关文档的总数，P@r 是前r个检索到的相关文档的精度。
这里再对分母R做一个说明，R又可分为两种，一种是整个文档集合中所有相关文档的总数，包括了未出现再返回的Top-N结果内的所有相关文档，这种方式考虑到了召回率。另一种是R只算了返回的Top-N个结果内的相关文档的总数。
下面展示一个例子： 上图为对一个系统的两次查询。对于结果1，AP@10=(1.0+0.67+0.75+0.8+0.83+0.6)/6=0.78，对于结果2，AP@10=(0.5+0.4+0.5+0.57+0.56+0.6)/6=0.52。
对于一次查询，AP值可以判断优劣，但是如果涉及到一个系统整体的效果，就需要用到MAP（Mean Average Precision），简单的说，MAP的计算的是搜索查询结果AP值的均值。如上图如果表示的MAP = (0.78+0.52)/2。
不同论文中计算需要注意的区别 MAP的计算也是很简单的，但是需要注意的就是AP@n这个n的取值。MAP不像P@10这样明确的表达了要用返回结果的前10个进行计算，多数论文都没有具体写明要取前多少个计算MAP。我遇到的论文就是，实验结果得到了前1000个答案，但是它只选了前100个进行计算MAP值，虽然简单，但是没注意到的话还是会让人摸不着头脑的答案不一致。 3、NDCG@n NDCG可以拆解为四个部分，分别是N（Normalization）标准化、D（D iscounted）折减、C（C umulative）累积、G（G ain）增益。四个部分通过下式表示NDCG。 其中x表示一个查询，n表示用返回的前n个答案计算本次查询的NDCG，i表示第几个答案。 G可以理解为一个返回的答案对于本次查询质量的加分。G的大小与i无关，只取决于这个答案的质量。 D可以理解为对于一个加分的适当减分。因为越靠前的答案应该加分越多，越靠后的答案加分越少，加分G是与答案的位置前后无关的，所以需要通过D来控制加分大小。所以D是一个随答案位置i增大而增大的量。 C是对1到n个位置的G/D进行累加，得到这次查询的质量得分。 N是对得分进行归一化处理，可以理解为N是理想情况下的得分，及能够取得的最高得分。 计算NDCG存在的差异 NDCG相对于前两种指标公式会更复杂，所以计算方式存在差异的可能性更大。除了C是进行累加没有什么争议以外，N、D、G三项计算都可能存在差别 G的差别比较大，有的是直接取相关度得分rel作为G的值，有的是取2^rel-1作为G的值，当然还存在有其他的表达方式。相同的是相关度得分都是rel = {0,1,2......}。 对于D相同的都是以log(i)的形式取值，显然i=1时D=0，不可作为分母。因此发现有两种不同的方式。第一种，当i=1时，D取1，其余的取log(i)。第二种D=log(1+i)。 对于N也发现了两种计算方式。相同的是都使用了相同的DCG方式计算，不同的在于取哪些值计算。 第一种，取当前返回结果的前n的最优排序计算DCG作为N的值。例如，一组NDCG@5的相关度为X={1,0,2,2,1}，将其变化成X={2,2,1,1,0}计算DCG的值作为N。也就是说集合X的取值一定出现在答案中。但是假设返回的前n个的相关度得分都是0，N也变成了0，那么答案将出错。网络上的计算方式大多是这种。 第二种，是将整个搜索空间中的最优n个答案形成集合X，从高到低排列后计算DCG作为N的值。集合X的值不要求出现在系统返回的答案中。我在论文中遇到的是这种。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1c6a1ce1dbab7a84010068f87335d7/" rel="bookmark">
			click已经安装好了 仍然提示ImportError: No module named click
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络上的方法都试过了，还是不行， 于是重复了下命令 pip install click 结果如下 Requirement already satisfied: click in e:\anaconda3\lib\site-packages
于是去查看了下e:\anaconda3\lib\site-packages，发现里边并没有click文件，于是通过其他软件搜索到click文件，将这个文件放到e:\anaconda3\lib\site-packages下，再执行pip install click，竟然可以了
人生真是处处是惊喜！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96778fa80c20b0a57b4ece856da416d/" rel="bookmark">
			HDFS Client couldn&#39;t create proxy provider class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始文章链接：https://alphablacktan.github.io/bigdata/2018/08/12/HDFS-Client-Couldn’t-Create-Proxy-Provider-Class/
问题现象 HDFS Client抛出如下异常：
java.lang.RuntimeException: java.io.IOException: Couldn't create proxy provider class org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider at org.apache.hadoop.hdfs.NameNodeProxies.createFailoverProxyProvider(NameNodeProxies.java: 587) at org.apache.hadoop.hdfs.NameNodeProxies.createProxy(NameNodeProxies.java: 164) at org.apache.hadoop.hdfs.DFSClient.&lt;init&gt;(DFSClient.java: 359) at org.apache.hadoop.hdfs.DFSClient.&lt;init&gt;(DFSClient.java: 293) 问题分析 Classpath缺乏Hadoop Client关键Jar包hadoop-hdfs-*.jar。
问题解决方案 在Classpath下添加对应Jar（注意分布式环境在不同classloader下不同的加载机制）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04757b8094ca93c60e11d8e76e406626/" rel="bookmark">
			HDFS No Common protection layer between client and server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始文章链接：https://alphablacktan.github.io/bigdata/2018/08/12/HDFS-No-Common-Protection-Layer-Between-Client-And-Server/
问题现象 HDFS Client访问Server出现如下异常：
... Caused by: javax.security.sasl.SaslException: No common protection layer between client and server at com.sun.security.sasl.gsskerb.GssKrb5Client.doFinalHandshake(GssKrb5Client.java:251) at com.sun.security.sasl.gsskerb.GssKrb5Client.evaluateChallenge(GssKrb5Client.java:186) at org.apache.hadoop.security.SaslRpcClient.saslEvaluateToken(SaslRpcClient.java:483) at org.apache.hadoop.security.SaslRpcClient.saslConnect(SaslRpcClient.java:427) at org.apache.hadoop.ipc.Client$Connection.setupSaslConnection(Client.java:552) at org.apache.hadoop.ipc.Client$Connection.access$1800(Client.java:367) at org.apache.hadoop.ipc.Client$Connection$2.run(Client.java:717) at org.apache.hadoop.ipc.Client$Connection$2.run(Client.java:713) at java.security.AccessController.doPrivileged(Native Method) at javax.security.auth.Subject.doAs(Subject.java:422) at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1614) at org.apache.hadoop.ipc.Client$Connection.setupIOstreams(Client.java:712) ... 34 more 问题分析 该异常由服务端与客户端配置项hadoop.rpc.protection不一致导致。
问题解决方案 修正服务端或客户端hadoop.rpc.protection配置，确保两端一致。如修改服务端需重启服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7f529cc99e32b204ed47cb81547aed/" rel="bookmark">
			靠纯技术是否能渡过中年危机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自：架构师技术联盟(ID:ICT_Architect)
题记：靠纯技术是否能渡过中年危机，走路久了也该抬头看看前方路，干货枯燥，伴随音乐阅读吧
这个世界本来就不是纯技术的，人到中年就应该学会承担责任和接受这个世界你改变不了的事情。这个世界不会总存在一个父母老师一样的角色，布置作业给你做然后你做好了给你糖吃。不要指望这个世界会给你糖吃，不要指望这个世界会很公平地回报你的付出。你想对什么事情负责任你自己做决定，同时你要知道哪些事情是你改变不了的所以不要去承担责任。这不是一个技术和管理之间做选择的问题。这是一个心智成熟度的问题。我个人在知乎上面整理了几段文章来解惑：
Part 一 作者：低端叫兽
来源：知乎
绝大部分人不能。悲观点讲，大部分8090后互联网人(不仅仅是程序员)的职业生涯，可能比70后那帮老兵更短。
很长一段时间里，我都在想，我们写代码的这几年拿得多，是因为我们比那帮学生物学航天的聪明或者付出更多吗？显然不是，我们只是赶上历史行程了而已，最近的一波历史行程，说直白点，就是由智能手机和移动互联网带来的行业爆发式增长。
但 IT行业和其他行业一样，也要受行业周期的影响，不幸，或者说对后来者不幸的是，这个行业从完全竞争阶段发展到寡头垄断阶段的速度比能源，机械等传统行业快得多(一方面，这是技术进步带来了市场效率的增加，另一方面，商学院的那帮人比过去更熟练了)，阿里腾讯从差点要死的初创公司演化成全球市值前十的中国寡头，花了不过十几年时间。换句话说，十几年里就走完了传统行业需要花几十上百年才能完成的路。行业的细分领域，比如外卖，出行，只需几年就能发展到寡头垄断乃至完全垄断的地步。
过快的行业演化速度，首先带来的就是行业更快进入垄断成熟期和相关领域就业的过山车行情。比如前几年安卓和IOS程序员就业十分容易，培训班培训半年出来就敢要一万多的月薪，但随着行业的集中度提高，大量初创公司死掉(比如O2O领域)，招聘门槛明显变高，职位也变少了。其次，互联网行业推崇的破坏式创新，对从业人员，尤其是后来者来说是把双刃剑(破坏式创新 - MBA智库百科)。在一个领域里辛苦耕耘多年，结果其他领域或者方向的破坏式创新就把你的多年的工作废了甚至彻底爆掉(比如微信架空QQ,智能机颠覆功能机)。
能不能纯靠技术渡过中年危机？那就要看你对历史行程的把握了。如果你的技术方向不幸地被时代抛弃了，那不管个人怎么努力都是没有什么大用的。想明白这点后我今年再次放弃鹅厂跑券商做我押宝的领域了，建议平时多花点时间去琢磨业务，琢磨行业和产业，不要只会低头拉车，也要抬头看路，毕竟资本可以相对容易地在一个行业进退，而人到中年是很难转行的。
Part 二 作者：北南来源：知乎
中兴悲剧就不多谈了，脱离悲剧，只谈问题。首先得定义中年危机，我觉得中年危机是个很主观的定义，是否危机，是你自己的感受，而没有一个客观的标准。比如说刚毕业的年轻人一个月四千，你觉得你一个月必须得四万，如果不到四万，就中年危机了。如果你觉得你一个月只要3000就很开心，在中国的就业环境下，那我就不信你能觉得危机。 再来回答题主的问题，咱们以中国为背景，以十倍普通年轻人收入为中年危机的心理阈值，我觉得纯技术可以，但你得真有两把刷子。咱们再来定义纯技术领域怎么叫有两把刷子。 1、你得有一系列可追踪牛逼项目的经历。比如说后端，你要就要拿的出来你能处理多大scale的问题，每秒能处理多少访问。这个数字也在进步，如果你现在能游刃有余的架构千亿级日均的服务，你就是个硬通货。还有你在项目里又是什么角色，这决定你薪水的高低。好的经历会让你不缺工作。 2、你要有跟得上时代的技能树。我记得有个猎头去年和我说，“你就会个Java，落伍了”。我懒得和他掰扯。但他说的对，只会一个Java，或者只会一个PHP是不行的，现在的后端是多语种组合的时代。而且技术不停在发展，你可以不学NoSql，但就说MySQL也不是以前的那个样子了，看看阿里和亚麻对MySQL的分布式扩展。你未必真去读那么多AI的论文，但是各种框架/数据流程图那是说画就画，各种算法优缺点和适用性，要/不要训练，大概需要多少训练数据，能/不能解决什么问题，你得张口就来。 3、创造力，不是说你没事就造个轮子，整几个开源项目。你得在公司里能不断有新的想法，不是幺蛾子，是真正能提高效率，解决难题的想法。小年轻喜欢没事去网上搬现成解决方案，觉得新奇有趣，是福是祸自己也没搞清楚。作为一个老将，你得根据公司的实际情况全靠自己设计，最多出去拣点转头，胸中锦绣藏不住，万丈高楼就平地起了。 4、气质，公司招一个这么大岁数的人进来，其实主要看气质。你得稳重又不失活力，随便往哪一坐，健康的正能量就能汩汩的满地流淌。你未必需要带团队，但大家就是每天爱和你说话。这样的人不拿10倍工资，你觉得合理吗？我记得我以前在国内就招过一个比我大好几岁的，个性比我好太多了，真的特别好，有他在团队多了好多凝聚力，大家都喜欢他。 那如果达不到这么办，要么早点转管理(我看也不是每个人都是那块料，技术都没整明白，就能把人整明白了)，或者咱们心态好点，卖了房子，换个地方，大城市空气污染那么厉害，你在那赖着图个啥？像我不就远走他乡了。钱够用就行呗。
Part 三 作者：行人逆旅
来源：知乎
自从程序员跳楼后，大家都在讨论这个问题。看得多了，我对写程序的热情变小了，倒不是怕中年危机，而且热爱社会学的我对行业趋势和职业发展有了统计研究的兴趣，越思考这个问题，兴趣越浓厚。
现在的社会和过去走了很大的不同，以后和现在也会有很大的不同，工业革命前，100年间没什么变化，职业发展极其稳定。近200年间，技术不断突破，如果能统计衰落产业的人情况，就是历史经验，要比个人经验价值高出许多。
然后就是以后和现在的区别，过去是不断的技术革新，兴盛代替衰落，但目前的科技而言，人工智能飞速发展，我们对科学的认识缺没有质的进步，甚至没有令人鼓舞的进步。也就是。未来的一段时期内是没有新的产业产生的，而旧的又不断被人工智能替代。从这方面考虑，是程序员有中年危机，还是社会的大多数人有生存危机？这种情况下就算是管理岗位形势是十分严峻，多数人被替代了，对管理的需求也大大降低了。真到了这个时候，黑客和网络安全应该是最牛的了吧。
退一步说，为了社会稳定，国家机器限制人工智能的应用范围，人到中年，又有谁没有危机呢？这个时候是有专业技术的人好点还是怎么样应该很明显了吧。
这个问题的潜在条件应该是对普通人来说，我们如何度过中年危机？做管理，管理毕竟是少数，做小生意，不好意思，请离开大城市，创业，普通人去创业去挥霍资本？去投资？不好意思，这是在给别人送钱。
说到这里，我自己都觉得悲哀了。但普通人的人生就是如此啊，辛苦恣睢，奔波劳碌。但普通人有普通人的好处，心宽，穷富皆可，平安是福，团圆是乐。
怕就怕心比天高，命比纸薄。自己把自己架上去，无所得而为人谈资。如何度过中年危机，中年前认为自己是天之骄子，努力追求，中年后承认自己普通，调整心态。否则，不过一笑谈耳！
Part 四 作者：李斌
来源：知乎
1、编程重要的是思想，不是语言，语言只是工具。精通了C++，转Java分分钟的事情，我认识一个朋友，写了十五年C++，被华为辞退后两天就找到了一份java开发工作，虽然每个月4千块少了点，但老板承诺只要你能力强，月入一万不是事。还是这位朋友，一天之内就可以用C#、VB、Foxpro、Python等多种语言编写打印“Hello World”的程序和打印九九乘法表。
2、有些中年程序员，拿家庭和照顾孩子做借口，拿精力不济做借口，不愿意加班，不愿意拼搏，不愿意学习新知识。这样的人，就该淘汰出it界。it界就是快速发展，快速学习的行业，想躺在功劳簿上吃老本，办不到，公司不是慈善机构，是不养闲人的。我有个朋友，虽然年过四十，家里有俩娃老婆需要照顾，仍奋战在工作的第一线，在病重住院的前一天，还在连续加班7天7夜，即使最后过劳死，也要缴纳最后一次党费了才咽气，他们公司领导在他牺牲后，还携带了鸡蛋、水果等慰问品前去亲切的看望他的家属，叮嘱大家不要悲伤，要过个好年。
3、即使你们年到中年，但也不要想稳定。不要以为工龄长就可以拿多钱，别人应届生和你们干一样的活，每个月只拿3千块，别人说什么了？公司需要年轻化，产业也需要年轻化，否则跟不上时代的潮流。我们老板说了，公司年轻化从他做起，老板他自己就做出了榜样，功成身退，把公司交给他不到30岁的大儿子，这样的榜样难道不值得我们学习吗？下一步公司将辞退31岁以上的技术人员，招聘若干应届生和实习生顶替，大家一定拥护公司的决定啊。
祖国在发展，世界在日新月异，大家一定要不怕吃苦，甘当铁人，牺牲小家，成全大家，辛苦你一个，幸福十亿人。心若在，爱就在，大不了从头再来，员工要替公司想，你不下岗谁下岗。
结尾总结 中年危机大概率是职业家庭进入瓶颈期，脱离了每年7%高速增长的轨道，心态L型硬着陆的过程。如果技术增长持续乏力的话，就只能考虑供给侧改革了。历史的教训都是一致的，能不能单纯靠技术渡过中年危机，没什么确定的答案，要么够技术，要么够单纯，要么就换条路撸起袖子加油干去了。
PS：文章很长，能看到这里的朋友，都是英雄，小编对你充满了崇拜之心！
特别推荐一个JAVA架构交流QQ群：619881427
1、具有1-5工作经验的，面对目前流行的技术不知从何下手，需要突破技术瓶颈的可以加群。
2、在公司待久了，过得很安逸，但跳槽时面试碰壁。需要在短时间内进修、跳槽拿高薪的可以加群。
3、如果没有工作经验，但基础非常扎实，对java工作机制，常用设计思想，常用java开发框架掌握熟练的，可以加群。
4、觉得自己很牛B，一般需求都能搞定。但是所学的知识点没有系统化，很难在技术领域继续突破的可以加群。
5.阿里Java架构师，分享知识，多年工作经验的梳理和总结，带着大家全面、科学地建立自己的技术体系和技术认知
觉得有帮助？请转发给更多人！
架构师小秘圈，聚集10万架构师的小圈子！不定期分享技术干货，行业秘闻！汇集各类奇妙好玩的话题和流行动向！长按左侧图片，扫码加入架构师微信群！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc14e697c2746a5b4a2a382ed4ea2fd5/" rel="bookmark">
			秀米编辑后复制粘贴格式发生变形的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个后台管理，测试阶段我们前端发现他在秀米上设计好板式复制到我们的编辑器上时样式发生了一些变化，需要我去处理一下。
在做了一些测试后发现是由于编辑器自动过滤了一些HTML代码引起的，在查阅了一些资料后发现使我们编辑器的问题，我们用的是KindEditor，据官方文档：4.1.1版本开始默认开启白名单过滤，只能使用htmlTags里定义的HTML标签和属性，其它标签和属性会被编辑器过滤。也就是说
像这样的代码：
&lt;table class="shoptable ke-zeroborder" border="0" cellspacing="0" cellpadding="0" width="464" align="left"&gt; 读取的内容就会被过滤为：
&lt;table border="0" cellspacing="0" cellpadding="0" width="705" align="left"&gt; 我的解决办法是在引用编辑器的HTML中加入如下代码：
&lt;script&gt; $(function() { KindEditor.options.filterMode = false; var editor = KindEditor.create('#content'); }); &lt;/script&gt; 将他默认的过滤设置为FALSE。
经测试后是没问题的，希望能给大家一些帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/600e662eddfd1a9e03504da766261be2/" rel="bookmark">
			HBase on Spark NioWorkerPool VerifyError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始文章链接：https://alphablacktan.github.io/bigdata/2018/08/12/HBase-On-Spark-NioWorkerPool-VerifyError/
问题现象 提交HBase on Spark的Yarn Cluster任务时，AM启动失败，抛出如下异常：
ERROR [2016-08-22 14:54:47,127] ({sparkDriverActorSystem-akka.actor.default-dispatcher-7} Slf4jLogger.scala[apply$mcV$sp]:66) - Uncaught fatal error from thread [sparkDriverActorSystem-akka.remote.default-remote-dispatcher-8] shutting down ActorSystem [sparkDriverActorSystem] java.lang.VerifyError: (class: org/jboss/netty/channel/socket/nio/NioWorkerPool, method: createWorker signature: (Ljava/util/concurrent/Executor;)Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker Wrong return type in function at akka.remote.transport.netty.NettyTransport.&lt;init&gt;(NettyTransport.scala:283) at akka.remote.transport.netty.NettyTransport.&lt;init&gt;(NettyTransport.scala:240) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at akka.actor.ReflectiveDynamicAccess$$anonfun$createInstanceFor$2.apply(DynamicAccess.scala:78) at scala.util.Try$.apply(Try.scala:161) at akka.actor.ReflectiveDynamicAccess.createInstanceFor(DynamicAccess.scala:73) at akka.actor.ReflectiveDynamicAccess$$anonfun$createInstanceFor$3.apply(DynamicAccess.scala:84) at akka.actor.ReflectiveDynamicAccess$$anonfun$createInstanceFor$3.apply(DynamicAccess.scala:84) at scala.util.Success.flatMap(Try.scala:200) ... 问题分析 从堆栈中可以看出，问题出在NioWorker的初始化过程中，发生了调用方法得到了非预期的返回值的状况。这种状况一般出现在依赖jar与环境jar版本不一致或者lib包出现多版本冲突的时候。根据堆栈可以得出问题出在Netty包，进而通过查询可以发现Netty在两个版本间接口存在变动。
问题解决方案 排查Classpath中是否存在多版本Netty包，以及编译Netty依赖是否与环境一致。
注：Spark Assembly包中通常含有Netty包的类，注意排查。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef636c94205a957c7ae21284dd8d8c8/" rel="bookmark">
			如果有一天程序员再也不忙了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
程序员是世界上最可爱的人！
正文
（一）：程序员是什么
（二）：程序员写的代码有什么用
（三）：程序员最本质的不同是什么
（四）：程序员为什么找不到妹子
（五）：程序员的工作究竟有多忙
（六）：有一天程序员不忙了会怎样
（七）：找不到妹子真的是因为工作忙吗
（八）：你自己看吧。。。
所以我说的对吗？
推荐阅读：
技术：年关到了，程序员是时候考虑离职了
技术：分布式唯一ID极简教程
职场：程序员职业规划
分享：2T架构师学习资料干货分享
觉得有帮助？请转发给更多人！
架构师小秘圈，聚集10万架构师的小圈子！不定期分享技术干货，行业秘闻！汇集各类奇妙好玩的话题和流行动向！长按左侧图片，扫码加入架构师微信群！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c820bec65976b6fe05ba1d130ba6dfe/" rel="bookmark">
			Python练手经典100例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博文转载自：http://blog.csdn.net/dajiangtai007/article/details/65632987
100个Python练手小程序，学习python的很好的资料，覆盖了python中的每一部分，可以边学习边练习，更容易掌握python。
【程序1】 题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去 掉不满足条件的排列。 2.程序源代码：
for i in range(1,5): for j in range(1,5): for k in range(1,5): if( i != k ) and (i != j) and (j != k): print i,j,k 12345 【程序2】 题目：企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高 于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可可提 成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于 40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于 100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？ 1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。　2.程序源代码：
bonus1 = 100000 * 0.1 bonus2 = bonus1 + 100000 * 0.500075 bonus4 = bonus2 + 200000 * 0.5 bonus6 = bonus4 + 200000 * 0.3 bonus10 = bonus6 + 400000 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c820bec65976b6fe05ba1d130ba6dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facb296a35cfaf2721f7ccc461235d84/" rel="bookmark">
			app如何获取ANR时产生的trace文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跑了个Demo程序，想把/data/anr/trace.txt文件拿到，然而普通app是无法获取该文件的，就算把手机root也不行。
因为不知道进入anr文件的api，就直接使用路径创建文件，同时使用一个可以获取的文件做为对比，说明该刚发可行，确实是app拿不到trace.txt。
先通过adb，进入app的外部存储路径看看有什么文件： 以ecmsLogger(java).log文件为例，通过代码拿到该文件： 结果： 说明这种方法是可以拿到文件的，下面通过同样方法，尝试获取trace.txt: 先通过adb，进入目录，确实是存在trace.txt文件，然后通过同样的代码尝试获取该文件： 结果： 拿不到…………
是不是权限不够？试试把app push到system/app目录下： 同样先check一下有没有trace.txt: 有的，以相同代码运行，结果： 仍然没有拿到。
跑个Demo，至少说明通过这种方法无法拿到想要的trace文件，还没有找到其它方法。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39d464d075137eda258a352efc57c6d/" rel="bookmark">
			php ob库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是ob
ob的全称（output_buffering ）输出缓冲区，输出缓冲区通过php.ini中的output_buffering变量控制的，这个默认值是off,可以设置为on来打开buffer。打开buffer后。即便程序中没有用ob函数，实际上代码也是使用缓冲区。另外，不管PHP.ini中output_bufering 的设置，cli模式下的PHP始终默认是关闭。引入缓冲区，CPU可以快速生成数据进入缓冲区。优势是合理解决了告诉CPU与低速I/O设置矛盾的。
ob原则：如果开启ob缓存，那么echo的数据会优先进入ob缓存。如果是header信息，就直接放入程序缓存。页面执行到最后，会把ob缓存的数据放入程序缓存，然后依次返回给浏览器。
ob的作用： 1--防止浏览器有输出之后使用setcookie .header || session_start等发送文件的函数造成的错误，尽量少使用为好； 2--对一些不可或缺的函数输出，如PHPinfo会输出大量的HTML信息，但是我们无法用一个变量例如 $info =phpinfo(); 这时候就不能使用了，我们就找ob来帮忙； 3--对输出的内容进行处理，可以gzip压缩，字体的简繁转换，还有一些字符串的替换等； 4--生成静态文件，捕捉整个页的输出，然后存成文件，生成HTML或整个页缓存中使用；
1、ob_start: 函数一般主要是用来开启缓存，注意使用ob_start之前不能输出空格、字符等。
2、ob_get_contents函数主要获取缓存中的内容以字符，注意这个函数必须在ob_end_clean函数之前调用，否则取不动缓存内容。
3、ob_end_clean函数主要是清空缓存中的内容并关闭缓存，成功true 失败false；
4、flush:刷新缓存区内容，输出。 这个函数经常使用效率高
5、ob_get_length:返回内容缓存区的长度 函数返回当前缓冲区的长度&amp;ob_get_contents一样，如果输出缓冲区没激活，返回false
6、ob_end_flush:发送内部缓存区的内容到了浏览器，并且关闭输出缓冲区 此函数发送输出缓冲区的内容
7、ob_end_clean:删除内部缓冲区的内容，并关闭内部缓冲区 此函数不会输出内容不输出内部缓冲区的内容而是删除。
8、ob_implicit_flush :打开或关闭绝对刷新 ob_implicit_flush([int flag]) 用过perl的人都知道$|=x的意思，这个字符可以打开|关闭缓冲区，而ob_imlicit_flush函数页和那个一样，默认是关闭缓冲区，打开绝对输出后，每个脚本输出直接发送到浏览器，不需要调用flush()
明日待续····
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/255/">«</a>
	<span class="pagination__item pagination__item--current">256/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/257/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>