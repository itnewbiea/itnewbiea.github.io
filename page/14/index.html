<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9430f83ac0f727e88a1a79b1152e48d1/" rel="bookmark">
			MPLS动态协议LDP配置示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、预习： MPLS：Multi-Protocol Label Switching多协议标签交换，是一种根据报文中携带的标签转发的技术；可承载在各种链路层协议之上（如PPP、ATM、帧中继、以太网）；同时它还能承载各种网络层报文，如ipv4、ipv6；采用无连接的控制平面，实现路由信息的传递和标签的分发，采用面向连接的数据平面，实现报文在建立的标签转发路径上传送。LSR之间运行LDP来告知其他LSR本设备上的标签绑定信息，从而实现标签报文的正确转发。
技术创新：摒弃了繁琐的路由查找 ，将具有全局意义的路由表改为简单快速的标签交换；MPLS转发的本质就是将数据归到对应的FEC并按照提前建立好的LSP进行转发
MPLS在二层以太网网络协议号中使用8847或8848，IP协议号为0800，端口号646，BGP端口号179
MPLS实际应用场景： 随着硬件技术的发展，ip转发性能也大大提高，MPLS在这方面并未发挥优势，但由于MPLS结合了IP网络强大的三层路由功能和二层网络高效的转发机制，所以目前MPLS主要应用于VPN技术，TE（Traffic Engineering，流量工程）以及QOS（Quality of Service，服务质量）。
提示：基于MPLS的VPN通过LSP将私有网络的不同分支连接起来，形成一个统一的网络，用户设备无需为VPN配置GRE、L2TP等隧道；网络延时也会被降至最低。
MPLS体系结构 ： 控制平面：负责产生和维护路由以及标签信息；包括IP路由协议和路由信息表，标签分发协议和标签信息表
转发平面：也称数据平面，负责普通IP报文的转及带MPLS标签报文的转发；转发平面包括转发信息表和标签转发信息表
LSR：Label Switching Router，标签交换路由器，由LSR 构成的网络区域称为 MPLS域（MPLS Domain），在 IP 网络内进行传统的 IP 转发，在 MPLS 域内进行标签转发。
LER：Label EdgeRouter位于 MPLS 域边缘、连接其它网络的边缘路由器，进入到MPLS网络的流量由LER分为不同的FEC；
Core LSR：区域内部的 LSR 称为核心 LSR。
LSR分类：
Ingress LSR 入站标签，压入MPLS头部并生成MPLS报文的LSR
Transit LSR 中转LSR，做标签转换操作
Egrss LSR 出站LSR，做剥离MPLS标签操作
LSP：Label Switch Path 标签交换通道
LDP：Label Distribution Protocol，标签分发协议是MPLS的一种控制协议，相当于传统网络中的信令协议，负责FEC的分类、标签的分配及LSP的建立和维护等操作。LDP规定了标签分发过程中的各种消息及相关处理过程。
LSP：Label Switch Path，标签交换路径|通道，是标签报文穿越MPLS网络到达目的地所走的路径，LSP是单向的路径，和数据流的方向一致同一个FEC的报文通常采用相同的LSP穿越MPLS域，所以对同一个FEC，LSR总是用相同的标签转发。
Label Stack：MPLS支持一层或者多层标签头部，这些标签头部的有序集合被称为标签栈
FEC：Forwarding Equivalence Class，转发等价类，是一组具有某些共性的数据流的集合，这些数据流在转发过程中被网络节点以相同方式处理，MPLS基于FEC发放标签；在转发过程中以等价的方式来标识创建FEC，通常的MPLS只是一条路由对应一个FEC
在MPLS网络中，FEC可通过多种方式划分，如基于目的IP及网络掩码、DSCP等特征来划分
数据属于另一个LSP，由数据 进入MPLS域时的Ingress LSR 决定
MPLS标签通常是与FEC相对应的，必须有某种机制使得网络中的LSR获得关于某FEC的标签信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9430f83ac0f727e88a1a79b1152e48d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b180a9ef7f443fc3dea89623cb99c9e5/" rel="bookmark">
			linux stop_machine 停机机制应用及一次触发 soft lockup 分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 stop_mchine 引起的 soft lockup触发 soft lockup 原因分析（一）：触发 soft lockup 原因分析（二）触发 soft lockup 原因分析（三） stop_mchine 引起的 soft lockup 某次在服务器上某节点发现系统有大量 soft lockup 打印，如下：
May 8 11:46:12 node-2 kernel: watchdog: BUG: soft lockup - CPU#116 stuck for 22s! [migration/116:733] May 8 12:45:00 node-2 kernel: watchdog: BUG: soft lockup - CPU#104 stuck for 23s! [migration/104:659] May 8 12:45:34 node-2 kernel: watchdog: BUG: soft lockup - CPU#21 stuck for 23s! [migration/21:139] May 8 12:46:04 node-2 kernel: watchdog: BUG: soft lockup - CPU#121 stuck for 22s!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b180a9ef7f443fc3dea89623cb99c9e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33965879546dc0a14623931ba4051a32/" rel="bookmark">
			Oracle-数据库迁移之后性能变慢问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景：
​一套Oracle11.2.0.4的RAC集群，通过Dataguard switchover方式迁移到新机器之后，运行第一天应用报障说应用性能慢，需要进行性能问题排查
问题分析：
首先，登陆到服务器，用TOP看一眼两个节点数据库的服务器整体负载情况，节点二的负载别节点一高，但整体cpu，io等待负载还是在正常的范围内，查看数据库的等待事件，也没有大量IO，锁争用的等待事件，初步判断数据库的整体负载正常，可能是某些模块语句有问题，再次跟应用确认应用是全部慢，还是某个功能、语句慢，得到应用回复说是部分涉及与其他系统交互的存储过程执行起来慢，这与我们之前的初步判断基本一致，那接下来我们的分析方向就锁定为这一类涉及与其他系统交互的存储过程
让应用提供了其中一个正在执行的存储过程XXX_APP_INTERFACE_PKG.GET_PRE_XXX_RESULT，sql_id:6321wf6xz0at4,应用描述这个存储过程迁移之前的执行时间是在5分钟之内可以执行完，现在的执行时间要超过10分钟以上，最近一次30分钟还没执行完，查看当前执行存储过程的会话，等待事件为TCP Socket (KGAS)
注:KGAS是数据库服务层中处理TCP/IP套接字的组件，KGAS接口不参与客户端/服务器通信，而是当数据库服务上的会话使用PLSQL包如UTL_HTTP，UTL_TCP进行TCP/IP调用时使用到，在调用过程出现的等待为TCP Socket (KGAS)
用10046跟踪了该会话执行的sql情况，并用tkprof格式化跟踪产生的trc文件
--跟踪会话 oradebug setmypid oradebug unlimit 106903 oradebug event 10046 trace name context forever,level 12 oradebug tracefile_name --关闭跟踪会话 oradebug event 10046 trace name context off --格式化trc文件 tkprof trc文件 生成文件 从trc文件看，执行的存储过程语句主要的等待为SQL*Net message from dblink等待从dblink的目标端返回数据，没有发现涉及调用UTL_HTTP，UTL_TCP的语句
先查看了调用的dblink语句，语句只调用了dblink目标端的表，没有与源端的表进行关联，去掉dblink直接在目标端跑了一下，发现语句的执行效率的确一般，执行时间需要6-7秒，主要消耗在于语句里面一张超过1G大小的表XXX_PARAM_LIST的全表扫描
查询语句结构不复杂，where条件列组合的唯一值也较多过滤行不错，可以直接通过创建一个组合索引快速优化这个语句，创建索引优化了语句，执行时间降为1秒以内
优化了高消耗的语句之后，存储过程的执行速度还是没有任何改善，还是要找到真正引发TCP Socket (KGAS)等待的代码，直接去分析10046生成的trc文件，之前是检查生成的tkprof文件，格式完之后的文件可能会遗漏了一些存储过程执行的信息，直接是trc里面搜等待事件TCP Socket (KGAS)的关键字，发现了一些引发等待事件TCP Socket (KGAS)的输入值，里面有个http开头的url地址
进一步查看了存储过程里面的代码，发现里面调用了一个消息推送的存储过程，该存储过程使用了UTL_HTTP包进行了外部url的请求
尝试使用curl工具从数据库的服务器去测试之前发现的url能否访问成功，出现访问超时的报错Failed connect to xxxxx;connection timed out，到这里终于抓到了问题的真凶，存储过程里面通过UTL_HTTP包进行了外部url的消息推送，而数据库服务器与请求的url存在网络通信不通问题，导致存储过程一直出现TCP Socket (KGAS)的等待，存储过程执行缓慢
进一步跟网络管理员确认，迁移之后并没有完全开通新服务器到应用系统的网络策略，而数据库迁移只是替换了scan ip，主机的IP是发生了变化的，所以数据库服务器跟一些外部的应用系统存在网络不通的问题，最终导致数据库迁移到新环境之后，那些存在系统交互的存储过程执行起来变慢
问题解决：
网络重新开通了网络策略，将新数据库服务器的主机IP加入到了旧的数据库组里面，确保新数据库服务器与应用系统的网络相通，存储过程的执行效率也恢复了正常，平均执行时间从原来的2417秒降到了2.85秒
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e6be5d64b67c1956e7950ada0c7f80/" rel="bookmark">
			Spring Boot核心特性、注解和Bean作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 是基于 Spring Framework 构建应用程序的框架，Spring Framework 是一个广泛使用的用于构建基于 Java 的企业应用程序的开源框架。Spring Boot 旨在使创建独立的、生产级别的 Spring 应用程序变得容易，您可以"只是运行"这些应用程序。
1. 术语 Spring Core 是 Spring Framework 的基础，为基于 Java 的应用程序提供了全面的编程和配置模型。这里是与 Spring Core 相关的一些关键术语和概念：
Bean：在 Spring 中，“bean”是由 Spring 容器管理的 Java 对象。通常使用配置元数据来定义bean，可以在 XML、Java 注释或 Java 代码中指定。控制反转（IoC）：Spring 的主要原则之一是控制反转（IoC），这意味着 Spring 容器负责管理bean的生命周期并注入其依赖项。依赖注入（DI）：Spring 使用依赖注入（DI）来管理 bean 之间的依赖关系。在 DI 中，对象的依赖项由容器提供，而不是对象自己创建或查找其自己的依赖项。容器：Spring 容器是 Spring Framework 的核心部分，它创建和管理bean及其依赖项。ApplicationContext：ApplicationContext 是 Spring 容器的实现。它负责加载和管理配置元数据，并创建在该元数据中定义的bean。面向切面编程（AOP）：Spring 支持面向切面编程（AOP），允许您将横切关注点（例如日志记录或安全性）与应用程序的业务逻辑分离。事件：Spring 提供了一种事件模型，允许 bean 发送和接收事件。这用于将bean彼此解耦，使应用程序更松散耦合。ApplicationEvent和监听器：Spring 支持发布订阅模型来处理事件，ApplicationEvent 定义事件对象，监听器是实现 ApplicationListener 接口的类，监听特定事件并采取必要的操作。数据访问：Spring 使用各种框架（如 JDBC、Hibernate、JPA）提供了一致的高级数据访问抽象。事务：Spring 提供了一种灵活、一致且易于声明式地使用不同底层技术（如 JPA、JDBC 和 Hibernate）管理事务的方法。任务执行和调度：Spring 提供了 TaskExecutor 和 TaskScheduler，提供了一种方便的方式来并发运行任务，在计划的基础上或异步运行。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e6be5d64b67c1956e7950ada0c7f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f19e64701e766be173fc95374a967bb/" rel="bookmark">
			使用 Jackson 提取 JSON 数据值 - JsonUtils工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提取值 JsonUtils工具类提供了一个extractValue方法，用于从JSON数据中提取特定字段的值。该方法支持返回单一值或值列表，具体取决于JSON数据中字段的类型。
/** * 从 JSON 数据中提取值 * * @param jsonData JSON 数据字符串 * @param field 字段名称 * @return 提取到的值，如果是列表则返回列表 */ public static Object extractValue(String jsonData, String field) { try { ObjectMapper objectMapper = new ObjectMapper(); JsonNode jsonNode = objectMapper.readTree(jsonData); // 使用 JsonNode.at 方法获取指定路径的节点 JsonNode targetNode = jsonNode.at(field); // 如果节点是列表，将列表转换为 Java List if (targetNode.isArray()) { List&lt;String&gt; values = new ArrayList&lt;&gt;(); Iterator&lt;JsonNode&gt; elements = targetNode.elements(); while (elements.hasNext()) { values.add(elements.next().asText()); } return values; } else { // 如果节点不是列表，直接返回节点的文本值 return targetNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f19e64701e766be173fc95374a967bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f06cf71b889271f2237d4cc30769e2/" rel="bookmark">
			k8s中实现pod自动扩缩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、k8s应用自动扩缩容概述
1）背景：
在实际的业务场景中，我们经常会遇到某个服务需要扩容的场景（例如：测试对服务压测、电商平台秒杀、大促活动、或由于资源紧张、工作负载降低等都需要对服务实例数进行扩缩容操作）。
2）扩缩容分类
对象分类
• node扩缩容
• 在使用 kubernetes 集群经常问到的一个问题是，我应该保持多大的节点规模来满足应用需求呢？cluster-autoscaler 的出现解决了这个问题， 可以通过 cluster-autoscaler 实现节点级别的动态添加与删除，动态调整容器资源池，应对峰值流量。
• pod层面
• 我们一般会使用 Deployment 中的 replicas 参数，设置多个副本集来保证服务的高可用，但是这是一个固定的值，比如我们设置 10 个副本，就会启 10 个 pod 同时 running 来提供服务。如果这个服务平时流量很少的时候，也是 10 个 pod 同时在 running，而流量突然暴增时，有可能出现 10 个 pod 不够用的情况。针对这种情况怎么办？就需要自动扩缩容。
按方式分类
• 手动模式
通过 kubectl scale 命令，这样需要每次去手工操作一次，而且不确定什么时候业务请求量就很大了，所以如果不能做到自动化的去扩缩容的话，这也是一个很麻烦的事情。
• 自动模式
kubernetes HPA（Horizontal Pod Autoscaling）：根据监控指标（cpu 使用率、磁盘、自定义的等）自动扩容或缩容服务中的pod数量，当业务需求增加时，系统将无缝地自动增加适量 pod 容器，提高系统稳定性。
kubernetes KPA（Knative Pod Autoscaler）：基于请求数对 Pod 自动扩缩容，KPA 的主要限制在于它不支持基于 CPU 的自动扩缩容。
kubernetes VPA（Vertical Pod Autoscaler）：基于 Pod 的资源使用情况自动设置 pod 的 CPU 和内存的 requests，从而让集群将 Pod 调度到有足够资源的最佳节点上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f06cf71b889271f2237d4cc30769e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dddfd8b89436d9cffbf17741797a5b7/" rel="bookmark">
			深入理解ArkTS：Harmony OS 应用开发语言 TypeScript 的基础语法和关键特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArkTS 是 Harmony OS 应用开发中使用的 TypeScript 框架，它提供了一种基于 TypeScript 的应用开发方式。下面是 ArkTS 的基础语法和关键特性的概述，并附带一些例子：
1. 类型注解（Type Annotations）：使用类型注解可以明确指定变量的类型，帮助开发者在编码阶段发现潜在的类型错误。
- 例子：
let message: string = "Hello, ArkTS!"; let count: number = 10; 2. 接口和类型别名（Interfaces and Type Aliases）：使用接口定义对象的结构和方法，或使用类型别名给类型起一个别名，提高代码的可读性和可维护性。
- 例子：
interface Person { name: string; age: number; } type Point = { x: number; y: number }; 3. 类和继承（Classes and Inheritance）：使用类来创建对象，定义属性和方法，并通过继承来实现代码的复用。
- 例子：
class Animal { name: string; constructor(name: string) { this.name = name; } speak() { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dddfd8b89436d9cffbf17741797a5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f00e1daa52b7cb5c5bc865e89dbc79/" rel="bookmark">
			Numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 numpy基础运算axis numpy的索引numpy array合并numpy分割numpy copy &amp; deep copy numpy基础运算 import numpy as np array=np.array([[1,2,3],[2,3,4]]) # 用array将列表转化成数组 print(array) #矩阵 [[1 2 3] [2 3 4]] array.ndim # 数组维度 2 array.shape #(行数，列数) (2, 3) array.size #元素 6 a = np.array([2,23,4], dtype=np.int64) #a的数据类型 a.dtype dtype('int64') a=np.array([[1,2,3],[2,3,4]]) a array([[1, 2, 3], [2, 3, 4]]) a1 = np.zeros((3,4)) a1 array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) a2 = np.ones((3,4),dtype=np.int32) a2 array([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) a3 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f00e1daa52b7cb5c5bc865e89dbc79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7360bf28a57794194cea7433620fed/" rel="bookmark">
			前端使用 ＜el-descriptions＞标签报错： ＜el-descriptions＞ - did you register the component correctly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 el Descriptions 描述列表时前端报错 - did you register the component correctly
报错原因： element-ui版本问题。是到了element-ui 2.15.6才开始更新上线的，而项目里的element-ui是 2.15.6以下的版本，所以使用报错。 解决方案： 将项目内element-ui更新到最新版本 1.卸载现有element-ui版本
npm uninstall element-ui 2.安装最新版element-ui
npm i element-ui -S 3.重新安装依赖
npm install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558655108162468aa3ab192d3bdd422f/" rel="bookmark">
			【Unity3D之日常BUG】Unity3D中出现WakeUp为空的时候时候解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 推荐阅读
CSDN主页GitHub开源地址Unity3D插件分享简书地址我的个人博客 大家好，我是佛系工程师☆恬静的小魔龙☆，不定时更新Unity开发技巧，觉得有用记得一键三连哦。
一、前言 今天在开发中遇到一个问题（以前也遇到过，没想起来记下来），也就是WakeUp为空，具体错误提示是这样的：
UnityEditor.Graphs.Edge.WakeUp ()
NullReferenceException: Object reference not set to an instance of an object UnityEditor.Graphs.Edge.WakeUp () (at :0) UnityEditor.Graphs.Graph.DoWakeUpEdges (System.Collections.Generic.List1[T] inEdges, System.Collections.Generic.List1[T] ok, System.Collections.Generic.List`1[T] error, System.Boolean inEdgesUsedToBeValid) (at :0) UnityEditor.Graphs.Graph.WakeUpEdges (System.Boolean clearSlotEdges) (at :0) UnityEditor.Graphs.Graph.WakeUp (System.Boolean force) (at :0) UnityEditor.Graphs.Graph.WakeUp () (at :0) UnityEditor.Graphs.Graph.OnEnable () (at :0) 二、解决方案 这个是Unity3D自身存在的BUG，代码位于UnityEditor.Graphs.DLL中。
这个BUG需要操作什么，只需要尝试关闭和重新打开Unity项目即可。
这个问题似乎在删除和重新创建没有任何变换Transform的动画控制器Animator的时候，很常出现这种情况。
三、后记 如果觉得本篇文章有用别忘了点个关注，关注不迷路，持续分享更多Unity干货文章。
你的点赞就是对博主的支持，有问题记得留言：
博主主页有联系方式。
博主还有跟多宝藏文章等待你的发掘哦：
专栏方向简介Unity3D开发小游戏小游戏开发教程分享一些使用Unity3D引擎开发的小游戏，分享一些制作小游戏的教程。Unity3D从入门到进阶入门从自学Unity中获取灵感，总结从零开始学习Unity的路线，有C#和Unity的知识。Unity3D之UGUIUGUIUnity的UI系统UGUI全解析，从UGUI的基础控件开始讲起，然后将UGUI的原理，UGUI的使用全面教学。Unity3D之读取数据文件读取使用Unity3D读取txt文档、json文档、xml文档、csv文档、Excel文档。Unity3D之数据集合数据集合数组集合：数组、List、字典、堆栈、链表等数据集合知识分享。Unity3D之VR/AR（虚拟仿真）开发虚拟仿真总结博主工作常见的虚拟仿真需求进行案例讲解。Unity3D之插件插件主要分享在Unity开发中用到的一些插件使用方法，插件介绍等Unity3D之日常开发日常记录主要是博主日常开发中用到的，用到的方法技巧，开发思路，代码分享等Unity3D之日常BUG日常记录记录在使用Unity3D编辑器开发项目过程中，遇到的BUG和坑，让后来人可以有些参考。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d456f8d6a7cf9fd107a72356541679a/" rel="bookmark">
			Tomcat与Servlet是什么关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat与Servlet是什么关系 Apache Tomcat和Servlet之间存在密切的关系，可以说它们是一对密切合作的组件。下面是它们的关系：
Tomcat是Servlet容器： Tomcat是一个开源的、轻量级的Servlet容器。Servlet容器是一个Web服务器扩展，用于支持Servlet的部署和执行。Tomcat的主要功能之一就是管理和执行Servlet。
Servlet是Java Web应用的一部分： Servlet是Java编写的服务器端程序，用于处理Web请求和生成Web响应。Servlet通常用于构建Web应用程序的后端逻辑。它们与客户端（通常是浏览器）之间通过HTTP通信，处理用户请求，生成动态内容，并返回相应的响应。
Tomcat支持Servlet规范： Servlet规范是Java企业版（Java EE）的一部分，定义了Servlet的API和行为。Tomcat实现了Servlet规范，因此可以部署和执行符合规范的Servlet。这就是为什么你可以将Servlet部署到Tomcat服务器中并运行它们的原因。
Tomcat提供了Servlet容器环境： 当你将一个Web应用程序部署到Tomcat中时，Tomcat负责管理Servlet的生命周期、处理HTTP请求和响应、维护会话等。Tomcat提供了一个运行时环境，使得Servlet可以在其中执行。
总的来说，Tomcat是一个Servlet容器，为Servlet提供了运行环境，而Servlet是Java Web应用程序的一部分，用于处理Web请求和生成动态内容。在Java Web开发中，Tomcat和Servlet经常一起使用，以构建强大的Web应用程序。
再看另一种说法：
Tomcat 和 Servlet 之间有密切的关系，它们是 Java Web 应用程序开发中的两个关键组件。
Tomcat： Apache Tomcat 是一个开源的、轻量级的、用于支持 Java Servlet 和 JavaServer Pages (JSP) 的应用服务器。它实际上是一个 Servlet 容器，负责处理和管理 Servlet 和 JSP 程序的运行。Tomcat 提供了一个环境，使得开发人员能够在 Web 服务器上运行和管理 Java Web 应用程序。
Servlet： Servlet 是一种 Java 编写的服务器端程序，用于处理客户端的请求并生成动态的 Web 内容。Servlet 通常被部署在支持 Java Servlet 规范的 Servlet 容器（如 Tomcat）中。Servlet 允许开发人员在服务器端创建动态的、可交互的 Web 应用程序。Servlet 可以接收来自客户端的请求，处理请求并生成响应，然后将响应发送回客户端。
关系总结：
Tomcat 是一个 Servlet 容器，提供了运行和管理 Servlet 的环境。Servlet 是服务器端的 Java 程序，用于处理客户端的请求和生成动态的 Web 内容。当一个 Web 应用程序中包含 Servlet 时，这个应用程序通常会被部署到 Tomcat 或类似的 Servlet 容器中。Tomcat 负责管理 Servlet 的生命周期、处理请求和响应等任务，使得开发人员可以专注于编写 Servlet 程序而不必关心底层的服务器管理细节。 综上所述，Tomcat 是 Servlet 的运行环境和管理者，Servlet 是在这个环境中运行的服务器端 Java 程序。它们一起构成了 Java Web 应用程序的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0809169a75986395e483fc50076da6a3/" rel="bookmark">
			【数据分析】指数移动平均线的直观解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@slavahead 一、介绍 在时间序列分析中，通常需要通过考虑先前的值来了解序列的趋势方向。序列中下一个值的近似可以通过多种方式执行，包括使用简单基线或构建高级机器学习模型。
指数（加权）移动平均线是这两种方法之间的稳健权衡。在幕后有一个简单的递归方法可以有效地实现该算法。同时，它非常灵活，可以成功适应大多数类型的序列。
本文介绍了该方法背后的动机、其工作流程和偏差校正的描述——一种克服近似中偏差障碍的有效技术。
二、动机 想象一个近似随时间变化的给定参数的问题。在每次迭代中，我们都知道它之前的所有值。目标是根据先前的值来预测下一个值。
一种幼稚的策略是简单地取最后几个值的平均值。这在某些情况下可能有效，但不太适合参数更依赖于最新值的情况。
克服此问题的可能方法之一是将较高的权重分配给较新的值，并将较少的权重分配给先前的值。指数移动平均线正是遵循这一原则的策略。它基于这样的假设：变量的较新值比先前值对下一个值的形成贡献更大。
三、公式 为了理解指数移动平均线的工作原理，让我们看看它的递归方程：
指数移动平均公式
vₜ 是近似给定变量的时间序列。它的索引 t 对应于时间戳 t。由于该公式是递归的，因此需要初始时间戳 t = 0 的值 v₀。实际中，v₀通常取0。θ 是当前迭代的观测值。β 是一个介于 0 和 1 之间的超参数，定义权重重要性应如何在先前平均值 vₜ-₁ 和当前观测值 θ 之间分布 让我们为前几个参数值写下这个公式：
第t个时间戳的获取公式
结果，最终的公式如下所示：
第 t 个时间戳的指数移动平均值
我们可以看到，最近的观测值 θ 的权重为 1，倒数第二个观测值 — β，倒数第三个 — β² 等。由于 0 &lt; β &lt; 1，乘法项 βᵏ 随着 k 的增加呈指数下降，因此，观察结果越旧，它们就越不重要。最后，将每个总和项乘以 (1 -β)。
实际上，β 的值通常选择接近 0.9。
不同时间戳的权重分布（β = 0.9）
四、数学解释 利用数学分析中著名的第二奇妙极限，可以证明以下极限：
通过替换 β = 1 - x，我们可以将其重写为以下形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0809169a75986395e483fc50076da6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d720d61c8195343450794f3e251e8b/" rel="bookmark">
			fineBI web组件传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、fineBI web组件传参
1.1、
Web组件- FineBI帮助文档 FineBI帮助文档1. 概述1.1 版本FineBI 版本HTML5移动端展现功能变动6.0--V11.0.83web组件适配移动端效果优化6.0.13-web组件支持传递参数 ${过滤组件https://help.fanruan.com/finebi/doc-view-143.html 1.2、自己做的例子如下图：
2、
3、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd2c5120a85639e983ea1b6b4a1b520/" rel="bookmark">
			Python五种方式实现可视化，包括炫酷的动态图（matplotlib、seaborn、plotly、bokeh、pyecharts）——matplotlib传记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、matplotlib简介 1、介绍 matplotlib是一个功能强大的Python绘图库，用于创建各种类型的图形和可视化数据。它提供了广泛的绘图功能和灵活的配置选项，可以满足不同需求下的数据可视化需求。
2、主要特点 matplotlib的主要特点包括： 简单易用：matplotlib的API设计简单直观，使用起来非常方便。它的语法和Matlab绘图库相似，对于熟悉Matlab的用户来说更容易上手。 多种图形类型：matplotlib支持多种类型的图形，包括折线图、散点图、柱状图、饼图、直方图、箱线图、热力图等。用户可以根据数据类型和需求选择合适的图形类型。 高度可定制：matplotlib提供了丰富的配置选项，用户可以自定义图形的样式、颜色、标签、标题、轴标签等。通过配置选项，可以灵活地调整图形的外观和布局，以满足个性化的需求。 支持多种输出格式：matplotlib可以将图形输出为多种格式，包括图片文件（如PNG、JPEG）、PDF、SVG等。用户可以根据需要选择合适的输出格式，方便地将图形用于报告、文档或网页中。 丰富的扩展库：matplotlib生态系统非常丰富，有许多扩展库可以与之配合使用，如Seaborn、Pandas等。这些扩展库提供了更高级的绘图功能和更方便的数据处理工具，进一步提升了matplotlib的使用体验和效果。 总之，matplotlib是一个功能强大且灵活的Python绘图库，适用于各种数据可视化需求。无论是初学者还是专业人士，都可以通过matplotlib轻松地创建出精美的图形，并更好地理解和分析数据。 3、matplotlib库可以实现多种类型的图形，包括但不限于以下几种： 折线图（Line Plot）：用于显示连续数据的趋势和变化。 散点图（Scatter Plot）：用于显示两个变量之间的关系和分布。 柱状图（Bar Plot）：用于比较不同类别或组之间的数值。 条形图（Barh Plot）：用于水平展示柱状图。 饼图（Pie Chart）：用于显示数据的相对比例和占比。 直方图（Histogram）：用于显示数据的分布情况。 箱线图（Box Plot）：用于显示数据的分散情况和异常值。 热力图（Heatmap）：用于显示数据的矩阵关系。 3D图形（3D Plots）：包括3D散点图、3D曲面图等。 等高线图（Contour Plot）：用于显示二维数据的等高线。 极坐标图（Polar Plot）：用于显示数据在极坐标系下的分布。 简单地理图（Simple Maps）：用于显示地理数据的简单地图。 除了上述常见的图形类型，matplotlib库还提供了许多其他类型的图形，同时也支持自定义图形的样式、颜色、标签等。通过使用matplotlib库，可以根据具体的需求和数据类型选择合适的图形类型，并灵活地进行定制和配置，以实现所需的数据可视化效果。 4、基本属性设置 matplotlib库提供了丰富的属性设置，用于自定义图形的样式和外观。以下是常用的属性设置： 颜色设置： color：设置图形的颜色，可以使用预定义的颜色名称（如'red'、'blue'等），也可以使用RGB值或十六进制颜色码。 edgecolor：设置图形边缘的颜色。 facecolor：设置图形内部的填充颜色。 线型设置： linestyle：设置线条的样式，如实线、虚线等。 linewidth：设置线条的宽度。 标记设置： marker：设置标记的样式，如圆圈、方形等。 markersize：设置标记的大小。 文本设置： fontsize：设置文本的字体大小。 fontweight：设置文本的字体粗细。 fontfamily：设置文本的字体族。 图例设置： legend：设置图例的位置和样式。 label：设置图例的标签。 坐标轴设置： xlabel：设置x轴的标签。 ylabel：设置y轴的标签。 xticks：设置x轴刻度的位置和标签。 yticks：设置y轴刻度的位置和标签。 图形大小和边距设置： figsize：设置图形的大小。 dpi：设置图形的分辨率。 tight_layout：自动调整子图的布局，使其适应图形大小。 以上只是一些常用的属性设置，matplotlib还提供了更多的属性和方法，用于进一步自定义图形的样式和外观。可以通过查阅matplotlib的官方文档来获取更详细的信息。 （1）颜色设置：
在matplotlib中，可以使用RGB值或十六进制颜色码来设置图形的颜色。以下是一些常用的颜色的RGB值和十六进制颜色码： 预定义颜色名称： 'red'：红色 'blue'：蓝色 'green'：绿色 'yellow'：黄色 'orange'：橙色 'purple'：紫色 'brown'：棕色 'gray'：灰色 'black'：黑色 'white'：白色 RGB值： (1, 0, 0)：红色 (0, 0, 1)：蓝色 (0, 1, 0)：绿色 (1, 1, 0)：黄色 (1, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd2c5120a85639e983ea1b6b4a1b520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1677d5ebe3920489d0a4dc73be96a8/" rel="bookmark">
			ARM1.2作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现数码管不同位显示不同的数字
spi.h
#ifndef __SPI_H__ #define __SPI_H__ #include "stm32mp1xx_gpio.h" #include "stm32mp1xx_rcc.h" //MOSI对应的引脚输入高低电平的信号PE14 #define MOSI_OUTPUT_H() do{GPIOE-&gt;ODR |= (0x1 &lt;&lt; 14);}while(0) #define MOSI_OUTPUT_L() do{GPIOE-&gt;ODR &amp;= (~(0x1 &lt;&lt; 14));}while(0) //对应595芯片的锁存引脚输出高低电平 PE11 #define NSS_OUTPUT_H() do{GPIOE-&gt;ODR |= (0x1 &lt;&lt;11);}while(0) #define NSS_OUTPUT_L() do{GPIOE-&gt;ODR &amp;= (~(0x1 &lt;&lt;11));}while(0) //时钟信号对应的引脚输出高低电平 PE12 #define SCK_OUTPUT_H() do{GPIOE-&gt;ODR |= (0x1 &lt;&lt;12);}while(0) #define SCK_OUTPUT_L() do{GPIOE-&gt;ODR &amp;= (~(0x1 &lt;&lt;12));}while(0) //SPI初始化函数，推挽输出，高速，禁止上拉和下拉 void SPI_init(void); //SPI发送数据的函数 void SPI_write(unsigned char dat); void delay_us1(unsigned int us); #endif spi.c
#include "spi.h" void delay_us1(unsigned int us) { int i,j; for(i = 0;i&lt;us;i++) for(j = 0;j&lt;1;j++); } void SPI_init(void) { RCC-&gt;MP_AHB4ENSETR |= (0x1 &lt;&lt; 4); //MOSI PE14 GPIOE-&gt;MODER &amp;= (~(0x3 &lt;&lt;28)); GPIOE-&gt;MODER |= (0x1 &lt;&lt;28); GPIOE-&gt;OTYPER &amp;= (~(0x1 &lt;&lt; 14)); GPIOE-&gt;OSPEEDR &amp;= (~(0X3 &lt;&lt; 28)); GPIOE-&gt;PUPDR &amp;= (~(0X3 &lt;&lt;28)); //MOSI PE13 GPIOE-&gt;MODER &amp;= (~(0x3 &lt;&lt;26)); GPIOE-&gt;OSPEEDR &amp;= (~(0x3 &lt;&lt; 26)); GPIOE-&gt;PUPDR &amp;= (~(0x3 &lt;&lt;26)); //MOSI PE12 GPIOE-&gt;MODER &amp;= (~(0x3 &lt;&lt;24)); GPIOE-&gt;MODER |= (0x1 &lt;&lt;24); GPIOE-&gt;OTYPER &amp;= (~(0x1 &lt;&lt; 12)); GPIOE-&gt;OSPEEDR &amp;= (~(0X3 &lt;&lt; 24)); GPIOE-&gt;PUPDR &amp;= (~(0X3 &lt;&lt;24)); //MOSI PE11 GPIOE-&gt;MODER &amp;= (~(0x3 &lt;&lt;22)); GPIOE-&gt;MODER |= (0x1 &lt;&lt;22); GPIOE-&gt;OTYPER &amp;= (~(0x1 &lt;&lt; 11)); GPIOE-&gt;OSPEEDR &amp;= (~(0X3 &lt;&lt; 22)); GPIOE-&gt;PUPDR &amp;= (~(0X3 &lt;&lt;22)); NSS_OUTPUT_L();//595芯片的锁存引脚拉低 SCK_OUTPUT_L();//SPI的时钟线拉低 } void SPI_write(unsigned char dat) { unsigned char i; for(i = 0;i&lt;8;i++) { if(dat &amp; 0x01) { MOSI_OUTPUT_H();//MOSI线写高 } else { MOSI_OUTPUT_L();//MOSI线写低 } dat &gt;&gt;=1; //时钟线从低电平到高电平的变化时，MOSI数据线上的数据 //被写到595芯片的移位寄存器中 SCK_OUTPUT_L(); delay_us1(10); SCK_OUTPUT_H(); delay_us1(10); } } main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e1677d5ebe3920489d0a4dc73be96a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20215a41d9879150e4fedba80dc7b5b4/" rel="bookmark">
			02 Deep learning algorithm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Neural Networks target：
inference（prediction）training my own modelpractical advice for building machine learning systemdecision Tress application: speech（语音识别） ----&gt; images(计算机视觉)—&gt; text(NLP)
一、Neural Networks 1.神经元和大脑 1） Demand Prediction（需求预测） a) some notion neuron（神经元）：可以将一个简单的模型例如logistic regression 看作一个简单的neuron
layer(层) ： some neuron or single，输入equal or similar feature and out put some data together
activation(激活) ：将 input of neuron called activation
activation function:激活函数是代表能够输出激活值的函数
hidden layer： 知道输入和输出，中间的处理neuron叫做hidden layer
2) 神经网络的网络层 a) definition ​ 输入一组数字向量，经过一系列层的处理，输出另一组数字向量
b) notion: ​ 对于不同的层，w参数的角标也可以标识 通过上标标识
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20215a41d9879150e4fedba80dc7b5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7570c7cfb8bfccc7818fccbff1392efa/" rel="bookmark">
			github短视频去除水印项目Douyin_TikTok_Download_API介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当下正值短视频盛行的时代。在我们浏览短视频的同时，经常能发现一些精美的图片、引人入胜的文案以及吸引眼球的视频，想要将它们保存到本地。然而，保存下来的图片或视频通常伴随着不太愉悦的水印，这显著降低了使用体验。因此，我时常思考是否存在途径能够下载一些无水印的图片。虽然有许多小程序等可以保存无水印的图片或视频，但它们往往伴随着一些令人不悦的广告或付费等。今天，在浏览 GitHub 时偶然发现了一个开源项目，名为“Douyin_TikTok_Download_API”，它能够满足我们的需求。在本文中，我将详细介绍这个项目，并分享如何进行部署和使用。
项目简介 github地址： https://github.com/Evil0ctal/Douyin_TikTok_Download_API
目前该项目在github 已有5.1k star,如下是作者写的项目介绍：
「Douyin_TikTok_Download_API」是一个开箱即用的高性能异步抖音|TikTok|Bilibili数据爬取工具，支持API调用，在线批量解析及下载。
该项目是基于 PyWebIO，FastAPI，AIOHTTP，快速异步的抖音/TikTok/Bilibili数据爬取工具，并通过Web端实现在线批量解析以及下载无水印视频或图集，数据爬取API，iOS快捷指令无水印下载等功能。你可以自己部署或改造本项目实现更多功能，也可以在你的项目中直接调用scraper.py或安装现有的pip包作为解析库轻松爬取数据等…
一些简单的运用场景：
下载禁止下载的视频，进行数据分析，iOS无水印下载（搭配iOS自带的快捷指令APP 配合本项目API实现应用内下载或读取剪贴板下载）等…
项目部署 在 README 中，作者提供了两种部署方式。我们选择了基于 Docker 的部署方法，接下来将详细介绍如何使用 docker-compose 进行部署。
第一步：创建docker-compose.yml 文件 我们在服务器上创建一个部署目录tiktok,在tiktok下创建docker-compose.yml文件，内容如下：
docker-compose.yml
version: "3.7" services: # bot douyin_tiktok_download_api: image: evil0ctal/douyin_tiktok_download_api network_mode: host container_name: douyin_tiktok_download_api restart: always volumes: - ./config.ini:/app/config.ini environment: TZ: Asia/Shanghai deploy: resources: limits: cpus: '0.80' 第二步：创建config.ini 文件 项目的相关配置存储在 config.ini 文件中，因此当需要进行配置更改时，只需编辑 config.ini 文件即可。
在与 docker-compose.yml 同级的目录下创建 config.ini 文件，然后将项目中 config.ini 文件的内容复制到新创建的 config.ini 文件中。
# -*- encoding: utf-8 -*- # @Author: https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7570c7cfb8bfccc7818fccbff1392efa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb00ee6860c8854f510e417212536111/" rel="bookmark">
			非凸非光滑优化的惯性块镜像下降方法（Matlab代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
🎉3 参考文献
🌈4 Matlab代码及文章
💥1 概述 文献来源：
在本文中，我们提出了块坐标下降方法的惯性版本，用于解决非凸非光滑复合优化问题。我们利用Bregman距离函数的一般框架来计算近端映射。我们的方法不仅允许使用两个不同的外推点来评估梯度并添加惯性力，还利用随机选择要更新的变量块。此外，我们的方法不需要重新启动步骤，因此不是一个单调递减的方法。为了证明整个生成序列收敛到临界点，我们修改了Bolte、Sabach和Teboulle的收敛证明方法（非凸非光滑问题的近端交替线性化最小化，数学规划146(1)：459-494，2014），并结合辅助函数。我们使用所提出的方法来解决非负矩阵分解（NMF）问题，并展示它们与最先进的NMF算法竞争优势。
📚2 运行结果 主函数代码：
clear all; close all; clc;
% Options and parameters
options.maxiter =inf;
options.timemax =2;
options.display=0;
% Dimensions of input matrix and rank
m = 200;
n = 200;
r = 20;
% Generation of synthetic data set
Vtrue = rand(r,n);
Utrue = rand(m,r);
X = Utrue*Vtrue;
% Initialization
U0 = rand(m,r);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb00ee6860c8854f510e417212536111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d0f8ae84ac13488d952aa849a822c26/" rel="bookmark">
			120基于matlab的LMS自适应滤波算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的LMS自适应滤波算法，如、解相关LMS算法，滤波型LMS算法，变换域LMS算法，输出滤波前后及学习曲线图。数据可更换自己的，程序已调通，可直接运行。
120自适应滤波算法变换域LMS算法 (xiaohongshu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0199aa2f61517e777d95d8c6c7207181/" rel="bookmark">
			基于物理表面张力-神经网络分类方法实现对教师学校心理社会风险水平的预测研究（Matlab代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
🎉3 参考文献
🌈4 Matlab代码、数据
💥1 概述 基于物理表面张力-神经网络分类方法实现对教师学校心理社会风险水平的预测研究
此方法也可以用在其他领域。
基于物理表面张力-神经网络分类方法的研究旨在预测教师学校的心理社会风险水平。
该方法利用物理表面张力-神经网络分类算法，结合教师学校的相关数据和指标，对心理社会风险进行预测。通过收集和分析与工作环境、工作组织、工作条件和劳动关系等因素相关的数据，建立模型来评估教师学校中存在的心理社会风险。
这项研究的目标是为教师学校提供有针对性的干预和支持，促进教师的健康和福祉，提高工作效能和工作满意度，进而提升教育质量和学生成绩。
通过对工作组织、工作设计、工作条件和劳动关系等方面的数据进行分析和建模，我们可以更准确地预测教师学校的心理社会风险水平。这项研究将使用神经网络分类方法来识别和分析不同因素之间的关联，从而帮助学校管理者更好地了解和管理教师的工作压力。
此外，我们还将探讨如何利用物理表面张力的概念来描述和量化工作相关压力，以便更好地理解和预测教师的心理社会风险水平。这种新的方法有望为学校管理者提供更准确的预测工具，帮助他们及时采取措施来减轻教师的工作压力，保障他们的健康和安全。
通过这项研究，我们希望为教师学校的心理社会风险管理提供新的思路和方法，促进教师的健康和幸福，从而提高教学质量和学校整体的发展水平。这将是一项具有重要意义的研究，有望在教育领域产生积极的影响。
该研究可以帮助学校管理层和决策者识别和评估教师所面临的心理社会风险，从而制定相应的措施和政策来改善工作环境、减轻工作压力，保护教师的心理健康和工作安全。
📚2 运行结果 部分代码：
%la siguiente linea es la semilla guardada de los resultados
RandStream.setGlobalStream(RandStream('mt19937ar','Seed',387));
%si se quiere obtener nuevos resultados diferentes comentar la linea 3
blancoynegro=false;%si se coloca true las graficas salen en blanco y negro
load('../data/basededatos');%se carga la base de datos de Matlab
num=datos(:,1:end-1)';%datos de entrada
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0199aa2f61517e777d95d8c6c7207181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565bbc1fe033057685bf939f706c8a49/" rel="bookmark">
			《Ensemble deep learning: A review》阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题 《Ensemble deep learning: A review》
集成深度学习： 综述
作者 M.A. Ganaie 和 Minghui Hu
来自印度理工学院印多尔分校数学系和南洋理工大学电气与电子工程学院
本文写的大而全。
初读 摘要 集成学习思想：
结合几个单独的模型以获得更好的泛化性能。
目前，深度学习架构与浅层或传统模型相比表现更好。深度集成学习模型结合了深度学习模型和集成学习的优点，使最终模型具有更好的泛化性能。
集成模型大致分类：
袋装法（bagging）提升法（boosting）堆叠法（stacking）基于负相关的深度集成模型（negative correlation based）显式/隐式集成（explicit/implicit）同质/异质集成（homogeneous/heterogeneous）基于决策融合策略的深度集成模型（decision fusion strategies based deep） 本文贡献：
本文回顾了最先进的深度集合模型，从而为研究人员提供了一个广泛的总结。本文还简要讨论了深度集成模型在不同领域的应用。最后，我们总结了这篇文章，并提出了未来的一些研究方向。 结论 这篇文章主要是总结和展望，后面写。
再读 Section 1 Introduction 深度学习（Deep learning）：
深度学习架构已成功应用于从图像、视频分类到医疗保健等广泛领域。这些模型的成功归功于多层处理架构更好的特征表示。
深度学习模型主要用于分类、回归和聚类问题：
**分类（classification）**问题：
分类问题被定义为根据从一组训练数据中学习到的假设 h h h 对新观察结果进行分类。假设 h h h 表示输入数据特征到适当目标标签/类别的映射。学习假设 h h h 的主要目的是尽可能接近真实的未知函数，以减少泛化误差。这些分类算法有多种应用，从医疗诊断到遥感都有。从数学上来看：
O c = h ( x , θ c ) , O c ∈ Z O_c=h(x,\theta_c),\ O_c\in\Z Oc​=h(x,θc​), Oc​∈Z
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565bbc1fe033057685bf939f706c8a49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c830ed022feee6300436dbd32eb89751/" rel="bookmark">
			RobotFrameWork自动化测试框架如何搭建环境？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Robot Framework是一款python编写的功能自动化测试框架。具备良好的可扩展性，支持关键字驱动，可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。主要用于轮次很多的验收测试和验收测试驱动开发（ATDD），支持python，java等编程语言(百度百科)。功欲善其事必先利其器，在学习RF之前同样需要搭建开发环境，包括运行环境的搭建，web自动化测试环境的搭建，所以今天会讲解3种RF测试环境的搭建--RIDE，Pycharm及Eclipse，你可以根据自己的喜好选择使用哪种环境做RF自动化测试
python安装 由于我们主要使用python环境开发RF脚本，因此python的安装是必不可少的，但是今天不过多介绍，网上教程很多，安装过程也很简单
浏览器驱动安装 浏览器及浏览器驱动的安装是做web自动化测试必不可少的部分，当然，这里还是省略配置步骤，网上教程依然很多，提供一个下载Chrome驱动的链接
https://npm.taobao.org/mirrors/chromedriver
RIDE环境配置 安装RIDE RIDE一般是初学者习惯使用的开发RF脚本的一个工具，具有图形化的界面，使用简单，无需手动编写python代码，学习成本比较低，而且安装很简单！
打开CMD，执行 pip3 install robotframework-ride命令即可
安装完RIDE后，我们打开python的安装目录下的Script目录，会发现多了一个ride.py和robot.exe文件
ride.py就是RIDE GUI的启动程序，我们可以双击启动一下看看是否能够打开RIDE的GUI界面，如果打开后出现下面的界面，说明RIDE工具已经安装成功了，是不是很简单？
疑问 1. 有的同学可能会有个疑问，为什么网上找的教程那么复杂，还要安装wxPython，robotframework库？
答：如果使用RIDE工具，以上的依赖库确实需要安装，因为RIDE GUI是wxPython实现的，而使用RF框架又要依赖robotframework库，我这里没有单独安装，是因为在安装robotframework-ride的时候，pip已经给你安装好了这些依赖^-^，不信可以看看前面的截图，如果你再安装过程种没有自动安装依赖环境，那么就手动使用pip命令安装一下这几个库即可
2. 安装完RIDE，但是打不开GUI页面，怎么办？
答：因为执行ride.py需要使用python解释器，设置一下ride.py文件的执行方式为python的解释器即可
安装seleniumlibrary
seleniumlibrary库是基于selenium做的二次封装库，主要针对RF使用的版本，因此需要安装才能使用RF实现web自动化测试
打开CMD执行pip3 install robotframework-seleniumlibrary命令即可
同样，在安装这个库的时候，selenium同样会被自动安装，因为robotframework-seleniumlibrary是基于selenium封装的，针对RF框架实现web自动化测试的依赖库
ok，到目前为止，所有的环境都已经安装完成，我们可以写一个简单的脚本测试一下环境是否存在问题
环境测试 具体脚本如何编写，这里不做介绍，我只写了一个打开浏览器访问百度首页的一条脚本
如果你看到以下输出信息并且浏览器被成功打开那么说明你的环境已经搭建成功，可以学习如何使用RF编写自动化测试脚本了
执行结果 小结 RIDE对于初学者，使用起来还是比较方便的，可以查看关键字的使用，编写脚本可以通过填写表格的方式完成，也可以直接编写代码，但是没有智能提示，也不会自动补全代码，写起来比较累
Pycharm环境配置 作为一个专注于python语言的开发者，最喜欢使用的IDE首选就是pycharm，因为他功能强大，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发，那么长时间以来，你可能会形成一种依赖，不管做什么开发都希望使用pycharm，因为你已经足够了解它并且爱上它，那么做RF自动化能不能使用pycharm讷？当然，这么强大的工具干啥不行讷？接下来我们就讲解以下如何使用pycharm搭建RF的web自动化测试环境
使用pycharm配置RF做web自动化测试之前，同样需要安装selenium，robotframework，robotframework-seleniumlibrary，浏览器及浏览器驱动，不需要robotframework-ride，你可以按照以下方式安装
pip3 install selenium
pip3 install robotframework
pip3 installl robotframework-seleniumlibrary
由于我上面在配置RIDE的时候已经安装过了，所以接下来就不需要再安装这个几个库了
pycharm安装 安装步骤这里也不再赘述，百度一堆一堆，破解方法也一堆一堆
安装intelliBot插件 这个插件主要为了Pycharm能够识别RF脚本及编写执行RF脚本
打开Pycharm-点击右上角【File】-选择【Setting】-点击【Plugins】
搜索框输入intelliBot，点击上图中的Install，等待安装完成
注意：安装完插件之后需要重启pycharm
配置RF的文件类型识别 同样打开【Setting】-选择【Editor】-点击【File Types】-在右侧文件列表中找到【Robot Feature】，并添加RF脚本所有的文件类型
配置完保存即可
Suite和Case的运行配置 因为RF框架编写的测试脚本是无法使用python解释器运行的，它有自己的执行脚本程序robot.exe，这个程序再执行pip3 install robotframework 时自动安装，存在于python安装目录的script目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c830ed022feee6300436dbd32eb89751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf7d5a8ede7dfe4974a637352bb03ae/" rel="bookmark">
			软件测试/测试开发丨Python 模块与包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 模块与包 python 模块 项目目录结构 组成 package包module模块function方法 模块定义 定义 包含python定义和语句的文件.py文件作为脚本运行 导入模块 import 模块名from &lt;模块名&gt; import &lt;方法 | 变量 | 类&gt;from &lt;模块名&gt; import * 注意：同一个模块写多次，只被导入一次import 应该放在代码的顶端 模块的分类 系统内置模块第三方的开源模块自定义模块 文件引用 系统内置模块
** python安装好之后自带的一些非常有用的模块（sys，os，time，json模块等）第三方开源模块
** 是通过包管理工具pip完成的自定义模块
** 自定义模块是自己写的模块，对某段逻辑或某些函数进行封装后供其他函数调用 # 系统内置模块 import sys import os import re # 正则 import json # json文件处理 import time # 时间 print(sys.path) # 第三方模块 import yaml # 命令行可以命令安装 pip install pyyaml import requests # 命令行可以命令安装 pip install requests # 自定义模块 from test import * print(dir()) 模块引用的总结 代码的可维护性提升编码效率函数名可重复（起名避免与系统重复） 最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf7d5a8ede7dfe4974a637352bb03ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae6b9277d9fc01078c182cfe8fd4e5c/" rel="bookmark">
			软件测试/测试开发丨Selenium 高级定位 Xpath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、xpath 基本概念 XPATH是一门在XML文档中查找信息的语言
XPATH使用路径表达式在XML文档中进行导航
XPATH的应用非常广泛，可以用于UI自动化测试
二、xpath 使用场景 自动化测试app自动化测试 2.1、XPATH相对定位的优点 # 复制的绝对定位 $x('//*[@id="ember75"]/td[1]/span/a') # 编写的相对行为 $x("//*[text()='技术分享 | SeleniumIDE用例录制']") 2.2、xpath 定位的调试方法 浏览器-console
$x("xpath表达式") 浏览器-elements
ctrl+f 输入xpath或者css 三、xpath 语法与实战 3.1、xpath 基础语法（包含关系） 表达式结果示例/从该节点的子元素选取$x(‘/’)//从该节点的子孙元素选取$x(‘//’)*通配符$x(‘///*’)nodename选取此节点的所有子节点…选取当前节点的父节点@选取属性 # 整个页面 $x("/") # 页面中的所有的子元素 $x("/*") # 整个页面中的所有元素 $x("//*") # 查找页面上面所有的div标签节点 $x("//div") # 查找class属性为site-logo的节点 $x('//*[@class="site-logo"]') # 查找节点的父节点 $x('//*[@class="site-logo"]/..') 3.2、xpath 顺序关系（索引） xpath通过索引直接获取对应元素 xpath 高级用法 [last()]：选取最后一个
[表达式1 and 表达式2]：与关系
$x(‘//*[@class=“container” and @id=“main-container”]’) [表达式1 or 表达式2]：或关系
$x(‘//*[@data-topic-id="7306"or@id=“ember476”]’) [text()=“文本内容”]：根据文本内容定位
[contains(方法,“匹配的内容”]：根据文本内容包含定位
第一个参数匹配方法，如：text()，@id，@class等，第二参数匹配的内容 最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33cf7dba71d47841d78e4d57a58c0844/" rel="bookmark">
			如何删除K8S中的Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 1. 查看pod信息2. 删除命令（未设置副本）3. 删除命令（设置了副本） 1. 查看pod信息 kubectl get pod -n 命名空间名称 2. 删除命令（未设置副本） kubectl delete pod podname -n 命名空间名称 3. 删除命令（设置了副本） 如果deployment中设置了副本，上面命令删除后会自动创建新的pod
此时想要彻底删除，需要删除deployment部署，命令如下
kubectl delete deployment name -n 命名空间名称 其中name是deployment文件中的name参数对应的值
感谢阅读，祝君暴富！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86bb7d4fb777e0a583f6b1c2c2f9406/" rel="bookmark">
			软件测试/测试开发丨Pytest结合数据驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装yaml pip install pyyaml pytest结合数据驱动yaml 工程目录结构 数据准备 读取excel文件 openpyxl库的安装 openpyxl库的操作 pytest结合csv实现数据驱动 csv文件介绍 pytest结合json实现数据驱动 最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5679554ca62fa6bad6793f700657dd97/" rel="bookmark">
			软件测试/测试开发丨Python 错误与异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 错误与异常 语法错误与定位 错误 语法错误逻辑错误系统错误 # 错误 # 语法错误 num = 1 if num &gt; 1 # 缺少冒号 print("num&gt;1") # 结构是： SyntaxError: expected ':' line 4第四行 # 逻辑错误 if num &gt;=1: print("num&lt;=1") # 实现结果与实际场景逻辑不对 elif num&gt;100: print("num&lt;100") # 实现结果与实际场景逻辑不对 # 系统错误 # 如运行是内存泄露、系统错误等引起的运行失败 异常 程序执行过程中出现的未知错误语法和逻辑都是正常的程序业务逻辑不完善引起的程序漏洞–bug 错误与异常的区别 异常可以被捕获和处理错误一般是编码错误、逻辑错误、系统错误 常见的异常类型 异常类型：docs.python.org/3/library/e…常见的异常类型
** 除零类型、名称异常、索引异常、键异常、值异常、属性异常等 # 除零异常 def div(a,b): return a/b print(div(1, 0)) # 异常是：ZeroDivisionError: division by zero # 名称异常 # num =1 if numb &gt;1: num =2 # 异常是：NameError: name 'numb' is not defined.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5679554ca62fa6bad6793f700657dd97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35fde871d721b9c4c929e286cbfd491/" rel="bookmark">
			opencv期末练习题（6）附带解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滑动块调整图像灰度 import cv2 import numpy as np """ 滑动块调整图像灰度 1. 读取图片，并转为灰度图 2. 定义启动滑块和阈值滑块 3. 只有启动滑块的值为1时，拖动阈值滑块才生效 4. 根据阈值滑块的值实时对图像进行二值化操作 """ enable = False img = cv2.imread("./img.png", 0) # 读取灰度化后的图像，0代表读入灰度图。 def nothing(x): # 滑动条修改后会触发这个事件，我们这个程序不需要所以置空 pass # pass代表啥也不干 def enableButton(x): # 启动滑块触发事件 global enable # 表明引用的事全局变量enable enable = bool(x) # 根据当前滑块的值设置当前的启动状态 cv2.namedWindow("image") # 创建调色板滑动条 cv2.createTrackbar('Enable', 'image', 0, 1, enableButton) # 创建是否启用滑块，返回为0-1之间 cv2.createTrackbar('thresh', 'image', 0, 255, nothing) # 创建阈值滑块，范围在0-255之间 new_img = img.copy() # 拷贝一个新图像 while 1: cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a35fde871d721b9c4c929e286cbfd491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739aa697047a5b5a623b0aa460b6789f/" rel="bookmark">
			electron使用webview出现空白页面解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用webview标签的时候，出现了空白页面的情况，刚开始以为没有生效，后来发现页面上是有这个标签的，但是没有展示出内容，后来看了官网，默认情况下，webview标签在 Electron &gt;= 5 中被禁用。
&lt;webview id="foo" src="https://www.baidu.com/" style="display:inline-flex; width:840px; height:980px"&gt;&lt;/webview&gt; 如果需要使用，需要单独配置：在BrowserWindow 中单独配置开启
const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { webviewTag: true, preload: path.join(__dirname, 'preload.js') } }) 开启之后，就会显示出来了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b70c494fdab40ef300d12f75b69206d/" rel="bookmark">
			vfb控件数组的实现原理(visual freebasic ide),64位VB6 vb7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vfb控件数组的实现原理(visual freebasic ide),64位VB6 vb7
Sub Form1_Command1_BN_Clicked(ControlIndex As Long, hWndForm As hWnd, hWndControl As hWnd) MsgBox ("Command1 ControlIndex=" &amp; ControlIndex &amp; ",Command1(x).Caption =" &amp; Command1( ControlIndex).Caption &amp; ",hWnd=" &amp; Command1( ControlIndex).hWnd) End Sub IDE下载VisualFreeBasic(软件介绍) http://wwx.yfvb.com/soft-48.htm
Case WM_COMMAND
Dim As Long IDC =LoWord(wParam) ,CODE = HiWord(wParam)
为什么可以从wParam取出IDC和CODE=BN_CLICKED消息
在Windows消息处理过程中，wParam参数是一个32位的值，其中包含了消息的附加信息。对于WM_COMMAND消息，wParam的低16位（LoWord）存储了控件的标识符（IDC），高16位（HiWord）存储了控件发送的消息代码（CODE）。
在BN_CLICKED消息中，wParam的低16位存储了按钮控件的标识符（IDC），高16位存储了按钮控件发送的消息代码（CODE）。因此，通过使用LoWord和HiWord函数，可以从wParam中提取出IDC和CODE的值。
LoWord函数用于提取wParam的低16位，返回一个无符号整数（WORD）值。HiWord函数用于提取wParam的高16位，返回一个有符号整数（SHORT）值。
所以，通过使用LoWord(wParam)和HiWord(wParam)可以从wParam中取出IDC和CODE的值。
==============================================
如果是多个窗口，也有不同的IDC区分吗？还是按照句柄？
在多个窗口的情况下，每个窗口都有自己的句柄（handle），用于唯一标识该窗口。句柄是一个整数值，可以通过调用CreateWindow或CreateWindowEx函数来创建窗口时获得。
在WM_COMMAND消息中，wParam参数的低16位（LoWord）存储了控件的标识符（IDC），用于区分不同的控件。这个标识符是在创建控件时通过指定ID参数来设置的，可以是一个整数值或者是一个预定义的常量。
因此，通过wParam的低16位的IDC值，可以区分不同的控件。而句柄则用于区分不同的窗口。在处理WM_COMMAND消息时，可以根据wParam的IDC值和句柄来确定是哪个窗口的哪个控件发送了该消息，从而进行相应的处理。========================================
Type Form1_Class_Form Extends Class_Form Command3(3) As Class_Button Command1(2) As Class_Button Declare Function Show(hWndParent*** end type 创建控件数组，绑定到同一个事件过程。 This.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b70c494fdab40ef300d12f75b69206d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655fef7d9105285e8de999c10e7ae156/" rel="bookmark">
			数据结构OJ实验15-插入排序与交换排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. DS内排—直插排序 题目描述 给定一组数据，使用直插排序完成数据的升序排序。
--程序要求-- 若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio 程序中若include多过一个头文件，不看代码，作0分处理 不允许使用第三方对象或函数实现本题的要求 输入 数据个数n，n个数据
输出 直插排序的每一趟排序结果
样例查看模式 正常显示查看格式
输入样例1 7 34 23 677 2 1 453 3
输出样例1 23 34 677 2 1 453 3\n
23 34 677 2 1 453 3\n
2 23 34 677 1 453 3\n
1 2 23 34 677 453 3\n
1 2 23 34 453 677 3\n
1 2 3 23 34 453 677\n
AC代码 #include&lt;iostream&gt; using namespace std; const int N = 1e5; int a[N]; int n; void insert_sort() { for (int i = 1; i &lt; n; i++) { int t = a[i]; int j; for (j = i - 1; j &gt;= 0; j--) { if (a[j] &gt; t) { a[j + 1] = a[j]; } else break; } a[j+1] = t; for (j = 0; j &lt; n; j++) { cout &lt;&lt; a[j]; if (j !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/655fef7d9105285e8de999c10e7ae156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10033f8cfefe4169fa3292cf693e1868/" rel="bookmark">
			单片机原理及应用：计数按键控制数码管显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		承接上文，我们来介绍一下按键和数码管的配合工作，由于数码管显示的字符和位数多种多样，无法做到一个字符对应一个按键，所以程序主要记录按键的使用次数来切换数码管的显示。
#include &lt;reg52.h&gt; //包含reg52.h头文件 unsigned char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f};//共阴极接法 unsigned char Count; //定义变量放置计数数值 sbit KEY=P1^0;	//定义KEY为接在P1.0上的按键 sbit KEY1=P1^1; void delay10ms(void) //定义10ms延时函数 { unsigned char i,j; for(i=20;i&gt;0;i--) for(j=248;j&gt;0;j--); } void main(void) { //初始步骤，用于控制上电之后所显示的数字，共三步，数据 Count=0; //计数变量初始为0 P0=table[Count/10]; //十位数码管显示0 P2=table[Count%10]; //个位数码管显示0 while(1) //按键扫描，计数显示处理 { if(KEY==0) //双if嵌套去抖动 { delay10ms(); //延时 if(KEY==0) { Count++; //计数加1 if(Count==100) { Count=0; //计数清零 } P0=table[Count/10]; //显示十位数 P2=table[Count%10]; //显示个位数 while(KEY==0); //防止不松手等键释放 } } //再加一个按键KEY1，按下后会减一 //由于count在-1时重新赋值99.所以count得是有符号的char类型 if(KEY1==0) { delay10ms(); if(KEY1==0) { Count--; if(Count==-1) { Count=99; } P0=table[Count/10]; P2=table[Count%10]; while(KEY1==0); } } /* //加一个KEY2，按下后会清零 if(KEY2==0) { delay10ms(); if(KEY2==0) { P0=table[0]; P2=table[0]; while(KEY2==0); } } */ } } 键盘去抖的方式有很多，不过for循环嵌套应该是最简单的。这类计数装置需要考虑按键释放，要在if内层的最后一行写一个while（1） 。仿真电路如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10033f8cfefe4169fa3292cf693e1868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a3e4f5192e95b39630cea843c5c585/" rel="bookmark">
			利用Spring Cloud和Java系统设置优化工程项目管理系统源码的二次开发体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程项目管理涉及众多环节和角色，如何实现高效协同和信息共享是关键。本文将介绍一个采用先进技术框架的Java版工程项目管理系统，该系统支持前后端分离，功能全面，可满足不同角色的需求。从项目进度图表到施工地图，再到系统管理和统计报表，该系统为工程项目管理带来了诸多便利。
工程项目各模块及其功能点清单
一、系统管理
1、数据字典：实现对数据字典标签的增删改查操作
2、编码管理：实现对系统编码的增删改查操作
3、用户管理：管理和查看用户角色
4、菜单管理：实现对系统菜单的增删改查操作
5、角色管理：管理和查看用户角色的权限
6、系统消息：查看系统消息
二、系统设置
1、项目前期模板设置：实现对项目前期模板文档的增删改查操作
2、项目权限管理：管理各项目的成员名单
3、资源管理：实现对资源清单的增删改查操作
4、考核指标：实现对考核指标的增删改查操作
5、预警指标：实现对预警指标的增删改查操作
6、模板管理：实现对模板的增删改查操作
7、提醒消息模板：实现对提醒消息模板的增删改查操作
三、项目管理
1、项目列表：实现对项目列表的增删改查操作，包括查看各项目的立项人、创建时间、
项目经理、计划开始时间、计划结束时间等信息，可以进行终止和导出操作
2、项目计划管理：项目计划查看和管理模块，可执行增删改查操作，包括查看甘特图
3、进度上报管理：项目进度上报模块，可上报任务或任务步骤进度
4、形象进度：形象进度管理
5、指引：项目指引详情
四、合同管理
1、项目合同：项目合同详情查询和展示页面
2、问题合同：问题合同详情查询和展示页面
3、合同收付款：合同收付款详情查询和展示页面
4、资金计划：实现各项目资金计划的详情查看及其增删改和导出操作
5、项目考核：项目考核详情查看页面
6、奖惩管理：奖惩查看管理页面
五、预警管理
1、预警管理：预警管理和信息查看页面，可以执行设置预警指标操作
2、预警记录：预警记录管理
六、竣工管理
1、工程竣工移交：工程竣工移交管理
2、工程竣工验收：工程竣工验收管理
七、质量管理
1、中间验收：中间验收记录管理
2、质量检查：质量检查记录管理
3、隐患整改：隐患整改记录管理
八、统计报表
1、项目汇总：项目汇总信息查看，包括进度、计划时间等信息
2、进度报表：项目进度报表，包括计划时间和已用资源等信息
3、收支报表：项目收支报表，包含总体收支、项目收支和收支统计模块
4、资金计划报表：资金计划详情展示
5、资金计划统计：资金计划统计模块，提供信息导出功能
6、差异报表：项目差异报表，进入详情界面可执行基线对比
7、每周报表：项目每周报表
九、工作台
1、我的待办：我的待办和已办工作
2、我的消息：我的消息清单，包含未读信息和已读信息
前端架构：VUE、Uniapp、Layui、Bootstrap、H5、CSS3
涉及技术：Eureka、Config、Zuul、OAuth2、Security、OSS、Turbine、Zipkin、Feign、Monitor、Stream、ElasticSearch等 该工程项目管理系统采用先进的技术框架和设计模式，构建了一个功能强大的工程项目管理系统。该系统涵盖了多个方面，包括项目管理、合同管理、预警管理、竣工管理、质量管理等，通过数据字典、编码管理、用户管理、菜单管理等功能实现了系统的全面管理和设置。同时，系统还提供了丰富的统计报表和差异报表，方便用户进行数据分析和决策。该系统的建立将有助于提高工程管理效率、减轻劳动强度、提高信息处理速度和准确性，为企业数字化转型和提升竞争力提供了有力支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc2a470ba11b8c418f1bd0d17bb199e/" rel="bookmark">
			AIGC年度回顾！2024向量数据库是否还是AI发展方向之一？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 2023 年，是 AI 技术大爆发的一年，从年初到年末，全球关心技术发展的人们见证了一次次的 AI 技术升级，也逐步加深着对 AGI 发展的畅想。而伴随着生成式人工智能的飞速发展，向量数据库以其独特的技术优势逐渐崭露头角。它通过将数据转化为高度精炼的向量，使得这些向量能够精确地代表特征或类别。
其实，向量数据库并非最近两年才兴起的新生事物，而是随着生成式 AI 的飞速前进而崛起并受到关注。11 月 15 日，腾讯也联合信通院发布了业内首个向量数据库标准。向量数据库，似乎正在成为 AI 发展中不可或缺的一环。但同时，也有一部分人坚持向量数据库是伪需求，随着生成式人工智能的发展，尤其是 GPTs 的出现，未来将不再需要向量数据库。
那么，为什么向量数据库能借由大模型引起众多关注？与传统数据库相比又有着怎样的差异？向量数据库的发展会否取代传统数据库而占据主导地位？它到底是时代的昙花一现，还是未来 AI 时代的航道灯塔？
大咖共话AI发展未来 本期 TVP 技术夜未眠，特邀 Boolan 首席技术专家、全球机器学习技术大会主席、腾讯云 TVP 李建忠 &amp; 腾讯云向量数据库产品负责人 邹鹏与腾讯云产品四部总经理 田超展开对谈。12 月 28 日（周四） 19:30-21:00，锁定 TVP 视频号，AGI 元年总结，未来 AI 与向量数据库发展路径，三位专家将为你带来最详尽的解读 扫描海报二维码或点击链接即可预约直播~
点击视频号立即预约直播~
对话嘉宾介绍： 李建忠 Boolan 首席技术专家、全球机器学习技术大会主席、腾讯云 TVP
Boolan ⾸席技术专家，全球机器学习技术⼤会主席。对软件架构、产品创新、人工智能有丰富经验和深入研究。近年来主要研究以⼤语⾔模型为主的⼈⼯智能⽅法在软件领域的应用，相关研究和演讲引起业界强烈关注。曾于 2005 年-2010 年期间担任微软最有价值技术专家，区域技术总监。拥有近⼆⼗年软件技术架构与产品经验，主讲多门技术课程，为包括众多世界 500 强公司在内的知名品牌提供⾼端 IT 技术咨询，影响近百万软件开发⼈员。
邹鹏 腾讯云向量数据库产品负责人
腾讯云向量数据库产品负责人，拥有多年数据库、网络安全研发经验。在网络、计算、存储、安全等领域，及 Redis、MySQL 等数据库的高可用、高可靠和中间件方面有深入的研究和丰富的产品化及实践经验。
田超 腾讯云产品四部总经理
腾讯云产品四部总经理，负责腾讯云用户增长及客户经营相关产品。同时也是资深用户增长专家、大数据技术专家，曾任应用宝增长平台总经理，摩拜单车技术副总裁，长期致力于企业数字化相关研究。
TVP技术夜未眠 TVP 技术夜未眠 —— 技术畅言，夜深不眠。聚焦最新、最热、最受关注的技术话题，邀请各领域资深专家对话 TVP 大咖，深度剖析技术原理，洞察互联网技术走向，碰撞出思维火花，照亮技术之夜。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4c0fbabf0bb1ba1c0ffb67ce7648df/" rel="bookmark">
			白话机器学习的数学-3-评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 模型评估 那我们如何测量预测函数 fθ(x)的正确性，也就是精度呢？ 观察函数的图形，看它能否很好地拟合训练数据： 这是只有一个变量的简单问题，所以才能在图上展 示出来。 过像多重回归这样的问题，变量增加后就不能在图上展示了。 所以我们需要能够定量地表示机器学习模型的精度。 2、 交叉验证 回归问题的验证 把获取的全部训练数据分成两份：一份用于测试，一份用于训练，然后用前者来评估模型。 如果变量增加，就不能画图了，就算能画图，也会很麻烦。 对于回归的情况，只要在训练好的模型上计算测试数据的误差的平方，再取其平均值就可以了。假设测试数据有 n 个，那么可以 这样计算： 这个值被称为均方误差或者 MSE，全称 Mean Square Error。 这个误差越小，精度就越高，模型也就越好。 分类问题的验证 由于回归是连续值，所以可以从误差入手， 但是在分类中我们必须要考虑分类的类别是否正确。 我们是根据图像为横向的概率来分类的， 关于分类是否成功就会有下面 4 种情况： 设横向的情况为正、非横向的情况为负，那么一般来 说，二分类的结果可以用这张表来表示： 分类结果为正的情况是 Positive、为负的情况是 Negative。分类 成功为 True、分类失败为 False。 我们可以使用表里的 4 个记号来计算分类的精度。精 度的英文是 Accuracy，它的计算表达式是这样的： 它表示的是在整个数据集中，被正确分类的数据 TP 和 TN 所占 的比例。 假如 100 个数据中 80 个被正确地分类了，那么精度就是这样： 精确率和召回率 一般来说，只要计算出这个 Accuracy 值，基本上就可以掌握分类 结果整体的精度了。 但是有时候只看这个结果会有问题，所以还 有别的指标。 假设图中的圆点是 Positive 数据、叉号是 Negative 数据，我们来考虑一下数据量极其不平衡的情况： 假设有 100 个数据，其中 95 个是 Negative。那么，哪怕出现模型把数据全部分类为 Negative 的极端情况，Accuracy 值也为 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c4c0fbabf0bb1ba1c0ffb67ce7648df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0af3f286cc112e1e27a632638e05a22/" rel="bookmark">
			【MySQL】数据库之主从复制和读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是读写分离？
二、为甚要读写分离？
三、什么时候需要读写分离？
四、主从复制与读写分离
五、MySQL支持的二进制日志格式
六、主从复制的工作原理
七、MySQL读写分离的原理
八、MySQL读写分离的方式有哪些
九、实验一：实操主从复制
步骤一：完成所有服务器的时间同步
步骤二：完成主服务器的配置
步骤三：完成从服务器的配置
步骤四：测试
十、实验二：实操主从复制之半同步复制
十一、实验三：实操基于amoeba的读写分离
步骤一：先完成三台mysql服务器的账号和用户设置，并进行授权
步骤二：jdk配置和amoeba安装和配置
​编辑 测试 读写分离测试
一、什么是读写分离？ 读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。
二、为甚要读写分离？ 因为数据库的“写”（写10000条数据可能要3分钟）操作是比较耗时的。
但是数据库的“读”（读10000条数据可能只要5秒钟）。
所以读写分离，解决的是，数据库的写入，影响了查询的效率。
三、什么时候需要读写分离？ 数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用。利用数据库主从同步，再通过读写分离可以分担数据库压力，提高性能。
四、主从复制与读写分离 在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。有点类似于rsync，但是不同的是rsync是对磁盘文件做备份，而mysql主从复制是对数据库中的数据、语句做备份。
五、MySQL支持的二进制日志格式 （1）STATEMENT：基于语句的复制。在服务器上执行sql语句，在从服务器上执行同样的语句，mysql默认采用基于语句的复制，执行效率高。
（2）ROW：基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。
（3）MIXED：混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。
六、主从复制的工作原理 两个日志（主：binlog二进制日志，从：relay-log中继日志）
三个线程（主：dump线程，从：IO线程和SQL线程）
（1）Master节点将数据的改变记录成二进制日志（bin log），当Master上的数据发生改变时，则将其改变写入二进制日志中。
（2）Slave节点会在一定时间间隔内对Master的二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O线程请求 Master的二进制事件。
（3）同时Master节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至Slave节点本地的中继日志（Relay log）中，Slave节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，即解析成 sql 语句逐一执行，使得其数据和 Master节点的保持一致，最后I/O线程和SQL线程将进入睡眠状态，等待下一次被唤醒。
注：
●中继日志通常会位于 OS 缓存中，所以中继日志的开销很小。
●复制过程有一个很重要的限制，即复制在 Slave上是串行化的，也就是说 Master上的并行更新操作不能在 Slave上并行操作。
七、MySQL读写分离的原理 读写分离就是只在主服务器上写，只在从服务器上读。基本的原理是让主数据库处理事务性操作，而从数据库处理 select 查询。数据库复制被用来把主数据库上事务性操作导致的变更同步到集群中的从数据库。
八、MySQL读写分离的方式有哪些 1）基于程序代码内部实现
在代码中根据 select、insert 进行路由分类，这类方法也是目前生产环境应用最广泛的。
优点是性能较好，因为在程序代码中实现，不需要增加额外的设备为硬件开支；缺点是需要开发人员来实现，运维人员无从下手。
但是并不是所有的应用都适合在程序代码中实现读写分离，像一些大型复杂的Java应用，如果在程序代码中实现读写分离对代码改动就较大。
2）基于中间代理层实现
代理一般位于客户端和服务器之间，代理服务器接到客户端请求后通过判断后转发到后端数据库，有以下代表性程序。
（1）MySQL-Proxy。MySQL-Proxy 为 MySQL 开源项目，通过其自带的 lua 脚本进行SQL 判断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0af3f286cc112e1e27a632638e05a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229c7a6546ce2393a1e5454df3c06e39/" rel="bookmark">
			Flink-【时间语义、窗口、水位线】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 时间语义 1.1 事件时间：数据产生的事件（机器时间）； 1.2 处理时间：数据处理的时间（系统时间）。 🌰：可乐
可乐的生产日期 = 事件时间（可乐产生的时间）；
可乐被喝的时间 = 处理时间（可乐被处理【喝掉=处理】的时间）。
机器时间：可能不准确（例如：A可乐厂的时钟比较慢，B可乐厂的时钟比较快，但实际上B产生可乐的时间比A产生可乐的时间慢，却被先处理了）
系统时间：相对准确（处理机器设置的时间，一般无误【当然分布式可能会有误差，但是一般会先校准同一个时钟再处理数据】）
2. 窗口 2.1 滑动窗口：设置窗口大小，步长大小； 🌰：窗口大小5，步长2
2.2 滚动窗口：一般设置窗口大小即可； 🌰：窗口大小5
2.3 会话窗口：设置会话窗口大小； 2.4 计数窗口：设置窗口处理数据的数目。 3. 水位线 水位线是Flink窗口处理数据的临界线；一般为了处理延迟数据，还会搭配一个容忍时间。
例如：使用滚动窗口，水位线为5，容忍时间为2，处理如下。
滚动窗口有两个，分别是【1，5）和【5，10）
处理时间有7个，分别是：1，2，7，3，6，5，20
1，2处理时间事件到达后，交给【1，5）窗口处理；
7处理时间事件到达后，由于7-2=5大于【1，5）这个窗口了（处理时间 - 容忍时间），所以关闭【1，5）窗口，进行计算...（就好比上课，有些同学没到，老师说晚2分钟再开始上课，7这个处理时间已经是在2分钟后了，所以开始讲课，不等了），7归类到【5，10）窗口进行计算；
3处理时间时间到达后，由于他是在【1，5）窗口的，但是该窗口已经关闭计算了，所以此时的3处理时间事件只能丢弃；
后面6，5，20处理时间事件分析同上...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32df1ebad4c18b24ff9e8184f1ee40da/" rel="bookmark">
			ASP.NET Core基础之图片文件(一)-WebApi访问静态图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获： 学会在WebApi项目中访问静态图片了解静态文件中间件UseStaticFiles的用法 系统中免不了要去处理图片文件，比如上传商品的图片、显示商品的图片，访问系统中的图片等等，根据微软官网描述：
静态文件（如 HTML、CSS、图像和 JavaScript）是 ASP.NET Core 应用直接提供给客户端的资产。
那么怎么才能访问系统中的静态文件呢？本次，通过以下案例来演示在ASP.NET Core WebApi中如何访问静态图片。
开发环境：
操作系统： Windows 10 专业版
平台版本是：.NET 6
开发框架：ASP.NET Core WebApi
开发工具：Visual Studio 2022
一、显示wwwroot下的静态图片文件 静态文件存储在项目的 Web 根目录中。 默认的Web根目录路径为 "内容根目录/wwwroot"，其中的"内容根目录"需要知道一下—— 在开发中，内容根目录默认为项目的根目录，它是应用内容文件(如生成的exe、dll文件，json配置文件等)和 Web 根目录的基路径。按照以下步骤：
项目中创建wwwroot文件夹
ASP.NET Core WebApi项目中默认没有wwwroot文件夹，项目上右键菜单依次单击“添加”-“新建文件夹”来创建一个wwwroot文件夹，接着在此文件夹下面创建images文件夹，并添加 wwwroot/images/eagle.jpg 文件
在Program.cs中配置 静态文件中间件UseStaticFiles
//服务注册代码略... // 配置HTTP请求管道 （Middleware 中间件：处理请求和响应的一些组件） var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } //配置静态文件中间件 app.UseStaticFiles(); app.UseHttpsRedirection(); app.UseCors(); app.UseAuthorization(); app.MapControllers(); app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32df1ebad4c18b24ff9e8184f1ee40da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ba63fa19e6df11355547e688609984/" rel="bookmark">
			mysql查询表里的重复数据方法：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
2
3
4
INSERT INTO hk_test(username, passwd) VALUES
('qmf1', 'qmf1'),('qmf2', 'qmf11')
delete from hk_test where username='qmf1' and passwd='qmf1'
MySQL里查询表里的重复数据记录：
先查看重复的原始数据：
场景一：列出username字段有重读的数据
1
2
3
select username,count(*) as count from hk_test group by username having count&gt;1;
SELECT username,count(username) as count FROM hk_test GROUP BY username HAVING count(username) &gt;1 ORDER BY count DESC;
这种方法只是统计了该字段重复对应的具体的个数
场景二：列出username字段重复记录的具体指：
1
2
3
4
5
select * from hk_test where username in (select username from hk_test group by username having count(username) &gt; 1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ba63fa19e6df11355547e688609984/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba919fcde36a3dfd8c019396aadaade9/" rel="bookmark">
			MySQL|如何查询重复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL|如何查询重复数据？
Q1：如何查询重复的单个字段？
A1:
SELECT 重复字段A,count(*)
FROM table
GROUP BY 重复字段A
Having count(*)&gt;1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f8e027ef6f2cb8895aa5a87ef94f0e/" rel="bookmark">
			一套完整的渗透测试流程，值得阅读分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、授权
首先客户需要先授权委托，并同意实施方案是进行渗透测试的必要条件。渗透测试首先必须将实施方法、实施时间、实施人员，实施工具等具体的实施方案提交给客户，并得到客户的相应书面委
托和授权。应该做到客户对渗透测试所有细节和风险的知晓、所有过程都在客户的控制下进行。
二、信息收集
信息收集是每一步渗透攻击的前提，通过信息收集可以有针对性地制定模拟攻击测试计划，提高模拟攻击的成功率，同时可以有效的降低攻击测试对系统正常运行造成的不利影响。信息收集的方法包括 Ping Sweep、DNS Sweep、DNS zone transfer、操作系统指纹判别、应用判别、账号扫描、配置判别等。信息收集常用的工具包括商业网络安全漏洞扫描软件，免费安全检测工具（例如：NMAP、NESSUS 等）。操作系统内置的许多功能（例如：TELNET、NSLOOKUP、IE 等）也可以作为信息收集的有效工具。
三，内部计划制定、二次确认
根据客户设备范围和项目时间计划，并结合前一步初步的信息收集得到的设备存活情况、网络拓扑情况以及扫描得到的服务开放情况、漏洞情况制定内部的详细实施计划。
具体包括每个地址下一步可能采用的测试手段，详细时间安排。并将以下一步工作的计划和时间安排与客户进行确认。
四、取得权限、提升权限
通过初步的信息收集分析，存在两种可能性，一种是目标系统存在重大的安全弱点，测试可以直接控制目标系统；另一种是目标系统没有远程重大的安全弱点，但是可以获得普通用户权限，这时可以通过该普通用户权限进一步收集目标系统信息。接下来尽最大努力取得超级用户权限、收集目标主机资料信息，寻求本地权限提升的机会。这样不停的进行信息收集分析、权限提升的结果形成了整个的渗透测试过程。
五、渗透测试采用的技术手段
信息的收集和分析伴随着每一个渗透测试步骤，每一个步骤又有三个组成部分：操作、响应和结果分析。
1、网络信息搜集
使用 PING Sweep、DNS Sweep、SNMP Sweep、Tracert 等手段对主机存活情况、DNS 名称、网络链路等进行信息收集。可以对目标的网络情况、拓扑情况、应用情况有一个大致的了解，为更深层次的渗透测试提供资料。
2、端口扫描
通过对目标地址的 TCP/UDP 端口扫描，确定其所开放的服务的数量和类型，这是所有渗透测试的基础。通过端口扫描，可以基本确定一个系统的基本信息，结合安全工程师的经验可以确定其可能存在以及被利用的安全弱点，为进行深层次的渗透提供依据。
3、远程溢出
这是当前出现的频率最高、威胁最严重，同时又是最容易实现的一种渗透方法，一个具有一般网络知识的入侵者就可以在很短的时间内利用现成的工具实现远程溢出攻击。对于在防火墙内的系统存在同样的风险，只要对跨接防火墙内外的一台主机攻击成功，那么通过这台主机对防火墙内的主机进行攻击就易如反掌。
4、口令猜测
口令猜测也是一种出现概率很高的风险，几乎不需要任何攻击工具，利用一个简单的暴力攻击程序和一个比较完善的字典，就可以猜测口令。
对一个系统账号的猜测通常包括两个方面：首先是对用户名的猜测，其次是对密码的猜测。
1、本地溢出
所谓本地溢出是指在拥有了一个普通用户的账号之后，通过一段特殊的指令代码获得管理员权限的方法。使用本地溢出的前提是首先要获得一个普通用户的密码。也就是说由于导致本地溢出的一个关键条件是设置不当的密码策略。多年的实践证明，在经过前期的口令猜测阶段获取的普通账号登录系统之后，对系统实施本地溢出攻击，就能获取不进行主动安全防御的系统的控制管理权限。
2、Web 脚本及应用测试
Web 脚本及应用测试专门针对 Web 及数据库服务器进行。根据最新的技术统计，脚本安全弱点为当前 Web 系统尤其存在动态内容的 Web 系统存在的主要比较严重的安全弱点之一。利用脚本相关弱点轻则可以获取系统其他目录的访问权限，重则将有可能取得系统的控制权限。因此对于含有动态页面的 Web、数据库等系统，Web 脚本及应用测试将是必不可少的一个环节。在 Web 脚本及应用测试中，可能需要检查的部份包括：检查应用系统架构、防止用户绕过系统直接修改数据库检查身份认证模块，防止非法用户绕过
3、身份认证
检查数据库接口模块，防止用户获取系统权限检查文件接口模块，防止用户获取系统文件检查其他 web 安全威胁
4、其它除了上述的测试手段外，还有一些可能会在渗透测试过程中使用的技术，包括：
社会工程学
客户端攻击
拒绝服务攻击（现网环境不采用）
中间人攻击
六、渗透测试实施输入输出
1、输入指导
主机渗透测试：指定 IP 地址
WEB 渗透测试：URL、IP 地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f8e027ef6f2cb8895aa5a87ef94f0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f1869b3c83737da82c3cbc1971ef14/" rel="bookmark">
			ntp校时服务器、ntp授时服务器、ntp时钟服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ntp校时服务器、ntp授时服务器、ntp时钟服务器
ntp校时服务器、ntp授时服务器、ntp时钟服务器
三者都是利用NTP技术来实现时间同步服务的一种电子科技产品，名称不同功能一样而已、设备采用冗余架构设计，高精度时钟直接来源于北斗、GPS系统中各个卫星的原子钟，通过信号解析驯服本地时钟源，实现卫星信号丢失后本地时钟精准保持功能。独特的嵌入式硬件设计、高效Linux操作系统，可灵活扩展多种时钟信号输出。全面支持最新NTP对时协议、MD5安全加密协议及证书加密协议，时间精度优于2毫秒。
融合了参考源无缝切换技术、高精度时间间隔测量TIC技术和自适应精密频率测控技术。采用模块化设计，由北斗接收机、GPS接收机、高性能工业级主板、人机界面及监控管理单元、本地时钟（晶振）驯服单元、输出接口模块和电源模块组成。
设备可以广泛应用于政府、金融保险、移动通信、云计算、电子商务、能源电力、石油石化、工业自动化、智能交通、安防、智慧城市、物联网、国防军工等领域。
l 系统扩展性：使用GPS时间参考源为一级网络时间服务器，可选配北斗卫星接收机、格洛纳斯卫星接收机作为授时时间源；可选配支持时钟信号输出扩展，可输出10M、E1、1PPS、B码等时钟信号；可选配恒温晶振或铷原子钟作为守时部件，支持独立时间守时功能；设备可配置为二级时间服务器。
l 硬件稳定可靠：选取高稳定的工业级服务器主板，MTBF可达80000小时；支持多路相互独立的10/100/1000M 以太网端口。
l 软件高效可靠：采用高效嵌入式Linux操作系统，授时精度高，PPS精度100ns，服务器授时精度1us；提供Windows NTP软件进行精确同步。
l 显示屏内容丰富：液晶信息丰富，可显示卫星、网络、系统等状态信息；通过LED状态指示灯显示服务器工作状态。
l 网络安全配置：支持Bonding功能，通过该功能轻松实现网卡冗余备份和负载均衡；支持iptable包过滤配置功能。
l 系统管理方便：支持Telnet、SSH远程配置管理，支持SNMP网管功能；提供直观的NTP时间网络监控软件BDMonitor，可监控服务器卫星和同步信息，通过syslog、Email等方式发送异常事件信息。
VFD高亮超宽液晶屏
Ø 显示卫星时间、卫星状态、锁定卫星颗数、经纬度、高度、各网卡IP、子网掩码、系统工作状态、版本号等
LED指示灯
Ø REF：设备锁定卫星亮，设备失锁卫星熄灭
Ø NTP：当设备NTP服务具备授时功能时亮
Ø ALM：当设备卫星失锁或NTP授时异常时亮
Ø CONSOLE接口（左）：1路，RJ-45串口，波特率115200，数据位8，停止位1，无流控，用于配置NTP授时系统。
Ø USB接口 :2路，备份、恢复、升级功能
Ø ETH网络接口:6路，RJ-45，10/100/1000M自适应以太网接口
Ø ANT接口：天线输入，BNC，1路，GPS L1、BD2B1，输出5V DC。
Ø 10MHz:1路，BNC,正弦波，幅度12±1dBm，50Ω。（晶振产品选配）
Ø 1PPS接口：硬件秒脉冲信号输出，TTL电平，50Ω，BNC接口；授时精度：&lt;±30ns（RMS）；GPS/北斗接收机工作不正常时或进入内时钟保持状态时，不保证上述精度。
Ø 绿端子：未定义，暂无意义。
Ø TOD：1路，TOD输出，波特率9600，数据位8，停止位1，无流控；输出语句：**RMC，**GGA。
Ø VGA接口：1路，连接显示器，配置NTP授时系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13735de1bdcfb3e60f00ce2dda93afd/" rel="bookmark">
			VS2022 Android NativeActivity 开发指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几年前最初使用VS时，记得是有Android NativeActivity的，今天更新到了2022最新版，发现找不到这个创建选项。
然后确保安装了C++ 跨平台开发工具后，开始排查原因。
Visual Studio 2022 中没有“本机活动应用程序” - android - SO中文参考 - www.soinside.com
在网络上看到了这么一片帖子，疑似“Visual Studio 17.4 版本之前提供。从那时起它就被删除了，Android SDK 更新 Ant 脚本已被删除，因此用户将不再在“新建项目”对话框中看到基于 Ant 的模板。”
但我在MSDN MDK也没有找到官方删除的说明。
最终的方案：
1.下载模板 GitHub - dnd29/Android-Native-Visual-Studio-Template: Android Native Activity (GameActivity) For Visual Studio Template
2.更改VS的Java版本设置为jdk11以上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b53d8c1b95b1095ae4b335a1736814b/" rel="bookmark">
			openssl 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		openssl genrsa 命令产生私钥 openssl genrsa 命令是会用来生成 RSA 私有秘钥，不会生成公钥，因为公钥提取自私钥。生成时是可以指定私钥长度和密码保护。
如果需要查看公钥或生成公钥，可以使用 openssl rsa 命令。
命令语法：
openssl genrsa [-out filename] [-passout arg] [-f4] [-3] [-rand file(s)] [-engine id] [numbits] [-des] [-des3] [-idea]
openssl genrsa [-out filename] [-passout arg] [-aes128] [-aes192] [-aes256] [-camellia128] [-camellia192] [-camellia256] [-des]
[-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]
penssl genrsa ?
openssl genrsa ?
usage: genrsa [args] [numbits]
-des encrypt the generated key with DES in cbc mode
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b53d8c1b95b1095ae4b335a1736814b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8cc9b755e2fdb829eb85be6108bfccd/" rel="bookmark">
			SRS服务器RTMP2WebRTC外网拉流配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将前端服务开放到外网，并且在外网使用WebRTC拉流，要求全部使用同一端口。
外网地址：10.172.59.42（域名：test.com）外网端口为33333内网SRS服务器地址：192.168.5.177，内网端口为10090路由器将外网33333端口映射到内网192.168.5.177:10090 一、使用docker搭建SRS服务器
1、编辑~/.bashrc，添加export CANDIDATE="192.168.5.177"，执行source ./bashrc。
2、docker创建SRS服务器，将开放的8000端口改为33333端口。
docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 --env CANDIDATE=$CANDIDATE -p 33333:33333/udp registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf WebRTC包含信令(Signaling)和媒体(Media)两个部分的协议，信令默认使用1985端口，媒体默认使用UDP8000端口传输，无法单独修改发送给客户端的媒体端口，所以需要将8000端口改为和外网端口一致的端口33333。
3、修改SRS配置文件，将rtc_server中监听的UDP端口8000改为33333，重启容器。
# 将容器中的配置文件复制到本地 docker cp srs:conf/rtmp2rtc.conf ./ # 将本地修改完的配置文件复制回容器内 docker cp rtmp2rtc.conf srs:/usr/local/srs/conf # 重启容器 docker restart srs 二、使用Nginx配置反向代理
http { server { listen 10090; server_name _; # WebRTC拉流时，需要调用API：/rtc/v1/play/ location /rtc { proxy_pass http://localhost:1985; } # WebRTC拉流地址前缀匹配 location /live { proxy_pass http://localhost:1985; } } } # steam块不能放在/etc/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8cc9b755e2fdb829eb85be6108bfccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36527a3c4ccac8eccb1b17b878b865db/" rel="bookmark">
			履机乘变，轻舟便楫：源启分布式PaaS深度赋能企业级技术平台建设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语
源启分布式PaaS平台围绕应用视角为用户提供应用运行的全生命周期管控能力，提供注册中心、服务路由、网关、服务治理等中间件技术支持，实现应用之间的联通，解决客户多厂商产品不兼容、产品组合不可选择、孤岛效应等问题，满足企业级应用集成需要，实现降本增效。
在《洞若观火，明察秋毫：源启一体化监控平台构建云原生全链路可观测体系》中，我们阐述了源启一体化监控平台，是如何构建完整云原生可观测体系，保障敏稳双态业务稳定运营的。今天，我们将向大家详细介绍源启分布式PaaS平台是如何深度赋能企业级技术平台建设，为数字化应用迁移上云打下坚实技术基础，保障企业数字化转型。
日前，中电金信正式发布源启分布式PaaS平台5.0。源启分布式PaaS平台是以应用为核心，采用分布式架构、DevOps、数据驱动、自动运维和持续创新等设计理念，面向金融和重点行业量身打造的快捷灵活、跨平台、智能化的技术平台。
源启分布式PaaS平台是构成源启基础运行支撑平台的主要产品之一，同时也是源启数字底座的重要组成部分，为整个数字底座提供平台服务管理能力。平台为重点行业客户提供完整的、满足金融IT标准的轻量级分布式PaaS平台解决方案，助力客户打造具备快速设计、快速开发、快速部署能力的高可用、高可靠、可视化的企业级技术平台。围绕应用视角，源启分布式PaaS平台为用户提供应用运行的全生命周期管控能力，提供注册中心、服务路由、网关、服务治理等中间件技术支持，实现应用之间的联通，解决客户多厂商产品不兼容、产品组合不可选择、孤岛效应等问题，满足企业级应用集成需要，实现降本增效。
随着数字化转型步入深水区，企业在自身传统业务模式的基础上，开始朝向创新型业务模式发力，业务形态的发展日新月异，对新一代技术平台的需求也日益凸显。这需要技术平台能匹配业务转型的需求，满足日益复杂的业务系统变化，在转型期内支持庞杂系统内设备、组件、技术体系多样化并存的实际情况，并在业务转型期间及转型完成后均保持极高的灵活性，支持新兴业务的快速迭代开发。
为了满足以上需求，企业级技术平台需要建立灵活与复杂的标准化管理体系，具备对应用资产、中间件资产、数据库资产多种类资产以及未来可能出现的新型资产等进行统一管理的能力，方便各类资产快速统一接入和快速装配集成；同时需要具备分布式微服务开发、服务治理、资源监控、开源技术中间件维护能力。
中电金信自2012年起就开始了金融分布式技术的研究探索。从2012年至2019年，中电金信实现了从初探分布式架构、分布式PaaS平台1.0、2.0、金融核心项目群统一分布式技术平台，到实现解耦、组件化、跨平台、国产化的开发、运行、管控一体化分布式PaaS平台3.0的逐步进化。
2019年以后，为了解决长久以来金融业IT面对的分布式微服务开发和中间件管理两大难题、贴合云原生技术发展以及满足国产化要求，中电金信在分布式PaaS平台3.0基础上继续扩展了分布式微服务规范、多租户、应用管理、安全、高可用等能力，提升了平台的可用性，增加了对国产化设备、国产化中间件、国产化分布式数据库的支持；同时增加容器、镜像库、组件市场，实现更加广泛的中间件支持。经过多年的建设、发展和完善，尤其在云原生、单元化、多地多活等技术方向积累了大量的经验与成果，并经由多个重大项目的落地验证，源启分布式PaaS平台5.0于近日正式上线。
源启分布式PaaS平台主要由联机引擎、批量引擎、服务治理、服务路由、服务网关、分布式事务、批量调度、序列中心、缓存中心、消息中心、注册中心、配置中心、日志、监控平台、文件传输等组件组成，同时具备企业级应用集成、中间件管理、典型应用场景服务引擎、应用运行管理及监控运维等核心能力。
源启分布式PaaS平台全面具备重点行业应用所需的关键技术特性，并形成完善的金融级应用支撑能力，整个平台基于开发态、运行态、运维态进行整体设计，具备支持云原生、多地多活、单元化等特点。
作为企业基础设施与业务体系衔接层，源启分布式PaaS平台起到了“桥梁”的重要作用，结合开发工具链体系和运维工具链体系，满足业务扩展时的快速组装能力与快速运维接入能力。源启分布式PaaS平台采用松耦合理念设计，形成“开发、运行、管控”一体化的完整技术体系，可按客户需求进行组件定制组合；弹性伸缩、灵活扩展，支持高并发、海量用户和秒杀、抢购等互联网应用场景；支持持续集成、可视编排、一键自动化部署、灰度发布等一套完善的DevOps体系；具备统一的平台监控和运维管理，涵盖资源、组件、应用的多维度管理和监控；为上层应用系统提供技术隔离、平台无关、高效易用的分布式开发框架。同时，依托中国电子集团能力，可为重点行业客户提供安全稳固的系统架构升级和数字化转型支撑。
源启分布式PaaS平台在设计时充分考虑了国内金融等重点行业系统特点，保证了在合理利用旧有IT资产的情况下，向云架构平稳过渡的可能。平台能支撑10亿以上账户，支撑核心银行、互联网移动银行等关键应用及其他60多种主流数字化应用，具备完善的PaaS平台应用、实施标准和技术规范体系。目前已成功在分布式核心系统、信用卡核心、开放银行等场景中应用，并在多家国有大行、股份制银行、城市商业银行和非银金融机构中构建了分布式技术体系，在金融行业云建设中处于领先地位。此外，还为多家金融机构提供了分布式技术平台规划与设计，为其构建分布式应用产品体系赋能。
中国的金融及重点行业已进入开放化、数字化、智能化的全新发展阶段，在时代带来的机遇之下，中电金信顺势而为，始终坚持自主研发及科技创新，在实践中不断迭代更新，持续提升分布式技术平台产品的成熟性与稳定性，为行业客户数字化应用的迁移上云打下坚实的技术基础，并不断保持技术前瞻性，将高新技术转换成生产力，全面赋能金融及重点行业数字化转型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc202dcd5eb421f8284b39db83724e1/" rel="bookmark">
			ros2 基础学习12 分布式通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？
这就是分布式系统，可以实现多计算平台上的任务分配。
分布式通信
什么叫分布式？
之前我们也讲过，在ROS系统中，机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中。
这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。
比如这款机器人系统中，有两个计算平台。
机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用树莓派作为控制器，主要实现传感器驱动和电机控制等功能。
不过视觉处理和应用功能就不适合在树莓派里运行了，我们放在另外一个性能更强的笔记本电脑中。
此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。
两个电脑之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的。
不过ROS系统都已经为我们设计好了，我们只需要在每一个电脑上配置好ROS环境，功能开发上完全不需要做任何变化，实现非常方便。
接下来，我们就带领大家一起来感受下ROS分布式系统的魅力。
分布式网络搭建
除了我使用的笔记本电脑之外，另外一个计算平台我们选择了树莓派，模拟一个放置在机器人上的控制器。
树莓派配置
在开发之前，我们需要先配置好树莓派的环境，网上也有很多资料，大家都可以参考。
装系统
我们先要给树莓派装系统，这里我们选择的是Ubuntu Mate针对树莓派的镜像，下载镜像之后，烧写到树莓派的SD卡中就可以启动系统了。
Ubuntu MATE镜像下载链接：
https://ubuntu-mate.org/download/
安装ROS2
在安装好的Ubuntu Mate系统中，安装ROS2，和电脑端安装的流程一样。
编译代码
将我们课程的代码也下载到树莓派中，进行编译。
远程桌面
如果大家有显示器，可以直接在树莓派上连接键盘鼠标显示器使用，如果使用不方便的话。
也可以在树莓派上配置好远程桌面，就可以通过网络访问树莓派的桌面系统了。
以上步骤的整体流程和电脑端操作基本一致，大家也可以参考如下链接配置树莓派：
https://blog.csdn.net/qq_52785580/article/details/122599728
分布式数据传输
树莓派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？
简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。
Attention
如使用虚拟机，请将虚拟机网络修改为桥接模式
在树莓派端，使用如下命令启动一个发布者节点：
ros2 run demo_nodes_cpp talker #树莓派端 图片
接下来在电脑端，使用如下命令启动一个订阅者节点：
ros2 run demo_nodes_py listener #PC端 神奇的事情就这样发生了，只要两个计算机安装好ROS2，并且处于同一网络中。
他们就可以实现之前讲过的话题、服务、动作等通信了，感觉就像在一个电脑里一样。
不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联。
而是可以分组通信，小组之间是无法实现通信的。
分布式网络分组
没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样。
处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和树莓派端的.bashrc中加入这样一句配置，即可将两者分配到一个小组中：
export ROS_DOMAIN_ID=&amp;lt;your_domain_id&amp;gt; 如果分配的ID不同，则两者无法实现通信。
案例一：小海龟分布式控制
分布式通信网络似乎已经建立成功了，是否真有我们想的这么神奇，我们继续测试之前学习过的一些例程。
先来试试ROS中的经典案例——小海龟。
我们可以在电脑端启动小海龟仿真器，树莓派上启动键盘控制节点，或者反过来也可以，依然可以流畅的控制小海龟运动：
ros2 run turtlesim turtlesim_node # PC端$ ros2 run turtlesim turtle_teleop_key # 树莓派端 案例二：话题分布式通信
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc202dcd5eb421f8284b39db83724e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952b4d9a48ab6f9aebfda92310830465/" rel="bookmark">
			【MPC学习笔记】01：MPC简介（Lecture 1_1 Unconstrained MPC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记来自北航诸兵老师的课程
课程地址：模型预测控制（2022春）lecture 1-1 Unconstrained MPC
文章目录 0 MPC 简介0.1 案例引入0.2 系统模型0.3 MPC的优点0.4 MPC的缺点0.5 MPC的未来 1 详细介绍 0 MPC 简介 0.1 案例引入 MPC（Model Predictive Control）模型预测控制，是预测控制的一种，是基于模型来进行控制的。
老师举了下面这个例子来引入MPC的基本思想：
比方说我们为未来的一段时间制定计划，一天中几点到几点该做什么。但是计划赶不上变化，出现变化，出现拖延，计划就得做相应的调整。过了一段时间，根据计划的实际落实情况，再对接下来的计划进行调整。如此往复。不断地执行计划，也不断地修订计划。
0.2 系统模型 在控制系统中，有惯用表示：输入记作 u u u，状态变量记作 x x x，输出记作 y y y
假设系统是离散的，系统的状态方程为：
x ( k + 1 ) = f ( x ( k ) , u ( k ) ) x(k+1)=f(x(k),u(k)) x(k+1)=f(x(k),u(k))
实际上系统可以是，线性的或非线性的，连续的或离散的或既包含连续又包含离散的，确定的或随机的，只要满足该方程即可
设当前时刻为 k k k，当前状态为 x ( k ) x(k) x(k)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952b4d9a48ab6f9aebfda92310830465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc08d4b40e53309f3987039ca064e750/" rel="bookmark">
			【MPC学习笔记】02：MPC详细简介（Lecture 1_1 Unconstrained MPC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本笔记来自北航诸兵老师的课程
课程地址：模型预测控制（2022春）lecture 1-1 Unconstrained MPC
接上一篇：【MPC学习笔记】01：MPC简介（Lecture 1_1 Unconstrained MPC）
文章目录 1 详细介绍1.1 状态方程1.2 Cost Function1.3 状态变量 u ( k ) u(k) u(k) 的求解1.4 举例 1 详细介绍 1.1 状态方程 对 LTI 离散系统：
x ( k + 1 ) = A x ( k ) + B u ( k ) x ∈ R n , u ∈ R p x(k+1) = Ax(k) + Bu(k)\quad x\in\R^n, u\in R^p x(k+1)=Ax(k)+Bu(k)x∈Rn,u∈Rp
对传统控制系统，连续系统是好处理的，离散系统是要额外考虑其他因素的
对MPC，则是反过来，离散系统是好处理的，连续系统是要额外考虑其他因素的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc08d4b40e53309f3987039ca064e750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc75140c0710e8c6f94dba86a1991b37/" rel="bookmark">
			K8S三种发布方式和声明式资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝绿发布 把应用服务集群标记位两个组，蓝组和绿组，先升级蓝组，先要把蓝组从负载均衡当中移除，绿组继续提供服务，蓝组升级完毕，再把绿组从负载均衡当中移除，绿组升级，然后都加入回负载均衡当中去，完成对外服务，对硬件资源要求很高，但是有了云计算和微服务，现在的成本也大大降低了
特点：
1.一旦出现问题，问题影响范围很大
2.发布策略简单
3.基于云计算技术和微服务，用户是无感知的
4.升级和回滚都比较方便
缺点：
在发布升级的过程之中，只有一部分集群在对外服务，可能会使集群的负载能力下降，响应变慢,需要注意给集群增加负载能力（一般来说没什么特殊需求）
段时间内可能会浪费一定的资源成本
金丝雀发布（灰度发布） 基于deployment控制器创建的服务，才可以使用这种发布方式，也算是一种滚动更新，实现了一个步骤叫暂停，也就是发布的过程中，暂时停止，只有一部分的pod先升级，其他的pod还是处于老的版本，只有一部分用户可以访问新的版本，绝大数用户还在老版本，确定无问题之后，再把剩下的老版本升级成新的版本，也就是把暂停取消，继续发布，如果有问题可以立即回滚，暂停不是回滚，一旦取消暂停只能全部升级完毕之后，再回滚。
特点：
自动化的要求比较高，对运维人员的要求比较高
方便发现问题，及时解决，影响范围比较小
用户无感知，可以实现平滑过渡，而且比较节约资源
发布策略比较复杂
不易回滚，必须等到全部发布成功之后才能回滚。
滚动发布 deployment的默认更新方式
应用程序升级，面临的最大的问题是新旧业务之间的切换，从立项&gt;定稿&gt;需求发布&gt;开发&gt;测试&gt;发布，测试之后上线，再完美也会有问题，为了不让发生的问题影响所有用户，有了上述的三种发布方式
声明式资源管理(yaml文件)
1 适合对资源的修改操作
2 声明式管理依赖于yaml文件，所有的内容都在yaml文件当中
3 编辑好的yaml文件还是要靠陈述式命令发布到k8s集群当中
Kubectl create
只能创建，不能更新，从指定yaml文件中读取配置，创建服务，不能更新
Kubectl apply -f
既可以创建资源对象也可以更新资源对象，如果yaml文件更改了，apply可以直接更新资源对象
Kubectl delete -f
删除yaml文件中声明的资源对象，如deployment或者pod和service
Yaml文件如何生成
1手打2 可以根据已有的资源，直接生成
1.deployment的yaml文件
2.Service的yaml文件
3.不基于控制器的pod的yaml文件
k8s当中支持两种声明式资源管理方式
yaml格式
用来配置和管理资源对象
Json格式
主要用于api接口之间消息的传递
[root@master01 k8s.yaml]# kubectl get deployments.apps NAME READY UP-TO-DATE AVAILABLE AGE myapp-test 0/3 3 0 5d nginx-chen 0/1 1 0 40h [root@master01 k8s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc75140c0710e8c6f94dba86a1991b37/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/13/">«</a>
	<span class="pagination__item pagination__item--current">14/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/15/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>