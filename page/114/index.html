<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90309ea39b0d5d7e582061aaf06b76d/" rel="bookmark">
			如何将centOS环境下的MySQL服务改为开机自启动而非手动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.启动MySQL服务
systemctl start mysqld 2.检查服务是否启动
systemctl status mysqld 3.查看是否为自启动
systemctl list-unit-files | grep mysqld.service 默认为 enabled 即为自启动，disabled 为非自启动
4.设置为开机自启动
systemctl enable mysqld.service 5.查询即可
[root@atdajv ~]# systemctl list-unit-files | grep mysqld.service mysqld.service enabled [root@atdajv ~]# 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e318836778eec993b557e64984d4f721/" rel="bookmark">
			在centOS环境下安装MySQL80步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名数据库菜鸟在通往大佬的路上肯定会接触到虚拟机，那么如何在centos环境下安装MySQL呢？首先就得去官网下载相应文件，网址如下https://dev.mysql.com/downloads/mysql/（这里用到的是MySQL Community Server社区版本，也就是白嫖版）： 选择1之后，就在2中选择对应需要的就ok 下载后就可以解压在同一个文件夹中了
1.这里使用Xftp5先去连接虚拟机，连接成功后一般将安装文件推送在虚拟机的 /opt 目录下 ，直接在Xftp中从主机拖过来即可（可能Xftp在连接成功后会出现乱码情况，这里在设置里勾选使用uft-8编码后刷新即可如下图）；
这里需要使用的工具我打包ok了：http://链接：https://pan.baidu.com/s/1XainZKG7cv2TyupV-BZzOQ 提取码：dajv
2. 推送完毕后这里用的是Xshell去做查看，先在Xshell中连接虚拟机，然后执行 # cd /opt ; # ll ，会显示刚推送成功的文件；
[root@atdajv ~]# cd /opt [root@atdajv opt]# ll 总用量 489748 -rw-r--r--. 1 root root 47810444 11月 27 16:36 mysql-community-client-8.0.25-1.el7.x86_64.rpm -rw-r--r--. 1 root root 193616 11月 27 16:36 mysql-community-client-plugins-8.0.25-1.el7.x86_64.rpm -rw-r--r--. 1 root root 628904 11月 27 16:36 mysql-community-common-8.0.25-1.el7.x86_64.rpm -rw-r--r--. 1 root root 4240320 11月 27 16:36 mysql-community-libs-8.0.25-1.el7.x86_64.rpm -rw-r--r--. 1 root root 448614076 11月 27 16:36 mysql-community-server-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e318836778eec993b557e64984d4f721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793dd14c9331e89d0ece6c13bc95b54b/" rel="bookmark">
			BCrypt算法的基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BCrypt算法是一种基于哈希算法的算法，所以，这种算法也是不可逆的！
应用场景:用于存放密码，卡号等不可解密的数据信息
在开发实现中，通常，可以使用配置类中的@Bean方法来创建BCryptPasswordEncoder对象，此对象将是由Spring进行管理的，当需要使用时，自动装配即可，例如：
@Configuration public class SecurityConfiguration { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } } @Service public class AdminServiceImpl implements IAdminService { @Autowired private PasswordEncoder passwordEncoder; } 下面我们来看看BCrypt的使用:
如上我们编写了一个测试类,类中方法testEncode()和testMaches()分别实现了密码加密和密码匹配
当我们执行第一个方法testEncode()得到如下结果:
我们在多执行几次,看看结果会有什么不同:
对此我们可以很清楚的看到,密码并未改变都是123456,而加密后的密文每一次的结果都不同的.
为什么会出现这种情况?
这是因为
通过BCrypt算法进行编码后的结果，长度固定为60字符。
使用同一个原文进行反复编码，每次得到的结果都是不同的，因为在编码过程中，BCrypt使用了随机的盐，并且，使用的盐也作为编码结果的一部分保存了下来。
BCrypt算法的加盐机制:
随机生成一个含有29个字符的字符串,并且会与密码一起合并进行最终的密文生成
每一次生成的盐的值都是不同的
且密码不可逆，是通过加密后和密文比较来确认
下面我们执行一下testMaches()方法看看生成的不同密文是否和原密码都是匹配的: 可以看出生成的不同密文最终的匹配结果都是true.
所以,以上就是BCrypt算法的一些基础使用,希望可以帮助到大家!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85e24de67317fbf00e63ba0e9f29cde/" rel="bookmark">
			简单理解--java反射（面试必备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是反射? 一般Java对象的类型在编译器就已经确定下来了在运行的时候可能会动态加载一些类，但是这些类在之前并没有用到，所以他没有加载到Java虚拟机里面，这个时候就可以使用反射机制进行加载
反射是在运行状态中，对于任意一个类,都能够知道这个类的所有属性和方法;对于任意一个对象， 都能够调用它的任意一个方法和属性;这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。
二、反射的优缺点? 优点: 通过配置文件设定要反射的类，即可自动完成对象的实例化，然后进行相应操作，完全不需要更改java源代码，提高了程序的灵活性和拓展性。
缺点: 打破封装、私有属性会被访问;反射机制是动态解析的，JVM无法进行代码优化。
三、反射机制的主要应用场景 用于反编译将.Class 文件转换成.Java 文件Spring框架的配置使用的就是反射来动态加载对象： 我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序;
Spring框架的IOC (动态加载管理Bean) 创建对象以及AOP (动态代理)功能都和反射有联系;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcb8b236a4278bcb51e09aa76efafcc/" rel="bookmark">
			点云体素下采样(抽稀)（附open3d python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 采样后的点排列看上去会很整齐均匀，但是位置和之前相比有轻微的移动。 体素下采样使用常规体素网格从输入点云创建均匀下采样的点云。 它通常用作多点云处理任务的预处理步骤。该算法分为两步操作: 1. 点被储存到体素中。 2. 每个被占用的体素通过平均内部所有点的坐标而生成一个点。 参数voxel_size为体素大小，该参数越小，降采样得到的结果的点越多， 该方法的缺陷是会改变原有点的坐标， 因为下采样之后的点是通过平均计算得到的。 # coding:utf-8 import numpy as np import open3d as o3d print("-&gt;正在加载点云... ") point_cloud = o3d.io.read_point_cloud("kitti_p.pcd") print(point_cloud) point_cloud2 = point_cloud.voxel_down_sample(voxel_size=0.5) # voxel_down_sample 把点云分配在三维的网格中取平均值 o3d.visualization.draw_geometries([point_cloud2], window_name="wechat 394467238 ") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70dfc801045a36a31b7910fafe4bed3/" rel="bookmark">
			JavaScript判断奇偶数的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章就给大家分享JS判断奇数和偶数的两种方法，感兴趣的朋友可以参考一下：
方法一：if else 双分支语句方式 描述：用if函数判断数字能否整除2，能则为偶，否则为奇，具体代码如下：
var num = prompt('输入一个数字'); if(num % 2 == 0){ alert('这是个偶数') }else{ alert('这是个奇数') } 方法二：三元运算方式 描述：原理一样，都是判断数字能否整除2，不过使用三元表达式更为简便，具体代码如下：
var num = prompt('输入一个数字'); var result = num % 2 == 0 ? '这是偶数' : '这是奇数'; alert(result); 以上就是JS判断数字是奇数还是偶数的两种方法，原理都是相同，只是实现方法不一样，初学者可以自己动手尝试，希望对你有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ef58ac7138cd549d25a27e93b184f3/" rel="bookmark">
			JavaScript-ES6-基础语法二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6-基础语法二 1. Symbol1.1. Symbol介绍1.2. Symbol内置值 2. 迭代器2.1. 迭代介绍2.2. 自定义迭代器实现 3. 生成器3.1. 生成器介绍3.2. 带参数生成器使用3.3. 生成器解决回调地狱问题3.4. 生成器异步回调demo 4. Promise4.1 Promise基本使用4.2. Promis封装读取文件4.3. Promis封装Ajax4.4. Promise then方法4.5. Promise catch 方法4.6. Promis读取多个文件实战 1. Symbol 1.1. Symbol介绍 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。
Symbol特点：
Symbol 的值是唯一的，用来解决命名冲突的问题Symbol值不能与其他数据进行运算Symbol定义的对象属性不能使用for…in 循环遍历, 但是可以使用Reflect.ownKeys来获取对象的所有键名 // create symbol let s = Symbol() console.log('s: ', s) // Symbol() console.log('type of s: ', typeof s) // symbol // create symbol with value let s2 = Symbol('michael') let s3 = Symbol('michael') console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ef58ac7138cd549d25a27e93b184f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e318e79b7f7aa7b174ca75e28d541e/" rel="bookmark">
			Docker-JenKins安装及配置！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jenkins官网：Jenkins
安装主机配置（官方）： 最低： 256 MB 内存
1 GB 的驱动器空间（尽管如果将 Jenkins 作为 Docker 容器运行，则建议至少 10 GB）
小团队推荐： 4 GB+ 内存
50 GB 以上的驱动器空间
其实，还是根据微服务项目的大小和多少来定毕竟构建一个项目和构建多个项目所需要的主机配置是有很大的跨度的； 拉取镜像：jenkins官方下载地址 拉取镜像命令：docker pull jenkins/jenkins:2.332.3-lts;
创建并编辑启动jenkins的dockercompose.yml文件； version: "3.1" services: jenkins: image: jenkins/jenkins:2.332.3-lts container_name: jenkins ports: - 9999:8080 - 50000:50000 volumes: - /mydocker/jenkins/data/:/var/jenkins_home/ 执行命令 ：docker-compose up -d
ports:
- 9999:8080 将jenkins容器的8080映射到宿主机的9999端口；
并查看日志如果出现一下权限问题就赋予它即可：
输入命令：chmod -R 777 data
再次重启jenkins容器即可：docker-compose restart 访问部署好的jenkins：http://8.142.97.14:9999 输入初始密码：输入：docker logs -f jenkins 查看jenkins启动日志查看密码；
复制密码确定即可；然后选择推荐安装，得等一大会儿毕竟镜像都在国外，当然下载失败也没问题，后期可以在jenkins官网插件模块下载即可：
完成之后创建第一个用户：
保存并继续；
保存并继续；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1e318e79b7f7aa7b174ca75e28d541e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a01f7a49e5e162a791db57cf26f196/" rel="bookmark">
			linux 命令行进入redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.找到redis安装目录
2.进入redis bin目录 cd /usr/local/redis/bin
3.查看有没有 redis-cli 有则执行 redis-cli
执行命令报错：(error) NOAUTH Authentication required
执行：auth 密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0823dda624f20e320eca26e843492370/" rel="bookmark">
			牛客网——翻转直角三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冲
目录
前言
一、翻转直角三角形
描述
输入描述：
输出描述：
总结
前言 你永远不知道未来的你 会有什么样的人生 会和什么样的人在一起恋爱 吃的是几块钱的早餐 生活的是几线城市 会给父母怎样的回报 越努力越幸运 你的余生还很长 要坚强地走下去 要做一个优秀的女孩儿 对自己狠一点 逼自己努力 再过五年 你将会感谢今天发狠的自己 恨透今天懒情自卑的自己 既然认准一条路 那就坚持走下去 命运不会辜负每一个对自己认真而努力的人.
You never know what kind of life you will have in the future. What kind of people will you fall in love with? It is a few dollars for breakfast. What are the rewards for parents in a few cities? The harder you work, the luckier you are.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0823dda624f20e320eca26e843492370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ddd84bf01c027bc6b664b8a82bf9a7/" rel="bookmark">
			FastAPI从入门到实战（7）——请求体函数的参数设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇记录了FastAPI中声明请求体的相关内容，本文记录一下零碎的函数特性和参数特性相关内容。
Pydantic schema_extra 可以使用 Config 和 schema_extra 为Pydantic模型声明一个示例:
class City(BaseModel): country:str = "中国" provence:str = Field(...,example = "四川") # Field可以定义请求体的格式和类型 citys: Optional[List] = None population: int = Field(default=None,title="人口数",ge=1000) class Config: schema_extra = { "example":{ "country":"中国", "provence":"四川", "citys":["绵阳","成都","遂宁","..."], "population":66666666 } } Field参数设置 field同Path、Query、Body可以设置default、title等信息；具体参看源码;
def Field( default: Any = Undefined, *, default_factory: Optional[NoArgAnyCallable] = None, alias: str = None, title: str = None, description: str = None, exclude: Union['AbstractSetIntStr', 'MappingIntStrAny', Any] = None, include: Union['AbstractSetIntStr', 'MappingIntStrAny', Any] = None, const: bool = None, gt: float = None, ge: float = None, lt: float = None, le: float = None, multiple_of: float = None, allow_inf_nan: bool = None, max_digits: int = None, decimal_places: int = None, min_items: int = None, max_items: int = None, unique_items: bool = None, min_length: int = None, max_length: int = None, allow_mutation: bool = True, regex: str = None, discriminator: str = None, repr: bool = True, **extra: Any, ) Body参数设置 Body和Path、Query是一个性质的，分别声明请求体、路径参数、查询参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ddd84bf01c027bc6b664b8a82bf9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b78e73472ca582cd4fd2537374be947b/" rel="bookmark">
			使用ClickHouse JDBC官方驱动，踩坑无数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近遇到一个ClickHouse的线上问题：
Code: 242, e.displayText() = DB::Exception: Table is in readonly mode(zookeeper path:/clickhouse/tables/02/xxx) (version 21.12.4.1) (official build) 这个问题我在网上查原因说是由于Zookeeper压力过大，表变成只读状态，导致ClickHouse插入数据失败。
具体原因有两个：
写入数据频率过高。Zookeeper中的集群节点挂掉。 而我们项目出现这个问题的原因是第一个：写入数据频率过高。
但是在网上搜资料的过程中，我又发现了另外一个问题：我们项目用了JDBC驱动Maven groupId ru.yandex.clickhouse，但ClickHouse官方并不推荐。
于是我果断的访问了ClickHouse的官网，通过它访问了ClickHouse的GitHub地址：https://github.com/ClickHouse/clickhouse-jdbc。
证实了官网确实不建议使用ru.yandex.clickhouse驱动：
而应该改成com.clickhouse驱动，并且推荐使用0.3.2以上的版本：
于是，后面几天开始了ClickHouse的JDBC驱动升级之旅。踩了不少坑，拿出来跟大家一起分享一下，希望对你会有所帮助。
1. 第一次升级 ClickHouse官方GitHub上面推荐使用的JDBC驱动是0.3.2以上的版本：
于是，我果断把项目中的pom.xml文件中的groupId换成了com.clickhouse，版本换成了0.3.2。
刷新了一下maven，本地启动项目，能够正常运行。
然后在本地测试了一下业务功能，能够正常从ClickHouse中读取和写入数据。
心里不禁在想：这次升级实在太容易了。
2. 第二次升级 后来，项目组的同事建议换成最新版本，说有更多新功能，并且性能有很大提升。
我听到性能有很大提升这几个字，就决定再升级试试。
于是，把版本升级成了0.3.2-patch11。
在本地再次测试，业务功能一切正常。
然后把项目部署到测试环境了。
3. 发现问题了 第二天收到了两封sentry的报警邮件，报警级别都是warn。
第一封邮件中提示异常：This driver is DEPRECATED. Please use [com.clickhouse.jdbc.ClickHouseDriver] instead。
意思是说ru.yandex.clickhouse的驱动已经被废弃了，请使用com.clickhouse.jdbc.ClickHouseDriver驱动。
第二封邮件中提示异常：Also everything in package [ru.yandex.clickhouse] will be removed starting from 0.4.0。
意思是说ru.yandex.clickhouse将被移除。
看到这两封邮件，我当时有点懵，不就是用的com.clickhouse驱动包吗，ru.yandex.clickhouse是从哪里来的？
于是全局搜索了一下ru.yandex.clickhouse关键字，并没有搜到任何记录。
这让我更懵了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b78e73472ca582cd4fd2537374be947b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6560066897c961b7661bef40e09f8df/" rel="bookmark">
			算法练习--日更 准备蓝桥杯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 1.sizeof关键字 计算其数据类型占用内存的大小
sizeof(int); sizeof(hello); 2.静态变量 方法1： #define 不用分号方法2 ： 在局部变量前面加 const // ------------ 常量 ------------- // 方法一： #define 不用分号 #include &lt;iostream&gt; using namespace std ; #define Day 7 int main(){ // Day = 10 ; // 无法修改否则报错 cout &lt;&lt; "一周共有：" &lt;&lt; Day &lt;&lt; endl; // 方法2 ： 在局部变量前面加 const const int month = 12 ; cout &lt;&lt; "一月共有：" &lt;&lt; month &lt;&lt; endl; cout &lt;&lt; "其数据大小为：" &lt;&lt; sizeof(month) &lt;&lt; endl; system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6560066897c961b7661bef40e09f8df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d84aad70e3888af9ee519d8f5dfd1f/" rel="bookmark">
			如何用binlog日志恢复MySQL误删数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从学习数据库以来，我接触数据库后在日常学习中理解了 “从删库到跑路” 这句话的重要性。
终于我学到了用binlog文件恢复数据来避免这个问题，我使用的流程如下（要求：必须是centos环境下安装的MySQL）：
1.让我们先创建、插入数据（此时一定记得检查日志功能是否开启，具体参照第3步）；
mysql&gt; select * from reader; +------+---------------+---------+--------------+ | rid | rName | lendNum | rAddress | +------+---------------+---------+--------------+ | 001 | zhangYongwei | 2 | 北京西城 | | 002 | zhangDawei | 1 | 北京东城 | | 3 | jixiegongye | 10 | 北京南 | | 4 | zhangchongkun | 10 | 北京北 | | 5 | wangdaxian | 10 | 北京西 | | 6 | liergou | 10 | 北京南 | +------+---------------+---------+--------------+ 6 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d84aad70e3888af9ee519d8f5dfd1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784274d26bb540e26f122de1b0e0162f/" rel="bookmark">
			React详解(CDN引入、JSX、脚手架、类组件、函数组件、事件、Hooks、生命周期方法、Ref使用、注意点)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
React
CDN引入
开发版本
压缩版本（生产环境） React.createElement(str,obj,innerHTML)
ReactDOM.render(h3,ele)
JSX
使用
注释
数组
内联渲染样式
脚手架
创建项目包
安装VScode插件 JSX 提示
​编辑
类组件
接收参数
state状态
setState(state,callback)
defaultProps this.forceUpdate(callback)
函数组件
接收参数 defaultProps props.children
注意点 事件
绑定this
bind绑定this
箭头函数绑定this
事件池
Hooks
Ref使用详解
React生命周期和错误处理方法
注意点 img标签
React react项目是SPA（Single web Page Application单页网页应用）项目，整个网站只有一个页面，通过路由切换页面中局部的内容，实现页面的变更。
CDN引入 注意下面引入的2个文件，React负责创建元素，ReactDom负责渲染元素到其它元素中。
开发版本 &lt;script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"&gt;&lt;/script&gt; &lt;script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"&gt;&lt;/script&gt; 压缩版本（生产环境） &lt;script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"&gt;&lt;/script&gt; &lt;script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"&gt;&lt;/script&gt; React.createElement(str,obj,innerHTML) 利用React创建元素，其中str为标签的名，obj对象上的属性为该标签上挂载的属性，innerHTML为标签内的文本内容。
let h3 = React.createElement('h3',{id:'time',className:'danger'},'时间') ReactDOM.render(h3,ele) 其中h3为上面React.createElement的返回变量，ele为dom节点。
下面利用ReactDOM渲染h3元素到id为‘yf’的节点上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/784274d26bb540e26f122de1b0e0162f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f2bff374541b29a4231dce3ac148a9/" rel="bookmark">
			快手资讯|快手推出多档世界杯相关节目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、快手直播间上线“相亲角”功能 近日，快手直播间上线了“相亲角”功能，可为主播打造相亲功能。
此外，快手还在“热门活动”中推出了“婚庆”频道，主要展示“婚礼现场”、“婚纱照”等短视频内容。企查查App显示，北京快手科技有限公司发生工商变更，经营范围新增“婚姻介绍服务”。
据悉，快手一直在探索相亲方面的有关服务。今年8月，快手和黑龙江广电联合制作了一档老年相亲的综艺《老铁情缘》。同时，快手推出了自营的相亲专属平台“快相亲”，不定期推送相亲、红娘和活动信息。
2、快手Q3财报：电商业务GMV同比增长26.6%，日活达3.634亿 11月22日，快手发布2022年Q3财报，总营收同比增长12.9%至231亿元，净亏损（期内亏损）27.1亿元，同比收窄61.7%，三季度国内经营利润超3.75亿元。
快手线上营销服务（即广告）、直播和其他服务（含电商）对收入的贡献占比分别为50.1%、38.7%和11.2%。其中，快手线上营销服务收入达116亿元，同比增长6.2%；电商业务GMV同比增长26.6%至2225亿元。电商月活跃买家超过1亿规模，用户复购率同比提升约1.1%。
月活方面，第三季度快手应用的平均日活跃用户同比增长13.4%，达3.634亿；平均月活跃用户同比增长9.3%，达6.260亿。
3、周杰伦快手“歌友会”最高同时在线1129万人，获赞超10亿 11月19日晚8点，周杰伦快手独家线上“哥友会”开播。
据介绍，此次直播是周杰伦在全网首次以线上“哥友会”的形式与粉丝见面，同时也是周杰伦时隔三年再次现场开唱。
据快手官方透露，本次线上“哥友会”直播从预热阶段就备受关注，预约人数超2883万，而19日晚最高同时在线人数一度突破1129万，总点赞数达10.5亿。
4、快手推出《足球大赢家》、《快侃世界杯》等多档世界杯相关节目 11月20日，卡塔尔世界杯正式开幕。世界杯期间，快手陆续推出包括黄健翔的《足球大赢家》、刘语熙等人的《闺蜜说》、董路等人的《快侃世界杯》、李磊等人的《传奇请指教》等足球栏目。
据了解，除推出热门球员资料+足球百科科普外，快手还组建了世界杯千人预测团，为用户们提供海量精准预测和专业解读，用户参与竞猜有机会瓜分价值千万的奖池，每天开奖。
与此同时，快手燃动好物季也同步开启，快手电商为广大球迷准备了运动服饰、食品饮料等多品类好物。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4637d71f6033a69891fd5e2f6e67038/" rel="bookmark">
			python读取csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于工作需要，需要用python提取csv文件中内容，这篇文章主要是记录下用pandas读取csv文件内容的一些简单的操作，适合python初学者。
首选需要安装pandas
查看是否已安装pandas
pip list 若没有安装，则使用下面语句安装即可
pip install pandas pandas安装完成后，下面来记录下读取csv文件
首先看看csv文件内容
step1：需要把 csv和pandas引入进来
获取字段
import csv import pandas as pd def reader(master_table): file = 'csv/' + master_table + '.csv' df = pd.read_csv(file,encoding='GB18030') #如果不写encoding='GB18030'，则可能会出现中文乱码 labels = list(df.columns.values) #获取所有字段 print(labels) if __name__ == "__main__": reader('test') 执行结果如下，这是csv文件第一行的内容
['type_name', 'id', 'name', 'category', 'price'] 读取csv内容：
import csv import pandas as pd def reader(master_table): file = 'csv/' + master_table + '.csv' df = pd.read_csv(file,encoding='GB18030') #如果不写encoding='GB18030'，则可能会出现中文乱码 labels = list(df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4637d71f6033a69891fd5e2f6e67038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32be58ea5254487532538cdf53e21df/" rel="bookmark">
			跟着官方帮助文档学ICEM网格划分（附视频教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 如鹰展翅上腾 导读：划分结构化网格是ICEM软件的一大特色，自学的话会比较耗时，如有人带的话，入门进阶都是比较快的，就像一层窗户纸一捅就破。软件是使我们研究的问题得以求解的工具，重点侧向于操作性，而理论基础和经验才能正确判断计算结果的准确与否。
一、写在文前
众所周知，划分网格是仿真计算的第一步，学好ICEM软件划分网格是为了更好的服务于我们的工作和科研，ICEM划分的高质量网格可以有助于我们验证仿真的准确性。
假如你是高年级本科生，ICEM划分网格的技能可以成为你的软实力，使你的仿真计算更有底气。
假如你是研究生，在你看论文的同时可以复现论文上的仿真计算，让你搞懂论文研究内容的同时可以升华你的研究方向。
二、ICEM网格划分案例实操
接下来，我给大家展示一个《带孔三维管道结构化网格划分实操教程》。
划分结构化网格的策略
创建一个Block，对Block进行切分处理，最终使得Block与几何模型接近，然后对点、线、面进行关联（根据需要可以混合使用关联），初步设置节点参数，生成网格，判断网格的质量；细调网格尺寸，最终生成高质量网格。
Step1：打开ICEM软件，将现有几何模型导入几何ICEM，选择Geometry下的修复几何命令，修复几何模型拓扑关系，如下图所示
Step2：创建块，选择Blocking下的创建block命令，如下图所示
在Part中输入block的名字：FLUID，具体步骤见下图：
创建的Block如下图所示：
Step3：分割块，选择Blocking下的Split block命令，在Split Block中按照顺序操作。如下图所示
初步切割块如下图所示
进一步切割块如下图所示
删除多余的Block：选Blocking下的delete block命令，将多域的块删除，具体操作见下图：
Step4 映射，选择Blocking下映射命令
映射后如下所示：
对齐操作如下图所示：
对齐后如下图所示：
将不在同一平面的Vertex进行移动，使其处在同一平面，具体操作如下图
对圆孔位置的块进行两次切割，切割后如下图所示：
Step5：对块进行“O”型剖分，对所有的块进行“O”型剖分，具体操作入下图所示：
“O”型剖分的块如下图所示：
​​​​​​​ 点击完整阅读全文 一捅就破：跟着官方帮助文档学ICEM网格划分（附视频教程）
相关阅读推荐：
我从“校园小白”到仿真“职场小达人”的CFD学习史
如何成为一名CFD工程师
Workbench Meshing 边界层网格划分 step by step
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a8003acbbbeb0fcde08138d7ecfec0/" rel="bookmark">
			HugeGraph-Hubble安装配置和简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在HugeGraph官网上并没有关于HugeGraph-Hubble的安装配置，只有使用文档，所以对学习和开发人员不太友好。本文着重于HugeGraph-Hubble的安装和配置。
在进行安装之前，首先你需要安装HugeGraph的核心服务HugeGraph-server，可以参考我之前的文章hugegraph-server和HugeGraph-Hubble超详细安装部署教程
一、HugeGraph-Hubble介绍 HugeGraph-Hubble的前身是HugeGraph-Studio。
HugeGraph-Hubble：HugeGraph-Hubble是HugeGraph的Web可视化管理平台，一站式可视化分析平台。平台覆盖从数据建模，到数据快速导入，再到数据线上线下分析、图统一管理的全流程;
1、环境准备 我使用的linux(centOs7)，并且已完成HugeGraph-server的安装。
下载HugeGraph-server对应版本的压缩包，本文使用的是 HugeGraph-Hubble（1.6.0）。下载完成后将压缩包上传至linux opt目录下备用。
2、HugeGraph-Hubble使用说明 这个服务只是web可视化管理平台，进入该平台首页创建图数据库，可以绑定任意HugeGraph-server的ip和端口。
二、HugeGraph-Hubble安装配置 1.安装配置 进入目录
cd /opt
解压安装包
tar hugegraph-hubble-1.6.0.tar.gz
删除原压缩包
rm hugegraph-hubble-1.6.0.tar.gz
进入配置文件目录下
cd hugegraph-hubble-1.6.0/conf
编辑hugegraph-hubble.properties
vim hugegraph-hubble.properties
完成后保存退出
esc
:wq
2.修改后的配置文件 如果需要外部访问HugeGraph-Hubble，请修改server.host配置项 （默认为127.0.0.1），修改成机器名或IP地址，或者直接配置为（红色为修改后的）：
server.host=0.0.0.0
server.port=8088
gremlin.suffix_limit=250
gremlin.vertex_degree_limit=100
gremlin.edges_total_limit=500
gremlin.batch_query_ids=100
3.启动 进入目录
cd /opt/hugegraph-hubble-1.6.0
启动
./bin/start-hubble.sh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88895e73c7e285339325b37e12ac2cf/" rel="bookmark">
			C#线程间操作无效：从不是创建控件“textbox1”的线程访问它
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#的多线程访问中，在线程间的相互访问时因为线程安全问题有访问限制，在创建一般线程时，对于界面元素访问时这样的问题比较常见。
比如，创建一个form1，上面放置一个textbox控件，创建一个线程去访问textbox，界面如下：
按钮buuton1的代码：
private void button1_Click(object sender, EventArgs e) { var thread1 = new System.Threading.Thread(Func1); thread1.Start(); } 就是简单地创建一个线程，线程里面运行的func1代码：
private void Func1() { for(int i = 0; i &lt; 5; i++) { textBox1.Text = textBox1.Text+ $"线程{Thread.CurrentThread.ManagedThreadId}执行{i}."+Environment.NewLine; } } 运行，点击button1按钮系统会报错：
意思是说：线程间操作无效：从不是创建控件“textbox1”的线程访问它，这是不允许的。
线程存在安全保护机制，并不能随意访问，因为这样存在冲突的可能。
解决这个问题，最直接的方法是在界面初始化后去掉控件的跨线程非法访问属性，即将Control.CheckForIllegalCrossThreadCalls属性设置为false即可。
public Form1() { InitializeComponent(); Control.CheckForIllegalCrossThreadCalls = false; } 这样结果就出来了。
一般情况下，还是不要设置Control.CheckForIllegalCrossThreadCalls的属性，那么怎样可以达到修改textbox1的值呢？
可以通过委托来解决。
public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { var thread1 = new System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a88895e73c7e285339325b37e12ac2cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515c3a2ede8da5fda0a24756e8fce222/" rel="bookmark">
			Linux分区挂载目录说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备管理在 Linux 中，每一个硬件设备都映射到一个系统的文件，对于硬盘、光驱等，IDE 或 SCSI 设备也不例外。下文为大家详细介绍linux 分区的办法。
一、Linux默认可分为3个分区，分别是boot分区、swap分区和根分区。
二、设置分区挂载的目录
/ ----根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它。
swap ----交换分区，可能不是必须的，不过按照传统，还是挂载它吧。它的容量 只要约等于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。
三、对于Linux初次接触的新手或电脑硬盘空间比较小分区建议，
分区如下图:
四、设置分区挂载的目录
/home ---这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区。
/boot ---如果您的硬盘不支持LBA模式，您最好挂载它，如果挂载，将它挂载在硬盘的第一个 分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了。
五、对于Linux高级用户安装建议：
要再加上以上挂载的目录：
六、设置分区挂载的目录
/var ----如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区。
七、对于Linux高级Server用户安装建议：
可再上步中加以上挂载的目录：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4fd2575bb5166938609db432075d2f3/" rel="bookmark">
			EleutherAI GPT-Neo: 穷人的希望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面一篇blog finetune一个GPT3，借助openai的api finetune了一个GPT3，使用下来确实太贵，生成了1w条数据，花掉了60多美刀。肉痛，所以穷人只能想想穷人的办法，脑子就浮现出好朋友EleutherAI的GPT-Neo来。github上有两个项目GPT-Neo和GPT-NeoX，下图来自高仿也赛高？GPT-Neo真好用
之前一个blog，我是基于openai davinci做的微调，从这个角度来说，根据github上对gpt-neox的描述，得采用GPT-NeoX是最好的选择
We aim to make this repo a centralized and accessible place to gather techniques for training large-scale autoregressive language models, and accelerate research into large-scale training. Additionally, we hope to train and open source a 175B parameter GPT-3 replication along the way. Please note, however, that this is a research codebase that is primarily designed for performance over ease of use. We endeavour to make it as easy to use as is feasible, but if there's anything in the readme that is unclear or you think you've found a bug, please open an issue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4fd2575bb5166938609db432075d2f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce1cbb297b9de986c6a055342f1f214/" rel="bookmark">
			入门训练 Fibonacci数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下我的蓝桥杯的进击之路 今年报名了蓝桥杯比赛（Java组）所以从今天开始每天抽时间写一题的博客 从入门级别的开始（所有题都是在蓝桥杯官网上的练习系统上的） 话不多说直接开搞。 先看一下今天的题
入门训练 Fibonacci数列 问题描述 Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式 输入包含一个整数n。 输出格式 输出一行，包含一个整数，表示Fn除以10007的余数。 样例输入 10 样例输出 55 样例输入 22 样例输出 7704 数据规模与约定 1 &lt;= n &lt;= 1,000,000。 开始解题
我看到这个题的第一眼我就心里有了底了这不就是一个斐波那契数列么不愧是入门级别的题毫无挑战难度
分析一下这题
题目告诉了我们递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。
所以当n=1,n=2的时候结果都是1，故此我们知道了这个题的等价关系
废话少说直接上代码`：
public static void main(String[] args) { // TODO Auto-generated method stub Scanner sc=new Scanner(System.in); System.out.println(F(sc.nextInt())%10007); } static int F(int n) { if (n==1||n==2) { return 1; }else { return F(n-1)+F(n-2); } } 在eclipse上测试了几组样例后得到的结果与示例给出的一致，于是我提交到了蓝桥杯官网上，结果竟然出乎意料我居然只得到了30分，，，，，
纳林，什么情况？？？
看到评测结果我也很无奈呀前三次测试基数小还能通过验证后面可能基数大了导致cpu运行超时。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce1cbb297b9de986c6a055342f1f214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fef037c80c386e93fda80ca893c15a1/" rel="bookmark">
			c语言实现三子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、三子棋玩法
二、需要实现的游戏功能
三、拆分代码
3.1游戏菜单
3.2初始化棋盘
3.2.1函数调用
3.2.2函数体实现
3.3打印棋盘
3.3.1函数调用
3.3.2函数体实现
3.4玩家下棋
3.4.1函数调用
3.4.2函数体实现
3.4.3效果展示
3.5电脑下棋
3.5.1函数调用
3.5.2函数体实现
3.5.3效果展示
3.6判断输赢
3.6.1函数调用
3.6.2函数体实现
3.6.3效果展示
3.7游戏逻辑（主函数）
四、代码
4.1game.h(函数声明)
4.2game.c(函数体实现)
4.3main.c(函数逻辑)
END.
一、三子棋玩法 三子棋相信大家都不陌生，是一款非常好玩的益智游戏。
游戏规则是：谁先将三颗棋子连成一条线，谁就获胜
二、需要实现的游戏功能 1.需要有一个棋盘下棋
2.玩家能下棋，电脑能自动下棋
3.能判断输赢
三、拆分代码 这次的代码使用game.h(函数声明)game.c(函数体实现)main.c(游戏逻辑实现)
三子棋其实，用的是一个3*3的格子，我们可以用二维数组来实现 其中的行（row）和列（col）使用宏定义，这样我们修改棋盘大小时会很方便，只需要改这两个值即可。
3.1游戏菜单 用printf实现
3.2初始化棋盘 3.2.1函数调用 将数组，行和列传过去
3.2.2函数体实现 3.3打印棋盘 3.3.1函数调用 3.3.2函数体实现 使用for循环实现
3.4玩家下棋 3.4.1函数调用 3.4.2函数体实现 3.4.3效果展示 3.5电脑下棋 3.5.1函数调用 3.5.2函数体实现 猜数字游戏http://t.csdn.cn/NtRT7
3.5.3效果展示 3.6判断输赢 3.6.1函数调用 游戏无非就是这4种情况
3.6.2函数体实现 判断是否为平局的函数
3.6.3效果展示 3.7游戏逻辑（主函数） 主函数逻辑
游戏逻辑 四、代码 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fef037c80c386e93fda80ca893c15a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b087477605bce9fad7df6b251a12bfe/" rel="bookmark">
			FlinkCDC从Mongodb同步数据至elasticsearch（ES) 新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FlinkCDC从Mongodb同步数据至elasticsearch（ES） 一、 DataStreamingAPI方式pom.xml 二、主程序-配置三、主程序四、其他问题 一、 DataStreamingAPI方式 网上挺多flinksql方式同步数据，但是遇到数据比较杂乱，会经常无缘无故报错，笔者被逼无奈，采用API方式处理数据后同步，不知为何API资料笔者找到的资料很少，还很不全，摸着石头过河总算完成任务，收获颇丰，以此分享给大家。
pom.xml &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cece&lt;/groupId&gt; &lt;artifactId&gt;Mongo-ES&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt; &lt;flink.version&gt;1.13.0&lt;/flink.version&gt; &lt;scala.binary.version&gt;2.12&lt;/scala.binary.version&gt; &lt;scala.version&gt;2.12&lt;/scala.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-java&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_2.12&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_2.12&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-java-bridge_2.12&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner-blink_${scala.binary.version}&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-json&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-elasticsearch7_2.11&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b087477605bce9fad7df6b251a12bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23fa6788cb12360a5de19b708c9d68c9/" rel="bookmark">
			CentOS7 安装GCC 11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考文档1
参考文档2
CentOS7 默认的GCC版本为4.8.5
先卸载以前的旧版本 yum remove gcc yum remove gdb 验证卸载 gcc -v g++ -v gdb 执行这三个命令都会报错 执行如下命令 sudo yum install scl-utils sudo yum install centos-release-scl 查看 SCL 软件源下提供哪些软件集 yum list all --enablerepo='centos-sclo-rh' | grep "devtoolset" 安装需要的工具链（如果需要安装gcc 11，就下devtoolset-11-toolchain
；如果需要安装gcc10，就下devtoolset-10-toolchain；gcc 9、gcc 8等以此类推） # 直接下载开发的工具链，它会自动把 gcc, gcc-c++, make, gdb 等依赖也都完整下载下来 sudo yum install -y devtoolset-11-toolchain 启用高版本 gcc # 启用对应版本的工具链 sudo scl enable devtoolset-8 bash # 查看版本信息 gcc –v 配置环境变量,在/etc/profile文件末尾添加如下的代码 PATH=$PATH::/opt/rh/devtoolset-11/root/usr/bin export PATH sudo scl enable devtoolset-11 bash 验证 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b756caea2b17d97b9f0331a8dbdf1000/" rel="bookmark">
			【课设/毕业设计】电力系统潮流计算（Matlab代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓个人主页：研学社的博客 💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
🎉3 参考文献
🌈4 Matlab代码实现
💥1 概述 潮流计算是电力系统分析中的一种最基本的计算，对给定系统进行潮流计算可以得到各母线上的电压、网络中的功率分布及功率损耗等。本文介绍了潮流计算在电力系统分析中的作用及潮流计算的发展状况。通过对潮流计算所用的数学模型进行分析，建立潮流计算的基本方程。牛顿-拉夫逊法是目前广泛应用的一种潮流计算方法，本文阐述了牛顿-拉夫逊潮流计算的基本原理。详细展示了利用matlab平台编写潮流计算程序的具体过程，通过实例证明基于牛顿-拉夫逊法的潮流计算程序具有收敛速度快、占用内存小的优点。
文章结构：
第一章 潮流计算的基本概念 1.1 潮流计算的概述 1.2 潮流计算的发展状况 第二章 潮流计算的程序实现手段 2.1 复杂电力系统潮流计算的数学模型 2.2 牛顿-拉夫逊法潮流计算 2.3 初始数据的输入 2.4 变压器π型等效 2.5 节点导纳矩阵的形成 2.6 功率不平衡量的计算 2.7 雅可比矩阵的计算 2.8 求解节点电压修正量 2.9 迭代过程 2.10 平衡节点及各支路功率计算 2.11 实例计算 总结 参考文献 📚2 运行结果 初始条件：
各节点有功：
-1.2500 -0.9000 -1.0000 0 0 0 1.6300 0.8500 0
各节点无功：
-0.5000 -0.3000 -0.3500 0 0 0 0 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b756caea2b17d97b9f0331a8dbdf1000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fec4ab34e970823e87a8150377a00b/" rel="bookmark">
			全局变量与局部变量有差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全局变量可以给默认值，如Integer的默认值为0，但在局部变量中默认值不是0，也不可以给默认值;当全局与局部变量名相同时，在方法中会与局部变量的值优先
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4159a3696f8b74e30da3df4457599df/" rel="bookmark">
			正则验证大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近居家办公，用到正则验证，闲来无事，收集整理一份正则大全，以备不时之需！
用的时候记得这样写/^[0-9]+(.[0-9]{2})?$/(用2条反斜杠包起来啦
一、校验数字的表达式 1 数字^[0-9]*$
2 n位的数字^d{n}$
3 至少n位的数字^d{n,}$
4 m-n位的数字^d{m,n}$
5 零和非零开头的数字^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数^(-)?d+(.d{1,2})?$
8 正数、负数、和小数^(-|+)?d+(.d+)?$
9 有两位小数的正实数^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数^[1-9]d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$
12 非零的负整数^-[1-9][]0-9"*$ 或 ^-[1-9]d*$
13 非负整数^d+$ 或 ^[1-9]d*|0$
14 非正整数^-[1-9]d*|0$ 或 ^((-d+)|(0+))$
15 非负浮点数^d+(.d+)?$ 或 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$
16 非正浮点数^((-d+(.d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$
17 正浮点数^[1-9]d*.d*|0.d*[1-9]d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数^-([1-9]d*.d*|0.d*[1-9]d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数^(-?d+)(.d+)?$ 或 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$
二、校验字符的表达式 1 汉字^[一-龥]{0,}$
2 英文和数字^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符^.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4159a3696f8b74e30da3df4457599df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07ee4171d48982c84cc2f37318a802d/" rel="bookmark">
			Hyper-v系列---【windows系统如何开启Hyper-v？】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 windows系统如何开启Hyper-v？ 1.确认虚拟技术开关是否开启？ 这里可以看到，我的电脑虚拟技术默认是开启的，如果没有开启，在bios中开启intel virtualization technology选项。
2.在放大镜中搜索：程序和功能，找到"启动或关闭Windows功能"选项。 3.开启Hyper-v，确定，并重启电脑。 4.重启完毕后，点击"Hyper-v管理器"。 5.如下图，Hyper-v就开启成功了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a9c3ccbdc9ffc7cce709608afc5427/" rel="bookmark">
			C语言学习记录（十五）C预处理器和C库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、C预处理器1.1 翻译程序1.2 明示常量：#define1.3 在#define中使用参数1.4 文件包含：#include1.5 其他指令1.5.1 #undef指令1.5.2 从C预处理角度看已定义1.5.3 条件编译1.5.3.1 #ifdef、#else和#endif指令1.5.3.2 #ifndef1.5.3.3 #if和elif指令 二、C库2.1 数学库2.2 断言库 一、C预处理器 C预处理器在程序执行之前查看程序（故称为预处理器）。根据程序中的预处理指令，预处理把符号缩写替换成其他的内容。
1.1 翻译程序 在预处理之前，编译器必须对该程序进行一些翻译处理。首先，编译器把源代码中出现的字符映射到源字符集。该处理过程处理多字节和三字符序列。
第二，编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。
第三，编译器把文本划分成预处理记号序列、空白序列和注释序列（记号是由空格、制表符或换行符分隔的项）。编译器将用一个空格字符替换每一条注释。
1.2 明示常量：#define #define预处理指令和其他预处理指令一样，以#号作为一行的开始。ANSI和后来的标准都允许#号前面有空格或制表符，而且还允许在#和指令的其余部分之间有空格。但是旧版本的C要求指令从一行的最左边开始，而且#和指令其余部分不能有空格。指令可以出现在源文件的任何地方。其定义从指令出现的地方到该文件的末尾有效。我们大量使用#define指令来定义明示常量（也叫符号常量）。但是该指令还有其他用途。下面举例说明。
#include &lt;stdio.h&gt; #define TWO 2 /* 可以使用注释 */ #define OW "Consistency is the last refuge of the unimagina\ tive. - Oscar Wilde" // 反斜杠把该定义延续到下一行 #define FOUR TWO*TWO #define PX printf("X is %d.\n", x) #define FMT "X is %d.\n" int main() { int x = TWO; PX; x = FOUR; printf(FMT, x); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a9c3ccbdc9ffc7cce709608afc5427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598a513e3dc0e23d5c2914b46a46086d/" rel="bookmark">
			特征值和特征向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征值和特征向量 定义求解相关定理矩阵对角化 定义 找到向量 x ⃗ \vec{x} x 使得，
A x = λ x \bf Ax=\lambda x Ax=λx
则称 x ⃗ \vec{x} x 为矩阵A的特征向量， λ \lambda λ为特征值。
上式表明矩阵A作用与 x ⃗ \vec{x} x 不改变其方向，只改变其大小。
求解 ( A − λ I ) x = 0 (\bf A-\lambda I)x=0 (A−λI)x=0
有非零解，则 d e t ( A − λ I ) = 0 det(\bold{A}-\lambda \bold{I})=0 det(A−λI)=0。
求解 λ \lambda λ,将 λ \lambda λ带入上式方程求解特征向量 x ⃗ \vec{x} x 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598a513e3dc0e23d5c2914b46a46086d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d29ff15de9377e67f44556ee9bac954/" rel="bookmark">
			[转]Untiy部署至WebGL平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Untiy部署至WebGL平台 一.Webgl发布空项目 1.打包发布webglbuild设置 1) AddScene2) platform转换为webgl3) playersettings2.打包完成 1) 选择打包路径2) webgl包结构二.Nginx服务器部署 1.安装nginx2.nginx.exe启动3.配置nginx.conf 1) 了解需要配置的内容2) 找到所有端口3) 查询某端口是否被占用4) 查询本地ip5) 开始配置nginx.conf3.重启nginx 服务器 1) 进入nginx.exe安装路径2) nginx服务器重启4.常见的nginx命令三.浏览器验证webgl部署是否成功 1.浏览器输入url2. webgl平台运行成功 一.Webgl发布空项目 我们打开Untiy编辑器新建一个场景, 里面拖一个Cube然后保存场景命名为Sample
1.打包发布webglbuild设置 1) AddScene file-&gt;buildsettings -&gt; 将Sample场景拖进去
2) platform转换为webgl file-&gt;buildsettings -&gt;platform 选择webgl 注意development build不要勾选
3) playersettings 几乎默认 改一下resolution and pressentation -&gt; resolution -&gt; width 和height; publishsettings -&gt; enable exceptions -&gt;none;publishsettings -&gt; compression format-&gt;gzip;DataCaching勾选
2.打包完成 1) 选择打包路径 点击Build选择打包路径开始打包,发布webgl的时间有点长,耐心等待
2) webgl包结构 打包完成文件夹如下
二.Nginx服务器部署 下载地址:nginx: download
1.安装nginx 解压即安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d29ff15de9377e67f44556ee9bac954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c753aacdf7a7f20fe652b8ad248107ab/" rel="bookmark">
			思迅软件收银系统E店通10数据库无缝迁移导入到Eshop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思迅的E店通10，销售流水迁移至Eshop10的语句。
declare m_cursor cursor scroll for select a.com_no from eStore10_xyj..t_rm_saleflow a left join ESXYJLSCS..t_rm_saleflow b on a.flow_no =b.flow_no and a.flow_id =b.flow_id where b.flow_no is null open m_cursor declare @com_no int fetch next from m_cursor into @com_no while @@FETCH_STATUS=0 begin INSERT INTO [ESXYJLSCS].[dbo].t_rm_saleflow ([flow_no] ,[flow_id] ,[branch_no] ,[item_no] ,[sale_qnty] ,[source_price] ,[sale_price] ,[discount] ,[sale_money] ,[sell_way] ,[oper_id] ,[sale_man] ,[sale_rate] ,[oper_date] ,[shift_no] ,[item_flag] ,[spec_flag] ,[pref_amt] ,[vip_price] ,[in_price] ,[cost_price] ,[acc_num] ,[dec_rate] ,[card_id] ,[card_no] ,[pro_id] ,[com_flag] ,[memo] ,[plan_no] ,[item_sn] ,[vip_acc] ,[item_barcode] ,[produce_date] ,[valid_date] ,[item_rate] ,[cls_rate] ,[brand_rate] ,[dpfm_type] ,[irate_branch] ,[brate_branch] ,[crate_branch] ,[giftcert_no] ,[kz_flag] ,[update_date] ,[record_no] ,[weight_num] ,[real_shift_no] ,[shift_date] ,[share_cardid]) select A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c753aacdf7a7f20fe652b8ad248107ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bff69e28f94475ce00ab7b091ab2d23/" rel="bookmark">
			FFmpeg - Android 直播推拉流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 搭建自己的流媒体服务器 首先登录自己的云主机，下载解压 nginx 和 rtmp
sudo wget https://github.com/nginx/nginx/archive/release-1.17.1.tar.gz sudo wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gz sudo tar -zxvf release-1.17.1.tar.gz sudo tar -zxvf v1.2.1.tar.gz 然后编译安装nginx和rtmp
./auto/configure --add-module=/lib/nginx/nginx-rtmp-module-1.2.1 make make install 最后配置测试流媒体服务器
cd /usr/local/nginx/sbin/ ./nginx .\ffmpeg.exe -re -i 01.mp4 -vcodec libx264 -acodec aac -f flv rtmp://148.70.96.230/myapp/mystream 2. 集成 RTMP 推流的源码 当我们的流媒体服务器搭建好后，要用 ffmpeg 测试一下，确保流媒体服务器搭建成功后，我们再来集成 RTMP 推流的源码。
git clone git://git.ffmpeg.org/rtmpdump set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DNO_CRYPTO") /** * 初始化连接流媒体服务器 */ void *initConnectFun(void *context) { DZLivePush *pLivePush = (DZLivePush *) context; // 创建 RTMP pLivePush-&gt;pRtmp = RTMP_Alloc(); // 初始化 RTMP RTMP_Init(pLivePush-&gt;pRtmp); // 设置连接超时 pLivePush-&gt;pRtmp-&gt;Link.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bff69e28f94475ce00ab7b091ab2d23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d749601159eef3291790173c147f5c1/" rel="bookmark">
			finetune一个GPT3模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过程其实挺简单的，首先得注册一个账号获取token(我是叫在美国的朋友注册了一个)。注册好账号后，有18美金的试用额度，基本可以完成好几次模型训练了。除了模型训练需要收费之外，大概1000个token的费用是0.02美金。
设置好OPENAI_API_KEY这个环境变量。
export OPENAI_API_KEY="&lt;OPENAI_API_KEY&gt;"
接下来就进入正题了，
1. 准备数据，格式如下，每一行都是一个json，换行用\n表示，我finetune的task只需要1000条左右的数据，模型结果还不错，根据训练时的提示，至少需要100条，越多越好
{"prompt": "&lt;prompt text&gt;", "completion": "&lt;ideal generated text&gt;"} {"prompt": "&lt;prompt text&gt;", "completion": "&lt;ideal generated text&gt;"} {"prompt": "&lt;prompt text&gt;", "completion": "&lt;ideal generated text&gt;"} ... openai提供了现成的命令可以转csv成json: openai tools fine_tunes.prepare_data -f ./train_data.csv
2. 训练，我finetune的是davinci模型，还有三四个选择，输错命令行会提示。我的task只finetune了一个周期，整个过程大概花费1美金，持续约5～10分钟
openai api fine_tunes.create -t ./train_data_prepared.jsonl -m davinci --n_epochs 1
不需要的模型还可以删除
openai api models.delete -i "davinci:ft-personal-2022-11-20-03-40-02" 用如下命令可以列出曾经训练的模型列表
openai api fine_tunes.list 3. api调用，有好几种方法，比如直接
openai api completions.create -m davinci:ft-personal-2022-11-20-04-05-47 -p "Beautiful sunset beach landscape with a boat"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d749601159eef3291790173c147f5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6af93ea60bd5c6d632be06b9ea9181/" rel="bookmark">
			JS获取上周（自然周、最近七天）、上月（自然月、最近一个月）、全年的开始和结束日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS获取上周（自然周、最近七天）、上月（自然月、最近一个月）、全年的开始和结束日期 let now = new Date(); let nowTime = now.getTime(); //当前的时间戳 let nowYear = now.getFullYear(); //当前年 let weekDay = now.getDay(); //当前星期 let lastMonth = now.getMonth(); //上一个月 let oneDayTime = 24 * 3600* 1000; //一天的总毫秒数 let start = ""; //开始日期 let end = ""; //结束日期 let myDate = [] //最终需要的日期数组 [开始，结束] // 1. 上周（最近七天） let week = nowTime - oneDayTime * 7; // oneDayTime * 7 代表一周的总毫秒（ms）数 start = now.setTime(week); end = new Date(); myDate = [formatDate(start), formatDate(end)]; //console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6af93ea60bd5c6d632be06b9ea9181/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ad8dae7225eadf499f399b1626698b/" rel="bookmark">
			Mybatis的缓存机制 ----全网最详解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是一级缓存？
二、一级缓存什么时候会失效？
三、什么是二级缓存？
Mybatis框架内置了一级缓存机制与二级缓存机制。
一、什么是一级缓存？ Mybatis框架的一级缓存又称之为会话（Session）缓存，默认是开启的，且无法关闭！
一级缓存必须满足：同一个SqlSession、同一个Mapper对象、执行相同的查询、且参数相同！
下面我们进行测试：
@Slf4j @SpringBootTest public class MybatisCacheTests { @Autowired SqlSessionFactory sqlSessionFactory; @Test void testL1Cache() { SqlSession sqlSession = sqlSessionFactory.openSession(); BrandMapper brandMapper = sqlSession.getMapper(BrandMapper.class); Long id = 1L; log.debug("开始执行第1次【id={}】的查询……", id); BrandStandardVO result1 = brandMapper.getStandardById(id); log.debug("第1次的查询结果：{}", result1); log.debug("第1次的查询结果的hashCode：{}", result1.hashCode()); // sqlSession.clearCache(); // log.debug("已经调用clearCache()方法清除缓存！"); log.debug("开始执行第2次【id={}】的查询……", id); BrandStandardVO result2 = brandMapper.getStandardById(id); log.debug("第2次的查询结果：{}", result2); log.debug("第2次的查询结果的hashCode：{}", result2.hashCode()); } } 测试结果：
通过测试并观察日志，可以看到，第1次执行查询，但是，第2次并没有真正的执行查询，并且，2次查询结果的hashCode值是完全相同的！
也就是说：Mybatis只执行了第1次的查询，当执行第2次的代码时，并没有真正连接到MySQL数据库执行查询，而是将第1次的查询结果直接返回了！也可以说：Mybatis在第1次查询后，就把查询结果缓存下来了！
二、一级缓存什么时候会失效？ 一级缓存会因为以下任一原因消失：
调用`SqlSession`对象的`clearCache()`方法，将清空缓存当前执行了任何写操作（增/删/改），无论任何数据有没有发生变化，都会清空缓存 我们去除上面代码的注释符，及执行 sqlSession.clearCache();方法
查看测试结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ad8dae7225eadf499f399b1626698b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92c592a4630c59a683f77edffaf8350/" rel="bookmark">
			【linux】物理磁盘挂载目录——(分区、格式化、重启自动挂载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是好学的小师弟！
现有一全新的物理磁盘需要挂载到某个目录下，操作步骤如下。 目录
一、磁盘分区
二、磁盘格式化
三、磁盘挂载
四、重启自动挂载
注意点:
1.该目录要存在，不存在的话需手动mkdir创建
2.该目录需要为空白的空目录，若该目录下原来有内容的，那么原来的文件内容将被覆盖掉
一、磁盘分区 1.磁盘需要先分区，就算是一块磁盘全部容量给目录挂载，也是需要先进行分区的
根据磁盘大小来选择相应的命令，若一块磁盘大于2T，则用parted命令进行分区；若一块磁盘小于等于2T，则用fdisk 来分区
fdisk -l #先用上面的命令，来查看你需要挂载的磁盘容量大小 这里可以看到，我们的磁盘容量是小于2T的，所以我们就使用fdisk命令就行了
fdisk /dev/sdf #使用上面的命令进行分区，后面的路径是你所需要进行分区的磁盘路径 使用命令后，会看到下图。第一步，选择n，创建分区；第二步，选择p，创建主分区
如果你是想把这块磁盘容量全部给一个目录用，做完这两步后，就可以一直按回车键盘(按到打印出来的内容都是重复的就可以停止了)，然后输入w，退出分区操作
如果你是想创建多个分区，那么在做完上面的两步后，他会显示一个partition number(1-4)：让你选择哪个分区号(1就是第一块分区，2就是第二块分区...)，一般可以创建4个主分区。我们一般都是按照顺序来的，这里我们选择1。
注意:选择好分区号以后，下面会有两个需要你输入的地方，分区的起始处和增加的大小。这里我们只需要填写增加的大小就完事了，起始处直接按回车键就行了，就按1次，不要多按。
增加的大小，按照实际需求增加 模板: +数字大小(M、G、T单位)
完整操作步骤
二、磁盘格式化 mkfs.xfs -f /dev/sdc1 #这边我选择的文件系统格式是xfs格式，-f是强制性覆盖 #如果你有两个分区，那就再来一个mkfs.xfs -f /dev/sdc2 就完事了 三、磁盘挂载 mount /dev/sdc1 /data01 #/data01为已存在的空目录 四、重启自动挂载 先df -T 查看磁盘的格式，看看是不是xfs的
第二步，去配置文件里面添加路径和挂载目录；按照文件里面以有的内容，照着填写就完事了。填写完，保存退出即可
vim /etc/fstab #去这里面添加磁盘路径和挂载目录即可 新人创作不易，觉得不错的看官，点个赞吧，么么哒！！！
转载注明出处！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612c70b45ce326bc254fe7c01e5ae060/" rel="bookmark">
			ROS-Unity连接教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要介绍基于ROS-TCP-Connector、ROS-TCP-Endpoint两个Unity接口与ROS进行通信的环境配置，并对官方给出的Unity和ROS相互通信示例中的消息部分做了说明
一、环境配置 参考：Unity-Robotics-Hub/setup.md at main · Unity-Technologies/Unity-Robotics-Hub (github.com)
Ununtu环境下
1.成功配置ros环境 2.下载ROS-TCP-Endpoint放在工作空间编译 ROS-TCP-Endpoint下载地址：Unity-Technologies/ROS-TCP-Endpoint: ROS package used to create an endpoint to accept ROS messages sent from a Unity scene using the ROS TCP Connector scripts (github.com)
Unity环境下
1.创建新项目，在Window/Package Manager下导入两个包(方式有两个，本地导入和URL导入) URL导入：
两个包：
https://github.com/Unity-Technologies/ROS-TCP-Connector.git?path=/com.unity.robotics.ros-tcp-connector https://github.com/Unity-Technologies/ROS-TCP-Connector.git?path=/com.unity.robotics.visualizations 导入成功结果如下：
因为URL是在线下载，可能会连接失败(但我多试了几次也成功了)。选择本地的方式也可以，把整个包下载到本地，然后选择这两个com包：
下载上面画的这两个，然后路径选择本地磁盘，点击之后，导入com文件夹下的package.json即可：
这个时候发现Unity上多了一个选项：
点击Robotics下面的ROS Settings进行配置，主要是两个ROS IP Address和ROS Port，关于ROS IP Address在ubuntu下用ifconfig查一下设置，然后端口任意了默认10000了
到目前为止，两方的环境配置就结束了。
二、demo环境配置 Ubuntu环境
下载这两个到同一个工作空间，然后catkin_make一下
下载路径：Unity-Robotics-Hub/tutorials/ros_unity_integration/ros_packages at main · Unity-Technologies/Unity-Robotics-Hub (github.com)
Unity环境下
点击“Robotics -&gt; Generate ROS Messages…”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612c70b45ce326bc254fe7c01e5ae060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803babeecd9fe7287feca2b56d69e210/" rel="bookmark">
			【精】简单 就一个类 ---使用MyBatis Generator自动生成代码(com.baomidou.mybatisplus)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用MyBatis Generator自动生成代码，网上搜了一堆 都不靠谱，一点不简洁。
mybatis-plus代码生成器及配置 - BlogMemory - 博客园
所以我这边写了个简单的，就一个基础类搞定，其中有很多注释，你可以自定义选择需要一些特殊的配置（本来写好的项目 ，而且里面有很多集成的mybatis使用方式来着，结果一下让我给删了，而且找不回来了也。。。我就懒得重新写个项目了 ，心累啊！）
baseMapper 是mybatisplus 自带的写法
基础工具类
package com.baba.springcloud.pament.util; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert; import com.baomidou.mybatisplus.generator.config.querys.MySqlQuery; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.keywords.MySqlKeyWordsHandler; // 代码自动生成器 public class Generator1 { // 数据库连接字段配置 private static final String JDBC_URL = "jdbc:mysql://xxx/xxx?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true"; private static final String JDBC_USER_NAME = "xx"; private static final String JDBC_PASSWORD = "xxx"; // 包名和模块名 private static final String PACKAGE_NAME = "com.baba.springcloud.pament.util"; private static final String MODULE_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/803babeecd9fe7287feca2b56d69e210/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d03f15c9832ded9ba85cb731e89945/" rel="bookmark">
			【halcon每日一练】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 判断空图像 gen_empty_obj (TestEmptyObject1) *创建一个不为空的图像 gen_rectangle1 (Rectangle, 30, 20, 100, 200) region_to_bin (Rectangle, TestImage, 255, 0, 512, 512) *方式一：与参考空对象比较是否为空 ************************************测试图像为空***************************** if(TestEmptyObject1==RefEmptyObject) dev_get_window (WindowHandle) disp_message (WindowHandle, '空对象', 'window', 20, 20, 'black', 'true') else threshold (TestEmptyObject1, Region, 128, 255) endif ************************************测试图像不为空***************************** if(TestImage==RefEmptyObject) dev_get_window (WindowHandle) disp_message (WindowHandle, '空对象', 'window', 20, 20, 'black', 'true') else threshold (TestImage, Region, 128, 255) endif *方式二：利用算子比较类似于上述操作符比较 test_equal_obj (TestEmptyObject1, RefEmptyObject, IsEqual) test_equal_obj (TestImage, RefEmptyObject, IsEqual1) if(IsEqual1==1) dev_get_window (WindowHandle) disp_message (WindowHandle, '空对象', 'window', 20, 20, 'black', 'true') else threshold (TestImage, Region, 128, 255) endif *方式三：取对象灰度值判断是否为空 get_grayval (TestEmptyObject1, 0, 0, Grayval) if(Grayval==[]) disp_message (WindowHandle, '空对象', 'window', 20, 20, 'black', 'true') endif 判断空区域 *判断是否为空对象的方法--image，region，xld ***************************************************************************** ********************************区域判断是否为空****************************** ***************************************************************************** gen_empty_region (RefEmptyregion) gen_empty_region (TestEmptyregion) gen_rectangle1 (Rectangle, 30, 20, 100, 200) *方式一：操作符判断 if(TestEmptyregion==RefEmptyregion) dev_get_window (WindowHandle) disp_message (WindowHandle, '空对象', 'window', 20, 20, 'black', 'true') else *do something() endif *方式二：操作符判断 test_equal_obj (TestEmptyregion, RefEmptyregion, IsEqual) test_equal_obj (Rectangle, RefEmptyregion, IsEqual1) *方式三：计算regin面积判断是否为0 area_center (TestEmptyregion, Area, Row, Column) area_center (Rectangle, Area1, Row1, Column1) 判断空XLD *判断是否为空对象的方法--image，region，xld ***************************************************************************** ********************************XLD判断是否为空****************************** ***************************************************************************** gen_empty_obj (EmptyObject) gen_empty_region (EmptyRegion) gen_contour_region_xld (EmptyRegion, EmptyContour, 'border') dev_get_window (WindowHandle) draw_xld (ContOut,WindowHandle , 'true', 'true', 'true', 'true') *方式一：操作符判断 if(EmptyContour==EmptyObject) dev_get_window (WindowHandle) disp_message (WindowHandle, '空对象', 'window', 20, 20, 'black', 'true') else *do something() endif *方式二：操作符判断 test_equal_obj (EmptyContour, EmptyObject, IsEqual) test_equal_obj (ContOut, EmptyObject, IsEqual1) *方式三：计算轮廓长度 length_xld (EmptyContour, Length) length_xld (ContOut, Length1) tuple_length (Length, Vaule) tuple_length (Length1, Vaule1) 判断数组空 ***************************************************************************** ********************************Tuple判断是否为空****************************** ***************************************************************************** EmptyTuple:=[] TestTuple:=[1,2,3] TestTuple1:=['a','b'] *方式一：判断数组长度 tuple_length (EmptyTuple, Length) tuple_length (TestTuple, Length1) tuple_length (TestTuple1, Length2) *方式二：算子判断 tuple_is_number (EmptyTuple, IsNumber) tuple_is_number (TestTuple, IsNumber1) tuple_is_number (TestTuple1, IsNumber2) if(|IsNumber|==0) *数组为空 endif 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb443e904f63ee601f8a5ecd95933266/" rel="bookmark">
			Java 内存溢出（二）使用 MAT 分析 .hprof 内存映像文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、内存溢出时自动导出 .hprof 文件二、下载安装 MAT三、启动 MAT四、MAT 分析 hprof 文件1.Overview 概览2.Leak Suspects 溢出原因猜测3.Histogram 对象实例数量排序4.Dominator Tree 支配树 .hprof 文件： 是 java 项目的 Heap Dump 文件，也叫内存映像文件、内存快照文件，可以存放一个 java 进程在某个时间点的内存快照。生成 Heap Dump 文件的方式有两种：一是使用 jmap 命令手动导出，二是启动脚本中添加 -XX:+HeapDumpOnOutOfMemoryError 参数自动导出。本文中只涉及第二种。
一、内存溢出时自动导出 .hprof 文件 1.新建一个文本文件，命名为 HeapOOM.java，内容如下：
import java.util.ArrayList; import java.util.List; public class HeapOOM { static class User {} public static void main(String[] args) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); while (true) { list.add(new User()); } } } 2.打开控制台，执行如下命令编译 java 文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb443e904f63ee601f8a5ecd95933266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10fa1a26b6ec532baa282f4a22ff40c7/" rel="bookmark">
			简述供应商管理SRM系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简道云SRM管理系统 供应商关系管理(SRM系统)，是企业可以用来对供应商的优势和能力进行系统的、全行业范围的评估，涉及企业整体的商业战略，供应商寻源、采购审批、比价、招投标管理、订单执行、库存可视化管理、财务支付审批对账、供应商绩效评估、质量协同、供应商全生命周期管理以及风险管控等。通过SRM系统交互与战略供应伙伴发展双向、互利的关系，实现更高水平的创新和竞争优势最大化。
官网：http://s.fanruan.com/d6tgb
SRM系统目标—交互价值最大化。 在具体的采购端实践中，企业通过SRM系统与关键的供应商建立更紧密、更协作的关系，以帮助企业识别采购流程中的降本机会、创造更多价值、防止价值漏损，还可以极大地减少交易性采购所需的时间。
SRM与CRM相似的地方在于二者都是企业与供应商或者客户之间，通过系统进行及时的，多样性的互动。企业与供应商的互动——合同谈判、物流管理、交付、采购执行设计等。我们对SRM进行定义的出发点是认识到企业与供应商之间的各种互动，不是离散的，不是独立的。相反，它是采购过程中的有机组成部分，这种关系可以并且应该在企业实际采购应用场景中和业务单元接触点之间以协调的方式进行管理，并且贯穿整个关系的生命周期。
SRM的组件 组织结构 虽然在组织级别上没有一个正确的部署SRM的模型，但是有一组结构元素在大多数情况下是相关的:
公司级的正式SRM团队或办公室。这样一个小组的目的是促进和协调跨功能和业务单元的SRM活动。SRM本质上是跨职能的，需要商业、技术和人际交往能力的良好结合。这些围绕沟通、倾听、影响和管理变革的软技能，对于发展强大和信任的工作关系至关重要。
正式的关系经理或供应商客户经理角色。这些个人通常位于与供应商交互最频繁的业务单元中，或者由采购功能中的类别经理负责。这个角色可以是一个全职的，专门的职位，尽管关系管理的责任可能是更广泛的角色的一部分，取决于供应商关系的复杂性和重要性(见供应商细分)。SRM经理理解他们的供应商的业务和战略目标，并且能够从供应商的角度来看待问题，同时平衡他们自己的组织的需求和优先级。
管控 SRM办公室和供应链功能通常负责定义SRM治理模型，其中包括针对一些顶级战略供应商的清晰和共同同意的治理框架。有效的治理应该不仅包括在客户和供应商中指定高级执行发起人和专门的关系经理，而且还包括一个面对面的模式，将工程、采购、运营、质量和物流人员与他们的供应商对等方联系起来;定期举行行动和战略规划及检讨会议;以及定义良好的升级程序，以确保在适当的组织级别迅速解决问题或冲突
有效的供应商关系管理需要对与每个供应商进行什么活动的企业范围内的分析。实施一刀切的方法来管理供应商的常见做法可以拉伸资源，限制从战略供应商关系中获得的潜在价值与之相反，供应商细分是关于决定与不同供应商进行何种交互，以及如何最好地管理这些交互，而不仅仅是作为一组孤立的事务，而是以一种跨企业的协调方式供应商可以被细分，不仅仅是通过支出，还可以通过与他们的互动实现的总潜在价值(跨多个维度[9]衡量)。此外，供应商可以被风险的程度，其实现的价值是服从。
在实践中，SRM扩大了与主要供应商的互动范围，超越了传统的买卖交易，包括其他基于转变的联合活动。
更有纪律和系统的，经常扩大的信息共享
联合需求预测和流程再造(为领导组织节省了10- 30%的成本)
技术和系统 据说有无数的技术解决方案可以实现SRM。这些系统可用于收集和跟踪跨站点、业务单元和/或区域的供应商绩效数据。这样做的好处是对供应商绩效有一个更全面和客观的了解，可以用来做出更好的采购决策，以及识别和解决系统性的供应商绩效问题。值得注意的是，SRM软件虽然有价值，但不能在缺少其他业务结构和流程更改的情况下实现，这些更改被建议作为SRM实现策略的一部分。
SRM和供应商绩效管理 供应商绩效管理(SPM)和SRM之间的差异可能存在一些混淆。SPM是SRM的一个子集。表达SPM和SRM之间区别的一个简单方法是，前者是关于确保供应商交付合同中承诺的内容，这意味着一个狭窄的、单向的过程。相比之下，SRM是关于协作驱动双方的价值，从而降低成本、降低风险、提高效率、提高质量和获得创新这需要在整个实施过程中专注于合同谈判和管理产生的关系，以及系统的共同价值发现工作
实现 实施SRM计划有五个关键步骤:
为SRM计划设定目标根据目标衡量供应商的绩效与供应商接触，保持透明，保持一致协作和持续改进 互联时代的SRM更注重业务的协同性和自主性，更有利于构建起良性健康的采供关系，这里直接推荐一款协同型SRM系统。使用简道云SRM系统能够一键连接上下游，让外部组织共同参与到供应链的协作当中。帮助企业降低采购成本、提升供应商质量、把控采购质量、提升采购到货及时率、提升供应商管理效率，助力科学决策。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27db6b7e2e26964efd585c93e012b4a7/" rel="bookmark">
			牛客网——有序序列合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冲
目录
前言
一、有序序列合并
描述
输入描述：
输出描述：
总结
前言
迷宫般的城市，让人习惯看相同的景物， 走相同的路线，到同样的目的地；习惯让人的生活不再变。习让人有种莫名的安全感，却又有种莫名的寂寞。而你永远不知道，你的习惯会让你错过什么。（几米）
一、有序序列合并 描述 输入两个升序排列的序列，将两个序列合并为一个有序序列并输出。
数据范围： 1 \le n, m \le 1000 \1≤n,m≤1000 ， 序列中的值满足 0 \le val \le 30000 \0≤val≤30000 输入描述： 输入包含三行，
第一行包含两个正整数n, m，用空格分隔。n表示第二行第一个升序序列中数字的个数，m表示第三行第二个升序序列中数字的个数。
第二行包含n个整数，用空格分隔。
第三行包含m个整数，用空格分隔。
输出描述： 输出为一行，输出长度为n+m的升序序列，即长度为n的升序序列和长度为m的升序序列中的元素重新进行升序序列排列合并。
#include&lt;stdio.h&gt; int main(){ int n,m,max=0; scanf("%d %d\n",&amp;n,&amp;m); int arr[2000]; for(int i=0;i&lt;n;i++){ scanf("%d ",&amp;arr[i]); } for(int j=n;j&lt;n+m;j++){ scanf("%d ",&amp;arr[j]); } for(int t=0;t&lt;n+m;t++){ for(int w=t+1;w&lt;n+m;w++){ if(arr[t]&gt;arr[w]){ max=arr[t]; arr[t]=arr[w]; arr[w]=max; } } } for(int y=0;y&lt;n+m;y++){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27db6b7e2e26964efd585c93e012b4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60208092390e314148a247b7440af48/" rel="bookmark">
			牛客网——数位之和、金字塔图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写个题解
目录
描述
输入描述：
输出描述：
二、金字塔图案
描述
输入描述：
输出描述：
总结
前言
上一次觉得阳光这么温暖，是什么时候？好像就在昨天，又好像上辈子那么远，不要拒绝悲伤，只管去难过，去愤怒好了，忍不住眼泪，那就尽情的哭吧，而悲伤就像一条大河，或许会吞没你，但也能带你去梦想的远方。（《悲伤逆流成河》）
一、数位之和
描述 求一个整数的所有数位之和
输入描述： 输入一行，包含一个整数。
输出描述： 一个整数. int范围内
数位之和_牛客题霸_牛客网
#include&lt;stdio.h&gt; int main(){ int a,sum=0,b; scanf("%d",&amp;a); while(a&gt;0){ //除到0就停止了 b=a%10; //每次取个位 a=a/10; //然后小数点右移一位 sum=sum+b; //加起来 } printf("%d",sum); return 0; } 二、金字塔图案 描述 KiKi学习了循环，BoBo老师给他出了一系列打印图案的练习，该任务是打印用“*”组成的金字塔图案。
输入描述： 多组输入，一个整数（2~20），表示金字塔边的长度，即“*”的数量，，也表示输出行数。
输出描述： 针对每行输入，输出用“*”组成的金字塔，每个“*”后面有一个空格。
#include&lt;stdio.h&gt; int main(){ int n; while(scanf("%d",&amp;n)!=EOF){ //多组输入 int a=n; for(int i=1;i&lt;=n;i++,a--){ //确定空格数 for(int j=1;j&lt;=a-1;j++){ printf(" "); } for (int j = 1; j&lt;= i; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f60208092390e314148a247b7440af48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f41bf815b671c1bbe73c8d68363da64/" rel="bookmark">
			搞机攻略（Android Root &amp; iOS越狱）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【分享】搞机攻略
由于手机系统出厂时的用户权限较低，如果设置当中没有，很多想要的修改都做不了，但是我们又想折腾怎么办呢？
提高权限！
安卓系统是基于linux的，所以权限管理也是类似的，iOS虽然不是，但是也能类比。当前手机端的权限大致可以分为三类:
第三方软件权限：权限很低，使用时需要向用户申请访问权限 用户权限：例如可以设定锁屏密码、重启手机、卸载第三方软件等等 超级用户（root）权限：完全控制手机，去使用手机系统不对普通用户开放的功能，比如修改手机型号、卸载系统软件、甚至实现对硬件的控制（改调度，超频） 所以搞机的基础就是去获取root权限
数据无价，搞机前记得备份！
1.安卓
1.1 安卓的分区
Boot：放有启动和引导文件，包含操作系统的内核和虚拟内存，目前root的方式也是修改Boot分区，在改调度超频等操作时也是需要涉及Boot分区的
如果Boot分区被擦除或损坏手机就不能正常启动，会卡在开机的首个界面也就是LOGO上，请谨慎操作！
System：存放操作系统和预装软件等，系统升级或刷机通常都是在操作该分区
如果System分区被擦除或损坏就会卡在第二界面也就是开机动画上，请谨慎操作！
Data：存放用户数据的分区，擦除相当于清空所有软件数据
Cache：存放系统缓存，快速打开应用和访问数据
擦除上述两个分区并不会影响系统正常启动
Recovery：包含一个简易的Linux系统，用于恢复和维护手机。除了恢复还可以对其他分区进行擦除、重启等操作，所以在后续刷系统时经常在这里进行。
但是自安卓7.0以来，引入了新的OTA机制，A/B System Updates，出现了越来越多不存在Recovery的手机。这种升级方式将Boot System等分区分为两套，也就是常说的AB分区。
平时用的叫主分区，没在用的叫备用分区。进行OTA升级时就是将备用分区连接服务器升级，在后台升级完成后重启切换分区再开机，这样就做到了无缝切换，也可以预防升级失败导致系统不可用（因为系统重启无法启动就会又换回之前的分区启动）
但是显然两套分区会占用更多的空间，目前出厂搭载安卓11以上的机型普遍又采用了更新的技术Virtual A/B System Updates，让两代系统相同文件共用，不同文件存于虚拟A/B分区，以此解决空间占用问题
但是这对刷机来说都会造成困难，因为Recovery分区被并入了Boot分区中，想要刷入第三方的Recovery会比较麻烦，对后续的搞机路带来困难。（但小米12开始的骁龙8 gen1后的机型又将Recovery分区独立了出来）
所以更推荐使用fastboot进行刷机。
1.2 fastboot
在长按电源键开机的那一刻起，Bootloader就开始工作了，相当于电脑的BIOS，引导完系统内核可以选择进入一个fastboot阶段，这个时候可以连接电脑使用fastboot命令进行刷机，不论是解锁设备、注入镜像、线刷系统，很多操作都得通过fastboot进行。
Bootloader是根植于手机的，并不属于任何分区，如果你在搞机过程中把系统刷坏了，你永远可以试试能否进入fastboot救砖。
1.3 开始搞机
接下来用我的K50 ultra进行举例
首先第一步自然是进入开发者模式把USB调试打开方便连接电脑，MIUI可以通过连击7次版本号打开开发者模式，其他品牌手机操作步骤也都大同小异。
1.3.1 解锁Bootloader
大部分手机出厂时为了保证安全都会给Bootloader上锁，如果不解锁就没法修改分区，自然也没法root。要注意的的是解锁会清空手机数据，一定要记得备份！
先进入开发者模式打开OEM解锁功能，然后查看设备解锁状态，记住使用移动数据再点击绑定设备，且只点击一次，一般情况下需要等待7天才能解锁（也分情况，我的账号当时秒解了）
使用官方的手机解锁工具进行解锁，在这之前可以先检查一下驱动。
解锁完成后再开机，此时重启开机logo上就会出现一个小的锁打开的标志，说明成功了。完成开机引导后再次打开USB调试。
1.3.2 刷入TWRP
由于出厂的Recovery自带功能非常简单，也不允许我们乱刷东西，所以我们选择刷入第三方更好用的Recovery，其中最知名的就是TWRP，它集成了更多更好用的一键功能，可以刷内核、刷系统、备份数据等等。
K50 ultra存在Recovery分区，那么我们可以直接将第三方好用的TWRP刷入Recovery中。
我们进入fastboot模式（关机后按住下音量键和电源键），使用大神们制作的一键刷入脚本刷入，刷完后手机会自动进入TWRP（如果需要输入密码就是你的锁屏密码）。
1.3.3 刷入magisk
magisk是当前最火的root管理工具，它不仅可以获取root权限，还可以挂载各种模块，在实现功能的同时让系统分区毫发无伤。
进入TWRP可以轻松一键刷入magisk
重启系统进入桌面会多出来一个magisk应用，打开它，如果需要修复运行环境就按下图操作，注意图3文字。
成功root后就可以安装你想装的模块愉快搞机啦！
1.4 救砖
安卓刷机分为线刷和卡刷，具体的区别就是线刷需要连接电脑使用fastboot刷机，卡刷就是进入Recovery使用手机内存储的固件刷机。选取哪种方式取决于你当前变砖后能进入到哪个阶段，基本如果手头有电脑其实更推荐线刷，遇到的困难会少很多
小米有专门的线刷工具提供，只需要去官方下载对应型号的rom解压，选择好该文件夹后，使手机进入fastboot连接就可以一键刷了
2.iOS
iOS获取root权限的过程被称为越狱。而随着苹果安全策略的不断升级，能够利用来制作越狱工具的漏洞也越来越难以发现。同样的漏洞利用方式也越来越局限，自iOS9之后就没有完美越狱了（不完美越狱会导致重启后越狱失效）
而与安卓相比，越狱的操作就很简单了，因为大神们都给我们打包好了一键越狱工具，只需要去寻找符合你当前iOS版本和芯片型号的越狱工具就好了，下面我给出最近的一些系统对应的工具名称：
Checkra1n
iOS12.0 – iOS14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f41bf815b671c1bbe73c8d68363da64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ef57fa26b3fcbee556b3cdda96737b/" rel="bookmark">
			Vue中通过sort方法实现快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术：通过sort方法可以实现id ，价格 等等想要的快速排序方法。
&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;input type="text" placeholder="商品名称" v-model="queryInfor.name" /&gt; &lt;/div&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;编号 //v-if 就是当变量flag为true时创建改按钮为非true时删除 //然后绑定点击事件 &lt;button v-if="flag" @click="sortFun"&gt;升序&lt;/button&gt; &lt;button v-if="!flag" @click="sortFun"&gt;降序&lt;/button&gt; &lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for="(item, index) in lcList" :key="index"&gt; //循环遍历的数组 &lt;td&gt;{{ item.id }}&lt;/td&gt; &lt;td&gt;{{ item.goods_name }}&lt;/td&gt; &lt;td&gt;{{ item.price }}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import dates from "../../public/data"; //外部导入的数据 export default { components: {}, data() { return { lcList: {}, queryInfor: { //搜索框的变量 name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ef57fa26b3fcbee556b3cdda96737b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac82c22993c1b639b638b908910eb856/" rel="bookmark">
			Eoapi x OpenDLP 插件上线： 扫描 API 的敏感字段，让你的 API 更安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，开源 API 管理工具的 Eoapi 与哈尔滨工业大学（深圳）数据安全研究院发起的开源项目 OpenDLP，联合发布了合作插件——OpenDLP API 安全检查，小小插件能为 API 安全做什么呢？
企业安全关注的事情很多，API 安全目前来讲是一个非常新兴的，但是非常重要的一个热点。软件世界数据通信万物互联的背景下，从我的视角来看，API 是一种新的能够更低成本去让数据打通，让软件集成融为一体，以及在某种程度上甚至能够以一种更好的生产方式，快速完成企业软件交付的一种新模式。大家也已经看到，各行各业的企业都已经在做一些做业务或者做 API 化的战略转型，其实就在 API 里面。
基础设施增长的背后，一定也会带来安全问题。我们讲的黑客攻击，以利益为主导的黑客攻击它无非就是想控制你的资产，或者想偷你的数据，而 API 这两点它是都具备。
一方面，API 本身是暴露在网络上的，相当于软件构建的系统，对网站攻击的手法完全可以应用到 API 的场景里。API 的后端，比如一些 Java 的代码，也是各种各样的系统，这些系统它存在的漏洞，也可以通过 API 打进去，最终导致自己的资产实现。这是传统攻防领域的情况。
最近我们看到一个更严峻的趋势，越来越多的 API 导致了非常严重的数据泄露。数据泄露对企业来讲，尤其是大型企业，以及关系到民生或基础设施的企业，他们一次大范围的数据泄露是非常致命的，可能不仅仅是业务上损失，还会涉及到监管层面。
以前的数据泄露事件，要层层攻击，从外网到内网到数据库打进去，打进去很费劲，最终才能把数据库的数据拖出来。现在不一样了，我们只需要找到一个没有认证授权的 API 数据，随便一个脚本就可以把数据拖出来，这是一个非常简单快速的入侵链路，但是它的杀伤力巨大。现在越来越多企业除了要面对漏洞攻击，还要面对 API 导致的数据泄露。
提高 API 安全性的手段有很多，敏感数据识别扫描就是其中之一。
OpenDLP 是一个开源的敏感数据识别工具，我们可以通过 OpenDLP 服务在 Eoapi 上对文档进行扫描，避免部署/开放带有敏感字段的 API 文档。
如何使用 OpenDLP 插件 Docker 部署 OpenDLP 服务：Docker push longice/opendlp-eoapi:1.0.0
在 Eoapi 【插件广场】-【所有】-【OpenDLP】中找到 OpenDLP 插件一键安装
在 Eoapi 【插件广场】-【所有】-【OpenDLP】中输入 OpenDLP 服务地址，保存。
此时，在 API 详情页点击【扫描 API 敏感词】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac82c22993c1b639b638b908910eb856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac346ee85a5c6192330bd66584dd7f0/" rel="bookmark">
			一篇文章带你学完链表基础（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表，也称线性表的链式存储结构，其元素在内存空间上不是连续的，通过指针链接来决定元素的次序。
目录 一、链表的分类1.单向或者双向2.带头或者不带头3.循环或者非循环 二、单链表的实现动态申请一个节点单链表打印单链表尾插单链表尾删单链表头插单链表头删单链表查找单链表pos之后插入x单链表pos之前插入x单链表删除pos之后的节点单链表删除pos节点单链表销毁 例题——删除链表中等于给定值 val 的所有节点方法一：原链表修改方法二：创建新链表方法三：创建带头链表 例题——反转链表方法一：迭代法方法二：递归法 三、双向带头循环链表的实现动态申请一个节点初始化打印尾插尾删头插头删查找插入删除判断链表是否为空返回链表长度销毁 四、总结 一、链表的分类 链表的结构多种多样，以下的情况组合起来就有8种链表结构。
1.单向或者双向 2.带头或者不带头 3.循环或者非循环 虽然有这么多种结构，但是我们最常用的只有两种：
1.无头单向非循环链表：结构简单，一般不会单独用来存储数据。实际上更多是作为其他数据结构的子结构，如哈希桶，图的邻接表等。
2.带头双向循环链表：结构最复杂，但实现起来比较简单。
二、单链表的实现 typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; //动态申请一个节点 SLTNode* BuySListNode(SLTDataType x); //单链表打印 void SLTPrint(SLTNode* phead); //单链表尾插 void SLTPushBack(SLTNode** pphead, SLTDataType x); //单链表尾删 void SLTPopBack(SLTNode** pphead); //单链表头插 void SLTPushFount(SLTNode** pphead, SLTDataType x); //单链表头删 void SLTPopFount(SLTNode** pphead); //单链表查找 SLTNode* SLTFind(SLTNode* phead, SLTDataType x); //单链表pos之后插入x void SLTInsertAfter(SLTNode* pos, SLTDataType x); //单链表pos之前插入x void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); //单链表删除pos之后的结点 void SLTEraseAfter(SLTNode* pos); //单链表删除pos结点 void SLTErase(SLTNode** pphead, SLTNode* pos); //单链表销毁 void SLTDestroy(SLTNode** pphead); 动态申请一个节点 SLTNode* BuySListNode(SLTDataType x) { SLTNode* newnode = (SLTNode*)malloc(sizeof(SLTNode)); if (newnode == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac346ee85a5c6192330bd66584dd7f0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/115/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>