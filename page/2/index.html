<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8d1b48c71d08bdb58884218224c2c8/" rel="bookmark">
			Python3 注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 确保对模块, 函数, 方法和行内注释使用正确的风格。（文末送读者福利）
Python 中的注释有单行注释和多行注释。
Python 中单行注释以 # 开头，例如：
# 这是一个注释 print(“Hello, World!”)
多行注释用三个单引号 ‘’’ 或者三个双引号 “”" 将注释括起来，例如:
1、单引号（‘’'） #!/usr/bin/python3 ‘’’ 这是多行注释，用三个单引号 这是多行注释，用三个单引号 这是多行注释，用三个单引号 ‘’’ print(“Hello, World!”)
2、双引号（“”"） #!/usr/bin/python3 “”" 这是多行注释，用三个双引号 这是多行注释，用三个双引号 这是多行注释，用三个双引号 “”" print(“Hello, World!”)
读者福利：知道你对Python感兴趣，还准备了这套python学习资料
对于0基础小白入门：
如果你是零基础小白，想快速入门Python是可以考虑的。
一方面是学习时间相对较短，学习内容更全面更集中。
二方面是可以找到适合自己的学习方案
零基础Python学习资源介绍 👉Python学习路线汇总👈 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。（全套教程文末领取哈）
👉Python必备开发工具👈 温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 上述这份完整版的Python全套学习资料已经上传网盘，朋友们如果需要可以微信扫描下方二维码输入“领取资料” 即可自动领取 或者
【点此链接】领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e732b8ed80ae3cd421f78e3ceb510fe4/" rel="bookmark">
			力扣刷题记录（28）LeetCode：797、200、463
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		797. 所有可能的路径 解题思路：回溯算法，当收集到的路径的最后一个值等于n-1时，收集答案。
参数：图、当前结点
class Solution { public: vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; ans; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph,int index) { if(path.back()==graph.size()-1) { ans.push_back(path); return; } for(int i=0;i&lt;graph[index].size();i++) { path.push_back(graph[index][i]); dfs(graph,graph[index][i]); //回溯 path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { //从0开始的，先将0传入路径中 path.push_back(0); dfs(graph,0); return ans; } }; 200. 岛屿数量 解题思路：如果我们遍历到一块陆地，那我们就以这块陆地为中心向它的周围扩散，将所有与之相连的陆地全部都标记。这时我们所标记的所有相连的陆地就形成了一片岛屿，岛屿数量加一。那我们如果对所有陆地都进行这样的操作，就可以得到岛屿的数量。需要注意的是我们需要对已经标记过的陆地进行这样的操作，因为它已经是前面统计过的岛屿的一部分。
class Solution { private: void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y) { //判断是否越界 if(x&gt;=grid[0].size() || y&gt;=grid.size()) return; //判断岛屿是否遍历过 只遍历岛屿 if(grid[y][x]=='2'||grid[y][x]=='0') return; //将岛屿的状态改为遍历过 grid[y][x]='2'; dfs(grid,x-1,y); dfs(grid,x+1,y); dfs(grid,x,y-1); dfs(grid,x,y+1); } public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int ans=0; for(int i=0;i&lt;grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e732b8ed80ae3cd421f78e3ceb510fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8500ebe9023af34e9719f35cfd7ce54/" rel="bookmark">
			python项目分享 基于Django的问答社区管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 Hi，大家好，今天给大家介绍一个python管理系统，大家可以用于自己的课设或毕设！
今天要分享的是：毕业设计 基于Django的问答社区管理系统
项目分享：
https://gitee.com/sinonfin/system-sharing
1 设计说明 在虚拟环境中运行命令“python manage.py run”启动项目。启动成功后，在浏览器中输入网址“127.0.0.1:9000”即可进入BBS问答社区首页。如图1所示。
在首页可以根据状态和标签过滤帖子列表，按状态查看如图2所示，按标签查看如图3所示。
选中一个帖子，单击可以查看帖子详情，如图4所示。
只有在用户登录后，才能发帖和回帖。所以需要用户先来注册，然后再登录。注册和登录在一个页面，单击“注册”按钮实现注册功能，单击“登录”按钮实现登录功能，如图5所示。
用户发帖页面如图6所示，回帖页面如图7所示。
答案采纳页面如图8所示，显示回复数量页面如图9所示。
部分相关源码
# -*- coding: utf-8 -*- import base64 import uuid import hashlib from urllib import parse from io import BytesIO from tornado import gen from handlers.base_handlers import BaseHandler from database.sql_utils.auth import get_user_by_username, create_user from utils.auth_code import get_pic_code from utils.logger import logger from utils.errcode import LOGIN_VCODE_ERR, PASSWORD_ERR, USERNAME_ERR, USER_EXISTS, USER_CREATE_ERR class LoginHandler(BaseHandler): """登录控制器""" @gen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8500ebe9023af34e9719f35cfd7ce54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91689ed8ceb765f44ed8334ba9972cf7/" rel="bookmark">
			YoLov5从环境搭建到训练自己的数据，以良性皮肤痣和恶性皮肤痣的分类与血红细胞类型目标检测识别为例（非常详细，包括环境安装配置、源码下载、配置运行环境、代码改写、数据集制作、训练、预测和优化）等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软硬件的准备与虚拟环境搭建 1、Python环境：直接安装Anaconda 3-2022 （1）百度网盘下载地址(下载文件中附了非常详细的安装教程)：https://pan.baidu.com/s/1KQNOlYU-GMKbkPGcip1Hzw?pwd=5678
（2）直接网上百度下载和安装，非常多教程，这里直接略过
安装好之后，可以打开Anaconda Prompt（install），查看python版本：
（3）将安装的Anaconda加入电脑的系统环境变量里面
3.1 如下图所示：直接搜索系统环境变量，点击 编辑系统环境变量
3.2 点击 右下角环境变量
3.3 进入之后可以看见有xxx用户变量和系统变量两部分，里面都有path变量，选择path变量，点击编辑
3.4 进入之后点击新建，将Anaconda的安装路径和Scripts路径填写进去，最后点击确定就完成了环境变量的添加（注意：每个页面都有确定，请一一点击确定）
2、软件：安装Pycharm 2020.1 x64 软件（这是专业版） （1）百度网盘下载地址(下载文件中附了非常详细的安装教程)：https://pan.baidu.com/s/1KQNOlYU-GMKbkPGcip1Hzw?pwd=5678
（2）直接网上百度下载和安装，非常多教程，这里直接略过
3、查看当前电脑的cuda版本，为后面安装pytorch做准备 打开cmd的shell，输入命令：nvidia-smi，cuda版本为12.1
4、打开Anaconda Prompt(install)，创建虚拟环境，如下图所示： 1、创建虚拟环境
方法一：默认情况下虚拟环境创建在Anaconda安装目录下的envs文件夹中
conda create --name yolov5 #yolov5是虚拟环境名称（自定义） 方法二：如果想将虚拟环境创建在指定位置，使用–prefix参数即可：
conda create --prefix D:\Software\Envs\yolov5 python==3.9 #yolov5是虚拟环境名称（自定义） 2、查看已经创建好的虚拟环境：
conda env list 3、激活虚拟环境并查看下面已安装的库
4、如果想要删除yolov5这个虚拟环境：
conda remove --prefix D:\Software\Envs\yolov5 --all 二、下载yolov5项目的代码 在github官网下载源码 下载网址：https://github.com/ultralytics/yolov5 三、使用安装的pycharm软件打开项目并配置运行环境 1、打开软件，点击左上角的File，再点击Open 2、打开之后，在相应的路径下找到项目，点击ok，项目就被打开了 3、运行环境的配置：再一次点击左上角的File，接着点击Settings 4、进入之后，首先在页面左边找到 【Project：你的项目名】按钮并点击，再点击里面的 Python Interpreter，接着点击右上角的设置符号，里面会出来Add与Show All两个选项，再点击Add，如下图所示： 5、进入之后，选择Existing environment,再进行环境的选择，最后点击确定即可（在这里我选择了前面创建的yolov5环境，注意：选择到环境下面的python.exe路径才可以） 到这里项目的打开和运行环境的设置就完成了！
四、torch、opencv等库的安装 1、在上一个步骤中，我们已经使用pycharm打开了项目并配置了运行环境，接下里在打开的项目中找到requirements.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91689ed8ceb765f44ed8334ba9972cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e876532bd96350a0908a8f631265b53/" rel="bookmark">
			C# Unity将地形(Terrain)导出成obj文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# Unity将地形(Terrain)导出成obj文件 从其他地方搬运过来的，只能到出obj模型，不能导出贴图
using System.IO; using System.Text; using UnityEditor; using UnityEngine; using System; enum SaveFormat { Triangles, Quads } enum SaveResolution { Full, Half, Quarter, Eighth, Sixteenth } class ExportTerrain : EditorWindow { SaveFormat saveFormat = SaveFormat.Triangles; SaveResolution saveResolution = SaveResolution.Half; static TerrainData terrain; static Vector3 terrainPos; int tCount ; int counter ; int totalCount ; [MenuItem ("Terrain/Export To Obj...")] static void Init () { terrain = null; Terrain terrainObject = Selection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e876532bd96350a0908a8f631265b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1fc04465ea589a98be6d6cdc55ff63/" rel="bookmark">
			bulk-RNA seq测序数据分析流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如有bulk-RNA测序的数据：TH1，TH2，TH3三个重复（实验组），TW1，TW2，TW3三个重复（对照组）
准备工作 需要安装的软件（如FastQC、Trimmomatic、HISAT2、StringTie、samtools） conda install -c bioconda fastqc conda install trimmomatic conda install -c bioconda stringtie conda install -c bioconda hisat2 conda install samtools conda install -c bioconda picard 1. 质量控制 首先，需要对原始的测序数据（FASTQ格式）进行质量控制。通常使用FastQC进行初步的质量检查，然后使用Trimmomatic或者其他工具进行质量修剪。
# 质量检查 fastqc *.fq.gz # 质量修剪 for sample in TH1 TH2 TH3 TW1 TW2 TW3 do trimmomatic PE ${sample}.R1.fq.gz ${sample}.R2.fq.gz \ ${sample}.R1.trim.fq.gz ${sample}.R1.untrim.fq.gz \ ${sample}.R2.trim.fq.gz ${sample}.R2.untrim.fq.gz \ SLIDINGWINDOW:4:20 MINLEN:25 done 2.读段比对 使用比对工具（如HISAT2, STAR等）将质量修剪后的读段比对到参考基因组。
使用HISAT2进行读段比对 # 假设参考基因组索引为genome_index for sample in TH1 TH2 TH3 TW1 TW2 TW3 do hisat2 -x genome_index -1 ${sample}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1fc04465ea589a98be6d6cdc55ff63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a44a5026bbda42fdd82193ba0ccd8c6/" rel="bookmark">
			自动驾驶感知-预测-决策-规划-控制学习（3）：感知方向文献阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、文章主题二、摘要阅读1.名词理解①点云是什么？②二维图像分割器③轻量化卷积网络提取特征④单模态表达和多模态特征融合的区别⑤基于ROS的多传感器融合感知⑥TensorRT工具 2.总结摘要 三、绪论解析1.首先分析了车道线检测方面有三类工作2.又分析了三维目标检测研究的三类工作3.综述各章节内容 四、硬件与软件设计1.总体方案2.车道线语义分割算法3.三维障碍物检测算法4.ROS框架 五、车道线分割算法实现1.什么是特征？ 六、三维点云进行物体识别七、算法结果分析与比较八、自动驾驶感知方面的关键知识点： 前言 论文题目：《面向自动驾驶场景的多传感器环境感知系统研究》-中国矿业大学，朱良钦
主要目的是快速熟悉自动驾驶方向的一些专业名词与基本概念。
一、文章主题 本文使用摄像头和激光雷达传感器采集环境数据，基于深度学习理论与方法，重点解决自动驾驶行驶场景下车道线检测和三维目标检测的难题。
笔记：感知的硬件设备是摄像头和激光雷达，自动驾驶的车道线检测和三维目标（如车辆、行人、交通标志等）检测也是一个老生常谈和经久不衰的研究方向，那么作者是如何利用深度学习的理论知识在这个方向做出一定的创新呢？
二、摘要阅读 主要研究内容如下：
（1）针对车道线检测任务，提出图像与点云融合的检测方法，在二维图像分割器的基础上， 将检测结果映射到点云中,获取更丰富的深度信息。在图像分割模型上，采用轻量化卷积网络提取特征， 提升特征提取的效率， 并添加跨通道联合注意力模块和改进的空洞空间卷积池化模块， 加强局部细节特征的提取。利用图像车道线检测结果， 融合相机和激光雷达的位姿变换关系获取车道线深度信息。
（2）对于三维目标检测任务，针对单模态数据表达不够充分等缺点，采用 多模态特征融合的三维目标检测算法。先在模型输入前对图像和点云数据进行预 处理， 共同作为算法模型的输入。然后进行特征提取和信息融合， 自动提取不同模态中相关性更大的信息， 突出有效信息并削弱不相关信息。最后量化检测结果，生成预测的目标候选框。
（3）设计了基于 ROS 的多传感器融合感知系统，使用 ROS 便捷的消息通信机制，完成不同传感器多进程间的通信和数据共享。使用 TensorRT 工具将感知算法模型部署在实验硬件平台上， 在保持精度的同时提升算法的推理速度，使 用 FP16 精度相比 FP32 总体速度提升了 127%。最后在自动驾驶开源数据集和实车采集数据集进行了测试验证，车道线分割任务中F1 -score 达到了 75.6，障碍物检测任务中平均精度达到了 62.99。
1.名词理解 ①点云是什么？ 点云（Point Cloud）是由大量的三维点组成的数据集合，每个点都具有空间坐标和可能的其他属性信息。点云可以看作是对三维物体或场景的采样和表示，它可以通过激光雷达、深度摄像头等传感器获取。
在自动驾驶和计算机视觉领域，点云被广泛应用于三维感知、目标检测、场景重建等任务。通过分析点云数据，可以提取出物体的几何形状、表面法线、颜色信息等。点云数据的处理和分析可以帮助自动驾驶系统理解周围环境，识别和跟踪其他车辆、行人、障碍物等。
点云数据通常以XYZ坐标形式存储，每个点的坐标表示其在三维空间中的位置。此外，点云数据还可以包含其他属性信息，如颜色、反射强度、法线方向等，这些属性信息可以提供更多的场景细节和语义信息。
比如我用C++代码来举个例子：
struct Point { float x, y, z; // 点的坐标 float r, g, b; // 点的颜色 }; 一个三维点可以包含坐标信息和其三通道的RGB值，那么可以进一步分析出其法线方向、其他属性等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a44a5026bbda42fdd82193ba0ccd8c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69517ba93d3c46310d09b2fbccd4f9a5/" rel="bookmark">
			python项目分享 基于Django的智慧校园考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 Hi，大家好，今天给大家介绍一个python管理系统，大家可以用于自己的课设或毕设！
今天要分享的是：毕业设计 基于Django的智慧校园考试系统
项目分享：
https://gitee.com/sinonfin/system-sharing
1 设计说明 在虚拟环境下输入命令“python manage.py runserver”启动项目，然后，访问“http://127.0.0.1:8000”进入网站首页，如图1所示。
注册用户
鼠标悬浮至顶部导航中的“登录”按钮时，单击“密码”登录，弹出登录框，如图2所示。如果没有账号，需要点击登录框中的“注册”按钮进行注册，如图3所示。
在注册页面中，需要填写真实可用的邮箱，注册成功后，需要进行邮箱验证，如图4所示。单击“发送邮件”按钮，提示发送信息，如图5所示。
查看邮箱，如图6所示。
由于我们在本地测试，不能直接单击邮箱验证链接，可以手动赋值链接，然后在链接地址前添加“http://127.0.0.1:8000”, 即完成的链接地址为：“http://127.0.0.1:8000/auth/email_notify?email=2237800782@qq.com&amp;sign=53ec094a-4acf-11e9-8b5b-b0d59d3cadab”。然后使用浏览器访问该地址即可完成验证并自动登录，如图7所示。
注册完用户后，即可参与答题，如选择热门比赛。点击一个比赛，即可进入该比赛信息页，如图8所示。
单击“开始挑战”按钮开始答题，如图9所示。单击“查看排行榜”按钮，即可查看排行榜。
在答题页面，单击“后退”按钮，返回上一题；单击“前进”按钮，进入下一题；单击“交卷”按钮，显示答题成绩，如图10所示。
注册机构
机构用户可以参与出题，用户需要先注册结构才能成为机构用户。单击顶部导航中的“成为机构”按钮，进入注册机构页面，如图11所示。在该页面中，邮箱填写用户注册网站时邮箱。
注册完成后，单击导航栏顶部的“快速出题”按钮，进入出题页面。如图12所示。
在快速出题页面，需要先来录制题库，然后再配置比赛。单击“开始录制”按钮，如图13所示。创建题库时，需要先下载题库模块，然后根据模板提示，创建自己的Excel题库。然后填写题库名称，选择题库类型，上传Excel文件，最后单击“开始录制”按钮，上传题库。
上传完题库以后，开始配置比赛。在快速出题页面，单击“配置比赛”超链接，进入配置比赛页面。配置比赛时，选择题库，填写配置信息。如果需要答题用户在比赛前填写用户信息，则需要勾选“开启录入信息功能”，然后勾选下面的字段，如图14所示。配置完成后，页面跳转到答题页，单击“开始挑战”按钮，弹出一个填写答题用户信息的表单，该表单中的字段就是在配置信息中设定的内容，如图15所示。
后台管理员
后台管理员可以通过账号密码登录后台，输入网址“http://127.0.0.1:8000/admin/”，输入如下账号密码即可登录。
账号：mr
密码：mrsoft
登录成功后进入后台主页，如图16所示。在后台主页，管理员可以根据对应菜单执行相应的管理工作。
部分相关源码
# -*- coding: utf-8 -*- import datetime from django.conf import settings from django.contrib.auth import login, logout from django.contrib.auth.models import User from django.db import transaction from django.shortcuts import redirect, render, reverse from account.models import Profile from utils.errors import VeriCodeError, VerifyFailed, PasswordResetFailed, UserNotFound, VeriCodeTimeOut from utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69517ba93d3c46310d09b2fbccd4f9a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124784822ca8a2f783cdb73b6a6c569f/" rel="bookmark">
			一文读懂「AI Agent」智能体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料： 1. 🔥报告： https://download.csdn.net/download/Julialove102123/88707927 2. 💡简单介绍视频：强推👍🏻Zomi酱的 AI Agent视频介绍 3. ⭐️简单介绍PDF： https://download.csdn.net/download/Julialove102123/88710873 一、什么是AI Agent？ 定义：智能体agent是通过传感器感知环境（收集信息）并通过执行器作用于该环境（采取行动）的事物
大语言模型和 AI Agent 的区别
1. 在于 AI Agent 可以独立思考并做出行动，和 RPA 的区别在于它能够处理未知环境信息。ChatGPT 诞生后，AI 从真正意义上具备了和人类进行多轮对话的能力，并且能针对相应问题给出具体回答与建议。随后各个领域的“Copilot”推出，如 Microsoft 365 Copilot、GitHub Copilot、Adobe Firefly 等，让 AI 成为了办公、代码、设计等场景的“智能副驾驶”。
2. 大模型与人类之间的交互是基于 prompt 实现的，用户prompt 是否清晰明确会影响大模型回答的效果，例如 ChatGPT 和这些 Copilot 都需要明确任务才能得到有用的回答。而 AI Agent 的工作仅需给定一个目标，它就能够针对目标独立思考并做出行动，它会根据给定任务详细拆解出每一步的计划步骤，依靠来自外界的反馈和自主思考，自己给自己创建 prompt，来实现目标。如果说 Copilot 是“副驾驶”，那么 Agent 则可以算得上一个初级的“主驾驶”。和传统的 RPA 相比，RPA 只能在给定的情况条件下，根据程序内预设好的流程来进行工作的处理，在出现大量未知信息、难以预测的环境中时，RPA 是无法进行工作的，AIAgent 则可以通过和环境进行交互，感知信息并做出对应的思考和行动。
二、Agent结构 AI AGENT = LLM（核心控制器，构建核心能力）+ 规划能力 + 记忆 + 工具。其中基座模型能力至关重要。
2.1 规划Planning Chain-of-Thought 推理只是作为静态黑盒，它没有用外部知识，所以在推理过程中会出现事实幻想(fact hallucination)和错误传递(error propagation)的问题。ReAct 克服了在思维链推理中的幻觉和错误传播问题，通过与简单的维基百科API交互，生成类 似于人的任务解决型轨迹，解释性进一步增强。 1）Chain of thought 2）Self Reflection 自我反思(Self-reflection)允许 Agent 通过完善以往行动决策和纠正以往错误来迭代改进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124784822ca8a2f783cdb73b6a6c569f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841379966058ad1e04e2ee32b79681d7/" rel="bookmark">
			二手买卖、废品回收小程序 在app.json中声明permission scope.userLocation字段 教程说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 处理二手买卖、废品回收小程序 在app.json中声明permission scope.userLocation字段 教程说明
sitemapLocation
指明 sitemap.json 的位置；默认为 ‘sitemap.json’ 即在 app.json 同级目录下名字的 sitemap.json 文件
找到app.json这个文件 把这段代码加进去，保存，重新编译一下就好了 "permission": { "scope.userLocation": { "desc": "你的位置信息将用于小程序位置接口的效果展示" } }, 部分代码展示
&lt;view class="region data-v-f11e9bf6"&gt; &lt;picker bindchange="__e" bindcolumnchange="__e" class="picker data-v-f11e9bf6" data-event-opts="{{[ [ 'change',[ [ 'change',['$event'] ] ] ],[ 'columnchange',[ [ 'columnchange',['$event'] ] ] ] ]}}" disabled="{{disabled}}" mode="multiSelector" range="{{range}}" rangeKey="name" value="{{value}}"&gt; &lt;view class="{{['content data-v-f11e9bf6',!regionStr?'placeholder':'']}}"&gt; &lt;view class="ellipsis-1 data-v-f11e9bf6"&gt;{{regionStr?regionStr:placeholder}}&lt;/view&gt; &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; 安装搭建 预约上门家电家具回收系统小程序 可以QQ扫一扫： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65873cae18b9f4fd414d4ccef9b636d/" rel="bookmark">
			华为HCIA课堂笔记第五章 IP路由基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章 IP路由基础 5.1 背景 随着网络规模的扩大，需要通过3层设备来隔离不同的广播域，一般一个广播域一个网段，因此出现了访问远程设备会经过不同的网段，可以到达的路径也多种。因此需要进行路径选择。
5.2路由信息 5.2.1路由6元组 路由器依据路由表进行报文的转发，路由表中包含多个路由条目，每个路由条目都有6元组：
目的网络和掩码：表示数据报文可以通过该路由条目去往的目的网络。路由协议：表示该路由条目是从何种途径学习到的。优先级：可以通过优先级控制，当路由器学习到多条去往相同目的网络的路由条目，优先选择优先级最高（值越小越优）的条目，加入到IP路由表中。开销：可以通过控制开销，当路由器学习到多条去往相同目的网络的路由条目，且优先级也相同，则比较开销值，将开销值小的路由条目加入到IP路由表中。下一跳：是指报文匹配路由条目转发到目的需要先交给的下一个设备IP地址。出接口：报文要转发到目的网络，依据该路由条目，应该从设备的哪个接口发出。 5.2.2 路由的学习方式 六元组中Protocol用来表示路由的学习方式：
1、直连路由：路由设备配置了IP地址之后，根据IP地址自动生成的路由条目。表示该目的网络直接连接在路由器上的。
2、静态路由：通过手工配置的路由条目，手工指定目的网络和掩码、出接口、下一跳。
3、动态路由：通过路由协议动态学习路由条目，比如OSPF（开放式最短路径优先）。
5.2.3 优先级和开销（度量值） 常见协议的路由优先级：直连默认0，静态默认60，OSPF域内默认10，OSPF域外路由默认150。
路由器学习到不同的目的网络的多条路由：直接加入路由表，不比较优先级
路由器学习到相同的目的网络的多条路由：
比较路由条目优先级，值越小越优，将最优的路由条目加入到路由表中，如果优先级相等，则比较开销，开销值越小越优，将最优的路由条目加入到路由表中。如果开销也相同，则两条路由都加入到路由表中，形成等价路由。 5.2.4 路由的匹配方式（最长掩码匹配原则） 路由条目中的目的地址及掩码与数据报文中的目的IP地址进行比较，路由条目按照掩码的长度要求目的IP地址的前多个比特位与路由条目的目的网络必须要相同，如果相同，则匹配该条路由条目，如果不同，则不匹配。
例如：数据报文的目地IP地址192.168.10.1。
路由表中存在三条路由条目，均已生效：
192.168.0.0/16 G0/0/0 10.0.12.1 //该条目要求目的IP前16位与自己相同
192.168.10.0/24 G0/0/1 10.0.12.2 //该条目要求目的IP前24位与自己相同
192.168.10.128/25 G0/0/2 10.0.12.3 //该条目要求目的IP前25要与自己相同。
只有第一条和第二条可以匹配，选择最长掩码的第二条指导报文转发。
优先级和最长掩码匹配原则的区别：
优先级是选择最优的路由加入到路由表中（学习到多条相同网段的路由才比较优先级，不同网段的直接加表，不比较优先级）最长掩码匹配原则：转发报文的时候，已存在在路由表中的路由同时多条路由匹配目的IP地址，此时选择最长掩码的路由条目转发报文。 5.3 路由 5.3.1 缺省路由 缺省路由0.0.0.0/0 又叫做默认路由，可以是静态的，也可以是动态的。主要用于园区网出口设备，匹配互联网中的所有目的地址。
5.3.2 动态路由分类 按照工作区域分类：AS（自治系统）：一系列的路由设备由同一个组织使用相同的路由策略进行管理的设备范围。 内部网关路由协议（IGP）： OSPF（开放式最短路径优先），路由默认优先级内部10，外部150IS-IS（中间系统到中间系统），路由默认优先级L1级15,L2级18RIP（路由信息协议，淘汰了），路由默认优先级是100外部网关路由协议（EGP）： BGP（边界网关路由协议），路由默认的优先级是255按照工作算法分类： 距离矢量路由协议：RIP，逐跳传递路由条目。链路状态路由协议：OSPF，ISIS，传递的链路状态信息，根据链路状态信息计算路由条目。 5.4 路由特性 5.4.1 路由递归 路由条目的下一跳必须可达，如果不可达，在路由不会生效：
路由条目的下一跳可以是直连的，可以是不直连的通过重新配置一条路由使得不直连的路由下一跳可达，从而使得不直连路由生效。 5.4.2 等价路由 从同一个路由协议（静态，直连，动态）学习相同目的地的多条路由，优先级相同，开销相同，则多条路由同时生效，形成等价路由。
5.4.3 浮动路由 从不同的路由协议，或者是相同的路由协议学习到多条路由，最终比较优先级和开销，仅将最优的加入到路由表中，次优的路由作为备份路由，当主路由失效，备份路由就生效，用于指导报文转发。
5.4.4 CIDR 无类域间路由：将代表小范围的多条路由汇总成一条范围更大的路由，用于指导报文转发。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b65873cae18b9f4fd414d4ccef9b636d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dbe09105384668e18c97b51e147f6d6/" rel="bookmark">
			【LeetCode】1341. 电影评分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表：Movies
+---------------+---------+ | Column Name | Type | +---------------+---------+ | movie_id | int | | title | varchar | +---------------+---------+ movie_id 是这个表的主键(具有唯一值的列)。 title 是电影的名字。 表：Users
+---------------+---------+ | Column Name | Type | +---------------+---------+ | user_id | int | | name | varchar | +---------------+---------+ user_id 是表的主键(具有唯一值的列)。 表：MovieRating
+---------------+---------+ | Column Name | Type | +---------------+---------+ | movie_id | int | | user_id | int | | rating | int | | created_at | date | +---------------+---------+ (movie_id, user_id) 是这个表的主键(具有唯一值的列的组合)。 这个表包含用户在其评论中对电影的评分 rating 。 created_at 是用户的点评日期。 请你编写一个解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dbe09105384668e18c97b51e147f6d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13488994347434407a46d03298f222c8/" rel="bookmark">
			互联网加竞赛 基于人工智能的图像分类算法研究与实现 - 深度学习卷积神经网络图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 简介1 常用的分类网络介绍1.1 CNN1.2 VGG1.3 GoogleNet 2 图像分类部分代码实现2.1 环境依赖2.2 需要导入的包2.3 参数设置(路径，图像尺寸，数据集分割比例)2.4 从preprocessedFolder读取图片并返回numpy格式(便于在神经网络中训练)2.5 数据预处理2.6 训练分类模型2.7 模型训练效果2.8 模型性能评估 3 1000种图像分类4 最后 0 简介 🔥 优质竞赛项目系列，今天要分享的是
基于人工智能的图像分类技术
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 常用的分类网络介绍 1.1 CNN 传统CNN包含卷积层、全连接层等组件，并采用softmax多类别分类器和多类交叉熵损失函数。如下图：
卷积层(convolution layer): 执行卷积操作提取底层到高层的特征，发掘出图片局部关联性质和空间不变性质。
池化层(pooling layer): 执行降采样操作。通过取卷积输出特征图中局部区块的最大值(max-pooling)或者均值(avg-pooling)。降采样也是图像处理中常见的一种操作，可以过滤掉一些不重要的高频信息。
全连接层(fully-connected layer，或者fc layer): 输入层到隐藏层的神经元是全部连接的。
非线性变化: 卷积层、全连接层后面一般都会接非线性变化层，例如Sigmoid、Tanh、ReLu等来增强网络的表达能力，在CNN里最常使用的为ReLu激活函数。
Dropout : 在模型训练阶段随机让一些隐层节点权重不工作，提高网络的泛化能力，一定程度上防止过拟合
在CNN的训练过程总，由于每一层的参数都是不断更新的，会导致下一次输入分布发生变化，这样就需要在训练过程中花费时间去设计参数。在后续提出的BN算法中，由于每一层都做了归一化处理，使得每一层的分布相对稳定，而且实验证明该算法加速了模型的收敛过程，所以被广泛应用到较深的模型中。
1.2 VGG VGG 模型是由牛津大学提出的（19层网络），该模型的特点是加宽加深了网络结构，核心是五组卷积操作，每两组之间做Max-
Pooling空间降维。同一组内采用多次连续的3X3卷积，卷积核的数目由较浅组的64增多到最深组的512，同一组内的卷积核数目是一样的。卷积之后接两层全连接层，之后是分类层。该模型由于每组内卷积层的不同主要分为
11、13、16、19 这几种模型
增加网络深度和宽度，也就意味着巨量的参数,而巨量参数容易产生过拟合，也会大大增加计算量。
1.3 GoogleNet GoogleNet模型由多组Inception模块组成，模型设计借鉴了NIN的一些思想.
NIN模型特点：
1. 引入了多层感知卷积网络(Multi-Layer Perceptron Convolution, MLPconv)代替一层线性卷积网络。MLPconv是一个微小的多层卷积网络，即在线性卷积后面增加若干层1x1的卷积，这样可以提取出高度非线性特征。 2)设计最后一层卷积层包含类别维度大小的特征图，然后采用全局均值池化(Avg-Pooling)替代全连接层，得到类别维度大小的向量，再进行分类。这种替代全连接层的方式有利于减少参数。 Inception 结构的主要思路是怎样用密集成分来近似最优的局部稀疏结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13488994347434407a46d03298f222c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa1f8a380a90e1530b2b57767e9baad/" rel="bookmark">
			华为OD机试2024年最新题库（Python、JAVA、C&#43;&#43;、JS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名软件开发培训机构老师，我的学生已经有上百人通过了华为OD机试，学生们每次考完试，会把题目拿出来一起交流分享。
重要：2023年11月份开始，考的都是OD统一考试（C卷），题库已经整理好了，命中率95%以上。
2024年题库已经更新为OD统一考试（C卷），题库由两部分组成：
1、新增题库
2、2023年OD机试历史题库
新增题库更新如下，由于时间比较紧张，我会先更新题目+1种解法，随后补齐Python、JAVA、C++、JS解法。
以下是100分题目：
序号题目分值通过率试卷类型语言1寻找身高相近的小朋友100100%OD统一考试（C卷）python、java、C++、JS2围棋的气100100%OD统一考试（C卷）python、java、C++、JS3用连续自然数之和来表达整数100100%OD统一考试（C卷）python、java、C++、JS4开源项目热榜100100%OD统一考试（C卷）python、java、C++、JS5API集群负载统计100100%OD统一考试（C卷）python、java、C++、JS6整数对最小和100100%OD统一考试（C卷）python、java、C++、JS7素数之积100100%OD统一考试（C卷）python、java、C++、JS8CPU算力分配100100%OD统一考试（C卷）python、java、C++、JS9最大坐标值100100%OD统一考试（C卷）python、java、C++、JS10寻找最富裕的小家庭100100%OD统一考试（C卷）python、java、C++、JS11查找接口成功率最优时间段100100%OD统一考试（C卷）python、java、C++、JS12分割均衡字符串100100%OD统一考试（C卷）python、java、C++、JS13虚拟游戏理财100100%OD统一考试（C卷）python、java、C++、JS14靠谱的车100100%OD统一考试（C卷）python、java、C++、JS15执行时长100100%OD统一考试（C卷）python、java、C++、JS16万能字符单词拼写100100%OD统一考试（C卷）python、java、C++、JS17来自异国的客人100100%OD统一考试（C卷）python、java、C++、JS18求最多可以派出多少支团队100100%OD统一考试（C卷）python、java、C++、JS19最长子字符串的长度(一)100100%OD统一考试（C卷）python、java、C++、JS20机场航班调度程序100100%OD统一考试（C卷）python、java、C++、JS21数的分解100100%OD统一考试（C卷）python、java、C++、JS22智能成绩表 100100%OD统一考试（C卷）python、java、C++、JS23提取字符串中的最长数学表达式并计算100100%OD统一考试（C卷）python、java、C++、JS24最大N个数与最小N个数的和100100%OD统一考试（C卷）python、java、C++、JS25小朋友来自多少小区100100%OD统一考试（C卷）python、java、C++、JS26停车场车辆统计100100%OD统一考试（C卷）python、java、C++、JS27执行任务赚积分100100%OD统一考试（C卷）python、java、C++、JS28最多购买宝石数目100100%OD统一考试（C卷）python、java、C++、JS29求字符串中所有整数的最小和100100%OD统一考试（C卷）python、java、C++、JS30堆内存申请100100%OD统一考试（C卷）python、java、C++、JS31智能成绩表100100%OD统一考试（C卷）python、java、C++、JS32测试用例执行计划100100%OD统一考试（C卷）python、java、C++、JS33按身高和体重排队100100%OD统一考试（C卷）python、java、C++、JS34攀登者1100100%OD统一考试（C卷）python、java、C++、JS35分披萨100100%OD统一考试（C卷）python、java、C++、JS36攀登者100100%OD统一考试（C卷）python、java、C++、JS37计算面积100100%OD统一考试（C卷）python、java、C++、JS38考勤信息100100%OD统一考试（C卷）python、java、C++、JS39字符串变换最小字符串100100%OD统一考试（C卷）python、java、C++、JS40分配土地100100%OD统一考试（C卷）python、java、C++、JS41小华最能得到多少克黄金100100%OD统一考试（C卷）python、java、C++、JS42英文输入法100100%OD统一考试（C卷）python、java、C++、JS43游戏分组100100%OD统一考试（C卷）python、java、C++、JS44精准核酸检测100100%OD统一考试（C卷）python、java、C++、JS45内存冷热标记100100%OD统一考试（C卷）python、java、C++、JS46密码解密100100%OD统一考试（C卷）python、java、C++、JS47密码输入检测100100%OD统一考试（C卷）python、java、C++、JS48螺旋数字矩阵100100%OD统一考试（C卷）python、java、C++、JS49火星文计算100100%OD统一考试（C卷）python、java、C++、JS50灰度图恢复100100%OD统一考试（C卷）python、java、C++、JS51查找众数及中位数100100%OD统一考试（C卷）python、java、C++、JS52找朋友100100%OD统一考试（C卷）python、java、C++、JS53求幸存数之和100100%OD统一考试（C卷）python、java、C++、JS54多段线数据压缩100100%OD统一考试（C卷）python、java、C++、JS55生成哈夫曼树100100%OD统一考试（C卷）python、java、C++、JS56机器人仓库搬砖100100%OD统一考试（C卷）python、java、C++、JS57字符串序列判定100100%OD统一考试（C卷）python、java、C++、JS58数组去重和排序100100%OD统一考试（C卷）python、java、C++、JS59找座位100100%OD统一考试（C卷）python、java、C++、JS60计算三叉搜索树的高度100100%OD统一考试（C卷）python、java、C++、JS61小明找位置100100%OD统一考试（C卷）python、java、C++、JS62转盘寿司100100%OD统一考试（C卷）python、java、C++、JS63 手机App防沉迷系统100100%OD统一考试（C卷）python、java、C++、JS64传递悄悄话100100%OD统一考试（C卷）python、java、C++、JS65 以下是200分题目：
序号题目分值通过率试卷类型语言1分月饼 200100%OD统一考试（C卷）python、java、C++、JS2找城市200100%OD统一考试（C卷）python、java、C++、JS3两个字符串间的最短路径问题200100%OD统一考试（C卷）python、java、C++、JS4电脑病毒感染200100%OD统一考试（C卷）python、java、C++、JS5 项目排期200100%OD统一考试（C卷）python、java、C++、JS6模拟数据序列化传输 200100%OD统一考试（C卷）python、java、C++、JS75G网络建设200100%OD统一考试（C卷）python、java、C++、JS8叉树计算200100%OD统一考试（C卷）python、java、C++、JS9二叉树的广度优先遍历200100%OD统一考试（C卷）python、java、C++、JS10可以组成网络的服务器200100%OD统一考试（C卷）python、java、C++、JS11田忌赛马200100%OD统一考试（C卷）python、java、C++、JS12任务处理200100%OD统一考试（C卷）python、java、C++、JS13会议室占用时间200100%OD统一考试（C卷）python、java、C++、JS14石头剪刀布游戏200100%OD统一考试（C卷）python、java、C++、JS15篮球游戏200100%OD统一考试（C卷）python、java、C++、JS16攀登者2200100%OD统一考试（C卷）python、java、C++、JS17最小矩阵宽度200100%OD统一考试（C卷）python、java、C++、JS18部门人力分配200100%OD统一考试（C卷）python、java、C++、JS19中文分词模拟器200100%OD统一考试（C卷）python、java、C++、JS20Wonderland200100%OD统一考试（C卷）python、java、C++、JS21跳马200100%OD统一考试（C卷）python、java、C++、JS22符号运算200100%OD统一考试（C卷）python、java、C++、JS23孙悟空吃蟠桃200100%OD统一考试（C卷）python、java、C++、JS24最长子字符串的长度(二)200100%OD统一考试（C卷）python、java、C++、JS25求满足条件的最长子串的长度200100%OD统一考试（C卷）python、java、C++、JS26最长的指定瑕疵度的元音子串200100%OD统一考试（C卷）python、java、C++、JS27抢7游戏200100%OD统一考试（C卷）python、java、C++、JS28贪心歌手200100%OD统一考试（C卷）python、java、C++、JS29数组排列求和200100%OD统一考试（C卷）python、java、C++、JS30考古学家200100%OD统一考试（C卷）python、java、C++、JS31学生重新排队200100%OD统一考试（C卷）python、java、C++、JS32解密犯罪时间200100%OD统一考试（C卷）python、java、C++、JS33路口最短时间问题200100%OD统一考试（C卷）python、java、C++、JS34加密算法200100%OD统一考试（C卷）python、java、C++、JS35信道分配200100%OD统一考试（C卷）python、java、C++、JS36员工派遣200100%OD统一考试（C卷）python、java、C++、JS37字符串拼接200100%OD统一考试（C卷）python、java、C++、JS38伐木工200100%OD统一考试（C卷）python、java、C++、JS39查找一个有向网络的头节点和尾节点200100%OD统一考试（C卷）python、java、C++、JS40文件缓存系统200100%OD统一考试（C卷）python、java、C++、JS41园区参观路径200100%OD统一考试（C卷）python、java、C++、JS42快递员的烦恼200100%OD统一考试（C卷）python、java、C++、JS43文本统计分析200100%OD统一考试（C卷）python、java、C++、JS44矩阵匹配200100%OD统一考试（C卷）python、java、C++、JS45图像物体的边界200100%OD统一考试（C卷）python、java、C++、JS46模拟目录管理200100%OD统一考试（C卷）python、java、C++、JS47 寻找最优的路测线路200100%OD统一考试（C卷）python、java、C++、JS48运输时间200100%OD统一考试（C卷）python、java、C++、JS49高效货运200100%OD统一考试（C卷）python、java、C++、JS50贪吃的猴子200100%OD统一考试（C卷）python、java、C++、JS51最长的指定瑕疵度的元音子串200100%OD统一考试（C卷）python、java、C++、JS 华为OD招聘，每年的1-5月份是高峰期，这个阶段呢，offer多，面试简单，薪资高，大家可以利用年前的时间好好准备和复习，取得一个不错的机试成绩~
机考题库大概每半年更新一次，也就是说一直到2024年5月份，考的都是这份题库，大家有充足的时间来复习和准备~
另外，这些题目是给大家参考的，考试过程中要注意重复率，重复率过高很判定作弊嫌疑，切记~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c94b59ec01a435daa4c69b7ceeca648/" rel="bookmark">
			基于单片机的护理床控制器设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 随着科技的不断发展，人们对生活质量的要求越来越高，特别是在医疗保健领域。护理床作为医院病房中常见的设备，其功能和性能直接影响到患者的康复进程。本文主要介绍了一种基于单片机的护理床控制器设计，该控制器可以实现床体的升降、左右移动、背部抬起等功能，同时还具有安全防护和紧急停止功能。通过对单片机的编程控制，实现了护理床的自动化和智能化，提高了护理工作的效率和质量。
二、引言 护理床是医院病房中用于照顾病人的重要设备，其主要功能包括床体的升降、左右移动、背部抬起等。传统的护理床操作繁琐，需要医护人员手动操作，不仅劳动强度大，而且容易出现误操作。为了解决这些问题，本文提出了一种基于单片机的护理床控制器设计，通过单片机对护理床的各个功能模块进行控制，实现护理床的自动化和智能化。
三、系统设计 本设计主要包括以下几个部分：单片机最小系统、驱动电路、执行机构和人机交互界面。
1. 单片机最小系统：本设计采用AT89S52单片机作为控制核心，负责接收来自人机交互界面的信号，并根据信号控制驱动电路，从而实现对护理床的控制。
2. 驱动电路：驱动电路主要包括电机驱动电路和电磁铁驱动电路。电机驱动电路负责控制床体的升降、左右移动和背部抬起；电磁铁驱动电路负责实现床板的锁定和解锁功能。
3. 执行机构：执行机构主要包括电机和电磁铁。电机负责实现床体的升降、左右移动和背部抬起；电磁铁负责实现床板的锁定和解锁功能。
4. 人机交互界面：人机交互界面主要包括按键和显示屏。按键用于输入控制指令；显示屏用于显示当前护理床的状态信息。
四、软件设计 本设计的软件主要包括主程序、按键处理程序、显示处理程序和电机控制程序。主程序负责整个系统的运行；按键处理程序负责处理按键输入的信号；显示处理程序负责处理显示屏的显示内容；电机控制程序负责控制电机的运行。
五、系统测试与分析 通过对本设计的护理床控制器进行实际测试，验证了其功能的实现和性能的稳定性。测试结果表明，本设计的护理床控制器可以实现床体的升降、左右移动、背部抬起等功能，同时还具有安全防护和紧急停止功能。通过对单片机的编程控制，实现了护理床的自动化和智能化，提高了护理工作的效率和质量。
部分代码如下
#include &lt;reg52.h&gt; // 包含头文件，定义单片机寄存器 sbit motor_pin = P1^0; // 电机控制引脚 sbit limit_switch_pin = P1^1; // 限位开关引脚 void delay(unsigned int time) // 延时函数 { unsigned int i, j; for (i = 0; i &lt; time; i++) for (j = 0; j &lt; 120; j++); } void main() // 主函数 { while (1) // 无限循环 { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c94b59ec01a435daa4c69b7ceeca648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50841c44b0137186f5a111b63aae46b8/" rel="bookmark">
			【Linux基础】Linux主要指令的详解（指令补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.cp指令（重要） 语法： cp [选项] 源文件或目录 目标文件或目录
功能: 复制文件或目录
说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息
常用选项：
-f 或 --force 强行复制文件或目录， 不论目的文件或目录是否已经存在
-i 或 --interactive 覆盖文件之前先询问用户
-r递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录 或符号链接，则一律视为普通文件处理
-R 或 --recursive递归处理，将指定目录下的文件及子目录一并处理
我先用rm指令删除了test.c
-r选项是递归删除当前目录文件及它里面包含的一些递归式的文件，加上-f可强制删除，无需确认是否删除。
经过这样一操作就把这个文件给拷贝到指定目录下。
cp指令在路径之后还可继续跟着文件名，意思是可以把拷贝的文件名换成指定文件名。
2.mv指令（重要） mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命
令，经常用来备份文件或者目录。
语法: mv [选项] 源文件或目录 目标文件或目录
功能:
1. 视mv命令中第二个参数类型的不同（是目标文件还是目标目录）， mv命令将文件重命名或将其移至一个新的目录中。
2. 当第二个参数类型是文件时， mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。
3. 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个， mv命令将各参数指定的源文件均移至目标目录中。
常用选项：
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖
mv指令比较重要，但也很简单就能记忆，就是用来移动文件的。
mv指令其实就相当于Windows系统下的剪切功能。
mv指令也是可以进行剪切的同时进行重命名。
3.cat指令 语法： cat [选项][文件]
功能： 查看目标文件的内容
常用选项：
-b 对非空输出行编号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50841c44b0137186f5a111b63aae46b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749169c854f6f00a4633d61911bf016a/" rel="bookmark">
			工业相机——帧率和曝光（快门）之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 项目场景2 技术背景3 帧率和快门时间计算方式 1 项目场景 工业相机是常用与工业视觉领域的常用专业视觉核心部件，拥有多种属性，是机器视觉系统中的核心部件，具有不可替代的重要功能。
工业相机已经被广泛应用于工业生产线在线检测、智能交通,机器视觉,科研,军事科学,航天航空等众多领域
工业相机的主要参数包括:分辨率、帧率、像素、像元尺寸、光谱响应特性等，本文主要介绍工业相机的帧率和它的曝光之间的关系。
工业相机帧率：相机采集传输图像的速率,对于面阵相机一般为每秒采集的帧数(Frames/Sec.),对于线阵相机为每秒采集的行数(Hz)。
工业相机曝光：曝光是图像传感器进行感光的一个过程，相机曝光时间，也就是快门速度，曝光即曝光时间控制，控制感光元件上总的光通量。曝光越大，光通量越大。在数码相机中，可以采用电子快门，也可以采用传统的机械快门。快门速度和光圈大小是互补的。
2 技术背景 在工业相机中，帧率和曝光是相互依存的参数，影响着拍摄图像的质量。
帧率是指工业相机在一秒钟内捕获的视频帧的数量。它对于需要实时视频监控或快速移动物体跟踪的应用非常重要。更高的帧率可以提供更流畅的视频播放，但可能会减少曝光时间，并影响图像的亮度和清晰度。
另一方面，曝光决定了相机传感器捕捉到的光量。较长的曝光时间允许更多的光线进入传感器，产生更明亮的图像，但如果相机或场景中的物体在移动，也可能引入运动模糊或图像噪音。
因此，设置最佳帧率和曝光需要在为实时应用捕捉足够的帧数和获得足够的光量以获得清晰的图像质量之间找到最佳平衡。根据具体的应用要求，不同的工业相机可能有不同的调整帧率和曝光的能力和设置。
本文将以Baumer工业相机作为案例研究工业相机帧率和曝光之间的关系。
3 帧率和快门时间计算方式 工业相机的帧率和曝光快门时间之间的计算是基于以下公式。
快门时间=1/帧率
例如，如果工业相机的帧率是每秒30帧（fps），那么快门时间的计算方法是：。
快门时间 = 1 / 30帧 = 0.0333秒=33.3毫秒=33300微秒
相反，如果所需的快门时间是已知的，相应的帧率可以使用相同的公式计算。
注意：这种计算方式是基于最基础的数学公式来计算的，可以作为参考，工业相机实际的帧率涉及的因素较多，一般以实际测试结果为准。
很多工程技术人员对于工业相机可能会有下面类似疑问
是否可以简单通过曝光快门时间计算出相机帧率？
不可能简单地从快门时间计算出工业相机的帧率，因为帧率取决于各种因素，如曝光时间、读出时间、图像传输率和相机接口带宽。
帧率可以通过用每秒拍摄的帧数除以曝光时间加上读出时间来计算。
此外，相机规格表或手册通常提供给定相机配置的最大可实现的帧率，这对确定相机的整体性能很有用。
https://blog.csdn.net/xianzuzhicai/article/details/129483022
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407a357471b4d941f47a2f360231b08f/" rel="bookmark">
			工业相机——输出图像格式 RAW、RGB、YUV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.RAW（或RAW RGB）2.RGB3.YUV Output Format输出格式 1.RAW（或RAW RGB） CMOS图像传感器输出的原始图像格式是RAW。RAW图像就是CMOS图像感应器将捕捉到的光源信号转化为数字信号的原始数据。RAW文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些原数据（Metadata，如ISO的设置、快门速度、光圈值、白平衡等）的文件。RAW是未经处理、也未经压缩的格式，可以把RAW概念化为“原始图像编码数据”或更形象的称为“数字底片”。
2.RGB RGB565，每个像素用16位表示，RGB分量分别使用5位、6位、5位（常用也就是上说的RGB）。
RGB555，每个像素用16位表示，RGB分量都使用5位（剩下1位不用）。
RGB24，每个像素用24位表示，RGB分量各使用8位。
RGB32，每个像素用32位表示，RGB分量各使用8位（剩下8位不用）。
ARGB32，每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）。
3.YUV YUV三个字母中，其中"Y"表示明亮度（Luminance或Luma），也就是灰度值。而"U"和"V"表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。YUV存储格式有两大类，planar（平面格式）和packed（打包格式）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5cf21d753cae2051e1784ce0fef46ae/" rel="bookmark">
			基于神经网络的手写汉字提取与书写评分系统研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关源码和文档获取请私聊QQ:3106089953
论文目录结构 目 录 摘 要 I Abstract II 目 录 IV 第1章 绪论 1 1.1. 研究背景与意义 1 1.2. 国内外研究现状 2 1.2.1. 文本定位技术研究现状 2 1.2.2. 手写汉字识别研究现状 3 1.2.3. 汉字书写质量评价方法研究现状 4 1.3. 本文所做工作 4 1.4. 论文结构安排 5 第2章 系统需求分析及概要设计 6 2.1. 可行性分析 6 2.2. 系统用例分析 7 2.2.1. 用例表设计 7 2.3. 功能需求分析 9 2.4. 性能需求分析 10 2.5. 系统总体设计 10 2.5.1. 系统总体架构设计 10 2.5.2. 系统功能模块设计 12 2.6. 相关技术介绍 13 2.6.1. Android系统 13 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5cf21d753cae2051e1784ce0fef46ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e9b345d7e794c6d3dcd012224a2ba8/" rel="bookmark">
			3D 建模中的 GLTF、USDZ 和 GLB 3D 文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线工具推荐： 3D数字孪生场景编辑器 - GLTF/GLB材质纹理编辑器 - 3D模型在线转换 - Three.js AI自动纹理开发包 - YOLO 虚幻合成数据生成器 - 三维模型预览图生成器 - 3D模型语义搜索引擎 3D 建模是一个快速发展的领域，它使我们能够为各个行业创建错综复杂的对象和环境模型。要创建 3D 模型，第一步是选择可以存储模型数据的文件格式。在本文中，我们将讨论 GLTF、USDZ 和 GLB 文件格式及其在 3D 建模中的重要性。
什么是 GLTF、USDZ 和 GLB 文件格式？ GLTF系列 GL 传输格式 （GLTF） 是一种用于存储 Khronos Group 创建的 3D 模型的文件格式。它被设计为一种轻量级格式，可以通过 Web 浏览器和 3D 引擎轻松加载和渲染。GLTF 格式使用 JSON（JavaScript 对象表示法）来描述模型的结构，并以二进制格式存储模型的几何形状、材料、纹理和动画。
USDZ 通用场景描述（USD）是由皮克斯动画工作室开发的一种文件格式，用于在不同的3D应用程序之间存储和交换3D数据。USDZ 是 USD 格式的变体，专为 AR（增强现实）内容创作而设计。USDZ 文件可以包含 3D 模型、动画和纹理，并且可以轻松集成到 iOS 设备上的 AR 应用程序中。
GLB系列 GLB 是一种二进制文件格式，用于以 GLTF 格式存储 3D 模型。GLB 文件在单个文件中包含渲染 3D 模型所需的所有数据，包括几何图形、材质、纹理和动画。这使得跨不同平台传输和加载 3D 模型变得容易。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e9b345d7e794c6d3dcd012224a2ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea2767fdc7ffca0ff3865d3ca50bcd4/" rel="bookmark">
			专业课128分总分400&#43;南京理工大学818信号系统与数字电路南理工考研经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专业课128分总分400+南京理工大学818信号系统与数字电路南理工电光院考研经验分享，希望自己的经历对大家有借鉴。
我是在六月底确认自己保不上研然后专心备考的，时间确实比较紧张。虽然之前暑假看了一点高数，但因为抱有保研的期望，所以没怎么认真准备。
首先是数学部分，因为时间紧，所以直接就上了强化课程。高数跟的是武忠祥老师的强化课程，用的就是《高数辅导讲义》，只有辅导讲义配套的严选题全部做完了，660和880只找了一小部分自己比较薄弱的部分做。线代跟的是李永乐老师的强化课，只做了线代辅导讲义上的题。听老师课的时候，我一直是基础知识部分在讲义上直接勾画补充，例题部分先自己做一下，然后再听老师讲一遍，老师没讲的题就自己对照答案核对一下，个人感觉效果还不错。9-10月份两个月完成了高数的强化，然后在10.28日开始做往年的真题，先挑往年平均分比较高的年份也就是比较简单的做，然后再做比较难的，毕竟自己基础不怎么牢。做完之后一定要将错题总结，这很重要，我往前做了20年的真题，上午限时三小时做的。11.24开始做各种模拟卷，首先做的是李林6套卷，然后是张宇8套卷高分版（只做了前4张），李林4套卷，张宇4套卷，最后在考前刷了两张之前留下来没做的真题卷，复习了前面整理的错题和笔记，然后就到考试时间了。考场上感觉很得心应手，出来131感觉比心理预期少了四五分的样子，但由于没核对答案，所以还可以吧，没准比自己预估多错了道小题呢。
英语部分，我只做了英语一英语二从10年开始的真题，先是10年-21年英语二真题的客观题部分，毕竟决定命运的大头在客观题，前期每天只做两三篇，做完之后对照翻译和答案一点一点的抠，绝对不能只是简简单单地过一下，过完英二之后把英语一客观题用同样的方法刷了一遍，然后又把英语二真题二刷了一遍，第一遍的精读之后二刷就几乎没有错的了。经过前面客观题对照译文认真阅读，翻译题其实已经把基础打好了，然后就只是把10年以来的英二翻译题做一遍，再认真核对答案，揣摩一下得分点。作文我是从11月中旬开始的，看了潘赟的九宫格作文，以及王江涛的考研高分作文写作（主要是看作文结构以及往年的作文真题）和王江涛考前20篇作文预测，整理了适合自己的作文模板，比如怎么开头引入，中间端怎么写，怎么结尾的套路句子。哦对还有单词，我自己是一个做题不怎么吃单词量的人，就是只要核心词汇是认识的，就差不多能读懂能够做题，所以我只背了红宝书上的高频必考词，使用了实体书+不背单词APP搭配的方法，第一遍对着书背，然后在APP上检查记忆效果，背完一千多个高频必考词之后，就只使用APP进行复习了。最后能考到英二90的分数自己也没想到。
政治部分，作为一个纯正的理工科，外加大学思政课都是考前突击，个人只有初中思政基础，所以前期感觉还是比较担心的。9月6号开始准备政治，前期是徐涛的课搭配肖秀荣的精讲精练和1000题（1000题除了书上做一遍，我还用小程序刷了一遍），一直慢慢地刷课看书做题，全部过完就已经是11.25了，肖八到了但是基础还没过完的那一段时间真的很着急，现在想想也没什么可着急的，按照自己的速度走就行，毕竟只有肖四的大题需要背。基础过完后，就按照大家都会有的步骤，开始刷肖八，在肖四到手之前，闲着没事又刷了徐涛腿姐等一系列比较有名老师预测卷的选择题，肖四到手已经是12.8了，一到手就开始刷选择题，每天背两道大题，选择题刷完之后进行了肖八肖四的二刷和做其他一些老师的选择题，搭配需要背的肖四大题。肖四第一遍是按照一张卷子一张卷子背的，然后又把同类题放在一起背了第二遍，考前又突击了一下背了第三遍，然后就上考场了。
专业课818信号系统与数字电路
南理工专业课是两门，信号和数电，大家一定要重视，这两年难度在提高，由于两门专业课都需要同等对待，自然时间上也安排好。由于我是跨学校报考，按上岸前辈的建议，直接参加了信息通信Jenny老师的专业课辅导，学长也是参加过，非常推荐Jenny老师，我也是先去b站看了很多老师分享的视频，感觉老师讲课谈吐清晰，思路严密，能把很多问题深入浅出，顺着我们的学习思维讲透，听课效率很高，就果断报名了，实事证明，老师课程比我想象的还要好，毕竟b站上只是一些零散的知识点和题目分享，课程才是体系和完整的，两门课安排100多课时，全部干货，定期的模考测评，慢慢的也让我专业有了信心，不断发现问题解决问题。所以对于报考南理工818的同学，还是建议先去b站看看Jenny老师分享的视频。有条件尽量参加老师专业课辅导。
Jenny老师课程安排也非常合理，每次课从知识点引入到数学模型推导证明，到物理意义的深入讲解，再到考研怎么去解题，运用整合在一起，非常高效，说到这，还是给老师课程点赞，边学边做，现学现用，非常切合考研。
我简单总结一些自己对专业课复习的看法，先看信号系统，我们把他分为两部分:连续和离散连续信号、时域分析（微分方程)、连续信号的频域变换手段(fourier变换Laplace变换)、频域分析离散信号、时域分析（差分方程)、离散信号的频域变换手段（z变换，DTFT)，频域分析单独的两章:信号的采样和状态方程很容易看到连续和离散是互相对应的，学的时候先学连续，学完连续再学离散，不然会弄混。我的建议是能用频域分析就别用时域分析，频域分析的意义就是把时域复杂的解方程变成乘法运算，以后学了就理解了。相互等价的东西:电路图-微分方程-系统函数-信号流图，他们是互推的，这个一定要掌握，熟练应用能简化计算。F，L，z三大变换要记的东西很多，里面有很多性质，不能搞混，用小本本记下来，多用印象就深了。
接下来数电，数电的知识点杂散很多，各种什么器，但是你只要认全了，数电的计算量是很小的，麻烦的是穷举，做起来会比较折磨。前面是基本概念，数制转换，基本码(8421，BCD之类的)，与或非，逻辑运算公式，标准形式，卡诺图，真值表（整整这一大章都是打基础，给后面设计电路准备的)接下来两大块重点:组合电路有编码器、译码器、七段显示译码器、数据分配器、数据选择器、加法器、比较器时序电路有锁存器、触发器、计数器、寄存器，各种集成的非集成的，同步还是异步。555定时器，由它组成的三种电路(Schmitt，单稳态，多谐)最后有比较杂的两章，逻辑门电路和ROM，这两章没啥方法，就是背，记住了认识电路就行，占分不大，还有一章AD转换器需要了解。设计题这类最难的题目直接跟Jenny老师课程就可以，各种类型设计都有，最优，最简，最小化，给定期间设计等等，做多了，自然心里有底。
一年的努力换来南理工的录取通知，一切付出都是值得的，希望大家可以通过自己的努力取得考研圆满成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30cc2115e11bca56deb1fbeaff21eb1/" rel="bookmark">
			OCS2 入门教程（四）- 机器人示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 前言 OCS2 包含多个机器人示例。我们在此简要讨论每个示例的主要特点。
System
State Dim.
Input Dim.
Constrained
Caching
Double Integrator
2
1
No
No
Cartpole
4
1
Yes
No
Ballbot
10
3
No
No
Quadrotor
12
4
No
No
Mobile Manipulator
6-13
6-13
Yes
Yes / No
Legged Robot
24
24
Yes
No
对于所有这些机器人示例，有两个独立的软件包：
ocs2_&lt;robot&gt;： 提供机器人专用 MPC 实现库。ocs2_&lt;robot&gt;_ros： 用 ROS 封装 MPC 实现，以定义 ROS 节点。 一、Double Integrator 双积分器示例是我们最简单的问题。它模拟了一个沿 x 方向移动的一维点质量。模型是线性的，成本函数是二次函数。目标点通过参考管理器模块设置为二次成本。
# Build the example catkin build ocs2_double_integrator_ros # Source workspace # Do not forget to change &lt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e30cc2115e11bca56deb1fbeaff21eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d59f7bad8523f533e295ebabb33a63fd/" rel="bookmark">
			华为机试（Python）真题Od【A卷&#43;B卷&#43;C卷&#43;D卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各语言题库： 【Python+JS+Java合集】【超值优惠】：Py/JS/Java合集
【Python】：Python真题题库
【JavaScript】：JavaScript真题题库
【Java】：Java真题题库
【C++】：C++真题题库
【C语言】：C语言真题题库
【面试手撕代码题库】：面试手撕代码题库
集中答疑： 0：全网最全题库，400+题目。
1：考试链接上写着【A卷】，对应的就是OD统一考试A卷目录的题目。
2：考试链接上写着【B卷】，对应的就是OD统一考试B卷目录的题目。目前B卷的题目由一部分以前考过的旧题库的题目+一部分全新题目（之前没考过的）题目组成。
3：考试链接上写着【C卷、D卷】。目前由A+B卷的旧题 + 全新题目组成。也就是说C卷和D卷还会考到A+B卷的题目，比例大概是新题1道，旧题2道。
4：【C卷、D卷】的新题有一个特殊点，就是无需自己处理输入和输出，为leetcode模式，实现对应函数逻辑即可。
5：机试没过，半年的冷冻期。
6：订阅专栏后，专栏内所有的文章都可以看，以后再更新新的题目也可以看，每年更新的题目都会更新到一个专栏里面。
7：文章内均有题目+思路+代码。
8：已经订阅过我专栏的同学，推荐新人订阅的可享 8折 优惠，私信我即可！
OD统一考试【C卷题库】 2023Q4新题库【更新中】
（目录可能更新不及时，可以直接搜我的博客）
序号题目考点分值时间1山脉的个数数据结构2002023Q42数据单元的变量替换字符串处理1002023Q43密码输入检测字符串处理1002023Q44找出作弊的人自定义排序1002023Q45转盘寿司单调栈2002023Q46体育场找座位逻辑分析1002023Q475G网络建设并查集2002023Q48中庸行者BFS/DFS2002023Q49会议室占用时间段逻辑模拟1002023Q410小华地图寻宝BFS/DFS2002023Q411CPU算力分配逻辑分析1002023Q412高效货运贪心算法1002023Q413小明的幸运数逻辑模拟1002023Q414跳马问题BFS/DFS2002023Q415掌握单词的个数数据结构1002023Q416计算三叉搜索树的高度树遍历2002023Q417来自异国的客人/幸运数字进制转换1002023Q418石头剪刀布游戏逻辑分析1002023Q419园区参观路径BFS/DFS1002023Q420多线段数据压缩数学知识2002023Q421开源项目热度榜单自定义排序1002023Q422API集群负载统计数据结构1002023Q423机场航班调度自定义排序1002023Q424小明找位置二分法1002023Q425最优的投资方式逻辑分析1002023Q426分配土地数据结构1002023Q427最多购买宝石数目滑动窗口1002023Q428王者荣耀游戏分组回溯算法1002023Q429执行任务赚积分逻辑模拟1002023Q430智能成绩表自定义排序1002023Q431内存冷热标记自定义排序1002023Q432最富裕的小家庭数据结构1002023Q433机器人搬砖二分法1002023Q434剩余银饰的重量逻辑模拟1002023Q435分割均衡字符串逻辑模拟1002023Q436分披萨回溯法1002024Q137员工派遣二分法+数学2002024Q138测试用例执行计划自定义排序1002024Q139伐木工贪心算法1002024Q140快递员的烦恼 / 快递员最短路径BFS/DFS1002024Q141跳格子3动态规划2002024Q142堆内存申请自定义排序1002024Q143符号运算/求分数计算结果数据结构2002024Q144反射计数逻辑模拟1002024Q145路口最短时间问题BFS/DFS2002024Q146小扇和小船的数字游戏进制问题1002024Q147亲子游戏BFS/DFS2002024Q148传递悄悄话数据结构1002024Q149特殊的加密算法BFS/DFS1002024Q150贪吃的猴子双指针法1002024Q151结对编程逻辑模拟2002024Q152幸存数之和逻辑模拟1002024Q153电脑病毒感染图计算2002024Q154部门人力分配二分法2002024Q155分解正整数数学知识1002024Q156围棋的气数据结构1002024Q157小朋友来自多少小区贪心算法1002024Q158宽度最小的子矩阵滑动窗口1002024Q159智能驾驶​​​​​​​BFS/DFS2002024Q160目录待更新~~题目已经有了 OD统一考试【B卷】题库 序号题目考点分值时间1宜居星球改造计划数据结构2002023Q2 2
需要打开多少监视器
逻辑分析1002023Q23最佳植树距离逻辑分析1002023Q24阿里巴巴找黄金宝箱前缀和2002023Q25选修课数据结构1002023Q26五子棋迷逻辑分析1002023Q27代表团坐车动态规划1002023Q28座位调整逻辑分析1002023Q29食堂供餐二分法1002023Q210寻找最大价值的矿堆DFS1002023Q211最长公共后缀逻辑分析1002023Q212模拟消息队列逻辑分析1002023Q213比赛数据结构1002023Q214告警抑制逻辑分析1002023Q215报文重排序字符串处理1002023Q216字符串摘要字符串处理1002023Q217稀疏矩阵逻辑分析1002023Q218AI 识别面板数据结构1002023Q219报文回路数据结构1002023Q220阿里巴巴找黄金宝箱 II数据结构1002023Q221阿里巴巴找黄金宝箱 III数据结构1002023Q222阿里巴巴找黄金宝箱 IV单调栈2002023Q223文件目录大小DFS1002023Q224组装最大可靠性设备动态规划2002023Q225找出两个整数数组中同时出现的整数数据结构1002023Q226通过软盘拷贝文件动态规划2002023Q227代码编辑器逻辑分析2002023Q228数据分类进制问题1002023Q229恢复数字序列滑动窗口1002023Q230阿里巴巴找黄金宝箱 V滑动窗口1002023Q231比赛的冠亚季军排序算法1002023Q232数字游戏逻辑分析1002023Q233经典屏保逻辑分析1002023Q234字符串化繁为简字符串处理2002023Q235数据最节约的备份方法二分法1002023Q236跳格子2逻辑分析1002023Q237跳房子2数据结构1002023Q238支持优先级的队列数据结构1002023Q239乘坐保密电梯回溯法1002023Q240计算最接近的数逻辑分析1002023Q241人气最高的店铺逻辑分析1002023Q242战场索敌DFS2002023Q243二维伞的雨滴效应二叉树1002023Q244跳房子I数据结构1002023Q245分割数组的最大差值逻辑分析1002023Q246生日礼物二分法1002023Q247求最小步数逻辑分析1002023Q248拔河比赛数据结构1002023Q249评论转换输出递归法2002023Q250树状结构查询数据结构2002023Q251不开心的小朋友逻辑分析2002023Q252数字序列比大小逻辑分析2002023Q253符合要求的元组个数 / K 数之和回溯法1002023Q254最小循环子数组KMP算法2002023Q255金字塔 / 微商的收入数据结构1002023Q256矩阵元素边界值字符串处理1002023Q257MELON的难题动态规划2002023Q258矩阵中非1的元素个数BFS2002023Q259计算误码率逻辑分析2002023Q260增强的strstr正则匹配1002023Q261关联子串字符串处理1002023Q262计算礼品发放的最小分组数目双指针1002023Q263字符匹配正则匹配1002023Q264最小传输时延I Dijkstra算法2002023Q265一种字符串压缩表示的解压正则匹配1002023Q266冠亚军排名排序方法1002023Q267报数游戏逻辑分析1002023Q268找出经过特定点的路径长度逻辑分析1002023Q269按单词下标区间翻转文章内容字符串处理1002023Q270数列描述逻辑分析1002023Q271字符串筛选排序排序方法1002023Q272相对开音节正则匹配1002023Q273字符串变换最小字符串字符串处理1002023Q274VLAN资源池数据结构1002023Q275拼接URL字符串处理1002023Q276执行时长/GPU算力逻辑分析1002023Q277荒岛求生数据结构2002023Q378查字典字符串处理1002023Q379周末爬山BFS2002023Q380最小数字排序方法1002023Q381最长的元音子串字符串处理1002023Q382TLV解析II数据结构1002023Q383玩牌高手逻辑分析2002023Q384最长连续子序列滑动窗口1002023Q385路灯照明II区间合并1002023Q386最多团队排序方法1002023Q387最长的顺子数据结构1002023Q388数字最低位排序排序方法1002023Q389整数编码字符串处理1002023Q390找车位逻辑分析1002023Q391选举拉票线段树2002023Q392单词加密字符串处理1002023Q393购物优先级队列2002023Q394最佳的出牌方法逻辑分析2002023Q395字符串划分数据结构1002023Q396洞穴探险字符串处理1002023Q397最大岛屿体积BFS1002023Q398DNA序列滑动窗口1002023Q399服务启动DFS1002023Q3100最长公共前缀字符串处理1002023Q3101查找舆情热词数据结构1002023Q3102排队游戏二分法2002023Q4103BOSS的收入数据结构1002023Q4104猴子吃桃二分法1002023Q4105滑动窗口最大值滑动窗口1002023Q4106全排列数学问题1002023Q4107编码能力提升计划逻辑处理2002023Q4108水果摊小买卖贪心算法1002023Q4109正整数到excel编号的转换进制转换1002023Q4110反转每对括号间的子串数据结构1002023Q4111模拟工作队列数据结构2002023Q4112删除字符串中出现次数最少的字符字符串处理1002023Q4 2023Q2 旧题目
序号题目考点分值时间1 德州扑克
数据结构2002022Q1+2023 2
字符串子序列 II
字符串处理1002022Q1+20233 分苹果
位运算1002022Q1+20234 事件推送
数据结构1002022Q1+20235 路灯照明
逻辑模拟1002022Q1+20236 补种未成活胡杨
滑动窗口1002022Q1+20237 统计射击比赛成绩
排序算法1002022Q1+20238 高矮个子排队
排序算法2002022Q1+20239 非严格递增连续数字序列
双指针1002022Q1+202310 最大股票收益
贪心算法2002022Q1+202311 找朋友
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d59f7bad8523f533e295ebabb33a63fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e301ac56bd782afb786a4b4ee79e7639/" rel="bookmark">
			八股文打卡day22——操作系统（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 面试题：什么是死锁？如何避免死锁？ 我的回答： 死锁是两个或者多个进程都占有各自的资源，然后都互相请求资源，导致互相都陷入了阻塞状态。
如何避免死锁呢？
首先，造成死锁有四个必要条件：
1.互斥条件
当一个进程占用某个资源的时候，其他进程是不可能再占用这个资源的。
2.不可剥夺条件
当一个进程占用某个资源时，无法直接剥夺他占用的资源，只能由其主动释放。
3.请求保持条件
当一个进程占用部分资源，然后又请求某些资源时，会占用已有资源，然后进入阻塞状态等待。
4.环路等待条件
多个进程形成一个循环等待的链条，每个进程都在等待下一个进程释放其所占用的资源。
要想避免死锁，就要打破造成死锁的这四个必要条件之一即可：
1.打破不可剥夺条件
设置请求倒计时，当一个进程请求一个资源，超过这个倒计时，会强制回收其所占用的资源，让其终止或者重新申请。
2.打破请求保持条件
一次性分配所有的资源给进程，避免占用部分资源，再去申请其他资源，造成循环等待。
3.打破环路等待条件
让多个进程按顺序申请资源，然后反序释放资源。
其他一些避免死锁的策略有：
1.资源分配图
通过资源分配图来检测死锁是否存在
2.死锁检测与恢复
完全避免死锁几乎不可能，而且代价太大，所以可以对死锁现象进行检测，检测到了，再采取必要的恢复策略。如：终止某些进程或回滚操作。
回答八股的时间：2024.01.06 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bf4f99b335307c017c66ccd0b0a785/" rel="bookmark">
			基于缺陷模式的软件测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于缺陷模式的软件测试是一种常见的软件测试方法，旨在发现和识别软件系统中可能存在的缺陷模式。它通过分析过去的软件缺陷数据，构建缺陷模式库，并基于这些模式来设计测试用例。
该方法的基本步骤如下：
收集缺陷数据：开始之前，需要收集已知的软件缺陷数据。这可以包括已报告的缺陷、错误日志、用户反馈等。
缺陷模式识别：在收集到足够的缺陷数据后，可以进行缺陷模式的识别。通过对缺陷进行分类和分析，可以发现一些共同的特征和模式。
构建缺陷模式库：基于已识别的缺陷模式，可以构建一个缺陷模式库。该库可以包含缺陷模式的描述、示例和相关的测试用例。
设计测试用例：根据缺陷模式库，设计测试用例来覆盖已识别的缺陷模式。这些测试用例应该能够模拟实际的软件使用情况，并尽可能地触发已知的缺陷模式。
执行测试用例：执行设计好的测试用例，并记录测试结果。如果测试用例能够触发已知的缺陷模式，那么就可以确认软件中存在相应的缺陷。
分析测试结果：对测试结果进行分析，确定是否存在新的缺陷模式或者已知缺陷模式的变体。如果发现新的缺陷模式，可以将其添加到缺陷模式库中。
基于缺陷模式的软件测试方法可以帮助测试人员更有效地发现和识别软件系统中的缺陷。它通过利用历史数据和已知的缺陷模式，提供了一种系统化的测试方法，有助于提高软件质量和可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a39ec59fe35d642a82725f0bfd1810b8/" rel="bookmark">
			线性代数 --- 为什么LU分解中的下三角矩阵L的主对角线上都是1?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么LU分解中的下三角矩阵L的主对角线上都是1? 笔者的一些话：
为什么LU分解中L矩阵的主对角线上都是1？因为最近一段时间在研究LU分解的编程实现，这个问题也就时不时的从我脑子里面冒出来。但大多时候都是一闪而过，没有太在意。有时候，查了一些资料后，明白了，或者是当时明白了，又或者是似乎明白了，没过多久又忘了。索性趁着这两天有空，干脆写一篇CSDN记录下来，自己以后要看了，就回来翻翻。
正文：
一方面，对于LU分解而言，下三角阵L是对高斯消元过程的记录，是高斯消元的逆过程，是多个消元矩阵E的逆矩阵的乘积(形如下图中的下三角矩阵)，即：
另一方面，根据矩阵的乘法原则两个矩阵A和B的乘积C中的元素，来自于矩阵A中第i行元素与矩阵B中第j列元素的乘积。下图是我引用的维基百科中一个4x2矩阵A和一个2x4矩阵B的乘法的说明图。
如图，在本例中矩阵C中的元素源自于矩阵A第一行和矩阵B第二列的乘积。 如果把这个规律放到一系列消元矩阵的逆矩阵(且是方阵)的乘法运算中就会发现，在计算L矩阵中主对角线上元素时，其他部分的乘积都是0，最终只剩下主对角线上对应位置的乘积为1。
例如：
以4x4矩阵为例，不论这两个矩阵中的X和Y是多少，主对角线上的元素一定是1。我们以的计算为例(其他也相仿)，他等于前一个矩阵的第2行，乘以后面矩阵的第2列：
（全文完）
作者 --- 松下J27 参考文献(鸣谢)：
1，https://en.wikipedia.org/wiki/Matrix_multiplication
2，线性代数 --- LU分解（Gauss消元法的矩阵表示）_矩阵的lu分解-CSDN博客
（配图与本文无关） 版权声明：所有的笔记，可能来自很多不同的网站和说明，在此没法一一列出，如有侵权，请告知，立即删除。欢迎大家转载，但是，如果有人引用或者COPY我的文章，必须在你的文章中注明你所使用的图片或者文字来自于我的文章，否则，侵权必究。 ----松下J27
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3848413e1d69ba6522dcdea8cc883c/" rel="bookmark">
			时间戳长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线工具
时间戳分秒和毫秒，秒返回的是10位数字，毫秒返回的是13位数字
无论用那种语言，时间戳都是一样的，使用的时候需要注意下长度即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ac506642ddc5dce958a692e73681cb/" rel="bookmark">
			Linux下的tar命令打包与解压：打包到根目录：将文件或文件&#43;目录打包到第一层（×）、打包到子目录：将文件或文件&#43;目录打包到第二层，在第一层包裹一层目录（√）（打包规范、压缩包规范、压缩规范）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux下的打包与解压：对比分析与最佳实践1. `tar`命令概述2. 不同的打包方式对比2.1 打包到根目录2.2 打包到子目录 3. 解压过程中可能出现的问题与影响3.1 文件混乱3.2 文件覆盖3.3 不便于管理 4. 最佳实践5. 结论 Linux下的打包与解压：对比分析与最佳实践 在Linux环境中，处理文件打包与解压是常见的任务。正确使用tar命令能够有效地提高工作效率，并避免可能出现的问题。本文将通过实例详细比较两种不同的打包方式，并讨论在解压过程中可能出现的问题及其影响。
1. tar命令概述 tar（Tape Archive）命令是Unix/Linux系统中非常常用的归档工具，它可以将多个文件或目录打包成一个文件，并支持各种压缩功能。以下是其基本语法：
tar [options] [archive-file] [file or dir to be archived] 其中，“options”是命令选项，“archive-file”是你想要创建的存档文件，“file or dir to be archived”则是待打包的文件或目录。
2. 不同的打包方式对比 2.1 打包到根目录 在这种方式中，所有文件都被打包到.tar或.tgz文件的根目录下。例如，有三个文件：file1.txt、file2.txt 和 file3.txt，可以使用以下命令将它们打包到一个名为"archive.tgz"的文件中：
tar -czvf archive.tgz file1.txt file2.txt file3.txt 2.2 打包到子目录 在这种方式中，所有文件都被打包到一个名为归档文件名的子目录中。使用相同的例子，可以使用以下命令将它们打包到"archive"目录下的"archive.tgz"文件中：
mkdir archive &amp;&amp; cp file1.txt file2.txt file3.txt archive/ tar -czvf archive.tgz archive/ 3. 解压过程中可能出现的问题与影响 3.1 文件混乱 如果采用第一种方式，解压后的文件会直接放在当前工作目录下，可能导致文件混乱，尤其是当归档文件中有大量文件或者和工作目录中的文件有重名情况时。
想必在windows上你可能遇到过这种情况，从网上下载了一个.rar或.zip的压缩包，放到windows桌面，然后我们对它右键–&gt;解压到当前文件夹，因为打包的人使用的是第一种方式，打包了大量的文件到第一层，于是解压时，大量文件被直接解压到了我们桌面上，而不是某个目录中，然后我们只能慢慢清理桌面上的文件了 - -||
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ac506642ddc5dce958a692e73681cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd38eab765744ae80df30049b1b8aa1a/" rel="bookmark">
			创建VScode的C/C&#43;&#43;编译环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建VScode的C/C++编译环境 安装软件json文件 安装软件 可以选择安装Dev-Cpp、BlockCode或者MinGW。这里选择了Dev-Cpp。
json文件 launch.json
{ "version": "0.2.0", "configurations": [ { "name": "（gdb) Launch", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "program": "${workspaceFolder}/${fileBasenameNoExtension}.exe",// 将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "${workspaceFolder}", // 调试程序时的工作目录，一般为${workspaceFolder}即代码所在目录 "environment": [], "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "MIMode": "gdb", "miDebuggerPath": "C:\\Program Files (x86)\\Dev-Cpp\\MinGW64\\bin\\gdb.exe", // miDebugger的路径，注意这里要与MinGw的路径对应 "preLaunchTask": "g++.exe build active file", // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc. 和tasks中label保持一致 "setupCommands": [ { "description": "Enable pretty-printing for gdb"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd38eab765744ae80df30049b1b8aa1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94acd116201e77ac21bb70f30581bea9/" rel="bookmark">
			iOS基础之修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Objective-C @automic：原子的，表示线程安全，目的是确保其他线程不在同一时间内访问相同的资源；
@nonatomic：非原子的，表示线程不安全，可以在不同位置读写属性的值；
@readwrite：编译器会为属性生成get和set方法；
@readonly：编译器只生成get方法；
@protected：缺省，受保护的成员变量；
@public：公开的成员变量；
@private：私有成员变量；
@copy：copy，会重新分配内存；
block分为全局block、堆block和栈block；
方法是在内存的栈区，每个方法都是在被调用的时候从硬盘到内存，然后去执行，执行完就消失；
Objective-C中的类对象（堆区），block（栈区）当使用copy修饰时，系统会把block拷贝到堆区，这样属性就拥有block的所有权保证block不会提前释放；
@weak：不增加引用计数，也不持有对象，ARC中使用，只可修饰对象；RunTime维护了一个weak表，用于存储指向某个对象的所有weak指针，weak表是一个hash table，key为所指对象的地址，value是weak指针的地址数组；
初始化时，RunTime会调用objc_initWeak初始化一个新的weak指针指向对象的地址，添加引用时，objc_initWeak函数会调用objc_storeWeak函数更新指针指向，创建对应的weak table，释放时，调用clearDeallocating根据对象地址获取所有的weak指针地址的数组，遍历数组把数据至空，最后将weak table中这个entry删除并清理对象记录；
在xib/storyboard中的控件使用weak修饰；
@assign：修饰基本数据类型，分配在栈上，由系统分配和释放；
@strong：强引用；
__block：如果可以访问局部变量但是不能修改局部变量可以使用，编译器会将__block变量包装成一个对象，变成对象后就可以根据指针地址在block内部去修改外部的变量；
__strong：对变量强引用；
unsafe_unretained：在所修饰的对象被释放后，该指针就变成了野指针；
@assign：不会使引用计数加1，直接赋值，可修饰对象和基本数据类型；
二、Swift let修饰常量；
var修饰变量；
typealias修饰类型别名；
func修饰函数声明；
inout修饰输入输出参数（copy-in copy-out），函数调用时，参数的值被copy；
函数内部时，copy的值被修改；
函数返回时，copy的值被赋值给原参数；
**_**命名的参数被显式忽略；
**…**参数基本类型名称后紧跟三个点，会被视为可变参数；
mutating自身修改，Enum或extension的方法如果会修改self，需要以mutating标记；
override重写超类中的方法；
static类型方法，如果是class中的方法使用static或class final修饰则不可被重写，class中使用class修饰的方法则可被重写；
throws抛出错误的函数和方法；
rethrows重抛错误的函数和方法；
async异步函数和方法；
Never表示函数或方法不会返回给它的调用者（不归函数）；
Struct结构体声明、Enum枚举声明、Class类声明、Actor声明、Protocol协议声明、extension拓展声明、Associatedtype协议关联类型声明、Subscript下标声明、init构造器声明（init?可失败构造器）、convenience便利构造器；
required子类必须实现；
deinit析构器声明；
operator运算符声明（infix中缀、prefix前缀、postfix后缀），使用于运算符重载；
open所有命名空间可访问、继承和重写；
public所有命名空间内可访问，但其他命名空间不能继承和重写；
internal默认访问级别，可以访问同一命名空间，但其他实体不能访问该实体；
fileprivate文件内私有；
private类私有；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbd2c7adecc78274cdf5e8ed2ef79b4/" rel="bookmark">
			什么是js，js的特点，js的组成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是JavaScript？二、JavaScript的特点三、JavaScript的组成 一、什么是JavaScript？ JavaScript是一种高级的脚本编程语言，通常用于网页开发。它是一门动态类型、面向对象的语言，通过在浏览器中解释运行，实现对网页中元素的交互、动态效果和数据处理等功能。
二、JavaScript的特点 1、弱类型语言
它的语法松散要求不严谨，比如一个变量在之前没有声明的情况下就可以直接使用，声明变量的时候也可以不声明变量的类型等
2、跨平台性
JavaScript是依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持javascript
的浏览器就可正确执行。但是不同浏览器以及同一浏览器的不同版本对JavaScript的支持是不同的
(浏览器的兼容性)
3、安全性
JavaScript不允许访问本地的硬盘，并不能将数据存入到服务器上，不允许对网络文档进行修改和
删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。
三、JavaScript的组成 ECMASctipt：JavaScript语法
由单行注释与块注释（ // 、/**/）、变量、操作符、流程控制语句、数组、对象、函数、正则表达式等构成的标准。目前基本所有的js解释器都可以兼容ECMAScript。
DOM：页面文档对象模型
简单来说就是使用JavaScript操作html的API，是针对XML但经过扩展用于HTML的应用程序编程接口。DOM将整个页面映射成一个多节点结构。
var input=document.getElementsByTagName(“input”); var input=document.getElementById(“input_name”); input.οnclick=function(){} BOM：浏览器对象模型
简单来说就是使用JavaScript操作浏览器的API，开发人员可以使用BOM控制浏览器显示的页面以外的部分。
例如：
弹出新浏览器窗口；移动，缩放，关闭浏览器的功能；
//弹窗 alter("hello world! "); prompt()； confirm()； 四、总结
需要注意的是：只有ECMAScript是标准，也就是在绝大多数浏览器以及js解析器（node）中运行效果相同，但是DOM与BOM是各大浏览器厂商自己提供的API，在使用上大同小异，但是也可能会出现少许不兼容的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28c4bce3fc4901d4dfa7687c905372c/" rel="bookmark">
			车流量识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车流量识别摄像机是一种利用先进的图像识别技术和智能算法来监测道路上车辆数量和流量的设备。通过安装在道路或交通路口的摄像头，可以实时准确地统计车辆的通过情况，进而为交通管理、道路规划以及交通安全提供重要数据支持。
车流量识别摄像机主要通过计算车辆的速度、方向和密度来对车流量进行精准识别。其工作原理是利用高清晰度的视频图像，结合图像处理算法，实现针对道路上运行车辆的自动检测和跟踪，从而识别并记录车辆通过的数量和时间。同时，车流量识别摄像机还可以实现不同车辆类型的识别，如小型车、大型车或者两轮车等，从而更精准地分析车流组成和特征。通过这些数据，交通管理部门可以了解道路的拥堵情况、车辆通行状况和高峰时段的流量变化，以便更好地进行交通管理和规划。车流量识别摄像机在城市交通管理中发挥着重要作用。它可以帮助交通管理部门实时监测道路交通情况，提供数据支持和决策参考，有效缓解交通拥堵、提高交通效率。此外，车流量识别摄像机还可用于监测车辆违规行为，如闯红灯、逆行等，有助于提升交通安全。对于交通控制和智能交通系统而言，车流量识别摄像机更是不可或缺的重要组成部分，有助于实现智能信号灯控制、车辆导航引导和交通信息发布等功能。
总之，车流量识别摄像机的出现为城市交通管理带来了新的思路和技术手段。它以高效、准确和智能的方式实现对车辆流量的识别与监测，为提升交通管理水平和解决交通问题提供了有力支持。相信随着技术的不断进步和应用领域的拓展，车流量识别摄像机在未来会发挥更加重要的作用，为城市交通的发展和改善贡献力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1288fec85b6067abebf6462696b8d254/" rel="bookmark">
			华为HCIA课堂笔记第四章 网络层协议与IP编址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 网络层协议与IP编址 4.1 IP报文格式 版本（version）：表示该IP协议的版本号，取值0100即4，为IPV4
头部长度：表示IP协议头部长度（不固定长度：20B固定，0-40B不固定）
服务类型：ToS字段，区分服务字段。该字段主要用于Qos（服务质量）
总长度：IP头部与数据部分之和
标识（Identifier）：用于数据包分和重组，分片后的多个IP报文如果标识相同，则表明这些报文原来于同一个分片前的报文。
标志位：
DF比特位：不分片位，置1表示该报文不可以进行分片MF比特位： 置位0，该分片报文是最后一个分片报文。置位1，则表示该分片报文后还有其他的分片报文。 片偏移字段：用于重组报文，重组时分片报文中的该字段值表示分片报文携带的数据部分起点距离原始报文起点的距离。
TTL值：用于防环，取值范围0-255。三层设备收到报文后，如果IP地址不是自己的，转发该报文，转发时，将TTL值减1，每一个三层设备都如此进行，最终TTL将为0，设备收到TTL值为0的报文，直接丢弃不进行转发。
协议字段：用于标识上层协议的，以下为上层协议与该字段取值关系：
TCP：取值6UDP：取值17IGMP（因特网组管理协议）：取值为2ICMP（英特网控制消息协议）：取值为1 头部校验和：用于头部校验
源IP地址：报文的来源
目的IP地址：报文要去的目的
Option字段：可变长字段（0-40B），携带可选的功能字段。
Padding字段：如果携带Option字段，则通过Padding字段将IP头部填充到4B整数倍。
总结：IP头部由固定部分和不固定部分组成，固定部分长度20B，不固定部分是Option部分，长度是0-40B，即IP报文头部最短是20B，最长是60B。
4.2 IP地址 4.2.1 IP地址表示方式 IP地址有32bit，采用点分10进制表示，每8bit位一个小组，使用“.”号分开，每个小组的二进制换算成10进制，例如192.168.10.1
比如：1100 0000 10101000 0000 1010 0000 0001
1100 0000-1010 1000-0000 1010-0000 0001=192.168.10.1
172.16.20.1=（128+32+8+4）.16.（16+4）.1=10101100000100000001010000000001
范围：0.0.0.0-255.255.255.255
4.2.2 IP地址的构成 IP地址：32bit中分为两个部分：一个部分为网络位，一个部分为主机位
网络位：用来标识一个网络，两个IP地址的网络位不相同，则认为两个地址不在同一个网段。主机位：主机位一个网络内的不同主机。 掩码：32bit，由连续的1和连续的0组成。用于区分IP地址的主机位和网络位。
表示方式：
点分十进制：255.255.255.0前缀长度表示方式：掩码中1的个数（网络位的长度）10进制值。 IP地址：192.168.10.1/24 //IP地址为192.168.10.1，掩码为24（255.255.255.0）
4.2.3 IP地址的分类 分为5个类型：
A类地址范围：0.0.0.0-127.255.255.255 掩码8（255.0.0.0）
B类地址范围：128.0.0.0-191.255.255.255 掩码16（255.255.0.0）
C类地址范围：192.0.0.0-223.255.255.255 掩码24 （255.255.255.0）
D类地址范围：224.0.0.0-239.255.255.255 用于组播
E类地址范围：240.0.0.0-255.255.255.255 用于IPV4研究
特殊地址：
0.0.0.0地址：可以表示所有的网络，也可以表示设备接口未配置地址，不能作为设备的有效地址是：
127.0.0.0-127.255.255.255地址：表示环回地址，网卡本身，如果发送报文的目的地址是该地址范围，则报文不会发送出网卡，会从网卡的出口环回到设备上。用于测试使用。
169.254.0.0-169.254.255.255地址：动态获取地址失败后，为自己的网卡配置的用于临时通信的地址。
255.255.255.255地址:有限广播地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1288fec85b6067abebf6462696b8d254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca73a768736c6b92f625e92295afd41/" rel="bookmark">
			vue项目报错，且运行不起来No known conditions for “./lib/locale/lang/zh-cn” entry in “element-plus” package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 运行element-plus项目控制台报错：No known conditions for “./lib/locale/lang/zh-cn” entry in “element-plus” package
项目运行不起来，加载不出来
解决-修改所有引用语言包的地方 将原有的/lib/local/lang路径改成/es/local/lang
我的项目就修改了两个地方
1、locals/index.js中的引用
2、package.json中的引用
原因 原本项目中element-plus版本是2.3.1，重新安装依赖后安装的版本却变成了2.4.4,但在新版本中的地址不符合需要修改为es
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16496c2b44ed9fa55d9a3395e0795514/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】太阳能追光系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用LCD1602液晶、光敏传感器、ADC模块、按键模块、28BYJ48步进电机驱动模块、直流电机模块等。
主要功能：
系统运行后，LCD1602显示四个方向光线强度、工作模式及控制状态；
系统默认工作在自动模式，当系统检测为白天晴天，可以开始工作，当上光线值比下光线值还高于阈值，则直流电机工作上升；
当下光线值比上光线值还高于阈值，则直流电机工作下降；
当左光线值比右光线值还高于阈值，则步进电机工作左转；
当右光线值比左光线值还高于阈值，则步进电机工作右转；
当系统检测为夜晚，停止工作。
当按下K1键，切换为手动模式，可通过K2-K5键对上下左右方向控制；
二、软件设计 /* 作者：嗨小易（QQ技术交流群：570487280） */ //系统数据显示 void sys_data_show(void) { while(1) { //光线显示 lcd1602_show_nums(2,0,sys_ctrl.light[0],2,0);//上 lcd1602_show_nums(8,0,sys_ctrl.light[1],2,0);//下 lcd1602_show_nums(2,1,sys_ctrl.light[2],2,0);//左 lcd1602_show_nums(8,1,sys_ctrl.light[3],2,0);//右 //自动手动显示 if(sys_ctrl.auto_flag)lcd1602_show_string(12,0,"SD"); else lcd1602_show_string(12,0,"Au"); //上升下降状态显示 if(sys_ctrl.udrun==0)lcd1602_show_string(15,0,"N"); else if(sys_ctrl.udrun==1)lcd1602_show_string(15,0,"U"); else if(sys_ctrl.udrun==2)lcd1602_show_string(15,0,"D"); //左右转状态显示 if(sys_ctrl.lrrun==0)lcd1602_show_string(15,1,"N"); else if(sys_ctrl.lrrun==1)lcd1602_show_string(15,1,"L"); else if(sys_ctrl.lrrun==2)lcd1602_show_string(15,1,"R"); break;	} } //系统功能控制 void sys_fun_ctrl(void) { //手动模式下 if(sys_ctrl.auto_flag==1) { switch(sys_ctrl.udrun) { case 0: _dc_motor_stop();break;//停止 case 1: _dc_motor_fturn();break;//上升 case 2: _dc_motor_zturn();break;//下降 } switch(sys_ctrl.lrrun) { case 1: step_motor_28BYJ48_send_pulse(8,0,STEPMOTOR_MAXSPEED,1,1);break;//左转 case 2: step_motor_28BYJ48_send_pulse(8,1,STEPMOTOR_MAXSPEED,1,1);break;//右转 }	} //自动控制模式 else { //如果是晴天，根据4个传感器检测光线强弱自动调节 if(sys_ctrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16496c2b44ed9fa55d9a3395e0795514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7964dc053413c92de0604650765f5f/" rel="bookmark">
			Keras实现seq2seq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Seq2Seq是一种深度学习模型，主要用于处理序列到序列的转换问题，如机器翻译、对话生成等。该模型主要由两个循环神经网络（RNN）组成，一个是编码器（Encoder），另一个是解码器（Decoder）。
seq2seq基本结构 Seq2Seq被提出于2014年，最早由两篇文章独立地阐述了它主要思想，分别是Google Brain团队的《Sequence to Sequence Learning with Neural Networks》和Yoshua Bengio团队的《Learning Phrase Representation using RNN Encoder-Decoder for Statistical Machine Translation》。这两篇文章针对机器翻译的问题不谋而合地提出了相似的解决思路，Seq2Seq由此产生。
工作原理 编码阶段：输入一个序列，使用RNN（Encoder）将每个输入元素转换为一个固定长度的向量，然后将这些向量连接起来形成一个上下文向量（context vector），用于表示输入序列的整体信息。转换阶段：将上下文向量传递给另一个RNN（Decoder），在每个时间步，根据当前的上下文向量和上一个输出生成一个新的输出，直到生成一个特殊的结束符号，表示序列的结束。训练阶段：根据目标序列和生成的输出之间的差异计算损失，并使用反向传播算法优化模型的参数，以减小损失。预测或生成阶段：使用训练好的模型根据输入序列生成目标序列。 示例 # 导入所需的库 import numpy as np from keras.models import Model from keras.layers import Input, LSTM, Dense # 定义输入序列的长度和输出序列的长度 input_seq_length = 10 output_seq_length = 10 # 定义输入序列的维度 input_dim = 28 # 定义LSTM层的单元数 lstm_units = 128 #定义编码器模型 #定义编码器的输入层，形状为(None, input_dim)，表示可变长度的序列 encoder_inputs = Input(shape=(None, input_dim)) #定义一个LSTM层，单元数为lstm_units，返回状态信息 encoder = LSTM(lstm_units, return_state=True) #将编码器的输入传递给LSTM层，得到输出和状态信息 encoder_outputs, state_h, state_c = encoder(encoder_inputs) #将状态信息存储在列表中 encoder_states = [state_h, state_c] #定义解码器模型 #定义解码器的输入层，形状为(None, input_dim)，表示可变长度的序列 decoder_inputs = Input(shape=(None, input_dim)) #定义一个LSTM层，单元数为lstm_units，返回序列信息和状态信息 decoder_lstm = LSTM(lstm_units, return_sequences=True, return_state=True) #将解码器的输入和编码器的状态传递给LSTM层，得到输出和状态信息 decoder_outputs, _, _ = decoder_lstm(decoder_inputs, initial_state=encoder_states) #定义一个全连接层，输出维度为input_dim，激活函数为softmax decoder_dense = Dense(input_dim, activation='softmax') #将LSTM层的输出传递给全连接层，得到最终的输出 decoder_outputs = decoder_dense(decoder_outputs) # 定义seq2seq模型，输入为编码器和解码器的输入，输出为解码器的输出 model = Model([encoder_inputs, decoder_inputs], decoder_outputs) # 编译模型，使用RMSProp优化器和分类交叉熵损失函数进行编译 model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7964dc053413c92de0604650765f5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e28ab6b1836f7ee48ad8d09fffb9908/" rel="bookmark">
			第四章 前后端数据交换格式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. JSON数据结构与序列化/反序列化 JSON（JavaScript Object Notation） 是一种轻量级的数据交换格式，基于JavaScript的一个子集，易于人阅读和编写，同时也易于机器解析和生成。在前后端通信中，JSON格式被广泛用于传递结构化的数据。
1.1 JSON数据结构 JSON由键值对组成，可以嵌套形成复杂的数据结构，包括对象（在JSON中表示为花括号 {} 包围的键值对集合）和数组（方括号 [] 包围的值列表）。例如：
{ "user": { "name": "John Doe", "age": 30, "email": "john.doe@example.com" }, "items": [ {"id": 1, "name": "Item 1"}, {"id": 2, "name": "Item 2"} ] } 1.2 JSON序列化 序列化是指将JavaScript对象或数据结构转换成JSON字符串的过程，通常通过JSON.stringify()方法实现。如：
let user = { name: "John Doe", age: 30, email: "john.doe@example.com" }; // 序列化为JSON字符串 let jsonString = JSON.stringify(user); console.log(jsonString); // '{"name": "John Doe", "age": 30, "email": "john.doe@example.com"}' 1.3 JSON反序列化 反序列化则是将JSON字符串还原成JavaScript对象的过程，使用JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e28ab6b1836f7ee48ad8d09fffb9908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02d4bf5e9dbf04dae5c0013e95037e9/" rel="bookmark">
			oracle 补齐数字长度 to_char踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle的to_char网上找到的说明如下
（1）用作日期转换：
to_char(date,'格式');
select to_date('2005-01-01 ','yyyy-MM-dd') from dual; select to_char(sysdate,'yyyy-MM-dd HH24:mi:ss') from dual; （2）处理数字：
to_char(number,'格式');
①其9代表：如果存在数字则显示数字，不存在则显示空格
②其0代表：如果存在数字则显示数字，不存在则显示0，即占位符。
③在格式参数FMT中，前面加上FM代表去掉返回结果中的前后空格和0。
select to_char(88877) from dual; select to_char(1234567890,'099999999999999') from dual; select to_char(12345678,'999,999,999,999') from dual; select to_char(123456,'99.999') from dual; select to_char(1234567890,'999,999,999,999.9999') from dual; （3）to_char(salary,'$99,99');
select TO_CHAR(123,'$99,999.9') from dual; （4）用于进制转换：将10进制转换为16进制；
select to_char(4567,'xxxx') from dual; select to_char(123,'xxx') from dual; 使用场景：
定义了一个 循环sequence 用于与日期拼成一个唯一的序号。
使用to_char生成固定6位数的sequence
业务系统跑了一段时间后，发现序号的后6位变成######
这是什么情况，难道溢出了？我是循环sequence呀？
原来 to_char 对于超出占位符的数字全部显示#
解决办法1：用取余函数mod保证小于除数
解决办法2： lpad 不足左边补0，超出从左边开始截取，保证长度但是意义稍微有点差异。
办法3: 至少5位，从右到左截取5位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a9f1085b3ca24ec5ceab9af8775631/" rel="bookmark">
			格密码基础：对偶格（超全面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 对偶格的格点
1.1 基本定义
1.2 对偶格的例子
1.3 对偶格的图形理解
二. 对偶格的格基
2.1 基本定义
2.2 对偶格的格基证明
三. 对偶格的行列式
3.1 满秩格
3.2 非满秩格
四. 重复对偶格
五. 对偶格的转移定理（transference theorem）
六. 对偶格的连续最小值
七. 对偶格的正交投影
八. 对偶格基的正交化
推荐先阅读：
格密码的基础概念-CSDN博客
一. 对偶格的格点 1.1 基本定义 对偶格（dual lattice）也被称之为倒易格（reciprocal lattice）。原来满秩的格写做，其对偶格的定义如下：
原来的格点和对偶格的任意（这两个字非常重要）格点相乘为整数即可。原来的格点如果为整数，那么对偶格里有可能会出现小数。此处代表n维实数空间，更准确来讲，对偶格应该在原来格的扩展空间内。那么对偶格更准确的定义，如下：
对偶格的右上角经常带“*”,代表格的扩展空间。
对偶格的重心在于，向量相乘为整数。当然，对偶格也是一种格，格的一些基本性质对偶格也具有。格和对偶格是成对出现的。
1.2 对偶格的例子 整数格的对偶格是其本身，也就是：
也就是整数格满足自对偶的性质。
如果把整数格的格点都扩大两倍，则形成子格。该格的对偶格则会出现小数，如下：
此处的系数有点类似倒数的感觉。
原始格的安全性在对偶格中依旧是存在的。
1.3 对偶格的图形理解 思考：给出任意一个向量点x，请找出所有跟这个向量点乘积为整数的点？
备注：向量与向量相乘为标量
线性代数告诉我们这些点会形成一个超平面，点跟点之间的距离为1/||x||。看一个二维的图形就很直接：
二. 对偶格的格基 格点相乘为整数，那这两个格的格基满足什么性质？
2.1 基本定义 原来的格基叫B，写做：
格基内每个向量都是m维，一共有n个向量。
对偶格的格基维度肯定是保持不变的，也就是：
对偶格和原来的格扩展空间肯定一致（向量点维度不一样的话，都不能相乘）：
刚才发现对偶格有点倒数的感觉，反应在矩阵上则互逆，所以满足：
单位阵对角线上全为1，其他位置均为0。那么矩阵互逆告诉我们，向量位置一致时，相乘为1，也就是：
向量位置不一致时，相乘为0：
如果格基为方阵，也就是格满秩，则可以直接求逆，那么：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a9f1085b3ca24ec5ceab9af8775631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c366f24b9491f4c87b524071ddf89c09/" rel="bookmark">
			计算机毕业设计 基于SpringBoot的公司资产网站的设计与实现 Java实战项目 附源码&#43;文档&#43;视频讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌从事软件开发10年之余，专注于Java技术领域、Python人工智能及数据挖掘、小程序项目开发和Android项目开发等。CSDN、掘金、华为云、InfoQ、阿里云等平台优质作者✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
————————————————
计算机毕业设计《1000套》✌
目录
1、项目介绍及开发技术
1.1 项目介绍
1.2 开发技术
2、系统功能设计结构图
3、功能截图
4、数据库表结构设计
5、关键代码
5.1 资产Controller模块 5.2 资产Service模块 5.3 资产ServiceImpl模块
5.4 资产Dao模块
6、论文目录结构
7、源码获取
1、项目介绍及开发技术 1.1 项目介绍 信息数据从传统到当代，是一直在变革当中，突如其来的互联网让传统的信息管理看到了革命性的曙光，因为传统信息管理从时效性，还是安全性，还是可操作性等各个方面来讲，遇到了互联网时代才发现能补上自古以来的短板，有效的提升管理的效率和业务水平。传统的管理模式，时间越久管理的内容越多，也需要更多的人来对数据进行整理，并且数据的汇总查询方面效率也是极其的低下，并且数据安全方面永远不会保证安全性能。结合数据内容管理的种种缺点，在互联网时代都可以得到有效的补充。结合先进的互联网技术，开发符合需求的软件，让数据内容管理不管是从录入的及时性，查看的及时性还是汇总分析的及时性，都能让正确率达到最高，管理更加的科学和便捷。本次开发的公司资产网站实现了字典管理、公告管理、员工管理、资产管理、资产报废管理、资产申请管理、资料库管理、管理员管理等功能。系统用到了关系型数据库中王者MySql作为系统的数据库，有效的对数据进行安全的存储，有效的备份，对数据可靠性方面得到了保证。并且程序也具备程序需求的所有功能，使得操作性还是安全性都大大提高，让公司资产网站更能从理念走到现实，确确实实的让人们提升信息处理效率。
1.2 开发技术 Java开发语言、SpringBoot、MyBatisPlus、MySQL数据库、Maven、IDEA开发工具、JDK1.8+、Vue、HTML、CSS、JS。
2、系统功能设计结构图 3、功能截图 资产管理：主要实现资产的增加、修改、删除、查看的功能。
公告信息管理：新增公告，修改公告，删除公告操作。
公告类型管理：在此页面既可以让管理员添加新的公告信息类型，也能对已有的公告类型信息执行编辑更新，失效的公告类型信息也能让管理员快速删除。
资产报废管理： 新增资产报废,修改资产报废,删除资产报废。
资产报废类型管理： 管理员可以新增资产报废类型,修改资产报废类型,删除资产报废类型。
4、数据库表结构设计 CREATE DATABASE /*!32312 IF NOT EXISTS*/`gongsizichan` /*!40100 DEFAULT CHARACTER SET utf8 */; USE `gongsizichan`; /*Table structure for table `config` */ DROP TABLE IF EXISTS `config`; CREATE TABLE `config` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(100) DEFAULT NULL COMMENT '配置参数名称', `value` varchar(100) DEFAULT NULL COMMENT '配置参数值', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='配置文件'; /*Data for the table `config` */ /*Table structure for table `dictionary` */ DROP TABLE IF EXISTS `dictionary`; CREATE TABLE `dictionary` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `dic_code` varchar(200) DEFAULT NULL COMMENT '字段', `dic_name` varchar(200) DEFAULT NULL COMMENT '字段名', `code_index` int(11) DEFAULT NULL COMMENT '编码', `index_name` varchar(200) DEFAULT NULL COMMENT '编码名字 Search111 ', `super_id` int(11) DEFAULT NULL COMMENT '父字段id', `beizhu` varchar(200) DEFAULT NULL COMMENT '备注', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='字典'; /*Data for the table `dictionary` */ insert into `dictionary`(`id`,`dic_code`,`dic_name`,`code_index`,`index_name`,`super_id`,`beizhu`,`create_time`) values (1,'gonggao_types','公告类型',1,'公告类型1',NULL,NULL,'2023-05-17 14:02:33'),(2,'gonggao_types','公告类型',2,'公告类型2',NULL,NULL,'2023-05-17 14:02:33'),(3,'zhiwei_types','职位',1,'职位1',NULL,NULL,'2023-05-17 14:02:33'),(4,'zhiwei_types','职位',2,'职位2',NULL,NULL,'2023-05-17 14:02:33'),(5,'bumen_types','部门',1,'部门1',NULL,NULL,'2023-05-17 14:02:33'),(6,'bumen_types','部门',2,'部门2',NULL,NULL,'2023-05-17 14:02:33'),(7,'sex_types','性别类型',1,'男',NULL,NULL,'2023-05-17 14:02:33'),(8,'sex_types','性别类型',2,'女',NULL,NULL,'2023-05-17 14:02:33'),(9,'jinyong_types','账户状态',1,'启用',NULL,NULL,'2023-05-17 14:02:33'),(10,'jinyong_types','账户状态',2,'禁用',NULL,NULL,'2023-05-17 14:02:33'),(11,'zichan_types','资产类型',1,'资产类型1',NULL,NULL,'2023-05-17 14:02:33'),(12,'zichan_types','资产类型',2,'资产类型2',NULL,NULL,'2023-05-17 14:02:33'),(13,'zichan_types','资产类型',3,'资产类型3',NULL,NULL,'2023-05-17 14:02:33'),(14,'zichan_types','资产类型',4,'资产类型4',NULL,NULL,'2023-05-17 14:02:33'),(15,'zichan_shenqing_types','资产申请类型',1,'资产申请类型1',NULL,NULL,'2023-05-17 14:02:33'),(16,'zichan_shenqing_types','资产申请类型',2,'资产申请类型2',NULL,NULL,'2023-05-17 14:02:33'),(17,'zichan_shenqing_types','资产申请类型',3,'资产申请类型3',NULL,NULL,'2023-05-17 14:02:33'),(18,'zichan_shenqing_types','资产申请类型',4,'资产申请类型4',NULL,NULL,'2023-05-17 14:02:33'),(19,'zichan_shenqing_yesno_types','申请状态',1,'待审核',NULL,NULL,'2023-05-17 14:02:33'),(20,'zichan_shenqing_yesno_types','申请状态',2,'同意',NULL,NULL,'2023-05-17 14:02:33'),(21,'zichan_shenqing_yesno_types','申请状态',3,'拒绝',NULL,NULL,'2023-05-17 14:02:33'),(22,'zichan_baofei_types','资产报废类型',1,'资产报废类型1',NULL,NULL,'2023-05-17 14:02:33'),(23,'zichan_baofei_types','资产报废类型',2,'资产报废类型2',NULL,NULL,'2023-05-17 14:02:33'),(24,'zichan_baofei_types','资产报废类型',3,'资产报废类型3',NULL,NULL,'2023-05-17 14:02:33'),(25,'zichan_baofei_types','资产报废类型',4,'资产报废类型4',NULL,NULL,'2023-05-17 14:02:33'),(26,'ziliaoku_types','资料类型',1,'资料类型1',NULL,NULL,'2023-05-17 14:02:34'),(27,'ziliaoku_types','资料类型',2,'资料类型2',NULL,NULL,'2023-05-17 14:02:34'),(28,'ziliaoku_types','资料类型',3,'资料类型3',NULL,NULL,'2023-05-17 14:02:34'),(29,'ziliaoku_types','资料类型',4,'资料类型4',NULL,NULL,'2023-05-17 14:02:34'),(30,'ziliaoku_types','资料类型',5,'资料类型5',NULL,'','2023-05-17 14:43:18'); /*Table structure for table `gonggao` */ DROP TABLE IF EXISTS `gonggao`; CREATE TABLE `gonggao` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键 ', `gonggao_name` varchar(200) DEFAULT NULL COMMENT '公告名称 Search111 ', `gonggao_photo` varchar(200) DEFAULT NULL COMMENT '公告图片 ', `gonggao_types` int(11) NOT NULL COMMENT '公告类型 Search111 ', `insert_time` timestamp NULL DEFAULT NULL COMMENT '公告发布时间 ', `gonggao_content` longtext COMMENT '公告详情 ', `create_time` timestamp NULL DEFAULT NULL COMMENT '创建时间 show1 show2 nameShow', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COMMENT='公告'; /*Data for the table `gonggao` */ insert into `gonggao`(`id`,`gonggao_name`,`gonggao_photo`,`gonggao_types`,`insert_time`,`gonggao_content`,`create_time`) values (1,'公告名称1','upload/gonggao1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c366f24b9491f4c87b524071ddf89c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5b4331dc6ab810bc9e32a58b640839/" rel="bookmark">
			多内层神经网络具有先天的不可解释性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多层神经网络的不可解释性是指其内部的决策过程很难被人类理解和解释。这主要是因为多层神经网络具有大量的神经元和多个层次的连接，使得网络的决策过程变得非常复杂。
具体而言，多层神经网络中每一层的神经元会根据输入的特征进行加权组合和非线性变换，然后将结果传递给下一层。这种层层传递的特性使得网络在处理复杂任务时能够提取更高级别的特征，但也使得网络的决策过程变得不透明。
由于网络的参数众多和复杂的结构，很难准确了解每个神经元在整个网络中的作用和贡献。即使可以通过可视化方法来观察网络的某些层次上的特征提取，仍然无法清楚地解释网络是如何将这些特征组合起来做出决策的。
因此，多层神经网络在很多情况下被视为“黑盒子”，我们可以观察到其输入与输出之间的映射关系，但无法精确理解其中的具体决策过程。这也是人们对于机器学习模型的可解释性提出要求的原因之一。为了增加模型的可解释性，研究者们正在探索一些方法，如基于注意力机制的可解释性方法和规模化网络的解释方法等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8988f1bfe26ffb65cc5364fe159c8984/" rel="bookmark">
			量产基石 | 站在上帝的视角重新定义BEV感知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BEV感知从进入大众的视野，到成熟地落地量产不到两年的时间。回想22年之前的方案，当时还是2D检测结合一系列复杂的pipeline得到目标的距离信息，最终建模在BEV下。泊车方案大都基于IPM建模BEV，损失了高度的信息。或者使用一些容易部署的单目3D检测方案。整个22年和23年给汽车人的感觉就是技术发展太快了！在沉淀一段时间后，也更让我们坚信自动驾驶终将实现~
说回BEV感知，近一段时间看了很多公司的方案，可以说BEV已经成为当下主流L2/L3量产的基石。各家基于Orin或者J5的方案BEV都可以上车，那么也引出了汽车人的一个思考—BEV感知的边界在哪里？自动驾驶下一代方案（面向L4）的方向是什么？
BEV感知的优势自不必多说，离不开更大的全局感受野、统一了多传感器融合的坐标和尺度以及时序融合等等一系列好处。相比于之前的方案的确有了质的提升。但感知总归是有感知的边界，BEV也不可能处理所有的情况。尤其是当下我们似乎慢慢摸索到了这个边界，再向前一步该如何去做？下一代自动驾驶方案应该如何设计才能破局？目前汽车人也是带着这个思考再向前走，也欢迎大家畅所欲言！但不管怎样，BEV感知在学术界和工业界中的问题还没有完全收敛，仍然有很多问题需要解决和探索，汽车人和大家一起在思考中不断前进！
以上内容均出自【自动驾驶之心知识星球】
自动驾驶之心知识星球，创办于2022年7月份，致力于打造为自动驾驶行业中的 ”黄埔军校“，目前近2400人，聚集了近50+自动驾驶行业专家为大家答疑解惑。
星球内已经打磨出近30+的学习路线，涉及BEV感知、动态/静态障碍物检测、多传感器融合、多传感器标定、目标跟踪、模型部署与cuda加速、仿真等方向，沉淀了大量工程上的解决方案、学术上的优化思路！星球主要内容一览：
如何持续保持跟进和输入呢？我的答案是找对圈子，让你每天能够主动和被动接受很多新的知识，包括领域知识体系的梳理、刷题、面试经验、各家企业现状、各个岗位的具体职责以及后续的职业前景等。一个人入门学习，无异于大海捞针，浪费了大把时间踩坑，还得不到想要的答案。哪里有专业回答的规划呢？这里我推荐一个我们一直在维护的社区：自动驾驶之心知识星球，目前是国内最大、最专业的自动驾驶社区。欢迎加入！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b354c50a76723ff6c2427015764ddffe/" rel="bookmark">
			【C&#43;&#43;】继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、继承概念及定义 1. 继承概念 继承是面向对象程序设计中使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生的新的类，称派生类，原有的类称为基类或者父类。
下面代码中student和teacher两个类都继承了person类，继承后，基类的成员函数和成员变量可以在子类中访问到。
class Person { public: void Print() { cout &lt;&lt; "name:" &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; "age:" &lt;&lt; _age &lt;&lt; endl; } protected: string _name = "peter"; // 姓名 int _age = 18; // 年龄 }; // 继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。这里体现出了Student和Teacher复用了Person的成员。下面我们使用监视窗口查看Student和Teacher对象，可以看到变量的复用。调用Print可以看到成员函数的复用。 class Student : public Person { protected: int _stuid; // 学号 }; class Teacher : public Person { protected: int _jobid; // 工号 }; int main() { Student s; Teacher t; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b354c50a76723ff6c2427015764ddffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be8422d0d239966f7dc9546a66e6584/" rel="bookmark">
			23 导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果演示 实现了一个响应式的导航栏，当鼠标悬停在导航栏上的某个选项上时，对应的横条会从左到右地移动，从而实现了导航栏的动态效果。
Code &lt;div class="flex"&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;div class="bar"&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; body { height: 100vh; display: flex; justify-content: center; align-items: center; background-color: #e8e8e8; } .flex { width: 50vw; height: 80px; line-height: 80px; background-color: white; position: absolute; top: 50%; left: 50%; margin: -25px 0 0 -25vw; } .flex ul { display: flex; padding: 0; margin: 0; box-shadow: 0 10px 20px 0 rgba(0, 0, 0, 0.25); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be8422d0d239966f7dc9546a66e6584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c633863ddb3c54f656a20f40f0e9d69d/" rel="bookmark">
			Dart调用JS对10000条定位数据滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Dart调用JS，还是为了练习跨语言调用；
一、编写对应的JS代码 平时在开发时不推荐将算法放在JS里，我这里是简单的做一下数据过滤；
首先生成一些随机定位数据，在实际开发中可以使用真实数据；
// 随机定位点 function getRandomCoordinate() { return { latitude: getRandomFloat(110, 115), longitude: getRandomFloat(110, 115) }; } // 随机数 function getRandomFloat(min, max) { return min+Math.random()*(max-min); } 将数据添加到对应容器中；
// 滤波 function filterData() { console.log("开始滤波-----"); var data = []; // 添加10000条随机定位点 for (let index = 0; index &lt; 10000; index++) { let coordinate = getRandomCoordinate(); data.push(coordinate); } console.log(data); averageFilter(data); } 滤波时需要计算弧面距离；
// 计算定位之间的距离 function distance(lat1, lon1, lat2, lon2) { const R = 6371; // 地球半径，我使用的是平均值，单位公里 const dLat = deg2rad(lat2-lat1); // 角度转弧度 const dLon = deg2rad(lon2-lon1); // 同上 const dL1 = deg2rad(lat1); const dL2 = deg2rad(lat2); // 开始求弧面距离了 const a = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c633863ddb3c54f656a20f40f0e9d69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71fc3f00439c40914d520637917d5f3/" rel="bookmark">
			计数原理@排列数@组合数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 两类基本计数原理分类加法计数原理分类乘法计数原理小结 排列组合元素 排列排列数全排列排列数性质从计数原理角度解释该公式从排列数展开公式推导 组合组合数组合数与排列数的关系👺组合数的性质计数原理的方法证明纯代数方法证明 排列数和组合数公式的逆用笔算或口算中的排列组合👺 两类基本计数原理 以下两种计数原理是解决计数问题的最基本理论依据它们分别给出了"分类"和"分步"完成一件事(任务)的方法总数的计算方法 分类加法计数原理 完成任务A有 n n n类办法,第 i i i类办法中有 m i m_i mi​种不同的方法 ( i = 1 , 2 , ⋯ , n ) (i=1,2,\cdots,n) (i=1,2,⋯,n),那么完成A的方法数有 N = ∑ i = 1 n m i N=\sum_{i=1}^{n}m_i N=∑i=1n​mi​ 分类乘法计数原理 完成任务B有n个步骤,第 i i i个步骤有 m i m_i mi​种不同的方法,则完成B的方法数有 N = ∏ i = 1 n m i N=\prod_{i=1}^{n}m_i N=∏i=1n​mi​注意,乘法原理是各个步骤之间的顺序的,如果对调两个步骤仍能得到一样的效果,则该问题不是乘法原理能直接使用范围 例如组合问题:设有 a , b , c a,b,c a,b,c三个球,从中取出2个球可以产生多少种可能?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71fc3f00439c40914d520637917d5f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f946b10e71ee9573b551704983488c7a/" rel="bookmark">
			【SpringMVC】常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是MVC？
MVC是一种程序分层开发模式，分别是Model（模型），View（视图）以及Controller（控制器）。这样做可以将程序的用户界面和业务逻辑分离，使得代码具有良好的可扩展性、可复用性、可维护性和灵活性。
@Controller 显而易见，@Controller注解对应的是MVC模式中的Controller对象。在Bean注解存储对象一文中也有过介绍，@Controller表示的是控制器，归属于业务逻辑层，对前端发来的请求进行判断，观察其数据是否合理，也就是控制用户行为，判断参数合理性。
@RequestMapping @RequestMapping，翻译过来的意思就是请求映射，顾名思义就是对前端发来的路由地址进行映射，使其对应到某个类或者方法上。
使用位置 1. Java类 如上图，若对应到某个类上，那么这个类其中的所有方法进行请求映射时都需要先把父路径加上。
2. Java方法 如上图，当用户想要进行登录的时候，前端就会向后端发一个路由，而路由正是根据这个@RequestMapping注解其中的请求映射而来。
常见属性 1. value value指的就是请求地址，但是使用的时候一般其他属性不多见，因此也就将其直接省略。
@RequestMapping(value = "/login") 2. method 如果各位程序猿有了解过HTTP协议的话，这其实就是HTTP协议首行中的方法。本来设计协议的大佬是为了更好的描述一次请求是想要干啥，但是在实际开发中，好多都是一刀切，直接使用一个POST请求解决一切请求。
GET：获取资源，也就是CURD中的查询操作，将数据库中的一些资源给返回前端，然后前端调取显示到页面上；例如博客系统中可以使用GET请求来获取博客。POST：添加资源/修改资源，较着重于添加资源，也就是CURD中的增加操作，给数据库中增加一些实例个体；例如写好一篇文章之后点击提交按钮就是发送POST请求将播客存储到数据库中。DELETE：删除资源，也就是CURD中的删除操作，在数据库中删除一些信息；例如点击一篇博客的删除按钮就是发送DELETE请求将此篇博客删除。PUT：修改资源，也就是CURD中的修改操作，将数据库中的一些信息进行修改；例如发现博客系统的一篇博客不太好，然后进行修改，再提交时就是使用PUT请求。PATCH：新引入的一个方法，修改局部资源，还是修改操作，和PUT不太一样的是修改局部，其实我感觉还是比较鸡肋，毕竟有那么多还是POST一刀切，那为啥还要增加这种，不过从维护角度看还是非常不错，通过这些注解大概了解代码进行了啥操作。 上述最常用的就是GET和POST请求，在面试中也会问一些关于这两个操方法的不同点，需要切记的一点就是没有啥区别，毕竟都是人为规定的，那么肯定就是可以修改的。
@RequestMapping(value = "/login", method = RequestMethod.GET) @PostMapping(value = "/login") 综上所述，@RequestMapping注解就是进行路由映射，也就是前端在进行某些操作时会用到一些数据，此时前端就会发送路由，而后端根据发送的路由就可以映射到对应的类和方法上进行逻辑操作。
@Requestparam @Requestparam，翻译过来就是请求参数。本质上写代码不使用这个注解也是没有问题的，但是为了代码的严谨性，建议叠加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379c607302c8612c576e882d8cdc15c9/" rel="bookmark">
			python编译器安装第三方库,python编译器安装模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这篇文章主要介绍了python编译器下载安装教程，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下。
一、前言 新手学习python前需要安装python与编译工具，接下来为大家介绍python、pycharm、vs code安装过程以及编译工具汉化的安装，最后有相应安装包链接提供大家下载。 二、安装 2.1 安装python 官网下载地址 https://www.python.org/downloads/ 一定要选Add Python 3.10 to PATH，以免需要手动配置环境变量，然后一直点击下一步python画树状图。
安装成功页面。
验证是否可以使用，cmd输入python -V
2.2 安装pycharm 官网下载地址 https://www.jetbrains.com/pycharm/download/#section=windows 一直点击next下一步
不懂选啥的同学全勾上就行了，然后一直点击下一步。
可以选择手动重启或者选择第一项Reboot now立即重启，需要重启一次电脑。
重启后打开Pycharm，勾上然后点击Continue。
遇到这个页面就选择Don’t Send。
pycharm 安装中文与python插件。
到此为止，安装pyCharm安装结束。
2.3 安装vs code 官网下载地址 https://code.visualstudio.com/download 点击下一步。
不懂选啥的同学全勾上就行了，然后一直点击下一步。
安装成功页面。
vs code 安装中文与python插件，python插件在编程的时候有代码提示和高亮非常nice，点击红框图标。
输入chinese，选择后点击install进行安装。
插件安装完成后点击Restart重启软件即可。
安装python插件
到此为止，安装vs code安装结束。
三、vs code 与 pycharm区别 个人看法：
pycharm适用于项目类型的开发，很好的Debug调试功能，功能多种多样。 vs code适用多种编程语言开发（vue、php……），比较轻量简洁，较用于脚本化开发（就python而言）。 我个人写脚本多一些，所以用vs code比较多，pycharm也用，需要调试的时候用pycharm就很方便，建议两个都安装，都体验体验。 四、安装包网盘链接 公众号回复python安装包，即可获取python、pycharm、vscode安装包。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662dda2766fd7d4f93dfc69200e95254/" rel="bookmark">
			如何在 ChatGPT 上使用 Wolfram 插件回答数学问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 写在最前面Wolfram是什么？ChatGPT 如何与 Wolfram 相结合，为什么有效？如何在 ChatGPT 上安装 Wolfram 插件？ 写在最前面 参考：https://clickthis.blog/zh-CN/how-to-answer-math-questions-using-wolfram-plugin-on-chatgpt/
ChatGPT 配备的 Wolfram 插件能够有效解决数学方程、文字问题、绘制图形和图表，甚至查找特定计算工作所需的数据。当解决数学问题时，Wolfram 插件能提供问题的可视化表示，这对理解和学习尤为有帮助。用户还可以特别请求这种可视化展示。
此外，Wolfram 的功能不仅局限于数学问题解答。它在音乐、地质学、物理、化学、语言学、经济学等多个领域同样表现出色。尽管 ChatGPT 在处理数学问题方面表现可圈可点，但其在回答问题时所表现出的随机性可能不利于解决数学问题，因为这些问题通常有唯一的正确或错误答案。
在使用 ChatGPT 解决数学问题时，您可能会遇到答案不一致的情况，特别是在直接使用它进行复杂计算时。这正是需要借助像 Wolfram 这样的插件的场合。本文将指导您如何在 ChatGPT 上安装和使用 Wolfram 插件，以便可靠地解决数学问题，并使其成为您值得信赖的数学解题伙伴。
Wolfram是什么？ 首次推出于 2009 年的 Wolfram 是一种在线服务，它结合了先进的技术和计算软件功能，可以根据外部来源的数据生成事实答案。Wolfram 以其科学的数据处理方法，特别适合于解决数学问题，无论是简单还是高级的计算。
Wolfram 包含两个核心部分：Wolfram|Alpha 和 Wolfram 语言。Wolfram|Alpha，作为一个计算知识引擎，提供高精度的计算、数学运算、数据分析和知识查询等功能。它拥有一个丰富的数据和算法库，能够回答多种问题，并提供详细的计算结果和图表展示。而 Wolfram 语言是一种功能强大的编程语言，适用于符号计算、数据可视化、机器学习、图像处理等多种操作，是科学计算和数据分析的理想选择。
ChatGPT 如何与 Wolfram 相结合，为什么有效？ ChatGPT 上的 Wolfram 插件结合了 Wolfram 的计算服务来解决文字问题、方程、物理计算等。最关键的是，它不仅提供了解决方案的分步说明，还提供了答案的视觉参考，使得 Wolfram 成为在使用 ChatGPT 学习和解决数学问题时的理想辅助工具。
ChatGPT 是一个基于神经网络的自然语言处理模型，而 Wolfram 则是一个功能强大的计算和知识系统。这两者结合的方式是通过在 ChatGPT 上集成 Wolfram 插件，使 ChatGPT 能够利用 Wolfram|Alpha 的计算知识和 Wolfram 语言的强大功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/662dda2766fd7d4f93dfc69200e95254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a39e1740aeda0f3234241f00506139/" rel="bookmark">
			【计算机病毒传播模型】报告：区块链在车联网中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链在车联网中的应用 写在最前面题目 - 26 车联网安全汇报演讲稿-删减2后，最终版（1469字版本）汇报演讲稿-删减1后（2555字版本）汇报演讲稿-删减前（3677字版本）1 概述1.1 车联网1.2 区块链1.3 区块链在车联网中的机遇与挑战 2. 车联网中的区块链框架2.1 链下扩容和链上扩展2.2 六层区块链系统组成 3 车联网的集成系统3.1 车联网（IoV）网络架构3.2 区块链在车联网中的集成 4 安全隐患—技术原理4.1 网络安全4.2 可扩展性4.3 身份认证4.4 数据完整性4.5 区块生成延迟 5 防护手段5.1 内容保密性5.2 身份匿名5.3 访问控制5.4 基于机器学习的入侵检测5.5 多级隐私保护 6. 研究挑战和开放性问题 写在最前面 我选的题目是车联网，然后在调研的过程中，我发现车联网有着众多细分方向。我选择了其中最吸引我、同时也是目前非常热门的一个方向：区块链技术在车联网中的应用。
为了深入了解这一主题，我参考了三篇一区的学术论文，并遵循老师提供的研究思路进行梳理。
没错，这个ppt就是一键生成，然后微调的hhh
感兴趣的朋友可以去看看，往期文章对如何自动生成PPT展开介绍过：
[ChatGPT与PowerPoint：AI高效PPT创作、VAB代码]
(https://blog.csdn.net/WTYuong/article/details/135037160)
然后发现内容太多了，于是进行了删减。删减前后的版本，我都放出来给大家参考，希望能有所帮助。
然而最后老师掐着5分钟的表来计时的，所以一半都没说到hh
题目 - 26 车联网安全 当前车联网逐渐兴起，车联网的安全不容忽视，请搜集，研究车物联网发展的现状、结构、功能架构，分析其安全隐患，并给出安全的防护措施。
主要内容：
1 车联网的概念；
2 车联网的框架；
3 车联网的集成系统；
4 安全隐患—技术原理；
5 防护手段
要求：
1可以参考相关文献资料；
2提出自己的观点，大胆阐述自己对主题内容的看法，也可以多参照些他人的观点；
3书写格式要严整，标题，子标题命名要正规，字符（楷体——GB），型号（小四）；行间距标准单行或1；
4字数不少于5000字，或不少于A4的纸6页，无上限；
汇报演讲稿-删减2后，最终版（1469字版本） 汇报主题：《区块链在车联网中的应用》
大家好，我选的题目是车联网，然后在调研的过程中，我发现车联网有着众多细分方向。我选择了其中最吸引我、同时也是目前非常热门的一个方向：区块链技术在车联网中的应用。
为了深入了解这一主题，我参考了三篇一区的学术论文，并遵循老师提供的研究思路进行梳理。下面，我向大家分享我所学习到的内容。
首先，车联网源自物联网，核心组成包括自动驾驶汽车和路边基础设施。它旨在通过网络连接实现车与车、车与路、车与人以及车与传感设备之间的交互，从而提升用户服务质量。
车联网通过传感器、无线射频识别等技术来收集车辆、道路和环境信息，然后上传到信息网络平台上，进行加工、计算、共享，从而提供监管、引导、多媒体服务和移动互联网应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a39e1740aeda0f3234241f00506139/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/">«</a>
	<span class="pagination__item pagination__item--current">2/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/3/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>