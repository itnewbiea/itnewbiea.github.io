<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2bca6fa96828fa4bf3a7ef66112963/" rel="bookmark">
			如何使用Qt实现线程与定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍如何使用Qt实现线程与定时器，文中介绍的非常详细，具有一定的参考价值，感兴趣的小伙伴们一定要看完！
本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（C++语言基础，C++设计模式，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
一、定时器QTimer类 The QTimer class provides repetitive and single-shot timers.
The QTimer class provides a high-level programming interface for timers. To use it, create a QTimer, connect its timeout() signal to the appropriate slots, and call start(). From then on, it will emit the timeout() signal at constant intervals.
上面这段话摘自Qt助手文档，我们使用QTimer类定义一个定时器，它可以不停重复，也可以只进行一次便停止。
使用起来也很简单：
QTimer *timer = new QTimer(this); connect(timer, SIGNAL(timeout()), this, SLOT(update())); timer-&gt;start(1000); 创建一个QTimer对象，将信号timeout()与相应的槽函数相连，然后调用start()函数。接下来，每隔一段时间，定时器便会发出一次timeout()信号。
更多用法这里就不讲了，您可以自行参考官方文档。比如如何停止、如何令定时器只运行一次等。
二、在多线程中使用QTimer 1.错误用法 您可能会这么做：
子类化QThread，在线程类中定义一个定时器，然后在run()方法中调用定时器的start()方法。
TestThread::TestThread(QObject *parent) : QThread(parent) { m_pTimer = new QTimer(this); connect(m_pTimer, &amp;QTimer::timeout, this, &amp;TestThread::timeoutSlot); } void TestThread::run() { m_pTimer-&gt;start(1000); } void TestThread::timeoutSlot() { qDebug() &lt;&lt; QString::fromLocal8Bit("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2bca6fa96828fa4bf3a7ef66112963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bb2a67b8ed54402f53c2ec25fb6a45/" rel="bookmark">
			Yolo V5 学习 (预处理 create_dataloader )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、调用create_dataloader完成加载数据与预处理 一、调用create_dataloader完成加载数据与预处理 create_dataloader函数用于创建数据加载器，它可以从数据集中加载数据并进行预处理。
这个函数返回一个数据加载器和一个数据集对象。
代码如下（示例）：
train_loader, dataset = create_dataloader(train_path, imgsz, batch_size // WORLD_SIZE, gs, single_cls, hyp=hyp, augment=True, cache=None if opt.cache == 'val' else opt.cache, rect=opt.rect, rank=LOCAL_RANK, workers=workers, image_weights=opt.image_weights, quad=opt.quad, prefix=colorstr('train: '), shuffle=True, seed=opt.seed) train_path
数据集的路径
imgsz
图片的大小
batch_size
批处理大小
gs
步长
single_cls
是否为单类别
hyp=hyp
超参数
augment=True
是否进行数据增强
cache=None if opt.cache == ‘val’ else opt.cache
是否使用缓存文件技巧
rect=opt.rect
是否使用矩形训练
rank=LOCAL_RANK
进程等级
workers=workers
工作进程数量
image_weights=opt.image_weights
是否使用图像权重
quad=opt.quad
是否切割为四份或九份
prefix=colorstr('train: ')
前缀字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bb2a67b8ed54402f53c2ec25fb6a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be99846b27474db009b591c887b6ce5a/" rel="bookmark">
			nodejs给密码加密 报错 ，找bug全过程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用md5对密码加密 1.1 将加密内容抽取为独立文件：
1.2 在组件中使用md加密：
1.3 上图对密码加密是封装成中间件的，所以还要在路由中使用该中间件：
1.4 使用postman发起请求：（报错）
1.5 对错误进行处理：
以为是md5加密的方法错了，但是看网上都是这样子加密的，，实在是不知道哪里错了。。 通过debug来排查错误，没查出来。。。决定换一种加密方法，下面使用bcrypt进行加密。 二、使用bcrypt对密码进行加密 2.1 加密方法：
2.1 还是报错，这是想单独执行一下加密文件，先确定一下是加密逻辑的错误还是其他逻辑错误。
结果：两种加密方法都运行成功！！！好吧，原来加密逻辑没有错！虽然证明md5本身没有问题，省的换来换去，还是接着使用bcrypt进行加密了。 2.2 突然想起，感觉应该使用异步操作，对于获取加密后的 密码， 然后就将加密内容换成异步的了：（en~我可太缺乏探索精神了555，没有深究是否必须要异步）
2.3 在页面中确实可以拿到加密后的密码，但是，还是报错500！
下面是密码加密的中间件：为什么使用一堆 console.log来调试，而不用debug呢——因为debug总是走不到我希望它进入的那一步【冒冷汗】~~~ 2.4 至此，在上图中每一步都可以获得加密后的密码，但是，发起请求还是500！！！
三、一步步回溯，顺着代码倒推 项目中采用分层架构，代码逻辑是一层层嵌套的。决定一层层刨析！！！【真~洋葱模型~~】代码结构如下图： 下面对第5步代码进行分析：突然想起来，加密后的密码！变长了！！！MySQL中密码字段长度不够！！！加长密码长度，成功了！！！ 四、总结
1. 还有一些细节上的坎坎坷坷，这里没有写。最主要的原因也并非字段长度不够。因为前面在抽离的加密函数和 加密中间件之间一直没打通。打通之后意识到字段不够也就是顺藤摸瓜了。
2. 不过，还是得缕清逻辑，写想清楚再下手。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ebd10076908964283cfc2aa13567e15/" rel="bookmark">
			Java责任链模式：优雅解耦系统处理流程，实现高效灵活的请求处理与分发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是责任链模式 1.1 责任链模式定义 责任链模式是一种行为型设计模式，它用于将多个请求处理器对象连接成一条链，可以让请求沿着这条链不断地传递，直到有一个请求处理器处理完成为止。
在责任链模式中，每个请求处理器都可以选择将请求进行处理，或将请求转发给下一个请求处理器。因此，责任链模式可以将系统中的请求处理逻辑进行解耦，使得请求的发送者和接收者之间的关系更加灵活。
1.2 责任链模式角色 抽象处理器（Handler）：定义了一个处理请求的接口，并维护了一个后继处理器对象。具体处理器（ConcreteHandler）：实现了处理请求的接口，并决定能否处理该请求。如果不能处理，则将请求转发给后继处理器。客户端（Client）：创建一个请求处理器对象，并将其添加到责任链中。 1.3 责任链模式应用场景 责任链模式通常用于以下几种情况：
有多个对象可以处理一个请求，而处理器的具体类型在运行时才能确定。想要将请求的处理流程从请求发送者中解耦。想要动态地指定可处理请求的对象集合。 举个例子，在一个银行卡支付系统中，用户可以使用多种方式进行支付，如支付宝、微信支付、银行卡支付等，每个支付方式都有其自身的处理逻辑，且处理顺序可能也不同。此时可以使用责任链模式来将支付请求通过多个支付处理器进行处理，直至请求完成为止。这样可以避免代码耦合度过高，增加代码的可维护性和可扩展性。
二、责任链模式的实现方式 2.1 单向链表实现 首先，我们需要创建一个抽象处理器接口：
public interface Handler { void handleRequest(Request request); void setNextHandler(Handler nextHandler); } 复制代码 然后，我们创建具体的请求处理器，实现handleRequest()方法，并将请求转发给下一个处理器：
public class ConcreteHandler1 implements Handler { private Handler nextHandler; public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } public void handleRequest(Request request) { if (request.getType() == RequestType.TYPE1) { System.out.println(request.getName() + " is handle by ConcreteHandler1"); } else { if (nextHandler !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ebd10076908964283cfc2aa13567e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4d8c2d97bef2ddc5d2e4811301d0a5/" rel="bookmark">
			Android仿系统provision应用实现开机向导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:TV首次开机实现遥控对焦、连接wifi等指导性功能
应用需要的功能 ：
1.设置相关属性让自己早于Launcher起来；
2.设置开机引导已经走完的标记位。
1. AndroidManifest.xml配置 &lt;!-- 添加权限 For miscellaneous settings --&gt; &lt;uses-permission android:name="android.permission.WRITE_SETTINGS" /&gt; &lt;uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS" /&gt; &lt;activity android:name="xxxxxxx" android:configChanges="locale|keyboard|keyboardHidden|navigation|layoutDirection" android:exported="true" android:excludeFromRecents="true" android:theme="@style/Theme.AppCompat.Light.NoActionBar"&gt; &lt;intent-filter android:priority="1"&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.HOME" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.SETUP_WIZARD" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 2.保存开机引导状态 开机引导结束后设置
public void setupSys() { // Add a persistent setting to allow other apps to know the device has been provisioned. // 添加持久设置以允许其他应用程序知道设备已配置。 Settings.Global.putInt(getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 1); //这个标记位标识当前用户已经走完引导流程，如果不设置这个值，Home键、锁屏等将不可用 Settings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4d8c2d97bef2ddc5d2e4811301d0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66104ceab602337da3f23ab4cbc26187/" rel="bookmark">
			nvm安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更换node.js 在公司实战项目开发中遇到了运行项目时发现node版本问题导致项目运行失败，现在将自己的处理方式总结如下，方便自己以后查阅同时与小伙伴们共同分享
文章目录 更换node.js一、关于nvm的下载以及安装傻瓜式安装安装成功后安装完记得重启电脑 二、处理cmd中查询nvm未查询 一、关于nvm的下载以及安装 nvm官网
推荐 nvm 1.1.7-setup.zip 版本
傻瓜式安装 安装成功后 在命令行窗口输入nvm即可查看当前nvm的安装版本，则表示nvm安装成功
安装完记得重启电脑 二、处理cmd中查询nvm未查询 ‘nvm’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
又遇到查询nvm失效不是命令
输入变量名 NVM_HOME
变量值为你nvm所安装的路径，我这里安装的路径为：C:\Users\zjy\AppData\Roaming\nvm
新建系统变量点击确定后，找到系统变量中的Path 点击编辑 输入
%NVM_HOME%
确定
然后挨个确定
然后win+R cmd打开命令提示符 输入nvm 的任何一个命令即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace7d590965143a4cb96911665b8a8db/" rel="bookmark">
			ffmpeg下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ffmpeg的安装 1.官网下载FFmpeg
2.下载其中一个就可以
3.下载好解压到本地目录
4.打开“控制面板”，进入“编辑环境系统变量”
将ffmpeg文件路径地址粘过来，点击“确定”就可以了
5.cmd 输入 ffmpeg -version 检查一下是否安装成功
说明已经安装成功了 二、MP4转码webm 输入ffmpeg -i input.mp4 -c:v libvpx -crf 10 -b:v 1M -c:a libvorbis output.webm
其中，“-c:v libvpx”表示使用VP8视频编解码器，“-crf 10”表示视频质量，数值越小表示质量越高，“-b:v 1M”表示视频比特率为1Mbps，“-c:a libvorbis”表示使用Vorbis音频编解码器。将“input.mp4”替换为您要转换的MP4文件名，“output.webm”替换为您要输出的WebM文件名
对视频质量有要求的话可以 输入ffmpeg -i input.mp4 -lossless 1 output.webm
但是文件会变大很多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e9735322d29c60694c5ea4b8ef1b23/" rel="bookmark">
			RBAC96 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RBAC96（Role-Based Access Control '96）是一种基于角色的访问控制（Role-Based Access Control, RBAC）模型，最早由 Ravi Sandhu、Edward Coyne、Hal Feinstein 和 Charles Youman 在 1996 年提出。RBAC96 是一种非常具有影响力的 RBAC 模型，后续的许多基于角色的访问控制研究都以 RBAC96 作为基础。
背景：
在 RBAC96 之前，访问控制主要分为两类：自主访问控制（Discretionary Access Control, DAC）和强制访问控制（Mandatory Access Control, MAC）。DAC 是一种基于用户和对象的访问控制，对象的所有者可以决定谁可以访问对象。MAC 是一种更严格的访问控制，它根据安全策略来限制对象的访问。这两种方法都有局限性，特别是在处理大型组织和复杂的权限管理方面。为了解决这些问题，RBAC 应运而生，它通过角色将权限管理从用户和对象中解耦。
概念：
RBAC96 的核心思想是将权限分配给角色，而不是直接分配给用户。用户通过成为角色的成员来获得权限。这种设计使得权限管理更加灵活和可扩展，特别是在大型组织中。
RBAC96 定义了四个基本组件：
用户（User）：表示系统中的实体，如人员或其他系统。用户与角色之间的关系是多对多的，即一个用户可以属于多个角色，一个角色可以包含多个用户。角色（Role）：表示一组相关的权限。角色是 RBAC 的核心概念，角色之间可以存在继承关系。用户通过成为角色的成员来获得权限。权限（Permission）：表示访问受保护资源的能力。权限由操作和对象组成，例如“读取文件”或“修改数据库”。权限通常分配给角色，而不是直接分配给用户。会话（Session）：表示用户与系统之间的交互。会话允许用户激活他们的角色，从而限制他们在特定会话中可以使用的权限。这有助于实现最小特权原则，即用户只能访问他们完成任务所需的权限。 我们将设计一个基于 RBAC96 的数据库管理系统，用于管理一个在线书店。我们将创建几个角色，例如顾客、销售员、库存管理员和系统管理员。每个角色将具有不同的权限，以执行特定的操作。
首先，创建数据库表来存储 RBAC96 中的四个基本组件：用户、角色、权限和用户角色关联。
users 表：存储用户信息 CREATE TABLE users ( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(255) UNIQUE NOT NULL, password VARCHAR(255) NOT NULL, email VARCHAR(255) UNIQUE NOT NULL ); roles 表：存储角色信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e9735322d29c60694c5ea4b8ef1b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbeb181613a8adf735af30af4a4e2388/" rel="bookmark">
			Reactor 第九篇 WebFlux重构个人中心，效果显著
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 重构背景 原有的开发人员早已离职，代码细节没人知道，经过了一段时间的维护，发现有以下问题：
个人中心系统的特征就是组装各个业务的接口，输出个人中心业务需要的数据，整个系统调用了几十个第三方业务线的接口，如果编排不合理，可能会导致响应时间急剧上涨，尤其是弹窗业务，新的弹窗会不断接入，整个接口可能会不可用。
2 整体架构 service：是最小的业务编排单元，request方法对infrastructure第三方接口进行编排调用；apply 方法对第三方接口调用的结果进行组装，结果是service的业务返回；
infrastructure：是对第三方的异步非阻塞调用，不包含业务逻辑。一个service内部根据实际业务可以编排0个或者多个infrastructure服务。
在实际优化过程中我们抽象了30多个infrastructure第三方调用，40多个service。他们都是小而且独立的类，减轻了开发同学尤其是新同学熟悉的成本。边界也比较清晰，逻辑内聚。
2 编排举例 每个 service 内部都是由一个或者多个 infrastructure 第三方调用组装编排的业务单元，内部处理能异步处理的全是使用异步处理，实在不能异步处理的使用串行+并行的方式。
2.1 串行 需要串行的可以使用 flatMap 方法，可以参考以下格式。
这种方式会执行S1，然后S2。
伪代码如下：
Mono.from(service1.func()) .flatMap(service1Res-&gt; { return service2.func(); }) 2.2 并行 zip 和 zipWith，zipWith一次组装一个Mono，zip 一次可以组装多个Mono。
示例代码如下：
service1.zipWith(service2) Mono.zip(service1, service2, service3) 一个使用 zip 组装多个service的示例代码，并行执行service1, service2, …, service6，使用doOnError处理错误，onErrorReturn 处理异常返回，doOnFinally 监控整个接口调用量、耗时情况。
Mono.zip(service1, service2, service3, service4, service5, service6) .map(t -&gt; { String service1Ret = t.getT1(); String service2Ret = t.getT2(); // .... return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbeb181613a8adf735af30af4a4e2388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f276b95d85dfc6fa95b167d5972aa9eb/" rel="bookmark">
			html面经——css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同？ 盒模型都是由四个部分组成的，分别是margin、border、padding和content
标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。
一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
2、CSS的选择器有哪些？ id选择器（#myid）类选择器（.myclassname）标签选择器（div ,h1,p）后代选择器（h1 p）子选择器（ul&gt;li）兄弟选择器（所有）（li~a）相邻兄弟选择器（li+a ）属性选择器（a[rel=“external”]）伪类选择器（a:hover,li:nth-child）伪元素选择器（::before ::after）通配符选择器（*） 3、::before和::after中双冒号和单冒号有什么区别？解释一下这两个伪元素的作用。 在css3中使用单冒号来表示伪类，用双冒号来表示为元素。但是为了兼容已有的伪元素的用法，在一些浏览器中也可以使用单冒号来表示伪元素。
伪类一般匹配的是元素的一些特殊状态，比如hover、link等。而伪元素一般匹配的特殊的位置，比如after、before等。
4、伪类与伪元素的区别 css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不再在文档树中的部分，比如，一句话中的第一个字母或者是列表中的第一个元素。
伪类用于当已有的元素处于某个状态的时候，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素的时候，我们可以通过:hover来描述这个元素的状态。
伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为 元素的某些部分设置样式。比如说，我们可以通过::before 来在一个元素前面添加一些文本，并为这些文本设置样式。虽然用户可以看到这些文本，但是这些文本实际不存在于文档树中。
有时你会发现伪元素使用了两个冒号（::）而不是一个冒号。这是css3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用双冒号而不是单冒号。从而区分是伪元素还是伪类。但是，由于在旧的W3C龟板并未对此进行特别区分，因此目前绝大多数的浏览器都支持这两种方式表示伪元素。
5、CSS中哪些属性可以被继承？ 每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。
一般来说具有继承性的属性有
字体相关的属性：font-size和font-weight等。
文本相关的属性：color和text-align等。
表格的一些属性、列表的一些属性如list-style等。
还有光标属性cursor、元素可见性visibility。
当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。
6、CSS优先级的计算 判断优先级的时候，首先我们会判断一条属性声明是否具有权重，也就是是否在声明的后面加上了!important。一条声明如果加上了权重，那么它的优先级是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需去比较匹配规则的特殊性。
一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分成四个等级
行内样式，1000id选择器 0100类选择器、伪类选择器和属性选择器 0010元素选择器和伪元素选择器 0001
规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说1开头的特殊性值比所有以0开头的特殊性值要大。 如果两个规则的特殊值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级越高。
7、对于LVHA的解释？ a标签有四种状态:连接访问前，链接访问后、鼠标滑过、激活状态，分别对应四种伪类：:link、:visited、:hover、:active
当链接未访问时：
当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签 的颜色，就必须将:hover放在:link的后面声明当鼠标点击激活a链接的时候，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式(:active）就必须把它放到link和hover之后。所以得出LVHA这个顺序。
当链接访问过时候，情况基本同上，只不过需要将:link换成:visited 这个顺序可以变，但是只有link和visited能够交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足。也就不存在覆盖的问题。
8、CSS新增的伪类有哪些？ :enabled：控制表单控件的状态:disabled：控制表单控件的状态:checked单选框或复选框被选中elem:empty选中不包含子元素和内容的elem类型元素 9、如何居中div？ 一般常见的几种居中方法有：
对于宽高固定的元素
利用margin:0 auto来实现元素的水平居中利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。利用绝对定位，先将元素的左上角通过left：50%和top:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。使用flex布局，通过align-items：center和justify-content：center设置容器的垂直和水平方向上的居中对齐，然后它的子元素也可以实现垂直和水平居中。 对于宽高不固定的元素，上面的后两种方法，可以实现元素的垂直和水平居中。
10、display有哪些值？说明它们的作用？ block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none 元素不显示，并从文档流中移除inline 行内元素类型。默认宽度为内容宽度，不支持设置宽高，同行显示。inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。list-item 像块类型元素一样显示，并添加样式列表标记。table 此元素会作为块级表格来显示。inherit 规定应该从父级元素继承display属性 的值。 11、position的值relative和absoulute定位原点是？ relative定位的元素，是相对于元素本身所在文档流中的位置进行定位的。
absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，首先需要找到一个绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来进行定位，也就是说在计算定位距离的时候，padding的值也要算进去。
12、CSS有哪些新特性？（根据项目回答） 新增各种CSS选择器（:not(.input)：所有class不是“input”的节点）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f276b95d85dfc6fa95b167d5972aa9eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca5eba1ca12c30f22b93e4b53cc705c/" rel="bookmark">
			基于OpenHarmony开发的健康生活应用（ArkTS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		健康生活应用（ArkTS） 介绍 本篇Codelab介绍了如何实现一个简单的健康生活应用，主要功能包括：
用户可以创建最多6个健康生活任务（早起，喝水，吃苹果，每日微笑，刷牙，早睡），并设置任务目标、是否开启提醒、提醒时间、每周任务频率。
用户可以在主页面对设置的健康生活任务进行打卡，其中早起、每日微笑、刷牙和早睡只需打卡一次即可完成任务，喝水、吃苹果需要根据任务目标量多次打卡完成。
主页可显示当天的健康生活任务完成进度，当天所有任务都打卡完成后，进度为100%，并且用户的连续打卡天数加一。
当用户连续打卡天数达到3、7、30、50、73、99天时，可以获得相应的成就。成就在获得时会以动画形式弹出，并可以在“成就”页面查看。
用户可以查看以前的健康生活任务完成情况。
相关概念 @AppStorage：应用程序中的单例对象，为应用程序范围内的可变状态属性提供中央存储。
@Observed 和 @ObjectLink：@Observed适用于类，表示类中的数据变化由UI页面管理；@ObjectLink应用于被@Observed装饰类的对象。
@Consume 和 @Provide：@Provide作为数据提供者，可以更新子节点的数据，触发页面渲染。@Consume检测到@Provide数据更新后，会发起当前视图的重新渲染。
Flex：一个功能强大的容器组件，支持横向布局，竖向布局，子组件均分和流式换行布局。
List：List是很常用的滚动类容器组件之一，它按照水平或者竖直方向线性排列子组件， List的子组件必须是ListItem，它的宽度默认充满List的宽度。
TimePicker：TimePicker是选择时间的滑动选择器组件，默认以00:00至23:59的时间区创建滑动选择器。
Toggle：组件提供勾选框样式、状态按钮样式及开关样式。
关系型数据库（Relational Database，RDB）：一种基于关系模型来管理数据的数据库。
环境搭建 软件要求 DevEco Studio版本：DevEco Studio 3.1 Beta2及以上版本。OpenHarmony SDK版本：API version 9及以上版本。 硬件要求 开发板类型：润和RK3568开发板。OpenHarmony系统：3.2 Release及以上版本。 环境搭建 完成本篇Codelab我们首先要完成开发环境的搭建，本示例以RK3568开发板为例，参照以下步骤进行：
获取OpenHarmony系统版本：标准系统解决方案（二进制）。以3.2 Release版本为例：
搭建烧录环境。
完成DevEco Device Tool的安装完成RK3568开发板的烧录 搭建开发环境。
开始前请参考工具准备，完成DevEco Studio的安装和开发环境配置。开发环境配置完成后，请参考使用工程向导创建工程（模板选择“Empty Ability”），选择JS或者eTS语言开发。工程创建完成后，选择使用真机进行调测。 代码结构解读 本篇Codelab只对核心代码进行讲解，完整代码可以直接从gitee获取。
├──entry/src/main/ets // 代码区 │ ├──common │ │ ├──bean │ │ │ ├──ColumnInfo.ets // 数据表信息接口 │ │ │ ├──DayInfo.ets // 每日信息接口 │ │ │ ├──GlobalInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ca5eba1ca12c30f22b93e4b53cc705c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b39387d052aceaf9ddcf4dc18150cb/" rel="bookmark">
			nacos启动关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动服务器
注：Nacos的运行需要以至少2C4g60g*3的机器配置下运行。
Linux/Unix/Mac
启动命令(standalone代表着单机模式运行，非集群模式):
sh startup.sh -m standalone
如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：
bash startup.sh -m standalone
Windows
启动命令(standalone代表着单机模式运行，非集群模式):
startup.cmd -m standalone
关闭服务器
默认集群，无集群会报错
Linux/Unix/Mac
sh shutdown.sh
Windows
shutdown.cmd
单机启动
windows启动：
startup.cmd -m standalone
linux启动：
startup.sh -m standalone
或者双击shutdown.cmd运行文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c98415201b5a31cdea10be026b39490/" rel="bookmark">
			百万级数据导入导出优化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 背景 大家在日常的开发中，excel导入导出是非常常见的需求，大部分公司因为业务量比较小，操作的数据量都是几千、几万，这个级别的数据量，我们采用apache的POI很轻松可以搞定，但如果遇到大型互联网公司动不动就百万级别的用户体量，POI就会出现各种各样的问题，比较常见的现象就是内存OOM或者导入导出耗时特别久无响应，很显然，POI在百万级别的数据量处理，已经不合适了。
2、痛点 1、导入百万级别数据(excel)到DB，有什么痛点呢? 一次加载百万级别数据到内存，发生OOM?
导入时百万级别数据存储到DB如果循环一条条插入，数据库链接不够用?
2、导出百万级别数据(DB)到excel，有什么痛点? 一次查询百万级别数据到内存，mybatis查询超时报错?
一次加载百万级别数据到内存，发生OOM?
百万级别数据导出到Excel，写到一个Sheet中，能打开，不卡爆?
百万级别数据导出到Excel中一行一行写入Excel，频繁io操作，CPU飙高?
3、业务操作高峰期，后台管理员频繁操作导入导出excel，这个时候系统很容易就会因为内存溢出挂掉了 3、解决方案 1、选用合适的excel开源处理框架 阿里的easyexcel
2、百万级别导入方案 逐行解析excel数据，分批读取excel数据放到List， ist达到一定数据量持久化到DB，同时清空List列表数据；
采用mybatis的foreach批量保存、mybatis-plus批量saveBatch法保存；
3、百万级别导出方案 分批分页查询db数据到内存，比如一次查询5000条，分20次分批查询出来；
每次加载指定大小的数据到内存，比如每次5000条，5000条批量写入到excel以后，清空当前List，释放内存；
分多个sheet写入，每个sheet比如放20w，100百万数据放到5个sheet；
4、解决高峰期导入导出资源瓶颈 从产品侧设计的时候，引导产品，将导入导出功能设计成异步，尽量不要同步等待，虽然牺牲了一点体验，但是长期看对系统的稳定非常重要(为了产品的体验，可以提供一个统一excel导入导出历史记录功能给产品或运营同学，支持查看对应的下载进度，可追溯)，异步导入导出可参考这里
Java注解实现异步导入与导出（一）
Java注解实现异步导入与导出（二）
前端导入导出按钮控制操作的频率，比如3分钟内不能频繁导入导出。
后端导入导出采用MQ异步排队处理，防止把内存写爆，CPU打满。
采用动态配置开关控制导入导出的数量，通过压测预估系统处理数据的阔值，导入导出超过闻值需要产品或运营发邮件申请，开发修改配置如果业务确实有超大数据量要求，超过闽值太多，引导产品或运营分批导入导出解决。
通过以上方法，能够有效的支撑百万级别的数据导入导出，而且系统的CPU、内存等核心指标不会出现明显波动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213980dd477c4ed5a98ccc57e0771f06/" rel="bookmark">
			行人重识别(REID)——原理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行人重识别：短时 类内差异增大，类间差异减小 应用——行人跟踪 单摄像头单目标单摄像头多目标多摄像头多目标 行人重识别系统 特征提取
学习能够应对在不同摄像头下行人变化的特征
度量学习
将学习到的特征映射到新的空间使相同的人更近，不同的人更远
图像检索
根据图片特征之间的距离进行排序，返回检索结果
评价模式 single query vs multi query
Single query是指probe中每个人的图像为一张（N=1），而multi query是指probe中每个人的图像为N&gt;1张图像，然后融合N张图片的特征（最大池化或者平均池化）作为最终特征。同样的Rank-k下，一般N越大，得到的识别率越高。
特征 全局特征 每一张图片的全局信息进行一个特征抽取，全局特征没有任何的空间信息。
噪声区域会对全局特征造成极大的干扰姿态的不对齐也会使全局特征无法匹配 局部特征 对图像的某一个区域进行特征提取，最后将多个局部特征融合起来作为最终特征
水平切块 ★★★ 将图像进行水平方向的等分，每一个水平切块通过水平池化提取一个特征
Gate Siamese 和 AlignedReID 通过设计规则融合所有的局部特征计算距离
PCB，ICNN，SCPNet 对每一个局部特征计算一个 ReID 损失，直接将局部特征拼接起来
联合局部特征和全局特征往往能够得到更好的结果
Gate Siamese
每一块经过 CNN 网络得到特征，局部特征按顺序输入到 LSTM 网络，自动表达为图像最终的特征利用对比损失训练网络 AlignedReID
主要解决姿态不对齐的问题
骨架网络为 ResNet50
动态对齐 (DMLI) 假如输入图像为256×128，输出的特征图尺寸为 8×4×2048利用水平池化得到 8 个局部特征，并计算一个 8×8 的距离方阵对齐局部信息不能有跳连（从上到下）利用 shortest path 来找到最优的动态连接 PCB
输入图像 384×128，分成 6 块利用 ResNet50 提取特征，最后 24×8 的 feature map每一行提取一个局部特征，连接一个 ReID loss使用的时候把 6 个局部特征 concatenate 起来 ICNN
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/213980dd477c4ed5a98ccc57e0771f06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b95ad3ba539119013ab80d6af1418d3/" rel="bookmark">
			docker本地私有仓库与harbor私有仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建本地私有仓库
1、首先下载registry镜像
1
docker pull registry
2、在daemon.json文件中添加私有镜像仓库地址
1
2
3
4
5
6
7
8
vim /etc/ docker/daemon.json
{
"insecure-registries": ["192.168.80.11:5000"],
#添加，注意用逗号结尾
"registry-mirrors": ["https://6ijb8ubo.mirror.aliyuncs.com"]
}
systemctl restart docker.service
3、运行registry容器
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
docker run -itd -v /data/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest
===================================================
-itd: 在容器中打开一个伪终端进行交互操作，并在后台运行
-v: 把宿主机的/data/registry目录绑定到容器/var/lib/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的
持久化;
-p:映射端口;访问宿主机的5000端口就访问到registry容器的服务了
--restart=always: 这是重启的策略，在容器退出时总是重启容器
--name registry: 创建容器命名为registry
registry:latest:这个是刚才pull下来的镜像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b95ad3ba539119013ab80d6af1418d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70346344b326ead61da57f7e07f4d60b/" rel="bookmark">
			抖音和tiktok的逆向开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短格式的移动视频共享已成为当今互联网技术中最热门的趋势之一。像字节跳动的 抖音和TikTok 这样的领先平台允许用户分享设置为音乐的活泼剪辑，捕捉滑稽舞蹈、唇形同步和其他形式的自我表达的转瞬即逝的瞬间。作为一名逆向工程师，您可能很想分析这些应用程序并可能对其进行修改，但是您应该这样做吗？在讨论私人开发的专有闭源代码库时，答案并不是很简单。但是，您绝对可以研究客户端和服务器生成的网络流量。事实上，开发现代移动应用程序所涉及的大部分工作都涉及使用标准化 API（如 RESTful Web 服务）通过 HTTP 或其加密副本 HTTPS 进行通信。如果你足够了解网络协议，
在深入分析数据包之前，请考虑您为什么想要研究 抖音和TikTok 等流行的消费者应用程序。由于社交媒体平台严重依赖用户生成的内容，因此它们可以帮助您在将它们部署到企业解决方案之前尝试处理音频或视觉信息的新方法。由于成千上万的并发用户访问每秒运行数百万个查询的服务器所产生的大量数据，它们还在可扩展性方面提出了新的工程问题。解决方案包括跨分布式数据库（如 Apache Cassandra 或 Google Bigtable）对数据进行分片，将频繁访问的数据缓存在内存缓存或内容分发网络 (CDN) 中，在存储和传输过程中应用压缩和加密，以及将计算卸载到 GPU 集群或专用 ASIC 硬件上。最后，专门研究 TikTok 可以让我们了解支持图像识别、字幕生成、翻译、摘要、推荐引擎、机器人检测、欺诈预防、情绪分析器、语音合成和数字信号处理器的人工智能技术如何改进现实世界的产品。尽管研究这些创新技术很重要，但风险仍然很大——但无论如何让我们继续，检查一旦 TikTok 客户端在播放时开始发出 HTTP POST 或 GET 请求后会发生什么。
要进一步调查，请利用 Wireshark 开源协议分析器（LibPcap 的 GUI，它本身构建在 Linux 内核 iptables 之上）以被动嗅探局域网接口来捕获 TCP 流。尽管 TikTok 提供了涵盖各种 API 端点的文档，以便以编程方式与其基础设施进行交互，但除非遵循某些模式，否则仅手动输入 URL 通常不会产生预期的结果。具体来说，许多功能需要发送额外的元数据以及用户凭证；cookie 似乎不是必需的，尽管 HSTS 强化了服务器以抵御 SSL strip 攻击，确保令牌仅在访问客户端收到由受信任的证书颁发机构签署的 TLS 证书后到达。Nonce 计数器防止跨站点请求伪造。在观察到跨渠道流动的大量不同消息后，从捕获的会话中提取与您的目标相关的标头，特别关注内容类型和接受选项。根据上下文，他们将确定可接受的文件格式、字符编码、支持的 HTTP 版本、所需的媒体播放器、DNT 跟踪首选项等等。客户端通常使用众所周知的方法（例如 3xx 状态代码）遵循重定向响应。到达最终目的地后，使用包含在 PUTPOSTGET 参数中的 JSON 对象发送有效负载。您的应用程序 ID 保密，存储在本地读取的配置文件中，而不是通过 HTTP 发送。相反，识别与您的帐户关联的令牌字符串；有时这会在首次注册客户端应用程序时作为初始登录确认屏幕的一部分立即出现。下一个，检查令牌的有效期。有些在三分钟后过期，必须在必要时从数据库中刷新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3099c2383da8639b08aa98f56eaada98/" rel="bookmark">
			手把手教你本地CPU环境部署清华大模型ChatGLM-6B，利用量化模型，本地即可开始智能聊天，达到ChatGPT的80%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是微学AI，今天教你们本地CPU环境部署清华大ChatGLM-6B模型，利用量化模型，每个人都能跑动大模型。ChatGLM-6B是一款出色的中英双语对话模型，拥有超过62亿个参数，可高效地处理日常对话场景。与GLM-130B模型相比，ChatGLM-6B在对话场景处理能力方面表现更加卓越。此外，在使用体验方面，ChatGLM-6B采用了模型量化技术和本地部署技术，为用户提供更加便利和灵活的使用方式。值得一提的是，该模型还能够在单张消费级显卡上顺畅运行，速度较快，是一款非常实用的对话模型。
ChatGLM-6B是清华开发的中文对话大模型的小参数量版本，目前已经开源了，可以单卡部署在个人电脑上，利用 INT4 量化还可以最低部署到 6G 显存的电脑上，在 CPU 也可以运行起来的。
项目地址：mirrors / THUDM / chatglm-6b · GitCode
第1步：下载：
git clone https://gitcode.net/mirrors/THUDM/chatglm-6b.git 第2步：进入ChatGLM-6B-main目录下，安装相关依赖
pip install -r requirements.txt 其中 torch安装CPU版本即可。
第3步：打开ChatGLM-6B-main目录的web_demo.py文件，源代码：
from transformers import AutoModel, AutoTokenizer import gradio as gr import mdtex2html tokenizer = AutoTokenizer.from_pretrained("THUDM/chatglm-6b", trust_remote_code=True) model = AutoModel.from_pretrained("THUDM/chatglm-6b", trust_remote_code=True).half().cuda() model = model.eval() 这个是在GPU版本下的代码，现在改为CPU版本下的代码：
from transformers import AutoModel, AutoTokenizer import gradio as gr import mdtex2html tokenizer = AutoTokenizer.from_pretrained("THUDM/chatglm-6b-int4", trust_remote_code=True) model = AutoModel.from_pretrained("THUDM/chatglm-6b-int4", trust_remote_code=True).float() model = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3099c2383da8639b08aa98f56eaada98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680b5387d17ceed2aac340d7ca1cb73a/" rel="bookmark">
			前端三剑客之HTML】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐个人主页：书生♡博客主页🙋‍♂
🍑博客领域：java编程,前端，算法，强训题目
写作风格：干货,干货,还是tmd的干货
支持博主：点赞、收藏⭐、留言💬
目录 1.前端1.1什么是前端1.2前端的作用 2.HTML2.1什么是HTML2.2HTML文件基本结构2.3标签的层次结构 3.HTML常见标签3.1什么是标签3.2常见标签3.2.1注释标签3.2.2标题标签 h3.2.3段落标签 P3.2.4 换行标签 br3.2.5格式化标签3.2.6图片标签 img3.2.7 超链接标签 a3.2.8 表格标签3.2.9 列表标签3.2.10 表单标签3.2.11 无语义标签 1.前端 1.1什么是前端 前端又称web前端，web顾名思义就是网页，所以大部分人的理解就是前端就是做网页的。但其实并不是，前端开发是创建WEB页面或APP等前端界面呈现给用户的过程，通过HTML，CSS及JavaScript以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互的过程。以前的前端确实就是单纯的用DreamWeaver以及其它一系列的软件做静态网页，但随着互联网技术的不断发展，网站开发的难度加大，网页从静态发展为动态，交互效果更加强大。
随着手机成为人们不可或缺的一部分，前端也开始向手机端发展，向我们平时所用的微信小程序和一些手机app都属于前端。随着科技的不断发展，前端还在向智能电视、智能手表甚至人工智能领域等方面不断的发展。
1.2前端的作用 （1）简化界面，交互功能技术支持
（2）浏览器兼容支持
（3）提高用户浏览速度
（4）跨平台支持（基于webkit等的渲染引擎的应用）
（5）数据显示在页面上（数据接口）
2.HTML 前端中有三个是非常重要的，那就是我们俗称前端三剑客的 HTML，CSS，JS
这里我们现来了解一些什么是HTML.
2.1什么是HTML HTML，全称为超文本标记语言（HyperText Markup Language），是一种用于创建网页的标准标记语言。它使用各种标签和属性来描述网页的结构和内容，包括文字、图像、超链接、音频、视频等元素。HTML 文件通常可以通过 Web 浏览器进行解析和渲染，从而呈现出具有格式和样式的网页。
HTML代码是由标签组成的。
例如
&lt;body&gt;hello&lt;/body&gt; 咱们最开始的就会给你一部分的标签 当我们输入（！）的时候回车就会出现
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 细节解释: (了解即可, 不必深究)
&lt; !DOCTYPE html&gt; 称为 DTD (文档类型定义), 描述当前的文件是一个 HTML5 的文件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/680b5387d17ceed2aac340d7ca1cb73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b3ec241e05973667dd2374900c6f59/" rel="bookmark">
			C&#43;&#43; 笔记 21 （STL常用算法 - 遍历 &amp; 查找）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五. STL-常用算法 概述：
算法主要是由头文件&lt; algorithm &gt;&lt; functional &gt;&lt; numeric &gt;组成；&lt; algorithm &gt;是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等；&lt; numeric &gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数；&lt; functional &gt;定义了一些模板类，用以声明函数对象 1. 常用遍历算法 for_each 遍历容器 transform 搬运容器到另一个容器 1.1 for_each 功能：实现遍历容器
原型：
for_each(iterator beg, iterator end ,_func()) /*iterator beg为开始迭代器，iterator end为结束迭代器， _func()为函数或者函数对象*/ 示例：
//普通函数 void print01(int val) { cout&lt;&lt;val&lt;&lt;" "; } //函数对象 class Print02 { public: void operator()(int val) { cout&lt;&lt;val&lt;&lt;" " } }; vector&lt;int&gt;v; for_each(v.begin(),v.end(),print01); for_each(v.begin(),v.end(),print02()); 总结：for_each是最常用的遍历算法，需要熟练掌握。
1.2 transform 搬运容器到另一个容器中；
原型：
transform(iterator beg1,iterator end1,iterator beg2,_func) 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b3ec241e05973667dd2374900c6f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8aabc34a710c3e47d20db75425fa2a4/" rel="bookmark">
			【DarkLabel】使用教程（标注MOT数据集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DarkLabel 使用教程 功能部分 Open video
第 2 处的内容为数据集类型。例如：VOC、COCO、MOT、YOLO等。
第 3 处的内容为标签名称。
可在 darklabel.yml 中修改 classes_set。例如：classes_set: "mot_classes"
第 4 处的内容为两种跟踪方法可选：
Tracker1(robust)
插值法，每次一个目标。
首先在第一帧点击Begin Interpolation，然后画目标bbox，按↓键往后几十帧，在找到该目标画出bbox，点击End Interpolation，然后就可以看到中间帧该目标都被圈住了，效果挺好的。
Tracker2(accurate)
在当前帧画出多个目标bbox，然后点击next,这些算法，越往后bbox就越不准了，但是可以多个目标同时跟踪，插值效果比较好，但是只能一个一个目标跟踪，自己选择。
第 5 处的内容为
第 6 处的内容为
功能快捷键 Arow / PgUp / PgDn / Home / End：浏览图像帧
鼠标：左（创建框），右（取消最近创建的框）
Shift +鼠标：向左（修改框），向右（删除所选框/轨迹或所有框）
Shift + DoubleClick：修改框属性（标签，ID，难度）
Ctrl +’+’/’-’：放大/缩小
Ctrl +箭头：滚动缩放窗口
Ctrl + 滚珠：放大/缩小
Ctrl +s：保存gt
F1：显示此帮助
撤回画的bbox：在任意区域按压鼠标右键，以出栈的顺序依次删除bbox
删除指定bbox：鼠标放在bbox上，按压shift键，点击鼠标右键删除bbox
调整bbox：鼠标放在bbox上，按压shift键，点击鼠标左键可以修改bbox类别和id
yaml 配置文件 ## Default Settings media_path_root: "H:\\darklabel_test\\media" # if specified, image/video files are opened in this folder by default gt_path_root: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8aabc34a710c3e47d20db75425fa2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700f91394b4fe2b7f108fcb39f0a4733/" rel="bookmark">
			Python微信订餐小程序课程汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python微信订餐小程序课程视频 https://edu.csdn.net/course/detail/36074
结合chatgpt提问快速掌握python订单小程序开发 快速提问提高学习效率
你将收获 从基础语法入手，构建MVC架构
增进对小程序和后端API的理解认识
从项目搭建到部署上线，让你掌握Python全栈开发
从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。
适用人群 Python web后端开发，想进阶全栈系统学习的你 技术储备要求 Python语法基础、Web后端开发基础，对前端有所了解
从项目搭建到部署上线，让你掌握Python全栈开发！ 本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。
课程介绍 从基础语法入手，构建MVC架构，增进对小程序和后端API的理解认识。帮助你快速提升项目经验，提高项目中解决问题的能力。
部署上线 操作系统: CentOS7 远程连接：SSH 环境：Python3 数据库: Mysql 网关：UWSGI 版本管理: Git
环境参数 系统： Linux + CentOS7 / Windows语言： Python3.X数据库： Mysql5.7
前端-小程序 授权登录 微信支付 上拉刷新 分页模板消息 小程序分享
Python3 + Flask Python3安装 数据库安装 Flask框架和扩展安装 快速体验Hello World 路由规划 数据库ORM
后台管理系统 搭建高可用Flask MVC框架 管理员Cookie登录态 登录和错误处理拦截器 通用支付系统设计 无刷新上传技术和图片服务链接统一管理器
有前有后，打造性感全栈项目 高性价比课程，带你迈进python全栈工程师
腾讯云部署，轻松发布属于你的上线小程序
招聘要求越来越高，热门技术一网打尽
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcb3aa4ba5355401d17122735e09a34/" rel="bookmark">
			Three.js--》Gsap动画库基本使用与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Gsap动画库使用讲解
Gsap动画库基本使用
修改自适应画面及双击进入全屏
设置stats性能监视器
Gsap动画库使用讲解 GSAP的全名是GreenSock Animation Platform，是一个从flash时代一直发展到今天的专业动画库，今天将其与three.js进行结合，看看能够创作出怎样的效果，首先我们先要理解动画渲染循环的原理：three.js可以借助HTML5的API请求动画帧 window.requestAnimationFrame 实现动画渲染，如下：
// 周期性执行，默认理想状态下每秒钟执行60次 function render(){ cube.rotateY(0.01) // 周期性旋转，每次旋转0.01弧度 renderer.render(scene,camera) // 周期性执行相机的渲染功能，更新canvas画布上的内容 requestAnimationFrame(render) // 接下来渲染下一帧的时候就会调用render函数 } // 先开始就渲染一下 render() Gsap动画库基本使用 首先进行第三方库的安装，终端执行如下命令即可：
npm install gsap 安装完成之后，导入动画库即可：
// 导入动画库 import gsap from 'gsap'; 可以参考 官网 这里使用ease，来实现动态曲线变化率：
当然gsap还有许多好玩的属性，可以对动画进行精准的操作，如下：
当然如果想对动画进行暂停还启动的效果也是可以的，我们可以设置一个监听事件，当动画处于运动状态下，双击屏幕进行动画暂停，当动画处于暂停状态下，双击屏幕进行动画启动，如下我们对正方体的移动进行监听限制，但是不限制正方体的旋转，效果如下：
当然你也可以设置一下设置控制器阻尼，相关介绍可参考官方文档，如下给出解释：
修改自适应画面及双击进入全屏 不知道大家有没有发现，启动项目打开浏览器给出你画面的时候是正常，可一旦你修改浏览器尺寸大小，3d动画效果是不会随着你浏览器尺寸的变化而变化的，最后呈现的结果永远是那个像素大小
经过如下设置可以修改3d画面的分辨率大小值，代码如下：
// 监听画面变化，更新渲染界面 window.addEventListener('resize',()=&gt; { // 更新摄像头 camera.aspect = window.innerWidth / window.innerHeight // 更新摄像机的投影矩阵 camera.updateProjectionMatrix() // 更新渲染器 renderer.setSize(window.innerWidth,window.innerHeight) // 设置渲染器的像素比 renderer.setPixelRatio(window.devicePixelRatio) }) 解决完自适应画面后，接下来实现双击进入全屏的效果，这个实现与上面讲解到的双击暂停和启动动画效果是一致的，无非是调用进入全屏和退出全屏的相关API函数而已，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcb3aa4ba5355401d17122735e09a34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ef3fe3c9db2c063ea45be493c8f131/" rel="bookmark">
			java 死锁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是Java死锁？
定义和原理
死锁的特点和表现形式
Java死锁产生的原因
资源竞争
线程调度问题
如何检测Java死锁？
jstack命令
jconsole工具
VisualVM分析器
Java死锁案例分析
案例分析和解决方法
总结
Java死锁的知识点回顾
死锁对程序性能和稳定性的影响
如何预防和解决Java死锁问题
什么是Java死锁？ 定义和原理 Java死锁是指两个或多个线程在互相请求对方占用的资源时处于等待状态，导致程序无法继续执行的现象。
死锁发生的原理是由于每个线程都持有一个资源并且同时等待另一个资源，这样就会形成一种僵局，没有任何一个线程能够释放其持有的资源，也无法获得它所需的资源。这样的情况下，程序就会停止响应，形成死锁。解决死锁通常需要使用一些技术手段，如避免嵌套锁、使用可重入锁、资源分配策略等。
死锁的特点和表现形式 两个或多个线程互相持有对方所需的资源，并同时等待对方释放资源，导致程序无法继续执行。程序会陷入一种“僵局”状态，无法自行解锁，需要手动进行干预或者使用一些技术手段来避免或解决死锁。死锁通常会导致程序无响应或者卡死，无法正常处理请求，给用户带来不好的体验。 Java死锁产生的原因 资源竞争 资源竞争是指多个线程同时竞争有限的资源，例如共享内存、文件、数据库连接等。如果这些线程在竞争资源时，出现了相互等待对方释放资源的情况，就可能导致死锁。例如，线程A持有锁L1，但需要锁L2才能继续执行，而线程B持有锁L2，但需要锁L1才能继续执行，这样就会发生死锁。
线程调度问题 线程调度问题是指操作系统或虚拟机在调度线程时出现问题，例如某个线程长时间占用CPU资源，导致其他线程无法得到执行机会。这样就可能导致等待资源的线程被无限期地挂起，从而出现死锁。例如，线程A在执行耗时任务时一直占用CPU资源，而线程B在等待A释放共享资源，但由于A一直没有释放，B也无法继续执行，就会出现死锁。
如何检测Java死锁？ jstack命令 a) 运行Java应用程序：java &lt;应用程序名&gt;
b) 在不同窗口中打开一个终端
c) 输入 jps 命令，将显示正在运行的 Java 应用程序的进程 ID。
d) 输入 jstack 命令并指定 Java 应用程序的进程 ID： jstack &lt;Java 进程 ID&gt;
e) 可能需要几秒钟才能运行此命令，但它会输出应用程序的详细信息和堆栈跟踪，包括死锁或潜在死锁的提示。
jconsole工具 a) 运行 Java 应用程序。
b) 打开 Jconsole 工具： $ jconsole
c) 在弹出的界面中，选择“远程”选项卡。
d) 在主控服务器的 IP 地址或机器名下输入相应的IP地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ef3fe3c9db2c063ea45be493c8f131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fed4fd597b36aebf89b0e75f9f4b28b/" rel="bookmark">
			webpack 面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、谈谈你对Webpack的理解（Webpack是什么？）
2、webpack核心概念
3、 webpack 切换环境，区分环境，跨平台传递参数
4、webpack有哪些优化方式？
5、plugin的作用
6、webpack 中的插件plugin与加载器loader的区别 ？
1、谈谈你对Webpack的理解（Webpack是什么？） Webpack 是一个 静态模块打包器，可以分析各个模块的依赖关系，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部递归构建出一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。最终编绎输出模块为 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等）。
webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。
webpack的主要作用如下： 模块打包 可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。 编译兼容 在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less，.vue，.jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。 能力扩展 通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。
2、webpack核心概念 入口：entery 从那开始进入打包 index.js/main.js
出口：文件输入的位置 output
plugin：插件 ，在webpack运行生命周期过程中进行打包清理，压缩等额外操作
loader：加载器处理非.js 文件的
mode：模式production development
tip：vue.config.js 其实就是webpack.config.js的vue版本（大部分可通用）
3、 webpack 切换环境，区分环境，跨平台传递参数 cross-env 插件跨平台传递参数，通过参数区分环境，切换环境。
process.env 这个参数（axios的baseURL也是通过pross.evn区分环境的）
4、webpack有哪些优化方式？ 区分生产模式和开发模式
压缩优化css，压缩优化js，压缩图片，base64小文件减少请求
使用hash命名控制二次缓存
异步加载，懒加载，按需加载，摇树treeshake
5、plugin的作用 plugin是一个类，类中有一个apply()方法，主要用于Plugin的安装，可以在其中监听一些来自编译器发出的事件，在合适的时机做一些事情。
webpack中的plugin赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在webpack的不同阶段（钩子 / 生命周期），贯穿了webpack整个编译周期。目的在于「解决 loader 无法实现的其他事」。
6、webpack 中的插件plugin与加载器loader的区别 ？ loader用来处理非js文件的，插件在webpack运行生命周期中进行压缩，清理等工作
后面补充！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9cd85762e09f095f6119b163acdb95a/" rel="bookmark">
			Elasticsearch写入速度优化[翻译版]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章「程序员英语学习指北: 阅读篇」中提到了学习英语需要用起来，假期尝试对Elasticsearch文档进行了翻译，最终成果如下。
原文链接：https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-indexing-speed.html
1.使用批处理请求接口（bulk requests） 批处理接口的性能要远优于单文档写入接口。为了确定批处理最适合的大小，基准测试应该基于单节点、单分片。首先尝试一次写入100个文档，然后加大到200个、400个，以此类推。每次跑基准测试时将写入数量加倍。当写入速度趋于平稳时，说明已经达到了单次写入的最适合批次大小。在同等情况下，文档数量不宜过多。值得注意的是，大数据量的批处理请求在并发高时，会加大集群的内存压力，因此需要尽量避免一次请求超过几十兆的数据量，就算是效率更高。
2.使用多线程实现写入数据 单线程发送批处理请求，并不能最大化Elasticsearch集群的写入效率。为了集群资源的最大化利用，你应该使用多线程来进行处理。除了更好的利用集群资源，还能够降低数据同步的成本。
当出现 TOO_MANY_REQUESTS (429) 返回码（在Java客户端是 EsRejectedExecutionException 异常）时，说明 Elasticsearch 无法承载当前的写入速率。此时，你需要降低写入的速率，最好能够使用指数级的降级策略。
和批处理大小类似，确定并发线程数量只能通过不断的测试。测试方式是通过逐步增加线程数量，直到 I/0 或者 CPU资源达到饱和为止。
3.不设置或者增大刷新间隔 通过 refresh 操作，数据才能被搜索到，执行成本较高，当数据正在写入时，频繁的 refresh 会影响写入速度。
默认情况下，Elasticsearch每秒刷新一次索引，但是只有在最近30s内收到一次或者多次搜索请求时才会生效。
如果你的搜索请求量非常小(例如，5分钟内少于一次)，或者想要优化写入速度，有相应的配置可以进行支持。默认情况是这没有搜索执行时，可以自动优化批量写入速度。可以通过设置刷新间隔参数来显式的进行设置。
另一方面，如果你的索引有比较稳定的请求流量，Elasticsearch将默认每秒刷新一次数据。如果你能够接受文档从写入完成到可以被搜索到有较大的延迟时间，可以将
index.refresh_interval 参数设置为一比较大的值，例如30s，可以改善文档写入速度。
4.在初始化时不开启备份 如果你有大批量的数据想要一次性导入到Elasticsearch，将 index.number_of_replicas 参数设置为0将有利于提升写入速度。缺少备份意味着存在数据丢失的风险，所以很重要的一点是，在其他地方有存储这份数据以便在意外的情况下可以进行重试操作。一旦数据初始化工作完成，可以将index.number_of_replicas 参数恢复为原始值。
如果index.refresh_interval 参数是配置在索引上的，在初始化数据的场景下不进行设置，在初始化完成后恢复原始值，将会是一个很有帮助的特性。
5.关闭swapping 你应该通过关闭操作系统的swapping的功能，来确保Java进程的内存不会被超额使用。
6.留足文件系统内存 文件系统内存用于数据的 I/O 操作。你应该确保运行Elasticsearch的机器上至少有一半的内存可以被文件系统内存使用。
7.使用自增ID 当写入一份带有id属性的文档时，Elasticsearch需要检查在同一个分片上是否已经存在具有相同id的文档，而这个操作随着文档数量的增加将耗费更多的时间。使用自增id，Elasticsearch可以跳过检查的这一步，加快写入速度。
8.使用更快的硬件 如果数据写入达到了I/O瓶颈，可以考虑增加文件系统的内存或者使用更快的存储设备。Elasticsearch在创建单个文件时是使用顺序写入。然而，并发写入多个文件时，会涉及到随机读和顺序读操作，因此SSD要比机械硬盘有更好的性能。
通过设置RAID 0磁盘阵列，将索引分布着多个SSD磁盘上。这样会增加失败的风险，当任一SSD磁盘毁坏了索引数据时。然而，常用的权衡利弊的做法是，将单个分片的性能提升到极致，然后通过副本的方式在其他分片上设置冗余数据，来解决任意节点失败的情况。为了更加保险，可以通过设置快照的方式来进行备份数据。
9.写入的缓存大小 如果你的节点在进行大量数据写入，确保 indices.memory.index_buffer_size 参数足够大到每个分片有最多512M的indexing buffer（超过这个值写入性能不会有明显的改善）。Elasticsearch将这个设置（java heap的百分比或者具体的数值）作为共享内存提供给所有活跃的分片使用。更加活跃的分片会占用更多的内存。
默认值10%通常上足够的，例如，jvm内存设置为10G，index buffer就上1G了，足够2个分片进行大量数据的写入。
10.使用多集群实现读写分离 在单个集群中，读写需要竞争资源。设置2个集群，通过跨集群复制将数据从一个集群复制到另外一个，将查询请求都路由到从索引，查询操作将不会占用主索引节点的资源了。
11.避免热点问题 当节点资源、分片、请求不均衡时可能会出现热点问题。Elasticsearch通过跨节点来同步集群状态，热点问题将引发集群能力的退化。
12.其他优化策略 在磁盘的使用方面也有很多可以提升写入速度的策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3baac5ce61165760f32e624932b9fa5e/" rel="bookmark">
			实验四图像处理代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I=imread('D:\ALLDOWNLOAD\彩色图像处理-实验\你的图.tif');
mask=roipoly(f);
R=immultiply(mask,f(:,:,1));
G=immultiply(mask,f(:,:,2));
B=immultiply(mask,f(:,:,3));
g=cat(3,R,G,B);
subplot(3,3,1);imshow(g);title('原图像');%找出平均矢量m和协方差矩阵C
[M,N,K]=size(g);
%重新排列g中的彩色元素
I=reshape(g,M*N,3);
%找出彩色像素的行索引
idx=find(mask);
I=double(I(idx,1:3));
%计算平均矢量m和协方差矩阵C
[C,m]=covmatrix(I);
%计算C的对角线元素并计算它们的平方根
%sd中的第一二三个元素是ROI区域中的红绿蓝分量的标准差
d=diag(C);
sd=sqrt(d);%用欧几里得距离来计算
%以T的25倍作为阈值，这个值是最大标准差的近似
E25=colorseg('euclidean',f,25,m);
subplot(3,3,2),imshow(E25);
%以T的50倍作为阈值
E50=colorseg('euclidean',f,50,m);
subplot(3,3,3),imshow(E50);%以T的75倍作为阈值
E75=colorseg('euclidean',f,75,m);
subplot(3,3,4),imshow(E75);%以T的100倍作为阈值
E100=colorseg('euclidean',f,100,m);
subplot(3,3,5),imshow(E100);
f=imread('D:\ALLDOWNLOAD\彩色图像处理-实验\你的图.tif');
size(f);
mask=roipoly(f);
R=immultiply(mask,f(:,:,1));
G=immultiply(mask,f(:,:,2));
B=immultiply(mask,f(:,:,3));
g=cat(3,R,G,B);
figure,imshow(g);
[M,N,K]=size(g);
I=reshape(g,M*N,3);
idx=find(mask);
I=double(I(idx,1:3));
[C,m]=covmatrix(I);
d=diag(C);
sd=sqrt(d);
E25=colorseg('euclidean',f,25,m);
subplot(2,2,1),imshow(E25);
E50=colorseg('euclidean',f,50,m);
subplot(2,2,2),imshow(E50);
E75=colorseg('euclidean',f,75,m);
subplot(2,2,3),imshow(E75);
E100=colorseg('euclidean',f,100,m);
subplot(2,2,5),imshow(E100);
这段代码实现了基于欧几里得距离的彩色图像分割。首先读取一个彩色图像，选择一个感兴趣区域（ROI），然后通过roipoly函数获取该感兴趣区域的掩膜。接着，将掩膜应用于原始图像的每个通道，得到分离后的颜色通道。将分离的颜色通道合并成一个三通道的图像，并将其展开成一个二维的矩阵。然后，计算感兴趣区域内的像素点的协方差矩阵和均值向量。通过协方差矩阵的特征值和特征向量，可以得到每个通道的标准差。最后，使用colorseg函数将图像分割成不同的区域，分别设置25、50、75和100的距离阈值，并将每个分割结果可视化。
I=imread('D:\ALLDOWNLOAD\实验四、彩色图像处理\彩色图像处理\lena_color.bmp');
subplot(231),imshow(I);title('原图像');
I_R=I(:,:,1);
BW1_R=edge(I_R,'sobel');
I_G=I(:,:,2);
BW1_G=edge(I_G,'sobel');
I_B=I(:,:,3);
BW1_B=edge(I_B,'sobel');
out(:,:,1)=BW1_R;
out(:,:,2)=BW1_G;
out(:,:,3)=BW1_B;
subplot(232);imshow(double(out),[]);title('out3arrays');
out2=cat(3,BW1_R,BW1_G,BW1_B);
subplot(233);imshow(double(out2),[]);title('cat3arrays');
[VG,A,PPG]=colorgrad(I);subplot(234);imshow(VG);title('VG');
subplot(235);imshow(A);title('A');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3baac5ce61165760f32e624932b9fa5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f3936ede895a14bf0d14133a98b631/" rel="bookmark">
			实验四、彩色图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的 使用MatLab软件对图像进行彩色处理，熟悉使用MatLab软件进行图像彩色处理的有关方法，并体会到图像彩色处理技术以及对图像处理的效果。
作业1：生成一副256*256的RGB图像，使得该图像左上角为黄色或者青色，左下角为蓝色，右上角为绿色，右下角为黑色。 rgb_R=zeros(256, 256); %红色分量
rgb_R(1:128,1:128)=1;
rgb_G=zeros(256, 256); %绿色分量
rgb_G(1:128,1:256)=1;
rgb_B=zeros(256, 256); %蓝色分量
rgb_B(128:256,1:128)=1;
rgb=cat(3,rgb_R,rgb_G,rgb_B); %生成一副RGB彩色图像的基本语法
imshow(rgb);title('RGB 彩色图像')
作业2：利用作业1生成的RGB图像展示其R、G、B三个分量与RGB图；将其转化为HSI彩色模型，然后展示H、S、I三个分量及HSI图。 I=RGB;
r=I(:,:,1);
g=I(:,:,2);
b=I(:,:,3);
figure;
subplot(2,2,1);imshow(I);title('RGB彩色图像');
subplot(2,2,2);imshow(r);title('R分量');
subplot(2,2,3);imshow(g);title('G分量');
subplot(2,2,4);imshow(b);title('B分量');
hsi = rgb2hsv(I);
h=hsi(:,:,1);
s=hsi(:,:,2);
i=hsi(:,:,3);
figure;
subplot(2,3,1);imshow(I);title('original image');
subplot(2,3,2);imshow(hsi);title('HSI彩色图形');
subplot(2,3,4);imshow(h);title('色调H');
subplot(2,3,5);imshow(s);title('饱和度S');
subplot(2,3,6);imshow(i);title('亮度I');
rgb_hsi=hsv2rgb(hsi);
subplot(2,3,3);imshow(rgb_hsi);title('RGB彩色图形');
作业3：将作业1中的图像进行上下镜像。 image=imread('D:\ALLDOWNLOAD\实验四、彩色图像处理\彩色图像处理\shiyan4.1.png');
res = im2uint8(zeros(size(image)));%生成image图像大小的0值unit8图片
[rows,cols,n] = size(image); % 图像行列数
res1 = im2uint8(zeros([rows,cols]));
res2 = im2uint8(zeros([rows,cols]));
res3 = im2uint8(zeros([rows,cols]));
temp1 = image(:, :, 1);
temp2 = image(:, :, 2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f3936ede895a14bf0d14133a98b631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3ab421dc629b1f1993ec12a6ba60ea1/" rel="bookmark">
			vue&#43;element 多选级联选择器自定义props
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我这里分享的是Cascader 级联选择器中的多选、以及如何自定义props的使用详解
1.使用Cascader 级联选择器 效果
代码
&lt;div class="block"&gt; &lt;span class="demonstration"&gt;默认显示所有Tag&lt;/span&gt; &lt;el-cascader :options="options" :props="props" clearable&gt;&lt;/el-cascader&gt; &lt;/div&gt; &lt;div class="block"&gt; &lt;span class="demonstration"&gt;折叠展示Tag&lt;/span&gt; &lt;el-cascader :options="options" :props="props" collapse-tags clearable&gt;&lt;/el-cascader&gt; &lt;/div&gt; &lt;script&gt; export default { data() { return { props: { multiple: true }, options: [{ value: 1, label: '东南', children: [{ value: 2, label: '上海', children: [ { value: 3, label: '普陀' }, { value: 4, label: '黄埔' }, { value: 5, label: '徐汇' } ] }, { value: 7, label: '江苏', children: [ { value: 8, label: '南京' }, { value: 9, label: '苏州' }, { value: 10, label: '无锡' } ] }, { value: 12, label: '浙江', children: [ { value: 13, label: '杭州' }, { value: 14, label: '宁波' }, { value: 15, label: '嘉兴' } ] }] }, { value: 17, label: '西北', children: [{ value: 18, label: '陕西', children: [ { value: 19, label: '西安' }, { value: 20, label: '延安' } ] }, { value: 21, label: '新疆维吾尔族自治区', children: [ { value: 22, label: '乌鲁木齐' }, { value: 23, label: '克拉玛依' } ] }] }] }; } }; &lt;/script&gt; 这里在优化一下，将option放置外部引入，如果是通过后端传入的数据这里也可以直接赋值给option
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3ab421dc629b1f1993ec12a6ba60ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0efaf5f2774f6787a8ad7aad72c66b9/" rel="bookmark">
			【深度学习入门系列】 pytorch实现多层感知机（MLP）（内含分类、回归任务实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. BP和MLP1 分类1.0 数据集1.1 网络架构1.2 代码1.3 结果 2 回归2.0 数据集2.1 网络架构2.2 代码2.3 结果 3 代码（可直接食用） 众所周知，sklearn提供了MLP函数。个人认为这个东西虽然蛮好用的——有的时候比你自己写的效果都好，但是，不是长久之计。通过Pytorch能建立自定义程度更高的人工神经网络，往后在网络里面加乱七八糟的东西都很方便（比如GA/PSO求解超参之类的、比如微调模型架构之类的）。本文将不再对MLP的理论基础进行赘述，直接介绍MLP的具体搭建方法。
0. BP和MLP 在做这个之前，我突然想到一个问题
我现在出了一篇 MLP 的文章，要不要再出一个 BP 的？
沉默……
这俩有什么区别啊？？？
跟某知名大博主讨论了一下，感觉大概是这样的：
我们先明确3个概念：
BP：BP的全称是back propagation（反向传播算法），这并不是一个神经网络。BP神经网络：用了BP算法的神经网络。MLP：多层感知机，也就是我们说的神经网络。 那么我们不难发现，所谓的BP神经网络其实应该是（BP-MLP ）
&lt;=&gt; BP神经网络 = BP算法 + MLP（多层感知机）
也就是说，BP 和 MLP 本身是平行的两个概念，不是一件事；它们是 BP 神经网络这个事物的两个不同的方面。
猜测
最开始的时候，神经网络方面的知识还不够丰富，这个时候人们把刚开始的那个简单的结构称作MLP。
随着时间的流逝，人们发现了反向传播算法（BP），这个时候开始强调训练方法了，所以将其相关的神经网络称为BP神经网络。
再往后，因为人们都用BP了，BP不那么新那么火了，这个时候又开始强调模型结构了，就出现了乱七八糟的其他神经网络。
1 分类 1.0 数据集 数据集我采用的是之前接手的一个保险理赔项目。
目标是判断用户是不是来骗保的，给了一大堆特征，这里我就不详细解释是哪些特征了，这篇文章主要负责搭建模型。
归一化之后发现数据还是非常稀疏的，而且看着可能二值化效果会不错，嫌麻烦，不尝试了，就直接拿这个用也没什么大问题。
是一个4分类任务，结果可能没2分类好看，这跟项目的数据也有关，本身数据也比较脏、噪声也比较多，感觉特征与 label 之间的联系也不是特别紧密。不过问题不大，我们的重心还是放在搭网络上。
数据集缺点还包括样本不平衡，确实会影响结果。
data.csv （36221x24）=&gt; 已经包括 label 了
1.1 网络架构 torch 输出的架构如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0efaf5f2774f6787a8ad7aad72c66b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7147aa4fe984ee1fad5147ffd16dd059/" rel="bookmark">
			linux部署tomcat项目详细教程（安装linux到部署tomcat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近来想要研究下linux，所以就搭了个linux系统来配置服务器玩玩。这里分了个目录，如果已经安装好虚拟机或者linux系统的小伙伴可以直接跳过前面的安装介绍，直接看部署。
文章目录 一、总步骤说明二、安装虚拟机三、创建linux系统四、配置前的准备五、配置jdk六、配置tomcat七、部署项目 一、总步骤说明 下载需要的材料（除了linux镜像文件，其他可在我博客免费下载），这里我用到的主要有
1）虚拟机Vmware，
2）linux镜像文件CentOS-6.5-x86_64-bin-DVD1.iso
3）服务器apache-tomcat-7.0.105.tar.gz
4）jdk7u79linuxx64.tar.gz
5）securecrt-x64.rar
6）WinSCP.zip安装虚拟机创建linux系统配置jdk配置tomcat部署项目 二、安装虚拟机 然后输入解压后提供的密钥即可!
三、创建linux系统 打开虚拟机，然后开始创建新的虚拟机
然后等创建结束
四、配置前的准备 准备好进行操作linux的工具，我这里是使用SecureCRT 和winScp，SecureCRT进行代码操作，winScp进行文件可视化的移动操作。由于可能会涉及到一些权限问题，所以这里直接用root用户登录，包括SecureCRT和winScp也是直接用root用户登录，密码是刚刚自定义的密码。获取linux系统的ip，然后在本地试试能否ping通
右键，点击这个选项
然后输入ifconfig
然后再本地ping看看是否能ping通
能ping通，说明没有问题，。
注：当然你也可以修改固定的ip地址，只需要修改etc/sysconfig/network-scripts/ifcfg-etho文件即可，这是我个人的简单配置 DEVICE="eth0" BOOTPROTO="none" HWADDR="00:0C:29:68:52:69" IPV6INIT="yes" NM_CONTROLLED="yes" ONBOOT="yes" TYPE="Ethernet" UUID="a844414a-af21-44b4-bedd-ac6fb18a7dc4" IPADDR="192.168.121.128" NETMASK="255.255.255.0" GATEWAY="192.168.121.1" 五、配置jdk 这里使用的是jdk7u79linuxx64.tar.gz。
总步骤==&gt;添加安装包，解压，配置环境变量，测试
用winScp连接上linux，在usr目录下创建java文件夹，然后将安装包copy放在java文件夹底下
将安装包直接通过winScp复制到java文件底下（ctrl+c，ctrl+v）
用winScp连接上linux，切换到ava目录底下，通过tar xvf命令解压jdk安装包（如果不确定自己在哪个目录。可以通过ls命令查看当前目录下的文件并且与winScp的文件目录对比即可）
解压结束！！！配置jdk环境变量
直接通过winScp打开etc/profile文件
然后配置跟window差不多的环境变量，在文件底部加上这四行
然后点击保存（注意，这里需要用到root用户登录，一开始我用自定义用户登录提示我无法修改，权限不足）测试
首先通过source /etc/profile刷新profile文件，
再通过java -version查看jdk版本
如果成功显示jdk版本，则说明配置成功 六、配置tomcat tomcat的安装配置和jdk的基本一样
总步骤==&gt;添加安装包，解压，配置环境变量，测试
在usr目录下创建tomcat文件夹，然后将安装包copy放在tomcat文件夹底下
解压tomcat
配置环境变量
同样打开etc/profile文件，添加配置
测试
首先通过source /etc/profile刷新profile文件，
然后直接启动tomcat，通过本地访问。
进入tomcat的bin目录，通过startup.sh启动tomcat
然后在本地直接根据ip和端口访问
发现访问不到，后来想想可能是防火墙的原因。通过
service iptables status查看发现防火墙果然是开着的，所以这里通过service iptables stop临时将防火墙关闭（或者也可以通过chkconfig iptables off 用就关闭，不过设置完需要重启）.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7147aa4fe984ee1fad5147ffd16dd059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7083d56774419093c3f4edbae583e70a/" rel="bookmark">
			vite设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发服务器选项 | Vite 官方中文文档 // vite.config.js export default defineConfig({ server: { proxy: { // 字符串简写写法：http://localhost:5173/foo -&gt; http://localhost:4567/foo '/foo': 'http://localhost:4567', // 带选项写法：http://localhost:5173/api/bar -&gt; http://jsonplaceholder.typicode.com/bar '/api': { target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\/api/, ''), }, // 正则表达式写法：http://localhost:5173/fallback/ -&gt; http://jsonplaceholder.typicode.com/ '^/fallback/.*': { target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\/fallback/, ''), }, // 使用 proxy 实例 '/api': { target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, configure: (proxy, options) =&gt; { // proxy 是 'http-proxy' 的实例 } }, // 代理 websockets 或 socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7083d56774419093c3f4edbae583e70a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c08ba711b263622cd1da226e0787763/" rel="bookmark">
			都2023了，Android Compose还值得学吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Android Compose作为去年出来的新技术，本来我也没有想着再写一篇关于这方面的文章，但是有不少人问了这个问题。就把这个问题再提出来聊一次。
Jetpack Compose 简述 Jetpack Compose是用于构建原生Android UI的现代工具包。 Jetpack Compose使用更少的代码，强大的工具和直观的Kotlin API，简化并加速了Android上的UI开发。这是Android Developers 官网对它的描述。
由于Compose基于Kotlin构建，因此可以与Java编程语言完全互操作，并且可以直接访问所有Android和Jetpack API。因此你可以简单地描述UI的外观，而Compose则负责其余的工作-当状态发生改变时，你的UI将自动更新。
它与现有的UI工具包也是完全兼容的，因此你可以混合原来的View和现在新的View，并且从一开始就使用Material和动画进行设计。
据谷歌官方介绍Jetpack Compose 有以下特点
更少的代码：使用更少的代码实现更多的功能，并且可以避免各种错误，从而使代码简洁且易于维护。
直观的 Kotlin API：只需描述界面，Compose 会负责处理剩余的工作。应用状态变化时，界面会自动更新。
加快应用开发：兼容现有的所有代码，方便随时随地采用。借助实时预览和全面的 Android Studio 支持，实现快速迭代
。
功能强大：凭借对 Android 平台 API 的直接访问和对于 Material Design、深色主题、动画等的内置支持，创建精美的应用。
Compose的渲染性能到底怎么样？ Compose列表渲染性能分析
关于Compose的列表的性能问题也是老生常谈了，很多人都说Compose的LazyColumn在低端手机上会卡顿，那么我们就来分析比较一下同一个页面用LazyColumn与RecyclerView分别实现，在性能上有什么差距？
首先来看下页面的样式。
如上，这个页面整体是一个列表，共有4种类型。
可左右滑动的Banner
包含文字与一张图片的item
包含3张图片的复杂item
作为视频封面的大图item
然后我们用LazyColumn与RecyclerView分别实现以上页面，然后在不同手机上分别测量其快速滑动时的FPS，结果如下：
同时在debug包与release包都进行了以上测试，结果基本一致。可以看出，LazyColumn与RecyclerView在性能上的确有一定差距，尤其在低端手机上，LazyColumn快速滑动时掉帧明显，而RecyclerView则都很流畅。
只能说RecyclerView太强了~
/ Compose粒子动画渲染性能分析 /
除了列表，我们也可以通过粒子动画的方式来测量Compose的性能，通过粒子动画我们可以评估在极端情况下Compose与View的渲染性能。首先来看下粒子动画效果：
如上，我们可以在画布上生成随机粒子并且做动画，随着粒子数量的增长，观察应用的FPS，以此评估Compose的渲染性能，我们同时也实现了一个View版本以进行对比，结果如下：
可以看出，随着粒子数从100增长到10000，应用的FPS逐渐降低，在低端手机上尤其明显。而与列表不同的是，Compose与View在粒子动画中的渲染性能几乎一致，可以说是几乎没有区别。
总结
本文主要从FPS的角度分析介绍了Compose的渲染性能，可以看出在画布中随机生成粒子动画时，Compose与View的渲染性能几乎一致。而对于复杂列表，LazyColumn与RecyclerView在性能上有一定差距，在低端手机上尤其明显，在快速滑动时会有明显卡顿。
结合两个实验，看起来应该是LazyColumn组件存在一定性能问题，而Compose本身的渲染性能已经基本与View一致了~
Jetpack Compose VS 传统UI Jetpack compose 提供了现代化的声明式 Kotlin API，取代 Android 传统的命令式开发 xml 布局，可帮助开发者用更少的代码构建美观、响应迅速的应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c08ba711b263622cd1da226e0787763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb7c75240ddaefd621b5608c1c623f2/" rel="bookmark">
			VSCode 技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用快捷键 1、代码格式化：Shift+Alt+F
2、 移动某一行：Alt+ ↑ / ↓ 3、复制某一行：Shift+Alt + ↓ / ↑
4、快速保存：Ctrl+s
5、快速查找：Ctrl+F
6、快速替换：Ctrl+H
7、ctrl+上下箭头上下滚动页面
8、Ctrl+Shift+K 删除某一行
9、ctrl + Enter 跳转下一行开头
10、shift + ctrl + enter 跳转上一行开头
11、Ctrl+Shift+ 跳转到相应的匹配括号
12、Alt+Shift+A 多行注释
13、Ctrl+Shift+F 全局搜索
VsCode编辑器设置 一、关闭鼠标hover时的悬浮窗：
1.点击编辑器左下角的齿轮设置，第二个“设置”选项，弹出用户设置界面，如图：
在顶栏的输入框内输入：editor.hover，如图：
然后找到图中的“控制是否显示悬停提示”复选框，把勾去掉即可。
二、关闭输入提示悬浮窗
1.还是在这个用户设置页面
2.在顶栏的输入框内输入“输入”两字，如图：
找到“在输入时显示含有参数文档和类型信息的小面板”选项，去掉前边的勾即可。
两种提示框都关闭后，不需要重启编辑器就可以应用设置。设置完成后，方便太多了，再也不会遮挡视线了。
VSCode开发者快捷工具 生成浏览器文件.html快捷方式
html:5 + tab 更简单的生成，可以配置vsCode
文件——首选项——设置E···——勾选T···和U··
！ + Tab 后面在补充！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2f47e808f8aa87ba96eca0e3bae0f0/" rel="bookmark">
			使用Python批量拼接图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 当需要将多张图像拼接成一张更大的图像时，通常会用到图片拼接技术。这种技术在许多领域中都有广泛的应用，例如计算机视觉、图像处理、卫星图像、地理信息系统等等。在实际应用中，拼接图像可以用于创建全景图像、地图、海报、广告牌等等。
本文将使用以下四张图片为例，介绍使用Python中的PIL库进行图片拼接的方法。我们将使用PIL库中的Image模块来加载、调整大小和合并多张图像。
目录
前言
〇、准备工作，PIL库安装
一、简单程序实现
二、更复杂情况
〇、准备工作，PIL库安装 PIL（Python Imaging Library）是Python中一个强大的图像处理库，它可以实现图像的打开、保存、调整大小、裁剪、合并等多种操作。PIL库还提供了丰富的图像处理功能，例如色彩调整、滤镜效果、文字叠加等等，使得图像处理变得更加简单和高效。
安装PIL库的方法如下：
使用pip安装 在命令行中输入以下命令即可：
pip install pillow 此外，还可以通过Anaconda或Miniconda等科学计算发行版进行安装。如果你使用Anaconda，可以使用以下命令来安装Pillow库：
conda install pillow 一、简单程序实现 import os import glob from PIL import Image # 设置图像文件夹的路径 image_dir = 'images/' # 获取文件夹中所有图像文件的列表 image_files = glob.glob(os.path.join(image_dir, '*.png')) # 加载每个图像，并调整为200x200像素大小（如果需要） images = [] for image_file in image_files: image = Image.open(image_file) image = image.resize((200, 200)) images.append(image) # 创建一个新的400x400像素大小的白色背景图像 new_image = Image.new('RGB', (400, 400), 'white') # 将四个图像粘贴到新图像的正确位置 new_image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2f47e808f8aa87ba96eca0e3bae0f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8ec030edbc7857e330b96da3deb5b7/" rel="bookmark">
			windows10 安装 Docker 集成到 WSL 2虚拟机以及Doceker下面安装Hyperf 系统 下面Go安装配置 下载Gin框架(保证安装成功 保证都会)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看windows系统的版本号 windows 系统到 win10 v2004 的内部版本 19041 或更高版本， 可以使用win10自带的WSL1或WSL2. 1和2的区别：
打开powershell 管理员身份运行 输入 winver，版本如果达不到。如果不是，到微软官网更新系统。win10更新
2 此电脑 --点击属性--控制面板\程序\程序和功能 勾选之后 保存
然后重启电脑
3 确保在BIOS中启用虚拟化。可根据电脑厂家型号查找进入bios方法(开机时狂按某键)，以及如何设置。 ctrl+alt+del 查看是否虚拟机化
4 开始执行如下命令
//启用“适用于 Linux 的 Windows 子系统”可选功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart //启用虚拟机平台可选功能 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart //设置WSL2为默认版本 wsl --set-default-version 2 //设置默认的WSL系统Linux版本 然后重启电脑
开机后执行 然后提示 我们开始安装wsl（windows system Linux）子系统的内核 ，输入 wsl --set-default-version 2，如果出现错误代码，则到WSL官网下载linux内核并安装，然后重复一次此步骤。（wsl --help为检测WSL是否安装成功的指令） WSL csdn - 安全中心
Error: 0x800701bc WSL 2 ?????????????????? https://aka.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8ec030edbc7857e330b96da3deb5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c0b02bfaca9fa6b1419053bd72b644/" rel="bookmark">
			DockerFile文件详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DockerFile文件详细解析 所有文章不设限，我们相遇偶然，相散坦然，互不打扰，各自安好，向阳而生
致敬尚硅谷周阳老师，此处内容迁移学习来自于阳哥！
DockerFile是什么 DockerFile是用来构建Docker镜像的文本文件，是一条条构建镜像所需要的指令和参数构成的脚本
构建三步骤 编写DockerFile文件Docker build命令构建镜像docker run 依据镜像运行容器实例 DockerFile构建过程解析 DockerFile内容基础知识 每条保留字指令都必须为大写字母且后面要跟随至少一个参数指令按照从上向下，顺序执行#表示注释每个指令都会创建一个新的镜像层并且对于镜像进行提交 Docker执行DockerFile的大致流程 Docker从基础镜像运行一个容器执行一条指令并且对于容器做出修改执行类似docker commit的操作提交一个新的镜像层Docker再基于刚提交的镜像运行一个新的容器执行DockeFile 中的下一条指令直到所有指令都执行完成 小总结 从应用软件的角度而言，DockerFile，Docker镜像和Docker容器分别代表了软件的三个不同阶段
DockerFile是软件的原材料Docker镜像是软件的交付品Docker容器则可以认为是软件镜像的运行状态，也是依照镜像运行的容器实例 DockerFile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署和运维，三者缺一不可，合理充当Docker体系的基石！
Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时会真正开始提供服务;Docker容器，容器是直接提供服务的。 DockerFile常用保留字指令 FROM指令 基础镜像，当前镜像是基于那个镜像的，指定一个已经存在的镜像作为模版，第一条必须是from
MAINTAINER 指令 镜像维护者的姓名和邮箱地址
RUN 指令 第一种 shell格式
RUN yum -y install vim
第二种
exec格式 RUN[“可执行文件”,“参数1”,“参数2”]
RUN实在docker bilid时进行运行
EXPOSE 指令 当前容器对外暴露出的端口
WORKDIR 指令 指定在创建容器后，终端默认进入后的目录
USER 指令 指定该镜像以什么样的用户去执行，如果不指定，默认是root
ENV 指令 用来构建镜像的过程中设置环境变量
ADD 指令 将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包
COPY 指令 类似ADD，拷贝文件和目录到镜像中
将从构建上下文目录中的&lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置
第一种写法
COPY src dest
第二种写法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c0b02bfaca9fa6b1419053bd72b644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f42c9735971f2ce6e3d908bca73ea0/" rel="bookmark">
			C语言简单的爱心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天看到网上有很多人在找爱心代码，小编立刻就坐不了，就用C语言简单的写了一个，希望对大家能有帮助。
#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;
int main()
{
for(int i=0;i&lt;2;i++)
{
float x,y,a;
for(y=1.5; y&gt;-1.5; y-=0.1)
{
for(x=-1.5; x&lt;1.5; x+=0.05)
{
a=x*x+y*y-1;
putchar(a*a*a-x*x*y*y*y&lt;=0.0?'*':' ');
}
system("color 0c");
putchar('\n');
}
}
return 0;
}
好了，以上就是今天的文章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/118dfd0063ac06275f27e2e6833b3e5c/" rel="bookmark">
			硬件设计规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 文档... 2
1.1 变更历史... 2
1.2 术语和缩写... 2
1.3 引用文档... 2
2 目的... 3
3 硬件架构... 3
3.1 模块图... 3
3.2 HW组件说明... 3
3.3 HW接口... 4
3.3.1 外部接口... 4
3.3.2 内部接口... 4
3.3.3 独立性措施... 4
3.3.4 HW 组件s的交互... 4
3.4 非功能失效的处理... 5
4 硬件详细设计... 5
4.1 HW组件A.. 5
4.1.1 详细说明... 5
4.1.2 详细说明... 5
4.1.3 设计约束... 5
4.2 HW组件B.. 5
4.2.1 详细说明... 5
4.2.2 详细说明... 5
4.2.3 设计约束.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/118dfd0063ac06275f27e2e6833b3e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ef9bb8479cf083198a3de8a30995bf/" rel="bookmark">
			南京邮电大学面向对象程序设计及C&#43;&#43;实验2：继承与派生实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的和要求
（1）掌握单继承和多重继承下派生类的定义方法，理解基类成员在不同的继承方式下不同的访问属性。
（2）正确定义派生类的构造函数与析构函数，理解定义一个派生类对象时各个构造函数、析构函数被调用的顺序。
（3）正确定义虚基类，消除在多层次多重继承方式下顶层基类中成员访问的二义性问题，关注此时各构造函数、析构函数的调用顺序。
（4）通过基类与公有派生类的定义，及基类对象、指针、引用与派生类的对象、地址间相互赋值的方法，正确理解赋值兼容的4种情况，通过程序理解其不可逆性。
二、实验环境(实验设备)
硬件: 微型计算机
软件: Windows 操作系统、Microsoft Visual Studio 2010
三、实验原理及内容
实验题目1: 定义一个车基类，派生出自行车类和汽车类，又以自行车类和汽车类为基类共同派生出摩托车类，每个类都要定义带有参数的构造函数。对自行车类继承车基类的方式分别用private、protected、public，观察基类成员在派生类中的访问属性；观察自行车类、汽车类和摩托车类对象定义时构造、析构函数的调用顺序。最后将车基类定义为虚基类再观察程序运行结果。
实验解答：
①根据提示进行填写完整实验指导204页代码对应位置内容如下：
( 1 ) MaxSpeed = m; ( 2 ) Weight = w; ( 3 ) Vehicle(m,w) ( 4 ) Height = h; ( 5 ) Vehicle::Show() ; ( 6 ) cout&lt;&lt;”It’s height is:”&lt;&lt;Height&lt;&lt;endl; ( 7 ) Bicycle b(100,100,100); 此时程序的运行结果是：
Constructing Vehicle...
Constructing Bicycle...
The vehicle is running!
Please stop running!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00ef9bb8479cf083198a3de8a30995bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ca124a1890a46abd26ad3d8f951a59/" rel="bookmark">
			数据拟合的相关函数（图像及应用实例 ）- 基于python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据拟合的相关函数（图像及应用实例 ）- 基于python 本文提到的、的数学拟合需要基于numpy这个库，而为了将拟合更加直观的展示出来，用于绘图的matplotlib也是必要的，如果有想要跟着本文这些不值一提的思路去尝试实现的读者，需要预先安装这两个库。
本教程较为基础，因为笔者也是初学，只是做整理工作而已，因此在正式介绍拟合函数相关的内容之前有一些前置的会用到的函数说明，读者亦可跳过，直接前往拟合函数，有不熟悉的再往前翻阅亦可。
其他函数 numpy.linspace(start, end, number) &amp; numpy.arange(start, end, step) numpy.linspace这个函数可以生成相等间隔的数组（等差数列），几个参数分别是首项，尾项和项数，还有一些其他参数包括是否包括尾项、是否返回步长等等，可自行了解。
numpy.arange这个函数和numpy.linspace非常相像，前两个参数都是首项和尾项，只不过对于numpy.linspace来说，第三个参数是项数，而numpy.arrange的第三个系数是公差。另外numpy.linspace是默认包括尾项的，numpy.arange是默认不包括尾项的。
import numpy as np print(np.linspace(1,5,5)) # [1,2,3,4,5] print(np.arange(1,5,1)) # [1,2,3,4] 绘图函数 matplotlib.pyplot.scatter (x,y,c=None,marker =None) 作为一个绘图函数，matplotlib.pyplot.plot ()可以绘制散点图，这个函数有非常多的样式方面的自定义项，包括颜色、透明度、色彩映射等等，我们只选取颜色和散点形状讲解（大部分时候用于绘图时候的区分是足够了）
x和y是横纵坐标c是颜色，颜色可以用很多方式去声明，我们不需要颜色特别的精确，直接用特征字符串（‘red’ , ‘green’ 等）去声明就足够了marker是点的形状，常用的有（’o’ , ‘x’ , ‘+’ ,‘*’）他们的形状就像他们看到的那样 举例：简单散点图 import numpy as np import matplotlib.pyplot as plt x = [1, 2, 3, 4, 5] y = [2, 2, 2, 2, 2] plt.scatter(x, y, c='red', marker='x') y = [1, 1, 1, 1, 1] plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ca124a1890a46abd26ad3d8f951a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb7fe121fa57493ca9f5e4b4cc9a3b9/" rel="bookmark">
			2023年第二十届五一数学建模A题：无人机定点投放问题思路及参考matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
⛄ 内容介绍 随着科学技术的不断发展，无人机在许多领域都有着广泛的应用。对于空中执行定点投放任务的无人机，其投放精度不仅依赖于无人机的操作技术，而且还与无人机执行任务时所处状态和环境有关，例如在接近投放点时无人机的高度、速度，无人机所处位置的风速、投放点周围地理环境等因素。在本题中仅考虑喷气式无人机，请查阅相关资料，研究以下问题：
问题1：假设无人机以平行于水平面的方式飞行，在空中投放物资(物资为球形，半径20cm，重量50kg)到达地面指定位置。
(1)建立数学模型，给出无人机投放距离(投放物资时无人机与地面物资指定落地点之间的直线距离)与无人机飞行高度、飞行速度、空气阻力等之间的关系。
(2)假设无人机的飞行高度为300m，飞行速度为300km/h，风速为5m/s，风向与水平面平行。建立数学模型，分别给出无人机飞行方向与风向相同(夹角为0度)、相反(夹角为180度)、垂直(夹角为90度)情况下无人机的投放距离。
问题2：无人机不仅能定点投放物资，而且还可以通过安装在无人机前端的发射筒发射爆炸物疏通河道。其大致过程是：无人机首先水平飞行接近障碍物所处区域，然后俯冲找准时机发射爆炸物，发射结束后无人机随即拉升飞走。现有一处河流被冰块堆积阻断，需要用无人机发射爆炸物(爆炸物为球形，半径8cm，重量5kg)对目标进行爆破。假设无人机的初始点到目标的水平距离为10000m。受环境影响，无人机必须俯冲发射，并且发射方向与无人机的飞行方向一致。
(1)建立数学模型，给出无人机发射距离(发射点与目标的直线距离)与无人机的飞行高度、飞行速度、俯冲角度及发射速度等因素之间的关系。
(2)假设风速为6m/s，无人机接近目标时的飞行高度为800m、飞行速度为300km/h，爆炸物的发射速度为600km/h(相对于无人机的速度)。要求发射爆炸物时无人机与目标的距离在1000 m-3000 m之间，且无人机的高度不低于300m，请给出无人机击中目标的发射策略。
问题3：无人机发射爆炸物命中目标的精度与无人机飞行的稳定性有很大关系。相同条件下，无人机发射爆炸物时越稳定，命中目标的精度越高。开始俯冲后，无人机操控员需要不断调整无人机的飞行姿态以修正风向、风速对无人机的影响。
(1)在飞行速度、发射速度一定的情况下，综合考虑各种因素，建立数学模型，量化无人机飞行的稳定性，给出稳定性与命中精度之间的关系，并利用数值仿真等方法对无人机的稳定性进行分析验证。
(2)假设风速为6m/s，无人机的飞行速度范围为300 km/h -400 km/h，爆炸物的发射速度为500km/h(相对于无人机的速度)。无人机在800m高度开始俯冲，初始俯冲角度为45°，发射爆炸物时的飞行高度不低于300m，请给出为尽量保持无人机稳定而采取的飞行姿态最优调整策略。
代码资料关注
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/374cf84994a4b93bbe0b4ccdf7a931bf/" rel="bookmark">
			【模电知识总结】MOS管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、MOS管是什么？二、结构与工作原理三、输出特性1、VDS不变，VGS改变2、VGS固定，VDS改变 四、答疑1、进入饱和区，若想加大电流该怎么做？2、MOS管的特性3、为什么叫MOS管？4、增强型N沟道MOS管符号解释5、既然MOS管是一个对称结构，SD极是否可以互换？6、源漏栅名字的由来7、MOS管为什么称为电压型器件？8、寄生二极管哪儿来的？9、增强型名字的由来10、为什么要把衬底接地？ 五、NMOS与PMOS参考资料 一、MOS管是什么？ MOS管全称叫金属氧化物半导体场效应晶体管，是一种压控器件。
MOS管属于场效应晶体管。
其中增强型NMOS与PMOS是应用最多的种类，也是本文要介绍的内容。
二、结构与工作原理 在一个P型基底上生成两块N型半导体，再加上两个金属电极形成源极和漏极。
给源极和漏极加上电，不能导通，因为两者之间相当于两个背靠背的二极管。此时MOS管始终截止。
怎样让源极和漏极可以导通？
在P型半导体上加一个很薄的二氧化硅绝缘层（下图中红色薄片），又在绝缘层上制作了金属极板（下图中黑色薄片），形成栅极。
注意：栅极极板以前一般为铝，现在一般使用多晶硅
在栅极上也加上正向电压，栅极与P型半导体形成一个电容，并形成一个电场，电场方向从栅极指向P型半导体，在电场的作用下，P型半导体一侧空穴受到排斥，电子得到吸引，该区域自由电子数量开始增加，但MOS管仍不导通。
栅极电压继续增大，自由电子进一步增加，当栅极电压达到一个阈值电压VTH后，此时P型半导体转变为N型半导体（反型层），连通漏极和源极，即形成了N沟道（即供电子通过的沟道）。此时MOS管导通。
注：该结构中导电沟道是N型的，所以是N沟道。
三、输出特性 1、VDS不变，VGS改变 VGS主要影响导电沟道的宽度。
当VGS &lt; VTH时，导电沟道未形成，MOS管处于截止区，这种情况称为MOS管被夹断；
当VGS = VTH时，导电沟道开始形成；
当VGS &gt; VTH时，随着VGS的增大，沟道宽度也加大，阻力也变小，能通过的电流也变大。这也就是为什么驱动大功率设备，VGS不能太小的原因，太小内阻太大，导致MOS管发热严重。
这也就是说，MOS管的内阻可以通过VGS来调节。
2、VGS固定，VDS改变 前提:VGS大到可以形成沟道。
VDS将引起漏极电流的变化。
当VDS较小时，随着电压增大，电流iD线性增大，此时MOS管满足欧姆定律。与这一过程同时发生的是随着VDS的增加，沟道两端的电势差开始不等。
VGD &gt; VTH阶段：在VDS=0V时，沟道两端的电势相等（VGS = VGD），两端沟道宽度相等。当VDS增加时，VGS 保持不变，VGD=VGS - VDS逐渐减小，这导致沟道变窄（栅极与衬底电势差越小，沟道越窄），这限制了电子的流动，虽然被限制，但电流大小一直在增加，只是增加速率减小了。
VGD = VTH阶段：VDS继续增加，沟道越来越窄，直到进入临界状态，沟道靠漏极一端趋于夹断，但由于电流的连续性，沟道无法真正夹断（称为预夹断），留有极窄的通道，电子在里面高速通过，此时漏极电流几乎达到最大值，此时的电流称为饱和电流（此时MOS成了一个恒流源），发生该电流的电压称为饱和电压（每一个VGS对应一个饱和电流和饱和电压）。
包括前两个阶段在内的MOS管都处于可变电阻区。在该区MOS管相当就是一个由VGS控制的可变电阻
VGD &lt; VTH阶段：VDS进一步增大，电流基本不会改变，MOS管进入饱和区。说是不改变，但还是会有所增加。这称为沟道长度调制效应，这里不做讨论。
四、答疑 1、进入饱和区，若想加大电流该怎么做？ 答：增加栅极电压，以扩大沟道宽度，此时到沟道再次被夹断所通过的电流也会增大。
2、MOS管的特性 答：（1）MOS管的栅极输入阻抗非常高
因为SiO2绝缘层的存在，MOS管输入阻抗达上亿欧姆，导致栅极电流几乎被完全阻断，栅极功耗几乎为0。
（2）MOS管的栅极容易被静电击穿（MOS管是一个ESD敏感器件）
因为栅极输入阻抗很大，栅极上的感应电荷很难释放，它产生的高压很容易就把很薄的绝缘层给击穿。
为什么会产生高压？
U=Q/C
MOS管的极间电容很小，一点点电荷积累就会产生高压！因此用手指触摸栅极就可以使MOS管导通。
怎么解决？
在实验中栅极悬空很危险，很多时候就因为这样爆管，栅极接个下拉电阻对地，旁路搅扰信号就不会直通了，一般选10~20K（为什么？经验值，太大泄放速度慢，太小功耗增加）。这个电阻称为栅极电阻（可泄放栅极积累的电荷）。但这么做的代价就是控制极产生了能耗，原本几乎是0耗能的。
（3）导通电阻低，可以做到几个毫欧的电阻，极低的传导损耗
（4）开关速度快，开关损耗低，理论上可以达到几十MHz或以上，特别适应PWM输出模式。相比之下，三极管的开关速度一般只有几百KHz。
为什么MOS管开关速度这么快？
因为MOS管的极间电容很小，充放电时间很短。
3、为什么叫MOS管？ 下面是MOS管的全称，可以看出MOS管的名称是根据结构与材质来的，它体现的是MOS管的“三明治”结构。
4、增强型N沟道MOS管符号解释 5、既然MOS管是一个对称结构，SD极是否可以互换？ 不能！因为衬底与S相连，使对称结构成为不对称结构，规定与衬底相连的一极为S极。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/374cf84994a4b93bbe0b4ccdf7a931bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bcc4cdcf0f479d51f6d517fbf73d7cb/" rel="bookmark">
			我的开源项目 - 使用OnnxRuntime在CPU端部署RTMPose玩转实时2D姿态估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 RTMPose RTMPose论文地址：https://arxiv.org/abs/2303.07399。
RTMPose是一种Top-Down范式的2D姿态估计框架，魔魔魔魔改Simcc，更加轻量化且更加有效，更加具有工业应用特质。
RTMPose的亮点主打的就是工业级别的推理速度和精度，这在他的论文摘要也是着重突出，可以仔细看他的论文摘要，
Recent studies on 2D pose estimation have achieved excellent performance on public benchmarks, yet its application in the industrial community still suffers from heavy model parameters and high latency. In order to bridge this gap, we empirically explore key factors in pose estimation including paradigm, model architecture, training strategy, and deployment, and present a high-performance real-time multi-person pose estimation framework, RTMPose, based on MMPose. Our RTMPose-m achieves 75.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bcc4cdcf0f479d51f6d517fbf73d7cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02d0d369e0411851787ff0b89c66f27/" rel="bookmark">
			Android 11.0 源码中,锁屏界面使用 密码 锁屏方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求:判断当系统的锁屏方式为 密码 锁屏方式时,需要做某些业务逻辑.
//需要导入的包 import com.android.internal.widget.LockPatternUtils; import android.app.admin.DevicePolicyManager; import android.app.ActivityManager //定义变量 private LockPatternUtils mLockPatternUtils; private DevicePolicyManager policyManager; //初始化变量 mLockPatternUtils = new LockPatternUtils(mContext); /** *判断锁屏界面是否采用 密码 方式进行锁屏 * * */ public void function(){ try { int currentUserId=ActivityManager.getService().getCurrentUser().id; int type = mLockPatternUtils.getActivePasswordQuility(currentUserId); if (type == 0) { //当锁屏采用 密码 方式时,添加业务代码... } else { //当锁屏不是采用 密码 方式时,添加业务代码... } } catch (Exception e) { e.printStackTrace(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d74683d54b00f1410a44091ddcf241/" rel="bookmark">
			抖音人气基本算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以根据已知的观众互动行为，设计一个简单的模拟算法来模拟计算抖音直播人气值。具体的算法如下：
1. 定义一个变量room_popularity来表示当前的房间人气值，初始化为0。
2. 当有观众进入房间，room_popularity加1。
3. 当观众送出礼物，主播亲密度值加1，room_popularity加送出礼物的价值。
4. 当观众点赞，room_popularity加1。
5. 当观众评论，room_popularity加1。
6. 当观众分享直播，room_popularity加1。
7. 当观众连击点赞、评论、分享等，room_popularity加连击次数。
8. 定期（比如每1秒钟）更新房间人气值。
这个算法模拟了抖音直播人气的基本计算方式，但是并不能完全模拟抖音直播人气的复杂计算过程。因为抖音直播人气的计算方式是非常复杂的，还涉及到很多其他因素，比如主播的粉丝数、观众的地域分布、直播内容的热度等等。如果想要更准确地模拟抖音直播人气值，需要更加复杂的算法和数据模型来进行计算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b65ff6f352d6fe17c00c8907cbd1ae01/" rel="bookmark">
			[mars3d 学习] 最近升级版本造成的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、mars3d升级3.5以上，使用的时候报错；
需要看下 Mars3D三维可视化平台 | 火星科技 版本更新日志；
使用将Cesium的版本升级到1.103
2、升级Cesium到1.103，之后打包又会报错 - error in ./node_modules/mars3d-Cesium/Build/Cesium/index.js
哦，是因为cesium1.96改变了代码打包方式；在vue2中就会存在这种问题
解决办法：
1、参考 https://gitee.com/marsgis/mars3d-vue-template/tree/master/mars3d-vue2 升级下vuecli到5
2、固定mars3d-cesium版本为1.95，"mars3d-cesium": "1.95.1" 【注意不要^】
3、在html直接引入Cesium资源和import mars3d方式集成 (cdn cesium + import mars3d) 如果不升级Cesium的版本到1.1以上，就需要保持，mars3d的版本在3.4咯，
那肯定不现实，因为新版本肯定会有新功能，万一想要用新功能呢；
那么就只能升级啦，
个人认为最方便，最佳的解决方案肯定就是从cdn引入Cesium；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb03157daf763207f530e975f1c3b5f/" rel="bookmark">
			PCL-1.13.0&#43;VS2019配置（亲测可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、环境安装PCL-1.13.0-AllInOne-msvc2022-win64二、安装OpenNI2三、环境配置四、VS2019配置4.1 添加包含目录4.2 添加库目录4.3 添加LIB文件4.4 添加预处理器 一、环境 VS2019 + PCL1.13.0
PCL下载链接: https://github.com/PointCloudLibrary/pcl/releases
安装PCL-1.13.0-AllInOne-msvc2022-win64 选择Add PCL to the system PATH for all users，安装完系统变量中会自动生成下图变量，若没有需自行添加。
二、安装OpenNI2 在下列路径中，找到OpenNI2的安装包安装
将下载的第二个文件pcl-1.13.0-pdb-msvc2022-win64解压后，将其中pdb文件复制到PCL安装目录的bin目录下
三、环境配置 系统变量里点击Path，然后添加下图所示路径（按照自己的安装路径来），在配置完后重启电脑
四、VS2019配置 4.1 添加包含目录 4.2 添加库目录 点击C/C++，选择常规，然后将SDL检查改为否
4.3 添加LIB文件 release为：
下面展示一些 内联代码片。
OpenNI2.lib pcl_common.lib pcl_features.lib pcl_filters.lib pcl_io.lib pcl_io_ply.lib pcl_kdtree.lib pcl_keypoints.lib pcl_ml.lib pcl_octree.lib pcl_outofcore.lib pcl_people.lib pcl_recognition.lib pcl_registration.lib pcl_sample_consensus.lib pcl_search.lib pcl_segmentation.lib pcl_stereo.lib pcl_surface.lib pcl_tracking.lib pcl_visualization.lib vtkcgns-9.2.lib vtkChartsCore-9.2.lib vtkCommonColor-9.2.lib vtkCommonComputationalGeometry-9.2.lib vtkCommonCore-9.2.lib vtkCommonDataModel-9.2.lib vtkCommonExecutionModel-9.2.lib vtkCommonMath-9.2.lib vtkCommonMisc-9.2.lib vtkCommonSystem-9.2.lib vtkCommonTransforms-9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb03157daf763207f530e975f1c3b5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a678cf626658e533683fbadc2aa8836/" rel="bookmark">
			NLP中的对抗训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 对抗训练定义 对抗训练是一种引入噪声的训练方式，可以对参数进行正则化，提升模型鲁棒性和泛化能力
1.1 对抗训练特点 相对于原始输入，所添加的扰动是微小的添加的噪声可以使得模型预测错误 1.2 对抗训练的基本概念 就是在原始输入样本 x 上加上一个扰动Δx得到对抗样本，再用其进行训练，这个问题可以抽象成这样一个模型：
m a x θ P ( y ∣ x + Δ x ; θ ) max_{\theta}P(y|x+\Delta x; \theta) maxθ​P(y∣x+Δx;θ)
其中，y 是ground truth, θ \theta θ 是模型参数。意思就是即使在扰动的情况下求使得预测出y的概率最大的参数，扰动可以被定义为：
Δ x = ϵ ∗ s i g n ( ∇ x L ( x , y ; θ ) ) \Delta x= \epsilon *sign(\nabla x L(x,y; \theta)) Δx=ϵ∗sign(∇xL(x,y;θ))
其中，sign为符号函数，L 为损失函数
最后，GoodFellow还总结了对抗训练的两个作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a678cf626658e533683fbadc2aa8836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f07b9b1b298847ba15e272d93001fa5/" rel="bookmark">
			linux通配符和正则表达式深层解析...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
(一)了解通配符和正则的作用
(二)通配符的使用
(三)正则表达式的使用
(四)扩展正则表达式的使用
(一)了解通配符和正则的作用
(1.1)在我们日常的工作中，我们都会使用到通配符或者正则表达式。通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。正则表达式是计算机科学的一个概念，正则表达式通常被用来检索、替换那些符合某个模式的文本，正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
(1.2)不管是通配符还是正则表达式，其功能都是实现模糊匹配，用来匹配某一类东西，并不是匹配具体的某一个值。通配符一般用于shell中，正则表达式一般用于其他语言。
(二)通配符的使用
(2.1)首先第一个是“[]”中括号[list]，匹配的是list中的任意单一字符。例如a[xyz]b，a与b之间必须也只能有一个字符，但只能是x或y或z，如：axb，ayb，azb
(2.2)第二个是“[c1-c2]”，用来表示字符的范围，匹配c1-c2的任意单一字符，如[0-9]或[a-z]。例如“a[0-9]b”表示的是0到9之间必须也只能有一个字符，如：a0b、a1b、a2b、a3b、a4b、a5b、a6b、a7b、a8b、a9b
注意：如果我们需要匹配的是单个字母，且不分大小写，则我们可以使用“[a-zA-Z]”来进行表示。
(2.3)第三个是“[!c1-c2]或[^c1-c2]”，匹配的是不在c1-c2的任意字符。例如a[!0-9]b，a[^0-9]b表示a与b之间只有一个字符，并且不是数字0-9之间的字符，符合要求的有：acb、adb
(2.4)示例：我们在vms002主机上创建一个rh124目录，然后在rh124目录中创建相关的文件：11111、a111、a_111、a22、lwang、lWang、rh124。接着我们查询第一个字符时a到z之间的，第二个字符是非数字的，后面的字符都是任意的。
# mkdir rh124
# touch 11111 a111 a_111 a22 lwang lWang rh124
# ls [a-z][^0-9]*---查询第一个字符时a到z之间的，第二个字符是非数字的，后面的字符都是任意的
(2.5)示例：接着我们的需求是在rh124目录下找到格式为第一个字符是a到z之间，第二个字符是a或者“-”或者z三个字符中的任意一个，后面的字符是任意的。这样我们就可以符合要求的文件名a-1
# touch a-1
# ls [a-z][a-z]*
(2.6)第四个是精确指定字符的大小写“[[:upper:]]”、“[[:lower:]]”，由于我们使用[a-z]的时候可能会匹配出a到z和A到Z之间的字符，大小写并不能精确匹配，所以我们可以使用“[[:upper:]]”表示纯大写的字符，我们可以使用“[[:lower:]]”表示纯小写的字符。
# ls [[:upper:]]*---查询所有纯大写字目开头的文件名
# ls [[:lower:]]*---查询所有纯小写字母开头的文件名
(2.7)当然第四个精确指定字符中还是有其他表示特定字符的方式的：“[[:alpha:]]”表示的是只匹配字母，“[[:alnum:]]”表示的是匹配字母和数字，“[[:digit:]]”表示的是匹配纯数字。
(2.8)示例：现在我们的系统中没有marry用户，我们首先创建一个marry用户，并且指定在根下创建marry的家目录(图1-5)。然后我们将marry家目录删除，此时我们切换到marry用户后发现由于没有家目录，所以切换后是异常的状态(图1-6)，此时我们在/etc/default/useradd配置文件中，查询到用户家目录的模板文件在/etc/skel的目录中(图1-7)，我们将/etc/skel中的所有模板文件都拷贝到marry家目录下，并修改了属主和属组的相关信息，此时便可以正常的进行marry用户的切换了(图1-8)。
# useradd -d /marry marry---创建一个marry用户，并且指定在根下创建marry的家目录
# rm -rf /marry/---删除marry的家目录
# vim /etc/default/useradd---查询/etc/default/目录下的useradd文件
# cp -a /etc/skel/.[^.]* /marry/---将/etc/skel/目录下的所有以“.”开头，第二个字符由于是“[]”所以必须要存在而且是非“.”号，后面跟任意字符的文件全部拷贝到/marry家目录下，skel表示骨架、框架(图1-8)
# chown -R marry.marry /marry/---修改/marry家目录的所有者和所属组都为marry(图1-8)
(2.9)第五个是“?”问号，匹配的是任意一个字符。例如在rh124目录中，我们查询“[a-z]????”，表示的是查询第一个字符是字母构成，后面会有四个任意的字符构成的文件名。
注意：“?”问号是不能匹配到表示隐藏文件的“.”点号的。即表示如果现在系统中有“.aa”文件，我们使用“???”是不能匹配出这个隐藏文件的，如果我们想要匹配出这类隐藏文件则应该开启全局通配符处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f07b9b1b298847ba15e272d93001fa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f653bf58fe1fe5b20fc1b7d6688438f/" rel="bookmark">
			数据科学与机器学习案例之WiFi定位系统的位置预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据科学与机器学习案例之客户的信用风险与预测
数据科学与机器学习之信用卡欺诈识别（严重类失衡数据建模）
数据科学与机器学习案例之汽车目标客户销售策略研究
数据科学与机器学习案例之WiFi定位系统的位置预测 数据简介可视化图集代码汇总 数据简介 可供建模的训练集与测试集共有140多万条记录，我们对文本数据进行了转换，开发了文本处理的函数，并进行了程序调试。
汇总之后的数据共有以下字段：时间、WiFi地址、X、Y、方向、移动设备地址、信号值、信号频率、距离
数据变量类型时间POSIXctWiFi地址分类X连续Y连续Z连续方向连续移动设备地址分类信号值连续信号频率分类距离连续 详细的数据处理、数据汇总、可视化、模型、预测已在思维导图中说明。以下就不在单独详细介绍。
可视化图集 不同位置的记录数
可视化图集1
图1 训练数据的方向的密度图与累积分布图 图2 训练数据方向的直方图 图3 训练数据方向的柱状图 图4 不同数据分割情形下数目与均值减中位数的散点图与拟合估计图 可视化图集2
图1 k近邻交叉验证图 图2 加权k近邻交叉验证图 图3 直接预测的原始位置与预测位置的路径图 图4 WiFi位置图 可视化图集3
图1 训练数据中特定筛选条件下的散点图 图2 特定筛选条件下的信号值的箱线图 可视化图集4
代码汇总 &gt; library(ggplot2) &gt; library(caret) &gt; library(data.table) &gt; library(parallel) &gt; library(lubridate) &gt; &gt; txt = readLines('训练.txt') &gt; &gt; head(txt,6) &gt; &gt; process.data &lt;- function(x){ + a = strsplit(x,'[,;=]')[[1]] + mat = matrix(a[-(1:10)],ncol = 4,byrow = T) + result = cbind(matrix(a[c(2,4,6,7,8,10)],nrow = nrow(mat),ncol = 6 + ,byrow = T),mat) + result} &gt; &gt; process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f653bf58fe1fe5b20fc1b7d6688438f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/85/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>