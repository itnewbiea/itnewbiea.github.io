<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6534ec748bc399d592fa5a22030cb6e0/" rel="bookmark">
			知云文献翻译软件及遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件：知云文献翻译 下载地址：👉点这里
在第一次使用知云文献翻译软件的时候，可能会遇到以下的一些问题，问题不多，但也需要在网上寻找很久的文章，就让我在这里一步到位，觉得对你有帮助的，麻烦点点赞，留下你的评论！
软件介绍 知云文献翻译是一款英文PDF翻译软件。致力于文献阅读的同时，它也是一款功能非常强大的PDF阅读器，软件本身非常小巧，有桌面版和在线网页版，桌面版支持WINDOWS系统，强大的翻译功能知云文献翻译软件内置4种翻译引擎供你选择。
知云文献翻译特点 引擎专为学术术语优化翻译质量可靠，你只需打开PDF文件，选中要翻译的部分，窗口右侧会立即给出翻译，当划选单个词时右侧会有详细词典解释及音标读音，这样在翻译文献的同时你也可以深入地学习英语。
丰富的注释功能知云文献翻译不仅可以翻译，还支持标注注释文档，打开软件注释窗口可以发现包括了附注打字机高亮文本，删除线文本下划线文本箭头线条戳记和戳记模型等功能，点击左下角的注释按钮，还可查找笔记内容非常方便。
登录问题 当我们第首次使用软件，会弹出“请扫码登录”的提示，那么这时，我们可以打开微信扫码登录，那如果你登录成功了，那么恭喜你，你就不用听博主的唠叨了，请开始你的文献阅读之旅吧。那如果有人首次使用划选段落或点击右上方菜单，其他功能-重新登录 ，不显示登陆二维码；或者有些人如下图，二维码处显示一个叉叉；还有些二维码处完全空白的情况。
可能造成这种情况的原因如下：
1、电脑的网络不畅。
2、Internet Explorer故障无法正常联网。
3、所上的网络ip地址被您的单位把腾讯的某些ip地址给屏蔽了。
4、操作系统时间日期和时间不正确。
解决方法 方法1： 1、电脑时间不正确和临时网络不畅的解决。
首先查看电脑右下角看当前日期和时间是否准确。如果不准确修改正确。然后关闭知云， 重新打开，然后点击右上方 其他功能-重新登录。看是否显示二维码。如果显示二维码了，请在1分钟内微信扫码登录。超时请自己点击右上方 其他功能-重新登录，重新产生一个二维码。请务必不要高频率连续3次，在20秒内点击重新登录按钮，以免ip被服务器封禁。
方法2： 2、Internet Explorer代理故障导致的ie无法正常联网。
打开 Internet Explorer
点击“设置”中的“Internet 选项”
切换到“连接”选项卡，打开“局域网设置”
取消“局域网设置”中的所有勾中的选项，点击“确定”
然后再重新打开知云翻译，随便选中一段进行翻译，右侧即可正常登录。
显示二维码后，扫描登录不跳转——解决方案 选择“其他功能”选项中的“重新登录”，即可刷新二维码，刷新之后可以正常扫描登录。
方法3： 注意以下操作必须在一分钟内完成，否则二维码链接过期了。因此点击重新登陆产生新的二维码链接后再快速在一分钟内完成操作。
点击右上方其他功能→重新登陆，如果显示了二维码就直接扫码登录。如果在没有显示二维码的情况下，点击其他功能→提取源代码。
弹出提示：“源代码已经复制到剪贴板。”
然后打开一个文本文件，将剪贴板的内容粘贴进去。这时文本文件最好设置为自动换行，以免代码查看不全。
然后观察粘贴到记事本的内容，其中src=" 两个引号之间的是二维码图片网址"。看下图选中的，两个引号之间的是二维码网址。这个网址每个人的不同，而且每一分钟就会不同，将它复制出来，用电脑浏览器单独打开。
接下来就是用微信的”扫一扫“功能扫描一下你所打开的二维码。
提示登录成功啦。
至此，解决办法分享完毕，如有问题，欢迎私信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202a0cd4baf57984d9300c12fe97a000/" rel="bookmark">
			An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a s
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装torch时总是会出现以上问题，总结如下：
1.更换镜像
用文档打开C:\Users\admin里的.condarc
内容替换成：
channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ -default show_channel_urls: true 2.试试把-default去掉
3.试试把hppts换成hppt
4.以上都解决不了试试，防火墙问题
conda config --set ssl_verify false
5.如果以上方法都无法解决，请换个网络试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030c5fc4d6d702573e9856a720bb83ea/" rel="bookmark">
			什么是隧道？| 网络中的隧道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是隧道？ 在物理世界中，隧道是一种跨越通常无法跨越的地形或边界的方法。同样，在网络中，隧道是一种使用网络不支持的协议在该网络中传输数据的方法。隧道的工作原理是对数据包进行封装：将数据包包装在其他数据包内。（数据包是小块的数据，可以在目的地重新组合成一个大文件）。
隧道技术经常用于虚拟专用网络 (VPN)。它还可以在网络之间建立高效和安全的连接，从而使用本不受支持的网络协议，并在某些情况下允许用户绕过防火墙。
数据包封装是如何运作的？ 通过网络传输的数据被分成数据包。一个典型的数据包有两部分：标头，它指示数据包的目的地和它使用的协议，以及有效负载，它是数据包的实际内容。
封装的数据包本质上是另一个数据包内的数据包。在封装的数据包中，第一个数据包的标头和有效负载进入周围数据包的有效负载部分。原始数据包本身成为有效负载。
为什么封装有用？ 所有数据包都使用网络协议（格式化数据的标准化方式）来到达目的地。但是，并非所有网络都支持所有协议。想象一家公司想建立一个广域网 (WAN) 连接办公室 A 和办公室 B。该公司使用 IPv6 协议，这是最新版本的互联网协议 (IP)，但是办公室 A 和办公室 B 之间有一段网络仅支持 IPv4。通过将 IPv6 数据包封装在 IPv4 数据包中，公司可以继续使用 IPv6，同时仍可在办公室之间直接发送数据。
封装对于加密的网络连接也很有用。加密是对数据进行扰乱的过程，只有使用保密的加密密钥才能解开；解开加密的过程被称为解密。如果一个数据包包括标头在内被完全加密，那么网络路由器就无法将数据包转发到它的目的地，因为它们没有密钥，看不到其标头。通过将加密的数据包包装在另一个未加密的数据包中，数据包可以像往常一样跨网络传输。
什么是 VPN 隧道？ VPN 是公共共享网络上的安全加密连接。隧道是 VPN 数据包到达其预期目的地（通常是专用网络）的过程。
许多 VPN 使用 IPsec 协议套件。IPsec 是一组在网络层的 IP 之上直接运行的协议。IPsec 隧道中的网络流量是完全加密的，但一旦到达网络或用户设备就会被解密。（IPsec 还有一种称为“传输模式”的模式，它不会创建隧道。）
另一个常用于 VPN 的协议是 Transport Layer Security (TLS)。该协议在 OSI 模型的第 6 层或第 7 层运行，具体取决于模型的解释方式。TLS 有时称为 SSL（安全套接字层），尽管 SSL 指的是不再使用的旧协议。
什么是拆分隧道？ 通常，当用户将他们的设备连接到 VPN 时，他们的所有网络流量都会通过 VPN 隧道。拆分隧道允许一些流量离开 VPN 隧道。从本质上讲，拆分隧道允许用户设备同时连接到两个网络：一个公共网络和一个私有网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030c5fc4d6d702573e9856a720bb83ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efdc03a9ca55f62c86b5c3eb698eca4f/" rel="bookmark">
			xducs软件工程期末复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29fce9592d50868636b11bf3723f9e2/" rel="bookmark">
			iptables中SNAT和MASQUERADE的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPtables中可以灵活的做各种网络地址转换（NAT）
网络地址转换主要有两种：SNAT和DNAT
SNAT是source network address translation的缩写
即源地址目标转换
比如，多个PC机使用ADSL路由器共享上网
每个PC机都配置了内网IP
PC机访问外部网络的时候，路由器将数据包的报头中的源地址替换成路由器的ip
当外部网络的服务器比如网站web服务器接到访问请求的时候
他的日志记录下来的是路由器的ip地址，而不是pc机的内网ip
这是因为，这个服务器收到的数据包的报头里边的“源地址”，已经被替换了
所以叫做SNAT，基于源地址的地址转换
DNAT是destination network address translation的缩写
即目标网络地址转换
典型的应用是，有个web服务器放在内网配置内网ip，前端有个防火墙配置公网ip
互联网上的访问者使用公网ip来访问这个网站
当访问的时候，客户端发出一个数据包
这个数据包的报头里边，目标地址写的是防火墙的公网ip
防火墙会把这个数据包的报头改写一次，将目标地址改写成web服务器的内网ip
然后再把这个数据包发送到内网的web服务器上
这样，数据包就穿透了防火墙，并从公网ip变成了一个对内网地址的访问了
即DNAT，基于目标的网络地址转换
MASQUERADE，地址伪装，在iptables中有着和SNAT相近的效果，但也有一些区别
但使用SNAT的时候，出口ip的地址范围可以是一个，也可以是多个，例如：
如下命令表示把所有10.8.0.0网段的数据包SNAT成192.168.5.3的ip然后发出去
iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j SNAT --to-source 192.168.5.3下命令表示把所有10.8.0.0网段的数据包SNAT成192.168.5.3/192.168.5.4/192.168.5.5等几个ip然后发出去
iptables -t nat -A POSTROUTING -s 10.8.0.0/255.255.255.0 -o eth0 -j SNAT --to-source 192.168.5.3-192.168.5.5
这就是SNAT的使用方法，即可以NAT成一个地址，也可以NAT成多个地址
但是，对于SNAT，不管是几个地址，必须明确的指定要SNAT的ip
假如当前系统用的是ADSL动态拨号方式，那么每次拨号，出口ip192.168.5.3都会改变
而且改变的幅度很大，不一定是192.168.5.3到192.168.5.5范围内的地址
这个时候如果按照现在的方式来配置iptables就会出现问题了
因为每次拨号后，服务器地址都会变化，而iptables规则内的ip是不会随着自动变化的
每次地址变化后都必须手工修改一次iptables，把规则里边的固定ip改成新的ip
这样是非常不好用的
MASQUERADE就是针对这种场景而设计的，他的作用是，从服务器的网卡上，自动获取当前ip地址来做NAT
比如下边的命令：
iptables -t nat -A POSTROUTING -s 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d29fce9592d50868636b11bf3723f9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b857366c6e200d1b4b58c2b9a5031cad/" rel="bookmark">
			vue 监控 localStorage 的值变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 1. main.js 重写 localStorage的 setItem // 重写 setItem，为了方便监控 localStorage const Tools = function dispatchEventStroage() { const signSetItem = localStorage.setItem; localStorage.setItem = function (key, val) { let setEvent = new Event("setItemEvent"); setEvent.key = key; setEvent.newValue = val; window.dispatchEvent(setEvent); signSetItem.apply(this, arguments); }; }; Vue.use(Tools); // 2. 页面使用 window.addEventListener 就可以检测到 localStorage 的值了，获取到变化的值，就可以更新页面的数据了 const that = this; // queryqueueCount 为存到localStorage的key window.addEventListener("setItemEvent", function (e) { if (e.key === "queryqueueCount") { // e.newValue(为新的数据) // 更新页面的数据; } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdc6e418a0b0295e3a66ec48edba352/" rel="bookmark">
			c# ini（配置文件）文件读写(简单类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//本文列出了ini类，不考虑节（section）。
//所谓ini文件是扩展名为ini的文本文件，常用于保存和读取配置文件。
//如下所示:
//user=JackMa
//password=123456
//在等号的左边是key,右边是value,一个对应一个value.
//本文中的value是字符串，不涉及类型转换。
//在ini类的后面演示了如何使用该类。
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using System.Collections;
//namespace WindowsFormsApp1//根据情况修改命名空间，最好单独文件保存，再去掉前面的//
{
public class Config
{
public Dictionary&lt;string, string&gt; configData;
string fullFileName;
public Config(string _fileName)//注意路径
{
configData = new Dictionary&lt;string, string&gt;();
fullFileName = Application.StartupPath + @"\" + _fileName;
bool hasCfgFile = File.Exists(Application.StartupPath + @"\" + _fileName);
if (hasCfgFile == false)
{
StreamWriter writer = new StreamWriter(File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdc6e418a0b0295e3a66ec48edba352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c77d233643ff43c618d15e12440c38/" rel="bookmark">
			Yolov7训练自己的数据集（主要是coco2yolo代码，和分割数据集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载安装Yolov7参考一下博文
(52条消息) YOLOv7保姆级教程（个人踩坑无数）----训练自己的数据集_AmbitionToFree的博客-CSDN博客
2. Yolov7支持的数据集格式为yolo格式，我的格式是json，所以需要自己转一下
注意：我这里面json格式中是两个角点（包络框左上角和右下角），不同的格式对应不同的代码，因为发现其他格式网上都有，就只有这一种没找到
代码如下：
import os import json import numpy as np import cv2 #dir_json = 'D:\projects\json/50zhang\ceshijson/' # json存储的文件目录 dir_json = r'E:\projects\json\temp\objectDetection/' dir_txt = r'E:\projects\json\temp\objectDetection/' # txt存储目录 list_json = os.listdir(dir_json) def json2txt(path_json, path_txt): # 可修改生成格式 with open(path_json, 'r',encoding='utf-8') as path_json: jsonx = json.load(path_json) with open(path_txt, 'w+') as ftxt: shapes = jsonx['shapes'] # path = dir_json+shape['image'] # img = cv2.imread(path) # size =img.shape width=jsonx['imageWidth'] height=jsonx['imageHeight'] for shape in shapes: # label = str(annotation['label']) + ' ' x1 = shape['points'][0][0] y1 = shape['points'][0][1] x2 = shape['points'][1][0] y2 = shape['points'][1][1] if shape['label']=='trunk': cat=0 else: cat=1 dw = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c77d233643ff43c618d15e12440c38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966cf332d19636264208aef9fb7f111a/" rel="bookmark">
			CSDN每日一练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写一个函数，传入两个非降序的整数数组（A, B），将 A, B 合并成一个非降序数组 C，返回 C（不要使用内置 sort 函数）。（测试用例仅做参考，我们会根据代码质量进行评分）
在看到这道题时，小编射线想到的就是数组的 一一赋值法 (不知道的小伙伴可以去我主页看看我以往的博客) ,定义两数组，赋值，再进行排序，附上完整代码：
注意，在一一赋值时，一定要注意数组的大小，仔细盯住变量，防止数组溢出，造成错误；
如果觉得小编写的好的话，给小编一个免费的关注，您的肯定是小编创作的动力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f797db9031f2889e61ce6096f08bff/" rel="bookmark">
			zabbix4.0-自定义脚本告警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、在zabbix-server端下载mailx
2、配置mailx配置文件
3、查看zabbix-server设置的 AlertScriptsPath变量
4、在对应路径下面编写邮件脚本
5、创建一个媒介类型
6、为用户指定媒介类型
7、更改触发器表达式进行测试
1、在zabbix-server端下载mailx [root@zabbix-server ~]# yum install -y mailx 已加载插件：fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.ustc.edu.cn * centos-sclo-rh: mirrors.ustc.edu.cn * centos-sclo-sclo: mirrors.ustc.edu.cn * extras: mirrors.ustc.edu.cn * updates: mirrors.ustc.edu.cn base | 3.6 kB 00:00:00 centos-sclo-rh | 3.0 kB 00:00:00 centos-sclo-sclo | 3.0 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 zabbix | 2.9 kB 00:00:00 zabbix-non-supported | 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15f797db9031f2889e61ce6096f08bff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c843d73fe43915d4ce4a2f6f7cc0b4f/" rel="bookmark">
			微信电脑版字体模糊（或文字太小）怎么调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一步：设置屏幕缩放125%第二步：文本大小设置为125%第三步：微信设置--通用--勾选“适配系统缩放比例”第四步：微信高DPI缩放行为设置（关键）ClearType勾选（可选） 笔者遇到这个问题，是在支持1920*1080的高分辨率屏幕，Win11系统。
高分辨率屏幕上一般都会通过设置文本放大，来避免文字太小的问题。
但是设置之后，尽管其他软件能正常显示文字，微信PC版却是模糊字体。
解决方案如下，请对照设置：
第一步：设置屏幕缩放125% 按下Windows徽标键，输入关键字“分辨率”，然后将屏幕缩放设置为125%
第二步：文本大小设置为125% 按下Windows徽标键，输入关键字搜索“文本大小”，将文本大小设置为125%
第三步：微信设置–通用–勾选“适配系统缩放比例” 第四步：微信高DPI缩放行为设置（关键） 在桌面微信图标上，按下鼠标右键，选择属性--兼容性--更改高DPI设置：
勾选上，缩放执行，选择“应用程序”。
ClearType勾选（可选） 按下Windows徽标键，输入关键字“clear”，选择打开“调整ClearType文本”，勾选“启用ClearType”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ef37238cca4c13c6f28a186f467fe9/" rel="bookmark">
			用while循环和for循环分别输出九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		while循环输出九九乘法表：
#while循环输出九九乘法表
p = 1
while p&lt;=9:
j = 1
while j&lt;=p:
print(f"{j}*{p}={p*j}\t",end='') # 制表符\t保证输出内容对齐，end让输出内容不换行
j+=1
p+=1
print() #输出空内容，达到换行的效果
for循环输出九九乘法表：
#for循环输出九九乘法表
for p in range(1, 10):
for j in range(1, p+1):
print(f"{j}*{p}={p*j}\t", end='')
print()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ea7f0b10fb9e0709bb8f0230a8a2e6/" rel="bookmark">
			初学者完成HBuilder X网站制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		像上图这种网站是如何制作的呢？
首先我们观察图片 有大概哪一些标签 （图上（设置了网站标题 h1(标题标签) video(视频标签:居中) hr（水平线标签) p(段落标签) font（字体标签）
非常简单！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a58949db8597aaefad6d60f6e27199f/" rel="bookmark">
			简易项目:servlet实现个人博客(超级详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成品展示 博客登录页 2.博客预览页 博客详情页 4.博客编写发布页 5.可访问网址 http://43.143.248.172:8080/blog_system/login.html
用户名:zhangsan
密码:123
确认需求 1.1核心功能 1.1.1用户登陆和注销 这一部分需要满足用户的登入和注销操作，同时需要判断用户名和密码的正确性，我们使用JDBC从数据库中拉取数据来实现
1.1.2发布博客 这一部分我们需要引入markdown来进行博客系统的编写页面，并且通过JDBC将发布的博客写入到数据库中
1.1.3删除博客 这一部分我们需要将数据从数据库中将对应的博客进行删除，同时需要跳转到博客预览页
1.1.4浏览博客 这一部分我们通过JDBC将博客的标题和正文一部分展示到博客预览页
具体实现 2.1项目基础设计 2.1.1数据库概要设计 首先我们要先设计数据库，基于我们的系统比较简易，所以只有两张表
博客表（blog）
用户表（user）
然后我们根据这两张表，去创建数据库
--创建数据库并设置字符集为utf8mb4 create database if not exists blog_system charset utf8mb4; use blog_system; drop table if exists blog; create table blog( blogId int primary key auto_increment, title varchar(256), content varchar(1025), postTime datetime, userId int ); create table user( userId int primary key auto_increment, username varchar(20), password varchar(20) ); 由于我们没有实现注册功能，所以我们提前在用户表中插入两条数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a58949db8597aaefad6d60f6e27199f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f8c46814038eab48ff19799e77ff44/" rel="bookmark">
			列表删除元素的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常用列表删除元素的方法有5种。
一. del删除列表中对应索引的元素
del listname[index] 二. del删除列表中一段数据
del listname[start : end] 三. pop 删除对应索引的数据
listname.pop(index) 四. remove根据元素内容删除，注意只删除列表中第一个该元素。
listname.remove(item) 五. clear删除列表所有元素
listname.clear(item) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6f17f3e3dfcfde69aa83c3b35ce584/" rel="bookmark">
			Zookeeper选举机制介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZooKeeper是一个高可用的分布式协调服务，它的核心功能之一就是选举机制。当ZooKeeper集群中的一个节点宕机时，需要通过选举机制来选出一个新的leader节点，确保集群的正常运行。下面是ZooKeeper选举机制的详细介绍。
首先，ZooKeeper中每个节点都有一个zxid（ZooKeeper Transaction Id）标识其所提交的事务，zxid值越大，表示该节点提交的事务越多，也就意味着其数据状态更为更新。节点还有一个myid，是一个数字，用来唯一标识该节点。
ZooKeeper中选举leader的流程如下：
每个节点先投自己一票，并向其他节点发送投票信息，包括自己的myid、zxid和选举周期（epoch）。
节点收到其他节点的投票信息后，首先比较各自的epoch值。如果其他节点的epoch值比自己的小，则忽略该节点的投票信息，如果epoch值相等，则比较zxid的值，选取zxid值最大的节点作为leader。
如果没有节点的zxid值比自己的大，则选取myid值最大的节点作为leader。如果myid值也相等，则随机选择一个节点作为leader。
如果当前选举出的节点还没有达到大多数（即超过一半）节点的支持，那么选举失败，重新进入选举流程。
需要注意的是，当节点发现自己被选举为leader时，需要向其他节点发送通知，以确保其他节点能够更新自己的状态。此外，为了避免脑裂（split-brain）问题，ZooKeeper还采用了“过半原则”，即只有大多数节点都能够响应才能够继续进行选举，否则选举将会失败。
另外，ZooKeeper还有两个比较重要的概念，分别是“选举观察者”和“决策者”。
选举观察者是指那些处于“LOOKING”状态的节点，它们会参与到选举过程中，但不会发起投票，只是观察其他节点的投票情况，根据投票结果更新自己的状态。
决策者是指那些处于“LEADING”状态的节点，它们是被选举出来的leader节点，会负责处理客户端请求、更新集群状态等工作。
在ZooKeeper集群中，为了确保选举机制的正常运行，通常会建议使用奇数个节点。这是因为在偶数个节点的情况下，如果出现一半节点宕机的情况，选举就会失败。
总的来说，ZooKeeper选举机制的目的是为了确保集群的高可用性，使得即使部分节点宕机，集群仍然能够正常运行。在实际应用中，我们需要根据自己的业务需求和系统规模，来选择适当的ZooKeeper集群大小和节点数量。
下面对脑裂问题做下介绍：
脑裂（Split-brain）是分布式系统中常见的问题之一，指的是系统中的节点被划分成多个互相隔离的部分，每个部分都认为自己是唯一正确的状态，而与其他部分的状态不一致，导致系统失去一致性，从而产生一系列问题。
脑裂问题的产生通常是由于网络分区、软件故障、硬件故障等因素造成的。当发生脑裂时，不同的部分将继续执行自己的操作，更新自己的状态，如果这些状态互相矛盾，就会导致数据不一致、操作冲突等问题，甚至会影响系统的可用性和数据安全。
在分布式系统中，避免脑裂问题是一个比较困难的问题。一些常见的避免方法包括：
采用集群划分算法，将节点划分到不同的分区中，保证每个分区中的节点互相通信，并限制不同分区的节点之间的通信。
采用“过半原则”，即只有大多数节点都能够响应才能够继续进行操作，否则操作将会失败，从而避免不同部分之间的状态不一致问题。
采用“选主”机制，即在分布式系统中选出一个主节点，其他节点都作为从节点，由主节点来负责协调各个从节点的操作，避免不同部分之间的操作冲突和数据不一致问题。
总的来说，脑裂问题在分布式系统中是一个比较常见的问题，需要我们在设计和实现分布式系统时，特别关注和避免该问题的发生，以确保系统的正确性和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8486dfb0f9fe84a5ae4e2e30354b2d/" rel="bookmark">
			图像处理----直方图均衡化（灰度直方图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像灰度变换中一个非常有用的例子就是直方图均衡化。直方图均衡化是指将一副图像的灰度直方图变平，使得变换之后的图像中的每个灰度值的分布概率都相同。在对图像做进一步处理之前，直方图均衡化通常是对图像灰度值进行归一化的非常好的方法，并且可以增强图像的对比。
在这种情况下，直方图均衡化的变换函数是图像中像素值的累积分布函数（cumulative distribution function,简写为cdf,将像素值的范围映射到目标范围的归一化操作里）。
下面这个函数是直方图均衡化的具体实现：
from PIL import Image from pylab import * from numpy import * def histeq(im, nbr_bins=256): """对一幅灰度图像进行直方图均衡化""" # 计算图像的直方图 # 在numpy中，也提供了一个计算直方图的函数histogram(),第一个返回的是直方图的统计量，第二个为每个bins的中间值 imhist, bins = histogram(im.flatten(), nbr_bins, normed=True) cdf = imhist.cumsum() # cdf = 255.0 * cdf / cdf[-1] # 使用累积分布函数的线性插值，计算新的像素值 im2 = interp(im.flatten(), bins[:-1], cdf) return im2.reshape(im.shape), cdf pil_im = Image.open('D:\\software\\pycharm\\PycharmProjects\\computer-version\\data\\tu3.jpg') # 打开原图 pil_im_gray = pil_im.convert('L') # 转化为灰度图像 pil_im_gray.show() # 显示灰度图像 im = array(Image.open('D:\\software\\pycharm\\PycharmProjects\\computer-version\\data\\tu3.jpg').convert('L')) im2, cdf = histeq(im) im2 = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8486dfb0f9fe84a5ae4e2e30354b2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2655663da63f8e832e68591332ef88/" rel="bookmark">
			关于字符串的查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这道题正式解答前，我想用strcmp 函数来解答，首先来对strcmp 函数讲解一下：
strcmp 函数是用来比较两个字符串的长度，例：
注意，当前仅当strcmp 函数的两个字符串长度相同且内容完全一致时，会返回0；长度相同但是内容不同时会根据单个字符的ascll 码值来比较，而且是前面的减去后面的，例：
If(strcmp(str1,str2)&gt;0)
Return 正数；
Else Return 负数；
如果理解了的话，这道题就好办多了：
按部就班的写就行：
需要注意的是，因为是输入多个字符串，所以定义一个二维数组，输入时只用一个变量来控制，然后来输入。
如果觉得小编写的好的话，给小编一个鼓励，您的肯定是小编创作的动力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1ade99a6c2ab3ca5cd714ea1e83f92/" rel="bookmark">
			MINIEYE笔试第一题：堆方块求表面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：
求一个立方体堆积的多面体的全部表面积。不能简单通过前后左右上下6个面的投影得到，要考虑中间可能有凹陷，凹陷部分会多出表面积。
应当使用减法：先求出所有小方块的6表面积之和，假设它们前后左右不重叠，然后遍历行和列，按照前后和左右，相邻两个方块，高度小的一边会被重叠掉（记高度小的高度为x），应减去2*x。
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; int Solution(int n, int m, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;vec){ int s=0,sum=0,s_left=0,s_pre=0,s_above=0; for(int i = 0;i &lt; n;++i){ for(int j = 0; j &lt; m; ++j){ if(vec[i][j] &gt; 0) sum += 4 * vec[i][j] + 2; if(j + 1 &lt; n) s_left += 2 * std::min(vec[i][j+1], vec[i][j]); if(i + 1 &lt; n) s_pre += 2 * std::min(vec[i+1][j], vec[i][j]); } } s = sum- s_left -s_pre; return s; } int main(){ int n, m; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;std::vector&lt;int&gt; &gt; vec(n); for(int i = 0; i &lt; n; ++i){ std::string str; std::cin &gt;&gt; str; int num = stoi(str); int col = m; while(col &gt; 0){ vec[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1ade99a6c2ab3ca5cd714ea1e83f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9b8b01ad22f38c6dfb58f4644640d8/" rel="bookmark">
			基于x-delayed-message插件实现RabbitMQ延迟消息（Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前提 安装 rabbitmq_delayed_message_exchange 插件，请参考：Windows 10安装RabbitMQ及延时消息插件
2、文件说明 config.php 配置文件TestDelayProduct.php 生产消息TestDelayConsumer.php 消费消息 3、config.php &lt;?php /** * Created by PhpStorm * User: Jason * Date: 2023-02-06 * Time: 11:23 */ return [ // 配置 'config' =&gt; [ 'host' =&gt; '127.0.0.1', 'port' =&gt; '5672', 'vhost' =&gt; '/', 'login' =&gt; 'guest', 'password' =&gt; 'guest', ], // 交换机名称 'exchange_name' =&gt; 'order_expire_exchange', // 队列名称 'queue_name' =&gt; 'order_expire_queue', // 路由key 'route_key_name' =&gt; 'order_expire_key', ]; 4、TestDelayProduct.php &lt;?php /** * Created by PhpStorm * User: Jason * Date: 2023-02-24 * Time: 15:17 */ $config = require 'config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f9b8b01ad22f38c6dfb58f4644640d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d8780fa64988a6b47239bccc483db8/" rel="bookmark">
			shell脚本练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell脚本练习100例-例1-4 例1 循环ping192.168.110网段的所有主机例2 for批量创建用户例3 创建存放1-100奇数的数组里例4 数组操作 例1 循环ping192.168.110网段的所有主机 #!/bin/bash i=1 #定义变量 for i in {1..254} #变量取值范围 do ping -c 2 -w 3 -i 0.3 192.168.110.$i $&gt; /dev/null #ping指令 -c代表执行次数 -w代表超时时间 -i代表时间间隔 $i表示ip地址的最后一个字段取值为变量i /dev/null表示无底洞 即ping指令的输出直接丢弃不显示 if [ $? -eq 0 ] ;then #$?表示上一个指令的退出状态 如果不为0表示ping通 则显示该地址可达 echo "192.168.110.$i is yes" else echo "192.168.110.$i is no" fi #fi是if语句的结束 let i++ #let用来操作表达式 done #for循环结束 例2 for批量创建用户 user=$`cat /opt/user.txt` for i in $user #读取文件中的用户信息 do useradd $i #添加用户 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d8780fa64988a6b47239bccc483db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63597dee32320712fd42ea1d1b5231b2/" rel="bookmark">
			An import path cannot end with a ‘.tsx‘ extension. Consider importing ‘./component/tagUpdate.js‘ ins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 An import path cannot end with a ‘.tsx’ extension. Consider importing ‘./component/tagUpdate.js’ instead.ts(2691)
把
import TagUpdate from './component/tagUpdate.tsx' 改为
// @ts-ignore import TagUpdate from './component/tagUpdate.tsx' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8650f10ccc04472c46686119083a3af3/" rel="bookmark">
			信阳师范学院自动登录校园网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、项目功能
二、使用方式
三、软件下载
四、核心代码
一、项目功能 每次打开电脑都要打开网页重新登录校园网，天天如此简直是在浪费生命。这个项目可以实现校园网的自动登录。开机后校园网连接后直接自动登录，不需要等待启动浏览器填写账号密码。
二、使用方式 文件夹里有两个文件，一个exe文件，一个txt文件。txt文件内要填写自己的账号密码和运营商，且要和exe文件放在同一个文件夹。为exe文件创建快捷方式，并放到启动项。操作参考：Windows10如何添加开机启动项-百度经验 (baidu.com)打开电脑右下角的WiFi列表，将校园网的自动连接勾选上。 三、软件下载 (访问码:gn4s)​​​​​​​天翼云盘 珍藏美好生活 家庭云|网盘|文件备份|资源分享
四、核心代码 实现代码比较重要的是抓包。浏览器显示的网页ip不是固定的，是由一个固定链接打开的。需要用fiddler抓包工具获得。再通过这个链接获得浏览器显示的网页ip。代码如下。
def diyibu(): global wlanuserip get_par = {"wlanuserip":""} static_url = "http://www.msftconnecttest.com/redirect%20HTTP/1.1" static_response = requests.get(static_url) static_response_302_dict = dict(parse_qs(urlsplit(static_response.url).query)) try: get_par['wlanuserip'] = static_response_302_dict['wlanuserip'][0] except Exception as result: 0 # print("网页打开错误，可能已登录成功") #print(get_par['wlanuserip']) wlanuserip = get_par['wlanuserip']#获取登录网址ip 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91cddc3757e9b23553e14b71cb97f3e3/" rel="bookmark">
			测试人不会这个？那回家种田吧——Jmeter使用beanshell对接口加密，调用AES代码的jar包，CBC模式，有偏移量。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中需要对接口进行AES加密，找开发要来了加密的代码（如下），记录下具体的使用方法：
在IDEA中新建一个AES1模块，在里面新建一个类（类的名字为AESu1）。
把下面的代码复制进去，
这样，AES加密的方法就构建好了。接下来就是导出为jar包了。文件-项目结构-工件-点击+号，
3.1 点击构建-构建工件
3.2 再选中AES1.jar，点击构建，jar就创建好了
把生成的jar包，放到jmeter的lib路径下（有的文章说需要放到lib的ext路径下），不过我是放到lib就已经可以使用了。
在jmeter中，需要把jar包的路径，放到测试计划中。
在beanshell中import AES1.*;填入代码即可
这是AES加密代码
package AES1; import sun.misc.BASE64Encoder; import javax.crypto.Cipher; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; import java.io.UnsupportedEncodingException; import java.nio.charset.StandardCharsets; import java.security.AlgorithmParameters; import java.security.Key; public class AESu1{ private static final String ALGORITHM = "AES/CBC/PKCS5PADDING";//加密模式,设置为CBC private static final String IV_SPEC = "ZE*84J]YE@11a=?9";//偏移量,可自行更改。 public static String encrypt(String content, String token) throws UnsupportedEncodingException { //对content加密，token为加密的秘钥，长度要为16位 byte[] result = encryptByte(content.getBytes(StandardCharsets.UTF_8), token.substring(0, 16).getBytes(StandardCharsets.UTF_8)); //return Base64.encodeBase64URLSafeString(result); return new BASE64Encoder().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91cddc3757e9b23553e14b71cb97f3e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd52d72f1f01aeaae6433ec926c9a630/" rel="bookmark">
			通过AI算法预测彩票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作上比较闲，于是抽时间写了个APP，运用一些AI算法，先排除一些明显不可能的号，然后结合历史数据，分析测算出可能得结果，试运行了大概10期，中了一个三等奖，蓝球概率有明显提高，红球最高中了5个号，预测算法还在不断改进中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28318cba7dd83dd8cdf70fe316c01fd/" rel="bookmark">
			vue&#43;WangEditor编辑器配置上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录. 起因这段在维护老项目过程中，客户反馈说前台页面查看项目动态时加载太慢需要 2-3秒才能加载出页面。后来我去排查是发现之前富文本编辑器上传图片时把 图片转base64发送给了后端…结果你懂.
这种情况一张图片还好图片多了就导致信息量太大，5mb大小文件存到数据库里…这查询能不慢么
下面代码
this.editor = new E(this.$refs.editorElem); this.editor.customConfig.menus = [ // 菜单配置 "head", // 标题 "bold", // 粗体 "fontSize", // 字号 "fontName", // 字体 "italic", // 斜体 "underline", // 下划线 "strikeThrough", // 删除线 "foreColor", // 文字颜色 "backColor", // 背景颜色 "link", // 插入链接 "list", // 列表 "justify", // 对齐方式 'image', // 插入图片 "table", // 表格 "undo", // 撤销 "redo", // 重复 ]; this.editor.customConfig = this.editor.customConfig ? this.editor.customConfig : this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28318cba7dd83dd8cdf70fe316c01fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66515b250e640634cd4f8490dc3558aa/" rel="bookmark">
			对象数组根据某个key来进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 自定义排序方法 数组对象按key升序或者降序排列 const compareValues = (key, order = 'asc') =&gt; { return function innerSort(a, b) { if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) return 0; // const comparison = a[key]?.localeCompare(b[key]); // 这个是按字符串的顺序来进行排列，如果是数组的话，则1 和 10就会排在最前面， // 如果是按数字的顺序来进行排列，就要用这种相减的方式 const comparison = a[key] - b[key] console.log(comparison) return order === 'desc' ? comparison * -1 : comparison; }; }; 用法：
list.sort(compareValues('orderNo')) // list对象数组根据orderNo来进行排序 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5550eaba9563f9dae77422655d9652/" rel="bookmark">
			uniapp 、 微信小程序 text 字母 数字不换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 、 微信小程序 text 字母 数字不换行 设置css 试试 word-break: break-all;
word-wrap: break-word;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c71a6ef001823d8d4526f708c8873ee/" rel="bookmark">
			Java：博客系统，实现加盐加密，分页，草稿箱，定时发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 项目概述2. 准备工作2.1 数据库表格代码2.2 前端代码2.3 配置文件 3. 准备项目结构3.1 拷贝前端模板3.2 定义实体类3.3 定义mapper接口和 xml 文件3.4 创建其他包 4. 统一数据返回4.1 Result 类4.2 统一数据格式 5. 注册5.1 逻辑5.2 验证数据规范性5.3 实现注册5.4 前端代码完善 6. 登录6.1 前端代码6.2 后端代码 7. 拦截器7.1 逻辑7.2 拦截规则7.3 拦截器所作用的范围 8. 博客编辑页8.1 逻辑8.2 触发登录验证8.3 发布文章8.4 保存至草稿箱8.5 退出账号 9. 个人主页9.1 获取用户信息栏9.2 获取个人主页所有文章9.3 删除文章 10. 博客详情页10.1 获取 URL 中的参数10.2 左侧作者信息10.3 右侧文章详情 11. 修改文章页11.1 加载文章内容11.2 将文章保存为草稿11.3 修改后发表 12. 博客主页12.1 分页12.2 前端12.3 后端12.4 实现剩下四个按钮 13. 密码加盐加密13.1 加盐加密13.2 验证13.3 更新 14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c71a6ef001823d8d4526f708c8873ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cff36ed44efc3a194c179da714e21f2/" rel="bookmark">
			centos配置开机自启动jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1，查找centos安装的java路径
/usr/bin/java ll /usr/bin/java ll /etc/alternatives/java java默认的安装路径为：
/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64/jre/bin/java 2，在任何目录下创建自启动脚本,设置开机自启动，auto_start.sh
在家目录创建脚本文件，添加内容：
#!/bin/bash #配置jdk的路径 export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64/jre/bin/java #此处为我的java环境路径，需要改为自己的JDK路径 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #有时需要把jar包延时启动（不设置延时启动jar，nacos会提示拒绝连接） #延时10S运行jar包，需要延时启动则放开sleep注释行 （sleep+数字，表示延迟多少秒启动） sleep 5 #配置jar包启动的路径 日志生成路径 nohup表示静默启动,不在窗口显示启动日志 nohup java -jar /home/ss/projects/license/license-api.jar &amp; 为自启动脚本添加执行权限
chmod +x /home/ss/auto_start.sh
3,编辑/etc/rc.local文件内容
添加完成之后，对文件重新赋予执行权限
chmod +x /etc/rc.local 4,重启计算机测试
5，查看jar包启动命令
ps -ef | grep java 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7842be302f4a0f85dce3e95a00388b/" rel="bookmark">
			React从入门到精通二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React从入门到精通之购物车案例 1. 购物车需求说明使用到的data list 2. 项目code 1. 购物车需求说明 list data展示到列表中每个item的通过±按钮来控制购买的数据量删除按钮可以删除当前的itemTotal Price计算当前购物车的总的价格 使用到的data list const books = [ { id: 1, name: 'introduction to algorithms', date: '2006-9', price: 85.00, count: 1 }, { id: 2, name: 'The Art of UNIX Programming', date: '2006-2', price: 59.00, count: 1 }, { id: 3, name: 'Programming pearls', date: '2008-10', price: 39.00, count: 1 }, { id: 4, name: 'Complete code', date: '2006-3', price: 128.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7842be302f4a0f85dce3e95a00388b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8160edd48af2ab240906fa581ecf1a7/" rel="bookmark">
			Prism学习：Region的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prism学习：Region的使用 什么是Region使用Region的两种方式通过Region使View和ViewModel解耦创建一个项目使用Region将View和ViewModel解耦 什么是Region 在我们的日常开发中，通常会将一个页面切割成不同的部分。如下一个页面，我们可以将其划分为头部、左侧目录、页面主体三个部分。
在Prism中，我们可以将这三个部分理解为三个区域（Region），而区域之中可以再细分区域。Region负责承担UI控件，其中内容并不固定，可以动态分配。
Prism中Region通过RegionManager进行管理。
使用Region的两种方式 方式1：
给页面中的内容控件设置RegionName
&lt;ContentControl Grid.Row="1" prism:RegionManager.RegionName="ContentRegion" /&gt; 在页面的构造函数中注册Region中需要展示的内容，其中ViewA是定义在另一个xaml文件中的页面模块。
public MainView(IRegionManager regionManager) { InitializeComponent(); regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA)); } 方式2：
给页面的内容控件设置Name。
&lt;ContentControl Grid.Row="1" x:Name="MainContent" /&gt; 在构造函数中通过SetRegionName方法设置RegionName，并注册Region中需要展示的内容。
public MainView(IRegionManager regionManager) { InitializeComponent(); RegionManager.SetRegionName(MainContent, "ContentRegion"); regionManager.RegisterViewWithRegion("ContentRegion", typeof(ViewA)); } 通过Region使View和ViewModel解耦 创建一个项目 项目只有一个窗体，但有两个页面模块，需要通过两个按钮进行页面切换。
在ViewModel设置一个object类型的对象Body来存放页面模块。
点击按钮后，通过Command中的委托方法来切换页面模块。
项目结构如下：
页面如下：
页面文件：MainView.xaml
&lt;Window x:Class="PrismDemo.Views.MainView" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:local="clr-namespace:PrismDemo" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:prism="http://prismlibrary.com/" Title="MainWindow" Width="800" Height="450" prism:ViewModelLocator.AutoWireViewModel="True" mc:Ignorable="d"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="28" /&gt; &lt;RowDefinition /&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8160edd48af2ab240906fa581ecf1a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b0a127490011654e48aa7ae3f3dfdc/" rel="bookmark">
			Python表白代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体代码如下
import time
def send_love(name):
print(f"亲爱的{name}，我想告诉你：")
time.sleep(2)
print("我喜欢你！")
time.sleep(2)
print("喜欢你的笑容、喜欢你的眼神、喜欢你的声音，")
time.sleep(2)
print("喜欢你每一个细微的表情和动作。")
time.sleep(2)
print("我知道我们之间还有些距离，但我想一步一步走过来，")
time.sleep(2)
print("和你一起分享生活的点点滴滴，")
time.sleep(2)
print("一起经历生命中的每一个美好瞬间。")
time.sleep(2)
print("愿意接受我的心意吗？")
time.sleep(2)
print("祝你有一个美好的一天，等待你的回复。")
# 在这里输入表白对象的名字
send_love("小美")
只需要将最后一行代码中的“小美”替换为你喜欢的人的名字，然后运行即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39aa8d8142e89fda98a6d70ca0377e11/" rel="bookmark">
			Android singleLine弃用，怎么正确处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先看一下singleLine的解释与用法 android:singleLine
Formats: boolean
Constrains the text to a single horizontally scrolling line instead of letting it wrap onto multiple lines, and advances focus instead of inserting a newline when you press the enter key. The default value is false (multi-line wrapped text mode) for non-editable text, but if you specify any value for inputType, the default is true (single-line input field mode). {@deprecated This attribute is deprecated. Use maxLines instead to change the layout of a static text, and use the textMultiLine flag in the inputType attribute instead for editable text views (if both singleLine and inputType are supplied, the inputType flags will override the value of singleLine).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39aa8d8142e89fda98a6d70ca0377e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc69b087f47956df2f6280a6adb8f4c/" rel="bookmark">
			Nginx 配置 HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器上已经安装nginx服务，已经具备http访问； nginx服务器是否已经安装ssl模块得支持； 是否已经拥有ssl证书； 查看nginx 安装模块
/usr/local/nginx/sbin/nginx -V 如果看到我上图标记得 configure arguments: --with-http_ssl_module, 则已安装
如果之前没有安装更新步骤
cd nginx ./configure --prefix=/usr/local/nginx --with-http_ssl_module 使用 make 命令编译（使用make install会重新安装nginx），此时当前目录会出现 objs 文件夹。用新的 nginx 文件覆盖当前的 nginx 文件
cp ./objs/nginx /usr/local/nginx/sbin/ ssl 证书部署 下载申请好的 ssl 证书文件压缩包到本地并解压（这里是用的 pem 与 key 文件，文件名可以更改）。
在 nginx 目录新建 cert 文件夹存放证书文件。
cd /usr/local/nginx mkdir cert nginx 配置
server { listen 443; #SSL 访问端口号 server_name soft.loiot.com; #填写绑定证书的域名 ssl on; #启用 SSL 功能 ssl_certificate ../cert/c.pem; #证书文件名称 ssl_certificate_key .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc69b087f47956df2f6280a6adb8f4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3fcd26c82786260937d354abc87c8db/" rel="bookmark">
			IDEA 值得推荐的优秀插件分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA可以说是目前市面上，比较好用的编程软件之一，想必各位程序大佬们也都有用过。这要得益于它炫酷的UI界面，强大的功能，以及可以下载丰富的插件，帮助我们编程开发，提升我们的工作效率等等。之前也有朋友和同事，询问我有没有好用的插件推荐。正好，最近项目不忙，闲来无事，决定写篇帖子，跟大家分享一下IDEA比较好用的插件。
以下都是本人使用idea开发以来，所使用过的插件，强烈推荐，提升代码质量，事半功倍之首选！！！
一、插件如何安装？ ps：本人使用idea的版本是2022.2.3
1.打开IDEA
2.点击菜单栏中的"文件"
3.弹出的下拉框中，选择"设置"
4.选择菜单“插件”，如果没找到，也可以在搜索框中输入“Plugins”
5.点击安装按钮，插件安装完毕，重启IDEA就可以使用了
6.卸载已安装的插件：
二、插件推荐 1、Alibaba Java Coding Guidelines(阿里规范检测工具)
一款代码规范扫描工具，以后我们的Java代码规范，就靠它了。
2、Chinese(Simplified) Language Pack(中文汉化)
一款汉化语言包，idea展示的全是英文，对于英语不好的同学用起来非常的难受，安装这款插件后瞬间舒服了很多。（原谅我英文不好，因为我爱国☺）
3、GenerateAllSetter
一键生成set、get方法，同学们以后再也不用手动一遍遍的敲击set、get方法了，释放双手。
在代码中，new一个对象，鼠标停留在对象变量userEntity上，alt+enter会出现快捷选项，如图：
选择其中的Generate all setter，就会出现如下图所示：
4、Grep Console
一款可以自定义控制台打印日志颜色的插件，让自己的控制台高大上起来。
效果如下：
日志颜色设置：
5、JRebel（快速热部署插件）
一款自动化热部署的插件，修改完html,js,controller等代码后，再也不用手动重启项目了，又帮自己剩下几秒时间，强烈推荐。不过这个插件现在是要收费的，详细使用方法如下：
⑴.选择第一个选项，Connect to online licensing service，在第一个输入框中输入拼接好的服务地址(例如：http://jrebel.cicoding.cn/+生成的GUID)，然后在第二个输入框中随便输入一个邮箱地址（符合格式的邮箱都可以）。
生成随机的GUID：https://www.guidgen.com/
⑵.然后点击Change license按钮即可。如果失败，可以用上面说的重新生成一个新的GUID再试一次。
⑶.设置编译时间
6、Lombok
Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。
简单的说，就是在你的实体类上添加**@Data**这个注解，就无需生成get、set、toString、构造方法等等，是不是很方便（大大增加了摸鱼的时间）。
在使用之前需要添加一下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 7、MyBatisCodeHelperPro（强烈推荐）
这个是一款比较实用的插件。但是，现在需要收费啦，貌似是需要花费29块钱，送两个激活码。不过，也可以申请7天的免费测试码，体验一下在购买也可以的。收费掩盖不了她的魅力所在，这也是行业发展的趋势。具体功能如下（附白嫖地址）：
提供Mapper接口与配置文件中对应SQL的导航编辑XML文件时自动补全根据Mapper接口, 使用快捷键生成xml文件及SQL标签ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C)快捷键生成@Param注解XML中编辑SQL时, 括号自动补全XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数)自动检查Mapper XML文件中ID冲突自动检查Mapper XML文件中错误的属性值支持Find Usage支持重构从命名支持别名自动生成ResultMap属性快捷键: Option + Enter(Mac) | Alt + Enter(Windows) 下载地址：https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro/versions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3fcd26c82786260937d354abc87c8db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ff97b0fd734b22cb5aad8e16fd0df4/" rel="bookmark">
			java反序列化漏洞基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近年来反序列化漏洞可谓被大家熟知，尤其是的在JAVA 程序中发现了大量的反序列化漏洞，这种漏洞危害极大，可以直接造成RCE，获取到权限，本人之前对于这个漏洞一致认识很浅薄，甚至对于利用方式和工具都不太清楚，本文是对java语言基础的序列化与反序列化进行学习。
序列化与反序列化 Java 序列化是指把 Java 对象转换为字节序列的过程，序列化后的字节数据可以保存在文件、数据库中；而Java 反序列化是指把字节序列恢复为 Java 对象的过程。
所有在网络上面传输的对象，必须是可以序列化的。比如RMI（remote method invoke 远程方法调用），传入的参数和返回的结构都是可序列化的。所有需要保存到磁盘的对象都要实现序列化。通常建议创建的javaBean类都实现Serializable接口。
当然在实际场景中，直接使用JDK序列化的场景是很少的，一般都是使用其他方式，这是因为其本身有很多缺陷，如：无法跨语言、易被攻击、序列化后的流太大、序列化性能太差等。
但是我们通过学习他来了解基础原理，其他方式思路上应该也是大差不差。
java序列化 java中想要实现序列化与反序列化，主要是通过Serializable和Externalizable接口实现的。
Serializable与Externalizable的不同
Serializable接口是不需要提供无参构造器的，因为直接由虚拟机来创建对象的，不通过构造方法。Externalizable是通过反射来创建对象的，需要类中有无参构造器。
采用Externalizable无需产生serialVersionUID，而Serializable接口需要。
Externalizable 接口继承自 Serializable 接口，实现 Externalizable 接口的类完全由自身来控制反序列化的行为，而实现 Serializable 接口的类既可以采用默认的反序列化方式，也可以自定义反序列化方式。
Serializable接口 Serializable接口并没有要实现的方法，只是类似于一个标识符，表示这个类是可以被序列化的，不实现这个接口，序列化时程序会报错。
首先，我们创建一个User 类，这个类一定要实现Serializable接口
class User implements Serializable{ private int age; private String name; public User(){ }; public User(String name,int age){ this.age = age; this.name = name; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32ff97b0fd734b22cb5aad8e16fd0df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d43e2e2800e591cda5c2db6a40d2a91/" rel="bookmark">
			Qt——线程与定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定时器QTimer类 The QTimer class provides repetitive and single-shot timers.
The QTimer class provides a high-level programming interface for timers. To use it, create a QTimer, connect its timeout() signal to the appropriate slots, and call start(). From then on, it will emit the timeout() signal at constant intervals.
上面这段话摘自Qt助手文档，我们使用QTimer类定义一个定时器，它可以不停重复，也可以只进行一次便停止。
使用起来也很简单：
QTimer *timer = new QTimer(this); connect(timer, SIGNAL(timeout()), this, SLOT(update())); timer-&gt;start(1000); 创建一个QTimer对象，将信号timeout()与相应的槽函数相连，然后调用start()函数。接下来，每隔一段时间，定时器便会发出一次timeout()信号。
更多用法这里就不讲了，您可以自行参考官方文档。比如如何停止、如何令定时器只运行一次等。
二、在多线程中使用QTimer 1.错误用法 您可能会这么做：
子类化QThread，在线程类中定义一个定时器，然后在run()方法中调用定时器的start()方法。
TestThread::TestThread(QObject *parent) : QThread(parent) { m_pTimer = new QTimer(this); connect(m_pTimer, &amp;QTimer::timeout, this, &amp;TestThread::timeoutSlot); } void TestThread::run() { m_pTimer-&gt;start(1000); } void TestThread::timeoutSlot() { qDebug() &lt;&lt; QString::fromLocal8Bit("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d43e2e2800e591cda5c2db6a40d2a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f004dae34b6106b166d60bea83c27b0/" rel="bookmark">
			vue项目上线前后端以及数据库操作整套流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.项目优化
2.项目打包
3.服务器新建数据库
4.服务器运行node项目
5.服务器配置跨域
1.项目优化 本地的项目或者已经优化的项目直接忽略前两项
当我们完成一个Vue项目的时候，可以用vue uI 进行优化，将我们的项目导入
进去 ，具体的优化流程看之前发布的博客vue 项目优化上线以及如何开启gzip压缩_Mr.mjw的博客-CSDN博客_vue项目开启gzip压缩
vue 项目优化上线以及如何开启gzip压缩_Mr.mjw的博客-CSDN博客_vue项目开启gzip压缩
2.项目打包 使用vue ui 里面的打包工具可以快速将项目打包，打包完成之后可以在本地使用live-server在本地运行此项目，确保无误的话就等待放到服务器的文件夹中
3.服务器新建数据库 下面用的是宝塔Linux面板用其他的盆友可以忽略
登录进去宝塔面板
点击添加数据库会弹出一下窗口 用户名不能使用root，这里先用mydb来代替了,密码一致下面会用到
然后将我们的默认数据上传进去，上传完成之后再次点击导入
4.服务器运行node项目 首先在服务器的目录下创建一个新的文件夹，然后将我们的node文件放到文件夹里面，
&lt;注意不用上传依赖进去，运行项目的时候自己会下载！&gt; 然后再网站的node项目里面添加node项目
项目名称随便先起一个，项目目录就是刚才上传的node文件
启动选项改成自定义启动
添加完成以后会出现
注意！！！
项目端口一定要和app.js里面的端口号一致 这边先随便定义任意数不要冲突，我的是3001
由于上面的是3001所以下面也要和上面定义的一致
有域名的话就绑定域名，没域名的话就用服务器ip，域名一定要解析
然后就可以提交了
然后改里面的文件
下面的三个mydb分别是数据库名字也就是我们新建的数据库还有用户名跟密码
然后node项目就可以运行了 我们的这个项目里面放的是接口，现在就可以请求到这些接口了
本地跨域 如果需要本地跨域则在vue.config.js里面配置
devServer: { proxy: { "/api": { target: "跨域地址", changeOrigin: true, pathRewrite: { "^/api": "", }, }, }, } 5.服务器配置跨域 如果我们在项目的config.js里面设置了跨域，打包完成以后请求不到数据
就需要在服务器里来配置了
点击设置进入设置面板
然后在root下面加进去一下代码
location /api { proxy_pass 跨域地址; } 然后保存，保存完成以后要重新运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71cf5681f771a3d91f3d4c91773804b8/" rel="bookmark">
			华为外包测试2年，不甘被替换，168天的学习转岗成正式员工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我25岁的时候，华为外包测试，薪资13.5k，人在深圳。
内卷什么的就不说了，而且人在外包那些高级精英年薪大几十的咱也接触不到，就说说外包吧。假设以我为界限，25岁一线城市13.5k，那22-24大部分情况下是不会超过13的。而我旁敲侧击了30岁以上未做到管理层的老大哥们，他们估计到手15-16k。
人生曲线配合这个职业，我自己是觉得，我到头了。我不能被限制在深圳！我二十出头的时候，朋友说我月入过万，一顿吹，我也觉得我好像挺厉害的。
几年后，我麻了，外包是不被当人看待的，我不是什么人中龙凤，也许五年后十年后，老大哥们的现在就是我的未来，我慌了。年轻的时候疯狂加班，我感觉自己很虚，已经是咬牙加班了，而老大哥们已经有头发发灰发白迹象了。
对了，劳累使人变丑头秃是真的，我的好搭档当时已经由乌黑浓密变得稀疏了，他才26！我那次离职是得了失眠症，又是吃药又是针灸推拿，花了一万多养了一个月才恢复一点。而且，由于人经常对着电脑，直线思维，铁直男很难找到女朋友的，如果头秃，就更难了
当时这家公司那段时间貌似要我去接手一个维护的班（听说）老哥在我这年纪做了维护，然后恍惚之间已然30岁，然后毅然辞职回家，要找女朋友，要结婚。。。老实说我觉得很晚了，大城市不在乎你几岁，但小城市在乎，但愿他能成功。
至于我，理想状态下，外包测试生涯，我打算早一点19年10月做完，晚一点，来年4月。我要考研了，我知道我学历低，也没比别人聪明到哪，假如我有那么万一的几率成功，我想我会努力留在深圳的。可是不能的话，我也不留在深圳耗了。
人生很长，没有什么工作能从一而终，测试我始终认为下线高，刚入行就能很快破万。我不能接受，我30岁以后在深圳996的怼，而工资还不到两万（即使能突破，又能高几分？）人生自有得失，我在这个年纪，虽然怼996，可确实工资还不错，但是随着年龄增长，工资却不怎么动的时候，就该走了。
我也需要一段大量的时间，去恋爱，去结婚。而不是在方寸之间与电脑共度青春。什么？你说好好干升职加薪？醒醒吧，外包哪有前途，你只是块干电池而已，随时都会被换掉。
在深思过后，我还是准备提升自己。在一次偶然机会下开始初步接触了自动化测试，也学习了 Jenkins 操作以及 Linux 命令行等相关基础技能。
不是在学习，就是在学习的路上，后来尝试着接触一些代码和一些框架，把自己所学的知识融入到你自己的项目中去。把自己的项目整理出一个测试框架去学selenium，网站的架构，代码知识，知识，网络瓶颈，系统优化，优化脚本，去设计场景，去获取目标用户量，去执行，去分析压力结果。
终于，两年外包做测试，一遇风云变化龙！转岗成正式员工，月薪18k
我的自动化测试之路，一路走来都离不每个阶段的计划，因为自己喜欢规划和收集总结，所以，我和朋友特意花了一段时间整理编写了下面的《自动化测试工程师学习路线》
自动化测试工程师学习路线
1.自动化测试必备Python编程内容
2.Web UI 自动化测试基础内容
3.Web UI 自动化测试实战内容
4.APP UI 自动化测试基础内容
5.APP UI 自动化测试实战内容
6.API 接口自动化测试基础内容
7.API 接口自动化测试实战内容
8.CI/CD持续集成专项技术
9.自动化测试框架实战技术
上面就是我为大家整理出来的一份软件测试工程师发展方向知识架构体系图。希望大家能照着这个体系在3-4个月完成这样一个体系的构建。可以说，这个过程会让你痛不欲生，但只要你熬过去了。以后的生活就轻松很多。正所谓万事开头难，只要迈出了第一步，你就已经成功了一半，等到完成之后再回顾这一段路程的时候，你肯定会感慨良多。
总结： 最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你!有需要的小伙伴可以点击下方小卡片领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50541738e8e79ae640f976200ae33c86/" rel="bookmark">
			2023-2030老龄化（＞=65）比率预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、数据来源和处理
二、相关性检验
Ⅰ、图形说明
Ⅱ、相关矩阵
三、LSTM算法预测
四、BP神经网络预测
前言 如何预测未来八年老龄化比率？作者从以下四个角度出发：GDP，医院数（医院包括综合医院、中医医院、中西医结合医院、民族医院、各类专科医院和护理院，不包括专科疾病防治院、妇幼保健院和疗养院。），自然增长率，15-64岁人群比率。经济的发展和医疗服务保障会促进人类平均寿命的延长，自然增长率则涉及到人口基数的变化，由于预测的是未来五年老龄化比率，15-64人群比率也要考虑在内。
其他因素对老龄化也有很大影响，如不可抗力（自然灾害，疫情等），或因为作者知识水平有限，或为了简化模型，不考虑在内。如果你有相异的见解，欢迎一起交流。
一、数据来源和处理 声明：本文所用数据都来自于国家统计局，特别感谢作者的信息检索老师，为数据的寻求提供了帮助。
由于各方面的原因，国统局对65岁以上人群的连续（每年）统计从1990年开始，本文所用到的数据均为相同的时间跨度：1990-2022。补充：2023/2/19，国统局上尚未公布2022年医院数，以38000估计。
附议Python文件处理代码：
f=open(r"C:\Users\username\Desktop\1.txt",'r').readlines() #1.txt存放了复制粘贴的数据 g=open(r"C:\Users\username\Desktop\2.txt",'w') #2.txt准备写入处理后的数据 for i in list(reversed(f[0].split())):#原年份为倒序，故reversed g.write(i+'\n')#注意要换行 g.close() 二、相关性检验 Ⅰ、图形说明 p是经过处理后的数据，各列所代表的意义如下图。（想要完整数据的请私信）
将p归一化处理后（对每个指标），绘制五个指标在同一坐标系下的图
从中发现：
①15-64岁人口比率和&gt;65的比率相关性较弱
②自然增长率与&gt;65的比率大致呈负相关
③GDP与&gt;65的比率大致呈正相关
④医院数大致与老龄化正相关
q=mapminmax(p',0,1); ls=['r*--','go--','bd--','ys:','kx-.'];%linestyle for i=1:5 plot(1990:2022,q(i,:),ls(i)); hold on end set(gca,'XTick',1990:3:2023); legend('15-64比率','&gt;65比率','自然增长率','GDP','医院数'); title('各数据归一化后在同一坐标轴的呈现'); Ⅱ、相关矩阵 想要进一步了解相关矩阵请前往阿白数模笔记之协方差矩阵与相关矩阵
&gt;&gt; corrcoef(p) ans = 1.0000 0.3315 -0.5089 0.3467 0.2950 0.3315 1.0000 -0.8596 0.9920 0.9925 -0.5089 -0.8596 1.0000 -0.8062 -0.8119 0.3467 0.9920 -0.8062 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50541738e8e79ae640f976200ae33c86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ec4875f2b66b015eb4849df9e27eba/" rel="bookmark">
			【Mysql的基本用法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.什么是Mysql2.数据类型3.数据库的操作3.1创建库3.2显示库3.3 使用数据库3.4删除数据库 4.标的操作4.1查看表4.2 创建表4.3显示表结构4.4删除表 5.插入5.1单列插入5.2多列插入 6.查询6.1全列查询6.2指定查询6.3 查询字段为表达式6.4 去重 DISTINCT6.5别名 as[别名]6.6排序 desc,asc6.7条件查询 where6.8分页查询 limit 7.修改 UPDATE8.删除 DELET9.寄语 1.什么是Mysql MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。
MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点
2.数据类型 这里列举了一些在数据库操作的做常用的数据类型
3.数据库的操作 3.1创建库 create [数据库名] set utf8; //set utf8 是为了使用字符集,防止插入汉字时出现错误 3.2显示库 show [数据库名]; //显示当前所有的数据库 3.3 使用数据库 use [数据库名]; //转换当前数据库 3.4删除数据库 drop database [数据库名]; 4.标的操作 4.1查看表 show tables; //查看当前数据库所有表 4.2 创建表 create table [表名](数据 类型,数据 类型); //create table lisan(id int,name varchar(20),score decimal(3,1)); 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ec4875f2b66b015eb4849df9e27eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b265a8505855aa85e8b62b2090ffa8e5/" rel="bookmark">
			关于上楼梯题目和确定不知道多少个整形数组出数字的解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		马上就要开学了，C语言上机测试小编也很慌，于是今天早上赶紧爬起来复习，结果看到这么一个题目:
现在有一截楼梯，根据你的腿长，你一次能走 1 级或 2 级楼梯，已知你要走 n 级楼梯才能走到你的目的楼层，请实现一个方法，计算你走到目的楼层的方案数。
​​​​​​​刚拿到题时，我也有点懵，但是仔细一想，是递归的题目：
首先，把 n&lt;=2 的情况直接返回，再考虑n&gt;2的情况：
一一把他们类出来，就能发现规律：
下面是我自己写的代码，可能会有不对的地方，望大家指正：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
int n;
scanf("%d",&amp;n);
printf("%ld",Fibonacci(n));
return 0;
}
int Fibonacci(int n)
{
if (n == 1 || n == 2)
{
return n;
}
int first = 1;
int second = 1;
int third = 2;
while (n &gt; 2)
{
first = second;
second = third;
third = first + second;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b265a8505855aa85e8b62b2090ffa8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65a9160493bb0e54c3286b12640a6bb/" rel="bookmark">
			VS2019&#43;OpenCV&#43;Qt5.15.2安装及工程配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、下载链接
1.1 VS2019下载安装
1.2 OpenCV下载安装
1.3 Qt5.15下载安装
二、工程环境配置
2.1 OpenCV环境配置
2.1.1 环境变量配置
2.1.2 工程属性表配置
2.1.3 重启vs测试
2.2 Qt环境配置
2.2.1 Qt Creator设置
2.2.2 VS2019配置
2.2.3 创建Qt项目
2.2.4 UI 设计配置
一、下载链接 1.1 VS2019下载安装 该文件仅 1.39 MB，是 VS 2019 Community 简体中文版的一个安装引导程序，启动后勾选需要的组建即可进行在线下载安装。
链接：https://pan.baidu.com/s/111f1yZ5bbVK6gca9NqhIWw?pwd=2019 提取码：2019
选择C++桌面开发，点击安装，等待安装完成。
安装好自动弹出工程创建窗口。
1.2 OpenCV下载安装 进入OpenCV官网，点击release。
点击Windows，等待下载完成。
下载后直接解压到要安装的目录。
1.3 Qt5.15下载安装 Qt5.15需要在线安装，在线安装下载链接Index of /qt/official_releases/ (tencent.com)，选择online_installers。
打开后，需要输入账号，可以直接注册。
同意
都可
选择安装路径。
选择安装组件，前四个必须，后面的可以按需要勾选。
勾选
开始下载安装。
安装完成。
二、工程环境配置 2.1 OpenCV环境配置 2.1.1 环境变量配置 此电脑-》属性 高级系统设置-》环境变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f65a9160493bb0e54c3286b12640a6bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3976adfd940af8a7b927d36e3ab75a/" rel="bookmark">
			Blob 转json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Blob 转json 提示：Blob是二进制文件流, 常用于文件上传时
例如：文件上传流如果后端抛出的错误也会变成blob无法编译
getQuaDownload(this.applyId,this.id).then(result=&gt;{ if(result.type=='application/json'){ const reader = new FileReader() reader.onload = function () { const { msg } = JSON.parse(reader.result)//此处的msg就是后端返回的msg内容 alert(msg) } reader.readAsText(result) }else{ let url = window.URL.createObjectURL(result); this.url=url; } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923adddd9d10877123382b11f8fc6a0a/" rel="bookmark">
			如何使用MyBatis进行数据存储的加密、解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：在大部分的系统中，出于用户的隐私安全考虑，都会对数据库内容进行加密，那么在编写业务代码逻辑时加密也不太现实。于是通用的加解密插件就应运而生，本文将采用mybatis的拦截器作为基础进行实现。
思路：我们可以通过mybatis的拦截器进行参数的加密和解密
Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) // 拦截执行方法ParameterHandler (getParameterObject, setParameters) // 拦截参数处理器ResultSetHandler (handleResultSets, handleOutputParameters) // 拦截结果集处理器StatementHandler (prepare, parameterize, batch, update, query) // 拦截sql构建处理器 两个注解，一个用于实体类（SensitiveData），一个用于实体类的字段（SensitiveField）重写mysql的拦截器Interceptor，对数据进行加密和解密 加密：（拦截参数处理器） @Intercepts({@Signature(type = ParameterHandler.class, method = "setParameters", args = PreparedStatement.class)}) public Object intercept(Invocation invocation) throws Throwable { //@Signature 指定了 type= parameterHandler 后，这里的 invocation.getTarget() 便是parameterHandler //若指定ResultSetHandler ，这里则能强转为ResultSetHandler ParameterHandler parameterHandler = (ParameterHandler) invocation.getTarget(); log.info("============parameterHandler ==={}", parameterHandler); // 获取参数对像，即 mapper 中 paramsType 的实例 Field parameterField = parameterHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/923adddd9d10877123382b11f8fc6a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35e22da50e378a637278e29be4e049f/" rel="bookmark">
			asp.net 数据绑定控件--表格绑定控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据绑定 Web 服务器控件是指可绑定到数据源控件，以实现在 Web 应用程序中轻松显示和修改数据的控件。数据绑定 Web 服务器控件是将其他 ASP.NET Web 控件（例如 Label 和 TextBox 控件）组合到单个布局中的复合控件。
例如，诸如 DetailsView 控件等数据绑定控件可绑定到一个结果集，例如，包含每个雇员的姓名、地址、职务等信息的雇员表。在 DetailsView 控件中，可以将 Label 控件绑定到单个数据值（如名称或地址字段），以便在页面中创建数据布局。
使用数据绑定控件，您不仅能够将控件绑定到一个数据结果集，还能够使用模板自定义控件的布局。它们还提供用于处理和取消事件的方便模型。
DetailsView 控件 – DetailsView 控件一次呈现一条表格形式的记录，并提供翻阅多条记录以及插入、更新和删除记录的功能。FormView 控件 – FormView 控件与 DetailsView 控件类似，它一次呈现数据源中的一条记录，并提供翻阅多条记录以及插入、更新和删除记录的功能。
不过，FormView 控件与 DetailsView 控件之间的差别在于：DetailsView 控件使用基于表的布局，
在这种布局中，数据记录的每个字段都显示为控件中的一行。Repeater 控件 – Repeater 控件使用数据源返回的一组记录呈现只读列表。DataList 控件 – DataList 控件以表的形式呈现数据，通过该控件，您可以使用不同的布局来显示数据记录，
例如，将数据记录排成列或行的形式。
DataList 控件与 Repeater 控件的不同之处在于：DataList 控件将项显式放在 HTML 表中，而 Repeater 控件则不然。ListView 控件 – ListView 控件可以以您使用模板定义的格式来显示来自数据源的数据。
该模板包含有用于设置数据布局的格式、控件和绑定表达式。
ListView 控件对于重复结构中的数据很有用，它类似于 DataList 和 Repeater 控件。
但是，与 DataList 和 Repeater 控件不同的是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35e22da50e378a637278e29be4e049f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35f22348e7e923d0b0a79a80377df82/" rel="bookmark">
			K8S安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S安装 一、安装Docker二、添加Docker镜像加速三、安装 kubeadm、kubelet 和 kubectl四、禁用swap分区五、初始化主节点六、启动集群七、子节点加入集群八、查看集群 一、安装Docker # 安装yum-utils包（提供yum-config-manager 实用程序）并设置稳定存储库 sudo yum install -y yum-utils sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 安装Docker sudo yum install --allowerasing docker-ce docker-ce-cli containerd.io # 启动Docker sudo systemctl start docker # 允许开机启动Docker sudo systemctl enable docker 二、添加Docker镜像加速 # /etc/docker创建daemon.json并添加 { "registry-mirrors":[ "https://f1z25q5p.mirror.aliyuncs.com", "https://hub-mirror.c.163.com", "https://reg-mirror.qiniu.com", "https://docker.mirrors.ustc.edu.cn" ], "exec-opts": ["native.cgroupdriver=systemd"] } # 控制台执行 sudo systemctl daemon-reload sudo systemctl restart docker 三、安装 kubeadm、kubelet 和 kubectl cat &lt;&lt;EOF | sudo tee /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35f22348e7e923d0b0a79a80377df82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f248e35c5423502d3b59b0fd6028d9/" rel="bookmark">
			JavaScript-XHR-深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript-XHR-深入理解 1. XHR(Asynchronous JavaScript And XML)初始1.1. xhr request demo1.2. status of XHRHttpRequest1.3. send synchronous request by xhr1.4. onload监听数据加载完成1.5. http status code1.6. get/post request with josn/form/urlcoded1.7. encapsulate an ajax function to send requests1.8. encapsulate an ajax function to send requests with Promise 2. Fetch2.1. fetch demo 1. XHR(Asynchronous JavaScript And XML)初始 1.1. xhr request demo 第一步：创建网络请求的AJAX 对象（使用 XMLHttpRequest第二步：监听XMLHttpRequest 对象状态的变化，或者监听 onload 事件（请求完成时触发）；第三步：配置网络请求（通过open 方法）；第四步：发送send 网络请求； &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f248e35c5423502d3b59b0fd6028d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52bd4e0767ab4e670490ab1e298ce2af/" rel="bookmark">
			idea生成wsdl客户端文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.idea安装插件 Jakarta EE: Web Services ​(JAX-WS)​
2.新建java maven项目，pom文件加入相关依赖文件
&lt;dependency&gt; &lt;groupId&gt;org.apache.axis&lt;/groupId&gt; &lt;artifactId&gt;axis&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-discovery&lt;/groupId&gt; &lt;artifactId&gt;commons-discovery&lt;/artifactId&gt; &lt;version&gt;0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml&lt;/groupId&gt; &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt; &lt;artifactId&gt;saaj-api&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;wsdl4j&lt;/groupId&gt; &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt; &lt;version&gt;1.6.3&lt;/version&gt; &lt;/dependency&gt; 选择生成代码的文件，点击Tools-&gt;XML Webservice and WSDL-&gt;Generate Java Code
4.填写wsdl访问路径及生成文件的包名，点击ok生成相关文件
5.编写代码进行调用
URL endpoint = new URL("http://ip:端口/xxxx"); WSExportMaterialFacadeSrvProxy materialFacadeSrvProxy = new WSExportMaterialFacadeSrvProxyServiceLocator().getWSExportMaterialFacade(endpoint); Object[] matetialData = materialFacadeSrvProxy.exportMatetialData(0,1000); System.out.println(matetialData); 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/101/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>