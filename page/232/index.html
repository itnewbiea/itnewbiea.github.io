<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdaad498aa0b6824bc79c771529f5ddf/" rel="bookmark">
			eslint-disable-next-line
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webstrom启动项目报eslint-disable-next-line to ignore the next line错误 项目一直报这个错误，心里一直不爽，我知道这个是es6对语法过多检查的但是以前尝试去解决时候，就是不知道该怎么配置，今天启动又一次触发了我对这个提示不爽的神经，然后尝试去解决一下。
详细问题 在项目规则配置文件里面加 “indent”: [2, 4], 重启项目才会生效
Use /* eslint-disable */ to ignore all warnings in a file.
Module Warning (from ./node_modules/_eslint-loader@2.2.1@eslint-loader/index.js): error: Expected indentation of 4 spaces but found 6 (indent) at src\router\index.js:16:1: 14 | component: () =&gt; import(/* webpackChunkName: "demo" */ '../views/Demo.vue') 15 | }, &gt; 16 | { | ^ 17 | path: '/', 18 | name: 'demo', 19 | component: () =&gt; import(/* webpackChunkName: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdaad498aa0b6824bc79c771529f5ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c1ef8c6e4758fa02c1923f55bb1dde/" rel="bookmark">
			基于OpenCV4.1.0实现静态图片人脸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：今天花了一天的时间完成了静态图片中的人脸检测，这是对计算机视觉的第一次直观体验，颇有成就感。这篇文章详细的解释了源程序每一行语句的作用，主要还是理清自己大脑的思路。话不多说，直接开撸！ 源代码 注：本文所用开发环境为VS2019 Community + OpenCV4.1.0，需提前配置好环境，如需帮助，请关注公众号【极客熊猫】，看我的第一篇推文。
//FaceRec.cpp #include&lt;opencv2/opencv.hpp&gt; //#include&lt;opencv2/objdetect/objdetect.hpp&gt; //#include&lt;opencv2/highgui/highgui.hpp&gt; //#include&lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2\imgproc\types_c.h&gt; using namespace std; using namespace cv; CascadeClassifier faceCascade; //人脸检测的类 int main() { faceCascade.load("D:/openCV/opencv/sources/data/haarcascades/haarcascade_frontalface_alt2.xml"); //加载分类器，注意文件路径 Mat img = imread("3ming.jpg"); //图片放在与FaceRec.cpp同级目录中 Mat imgGray; vector&lt;Rect&gt; faces; if (img.empty()) { return 1; } if (img.channels() == 3) { cvtColor(img, imgGray, CV_RGB2GRAY); } else { imgGray = img; } faceCascade.detectMultiScale(imgGray, faces, 1.2, 6, 0, Size(0, 0)); //检测人脸 if (faces.size() &gt; 0) { for (int i = 0; i &lt; faces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c1ef8c6e4758fa02c1923f55bb1dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46555835af32e708bb19ce89c041f284/" rel="bookmark">
			c&#43;&#43; 线程间通信方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 线程同步和线程互斥线程间通信方式信号量、条件变量、互斥量进程、线程、协程多进程和多线程 线程同步和线程互斥 互斥 某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的，线程间不需要知道彼此的存在。
同步 在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问，线程间知道彼此的存在。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
线程间通信方式 两个进程间的两个线程通信，相当于进程间通信：
信号量, socket网络连接, 共享内存 ,管道,共享文件一个进程中的两个线程间通信方式：
1.互斥锁
mutex;
lock_guard (在构造函数里加锁，在析构函数里解锁）
unique_lock 自动加锁、解锁
atomic 基本类型的原子操作
参考链接：
std::unique_lock与std::lock_guard区别
C++11 std::unique_lock与std::lock_guard区别及多线程应用实例
C11:std::unique_lock和std::lock_guard的区别
2.条件变量condition_variable
关于互斥锁和条件变量：
互斥量可以保护共享数据的修改，如果线程正在等待共享数据的某个条件出现，仅用互斥量的话就需要反复对互斥对象锁定解锁，以检查值的变化，这样将频繁查询的效率非常低。
条件变量可以让等待共享数据条件的线程进入休眠，并在条件达成时唤醒等待线程，提供一种更高效的线程同步方式。条件变量一般和互斥锁同时使用，提供一种更高效的线程同步方式。
3.信号量
4.读写锁shared_lock。 信号量、条件变量、互斥量 1.互斥锁是为上锁而优化的；条件变量是为等待而优化的； 信号量既可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性。
2.互斥锁，条件变量都只用于同一个进程的各线程间，而信号量可用于不同进程间的同步。当信号量用于进程间同步时，要求信号量建立在共享内存区。
3.读写锁与互斥量类似，不过读写锁允许更高的并行性。读写锁也叫做共享-独占锁，当读写锁以读模式锁住时，它是以共享模式锁住的；当他以写模式锁住时，它是以独占模式锁住的。
进程、线程、协程 1.进程有自己独立的堆和栈，都不共享，是操作系统调度的基本单位
2.线程有自己独立的栈和共享的堆，是cpu调度的基本单位
3.协程有自己独立的栈和共享的堆，由程序员在代码里显示调度。
协程的优点：
没有线程切换的开销，执行销量高；只有一个线程，共享资源不加锁。 多进程和多线程 需要频繁创建销毁的优先用线程。
web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。需要进行大量计算的优先使用线程
所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。比如：图像处理、算法处理强相关的处理用线程，弱相关的处理用进程。
一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。可能扩展到多机分布的用进程，多核分布的用线程。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60b77a5c4f9489cff99ec18f1813f3b/" rel="bookmark">
			HIVE 大数据实战项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目需求
二、数据介绍
三、创建表结构
四、数据清洗
五、数据加载
六、业务数据分析
七、原始数据
一、项目需求 1.统计视频观看数 Top10
2.统计视频类别热度Top10
3.统计出视频观看数最高的20个视频的所属类别以及类别包含这Top20视频的个数
4.统计视频观看数Top50所关联视频的所属类别的热度排名
5.统计每个类别中的视频热度Top10，以 Music为例
6.统计每个类别中视频流量 Top10 ，以 Music为例
7.统计上传视频最多的用户Top10以及他们上传的观看次数在前20的视频
8.统计每个类别视频观看数Top10（分组取topN）
二、数据介绍 1.视频数据表：
2.用户表：
三、创建表结构 1.视频表：
create table youtube_ori( videoId string, uploader string, age int, category array&lt; string&gt;, length int, views int, rate float, ratings int, comments int, relatedId array&lt; string&gt;) row format delimited fields terminated by "\t" collection items terminated by "&amp;" ; create table youtube_orc( videoId string, uploader string, age int, category array&lt; string&gt;, length int, views int, rate float, ratings int, comments int, relatedId array&lt; string&gt;) clustered by (uploader) into 8 buckets row format delimited fields terminated by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60b77a5c4f9489cff99ec18f1813f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd640d432dca8b5738151143dbfd82b2/" rel="bookmark">
			Spring--Resource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常程序开发中，处理外部资源是很繁琐的事情，我们可能需要处理URL资源、File资源资源、ClassPath相关资源、服务器相关资源（JBoss AS 5.x上的VFS资源）等等很多资源。因此处理这些资源需要使用不同的接口，这就增加了我们系统的复杂性；而且处理这些资源步骤都是类似的（打开资源、读取资源、关闭资源），因此如果能抽象出一个统一的接口来对这些底层资源进行统一访问，是不是很方便，而且使我们系统更加简洁，都是对不同的底层资源使用同一个接口进行访问。
Spring 提供一个Resource接口来统一这些底层资源一致的访问，而且提供了一些便利的接口，从而能提供我们的生产力。
类继承图 类定义 InputStreamSource public interface InputStreamSource { InputStream getInputStream() throws IOException; } getInputStream：定位并打开资源，返回资源对应的输入流。每次调用都会返回新的输入流，调用者在使用完毕后必须关闭该资源。 Resource public interface Resource extends InputStreamSource { boolean exists(); boolean isReadable(); boolean isOpen(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription(); } UrlResource 代表URL资源，用于简化URL资源访问，是对java.net.URL的包装。在java中，将不同来源的资源抽象成URL，通过注册不同的handler来处理不同来源的资源的读取逻辑。一般不同类型使用不同的前缀。
isOpen永远返回false，表示可多次读取资源。
UrlResource应该提供标准的协议前缀，一般支持如下资源访问：
http：通过标准的http协议访问web资源，如new UrlResource(“http://地址”)；ftp：通过ftp协议访问资源，如new UrlResource(“ftp://地址”)；file：通过file协议访问本地文件系统资源，如new UrlResource(“file:d:/test.txt”) 但是UrlResource无法解决相对classpath路径或servletContext的处理方法，因此需要其他的Resource实现类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd640d432dca8b5738151143dbfd82b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1405053dfb287784d1c94c6d5875a903/" rel="bookmark">
			JFinal的validator详解和防止表单重复提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JFinal的架构中没有专门的Validator，它的validator就是Interceptor。完全可以把它当成一个普通的Interceptor使用。
例如在save方法上添加@Before({ Tx.class, SkuValidator.class })，表示它将执行Tx、SkuValidator中的public void intercept(Invocation inv) 方法，该方法是Interceptor的接口方法。Validator是抽象类，实现了Interceptor，定义了protected abstract void validate(Controller c);和protected abstract void handleError(Controller c);这两个方法就是我们继承Validator之后需要实现的方法。
Validator的intercept方法的实现如下，这是一个典型的模板方法模式的应用。
final public void intercept(Invocation invocation) {
Validator validator = null;
try {validator = getClass().newInstance();}
catch (Exception e) {throw new RuntimeException(e);}
validator.controller = invocation.getController();
validator.invocation = invocation;
try {validator.validate(validator.controller);} catch (ValidateException e) {/* should not be throw */}// short circuit validate need this
if (validator.invalid)
validator.handleError(validator.controller);
else
invocation.invoke();
}
Validator类是抽象类，不可能有自己的实例，validator = getClass().newInstance();这句话就可以实例化子类的一个实例，然后给validator的私有属性赋值，再调用其validate方法，这里利用了多态，在自己的validate方法中实现你的验证逻辑，这个方法的参数传入Controller，你就可以调用一切Controller的方法，比如获取参数等。如果验证有错，调用addError，该方法中首先设置invalid为true，然后将错误信息设置到controller中。最后如果设置了shortCircuit，将直接抛出异常，validator.validate方法如果检测到这个异常，然后什么也不做，以后的也就不验证了，所以短路验证只需要设置该shortcircuit为真即可。【通过异常巧妙地实现短路验证】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1405053dfb287784d1c94c6d5875a903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe4dfbc42f04417c1aec865ab7a1f6d/" rel="bookmark">
			一个通用的Json解析框架接口设计（二）- 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://gitee.com/xxssyyyyssxx/Json-fastjson
https://gitee.com/xxssyyyyssxx/Json-orgJson
https://gitee.com/xxssyyyyssxx/Json-Gson
https://gitee.com/xxssyyyyssxx/Json-Jackson
https://gitee.com/xxssyyyyssxx/Json-Jsonlib
后续打算实现一些高级特性，比如FastJson、Gson的注解等
fastjson实现 package cn.zytx.common.json.impl; import cn.zytx.common.json.Json; import cn.zytx.common.json.JsonArray; import cn.zytx.common.json.JsonObject; import com.alibaba.fastjson.JSON; import java.math.BigDecimal; import java.math.BigInteger; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; /** * @author xiongshiyan at 2018/6/10 */ public class JSONObject extends BaseJson&lt;JSONObject&gt; implements JsonObject { private com.alibaba.fastjson.JSONObject jsonObject; public JSONObject(com.alibaba.fastjson.JSONObject jsonObject){ this.jsonObject = jsonObject; } public JSONObject(Map&lt;String , Object&gt; map){ this.jsonObject = new com.alibaba.fastjson.JSONObject(map); } public JSONObject(){ this.jsonObject = new com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe4dfbc42f04417c1aec865ab7a1f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6e4c5900055d760ada93199a53b83d/" rel="bookmark">
			对接支付宝遇到的坑sign check fail: check Sign and Data Fail
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成功解决支付宝验证失败sign check fail: check Sign and Data Fail
解决方法：
在使用支付宝的沙漏环境开发测试支付功能的时候，报上面错误。
问题出现在一个参数上：alipay_public_key 支付宝公钥
接口中alipay_public_key这个参数填哪里的公钥呢？
在配置沙箱应用的时候，要配置RSA2(SHA256)密钥(推荐)，配置好应用的公钥后，会生成一个支付宝公钥，点击“查看应用公钥 | 查看支付宝公钥”中的查看支付宝公钥,alipay_public_key就是这个支付宝公钥。
转载于:https://www.cnblogs.com/sjzxs/p/11256077.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b992810357b3d5bc6e5f3a74fbf1aa/" rel="bookmark">
			保存layui表格里input标签的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		保存layui表格里input标签的数据 上次写到了在layui表格里面加入input标签, 并且设置input标签的类型为时间格式，使数据顺序整齐排列在表格里，并且可以在layui表格里同时对多条数据进行编辑。
那么，现在，问题又来了：如何同时保存在layui表格里面编辑的多条数据呢？
在创建table标签时，我给它套了一个form表单，layui表格里面的input标签也按照form表单里面的input标签的格式设置了对应的name。所以，layui表格里面的数据就如同form表单里面的数据一样，可以被序列化出来。
从上图，我们可以看到，被序列化出来的21条input标签的数据，其中每一条数据都有其他几条name是相同的数据，但是，细心观察，你会发现，这些数据都是按顺序排列的，并且如同你在layui表格排列数据的顺序一样。（仅限添加了input标签的）
如果将数据就这样通过“post”提交到控制器，控制器只会读取到表格的第一行数据，无法同时读取多条数据。
既然控制器无法同时读取多条数据，我就想到在把数据在通过post提交之前先处理一下，把layui表格的数据一行一行地提交出来。
前面也提到，被序列化出来的数据都是虽然很多name相同，但数据排列规律。仔细观察上图中的21条name，你可以发现，这些数据每7条为一组，即相当于每7条为layui表格的一行数据。那么，我就想到，是不是可以把数据分开提交，按照上图数据排列的规律，一次获取7条提交保存。
先通过序列化方法将layui表格的数据全都获取到，然后判断是否有数据，没有就弹出提示；然后分别为每一个name都声明一个字段接收数据，再声明一个字段记录提交数据的次数。然后通过for循环将序列化出来的数据一行一行地循环获取。这里我用到了一个正则表达式，这个正则的意思是只可以输入0和非0开头的整数。上面说过数据每7条为layui表格的一行数据，所以 一次要获取7条，而序列化出来的数组的长度也是7的倍数，所以，在for循环里面，将代表条数的i除以7，“/”相当于除号。用正则表达式筛选i除以7的结果，当i除以7为整数时，就进入获取数据，通过上图可以看到，值在value里面，所以通过“value”获取，一次获取7个数据，通过post提交到数据库保存。“trues++”记录提交的次数，然后根据次数对layui表格的每一行数据进行提示，最后刷新表格。
//批量修改时间 Regex=/^(0|[1-9][0-9]*)$/ function save() { var forDate = $("#formUpdateWork").serializeArray(); var formDate; if (forDate.length &gt; 0) { var trues=''; var WorkDetailID = ''; var PlanStartDate=''; var PlanEndDate=''; var ActualStartDate=''; var ActualEndDate=''; var WorkID=''; var ProgressPlanID=''; for (var i = 0; i &lt; forDate.length; i++) { var text=i/7; if(!Regex.test(text)){ WorkDetailID = ''; PlanStartDate=''; PlanEndDate=''; ActualStartDate=''; ActualEndDate=''; WorkID=''; ProgressPlanID=''; } else { WorkDetailID = forDate[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b992810357b3d5bc6e5f3a74fbf1aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad76a3209f6d6ce86aaa18629c2baf7/" rel="bookmark">
			android 项目迁移到 AndroidX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Android Studio 迁移现有项目 借助 Android Studio 3.2 及更高版本，您可以通过从菜单栏中依次选择 Refactor &gt; Migrate to AndroidX，快速迁移现有项目以使用 AndroidX。
如果您有任何尚未迁移至 AndroidX 命名空间的 Maven 依赖项，那么当您在 gradle.properties 文件中将以下两个标记设置为 true 时，Android Studio 编译系统也会为您迁移这些依赖项：
android.useAndroidX=true android.enableJetifier=true 要迁移未使用任何第三方库但带有需要转换的依赖项的现有项目，可以将 android.useAndroidX 标记设置为 true，并将 android.enableJetifier 标记设置为 false。
详情参考：https://developer.android.google.cn/jetpack/androidx/migrate#migrate
android studio 3.4.2 gradle依赖名字发生了变化 详情参考 https://developer.android.google.cn/studio/build/dependencies
如果你觉得对你有帮助，可以对博主表示感谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc3d7c4175f5f53c5e8269ba8c7603d/" rel="bookmark">
			数据分析中应该了解的几种常用预测方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文“预测”的含义在“英语”情境下则有两种含义：
evaluate，“估算”，前文归因的方法中，是从因变量Y发现自变量X，也就是Y--&gt;X，“估算”则是“归因”的逆操作——需要从已知的X来推导未知的Y，即X--&gt;Y;
forecast，“预测”，基于“时间序列”来预估未来的数据，比如股票走势、业务发展趋势、交易量预估等等；
evaluate &amp; forecast
关于 evaluate
“估算”常见有两种情况：
基于关联原则来类推，简称“类推法”，也就是先归类，然后推导。比如格子衫、发量少、戴眼镜、男性、程序员这几个特征是高度关联的，知道“格子衫”和“发量少”就能推断出此人职业很可能是“程序员”；
基于目标数据和已知数据存在“函数关系”，简称“函数法”或者“公式法”，即Y=f(X)，基于函数规则就能计算得到目标数据Y。比如评估某次产品运营活动对交易产生的影响量(Y)，那么对应需要考虑的X可能包含活动覆盖的人群属性、人群数量、活动方式、优惠力度等；
类推法
类推法可以分为两种：
相似个体类推，相似的个体通常其属性(特征)也具有相似性，如果要推算某个体的某属性，那么找到具有相似性的个体的属性作为预估值即可。
归属群体类推，人以类聚，物以群分，每个类群的整体属性和个体属性差异不会太大(只要不是极端个例)，也可以理解为正态分布的群体的某属性的均值可以作为某个未知个体属性的替代值。
相似个体类推
如上图所示，假如现在我们要想估算主体B的属性③的数值(橙色标记目标数据)，那么我们可以找到和B类似(AB在属性②、④上相似)且同时具有属性③的主体A，如果主体A的属性③是已知的，那么该数值可以当做主体B属性③的估算值，如果可以匹配的已知相似属性更多，得到的值一般更精确。
e.g. 要推算京东在微信端交易订单量占整体交易量的占比，可以借鉴唯品会的数据。首先唯品会和京东的业务模式具有较高的相似性——都是电商平台(虽然主要品类结构不一样)，主要交易端都是App\PC\Weixin这3个，唯品会和京东都在微信上都有“钱包入口”，整体上覆盖的人群结构也差不多——现在知道了唯品会微信上交易量的占比(数据已经相对稳定)，那么该数值可以作为预估京东数据的参考值基准。
注：因为京东在“发现”页还有入口，而且唯品会和京东的交易量级以及品类结构上存在差异，所以数据还需要进一步调整。
归属群体类推
如上图右图，基于背景知识，我们知道要推算的个体X归属于某个群体，那么可以用该群体的属性来推断X的对应属性。
e.g. 我们到野外偶遇一只不知所名的动物(未知的X)，发现此动物尖牙利爪长尾巴(已知属性)，这和我们平时见到的猫科动物(归属的群体)特征很匹配，我们知道猫科动物大多数是吃肉的，那么可以推断该动物也很可能不是吃素的(肉食动物)。
确定相似性可以参考的特征：
空间属性，比如所处地理位置相同，具有类似的结构或者模式，体量差不多，或者归属的群体是一致的等等；
时间属性，所处的时代相同，主体的生命周期差不多等；
函数法
目标数据和已知数据存在“函数关系”，即Y=f(X)，基于函数规则就能计算得到目标数据Y。
常见的两种函数或者公式如下：
连乘公式，常见于存在转化率或集合包含关系的情况
加权公式，常见于存在多个成分或分类的情况
使用函数法需要明确目标数据的函数表达式，以及需要知道函数表达式中各变量的数值。
函数法中，因变量Y和自变量X的具有高相关性。
使用函数法进行估算的案例，可以参考前文从一道面试题谈数据推算方法。
在该案例中，估算目标用户群数量时用的就是连乘公式。
该城市总人口1000W，设符合用车条件的人群(16-60)占比为60%(这个数据也可以到国家人口普查数据上找)；设上述人群中有互联网产品使用经验的比例为60%(可以查下中国互联网普及率)；设有短距离出行需求的人数比例为15%(大多数时候选择的交通工具是地铁、公交、自驾)；设该公司在该城市的市场份额为30%(假设要和ofo、摩拜3分天下，这里的30%是假设只有3家投放单车时的值)，基于以上假设可以得到目标用户数为：1000W*60%*60%*15%*30% ≈ 16W人
AhongPlus，公众号：数据分析007从一道面试题谈数据推算方法 e.g. 假设现在需要预估一次运营活动带来的交易量，那么可以先对交易量“细分”，看看活动覆盖哪些人群、覆盖哪些端口、不同人群或端口的交易转化率(可以参考历史数据或业务经验)等，把每个细分人群细分端口的交易计算出来，再进行加总即可。
关于 forecast
基于时间序列的趋势预测，是基于历史数据预测未来发生的事件。
e.g. 进行年度KPI预测的时候，可以拟合历年的实际交易数据——一般业务过了成熟期，就能看到比较明显的S曲线(sigmoid curve)——基于拟合的曲线就能大致预测出下一年的交易量了。这个预测值可以作为基准，还要考虑业务上新的变化对数据进行调整，比如产品功能改变、人群定位变化等、渠道入口发生改变等。
e.g. 交易预估流程(先用线性回归预测2018年度的总交易，然后拆分到季度)
注：此处交易是有明显的季节性变化趋势的。
注：该案例也可以Holt-Winters法来操作，把Residual的部分区分出来。
时间序列可以分解(decomposition)为4部分：
参考：https://en.wikipedia.org/wiki/Decomposition_of_time_series
长期趋势(Trend)，比如持续的增长或者降低，这种趋势可能是线性也可能是非线性的(比如S型曲线)；
季节变化(Seasonal)，通常是一年时间内的周期波动(可能季度、月度或者周等不同时间颗粒度)，季节变化通常是因为受到人们活动的周期性的影响而出现的。比如：①人行为上的周期性，e.g.一天的作息、一年4季的购衣需求、不同年龄阶段的行为模式等；②周期性的社会活动，e.g.节假日、定期行业集会等；③商业业务的周期性，e.g.唯品会的早10晚8上新、公众号通常在上班前或者下班后发布消息等；
发展周期(Cycle)，不同于季节变化，发展周期的时间跨度更长(通常是两年以上)，而且和事物的生命周期有关(比如产品的生命周期等)；
随机噪声(Reminder，或Residual)，不能归于以上3类的部分被称为不规则剩余(Irregular Remainder)，可以看做是时间序列数据中的随机成分；
举个例子，原始时间序列如下图所示：
数据源：https://raw.githubusercontent.com/jbrownlee/Datasets/master/airline-passengers.csv
可以分解为3部分(此处不考虑“发展周期”因素)：
注：此处采用Holt-Winters’ additive method来分解，调用函数为statsmodels.tsa.seasonal.seasonal_decompose
时间序列预测的流程可以参考下图
来源：http://people.duke.edu/~rnau/411fcst.htm
对于数据转化和预测方法的选择可以参考
http://people.duke.edu/~rnau/whatuse.htm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc3d7c4175f5f53c5e8269ba8c7603d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1cf866ce89a6757db2b86f75cfc7c6/" rel="bookmark">
			目录项dirent详解及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dirent结构体
struct dirent { ino_t	d_ino; /* inode number*/ off_t d_off; /* offset to the next dirent */ unsigned short d_reclen; /* length of this record 本条记录的长度*/ unsigned char d_type; /* type of file; not supported by all file system types */ char d_name[256];	/* filename */ }; dirent.h中的常用的三个函数
#include &lt;dirent.h&gt; DIR *opendir(const char *dirname);	//根据路径，打开一个目录文件，DIR是一个结构体，类似于FILE，不需要去深究其内部，只需要得到它就行 DIR *fdopendir(int fd);	//这个是根据文件描述符fd来打开一个目录文件 struct dirent *readdir(DIR *dirp);	//从目录文件中获取所有dirent，调用一次只可以获取到一个dirent结构体，多次获取，直到该函数返回NULL时表示已经获取完了 int closedir(DIR *dirp);	//用完之后关闭 示例代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb1cf866ce89a6757db2b86f75cfc7c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/944853c10b94c245b12a1980b01eb780/" rel="bookmark">
			利用 GitHub Pages 快速搭建个人博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/e68fba58f75c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58937beb88a87c71e2899d15c7dc1aa/" rel="bookmark">
			CentOS7.5下安装部署nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装相关依赖包
安装nginx需要先将官方下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，则需要安装。
安装编译工具
yum -y install gcc gcc-c++ 安装pcre
yum -y install pcre pcre-devel 安装openssl
yum -y install openssl* 将nginx-1.6.0.tar.gz放到/usr/local/文件夹下
解压 nginx-1.6.0.tar.gz得到nginx-1.6.0文件夹
tar -zxf nginx-1.6.0.tar.gz cd nginx-1.6.0 ./configure --prefix=/usr/local/nginx --group=nginx --with-http_stub_status_module &amp;&amp; make &amp;&amp; make install 执行完成后会自动生成nginx文件夹
二.环境配置 开放防火墙
firewall-cmd --add-port=80/tcp --permanent firewall-cmd --reload 三.启动nginx
/usr/local/nginx/sbin/nginx 如果出现：bash: nginx: command not found..
进入 /etc/profile 文件 进行编辑
加上：
PATH=$PATH:/usr/local/nginx/sbin
export PATH
export JAVA_HOME=/usr/java/jdk1.8.0_192 export CLASSPATH=$JAVA_HOME/lib/ export PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH unset i unset -f pathmunge PATH=$PATH:/usr/local/nginx/sbin export PATH 执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58937beb88a87c71e2899d15c7dc1aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1052674e337d2fbb6beaf38ad2f05f/" rel="bookmark">
			Layer Normalization原理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 前面介绍了Batch Normalization的原理，我们知道，BN层在CNN中可以加速模型的训练，并防止模型过拟合和梯度消失。但是，如果将BN层直接应用在RNN中可不可行呢，原则上也是可以的，但是会出现一些问题，因为我们知道Batch Normalization是基于mini batch进行标准化，在文本中，不同的样本其长度往往是不一样的，因此，如果在每一个时间步也采用Batch Normalization时，则在不同的时间步其规范化会强行对每个文本都执行，因此，这是不大合理的，另外，在测试时，如果一个测试文本比训练时的文本长度长时，此时Batch Normalization也会出现问题。因此，在RNN中，我们一般比较少使用Batch Normalization，但是我们会使用一种非常类似的做法，即Layer Normalization，本文将具体介绍一下该方法的原理。
论文地址：《Layer Normalization》 2. Layer Normalization原理介绍 Layer Normalization的思想与Batch Normalization非常类似，只是Batch Normalization是在每个神经元对一个mini batch大小的样本进行规范化，而Layer Normalization则是在每一层对单个样本的所有神经元节点进行规范化。
对于RNN的每个时间步，其输入都会包含两部分，即当前的输入 x t x^{t} xt和上一个时刻的隐藏状态 h t − 1 \mathbf{h}^{t-1} ht−1，记 a t = W h h h t − 1 + W x h x t \mathbf{a}^{t}=W_{h h} h^{t-1}+W_{x h} \mathbf{x}^{t} at=Whh​ht−1+Wxh​xt，其中， W h h W_{h h} Whh​和 W x h W_{x h} Wxh​为对应的权重矩阵，则在每一个时刻，Layer Normalization对每一个样本都分别计算所有神经元的均值和标准差如下：
μ t = 1 H ∑ i = 1 H a i t \mu^{t}=\frac{1}{H} \sum_{i=1}^{H} a_{i}^{t} μt=H1​i=1∑H​ait​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c1052674e337d2fbb6beaf38ad2f05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34134d5da4a5991dd50a00488c5ac35c/" rel="bookmark">
			LiveCap: Real-time Human Performance Capture from Monocular Video
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TOG 2019 GVV
亮点：
1）实时，25Hz；对松弛的衣物也进行了重建。
2）skeleton pose estimation时，加入了face landmark；silhouette alignment时，用的是图像距离变换。
3）surface registration时，利用了texture信息；基于部件进行silhouette alignment。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5967013e058b851755d5a3a0d6a73bc1/" rel="bookmark">
			Could not generate DH keypair
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jdk1.6，调用https接口报错如下：
log4j:WARN No appenders could be found for logger (org.apache.http.client.protocol.RequestAddCookies). log4j:WARN Please initialize the log4j system properly. javax.net.ssl.SSLException: java.lang.RuntimeException: Could not generate DH keypair at com.sun.net.ssl.internal.ssl.Alerts.getSSLException(Alerts.java:190) at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1747) at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1708) at com.sun.net.ssl.internal.ssl.SSLSocketImpl.handleException(SSLSocketImpl.java:1691) at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1222) at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1199) at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:275) at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:254) at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:123) at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:318) at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363) at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219) at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195) at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86) at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108) at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106) at com.thinkive.htqh.info.Test.fun1(Test.java:133) at com.thinkive.htqh.info.Test.main(Test.java:80) Caused by: java.lang.RuntimeException: Could not generate DH keypair at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5967013e058b851755d5a3a0d6a73bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8026b184462157271f91f803a31573e8/" rel="bookmark">
			一个会“说话”的油箱盖，告诉你每一滴油的去向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【无线油位检测仪器SP1.0】
是机械指挥官旗下的一款产品
能够精准检测优油量与耗油量
集聚诸多优势
可以查看每分钟的油量变化，控制油耗不浪费
每台机械每一天、每小时的油耗都可以在曲线上一目了然，出现费油情况可以进行历史追溯
减少因操作而引起的燃油浪费，提高燃油利用率
无线油位检测仪器SP1.0
一个会“说话”的油箱盖，
告诉你每一滴油的去向
如果您对以上的产品有需求
可以通过以下方式与我们联系。
商业合作
慧材（上海）信息技术有限公司
联系人：王先生 021-61997709 邮箱：wangdanhua@leadai.org
地址：上海市松江区谷阳北路2558号9号楼1单元1301室
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c96689c0fe3ef342d4cbbae555f1823/" rel="bookmark">
			LINUX ：（面试题）三次握手、四次挥手的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、三次握手过程（每一次都携带了什么数据？ACK为什么加一？） 首先来看一下TCP的头部：
其中标志位分别为：
序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。
确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。
确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。
终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接
PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。
图解三次握手： SYN：同步序列编号(Synchronize Sequence Numbers)
文字说明： (1).第一次握手：建立连接。客户端发送连接请求报文段(SYN),然后客户端进入SYN_SEND状态，等待服务器的确认。
(2).第二次握手：服务器收到请求。服务器收到SYN请求报文段之后，去要对这个SYN报文段进行确认，同时自己还要发送SYN信息，表示同意连接。服务器将上述信息都放在同一个报文段中(SYN+ACK)报文段,一并发送给客户端。此时，客户端进入SYN_RECV状态。【listen之后（内核的网络模块完成），accept之前（从内核维护的已完成连接的队列中获取一个客户端）】
(3).第三次握手：客户端收到服务器发来的SYN+ACK报文段。客户端向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手。
ACK加一：确认号是为了保证在整个数据发送过程中，确认之前发送的数据都已经收到，可以放心对后面数据进行发送。Ack+1可以确认下一次发送的起始位置。
二、四次挥手 图解： 文字说明： (1).第一次挥手：主机1向主机2发送FIN报文段，表示要断开连接，之后主机1进入FIN_WAIT_1的状态，表示已经没有数据要进行发送了。【主机1和主机2可以理解为主动断开方与被动断开方，客户端/服务器端都可以作为主动断开方与被动断开方】
(2).第二次挥手：主机2收到主机1发来的FIN断开连接请求后，向主机1发送一个ACK报文段，表示同意你的断开连接请求，此时主机1进入FIN_WAIT_2状态，主机2进入CLOSE_WAIT状态，开始处理未传输完的数据。
(3).第三次挥手：主机2这时候已经处理完未发送的数据，并向主机1发送FIN报文段，表示关闭连接，此时主机2进入LAST_ACK状态。
(4).第四次挥手：主机1接收到主机2的FIN关闭连接请求后，向主机2发送ACK报文段，主机1进入TIME_WAIT状态，主机2收到ACK响应报文段之后就可以关闭连接处于CLOSED状态，主机1在等待2MSL后，没有收到来自主机2的任何回应后，关闭连接。
六大标志位： SYN:同步标志位；ACK:确认标志位；PSH:传送标志位【数据传输】；FIN:结束标志位；RST:重置标志位【连接重置】；URG：紧急标志位；
2MSL含义： 任何报文段在被丢弃前允许在网络中存在的最长时间。为了更安全的断开连接，保证迟来的数据被丢弃。
TIME_WAIT状态含义(2MSL等待状态)： 保证迟来的数据能被识别并丢弃，完成可靠的中止TCP连接。
三、相关问题： （1）为什么是三次不是两次？ （2） 那个阶段容易受到攻击？ （3） 什么时候开始进行三次握手 （4）为什么连接的时候是三次握手，关闭的时候却是四次握手？ 因为当Server端收到Client端的SYN连接求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
（5）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
（6）如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
参考：https://blog.csdn.net/scuzoutao/article/details/81774100
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1df1acad8cce7859a47c1ea13510988/" rel="bookmark">
			链表的基本操作:建立，增加，删除指定位置元素，销毁（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习心得：C语言中，要掌握链表，除了基本的知识外，还要有对指针的理解在这里特别是指向结构体的指针，由于知识比较抽象，必要时可通过画图方便理解。 运行结果 源代码（每个函数都有说明参数和功能） #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct list{ struct list *next; //指针域 int number;//数据域 }; struct list *head; //功能：创建头节点 //返回值：头结点指针 struct list * setList(); //功能：头插法 //参数：头节点指针 head void in_head(struct list *head); //功能：尾插法 //参数：头节点指针 head void in_tail(struct list *head); //功能：输出链表成员 //参数：头节点指针 void out(struct list *head); //功能：指定位置插入元素 //参数：头节点 void insert(struct list *head); //功能：删除指定位置节点 //参数：头节点指针 void delete_list(struct list *head); //功能：回收内存 //参数：头节点指针 void destory(struct list *head); int main(){ struct list *head; head=setList(); //in_head(head); in_tail(head); out(head); // delete_list(head); insert(head); out(head); destory(head); return 0; } struct list * setList(){ struct list *head; head=(struct list *)malloc(sizeof(struct list )); head-&gt;next=NULL; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1df1acad8cce7859a47c1ea13510988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68434077855990adcc2c5ff1a7e998fd/" rel="bookmark">
			让ubuntu18.04开机进入命令行模式或还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置开机进入命令行模式 1、首先我们修改grub文件sudo vim /etc/default/grub
用#“”注释掉GRUB_CMDLINE_LINUX_DEFAULT="quiet"，修改为GRUB_CMDLINE_LINUX_DEFAULT="text"。
打开GRUB_TERMINAL=console。
改完之后，按Esc再 :wq保存退出； 2、然后更新grub：sudo update-grub
3、设置开机进入字符界面：
sudo systemctl set-default multi-user.target　此步骤必须做，网上有的文章都没写此步骤
4、重新启动ubuntu：
sudo reboot
重启完后，应该就直接进入到命令行模式了；
还原到图形界面模式 还原上述步骤1, 2步骤3，改为sudo systemctl set-default graphical.target，既默认进入图形界面重启即可 ubuntu命令行模式与图形桌面切换方法(此方法在没有做上述步骤时可用)： 1、图形桌面—&gt;命令行模式：Ctrl+Alt+F6
2、命令行模式—&gt;图形桌面：Ctrl+Alt+F7
参考：
让ubuntu16.04开机进入命令行模式 - 白茶清风 - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc13e11ac1a086d3a7d4bae216995c9e/" rel="bookmark">
			js-----用户注册页面实现，验证用户名、密码、验证码等是否符合需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是在经过断断续续学习html、css和js后，写的第一个算是比较完善，依然比较初级的小案例，用户注册界面，其中用的html以及css知识都比较少，主要是js代码中各种【验证功能】实现。
html部分：标题+form表单+table表格的运用。另外在head部分写入少量的css样式，以及部分js代码。该页面并没有连接数据库对数据进行提交处理。
下图就是完成界面展示。
用户在注册时，按照要求即可注册，分别需要填写用户名、密码、确认、邮箱、手机号、性别、爱好、籍贯、个人介绍、以及验证码、是否同意本公司协议，除了个人介绍可以不用填写外。其他都需要进行填写或则选择，只有这些都选择过后才能够点击注册按钮，否则注册按钮为不可读属性，此外验证码需要在页面加载时就进行实现，通过onload属性即可完成。如图所示：
其中如红色提示等信息提示，是在各种input、select标签后添加span标签，在标签中能够填充其他展示内容。
每当用户填写一个数据，点击其他地方时，就会触发失去焦点事件，“onblur”，这个input的属性在这个案例中应用十分重要！
每当失去焦点，就要触发onblur所代表的函数或者事件。
这些事件大多数都是验证事件！
验证事件的实现步骤为：
1.建立函数
2.获取用户输入或选择的信息
3.创建校验规则（符合条件的是特殊的，不符合条件则有各种各样的情况，因此设定条件反而会更简单些）
4.获取span对象
5.开始校验（校验情况分3中，当用户输入为空值、当用户输入符合条件、用户输入不符合条件）
6.输出校验结果
在对几个信息进行校验后，就能够发现代码充裕率比较高，因此可以进行【封装校验】，设定一个函数，传递要校验的id、相应的校验规则，输出结果进行一定的变更即可，相应id的value+“通过”或者“不通过”即可。
因此在设定span的id时，同一设定为“**Span”，比如用户名id=“uname”，则span的id=“unameSpan”。
在爱好选择中，则需要对每一个爱好的选择进行事件触发。一旦有一个爱好被选择，即可通过校验，此时就需要获得爱好的所有选项，id是唯一的，但name可以多个标签公用，此时getElementByName，之后遍历数组，如果有一个爱好被选择，则该checked的值为1，就能通过校验，失去焦点后，触发校验事件，不通过校验的提示会一直显示，直到通过校验则立即返回。
在校验验证码时，需要获得codespan的innerHTML的值，将该值和用户输入值进行比较，相同则通过。
当开始注册按钮的属性disabled为不可读，只有当用户勾选同意协议时（checked值为true），变为可读（disabled值为false），此时二者正好相反。
再点击提交按钮时，需要进行时间阻断，触发之前定义的所有校验事件，只有之前的校验事件全部通过，该submit才能够实现。οnsubmit=“return checkSub()”
&lt;html&gt; &lt;head&gt; &lt;title&gt;注册界面&lt;/title&gt; &lt;meta charset="UTF-8"/&gt; &lt;style type="text/css"&gt; body{background: url(img/a.jpg) no-repeat center 0}; font{color="darkgray"}; tr{height:60px} &lt;/style&gt; &lt;!--声明js代码域--&gt; &lt;script type="text/javascript"&gt; //常见验证码 function createCode(){ //创建随机4位数字，math.floor向下取整 var code=Math.floor(Math.random()*9000+1000); //获取元素对象 var span=document.getElementById("codeSpan"); //将数字存放到span中 span.innerHTML=code; //给span添加背景图片 } //验证用户名 function checkUname(){ //获取用户获得用户名信息 var uname=document.getElementById("uname").value; //创建校验规则,用户名2-4个 var reg=/^[\u4e00-\u9fa5]{2,4}$/ //获取span对象 var unameSpan=document.getElementById("unameSpan"); //开始交验 if(unameSpan==""||unameSpan==null){ //输入校验结果 unameSpan.innerHTML="*用户名不能为空"; unameSpan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc13e11ac1a086d3a7d4bae216995c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b881b4b1e33b822c4fc3b723cbd5e0/" rel="bookmark">
			SQL在线练习 工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：地址是：http://sqlfiddle.com/ 二：http://zh.sqlzoo.net/wiki/SELECT_basics/zh
三：http://www.w3school.com.cn/sql/
速查基础SQL命令，快速理解SQL命令的含义和使用方法。最后做一下SQL测试，看看是否建立了基本的SQL概念。
无需注册。
四：https://sqlbolt.com/
友好的界面，详细解释SQL语句的功能，并提供了可交互的在线编程环境，体会SQL的用法。
无需注册。
五： http://www.w3resource.com/sql-exercises/
题量丰富但基础，提供可交互的编程窗口，但界面不够友好。适合已经大体掌握SQL后巩固之用。
无需注册。
六：http://www.sql-ex.ru/
题量丰富且困难，出题的人考虑到了实际使用时的一些坑爹场景。适合刷题解闷，理解SQL运行的深层逻辑。网站风格古老。标准答案有时候都不能通过答题系统。
需要注册。
七：在线学习 HiveQL 的网址 https://www.tutorialspoint.com/hive/
八：https://sqlzoo.net/
支持多种数据库，右上角可以选择中文语言和数据库类型
九：https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088
廖雪峰的在线SQL练习网站
十：SQL命令练习：https://www.sqlteaching.com/#!select
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047af2c81fd48f65ced88ea7618b6251/" rel="bookmark">
			【Android系统源码修改】源码含有SmsManager的编译失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：源码中调用了android.telephony.SmsManager，编译时cannot find symbol
解决方法：在.mk中加入
LOCAL_JAVA_LIBRARIES += telephony-common
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8693f4be1c88764713ced21d045f5da/" rel="bookmark">
			算法附（一）：BST、AVL树、红黑树、B树比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/bigtree_3721/article/details/78172634 一、二叉搜索树 定义：
二叉搜索树(BST)，又称为二叉排序树，属于二叉树的一种，通过二叉树将数据组织起来，树的每个节点都包含了健值 key、数据值 data、左子节点指针、右子节点指针。其中健值 key 是最核心的部分，它的值决定了树的组织形状；数据值 data 是该节点对应的数据，有些场景可以忽略，举个例子，key 为身份证号而 data 为人名，通过身份证号找人名；左子节点指针指向左子节点；右子节点指针指向右子节点。
特点:
左右子树也分别是二叉搜索树。左子树的所有节点 key 值都小于它的根节点的 key 值。右子树的所有节点 key 值都大于他的根节点的 key 值。二叉搜索树可以为一棵空树。一般来说，树中的每个节点的 key 值都不相等，但根据需要也可以将相同的 key 值插入树中。 BST 的操作代价分析：
(1) 查找代价： 任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。
当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。
当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)/2，查找的平均时间复杂度在O(N)数量级上。
(2) 插入代价： 新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。
(3) 删除代价： 当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。
BST效率总结 : 查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。
特点：就时间复杂度来说，BST的查找与二分查找性能差不多，但是增删时BST无需移动记录，只需移动指针比顺序存储好很多;一般性能都在O（log n）。
BST退化成单支树结构，如右边顺序序列所示，此时性能和顺序存储无异。所以，使用BST树还要考虑尽可能让BST树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题,进而引出AVL。 二、AVL树 一些详细操作参考：https://baijiahao.baidu.com/s?id=1617719367838438352&amp;wfr=spider&amp;for=pc
二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。
在AVL树中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)（树高）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。
引入AVL树的目的是为了提高二叉树的搜索的效率,减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度.
定义：
AVL树，也称平衡二叉搜索树。AVL树属于二叉搜索树的一种，不同的是他通过一定机制能保证二叉搜索树的平衡，平衡的二叉搜索树的查询效率更高。
特点：
AVL树是一棵二叉搜索树。AVL树的左右子节点也是AVL树，说明可以使用一些递归操作。AVL树拥有二叉搜索树的所有基本特点。每个节点的左右子节点的高度之差的绝对值最多为1，即平衡因子为范围为[-1,1] AVL 的操作代价分析：
(1) 查找代价： AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。
(2) 插入代价： AVL必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。
(3) 删除代价：AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN).
二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。。但同时引入的问题是删除、插入需要频繁的旋转。因此，引入了红黑树。红黑树通过节点红黑两种因子控制，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率。
三、红黑树 红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构，能够做到一步旋转之内达到平衡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8693f4be1c88764713ced21d045f5da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c60497982fc532a44e23c96e27b57f/" rel="bookmark">
			adb logcat把之前的log信息都输出来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直在公司电脑调试，这些天都在自己电脑上抓log，发现
adb logcat &gt; D:\**\*.log 把几天前的log信息比如Fatal Exception也输出出来，虽然我可以从尾部开始看起，但是变得比较不方便，特别是*.log也保留了几天前报错的log。
然后用adb logcat -c之后，再用adb logcat 输出才输出当前的log。(没有清空，直接用adb logcat -v time &gt; *.log也会把前几天的报错信息的log也输出)
应该不是因为电脑端用adb logcat重定向到本地文件的问题，因为之前在公司同样装了win10的电脑上从没出现这样的情况。log已经清空不能再试，先记录一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52978a918a7104aeb89a3676cfcf9c64/" rel="bookmark">
			Java实现邮件发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现邮件发送 一、邮件服务器与传输协议 要在网络上实现邮件功能，必须要有专门的邮件服务器。这些邮件服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。
SMTP服务器地址：一般是 smtp.xxx.com，比如163邮箱是smtp.163.com，qq邮箱是smtp.qq.com。
SMTP协议
通常把处理用户smtp请求(邮件发送请求)的服务器称之为SMTP服务器(邮件发送服务器)。
POP3协议
通常把处理用户pop3请求(邮件接收请求)的服务器称之为POP3服务器(邮件接收服务器)。
二、Java发送邮件 使用到的jar包：
mail.jaractivation.jar QQ邮箱需获取相应的权限：
QQ邮箱–&gt;邮箱设置–&gt;账户–&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 开启POP3/SMTP服务，然后获取16位授权码（注意不要将授权码泄露，一个账户可以拥有多个授权码）
Java实现纯文本邮件发送
package org.westos.email; import com.sun.mail.util.MailSSLSocketFactory; import javax.mail.*; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; import java.security.GeneralSecurityException; import java.util.Properties; public class SendEamil { public static void main(String[] args) throws MessagingException, GeneralSecurityException { //创建一个配置文件并保存 Properties properties = new Properties(); properties.setProperty("mail.host","smtp.qq.com"); properties.setProperty("mail.transport.protocol","smtp"); properties.setProperty("mail.smtp.auth","true"); //QQ存在一个特性设置SSL加密 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); properties.put("mail.smtp.ssl.enable", "true"); properties.put("mail.smtp.ssl.socketFactory", sf); //创建一个session对象 Session session = Session.getDefaultInstance(properties, new Authenticator() { @Override protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52978a918a7104aeb89a3676cfcf9c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4030c8a5be0c4e8a0fd45907374ea13/" rel="bookmark">
			mysql8.0密码错误问题解决办法及修改密码方法(解压版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、mysql密码错误解决方法 1.确认sql目录下有没有data（Data）文件夹，如果有就删掉。(我的是解压版本的)
2.然后在cmd输入mysqld --initialize，等待一段时间（这段时间就是在创建data（Data）文件夹），然后就再次输入net start mysql便可，mysql服务器会启动，这个之后 重新登录时会产生一个随机密码,先关闭cmd。
3.随后以管理员身份运行 cmd,我们先找到随机密码，可以搜索.err文件（找文件目录:**mysql\bin\data\ .err 文件 ，或寻找你的安装按目录），貌似里面就这一个.err的文件,用记事本打开，直接查找password，后面就是随机密码。
参考链接：数据库密码忘记解决方法：https://blog.csdn.net/weixin_43815050/article/details/86997113
二、修改密码 1.以管理员身份打开cmd
2.进入数据库：mysql -u root -p
然后会提示输入密码,输入上面找到的密码。
3.数据库修改密码：ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c708905a96874010cc3f2d1305e42958/" rel="bookmark">
			白话空间统计三十：地统计（4）变异分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这篇文章之前，我是纠结了很久的……一旦说道函数这种东西， 而且公式推理这种东西，基本上整个就变成的天书，而白话空间统计整个系列的核心目的还是科普，既然科普，自然就要让大家都能看得懂了咯……所以大段的公式推理，我就不列了，有兴趣的同学自己百度，这里仅做简单介绍。
变异分析——地统计学的理论核心
地统计学需要研究的是区域化变量之间的空间变异结构，其理论核心就是变异函数的研究。
下面我们来看看啥是变异函数。
还是来看两个点之间的温度观测值：
从位置一，到位置二的观测值变化，看成是一个一维条件下的变化函数，如果仅仅是一个线性变化的函数自然就莫得问题了，但是他又具有局部性的随机变化函数，那么，在哪一个点可以代表这个曲线方程呢？
地统计学里面，把一维条件下的变异函数定位为：当空间点Z在一维X轴上变化时，区域化变量Z(x)在点x与x+h处的值Z(x) 与Z(x+h)差的方差的一半，为变量Z(x)在x轴方向上的变异函数，记为y(h)。所以，很多书上，把地统计学的变异函数，也叫做半变异函数。
写成数学公式就是：
(好吧，这是本文中唯一的数学公式，忍忍就过去了……当然，意犹未尽的同学，可以自行去查找变异函数的各种数据描述，我这里就不亮了，毕竟用PPT敲数学公式还是很麻烦的）
我们下面来解释一下，为什么说变异函数可以地统计学的核心研究内容。
首先，变异函数里面，Z（x)与Z（x+h)的差是计算的第一步，那么如果h=0的话（距离为零，就是在同一个位置连续进行两次测量），得到的结果变异函数也等于0了。
也就是说，默认，如果在同一个位置进行同等条件的两次测量，默认得到同一结果，不会发生变异，也就是变异函数排除了测量误差的假设。
第二，y(h) = y(-h)，也就是说，变异函数是个对h=0的直线对称，是一个偶函数。偶函数就表示了，二者之间的距离与正负无关（从谁参照物进行测量都行）。
第三，y(h) &gt;=0 ，研究现象的变异性，要么出现，要么不出现，只能大于等于0，不能是负数（自现象研究不出现负数）。
第四，当|h| -&gt; 无穷大的时候，y(h) -&gt; C(0)，好吧，我知道你们会问，这个C（0）是神马，这个东西叫做“先验方差”。
当h趋近于无穷大的时候，也就是说，这两个点已经无穷远了，比如：
根据地理学第一定律，那么他们之间的关系应该无穷小才对，那么这个先验方差又是神马呢？
先验方差是概率论里面的一个基本概念，指的是在实验之前，就对结果进行了断言——也就是所谓的：这事情嘛，虽然还没有开始，但是我估摸着这样应该差不多了……的意思。在概率论里面，相关的还有无信息先验贝叶斯这一类相关的概念，有兴趣的同学自己回去捡概率论回来看看。
这个概念在这里有啥用呢？
这个概念实际上是与第一个性质h= 0 相对应的，得到的实际上是这样一个函数：
这种完全没有空间相关性的，在地统计里面，也有一个专用名称，叫做“纯块金效益”。
块……金……？
好吧，英文单词确实是：Nugget，但是这里指的确和金块没有关系。
这里指的是这样一个情况：
上面那个图，是个理想化的函数，距离无穷小的时候，变异也无穷接近与0，但是很多时候，虽然两次测量和接近，但是结果确截然不同。
那么具体来说，在什么情况下会出现呢？
如果有A、B两个点，A点的值是100的话，B的取值应该是以100为中心的正态分布曲线的取值，AB两点距离越近，B点的取值就越接近100，这是理论的情况。
但是实际上可能出现这种情况：
实际上AB两点距离很近，但是获得的数据并非是正态分布的取值，这就是一种特有的变异。这种即使距离很近，但是样品之间也存在差异的情况，就叫做块金效益。
下面我们来看看完整的变异曲线图中的其他一下概念：
除了上面介绍过的块金值，还有一下几个基本概念：
首先是偏基台值与基台值：
一旦达到基台值之后，半变异的曲线就会进入平台期，哪怕h值在增大，y(h)的变化也不会太大了，这个常数就是所谓的基台值。
不过这个值对最后的插值结果影响不大（废话，都常数了不是）。
然后是变程：
在分析中，是可以存在最佳变程的，那么怎么去寻找这个最佳变程，就是我们后面在实践操作中需要详细讲解的内容。
当然，关于变异分析，还有更多的理论，有兴趣的同学可以去自行阅读相关资料，我们这里仅做科普性质。
从下一节开始，我们开始进入克里金插值过程的实操部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b90609bf833675894c782ffc938d23/" rel="bookmark">
			EEGLAB初步学习（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EEGLAB是可用于处理EDF格式的脑电信号的开源软件。eeglab有依附于matlab的版本，也有独立的版本，可以在官网下载。我使用的版本是v2019.0。安装完成，打开后可以看到以下界面：
单击file来导入数据，注意要根据所用设备来选取导入的方法。我的是edf文件，选择的是如下选项。
导入数据以后就可以对数据进行一系列的处理了。首先要对各个通道进行定位。不然有的图片做不出来。选择Edit-&gt;channel location, 连续点击OK，在主页面的channel locations就会从no变成yes了。不做这个的话，在plot选项的做出各个通道的功率谱密度图是做不出来的。
在这个时候，虽然还没有导入事件，也没有进行ICA（独立成分分析Independent component analysis）,根本就还没有去除各种噪声，但是通过PLOT-&gt;channel data(scroll)，也可以得到初步的scrolling data(时域上的信号),在此基础上还可以手动删除不需要的，局部放大，窗口比例放大缩小等操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6ba90a7927417a01f2318ba5506aa0/" rel="bookmark">
			csv导出百万级数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：测试数据200多万，项目使用
2：csv工具类，我用的第一方法
package com.wptx.comm.config; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.net.URLEncoder; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import javax.servlet.http.HttpServletResponse; import org.apache.commons.beanutils.BeanUtils; import org.apache.commons.lang3.StringUtils; public class CSVUtils { private static CSVUtils csvUtils; public static CSVUtils getInstance() { if (csvUtils == null) { csvUtils = new CSVUtils(); } return csvUtils; } /** * 生成为CVS文件 * @param exportData * 源数据List * @param map * csv文件的列表头map * @param outPutPath * 文件路径 * @param fileName * 文件名称 * @return */ @SuppressWarnings({ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6ba90a7927417a01f2318ba5506aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3952c97f76659f26d93fb315b5aded71/" rel="bookmark">
			Selenium webdriver 在chrome设置页面获取不到#shadow-root下面的html标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Selenium webdriver 在chrome设置页面获取不到#shadow-root下面的html标签 最近自己想用winform和selenium做个自动登陆web网站的小工具，动力来源于，开发过程中或者处理bug过程中经常需要切换账号登陆，打开浏览器，地址栏输入地址，输入账号密码，登陆，这个过程感觉在开发过程中经常会遇到，所以干脆自己做个小工具，自动化登陆，设置好账号密码和登陆地址就好，这也能节约很多时间
创建winform项目，引入Selenium.WebDriver 和Selenium.WebDriver.ChromeDriver 然后更具chrome浏览器下载对应版本的chromedriver.exe 并移动到对应文件夹下，然后就能写程序啦，这里有个问题，我想在打开登录页前先清理浏览器缓存，我的思路是这样的：先打开浏览器，然后跳转到“chrome://settings/clearBrowserData”，就会弹出下图，这时直接点击“清除数据”就行，很简单；但是实现过程中发现弹窗的内容是在#shadow-root下面，里面的元素通过id,cssselector,xpath都不能获取到，网上也查了下，一直没有找到很好的解决方案，这里先暂时启动的时候启用隐私模式代替。关于如何启用隐私模式另一篇文章有讲，这里就不赘述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1acec83bb79a6b88bd12662438a60bd/" rel="bookmark">
			css 设置水平滚动条 及其样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .ximiBlock::-webkit-scrollbar-track{ -webkit-box-shadow: inset 0 0 2px rgba(0,0,0,0.3); border-radius: 5px; background-color: rgba(255,255,255,0.8); } .ximiBlock::-webkit-scrollbar{ height: 10px;	/*设置滚动条样式*/ background-color: rgba(0,0,0,0); } .ximiBlock::-webkit-scrollbar-thumb{ border-radius: 5px; -webkit-box-shadow: inset 0 0 2px rgba(0,0,0,.3); background-color: #555;} .ulbox li {float: left; padding: 0 5px; margin-right: 10px; list-style: none;} .ulbox::-webkit-scrollbar-track{ -webkit-box-shadow: inset 0 0 2px rgba(0,0,0,0.3); border-radius: 5px; background-color: rgba(255,255,255,0.8);} .ulbox::-webkit-scrollbar{ height: 10px;	/*设置滚动条样式*/ background-color: rgba(0,0,0,0);} .ulbox::-webkit-scrollbar-thumb{ border-radius: 5px; -webkit-box-shadow: inset 0 0 2px rgba(0,0,0,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1acec83bb79a6b88bd12662438a60bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95aa2fc6501dbdb5113c758fa0547710/" rel="bookmark">
			ElementUI之Steps 步骤条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ElementUI之Steps 步骤条 步骤条表单效果图 步骤条表单 &lt;!-- 步骤条表单 这是头信息 使用 ‘v-if="active === 0" ’ --&gt; &lt;div class="deployBox" style="margin-top: 12px;"&gt; &lt;el-steps :active="active" finish-status="success" align-center space="550px"&gt; &lt;el-step title="基本信息1"&gt;&lt;/el-step&gt; &lt;el-step title="基本信息2"&gt;&lt;/el-step&gt; &lt;el-step title="基本信息3"&gt;&lt;/el-step&gt; &lt;/el-steps&gt; &lt;/div&gt; 效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736c6e5256787d74889764eb2b4dad0a/" rel="bookmark">
			Python里面如何实现tuple和list的转换？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#list to tuple lis=[1,2,3,4,5,6] x=tuple(lis) print(type(x),x) #tuple to list tup=(1,2,3,4,5,6) y=list(tup) print(type(y),y) 输出
(&lt;type 'tuple'&gt;, (1, 2, 3, 4, 5, 6)) (&lt;type 'list'&gt;, [1, 2, 3, 4, 5, 6]) 转载于:https://www.cnblogs.com/sea-stream/p/11191703.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d69b4e4db46ff6083be900ef75102e/" rel="bookmark">
			读书笔记：推荐系统与深度学习-第五章-混合推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是混合推荐系统 目前介绍的算法各有利弊：
基于内容的推荐方法：一类item的特征描述协同过滤：利用user和item的特定类型的信息转化生成推荐结果社交网络的推荐算法：根据user的相互影响关系进行推荐
所以，希望构建一种混合的推荐系统，结合不同算法的有点，克服缺陷，以提高推荐系统的可用性 1.1 混合推荐系统的意义 1.1.1 海量数据推荐 海量数据推荐系统通常是三个部分构成的：在线系统、近线系统和离线系统。
离线系统是传统的个性化推荐系统的主体，定期利用大量历史操作日志进行批处理运算，然后进行特征构造及选取， 最终建立模型并更新。近线系统是将用户产生的事件，利用流式计算得到中间结果，这些中间结果一方面发送给在线部分用于实时更新推荐模型， 另一方面将中间结果存储起来作为备份。在线部分利用离线部分的主体模型并考虑近线部分的实时数据对模型进行增量更新，然后得到实时的推荐模型，进而根据用户的行为来对用户进行实时推荐。 1.1.2 高质量推荐 为了提升推荐系统的推荐精度以及推荐多样性，工业上会对推荐系统进行特征、模型等多层面的融合来构建混合推荐系统。
1.2 混合推荐系统的算法分类 加权型混合推荐：就是将不同算法的推荐结果进行加权总和，生成最终的排序结果。权重可以根据用户的反馈进行调整。缺点是在数据稀疏的时候，相关的推荐方法没有办法获得好的效果。切换型混合推荐：根据问题的背景和实际情况在使用不同的推荐技术交叉型混合推荐：将不同推荐算法的生产结果，按照一定的配比融合在一起，打包后集中呈献给用户。主要可能存在的问题是结果组合时的冲突解决问题。特征组合型混合推荐：将不同推荐数据源的特征组合，由一种单一的推荐技术使用。瀑布型混合推荐：采用了过滤的设计思想，把不同的推荐算法看作是不同粒度的过滤器，特别适用于推荐对象与所需推荐的结果数量相差悬殊的时候，一般会把算起来快，区分度低的算法放在前面。特征递增型混合推荐：将前一个推荐方法的输出作为后一个推荐方法的输入，前者会为后者提供某些特征。元层次型混合推荐：将不同的推荐模型在模型层面上进行深度的融合 上面的这些混合推荐方式，又可以分为三类：
整体式混合推荐系统：对算法内部进行调整并行式混合推荐系统：对结果进行调整流水线式混合推荐系统：利用多个流程顺序产生推荐结果 2 推荐系统特征处理方法 2.1 特征处理方法 2.1.1 数值特征处理 方法一：无量纲处理： 名称python代码计算方法标准化sklearn.preprocessing.scale x ′ = x − x S x^{&amp;#x27;}=\frac {x-x} {S} x′=Sx−x​最大最小标准化sklearn.preprocessing.MinMaxScale x ′ = x − M i n M a x − M i n x^{&amp;#x27;}=\frac {x-Min} {Max-Min} x′=Max−Minx−Min​二次核sklearn.preprocessing.normalize/ 方法二：非线性变化：对数变换,主要的作用是解决随着自变量增加，因变量的方差变大的问题；把非线性转化为线性方法三：离散化，主要的优点，减少异常值的影响，易于存储，使得模型更稳定 无监督离散化： 等宽度离散方法等频分箱法：使得分到每个箱中的数据个数是相同的基于聚类分析的离散化方法：自顶向下的分裂策略和自底向上的合并策略 有监督离散化：基于熵的离散化方法和基于卡方的离散化方法 2.1.2 离散特征处理 方法一：One-Hot编码 sklearn.preprocessing.OneHotEncoder()方法二：特征哈希 作用：把高维特征向量压缩成低维特征向量针对特征：如id类型特征相比embedding方法更加节约资源 方法三：时间特征处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d69b4e4db46ff6083be900ef75102e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1086b1d85eaf2b8e2794137a37fa12/" rel="bookmark">
			一个由pom文件中依赖的scope为provided引发的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过Spring boot的主启动文件启动市报ClassNotFoundException，如下：
Caused by: java.lang.ClassNotFoundException: io.grpc.ManagedChannelBuilder at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_172] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_172] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) ~[na:1.8.0_172] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_172] ... 25 common frames omitted 但是这个jar包确实导入了，百思不得其解，
换了一种方式，启动成功了：
那么问题来了，为什么用spring-boot:run这种方式运行就可以成功，而直接如下运行却报错呢？
报错的原因找到了，如下
有一个没解决问题是，用spring boot插件运行和直接main函数运行有什么区别，为什么同样的配置，一个报错，一个就没有报错？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cfcf253400cba440e1ac292b5ef08b6/" rel="bookmark">
			移动端的开发和适配  rem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动端的开发和适配 1.特点
相当于跑在手机端的web页面
跨平台
基于webview，webkit
更高的适配和性能要求
2.移动端适配方法
3.媒介查询
@media screen and (max-width:200px){} //方式1 &lt;link rel=”stylesheet” media=”screen and (min-width:992px) “&gt; //方式2 @media not screen//排除 4.Rem(font-size of root element )
根据页面根元素的字体大小公式：字体大小/html字体大小=rem例：html {font-size:62.5%} // 10px/16px*100%=62.5% 默认Font-size为16px,这里设置为10px，方便计算
body{font-size:1.4rem} // 1.4 * 10=14px 5.动态修改font-size
javascript代码
//viewport视图宽度 var htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; //html宽度 var htmlDom = document.getElementsByTagName("html")[0]; var htmlDom.style.fontSize = htmlWidth/10+"rem"; CSS代码
@function px2rem($px){ $rem : 37.5px; return ($px/$rem) + rem; } 为什么是$rem为37.5？
关于rem的基准值，也就是上面那个37.5px其实是根据我们所拿到的视觉稿来决定的主要有以下几点原因：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cfcf253400cba440e1ac292b5ef08b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0129edc818fd8595ca6f16ef387bd41/" rel="bookmark">
			【企业管理】价值创造的来源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文内容主要整理自《华为公司基本法》一些核心关键思想，不具体展开，仅供学习参考。
概要
只有客户成功，才有企业的成功价值创造的辩证关系 只有客户成功，才有企业的成功 顾客利益，就是我们生存和发展最根本利益以顾客满意度作为衡量一切工作的准绳可持续发展，归根结底是满足客户需求企业发展之魂是客户需求，而不是某个企业领袖 价值创造的辩证关系 实事求是才有凝聚力公司生存唯一道路，就是客户价值最大化 -- 质量好，服务好，价值最低。客户利益大了，就有再多的钱买公司的设备，我们也就活下来了。组织结构，流程制度，服务方式，工作技巧一定要围绕这个目标（客户价值最大化）坚持以客户利益为核心的价值观，驱动员工努力奋斗坚决反对空洞的思想，培养员工从小事开始关心他人，平时关心同事，以及周围有困难的人，修养自己。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0365a680e807bc5174cbbf0851634025/" rel="bookmark">
			[填坑]Ubuntu18.04无法使用shutter截图工具解决方案（截取时黑屏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现一个Ubuntu上一个比较好的截图工具，于是下载下来用，结果发现截图时要么是黑屏要么是花屏，根本获取不到屏幕内容，而自带的截图工具是可以正常工作的，很纳闷，以为是依赖库的问题，解决了半天还是没用，后来才发现原来是显示服务器的的问题：
shutter只能在X Window下工作（2019年7月14号 ；Ubuntu18.04 ；shutter version0.94 Rev.1290），如果想要使用必须从wayland模式切换到X window下。
首先，需要查看一下，图形驱动用的是Wayland还是Xwindow。
1、如何查看自己使用的是wayland还是xwindow？ 输入命令
echo $XDG_SESSION_TYPE 如果是wayland，会返回wayland，如果是xwindow，会返回x11或者x后面跟其他数字。
2、如何切换wayland和X Window？ 1、注销 2、在登录界面选择以哪种图形服务器进入 选择 Ubuntu默认以x window运行，选择Ubuntu on wayland则以wayland运行
关于显示服务器wayland和xwindow的介绍可以看一下链接
揭开Wayland的面纱（一）：X Window的前生今世：https://imtx.me/archives/1573.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e224d0305878fb6035821ea2daa8422b/" rel="bookmark">
			Android SDK是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SDK (Software Development Kit) 软件开发工具包是软件开发工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。Android SDK 就是 Android 专属的软件开发工具包。
Android SDK 目录结构 Android SDK 解压即可完成安装，其中包含的文件、文件夹如图 1 所示。
图 1 Android SDK 目录结构图
1) add-ons
该目录中存放 Android 的扩展库，比如 Google Maps，但若未选择安装 Google API，则该目录为空。
2) docs
该目录是 developer.Android.com 的开发文档，包含 SDK 平台、工具、ADT 等的介绍，开发指南，API 文档，相关资源等。
3) extras
该目录用于存放 Android 附加支持文件，主要包含 Android 的 support 支持包、Google 的几个工具和驱动、Intel 的 IntelHaxm。
4) platforms
该目录用于存放 Android SDK Platforms 平台相关文件，包括字体、res 资源、模板等。
5) platform-tools
该目录包含各个平台工具，其中主要包含以下几部分。
名称作用api 目录api-versions.xml 文件，用于指明所需类的属性、方法、接口等lib 目录目录中只有 dx.jar 文件，为平台工具启动 dx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e224d0305878fb6035821ea2daa8422b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504e54ea7fda210a9794002ce0c43f14/" rel="bookmark">
			C&#43;&#43;容器常见函数操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;deque&gt; #include &lt;list&gt; #include &lt;forward_list&gt; #include &lt;array&gt; using namespace std; int main() { /*--------------------- vector容器的一些操作 ------------------*/ vector&lt;int&gt; vect1; // 定义一个vector容器 vect1.push_back(1); // push_back: 向容器的末尾添加元素 vect1.push_back(2); vect1.push_back(3); vect1.pop_back(); // pop_back: 去除末尾的元素 vect1.insert(vect1.begin() + 1, 8); // 在某个位置插入一个元素,效率低，不适合大批操作 vect1.at(0); // at:取某个位置的元素 vect1.capacity(); // capacity: 不分配新的内存空间的前提下它最多能保存多少元素。这个和下面的size 是有区别的！！ vect1.size(); // size: 已经保存的元素的数目 vect1.empty(); // empty：判断容器是否为空 vect1.front(); // front：取第一个元素 vect1.back(); // back：取最后一个元素 vect1.erase(vect1.begin() + 1); // erase：删除指定位置的元素 vector&lt;int&gt; vect2; vect2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504e54ea7fda210a9794002ce0c43f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/318b706073e5acd6b66f7f4519980798/" rel="bookmark">
			YoungTalk STM32——蜂鸣器驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		buzzer.c内各驱动函数：
蜂鸣器的接口初始化 void BUZZER_Init(void){
GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Pin = BUZZER;//选择端口号
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //选择IO接口工作方式
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //设置IO接口速度（2/10/50MHz）
GPIO_Init(BUZZERPORT, &amp;GPIO_InitStructure);
GPIO_WriteBit(BUZZERPORT,BUZZER,(BitAction)(1)); //蜂鸣器接口输出高电平1(保护作用) }
蜂鸣器响一声(可修改音调和鸣响时间) void BUZZER_BEEP1(void){
u16 i;
for(i=0;i&lt;200;i++){
GPIO_WriteBit(BUZZERPORT,BUZZER,(BitAction)(0)); //蜂鸣器接口输出0
delay_us(500);//延时 GPIO_WriteBit(BUZZERPORT,BUZZER,(BitAction)(1));//蜂鸣器接口输出高电平1
delay_us(500); //延时 }
}
void BUZZER_BEEP2(void){
u16 i;
for(i=0;i&lt;500;i++){
GPIO_WriteBit(BUZZERPORT,BUZZER,(BitAction)(0)); //蜂鸣器接口输出0
delay_us(250);//延时 GPIO_WriteBit(BUZZERPORT,BUZZER,(BitAction)(1));//蜂鸣器接口输出高电平1
delay_us(250);//延时 }
}
函数调用较为简单，不再赘述。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d32b6d9d471b6a9b676c2f7ab0492e/" rel="bookmark">
			【Android系统源码修改】禁止开机锁屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改两个地方：
1 锁屏功能完全屏蔽，如果在设置中设置锁屏，会导致开机后黑屏
2 设置默认锁屏为无
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2ececfbe9ab9accbc6f618f1b08f5c/" rel="bookmark">
			怎样在idea中单独运行一个小的方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样在idea中单独运行一个小的方法？ 单击出错地方，右键，选择exclude from compile，之后即可
那之后又想运行这个方法怎么办呢？
File-&gt;Settings-&gt; Build,Execution,Deployment-&gt;Compiler-&gt; Execludes
貌似找不到或者无法加载主类，也是这个处理方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b4188928855691ac034746500028f5/" rel="bookmark">
			react-native:Task:react-native-gesture-handler:compileDebugJavaWithJavac Failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天运行React-Native app时候遇到的一个错误:
react-native:Task:react-native-gesture-handler:compileDebugJavaWithJavac Failed
原因未知，网上说是sdk问题，
解决方法：运行：
npm i jetifier
npx jetify
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0cc7a287582b5c9f0774651a034638a/" rel="bookmark">
			Ubuntu/Linux 开机运行指定的命令/自动运行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候需要Ubuntu在开机的时候执行一些指定的命令，这里对操作方法进行记录。
在 /etc/init.d/ 中创建自己的开机运行脚本 # 这里的文件名 mystart 可以修改为任何你喜欢的名称，但是必须放在/etc/init.d/目录中 cd /etc/init.d sudo vim /etc/init.d/mystart.sh 写入需要执行的命令, #!/bin/bash ### BEGIN INIT INFO # Provides: tuzixini # Required-Start: $local_fs $network # Required-Stop: $local_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: self define auto start # Description: self define auto start ### END INIT INFO # 上面的部分也必须写上，后面放上你需要开机执行的命令，这里是挂载一个硬盘 sudo mount /dev/sdb1 /opt/disk 修改脚本文件权限(将命令中的mystart.sh替换成实际的脚本文件名称) sudo chmod 755 /etc/init.d/mystart.sh 加入开机启动(将命令中的mystart.sh替换成实际的脚本文件名称) sudo update-rc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0cc7a287582b5c9f0774651a034638a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1abdb2a6d87c1e7d801c0cb34f1b6f5/" rel="bookmark">
			Mybaits映射文件配置之获取属性对象属性参数(参数对象嵌套)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Mybaits映射文件配置之获取属性对象属性参数(参数对象嵌套) Mybaits映射文件配置之获取属性对象属性参数(参数对象嵌套) ​ 如果参数是一个对象，该对象的属性也是一个对象，如果要获取这个属性对象的属性；属性名.属性名就可以获取了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6406bf0022f16ae0858e0a4199839bad/" rel="bookmark">
			分解因数——递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给出一个正整数 aaa，要求分解成若干个正整数的乘积，即 a=a1×a2×a3×...×ana = a_1 \times a_2 \times a_3 \times ... \times a_na=a1​×a2​×a3​×...×an​，并且 1&lt;a1≤a2≤a3≤...≤an1 &lt; a_1 \le a_2 \le a_3 \le ... \le a_n1&lt;a1​≤a2​≤a3​≤...≤an​，问这样的分解的方案种数有多少。注意到 a=aa = aa=a 也是一种分解。
输入格式
第 111 行是测试数据的组数 n(1≤n≤10)n(1 \le n \le 10)n(1≤n≤10)，后面跟着 nnn 行输入。每组测试数据占 111 行，包括一个正整数 a(1&lt;a&lt;32768)a (1 &lt; a &lt; 32768)a(1&lt;a&lt;32768)。
输出格式
nnn 行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的方案种数。
输出时每行末尾的多余空格，不影响答案正确性
样例输入复制
2 2 20 样例输出复制
1 4 【分析】给一个数，求它的因式分解个数（加上数本身）。
比如12 = 2 * 6 = 2 * 2 * 3 = 3 * 4 = 12；答案为4；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6406bf0022f16ae0858e0a4199839bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e1b753c5c0b6c4bf48232e4f0461d3/" rel="bookmark">
			xorg的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		较新版本的linux系统都已经没有xorg.conf文件，但是有时候为了对显示做微调或为了支持多屏显示等原因，还需要手工生成一个xorg.conf，然后根据情况做些修改设置。这种情况下我们如何有一个基本的xorg.conf模板呢？当然可以从网上去找一个，然后手工修改，但是还有一种方式可以生成xorg.conf，而且更符合你实际的系统环境，步骤如下：
在命令行下切换到root身份；执行命令“ cp /var/log/Xorg.0.log /var/log/Xorg.1.log";执行命令” Xorg -configure :1";执行命令3后 xorg.conf.new 在 /root/ 目录下生成，该文件可以做为当前系统的xorg.conf的基本模板使用了 X的配置，实际上就是生成 /etc/X11/xorg.conf 这个文件。
通常的配置主要对以下的Section作操作：
a. 显示器的信息写在该节
Section “Monitor”
Identifier “monitor0”
VendorName “VSC”
ModelName “VSC1609 ”
HorizSync 30 – 70
VertRefresh 50 - 160
ModeLine “…” ---------&gt;指定显示器的显示模式，很重要。
…
ModeLine “…”
Endsection
ModeLine 可以用ddcxinfo-knoppix直接生成。（通过检测你的显卡和显示器）
或者通过gtf 直接计算标准的VESA mode lines。如：
gtf 1024 768 85 则生成：
1024x768 @ 85.00 Hz (GTF) hsync: 68.60 kHz; pclk: 94.39 MHz Modeline “1024x768_85.00” 94.39 1024 1088 1200 1376 768 769 772 807 -HSync +Vsync
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e1b753c5c0b6c4bf48232e4f0461d3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/231/">«</a>
	<span class="pagination__item pagination__item--current">232/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/233/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>