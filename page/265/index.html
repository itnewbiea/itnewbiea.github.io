<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fef64ccacc7b22ff74e2733516f8b506/" rel="bookmark">
			CAS服务端redis集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：cas4.0.x+Tomcat7+Jdk7+redis3.0
CAS中的票据默认是存储在TicketRegistry中的，若是想要实现CAS服务端的集群，首先要做的是将票据共享到缓存中。
1.实现AbstractDistributedTicketRegistry抽象类
import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Collection; import javax.validation.constraints.Min; import org.jasig.cas.ticket.ServiceTicket; import org.jasig.cas.ticket.Ticket; import org.jasig.cas.ticket.TicketGrantingTicket; import org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry; import org.springframework.beans.factory.DisposableBean; import redis.clients.jedis.Jedis; import com.sdzn.cas.util.RedisClient; public class RedisTicketRegistry extends AbstractDistributedTicketRegistry implements DisposableBean { /** * TGT cache entry timeout in seconds. */ @Min(0) private final int tgtTimeout; /** * ST cache entry timeout in seconds. */ @Min(0) private final int stTimeout; /** * Creates a new instance that stores tickets * * @param ticketGrantingTicketTimeOut * TGT timeout in seconds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fef64ccacc7b22ff74e2733516f8b506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638876a81aab98a0166fe62ca4d6e975/" rel="bookmark">
			新版sonar代码审查问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要问题列表： 格式：问题名字+问题出现的次数
Resources should be closed2
资源未关闭，打开发现有两处用到的IO流没有关闭
Conditions should not unconditionally evaluate to "TRUE" or to "FALSE"1
if/else判断里出现了重复判断，比如在if(a&gt;10)的执行体里面又判断if(a&lt;0)，而后者肯定不会是true
Exception handlers should preserve the original exception13
处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事
Throwable.printStackTrace(...) should not be called7
不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。
Loggers的优势是：Users are able to easily retrieve the logs.
The format of log messages is uniform and allow users to browse the logs easily.
Instance methods should not write to "static" fields6
不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变
"public static" fields should be constant1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638876a81aab98a0166fe62ca4d6e975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7179138d5732b202b1205e7478d713/" rel="bookmark">
			sort_buffer_size:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sort_buffer_size: 每个session 必须执行一个排序 分配一个 这个大小的buffer. sort_buffer_size 不特定的对于任何存储引擎适用于一般的优化方式。 sort_buffer_size的最小值 必须足够大 容纳15个元组在sort buffer. 同时, 增加 max_sort_length的值 可能需要增加sort_buffer_size的值 如果你看到很多的Sort_merge_passes 每秒在 SHOW GLOBAL STATUS输出 [root@zjzc01 binlog]# mysql -uroot -p'R00t,uHagt.0511' -e"SHOW GLOBAL STATUS" | grep -i sort Warning: Using a password on the command line interface can be insecure. Sort_merge_passes	44 Sort_range	8619222 Sort_rows	1212216576 Sort_scan	10157773 你可以考虑增加sort_buffer_size value来加速 ORDER BY 或者GRUP BY 操作 不能通过查询优化或者改善索引 在MySQL 5.6.4中,优化器 尝试计算难处 需要多少空间 但是可以分配更多, 最大到限制。 在MySQL 5.6.4种,优化器分配整个buffer 即使它是不完全需要的。 在任何情况下,设置它大于需要的激昂减慢大多数查询。 最好是增加它 作为session设置 在Linux上,有256KB和2MB的阀值 更多的值可能显著的减慢内分分配, 你应该考虑下面中的那些值。 转载于:https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7179138d5732b202b1205e7478d713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5859c4db639fc16366f99b3bbddb86f9/" rel="bookmark">
			支付宝错误提示： sign check fail: check Sign and Data Fail JSON also
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		细节决定命运 ，真是体会深刻！
支付宝报错：sign check fail: check Sign and Data Fail JSON also 支付宝签名文件错误，查了好几天，密钥、公钥也重新生成了，支付宝也有交易流水，但是查询网关交易记录时直报错，找了很多次，终于发现了，原来犯了一个非常低级的错误，手工复制的alikey文件中没有加入文件头、文件尾，打开另二个文件中的随便一个，然后找到头、尾添加进去就可以了，真的是醉了，可不能轻视细节哦。
加上头尾后，文档内容如下，保存后修改文件为 .pem 的文件就可以了。
例：
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB
-----END PUBLIC KEY-----
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf9e979ee906ae739907e920f8d7081/" rel="bookmark">
			smbd服务器-网络磁盘映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、smbd可进行虚拟机的网络磁盘映射，并且可以让整个磁盘在windows下进行操作。
1、首先要安装、设置并开启smbd服务 ： /etc/init.d/smbd start
2、映射网络驱动,IP+虚拟机下的文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13913979995635b4561d7074c595e0af/" rel="bookmark">
			Rstudio连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用Rstudio连接mysql数据库
我们常常会把大量的数据存储在MySQL这样的数据库中，这样方便我们进行数据提取和操作，而很多时候当我们在用R进行数据分析的时候，通常都希望R能够直接和mysql数据库连接，方便我们直接对大规模数据进行处理。当然，mysql中存储的是结构化数据。
有些朋友在使用R连接mysql等数据库的时候会遇到一些问题，因而本文着重以mysql为例，介绍如何利用R连接mysql数据源的基本步骤。具体步骤如下：
1、R下载RODBC包，安装好。
install packages("RODBC"); #安装RODBC包
2、打开链接 http://dev.mysql.com/downloads/connector/odbc，下载mySQL ODBC，安装好：
3、控制面板---&gt;管理工具---&gt;数据源（ODBC）（根据电脑选择32位、64位）---&gt;点击添加---&gt;选中mysql ODBC driver选项（Unicode和ANSI任意选择一个）。
data source name（DSN数据源名称）填入你想要使用的名字，例如：mysql_data;
description 可以随意填写，例如mydata
TCP/IP Server 本机服务器IP，一般为：127.0.0.1或者localhost
user 你的mysql用户名
password 你的mysql密码
然后数据库里会出现你的mysql里的所有数据库，选择一个数据库。
4、打开R的界面调用数据库：（本人使用的是RStudio）
（1）library(RODBC); （2）channel &lt;- odbcConnect("mysql_data", uid="root", pwd="123456"); （3）sqlTables(channel); #查看数据库中的表 （4）data&lt;-sqlFetch(channel,"titanicdata"); # 将表titanicdata的内容，存到数据框data里
5、至此，R已经成功与mysql数据库连接，并且获取了mysql库中niesheng数据库里titanicdata表中的数据。
6、既然能够连接上数据库，那么在R中同样可以使用SQL语句进行数据处理和数据提取。
例1：将年龄不为空的数据存入data1数据集中。
data1 &lt;- sqlQuery(channel, "selectsurvived, age, class, sex from titanicdata where age&lt;&gt; 'null';
例2：将是否幸存survived、阶级class、性别sex 都转换为1、0这样的数值，便于后面进行分析。
Titanic &lt;- sqlQuery(channel, "select (CASE WHEN t.survived='yes' THEN 1 ELSE 0 END) survived, age,(case when t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13913979995635b4561d7074c595e0af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c486d45f3781f54b00ab61bf3031c0c/" rel="bookmark">
			HyBrid App框架介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果篮球架和人同高，则无法引起人们的兴趣；但如果篮球架有两层楼那么高，同样是人丧失兴趣。——篮球架效应
RuiMan的博客 - [混合开发]HybridApp分析！！！ kingplus - Hybrid APP混合开发的一些经验和总结chemdemo/chemdemo.github.io - Hybrid APP架构设计思路Hybrid APP架构设计思路极致的 Hybrid 混合式开发（去啊App Hybrid 实战） 之后，谨慎的我还去找了资料，综合了下。以下是找来的资料。 博主在入坑了之后，深觉综合查询是重要的，学习一门技术需要看自己的能力水平和这门技术是否相对成熟（大牛勿笑）以及自己学习这项技术的目的。
简介 HybridApp概念 Hybrid App：Hybrid App is a mobile application that is coded in both browser-supported language and computer language. They are available through application distribution platforms such as the Apple App Store, Google Play etc. Usually, they are downloaded from the platform to a target device, such as iPhone, Android phone or Windows Phone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c486d45f3781f54b00ab61bf3031c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc70d2271e154d739de48ad79cad5776/" rel="bookmark">
			android  ScrollView 嵌套RecyclerView 解决滑动冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了解决滑动事件的冲突需要重写ScrollView /* * Copyright 2014 Soichiro Kashima * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc70d2271e154d739de48ad79cad5776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4951fe73c4a96c17f89dc3a6ec35867/" rel="bookmark">
			mysql单列索引、多列索引的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 数据库的索引可以加快查询速度，原因是索引使用特定的数据结构(B-Tree)对特定的列额外组织存放,加快存储引擎(索引是存储引擎实现)查找记录的速度。
索引优化是数据库优化的最重要手段。
如果查询语句使用索引（通常是where条件匹配索引)就会利用树的结构加快查找，索引会按值查找到要查找的行在表中位置，不需回表查询数据的就是聚簇索引(索引和数据存放在一起)。通常是需要回表再查数据，需要消耗额外的磁盘IO。所以有些时候（如按顺序读取数据）全表扫描会比使用索引快的原因就在于此。
查询条件只有一个字段时，在该字段建立索引即可，可优化的地方是对于text blob字段使用前缀索引。
当查询条件有多个字段时，单列索引和多列索引有很大的区别。如果使用多列索引，where条件中字段的顺序非常重要，需要满足最左前缀列。最左前缀：查询条件中的所有字段需要从左边起按顺序出现在多列索引中，查询条件的字段数要小于等于多列索引的字段数，中间字段不能存在范围查询的字段(&lt;,like等)，这样的sql可以使用该多列索引。
二、多列索引适合的场景 1.全字段匹配
2.匹配部分最左前缀
3.匹配第一列
4.匹配第一列范围查询(可用用like a%,但不能使用like %b)
5.精确匹配某一列和和范围匹配另外一列
order by操作中出现的字段同样适用于按值查找的规则，where+order by中出现的字段需可以建立满足如上五种规则多列索引。使用多列所需需要按照最左索引列查找；不能跳过中间列；如果某一列是范围查询，那么其右边所有列无法使用索引。IN什么情况下是范围查询，什么情况下是多个等值查询？如果有order by排序时，多个等于条件查询就是范围查询，没有order by排序就没有限制。
例如,建立多列索引(name, age, id),只能使用索引的前两列。in是范围查询
... where name='nginx.cn' and age in(15,16,17) order by id
可以使用整个索引，in是按值查询
... where name='nginx.cn' and age in(15,16,17) and id ='3'
三、复合索引的建立以及最左前缀原则 索引字符串值的前缀（prefixe）。如果你需要索引一个字符串数据列，那么最好在任何适当的情况下都应该指定前缀长度。
例如，如果有CHAR(200)数据列，如果前面10个或20个字符都不同，就不要索引整个数据列。索引前面10个或20个字符会节省大量的空间。你可以索引CHAR、VARCHAR、BINARY、VARBINARY、BLOB和TEXT数据列的前缀。
假设你在表的state、city和zip数据列上建立了复合索引。索引中的数据行按照state/city/zip次序排列，因此它们也会自动地按照state/city和state次序排列。这意味着，即使你在查询中只指定了state值，或者指定state和city值，MySQL也可以使用这个索引。因此，这个索引可以被用于搜索如下所示的数据列组合：
state, city, zip
state, city
state
MySQL不能利用这个索引来搜索没有包含在最左前缀的内容。例如，如果你按照city或zip来搜索，就不会使用到这个索引。如果你搜索给定的state和具体的ZIP代码（索引的1和3列），该索引也是不能用于这种组合值的，尽管MySQL可以利用索引来查找匹配的state从而缩小搜索的范围。
如果你考虑给已经索引过的表添加索引，那么就要考虑你将增加的索引是否是已有的多列索引的最左前缀。如果是这样的，不用增加索引，因为已经有了(例如，如果你在state、city和zip上建立了索引，那么没有必要再增加state的索引)。
四、通过实例理解单例索引、多列索引以及最左前缀原则 实例：现在我们想查出满足以下条件的用户id：
mysql&gt;SELECT ｀uid｀ FROM people WHERE lname｀='Liu' AND ｀fname｀='Zhiqun' AND ｀age｀=26 ； 因为我们不想扫描整表，故考虑用索引。
1、单列索引：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4951fe73c4a96c17f89dc3a6ec35867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684a6cf22773beb7b1a8aafb487527ec/" rel="bookmark">
			hdu 5895(矩阵快速幂&#43;欧拉函数)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接:http://acm.hdu.edu.cn/showproblem.php?pid=5895
f(n)=f(n-2)+2*f(n-1) f(n)*f(n-1)=f(n-2)*f(n-1)+2*f(n-1)*f(n-1); 2*f(n-1)*f(n-1)=f(n)*f(n-1)-f(n-2)*f(n-1); 累加可得 g(n) = f(n)*f(n+1)/2 然后这个公式:A^x % m = A^(x%phi(m)+phi(m)) % m (x &gt;= phi(m)) 反正比赛没做出来. #include &lt;bits/stdc++.h&gt; #define LL long long using namespace std; struct Maxtri{ LL v[2][2]; Maxtri(){memset(v,0,sizeof(v));} }ori; LL n, y, x, s, mod ; Maxtri mult(Maxtri a,Maxtri b){ Maxtri temp; for(int i=0;i&lt;2;i++){ for(int j=0;j&lt;2;j++){ for(int k=0;k&lt;2;k++){ temp.v[i][j] = (temp.v[i][j]+(a.v[i][k]*b.v[k][j])%mod)%mod; } } } return temp; } LL pow_mod(Maxtri a,LL n){ if(n==0) return 0; if(n==1) return 1; if(n==2) return 2; n-=2; Maxtri ans; for(int i=0;i&lt;2;i++){ ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684a6cf22773beb7b1a8aafb487527ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b54b8f7d995c70ef6cad7acc60378d3/" rel="bookmark">
			CSS3选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：属性选择器 CSS3新增了3个属性选择器，使得属性选择器有了通配符的概念。
二：结构性伪类选择器 :root :root选择器，可理解为根选择器，匹配元素所在文档的根元素。在HTML文档中，根元素始终是&lt;html&gt;。
:root选择器等同于&lt;html&gt;元素：
:root{background:orange} html {background:orange;}
另外在IE９以下还可以借助“:root”实现hack功能。
:not :not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。比如说你想给表单中除submit按钮之外的input元素添加红色边框，可以写成：
input:not([type="submit"]){ border:1px solid red;}
:empty :empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，包括空格。
:target :target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。
1.点击链接显示隐藏的段落。
&lt;h2&gt;&lt;a href="#brand"&gt;Brand&lt;/a&gt;&lt;/h2&gt; &lt;div class="menuSection" id="brand"&gt; content for Brand &lt;/div&gt; .menuSection{ display: none; } :target{/*这里的:target就是指id="brand"的div对象*/ display:block; } 分析:(1)、触发元素的URL中的标志符通常会包含一个#号，后面带有一个标志符名称，上面代码是：#brand
(2)、：target就是用来匹配id为“brand”的元素（id="brand"的元素）,上面代码中是那个div元素。
2.多个url（多个target）处理：
当同一个页面上有很多的url的时候，你可以取不同的名字，只需#号后的名称与id=""中的名称对应。
:first-child :first-child选择器表示的是选择父元素的第一个子元素的元素E。
ul&gt;li:first-child{background:blue;}
:last-child 与:first-child选择器作用类似，但:last-child选择器选择的是元素的最后一个子元素。
ul&gt;li:last-child{background:blue;}
:nth-child(n) :nth-child(n)选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。
:nth-last-child(n) :nth-last-child(n)从某父元素的最后一个子元素开始计算，来选择特定的元素。
:first-of-type :first-of-type选择器类似于:first-child选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。
:nth-of-type(n) :nth-of-type(n)选择器和:nth-child(n)选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用:nth-of-type(n)选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在:nth-of-type(n)选择器中的n和:nth-child(n)选择器中的n参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。
:last-of-type选择器 :last-of-type选择器和:first-of-type选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素
:nth-last-of-type(n) :nth-last-of-type(n)选择器和:nth-of-type(n)选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的:nth-last-child(n)选择器一样。
:only-child :only-child选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。
:only-of-type :only-of-type选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。:only-of-type是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用:only-of-type选择器就可以选中这个元素中的唯一一个类型子元素
三：在表单中使用的选择器： :enabled 对表单元素可用（:enabled）和不可用（:disabled）状态设置样式，:enabled用来选择可用表单元素。
:disabled 用来选择不可用表单元素。只需在表单元素的HTML中设置“disabled”属性。
:checked 表单元素中，单选按钮和复选按钮都具有选中和未选中状态。CSS中:checked表示的是选中状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b54b8f7d995c70ef6cad7acc60378d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c950c68e8c23f6576bde51431c803d/" rel="bookmark">
			阅读感悟_之分享一些自己的学习历程和学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今日在csdn博客上偶然读到一篇关于技术方面的学习经历，颇为感触，地址：分享一些自己的学习历程和学习方法.
1)学习的三个阶段：消费者阶段，实践者阶段，创造者阶段。
2）在学习过程中莫要心急，由小到大，逐渐深入学习；
3）不要担心重复造轮子，只要有一些小的改动也是值得的；
4）莫要用战术上的勤奋来弥补战略上的懒惰，总是沉浸于各种碎片化知识，多读一手资料，形成自己的系统逻辑；
作者这样说：
“我不否认知乎存在有价值的知识，但，根本不值得你花那么多时间，去发现那少的可怜的知识。去读书吧。用最系统的逻辑，去学会一项技能， 哪怕你去《硅谷百年史》里去读那些振奋人心的仙童半导体的故事，也比你不断的知乎看&gt;着水的一笔的帖子要强的多。现在，最可怕的是大家在 知乎上消费着垃圾，却依然觉得自己在吃着奶酪，学习的过程都是伴&gt;随着思考和痛苦的，如果你边笑边学习，那你真的得醒醒了。" 5)当自己有天马行空的idea时，随时记录； 6）赶在兴趣之前，去学习新知识，永远不要怀疑零碎知识的意义； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e414300e89d60f8420d9878314c740c8/" rel="bookmark">
			『HDU 5895』Mathematician QSC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接:http://acm.hdu.edu.cn/showproblem.php?pid=5895
转载链接:http://blog.csdn.net/viscu/article/details/52595126
知识点链接:http://blog.csdn.net/acdreamers/article/details/8236942
题意:就是求一个公式 个人感想:
今天补补我没看过的题,我一拿到题,然后拆分一下,我想,不就矩阵快速幂吗,对于每个 f[i]^2 求一个快速幂,然后我看了一下n*y,这个数据&lt;=10^12次方,就算用nlogn求完指数也会超时,…然后我就想不出来了,我考虑过,能不能用矩阵把g【n】一起求出来,然后想了会实在没头绪,- -之后无奈下看了下转载写的题解,… 我曹,这样构造矩阵也可以…,我服…我做这种类型构造有点少啊…所以也没什么感觉,
然后我就觉得这样很简单啊,xjb搞搞就行了… 可是我突然发现…不行啊 应该可以取模才对啊,否则指数无限大啊。。。
我再查了一下取模公式 只有**（a^b）%p ==((a%p)^p)%p**;
但是没用啊。。。。
再百度一下 指数循环节,题解也提到过,看看ACdreamer写的… 没什么解释,就摆了一条公式, 窝尼玛,真牛,我感觉我得去刷刷矩阵幂和 ACdream给的指数循环了… 那里有好多题目…
真的久不做矩阵,我还犯了个错误,原来矩阵是不能交换律的…(⊙o⊙)哦！！！！！，然后测了很久才发现错误…
分析:矩阵快速幂+循环节.
代码:
/* Author:GavinjouElephant * Title: * Number: * main meanning： * * * */ #include &lt;iostream&gt; using namespace std; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;sstream&gt; #include &lt;cctype&gt; #include &lt;vector&gt; #include &lt;set&gt; #include &lt;cstdlib&gt; #include &lt;map&gt; #include &lt;queue&gt; //#include&lt;initializer_list&gt; //#include &lt;windows.h&gt; //#include &lt;fstream&gt; //#include &lt;conio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e414300e89d60f8420d9878314c740c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68dc90ec2413a8849f16a79a1a40852c/" rel="bookmark">
			Linq表达式和Lambda表达式用法对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Linq表达式？什么是Lambda表达式？
前一段时间用到这个只是，在网上也没找到比较简单明了的方法，今天就整理了一下相关知识，有空了再仔细研究研究
public Program() { List&lt;Student&gt; allStudent = new List&lt;Student&gt; { new Student("张三",23), new Student("李四",29), new Student("王二",25), new Student("赵六",26) }; //Ling表达式 var stus1 = from s in allStudent where s.Name == "王二" select new { s.Name, s.Age }; //Lanmbda表达式 var stus2 = allStudent.Where(t =&gt; t.Name == "王二").Select(t =&gt; new { t.Name, t.Age }); } public class Student { public string Name { set; get; } public int Age { set; get; } public Student(string name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68dc90ec2413a8849f16a79a1a40852c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926a9f74e333ab7edea2eb9b1585fa80/" rel="bookmark">
			hdu5895Mathematician QSC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：http://acm.hdu.edu.cn/showproblem.php?pid=5895 题意：给定f(0)=0,f(1)=1,f(n)=f(n-2)+2*f(n-1)，g(n)=sigma(f(i)^2){0&lt;=i&lt;=n}。给定多组n,y,x,s，求x^g(n*y)%(s+1)。 分析：写出矩阵递推式，然后就是矩阵快速幂啦。矩阵递推式见代码。 代码： #include&lt;map&gt; #include&lt;set&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #include&lt;math.h&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;stdio.h&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #pragma comment(linker, "/STACK:102400000,102400000") using namespace std; const int N=3010; const int M=50010; const int mod=1000000007; const int MOD1=1000000007; const int MOD2=1000000009; const double EPS=0.00000001; typedef long long ll; const ll MOD=1000000007; const int INF=1000000010; const ll MAX=1ll&lt;&lt;55; const double eps=1e-5; const double inf=~0u&gt;&gt;1; const double pi=acos(-1.0); typedef double db; typedef unsigned int uint; typedef unsigned long long ull; struct martrix{ ll x[5][5]; }p; ll phi(ll n) { ll i,ans=n,m=(ll)sqrt(n+0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/926a9f74e333ab7edea2eb9b1585fa80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1179607099f0978c1e9683677df6e04/" rel="bookmark">
			Loadrunner关联取参及设置检查点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Loadrunner关联取参及设置检查点：
获取post的响应值当作参数存储，要在此post请求之上添加
1 web_reg_save_param("sign", 2 "LB=md5码是:[", 3 "RB=]", 4 "Search=All", 5 LAST); 6 7 8 web_submit_data("tomd5", 9 "Action=http://v49.pclady.com.cn:8090/servlet/tomd5", 10 "Method=POST", 11 "RecContentType=text/html", 12 "Referer=http://192.168.23.25:8080/tomd5/index.jsp", 13 "Snapshot=t124.inf", 14 "Mode=HTTP", 15 ITEMDATA, 16 "Name=courseId", "Value=1802", ENDITEM, 17 "Name=prizeID", "Value=432", ENDITEM, 18 "Name=r", "Value={time}", ENDITEM, 19 "Name=userId", "Value={userId}", ENDITEM, 20 "Name=tijiao", "Value=提交", ENDITEM, 21 LAST); 25 //lr_output_message("# sign： %s",lr_eval_string("{sign}")); 44 lr_rendezvous("all"); 45 lr_start_transaction("prizeDraw"); 46 web_submit_data("prizeDraw.do", 47 "Action=http://v2.pclady.com.cn:83/app/prize/prizeDraw.do?", 48 "Method=POST", 49 "RecContentType=text/html", 50 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1179607099f0978c1e9683677df6e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45de6dec9008490726636d27b43ba9c7/" rel="bookmark">
			React实战-一个非常棒的React与Material风格相结合的UI控件库（Material-UI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React实战-一个非常棒的React与Material风格相结合的UI控件库（Material-UI）
ReactJs提供了JSX、UI更新机制、组件化原则等底层支持，但是正如我们在所有的程序语言基础上搭建系统框架所面临的问题一样，很大程度上语言提供的是解析、编译、运行过程的后台调度等，真正实现一个应用往往由大量的三方控件或库完成。所以当我们长期使用一个框架后，往往陷入了框架的规则，忘记了语言的规则，在java中最明显的例子就SSH了，在项目整体架构成熟后，我们好像就在干配置的工作，不断的依据SSH的规则，维护着库内或各层间的关联。
但是如果不用框架，几乎是不可能的，因为各种框架或者库，是之前程序员的经验总结与积累，这也就是每个人在设计程序框架时需要面临的经典问题：是选用轮子还是造轮子的问题？甚至在选轮子时，依然存在苦恼，哪个轮子好的问题。
在ReactJs开发过程中，你可以选择任何你喜欢的组件，在http://react-component.github.io/badgeboard/，你可以找到各类ReactJs的组件。
但是目前为止，我依然认为Material-UI是一款你应该首先选择的UI控件库（http://www.material-ui.com/#/components/app-bar）主要原因有以下几点：
1.完全基于ReactJs
Material-UI是一款完全基于ReactJs的控件，采用的是ReactJs的原理实现，虽然在早期的版本中存在为了推出控件，采用了原始的数据流和控制流方式，但是从其版本更新来看，它在不断改造自己，是自己更ReactJS。
2.设计风格基于Material
Material是近年来流行的设计方式，推崇简洁、明快的设计风格，在Material-UI中蕴含了前卫的设计元素，够炫、够Cool。
3.控件丰富、涵盖所有典型场景
在选择控件时，我们希望一个库能涵盖所有典型场景，但往往会出现很多的三方库集成在一起的情形。采用Material-UI不能说涵盖了所有所需控件，但至少涵盖了所有典型场景。
4.活跃度高
选择控件一个重要的考虑因素是活跃度，活跃度高的意味着该控件经历着各类实战的考验，能及时更新bug，控件库的功能、性能更有保证。从github上我们可以看到参与的开发者和使用者均居高位。
5.版本更新频率高
版本更新频率高是个双刃剑，你可能庆幸下一个版本修改了你急需修改的bug，也可能因为下一个版本的实现方法改变了导致你要重新修改代码，但目前看来,Material-ui的版本变化处理修改bug外，均是是自己更reactjs。
6.同时支持SVG/Font Icon
7.设置样式简单
Material-ui不仅支持一般采用Css class或者在JSX中设置Inline Styles设置样式，也可以采用设置Themes的方式统一设置整个应用的样式。如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98905d16e3904b8d9965b3f5a51a416a/" rel="bookmark">
			HDU 5895 矩阵快速幂&#43;欧拉降幂公式&#43;指数循环节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：HDU5895 注意到题目的数据非常之大，并且递归之后求的指数幂非常之大，所以要先知道欧拉降幂公式: ,相当于形成了指数的循环节。 根据递推关系得到： 建立矩阵: 用矩阵快速幂求解出g(n*y)，之后再利用快速幂取模求出最后的结果
由于数据很大，过程中把数据开大，及时取模。
AC代码：
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include&lt;iostream&gt; #include &lt;cmath&gt; using namespace std; typedef long long LL; typedef unsigned long long ULL; const int N=4; LL n,x,y,s,mod; struct mat{ ULL m[N][N]; mat() {} mat unit(){ for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=N;j++) m[i][j]=i==j?1:0; } }; mat t; mat operator * (mat a,mat b){ //cout&lt;&lt;mod&lt;&lt;endl; mat res; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;=N;j++){ res.m[i][j]=0; for(int k=0;k&lt;N;k++){ res.m[i][j]+=a.m[i][k]*b.m[k][j]; if(res.m[i][j]&gt;mod) res.m[i][j]%=mod; } } return res; } mat operator ^ (mat res,LL n){ //矩阵快速幂 res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98905d16e3904b8d9965b3f5a51a416a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b84114e02132c8034094d59519433490/" rel="bookmark">
			HDU 5895 欧拉定理&#43;快速幂&#43;公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://acm.hdu.edu.cn/showproblem.php?pid=5895 题意： F[ x ]=F[ x-1 ] * 2 + F[ x-2 ] G[ x ]=∑F[ i ] 问 x^G[ n*Y ] % (s+1)
思路：之前BC有过类似的题目，这个题目看完了很后悔。。本来是应该可以A掉的。。
思路就是利用欧拉定理来让G变小先。。然后快速幂搞一下。。。
类似斐波那契数列一样。。打表试一试就发现 G[ N ] = F[n]*F[n+1]/2 （证明和斐波那契那个证明方法差不多，两遍同时×F[ n-1 ]）,移项累加就好。
所以就很愉快了，但是注意！！！
这里明显除以2是要求一下逆元的！但是逆元显然不一定存在，所以利用求任意逆元的方法，a/b mod c = a mod（b*c）/b
( 最后时间紧张加上基础不牢靠并没有想起来。。十分遗憾 。。。)
代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;vector&gt; using namespace std; typedef vector&lt;vector&lt;long long&gt; &gt; mat; long long M ; long long M2 ; mat mul(const mat &amp;A,const mat &amp;B){ mat C(A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b84114e02132c8034094d59519433490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1151a85cf5d372c2bba7816bbfb2a2fb/" rel="bookmark">
			ReadLock和WriteLock(读写锁)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ReadWriteLock也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个资源可以被多个线程同时读，或者被一个线程写，但是不能同时存在读和写线程。
使用场合 假设在程序中定义一个共享的数据结构用作缓存，它大部分时间提供读服务（例如：查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。
在没有读写锁支持的（Java 5 之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行 通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键字进行同步），这样做的目的是使读操作都能读取到正确的数据，而不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，而写操作时获取写锁即可，当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被 阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。
特性 ReentrantReadWriteLock的实现里面有以下几个特性
**1、公平性：非公平锁（默认）。**读线程之间没有锁操作，所以读操作没有公平性和非公平性。写操作时，由于写操作可能立即获取到锁，所以会推迟一个或多个读操作或者写操作。非公平锁的吞吐量要高于公平锁。（公平锁概念：公平锁利用AQS的CLH队列，释放当前保持的锁时，优先为等待时间最长的那个写操作分配写入锁）
**2、重入性：**读写锁允许读线程和写线程按照请求锁的顺序重新获取读取锁或者写入锁。只有写线程释放了锁，读线程才可以获取重入锁，写线程获取写入锁后可以再次获取读取锁，但是读线程获取读取锁后却不能获取写入锁。
**3、锁降级：**写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级特性，经典cache案例使用了锁降级
**4、锁升级：**读取锁是不能直接升级为写入锁的。因此获取一个写入锁需要先释放所有的读取锁，如果有两个读取锁试图获取写入锁，且都不释放读取锁时，就会发生死锁
**5、锁获取中断：**读取锁和写入锁都支持获取锁期间被中断
**6、条件变量：**写入锁提供了条件变量的支持，但是读取锁却不允许获取条件变量，否则会得到一个UnsupportedOperationExcetpion异常
**7、重入锁：**读取锁和写入锁的数量最大分别只能是65535
读写锁机制 读-读不互斥
读-写互斥
写-写互斥
示例代码：
import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest { private double data = 0; ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public void get(){ try { rwl.readLock().lock(); System.out.println("----Thread:"+Thread.currentThread().getName()+"----read first value:"+data); Thread.sleep(1000); System.out.println("----Thread:"+Thread.currentThread().getName()+"----read second value:"+data); rwl.readLock().unlock(); } catch (Exception e) { // TODO: handle exception } } public void put(){ try { rwl.writeLock().lock(); data = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1151a85cf5d372c2bba7816bbfb2a2fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1838a47ca6f372cf00e75f207d037e/" rel="bookmark">
			HDU-5895 Mathematician QSC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目大意：
已知f[0] = 0, f[1] = 1, f[i] = f[i-1] * 2 + f[i-2]，且g[n] = g[n-1] + f[n] * f[n]，现在给出n，y，x，s，问你x^(g[n*y]) mod (s + 1)的值为多少。
解题思路：
首先可以得到的是g[n] = f[n] * f[n+1] / 2
证明方式就是xjb打表加上猜加上数学归纳法，别问我怎么猜到的我是用了这个网站http://oeis.org/
因此g[n]可以很轻松的得到了。那么现在的问题就是a^b mod p的值应该怎么求
这里提供一份关于求解这个值的非常详细的博客：传送门
代码：
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; typedef pair&lt;LL, LL&gt; pi; LL euler(LL n) { LL ans = n; for (LL i = 2; i * i &lt;= n; ++i) { if (n % i == 0) { ans -= ans / i; while (n % i == 0) n /= i; } } if (n &gt; 1) ans -= ans / n; return ans; } LL fastMul(LL a, LL b, LL mod) { LL ans = 1; while (b) { if (b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1; a = (a * a) % mod; } return ans; } pi fastMatrix(LL n, LL mod) { LL t11, t12, t21, t22; LL bas[4] = {2, 1, 1, 0}; LL ans[4] = {1, 0, 0, 1}; while (n) { if (n &amp; 1) { t11 = ((ans[0] * bas[0]) % mod + (ans[1] * bas[2]) % mod) % mod; t12 = ((ans[0] * bas[1]) % mod + (ans[1] * bas[3]) % mod) % mod; t21 = ((ans[2] * bas[0]) % mod + (ans[3] * bas[2]) % mod) % mod; t22 = ((ans[2] * bas[1]) % mod + (ans[3] * bas[3]) % mod) % mod; ans[0] = t11; ans[1] = t12; ans[2] = t21; ans[3] = t22; } n &gt;&gt;= 1; t11 = ((bas[0] * bas[0]) % mod + (bas[1] * bas[2]) % mod) % mod; t12 = ((bas[0] * bas[1]) % mod + (bas[1] * bas[3]) % mod) % mod; t21 = ((bas[2] * bas[0]) % mod + (bas[3] * bas[2]) % mod) % mod; t22 = ((bas[2] * bas[1]) % mod + (bas[3] * bas[3]) % mod) % mod; bas[0] = t11; bas[1] = t12; bas[2] = t21; bas[3] = t22; } return make_pair(ans[0], ans[2]); } LL solve(LL n, LL y, LL x, LL s) { LL eul = euler(s + 1); pi tmp = fastMatrix(n * y, eul * 2); LL N = ((tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd1838a47ca6f372cf00e75f207d037e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8608f76beeb830d5cdd9f99da71b5ebb/" rel="bookmark">
			Spark编程技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark是一种强烈依赖内存的计算框架，结合其运行流程，可以有很多可以调优的地方
用reduceByKey 替代groupByKey 这两个转换都有shuffle过程发生，且都类似map reduce，但是reduceByKey会在map阶段会对相同的key进行聚合，极大的减少了map产生的数据量，进而减少了shuffle的数据量，提高了程序的执行效率 避免shuffle shuffle类算子会将多个节点的key，拉取到一个节点上，进行join或者聚合操作，代价很大。
关于缓存 如果一个rdd被多个rdd依赖，就要持久化该rdd，避免被生成多次，而持久化时又有一些小技巧，如下
用persist(MEMORY_ONLY_SER) 代替persist和cache persist的默认持久化类型是MEMORY_ONLY，该类型在内存中会缓存原始的对象，而MEMORY_ONLY_SER将对象序列化后再缓存，这样会节省大量的内存。因为Spark模型的各个阶段都会耗内存，而且现在计算的瓶颈一般不在CPU而在IO上，节省了内存。会让Spark其他阶段拥有更多的内存，从而减少了和磁盘的交互，进而加快作业的执行速度
内存不够时 内存不够时，使用 MEMORY_AND_DISK_SER
避免使用DISK_ONLY和后缀为_2的持久化方式 DISK_ONLY将rdd缓存在磁盘上，基于磁盘的读写会严重影响性能 后缀为_2的持久化方式，会将rdd复制一份副本，发送到其他节点上，数据复制和网络传输的性能开销较大
使用Kryo序列化 该种序列化方式会比默认的java序列化方式节省2到5倍的空间
分解一个job之中的transformation 尽量避免在一个transformation中处理所有的逻辑, 尽量分解成map, filter等之类的操作，这样程序会更容易理解
调低spark.memory.fraction 如果因为GC导致outofmemory，很可能是老年代的内存较小，可以调低该参数
包冲突 将spark自带的包设置成provided，这样就可以使用spark内核自带的相应类spark自带了很多包，比如org.json4s， guava等，因为这些包升级时没做向前兼容性，如果用户自己引入了这些包，很可能产生运行时异常。这个时候，有两种方式处理：不使用这些包，这样就将雷跳过去了；使用shade打包，改变包的名字，也可以将雷跳过去 yarn-client 选择了yarn-client模式, 因此是默认没有开启本地Driver的gc log的, 为了更好应对出错时debug, 建议在本地export 因此是默认没有开启本地 Driver 的 gc log 的, 为了更好应对出错时 debug, 建议在本地 export SPARK_SUBMIT_OPTS=" -Xloggc:tmp/gc_log -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDetails -XX:+PrintGCDateStamps -verbose:gc -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=10M " 查看调试信息 spark-submit --verbose 参考 Spark性能优化指南——基础篇 Spark性能优化指南——高级篇 Spark Tuning
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020713c882415a714c56a64cd0fe5f5e/" rel="bookmark">
			git detached from head
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天做git项目，出现了问题：工程一直处在detached from head state
git branch 之后显示：* detached xxxxxx
查询之后，知道了head指向了一个commitid了
这样提交代码是很危险的，因为它不在任何分支上
我一直不知道怎么切换到master分支上
用git checkout master之后，提醒：无法操作，无法切换到master。原因如下：
$ cd d://project/customerService/.git
就因为我在这下面操作的。所以一直无法切换到master
（大神们勿喷，确实是git小白，各种不懂）
$ cd d://project/customerService
在工程目录下，直接操作git checkout master 就切换到了master分支上了
提醒各位小白，一定要注意自己在什么分支上。
这几天学习了git，觉得git真是强大，它的分布式版本控制，可以防止文件的丢失，可以说你可以添加很多很多的分支，都是记录的文件的快照，而不是文件变更
我们可以在分支上更改自己想改的，然后合并到master上，然后再删除这个分支。都没事。git真是记录了所有文件的快照。
是因为看了这篇博文，给了我启发：http://hbiao68.iteye.com/blog/2055494
error:src refspec master does not match any
引起该错误的原因是目录中没有文件，空目录是不能提交上去的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a686e1b9c27ba481f70cda636ed4de1f/" rel="bookmark">
			大前端完整学习路线（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大前端完整学习路线（详解） 第一阶段： HTML+CSS: HTML进阶、CSS进阶、div+css布局、HTML+css整站开发、
JavaScript基础： Js基础教程、js内置对象常用方法、常见DOM树操作大全、ECMAscript、DOM、BOM、定时器和焦点图。
JS基本特效： 常见特效、例如：tab、导航、整页滚动、轮播图、JS制作幻灯片、弹出层、手风琴菜单、瀑布流布局、滚动事件、滚差视图。
JS高级特征： 正则表达式、排序算法、递归算法、闭包、函数节流、作用域链、基于距离运动框架、面向对象基础、
JQuery：基础使用 悬着器、DOM操作、特效和动画、方法链、拖拽、变形、JQueryUI组件基本使用。
第二阶段：HTML5和移动Web开发 HTML5： HTML5新语义标签、HTML5表单、音频和视频、离线和本地存储、SVG、Web Socket、Canvas.
CSS3: CSS3新选择器、伪元素、脸色表示法、边框、阴影、background系列属性改变、Transition、动画、景深和深透、3D效果制作、Velocity.js框架、元素进场、出场策略、炫酷CSS3网页制作。
Bootstrap: 响应式概念、媒体查询、响应式网站制作、删格系统、删格系统原理、Bootstrap常用模板、LESS和SASS。
移动Web开发： 跨终端WEB和主流设备简介、视口、流式布局、弹性盒子、rem、移动终端JavaScript事件、手机中常见JS效果制作、Zepto.js、手机聚划算页面、手机滚屏。
第三阶段：HTTP服务和AJAX编程 WEB服务器基础： 服务器基础知识、Apache服务器和其他WEB服务器介绍、Apache服务器搭建、HTTP介绍。
PHP基础： PHP基础语法、使用PHP处理简单的GET或者POST请求、
AJAX上篇： Ajax简介和异步的概念、Ajax框架的封装、XMLHttpRequest对象详细介绍方法、兼容性处理方法、Ajax框架的封装、Ajax中缓存问题、XML介绍和使用。
AJAX下篇： JSON和JSON解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和lazy-load技术、JQuery框架中的AjaxAPI、使用Ajax实现爆布流案例额。
第四阶段：面向对象进阶 面向对象终极篇： 从内存角度到理解JS面向对象、基本类型、复杂类型、原型链、ES6中的面向对象、属性读写权限、设置器、访问器。
面向对象三大特征： 继承性、多态性、封装性、接口。
设计模式： 面向对象编程思维、单例模式、工厂模式、策略模式、观察者模式、模板方法模式、代理模式、装饰者模式、适配器模式、面向切面编程。
第五阶段：封装一个属于自己的框架 框架封装基础： 事件流、冒泡、捕获、事件对象、事件框架、选择框架。
框架封装中级： 运动原理、单物体运动框架、多物体运动框架、运动框架面向对象封装。
框架封装高级和补充： JQuery框架雏形、可扩展性、模块化、封装属于传智自己的框架。
第六阶段：模块化组件开发 面向组件编程： 面向组件编程的方式、面向组件编程的实现原理、面向组件编程实战、基于组件化思想开发网站应用程序。
面向模块编程： AMD设计规范、CMD设计规范、RequireJS，LoadJS、淘宝的SeaJS。
第七阶段：主流的流行框架 Web开发工作流： GIT/SVN、Yeoman脚手架、NPM/Bower依赖管理工具、Grunt/Gulp/Webpack。
MVC/MVVM/MVW框架： Angular.js、Backbone.js、Knockout/Ember。
常用库： React.js、Vue.js、Zepto.js。
第八阶段：HTML5原生移动应用开发 Cordova： WebApp/NativeApp/HybirdApp简介、Cordova简介、与PhoneGap之间的关系、开发环境搭建、Cordova实战（创建项目，配置，编译，调试，部署发布）。
Ionic： Ionic简介和同类对比、模板项目解析、常见组件及使用、结合Angular构建APP、常见效果（下拉刷新，上拉加载，侧滑导航，选项卡）。
React Native： React Native简介、React Native环境配置、创建项目，配置，编译，调试，部署发布、原生模块和UI组件、原生常用API。
HTML5+： HTML5+中国产业联盟、HTML5 Plus Runtime环境、HBuilder开发工具、MUI框架、H5+开发和部署。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a686e1b9c27ba481f70cda636ed4de1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b54dc2655f1bf8d6e856db13a67b36/" rel="bookmark">
			HDU5895 Mathematician QSC(经典数论集合题）（一点点更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mathematician QSC
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others)
Total Submission(s): 142 Accepted Submission(s): 66
Problem Description
QSC dream of becoming a mathematician, he believes that everything in this world has a mathematical law.
Through unremitting efforts, one day he finally found the QSC sequence, it is a very magical sequence, can be calculated by a series of calculations to predict the results of a course of a semester of a student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b54dc2655f1bf8d6e856db13a67b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de284b4f6279641424e238ac0418d22/" rel="bookmark">
			hdu5895Mathematician QSC&#43;矩阵快速幂&#43;除法取余
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Description QSC dream of becoming a mathematician, he believes that everything in this world has a mathematical law.
Through unremitting efforts, one day he finally found the QSC sequence, it is a very magical sequence, can be calculated by a series of calculations to predict the results of a course of a semester of a student.
This sequence is such like that, first of all, f(0)=0,f(1)=1,f(n)=f(n−2)+2∗f(n−1)(n≥2) Then the definition of the QSC sequence is g(n)=∑ni=0f(i)2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de284b4f6279641424e238ac0418d22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f9784f09050a32cc0d90bd2ec624bd/" rel="bookmark">
			web_submit_data函数上传图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web_submit_data函数上传图片
通常loadrunner上传下载文件脚本不能通过录制来实现，录制上传脚本回放过程会出问题，主要原因在于上传文件的路径，了解了上传文件的原理之后，可以手工完成无法录制的脚本，以下为上传图片实例：
web_submit_data("CropZoomImgController.do", //请求路径 。 "Action=http://10.10.10.113:9080/Borrower/app/sale/core/Image/saveImage.do", //请求方法。 "Method=POST", //使用包含文件上传控件的表单。 "EncType=multipart/form-data", //引用链接。 "Referer=http://10.10.10.113:9080/Borrower/app/sale/core/Image/saveImage.do", //请求方式。 "Mode=HTTP", //请求参数。 ITEMDATA, "Name=borrowerId", "Value=MOR20151216002001", ENDITEM, "Name=FiledataFileName", "Value=A2", ENDITEM, "Name=appId", "Value=BOR20151216002001", ENDITEM, "Name=imaType", "Value=N1", ENDITEM, //上传文件路径 "Name=Filedata", "Value=E:\\picture\\A4-2.jpg", //上传文件时，添加此参数且要选择Yes。 "File=Yes", ENDITEM, LAST); 转载于:https://www.cnblogs.com/TestWorld/p/5880745.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0840a6e2b6a7d7bd68957ab9171009/" rel="bookmark">
			SWT display wave显示波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package plug_in_test; import java.util.ArrayList; import java.util.List; import java.util.Timer; import java.util.TimerTask; import org.eclipse.swt.SWT; import org.eclipse.swt.events.PaintEvent; import org.eclipse.swt.events.PaintListener; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.graphics.GC; public class TstDrawDisplay2 { /* * wave #1 * ********************************************** * /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ /\ / * / \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ * ********************************************** */ private static int[] wave1_data = new int[]{-100, 0, 100, 0, }; /* * wave #2 * ********************************************** * _ _ _ _ _ _ _ _ * / \ / \ / \ / \ / \ / \ / \ / * / \_/ \_/ \_/ \_/ \_/ \_/ \_/ * ********************************************** */ private static int[] wave2_data = new int[]{-100, 0, 100, 100, 0, -100 }; /* * wave #3 * ********************************************** * _ _ _ _ _ _ * _/ \_ _/ \_ _/ \_ _/ \_ _/ \_ _/ \_ * / \_/ \_/ \_/ \_/ \_/ \ * ********************************************** */ private static int[] wave3_data = new int[]{-100, 0, 0, 100, 100, 0, 0, -100, -100, 0, 0, 100, 100, 0, 0, -100,}; /* * wave #4 * ********************************************** * /\ /\ /\ /\ * / \ /\ / \ /\ / \ /\ / \ * / \ / \/ \ / \/ \ / \/ \ / * / \/ \/ \/ \/ * ********************************************** */ private static int[] wave4_data = new int[]{-200, -100, 0, 100, 200, 100, 0, -100, -200, -100, 0, 100, 0, -100, 0, 100, 200, 100, 0, -100 }; private static int timerCounter = 0; public static void main(String[] args) { final Display display = new Display(); final Shell shell = new Shell(display); shell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea0840a6e2b6a7d7bd68957ab9171009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44374af9d776abdb3f5850b00d714893/" rel="bookmark">
			P问题、NP问题、NPC问题（NP完全问题）、NPH问题和多项式时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 http://blog.csdn.net/k346k346/article/details/51026006
本文为博主吕吕(Dablelv)原创文章，欢迎转载，传播知识，请留言告知并注明出处。个人之言，请抱着怀疑的态度参考！
1.多项式时间复杂度 定义： 解决问题需要的时间与问题的规模之间是多项式关系。
多项式关系形如 O(nk) ，k为某个常数，n是问题的输入规模。例如，时间复杂度为O(nlog(n))、O(n^3)都是多项式时间复杂度。时间复杂度为O(n^log(n))、O(2^n)是指数时间复杂度，O(n!)是阶乘时间复杂度。像O(a^n)和O(n!)型的时间复杂度，它是非多项式级的，其复杂度计算机往往不能承受。
为什么多项式时间复杂度的定义形式是 O(nk) 呢，它的多项式的多项性体现在哪呢？
因为算法的时间复杂度的表达式 O(nk) 可以为 O(nk+nk−1) ，在表示时 O(nk)=O(nk+nk−1) ，取指数最高项保留作为时间复杂度的表达式，未删除低指数项就可以看出多项式的多项性了吧！当然，单项式也算作多项式。
注：图G的顶点个数称为图G的阶(Order)。
2.P问题 《算法导论》给出的定义：在多项式时间内可解的问题为P问题（Polynomial Problem，多项式问题）。
更为具体的是：P问题指可以在多项式时间内求解的问题，例如：时间复杂度为O(nlog(n))的快速排序和堆排序， O(n2) 的冒泡排序和直接选择排序算法都是P问题，也就是多项式时间算法。相反，时间复杂度为 O(nlogn) 、 O(2n) 的算法是指数时间算法。
3.NP问题 定义： NP问题（(Non-deterministic Polynomial Problem，非确定性多项式问题），指问题只能通过验证给定的猜测是否正确来求解。所谓多项式指的是验证猜测可在多项式时间内完成，所谓非确定性指的是问题只能通过验证猜测来解，而不能直接求解。
如Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点可在多项式时间内完成，但是找出一个Hamilton回路却要穷举所有可能性，不能直接求解。
又如大合数的质因数分解，没有给定的公式可直接求出一个合数的两个质因数是什么，但是验证两个数是否是质因数却可在多项式时间完成，所以它也是非确定性多项式问题，即NP问题。
之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。
简单的说，存在多项式时间的算法的一类问题，称之为P类问题；而像梵塔问题，推销员旅行问题等问题，至今没有找到多项式时间算法解的一类问题，称之为NP问题。同时，P类问题是NP问题的一个子集。也就是说，能多项式时间地解决一个问题，必然能多项式时间地验证一个问题的解。
3.1NP与P的关系 目前，人类还未解决的问题是：是否所有的NP问题都是P类问题，即P=NP?。这就是注明的世界七大数学难题之首。虽然这个问题尚未解决，但是，一个总的趋势和大方向是人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。
人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题（Non-deterministic Polynomial Complete Problem），也即所谓的 NPC问题。正是NPC问题的存在，使人们相信P≠NP。
4.NPC问题 4.1约化 为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”（Reduction）) 。
约化的概念： 约化的标准概念：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B，即可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。 如：一元一次方程可以“归约”为一元二次方程。
约化的性质： 约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。
约化的意义： 问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。
约化的要求： 我们所说的“可约化”指的是可“多项式时间地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。
4.2NPC问题 NPC问题是指满足下面两个条件的问题： （1）它是一个NP问题； （2）所有的NP问题都可以用多项式时间约化到它。
所以显然NP完全问题具有如下性质：它可以在多项式时间内求解，当且仅当所有的其他的NP完全问题也可以在多项式时间内求解。这样一来,只要我们找到一个NPC问题的多项式解，所有的NP问题都可以多项式时间内约化成这个NPC问题，再用多项式时间解决，这样NP就等于P了。
目前，NPC问题还没有找到一个多项式时间算法，因此我们就此可直观地理解，NPC问题目前没有多项式时间复杂度的有效算法，只能用指数级甚至阶乘级复杂度的搜索。
大多数人的观点对于 P类问题，NP类问题，NPC之间的关系可用下图表示（此图正确性有待验证）：
4.3第一个NPC问题 逻辑电路问题是第一个NPC问题。逻辑电路问题指的是这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44374af9d776abdb3f5850b00d714893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa01ce59479d3f78ae9613b4fc7d9a8/" rel="bookmark">
			Elasticsearch常用配置及性能参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cluster.name: estest 集群名称
node.name: “testanya” 节点名称
node.master: false 是否主节点
node.data: true 是否存储数据
index.store.type: niofs 读写文件方式 index.cache.field.type: soft 缓存类型
bootstrap.mlockall: true 禁用swap
gateway.type: local 本地存储
gateway.recover_after_nodes: 3 3个数据节点开始恢复
gateway.recover_after_time: 5m 5分钟后开始恢复数据
gateway.expected_nodes: 4 4个es节点开始恢复
cluster.routing.allocation.node_initial_primaries_recoveries:8 并发恢复分片数 cluster.routing.allocation.node_concurrent_recoveries:2 同时recovery并发数
indices.recovery.max_bytes_per_sec: 250mb 数据在节点间传输最大带宽 indices.recovery.concurrent_streams: 8 同时读取数据文件流线程
discovery.zen.ping.multicast.enabled: false 禁用多播 discovery.zen.ping.unicast.hosts:[“192.168.169.11:9300”, “192.168.169.12:9300”]
discovery.zen.fd.ping_interval: 10s 节点间存活检测间隔 discovery.zen.fd.ping_timeout: 120s 存活超时时间 discovery.zen.fd.ping_retries: 6 存活超时重试次数
http.cors.enabled: true 使用监控
index.analysis.analyzer.ik.type:”ik” ik分词
thread pool setting
threadpool.index.type: fixed 写索引线程池类型 threadpool.index.size: 64 线程池大小（建议2~3倍cpu数） threadpool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa01ce59479d3f78ae9613b4fc7d9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28cd3242c455803135eb648e91a6aae/" rel="bookmark">
			Java设计模式—组合模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合模式是一种常见的设计模式（但我感觉有点复杂）也叫合成模式，有时又叫做部分-整体模式，主要是用来描述部分与整体的关系。
个人理解：组合模式就是将部分组装成整体。
定义如下：
将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
通用类图如下：
组合模式的包含角色：
● Component 抽象构件角色
定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。
● Leaf 叶子构件
叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。
● Composite 树枝构件
树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。
通用源代码：
抽象构件 public abstract class Component { //个体和整体都具有的共享 public void do Something(){ //编写业务逻辑 } } 树枝构件 public class Composite extends Component { //构件容器 private Array List&lt;Component&gt; component Array List = new Array List&lt;Component&gt;() //增加一个叶子构件或树枝构件 public void add(Component component){ this.component Array List.add(component); } //删除一个叶子构件或树枝构件 public void remove(Component component){ this.component Array List.remove(component); } //获得分支下的所有叶子构件和树枝构件 public Array List&lt;Component&gt; get Children(){ return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28cd3242c455803135eb648e91a6aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f34aaffc64b4ca40a09ef37d2908c53/" rel="bookmark">
			GCC_RESET_STATUS Definition (check each platform SWI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QCAP
 GCC_RESET_STATUS = 0x23 → Secure Watchdog Bite
 GCC_RESET_STATUS = 0x13 → PMIC Abnormal Reset
 GCC_RESET_STATUS = 0x1B → TSENSE Reset (Temperature Sensor
Triggered Reset)
 GCC_RESET_STATUS = 0x0 → Non-MSM triggered Reset  GCC_RESET_STATUS = 0x13 → PMIC Abnormal Reset
 GCC_RESET_STATUS = 0x1B → TSENSE Reset (Temperature Sensor
Triggered Reset)
 GCC_RESET_STATUS = 0x0 → Non-MSM triggered Reset 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f77bdfdb42e9e63785c3619bfdfe17a/" rel="bookmark">
			SCP传输文件和断点续传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.上传文件 scp /tmp/test.tar root@192.168.1.190:/home/test.tar 2.下载文件 scp root@192.168.1.190:/home/test.tar /tmp/test.tar 3.上传整个目录 scp -r /tmp/testdir root@192.168.1.190:home 4.下载整个目录 scp -r root@192.168.1.190:home/testdir /tmp 5.断点续传 rsync -P --rsh=ssh /tmp/test.tar 192.168.1.190:/home/test.tar
6. 在后台运行, 退出shell进程不会退出
nohup /tmp/test.tar root@192.168.1.190:/home/test.tar
Ctrl+Z
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c190cbeeb4adf8b5ed90ba1671f5c8d/" rel="bookmark">
			解决vue的变量在settimeout内部效果失效方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、定义一个self暂存this
2、再改变变量的值，则生效啦
var self=this; this.toastrVal = inVal; this.loadState = true; this.noBg = bgState; setTimeout(function () { self.loadState = false; }, 3000) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2868be43c56e3092c09f5d460995a7c/" rel="bookmark">
			java中的继承(向上转型)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习完继承和多态后，了解到使用继承的一个好处。看下面的例子：
public class British extends People { public British(String name) { super(name); } } public class People { public String name; public People(String name){ this.name = name; } } public class American extends People { public American(String name) { super(name); } } public class Italian extends People { public Italian(String name) { super(name); } } public class Language { public void say(People people){ System.out.println(people.name + " say language"); } //	public void ameSay(American a){ //	System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2868be43c56e3092c09f5d460995a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cdf926ecfd6ce2b5ef32ff7c9a14881/" rel="bookmark">
			C#实现调用Java类中方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思路： 用C#实现调用Java编写的类中的方法；重点是将Java编写的程序打包成Jar，然后使用开源工具(IKVM)将其转化成DLL控件，在.NET环境下调用。
1.打开Eclipse编写Java应用程序，然后将其打包成Jar包(方法不详细列出)（也可以在cmd下使用命令进行）
2.到IKVM官方网站下载IKVM需要的组件 http://www.ikvm.net/ 下载ikvmbin-XX.zip文件解压进入BIN文件夹 百度网盘:链接：http://pan.baidu.com/s/1kVzBAuV 密码：i12b
3.将转化的JAR包通过IKVM工具(在BIN目录下)转化为DLL控件。 在cmd下使用命令ikvmc -out:Hello.dll com.Hello.jar即可转化
4.新建C#项目，将ikvm-XX.zip解压出来的文件路径的bin目录下找到以下3个DLL控件IKVM.OpenJDK.Core.dll ，IKVM.Runtime.dll ，IKVM.Runtime.JNI.dll 将它们添加引用添加到C#项目中。然后添加自己生成的Hello.dll控件。
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; //引入命名空间(Java中包的名字到C#这边会转化成namespace) using com;
namespace WindowsFormsHello { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void btnClick_Click(object sender, EventArgs e) { //Java中的类 Hello hello = new Hello(); MessageBox.Show(hello.SayHello()); } } }
点击界面上的按钮,就会输出Hello,Java的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd7f229c6a6f1d735d83233ab86d1cc/" rel="bookmark">
			HDU1695 GCD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目重现 Given 5 integers: a,b,c,d,k , you’re to find x∈[a,b],y∈[c,d] that gcd(x,y)=k . gcd(x,y) means the greatest common divisor of x and y. Since the number of choices may be very large, you’re only required to output the total number of different number pairs. Please notice that, (x=5,y=7) and (x=7,y=5) are considered to be the same.
You can assume that a=c=1 in all test cases.
Input The input consists of several test cases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd7f229c6a6f1d735d83233ab86d1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec35ef289b46683d85f86136945d3606/" rel="bookmark">
			HDU2866 Special Prime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目重现 Give you a prime number p , if you could find some natural number (0 is not inclusive) n and m , satisfy the following expression: n3+p∗n2=m3 We call this p a “Special Prime”. AekdyCoin want you to tell him the number of the “Special Prime” that no larger than L. For example: If L=20 13+7∗12=23 83+19∗82=123 That is to say the prime number 7, 19 are two “Special Primes”.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec35ef289b46683d85f86136945d3606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac3ba9ca6e2499823c89d2711966ff3/" rel="bookmark">
			Js获取  数组或对象  的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Javascript 计算Object的长度 获取数组长度比较简单
Var arr=[“as”,”da”];
arr.length不用加();
在我们日常开发中，对象的使用频率很高，我们计算数组的长度是非常方便的，但是如何计算对象的长度呢？
假如我们有一个图书馆的项目，项目中有一组图书和作者，像下面这样：
1var bookAuthors = { 2 "Farmer Giles of Ham":"J.R.R. Tolkien", 3 "Out of the Silent Planet":"C.S. Lewis", 4 "The Place of the Lion":"Charles Williams", 5 "Poetic Diction":"Owen Barfield" 6}; 我们分析现在的需求，我们给一个API发送数据，但是书的长度不能超过100，因此我们需要在发送数据之前计算在一个对象中总共有多少本书。那么我们总怎么做呢？我们可能会这样做：
01function countProperties (obj) { 02 varcount = 0; 03 04 for(var property in obj) { 05 if(Object.prototype.hasOwnProperty.call(obj, property)) { 06 count++; 07 } 08 } 09 10 returncount; 11} 12 13var bookCount = countProperties(bookAuthors); 14 15// Outputs: 4 16console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac3ba9ca6e2499823c89d2711966ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd69eab46ae4cf1cb3bff6d6a150c78/" rel="bookmark">
			Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明出处： http://kyang.cc/ 栈是什么？栈有什么作用？ 首先，栈 (stack) 是一种串列形式的 数据结构。这种数据结构的特点是 后入先出 (LIFO, Last In First Out)，数据只能在串列的一端 (称为：栈顶 top) 进行 推入 (push) 和 弹出 (pop) 操作。根据栈的特点，很容易的想到可以利用数组，来实现这种数据结构。但是本文要讨论的并不是软件层面的栈，而是硬件层面的栈。
大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈/出栈 的操作。例如在 ARM 架构上，R13 (SP) 指针是堆栈指针寄存器，而 PUSH 是用于压栈的汇编指令，POP 则是出栈的汇编指令。
【扩展阅读】：ARM 寄存器简介
ARM 处理器拥有 37 个寄存器。 这些寄存器按部分重叠组方式加以排列。 每个处理器模式都有一个不同的寄存器组。 编组的寄存器为处理处理器异常和特权操作提供了快速的上下文切换。
提供了下列寄存器： - 三十个 32 位通用寄存器： - 存在十五个通用寄存器，它们分别是 r0-r12、sp、lr - sp (r13) 是堆栈指针。C/C++ 编译器始终将 sp 用作堆栈指针 - lr (r14) 用于存储调用子例程时的返回地址。如果返回地址存储在堆栈上，则可将 lr 用作通用寄存器 - 程序计数器 (pc)：指令寄存器 - 应用程序状态寄存器 (APSR)：存放算术逻辑单元 (ALU) 状态标记的副本 - 当前程序状态寄存器 (CPSR)：存放 APSR 标记，当前处理器模式，中断禁用标记等 - 保存的程序状态寄存器 (SPSR)：当发生异常时，使用 SPSR 来存储 CPSR
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dd69eab46ae4cf1cb3bff6d6a150c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dad02c6b707dfbfb73793b86972e787/" rel="bookmark">
			MyBatis——动态SQL讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis的动态SQL是基于OGNL表达式的，它可以帮助我们方便的在SQL语句中实现某些逻辑。 MyBatis中用于实现动态SQL的元素主要有：
ifwheresetchoose（when，otherwise）trimforeach 1、if标签 if标签可用在许多类型的sql语句中，我们以查询为例。首先看一个很普通的查询：
&lt;!-- 查询学生list，like姓名 --&gt; &lt;select id="getStudentListLikeName" parameterType="StudentEntity" resultMap="studentResultMap"&gt; SELECT * from STUDENT_TBL ST WHERE ST.STUDENT_NAME LIKE CONCAT(CONCAT('%', #{studentName}),'%') &lt;/select&gt; 但是此时如果studentName为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。 参数为实体类StudentEntity。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。
&lt;!-- 2 if(判断参数) - 将实体类不为空的属性作为where条件 --&gt; &lt;select id="getStudentList_if" resultMap="resultMap_studentEntity" parameterType="liming.student.manager.data.model.StudentEntity"&gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.STUDENT_PHOTO, ST.CLASS_ID, ST.PLACE_ID FROM STUDENT_TBL ST WHERE &lt;if test="studentName !=null "&gt; ST.STUDENT_NAME LIKE CONCAT(CONCAT('%', #{studentName, jdbcType=VARCHAR}),'%') &lt;/if&gt; &lt;if test="studentSex != null and studentSex != '' "&gt; AND ST.STUDENT_SEX = #{studentSex, jdbcType=INTEGER} &lt;/if&gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dad02c6b707dfbfb73793b86972e787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5fb027d2f810d310693b7417a2ae86/" rel="bookmark">
			mybatis——select、insert、update、delete
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、select &lt;!-- 查询学生，根据id --&gt; &lt;select id="getStudent" parameterType="String" resultMap="studentResultMap"&gt; SELECT ST.STUDENT_ID, ST.STUDENT_NAME, ST.STUDENT_SEX, ST.STUDENT_BIRTHDAY, ST.CLASS_ID FROM STUDENT_TBL ST WHERE ST.STUDENT_ID = #{studentID} &lt;/select&gt; 这条语句就叫做‘getStudent，有一个String参数，并返回一个StudentEntity类型的对象。 注意参数的标识是：#{studentID}。
select 语句属性配置细节： 属性描述取值默认id在这个模式下唯一的标识符，可被其它语句引用parameterType传给此语句的参数的完整类名或别名resultType语句返回值类型的整类名或别名。注意，如果是集合，那么这里填写的是集合的项的整类名或别名，而不是集合本身的类名。（resultType 与resultMap 不能并用）resultMap引用的外部resultMap 名。结果集映射是MyBatis 中最强大的特性。许多复杂的映射都可以轻松解决。（resultType 与resultMap 不能并用）flushCache如果设为true，则会在每次语句调用的时候就会清空缓存。select 语句默认设为falsetrue/falsefalseuseCache如果设为true，则语句的结果集将被缓存。select 语句默认设为falsetrue/falsefalsetimeout设置驱动器在抛出异常前等待回应的最长时间，默认为不设值，由驱动器自己决定正整数未设置fetchSize设置一个值后，驱动器会在结果集数目达到此数值后，激发返回，默认为不设值，由驱动器自己决定正整数驱动器决定statementTypestatement，preparedstatement，callablestatement。预准备语句、可调用语句STATEMENT、PREPARED、CALLABLEPREPAREDresultSetTypeforward_only、scroll_sensitive、scroll_insensitive 只转发，滚动敏感，不区分大小写的滚动FORWARD_ONLY、SCROLL_SENSITIVE、SCROLL_INSENSITIVE驱动器决定 二、insert 一个简单的insert语句：
&lt;!-- 插入学生 --&gt; &lt;insert id="insertStudent" parameterType="StudentEntity"&gt; INSERT INTO STUDENT_TBL (STUDENT_ID, STUDENT_NAME, STUDENT_SEX, STUDENT_BIRTHDAY, CLASS_ID) VALUES (#{studentID}, #{studentName}, #{studentSex}, #{studentBirthday}, #{classEntity.classID}) &lt;/insert&gt; insert可以使用数据库支持的自动生成主键策略，设置useGeneratedKeys=”true”，然后把keyProperty 设成对应的列，就搞定了。比如说上面的StudentEntity 使用auto-generated 为id 列生成主键.
&lt;insert id="insertStudent" parameterType="StudentEntity" useGeneratedKeys="true" keyProperty="studentID"&gt; 推荐使用这种用法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff5fb027d2f810d310693b7417a2ae86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fe48099457becadb262a277a9674d3/" rel="bookmark">
			Java对象和引用变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于引用变量的深层含义，未必在初学的时候就能深刻理解，
所以理解好下面这两句话的真正含义非常重要
Case cc=new Case(); Case cc; cc=new Case(); 1.先搞清楚什么是堆，什么是栈。
Java开辟了两类存储区域，对比二者的特点
存储区域存储内容优点缺点回收栈基本类型的变量和对象的引用变量存取速度比堆要快，仅次于寄存器，栈数据可以共享存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量当超过变量的作用域后，Java会自动释放掉该变量,内存空间可以立即被另作他用堆由new等指令创建的对象和数组可以动态地分配内存大小，生存期也不必事先告诉编译器由于要在运行时动态分配内存，存取速度较慢由Java虚拟机的自动垃圾回收器来回收不再使用的数据 堆栈的存储特点决定了其中存储的数据类型。
注意，栈内存储的除了基本类型的变量（float， int 这种类型的变量）还会存储对象的引用变量。java中，引用变量实际上是一个指针，它指向的是堆内存中对象实例。
引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。
2.给引用变量赋值
回过头再来看代码
实际上里面分解成了四个步骤。
Case cc; '''在栈内存里面开辟了空间给引用变量cc，这时cc=null''' cc=new Case(); ''' 1. new Case()在堆内存里面开辟了空间给Case类的对象，这个对象没有名字 2. Case()随即调用了Case类的构造函数 3. 把对象的地址在堆内存的地址给引用变量cc ''' 这样我们就明确了：
Java中，这里的“=”并不是赋值的意思，而是把对象的地址传递给变量；对象创建出来，其实连名字都没有，因此必须通过引用变量来对其进行操作。 为了形象地说明对象、引用及它们之间的关系，可以做一个或许不很妥当的比喻。对象好比是一只很大的气球，大到我们抓不住它。引用变量是一根绳， 可以用来系汽球
紧接着就会问，引用变量是怎么传递的呢？
这就涉及到Java唯一的参数传递方式——按值传递
看下面一段代码：
public class ObjectRef { '''基本类型的参数传递''' public static void testBasicType(int m) { System.out.println("m=" + m);//m=50 m = 100; System.out.println("m=" + m);//m=100 } '''参数为对象，不改变引用的值''' '''s即sMain指向的对象执行了append方法，在原来的字符串上加了段“_add”''' public static void add(StringBuffer s) { s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80fe48099457becadb262a277a9674d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6a6b320e620835d2480004ded599a1/" rel="bookmark">
			JS_Ajax基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一:Ajax ajax 的全称是Asynchronous(异步) JavaScript and XML 在不刷新页面的情况下从服务器获取，提交数据的一种数据交互方式;
二：Ajax使用步骤概括
//1：创建Ajax对象 var xhr; //浏览器兼容问题解决 if(window.XMLHttpRequest){ xhr = new XMLHttpRequest(); }else{ xhr = new ActiveXObject('Microsoft.XMLHTTP'); } //或者 var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject('Microsoft XMLHTTP'); //2：配置 Ajax请求地址 xhr.open('get','index.xml',true); //3：发送请求 xhr.send(); //4:接收服务器返回数据 xhr.onreadysatechange=function(){ if(xhr.readySates==4&amp;&amp;xhr.status==200) console.log(xhr.responsetXML) } 三：Ajax使用步骤分析：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script&gt; //网络数据请求工具 ，数据类型一般有：(json|xml) //如何拿：创建对象+配置方法open+send请求发送给服务器 //监听数据状态， onreadystatechange 判断状态，服务器默认get请求|若用POST请求出错500，请求方式由服务器来定， //一:创建Ajax对象 // 1.1定义变量，用来保存创建出的对象，(XMLHttpRequest); var xhr; //1.2：根据浏览器支持标准。创建对象。 //判断当前浏览器是否具备XMLHttpRequest if(window.XMLHttpRequest){ xhr = new XMLHttpRequest(); }else{ //IE5|6|7 使用ActiveXobject创建 //Ajax组件放在ActiveXObject组件库中，需传入'Miscrosoft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6a6b320e620835d2480004ded599a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd2e6c8738279d23f8bcc78069e9b77/" rel="bookmark">
			Visual studio 2015（VS2015）的下载和安装，以及安装VS2015中的C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容如下：
1. VS2015下载
2. VS2015安装 3. VS2015安装C++的内容 作者：大曲曲
邮箱：xiaoxia.qu@foxmail.com
本文最终目标：要实现VS2015+QT5+OpenCV3开发环境搭建
1. VS2015下载 Visual studio官方网站：https://www.visualstudio.com/
Visual studio下载：https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx
官网安装程序所在的页面如下图所示：
主要包含的软件如下所示：
（1）VisualStudio Community 2015简体中文版（社区版，针对个人免费）
（2）VisualStudio Professional 2015简体中文版（专业版）
（3）VisualStudio Enterprise 2015简体中文版（企业版）
个人学习下载社区版即可，如下图所示：
点击下载之后，下载完成得到如下的软件安装包：
2. VS2015安装 第1步：官网下载社区版，双击exe文件后，显示如下：
第2步：点击“安装”
问题：这里会出现一个问题如下,
问题：visual studio 安装包丢失或损坏
原因：因为没有翻墙，所以点击exe以后，没法下载安装包。建议使用VPN翻墙后安装。
也可能是我在校园网络，限制比较多，需要翻墙才能安装。如果没有此问题就直接继续安装就好啦。
第3步：漫长的等待
翻墙后重新点击exe文件，再点击安装，重新开始安装。然后就是漫长的等待。等待时间比较长，要在线获取安装包。
第4步：结束啦，打开VS2015界面如下。
3. VS2015安装C++的内容 因为选了默认的安装，安装完发现主要是C#的内容，C++的内容没有，于是需要继续安装C++的内容。
问题描述：VS2015中没有C++编程的部分。
解决方案如下：
（1）打开VS2015后【文件】→【新建】→【项目】，出现的内容如下所示：
（2）双击【安装通用Windows平台工具】，出现如下界面
（3）漫长的安装过程，慢慢等待。 备注：如果您的网络和我的一样，没法找到安装包。那您也还是需要翻墙，否则会出现找不到安装包
（4）安装完成
（5）重新打开VS2015，【文件】→【新建】→【项目】，出现的内容如下所示： 安装完成，如上图所示有C++啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e8438bceb0e491c0637866fae995ec/" rel="bookmark">
			漫步微积分二十九——微积分基本定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前为止，我们通过逼近和的极限，得到了一个相当复杂的连续函数定积分的定义， ∫baf(x)dx=limmax Δxk→∞∑k=1nf(x∗k)Δxk(1) 之前我们已经用这个定义计算了一些简单的积分，例如 ∫b0xdx=b22,∫b0x2dx=b33,and∫b0x3dx=b44(2) 这些计算有两个目的：通过提供一些逼近和的直观经验来强调积分的基本性质，并且这种方法得到的极限值可以作为计算其他积分的实用工具。那么，我们可以利用极限和的方方求解下面更复杂的积分吗？ ∫10x47+x5−−−−−√3dxand∫21(1+1x)4dxx2(3) 这显然是不可能的，所以我们该何去何从呢？显然我们需要的是一种更高效、更强大的计算积分方法，而这种方法就是牛顿和莱布尼兹的想法。
牛顿-莱布尼兹解决(1)那样积分问题的计算方法乍一看似乎是自相矛盾的。为了解决这个问题，我们用更难的问题来替换它。我们不求解图1左那样固定的面积，而是图1右边变化的面积，图像右边的边界是可以移动的，这样的话面积就是 x 的函数。面积函数用A(x)表示，那么显然左边图中 A(a)=0,A(b) 表示固定的面积。我们的目标是找到一个 A(x) 的显示公式，然后通过设置 x=b 来确定所需的面积。在这个过程中有几个步骤，为了清楚起见，我们单独考虑。 图1 步骤1：我们通过建立重要的事实 dAdx=f(x)(4) 开始。这是说面积 A 关于x的变化率等于区域右边界的长度。为了证明这个命题，我们必须考虑导数的定义 dAdx=limΔx→0A(x+Δx)−A(x)Δx 现在 A(x) 是图像下边 a,x 之间的面积， A(x+Δx) 是 a,x+Δx 之间的面积。因此，分子 A(x+Δx)−A(x) 是 a,x+Δx 之间的面积(看图2中阴影部分的面积)。很容易看出面积等于有着相同底，高为 f(x¯) 的矩形面积，其中 x¯ 是 x,x+Δx 之间的某个点。由它我们继续(4)的证明： dAdx=limΔx→0A(x+Δx)−A(x)Δx=limΔx→0f(x¯)ΔxΔx=limΔx→0f(x¯)=f(x) 利用到 f(x) 是连续函数。为了更加详细的解释最后一步，我们指出 Δx→0 等价于 x+Δx→x ；因为 x¯ 位于 x,x+Δx 之间，所以 x¯→x ，现在利用函数的连续性得 f(x¯)→f(x) 图2 步骤2：方程(4)告诉我们，找到面积函数 A(x) 就能实现我们的目标。根据(4)， A(x) 是函数 f(x) 的反导之一。但是，如果 F(x) 是任何一个 f(x) 的反导，根据前面不定积分的知识我们有 A(x)=F(x)+c(5) c 是常数值。为了确定c，我们令 x=a ，从而得到 A(a)=F(a)+c ；但是因为 A(a)=0 ，从而得出 c=−F(a) 。因此 A(x)=F(x)−F(a)(6) 就是需要的公式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85e8438bceb0e491c0637866fae995ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b590174803b310c1c8e7569b678dae/" rel="bookmark">
			java中String类为什么要设计成不可变的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是不可变？
String不可变很简单，如下图，给一个已有字符串“abcd”第二次赋值成"abced",不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。
2.String为什么不可变？
翻开JDK源码，java.lang.String类起手前三行，是这样写的：
public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { /** String本质是个char数组. 而且用final关键字修饰.*/ private final char value[];首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[]数组，而且是用final修饰的。final修饰的字段创建以后就不可改变。 有的人以为故事就这样完了，其实没有。因为虽然value是不可变的，也只是value这个引用地址不可变。挡不住Array数组是可变的事实。
也就是说Array变量只是stack上的一个引用，数据的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。看这个这个例子，
final int[] value={1,2,3} int[] another={4,5,6}; value = another;//编译器报错，final不可变 value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果直接对数组元素动手，分分钟搞定。 final int[] value={1,2,3}; value[2]=100;//这时候数组里已经是{1,2,100}所以String是不可变，关键是因为SUN公司的工程师，在后面所有String的方法里很小心地没有去动Array里的元素，没有暴露内部成员字段。private final char value[]这一句里，private的私有访问权限的作用都比final大。而且设计师还很小心地反整个String设计成final禁止继承，避免被其他人继承后破坏。所以String是不可变的关键在于底层的实现，而不是一个final。考验的是工程师构造数据类型，封装数据的功力。 3.不可变有什么好处？
这个最简单的原因，就是为了安全。看下面这个场景，一个函数appendStr()在不可变的String参数后面加上一段“bbb”后返回。appendSb()负责在可变的StringBuilder后面加"bbb"。
Class Test{ //不可变的String public static String appendStr(String s){ s+="bbb"; return s; } //可变的StringBuilder public static StringBuilder appendSb(StringBuilder sb){ return sb.append("bbb"); } public static void main(String[] args){ String s = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b590174803b310c1c8e7569b678dae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f238a107ae9b01cf003c72f782a69e4a/" rel="bookmark">
			md5解析出的结果不一致的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：md5在不同的环境下（例如：eclipse或intellij或tomcat下跑同样的代码），md5后的值不一样
解决方法：在参数转成字节的时候，统一字符集，下面方法红色部份
public static String MD5(String input) {
try {
// 获得MD5摘要算法的 MessageDigest 对象
MessageDigest mdInst = MessageDigest.getInstance("MD5");
// 使用指定的字节更新摘要
mdInst.update(input.getBytes("utf-8"));
// 获得密文
byte[] md = mdInst.digest();
// 把密文转换成十六进制的字符串形式
StringBuffer hexString = new StringBuffer();
// 字节数组转换为 十六进制 数
for (int i = 0; i &lt; md.length; i++) {
String shaHex = Integer.toHexString(md[i] &amp; 0xFF);
if (shaHex.length() &lt; 2) {
hexString.append(0);
}
hexString.append(shaHex);
}
return hexString.toString();
} catch (NoSuchAlgorithmException e) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f238a107ae9b01cf003c72f782a69e4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69319c9a76c0087917f474bcc7d4564a/" rel="bookmark">
			2014 ACM/ICPC Xi&#39;an Regional I - International Collegiate Routing Contest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目重现 You may know that Bluegao University (formly Bluey University) is famous of networking technology. One day, their headmaster Yuege received a special router, along with a task about routing table. In this problem, routing table is a (probably) big table with several items, each item represents a subnet. The router has limited function, it can only deal with two next-hops and one main routing table. Packets will be send to next hop A if there exists a subnet containing the destination of the packet in the main outing table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69319c9a76c0087917f474bcc7d4564a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9766f9f809b0806034b382d5786281ed/" rel="bookmark">
			Android解析JSON数据几种方式对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Json介绍 Json(JavaScript Object Natotion)是一种轻量级的数据交换格式，具有良好的可读性和便于快速编写的特性，主要用于传送数据。Json是一种取代Xml的数据结构，相比于xml更小巧，从而减少数据传输流量和占用的带宽。
Json语法
{ } 表示对象
[ ] 表示数组
" " 表示值或属性
: 表示前面是key后面是value，value可以是字符串、数字或者另一个数组或对象
举个例子 {"name":"tom"},表示属性名为name,值是tom。[ {"name":"tom"}, {"name":"jack"}] 这个表示2个对象的数组，等价于{"name":["tom","jack"]}这是一个拥有name数组的对象。
传统方式（使用org.json包） 下面给出生成json字符串和解析json字符串的方法。
/** * 将对象转换成json数据 * @param user * @return */ public static String buildJson(User user) { try { JSONObject juser = new JSONObject(); juser.put("name", user.getName()); juser.put("pwd",user.getPwd()); return juser.toString(); }catch (JSONException e) { Log.e("JSON_ERROR",e.getMessage()); } return null; } /** * 将json数据转换成对象 * @param json * @return */ public static User getUser(String json) { JSONTokener jsonTokener = new JSONTokener(json); try { JSONObject user = (JSONObject) jsonTokener.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9766f9f809b0806034b382d5786281ed/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/264/">«</a>
	<span class="pagination__item pagination__item--current">265/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/266/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>