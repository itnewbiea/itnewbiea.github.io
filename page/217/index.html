<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802f375982b1fe8d291a074b5e6ce8ab/" rel="bookmark">
			AI Studio 配置 mmdetection 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI Studio 配置 mmdetection 环境 首先进入 AI Studio 的黑窗，按如下步骤操作（不要在 notebook 中操作）
一、conda 换源： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes 二、安装 pytorch 1、先使用 nvcc -V 查看 cuda 版本
可以看到 cuda 版本为 9.2
2、创建虚拟环境
conda create -n mmdet python=3.7 conda init 关闭黑窗并重新打开，并运行：
conda activate mmdet 此时你会进入mmdet的虚拟环境中。（如下图）
3、安装 pytorch
conda install pytorch torchvision cudatoolkit=9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802f375982b1fe8d291a074b5e6ce8ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed68032fd0b851f0feab10044fab04b8/" rel="bookmark">
			xbk全备与恢复过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 安装依赖包 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL libev
2下载、安装XBK wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm yum -y install percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm 3 xbk全备 innobackupex --user=root --password=123456 --no-timestamp /data/backup/full_`date +%F` 模拟数据目录被删 4 恢复备份前，数据处理准备 [root@db01 ~]# innobackupex --apply-log /data/backup/xbk/full_`date +%F` 5 将备份数据移动到数据目录下，并授权 [root@db01 /data/backup/full_2020-05-12]# cp -a ./* /data/mysql/ [root@db01 /data/backup/full_2020-05-12]# chown -R mysql.mysql /data 6 启动数据库 这里报错是因为配置文件/etc/my.cnf指定了错误日志和二进制日志的目录，但是rm -rf /data/mysql/* 把指定的文件目录删了
所以这里要手动创建出来
7重启数据库，连接登录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583f4cc9db8a6c533db0b0295a77d948/" rel="bookmark">
			【PyQt5】{12} —— 连接带参数的槽函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接带参数的槽函数 连接带参数的槽函数，必须传入一个函数对象，而不是函数的调用结果，因此使用lambda把函数封装成函数对象。 # -*- coding: utf-8 -*- """ Created on Sat May 9 12:16:58 2020 @author: Giyn """ import sys from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QPushButton, QVBoxLayout class Simple_Window(QWidget): def __init__(self): super(Simple_Window, self).__init__() # 使用super函数可以实现子类使用父类的方法 self.label = QLabel("I am the original Label", self) # self是指定的父类Simple_Window，表示QLabel属于Simple_Window窗口 self.button = QPushButton("Button", self) self.button.clicked.connect(lambda: self.change_label("I am the changed Label")) # 此处要使用匿名函数把函数封装成函数对象 self.v_layout = QVBoxLayout() # 实例化一个QVBoxLayout对象 self.v_layout.addWidget(self.label) self.v_layout.addWidget(self.button) self.setLayout(self.v_layout) # 调用窗口的setLayout方法将总布局设置为窗口的整体布局 def change_label(self, text): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583f4cc9db8a6c533db0b0295a77d948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d049bbe5ae4ff53a61773dafa7f974/" rel="bookmark">
			MPC算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MPC算法
一. 引言
在工程技术方面，MPC全称可指Model Predictive Control模型预测控制（又称RHC, Receding Horizon ）。
模型预测控制算法
一种进阶过程控制方法，自1980年以来开始在化工炼油等过程工业得到应用，并在经济领域开始得到应用。
MPC是一种多变量控制策略，其中涉及了：
过程内环动态模型；控制量的历史数值；在预测区间上的一个最优值方程J。最优控制量可由以上各量求出。
MPC最大的特点在于，相对于LQR控制而言，MPC可以考虑空间状态变量的各种约束，而LQR，PID等控制只能够考虑输入输出变量的各种约束。
MPC可应用于线性和非线性系统。
在当今过程控制中，PID当然是用的最多的控制方法，但MPC也超过了10%的占有率。MPC是一个总称，有着各种各样的算法。其动态矩阵控制（DMC）是代表作。DMC采用的是系统的阶跃响应曲线，其突出的特点是解决了约束控制问题。那么是DMC是怎么解决约束的呢？在这里只给出宏观的解释，而不做详细的说明。DMC把线性规划和控制问题结合起来，用线性规划解决输出约束的问题，同时解决了静态最优的问题，一石二鸟，在工业界取得了极大的成功。
如下图所示为一个MIMO系统u1,u2输入与y1,y2输出相互影响。如果使用PID控制的话，每一个子系统单独设计一个PID控制器，两个相互影响的子系统没有任何的交联，使得系统难以设计，如果像图二一样设计一个较大的系统，则参数较多难以实现，而使用MPC控制器的话可以较好的解决两种问题，综合相互间的影响来设计参数。
二. 作用机理
MPC作用机理描述为：在每一个采用时刻，根据获得的当前测量信息，在线求解一个有限时间开环优化问题，并将得到的控制序列的第一个元素作用于被控对象。在下一个采样时刻，重复上述过程：用新的测量值作为此时预测系统未来动态的初始条件，刷新优化问题并重新求解
。
即MPC算法包括三个步骤：
（1）预测系统未来动态；
（2）（数值）求解开环优化问题；
（3）将优化解的第一个元素（或者说第一部分）作用于系统
这三步是在每个采样时刻重复进行的，且无论采用什么样的模型，每个采样时刻得到的测量值都作为当前时刻预测系统未来动态的初始条件
在线求解开环优化问题获得开环优化序列是MPC和传统控制方法的主要区别，因为后者通常是离线求解一个反馈控制律，并将得到的反馈控制律一直作用于系统。
在这里给出两点说明：
1.MPC是一个反馈控制策略，但是之前不是说将得到的控制序列中的第一个元素作用于被控对象，求解开环问题。那么哪来的反馈呢？
实际上在下一个采样周期，下一时刻的测量值又被使用上了，用下一时刻的测量值求解下一时刻的控制值。故这是一个反馈控制策略
2.传统的控制方法为什么被称为离线控制？
设计变阻器应有的级数来达到控制并励直流电动机启动的例子，那么如何看的出来是离线控制呢？其实很简单，在起始的时候就已经把每级电阻值就给定出来了，但是实际上是否能如理论计算的这样呢?比如我电压突然受到了扰动了怎么办？那么这个计算的每级电阻值肯定不对了啦，但是传统的控制方法对此确是无能为力的，因为每级启动电阻在最早的时候已经计算好了的。
三. MPC的基本特点
不管是何种算法，他们的基本特点都是：基于模型的预测、滚动优化和前馈-反馈的控制结构。
1.基于模型的预测
在MPC算法中，需要一个描述对象动态行为的模型，这个模型的作用是预测系统未来的动态。即能够根据系统k时刻的状态和k时刻的控制输入，预测到k+1时刻的输出。在这里k时刻的输入正是用来控制系统k+1时间的输出，使其最大限度的接近k+1时刻的期望值。故我们强调的是该模型的预测作用，而不是模型的形式。
在这里我重点讲解一下状态空间模型。那么什么是状态？输出是不是也是状态的一种？对的，输出也是一种状态，只不过我们赋予了这个状态特殊的意义。举个例子来说，舞龙，假设是只能通过龙尾的人A指挥前面一个人B动作，然后B指挥他前面的一个人C动作….依次如此，达到控制龙头的人F叼住绣球的动作。如果只关注龙头的人（输出）和龙尾的人（输入），而忽略龙身子的动态，那就是所谓的输入—输出系统。经典控制理论就是建立在输入—输出系统的基础上面的。
但是我如果不管要管龙尾和龙头的人，我连龙身子上面的人也要要求在固定的位置，那么这就是状态空间的概念，即我对系统中的每一个状态都要控制到。龙头位置的人也是一个状态，故输出本身就是一个状态，或者说是状态的一个组合。
2.滚动优化
因为外部干扰和模型失配的影响，系统的预测输出和实际输出存在着偏差，如果测量值能测到这个偏差，那么在下一时刻能根据这个测量到偏差的测量值在线求解下一时刻的控制输入，即优化掉了这个偏差值。若将求解的控制输出的全部序列作用于系统，那么k+1时刻的测量值不能影响控制动作，也就是说测量值所包括的外部干扰或模型误差信息得不到有效利用。故我们将每个采样时刻的优化解的第一个分量作用于系统，在下一个采用时刻，根据新得到的测量值为初始条件重新预测系统的未来输出并求解优化解，继续讲这个时刻的优化解的第一个分量作用于系统，这样重复至无穷。
故预测控制不是采用一个不变的全局优化目标，而是采用时间向前滚动式的有限时域优化策略。这也就是意味着优化过程不是一次离线进行，而是反复在线进行的。
3.前馈-反馈的控制结构
这个在前面给出的两点说明中的第一点就已经给出了。
四． MPC参数选择
选择一个好的参数不仅影响MPC控制的性能，而且还会影响到MPC每一个timestep内进行在线优化的计算复杂度。这里将会给出关于控制器采样周期、预测及控制范围(prediction and control)、约束及权重。
采样周期的选择
采样周期过大，则系统反应过慢导致难以及时进行修正控制，而采样周期过小，则会导致系统产生大量的在线优化计算，给系统带来较大的开销。因而建议采样周期设计采用开环响应时间(10~90%上升时间)的十分之一或二十分之一：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3076f78a5eb78536a657256fdd0f568/" rel="bookmark">
			IP基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP基础知识 一、IP基础知识 https://mp.weixin.qq.com/s/jYc5E1Nd7oC47bdCWbCLJw
网络层与数据链层 IP 在 TCP/IP 参考模型中处于第三层，也就是网络层。网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。
网络层与数据链层的关系
IP 的作用是主机之间通信中的，而MAC的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。 举例：小林要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源MAC地址，目标地点好比目的MAC 地址。整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的 IP 地址。
还有重要一点，旅行途中我们虽然不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。其实，在网络中数据包传输中也是如此，源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。
２. IP地址的基础知识
IP 地址（IPv4地址）由32位正整数来表示，IP地址在计算机是以二进制的方式处理的。而人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每8位为组，共分为4组，每组以「.」隔开，再将每组转换成十进制。
IP地址的分类
IP地址分为5类，分别为A、B、C、D、E类。首位是0为A类，首位是1第二位为0为B类，首位为1第二位为1第三位为0为C类，以此类推，推出D、E类。
什么是A、B、C类地址
其中对于 A、B、C类主要分为两个部分，分别是网络号和主机号。这很好理解，好比小林是 A 小区 1 栋 101 号，你是 B 小区 1 栋 101 号。A、B、C分类地址最大主机个数的计算
最大主机个数，就是看主机号的位数，比如C类地址的最大主机个数是8
2 8 − 2 = 254 2^8 -2 = 254 28−2=254减去2的原因是，在IP地址中，主机号全为1的含义为指定某个网络下的所有主机用于广播，主机号全为0指定某个网络。广播地址用途
广播地址用于在同一个链路中相互连接的主机之间发送数据包D、E类地址
而 D 类和 E 类地址是没有主机号的，所以不可用于主机IP，D类常被用于多播，E 类是预留的分类，暂时未使用。多播地址用于什么
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3076f78a5eb78536a657256fdd0f568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39f7b26b6d018750d0893d61245a45f/" rel="bookmark">
			python对象与类型之函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始语：
在python软件中，为了便于维护以及更好地实现模块化，好的程序都被分解成多个函数。
各个函数都有它的功能，我们可以通过自己定义的一系列函数来实现自己想要的功能。
（1）定义 使用def语句定义函数。
格式：
def 函数名(参数列表): "函数_文档字符串" # 函数说明，定义完成后，可通过.__doc__来获取 函数体 return 表达式 # 结束函数，不带表达式的return相当于返回None 函数体就是在调用函数时执行的一系列语句。
例子：
def add_abs(x,y = 0): if x&gt;=0: return x+y else: return y-x 注：
如果定义的函数中带有默认参数（有默认值的参数，如y = 0），该参数及其后面所有参数都是可选的。如果忘记给函数定义中的所有可选参数（*args，**kwargs）赋值，就会引发语法错误。定义了函数之后，默认的参数值会传递给：以值的方式提供的对象。
如: a = 10 def foo(x = a): return x a = 5 print(foo()) # 10 以下情况若使用可变对象作为默认值，默认参数将保留前面调用进行的修改。
def foo(x,items=[]): items.append(x) return items print(foo(1)) # [1] print(foo(2)) # [1, 2] print(foo(3)) # [1, 2, 3] 为防止出现这种状况，可设置None值，并附上相应的检查代码：
def foo(x,items=None): if items is None: items = [] items.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39f7b26b6d018750d0893d61245a45f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2574ef7273ce1875e409afb6b941e45/" rel="bookmark">
			NLP——8.基于统计的翻译系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于统计的机器翻译：mosesdecoder作为比对翻译效果的baseline，如果不如这个的效果，就说明测试系统效果不算好。
首先看看一共需要以下三个模型：
语言模型：用来评估这句话的通畅程度。
1、需要从大量的语料中学习出在新的句子知道对应的英语翻译是什么。
2、翻译模型：实质是基于短语的（不是基于单词的翻译）
3、平行语料：只要中英文两个文件中行是相同的，那他们就是相互对应的中英文
4、在大量的平行语料中学习出该怎样去完成。可能会对词进行一些表示，例如word2vec等将文字表示为计算机能读懂的向量。然后做后续的映射。
5、基于统计的机器翻译就是做大量运算之后得到一个统计表：中文对应英文某表达的概率（可能有很多对应，但是每种对应方式会有不同大小的概率值）
6、对于数字、日期、时间、网址等这类不需要翻译（翻译前后都是一模一样的数字），无需为他们在统计表中记录下来，因此可以提前将所有苏子都转化为$number标记好，然后在训练时就直接原封不动的保留下来即可，不必放入统计表中计算映射关系。
这类均可以通过自行定义泛化名进行原文替换。同时，泛化可以很好地解决数据稀疏的问题（因为所给的这些量只会有很少的次数对应，有可能所有个文档中就出现一次）
因此，可以对所有你认为有必要且能规整为一个固定模式的量都进行这样的泛化处理。
7、提前将训练数据做好分词（可以利用jieba等）对整个文件做好分词。如果不做这些预处理，会有很多冗余的信息量，会浪费很多内存。
1.双语数据预处理 目标：了解和学习开发汉英双语数据预处理模块。
双语数据预处理是统计机器翻译系统构建的第一步，为词对齐处理提供分词后的 双语数据。预处理的工作本质上就是双语数据的分词处理，与传统分词不同的一 点在于需要对一些特定类型词汇进行泛化处理，如数字词汇“123.45”泛化为 “$number”来代替原文。本讲中以汉英双语数据为处理内容。
中文分词预处理 采用传统基于词典的正向最大匹配法来完成中文分词。基本流程如图所示：
由于数字、日期、时间、网址等不可枚举，无法通过词典简单查找来分词。 可以采用正则表达式或者自动机进行自动识别，并给予特殊名字进行泛化。例如：
数字类型 $number 如：123
日期类型 $date 如：1993 年 12 月 3 日
时间类型 $time 如：3:10
网址等类型 $literal 如：http://www.niutrans.com
实际上大家可以总结更多类型，并自行定义泛化名字进行替换原文。泛化的 目的是为了有效解决数据稀疏问题。
需要注意一点的是，建议不要对组织机构名进行捆绑为一个词汇。例如将“东 北大学信息学院”最好分成两个词“东北大学”“信息学院”。这样做的好处是为 了有助于后面规则抽取模块抽取出更多翻译规则。
英文分词处理 相对于中文分词处理来说，英文分词主要处理三个问题：
将所有大写字母改为小写字母；将英文句尾结束符与句尾最后一个单词用空格分开；同样将数字、日期、时间、网址等不可枚举的类型进行识别，然后分 别采用特殊名字进行泛化处理。 例如双语句对：
中文：4 月 14 日我买了 10 本书。
英文：I bought 10 books on April 14.
预处理结果：
中文：$date 我 买 了 $number 本 书 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2574ef7273ce1875e409afb6b941e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b19cfa0f4f42a11d9aa48c967f6ea5/" rel="bookmark">
			Python split()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python split()方法 描述 Python split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串
语法 split() 方法语法：
str.split(str="", num=string.count(str)).
参数 str – 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。num – 分割次数。默认为 -1, 即分隔所有。 返回值 返回分割后的字符串列表。
实例 以下实例展示了 split() 函数的使用方法：
str = "Line1-abcdef \nLine2-abc \nLine4-abcd"; print str.split( ); # 以空格为分隔符，包含 \n print str.split(' ', 1 ); # 以空格为分隔符，分隔成两个 输出：
['Line1-abcdef', 'Line2-abc', 'Line4-abcd'] ['Line1-abcdef', '\nLine2-abc \nLine4-abcd'] 当不给split函数传递任何参数时，分隔符sep会采用任意形式的空白字符：空格、tab、换行、回车以及formfeed。
示例 str = "I am a boy." print( str.split() ) 输出：['I', 'am', 'a', 'boy.'] str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b19cfa0f4f42a11d9aa48c967f6ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ce9f2d5457a6babcd4c9843e5d0905/" rel="bookmark">
			动态QueryRange
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[ExtensionOf(classStr(SysQueryRangeUtil))] final class SBXSysQueryRangeUtilClass_Extension { [QueryRangeFunctionAttribute] public static str customerDefault() { return CustParameters::find().SBXAccountNum; } } 测试：
class SBXRunableClass
{ /// &lt;summary&gt;
/// Runs the class with the specified arguments.
/// &lt;/summary&gt;
/// &lt;param name = "_args"&gt;The specified arguments.&lt;/param&gt;
public static void main(Args _args)
{
Query q = new Query(queryStr(SBXSalesTable));
QueryRun qr = new queryRun(q);
SalesTable salesTable;
while(qr.next())
{
salesTable = qr.get(tableNum(SalesTable));
Info(strFmt("%1 -- %2", salesTable.SalesId, salesTable.CustAccount));
}
}
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02ce9f2d5457a6babcd4c9843e5d0905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6237ea6c2e3fe3a13667aeba7fb099e8/" rel="bookmark">
			纯粹使用xaml实现毛玻璃背景Panel效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于一些原因，在一个wpf的应用里想做个有毛玻璃效果的Panel，放些图片按钮在上面， 然后叠加在一个listbox（内容为图片）上。感觉会还不错。
在网上找了一段时间，感觉都比较复杂，还得写c#代码。觉得应该只写xaml就够了啊，又找不到资源，干脆自己写算了。
参考了一些资料，觉得关键在于这个Panel的背景需要参考另一个Panel影像并对它做blur操作。
参考另一Panel的影像其实就是把自己的背景的Visual binding到那个Panel上。
找找哪个容器能包含Visual和Effect， 这样就可以做背景了。对了， 使用Border‘！
&lt;Border.Background&gt; &lt;VisualBrush Stretch="Uniform" Visual="{Binding ElementName=targetPanelName}"/&gt; &lt;/Border.Background&gt; &lt;Border.Effect&gt; &lt;BlurEffect Radius="50"&gt;&lt;/BlurEffect&gt; &lt;/Border.Effect&gt; 做好那个需要毛玻璃背景Panel， 调整好大小，位置， 设置这个Panel的背景为Transprent。
按照这个Panel的位置，大小，设置Border.Clip
&lt;Border.Clip&gt; &lt;RectangleGeometry Rect="0,0,200,200"/&gt; &lt;/Border.Clip&gt; 然后就OK了！嘿，还是挺简单的！
没有需要就没有做Panel拖拽， 但是应该也不难， 在代码里修改这个Border.Clip就好。
资源：https://download.csdn.net/download/bullseye/12404719
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8c37abe357c1fa7289d7cbb446dd4b/" rel="bookmark">
			ARCGIS 10.2全套资源下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源不好找,转自大神博客,感谢大神.
ArcGIS10.2最新全套下载地址
http://www.tuicool.com/articles/VfaMfy
免责声明：
该链接来自于哥伦比亚大学或者牛津大学的网站链接， 下载 软件之前确保有正版的软件授权 ，本博客只是转载了网站链接而已，如果用户有相关的盗版行为，与本博客和本作者无关！
特此声明！
版权所有，文章允许转载，但必须以链接方式注明源地址，否则追究法律责任!
Blog: http://blog.csdn.net/linghe301
以下来自于美国哥伦比亚大学的镜像
GIS Service Center – Download
Main Page | Service Plan | Download | Request Software Authorization | Support | Resources | FAQs
Before downloading the software, you must request an authorization file to activate the software.
Refer to the installation instructions to download software listed below and to activate the software using the authorization files.
Installation/Renewal Instructions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b8c37abe357c1fa7289d7cbb446dd4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a824ae2ec8fc02761cf49fabe2d6e4/" rel="bookmark">
			【STM32】STM32F407互补PWM进阶-带相移的互补PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一次尝试了STM32F4的PWM互补输出，这次尝试带移相的两对PWM互补输出。
1.相位差的概念
在这里，我把相位简单理解为延时，当然前提是两个信号彼此之间除了相位差，其他参数都一致。如下图，两信号在一个周期内，两波峰（或波谷）的时间差，就是相位差。而习惯上用弧度方式表示，如果两信号相位差位π/2，那么就是相差1/4个周期，这个很好理解，一圈为2π，π/2当然就是1/4了。
2.思路
互补PWM使用高级定时器TIM1和TIM8产生，均使用CH1和CH1N通道，上一篇文章有提到，这里就不再赘述。这两个定时器相互之间是独立的，我把参数配置成一样的时候，可以发现他们几乎是相同的。所以大概的思路就是在TIM1产生PWM之后，延时一会再由TIM8产生PWM,当然直接使用delay_ms()肯定是有误差的，这两个波形有可能会越差越多。
按照这个思路，继续往下走，通过查看《STM32F4xx中文参考手册》，我们发现定时器具有主从模式，即主机产生一个触发信号(TRGO)时，从机可以响应。在这里，我们可以想象成当TIM1输出PWM，时间达到1/4个周期，产生一个触发信号，使得TIM8的PWM输出被打开。可以通过寄存器配置内部触发，从TIM8到TIM1.下面两张图展示了这一段话。
那么怎么判断达到1/4个周期呢？想到计数器和定时器其实是一样的，能不能再用一个定时器呢？大可不必，既然定时器有那么多通道，我们干脆拿出一个通道来计时不就好了吗。于是TIM1的CH2,我们用来计时。下面是OC2的配置代码。
// TIM1_OC2配置 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Active; // TIM1_OC2REF的模式为高电平有效 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable; // 不需要输出 TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;// 不输出 TIM_OCInitStructure.TIM_Pulse = 12500/2; // 比较值为25000，这里四分之一就是12500/2 TIM_OC2Init(TIM1,&amp;TIM_OCInitStructure); // OC2初始化 TIM_SelectOutputTrigger(TIM1,TIM_TRGOSource_OC2Ref); // TRGO源配置为TIM1_CH2 TIM_OC2PreloadConfig(TIM1,TIM_OCPreload_Enable); // 配置自动重载 上面的代码已经帮我们搞定了触发信号来源，什么时候触发的问题，接下来就是把这个触发信号与TIM8相连接，并产生相应的事件。上代码：TIM1的OC2计数满之后，产生高电平给从定时器TIM8，TIM8配置为复位模式，重新输出PWM
//内部触发配置 void TIM8_IN_Config(void) { TIM_SelectSlaveMode(TIM8,TIM_SlaveMode_Reset); //从模式 复位模式 TIM_SelectInputTrigger (TIM8,TIM_TS_ITR0); //触发源 TIM_TS_ITR0，从TIM8到TIM1 } 3.结果及代码
使用双通道示波器对TIM1_CH1和TIM2_CH2测量，结果如下图所示，占空比为50%，容易看出两信号相差1/4周期，我们的目标达到，通过修改通道2的比较值TIM_OCInitStructure.TIM_Pulse，可以实现不同相位差（适用于0-180°）
附上完整代码：
//TIM1-CH1 PA8 //TIM1-CHN PA7 //TIM1-OC2 触发源 void TIM1_PWM_Init() {	// 结构体声明 GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; TIM_BDTRInitTypeDef TIM_BDTRStructure; // 时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE); //TIM3时钟使能 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); //使能PORTC时钟	// IO复用 GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_TIM1); // GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_TIM1); // // IO配置 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a824ae2ec8fc02761cf49fabe2d6e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c68b0ed5249c8090c56e5df784050d7/" rel="bookmark">
			学术派 |用深度学习实现2D到3D的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着 5G 时代的到来，VR 端应用呈爆发式增长，3D 内容作为构建 VR 生态的主力输出一直深受广大用户的追捧和喜爱。针对目前 3D 内容过少，质量不高、生产昂贵等现状，爱奇艺作为国内领先的互联网视频媒体，自然首当其冲，以真实世界的 3D 内容为基础，研究2D 转 3D 技术，实现更优质的 VR 端的 3D 内容生态的构建，满足更多用户的日常需求。
相对于 2D 内容，优质的 3D 内容有输出符合真实景深关系的能力，让用户在观看时具有更好的观影体验。下面我们从技术的角度，介绍爱奇艺如何赋予2D内容真实的景深关系，实现 2D 内容到 3D 内容的转换。
面临的挑战 目前 2D 转 3D 技术主要问题是转制成本太高，不能大面积使用，如使用一般的策略很难适用多种场景的真实 3D 视差关系，这很容易让用户感到不适。
综合以上原因，我们考虑采用深度学习方法，通过对大量 3D 电影（side-by-side 的双目介质）真实视差的学习与建模，完成单目视图到双目视图的转换。
以下是2D转3D技术面临的几个挑战：
数据集质量
3D介质中包含大量不符合真实视差关系的双目视图 受相机参数的影响，同类场景的视差在不同的 3D 介质中不统一 帧间抖动
场景多样化，需要保证视差预测的连续性与准确性 重构视图的遮挡区域空洞的填补 3D 效果的评价指标难以量化
同类场景具有不同的并且满足真实世界的视差关系 3D 效果依靠人工评价，过于主观 模型原型思路 通过对大量用户的调研发现，除去特效场景刺激眼球外，3D 介质的 3D 感知越符合真实世界越受用户喜爱，因此在模型构建上必须符合真实世界的 3D 观感——双目视觉
图1双目相机成像与视差原理
如图 1 左所示，两个相机拍摄同一场景生成的图像会存在差异，这种差异叫视差，其产于与真实的三维空间。视差不能通过平移消除，同时离相机近的物体视差偏移较大，反之越小。
人的左右眼就如同图中的左右相机一样，分别获取对应图像后，通过大脑合成处理这种差异，从而获取真实世界的 3D 感知，通过图 1 右可得出视差与相机焦距和轴间距间的关系：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c68b0ed5249c8090c56e5df784050d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/387b1420598b20c73bccb572953de144/" rel="bookmark">
			Liunx服务管理之NFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. nfs简介1.1 nfs特点1.2 nfs的应用场景1.3 nfs的体系组成 2. nfs工作机制2.1 RPC2.2 nfs工作机制 3. exports文件的格式4. nfs管理 1. nfs简介 1.1 nfs特点 NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样nfs适用于Linux与Unix之间实现文件共享，不能实现Linux与Windows间的文件共享功能nfs是运行在应用层的协议，其监听于2049/tcp和2049/udp套接字上
nfs服务只能基于IP进行认证 1.2 nfs的应用场景 nfs有很多实际应用场景，以下是一些常用的场景：
多个机器共享一台CDROM或其他设备。这对于在多台机器中安装软件来说更加便宜与方便在大型网络中，配置一台中心NFS服务器用来放置所有用户的home目录可能会带来便利。这些目录能被输出到网络以便用户不管在哪台工作站上登录，总能得到相同的home目录不同客户端可在NFS上观看影视文件，节省本地空间在客户端完成的工作数据，可以备份保存到NFS服务器上用户自己的路径下 1.3 nfs的体系组成 nfs体系至少有两个主要部分：
一台nfs服务器若干台客户机
nfs体系的架构图如下：
客户机通过TCP/IP网络远程访问存放在NFS服务器上的数据
在NFS服务器正式启用前，需要根据实际环境和需求，配置一些NFS参数
2. nfs工作机制 nfs是基于rpc来实现网络文件系统共享的。所以我们先来说说rpc。
2.1 RPC RPC（Remote Procedure Call Protocol），远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。
rpc工作机制如上图所示，下面来描述一下它：
客户端程序发起一个RPC系统调用基于TCP协议发送给另一台主机（服务端）服务端监听在某个套接字上，当收到客户端的系统调用请求以后，将收到的请求和其所传递的参数通过本地的系统调用执行一遍，并将结果返回给本地的服务进程服务端的服务进程收到返回的执行结果后将其封装成响应报文，再通过rpc协议返回给客户端客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行 2.2 nfs工作机制 //NFS服务器端运行着四个进程： nfsd mountd idmapd portmapper idmapd //实现用户帐号的集中映射，把所有的帐号都映射为NFSNOBODY，但是在访问时却能以本地用户的身份去访问 mountd //用于验证客户端是否在允许访问此NFS文件系统的客户端列表中，在则允许访问（发放一个令牌，持令牌去找nfsd），否则拒绝访问 //mountd的服务端口是随机的，由rpc服务（portmapper）提供随机端口号 nfsd //nfs的守护进程，监听在2049/tcp和2049/udp端口上 //不负责文件存储（由NFS服务器本地内核负责调度存储），用于理解客户端发起的rpc请求，并将其转交给本地内核，而后存储在指定的文件系统上 portmapper //NFS服务器的rpc服务，其监听于111/TCP和111/UDP套接字上，用于管理远程过程调用（RPC） 下面通过一个例子来说明NFS的简单工作流程：
需求：查看file文件的信息，此file存储在远程NFS服务端主机上（挂载在本地目录/shared/nfs中） 客户端发起查看file信息的指令（ls file）给内核，内核通过NFS模块得知此文件并不是本地文件系统中的文件，而是在远程NFS主机上的一个文件客户端主机的内核通过RPC协议把查看file信息的指令（系统调用）封装成rpc请求通过TCP的111端口发送给NFS服务端主机的portmapperNFS服务端主机的portmapper（RPC服务进程）告诉客户端说NFS服务端的mountd服务在某某端口上，你去找它验证 因为mountd在提供服务时必须要向portmapper注册一个端口号，所以portmapper是知道其工作于哪个端口的
客户端得知服务端的mountd进程端口号后，通过已知的服务端mountd端口号请求验证mountd收到验证请求后验证发起请求的客户端是否在允许访问此NFS文件系统的客户端列表中，在则允许访问（发放一个令牌，持令牌去找nfsd），否则拒绝访问验证通过后客户端持mountd发放的令牌去找服务端的nfsd进程，请求查看某文件服务端的nfsd进程发起本地系统调用，向内核请求查看客户端要查看的文件的信息服务端的内核执行nfsd请求的系统调用，并将结果返回给nfsd服务nfsd进程收到内核返回的结果后将其封装成rpc请求报文并通过tcp/ip协议返回给客户端 3. exports文件的格式 nfs的主配置文件是/etc/exports，在此文件中，可以定义NFS系统的输出目录（即共享目录）、访问权限和允许访问的主机等参数。该文件默认为空，没有配置输出任何共享目录，这是基于安全性的考虑，如此即使系统启动了NFS服务也不会输出任何共享资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/387b1420598b20c73bccb572953de144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c2cef0ca04f4a590306bc6b1c2150c/" rel="bookmark">
			一. Nacos Windows 单机版下载与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud Alibaba Nacos 服务注册和配置中心,更易于构建云,原生应用的动态服务发现,配置管理,和服务管理平台,就是以前配置中心 Config + 注册中心 Eureka + Bus 消息总线的组合体SpringBoot+SpringCloud Alibaba支持 Nacos 的父项目容器 pom 示例 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.test.springcloud&lt;/groupId&gt; &lt;artifactId&gt;com.test.springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--当前府项目容器中包含的子项目(在父项目容器中创建子项目会自动添加此处代码))&gt; &lt;modules&gt; &lt;module&gt;cloudalibaba-consumer-nacos-order83&lt;/module&gt; &lt;module&gt;cloudalibaba-config-nacos-client3377&lt;/module&gt; &lt;/modules&gt; &lt;!--1.指定父项目容器打包方式为pom--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--2.统一jar包版本号管理--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;12&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;12&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;lombok.version&gt;1.18.10&lt;/lombok.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;/druid.version&gt; &lt;mybatis.spring.boot.version&gt;2.1.1&lt;/mybatis.spring.boot.version&gt; &lt;/properties&gt; &lt;!--3.子模块中需要的依赖 dependencyManagement 作用:锁定版本,子模块中不用写groupId,version--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring boot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud 阿里巴巴--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c2cef0ca04f4a590306bc6b1c2150c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c85d208980675bc69df7d07b4d268c92/" rel="bookmark">
			六. SpringCloud Ribbon 负载均衡与修改默认的负载策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 基础概述二. 通过 @LoadBalanced 注解了解 Ribbon 负载均衡二. Ribbon 核心组件 IRule 与负载算法三. 项目中如何修改负载策略 一. 基础概述 自己做的记录,推荐看大神的Ribbon的负载均衡策略及原理
什么是负载均衡: 简单来说就是根据算法指定将用户的请求平摊分片到多个服务上,或打到指定的服务上,从而达到服务的高可用,负载均衡分为软负载nginx,lvs与应负载F5等在前面 SpringCloud 中使用注册中心,使用 RestTemplate 根据服务名称在注册中心获取指定服务的调用地址,使用 @LoadBalanced 修饰 RestTemplate ,默认是轮询算法(G版本前)SpringCloud 中有好多框架默认整合引入了 Ribbon 依赖,例如spring-cloud-starter-zookeeper-discovery 或者spring-cloud-starter-netflix-eureka-client等,也可以单独引入 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; 二. 通过 @LoadBalanced 注解了解 Ribbon 负载均衡 点开 @LoadBalanced 注解源码,会发现该注解没做其它附加操作,只是用来修饰 RestTemplate 用来标识一下,是借助 Spring 装载机制完成的负载设置查看 spring.factories 文件,找到项目启动时默认自动装载的类 RibbonAutoConfiguration
RibbonAutoConfiguration 使用 @AutoConfigureBefore({LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class}) 修饰该类,表示在创建该类注入以前首先会创建 LoadBalancerAutoConfiguration 注入到容器中,通过 LoadBalancerAutoConfiguration 向 RestTemplate 添加了一个请求拦截器 LoadBalancerInterceptor @Bean @ConditionalOnMissingBean public RestTemplateCustomizer restTemplateCustomizer(final LoadBalancerInterceptor loadBalancerInterceptor) { return (restTemplate) -&gt; { List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList(restTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c85d208980675bc69df7d07b4d268c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd383a2a56dcbc19707300c038418e8/" rel="bookmark">
			正点原子阿波罗开发板下载调试的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近购买了正点原子的阿波罗的开发板，评估STM32F429的以太网功能。原子的开发板设计的不真不错，功能强大，外形设计优美。更多的优点我就不夸了。
新板子到手的肯定是首先连接仿真器下载一段代码进去，下载后发现程序不能运行到main函数，代码一直在0x1FFF0000开始的地址内运行，实际这段地址是stm32芯片内部的bootloader地址。程序无法跳转到应用程序。控制跳转到应用程序的芯片的boot引脚，经查芯片的boot引脚跳线设置正常。
1、下载调试的问题 目前的现象是程序只能脱机下载后运行，不能仿真。真是奇怪。那么就详细看一下硬件设计。其中的usb转串口部分电路设计了控制芯片的复位，控制BOOT0引脚，这样的设计是用于串口一键下载的功能，但是有负作用，就是usb和电脑usb口连接的一段时间内CH340的产生错误信号，导致芯片产生复位并且进入boot阶段，导致仿真器仿真时无法运行到main函数。
原因查找后，解决办法就很简单了，把电路板上面的D7 1N4148和R68 1K电阻焊掉，从此我的STM32F429又可以愉快的仿真程序了。
2、以太网复位 以太网的PHY芯片是通过PCF8574 IO扩展芯片来进行复位，在个别情况下上电，出现以太网PHY LAN8720无法复位，导致网络无法获取IP地址的情况出现，再次复位就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a882dff1c12bda3b551e57e01feffa/" rel="bookmark">
			python对象与类型之映射（dict）与集合（set）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、映射（dict） （1）定义 dict() # new empty dictionary dict(mapping) # new dictionary initialized from a mapping object's (key, value) pairs a = (1,2,3);b = ('a','b','c') dict(zip(b,a)) # {'a': 1, 'b': 2, 'c': 3} dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. dict(a=1, b=2) # {'a': 1, 'b': 2} 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a882dff1c12bda3b551e57e01feffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e16efb293a6ad14a539b8fec0ba73ae/" rel="bookmark">
			adb命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://developer.android.com/studio/command-line/adb
Android Debug Bridge version 1.0.41 Version 30.0.5-6877874 Installed as C:\Users\Administrator\AppData\Local\Android\Sdk\platform-tools\adb.exe global options: -a listen on all network interfaces, not just localhost -d use USB device (error if multiple devices connected) -e use TCP/IP device (error if multiple TCP/IP devices available) -s SERIAL use device with given serial (overrides $ANDROID_SERIAL) -t ID use device with given transport id -H name of adb server host [default=localhost] -P port of adb server [default=5037] -L SOCKET listen on given socket for adb server [default=tcp:localhost:5037] general commands: devices [-l] list connected devices (-l for long output) help show this help message version show version num networking: connect HOST[:PORT] connect to a device via TCP/IP [default port=5555] disconnect [HOST[:PORT]] disconnect from given TCP/IP device [default port=5555], or all pair HOST[:PORT] [PAIRING CODE] pair with a device for secure TCP/IP communication forward --list list all forward socket connections forward [--no-rebind] LOCAL REMOTE forward socket connection using: tcp:&lt;port&gt; (&lt;local&gt; may be "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e16efb293a6ad14a539b8fec0ba73ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ef1f2c02fbf763f177e0eb09098796/" rel="bookmark">
			使用 Element 上传组件读取文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：支持 .txt 和 .sql 后缀文件内容的读取，最大 2MB。显示已读取文件名称、读取进度和读取成功状态。读取按钮重复点击时，已读取文件列表中的文件被新的文件替换。
&lt;template&gt; &lt;el-upload ref="upload-sql" action='' accept=".txt,.sql" :auto-upload="false" :on-change="changeFile" :http-request="uploadHandler"&gt; &lt;el-button class="mr-2" plain slot="trigger" size="small"&gt; &lt;i class="el-icon-upload mr-1 font-size-14"&gt;&lt;/i&gt;读取文件 &lt;/el-button&gt;支持 .txt 和 .sql 后缀文件上传，最大2MB &lt;/el-upload&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { sqlText: '' } }, methods: { getRandomNum (min, max) { return Math.floor(Math.random() * (max - min + 1) + min) }, changeFile (file, fileList) { if (file.status === 'ready') { // 已上传文件列表如果存在 2 条记录，移除第一条，实现替换效果 if (fileList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09ef1f2c02fbf763f177e0eb09098796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49a81668f533b55660f1d9fde4e1ecc/" rel="bookmark">
			rabbitmq中相关概念 交换器，路由键，绑定，和处理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基本概念
Broker：简单来说就是消息队列服务器实体。
Exchange：交换器，它指定消息按什么规则，路由到哪个队列,rabbitmq常用有4种类型交换器， fanout,direct,topic,headers，此外AMQP协议中还提到另外两种System和自定义。
fanout：会把所有发送到该交换器的消息都路由到所有与该交换器绑定的队列去。direct：会把消息路由到BindingKey与RoutingKey匹配的队列中去topic：与direct类似，但是匹配规则有些不同。headers：不依赖RountingKey来匹配消息，而是根据消息的headers属性进行陪陪
Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
Routing Key：路由键，exchange根据这个关键字进行消息投递。
vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
producer：消息生产者，就是投递消息的程序。
consumer：消息消费者，就是接受消息的程序。
channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个
会话任务。
消息队列的使用过程大概如下：
（1）客户端连接到消息队列服务器，打开一个channel。
（2）生产者设置一个交换器（Exchange），并设置相关属性。
（3）生产者设置一个队列（Queue)，并设置相关属性。
（4）生产者通过路由键（RoutingKey）将交换器和队列绑定起来。
（5）客户端投递消息到交换器（Exchange)。
交换器（Exchange)接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到
一个或多个队列里。交换器（Exchange)也有几个类型，完全根据key进行投递的叫做Direct交换机，例如，
绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会
投递到队列。对key进行模式匹配后进行投递的叫做Topic交换机，符号”#”匹配一个或多个词，
符 号 ”” 匹 配 正 好 一 个 词 。 例 如 ”abc.#” 匹 配 ”abc.def.ghi” ， ”abc.” 只 匹
配”abc.def”。还有一种不需要key的，叫做Fanout交换机，它采取广播模式，一个消息进来
时，投递到与该交换机绑定的所有队列。
RabbitMQ支持消息的持久化，也就是数据写在磁盘上，为了数据安全考虑，我想大多数用户都会
选择持久化。消息队列持久化包括3个部分：
（1）exchange持久化，在声明时指定durable =&gt; 1
（2）queue持久化，在声明时指定durable =&gt; 1
（3）消息持久化，在投递时指定delivery_mode =&gt; 2（1是非持久化）
如果exchange和queue都是持久化的，那么它们之间的binding也是持久化的。如果exchange和
queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdcb8e7f43525e66f5af2be23be261a/" rel="bookmark">
			WWW服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。
1xx：指示信息 —— 表示请求已接收，继续处理。
2xx：成功 —— 表示请求已被成功接收、理解、接受。
3xx：重定向 —— 要完成请求必须进行更进一步的操作。
4xx：客户端错误 —— 请求有语法错误或请求无法实现。
5xx：服务器端错误 —— 服务器未能实现合法的请求。
安装软件：
[root@localhost ~]# yum install httpd -y
1./etc/httpd/conf/httpd.conf 主要的配置文件 。
2./var/www/html/这就是默认的首页所在目录，当输入网址时所显示的数据，就是放在这个目录当中的首页文件（默认为index.html）。
3./var/www/cgi-bin/默认给一些可执行的CGI（网页程序）程序放置的目录，当输入网址/cgi-bin/时所显示的数据所在。
4./var/log/httpd/默认的Apache日志文件都放在这
主配置文件内容:[root@localhost ~]# vim /etc/httpd/conf/httpd.conf
31 ServerRoot “/etc/httpd” http服务的顶级目录为/etc/httpd
42 Listen 80监听在80端口,80为web服务器的默认端口
56 Include conf.modules.d/.conf 包括/etc/httpd/conf.modules.d/.conf的所有文件
66 User apache服务的用户
67 Group apache
86 ServerAdmin root@localhost邮箱
95 #ServerName www.example.com:80 ServerName 0.0.0.0:80匹配任意IP地址，监听端口在80端口
102 目录为根，&lt;&gt;为起始标志，&lt;/&gt;为结束标志
103 AllowOverride none 不允许这个目录下的访问控制文件来改变这里的配置，这也意味着不用查看这个目录下的访问控制文件。
104 Require all denied 拒绝访问根
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bdcb8e7f43525e66f5af2be23be261a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7a671072b6b370d25ed6b71484613a/" rel="bookmark">
			Git Your branch is ahead of &#39;origin/master&#39; by 1 2 3 4 commits解决方法 Git冲突解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意！！以下命令会将目前的本地分支和最新的远端git仓库同步，所以要确定本地没有push的内容不再需要，才可用以下指令进行还原。
git reset --hard origin/master
还有一个将本地代码与服务器代码更新一致的语句
git branch -u origin/master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dd1cc0fd94ad4b18ee11138b7cfafb/" rel="bookmark">
			Sift特征匹配以及ransac消除误差解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文不光展示SIFT算法的匹配效果，更重要的是记录下搜集信息以及处理信息的过程，方便以后按照这个行动思路去解决问题，以及优化行动思路
第一部分：了解到SIFT算法的存在 其实早在学习双目视觉的时候就了解过 特征匹配 算法，其中就使用过SIFT算法，以及众多SIFT算法的变种，这时只是知道名字，最近因为课题需要使用，所以开展从原理到实践的研究，首先了解一个算法，首先要直观的看到他的运行结果，不管是自己跑的还是别人跑的，第一个数据来源是opencv-python的中文文档
单张图片特征查找效果如下：
两张图片匹配效果如下：
看到这里就激起了我的兴趣，接下来就进行第二步
第二部分 学习算法原理 首先去找的是视频资源，当然是先去B站康康，没想到真的有！
视频详解
看完这些之后大概了解了SIFT的流程以及部分数学知识，但是具体的细节还需要文字资料配合食用：
SIFT的宏观描述（大体流程）
SIFT的微观描述（数学细节）
此时再回去看带你入门的视频，会发现首尾呼应，有些不懂的地方也明白了，但是这是一个不断反复多次理解的过程，没有人能一天把别人长时间的研究成果搞懂，所以不会以及困惑很正常，不要灰心，多找资料，反复看几遍就会懂了。
第三部分 算法实践 到这里相信你已经明白了SIFT是什么原理，匹配出来的效果大概是什么样的，所以你也想做出和示例中一样的效果，甚至做得更好，或者你想用SIFT帮助你的科研项目，这些都没有问题，以下是我的代码学习历程以及成果。 在最初阶段，我只想让代码运行起来，因为SIFT算法是受专利保护的，所以在opencv3.4之后被放到了一个单独的收费库里，只能自己在本地机器编译后才能运行，
windows编译方法1
windows编译方法2
当然这个过程会费时大概一天，只有真正的强者才能完成编译这个过程，你会遇上非常多的莫名其妙的问题，需要你自己一个一个去解决，但是只要肯用功，总会解决的
我在这补充一个编译之后在本地python使用的方法，网上没找到，是自己研究出来的，当你完成编译后会有下图这样的文件夹
找到其中的python_loader,然后打开anaconda prompt，如果你没有anaconda，那么你就打开cmd，并保证输入python后出现python的交互界面（把python放到环境变量的path里）接下来操作如下
1.首先卸载你的 opencv-python
pip uninstall opencv-python pip uninstall opencv-contrib-python 2.定位到你的setu.py的目录
切换目录方法
3.然后分别输入
python setup.py build python setup.py install 下面就是代码实践，我首先尝试了官网教程给出的算法例子
import numpy as np import cv2 as cv img = cv.imread('home.jpg') gray= cv.cvtColor(img,cv.COLOR_BGR2GRAY) ''' 下面是创建sift，以及使用sift进行计算的方法 ''' sift = cv.xfeatures2d.SIFT_create() kp = sift.detect(gray,None) ''' 下面是绘图部分 ''' img=cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67dd1cc0fd94ad4b18ee11138b7cfafb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efa84e9f2058ad7cfd5da320b3ec800/" rel="bookmark">
			使用JDK发布和调用webservice服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用JDK发布webservice服务 创建接口 package com.test.service; public interface WeatherService { /** * 查询指定城市的天气 * @param cityName 城市名称 * @return */ String queryWeather(String cityName); } 创建接口实现类，添加webservice服务端注解 package com.test.service.impl; import com.test.service.WeatherService; import javax.jws.WebService; @WebService public class WeatherServiceImpl implements WeatherService { @Override public String queryWeather(String cityName) { System.out.println("查询天气的城市为：" + cityName); String result = "该城市的天气为：晴天"; System.out.println(result); return result; } } 发布webservice服务 package com.test.service; import com.test.service.impl.WeatherServiceImpl; import javax.xml.ws.Endpoint; /** * 使用JDK的方式发布服务 */ public class PushWebService { public static void main(String[] args) { //使用jdk提供的Endpoint类可以将webservice服务发布出去 /** * Endpoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efa84e9f2058ad7cfd5da320b3ec800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfba83bd805964ffe9e1f2a9dfddd35/" rel="bookmark">
			halcon培训-快速傅里叶变换（FFT）对塑料制品-@龙熙视觉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		halcon培训-快速傅里叶变换（FFT）对塑料制品-@龙熙视觉 This program demonstrates how to detect small texturedefects on the surface of plastic items by using the fastfourier transform (FFT).First, we construct a suitable filter using Gaussianfilters. Then, the images and the filter are convolvedby using fast fourier transforms. Finally, the defectsare detected in the filtered images by usingmorphology operators. **例程：detect_indent_fft.hdev
说明：这个程序展示了如何利用快速傅里叶变换（FFT）对塑料制品的表面进行目标（缺陷）的检测，大致分为三步：
首先，我们用高斯滤波器构造一个合适的滤波器（将原图通过高斯滤波器滤波）；
然后，将原图和构造的滤波器进行快速傅里叶变换；
最后，利用形态学算子将缺陷表示在滤波后的图片上（在缺陷上画圈）。*
Initializations
在程序执行过程中选择将PC更新操作打开或关闭
dev_update_off ()
*** 关闭激活的图形显示窗口**
dev_close_window ()
read_image (Image, ‘plastics/plastics_01’)
get_image_size (Image, Width, Height)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcfba83bd805964ffe9e1f2a9dfddd35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a420885c0a63497f8df4bd9eabaec52/" rel="bookmark">
			C&#43;&#43;语言标准库&lt;functional&gt;中的函数对象，绝对是装B神器~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++语言标准库&lt;functional&gt;中的函数对象，绝对是装B神器~用一下，感慨万千~~~
基本上是C++ Primer上的，show一下代码：
#include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; int main() { plus&lt;int&gt; int_plus; minus&lt;int&gt; int_minus; int value_plus = int_plus(200, 100); cout &lt;&lt; "int_plus(200, 100):\t" &lt;&lt; value_plus &lt;&lt; endl; int value_minus = int_minus(200, 100); cout &lt;&lt; "int_minus(200, 100):\t" &lt;&lt; value_minus &lt;&lt; endl; return 0; } 运行结果如下：
int_plus(200, 100): 300
int_minus(200, 100): 100
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9f8cfd76a2da1fd86e845aba3db5a8/" rel="bookmark">
			汇编OFFSET,SEG,LEA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OFFSET OFFSET +X符识符，
表示取X的偏移地址
TABLE DW 10； 设定一个以TABLE为首地址的数据 MOV BX,OFFSET TABLE；将TABLE的偏移地址传送给基址寄存器BX SEG段基址 OFFSET偏移地址 LEA lea eax,[SI] 说明: eax得到SI指向的堆栈内容的偏移地址， 和寄存器SI的值是相同的 LEA BX, TABLE ;在实际执行时才会将变量buffer的地址放入bx
MOV BX, OFFSET TABLE ;在编译时就已经计算出buffer的地址为4300(假设)，然后将上句替换为: mov bx,4300
lea可以进行比较复杂的计算，比如lea eax,[esi+ebx * 4]，把ebx的值*4，加上esi的值，存入eax中。 mov就不行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a990cb6554340c585c6b493a535f97ec/" rel="bookmark">
			python3基础篇（十）——异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3基础篇（十）——异常处理 前言：
阅读这篇文章我能学到什么？
这篇文章将为你介绍python3中的异常捕获和处理，如果你看过《代码大全2》会明白为程序设计上异常的处理是多么重要的一件事。如果你希望对它有一些基础的了解，那么请读这篇文章。
——如果你觉得这是一篇不错的博文，希望你能给一个小小的赞，感谢您的支持。
目录 python3基础篇（十）——异常处理 1 程序异常处理1.1 assert（断言）1.2 try异常捕获和处理1.2.1 try-except结构1.2.2 try-except-else结构1.2.3 try-except-finally结构 2 异常结构的嵌套3 异常类型 1 程序异常处理 程序异常就是程序的运行结果超出了设计者的预料，程序的运行是“非正常”的执行流程。程序的异常处理其实应该分两个阶段，第一个阶段是异常的检测（识别出异常状态，并区分出是何种异常），第二个阶段是针对特定异常情况应该做何种处理（处理可以是忽略、修正、甚至重启）。变成语言支持异常处理已经不是什么“新鲜”的事了，但还是要提一下早期程序处理异常是用 error code 的方式，即函数或代码段返回故障码，通过故障码来区分异常种类和决定如何处理。这种方式已经日渐淘汰，现在很多编程语言已经对异常处理有了较好的支持，形式通常是 try-catch ，在python3中是 try-except形式。断言是一种常用的异常处理，它一般用于调试阶段（发行版一般将其关闭）。
1.1 assert（断言） 也其他语言的断言处理一样，当断言的条件为False时，触发异常进行断言处理。断言用于在程序检测到异常时立即终止程序的运行并抛出此时的异常，不必等到后续运行到程序崩溃，抛出一大堆非根源错误信息。代码大全的防御式编程思想是建议在开发调试阶段使问题尽可能“扩大化”，让小问题也无法被忽视（小问题也导致程序运行终止，这样有利于我们写出健康强壮的代码）。
我们尝试实现一个功能函数，为它加上断言来捕获一些异常。
代码示例：
def Myabs(Num): #求数的绝对值 if Num &gt;= 0: RetValue = Num else: RetValue = -Num return RetValue print(Myabs(1)) #整数 print(Myabs(0)) print(Myabs(-1)) print(Myabs(-1.0)) #浮点数 运行结果：
1 0 1 1.0 这个函数用于求一个数的绝对值，看上去似乎没有问题，因为我们进行了一些简单测试后发现结果符合我们的预期。但是如果这个代码交到客户手中将会出现严重的bug，因为你无法现象客户可能给这个函数传递什么奇葩的内容进去。
进行如下测试：
def Myabs(Num): #求数的绝对值 if Num &gt;= 0: RetValue = Num else: RetValue = -Num return RetValue #预料之外的输入 #print(Myabs("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a990cb6554340c585c6b493a535f97ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a872ed76fb6d7aa3c4370466fea60a5/" rel="bookmark">
			钢筋点根环境部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统环境：Ubuntu 16.04 LTS
1 标题系统环境 1.1 apt-get镜像源更换 sudo vim /etc/apt/sources.list 用以下内容更换，这个是阿里云的源，当然也可更换其他源，这里仅做参考（注意：不同系统的镜像源地址不同，需要谨慎操作，这个对应的是Ubuntu 16.04 LTS）：
# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a872ed76fb6d7aa3c4370466fea60a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a63ea734936b52cad99183b5f4277cb/" rel="bookmark">
			System.Diagnostics.Process.Start(&#34;‪C:\\Windows\\System32\\osk.exe&#34;);提示找不到文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System.Diagnostics.Process.Start(“‪C:\Windows\System32\osk.exe”);提示找不到文件
解决方法：工程选择属性，生成界面，把首选32位的勾去掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef91b3d08185c7464421f73b5909567/" rel="bookmark">
			top.layer.open 子页面按钮点击关闭刷新父页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 父页面打开弹框 top.layer.open({ ...... }) // 子页面方法 $("#button").click(function(){ var index = parent.layer.getFrameIndex(window.name); parent.layer.close(index);// 关闭弹出层 parent.window.location.reload(); // 刷新父页面 }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ecdf5493b5c737cf9675200a921a87/" rel="bookmark">
			C/C&#43;&#43;程序设计面试题目整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.C/C++程序基础1.1 C和C++的区别面向对象程序设计的主要优点面向过程和面向对象编程区别 1.2 模块化程序设计1.3 C++主函数前后执行的语句主函数能不能有参数 1.4 常用的循环结构：for,while,dowhile1.5 i++和++i的效率区别（后缀自增运算符与前缀自增运算符）1.6 不使用临时变量替换a与b的值1.7 if..else和switch区别1.8以分号结束和不以分数结束的语句 2.预处理、const、static和sizeofconst作用 2.2 include预编译指令：将被包含的头文件插入到该编译指令的位置。include头文件&lt;&gt;和""区别条件编译与头文件保护 2.3 static作用、类静态成员和方法2.4 sizeof和strlen区别2.5 typedef和define区别2.6 内联函数：替代宏定义来解决函数调用的效率问题为什么函数不全部替换成内联函数？内联函数与宏定义区别？ 3.引用和指针3.1 引用和指针区别3.2 什么是野指针3.3 为什么有了malloc/free，还要有new/delete3.4 内存分配/释放函数及区别：malloc、calloc、realloc、free等 4.字符串4.1 strcpy和memcopy区别 6.面向对象6.1 类的特性：封装、继承、多态（面向对象三大特征）、抽象、重载类和对象区别 6.2 struct和clas区别6.3 C++空类中默认产生哪些成员函数：默认构造函数、复制构造函数、析构函数、赋值函数和取址函数6.4 简要说明构造函数与析构函数复制构造函数：特殊的构造函数，完成同一类其他对象的初始化深拷贝与浅拷贝区别 初始化列表：可在构造函数初始化列表初始化成员虚析构函数：当一个类作为基类时，虚析构函数会先执行子类虚构函数 6.5 复制构造函数和赋值函数区别6.6 什么是内存泄漏6.7 访问修饰符与继承方式 7.多态和继承7.1 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同类型的执行结果虚函数：允许用基类的指针来调用 子类对应的虚函数实现纯虚函数与抽象类：含有纯虚函数的类被称为抽象类 重载：同一作用域中多个同名函数，形参列表必须不同覆盖（重写）：覆盖基类虚函数（参数必须相同）隐藏与覆盖的区别 7.2 抽象类（概念，并有具体对应）接口（概念，无具体对应。对应 仅纯虚函数的抽象类） 7.3 多继承：一个类有多个基类,这样的继承关系称为多继承多继承重复调用同一基类构造函数造成二义性：虚继承解决多继承的二义性问题 7.4 接口继承和实现继承7.5 this指针的含义：指向成员函数作用的对象7.6 类对象与类指针： 8.数据结构8.1 两个栈实现队列 10.泛型编程：多种数据类型皆可操作（模板实现）10.1 函数模板与类模板10.2 模板缺点 1.C/C++程序基础 1.1 C和C++的区别 （1）C是结构化语言，偏向于面向过程，它的重点在于设计算法和数据结构。
（2）C是偏向于面向对象的语言。C++扩展了面向对象的功能，如类、继承、模板、虚函数等，不仅要考虑封装，还要考虑对象接口的设计、继承使用等问题。
（3）最大区别在于解决问题的思想不同，C考虑的是如何通过一个过程来完成任务，C++考虑的是如何构造一个对象模型，让这个模型能配合对应的问题。
（4）C++拥有面向对象的特征但是也可以实现过程化的程序，Java才是真正面向对象的。
延伸，C和C++具体区别：
1、从机制上：
C是面向过程的结构化编程语言（但也可以编写面向对象的程序），偏向于面向过程的程序设计
C++是面向对象的，提供了类。侧重于类的设计而不是过程的设计。
2、从适用的方向：
C适合代码体积小的，效率高的场合，如嵌入式；
C++适合更上层的，复杂的场合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2ecdf5493b5c737cf9675200a921a87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41504db8a45ce5d9e084a55c8ec2db9/" rel="bookmark">
			Unity Shader - Ray Marching - T7 - AO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运行效果单纯AO光照遮蔽值无AO有AO ProjectGGBExcelReferences 自学Raymarching汇总：Unity Shader - Ray Marching Study Summary - 学习汇总
说个题外话，今天面试虽然没成功了，让自己发现更多的问题。
但收获非常的大，让我调整得更好的方向。
真的非常感谢这位面试官！
此篇为Raymarching告一段落的文章，后续如果有时间会更加深入。
因为要去开始进修对的方向的内容，可能时间需要挺长的。
生活就是这样子，不可能什么都一帆风顺。
生活只会给你更沉重的打击，每个人都一样，就看个人的心态如何调整，应对。
发现很多实现在Raymarching里都非常的简单与直白。
之前看过一下AO的内容，虽然知道AO是指：Ambient Occlusion，环境遮蔽。
然后生成的方法也大概了解一丢丢，但从来没去实践过。
就是对需要计算AO的表面，计算它的指定半径范围内有无东西靠近，越多东西靠近，往往AO就越高，就环境光量的辐射就遮蔽越多。
根据之前知识点的累计，就画一张示意图：
如上图，假设要计算某个微表面的点P的AO值，我们按一定的角度平分了AO采样计算的射线。
我们一共发射了12条AO射线。红色点的说明该点P附近有阻挡物，或是有几何体；绿色的说明这个AO射线上没有阻挡物。
可以看到12条中，有9条检测有阻挡物，只有3条检测是没有阻挡物的。
所以他的AO值为： A O p = 9 12 AO_p=\frac{9}{12} AOp​=129​，最后应用该值到着色只要：col *= 1 - AO; 1-AO取反一下就好，或这我们在计算AO值的时候直接统计：3条未检测有阻挡物的比例值，即： A O p = 3 12 AO_p=\frac{3}{12} AOp​=123​，后续我们就以取检测到没有阻挡的比例值作为AO着色因子吧。
但是上面的这种算法有一些问题。再来看看另一种情况，如下图：
如上图所示，采样计算点P的AO值，有阻挡的6条射线，无阻挡也是6条。
那么6条无阻挡的AO结果为： A O p = 6 12 = 1 2 = 0.5 AO_p=\frac{6}{12}=\frac{1}{2}=0.5 AOp​=126​=21​=0.5
所以就连平躺微表面的指定半径范围无其他阻挡物有也0.5的AO值，那乘到着色点上：col *= AO; =&gt; col *= 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a41504db8a45ce5d9e084a55c8ec2db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fff407edc56b9482eb8c09475fec5e/" rel="bookmark">
			数据结构-树-树的前序、中序、后序遍历详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树的前序遍历、中序遍历、后序遍历详解 zlingyun
遍历是针对根节点的
前序遍历顺序：根节点--左子树--右子树, 根左右
中序遍历顺序：左子树--根节点--右子树, 左根右
后序遍历顺序：左子树--右子树--根节点, 左右根
深入一点去理解这个排序顺序是这样的
前序遍历首先访问根结点，然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。
中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，再访问根结点，最后遍历右子树。
后序遍历首先遍历左子树，然后遍历右子树，最后访问根节点。在遍历左、右子树时，仍然先遍历左子树，再遍历右子树，最后访问根结点。
也就是说我们在遍历的时候必然是一层一层去寻找，并且不断递归。
说明
已知前序遍历与中序遍历，可确定唯一二叉树；
已知中序遍历与后序遍历，可确定唯一二叉树；
但是已知前序遍历与后序遍历，无法确定唯一二叉树。
确定唯一二叉树
举个例子来看懂树的排序
如果我们已知中序遍历是DBEAFC，前序遍历是ABDECF，求后序遍历。
解：
根据前序遍历ABDECF，A肯定是根节点（第一个遍历根节点）。对照中序遍历，就能知道DBE是左子树，FC是右子树。
左子树：中序DBE，前序是BDE；说明B是左子树的根节点，D是B的左孩子，E是右孩子。
右子树类似：C是右子树的根节点，F是C的左孩子（因为中序遍历中F是在C前面的，所以一定是左孩子；如果F在C的后面，就是右孩子）
后序遍历DEBFCA
所以我们已知树去写三种不同的遍历的时候，就是不断的把树拆分成左子树，根节点，右子树，一级一级的拆分下去。最终获得最小的二叉树，可以轻易的写出来顺序。
或者我们已知两种遍历结果（前提是可以唯一确定二叉树），我们根据前序遍历或者后续遍历可以立即得到根节点是什么，根据根节点将中序遍历拆分，立即获得左子树与右子树内容。在一级一级的拆分下去。可获得完整的二叉树结构。
算法程序：
https://blog.csdn.net/Su_coding/article/details/70196173
原文链接：https://blog.csdn.net/zlingyun/article/details/81209058
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e989766e4cc6e6d02db3e05094a8cc/" rel="bookmark">
			【C&#43;&#43;】统计字符串中文、英文字母、空格、数字和其他字符的个数 / 判断中文字符（GBK）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文针对GBK编码进行编程，可以右键控制台选择属性查看。
若是UTF-8或其他编码，可以查询相对应的编码表，参考本文思路进行编程。
判断中文字符 首先，我们要知道输入一个中文字符，如果是GBK编码，那么要用两字节进行存储，如果拿string进行存储，那么字符串长度其实为2，s[0]是高字节而s[1]是低字节（此处涉及到内存存储，请参考大小端模式）。有了前置知识就好办了，我们判断中文字符的阻碍其实就是中文字符存储字节数的不确定和每个字节存储范围的不确定。如果我们能知道编码是什么，那么上面两个问题就都解决了。搜索资料可知GBK编码范围为0x8140到0xFEFE（这个0x其实是16进制表示的意思，两个十六进制位，就是8位也就是一个字节）。说人话：用16进制表示的话，高字节范围从81到FE，低字节范围从40到FE，若不符合则不是GBK中文字符。 参考代码 这个编程风格是为了缩格演示思路，并不规范，请见谅。。。
#include &lt;iostream&gt; #include &lt;map&gt; using namespace std; int main(){ cout&lt;&lt;"请输入字符串："&lt;&lt;endl; string s; getline(cin, s);	//获取一行输入 map&lt;string, int&gt; cnt;	//用于统计 for (int i=0; i&lt;s.length(); i++) { if ((s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') || (s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z')) cnt["英文字母"]++; else if (s[i]&gt;='0' &amp;&amp; s[i]&lt;='9') cnt["数字"]++; else if (s[i] == ' ') cnt["空格"]++; else if(i+1&lt;s.length() &amp;&amp; //防止越界 ((unsigned char)s[i]&gt;=0x81&amp;&amp;(unsigned char)s[i]&lt;=0xFE&amp;&amp; //高位 (unsigned char)s[i+1]&gt;=0x40&amp;&amp;(unsigned char)s[i+1]&lt;=0xFE)){ //低位 //使用unsigned char是因为unsigned不会变成负值，这样方便判断 cnt["中文字符"]++; i++; } else cnt["其它字符"]++; } for (map&lt;string, int&gt;::iterator it = cnt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e989766e4cc6e6d02db3e05094a8cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14bb41669fdc7fa33f6d21d00a2bb29c/" rel="bookmark">
			penumbra shadows in raymarched SDFs - 光线步进中使用有向距离场实现软阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Intro - 介绍The trick - 技巧An improvement - 改进GGB 原文：penumbra shadows in raymarched SDFs
Intro - 介绍 许多步进用的距离场(distance fields)函数，他们都是本身提供了全局信息。这意味着，当要着色着色某一点时，它可以使用距离场函数（distance function）很简单就探索出周围几何体。这不像传统的光栅器，它得使用一个预先烘焙好的全局全局光照数据给后续的使用（如shadowmap阴影图，depthmap深度图，pointcloud点云图），或是在一个光线追踪要查找全局信息就必须通过光线投射来采样几何体信息，而在distance field距离场中是着色期间就可以取到的，这简直就是免费的（“免费”是加了双引号）。这意味着许多逼真的着色器和光照技术使用距离场都是很简单就可以实现的。并且raymarcher射线步进器在采样/渲染时会更真实。此文将运用光线步进的这些良好的特性来免费渲染半影的软阴影。
免费的计算软阴影与半影
经典的光线投射阴影
The trick - 技巧 那么，假设你有一个距离场编码函数 float map(vec3 p)。你可以在这里
查看构建一些基础的距离函数。为了简便起见，假设 map() 函数包含了场景中所有需要渲染的对象，并且所有对象都允许投射阴影给其他对象。那么，在着色一个点的阴影计算是很简单的，沿着光方向的向量来射线步进，直到从光源到着色点的距离有碰撞到东西就好了。你可能需要处理类似这样的代码：
float shadow( in vec3 ro, in vec3 rd, float mint, float maxt ) { for( float t=mint; t&lt;maxt; ) { float h = map(ro + rd*t); if( h&lt;0.001 ) return 0.0; t += h; } return 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14bb41669fdc7fa33f6d21d00a2bb29c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c11b9202d8a35d8f26a7886edb25c48/" rel="bookmark">
			什么是异或_异或运算及异或运算的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是异或_异或运算及异或运算的作用 异或，是一个数学运算符，英文为exclusive OR，缩写为xor，应用于逻辑运算。
异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为：
a⊕b = （¬a ∧ b） ∨ （a ∧¬b）
如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。
异或也叫半加运算，其运算法则相当于不带进位的二进制加法：
二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），
这些法则与加法是相同的，只是不带进位。
异或略称为XOR、EOR、EX-OR
程序中有三种演算子：XOR、xor、⊕。
使用方法如下
z = x ⊕ y
z = x xor y
异或运算的作用 参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。
即：
0^0 = 0，
1^0 = 1，
0^1 = 1，
1^1 = 0
按位异或的3个特点：
（1） 0^0=0，0^1=1 0异或任何数＝任何数
（2） 1^0=1，1^1=0 1异或任何数－任何数取反
（3） 任何数异或自己＝把自己置0
按位异或的几个常见用途：
（1） 使某些特定的位翻转
例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。
10100001^00000110 = 10100111
（2） 实现两个值的交换，而不必使用临时变量。
例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：
a = a^b； //a=10100111
b = b^a； //b=10100001
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c11b9202d8a35d8f26a7886edb25c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/734ce8e39248d478753db30988f76602/" rel="bookmark">
			halcon中的Pose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pose
姿态描述的是一个刚性的3D转换，即，一种由任意平移和旋转组成的变换。在Halcon中，一个pose是具有7个参数的元组：3个参数描述平移（TransX、TransY、TransZ），3个参数描述旋转（RotX、RotY、RotZ）。最后一个参数确定了平移和旋转的顺序（以及旋转的方向）
3D姿势有两种解释：第一种，描述了一个坐标系相对于另一个坐标系的位置和方向（例如，一个零件坐标系相对于照相机的坐标系统的姿态，即两件相对于照相机的姿态）。第二种解释，一个姿势描述了如何在两个坐标系之间转换坐标（例如，将点从局部坐标转换为摄像机坐标）
将点坐标从坐标系1（cs1）转换为坐标系2（cs2）的位姿表示为。在cs1（）中给出的点到cs2（）的对应转换记为：
请注意，上面的表示法仅用于可读性，不是姿态（作为一个元组）用作乘法，而是由这个姿态描述的转换，因此，姿态描述了由齐次变换矩阵表示的刚性变换
所以描述了从cs1到cs2的点的转换，此外，它也描述了坐标系统本身的转换，但是以相反的顺序：描述了如何转换坐标系2以获得坐标系1.从而能得到坐标系2相对于坐标系1的位姿。
由此，位姿就可以像齐次矩阵一样连接起来：
这样的连接可以使用pose_compose来完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a40793f24a89015c31590d03bca197/" rel="bookmark">
			vs2019配置OpenCV4.30（win10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs2019配置OpenCV4.30 新的任务是学习OpenCV，第一步当然是配置环境。社区里虽然有各种教程，但作为小白的我依然遇到了许多问题。决定总结一下， 避免和我一样的小白踩雷。并且也算是最新的一版本的教程。
vs2019 宇宙最强IDE没的说，安装就阔以，此处给出社区版在线安装器vs2019，下载好选择你需要的扩展即可。如果和我一样是c语言的话按下图即可。之后要注册账号那些后续步骤。（后续如果需要新的功能和扩展可在vs的工具选项卡第一个选项获取工具和功能里在选择下载）
OpenCV 大家有各自的OS，相应在OpenCV官网下载就行，这里给出Windows的地址win64建议某雷下载，比较快
下载完成是一个自解压文件，找到合适 的地方解压就可以。记住地址！
配置OpenCV的本地环境 首先需要将OpenCV的地址放到path里。在桌面右键计算机选属性。选择左侧的高级系统设置
选择下面的环境变量
进来就比较有意思了，有的教程说把路径（之前解压OpenCV的文件bin的位置）加在用户里，有的说加在系统里，反正我都加了，也没啥问题。（建议加在系统变量里）C:\OpenCV\opencv\build\x64\vc15\bin这个路径。举例而已，大家知道是这个文件夹就可以。我是放在c盘了。
具体操作就是选择PATH然后点编辑，进去之后选择新建，然后复制地址即可。
还有的教程把两个动态链接库dll文件复制到了相应的文件夹，有的教程没放，本着宁可信其有不可信其无的态度，我也放了。操作如下。
vc15-bin文件夹中的opencv_world430.dlll和opencv_world430d.dll文件复制到C:\Windows\SysWOW64
将bin目录的opencv_videoio_ffmpeg430_64l复制到C:\Windows\System32。
vs2019中环境搭建 在你新建的c控制台项目里，右侧的解决方案管理器中右键你的项目选择项目属性。
如图选择VC++,我们分别要对include和库进行设置。如图即可。
这是库目录需要编辑的。点那个文件夹小图标即可选择相应的文件夹。大家按照图上的我的相对路径选择自己的文件夹即可。
然后选择链接器下输入选项，附加依赖项中如图添加。
一定要按图片上的名字写不然会报错，如果你只是复制了你文件的名字是不行的。必须有后缀lib。好多人卡在这了。以上就是全部配置了。
现在大家可以试一试运行demo测试。（可能会碰到预编译的问题，每个人情况不同。百度即可）
#include &lt;iostream&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/core.hpp&gt; #include &lt;opencv2/imgcodecs.hpp&gt; using namespace cv; using namespace std; int main() { Mat image; image = imread("C:\\Users\\Administrator\\Pictures\\25.jpg"); // 选择一张图片 if (image.empty()) // Check for invalid input { cout &lt;&lt; "Could not open or find the image" &lt;&lt; std::endl; return -1; } namedWindow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a40793f24a89015c31590d03bca197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f140797058ea82240afed7d5492463d3/" rel="bookmark">
			渗透测试文件传输：python -m SimpleHTTPServer 80及设置下 code 404, message File not found问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们做渗透时
有很多情形需要从本机传输文件到靶机，或者在某处需要调动本机的恶意文件
可以本机开启apache2，
systemctl start apache2 这样你本机里/var/www/html路径下存放的文件，就可以通过http调用了。
形式就是你的ip + 文件。 比如你的ip是10.10.10.10. 文件是xxx
就在靶机里输 wget http://10.10.10.10/xxx 就可以下载这个文件了到靶机了
但是也有很多情况的漏洞利用较复杂。
有些漏洞的脚本利用可能是先调用文件，再执行。等
但是我们没有收到shell
排查问题，到底是调用本机文件就出问题了，还是后面的执行环节出问题了
systemctl start apache2这个还不够
而
python搭建的简易http服务很方便。本机打开
python -m SimpleHTTPServer 80 同样的功效，
还能看是否调用
成功的是200
失败的是404
如果没有任何显示，那就是根本在调用环节就出了问题，没有来你本机找文件。还要继续排查是哪个命令弄错了。
这里有个问题小细节。
你在哪个目录下的终端打开python -m SimpleHTTPServer 80，那么实际上你在浏览器输入127.0.0.1，发现http的内容就是哪个目录下的文件。
不再一定是/var/www/html了。
比如我在root下打开，那以后靶机调用文件就是从我本机的root目录下找。如果我是在/root/666目录下打开，那么就是在666目录找文件。
如果没意识到的话，会非常懵的，明明放在/var/www/html路径里了，怎么还一直报错找不到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bff9b69a237c57b40c8faa7d3e91099/" rel="bookmark">
			sqlite 中的类似top的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlite中没有像申请了server、mysql的select top 5 from tb 的用法，但是在网上突然发现可以用 limit 5 offset 2了真是一个不错的东西；
这个用来分页查询非常ok，对limit 5 offset 2进行解释一下：
5：需要去到数据的行数 2：去除几行，即从第三行开始取数据
另外 直接limit 5 不要offset 2就等于limit 5 offset 0；
都是在别人的博客看见的，只是多加了一个标题，让大家能够方便进行搜索！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fe4be8cb0f15e94ff085158cd91169/" rel="bookmark">
			【MongoDB】日志文件过大/logRotate解决日志轮转的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于mongodb不提供自动按天来输出日志文件的rotate配置。
如果日志文件清理不及时，会导致mongo越来越慢，甚至服务莫名down掉。
下面就我们在实践过程中使用logRotate的解决日志文件切割的方案叙述一下。
首先看一下官方文档对于logRotate的叙述：
一、定义（Definition） logRotate logRotate命令是一个管理命令，它可以轮转MongoDB日志，以防止单个日志文件占用过多的磁盘空间。
必须对admin database发出logRotate命令，方式如下：
{ logRotate: 1 } 注意：您的mongod实例需要使用--logpath [file]选项运行。
也可以通过将SIGUSR1信号发送到mongod进程来轮转日志。比如mongod的进程ID为2200，则在Linux上发送信号的方法如下：
kill -SIGUSR1 2200 二、行为（Behavior） systemLog.logRotate设置或--logRotate选项规定了logRotate的行为。
当systemLog.logRotate或--logRotate设置为rename时，logRotate通过将当前时间戳附加到文件名来重命名现有日志文件。附加的时间戳格式如下：
&lt;YYYY&gt;-&lt;mm&gt;-&lt;DD&gt; T &lt;HH&gt;-&lt;MM&gt;-&lt;SS&gt; 然后，logRotate创建一个新的日志文件，新文件名与最初由mongod或mongos的systemLog.path设置规定的日志文件名相同。
将systemLog.logRotate或--logRotate设置为reopen时，logRotate遵循典型的Linux / Unix行为，仅关闭日志文件，然后重新打开同名的日志文件。通过reopen，mongod期望在轮转之前，另一个进程会重命名该文件，并且创建新文件实现重新打开会。
原文链接：https://docs.mongodb.com/manual/reference/command/logRotate/
三、实践篇 1.打开mongo shell（由于在mongod实例的本地打开此命令，故--ip省略）。 D:\MongoDB\Server\3.4\bin&gt;mongo --port 你的端口 2.切换到admin数据库。 use admin 3.授权。 db.auth("你的管理账号", "你的密码") 4.执行logRotate命令。 db.adminCommand({logRotate:1}) 1-4步执行过程如下图所示：
5.执行结果 四、制定计划任务，每天自动轮转 1.制定计划任务 在操作系统的“任务计划程序”中添加计划任务，填写时间、操作等信息，内容如下：
2.编写bat脚本 编写日志轮转的bat执行脚本文件，新建一个后缀名是.bat文件内容如下：
@call :output&gt;logRotate.log exit :output @ECHO OFF echo %date:~0,4%-%date:~5,2%-%date:~8,2% %time% log rotate begin...... D:\MongoDB\Server\3.4\bin\mongo --host 你的ip --port 你的端口 -u 你的管理账号 -p 你的密码 --authenticationDatabase admin --eval "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fe4be8cb0f15e94ff085158cd91169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644c3f58b04c8217d7750a1431ef7acd/" rel="bookmark">
			nuxt引用组件报错：This relative module was not found:* ./xxx.vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nuxt引用组件时报错：
This relative module was not found: * ./xxx.vue?xvue&amp;type=style&amp;index=0&amp;id=fad11dd4&amp;scoped=true&amp;lang=scss&amp; in ./components/xxx.vue 仔细看了下有导入组件，也有注册，找了好久发现是因为子组件中用了sass，但是没有安装依赖，安装node-sass和sass-loader后就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4c4b31e61f5a22fad48179ad7c77ac/" rel="bookmark">
			常用向量空间距离计算的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用向量空间距离包括：
1、欧式距离
2、余弦距离和余弦相似度
3、曼哈顿距离
……
下面介绍一下常用的计算方法：
1、计算向量的余弦距离
2、使用scipy计算常用向量空间距离
3、使用sklearn计算常用向量距离
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef4c12996388730808de972acf26e45/" rel="bookmark">
			HTML基础学习知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML简介 HTML：超文本标记语言
HTML百度百科
html特点：
html不需要编译，直接通过浏览器展现html文件是一个文本文件必须使用html/htm作为文件后缀名大小写不敏感，HTML与html一样 开发工具：
普通：记事本、wordDreamweaer–DW、webstorm–ws、sublime、hbuilder HTML基础 html基本结构 &lt;!DOCTYPE html&gt; &lt;!--&lt;!DOCTYPE html&gt;是一个html文档类型声明，必须放在第一行，不是html标签--&gt; &lt;!-- 整个html文件 --&gt; &lt;html&gt; &lt;!--头部信息--&gt; &lt;head&gt; &lt;!--当网页出现中文乱码时，在head包裹下添加meta标签处理--&gt; &lt;meta http-equiv="Congtent-Type" content="text/html;charset=utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;!--网页主题部分--&gt; &lt;body&gt; 网页主题内容 &lt;/body&gt; &lt;/html&gt; HTML标签 添加标签基本语法：
&lt;标签名 属性名1=“属性值” 属性名2=“属性值”&gt;…&lt;/标签名&gt;
例如：&lt;body bgcolor="red"&gt;...&lt;/body&gt;
常用的标签
标题标签：&lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt;
段落标签：&lt;p&gt;&lt;/p&gt;
换行标签：&lt;br/&gt;
预编译标签：&lt;pre&gt;&lt;/pre&gt; (复制的原内容 原模原样的展现出来）
水平线标签：&lt;hr/&gt;
文字斜体标签：&lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt;
加粗标签：&lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt;
上标：&lt;sup&gt;&lt;/sup&gt;
下标：&lt;sub&gt;&lt;/sub&gt;
align对齐方式的属性值
左对齐（默认）：align="left"右对齐：align="right"居中：align="center"两端对齐：align="justify" (对行进行伸展，使每行都有相等的长度） 特殊字符
. &lt; : &amp;lt;. &gt; :&amp;gt;已注册: &amp;reg;版权标：&amp;copy;TM商标:&amp;trade;space空格键:&amp;nbsp; 列表标签 无序列表 &lt;ul type="disc"&gt; &lt;!--type属性值 disc圆点， square正方形 ，circle空心圆--&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef4c12996388730808de972acf26e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/483b6a7abb8a579557668e58a2d0c780/" rel="bookmark">
			Windows查看和导入证书（.cer / .pfx）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 证书介绍问题汇总导入导出细节注意如何查看以上两种证书的到期日？ Windows下导入证书 证书介绍 作为文件形式存在的证书一般有以下几种格式：
带有私钥的证书
由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作为证书文件后缀名。
二进制编码的证书
证书中没有私钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。
Base64编码的证书
证书中没有私钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。
由于cer证书只包含公钥信息，一般只能用于解密使用（解密该公钥对应的私钥加密的数据）
问题汇总 导入导出细节注意 pfx证书既可以导出为pfx证书，也可以导出为cer证书。cer证书不能导出为pfx证书。导出pfx证书时，会提示是否导出私钥，导出私钥即pfx证书，不导出则是cer证书。
如果选择导出私钥，出于安全性考虑，浏览器会提示你指定一个密码用于保护该私钥，以后再次导入该pfx证书时，浏览器会要求你提供该私钥保护密码。导入pfx证书时，需要指定私钥保护密码，另外还有一个选项“标志此密钥为可导出密钥。这将允许您稍后备份或传输密钥”。出于安全性考虑，该选项默认是不勾选的，如果不勾选，下次从浏览器导出该证书时，则无法导出pfx证书，只能导出不包含私钥的cer证书了。pfx证书默认导入到“个人”选项卡下。cer证书只能导入到“其他人”选项卡下，无法导入到“个人”选项卡下。 如何查看以上两种证书的到期日？ .cer
双击该证书，出现证书信息的页面，在上面就可以找到证书的到期日。.pfx
双击该证书，就会出现一个导入的向导页面，不太容易看到到期日。可以先导入，再查看。 Windows下导入证书 Windows系统中，windows键 + R （快捷方式），输入 mmc, 点击确定， 出现下面的界面：
点击文件， 然后点击： 添加/删除管理单元(M)…
左侧选择证书，然后点击：添加。 后面就可以根据提示操作即可：
接下来在 “个人” 那里导入证书即可，
导入成功后，点击 个人下的 证书，就可以在右侧界面，找到该.pfx证书的信息，就可以看到到期日。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85657b8520a1e3e2d287523ff62e15ce/" rel="bookmark">
			C语言浮点数的输出方法和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、浮点数的输出2、获取视频教程3、版权声明 1、浮点数的输出 float采用%f占位符。
double采用%lf占位符。测试结果证明，double不可以用%f输入，但可以用%f输出，但是不建议采用%f，因为不同的编译器可能会有差别。
long double采用%Lf占位符，注意，L是大写。
浮点数输出缺省显示小数点后六位。
浮点数采用%lf输出，完整的输出格式是%m.nlf，指定输出数据整数部分和小数部分共占m位，其中有n位是小数。如果数值长度小于m，则左端补空格，若数值长度大于m，则按实际位数输出。
double ff=70001.538; printf("ff=%lf=\n",ff); // 输出结果是ff=70001.538000= printf("ff=%.4lf=\n",ff); // 输出结果是ff=70001.5380= printf("ff=%11.4lf=\n",ff); // 输出结果是ff= 70001.5380= printf("ff=%8.4lf=\n",ff); // 输出结果是ff=70001.5380= 2、获取视频教程 百万年薪程序员录制，《C/C++高性能服务开发基础》视频教程已在CSDN学院发布，优惠价12元，地址如下：
https://edu.csdn.net/course/play/29402
3、版权声明 C语言技术网原创文章，转载请说明文章的来源、作者和原文的链接。
来源：C语言技术网（www.freecplus.net）
作者：码农有道
如果这篇文章对您有帮助，请点赞支持，或在您的博客中转发此文，让更多的人可以看到它，谢谢！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e7f6404c3ec7ba14418848e0125589/" rel="bookmark">
			从2D图像如何生成3D模型（点云）深度学习的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://chenhsuanlin.bitbucket.io/3D-point-cloud-generation/paper.pdf
摘要：
对于3D物体的重建，信息主要丰富在表面。本文的目的在于以密集点云的形式表示3D模型，
这边文章讲的就是用2D图像如何生成3D模型。2D图像也是从3D的世界投影来的，从3D到2D必然是缺少了很多信息的，所以单一视角的2D图像是不可能恢复出3D模型的。如果非要的必须要有一些先验知识。
作者说采用这种编码解码学习一个压缩的表达，是最有希望的方式（黑人问号？）
关于3D模型的表达方式，有以下三种：
先看看体素网格：
体素网格就是用规则的有体积的小网格去表达3D模型，会损失一些细节，当分辨率越高，需要的小网格也就越多，但其实我们只需要表面的，所以就算量比较大，要衡量分辨率和计算量之间的权衡，不过这种表达方式还是比较容易地输入到CNN里面。
多边形网丝：由顶点、边缘和朝向（定义表面的3要素）组成，它可以抓住细小的细节。
点云：（x,y,z),点云数量越多表达的越细节。
以上两个优点在于表达细腻，但是不能直接用于CNN网络
方案：
我们使用点云紧实的的表达和传统的2d 卷积，学习先验的形状信息。
第一步：3D结构生成器 该模块根据2D的RGB图和物体对应的binary mask预测像素点的三维坐标（x,y,z)，
该步骤的输入输出为：
其中：2D projection == 3D coordinates (x,y,z) + binary mask (m)
第二步：Point Cloud Fusion（点云融合）
融合点云成3D模型，这是可行的（因为每幅图像对应的3D姿态是固定的且事先知道的）
其输入输出如下：
第三步：根据3D模型生成新的2D投影，跟GroundTruth比对计算loss
其输入输出如下：
也就是说如果生成的3D模型是接近真实的，那么新视角的投影应该也是接近真实的ground_truth
总体的流程如下图所示：
结果对比： 下图是真实的点云信息和生成的点云信息的对比：
最终的结果：
总结： 本文确实是从一系列的2D图像以及每张图片对应的映射矩阵生成3D模型，最聪明的举动在于融合和新角度的渲染生成，陈生了差异以及几何意义，利用这种差异我们才能从2D投影学习到3D点云。
代码地址： Pytorch code: https://github.com/lkhphuc/pytorch-3d-point-cloud-generation
Tensorflow code: https://github.com/chenhsuanlin/3D-point-cloud-generation
Paper: https://arxiv.org/abs/1706.07036
Original project website: https://chenhsuanlin.bitbucket.io/3D-point-cloud-generation/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03700c23ac061d14be8cf9f01fea597c/" rel="bookmark">
			交换两变量值--两种较高效率方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.可以用两个数求和然后相减的方式进行数据交换,弊端在于如果 x 和 y 的数值过大的话，超出 int 的值会损失精度。
x = x + y; y = x - y; x = x - y;
2.利用位运算的方式进行数据的交换，利用的思想原理是：一个数异或同一个数两次，结果还是那个数，而且不会超出int范围。
x = x^y;
y = x^y;
x = x^y;
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/216/">«</a>
	<span class="pagination__item pagination__item--current">217/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/218/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>