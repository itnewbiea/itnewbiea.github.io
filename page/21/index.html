<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3982de0ebeb08cf84268001606116707/" rel="bookmark">
			com.android.ide.common.signing.KeytoolException: Failed to read key key0 from store “C:\Users\abc\.a
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、报错信息二、解决方法 一、报错信息 com.android.ide.common.signing.KeytoolException: Failed to read key key0 from store "C:\Users\abc\.android\oppo.jks": Get Key failed: getSecretKey failed: Password is not ASCII Execution failed for task ':app:packageRelease'. &gt; A failure occurred while executing com.android.build.gradle.internal.tasks.Workers$ActionFacade &gt; com.android.ide.common.signing.KeytoolException: Failed to read key key0 from store "C:\Users\abc\.android\oppo.jks": Get Key failed: getSecretKey failed: Password is not ASCII 根据英文提示：你的秘钥密码不是ASCII字符集。
二、解决方法 Build—&gt;Generate Signed APK——APK，然后选择你本地的秘钥，输入正确密码，再设置一个别名，输入正确密码。下一步选择release类型的数字签名，继续选择V2版本的签名，最后点击Finish即可。
然后等待打包APK，过程会很快，有可能会报资源文件格式的问题，将对应图像的格式修改好即可。
点击下方提示信息，然后可以直接定位到apk的 生成目录。
9:53	Generate Signed APK APK(s) generated successfully for module 'BookAdminister.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3982de0ebeb08cf84268001606116707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf130e27fa02d981b1c9b4d0cc8e1579/" rel="bookmark">
			案例071:基于微信小程序的汽车预约维修系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
后台模块的实现
用户信息管理
技师管理
用户预约管理
小程序会员模块的实现
系统首页
我的菜单
用户预约
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了基于微信小程序的汽车预约维修系统的开发全过程。通过分析基于微信小程序的汽车预约维修系统管理的不足，创建了一个计算机管理基于微信小程序的汽车预约维修系统的方案。文章介绍了基于微信小程序的汽车预约维修系统的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本基于微信小程序的汽车预约维修系统管理员功能有个人中心，用户管理，技师管理，用户预约管理，取消预约管理，订单信息管理，系统管理。技师和用户可以注册和登录，用户可以预约和取消预约技师，并且可以产生订单信息。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得基于微信小程序的汽车预约维修系统管理工作系统化、规范化。
系统展示 后台模块的实现 用户信息管理 管理员可以管理用户信息，可以对用户信息添加修改删除。
技师管理 管理员可以技师信息进行添加修改删除操作。
用户预约管理 管理员可以查看用户预约信息。界面如下图所示：
小程序会员模块的实现 系统首页 小程序用户是需要注册才可以进行登录的，登录后在首页可以查看相关信息，并且下面导航可以点击到其他功能模块。界面如下图所示：
我的菜单 在小程序里点击我的，会出现关于我的界面，在这里可以修改个人信息，以及可以点击其他功能模块。界面如下图所示：
用户预约 用户可以对自己感兴趣的技师进行预约操作。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf130e27fa02d981b1c9b4d0cc8e1579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b55128e882ff3597a792fb2a375f49/" rel="bookmark">
			使用Vscode远程debug报错找不到Module找不到File
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1..报第一个错 提示我无法导入自己写的module
如图：
解决办法：
stackoverflow上说的在launch.json中加了一条 env，就解决了。
"env": { "PYTHONPATH":"/home/zt/ge-sc-master/ge-sc-master"}, 2.解决完第一个问题继续debug出现了第二个错误FileNotFound
因为我加载数据时使用的是相对路径，那么需要在launch.json中把省略的这部分相对路径写入cwd
所以launch.json中cwd应该为
但是呢改完之后，又报了错误一，我真的服了。。。，难道是cwd跟env设置有冲突了？？？不知道。。最后我还是把相对路径改成绝对路径了，最后debug成功了。。。
真实一场酣畅淋漓的debug啊。麻了浪费姐仨小时。也没搞明白为啥加了cwd不能行，如果有路过的我解释不清楚可以看看这篇说的已经很清楚了。【Vscode-Debug调试】 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5860d2f38a48ebf4bb75e8569e40853d/" rel="bookmark">
			HTML5-新增语义相关标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义相关标签 address 概念：address元素定义为文档或文章添加联系信息
语法：
&lt;address&gt;&lt;/address&gt; 如果address元素位于body元素内，则表示该网站所有者的联系信息
如果address元素位于article元素时，表示该篇文章所有者的联系信息
实例：
&lt;h1&gt;address元素应用于整个页面&lt;/h1&gt; &lt;footer&gt; &lt;address&gt; 电子邮件:111@111 地址信息：1122 &lt;/address&gt; &lt;p&gt;例子&lt;/p&gt; &lt;/footer&gt; &lt;article&gt; &lt;h1&gt;address应用于article元素&lt;/h1&gt; &lt;footer&gt; &lt;address&gt; 通过电子信息联系作者：11 &lt;/address&gt; &lt;p&gt;例子&lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; mark 标注，用来突出显示文本，默认添加黄色背景
time 概念：定义日期和时间，便于搜索引擎智能查找
语法：
&lt;time datetime="时间"&gt;&lt;/time&gt; datetime属性取值是一个时间，可以省略不写。
datetime属性中的时间是提供给搜索引擎看的
time标签内容的时间是提供给用户看到
这两者内容可以一样也可以不一样
实例：
&lt;time&gt;2023-12-22&lt;/time&gt; &lt;br/&gt; &lt;time datetime="2023-12-22"&gt;2023-12-22&lt;/time&gt; &lt;br/&gt; &lt;p&gt;我在&lt;time datetime="2023-12-14"&gt;情人节&lt;/time&gt;有个约会&lt;/p&gt; 运行结果:
meter 概念：以进度条的形式来表示数据所占的比例
语法：
&lt;meter min="最小值" max="最大值" value="当前值"&gt;&lt;/meter&gt; 常用属性:
max 定义最大值，默认为1
min 定义最小值，默认为0
value 定义当前值
high 定义限定为高的值
low 定义限定为低的值
optimum 定义最佳值
规定:
如果optimum大于high，则表示值越大越好 当value大于high时为绿色 当value在low和high之间时为黄色 当value小于low时为红色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5860d2f38a48ebf4bb75e8569e40853d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed70775996865b77529cc091befdc84b/" rel="bookmark">
			Java虚拟机中的垃圾回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 垃圾回收 2.1 判断一个对象是否可回收 2.1.1 引用计数法 如果一个对象被另一个对象引用，那么它的引用计数加一，如果那个对象不再引用它了，那么引用计数减一。当引用计数为 0 时，该对象就应该被垃圾回收了。
但是下面这种互相引用的情况就无法回收了：
两个对象的计数都为1，导致两个对象都无法被释放
2.1.2 可达性分析算法 垃圾回收之前，扫描所有对象，判断每个对象是否被根对象引用，如果没有被根对象引用，那么在以后垃圾回收时就将那些没有与根相连的对象回收
Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收哪些对象可以作为 GC Root ? 查找可以作为GCRoot的对象：
运行下面程序：
public static void main(String[] args) throws IOException { ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("b"); list.add(1); System.out.println(1); System.in.read(); list = null; System.out.println(2); System.in.read(); System.out.println("end"); } 使用 jmap -dump:format=b,live,file=1.bin 进程id 将堆内存中的信息存储到文件1.bin中
使用Eclipse Memory Analyzer 打开1.bin文件，选择 GC Root 选项进行分析：
可以看出 GC Root 分为四类：
System Class ：系统类，启动类加载器加载的类，例如Object，HashMap等核心类Native Stack：Java 有时候需要调用系统中的一些方法Busy Monitor ：被加锁的对象也需要被保留Thread：活动线程的栈帧内中使用的对象 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed70775996865b77529cc091befdc84b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fa49b7d5939cdf420149e520454f63/" rel="bookmark">
			【mysql】—— 表的内连和外连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，内连（INNER JOIN）和外连（OUTER JOIN）是用于联接多个表的操作。接下来，我分别给大家介绍下二者。
目录
（一）内连接
1、什么叫内连接
2、语法格式
3、案例：显示SMITH的名字和部门名称（来自oracle 9i的经典测试表）
（二）外连接
1、什么叫外连接
2、左外连接
2.1案例演示
3、右外连接
3.1案例演示
4、全外连接
5、练习演示
（三）实战OJ
（四）总结
（一）内连接 1、什么叫内连接 在MySQL中， 内连接 实际上就是利用 where 子句对两种表形成的笛卡儿积进行筛选，我们前面学习的查询都是内连接，也是在开发过程中使用的最多的连接查询。 2、语法格式 💨 以下是内连接的基本语法： SELECT 列名
FROM 表1
INNER JOIN 表2 ON 表1.关联列 = 表2.关联列;
注：内连会返回同时存在于表1和表2中的行，并且仅包括满足关联条件的行。
3、案例：显示SMITH的名字和部门名称（来自oracle 9i的经典测试表） 之前我们通过笛卡尔积可以对其进行操作，今天我们通过内连接的方式来进行有关操作。具体如下：
用前面的写法： select ename, dname from EMP, DEPT where EMP.deptno=DEPT.deptno and ename='SMITH'; 结果展示： 用标准的内连接写法： select ename, dname from EMP inner join DEPT on EMP.deptno=DEPT.deptno and ename='SMITH'; 结果展示： 【小结】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1fa49b7d5939cdf420149e520454f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0d01f55ba68687d92cedf5f9a828e9/" rel="bookmark">
			常见的Transformers（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from PIL import Image from torch.utils.tensorboard import SummaryWriter from torchvision import transforms writer = SummaryWriter('logs') img = Image.open(r'D:\Pytorch\hymenoptera_data\train\ants_image\6240329_72c01e663e.jpg') # ToTensor trans_totensor = transforms.ToTensor() img_tensor = trans_totensor(img) writer.add_image('ToTensor', img_tensor) #Normalize trans_norm = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) img_norm = trans_norm(img_tensor) writer.add_image('Normalize', img_norm) print(img_tensor[0][0][0]) print(img_norm[0][0][0]) #Resize print(img.size) # (500, 369) trans_resized = transforms.Resize((512, 512)) img_resize = trans_resized(img) img_resize = trans_totensor(img_resize) writer.add_image('Resized', img_resize,0) # Compose - resize - 2 trans_resized_2 = transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b0d01f55ba68687d92cedf5f9a828e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87b8e14b7b9e948531631ea69035a5f4/" rel="bookmark">
			利用Pandas进行高效网络数据获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Pandas进行高效网络数据获取 背景： ​ 最近看到一篇关于使用Pandas模块进行爬虫的文章，觉得很有趣，这里为大家详细说明。
基础铺垫： ​ pd.read_html pandas 库中的一个函数，用于从 HTML 页面中读取表格数据并返回一个包含 DataFrame 对象的列表。那么说明是表格数据呢，就是table标签的，如下图！
​ 我们可以使用XPath快速判断当前页面是否具有使用Pandas进行爬虫的前提条件。
​ pd.read_html(io, match=‘.+’, flavor=None, header=None, index_col=None, skiprows=None, attrs=None, parse_dates=False, thousands=‘,’, encoding=None, decimal=‘.’, converters=None, na_values=None, keep_default_na=True, displayed_only=True)
参数说明：
io: 接受的输入数据，可以是一个 HTML 字符串、一个 URL、一个文件路径或一个文件对象。match (可选): 一个正则表达式，用于匹配要提取的表格的 HTML 属性。flavor (可选): 解析器的名称，例如 'html5lib'、'lxml'、'html.parser' 等。其他参数：例如 header、index_col、skiprows 等参数用于控制读取表格数据的方式和格式。 案例实战： pd.read_html 函数会尝试从输入数据中提取所有的表格，并返回一个包含 DataFrame 对象的列表，就是一个列表里存在多个dataframe类型，每个 DataFrame 对象对应一个表格。
import pandas as pd # 从 HTML 页面中读取表格数据 url = 'https://vip.stock.finance.sina.com.cn/q/go.php/vFinanceAnalyze/kind/profit/index.phtml?p=1' tables = pd.read_html(url) print(tables,type(tables),len(tables)) # 选择第一个表格的 DataFrame 对象 df = tables[0] # 打印 DataFrame print('---------------------------------------') print(df,type(df)) ​ 那么如果爬取多页呢？ 写个for循环，然后使用concat拼接起来，不会拼接的看一下我不久前写的博客。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87b8e14b7b9e948531631ea69035a5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63442fca9c5115767f00648efa5ff068/" rel="bookmark">
			electron-builder 打包exe后白屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目用的是An Electron application with Vue3 and TypeScript。
Debug运行项目没问题，可以显示页面。不过有浏览器控制台显示错误：
Unable to load preload script：preload/index.js
Unable to load preload script 翻译后：无法加载预加载脚本。
猜测指向的加载index.js路径有问题。最后改成输出out文件中：
__dirname：程序exe运行的路径
// HMR for renderer base on electron-vite cli. // Load the remote URL for development or the local html file for production. if (is.dev &amp;&amp; process.env['ELECTRON_RENDERER_URL']) { console.log("__dirname=====&gt;"+__dirname); mainWindow!.webContents.openDevTools(); mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL']) } else { //mainWindow.loadFile(join(__dirname, '/renderer/index.html')) mainWindow.loadFile(join(__dirname,'../../out/renderer/index.html')); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eec25d0bcdee36a46145d578fa3c279/" rel="bookmark">
			k8s报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决failed to verify certificate: x509报错问题
[root@master1 home]# kubectl get nodes
Unable to connect to the server: tls: failed to verify certificate: x509: certificate signed by unknown authority (possibly because of “crypto/rsa: verification error” while trying to verify candidate authority certificate “kubernetes”)
处理：
[root@master1 ~]# rm -rf .kube/ [root@master1 ~]# sudo mkdir ~/.kube [root@master1 ~]# sudo cp /etc/kubernetes/admin.conf ~/.kube/ [root@master1 ~]# cd ~/.kube [root@master1 .kube]# sudo mv admin.conf config [root@master1 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eec25d0bcdee36a46145d578fa3c279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db49ded132f52dc03cc95e0393f2cb18/" rel="bookmark">
			DjangoRestFramework概括
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 drf入门规范 前后端开发模式：混合、分离
API接口：地址、请求方法、请求参数、返回值
测试软件的使用：postman、Apifox等
序列化和反序列化
restful规范：比如http响应状态码
在Django中写符合规范的接口
djangorestframework：django的app
快速使用
二 CBV源码分析 CBV源码分析
路由中，视图类.as_view() ----&gt; django的View的as_view() ----&gt;执行结果view内存地址----&gt;请求来了，路由匹配成功----&gt;view(request) ----&gt;return self.dispatch() ----&gt; View的dispatch ----&gt;通过反射，不同的请求会执行视图类中跟请求同名的方法
APIview源码分析
APIView继承了View 视图类： class BookView(APIView)：
路由中 ，视图类.as_view() ----&gt;drf的APIView的as_view() ----&gt;调用父类的as_view,去除csrf ----&gt;
View类的as_view内部的view闭包函数（加了个装饰器） ----&gt;view(request) ----&gt;return self.dispatch() ----&gt;APIView的dispatch()
三 Request类的对象 request.data
request.query_params
request.Files
request.method,request.path等
重写了魔术方法（）
四 序列化组件（drf核心） 能做的事：序列化、反序列化校验、序列化
Serializer ----&gt;book表先做序列化
定义序列化类
class BookSerializer (Serializer):
name=serializer.CharField()
使用序列化类
ser=BookSerializer(instance=qs,单个对象,many=True)
ser.data #字典
字段类：很多，如ListField、DictField
字段参数：反序列化校验，字段自己的规则
read_only write_only
反序列化校验：1.字段自己 2.局部钩子：validate_字段名 3.全局钩子validate
反序列化保存：校验过后，ser.save() ----&gt;判断instance是否存在，如果不存在，就是调用ser的create方法。在序列化类中，重写create
反序列化更新：校验过后，ser.save() ----&gt;判断instance是否存在，如果不存在，就是调用ser的update方法。在序列化类中，重写update
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db49ded132f52dc03cc95e0393f2cb18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee09a961838077e118fbd25ad9cef64/" rel="bookmark">
			网络安全（黑客）技术——高效自学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络安全是什么 网络安全可以基于攻击和防御视角来分类，我们经常听到的 “红队”、“渗透测试” 等就是研究攻击技术，而“蓝队”、“安全运营”、“安全运维”则研究防御技术。
2.网络安全市场 一、是市场需求量高； 二、则是发展相对成熟入门比较容易。 安全不是独立存在的，而是建立在其他技术基础之上的上层应用技术。脱离了这个基础，就很容易变成纸上谈兵，变成“知其然，不知其所以然”，在安全的职业道路上也很难走远。
如果你是原本从事网工运维，那么可以选择网络安全方向入门； 如果你原本从事程序开发，推荐选择Web安全/渗透测试方向入门。 当然学到一定程度、或者有了一定工作经验，不同方向的技术耦合会越来越高，各个方向都需要会一点。
3.所需要的技术水平 需要掌握的知识点偏多（举例）：
4.国家政策环境 对于国家与企业的地位愈发重要，没有网络安全就没有国家安全
更有为国效力的正义黑客—红客联盟
可见其重视程度。
5.自学网络安全学习的误区和陷阱 1.不要试图先成为一名程序员（以编程为基础的学习）再开始学习 行为：从编程开始掌握，前端后端、通信协议、什么都学。
缺点：花费时间太长、实际向安全过渡后可用到的关键知识并不多。
很多安全函数知识甚至名词都不了解 unserialize outfile
2.不要把深度学习作为入门第一课 很多人都是冲着要把网络安全学好学扎实来的，于是就很容易用力过猛，陷入一个误区：就是把所有的内容都要进行深度学习，但是把深度学习作为网络安全第一课不是个好主意。原因如下：
【1】深度学习的黑箱性更加明显，很容易学的囫囵吞枣
【2】深度学习对自身要求高，不适合自学，很容易走进死胡同
3.以黑客技能、兴趣为方向的自学误区： 行为：疯狂搜索安全教程、加入各种小圈子，逢资源就下，逢视频就看，只要是黑客相关的。
缺点： 就算在考虑资源质量后的情况下，能学习到的知识点也非常分散，重复性极强。
代码看不懂、讲解听不明白，一知半解的情况时而发生。
在花费大量时间明白后，才发现这个视频讲的内容其实和自己看的其他知识点是一样的。
4.不要收集过多的资料 网上有很多关于网络安全的学习资料，动辄就有几个G的材料可以下载或者观看。而很多朋友都有“收集癖”，一下子购买十几本书，或者收藏几十个视频
网上的学习资料很多重复性都极高而且大多数的内容都还是几年前没有更新。在入门期间建议“小而精”的选择材料，下面我会推荐一些自认为对小白还不错的学习资源，耐心往下看
6.网络安全学习路线 网络安全（黑客技术）学习路线图
需要高清pdf可以留言
第一阶段：安全基础 网络安全行业与法规
Linux操作系统
计算机网络
HTML PHP Mysql Python基础到实战掌握
第二阶段：信息收集 IP信息收集
域名信息收集
服务器信息收集
Web网站信息收集
Google hacking
Fofa网络安全测绘
第三阶段：Web安全 SQL注入漏洞
XSS
CSRF漏洞
文件上传漏洞
文件包含漏洞
SSRF漏洞
XXE漏洞
远程代码执行漏洞
密码暴力破解与防御
中间件解析漏洞
反序列化漏洞
第四阶段：渗透工具 MSF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ee09a961838077e118fbd25ad9cef64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0862853a1346d565815aa5f01279df69/" rel="bookmark">
			AJAX：整理1： 了解AJAX的相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 优点： （1）可以无需刷新页面与服务器端进行通信；
（2）允许你根据用户事件来更新部分页面内容
2. 缺点： （1）没有浏览历史，不能回退；
（2）存在跨域问题；
（3）SEO(搜索引擎优化)不友好 =&gt; 爬虫是爬不到的
3. HTTP协议： HTTP (hypertext transport protocol ) 协议 【超文本传输协议】，协议详细规定了浏览器和万维网服务器之间互相通信的规则。
（1）请求报文：【重点是格式与参数】
请求行：GET/POST /s ?ie=uef-8 HTTP/1.1
请求头：Host: baidu.com
Cookie: name = xx
Content-type: application/x-www-form-urlencoded
User-Agent: chrome 83
空行：
请求体：GET请求的话，请求体是空的；POST请求的话请求体可以不为空（userName=admin&amp;password=admin123）
（2）响应报文：
响应行：HTTP/1.1 200/404/500 OK
响应头：Content-type: text/html; charset=utf-8
Content-length: 2048
Content-encoding: gzip
空行：
响应体：&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;xx&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af72ca52d85f2dec2a7b8e7a30171212/" rel="bookmark">
			nrm的保姆级使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 鸿蒙专栏：想学鸿蒙的，冲
📢 C语言专栏：想学C语言的，冲
📢 VUE专栏：想学VUE的，冲这里
📢 CSS专栏：想学CSS的，冲这里
📢 Krpano专栏：想学VUE的，冲这里
🔔 上述专栏，都在不定期持续更新中！！！！！！！！！！！！！
目录
✨ 前言
✨ 什么是nrm
✨ 安装nrm
✨ 使用nrm
🔔 查看可用的源
🔔 增加自定义源
🔔 删除自定义源
🔔 测试源的响应时间
✨ 进阶应用
nrm的registry配置
永久使用源
nrm的权限控制
与yarn结合使用
使用nrm的安全性
✨ 结语
✨ 前言 作为前端开发，你一定使用过 npm 来安装第三方依赖包，但由于 npm 默认的下载仓储地址是 https://registry.npmjs.org/，属于外国的网站，所以我们下载的时候可能会非常的慢。所以淘宝也做了一个 npm 的镜像网站（看这里）。
比如我们切换成淘宝镜像源，我们可以通过以下命令完成切换：
$ npm config set registry https://registry.npmmirror.com/ # 或者直接在 npm 配置文件修改 $ npm config edit 虽然实现了镜像源的切换，但是这个貌似有点复杂，我们还要记住这个镜像地址 SO，nrm 它来了
✨ 什么是nrm nrm(npm registry manager)是一个NPM源管理器,它允许你快速地在如下NPM源间切换:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af72ca52d85f2dec2a7b8e7a30171212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730ea457c73407af7aa4a474f4a4e41f/" rel="bookmark">
			通讯协议入门——PS2(SPI协议)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 手柄跟键盘一样，都是人与机器沟通的一个工具，只是交互具体方式不太一样而已。作为开发者，我们也不用在意他们之间的差异，我们只需要知道他们之间是用什么进行沟通的。
就像人类沟通一样，要有嘴和耳朵，也就是发送器和接收器。发送器已经被厂家规定好软硬件，我们也可以做二次开发，但是本篇文章我们把重点放在微处理器（人的大脑）和接收器（人的耳朵）直接的沟通
解释： 什么是通信？什么是通信协议？http://t.csdnimg.cn/0eFMG
为什么要学习PS2手柄使用？http://t.csdnimg.cn/5OjAZ
一、硬件部分： 1. 接收器引脚及作用： （1）​​引脚：
​​​​​​​​
分析：我们初步学习只需要了解某些重要的引脚即可
（1）DI,DO为数据口，用于传输数据，DI为data in，指数据输入到我们使用的单片机
（2）CS用于选择该设备，低电平为选择
（3）CLK为时钟口，类似于节拍器，让两个单片机通讯时能同步
（4）VDD(3-5v)，GND为电源口
二、软件部分： 1、SPI通信协议 ​​​​​​​​​​​​
2、具体协议： 3、实验： 按下手柄按键，对应按键的LED灯亮
参考代码：（环境：IAP15FK61S2 12MHZ）
https://gitee.com/late-night-study/Tech
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc7caef819de2da6137761084e23c537/" rel="bookmark">
			项目记录：RabbitMq&#43;Redis配置消息队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、思路简述
二、配置依赖
三、RabbitMq配置类
四、增加操作
一、思路简述 这里主要配置的是增加操作，生产者部分负责将增加的数据存入redis，消费者部分负责将redis数据存入mysql。
二、配置依赖 配置RabbitMq的Maven：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置Redis的Maven：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 配置RabbitMq的yml：
rabbitmq: host: # 这里换成你的服务器地址 port: 5672 # 确保这里是RabbitMQ 实际用于客户端连接的端口，而不是管理界面端口 username: admin password: admin 配置Redis的yml：
data: redis: database: 0 host: port: 6379 password: 三、RabbitMq配置类 生产者：
import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class DirectRabbitConfig { //队列 起名：TestDirectQueue @Bean public Queue TestDirectQueue() { // durable:是否持久化,默认是false,持久化队列：会被存储在磁盘上，当消息代理重启时仍然存在，暂存队列：当前连接有效 // exclusive:默认也是false，只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable // autoDelete:是否自动删除，当没有生产者或者消费者使用此队列，该队列会自动删除。 // return new Queue("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc7caef819de2da6137761084e23c537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f69c4fedd78ff5f51b6bf5c4ea8c566/" rel="bookmark">
			【二叉树】【DFS】104.二叉树的最大深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目
法1：DFS class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } else if (root.left == null &amp;&amp; root.right == null) { return 1; } else { return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b02c0a58523c4c36a6873de71583f9/" rel="bookmark">
			透明度opacity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不仅对颜色有效，对图像或者页面中其它的元素也有效。
值为一个 0~1 之间的浮点数（小数），用来表示元素的透明度，值越小则越透明（0 表示完全透明，1 表示完全不透明）。
需要注意以下几点：
当一个元素定义了 opacity 属性，并且其值小于 1 时，那么它的子元素也会拥有同样的透明度； 当一个元素定义了 opacity 属性，并且其值小于 1 时，将会重新定义该元素默认的 z-index 属性，如果其它的元素为非定位元素，那么该元素的堆叠级别将会高于 其它元素； 如果定义的 opacity 属性值超过了指定的范围，那么则截取与之最相近的值。 兼容写法：
filter: alpha(opacity = number);
p { opacity: 0.5; filter: alpha(opacity=50); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c955093855308a5f46f76fdfed6652/" rel="bookmark">
			C#中的垃圾回收(简单理解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在C#中，当一个对象称为垃圾后任会占用内存空间，时间一长，就会导致内容空间的不足。为了清除这些无用的垃圾对象，释放一定的内容空间，C#中引用了垃圾回收机制。在这种机制下，程序员不需要过多关心垃圾对象回收的问题，.Net运行环境会启动垃圾回收器将这些垃圾对象从内容中释放，从而使程序获得更多可用的内容空间
除了等待运行环境进行自动垃圾回收，还可以通过调用GC.Collect()方法来通知运行环境立即进行垃圾回收。
注意：垃圾回收操作是在后台完成的，程序结束后，垃圾回收的操作也会终止。为了更好的观察垃圾对象被回收的过程，定义了Student类的析构函数，它的写法与构造方法类似，只不过需要再函数名称前面加上“~”号，析构函数会再对象销毁时，被垃圾回收器调用。
一个类只能有一个析构函数。
无法继承或重载析构函数。
无法调用析构函数，而是在对象被销毁时被自动调用的。
析构函数既没有修饰符，也没有参数。
C#中的析构函数是一种特殊的成员函数，用于在对象被销毁之前执行清理操作。析构函数的名称与类名相同，但在名称前面加上一个波浪线（~）。它不能带有任何参数，也不能被重载。
class MyClass { // 构造函数 public MyClass() { Console.WriteLine("对象已创建"); } // 析构函数 ~MyClass() { Console.WriteLine("对象将被销毁"); // 执行清理操作的代码 } } // 创建对象 MyClass obj = new MyClass(); // 对象将被销毁时，析构函数会自动调用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aafbaf96d3375f7408f18cda1ad2ee2c/" rel="bookmark">
			shell打印粉色小心心、颜文字心心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash # *********************************************************# # # # * Author : 白嫖一茶 # # * QQ邮箱址 : 2534824121@qq.com # # * Create time : 2023-12-29 16:08:04 # # * Filename : xin.sh # # * Description : This is Shell scripts # # # # # # *********************************************************# how_xin=10 color_red="\e[1;31m" color_null="\e[0m" color_purple="\e[0;35m" clear for i in {1..100} do echo -e "$color_red LoveLo LoveLo $color_null" echo -e "$color_red LoveLoLoveLoLoveLoLoveLo$color_null" echo -e "$color_red LoveLoLoveLoLoveLoLove $color_null"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aafbaf96d3375f7408f18cda1ad2ee2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7274b2dff5c25243e770f899792b57fa/" rel="bookmark">
			SpringCloud实战之Kubernetes项目运行示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文速览：
获取源码并加载环境spring-cloud-kubernetes下的示例mac minikube 本地构建执行SpringCloud-Kubernetes-Example 文章背景：
2019年开始 SpringCloud 开始向 K8S容器化流程演变，逐步诞生了【Spring-Cloud-Kubernetes】
环境要求：
maven 3.+jdk17 获取源码并加载环境 从github仓库获取源码
git clone https://github.com/spring-cloud/spring-cloud-kubernetes.git 导入IDEA后，确认以下构建环境
maven 3.+jdk17当前springcloudkubernetes版本：3.1.0-SNAPSHOTspring-cloud-build 4.1.0-SNAPSHOT 由于代码涉及snapshot库的代码拉取（体现Spring全家桶的协同），需要关注项目根目录下的.setting文件，作为一般本地maven文件的补充，主要关注仓库部分，构建的时候可以直接选定这个setting文件，消除全项目红波浪线的问题。
确认以上环境后
./mvnw clean package -Dmaven.test.skip=true 保持网络通畅，期间会需要连接docker，现在打包工具，确定JRE版本，下载JRE版本，打包到镜像仓库等动作。
spring-cloud-kubernetes下的示例 使用spring-cloud-kubernetes下的example体验springcloud与kubernetes的融合与互动
/spring-cloud-kubernetes/spring-cloud-kubernetes-examples/kubernetes-leader-election-example mvn spring-boot:build-image -Dspring-boot.build-image.imageName=org/kubernetes-leader-election-example :~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest a416a98b71e2 4 weeks ago 4.26MB registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver v1.24.1 e9f4b425f919 15 months ago 130MB registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler v1.24.1 18688a72645c 15 months ago 51MB registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy v1.24.1 beb86f5d8e6c 15 months ago 110MB registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7274b2dff5c25243e770f899792b57fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7518f7665db391fc44cc0c2cda5551/" rel="bookmark">
			微信浏览器不显示视频原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;video id="video" src="视频路径" width="100%" height="100%" autoplay controls muted loop poster="视频封面图片路径"&gt; &lt;/video&gt; 微信浏览器内核不支持自动播放视频 autoplay属性失效 使用了自动播放就不会显示视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e1526c8b533558274d9c76348b39f6c/" rel="bookmark">
			迁移Ubuntu报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
使用LxRunOffline-v3.5.0-mingw迁移Ubuntu至非系统盘时，出现如下报错
‘Couldn’t set the case sensitive attribute of the directory “\?\C:\Users\xxx\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState”.
Reason: Indicates that the directory trying to be deleted is not empt
解决方法：
更换LxRunOffline的版本为LxRunOffline-v3.5.0-11-gfdab71a-msvc，下载链接如下：
LxRunOffline-v3.5.0-11-gfdab71a-msvc
然后再进行迁移工作，发现迁移成功，使用命令查看迁移后的目录，发现Ubuntu20.04被迁移到D盘中
.\LxRunOffline.exe get-dir -n Ubuntu20.04LTS 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1d581f1f24933660eb76ff24504392/" rel="bookmark">
			element表格排序功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方展示 个人项目
可以分别对每一项数据进行筛选
注：筛选的数据不能是字符串类型必须是数字类型，否则筛选会乱排序
html &lt;el-table :data="tableData" border height="600" style="width: 100%"&gt; &lt;el-table-column prop="title" label="员工" align="center"&gt; &lt;/el-table-column&gt; &lt;el-table-column :label="tableData[0].day1" align="center"&gt; &lt;el-table-column prop="count1" sortable width="120" label="目标" align="center"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="ordercount1" sortable width="120" label="完成" align="center"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="orderrate1" sortable width="120" label="完成率" align="center"&gt; &lt;template #default="scope"&gt; {{ scope.row.orderrate1 + "%" }} &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;el-table-column :label="tableData[0].day2 + '至' + tableData[0].day1" align="center"&gt; &lt;el-table-column prop="count2" sortable width="120" label="目标" align="center"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="ordercount2" sortable width="120" label="完成" align="center"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f1d581f1f24933660eb76ff24504392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d1c1d8ba79243fad31be899dcd5129/" rel="bookmark">
			【toolschain】关于anaconda安装包时候 系统级全局安装还是安装在虚拟环境里的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于安装方式决定所被安装环境的问题 借机会研究了一下 关于处在anaconda虚拟环境下的 安装方式的不同 安装路径不同的问题，并总结如下原则：
conda 无法管理或者conda库查不到的，自然只能通过其他方式安装，那么路径就不在虚拟环境下 比如显卡驱动在conda环境下 但是不用conda安装 用yam apt-get src编译再install等也会是全局的为了使用隔离环境，常出现多版本的东西最好都使用conda安装，比如复现一个使用特定版本库的论文当在 Conda 环境中工作时，为了避免冲突和不一致，建议尽可能使用 Conda 环境中的软件包 （可以在编译或者运行时候手动指定路径或者使用的版本，具体方法请再自上网查）如果发现 Conda 环境中的软件包与系统级别的软件包存在冲突，可以考虑创建一个干净的新 Conda 环境，仅包含所需的软件包，以避免冲突pip 要注意 pip使用的是系统下pip还是conda下 可以通过 which来确认一下 如果全局和虚拟环境里有多版本 取决于环境变量配置的问题，也就类似与ros当前激活工作空间，默认选取bashrc中的最后一个。
但是gpt说正好相反：对于可执行文件（如命令行工具），通常优先使用在 PATH 环境变量中最先出现的版本。当你激活一个 Conda 环境时，Conda 会调整 PATH 使得环境内的路径优先于系统路径。
GPT问答环节 我与gpt问答扩展了一些场景和细节如下：
Q conda list 命令 显示全局的库的信息吗 A： 当你运行 conda list 命令时，它通常只显示在当前 Conda 环境中安装的软件包，不包括系统级别的安装。
如果想查看系统级别安装的软件包，你需要使用系统自身的包管理工具，例如，在 Ubuntu 上使用 apt list --installed，或者在 Python 中使用 pip list 来查看通过 pip 全局安装的包。
Q 总结一下 必须用conda命令安装，才是在conda环境下，否则即使处于conda某个环境下的安装也是系统全局可见的安装对吗 A 基本上是的，Conda 的环境隔离是由它的命令行工具和软件包管理系统来管理的。若要确保安装在特定的 Conda 环境中，最好使用 Conda 提供的命令安装软件包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8d1c1d8ba79243fad31be899dcd5129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f59b73de8bfb506c35733e8d4104f6f/" rel="bookmark">
			用轻量级ORM--Dapper调用MySQL存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文你的收获 写一个MySQL的分页存储过程学会使用Dapper去调用存储过程 在《用轻量级ORM–Dapper实现泛型仓储》中分享了轻量级ORM框架的基本使用，并实现了一个泛型仓储。本文继续分享用Dapper执行存储过程，区别于上文用的SQL Server数据库，本次我们用MySQL。闲话少絮，直接上案例。
一、场景描述 分页是系统中常用的功能，首先我们在MySQL中创建一个通用的分页存储过程，然后用Dapper去调用分页存储过程，实现用户列表的分页查询。
开发环境：
平台版本是：.NET6
开发框架：ASP.NET Core WebApi
开发工具：Visual Studio 2022
数据库版本：MySQL 5.7
二、在MySQL中创建存储过程 1.创建存储过程
写一个通用分页存储过程，可以进行任何单表的分页查询。
-- 0. 如果存在该存储过程，则删除 DROP PROCEDURE IF EXISTS p_pageList; -- 1. 创建存储过程 CREATE PROCEDURE p_pageList ( IN _pageIndex INT, -- 页码 IN是输入参数 IN _pageSize INT, -- 页的容量 IN _tableName varchar(30), -- 表的名字 IN _condition varchar(500), -- 查询条件 OUT _totalCount INT -- 总条数 OUT是输出参数 ) BEGIN -- 用Declare关键词 定义一个局部变量 DECLARE skip int; -- 给skip赋值, 跳过的条数 set skip = (_pageIndex-1)*_pageSize; -- mysql的分页怎么写，用什么关键字？？ -- SELECT SQL_CALC_FOUND_ROWS * FROM users where xxxx='' LIMIT skip ,_pageSize; -- 用Concat函数，拼接SQL语句，存入全局变量@sqlStr set @sqlStr = CONCAT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f59b73de8bfb506c35733e8d4104f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991fe3f3085114448394376668340011/" rel="bookmark">
			docker入门概念详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章对docker的一些基础概念和周边概念进行了详细解释。帮助你可以很好的理解docker是用来干什么的，docker是怎么工作的。其中有docker所运用到的技术解释，docker的不同发展版本，dokcer的架构，docker的生态等等详解。希望本片文章会对你有所帮助。
文章目录
一、虚拟化与容器化
1、1 什么是虚拟化、容器化
1、2 为什么要虚拟化、容器化？
二、虚拟化实现方式
2、1 虚拟化常见类别
2、2 常见虚拟化实现
2、2、1 主机虚拟化(虚拟机)实现
2、2、2 容器虚拟化实现
2、2、3 容器虚拟化基础之 NameSpace
2、2、4 容器虚拟化基础之 cgroups。
2、2、5 容器虚拟化基础之 LXC
2、3 Docker 是什么
2、3、1 Docker的本质
2、3、2 Docker 的引擎迭代
2、3、3 Docker 和虚拟机的区别
2、3、4 Docker 为什么比虚拟机资源利用率高，启动快
三、docker的版本
四、docker架构
五、docker的生态
🙋‍♂️ 作者：@Ggggggtm 🙋‍♂️
👀 专栏：Docker 👀
💥 标题：docker入门概念详解 💥
❣️ 寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景 ❣️
一、虚拟化与容器化 1、1 什么是虚拟化、容器化 物理机：实际的服务器或者计算机。相对于虚拟机而言的对实体计算机的称呼。物理机提供给虚拟机以硬件环境，有时也称为“寄主”或“宿主”。 虚拟化：是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 容器化：容器化是一种虚拟化技术，又称操作系统层虚拟化（Operating system level virtualization），这种技术将操作系统内核虚拟化，可以允许用户空间软件实例（instances）被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运 行。这个软件实例，也被称为是一个容器（containers）。对每个实例的拥有者与用户 来说，他们使用的服务器程序，看起来就像是自己专用的。容器技术是虚拟化的一种。 docker 是现今容器技术的事实标准。 1、2 为什么要虚拟化、容器化？ 虚拟化和容器化的最主要目的就是资源隔离，随着资源隔离的实现逐渐也带来了更大的收益。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991fe3f3085114448394376668340011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b923627880f0e4e2b2ee82d909fad66/" rel="bookmark">
			数组排序方法——sort()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.数组里面的字符串排序
1.降序 2.升序
1.数组里面的对象排序 1.降序 2.升序
1.数组里面的字符串排序 1.降序 let arr = [1,2,3,4,5] arr.sort((a, b) =&gt; { return b - a }) // 会改变原数组 [5,4,3,2,1] 2.升序 let arr = [5, 4, 3, 2, 1] arr.sort((a, b) =&gt; { return a - b }) // 会改变原数组[1, 2, 3, 4, 5] 1.数组里面的对象排序 1.降序 let arr = [{ num: 1 }, { num: 2 }, { num: 3 }, { num: 4 }, { num: 5 }]; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b923627880f0e4e2b2ee82d909fad66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766a012b4837d1d6264e4845e4223731/" rel="bookmark">
			如何有效使用 .gitignore 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在任何使用 Git 的软件项目中，.gitignore 文件都是一个必不可少的工具。它帮助开发者定义哪些文件和目录应该被 Git 忽略，从而保持代码库的整洁和管理的简便性。
什么是 .gitignore？
.gitignore 文件是一个文本文件，您可以在其中指定 Git 应该忽略的文件和目录模式。这通常包括编译生成的文件、本地配置文件和其他不需要或不应该包含在源代码管理中的文件。
基本用法
创建 .gitignore 文件很简单。您只需在项目的根目录下创建一个名为 .gitignore 的文件，然后在其中添加规则。
示例规则：
忽略所有 .log 文件 *.log 忽略特定目录 bin/ temp/ 忽略除此规则外的所有文件（例外规则） !README.md
最佳实践
将 .gitignore 放在仓库根目录：这确保了它的规则对整个项目有效。
为不同类型的文件制定规则：通常，您应该忽略编译生成的文件（如 .class 或 .o 文件）、包文件（如 .jar 或 .exe 文件）和临时文件（如 .log 或 .tmp 文件）。
使用注释说明规则：在 .gitignore 文件中使用 # 开头添加注释，解释为什么某个文件或模式被忽略，有助于团队成员理解这些规则。
使用全局 .gitignore：对于所有项目通用的忽略规则（如操作系统生成的文件），可以在您的 Git 配置中设置一个全局 .gitignore 文件。
避免忽略重要文件：务必确认您的 .gitignore 规则不会意外忽略掉重要的源代码或文档。
常见问题及解决方案
更新 .gitignore 后文件仍被跟踪：
如果文件已经被添加到仓库中，您需要先手动从 Git 中移除它们的跟踪状态：
git rm --cached &lt;file&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766a012b4837d1d6264e4845e4223731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283a645dc20a98170bad460d762de76d/" rel="bookmark">
			RK3568 解决MIPI屏幕开机只显示uboot logo的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 之前写过一篇文章介绍了RK3568驱动MIPI屏幕的方法，这次产品迭代，硬件改版，选型的新的屏幕了。所以再次开启调试屏幕的过程。本以为会和上次一样会轻车熟路，事情总是事与愿违，同样的路，遇到新的坑。
2、配置屏幕 适配MIPI屏幕只需要修改一下屏幕的相关的参数，主要是屏幕时序参数，初始化序列这些。整个设备树的配置如下：
&amp;dsi0 { status = "okay"; //rockchip,lane-rate = &lt;1000&gt;; dsi0_panel: panel@0 { status = "okay"; compatible = "simple-panel-dsi"; reg = &lt;0&gt;; backlight = &lt;&amp;backlight_0&gt;; power-supply = &lt;&amp;vcc1v8_lcd0_power&gt;; //enable-gpios = &lt;&amp;gpio0 RK_PC6 GPIO_ACTIVE_HIGH&gt;; reset-gpios = &lt;&amp;gpio4 RK_PA1 GPIO_ACTIVE_LOW&gt;; enable-delay-ms = &lt;35&gt;; prepare-delay-ms = &lt;20&gt;; reset-delay-ms = &lt;20&gt;; init-delay-ms = &lt;120&gt;; unprepare-delay-ms = &lt;0&gt;; disable-delay-ms = &lt;20&gt;; mipi-data-delay-ms = &lt;100&gt;; /*屏幕的宽度,高度，单位mm*/ size,width = &lt;152&gt;; size,height = &lt;244&gt;; dsi,flags = &lt;(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)&gt;; dsi,format = &lt;MIPI_DSI_FMT_RGB888&gt;; dsi,lanes = &lt;4&gt;; /*上海琪翰HQ10-21440B1-C 10寸屏 驱动芯片ILI9881C 寄存器初始操作, 0x15命令类型，单字节数据, 第2个字节为延时, 第3个字节为数据长度，第4,5个字节为数据表示寄存器地址和写入的数据 */ panel-init-sequence = [ 39 00 04 FF 98 81 03 /*GPI_1*/ 15 00 02 01 00 15 00 02 02 00 15 00 02 03 53 15 00 02 04 D3 15 00 02 05 00 15 00 02 06 0D 15 00 02 07 08 15 00 02 08 00 15 00 02 09 00 15 00 02 0a 00 15 00 02 0b 00 15 00 02 0c 00 15 00 02 0d 00 15 00 02 0e 00 15 00 02 0f 28 15 00 02 10 28 15 00 02 11 00 15 00 02 12 00 15 00 02 13 00 15 00 02 14 00 15 00 02 15 00 15 00 02 16 00 15 00 02 17 00 15 00 02 18 00 15 00 02 19 00 15 00 02 1a 00 15 00 02 1b 00 15 00 02 1c 00 15 00 02 1d 00 15 00 02 1e 40 15 00 02 1f 80 15 00 02 20 06 15 00 02 21 01 15 00 02 22 00 15 00 02 23 00 15 00 02 24 00 15 00 02 25 00 15 00 02 26 00 15 00 02 27 00 15 00 02 28 33 15 00 02 29 33 15 00 02 2a 00 15 00 02 2b 00 15 00 02 2c 00 15 00 02 2d 00 15 00 02 2e 00 15 00 02 2f 00 15 00 02 30 00 15 00 02 31 00 15 00 02 32 00 15 00 02 33 00 15 00 02 34 03 15 00 02 35 00 15 00 02 36 00 15 00 02 37 00 15 00 02 38 96 15 00 02 39 00 15 00 02 3a 00 15 00 02 3b 00 15 00 02 3c 00 15 00 02 3d 00 15 00 02 3e 00 15 00 02 3f 00 15 00 02 40 00 15 00 02 41 00 15 00 02 42 00 15 00 02 43 00 15 00 02 44 00 /*GIP_2*/ 15 00 02 50 00 15 00 02 51 23 15 00 02 52 45 15 00 02 53 67 15 00 02 54 89 15 00 02 55 AB 15 00 02 56 01 15 00 02 57 23 15 00 02 58 45 15 00 02 59 67 15 00 02 5a 89 15 00 02 5b AB 15 00 02 5c CD 15 00 02 5d EF /*GIP_3*/ 15 00 02 5e 00 15 00 02 5f 08 15 00 02 60 08 15 00 02 61 06 15 00 02 62 06 15 00 02 63 01 15 00 02 64 01 15 00 02 65 00 15 00 02 66 00 15 00 02 67 02 15 00 02 68 15 15 00 02 69 15 15 00 02 6a 14 15 00 02 6b 14 15 00 02 6c 0D 15 00 02 6d 0D 15 00 02 6e 0C 15 00 02 6f 0C 15 00 02 70 0F 15 00 02 71 0F 15 00 02 72 0E 15 00 02 73 0E 15 00 02 74 02 15 00 02 75 08 15 00 02 76 08 15 00 02 77 06 15 00 02 78 06 15 00 02 79 01 15 00 02 7a 01 15 00 02 7b 00 15 00 02 7c 00 15 00 02 7d 02 15 00 02 7e 15 15 00 02 7f 15 15 00 02 80 14 15 00 02 81 14 15 00 02 82 0D 15 00 02 83 0D 15 00 02 84 0C 15 00 02 85 0C 15 00 02 86 0F 15 00 02 87 0F 15 00 02 88 0E 15 00 02 89 0E 15 00 02 8A 02 /*CMD_Page 4*/ 39 00 04 FF 98 81 04 15 00 02 6E 2B 15 00 02 6F 37 15 00 02 3A A4 15 00 02 8D 1A 15 00 02 87 BA 15 00 02 B2 D1 15 00 02 88 0B 15 00 02 38 01 15 00 02 39 00 15 00 02 B5 07 15 00 02 31 75 15 00 02 3B 98 /*CMD_Page 1*/ 39 00 04 FF 98 81 01 15 00 02 22 0A 15 00 02 31 00 15 00 02 53 40 15 00 02 55 40 15 00 02 50 99 15 00 02 51 94 15 00 02 60 10 15 00 02 62 20 /*Gamma start*/ 15 00 02 A0 00 15 00 02 A1 00 15 00 02 A2 15 15 00 02 A3 14 15 00 02 A4 1B 15 00 02 A5 2F 15 00 02 A6 25 15 00 02 A7 24 15 00 02 A8 80 15 00 02 A9 1F 15 00 02 AA 2C 15 00 02 AB 6C 15 00 02 AC 16 15 00 02 AD 14 15 00 02 AE 4D 15 00 02 AF 20 15 00 02 B0 29 15 00 02 B1 4F 15 00 02 B2 5F 15 00 02 B3 23 /*Neg Register*/ 15 00 02 C0 00 15 00 02 C1 2E 15 00 02 C2 3B 15 00 02 C3 15 15 00 02 C4 16 15 00 02 C5 28 15 00 02 C6 1A 15 00 02 C7 1C 15 00 02 C8 A7 15 00 02 C9 1B 15 00 02 CA 28 15 00 02 CB 92 15 00 02 CC 1F 15 00 02 CD 1C 15 00 02 CE 4B 15 00 02 CF 1F 15 00 02 D0 28 15 00 02 D1 4E 15 00 02 D2 5C 15 00 02 D3 23 /*Gamma End*/ 39 00 04 FF 98 81 00 05 C8 01 11 05 14 01 29	]; disp_timings0: display-timings { native-mode = &lt;&amp;dsi0_timing0&gt;; dsi0_timing0: timing0 { clock-frequency = &lt;70000000&gt;;//时钟频率(hactive+ hsync-len + hfront-porch + hback-porch)*(vactive + vsync-len + vfront-porch + vback-porch) * Frame rate60Hz = 70060800 hactive = &lt;800&gt;; //水平像素点数 vactive = &lt;1280&gt;; //垂直像素点数 hsync-len = &lt;10&gt;; //水平同步信号宽度HSYNC/thp hback-porch = &lt;40&gt;; //水平同步后肩 hfront-porch = &lt;40&gt;;//水平同步前肩 vsync-len = &lt;2&gt;; //垂直同步信号宽度VSYNC/tvp vback-porch = &lt;20&gt;; //垂直同步后肩 vfront-porch = &lt;10&gt;;//垂直同步前肩 hsync-active = &lt;0&gt;; //hsync激活有效电平为低电平 vsync-active = &lt;0&gt;; //vsync激活有效电平为低电平 de-active = &lt;1&gt;; //de激活有效电平为高电平 pixelclk-active = &lt;0&gt;; //pixelclk激活有效电平为低电平 }; }; ports { #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; port@0 { reg = &lt;0&gt;; panel_in_dsi0: endpoint { remote-endpoint = &lt;&amp;dsi0_out_panel&gt;; }; }; }; }; ports { #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; port@1 { reg = &lt;1&gt;; dsi0_out_panel: endpoint { remote-endpoint = &lt;&amp;panel_in_dsi0&gt;; }; }; }; }; 设备树配置好，检查好硬件屏幕的接口电路全部正确后，测试屏幕可以正常显示并进入系统桌面。看来还是顺利的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/283a645dc20a98170bad460d762de76d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec6707c48b771f7f39c0d214beb8a8a/" rel="bookmark">
			SpringCloud实战之Feign 2.x 迁移到 4.x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从官方文档中去发现变化的点：
官方关于Okhttp from 3.x to 4.x
官方关于Spring-cloud+feign from 2.2.x
官方关于Spring-cloud+feign from 4.1.x
spring-cloud-openfeign 变化对比 如何引入feign?如何加载feign?如何申明一个client？关于load-balancer关于资源加载关于启动默认的httpclient和okhttp的配置关于 SpringEncoder 配置关于熔断的配置关于请求/响应的压缩关于SpringData的支持 其他 4.1.x的新特性SpringBoot + SpringCloud + Feign + Okhttp 实践示例 spring-cloud-openfeign 变化对比 如何引入feign? &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 如何加载feign? 通过注解：@EnableFeignClients，开始feign的注入
如何申明一个client？ @FeignClient("stores") public interface StoreClient { @RequestMapping(method = RequestMethod.GET, value = "/stores") List&lt;Store&gt; getStores(); @RequestMapping(method = RequestMethod.GET, value = "/stores") Page&lt;Store&gt; getStores(Pageable pageable); @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json") Store update(@PathVariable("storeId") Long storeId, Store store); @RequestMapping(method = RequestMethod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec6707c48b771f7f39c0d214beb8a8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e044bf774ccf6821173564b3f6b94f1/" rel="bookmark">
			使用 JWT（JSON Web 令牌）实现登录身份验证和令牌续订
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文档链接
文档链接, PDF中包含一部分宣传大字制作不易还望多多支持互相交流
使用 JWT（JSON Web 令牌）实现登录身份验证和令牌续订。它将 JWT 与基于会话的身份验证进行了比较，并强调了每种方法的差异、优点和缺点。本文档介绍了基于会话的方法和基于 JWT 的方法的身份验证过程。它还讨论了与 JWT 相关的安全性、性能和过期问题。该文档最后建议使用 JWT 进行身份验证，尤其是在分布式环境中。它提供了用于生成和解析 JWT 令牌的代码示例，以及使用 Redis 实现令牌存储。该文档还包括用于登录、注销和密码更新功能的代码片段。
大意：
基于会话的身份验证和基于 JWT 的身份验证之间的比较基于会话和基于 JWT 的方法的身份验证过程智威汤逊的优缺点JWT 的安全问题JWT 的性能注意事项JWT 的代币续订策略使用 JWT 进行身份验证的建议用于生成和解析 JWT 令牌的代码示例使用 Redis 实现令牌存储用于登录、注销和密码更新功能的代码片段 SessionJWT存储位置服务器端客户端存储方式内存/数据库Local Storage/Cookie有效期服务器端控制Token中包含过期时间扩展性需要额外实现多机数据共享无需额外实现多机数据共享安全性需要保护Session ID使用签名保护Token性能需要在服务器端存储和检索Session无需在服务器端存储和检索Token废弃可以主动废弃Session无法主动废弃Token，需要等待过期续签需要刷新Session的过期时间需要签发新的Token一次性每次请求都要做Session的加密解密每次请求都返回新的Token分布式环境需要额外实现多机数据共享无需额外实现多机数据共享 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c7c5788d7fe7b9af730651cabe65e2/" rel="bookmark">
			Flutter异常捕获runZoned
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter异常捕获
Dart中可以通过try/catch/finally来捕获代码块异常，这个和其它变成语言类似，，如果读者不清楚，可以查看Dart语言文档，不在赘述，下面我们看看Flutter中的异常捕获。
Flutter框架异常捕获
Flutter 框架为我们在很多关键的方法进行了异常捕获。这里举一个例子，当我们布局发生越界或不和规范时，Flutter就会自动弹出一个错误界面，这是因为Flutter已经在执行build方法时添加了异常捕获，最终的源码如下：
@override void performRebuild() { ... try { //执行build方法 built = build(); } catch (e, stack) { // 有异常时则弹出错误提示 built = ErrorWidget.builder(_debugReportException('building $this', e, stack)); } ... } 可以看到，在发生异常时，Flutter默认的处理方式时弹一个ErrorWidget，但如果我们想自己捕获异常并上报到报警平台的话应该怎么做？我们进入_debugReportException()方法看看：
FlutterErrorDetails _debugReportException( String context, dynamic exception, StackTrace stack, { InformationCollector informationCollector }) { //构建错误详情对象 final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: 'widgets library', context: context, informationCollector: informationCollector, ); //报告错误 FlutterError.reportError(details); return details; } 我们发现，错误是通过FlutterError.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c7c5788d7fe7b9af730651cabe65e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2cffde226a0076d7898d0ae9106380/" rel="bookmark">
			LeetCode 2706. 购买两块巧克力：一次遍历（O(n) &#43; O(1)）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】2706.购买两块巧克力：一次遍历（O(n) + O(1)） 力扣题目链接：https://leetcode.cn/problems/buy-two-chocolates/
给你一个整数数组 prices ，它表示一个商店里若干巧克力的价格。同时给你一个整数 money ，表示你一开始拥有的钱数。
你必须购买 恰好 两块巧克力，而且剩余的钱数必须是 非负数 。同时你想最小化购买两块巧克力的总花费。
请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 money 。注意剩余钱数必须是非负数。
示例 1：
输入：prices = [1,2,2], money = 3 输出：0 解释：分别购买价格为 1 和 2 的巧克力。你剩下 3 - 3 = 0 块钱。所以我们返回 0 。 示例 2：
输入：prices = [3,2,3], money = 3 输出：3 解释：购买任意 2 块巧克力都会超过你拥有的钱数，所以我们返回 3 。 提示：
2 &lt;= prices.length &lt;= 501 &lt;= prices[i] &lt;= 1001 &lt;= money &lt;= 100 方法一：一次遍历 使用两个变量 m 1 m1 m1和 m 2 m2 m2来维护“最便宜的两块巧克力的价格”，并且保证，在每次操作结束后满足 m 1 ≤ m 2 m1\leq m2 m1≤m2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2cffde226a0076d7898d0ae9106380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f00553212046f0ac1a8be528b221fc/" rel="bookmark">
			flutter绘制流程——rebuild
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rebuild是Element的方法，有两种场景下会被调用:
element第一次构建mount的时候widget发生变化的时候 void rebuild() { if (_lifecycleState != _ElementLifecycle.active || !_dirty) return; performRebuild(); } 主要逻辑分为2步
判断状态是否是active，_dirty是否为true执行performRebuild()，这是个抽象方法，所以具体rebuild的逻辑由element子类去实现 下面重点来看performRebuild()
performRebuild.png
1 performRebuild() 顾名思义真正执行重新build的地方，因此每个实现类会有所不同，下面看下不同类型Element的实现
1.1 RenderObjectElement 更新renderObject，当然还有一些RenderObjectElement的继承类可能还做了其他逻辑
@override void performRebuild() { widget.updateRenderObject(this, renderObject); _dirty = false; } 1.1.1 SliverMultiBoxAdaptorElement 对于SliverGrid，SliverList，ListView都会用到它，这里逻辑比较多，今天这篇不去细讲，大概了解有关键逻辑 _build(index)和updateChild`，
@override void performRebuild() { super.performRebuild(); final SplayTreeMap&lt;int, Element?&gt; newChildren = SplayTreeMap&lt;int, Element?&gt;(); void processElement(int index) { //省略... final Element? newChild = updateChild(newChildren[index], _build(index), index); //省略... } //省略... newChildren.keys.forEach(processElement); //省略... } 1.2 ComponentElement void performRebuild() { Widget?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f00553212046f0ac1a8be528b221fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1943409308dbb26f57e2ab2d18bb34/" rel="bookmark">
			某后台管理系统加密参数逆向分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们日常的渗透中经常会遇到开局一个登录框的情况，弱口令爆破当然是我们的首选。但是有的网站会对账号密码等登录信息进行加密处理，这一步不由得阻碍了很多人的脚步。前端的加解密是比较常见的，无论是 web 后台还是小程序，都常常存在加解密传输，签名防篡改等机制，会使很多渗透人员没有办法直接对参数的值进行更改，大大增加了攻击者的攻击成本。本文将一个带验证码的后台实站案例与大家分享。
正文 发包逻辑分析： 开局一个登录框，随便输入一段账号密码跟验证码进行抓包
提交错误的验证码跟账号密码弹出了验证码错误！的提示，说明这个数据包就是校验账号密码跟验证码的数据包
查看一下参数，账号，验证码都是明文，密码被加密了
搜索参数关键词password，可以看到一个带有login的js文件，双击进入文件。
在文件内部总共有10个password关键词，全部打上断点发包校验。
断点在196行断了下来，t.param.password是明文。经过Object(i["a"])函数运行之后就成了加密密文。证明Object(i["a"])便是加密函数！后续便是把所有需要拿去爆破的明文加密成密文便可绕过前端加密直接进行暴力破解。
扣加密函数： 进入到加密函数内部查看
可以看到函数内部有个s函数，将断点下到156行，查看传进来的t是什么值，以及经过s函数运行之后的返回值又是什么呢。
t是传进来的明文，返回值是加密之后的值。
观察一下代码，可以看到"93a9"和 "7d92"，把代码拉到第一行，这个站点用的webpack打包技术。
那么webpack又是什么呢？
WebPack打包 webpack是一个基于模块化的打包（构建）工具, 它把一切都视作模块
概念：
webpack是 JavaScript 应用程序的模块打包器,可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。所有的资源都是通过JavaScript渲染出来的。
如果一个页面大部分是script标签构成，80%以上是webpack打包。
1. webpack打包简介
image20220329153518062
多个JS文件打包：
如果模块比较多，就会将模块打包成JS文件, 然后定义一个全局变量 window["webpackJsonp"] = [ ]，它的作用是存储需要动态导入的模块，然后重写 window["webpackJsonp"] 数组的 push( ) 方法为 webpackJsonpCallback( ),也就是说 window["webpackJsonp"].push( ) 其实执行的是 webpackJsonpCallback( ),window["webpackJsonp"].push( )接收三个参数,第一个参数是模块的ID,第二个参数是 一个数组或者对象,里面定义大量的函数,第三个参数是要调用的函数(可选)
寻找加载器 加载器一般是使用call或者apply方法
call() 方法会立即执行这个函数，接受一个多个参数，参数之间用逗号隔开；
apply()方法会立即执行这个函数，接受一个包含多个参数的数组；
我们找类似i("1ff3")这种的字眼，然后打断点，刷新页面进断点，一般就可以找到加载器了
断点断下来之后直接进入加载器函数
可以看到d函数里面明显的使用了call函数。
直接全扣整段webpack代码。
定义全局变量调用模块，运行代码
var 君主; 报错windows未定义。直接补上window对象。
var window={}; 在导出的模块里面没有寻找到我们需要的“7d92”模块
复制donate~login.06871226.js文件到ide折叠，将其7d92模块复制到我们有加载器的模块数组里面。
调用7d92模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1943409308dbb26f57e2ab2d18bb34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8081533c0e8a25287b9ed4f55e68caa1/" rel="bookmark">
			Oracle研学-对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学自B站黑马程序员
1.视图 (物化视图序列同义词oracle特有） 1.对一个SQL语句的封装，一个虚拟的表。-简化开发 视图是一种数据库对象，是从一个或者多个数据表或视图中导出的虚表，视图所对应的数据并不真正地存储在视图中，而是存储在所引用的数据表中，视图的结构和数据是对数据表进行查询的结果。视图和表的使用是相同的可以select
使用视图的优点：
简化数据操作：视图可以简化用户处理数据的方式。
着重于特定数据：不必要的数据或敏感数据可以不出现在视图中。
视图提供了一个简单有效的安全机制，可以定制不同用户对数据的访问权限。
提供向后兼容性：视图使用户能够在表的架构更改时为表创建向后兼容接口。
2.创建或修改视图语法 //基本subquery是查询语句 CREATE VIEW view_name AS subquery //[]可选 CREATE [OR REPLACE] [FORCE] VIEW view_name AS subquery [WITH CHECK OPTION ] [WITH READ ONLY] OR REPLACE ：若所创建的试图已经存在，ORACLE自动重建该视图(替换)； FORCE ：不管基表是否存在 ORACLE 都会自动创建该视图； subquery ：一条完整的 SELECT 语句，可以在该语句中定义别名； WITH CHECK OPTION ：插入或修改的数据行必须满足视图定义的约束； WITH READ ONLY ：该视图上不能进行任何 DML 操作。(加上后变为只读) //删除视图 DROP VIEW view_name 3.简单视图 //视图可以在views文件夹中找到,视图是虚拟表，修改视图数据相当于修改表数据，改表的数据则视图也跟着变，视图在数据库中只占一条sql语句的大小，视图的表也叫做基表 //创建视图：业主类型为1 的业主信息 create or replace view view_owners1 as select * from T_OWNERS where ownertypeid=1 //通过视图修改数据 update view_owners1 set name='周也' where id=4 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8081533c0e8a25287b9ed4f55e68caa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a375b6477660834ce3edefd7c6c1e532/" rel="bookmark">
			C/C&#43;&#43;转WebAssembly及微信小程序调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章讲了C/C++如何转WebAssembly，并测试了在Web端调用。本篇内容和上篇一样，介绍C/C++包转的.wasm包如何在小程序中调用。
说明 本篇是在上一篇步骤1-4的基础上，再做修改，供微信小程序端调用的方法和步骤。
本篇操作手册可以参考如下文档：
https://www.cijiyun.com/newsview?id=64139https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm 前情提要 通过上篇文章我们知道，将编写好的C/C++代码打包成.wasm，会同时生成.html、.js文件（具体方法参考 C/C++转WebAssembly流程及Web端调用测试 这一篇中的步骤 1-4）。文件如下：
对于微信小程序，直接编译打包后的包无法直接调用，所以还需要进行一些代码修改。
注意：此处修改web_assembly_test.js文件，是在上一篇修改之后的基础上再做修改，所以，需要先对上一篇文章有所了解。
具体步骤如下：
第一步：新建文件及目录 在小程序文件夹中新建文件目录，包括：
pages/worker目录：用于进行打包文件的调用workers目录：与pages平齐，创建workers目录，用于存放.wasm文件 目录结构如下：
说明：
workers目录中，只需要存放web_assembly_test.wasm即可，其它文件可以不需要。这样做的目的是：为了把.wasm打包进去，并且还可以分包打包在调用.wasm包的page中（pages/worker目录），只需要.js即可，这个文件包含了一些调用.wasm文件的方法。参考文档：https://www.cijiyun.com/newsview?id=64139 第二步：修改web_assembly_test.js文件 在web_assembly_test.js文件的最底部添加 module.exports = { Module: Module } 如下：
注释scriptDirectory = self.location.href代码 // scriptDirectory = self.location.href 修改instantiateArrayBuffer函数 将该方法修改为如下：
function instantiateArrayBuffer(binaryFile, imports, receiver) { return WXWebAssembly.instantiate('/workers/web_assembly_test.wasm', imports) .then(function(instance) { return instance; }) .then(receiver, function(reason) { err('failed to asynchronously prepare wasm: ' + reason); // Warn on some common problems. if (isFileURI(wasmBinaryFile)) { err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a375b6477660834ce3edefd7c6c1e532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5356a63bd2d5cb33c325b0502b338f12/" rel="bookmark">
			JavaScript系列——正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 需求场景正则表达式的定义创建正则表达式通过 / 表示式/ 创建通过构造函数创建 编写一个正则表达式的模式使用简单模式使用特殊字符常用特殊字符列表特殊字符组和范围 正则表达式使用代码演示 常用示例验证手机号码合法性 小结 需求场景 在前端开发领域，在日常的开发任务中，你是否遇到以下的需求：
例如：
前端表单校验手机号码是否符合规则？用户提交表单中的身份证件号是否符合大陆居民身份证规则？如何提取字符串中出现的数字？…等等等 上述类似的需求我们在日常开发中，会遇到很多，JavaScript 为我们提供了一套解决方案，就是正则表达式，我们可以提取需要识别的目标的轮廓，用其构造一个正则表达式对象，通过方法来提取目标对象或者判断是否符合某些规则，下面就来具体说明正则表达式。
正则表达式的定义 正则表达式是用于匹配字符串中的字符组合的模式。它是一个对象，这个对象可以被用于 RegExp(正则表达式）的exec/test和字符串的 match/matchAll/replace/search/split 方法。
创建正则表达式 我们可以使用以下两种方法构建一个正则表达式：
通过 / 表示式/ 创建 var re = /ab+c/; 通过构造函数创建 var re = new RegExp("ab+c"); 当JavaScript语句加载后，正则表达式字面量就会被编译，当其保持不变时，使用字面量创建方法，可以提高性能。
编写一个正则表达式的模式 一个正则表达式模式是由字符串构成的，这些字符串可以是数字、字母、特殊符号的组合。
使用简单模式 简单模式直接使用目标字符串构成，比如/abc/ 就是要找到出现abc的字符串，如果abc中间出现空格，那么这种简单的模式，就不能匹配，无法满足我们的需求，就需要用到下面带有特殊字符的模式，这些特殊的字符在正则表示式中，有特别的含义
使用特殊字符 当我们需要匹配一个不太确定的字符串时，比如寻找一个或多个“a” ，或者寻找空格，可以在模式中使用特殊字符，比如使用/ab*c/去匹配单独的“a”后面跟了零个或多个“b”，同时后面跟着“c”的字符串，特殊字符*的含义是，前一项的字符出现零次或者多次。
常用特殊字符列表 下面的页面与表格列出了一个正则表达式中可以利用的特殊字符的完整列表和描述。
特殊字符 字符含义\（1）在非特殊字符之前的反斜杠表示下一个字符就是特殊字符，此字符不能按照字面理解，面。例如前面没有 “” 的 “b” 通常匹配小写字母 “b”，但如果前面出现\，它则不会匹配任何字符，在特殊字符之前的反斜杠表示下一个字符不是特殊字符，能够转义^表示匹配以下一个字符开始的字符串，例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。$表示匹配以上一个字符结尾的字符串，例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。*匹配一个表达式0次货多次，等价于{0，}，例如，/bo*/ 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。+匹配前面表达式1次或者多次，等价于{1，}，例如，/a+/ 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5356a63bd2d5cb33c325b0502b338f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e2c947255b8e3ea81fadb0487ac301/" rel="bookmark">
			flutter 之proto
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和嵌入式用proto协议来通信，以mac来演示
先在电脑上安装protobuf（在博主文章内容里面搜Mac安装protobuf），然后在桌面上放这几个文件，且build_proto_dart.sh文件内容如图所示
#!/bin/bash SCRIPT=$(readlink -f "$0") SCRIPTPATH=$(dirname "$SCRIPT") cd $SCRIPTPATH protoc --dart_out=test *.proto --plugin=protoc-gen-dart=$HOME/.pub-cache/bin/protoc-gen-dart cd test mv *.pb*.dart ../test2/ 然后将你要转译的proto文件放在桌面上，然后在控制台输入sh build_proto_dart.sh，然后会在test2里面出现你想要的proto文件。build_proto_dart.sh文件内容博主自己需求写的，大家也可以按自己需求更改.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/123e28e37d39186c8640b301dc0e409f/" rel="bookmark">
			C#中的集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、集合的概念 数组可以保存多个对象，但在某些情况下无法确定到底需要保存多少个对象，由于数组的长度不可变，因此数组将不再适用。
如何保存数目不确定的对象呢？
为了保存这些数目不确定的对象，C#中提供了一系列特殊的类，这些类可以存储任意类型的对象，并且长度可变，统称为集合。
集合分类：
可分为非泛型集合和泛型集合，二者均间接实现了IEnumerable接口。
（1）非泛型集合
非泛型集合位于System.Collections命名空间，它可以存储多种类型的对象，其中最常用的是ArrayList集合和Hashtable集合。
（2）泛型集合
泛型集合位于System.Collections.Generic命名空间，它只能存储同一种类型的对象，其中最常用的是List &lt; T &gt; 泛型集合和 Dictionary&lt;TKey,TValue&gt; 泛型集合。
二、非泛型集合类ArrayList ArrayList可以容纳不同类型的对象
这些对象包括int、string、object等类型的对象
同时也提供一系列添加、删除、修改和查询元素等操作方法
int Add(object value)	|将元素添加到ArrayList集合，并且该元素可以是null，且允许重复值，返回值为所插入位置的索引值 void AddRange(ICollection c)	|将集合或者数组添加到ArrayList集合 void Clear()	|从ArrayList中移除所有元素 bool Contains(object item)	|判断某元素是否在ArrayList中 int IndexOf(object value)	|查找指定元素，并返回该元素在ArrayList中第一个匹配项的索引 void Insert(int index,object value)	|将元素插入ArrayList的指定索引处 int LastIndexOf(object value)	|查找指定元素，并返回该元素在ArrayList中最后一个匹配项的索引 void Remove(object obj)	|从ArrayList中移除指定元素的第一个匹配项 void RemoveAt(int index)|从ArrayList中移除指定索引处的元素 void Reverse()	|将整个ArrayList中元素的顺序反转 void Sort()	|对整个ArrayList中的元素进行排序，由小到大 //创建ArrayList集合对象arr ArrayList arr = new ArrayList(); //使用不同方法向集合添加多个元素 arr.Add(222); arr1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/123e28e37d39186c8640b301dc0e409f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbc3c316ddb4deec9536dc6cac3ab93/" rel="bookmark">
			代码随想录算法训练营Day14|二叉树理论基础及其递归遍历和迭代遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二叉树理论基础
二叉树的种类
满二叉树
完全二叉树
二叉搜索树
平衡二叉搜索树
二叉树的存储方式
二叉树的遍历方式
二叉树的定义
二叉树的递归遍历
前序遍历（递归实现）
中序遍历（递归实现）
后序遍历（递归实现）
二叉树的迭代遍历
前序遍历（迭代法）
后序遍历（迭代法）
中序遍历（迭代法）
二叉树统一迭代法
中序遍历（标记法）
前序遍历（标记法）
后序遍历（标记法）
总结
二叉树理论基础 二叉树的种类 二叉树可分为满二叉树和完全二叉树，二叉搜索树和平衡二叉搜索树等。
满二叉树 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。若满二叉树的深度为k，则有2^k-1个节点。
完全二叉树 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置（从左到右节点连续）。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
满二叉树是完全二叉树的一种特殊情况，堆也是一棵完全二叉树，同时保证父子节点的顺序关系。
二叉搜索树 前面两种树都是没有数值的，而二叉搜索树是有数值的，二叉搜索树是一个有序树。它具有以下特点：
若左子树不为空，则左子树上的所有节点值均小于根节点（中间节点）的值；若右子树不为空，则右子树上的所有节点值均大于根节点（中间节点）的值；它的左右字数也分别为二叉排序树，即满足以上两条。 平衡二叉搜索树 在二叉搜索树的基础上加上左右两个字数的高度差绝对值不超过1的条件。
C++中map、set|、multimap、multiset的底层实现都是平衡二叉搜索树，map、set的增删时间复杂度都是logn（unordered_map，unordered_set底层实现是哈希表）。
二叉树的存储方式 二叉树可以链式存储，也可以顺序存储。
链式存储用指针，顺序存储用数组。用数组来存储二叉树时，若父节点的下标是i，则他的左孩子是i * 2 + 1，右孩子就是i * 2 + 2。但是一般用链式表示二叉树更方便。
二叉树的遍历方式 二叉树的两种遍历方式：
1.深度优先遍历：先往深走，遇到叶子节点再往回走。
2.广度优先遍历：一层一层地去遍历。
继续对两种遍历进行拓展：
深度优先遍历 前序遍历：中左右（递归法，迭代法）
中序遍历：左中右（递归法，迭代法）
后序遍历：左右中（递归法，迭代法）
广度优先遍历 层次遍历（迭代法）
在深度优先遍历中有三个顺序：前中后序，前中后指的是中间节点的遍历顺序。
在实现深度优先遍历时，经常使用递归的方式，栈也是递归的一种实现结构，因此前中后序遍历的逻辑也可以借助栈使用递归的方式实现。
而广度优先遍历的实现一般使用队列来实现。这是由队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层地遍历二叉树。
二叉树的定义 链式存储二叉树节点的定义方式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbc3c316ddb4deec9536dc6cac3ab93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec049af56f19556ff89f62f06abdb5f/" rel="bookmark">
			2023 年中国高校大数据挑战赛赛题B DNA 存储中的序列聚类与比对-解析与参考代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目背景：目前往往需要对测序后的序列进行聚类与比对。其中聚类指的是将测序序列聚类以判断原始序列有多少条，聚类后相同类的序列定义为一个簇。比对则是指在聚类基础上对一个簇内的序列进行比对进而输出一条最有 可能的正确序列。通过聚类与比对将会极大地恢复原始序列的信息，但需要注意 由于DNA测序后序列众多，如何高效地进行聚类与比对则是在满足准确率基础上的另一大难点。
数据说明：
“train_reference.txt”是某次合成的目标序列，其中第一行为序号，第二行 为序列内容。
通过真实合成、测序后读取到的测序序列文件为“train_reads.txt”，我们已经对测序序列进行了分类，该文件第一行为目标序列的序号，第二行为序列内容。 基于赛题提供的数据，自主查阅资料，选择合适的方法完成如下任务： 任务1：观察数据集“train_reads.txt”、“train_reference.txt”，针对这次合成任务，进行错误率（插入、删除、替换、断链）、拷贝数方面的分析。其中错误率定义为某个碱基发生错误的概率，需要对不同类型的错误率分别进行分析。拷贝数定义为原始序列复制的数量。 ·数据读取与查看：
首先需要根据题目给出的数据信息，对任务1中提到的两个数据集“train_reads.txt”、“train_reference.txt”进行读取与查看。
这里我们采用python语言，Jupiter notebook编程：
import pandas as pd import numpy as np #1#读取数据 df_reference = pd.read_csv('train_reference.txt', delimiter=' ',header=None) df_reference.columns = ['序号', '序列内容'] # 替换列名 df_reference df_train=pd.read_csv('train_reads.txt',delimiter=' ',header=None) df_train.columns = ['序号', '序列内容'] # 替换列名 df_train ·拷贝数分析：
由于拷贝数的统计计算较为简单，我们首先对拷贝数进行统计分析。
根据题意，拷贝数定义为原始序列复制的数量，所以我们只需要计算每个序列对应的复制次数。
代码如下：
#拷贝数分析 df_copies=df_train['序号'].value_counts().sort_index() df_copies #可视化 import matplotlib.pyplot as plt # 绘制柱状图 plt.bar(df_copies.index, df_copies.values) plt.xlabel('Order') plt.ylabel('Count') plt.title('Order Counts') plt.show() 从可视化结果可以直观地看出，绝大多数序列被复制的次数都在100-140之间，但是具体的复制数目参差不齐。
·错误率分析：
错误率共有四种类型：（插入、删除、替换、断链）
针对每种类型，需要我们进行人工定义相应的错误率计算方式：
插入错误（记为1类错误） 删除错误（记为2类错误）替换错误（记为3类错误） 断链（记为4类错误）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec049af56f19556ff89f62f06abdb5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2aab8ee1974413a8492f74acd357c1/" rel="bookmark">
			Ubuntu16.04 安装Anaconda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤 1： 去官网下载安装包,链接如下:
https://repo.anaconda.com/archive/
找到对应版本下载至本地电脑，并上传至服务器。
步骤2: 通过命令解压
sh Anaconda3-2023.03-0-Linux-x86_64.sh
一路选择yes或则回车，直到安装成功出现下面画面：
步骤3: 刷新配置
source ~/.bashrc
步骤4： 创建环境变量试一试
conda create --name py38 python=3.8
步骤5： 进入新创建的环境变量
conda activate py38
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d9b5f25aec71a20a1698bacd1fd0d7/" rel="bookmark">
			【go语言】Chromeless简介及Chromedp库实现模拟登录截屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Chromeless chromeless 是一个基于 Node.js 的库，用于通过无头浏览器（Headless Chrome）进行自动化测试和网页截图。它允许开发者使用 JavaScript 脚本来控制和操作浏览器，而无需实际打开浏览器窗口。
以下是一些 chromeless 的主要特性和用法：
基于 Chrome DevTools Protocol：chromeless 使用 Chrome DevTools Protocol（CDP）与浏览器进行通信。这允许对浏览器进行底层的控制和操作。支持无头模式： 由于使用 Headless Chrome，chromeless 在执行测试和脚本时不会显示实际的浏览器界面，从而提高了效率。链式调用：chromeless 的 API 设计允许使用链式调用，使代码看起来更清晰和易读。截图和PDF生成： 可以使用 chromeless 进行页面截图和生成 PDF 文件，这对于测试和生成报告非常有用。表单提交和用户交互： 支持模拟用户在页面上的交互，比如点击、输入文本等操作。异步执行：chromeless 支持异步操作，可以等待页面加载完成或等待特定的事件发生。 以下是一个简单的 chromeless 示例：
const { Chromeless } = require('chromeless'); async function run() { const chromeless = new Chromeless(); const screenshot = await chromeless .goto('https://www.example.com') .screenshot(); console.log(screenshot); // 返回截图的 Buffer await chromeless.end(); } run().catch(console.error); 在这个示例中，chromeless 打开了一个 Headless Chrome 浏览器，导航到了 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d9b5f25aec71a20a1698bacd1fd0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d511b4f992fd15c589079602a2450f6/" rel="bookmark">
			MMDet 第三季度更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MMDet 第三季度更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f51ff1c149951738b28d063c12ae03c7/" rel="bookmark">
			Tensorboard(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from torch.utils.tensorboard import SummaryWriter import numpy as np from PIL import Image img_path = r'D:\Pytorch\hymenoptera_data\train\bees\16838648_415acd9e3f.jpg' img_PIL = Image.open(img_path) print(type(img_PIL)) img_arry = np.array(img_PIL) print(img_arry.shape) # (512, 768, 3) writer = SummaryWriter('logs') writer.add_image('test', img_arry, -1, dataformats='HWC') # 高度 宽度 通道 #y = x for i in range(100): writer.add_scalar('y = 2x', 2*i, i) writer.close() tensorboard --logdir=pythonProject/Tensorboard/logs --port=6007 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c6b8036dcdb4ab3f42c9439225aa96/" rel="bookmark">
			76 BFS解单词接龙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：给定两个单词(beginWord和endWord)和一个字典，找到从beginWord到endWord的最短转换序列的长度，转换需要遵循一下规则：每次转换只能改变一个字母，转换过程中的中间大慈必须是字典中的单词；说明：如果不存在这样的转换序列，返回0，所有的单词具有相同的长度，所有单词都由小写字母组成，字典中不存在重复的单词，可以假设beginWord和endWord是非空的，且二者不相同。
bfs求解，每一层bfs将所有能考虑到的将单词改变一个字母的单词，且存在于wordDict中，且没有遍历过，则加入队列中，直到找到这个单词或遍历完所有情况。并返回当前层次即可。
public int minStep(String beginWord,String endWord,List&lt;String&gt;wordDict) { Set&lt;String&gt;wordSet=new HashSet&lt;&gt;(wordDict); Set&lt;String&gt;set=new HashSet&lt;&gt;(); Queue&lt;String&gt;queue=new LinkedList&lt;&gt;(); set.add(beginWord); queue.add(beginWord); int level=0; while(!queue.isEmpty()) { int queueSize=queue.size(); for(int i=0;i&lt;queueSize;i++) { String tempStr=queue.poll(); if(tempStr.equals(endWord)){return level;} for(int j=0;j&lt;tempStr.length();j++) { for(char j='a';j&lt;='z';j++) { String changeStr=tempStr.substring(0,j)+j+tempStr.substring(j+1); if(!wordSet.contains(changeStr)||set.contains(changeStr)) { continue; }else { queue.add(changeStr); } } } } level++; } return -1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41222cd44a5d7b58cf4098e04e061ab4/" rel="bookmark">
			Pandas教程（二）—— 不同格式的数据读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：几种常用数据格式的介绍 csv文件 1. 逗号分隔值文件，以纯文本形式（记事本）存储表格数据
2. 它是一种平面文件：即只存储数据和文字，不能存储公式、图表等
3. 更适合存储大数据，一般用来批量一维或二维存储数据
4. csv、tsv、txt都属于文本文件，只是csv以逗号分隔，tsv以制表符Tab隔开，而txt没有具体要求（逗号、制表符、空格等都可） CSV文件的存储方式 Excel文件 1. Excel是一个电子表格，将文件保存为自己的专有格式，即xls或xlsx
2. Excel是一个二进制文件，它不仅可以存储数据，还可以对数据进行操作
3. 不适合处理大数据
JSON数据 1. JSON是一种轻量级的数据交换格式，用于存储和传输结构化数据
2. JSON一般存储与Web浏览器中，是一种在各个编程语言中流通的数据格式（类似英语）
3. JSON 数据的书写格式是键（名称）值对
XML、HXML格式 1. XML是一种标记语言，被设计用来传输和存储数据（同JOSH），其焦点是数据的内容
2. HTML 是超文本标记语言，被设计用来显示数据，其焦点是数据的外观
1.在python中新建文件 文件类型新建方法csv和txt（纯文本文件）pd.to_csv（路径）excelpd.to_excel（路径）sqlpd.to_sql（路径） 新建文件方法的几个参数：
sep：分隔符
na_rep= : 缺失值标注（默认为空字符串）
index = : 是否写入行的标签（默认True）
header = ：是否写入列的标签（默认True）
import pandas as pd import numpy as np road = "D:\python code\pycharm\表格.xlsx" data = pd.DataFrame(np.arange(9).reshape(3, 3)) print(data) data.to_excel(road,index=False,header=False) 2.读写csv和txt文本文件 函数描述pd.read_csv（path）从文件读取分割好的数据，默认分隔符为逗号 ，pd.read_table（path）从文件读取分割好的数据，默认分隔符为制符表 \tpd.read_clipboard（）从粘贴板读取数据 读写文本文件方法的几个参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41222cd44a5d7b58cf4098e04e061ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0dbc95003e6505e1cf93c938b1e73fe/" rel="bookmark">
			智慧工地解决方案，智慧工地项目管理系统源码，支持大屏端、PC端、手机端、平板端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智慧工地解决方案依托计算机技术、物联网、云计算、大数据、人工智能、VR&amp;AR等技术相结合，为工程项目管理提供先进技术手段，构建工地现场智能监控和控制体系，弥补传统方法在监管中的缺陷，最线实现项目对人、机、料、法、环的全方位实时监控。支持多端展示（大屏、PC端、手机端、平板端）。
相关技术：微服务架构+Java+Spring Cloud +UniApp +MySql
智慧工地平台：
1个可扩展监管平台
依托组件化开发平台，满足用户需求的灵活配置。
2个应用端
满足用户PC端、移动端数据同步需求，移动端可选多种平台。
3方数据融合
依托数据交互子平台，智慧工地平台，5G及智能终端算法，满足住建数据监管要求。
N+个智能设备
依托丰富的设备接口标准库，快速接入工地现场各类型设备。
系统介绍：
1、可视化大屏
可视化大屏是本系统的核心所在是执行日常监控、系统管理、应急指挥的场所，集形象展示，监控指挥，视频监控显示、工地大脑展示为一体。
内部的视频监控综合管理平台，包括数据库服务模块、管理服务模块、接入服务模块、报警服务模块、流媒体服务模块、存储管理服务模块、Web 服务模块等。
支持随时抽查全部视频监控资源，接收报警信息，查阅各类统计数据，实现管理的高度集中化，做到管控一体集中处理。
2、视频监控系统
系统远程调阅音视频资源，可对联网系统内带有云台镜头解码器的摄像机进行远程控制。能按照指定通道进行单路图像、分组图像的实时点播，自动或手动轮循切换显示。
能根据时间段，自动切换不同类型的图像分组。支持对显示图像的缩放、抓拍和录像。
系统能按图像通道、日期和时间、报警信息等检索条件对前端设备录像文件进行检索。在录像检索时，可以在 4 画面、9 面对多路视频录像进行同步回放， 从多个角度掌握现场情况。
3、Wi-Fi安全教育
全面覆盖工地生活场景，深化工地人员安全意识，营造积极主动的工地学习氛围，降低教育成本。
手机连接工地wifi，完成安全问答，正确率达标即可上网。系统自动记录答题人数、答题数量、答题正确率以及是否通过等。通过访问web端，自定义题库内容。
可根据答题正确率动态限定上网时长，超过认证时间后均需重新进行安全答题。灵活调整AP数量，以及管理工作网络与娱乐网络的带宽分配。
4、环境监测系统
实时显示 PM2.5、PM10、温度、湿度、风速、风向、噪音数据:；智慧工地平台可设置报警值、预警值，发生报警时能够及时推送预警信息。
智慧工地平台可设置颗粒物指标预警值，当检测到颗粒物浓度超标后系统自动启动喷淋设备，实现自主降尘。
手机端APP 具有远程控制功能。
5、高支模监测系统
智能传感器实时监测，精确至微米级，保障安全。创新提出架体水平位移、模板沉降、立杆轴力、立杆倾角四类大项，监测更全面，施工更安心。
各项安全数据秒级传输，确保同步声光预警，便于紧急隐患排查，安全疏散。高支模监测预警工地大脑，率先行业提出手机端与网页端同步监测，信息技术促进行业升级。
6、深基坑监测系统
系统对前端深基坑的围护结构顶部水平位移、深层水平位移、立柱顶水平位移、沉降、支撑结构内力、维护桩内力和锚索应力等数据实时监测。
系统实时接收前端监测设备的数据，一旦有任何数据超过警戒线，系统立刻报警，将报警信息发送至设计单位、建设单位和检测机构等，为相关单位做出决策提供数据依据。
7、智能水电监测系统
系统中的水电表，按照设定的时间将前端的数据上传到后端工地大脑，最高频率可按照 1小时/次上传。
系统获取数据后按照日、月进行统计，统计后的详细数据可以通过柱状图、折线图等方式展现，方便使用者查看。系统可对上传的数据进行分析，对异常用水量，用电量进行侦测。
检测瞬间大波动，并将异常信息推送给相关管理人员，以此预判线管爆裂，电路线缆短路等情形。
8、塔机升降安全监测系统
当吊重超限超载时，系统自动声光预警，系统自动切断上升方向的电源，只允许下降方向的运动；系统可智能判断塔机的起重量与起重力矩，有效的保证了塔机的操作安全。
塔吊每吊数据均通过 GPRS 模块实时发送到监控系统平台，远程可同步监控。群塔中每塔均安装防碰撞监控设备，对塔吊作业状态(转角、半径、塔高等)进行实时监控，塔吊智能识别和判断碰撞危险区域。
配备智能 IC 卡/人脸识别/指纹识别 通过塔吊智能安全服务平台，对塔吊实行在线备案管理，对塔吊的安装、拆卸和移机进行全方位远程异地管理。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/20/">«</a>
	<span class="pagination__item pagination__item--current">21/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/22/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>