<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/731c7261f21995c538c999d22aa27cc3/" rel="bookmark">
			python&#43;vue企业员工在线办公自动化oa系统22ms1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目主要模块有登录，职位管理、职称管理、部门管理、员工管理、工资管理、在线聊天本项目目的是实现中小型企业的在线办公系统，在线办公系统是一个用来管理日常的办公事务的一个系统，它能够管的内容有:日常的各种流程审批，新闻，通知，公告，文件信息，财务，人事，费用，资产，行政，项目，移动办公等等。它的作用就是通过软件的方式，方便管理，更加简单，更加扁平。更加高效，更加规范，能够提高整体的管理运营水平。
语言：Python
框架：django/flask可以定制
软件版本：python3.7.7
数据库：mysql 数据库工具：Navicat
开发工具pycharm/vscode都可以
前端框架:vue.js
本项目在技术方面采用最主流的前后端分离开发模式，使用业界最流行、社区非常活跃的开源框架 Vue和Spring Boot 来构建前端和后端，旨在实现云办在线办公系统。包括职位管理、职称管理、部门管理、员工管理、工资管理、在线聊天等模块一个好的系统能够把传统的在线办公管理方式，带上一全新的方式，效率、可靠、安全稳定集合一身的系统，带来的体验是传统管理方式所没有办法实现的，信息的交流将达到顶峰，用户的沟通将会更加的便捷，有问题实时反馈提交，及时接收重要通知，将在线办公信息管理正规化、合理化、高效化。
由此设计与开发一个在线办公系统是非常有必要的，python语言是所有语言中的基础，学习好python语言才能去更深入的学习其它语言。python语言有以下特点：绘图能力强、可移植性、有很强的数据处理能力，适用于系统软件的编写、三维和二维图形，还可以编写出动画的效果，所以它是一种高级语言。
这一次的系统开发，选用的是 python语言，这也是一种面向对象编程的语言。 python为开发者提供了非常丰富的类库，极大地降低了使用 windows编程的难度，降低了开发人员在设计算法上的难度[9-11]。 python开发 Visual Studio更是一个不可或缺的角色，其友好的界面，强大的功能，给程序开发人员带来了许多便利。再加上环境简单，移动容易，无疑使此系统成为了最佳的选择。因此，在后台的设计中，我们选用了 MySQL的数据库查询来建立并维持资讯。从未来发展趋势来看，应该具有功能完善，使用便利，后台数据库的要求则是能够建立和保持数据信息的一致性和完整性，
目 录
第1章 概述 6
1.1课题研究背景 6
1.2课题研究意义 6
1.3系统研究现状 7
1.4前期工作 7
1.5本文的组织结构 7
第2章开发技术 9
2.1 python语言 9
2.2 django框架 9
2.3 MYSQL数据库技术 9
2.4 B/S结构简介 10
第3章 系统分析 12
3.1系统总体分析 12
3.2可行性分析 12
3.3系统功能分析 13
3.4系统流程分析 14
3.4.1登录流程 14
3.4.2添加信息流程 15
3.4.3删除流程 15
第4章 系统设计 17
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/731c7261f21995c538c999d22aa27cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fca41db34d5f9c997d9da8e6754c88f/" rel="bookmark">
			微信小程序的碎片化学习签到打卡系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语言：nodejs+python+nodejs+php+java均可选
运行软件:idea/eclipse/vscode/pycharm/wamp
框架支持:springboot/Ssm/vue/django/thinkphp
用户：登录、
个人信息修改
查看公告
写备忘录、
导入课程表、上课提醒、
制定学习计划，任务开始前有签到，任务结束打卡
用户可以写日记
用户可以查看自己的学习记录、签到记录以及碎片化时间利用率等
管理员：登录后台管理系统
管理用户信息
发布公告，管理公告
对每个用户有一个学习情况的界面，可以看到用户做了哪些计划，完成情况怎么样
1.本课题是基于小程序的签到碎片化学习平台的研究，主要划分为管理员和用户，管理员主要是进行系统的维护，发布一些信息。用户主要是通过小程序安排学习计划，进行学习打卡。下面介绍各个角色的功能：
（1）管理员
1）管理员登陆
使用管理员账号登录，进入后台管理
2）公告管理
此功能是为了发布公告来告知用户一些重要信息，可以对公告信息进行添加、修改、查看详情、删除操作，新增的公告包括标题、内容两种信息。
（2）用户
1）登录
用户可以直接授权登录
2）个人信息查询
用户可以对个人信息进行修改操作，包括用户名、姓名、性别、学校、个性签名等信息。
3）公告查询
用户可以查看公告信息
4）记录查询
用户可以查看自己的学习记录、签到记录以及碎片化时间利用率等
2.数据库设计
（1）用户表（主键、用户名、密码、真实姓名、添加时间、用户身份、手机号、籍贯、性别、年龄等）
（2）公告表（主键、公告标题、公告内容、添加时间、删除状态）
（3）用户学习记录表（主键、学习时间、学习内容、学习时长等）
3.系统实现
（1）后台登录界面：实现用户登录、用户注册、登陆权限、跳转到注册界面等功能。
（2）用户管理页面：对用户信息进行管理，跳转到添加用户等功能。
（3）学习安排界面：安排学习时间，制定学习计划
（4）签到界面：学习完成进行签到打卡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90543b414a120a9676e045cde842c490/" rel="bookmark">
			React格式化规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 React并没有特定的格式要求，它允许开发者根据自己的喜好和项目需求来选择代码的格式化风格。然而，在React社区中有一些常见的约定和最佳实践，以下是一些常用的格式化规范和建议：
缩进：使用2个或4个空格来进行缩进，避免使用制表符（tab）。
大括号：在JSX中，通常将大括号与标签的起始位置放在同一行，并且每个属性都应该单独占据一行。示例：
&lt;Component prop1={value1} prop2={value2} prop3={value3} /&gt; 标签格式：对于没有子元素的标签，应该使用自闭合形式，即在结束标签前添加斜杠。示例：
&lt;EmptyTag /&gt; &lt;TagWithProps prop1={value} /&gt; JSX花括号：当需要在JSX中嵌入JavaScript表达式时，使用花括号 {} 包裹表达式。示例：
&lt;h1&gt;{title}&lt;/h1&gt; &lt;p&gt;{(num1 + num2) * 2}&lt;/p&gt; 行长度限制：为了保持代码可读性，建议每行代码不超过80-100个字符。
组件定义：每个组件应该在一个单独的文件中进行定义，并使用PascalCase命名约定。同时，组件的代码可以分为状态（state）和生命周期方法（lifecycle methods）、事件处理器（event handlers）、渲染方法（render method）等块来进行组织。
空行：在适当的位置添加空行来提高代码可读性，例如在不同的逻辑块、组件之间添加空行。
注释：合理使用注释，对关键代码和复杂逻辑进行解释说明。注释应该是清晰、简洁和易于理解的。
导入顺序：按照一定的顺序进行导入语句的编写，例如先导入React相关库，然后是第三方库，最后是本地文件。示例：
import React from 'react'; import PropTypes from 'prop-types'; import ThirdPartyLibrary from 'third-party-library'; import LocalComponent from './LocalComponent'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3bb652b3016f4aec770d92533e12ce/" rel="bookmark">
			八、Lua脚本详解—— 超详细操作演示！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八、Lua脚本详解 —— 超详细操作演示！ 八、Lua脚本详解8.1 Lua 简介8.2 Linux 系统的Lua8.2.1 Lua 下载8.2.2 Lua 安装8.2.3 Hello World 8.3 Win 系统的Lua8.4 Lua 脚本基础8.4.1 注释8.4.2 数据类型8.4.3 标识符8.4.4 运算符8.4.5 函数8.4.6 流程控制语句8.4.7 循环控制语句 8.5 Lua 语法进阶8.5.1 table8.5.2 迭代器8.5.3 模块8.5.4 元表和元方法8.5.5 面向对象8.5.6 协同线程与协同函数8.5.7 文件IO 九、分布式锁9.1 分布式锁的工作原理9.2 问题引入9.3 setnx 实现方式9.4 为锁添加过期时间9.5 为锁添加标识9.6 添加 Lua 脚本9.7 Redisson 可重入锁9.8 Redisson 红锁9.9 分段锁9.10 Redisson 详解 数据库系列文章：
关系型数据库:
MySQL —— 基础语法大全MySQL —— 进阶 非关系型数据库:
一、Redis 的安装与配置二、Redis 基本命令（上）三、Redis 基本命令（下）四、Redis 持久化五、Redis 主从集群六、Redis 分布式系统七、Redis 缓存 八、Lua脚本详解 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c3bb652b3016f4aec770d92533e12ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f618fb30318f6a1a42d063c32e11ab99/" rel="bookmark">
			题解 | #在二叉树中找到两个节点的最近公共祖先#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法面试高频知识点：模型部署总结
秋招最终选----团子
太古地产 招商与运营岗 面经
网络安全与隐私保护
荣耀网络安全工程师
现在这么卷了吗
一个中科大差生的8年程序员工作总结
春招，再拼搏一次吧！
春招来了，我是否要换方向呢？
#对未来的工作有什么期待(46774)#[喝可乐]先爆几年米然后争取回川渝工作去，希望到时候能转到比
菜鸟总部附近转租
☁还是✋
23京东春招产品笔试
老码农毕业之后东奔西走的那些年
春招提前批启动！产品运营市场大类岗位1.4已更新
华为2012东莞中硬状态普查
关于邮储的一些情况
题解 | #有效括号序列#
#include &lt;string&gt;#include &lt;type_traits&gt;class Solution {public: /*
题解 | #百钱买百鸡问题#
#include &lt;stdio.h&gt;int main() { int a,b,c,e,f; // scanf("%d"
题解 | #链表内指定区间反转#
/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : 题解 | #在二叉树中找到两个节点的最近公共祖先#
/** * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *r
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f618fb30318f6a1a42d063c32e11ab99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e548385da850d1d54657ad672e186d3/" rel="bookmark">
			代码随想录day20 开始二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		654.最大二叉树 题目 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
二叉树的根是数组中的最大元素。左子树是通过数组中最大值左边部分构造出的最大二叉树。右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。
示例 ：
思考 本题也是通过递归的方式构造二叉树：找到数组中最大的数，然后最大数左部分变成一个数组，右部分变成一个数组，继续node-&gt;left、node-&gt;right递归两个数组，注意创建左右数组的时候需要跳过node
代码 class Solution {
public:
TreeNode* traversal(vector&lt;int&gt;&amp; nums) {
if(nums.size() == 0) return nullptr;
int maxValue = INT_MIN;
for(auto i : nums) {
maxValue = max(maxValue, i);
}
TreeNode* node = new TreeNode(maxValue);
int pos = 0;
for(; pos &lt; nums.size(); pos++) {
if(nums[pos] == maxValue) break;
}
vector&lt;int&gt; left(nums.begin(), nums.begin() + pos);
vector&lt;int&gt; right(nums.begin() + pos + 1, nums.end());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e548385da850d1d54657ad672e186d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0bf8e3daac0068b6802356455af995/" rel="bookmark">
			大模型上下文长度的超强扩展：从LongLoRA到LongQLoRA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文一开始是《七月论文审稿GPT第2版：从Meta Nougat、GPT4审稿到Mistral、LongLora Llama》中4.3节的内容，但考虑到
一方面，LongLora的实用性较高二方面，为了把LongLora和LongQLora更好的写清楚，而不至于受篇幅之限制三方面，独立成文可以有更好的排版，而更好的排版可以有更高的可读性(哪怕一个小小的换行都能提高可读性，更何况独立成文带来的可读性的提高) 故把这部分的内容抽取出来独立成本文
第一部分 LongLora 具体而言，LongLora是港中文和MIT的研究者通过此篇论文《LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models》于23年9月底提出的(这是其GitHub)，其显著特点有三
longlora的作者团队认为：尽管在推理过程中需要密集的全局注意力，但通过稀疏局部注意力(sparse local attention)也可以高效地完成模型的微调，比如他们提出的移位稀疏注意力(shifted sparse attention，简称S2-Attn)可有效地实现上下文扩展且显著节省计算资源，具有与使用vanilla注意力(vanilla attention)进行微调相似的性能
简言之，用sparse local attention替换掉dense global attention，类似检索，不需要把所有的东西都拿过来，把相似度高的，匹配度高的一部分context拿来就可以了他们发现，LoRA加到embedding matrix以及normalization的子网络上的时候，效果更好
啥意思？这点在于常规操作是lora一般加到query, key, value等部分上，而这里是加到embedding matrix上，以及normaliztion上了LongLoRA在保留原始架构的同时扩展了模型的上下文，并且与大多数现有技术(如Flash-Attention2)兼容
此外，还进一步发布了使用LongLoRA技术的长指令遵循数据集LongAlpaca，以进行监督微调(we further conduct supervised fine-tuning with LongLoRA and our long instruction-following LongAlpaca dataset) 1.1 LoRA在长文本上的不足 通过本博客内的多篇文章可知，原始transformer的计算复杂度虽序列长度的二次方成正比，这一点一直导致模型的长下文长度不好扩展(比如把长度从2048扩展到8192，复杂度得上升4x4 = 16倍)，对于该问题 很多研究者或团队做了各种改进与探索
比如Flash-Attention、Flash-Attention2(详见此文《通透理解FlashAttention与FlashAttention2：让大模型上下文长度突破32K的技术之一》)再比如Position Interpolation (详见此文《大模型上下文扩展之YaRN解析：从直接外推ALiBi、位置插值、NTK-aware插值、YaRN》的2.3节) spent 32 A100 GPUs to extend LLaMA models from 2k to 8k context，当然了，这种资源开销即便是七月项目团队也不一定舍得耗(其实，我司项目团队一直在“低成本 高效果”的方向上探索，过程中积攒了这方面的很多经验)，更别说一般个人了 如何降低资源开销呢？一种直接的方法是通过LoRA对预训练的LLM进行微调
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0bf8e3daac0068b6802356455af995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c4441fe48f8700a25fc04aa0d8a511/" rel="bookmark">
			根本记不住MySQL进阶查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 MySQL进阶查询 1.1 MySQL进阶查询的语句 全文以数据库location和Store_Info为实例 ---- SELECT ----显示表格中一个或数个字段的所有数据记录 语法：SELECT "字段" FROM "表名"; select 列名 from 表名 ;
---- DISTINCT ----不显示重复的数据记录 语法：SELECT DISTINCT "字段" FROM "表名"; SELECT DISTINCT Store_Name FROM Store_Info;
---- WHERE ----有条件查询 语法：SELECT "字段" FROM "表名" WHERE "条件"; SELECT Store_Name FROM Store_Info WHERE Sales &gt; 1000;
---- AND OR ----且 或 语法：SELECT "字段" FROM "表名" WHERE "条件1" {[AND|OR] "条件2"}+ ; SELECT Store_Name FROM Store_Info WHERE Sales &gt; 1000 OR (Sales &lt; 500 AND Sales &gt; 200);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c4441fe48f8700a25fc04aa0d8a511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27130f45db40e983f3979656dd747038/" rel="bookmark">
			入门使用mybatis-plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：pom文件带入依赖 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 第二步：创建实体对象 @TableName("leave_request") @Data @AllArgsConstructor @NoArgsConstructor public class LeaveRequest { @TableId private int id; private String requestUuid; private String title; private Integer leaveDay; private LocalDate leaveStartTime; private LocalDate leaveEndTime; private String requestorName; private String teamLeader; private String sourcingManager; private String DbsBoss; private String NCSTeamLeader; private String status; } 需要注意的是@TableName("leave_request")，这个东西对应你数据库里面的表
第三步：@Mapper和@MapperScan必须二选一 @SpringBootApplication(exclude= SecurityAutoConfiguration.class) @MapperScan("com.example.demo.Mappers") public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } @MapperScan("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27130f45db40e983f3979656dd747038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728cb2c9fa67b2020696c22e7d138e2c/" rel="bookmark">
			Python-CSV文件的存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSV文件存储 CSV其文件以纯文本形式存储表格数据。CSV文件是一个字符序列，可以由任意数目的记录组成，各种记录由某种换行符分隔开。它比Excel文件更加简洁，XLS文本是电子表格，包含文本、数值、公式和格式等内容，CSV中则不包含这些，就是以特定字符作为分隔符的纯文本，结构简单清晰，所以有时候使用CSV来存储数据是比较方便的。
1.写入 import csv with open('data.csv','w') as csvfile: writer = csv.writer(csvfile) writer.writerow(['id','name','age']) writer.writerow(['10001','Mike',20]) writer.writerow(['10002','Bob',21]) writer.writerow(['10003','Jered',22]) 这里首先打开data.csv文件，指定打开模式w写入，获得文件句柄，随后调用csv库的writer方法初始化写入对象，传入该句柄，然后用writerow方法传入每行的数据。
运行结束后会生成一个名为data.csv的文件，打开如图所示。
这时候如果直接打印输出会发现分隔符这时是默认的以逗号分隔，如果想修改列与列之间的分隔符，可以传入delimiter参数。
import csv with open('data.csv','w') as csvfile: writer = csv.writer(csvfile,delimiter=' ') writer.writerow(['id','name','age']) writer.writerow(['10001','Mike',20]) writer.writerow(['10002','Bob',21]) writer.writerow(['10003','Jered',22]) 这时就会发现列于列之间的分隔符已经变成了空格。
另外我们也可以调用writerows方法同时写入多行，此时参数需要传入二维列表。
import csv with open('data.csv','w') as csvfile: writer = csv.writer(csvfile) writer.writerow(['id','name','age']) writer.writerows([['10001','Mike',20],['10002','Bob',21],['10003','Jered',22]]) 但是，在一般情况下爬虫爬取的数据都是结构化数据，我们一般会用字典表示。csv库也提供了字典的写入方式。
import csv with open('data.csv','w') as csvfile: filednames = ['id','name','age'] writer = csv.DictWriter(csvfile,fieldnames=filednames) writer.writeheader() writer.writerow({'id':'10001','name':'Mike','age':20}) writer.writerow({'id':'10002','name':'Bob','age':21}) writer.writerow({'id':'10003','name':'Jared','age':22}) 这里定义了三个字段，用filedname表示，然后传给DictWriter方法以初始化一个字典写入对象，并赋值给writer变量。接着用writeheader方法先写入头信息，再调用writerow方法传入相应字典。
另外，如果想要追加写入，可以修改文件的打开模式，即把open函数的第二个参数改成a，代码如下：
import csv with open('data.csv','a') as csvfile: filednames = ['id','name','age'] writer = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728cb2c9fa67b2020696c22e7d138e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b8c98185541025f6b5ba023dd006c6/" rel="bookmark">
			力扣第一百道题，记录一下——x 的平方根
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
很容易想到用二分查找，但有一点要注意，mid的平方计算时要强转成long类型，因为如果x很大的话，取x的一半算平方很容易就超出int范围。
public int mySqrt(int x) { int l = 0, r = x, ans = 0; while (l &lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid &gt; x) { r = mid - 1; } else { ans = mid; l = mid + 1; } } return ans; } 本来第一百题特地挑一题简单题刷一下，结果自信写出来，第一次提交还错误，怎么想逻辑都没问题，那很大可能就跟数字大小有关了，改成long之后果然没问题了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b8c98185541025f6b5ba023dd006c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b65124ba5c0ed2cb44c1ab453a8f13/" rel="bookmark">
			Linux 进程(八) 进程的退出码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main 函数的返回值叫做进程的退出码。当进程成功退出的时候，我们一般用0来表示。进程失败的时候一般用非零来表示。我们使用不同的数字来表示进程退出时不同的失败原因。
我们查看系统的有多少退出码以及其含义时需要用到strerror() 他的头文件和用法如下。
通过一下代码来查看系统有多少退出码
#include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;errno.h&gt; #include&lt;string.h&gt; int main() { int i = 0; for(i;i&lt;200;i++) { printf("%d:,%s\n",i,strerror(i)); } return 0; } 我们可以看到系统大概有134个退出码，每个退出码都有其自己的含义。由于太长只列举出来前几个。
echo $? 查看最近一个进程的退出状态，查看到的是0 表示的就是成功。
同时我们还可以自己设置进程退出码以及它的含义。
enum{ success=0, open_err, malloc_err }; const char* errorTodesc(int code) { switch(code) { case success: return "sucesss"; case open_err: return "open_fail"; case malloc_err: return "malloc_fail"; dafault: return "unknow error"; } } int main() { int code = malloc_err; printf("%s\n",errorTodesc(code)); return malloc_err; } 除了进程退出，还有函数退出。 main函数退出表示进程结束，而函数退出仅仅表示函数调用完毕。函数也是有返回值的。调用函数一般我们通常想看到两种结果，第一函数执行结果 成功，或者失败。第二函数的执行情况，如打开一个文件，如果成功会返回一个文件指针，如果失败就会返回NULL。如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61b65124ba5c0ed2cb44c1ab453a8f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6411cc4910860660fc23ba1e3d4ac9a4/" rel="bookmark">
			算法基础之区间覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区间覆盖 核心思想： 贪心
1.将所有区间按照左端点大小排序
2.遍历所有区间 找到能覆盖start 且右端点最大的那个区间(双指针)
3.更新start为max®
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N = 100010; int n; struct Range{ int l,r; bool operator&lt; (const Range&amp; W)const{ return l &lt; W.l; } }range[N]; int main() { int st,ed; cin&gt;&gt;st&gt;&gt;ed&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;range[i].l&gt;&gt;range[i].r; sort(range,range+n); int res=0; bool success = false; //标记是否找出能覆盖的区间 for(int i=0;i&lt;n;) //双指针 用里层j去更新i { int j=i,r=-2e9; //r为最大右端点 while(j&lt;n &amp;&amp; range[j].l &lt;= st) //能覆盖st { r = max(r,range[j++].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6411cc4910860660fc23ba1e3d4ac9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83a33e8225cf5502378d247c83feef87/" rel="bookmark">
			兄弟们mdpi或者ieee Access润色和翻译都咋搞的哇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		春招提前批开了？卷王已经开始刷题了！
我还没进去，hr离职了服了
【2023校招】智加科技-自动驾驶软开面经
大疆嵌入式一面
入职阿里四个月生活的乐趣似乎离我越来越远
求路过的大佬为犬子点赞+收藏[赞]
这份简历，让我虎躯一震...
Java学习路线总结
Offer选择 大厂ssp 头部基金it 政策行总行
字节跳动 抖音中视频/西瓜视频/抖音精选 #字节引流(45786)# #抖音(2262)#
日记
华为舔狗日记（日更
集训营有Python版本的吗
这个赛后讲解有Python版本的吗
在阿里一年多了，忙是阶段性的，996 不可能也不应该是常态
已经在这里待了一年多了。相比较刚来时的胆小谨慎，现在我已经完全蜕变为一个“搞笑女”，每天都在和老板斗智斗勇，工作上也有幸得到了很多同事的认可。网上总是唱衰互联网
题解 | #密码验证合格程序#
import sysabc = "abcdefghijklmnopqrstuvwxyz"ABC = abc.upper()num = &amp;qu
题解 | #xxx定律#
//XXX定律 浙大 2024/1/4//http://t.cn/E937wDs#include &lt;iostream&gt;using namespace
春招
春招开了吗，最近收到好几个面试
入职阿里四个月生活的乐趣似乎离我越来越远
作为一名新员工，我在入职的四个月里经历了两次集团层面的调整，其中一次是 CEO 的更替，这被认为是公司历史上最大的调整之一。而在团队内部，小的调整更是不计其数，
实习是三无大学生秋招前的救赎！
秋招年年卷成麻花，但依然有大把的同学在秋招季哀嚎自己作为三无大学生的艰难。既然如此，摆脱三无大学生的头衔是秋招前一个很重要的议题。实习作为最直接影响秋招的因素，
联通数科西安
突然收到了电话应该是补录，想问问有没有了解情况的uu啊😭不知道签不签呢
题解 | #计算三角形的周长和面积#
#include &lt;stdio.h&gt;#include&lt;math.h&gt;int main() { int a, b, c = 0; 饿了么实习让我能够快速成长，不断提升自己的技能水平
前端实习饿了么，时间过得真快，转眼间已经进入第二周了。这周开始，我暂时告别了页面仔的身份，转而负责饿了么的 UI 设计。第二周，我开始着手开发一个后台管理系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83a33e8225cf5502378d247c83feef87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d45234d8ca454680ad16bb63341f945/" rel="bookmark">
			04 supervised learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Summary: unspervised learning clustering（聚类算法）Anomaly detection（异常检测） Recommender Systems（推荐系统）Reinforcement Learning（强化学习） 一 、 K-means算法 1.Notion a) K-means做的 ​ k-means重复做的两件事中
​ 第一件：是分配簇质心，然后将样本点距离近的变成相关的颜色
​ 第二件：重新遍历所有相同类型的点，然后取平均值，选出新的簇质心，检测每个点距离谁最近
b) some symbol &amp; cost function 2. k-means 聚类的步骤 a) Random initialization k ​ 簇质心随机选择样本中的点，然后循环多次选择不同的样本为簇质心，用于来找到 J 最小的时候的簇质心，次数如果太多也会降低效果
b ) how many k do we need ? i . elbow method(肘部法则) ​ 当我们将k 从1增加到m时候，代价函数 J 的函数图像会从大到小的递减，函数会有一个从递减迅速到缓慢的点，类似于人类的肘部 （但是有时很多J都是平缓下降的 没有肘部）
二 、 Anomaly detection 1. notion 如何计算正态分布的两个变量
2. 计算步骤 首先算出每一个特征的均值和方差利用每个特征的方差和均值算出某一个样本中的概率p(x)用计算出的p(x)和阈值比较，如果满足则表示有问题查看算法在交叉验证集中没能检测出的异常，然后考虑是否需要新建一个特征，使得发现这些异常原理： 算出每个样本的feature相较于所有样本中的异常大或者小的feature，然后p(x）乘出来会很小所以标记为异常
3. algorithm evaluation system（异常评估系统） 4 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d45234d8ca454680ad16bb63341f945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd52ddc3b48d1dd74f84b03dd23c1572/" rel="bookmark">
			Hadoop集群三节点搭建（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一台虚拟机准备 确认是可以上网，方便下载文件和工具，使用ping命令测试下
安装工具
net-tool：工具包集合，包含ifconfig等命令，大家可以根据自己需要按需下载
创建普通用户attest，并修改attest用户的密码
配置attest用户具有root权限，方便后期加sudo执行root权限的命令
在/opt目录下创建文件夹，并修改所属主和所属组
二、安装JDK 卸载虚拟机自带的JDK
rpm -qa：查询所安装的所有rpm软件包
grep -i：忽略大小写
xargs -n1：表示每次只传递一个参数
rpm -e –nodeps：强制卸载软件
切换成attest用户，安装jDK，Hadoop
上传jdk hadoop 安装包到指定的目录 （/opt/software）
解压JDK到/opt/module目录下 [attest@master software]$ tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/ 配置JDK环境变量
新建/etc/profile.d/my_env.sh文件 sudo vim /etc/profile.d/my_env.sh #JAVA_HOME export JAVA_HOME=/opt/module/jdk1.8.0_212 export PATH=$PATH:$JAVA_HOME/bin source一下/etc/profile文件，让新的环境变量PATH生效 [attest@master software]$ source /etc/profile 测试JDK是否安装成功 [attest@master software]$ java -version java version "1.8.0_212" Java(TM) SE Runtime Environment (build 1.8.0_212-b10) Java HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode) 能看到以上结果，则代表Java安装成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd52ddc3b48d1dd74f84b03dd23c1572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e756d674a05b837b67815e0fc6562fe/" rel="bookmark">
			杨中科 ASP.NETCore开发效率利器 HOT RELOAD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HOT RELOAD 1、困惑:修改了服务器端的代码，必须重新运行程序。
2、方法1: [启动 (不调试) ]
3、方法2: .NET 6开始的Hot Reload(热重载)
正常修改代码后 不重启，是无法看到新的数据展示在页面
修改
运行结果：
方式一：设置开始执行不调试 点击生成解决方案
再次刷新
缺点：不是以调试的方式 生成项目，无法使用断点操作
方式二：修改后点机热重载按钮 发现此时，不需要重启项目，便可以得到最新的结果
文件保存时热重载 点机保存之后，便能自动刷新
【注意】
代码发生比较重大的变化时，比如新增、删除方法，给方法增加参数等等
1.如果需要经常设置断点：热重载
2.如果不太需要断点调试：开始执行不调试方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f187ef67145b6cdcabba9ae02e9e44a/" rel="bookmark">
			C#设计模式之观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 观察者（Observer)模式也称发布-订阅（Publish-Subscribe）模式，定义了对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
观察者模式的图解如下所示：
Subject（目标）：
目标知道它的观察者。可以有任意多个观察者观察同一个目标。
目标提供了注册和删除观察者对象的接口。
Observer（观察者）：
为那些在目标发生改变时需获得通知的对象定义一个更新接口。
ConcreteSubject（具体目标）：
将有关状态存入各ConcreteObserver对象。
当它的状态发生改变时，向它的各个观察者发出通知。
ConcreteObserver（具体观察者）：
维护一个指向ConcreteSubject对象的引用。
存储有关状态，这些状态应与目标的状态保存一致。
实现Observer的更新接口以使自身状态与目标的状态保持一致。
不使用事件的示例 接下来我将根据上面的图解写一个C#观察者模式的例子，刚开始这个例子没有使用事件，在后面一个例子中使用事件。
首先来看看Subject（目标）：
//主题接口 public interface ISubject { public void Attach(Observer observer); public void Detach(Observer observer); public void Notify(); public string? SubjectState { get; set; } } 这里我使用的是接口，里面有Attach、Detach和Notify方法的声明，还有SubjectState属性的声明。
接下来看看ConcreteSubject（具体目标）：
public class School : ISubject { private IList&lt;Observer&gt; observers = new List&lt;Observer&gt;(); public string? SubjectState { get; set; } public void Attach(Observer observer) { observers.Add(observer); } public void Detach(Observer observer) { observers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f187ef67145b6cdcabba9ae02e9e44a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d423d73bbf5d21f4977dc81682bb60cd/" rel="bookmark">
			由浅入深理解C#中的事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 本文较长，给大家提供了目录，可以直接看自己感兴趣的部分。
前言 有关事件的概念 示例 ​ 简单示例 ​ 标准 .NET 事件模式 ​ 使用泛型版本的标准 .NET 事件模式 ​ 补充 总结 参考 前言 前面介绍了C#中的委托，事件的很多部分都与委托类似。实际上，事件就像是专门用于某种特殊用途的简单委托，事件包含了一个私有的委托，如下图所示：
有关事件的私有委托需要了解的重要事项如下：
1、事件提供了对它的私有控制委托的结构化访问。我们无法直接访问该委托。
2、事件中可用的操作比委托要少，对于事件我们只可以添加、删除或调用事件处理程序。
3、事件被触发时，它调用委托来依次调用调用列表中的方法。
有关事件的概念 发布者（Publisher）：发布某个事件的类或结构，其他类可以在该事件发生时得到通知。
订阅者（Subscriber）：注册并在事件发生时得到通知的类或结构。
事件处理程序（event handler）：由订阅者注册到事件的方法，在发布者触发事件时执行。
触发（raise）事件：调用（invoke）或触发（fire）事件的术语。当事件触发时，所有注册到它的方法都会被依次调用。
示例 简单示例 现在我们先来看一下最最原始的事件示例。其结构如下所示：
委托类型声明：事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型进行描述。
事件处理程序声明：订阅者类中会在事件触发时执行的方法声明。它们不一定有显示命名的方法，还可以是匿名方法或Lambda表达式。
事件声明：发布者类必须声明一个订阅者类可以注册的事件成员。当声明的事件为public时，称为发布了事件。
事件注册：订阅者必须订阅事件才能在它被触发时得到通知。
触发事件的代码：发布者类中”触发“事件并导致调用注册的所有事件处理程序的代码。
现在我们可以照着这个思路去写示例代码。
首先声明一个自定义的委托类型：
public delegate void MyDelegate(); 该委托类型没有参数也没有返回值。
然后再写一个发布者类：
public class Publisher { public event MyDelegate MyEvent; public void DoCount() { for(int i = 0; i &lt; 10; i++) { Task.Delay(3000).Wait(); //确认有方法可以执行 if(MyEvent !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d423d73bbf5d21f4977dc81682bb60cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57701ec911603714cf978850c58dc048/" rel="bookmark">
			在 Linux 中开启 Flask 项目持续运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Linux 中开启 Flask 项目持续运行 在部署 Flask 项目时，情况往往并不是那么理想。默认情况下，关闭 SSH 终端后，Flask 服务就停止了。这时，您需要找到一种方法在 Linux 服务器上实现持续运行 Flask 项目，并在服务器重启后自动重新启动。
本文将介绍两种方法来帮助您在 Linux 服务器上持续运行 Flask 项目。第一种方法是使用进程管理工具（如 Supervisor 或 Systemd），第二种方法是使用 nohup 命令。下面将以 Ubuntu 22.04 系统为例，逐一介绍这两种方法。
方法一：使用 Systemd 步骤一：创建服务文件
使用 nano 或其他编辑器，在 /etc/systemd/system/ 目录下创建一个新的服务文件，例如 www.service
步骤二：编辑服务文件
在 www.service 服务文件中输入以下内容：
[Unit] Description=www After=network.target [Service] User=root Group=default WorkingDirectory=/root/www/thrive_api ExecStart=/root/www/thrive_api/venv/bin/python3 /root/www/thrive_api/main.py [Install] WantedBy=multi-user.target 命名含义[Unit]这是服务单元的声明部分，用于描述服务和其依赖关系Description描述这个服务的信息，这里是 wwwAfter指定这个服务应该在哪些其他服务之后启动，这里是在网络服务启动之后启动[Service]这是服务相关设置的部分[Unit]这是服务单元的声明部分，用于描述服务和其依赖关系User指定运行服务的用户，这里是 rootGroup指定运行服务的用户组，默认情况下是 defaultWorkingDirectory指定服务的工作目录，这里是 /root/www/thrive_apiExecStart指定要运行的命令，这里是在虚拟环境中执行的 Python3 脚本 /root/www/thrive_api/main.py[Install]这是安装相关设置的部分WantedBy指定在哪些特定的 target（目标）之下安装服务，这里是 multi-user.target，表示在多用户模式下安装请根据您的实际情况修改这些参数。 步骤三：重新加载 Systemd 配置文件
运行以下命令重新加载 Systemd 配置文件：
sudo systemctl daemon-reload 步骤四：启动并启用服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57701ec911603714cf978850c58dc048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838301cb98699a75af394995b7356dc1/" rel="bookmark">
			vue保姆级教程----深入了解 Vue3路由守卫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 鸿蒙专栏：想学鸿蒙的，冲
📢 C语言专栏：想学C语言的，冲
📢 VUE专栏：想学VUE的，冲这里
📢 CSS专栏：想学CSS的，冲这里
📢 Krpano专栏：想学VUE的，冲这里
🔔 上述专栏，都在不定期持续更新中！！！！！！！！！！！！！
目录
✨ 前言
全局前置守卫
全局解析守卫
全局后置钩子
路由独享守卫
组件内守卫
完整的导航解析流程
实现原理
🔔 实现机制
🔔 全局守卫
🔔 组件内守卫
🔔 next 函数
🔔 总结
✨ 结语
✨ 前言 导航守卫是Vue Router中非常重要的一个功能,它可以让我们在路由导航期间进行Hooks操作,比如登录校验、数据预取、页面跳转取消等。合理利用好导航守卫可以大大提高路由的可控性。
本文将首先介绍导航守卫的种类,包括全局守卫、独享守卫、组件内守卫。然后结合代码示例详细探讨每个守卫的使用场景和方法。
此外,文中还会剖析导航守卫的内部实现原理,了解其工作流程和 Hooks 调用顺序。守卫函数其实是基于路由系统内部的 Navigation Guards 系统实现的。通过分析其机制,可以更深入理解守卫的运行规则。
最后,本文将给出一些实战技巧,帮助开发者思考在什么场景下使用哪种类型的导航守卫,以提高实际项目中的开发效率。
如果你想深入理解导航守卫,或者想在Vue项目中合理利用它们加强路由控制,本文将是一个很好的学习参考。结合示例代码可以快速上手应用。让我们开始探索导航守卫的世界吧!
全局前置守卫 // router.js router.beforeEach((to, from) =&gt; { // ... }) 全局前置守卫在每次路由导航前被调用,常用于登录校验、权限检查等。
全局解析守卫 router.beforeResolve((to, from) =&gt; { // ... }) 在 navigation 被确认之前调用,组件内守卫和异步路由组件被解析之后调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838301cb98699a75af394995b7356dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e0253fdb741c837fb91937fcb749d63/" rel="bookmark">
			【论文阅读笔记】Mip-NeRF 360: Unbounded Anti-Aliased Neural Radiance Fields
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述摘要引言参数化效率歧义性 mip-NeRF场景和光线参数化从粗到细的在线蒸馏基于区间的模型的正则化实现细节实验限制总结：附录退火膨胀采样背景颜色 paper：https://arxiv.org/abs/2111.12077
code：https://github.com/google-research/multinerf
project：https://jonbarron.info/mipnerf360/
概述 MipNeRF360是在NeRF++和MipNeRF的基础上进行的扩展，利用NeRF++提出的远景参数化技巧和MipNeRF的低通滤波思想同时实现了无界场景的高质量渲染与抗锯齿。
摘要 现有方法在新视角合成方面取得了令人影响深刻的结果但是现有方案由于附近和远处物体的细节和比例不平衡导致模糊和低分辨率渲染提出了基于mipnerf的扩展：场景参数化、在线蒸馏和一种失真正则化来克服抗锯齿和无界场景渲染目标场景是相机围绕一个点旋转360度的场景，同时能够得到较低的误差和更好的渲染质量、更详细的深度图 引言 NeRF（Neural Radiance Fields）使用沿着射线的无穷小3D点来建模多层感知机（MLP）的输入，这种建模方式在渲染不同分辨率的视图时可能会导致混叠现象MipNeRF沿着截椎体进行推断，提高了质量但和NeRF一样都在渲染无界场景的时候遇到困难现有方法在处理无界场景的问题 参数化：无界的360度场景可以占据一个任意大的欧几里德空间区域，但mip-NeRF要求3D场景坐标位于有界域内。效率：大型和详细的场景需要更多的网络容量，但在训练过程中沿着每条射线密集查询大型MLP是昂贵的。歧义性：无界场景的内容可能位于任意距离，并且只有少数射线观察到，加剧了从2D图像重建3D内容的固有歧义性 参数化 NeRF 成功的一个方面是它将特定场景类型与其适当的 3D 参数化配对，比如mask场景可直接在3D欧式空间进行参数化场景；对于前置场景，NeRF使用投影空间中定义的坐标(归一化设备坐标，或“NDC”）。通过将无限深的相机视锥体变形为有界的立方体，其中沿着z轴的距离对应视差（逆距离），NDC有效地重新分配了NeRF MLP的容量，以与透视投影的几何形状一致。NeRF++ 使用一个额外的网络来模拟远处的对象；DONeRF 提出了一种空间扭曲过程，以将远处的点缩小到原点 效率 随着场景的变大，MLP的容量也需要变大吗，带来了时间复杂度的增长NeRF使用两个网络分别表达粗采样和细采样，但是粗采样对于最终图像没有贡献；本文使用了一个小型的proposal MLP和一个较大的NeRF MLP。proposal MLP预测体积密度，用于重新采样提供给NeRF MLP的新间隔，然后渲染图像。proposal MLP生成的权重使用NeRF MLP生成的直方图权重进行监督，而不是输入图像。这使得能够使用一个大型的NeRF MLP，相对较少地进行评估，以及一个小型的提案MLP，进行更多次的评估。因此，整个模型的总容量比mip-NeRF的容量大得多（约15倍），从而显著提高了渲染质量，但我们的训练时间仅略有增加（约2倍）。两个MLP同时训练，被称为在线蒸馏。NeRV使用类似的建模可见性和光照，DONeRF使用深度图监督，TermiNeRF使用类似方案加速了推理，但减慢了训练几项工作尝试将训练好的NeRF**压缩或“烘焙”**成一个可以快速渲染的格式[KiloNeRF等]，但没有加速训练过程。在渲染领域，通过使用层次化数据结构（如八叉树或包围体层次结构）来加速光线追踪的思想已经得到了广泛探索，但这些方法假设对场景的几何形状有先验知识，因此无法自然地推广到逆向渲染的情景中，其中场景的几何形状是未知的，需要进行恢复。事实上，尽管在优化类似NeRF模型时构建了八叉树加速结构，但神经稀疏体素场方法并没有显著减少训练时间。 歧义性 无限系列的nerf可以解释输入图像，但只有一个小子集为新视图产生可接受的结果。(参见nerf++)例如，一个NeRF可以通过将每个图像重新构建为其相应相机前方的纹理平面来重新创建所有输入图像原始的NeRF论文通过在NeRF MLP的密度头部在整流器之前注入高斯噪声来正则化模糊的场景这样可以使密度趋向于零或无穷大。尽管通过抑制半透明密度减少了一些"浮游物"，但我们将展示这对于我们更具挑战性的任务是不够的。其他的NeRF正则化方法也已经被提出，比如对密度的鲁棒损失或对表面的平滑惩罚[UNISURF,NeRFactor]，但这些解决方案解决的问题与我们的不同（渲染缓慢和非平滑表面）。此外，这些正则化方法是针对NeRF使用的点采样设计的，而我们的方法是为每个mip-NeRF射线上定义的连续权重而设计的。 mip-NeRF 使用位置集成编码对沿射线方向的圆锥台区间计算位置编码的均值和方差
γ ( μ , Σ ) = { [ sin ⁡ ( 2 ℓ μ ) exp ⁡ ( − 2 2 ℓ − 1 diag ⁡ ( Σ ) ) cos ⁡ ( 2 ℓ μ ) exp ⁡ ( − 2 2 ℓ − 1 diag ⁡ ( Σ ) ) ] } ℓ = 0 L − 1 \gamma(\boldsymbol{\mu}, \boldsymbol{\Sigma})=\left\{\left[\begin{array}{l} \sin \left(2^{\ell} \boldsymbol{\mu}\right) \exp \left(-2^{2 \ell-1} \operatorname{diag}(\boldsymbol{\Sigma})\right) \\ \cos \left(2^{\ell} \boldsymbol{\mu}\right) \exp \left(-2^{2 \ell-1} \operatorname{diag}(\boldsymbol{\Sigma})\right) \end{array}\right]\right\}_{\ell=0}^{L-1} γ(μ,Σ)={[sin(2ℓμ)exp(−22ℓ−1diag(Σ))cos(2ℓμ)exp(−22ℓ−1diag(Σ))​]}ℓ=0L−1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e0253fdb741c837fb91937fcb749d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e774f067b2e906a8360551c5f15e687d/" rel="bookmark">
			VScode安装ESP开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VScode安装ESP开发环境 ESP-IDF 是乐鑫官方的物联网开发框架，适用于 ESP32、ESP32-S、ESP32-C 和 ESP32-H 系列 SoC。它基于 C/C++ 语言提供了一个自给自足的 SDK，方便用户在这些平台上开发通用应用程序，并集成了大量的软件组件，包括 RTOS、外设驱动程序、网络栈、多种协议实现技术以及常见应用程序的使用助手。
若您此前没有接触过 ESP-IDF，可点击以下链接了解 ESP-IDF 的功能特性：
VS Code ESP-IDF IDE 快速入门
ESP-IDF 插件使用教程
目前 ESP-IDF 支持 Eclipse 和 VS Code 等 IDE，能够简化开发人员安装和使用过程。
教程视频
vscode安装ESP-IDF教程
搭建步骤 1.在安装 ESP-IDF VS Code 插件前，需要确保您的电脑上已经下载并安装了 VS Code。
在 VS Code 界面左侧的扩展（插件市场）中搜索“esp idf”，在列表中找到“Espressif IDF” 并点击安装。
安装完成后，按下 F1 或 Ctrl+Shift+P 打开命令行，输入 esp-idf extension，并点击“配置 ESP-IDF 插件”。
接下来，在配置界面选择全局的快速安装模式，此模式无需多余的配置，能够快速简洁的完成安装。设置完成后，点击 “EXPRESS”。
为避免在安装过程中出现无法访问 Github 的情况导致安装失败，需要将服务器设置为 Espressif，并勾选下方的“ 所有 IDF tag 版本”，接着在“选择 ESP-IDF 版本”中选择以 v 开头的则为 TAG 版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e774f067b2e906a8360551c5f15e687d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b58a88031bb39912a666dce8eba9e9/" rel="bookmark">
			ubuntu 安装显卡驱动黑屏，自带屏幕和外接屏只能使用一个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象:
1、ubuntu 系统，自带的屏幕和外接显示屏幕只能使用一个。
2、xrandr 命令 只能识别一个屏幕设备
按网上说法安装显卡驱动后自带屏幕黑屏。
安装显卡驱动后，nvidia-smi 驱动显示正常。
如果进行一下操作：
cd /etc/X11 sudo rm xorg.conf sudo cp xorg.conf.nvidia-xconfig-original xorg.conf 则自带屏正常使用，外接屏无法识别。
以上说明设备有冲突，与驱动无关，应该到 bios 下设置。
例如我的是DELL， 开机F2 进入，在display 那里设置将混显模式改为独显模式，重启OK。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9a43dde529d431b133dcc12c1b30cb/" rel="bookmark">
			使用 Swagger 导入 Postman: 最佳实践与步骤解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swagger和 Postman 都是常用的 API 测试工具，都有各自的优势。为了结合两者的优点，我们可以考虑将 Swagger 中的 API 定义导入到 Postman 中去，这样就可以利用 Postman 更强大的测试功能来测试 Swagger 定义的接口。
下面将以 Swagger Petstore 开源项目为例，介绍如何将 Swagger 导入到 Postman 中，以便后续进行更可观的接口测试。
导出 JSON 文件 Swagger Petstore 开源项目，点击 swagger.json 文件，鼠标右键，将其存到电脑本地，如下图所示，这会下载一个 JSON 格式的文件。
导入 Postman 打开 Postman 应用，选择一个集合空间，点击导入按钮，将文件上传。
将刚才下载的 OpenAPI 规范 文件（JSON 文件）上传或输入文件链接地址。 Postman 会自动解析该文件并生成相应的请求集合和环境，检查导入的请求是否正确，可以对请求进行必要的修改。
这样就可以直接在 Postman 中发送这些 API 请求了。
如果 Swagger 文档有更新，也可以重新导出 OpenAPI 文件并导入到 Postman 来更新。主要利用 Postman 支持导入 OpenAPI 规范 的功能，直接读取 Swagger 导出的文件，这样可以快速地将 Swagger 中的接口导入到 Postman 进行测试。
如果你需要全中文工具 Postman 有时候打开会非常慢，而且是全英文的，或许你可以试试 Apifox。Postman 有的功能它都有，它还免费的，支持中英文，简直完美。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc9a43dde529d431b133dcc12c1b30cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1db7ebf09fd9b698360e8e7a301705/" rel="bookmark">
			Java编程中的IO模型详解：BIO，NIO，AIO的区别与实际应用场景分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO模型 IO模型就是说用什么样的通道进行数据的发送和接收，Java 共支持3种网络编程IO 模式：BIO,NIO,AIO
BIO(Blocking lO) 同步阻塞模型， 一个客户端连接对应一个处理线程
代码示例：
package com.tuling.bio; import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class SocketServer { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(9000); while (true) { System.out.println("等待连接。。"); //阻塞方法 Socket clientSocket = serverSocket.accept(); System.out.println(" 有客户端连接了。。"); handler(clientSocket); /*new Thread(new Runnable() { @Override public void run() { try { handler(clientSocket); } catch (IOException e) { e.printStackTrace(); } } }).start();*/ } } private static void handler(Socket clientSocket) throws IOException { byte[] bytes = new byte[1024]; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1db7ebf09fd9b698360e8e7a301705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3437a9555b93f7274ee6453f0d0297a7/" rel="bookmark">
			【LeetCode】150. 逆波兰表达式求值(ASCII码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日学习的文章链接和视频链接 leetcode题目地址：150. 逆波兰表达式求值
代码随想录题解地址：代码随想录
题目简介 即将后缀表达式转换成中缀表达式并计算。
给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。
请你计算该表达式。返回一个表示表达式值的整数。
看到题目的第一想法(可以贴代码） 1. 逆波兰表达式主要有以下两个优点：
去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 public int evalRPN(String[] tokens) { Stack&lt;String&gt; st = new Stack&lt;&gt;(); for (String i : tokens){ if (i.charAt(0)&gt;=48 &amp;&amp; i.charAt(0)&lt;=57 || i.charAt(0)=='-' &amp;&amp; i.length() != 1){ st.push(i); }else if (i.charAt(0)=='+'){ int num1 = Integer.parseInt(st.pop()); int num2 = Integer.parseInt(st.pop()); int sum = num1 + num2; st.push(Integer.toString(sum)); }else if (i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3437a9555b93f7274ee6453f0d0297a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5dae69340b4cf661adfbe280f33531a/" rel="bookmark">
			血细胞图像检测Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% 预处理
clc;clear;close all;
%%主程序包含三个函数，分别是XingTaiXue、DongTai_OTSU、Hough，
%%分别对应了三种细胞计数与面积计算方法
I = imread('Orig_Cell.JPG');
%% 在原图画框，展示三种算法结果。
counts=1;%第几次裁剪细胞图像
while(1)
%原图裁剪
figure('Name','请拖动鼠标左键选择裁剪区域，并双击鼠标左键确定'),imshow(I);
fprintf(['\n%%%%%%%%%%%%%%%%%%%%%% 我是分割线，这是你第%d次裁剪细胞 ' ...
'%%%%%%%%%%%%%%%%%%%%%\n'],counts);
counts=counts+1;
% 定义裁剪区域
Xcropped = imcrop([I]); %加中括号的目的是不在CommendWindow显示裁剪矩阵
subplot(221); imshow(Xcropped); title('裁剪原图');
% 形态学处理
subplot(222); imshow(Xcropped); title('形态学处理'); hold on
[XingTai,Num_XingTai,Area_XingTai] = XingTaiXue(Xcropped,1);
%动态阈值处理
M=256;
Xcropped = Xcropped(:,:,1);
subplot(223); imshow(Xcropped); title('动态阈值（OTSU）'); hold on
[YuZhi,Num_Yuzhi,Area_YuZhi] = DongTai_OTSU(Xcropped,M,1);
% 霍夫圆变换处理
subplot(224); imshow(Xcropped); title('霍夫圆变换'); hold on
%为了让霍夫圆在原图圈出
[HuoFu,Num_Hough,Average_Hough_area] = Hough(Xcropped,1);
%% 血细胞计数与面积计算
fprintf('\n基于形态学的细胞个数统计：%d个\n',Num_XingTai);
fprintf('基于形态学的细胞平均面积计算：%2.2f(pixels)\n',Area_XingTai);
fprintf('\n基于OTSU动态阈值分割的细胞个数统计：%d个\n',Num_Yuzhi);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5dae69340b4cf661adfbe280f33531a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357e0c3e317fc777aea912feed1ce234/" rel="bookmark">
			矩阵式键盘按键值的数码管显示实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;reg51.h&gt; //包含51单片机寄存器定义的头文件
sbit P14=P1^4; //将P14位定义为P1.4引脚
sbit P15=P1^5; //将P15位定义为P1.5引脚
sbit P16=P1^6; //将P16位定义为P1.6引脚
sbit P17=P1^7; //将P17位定义为P1.7引脚
unsigned char code Tab[ ]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90}; //数字0~9的段码
unsigned char keyval; //定义变量储存按键值
/**************************************************************
函数功能：数码管动态扫描延时
**************************************************************/
void led_delay(void) {
unsigned char j;
for(j=0;j&lt;200;j++)
;
}
/**************************************************************
函数功能：按键值的数码管显示子程序
**************************************************************/
void display(unsigned char k)
{
P2=0xbf; //点亮数码管DS6
P0=Tab[k/10]; //显示十位 led_delay(); //动态扫描延时 P2=0x7f; //点亮数码管DS7
P0=Tab[k%10]; //显示个位 led_delay(); //动态扫描延时 }
/**************************************************************
函数功能：软件延时子程序
**************************************************************/
void delay20ms(void) {
unsigned char i,j;
for(i=0;i&lt;100;i++)
for(j=0;j&lt;60;j++)
;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/357e0c3e317fc777aea912feed1ce234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1c16552be217d14c0e33fa82b61de5/" rel="bookmark">
			数据挖掘总结(考试版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘总结： 第一章： 数据挖掘KDD步骤：
数据清理: (消除噪声和删除不一致的数据)数据集成（多种数据源可以组合在一起）数据选择（从数据库中提取与分析任务相关的数据）数据变换（数据变换或统一成适合挖掘的形式)数据挖掘（核心步骤，使用智能方法提取数据模式）模式评估（根据某种兴趣度量识别提供知识的真正有趣的模式）知识表示（使用可视化和知识表示技术，向用户提供挖掘的知识） ​ 数据仓库(数据立方体)：是一个从多个数据源收集的信息存储库，存放在一致的模式下，并且通常驻留在单个站点上。
文本数据库的分类：
无结构类型、半结构类型、结构类型 研究任务：
关联规则，分类回归，聚类，离群点分析 数据库系统研究关注为单位和最终用户创建、维护和使用数据库。
数据仓库集成来自多种数据源和各个时间段的数据。
第二章： 数据集由数据对象组成。数据行对应数据对象,列对应属性。 属性：
标称属性 ：属性值是一些符号或者事物的名称，属于哪一类二元属性 ：只有两个状态例如：是或者不是，有或者没有序数属性：其可能的值之间具有有意义的序或者秩评定，例如评定等级数值属性：:定量的且用具体数值表示 对于数据的描述信息：
中心趋势度量
均值、中位数、众数、中列数 数据的散布
极差、四分位数极差、五数概括、盒图、变异系数 数据可视化
分位数图、分位数-分位数图、直方图、散点图、词云图 数据度量：
相似性、相异性、邻近性 空间距离：
曼哈顿距离、欧氏距离、切比雪夫距离、切比雪夫距离、绝对值距离，闵考夫斯基距离 数据规整：
数据归一化、数据标准化 from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import MinMaxScaler 第三章： 数据预处理：
数据清理
填充缺失值，识别/去除离群点，光滑噪音，并纠正数据中的不一致 数据集成：
多个数据库，数据立方体或文件的集成 数据规约：
得到数据的归约表示，它小得多，但产生相同或类似的分析结果：维度规约、数值
规约、数据压缩
缺失值处理，离散点处理
重复值处理、相关性分析
主要成分分析(PCA降维)，奇异值分解
第四章： 数据仓库：
​ 数据仓库是一个面向主题的、集成的、随时间而变化的、不容易丢失的数据集合，支持管理部门的决策过程
数据仓库特征：面向主题、数据集成、随时间而变化、数据不易丢失
数据库的主要任务：联机事务处理(OLTP)和增删改查(CURD).
数据仓库的主要任务:联机分析处理(OLAP),数据分析和决策支持.
数据仓库的三层架构：
底层：数据仓库的数据库服务器中间层：OLAP服务器前端客户工具层 OLAP的优点：
数据展现方式
​ 基于多维模型的数据组织让数据的展示更加直观，可以从多个角度多个层面去发现事物的不同特性，而OLAP正是将这种寻常的思维模型应用到了数据分析上。
查询效率
​ 多维模型的建立是基于对OLAP操作的优化基础上的，比如基于各个维的索引、对于一些常用查询所建的视图等，这些优化使得对百万千万甚至上亿数量级的运算变得得心应手。
分析的灵活性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1c16552be217d14c0e33fa82b61de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4a2c7d23910535ca8fab7ed90b920e/" rel="bookmark">
			linux安装jdk环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Linux上安装JDK环境，可以按照以下步骤进行操作：
打开终端并以root用户身份登录。
使用以下命令更新系统软件包列表：
sudo apt update 安装Java运行时环境（JRE）： sudo apt install default-jre 安装Java开发工具包（JDK）： sudo apt install default-jdk 验证JDK安装是否成功： java -version 下载所需的JDK版本。可以从Oracle官网下载最新版本的JDK，也可以选择OpenJDK等其他版本。
解压下载的JDK安装包到指定目录，例如’/usr/lib/jvm’：
sudo mkdir /usr/lib/jvm sudo tar -xf [下载的JDK安装包].tar.gz -C /usr/lib/jvm/ 设置JAVA_HOME环境变量。编辑 /etc/profile 文件并添加以下行： export JAVA_HOME=/usr/lib/jvm/[JDK目录名] export PATH=$PATH:$JAVA_HOME/bin 使环境变量生效： source /etc/profile 验证JDK安装是否成功： java -version 以上就是在Linux上安装JDK环境的步骤。根据不同的Linux发行版和版本，可能会有一些细微的差异，但大致步骤是相似的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c24f8fe911796d95e94d28c210e400b/" rel="bookmark">
			vue中provide和inject使用的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue.js中，provide 和 inject 是用于父组件向子组件传递数据的高级选项。它们通常用于跨层级组件之间的通信，而不需要通过中间组件进行 props 或事件的传递。
provide 选项： provide 选项用于在父组件中声明需要传递给后代组件的数据。
// ParentComponent.vue export default { provide() { return { message: 'Hello from ParentComponent', // 可以提供任何类型的数据，包括函数或对象 greet: () =&gt; { console.log('Greetings from ParentComponent'); } }; }, // ... }; inject 选项： inject 选项用于在子组件中注入父组件提供的数据。
// ChildComponent.vue export default { inject: ['message', 'greet'], // 指定需要注入的属性名称 mounted() { console.log(this.message); // 输出 'Hello from ParentComponent' this.greet(); // 调用父组件提供的函数 }, // ... }; 在上述示例中，provide 方法返回一个对象，该对象的属性和方法会被传递给所有的子组件。在 inject 选项中，通过指定需要注入的属性名称，子组件可以访问这些属性和方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c24f8fe911796d95e94d28c210e400b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b05725628b3eb5f83f96661d604067/" rel="bookmark">
			求帮选校招Offer：中国建设银行、中德住房储蓄银行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普九天坑能动专业本科生秋招总结
华为14A还是保研华中科技大学
数据分析秋招回顾-Day7: 统计学(Part 2)
offer还愿 社招面经 数据科学+算法
美团商分校招生面试经验分享～
女朋友，驾照，六级
签了三方offer全都来了
华为上海青浦，有什么人才扶持政策吗？
【面经大全】实习&amp;提前批&amp;秋招 -&gt; 353个面经OC记录
跌宕起伏的2023结束了，期待2024
【回暖分析】战绩结算 on 赛文X
应届生请不要投冠宇电池，珠海冠宇电池
春招提前批启动！产品运营市场大类岗位1.3已更新
海思和理想同时开了
计算机专业国企大汇总（收藏）
郑州乐精灵教育面经
题解 | #N皇后问题#
class Solution: def Nqueen(self, n: int) -&gt; int: corrs = [] 专利审查和南方电网
南方电网十几号才面试，现在收到了专利审查中心广州局要不要签啊，违约金好像特别高。求指教[牛泪]
题解 | #按之字形顺序打印二叉树#
利用队列思想 + 二叉树的层次遍历。package mainimport . "nc_tools"/* * type TreeNode st
题解 | #提取博客URL中的用户名#
语法：substring_index(string,sep,num)，即substring_index(字符串,分隔符,序号)参数说明：string：用于截取目
题解 | #平均工资#
select avg(salary)from salarieswhereto_date = '9999-01-01' and salary != (
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b05725628b3eb5f83f96661d604067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d37841f3c88ace1abdd4b47a037a0f9/" rel="bookmark">
			Apache Camel笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Camel笔记 1. Apache Camel概念 Apache Camel是一个轻量级的应用集成开发框架，专注于简化集成应用的开发。它基于Enterprise Integration Patterns（企业集成模式，简称EIP）的设计理念，提供了灵活的路由和中介机制，用于解决不同应用系统之间的消息传输问题。 Apache Camel的主要特点如下： 使用基于SEDA处理模型的高度可伸缩的企业服务器。 支持REST API。 强大的基于EIP模式的事件路由机制。 动态、声明性的、基于内容和基于规则的路由选项。 易扩展。 可以结合Spring boot使用。 Apache Camel提供多种领域语言来定义路由规则，包括基于Java的Fluent API、Spring或者Blueprint XML配置文件、Scala DSL等。用户可以通过IDE或者Java、Scala或者XML编辑器获得智能化路由规则补全功能。 Apache Camel的使用场景包括： 消息汇聚：例如，有来自不同服务器的消息，有ActiveMQ、RabbitMQ、WebService等，想把它们都存储到日志文件中，可以通过Apache Camel定义路由规则实现。 接口对接：例如，接口报文转换，比如json格式/内容；协议转换，比如不同协议的接口适配；数据对接，比如ETL数据清洗等。在应用架构中通常用于和外部系统进行集成对接。特别适合在大的金融行业、电信行业等系统特别复杂的场景下做系统对接集成工作。对于小型的应用集成项目很难体现出Apache Camel的应用优势，可以根据自身的业务应用需求来灵活选择。 2. endpoints 端点定义 从哪个端点来, 到哪个端点去
支持http、file、kafka、mq 等消息端点类型：
（1）file:directoryName 官方手册链接
（2）http:hostname[:port][/resourceUri][?options] , 例如：http://127.0.0.1:8080/order?orderId=123 官方手册链接
（3）sftp:host:port/directoryName 官方手册链接
（4）kafka:topic[?options] 例如：kafka:my_topic?headerFilterStrategy=#myStrategy 官方手册链接
// java dsl 方式定义 RouteBuilder builder = new RouteBuilder() { public void configure() { String endpoint1 = "sftp:localhost:8081/folder/test.json"; // 端点1：请求到sftp服务器, 获取文件test.json String endpoint2 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d37841f3c88ace1abdd4b47a037a0f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c434be8e20772c5390ab1cab88bb4c7/" rel="bookmark">
			Yuv420sp格式转成JPEG的原理以及代码实现过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，JPEG格式介绍以及存储方式介绍
JPEG（Joint Photographic Experts Group）是一种用于连续色调静态图像压缩的标准，也被称为联合图像专家组。它是一种常用的图像存储格式，文件后缀名为.jpg或.jpeg。JPEG采用预测编码（DPCM）、离散余弦变换（DCT）以及熵编码的联合编码方式，以去除冗余的图像和彩色数据，属于有损压缩格式。
JPEG的优点在于能够将图像压缩在很小的储存空间，同时用有损压缩方式去除冗余的图像数据，用较少的磁盘空间得到较好的图像品质。一幅16M（24位）的.jpg/.jpeg图像看上去与照片没有多大差别，非专业人士甚至无法分辨。同样一幅画面，用.jpg/.jpeg格式储存的文件是其他类型图形文件的1/10～1/20。一般情况下，.jpg/*.jpeg文件只有几十KB，而色彩数最高可达到24位。
此外，JPEG格式可以分为标准JPEG、渐进式JPEG和JPEG2000三种格式。标准JPEG在网络上应用较多，只有图片完全被加载和读取完毕之后，才能看到图片的全貌；它是一种很灵活的图片压缩方式，用户可以在压缩比和图片品质之间进行权衡。不过，通常来讲，其压缩比在10:1到40:1之间，压缩比越大，品质就越差，压缩比越小，品质就越好。
以上内容仅供参考，如需更多信息，建议访问信息技术论坛或咨询专业信息技术人员。
2，JPEG压缩编码的过程
JPEG压缩编码的过程主要分为以下步骤：
正向离散余弦变换（FDCT）：这一步将图像从空间域表示变换到频率域表示。通过离散余弦变换，图像的高频部分（图像细节）和低频部分被分离出来。
量化（Quantization）：在这一步，使用加权函数对DCT系数进行量化，这个加权函数对于人的视觉系统是最佳的。量化是JPEG压缩中的关键步骤，它去除了一些人眼无法察觉的图像细节，从而大大减小了图像数据量。
Z字形编码（Zigzag Scan）：此步骤将量化后的频率系数按照Z字形的扫描路径重新排序，以便于后续的编码。
差分脉冲编码调制（DPCM）：对于直流系数（DC）使用差分脉冲编码调制进行编码，这进一步减少了图像数据的数量。
行程长度编码（RLE）：对于交流系数（AC）使用行程长度编码进行编码。RLE是一种简单的编码方式，它统计连续相同符号的数目，然后使用较短的代码来表示连续的符号。
解压缩或解码的过程与压缩编码过程相反，首先是解码RLE和DPCM编码的数据，然后逆Z字形扫描，逆量化，最后逆DCT，从而恢复原始的图像数据。
3，yuv420sp格式转换成JPEG格式的原理说明
YUV420SP格式转换为JPEG格式的过程涉及到图像的编码和解码。YUV420SP是一种颜色编码方式，它将图像的亮度和色度分离，以减少对存储空间和带宽的需求。JPEG是一种压缩图像格式，它使用离散余弦变换（DCT）将图像编码为频域系数。
在将YUV420SP转换为JPEG的过程中，首先需要将YUV格式的图像转换为RGB格式的图像。这是因为JPEG压缩算法是基于RGB颜色空间的。这一步可以通过颜色空间转换公式实现，即将Y、U、V分量分别进行线性变换，得到R、G、B分量。
接下来，将RGB格式的图像进行JPEG压缩编码。JPEG压缩算法包括离散余弦变换、量化、熵编码等步骤。在这一步中，首先对RGB图像进行离散余弦变换，将其从空域变换到频域。然后，对变换后的系数进行量化，去除人眼不敏感的细节和冗余信息，进一步压缩数据。最后，使用熵编码技术对量化后的系数进行压缩编码，生成JPEG格式的图像。
需要注意的是，由于YUV420SP格式的UV分量是交错存放的，因此在转换过程中需要特别处理。具体来说，可以先将U、V分量分别提取出来，进行适当的调整和转换，然后再与Y分量合并，形成完整的RGB图像。
总之，YUV420SP转换为JPEG的过程涉及到图像的编码和解码，包括颜色空间转换和JPEG压缩编码等步骤。这一过程可以有效地减小图像文件大小，同时保持较好的图像品质。
4，yuv420sp转JPEG的步骤
将YUV420SP格式转换为JPEG格式的步骤如下：
1，读取YUV420SP格式的图像数据。
2， 将YUV420SP格式的图像数据转换为RGB格式的图像数据。这一步可以通过颜色空间转换公式实现，即将Y、U、V分量分别进行线性变换，得到R、G、B分量。
3，对RGB格式的图像数据进行JPEG压缩编码。这一步包括离散余弦变换、量化、熵编码等步骤。具体来说，首先对RGB图像进行离散余弦变换，将其从空域变换到频域。然后，对变换后的系数进行量化，去除人眼不敏感的细节和冗余信息，进一步压缩数据。最后，使用熵编码技术对量化后的系数进行压缩编码，生成JPEG格式的图像数据。
4， 将生成的JPEG格式的图像数据保存为文件。
需要注意的是，由于YUV420SP格式的UV分量是交错存放的，因此在转换过程中需要特别处理。具体来说，可以先将U、V分量分别提取出来，进行适当的调整和转换，然后再与Y分量合并，形成完整的RGB图像。
另外，为了减少数据量，通常需要进行压缩。在JPEG压缩编码过程中，可以采用多种方法进行优化，例如调整量化表、选择不同的压缩质量参数等。这些方法可以在保证图像质量的同时，进一步减小图像文件的大小。
总之，将YUV420SP格式转换为JPEG格式需要经过颜色空间转换和JPEG压缩编码等步骤。在转换过程中需要注意YUV420SP格式的特点和处理方法，以及JPEG压缩编码的优化方法。
5，yuv420sp格式转成JPEG的代码实现过程
YUV420SP格式转JPEG格式的C代码实现过程可以分为以下几个步骤：
1，包含必要的头文件：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;jpeglib.h&gt; 2，定义转换函数：
void convert_yuv420sp_to_jpeg(const uint8_t* yuv420sp, size_t width, size_t height, const char* output_file) { struct jpeg_compress_struct cinfo; struct jpeg_error_mgr jerr; FILE* outfile; JSAMPROW row_pointer[1]; int row_stride; cinfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c434be8e20772c5390ab1cab88bb4c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4495fa3d132ccea7d93a7efcd8e1b0a4/" rel="bookmark">
			【金猿CIO展】三亚科技投资集团总经理兼CIO徐斌：“三亚放心游”旅游大数据助力三亚旅游监管能力提升...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍
徐斌
本文由三亚科技投资集团总经理兼CIO徐斌撰写并投递参与“数据猿年度金猿策划活动——2023大数据产业年度优秀CIO榜单及奖项”评选。
大数据产业创新服务媒体
——聚焦数据 · 改变商业
在数字化飞速发展的今天，大数据已经成为企业决策、创新和竞争优势的关键因素。作为公司的首席信息官，我深知大数据在2023年为我们的业务带来的巨大价值和成果。本文将围绕大数据在我们公司的应用、对大数据产业的未来看法以及如何结合“小趋势·大未来”这一主题展开。
三亚科技投资集团有限公司2019年7月成立，是按照市委市政府国资改革的要求，由国资系统科技企业整合而成的三亚六大国有产业投资集团之一。集团以科技产业投资服务商为定位;以数字城市建设、科技投资和科技服务等为主要业务方向;以成为三亚信息化建设、运营、维护和研发的龙头企业，成为海南数字城市和自由贸易港建设、智慧旅游产品和物联网与人工智能的领军企业，成为全国信息化系统研发运营服务的品牌企业为目标愿景;面向自由贸易区(港)建设，努力打造服务于地方政府和科技创新智慧之城的载体。
大数据在2023年的价值体现与作用
在2023年，大数据已经成为我们科投集团内部运营和决策的核心。从运营数字城市、提高城市管理智能化、自动化水平、提升城市现代化治理水平，大数据都在其中发挥着至关重要的作用。
首先，大数据的实时处理能力使得数字城市能够更加高效地应对各种突发事件。通过对大量数据的分析，可以提前预测事件的发展趋势，有助于及时采取有效的应对措施。
其次，大数据的智能化分析能够提升城市管理的自动化水平。例如，通过分析城市交通流量数据，可以自动调整交通信号灯的运行逻辑，有效缓解交通拥堵问题。同时，大数据也可以用于智能化的城市规划，例如基于人口流动数据规划商业区的布局。
此外，大数据还有助于提升城市现代化治理水平。政府机构可以通过大数据分析来更好地了解市民的需求和诉求，从而制定出更加科学、合理的政策。同时，大数据也可以用于公共服务的优化，例如通过分析公共设施的使用数据来合理分配资源。
具体来说，在2023年我们通过大数据分析实现了以下成果：
三亚放心游
今年三亚科技投资集团推出了“三亚放心游”这一旅游城市信用品牌。简单来说，就是当游客在三亚涉旅商家消费，发生了不愉快的事情，可以通过“三亚放心游”微信公众号或支付宝小程序在线投诉，提交图片或视频材料，“三亚放心游”平台承诺3分钟响应，30分钟完成预先理赔，三亚市人民政府为此设立了1000万的先行赔付资金池来维护游客权益。目前，“三亚放心游”平台已覆盖三亚全市超过10万家优质涉旅商户。同时在海南省人民政府的支持下，由海南省旅游和文化广电体育厅牵头，于8月25日“三亚放心游”正式升级为“海南放心游”，面向全省近20万家涉旅场所进行游客消费保障，上线以来目前已累计保障游客权益超过30万元。
“三亚放心游”实践的创新在于，在政府信用背书的基础上，将商家信用和游客信用关联进来，形成一个正向的循环，推动诚信旅游的发展。对于普通涉旅投诉，预先赔付资金到游客支付宝或微信钱包后将冻结3天，12345系统核验证据链并依法处置后进行资金解冻，游客实现赔付资金提现，同时“三亚放心游”接入了支付宝芝麻信用数据，对于高信用客群提供小额赔付资金实时到账服务，目前单笔赔付限额1000元，通过“小额直赔”机制进一步改善游客旅游消费体验。
“三亚放心游”的背后是三亚市城市超级大脑项目的底层数字化服务能力，其中旅游监管服务板块涉及游客端的投诉受理、预先赔付，12345执法端的工单派发、证据处理，底层将旅游、市场监管、综合执法等单位数据打通，并通过数据中台、AI中台分析处理，为快速响应游客诉求提供了技术支撑。“三亚放心游”还基于三亚市场监督管理部门的后台电子秤数据，将游客关心的海鲜、水果成交价格进行加权处理，公布各品类海鲜水果实时均价供游客参考。
目前，三亚市以智慧旅游监管服务平台为抓手，实现了旅游行业全要素的“一网融合”、涉旅事件处置的“一屏指挥”、涉旅业务跨部门的“一键协同”，在治理理念、治理手段、工作流程等方面突破创新，切实加强三亚旅游市场整治，推动旅游监管方式全面转型升级。
为游客提供更好的服务一直是三亚市锲而不舍追求的目标，三亚市“城市超级大脑”也将继续利用互联网大数据、人工智能和安全体系等能力优势，集成互联网、物联网、大数据、云计算、人工智能等先进技术，成为三亚市数字城市建设的“数字化助手”，不断提高城市管理水平和市民生活质量。
三亚智慧交通
通过多年持续不断的建设，三亚交通信息化建设已初具规模并取得了一定的成效。但是，随着社会、经济的迅猛发展，三亚市亦是定位于国际旅游消费中心、全球自贸服务中心、区域城市服务中心，各种类型的大型活动将会越来越多。存在以下痛点：
路网局限性导致管控复杂：三亚路网“依海就势”，山河阻隔，路线单一，带来通道瓶颈问题。一旦核心路段发生交通事故，整个市区交通受阻。
多交通方式混行引发管理矛盾：存在极为突出的多交通出行方式混行现象，非机动车、行人、机动车间冲突干扰，造成管理焦点多样。
节假日出行带来交通需求激变：三亚作为旅游城市，节假日、旅游旺季来临，外地车辆大量涌入，导致很多路段拥挤不堪，带来很多不可预测的交通难题。
精准到达难：路口信号灯控制不到位，警卫车队不能全程绿波通行，难以准时到达；车辆定位不准，车队整体概貌无法掌握。
减少扰民难：信息发布手段不充分，道路管制时间长，疏散不及时，造成过度扰民。
指挥调度难：勤务岗位点位多，警力不足，岗位职责制定及警力安排难统筹。
通过三亚交通大数据应用分析系统融合分析交通大数据，实现运行态势的实时精准掌控，路面交通一图展示、一键调度，为交通管理者的交通组织、交通秩序、交通安全等全方位管理决策提供科学的数据，提高交通管控能力；
从全时、全域、全要素、全流程细分场景，搭建场景化的指挥平台：分场景抓重点、固化优秀的指挥方法、以数据代替经验决策，降低指挥的难度和门槛，即使面对不同的指挥人员，也能打造无差异的指挥效果。为交警支队以及各大队提供场景化的快速处置方案，通过数据分析支撑指挥决策，覆盖节假日、早晚高峰等场景下的指挥操作，并提供常用分析工具，满足研判需求，确保交通畅通。
对大数据产业的未来看法与期待
随着技术的不断进步和应用领域的拓宽，我认为未来大数据将在以下方面发挥更加重要的作用：
更加智能化和自动化：随着机器学习和人工智能技术的不断发展，大数据分析将更加智能化和自动化。数据驱动的决策将成为常态，而数据本身的复杂性和多样性也将得到更有效的处理和分析。
更加垂直化和专业化：未来的大数据应用将更加聚焦于垂直行业领域。从医疗健康、金融到教育等各个行业，都将充分利用大数据进行业务创新和流程优化。这要求数据分析和处理技术更加专业化和精细化的匹配需求。
更加关注隐私和安全：随着数据价值的提升和数据泄露风险的增加，对数据隐私和安全的保护将更加受到重视。技术手段和管理策略将在保护数据安全的同时实现数据的合理利用和开发。
更加开放和共享：在“小趋势·大未来”这一主题下，我认为未来的大数据将更加注重小而美的数据趋势的挖掘和应用。这些小趋势可能来自于看似微不足道的数据细节，但它们却能揭示出影响未来的大趋势。因此，我期待看到更多的开放数据平台和共享机制的出现，使得更多有价值的数据能够被充分地利用和创新。这将有助于打破数据孤岛，推动数据生态系统的健康发展。
更加跨界融合：未来的大数据将更加注重与其他领域的融合与创新。例如，与物联网、区块链等新兴技术的结合将创造出更多的应用场景和商业模式。这种跨界融合将为大数据产业带来更多的发展机遇和挑战。
更加注重人才培养与教育：随着大数据技术的普及和应用领域的拓宽，对专业人才的需求将不断增长。我期待看到更多的大数据教育和培训项目的发展，以培养出更多具备专业技能和创新精神的大数据人才。这将为大数据产业的持续发展提供强有力的人才保障。
更加可持续性与社会责任：在可持续发展成为全球共识的背景下，大数据将在环境监测、能源管理、公共安全等领域发挥重要作用。企业将更加注重利用大数据实现社会责任目标，推动经济、社会和环境的协调发展。
更加国际合作与交流：随着全球化进程的加速，各国在大数据领域的合作与交流将更加频繁。跨国企业将加强数据资源的共享与整合，共同应对全球性挑战，推动大数据技术的国际应用与发展。
更加关注伦理与合规：在大数据应用过程中，伦理与合规问题将受到更多关注。企业将更加注重数据的公正性、透明度和伦理原则，确保大数据技术的合理运用符合社会伦理道德标准。同时，政府也将加强对数据市场的监管，制定更加完善的法律法规以保障数据安全和隐私权益。
更加普惠与包容性：大数据技术有望为更多领域带来普惠与包容性的发展。无论是在教育、医疗还是金融等领域，大数据都将为弱势群体提供更好的服务和机会，缩小数字鸿沟，促进社会。
·关于徐斌：
徐斌，三亚科技投资集团有限公司总经理兼CIO。
曾任海南省旅游信息技术有限公司董事长、总经理，海南海岛一卡通公司副总裁，海南百成信息技术有限公司副总裁，海南易建科技股份有限公司市场销售部总经理。曾参与海南省政务大数据共享平台建设，主持海南省旅游电子商务交易平台，海南省旅游年卡系统，海南放心游系统，三亚游艇旅游监管服务平台等项目建设。
·关于推荐企业：东方金信
北京东方金信科技股份有限公司成立于2013年2月。公司拥有ISO9001、ISO27001和CMMI5级认证;中国大数据企业50强;首批通过工信部数据中心联盟大数据基础能力和性能双认证;首个国家信息中心“数据资产研究中心”授牌单位;全国信标委智慧城市及大数据标准工作组成员，2017年入选Gartner全球大数据行业和人工智能报告；2019年与腾讯云成为战略合作伙伴并获腾讯数亿元投资；2020年获中金、海淀区国资委入股。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c17df543ec27add8e375f7cc355bdb6/" rel="bookmark">
			入门Python笔记详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是 Python 入门的详细介绍： 1.安装 Python：首先，你需要从 Python 官方网站（https://www.python.org/）下载适用于你的操作系统的 Python 版本，并按照安装向导进行安装。 2.编写第一个 Python 程序：打开任意代码编辑器（如 VS Code）并创建一个新的文件，将其保存为 .py 后缀的文件名。在文件中输入以下代码： print("Hello, World!") 保存文件后，在命令行中运行 python 文件名.py 命令，你将看到输出 Hello, World!。 3.变量和数据类型：Python 是一种动态类型的语言，你不需要显式声明变量的类型。你可以直接使用变量名来存储数据。例如： name = "John" age = 25 Python 支持多种数据类型，包括整数、浮点数、字符串、布尔值等。 4.控制流程：Python 提供了多种控制流程语句，如条件语句（if-elif-else）、循环语句（for、while）等。例如： if age &gt;= 18: print("You are an adult.") else: print("You are a minor.") 5.列表和字典：Python 提供了列表和字典等数据结构来存储和操作多个值。列表是一个有序的集合，可以通过索引访问其中的元素。字典是一种键值对的集合，可以通过键来访问对应的值。例如： fruits = ["apple", "banana", "orange"] person = {"name": "John", "age": 25} 6.函数：函数是一段可重用的代码块，可以接受参数并返回一个值。你可以使用 def 关键字来定义函数。例如： def add(a, b): return a + b result = add(3, 5) print(result) # 输出 8 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c17df543ec27add8e375f7cc355bdb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592d3b7c6fe004ad5679af5a58f958f8/" rel="bookmark">
			新一代爬取JavaScript渲染页面的利器-playwright（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Playwright的使用 Playwright是微软在2020年初开源的一款新一代自动化测试工具，其功能和**Selenium**、Pyppeteer类似，都可以驱动浏览器进行自动化操作，但是也具备了Selenium、Pyppeteer不具备的更好的API，是新一代爬取JavaScrip渲染页面的利器。
1.Playwright的特点 Playwright支持当前所有的主流浏览器，提供完善的自动化控制API。Playwright支持移动端页面测试，使用设备模拟技术，可以在移动web浏览器中测试响应式的web应用程序。Playwright支持所有浏览器的无头模式和非无头模式。Playwright安装配置比较简单，安装过程中会自动安装对应的驱动，无需额外配置WebDriver等。Playwright提供和自动等待相关的API，在页面加载时会自动等待对应的节点加载，大大减少了API编写的复杂度。 2.安装 首先，确保python版本大于或等于3.7。
pip3 install playwright 安装完成后执行初始化操作。
playwright install 这是会自动安装Chromium、Firefox、WebKit浏览器和一些驱动。
3。基本使用 Playwright支持两种编写模式，一种是和Pyppetter一样的异步模式，一种是和Selenium一样的同步模式，可以根据不同的实际需求来进行选择。
# 同步模式 # 调用了sync_playwright方法，该方法返回值是PlaywrightContext,可以理解为浏览器上下文管理器 from playwright.sync_api import sync_playwright with sync_playwright() as p: for browser_type in [p.chromium,p.firefox,p.webkit]: # 不把lauch的headless设置为False，默认为无头浏览器 browser = browser_type.launch(headless=False) # 新建选项卡，返回page对象 page = browser.new_page() page.goto('http://www.baidu.com/') # 截图并定义文件名称 page.screenshot(path=f'screenshot-{browser_type.name}.png') # title方法返回页面标题 print(page.title()) browser.close() 运行上面代码可以看到chromium、firefox、webkit三个浏览器依次启动，启动后加载百度首页，加载完成后生成截图，然后打印页面标题到控制台。
当然，除了同步模式，playwright还提供了支持异步模式的API，如果项目中使用了asyncio关键字，就应该使用异步模式。
import asyncio from playwright.async.api import async_playwright async def main(): async with async_playwright() as p: for browser_type in [p.chromium,p.firefox,p.webkit]: browser = await browser_type.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592d3b7c6fe004ad5679af5a58f958f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86353c410cc938ab1b6355b0c1049fc3/" rel="bookmark">
			新一代爬取JavaScript渲染页面的利器-playwright（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上文：新一代爬取JavaScript渲染页面的利器-playwright（一）
上文我们主要讲了Playwright的特点、安装、基本使用、代码生成的使用以及模拟移动端浏览，这篇我们主要讲下Playwright的选择器以及常见的操作方法。
6.选择器 我们可以把传入的字符串称为Element Selector，除了它已经支持的CSS选择器、XPath，Playwright还为它拓展了一些方便好用的规则，例如直接根据文本内容筛选，根据节点的层级结构筛选等。
文本选择 文本选择支持text=这样的语句进行筛选，例如：
page.click(“text=Log in”)
该句代表点击文本内容是Log in的节点
CSS选择器 例如根据id/class筛选：
page.click(“button”)
page.click(“nav-bar .contact-us-item”)
根据特定的节点属性进行筛选：
page.click(“[data-test-login-button]”)
page.click(“[aria-label=‘Sign in’]”)
CSS选择器+文本值 常用的方法是has-text和text，前者代表节点中包含指定的字符串，后者代表节点中的文本值和指定的字符串完全匹配，示例如下：
page.click(“article:has-text(‘playwright’)”)
page.click(“#nav-bar :text(‘Contact us’)”)
CSS选择器+节点关系 CSS选择器还可以结合文本关系来筛选节点，例如指定另一个选择器，示例如下：
page.click(“.item-description:has(.item-promo-banner)”)
这里选择的就是class为item-description的节点，且该节点还要包含class为item-promo-banner的子节点。
另外还可以结合一些相对位置关系，例如使用right-of指定位于某个节点右侧的节点。
page.click(“input:right-of(:text(‘Username’))”)
这里选择的就是一个input节点，并且该节点要位于Username的节点的右侧。
XPath XPath也是支持的，不过是xpath关键字需要我们自己来指定，示例如下：
page.click(“xpath=//button”)
7.常用操作方法 下面介绍些一些常用的操作方法。例如click(点击)，fill(输入)等等，这些方法都属于page对象，所有方法都可以从page对象的API文档查找。
下面介绍几个常见的操作方法的用法。
事件监听 page对象提供一个on方法，用来监听页面中发生的各个事件，例如close，console，load，request，response等。
这里我们监听response事件，在每次页面请求得到相应的时候会触发这个事件，我们可以设置回调方法来获取响应中的全部信息，示例如下：
from playwright.sync_api import sync_playwright def on_response(response): print(f'State{response.status}:{response.url}') with sync_playwright() as p: browser = p.chromium.launch(headless=False) page = browser.new_page() page.on('response',on_response) page.goto('https://spa6.scrape.center') page.wait_for_load_state('networkidle') browser.close() 可以看到输出结果如下；
我们在创建page对象后，就开始监听response事件，同时将回调方法设置为on_response，其接收一个参数，然后输出响应中的状态码和链接。
如果观察网页请求包内容可以发现，这个输出结果正好对应浏览器network中所有的请求和响应。
这个网站的真实的数据都是Ajax加载的，同时Ajax请求中还带有加密参数，不容易轻易获取。但是有了on_response方法，如果我们想截取Ajax请求，是非常容易的。
from playwright.sync_api import sync_playwright def on_response(response): if '/api/movie' in response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86353c410cc938ab1b6355b0c1049fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cf4d15ccb5df8fdbfec5a5bf1a2b42/" rel="bookmark">
			OpenCV 安装概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 核心团队的软件包 每个版本都会发布使用默认参数和最新编译器构建的适用于 Android、iOS 和 Windows 的包，它们不包含opencv_contrib模块。
GitHub 版本：Releases · opencv/opencv · GitHubSourceForge.net： OpenCV - Browse Files at SourceForge.net 第三方软件包 其他组织和个人维护自己的 OpenCV 二进制发行版。例如：
常用 Linux 发行版中的系统软件包 （https://pkgs.org/search/?q=opencv)PyPI （Search results · PyPI)康达 （Search :: Anaconda.org)柯南 （GitHub - conan-community/conan-opencv: [DEPRECATED] Conan recipes for OpenCV)vcpkg （https://github.com/microsoft/vcpkg/tree/master/ports/opencv)NuGet （NuGet Gallery | Packages matching opencv)冲泡 （opencv — Homebrew Formulae)Maven （Maven Central Repository Search) 从源代码构建 现有的二进制包可能不适用于您的用例，那么您必须自己构建 OpenCV 的自定义版本。本部分简要概述了构建过程，请查看特定平台的教程以获取实际的构建说明。
OpenCV 使用 CMake 构建管理系统进行配置和构建，因此本节主要介绍使用 CMake 构建软件的一般过程。
步骤 0：先决条件 安装 C++ 编译器和生成工具。在 *NIX 平台上，它通常是 GCC/G++ 或 Clang 编译器和 Make 或 Ninja 构建工具。在 Windows 上，它可以是 Visual Studio IDE 或 MinGW-w64 编译器。Android NDK 中提供了适用于 Android 的原生工具链。XCode IDE 用于为 OSX 和 iOS 平台构建软件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30cf4d15ccb5df8fdbfec5a5bf1a2b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/919f411081f64f668db8297222b51812/" rel="bookmark">
			数据中台建设之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据中台是在政企数字化转型过程中，对各业务单元业务与数据的沉淀，构建包括数据技术、数据治理、数据运营等数据建设、管理、使用体系，实现数据赋能。数据中台，是新型信息化应用框架体系中的核心。
1、什么是数据中台 随着企业数字化转型的加速，数据中台的概念逐已为大家所熟知，政企对数据中台的建设需求逐渐加大。
数据中台是对既有/新建信息化系统业务与数据的沉淀，是实现数据赋能新业务、新应用的中间、支撑性平台。
数据中台是在政企数字化转型过程中，对各业务单元业务与数据的沉淀，构建包括数据技术、数据治理、数据运营等数据建设、管理、使用体系，实现数据赋能。数据中台，是新型信息化应用框架体系中的核心。
然而，对于很多人来说，数据中台仍然是一个模糊的概念。
Gartner：数据中台的建设方向应该处于企业数字化平台的核心，即Gartner定义的数据和分析平台，帮助企业的数字化平台（客户体验平台，生态系统平台，物联网平台和内部信息系统）的业务用户做出更好的决策，并在各个数字化平台的合作孵化下形成可复用的数据分析能力。数据分析能力应该在业务端无处不在且高度自助，最终助力数字化平台实现Gartner定义的封装的业务能力 （Packaged Business Capability）。
Alibaba：通过OneModel、OneID、OneService，实现数据的统一，即OneData。其中OneModel统一数据构建及管理，完全消除数据二意性，实现分钟级代码自生成；OneID是将核心商业要素资产化，实现数据的全域连接、标签萃取、立体像；OneService则统一数据服务，以主题式服务输出，简化了数据查询。
星环科技：数据中台让企业高效数据驱动，适配企业主营、创新、孵化业务快速变化，支撑企业数字化转型。通过统一底层架构，统一数据治理，统一数据服务，以及个性化数据应用，最终实现整个企业数据资产化、资产价值化、价值个性化。
因此，不同的厂商，甚至同厂商不同的团队/人对于数据中台的定义/主推方案都难以统一。中台的本质：大数据？数仓？数据湖？数据治理？数据服务？云平台？......
2、数字化转型时代下的数字化管理需求 《“十四五”数字经济发展规划》要求以数据为关键要素，以数字技术与实体经济深度融合为主线，加强数字基础设施建设，完善数字经济治理体系，协同推进数字产业化和产业数字化，赋能传统产业转型升级，培育新产业新业态新模式，不断做强做优做大我国数字经济，为构建数字中国提供有力支撑。
而企业的数字化转型需要一个“数字大脑”的提升，包括存算能力、治理能力、服务能力、个性应用。
这意味着：
需要统一的数据底座 开源大数据混合架构在处理解决不同类型的业务时，需要将数据存放入不同的数据库中，大量数据冗余。烟囱式的开发方式导致了需要通过不同的查询方式获取到对应的数据后再进行处理，开发复杂并且处理效率低下。
需要统一的数据治理 数据治理有4个问题需要解决：有什么数据，数据在哪里，数据从哪来，数据谁在用。缺乏统一的数据治理会导致数据质量低，不具备可用性、一致性、完整性、合规性和安全性。
需要统一的数据服务 每当有一个新的业务需求或者数据使用需求时，开发人员都需要从底层基础数据开始加工，逐层开发，直到最后完成数据服务，整个开发周期长，并且烟囱式的开发方式导致了数据服务无法直接复用。
需要敏捷灵活的个性应用建设能力 新的业务系统建设需要有独立的环境并且获取需要的数据来进行测试与上线，整个环境准备、数据准备、应用开发的建设流程繁复，负责统建的科技部门通常成为资源瓶颈，缺乏统一的应用管理导致应用不具备可复用性。
3、数据中台转型之痛 但是，数据中台如果未经过系统规划，以业务为导向，不同业务选型不同的技术组件和工具，会导致数据中台建设混乱。大部分业务只使用了贴源层，在贴源层上烟囱式建设，造成数据烟囱、工具烟囱、服务烟囱，从而导致开发团队疲于应付各种技术组件的运维，和具体业务的数据模型请求，没有精力做更有价值的工作，如技术提升、共性数据模型抽象、数据服务梳理、应用开发等。
4、数据中台的演进 因此，数据中台的建设一般会历经3个版本的演进之路，从而实现“释放数据生产力，改善数据生产关系”的目标。
数据中台1.0：混合底层架构 + 统一工具层
这是大多数企业，特别是中小型企业下意识、喜欢采用的方式。但这个方式带来的建设成效一般，正如徐志胜所说“年轻人总要走一些弯路，才能到达彼岸!”。
数据中台2.0：统一底层架构，全域数据集成，统一数据底座
在贯穿整个企业的价值链活动中，统一底层架构提升存算效能，统一数据治理构建数据资产，统一数据服务激活数据价值，最终让企业高效数据驱动，支撑企业数字化转型。
数据中台3.0：敏捷应用开发模式，贯穿价值链路，高效数据驱动
基于2.0已经存在的数据底座，建设统一的数据治理构建数据资产，统一数据服务激活数据价值，最终让企业高效数据驱动，适配企业个性化主营、创新、孵化业务等数据应用的快速变化，支撑企业数字化转型。
5、数据中台的建设思路 5.1建设目标 那么，数据中台应该以什么个思路推进建设呢?
建设“统一接入、统一存储、统一治理、统一开发、统一服务”的大数据中台，以实现多源数据的统一归集，业务数据的统一治理，内部和生态应用的统一支撑，同时降低使用门槛，具有服务自助、数据自治、平台自理的能力，实现三个一(一个智能化的分析运营生态、一套常态化的精益治理体系、一个集约化的数据平台底座)为建设目标。
数据中台应集成企业数据治理和管理、数据资产开发和运营并串联和驱动数据共享与服务、数据开发与运维的理念和最佳实践方法，整体功能框架应与企业数据治理体系框架一致，建成后能够对整个数字化管理工作起到良好的技术支撑作用。
5.2建设内容 在数据中台建设内容上，一般包括如下几部分：
大数据基础平台，为整个大数据中台提供分析计算和存储的引擎和工具，是大数据中台的底层功能支撑。提供分布式数据仓库、分布式NoSQL数据库、实时计算、数据检索、数据挖掘等组件。
数据开发治理工具(平台)，提供数据接入、数据开发、数据治理、数据服务、数据管理等组件为大数据中台的开发进行支撑。从而，从数据采集、数据交换、数据存储、数据治理到数据共享与服务，为大数据中台建立起整个数据开发共享体系。
5.2.1大数据基础平台 基于多模型统一技术架构，提供统一的接口层、统一的计算引擎层、统一的分布式存储管理层和统一的资源调度层，在保障不同数据模型高性能、高可靠、高可用的同时，实现了资源配置更灵活、操作运维更简洁易用的目标。
大数据基础平台能够为整个数据中台提供分析计算和存储的引擎和工具，是大数据中台的底层功能支撑。它需要为数据仓库的构建提供高性能、高稳定、高可用的数据库软件，并通过提供离线处理、流处理、全文检索、数据挖掘等组件。
根据平台底层存储设计和平台业务特性分析，建议采用Hadoop生态体系进行大数据基础平台的方案设计。所建设的大数据基础平台需能够以产品组件、引擎或工具的形式满足包括但不限于以下海量数据的大规模处理与分析场景：离线批处理、实时流处理分析、数据并发查询、全文检索、数据挖掘、BI分析、交互式分析等;所建设的大数据基础平台需既能够处理结构化的数据，也能够处理非结构化、半结构化数据，满足配置、日志、网页、音视频、IoT、网络爬虫等多源异构数据的加载和存储;平台需提供完整的多租户功能，对于计算资源与存储资源以及数据访问资源进行统一控制管理，对于计算资源进行高效的调度管理与使用控制，对于存储资源进行配额管理，对于数据访问进行严格的权限管理;平台需提供统一的可视化运维监控界面，对安装、配置、监控、告警方面进行运维管理。
5.2.2数据开发治理工具 数据开发治理平台技术架构是以Docker+Kubernetes为基础，并且采用微服务开发框架，实现数据整合、数据开发、任务调度、数据治理、数据服务、数据商城等可视化操作工具。
5.2.3建设步骤 以星环的数据中台产品为例，可采用如下建设步骤：
1.中台规划
建设统一的数据底座(统一资源管理、统一存储管理、统一计算引擎、统一查询语言)，构建数据集市、数据仓库、数据湖;建设统一的数据治理，构建数据资产;建设统一的数据服务，激活数据价值，最终让企业高效数据驱动，适配企业个性化主营、创新、孵化业务等数据应用的快速变化，支撑企业数字化转型。
2.平台部署
通过云原生操作系统及数据管理平台，统一纳管异构处理器(X86、ARM)、GPU和异构的操作系统(UOS、中标麒麟、银河麒麟)，支持信创、国产化的要求。
通过屏蔽底层技术架构，提供统一的资源层给云产品，只暴露资源的CPU架构，为数据中台的系统提供良好的部署环境。
3.数据接入与运营
通过企业级的数据开发与管控能力和多模态的大数据处理能力，提升企业构建数据湖、数据中台、数据仓库等系统的效率，更高效的实现数据的资产化和数据业务化。
4.应用支持
由业务用户需求出发赋能业务用户，自主敏捷建设个性应用。
5.运维管理
通过设计流程，规范资产申请流程、数据入湖流程、数据入仓流程，提供监控告警、数据安全防护功能，实现对平台的全方位运维。
6、结尾 风正潮平，自当扬帆破浪；任重道远，更须奋鞭策马。
随着数字化转型的深入推进，数据中台作为企业数据管理的重要基础设施，其未来发展前景广阔。
数据中台的未来发展将更加注重实时化、智能化、云原生化、泛在化和安全合规等方面。企业需要紧跟技术发展趋势，不断升级和完善数据中台的建设和应用，以更好地支撑企业的数字化转型和发展。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a032ddd706eec762d8b515d78d4ead07/" rel="bookmark">
			office 2021版安装使用教程，外加Visio的安装并激活，计算机小白都能学得会，正版安装哦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、准备工作2、打开 Office Tool Plus3、卸载相关版本4、开始安装5、软件激活6、激活成功 1、准备工作 访问 Office Tool Plus 官网（https://otp.landian.vip/zh-cn/），下载最新版本，这里建议大家下载包含框架的版本，一次性安装成功。
下载下来的文件是个压缩文件，需要先解压出来。
2、打开 Office Tool Plus 点击如下可执行文件。
显示如下。
3、卸载相关版本 在安装新版本的office之前，需要卸载以前的版本和许可证，如果不卸载的话，可能会出现正版绿色不成功或者安装失败等问题。我也尝试直接安装新版的，不卸载旧版的，出现了兼容的问题，从而导致绿色失败。
卸载完之后，就可以安装新版本的office任务了。
4、开始安装 配置 Office，相关设置如下，这里我演示安装 Office 2019 。配置选项如下所示
添加产品。
找到如下版本。
应用程序根据自己的需要进行选择，这里我选择的是 Access，Excel，Powerpoint，Word（常用的程序）；Visio 是不同于office，需要单独。
语言选择简体中文(中国) - zh-cn。
以上部署完成之后，就可以开始部署了。
整体部署设置显示如下。
选择“是”。
等待一会，office工具根据需求安装相关的软件。
好了，安装完成了。下面就是用该工具绿色化。
5、软件激活 还是刚开始的网站（https://otp.landian.vip/zh-cn/），点击新手教程。
点击新手必读栏目的文章。
相关教程里面有个 [激活 Office] Office Tool Plus 入门教程。
找到如下命令，这里根据自己需要。如果是安装同版本的Visio和office，则可以使用第一行代码。
点击这个符号。
输入刚复制的命令。
这个命令是需要在office软件安装完成之后才能激活使用。
6、激活成功 这就激活了，如果有问题，欢迎大家评论提问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a752ef312e87ff83ddc2c14b6347a4/" rel="bookmark">
			小红书12月内容趋势分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为洞察小红书平台的内容创作趋势及品牌营销策略，新红推出12月月度榜单，从创作者、品牌、热搜词多方面入手，解析月榜数据，为从业者提供参考。
以下为12月部分榜单解析，想要查看更多行业榜单，创作优质内容，请点击 前往新红官网查看。
&amp;nbsp;游戏官号涨粉百万
街头探访博主备受关注
据12月的『涨粉排行榜』TOP30数据显示，从账号类型来看，生活、情感、美妆类博主更受平台用户欢迎，占比60%。
涨粉榜中，@网易蛋仔派对位列第一位，该账号借助多篇福利笔记，涨粉158.66w；@拜托了汤圆凭借挑战视频，热度上涨，12月涨粉39.22w，位于第二；排名第三的@工藤七通过街边随机采访，持续涨粉22.47w。
以下是12月『涨粉排行榜』TOP30的红人排名情况：
*向上滑动阅览*
排名第三的@工藤七从19年年底开始在小红书运营，账号前期内容主要是一些日常分享和探店类视频，账号粉丝增幅不大；12月中旬起粉丝开始猛涨，12月16日单日涨粉6.26w。
▲ 新红-红人搜索-粉丝分析
从@工藤七的历史数据来看，排名靠前的都是路人家的探访视频，这类视频内容主要是一个反差和生活感的结合。
▲ 新红-红人搜索-笔记分析
笔记标题和封面引发用户好奇，视频内容通过房屋改造满足大家对美好生活的向往，结合当地历史提升了视频的深度，受到不少用户的喜欢。
节点投放力度加大
支付宝提升品牌影响力
将视野放到品牌营销动作上，12月有双十二、圣诞、元旦等营销节点，TOP30品牌投放力度加大，品牌投放笔记的互动数也呈稳步上升。
据『商业投放榜』TOP30数据显示，食品饮料、互联网科技、美妆护肤类品牌的投放更加活跃，占比43%，排名前三的品牌分别是“京东”、“滴滴”以及“支付宝”。
以下是12月『商业投放榜』TOP30的品牌排名情况：
*向上滑动阅览*
排名第三的“支付宝”作为大家常用的生活软件，近期在小红书大量投放，与@刘一朵、@张德帅、@殷世航等头腰部博主合作推广其营销活动。
投放内容包括“上支付宝领好运莲莲三件套”、“饿了么优惠券”和“学习打卡领红包”等，12月共投放731篇商业笔记，互动数超百万。
▲ 新红-品牌搜索-种草笔记
其中，与“好运莲莲三件套”相关的笔记表现最佳，通过与剧情、生活、萌宠博主合作，在近期考研、期末、年终等时间节点，支付宝抓住了年轻人“求好运祈福”的心理，进一步提升了品牌对外影响力，有效促活老用户。
季节美食热度攀升
东方甄选讨论不断
12月小红书平台又出现哪些热点呢？通过『热搜词上升榜』可以发现近期热度攀升的关键词。
12月东方甄选董宇辉事件讨论不断，平台上与之相关内容的增加，“东方甄选”热度热度值达264.02w，排名第一。
主要内容体现在影视综、职场和兴趣爱好领域；与东方甄选广西行、东方甄选直播、董宇辉等的相关的笔记大量出现。
▲ 新红-流量分析-热搜词排行
此外，时令水果“车厘子”、“草莓”相关的内容热度也开始上涨，12月与“车厘子”相关的笔记达11187篇，排名第二；“草莓蛋糕”的需求也增加，本周期内笔记超过1w篇，热度值超过200w，排名第三。
更多新增热搜词，可查看详细榜单：
*向上滑动阅览*
以上就是本期月榜的部分内容，如果你也想把握行业热门趋势，打造爆款内容，实现粉丝增长，前往新红官网（xh.newrank.cn）了解更多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f52aba2ae3ff64c6bf40dc2d6ed4a64/" rel="bookmark">
			第五篇 设计模式的选择和应用 - 智慧选择与合理实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五篇：设计模式的选择和应用 - 智慧选择与合理实践
1. 如何识别和选择合适的设计模式 理解问题本质：首先，要深入理解面临的问题或需求。分析系统中的对象、它们之间的关系以及可能出现的变化点。了解哪些部分需要灵活性、扩展性或者解耦。
模式匹配：根据问题特征对照已知的设计模式，识别出可能适用的模式类型。例如，若遇到对象创建过程复杂且需要解耦，可以考虑使用工厂方法、抽象工厂或建造者模式；若需处理对象间复杂的交互逻辑，则可考虑责任链、中介者或观察者模式等。
权衡比较：对于多种可能适用的设计模式，进行对比分析，考虑每种模式带来的优缺点。如复用程度、代码可读性、维护成本、性能影响等因素。
实际场景结合：确保所选模式符合项目的具体应用场景，同时考虑到系统的未来发展变化。确保选择的设计模式能够适应业务需求的演变，而不是仅仅为了应用模式而模式化设计。
2. 设计模式的权衡和适用场景分析 在选择和应用设计模式时，必须认识到每个模式都有其适用范围和局限性：
一些模式可能会增加系统的复杂性，特别是在小型项目中过度使用。有些模式可能提高代码的可读性和复用性，但可能导致运行时性能下降（如工厂方法产生的类实例增多）。有的模式如单例和全局状态可能会导致难以测试和扩展。 因此，在决定采用某个设计模式时，应综合评估该模式在当前场景下的价值，包括是否解决了特定问题、是否会带来其他潜在问题以及未来可能的需求变化。
3 设计模式在实际项目中的应用案例分享 3.1. Spring框架中的依赖注入：Spring通过实现控制反转（IoC）和依赖注入（DI），实际上采用了工厂方法、策略和代理等模式，使得组件间的耦合度降低，更易于测试和维护。 Spring框架通过依赖注入（DI）实现控制反转（IoC），在实际应用中确实采用了工厂方法、策略和代理等模式的变体。下面分别以代码片段的形式说明：
1. 工厂方法模式的体现：BeanFactory与ApplicationContext
Spring中的BeanFactory接口是IoC容器的基本实现，它扮演了抽象工厂角色，负责管理和创建各种对象（即bean）。而ApplicationContext作为BeanFactory的高级实现，更加强大且功能丰富。
// Spring BeanFactory 实现了工厂方法模式 public interface BeanFactory { Object getBean(String name) throws BeansException; // ... 其他获取bean的方法 } // 通常我们使用 ApplicationContext 来获取 bean public class ClassPathXmlApplicationContext implements ApplicationContext { public Object getBean(String name) throws BeansException { // ... } } 2. 策略模式的体现：例如数据源配置切换
Spring允许通过Java配置或XML配置定义多个数据源，并根据运行时条件选择不同的数据源策略。
@Configuration public class DataSourceConfig { @Autowired private Environment env; @Bean @Primary public DataSource primaryDataSource() { return DataSourceBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f52aba2ae3ff64c6bf40dc2d6ed4a64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e869f6ee49eeb679e43b20f6bba636d/" rel="bookmark">
			微服务全做错了！谷歌提出新方法，成本直接降为1/9！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也许对于一个创造数十亿收入的机构来说，6500万美元的可观测性账单可能是值得的。但是对于架构师而言，面对过去十年中做出的工程决策带来的技术债，也许是时候做出一些调整的决定。
撰稿 | 言征 如烟
2023，微服务“水逆”之年。
长期以来，不管大厂还是小厂，微服务都被认为是云原生服务应用程序架构的事实标准，然而2023，不止那位37signals的DHH决心下云，放弃微服务，就连亚马逊和谷歌等这些云巨头，正在带头开始革了微服务的命。
1、谷歌坐不住了：我们做的微服务都错了！ “在编写分布式应用程序时，传统观点认为将应用程序拆分为可以独立推出的独立服务。这种方法的初衷是好的，但像这样基于微服务的体系结构往往会适得其反，带来的挑战抵消了体系结构试图实现的好处。”
今年6月，一群谷歌员工（由谷歌软件工程师Michael Whittaker领导）发表了一篇名为“Towards Modern Development of Cloud Applications”的论文，开篇就对当下的微服务架构开怼。
图片
文章认为，从架构上讲，微服务本身设置就有问题，它是一个没有边界的结构：“从根本上说，这是因为微服务将逻辑边界（如何编写代码）与物理边界（如何部署代码）混为一谈。”
因此，谷歌的工程师们提出了一种堪称“微服务2.0”的方法。将应用程序构建为逻辑整体，但将其交给自动化运行时，后者可以根据应用程序所需的内容和可用的内容来决定在哪里运行工作负载。
图片
基于新提出的结构，他们能够将系统的延迟降低到1/15，成本降低到1/9。
“从有组织的模块化代码开始，我们就可以将部署架构作为实现细节，”Google开发人员倡导者Kelsey Hightower在10月份对这项工作表示了下一步计划。
图片
这群谷歌开发者们发现了将应用程序拆分为独立部署的服务方法缺点太明显，并给出了非常有创新性的3条原则：
（1）鼓励开发人员编写分为逻辑组件的单片应用程序
（2）将物理分布和执行模块化单片的挑战推迟到运行时
（3）原子部署应用程序。
这三个指导原则带来了许多好处，并会为未来的开发创新打开大门。
2、亚马逊Prime Video团队：放弃微服务，改用单体 无独有偶，同样是在6月，亚马逊流媒体平台 Prime Video发布的一则案例研究似乎改变了风向：“我们放弃了无服务器、微服务架构，改用单体架构取而代之，此举为客户节省90%的运营成本，还简化了系统复杂度”。
单体应用对微服务的“反戈一击”，还是亚马逊团队提出来的，再次让这个话题迅速引爆技术圈。
整个案例看下来，微服务跟降本增效似乎也扯不到一起去。问题出在哪里？
Prime Video 团队需要一个监控视频流质量问题的工具，由于视频数量太大，就要求该工具有很强的可扩展性。
最初这项工作是由一组分布式组件完成的，这些组件由AWS Step Functions（一种无服务器编排服务，AWS Lambda无服务器服务）编排，分分钟就能搭出一个有模有样的监控系统。但谁能想到，Step Function 伸缩问题竟然成为最大的绊脚石。
具体来看，一是对于视频流的每一秒，需要很多并发的 AWS Step Function，所以很快就达到了账户限制；二是 AWS Step Function 是按照状态转换向用户收费的，太贵了实在用不起。
无奈之下，Prime Video开始考虑用单体的解决方案以降低成本和增加应用的扩展能力，在经历了反复试验后，团队最终决定重建Prime Video的整个基础设施。
亚马逊在博客文章总结道：“微服务和无服务器组件是可以大规模工作的工具，但是否在整体上使用它们必须根据具体情况而定……将服务迁移成单体让我们的基础设施成本降低了 90%以上，还提升了我们的伸缩能力。”
这就说明，至少在视频监控领域，单体架构比微服务、无服务器主导的方法产生了更高的性能、更能降本增效。
始终鼓吹下云和反对微服务化的DHH（ Ruby on Rails创始人，David Heinemeier Hansson）一针见血地指出：连亚马逊自个都觉得微服务或无服务器“扯淡”了。
3、放弃微服务的，不止谷歌、亚马逊 最近几年，无数的中小团队在权衡利弊后选择放弃微服务。
Uber 就是其中一家，此前 Uber 通过构建微服务来完成很小的需求或功能，甚至出现很多由一个人构建维护的微服务。这些微服务的存在给Uber带来了更多的挑战，比如监控、测试、持续集成 / 持续交付（CI/CD）、服务级别协议（SLA）等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e869f6ee49eeb679e43b20f6bba636d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d658d2bcdeee30d7c9cfd55843830e9/" rel="bookmark">
			【科研指南8】如何快速批量下载一篇论文后的所有的参考文献？附赠Endnote分组论文管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何快速下载一篇论文后的所有的参考文献？ 写在最前面第一步：在文献检索网站导出引用文献的RIS文件第二步：EndNote导入RIS文件，然后批量下载第三步（可选）：将之前找到的论文合并到Endnote一个数据集下 写在最前面 很多综述类文章会引用很多经典文献，如何一次性下载和导入文献管理工具？
能够在阅读论文的时候自动导出论文的所有参考文献，然后通过endnote文献管理软件的功能，可以实现在线阅读or下载所有论文。
参考：https://blog.csdn.net/qq_40876787/article/details/106754109
https://www.zhihu.com/question/264460730
第一步：在文献检索网站导出引用文献的RIS文件 在文献检索网站导出引用文献的RIS文件。双击下载 citations.ris 文件，即可自动导入到 endnote ，或者拖动到 endnote 也可以，或者在endnote软件中选择菜单进行导入也可以，等等各种方式。
推荐网站：https://git.macropus.org/citation-finder/
界面如下：
复制所有的参考文献到输入框中，并点击 “SEARCH”：
等待进行自动查询和匹配相关论文，如果万一有匹配错的，旁边有相似的论文可以手动选择标记，一般是不会错的。
点击 “DOWNLOAD ALL”，得到一个 *.ris 文件。
第二步：EndNote导入RIS文件，然后批量下载 1）EndNote下载完成之后进行安装，安装完成之后打开该软件。
2）自动导入到 endnote
双击先前下载 citations.ris 文件，（这个感觉最好用）
或者拖动到 endnote ，
或者在endnote软件中选择菜单进行导入。
3）导入之后，可以看到相关的论文名称相关信息，选中所有相关的论文（可以用shift辅助选择多篇文献），利用Endnote软件自带的Find Full Text 功能，即可即可自动批量下载所有参考文献的PDF文件。
4）左边会显示下载pdf的进度，当Searching为0时，说明处理完成。可以去设置的图书馆文件保存地址下，查看已下载的论文pdf。
搞定！！!
第三步（可选）：将之前找到的论文合并到Endnote一个数据集下 参考：文献管理软件 EndNote 实用手册「下」
EndNote 中规整/管理文献：
Group/文献组 的属性 文献可以被添加到多个不同的文献组中
文献从文献组中删除后，我们仍然可以在 My Library → All References 中查找到此文献
但是文献在 All References 中被删除后，它也会从所属的文献组中删除
创建 Group/文献组 从主菜单点击 Groups → Create Group来创建立一个新的文献组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d658d2bcdeee30d7c9cfd55843830e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00d42162287b9e5d547b1ebf5b278ca/" rel="bookmark">
			UI5与后端的文件交互（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、开发Action1. 修改Table2. BDEF中新增Action3. 新建结构，用于接收uuid以及附件数据4. 实现Method逻辑 二、UI5项目修改1. 添加表格行2. 事件处理函数3. 点击文件名时的事件 三、测试 前言 这系列文章详细记录在Fiori应用中如何在前端和后端之间使用文件进行交互。
这篇的主要内容有：
后端RAP的开发（S4HANA On-Premise） 新建Action（保存base64） 前端（UI5）读取文件并保存到后端 传输文件流，并保存在ABAP数据库表在前端下载已保存的文件在前端显示已保存的图片 一、开发Action 1. 修改Table 新增3个字段 attachment ，filename，filetype对应的CDS也添加三个字段 define table ymoon_t010 { key client : abap.clnt not null; key uuid : sysuuid_x16 not null; name : abap.char(40); age : abap.int1; gender : abap.char(10); city : abap.char(40); attachment : abap.string(0); filename : abap.char(100); filetype : abap.char(100); } 2. BDEF中新增Action managed implementation in class zbp_moon_i_010 unique; strict ( 2 ); define behavior for ymoon_i_010 alias Student persistent table YMOON_T010 early numbering lock master authorization master ( instance ) //etag master &lt;field_name&gt; { create; update; delete; //Add Action static action upload_file parameter ymoon_s010; //新增Action static action upload_attachment parameter ymoon_s011; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00d42162287b9e5d547b1ebf5b278ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69181c75e9f7781359e418baca6df416/" rel="bookmark">
			UI5与后端的文件交互（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、后端开发1. 新建管理模板表格2. 新建Function，动态创建文档 二、修改UI5项目1.Table里添加下载证明列2. 实现onClickDown事件 三、测试四、附 前言 这系列文章详细记录在Fiori应用中如何在前端和后端之间使用文件进行交互。
这篇的主要内容有：
后端RAP的开发（S4HANA On-Premise） 新建表格及CDS，管理模板文件新建Function（动态创建Excel文档并返回文件流） 前端（UI5） 提交请求并下载文档（例：在职证明） 一、后端开发 1. 新建管理模板表格 @EndUserText.label : 'Form Template Table' @AbapCatalog.enhancement.category : #NOT_EXTENSIBLE @AbapCatalog.tableCategory : #TRANSPARENT @AbapCatalog.deliveryClass : #A @AbapCatalog.dataMaintenance : #ALLOWED define table ymoon_t000 { key client : abap.clnt not null; key uuid : sysuuid_x16 not null; attachment : abap.string(0); attachment_x : abap.rawstring(0); filename : abap.char(200); erdat : erdat; erzet : erzet; } 附上数据
工作模式和之前里的内容是一样的。就是把文件流保存到表格里。 额外一点就是把XString类型的数据也一并保存。这里不再熬述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69181c75e9f7781359e418baca6df416/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198600c3234869f3580eb94f52a8893d/" rel="bookmark">
			嵌入式Linux之MX6ULL裸机开发学习笔记（IMX启动方式-启动设备的选择）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一,硬件启动方式选择 1.启动方式的选择 6ull支持多种启动方式。 比如可以从 SD/EMMC、 NAND Flash、 QSPI Flash等启动。
6ull是怎么支持多种外置flash启动程序的。
1.启动方式选择： BOOT_MODE0 and BOOT_MODE1，这两个是两个IO来控制的，选择从USB启动还是内部BOOT启动，如果要烧写系统到开发板中可以选择从USB下载，下载到SD卡，EMMC，NADN等外置存储中。烧写完成设置从内部BOOT启动，然后从相应的外置存储中启动。
2.选择启动设备 2.启动设备的选择 前提是设置MODE1=1；MODE0=0；也就是从内部BOOT启动的。
支持哪些设备： NOR flash,oneNADN,NADN Flash,QSPI flash,SD/EMMC,EEPROM。我们最常用的就是NADN，SD，EMMC，甚至QSPI flash。
如何选择设备？ 通过BOOT_CFG选择，有BOOT_CFG1.2.4,每个8位，BOOT_CFG是由LCD_DATA0-23来设置的。在ALPHA开发板上，大部分默认都接地，BOOT_CFG4的8根线全部接地，BOOT_CFG2全部接地，除第3.4位用来选择SD卡的启动接口，因为它有两个接口，BOOT_CFG1的第0.1.2位都是定死的，所以只用设置3.4.5.6.7位。
BOOT_CFG1:
BOOT_CFG2:
BOOT_CFG4:
总结：总之来说，就是设置启动方式的拨码开关的原理。重点：BOOT_CFG4全部接地，BOOT_CFG2的第3.4位选择SD卡启动接口，BOOT_CFG1的第0-2位是定死了的，看表接线就行，其他第3.4.5.6.7位根据选择的启动方式来拨码，下面的表是BOOT_CFG1的3.4.5.6.7位根据启动方式不同的拨码方式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e48c3890675005c77317bc34333d9f/" rel="bookmark">
			爬虫工具（tkinter&#43;scrapy&#43;pyinstaller）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求介绍输入：关键字文件，每一行数据为一爬取单元。若一行存在多个and关系的关键字 ，则用|隔开处理：爬取访问6个网站的推送，获取推送内容的标题，发布时间，来源，正文第一段（不是图片或者图例）输出：输出到csv文件ui：窗口小程序，能实时地跟踪爬虫进度运行要求：不依赖于python环境，独立运行的exe文件
分析实现的主要程序
最后pyinstaller 打包crawl.py即可
实现 uI中的线程控制 import tkinter as tk import time import sys import queue import threading def fmtTime(timestamp): localtime=time.localtime(timestamp) datetime=time.strftime("%Y-%m-%d %H:%M:%S",localtime) return datetime class re_Text(): def __init__(self,queue): self.q=queue def write(self,content): self.q.put(content) class GUI(object): def __init__(self,root): self.root=root self.q=queue.Queue() self.initGUI(root) def show_msg(self): if not self.q.empty(): self.text.insert("insert",self.q.get()) self.text.see(tk.END) self.root.after(100,self.show_msg) def initGUI(self,root): root.title("点击数据") root.geometry('400x200+700+500') bn=tk.Button(root,text="click",width=10,command=self.show) #pack 控制排版 bn.pack(side="top") scrollBar = tk.Scrollbar(root) scrollBar.pack(side="right", fill="y") self.text = tk.Text(root, height=10, width=45, yscrollcommand=scrollBar.set) self.text.pack(side="top", fill=tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e48c3890675005c77317bc34333d9f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/8/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>