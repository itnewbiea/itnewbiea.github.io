<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565da06c430b023ecd196a9b329ac40a/" rel="bookmark">
			vue element upload文件上传使用心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己用的upload组件主要使用before-upload，http-request，on-remove事件，给组件加ref方便调用里面的方法。文件上传重点在于将file文件传给后端，而before-upload的参数就是可以获得file，http-request也可以，不过他的file文件还要从参数里面找，http-request之所以要用是因为 upload自带的actions属性我不需要，所以需要http-request这个来自定义上传的方式，不然会报错。on-remove事件主要用来当用户手动删除了文件列表后触发。
注意actions可以随便填，只要定义了http-request
例如 手动拖拽文件上传这个
&lt;el-upload class="upload-demo" drag action="123" multiple :before-upload="beforeUpload" :http-request="uploadFile" :on-remove="handleRemove" ref="upload" &gt; &lt;i class="el-icon-upload"&gt;&lt;/i&gt; &lt;div class="el-upload__text"&gt; 将文件拖到此处，或 &lt;em&gt;点击上传&lt;/em&gt; &lt;/div&gt; &lt;/el-upload&gt; &lt;el-button type="primary" size="mini" @click="uploadSubmit"&gt;提交&lt;/el-button&gt; 在data中定义fileData保存多个文件，file保存单个文件，如果你是多文件就用fileData，单文件就用file，看你自己需要，二选一。下面的代码都是我单个文件和多个文件都写，看自己需要。
文件上传前 before-upload 参数就是上传的文件，每次上传文件前就会触发，如果是多文件上传，就将每次的file放进数组里面
beforeUpload(file) { console.log(file); this.fileData.push(file); this.file = file; }, http-request的方法 这里啥都不干，但要写，不然会报错（需要这个方法重定义上传方式，覆盖action），其实也可以在这里做 before-upload 的事，只不过因为他的参数不能直接获取file，我不喜欢。
uploadFile(row) {}, 上传文件请求接口 点击上传按钮上传发送文件给后端 这里用的表单提交formData
uploadSubmit() { if (this.fileData.length == 0) { return this.$message.error("请上传至少一个文件"); } const formData = new FormData(); // 多文件上传就用for循环，将每个文件push进后端需要的files字段 for (let item of this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565da06c430b023ecd196a9b329ac40a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23355ce1ed902b21f0d14e48434afe9/" rel="bookmark">
			wincc显示系统时间_在WinCC中如何取得系统日期和时间并显示-工业支持中心-西门子中国...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		右键点击变量管理--添加新的驱动程序--选择System Info.chn，然后在System Info--系统信息右键--新驱动程序的连接，然后新建变量系统日期、 时间就可以了。
回答者：
barry - 高级顾问&amp;nbsp&amp;nbsp第14级 2009-03-02 14:57:49
在控件中选择“WINCC Digital/Analog Clock Control”控件，并且在它的控件属性中“模拟”属性来决定是以数字形式还是模拟钟的形式来显示系统时间
回答者： 珊 - 新生&amp;nbsp&amp;nbsp第1级
2009-03-02 14:59:12
右键点击变量管理--添加新的驱动程序--选择System Info.chn,然后在此驱动下建立日期和时间的变量.
回答者： xsxzc - 中级工程师&amp;nbsp&amp;nbsp第10级
2009-03-02 15:17:10
#pragma code("kernel32.dll");
Void GetLocalTimes(LPSYSTEMTIME lpSystemTime);
#pragma code();
SYSTEMTIME time;
GetLocalTime(&amp;time);
SetTagWord("year",time.wYear);
SetTagWord("month",time.wMonth);
SetTagWord("day",time.wDay);
SetTagWord("hour",time.wHour);
SetTagWord("minute",time.wMinute);
SetTagWord("second",time.wSecond);
回答者： 麦-子 - 中级技术员&amp;nbsp&amp;nbsp第6级
2009-03-02 15:37:46
上一页
1
下一页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0a5851b59cbf8e5e16040f2cd8a439/" rel="bookmark">
			wxpython4.1.1对应的python_1.Python基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 Python语言历史与趋势剖析 • 1991年第一个Python编译器（也是解释器）诞生
• Python是一门跨平台的脚本语言，Python规定了一个Python语法规则，实现了Python语法的解释程序就成为了Python的解释器。
• Python 是解释性、面向对象、直译式、动态数据类型的高级程序设计语言，也是一种功能强大而完善的通用型语言。
• Python语法简明清晰和开发效率高
1.2 Python语言版本介绍 • Python发展至今有两个主要版本，分别是Python 2和Python 3。
• Python 2发布于2000年年底，语法更加清晰和更具包容性。
• Python 3于2008年年末发布，以解决和修正以前语言版本的内在设计缺陷。
• 对Python 3.0的主要修改包括将print语句更改为内置函数，改进整数分割的方式，并对Unicode 提供更多的支持。
1.3 Python下载与安装 • 下载地址：
Python官网：https://www.python.org/downloads/
Python文档下载地址：https://www.python.org/doc/
1.3.1 Window 平台安装 Python: （1）打开 WEB 浏览器访问 https://www.python.org/downloads/windows/ ；
（2）在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件， XYZ 为你要安装的版本号；
（3）要使用安装程序 python-XYZ.msi, Windows 系统必须支持 Microsoft Installer 2.0 搭配使用。只要保存安装文件到本地计算机，然后运行它，看看你的机器支持 MSI；
（4）下载后，双击下载包，进入 Python 安装向导，安装非常简单，你只需要使用默认的设置一直点击"下一步"直到安装完成即可。
1.3.2 Linux 平台安装 Python: ✓ 打开 WEB 浏览器访问https://www.python.org/downloads/source/
✓ 选择适用 于Unix/Linux 的源码压缩包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0a5851b59cbf8e5e16040f2cd8a439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8487e398c16d3eff2f5260add3942e06/" rel="bookmark">
			大于3小于4的整数bleem_比三大，比四小的整数是存在的吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题很有意思，看了不少评论，里面谈到数学是基于现实而不是臆想。一开始确实是这样的，例如整数1、2、3、4。它可以是我们祖先白天打猎获取的几只鹿。这些是自然界存在的数。那么，评论说数学完全是基于现实而建立的人，有没有考虑过，如果原始部落里有3个人，而恰好打猎到了5只兔子，想平均分配的话，每个人可以得到多少呢？ 那么不妨把一只兔子分成3份，然后每个人拿取5份，这样的话问题就解决了。但是这里面的数字就比较抽象了，我们称之为分数5/3 。对于把一只兔子分成三份来说，其实所谓平均分配也是颇有难度的。假设一只兔子是50CM，那么分成五份每份就是10CM。听着很公平，不过假如兔子的长度是51CM，这怎么办呢？那么，这里面我们注意到了CM这个单位可能还是太大了。没关系，随着科技的发展我们发现了毫米这个单位。于是再仔细一量，发现这只兔子的身长是510毫米。这样的话，一只兔子似乎就可以被平均分割成102毫米为一份的单位。根据我们对整数的定义，我们通常认为3和4之间的是小数，是那些不能被平均分配的兔子。然而，实际上解决兔子的平均分配,目前有两个办法。一是把兔子先整数除，然后使用加法也就是1/3 + 1/3 +1/3 。在这里面我们也注意到了设置一个特殊单位也可以解决这个问题。我看到下面有评论提到了用计算机编程，把bleem设置为一个变量。实际上，人类发明的计量单位也是这个思路。无论是英寸(贵族手指长度)、米(法国科学家们的设定)。实际上都是根据现实中某个物体的一段长度作为变量，来方便分割和计算。 实际上，如果你觉得数学就是取自生活，应用于生活。那么，除法就是一种分配方式。通过先除后加的方式或者引入中间变量(单位)的方式，可以解决平均分配也就是整除的问题。
空两行，聊聊电影里面的故事。电影里面的整数糖豆，设定也颇有趣。它认为3和4之间的整数是通往过去与未来的门。电影中数学家在桌子上摆下糖豆，它认为找出3、4糖豆中间的整数，需要换个思路。既不能仅从糖豆(或者兔子)的角度来整除或者分割，而是要从空间的角度来作文章。经典物理学认为一个物体的状态应当有且仅有一种，你看到什么就是什么。物体之间的彼此状态的变化为单位，构成了时间。例如我们的地球时间就是以地球围绕太阳公转一圈为一年，自转一圈为一天的。电影里面的bleem到底是什么意思呢？实际上回到平均分兔子的问题上，一个部落打到5只兔子，分配给3个人。先是分配了3只，在即将分配第四只的时候，兔子的数量应该还剩2只，此时分配者和被分配者的状态发生了变化，分配者和被分配者回到了分配第三只兔子前的状态。于是分配者此时又分配了一只兔子给分配者。也就是科学家拿着糖豆给到了过去的医生。
我觉得这种设定也是挺有趣的，如果要表达的话就是分配兔子也好，摆糖豆也好，在分配的单位上加上一个状态，其实这个状态对我们来说实在太显而易见了(时间总是从过去向未来流逝)所以我们忽视了实际上从自然万物衍生出来的数字符合是带有方向的，是矢量。3、4整数前面应该还有一个加号。+3 和+4之间的整数bleem应该是一个负数或者说是一个状态与我们目前认知的世界不一样的存在。这里倒不一定说时间旅行这样的事情。实际上，就我们目前了解到的知识来说，世界上的物质电子为正，而还有一些为负电荷的反物质。更有趣的是还存在一些根本不知道是什么的暗物质，而且暗物质的数量比我们了解的物质或者反物质更多。试着多以包容、好奇的心态去看世界，生活也觉得很有意思
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7552c57c9d72d41192fadd9b41ebe6b/" rel="bookmark">
			less webpack 热更新_使用babel和webpack优化项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 组件化、模块化、自动化、工程化是现在考核一前端项目是否为一个优秀项目的标准之一，从而应运而生了一些列前端模块化、工程化的工具库。babel和webpack就是其中的优秀代表，那你了解他们么？你知道如何通过babel和webpack来优化前端项目么？
正文 webpack webpack是一款前端构建工具，他的主要作用就是将各个具有依赖的模块打包整合在一起生成静态资源。就像官网展示的图片：
module chunk bundle的区别 module: 各个源码文件，webpack中一切皆模块chunk: 多个模块拼接合成的文件，使用entry，import()，splitChunk可以生成chunkbundle: 最终输出的文件称为bundle loader和plugin的区别 loader: 模块转换器。less=&gt;cssplugin: 扩展插件 webpack性能优化 基本分为两个方面：
优化打包构建速度优化产出代码 优化打包构建速度 优化babel-loader 启用缓存use:['babel-loader?cacheDirectory]合理使用include和exclude IgnorePlugin: 忽略本地化内容 new Webpack.IgnorePlugin(/\.\/locale/,/moment/),//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去
// index.js 在文件中需要手动引入当前包内自己所需要的部分
import moment from 'moment'
//手动引入所需要的语言包
import 'moment/locale/zh-cn';
moment.locale('zh-cn');
noParse: 打包时不去解析相关模块中是否还依赖其他包,而这些三方库里面没有其他依赖 module:{
noParse:/jquery|lodash/,//不去解析jquery、lodash中的依赖库
}
happyPack: 开启多进程打包，提高构建速度。 // loader
{
text:/\.js$/,
use:['happypack/loader?id=babel'],
}
// plugins
new HappyPack({
id:'babel',
loaders:[{
loader: 'babel-loader',
options:{
cacheDirectory: true,
}
}]
})
parallelUglifyPlugin webpack内置了一款Uglify工具压缩js，但是不能开启多进程项目比较大。构建速度缓慢才需要使用多进程，项目简单开启多进程开销太大，可能拖慢打包进程 new ParallelUglifyPlugin({
uglifyJS:{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7552c57c9d72d41192fadd9b41ebe6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22731d32f99d85cfa971edd823dfc5c1/" rel="bookmark">
			距离函数的等价性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ANN应用场景广泛，如搜索、推荐，ANN在使用时对两个样本或向量之间的相似度定义有不同方式，相似度使用距离来衡量，距离越大则相似度越小，距离越小则相似度越大。文本语料上训练出来的特征向量习惯采用余弦距离，图片或视频上提取的特征向量一般采用欧氏距离。此外，还有特殊场景下定制的各种距离函数，此处介绍一个在搜索排序场景中使用的angular相似度度量函数，其可有效放大被召回的头部样本点之间的差异。
如上图左图所示，angular similarity是特殊场景中定制的距离度量函数。
有一个结论是：归一化向量之间的余弦距离可以跟欧氏距离进行直接转换，即euclidean_distance^2 = 1 - 2 * cosine_distance。所以很多代码在实现欧氏距离时先做归一化再直接相乘。
ANN召回场景下，本文要说的是：
1）即使不做归一化，也可以直接让欧氏距离与余弦距离建立等价关系；
2）任意向量内积的结果可与欧氏距离建立等价关系。
ANN中按欧氏距离计算出的近似K近邻点与按内积或余弦距离计算出来的近似K近邻点结果相同，所要做的仅仅是对所有待检索的向量做预处理即可，找出最大的常数φ，然后构造一个维度+1的新向量。
上图来自论文《Speeding Up the Xbox Recommender System Using a Euclidean Transformation for Inner-Product Spaces》。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca4b275918f77825753ad796911b3a1/" rel="bookmark">
			C语言strcat()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 char *strcat(char *dest, const char *src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
声明 下面是 strncat() 函数的声明。
char *strcat(char *dest, const char *src) 参数 dest -- 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。src -- 指向要追加的字符串，该字符串不会覆盖目标字符串。 返回值 该函数返回一个指向最终的目标字符串 dest 的指针。
实例 下面的实例演示了 strcat() 函数的用法。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char str1[6] = "hello"; char str2[6] = "world"; strcat(str1,str2); printf("str1 = %s\n",str1); printf("str2 = %s\n",str2); int len = strlen(str1); printf("len的长度:%d\n",len); return 0; } 打印结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca4b275918f77825753ad796911b3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218369fcdf491321e2945fc04655e75c/" rel="bookmark">
			win10使用vscode&#43;anaconda&#43;Python环境配置（解决无法加载文件 \WindowsPowerShell\profile.ps1，因为在此系统上禁止运行脚本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10使用vscode+anaconda+Python环境配置（解决无法加载文件 \WindowsPowerShell\profile.ps1，因为在此系统上禁止运行脚本） 安装anaconda为conda设置环境变量conda 环境初始化 vscode 安装vscode安装python插件安装powershell的权限修改 安装anaconda 在win10里安装anaconda十分简单，傻瓜式下载安装即可。进入anaconda官网下载页下载相应的文件进行安装即可。记得选择Python的版本，anaconda会自动安装相应的Python以及众多常用的Python库。（与直接安装Python不同的是，通过anaconda安装的Python在使用时需要启用anaconda的环境，直接在cmd终端里用python命令是无效的）
为conda设置环境变量 一般来说，安装成功会自动添加环境变量，但是，很多时候并没有（不知道什么原因），所以安装完成后最好检查一下，如果环境变量没有设置，在系统终端（cmd或者powershell中执行conda相关命令时会报错，出现类似“找不到制定命令，conda不是一个可执行命令”之类的错误）
按上图步骤打开环境变量窗口后如下图所示，查看path变量的值。
如上图所示，修改环境变量中的Path变量的值，添加conda的相关目录进去即可，用户变量和系统变量的区别只在于系统变量对所有用户都生效（只是自己用的话，用户变量就够了）。上图所示是我自己的安装目录，仅供参考，根据个人实际安装目录调整。
conda 环境初始化 与Ubuntu中安装完anaconda后终端会自动默认启用anaconda的base环境不同，win10中在cmd终端或者powershell终端里默认base环境是不启用的，而且直接使用conda activate命令的时候，会报如下错误：
按照提示进行初始化执行conda init命令即可。
vscode 安装 vscode安装 进入vscode官网（可能会比较慢，如果有梯子科学上网可能会快一点）下载并安装vscode。
python插件安装 在vscode中搜索python的插件（如下图）并安装
如果先安装了anaconda，再安装vscode以及python插件，基本上不需要自己设置什么，vscode会自动检测并进行配置，如果有多个python环境，可以在左下角状态栏处点击选择修改。
powershell的权限修改 在win10中，vscode中的终端使用的是powershell，windows中常用的是cmd，在win10中，可以通过Ctrl+X调出含有powershell的菜单（如下图）
选择管理员权限打开，并在其中输入如下命令：
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned 因为win10默认不允许执行powershell脚本，所以，在未进行权限调整的时候，vscode中启用conda环境进行调试时会提示如下图所示错误：
当然，有时候这个错误并不影响python程序本身的执行，但是在进行调试或者需要在终端中使用一些命令时，会无法执行。
如果不想直接修改系统的这个权限，或者在vscode的终端中无法用管理员权限打开powershell，可以只针对当前用户修改权限，可以直接在vscode终端中执行如下命令：
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned 参考如下图：
这样一来，vscode中可以完整使用anaconda+python环境进行开发和调试程序了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c64639327af2d505e1179b3fd595d1/" rel="bookmark">
			C语言strlen()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 strlen()函数：该函数从第一个字符开始计算字符串中字符数，直到遇到空字符即'\0'为止，然后返回计算字符数的长度，包括'\0'。
以下是strlen()函数代码，如下：
##include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void){ char str [50] = "HelloWorld'\0'Hi";//定义字符数组str容量:50 int len = strlen(str);//定义整数类型int len,然后把strlen(str)计算出来的长度赋值给len printf("len的长度：%d\n",len); return 0; } 打印结果：
代码分析：HelloWorld'\0'Hi共计13个字符，然而打印出来的结果却只有11个，这是因为strlen（）函数在计算长度的时候碰到'\0'空格键的时候便不再计算后面的长度，所以计算的长度只有"HelloWorld"+'\0'共11个。
指正：计算长度"HelloWorld"+'共11个，不包括\0',感谢@安如少年初如梦i的指正！
以上就是strlen()函数使用方式以及说明！
完 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5223989008feedce25afd0b89bc6b5f9/" rel="bookmark">
			错误：非法字符：“\ufeff”　　Java　python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JAVA IDEA导入开源的项目的时候，非法字符：“\ufeff”，编码问题，这一般这个项目是用eclipse开发的。主要原因是: Eclipse可以自动把UTF-8+BOM文件转为普通的UTF-8文件
解决办法：UTF-8 换成 GBK 然后再换成UTF-8 就好了
方法二：
将这些报错的文件拷贝到一个目录中，然后用notpad++打开，点击工具类上的 编码，将 以uft8格式编码 转为 以utf8无BOM格式编码，然后保存，再覆盖idea中对应的文件。
方法三：
将文件用EditPlus打开，然后选择Document（文件），再选择Convert Encoding（编码转换）如下图操作
再弹出框中选择 UTF-8即可
上面是转换一个文件的编码，如何转换整个项目的编码:
Python 使用python打开txt文件，总是开始出现\ufeff，例如使用下面python代码打开a.txt文件，就会报这个错误
lines = open(osp.join(rootpath,'test.txt'),'r',encoding='utf-8').read().rstrip().split('\n') 解决办法：修改解码规则
f = open('test.txt', encoding='UTF-8-sig') name_list = [] for line in f: name_list.append(line.strip()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56166b70380b962b41e2a918a866cb08/" rel="bookmark">
			无线智能阀门控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、产品研发的由来 今年做了一个比较满意的产品，这个产品也是总结过去三年的产品经验，融入最新的软件架构，通信技术，按照自己的对产品与技术的理解，自己定义研发这样一款产品，此次产品的功能结构，设计理念，软件架构都有了一个质的变化，特发此文纪念一下。
一个硬件产品要想真正的质量过硬，客户用着皮实耐用，没有个三个年的功夫是做不出来一个好产品的，那些花一年时间做出来的产品顶多是一个功能样机，实现基本功能，远远达不到可靠耐用，市场认可的程度，还是要让产品去市场上接受考验，同时根据客户反馈，不断升级优化才能做出好产品。这些年来见过太多的公司，产品研发只做一次，上市后就不再管了，不升级，不改进。下一次还是再开发一款新产品出来兼容老产品的功能，再加新功能，周而复始做着只装半瓶水的事，就是不肯踏踏实实下来把一款产品迭代稳定。总想着时间快，多出产品，占有市场。就说中国企业没有工匠精神的企业，所以也就难以研发设计制造出像国际大企业ABB, SIEMENS,GE这个公司质量过硬的产品。
2、产品的功能 产品的功能说起来很简单，实现起来也不难，在校大学生都能做，但是要真正做出一个产品，经受住用户的使用与考验，这个事就难了。这次研发的产品是一个12路智能电磁阀控制器。
12路智能电磁阀控制器的功能有，手机远程控制打开，关闭电磁阀的功能、手持遥控器本地打开，关闭电磁阀的功能、定时开关功能、支持有线以太网，4G两种联联网方式，自动进行网络切换，优先使用有线网络连接服务器。
3、软件架构 产品的软件采用RT Thread嵌入式实时操作， 优化kawii mqtt软件包，实现使用mqtt协议连接服务器功能，编写onenet软件包抽象服务器网络接入功能，编写zFTP软件包用于实现支持有线以太网与4G双通道自适应联网进行远程固件OTA功能。有线网络接入使用lwip协议，4G网络接入使用AT SOCKET组件，上层mqtt协议使用kawii mqtt软件包（经过优化）。整个产品的软件架构图如下图所示。
在一个优良的技术架构下，轻松的实现了产品的功能设计，产品的关键技术指示相对于上一代产品有了质的变化，产品在线时间由原来的90%提高了99%的，产品性能得到了很大幅度的提升。
4、硬件架构 硬件设计此次优先以实现产品各个方面的性能，以前的设计连双层板与四层板相差的成本都要计较。实际从整个产品来看，产品质量与性能的提升是能覆盖住设计上的就点小小的成本的。
电源方案采用12-24V AC/DC输入，经过DC-DC变成5V，5V经LDO变成3.8V供4G CAT1模块使用，5V经LDO变成3.3V供MCU及外围通信，存储模块使用。
MCU采用STM32F207VE，外接有线以太网，4G模块，遥控器接收模块，IO驱动12路电磁阀，指示灯，蜂鸣器，存储芯片。
5、产品性能测试 产品可以实现稳定的联网工作，长达10天连接服务器不断网，产品超长时间工作软件不死机，不重启，4G连接发生断网时间最多1分钟，有线连接发生断网时间2秒钟，大大提升了产品的在网时间。软件功能划分合理，各个软件功能模块全部解耦合，互不影响，各司其职，模块化的设计提升的产品的软件的可靠性，具有很强可维护性。
硬件电路设计紧凑，电路布局合理，各路射频信号阻抗匹配，性能优越。电路上各个信号完整，硬件工作稳定可靠。
6、产品实拍 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bc30423bd748bc6b587b8427614645/" rel="bookmark">
			面试题之数组var fun = function(){for(var i = 0 ,arr = []； i＜3； i&#43;&#43;){arr[i] = function(){ console.log(i) }
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var fun = function(){ for(var i = 0 ,arr = []; i&lt;3; i++){ arr[i] = function(){ console.log(i) } } return arr } var funs = fun(); funs[0](); //3 funs[1](); //3 funs[2](); //3 解析：
函数 fun 仅调用了1次，只创建了一个作用域，通过 for 循环分别创建了3个子函数保存在数组arr中，此时子函数并未调用，当for循环结束时，i = 3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c5214e5e1bcbd8572a3116f1f9e573/" rel="bookmark">
			acquireSharedInterruptibly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 countdownlatch也用到了AQS，在CountDownLatch内部写了一个Sync并且继承了AQS这个抽象类重写了AQS中的共享锁方法。首先看到下面这个代码，这块代码主要是判断当前线程是否获取到了共享锁;（在CountDownLatch中，使用的是共享锁机制，因为CountDownLatch并不需要实现互斥的特性）
public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) //state如果不等于0，说明当前线程需要加入到共享锁队列中 doAcquireSharedInterruptibly(arg); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96738d775e63d9872463956283e94947/" rel="bookmark">
			2020年Android开发总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 2020年Android开发总结开发中的收获KotlinJetpack我对岗位的认知我觉得最有实际意义的开发最充实的一次开发技术成长自己对工作的一些看法 2020年Android开发总结 年底总是一个充满回顾与展望的日子，在2020这场哀鸿遍野的“寒冬”里尤为明显。
其实不管是公司、集体还是个人，都需要在这个时候找个机会停下来，思考一下这一年来的收获与成长、失去与遗憾。
每个人都有自己的希冀与计划，每个人又同你我一样，是犯有轻微拖延症的普通人。
面向即将到来的一年大家总会立各种 flag，临近年终时又总是自嘲式的将计划延期至新的一年。
2020是一个神奇的一年，发生了许多大事，但回到个人身上也只是一件一件小事。
开发中的收获 在过去的一年里，我接触到了 Kotlin、Jetpack、Gradle 等这些新技术，在项目中实践。
Kotlin 自从Google 宣布 Kotlin 成为 Android 开发的第一语言之后，大量的示例代码以及第三方库都开始拥抱 Kotlin，以及同事也在使用，我也开始了我的 Kotlin 之路。
起初的目的很简单，只是为了能看懂别人写的 Kotlin 代码，慢慢的自己也加入到使用 Kotlin 的队伍中，现在公司的项目中也是 Java 与 Kotlin 混合开发。
Jetpack 我在查阅了较多的资料后发现 Navigation 是 Google 提供给开发者的一个组件，但似乎 Google 并不想让开发者局限于这个组件，而是提供了丰富的可扩展的 API 让开发者发现它的更多使用方法。目前我在项目中实际使用的只有Room组件，以后逐步学习其更多组件在项目中使用。
我对岗位的认知 具备团队精神和协作能力写文档的习惯需求理解的能力模块化思维，减少重复的劳动有自测习惯提高还原度、按时完成开发任务做好自己的，不给团队成员带来精神或经济的压力 我觉得最有实际意义的开发 CICD自动化打包： 学会了在Linux安装Java环境、Android构建环境学会了简单的编写Shell脚本学会了Gradle自动化相关配置虽然做这块时联调及自测比较心累，但是最后也是收获满满的，解放了双手，公司三款APP再也不必要我们手动出包了。 卡友地带接入网关 使用 Retrofit 做网络请求，Rxjava 数据流，Okhttp封装卡友地带走网关的一套网络框架。完成了我在公司封装的第一套网络通讯代码。 最充实的一次开发 好运宝的卡钻页面：
疫情期间在家办公的日子，本以为是无聊的日子，没想到来了这么一个需求，那个产品经理三天两头的换UI、改动效。我们也是乐在其中，更多的是学会了如何去接受善变的需求，以积极的心态去面对。 技术成长 今年技术上的成长并不多，在业务压力之下，Android UI 玩得更加熟练吧。 Google IO大会提出了一些新的架构：LiveData, Room, LifeCycle, ViewModel。 目前我只尝试使用了 Room，其它的几个目前还没怎么了解，学习这些新的架构还是蛮有必要的，即使不用它们，它们的源码也是非常值得阅读的。个人成长方面也有所进步，初步形成了知识管理、任务管理的基本概念，但目前都还是属于初级阶段，尚不能影响什么具体的东西，还需要一定的时间进行沉淀。
自己对工作的一些看法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e545df947dced3694f4a399be52805/" rel="bookmark">
			ROS2_Foxy学习5——基础编程_C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2_Foxy学习5——基础编程_C++ 1 workspace1.1 工作空间及其层次1.2 检查依赖1.3 编译工具 colcon 2 编写 package2.1 功能包创建2.2 package.xml 和 CMakeLists.txt2.3 功能包编译、设置环境变量、运行 3 编写 topic3.1 发布 publisher3.2 订阅 subscriber3.3 修改 package.xml / CMakeLists.txt3.4 编译、运行两个节点 4 编写 service4.1 服务器端 server4.2 客户端 client4.3 修改 package.xml / CMakeLists.txt4.4 编译、运行两个节点 5 自定义消息 msg/srv5.1 创建消息功能包5.2 测试自定义消息接口5.3 应用自定义消息接口5.4 使用同一功能包的消息接口 6 使用 parameter6.1 参数的声明与获取6.2 终端修改参数6.3 launch文件修改参数 附件1 消息文件应用 里面的例子参考 官方教程，然后附带一些解释和一些推荐的便于理解的文章。 1 workspace 1.1 工作空间及其层次 空间的创建：ROS2与ROS1一样，创建工作空间目录，并在其中创建/src目录，用于存放package功能包。
层次的概念：ROS2增加了overlay和underlay的概念，用于在多个workspace同时工作时，处理各个workspace之间的层次问题，对于包名相同的package，上层workspace将覆盖(override)下层workspace中的同名package。
层次的配置：层次是通过环境变量配置的先后决定的，ROS通过setup.bash设置环境变量，ROS2安装路径一般设置为最下层的工作空间，即
$ source /opt/ros/foxy/setup.bash 运行新建workspace的package功能包，需要在对工作空间编译后的新终端中配置如下
# 设置当前工作空间中功能包的相关环境变量 $ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e545df947dced3694f4a399be52805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42602059f408a7ffade8d5ee44019cc/" rel="bookmark">
			基于正则化图神经网络的脑电情绪识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于正则化图神经网络的脑电情绪识别 一、 引言（Introduction） 论文动机 ​ 现有的基于脑电图的情绪识别方法大多不能很好地解决以下三个方面的问题: 1)脑电图信号的拓扑结构没有被有效地利用来学习更多的有鉴别性的脑电图特征然而，大多数方法需要在头皮上对脑电图通道进行2D表示，这可能会在flatten过程中造成信息丢失，因为通道实际上是在3D空间中排列的; 2)不同受试者的脑电图信号差异较大，不利于训练分类器的泛化; 3)参与者在观看引发情绪的刺激时，可能并不总是产生与刺激一致的预期情绪。目前研究中，在基于脑电图的情绪识别方面，还没有人试图解决噪音标签的问题。作者提出了一个正则化的图神经网络(RGNN)来解决上述三个问题。
论文工作 ​ 脑电信号中的每个通道看作是图形中的一个节点。RGNN模型扩展了简单图卷积网络(SGC)，利用了脑电图信号的拓扑结构，即根据脑网络组织的经济性，作者提出了一个符合生物原理的稀疏邻接矩阵来捕捉局部和全局的通道间关系。局部通道间关系连接附近的神经元群，可以显示解剖学上的连通性。整体的通道间关系连接左右脑半球之间的神经元群，可以揭示与情绪相关的功能连接。此外，作者提出一个节点域对抗训练(NodeDAT)来正则化图模型，以更好地解决跨被试分类场景，并且还提出了一种基于情绪感知的分布学习(EmotionDL)方法来解决数据集中的噪声标签问题。
二、RGNN知识基础 ###简单图卷积网络(Simple Graph Convolution Network ,SGC)
​ 给定图 G = ( V , E ) \mathcal{G}=(\mathcal{V}, \mathcal{E}) G=(V,E)， V \mathcal{V} V表示节点集， E \mathcal{E} E表示边集。 X ∈ R n × d \mathbf{X} \in \mathbb{R}^{n \times d} X∈Rn×d表示特征矩阵， n n n表示节点的数目， d d d 输入特征的维度。 E \mathcal{E} E可以用加权邻接矩阵 A ∈ R n × n \mathbf{A} \in \mathbb{R}^{n \times n} A∈Rn×n表示。 一般情况下，GNNs对输入 $\mathbf{X} $学习一个特征变换函数，生成输出 Z ∈ R n × d \mathbf{Z} \in \mathbb{R}^{n \times d} Z∈Rn×d, d d d表示输出的维度。特征转换可以写成： H l + 1 = f ( H l , A ) \mathbf{H}^{l+1}=f\left(\mathbf{H}^{l}, \mathbf{A}\right) Hl+1=f(Hl,A)，这里 l = 0 , 1 , … , L − 1 , L l=0,1, \ldots, L-1, L l=0,1,…,L−1,L， H 0 = X , H L = Z \mathbf{H}^{0}=\mathbf{X}, \mathbf{H}^{L}=\mathbf{Z} H0=X,HL=Z。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42602059f408a7ffade8d5ee44019cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a3267fa4e02ebd3dd912f890c596d70/" rel="bookmark">
			ant-design里用Form（v-decorator）和FormModel(v-model)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续更新 用ant-design 的踩坑记录。。
Form 和 FormModel
近在用ant design vue 做项目 遇到了 一下坑 比如 v-decorator 可以做数据 绑定 与v-model 不同的是 给 form 表单赋值
v-model 的值是 双向绑定的
如果想 给改变 v-model的值 直接赋值 即可 比较 方便
而 v-decorator 个人认为 有点 麻烦
如果 你想 改变 v-decorator 中绑定的值
Form
如上图 需要用到 this.form.setFieldsValue({}) 方法 其中 nachineName 就是绑定的值 如下图
以此方法 就可以 给 v-decorator 绑定的值赋值 了
最后你可能 想问 如何查看获取 from 中绑定的表单数据 呢 ，那么它来了
如上图 this.form.validateFields 方法就可以获取表单里的值 此时 打印的 values 就是 当前form表单里的全部 数据 了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a3267fa4e02ebd3dd912f890c596d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3668ce8eb540d82a914a0b2a184f8917/" rel="bookmark">
			h5页面转发微信好友，qq，微信朋友圈，qq空间踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：扫描二维码，打开一个移动端页面，用户分享到微信好友，qq，微信朋友圈，qq空间可以自定义标题，图片，描述。
实现步骤：
一.绑定域名
二.引入JS文件
三.通过config接口注入权限验证配置
四.通过ready接口处理成功验证
五.通过error接口处理失败验证
注意点：
1.引入JS文件：
老版本常使用http://res.wx.qq.com/open/js/jweixin-1.2.0.js（针对使用wx.onMenuShareAppMessage，wx.onMenuShareTimeline接口）
微信文档已更新推荐http://res2.wx.qq.com/open/js/jweixin-1.6.0.js (针对使用wx.updateAppMessageShareData，wx.updateTimelineShareData接口)
2.通过config接口注入权限验证配置：
axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;
axios({
method: ‘post’,
url: ‘’, //此处为请求签名接口
dataType: ‘json’,
data: queryParam({url: window.location.href})
})
请求签名，data里的url必须编码，且不可带#后面的参数，url需要手动获取
wx.config()配置，appId需保持一致；签名很重要，config如果报错，一定要检查签名，微信有一个检测网址🔗，根据检测结果再去排查data里的url等
1.4.0以下版本 ：jsApiList[‘onMenuShareAppMessage’,‘onMenuShareTimeLine’,]，
1.4.0及以上jsApiList：[‘updateAppMessageShareData’,‘updateTimelineShareData’]
3.通过ready接口处理成功验证：
1.4.0及以上 wx.updateAppMessageShareData，wx.updateTimelineShareData link必传 ios系统14版本开始，imgUrl必传，否则报imgUrl is needed
1.4.0以下wx.onMenuShareAppMessage，wx.onMenuShareTimeline即将废弃
4.页面链接
需要加上index.html 参数是网址需要编码处理
5.生成二维码，链接需要短链处理，否则可能出现二维码太密扫不上的情况
总结：目前的分享在ios14上坑还是很多的，遇到再补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa9378366f7c2037db104f51cc1e9f2/" rel="bookmark">
			之江杯2020零样本目标分割题参赛总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、赛题简介二、ZS3Net简介三、我的tricks四、总结 比赛链接：https://zhejianglab.aliyun.com/entrance/531816/rankingList。我最终排名第四，这是综合决赛第一轮、第二轮线上成绩和最后答辩成绩的排名，实际上我最后决赛第二轮线上成绩已达到第二。和商业赛不同，之江杯更关注学术问题，这个赛题也比较前沿，报名团队只有三百多个，但看最后的决赛名单就知道，来的多是非常专业的团队。我这次依然是solo参赛，最后居然冲到了前排，真是没想到，实属幸运。
一、赛题简介 本题属于图像语义分割任务，零样本是指没有提供任何测试集类别的样本，但提供了和测试集相似类别的图像及语义分割标注作为训练集，此外可以使用已训练好的词向量表来连结训练集类别和测试集类别间的语义关系，（词向量可以理解为一种用数字编码表示的词典）。举例：训练集中提供了西瓜的图像分割样本，测试集要求实现哈密瓜的图像分割，好比一个人见过西瓜但从来没有见过哈密瓜，他可以通过查阅西瓜和哈密瓜的词典来推测哈密瓜长什么样子。
零样本目标分割任务的初衷是为了解决图像语义分割问题标注成本非常高的问题，同时这也是对更为通用的人工智能的一种探索，要求机器不仅能够识别图像，还要把图像名称的语义和图像特征对应起来。本赛题训练集200类（下称已知类，seen），共约80000张图片，是和ImageNet风格类似的实物照片，测试集初赛和决赛都各有不同的50类（下称未知类，unseen），每类约100张图片。
这个问题比较前沿，相关文献和开源不多，能够查到的按时间顺序排序是SPNet -&gt; ZS3Net -&gt; CaGNet。CaGNet应该是当时的SOTA，这次比赛CaGNet的作者团队也来了，但最后没有获奖，学术和比赛毕竟还是不一样，比赛需要很多trick，就比如孔子参加科举未必能中举因为他不会写八股文，但大师的成就不是区区小赛的成绩所能比的，向他们致敬。这次比赛的冠军团队来自浙江大学，确实非常牛，心服口服，他们的方法已经撰写论文被顶会录用（好像是AAAI?)，应该是新的SOTA了。
二、ZS3Net简介 由于赛程短，我还是零基础进入，自然是采用本渣一贯的策略：走别人的路，让别人无路可走（囧）。看了一圈文献后，觉得CaGNet较难，估计来不及，所以从ZS3Net下手，ZS3Net是该领域较早期的一个作品。下面简介一下ZS3Net和我的理解。
原文NIPS2019：https://arxiv.org/abs/1906.00817
代码：https://github.com/valeoai/ZS3
先放上论文主图：
ZS3在经典图像分割网络DeepLabV3+基础上动手术，首先把网络切开，切出末层和除末层之外的前层。网络末层的输出是像素级的分类结果，而末层的输入就是每像素所属类别的语义特征，语义特征是什么？也是词向量。而零样本任务中已知类和未知类的唯一连结就是词向量，这样我们从DeepLabV3+末层的输入入手，就可以把已知类和未知类关联起来。
然而DeepLabV3+的末层输入的这个词向量和我们从其他文本中训练得到的词向量（我使用的是Glove6B）是不对应的。我们可以想象一下，假设末层输入的语义特征是300维，它可能是按照颜色、纹理、形状…这样的300个属性排列的，但我们从外界得到的词向量可能是物种、材料…、形状、纹理、颜色…等这样的排列，两者有交叉部分，但顺序不同，描述方式也不同，好比是两本词典，你需要一个翻译机制翻译过来。
ZS3Net创造性的提出用生成器的方式实现这个翻译。这个生成器的输入是外界得到的词向量，比如Glove6B中词向量，输出是刚才提到特征向量（即DeepLabv3+末层的输入，当然它也是前层的输出），使用已知类的Glove6B词向量和DeepLabv3+前层输出特征向量训练这个生成器，训练好的生成器就掌握了这种翻译机制，可以用来根据未知类的Glove6B词向量生成未知类的特征向量。
得到了未知类的特征向量再用它来训练DeepLabV3+的末层（前层冻结不训练），得到了新的网络权重，就可以直接用于未知类的分割任务了。
这个问题可能有点绕，我再来捋一遍，其实就是分为3步：
1，在已知类上把DeepLabV3+训练充分；
2，使用训练集类别的词向量和训练集图片经DeepLabV3+前层输出的特征向量训练一个生成器；
3，从Glove6B中得到未知类的词向量，用生成器生成特征向量，用这个特征向量替换训练集图片经DeepLabV3+前层输出的特征向量（注，只替换目标部分，不替换背景），同时也替换训练集标注Label中的已知类类别为未知类类别。然后再冻结前层，重新训练末层。最后把前层权重和末层权重合并起来得到的新的网络权重，就可以直接用于未知类测试集的推理。
实际ZS3Net原文方法比我讲的要复杂一些，还用了一些技巧，但核心原理就是我刚才讲的三步。
三、我的tricks 单靠已有开源想在这种比赛中获胜是不可能的，我在仔细分析数据、调试网络之后，进行了以下三点主要的改进，正是这三点改进使得分有了很大提高。
1、对训练集逐类别加强训练
由于本题训练集的类别数特别多，高达200类，而且各类差别很大，有的很好训练，而有的很难训练，主要是上帝造的东西都比较好训练一些，人造的东西都难训练。如果全部丢进去一起训练，网络训练进展非常缓慢，而且我卡也有限，只有2080ti，跑两天两夜也只达到mIoU0.25的水平。逼的没办法，我设计了一种逐类别训练的方法，效果不错。具体如下：
step1: 先把200类全部训练几个epoch，验证每一类的IoU，把IoU达到一定阈值以上的类别称为learned类，表示它们已经训练好了，把剩余的称为unlearn类。
step2: 然后每epoch从unlearn类中随机挑选10个作为to learn类，从learned类中每类选50张图片以保持记忆性，从to learn中每类选200张图片以加强训练。每轮训练结束再验证，重新划分learned类和unlearn类。
如此循环往复。我最后达到159类learned，还有41类确实非常难以分类，仍然是unlearn。这样可以达到mIoU0.36，比直接训练法整整提高了11个点！
2、只使用优质数据训练生成器
ZS3Net的生成器使用GMMN，它比较简单，参数也少，所以训练它不难，不需要非常大量的数据。但是由于deeplabv3+本身在本题训练集上的成绩并不是很高，mIoU0.36实际上意味着它有很多分割结果仍是错误的，如果我们用这些错误的特征向量和类别对应关系去训练这个生成器，这个生成器的翻译就会不准。
所以我们应该去掉那些错误数据，只喂给生成器最好的饲料来训练。一个自然的想法是只用learned类来训练它，更进一步还可以深入到每张图片，比如计算每张图片的acc，只用acc高的图片来喂它。这样训练出来的生成器就更加准确。
3、用一种新颖的方法对结果进行融合
观察测试集推理结果我发现，网络对很多图片分割也都大致能分割出来，但分类却是错误的，更细致的观察我发现如果网络对某张图片分类错误时它会表现的没有正确时那么“自信”，就是它分割出的面积会小一些，比如缺一块或者中间有孔洞。这样我就想出了采用如下方式进行融合：
step1:在不同训练条件下得到的各个权重分别对测试集做推理
step2:对比同一张图片在不同权重下的推理结果，选择目标面积较大的一个作为最终推理结果。
这个方法也很有效，我在决赛第一轮的时候没有使用融合，只排到第6名，决赛第二轮的时候使用了这个融合，排到第2名。
四、总结 本次赛制是初赛取前12名进入决赛，决赛前6有奖，我是以初赛第11名进入决赛的，所以我去现场的时候没报希望，心态也非常放松。由于决赛采用了未知类词向量统一提供的方式，而初赛很多团队在词向量方面做了不少工作，所以改这种方式之后很多队伍翻了船，而我自始至终本本分分的做零样本网络方面的工作，没有去琢磨词向量，所以决赛我占优势。另外决赛第二轮我想到了用上面提到的融合方法又提了不少分，说实话第一轮我也想到了，但是当天一直在赶路，而且心态上没抱希望所以没有打起精神来改代码就没用融合。
这次比赛认识了很多大佬，结识了几位朋友，收获满满。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92aa6e2a22d322f48f02d412c6411a0/" rel="bookmark">
			32个笔画顺序表图片_32个笔画掌握透了，练字真的不难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔画作为硬笔书法最基础的部首，也是十分重要的一部分。建议初学者一定先要学好这些笔画。配图选自田英章老师的楷书教材。
这本教材是我上大学时候，社团统一购买的。由于都是大部分都是摹写的，我本人不喜欢摹写，所以字帖一直保存良好。现在回想一下，这本字帖都近十年了。
这本教材的笔画部分共8课，每课4个笔画，总计32个笔画，每个笔画都附有详细的讲解，并且提供3个范字可摹写。
之前没啥学习兴趣，自然没去多看讲解部分，其实现在看来，各个笔画的讲解都很到位，也利于初学者理解。
说这是一本入门字帖吧，我觉得编排上存在一些问题：
一课学习4个笔画，对初学者来说太难了范字的选择也有点难练习量安排得太少基本就是一张临摹纸让你跟着练，书上的内容及其多，还有部首和结构，以及作品欣赏，全部集中在一本书上，让人一看就不太想学，我觉得一本好的字帖，应该要让人容易入手，看起来就像练练。 所以我这样扫描后截图起来，一个笔画一个笔画学习起来，清晰多了。分享给正在自学、初学硬笔书法的人：其实写字不难的，又不当书法家。理解了这32个笔画的写法，基本就成功入门了。祝大家学习有成！
注：以上字帖非本人制作，仅供参考
更多字帖下载、练字分享可在圈中获取
感谢您的阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9f33fcc0218533c443ca41a9e1b32e/" rel="bookmark">
			php连接oracle很慢是什么原因_帮你梳理—LAMP架构是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LAMP分别代表什么？ · L代表服务器操作系统使用Linux
· A代表网站服务使用的是Apache软件基金会中的httpd的软件
· M代表网站后台使用的数据库时MySQL数据库
· P代表网站是使用PHP/Perl/Python等语言开发
Apache/MySQL/PHP各自有什么作用？ 我们可以将LAMP架构理解为饭店，家饭店很特别，前台小姐姐灰常漂亮，服务生和厨师很丑，丑到不能见人的那种(自行脑补哈)，所以你去饭店就只能看见前台小姐姐。
1. 聊聊Apache(httpd) · 像极了前台
· 作用：提供web服务，接受用户的连接请求!
注意：Apache或Nginx都只支持静态页面的解析
当客户端请求的是静态资源时，web服务(httpd程序)会直接返回静态资源给客户端
（1）静态网页
· 静态网页指使用HTML(超文本标记语言)编写，一般后缀为.htm、.html等;网页文件中没有程序代码
· 静态网页，用户双击打开，看到的效果与web服务器是相同的，因为网页的内容在用户访问之前，就已经确定
（2）动态网页
· 动态网页指网站使用特定的编程语言编写，网页文件中除了HTML标记以外，还包括一些实现特定功能的程序代码
· 服务器端可以根据客户端的不同请求动态产生网页内容
· 动态网页后缀一般为.php、.asp、.aspx、cgi、.perl、.jsp等
· 常见的留言板、论坛、注册、发帖都是用动态网页实现的
（3）小结
1)什么是web服务?
答：提供网页浏览功能的网站服务。
即安装了web服务软件如，httpd/nginx等软件，并启动。客户通过浏览器可以访问网站。
2)什么是Web服务器?
答：简单来理解就是安装web服务软件，并能提供Web服务的机器。
3)Web一般是分为客户端与服务器端，两者是如何交互的呢?
答：通过HTTP协议http://www.itheima.com。
4)Apache(httpd)的作用和特点?
答：Apache用于接受用户连接请求;只负责静态页面的解析。
2. 聊聊PHP · 像极了服务生
· 作用：PHP主要负责PHP脚本程序的解析以及实现与MySQL数据库的交互工作，我们项目中的注册/登录/下单/支付等大多数功能都是基于PHP+MySQL进行实现。PHP是一种通用开源脚本语言。
（1）当客户端请求的是动态资源时，Apache(httpd程序)会调用libphpX.so模块进行相应的解析。
（2）如果解析处理需要用到后台数据库相关数据，此时php程序也会连接后台数据库。
（3） 最终php程序将解析后的结果返回给Apache(httpd程序)，让Apache返回给客户端。
3. 聊聊MySQL · 像极了大厨
· 作用：MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle旗下产品。其主要作用用于永久的存储数据。【推荐了解：IT运维课程】
LAMP架构是什么？ · 像极了饭店
(1) Apache像极了饭店前台，专门用来接受客户请求，并做一些静态页面处理(只买酒水饮料)。
(2) PHP像极了服务生，他专门用来解析处理由前台不能处理的”订单”，如用户想吃一碗意大利面，服务生就需要和后厨沟通，并做相应的安排处理.然后将处理后的结果返回给前台，由前台再给用户，因为服务生太丑了，见不得人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9f33fcc0218533c443ca41a9e1b32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec3cec12ae13c39cb201c492dad1d96/" rel="bookmark">
			asp 接受post文件_Asp 代码审计项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务背景：
需要得知周某某的今年采购的其中一个项目具体信息，目前已知该成员是xxx电网。负责丰满大坝的采购人员。
整体思路如下：
找到开发公司，得到源码，审计问题，得到shell，拿到服务器，得到域控(或者终端管理)。得到个人机。下载任务文件。
得知该电网公司电网相关网站是某公司出品，得到某公司对外宣传网站，并且得到该公司服务器权限，下载源码模板。
源码审计：
全局共计2个主要文件，分别是Funcon.asp，Startup.asp
后台验证项：
Function.asp
来源验证
注入验证：(目标服务器waf，遂放弃)
错误处理
XSS字符处理：
错误处理
直接输入admin/下文件名处理
目录生成：针对iis6以及iis7 php版本
Startup.asp配置文件：当不可以执行的时候，是否可以备份出数据库，以便下载。
关于新闻显示，全局incude head.asp
其中check_si.asp 主要为防止注入
Get注入
Post 注入 新版本中加入post注入过程中遇到服务器卡顿现象，也就是不清楚列名数，本地二分法测试如下：
在admin 目录下有个database.asp文件
目标测试：根据以上信息，构造referrer，构造参数，禁止js。产生出越权漏洞。
根据越权漏洞，继续看upload.asp文件，允许匿名上传图片文件。在根据越权漏洞备份出webshell文件
82：
得到webshell
对方没有开启远程桌面：
开启：
REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD/d 00000000 /f
通过该服务器得到mssql 数据库。得到终端管理权限。
查看在线机器，查找目标人物。
推送payload 反弹。
确定是否为目标人物：采购员桌面截图
按照任务取得该人员的其中一个xls文件
任务完成。
任务完成。
文章来源：https://micropoor.blogspot.com/
你可能喜欢
满满的干货，代码审计资料整理免费分享！
代码审计入门总结
代码审计报告
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43bfaf3d9f42182696bea212d63d3ac9/" rel="bookmark">
			鸿合一体机触屏没反应怎么办_一体机屏幕触摸不准的原因以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：一体机屏幕触摸不准的原因以及解决方法
在使用触摸屏一体机的时候，由于我们的使用方法不正当，用手指触摸显示器屏幕的部位不能正常地完成对应的操作，这种现象可能是触摸屏的校对有问题，针对触摸屏触摸不够精准的问题触摸一体机厂家来教您解决办法。
触摸一体机的触摸屏为什么不准?
问题1：可能是触摸一体机在使用一段时间后，一体机屏四周的反射条纹上面被灰尘覆盖。
解决办法：用一块干的软布进行擦拭，然后断电重新启动计算机并重新校准
问题2：可能是触摸一体机屏的反射条纹受到轻微破坏，无法完全修复。
触摸一体机的触摸屏为什么触摸无响应?
问题1：可能是触摸一体机触摸屏的连线中，其中一个连接主机键盘口的连线没有连接，请检查连线。
问题：可能是触摸一体机的触摸屏的驱动程序没有相对应触摸屏实际安装的串口号进行安装，请从新安装驱动程序。
在下列情况下可运行屏幕校准程序:(打开桌面上的触摸屏软件校对程序)
①第一次完成驱动软件的安装；
②每次改变显示器的分辨率或显示模式后；
③每次改变了显示的显示区域后；
④每次调整了控制器的频率后；
⑤每次光标与触摸点不能对应时。
融合了人机交互、平板显示、多媒体信息处理和网络传输等多项技术显示模式、主持人可全程无盲点完全触摸显示内容进行电视节目讲解，并与观众互动，具备书写、绘画、批注、可为电视观众抓住目光，让专注度进一步提高。返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebba1662381eec76d713cfac8a0f2e1d/" rel="bookmark">
			elif在python中啥意思_python中的elif是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elif是else if的简写。else和elif语句也可以叫做子句，因为它们不能独立使用，两者都是出现在if、for、while语句内部的。else子句可以增加一种选择；而elif子句则是需要检查更多条件时会被使用，与if和else一同使用。
实例：people = 30
cars = 40
buses = 15
if cars &gt; people:
print( "We should take the cars.")
elif cars &lt; people:
print ("We should not take the cars.")
else:
print ("We can't dicide.")
if buses &gt; cars:
print ("That's too many buses.")
elif buses &lt; cars:
print ("Maybe we could take the buses.")
else:
print ("We still can't decide.")
if people &gt; buses:
print ("Alright, let's just take the buses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebba1662381eec76d713cfac8a0f2e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93692f095ad3801df8d20da82fd15b54/" rel="bookmark">
			计算机图形学学习笔记：规则形体的表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实体模型的三类表示：
边界表示（Boundary Representation, B-reps），即用一组曲面（含平面）来描 述物体，这些曲面将物体分为内部和外部。
边界表示具体又包括多边形表面模型和扫 描表示两种。
构造实体几何表示（Constructive Solid Geometry，CSG），它将实体表示成立 方体、长方体、圆柱体、圆锥体等基于体素的组合，可以采用并、交、差等运算构造新的形体。
空间分割表示（Space-Partitioning），用来描述物体的内部性质，将包含一物体的空间区域划分成一组小的、非重叠的、连续实体（通常是立方体）。
多边形表面模型 边界表示(B-reps)的最普遍方式是多边形表面模型，它使用一组包围物 体内部的平面多边形，也即平面多面体，来描述实体。
表面模型的数据结构如下图：
对于一个多边形平面，其几何信息用几何表来组织，它包括顶点坐标和标识多边形平面空间方向的参数。具体包括：顶点表、边表、多边形表。
任何多边形平面都有两个面，内侧面和外侧面。一般来说，法向量方向指向物体外部。当多边形顶点序列指定后，它满足右手定则。
除了这三张表给出的几何信息外，还需要增加额外的信息来表示其拓扑信息。例如， 将边表扩充成包括指向面表和顶点表的指针。如下图的例子：
由此可构造出翼边结构表示（Winged Edges Structure），它对于一个多面体的每一 条边指出它的两个相邻面、两个端点，以及四条邻边。这四条邻边好象伸展的翅膀， 所以叫翼边结构表示。
在存储多边形的几何信息和拓扑信息后，还需要用属性表存储多边形面的属性，指明 物体透明度、表面材质和纹理特征等。
多边形网格：
三维形体的曲面边界通常用多边形网格（polygon mesh）的拼接来模拟。这些多边形往往是简单的三角形或四边形。
下图是Maya中的多边形网格：
构造实体几何表示 在构造实体几何法中，集合运算的实现过程可以用一棵二叉树（称为CSG树）来描述：
其中，树的叶子表示基础几何对象，非终端节点表示交并差补操作，根节点就是最终的CSG对象。
这种方法的优缺点如下：
优点：如果体素设置比较齐全，通过集合运算就可以构造出多种不同的符合需要的实体。
缺点：当用户输入体素时，主要是给定体素的有关参数，然后由系统给出该体素的表面方程，再由系统进行集合的求交运算，最后得到生成的实体。
这里面存在两个问题：
（1）一是集合运算的中间结果难以用简单的代数方程表示，求交困难；
（2）CSG树不能显式地表示形体的边界，因而无法直接显示CSG树表示的形体。
为了解决这两个问题，引入了光线投射算法。
光线投射算法
光线投射算法的核心思想是从显示屏幕（投影平面）的每一象素位置发射一根光线（射线）， 求出射线与距离投影平面最近的可见表面的交点和交点处的表面法矢量，然后根据光照模型计算出表面可见点的色彩和亮度，生成实体的光栅图形。
该算法的关键之处在于确定光线与距离投影平面最近的可见表面的交点，这可以通过集合成员分类算法实现。
具体算法步骤：
(1)将射线与CSG树中的所有基于体素求交，求出所有的交点；
(2)将所有交点相对于CSG树表示的物体进行分类，确定位于物体边界上的那部分交点；
(3)对所有位于物体边界上的交点计算它们在射线上的参数值并进行排序，确定距离最 近的交点。
空间分割表示 有三种表示方法：空间位置枚举表示、八叉树、BSP树。
空间位置枚举表示
将包含实体的空间分割为大小相同、形状规则（正方形或立方体）的体素，然 后，以体素的集合来表示图形对象。
用三维数组P[I][J][K]表示物体，数组中的元素与单位小立方体一一对应。
如上图，当P[I][J][K] = 1时，表示对应的小立方体被物体占据。当P[I][J][K] = 0时，表示对应的小立方体没有被物体占据
八叉树
八叉树（octrees）又称为分层树结构，它对空间进行自适应划分，采用具有层次结构的八叉树来表示实体。
下图展示了平面区域的四叉树表示：
对于3维实体，就需要八叉树来表示了。如下图所示，八叉树表示的形体非常容易进行集合运算：
BSP树
二叉空间分割（Binary Space Partitioning，BSP）方法每次将一实体用任一位置和任一方向的平面分为二部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93692f095ad3801df8d20da82fd15b54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac78fcb746808c2ba0415fbf51e31f2/" rel="bookmark">
			2020Android 开发年度总结：“这一年里我到底做了些啥，掌握了哪些技术？”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 眼看2020年还有两天就要结束了，即将迎来2021新的一年。感觉今年比起往年要过稍稍的快一些，因为2020的开年工作时间比以往是晚了许多，基本都是在3月份左右开始投入工作。而以往基本都是大年初八左右，人们都开始投入工作了。
小编把自己这一年的一些事件进行了总结，请看下方
本人是一名Android 开发者，毕业3年，年龄到了人们常说的中年危机的年纪。30岁之前就常常在各大社交博客平台上看到一些程序员中年危机和Android 不行了等相关帖子，刚开始我还是有点慌，在想当初选择走开发这条道路是不是错的？要不要趁早转行从事别的工作？
本不焦虑的自己，反到被这些话题帖子给弄焦虑了。最后自己静下心来想了想，这些事情还没有发生到自己身上，为什么要去想这么多，自己吓自己，在这里浪费自己的时间呢？有这些时间还不如去多写几行代码，去深入研究技术，说不定自己可以通过技术去突破这个危机呢。
直到现在我终于明白了，30岁并没有什么中年危机，只是一些遇到技术瓶颈的同行在造谣罢了。
为什么这么说呢？ 如果是一个公司的老板或者管理者，你手下有一批多年开发经验的技术人员，他们的技术水平能力都不等。突然有一天你招聘了一个没有什么开发经验的毕业实习生，而这个毕业生又肯勤奋的学习，没过几个月，技术能力水平有明显的进步，甚至可以与一些多年开发经验的老员工不相上下。等到了公司需要裁员的时候，你觉得公司会怎么选择呢？想必大家的想法是我一样，肯定是优先裁掉技术能力和水平排在末位的人员，现在这个时代是非常现实的。所以我们要一直保持学习的心态去工作，这样才能更好的进步。
作为Android 开发现在需要深入学习的技术有哪些呢？ 我为大家总结了八大版块，分别是项目开发底层技术、Android Q FrameWork源码与UI、APP调优技术、音视频技术、架构技术、 Gradle、Kotlin、混合开发技术等。
1.项目开发底层技术
2.Android Q FrameWork源码与UI
3. APP调优技术
4.音视频技术
5.架构技术
6. Gradle技术
7.Kotlin技术
8.混合开发技术
这八大版块里面的技术知识点，基本都是现在市场上的主流技术。就拿音视频技术来说，现在市场会音视频开发技术的人才并不多，而有许多公司在高薪聘请会音视频开发的技术人才，大家可以在各大招聘网站上可以看的基本都是在20K起步，大家可以看下图。
这是因为互联网发展日新月异的今天，人们的社交需求也在不断升级。一直以来，社交平台持续探索新的互动方式，以满足人们不断更迭的社交需求。从2018年火爆的直播，再到越来越被大众依赖的实时音视频通话，高速发展的通信技术为社交平台的探索提供了更多可能。
随着5G的普及，将会改变人与人之间、人与物之间的沟通方式。以后图文沟通的方式会越来越少，而音视频通话则将成为主流
这也催生出大量的音视频通话相关的需求。但目前具备开发音视频通话能力的开发者，可谓是少之又少。
这说明现在学习好音视频技术前景还是非常不错的。如果想割这波韭菜就要趁早了。
为了能够帮助到大家更有效快速的切换至学习的状态，少踩点坑，我把我之前学习的一些知识点笔记等进行了整理，如有需要参考学习的小伙伴可以加入Android 粉丝裙:872206502获取学习资料。
QQ扫码快速通道
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5bd11007cf3012a7aa4ebedf8d9860/" rel="bookmark">
			全新版大学英语综合教程3(课后答案)完全版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全新版大学英语综合教程3课后答案，部分截图如下
太多了，就不在一一复制，可以扫描下方二维码，关注微信公众“数据结构和算法”，回复新版大学英语的拼音简称xbdxyy即可获得下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1cf2d9f428314074ba2ff4365c9890b/" rel="bookmark">
			umi.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 umi使用步骤 相关配置 在.umirc.ts文件中配置hash为true时，打包完dist目录下的js和css文件会生成随机hash值
配置base则会改变首页文件的访问路径,配置的时候还要一起配置一个publicPath，一般和base相同，添加这个的目的就是在dist生成的index里面引入的css和js也会加入这个前缀不然引入不到，它们默认都是’/’
配置outputPath可以更改build完的文件名，默认是dist，这里改成’abc’
配置title可以更改网页标题，单独组建想定义的话就写在routes里面
默认的模板在包里面的@umijs的core里lib里的Html里的document.ejs，但是要修改模板文件的话如下图，配置这个文件主要是有些第三方的组件可能在npm里面没有，只能在页面中用script和link标签引入
配置路由组件他是会默认匹配的，只要在src下创建组件同名目录，然后在底下创建一个index.js就可以啦,重定向就是输入这个路径它会自动马上跳转到指定的路径，子路由就是在里面再套一个routes，子路由的用处就是你把它这个组件写在其他页面的某个地方，只有在访问到你这个子路由的路径时这个组件才会显现出来，具体可以看官方文档,还可以配置title，redirct啥的
routes: [ { path: '/', component: '@/pages/index','title':'首页'，routes:[{ path: '/user', component: '@/pages/user','title':'用户列表'}] }, ], 组件里面就是用props.children属性放在想要的位置，去往固定的路由地址就会显示相应的子组件
Link和react引用的方式相同，但是是引用自umi
NavLink就是导航式链接，到达对应路由的时候，导航的样式会发生相应设置的变化(每个NavLink都有一个active类名，可以在上面设置样式)
Mock
在.umirc.ts里面配置mock:false会默认关闭mock相关配置
mock文件夹下面是mock的相关文件，这里面写的东西就是等下axios请求来的东西
mock里面不需要走的文件
mock的文件大概这么写
umi中使用dva npm install -D dva 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d3f6aff27876f69e07daae33fda71f/" rel="bookmark">
			2020-12-27
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 迁移学习是当前深度学习领域的一系列通用的解决方案，而不是一个具体的算法模型。Pre-training + fine-tuning（预训练+调参） 的迁移学习方式是现在深度学习中一个非常流行的迁移学习方式，尤其是以图像领域为代表，很多时候会选择预训练的 ImageNet对模型进行初始化。
在迁移学习中，有几个概念，domain（域）和task（任务） 、source（源） 和target（目标）需要理清楚。
- domain：一般指的是特征空间和概率分布 - task:包含标记空间和目标预测函数
- source和target：前者是用于训练模型的域/任务，后者是要用前者的模型对自己的数据进行预测/分类/聚类等机器学习任务的域/任务。
迁移学习的种类根据迁移的内容可以归纳为以下几种：
-Instance-based TL（样本迁移）：source domain数据不可以整个直接被用到target domain里，但是在source domain中还是找到一些可以重新被用到target domain中的数据。对它们调整权重，使它能与target domain中的数据 匹配之后可以进行迁移。
- Feature-representation-transfer（特征迁移）：找到一些好的有代表性的特征，通过特征变换把source domain和target domain的特征变换到同样的空间，使得这个空间中source domain和target domain的数据具有相同的分 布。
- Parameter-transfer（参数/模型迁移）：假设source tasks和target tasks之间共享一些参数，或者共享模型hyperparameters（超参数）的先验分布。这样把原来的模型迁移到新的domain时，也可以达到不错的精度。Pre-training + fine-tuning 的迁移学习方式就可以理解为是一种Parameter-transfer，这种方法也是最常用的迁移学习的应用。
在Pre-training + fine-tuning模式下的迁移学习过程中，常用的训练trick和调参方法总结有如下几点：
- 把预训练模型当做特征提取器： TensorFlow或者Pytorch都有ImageNet上预训练好的模型，将最后一层全连接层（原始的是1000个类别或者更多）改成你自己的分类任务的种类进行输出，或者把最后一层直接去掉换成自己的分类器， 剩下的全部网络结构当做一个特征提取器。
-fine-tuning： 通常来说，直接把预训练模型来用效果不一定足够好，因此需要进行fine-tuning（微调）。fine-tuning需要冻结网络的前几层参数，只更新网络结构的后面几层和最后的全连接层，这样效果会更好。
-Learning rate： 在迁移学习的微调过程中一般不建议使用过大的学习率，通常来说1e-5是比较合适的选择。
迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。
新的数据集较小，并且和pre-trained model所使用的训练数据集相似度较高： 由于数据集较小，在进行finetune存在overfit的风险，又由于数据集和原始数据集相似度较高，因此二者不论是local
feature还是global feature都比较相 近，所以此时最佳的方法是把CNN网络当做特征提取器然后训练一个分类器进行分类新的数据集较大，并且和pre-trained model所使用的训练数据集相似度较高： 很明显，此时我们不用担心overfit（过拟合），因此对全部网络结构进行finetune是较好的。新的数据集较小，并且和pre-trained model所使用的训练数据集差异很大： 由于数据集较小，不适合进行finetune，由于数据集差异大，应该在单独训练网络结构中较高的层，前面几层local的就不用训练了，直接固定权值。在实际
中，这种问题下较好的解决方案一般是从网络的某层开始取出特征，然后训练SVM分类器。新的数据集较大，并且和pre-trained model所使用的训练数据集差异很大： 本来由于数据集较大，可以从头开始训练的，但是在实际中更偏向于训练整个pre-trained model的网络。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75aa3d033d7c4b03386b1e123dda19a9/" rel="bookmark">
			C&#43;&#43;版本OpenCv教程(十二)图像像素统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以将数字图像理解成一定尺寸的矩阵，矩阵中每个元素的大小表示了图像中每个像素的亮暗程度，因此统计矩阵中的最大值，就是寻找图像中灰度值最大的像素，计算平均值就是计算图像像素平均灰度，可以用来表示图像整体的亮暗程度。因此针对矩阵数据的统计工作在图像像素中同样具有一定的意义和作用。在OpenCV 4中集成了求取图像像素最大值、最小值、平均值、均方差等众多统计量的函数，接下来将详细介绍这些功能的相关函数。
寻找图像像素最大值与最小值 OpenCV 4提供了寻找图像像素最大值、最小值的函数minMaxLoc()，该函数的原型在代码清单3-7中给出。
void cv::minMaxLoc(InputArray src, double * minVal, double * maxVal = 0, Point * minLoc = 0, Point * maxLoc = 0, InputArray mask = noArray()) src：需要寻找最大值和最小值的图像或者矩阵，要求必须是单通道矩阵minVal：图像或者矩阵中的最小值。maxVal：图像或者矩阵中的最大值。minLoc：图像或者矩阵中的最小值在矩阵中的坐标。maxLoc：图像或者矩阵中的最大值在矩阵中的坐标。mask：掩模，用于设置在图像或矩阵中的指定区域寻找最值。
这里我们见到了一个新的数据类型Point，该数据类型是用于表示图像的像素坐标，由于图像的像素坐标轴以左上角为坐标原点，水平方向为x轴，垂直方向为y轴，因此Point(x,y)对应于图像的行和列表示为Point(列数，行数)。在OpenCV中对于2D坐标和3D坐标都设置了多种数据类型，针对2D坐标数据类型定义了整型坐标cv::Point2i(或者cv::Point)、double型坐标cv::Point2d、浮点型坐标cv::Point2f，对于3D坐标同样定义了上述的坐标数据类型，只需要将其中的数字“2”变成“3”即可。对于坐标中x、y、z轴的具体数据，可以通过变量的x、y、z属性进行访问，例如Point.x可以读取坐标的x轴数据。 该函数实现的功能是寻找图像中特定区域内的最值，函数第一个参数是输入单通道矩阵，需要注意的是，该变量必须是一个单通道的矩阵数据，如果是多通道的矩阵数据，需要用cv::Mat::reshape()将多通道变成单通道，或者分别寻找每个通道的最值，然后再进行比较寻找到全局最值。对于cv::Mat::reshape()的用法，在代码清单3-8中给出。第二到第五个参数分别是指向最小值、最大值、最小值位置和最大值位置的指针，如果不需要寻找某一个参数，可以将该参数设置为NULL，函数最后一个参数是寻找最值得掩码矩阵，用于标记寻找上述四个值的范围，参数默认值为noArray()，表示寻找范围是矩阵中所有数据。
Mat cv::Mat::reshape(int cn,int rows = 0) cn：转换后矩阵的通道数。rows：转换后矩阵的行数，如果参数为零，则转换后行数与转换前相同。
注意
如果矩阵中存在多个最大值或者最小值时，minMaxLoc()函数输出最值的位置为按行扫描从左向右第一次检测到最值的位置，同时输入参数时一定要注意添加取地址符。
为了让读者更加了解minMaxLoc()函数的原理和使用方法，在代码清单3-9中给出寻找矩阵最值的示例程序，在图3-6中给出了程序运行的最终结果，在图3-7给出了创建的两个矩阵和通道变换后的矩阵在Image Watch中查看的内容。 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;string&gt; #include &lt;opencv2/opencv.hpp&gt; #include "opencv/highgui.h" using namespace std; using namespace cv; int main(int argc,char** argv) { cout&lt;&lt;"OpenCv Version: "&lt;&lt;CV_VERSION&lt;&lt;endl; float a[12]={1,2,3,4,5,10,6,7,8,9,10,0}; Mat img=Mat(3,4,CV_32FC1,a);//单通道矩阵 Mat imgs=Mat(2,3,CV_32FC2,a);//多通道矩阵 double minVal,maxVal;//用于存放矩阵中的最大值和最小值 Point minIdx,maxIdx;//用于存放矩阵中的最大值和最小值的位置 /*寻找单通道矩阵中的最值*/ minMaxLoc(img,&amp;maxVal,&amp;minVal,&amp;minIdx,&amp;maxIdx); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75aa3d033d7c4b03386b1e123dda19a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742ddf1538e9b3ea3c2776c063540fe6/" rel="bookmark">
			Oracle 定时任务详解（dbms_scheduler）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 概述1.1 思维导图 2 语法2.1 核心三要素2.1.1 program 程序2.1.2 schedule 计划表2.1.3 job 工作 2.2 核心属性2.2.1 type、action2.2.2 repeat_interval 3 示例3.1 创建带参数的过程 job3.2 创建无日志 job 1 概述 1. dbms_scheduler 包概念： "分而治之" (1) 替代了之前的 dbms_job 包，功能更加强大，可以将 job 需要的 '各种资源分开再进行组合' (2) 核心三要素：'schedule', 'program' 和 'job' 其它都是围绕它们来的 (3) 除了单个 job，还能设置 job 组 2. 主要视图 (1) 基础信息查询 select * from dba_scheduler_programs t; select * from dba_scheduler_program_args t; -- 过程参数 select * from dba_scheduler_schedules t; select * from dba_scheduler_jobs t; (2) 执行信息查询 select * from dba_scheduler_running_jobs t; select * from dba_scheduler_job_log t; select * from dba_scheduler_job_run_details t; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/742ddf1538e9b3ea3c2776c063540fe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea82dd3c90f477bf1411f91948637f4/" rel="bookmark">
			spring实现druid使用ssh连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中，由于数据安全管理需要，mysql等重要数据库往往只允许主机后内网地址访问，程序连接时只能用ssh连接，以下为spring框中ssh连接mysql思路与方案
1.引入ssh代理jar
&lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; 2.重载BeanPostProcessor类，在druid连接数据库前设置ssh隧道,druid连接时使用ssh隧道进行mysql连接。注意spring框架中初始化化com.alibaba.druid.pool.DruidDataSource前，程序将进行mysql连接初始化，将要在初始化前设置ssh隧道；
3.设置ssh隧道，先查询druid连接数据的bean名字
示例中连接msyql的配置文件bean名字为dataSource_jeecg
在程序中新BeanPostProcessor类
package com.jeecg.commons.web; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; import org.springframework.stereotype.Component; import com.jcraft.jsch.JSch; import com.jcraft.jsch.Session; @Component public class MyBeanPostProcessor implements BeanPostProcessor{ /* * 本方法一定要返回bean对象 */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if("dataSource_jeecg".equals(beanName)) {	System.out.println(beanName+"对象初始化前..."); ssh(); } return bean; } /* * 本方法一定要返回bean对象 */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return bean; } //本地端口，对应jdbc:mysql://localhost:3306/abc?useUnicode=true&amp;characterEncoding=UTF-8中的3306 public static final int lmport=3306; public static final int rmport=3306;//mysql端口 public static String rhost="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea82dd3c90f477bf1411f91948637f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9393ec8a4daaaa3936caa5f47678c1/" rel="bookmark">
			错误: ‘shared_ptr’ in namespace ‘std’ does not name a type的解决方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误: ‘shared_ptr’ in namespace ‘std’ does not name a type的解决方法。
参考文章：
（1）错误: ‘shared_ptr’ in namespace ‘std’ does not name a type的解决方法。
（2）https://www.cnblogs.com/darklights/p/10552687.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e699d524ef5fb63a73769aa74140c8f/" rel="bookmark">
			LLD-LLVM链接器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLD-LLVM链接器
LLD是LLVM项目中的链接器，是系统链接器的直接替代，并且运行速度比它们快得多。它还提供了对工具链开发人员有用的功能。
链接器按完整性降序支持ELF（Unix），PE / COFF（Windows），Mach-O（macOS）和WebAssembly。在内部，LLD由几个不同的链接器组成。ELF端口是本文档中将要描述的端口。PE / COFF端口已完成，包括Windows调试信息（PDB）支持。WebAssembly端口仍在开发中（请参阅WebAssembly lld port）。Mach-O端口是基于与其他端口不同的体系结构构建的。有关Mach-O的详细信息，请阅读ATOM-based lld。
特征功能
• LLD是GNU链接器的直接替代，它接受与GNU相同的命令行参数和链接器脚本。
目前正在与FreeBSD项目紧密合作，以使LLD在操作系统的未来版本中成为默认系统链接器，因此非常重视解决兼容性问题。LLD能够链接包括内核在内的整个FreeBSD / amd64基本系统。使用一些正在进行的补丁程序，它可以链接AMD64上大约95％的端口集合。有关详细信息，请参见FreeBSD quarterly status report。
• LLD非常快。在多核计算机上链接大型程序时，可以预期LLD的运行速度是GNU gold链接器的两倍以上。但是，里程可能会有所不同。
• 它支持各种CPU / ABI，包括AArch64，AMDGPU，ARM，Hexagon，MIPS 32/64大/小端，PowerPC，PowerPC64，RISC-V，SPARC V9，x86-32和x86-64。其中，AArch64，ARM（&gt; = v6），PowerPC，PowerPC64，x86-32和x86-64具有生产质量。MIPS似乎也不错。
• 它始终是交叉链接器，这意味着无论它是如何构建的，它始终支持上述所有目标。实际上，没有提供构建时选项来启用/禁用每个目标。链接器轻松用作交叉编译工具链的一部分很容易。
• 可以将LLD嵌入程序中，以消除对外部链接程序的依赖。要做的就是构造目标文件和命令行参数，就像调用外部链接器然后lld::elf::link从代码中调用链接器的主要功能一样 。
• 正在使用LLVM libObject库从目标文件读取数据，因此这并不是一个完全公平的比较，LLD / ELF仅包含2万1千行C ++代码，而GNU gold由19.8万行C ++代码构成。
• 默认情况下支持链接时间优化（LTO）。本质上，要做LTO所需要做的就是将-flto选项传递给clang。然后clang创建的对象文件不是本机目标文件格式，而是LLVM位码格式。LLD读取位码目标文件，使用LLVM对其进行编译并发出输出文件。因为以这种方式LLD可以看到整个程序，所以它可以对整个程序进行优化。
• 古老的Unix系统（90年代以前甚至更早）的一些非常古老的功能已被删除。一些默认设置已进行了调整。例如，默认情况下，将堆栈标记为不可执行以加强安全性。
性能
这是在2插槽20核40线程Xeon E5-2680 2.80 GHz带有SSD驱动器的计算机上的链接时间比较。在有或没有多线程支持的情况下都发挥了作用。为了禁用多线程，添加-no-threads了命令行。
如表所见，lld的速度明显快于GNU链接器。请注意，这只是环境的基准结果。根据可用核心数，可用内存量或磁盘延迟/吞吐量，结果可能会有所不同。
由于GNU ld不支持-icf=all and -gdb-index选项，因此从GNU ld的命令行中删除了。如果拥有这些选项，GNU ld将会比这慢。
构建
如果已经使用SVN检出了LLVM，则可以在tools中像clang一样检出目录下的LLD 。有关详细信息，请参阅Getting Started with the LLVM System。
如果尚未签出LLVM，构建LLD的最简单方法是，从git镜像签出整个LLVM项目/子项目并构建该树。需要cmake，当然也需要C ++编译器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e699d524ef5fb63a73769aa74140c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8968df6d3fb74db7ceca6a771cd0325a/" rel="bookmark">
			幻宇树莓派麦克纳姆轮小车：建图导航快速体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、远程连接机器人
查看PC端的ip，及时更改/.bashrc文件
ifconfig subl /.bashrc ssh huike@192.168.12.1 1、重启机器人nfs
sudo /etc/init.d/nfs-kernel-server restart 2、将代码挂载到PC端
sudo mount -t nfs 192.168.12.1:/home/huike/robot_ws /mnt 等待程序完全挂载，大概两分钟时间。
3、将机器人放置一个空间内，在机器人周围距障碍物至少50厘米，保证建图之后地图膨胀之后机器人不会处在障碍物当中。
（1）启动机器人：
roslaunch huanyu_robot_start Huanyu_robot_start.launch （2）启动建图节点：
roslaunch huanyu_robot_start gmapping_slam.launch 确保能看到First Scan字样，说明第一束激光已经收到，建图节点已经开启。
（3）启动rviz
添加Map、LaserScan、RobotModel。注意Fixed Frame选择map。
（4）启动遥控器（手柄）节点
roslaunch huanyu_joy huanyu_ps2_control.launch （5）用手柄控制机器人移动，扫描地图，机器人移动速度要慢一点，建图才能准确。
（6）保存地图
新建终端，进入到map文件夹下：
ssh huike@192.168.12.1 cd robot_ws/src/huanyu_robot_start/map/ ls 可以看到有之前保存下来的两个地图，将其删掉
sudo rm map.* ls 发现文件夹下面没有东西了，将新的地图保存在该文件夹下：
rosrun map_server map_saver -f map 新的地图名字仍为map，不要更改别的名字，否则需要更改代码。可以看到生成的两个map.*文件，此时这个终端可以退出为PC端，然后关掉。
exit （7）导航
可以把所有的机器人终端节点ctrl+c掉（不要叉掉），然后将手柄节点exit，然后关掉；将rviz节点ctrl+c，将机器人放置在建图之前的位置，方向位置不要太大的偏差。
重新启动机器人：
roslaunch huanyu_robot_start Huanyu_robot_start.launch 启动导航：
roslaunch huanyu_robot_start teb_navigation_slam.launch 注意：出现黄色的说明数据可能有一点偏差，不要紧。出现红色的错误说明机器人没有定位，需要把机器人放到起点，重新启动机器人，启动导航。看到odom received!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8968df6d3fb74db7ceca6a771cd0325a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625cbb48b430be4100fe5916ba38e38f/" rel="bookmark">
			UWB测距数据处理java源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UWB测距是利用UWB技术实现点对点或者1对多测距的应用，华星智控UWB无线脉冲测距设备可以用于天车定位，人车防撞，远距离无线测距等应用，下面介绍下如何处理测距基站输出的数据。
处理收到的原始数据
package Model; import java.util.Vector; import PublicMethod.DellMessage; import PublicMethod.Jiaoyan; /** @@author 北京华星北斗智控技术 */ public class DellHex implements Runnable {	//收到的原始数据集合，将收到的数据包拆分为2个字符一组放入该集合 static Vector&lt;String&gt; hexvc=new Vector&lt;&gt;(); //处理数据到什么状态了 int usart_state=0; //数据位的长度 int pack_len=0; //收到的数据类型 String type="";//数据类型 //线程休眠的时间 int sleeptime=0; //完整的数据包 static StringBuffer pack_cmd=new StringBuffer(); /**向集合插入一条数据*/ public static void insert_adata(String hex) { hexvc.add(hex); } /**用于处理接收到的报文数据*/ public void dellhex() { //原始数据集合的长度 int size=hexvc.size(); //如果原始数据集合长度等于0代表没有数据，让线程休眠100毫秒等待集合有数据 if(size==0) { sleeptime=100; }else { sleeptime=0; String hex=hexvc.get(0).toUpperCase(); //将原始数据集合中的第一条数据取出放入swich循环 switch(usart_state) { case 0: //如果数据是55则执行	if(hex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625cbb48b430be4100fe5916ba38e38f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a61387d76ebd39fbdf2be3820ab5e215/" rel="bookmark">
			Openlayers 投影与坐标转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Openlayers 投影与坐标转换 在初始化map实例时，如果不在view中用projection参数指定投影坐标系，则将会使用默认的空间参考EPSG:3857(Web 墨卡托投影)。后续叠加的图层，都会将数据进行投影转换，确保map在同一个空间参考内。
EPSG(European Petroleum Survey Group，欧洲石油调查组织)负责维护并发布坐标参照系统的数据集参数，以及坐标转换描述。它将已有的椭球体，投影坐标系等及其不同组合都对应着不同的ID号，这个号在EPSG中被称为EPSG code，它代表特定的椭球体、单位、地理坐标系或投影坐标系等信息。
Openlayers中的指定空间参考可以直接使用EPSG code指定，如EPSG:4326，因为ol.proj.Projection已经帮我们定义好EPSG:4326和EPSG:3857这两个空间参考的参数，同时也为这两个空间参考定义了一些别名，如EPSG:3857的EPSG:102100、EPSG:102113、EPSG:900913这些曾用名，也有用于识别GML要素的http://www.opengis.net/gml/srs/epsg.xml#3857和urn:ogc:def:crs:EPSG:6.18:3:3857。
空间参考的别名可以使用proj4js的defs()方法添加：
proj4.defs('urn:x-ogc:def:crs:EPSG:4326', proj4.defs('EPSG:4326')); ol对于其他空间参考，可以使用proj4js进行自定义。defs()方法定义，register()方法进行注册。
proj4js是一个JavaScript库，是一个强大的通用坐标转换引擎，可以同时进行大规模地图投影和高精密度的坐标转换。
proj4.defs( 'EPSG:21781', '+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +k_0=1 ' + '+x_0=600000 +y_0=200000 +ellps=bessel ' + '+towgs84=660.077,13.551,369.344,2.484,1.783,2.939,5.66 +units=m +no_defs' ); register(proj4); 自定义的投影必须是在https://epsg.io/可以找到的才有效。
常用参数列表：
参数描述+proj投影名称，安装proj后可以使用proj - l命令查看支持的投影名称+lat_0维度起点+lon_0中央经线+x_0东（伪）偏移量+y_0北（伪）偏移量+ellps椭球体名称,使用proj -le 命令查看支持哪些椭球体+units水平单位，meters（米）。使用proj -lu命令查看PROJ支持的单位+lat_ts有效纬度范围+a椭球体长半轴长度+b椭球体短半轴长度+k比例系数（比例因子），旧版本，不赞成使用+k_0比例系数（比例因子）+vunits垂直单位+datum基准面名称，使用proj -ld命令查看支持的基准面+towgs843参数或7参数基面转换+to_meter将水平单位转换为米计算输出转换参数，如：1英尺=+no_defs不要使用proj库中的缺省定义文件。 下面使用OSM地图作为示例图层，定义CGCS2000的空间参考。
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="css/ol.css" type="text/css"&gt; &lt;style&gt; .map { height: 85vh; width: 100%; } &lt;/style&gt; &lt;script src="lib/ol.js"&gt;&lt;/script&gt; &lt;!--引入proj4.js--&gt; &lt;script src="lib/proj4.js"&gt;&lt;/script&gt; &lt;title&gt;OpenLayers example&lt;/title&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a61387d76ebd39fbdf2be3820ab5e215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4edec364ad08b4688bfeb7f73d1e0d/" rel="bookmark">
			springboot中使用RSA加密实现密码信息的密文传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建RASUtils
package com.demo.springboot.util; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.tomcat.util.codec.binary.Base64; import javax.crypto.Cipher; import java.security.*; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; public class RSAUtils { protected static final Log log = LogFactory.getLog(RSAUtils.class); private static String KEY_RSA_TYPE = "RSA"; private static String KEY_RSA_TYPE_ALL = "RSA/ECB/PKCS1Padding"; private static int KEY_SIZE = 1024;//JDK方式RSA加密最大只有1024位 private static int ENCODE_PART_SIZE = KEY_SIZE/8; public static final String PUBLIC_KEY_NAME = "public"; public static final String PRIVATE_KEY_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a4edec364ad08b4688bfeb7f73d1e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75df9c9e6d1fa0be23d0403b289f8e4/" rel="bookmark">
			【Android】 一个crash 背后竟然暗藏玄机，速看！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 最近公司有一个需求，就是如何让App 不奔溃或者奔溃后可以自动重启?咋一听，可能你和我都会说，对可能Crash的地方try…catch 不就可以了？
然而细琢磨一下这个问题，其实并非如此简单。。。。接下来大家就跟我一起看看App Crash背后的缘由吧！
问题细化 如何让自己的App不奔溃呢？其实问题主要涉及一下几个点：
1、App为什么会Crash?
2、未捕获到的异常导致的Crash怎么办?
3、有什么办法可以让APP不奔溃呢？
4、假如App奔溃后，能否自动重启呢？
带着这几个问题，和大家分享一下我查阅到的解决方案，以下内容或多或少参阅了其他博文，请大家不要见笑。。就当是自己学习总结了下哈。
探究一：App为什么会Crash? 首先捕获程序崩溃的异常就必须了解一下java中UncaughtExceptionHandler这个接口，android沿用了此接口，在android API中通过实现此接口，能够处理线程被一个无法捕捉的异常所终止的情况。
在java API中对该接口描述如下：
在实现UncaughtExceptionHandler时，必须重载uncaughtException(Thread thread, Throwable ex)
1、如果我们没有实现该接口，也就是没有显示捕捉异常，则ex为空，否则ex不为空，thread 则为出异常的线程；
2、如果想捕获异常我们可以实现这个接口或者继承ThreadGroup，并重载uncaughtException方法。
显示处理线程异常终止的情况；
一、首先我们看下线程中抛出异常以后的处理逻辑。一旦代码抛出异常，并且我们没有捕捉的情况下，JVM 会调用 Thread 的 dispatchUncaughtException 方法
public final void dispatchUncaughtException(Throwable e) { Thread.UncaughtExceptionHandler initialUeh = Thread.getUncaughtExceptionPreHandler(); if (initialUeh != null) { try { initialUeh.uncaughtException(this, e); } catch (RuntimeException | Error ignored) { // Throwables thrown by the initial handler are ignored } } //这里会获取对应的 UncaughtExceptionHandler 对象，然后调用对应的 uncaughtException 方法 getUncaughtExceptionHandler().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a75df9c9e6d1fa0be23d0403b289f8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a06c2290c35ce8c7d5f8776e5f8273e/" rel="bookmark">
			力扣 LeetCode 915. 分割数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从左到右遍历一遍，用一个max_val记录遍历过程中遇到的最大值，用一个lmax_val记录左边子数组中的最大值，左边子数组的要求为，右边的值都大于左边的值，及当遍历到一个数字小于lmax_val时，则到该元素为止的所有值都归左边子数组，此时lmax_val=max_val。
class Solution { public: int partitionDisjoint(vector&lt;int&gt;&amp; A) { int index=0; int res=0; int lmax_val=A[0]; int max_val=A[0]; while(index&lt;A.size()-1){ index++; if(lmax_val&gt;A[index]){ res=index; lmax_val=max_val; } else{ max_val=max(A[index],max_val); } } return res+1; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761426ccc375243cb440853d0061c5d8/" rel="bookmark">
			＜img＞标签上title属性与alt属性的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a. 12alt属性是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短, 下•不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等
b. title属性为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83125d366e91c35135336dfafe6f855f/" rel="bookmark">
			Spring @Autowire 注解用于属性或构造函数的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring @Autowire 注解用于属性或构造函数的区别 背景回复1回复2回复3 本文为译文，原文链接：https://stackoverflow.com/questions/40620000/spring-autowire-on-properties-vs-constructor 背景 因此，由于我一直在使用 Spring，所以如果我要编写具有依赖项的 Service，我将这样实现：
方法 A
@Component public class SomeService { @Autowired private SomeOtherService someOtherService; } 但是我现在发现了使用另一种约定也可以实现相同目标的代码：
方法 B
@Component public class SomeService { private final SomeOtherService someOtherService; @Autowired public SomeService(SomeOtherService someOtherService){ this.someOtherService = someOtherService; } } 这两种方法都可以达到相同的目的。但是使用第二种方式有一些优势吗？对我来说，它在类和单元测试中创建了更多代码。 （必须编写构造函数，而不能使用 @InjectMocks）
有什么我不清楚的吗？ 除了将代码添加到单元测试中之外，Autowired 构造函数还有其他功能吗？ 方法 B 是进行依赖注入更优的吗？
回复1 是的，实际上建议使用方法 B（称为构造函数注入），而不是使用属性注入，它具有以下优点：
依存关系明确。在测试或在任何其他情况下实例化对象时（例如在 config 类中显式创建 bean 实例），都不会忽略此构造方法；依赖关系可以是 final，这有助于增强鲁棒性和线程安全性；您不需要反射来设置依赖项。InjectMocks 仍然可用，但不是必需的。 您可以自己创建 mocks 并通过调用构造函数将其注入。 请参阅该博客文章来获取详细信息，此文章的作者是 Spring 的一个贡献者 Olivier Gierke。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83125d366e91c35135336dfafe6f855f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653ee9fc27ac81be3ee557af1c52ba87/" rel="bookmark">
			ubuntu python安装cv2模块_Ubuntu系统下Import cv2提示no modules ...错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近利用pycharm在Ubuntu系统下调试一个Python项目，将pycharm的解释器从python2.7更换到python3.4后，程序中的Import cv2提示no modules named cv2错误。
经测试需要做两处调整可以解决此问题：
1)将usr/lib/python2.7/dist-packages中的cv2.so文件复制到usr/lib/python3.4/dist-packages
2)回到/home路径下，Ctrl+h将隐藏文件夹及文件复现，然后找到/home/.PyCharmCE2017.2/system/python_stubs下面会有两个文件夹，一个对应python2.7第三方模块的源文件，另一个对应于python3.4。只需找到python2.7下面的cv2文件夹复制到python3.4对应的文件夹下面即可。
--------------------------------------------------------我是分割线-----------------------------------------------
很遗憾，上面的方法指标不治本，在调试程序时出现错误：
ImportError: dynamic module does not define init function (PyInit_cv2)
在stackflow上搜了一波之后，类似问题说并没导出对应的初始化函数，但是具体如何导出让然不得而知。于是又尝试安装opencv-python:
sudo pip3 install opencv-python
结果问题迎刃而解。对应版本为version3.2.0.8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0caf4401cfaf614daf4ee6616c9de11/" rel="bookmark">
			vcpkg和cgal安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 下载并安装visual studio 2019 windows下最方便的安装方式就是用visual studio来安装, 并勾选使用C++的桌面开发和右侧的MSVC v142...和Windows 10 SDK。注意vcpkg会使用到$vswhereExe = "$programFiles\Microsoft Visual Studio\Installer\vswhere.exe",因此需要visual studio 2015及其以上版本才行。否则运行bootstrap-vcpkg.bat会报错。
2. 安装vcpkg 在github上下载vcpkg,然后运行如下命令
bootstrap-vcpkg.bat 将会生成vcpkg.exe文件,将此加入到环境变量。
##3. 利用vcpkg安装和卸载包
vcpkg install pkg:x64-windows vcpkg remove pkg:x64-windows 安装的包会放在cvpkg/packages下面。
4. 使用cgal 下载cgal的官方demo,然后使用cmake打开:
cd Triangulation_2 mkdir build cd build cmake-gui .. 然后利用cmake指定Boost_DIR, CGAL, GMP, MPFR
Boost_INCLUDE_DIR D:\boost_1_72_0 CGAL_DIR D:/vcpkg/packages/cgal_x64-windows/share/cgal GMP_INCLUDE_DIR D:/vcpkg/packages/mpir_x64-windows/include GMP_LIBRARIES D:/vcpkg/packages/mpir_x64-windows/lib/mpir.lib MPFR_INCLUDE_DIR D:/vcpkg/packages/mpfr_x64-windows/include MPFR_LIBRARIES D:/vcpkg/packages/mpfr_x64-windows/lib/mpfr.lib 注意安装cgal包时要使用vcpkg install cgal[qt]:x64-windows而不是直接使用vcpkg install cgal:x64-windows。安装完成之后再安装qt相关的包vcpkg install qt5:x64-windows。然后指定
Qt5_DIR D:/vcpkg/packages/qt5-base_x64-windows/share/cmake/Qt5 否则会报错:
The example draw_triangulation_2 requires Qt and will not be compiled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0caf4401cfaf614daf4ee6616c9de11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692c06d35809161898a3a1b573dd9a40/" rel="bookmark">
			可燃气体浓度多少合格_动火作业气体检测浓度多少为合格?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
每种气体不一样，要保证在32313133353236313431303231363533e59b9ee7ad9431333433636166闪点和爆炸下限之下。
闪点是指可燃气体挥发出的蒸气和空气的混合物与火源接触能够闪燃的最低温度。闪点越低，引发火灾事故的危险性越大。如常见的VOCs类汽油、苯、酒精等闪点在28以下，容易引发火灾事故。
爆炸极限也称爆炸浓度极限，是指可燃物质(可燃气体、蒸气和粉尘)与空气(或氧气)必须在一定的浓度范围内均匀混合，形成预混气，遇着火源才会发生爆炸，这个浓度范围。
例如常见的VOC：苯，其与空气混合的爆炸极限为1.5%～9.5%，前后两个数字分别称为爆炸下限和爆炸上限，这两者有时亦称为着火下限和着火上限。在低于爆炸下限时不爆炸也不着火；在高于爆炸上限时不会爆炸，但能燃烧。这是由于前者的可燃物浓度不够，过量空气的冷却作用，阻止了火焰的蔓延；而后者则是空气不足，导致火焰不能蔓延的缘故。
常见物质的爆炸极限如下，仅供参考：
常见可燃气体的爆炸下限和爆炸上限
附：混合气体的爆炸极限计算(仅供参考)
公式为：Lm=1/(Y1/L1+Y2/L2+Y3/L3)，式中：
Lm——混合VOCs爆炸极限(%);
Y1、Y2、Y3——混合物中组成(%);
L1、L2、L3——混合气体各组份相应的爆炸极限(%)。
例如：一天然气组成如下：甲烷80%(L下=5.0%)、乙烷15%(L下=3.22%)、丙烷4%(L下=2.37%)、丁烷1%(L下=1.86%)
求该天然气的爆炸下限。
解：Lm=1/(80/5+15/3.22+4/2.37+1/1.86)= 4.369%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e88364e1f725aa0db8d452dd334a1b/" rel="bookmark">
			la是什么牌子_la是什么牌子 La Prairie莱珀妮品牌护肤品怎么样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人都见过la字样的牌子，但是这个字样有很多种，像La Prairie莱珀妮就是其中的一种，今天小编就来给大家介绍关于这个品牌的品牌简介和关于这个品牌的产品到底怎么样，一起来看一下。
1la是什么牌子
la是La Prairie 莱珀妮的简称，应该是全球最昂贵的护肤品品牌，来自于瑞士，该品牌追求的永恒之美造就了这个品牌的传奇，利用精选的珍贵成分，利用先进生物技术和活细胞精华，成就了奢华的产品。
La Prairie 莱珀妮品牌的最大亮点就是富含细胞精华，通过提供人体所需要的营养成分，活化及滋养人体细胞，让细胞得到改善并强化本身肌肤的自然功能，调节人体的新陈代谢，预防和改善衰老。
La Prairie 莱珀妮品牌的招牌产品就是鱼子精华，利用罕见的鲟鱼子(Caviar)精华成分，将这些成分运用到保养品当中，能够最大程度的将人体的肌肤得以改善和保养，是护肤品中的佼佼者。
2La Prairie莱珀妮品牌护肤品怎么样
La Prairie莱珀妮品牌的护肤品可谓是贵妇的首选，一套蓝鱼子精华系列基础五件套(水+乳液+精华+眼霜+面霜50ml)的价格上万，大概是全球最昂贵的护肤品牌，效果自然就是不用说了。
La Prairie莱珀妮品牌是瑞士正经牌子，主打鱼籽提取物，精华只需要一颗，就可以涂满全脸，而且效果极佳，除了价格贵之外，其他的没有什么缺陷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea5cf908512a96785e83a2c8595c0b9/" rel="bookmark">
			高程初识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高程是指某一点相对于基准面的高度，目前常用的高程系统共有正高、正常高、力高和大地高程4种，而高程基准各国均有不同定义。高程系统则是定义某点沿特定的路径到一个参考面上距离的一维坐标系统。
高程系统 地球上某一点的高程通常用该点到所选取的基准面的垂直距离来表示，所选的基准不同，高程也会不同。以大地水准面为基准的高程系统称为正高，以似大地水准面为基准的高程系统称为正常高。zhong国的高程系统采用的是正常高系统。
大地高程 大地高程以椭球面为基准面，是由地面点沿其法线到椭球面的距离。可以采用卫星大地测量法或几何物理结合大地测量法获得。
大地水准面 大地水准面（德语：Geoid）是指地球重力场中，与处于自由静止状态的平均海水面相重合或最为接近的重力等位面。这一概念最早由德国大地测量学家卡尔·弗里德里希·高斯在1828年提出。当时，高斯以“地球的数学表面”来指称与重力方向相垂直、且与静止的平均海水面相重合的几何表面，并提出将其作为高程系统的基准面。其后，高斯的学生利斯廷于1873年创造出了“Geoid”一词，用以描述高斯所提出的数学表面。
经典定义 1873年，利斯廷提出了大地水准面的经典定义，即大地水准面是与平均海水面相重合的重力等位面。
相对论定义 1985年，瑞典大地测量学家布耶哈马基于相对论重力提出了相对论大地水准面的概念，即一个使其上所有精密时钟的运行速率相同且与平均海水面最为密合的封闭曲面。
似大地水准面 似大地水准面也称准大地水准面，是苏联科学家莫洛坚斯基研究地球形状时引入的一个虚拟的辅助面，似大地水准面是正常高的基准面，它与大地水准面之差等于正高与正常高之差。似大地水准面是由地面点沿正常重力线向下量取该点的正常高，其端点所构成的曲面。
参考维基百科
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e894b4089e27c70a77e82075a39d46/" rel="bookmark">
			mysql选出重复的字段_mysql如何标记某字段值第几次重复出现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能简单介绍下你的应用场景么？因为就此问题，解决方法从不同角度有很多样
概述
根据你的描述，我建议你使用redis，其实就是实现一个计数器功能(比如大型网站的点赞功能，文章ID就是你的A，点赞次数就是你的B)
具体实现
用INCR命令，命令说明见http://redisdoc.com/string/in...
INCR A，其中A就是redis的key，也就是你表中的字段A
例子
Redis Incr 命令将 key 中储存的数字值增一。
如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
本操作的值限制在 64 位(bit)有符号数字表示之内。
示例：
127.0.0.1:6379&gt; set num 10
OK
127.0.0.1:6379&gt; incr num
(integer) 11
127.0.0.1:6379&gt; get num # 数字值在 Redis 中以字符串的形式保存
"11"
实践证明
我们有一个web应用，我们想记录每个用户每天访问这个网站的次数。
web应用只需要通过拼接用户id和代表当前时间的字符串作为key，每次用户访问这个页面的时候对这个key执行一下incr命令。
select A,max(B) from table_x group by A, 获取每个A的最大B
直接获取每个A的最大B不就好了，B=1表示首次，B&gt;1肯定不是首次 ？ 是这个逻辑么
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ee45469328456eca7da2fc45bb91bb/" rel="bookmark">
			win10蓝牙已配对连接不上_win10系统蓝牙已配对但未连接的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴都遇到过win10系统蓝牙已配对但未连接的困惑吧，一些朋友看过网上零散的win10系统蓝牙已配对但未连接的处理方法，并没有完完全全明白win10系统蓝牙已配对但未连接是如何解决的，今天小编准备了简单的解决办法，只需要按照1、蓝牙设备的状态文本在“设置” &gt;“设备” &gt;“蓝牙和其他设备” 中发生更改； 2、蓝牙设备只有在设备真正处于使用状态时才显示为“已连接”(例如，处于连接状态并且正在播放音乐的蓝牙扬声器)。当设备未处于使用状态时，状态文本将显示为“已配对”；的顺序即可轻松解决，具体的win10系统蓝牙已配对但未连接教程就在下文，一起来看看吧！
蓝牙连接未启动的修复方法：
1、蓝牙设备的状态文本在“设置” &gt;“设备” &gt;“蓝牙和其他设备” 中发生更改；
2、蓝牙设备只有在设备真正处于使用状态时才显示为“已连接”(例如，处于连接状态并且正在播放音乐的蓝牙扬声器)。当设备未处于使用状态时，状态文本将显示为“已配对”；
3、如果你的蓝牙设备未工作，则可以尝试删除该设备，然后重新配对。在“蓝牙”设置中，依次选择已配对但并未工作的蓝牙设备 &gt;“删除设备” &gt;“是” ，然后进行确认。在此之后，重新配对该设备即可！
打开你的蓝牙音频设备并使其可发现，使其可发现的方式取决于设备。查看设备或访问制造商网站以了解操作方法.
以上便是win10系统中蓝牙已配对但未连接的有效解决方法！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa7c4c7b797f6cc93410a98c28a497f/" rel="bookmark">
			12 个 GitHub 上超火的 JavaScript 奇技淫巧项目，找到写 JavaScript 的灵感！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是你们的 猫哥，一个不喜欢吃鱼、又不喜欢喵 的超级猫 ~
前言 猫哥是一个常年混迹在 GitHub 上的猫星人，所以发现了不少好的前端开源项目、常用技巧，在此分享给大家。
1. 30-seconds-of-code 该项目讲的是满足你所有开发需求的简短代码段，里面都是些经常会用到而且是非常经典的代码，非常值得学习！
比如 JavaScript 模块就分为了 All、Array、Browser、Date、Function、Math、Node、Object、String 方便学习的。
比如：你必须知道的 4 种 JavaScript 数组方法
Array.prototype.map()
const arr = [1, 2, 3]; const double = x =&gt; x * 2; arr.map(double); // [2, 4, 6] Array.prototype.filter()
const arr = [1, 2, 3]; const isOdd = x =&gt; x % 2 === 1; arr.filter(isOdd); // [1, 3] Array.prototype.reduce()
const arr = [1, 2, 3]; const sum = (x, y) =&gt; x + y; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa7c4c7b797f6cc93410a98c28a497f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/196/">«</a>
	<span class="pagination__item pagination__item--current">197/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/198/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>