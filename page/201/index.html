<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7da1d7c12fffb2df494c745c1e48ee8/" rel="bookmark">
			tensorflow2.3&#43;多任务学习MTL保存多个模型方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		esmm模块 以下代码是一个简单的esmm的模型，当我们想保存多个模型的时候，而且线上预测的时候，不想传两个label(label1,label2)进去的时候,处理方式如下
def base_model(inputs,output, variable_scope): with tf.compat.v1.variable_scope(variable_scope): base_model = tf.keras.Model( inputs=inputs, outputs=output, name=variable_scope) return base_model # 模型 def gen_model(): input1 = tf.keras.layers.Input(shape=(2,), dtype=tf.float32, name='ty') input_layers= Dense(units=16,activation='relu')(input1) a_preds = tf.keras.layers.Dense(units=1, activation='sigmoid')(input_layers) c_preds = tf.keras.layers.Dense(units=1, activation='sigmoid')(input_layers) a_model=base_model(inputs=input1 ,output=a_preds , variable_scope='a_model') c_model=base_model(inputs=input1 ,output=a_preds , variable_scope='c_model') # output layer a_preds = tf.keras.layers.Lambda(lambda x: x, name='a')(a_preds) b_preds = tf.keras.layers.Multiply(name='b')([a_preds, c_preds]) b_model=base_model(inputs=input1 ,output=a_preds , variable_scope='b_model') a_label = tf.keras.layers.Input(shape=(1,), dtype=tf.float32, name='a_label') b_label = tf.keras.layers.Input(shape=(1,), dtype=tf.float32, name='b_label') loss_inputs = [a_label, a_preds, b_label, b_preds] def sum_loss(inputs): a_true, a_pred, b_true, b_pred = inputs a_loss = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7da1d7c12fffb2df494c745c1e48ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c04b2adf37f2f2bfab93226ca65ebad/" rel="bookmark">
			用vins_mono运行kitti（raw data）数据集并用evo评估。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、扒vins_mono源码。参考：vins_mono代码阅读笔记
二、kitti数据集没有rosbag版本，因此需要将kitti数据集录制成rosbag版本。
参考：
1、如何在kitii raw data 上跑vins_mono
注：
2、这位博主在公布了自己代码的github地址，需要运行起来需要安装很多依赖，按照步骤一点一点走就可以。
3、制作好rosbag之后，运行vins的时候将config file 的image topic 和 imu topic修改一下就可以正常运行。
三、使用evo 评估 vins_mono运行 kitti的结果
参考：
1、vins-mono保存、重载地图、evo工具测试
2、evo源码
注：
3、kitti ground truth中没有时间戳，但是可以用将kitti数据格式转为tum数据格式进行评估。
存在的问题：
4、将时长为471的Kitti数据集用vins跑了一下，轨迹混乱。可能的原因：imu的数据问题。
5、evo基本可以使用，但是vins保存的轨迹的时间戳和kitti真值的时间戳不一致，在使用evo的时候肯定会存在问题（未尝试）
记录时间：2020.12.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3450583000bc1d904ea965c046bf072e/" rel="bookmark">
			char data[0]（0长数组）用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在标准C和C++中“0长数组”如char Array[0]是不允许使用的，因为这从语义逻辑上看，是完全没有意义的。
但是，GUN中却允许使用，而且，很多时候，应用在了变长结构体中，如：下面看一段C程序：
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
typedef struct _Info
{
int i;
char data[0];
}Info;
int main(int argc, char* argv[])
{
printf("%d/n",sizeof(Info));
return 0;
}
程序的执行结果是：4。整数i就占了4个字节，这表明data没有占用空间。
1. 含义：此处，data是一个数组名，该数组没有元素；该数组的真实地址紧随结构体Info之后；这种声明方法可以巧妙的实现C语言里的数组扩展。
2. 用途 ：长度为0的数组的主要用途是为了满足需要变长度的结构体，如缓冲区，数据包等等。
3. 用法 ：在一个结构体的最后 ，申明一个长度为0的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代 表了一个不可修改的地址常量（注意：数组名永远都不会是指针！而且指针占内存空间），但对于这个数组的大小，我们可以进行动态分配，然后用字符串拷贝strcpy()或者内存拷贝memcpy()将开辟的空间拷贝给0长数组data。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8a3b1365c357545530dcdb29142c4c/" rel="bookmark">
			说明Hive中order by，sort by，distribute by，cluster by的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、order by2、sort by3、distribute by4、cluster by 笼统地看，这四个在hive中都有排序和聚集的作用，然而，它们在执行时所启动的MR却各不相同。
1、order by order by会对所给的全部数据进行全局排序，并且只会“叫醒”一个reducer干活。它就像一个糊涂蛋一样，不管来多少数据，都只启动一个reducer来处理。因此，数据量小还可以，但数据量一旦变大order by就会变得异常吃力，甚至“罢工”。
order by（ASC | DESC）:类似mysql只使用一个Reducer执行全局数据排序速度慢,应提前做好数据过滤支持使用CASE WHEN或表达式支持按位置编号排序，需要设置：set hive.groupby.orderby.position.alias=true select * from offers order by case when offerid = 1 then 1 else 0 end; select * from offers order by 1; 2、sort by sort by是局部排序。相比order by的懒惰糊涂，sort by正好相反，它不但非常勤快，而且具备分身功能。sort by会根据数据量的大小启动一到多个reducer来干活，并且，它会在进入reduce之前为每个reducer都产生一个排序文件。这样的好处是提高了全局排序的效率。
SORT BY对每个Reducer中的数据进行排序当Reducer数量设置为1时，等于ORDER BY排序列必须出现在SELECT column列表中 3、distribute by distribute by的功能是：distribute by 控制map结果的分发，它会将具有相同字段的map输出分发到一个reduce节点上做处理。即就是，某种情况下，我们需要控制某个特定行到某个reducer中，这种操作一般是为后续可能发生的聚集操作做准备。这样肯定是全局有序的，因为相同的字段会被放到同一个reducer处理，distribute by需要和sort by一起使用，distribute by必须要写在sort by之前。
distribute by ：类似mysql的group by确保具有匹配列值的行被分区到相同的Reducer不会对每个Reducer的输出进行排序通常使用在SORT BY语句之前 select id,name,score from stu_score distribute by id sort by score desc; 4、cluster by 如果sort by和distribute by中所用的列相同，可以缩写为cluster by以便同时指定两者所用的列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c8a3b1365c357545530dcdb29142c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a84a628bc4ea9cbb2ee592b75a4294/" rel="bookmark">
			element-tree 展开符号文字描述，样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图，把下三角改为“展开“ ‘’收起‘’，增加边框
要点：把左侧三角符号的显示挪到右侧，去除转换方向，icon变为文字。
实现效果主要是css，其他根据官网代码来实现
/*树形图*/ .el-tree { .el-checkbox__input.is-checked .el-checkbox__inner, .el-checkbox__input.is-indeterminate .el-checkbox__inner { background-color: #06CCC5; border-color: #06CCC5; } .el-tree-node__expand-icon.expanded { -webkit-transform: rotate(0deg); transform: rotate(0deg); } .el-tree-node__expand-icon { } .el-icon-caret-right:before { content: '展开'; display: block; width: 100% !important; height: 14px; font-size: 14px; font-family: NotoSansHans-Regular; font-weight: 400; color: rgba(153, 153, 153, 1); position: absolute; right: -395px; top: -0px; } .el-tree-node__expand-icon.expanded.el-icon-caret-right:before { content: '收起'; display: block; width: 100% !important; height: 14px; font-size: 14px; font-family: NotoSansHans-Regular; font-weight: 400; color: rgba(153, 153, 153, 1);; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a84a628bc4ea9cbb2ee592b75a4294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38823f49b1245e6f1b725ded582f39f9/" rel="bookmark">
			perl 铜板街登录接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		my $login_url = 'https://login.tongbanjie.com/web/submitlogin';
my $res = $ua-&gt;post($login_url,{
'MOBILE_DEVICE'=&gt;'PC',
'password'=&gt;'xxx',
'phone'=&gt;'18072722237',
'pictureCode'=&gt; $validCode,
# 'redirectUrl' =&gt;"https://www.tongbanjie.com/",
't'=&gt;"$now",
'tongduntokenid'=&gt;"$tongduntokenid"
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fffb519c4a585d5290f0d20eacc91d0/" rel="bookmark">
			java获取cpu数量,以及cpu使用率(cpu负载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java获取cpu数量,cpu使用率 如下是spring-boot监控服务spring-boot-starter-actuator源码中获取cpu个数,cpu使用率的方式. import com.sun.management.OperatingSystemMXBean; import java.lang.management.ManagementFactory; /** * @author luckhwb */ public class SystemUtil { private static OperatingSystemMXBean operatingSystemMXBean; static { operatingSystemMXBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean(); } /** * 获取cpu使用率 * @return */ public static double getSystemCpuLoad() { return operatingSystemMXBean.getSystemCpuLoad(); } /** * 获取cpu数量 * @return */ public static int getSystemCpuCount() { return Runtime.getRuntime().availableProcessors(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1b04e098304a812e3562d61f910f8e/" rel="bookmark">
			pymesh版本问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip install pymesh出现错误的话,尝试在https://github.com/PyMesh/PyMesh/releases下载并安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e0eb21e8c66499f9cc8ff9f7c7a13e/" rel="bookmark">
			python多线程操作字典_Python：迭代字典而另一个线程修改字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一个pyglet窗口,它有一个属性“observer”.观察者有一本字典“dict”.在main_loop()函数中,窗口根据observer.dict的内容重新绘制窗口.观察者本身是一个读取流的线程,向dict添加读数.观察者还有一个计时器线程,如果dict中有过时的项目,则每秒检查一次,如果是,则删除它们.
显然,如果在窗口迭代dict时添加或删除项目,则可能会导致问题.我目前的解决方法是每次都使dict的深层副本,并绘制副本.它似乎有效,但它是一个丑陋的解决方案.
我对python很新,特别是w.r.t线程/锁定/等等.我想我需要观察者在添加或删除项目时“锁定”dict.有人可以给我一些提示在哪里先看？
我试图提取我的代码的有意义的结构,所有都会太长.我希望你能得到主要的想法.
class GraphConsole(window.Window):
def __init__(self, *args, **kwargs):
window.Window.__init__(self, *args, **kwargs)
def init(self, observer):
self.observer = observer
def main_loop(self):
while not self.has_exit:
...
self.draw()
def draw(self):
dict_copy = deepcopy(self.observer.dict) # &lt;-- UGLY WORKAROUND
for k, v in dict_copy.iteritems():
...
class Observer(threading.Thread):
def __init__(self):
threading.Thread.__init__(self)
self.dict = {}
self.timer = Timer(1, self.delete_obsolete);
self.timer.start()
def run(self):
while True:
...
# read a stream
self.dict.append()
...
def delete_obsolete(self):
...
del self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e0eb21e8c66499f9cc8ff9f7c7a13e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0672e8df593f43549167e21b985a04f9/" rel="bookmark">
			踩坑指南！import cv2出错怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有更新，最近代码相关问题看的比较少，有时候忙着debug就忘记了记录，反思一下。
背景：在提取视频帧序列的时候用到了opencv包，结果运行出错。
解决：经过查找资料，import cv2出现“ImportError: numpy.core.multiarray failed to
import”最主要的原因是opencv3版本依赖出现问题，太新的numpy版本会导致cv2引用出错，所以出现此类问题，不防降低numpy版本试试！
列几个我用到的语句：
pip install opencv-python pip uninstall numpy pip install numpy pip install numpy==xxx(实际需要的版本) 举例：
这里可以看到我已经安装了opencv和numpy包，numpy的依赖关系是1.17.3及以后，当前版本为1.19.4，卸载当前版本并安装旧版本。
成功解决！
这篇debug很简单，全网类似教程有许多，没什么技术含量。记录的主要目的是在debug过程中，有在重新安装numpy版本时遇到飘红的头疼问题，当时苦恼了很久(一苦恼就忘了记录bug)，仔细阅读报错和官网opencv的文档发现：
大概意思就是说需要安装一个c++的工具，我报错的部分也给出了一个网址，让去对应地址下载安装Microsoft C++。一开始觉得有点麻烦，最后还是老老实实按照提示解决。
心得：debug遇到满篇飘红、error都不是事，有提示先试试提示的解决方法，最难的是全网找不到你这个bug的问题是什么。
参考：
参考解决指南-记如何解决import cv2出现的“ImportError: numpy.core.multiarray failed to import”
opencv-python官方文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e052dd3f5f79c82e1a58dadc5bfd0327/" rel="bookmark">
			C&#43;&#43;死磕基础之指针篇(三)--对象指针的创建以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中已经介绍了C++对象指针的概念，本篇文章主要讲解对象指针的两种创建方式
C++对象指针简介:C++对象指针
一.定义对象的指针，对象指针指向类的实例化对象的地址 先来看一个示例:
Test1.h
#ifndef TEST1_H #define TEST1_H class Student{ public: Student(){} int getNum(); int getScore(); void print()const; int num; int score; }; #endif Test1.cpp
#include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; #include"Test1.h" int Student::getNum(){ return num; } int Student::getScore(){ return score; } void Student::print() const { cout&lt;&lt;"学号:"&lt;&lt;num&lt;&lt;","&lt;&lt;"分数:"&lt;&lt;score&lt;&lt;endl; } int main(){ Student std1; Student* ptrstu=&amp;std1; ptrstu-&gt;num=2; ptrstu-&gt;score=100; ptrstu-&gt;print(); return 0; } 结果:
分析:
首先在h文件中定义了Student类以及声明了类的成员函数，在cpp中定义成员函数。
1.在main函数中创建了Student类的对象std1
2.定义对象指针ptrstu //Student* ptrstu=&amp;std1;
3.对象指针指向类的对象的地址 //Student* ptrstu=&amp;std1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e052dd3f5f79c82e1a58dadc5bfd0327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccda76514e2b8a146071b012a5fa2144/" rel="bookmark">
			python判断是否为数字符_Python判断字符串是否为数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python判断一个字符串是否为数字，可以分为两种情况考虑。
字符为纯数字
如果需要检测的数字为纯数字，不包括负号，小数点等，可以使用字符串的isdigit()函数来判断
&gt;&gt;&gt; a = "001"
&gt;&gt;&gt; a.isdigit()
True
&gt;&gt;&gt; a = "-1"
&gt;&gt;&gt; a.isdigit()
False
&gt;&gt;&gt; a = "1.0"
&gt;&gt;&gt; a.isdigit()
False
整数/浮点数（正负）
判断一个字符串是否可以转换为数值，可以使用float()函数，如果不能转换为数值，抛出ValueError异常。
def is_number(s):
try:
float(s)
return True
except ValueError:
return False
排除nan，inf和-inf
上面的is_number函数会把nan，inf（正无穷）和-inf（负无穷）作为数值。下面的函数排除了这三种情况
def is_number(s):
try:
f = float(s)
if f!=f or f == float('inf') or f == float('-inf'):
return False
return True
except ValueError:
return False
其中，f!=f用来判断是否为NaN，NaN == NaN比较为false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cada1fa803f500bb5a2e457c7f4ca27/" rel="bookmark">
			参数曲线拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前都是单变量的函数，现在是多元的函数。
使用两个一元函数的基函数的相互乘积来定义二元函数的基函数。二元函数的两个方向可以用相同的基函数，也可以用不同的基函数，如果相同，则是共享基函数。通常选用相同的基函数。
张量积定义的优点是定义简单，不足是随着维数增加，基函数个数急剧增加。
解决方案：用神经网络表达，用一个单变量函数（称为激活函数）的不同仿射变换来构造基函数，基函数数目可控。
向量值函数，看成多个单变量函数，各个函数独立无关。 一般会用相同的基函数，共享基函数。
平面参数曲线：
一条曲线由一个变量参数t决定，也成为单参数曲线。参数t可看成该曲线的时间变量可灵活的表达非函数型的曲线（任意曲线） 参数曲面
一张曲面由两个参数（u，v）决定，也成为双参数曲面可灵活表达非函数型的任意曲面 当进行降维映射的时候，一般会有信息丢失，且丢失的信息大部分情况不可逆，且无法恢复。所以，调参的时候维度不能太低。
曲线拟合问题：
输入：给定平面上系列点输出：一条参数曲线，拟合这些点 用x来拟合x(i)，用y来拟合y(i)。
(t,x) (t,y)
参数化方式：
均匀参数化弦长参数化中心参数化Foley参数化 能够展成平面的曲面称为可展曲面：圆柱、圆锥。
非可展曲面：球
应用：纹理映射
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811bdd57fda5441e374714c99a370ea1/" rel="bookmark">
			php mysql in占位符赋值_R中的管道符-magritter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我一直不舍得完全从R转到python有很多原因，但是其中最舍不得的两个就是ggplot2和magritter，完全使我的R语言代码变得高效而且简介，今天就来详细介绍一下R中的pipe operator的包-magritter
关于magritter的包描述是这样的：A Forward-Pipe Operator for R
安装： # 直接从tidyverse中使用: install.packages("tidyverse") # 或者直接安装: install.packages("magrittr") # 从GitHub下载开发版本: # install.packages("devtools") devtools::install_github("tidyverse/magrittr") 使用方法： 1.基本用法
x %&gt;% f 等价于 f(x) x %&gt;% f(y) 等价于 f(x, y) x %&gt;% f %&gt;% g %&gt;% h 等价于 h(g(f(x))) ---------------------------------- x %&gt;% f(y, .) 等价于 f(y, x) x %&gt;% f(y, z = .) 等价于 f(y, z = x) 如果数据作为函数的第一个参数的话，是不需要placeholder的，但是如果是第二或者更后面的参数，就需要使用 . 作为占位符。
2.构建函数
f &lt;- . %&gt;% cos %&gt;% sin 等价为 f &lt;- function(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811bdd57fda5441e374714c99a370ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd083e6fdbe2cf2b5f5f334033f72a8/" rel="bookmark">
			Ubuntu 配置镜像文件(清华)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：
https://blog.csdn.net/lxlong89940101/article/details/83868651 一、流程介绍 Ubuntu 的软件源配置文件是 /etc/apt/sources.list。
在修改之前，先将系统自带的该文件做个备份，将该文件替换为清华源官网提供的内容。
即可使用 TUNA 的软件源镜像，最重要的是使用清华源可以走 ipv6。
清华源官网：https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/
二、登录与备份 首先需要使用root用户
sudo -s 进行源码备份.
cp /etc/apt/sources.list /etc/apt/sources.list.bak 三、修改与保存 进行源列表的修改
vi /etc/apt/sources.list 将sources.list中的内容提换如下
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse # deb-src https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd083e6fdbe2cf2b5f5f334033f72a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778ee8298697aef6d0a2b9d9cb378cdf/" rel="bookmark">
			源地址和目的地址理解_什么？你不知道0.0.0.0和255.255.255.255这两个地址是干嘛的？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们电脑的ip配置里，有静态配置 ip 地址和动态获取 ip 地址两种选择。
我敢保证绝大部分人使用的都是动态获取 ip 地址，因为如果自己静态配置的话，容易出错，例如你不小心配置了一个已经被其他人在使用的 ip 地址。所以我们一般选择的是动态获取 ip 地址。注意，这里的 ip 地址不仅仅是指主机的唯一标识，还指DNS、网关等 ip 地址。
对于动态获取 ip 地址，如果你的电脑关机重启了之后，此时可以说你的电脑如同一个初生的婴儿，啥 ip 也没有。这个时候最重要的事情就是让自己获得一个 ip ，好让自己可以去冲浪，可是问题来了，你该给谁发送报文以此来获取 ip 呢？
有人可以会说，我可以给 DHCP 服务器发送一个报文来动态获取 ip，然而问题是，你知道 DHCP 服务器的 ip 是多少吗？你不知道，你是一个刚出生的婴儿，你啥也不知道。
居然我们不知道该找谁来给我们分配一个 ip 地址，那就只能暴力一点，发个广播吧，告诉所有人，我急需一个 ip 地址。于是，我们发了一个广播通知了所有人。
目的 ip 填 255.255.255.255 代表这是一个广播报文，会发给局域网内的所有主机。其他主机收到广播报文之后，会进行判断这个广播报文是否是发给自己的，如果是发给自己的，则进行处理，否则就把这个广播报文丢弃。
这个时候， DHCP 服务器终于收到了我的广播，这个时候问题来了，DHCP服务器是如何知道我是来请求一个 ip 的呢？
为了解决这个问题，我们需要在报文里做一个标记，告诉 DHCP服务器我是来请求报文的，于是，啥也没有的我，在报文的源地址里填了 0.0.0.0。当DHCP服务器看到报文的源地址是 0.0.0.0时， 就知道我还没有被分配过 ip，急需一个ip来去冲浪了。
于是，DHCP服务器赶紧找了一个没有被使用ip地址发给我，并且把这个 ip 地址标记为 已使用的状态。
有人可能会说，我没有 ip 地址，DHCP服务器怎么发送给我呢？好吧，我没有 ip 地址，但我有全球唯一的 Mac地址啊。这样，我就能顺利着拿到我的 各种 ip参数了。
总结下：
255.255.255.255这个地址一般用来广播的时候使用，而0.0.0.0这个地址可以代表这是一个还没有分配 ip 的主机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778ee8298697aef6d0a2b9d9cb378cdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1687a533a8f57ab57fed64feded5b506/" rel="bookmark">
			vue3.0&#43;ts&#43;antd&#43;admin（二）了解vue3.0新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3.0 官网Api 官方网址
安装使用 vue-class-component 插件，是vue官方推荐
安装使用 vue-property-decorator 插件，是vue社区推荐
网址
options的五类属性： 1.数据：data、 props、 propsData、 computed、methods、 Watch
2.DOM: el、 template、 render、 renderError
3.生命周期钩子: beforeCreate、 created、beforeMount、 mounted、 beforeUpdate、 updated、activated、 deactivated、 beforeDestroy、 destroyed、errorCaptured
4.资源: directives、 filters、 components
5.组合: parent, mixins、 extends、 provide、 inject
建议用 vue3 方法 引入图标字体
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d64c5637b3a831f290abf93446ec85/" rel="bookmark">
			python字符串查找匹配_python 字符串的匹配与查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，尤其是根据日志定位，我们常常需要手动搜索大量的关键字符串，进行问题定位。第一次可能是技术的学习，那么从第二次开始，就开始是大量的体力劳动，遵循凡事重复的体力劳动，都交给python的原则，我们可以利用python把我们需要的字符串都找出来，避免纯手工操作。
1、正则表达式
正则表达式，几乎是计算机领域绕不过去的一种手段了，毕竟机器并不是人，比如人看到100-109这些自然会认为是数值。并且满足：
1）它是三位数。
2）它大于等于100，并且小于等于109。
但是在机器的眼里，它并没有这些意义，如果从存储的角度看，所有的在计算机的内容都是二进制的1和0。之所以我们能在文本里面看到100，101，102,...,109。是因为我们将这些二进制进行了再翻译，这种过程叫做编码。
所以如何让程序知道，你要找的是东西呢？
比如说上面的例子，我们要找的100-109这个范围的数值，一种最简单的方法是把这10个数每次遍历一遍文本找到，但是当我们扩大范围呢10000-99999，找的这个范围内的数值，每个数字都进行遍历显然是不太现实的。
这时我们可以用正则定义一个规则“\d\d\d”,它告诉计算机，我们要寻找一个三位数字的字符串。但是这样的三位数是很多的，如何找的100到109范围内的整数呢。可以观察到100到109，它们的第一位数都是1，第二位是0，第三位则是取0-9任意值。于是我们只要限定这三位的取值，就可以找的对应的字符串了----》“10[0-9]”
[0-9]就是一种通配符的表达，它表示这里可以取0-9的任意值。
事实上正则表达式远没有这么简单，确切的说，它因为不同需求，复杂程度也是不同的。学习正则表达式，可以参考下面链接的资料：
2、python的re 模块
re是python内嵌的，用于匹配正则表达式的模块，因此，可以直接引用re的模块来运用正则表达式查询我们想要的内容。
re模块内部集成了很多方法，这里只简单介绍几种比较常用的方法。
1）findall
re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。
格式：
re.findall(pattern, string, flags=0)
pattern: 编译时用的表达式字符串。
flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：
例如我们要找的字符串中的102。
运行结果：
2）compile
编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）
格式：
re.compile(pattern,flags=0)
那么上面的例子，我们还可以这么写：
re还提供了很多方法用于更方便的查找字符串，这里不再一一详细叙述。
好了，我们现在实现这样一个小项目，工作中，你的领导需要你将日志log.log中所有101-109的数值，查找出来。那么你应该怎么做呢？
1）正则表达式可以用“10[0-9]”表示
2）利用re把log.log中满足要求的内容查找出来。
log.log内容如下：
简化代码如下：
运行结果如图：
正则+python 可以帮助你实现更多有趣的内容。查找匹配字符串的技能几乎在python中无处不在，这将有助于你更好的用python帮助自己解决问题，从繁复的体力查找中抽出时间，进行更有意义的思考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99a9154fca57d81bb901b7510b1e57f/" rel="bookmark">
			Bernstein多项式与RBF函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做函数拟合时，我们会选用多项式作为基函数，因为多项式易于计算、表现良好、光滑，表达能力足够。然而多项式插值存在一定问题，存在振荡现象和对插值点数的高度敏感性。为此，我们需要更好的基函数来做插值，由此引入Bernstein基函数。
n次Bernstein基函数定义为：
对于[0, 1]区间上任意连续函数 f(x) 和任意正整数n，在n趋于无穷的时候，Bernstein多项式可以一致逼近 f(x)。
Bernstein基函数有很多良好的性质：
非负性权性（和为1）凸包性逼近结果优秀
当把b(n,j)看作是系数时，当n趋于无穷大时，点足够密，对于拟合之后的函数就会逼近到原值。把f看成系数时，就会变成一个新的函数。 RBF就是高斯函数在高维的情况，我们同样可以通过把RBF函数作为基函数实现函数拟合。
但是当均值μ和方差δ选取的不够好的时候，效果也不好。所以，我们可以想办法让均值和方差一起来优化。
机器学习就是在做拟合，在RBF神经网络就是用高斯函数作为激活函数。通过输入和输出来训练方差和均值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e677e9c1a16645281445581967ad724/" rel="bookmark">
			人工智能发展史_最全计算机发展史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自自主可控新鲜事
出品丨自主可控新鲜事
文章共13292字，建议阅读时间20分钟
公众号转载请注明出处
计算工具的演化经历了由简单到复杂、从低级到高级的不同阶段，如从“结绳记事”中的绳结到算筹、算盘计算尺、机械计算机等。它们在不同的历史时期发挥了各自的历史作用，同时也启发了现代电子计算机的研制思想。
计算机(computer)俗称电脑，是现代一种用于高速计算的电子计算机器，可以进行数值计算，又可以进行逻辑计算，还具有存储记忆功能。是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。
但是，你知道计算机的发展史以及经历的不同阶段么？下面小新就为大家一一介绍。
在史前时代，德国科学家契克卡德(W. Schickard)制造的人类有史以来第一台机械计算机，这台机器能够进行六位数的加减乘除运算。这一划时代的发明为人类的计算机发展奠定了基础。“穿孔纸带”、二进制、布尔代数以及手摇式计算机、按键式计算机开始出现，为百年后出现的数字计算机奠定了方法与理论基础。
在电子管时代，ENIAC于1946年在费城公诸于世，它通过不同部分之间的重新接线编程，还拥有并行计算能力，但功能受限制，速度也慢。ENIAC的问世标志现代计算机的诞生，是计算机发展史上的里程碑。
后来，晶体管的发明大大促进了计算机的发展，晶体管代替电子管，电子设备体积减小。1956年，晶体管在计算机中使用，晶体管和磁芯存储器导致了第二代计算机的产生。第二代计算机体积小、速度快、功耗低、性能更稳定。首先使用晶体管技术的是早期的超级计算机，主要用于原子科学的大量数据处理，这些机器价格昂贵，生产数量极少。
在集成电路时代，计算机速度更快(一般为每秒数百万次至数千万次)，而且可靠性有了显著提高，价格进一步下降，产品走向了通用化、系列化和标准化等。应用领域开始进入文字处理和图形图像处理领域。
从1970年开始计算机硬件方面就和现代一样了，逻辑元件采用大规模和超大规模集成电路(LSI和VLSI)。软件方面出现了数据库管理系统、网络管理系统和面向对象语言等。其标志性事件是1971年世界上第一台微处理器在美国硅谷诞生，开创了微型计算机的新时代。
以下为计算机发展时刻表：
文章编辑综合自网络，如有不全欢迎后台补充留言
相关阅读
【工业机器人】全球工业机器人详细产业链梳理！ 【智能工厂】智能工厂如何快速落地 【工业技术】航空制造推动新概念机器人发展(上) 【工业技术】航空制造推动新概念机器人发展(下) 【AI】一文读懂人脸识别技术 【AI】解析 | 人工智能发展及技术架构 【AI】(收藏)从 A-Z 全面盘点人工智能专业术语梳理！ 【AI】计算机视觉入门大全：基础概念、运行原理、应用案例详解 【AI】一文读懂机器学习、数据科学、人工智能、深度学习和统计学之间的区别 【智能仓储】一文带你彻底搞懂智能仓储！ 【深度学习】12张高清思维导图，总结深度学习 【神经网络】给初学者们讲解人工神经网络(ANN) 人工智能的基础--知识分类
【AI】一文读懂人工智能产业链 【AI】中国人脸识别产业链全景图！ 【AI】史上最全的人工智能(AI)产业链地图！ 【芯片】国产芯片大全：70个细分领域代表企业 人工智能产业链深度透析—基础层
人工智能产业链深度透析-技术层 人工智能全产业链深度透析--(综合) 人工智能产业链深度透析—产业应用医疗篇 朱松纯 | 人工智能的现状、任务、构架与统一(上) 朱松纯 | 人工智能的现状、任务、构架与统一(中) 朱松纯 | 人工智能的现状、任务、构架与统一(下) 【AI】美国国家人工智能研发战略规划2019 【智慧农业】2018中国农牧家禽行业智慧养殖白皮书 【智慧农业】2019年智慧农业市场调研及前景研究报告(附PDF下载) 【智能家居】我国智能锁产业现状及未来发展趋势分析 【知识图谱】详解知识图谱关键技术与应用、AI图谱技术在知乎的应用实践、如何构建多快好省的“知识图谱即服务” 荐：
【中国风动漫】除了《哪吒》，这些良心国产动画也应该被更多人知道！ 声明
免责声明：部分文章和信息来源于互联网，不代表本订阅号赞同其观点和对其真实性负责。
编辑：Zero
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2806adaad0a0c9d1bb75db270cbbdbfc/" rel="bookmark">
			函数拟合3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓函数拟合，就是给定一些输入点，输出一个函数曲线。
选择的基函数会直接影响线性组合函数的表达能力。
当采样点较多，而系数较少时，会出现欠拟合，表达能力不够。
当采样点较少，而系数较多时，会出现过拟合。
为了防止过拟合，可以百分之九十的数据拟合，百分之十的数据验证。
有时候很难确定基函数，可以选取一些冗余的，过完备的基函数，有可能线性相关，然后可以通过让系数向量的模尽可能小，从中挑选（“学习”）一些合适的基函数。
函数拟合可以通过存储一些特定的数（系数）达到压缩存储的效果，也以用作预测。
RBF就是高维的高斯函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0a5e3f04962269a4df9c9e63b49361/" rel="bookmark">
			python epoll 并发_Python使用epoll实现高并发服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是epoll
我们在 Python多种方式实现并发的Web Server 的最后使用单进程+单线程+非阻塞+长连接实现了一个可并发处理客户端连接的服务器。他的原理可以用以下的图来描述：
解释：
1.HTTP服务器是我们使用 单进程+单线程+非阻塞+长连接实现 的web服务器。
2.在实现的时候，我们创建了一个存放已接受Socket连接的列表，该列表是在应用程序的内存空间中的。如图中深蓝色部分
3.当有3个客户端接入的时候，列表中一共存在3个对应的socket句柄，分别对应三个小黄框。
4.灰色小框代表服务器接收请求的socket。
5.我们在进行无限循环的时候，首先是检查是否有新的客户端接入，相当于检查灰色小框是否有数据到达。然后轮询3个小黄框对应socket是否有数据到达。轮询的效率是很低的。
6.服务器在使用accept和recv时，实际上是委托操作系统帮他检查是否有数据到达，由于这个列表的socket都处于用户内存空间，所以需要将其复制到内核空间。操作系统检查完毕后，如果有数据就返回数据给应用程序，如果没有数据就以异常的方式通知应用程序。而且不光这样，操作系统可能还同时在运行其他的应用程序，这样效率会非常低。
我们再来看epoll的图：
解释：
1.我们可以看到，在结构上，最大的区别在于，存放socket的列表不处于应用程序内部。在epoll中，这个存放socket的列表处于一个特殊的内存空间，这个内存空间是应用程序与内核共享的空间。也就是说，当应用程序委托操作系统检查是否有数据到达时，无需将复制数据给内核空间，操作系统可以直接进行检查。
2.操作系统检查到某个socket有数据到达，使用事件通知的形式，直接告诉应用程序，而不是以轮询的方式。打个比方，一个厨师挨个问50个人饿了没，如果饿了就给他东西吃，这是轮询。而50个人中，谁饿了谁举手，厨师就给吃的，这叫事件通知。很明显，事件通知的效率会特别高。
实现代码：
importsocketimportreimportselectdefhandle_request(new_socket, recv_msg):#从请求中解析出URI
recv_lines =recv_msg.splitlines()#使用正则表达式提取出URI
ret = re.match(r"[^/]+(/[^ ]*)", recv_lines[0])ifret:#获取URI字符串
file_name = ret.group(1)#如果URI是/，则默认返回index.html的内容
if file_name == "/":
file_name= "/index.html"
try:#根据请求的URI，读取相应的文件
fp = open("." + file_name, "rb")except:#找不到文件，响应404
response_msg = "HTTP/1.1 404 NOT FOUND\r\n"response_msg+= "\r\n"response_msg+= "
----file not found----"new_socket.send(response_msg.encode("utf-8"))else: html_content=fp.read()
fp.close()
response_body=html_content#响应正确 200 OK
response_header = "HTTP/1.1 200 OK\r\n"response_header+= "Content-Length:%d\r\n" %len(response_body)
response_header+= "\r\n"response= response_header.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0a5e3f04962269a4df9c9e63b49361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7608167f8fb8b455d1d777050b2c9277/" rel="bookmark">
			钢构cad插件_盘点那些年用过的神级CAD插件，每一款都舍不得卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要学好CAD，除了要掌握一些技巧之外，熟练使用插件也是必不可少的哦！那么大家都知道有哪些超好用的CAD插件呢？不知道？没关系！今天小编就来分享大家几款超好用的插件，每一款都堪称神器哦！
一、工具类插件1、燕秀工具箱
这款插件可是鼎鼎有名的哦！它集成了超多的小工具，嵌入在CAD软件中，可以随时调用，大幅提高绘图制图效率。而且这款插件是完全免费的，良心插件，绘图必备。
2、海龙工具箱
搞室内设计的应该都知道这款插件，也是挺有名的一款CAD插件，有了它我们可以快速完成平面图绘制、立面图绘制、剖面图绘制等，是室内设计比不可少的一款插件！
3、Cad迷你建筑工具箱
这款不到20M的插件虽然迷你，但功能可一点都不少！无论是家装设计还是绿化设计，这款插件都可以帮助你在最短的时间内完成绘图制图，而且很容易上手！麻雀虽小，五脏俱全！
二、建筑专用插件
除了上面讲到的几款工具插件，在这里再给学建筑专业的小伙伴整理两款最好用的建筑绘图插件！1、天正建筑
这是一款专门针对建筑设计、装饰设计及其相关专业的CAD插件，稳定性挺好，用它绘制平面设计图是最好不过的选择了！
2、源泉建筑
源泉建筑也是一款用于辅助建筑设计的CAD软件，它内置了丰富的装饰构件、建筑构件和建筑符号，是一款特别实用的建筑设计插件。
好啦，这就是小编今天要分享的内容啦！如果你还知道其他更好用的插件的话，欢迎在评论区分享哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee2b8c85216b7e8b09d2f907f8c84c0f/" rel="bookmark">
			hough变换_Hough变换算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、算法思想
边缘检测比如canny算子可以识别出图像的边缘，但是实际中由于噪声和光照不均匀等因素，很多情况下获得的边缘点是不连续的，必须通过边缘连接将他们转换为有意义的边缘。Hough变化是一个重要的检测间断点边界形状的方法，它通过将图像坐标空间变化到参数空间来实现直线和曲线的拟合。
霍夫变换于1962年由Paul Hough 首次提出，后于1972年由Richard Duda和Peter Hart推广使用，经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。
Hough变换是图像处理中从图像中识别几何形状的基本方法之一。Hough直线检测的基本原理在于利用点与线的对偶性，在我们的直线检测任务中，即图像空间中的直线与参数空间中的点是一一对应的，参数空间中的直线与图像空间中的点也是一一对应的。这意味着我们可以得出两个非常有用的结论：
1)图像空间中的每条直线在参数空间中都对应着单独一个点来表示；
2)图像空间中的直线上任何一部分线段在参数空间对应的是同一个点。
因此Hough直线检测算法就是把在图像空间中的直线检测问题转换到参数空间中对点的检测问题，通过在参数空间里寻找峰值来完成直线检测任务，也即把检测整体特性转化为检测局部特性。
2、算法原理 1)图像空间和参数空间
霍夫变换的数学理解是“换位思考”，比如一条直线y=a*x+b有两个参数，在给定坐标系下，这条直线就可以用a和b进行完整的表述。如果我们把x和y看作参数，把a和b看作变量的话，那么图像空间下的坐标点(x1，y1)对应着参数空间里的一条直线q=-x1*k+y1, 图像空间直线上的点(x1，y1)就是参数空间的斜率和截距，其中k，q为参数空间的自变量。
2)参数空间转换过程
下面用不同空间下的点和线的变换过程示例说明。
一条直线可由两个点A=(X 1 ,Y 1 )和B=(X 2 ,Y 2 )确定(笛卡尔坐标)。
另一方面，y=kx+q也可以写成关于(k,q)的函数表达式(霍夫空间)：
对应的变换可以通过图形直观表示：
变换后的空间成为 霍夫空间 。即： 笛卡尔坐标系中一条直线，对应霍夫空间的一个点 。
反过来同样成立( 霍夫 空间的一条直线，对应笛卡尔坐标系的一个点 )：
再来看看 A、 B两个点，对应霍夫空间的情形：
再看一下三个点共线的情况：
可以看出如果笛卡尔坐标系的点共线，这些点在霍夫空间对应的直线交于一点：这也是必然，共线只有一种取值可能。
如果不止一条直线呢？再看看多个点的情况(有两条直线)：
其实(3，2)与(4，1)也可以组成直线，只不过它有两个点确定，而图中A、B两点是由三条直线汇成，这也是 霍夫变换的后处理的基本方式 ： 选择由尽可能多直线汇成的点 。
到这里问题似乎解决了，已经完成了霍夫变换的求解，但是如果像下图这种情况呢？
k=∞是不方便表示的，而且q怎么取值呢，这样不是办法。因此考虑 将笛卡尔坐标系换为：极坐标表示 。(参考文件里大佬博客里面的图错了，下图是正确的极坐标表示方法，并且给出了辅助线几何解释)
在极坐标系下，其实是一样的：极坐标的点→霍夫空间的直线，只不过霍夫空间不再是 [k,q]的参数，而是 [ ρ , θ ]的参数，给出对比图：
从上面可以看到，参数空间的每个点 (ρ ,θ )都对应了图像空间的一条直线，或者说图像空间的一个点在参数空间中就对应为一条曲线。这样就把在图像空间中检测直线的问题转化为在极坐标参数空间中找通过点 (r,θ )的最多正弦曲线数的问题。霍夫空间中，曲线的交点次数越多，所代表的参数越确定，画出的图形越饱满。
霍夫直线检测就是把图像空间中的直线变换到参数空间中的点，通过统计特性来解决检测问题。具体来说，如果一幅图像中的像素构成一条直线，那么这些像素坐标值( x, y)在参数空间对应的曲线一定相交于一个点，所以我们只需要将图像中的所有像素点(坐标值)变换成参数空间的曲线，并在参数空间检测曲线交点就可以确定直线了。
下面给出霍夫变换的算法步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee2b8c85216b7e8b09d2f907f8c84c0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124d04ebb70104c13de909cbbd482085/" rel="bookmark">
			hbuilder制作简单网页_源于初见，跳动在网页中间的精灵Javascript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天开始js的内容整理，跳动在网页里的精灵就是它了。 一、简介 1、什么是Javascript JavaScript 是一种具有面向对象能力的、解释型的程序设计语言。更具体一点，它是基于对象和事件驱动并具有相对安全性的客户端脚本语言。它的主要目的是，验证发往服务器端的数据、增加 Web 互动、加强用户体验度等。
2、JavaScript发展史 大概在1992年,一家称作Nombas的公司开始开发一种叫做C– –(C-minus-minus,简称Cmm)的嵌入式脚本语言。保持与C(和C++)的相似性，以便开发人员能很快学会。Nombas最终把Cmm的名字改成了ScriptEase，而这种嵌入式脚本的理念也成为因特网的一块重要的基石。
1995年，Netscape(网景)公司的布兰登与Sun 公司联手开发一个称LiveScript 的脚本语言。为了营销便利，之后更名为 JavaScript(目的是在 Java 这课大树下好乘凉)。一个完整的JavaScript实现是由以下3个不同部分组成的。
ECMAScript定义的只是这门语言的基础，与Web浏览器没有依赖关系，而在基础语法上可以构建更完善的脚本语言。JavaScript的运行需要一定的环境，脱离了环境JavaScript代码是不能运行的，JavaScript只能够寄生在某个具体的环境中才能够工作。JavaScript运行环境一般都由宿主环境和执行期环境共同构成，其中宿主环境是由外壳程序生成的，如Web浏览器就是一个外壳程序，它提供了 一个可控制浏览器窗口的宿主环境。执行期环境则由嵌入到外壳程序中的JavaScript引擎(或称为JavaScript解释器)生成，在这个环境中 JavaScript能够生成内置静态对象，初始化执行环境等。
Web浏览器自定义的DOM组件，以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象，这些对象的行为和属性以及这些对象之间的关系。DOM对象，是我们用传统的方法(javascript)获得的对象。DOM属于浏览器，而不是JavaScript语言规范里的规定的核心内容。
前面的DOM是为了操作浏览器中的文档，而为了控制浏览器的行为和操作(BOM)，浏览器还提供了BOM(浏览器对象模型)。
简单的说就是下面这种结构
ECMAScript(基础语法) JavaScript的核心语法ECMAScript描述了该语言的语法和基本对象
BOM(浏览器对象模型) 浏览器对象模型(BOM)—— 描述了与浏览器进行交互的方法和接口
DOM(文档对象模型) 文档对象模型(DOM)—— 描述了处理网页内容的方法和接口
3、开发工具 浏览器: chrome或火狐
Hbuilder或Eclipse等等
进入“控制台”console：浏览器F12
控制台的作用 console对象代表浏览器的JavaScript控制台，用来运行JavaScript命令，常常用来显示网页运行时候的错误信息。Elements用来调试网页的html和css代码。
二、语法格式 1、注释 可以将注释插入 JS代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。
// 这里的内容就是注释/* 这里的内容就是注释 *//*也可以这样多行注释 */ 2、行内式 行内式将JS定义在具体html元素中。以行内式写的JS耦合度高，这种写法会使得页面非常杂乱无章，真正开发中实际上是使用嵌入式或引入外部JS文件的方式。
&lt;button onclick="alert('you clicked hered!!!')"&gt;click herebutton&gt; 3、嵌入式 嵌入式通过在html页面内容开辟一段属于JS的代码区域，通常做法为在标签中嵌套标签。
&lt;script type="text/javascript" charset="utf-8"&gt; // 页面加载后执行一个警告框 alert('this is inner js code');script&gt; 4、引入外部文件 在实际开发当中，很多时候都使用引入外部文件，这种形式可以使html页面更加清晰。
hello.js
// 页面加载后执行一个警告框alert('this is a outter js document'); index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124d04ebb70104c13de909cbbd482085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b221ff3be3d659eb017654d326a8f123/" rel="bookmark">
			office 2007图标_忘了以前Office长什么样？看完这12个历史版本就知道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天设计界的大事情就是Office图标更新了。
微软前几天发布了Office的一套全新图标设计，整体色彩更加丰富。每种图标在同一主题色下包含了阶梯渐变，显得更加具有现代感和动态美，代表了Office未来云端化、智能化、跨平台化的大方向。
同时微软正在考虑Windows整体的图标重绘工作，运用最新Fluent Design视觉语言来定义下一代的Windows界面。希望到时候的界面能让用户和设计师耳目一新。
如果对Fluent Design感到陌生，请查看其官网https://www.microsoft.com/design/fluent/
本次更新是Office 图标5年来首次变化，上次还是2013年的时候。那么各位设计师对以前的图标和界面还有印象吗？Word、Excle、PPT它们刚开始长什么样呢？一起来回顾下。
DOS时代的Office 在很早之前，电脑是没有图形界面的，当时屏幕全都是代码，也就是DOS系统。UI（user interface）是什么？谁也不知道。电脑门槛很高，一般人还玩儿不了。
和电脑刚开始类似，MUD游戏（Multiple User Domain多用户虚拟空间游戏）是最早的网络游戏，没有图形，全部用文字和字符画来构成。下图是当年很火的mud游戏：北大侠客行。
下图是DOS时代的Office，真的不能想象，没有图文界面，这软件怎么排版的……
Office 1.0 比尔盖茨说要让让每个家庭的桌上都有一台电脑，那么电脑的门槛必定要降低，所以用户图形界面时代到来了，纯代码的DOS界面实在不友好，用现在的话说就是用户体验极差。1990年，Office1.0登场，这在当时已经算是划时代的作品了，各种操作图形化，门槛大大降低。全家桶三大软件都包括，具体版本为Word 1.1、Excel 2.0、和PowerPoint 2.0。
下图是当时Word的界面，以现在的审美来看，是不是很难接受呢？不过它基本上奠定了未来几十年Word的框架结构。
Office 3.0 1992年，推出Office3.0，界面上没什么大的改变，不久之后更名为Office92。
Office 4.0 1994年，推出Office4.0，依然没有大变化，貌似图标变成彩色了？
Office 95 1995年，Windows95操作系统发布，Office 95也同步推出。从这个版本开始，Office里的软件版本号都与Office的版本号统一了起来。比如Word 7.0、Excel 7.0、PowerPoint 7.0。桌面图标有着浓厚的上世纪互联网初期气息。
Office 97 1996年11月发布Office97，界面细节更加完善。工具图标不再使用高光引用凸出，变得更加简洁。桌面图标没有改变。
在这个版本中，微软提供了一个小助手，是一个右下角动来动去的长着大眼睛的小回形针，给用户带来使用帮助。后来才知道这家伙英文名叫Clippy，2007年被去掉了。
Office 2000 1999年发布Office2000，桌面图标重新设计，开始有点现代互联网图标的感觉了。从这代开始全家桶的主体颜色开始确定。
小助手Clippy换了新面貌，更加立体有光泽，同时还带来了它的几个小伙伴。这个是我最早接触的office，当时上小学，电脑课还叫微机课，上课最大的乐趣就是逗它玩儿。
Office XP 发布于2001年，和Windows XP同一年推出。虽然新的 Office XP 名称中有“XP”代号，但并不是只能在 Windows XP 系统中运行，只是配合当时的营销手法而命名。
界面上比2000版更加柔和和现代，少了之前的生硬，更符合互联内网时代的风格。
Office 2003 2003年发布，这个版本Office采用了新的logo，也是使用最久的一个版本，至今很多复印店里面还在使用。
工具栏图标背景都经过大幅度的优化，整个界面也与XP系统的蓝色主题相得益彰，已经摆脱了以前界面中的原始感觉，开始进入现代设计风格。桌面图标和上一代相比更加立体和质感，上大学用的最多的一版，现在看来满满都是回忆。
Office 2007 发布于2007年，这一版界面又发生了重大变化，是我最喜欢的一个版本。交互上，工具菜单进行了整合，界面看起来非常赏心悦目，整个细节把控的很好，尤其是那些高光投影的运用，在word里面编辑文字当时是一种享受。桌面图标也是经过精心设计，结构一致。
Office 2010 发布于2010年，界面进一步进化，但是与2007相比去掉了很多样式细节，偏向简化，去掉了界面中大面积的浅蓝色。Office主logo细节调整，变成橙黄色渐变。桌面图标也更加优美，这版的图标个人觉得比之前的都要有感觉。全家桶中的软件大部分都拥有了自己专属的字母标志。
Office 2013 发布于2013年，Office主logo发生巨变，更加简洁。2013年也是iOS7发布的年份，互联网设计风格开始往扁平化方向发展。
之前界面中的细节全部去除，只留下信息本身和主题色。这样的设计很适合网页版本，也预示着微软产品开始往云端、跨平台发展。
Office 2016 我目前用的这一版本，图标没什么变化，界面最大改动就是顶部导航用纯色突出，很有层次感。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b221ff3be3d659eb017654d326a8f123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f93b41512853b9e9d595cc3d832e4f/" rel="bookmark">
			JAVA基础：a&#43;&#43;与&#43;&#43;a的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a++与++a 首先在java中a++和++a都属于自增运算符 关于区别我们来看下边程序： public static void main(String[] args) { int a = 0; System.out.println("初始化a:"+a); int b = a++; System.out.println("a++运算:"+b); System.out.println("a++运算结束，a值:"+a); a = 0; System.out.println("初始化a:"+a); int c = ++a; System.out.println("++a运算:"+c); System.out.println("++a运算结束，a值:"+a); } 我们将a++赋值给b，将++a赋值给c，方便打印
程序输出结果： 初始化a:0 a++运算:0 a++运算结束，a值:1 初始化a:0 ++a运算:1 ++a运算结束，a值:1 从输出结果可以看出： a++运算输出为0，但是经过a++后，a的值最终为1++a运算输出为1，经过a++后，a的值最终为1 所以可以得出： a++是先进行取值，然后进行自增运算. ++a是先进行自增运算，然后进行取值. 为知其然知其所以然，我们使用IDEA打开对应的ByteCode public static main([Ljava/lang/String;)V L0 LINENUMBER 10 L0 ICONST_0 ISTORE 1 L1 LINENUMBER 11 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ILOAD 1 IINC 1 1 INVOKEVIRTUAL java/io/PrintStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5f93b41512853b9e9d595cc3d832e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55bb9381d0d63cd0c7e72cfcb7fc995c/" rel="bookmark">
			python自编循环语句_Python循环语句-for/while
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#优先掌握的操作：（*****）
1、按索引取值(正向取+反向取) ：只能取#msg='hello world'#print(type(msg[0])) #取出的字符还是为str类型#print(msg[-1])#msg[0]='H' #此处要执行修改操作的化会发生报错
​2、切片(顾头不顾尾，步长)#msg='hello world'#print(msg[0]+msg[1]+msg[2])#print(msg[0:5])#print(msg[0:5:2]) #其中0为起始位置 5为结束位置（顾头不顾尾）取不到索引为5的字符 2为步长#print(msg[0:]) #不写默认到最后一个字符#print(msg[:]) #不写起始和结束位置元素默认从第一个切片到最后一个字符
​#print(msg[-1:-5:-1]) #-1 -2 -3 -4#print(msg[::-1]) #-1 -2 -3 -4
​3、长度len：统计的是字符串中字符的个数#msg='h你d'#print(len(msg))
​4、成员运算in和not in：判断一个子字符串是否存在与一个大字符串中#msg='hello world'#print('ho' in msg)#print('ho' not in msg)
​5、移除空白strip:移除字符串左右两边的某些字符。strip后面跟一个参数（即要移除的字符，可以为多个）#msg=' hello '
​#print(msg.strip(' '))#print(msg.strip()) 不写参数，默认参数为空格#print(msg)
​#name=input('name&gt;&gt;&gt;: ').strip() #name='egon'#pwd=input('password&gt;&gt;&gt;: ').strip()#
#if name == 'egon' and pwd == '123':#print('login successfull')#else:#print('username or password error')
​#msg='***h**ello**********'#print(msg.strip('*'))
​#msg='*-=+h/ello*(_+__'#print(msg.strip('*-=+/(_'))
​
​6、切分split: 把有规律的字符串切成列表从而方便取值，split（分隔符，切几次 不写默认切完）#info='egon:18:180:150'#res=info.split(':',1)#print(res)#print(res[1])
​#info='egon:18:180:150'#res=info.split(':')#print(res)
​#s1=res[0]+':'+res[1]+':'+res[2]+':'+res[3]#s1=''#for item in res:#s1+=item#print(s1)
​#s1=':'.join(res) 专门用于字符串的拼接 参数为一个需要拼接的内容#print(s1)#':'.join([1,2,3,4,5])
​7、循环#for i in 'hello':#print(i)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55bb9381d0d63cd0c7e72cfcb7fc995c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aeb7324c790d4186f53376c5219a0ca/" rel="bookmark">
			python数据分析用哪个ide_什么是数据科学的最佳Python IDE？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		m创建，于1991年首次发布，解释的高级编程语言是为通用编程而开发的。Python解释器可在多种操作系统上使用，包括Linux，MacOS和Windows。以下是最受欢迎的Python IDE /编辑器，基于受此博客启发的KDnuggets民意调查。
​随着近30年的运行过程，Python在编程社区中获得了极大的欢迎。使用IDLE或Python Shell写下Python代码对于较小的项目是有效的，但在完成成熟的机器学习或数据科学项目时却不实用。
在这种情况下，您需要使用IDE（集成开发环境）或专用代码编辑器。由于Python是领先的编程语言之一，因此可以使用多种IDE。所以问题是，“哪个是Python最好的IDE？”显然，Python没有单一的IDE或代码编辑器可以加上“最佳”标签。这是因为他们每个人都有自己的优点和缺点。此外，在众多IDE中进行选择可能非常耗时。
​ 不过不要担心，为了帮助您选择正确的，我们已经整理了一些Python的IDE，专门用于处理数据科学项目。这些是：
Atom
平台 - Linux / macOS / Windows
类型 - 通用文本编辑器
Atom是一个免费的开源文本和源代码编辑器，可用于许多编程语言，包括Java，PHP和Python。文本编辑器支持用Node.js编写的插件。尽管Atom可用于多种编程语言，但它通过其有趣的数据科学功能展示了对Python的非凡热爱。
Atom带来的最大功能之一是支持SQL查询。但是，您需要首先安装Data Atom插件才能访问该功能。它为Microsoft SQL Server，MySQL和PostgreSQL提供支持。此外，您可以在Atom中可视化结果，而无需打开任何其他窗口。
另一个有利于Python数据科学家的Atom插件是Markdown Preview Plus。这为编辑和可视化Markdown文件提供了支持，允许您预览，渲染LaTeX方程等。
好处：积极的社区支持
与Git的完美整合
为管理多个项目提供支持
缺点：可能会遇到旧CPU的性能问题
遇到迁移问题
Jupyter Notebook
平台 - Linux / macOS / Windows
类型 - 基于Web的IDE
Jupyter Netbook于2014年诞生于IPython，是一个基于服务器 - 客户端结构的Web应用程序。它允许您创建和操作称为notebook的笔记本文档。对于Python数据科学家来说，Jupyter Notebook是必不可少的，因为它提供了最直观和交互式的数据科学环境之一。
除了作为IDE运行之外，Jupyter Notebook还可用作教育或演示工具。此外，对于刚刚开始使用数据科学的人来说，它是一个完美的工具。您可以使用Jupyter Notebook轻松查看和编辑代码，从而创建令人印象深刻的演示文稿。
通过使用Matplotlib和Seaborn等可视化库，您可以在代码所在的同一文档中显示图形。此外，您可以将整个工作导出为PDF，HTML或.py文件。与IPython一样，Project Jupyter是一系列项目的总称，包括Notebook本身，一个控制台和一个Qt控制台。
好处：允许从notebook创建博客和演示文稿
确保可重复的研究
在运行它们之前编辑片段
缺点：复杂的安装过程
PyCharm
平台 - Linux / macOS / Windows
类型 - 特定于Python的IDE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aeb7324c790d4186f53376c5219a0ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032b30e889a91b399adbc5cc1c3102ef/" rel="bookmark">
			性能优化之电量和网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电量 电量的分析工具 energy profiler 使用 Android 8.0 及以上版本的设备时，使用Energy Profiler 可以了解应用在哪里耗用了不必要的电量。 Energy Profiler 会监控 CPU、网络无线装置和 GPS 传感器的使用情况，并直观地显示其中每个组件消耗的电量。还会显示可能会影响耗电量的系统事件（唤醒锁定、闹钟、作业和位置信息请求）的发生次数
使用Profile 运行App。
下面红框的时间段,我打开了定位功能的页面,就显示除了location高亮
可以选择这段定位的区域,进行分析
上面的系统事件说明： **WakeLock（唤醒锁定）：**是一种机制，可在设备进入休眠模式时使 CPU或屏幕保持开启状态。例如，播放视频的应用可以使用唤醒锁定，以便在用户未与设备交互时使屏幕保持开启状态。请求唤醒锁定不是一项耗电量很高的操作，但未撤消唤醒锁定会导致屏幕或CPU 保持开启状态的时间超过必要时间，从而加快电池耗电速度。**Alarms（闹钟）：**您可以使用闹钟定期在应用上下文之外运行后台任务。当闹钟触发时，它可能会唤醒设备并运行耗电量很高的代码。**Jobs（作业）：**您可以使用作业在指定条件下（例如恢复网络连接时）执行相关操作。您可以使用 JobBuilder 创建作业，并使用JobScheduler 对这些作业进行调度。在许多情况下，建议您使用 JobScheduler对作业进行调度，而不是使用闹钟或唤醒锁定。**Location（位置）：**位置信息请求使用 GPS 传感器，这会消耗大量电量。 电量的优化 电池续航时间是移动用户体验中最重要的一个方面。没电的设备完全无法使用。因此，对于应用来说，尽可能地考虑电池续航时间是至关重要的。在我们开发时对于单个APP应该注意能够：
**减少操作：**您的应用是否存在可删减的多余操作？例如，是否可以缓存已下载的数据，而不是每次重新下载数据？**推迟操作：**应用是否需要立即执行某项操作？例如，是否可以等到设备充电后或者Wifi连接时（通常情况下使 用移动网络要比WIFI更耗电）再将数据备份到云端？**合并操作：**工作是否可以批处理，而不是多次将设备置于活动状态？比如和服务器请求不同的接口获取数 据，部分接口是否可以合并为一个？ 监控电池电量和充电状态 为了减少电池续航被我们软件的影响，我们可以通过检查电池状态以及电量来判断是否进行某些操作。比如我们可以在充电时才进行一些数据上报之类的操作。
获取充电状态 IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED); Intent batteryStatus = registerReceiver(null, ifilter); // 是否正在充电 int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1); boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL; // 什么方式充电？ int chargePlug = batteryStatus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032b30e889a91b399adbc5cc1c3102ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1da7c92a2d6abc0a4dd08e26c000f4/" rel="bookmark">
			laravel yii thinkphp 框架对比_PHP框架之Laravel基础知识最全总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程小丸子 2019-12-19 21:50:07
laravel框架基础知识
一、laravel简介
laravel是一套优雅简介的PHP开发框架，受欢迎程度非常之高，功能强大，工具齐全；今天我们一起来看看框架的基础知识
二、版本选择
本篇学习笔记以laravel5.2.15版本为框架的版本基础；更多版本请移步https://www.golaravel.com/
三、laravel下载安装以及开发环境搭建
（一）：环境搭建
由于laravel使用较多的php新特性，所以新版本的laravel对PHP的版本要求比较高，这里选择的laravel5.2.15要求 PHP&gt;5.5.9+ 。Win系统下推荐使用集成的开发环境比如wamp、phpStudy、Xampp都可以，下载安装的时候需要注意PHP版本，Linux系统下需要编译安装。
（二）：下载、安装及大致介绍
1、安装包下载安装
原本laravel中文网是可以下载一键安装包的，但是等我去下载的时候发现没地方可以下载，也只能通过度娘找其它下载资源下载安装包然后安装；我的资源：https://github.com/yuwenbo5/laravel5.2.15.git；下载安装包后解压更改名称(laravel)，直接拷贝到环境根目录www（win下wamp环境）或者 /var/www/html（linux下lamp环境）中；打开浏览器输入url：localhost/laravel/public 然后回车，出现如下画面表示安装成功：
laravel5启动页面
2、composer安装
cd到环境根目录，使用命令：composer create-project --prefer-dist laravel/laravel=5.2.15 laravel(项目名称,可修改)
3、简单介绍
laravel是基于mvc模式的php框架，m——模型层，v——视图层，c——控制器层；以下为laravel框架的目录文件，框出来的文件目录将在后续中用到：
框架目录
app是应用的核心代码文件目录，以后的代码基本都在这里完成；app/Http/Controller目录是应用的控制器文件；routes.php是框架的路由文件，负责路由分配和映射；Http下的类文件，比如上面目录中的User.php、Menu.php文件是应用的模型文件；config目录是所有应用的配置文件目录；public是框架的入口文件及静态资源文件目录；resources/views则是应用的视图文件目录。
四、laravel路由
（一）：简介
用过thinkPHP的开发者都知道，传统的MVC的url都是对应应用的控制器及控制器中的方法，laravel中的MVC则是通过路由功能映射到对应的程序(控制器方法)，通过路由将用户的请求发送到对应的程序进行处理，其作用就是建立url和处理程序之间的映射关系，这样做有一个好处，对url进行美化只需要修改路由而无需对程序本身进行修改。
laravel中请求类型包括：get、post、put、patch、delete。
前面说了route.php是laravel的路由文件，所有的路由映射都要通过编辑route.php文件进行代码书写。
（二）：路由学习
1、基本路由
get请求：
1 &lt;?php 2 3 //基本路由的get请求 4 5 Route::get('get_base', function(){ 6 return 'get request base'; 7 }); 8 9 10 浏览器输入：http://127.0.0.1/laravel/public/get_base 11 页面输出：get request base post请求：
1 &lt;?php 2 3 //基本路由的post请求 4 5 Route::post('post_base', function(){ 6 return 'post request base'; 7 }); 8 9 10 以上路由需要通过post方式请求，这里不做演示 11 请求后页面输出：post request base 2、多请求路由
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1da7c92a2d6abc0a4dd08e26c000f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ee9c19b6322ddee690a3340a4590f2/" rel="bookmark">
			aes 加密_Jmeter处理AES加密接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中，有时候我们会遇到登录密码加密的接口，有用MD5加密，也有用AES加密。MD5加密一般用jmeter自带的函数助手就能完成，下面讲的是AES加密。废话不多说，直接教程。
要处理AES加密接口，首先要了解AES加密的机制。一般来说，AES加密有三个部分组成：
第一个就是加密的模式(ECB,CBC,CFB,CTP等)。
第二个就是补码方式(Pkcs5padding,Zeropadding等)。
第三个就是密钥，也就是key。
这三个部分都是开发自定义写好，我们到时候直接询问开发即可。我下面的登录登录接口采用的是AES/ECB/Zeropadding(算法/加密模式/补码方式),key是16个9。
那么如何用jmeter完成这个加密接口的请求呢？首先因为算法是开发编写的，所以我们测试人员可以先让开发提供加密写法的jar包(其实就是java代码一些类和方法)，然后告诉我们使用加密的方法名是什么，最后在jmeter中导入jar包完成接口请求。
首先在打开jmeter，在测试计划内导入加密的jar包，如下:
导入成功后，我们添加线程组，登录的请求，然后在登录的请求下添加一个前置处理器-BeanShell PreProcessor,接下来只要写几行简单的代码就可以实现加密了，如下：
在写之前了，我们先了解一下开发的jar包的方法进行了解，下图就是导入了AesUtil类(开发已经封装好了)，然后使用encrypBase64方法名对明文进行加密，并传输了两个参数，一个是需要的加密明文，一个是加密的key(16个9)，如下：
了解上图之后了，我们在BeanShell PreProcessor开始编写代码，首先导入加密的类，然后使用类方法开始加密，最后传给系统变量，如下：
最后，我们只需要在登录请求的密码参数值，引用变量${pword}传输即可，如下： 最后查看结果树，加密成功，响应也正确了，如下： 最后做一下步骤总结：
找到开发要加密的jar包(不要怕直接要，他们会给的)，然后在测试计划内导入jar包。
在登录的请求下添加前置处理器-BeanShell PreProcessor，编写代码：导入加密jar包的类，然后使用加密类方法对明文进行加密，最后使用vars.put()方法传递给jmeter系统变量中。
最好在登录请求内的密码参数中，值用${变量名}引用进行发送请求即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaa247f73cc539fb2c5d9913d2e3abc0/" rel="bookmark">
			plink软件初体验3--计算样本杂合度和SNP位点杂合度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里，模拟一个plink文件的数据，8个样本，8个SNP位点，通过手动Excel计算样本杂合度和位点杂合度，比较plink计算杂合度的方法。
1. 模拟数据 ped数据：
$ cat a.ped FAMILY1 ID1 0 0 0 -9 CC CC AA GG AG GG GG GC FAMILY1 ID2 0 0 0 -9 CC GC AG GG GG AA AG CC FAMILY1 ID3 0 0 0 -9 GG CC AG GG GG GA AG GC FAMILY1 ID4 0 0 0 -9 GG CC GG GG GG AA GG GG FAMILY1 ID5 0 0 0 -9 GG CC GG GG GG AA AG GC FAMILY1 ID6 0 0 0 -9 GG CC GG GG GG AA AA CC FAMILY1 ID7 0 0 0 -9 GG CC GG AG AA AA GG CC FAMILY1 ID9 0 0 0 -9 GG CC GG AG AA AA GG CC map数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaa247f73cc539fb2c5d9913d2e3abc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986721d81636c559a472f8aa66e99e8f/" rel="bookmark">
			centos 切换用户_linux进入单用户模式的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：记得初中时有个刚毕业的老师要走了，同学们纷纷送礼，不过班上总有几个家庭拮据的同学，送的可能不入流或者没送吧，结果，老师一一数出了送的什么礼物，谁谁送的，哪些同学没心意，哪些同学没送，当时懵懂虫一般，好像并没啥，直到后来步入社会回想起，才悟到，其实那对于那几个掉队的人来说，实在有点太受伤害。 后来有个家境很不好的同学退学了，9年义务的最后一年还是放弃了，时隔多年我做一个恶意的猜测吧，那时的那位同学，是不是受到过周围的冷暴力而选择退学呢？当然，我也只能是猜测，没有任何的实际的或者理论来支持，那位同学也是从此再没见过，前年初中同学组了个群，也不曾见到他，或许他也和小编一样，躲在了大城市的角落里，不愿与过往有过多的交集吧
一，进入单用户模式的作用
单用户模式，只有一个用户可以访问某个资源的状态，在类Unix系统上工作时的一种拥有超级用户权限的模式，通常在引导菜单给予1或S参数能进入这个模式。这个模式只在面对主机实体时才有机会透过引导菜单进入，也因此确保超级权限授予的对象是能接触到主机的超级用户，此操作通常用于维护硬盘分区或更改超级用户密码等需在磁盘挂载前操作的维护，库都可以置于单用户模式linux单用户模式，也被称为维护模式，超级用户可以在此模式下恢复/修复系统问题 二，进入单用户的几种方式，以cento7为例子
方法 1：通过向内核添加 rd.break 参数来以单用户模式启动 CentOS/RHEL 7/8 系统方法 2：通过用 init=/bin/bash 或 init=/bin/sh 替换内核中的 rhgb quiet 语句来以单用户模式启动 CentOS/RHEL 7/8 系统方法 3：通过用 rw init=/sysroot/bin/sh 参数替换内核中的 ro 语句以单用户模式启动 CentOS/RHEL 7/8 系统 三，方法1实践：
通过向内核添加 rd.break 参数来以单用户模式启动系统重启系统，在 GRUB2 启动界面，按下 e 键来编辑选中的内核。第一个一般是最新的内核，如果想用旧的内核启动系统你也可以选择其他的行 CentOS 7的系统就找 linux16，提示：如果你的系统是 RHEL/CentOS 8，那么你需要找 linux。在utf-8后添加rd.break，然后ctrl+x，进入紧急模式
如下命令，root 文件系统以 “只读(ro)” 模式挂载，你可以用下面的命令来验证下。下面的输出也明确地告诉你当前是在紧急模式。 mount -o remount,rw /sysroot 为了修改 sysroot 文件系统，我们要用读写模式(rw)重新挂载，以及修改环境。
mount -o remount,rw /sysrootchroot /sysroot 现在，已经进入单用户模式，当修复完问题退出，可以执行下面的步骤，centos7默认使用 SELinux，因此创建下面的隐藏文件，这个文件会在下一次启动时重新标记所有文件
touch /.autorelabelreboot -f #或者连词exit也能退出重启 四，方法2实践：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/986721d81636c559a472f8aa66e99e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/190409471c39b7bf2a6959baeee76032/" rel="bookmark">
			适合 Java 新手的开源项目集合——在 GitHub 学编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-老荀
当今互联网份额最大的编程语言是哪一个？是 Java！这两年一直有听说 Java 要不行了、在走下坡路了。没错，Java 的确在走下坡路，未来的事情的确不好说，但是瘦死的骆驼比马大，未来的三五年之内，我相信 Java 仍然是行业“一哥”！各位是否和我刚学完 Java 基础语法时一样，陷入过不知道 Java 能做什么的困扰中？觉得 Java 只能在控制台里 System.out.println 打印打印猫啊狗啊、爸爸和儿子吗？
不！在开源的世界里，有着无数的 Java 项目等待你去发现探索，让我们一起跟着本篇文章去看看有哪些开源项目吧？
兴趣是最好的老师，HelloGitHub 就是帮你找到编程的乐趣。
这里是 HelloGitHub 的《GitHub 上适合新手的开源项目》系列，共计 5 篇文章：
C++ 篇
Python 篇
Go 篇
Java 篇
JavaScript 篇
本期是 Java 篇 希望这篇文章能让大家找到 GitHub 上适合自己学习的 Java 开源项目。可以把这次的学习当成一次游戏，一路打怪升级直至通关，我层层递进的设计了三个阶段：青铜-&gt;白银-&gt;黄金。为什么只到黄金？因为成为真正大牛的路是非常漫长的，我相信黄金之后的路。你一定就会有自己的想法了，大胆的走自己的路，成为那颗璀璨的“钻石”吧！
一、青铜 万事开头难
1.1 快乐的小鸟 作为整篇文章的开头，我选择了一个比较轻松好玩的项目，希望能够勾起你对编程的兴趣！作者仅使用了 Java 标准库还原了，曾经在手机上红遍一时的“愤怒的小鸟”。先 clone 把源码下载后，可以通过 java -jar FlappyBird.jar 直接运行，也可以通过运行源码中的 GameApp:main 方法来启动整个游戏。通过学习该项目可以学习到：
使用标准库中的一些工具，比如集合、播放音效、加载图片
如何利用多文件，把不同的逻辑拆分到不同的类中去，并相互之间协作构建起整个游戏的状态
一些设计模式的应用，比如单例、对象池
GitHub 地址：https://github.com/kingyuluk/FlappyBird
1.2 Java 圣经 高尔基说过：「书是人类进步的阶梯」。在历史的长河中诞生过无数的著作，计算机领域也不例外，而《Think in Java》就是我要重点介绍的一本著作，这本书给我的第一印象就是：全！从最基本的数据类型到之后的面向对象再到后面的泛型反射的高级话题，无所不包。我之前阅读的是第四版实体书，现在的好消息是，第五版来了！而且是以开源的形式。经过之前小项目的小打小闹，大家也有了一点编程的感觉了，是时候巩固下理论知识了，俗话说的好：「基础不牢，地动山摇」。现在这个阶段去阅读此著作一定会给你不一样的感觉，我甚至推荐你每到一个阶段，你可以回过头去翻翻这本经典书籍，每次都会有新的认识。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/190409471c39b7bf2a6959baeee76032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2775731daa4c16b6634416f96556ed85/" rel="bookmark">
			python能写什么_python用什么写成的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python是由C语言写的。那python到底是什么类型的语言呢？
Python是一种脚本语言，写好了就可以直接运行，省去了编译链接的麻烦，对于需要多动手实践的初学者而言，也就是少了出错的机会。而且Python还有一种交互的方式，如果是一段简单的小程序，连编辑器都可以省了，直接敲进去就能运行。
Python是一种清晰的语言，用缩进来表示程序的嵌套关系可谓是一种创举，把过去软性的编程风格升级为硬性的语法规定。再不需要在不同的风格间选择、再不需要为不同的风格争执。与Perl不同，Python中没有各种隐晦的缩写，不需要去强记各种奇怪的符号的含义。Python写的程序很容易懂，这是不少人的共识。
Python是一种面向对象的语言，但它的面向对象却不象C++那样强调概念，而是更注重实用。不是为了体现对概念的完整支持而把语言搞得很复杂，而是用最简单的方法让编程者能够享受到面向对象带来的好处，这正是Python能像Java、C#那样吸引众多支持者的原因之一。
Python是一种功能丰富的语言，它拥有一个强大的基本类库和数量众多的第三方扩展，使得Python程序员无需去羡慕Java的JDK。
Python为程序员提供了丰富的基本功能使得人们写程序时用不着一切都从最底层做起。说到这里，人们通常会用一种担心：脚本语言通常很慢。脚本语言从运行的速度讲的确会慢一些，但Python的速度却比人们想象得快很多。 虽然Python是一种脚本语言，但实际上也可以对它进行编译，就象编译Java程序一样将Python程序编译为一种特殊的ByteCode，在程序运行时，执行的是ByteCode，省去了对程序文本的分析解释，速度自然提升很多。
随着Python与人们的生活日渐密切，许多人都想转行从事Python开发，给自己的人生勾勒一个崭新的轮廓，那么学习Python，选择哪个Python培训班比较靠谱呢?综合评估，唯有千锋教育教授的是真正Python全栈开发，包含Python项目，爬虫、服务集群、网站后台、微信公众号开发，Python机器学习与数据挖掘，数据分析框架与实战，Python 物联网树莓派的开发等。内容更全、实用性更强，未来在激烈的市场竞争中脱颖而出的机率将大大增加。
以上就是python用什么写成的的详细内容，更多请关注php中文网其它相关文章！
本文原创发布php中文网，转载请注明出处，感谢您的尊重！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3dce64f0c22f300345bf78048ee640/" rel="bookmark">
			计算机导论——程序设计基础07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、程序设计基本概念 （1）程序语言的发展 1、第一代——机器语言 2、第二代——汇编语言 3、第三代——高级程序设计语言 4、第四代——非过程化程序设计语言 5、第五代——智能性语言 （2）程序设计语言举例 BASIC语言Pascal语言C语言C++语言Java语言 （3）高级语言程序的执行 高级语言编写的程序称为源程序，计算机不能直接执行源程序。
高级语言源程序：
解释性编译性 （4）程序设计的方法 面向对象程序设计面向过程程序设计 二、算法和结构化程序设计 （1）算法的概念 解决一个问题而采用的方法和步骤称为算法。
（2）算法的特性 有穷性确定性有输入有输出可行性 （3）算法的描述 用自然语言描述算法用伪代码描述算法用流程图描述算法用计算机高级程序设计语言描述算法 （4）算法的基本逻辑结构 顺序结构分支结构循环结构 （5）简单算法举例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4d61c0d0de04ede8b3ebc050aee9e0/" rel="bookmark">
			计算机导论——信息安全基础06
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信息安全概述 （1）信息安全的发展历史 目前信息安全已涉及攻击、防范、监测、控制、管理、评估等多方面的基础理论和实施技术，其中，密码技术和管理技术是信息安全的核心，安全标准和系统评估是信息安全的基础。
1、通信保密阶段（20世纪40年代—20世纪70年代） 古代加密方法古典加密方法近代加密方法 2、计算机系统安全阶段（20世纪70年代—20世纪80年代） 信息安全学术界形成以安全模型分析与验证为理论基础，以信息安全产品为构件，以安全域建设为主要目标的安全防护体系思想。
3、网络信息安全阶段 4、信息安全保障阶段 5、云计算安全阶段 （2）信息安全基本概念 1、信息安全的定义 通过实施一组控制达到，包括策略、措施、过程、组织结构及软件功能，是对机密性、完整性和可用性保护的一种特性。
2、安区服务 计算机信息系统的安全目标：
机密性完整性可用性不可否认性认证 （3）信息安全攻击 1、威胁机密性的攻击 窃听流量分析 2、威胁完整性的攻击 篡改伪装插入、重放否认 3、威胁可用性的攻击 4、其他类型攻击 5、主动攻击与被动攻击 （4）安全策略 信息安全策略是一组规则，他们定义了一个组织要实现的安全目标和实现这些安全目标的途径。
（5）安全机制 安全机制是实施安全策略的方法、工具或者规程。
1、加密技术 对称密码非对称密码密钥管理 2、信息完整性 3、数字签名 4、身份识别 5、流量填充 6、路由控制 7、公证 8、访问控制 9、事件检测与安全审计 10、恢复机制 二、信息安全体系结构 （1）信息安全体系结构的含义 信息系统安全由技术体系、组织机构体系、管理体系组成。
（2）技术体系 物理安全技术系统安全技术网络安全技术应用安全技术管理安全性 （3）OSI安全体系结构 1、OSI安全服务 ISO安全体系结构确定了5大类安全服务
认证服务访问控制服务数据保密性服务数据完整性服务不可否认服务 2、OSI的安全机制 8大类安全机制
加密机制数字签名机制访问控制机制数据完整性机制认证机制业务流填充机制路由控制机制公正机制 3、OSI中的安全管理 安全管理是对安全服务和安全机制进行管理，把管理信息分配到有关的安全服务和安全机制中去，并收集与它们的操作有关的信息。
（4）组织体系结构和管理体系结构 组织体系结构：机构，岗位、人事。
管理体系结构：决策层、管理层、执行层。
三、计算机网络安全 （1）网络安全协议 1、 IPSEC协议 2、SSL/TLS协议 3、电子商务安全与SET协议 （2）VPN 1、VPN概述 是指通过在一个公用网络中建立一条安全、专用的虚拟通道，连接异地的两个网络，构成逻辑上的虚拟子网。
安全可靠易于部署成本低廉 2、VPN技术原理 隧道技术：
自愿隧道强制隧道 3、VPN的应用 企业内部型VPN（Intranet VPN）企业扩展型VPN（Extranet VPN）远程访问型VPN（Access VPN） （3）防火墙 1、概述 防火墙是部署在两个网络之间的一个或一组部件，要求所有进出内部网络的数据流都通过它，并根据安全策略进行检查，只有符合安全策略，被授权的数据流才能通过，由此保护内部网络安全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4d61c0d0de04ede8b3ebc050aee9e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f7248ced1e5b15dab6620540fd43b4/" rel="bookmark">
			计算机导论——计算机网络05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络和现代通信技术相结合形成了计算机网络
计算机网络可以划分为两层结构：
外层为由主机构成的资源子网，主要提供共享资源和相应的服务。内层为由通信设备和通信线路构成的通信子网，主要提供网络的数据传输和交换。 一、数据通信基础 （1）数据通信的基本概念 数据通信是指在两结点之间进行信息传输与交换的过程
1、数据、信息和信号 数据是由数字、字符和符号等组成，是信息的载体。
信息是数据的具体内容，是数据经过加工处理后得到的，按一定要求以规定格式组织起来具有一定含义的数据
信号是数据在传输过程中的电信号的表示形式，它使数据以适当的形式在介质上传输。
电话线上传送的为模拟信号
计算机中产生的电信号是数字信号
2、数据通信系统模型 源系统：源系统包括信源和数据源。信源就是数据源，是发出待传送信息的设备。发送器是进行信号转换的设备。传输系统：传输系统可以是简单的信道，也可以是连接源系统和目的系统之间的辅助网络设备。目的系统：目的系统包括信宿和接收器。接收器接收传输系统传送过来的信号，并将其转换为能够被目的设备处理的信息。信宿是指信息的接收者。噪声：信号早传输过程中受到的干扰称为噪声。 3、数据通信系统的主要性能评价指标 传输速率带宽差错率 （2）传输介质 信号在介质中以电磁波的形式进行传输
1、有限传输介质 同轴电缆双绞线光纤 2、无线传输介质 无线电波微波红外线激光 二、计算机网络的基本概念 计算机网络是计算机技术与通信技术相结合的产物，它包括计算机软硬件，网络系统结构以及通信技术等内容。
（1）计算机网络的形成与发展 1、第一代计算机网络——以单计算机为中心的联机终端网络 2、第二代计算机网络——计算机—计算机网络 3、第三代计算机网络——网络体系结构和协议标准化的计算机网络 4、第四代计算机网络——高速化和综合化的计算机网络 （2）计算网络的定义 （3）计算机网络的分类 1、按地理范围分类 局域网广域网城域网 2、按资源共享方式划分 对等网客户/服务器网络 3、按通信传输技术分类 广播式网络点-点式网络 4、根据网络的拓扑结构 总线型网络拓扑结构环形网络拓扑结构星型网络拓扑结构树形网络拓扑结构网状型网络拓扑结构混合型网络拓扑结构蜂窝拓扑结构 三、计算机网络通信协议 （1）网络通信协议概述 计算机网络中将计算机之间通信所必须遵守的规则、标准或约定统称为网络协议。
网络”分层“将复杂的网络问题简化成若干较小的局部问题，出现了层间协议。
（2）ISO与OSI参考模型 1、OSI参考模型的层次 ISO：国际标准化组织
OSI/RM：开发系统互连参考模型
2、OSI/RM各层的主要功能和协议 物理层数据链路层网络层传输层会话层表示层应用层 3、TCP/IP参考模型 应用层传输层网络互联层主机-网络层 四、局域网 （1）局域网概述 局域网是指那些覆盖一个有限的地理范围。
从硬件角度：一个局域网是由计算机、网络适配器、传输媒体以及其他连接设备组成的集合体
从软件角度：LAN在网络操作系统的同一调度下给网络用户提供文件、打印、通信等软硬件资源共享服务功能
（2）以太网 IEEE802.3标准系列IEEE802.3标准的介质访问控制（MAC）方法10Base-T以太网100Base-T以太网千兆位以太网 （3）无线局域网 （4）以太网的组网技术 组网中的组要设备
服务器工作站网卡局域网集线器RJ-接头局域网操作系统网络协议 五、Internet基础 （1）Internet发展和结构 （2）Internet接入 1、因特网服务器提供者ISP 因特网服务提供者能为用户提供因特网接入服务，它是用户接入因特网的入口点。
2、Internet接入技术 使用调制解调器接入XDSL接入DDN、X。25、帧中继等专线方式接入ISDN接入无线接入光纤宽带接入HFC无源光网络电力网接入（PLC） （3）IP地址 1、IP地址结构 一个IP地址划分为两部分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f7248ced1e5b15dab6620540fd43b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae618147b338dff84f98c1d66a789c8/" rel="bookmark">
			python保留两位小数_python保留小数位的三种实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
保留小数位是我们经常会碰到的问题，尤其是刷题过程中。那么在python中保留小数位的方法也非常多，但是笔者的原则就是什么简单用什么，因此这里介绍几种比较简单实用的保留小数位的方法：
方法一：format函数
1
2
3
4
&gt;&gt;&gt;print('{:.3f}'.format(1.23456))
1.235
&gt;&gt;&gt;print(format(1.23456,'.2f'))
1.23
正如上面代码所示，format有不同用法，前者使用了占位符{}，使用占位符可以同时输出多个，后者一次只能输出一个，需要注意的是占位符中的冒号不能丢。笔者推荐使用占位符+format输出。
1
2
&gt;&gt;&gt;print('{:.3f} {:.2f}'.format(1.23456,1.23456))
1.235 1.23
方法二：'%.xf'方法
1
2
&gt;&gt;&gt;print('%.2f' % 1.23456)
1.23
这种方法同样比较简单直观，看大家习惯选择吧，笔者还是习惯第一种方法。
方法三：round()函数
1
2
3
4
5
6
7
8
&gt;&gt;&gt;print(round(1.23456,3))
1.235
&gt;&gt;&gt;print(round(2.355,2))
2.35
&gt;&gt;&gt;print(round(2.5))
2
&gt;&gt;&gt;print(round(3.5))
4
round()函数比较迷，它不完全是按照四舍五入的原则来进位的，因此不建议大家使用。它的保留值将保留到离上一位更近的一端（四舍六入），如果距离两端一样远，则会保留到偶数的一边。好了笔者也要绕晕了，反正笔者是不会用这种方法的。
总结
以上所述是小编给大家介绍的python保留小数位的三种实现方法，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对服务器之家网站的支持！
如果你觉得本文对你有帮助，欢迎转载，烦请注明出处，谢谢！
原文链接：https://www.cnblogs.com/marvin-wen/archive/2020/01/06/12159155.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8983da6ac99583052f0695a65f2efa21/" rel="bookmark">
			网易2020校招数据分析方向正式批笔试题 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网易2020校招数据分析方向正式批笔试题 选择题简答题编程题 题目来自网易2020校招数据分析方向正式批笔试题
选择题 关于主成分分析说法错误的是 PCA可以用来降维处理
PCA可以通过SVD来实现
PCA实现线性组合最大化样本方差
PCA可以通过特征值分解来实现
2个盒子被小牛分别放入中有两个大小相同的球，这两个球只可能是红和蓝两种颜色，并且一个球是红的还是蓝的是等可能的。小牛让小客来猜盒子里球的颜色分别是什么样颜色。在小客猜的过程中，小牛告诉小客其中一个是盒子里面是红色的小球，那么另一个盒子里球还是红色的概率是多少 题解：
总共4种情况：红红、红蓝、蓝红、蓝蓝
现在已知一个是红色 排除最后一种 还有一个是红的概率是 1/3
若 f ′ ( e x ) = x e − x , f ( 1 ) = 1 f'(e^x) = xe^{-x},f(1)=1 f′(ex)=xe−x,f(1)=1,那么 f ( e ) = ? f(e)=? f(e)=? 令 y = e x , x = l n y y = e^x , x = lny y=ex,x=lny ,则$ f’(y) = lny * y^{-1}$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8983da6ac99583052f0695a65f2efa21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/510cbe3265a4af6ff9a3f5fa772d8c75/" rel="bookmark">
			C语言  程序环境和预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的内容会详细讲到在编译过程中发生的事，也会讲解预处理的问题。
程序的翻译环境和执行环境 在ANSI C的任何一种实现中，存在两个不同的环境。
第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。
第2种是执行环境，它用于实际执行代码。
（一）翻译环境
翻译过程如下图：
组成一个程序的每个源文件通过编译过程分别转换成目标代码(.obj)。每个目标文件由链接器捆绑在一起，形成一个单一而完整的可执行程序。链接器同时也会引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员个人的程序库，将其需要的函数也链接到程序中。 1.编译
预处理 选项 gcc -E test.c -o test.i 预处理完成之后就停下来，预处理之后产生的结果都放在test.i文件中。
编译 选项 gcc -S test.c 编译完成之后就停下来，结果保存在test.s中。
编译是把C语言翻译成汇编代码
汇编 gcc -c test.c 汇编完成之后就停下来，结果保存在test.o中。
注：上面指令都在Linux环境下完成
在编译三个阶段中，要进行的操作如下图：
2.链接
（1）合并段表：不同符号表之间的段按照一定的规则合并，生成exe可执行文件。
（2）符号表的合并和符号表的重定位
具体过程如下图：
（二）运行环境
程序执行的过程：
程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。程序的执行便开始。接着便调用main函数。开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。终止程序。正常终止main函数；也有可能是意外终止。 预处理详解 预定义符号
__FILE__ //进行编译的源文件 __LINE__ //文件当前的行号 __DATE__ //文件被编译的日期 __TIME__ //文件被编译的时间 __STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义 举例
printf("file:%s line:%d date:%s time:%s\n", __FILE__, __LINE__, __DATE__, __TIME__); #define
（1） #define定义标识符
语法：
#define name stuff
举例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/510cbe3265a4af6ff9a3f5fa772d8c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e1c1d2b3a9ac39f804e1aceb0e7783/" rel="bookmark">
			armeabi,armeabi-v7a，arm64- v8a的不同
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前android打包可以支持如下cpu架构 armeabi-v7a 第7代 ARM v7，使用硬件浮点运算，具有高级扩展功能（支持 armeabi 和 armeabi-v7a，目 前大部分手机都是这个架构）
arm64-v8a 第8代，64位，包含AArch32、AArch64两个执行状态对应32、64bit（支持 armeabi-v7a、 armeabi 和 arm64-v8a）
x86 intel 32位，少数的平板应用此架构（支持 armeabi(性能有所损耗) 和 x86）
x86_64 intel 64位，少数的平板应用此架构（支持 x86 和 x86_64）
随着手机性能的越来越好，从armeabi-&gt;armeabi-v7a-&gt;armeabi-v8a更新
在android打包出来的apk里面就包含这四种cpu平台。对于armeabi-v7a是arm32位的，这种支持着armeabi 和 armeabi-v7a。对于arm64-v8a是arm64位的，这种支持着支持 armeabi-v7a、 armeabi 和 arm64-v8a。
目前市面上手机设备绝大多数都是arm架构，因此armv7a几乎能兼容所有设备。大多数应用只会打包armv7a 的so在Apk中。对于第三方服务，如百度地图、Bugly等会提供全平台的cpu架构。因此我们可以进行如下配 置，指定只打包armv7a到apk，从而减少apk大小,例如京东app,解压打开都是放到v7a中。
但是上google play的话，目前只支持64位的了，另外看微信android app下载，默认下载的是64的，还有支持下载32位的，所以我们如果有需要可以分开打包。
具体方法：productFlavor 或 splits
此外：app在寻找so库时的原则是：
arm64-v8a手机,只放armeabi-v7a的app;在找so文件时,会发现没有arm64- v8a目录,那就会去找armeabi-v7a目录,(如果没有发现没有armeabi-v7a目录,就会去找armeabi目录)
armeabi-v7a手机,只放了arm64-v8a的app;在找so文件时,就会找不到对应的so库,所以只放v8a的,就会放弃掉32位的设备
需要注意的是:如果你的app,arm64-v8a目录放了a.b so文件, armeabi-v7a目录放了c so文件,那c这个so文件就找不到了,因为发现有arm64-v8a目录后,就不会再去找32位的目录了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6589026e3166583f94064b57bc1773b3/" rel="bookmark">
			loadrunner录制事件为0_测试工具LoadRunner常见问题汇总，解决方案整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LoadRunner是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。
我们在使用它进行测试的过程中经常会遇到一些错误，这些错误可能是由于设置不当引起，也有可能是选项设置引起，更有可能是测试执行中的一些细节没有注意而引起的，在此做一个系列总结。
1、LoadRunner超时错误如何解决?
在录制Web协议脚本回放时超时情况经常出现，产生错误的原因也有很多，解决的方法也不同。
错误现象1：Action.c(16)： Error -27728: Step download timeout (120 seconds) has expired when downloading non-resource(s)。
错误分析：对于HTTP协议，默认的超时时间是120秒(可以在LoadRunner中修改)，客户端发送一个请求到服务器端，如果超过120秒服务器端还没有返回结果，则出现超时错误。
解决办法：首先在运行环境中对超时进行设置，默认的超时时间可以设置长一些，再设置多次迭代运行，如果还有超时现象，需要在"Runtime Setting"&gt;"Internet Protocol：Preferences"&gt;"Advanced"区域中设置一个"winlnet replay instead of sockets"选项，再回放是否成功。
错误现象2：Action.c(81)：Continuing after Error -27498: Timed out while processing URL= querystat/ subOrderQuery.do
错误分析：这种错误常常是因为并发压力过大，服务器端太繁忙，无法及时响应客户端的请求而造成的，所以这个错误是正常现象，是压力过大造成的。
如果压力很小就出现这个问题，可能是脚本某个地方有错误，要仔细查看脚本，提示的错误信息会定位某个具体问题发生的位置。
解决办法：例如上面的错误现象问题定位在某个URL上，需要再次运行一下场景，同时在其他机器上访问此URL。如果不能访问或时间过长，可能是服务器或者此应用不能支撑如此之大的负载。分析一下服务器，最好对其性能进行优化。
如果再次运行场景后还有超时现象，就要在各种图形中分析一下原因，例如可以查看是否服务器、DNS、网络等方面存在问题。
最后，增加一下运行时的超时设置，在"Run-Time Settings"&gt;"Internet Protocol:Preferences"中，单击"options"，增加"HTTP-request connect timeout"或者"HTTP-request receive"的值。
2、 LoadRunner脚本中出现乱码：
在录制Web协议脚本时出现中文乱码，在回放脚本时会使回放停止在乱码位置，脚本无法运行。
错误现象：某个链接或者图片名称为中文乱码，脚本运行无法通过。
错误分析：脚本录制可能采用的是URL-based script方式，如果程序定义的字符集合采用的是国际标准，脚本就会出现乱码现象。
解决办法：重新录制脚本，在录制脚本前，打开录制选项配置对话框进行设置，在"Recording Options"的"Advanced"选项里先将"Surport Charset"选中，然后选中支持"UTF-8"的选项。
3、 LoadRunner HTTP服务器状态代码：
在录制Web协议脚本回放的过程中，会出现HTTP服务器状态代码，例如常见的页面-404错误提示、-500错误提示。
错误现象1：-404 Not Found服务器没有找到与请求URL相符的资源，但还可以继续运行直到结束。
错误分析：此处与请求URL相符的资源在录制脚本时已经被提交过一次，回放时不可再重复提交同样的资源，而需要更改提交资源的内容，每次回放一次脚本都要改变提交的数据，保证模拟实际环境，造成一定的负载压力。
解决办法：在出现错误的位置进行脚本关联，在必要时插入相应的函数。
错误现象2：-500 Internal Server Error服务器内部错误，脚本运行停止。
错误分析：服务器碰到了意外情况，使其无法继续回应请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6589026e3166583f94064b57bc1773b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1718adc8f181205ce205dd72efd3070/" rel="bookmark">
			Linux(入门基础):18---Linux下sleep函数与usleep函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 时钟换算：
1s = 1000ms
1ms = 1000μs
1μs = 1000ns
1ns = 1000ps
一、sleep 头文件: #include &lt;unistd.h&gt; 功 能: 执行挂起指定的秒数 语 法: unsigned sleep(unsigned seconds); 举例： void father() { int i; for(i = 0 ;i &lt; 3;i++) { printf("father\n"); sleep(1); } } 二、usleep
头文件: #include&lt;windows.h&gt; //在VC中使用带上头文件 #include &lt;unistd.h&gt; //在gcc编译器中，使用的头文件因gcc版本的不同而不同 功 能: usleep功能把进程挂起一段时间， 单位是微秒（百万分之一秒）； 语 法: void usleep(int micro_seconds); 返回值: 无 内容说明：本函数可暂时使程序停止执行。参数 micro_seconds 为要暂停的微秒数(us)。 注 意： 这个函数不能工作在windows 操作系统中。用在Linux的测试环境下面。 参 见:usleep() 与sleep()类似，用于延迟挂起进程。进程被挂起放到reday queue。 一般情况下，延迟时间数量级是秒的时候，尽可能使用sleep()函数。如果延迟时间为几十毫秒（1ms = 1000us），或者更小，尽可能使用usleep()函数。这样才能最佳的利用CPU时间。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3106e26b4fd9039d055297448dccdb/" rel="bookmark">
			性能优化之apk瘦身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一:apk的分析 将apk直接拖入到android studio中,可以分析出lib,res等文件的大小可以用https://nimbledroid.com/;这个网址可以直接分析apk的文件大小,dex方法数,sdk方法数 二:代码瘦身 1.第三方库的瘦身 各个三方库依赖的同个库版本需一致对于同类型的库，选择方法数少的，可以用插件android method count来计算对于一个库中只需要用其一个模块的功能，只需要集成对应功能即可，例如fresco中只需要其webp图片加载功能 2.删除无用的代码 业务代码不断的增加代码太多不敢删除，怕以后还得用到用aop统计使用情况 三:资源瘦身 右键 -&gt; Refactor -&gt; remove unused res。-&gt; preview。这个去除没有用到的资源文件图片压缩,可以用熊猫网站压缩图片图片格式的选择,对于网络图片可以用webp格式的,一些图标也可以用svg格式的资源混淆:https://github.com/shwenzhang/AndResGuard;可以将冗长的资源路径变短图片可以只保留一份,在mipmap-xhdpi,其会自动放大缩小根据分辨率对于一些图片可以放到服务器,app启动对其预加载 四:so库瘦身 目前支持的cpu架构有：armeabi-v7a(arm32)，arm64- v8a(arm64)，x86，x86-64的四种,对于so库我们应该选择v7a还是v8a呢?
举个例子:
1.arm64-v8a手机,只放armeabi-v7a的app;在找so文件时,会发现没有arm64- v8a目录,那就会去找armeabi-v7a目录,(如果没有发现没有armeabi-v7a目录,就会去找armeabi目录)
2.armeabi-v7a手机,只放了arm64-v8a的app;在找so文件时,就会找不到对应的so库,所以只放v8a的,就会放弃掉32位的设备
3.需要注意的是:如果你的app,arm64-v8a目录放了a.b so文件,
armeabi-v7a目录放了c so文件,那c这个so文件就找不到了,因为发现有arm64-v8a目录后,就不会再去找32位的目录了
可以看到微信也是32和64都打了包,所以我们可以看需求:
最好是32位的打一个,64的打一个,毕竟64的效率肯定更高;如果不想这么麻烦就直接用armeabi-v7a即可
面试 apk的长期瘦身的有效处理 在后期开发新功能的时候,发版之前需与上一个版本包体积对比,超过阈值则必须要优化模块推进以插件化的形式进行动态下发 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9d21328a5cbc11eda44faf7f6ed7549/" rel="bookmark">
			python统计中文字符的个数_python如何统计字符串中字母个数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法：首先用“str_count = 0”定义字母的字符初始个数为0；接着遍历字符串，判断字符串内各字符的类型，并将字母个数累加；最后用“print(‘字母 = %d’ %(str_count))”输出字母个数结果即可。
python统计字符串中字母个数
给一个字符串，统计其中的数字、字母和其他类型字符的个数；
例如：输入“254h!%he”，输出：数字=3，字母=3，其他=2
方法：
①首先用“str_count = 0”定义字母的字符初始个数为0
②接着遍历字符串，判断字符串内各字符的类型，并将字母个数累加；
③最后用“print(‘字母 = %d’ %(str_count))”输出字母个数结果即可。
数字初始个数int_count = 0
字母初始个数str_count = 0
其他字符初始个数other_count = 0
输入字符串a = input(‘please input a str\n’)
遍历字符串for i in a:
# 判断是否为数字
if i.isdigit():
int_count += 1
# 判断是否为字母
elif i.isalnum():
str_count += 1
# 判断为其他字符
else:
other_count += 1
print(‘数字 = %d, 字母 = %d，其他 = %d’ %( int_count ,str_count,other_count))
以上就是python如何统计字符串中字母个数？的详细内容，更多请关注php中文网其它相关文章！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9d21328a5cbc11eda44faf7f6ed7549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85cb99eeaf0088f6976ded4797330f2f/" rel="bookmark">
			pymysql安装_第八章 nova组件安装2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在控制节点安装nova组件
apt -y install nova-api nova-placement-api nova-conductor nova-consoleauth nova-scheduler nova-novncproxy python3-novaclient # 配置文件 mv /etc/nova/nova.conf /etc/nova/nova.conf.org # 备份官方的 vi /etc/nova/nova.conf # 修改如下 # create new [DEFAULT] # allow resize to same host allow_resize_to_same_host = True # block allocate time block_device_allocate_retries = 600 block_device_allocate_retries_interval = 6 max_concurrent_live_migrations = 10 debug = True # 打开调试功能 use_neutron = True linuxnet_interface_driver = nova.network.linux_net.LinuxBridgeInterfaceDriver # LinuxBridge桥接 firewall_driver = nova.virt.firewall.NoopFirewallDriver # define own IP my_ip = 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85cb99eeaf0088f6976ded4797330f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1ef95ac835d39f62c157fb074aa848/" rel="bookmark">
			css滚动条不占用宽度_如何把控css的方向感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github: MrXujiang 学习方法推荐 问题学习法：带着问题去学习，有利于集中注意力，目的明确，这既是有意学习的要求，也是发现学习的必要条件。心理学家把注意分为无意注意与有意注意两种。有意注意要求预先有自觉的目的，必要时需经过意志努力，主动地对一定的事物发生注意。它表明人的心理活动的主体性和积极性。问题学习法就是强调有意注意有关解决问题的信息，使学习有了明确的指向性，从而提高学习效率。 在介绍完问题学习法之后，进入我们今天的主题，接下来我会介绍css的一些底层的知识和比较诡异的现象，借此来让大家对css有更深入的理解。
一.css尺寸 1.首选最小宽度–实现复杂图形效果 在css中，图片和文字的权重远大于布局，因此当width:0时表现出来的宽度就是“首选最小宽度”。 中文的最小宽度为每个汉字的宽度，西方文字取决于连续的英文字符单元。 因此，我们可以跟据这个它特性，去实现一些复杂的图形，如下：
当鼠标经过时，变成了下面的样子：
代码如下：
.minW{ display: inline-block; width: 0 } .minW::before { content: "love 你 love"; color: transparent; outline: 2px solid #cd0000; } .minW:hover::before{ content: "你 love 我"; color: transparent; outline: 2px solid #cd0000; } 我们会发现，当容器宽度设置为0后，由于首选宽度的影响，出现了基于文字空间的形状。
2.2.子元素宽度设为100%时的奇怪现象原理探究 父元素的宽度 = 图片宽度 + 文字内容宽度 浏览器渲染原理：先下载文档内容，加载头部样式资源，然后按从上到下、自外而内的顺序渲染dom内容。 本例的现象产生的原因就是：当渲染到父元素时，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素的宽度已经固定，此时的width:100%就是以固定好的父元素的宽度，宽度不够只能溢出。 .box{ display: inline-block; white-space: nowrap; } .text{ display: inline-block; width: 100%; } 理论上父元素宽度因该是子元素宽度之和，但是却出现了上图的现象，原因归根就在于浏览器渲染的顺序：自外而内，这点十分重要。
3.如何让元素支持height:100%效果 知识点：绝对定位的宽高百分比是基于padding-box的，而非绝对定位的宽高百分比是基于content-box 方法如下：
* 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1ef95ac835d39f62c157fb074aa848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c7403ef47c33afea9027637146e0ba/" rel="bookmark">
			python用户界面画图_使用Tkinter绘制GUI并结合Matplotlib实现交互式绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/env python
#coding:utf-8
"""
Author: Chaos --
Purpose: 修改Matplotlib的后端，实现在Tkinter的GUI绘制图像
Created: 2014-10-15
"""
import numpy as np
from Tkinter import *
import matplotlib
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
#----------------------------------------------------------------------
def drawPic():
"""
获取GUI界面设置的参数，利用该参数绘制图片
"""
#获取GUI界面上的参数
try:sampleCount=int(inputEntry.get())
except:
sampleCount=50
print '请输入整数'
inputEntry.delete(0,END)
inputEntry.insert(0,'50')
#清空图像，以使得前后两次绘制的图像不会重叠
drawPic.f.clf()
drawPic.a=drawPic.f.add_subplot(111)
#在[0,100]范围内随机生成sampleCount个数据点
x=np.random.randint(0,100,size=sampleCount)
y=np.random.randint(0,100,size=sampleCount)
color=['b','r','y','g']
#绘制这些随机点的散点图，颜色随机选取
drawPic.a.scatter(x,y,s=3,color=color[np.random.randint(len(color))])
drawPic.a.set_title('Demo: Draw N Random Dot')
drawPic.canvas.show()
if __name__ == '__main__':
matplotlib.use('TkAgg')
root=Tk()
#在Tk的GUI上放置一个画布，并用.grid()来调整布局
drawPic.f = Figure(figsize=(5,4), dpi=100)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60c7403ef47c33afea9027637146e0ba/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/200/">«</a>
	<span class="pagination__item pagination__item--current">201/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/202/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>