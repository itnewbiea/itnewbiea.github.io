<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba06130ac501df638954580b3a4bf21/" rel="bookmark">
			Android 13.0 修改Android系统的通知自动成组的数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景: Android 系统对显示在通知列表中的同一个应用的通知进行分组管理,即相同的packageName中,当通知数量达到系统默认指定的数量时,会自动成一组.
Android 13.0 中系统默认的自动成组数如下所示:
核心路径 : frameworks/base/core/res/res/values/config.xml &lt;!-- 来自同一应用程序的通知的默认数量，然后由操作系统自动分组 --&gt; &lt;integer translatable="false" name="config_autoGroupAtCount"&gt; 2 &lt;/integer&gt; 如果想修改系统默认的自动分组数,则修改属性为 config_autoGroupAtCount 后的值即可.
参考: 相对比于Android 12.0 和 Android 11.0 指定的默认自动成组数为 4 , 在 Android 13.0 中该值为 2 .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bdf67a7870c086c47080127b864490/" rel="bookmark">
			Android 11.0 修改Android系统的通知自动成组的数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景: Android 系统对显示在通知列表中的同一个应用的通知进行分组管理,即相同的packageName中,当通知数量达到系统默认指定的数量时,会自动成一组.
Android 11.0 中系统默认的自动成组数如下所示:
核心路径 : frameworks/base/core/res/res/values/config.xml &lt;!-- 来自同一应用程序的通知的默认数量，然后由操作系统自动分组 --&gt; &lt;integer translatable="false" name="config_autoGroupAtCount"&gt; 4 &lt;/integer&gt; 如果想修改系统默认的自动分组数,则修改属性为 config_autoGroupAtCount 后的值即可.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633b5a8483281949ef5ededfa324910f/" rel="bookmark">
			Android 12.0 修改Android系统的通知自动成组的数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景: Android 系统对显示在通知列表中的同一个应用的通知进行分组管理,即相同的packageName中,当通知数量达到系统默认指定的数量时,会自动成一组.
Android 12.0 中系统默认的自动成组数如下所示:
核心路径 : frameworks/base/core/res/res/values/config.xml &lt;!-- 来自同一应用程序的通知的默认数量，然后由操作系统自动分组 --&gt; &lt;integer translatable="false" name="config_autoGroupAtCount"&gt; 4 &lt;/integer&gt; 如果想修改系统默认的自动分组数,则修改属性为 config_autoGroupAtCount 后的值即可.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12773d52922577d6f27937e70e790df3/" rel="bookmark">
			JS的常用验证密码正则(转自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS的正则表达式
强：字母+数字+特殊字符 ^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)(?![a-zA-z\d]+$)(?![a-zA-z!@#$%^&amp;*]+$)(?![\d!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$
中：字母+数字，字母+特殊字符，数字+特殊字符
^(?![a-zA-z]+$)(?!\d+$)(?![!@#$%^&amp;*]+$)[a-zA-Z\d!@#$%^&amp;*]+$
弱：纯数字，纯字母，纯特殊字符
^(?:\d+|[a-zA-Z]+|[!@#$%^&amp;*]+)$
//校验是否全由数字组成
function isDigit(s)
{
var patrn=/^[0-9]{1,20}$/;
if (!patrn.exec(s)) return false
return true
}
//校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串
function isRegisterUserName(s)
{
var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/;
if (!patrn.exec(s)) return false
return true
}
function isRegisterUserName(s)
{
var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/;
if (!patrn.exec(s)) return false
return true
}
//校验用户姓名：只能输入1-30个以字母开头的字串
Javascript代码
function isTrueName(s)
{
var patrn=/^[a-zA-Z]{1,30}$/;
if (!patrn.exec(s)) return false
return true
}
}}
//校验密码：只能输入6-20个字母、数字、下划线
function isPasswd(s)
{
var patrn=/^(\w){6,20}$/;
if (!patrn.exec(s)) return false
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12773d52922577d6f27937e70e790df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be0fb718a41e67acae276f62f5fd8cb/" rel="bookmark">
			npm 更换镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候npm install 安装时太慢了，可以试试设置淘宝镜像
1、更换镜像
npm config set registry https://registry.npm.taobao.org
2、查看镜像
npm config get registry
如果返回 https://registry.npm.taobao.org/，说明配置的是淘宝镜像。
3、还原镜像
npm config set registry https://registry.npmjs.org
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b08e1c85b7fdbd59e2cf26281e1fe7/" rel="bookmark">
			超详细！箭头函数全解，从基础到高级应用一网打尽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		超详细！箭头函数全解，从基础到高级应用一网打尽 前言1.箭头函数的基础语法1.1 箭头函数的基本结构:1.2 对比传统函数表达式:1.3 箭头函数的简便之处: 2.箭头函数的词法作用域2.1 词法作用域的概念:2.2 箭头函数继承父作用域:2.3 避免了传统函数中的this陷阱: 3.箭头函数与this关键字3.1 传统函数中的 `this` 行为:3.2 箭头函数中的 `this` 行为:3.3 箭头函数与传统函数的对比: 4.单行箭头函数的隐式返回4.1 隐式返回的概念:4.2 单行箭头函数的基本用法:4.3 多行箭头函数的注意事项:4.4 使用场景： 5.箭头函数与高阶函数5.1 高阶函数的概念:5.2 灵活运用箭头函数的高阶函数:5.2.1 使用箭头函数简化回调:5.2.2 在高阶函数中传递箭头函数: 5.3 箭头函数在高阶函数中的优势:5.4 示例：使用箭头函数实现高阶函数： 6. 使用箭头函数简化回调6.1 在事件处理中使用箭头函数:6.2 在数组方法中使用箭头函数:6.3 在定时器中使用箭头函数:6.4 在 Promise 中使用箭头函数:6.5 在条件语句中使用箭头函数: 7. 箭头函数的不足与注意事项7.1 没有自己的 `this`:7.2 不适用于构造函数:7.3 适用场景的限制:7.4 避免在复杂的对象方法中使用箭头函数: 8. 解构参数与箭头函数8.1 解构数组参数:8.2 解构对象参数:8.3 默认值和解构参数:8.4 结合数组解构和剩余参数: 9. 箭头函数与数组方法的完美搭配9.1 使用箭头函数进行映射（`map`）:9.2 使用箭头函数进行筛选（`filter`）:9.3 使用箭头函数进行迭代（`forEach`）:9.4 使用箭头函数进行累积（`reduce`）:9.5 使用箭头函数进行转换（`map` + 箭头函数 + 解构参数）:9.6 使用箭头函数进行条件筛选: 10. 异步编程中的箭头函数10.1 Promise 中使用箭头函数:10.2 Async/Await 中使用箭头函数:10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b08e1c85b7fdbd59e2cf26281e1fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f59363dd75aa847a36aad11dc1f0fc8/" rel="bookmark">
			《四》Javascript 中的引用类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Object 类型： 对象是用来保存多个数据的容器。
对象的组成：
属性：属性由属性名和属性值组成。方法：方法是一种特殊的属性，它的属性值是函数。 创建 Object 类型： 使用 Object 构造函数创建，可以省略 new 关键字。var obj=new Object() / /创建一个对象 obj.name=’小米’ // 创建属性 obj.run=function(){ // 创建方法 return “123” } 使用对象字面量方式创建，使用最多。var obj={ // 创建一个对象 name:’小米’, // 创建属性 run:function (){ // 创建方法 rerurn ‘123’ } } 属性： 访问对象的属性： 访问对象的属性有两种方法：
一般使用点表示法访问对象属性。但也可以使用方括号表示法访问对象属性：属性名要以字符串的形式放在方括号中。如果属性名中包含会导致语法错误的字符，或者使用的是变量名，就可以选择使用方括号表示。 console.log(person.name) console.log(person[“name”]) person[“first name”] var proppertyName=”name” console.log(person[proppertyName] === person['name']) // true 删除对象的属性 删除对象的属性是使用 delete 操作符。
var person={ name: ’Lee’ } delete person.name alert(person.name) // undefined 判断对象中是否有某属性： 判断对象中是否有某属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f59363dd75aa847a36aad11dc1f0fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976272eb1e171b0aeb155014eede3a62/" rel="bookmark">
			相同的树 单值二叉树 二叉树的最大深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相同的树单值二叉树二叉树的最大深度 相同的树 力扣：100相同的树
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1：
输入：p = [1,2,3], q = [1,2,3]
输出：true
示例 2：
输入：p = [1,2], q = [1,null,2]
输出：false
示例 3：
输入：p = [1,2,1], q = [1,1,2]
输出：false
提示：
两棵树上的节点数目都在范围 [0, 100] 内
-104 &lt;= Node.val &lt;= 104
分析：
如果两个二叉树都为空，那么这两个二叉树必定相同
如果这两个二叉树一个为空，另一个不为空，那么两个二叉树必定不相等
如果两个二叉树都不为空，那么就判断根节点是否相同：如果不相同，那么两个二叉树必定不相同；如果相同，再去遍历两个二叉树的左子树和右子树。
这是一个递归的过程，也是分治思想，都是去判断两个二叉树自己（根节点）的值是否相同，然后再去遍历左右子树，不是左右孩子。
代码：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* p, struct TreeNode* q) { if(p==NULL&amp;&amp;q==NULL) return true; if(p==NULL||q==NULL) return false; if(p-&gt;val!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976272eb1e171b0aeb155014eede3a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8e1437d5555c2a66282c8387057042/" rel="bookmark">
			Antd可编辑表格初始数据为空，单元格不能编辑的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑科技超简单:
给table表格增加行className rowClassName={() =&gt; 'editable-row'}
然后设置可编辑表格的行样式
.editable-row:hover .editable-cell-value-wrap { border: 1px solid #d9d9d9; border-radius: 4px; padding: 4px 11px; } .editable-cell-value-wrap { padding: 5px 12px; cursor: pointer; min-height: 32px; } 这样即使是空值的时候我们也可以点击到，从而修改值了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7483a088e1a709f9621539626dfbef33/" rel="bookmark">
			python完美表白代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.源代码
import turtle import time # 清屏函数 def clear_all(): turtle.penup() turtle.goto(0, 0) turtle.color('white') turtle.pensize(800) turtle.pendown() turtle.setheading(0) turtle.fd(300) turtle.bk(600) # 重定位海龟的位置 def go_to(x, y, state): turtle.pendown() if state else turtle.penup() turtle.goto(x, y) # 画爱心 def draw_heart(size): turtle.color('red', 'pink') turtle.pensize(2) turtle.pendown() turtle.setheading(150) turtle.begin_fill() turtle.fd(size) turtle.circle(size * -3.745, 45) turtle.circle(size * -1.431, 165) turtle.left(120) turtle.circle(size * -1.431, 165) turtle.circle(size * -3.745, 45) turtle.fd(size) turtle.end_fill() # 画出发射爱心的小人 def draw_people(x, y): turtle.penup() turtle.goto(x, y) turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7483a088e1a709f9621539626dfbef33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3caf160b71b95fbbb63a81ba7649a8/" rel="bookmark">
			Flash-Attention代码调用尝试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flash-Attention代码调用尝试 本文主要介绍通过如何通过源码方式使用flash-attention，以实现更自由的调用。
1.介绍 Flash-attention原理：
论文：
FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness
Tri Dao, Daniel Y. Fu, Stefano Ermon, Atri Rudra, Christopher Ré
Paper: https://arxiv.org/abs/2205.14135
IEEE Spectrum article about our submission to the MLPerf 2.0 benchmark using FlashAttention. FlashAttention
FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning
Tri Dao
Paper: https://tridao.me/publications/flash2/flash2.pdf
源码：
https://github.com/Dao-AILab/flash-attention
FlashAttention-2 硬件支持
Ampere, Ada, or Hopper GPUs (e.g., A100, RTX 3090, RTX 4090, H100).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3caf160b71b95fbbb63a81ba7649a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7bae35d56c6c947ff4811e452d6ff96/" rel="bookmark">
			PLECS: Analysis tools 分析工具，伯德图 Bode 分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关键词：PLECE,伯德图，Bode，BUCK
记录目的：记录 Plecs 的分析工具使用方法，会根据Demo学习使用根据生成电路的 伯德图。
软件：PLECS 4.7.3
1.先通过软件自带Demo学习 1.1 Demo路径 如下图是软件自带的Demo，一个buck电路的分析模型文件：
文件名：buck_converter_with_analysis_tools.plecs
路径：\Plexim\PLECS 4.7 (64 bit)\demos\buck_converter_with_analysis_tools
1.2 Analysis tools 分析工具使用 打开文件后，按如下图路径找到对应菜单
点击 Start analysis 按钮后，待分析完成会弹出如下窗口。
2.学习Demo 自建分析模型 2.1 复制分析模型 将如下框中的PWM部分复制到自己的文件中，并连接到上管，右边的小信号分析模块接入电压信号。
2.2添加测试项目 添加测试项目
分析出的伯德图
2.3 导出分析数据的CSV文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c0f74804d7275b4ba7ad9e151bba5c/" rel="bookmark">
			Redis-安装、配置和修改配置文件、以及在Ubuntu和CentOS上设置Redis服务的开机启动和防火墙设置，以及客户端连接。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. Redis简介
2. 离线安装
2.1 准备工作
2.2 解压、安装
2.3 修改配置文件
2.4 redis服务与关闭
2.5 redis服务的开机启动
2.5.1 Ubuntu上的配置
2.5.2 centos上的配置
3. 在线安装
4. 设置防火墙
5. 客户端连接
1. Redis简介 Redis 是完全开源免费的，遵守BSD协议，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。
特点：
支持数据的持久化，可以将内存中的数据保存到硬盘，在重启后再次加载使用。
支持的数据结构丰富，String，list，set， zset， hash等等。
支持数据备份，master-slave模式进行数据备份。
优势：
性能高，Redis能读的速度是110000次/s,写的速度是81000次/s。
数据类型丰富
原子性，redis中所有操作都是原子的，并且多个操作也支持原子性
丰富的特性，如通知，key过期等。
2. 离线安装 说明：该例的示例步骤基于ubuntu16版本。
2.1 准备工作 在离线安装redis前先安装两个软件，gcc和make，为方便安装可以先将用户切换到root下（使用 su 命令，需要输入root的密码）
1）安装gcc
apt-get install gcc 2）安装make
apt-get install make 关于gcc和make
GCC（GNU Compiler Collection，GNU编译器套件），是由 GNU 开发的编程语言编译器。它是以GPL许可证所发行的自由软件，也是 GNU计划的关键部分。GCC是Linux下重要的编译工具。
make工具的定义是通过编写的makefile脚本文件描述整个工程的编译、链接规则；通过脚本文件，对于复杂的工程也可以只通过一个命令就完成整个编译过程。类似于java中的maven
3）下载redis5，本例下载到了/home/lise目录下。
wget http://download.redis.io/releases/redis-5.0.3.tar.gz 注： wget简介
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c0f74804d7275b4ba7ad9e151bba5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a1e50379d5b4efc5faf18b27067ef4/" rel="bookmark">
			uni-app 自定义宫格布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;view class="grid"&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;168&lt;/view&gt; &lt;view class="grid-text"&gt;数量&lt;/view&gt; &lt;/view&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;168&lt;/view&gt; &lt;view class="grid-text"&gt;数量&lt;/view&gt; &lt;/view&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;95.64%&lt;/view&gt; &lt;view class="grid-text"&gt;在线率&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="grid"&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;168&lt;/view&gt; &lt;view class="grid-text"&gt;数量&lt;/view&gt; &lt;/view&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;168&lt;/view&gt; &lt;view class="grid-text"&gt;数量&lt;/view&gt; &lt;/view&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;95.64%&lt;/view&gt; &lt;view class="grid-text"&gt;在线率&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="grid"&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;168&lt;/view&gt; &lt;view class="grid-text"&gt;数量&lt;/view&gt; &lt;/view&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;168&lt;/view&gt; &lt;view class="grid-text"&gt;数量&lt;/view&gt; &lt;/view&gt; &lt;view class="grid-item"&gt; &lt;view class="grid-num"&gt;95.64%&lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a1e50379d5b4efc5faf18b27067ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4764bacaa62516ba5753c612f2327af/" rel="bookmark">
			消息中间件——RabbitMQ（七）高级特性 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇消息中间件——RabbitMQ（七）高级特性 1中我们介绍了消息如何保障100%的投递成功？,幂等性概念详解,在海量订单产生的业务高峰期，如何避免消息的重复消费的问题？,Confirm确认消息、Return返回消息。这篇我们来介绍下下面内容。
自定义消费者消息的限流（防止占用内存过多，节点宕机）消息的ACK与重回队列TTL消息死信队列 1. 自定义消费者 1.1 消费端自定义监听 我们一般就在代码中编写while循环，进行consumer.nextDelivery方法进行获取下一条消息，然后进行消费处理！
但是这种轮训的方式肯定是不好的，代码也比较low。
我们使用自定义的Consumer更加的方便，解耦性更加的强，也是在实际工作中最常见的使用方式！ 1.2 代码演示 1.2.1 生产者 public class Producer { public static void main(String[] args) throws Exception { //1 创建ConnectionFactory Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel(); String exchange = "test_consumer_exchange"; String routingKey = "consumer.save"; String msg = "Hello RabbitMQ Consumer Message"; for(int i =0; i&lt;5; i ++){ channel.basicPublish(exchange, routingKey, true, null, msg.getBytes()); } } } 1.2.2 消费者 public class Consumer { public static void main(String[] args) throws Exception { // 创建ConnectionFactory Connection connection = ConnectionUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4764bacaa62516ba5753c612f2327af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f78ddb460a8893092801930195f4a0e/" rel="bookmark">
			消息中间件——RabbitMQ（七）高级特性 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前面我们介绍了RabbitMQ的安装、各大消息中间件的对比、AMQP核心概念、管控台的使用、快速入门RabbitMQ。本章将介绍RabbitMQ的高级特性。分两篇（上/下）进行介绍。
消息如何保障100%的投递成功？幂等性概念详解在海量订单产生的业务高峰期，如何避免消息的重复消费的问题？Confirm确认消息、Return返回消息 1 消息如何保障100%的投递成功？ 1.1 什么是生产端的可靠性投递？ 保障消息的成功发出保障MQ节点的成功接收发送端收到MQ节点（Broker）确认应答完善的消息进行补偿机制 前三步不一定能保障消息能够100%投递成功。因此要加上第四步
BAT/TMD 互联网大厂的解决方案：
– 消息落库，对消息状态进行打标
在发送消息的时候，需要将消息持久化到数据库中，并给这个消息设置一个状态（未发送、发送中、到达）。当消息状态发生了变化，需要对消息做一个变更。针对没有到达的消息做一个轮训操作，重新发送。对轮训次数也需要做一个限制3-5次。确保消息能够成功的发送.
消息的延迟投递,做二次确认,回调检查 具体采用哪种方案,还需要根据业务与消息的并发量而定。
1.2 第一种方案： 生产端-可靠性投递
图解：
蓝色部分表示：生产者负责发送消息发送至Broker端
Biz DB：订单数据库 MSG DB: 消息数据
面对小规模的应用可以采用加事务的方式，保证事务的一致性。但在大厂中面对高并发，并没有加事务，事务的性能拼接非常严重，而是做补偿。
比如：如下发一条订单消息。
step1：存储订单消息（创建订单），业务数据入库，消息也入库。缺点:需要持久化两次。（status:0）
step2：在step1成功的前提下，发送消息
step3：Broker收到消息后，confirm给我们的生产端。Confirm Listener异步监听Broker回送的消息。
step4：抓取出指定的消息，更新（status=1），表示消息已经投递成功。
step5：分布式定时任务获取消息状态，如果等于0则抓取数据出来。
step6：重新发送消息
step7：重试限制设置3次。如果消息重试了3次还是失败，那么（status=2）,认为这个消息就是失败的。
查询这些消息为什么失败，可能需要人工去查询。
假设step2执行成功，step3由于网络闪断。那么confirm将永远收不到消息，那么我们需要设定一个规则：
例如：在消息入库的时候，设置一个临界值 timeout=5min，当超过5min之后，就将这条数据抓取出来。
或者写一个定时任务每隔5分钟就将status=0的消息抓取出来。可能存在小问题：消息发送出去，定时任务又正好刚执行，Confirm还未收到，定时任务就会执行，会导致消息执行两次。
更精细化操作：消息超时容忍限制。confirm在2-3分钟内未收到消息，则重新发送。
保障MQ我们思考如果第一种可靠性投递，在高并发的场景下是否合适？ 第一种方案对数据有两次入库，一次业务数据入库，一次消息入库。这样对数据的入库是一个瓶颈。
其实我们只需要对业务进行入库。
消息的延迟投递，做二次确认，回调检查 这种方式并不一定能保证100%成功，但是也能保证99.99%的消息成功。如果遇到特别极端的情况，那么就只能需要人工去补偿，或者定时任务去做。
第二种方式主要是为了减少对数据库的操作。
看下第二种方式：
图解：
Upstream service:生产端
DownStream service:消费端
Callback service:回调服务
step1:业务消息入库成功后，第一次消息发送。
step2:同样在消息入库成功后，发送第二次消息，这两条消息是同时发送的。第二条消息是延迟检查，可以设置2min、5min 延迟发送。
step3:消费端监听指定队列。
step4:消费端处理完消息后，内部生成新的消息send confirm。投递到MQ Broker。
step5: Callback Service 回调服务监听MQ Broker,如果收到Downstream service发送的消息，则可以确定消息发送成功，执行消息存储到MSG DB。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f78ddb460a8893092801930195f4a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074dd699710da0ec1eb45f13b31788e3/" rel="bookmark">
			TensorFlow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TensorFlow是一个开源的机器学习框架，由Google开发和维护。它支持多种机器学习算法，包括神经网络、决策树等，可以用于各种各样的任务，如图像分类、自然语言处理、语音识别等。
TensorFlow的核心概念是计算图（Computation Graph）和张量（Tensor）。计算图是用来表示算法中操作和数据流的图，节点表示操作，边表示数据流。张量是TensorFlow中的基本数据类型，可以被看做一个多维数组，可以在计算图中流动。
TensorFlow的使用场景非常广泛，常见的包括：
1. 图像识别：利用卷积神经网络（CNN）进行图像分类、识别等任务。
2. 自然语言处理：利用循环神经网络（RNN）进行文本分类、语言生成等任务。
3. 强化学习：利用策略梯度等算法进行智能体的决策。
4. 推荐系统：利用深度神经网络进行用户个性化推荐。
5. 数据分析：利用TensorFlow进行数据探索、特征提取等。
TensorFlow是一种非常强大的机器学习工具，可以帮助开发者构建和训练复杂的机器学习模型。同时，它也有着广泛的应用场景，如图像识别、自然语言处理、推荐系统、智能体决策等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e049883d7461f5273b393a8017179d81/" rel="bookmark">
			vue3 setup写法页面引入个性化子组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;component :is="Tab3Name" &gt;&lt;/component&gt; import { ref, computed } from 'vue'; import a from './stepThree.vue'; import b from '@/views/idv/330702000016/joint/stepThree.vue'; let code="11" // 判断个性化条件 const omponentName = computed(() =&gt; { switch (code) { case '11': return a; default: return b; } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf59ac793c80852239152a4de84be1f1/" rel="bookmark">
			android@adb连接电脑和android设备@安装和卸载@清除app数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 refadb连接电脑和android设备android设备端设置和准备电脑端准备 android设备开发者选项设置推荐(可选)实例adb 安装app实例👺adb 卸载app实例 FAQ@可能出现的问题👺错误的进入adb shellmore than one device/emulator 第三方安装器查看应用版本清除app数据 参考adb文档 ref Android 调试桥 (adb) | Android 开发者 | Android Developers adb连接电脑和android设备 android设备端设置和准备 USB选项: 选择文件传输而不是仅充电(只会导致文件传输等功能无法生效) 典型错误:more than one device/emulator 打开开发者选项(developerOptions)启用USB调试(USB debugging) Switche to debugging mode when USB is connected 允许通过USB安装应用(apps)(Install via USB) 根据设备情况启用(比如MIUI) (可选)关闭授权过期功能(Disalble adb authorizatoin timeout) 电脑端准备 下载adb工具包,并将所在目录用命令行打开(推荐配置到系统环境变量,以便在任何目录下可以调用adb)将需要安装的包准备在已知目录(比如桌面)或者adb命令工具所在目录 前者使用绝对路径定位安装包位置:执行命令的格式为adb install xxx/xxx/appName.apk&gt;完成安装后者只需要知道安装包的名字即可执行安装:执行adb install &lt;appName.apk&gt;完成安装即可 android设备开发者选项设置推荐(可选) 如果您经常用手机连接电脑做通行/传输,那么建议将usb连接的默认选项设置为File Transfer(文件传输)设置方法: 较新android设备可以在设置搜索框中搜索默认或者直接在设置中按照打开路径:Additional settings/Developer options/Default Use configuration/File Transfer 实例 adb 安装app实例👺 检查设备链接情况
PS C:\Users\cxxu\Desktop\n11tp&gt; adb devices List of devices attached UO7PKFNF99IR9TV4 device 执行安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf59ac793c80852239152a4de84be1f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a81dec252c567f2b404ef4b256deec/" rel="bookmark">
			MySQL8.0的中文OCP考题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e0ff0fef12b9e2e36b53f1767f6ffb/" rel="bookmark">
			怎么添加留言功能_为公众号增添互动魅力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、了解留言功能的重要性
在当今的互联网时代，互动和沟通变得尤为重要。留言功能作为网站或应用的重要组件之一，能够让用户与网站或应用进行实时的互动和交流，从而提高用户参与度和活跃度。通过留言功能，用户可以随时随地发表自己的观点、意见和建议，同时也可以与其他用户进行讨论和交流。这种互动不仅能够增强用户的黏性，还可以为企业或个人带来更多的流量和收益。
二、选择合适的留言功能实现方式
第三方留言系统：使用第三方留言系统是一种便捷的实现方式。你可以选择一些知名且稳定的第三方留言系统，如Disqus、Livefyre等。这些留言系统通常提供易于集成、功能强大的特点，并且可以与各种网站或应用进行无缝对接。自定义开发：如果你具备足够的开发能力和技术实力，可以选择自定义开发留言功能。通过编写代码和集成相应的API，你可以根据自己的需求和网站或应用的风格来设计和开发留言功能。在线表单：如果你只是需要简单的留言功能，可以考虑使用在线表单来实现。一些在线表单工具，如Google Forms、 Wufoo等，可以方便地创建和发布问卷调查、反馈表等，同时也支持用户提交留言。 三、实现留言功能的步骤
选择合适的留言功能实现方式：根据自身需求和实际情况选择一种适合自己的留言功能实现方式。配置留言审核机制：为了确保留言的质量和网站的秩序，需要配置留言审核机制。你可以设置自动审核或手动审核，同时也可以根据需要对敏感词汇进行过滤。设计留言界面：根据网站或应用的风格和需求，设计一个简洁明了且易于操作的留言界面。界面应该包括留言输入框、提交按钮以及其他必要的功能组件。实现留言数据的存储和处理：根据所选的留言功能实现方式，编写代码或配置相应的API来存储和处理留言数据。确保数据的安全性和完整性。实现留言列表的展示：在留言界面中，设计一个留言列表来展示用户的留言信息。列表应该包括留言者的姓名、留言时间、留言内容等关键信息。实现回复功能：为了方便用户之间的互动和交流，可以在留言列表中实现回复功能。用户可以点击回复按钮来回复其他用户的留言。测试和优化：在完成留言功能的开发和测试后，进行全面的测试以确保其稳定性和可靠性。同时可以根据反馈和实际使用情况进行适当的优化和改进。 四、注意事项
保护用户隐私：在实现留言功能时，要充分考虑用户隐私的保护。不要收集或泄露用户的敏感信息，同时也要确保留言内容的安全性和可靠性。提高用户体验：在设计和实现留言功能时，要注重提高用户体验。提供清晰的操作指南和友好的界面设计，同时也要确保留言的显示顺序和加载速度等方面的优化。及时回复和审核：为了保持用户的活跃度和信任度，要及时回复用户的留言并审核通过。对于违规或不良言论要及时处理和纠正，确保网站或应用的良性发展。定期维护和更新：对于已经实现的留言功能要进行定期维护和更新。及时修复潜在的问题和漏洞，同时也要根据用户反馈和市场变化进行适时的调整和改进。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c4d63beda47b9db184409b5aca8236/" rel="bookmark">
			深入理解 PHP Session 配置与跨域共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发 Web 应用程序时，我们经常需要保存用户会话状态。PHP 提供了一套简便的机制来处理会话数据，即 Session。Session 允许您在不同请求之间存储用户特定的信息。然而，在前后端分离和跨域的场景中，正确配置 Session 变得极为关键。今天，我们将探讨如何在 PHP 中配置和优化 Session 设置，并解决跨域 Session 共享的问题。
Session 存储形式 首先，我们需要确定 Session 的存储形式。默认情况下，PHP 以文件形式在服务器上存储 Session 数据。但是，我们可以通过修改 session.save_handler 来指定其他存储方式，例如 Memcache 或者自定义的用户存储方式（如数据库或 Redis）。
session.save_handler = files Session 存储路径 对于以文件形式存储的 Session，我们必须指定存储 Session 文件的路径。这可以通过设置 session.save_path 来实现。如果使用 Memcache，则该设置用作服务器连接字符串。
session.save_path = "D:\xampp\tmp" 注意，有一种设置格式为 "N;/path"，用于随机分级存储 Session 文件，但请记住，这样会使得垃圾回收功能失效。
Cookie 配置 Session 通常依赖于 Cookie 来存储用户的 Session ID。以下是一些重要的 Cookie 相关配置：
session.use_cookies = 1 session.use_only_cookies = 1 session.name = PHPSESSID session.cookie_lifetime = 0 session.cookie_path = / session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41c4d63beda47b9db184409b5aca8236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d43add4e23903f550e7f0c8c5bcc600/" rel="bookmark">
			运行芋道代码，Cannot find module @rollup/rollup-win32-x64-msvc. 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cannot find module @rollup/rollup-win32-x64-msvc. npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). Please try `npm i` again after
removing both package-lock.json and node_modules directory.
运行芋道代码，报错。
一顿百度搜索居然没有一条能对的上。 搜索msvc. 显示缺少.dll文件，需要修复,我以为是vscode软件的问题，需要修复。卸载vscode，重新安装高版本的vscode。v1.84
vscode
三步骤：
node -v v19.19 官网下载
npm -v v8.17
pnpm -v v8.11
安装完后，还是报错。最后去官网继续看，看看有没有思路
1.重新下载代码
2.跟着步骤一步一步走，对于版本要求严格
官网：快速启动（前端项目） | ruoyi-vue-pro 开发指南
Windows 安装 Node.js 指南：NodeJS 安装指南（Windows 版本） | 芋道源码 —— 纯源码解析博客
启动。报Uncaught SyntaxError: Unexpected reserved word，
转载：解决Uncaught SyntaxError: Unexpected reserved word-CSDN博客
最终没有报最上面的错误，成功启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df84007774557a0ceba8f160357a923/" rel="bookmark">
			crui_lvgl 一个LVGL的DSL辅助工具的设想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设想 Target以LVGL为目标，语法以CSS为Reference。
CSS 规范 略
CSS规范最强大的属于CSS自身的属性很多，可以通过class和伪属性选择器对UI进行直接控制。
QML规范 ApplicationWindow { visible: true width: Constants.width height: Constants.height title: qsTr("Coffee") ApplicationFlowForm { id: applicationFlow state: "initial" property int animationDuration: 400 choosingCoffee.brewButtonSelection.onClicked: { applicationFlow.state = "settings" } } Image { id: root source: "images/icons/coffees/cappucino.png" signal clicked property int duration: 250 property alias text: label.text MouseArea { anchors.fill: parent onClicked: root.clicked() onPressed: { glow.visible = true animation1.start() animation2.start() } } Rectangle { id: glow visible: false width: 250 height: 250 color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df84007774557a0ceba8f160357a923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b92b0e8e87d8f8755551a9c803fa8ea/" rel="bookmark">
			微信小程序本地和真机调试文件上传成功但体验版不成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是微信小程序ip白名单的问题，去微信公众平台（小程序）上设置小程序的ip白名单
1、在本地中取消不校验
然后在本地去上传文件，就会发现控制台报错了，会提示一个https什么不在ip白名单，复制那个网址
2、微信公众平台中设置刚才那个网址
三个红色箭头的网址就是复制加进去的，每个网址用;隔开，然后等待一段时间就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507e05241b14354f071bb0edf3e235e2/" rel="bookmark">
			ground truth 在深度学习任务中代表的是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概念 在深度学习领域，ground truth (中文意思是“地面真实值”或“基准真实值”，简单理解就是真实值) 是指用于训练和评估模型的准确标签或数据。它是机器学习算法的参考标准，用于衡量模型的性的和判断模型的准确性，本文将介绍 “ground truth” 在深度学习中的应用。
2、在深度学习中的作用 在深度学习任务中，我们通常需要训练一个模型来预测输出 输入数据的某些属性或标签。这些标签通常由 专家手动标注(准确性高)，以提供准确的参考值。这些参考值就被称为 “ground truth”。
“ground truth” 在深度学习中起到以下几个重要作用：
训练模型： 深度学习模型通过与 “ground truth” 进行比较学习 以获得输入到输出的映射关系，通过最小化预测值与 “ground truth” 之间的误差，模型能够学习到更准确的预测能力。评估模型的性能："ground truth"用于评估模型的性能和准确性，通过比较模型的预测值与 “ground truth”，我们可以计算出各种评估指标如准确率、召回率、精率等)，以判断模型的优劣。对比算法之间的差异： 在比较不同算法或模型之间的性能时，我们需要一个公共的 “ground truth”（参考标准）。通过与同样的 “ground tnuth” 进行比较，我们可以客观地评估不同算法或模型之间的差异。 3、总结 总的来说，“ground truth” 是模型训练和评估过程中的基准标准，也是评估模型性能和准确度的关键指标。通过它，可以直接间接评估模型的性能。
4、代码演示 import numpy as np import matplotlib.pyplot as plt # 生成一些模拟数据 np.random.seed(42) X = np.linspace(0, 10, 100) # 输入特征 y_true = 2 * X + 1 + np.random.normal(scale=2, size=len(X)) # 真实的目标值，带有一些噪音 # 可视化模拟数据和真实情况 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507e05241b14354f071bb0edf3e235e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79606b099e240bfe6c36c60d05db4005/" rel="bookmark">
			RK3568笔记六：基于Yolov8的训练及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处。
基于Yolov8的训练及部署，参考鲁班猫的手册训练自己的数据集部署到RK3568,用的是正点的板子。
1、 使用 conda 创建虚拟环境 conda create -n yolov8 python=3.8 ​ conda activate yolov8 2、 安装 pytorch 等等 根据pytorch自行安装
3、 安装 ，直接使用命令安装 方法有两种，个人使用的是第二种方法：
方法一：
通过pip安装
pip install ultralytics -i https://mirror.baidu.com/pypi/simple 方法二：
通过拉取仓库然后安装
git clone https://github.com/ultralytics/ultralytics ​ cd ultralytics ​ pip install -e . # 安装成功后，使用命令 yolo 简单看下版本
(yolov8) llh@anhao:/$ yolo version ​ 8.0.206 4、简单测试 下载权重文件
wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt *获取测试图片，可以下面位置获取，可能会失败，也可以从配套例程获取
wget https://ultralytics.com/images/bus.jpg 使用 yolo 命令进行测试
yolo detect predict model=./yolov8n.pt source=./bus.jpg ​# 预测图片结果保存在当前 runs 目录下，具体路径是.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79606b099e240bfe6c36c60d05db4005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1944ac526e80bd9810ab14af4b0991d3/" rel="bookmark">
			python 重定向输出到控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class RedirectText(io.TextIOBase): def __init__(self): self.browser = None def setTextBrowser(self, browser): self.browser = browser def write(self, text): scroll_bar = self.browser.verticalScrollBar() scroll_bar.setSliderPosition(scroll_bar.maximum()) text_cursor = self.browser.textCursor() text_cursor.movePosition(QTextCursor.End) text_cursor.insertText(text) class MainWindow(QMainWindow): def __init__(self): super(MainWindow, self).__init__() self.ui = Ui_MainWindow() self.ui.setupUi(self) redirect_text = RedirectText() # 保存原来的标准输出 original_stdout = sys.stdout # 重定向标准输出到自定义的写入器 sys.stdout = redirect_text redirect_text.setTextBrowser(self.ui.plainTextEdit) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f83c15e4ef2aec8186c3e0df83105cb4/" rel="bookmark">
			Linux 有线网络驱动实验(PHY芯片LAN8720)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 嵌入式网络简介嵌入式下的网络硬件接口MII/RMII 接口MDIO 接口RJ45 接口I.MX6ULL ENET 接口简介 PHY 芯片详解PHY 基础知识简介LAN8720A 详解SR8201F 详解 Linux 内核网络驱动框架net_device 结构体net_device_ops 结构体sk_buff 结构体网络 NAPI 处理机制(综合轮询和中断方式) I.MX6ULL 网络驱动简介I.MX6ULL 网络外设设备树I.MX6ULL 网络驱动源码简析fec_netdev_ops 操作集Linux 内核PHY 子系统与MDIO 总线简析 网络驱动实验测试LAN8720 PHY 驱动测试通用PHY 驱动测试DHCP 功能配置 单网卡使用只使用ENET2 网卡只使用ENET1 网卡 和自己工作的IOT项目类似。项目里使用AWS的框架，分为linux系统和freertos系统。Freetros里需使用AT指令驱动4g，不同的模组驱动有差异，需自己实现模组AT驱动然后注册到AWS框架里面。
嵌入式网络简介 网络驱动是linux 里面驱动三巨头之一，linux 下的网络功能非常强大，嵌入式linux 中也常常用到网络功能。前面我们已经讲过了字符设备驱动和块设备驱动，本章我们就来学习一下linux 里面的网络设备驱动。
嵌入式下的网络硬件接口 本章节讨论的都是有线网络！
注意！正点原子I.MX6U-ALPHA开发板V2.4版本以前的底板使用的网络PHY 为LAN8720，V2.4 及其以后的版本使用的网络PHY 为SR8201F，而且网络PHY 地址有改变，大家一定要看准自己所使用的底板版本号！原理基本一致，本章就以LAN8720 为例进行讲解。
以下摘自：yhttps://baike.c114.com.cn/view.asp?id=8730-169B7DF1
网卡芯片也有“软硬”之分，特别是对与主板板载(LOM)的网卡芯片来说更是如此，这是怎么回事呢?大家知道，以太网接口可分为协议层和物理层。
协议层是由一个叫MAC(Media Access Layer，媒体访问层)控制器的单一模块实现。
物理层由两部分组成，即PHY(Physical Layer，物理层)和传输器。
常见的网卡芯片都是把MAC和PHY集成在一个芯片中，但目前很多主板的南桥芯片已包含了以太网MAC控制功能，只是未提供物理层接口，因此，需外接PHY芯片以提供以太网的接入通道。这类PHY网络芯片就是俗称的“软网卡芯片”，常见的PHY功能的芯片有RTL8201BL、VT6103等等。
“软网卡”一般将网络控制芯片的运算部分交由处理器或南桥芯片处理，以简化线路设计，从而降低成本，但其多少会更多占用系统资源.
提起网络，我们一般想到的硬件就是“网卡”，“网卡”这个概念最早从电脑领域传出来，顾名思义就是能上网的卡。在电脑领域的“原始社会”，网卡是独立的硬件，如果电脑要上网就得买个网卡插上去，类似现在的显卡一样。但是大家现在观察自己的笔记本或者台式机主板会发现并没有类似显卡一样的网卡设备，原因是随着技术的不断发展，现在只需要一个芯片就可以实现有线网卡功能，因此网卡芯片都直接放到了主板上。所以大家在接触嵌入式的时候听到“网卡”这两个字，不要急着在开发板上找“卡”一样的东西。
既然现在网卡已经是通过一个芯片来完成了，那么是什么样的芯片呢？这个就要先了解一下嵌入式中的网络硬件方案。首先，嵌入式网络硬件分为两部分：MAC 和PHY，大家都是通过看数据手册来判断一款SOC 是否支持网络，如果一款芯片数据手册说自己支持网络，一般都是说的这款SOC 内置MAC，MAC 类似I2C 控制器、SPI 控制器一样的外设。但是光有MAC还不能直接驱动网络，还需要另外一个芯片：PHY，因此对于内置MAC 的SOC，其外部必须搭配一个PHY 芯片。但是有些SOC 内部没有MAC，那也就没法搭配PHY 芯片了，这些内部没有网络MAC 的芯片如何上网呢？这里就要牵扯出常见的两个嵌入式网络硬件方案了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f83c15e4ef2aec8186c3e0df83105cb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c10ce45b6cfcd517cd52152fc6d4cf/" rel="bookmark">
			ubuntu开机自动执行某条命令、程序的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考systemd控制服务的设置方法
1. 安装systemd sudo apt-get install systemd 2. 在/etc/systemd/system目录下创建test1.service文件，内容如下： # 服务名称，可自定义 Description = frp server After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动frps的命令，需修改为您的frps的安装路径 # 也是就是开机要执行的命令 ExecStart = /path/to/frps -c /path/to/frps.toml [Install] WantedBy = multi-user.target 3. 设置开机自动启动即可，即是test1.service的文件名 sudo systemctl enable test1 设置方法至此已经结束，下面介绍一些配套的管理命令 # 启动frp sudo systemctl start frps # 停止frp sudo systemctl stop frps # 重启frp sudo systemctl restart frps # 查看frp状态 sudo systemctl status frps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6597ab696520bd0ed8892277759ed1f0/" rel="bookmark">
			20届 信息安全毕业设计(论文)选题推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
选题背景意义
信息安全毕设选题
选题迷茫
选题的重要性
更多选题指导
最后 前言 大四是整个大学期间最忙碌的时光,一边要忙着准备考研,考公,考教资或者实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。大四的同学马上要开始毕业设计,对选题有疑问可以问学长哦!
以下整理了适合不同方向的计算机专业的毕业设计选题
🚀对毕设有任何疑问都可以问学长哦!
更多选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是毕设选题专场,本次分享的是
🎯 20届 信息安全毕业设计(论文)选题推荐
选题背景意义 随着计算机科学与技术领域的迅速发展，计算机方向的毕业设计已经成为培养学生综合能力和创新思维的重要环节。计算机领域的广泛应用涵盖了人工智能、数据科学、信息安全、软件工程等各个方向。在这个数字化时代，计算机领域的问题和挑战也日益复杂和多样化，因此，选择一个合适的毕业设计选题具有重要意义。
信息安全毕设选题 研究方向：网络安全防御、入侵检测与防护、安全协议设计、密码学、网络隐私保护等。技术框架：Wireshark、Metasploit、OpenSSL、Nmap、Snort等 学长为大家准备了一些近年来比较流行的毕业设计选题，具体如下：
基于云端的身份认证方法及系统信息技术在档案管理中的应用研究基于区块链技术的疫情健康码方案基于迭代二分聚类的K-匿名机制云外包数据的可搜索加密技术研究一种面向智慧灯杆的可信认证方法统一账号实名制管理的设计与实现变电站智能设备信息安全技术与实现运营商用户信息检测与安全分析研究面向车联网的数据安全防护技术研究基于联盟链的医疗数据存储方法研究基于人脸检测的图像混沌加密及优化基于区块链的电子病例隐私保护方法基于标签增强的掌静脉识别算法研究基于击键动力学的身份认证技术研究多数据库单点登录身份认证模型研究一种基于区块链的跨域身份认证方法基于计算机网络的蠕虫防御和检测技术基于混合模式匹配算法的网络入侵检测基于深度学习的网络流量异常预测方法基于网络流量分析的未知恶意软件检测基于同态加密的人脸识别隐私保护方法商用密码在海洋数据安全中的应用研究掌上医院平台信息安全风险分析与控制基于深度学习的遮挡人脸识别技术研究高校网站群统一管理平台的研究与应用基于改进降噪自编码模型的网络入侵检测基于对抗深度学习的物联网安全检测方法基于动态IP黑名单的入侵防御系统模型基于平均特征重要性和集成学习的异常检测基于人工智能的通信网络入侵检测系统设计 海浪学长作品示例： 选题迷茫 毕设开题阶段,同学们都比较迷茫该如何选题,有的是被要求自己选题,但不知道自己该做什么题目比较合适,有的是老师分配题目,但题目难度比较大,指导老师提供的信息和帮助又比较少,不知道从何下手。与此同时,又要准备毕业后的事情,比如考研,考公,实习等,一边忙碌备考或者实习,一边还得为毕设伤透脑筋。
选题的重要性 毕设选题其实是重中之重,选题选得是否适合自己将直接影响到后面的论文撰写和答辩,选题不当很可能导致后期一系列的麻烦。
1.选题难易度
选题不能太难,也不能太简单。选题太难可能会导致知识储备不够项目做不出来,选题太难,则可能导致老师那边不同意开题,很多同学的课题被一次次打回来也是这个原因之一。
2.工作量要够
除非是算法类或者科研性项目,项目代码要有一定的工作量和完整度,否则后期论文的撰写会很难写,因为论文是要基于项目写的,如果项目的工作量太少,又缺乏研究性的东西,则会导致很难写出成篇幅的东西。
更多选题指导 最新最全计算机专业毕设选题精选推荐汇总
最后 🏆🏆🏆为帮助大家节省时间,如果对开题选题,或者相关的技术有不理解,不知道毕设如何下手,都可以随时来问学长,我将根据你的具体情况,提供帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab0f354e5f616104b3e6e26b9920f70/" rel="bookmark">
			ModbusRTU\TCP消息帧解析（C#实现报文发送与解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 知识点常用链接一、Modbus1.ModbusRTU消息帧解析2.主站poll、从站slave通讯仿真-modbusRTU1.功能码=01读线圈状态2.功能码=03读保持寄存器报文解析（寄存器存整型）报文解析（寄存器存float） 3.C#模拟主站Poll（ModbusRTU协议-组报文）4.NModbus4模拟主站poll（ModbusRTU协议）5.C#模拟主站Poll（ModbusTCP协议-组报文）6.NModbus4模拟从站slave（ModbusTCP协议）7.NModbus4模拟从站slave（ModbusRTU协议）8.modbusRTU、modbusTCP报文不同之处 二、明文TCP 知识点 PLC寄存器中存储（整型和无符号整型：2字节。长整型：4字节。单精度浮点数：4字节。双精度浮点数：8字节），我们只要知道数据类型，是2个字节一截取，还是4个字节 ，对接收到的报文进行字节截取然后编码成str就行向PLC中写入Float，float占4个字节=2个寄存器，所以要使用功能码“写多寄存器0x10”, 功能码0x06只能写一个寄存器”serialPort.write(bytes,0,bytes.Length); thread.sleep(300); serialPort.Read() 发完指令后，要等待从站响应300ms,然后再去读数据主站请求从站有两种方式：主动（手动点击查询线圈状态的按钮）被动（通过委托方式，一件事情的发生触发另外事件。场景：称菜，菜一放上去，触发去查询的功能代码块）一个F要用4个二进制表示，两个F用8个二进制表示，所以 0xFA ：表示1个字节modbusTCP响应 Tx:00 00 00 00 00 03 01 83 02 【83=1000 0011 （功能码03 的高位为1，就是异常）02是错误码代号要查表】
send()/recv()和write()/read()：发送数据和接收数据 参考链接socket原理不同协议图，
比如omoronsocekt, modbustcp,他们都是用socket进行数据交互，只是他们在应用层采用不同的协议约定，对报文进行不同方式的解析；明文协议就是直接编码不组包，其他协议都是组包发出去（如明文协议，将字符串编码后直接send
modbustcp协议，要组装发送报文为（从站地址+功能码+等等+字符串数据）） 常用链接 虚拟串口调试工具 V6.9 汉化版免费版
串口、Modbus通信协议
一、Modbus 课程
文章介绍
一篇博客
1.ModbusRTU消息帧解析 2.主站poll、从站slave通讯仿真-modbusRTU 从站slave用于模拟PLC中的功能区，一个tab页表示一个功能模块（下图建了两个功能块）
主站poll发送请求，获取PLC中数据。
poll、slave都要设置connection、setup两个区域，只有参数配对了才能正常收发数据
1.功能码=01读线圈状态 报文都是16进制表示
16进制 0X01=0000 0001，一位16进制需要4位二进制表达（F =1111），两个16进制数字表示1个字节
线圈中数据要么是0，要么是1
读取长度：00 0A表示读取10个寄存器
响应字节数（单位是字节）：02 表示两个字节，从02往后数两个字节都是数据未位
输出状态：A2 02 这是两字节，解析：先颠倒高低位 02 A2= 0000 0010 1010 0010 再反向读取数据0100 0101 0100 0000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab0f354e5f616104b3e6e26b9920f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6cca42231a7ae2b8d8ced4a60b5318/" rel="bookmark">
			巨坑，org.apache.ibatis.binding.BindingException:Invalid bound statement (not found)绑定异常出现原因和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BindingException 绑定异常，(其实出现这个问题实质就是mapper接口和mapper.xml文件没有映射起来。)
异常提示信息如下:
org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) :cn.tedu.csmall.server.mapper.BrandMapper.insert
出现这个问题，排查思路:
在XML中配置的接口名有误 (mapper.xml中的namespace和实际的mapper文件不一致)
节点的namespace属性值有误
在XML中配置的抽象方法名称有误(mapper接口中的方法名和mapper.xml中的id标签不一致)
或类似节点的id属性值有误
在配置文件中指定的XML路径,此项配置有误
application.properties中配置的mybatis.mapper-locations属性有误
上面问题都没有，但是还是不行，可能原因就是，没有构建进去，打开target看看对应的mapper.xml文件在不在
如果不在，恭喜你，即将学到新知识 SpringBoot项目整合Mybatis时Mapper.xml文件的存放位置
方式一: 放在与Mapper接口同级目录
在pom.xml中 节点添加如下配置，用于加载资源：
&lt;build&gt; &lt;resources&gt; &lt;!-- 扫描src/main/java下所有xx.xml文件 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!-- 扫描resources下所有资源 --&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 方式二：在resources创建Mapper接口同名文件夹用来存放Mapper.xml文件(很繁琐，不推荐)
方式三：在resources目录下创建mapper文件夹存放mapper.xml（推荐）
在 application.properties 中做如下配置：
mybatis.mapper-locations=classpath:/mapper/*.xml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb243c94deaa8af0d03c1b6b8f3283d0/" rel="bookmark">
			3D打印报价系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一款3d打印报价系统不仅可以展示三维模型，还能自动计算模型的相关信息，如面积、体积和尺寸信息。
用户上传三维模型后，系统会自动为其生成一个报价页面。在这个页面上，用户可以看到他们模型的所有相关信息，包括面积、体积和尺寸信息。更重要的是，系统会根据这些信息自动计算出打印该模型的预估价格。
三维模型展示 首先，我们的系统可以展示三维模型。用户可以上传自己的3D模型文件，系统会将其渲染成可视化的三维模型。这样，用户就可以从各个角度查看模型，以便更好地理解其结构。
自动计算模型信息 除了展示三维模型，我们的系统还可以自动计算模型的相关信息。这包括：
面积：系统会计算模型的表面积，这对于估计打印所需的材料量非常有用。体积：系统会计算模型的体积，这有助于估计打印所需的时间。尺寸信息：系统会提供模型的尺寸信息，包括长度、宽度和高度，以便用户可以根据自己的需求进行调整。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab84fb4089b930f467b47f8da8748380/" rel="bookmark">
			React 之 airbnb - 项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开发前言 1. 规范 2. 创建项目 node -v =&gt; 18.0.0 npm -v =&gt; 8.6.0
create-react-app star-airbnb
3. 项目基本配置 配置jsconfig.json { "compilerOptions": { "target": "es5", "module": "esnext", "baseUrl": "./", "moduleResolution": "node", "paths": { "@/*": [ "src/*" ] }, "jsx": "preserve", "lib": [ "esnext", "dom", "dom.iterable", "scripthost" ] } } 通过craco配置 react脚手架隐藏webpack
解决一 : npm run eject 导出webpack配置，要去找到对应的配置，如果修改错误，项目可能跑不起来
解决二 : 通过craco =&gt; create-react-app config
配置后，会与原来的webpack配置混合
npm install @craco/craco@alpha -D =&gt; "react-scripts": "5.0.1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab84fb4089b930f467b47f8da8748380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f2d6ff2555c11ff92d58d3f0a0facd5/" rel="bookmark">
			解决 OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.
意思是要初始化一个libiomp5md.dll文件，但是发现这个文件已被初始化了。
二、解决办法 做法就是在本项目的环境目录下搜索 libiomp5md.dll，可以找到如下图：
搜索到很多的同类型的文件夹，请确保你打开的是将要加载的虚拟环境文件夹中 libiomp5md.dll 文件所在的目录，将其剪切备份到另外(自己能找到的)的文件夹中即可再次运行项目，问题就可以解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9e1720ca6fa901220983e914eb19c1/" rel="bookmark">
			软件工程理论与实践 (吕云翔)第十四章 软件维护与软件工程管理课后习题与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第十四章 软件维护与软件工程管理 1.判断题 （1）代码行技术是比较简单的定量估算软件规模的方法。(√)
（2）功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。（√）
（3）常用的制订进度计划的工具主要有Word和Excel两种。(×)
解析：制订进度计划常用的工具不仅限于Word和Excel，还包括专门的项目管理工具和甘特图软件等
（4）民主制程序员组的一个重要特点是，小组成员完全平等，享有充分民主，通过协商做出技术决策(√)
（5）主程序员组的两个关键特性是专业化和层次性。(√)
（6）现代程序员组中，技术组长既负责技术工作，又负责非技术事务。(×)
解析：现代程序员组中，技术组长通常负责技术工作，而非技术事务通常由项目经理或其他管理人员负责。
（7）风险有两个显著特点，二个是不确定性，另一个是损失。(√)
（8）回避风险是指，风险倘若发生，就接受后果。(×)
解析：回避风险是指采取措施来避免风险的发生，而不是接受风险后果。
（9）软件质量保证的措施主要有，基于非执行的测试（也称为复审）、基于执行的测试和程序正确性证明。(√)
（10）总体上说，软件工程文档可以分为用户文档、开发文档和管理文档3类。（√）
（11）文档是影响软件可维护性的决定因素。(√)
（12）适应性维护是在软件使用过程中，用户会对软件提出新的功能和性能要求，为了满足这些新的要求而对软件进行修改，使之在功能和性能上得到完善和增强的活动。(√)
（13）进行软件维护活动时，直接修改程序，无须修改文档。（×）
进行软件维护活动时，除了修改程序外，也需要相应地修改相关的文档，以保持一致性和可维护性。
（14）软件生命周期的最后一个阶段是书写软件文档。(×)
解析：软件生命周期的最后一个阶段通常是维护阶段，其中包括维护文档、更新文档等活动。
（15）CMM是指导软件开发的一种面向对象的新技术。（×）
解析：CMM 代表“Capability Maturity Model”（能力成熟度模型），它是一个用于评估和指导软件开发过程的框架。CMM 并不是一种面向对象的新技术，而是一种管理和评估软件开发过程成熟度的方法。它有不同的级别，每个级别表示组织的软件过程能力的不同成熟度水平。 CMM 有五个级别，从初始级别（Level 1）到优化级别（Level 5）。每个级别都定义了一组特定的过程目标和实践。
2.选择题 （1）软件工程针对维护工作的主要目标是提高软件的可维护性，降低（B）。
A.维护的效率
B.维护的工作量
C.文档
D.维护的代价
解析：软件工程在维护工作中的主要目标是提高软件的可维护性，降低维护的工作量
（2）（B）的作用是为有效、定量地进行管理，把握软件工程过程的实际情况和它所产生的产品质量。
A.估算
B.度量
C.风险分析
D.进度安排
解析：度量的作用是为了有效、定量地进行管理，以了解软件工程过程的实际情况和产品质量。
（3）LOC和FP是两种不同的估算技术，但两者有许多共同的特征，只是LOC和FP技术对于分解所需要的（A）不同。
B.分解要求
C.使用方法
D.改进过程
A.详细程度
解析：LOC（Lines of Code，代码行数）和FP（Function Points，功能点）是两种不同的估算技术，它们在分解软件所需的详细程度上有所不同。
（4）项目团队原来有6个成员，现在又增加了6个成员，这样沟通渠道增加了多少？（A）
A.4.4倍
B.2倍
C.6倍
D.6条
解析：原来有6个成员时，沟通渠道数为6(6-1)/2 = 15。现在增加了6个成员，总共有12个成员。新的沟通渠道数为12(12-1)/2 = 66。
所以，新的沟通渠道数相对于原来增加了66-15=51条。
51/15 *100%=3.4倍
但是每这个选项。
（5）下列哪项不是风险管理的过程？（D）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b9e1720ca6fa901220983e914eb19c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7031f4b15109a0373933038ae6746503/" rel="bookmark">
			base64 前端显示 data:image/jpg；base64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常base64是后端服务之间传输时常用的一种方式。即把图片流转成了byte数组，再转成一长串字符串（这就是我们看到的base64格式字符串）。
想要还原成图片，后端通常的做法是将base64的字符串转成byte数组，再将byte数组装到流里写出来，就是图片了。
放在前端显示，主需在这字符串前加上data:image/jpg;base64，jpg换成你图片的后缀。
前端有两种显示方式：1.放CSS里，2.放img标签里。
在css里的写法：
#est_switch { background: url(data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAPsxpwBwiKNIuGxlOz0WhhpoWCMcALb/iyiLCTt8l10f//Z) no-repeat center; } 在html代码img标签里的写法
&lt;img src="data:image/gif;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAPsxpwBwiKNIuGxlOz0WhhpoWCMcALb/iyiLCTt8l10f//Z"&gt; 还有就是迅雷的地址：
thunder://QUFodHRwOi8vNDYuZHVvdGUub3JnL2R1b3RlX3FxLmV4ZVpa 将斜杠后面base64字符串解析，得到：AAhttp://51.duote.org/duote_qq.exeZZ
jpg——data:image/jpg;base64
png——data:image/png;base64
gif——data:image/gif;base64
===========================分割线==============================
文章到此已经结束，以下是紫薯布丁
#est_switch {
background: url(data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAPsxpwBwiKNIuGxlOz0WhhpoWCMcALb/iyiLCTt8l10f//Z) no-repeat center;
}
&lt;img src="data:image/gif;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gIoSUNDX1BST0ZJTEUAAQEAAAIYAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAAHRyWFlaAAPsxpwBwiKNIuGxlOz0WhhpoWCMcALb/iyiLCTt8l10f//Z"&gt;
thunder://QUFodHRwOi8vNDYuZHVvdGUub3JnL2R1b3RlX3FxLmV4ZVpa
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8ff7fff9f7415a21856c1ba87d2ad6/" rel="bookmark">
			多机器人三角形编队的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、机器人编队前的准备二、配置仿真环境2.编写机器人编队.cpp文件 三、三角形编队测试 前言 前阵子一直想要实现多机器人编队，找到了很多开源的编队代码，经过好几天的思索，终于实现了在gazebo环境中的TB3三角形机器人编队。
一、机器人编队前的准备 本次实现的多机器人三角形编队是在之前配置完成的单个TB3机器人基础上实现的，如果想要配置单个机器人可以参考这篇文章：双系统ubuntu20.04(neotic版本)从0实现Gazebo仿真slam建图
（1）创建工作空间：mkdir -p ~/catkin_ws/src
（2）把前面做好的单个机器人导航键图的功能包拷贝到src中。
可参考文章：ROS如何将拷贝的功能包成功运行在自己的工作空间中
（3）创建多机器人编队的功能包：
catkin_create_pkg turtlebot3_teams_wang roscpp rospy tf turtlesim （4）新建广播以及接收广播的对应的.cpp文件
cd ~/catkin_ws/src/turtlebot3_teams_wang/src/ touch tb3_tf_broadcaster1.cpp touch tb3_tf_broadcaster2.cpp touch tb3_tf_broadcaster3.cpp touch tb3_tf_listener1.cpp touch tb3_tf_listener2.cpp touch tb3_tf_listener3.cpp （5）创建launch启动文件
cd ~/catkin_ws/src/turtlebot3_teams_wang/launch touch turtlebot3_teams_follow_zhou.launch 二、配置仿真环境 （1）打开驱相应urdf.xacro模型（burger,waffle,waffle_pi都行）
本文选取waffle机器人模型
（2）插入以下代码增加话题订阅(订阅base_pose_ground_truth话题，gazebo可获取机器人相对与world的位置信息)
&lt;gazebo&gt; &lt;plugin name="base_waffle_controller" filename="libgazebo_ros_p3d.so"&gt; &lt;alwaysOn&gt;true&lt;/alwaysOn&gt; &lt;updateRate&gt;50.0&lt;/updateRate&gt; &lt;bodyName&gt;base_footprint&lt;/bodyName&gt; &lt;topicName&gt;base_pose_ground_truth&lt;/topicName&gt; &lt;gaussianNoise&gt;0.01&lt;/gaussianNoise&gt; &lt;frameName&gt;world&lt;/frameName&gt; &lt;xyzOffsets&gt;0 0 0&lt;/xyzOffsets&gt; &lt;rpyOffsets&gt;0 0 0&lt;/rpyOffsets&gt; &lt;/plugin&gt; &lt;/gazebo&gt; （3）编写机器人gazebo仿真环境
打开turtlebot3_simulations-&gt;turtlebot3_gazebo根据自己设计需要设置launch文件，这里为方便演示，我在multi_turtlebot3.launch文件的基础上进行修改，这里我只添加了三个机器人。
代码如下：
&lt;launch&gt; &lt;arg name="model" default="$(env TURTLEBOT3_MODEL)" doc="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8ff7fff9f7415a21856c1ba87d2ad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b005411952006863178e2d1fa09944e/" rel="bookmark">
			DDD全网最通俗易懂讲解（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		领域事件相关案例 我来给你介绍一个保险承保业务过程中有关领域事件的案例。
一个保单的生成，经历了很多子域、业务状态变更和跨微服务业务数据的传递。这个过程会产生很多的领域事件，这些领域事件促成了保险业务数据、对象在不同的微服务和子域之间的流转和角色转换。在下面这张图中，我列出了几个关键流程，用来说明如何用领域事件驱动设计来驱动承保业务流程。
事件起点：客户购买保险-业务人员完成保单录入-生成投保单-启动缴费动作
投保微服务生成缴费通知单，发布第一个事件：缴费通知单已完成，将缴费通知单数据发布到消息中间件。收款微服务订阅缴费通知单事件，完成缴费动作，缴费通知单已生成，领域事件结束收款微服务缴费完成后，发布第二个领域事件：缴费已完成，将缴费数据发布奥消息中间件。原来的订阅方收看微服务这是则变成了发布方。原来的时间 总之，通过领域事件驱动的异步化机制，可以推动业务流程和数据在各个不同微服务之间的流转，实现微服务的解耦，减轻微服务之间服务调用的压力，提升用户体验。
一个完整的领域事件 = 事件发布 + 事件存储 + 事件分发 + 事件处理。
事件发布：构建一个事件，需要唯一标识，然后发布；
事件存储：发布事件前需要存储，因为接收后的事件也会存储，可用于重试或对账等；就是每次执行一次具体的操作时，把行为记录下来，执行持久化。
事件分发：服务内的应用服务或者领域服务直接发布给订阅者，服务外需要借助消息中间件，比如Kafka，RabbitMQ等，支持同步或者异步。
事件处理：先将事件存储，然后再处理。
当然了，实际开发中事件存储和事件处理不是必须的。
因此实现方案：发布订阅模式，分为跨上下文（kafka，RocketMq）和上下文内（spring事件，Guava Event Bus）的领域事件。
用户注册后，发送短信和邮件，使用spring事件实现领域事件代码如下：
/** * 用户注册事件 * @Author WDYin **/ public class UserRegisterEvent extends ApplicationEvent { public UserRegisterEvent(Object source) { super(source); } } /** * 用户监听事件 * @Author WDYin **/ @Component public class UserListener { @EventListener(UserRegisterEvent.class) public void userRegister(UserRegisterEvent event) { User user = (User) event.getSource(); System.out.println("用户注册。。。发送短信。。。" + user); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b005411952006863178e2d1fa09944e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc05af381dd7b510aaed7bea7c4ddb9/" rel="bookmark">
			C#简化工作之实现网页爬虫获取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、需求 想要获取网站上所有的气象信息，网站如下所示：
目前总共有67页，随便点开一个如下所示：
需要获取所有天气数据，如果靠一个个点开再一个个复制粘贴那么也不知道什么时候才能完成，这个时候就可以使用C#来实现网页爬虫获取这些数据。
2、效果 先来看下实现的效果，所有数据都已存入数据库中，如下所示：
总共有4万多条数据。
3、具体实现 构建每一页的URL 第一页的网址如下所示：
最后一页的网址如下所示：
可以发现是有规律的，那么就可以先尝试构建出每个页面的URL
// 发送 GET 请求 string url = "https://cj.msa.gov.cn/xxgk/xxgkml/aqxx/qxyg/"; HttpResponseMessage response = await httpClient.GetAsync(url); // 处理响应 if (response.IsSuccessStatusCode) { string responseBody = await response.Content.ReadAsStringAsync(); doc.LoadHtml(responseBody); //获取需要的数据所在的节点 var node = doc.DocumentNode.SelectSingleNode("//div[@class=\"page\"]/script"); string rawText = node.InnerText.Trim(); // 使用正则表达式来匹配页数数据 Regex regex = new Regex(@"\b(\d+)\b"); Match match = regex.Match(rawText); if (match.Success) { string pageNumber = match.Groups[1].Value; Urls = GetUrls(Convert.ToInt32(pageNumber)); MessageBox.Show($"获取每个页面的URL成功，总页面数为：{Urls.Length}"); } } //构造每一页的URL public string[] GetUrls(int pageNumber) { string[] urls = new string[pageNumber]; for (int i = 0; i &lt; urls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cc05af381dd7b510aaed7bea7c4ddb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bdcd886258a26dc449c41da52f4791/" rel="bookmark">
			Javaweb家庭理财管理系统(SSM&#43;layui&#43;Mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：私信博主 项目介绍
本系统的业务包括用户登录、用户管理、资金账户、收入管理、支出管理、资金分布、资金分析、理财预测。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7等版本均可；
技术栈
1. 后端：Spring springmvc mybatis 2. 前端：JSP+layui+css+html
使用说明
1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2.使用IDEA/Eclipse/MyEclipse导入项目，配置tomcat，
3. 将项目中WebRoot/WEB-INF/applicationContext.xml配置文件中的数据库配置改为自己的配置，然后运行；
4.运行成功后，在浏览器中输入：http://localhost:8080/money
账号密码:admin/admin
资金账户控制层： @Controller @RequestMapping("/account") public class AccountController extends BaseController{ // Servrice start @Inject //自动注入，不需要生成set方法了。 private AccountService accountService; @RequestMapping("list") public String list(Model model, Account account, String pageNow) { return Common.BACKGROUND_PATH+"/account/list"; } @ResponseBody @RequestMapping("queryAccName") public Map&lt;String, Object&gt; queryAccName() { Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); List&lt;Account&gt; aaa= accountService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18bdcd886258a26dc449c41da52f4791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23750b0f947ede026163875427cf7e0b/" rel="bookmark">
			stm32多功能电子琴（12键）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现功能
1.多个按键可以弹奏歌曲
2.显示屏可看音调频率
3.声音长度可调
以下是接线图PA1-PA12接按键（音调升序）
PB8,PB9接显示屏
PA0接蜂鸣器
PB1,PB11插音量调节按钮
主要思路：
通关按键控制不同的重装值来进入中断函数，进行电频翻转实现音调高低的变化
以及控制计数值来实现声音长短，具体可以参考代码~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c8e8ca138bbb0ea08e28f284678b81/" rel="bookmark">
			【数据结构】堆（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来学习堆，它也是二叉树的一种（我滴神树！）
目录 堆的介绍：堆的代码实现：堆的结构体创建：堆的初始化：堆的销毁：堆的push：堆的pop：判空 &amp;&amp; 求Top元素 &amp;&amp; 求size： 完整源码： 堆的介绍： 如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足： &lt;= 且
&lt;= ( &gt;= 且 &gt;= ) i = 0，1，
2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
堆的性质：
堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。 由于他们存储在数组中，又因为完全二叉树的性质，数组中不会空出来，故可以得到以下结论（皆为数组下标）：
parent = （child - 1）÷ 2
child（左孩子结点） = parent × 2 + 1
child（右孩子结点） = parent × 2 + 2
堆的代码实现： 堆的结构体创建： typedef int HpDataType; typedef struct Heap { int size; int capacity; HpDataType* a; }Hp; 堆的初始化： 这里我们选择先不给赋值，等push时再给赋值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c8e8ca138bbb0ea08e28f284678b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed69b1ebfd1c60c731c99be83683c89a/" rel="bookmark">
			观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观察者模式适用于在一个一对多模型中，一者状态变化，多者需要根据变化做出相应调整的情况，下面我们通过一个简单的例子简单说明观察者模式的设计方法
注：本利旨在说明观察者模式的设计思想，例子中存在一定的内存泄露没有处理
假设我们有一台电脑主机，这台电脑主机不干别的事，只是向屏幕发送一个数字。
同时有多台显示器连接到这台主机上，并根据发送来的数字做自己的逻辑处理再显示出来
首先我们做一个只有一个显示器的情况
class Display { public: void update(int num) { m_num = num; show(); } void show() { std::cout &lt;&lt; m_num &lt;&lt; std::endl; } private: int m_num; }; class Computer { public: void setNum(int num) { m_num = num; numChange(); } int getNum() { return m_num; } void numChange() { m_display-&gt;update(m_num); } void setDisplay(Display *display) { m_display = display; } private: int m_num; Display *m_display; }; int main(int argc, char **argv) { Display *display = new Display; Computer *computer = new Computer; computer-&gt;setDisplay(display); computer-&gt;setNum(10); computer-&gt;setNum(100); return 0; } 在上面代码中，我们首先定义了一个显示器和一个主机，并为主机绑定了显示器。当主机的数字变化时，会自动调用显示器的更新方法，将新的数字显示出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed69b1ebfd1c60c731c99be83683c89a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb7421722a217c2ac1d9dfb23aaa648/" rel="bookmark">
			Selenium 连接到现有的 Firefox 示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前环境：
python 3.7
selenium 3.14.1
urllib3 1.26.8
Frefox 115.1.0esr(32位)
geckodriver.exe 0.33.0
1 下载 Firefox 浏览器，根据自己的需要选择。
下载 Firefox 浏览器，这里有简体中文及其他 90 多种语言版本供您选择
2 下载 geckodriver.exe，根据自己的浏览器版本对应选择。
Releases · mozilla/geckodriver · GitHub
3 右键安装好的 Firefox ，目标 加入 "-marionette -start-debugger-server 2828"，确定。
4 测试效果
测试代码：
from selenium import webdriver GECKODRIVER_PATH = r'./geckodriver.exe' driver = webdriver.Firefox(executable_path = GECKODRIVER_PATH, service_args = ['--marionette-port', '2828', '--connect-existing'] ) driver.get('https://www.baidu.com') print(driver.title) 参考：
如何使用selenium(python)连接到现有的firefox示例 https://www.saoniuhuo.com/question/detail-2247009.html
特别是 ifsvaxew 的回答：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb97b06a5919c91b531b3b47c1cdbb66/" rel="bookmark">
			基于javaFX的简易定制化的自动部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:
公司的七八个项目迭代的非常快,而且服务器上安装的是windows server系统,每次发布需要远程桌面登陆服务,把jar包拷贝到服务器上,再执行重启,操作复杂,多项目并行时需要抢资源,查看测试环境报错日志也不方便,基于这个背景,手写了一个自动化部署软件
原项目发布流程:
本地环境Idea打包编译,远程登陆windows server服务器,复制打包好的jar包到服务器上,然后通过任务管理器重启服务
使用软件之后的发布流程
打开软件,配置本地项目地址,点击发布
发布过程基于java代码实现,源码放在下面,有需要自取
https://download.csdn.net/download/qq_40426135/87874076
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3386b5f626b31e41bd5ec43a7ef6b50/" rel="bookmark">
			Bootstrap v5版本的HTML模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个基本的Bootstrap v5版本的HTML模板。这是一个非常基础的模板，包含了Bootstrap CSS和JS的引用，以及一个基本的HTML结构。
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Bootstrap v5 模板&lt;/title&gt; &lt;!-- 引入 Bootstrap CSS --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-6l9sXXGgb5JGb5hlT/hWJLLPLW9eStAefghSJwS+CJpc33ujIW1HnIhR7aZ+6U95Ex" crossorigin="anonymous"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h1&gt;欢迎来到我的网页&lt;/h1&gt; &lt;p&gt;这是一个基于Bootstrap v5的模板。&lt;/p&gt; &lt;/div&gt; &lt;!-- 引入 Bootstrap JS --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这个模板中，我已经包含了Bootstrap v5的CSS和JS的CDN链接。在&lt;div class="container"&gt;标签中，您可以添加您自己的HTML内容。
登录：
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;登录页面&lt;/title&gt; &lt;!-- 引入 Bootstrap CSS --&gt; &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3386b5f626b31e41bd5ec43a7ef6b50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85d81979af056e24c9dd5995d3ee331/" rel="bookmark">
			Python代码调试——Pycharm的实用调试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：快速使用，由以下博客提供：https://blog.csdn.net/qq_45753718/article/details/122079032
1.首先在怀疑出错的代码处的前面设置断点
2.点击pycharm debug按钮
3.step over 也就是 F8 进行单击调试，只有光标在哪一行就是即将运行的代码 只有光标跳到下一行，这一行才会执行
4.运行到某一个自定义函数 def的时候如果想知道里面如何运行 单击 step into（F7） 然后继续step over
最后可能返回一个result 回到main函数继续step over。
5.如果是嵌套函数，函数里面还有别的自定义函数 可以运行到那一行时继续step into
6.如果想从嵌套函数出来 运行step out 相当于直接运行完了当前的整个内置的函数
7.step into就是无论函数是否是当前程序还是import进来的包 都要跳转过去（F7）。
step into my code 就是只跳进去我的代码，而忽略第三方库代码 。（Alt+shift+F7）
8.run to cursor 就是把光标放在哪里 就直接运行到哪里。
快捷键口诀：7进，8出，9跳。
9，F9是直接跳到下一个断点处。
一些调试的相关入门知识：ref《编写高质量代码改善python程序的91个建议》20231127
一、
调试与定位——本质是复杂的搜索问题，必须通过大量分析才能接近真相；
很多时候调试要到底层，研究内部的数据或代码；
必须有丰富的知识，熟悉问题域各模块工作及写作方式。
除了使用调试器，一定要借助日志来帮助定位问题。logging是个方便的日志功能，可以将日记记录添加到代码中。通过查看日志输出，可以了解代码执行，并快速定位问题。
如果涉及到大量代码频繁操作，一定要使用快捷键，效率蹭蹭。
二、断点与调试
断点可以使能、不使能，或者条件使能。
三、查看变量的三种方式
3.1插入断点，Debug运行。在面板下就可看到变量，同时针对特定变量，右击add to watchers可以专门监控。
3.2 Eidt Configuration中勾选Run with Python console，Run后，点击控制台的“眼镜”图标，即可展开变量。
3.3 print打印方式。
四、CProfile库可记录执行时执行时间、函数调用次数等方式。导入import cProfile后，在代码中加入cProfile.run(“被测函数")即可获得代码运行信息。可以探测出该代码的性能瓶颈。
pyinstrument，py-spy:也是对Python代码性能分析。其中py-spy最快，cProfile最慢。
五、常见的Python典型问题与定位手法：
高耗时问题/函数调用栈过深/IO瓶颈/内存泄露/死锁类/正则回溯失控
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8d00c7567f946c687f2dadb5994de1/" rel="bookmark">
			OpenGl的详细安装流程以及OpenGL.error.NullFunctionError:报错解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本蒟蒻在第一次使用opengl遇到了一些问题，分享完整解决方法希望能帮到大家
第一次使用的报错：
下面是解决方法:
查看自己的python版本 安装OpenGl需要根据自己的python版本进行选择，我们先使用命令查看自己的python版本
python --version 以我自己的为例，我的版本是3.10.0版本
下载合适的PyOpenGL和PyOpenGL_accelerate文件 点击这里选择合适的版本，因为我的版本是3.10.0，选择这两个cp310的64位的版本
在命令行窗口进行安装 浏览器帮我把两个文件下载到了这里，先使用cd命令切换到包含whl文件的目录下，然后再运行命令进行安装。
cd C:\Users\玛玛哈哈\Downloads 切换完之后，使用下面这两个命令进行安装即可，whl名称以自己下载的为准的
pip install --user PyOpenGL_accelerate-3.1.6-cp310-cp310-win_amd64.whl pip install PyOpenGL-3.1.6-cp310-cp310-win_amd64.whl 可以看到，两个文件都下载成功了
运行测试 可以使用，本篇完结
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/37/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>