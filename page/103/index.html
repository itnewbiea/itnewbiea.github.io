<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c482d76ffcb48685f74817b106362a52/" rel="bookmark">
			python实现植物大战僵尸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现植物大战僵尸 @TOC
前言 植物大战僵尸是一款十分经典的游戏，在github上就有python版的开源代码（https://github.com/search?q=PythonPlantsVsZombies）打开后可以看见有六个版本，在这里我选的是第一个版本。
游戏介绍 游戏截图 介绍 现在含有的植物 太阳花，豌豆射手，寒冰射手，坚果，樱桃炸弹。新增加植物：双重豌豆射手，三重豌豆射手，食人花 ，小喷菇，土豆地雷，倭瓜。
现在含有的僵尸 普通僵尸，旗子僵尸，路障僵尸，铁桶僵尸。读报僵尸。
现在含有的关卡 在源文件中有六个关卡，四种模式：==白日模式、夜晚模式、传送带模式、坚果保龄球模式==
由于关卡设置是以.json文件保存，所以我们可以自己更改。
代码分析 1.main.py 这个游戏的源文件中包含了多个py文件，main.py中只有这5行代码：
import pygame as pg from source.main import main if __name__=='__main__': main() pg.quit() 2.menubar.py 这个文件是用来设置植物卡片的，先来看源码：
第一部分：卡片设置 card_name_list = [c.CARD_SUNFLOWER, c.CARD_PEASHOOTER, c.CARD_SNOWPEASHOOTER, c.CARD_WALLNUT, c.CARD_CHERRYBOMB, c.CARD_THREEPEASHOOTER, c.CARD_REPEATERPEA, c.CARD_CHOMPER, c.CARD_PUFFMUSHROOM, c.CARD_POTATOMINE, c.CARD_SQUASH] plant_name_list = [c.SUNFLOWER, c.PEASHOOTER, c.SNOWPEASHOOTER, c.WALLNUT, c.CHERRYBOMB, c.THREEPEASHOOTER, c.REPEATERPEA, c.CHOMPER, c.PUFFMUSHROOM, c.POTATOMINE, c.SQUASH] plant_sun_list = [50, 100, 175, 50, 150, 325, 200, 150, 0, 25, 50] plant_frozen_time_list = [0, 5000, 5000, 10000, 5000, 5000, 5000, 5000, 8000, 8000, 8000] all_card_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 这里以向日葵卡片为例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c482d76ffcb48685f74817b106362a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab2a0457bfc2ee2d958e8c9cbac76f5/" rel="bookmark">
			java中的线程停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 在线程停止上，java一开始我们准备了很多停止线程的方法，其中最常用的方法就是在Thread类里面的stop()方法，但是在jdk8出现后，这种方法就被淘汰了，紧接着我们停止线程需要自己写一个停止线程的方法。
方法如下 首先我们需要重新写一个类class TestStop类，继承runnable接口，重写run方法。
在run方法里面写上while循环，while(flag)中的flag来判断是否循环停止，flag的初始值为true。
书写线程停止方法stop(),方法里面就写this.flag=flase。
主函数里面new一下TestStop类，将这个类抛入到Thread thread = new Thread(teststop)里面，然后开启线程thread.start()。
让线程执行多少次之后停止，运用for循环+if语句来做到。
主要代码 package ThreadStudy.TestThread; public class TestStop implements Runnable{ public boolean flag=true; @Override public void run() { int i=0; while (flag){ System.out.println("我在学习stop"+i++); } } public void stop(){//线程停止函数 this.flag=false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 1000; i++) { System.out.println("main"+i); if (i==900){//执行900次线程停止 testStop.stop(); System.out.println("线程停止"); } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad49de9a0d2a1eb7eb4675b113f88ee/" rel="bookmark">
			postman实现接口测试详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位小伙伴大家好, 今天为大家带来postman实战接口测试详细教程
一、通过接口文档集合抓包分析接口 通过fiddler抓包获取到注册接口URL地址及相关参数数据,并通过接口文档分析接口参数内容及参数说明, 如有必要的依赖条件必须进行梳理, 如token等
Fiddler抓包注册接口请求与响应:
接口文档关于注册接口的描述与参数说明:
二、通过postman发起请求并获取响应结果 通过第一步获取到的相关数据,按照请求的沟通, 分别填写对应的请求行,请求头,请求体相关数据, 发起请求
注意: 通过接口文档与抓包, 我们观察到接口的请求参数传参方式 Content-Type: application/x-www-form-url-encoded, 因此我们在选择数据时,必须在Body中选择该类型进行参数传递。
Content-Type: 传参方式类型
1.form-data: 接口类型为文件上传类型时, 可以选择Body中的 form-data, 此时请求头中Content-Type: multipart/form-data
2.x-www-form-url-encoded: post请求默认传参方式, 传输数据类型为 key1=value&amp;key2=value…, 此时请求头中Content-Type: application/x-www-form-url-encoded
3.text/json格式数据传参: 选择Body中的Raw, 再选择json/text即可
Json格式必须以: {key: value, key:value…}格式进行传参
4.get请求参数写在URL的?之后, postman中也可以通过Params模块进行传参
三、设置环境变量引用
postman中环境变量: Environments --&gt; 设置新的环境 --&gt; 添加项目的基础接口URL地址
环境变量的引用方式: {{变量名}}
在请求中通过{{host}}引用环境变量中的数据即可
也可以通过Tests模块, 使用Javascript脚本进行环境变量的设置与获取。
四、postman中的Tests模块: 1、获取响应数据
通过Javascript脚本获取响应文本数据,并在conlose控制台进行输出
//获取postman响应文本数据 varresp = pm.response.text(); //控制台输出 获取到的响应数据 console.log(resp); // 从响应数据中提取需要的key的值 var userid = resp.json().userid; // 通过代码添加到环境变量中 key: id, value: userid pm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad49de9a0d2a1eb7eb4675b113f88ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53b52b4e0fba07abb52664f06ce9940/" rel="bookmark">
			CTA-敏感行为-定位（重点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 需求
2 权限
3 接口
4 示例
5 adb命令
6.1 验证
adb shell dumpsys appops --op 0/1/2
6.2 验证
adb shell dumpsys location
6.3 验证
adb logcat -b main | findstr "LocationManagerService:.onRegistrationAdded"
7 参考资料
Android源码
国内： AndroidXRef（1.6-9.0）AOSPXRef（7.1-12.0）海外： https://android.googlesource.com/platform/frameworks/base/ Android文档
国内 文档：Documentation | Android 开发者 | Android Developers指南：开发者指南 | Android 开发者 | Android Developers参考文档：Android API reference | Android Developers海外 文档：https://developer.android.com/docs指南：https://developer.android.com/guide参考文档：https://developer.android.com/reference Android权限
Manifest.permission | Android Developershttp://androidxref.com/8.0.0_r4/xref/frameworks/base/core/res/AndroidManifest.xml 参考资料：
构建位置感知应用 | Android 开发者 | Android Developers
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b53b52b4e0fba07abb52664f06ce9940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6657090957bae954a484798d4dd047ee/" rel="bookmark">
			java中的lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lambda表达式的具体形式如下:接口名称=(int a)-&gt;{想要表达的式子；}
介绍lambda表达式之前首先回顾一下内部类(静态内部类、局部内部类、匿名内部类)
正常调用 package ThreadStudy.TestThread; public class Testlambdademo01 { public static void main(String[] args) { test test = new test(); test.run(); } } interface slove{ void run(); } class test implements slove{ @Override public void run() { System.out.println("我会跑了"); } } 静态内部类、局部内部类、匿名内部类 package ThreadStudy.TestThread; public class Testlambdademo01 { // //静态内部类 // static class test implements slove{ // @Override // public void run() { // System.out.println("我会跑了"); // } // } public static void main(String[] args) { //局部内部类 // class test implements slove{ // @Override // public void run() { // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6657090957bae954a484798d4dd047ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b72fc87106114329ffca430b4176a15/" rel="bookmark">
			uni-app地址选择组件，三级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.组件目录结构
2.k-region.vue代码
&lt;template&gt; &lt;view&gt; &lt;view class="list" :style="{width:width+'rpx',height:height+'rpx'}"&gt; &lt;view class="name"&gt;收货地址&lt;/view&gt; &lt;picker class="picker" mode="multiSelector" :range="region" range-key="name" :value="regionIndex" @change="pickerChange" @columnchange="pickerColumnchange"&gt; &lt;view class="pbox" :class="{'pbox_hover':regionStr != '请选择省市区'}"&gt; &lt;view&gt;{{regionStr}}&lt;/view&gt; &lt;text class="iconfont icon-you"&gt;&lt;/text&gt; &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import region from './pca-code.json'; export default { data() { return { // 原数组 oldRegion: region, // 处理后的数组 region: [ [], [], [] ], // 选择省市区的下标Index 传则默认选中传递的 regionIndex: [0, 0, 0], // 选择的id // previnceId: 11, // cityId: 1101, // countyId: 110101, // 省市区字符串 regionStr: '请选择省/市/区' }; }, props: { // 组件高度 height: { type: [Number], default: 92 }, // 组件宽度 width: { type: [Number], default: 710 }, // 省id previnceId: { type: [Number], default: 11 }, // 城市id cityId: { type: [Number], default: 1101 }, // 县区id countyId: { type: [Number], default: 110101 }, // 是否是为修改(true为修改) isRevise: { type: [Boolean], default: false } }, methods: { pickerChange(e) { // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b72fc87106114329ffca430b4176a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51514d98ffe4bf4ab02d76a558f71a35/" rel="bookmark">
			VUE动态控制表单是否被编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候,有那么一个需求,就是查看表单的时候不允许编辑,有的时候允许编辑,所以就有了如下经验
&lt;el-form ref="form" :model="form" :rules="rules" label-width="20%" :disabled='this.title==="查看"'&gt;&lt;/el-form&gt; 一个比较取巧的行为就是使用了:disabled='this.title==="查看"' 只要满足条件表单就不允许编辑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfd377c97aa405e0b30eb68964fd39e/" rel="bookmark">
			opencv 去除孤立点以及findContours()和connectedComponentsWithStats()详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		findContours()和connectedComponentsWithStats()两个函数可以分别实现去除图像孤立点的功能 connectedComponentsWithStats()函数原理是检测像素的连通区域（连通图应该不用介绍-.-），上图中每个白色斑点区域都属于一个个连通区域，当然文字部分也是，通过这个函数检测到每个连通区域后，再对不同区域的面积进行筛选（孤立点的面积肯定远远小于文字的面积），就可以去掉这些孤立点，函数用法如下：
num_labels, labels, stats, centroids = cv.connectedComponentsWithStats(src, connectivity=8, ltype=None) 函数参数：
src：传入需要处理的图片，要求为二值图像，上面用例的图像已经是二值图像了，如果不是的话需要加一步二值化
connectivity：可选值为4或8，也就是使用4连通还是8连通，就是这个区别，简单易懂
ltype：这个参数跟输出有关，可以先默认，不用管
返回值：
num_labels：所有连通域的数目
labels：这个返回值很关键，主要就用到这个，ltype参数默认为none的情况下，输出的labels是一个和原图一样大小的矩阵，原图中检测到的连通图的位置，对应的labels矩阵值为1，其余值为0，算是一种特殊的标记
stats：记录了每个连通区域的信息，是一个5列的矩阵，每一行对应一个连通区域，分别为连通区域外接矩形的x、y、width、height和面积，例如stats[0][4]就是第一个连通区域的面积
centroids：连通域的中心点，没什么大用
这样就可以通过stats对连通域进行筛选，再通过labels确定筛选出的区域坐标，在进行各种想进行操作，比如这个去除孤立点，直接让该区域像素值置为背景颜色0，就去掉了
再说findContours()函数
contours, hierarch = cv.findContours(img, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE) 这个相对简单一点，是检测输入图像的轮廓，最后同样通过面积进行筛选
函数参数：
img: 输入图像，最好也是二值图像；
第二个: 表示轮廓的检索模式，有四种(有兴趣的朋友可以自己搜一下区别，这里不多做赘述了-.-）
第三个：轮廓的近似办法，有三种（同上）
返回值：
coutours：一个list，list中每个元素都是图像中的一个轮廓信息，用numpy中的ndarray表示，配合cv.contourArea() 函数可以直接得到轮廓面积,配合cv.drawContours()函数可以对某个区域进行操作，比如上述的直接让该区域像素值置为背景颜色0（这俩函数也不多做赘述了，一搜一大堆）
hierarchy:轮廓间的层次关系,为三维数组，形状为(1,n,4),用不上的参数统统简略
两个方法，个人更推荐第一个，连通区域的检测比轮廓检测要精准很多，就是慢点，毕竟有for循环
这是代码，Img1()和Img2()分别对应两个方法：
import cv2.cv2 as cv import numpy as np def Img1(src): num_labels, labels, stats, centroids = cv.connectedComponentsWithStats(src, connectivity=8, ltype=None) img = np.zeros((src.shape[0], src.shape[1]), np.uint8) #创建个全0的黑背景 for i in range(1, num_labels): mask = labels == i #这一步是通过labels确定区域位置，让labels信息赋给mask数组，再用mask数组做img数组的索引 if stats[i][4] &gt; 300: #300是面积 可以随便调 img[mask] = 255 #面积大于300的区域涂白留下，小于300的涂0抹去 else: img[mask] = 0 return img def Img2(img): contours, hierarch = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcfd377c97aa405e0b30eb68964fd39e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a636330d68a1161cf7c1428588d2615/" rel="bookmark">
			破译Android性能优化中的16ms问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		破译Android性能优化中的16ms问题 前言 Android应用有一个明显的趋势—越来越多地使用动画效果来提升用户体验。但任何事情都是有代价的，丰富复杂的动画提升用户体验的同时，性能问题像隐形的恶魔一样，逐渐地侵蚀着你的应用。动画不流畅、界面卡顿开始困扰着你，逼着你进行性能优化。在这个优化过程中，最理想的标准就是绘制一帧的时间不要超过16ms。这是什么意思？让我们一探究竟。
屏幕刷新频率 我们知道，手机屏幕是由许多的像素点组成的，如下图所示：
通过让每一个像素点显示不同的颜色，可以组合成各种各样的图像。这些像素点的颜色数据从哪里来？
答案是：在GPU控制的一块缓冲区中，这块缓冲区叫做 Frame Buffer（也就是帧缓冲区）。你可以把它简单理解成一个二维数组，数组中的每一个元素对应着手机屏幕上的一个像素点，元素的值代表着屏幕上对应的像素点要显示的颜色。
Frame Buffer 中的数据是不断变化的，为了应对这种变化，手机屏幕的逻辑电路会定期用Frame Buffer 中的数据刷新屏幕上的像素点。目前，主流的刷新频率是60次/秒，折算出来就是16ms刷新一次。
Frame Buffer中的数据怎么来 GPU除了 Frame Buffer，用以交给手机屏幕进行绘制外，还有一个缓冲区，叫 Back Buffer，这个 Back Buffer 用以交给你的应用，让你往里面填充数据。GPU会定期交换 Back Buffer 和 Frame Buffer，也就是让 Back Buffer 变成 Frame Buffer 交给屏幕进行绘制，让原先的 Frame Buffer 变成 Back Buffer 交给你的应用进行绘制。交换的频率也是 60次/秒，这就与屏幕硬件电路的刷新频率保持了同步。如下图所示：
丢帧是怎么发生的 上面说GPU会定期交换 Back Buffer 和 Frame Buffer，但有一个例外情况，当你的应用正在往 Back Buffer 中填充数据时，系统会将 Back Buffer 锁定。如果到了GPU交换两个 Buffer 的时间点，你的应用还在往 Back Buffer 中填充数据，GPU会发现 Back Buffer 被锁定了，它会放弃这次交换，后果就是手机屏幕仍然显示原先的图像。
最不幸的情况是，GPU刚刚放弃这次交换，你的应用就完成了对Back Buffer的数据填充。可怜的你必须等待下一个16ms时间，才能看到这次数据填充的效果。
在这种情况下，从 Back Buffer 锁定开始，也就是你的应用开始往 Back Buffer 中填充数据，到填充后的数据展示到屏幕上，需要的时间是32ms。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a636330d68a1161cf7c1428588d2615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd552b85d3384cfd46f5fd2889dac8f3/" rel="bookmark">
			Windows软件界面字体和图标太小的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们装好软件之后，打开软件会发现部分字体变得非常小，难以看清屏幕中的文字，如图所示：
下面小编在这里以Windows 11系统（其余版本Windows系统的设置步骤没有改变，只是部分选项的位置有所改变，各位读者自行寻找一下即可完成操作。）为例跟大家分享一下解决这个问题的方法：
首先要把系统的缩放比例和显示器分辨率调整合适，一般设置为推荐比例即可，具体方法如下：
1.在桌面空白处右击鼠标，在弹出的对话框中点击“显示设置”。
2.在下方找到“缩放”和“显示器分辨率”，分别点击“缩放”和“显示器分辨率”的下拉框，并选择系统推荐的缩放比例和显示器分辨率即可。
系统的缩放比例和显示器分辨率设置完成后，再进行以下步骤：
1.右击文字显示不正常的软件启动图标，点击“属性”。
2.然后点击“兼容性”，在“设置”栏里找到并点击“更改高DPI设置”。
3. 在弹出的对话框中，找到“替代高DPI缩放行为”一栏，勾选“替代高DPI缩放行为”，在“缩放执行”下拉框中选择“系统”，然后点击“确定”。
4.点击“应用”，再点击“确定”。
5.完成设置后再打开软件就会发现所有文字已经恢复成正常大小了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224fa8beeae112e086422488909b5d5a/" rel="bookmark">
			go mod导入本地自定义包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.要使用gomod首先要开启gomod，而不使用旧方法导入包 go env -w GO111MODULE=on 2.创建项目 mkdir myproject go mod init myproject 假设项目目录为： 其中main包和utils包同级
3.在main包中就可以使用utils包了 package main import ( "fmt" //导入自定义包时直接加上项目名，因为项目在init时已经添加到go环境中了 "myproject/utils" ) func main(){ fmt.Println("hello world") //调用utils中的Test函数 utils.Test() } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a211bd94482edc11e904254481aa41cf/" rel="bookmark">
			vue实现多栏布局拖拽（drag-box）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义dragLayouter文件下---组件DragBox 和DragItem
DragBox：
&lt;template&gt; &lt;div ref='dragBox' style='display: flex; width: 100%; height: 100%;'&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; mounted () { this.setDragItemFlex() this.dragControllerDiv() }, // 如果dragItem 没有定义宽度，则flex=1 setDragItemFlex () { const dragBox = this.$refs.dragBox const childsLen = dragBox.children.length for (let i = 0; i &lt; childsLen; i++) { const node = dragBox.children[i] if (!node.style.width) { // 如果没有定义宽度，则flex=1 node.style.flex = 1 } } }, dragControllerDiv () { const resize = document.getElementsByClassName('resize') // 拖拽条 // 循环为每个拖拽条添加事件 for (let i = 0; i &lt; resize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a211bd94482edc11e904254481aa41cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d9a22b4a4232cc771bdd58b78a46ca5/" rel="bookmark">
			js 中filter 什么时候加return
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结论：写了{}里面的要return，没写{}不加return
大概是写在{}里面的就算是函数了么？
应该是我ES6箭头函数没学好
let arr = [ { id: 1, name: 'aa', desc: 'aaaa' }, { id: 2, name: 'bb' }, { id: 3, name: 'aa' } ] let arr1 = arr.filter(item =&gt; item.name == 'aa')//正确 // let arr2 = arr.filter(item =&gt; return item.name == 'aa' ) //报错 let arr3 = arr.filter(item =&gt; {item.name == 'aa'})//为空 let arr4 = arr.filter(item =&gt; { return item.name == 'aa' })//正确 console.log(arr1, 'arr1') // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d9a22b4a4232cc771bdd58b78a46ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5763fc1125f712bededba18042041355/" rel="bookmark">
			解决跨域Access to XMLHttpRequest at ‘http://localhost:8080/xxx’ from origin ‘http://localhost:63342
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 搞了好久springboot+vuex 显示不了数据 看这里解决跨域问题： Access to XMLHttpRequest at http://xxx.xxx from origin ‘http://localhost:8000’ has been bl
欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5763fc1125f712bededba18042041355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97aefad5521bbe58c61634f09e442842/" rel="bookmark">
			vlookup(精确查找、区间查找、反向查找、多条件查找）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、基本语法 VLOOKUP(查找的值，查找范围，返回列数，查找方式)
查找的值
内容需完全一样：
查找范围
待查找的必须是数据范围的第一列（比如，要查找货品的数量，我们查的是货品，那么货品必须是查找范围的第一列）数据范围需要绝对引用（按F4实现）—— 使用绝对引用，当横向或者列向拓展时，可确保查找的数据范围不变 返回列数
要查找出来的具体内容在数据范围的第几列
查找方式
精确匹配或近似匹配
总结 (1)vlookup函数的四个参数：
（用谁找，在哪找，在哪列，精确0/模糊1）
其中：“用谁找”的谁必须是查找范围的首列
(2)输入vlookup，按住回车，然后再输入 ctrl+A键,可以调出参数框，使用参数框，在输入参数内容的时候，可以不用输入逗号，也可以帮助我们调节格式或者给出一些提示
二、精确匹配（精确查找） 已知有如下表：
现查找每种“货品”的“数量”：
以查找“数据线”的“数量”为例，vlookup函数的具体操作如下：
首先，得根据“数据线”这个内容去找寻对应的数量，因此查找值就是“数据线”其次，“货品”得是查找范围的第一列，因此从“货品”开始选择数据范围（绝对引用）接着，查找的“数量”在查找范围的第三列，因此输入3最后，选择精确匹配 出现“＋”然后往下拖拉，即可得到所有货品的数量。
三、模糊匹配（区间查找） 已知：给出了销售额的区间分布及对应的提成比例
现要得到具体销售额对应的提成比例：
step1: 统计出每个区间的最小销售额，并按从小到大的顺序排列
step2：使用vlookup函数进行区间查找（和前面类似，只不过把第四个参数改为“近似匹配”
注意: 模糊匹配的话，被查找区域数值一定要升序排列
四、反向查找 已有数据：
现要查找产品的“地址”：
由于使用vlookup函数时，查找的”产品“得位于数据范围的第一列，但是此时”产品“在”地址“的右边（即不是第一列），故得先构造辅助列:
使用vlookup函数：
五、多条件查找 已知数据：
由于相同的水果有多个产地，所以不能直接使用vlookup函数，得先构造辅助列，
将”水果“和”产地“两项连接起来作为辅助列
使用vlookup函数：
函数的第一个元素是"水果"和"场地"的合并，因为他在数据范围内是第一列选择左边的整个表作为数据范围要查绚的”市场价“在数据区域的第5列选择”精确匹配“ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066a6e22c7560218434bd748bef013c2/" rel="bookmark">
			用Docker搭建更酷的本地开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前要在本地跑一些有意思的工程和实验，都需要通过在本地装上一大堆软件来实现。最近发现有一种更酷的方式：Docker。
用Docker在本地搭建开发环境有一系列显而易见的优势：
不用依赖公司的资源，开发机资源够够的，环境完整可控，想怎么玩怎么玩，不用担心留痕也完全不会影响别人
能够使用标准化的镜像屏蔽掉一切安装过程的坑，不用担心安装过程中出现的各种乱七八糟的报错
虚拟环境想用即用，不想用了随时丢掉，不用操心清理起来很麻烦
镜像的安装方式大大降低了安装门槛，而且在虚拟环境跑服务完全没有任何心理门槛，终于可以在本地把想安装的中间件或者服务跑全了
酷，重点是酷
Docker 搭建的环境为什么能做到以上优势 道理其实很简单，使用Docker Desktop在本地起一个虚拟机，然后在虚拟机里跑Docker。这样所有的安装和启停变更都发生在虚拟环境里，自然而然的就带来了以上优势。
安装基础环境 下载Docker Desktop，安装过程踩了两个雷：
WSL2 Linux 内核更新包 Docker Desktop requires a newer WSL kernel version 这个报错是字面意思，需要更新内核版本。下载WSL2 Linux 内核更新包即可： 地址
Docker容器运行需要依赖虚拟化 Hardware assisted virtualization and data execution protection must be enabled in the BIOS 这个报错是因为BIOS里没有把对虚拟化的支持打开，重启进入BIOS，打开虚拟化相关配置即可。
运行你的第一个容器 安装完毕之后就可以用了。Docker Desktop的首页非常简洁明了。
Guides里有三个示例，大大的Run，点下去就可以快捷的体验本地服务了。这里我们启动Nginx试试。
切换到Terminal Tab可以对容器发出指令
这种起服务的方式，我觉得比以前挨个安装软件的方式确实爽太多了。
至此Docker所需的环境已经搭建成功了，但是距离我们搭建一个很酷的本地开发环境还差得远。因为还有一连串的问题等着我们。
比如我们再深入玩一下刚才启动的Nginx容器，就会发现有很多指令找不到，这对于我们在本地调试是不可接受的。
再比如需要部署到Nginx的制品如何与本地文件映射，本地启动多个依赖服务时网络与端口如何管理。以及针对不同的本地开发所需要依赖的资源和服务，可能需要通过自行build docker file的方式才能让他们在本地用起来更加丝滑和酷炫。这些问题，我们留到后文再续。
你在本地做开发的时候，是怎么搭建和管理自己的环境呢？欢迎留言讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a274bdb7da40553de2250759d9ef1af8/" rel="bookmark">
			window 如何查看cer 文件中的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要查看 .cer 文件中的信息，您可以使用 Windows 自带的证书管理器。步骤如下：
右键单击 .cer 文件，选择“属性”。在“详细信息”选项卡中，单击“证书”按钮。在弹出的证书对话框中，您可以查看证书的详细信息，包括颁发者、有效期和证书用途等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a286ee594e549cf9b7d099d06d5252a/" rel="bookmark">
			使用RDM将redis的数据导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDM(Redis Desktop Manager)是一款开源的图形化Redis客户端工具，可以帮助您管理和查看Redis数据库中的数据。如果您想使用RDM将Redis数据导出，请按照以下步骤操作：
启动RDM并连接到Redis数据库。
选择您要导出的数据库，然后在右侧的视图中选择数据。
在菜单栏上选择“文件”，然后选择“导出”。
选择您希望导出的格式(例如JSON)，然后指定保存文件的位置。
点击“保存”按钮即可完成数据导出。
这就是使用RDM导出Redis数据的简单步骤。希望对您有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854af2e5820528a30777ae5298768a96/" rel="bookmark">
			javascript 实现分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 实现分页可以使用以下步骤：
计算出需要分页的数据总量和每页显示的数据数量。
根据总数据量和每页数据量计算出需要的总页数。
根据当前页码计算出该页的数据在总数据中的起始位置和结束位置。
根据起始位置和结束位置截取出当前页的数据。
在界面上显示当前页的数据，并提供页码控制功能，使用户可以在不同的页码间切换。
以下是一个简单的 JavaScript 代码示例：
``` // 假设我们有一个长度为 100 的数组，每页显示 10 条数据 var data = [...Array(100).keys()]; var pageSize = 10;
// 计算总页数 var totalPages = Math.ceil(data.length / pageSize);
// 当前页码，默认为第一页 var currentPage = 1;
// 根据当前页码计算出该页的数据在总数据中的起始位置和结束位置 var startIndex = (currentPage - 1) * pageSize; var endIndex = Math.min(startIndex + pageSize, data.length);
// 截取当前页的数据 var currentPageData = data.slice(startIndex, endIndex);
// 在页面上显示当前页的数据 console.log(currentPageData);
// 为页码控制添加事件处理函数，使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/354b9e1b527ced8c08bffd65d73b417c/" rel="bookmark">
			ZYNQ-嵌入式学习（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPIO之MIO中断 GPIO的MIO中断功能实验：使用GPIO的MIO中断功能，实现按键控制LED的亮灭。 GPIO的MIO中断功能 从MIO输入到GPIO的线路有一个通向中断检测模块的分支。
INT_TYPE寄存器表示中断类型。包括边沿和电平两种类型。
INT_POLARITY寄存器表示极性。包括正负极性。电平类型中断包括低电平触发（-）和高电平触发（+）。边沿类型中断包括上升沿极性（+）和下降沿极性（-）。
INT_ANY寄存器针对边沿触发类型的中断。若为1，则两种边沿变换都可触发中断。
INT State寄存器用来保存中断状态。清零端口连接INT_STAT。INT_STAT写1清除中断。
读INT_STAT可获知引脚当前中断状态，即是否有中断产生。
INT_MASK寄存器表示MIO的哪个引脚的中断被屏蔽。读取此寄存器可知哪些引脚的中断被屏蔽。
INT_DIS表示关闭使能，即屏蔽。（disable）
INT_EN表示中断使能。
若某个引脚检测到中断，且同时这个引脚的中断未被屏蔽，则与门输出高电平，即输出一个中断到GIC，即向GIC发送一个IRQ中断请求。GIC即为PS中的中断控制器。#52表示中断ID。
GIC可接收PS和PL的IRQ，通过中断ID获知是谁发起的请求。每个外设的ID都不同，对于GPIO，其中断号为52。
实验：使用GPIO的MIO中断功能，实现按键控制LED的亮灭。 #include "stdio.h" #include "xparameters.h" #include "xparameters_ps.h" #include "xgpiops.h" #include "xscugic.h" #include "sleep.h" #define GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID #define INTC_DEVICE_ID	XPAR_SCUGIC_SINGLE_DEVICE_ID // GPIO中断号（52） #define GPIO_INTERRUPT_ID	XPAR_XGPIOPS_0_INTR // 核心板上PS端LED连接到MIO0 #define MIO0_LED 0 #define MIO12_KEY	12 #define GPIO_BANK	XGPIOPS_BANK0 /* Bank 0 of the GPIO Device */ XGpioPs_Config * ConfigPtr; XGpioPs Gpio; // 中断控制器的驱动实例 XScuGic Intc; // 中断控制器的配置实例 XScuGic_Config *IntcConfig; XScuGic *GicInstancePtr; XScuGic_Config *IntcConfig; /* Instance of the interrupt controller */ u32 key_press = 0; u32 led_value = 0; void SetupInterruptSystem(XScuGic *GicInstancePtr, XGpioPs *Gpio, u16 GpioIntrId); void IntrHandler(); int main(){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/354b9e1b527ced8c08bffd65d73b417c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace93b709a570ff30aef607417cc6625/" rel="bookmark">
			程序员职业生涯系列：关于技术能力的思考与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引子
技术人成长的悖论
技术能力是什么？
重复琐碎类工作的不同做法
抽象复杂类工作的不同做法
成长的维度
技术能力层次模型
术：硬核技术能力
法：技术架构能力
道：技术领导力
如何提升技术能力
寻找成长的源动力
常态化的总结与反思
实用技巧
程序员的理性与感性活动：程序员的自我修养
理性与感性活动
与系统和人打交道
宏观与微观层面
关于影响力
程序员的技能素养
不教条
自驱力、学习力
勇气
结构化思维
批判性思维
技术人的四大出路，你适合哪一个？
技术之路
技术管理之路
技术转型之路
技术人自主创业
技术人职业发展
常见技术岗位划分
小结
引子 儒、释（佛）、道三家思想：
释（佛家）：处理好人与心的关系，我们要战胜自己；
儒（儒家）：处理好人与人的关系，我们要团结好他人；
道（道家）：处理好人与自然的关系，我们应该顺势而为。
明人陆绍珩《醉古堂剑扫》自叙有云：
一愿识尽人间好人，
二愿读尽世间好书，
三愿看尽世间好山水。
或曰：静则安能，但身到处，莫放过耳。旨哉言乎！
余性懒，逢世一切炎热争逐之场，了不关情。
惟是高山流水，任意所如，遇翠丛紫莽，竹林芳径，偕二三知己，抱膝长啸，欣然忘归。
加以名姝凝盻，素月入怀，
轻讴缓板，远韵孤箫，
青山送黛，小鸟兴歌，
侪侣忘机，茗酒随设，
余心最欢，乐不可极。
若乃闭关却扫，图史杂陈，
古人相对，百城坐列，
几榻之余，绝不闻户外事。则又如桃源人，尚不识汉世，又安论魏晋哉？此其乐，更未易一二为俗人言也。
又云：宠辱不惊，看庭前花开花落；去留无意，望天上云卷云舒。
其实就是讲内心修炼到了一种心境平和，淡泊自然的境界。
技术人成长的悖论 在程序员界有一个悖论持续在困惑着很多技术人：
1、在写代码的人的困惑是一直写代码是不是会丧失竞争力，会不会被后面年轻的更能加班写代码的人汰换。典型代表就是工作5年左右的核心技术骨干，此时正处于编码正嗨但也开始着手规划下一个职业发展阶段的时候。
2、没在写代码的人困惑是我长时间不写代码（或者代码量较少）我的技术功底是不是在退化，我在市场上还会有竞争力吗，我的发展空间是不是被限制住了。典型代表就是带业务项目的架构师或者团队Team Leader，他们更多的精力是在业务需求理解和拆分，团队事务的管理上。
这种“内卷”现象非常严重，也是技术人在职业发展过程中必定会面临的困境。
但要回答清楚这个问题，其根源不在于是写不写代码或者代码量的多少，其本质还是要回到什么叫技术能力以及如何提升技术能力这个根节点上来。我把我的一些观察和思考总结下来，供大家参考。
技术能力是什么？ 技术能力本质就是解决问题的能力。
在编程领域，就是对遇到的业务问题进行抽象、提炼以及逻辑的构建，通过研发工具以提升解决问题的效能，降低人工低效的重复工作。
提升技术能力的方法：寻找成长的源动力；常态化的总结与反思；实用技巧（写文章）以写代想，以想促讲，以讲验真。
程序员日常工作：重复琐碎类工作；抽象复杂类工作。
重复琐碎类工作的不同做法 第一种：就事论事，把这个问题回答了结束。到这个程度你只是解决了一个具体的问题。很可惜我们很多技术同学都是处于这个层次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace93b709a570ff30aef607417cc6625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d2f56d8e7b51e147404526802012f3/" rel="bookmark">
			python：批量处理txt文件，读取txt文件内容，根据内容（例子为数字1）提取出对应txt文件到其他文件夹，后根据txt文件名提取对应名字图片。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本段代码为根据想要内容（数字1），把所有txt文件中有数字1的复制保存至其他文件夹
# 提取全部txt文件中 含有pf缺陷的txt文件 保存至其他文件夹中 import os import shutil # 读取给定目录下的所有 .txt 文件的文件名 def read_txt_files(path): # 创建文件名列表 file_names = [] # 遍历给定目录及其子目录下的所有文件 for root, dirs, files in os.walk(path): # 遍历所有文件 for file in files: # 如果是 .txt 文件，则加入文件名列表 if file.endswith('.txt'): # endswith () 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。 file_names.append(os.path.join(root, file)) # 返回文件名列表 return file_names # 读取 .txt 文件中的每一行，并返回每一行的第一个元素的列表 def read_txt_file(file_name): # 打开文件 with open(file_name, 'r') as file: # 读取文件中的所有行 lines = file.readlines() # 返回每一行的第一个元素的列表 first_elements = [line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d2f56d8e7b51e147404526802012f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21fcd724ed58e557e6c1659a43e8144/" rel="bookmark">
			Linux系统——新增用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.获取useradd命令的帮助 useradd -h 2.列出系统中的当前用户 cat /etc/passwd | cut -d : -f 1 3.建立新用户 useradd test 4.默认情况下，useradd命令将在/home路径中创建一个与用户名同名的主目录， 例如，如果用户名是test，则用户的主目录将是/home/test
useradd -d /home/mytest test5 此命令将使用主主 目录（例如/home/mytest）创建测试用户
5.创建具有特定用户ID的用户 系统为用户ID以便区分开来，用户ID从500开始，并在添加新用户后递增，但是我们
可以通过设置特定的ID来更改此默认行为，而无需获取默认UID。
-u 将提供给useradd命令以指定新用户的UID
增加nick用户：
useradd -u 567 nick 查询nick用户：
grep nick /etc/passwd 6.创建具有特定组ID的用户 系统在创建用户时，也会创建新的组，该组专用于新用户，并且新用户自动分配给
该用户组。默认情况下，将分配新的用户组ID，该ID从1000开始
可以使用-G选项更改此值。
useradd -g 0 nick 7.将用户添加到多个组 useradd -g root,vboxusers,kvm nick 8.创建具有日期到期的用户 useradd -e 2022-09-24 nick 使用chage来检查该日期：
chage -l nick 9.创建一个密码过期日期的用户 保护新创建用户的另一种方法是指定密码过期日期。指定密码到期日期将迫使
用户在指定日期更改其密码。通过定期更改密码，使用户凭据更安全
-f选项是天数，如果提供值是-1，密码将永不过期。
useradd -e 2022-09-23 -f 30 nick 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e21fcd724ed58e557e6c1659a43e8144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f127b985228bc7ff90a94741e0f5799f/" rel="bookmark">
			c#反射-执行方法和创建实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例类 以下是示例类，有两个重载方法和一个构造器。
class TestClass { public string GetString(int i) { return i.ToString(); } public string GetString(int a, int b) { return (a * b).ToString(); } public TestClass(string s) { Console.WriteLine("hello" + s); } } 执行方法 获取到方法后，使用Invok调用方法。
需要传入两个参数，第一个是从谁身上执行方法（如果是静态方法可以是null）。
第二个参数是所有参数构成的数组。
var m1 = type.GetMethod("GetString", new Type[] { typeof(int) }); var m2 = type.GetMethod("GetString", new Type[] { typeof(int), typeof(int) }); TestClass ts = new TestClass("admin"); object o1 = m1.Invoke(ts, new object[] { 16 }); object o2 = m2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f127b985228bc7ff90a94741e0f5799f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da39a2c63f309ca1d83048792d486601/" rel="bookmark">
			Qt学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号与槽函数 解释 （1）信号和槽是用于QT对象之间的通信，信号可以有某种动作触发，也可以直接由代码触发。
（2）槽也叫操函数，当完成了信号和槽的连接之后，一旦触发信号，自动调用连接的槽函数。
（3）信号和槽的连接是动态的，对象释放后会自动断开所有的信号和槽。
（4）代码触发信号的写法
什么是信号和槽 信号和槽是用于对象之间的通信，它是Qt的核心机制，在Qt编程中有着广泛的应用。如果想学好Qt，一定要充分掌握信号的槽的概念与使用。
举个例子，在一个十字路口，信号灯变成了绿色，对面的汽车看到后就启动了。信号灯就是发送信号的对象，绿灯亮是它发送的信号 (signal)，汽车是接收对象，汽车行驶是汽车对信号的响应，也叫槽 (slot)。
再举一个例子，比如在一个主窗口内有一个关闭按钮，如果点击这个按钮窗口就会关闭，那么关闭按钮是发送信号的对象，它发送的信号是点击，接收信号的对象是窗口，响应信号的槽是关闭窗口。
添加信号 关键字signals定义一个信号，信号不能也无需实现，并且返回值是void，信号与槽方法都可以携带参数，但是槽方法的参数类型必须是信号参数类型保持一致或者少于信号参数
signals: void Commeon(QString&amp; str); //信号不能也无需实现，且返回值是void 发送信号 使用emit关键字发送信号 。我们可以在任何地方使用emit关键字发送信号，包括在槽方法内
void MainWindow::on_whBtn_clicked() { QString str="武汉"; emit Commeon(str); } void MainWindow::on_zgBtn_clicked() { QString str="中国"; emit Commeon(str); } void MainWindow::on_sjBtn_clicked() { QString str="世界"; emit Commeon(str); } 信号与槽连接 QMetaObject::Connection QObject::connect( const QObject *sender, //信号发送者 const char *signal, //发送的信号 const QObject *receiver, //信号接收者 const char *method, //表示与信号连接的方式的字符串，可以是槽或信号 Qt::ConnectionType type = Qt::AutoConnection //连接方式，默认自动连接 ) 常用格式：connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da39a2c63f309ca1d83048792d486601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ce6a4a79de8ada73c8d91460cd4f045/" rel="bookmark">
			python3 -m http.server 80
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个命令在 Python 3 中启动了一个简单的 HTTP 服务器，并将其监听在端口 80 上。默认情况下，服务器会在当前工作目录中寻找文件，并将它们作为 Web 内容提供给客户端。此命令通常用于在本地开发或测试时快速提供 Web 内容。
注意：在生产环境中不建议使用这个命令，因为它不提供安全性和性能保证。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40922e8d746e3fbd223bd6e50b6482d5/" rel="bookmark">
			watch监听不到 props变量的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题
二、解决方法
三、总结
一、问题 1.父组件向子组件传参变量 detailData:{tableData:devicelist}。在父组件中detailData是响应式的。
在第一层子组件中接收detailData,并且通过:detailData="detailData.tableData"传递给第二层子组件, 在第二层子组件中使用如下代码监听deailData的变化，用watch就是监听不到detailData的变化。
watch( () =&gt; props.detailData, (newval,oldval) =&gt; { //监听到 detailData的变化，我需要执行一些函数 console.log("watch detailData") } ); 二、解决方法 1.检查了监听的代码，正确的呀，没有问题
2.使用devtools插件检查，看到子组件中的detailData确实是发生了变化的呀，怎么我就是监听不到呀。很是离谱。、
3.是不是 detailData不是响应式的呢？也不是呀，使用 isReactive(detailData)，检查了是响应式的呀。
4.到底是为什么呀，我真的没有见过这么离谱的事情，在第一层子组件中都监听不到 detailData的变化。尝试在父组件中监听 detailData的变化，结果竟然除了第一次变化，之后的变化的监听不到——离奇呀，devtools告诉我子组件的值都变了，只是没有渲染上去;父组件的监听却告诉我detailData的值压根就没有变化。
5.看到给detailData赋值的地方，于是打印了一下给detailData赋的值，但是也只能打印第一次赋值的情况，后续赋值也打印不出来呀。
console.log("item",isRef(item),item,isProxy(item)) Object.assign(detailData, { tableData: item }); 6.最后的最后：我要求detailData变化，就是要求 上面代码中的 item（deviceList)一直变化。竟然发现有一处写了如下一段代码，直接给devicelist赋值，devicelist不就是会失去响应式吗？可是为啥 isProxy()判断竟然是 true?
没细想把这段直接给响应式数据 deviceList赋值的代码注释了，竟然好了。。。。。。。
deviceList = deviceList.map((element) =&gt; { if (!element.isWarning) { element.isWarning = 0; } if (!element.level) { element.level = 0; } if (!element.remainTime || element.remainTime === '- -') { element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40922e8d746e3fbd223bd6e50b6482d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2141099d0874bc19468f28a120c69fdc/" rel="bookmark">
			c# 委托的同步调用（invoke）和异步调用(beginvoke)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;
namespace InvokeAndBegininvoke
{
public partial class Form1 : Form
{
public delegate void MsgDelegate(String str);//声明一个委托类型
public MsgDelegate msgDisp;//声明委托变量
public Form1()
{ InitializeComponent();
}
private void Form1_Load(object sender, EventArgs e)
{ }
private void msgShow(string text)
{ int i = int.Parse (text);
for (; i &lt; 1000; i++)
{ richTextBox1.Text += i.ToString() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2141099d0874bc19468f28a120c69fdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4da53a35f60d9321d32640e2cea706/" rel="bookmark">
			c# 跑马灯显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//本文演示跑马灯
//用到了线程、同步委托
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;
using System.IO;
namespace 跑马灯
{
public partial class Form1 : Form
{ public List&lt;Label&gt; lists = new List&lt;Label&gt;();//lists类型为Label
public delegate void MsgDelegate();//声明委托
public MsgDelegate msgDelegate; //声明委托变量
public bool start = new bool(); public bool stop=new bool();
public Form1()
{ InitializeComponent();
foreach (var item in this.Controls) //遍历所有Label,赋值到lists
{ if (item.GetType().ToString().Contains("Label"))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a4da53a35f60d9321d32640e2cea706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6cd1c7a8dd48c78a3ff3b36f8b7713/" rel="bookmark">
			js去掉所有的html 标签（正则）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 str = str.replace(/&lt;[^&gt;]+&gt;/g,""); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6861776e54b57447c01cd498d844502/" rel="bookmark">
			C#编程，异步中的等待处理Task.Delay
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、总结 1.Task.Delay实质是创建一个任务，再任务中开启一个定时间，然后延时指定的时间
2.Task.Delay不和await一起使用情况，当代码遇到Task.Delay一句时，创建了了一个新的任务去执行延时去了，当前代码继续往下执行
3.Task.Delay和await一起使用，当代码遇到await Task.Delay时候，当前线程要等该行代码执行完成后，再继续执行后面的代码
4、Thread.Sleep 是同步延迟，Task.Delay异步延迟。
5、Thread.Sleep 会阻塞线程，Task.Delay不会。
6、Thread.Sleep不能取消，Task.Delay可以。
7、Task.Delay() 比 Thread.Sleep() 消耗更多的资源，但是Task.Delay()可用于为方法返回Task类型；或者根据CancellationToken取消标记动态取消等待
8、Task.Delay() 实质创建一个运行给定时间的任务， Thread.Sleep() 使当前线程休眠给定时间。
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading; using System.Threading.Tasks; using System.Windows.Forms; namespace _006__Task.Delay { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void btnDelayNoAwait_Click(object sender, EventArgs e) { Task task = Task.Factory.StartNew(() =&gt; { Console.WriteLine($" Task.Delay开始：{DateTime.Now.ToString(" HH:mm:ss.fff")}"); for (int i = 0; i &lt; 10; i++) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6861776e54b57447c01cd498d844502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bbdc490509268b741b589139e35ff24/" rel="bookmark">
			基础篇（二）：内存屏障是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前置知识：内存屏障什么是内存屏障作用内存屏障的分类1. 强制读取/刷新主内存的屏障强制刷新主内存：Load屏障强制读取主内存：Store屏障总结 2. 禁止指令重排序的屏障LoadLoad屏障StoreStore屏障LoadStore屏障StoreLoad屏障以StoreStore屏障和StoreLoad屏障举个例子 前置知识：内存屏障 什么是内存屏障 内存屏障是一种指令，无论是在JAVA内存模型还是CPU层次，都是有具体的指令对应的，是一种特殊的指令。
作用 这种指令具有屏障的作用，所谓屏障，也就是类似关卡，类似栅栏，具有隔离的作用。
内存屏障的分类 强制读取主内存，强制刷新主内存的内存屏障，叫做Load屏障和Store屏障禁止指令重排序的内存屏障，有四个分别叫做LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障 1. 强制读取/刷新主内存的屏障 Load屏障：执行读取数据的时候，强制每次都从主内存读取最新的值。
Store屏障：每次执行修改数据的时候，强制刷新回主内存。
强制刷新主内存：Load屏障 如上图所示：在工作内存的变量名、变量的值之前有一道关卡或者栅栏，导致变量 i 获取不到工作内存中的值，所以每次只好主内存重新加载咯。
强制读取主内存：Store屏障 如上图所示，每次执行assign指令将数据变更之后，后面都会紧紧跟着一个Store屏障，让你立刻刷新到主内存。
总结 只要加了Load屏障，相当于加了一个栅栏，不管工作内存是否有数据，都是从主内存读取数据。只要加了Store屏障，具有强制作用，进行assign操作将变量更改了之后，立刻将变量刷新到主内存
2. 禁止指令重排序的屏障 LoadLoad屏障 序列：load1指令 LoadLoad屏障 load2指令
作用：在load1指令和load2指令之间加上 LoadLoad屏障，强制先执行load1指令再执行load2指令；load1指令和load2指令不能进行重排序（LoadLoad屏障 前面load指令禁止和屏障后面的load指令进行重排序）。
StoreStore屏障 序列：store1指令 StoreStore屏障 store2指令
作用：在store1指令和store2指令之间加上StoreStore屏障，强制先执行store1指令再执行store2指令；store1指令不能和store2指令进行重排序（StoreStore屏障 前面的store指令禁止和屏障后面的store指令进行重排序）
LoadStore屏障 序列：load1指令 LoadStore屏障 store2指令
作用：在load1指令和store2指令之前加上LoadStore屏障，强制先执行load1指令再执行store2指令；load1指令和store2执行不能重排序（LoadStore屏障 前面的load执行禁止和屏障后面的store指令进行重排序）
StoreLoad屏障 序列：store1指令 StoreLoad屏障 load2指令
作用：在store1指令和load2指令之间加上StoreLoad屏障，强制先执行store1指令再执行load2指令；
store1指令和load2指令执行不能重排序（StoreLoad屏障 前面的Store指令禁止和屏障后面的Store/Load指令进行重排）
以StoreStore屏障和StoreLoad屏障举个例子 （1）有三个区域分别是区域1、区域2、区域3
（2）区域1和区域2加了 StoreStore屏障，这样区域1和区域2的Store指令就被隔离开来，不能重排了
（3）区域2和区域3加了StoreLoad屏障，这样区域2和区域3的Store指令、Load指令就被隔离开来，不能重排了
（3）就相当于搞了个栅栏，禁止各个区域之间的指令跳来跳去的，否则就会导致乱序执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcb04c649397954f04111621b2d7868/" rel="bookmark">
			hive outline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航 hive 简介OLTP 和 OLAP 的区别hive 安装hive 测试是否安装成功hive 配置metastore三种方式hive 运行日志 数据仓库 数据仓库显示 配置hive 建表-复杂数据类型hive 内部表 外部表 创建hive 分区表 静态 动态分区hive 分桶表hive 视图hive 事务表hive 拉链表hive 查看文件系统命令hive 数据库 表 列（DDL）hive 数据导入 导出（DML）hive select查询（DQL）hive Order By Cluster By Distribute By+Sort Byhive 内连接 左外连接 右外连接 满外连接 左半开连接 交叉连接 多表连接 隐式连接hive 函数分类hive 内置函数hive 字符串函数hive 日期函数hive 数学函数hive 集合函数hive 条件函数hive 类型转换函数 casthive 数据脱敏函数hive java_method reflect hive 用户自定义函数hive 高阶函数hive explodehive lateral view 侧视图hive explode与posexplode的区别hive 增强聚合函数 Grouping setshive 增强聚合函数 Cubehive 增强聚合函数 with rolluphive 窗口函数 窗口表达式 窗口排序函数 窗口分析函数hive url 解析函数hive json数据处理函数 hive 调优（work）hive 数据倾斜（work）hive 小文件产生的原因 危害 解决方案（work）hive join 的工作机制（work）hive 面试（work） hive 简介 链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdcb04c649397954f04111621b2d7868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b916f4f3e95be8cf7d2227f50c0c80d/" rel="bookmark">
			Android ANR bugreport log分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作中频繁遇到设备ANR问题，而且是概率性的那种，于是决定花点时间找找规律复现分析下
说道这里，抓日志是问题解决的最有效途径，这里不得不说一下 bugreport log,其实网上关于它的分析方法有很多，在此仅仅是为了记录下bugreport 日志分析的过程和小技巧
希望对大家有所帮助。
1.抓取bugreport 日志（不指定，默认为当前目录）
- adb bugreport ..
- bugreport anr 目录
2.bugreport log 分析
拿到log，首先要了解下log 抓取到的系统基本信息，主要包括 内存，CPU ，进程队列 ，虚拟内存 ， 垃圾回收等信息
2022-04-20 18:15:20.674 870-970/? E/ActivityManager: Aborting stack trace dump (current extra pid=3061); deadline exceeded. 2022-04-20 18:15:20.675 870-970/? I/AnrManager: dumpStackTraces end! 2022-04-20 18:15:20.738 870-970/? I/AnrManager: ANR in 包名 (包名/.ui.activity.MainActivity), time=342068 Reason: Input dispatching timed out (Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b916f4f3e95be8cf7d2227f50c0c80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada2fe49e26be6f67cd963c1de423bcb/" rel="bookmark">
			如何用python 实现股票筹码峰 的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现股票筹码峰的代码需要以下几个步骤：
获取股票数据：可以通过爬虫获取实时股票数据，也可以从股票数据源获取历史数据。
数据处理：处理获取的数据，清洗数据，以计算股票的筹码峰。
筹码峰计算：计算股票的筹码峰，可以使用相关的算法，如均值，方差等。
可视化：将计算的筹码峰结果进行可视化，便于观察和分析。
以下是一个简单的代码实现示例：
import pandas as pd import numpy as np import matplotlib.pyplot as plt # 读取股票数据 data = pd.read_csv("stock_data. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b16b18c3b01cdd9c823091079b4491d/" rel="bookmark">
			企业web集群的搭建和应用报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
一、实训内容和要求
二、 相关知识 1. web应用nginx动静分离技术 2. Tomcat环境部署 3. Mariadb主从复制 4. Zabbix监控系统 三、 系统架构及基本环境要求 四、 系统搭建过程 五、 结果与测试 六、总结
一、实训内容和要求 本次实训内容模拟企业web集群的构建，其中涉及的知识点包括linux系统知识、nginx服务的安装及动静分离技术应用、tomcat的相关配置、mariadb数据库的主从复制、vsftpd虚拟用户的配置及使用同时还包括了集群的监控系统。要求学生通过本次实训掌握web集群的技术特点及实现方法。
二、相关知识 1.web应用nginx动静分离技术
动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat 出来动态页面。动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。
2.Tomcat环境部署
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器是开发和调试JSP程序的首选。
3.Mariadb主从复制
主从复制的原理图
①　主库db的更新事件(update、insert、delete)被写到binlog
②　主库创建一个binlog dump thread，把binlog的内容发送到从库
③　从库启动并发起连接，连接到主库
④　从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
⑤　从库启动之后，创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db.
4.Zabbix监控系统
zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent,可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD等平台上。
三、系统架构及基本环境要求
1.拓扑图如图-1，模拟实验环境所需的服务器信息如【表-1】。
2.相关说明：
模拟环境需要3台虚拟，主机名称分别为T001,T002,T003
T001为nginx负载均衡，其做作用是完成动态网页和静态网页的分离，同时安装vsftpd、rsync+inotify服务。
T002部署nginx相应静态网页，同时部署mariadb server该数据库服务的角色为slave
T003部署tomcat+jdk相应动态网页，同时部署mariadb server该数据库服务的角色为master。
Zabbix监控系统部署在T003服务器。
【图-1】
服务器IP地址应用部署T001ens33: 192.168.79.170 (NAT模式) 、 ens37: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b16b18c3b01cdd9c823091079b4491d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d2a8b0f25558a863aef7b8aacab594/" rel="bookmark">
			armeabi-v7a arm64-v8a armeabi都是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下，现在市面上常见的CPU架构类型如下：
1、armeabi-v7a: 第7代及以上的 32位ARM 处理器
2、arm64-v8a: 第8代、64位ARM处理器
3、armeabi: 第5代、第6代的32位ARM处理器，早期的手机在使用，现在基本很少了。
4、x86: Intel 32位处理器，在平板、模拟器用得比较多。
5、x86_64: Intel 64位处理器，在平板、模拟器用得比较多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97627f5ccc7ce91202179a514c08b5ab/" rel="bookmark">
			DVWA靶场通关和源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Brute Force1.low2、medium3、High4、Impossible 二、Command Injection1、Low2、Medium3、High 三、CSRF1、Low2、Medium3、High4、Impossible 四、File Inclusion1、Low2、Medium3、High 五、File Upload1、Low2、Medium3、High4、Impossible 六、 SQL注入1、Low2、Medium3、High4、Impossible 七、SQL盲注1、Low2、Medium3、High4、Impossible 八、Weak Session IDs1、Low2、Medium3、High4、Impossible 九、XSS(DOM）1、Low2、Medium3、High4、Impossible 十、XSS（Reflected）1、Low2、Medium3、High4、Impossiblle 十一、XSS（Stored）1、Low2、Medium3、High4、Impossible 十二、 CSP Bypass1、Low2、Medium3、High4、Impossible 十三、JavaScript1、Low2、Medium3、High 一、Brute Force 1.low 简单爆破脚本：
import requests s = requests.session() headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0', 'Cookie': 'PHPSESSID=02t5fg1bf27dpm9lk6il83b8k7; security=low' } f = open('password.txt', 'r',encoding='utf-8') while 1: password=f.readline().rstrip() if not password or not password: break url = f'http://121.40.115.95/vulnerabilities/brute/?username=admin&amp;password={password}&amp;Login=Login#' resp = s.get(url, headers=headers) if 'Username and/or password incorrect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97627f5ccc7ce91202179a514c08b5ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc2dd3e9521b58bbdbd3774d3bcca6d/" rel="bookmark">
			深度学习通用训练步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习通用训练步骤
1、选择model并送入GPU
2、加载权重（如果有）
3、定义优化器、定义lr衰减机制
4、定义loss并送入GPU
5、Dataset（）
6、model.train() #指定为训练模式，解冻dropout等层
7、for epoch in range():
Dataloder()
train() #指每一个batch的处理过程，见下面。
lr更新
test（） # 每个epoch完验证一下（记得指定为验证模式，model.eval()冻结 dropout，BN等层）
注：train（）函数
for i , data in enumerate(train_dataloader): #对于每个batch image，label 送入GPU
output=model（image） #将数据送入model
loss=loss_function（output，label） #计算loss
model.zero_grad() #清除梯度，或optimizer.zero_grad() (只有当这个优化器是这个model的优化器时，两者等同)
loss.backward() #计算梯度
optimizer.step（） #更新权重
计算（对每个batch累加平均）相应参数（acc，loss，auc，eer等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/512f5602414fa12d1ceba55e7031bcd8/" rel="bookmark">
			深度学习毕业设计 CNN实现谣言检测系统 - python 机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1.1 背景 2 数据集3 实现过程4 CNN网络实现5 模型训练部分6 模型评估7 预测结果8 最后 1 前言 Hi，大家好，学长今天向大家介绍 一个深度学习项目
基于CNN实现谣言检测
1.1 背景 社交媒体的发展在加速信息传播的同时，也带来了虚假谣言信息的泛滥，往往会引发诸多不安定因素，并对经济和社会产生巨大的影响。
2 数据集 本项目所使用的数据是从新浪微博不实信息举报平台抓取的中文谣言数据，数据集中共包含1538条谣言和1849条非谣言。
如下图所示，每条数据均为json格式，其中text字段代表微博原文的文字内容。
每个文件夹里又有很多新闻文本。
每个文本又是json格式，具体内容如下：
3 实现过程 步骤入下：
*（1）解压数据，读取并解析数据，生成all_data.txt
*（2）生成数据字典，即dict.txt
*（3）生成数据列表，并进行训练集与验证集的划分，train_list.txt 、eval_list.txt
*（4）定义训练数据集提供器train_reader和验证数据集提供器eval_reader
import zipfile import os import io import random import json import matplotlib.pyplot as plt import numpy as np import paddle import paddle.fluid as fluid from paddle.fluid.dygraph.nn import Conv2D, Linear, Embedding from paddle.fluid.dygraph.base import to_variable #解压原始数据集，将Rumor_Dataset.zip解压至data目录下 src_path="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/512f5602414fa12d1ceba55e7031bcd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7aa961f06dab069ca6d4bcfef8f4062/" rel="bookmark">
			ingess报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题Internal error occurred: failed calling webhook “validate.nginx.ingress.kubernetes.io”: Post https://ingress-nginx-controller-admission.kube-system.svc:443/networking/v1beta1/ingresses?
timeout=10s: dial tcp 10.0.0.5:8443: connect: connection refused
错误提示 Internal error occurred: failed calling webhook "validate.nginx.ingress.kubernetes.io": Post https://ingress-nginx-controller-admission.kube-system.svc:443/networking/v1beta1/ingresses? timeout=10s: dial tcp 10.0.0.5:8443: connect: connection refused 原因 之前安装的ingess-controller 存留了ValidatingWebhookConfiguration没有删除，再安装ingess-controller 就会存在问题。
[root@k8s-master ~]# kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io NAME WEBHOOKS AGE ingress-nginx-admission-nginx 1 7m45s ingress-nginx-admission-sap 1 27d resourcesquotas.quota.kubesphere.io 1 17d 解决方法 [root@k8s-master ~]# kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io NAME WEBHOOKS AGE ingress-nginx-admission-nginx 1 7m45s ingress-nginx-admission-sap 1 27d resourcesquotas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7aa961f06dab069ca6d4bcfef8f4062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2817bbe1cbdb8bafed39121911a0c4bb/" rel="bookmark">
			本地Pycharm连接远程服务器详细配置过程（直接在本地使用服务器显卡）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、建立远程服务器连接1.创建远程连接2.进行本地项目与远程项目之间的文夹路径映射3.设置自动上传项目4.验证是否连接成功 二、本地配置Python解释器三、测试案例四、本地启动服务器终端五、注意 前言 相信很多人都遇见过这种情况：实验室成员使用同一台服务器，每个人拥有自己的独立账号，我们可以使用服务器更好的配置完成实验，毕竟自己哪有money拥有自己的3090呢。通常服务器系统采用Linux，而我们平常使用频繁的是Windows系统，二者在操作方面存在很大的区别，比如我们实验室的服务器采用Ubuntu系统，创建远程交互任务时可以使用Terminal终端或者VNC桌面化操作，我觉得VNC很麻烦，所以采用Terminal进行实验，但是Terminal操作给我最不好的体验就是无法可视化中间实验结果，而且实验前后的数据上传和下载工作也让我头疼不已。前几天偶然看见本地Pycharm可以进行远程服务，抱着试试的态度我开始了环境配置…
一、建立远程服务器连接 说在前面：Pycharm分为专业版和社区版，只有专业版才支持远程服务，所以大家可以先确认自己的Pycharm版本，可通过下图所示操作查看自己的版本（工具栏help-&gt;about）：
然后开始进行本地与远程服务器之间的连接配置：
1.创建远程连接 配置环境的第一部工作是建立本地与远程服务器之间的SSH连接，我们知道远程服务器上的任务拥有自己的SSH以及用户名，用户名通常为root，SSH由ip:port两部分组成，ip为服务器ip地址，port为端口号，我们需要获取这个SSH连接后续配置需要使用：
1）开始配置
2）建立SSH连接
（1）选择文件传输协议SFTP
（2）设置服务器名（这个可以随意命名），此处我命名为DehazingServer
（3）配置SSH连接
点击SSH配置右侧的"…"，进行SSH内容设置：
此处我们需要设置三个参数：Host为前面提到的远程服务器ip地址xxx.xxx.xxx.xxx；Port为SSH连接后的端口号；User name为远程服务器用户名，通常为root；
（4）测试连接是否成功
点击Test Connection，进行连接测试，此时会出现密码输出框，输入远程服务的密码即可：
若成功会出现下图所示结果：
2.进行本地项目与远程项目之间的文夹路径映射 为了后续本地与服务器之间同一项目可以内容同步，我们还需要设置二者之间的项目路径映射，即本地项目在远程服务器中存放的位置：
3.设置自动上传项目 在连接建立并配置好本地与远程项目之间的路径映射后，我们再设置自动上传项目即可，如此本地与服务器之间就可以进行项目同步了，此时我们更新了本地代码之后只要使用Ctrl+S保存代码即可完成同步：
此处需要注意如果自动上传无法成功，我们可以手动将本地项目上传到服务器（选择上面的Upload to即可），一定要在本地代码更改后及时上传同步到服务器！！反之，如果服务器对代码进行了修改，则通过本地的Download from拉取服务器中的代码同步本地。
4.验证是否连接成功 在进行SSH连接建立之后，通过下图所示方法可验证是否连接成功：
如下图所示，点击浏览远程主机之后可在本地Pycharm右侧看到远程服务器的文件目录，此时可看到与远程服务器的文件目录一模一样（我们实验室服务器的私人数据就在下图中的/opt/data/private目录下）：
二、本地配置Python解释器 此时我们还不能在本地使用服务器的环境，我们需要将本地Pycharm的Python解释器设置为远程服务器中的指定环境下的Python解释器：
1）查询服务器中所使用的的Python解释器路径
进入服务器终端使用命令：
which python 即可查询python解释器的路径，这里我使用的是Anaconda中的虚拟环境，所以我需要先进入虚拟环境才可以使用该命令查询。需要注意的是，此时得到的Python路径可能是软链接的形式，我们可通过进入虚拟环境目录下使用ls -l命令查看该软链接真正指向的位置，比如我这里进入/opt/Anaconda3/envs/torch1.9/bin目录下看到python指向python3.7，所以我需要的Python解释器路径为/opt/Anaconda3/envs/torch1.9/bin/python3.7。
2）本地Pycharm中配置Python解释器
（1）进入设置，将服务器中的Python解释器添加到Pycharm中：
（2）选择SSH解释器，选择SSH配置，选中前面设置的服务器连接，然后点击Move-&gt;Next即可：
（3）这里需要设置远程服务器中的Python解释器路径和项目之间的路径映射，如下图所示：
到此处我们的环境配置工作就完成了！！大家可以进行测试了！
三、测试案例 这里我配置好环境之后，将本地的一个绘图代码同步到了服务器，并在本地直接运行此代码文件，可看到使用的是远程服务器的Python环境，但是我终于可以可视化结果了！！
四、本地启动服务器终端 现在我们可以在本地使用服务器的工作环境了，那如何在本地开启服务器终端呢，毕竟后面需要其他第三方库还得装包，这里我也说一下：
工具栏中打开Tools-&gt;Start SSH Session，然后选择我们前面配置的服务器，即可在本地Terminal处开启远程终端：
开启后效果如下：
五、注意 后面如果要切换回本地工作环境，直接去设置里面切换Python解释器即可！！！
原文链接：https://blog.csdn.net/qq_43665602/article/details/126970685
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7c060b8413613043483841f3098d0c/" rel="bookmark">
			前端调用后端接口,并把数据做分页处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端最主要的工作就是联合后端,调用后端接口,把页面用后端数据渲染出来
后端接口一般做封装处理
如下图:封装了一个接口,默认值处如果有默认值就写,如果没有默认值就直接写参数名,request下方记得把参数写全
在methods方法下方进行调用封装的接口,方法名随便起,调用接口方法中的变量和在封装接口中request保持一直,最下方做成功返回数据,若是做数据分页处理,在成功返回下方进行做(下方详细说明)
methods中的方法处理好后,先在script下方声明that,格式就是 var that,记得导入你所封装的接口,import { StoreCommodityList } from '../../../servies',然后在onLoad下方调用方法时先声明that = this,下方写入接口所给的数据,图中接口请求示例:{{host}}/f/api/guiji/getStoreCommodityList?guiJiCode=G340101002&amp;pageSize=10&amp;pageNo=1,最后调用接口的方法名
分页处理
先在html中写入uni-load-more(使用之前记得导入),loadMoreStatus为状态参数名
然后在return下方给loadMoreStatus一个默认状态
在所需要数据接口下方成功下做分页处理,因为没有总页数,所以就判断数据的长度和页大小就行比较
下拉刷新和触底加载 注意:
触底加载页数要+1并且还要判断是否需要下拉刷新,状态是否为'more',
下拉刷新数据需要先清空
&lt;template&gt; &lt;view&gt; &lt;u-sticky&gt; &lt;view style="background-color: #ffffff;"&gt; &lt;uni-section :title="terminal.guiJiCode+'('+terminal.jiGuiName+')'" :subTitle="terminal.store.name" type="line"&gt; &lt;view style="margin-bottom: 5px;"&gt; &lt;u-tag style="margin-left: 10px;" v-if="terminal.online" text="在线" type="success" /&gt; &lt;u-tag style="margin-left: 10px;" v-if="!terminal.online" text="离线" type="error" /&gt; &lt;u-tag style="margin-left: 10px;" v-if="terminal.terminalOpened" text="营业" type="success" /&gt; &lt;u-tag style="margin-left: 10px;" v-if="!terminal.terminalOpened" text="维护" type="error" /&gt; &lt;/view&gt; &lt;/uni-section&gt; &lt;uni-notice-bar showIcon scrollable v-if="text!=null" single :text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7c060b8413613043483841f3098d0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d173bf7237d56a085e48d688d7ed5a9/" rel="bookmark">
			遗传算法(Genetic Algorithm)之deap学习笔记(一): 基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法是通过计算机模拟生物学中的染色体用于解决最优化的一种搜索算法。
使用遗传算法要考虑的因素：
个体表征(Individual representation)
评估和适应度分配(Evaluation and fitness assignment)
选择(Selection)
变化(variation)，比如变异(Mutation)和交叉(Crossover)
停止标准(Stopping criterion)，确定算法何时应该停止，要么是因为达到最佳值，要么是因为优化过程没有进行。
一般来说遗传算法的结构为：
def evolutionary_algorithm(): population = [] # a list with all the individuals in the population population = initialize_population(pop_size) t = 0 while not stop_criterion( population[t] ): fitnesses = evaluate( population[t] ) populations[t+1] = environmental_selection( population[t], offspring ) offspring = mating_and_mutation( population[t], fitnesses ) t = t+1 DEAP是一个用于遗传算法计算的 Python 库：
https://deap.readthedocs.io/en/master/
DEAP GA 的基本特征：
deap.creator: 一个允许创建满足进化算法需求的类。
deap.base.Toolbox: 包含进化运算符的进化工具箱。可以使用 register() 方法任何与其他函数填充工具箱。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d173bf7237d56a085e48d688d7ed5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b0e54e1173384a19f51dce7521ffd4/" rel="bookmark">
			基于 SmartX 分布式存储的 RDMA 与 TCP/IP 技术与性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：深耕行业的 SmartX 金融团队
背景 上一篇 “分布式块存储 ZBS 的自主研发之旅｜架构篇” 文章中，我们简单介绍了 SmartX 分布式块存储 ZBS 的架构原理。接下来，我们将为读者深入解析 ZBS 存储中最为重要的技术之一“RDMA”。
目前 ZBS 在两个层面会使用到 RDMA 技术，分别是存储接入网络和存储内部数据同步网络。为了使读者更加容易理解，以及更有针对性地做存储性能对比，特通过两篇独立的文章分别进行介绍。本期，我们将聚焦 RDMA 远程内存直接访问技术，并结合 ZBS 内部存储数据同步进行详细的展开（ZBS 支持 RDMA 能力，也是在存储内部数据同步中最先实现）。
ZBS 存储内部数据同步 分布式存储系统与集中存储最重要的区别之一就是架构实现。分布式架构要保证数据的存储一致性和可靠性，就必须依赖网络进行数据同步。这里举一个例子，一个由 3 节点（A/B/C）组成的 ZBS 存储集群，数据采用两副本保护（数据存储两份，放置在不同的物理节点），假设数据分别存放在节点 A 和节点 B 上，当数据发生修改，ZBS 分布式存储必须完成对节点 A 和 B 的数据修改再返回确认。在这个过程中，A 和 B 节点同步数据修改，所使用的网络，即是存储网络。
通过例子，相信读者已经理解，数据同步效率对于分布式存储的性能表现有着非常大的影响，是分布式存储性能优化的重要方向之一，也是本篇文章重点讨论的内容。
图 1：分布式存储数据同步网络
在目前常规的工作负载需求下，ZBS 存储网络通常使用 10GbE 以太网交换机和服务器网卡配置，采用标准 TCP/IP 作为网络传输协议。但对于高带宽和低延时的业务工作负载，这样的配置明显会成为内部存储数据同步的性能瓶颈。同时，为了发挥新型的高速存储介质（例如 NVMe 磁盘）更强劲的 I/O 性能，采用 RDMA 技术并结合 25GbE 或更高的网络规格，是满足业务端更高的存储性能诉求的更优选择。
TCP/IP 通过软件定义实现的分布式存储，基于通用标准的硬件构建，是其有别于传统存储的重要的特点之一。多年以来，ZBS 使用 TCP/IP 网络协议栈作为存储内部通信方式，优势是具备与现有以太网最大的兼容性，同时满足绝大多数客户的业务工作负载需求。但 TCP/IP 网络通信逐渐不能适应更高性能计算的业务诉求，其主要限制有以下两点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21b0e54e1173384a19f51dce7521ffd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fc3f7282844c608b8976fd6fc76154/" rel="bookmark">
			Java：记录一下第一次面试经历（新希望六和）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录一下本菜鸡两个月前第一次面试新希望六合这家公司，那时的我很多都回答不上来，非常尴尬。不过这第一次面试经历也算是给足了我动力继续努力。
记录一下这个第一次面试的题目，也算是记录一下那时候的我
做过什么样的项目, 简单介绍一下你的项目, 项目的整体架构是什么样的, 运用的哪些技术, 介绍一下list 和 set 有什么区别HashMap put 的原理, 从 hashMap 的数据结构, 包括它的寻址, 扩容, 这几个方面去说== 和 equals 的区别重写了 equals 之后, 要不要重写 hashCodeString 可不可变？为什么不可变父类的静态方法能不能被子类重写静态方法和静态属性能不能被子类继承现在有一个父类和一个子类, 子类和父类都有自己的静态属性和静态方法, 现在去 new 一个子类的话, 它是怎样的执行过程.线程创建的方式有几种线程中常用的方法有写法wait 和 sleep 之间的区别线程池有哪些核心参数线程池的执行流程锁有没有了解过，简单讲述一下你了解的读写锁，简单说一下synchronized 和 lock 之间有什么区别synchronized 的锁升级策略Spring MVC 执行过程, 一个简单的前端请求到后端, 是怎么样流转的过程Spring 传播机制和隔离级别Spring Bean 的生命周期Spring 有哪些你所常用的注解@Spring Boot 有自动装配的功能, 自动装配是怎么自动装配的呢?MySQL 索引的数据结构是怎么样的, 在 InnoDB 的执行引擎下B + 是一颗什么样的树 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8525ce2661736973b6f7c9ba9e9ef6ae/" rel="bookmark">
			Cortex-M0综述概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1.简介2.特性系统特性应用特性调试特性其他特性 3.优势4.低功耗应用5.软件可移植性 1.简介 Cortex-M0处理器基于冯·诺伊曼架构（单总线接口），使用32位的精简指令集（RISC）。该指令集被称为Thumb（首次使用在ARM7TDMI上）。与之前相比，新的指令集增加了几条ARMv6架构的指令，并且纳入了Thumb-2指令集的部分指令。Cortex-M0总共支持56个基本指令。由于读写存储器的指令相互独立，而且算术或逻辑操作的指令使用寄存器，Cortex-M0处理器可以被归到加载-存储（load-store）的结构中。 其简单框图如下：
处理器核心包括寄存器组、算术逻辑单元（ALU）、数据总线和控制逻辑。流水线根据设计可以分为3种状态：取指、译码和执行。寄存器组包含16个32位寄存器。
其中，嵌套向量中断控制器（NVIC）可以处理最多32个中断请求和一个不可屏蔽中断（NMI）输入。NVIC需要比较正在执行中断和处于请求状态中断的优先级，然后自动执行高优先级中断。如果要处理一个中断，NVIC会和处理器进行通信，通知处理器执行正确的中断处理。
唤醒中断处理器（WIC）为可选的单元，在低功耗应用中，在关闭了处理器大部分模块后，微控制器会进入待机状态。此时，WIC可以在NVIC和处理器处于休眠的情况下，执行中断屏蔽功能。当WIC检测到一个中断时，会通知电源管理部分给系统上电，让NVIC和处理器内核执行剩下的中断处理。调试子系统包括多个功能模块，以处理调试控制、程序断点和数据监视点（data watchpoint）。当调试事件发生时，处理器内核会被置于暂停状态，这时开发人员可以检查当前的处理器状态。
JTAG（联合测试行动组）和SWD（串行线调试）提供了通向总线系统和调试功能的入口。JTAG是通用的5帧通信协议，一般用作测试。串行线协议为新扩展的，只需两根线就可以（时钟线和数据线），而且可以实现JTAG相同的调试功能。内部总线系统、处理器内核的数据通路以及AHB LITE总线接口都是32位宽的。 2.特性 Cortex-M0处理器具有多种特性，一些是可见的系统特性，另外一些对于开发者是不可见的。
系统特性 Thumb指令集，兼具高效和高代码密度，能够执行ARM7TDMI处理器的所有Thumb指令。高性能。内置的嵌套向量中断控制器（NVIC），中断配置和异常处理编程相当容易。当接收到中断请求后，中断处理就会自动执行，无须软件查找中断向量的位置。确定的中断响应时间，中断等待时间可以被设定为固定值或最短时间（最小为16个时钟周期）。不可屏蔽中断（NMI）输入，对高可靠性系统非常重要。架构预定义的存储器映射。存储器空间是线性的，而不像其他许多架构将存储器空间分页管理。方便易用，支持C语言，具有线程和处理两种模式。内置的系统节拍定时器（SysTick）。24位定时器，可被操作系统使用，或者用做通用定时器。请求管理调用，具有SVC异常和PendSV异常（可挂起的管理服务），支持嵌入式OS的多种操作。架构定义的休眠模式和进入休眠的指令，休眠特性能够使能量消耗极大降低。异常处理可以捕获到系统中的多种错误。 应用特性 中断数量可配置（1~32个）。快速乘法器（单周期）和小型乘法器（较小的硅片面积，低功耗，32周期）可供选择。支持大端或小端存储器。可选择的唤醒中断控制器（WIC），处理器可以在休眠状态下掉电以降低功耗，而WIC可以在中断发生时唤醒系统。极低的门数量，可用于混合信号半导体工艺。 调试特性 停止模式调试，处理器可以完全停止，此时寄存器可以被访问和修改。而且这样不会带来代码空间和栈空间的开销。CoreSight技术，调试器可以在没有停止处理器的情况下，操作存储器和外设。并且允许多核心的片上系统共用一个调试单元。支持JTAG和SWD调试接口。可配置数量的硬件断点（0~4个）和监视点（watchpoint）（0 ~ 2个）。断点指令支持不限数量的软件断点。芯片供应商可以取消所有的调试特性，使得规模最小。 其他特性 系统模型同ARM7TDMI处理器类似，大部分ARM7TDMI的Thumb代码可以重复使用。同Cortex-M1处理器相兼容，Cortex-M1的用户可以将其在FPGA上的设计移植到ASIC上。向上兼容Cortex-M3和Cortex-M4处理器，Cortex-M3支持Cortex-M0处理器的所有指令，因此向上升级到Cortex-M3将会非常简单。从Cortex-M3/Cortex-M4移植过来非常简单，因为这两种架构类似。被多种开发组件支持。被多种嵌入式系统支持。 3.优势 能耗效率：Cortex-M0相对于8位和16位处理器最显著的优势在于其能耗效率。Cortex-M0处理器和16位机差不多同等规模，但其性能却比8位和16位架构高得多。可以在其完成任务的同时，让处理器在大部分的时间里处于休眠状态，这样就可以降低功耗。8位和16位架构的局限性：在存储器容量和指令集方面，其相对于Cortex-M0具有明显的局限性。易于使用，软件可移植。选择多样化。 4.低功耗应用 Cortex-M0处理器通过以下几个方面，可以实现低功耗的目标：
门数量低：Cortex-M0的门数少，这也就直接降低了芯片的动态功耗和漏电流。高效率：拥有了高效率的架构，嵌入式开发人员开发产品时，可以使用较低的时钟频率来减小动态电流，而无须担心性能会降低。低功耗特性：Cortex-M0处理器具有很多低功耗特性，它们可以降低嵌入式系统的功耗。首先，处理器提供了两个休眠模式，可以使用WFI（中断触发唤醒）和WFE（事件触发唤醒）这两条指令进入相应的模式。利用休眠模式，芯片的电源管理单元可以降低系统的功耗。除了一般的休眠特性，Cortex-M0还包含了唤醒中断控制器（WIC）。利用这部分功能，即便处理器处于休眠状态，中断也可以将其立即唤醒，这样可以大大降低休眠时系统的漏电流（静态功耗）。逻辑单元提升 5.软件可移植性 Cortex-M3、Cortex-M1、Cortex-M0具有一致的内核架构、相似的系统模型和兼容的指令集。
兼容性如下：
Cortex-M0和Cortex-M1处理器都是基于ARMv6-M内核架构的，因此它们的指令集和系统模型几乎完全一样，但也有不同的地方，如指令时控和其他系统特性。Cortex-M3处理器基于ARMv7-M内核架构，所使用的Thumb-2指令集是ARMv6-M指令集的超集，系统模型同ARMv6-M相似。因此在Cortex-M0上设计的程序，可以在完全不用修改的情况下，在Cortex-M3处理器上运行。Cortex-M系列处理器的相似性带来了许多好处。首先，软件的移植性更好，在多数情况下，如果需要切换平台，C程序一般不需要改动。此外，同一款开发工具可以支持多种Cortex-M系列处理器，除了指令集和系统模型类似以外，调试架构也基本相同。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f54082a817db41b41c18da68a86491/" rel="bookmark">
			RabbitMQ的安装与基本使用（windows&#43;php版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ的安装与基本使用 一、安装erlang RabbitMQ服务端代码是基于并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang。
1.1 下载 Erlang官网：http://www.erlang.org/downloads
1.2 配置环境变量 变量名：ES_HOME
变量值：erlang 的安装路径
1.3 配置 erlang 可执行命令 path 1.4 查看 erlang 是否安装成功 二、安装 RabbitMQ RabbitMQ 官网下载地址：http://www.rabbitmq.com/download.html
双击下载后的.exe文件，傻瓜式"下一步"即可。
RabbitMQ 安装好后接下来安装 RabbitMQ-Plugins：
打开命令行cd，输入RabbitMQ的sbin目录输入 rabbitmq-plugins enable rabbitmq_management 命令进行安装打开sbin目录，双击 rabbitmq-server.bat 访问可视化界面：http://localhost:15672
用户名和密码默认都是：guest
三、安装 php 的 amqp 扩展 3.1 查看 php 的 thread safty 状态 3.2 根据php版本及thread satety状态，下载稳定版的dll amqp 的扩展下载地址：http://pecl.php.net/package/amqp
注意：php版本，X86 和X64 根据自己情况 而定 ，NTS 和 TS 就是那个thread safty 的状态
3.3 将 php_amqp.dll 文件放到 php 目录的 ext 文件夹下 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84f54082a817db41b41c18da68a86491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a91ffac1f5f088009682719711f700e/" rel="bookmark">
			国家专精特新小巨人的认定标准及流程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“专精特新”：“专”，即专业化与专项技术;“精”即产品的精致性、工艺技术的精深性和企业的精细化管理;“特”即产品或服务的独特性与特色化;“新”即自主创新、模式创新与新颖化。“专精特新”是指企业具有专业化、精细化、特色化、新颖化的发展特征。下面中科云策小编就来给大家详细说说国家专精特新小巨人的认定标准及流程。
国家专精特新小巨人的认定标准及流程
一、国家专精特新小巨人的认定标准
专精特新“小巨人”企业认定需同时满足专、精、特、新、链、品六个方面指标。
1、专业化指标
坚持专业化发展道路，长期专注并深耕于产业链某一环节或某一产品。截至上年末，企业从事特定细分市场时间达到 3 年以上，主营业务收入总额占营业收入总额比重不低于70%，近 2 年主营业务收入平均增长率不低于 5%。
2、精细化指标
重视并实施长期发展战略，公司治理规范、信誉良好、社会责任感强，生产技术、工艺及产品质量性能国内领先，注重数字化、绿色化发展，在研发设计、生产制造、供应链管理等环节，至少 1 项核心业务采用信息系统支撑。取得相关管理体系认证，或产品通过发达国家和地区产品认证(国际标准协会行业认证)。截至上年末，企业资产负债率不高于 70%。
3、特色化指标
技术和产品有自身独特优势，主导产品在全国细分市场占有率达到 10%以上，且享有较高知名度和影响力。拥有直接面向市场并具有竞争优势的自主品牌。
4、创新能力指标
满足一般性条件或创新直通条件。
(一)一般性条件。需同时满足以下三项：
1.上年度营业收入总额在 1 亿元以上的企业，近 2 年研发费用总额占营业收入总额比重均不低于 3%;上年度营业收入总额在 5000 万元—1 亿元的企业，近 2 年研发费用总额占营业收入总额比重均不低于 6%;上年度营业收入总额在5000万元以下的企业，同时满足近2年新增股权融资总额(合格机构投资者的实缴额)8000 万元以上，且研发费用总额3000 万元以上、研发人员占企业职工总数比重 50%以上。
2.自建或与高等院校、科研机构联合建立研发机构，设立技术研究院、企业技术中心、企业工程中心、院士专家工作站、博士后工作站等。
3.拥有 2 项以上与主导产品相关的Ⅰ类知识产权，且实际应用并已产生经济效益。
(二)创新直通条件。满足以下一项即可：
1.近三年获得国家级科技奖励，并在获奖单位中排名前三。
2.近三年进入“创客中国”中小企业创新创业大赛全国50 强企业组名单。
5、产业链配套指标
位于产业链关键环节，围绕重点产业链实现关键基础技术和产品的产业化应用，发挥“补短板”“锻长板”“填空白”等重要作用。
6、主导产品所属领域指标
主导产品原则上属于以下重点领域：从事细分产品市场属于制造业核心基础零部件、元器件、关键软件、先进基础工艺、关键基础材料和产业技术基础;或符合制造强国战略十大重点产业领域;或属于网络强国建设的信息基础设施、关键核心技术、网络安全、数据安全领域等产品。
二、国家专精特新小巨人的认定流程
1、申报采取网上填报与纸质报送相结合的方式。
2、网上填报：企业通过“专精特新”中小企业在线报送系统，在线填写并上传相关材料。
3、提交纸质材料：企业通过网上填报后，提交纸质材料(装订成册，一式三份，所有复印件加盖申报单位公章)，并现场拷贝电子版。纸质材料包含以下内容，请按顺序胶装成册，一式三份：
必选项：
(1)封面(注明国家级专精特新小巨人、企业名称、主导产品名称、企业地址、联系人、联系方式、申报时间等信息)。(2)附件2：2021年专精特新小巨人企业申请书(不需胶装，单独提交，请与申报系统填报资料保持一致)。(3)营业执照复印件。
可选项：对照一下10项可选指标(至少6项符合)，根据企业实际情况提供相关佐证材料：
(1)2019、2020年度审计报告复印件(需包含研发费用专门项，或提供研发费用的专审报告)、所得税纳税申报表(年度)。
(2)主导产品市场占有率或排名的佐证材料(政府机构、行业协会发布的官方文件或说明)。
(3)知识产权相关证书复印件(发明专利、集成电路布图设计专有权、实用新型、外观设计专利等)。
(4)研发人员名单(包含姓名、部门、职务、学历)、社保缴交证明(汇总表，税务机构机器打印)、研发人员社保缴交记录(详单)。
(5)特色称号佐证材料(工业文化遗产、地理标志产品、中华老字号、非物质文化遗产、农业产业化龙头企业、其他，提供由颁发部门提供的官方文件)。
(6)质量管理体系认证证书。
(7)产品执行的标准或通过发达国家和地区认证的证书。
(8)商标注册证书。
(9)核心业务采用信息系统支撑相关说明及佐证材料。
(10)近三年内获得的省级(副省级)以上奖励和荣誉证书等(如：专精特新企业认定文件(红头文件、牌匾、通知网页截图等))。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26c67b4a093f10f9d1e875f9fd03d5a/" rel="bookmark">
			js 动态给style标签内添加样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var style = document.createElement('style'); style.type = 'text/css'; style.appendChild(document.createTextNode('.layui-laydate {\n' + 'left: 200px !important;\n' + '}')); var head = document.getElementsByTagName('head')[0]; head.appendChild(style); 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/102/">«</a>
	<span class="pagination__item pagination__item--current">103/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/104/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>