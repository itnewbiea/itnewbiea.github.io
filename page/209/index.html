<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1e17c1164407f3019a4d068194674f/" rel="bookmark">
			vue表格判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 两个判断
&lt;el-table :data="personIdList" style="width: 100%" max-height="350" &gt; &lt;el-table-column prop="sex" label="性别" &gt; &lt;template slot-scope="scope"&gt;{{ scope.row.sex === 1 ? '男' : '女' }}&lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; 两个以上的判断
&lt;template slot-scope="scope"&gt; &lt;span v-if="scope.row.sex == 0" style="color: #F56C6C" &gt;女&lt;/span&gt; &lt;span v-else-if="scope.row.sex == 1" style="color: #67C23A" &gt;男&lt;/span&gt; &lt;span v-else style="color: #E6A23C" &gt;保密&lt;/span&gt; &lt;/template&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8c0b355e60d06af1b9feb9db49f956/" rel="bookmark">
			WebSphere性能调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在了解完WebSphere的基本使用并成功部署项目后，还需要做一步操作，那就是WebSphere性能调优。之所以要进行性能调优是为了在合理的利用服务器资源情况下为我们的应用程序提供最优的运行环境。在进行性能调优之前，我们要明确以下几个概念：
线程池：线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。WAS线程池使服务器组件能够复用线程而不是在运行时创建新线程。创建新线程通常是很耗费时间和资源的操作。 连接池：连接池是创建和管理一个物理连接的缓冲池，其中会保留一定数量创建的物理连接不关闭，当有客户端请求时，调用连接池，可以有效减少物理连接的创建次数，降低直连所带来的系统开销，缓解应用服务器压力，提高程序性能。 最大连接数：指当前连接池中允许创建的最大物理连接数，当到达指定值后，将不允许创建物理连接。和连接超时相对应，当达到最大值后，连接请求将等待，直到池中有空闲连接为止，否则报连接超时错误。 最小连接数：指当前连接池要保留的最小物理连接，其决定未使用超时维护机制的下限，连接池的创建不是根据最小连接数而特意创建，而是根据用户请求而创建，系统会一直维护最小的连接数目。最小连接数使应用服务器保持一定数量的物理连接，利用应用服务器维护机制，合理分配服务器资源。当应用程序访问频繁，但访问人数少的情况下，最小连接数的合理配置，可以将有效的资源进行充分利用，满足特定应用需求 在明确以上几个概念后，我们就可以开始进行性能调优了，在浏览器输入“https://IP:9043/ibm/console/logon.jsp” 访问WebSphere控制台，输入账号密码登录控制台
一、线程池调优 所谓线程池调优也就是Web Container最小、最大并发用户调优。Web Container维护着一个线程池，用来处理接收到的请求，如果这个线程池设置较小（3-5）则会影响应用的性能，如果这个线程池设置过大（200-2000），则会占用服务器资源。那么如何才能设置一个比较合适的线程池大小呢？这就需要我们预估应用上线后的最大用户并发数，然后将最大并发数提供给性能测试人员便于他们编写压测脚本对我们的应用程序进行压测，同时我们利用WebSphere提供的监控工具去获取合理的最小和最大值：
我们依次点击左边菜单项的“监视和调整 -&gt; 性能查看器 -&gt; 当前活动”进入监视工具页面：
勾选中状态为“活动”的服务器，然后点击上面的“启动监视”按钮进行监视该服务器
当看到下图所示的提示时则表示监视启动成功：
点击被监视的服务器进入监视的详情页
依次点击“性能模块 -&gt; 线程池 -&gt; WebContainer”，然后点击上面的“查看模块”按钮进行查看线程池的使用情况
从上图可表明ActiveCount并发活动线程数29。这解释了图中平均只使用 29 个线程处理来自 HTTP 负载驱动程序的 50 个并发客户机连接。根据此提供信息，我们就可以预估出合理的线程池大小了。
在知道合理的线程池大小后，我们就需要对线程池的大小进行调整。依次点击“服务器 -&gt; 所有服务器”，然后点击我们前面监控的服务器名称进入服务器的详情页面：
详情页拉倒最下面，点击“线程池”进入到线程池的配置页面
线程池配置页面拉倒最下面，点击“Web Container”
在下图所示的区域中设置我们预估出的合理的最小最大线程池数量，然后点击“应用”或“确定”按钮进行保存
点击页面中的“保存”按钮，至此，线程池调优就完成了
在参数调整完成后，我们需要去查看一下节点的状态，依次点击“系统管理 -&gt; 节点”，如果发现下图所示的区域中，状态为红色时，就需要勾选“Node01”，然后点击上面的“同步”按钮进行手动，后续的调优也需要在参数调完后查看一下节点，如果显示红色，也需要同步一下节点状态。
二、、数据库连接池调优 每次当应用程序尝试访问后端库时（比如数据库），它都需要资源来创建、维持和释放到该数据库的连接。为了缓解此过程对总体应用程序资源的压力，应用服务器允许我们建立一个后端连接池，用于在应用服务器上共享应用程序。连接池将连接开销分散分布在若干用户请求中，以便保留应用程序资源供未来请求使用。调优连接池的目标是确保各线程都有一个数据库连接，并且请求不需要排队以等待访问数据库。
连接池的大小影响资源占用和性能情况，如连接池过小（1-5），会影响性能处理能力，TPS降低，并发一段时间出现掉用户情况，不能满足现场环境应用高负载压力测试，如连接池过大（600-2000），则会长期占用服务器利用资源，且根据不同场景交易会出现提示错误信息，比如“Could not open JDBC Connection for transaction; nested exception is java.sql.SQLException: JZ006: 捕获到 IO 例外:java.net.SocketException: 打开的文件过多”等一些相关错误信息。那么如何才能设置一个比较合适的连接池大小呢？这也需要我们预估应用上线后的最大用户并发数，然后将最大并发数提供给性能测试人员便于他们编写压测脚本对我们的应用程序进行压测，同时我们利用WebSphere提供的监控工具去获取合理的最小和最大值：
我们依次点击左边菜单项的“监视和调整 -&gt; 性能查看器 -&gt; 当前活动”进入监视工具页面：
勾选中状态为“活动”的服务器，然后点击上面的“启动监视”按钮进行监视该服务器
当看到下图所示的提示时则表示监视启动成功：
点击被监视的服务器进入监视的详情页
依次点击“性能模块 -&gt; JDBC连接池 -&gt; ORACL_JDBC_DRIVER”，然后勾选需要调优的连接名称，最后点击上面的“查看模块”按钮进行查看该连接池的使用情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af8c0b355e60d06af1b9feb9db49f956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c6aed6022d4d7fbbb1be39809e1ffe/" rel="bookmark">
			Docker容器技术之私有仓库搭建与使用（8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Docker Registry2. Docker私有Registry2.1 使用docker-distribution自建Registry2.2 使用官方镜像自建Registry 3. Harbor3.1 Docker compose3.2 部署Harbor3.3 注意事项 1. Docker Registry 网上有很多的Registry服务器都支持第三方用户注册，而后基于用户名去做自己的仓库，但是使用互联网上的Registry有一个缺陷，那就是我们去推送和下载镜像时都不会很快，而在生产环境中很可能并行启动的容器将达到几十、上百个，而且很有可能每个服务器本地是没有镜像的，此时如果通过互联网去下载镜像会有很多问题，比如下载速度会很慢、带宽会用很多等等，如果带宽不够的话，下载至启动这个过程可能要持续个几十分钟，这已然违背了使用容器会更加轻量、快速的初衷和目的。因此，很多时候我们很有可能需要去做自己的私有Registry。
Docker Registry分类：
Sponsor Registry：第三方的Registry，供客户和Docker社区使用Mirror Registry：第三方的Registry，只让客户使用Vendor Registry：由发布docker镜像的供应商提供的registryPrivate Registry：通过设有防火墙和额外的安全层的私有实体提供的registry 事实上，如果运维的系统环境托管在云计算服务上，比如阿里云，那么用阿里云的Registry则是最好的选择。很多时候我们的生产环境不会在本地，而是托管在数据中心机房里，如果我们在数据中心机房里的某台主机上部署Registry，因为都在同一机房，所以属于同一局域网，此时数据传输走内网，效率会极大的提升。
所有的Registry默认情况下都是基于https工作的，这是Docker的基本要求，而我自建Registry时很可能是基于http工作的，但是Docker默认是拒绝使用http提供Registry服务的，除非明确的告诉它，我们就是要用http协议的Registry。
2. Docker私有Registry 为了帮助我们快速创建私有Registry，Docker专门提供了一个名为docker-distribution的软件包，我们可以通过安装这个软件包快速构建私有仓库。
当然，官方也提供了Registry的镜像，我们可以直接将其pull到本地并启动为容器即可快速实现私有Registry。
2.1 使用docker-distribution自建Registry 环境：
角色主机名IPdockernode02192.168.159.161registrynode01192.168.159.145 在node01上安装docker-distribution
[root@node01 ~]# yum -y install docker-distribution [root@node01 ~]# vim /etc/docker-distribution/registry/config.yml ... version: 0.1 log: fields: service: registry storage: cache: layerinfo: inmemory filesystem: rootdirectory: /var/lib/registry //这里可以修改镜像存放目录 http: addr: :5000 ... [root@node01 ~]# systemctl enable --now docker-distribution [root@node01 ~]# ss -antl|grep 5000 LISTEN 0 128 [::]:5000 [::]:* 在node02上使用自建的Registry去上传镜像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c6aed6022d4d7fbbb1be39809e1ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f573e8e5269d292bd61d6decef150185/" rel="bookmark">
			SpringMVC的执行流程以及运行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是MVC？什么是SpringMVC？SpringMVC中的核心组件SpringMVC的执行流程关于DispatcherServlet的配置说明关于SpringMVC的配置文件以及常用部分注解解释 什么是MVC？ MVC 是 Model、View 和 Controller 的缩写，分别代表 Web 应用程序中的 3 种职责，MVC是一种软件设计规范。它将业务逻辑、数据、显示分离的方法来组织代码，降低了视图与业务逻辑之间的双向耦合。
Model(模型)：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。View(视图)：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。Controller(控制器)：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC模式就是JSP+Servlet+JavaBean的模式。
什么是SpringMVC？ SpringMVC是一个基于MVC模式的Web框架，是Spring框架的一个模块 。它以SpringIOC容器为基础，并利用容器的特性来简化它的配置，所以 SpringMVC 和 Spring 可直接整合使用。SpringMVC 对 MVC 流程进行了封装，屏蔽掉很多底层代码，让开发者可以更加轻松快捷的完成基于 MVC 模式的 Web 开发。总的来说：Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 SpringMVC的特点：
轻量级，简单易学高效 , 基于请求响应的MVC框架与Spring兼容性好，无缝结合约定优于配置功能强大：RESTful、数据验证、格式化、本地化、主题等简洁灵活 SpringMVC中的核心组件 （1）前端控制器：DispactherServlet
（2）处理器映射器：HandlerMapping
（3）处理器适配器：HandlerAdapter
（4）处理器：Handler，
（5）视图解析器：ViewResolver
（6）视图：View
组件的介绍
前端控制器：接收请求、响应结果，相当于转发器，它是SpringMVC框架最核心的组件，有了它就能减少其他组件之间的耦合度。（不需要程序员开发）处理器映射器：根据配置的映射规则（根据请求的URL），找到对应的处理器。（不需要程序员开发）处理器适配器：适配调用具体的处理器，并且执行处理器中处理请求的方法，执行完毕之后返回一个ModelAndView对象。处理器：（需要程序员手动开发）。视图解析器：会根据传递过来的ModelAndView对象进行视图解析，根据视图解析名解析称真正的视图View。（不需要程序员开发）视图：View是一个接口，它的实现类支持不同类型的视图。比如：JSP、freemarker、Thymeleaf等等。 SpringMVC的执行流程 （1）当用户通过浏览器发起一个HTTP请求，请求直接到前端控制器DispatcherServlet；
（2）前端控制器接收到请求以后调用处理器映射器HandlerMapping，处理器映射器根据请求的URL找到具体的Handler，并将它返回给前端控制器；
（3）前端控制器调用处理器适配器HandlerAdapter去适配调用Handler；
（4）处理器适配器会根据Handler去调用真正的处理器去处理请求，并且处理对应的业务逻辑；
（5）当处理器处理完业务之后，会返回一个ModelAndView对象给处理器适配器，HandlerAdapter再将该对象返回给前端控制器；这里的Model是返回的数据对象，View是逻辑上的View。
（6）前端控制器DispatcherServlet将返回的ModelAndView对象传给视图解析器ViewResolver进行解析，解析完成之后就会返回一个具体的视图View给前端控制器。（ViewResolver根据逻辑的View查找具体的View）
（7）前端控制器DispatcherServlet将具体的视图进行渲染，渲染完成之后响应给用户（浏览器显示）。
关于DispatcherServlet的配置说明 使用SpringMVC时，第一步就是web.xml中配置DispatcherServlet，DispatcherServlet实际上就是一个Servlet，因此我们可以配置多个DispatcherServlet，它是前端控制器，在web.xml文件中配置时，还需要配置拦截匹配的请求，以及Springmvc的配置文件的加载，还有启动顺序的配置，使得该servlet随着Servlet容器的启动而启动，以下就是关于DispatcherServlet的常规配置：
&lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispactherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置加载Springmvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--配置启动顺序，数字越小启动优先级越高--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispactherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 以上指明了配置文件的文件名，不使用默认配置文件名，而使用springmvc-config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f573e8e5269d292bd61d6decef150185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e57f5fd1a968f3348fe20cfba95502/" rel="bookmark">
			解决JDK1.8 编译时提示 程序包com.sun.image.codec.jpeg不存在的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决JDK1.8 编译时提示 程序包com.sun.image.codec.jpeg不存在的问题 由于jdk1.6以后jre中删除rt.jar，jce.jar，所以会出现以上问题
解决办法：
在pom文件中build -&gt; plugins 中加入以下配置就可以了
&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;bootclasspath&gt;${java.home}\lib\rt.jar${path.separator}${java.home}\lib\jce.jar${path.separator}&lt;/bootclasspath&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; 借鉴：https://www.jianshu.com/p/9f4173e529cd
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e538c5ccff3728182e8bdf2d62348f/" rel="bookmark">
			WebSphere创建概要文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在上一篇博客Websphere8.5.5安装教程中我们已经成功的安装了websphere，那么基础软件都安装完毕后，我们就可以开始创建概要文件了。
一、创建概要文件 进入“/opt/IBM/WebSphere/AppServer/bin/ProfileManagement”目录下，输入“./pmt.sh”命令打开概要文件管理器，然后点击“创建”按钮 选择“单元...”，然后点击“下一步”（这里不选择默认的应用程序服务器是因为默认的“应用程序服务器”只有服务器的功能，没有控制台的功能） 选择“高级概要文件”，然后点击“下一步” 勾选“部署管理控制台”和“部署缺省应用程序”，然后点击“下一步” 这里的选项直接默认即可，点击“下一步” 主机名一定要填写能够ping通本服务器的主机名（本人使用的服务器主机名为“weblogic”），否则后面启动服务时就会失败，其他信息可调整也可不调整，配置完后点击“下一步” 设置一下登录控制台的用户名和密码，然后点击“下一步” 这里默认就行，直接点击“下一步” 这里也默认就行，直接点击“下一步” 端口的分配共三页，也默认就行，都直接点击“下一步” 不要勾选“将 Deployment...”，然后点击“下一步” 不要勾选“创建 Web...”，然后点击“下一步” 直接点击“创建”，然后耐心等待即可 点击“完成”按钮即可（此处勾选了“启动...控制台”，所以在点击“完成”按钮后，WebSphere控制台就开始启动了） 在弹出的界面中选择“安装验证”选项，验证一下创建的概要文件是否成功 看到安装验证完成后即可点击上面弹窗中的“退出”选项了 至此概要文件创建完成，我们可以看到一开始进入的界面中多了两个概要文件，至此可以关闭该界面了 由于前面已经勾选开启控制台，所以此处需要我们将控制台给干掉，这样就不影响后面的操作，快速的方式是使用“ps -ef | grep websphere”命令查看WebSphere的进程，然后通过“kill -9 进程号”命令干掉。安装完毕概要文件之后，一般要将IBM/目录下面的所有文件的所有者从root改为其他账户（本人的其他用户是yinyw），因为我们的服务器很少以root直接启动，所以我们进入到“/opt”目录下，输入“chown -R yinyw:yinyw IBM”命令将“IBM”目录的所有者改为yinyw即可。 二、启动控制台 由root用户切换到其他用户，然后进入到“/opt/IBM/WebSphere/AppServer/profiles/Dmgr01/bin”目录下，然后输入“./startManager.sh”即可启动控制台，耐心等待，如果出现如下图所示内容则表示控制台启动成功： 在浏览器窗口输入“https://服务器ip地址:9043/ibm/console”访问WebSphere控制台 输入前面设置的账号密码即可成功登陆控制台 此时我们分别选择左边菜单的“系统管理 -&gt; Node Agent”和“服务器 -&gt; 所有服务器”可以看到，管控节点和服务器都没有启动 下面我们开始启动节点和服务器 三、启动节点 进入到“/opt/IBM/WebSphere/AppServer/profiles/AppSrv01/bin”目录下，输入“./startNode.sh”命令开始启动节点，耐心等待，如果出现如下图所示内容则表示节点启动成功： 此时我们进入控制台的“系统管理 -&gt; Node Agent”下查看节点的状态即可看到启动成功的标志 四、启动服务 在启动节点的目录下输入“./startServer.sh server1”命令开始启动服务，耐心等待，如果出现如下图所示内容则表示服务启动成功 此时我们进入控制台的“服务器 -&gt; 所有服务器”下查看服务的状态即可看到启动成功的标志 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3254677a7917c6c01f55212f86c57fbf/" rel="bookmark">
			Dockerfile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. 常用指令2.1 FROM2.2 MAINTAINER2.3 RUN2.4 CMD2.5 EXPOSE2.6 ENV2.7 ADD2.8 COPY2.9 ENTRYPOINT2.10 VOLUME2.11 USER2.12 WORKDIR2.13 ONBUILD 3. 创建镜像4. 案例：构建nginx镜像 1. 概述 Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。
在Docker中创建镜像最常用的方式，就是使用Dockerfile。Dockerfile是一个Docker镜像的描述文件。Dockerfile其内部包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。
Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。
Docker分为四部分：
基础镜像信息维护者信息镜像操作指令容器启动时默认要执行的指令 例：
#基于centos镜像 FROM centos #维护人的信息 MAINTAINER The CentOS Project &lt;303323496@qq.com&gt; #安装httpd软件包 RUN yum -y update RUN yum -y install httpd #开启80端口 EXPOSE 80 #复制网站首页文件至镜像中web站点下 ADD index.html /var/www/html/index.html #复制该脚本至镜像中，并修改其权限 ADD run.sh /run.sh RUN chmod 775 /run.sh #当启动容器时执行的脚本文件 CMD ["/run.sh"] 一开始必须指明所基于的镜像名称，接下来一般会说明维护者信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3254677a7917c6c01f55212f86c57fbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2e45e162828badf4b12c5612283c21/" rel="bookmark">
			js遍历数组三种方式对比利弊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js遍历数组有几种方式:for，forEach(es5),for of (es6)
for循环略显臃肿；
forEach不臃肿，但是，不能用break中断，也不能用return语句跳出去;
for of 弥补forEach的不足，还可以
遍历字符串；
遍历类数组；
支持Map,Set对象的遍历
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916667612387a0169ab561e66b6387af/" rel="bookmark">
			React note9（脚手架：性能优化&amp;react脚手架端口&amp;项目如何启动&amp;避开eslint语法检查）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能优化 勾选变色
我们先用传统写法来完成勾选变色的功能，会使用到父子组件间的正传、逆传。
在判 " 勾选的是谁 " 时，思路是这样的：先是父组件正传一个函数给子组件，子组件将同时传过来的数组里某个对象的index绑定给父组件传过来的函数，然后在父组件的函数体里面通过子组件反传的变量index判断当前需要改变的元素是数组里面的哪个元素，然后改变该元素的style值。
当然，真正的dom元素样式改变是在子组件里面，通过判断父组件正传过来的style的值为true就变色，为false就不变色。
&gt;&gt;Check1.jsx --- 父 import React, { Component } from 'react' import Check2 from "./check2.jsx" export default class check2 extends Component { constructor(props){ super(props) this.state={ arr:[ {name:"路飞",style:false}, {name:"呢子扣",style:false}, {name:"炭治郎",style:false}, ] } } fun=(num)=&gt;{ //console.log(num);//找到勾选的是谁 let newarr=this.state.arr; newarr[num].style=!newarr[num].style; this.setState({ arr:newarr }) } list=()=&gt;{ // 不在render里写，避免污染 return this.state.arr.map((item,index)=&gt;{ return( &lt;Check2 key={index} name={item.name} style={item.style} num={index} listfun={this.fun} /&gt; ) }) } render() { return ( &lt;div&gt; &lt;h4&gt;I' check1 as a father.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916667612387a0169ab561e66b6387af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68408ed8c7fbe8d4c7a22f1387f66d3c/" rel="bookmark">
			214. 最短回文串20200831
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目描述解法1 遍历填充字符(太慢）代码复杂度分析结果 解法2 字符串哈希代码复杂度分析结果 解法3 KMP字符串匹配KMP算法代码复杂度分析 思路代码复杂度分析结果 题目描述 214. 最短回文串
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
示例 1:
输入: “aacecaaa”
输出: “aaacecaaa”
示例 2:
输入: “abcd”
输出: “dcbabcd”
解法1 遍历填充字符(太慢） 将字符串末尾的值依次添加到字符串开头，每次添加后判断是否为回文，如果是则结束，不是则继续添加。
例如：
输入为：’" aacecaaa \text{aacecaaa} aacecaaa“时，取倒数第一个字母a添加到开头，得到“ a \color{#FF3030}{\text{a}} a aacecaaa \text{aacecaaa} aacecaaa”，该字符串为回文，结束并返回该字符串“ a \color{#FF3030}{\text{a}} a aacecaaa \text{aacecaaa} aacecaaa"。输入为 “ abcd \text{abcd} abcd”,操作依次为：
“ d \color{#FF3030}{\text{d}} d abcd \text{abcd} abcd"，不是回文，继续；
“ dc \color{#FF3030}{\text{dc}} dc abcd \text{abcd} abcd"，不是回文，继续；
“ dcb \color{#FF3030}{\text{dcb}} dcb abcd \text{abcd} abcd"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68408ed8c7fbe8d4c7a22f1387f66d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b061ce9c02645201db235f48fe0759b/" rel="bookmark">
			cas5.x实现将ticket维护到redis集群（不使用官方提供的哨兵模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载至： http://zhfeat.cc/article/45
2020博客地址汇总
2019年博客汇总
前段时间基于CAS 5.2.6为公司二次开发了一套SSO单点登陆系统，整体来说比较顺利，不过最后卡在了将CAS服务端登陆所产生的ticket放到redis集群中这一环节。现在网上相关资料最多的是基于CAS 4.x版本的文章，对于CAS 5.x版本相关的资料还是比较少的，因此没有找到具体的解决同学，纠结了许久最后通过覆盖官方提供的jar包中的类解决了这个问题，希望能帮助到同样遇到这个问题的童鞋。该问题可能会有更优雅的解决方式，如果大家有更好的解决思路希望能分享给我，大家一同进步。
什么是CAS 这段是对CAS原理的一个剖析和总结，已经很清楚的同学可以略过。
SSO单点登录访问流程主要有以下步骤 访问服务：SSO客户端发送请求访问应用系统提供的服务资源。定向认证：SSO客户端会重定向用户请求到SSO服务器。用户认证：用户身份认证。发放票据：SSO服务器会产生一个随机的Service Ticket。验证票据：SSO服务器验证票据Service Ticket的合法性，验证通过后，允许客户端访问服务。传输用户信息：SSO服务器验证票据通过后，传输用户认证结果信息给客户端。 CAS 原理和协议 从结构上看，CAS 包含两个部分： CAS Server 和 CAS Client。CAS Server 需要独立部署，主要负责对用户的认证工作；CAS Client 负责处理对客户端受保护资源的访问请求，需要登录时，重定向到 CAS Server。如图是 CAS 最基本的协议过程：
CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。对于访问受保护资源的每个 Web 请求，CAS Client 会分析该请求的 Http 请求中是否包含 Service Ticket，如果没有，则说明当前用户尚未登录，于是将请求重定向到指定好的 CAS Server 登录地址，并传递 Service （也就是要访问的目的资源地址），以便登录成功过后转回该地址。
用户在第3步中输入认证信息，如果登录成功，CAS Server 随机产生一个相当长度、唯一、不可伪造的 Service Ticket，并缓存以待将来验证，之后系统自动重定向到 Service 所在地址，并为客户端浏览器设置一个 Ticket Granted Cookie（TGC），CAS Client 在拿到 Service 和新产生的 Ticket 过后，在第 5，6 步中与 CAS Server 进行身份核对，以确保 Service Ticket 的合法性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b061ce9c02645201db235f48fe0759b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180f8f100e13672e6cb9f34784197fda/" rel="bookmark">
			Docker容器技术之存储卷（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. COW机制2. 存储卷3. 存储卷的作用4. 存储卷的优缺点5. 存储卷管理方式6. 存储卷的分类7. 容器数据管理7.1 在容器中使用数据卷7.2 数据卷容器7.3 利用数据卷容器迁移数据 1. COW机制 Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。
如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本依然存在，只是已经被读写层中该文件的副本所隐藏，这就是“写时复制(COW)”机制。
对于这种方式来说，我们去访问一个文件，修改和删除等一类的操作，其效率会非常的低，因为隔着很多层镜像。
而要想绕过这种限制，我们可以通过使用存储卷的机制来实现。
2. 存储卷 存储卷就是将宿主机的本地文件系统中存在的某个目录直接与容器内部的文件系统上的某一目录建立绑定关系。这就意味着，当我们在容器中的这个目录下写入数据时，容器会将其内容直接写入到宿主机上与此容器建立了绑定关系的目录。
在宿主机上的这个与容器形成绑定关系的目录被称作存储卷。
3. 存储卷的作用 如果容器中跑的进程的所有有效数据都保存在存储卷中，从而脱离容器自身文件系统之后，带来的好处是当容器关闭甚至被删除时，只要不删除与此容器绑定的在宿主机上的这个存储目录，我们就不用担心数据丢失了。因此就可以实现数据持久，脱离容器的生命周期而持久。
我们通过这种方式管理容器，容器就可以脱离主机的限制，可以在任意一台部署了docker的主机上跑容器，而其数据则可以置于一个共享存储文件系统上，比如nfs。
Docker的存储卷默认情况下是使用其所在的宿主机上的本地文件系统目录的，也就是说宿主机上有一块属于自己的硬盘，这个硬盘并没有共享给其他的Docker主机，而在这台主机上启动的容器所使用的存储卷是关联到此宿主机硬盘上的某个目录之上。
这就意味着容器在这台主机上停止运行或者被删除了再重建，只要关联到硬盘上的这个目录下，那么其数据还存在。但如果在另一台主机上启动一个新容器，那么数据就没了。而如果在创建容器的时候我们手动的将容器的数据挂载到一台nfs服务器上，那么这个问题就不再是问题了。
4. 存储卷的优缺点 关闭并重启容器，其数据不受影响，但删除Docker容器，则其更改将会全部丢失。
因此Docker存在的问题有：
存储于联合挂载文件系统中，不易于宿主机访问
容器间数据共享不便
删除容器其数据会丢失
而要解决这些问题，解决方案就是使用存储卷。
5. 存储卷管理方式 存储卷（Data Volume）于容器初始化时被自动创建，由base image提供的卷中的数据会于此期间完成复制。
Volume的初衷是独立于容器的生命周期实现数据持久化，因此删除容器之时既不会删除卷，也不会对未被引用的卷做垃圾回收操作。
存储卷为Docker提供了独立于容器的数据管理机制，我们可以把镜像想象成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”。所以镜像可以重用，而卷则可以共享。
卷实现了“程序(镜像)”和“数据(卷)”的分离，以及“程序(镜像)”和“制作镜像的主机”的分离，用户制作镜像时无须再考虑镜像运行的容器所在的主机的环境。
6. 存储卷的分类 Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同：
Bind mount volume a volume that points to a user-specified location on the host file system Docker-managed volume the Docker daemon creates managed volumes in a portion of the host’s file system that’s owned bye Docker 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180f8f100e13672e6cb9f34784197fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450473b289e0a8d7cb448996c7784489/" rel="bookmark">
			关于《Java开发手册（嵩山版）》中：判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是size()==0的方式的疑惑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该规则如下：
【强制】判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是size()==0的方式。 说明：在某些集合中，前者的时间复杂度为O(1)，而且可读性更好。 正例： Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); if(map.isEmpty()) { System.out.println("no element in this map."); } 有哪些集合的size() == 0时间复杂度不是o(1)，百度不到，结果谷歌一下就找到了，ConcurrentLinkedQueue.java这个集合的size()时间复杂度就不是o(1)。解释见以下博客：
https://blog.caoyu.info/is-empty-size-in-java.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99cb9f530d5b28821f1b87d99e902d15/" rel="bookmark">
			Docker容器技术之常用操作（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 容器的常用操作1 查看容器的主机名2 在容器启动时注入主机名3 手动指定容器要使用的DNS4 手动往/etc/hosts文件中注入主机名到IP地址的映射5 开放容器端口6 自定义docker0桥的网络属性信息 7. docker创建自定义桥 容器的常用操作 1 查看容器的主机名 [root@node02 ~]# docker run -it --rm busybox / # hostname 10f87984f514 2 在容器启动时注入主机名 [root@node02 ~]# docker run -it --rm --hostname dragonyear busybox / # hostname dragonyear / # cat /etc/hosts 127.0.0.1	localhost ::1	localhost ip6-localhost ip6-loopback fe00::0	ip6-localnet ff00::0	ip6-mcastprefix ff02::1	ip6-allnodes ff02::2	ip6-allrouters 172.17.0.6	dragonyear / # cat /etc/resolv.conf # Generated by NetworkManager search localdomain nameserver 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99cb9f530d5b28821f1b87d99e902d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7331baac42847cee3c8c0be143df723e/" rel="bookmark">
			Putty &#43; Xming实现远程登陆Linux显示图形化界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Putty和Xming的简介 一般我们远程登录linux 服务器，都是使用非加密的 telnet 或者加密的 ssh。这些登录方式有一个特点：只能登录字符界面，不能运行那些带有GUI界面的程序。有时候为了学习或者工作的需要，我们需要远程打开有图形化界面的 linux application。putty：是一个用来远程登录 unix/linux 服务器的客户端，可以使用Telnet ssh等协议。Xming：是一个基于 c/s 架构的图形显示的x11 server，运行在你用来登录远程服务器的本地机器上。Xming 显示的原理是每一个运行在远端服务器的图形化application 都是一个client，把要显示的图形数据通过 ssh发送给 运行在本地的 Xming server，然后由Xming server 负责显示。所以，从图形显示的角度来说，xming就是server。 二、Putty和Xming的下载和安装 Putty的下载安装和使用方法可以参数本人的这篇博客：https://blog.csdn.net/Yinyaowei/article/details/108304485Xming下载地址：https://pan.baidu.com/s/11DO-1sYg4HGzUqt3Kf3QTg 提取码：ns3oPutty和Xming的安装都是一直点击next即可 三、实现远程登录Linux显示图形化界面步骤 打开Xming安装路径，找到“XLaunch.exe”文件，并双击它，按照下图所示步骤执行即可 点击完成后，查看如下位置是否显示了Xming的图标，如果显示就表明运行成功 打开putty，输入IP地址，使用SSH的默认端口，不用修改（不要点Open按钮或者按回车键，因为还没配置完） 点击Putty界面左边的data，然后在右边输入登录远程服务器的用户名 点击左边的SSH，然后点击展开后的X11，勾选如下图所示位置，并输入“localhost:0” 最后点击左边的Session，点击“save”按钮，最后点击“open”按钮即可 登录成功后输入“gedit”命令验证一下是否能打开图形化界面。打开会比较慢一点，耐心等待下 如果最终弹出如下界面则表明Xming显示图形化界面成功 原文地址：https://www.cnblogs.com/fangjb/p/12668546.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc3f230c90969f7bcc53d4ac80fe5b6/" rel="bookmark">
			Docker存储卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. COW机制2. 存储卷2.1 存储卷的作用2.2 存储卷的原理2.3 存储卷的分类 3. 容器数据管理3.1 使用数据卷3.2 数据卷容器3.3 利用数据卷容器迁移数据 1. COW机制 COW技术原理（Copy On Write，写时复制）
针对随时变化的数据进行备份 Ø 直接映射原始盘的数据内容
Ø 当原始盘的旧数据有修改时，在修改之前自动将旧数据存入前端盘
Ø 对前端盘的修改不回写到原始盘
Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层。
如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本依然存在，只是已经被读写层中该文件的副本所隐藏，这就是“写时复制(COW)”机制。
对于这种方式来说，我们去访问一个文件，修改和删除等一类的操作，其效率会非常的低，因为隔着很多层镜像。
而要想绕过这种限制，我们可以通过使用存储卷的机制来实现。
2. 存储卷 “卷”是容器上的一个或多个“目录”，此类目录可绕过联合文件系统，与宿主机上的某个目录“绑定（关联）”；
类似于挂载一样，宿主机的/data/web目录与容器中的/container/data/web目录绑定关系，然后容器中的进程向这个目录中写数据时，是直接写在宿主机的目录上的，绕过容器文件系统与宿主机的文件系统建立关联关系，使得可以在宿主机和容器内共享数据库内容，让容器直接访问宿主机中的内容，也可以宿主机向容器供集内容，两者是同步的。
mount名称空间本来是隔离的，可以让两个本来是隔离的文件系统，在某个子路径上建立一定程度的绑定关系，从而使得在两个容器之间的文件系统的某个子路径上不再是隔离的，实现一定程度上共享的效果。
在宿主机上的这个与容器形成绑定关系的目录被称作存储卷。
2.1 存储卷的作用 优点是容器中进程所生成的数据，都保存在存储卷上，从而脱离容器文件系统自身后，当容器被关闭甚至被删除时，都不用担心数据被丢失，实现数据可以脱离容器生命周期而持久，当再次重建容器时，如果可以让它使用到或者关联到同一个存储卷上时，再创建容器，虽然不是之前的容器，但是数据还是那个数据，特别类似于进程的运行逻辑，进程本身不保存任何的数据，数据都在进程之外的文件系统上，或者是专业的存储服务之上，所以进程每次停止，只是保存程序文件，对于容器也是一样；容器就是一个有生命周期的动态对象来使用，容器关闭就是容器删除的时候，但是它底层的镜像文件还是存在的，可以基于镜像再重新启动容器。
但是容器有一个问题，一般与进程的启动不太一样，就是容器启动时选项比较多，如果下次再启动时，很容器会忘记它启动时的选项，所以最好有一个文件来保存容器的启动，这就是容器编排工具的作用。一般情况下，是使用命令来启动操作docker,但是可以通过文件来读，也就读文件来启动，读所需要的存储卷等，但是它也只是操作一个容器，这也是需要专业的容器编排工具的原因。
另一个优势就是容器就可以不置于启动在那台主机之上了，如几台主机后面挂载一个NFS，在各自主机上创建容器，而容器上通过关联到宿主机的某个目录上，而这个目录也是NFS所挂载的目录中，这样容器如果停止或者是删除都可以不限制于只能在原先的宿主机上启动才可以，可以实现全集群范围内调试容器的使用，当再分配存储、计算资源时，就不会再局限于单机之上，可以在集群范围内建立起来，基本各种docker的编排工具都能实现此功能，但是后面严重依赖于共享存储的使用。
2.2 存储卷的原理 volume于容器初始化之时会创建，由base image提供的卷中的数据会于此期间完成复制
volume的初意是独立于容器的生命周期实现数据持久化，因此删除容器之时既不会删除卷，也不会对哪怕未被引用的卷做垃圾回收操作
卷为docker提供了独立于容器的数据管理机制
可以把“镜像”想像成静态文件，例如“程序”，把卷类比为动态内容，例如“数据”，于是，镜像可以重用，而卷可以共享卷实现了“程序(镜像)"和”数据(卷)“分离，以及”程序(镜像)“和"制作镜像的主机”分离，用记制作镜像时无须考虑镜像运行在容器所在的主机的环境 2.3 存储卷的分类 Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上位置有所不同;
Bind mount volume（绑定挂载卷）：
在宿主机上的路径要人工的指定一个特定的路径，在容器中也需要指定一个特定的路径，两个已知的路径建立关联关系
语法：
docker run -it --name CONTAINER_NAME -v HOSTDIR:VOLUMEDIR IMAGE_NAME Docker-managed volume（docker管理卷）：
只需要在容器内指定容器的挂载点是什么，而被绑定宿主机下的那个目录，是由容器引擎daemon自行创建一个空的目录，或者使用一个已经存在的目录，与存储卷建立存储关系，这种方式极大解脱用户在使用卷时的耦合关系，缺陷是用户无法指定那些使用目录，临时存储比较适合
语法：
docker run -it --name CONTAINER_NAME -v VOLUMEDIR IMAGE_NAME 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc3f230c90969f7bcc53d4ac80fe5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843448877a46d8e03b4b980075b95f04/" rel="bookmark">
			matlab——修改图中字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在画图的时候，我们可以使用xlabel命名x轴的名字，使用ylabel命名y轴的名字，使用legend命名变量的名字，使用title命名图片的标题。但标题的字体，大小都是默认的。其实那些都是可以调整的，这篇文章就介绍下，如何修改图中的字体。包括字体大小，字体颜色，字体种类。
上面标记的四种函数，默认第一个参数就是要显示的内容。其实后面还有很多变量可以自己设置，如下所示：
FontSize %字体大小 FontName %字体种类 FontWeight %字体是否加粗 Color %字体颜色 使用方法很简单，就像下面把每一个变量后面写上你想要的即可：
%由于xlabel，ylabel,legend,title使用方法一样。就以xlabel为例 xlabel('经度','FontSize',14） xlabel('经度','FontWeight','bold') xlabel('经度','FontName','黑体') xlabel('经度'，'Color','r'）; 同样，也可以把它们结合在一起。使之同时具有多种特性，如下：
%保证第一个是要表示的内容，后面的顺序无所谓的 xlabel('经度','FontSize',14,'FontWeight','bold','FontName','黑体','Color','r'); 前面说了使用方法，下面更为详细的说说每一个的特点：
FontSize: fontsize负责调整字体的大小，后面只要是正整数就可以。（想大就大，想小就小）。
FontWeight: fontweight控制是否需要对字体进行加粗，默认情况下是不加粗。当需要加粗的时候，设置其后面参数为** bold **即可
FontName: 对于字体的种类，matlab中是有一个默认字体。不过不是特别好看，matlab支持几种字体类型，目前我已经证实的包括：黑体，楷体，宋体，简雅黑四种。可能其他的还有，但我并未尝试。调用方式如下：
xlabel('经度','FontName','黑体') xlabel('经度','FontName','楷体') xlabel('经度','FontName','宋体') xlabel('经度','FontName','简雅黑') 对于英文和数字，默认的形式不好看。可以使用新罗马字体，调用方式如下：
xlabel('hello','FontName','Times New Roman') 注意：新罗马字体只适用于数字和英文，对中文不起作用的。
最后插句没有用的：其实对于xlabel的调用方式还有一种：
%基本格式是\变量{种类}...内容 xlabel('\fontname{黑体}\fontsize{15}精度'); 但我总是感觉这个方式不容易理解，就不学了吧，毕竟一个就够了。
最后看看成品图：
成品图代码附上：
scatter(x,y,[],[0,0,0.80392],'*') grid on xlabel('经度','FontSize',14,'FontWeight','bold','FontName','黑体'); ylabel('纬度','FontSize',14,'FontWeight','bold','FontName','黑体'); legend('\fontname{黑体}\fontsize{13}会员位置'); title('会员位置坐标图','FontSize',20,'FontName','宋体') 因作者水平有限，如有不足之处，请下方评论区指出，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162d9c3e86a140a633f317e38381e020/" rel="bookmark">
			js中if判断indexOf可能导致的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let str = 'abcdeee';//无l let a = 1; if(a == 2){ console.log('one'); }else if(str.indexOf('l')){ console.log('two'); }else if(a == 1){ console.log('three'); } //结果为two 在上边的例子中即便是indexOf(‘l’)本身在str里不存在也会返回true，这里涉及到两点，一是if，在js中，数字0为false，而非0的数字会被当做true。二是indexOf的返回值的问题，indexOf如果存在会返回字符第一次出现的位置0,1,2,3…，而indexOf如果不存在会返回-1，非0。
所以这两者相结合就会出现一些意外的结果，理论上indexOf查找不存在，if应该判断为false从而进入下一个if分支，结果因为indexOf返回的是-1会被if判定为true导致错误。也就是说无论indexOf是否能查找到都会返回true，除了第一个字符，indexOf会返回0从而被if判断为false。
let str = 'abcdeee'; let a = 1; if(a == 2){ console.log('one'); //z不存在indexOf返回-1，而if语句非0为true }else if(str.indexOf('z')){ console.log('two'); }else if(a == 1){ console.log('three'); } //结果为two let str = 'abcdeee'; let a = 1; if(a == 2){ console.log('one'); //因为a存在并且它是字符串第一个字符，indexOf返回0，而if语句0为false }else if(str.indexOf('a')){ console.log('two'); }else if(a == 1){ console.log('three'); } //结果为three 找到问题所在解决就好办了，给indexOf做一些判断就好了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/162d9c3e86a140a633f317e38381e020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82c211ae11e497aa5f158a837a0c404/" rel="bookmark">
			Docker容器技术之网络配置（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Linux内核实现名称空间的创建1.1 ip netns命令1.2 创建Network Namespace1.3 操作Network Namespace1.4 转移设备1.5 veth pair1.6 创建veth pair1.7 实现Network Namespace间通信1.8 veth设备重命名 1. Linux内核实现名称空间的创建 1.1 ip netns命令 可以借助ip netns命令来完成对 Network Namespace 的各种操作。ip netns命令来自于iproute安装包，一般系统会默认安装，如果没有的话，请自行安装。
注意：ip netns命令修改网络配置时需要 sudo 权限。
可以通过ip netns命令完成对Network Namespace 的相关操作，可以通过ip netns help查看命令帮助信息：
[root@node02 ~]# ip netns help Usage: ip netns list ip netns add NAME ip netns set NAME NETNSID ip [-all] netns delete [NAME] ip netns identify [PID] ip netns pids NAME ip [-all] netns exec [NAME] cmd .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82c211ae11e497aa5f158a837a0c404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068b3a6678ab93f00c43367c0c1b43e6/" rel="bookmark">
			vue element 树形图回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="roleList"&gt;
&lt;el-tree
ref="tree"
:data="accessList"
show-checkbox
node-key="menuKey"
highlight-current
:props="defaultProps"
:default-expanded-keys="checkedOpen" //回显展开数组
:default-checked-keys="checkedId" //回显数组
@check-change="handleCheckChange"
&gt;
&lt;!-- :default-expand-all="true" --&gt;
&lt;/el-tree&gt;
data里面
checkedId: [],
checkedOpen: [],
accessList ：[]
methods: {
递归树
funTree(listTree) {
listTree.forEach(item =&gt; {
if (item.isChecked) {
this.checkedId.push(item.menuKey)
this.checkedOpen.push(item.menuKey)
}
if (item.children &amp;&amp; item.children.length) {
this.funTree(item.children)
}
})
},
初始化调用
query() {
this.$http.get(`${api.GetRoleMenus}?roleId=${this.id}`).then(res =&gt; {
if (res.code === 200) {
this.accessList = res.data
this.funTree(this.accessList)
}
})
},
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d270fe029a94280c7c472435f511a7/" rel="bookmark">
			python3 进阶---多线程和锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先了解几个概念
（1）并发：多个任务同时进行，但是同一时刻只能处理一个任务，只有一个处理器，是逻辑意义上的同时发生
（2）并行：多个任务同时进行，而且在同一时刻是同时在执行的，有多个处理器，是物理意义上的同时发生
（3）进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位
（4）线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位
（5）一个进程至少包括一个线程
2.线程的创建与调用
# -*-coding:utf-8 -*- import threading import time start_time = time.time() def foo(name): start = time.time() print("hello %s" % name) time.sleep(2) end = time.time() cost_time = end - start print(cost_time) # 创建线程 # target参数指向要执行的函数名 # args参数指向要执行的函数的参数，元组或者列表都可以 threading1 = threading.Thread(target=foo, args=("小明",)) threading2 = threading.Thread(target=foo, args=("小红",)) # 启动线程 threading1.start() threading2.start() # 堵塞主线程：线程.join()，直到当前线程运行结束才会继续运行主线程 # threading1运行完才会继续执行主线程 threading1.join() # threading1运行完才会继续执行主线程 threading2.join() end_time = time.time() print("total time:", end_time - start_time) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6d270fe029a94280c7c472435f511a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daf0828e7eaf5a56e41db81f49191b01/" rel="bookmark">
			Liunx（一）VMware虚拟机安装学习--Liunx学习的准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机安装 初衷：一：安装前的准备二：虚拟机硬件配置2.1 打开VMware，选择“创建新的虚拟机”；2.2典型安装与自定义安装2.3 虚拟机兼容性选择2.4.选择稍后安装操作系统2.5操作系统的选择2.6 虚拟机位置与命名2.7 处理器与内存的分配2.8网络连接类型的选择，网络连接类型一共有桥接、NAT、仅主机和不联网四种。2.9其余两项按虚拟机默认选项即可2.10磁盘容量2.11.磁盘名称，默认即可2.12取消不需要的硬件2.13点击完成，已经创建好虚拟机。 三：安装CentOS镜像文件3.1.右击刚创建的虚拟机，选择设置3.2.先选择CD/DVD，再选择使用ISO映像文件3.3.开启虚拟机3.4安装操作系统 四：解决NAT模式没网的情况4.1NAT模式网络配置4.2.查看VMware虚拟网络编辑器的NAT模式设置 五：虚拟机克隆5.1克隆操作5.2修改配置 六：分享一个Linux课程 初衷： 写这篇文章的主要目的是为了以后自己再去安装虚拟机时能有有个参照，其实自己在本地有文件存储了该流程配置，但是要一直备份存储，现在想要放到网上，一来只要有网就能查看，方便学习；二来也能帮助和我一样的小伙伴（其实网上该类似的文章不少，比我写的全的、好的也不计其数，自己选择适合自己的即可）。
一：安装前的准备 Windows安装VMware【此处安装的是VMware® Workstation 14 Pro】下载你要安装CentOS对应版本的镜像【此处使用的是CentOS-7-x86_64-DVD-1810.iso】 二：虚拟机硬件配置 2.1 打开VMware，选择“创建新的虚拟机”； 2.2典型安装与自定义安装 典型安装：VMwear会将主流的配置应用在虚拟机的操作系统上，对于新手来很友好。自定义安装：自定义安装可以针对性的把一些资源加强，把不需要的资源移除。避免资源的浪费。 这里我选择自定义安装。
2.3 虚拟机兼容性选择 这里要注意兼容性，如果是VMwear12创建的虚拟机复制到VM11、10或者更低的版本会出现一不兼容的现象。如果是用VMwear10创建的虚拟机在VMwear12中打开则不会出现兼容性问题。
2.4.选择稍后安装操作系统 2.5操作系统的选择 这里选择之后安装的操作系统，正确的选择会让vm tools更好的兼容。这里选择linux下的CentOS
2.6 虚拟机位置与命名 虚拟机名称就是一个名字，在虚拟机多的时候方便自己找到。
VMwear的默认位置是在C盘下，我这里改成F盘。
2.7 处理器与内存的分配 处理器分配要根据自己的实际需求来分配。在使用过程中CPU不够的话是可以再增加的。这次只做安装CentOS演示，所以处理器与核心都选1.内存也是要根据实际的需求分配。
2.8网络连接类型的选择，网络连接类型一共有桥接、NAT、仅主机和不联网四种。 桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。仅主机：虚拟机与宿主机直接连起来不联网
桥接与NAT模式访问互联网过程，如下图所示：桥接与NAT区别
这里选择NAT模式
2.9其余两项按虚拟机默认选项即可 2.10磁盘容量 磁盘容量暂时分配30G即可后期可以随时增加，不要勾选立即分配所有磁盘，否则虚拟机会将30G直接分配给CentOS，会导致宿主机所剩硬盘容量减少。
勾选将虚拟磁盘拆分成多个文件，这样可以使虚拟机方便用储存设备拷贝复制
2.11.磁盘名称，默认即可 2.12取消不需要的硬件 点击自定义硬件
选择声卡、打印机等不需要的硬件然后移除。
2.13点击完成，已经创建好虚拟机。 三：安装CentOS镜像文件 3.1.右击刚创建的虚拟机，选择设置 3.2.先选择CD/DVD，再选择使用ISO映像文件 最后选择浏览找到下载好的镜像文件。启动时连接一定要勾选上后确定。
3.3.开启虚拟机 3.4安装操作系统 开启虚拟机后会出现以下界面
1.Install CentOS 7 安装CentOS 72.Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 73.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daf0828e7eaf5a56e41db81f49191b01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3d4103e4125377c2afb47cf7afedac/" rel="bookmark">
			JDK1.6 解决Could not generate DH keypair
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 早期版本是只支持 1024 位的 DH Parma，如果对方是2048位或以上的情况，会报Could not generate DH keypair的异常。
JDK1.6的解决办法如下：
1.下载bcprov-ext-jdk15on和bcprov-jdk15on的包到$JAVA_HOME/jre/lib/ext 下，版本的话1.50-1.59应该都可以
如：bcprov-ext-jdk15on-1.52.jar和bcprov-jdk15on-1.52.jar
2.包替换之后，修改$JAVA_HOME/jre/lib/security/java.security文件
在security.provider.X后面新增一行，例如：
本来最后是security.provider.8，新增一行security.provider.9=org.bouncycastle.jce.provider.BouncyCastleProvider
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b67eb3d7109554327ca1b48cb2dd350/" rel="bookmark">
			Zookeeper占坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等待更新中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33967b4ad495e66a75f7b702d079915/" rel="bookmark">
			httpServletRequest.getParameter 参数中存在“&amp;”导致获取不到完整参数的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录最近遇到的坑。
起因 账管有个信用卡绑定接口，我的调用的时候需要传号码、地址等信息，使用的是 HttpURLConnection，发送的时候将参数转为key=value&amp;key=value 的形式，账管那边使用 httpServletRequest.getParameter() 进行获取参数。
问题就是当某些地址中存在 &amp; 符号的时候，因为账管获取参数的时候是通过 &amp; 符号进行截取的，就会导致他们获取参数不全。
如：a=123&amp;b=park&amp;center
本来 b 的 value 应该是 park&amp;center，现在他们那边只能获取到 park，这就导致两边参数不一样，签名也不一样，然后验签失败。
解决方案 以上就是事情的起因，期初我的建议是他们那边能不能换成 json 格式的接收，我们这边直接发送 json 格式的数据，这样应该不会有问题，但是他们死活不愿意改。
后续方案是我们将参数中的 &amp; 进行 URL 编码，将其转化为 %26。
我们实现的方法大概如下：
public String pay(String url, Map&lt;String, String&gt; params) { URL u = null; HttpURLConnection con = null; // 构建请求参数 StringBuffer sb = new StringBuffer(); String strResult = null; if (params != null) { for (Entry&lt;String, String&gt; e : params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33967b4ad495e66a75f7b702d079915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37adb8c9d4bace177701ef6aaad12e3/" rel="bookmark">
			买卖股票最佳时期系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码已在 leetcode 上验证通过。
通解方式，学习：https://leetcode-cn.com/circle/article/qiAgHn/
T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i])
121.买卖股票的最佳时机
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。
class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() &lt;= 0) return 0; int profit0=0, profit1=-prices[0]; for (int i = 1; i &lt; prices.size(); i++) { profit0 = max(profit0, profit1+prices[i]); profit1 = max(profit1, -prices[i]); } return profit0; } }; 122.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f37adb8c9d4bace177701ef6aaad12e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ba066fd2c6b9efa773f1e00bdf7360/" rel="bookmark">
			Android禁止安装三方应用(屏蔽所有安装应用的方式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android系统安装应用有四种方式
1.系统应用安装――开机时完成，没有安装界面
2.网络下载应用安装――通过market应用完成，没有安装界面
3.ADB工具安装――没有安装界面。
4.第三方应用安装――通过现有的APK文件安装，有安装界面，由packageinstaller.apk应用处理安装及卸载过程的界面。
1.禁止ADB和应用商店安装由“frameworks\base\services\core\java\com\android\server\pm\PackageManagerService.java”来控制安装
需要屏蔽的话，只需要修改这个文件里边的代码。
//禁止第三方应用安装的标志 private boolean APK_INSTALL_FINISH = SystemProperties.getBoolean("persist.sys.horion.apk.install", false); class PackageHandler extends Handler{ ....... void doHandleMessage(Message msg) { switch (msg.what) { case INIT_COPY: { ++++ if(APK_INSTALL_FINISH){ ++++ return ; ++++ } HandlerParams params = (HandlerParams) msg.obj; int idx = mPendingInstalls.size(); if (DEBUG_INSTALL) Slog.i(TAG, "init_copy idx=" + idx + ": " + params); ........ } } } } public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ba066fd2c6b9efa773f1e00bdf7360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c822f003d0d3341de22f0474d8cc5c5d/" rel="bookmark">
			LaTeX：xcolor颜色介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：xcolor默认颜色只有19种，使用时可以在option中加入另外3张颜色表来极大扩充颜色库。
宏包：\usepackage{xcolor}
选项：dvipsnames, svgnames, x11names
使用：\usepackage[dvipsnames, svgnames, x11names]{xcolor}
注意：xcolor宏包一般要放在最前面！否则那3张颜色表容易加不进来。
使用：
链接：https://www.jianshu.com/p/5aee7c366369
\documentclass[UTF8]{article} \usepackage[dvipsnames, svgnames, x11names]{xcolor} % 一般放得靠前 \usepackage{ctex} \usepackage{geometry} \geometry{a4paper, margin = 1in} \title{xcolor颜色测试} \author{\bf{胜负55开}} \date{\bf{\today}} \begin{document} \maketitle {\color{red}{红色}}是19个基本颜色中的一个，下面秀几个高级货： 这里是{\color{NavyBlue}{海军蓝}}，这个是{\color{Peach}{桃子色}} 这个是{\color{SpringGreen}{春天绿}}，最后一个{\color{SeaGreen3}{海绿3}}。 \end{document} 注意一点：颜色名字必须和颜色表中完全一致！即注意字母的大小写！！
下面是xcolor的基础颜色表和外带3大颜色表：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90034ebb0299b450593524761a8bcf48/" rel="bookmark">
			gazebo崩溃gazebo-2 process has died exit code 139
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
[gazebo-2] process has died [pid 7605, exit code 139, cmd /opt/ros/kinetic/lib/gazebo_ros/gzserver -e ode ...... Ubuntu 16.04 on Virtualbox 6.1
gazebo 7.0
大家可以试试更新gazebo到7.16版本以上（或者直接通过应用商店）
添加源和钥匙
sudo sh -c 'echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main" &gt; /etc/apt/sources.list.d/gazebo-stable.list' wget https://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add - $ sudo apt-get dist-upgrade $ sudo apt-get update $ sudo apt-get upgrade 然而没用，出现同样错误 [gazebo-1] process has died exit code 139, cmd /opt/ros/kinetic/lib/gazebo_ros/gzserver
现在唯一的方法就是关闭虚拟机里的3D加速，这样仿真会慢很多
settings-&gt;Display-&gt;Acceleartion
如果有更好的办法我会在这里公布！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90034ebb0299b450593524761a8bcf48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e5514d264726b4fac001acd744ecef/" rel="bookmark">
			由于没有远程桌面授权服务器可以提供许可证,远程会话连接已断开解决方法（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：远程桌面连接提示由于没有远程桌面授权服务器可以提供许可证,远程会话连接已断开
解决方法：用mstsc /admin /v:ip:port登录后，我的电脑—右键菜单中选择-“管理”，点击"角色"，点击"删除角色"，选择“远程桌面服务”删除即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f35327ca3e67171f6904b8528257059/" rel="bookmark">
			layui数据表格和表单的完整运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@{ ViewBag.Title = "AutomaticRequestRecord"; Layout = "~/Views/Shared/MyLayout.cshtml"; } &lt;form class="layui-form" action="" id="form1"&gt; &lt;div class="layui-form-item"&gt; &lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;请货号&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" name="R_requestId" autocomplete="off" class="layui-input" placeholder="请货号"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;商品ID&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" name="GOODSID" autocomplete="off" class="layui-input" placeholder="商品ID"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;商品名称&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" name="GOODSNAME" autocomplete="off" class="layui-input" placeholder="商品名"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="layui-inline"&gt; &lt;select name="R_type"&gt; &lt;option value=""&gt;请选择请货类型&lt;/option&gt; &lt;option value="1"&gt;手动请货&lt;/option&gt; &lt;option value="0"&gt;自动请货&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f35327ca3e67171f6904b8528257059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5feb9af3d985b40280ee5269f17e4f/" rel="bookmark">
			超全面的后端开发C/C&#43;&#43;面经整理分享含详细参考答案 包括简历分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为博主2020年秋招提前批的c/c++后端开发面经整理，包括C/C++语言基础，计网，数据库，linux，操作系统，场景题，智力题和hr常问题。面试问题来自前人的工作和博主面试时遇到的值得记录的问题，其中面试题答案多为博主自行解答（并且面试的时候也基本是这样回答的），回答中都附上了参考资料的链接，全文共七万余字，仅供大家作为面试准备材料的参考。
希望大家在准备面试的时候都能建立一个属于自己的题库，自己从网上寻找问题，然后自己进行解答，并且记录下来，这样在面试的时候就能行云流水般的回答上来。因此我把这份面经的源文件 markdown格式分享给大家：网盘链接
提取码：229s
希望大家在这份面经上添砖加瓦或从头开始，建一个属于自己的面试题库！
附上博主2020秋招进展：
TP-LINK提前批 软开深圳:一面二面三面hr面 offer
shopee 后端深圳:笔试一面二面hr面 offer
快手提前批 客户端 深圳:一面二面三面hr面 offer
腾讯提前批 c++ teg 深圳:一面二面hr面 offer
百度提前批 c++ 北京:一面二面三面+hr面测评 offer
阿里C++ 北京:笔试一面二面三面交叉面一面二面三面hr面 offer
字节跳动提前批 后端深圳:一面二面 挂
招银网络提前批 软开深圳:一面二面三面 挂
京东提前批 后端 京东零售:简历 挂
猿辅导 服务端:笔试 挂
京东正式批 c++:笔试一面二面 放弃
网易互娱 游戏研发广州: 笔试 放弃
哔哩哔哩 后端上海:笔试 放弃
虎牙提前批 后端广州:放弃
拼多多提前批 后端:笔试 放弃
目录 写在前面关于实习关于简历关于投递关于面试准备 1. 语言基础 (C/C++)（0） 指针和引用的区别（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？（2） 堆和栈有什么区别（3）堆快一点还是栈快一点？（字节提前批一面）（4） new和delete是如何实现的，new 与 malloc的异同处（5）既然有了malloc/free，C++中为什么还需要new/delete呢？（6） C和C\+\+的区别（7）delete和delete\[\]的区别（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）（9）C++和python的区别（10） Struct和class的区别（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）（12） 在C\+\+中const的用法（定义，用途）（13） C++中的static用法和意义（14） 计算下面几个类的大小：（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等（16） STL源码中的hash表的实现（17）解决哈希冲突的方式？（18） STL中unordered_map和map的区别（19） STL中vector的实现（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。（21）C++中vector和list的区别（22） C++中的重载和重写的区别：（23） C ++内存管理（热门问题）（24） 介绍面向对象的三大特性，并且举例说明每一个。（25） 多态的实现（和下个问题一起回答）（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）（27） 实现编译器处理虚函数表应该如何处理（28） 基类的析构函数一般写成虚函数的原因（29） 构造函数为什么一般不定义为虚函数（30） 构造函数或者析构函数中调用虚函数会怎样（31） 纯虚函数（32） 静态绑定和动态绑定的介绍（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）（34） 对象复用的了解，零拷贝的了解（35） 介绍C++所有的构造函数（36） 什么情况下会调用拷贝构造函数（三种情况）（37） 结构体内存对齐方式和为什么要进行内存对齐？（38） 内存泄露的定义，如何检测与避免？（39） C++的智能指针有哪些（40） 调试程序的方法（41） 遇到coredump要怎么调试（42） inline关键字说一下 和宏定义有什么区别（43） 模板的用法与适用场景 实现原理（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）（46） C++的调用惯例（简单一点C++函数调用的压栈过程）（47） C++的四种强制转换（48）string的底层实现（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的（50）set，map和vector的插入复杂度（51）定义和声明的区别（52）typdef和define区别（53）被free回收的内存是立即返还给操作系统吗？为什么（54）引用作为函数参数以及返回值的好处（55）友元函数和友元类（56） 说一下volatile关键字的作用（57） STL中的sort()算法是用什么实现的，stable_sort()呢（58）vector会迭代器失效吗？什么情况下会迭代器失效？（58）为什么C++没有实现垃圾回收？ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5feb9af3d985b40280ee5269f17e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a3ec61e836b6e7ea252159df4ade40/" rel="bookmark">
			proto3默认值与可选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		proto3特性 proto3相较于proto2支持更多语言但在语法上更为简洁。去除了一些复杂的语法和特性，更强调约定而弱化语法。
删​​除原始值字段的presence字段逻辑，删除required字段以及删除默认值。这使得proto3更容易实现如在Android Java，Objective C或 Go 等语言中的开放式结构化表示。移除unknown关键字.去掉extensions类型，使用Any新标准类型替换。针对未知枚举值的固定语法.增加maps(主要指代码生成支持map)添加一组用于表示时间，动态数据等的标准类型。替换二进制编码的明确 JSON编码 问题提出 不可否认由于proto3在语法上进行了大量简化，使得proto格式无论是在友好性上、还是灵活性上都有了大幅提升。但是由于删除了presence、required及默认值这些内容，导致proto结构中的所有字段都成了optional（可选字段）类型。这在实际使用过程出现了如下问题：
结构化数据缺失、显示不全，默认值都当成了不存在（not present)。对外提供的数据上报时，不便于对数据的分析和使用。对内服务调试时，不便于问题跟踪和定位;无法验证业务逻辑上数据构造的正确性，如果是默认值不清楚数据构造时到底是否赋过值。 Introducing a new keyword or reusing an existing keyword to support field presence in proto3 will complicate protobuf semantics. We believe it will lead to confusion and misuse, which defeats the purpose of removing field presence in proto3.
at the moment we recommend users to design their proto3 protos without relying on field presence.
问题解决 1、wrappers方案 方案介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a3ec61e836b6e7ea252159df4ade40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5051e719be8a564f9cb78aa702e362/" rel="bookmark">
			使用Screenfull库来实现全屏效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天介绍一个Javascript的第三方库screenfull，简单易用，在github上已经有5000多🌟了
1. 使用前需要先安装，利用npm install就行
npm install screenfull
2.介绍几个核心方法和属性：
2.1 screenfull.toggle()
这个方法会请求全屏，如果当前是全屏则会退出全屏。
2.2 screenfull.isFullscreen
返回一个布尔值，当前是否是全屏状态。
2.3 screenfull.isEnabled
返回一个布尔值，是否当前可以进入全屏。
注意：这个第三方库支持电脑桌面或ipad上使用Safari浏览器，但是iphone是不行的。
3. 实例：
下面介绍在个人博客中使用此第三方库的例子。这里需要先定义一个变量来表示当前是否全屏的状态，默认初始化是false。然后，这里根据状态值判断展示不同的小图标icon，当点击图标时，会调用screenFullToggle函数来使用toggle()方法。当每次全屏或退出全屏之后，再将fullscreen的状态置反。具体代码如下：
state = { fullScreen: false } screenFullToggle = (fullScreen) =&gt; { if (screenfull.isEnabled) { screenfull.toggle() this.setState({ fullScreen: !fullScreen }) } } render() { const {fullScreen} = this.state const path = this.props.location.pathname return ( &lt;div className={'blog-nav'}&gt; &lt;span&gt; &lt;a href={'#/blog/home'} className={'header-left'}&gt; Martin's Blog &lt;/a&gt; &lt;/span&gt; &lt;span&gt; {fullScreen ? &lt;div className={'header-right'} onClick={() =&gt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5051e719be8a564f9cb78aa702e362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b544a6b2caaa946333e11100e4727b6e/" rel="bookmark">
			面向对象设计原则——依赖倒置原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口编程，不要面向实现编程。
由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成
二、赖倒置原则的实现方法 依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 三、实例 下面以“顾客购物程序”为例来说明依赖倒置原则的应用。
【例1】依赖倒置原则在“顾客购物程序”中的应用。
分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过天猫网店TianMaoShop 购物：
class Customer { public void shopping(TianMao shop) { //购物 Console.WriteLine（shop.sell()); } } 但是，这种设计存在缺点，如果该顾客想从另外一家商店（如京东JingDongShop）购物，就要将该顾客的代码修改如下： class Customer { public void shopping(JingDong shop) { //购物 Console.WriteLine（shop.sell()); } } 顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“天猫网店”和“京东网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下： class Customer { public void shopping(Shop shop) { //购物 Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b544a6b2caaa946333e11100e4727b6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9008efdb9eb0978b2e5a1e5698c7d07f/" rel="bookmark">
			vue v-if和v-show的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-if vs v-show v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。
&lt;template&gt; &lt;div id="app"&gt; &lt;div v-if="isIf"&gt; if &lt;/div&gt; &lt;div v-show="ifShow"&gt; show &lt;/div&gt; &lt;button @click="toggleShow"&gt;toggle&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'app', data() { return { isIf : true, ifShow : true, loginType : "username" } }, methods: { toggleShow : function(){ this.ifShow = this.ifShow ? false : true; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9008efdb9eb0978b2e5a1e5698c7d07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9655b282fc6794811a4acd723b413a/" rel="bookmark">
			opencascade基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回主页
大师之路
千淘万漉虽辛苦，吹尽狂沙始到金。
博客园 首页 新随笔 联系 管理 订阅订阅 随笔- 139 文章- 0 评论- 6
OpenCASCADE 基础
OpenCASCADE 基础
转载▼
一直在用OCC作项目，但这方面的中文资料很少，看来OCC在中国还不是十分普及；
后来，项目中使用OCC和DirectX结合使用，取得了很好的效果；
随着OCC6.3版本的推出，Open CASCADE在速度方面已有了很大的改变。以下为一些OCC的基础知识，愿与各位OCC爱好者共同学习；
一：OCC中的基础类：
gp_Pnt
在OCC中，gp_Pnt表示一个顶点，gp_Vec表示一个向量，可以用两个顶点来生成一个向量。
比如：
gp_Pnt P1(0,0,0);
gp_Pnt P2(5,0,0);
gp_Vec V1 (P1,P2);
向量有一个方法.IsOpposite（），可以用来测试两个向量的方向是相对还是平行;
比如：
gp_Pnt P3(-5,0,2);
gp_Vec V2 (P1,P3);
Standard_Boolean result =V1.IsOpposite(V2,Precision::Angular());
另外向量还有一些重要方法：
–Standard_Real Magnitude() const;计算向量的大小；
–Standard_Real SquareMagnitude() const;计算向量的平方；
–向量的加减乘除操作；
–向量的单位化；
–通过一个点，线，面得出其镜像的向量；
–向量的旋转，平移，缩放；
具体的函数名称可以看OCC的头文件说明；
有时需要决定一组空间点是位于一个点;一条直线,或一个平面,或一个空间:
OCC中提供了相应的算法；
比如：
TColgp_Array1OfPnt array (1,5); // sizing array
array.SetValue(1,gp_Pnt(0,0,1));
array.SetValue(2,gp_Pnt(1,2,2));
array.SetValue(3,gp_Pnt(2,3,3));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9655b282fc6794811a4acd723b413a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d525be3ee16aa6dbd4cff30c3528a659/" rel="bookmark">
			Big Data tools插件连接 &#43; yarn 集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
big data tools 使用
yarn资源管理
1.修改 mapred-site.xml 配置文件
2.修改yarn-site.xml
3.修改yarn-env.sh
4.分发到其他节点
5.启动yarn
6.访问
链接：
big data tools 使用 Path hdfs://192.168.232.100:8020/ is not accessible or does not exist
之所以在连接的时候出现这中情况，是由于在hadoop 集群环境搭建完成之后，没有创建做页目录
设置执行MapReduce作业所需的HDFS目录：
hdfs dfs -mkdir -p /data/hadoop
对hdfs目录文件的操作，可以参考单机搭建里面的内容：
官方网址为：https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html
namenode 锁的争抢是通过 zkfc 进程去zookeeper集群中注册，谁最先注册成功，谁就是主节点
resourcemanager 锁的争抢是进程自己直接去 zookeeper 集群中注册，谁先注册成功，谁是主节点
yarn 集群中共 nodemanager 节点数量和 DataNode 节点数量相同，都是通过 workers 配置文件进行启动的 mapReduce 计算框架存在自己的弊端，然后引出 yarn 集群框架去进行集群的管理
driver 是一个 jvm 进程， applicationMaster 作用是向其他的 worker（nodemanager）发送 task ，然后回收结果。 回收后的结果，保存在堆内存中,如果结果数据非常大，会造成内存溢出。
一个clinet 客户端的请求，会创建一个 applicationMaster
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d525be3ee16aa6dbd4cff30c3528a659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a774c9ae24c91b75f2eb9f38b2a5a0/" rel="bookmark">
			element-UI单选框表格默认选中某一行高亮状态,点击某一行获取表格的行数(表格数据下标)以及setCurrentRow方法无法选中问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.单选框表格默认选中某一行高亮状态 1.首先，element ui-----table添加表格属性highlight-current-row，官方解释为是否要高亮当前行，其次添加 ref=“multipleTable”， &lt;el-table :data="tableData3" @row-click="handle" ref="multipleTable" :header-cell-style="{background:'#DAEDFF'}" :row-class-name="tableRowClassName" highlight-current-row &gt; &lt;!-- &lt;el-table-column type="selection" :selectable="selectEnable" width="95" &gt;&lt;/el-table-column&gt; --&gt; &lt;el-table-column fixed :prop="item.prop" :label="item.name" width="247" v-for="item in column" :key="item.id" &gt;&lt;/el-table-column&gt; &lt;/el-table&gt; 2.其次element ui-----table默认选中一行用setCurrentRow(row)方法，官方解释为用于单选表格，设定某一行为选中行，如果调用时不加参数，则会取消目前高亮行的选中状态。然后我们来看一下setCurrentRow(row)==&gt;参数row是当前选中的数据，我们在vue的生命周期函数mounted加载后，来选中table的第一条数据，借用ref绑定找到table的数据源。第一个参数为表格数据的某一项，不可以把整个数组放进去。这里重中之重来了，这样写大家通常都会出问题，BUG就是样式并没有修改没有高亮，而且我点击第一行的时候也没有显示高亮，只能我点击了另外的一行再点击第一行的时候才会显示高亮，表示选中的状态。或者各种各样的问题。 原因就是可能这个element-UI中的table还没有加载渲染完毕 ，此时我们只需要加一个延时方法定时器等等都可以。 mounted() { this.$nextTick(()=&gt;{ this.$refs.multipleTable.setCurrentRow( this.tableData3[this.rowIndex], true ); }) }, 二.单选框表格点击某一行获取表格行数(表格数据下标) 1.首先可以通过指定 Table 组件的 row-class-name 属性来为 Table 中的某一行添加 class，表明该行处于某种状态。这个属性会自动执行。 &lt;template&gt; &lt;el-table :data="tableData2" style="width: 100%" :row-class-name="tableRowClassName"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a774c9ae24c91b75f2eb9f38b2a5a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2554d6cb77796e938f0840d93713f91/" rel="bookmark">
			Android隐私政策
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本应用尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。但本应用将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本应用服务使用协议不可分割的一部分。
1. 适用范围
(a) 在您注册本应用帐号时，您根据本应用要求提供的个人注册信息；
(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；
(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。
您了解并同意，以下信息不适用本隐私权政策：
(a) 您在使用本应用平台提供的搜索服务时输入的关键字信息；
(b) 本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情；
(c) 违反法律规定或违反本应用规则行为及本应用已对您采取的措施。
2. 信息使用
(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。
(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。
(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。
3. 信息披露
在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：
(a) 经您事先同意，向第三方披露；
(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；
(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；
(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；
(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；
(f) 在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。
(g) 其它本应用根据法律、法规或者网站政策认为合适的披露。
4. 信息存储和交换
本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。
5. Cookie的使用
(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。
(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。
(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。
6. 信息安全
(a) 本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。
(b) 在使用本应用网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对
7.本隐私政策的更改
(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。
(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。
方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358d15f6cac52dee9bd358266cab3eef/" rel="bookmark">
			npm配置代理下载包内网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm config set proxy=http://127.0.0.1:8087
npm config set https-proxy http://server:port | npm config set registry=http://registry.npmjs.org
若配置完成使用报错或者不走，
npm config set registry http://registry.npm.taobao.org
2、取消代理
npm config delete proxy | npm config set proxy null
npm config delete https-proxy | npm config set https-proxy null
错误处理：
我在配置的时候出现了 request to https://registry.npm.taobao.org/@angular%2fcli failed, reason: getaddrinfo ENOTFOUND server错误。解决方法
npm config get proxy
npm config get https-proxy
如果返回值不为null，继续执行： （这一步很重要，一定要保证两个命令的返回值都为null,话说回来，应该出现这个错误这两个返回值有不为null的）（这里博主两个都不为null）
npm config set proxy null
npm config set https-proxy null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358d15f6cac52dee9bd358266cab3eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50346aa06a8323609931cdb1a52643ed/" rel="bookmark">
			vscode中的C语言scanf卡在编译过程的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在vscode中编写c语言时发现，使用scanf键盘输入的时候，总是出现卡在running的情况，如下图。查了查原来是要在终端运行，配置过程如下。
配置方法： 打开首选项里的设置，找到扩展（Extensions）里边有个Code-runner:Run In Termial，就是他勾选即可。下面就可以愉快的使用scanf函数啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea868078eac7ebde47ca4f1919057dd/" rel="bookmark">
			Pytorch中contiguous()函数理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在pytorch中，只有很少几个操作是不改变tensor的内容本身，而只是重新定义下标与元素的对应关系的。换句话说，这种操作不进行数据拷贝和数据的改变，变的是元数据。
会改变元数据的操作是：
narrow()view()expand()transpose() 在使用transpose()进行转置操作时，pytorch并不会创建新的、转置后的tensor，而是修改了tensor中的一些属性（也就是元数据），使得此时的offset和stride是与转置tensor相对应的。转置的tensor和原tensor的内存是共享的！ transpose()后改变元数据，代码示例： x = torch.randn(3, 2) y = torch.transpose(x, 0, 1) print("修改前：") print("x-", x) print("y-", y) print("\n修改后：") y[0, 0] = 11 print("x-", x) print("y-", y) 运行结果：
修改前： x- tensor([[-0.5670, -1.0277], [ 0.1981, -1.2250], [ 0.8494, -1.4234]]) y- tensor([[-0.5670, 0.1981, 0.8494], [-1.0277, -1.2250, -1.4234]]) 修改后： x- tensor([[11.0000, -1.0277], [ 0.1981, -1.2250], [ 0.8494, -1.4234]]) y- tensor([[11.0000, 0.1981, 0.8494], [-1.0277, -1.2250, -1.4234]]) 可以看到，改变了y的元素的值的同时，x的元素的值也发生了变化。
因此可以说，x是contiguous的，但y不是（因为内部数据不是通常的布局方式）。注意不要被contiguous的字面意思“连续的”误解，tensor中数据还是在内存中一块区域里，只是布局的问题！
为什么这么说：因为，y里面数据布局的方式和从头开始创建一个常规的tensor布局的方式是不一样的。这个可能只是python中之前常用的浅拷贝，y还是指向x变量所处的位置，只是说记录了transpose这个变化的布局。
使用contiguous() 如果想要断开这两个变量之间的依赖（x本身是contiguous的），就要使用contiguous()针对x进行变化，感觉上就是我们认为的深拷贝。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea868078eac7ebde47ca4f1919057dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad25acda4b2e487dfddba435f8273950/" rel="bookmark">
			什么是RabbitMq?其原理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是RabbitMq？ RabbitMQ是一个实现了AMQP（Advanced Message Queuing Protocol）高级消息队列协议的消息队列服务，用Erlang语言。
rabbitmq原理 1.Producer：即数据的发送方。创建消息并将其发布(发送)到代理服务器 一般一个Message有两个部分：payload（有效载荷）和label（标签），payload顾名思义就是传输的数据，label是exchange的名字或者说是一个tag，它描述了payload，而且RabbitMQ也是通过这个label来决定把这个Message发给哪个Consumer。
2. Exchange：即rabbitmq内的消息交换器。交换器是消息路由代理，交换器接受来自生产者应用程序的消息，并通过头属性、绑定和路由键将它们路由到消息队列。 exchange从生产者那收到消息后，一般会指定一个Routing Key，来指定这个消息的路由规则，当然Routing Key需要与Exchange Type及Binding key联合使用才能最终生效，根据路由规则，匹配查询表中的routing key，分发消息到queue中。
3. binding：即绑定。绑定是一个“链接”，您设置它来将队列绑定到交换器 在绑定（Binding）Exchange与Queue的同时，一般会指定一个Binding key。但Binding key并不是在所有情况下都生效，它依赖于Exchange Type
4. Queue：即队列。是rabbitmq内部对象，用于存储消息。 消息最终被送到这里等待consumer取走。一个message可以被同时拷贝到多个queue中。
那么谁应该负责创建这个queue呢？是Consumer，还是Producer？
如果queue不存在，当然Consumer不会得到任何的Message。那么Producer Publish的Message会被丢弃。所以，还是为了数据不丢失，Consumer和Producer都try to create the queue！反正不管怎么样，这个接口都不会出问题。
queue对load balance的处理是完美的。对于多个Consumer来说，RabbitMQ 使用循环的方式（round-robin）的方式均衡的发送给不同的Consumer。
5. Connection与Channel：两者都是RabbitMQ对外提供的API中最基本的对象 连接表示到消息代理的真正TCP连接，而通道是其中的虚拟连接(AMPQ连接)。
Connection就是一个TCP的连接，Producer和Consumer都是通过TCP连接到RabbitMQ Server的。
Channel是建立在上述的TCP连接中，因为建立TCP Connection的开销将是巨大的，所以是节省开销。
Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。
6. Consumer：即数据的接收方 使用者附加到代理服务器(RabbitMQ)并订阅队列。
如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。
7. Broker: 即RabbitMQ Server RabbitMQ不是一辆餐车，而是一种送货服务。
其作用是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。
8. Virtual host：即虚拟主机 当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue。
rabbitmq 消息转发流程，如下图所示： 生产者向交换器发布一条消息。交换器接收消息，现在负责消息的路由。必须在队列和交换器之间设置绑定。在本例中，我们从exchange绑定到两个不同的队列。交换器将消息路由到队列中。消息一直在队列中，直到由使用者处理。使用者处理消息。 ps：重点说下路由转发。生产者Producer在发送消息时，都需要指定一个RoutingKey和Exchange，Exchange收到消息后可以看到消息中指定的RoutingKey，再根据当前Exchange的ExchangeType,按一定的规则将消息转发到相应的queue中去。
rabbitmq模拟器使用 有兴趣的博友可以用rabbitmq模拟器体验下
模拟器地址：http://tryrabbitmq.com
模拟器使用方法：
1、直接将画框左边的图标拖进画图区，构建想要的拓扑图
2、按住Alt或Shift键，鼠标点击需要连接的图标（如果不能连接，反方向试试看，如：先点击queue，再点击exchange）
3、双击图标进行编辑设置各项功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad25acda4b2e487dfddba435f8273950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c633277360608c76ff704e6c7d91564c/" rel="bookmark">
			mysql查询重复字符串字段的条目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：培训人员名单列表有批量导入功能，未做严谨过滤时，出现身份证号重复记录，需要查出重复记录做删除。
mysql语句：
SELECT b.* FROM ( SELECT idCardNo, count(1) AS i FROM tal GROUP BY idCardNo HAVING i &gt; 1 ) AS a LEFT JOIN tal b ON b.idCardNo = a.idCardNo 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2542f4b6ade4ab242f6e331f1ddd5f1/" rel="bookmark">
			MonoPerfCap: Human Performance Capture From Monocular Video
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写目录标题 文章方法总结贡献三级目录 文章方法 从RGB视频序列中，使用普通的背景以克服概述的限制深度相机和多视图设置。是第一个处理从单目视频输入自动3D全人体性能捕捉的问题。我们的模板使用特定于角色的模板网格。在记录前，通过图像重建得到模板网格的变形，并使用运动骨架和中等尺度变形场进行参数化。根据这种形状表示，我们估计了输入视频中每一帧的actor的变形，使变形的模板与输入帧紧密匹配。由此产生的算法允许我们生成一个演员全身表演的时间上一致的表面表示。使用的是卷积神经网络二维判别联合预测作为地标，将3D骨架登记到图像中。我们利用第二个CNN来处理翻转的模糊性，这个CNN被训练成从单眼图像中返回三维关节位置。（存在第二个CNN主要是解决当2D投影正确的时候，对应的3D位置可能还是错的）。
为了从根源上解决3D识别不准确的问题，采用低维线性轨迹子空间约束三维位姿，在非刚性结构的情况下被证明是有效的。基于自动提取的轮廓图计算一个非刚性变形场，以捕获松散服装引起的非刚性表面变形，并将变形模板网格精确地覆盖到输入图像帧上。
总结贡献 1、首个人体3D捕捉方法依赖单目相机输入；
2、将鉴别二维和三维检测与基于批处理的运动优化相结合，解决了单目三维位姿估计固有的翻转歧义问题
3、利用自动提取的单眼轮廓恢复非刚性表面变形
4、由大约40k帧组成的基准数据集，涵盖了各种不同的场景。
三级目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ced3b78e471743eca46f14baa01dc65/" rel="bookmark">
			网易轻舟 Serverless 平台 Knative 性能调优实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 刘勤龙
策划 | 田晓旭
首发 | InfoQ
Serverless 技术正在获得越来越多的认可。CNCF 2019 年报告显示，41% 的受访者表示已经在使用 Serverless，另外 20% 的受访者表示计划在未来 12-18 个月内采用 Serverless 技术。
Serverless 技术关注者对其价值点讨论⼤多是基于公有云场景的云函数等产品，其关注点在资源支付方式更加细粒度，和公有云 Baas 的粘合上，和私有云环境中业务团队关注的价值不太契合；在我们对业界落地场景调研以及同业务团队⼀起实践后，我们发现私有云环境中业务团队关心的 Serverless 价值可概括为三点：
提效： 加快业务团队迭代效率， Serverless 对开发流水线重新对分工，业务开发人员聚焦业务，无需操心运维和扩容等诸多事项；
降本：按需实时弹性可避免资源浪费，最大程度发挥资源优势；
解耦：支持事件触发，将各个组件通信的逻辑变成事件进⾏解耦合，非常适合业务的扩展和变化；
其中“提效”和“降本”为核心价值，解耦为重要考虑点。
我们认为 Serverless 出现不是为了替代现有的 Serverful（传统云）框架，两者是互补的关系，Serverless 有其业务场景优势（后续⽂章再展开），合适最重要。笔者目前工作是聚焦轻舟 Serverless（“轻舟”系网易研发的云原生基础设施平台代号）和业务团队⼀起实现业务开发的提效、降本和解耦。当前开源 Serverless 方案很多，而选型强大活跃开源社区方案让我们能够持续改进自己的 Serverless 平台。基于此诉求，我们很早便选型了 Knative，因为从一开始其社区非常活跃，有 Google，IBM，RedHat 等大公司参与，其次是标准先行。而事实也在慢慢印证了我们的选择。
如图所示， Knative 占据了 34% 的份额，遥遥领先于第⼆名 OpenFaaS，Knative 是搭建 Serverless 平台的首选。（ 数 据 来 源 于 CNCF 2019 年 社 区 调 查 报 告 ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ced3b78e471743eca46f14baa01dc65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5673cee5ef5074c3d1e235cf1069e077/" rel="bookmark">
			Qt 控件实现双击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 qt中很多控件有双击事件的功能，但是还是有些控件如QWidget，QTabWidget等没有该事件。解决办法有两种
方法一：重载代码 以QTabWidget为例
// 首先我们继承QTabWidget class MyTabWidget : public QTabWidget { Q_OBJECT protected: // 然后重新实现鼠标双击事件 void mouseDoubleClickEvent(QMouseEvent* e); public: MyTabWidget(QWidget* parent = nullptr) : QTabWidget(parent){ }; }; void MyTabWidget::mouseDoubleClickEvent(QMouseEvent* e) { // 你自己期望实现的功能，在这里我的实现是新建一个标签页以及新的文本编辑栏 } 方法二：事件过滤器 h文件
#ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = nullptr); ~MainWindow(); protected: virtual bool eventFilter(QObject * obj,QEvent *event) override; private: Ui::MainWindow *ui; }; #endif // MAINWINDOW_H cpp文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5673cee5ef5074c3d1e235cf1069e077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ea5e01776b22eecc91115e1ef709ca/" rel="bookmark">
			windows下修改host不生效的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改hosts的host mapping不生效解决
在windows 环境下，修改hosts，添加新host mapping，如下：
192.168.128. 128 test
执行ping 192.168.128.128 ，可以ping通
但执行ping test，死活都不通
最后才找到方法解决，mark下。
方法一：命令行(cmd)运行:ipconfig /flushdns #清除DNS缓存内容。
ps:ipconfig /displaydns //显示DNS缓存内容
方法二：修改注册表：HKeyCurrentUser\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings，
新建：DnsCacheEnabled 0x0 (REG_DWORD)
DnsCacheTimeout 0x0 (REG_DWORD)
ServerInfoTimeOut 0x0 (REG_DWORD)这三个DWORD。
方法三：打开：控制面板-管理工具– 服务， 在其中找到“DNS Client”　将其停用并改为手动模式（做了这个后，运行ipconfig /flushdns就没必要了，也运行不成功）
方法四：
打开本地连接-》Internet protocol version 4(TCP/IPv4)-&gt;Advanced-&gt;Wins tab
选中Enable LMHOSTS lookup前面的checkbox，然后点击import LMHOSTS, 选择%WINDOWS%\system32\drivers\etc\lmhosts.sam（hosts）文件，就可以了。
参考: https://blog.csdn.net/zhongdajiajiao/article/details/51602304
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f85d9115500f7385f43a0bfadc072b/" rel="bookmark">
			容器接水/矩形面积最大系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码已在 leetcode 上验证通过。
11.盛最多水的容器
给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。
在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
class Solution { public: int maxArea(vector&lt;int&gt;&amp; height) { int l = 0, r = height.size()-1; int maxWater = 0; while (l &lt; r) { if (height[l] &lt;= height[r]) maxWater = max(maxWater, (r-l)*height[l++]); else maxWater = max(maxWater, (r-l)*height[r--]); } return maxWater; } }; 42.接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63f85d9115500f7385f43a0bfadc072b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/210/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>