<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acab22a92860f2ad23da6937efe367ac/" rel="bookmark">
			Hive中orderBy，sortBy，distribute by，cluster by，group by
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.总结2.order by3.sort by4.distribute by5.distribute by + sort by6.Cluster by7.group by 和distribute by的区别 1.总结 order by：全局有序，但是会导致执行时间长或者任务集中。sort by：局部有序，对每个reduce进行排序distribute by：控制在map端如何拆分数据给reduce端的。划分map的数据流，使相同key传入一个reduce 一般来说distribute by 和sort by会放在一起使用，统计每个种类的topn
cluster by：distribute by + sort by（前提是列相同） 但是使用cluster by会抛弃sort by的并行性，可以实现输出文件的全局有序性
group by：对检索结果的保留行进行单纯分组，一般总爱和聚合函数一块用 group by把相同key的数据聚集到一起，后续必须是聚合操作。而distribute by仅仅是对map的数据流进行划分控制。
2.order by 首先我们要明白Hive的本质是将HiveSQL转成MapReduce来执行分布式计算的，和普通单机程序不同的一个特点就是最终的数据会产生多个子文件，每个reducer节点都会处理partition给自己的那份数据产生结果文件，这导致了在Hadoop环境下很难对数据进行全局排序。
所以如果在Hadoop上进行order by全排序，会导致所有的数据集中在一台reducer节点上，然后进行排序，这样很可能会超过单个节点的磁盘和内存存储能力导致任务失败。
因此OrderBy会导致全局排序，使用order by会引发全局排序
select * from baidu_click order by click desc;
3.sort by sort by则指的是局部排序，它将会在每个reduce中进行局部排序。但是无法保证全局有序。
4.distribute by distribute by 的作用是保证相同的key的键值对会发送到一个Reduce中
一般来说distribute by 会和 sort by一起使用
5.distribute by + sort by 使用distribute和sort进行分组排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acab22a92860f2ad23da6937efe367ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d581cb9e617b1a3cca38c61cc5037c/" rel="bookmark">
			c语言结构体成员赋值失败,objective-c - C语言在使用中遇到了一个结构体赋值失败的问题？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有一个A类：
定义了一个结构体
typedef struct
{
int sockfd;
on_av_frame_cb av_frame_cb;
on_av_frame_cb rtp_cb;
on_error_cb error_cb;
uint8_t *p_buf;
uint8_t *v_buf;
uint8_t *a_buf;
int rtp_flag;
}udp_client_t;
然后我再B类中调用：
static udp_client_t client;
int jldv_create_client(int src_port,int port ,const char *dst_ip){
udp_client_t *udpClient = &amp;client;
assert(udpClient != NULL);
const char *c_ip = dst_ip;
memset(udpClient, 0, sizeof(udp_client_t));
int ret = create_client(src_port, port, c_ip, &amp;udpClient);
if (ret != 0) {
goto err_output;
}
udpClient-&gt;av_frame_cb = (on_av_frame_cb )onVideoFrame;
udpClient-&gt;error_cb = on_error;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d581cb9e617b1a3cca38c61cc5037c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe5d44509d82e6c8f3748c40581ade9/" rel="bookmark">
			2021-05-20 Matlab实现傅里叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab实现傅里叶变换 傅里叶变换是将按时间或空间采样的信号与按频率采样的相同信号进行关联的数学公式。在信号处理中，傅里叶变换可以揭示信号的重要特征（即其频率分量）。
对于包含 n 个均匀采样点的向量 x，其傅里叶变换定义为
ω=e−2πi/n 是 n 个复单位根之一，其中 i 是虚数单位。对于 x 和 y，索引 j 和 k 的范围为 0 到 n−1。
MATLAB中的 fft 函数使用快速傅里叶变换算法来计算数据的傅里叶变换。以正弦信号 x 为例，该信号是时间 t 的函数，频率分量为 15 Hz 和 20 Hz。使用在 10 秒周期内以 150 秒为增量进行采样的时间向量。
t = 0:1/50:10-1/50; x = sin(2*pi*15*t) + sin(2*pi*20*t);figureplot(t,x) 计算信号的傅里叶变换，并在频率空间创建对应于信号采样的向量 f。
​​​​​​​
y = fft(x); f = (0:length(y)-1)*50/length(y); 以频率函数形式绘制信号幅值时，幅值尖峰对应于信号的 15 Hz 和 20 Hz 频率分量。
​​​​​​​
figureplot(f,abs(y))title('Magnitude') 该变换还会生成尖峰的镜像，对应于信号的负频率。为了更好地以可视化方式呈现周期性，使用 fftshift 函数对变换执行以零为中心的循环平移。
​​​​​​​
n = length(x); fshift = (-n/2:n/2-1)*(50/n);yshift = fftshift(y);figureplot(fshift,abs(yshift)) 含噪信号 在科学应用中，信号经常遭到随机噪声破坏，掩盖其频率分量。傅里叶变换可以清除随机噪声并显现频率。例如，通过在原始信号 x 中注入高斯噪声，创建一个新信号 xnoise。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe5d44509d82e6c8f3748c40581ade9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794f91b1d19bdeaa7abb08eb2a255ead/" rel="bookmark">
			React Hooks学习--useRequest网络请求Hooks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前用于网络请求的Hooks是很多的，但是为什么选择使用useRequest呢？
目前的许多Hooks都需要根据不同的场景来选择，比如分页usePagination，加载更多useLoadMoreuseAsync能力不足，不能支持并行请求useRequest不仅包含来Umi Hooks所有和网络请求相关的Hooks,还借鉴了swr的特性 swr的主要能力在于：我们在发送网络请求时，会优先返回缓存内的数据，然后在背后发起网络请求，最终用新的请求结果来触发组件渲染。
一.useRequest的基本使用 这是一个最简单的网络请求示例。在这个例子中 useRequest 接收了一个 Promise 函数。在组件初始化时，会自动触发 getUsername 执行，并自动管理 data 、 loading 、 error 等数据。
二.一些基础的params 手写请求：设置manual : true，即可阻止初始化发送service，只有触发run('xxxxx')才会发送service服务，run中的参数会传给service轮询：对需要时刻更新的数据，我们需要不断的发起网络请求，使用pollingInterval:时间并行请求：对相同的类型，只维护一次请求，对多个类型，维护多次请求，使用fetchKey防抖：debounceInterval:时间 节流：throttleInterval:时间swr：cacheKey分页：paginated:true 注意：
三.集成请求库 如果useRequest第一个参数不是异步请求方法Promise，而是object，array等，则自动使用umi-request发送网络请求
通过使用requestMethod,可以使用其他的请求库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbad47a1b76992c1bffacf1a9e0e5678/" rel="bookmark">
			复合辛普森公式c语言编程,复合辛普森公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《复合辛普森公式》由会员分享，可在线阅读，更多相关《复合辛普森公式(5页珍藏版)》请在人人文库网上搜索。
1、精选文档实验5 复合辛普森公式李涛 201226100108 计自1201一、实验目的l 用复合辛普森公式计算积分，使误差不超过(注意所给积分特点，做出相应的处理后再计算)二、实验步骤1.算法原理复合辛普森原理：将区间划分为n等分，在每个子区间上采用辛普森公式，若记则得l l 记l l 称为复合辛普森求积公式，其余项为l 于是当时，与复合梯形公式相似有l 易知误差阶为，收敛性是显然的，实际上，只要则可得到收敛性，即l 此外，由于中求积公系数均为正数，故知辛普森公式计算稳定。2.算法步骤复合辛普森：首先将区间划分为n等分，在每个子区间上采用辛普森公式，若记则得算法过程：这里将辛普森公式写为Sn(。
2、)函数，然后在Solve()函数里依次计算S1,S2,S4,S6.当相邻的精度小于eps时退出循环，则S2n保存结果。三.程序代码#include #include #define eps 1e-6using namespace std;double f(double x)return sqrt(1+cos(x)*cos(x);/被积函数double Sn(double a,double b,double n)double h=(a+b)/(2*n);double sum=0;for(int k=1;keps)coutn = i S1 = S1n S2 = S2nn;i+;S1n=S2n;S2。
3、n=Sn(a,b,2*i);return S2n;int main()coutSolve(0,48)n;四、结果展示并分析l 当eps设为10-4时计算结果为58.4708 错的l 当eps设为10-5时计算结果为58.4706 错的l 当eps设为10-6时计算结果为58.4705 考虑假收敛后结果此外根据第三次计算结果可以发现当n=42时已经满足10-4的精度要求，所以第一次和第二次计算都不能达到精度要求。五、心得体会通过本次试验，我理解复合辛普森公式的方法原理，并且能利用复合辛普森公式计算积分，在数值分析的理论知识上又有了较大的收获，在进行编程的过程中，我已经基本熟练了数值算法的程序过程，能独立的在有限的时间内完成，这对以后的学习会有很大的帮助。5。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7918fdbe749e09bfcbd62d76d22027c5/" rel="bookmark">
			同样是巨头的语言，为什么中国是 Go 最热的国家，而 C# 越来越少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说结论，确实是现在越来越多公司在转 Go 和招聘 Go，无论是大公司还是小公司。原因无非以下几点
大公司背书，毕竟是谷歌亲儿子，有专门的团队在维护，不用担心突然就撒手不管了
性能不错，天然支持并发，语法简洁易于上手，这些优点也促使了团队在做技术选型时选择了 Go
节约成本，性能好比较省机器，易上手比较容易招聘，经过几个月的内部培训也能写出高质量的业务代码
社区生态越来越好，越来越多开发者和大公司团队加入 Go 开源社区，并持续不断地贡献着，如 k8s，docker，grpc，gin，wire 等。这点非常重要，活跃的社区生态意味着
很多时候我们不需要重复造轮子，直接使用已有轮子，可以省去很多成本
有些坑已经被人踩了，我们不需要再去踩一次了
大量的最佳实践
云原生的兴起，所以你会看到很多运维开发工程师已经在学习 Go 了。
本人新建一个技术交流圈子，群主是10年老技术人员，某上市公司的技术负责人，群里面每天会给群友解答疑问，招聘内推，点击即可加入圈子
技术交流群，群友每天分享干货，答疑解惑
再说说C#，背靠微软
普通人用不起，windows服务器按核心收费，一台16核心一个月几千块钱，还有mssql价格和oracle不相上下几十万。java+mysql不要钱，这就是差价
因为C#的微软背景，很显然和微软有竞争关系的大软件公司都不会去使用C#，即使和微软没有竞争关系的公司，出于战略考虑，也绝对不会把公司的重心放在c#上，这样就导致C#的就业机会要你其他语言少的多，就业机会少，自然用的人就更少了。
C#没有Java在Web的优势，主要是少了开发社区的支持，看看Java的框架，各类应有竟有组件就知道了；第二是因为跨平台，对安卓，iOS的App支持不够好，对H5支持不够好，现在很多系统都需要服务端支持手机，平板电脑。零几年C#开发非常流行，我们是做软件外包，基本都是用.net。就是这几年手机应用成为主流，失去优势了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5774d9297f80850369effd1fbaca1ef8/" rel="bookmark">
			51单片机c语言数组怎么用,51单片机之C语言-4.2数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：51单片机之C语言-4.2数组
现在我们知道了，不同的数据实际上是占用的单元格不同，8个单元格就是char，16个坑就是int，32坑就是long. 在实际应用中，可能有很多char，比如char1,char2,char3...,也很多int1,int2,int3...,也有很多long1,long2,long3等等。这么多的变量，我们能不能归个类。比如把单元格长度相同的放在一起，比如char1,char2,char3等，这样就产生了 的概念。那么如何把这些相同长度的单元格变量放在一起呢，也就是说如何定义一个数组呢？
一维数组的定义方式如下:
类型说明符 数组名 [常量表达式]
类型说明符: 表示你想把什么长度单元格的变量放在一起，比如是char,int还是long
数组名: 给你定义的数组取个名字，数组标识符
常量表达式: 表示你定义的数组中装有多少个元素，也就是数组长度
比如char a[4]; 说明字符型数组a，有4个元素
既然定义了数组，那么如何访问数组中的元素呢？比如我要访问数组a的第二个元素，
a[0] 表示数组的第一个元素
a[1]就表示数组的第二个元素
依次类推。
现在我们举个例子如何在编程中使用数组，
例4-2-1 如何在单片机编程中使用数组
定义一个数组，将数组中各元素的值给P1端口实现流水灯的功能
#include "reg52.h"
typedef unsigned char uchar;
typedef unsigned char chararray[8];//定义一个新的数组类型，它有8个元素，数据类型为unsigned char
void delayUs (unsigned char t);
void delayMs(unsigned char t);
void main(void)
{
chararray a ={0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf ,0xbf ,0x7f};
while(1)
{
uchar i;
P1=a[0];
for (i=0;i&lt;8;i++)
{
P1=a[i];
delayMs(100);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5774d9297f80850369effd1fbaca1ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca3d152e8972119a3d4877e8036a45b/" rel="bookmark">
			数据结构实验课：实验五、二叉树操作及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验五、二叉树操作及应用 一、 实验目的
掌握二叉树的定义、结构特征，以及各种存储结构的特点及使用范围，各种遍历算法。掌握用指针类型描述、访问和处理二叉树的运算。掌握前序或中序的非递归遍历算法。
二、 实验要求
有如下二叉树：
程序代码给出了该二叉树的链式存储结构的建立、前序、中序、后序遍历的算法，同时也给出了查询“E”是否在二叉树里的代码。代码有三处错误，有标识，属于逻辑错误，对照书中的代码仔细分析后，请修改了在电脑里运行。
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
typedef char DataType;
typedef struct Node
{
DataType data;/数据域/
struct Node *leftChild;/左子树指针/
struct Node *rightChild;/右子树指针/
}BiTreeNode;/结点的结构体定义/
/初始化创建二叉树的头结点/
void Initiate(BiTreeNode **root)
{
*root = (BiTreeNode *)malloc(sizeof(BiTreeNode));
(*root)-&gt;leftChild = NULL;
(*root)-&gt;rightChild = NULL;
}
void Destroy(BiTreeNode **root)
{
if((*root) != NULL &amp;&amp; (*root)-&gt;leftChild != NULL)
Destroy(&amp;(*root)-&gt;leftChild);
if((*root) != NULL &amp;&amp; (*root)-&gt;rightChild != NULL)
Destroy(&amp;(*root)-&gt;rightChild);
free(*root);
}
/若当前结点curr非空，在curr的左子树插入元素值为x的新结点/
/原curr所指结点的左子树成为新插入结点的左子树/
/若插入成功返回新插入结点的指针，否则返回空指针/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca3d152e8972119a3d4877e8036a45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47da5ead72736c983ff040e7018a3731/" rel="bookmark">
			数组添加数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数组添加数据的方法 int[] b=new int[10]; Scanner scanner = new Scanner(System.in); for (int i = 0; i &lt; b.length; i++) { b[i]=scanner.nextInt();//每次循环i递增 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e239f854952dd3a6ca984a85f245cb0e/" rel="bookmark">
			el-input-number 组件修改默认值为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 num设置成undefined，显示为空，设置成null会显示为0
&lt;el-input-number v-model="num" :min="1" :max="10" label="描述文字"&gt;&lt;/el-input-number&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6037e9124965c5744dc9b4621fae30/" rel="bookmark">
			WSL1 升级为 WSL2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL2 是 WSL 1 的升级版，带来的主要优势：
提高文件系统性能
支持完全的系统调用兼容性
WSL2 使用了 hyper-v 虚拟化技术，它就是一个你感知不到的虚拟机（VM），比以前的版本性能更高。举个栗子，我在WSL里面安装 nodejs, 采用源码编译方式安装，在 WSL1 下整整编译了100分钟，实在是太慢了。
更纤细的介绍请参阅官方文档：比较 WSL 1 和 WSL 2
执行命令 wsl -l -v 可以看到WSL版本号是 1，需要执行升级，才能到2
1.启用虚拟机功能
使用 PowerShell 以管理员身份运行：
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
然后重启电脑
2.下载 Linux 内核更新包
x64: https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi
arm64: https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi
3.设置分发版版本
执行命令：wsl --set-version &lt;分发版名称&gt; &lt;版本号&gt;
如：将 Ubuntu18.04 设置为WSL2的命令为 wsl --set-version Ubuntu-18.04 2
这一步比较耗时，执行完成后通过命令 wsl -l -v 来查询升级是否成功
使用分享：
WSL2 是基于虚拟机的，所以可以在后台运行各种任务，比如 Docker 等等，但是带来的相应问题就是会占用一部分内存，使用 wsl --shutdown &lt;分发版名称&gt; 可以再不使用的时候停止它，以节约资源
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50a6dc35de098b831a73f6d61f2f024/" rel="bookmark">
			使用 Java 实现快速排序（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 最近在看一些面试题，发现很多面试过程中都会要求手写快速排序，查阅一些博客发现别人写的并不是特别清楚而且也很难记住，所以为了更好的掌握这个算法，所以在这篇文章中，将自己的学习过程记录下来，你将学习到快速排序算法和使用 Java 如何实现快速排序。
快速排序是一种基于分而治之的排序算法，其中：
1、通过从数组中选择一个中心元素将数组划分成两个子数组，在划分数组时，将比中心元素小的元素放在左子数组，将比中心元素大的元素放在右子数组。
2、左子数组和右子数组也使用相同的方法进行划分，这个过程一直持续到每个子数组都包含一个元素为止。
3、最后，将元素组合在一起以形成排序的数组。
中心元素（pivot element)：有的地方翻译为：枢轴元素、基元，基准元素，我这里就叫做中心元素
二、快速排序算法的工作原理 1、选择中心元素 选择不同位置的中心元素，快速排序就有不同的变体，比如可以选择：第一个元素、最后一个元素以及左端、右端和中心位置上的三个元素的中值作为中心元素，在这里，我们将选择数组的最后一个元素作为中心元素。
2、重新排列数组 现在重新排列数组，将比中心元素小的放在左边，比中心元素大的放在右边。
重新排列数组的方法如下：
1、指针固定在中心元素上，将中心元素与从第一个索引开始的元素进行比较。
2、如果该元素大于中心元素，则为该元素设置第二指针。
3、现在将中心元素与其他元素进行比较，如果到达的元素小于中心元素，则将较小的元素和上次找到的较大元素交换位置。
4、同样，重复该过程以将下一个更大的元素设置为第二指针，并且将其和另一个较小的元素交换位置。
5、该过程一直进行到到达倒数第二个元素为止。
6、最后将中心元素与第二个指针指向的元素交换位置。
3、划分子数组 再次分别为左子部分和右子部分选择了中心元素，并且重复步骤2，子数组被分割，直到每个子数组只有一个元素，至此，该数组已经通过快速排序算法升序排好序了。
4、快速排序可视化插图说明 可以借助以下插图了解快速排序算法的工作原理。
三、快速排序算法伪代码 1、伪代码说明 quickSort(array, leftmostIndex, rightmostIndex) if (leftmostIndex &lt; rightmostIndex) pivotIndex &lt;- partition(array,leftmostIndex, rightmostIndex) quickSort(array, leftmostIndex, pivotIndex - 1) quickSort(array, pivotIndex, rightmostIndex) partition(array, leftmostIndex, rightmostIndex) set rightmostIndex as pivotIndex storeIndex &lt;- leftmostIndex - 1 for i &lt;- leftmostIndex + 1 to rightmostIndex if element[i] &lt; pivotElement swap element[i] and element[storeIndex] storeIndex++ swap pivotElement and element[storeIndex+1] return storeIndex + 1 四、Java 实现快速排序 Java 实现快速排序的代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50a6dc35de098b831a73f6d61f2f024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ab2e5131922410536168cde5e3c0fb/" rel="bookmark">
			Android7.1 设置中添加导航栏显示隐藏功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置中添加导航栏显示隐藏功能
1、显示菜单中有“导航栏”及“自动隐藏导航栏”两个选项，且“导航栏”选项默认勾选，“自动隐藏导航栏"默认开启。
2、上划可划出导航栏
commit 406da4c29e1a26ffc73058ce7b68872879f4cd59 Author: liupingzhang &lt;liupiingzhang@neostra.com&gt; Date: Thu Oct 8 15:05:15 2020 +0800 1824d-jd-w25d: 1.Settings: add navigation bar show &amp; auto hide 2.frameworks: add navigation bar show &amp; auto hide diff --git a/device/rockchip/rk3288/system.prop b/device/rockchip/rk3288/system.prop index d11b0ce..f72af35 100755 --- a/device/rockchip/rk3288/system.prop +++ b/device/rockchip/rk3288/system.prop @@ -74,3 +74,9 @@ sys.bluetooth.address=xx:xx:xx:xx:xx:xx #sys.neostra_oem_id=N1MXXM00S01T0PXW0E0MXV111XXXXX persist.neo.hide.wifiap=true persist.neo.allowUsbPermission=true +#add navigation bar show &amp; auto hide hg@20200929 +persist.neo.statusbar=false +persist.neo.statusbar2=true +persist.sys.navbar_enable=1 +persist.sys.navbar_autohide=1 +persist.sys.navbar_show=0 \ No newline at end of file diff --git a/frameworks/base/packages/SystemUI/res/values/colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ab2e5131922410536168cde5e3c0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414e9a054dbe684b3a62b4e7d34face7/" rel="bookmark">
			ActivityThread和ApplicationThread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ActivityThread和ApplicationThread
ActivityThread和ApplicationThread 个人总结，原文地址：https://blog.csdn.net/qq_37196748/article/details/106478134
1.ActivityThread：主线程、UI线程，程序的入口（main函数），不是线程是运行在主线程中的一个对象。
2.ApplicationThread是ActivityThread和AMS交互的中间桥梁。
3.ApplicationThread 和ActivityThread之间的联系是通过Handler，ActivityThread的变量final H mH = new H(); 私有内部类H继承自Handler，是主线程的handler，处理一些消息事务。
4.关于ApplicationThread:
是ActivityThread的私有变量，也是一个Binder对象，ApplicationThread是Client端的Binder，里面有操作scheduleXX方法处理四大组件的生命周期方法，所以AMS（AMS是Android系统最为核心的服务之一，其职责包括四大核心组件与进程的管理）服务想要调用启动组件，那就必须持有ApplicationThread的实例，如调用ApplicationThread的scheduleLaunchActivity方法，最后在scheduleLaunchActivity方法中sendMessage方法发送消息,ActivityThread中处理消息。
5.简述Activity的启动：
分为两种根Activity和普通Activity，根Ay设计进程的创建。
首先Launcher进程向AMS请求创建根Activity，AMS会判断根Activity所需的应用程序进程是否存在并启动，如果不存在就会请求Zygote进程创建应用程序进程。应用程序进程启动后，AMS会请求应用程序进程创建并启动根Activity。
普通的Activity启动：
在应用程序进程中的Activity向AMS请求创建普通Activity（步骤1），AMS会对 这个Activty的生命周期管和栈进行管理，校验（AndroidManifest.xml注册文件声明、启动权限）Activity等等。如果Activity满足AMS的校验，（判断进程存在）AMS就会请求应用程序进程中的ActivityThread去创建并启动普通Activity。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6a7cd6bad6a5c83e6ec7889802931f/" rel="bookmark">
			PVD与CVD性能比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PVD与CVD性能比较
CVD定义：
通过气态物质的化学反应在衬底上淀积一层薄膜材料的过程。
CVD技术特点：
具有淀积温度低、薄膜成分和厚度易于控制、均匀性和重复性好、台阶覆盖优良、适用范围广、设备简单等一系列优点。
CVD方法几乎可以淀积集成电路工艺中所需要的各种薄膜，例如掺杂或不掺杂的SiO2、多晶硅、非晶硅、氮化硅、金属(钨、钼)等。
影响台阶覆盖性的关键在于气相沉积技术的“绕镀性”。
气相沉积技术按照其原理可以分为化学气相沉积(CVD, Chemical Vapor Deposition)和物理气相沉积(PVD, Physical Vapor Deposition)。
CVD相对于PVD，有什么优点？
跟材料特性相关的性质——结晶性和理想配比都比较好
薄膜成分和膜厚容易控制
*淀积温度低
*台阶覆盖性好（step coverage)
化学气相淀积系统
气态源或液态源
气体输入管道
气体流量控制系统
反应室
基座加热及控制系统
温度控制及测量系统
减压系统（LPCVD和PECVD)
CVD系统的分类
常压化学气相淀积(APCVD)
低压化学气相淀积(LPCVD)
等离子增强化学气相淀积(PECVD)
化学气相沉积(CVD)
CVD 是利用等离子体激励、加热等方法，使反应物质在一定温度和气态条件下，发生化学反应并以生成的固态物质，沉积在适当位置的基体表面，进而制得的固态薄膜或涂层的工艺技术。
优点: CVD 可以在真空低的条件下沉积涂层，各种氮化物、碳化物、氧化物、硼化物、硅化物涂层的制备，可在低于其熔点，或分解温度的沉积温度下进行，设备简单，同一种膜的制备可选用不同的化学反应，灵活性比较大，即反应原料的成分，不仅可以调节和改变，又能控制涂层的特性和成分。因为绕镀性好，适合用于形状复杂的零件和沉积内壁、内孔等的镀膜。
缺点: 工艺温度高在应用上受到限制，针对局部表面沉积涂层时，没有 PVD 技术方便，沉积速率不是很高，比溅射镀膜还要低，镀膜后需真空热处理。制备的涂层表面粗糙，需要采取措施解决环境污染问题。
物理气相沉积(PVD)
PVD 是一种利用溅射，或蒸发等之类的物理气相方法，在真空环境中的衬底上凝聚，形成涂层的过程。目前，PVD 的主要方法有溅射镀膜、真空蒸发镀膜、电弧、空心阴极、活性反应等离子体镀膜。
优点: PVD 技术制备出的薄膜具有硬度和强度高、热稳定性好、耐磨性好、化学性能稳定、摩擦系数低、组织结构致密等优点。与 CVD 相比低温沉积且薄膜内部的压应力状态，对硬质合金精密复杂刀具的涂层更为适合。PVD 工艺无污染，可实现绿色化制造。PVD 涂层技术，不仅广泛用于各种切削加工刀具、钻头等的涂层处理，而且，涂层成分也由单层涂层、多元涂层发展到多元复合涂层。
缺点: PVD 技术制备涂层薄膜要求基体的清洁度高，由于绕镀性差，使得覆盖台阶、复杂零件等的能力差，工艺重复性不好且加工成本高。
利用某种物理过程，例如蒸发或者溅射现象实现物质的转移，即原子或分子由源转移到衬底表面上，并淀积成薄膜。
PVD基本方法
蒸发（Ⅲ-Ⅴ族化合物半导体）
溅射
蒸发
在真空系统中加热蒸发源，使原子获得足够的能量，可以脱离金属表面的束缚成为蒸汽原子，淀积在晶片上。
溅射
真空系统中充入惰性气体，在高压电场作用下，气体放电形成的离子被强电场加速，轰击靶材料，使靶原子逸出并被溅射到晶片上。
PVD的发展：
蒸发
蒸发优点：
较高的淀积速率
薄膜纯度高，厚度控制精确
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6a7cd6bad6a5c83e6ec7889802931f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bef26d6c1c397e0dba07385fa8b1938/" rel="bookmark">
			c语言计算换行次数,C语言，每输出5个数换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加一个计数的变量，每次找到目标时计数加一，被5整除时换行。
源代码如下：
#include int main() {
int a, b, c;
int l, i;
int count = 0; // 计数的变量
for (i = 100; i &lt;= 999; i++)
{
a = i / 100;
b = i / 10 % 10;
c = i % 10;
l = a + b + c;
if (l % 7 == 0) {
printf("%d ", i);
count++;
// 就是这里
if (count % 5 == 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bef26d6c1c397e0dba07385fa8b1938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f4b6d88056c48f0ce66cba645d93ab/" rel="bookmark">
			1、JavaScript编程语言准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript编程语言准备 和b站黑马程序员6天实战游戏开发微信小程序学习
选择的游戏引擎是CocosCreator ，编程语言是JavaScript，游戏后台采用Java。
JavaScript的基本语言基础： 一、变量声明let与const let 声明的变量只在 let 命令所在的代码块内有效。
const 声明一个只读的常量，一旦声明，常量的值就不能改变。
1、let的使用 1、只在代码块内有效
for (var a = 0; a &lt; 10; a++) {} console.log(a); // 输出结果--&gt; 10 ​ for (let b = 0; b &lt; 10; b++) {} console.log(b); // 输出结果--&gt; Uncaught ReferenceError: b is not defined 2、不能重复声明
var a = 1; var a = 2; console.log(a) // 输出结果--&gt; 2 ​ let b = 1; let b = 2; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67f4b6d88056c48f0ce66cba645d93ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91236c416bdb52eb86f1d38a035fdd03/" rel="bookmark">
			oracle中to_date的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle中to_date的使用 1、采用to_date(‘2021-05-17 13:14:32’,‘yyyy-MM-dd HH:mm:ss’)的形式，会有提示：
原因是SQL并不区分大小写,MM与mm被认为是同一格式，正确的方式是将mm改为mi来代表分钟。
2、采用to_date(‘2021-05-17 13:14:32’,‘yyyy-MM-dd HH:mi:ss’)的形式会有提示：
这是因为HH为12小时制，要想使用24小时制的SQL应该使用HH24来表示小时。
正确的写法是：
select to_date(‘2021-05-17 13:14:32’,‘yyyy-MM-dd HH24:mi:ss’) from dual;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d454a5804a669f741d4a96405d6bb8ad/" rel="bookmark">
			对抗训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、定义2、对抗训练：从CV到NLP2.1 CV中的数据格式2.2 NLP中数据格式 ３、对抗样本与数据增强样本４ 如何确定微小扰动４.1 Fast Gradient Sign Method(FGSM)４.2 Fast Gradient Method(FGM)4.3 Projected Gradient Descent(PGD) 5 实验结果6 实现6.1 pytorch实现[2]6.2 keras实现[3] 1、定义 对抗样本：对输入增加微小扰动得到的样本。旨在增加模型损失。
对抗训练：训练模型去区分样例是真实样例还是对抗样本的过程。对抗训练不仅可以提升模型对对抗样本的防御能力，还能提升对原始样本的泛化能力。
2、对抗训练：从CV到NLP ​ 对抗训练最初在cv中使用，nlp中很少使用。因为图像和文本的数据格式导致，在文本中无法增加微小扰动。同数据增强一样，cv中很适用，但nlp中的很少使用。
2.1 CV中的数据格式 图像是由矩阵表示的，如RGB图像是0~255的数字矩阵表示。
图像+微小扰动=图像 2.2 NLP中数据格式 文本会首先设置词表，然后将词映射为对应的索引：
文本+微小扰动≠文本 ​ Goodfellow在17年[2]提出可以在embedding上做扰动。这样做会带来问题：在embedding扰动得到的“对抗样本”不能map到某个单词。在对抗攻击时，不能通过修改原始输入得到这样的样本。所以nlp中的对抗训练不能用于对抗攻击，只能用来提高模型泛化能力。
３、对抗样本与数据增强样本 ​ 提高模型的泛化性能是机器学习致力追求的目标之一。常见的提高泛化性的方法主要有两种：
添加噪声，比如往输入添加高斯噪声、中间层增加Dropout以及近来比较热门的对抗训练等，对图像进行随机平移缩放等数据扩增手段某种意义上也属于此列；是往loss里边添加正则项，比如L1,L2惩罚、梯度惩罚等 数据增强与对抗样本都属于在原始输入引入噪声的方法。区别在于数据增强的噪声通常是随机的，而对抗样本的噪声是有目的性的。
随机噪声的实现方式简单，对泛化性的提升也确实有效。但他的一个明显缺点是“特异性”。随机噪声可能不会对模型造成明显干扰，所以对泛化性能提升帮助有限。
４ 如何确定微小扰动 ​ 对抗训练流程，在原始输入上增加一个微小的扰动 r a d v r_{adv} radv​，得到对抗样本，用对抗样本就行训练。可以抽象为下面的模型：
l o s s = − l o g p ( y ∣ x + r a d v ; θ ) w h e r e r a d v = − a r g m a x r , ∣ ∣ r ∣ ∣ &lt; ε l o g p ( y ∣ x + r ; θ ^ ) = a r g m i n r , ∣ ∣ r ∣ ∣ &lt; ε l o g p ( y ∣ x + r ; θ ^ ) (1) loss=-\mathop{log}p(y|x+r_{adv};\theta)\tag1\\ \mathop{where}r_{adv}=-\mathop{argmax}\limits_{r,||r||&lt;\varepsilon}\mathop{log}p(y|x+r;\hat\theta) =\mathop{argmin}\limits_{r,||r||&lt;\varepsilon}\mathop{log}p(y|x+r;\hat\theta) loss=−logp(y∣x+radv​;θ)whereradv​=−r,∣∣r∣∣&lt;εargmax​logp(y∣x+r;θ^)=r,∣∣r∣∣&lt;εargmin​logp(y∣x+r;θ^)(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d454a5804a669f741d4a96405d6bb8ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d9452642ad70eb8bf4ce3b80ec93a9/" rel="bookmark">
			解决 group_concat 默认长度限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：mysql的group_concat默认连接长度为1024字符，也就是说你需要连接后的连接超过1024字符，它只会显示这么长，其余部分都会被截取丢掉。
解决办法： （1）GROUP_CONCAT有个最大长度的限制，超过最大长度就会被截断掉，你可以通过下面的语句获得长度：
SELECT @@global.group_concat_max_len;
show variables like "group_concat_max_len";
使用以下语句设置：
SET GLOBAL group_concat_max_len=102400;
SET SESSION group_concat_max_len=102400; （2）在MySQL配置文件中my.conf或my.ini中添加:
#[mysqld]
group_concat_max_len=102400
（3）重启MySQL服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901ad7409e71f8132f59b9fbb14efddf/" rel="bookmark">
			Zynq AXI-ACP接口简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZYNQ中的AXI接口包含三个类型，共9个，主要用于PS与PL的互联。
AXI_HP接口
PL模块作为主设备 AXI_ACP接口
PS端是从设备端 AXI_GP接口
PS端是从设备端 今天我们重点来说一下ACP接口。
ACP AXI_ACP接口，是ARM多核架构下定义的一种接口，只有1个，中文翻译为加速器一致性端口，又叫加速器一致性端口，用来管理DMA之类的不带缓存的AXI外设，PS端是Slave接口。
AXI_ACP接口适合做专用指令加速器模块接口，加速器一致性端口提供对可编程逻辑主机的低延迟访问，并具有与L1和L2高速缓存的可选一致性。
从系统角度来看，ACP接口具有类似的功能，作为APU与CPU的连接性。
PL端可直接从PS部分的Cache中拿到CPU的计算结果，同时也可以第一时间将逻辑加速运算的结果送至Cache中，延时很小。
由于这种紧密的连通性，ACP直接与它们竞争在APU块之外进行资源访问。下图概述了ACP连接。
需要注意的是，必须先通过LVL_SHFTR_EN启用PL电平转换器，然后才能进行PL逻辑通信。
注意：默认情况下，所有PS外设均设置为安全Trustzone模式。这意味着任何用AxPROT [1] = 1表示的非安全访问将收到DECERR响应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c761cc25fadced3c577ef9ff86fc1d4/" rel="bookmark">
			fclose在c语言中的作用,c语言fcloseall函数用法实例介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言fcloseall函数用法实例介绍。fcloseall函数的返回值，函数 fcloseall() 将所有打开的流与其底层的文件或功能集合关闭。任何缓冲的数据都将首先被写入，使用 fflush(3) 。另外标准流 (stdin，stdout 和 stderr) 也被关闭。
NAME
fcloseall – 关闭所有打开的流
头文件的引入以及函数返回类型：
#define _GNU_SOURCE
#include int fcloseall(void);
函数说明：
函数 fcloseall 将所有打开的流与它们底层的文件或功能集合断开。任何缓冲的数据都将首先被写入，使用 fflush(3) 。注意标准流 (stdin，stdout 和 stderr) 也被关闭。
fcloseall函数的返回值
这个函数总是返回 0。
SEE ALSO 参见
fclose(3), close(2), fflush(3), fopen(3), setbuf(3)
NAME
fcloseall – close all open streams
SYNOPSIS
#define _GNU_SOURCE
#include int fcloseall(void);
DESCRIPTION
The fcloseall function dissociates all open streams from its underlying file or set of functions. Any buffered output data is written first, using fflush(3).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c761cc25fadced3c577ef9ff86fc1d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c575c47a493112983711efc0df4b1388/" rel="bookmark">
			c语言作业存款,2道C语言的题第一：设银行定期存款的年利率rate为2.25%,并已知存款期为n年,存款本金为capital元,试编程计...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
2道C语言的题
第一：
设银行定期存款的年利率rate为2.25%,并已知存款期为n年,存款本金为capital元,试编程计算n年后的本利之和deposit.
要求定期存款的年利率rate、存款期n和存款本金capital均由键盘输入.
第二：设faHeight为其父身高,moHeight为其母身高,身高预测公式为：
男性成人时身高 = (faHeight + moHeight) * 0.54(cm)
女性成人时身高 = (faHeight * 0.923 + moHeight) / 2(cm)
此外,如果喜爱体育锻炼,那么可增加身高2%,如果有良好的卫生饮食习惯,那么可增加身高1.5%.编程从键盘输入你的性别(用字符型变量sex存储,输入字符F表示女性,输入字符M表示男性)、父母身高(用实型变量存储,faHeight为其父身高,moHeight为其母身高)、是否喜爱体育锻炼(用字符型变量sports存储,输入字符Y表示喜爱,输入字符N表示不喜爱)、是否有良好的饮食习惯等条件(用字符型变量diet存储,输入字符Y表示喜爱,输入字符N表示不喜爱),利用给定公式和身高预测方法对你的身高进行预测.
本人刚接触C语言没几天~
1个回答
分类：
综合
2014-11-26
问题解答：
我来补答
一
main(){
int n,i;
float captial,desposit=1,rate=0.0225;
clrscr(); /*清屏*/
printf("存入年数：");scanf("%i",&amp;n);
printf("年利率：");scanf("%f",&amp;rate);/*题目给了2.25% 又要求输入 有点怪*/
printf("本金：");scanf("%f",&amp;captial);
for(i=1;i
展开全文阅读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafaacf7ed0b75a8d64deda84b441093/" rel="bookmark">
			Pycharm中利用Fiddler抓包的两种配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用pycharm开发一些需要访问网络资源的程序时，往往会因人或因物导致的一些配置，表面上看不出异常问题，但实质运行过程中并未如预期，最后就是产生一些莫名其妙的结果，即使检查了千万遍，可能也检查不出问题所在。其中的原因，很多是我们的请求头或参数有问题，在爬虫领域更甚，有时在代码中配置了相同的请求url,header,cookie，以为是配对了，但有时方式不一定对，有时在这框架OK，换了个框架，得到的响应内容又不一样。
所以，这时候为了保证我们发送的请求参数和目标网站收到的请求参数都是OK的，就需要有第三方的抓取工具来跟踪和对比，而fiddler主是比较好的抓包工具，通过配置代理实理完美抓取网络请求。下面主要讲的是两种配置代理的方式：
目录
一、Fiddler安装与配置
二、代码块中使用局部代理
三、Pycharm中配置全局代理
一、Fiddler安装与配置 Fiddler 是以代理web服务器的形式工作的，它使用代理地址:127.0.0.1，端口:8888。 当Fiddler退出的时候它会自动注销， 这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。 解决的办法是重新启动下Fiddler。
fiddler 其它更多的功能、下载和安装在这里就不多讲述了，因为都比较简单，各个版本的安装和配置都是一样的。这里主要提醒下安装完后记得打开监控https协议的选项配置。
如下图：打开fiddler 后，在菜单栏，依次Tools-Options-HTTPS,如图示，在3的标记处打勾。
还有Connection属性也要设置下，如下：
默认的监听端口是8888，可以根据需要修改，并对“Allow remote computers to connect”前打勾选上。
以上配置完了需要重启一下fiddler,就可以正常地通过8888端口来监听http,https协议的网络请求了。
二、代码块中使用局部代理 直接在代码块发送网络请求的地方配置代理，可以有针对性避免其它程序的影响。一般适用范围明确、小、临时性的场景为主。
下面用requests来做个示例：
首先是准备好fiddler代理
fiddler_proxies = {'http': 'http://127.0.0.1:8888', 'https': 'http://127.0.0.1:8888'} 完整样例如下：
fiddler_proxies = { 'http': 'http://127.0.0.1:8888', 'https': 'http://127.0.0.1:8888' } url = "https://httpbin.org/get" r = requests.get(url,headers=headers, proxies=fiddler_proxies) print(r.status_code,r.text) 执行程序后，在fiddler窗口便可以看到捕获到代码所发送的请求详情，就可以对请求参数、响应等内容进行分析。
三、Pycharm中配置全局代理 这里所说的全局代理是针对pycharm来说的，当然更上一层的全局代理是在电脑操作系统层级做的了。pycharm默认提供有配置代理的选项。通过简单配置就可以使所有项目在发送HTTP请求时通过fiddler向外转发请求。具体配置看下面：
打开代理配置页：菜单File-settings，输入框输入http，找到Http proxy
如图3位置打勾，填写下边的Host,port，然后右下角点确定就好。这时如果是第一次配置，可能会弹出一个安装证书的窗口，点接受就OK了。
如果是直接在pycharm中配置了全局代理，那么在具体的代码块中就不需要再添加代理了。现实中很多人说抓不到pycharm的请求，基本上是配置没搞好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f192097701a260fcf71e38d63e48f4/" rel="bookmark">
			KVM_虚拟化技术安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KVM虚拟化 一.虚拟化技术1.概述2.kvm虚拟化类型1）全虚拟化2）半虚拟化3）直通3.kvm特性优势：劣势：4.KVM模式5.KVM虚拟化架构/三种模式 6.KVM原理6.KVM工作流程7.虚拟化前，虚拟化后对比 二.KVM虚拟化平台部署1.虚拟机资源 2.修改主机名3.将镜像光盘设为自动/永久挂载4.环境优化5.制作本地YUM仓库6.关闭防火墙、核心防护三.安装KVM1.安装KVM基本组件检测CPU是否支持虚拟化查看KVM模块是否已安装设置开启启动界面的显示模式 2.设置KVM网络创建、编辑桥接网卡 3.KVM部署与管理4.使用虚拟系统管理器管理虚拟机1） 创建存储池2） 创建存储卷3）创建镜像池4） 创建虚拟机总结： 一.虚拟化技术 1.概述 虚拟化技术将一台计算机虚拟为多台逻辑计算机 应用程序可以在相互独立的空间内运行不影响 以软件形式实现物理设备的功能 通过虚拟化技术将一台计算机虚拟为多台逻辑计算机，在一台计算机上同时运行多个逻辑计算机同时每个逻辑计算机可运行不同的操作系统，应用程序都可以在相互独立的空间内运行互相不影响对物理硬件资源进行逻辑分隔，等待被调用 2.kvm虚拟化类型 1）全虚拟化 将物理硬件资源全部通过软件的方式抽象化，最后进行调用在底层硬件和服务器之间建立一个抽象层，而基于核心的虚拟机是面向linux系统开源产品VMM可以捕捉cpu的命令 2）半虚拟化 需要修好操作系统 3）直通 直接使用物理硬件资源 3.kvm特性 优势： 1.集中化管理(原创管理、维护)2.提高硬件利用率(虚拟化解决的是"空闲”容量)3.动态调整机器/资源(系统的硬件程序和服务器硬件分离，提高灵活性)4.高可靠（可提高透明负载均衡、迁移) 劣势： 1.前期高额费用(初期硬件支持)2.降低硬件利用率(极度吃资源，不一定适合虚拟化)3.更大的错误影响面(本地物理机不可用，会导致虚拟机文件全部损坏)4.实施配置复杂，管理复杂(管理人员运维、排障困难)5.一定的限制性(需要支持的虚拟化技术)6.安全性(虚拟化技术自身的安全隐患) 4.KVM模式 1.客户模式：客户机在操作系统中运行的模式2.用户模式：为用户提供虚拟机管理用户工具3.linux内核模式：模拟cpu、内存，实现客户模式切换 5.KVM虚拟化架构/三种模式 1、客户模式(guestOS):VM中的OS为GuestOS
客户机在操作系统中运行的模式，客户机分为内核模式和用户模式，作用如下:2、客户模式:
为用户提供虚拟机管理的用户空间工具以及代表用户执行I/O，Qemu_ 工作在此模式下(Qemu的主要功能)3、linux内核模式
模拟CPU、内存，实现客户模式切换，处理从客户模式的推出，KVM即运行在此模式下 6.KVM原理 1、Guest: 客户机系统，包括CPU (vCPU) 、内存驱动(Console、 网卡、I/O设备驱动等),
被KVM置于-种受限制的CPU 模式下运行。2、KVM内核模块模拟处理器和内存以支持虚拟机运行3、Qemu 主要处理I/O以及为客户提供一个用户空间/dev/kvm 工具ibvirt来进行虚拟机管理
ioctl (定义) 专用于设备输入输出操作的系统调用
libvirt: KVM管理工具
以上构成一个完整的虚拟化平台 简单理解:
KVM驱动提供处理器、内存的虚拟化，以及客户机I/O的拦截，guest的I/O被拦截后，
交由Qemu处理
Qemu利用接口libkvm调用(ioctl) 虚拟机设备接口/dev/kvm来分配资源、管理、维护虚拟机
6.KVM工作流程 KVM工作流程
用户模式的Qemu利用接口libkvm通过ioctl系统调用进入内核模式。KVM驱动为虚拟机创建 虚拟CPU和虚拟内存,
然后执行VMLAU.NCH指令进入客户模式，装载Guest OS并运行。Guest OS运行过程中如果发生异常，则暂停Guest OS
的运行并保存当前状态同时退出到内核模式来处理这些异常。
内核模式处理这些异常时如果不需要/O则处理完成后重新进入客户模式。如果需要I/O则进入到用户模式，
则由Qemu来处理I/O,处理完成后进入内核模式，再进入客户模式
思路:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3f192097701a260fcf71e38d63e48f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59be742f4c7c3c004cb7d7a89f52fb17/" rel="bookmark">
			将xml类型的excel文件转换为标准的Excel格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作原理是，如双击打开Xml表格的Excel文件另存为Microsoft Office Excel 工作薄，代码是使用了系统安装的office插件的Microsoft.Office.Interop将xml文件转换为标准的Excel格式文件，具体代码如下：
/// &lt;summary&gt; /// 将xml类型的excel文件转换为标准的Excel格式文件 /// &lt;/summary&gt; /// &lt;param name="strpath"&gt;xml类型的excel文件物理路径&lt;/param&gt; /// &lt;param name="filePathName"&gt;标准的Excel格式文件物理路径&lt;/param&gt; /// &lt;returns&gt;成功true 失败false&lt;/returns&gt; public static bool XmlToExcel(string strpath, string filePathName) { try { //将xml文件转换为标准的Excel格式 //由于yongCOM组件很多值需要用Missing.Value代替 Object Nothing = System.Reflection.Missing.Value; // 初始化 Microsoft.Office.Interop.Excel.Application ExclApp = new Microsoft.Office.Interop.Excel.ApplicationClass(); //打开Excl工作薄 Microsoft.Office.Interop.Excel.Workbook ExclDoc = ExclApp.Workbooks.Open(strpath, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing); try { //获取Excl 2007文件格式 Object format = Microsoft.Office.Interop.Excel.XlFileFormat.xlWorkbookNormal; ExclApp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59be742f4c7c3c004cb7d7a89f52fb17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97af8f11b9651b9d1aef9ada4fb6ea25/" rel="bookmark">
			ryujinx模拟器linux安装教学,Switch模拟器 Ryujinx 安装使用过程 不定期更新软件及相关附件...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件图片
模拟器环境搭建
如果你的电脑经常玩一些大型游戏,这一步可以忽视.以下软件为win64版本
(1..net核心安装
2.开源声卡安装
模拟器安装
1.下载模拟器:
2.解压模拟器到硬盘根目录(建议解压到除C盘以外的其他盘)
3.打开文件夹,找到主程序,右键发送快捷方式到桌面
4.打开模拟器
5.安装固件Firmware 10.1.1.zip
6.下载密匙文件并解压放在下图目录里
key(10.0.4).zip
模拟器设置
打开设置
设置游戏目录(建议不要使用中文的目录,在非系统盘建一个非中文的目录,把游戏放进去.这里指过去)
模拟器手柄设置(默认player1或者handheld)
模拟器系统设置
全部设置好以后点下面的save保存
更新文件夹(含历史文件)
http://pan.yoodii.com/dir/363628-40566506-aed7ea
更新文件夹使用方法:
因为更新文件的日期会靠前.所以打开文件夹以后,顺序变一下即可看到.(点击修改时间到你需要的早期或近期)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a26ae4aa48926e4696260a00a59e4b/" rel="bookmark">
			Flink学习笔记（5）——算子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本转换算子 map：输入一条记录，输出一个结果，不允许不输出
flatmap：输入一条记录，可以输出0或者多个结果
filter：如果结果为真，则仅发出记录
package transform; import org.apache.flink.api.common.functions.FilterFunction; import org.apache.flink.api.common.functions.FlatMapFunction; import org.apache.flink.api.common.functions.MapFunction; import org.apache.flink.streaming.api.datastream.DataStreamSource; import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator; import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment; import org.apache.flink.util.Collector; import wc.WordCountSet; /** * Created with IntelliJ IDEA. * * @Author: yingtian * @Date: 2021/05/13/9:55 * @Description: 基础算子 map flatmap filter */ public class TransformTest1_Base { public static void main(String[] args) throws Exception{ // 创建执行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); //读取数据 String inputPath = WordCountSet.class.getClassLoader().getResource("sensor.txt").getFile(); DataStreamSource&lt;String&gt; dataStream = env.readTextFile(inputPath); //输出每行字符的长度 结果一一对应 需要new一个MapFunction SingleOutputStreamOperator&lt;Integer&gt; mapStream = dataStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a26ae4aa48926e4696260a00a59e4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ede47b3549a32eeead9264664614729/" rel="bookmark">
			解决STM32F407串口数据乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 我使用的开发板是正点原子的stm32f407探索者开发板 ，看的视频是野火的野火F407开发板-霸天虎视频-【中级篇】，使用的固件库是从野火资料下载中心下载的（问题就出在这），在做串口实验的时候，上位机接收到的数据显示总是乱码，具体如下图所示
不正常的实验现象 发送的信息是："\r\n您发送的消息为:\r\n"
解决方法： 1、排除硬件问题。使用正点原子的串口例程，通信结果是正常的，因此问题一定出在软件上。 2、当前项目搜索“#define PLL_M ”——在system_stm32f4xx.c文件中，确保PLL_M的值与板子上的晶振保持一致。如晶振是25MHz，PLL_M=25；晶振是8MHz，PLL_M=8。同文件中其他几个需要注意的参数宏定义是： #define PLLM 8 //VCO输入=HSE/PLL_M=8M/8=1M，1M≤VCO输入≤2M #define PLLN 336 //VCO倍频输出=1M*PLL_N=1M*336=336M，50≤PLLN≤432，100≤VCO倍频输出≤432. #define PLLP 2 //PLLCLK=336M/PLL_P=336M/2=168M=SYSCLK，PLLP={2,4,6,8}，SYSCLK≤168M #define PLLQ 7 //PLL48CK=336M/PLL_Q=36M/7=48M，4≤PLL_Q≤15,PLL48CK≤48 Ctrl+F 3、当前项目搜索“#define HSE_VALUE”——在stm32f4xx.h文件中，确保HSE_VALUE的值与板子上的晶振保持一致。如晶振是25MHz，HSE_VALUE=25000000；晶振是8MHz，HSE_VALUE=8000000。 正常的实验现象 原因分析： 1、PLL_M 对系统的影响。在系统进入到main函数之前，会先进行时钟配置，具体的过程在启动文件startup_stm32f40_41xxx.s中调用SystemInit函数来完成，而SystemInit函数中又调用了SetSysClock函数来最终完成配置。在SetSysClock函数中 RCC-&gt;PLLCFGR = PLL_M | (PLL_N &lt;&lt; 6) | (((PLL_P &gt;&gt; 1) -1) &lt;&lt; 16) | (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q &lt;&lt; 24); 更具体的可以看野火F407开发板-霸天虎视频-【中级篇】16——RCC时钟树讲解非常详细 2、HSE_VALUE对系统的影响。在串口的初始化函数USART_Init中，配置波特率的时候使用到了系统时钟，而获取系统时钟的方法是调用RCC_GetClocksFreq函数，而RCC_GetClocksFreq函数获得系统时钟的过程是 void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks) { uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2; /* Get SYSCLK source -------------------------------------------------------*/ tmp = RCC-&gt;CFGR &amp; RCC_CFGR_SWS; switch (tmp) { case 0x00: /* HSI used as system clock source */ RCC_Clocks-&gt;SYSCLK_Frequency = HSI_VALUE; break; case 0x04: /* HSE used as system clock source */ RCC_Clocks-&gt;SYSCLK_Frequency = HSE_VALUE; break; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ede47b3549a32eeead9264664614729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7acc616f8482ac5a3099ac1c8e07a911/" rel="bookmark">
			Android webview复用优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【背景】
公司前段H5大神决定优化H5首屏加载耗时，Android已经使用了腾讯的x5内核，本身x5已经比较优秀了，加载自带提速。所以想从webview初始化耗时这个点优化一波。
【想法】
提前创建webview并设置好相关属性，要用到时直接拿来用。
【方案】
APP打开时 创建一组webview等待使用。
【问题点】
创建webview需要使用到Activity context，Activity不存在时如何创建？Activity destroy的时候，webview的context要释放，避免内存泄漏，如何处理？创建多个webview才够用呢 【解决】
寻找中间层MutableContextWrapper，通过包装的方式，实现了一个Context的壳，真正的实现体包装在里面，逻辑调用真正调用到对应的实现体的函数。 经过实验发现，Android系统本身提供了这么一个MutableContextWrapper，作为Context的一个中间层。 //提前创建webview WebView myWebView = new WebView(new MutableContextWrapper(App.getInstance())); //使用前 MutableContextWrapper contextWrapper = (MutableContextWrapper) webView.getContext(); contextWrapper.setBaseContext(activity); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928ab28af2d607d67e9a9afb695cdb1e/" rel="bookmark">
			IDEA利用自带Axis工具和wsdl文件反向生成服务端客户端代码详细流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@IDEA利用自带Axis工具和wsdl文件反向生成服务端客户端代码详细流程TOC
IDEA，我使用的是最新版本（2021.1.1）
JDK1.8
tomcat-8
详细步骤，用图片代替，关键地方，字幕解释。
到此步骤，是关键重点，请认真看
鼠标右键选择项目（soap-demo）然后请看图片
当改完之后，项目结构，会发生改变
创建-服务端-生成代码
1.请提前准备好wsdl文件，确保文件准确，然后打开wsdl文件，请看图片修改位置
2.wsdl文件地址修改之后复制到项目里
3.选中wsdl文件
4.ok
5.
6.最最要的地方，能改变一生的决定，就在于这！！！
请打开自己生成的wsdd文件 -复制&lt;service。。。标签里所有内容替换到web.WEB-INF.server-config.wsdd service 标签步骤看以下图片
7.
8.
9.
10.
11.切记，端口号，不要设置6666，要么，tomcat启动，但是找不到网页，设置8987，就行。
12.
13启动tomcat，不会启动的，自己百度吧！！！这个没法教了。
看图片，有路径，访问wsdl页面，代表成功。
14.目前位置，详细的服务端创建成功，全网独一无二！！！
创建客户端，生成客户端代码 1.当你服务端启动了，这个时候，就要知道一个事情，服务端地址，这是第一步骤，必须知道，服务端地址。
刚刚，我们已经启动了服务端，就会有服务端地址，（http://localhost:8987/server/services/ctms?wsdl）
然后，打开wsdl文件，把这个路径，改成服务端地址，请看图片
2.把你修改的wsdl文件，粘贴到你项目里，然后生成客户端代码
3.
4.TestController测试客户端，调用服务的main方法。
package client; import javax.xml.rpc.ServiceException; import java.rmi.RemoteException; public class TestController { public static void main(String[] argv) { try { CSPRequestService ctmsSoapBindingStub = new CSPRequestServiceLocator(); String CSPID = "ljkljklgjghjhgj6544654"; String LSPID = "tyfghgfhgfhgfh65465g4hf65gfh4g6f5h46"; String correlateID = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928ab28af2d607d67e9a9afb695cdb1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f286797baa4c57e95dc6ce12b2f488b/" rel="bookmark">
			linux任务之间的通信与同步,【gogofly原创】嵌入式操作系统分析（五）：进程间通信与同步...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程间通信与同步
作者：gogofly邮箱：
一、概述
在单任务系统中，任务是线性执行，任务不可能被抢占，所以不需要同步来保护共享资源与临界资源，同时单任务也不存在数据交换的问题，但对于多任务操作系统，会出现与但任务系统不同的问题，进程间通信与同步就是为了解决这些问题而提出的特有机制，它们为多任务系统提供了不同进程的通信机制，同时也提供了对于临界资源和共享资源的保护。
进程间通信与同步是多任务系统中的不同表现形式,，对于一些嵌入式操作系统，进程间通信与同步处于同一地址空间，这样使一些进程间通信机制同时可以用作同步机制，比如在UCOS中的一些进程间通信与同步机制。对于另外一些嵌入式操作系统中，进程间通信与同步处于不同的地址空间，它们是截然不同的两种机制，相互间没有什么联系(不包括同一进程中的不同线程同步)，最典型的就是嵌入式Linux中的进程间通信与同步机制。
二、进程间通信与同步区别与联系
在不同的嵌入式系统中，进程间通信与同步的实现方式有所不同，但是基本原理都差不多。对于进程间通信与同步，主要有2种方式：虚拟内存系统中的进程间通信与同步和Falt 内存系统中的进程间通信与同步。
Linux系统中的进程间通信是典型的虚拟内存系统中的进程间通信：Linux的进程间通信是不同进程间交换数据的机制。由于Linux系统支持虚拟内存，对于每一个进程，系统会为它分配一个单独的进程空间，不同的进程有不同的进程空间，相互之间没有什么关系，在这种系统中，不能用全局变量等一般的手段来实现不同进程间的数据交换，所以必须提供特有的数据交换机制：进程间通信。
同时此类系统中，由于内核空间是由不同的进程共享，所以在内核的数据可以由不同的进程共享，不同的进程也可能同时需要访问临界资源，同时要考虑内核中的中断，这种情况下，进程间的数据交换已经不是问题，现在的问题是如何保护临界资源和共享资源不被同时访问造成资源的紊乱，这就是Linux的同步机制。
UCOS是比较典型的Falt 内存系统，它不支持虚拟内存机制，也没有用户空间和内核空间的区别，实际上它就象是Linux的内核空间，不同任务间可以相互访问，没有不同进程间内存保护机制。所以可以完全利用Linux系统中的同一进程中不同线程的通信机制。由于所有的任务与中断都共享同一地址空间，所以同步机制也与任务间通信在同一空间中实现，是这2种机制的相互替换成为可能。
(待续)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bbfe3430cdca4f95bc50ec793ba28e2/" rel="bookmark">
			linux grep -11,11个高级Linux字符类和括号表达式的grep命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否曾经在你需要的一种局面搜索字符串，文字或图案的文件里面呢？ 如果是，那么grep工具来在这样的情况下派上用场。
grep的是为其匹配一个正则表达式搜索行纯文本数据的命令行实用程序。 如果您将分词的grep如 g/re/p，然后grep的含义是(全局搜索正则表达式和打印)的搜索模式从文件和打印屏幕即标准输出就行了。
grep的解释高级命令在Linux和Unix 字符类，比如操作系统。
在这里，我已经考虑howtoing.txt是基本文件，我们将搜索模式与grep命令的这篇文章中解释的帮助。
1.搜索字母数字字符
如果你有成千上万的文件中的行，想寻找一条线，将只从开始AZ ， az和0-9 ( 字母数字字符 )。
$ grep "^[[:alnum:]]" howtoing.txt
Grep - 在文件中搜索字母数字字符
2.搜索阿尔法字符
类似的选择，如果你要搜索线将从才开始像[AZ &amp; az]即Alpha Characters 。
$ grep "^[[:alpha:]]" howtoing.txt
Grep - 搜索文件中的Alpha字符
3.搜索空白字符
另一种选择，如果你要搜索线将从开始像[Tab &amp; Space]即空格字符 。
$ grep "^[[:blank:]]" howtoing.txt
Grep - 在文件中搜索空格或制表符
4.搜索数字字符
grep的数字选项也是搜索线将从数字开头非常有用[0-9]即数字字符 。
$ grep "^[[:digit:]]" howtoing.txt
Grep - 在文件中搜索数字字符
5.搜索下字母
grep的另一种选择是搜索线将从低字母即开始[az] 下Letters)上 。
$ grep "^[[:lower:]]" howtoing.txt
Grep - 搜索文件中的小写字母或词
6.搜索标点符号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bbfe3430cdca4f95bc50ec793ba28e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a3f6e404c309d25fdc7760c28bdacc/" rel="bookmark">
			Linux开发板usb读卡器,【小技巧】用SD卡传文件到开发板就是这么简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：【小技巧】用SD卡传文件到开发板就是这么简单！
主机开发环境: Ubuntu9.10
内核: Linux2.6.22.6(资料光盘-&gt; systems目录)
文件系统: fs_qtopia.yaffs2(资料光盘-&gt;bin目录)
开发板：JZ2440
目的：通过SD卡传文件到开发板
其实很简单，就一条挂载命令，为了适应0基础刚入手开发板的同学，写的特别详细。
步骤:
1. JZ2440接上电源，按红色开关启动系统
2. 电脑用数据线连接JZ2440 USB转串口“USB-COM1”
3. 设备管理器找到开发板串口对应电脑的是com 几(笔者的是com3)
4. 打开SecureCRT(在资料光盘-&gt;windows工具目录)，如下设置连接串口
点确定在串口看到板子的启动信息，然后回车进入SHELL
5、插入带SD卡的读卡器
预装板子已经有UBOOT内核文件系统，已支持常用读卡器、SD卡。系统启动后出现qt界面后插入装有SD卡(笔者用的是8G SandDISK SDHC卡)的读卡器，串口提示如下：
6、.列出分区表
$ fdisk –l
DeviceBoot只有一项，一看便知/dev/sda1就是刚刚插的SD卡
7、挂载SD
$ mount –t vfat/dev/sda1 /mnt
进入mnt目录，看看是否挂载成功，挂载成功后就可以操作SD的文件了。
不用时卸载SD卡
$ cd /
$ umount/mnt
卸载成功，mnt没东西了
注意：上文只考虑了开发板有系统的情况，假设开发板啥都没有。
你需要通过jlink或者eop下载uboot到板子(nand、nor均可)
然后上传linux 2.6.22.6以及补丁到ubuntu，解压打补丁编译：
$ tar xjflinux-2.6.22.6.tar.bz2
$ cd linux-2.6.22.6
$ patch -p1 &lt; ../linux-2.6.22.6_jz2440.patch
$ mv ../4.3寸LCD_mach-smdk2440.carch/arm/mach-s3c2440/mach-smdk2440.c // 替换4.3寸源码
$ cp config_ok .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a3f6e404c309d25fdc7760c28bdacc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9f9dd6c9f8ca8ce9caf9e510a652e7/" rel="bookmark">
			shell脚本练习大杂烩，总有一个案例是你需要的！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础的练习 1.检查用户家目录中的 test.sh 文件是否存在，并且检查是否有执行权限2.用case语句解压根据输入的后缀名为 .tar.gz 或 .tar.bz2 的压缩包解压到 /opt 目录3.提示用户输入内容，使用if 语句判断输入的内容是否为整数,再判断输入的内容是奇数还是偶数。4.用if 语句判断主机是否存活5.用case语句在/etc/init.d/目录中写一个firewalld脚本，并加入到系统服务管理中6. 使用while循环用“*”号画出两个正反等腰三角形7. 根据RAMDON生成8位随机密码，包括数字和字母8. 如何将数组的内容进行反转？9. 如果ping测试一系列ip是否正常并记录延时超过3ms的ip？10. 如何将last的结果中，独立出账号，并且显示曾经登录过的账号？11. 如何显示/bin 下面任何以a为文件名开头的文件的详细数据？12. 如何显示/bin 下面，文件名为四个字符的文件？13. 编写shell脚本实现十进制转二进制14. 如何显示/bin 目录下 不是a-d开头的文件15. 如果想让用户登录后，显示欢迎信息，该怎么操作？16. 编写脚本：获取输入的字符串中数字、空格和特殊符号的数量17. 对输入的用户名进行判断是否存在 1.检查用户家目录中的 test.sh 文件是否存在，并且检查是否有执行权限 #!/bin/bash # 1.检查用户家目录中的test.sh文件是否存在，并且检查是否有执行权限 # anthor:cheng cd ~ if test -e test.sh; then echo 该文件存在！ if test -x test.sh; then echo 该文件有执行权限! else echo 该文件没有执行权限! fi else echo 该文件不存在！ fi 测试结果：
2.用case语句解压根据输入的后缀名为 .tar.gz 或 .tar.bz2 的压缩包解压到 /opt 目录 #!/bin/bash read -p "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b9f9dd6c9f8ca8ce9caf9e510a652e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f425638c268217617cea9114a1d5a4/" rel="bookmark">
			Node.js的EventEmitter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Node.js的EventEmitter 一、Node.js EventEmitter简单介绍二、EventEmitter类 一、Node.js EventEmitter简单介绍 Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 二、EventEmitter类 events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。events模块是内置的模块，使用的是里面的eventEmitter类模块，主要功能是事件的发布和事件的监听功能。 方法描述on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数emit(event, [arg1], [arg2], […])添加监听once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。addListener(event, listener)为指定事件添加一个监听器到监听器数组的尾部removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 const events=require("events"); const emitter=new events.EventEmitter(); // 先监听事件 emitter.on("dosomething",(args)=&gt;{ console.log(args); }); // 一次性监听 emitter.once("sendmsg",(args)=&gt;{ console.log(args); }); let handle=(args)=&gt;{ console.log(args); } emitter.addListener("listen",handle); setTimeout(()=&gt;{ console.log(emitter.listeners()); // 不带参是移除所有的监听 emitter.removeAllListeners(); // 移除指定事件监听 emitter.removeListener("listen",handle); emitter.emit("dosomething","你好"); emitter.emit("sendmsg","一次性"); emitter.emit("sendmsg","一次性"); emitter.emit("listen","add"); },3000); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e652ffa3eaf1f0a5bc791aa705f8f04e/" rel="bookmark">
			node.js aes-256-cbc 加密 解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 使用 node.js 进行AES 加密解密，代码如下
代码 // Nodejs encryption with CTR const crypto = require('crypto'); const algorithm = 'aes-256-cbc'; const keyStr = '2ba27190770c3203a3094b1d212f5e2f' const ivStr = keyStr.substr(0, 16) const keyByte = Buffer.from(keyStr) const ivByte = Buffer.from(ivStr) function encrypt(text) { let cipher = crypto.createCipheriv(algorithm, Buffer.from(keyStr), ivByte); let encrypted = cipher.update(text); encrypted = Buffer.concat([encrypted, cipher.final()]); return { keyStr: keyStr, ivStr: ivByte.toString('hex'), encryptedData: encrypted.toString('hex'), rawBuffer: encrypted, base64Str: encrypted.toString("base64") }; } function decrypt(text) { let encryptedData = text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e652ffa3eaf1f0a5bc791aa705f8f04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd1b7f3f71d102a96ba16bf0c61ce51/" rel="bookmark">
			进程调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多文章分享在个人微信公众号：极客熊猫
欢迎扫码关注：
调度的概念 首先，在《进程与线程基础》一文中，我们已经了解到：
进程是资源分配的基本单位；线程是CPU调度的基本单位。 一个单核CPU在某一时刻只能允许一个线程执行，但是现在的计算机总是有一大堆进/线程等待执行。这就需要某种规则来决定处理这些进/线程的顺序，这就是调度要研究的问题。
回忆之前提到的进程状态：
运行态：当前正在占有CPU的进/线程；
就绪态：具备运行条件，等待系统分配CPU的进/线程；
阻塞态：不具备运行条件，正在等待某外部事件发生的进/线程。
所谓进程调度，就是指在处于就绪态的一堆进/线程里，按照一定的调度算法，选出一个进/线程并给它分配CPU时间让它运行，从而实现多进程/多线程的并发执行。
进程调度与线程调度尽管有些不同，但大部分是相同的，本文仅关注二者共同的部分。
进程切换的基本流程：
首先用户态必须切换到内核态；保存当前进程的状态，包括在其PCB中保存CPU各寄存器值，以便日后重新执行；调度算法选定一个新进程；新进程的内存地址空间重新装入MMU（内存管理单元）；新进程开始执行。 调度目标 所有系统 对于所有系统，都应该有以下调度目标：
公平——给每个进程公平的CPU份额；策略强制执行——保证规定的调度策略被执行；平衡——保证系统的所有部分都在忙碌。 批处理系统 批处理系统更适合非抢占式调度算法（见下文），应有以下调度目标：
吞吐量——每小时最大作业数；周转时间——从提交到终止的最短时间；CPU利用率——保持CPU始终忙碌。 交互式系统 交互式系统更适合抢占式调度算法（见下文），应有以下调度目标：
响应时间——快速响应请求；均衡性——满足用户的期望。 实时系统 对于实时系统，应有以下调度目标：
满足截止时间——避免丢失数据；可预测性——如多媒体系统中避免品质降低。 调度算法 进程调度的核心自然是调度规则，即各种调度算法。
计算机都有一个硬件时钟，也叫RTC或CMOS，它独立于操作系统，由主板上一块电池供电的芯片，所以即使计算机断电，RTC也可以维持时间。这个硬件时钟会周期性的发出时钟中断。
根据如何处理时钟中断，可以把调度算法分为两类：
非抢占式调度算法：发生时钟中断时不调度；抢占式调度算法：通过时钟中断使CPU控制权返回给调度程序，进而调度其它进程。 非抢占式调度算法：正在运行的进程只有在该进程执行完成或发生阻塞（如I/O请求）的情况下才会释放CPU；
抢占式调度算法：分给进程的时间片耗尽之后，无论当前进程有没有执行完成，调度程序均选择其他进程执行。
非抢占式调度算法 先来先服务 先来先服务算法（FCFS）：按照进程请求CPU的顺序调度它们。
意思就是，所有的就绪状态的进程在一个队列中，申请使用CPU的进程按照先来后到的顺序排在队列尾部，每执行完一个进程，系统就从该队列的头部取出第一个进程来执行。
优点：
易于理解且算法实现简单； 缺点：
对短进程不利。排在长进程后面的短进程需要等待很长时间，短进程的响应时间可能会很长。 最短作业优先 最短作业优先算法（SJF）：每次调度时选择当前已到达的、且运行时间最短的作业。
优点：
对比FCFS，平均等待时间、平均周转时间、平均带权周转时间均有提高； 缺点：
需提前掌握各作业的运行时间；
对长作业不利。因为如果一直有短作业到来，那么长作业永远得不到调度，长作业有可能会饿死，处于一直等待短作业执行完毕的状态。
周转时间：从进程请求CPU到进程执行完毕为止的统计平均时间。
非抢占式优先级调度 优先级调度：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。
对于非抢占式优先级调度，当一个进程到达就绪队列时，比较它的优先级与当前运行进程的优先级。如果新到达进程的优先级高于当前运行进程的优先级，非抢占优先级调度算法只是将新的进程加到就绪队列的头部，而不会进行进程切换。
缺点：
若有源源不断的高优先级进程到来，低优先级进程会导致饥饿。 抢占式调度算法 最短剩余时间优先 最短剩余时间优先（SRTN）：当一个新的进程到达时，把它所需要的整个运行时间与当前进程的剩余运行时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程等待。
优点：
可以使新的短进程得到良好的服务。 缺点：
需提前掌握各进程的运行时间；对长进程不利。 最短剩余时间优先（SRTN）是最短作业优先的抢占式版本。
轮转调度 轮转调度（RR）:每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段内运行。如果在时间片结束时该进程还在运行，则剥夺其CPU并分配给另一个进程；如果该进程在时间片结束前阻塞或结束，则立即进行进程切换。
轮转调度算法对每个进程都一视同仁，就好比大家都排好队，一个一个来，每个人都运行一会儿再接着重新排队等待运行。
优点：
易理解且算法易实现；可以兼顾长进程和短进程。 缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd1b7f3f71d102a96ba16bf0c61ce51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1705156def8161cd2fa25510a5b3aa4b/" rel="bookmark">
			C&#43;&#43; functional
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 std::function std::bad_function_callstd::bindstd::ref std::cref std::reference_wrapperstd::mem_fn 类模板std::function是通用多态函数封装器。 std::function的实例能存储、复制及调用任何可调用函数、 lambda表达式、 bind表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。 若 std::function 不含目标，则称它为空。调用空std::function的目标导致抛出std::bad_function_call异常。 std::function std::bad_function_call function是一个类模板，模板声明如下。
构造函数支持默认构造（空function，不是一个有效的function）、引用类型、右值引用、拷贝赋值运算符支持的类型也很全。重载了bool()可以用于判断function是否是有效的支持交互function重载了()，支持不定参数支持获取函数类型信息target_type template&lt;class&gt; class function; // undefined template&lt;class R, class... ArgTypes&gt; class function&lt;R(ArgTypes...)&gt; : public unary_function&lt;T1, R&gt; // iff sizeof...(ArgTypes) == 1 and ArgTypes contains T1 : public binary_function&lt;T1, T2, R&gt; // iff sizeof...(ArgTypes) == 2 and ArgTypes contains T1 and T2 { public: typedef R result_type; // construct/copy/destroy: function() noexcept; function(nullptr_t) noexcept; function(const function&amp;); function(function&amp;&amp;) noexcept; template&lt;class F&gt; function(F); function&amp; operator=(const function&amp;); function&amp; operator=(function&amp;&amp;) noexcept; function&amp; operator=(nullptr_t) noexcept; template&lt;class F&gt; function&amp; operator=(F&amp;&amp;); template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt;) noexcept; ~function(); // function modifiers: void swap(function&amp;) noexcept; // function capacity: explicit operator bool() const noexcept; // function invocation: R operator()(ArgTypes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1705156def8161cd2fa25510a5b3aa4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c32bc9e5110d34b7e0f3c5dfa88dfd2c/" rel="bookmark">
			Hashcat使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hashcat系列有3个版本，分别是hashcat、 oclhashcat-lite和oclhashcat-plus.
其中hashcat是利用CPU来暴力破解密码的，支持的算法是最多的，但是相比破解速度很慢。
oclhashcat-lite和oclhashcat-plus都是利用GPU来破解密码的，破解速度比利用CPU的hashcat快很多倍。
oclHashcat-plus支持使用GPU破解多个HASH，并且支持的算法高达77种。oclHashcat-lite只支持使用GPU对单个HASH进行破解，支持的HASH种类仅有32种，但是对算法进行了优化，可以达到GPU破解的最高速度。
必须指定的两个参数
攻击模式有
软件支持用户最多定义4组字符集
自定义字符集，从而用于设置掩码
如 hashcat64.exe -a 3 -m 100 --custom-charset1 ?l?d bdba993c7b4b1f5f407f9e24483a407ed85cbc3a ?1?1?1?1?1?1?1?1
使用暴力破解，设置字符集为 ?l?d 为小写字母和数字，hash类型为sha1，明文是八个小写字母和数字 因此掩码使用?1?1?1?1?1?1?1?1
基本使用方式 hashcat -m 哈希类型 -a 攻击类型 hash文件/字符串 字典/掩码（根据攻击类型决定输入）
按s键查看破解进度，p键暂停，r键继续破解，q键退出破解
1.使用字典进行破解
hashcat -a 0 0192023a7bbd73250516f069df18b500 password.txt --force
2.使用指定字符集进行破解
hashcat -a 3 63a9f0ea7bb98050796b649e85481845 ?l?l?l?l --force
3.使用字典+掩码进行破解
hashcat -a 6 1844156d4166d94387f1a4ad031ca5fa password.txt ?d?d?d --force
4.使用掩码+字典进行破解
hashcat -a 7 f8def8bcecb2e7925a2b42d60d202deb ?d?d password.txt --force
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd23f6a5dc0ac9e69592743aa33f3ac/" rel="bookmark">
			ProtoBuf的序列化和反序列化(基础库)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容说明： 说明下什么是ProtoBufProtoBuf的序列化和反序列化ProtoBuf的优势前后端使用ProtoBuf交互 ProtoBuf简介： Google 的 ProtoBuf ==&gt; 将文件转成二进制文件
protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。
Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。 你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏由旧数据结构编译的已部署程序。 使用ProtoBuf是定义(前后端) ==&gt; .proto类型
这个比较麻烦小编会在专门写一篇文件说明 ==&gt; 待补充（前后端使用ProtoBuf交互）
ProtoBuf和Json和xml的小结： XML、JSON、ProtoBuf 都具有数据结构化和数据序列化的能力XML、JSON 更注重数据结构化，关注人类可读性和语义表达能力ProtoBuf 更注重数据序列化，关注效率、空间、速度，人类可读性差，语义表达能力不足（为保证极致的效率，会舍弃一部分元信息）ProtoBuf 的应用场景更为明确，XML、JSON 的应用场景更为丰富 使用场景：
1、跨平台的RPC数据传输
或者说：需要和其它系统做消息交换的，对消息大小很敏感的，那么protobuf适合了，它语言无关，消息空间相对xml和json等节省很多
.
2、在一个需要大量的数据传输的场景中，如果数据量很大，那么选择protobuf可以明显的减少数据量，减少网络IO，从而减少网络传输所消耗的时间
ProtoBuf的序列化和反序列化： 1、引入依赖 &lt;!--引入protostuff依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;/dependency&gt; 2、将protobuf封装成基础库 package sqy.test01.util; import io.protostuff.LinkedBuffer; import io.protostuff.ProtostuffIOUtil; import io.protostuff.Schema; import io.protostuff.runtime.RuntimeSchema; import java.util.Map; import java.util.Objects; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd23f6a5dc0ac9e69592743aa33f3ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9aaf722825483f3a67af9d878c819b/" rel="bookmark">
			websphere 64位下载 linux,win10 ubuntu子系统安装Websphere8.5.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu子系统安装
ubuntu子系统的安装可以参考下面的网址，不过不用更新到Insider预览版了，最新正式版已经提供相关功能。https://linux.cn/article-7209-1.html
通过Xstart安装Websphere
Xstart远程连接配置如下：
遇到的问题
Installation Manager静默安装完后，需要通过Xstart执行/opt/IBM/InstallationManager/eclipse下的launcher，执行过程中会报缺失libgtk-x11-2.0.so.0库。网上说需要安装sudo apt-get install ia32-libs ia32-libs-gtk。实际上，ubuntu需要的早已经不是这俩库了，实际上我们需要的是：sudo apt-get install libgtk2.0-0。
安装完成后即可开始was的安装。
安装was
从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell)。所以在安装之前需要将默认的shell改成bash
进入到IM安装目录/opt/IBM/InstallationManager/eclipse，用XStart执行命令./launcher进入was的图形化安装向导。
安装完并创建节点AppSrv01后，进入到/opt/IBM/WebSphere/AppServer/profiles/AppSrv01/bin目录，执行./startServer.sh server1启动服务。若报错Program exiting with error: java.lang.UnsatisfiedLinkError:Ws60ProcessManagement(/opt/IBM/WebSphere/AppServer/lib/native/linux/x86_64/libWs60ProcessManagement.so: cannot enable executable stack as shared object requires: Invalid argument)
解决办法：执行命令execstack -c /opt/IBM/WebSphere/AppServer/lib/native/linux/x86_64/
libWs60ProcessManagement.so后，再重新启动服务。
设置was使用sdk7
进入WebSphere安装目录，如 /opt/IBM/WebSphere/AppServer/bin
执行命令：./managesdk.sh -listAvailable
设置当新建profile时默认使用sdk7
执行命令：./managesdk.sh -setnewprofiledefault -sdkname 1.7.1_64
设置当前所有profile使用sdk7
提示：有些linux环境设置profile使用sdk7后会导致was崩溃，如遇崩溃，则卸载并重装was至此步骤后，先执行下面的解决方案，再执行此步操作
执行命令：./managesdk.sh -enableProfileAll -sdkName 1.7.1_64 -user wasadmin -password wasadmin
查看所有profile 的sdk版本, 都为1.7时说明设置成功
执行命令：./managesdk.sh -listEnabledProfileAll
卸载was
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9aaf722825483f3a67af9d878c819b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec961316a5c0f7269535d2150b95da23/" rel="bookmark">
			opencv——图像遍历以及像素操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 我们在图像处理时经常会用到遍历图像像素点的方式，在OpenCV中一般有四种图像遍历的方式，在这里我们通过像素变换的点操作来实现对图像亮度和对比度的调整。
数据格式千万不要搞错:
uchar对应的是CV_8U，char对应的是CV_8S，int对应的是CV_32S，float对应的是CV_32F，double对应的是CV_64F。
补充： 图像变换可以看成
像素变换——点操作邻域变换——区域操作(卷积，特征提取，梯度计算等) 对于点操作：
q(i，j)=αf(i，j)+β
其中f(i，j)是输入点像素值，q(i，j)是输出点像素值。
1，数组遍历-- at&lt;typename&gt;(i,j) 说明：就是把图像看成二维矩阵，at(i,j)索引坐标位置，单通道直接得到坐标位置对应的像素值，三通道就这个位置代表了像素值的一维数组；
Mat类提供了一个at的方法用于取得图像上的点，它是一个模板函数，可以取到任何类型的图像上的点。这里选用参数α=1.5，β=0.5来提高图像亮度。
int main(int argc, char** argv) { Mat src; src = imread("D:/opencv练习图片/薛之谦.jpg"); imshow("Image", src); //创建一个和原图一致的空白图像 Mat dst = Mat::zeros(src.size(), src.type()); for (int i = 0; i &lt; src.rows; i++) { for (int j = 0; j &lt; src.cols; j++) { if (src.channels() == 1) //单通道遍历 { dst.at&lt;uchar&gt;(i, j) = src.at&lt;uchar&gt;(i, j) + 100; } else if (src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec961316a5c0f7269535d2150b95da23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/634c7437209a32102d83054aa3ace4cb/" rel="bookmark">
			手把手带你玩转k8s-健康检查之存活探针与就绪探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 经过前面的一系列文章，我们对k8s应该也算是简单的入门了。本文开始，会逐步开始讲解一些进阶的知识点。在前面的文章中，我们主要是围绕如何完整地发布一个可对外访问的服务。其中重点是以springboot+vuejs前后端分离项目为主的。后续的文章也会是围绕springboot+vuejs，不过会基于其扩展一些新的服务，如redis、rabbitmq、elk等。
关于健康检测 健康检查（Health Check）是让系统知道您的应用实例是否正常工作的简单方法。 如果您的应用实例不再工作，则其他服务不应访问该应用或向其发送请求。 相反，应该将请求发送到已准备好的应用程序实例，或稍后重试。 系统还应该能够使您的应用程序恢复健康状态。
默认情况下，当 Pod 中的所有容器启动时，Kubernetes 开始向 Pod 发送流量，并在崩溃时重新启动容器。如果Pod启动后就立即对外服务，其实是不太合理的。因为Pod启动成功并不代表容器里面部署的服务就能对外服务了，比如springboot项目，容器启动成功后，springboot启动需要一些初始化工作，真正要能对外访问，快则需要几秒，慢则需要十几、二十秒，甚至更久。 Kubernetes 在设计上已经考虑到了这点，它可以通过创建自定义运行状况检查来使部署更加健壮 。这里涉及到一个关键字：容器探针。
容器探针 探针是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 Handler。有三种类型的处理程序：
ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。CPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。 每次探测都将获得以下三种结果之一：
成功：容器通过了诊断。失败：容器未通过诊断。未知：诊断失败，因此不会采取任何行动。 Kubelet 可以选择是否执行在容器上运行的两种探针执行和做出反应：
livenessProbe(存活探针)：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 重启策略的影响。如果容器不提供存活探针，则默认状态为 Success。readinessProbe(就绪探针)：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 Failure。如果容器不提供就绪探针，则默认状态为 Success。 高级 liveness 探针示例 探针的定义，也是k8s编排的重要内容。
apiVersion: apps/v1 kind: Deployment metadata: name: mldong-admin namespace: mldong-admin-test spec: selector: matchLabels: app: mldong-admin replicas: 1 template: metadata: labels: app: mldong-admin spec: containers: - name: mldong-admin env: - name: TZ value: Asia/Shanghai image: registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/634c7437209a32102d83054aa3ace4cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f617aa04ebd474afdfeb42cf1b7cd3/" rel="bookmark">
			linux救援模式应用,Linux系统救援模式的简单介绍及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、救援模式的前言
当我们一不小心把linux系统文件删除了，导致无法开机或者某些程序无法使用。linux为我们准备了救援模式(Rescue)！进入救援模式即可进入小型系统进行操作，进行恢复。
当服务器出现问题不能启动的时候，可以用救援模式恢复；
root密码忘记了，又配置了grub密码的时候，可以用救援模式来修改root密码。
救援模式就是进入一个运行于内存的小型Linux系统(救援系统)，有点类似于windows下的PE系统。
二、救援模式的介绍
实验一：centos6救援模式的介绍
1、进入救援
重启计算机，鼠标点入，在滚动条滚动的任意期间按下 ESC 键，此刻就进入到救援模式；
2、进入启动项选择界面：在这里我们选择第三项光盘启动，选择驱动器驱动
3、选择第三项；
4、等待一段时间，选择需要的语言；
之后选择默认选项即可；
5、当前在救援模式下不需要使用网络设置可以选择no(左右键选择)并回车；
之后选项默认即可；
6、选择第一项，获得一个shell；
注：centos6 中的重启为图中的第三项。(在此shell中输入exit后，跳转到此页面选择第三项)
df 查看各分区挂载情况
chroot /mnt/sysimage 切换根环境
实验二：centos7的救援模式介绍
1、进入救援
重启计算机，鼠标点入，在滚动条滚动的任意期间按下 ESC 键，此刻就进入到救援模式；
2、进入启动项选择界面：在这里我们选择第三项光盘启动，选择驱动器驱动
3、通过键盘上下键的移动选择第三个选项；
4、按下enter键，获得shell；
df 查看各分区挂载情况
三、救援模式的实战
在我的博客中有一篇文章，详细介绍了救援模式的实战内容。
安全链接：https://blog.51cto.com/13869720/2164266
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e508b704b7e79d2762697b9fd5bb920d/" rel="bookmark">
			linux kernel.sem参数,kernel.sem参数的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以理解为semaphore为每个进程通讯需要的信号灯或者IPC标志,每个连接的process都要分配一个semaphore,那么
semaphore的设置跟process的数量有关系.
semaphors的相关设置在REHL、OEL中可
通过kernel.sem参数定义.通过下面的任何一种方法都可以查看sem的值:
[root@dbtest vm]# sysctl -p|grep kernel.sem
kernel.sem = 250 35000 100 128
或者
[root@dbtest vm]# cat /proc/sys/kernel/sem
250 35000 100 128
或者
[root@dbtest vm]# ipcs -sl
------ Semaphore Limits --------
max number of arrays = 128
max semaphores per array = 250
max semaphores system wide = 35000
max ops per semop call = 100
semaphore max value = 32767
这个参数有四个值, 其实这四个不同的值又分别对应了另外四个不同的参数,按照上面值的顺序排列
SEMMSL: Maximum number of semaphores per set
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e508b704b7e79d2762697b9fd5bb920d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506e2f176a4e08eba3dc104903c31bbc/" rel="bookmark">
			.NET加密打包教程一（.NetReactor加密）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景.NetReactor加密FilesSettingsLicense ManagerSave ProjectProtect更多 背景 手头上做的一个项目临近工期，需要加密打包交付。由于系统比较简单，用户范围较为狭窄，所以系统只需要进行简单的代码混淆和系统加壳处理即可，目的是保护知识产权，防止随意拷贝。
系统采用VS平台&amp;C#语言进行开发，经过一番摸索查阅和多次踩坑，最终选用.NetReactor进行加密，并使用AdvancedInstaller进行打包。（~~简单易上手）
.NetReactor加密 加密过程很简单，最终通过授权文件对用户提供授权。如下步骤：
Files 1.点击Open加载需要加密的文件（一般是exe文件）
2.点击Add添加其它需要加密的文件（诸如dll文件等）
3.设置加密方式（对于加密要求不高的需求来说，一般勾选下图三项即可，过多的加密或导致程序不可用）
Quick Settings含义如下：
NecroBit：把程序集转为非托管代码Native Exe File：生成本机 Exe 文件Anti ILDASM：反编译Obfuscation：混淆Create Mapping File：创建地图文件Anti Tampering：防篡改String Encryption：加密字符Compress &amp; Encrypt Resources：压缩并加密资源Control FlowObfuscation：混淆控制流 Settings 在 Settings下可以自定义自己的设置需求。我这里的需求是系统有授权文件才可运行，所以设置Lock Settings下的Run Without License File为Flase.
License Manager 1.Master Key是软件唯一标识码，应保存下来，以后的授权需要用到。
2.采用一机一码的授权文件进行授权，所以需要根据Hardware ID生成授权文件，点击…按钮导入机器码。机器码的产生如下：
点击菜单栏Tools，选择Hardware ID Tool Generator-&gt;点击Generate按钮，生成HID.exe到保存路径下。
运行HID.exe即可生成该机器ID(对用户授权时，应在用户主机上运行HID.exe生成机器ID)，将生成的HardwareID.txt导入Hardware ID即可。
3.可对许可文件添加自定义信息，点击Create License生成授权文件。
Save Project 对项目模板进行保存，方便以后使用。
Protect 点击Protect即可生成加密后的文件。（默认程序目录下新建XXX_Secure文件夹存放加密后文件，发布时将加密后的文件进行打包发布）
更多 更多操作可参考其他详细教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1614b91989badae4f4382ad3753f0ae0/" rel="bookmark">
			Android 智能密码管理，自动填充背景变为黄色（部分机型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方案一：
关闭自动密码功能： android:importantForAutofill="no" 解决方案二：
设置activity主题色：android:autofilledHighlight设置为你想要的颜色，我设置的透明色
&lt;style name="Login.Light_AppCompat" parent="Theme.AppCompat.Light"&gt; &lt;item name="android:autofilledHighlight"&gt;@color/transparent&lt;/item&gt; &lt;/style&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4de8da51d12e7e6901311cdcde7bd48/" rel="bookmark">
			关闭所有Activity，然后打开某个Activity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Activiy启动flag，Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK，新Activity将成为一个空栈中的新的最底端activity，且旧Activity都会被finish掉。
原本Android中的每个界面都是在栈1里的，现在把栈1的所有界面清空，新建一个栈2，把这个activity放在栈2里，大致就这个意思。一般强制退出登录需要用这个标志位，防止点击返回还能返回到之前内部界面。
Intent intent = new Intent(this, LoginActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb6c61e20cf2377d3c8613306ded1c8/" rel="bookmark">
			Python---从文本中提取中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用正则从文本中抽取中文文本 import re text = "中国面积为960万平方公里" regStr = ".*?([\u4E00-\u9FA5]+).*?" ch = re.findall(regStr, text) # 返回列表 if ch: print(ch) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/183/">«</a>
	<span class="pagination__item pagination__item--current">184/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/185/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>