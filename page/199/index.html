<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330a3430a96fc124c1b1023ddd890e2d/" rel="bookmark">
			python中round(x、2)是什么意思_python中round函数具体使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		round函数是python中的内置函数，它在哪都能用，用于数字的四舍五入。当指定的位数大于 0，返回四舍五入到指定的小数位；当指定的位数等于 0，返回四舍五入到最接近的整数，保留整数部分；当指定的位数小于 0，对整数部分进行四舍五入，返回的结果是浮点数。具体使用过程请看本文。
一、语法round(number,num_digits)
二、参数
number：需要四舍五入的数
digits：需要小数点后保留的位数；
三、返回值
指定的位数大于 0，返回四舍五入到指定的小数位；
指定的位数等于 0，返回四舍五入到最接近的整数，保留整数部分；
指定的位数小于 0，对整数部分进行四舍五入，返回的结果是浮点数。
四、使用实例
1、指定的位数大于 0，返回四舍五入到指定的小数位；
保留2位小数：&gt;&gt;&gt; s = 1.234567
&gt;&gt;&gt; result = round(s, 2)
&gt;&gt;&gt; print(result)
1.23
&gt;&gt;&gt; s = 1.23567
&gt;&gt;&gt; result = round(s, 2)
&gt;&gt;&gt; print(result)
1.24
2、指定的位数等于 0，返回四舍五入到最接近的整数，保留整数部分；print("round(123.456789,0)的值为：",round(123.456,0))
输出round(123.456789,0)的值为： 123.0
3、指定的位数小于 0，对整数部分进行四舍五入，返回的结果是浮点数。round(-0.5) #-1.0
以上就是python中round函数的具体使用详解，希望能对你有所帮助哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a013459442965363928826330f5fa0/" rel="bookmark">
			YARN 作业 Staging目录的用途及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 staging目录的用途MapReduce作业Staging的配置示例 Spark 作业Staging目录的配置示例 staging目录的用途 关于staging目录可能很多人都不太会关注，毕竟日常运行作业也用不到这些配置。不过了解它对于我们理解作业的执行流程也是有所帮助的，比如我们都会使用hadoop jar 或 spark-submit等命令来提交一个MR或Spark作业，然后我们就会看到在集群的某些计算节点上启动executor(MapRedece对应的是mapper和reducer)来执行任务。这些executor都是一个JVM进程，既然如此，那么启动一个JVM进程必然需要用到至少一个jar包，那这些jar包是从哪里来的呢？此时就用到了staging 目录（有人把staging翻译为舞台目录，这也有一定的含义，提交作业，就要登上集群这个舞台了）了。提交作业的时候，会把相关的jar包和配置信息都上传到这个staging目录下，然后在启动executor之前，会从这里将这些信息下载到计算节点本地。
MapReduce作业Staging的配置 yarn.app.mapreduce.am.staging-dir：提交mapreduce作业的staging目录，默认是/tmp/hadoop-yarn/stagingyarn.app.mapreduce.am.staging-dir.erasurecoding.enabled：staging目录下的文件是否使用纠删码方式存储，默认false，这可以在提交作业时指定mapreduce.client.submit.file.replication：提交到staging目录下的文件的副本数，默认是10mapreduce.job.split.metainfo.maxsize：split元数据信息文件的最大大小，默认10000000，超过该大小AppMaster将不会再读取。设置为-1，则表示不限制该文件的大小。这个文件通常不会很大，一般也不会去单独设置 示例 下面从一个实际的MR作业来看一下stageing目录中的内容，可以看到文件job.jar和job.split以及libjars目录中的文件副本数都是10，这个10就是由配置项mapreduce.client.submit.file.replication指定的
下面通过提交一个测试作业验证一下这个配置项，指定mapreduce.client.submit.file.replication为12
作业提交后，查看对应的staging 目录文件，如下，说明配置参数生效了
最后解释一下这些文件的副本为什么是10呢，难道3副本还不能满足数据安全的要求吗？这里其实涉及到MR作业运行时的一个步骤就是资源本地化，本文开头已经介绍过staging目录的作用了，而比如一个MR作业的mapper有几百几千个的时候，那么就意味着会有上千的客户端会同时下载这个jar包，此时将这个jar包的副本数设置的大一点可以提高资源本地化的效率，而反之如果只是一个很小的MR作业，这么高的副本数就是浪费了。这也侧面说明了MR的设计初衷就是面向大规模数据的。
Spark 作业Staging目录的配置 下面是spark on yarn模式下的配置
spark.yarn.submit.file.replication：提交作业时上传到HDFS相关文件的副本数，默认是HDFS的默认副本数，通常是3spark.yarn.stagingDir：提交作业时的staging目录，默认是用户的家目录spark.yarn.preserve.staging.files：在提交作业时的staged 文件(Spark jar, app jar, distributed cache files) 在作业结束时是否保留，默认false，也就是作业执行结束后进行删除 示例 下面从一个实际的Spark作业来看一下stageing目录中的内容
可以看到，和MR作业的Staging目录相比，spark并未将spark的jar包设置为10副本；而且把配置信息和jar包分别进行了压缩，结构相对简单一点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68ea26a32cccdff1287857126a64b18/" rel="bookmark">
			iphone图片编辑画笔_苹果超强新功能上线！它打开了 iPhone 摄影的新大门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于 iPhone 来说，iOS 14.3 正式版的到来，应该是一个重要的里程碑。
iOS 14.3 包含了诸多功能的改进，如空气质量指数回归、升级了基带版本、新增了 Safari 的搜索引擎 Ecosia 等等。其中最重要的升级，当属为 iPhone 12 Pro，以及 iPhone 12 Pro Max 系列新增的 ProRAW 格式。
iPhone 12 Pro 系列用户，只需要在设置页面中，找到「相机」，再点击「格式」，便可开启「Apple ProRAW」。这时再返回相机应用，便可在右上角看到「RAW」的开关标识。
点击「RAW」，当其图标上的斜线消失时，便能够以 RAW 格式拍摄照片。不过每次退出相机应用再打开时，RAW 格式默认为关闭状态。
如果你不想让相机应用重置你的设置，那么你可以在「设置」-「相机」-「保留设置」里，将「Apple ProRAW」的开关打开。如此一来，相机应用就会保留你对 RAW 格式的开启状态。
在 iOS 14.3 正式版发布之前，我已经手持 iPhone 12 Pro Max，体验了近一个月的 Beta 版。在这段时间内，我对 ProRAW 格式进行了深度体验。可以说它的到来，是 iPhone 摄影发展史上最重要的升级之一。
ProRAW 是什么？ 作为 iPhone 12 Pro 系列独享的功能，苹果在秋季新品发布会上，曾将这一功能作为主要卖点加以介绍。
在了解 Apple ProRAW 之前，我们需要知道什么是 RAW 格式。
RAW 格式的原名是「RAW Image Format」，意思就是「未经加工」。以 RAW 格式记录下来的图像，是影像传感器将捕捉到的光源信号，转化为数字信号的原始数据。
▲ 图片来自：capture one
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e68ea26a32cccdff1287857126a64b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35dd7822b38e42ec3ff88f59c6276c90/" rel="bookmark">
			java计算数据的百分比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 有这样一个需求，需要计算一个集合中的数据占集合总数的百分比，这里做一个简单的记录。
java计算数据的百分比 实现代码如下：
import java.text.DecimalFormat; import java.text.NumberFormat; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; public class Test3 { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(15); list.add(21); list.add(41); // 计算集合数据的总数 int sum = list.stream().mapToInt(value -&gt; value).sum(); System.out.println("print getPercent -------------"); List&lt;String&gt; collect = list.stream().map(a -&gt; getPercent(a, sum)).collect(Collectors.toList()); System.out.println(collect.toString()); System.out.println("print getPercent2 ------------"); List&lt;String&gt; collect2 = list.stream().map(a -&gt; getPercent2(a, sum)).collect(Collectors.toList()); System.out.println(collect2.toString()); } /** * 方式一：使用java.text.NumberFormat实现 * @param x * @param y * @return */ public static String getPercent(int x, int y) { double d1 = x * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35dd7822b38e42ec3ff88f59c6276c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d6b76d922cb465e84d6a873f93b358/" rel="bookmark">
			Oracle数据库备份还原——物理备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 冷备份 异机恢复操作案例备份异机恢复 当一个阶段性系统使用完后，需要备份完全的数据库，此时使用冷备份再合适不过了。冷备份需要知道源机与目标机Oracle安装位置和文件系统位置，是一种非常快速的备份方法。源Oracle和目标Oracle版本需要一致。 冷备份 1、 冷备份发生在数据库已经正常关闭的情况下
2、冷备份所需备份的文件包括以下几种：
所有数据文件（datefile）、所有控制文件（controlfile）、所有联机REDO LOG 文件（logfile）、密码文件
3、冷备份的步骤
①正常关闭要备份的实例（instance）
②拷贝物理文件到指定备份路径或设备。
③完成备份后启动数据库
异机恢复 背景：目标机已安装数据库，且未创建同名实例
1、在目标机上的oradata目录下建立orcl文件夹，拷贝源机的所有data文件和联机redo文件到此目录下。
2、在目标机上的admin目录下建立orcl文件夹，然后在orcl里面再建立adump、bdump、cdump、udump、dpdump、pfile六个文件夹。
3、使用oradim命令在cmd下oradim -new -sid orcl 表示建立一个服务，sid为orcl（最好名字和源机备份的数据库名字一致，就不需要重建密码文件）。
4、拷贝源机的pfile到目标机的一个目录下，修改pfile里面相关文件的路径，然后通过SQL&gt;create spfile from pfile=‘文件路径’来创建参数文件。
5、重建控制文件。
6、用net configuration为orcl实例新建监听。
7、还原临时工作空间文件。
操作案例 冷备份数据必须是数据库不在open状态下。以Windows环境下oracle11gR2为例，备份恢复orcl实例。
备份 备份脚本如下：
spool D:/Other-shore/oradata/lengbei/bf.sql select 'COPY "'||name||'" "D:/Other-shore/oradata/lengbei"' from v$controlfile union all select 'COPY "'||name||'" "D:/Other-shore/oradata/lengbei"' from v$datafile union all select 'COPY "'||member||'" "D:/Other-shore/oradata/lengbei"' from v$logfile / create pfile='D:/Other-shore/oradata/lengbei/initorcl.ora' from spfile; alter database backup controlfile to trace as 'D:/Other-shore/oradata/lengbei/databasectl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d6b76d922cb465e84d6a873f93b358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73399248f8b04691f10dc80356af6b03/" rel="bookmark">
			Java的封装——小白篇(11)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装 封装就跟字面意思一样就是把东西装起来装在箱子里只留一个口让别人拿.
比如说：手机大家都不陌生吧！大家不用说都玩的比我还六，这就是产家为了用户更容易上手将复杂的东西包装成一个盒子只留下屏幕和开关，用户不用了解手机是怎么做的，也能操作666的。这就是封装。
该露的露，该藏的藏我们程序设计要追求：高内聚，低耦合，高内聚就是类的内部数据细节自己完成，不允许外部干涉，低耦合仅暴露少量的方法给外部使用。封装
通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，称为信息隐藏。
记住一句话：属性私有，get/set 代码： 待续。。。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4877ad74e06436f5a5a173ab57f23e/" rel="bookmark">
			nn.AdaptiveAvgPool2d() 与 nn.AvgPool2d() 模块各自的用途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先介绍一下我为啥会关注到这个问题，因为我在使用加了SE模块的Resnet的时候，程序出bug了，原来问题出在我使用了nn.AvgPool2d() ，而应该使用nn.AdaptiveAvgPool2d() 。
1. 问题 下边是我写的SEResnet模块的代码，然后我会贴出我程序报的错误：
class SEResNet(nn.Module): def __init__(self, block, layers, num_classes=1000): self.inplanes = 64 super(SEResNet, self).__init__() self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False) self.bn1 = nn.BatchNorm2d(64) self.relu = nn.ReLU(inplace=True) self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1) self.layer1 = self._make_layer(block, 64, layers[0]) self.layer2 = self._make_layer(block, 128, layers[1], stride=2) self.layer3 = self._make_layer(block, 256, layers[2], stride=2) self.layer4 = self._make_layer(block, 512, layers[3], stride=2) self.avgpool = nn.AvgPool2d(7, stride=1) self.fc = nn.Linear(512 * block.expansion, num_classes) for m in self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4877ad74e06436f5a5a173ab57f23e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6390b4388530990168ed921538d3801/" rel="bookmark">
			卷积神经网络系列之卷积/池化后特征图大小怎么计算？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.卷积后的大小： W：矩阵宽，H：矩阵高，F：卷积核宽和高，P：padding（需要填充的0的个数），N：卷积核的个数，S：步长
width：卷积后输出矩阵的宽，height：卷积后输出矩阵的高
width = （W - F + 2P）/ S + 1（向下取整）
height = （H - F + 2P） / S + 1（向下取整）
当conv2d(), max_pool() 中的 padding=SAME时，width=W，height=H，则保证输入输出尺寸图片大小相等，当padding=‘valid’时，P=0，相当于不填充~~
输出图像大小：（width，height，N）其中N代表的卷积核的个数就是在卷积操作中起到的分为N个通道数的作用
当卷积操作中含有膨胀因子d: 当卷积操作中含有膨胀因子d，且padding=pad，k为卷积核尺寸，stride为步长时：
out = （W - (F* d-1)+2* pad）/ S + 1(W、H相同)
2.池化后的大小： width = （W - F）/ S + 1（向下取整）
height = （H - F） / S + 1（向下取整）
⭐在深度学习中，可能对特征图的计算，tensorflow和pytorch的padding计算不同。
1. 在tensorflow中：如果你想要输出等于输入，padding="SAME"即可，如果你想要输出别的尺寸的特征图，使用padding=‘VALID’，conv2d会自动计算输出特征图大小。
2. 在pytorch中：pytorch里面没有same和valid，所以你想要保持输出等于输入，要利用pad=t，t为填充尺寸，以保持输入输出特征图相等。
3.上采样UpSampling2D 上采样相当于放大多少倍，size=倍数，
卷积操作：
stride=[1,1,1,1]时：
padding=‘SAME’，卷积操作后图片大小不变
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6390b4388530990168ed921538d3801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c733d918b4b2455453fc34e07c9b9e/" rel="bookmark">
			使用Feign，模块之间调用传递参数HttpServletRequest request拿不到值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
spring boot 项目，多模块之间使用Feign调用，请求方的request对象在传递的过程中丢失，服务方request对象中没有相应值。
初始状态：
feign接口
@PostMapping("/xxxx")
@ApiOperation(value = "xxxx", notes = xxxx")
RestResult&lt;JSONObject&gt; testFeign() throws Exception;
实现：
@PostMapping("/xxxx")
@ApiOperation(value = "xxxx", notes = xxxx")
@Transactional(rollbackFor = Exception.class)
public RestResult&lt;JSONObject&gt; testFeign(@Autowired HttpServletRequest request) throws Exception{
}
调用：
feignClient.testFeign();
结果：
request中没有请求头中没有相应数据。
解决过程：
尝试修改参数注解，在feign接口中增加参数。依然拿不到。
解决方案：
修改feign配置
public class NativeFeignConfig { @Bean public RequestInterceptor getRequestInterceptor() { return new RequestInterceptor() { @Override public void apply(RequestTemplate requestTemplate) { ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes(); HttpServletRequest req = servletRequestAttributes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c733d918b4b2455453fc34e07c9b9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8e185390a14a1c793176b190819932/" rel="bookmark">
			【点云PCL入门】点云滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 1.直通滤波器-PassThrough2.点云下采样-VoxelGrid3.删除离群值-StatisticsOutlierRemoval4.使用参数模型投影点云-ProjectInliers5.基于分段算法输出的索引提取点云中的子集-ExclIndices6.ConditionalRemoval和RadiusOutlierRemoval移除离群点7.CropHull任意多边形内部点云提取参考 1.直通滤波器-PassThrough 对指定的某一维度实现滤波，去掉在用户指定范围内部（或外部）的点。
#include&lt;pcl/point_types.h&gt; #include&lt;iostream&gt; #include&lt;pcl/filters/passthrough.h&gt; int main(int argc, char* argv[]) { pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); //填充点云 cloud-&gt;width = 5; cloud-&gt;height = 1; cloud-&gt;points.resize(cloud-&gt;width*cloud-&gt;height); for(auto&amp; point:*cloud) { point.x = 1024 * rand() / (RAND_MAX + 1.0f); point.y = 1024 * rand() / (RAND_MAX + 1.0f); point.z = 1024 * rand() / (RAND_MAX + 1.0f); } std::cerr &lt;&lt; "Cloud before filtering: " &lt;&lt; std::endl; for (const auto&amp; point : *cloud) std::cerr &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e8e185390a14a1c793176b190819932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eefdb55565fc5d9bf00d22ab9fc9a49/" rel="bookmark">
			CSS3中  的  calc() 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的是动态改变宽度/高度的变化，适配问题 css3 的 calc()函数。这里的意思是设置宽度比100%的宽度少30px。
calc()函数用于动态计算长度值。
calc()函数支持 "+", "-", "*", "/" 运算；
calc()函数使用标准的数学运算优先级规则； 注意 : 运算符"+ - * /"左右两边均要留空格 在less中使用以下样式宽度计算错误: width: calc(100% - 30px); 计算出来是:width: 70%; 分析 : px也被解析成%进行了运算，这个的原因是calc属性在less下解析时会忽略运算的单位，统一使用第一个数值的单位（注意：很多文章上写的是按照百分比处理，这个说法是不正确的, 例如将100%换为100em，最终的结果是21em）
解决方法:
1、width: calc(~"100% - 30px");
"~"是less语法中的转义字符，允许你使用任意字符串作为属性或变量值。所以不会进行计算，将最终的计算交给了calc
2、width: e("calc(100% - 30px)");
"e"是一个方法，也是less中提供的。功能其实也是转义，接收一个字符串，返回一个不经任何处理的字符串，也是将最终的计算交给了calc
参考文章:https://blog.csdn.net/qq8241994/article/details/108010648 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f78dc1705f2dc1fa9e8970fbff9226/" rel="bookmark">
			AltiumDesigner 设置焊盘在钢网上是否开孔的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AltiumDesigner 设置焊盘在钢网上是否开孔的办法 time : 2019-07-13 10:24 作者：凡亿pcb
“Top Paste”层为锡膏层，也就是钢网是否开孔，可以直观看到钢网开孔位置。
焊盘属性为“Multi-Layer”时，默认钢网不开孔；一般情况下插件焊盘属性为“Multi-Layer”。
焊盘属性为“Top Layer”或“Bottom Layer”时，默认钢网开孔；此时一般为贴装元器件。
如果单面焊盘，设计时需要开窗露铜且不想钢网开孔（禁止刷锡膏），可以如下设置：
设置“Specify expansion value”小于“X-Size/Y-Size”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9258a00dca9fb8ed6bfaeb3b050fb28f/" rel="bookmark">
			在anaconda虚拟环境并且在虚拟环境中安装包，有效有效！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、建立虚拟环境 我也是在网上查找资料，然后自己摸索总结出来的，现在记录下来，避免以后遗忘
1、打开anaconda（我使用的是python的发行版anaconda） 1、打开Anaconda Navigator，选择Environments2、在选择Environments以后，选择create，创建3、在弹出来的对话框中输入你要创建的虚拟环境名称，和选择创建的语言，包括python和R4、并且可以进一步选择所创建的虚拟环境使用的python版本5、然后点击create，环境创建完毕6、命令行创建虚拟环境
conda create -n name python=xx(python版本)7、退出虚拟环境
deactivate name
-8、删除虚拟环境
conda remove name --all 2、激活虚拟环境 1、打开Anaconda Prompt2、输入命令activate name（name为你需要激活的虚拟环境的名称）3、回车执行以后，你会发现已经进入你所创建的虚拟环境 二、在虚拟环境中安装所需要的包 在上一步激活虚拟环境的基础上安装包 使用命令 pip install name使用命令 conda install name 然后就可以测试是否安装完成 三、我使用的是VS Code 编辑器，在VS Code 中怎样选择虚拟环境 1、创建一个文件夹，里面包含你所要创建 的工程，以及你想要使用的环境2、环境可以在第一步创建完成后直接拷贝3、在工程文件目录下创建一个python文件，并且运行4、在VS Code 左下角的编译器选择上点击，会在上部中间位置出现环境选择的对话框5、选择你工程所使用的环境，然后就OK了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/155cd169c5787292bdca4ea07fc2325d/" rel="bookmark">
			python安装sklearn，亲测有效！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自：http://blog.csdn.net/qq_21904665/article/details/52681176
可直接用这行命令！： pip install -U scikit-learn 其他命令： （1）更新pip python -m pip install --upgrade pip （2）安装 scipy 在网址http://www.lfd.uci.edu/~gohlke/pythonlibs/ 中找到你需要的版本scipy
例如windows 64 位 Python2.7 对应下载:scipy-0.18.0-cp27-cp27m-win_amd64.whl
cd 下载scipy 目录下，安装
pip install scipy-0.18.0-cp27-cp27m-win_amd64.whl （3）安装 matplotlib pip install matplotlib （4）安装numpy+mkl 在网址http://www.lfd.uci.edu/~gohlke/pythonlibs/ 找到你需要的numpy+mkl版本
然后 cd 到numpy+mkl所在的目录下，安装
pip install numpy-1.11.1+mkl-cp27-cp27m-win_amd64.whl pip install -U scikit-learn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65473526796c59d8680e7ef9eef9208c/" rel="bookmark">
			【NiosII训练】第五篇、FPGA驱动DHT11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一部分、前言
1、闲话
第二部分、题目要求
1、图片
2、文字描述
3、dht11知识
第三部分、工程代码
1、软核的搭建
2、顶层文件的代码
3、Ecplise代码
第四部分、总结
1、效果演示
2、感想
3、完整工程
第一部分、前言 1、闲话 还是一样，这个设计也是我们《SOPC技术及应用》课程结束的期末作业。我自己的是老师题库里的第题、驱动AD9854这个模块，题目要求在第一篇已经说到了，想回去看的铁子们可以回去看。
这一题是我室友的，报酬是给我买一杯奶茶（结果没给，我亏大发了😭😭😭），效果如下：
第二部分、题目要求 1、图片 2、文字描述 使用FPGA调通DHT11温湿度传感器，并能够将温度和湿度实时显示在lcd上，系统需要使用ucosii操作系统。
3、dht11知识 关于DHT11的知识，你到CSDN搜一下，出来一大把，有些博主很详细的讲述了这个模块的工作原理，我这里就不做详述了。
第三部分、工程代码 1、软核的搭建 2、顶层文件的代码 module AC620_GHRD( input wire clk, // clk.clk input wire reset_n, // reset.reset_n output wire lcd_rst, // lcd_rst.export output wire lcd_rd_n, // lcd_rd.export output wire lcd_bl, // lcd_bl.export output wire lcd_wr_n, // lcd_wr.export output wire lcd_rs, // lcd_rs.export output wire lcd_cs_n, // lcd_cs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65473526796c59d8680e7ef9eef9208c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c297955fcb1db9bfc5eb93e67fcd1382/" rel="bookmark">
			su -s /bin/sh -c “nova-manage api_db sync“ nova报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你遇到su -s /bin/sh -c “nova-manage api_db sync” nova错误提示是这个时
解决方法：
进入/usr/lib/python2.7/site-packages/oslo_messaging/transport.py修改558行为
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8659240350f3be7b7dd369152926065b/" rel="bookmark">
			C语言 字符串加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 输入一串字符（长度不超过100）和一个正整数k，将其中的英文字母加密并输出加密后的字符串，非英文字母不变。加密思想：将每个字母c加一个序数k，即用它后面的第k个字母代替，变换公式：c=c+k。如果字母为z，则后一个字母是a，也就是字母字符形成一个圆。
Input 输入第一行是若干字符，以回车结束。输入第二行是一个整数k，k是int范围内的正整数； Output 输出加密后的字符串。 Sample Input 12kjsdZjk 280 Sample Output 12edmxTde Source Code #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(void) { char a[101]; int k; gets(a); scanf("%d",&amp;k); k%=26; for(int i=0; i &lt; strlen(a); i++) { if(a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z') a[i] = ((a[i] - 'a' + k) % 26) + 'a';	//只能减去该字母本身 if(a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z') a[i] = ((a[i] - 'A' + k) % 26) + 'A'; } puts(a); return 0; } Computational Results Hint 也涉及到约瑟夫环问题，26个英文字母构成一个约瑟夫环，先减去起始字母a,A，在找到“加密字符”后，再将起始字母a,A加上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5cadbb678320b64b652b1fd7bb4508/" rel="bookmark">
			两个MQTT.fx客户端借助阿里云物联网平台进行通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个MQTT.fx客户端借助阿里云物联网平台进行通讯 两个MQTT.fx客户端借助阿里云物联网平台进行通讯准备工作设置Topic 两个MQTT.fx客户端借助阿里云物联网平台进行通讯 本文演示两个MQTT.fx客户端借助阿里云物联网平台进行通讯，首先MQTT客户端给阿里云发送数据，借助阿里云产品流转功能实现数据转发，再从另一个MQTT客户端接收数据。
准备工作 1.创建两个mqtt客户端链接，具体步骤请参照上条博客https://blog.csdn.net/weixin_41551104/article/details/111210144
2.创建云产品流转规则，具体步骤请参考https://editor.csdn.net/md/?articleId=111203725
设置Topic 1.将MQTT数据发送端的发布Topic设置为/a1eaReiwgC7/test1/user/data。
2.将MQTT数据接收端的订阅Topic设置为/a1eaReiwgC7/test2/user/data。
3.发送端数据发送如下格式{“force”:5,“DetectDistance”:5}
4.接收端接收如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b5b679c2bbd858ba21f36f13950f32/" rel="bookmark">
			NodeJs常见web开发框架分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Express
Node界最老牌的Web框架，最成熟，生态最好。提供了基础的请求上下文封装，路由，中间件，模板引擎接口，静态资源服务。麻雀虽小，五脏俱全。很方便的进行扩展，大量的基于Express的框架。
Koa
Express原班人马打造，定义为下一代Web开发框架。仅提供一个请求上下文，中间件机制，没有捆绑任何中间件。通过利用async/await，让你写出更优雅的代码。方便开发者针对自身需求开发自定义框架。
Hapi
hapi是由沃尔玛实验室的移动团队创建的，Hapi 是一个用来构建基于 Node.js 的应用和服务的富框架，使得开发者把重点放在便携可重用的应用逻辑而不是构建架构。内建输入验证、缓存、认证和其他 Web 应用开发常用的功能。没有中间件，但提供了强大的插件机制。
restify
专注于REST api开发。提供了handle的链式调用及插件机制。
Fastify
Fastify号称是最快的Nodejs web框架，在Json输出的场景下，通过Json Schema序列化为Json数据，可以达到原生JSON.stringify 2倍的性能，在极端情况下可达到10倍速。采用对象池，将请求上下文包装对象进行复用。使用trie树存储路由，查找效率更高（在大量有路由的情况下）。Fastify提供了强大的插件机制，通过插件可以分割路由及中间件。
egg
eggjs是由阿里推出的一款web企业级框架，提供了完整的Web开发所需的组件，使用koa作为底层。使用了约定大于配置的理念，提供强大的插件机制，方便扩展。
thinkjs
thiinkjs是由360推出的，基于koa开发，借鉴了ThinkPHP的一些理念，降低了开发者的使用难度，使用了类是很多php框架的默认路由，使用了继承和钩子方法来重用逻辑。
SailsJs
Sailsjs可以算最早开始做集成度很高的框架，底层基于express，Nodejs上的Rails。
NestJs
NestJs的主要卖点是TypeScript的完全支持。大量的使用装饰器，代码看起来清爽多了。orm采用TypeORM，使用类型加装饰器，代码比一般的orm整洁得多。
AdonisJs
AdonisJs是Nodejs上的Laravel。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/411bc0c552be65fc1589ce6b9abe94a1/" rel="bookmark">
			R语言——连续向量离散化函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言——连续向量离散化函数总结 1、 cut函数 这种方式较为简单，函数参数：cut(x, breaks, labels = NULL,
include.lowest = FALSE, right = TRUE, dig.lab = 3,
ordered_result = FALSE, …)
Num_Vector&lt;- c(10, 5, 4, 7, 6, 1, 4, 8, 8, 5) Cut_Vector&lt;-cut(Num_Vector,breaks=c(0,3,6,9,11), labels=c("0~3", "3~6", "6~9", "&gt;9"), right = TRUE) #输出变量是因子型 2、ifelse函数 类似于Excel中的if函数
set.seed(1) age &lt;- sample(0:100,100,replace = T) ifelse(age&lt;18,"未成年",ifelse(age&lt;60,"成年人","老年人")) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/885b75a6f6f306b26952e1d6651b96f3/" rel="bookmark">
			python操作rocket-mq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、参考源码
看源码，可以修改消息字节长度限制（rocketmq/client.py）
2、推送消息
from rocketmq.client import Producer, Message producer = Producer('PID-001') #随便 producer.set_namesrv_addr('ip:port') #ip和端口 producer.start() msg = Message('rocket_mq_test_broadcast_topic') #topic msg.set_keys('2020-12-15') msg.set_tags('explain') msg.set_body('{"key":"value"}') ret = producer.send_sync(msg) print(ret.status, ret.msg_id, ret.offset) producer.shutdown() 推送消息的时候，如果消息所占字节太长，需要手动设置size，代码中设置的是1M。
producer = Producer('PID-001',max_message_size=1024*1024) 3、消费方式PullConsumer（全部消费）（可重复消费）
from rocketmq.client import PullConsumer import json consumer = PullConsumer('PID-001') consumer.set_namesrv_addr('ip:port') consumer.start() for msg in consumer.pull('rocket_mq_test_broadcast_topic'): print(msg.tags) print(msg.keys) print(msg.id, msg.body) print(msg.topic) print(msg) data=json.loads(str(msg)) #dict consumer.shutdown() 4、消费方式PushConsumer（即时消费）（不可重复消费）
import time from rocketmq.client import PushConsumer def callback(msg): print(msg) consumer = PushConsumer('PID-001') consumer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/885b75a6f6f306b26952e1d6651b96f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39032d4373d1534ca129b839e50e155b/" rel="bookmark">
			VINS slam , imu fusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VINS 基本介绍
VINS-Mono 和 VINS-Mobile 是香港科技大学沈劭劼老师开源的单目视觉惯导 SLAM 方案。2017年发表于《IEEE Transactions on Robotics》。另外，VINS 的最新一篇论文获得了 iROS 2018 最佳学生论文奖。它是基于优化和滑动窗口的 VIO ，使用 IMU 预积分构建紧耦合框架，同时还有自动初始化，在线外参标定，重定位，闭环检测，以及全局位姿图优化功能。
VINS-Mono 是基于单目视觉惯性系统的实时 SLAM 框架， 是目前非常先进的单目 VIO 算法，更是视觉与 IMU 的融合中的经典之作，其定位精度可以媲美 OKVIS，而且具有比 OKVIS 更加完善和鲁棒的初始化以及闭环检测过程，代码在 Linux 上运行，并与 ROS 完全集成。VINS-Mono 主要用于自主无人机的状态估计和反馈控制，但它也能够为 AR 应用提供精确的定位。VINS-Mobile 可以运行在 iOS 系统，值得一提的是，沈劭劼老师开源了 ROS 和 iOS 版本，前端写的很简洁，代码非常清晰，值得大家学习，链接：https://arxiv.org/pdf/1708.03852.pdf。
VINS 的整体系统框架图
前端基于 KLT 跟踪算法， 后端基于滑动窗口的优化(采用 ceres 库)， 基于 DBoW 的回环检测。
整体框架分为五部分，如上图所示：
1. Measuremen Preprocessing ：观测值数据预处理，包含图像数据跟踪IMU数据预积分；
2. Initialization：初始化，包含单纯的视觉初始化和视觉惯性联合初始化；
3. Local Visual-Inertia BA and Relocalization：局部 BA 联合优化和重定位，包含一个基于滑动窗口的 BA 优化模型；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39032d4373d1534ca129b839e50e155b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9556661369382e0ad772180a2c789e69/" rel="bookmark">
			归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 归并排序原地归并的抽象方法自顶向下的归并排序自底向上的归并排序 归并排序 归并排序基于归并这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。要将一个数组排序，可以先递归的将它分成两半分别排序，然后将结果归并起来。
归并排序能保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点是它所需的额外空间和N成正比。
原地归并的抽象方法 将涉及到的所有元素复制到一个辅助数组中，再把归并的结果放回原数组中
代码：
void MergeSort::merge(std::vector&lt;int&gt;&amp; a, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) aux[k] = a[k]; for (int k = lo; k &lt;= hi; k++) if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (aux[j] &lt; aux[i]) a[k] = aux[j++]; else a[k] = aux[i++]; } 自顶向下的归并排序 递归归并是分治思想中最典型的一个例子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9556661369382e0ad772180a2c789e69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204f15309b6035ffcab802e858dcceb3/" rel="bookmark">
			京训钉怎么快速看完_钉钉的品牌成长之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是犀牛实验室（公号ID：cookie1605），我是张开开 这是我分享的第4篇内容，希望你能有所收获 To B型企业，“闷声”服务客户的居多，愿意且能够耗费巨资创造热门传播的少。所以，像钉钉这样的品牌，在企业服务领域绝对算得上是珍稀物种。
尤其面对疫情，钉钉的机智借势与应对，创造了一个前无古人，后人恐怕也很难企及的传播局面，让人不服不行。所以，这次我们以点带面，来看看从成立之初到现在，钉钉都做了哪些关键的品牌营销。
01
早期借力
2015年1月，在杭州湖畔花园蛰伏了半年的钉钉团队，正式对外发布钉钉1.0版本，从来往换到钉钉，从个人社交切换至工作办公场景，钉钉CEO无招估计也没想到5年后成长态势如此迅猛。
刚成立的钉钉，全身环绕着“爸爸”阿里的光环，但很多人依旧不知钉钉为何物。作为一个新品牌，如何能够快速让人认识和了解？钉钉的主要策略是借力。最初定位于企业级移动通讯产品的钉钉，直接将微信作为切入大众品牌认知与差异化的对象。 2016年开始，钉钉从使用场景着手，与微信进行对比，在地铁、报纸媒体等平台开启品牌战役，传达“钉钉让工作回归工作”、安全等等核心价值。
2016年，微信的平均日登录用户为7.68亿。作为企业级通讯产品，钉钉开局就选择了这样一个庞然大物，通过“抱大腿”差异化的方式，高效但略失风度的“揭短式”传播，最终快速提升了大众对其的品牌认知。 02
中期占位
生活用微信，工作用钉钉。正式走入大众视野后，钉钉想隆重介绍一下自己，让自己的形象更立体、更清晰一些。
2016年9月，钉钉3.0版上线，同时还推出了品牌宣传片，以行业挑战者、创新者的姿态出现。视频十分抽象与概念化，总而言之就是一个目的：钉钉，让办公应时代而变。
第二年，钉钉推出了另一则品牌大片，用一句“酷公司，用钉钉”进行群体价值划分。视频解释了钉钉对于酷公司的理解与定义，以此聚集相信其价值观的企业。 “酷”的定义很宽泛，理解起来也是千人千面。为了进一步将“酷公司，用钉钉”的价值理念打穿打透，真正传递到产品的目标受众——企业端，钉钉又将市场传播聚焦于创始人、程序员、HR以及普通上班族等不同群体，从群体洞察出发，打动目标人群。这里挑选几个地铁campaign的案例： 2017年6月“创业很苦，坚持很酷”
2018年春500 名程序员求pick
之后，钉钉调整了传播的核心点，从“酷公司用钉钉”，转移到“职场工作方式”，通过犀利的职场洞察，增加职场人群对品牌的感知。
2018年6月地铁广告
2019年开春，钉钉重新亮相，其各条产品线联合了钉钉平台生态上的 To B 创业者，打造开工节，继续向各大企业种草。 2019年春节后的北京地铁
妇女节，钉钉邀请几位女性创业者，传递女性领导力与自我实现的价值讨论，通过激励职场上努力工作、艰苦创业的女性创业者朋友，传递品牌价值。 妇女节“世俗如此，不俗如你”议题设置
宣传点上，钉钉也开始从群体洞察延伸到产品本身。2018年年底，钉钉推出吉祥物雨燕钉三多，通过钉三多为品牌代言。
钉三多出圈
钉钉擅于设置传播议题（与市场预算也有很大关系），基本上每年都会通过细分目标群体，从不同圈层开启传播战役，而且驾轻就熟。经历5年的发展，钉钉的用户及品牌认知度已在行业遥遥领先。
2019年8月的未来组织大会上，无招宣布钉钉用户数突破2亿人，企业组织数超过1000万，成为全球最大的软硬件一体化智能移动工作平台。
03
后期升级
2020上半年疫情袭来，各行业转移到线上办公，钉钉成功抓住了这个历史的机遇。产品功能上，钉钉结合疫期办公场景需求，推出医疗、在线教培等不同场景解决方案，成为了教育行业、线上远程办公的必备工具。 与此同时，钉钉依旧采取用户群圈层化打通。其中尤其精彩的，是钉钉面对学生群体进行的“被动式”传播。疫情期间，教育部号召“停课不停学”，并将钉钉作为小学生上网课的平台。学生成为了钉钉在疫期全新的、非常重要的使用群体。 因为每天都要进行线上报到、直播课堂等等操作，学生们愤怒地给出了一星差评，让钉钉的App Store评分一度不足两分。没想到，钉钉用中小学生的表达方式，推出了求饶视频《钉钉本钉，在线求饶》，向用户跪求好评。截止目前，回应视频播放视频达到了2533.3万，评论32.5万，点赞175.3万。 钉钉的回应方式很可爱，虽然是一次被动式的危机传播，但博得了广泛的认同与好感。钉钉的品牌形象也变得更加人性且立体，在企业服务领域尤其凸显。 此后，钉钉似乎也找到了自己的风格，品牌视觉与传播开始年轻化，加入了更多有趣、鬼畜、二次元的元素，并新增IP钉哥，钉妹，拉近与用户的距离。预计，钉钉未来将会继续拥抱“后浪”，以这样年轻的方式进行传播。 04
总结
钉钉的品牌成长史就回顾到这里，看完之后，不知你有何感受。总结起来，对于一个新的品牌来说，有几点值得借鉴与思考： · 借力：借助大众熟知的对象对比强调，可快速清晰自身品牌定位。 · 打通圈层：想要用户真的了解你，先得找准沟通对象。钉钉基本上把所有潜在用户群体都一一聚焦，并通过线下活动来提升不同用户群体感知。 · 年轻化：为强调产品价值，To B类企业对外传播大多很正经。有趣的表达方式，会让人觉得很年轻，而且与众不同。 · IP化与升级：钉三多，钉哥，钉妹....这些IP都是钉钉自身的性格，通过这种形象与用户接触更有亲近感。
先说到这里，To B类企业的品牌营销到底如何可以做得更好，吸引更多潜在客户？欢迎朋友们评论区聊聊。 也欢迎关注公号犀牛实验室（ID：cookie1605），上面有更多To B 品牌营销干货文章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8c688b17a1fe8224c7e2eaa06f251b/" rel="bookmark">
			京训钉怎么快速看完_不要让家长输在起跑线，钉钉最全图文教程了解一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		受疫情影响，全国各地相继发布通知推迟开学时间，为了保证正常的教学进度，相关部门提出了"停课不停学"的口号，掀起了网络在线学习的热潮。
钉钉作为阿里巴巴集团开发的一款办公软件，功能强大，体验感好，可以十分方便地帮助老师进行线上直播教学，成为了很多学校和老师的不二选择。但是，不少家长还不太熟悉钉钉的操作流程，不知道该如何与老师互动，接收老师发布的重要通知，"输"在了辅助孩子进行网络学习的起跑线上。别着急，你现在在看的，就是一份超全钉钉操作图文教程，我们一起学起来吧！
(一)下载钉钉
首先，当然是下载钉钉，家长们可以根据自己的需要，在电脑端或者手机端下载不同版本的钉钉，各种设备的需要都可以被满足。
(二)进入钉钉班级群
下载好以后，家长可以根据班主任的邀请链接，使用自己的手机号码注册，就可以绑定学生。因为大多数学校已经提前将家长的电话录入到钉钉的系统中，所以家长认证起来非常方便，而且一个学生可以绑定多个家长，提高了认证的灵活性。
(三)打开并观看直播
家长在进入钉钉群以后，检查一下自己设备的视频、扬声器等功能是否正常，就可以静静等待老师上课的通知了。当老师开始直播时，家长和学生就要做好准备了。如果选择用手机打开钉钉看直播，会话列表里会有直播提示，点击即可进入，并且可以自主选择画面屏幕的大小。
如果选择用电脑版钉钉，进入方式和手机类似，同时在直播的视频界面上还有举手发言、为老师点赞、参与文字互动等功能的按钮。举手发言的同学在经过老师同意后，他的画面和声音就会出现在屏幕上，被所有成员接收。这样大大提高了老师与学生在直播课堂的互动。
有条件的家庭，还可以选择用电视投屏的方式进行直播的观看，这对手机软件和硬件就提出了一定的要求，家长可以根据自己的实际情况进行选择。
(四)直播回放
如果小孩在直播课上仍然没太听懂怎么办？直播结束后，学生可以在班级群中查找直播的视频回放，每一期都会有清晰的标题和分类，帮助学生快速定位自己需要巩固的知识点。
除此之外，家长也可以在群里及时收到老师通过小工具发布的作业，并及时督促小孩作业的完成情况。
怎么样，钉钉的操作很简单方便的吧，希望这段教程能帮助大家更好地理解具体的使用技巧。快收藏吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64dc5e3c8152704dd964b6fd30f49469/" rel="bookmark">
			为什么阿里云要做流批一体？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流批一体已经从理论走向实践，并在2020年迎来落地元年。
短短 5 年，Apache Flink（下称 Flink）从一个突然出现在大数据舞台的“萌新”系统，迅速成长为人人皆知的流计算引擎。
在伴随 Flink 发展掀起的这波实时计算浪潮里，阿里是国内走得最前、做得也最多的一个，“流批一体”是它的新赛道。今年双 11， Flink 流批一体开始在阿里最核心的数据业务场景崭露头角，并抗住了 40 亿条／秒的实时计算峰值。
这是第一次有互联网超级大厂真正在核心数据业务上规模化落地流批一体技术。同时，这也意味着 Flink 在阿里的发展已经进入第二个阶段，从全链路实时化进阶到全链路流批一体化。
恰逢 2020 年 Flink Forward Asia 大会召开之际，InfoQ 对 Apache Flink 中文社区发起人及阿里云实时计算负责人王峰（花名莫问）、阿里云实时计算团队资深技术专家杨克特（花名鲁尼）、天猫大数据负责人黄晓锋进行了独家专访，希望从多个角度更完整地还原 Flink 流批一体在阿里落地的过程和背后的技术挑战，并深入探讨这个新赛道对于阿里云的价值和未来发展方向。
从理论到落地
流批一体的技术理念最早提出于 2015 年，它的初衷是让开发人员能够用同一套接口实现大数据的流计算和批计算，进而保证处理过程与结果的一致性。随后，大数据厂商/框架们如 Spark、Flink、Beam 等，都陆续提出了自己的解决方案，虽然实现方式各不相同，但在一定程度上说明流批一体的思想已经在业界得到广泛认可。
然而，流批一体要真正从理论走到落地，尤其是在企业的核心数据业务场景规模化落地，往往面临技术和业务的双重挑战。在莫问看来，这也是为什么流批一体出现的很早，厂商落地案例却不多见。
从技术层面来看，流计算和批计算从计算方式、支撑模块、资源调度策略到流程规划等都存在差异，不管是批流一体还是流批一体，都有不少技术问题要解决。这其中关乎研发资源投入，但大前提是需要有一个统一的计算引擎。虽然 Spark 是最早提出流批一体理念的计算引擎之一，但由于其本质还是基于批（mini-batch）来实现流，在流计算语义和延迟上存在硬伤，难以满足复杂、大规模实时计算场景的极致需求，因此目前很多厂商的数据业务还是选择将流和批分开来做，流用 Flink、批用 Spark。这就导致前面说的大前提无法满足，在核心场景落地流批一体更加无从谈起。
从业务层面来看，如果企业有非常重的历史包袱或者在流批一体架构下不能取得足够多业务价值，那它也不会有足够的动力去做流批一体的改造和落地。
但对于阿里来说，恰恰是在技术和业务两个因素共同推动之下，流批一体才得以在双 11 核心业务场景正式亮相。
技术上，阿里 2019 年收购 Flink 的创始公司 Ververica 后，投入近百名工程师到 Flink 技术研发和社区工作中，在 Flink 基于流实现批计算的能力上做了非常多工作，其中有一些特性优先在双 11 落地，后续也会全部推进到社区里。
业务上，今年大促期曾经面临离线和实时数据统计口径不一致的问题，这类潜在问题会影响广告、商务甚至公司运营决策，这是真正的“秒秒钟几百万上下”，强电商属性和大业务体量倒逼着流批一体技术必须在阿里核心业务落地，方能解决痛点。
莫问提到，当前流批一体已经在许多业务场景成为刚需，而不是一个技术噱头。这次双十一就像一场“转正”考试，意味着在阿里巴巴业务场景中流批一体技术从理论走向落地，同时也标记着 Flink 在阿里开始从全链路实时化步入全链路流批一体化的新阶段。
路走对了，就不怕远
2015 年，针对搜索推荐业务做新的大数据计算引擎选型时，阿里云实时计算团队对流批一体的技术方向就已经有初步设想。
在经过深度调研、可行性验证和对未来可能遇到的问题进行推演之后，团队最终决定引入 Flink。鲁尼表示，虽然当时 Flink 整个系统还不是特别成熟，但团队认为 Flink 以流计算为核心的设计理念更符合未来数据计算实时化发展的大趋势。在阿里内部有一句土话，叫“路走对了，就不怕远”，从后续这几年的发展情况来看，Flink 确实进展顺利，甚至超过团队当时的预期。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64dc5e3c8152704dd964b6fd30f49469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f143e6f4a1cbc7132dc5b42d540599/" rel="bookmark">
			H2数据库-快速指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		H2数据库-简介 H2是开源的轻量级Java数据库。它可以嵌入Java应用程序中或以客户端-服务器模式运行。H2数据库主要可以配置为作为内存数据库运行，这意味着数据将不会持久存储在磁盘上。由于具有嵌入式数据库，因此它不用于生产开发，而主要用于开发和测试。
可以在嵌入式模式或服务器模式下使用此数据库。以下是H2数据库的主要功能-
极快的开源JDBC API在嵌入式和服务器模式下可用；内存数据库基于浏览器的控制台应用程序占用空间小-jar文件大小约为1.5MB H2数据库的功能 H2数据库的主要特点如下-
这是一个非常快的数据库引擎。
H2是开源的，并用Java编写。
它支持标准的SQL和JDBC API。它也可以使用PostgreSQL ODBC驱动程序。
它具有嵌入式和服务器模式。
H2支持集群和多版本并发。
它具有强大的安全功能。
附加功能 以下是H2数据库的一些其他功能-
H2是基于磁盘的或内存中的数据库和表，只读数据库支持，临时表。
H2提供事务支持（已提交读），两阶段提交的多个连接，表级锁定。
H2是基于成本的优化程序，使用遗传算法进行复杂查询（零管理）。
H2包含可滚动和可更新的结果集支持，大结果集，外部结果排序，函数可以返回结果集。
H2支持加密数据库（AES），SHA-256密码加密，加密功能和SSL。
H2数据库中的组件 为了使用H2数据库，您需要具有以下组件-
网络浏览器H2控制台服务器 这是一个客户端/服务器应用程序，因此服务器和客户端（浏览器）都需要运行它。
H2数据库-安装 H2是用Java编写的数据库。通过使用JDBC，我们可以轻松地将此数据库嵌入到我们的应用程序中。我们可以在许多不同的平台或任何版本的Java Runtime Environment上运行它。但是，在安装数据库之前，应在系统中安装Java。
验证Java安装 如果系统中安装了JDK，请尝试以下命令来验证Java版本。
&lt;span style="color:rgba(0, 0, 0, 0.87)"&gt;java –version &lt;/span&gt; 如果JDk成功安装在系统中，那么我们将获得以下输出。
&lt;span style="color:rgba(0, 0, 0, 0.87)"&gt;java version "1.8.0_91" Java(TM) SE Runtime Environment (build 1.8.0_91-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode) &lt;/span&gt; 如果系统中未安装JDK，则访问下面的Install JDK链接。
安装H2数据库 我们可以在许多不同的平台上运行此数据库。在本章中，我们将学习在Windows上安装H2数据库的知识。
以下是在Windows操作系统上安装H2数据库的步骤。
步骤1：下载H2设定档 从给定的链接下载最新版本的H2数据库。在此链接中，您将获得两种类型的H2数据库的最新版本。一种是Windows Installer类型（即.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f143e6f4a1cbc7132dc5b42d540599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec7bd8ed1871e4ad0c73fc169a2309f/" rel="bookmark">
			8路抢答器proteus仿真 2种电路图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8路抢答器proteus仿真 第一种
涉及到的元件有
1. 7448(芯片)
2. res(电阻)
3. OR_4(4路或门）
4. BUTTON(按钮）
5. OR_8(8路或门）
6. AND(与门)
7. 74ls373(芯片）
8. NOT(非门）
9. 7SEG-COM-CATHODE(数字屏）
所有电阻阻值均为1欧
电路图如下
第二种
涉及到的元件有
1. 1N4148(二极管)
2. 2N5551(三极管）
3. 4511(芯片)
4. BUTTON(按钮）
5. OR_8(8路或门）
6. OR_4(4路或门）
7. RES(电阻)
8. 74ls373(芯片）
9. NOT(非门）
10. 7SEG-COM-CATHODE(数字屏）
R6为2.2k欧，R7为100k欧，其他为默认值10k欧。
电路图如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74dbe72479bbf5a8610f245c214ea46a/" rel="bookmark">
			函数的单调性和曲线的凹凸性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数的单调性 函数单调性是针对某一个区间而言的，是一个局部性质。
学习函数单调性时
针对函数定义和特定函数的性质进行判断。
--&gt; 单调性知识点概述：
单调性改变的点为驻点或是极值点
驻点或极值点的求解方法：一阶求导
·
判断函数单调性的方法有很多，这边推荐定义法和求导法。
定义法：
①在区间D上，任取X1,X2，令X1&lt;X2;
②作差F(X1)-F(X2)；
④确定F(X1)-F(X2)符号的正负;
求导法：
如果函数y=f(x)在区间D内可导(可微)，若x∈D时恒有f’(x)&gt;0，则函数y=f(x)在区间D内单调增加；反之，若x∈D时，f’(x)&lt;0,则称函数y=f(x)在区间D内单调减少。
复合函数求解单调性可用同增异减来判断（考虑定义域）。
曲线的凹凸性 –&gt;
在函数f(x)的图象上取任意两点，如果函数图象在这两点之间的部分总在连接这两点的线段的下方，那么这个函数就是凹函数。同理可知，如果函数图像在这两点之间的部分总在连接这两点线段的上方，那么这个函数就是凸函数。
–&gt;
凹凸性的知识点概述：
曲线凹凸性变化的点为拐点
凹凸性变化点叫拐点又叫反曲点
‘
判断曲线凹凸性的方法：二阶导
求导法：
如果函数f(x)在区间I上二阶可导，则f(x)在区间I上是凸函数的充要条件是f’’(x)≤0;f(x)在区间I上是凹函数的充要条件是f’’(x)≥0;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4c7c10be697dffc2669ec81c2a18a5/" rel="bookmark">
			大连海事大学第一届“启航杯”DLMU CTF部分题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大连海事大学第一届“启航杯”CTF校园网络安全竞赛 签到题 0. dlmuctf2020 flag{welcome_to_dlmuctf2020}
dlmuctf{welcome_to_dlmuctf2020}
1. 早安，贝丝人 TVJXRzI1TERPUlRIV1NCV09aU1Y2TlM3TTRZREFaQzdNUTNIU0lMNQ==
​ 很明显的Base64编码，解密后得到MRWG25LDORTHWSBWOZSV6NS7M4YDAZC7MQ3HSIL5,在进行Base32解码，拿到flag：dlmuctf{H6ve_6_g00d_d6y!}
Misc 2. lsp了 ​ 题目叫lsp，第一反应想到的就是LSB加密。
可以看到，PK开头，可知是zip压缩文件，保存，打开，得到flag：flag{Good_Job_kkk}
3. base2sth ​ 打开flag.txt,里边有一堆代码，简单看一下，字母全是小写，最高位没有超过f，推测是HEX编码，解码一下。解码后，可以在开头位置看到data:image/png;base64 说明是Base64加密的图片，Base64转图片得到flag。
4. docz ​ 下载下来是docx文件，但是打不开，第一反应看16进制，用010editor打开
​ 明显PK开头，改后缀名为zip，打开后里边又是一层zip，打开里边有一个密码.zip，打开后内部是加密的，结合注释“真的有密码？”猜测是伪加密，用010editor打开，去除伪加密，打开里边的爆破.zip，根据提示6位数字密码，进行zip爆破，爆破得到密码233333（过程不展示了，工具到处都是），打开得到flag。
5. jigsaw ​ 题目叫做jigsaw，翻译一下就是拼图的意思，打开压缩包，里边有黑白图片一共10000张，推测是拼起来是个二维码，这里用的工具是ImageMagick 下的montage （具体安装方法百度吧）
​ 在终端下输入：
montage *.png -tile 100X100 -geometry +0+0 flag.png ​ 运行后得到flag.png
直接扫扫不出来，我当时是拖到word里加个滤镜，缩小一下扫出来的。。。
P.S.这道题做得我血压飙升，一万张图，在虚拟机跑好久，切一下后台kali就给我杀进程。。。期间卡死无数次。。。
Crypto 6. 经典三合一 ​ o{rnhBuRcj_Hjb_uN?p_auJ}
​ 先栅栏得oujp{Rb_rc_anjuuh_NJBH?}，再凯撒得到flag{Is_it_really_EASY?}
7. XOR ​ 题目XOR，肯定就是异或了，百度查阅了好多异或加密的资料，写代码：
#include &lt;stdio.h&gt; main() { char a[]="DsfvD-jZ|,+p}sX.zIfvzYrh|pSvWMX'"; char c[100]; int i; for(int j=1;j&lt;200;j++) { for(i=0;a[i];i++) c[i]=a[i]^j; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4c7c10be697dffc2669ec81c2a18a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a037e5f14f0051b1398cfe1b65dcdc/" rel="bookmark">
			2020年最新Spark企业级面试题【上】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 现在距离2021年还有不到一个月的时间了，是不是有的小伙明年不知该怎么复习spark，以及不知道该备战企业中会问到那些问题。好今天他来了总结了20个企业中经常被问到的面题以及会附带一些笔试题哦，编写不易建议收藏。
一、 Spark 有几种部署方式？ spark 中的部署模式分为三种 Standalone， Apache Mesos， Hadoop YARN，那他们分别有啥作用那？
Standalone： 独立模式， Spark 原生的简单集群管理器， 自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统，使用 Standalone 可以很方便地搭建一个集群；
Apache Mesos： 一个强大的分布式资源管理框架，它允许多种不同的框架部署在其上，包括 yarn；
Hadoop YARN： 统一的资源管理机制，在上面可以运行多套计算框架，如 mapreduce、 storm 等， 根据 driver 在集群中的位置不同，分为 yarn client 和 yarncluster。
二、 Spark 提交作业参数 企业问这个问题基本考验你对有没有是用spark提交过任务，以及是否了解每个参数的含义。合理设置参数也是可以起到优化作用的哦。
executor-cores —— 每个executor使用的内核数，默认为1num-executors —— 启动executors的数量，默认为2executor-memory —— executor内存大小，默认1Gdriver-cores —— driver使用内核数，默认为1driver-memory —— driver内存大小，默认512M 三、简述Spark on yarn的作业提交流程 既然spark是支持yarn调度的那你的调度流程是什么样的那？yarn这边是有两个模式分别为 yarn Clint 和yarn Cluster模式，那我这边分别讲下吧。
yarn Clint模式
在YARN Client模式下，Driver在任务提交的本地机器上运行，Driver启动后会和ResourceManager通讯申请启动ApplicationMaster，随后ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，此时的ApplicationMaster的功能相当于一个ExecutorLaucher，只负责向ResourceManager申请Executor内存。
ResourceManager接到ApplicationMaster的资源申请后会分配container，然后ApplicationMaster在资源分配指定的NodeManager上启动Executor进程，Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数，之后执行到Action算子时，触发一个job，并根据宽依赖开始划分stage，每个stage生成对应的taskSet，之后将task分发到各个Executor上执行。
yarn Cluster 模式
在YARN Cluster模式下，任务提交后会和ResourceManager通讯申请启动ApplicationMaster，随后ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，此时的ApplicationMaster就是Driver。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a037e5f14f0051b1398cfe1b65dcdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09442db946d64a3472de84c43de5830f/" rel="bookmark">
			JSP页面的内容及JSP页面工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP页面的内容 包括指令标识、HTML代码、JavaScript代码、嵌入的Java代码、注释和JSP动作标识等内容。
指令标识 指令标识主要用于设定整个JSP页面范围内有效的相关信息，它是被服务器解释并执行的，不会产生任何内容输出到网页中，对于客户端浏览器是不可见的。
例如：
JSP动作标识 利用JSP动作可以动态地插入文件、重用JavaBean组件、把用户重定向到另外的页面、为Java插件生成HTML代码
常用的动作标识
JSP规范定义了一系列的标准动作，它用JSP作为前缀，可用的标准动作元素如下：
jsp:include 在页面被请求的时候引入一个文件。
jsp:useBean 寻找或者实例化一个JavaBean。
jsp:setProperty 设置JavaBean的属性。
jsp:getProperty 输出某个JavaBean的属性。
jsp:forward 把请求转到一个新的页面（请求转发）
JSP页面工作原理 网络服务器有一个JSP引擎（容器）来处理 JSP 页面。容器负责截获对JSP页面的请求。JSP容器与Web服务器协同合作，为JSP的正常运行提供必要的运行环境和其他服务，并且能够正确识别专属于 JSP 网页的特殊元素。
当服务器上的一个jsp页面被第一次请求时，jsp引擎首先将JSP页面文件转译成一个java文件，编译生成字节码文件，然后执行字节码文件响应客户的请求。
把JSP页面中的HTML标记符号（页面的静态部分）交给客户的浏览器负责显示
处理JSP标记，并将有关的处理结果发送到客户的浏览器。执行“&lt;%”和“%&gt;”之间的java程序片（JSP页面中的动态部分），并把执行结果交给客户的浏览器显示
当多个客户请求一个JSP页面时，Tomcat服务器为每个客户启动一个线程，负责执行常驻内存的字节码文件来响应相应客户的请求
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f70c7985b0de5ffa9f0e77d2ca0d86c/" rel="bookmark">
			voc数据集_目标检测数据集的增强（旋转，镜像，亮度等）含针对VOC标注格式数据的源码...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对目标检测数据集的增强方案有很多，网上的资料写的零零散散，而且我好像没有找到一个系统完整的针对某套完整数据集的源码，这两天自己写了几个增强方案的源码，针对的是voc格式的数据集！
只要有自己标注好的数据，按VOC格式组织好文件，就能用上这套代码。比如目前只有几百张数据，那么这样增强后会大大的扩充自己的数据集。
源码地址​github.com 目录 0对图像/标签的旋转
1不损失图像信息的旋转
2对图像/标签的镜像
3对原图和标签的亮度/对比度变换
0对图像/标签的旋转 难点在于对标签的旋转，前面其实我有写过一篇文章介绍过旋转大致原理
lim0：目标检测增强数据——旋转目标和对应标签​zhuanlan.zhihu.com 前面的文章的代码只是针对一张图片的一个demo。本文会给出一个具体的处理VOC数据集格式的完整代码，涉及对.xml文件的基本操作，以及对文件，文件夹的基本操作，虽然都很基础，但是很多细节还是值得记录:
需要处理的数据文件树(VOC数据格式)
|---Annotations
----0.xml
......
----XX.xml
|---JPEGImages
----0.jpg
......
----XX..jpg
#定义旋转图像文件的函数 def getRotatedImg(Pi_angle,img_path,img_write_path): img = cv2.imread(img_path) ..... ###详细代码见github rotated_img = cv2.warpAffine(img, M, (cols, rows)) # 旋转后的图像保持大小不变 cv2.imwrite(img_write_path,rotated_img) return a,b #定义处理.xml文件的函数 def getRotatedAnno(Pi_angle,a,b,anno_path,anno_write_path): tree = ET.parse(anno_path) root = tree.getroot() objects = root.findall("object") for obj in objects: ..... ###详细代码见github tree.write(anno_write_path) # 保存修改后的XML文件 def rotate(angle,img_dir,anno_dir,img_write_dir,anno_write_dir): if not os.path.exists(img_write_dir): os.makedirs(img_write_dir) if not os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f70c7985b0de5ffa9f0e77d2ca0d86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b73db76ffb77189bc10d3199fc7fe9/" rel="bookmark">
			编程语言难度排名_当前最流行的十大编程语言都有哪些用途和优缺点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前最流行的十大编程语言都有哪些用途和优缺点？
这里是丁哥开讲，我们先来说说最流行的都是哪些语言， 首先声明下面的排名不分先后: C++, C#, Java, Javascript, Python,Swift, PHP, SQL, Go, R。下面我们从如下几个方面分析一下这十大最流行的编程语言： 创立时间，优点，缺点，主要用途，学习难度。
. C++:
这门语言创始于1983年。
它有如下优点：
第1个就是因为流行，所以有很多编译器和共享库。
第2个如果你会C++, 学习其他语言诸如C,C#, Java就会非常轻松。
第3个还没有垃圾回收器在后台运行因此执行效率相对较高。
它的缺点是：
第1个是语言的语法比较复杂，标准库又比较小，这使得这门语言对初学者学起来门槛比较高，感到非常难学。
第2个是这门语言没有垃圾回收。
这门语言的主要用途是游戏开发领域，追求高效率的高级计算领域， 图形图像处理领域。
学习难度是难。
.C#：
这门语言创立于2001年。
它的优点是：
第1个跟c语言具有非常类似的语法，如果你懂c类似语言的话，学习起来就会很容易。
第2个是由于靠着微软这棵大树，所以可以充分发挥微软.NET平台的优势， 也是多年来windows平台的一门主流编程语言。
第3个是取消了指针的使用。
它的缺点是：
它虽然取消了指针，但是如果你用unsafe block的话也可以使用指针。
它的主要用途是企业级跨平台应用开发， 网络应用开发， 手机应用开发，游戏开发。
学习难度是难
.Java
这门语言始于1996年。
它的优点是
第1个是面向对象编程语言。
第2个API接口非常丰富， 比如数据库连接访问，网络应用，工具类等等。
第3个是具有强大的开源开发工具。
第4个是有大量的开源共享库。
它的缺点是
第1个是内存管理方面非常昂贵。
第2个没有模板的支持。
它的主要用途是安卓应用开发，网络应用开发和大数据处理。
学习难度是容易。
.Javascript
这门语言最早开始于1995年。
它的优点是
第一，客户端浏览器中运行的效率非常高。
第二，比较容易学习。
第三，可以跟其他多种语言在多种场景下混合使用。
它的缺点是
第一，不支持多重继承。
第二，在不同的浏览器中，可能有不同的行为。
它的主要用途是网络应用开发，游戏开发， 手机应用开发和桌面程序开发。
它的学习难度是容易。
.Python
这门语言最早开始于1991年。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b73db76ffb77189bc10d3199fc7fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e8e2ab6053c970817447f98262e026/" rel="bookmark">
			react修改state中的对象数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 react修改state中的对象数组 一直把数据定义在store中没想过要把更改对象数组中的值，这次放在state中了突然发现还不知道怎么修改state中对象数组的某个对象的某个键值，解决之后先将实现方式来简单记录一下
constructor() { super() this.state = { CopyList: [{personNum:'111'},{personNum:'222'},{personNum:'333'}], } } CopyList.map((v,index)=&gt;{ &lt;li&gt;&lt;Input value={v.personNum} onChange={e =&gt; { //先解构state 中的CopyList const copyListTemp =[...this.state.CopyList]; //然后修改当前CopyList数组中第index个对象的personNum this.setState({ CopyList: copyListTemp.map((item, idx) =&gt; idx === index ? { ...item, personNum: e.target.value } : item) }) }} /&gt;&lt;/li&gt; }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a973106fcc1e07ccbbc154f4fb57da8/" rel="bookmark">
			三因素三水平正交表l9_影响多腔导管挤出机头设计的关键因素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着介入医学的不断发展，医疗领域对医用多腔导管的需求日剧增加，多腔医用导管已经成为微挤出成型技术的研究热点。文章通过数值模拟正交试验设计聚合物多腔导管挤出机头，以挤出速度分布均匀性为目标函数来衡量流道的流动均匀性。 利用 Polyflow 数值模拟，通过正交试验研究了不同流道主要结构参数及制品截面结构尺寸下聚合物熔体的挤出速度分布，根据目标函数确定挤出速度均匀性较好机头结构参数。结果表明:在导管截面面积不变的情况下，口模截面尺寸及流道结构参数是影响挤出机头设计的关键因素。
挤出成型具有实用领域广、高效率及低成本等优点。随着科学技术的发展，产品逐渐向轻微化方向发展。用于介入医学的多腔导管也进入了微米时代，但是多腔导管由于其截面复杂及尺寸小而使得挤出机头设计难度较大，因此挤出机头设计时需要考虑以下几个问题:
1) 平衡流道的设计;
2) 避免流变缺陷;
3) 保证生产的最大化和提高产品的质量。 挤出机头按照管材挤出机头的挤入方向和挤出方向的不同，可以分为直通式挤出机头、直角式挤出机头和补偿式挤出机头3 种。其中，直通式机头的结构设计虽然保证了熔体在流道中的流动平衡性，但是在挤出成型过程中，制品容易产生缺陷，同时注气孔难以加工和密封;直角式挤出机头虽然注气孔易于加工和密封，但是普通的流道结构很难实现流动平衡。
因此， 为了减小机头设计中注气孔的加工难度以及保证熔体的流动平衡性，文章流道采用满足狭缝理论的直角非对称流道设计。首先通过经验公式计算挤出机头各参数的初始值，然后通过 Polyflow 对流道主要结构参数和导管截面各型腔分布进行正交试验优化，最后根据挤出速度分布建立目标函数并确定最佳流道结构参数和口模截面尺寸。 1、数学模型
由于 Bird-Carreau 本构模型不仅能够反映低剪切速率聚合物熔体的牛顿行为以及高剪切速率下人造塑料的流道特性，而且还可以反映中间区域的非牛顿流体的流动特性。因此文章采用 Bird-Carreau 本构方程建立了 PP 多腔导管的挤出黏性模型:
式中: η 为黏度; γ 为剪切速率; η0为零剪切黏度; η∞ 为无穷剪切黏度; N 为非牛顿指数。
在挤出成型过程中，由于各个型腔的结构尺寸非常小，这使得聚合物熔体在机头中的流动阻力增大，型腔壁面附近的剪切力明显增加，流体在壁面附近发生大分子链滑移，因此在挤出过程中近壁面产生壁面滑移。文章采用广义 Navier 滑移理论来描述挤出壁面滑移特性:
式中: vs为流体切向速度，vwall为近壁面的法向速率; e 为材料的相关系数; F 为滑移系数。
2、聚合物5 腔导管挤出机头流道设计
文章以材料为聚丙烯( PP) 的 5 腔导管挤出机头设计为主要研究对象，通过对流道的主要结构参数和口模截面的主要结构参数进行正交试验，从而获得最佳的流道结构参数和口模截面形状。由于文章设计的是非对称流道直角挤出机头，为了避免管壁壁厚出现突变或者导管的形状出现扭曲等缺陷，同时为了减小设计周期，必须通过数值模拟预先确定满足流动平衡的流道结构和口模截面。 靳国宝等根据聚合物熔体流变学理论，推导出满足流道平衡的非对称流道结构关系，建立了优化目标函数，根据逆向设计理论，优化设计出微管挤出模具。文章在此基础上对直角挤出机头流道结构参数中的压缩角 β、压缩段 长度 L2以及定型段长度L1以及口模截面形状圆心距 Ｒ1， Ｒ2，夹 角θ1进行正交试验设计，通过数值模拟正交试验结果，建立相应的目标函数，最后得出最佳结构参数。 2. 1导管挤出机头结构参数正交试验设计 文章所研究的5 腔导管截面设计，如图1所示。
图1 五腔导管设计截面图(单位: mm)
图2 机头流道及截面结构参数
图2( a) 所示为流道的主要研究的结构参数，图 2( b) 所示为制品的截面研究结构参数。由于制品是轴对称结构，为了研究方便以及后续数值模拟节省计算时间，文章取二分之一流道作为研究的模型。 定型段 L1的功能是通过增加料流阻力，使得制品密实，同时也使得料流稳定均匀，消除螺旋运动和结合线。成型段长度不能过长，过长将导致聚合物熔体滞留时间过长而发生降解，但也不能过短，太短将起不到相应的作用。根据经验公式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a973106fcc1e07ccbbc154f4fb57da8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c69250cdc1eb3ce216a2569d18f579/" rel="bookmark">
			resize2fs: Bad magic number in super-block while trying to open /dev/mapper/centos-root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 今日，linux扩容磁盘后，文件系统大小还是没变化。
百度找了好些博文，全都是说使用resize2fs命令更新文件系统。好家伙，全都不分青红皂白，上来就是抛命令让人执行，兴许你文件系统类型刚好是用resize2fs命令就没碰壁，可我刚好就没这么幸运。
下面总结一下更新文件系统的具体方案： （1）首先，查看你的文件系统类型
mount |grep root （2）根据文件系统类型选择命令(这里以xfs类型做演示，步骤都一致)
resize2fs 命令 ：针对的是ext2、ext3、ext4文件系统
xfs_growfs 命令 ：针对的是xfs文件系统
（3）xfs类型文件系统重新定义大小要使用 xfs_growfs命令(注意文件系统名要与自己系统的一致)
xfs_growfs /dev/mapper/centos-root （4）接下来用df -h查看一下文件系统的大小，完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f6e83ff0a328fc10da51c824f164b6/" rel="bookmark">
			python net use_在循环中使用“net use”命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在编写一个简单的python脚本，它连接到几个远程Windows机器，读取这些机器上远程文件夹的内容，然后压缩并复制在给定日期之后修改过的所有文件。在
问题是，当它连接到第一台计算机后，它没有连接到第二台计算机，“netuse”命令不起作用。
如果我通过计算机的windows命令行手动执行此操作，它确实可以工作，但不能通过python脚本。在
我没有找到任何可以帮助我的话题，我现在有点困了。。。你们知道我会做错什么吗？在
下面是我的代码(如果看起来不太整洁，我很抱歉，我是从python开始的)。在import os, subprocess, datetime, shutil
# the local destination of log files on my computer
ROOT_folder = 'C:\\Logs'
for i, IP in enumerate(list_of_IPs):
# list of names corresponding to the IPs
location = list_of_locs[i]
# create a local repository in my ROT folder for storing the logs of this remote station
try:
os.chdir(ROOT_folder + '\\' + location)
except:
os.mkdir(ROOT_folder + '\\' + location)
# The path to the logs that are stored on the remote windows machines
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f6e83ff0a328fc10da51c824f164b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74be6c3474df089f08a7b3d5cef676e2/" rel="bookmark">
			华为手机丢失定位网站_EMUI这个功能可以帮你找回丢失的手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一部手机走天下的时代，出门可以不带钱包，尤其假日出行，非常方便，但是如果忘记带手机那你绝对要陷入焦虑中了，更可怕的事在于手机丢失或者被盗，那绝不亚于一场灾难。问题是，当手机丢失我们就只能认倒霉吗？其实完全可以再抢救一下，现在几乎所有的设备都有找回功能，可以定位和锁定丢失的手机，至少可以将手机中的个人资料抹除，防止造成更大的损失。
手机确认丢失或被盗后，不要着急，华为手机EMUI中的【查找我的手机】能帮到你哦。重点来了，详细使用步骤如下，快睁大眼睛看这里！
1. 首先确认丢失的EMUI设备是否有 登录华为帐号并且 开启“查找我的手机”功能，如果已登录华为帐号且开启“查找我的手机”，手机还保持开机联网状态，可在任意设备浏览器上登录华为云空间官网(cloud.huawei.com)，或在另一部华为手机上登录“查找我的手机”应用。
*使用与丢失设备相同的华为帐号、密码登录。
打开“查找我的手机”登录成功后，在设备列表中选择需定位的设备。(注：如果“查找我的手机”设备列表中无此设备，说明您没有开启“查找我的手机”，则无法使用华为查找手机功能，建议您联系公安机关或手机号运营商如移动电信等寻求帮助。)
1)远程锁定，发送警告信息
您可以通过“查找我的手机&gt; 远程锁定”为设备设定数字锁屏密码锁定手机。此密码与华为帐号密码不同，仅可设置数字密码。注意，如果您的设备已设置了锁屏密码，则无需再次通过查找我的手机进行锁屏密码设置操作(适用EMUI5.0及以上版本)。也可支持设置锁定信息，设置成功后信息将会显示在锁定设备屏幕上。若是设备有插入SD卡，也可对SD卡设置密码进行锁定。
发送警告信息，尽量使用友好的沟通词语，并留下您能使用的手机号以便对方能与您联系(例如：您好，这个手机对我非常重要，请您在捡到我的手机后尽快与我联系，万分感谢！手机号是：“****”)。
2)播放铃声
查看到设备的位置信息，您可以根据位置信息前往，并在到达附近位置后可以播放铃声，以便您能通过铃声更快找寻您的手机大概位置(尽量避免未到达时开启铃声，防止拿到手机的人强制关机，导致无法进行定位，被定位设备可以主动关闭铃声)。
*如设备未开机联网，则无法播放铃声。
3)可以进行擦除数据操作，以保护您的信息安全
如果定位失败，会显示“离线”或是“设备不在线”，表明您的设备可能已经关机或是不满足定位条件，但仍然可以进行远程锁定，擦除数据，待设备成功定位后指令会立即生效，以保障您的信息安全。
点击擦除数据，设备所有内容数据将被永久删除，但不影响云空间备份数据。点击擦除数据后只能定位无法锁定及播放铃声，擦除数据不可撤销，请慎重操作。(备注：EMUI4.0以下手机擦除数据后无法再继续定位跟踪)。
4)若开启了查找手机“发送最后位置”开关，开启后在设备电池快耗尽时(电量5％~10％)，设备会自动向服务器发送最后位置信息，若未开启此开关，设备不会自动触发定位。
最后小编提醒小伙伴，功能虽好，但一定要保管好自己的手机，减少丢失或被盗的风险才是王道哦！
常见问题及解决办法
查找我的手机的定位误差范围
实际定位的位置依赖当时被定位手机周围环境的信号强度，不同信号下查找我的手机的定位的定位精度范围不同。
*GPS定位：定位精度在10米－100米之间。
*WLAN定位：定位精度在5米－200米之间。
*基站定位：依赖移动、联通、电信等基站信息，定位精度在500米-5000米之间。
查找手机的定位准确度与地图的准确度、定位环境有关，WLAN信号、阴雨天气、高大建筑物、建筑密度、地铁内等场景下，都会影响定位准确度，建议用户点击查找手机界面的定位设备按钮，手动定位刷新最新位置信息，以此操作来进一步提高定位准确度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552aae90d38bb97b733238b1a6217084/" rel="bookmark">
			# Mybatis 代码生成器使用（生成某张表的相关代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis 代码生成器使用（生成某张表的相关代码） 其实MyBatis Generator就可以实现所有的功能，为了学习一下随便写的 引入依赖 &lt;dependencies&gt; &lt;!-- Mybaits 生成器代码 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 生成器主类 Generator.java public class Generator { private static Logger logger = Logger.getLogger(String.valueOf(Generator.class)); public static void main(String[] args) { logger.info("=====&gt;准备生成代码"); String table = null; String file = null; try { System.out.println("请输入表名："); InputStream in = System.in; Scanner scanner = new Scanner(in); table = scanner.next(); logger.info("=====&gt;表名称为："+table); System.out.println("请输入数据库配置文件名："); file = scanner.next(); logger.info("=====&gt;文件位置为："+file); scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552aae90d38bb97b733238b1a6217084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf19a48cb33a1eaa00cb9929828e4dbf/" rel="bookmark">
			python 3.6 将一个正整数分解质因数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#14.题目：将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。 ###写一个函数，用来判断是否是素数 def isPrimeNumber(b): count = 0 for i in range(2,b): if b%i==0: count=count+1 if count==0: return True #print(b,"是素数") 是素数返回 True else: return False #print(b,"不是素数") 不是素数返回 False def fix(x): list=[] #先设置一个空格列表 ，用来放 质因数 y=x #设置一个中间变量，y,每次需要对y 进行循环求解质因数，一旦 flag=1 while flag==1: for i in range(2,y): if y%i==0: if isPrimeNumber(i) is True and isPrimeNumber(y//i) is False: list.append(i) y=y//i #更新y的值，重新发起求解质因数 break #结束本次 for循环，判断是否从whilec重新开始，重新进入for循环，从i=2重新开始 if isPrimeNumber(i) is True and isPrimeNumber(y//i) is True: list.append(i) list.append(y//i) flag = 0 #flag=0 可以退出 while循环 break #结束本次 for循环，判断是否重新进入while循环 return list #最终将存放所有质因子的list返回 asd=int(input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf19a48cb33a1eaa00cb9929828e4dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bcd565f05e8035d5aaaf774133b2671/" rel="bookmark">
			MOS管基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： 记得诚电子设计
0. 概述 0.1 MOS管的分类 场效应管分为结型（JFET）和金属-氧化物-半导体型（MOSFET）两种类型，JFET的英文全称是Junction Field-Effect Transistor，也分为N沟道和P沟道两种，在实际中几乎不用。MOSFET英文全称是Metal-Oxide-Semiconductor Field-Effect Transistor，应用广泛，MOSFET一般称MOS管。
MOSFET有增强型（EMOS，即Enhancement MOS）和耗尽型（DMOS，即Depletion MOS）两大类，增强型和耗尽型每一类下面都有NMOS和PMOS。
一般主板上使用最多的是增强型的MOS管，NMOS最多，一般用在信号控制方面；其次是PMOS，PMOS用在电源开关等方面，耗尽型几乎不用。
0.2 增强型中NMOS与PMOS的区分 箭头指向G极的为NMOS；箭头背向G极的为PMOS。
也可以这样想，把箭头看成是二极管，箭头的指向就是二极管的由P指向N的方向，这样的话，箭头的头部就是N，箭头的尾部就是P。
以左图为例，箭头的头部在沟道上，因此这个MOS管为N沟道；以右图为例，箭头的尾部在沟道上，因此这个MOS管为P沟道。
下图为N沟道和P沟道MOS管的结构图。
0.3 工作原理 增强型MOS管的漏极D和源极S之间有两个背靠背的PN结。当栅-源电压VGS=0时，即使加上漏-源电压VDS，总有一个PN结处于反偏状态，漏-源极间没有导电沟道(没有电流流过)，所以这时漏极电流ID=0。
此时若在栅-源极间加上正向电压，即VGS&gt;0，则栅极和硅衬底之间的SiO2绝缘层中便产生一个栅极指向P型硅衬底的电场，由于氧化物层是绝缘的，栅极所加电压VGS无法形成电流，氧化物层的两边就形成了一个电容，VGS等效是对这个电容充电，并形成一个电场，随着VGS逐渐升高，受栅极正电压的吸引，在这个电容的另一边就聚集大量的电子并形成了一个从漏极到源极的N型导电沟道，当VGS大于管子的开启电压VT(一般约为 2V)时，N沟道管开始导通，形成漏极电流ID，我们把开始形成沟道时的栅-源极电压称为开启电压，一般用VT表示。
控制栅极电压VGS的大小改变了电场的强弱，就可以达到控制漏极电流ID的大小的目的，这也是MOS管用电场来控制电流的一个重要特点，所以也称之为场效应管。
0.4 特性 MOS管的栅极G和源极S之间是绝缘的，由于Sio2绝缘层的存在，在栅极G和源极S之间等效是一个电容存在，电压VGS产生电场从而导致源极-漏极电流的产生。此时的栅极电压VGS决定了漏极电流的大小，控制栅极电压VGS的大小就可以控制漏极电流ID的大小。这就可以得出如下结论：
MOS管是一个由改变电压来控制电流的器件，所以是电压器件。MOS管的输入特性为容性特性，所以输入阻抗极高。 0.5 寄生二极管 由于生产工艺，一般的MOS管会有一个寄生二极管，寄生二极管有的也叫体二极管，也叫续流二极管。在驱动感性负载（如马达），这个二极管很重要。顺便说一句，体二极管只在单个的MOS管中存在，在集成电路芯片内部通常是没有的。
在驱动感性负载(如电机、线圈等)时，当驱动电压突然断开，负载会产生很大的反电动势，因此为了防止电动机产生的反电动势烧坏开关器件，比如选用带有体二极管的MOS管，体二极管可以吸收电动机产生的反电动势。这时如果MOS管没有体二极管的话，反向电流会将MOS管反向击穿，烧坏器件。
NMOS寄生二极管方向由S极→D极，PMOS的寄生二极管方向由D极→S极。
寄生二极管和普通二极管一样，正接会导通，反接会截止。所以对于NMOS，当S极接正，D极接负，寄生二极管会导通，反之，截止；对于PMOS管，当D极接正，S极接负，寄生二极管导通，反之，截止。
某些应用场合，也会选择走寄生二极管，以增大DS之间的压降（寄生二极管的压降是比MOS的导通压降大很多的），同时也要关注寄生二极管的过电流能力。
当满足MOS管的导通条件时，MOS管的D极和S极会导通，因为MOS管的导通内阻极小，一般mΩ级别，1A级别的电流，也才mV级别，所以D极和S极之间的导通压降很小，不足以使寄生二极管导通，这点需要特别注意。
1. MOS管的导通条件 MOS管是压控型，导通由G和S极之间压差决定。
对于NMOS，当Vg-Vs&gt;Vgs(th)时，MOS管导通，即G极和S极的差大于一定值，MOS管会导通，但是也不能大太多，Vgs(th)和其他参数需要看MOS管的SPEC。
对于PMOS，和NMOS管是相反的，当Vs-Vg&gt;vsg(th)时，PMOS管导通，即S极和G极的差大于一定值，MOS管会导通，但是也不能大太多，同样的，具体参数看SPEC。
2. 基本开关电路 NMOS管一般用在信号控制上。
当GPIO_CTRL电压小于MOS管开启电压时，MOS管截止，OUT通过R1上拉到5V，OUT=5V。
当GPIO_CTRL电压大于MOS管开启电压时，MOS管导通，D极电压等于S极电压，OUT=0V；
PMOS管常用在电源开关上。
当GPIO_CRTL=0V，S和G极压差大于MOS管开启电压时，MOS管导通，5V_VOUT=5V_VIN；
3. 与三极管(BJT)的区别 三极管是电流控制(通过基极较小的电流控制较大的集电极电流)，MOS管是电压控制(通过栅极电压控制源漏间导通电阻)，主要有如下的区别：
只容许从信号源取少量电流的情况下，选用MOS管；在信号电压较低，有容许从信号源取较多电流的条件下，选用三极管。
MOS管是单极性器件（靠一种多数载流子导电），三极管是双极性器件（既有多数载流子，也要少数载流子导电）。
有些MOS管的源极和漏极可以互换运用，栅极也可正可负，灵活性比三极管好。
MOS管应用普遍，可以在很小电流和很低电压下工作。
MOS管输入阻抗大，低噪声，MOS管较贵，三极管的损耗大。
MOS管常用来作为电源开关，以及大电流开关电路、高频高速电路中，三极管常用来数字电路开关控制。
三极管便宜，常用在数字电路开关控制；mos管贵，常用来电源开关，以及大电流地方开关电路。
MOS管不仅可以做开关电路，也可以做模拟放大，因为栅极电压在一定范围内的变化会引起源漏间导通电阻的变化。
MOS管(场效应管)的导通压降下，导通电阻小，栅极驱动不需要电流，损耗小，驱动电路简单，自带保护二极管，热阻特性好，适合大功率并联，缺点开关速度不高，比较昂贵。
三极管开关速度高，大型三极管的Ic可以做的很大，缺点损耗大，基极驱动电流大，驱动复杂。
MOS管用于高频高速电路，大电流场合，以及对基极或漏极控制电流比较敏感的地方。
一般来说低成本场合，普通应用的先考虑用三极管，不行的话考虑MOS管。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1a72dbf9da5c21b83ab68e5dfb039d/" rel="bookmark">
			python中append和extend的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从两个角度来说：
1、append可以追加一个list，一个对象；
extend则是把两个list连接起来，类似matlab的cat函数。
NumList1 = [1,2,3] NumList2 = ['a','b','c'] NumList1.append(NumList2) print("列表2append到列表1：",NumList1) print('第四个元素为',NumList1[3]) NumList1 = [1,2,3] NumList1.extend(NumList2) print("列表2extend到列表1：",NumList1) 输出结果为：
列表2append到列表1： [1, 2, 3, [‘a’, ‘b’, ‘c’]]
第四个元素为 [‘a’, ‘b’, ‘c’]
列表2extend到列表1： [1, 2, 3, ‘a’, ‘b’, ‘c’]
2、对于拷贝的角度，append引用的是追加对象的地址；extend是直接复制第二个数组的值，创建了新的存储空间。
NumList1 = [1,2,3] NumList2 = ['a','b','c'] NumList1.append(NumList2) NumList2[0] = '更改第一个元素' print('拷贝问题',NumList1) NumList1 = [1,2,3] NumList2 = ['a','b','c'] NumList1.extend(NumList2) NumList2[0] = '更改第一个元素' print('拷贝问题',NumList1) 输出结果为：
拷贝问题 [1, 2, 3, [‘更改第一个元素’, ‘b’, ‘c’]]
拷贝问题 [1, 2, 3, ‘a’, ‘b’, ‘c’]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3449bb61fe680c5af3085be8f44081d2/" rel="bookmark">
			ultraedit查找每行第二个单词_Excel公式练习34： 识别是否存在相同字母的单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习Excel技术，关注微信公众号：
excelperfect
导语：这个案例来自于excelxor.com，真是太佩服了！这样复杂的要求都能够用公式解决，这样的解决方法都能够想到！
本次的练习是：判断单元格区域B1:B10的各单元格中的单词是否在单元格区域E1:E10中出现，如果该单词出现或者存在有与该单词相同字母组成的单词，则返回TRUE，否则返回FALSE。要求在列A中输入公式进行判断，如下图1所示。
图1
先不看答案，自已动手试一试。
公式
在单元格A1中输入数组公式：
=OR((LEN($E$1:$E$10)=LEN(B1))*(MMULT(0+(LEN(SUBSTITUTE(LOWER($E$1:$E$10),MID(LOWER(B1),TRANSPOSE(ROW(INDIRECT("1:"&amp;LEN(B1)))),1),""))=LEN(SUBSTITUTE(LOWER(B1),MID(LOWER(B1),TRANSPOSE(ROW(INDIRECT("1:"&amp; LEN(B1)))),1),""))),ROW(INDIRECT("1:" &amp;LEN(B1)))^0))=LEN(B1))
下拉至单元格A10，如下图2所示。
图2
公式解析
原文使用单元格A3中的公式来分析：
=OR((LEN($E$1:$E$10)=LEN(B3))*(MMULT(0+(LEN(SUBSTITUTE(LOWER($E$1:$E$10),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp;LEN(B3)))),1),""))=LEN(SUBSTITUTE(LOWER(B3),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp; LEN(B3)))),1),""))),ROW(INDIRECT("1:" &amp;LEN(B3)))^0))=LEN(B3))
公式的第一部分：
LEN($E$1:$E$10)=LEN(B3)
检查单元格区域E1:E10中有哪些单词与单元格B3中单词的字符数相同，得到数组：
{TRUE;FALSE;TRUE;TRUE;FALSE;TRUE;TRUE;TRUE;TRUE;FALSE}
公式的主要部分，即传递给MMULT函数的第一个数组：
0+(LEN(SUBSTITUTE(LOWER($E$1:$E$10),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp;LEN(B3)))),1),""))=LEN(SUBSTITUTE(LOWER(B3),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp; LEN(B3)))),1),"")))
先看看：
LEN(SUBSTITUTE(LOWER($E$1:$E$10),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp; LEN(B3)))),1),""))
其中：
1. LOWER($E$1:$E$10)
将单元格E1:E10中的数据转换成小写，以避免一些函数区分大小写问题。结果为：
{"andrew";"adel";"shelia";"anelie";"blake";"andria";"shelia";"eleina";"kassia";"daren"}
这个数组被传递给SUBSTITUTE函数，作为其第1个参数。
2. MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:" &amp;LEN(B3)))),1)
其中：
(1)LOWER(B3)
结果为：
eliane
(2)TRANSPOSE(ROW(INDIRECT("1:" &amp;LEN(B3))))
转换为：
TRANSPOSE(ROW(INDIRECT("1:" &amp;6)))
转换为：
TRANSPOSE({1;2;3;4;5;6})
结果为：
{1,2,3,4,5,6}
因此，MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:" &amp;LEN(B3)))),1)被转换为：
MID(“eliane”,{1,2,3,4,5,6},1)
最终创建组成单元格B3中字符串的字母构成的数组：
{“e”,”l”,”i”,”a”,”n”,”e”}
3. 因此，LEN(SUBSTITUTE(LOWER($E$1:$E$10),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp; LEN(B3)))),1),""))转换为：
LEN(SUBSTITUTE({"andrew";"adel";"shelia";"anelie";"blake";"andria";"shelia";"eleina";"kassia";"daren"},{“e”,”l”,”i”,”a”,”n”,”e”},””))
SUBSTITUTE函数参数中有两个数组，一个是10行1列的数组，另一个是1行6列的数组，得到一个10行6列的数组：
{"andrw","andrew","andrew","ndrew","adrew","andrw";"adl","ade","adel","del","adel","adl";"shlia","sheia","shela","sheli","shelia","shlia";"anli","aneie","anele","nelie","aelie","anli";"blak","bake","blake","blke","blake","blak";"andria","andria","andra","ndri","adria","andria";"shlia","sheia","shela","sheli","shelia","shlia";"lina","eeina","elena","elein","eleia","lina";"kassia","kassia","kassa","kssi","kassia","kassia";"darn","daren","daren","dren","dare","darn"}
作为LEN函数的参数，得到：
{5,6,6,5,5,5;3,3,4,3,4,3;5,5,5,5,6,5;4,5,5,5,5,4;4,4,5,4,5,4;6,6,5,4,5,6;5,5,5,5,6,5;4,5,5,5,5,4;6,6,5,4,6,6;4,5,5,4,4,4}
再看看等号的另一侧：
LEN(SUBSTITUTE(LOWER(B3),MID(LOWER(B3),TRANSPOSE(ROW(INDIRECT("1:"&amp; LEN(B3)))),1),""))
转换为：
LEN(SUBSTITUTE("eliane",{"e","l","i","a","n","e"},""))
转换为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3449bb61fe680c5af3085be8f44081d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259b2639ea4f113689c4f1df19ffcf8f/" rel="bookmark">
			pytorch的nn.MSELoss损失函数返回值介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、均方差损失函数 loss, x, y 可以是向量或者矩阵，i 是下标。
很多的loss函数都有size_average和reduce两个布尔类型的参数。因为一般损失函数都是直接计算 batch 的数据，因此返回的loss 结果都是维度为 (batch_size, ) 的向量。(说的是一般的情况，这里返回的没有维度为(batch_size,)这种情况)
2、nn.MSELoss()参数介绍 (1)如果 reduction = ‘none’，直接返回向量形式的 loss(2)如果 reduction ≠ ‘none’，那么 loss 返回的是标量
a)如果 reduction=‘mean’，返回 loss.mean(); 注意：默认情况下， reduction=‘mean’
b)如果 reduction=‘sum’，返回 loss.sum(); 3、代码 import torch import numpy as np a = np.array([[1, 2], [3, 4]]) b = np.array([[2, 3], [4, 4]]) inputs = torch.autograd.Variable(torch.from_numpy(a)) targets = torch.autograd.Variable(torch.from_numpy(b)) # **************************************************** # 1、返回向量 # **************************************************** loss_fn_1 = torch.nn.MSELoss(reduction='none') # 将Variable类型统一为float()（tensor类型也是调用xxx.float()） loss_1 = loss_fn_1(inputs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/259b2639ea4f113689c4f1df19ffcf8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4844c8fc3233a882fc75996c624934/" rel="bookmark">
			python 网格搜索 卡死_诡异的pip卡死问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pip安装包去venv里面，用pycharm的图形界面和pycahrm的命令行去跑，结果都卡死了，没有正常退出，但是看命令行里面的log，应该是成功的安装了才对。百思不得其解，直接按CTRL+C退出来，爆出来的Traceback如附件中的piplog.zip(里面是个.txt)
那么这个：当文件已存在时，无法创建该文件。: 'c:\\users\\avatu\\
appdata\\local\\pip\\cache\\http\\8\\2\\f\\d\\8\\82fd835af304644b417e2e805b44d1181077
da8bd78fad2fb38eb199.lock'
究竟是个什么鬼呢？
研究了一下，发现虽然用了pycharm的命令行工具进行pip，但是pip读取的cache居然还是系统全局的cache.......呃........
所以会看到有人使用 nocache的参数使用pip来避免pip卡死
反思一下我自己的操作，我在系统里面有不止一个解释器(3.5还有3.7)，而且我还有一大堆工程各自在用自己的小env....如果他们都用同一个cache.....好吧，我想这应该是一场大灾难了
解决的办法？
我把~\appdata\local\pip\cache里面所有的缓存文件都给删了，在这之后：
命令行：check
pycharm图形界面：check
pycharm terminal：check
世界一下子又变得美好起来了 O(∩_∩)O
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e572c4dde3a0db5052c224b7726e1b07/" rel="bookmark">
			tcp 测试工具_成哥总结：常用网络连通性测试工具（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文约需要10分钟，您可以先关注我们，避免下次无法找到。
01 前言 不管你是敲代码的，搞运维的，玩管理项目的，就算你只是想在家上个网，你都可能会用到成哥总结的网络连通性工具。
成哥打算用上下两篇文章把下图总结的工具给大家讲透。
上篇给大家讲讲ICMP和TCP层面的网络连通性测试工具。
下篇来介绍剩下的内容，包括nslookup、dig和curl。
另外，browser就是浏览器访问了，这个大家都很熟悉，不再赘述。
02 UDP UDP是一个简单的面向数据报的传输层协议，不提供可靠性。
使用UDP的应用进程需要控制UDP数据报的长度，不能让其超过网络MTU值，不然就会产生IP分片。因为UDP进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。
UDP数据报作为IP数据报的数据部分，包含在IP首部中。如下图所示：
UDP首部非常简单，其实UDP首部啥也没有。
且看下图，UDP首部只有四个部分：源端口号、目端口号、UDP长度和UDP检验和字段。
(1)端口号 (16位)
端口号表示发送进程和接收进程。
UDP端口号和TCP端口是相互独立的，有些知名服务的UDP和TCP使用相同的端口，只是为了使用方便。比如DNS的TCP 53端口和UDP 53端口。
(2)UDP长度 (16位)
UDP长度字段指的是UDP首部和UDP数据的字节长度之和。
理论上来说UDP的长度可达2^16字节，即65535字节。
下图展示了UDP长度为55字节的数据报。我们算一下，55字节(UDP长度) = 47字节(UDP数据)+ 8字节(UDP首部)。
(3)UDP检验和 (16位)
UDP检验和覆盖UDP首部和UDP数据。
03 nslookup nslookup (name server lookup) 域名查询，是一个用于查询 Internet域名信息和诊断DNS 服务器问题的工具。
通过使用nslookup工具，可以在windows和linux平台上查到对应的ip地址，同时可判断DNS服务器是否正常工作。
Window平台的使用如下：
Linux平台的使用如下：
如果使用nslookup工具解析出来了地址，则说明DNS系统解析正常。如果解析异常，则说明DNS解析异常。
04 dig dig (domain information groper) 域信息搜索器用来探测DNS解析的情况。执行dig命令，显示从接受请求的域名服务器返回的答复。
dig只能在Linux平台中使用，范例如下：
如果使用dig工具解析出来了地址，则说明DNS系统解析正常。如果解析异常，则说明DNS解析异常。
05 HTTP HTTP(HyperText Transfer Protocol ，超文本传输协议)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。
HTTP属于TCP/IP模型中的应用层协议，应用层协议需要下层协议为其提供服务。因此HTTP需要在TCP协议建立的状态化数据通道基础上进行数据的传输。
在HTTP 1.0版本中， 每条TCP连接只能对应一次HTTP数据请求，每次HTTP数据请求结束后，随即断掉当前的TCP连接。
在HTTP 1.1版本中，多次HTTP数据请求都可以复用同一个TCP连接，并且多次HTTP数据请求可以并行进行，不必等待按先后顺序执行。
HTTP的请求和应答处理过程图下图所示：
通过数据分析来展示HTTP的一次完成请求和应答过程。
下图展示了GET请求和应答的数据帧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e572c4dde3a0db5052c224b7726e1b07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24eb5ae0f4e9d739c05e89742f1be90/" rel="bookmark">
			HTML多媒体元素——小白篇(9)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 返回目录 多媒体元素 视频元素video音频元素audio &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;多媒体元素学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--音频的学习 src:路径位置 controls:控制条 outoplay：自动播放 --&gt; &lt;audio src="../音乐.mp3" controls autoplay&gt;&lt;/audio&gt; &lt;!--视频的学习--&gt; &lt;viodeo src="../视频.MP4" controls autoplay&gt;&lt;/viodeo&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d745b55a30678fb9f5730b5119b539c1/" rel="bookmark">
			HTML表格——小白篇(7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返回目录 表格 为什么使用表格简单通用结构稳定
基本结构 显示结果： 属性说明&lt; table&gt;&lt; /table&gt;定义表格的标签&lt; tr&gt;&lt; /tr&gt;定义表格的行&lt; td&gt;&lt; /td&gt;定义表格的列&lt; th&gt;&lt; /th&gt;一般定义表头单元格，文字会加粗居中 案例
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表格学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--表格table 行：tr 列：td border: 边框 clospan:跨列 rowspan:跨行 --&gt; &lt;table border="1px"&gt; &lt;tr&gt; &lt;th colspan="3"&gt;课程表&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;上午&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;下午&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 网页显示
表格属性 属性名属性值说明alignleft、center、right、表格的对齐方式 , &lt; table align=“center” &gt;border数字或” “表格是否有边框，默认”“，没有边框，, &lt; table border=“1” &gt;cellpadding像素值表格单元格边缘与内容之间的空白，默认1像素。, &lt; table cellpadding=“0” &gt;cellpacing像素值表格单元格之间的空白，默认2像素。, &lt; table cellpacing=“0” &gt;width像素值表格的宽度，&lt; table width=“133” &gt;height像素值表格的高度， &lt; table height=“133” &gt; 合并单元格 先确定是跨行还是跨列合并。找到目标单元格，写上合并的单元格数量：比如：&lt; td colspan=“2”&gt;&lt; /td&gt;删除多余单元格 属性名属性值说明colspan数字跨列，例如：&lt; td colspan=“2”&gt;内容&lt; /td&gt;rowspan数字跨行, 例如：&lt; td rowspan=“2”&gt;内容&lt; /td&gt; 表格结构标签 为了更好的表示表格的语义，可以将表格分割成表头部分和表格主体部分两大部分。表格结构标签，分别用&lt; thead&gt;标签表格的头部区域、&lt; tbody&gt;标签表格的主体区域。这样更好的分清表格结构。 &lt;table border="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d745b55a30678fb9f5730b5119b539c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31446df002616f34154e2c0bb9ad45f/" rel="bookmark">
			html去除input标签默认边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		input表单点击会出现一个默认边框，设置border: none;或者border: 0;都没有效果，还是会有默认边框，怎么去除呢
css设置这个input的outline: none;
就可以了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/198/">«</a>
	<span class="pagination__item pagination__item--current">199/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/200/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>