<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791722d2ac588a447615c9696b784a41/" rel="bookmark">
			Node-Red系列教程——NodeRed通过OPC UA读取数据并写入mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.登录 http://127.0.0.1:1880/ 在nodered安装node-red-contrib-opcua
2.配置节点
3. 运行opc ua读取数据
4. 写入mysql
本文采用模拟数据，需先安装kepware和UaExpert
具体参考文章《使用kepware配置opcua服务端，并使用UaExpert作为opc客户端进行连接（匿名和用户名密码）_鲸鱼姐的博客-CSDN博客_kepware opc ua服务器配置》本文采用的方式为匿名。
1.登录 http://127.0.0.1:1880/ 在nodered安装node-red-contrib-opcua 注意node的版本，如果提示安装失败，请升级node版本
安装成功后左侧出现opcua节点
2.配置节点 配置最终效果如下：
（1）配置inject节点
（2）配置opcua-item节点
其中Item中的数据和UaExpert的NodeId数据保持一致，数据类型Type和UaExpert的Datatype保持一致，name可以随意填写
（3）配置opcua-client节点
（4）配置debug节点
3. 运行opc ua读取数据 部署完成后，单击注入节点，发现OPC UA Client状态为connecting，但是deug窗口没有数据，则需关闭防火墙
注意：关闭防火墙
（7）重新部署，单击注入后，调试窗口显示出数据
4. 写入mysql （1）nodered安装node-red-node-mysql插件
（2）创建数据库表plc_test,一共三个字段，id自动递增，plc存值，create_time存读取的时间
（3）配置node-red写mysql
function节点
var insertOne = "INSERT INTO plc_test(plc,create_time) VALUES ('%d',Now())"; var newMsg = { // @ts-ignore "topic": util.format(insertOne, msg.payload) } return newMsg; mysql数据库节点
5. 部署运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75907f6d2db5570feee05f46e47bb30b/" rel="bookmark">
			《Deep Reinforcement Learning for Autonomous Driving: A Survey》笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B Ravi Kiran , Ibrahim Sobh , Victor Talpaert , Patrick Mannion , Ahmad A. Al Sallab,
Senthil Yogamani , and Patrick Pérez
调研(D)RL在自动驾驶中的应用。
目录
1. 绪论
2. 自动驾驶（AD）系统的组成
2.1 场景理解
2.2 定位和建图
2.3 规划和驾驶策略
2.4 控制
3. 强化学习
3.1 基于价值的方法
3.2 基于策略的方法
3.3 演员-评论家方法
3.4 基于模型（vs.无模型）和On/Off Policy 方法
3.5 深度强化学习（DRL）
4. 强化学习扩展
4.1 设计奖励（Reward Shaping）
4.2 多智能体强化学习（MARL）
4.3 多目标强化学习（MORL）
4.4 状态表征学习（SRL）
4.5 从示例中学习（LfD）
5. 强化学习用于自动驾驶任务
5.1 状态空间、动作空间和奖励
5.2 运动规划和轨迹优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75907f6d2db5570feee05f46e47bb30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aea6317680c22435082766803b2b885/" rel="bookmark">
			matlab制作散点图及颜色调配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		散点图也是比较常用的数据分析图，今天来聊聊用matlab如何画一个散点图出来！
在matlab中，对应散点图的函数是scatter()。参数形式为scatter(横坐标，纵坐标，颜色，RGB通道)。
下面上代码：
%linespace是在0-3pi之间等距选取200个点 x = linspace(0,3*pi,200); y = cos(x) + rand(1,200); scatter(x,y); 效果图如下：
颜色依旧是默认的蓝色，下面聊聊如何修改颜色，让它看上去beautiful！
根据上面的参数形式，修改代码如下：
x = linspace(0,3*pi,200); y = cos(x) + rand(1,200); scatter(x,y,'r'); 'r’就是字母颜色的简写，这点和plot很像。效果图如下：
调节颜色也可以通过RGB通道来进行调节，这样会有更多的选择。代码修改如下：
x = linspace(0,3*pi,200); y = cos(x) + rand(1,200); %格式为scatter(x,y,[],RGB值)。第三个是散点的大小，如果默认的话就写[]，不写就会报错 scatter(x,y,[],[1,0.5,0]) 效果图如下：
关于常用RGB的配色，找到了一篇很好的博客，和大家分享：https://blog.csdn.net/wh1312142954/article/details/80796764link;
前面讨论了几种不同情况，但实际上画出的都是空心圆。有没有方法使用其他标注呢？当然有啦~
%x,y分别为横纵坐标向量，中间还是老规矩[]，RGB通道，最后指定标注类型。这里选择的是* scatter(x,y,[],[0,0,0.80392],'*') 效果图如下：
对于不同标注对应的符号，我在这里分享一位博主的博客，里面有比较详细的说明：https://blog.csdn.net/Eric_KEY/article/details/53285544link
在这里再插一下：今天终于弄懂plot的RGB值是怎么添加的了，有固定的格式：
%如果想自己调节RGB那么第三个就必须是‘color’ plot(x,y,'color',[RGB值]); 由于可以自动调节RGB值，也可以让RGB不断变换，代码如下：
x = linspace(0,3*pi,200); y = cos(x) + rand(1,200); c = linspace(1,10,length(x)); %这样RGB值就是变量了 scatter(x,y,[],c) 效果图如下（好看吧！）：
同样scatter也支持三维，使用函数scatter3(x,y,z)。在这里我就不给出例子了（其实是我想不到~）
散点图get，继续前进！
参考学习文章：https://zhuanlan.zhihu.com/p/45791053link
本文作者水平有限，如有不足之处，请下方评论区指出，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f346de4812560d2938f7cf2c4e44319/" rel="bookmark">
			Linux查看文件夹大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux查看文件夹大小
du -h --max-depth=1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e94aa39aa265f6c76a77502ac2255ea/" rel="bookmark">
			USB转多串口/单串口方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单路USB转单/多路串口方案 在日常开发或产品设计时，会遇到不少使用串口通讯或者调试的情况，一个串口时使用USB转单路串口则可优雅解决，但若是多个串口时则可能需要占据多个USB口，颇为麻烦，所以探索了单路USB转单/多路串口的方案提供给大家，以便不时之需。
1、CH343 USB转单串口芯片 常见的肯定是单路USB转单串口了，此处推荐使用CH343。提供VIO独立供电功能，通过控制输入VIO引脚的电压大小可以使其和不同电压的串口进行通讯，实现两端串口的电平匹配，能更好适用于不同串口信号电平使用需求，串口信号电压范围1.8V~5V。
波特率支持50bps~6Mbps，在满足基本调试的同时也可以进行一些特殊的高速串口数据上传，同时也可使用高波特率进行串口下载。
其中DTR引脚可复用为TNOW引脚即串口发送状态引脚，可直连RS485转换芯片的DE和RE引脚来控制其发送和接收使能，同时支持外接电平转换芯片实现RS232、RS422等的转换。目前有SOP-16/ESSOP10/QFN16_3X3三种封装型号。
技术手册：http://www.wch.cn/downloads/CH343DS1_PDF.html 驱动程序： ​	Windows：http://www.wch.cn/downloads/CH343SER_EXE.html ​	Linux ：https://github.com/WCHSoftGroup/ch343ser_linux ​	MacOS ：http://www.wch.cn/downloads/CH34XSER_MAC_ZIP.html 应用电路： ​	参考链接：http://www.wch.cn/downloads/CH343EVT_ZIP.html USB转TTL串口电路参考 2、CH342 单路USB转双路串口 ​CH342是一个USB总线的转接芯片，实现单路USB转两个异步串口，串口相互独立互不影响。每个串口都支持高速全双工，支持波特率范围50bps~3Mbps，支持奇偶校验，提供了常用的MODEM联络信号（RTS、CTS、DTR、DSR、RI、DCD），外接其他电平转换芯片则可快捷转换成RS232、RS422、RS485等接口。同时也支持串口I/O独立供电，可一路串口用于下载一路用于调试或者同时联调两个串口设备。
目前提供QFN24和ESSOP10及QFN12三种封装，信息如下：
技术手册：http://www.wch.cn/downloads/CH342DS1_PDF.html 驱动程序： ​	Windows：http://www.wch.cn/downloads/CH343SER_EXE.html ​	Linux ：https://github.com/WCHSoftGroup/ch343ser_linux ​	MacOS ：http://www.wch.cn/downloads/CH34XSER_MAC_ZIP.html 应用电路： ​	参考链接：http://www.wch.cn/downloads/CH342EVT_ZIP.html USB转TTL串口参考电路 USB转RS232参考电路 USB转RS485参考电路 官网评估板说明 3、CH344/CH9344单路USB转4路串口 CH344和CH9344都是单路USB转4路串口的转接芯片，其中CH344L为USB2.0全速接口，CH344Q和CH9344为USB2.0高速接口，其都提供 4 组全双工的异步串口UART0/1/2/3。两者之前区别如下：
芯片型号CH344QCH344LCH9344L接口类型高速USB2.0接口全速USB2.0接口高速USB2.0接口支持波特率1200bps~6Mbps1200bps~230400bps1200bps~12MbpsGPIO数量161212串口信号电压3.3V供电支持5V电源电压和3.3V电源电压串口0/1/2及部分I/O独立供电，支持3.3V和2.5V甚至1.8V电源电压。串口3支持3.3V供电串口参数支持8个数据位1个停止位支持奇校验、偶校验以及无校验支持8个数据位1个停止位支持奇校验、偶校验以及无校验5、6、7、8个数据位以及1个或2个数据位支持奇、偶、无校验、SPACE、MARK校验USB配置功能支持自定义配置支持自定义配置不支持自定义配置 ​目前提供LQFP48封装,信息如下：
技术手册： ​	CH344 ：http://www.wch.cn/downloads/CH344DS1_PDF.html ​	CH9344：http://www.wch.cn/downloads/CH9344DS1_PDF.html 驱动程序： ​	（CH344和CH342使用同个驱动，此处为CH9344驱动） ​	Windows：http://www.wch.cn/downloads/USBMSER_exe.html ​	Linux ：https://github.com/WCHSoftGroup/ch9344ser_linux 应用电路： 参考链接： ​	CH344 ：http://www.wch.cn/downloads/CH344EVT_ZIP.html ​	CH9344：http://www.wch.cn/downloads/CH9344EVT_ZIP.html CH9344-USB转TTL参考电路 CH9344-USB转RS232参考电路 官网评估板说明 4、CH348 单路USB转8路串口 ​ CH348为单路USB转8路异步串口的转接芯片，串口之间互相独立，支持1200bps6Mbps波特率，CH348L串口I/O支持独立供电，电压范围1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e94aa39aa265f6c76a77502ac2255ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a745d2ef42ca61b2a53e762dd19047a/" rel="bookmark">
			Java身份证校验工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java身份证校验工具类 工作中经常会涉及到身份证的校验，而且需求不同，有的需要校验最后一位校验位，有的不需要，这里参考了几篇文章及自己工作中用到的情况写了一个工具类。记录一下，菜鸟一个，大佬勿喷。
这里只考虑18位身份证
public class IdCardValidateUtils { /** 省份开头字典 */ private static Map&lt;Integer, String&gt; provinces = new HashMap&lt;&gt;(); static { provinces.put(11, "北京"); provinces.put(12, "天津"); provinces.put(13, "河北"); provinces.put(14, "山西"); provinces.put(15, "内蒙古"); provinces.put(21, "辽宁"); provinces.put(22, "吉林"); provinces.put(23, "黑龙江"); provinces.put(31, "上海"); provinces.put(32, "江苏"); provinces.put(33, "浙江"); provinces.put(34, "安徽"); provinces.put(35, "福建"); provinces.put(36, "江西"); provinces.put(37, "山东"); provinces.put(41, "河南"); provinces.put(42, "湖北 "); provinces.put(43, "湖南"); provinces.put(44, "广东"); provinces.put(45, "广西"); provinces.put(46, "海南"); provinces.put(50, "重庆"); provinces.put(51, "四川"); provinces.put(52, "贵州"); provinces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a745d2ef42ca61b2a53e762dd19047a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3faeae566c64bfe8120dcf734d2e4725/" rel="bookmark">
			ProColumns中valueEnum的不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ProColumns中valueEnum的不生效问题 问题的描述
列表中，通过后台返回的Status值做枚举展示，但总是匹配不了。一直展示status状态number值
状态：all
正常的预期是什么？
正常显示状态：全部
状态：全部
问题产生的原因分析
通过官方demo对比，是增加了其他额外不相关的配置字段
columns={[ { title: "状态：", key: "state", dataIndex: "state", valueType: "select", ellipsis: true, valueEnum: { all: { text: "全部", status: "Default" }, open: { text: "未解决", status: "Error" }, closed: { text: "已解决", status: "Success" } } } ]} 问题的解决方案
通过官方demo对比，是增加了其他额外不相关的配置字段
修改如下即可完美解决 columns={[ { title: "状态：", key: "state", dataIndex: "state", valueType: "select", valueEnum: { all: { text: "全部", status: "Default" }, open: { text: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3faeae566c64bfe8120dcf734d2e4725/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3af8d05e60e2202a7dd7e249ff42c6/" rel="bookmark">
			一文学会动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 注意
在学习理论之前，希望读者能看如下几个例子，有助于理解
《算法导论》学习（十七）----动态规划之钢条切割（C语言）
《算法导论》学习（十八）----动态规划之矩阵链乘（C语言）
《算法导论》学习（十九）----动态规划之最长公共子序列（C语言）
文章目录 系列文章目录前言一、动态规划1.使用场景（1）什么是动态规划（2）动态规划与分治策略的对比 2.核心要素分析（1）最优子结构什么是最优子结构？构建结构 （2）重叠子问题什么是重叠子问题？问题解决 3.操作步骤（1）刻画问题特征（2）构建递归解（3）编写算法（4）构造最优解 总结 前言 本文主要讲解了动态规划的理论知识，表明动态规划的使用场景，分析了它的具体逻辑，给出了理论操作具体步骤。
一、动态规划 1.使用场景 （1）什么是动态规划 动态规划是一种用来解决一类最优化问题的编程方案，往往可以将指数时间代价的问题在多项式时间代价下解决，而这类最优化问题由如下特征：
某一级的最优化问题总是可以用比低级的同类子问题来描述，称为最优子结构一般情况下，解决第n级的子问题和解决第m级的子问题的时候，都会需要解决第k级的问题（n&gt;k,m&gt;k），称为重叠子问题如果解决该问题采用暴力求解（就是遍历所有情况得到最优解的方案），往往时间代价是指数级的 （2）动态规划与分治策略的对比 分治策略是一种很普遍的程序设计方法，在初学的时候感觉它们有很大的相似性，难以区分，因此特别在此作出区分，希望能帮助有困惑的读者
注：想了解分治策略的读者可以参考下面的文章：
《算法导论》学习（三）---- 最大和子数组问题的分治方法
《算法导论》学习（五）---- 分治策略(递归)的时间复杂度求解
动态规划与分治的对比大致如下：
都采用了用子问题来解决总问题的编程思路分治算法会采用固定的分割方式来切割问题成子问题，而动态规划的子问题切割方案由是否最优来决定，因此动态规划往往需要存储子问题的切割方式分治算法的往往采用递归的方法，设计算法是从上到下分割子问题的思路；动态规划往往采用自底向上的解决方案，即从最小的子问题开始向上解决，往往采用多层循环的方式动态规划需要存储所有的子问题的解，但是有的子问题的解对最终结果是基本没有作用的（如果忽略子问题间的比较以得到最优值这个过程）；分治策略中每一个子问题的解都会对最终结果的产生有或多或少的影响。因此动态规划解决的问题的时间代价一般比较大（纯个人见解，不一定正确）…(不妥之处大家请于评论区指出) 2.核心要素分析 （1）最优子结构 什么是最优子结构？ 最优子结构就是指：一个问题的最优解包含它的子问题的最优解
构建结构 最优子结构的构建步骤如下：
1.查看一个最优问题的解能不能用它的子问题一层一层地描述出来2.选择一种切割方案3.确定该方案需要哪些子问题来解决一个问题，包括子问题的个数和层级4.最后计算：得到最优切割方案所需要的遍历的情况数 （2）重叠子问题 什么是重叠子问题？ 重叠子问题一般指：几个子问题的解决往往都需要用到相同的层级偏低的子问题。通俗的来讲，就是循环程序会重复解决一些子问题
问题解决 采用自底向上的解决结构：
先从最小的子问题开始解决，然后将解存入存储矩阵，之后再需要用到已解决的子问题时们直接访问存储好的最优解即可 3.操作步骤 （1）刻画问题特征 首先就是要明确问题的特征是否包含两个特点：最优子结构与子问题重叠，如果满足两点，就可以考虑使用动态规划的解决方案解读问题的条件和目的，看看能不能构造出最优子结构。构造最优子结构的步骤见上如果可以构造出最优子结构，那么就要在模糊的方案上添加逻辑细节，保证所有情况下，都可以用该最优子结构方案解决好问题 （2）构建递归解 根据上一步编写好的完善的最优子结构方案，来写出它的数学公式设计一些存储变量，使得递归公式得以运行。比如存储子问题最优解的存储单元明确各个逻辑条件 （3）编写算法 首先申明存储变量，主要有存储子问题解和存储分割方案的存储单元
设计循坏方案，需要自底向上的逻辑结构
返回最优值
（4）构造最优解 通过切割方案的存储矩阵，获取每一次分割的方案设计递归结构，可以用递归树的方案来设计具体的细节明确具体要打印的一些数据 总结 文章的不妥之处请各位读者包涵指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d34b4b2aa43ce68b824c6ee37d4358/" rel="bookmark">
			css中的 :root
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 :root
是一个伪类，表示文档根元素，所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本。
在:root中声明相当于全局属性，只要当前页面引用了:root segment所在文件，都可以使用var()来引用。
用 – 这样写法加上样式名称 例如：–background 引用：var(–background)
:root { --blue: #007bff; --color:red; --background:#ccc; } var()
var()函数可以代替元素中任何属性中的值的任何部分。var()函数不能作为属性名、选择器或者其他除了属性值之外的值。（这样做通常会产生无效的语法或者一个没有关联到变量的值。）
body { background-color: var(--background); /* 设置背景颜色为#ccc */ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d8e0774baf8efa7cddbdb9a8071e9e/" rel="bookmark">
			excel百万数据如何导入导出？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目开发中往往需要使用到数据的导入和导出,导入就是从Excel中导入到DB中,而导出就是从DB中查询数据然后使用POI写到Excel上。
写本文的背景是因为在工作中遇到了大数据的导入和导出，问题既然来了逃跑不如干掉它！！！
只要这一次解决了，后期遇到同样的问题就好解决了。
废话不多说，开始撸起来！！！
# 传统POI的的版本优缺点比较
其实想到数据的导入导出,理所当然的会想到apache的poi技术,以及Excel的版本问题。
既然要做导入导出,那么我们就先来大致看一下传统poi技术的版本以及优缺点对比吧!
首先我们知道POI中我们最熟悉的莫过于WorkBook这样一个接口，我们的POI版本也在更新的同时对这个几口的实现类做了更新；
HSSFWorkbook : 这个实现类是我们早期使用最多的对象，它可以操作Excel2003以前（包含2003）的所有Excel版本。在2003以前Excel的版本后缀还是.xls
XSSFWorkbook : 这个实现类现在在很多公司都可以发现还在使用，它是操作的Excel2003--Excel2007之间的版本，Excel的扩展名是.xlsx
SXSSFWorkbook : 这个实现类是POI3.8之后的版本才有的,它可以操作Excel2007以后的所有版本Excel,扩展名是.xlsx
大致知道了我们在导入导出操作的时候会用到这样三个实现类以及他们可以操作的Excel版本和后缀之后,我们就要从优缺点分析他们了
HSSFWorkbook 它是POI版本中最常用的方式,不过:
它的缺点是 最多只能导出 65535行,也就是导出的数据函数超过这个数据就会报错;
它的优点是 不会报内存溢出。（因为数据量还不到7w所以内存一般都够用，首先你得明确知道这种方式是将数据先读取到内存中，然后再操作）
XSSFWorkbook
优点：这种形式的出现是为了突破HSSFWorkbook的65535行局限，是为了针对Excel2007版本的1048576行，16384列，最多可以导出104w条数据；
缺点：伴随的问题来了，虽然导出数据行数增加了好多倍，但是随之而来的内存溢出问题也成了噩梦。因为你所创建的book，Sheet，row，cell等在写入到Excel之前，都是存放在内存中的（这还没有算Excel的一些样式格式等等），可想而知，内存不溢出就有点不科学了！！！
SXSSFWorkbook
从POI 3.8版本开始，提供了一种基于XSSF的低内存占用的SXSSF方式;
优点：
这种方式不会一般不会出现内存溢出（它使用了硬盘来换取内存空间，
也就是当内存中数据达到一定程度这些数据会被持久化到硬盘中存储起来，而内存中存的都是最新的数据），
并且支持大型Excel文件的创建（存储百万条数据绰绰有余）。
缺点：
既然一部分数据持久化到了硬盘中，且不能被查看和访问那么就会导致，
在同一时间点我们只能访问一定数量的数据，也就是内存中存储的数据;
sheet.clone()方法将不再支持,还是因为持久化的原因;
不再支持对公式的求值，还是因为持久化的原因，在硬盘中的数据没法读取到内存中进行计算；
在使用模板方式下载数据的时候，不能改动表头，还是因为持久化的问题，写到了硬盘里就不能改变了；
# 使用方式哪种看情况
经过了解也知道了这三种Workbook的优点和缺点，那么具体使用哪种方式还是需要看情况的：
我一般会根据这样几种情况做分析选择：
1.当我们经常导入导出的数据不超过7w的情况下，可以使用 HSSFWorkbook 或者 XSSFWorkbook都行；
2.当数据量查过7w并且导出的Excel中不牵扯对Excel的样式，公式，格式等操作的情况下，推荐使用SXSSFWorkbook;
3.当数据量查过7w，并且我们需要操做Excel中的表头，样式，公式等，
这时候我们可以使用 XSSFWorkbook 配合进行分批查询，分批写入Excel的方式来做；
# 百万数据导入导出（正菜）
铺垫也做了不少，那么现在开始讲讲我在工作中遇到的超百万数据的导入导出解决方案：
想要解决问题我们首先要明白自己遇到的问题是什么？
1、 我遇到的数据量超级大，使用传统的POI方式来完成导入导出很明显会内存溢出，并且效率会非常低；
2、 数据量大直接使用select * from tableName肯定不行，一下子查出来300w条数据肯定会很慢；
3、 300w 数据导出到Excel时肯定不能都写在一个Sheet中，这样效率会非常低；估计打开都得几分钟；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d8e0774baf8efa7cddbdb9a8071e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc7c0c6a7c590277f16af8965b14158/" rel="bookmark">
			Stm32 cube IDE生成代码 &#43;烧写下载elf文件和 Stm32 cube Programmer 下载elf、hex、bin文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、通过STM32CubeIDE编译后能否生成BIN或HEX文件？能。
2、STM32CubeIDE工程显示栏中的ld后缀文件是什么文件？
3、STM32CubeProgrammer 下载HEX程序步骤
4、STM32CubeIDE生成代码烧写下载到单片机芯片方法
1、通过STM32CubeIDE编译后能否生成BIN或HEX文件？能。 默认情况下，通过STM32CubeIDE编译后生成的是ELF文件，如果希望生成HEX或BIN文件也是可以的。配置过程如下。
在主菜单project properties C++/C++ Build下面,打开如下界面：
2、STM32CubeIDE工程显示栏中的ld后缀文件是什么文件？ 它是工程链接脚本文件或者说程序加载文件，其它IDE也有类似的文件。比方ARMmdk中的.sct文件、IAR IDE中的.icf文件。
来自：stm32cubeide烧写程序_STM32CubeIDE使用入门的几个常见问题_weixin_39960116的博客-CSDN博客
3、STM32CubeProgrammer 下载HEX程序步骤 4、stm32cube IDE生成代码烧写下载到单片机芯片方法 stm32cube IDE生成代码烧写下载到单片机芯片方法_嵌入式阿萌的博客-CSDN博客
stm32cube IDE配置方法跟stm32cube MX的方法一样
然后点击此处生成代码。
添加流水灯代码
然后编译，Project—Build all, 没有错误警告后，开始下一步：下载程序
其实就是利用调试将程序下载进单片机
开始下载之前，将单片机和st-link连接并连接到电脑。
1. 点击debug—debug configurations(stlink更新后可以直接跳过这步)
双击后会提示更新stlink，更新即可，如果已经更新过可跳过这一步
2. 点击run—debug后出现如下界面，点击switch
至此，程序已经下载进单片机了，同时进入了调试界面
最近在学习stm32cube IDE生成代码却下载不了，网上找了一些资料，都没说明白，自己尝试着，居然成功了。不对之处请指正。
点击全速运行，可以看到效果，将st-link拔出，可以通电测试，程序下载好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa904f4e0a800eca839176d7c0e4854/" rel="bookmark">
			Vue中 $attrs、$listeners使用和理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 提示：Vue中 常见的组件通信方式可分为三类：
父子通信 通常父子传值都是 通过prpos,子组件通过events接收 通过父链/子链 通信($parent/$chldren); ref也可以访问实例 provide/inject $attrs/$listeners 兄弟通信 Bus; Vuex 跨级通信 Bus; Vuex; provide/inject $attrs/$listeners 一、前言 示例：多组件嵌套需要传递参数,通常使用vuex,但是如果只是传递数据,使用vuex不太合理,因为vuex实现的是两个组件两个值同步改变
故而Vue提供了另一种方法 使用v-bind=“$attrs”,将父组件不被认为props特性的属性传入子组件中,通常配合listeners选项一起使用,两个出现使组件之间跨组件通信不依赖vuex和bus变得简洁业务清晰
A组件跟b组件的通信:(父子组件)
如上图,abc分别是嵌套的,按照常规传参方式
a-&gt;b通过props方式向子组件传递b-&gt;a通过在b组件中使用$emit,a组件v-on接收通过全局设置vuex方式,通过computed计算属性和commit mutaion方式时间数据获取更新,达到父子通信目的Vue Event Bus 使用 Vue实例 实现事件监听发布,实现组件传值
一般数据不需要全局的情况父子传值 用第一种就可以解决 a组件与c组件通信(跨级组件嵌套关系)
使用b组件中转,a组件传递给b组件,b组件props接受再传递到c组件上,从下到上也是一次c组件emit传递,b也得emit传递,达到组件通信的效果通过Vuex全局使用Vue Event Bus实现监听和发布ps:如果只是祖先向子孙传递 不需要子孙返回 provide/inject 也可以解决
第一种方法会让代码显得冗余且不易于维护b组件只是中间站
第二种Vuex还是大材小用,只是组件数据传递,不是数据共享
第三种 如果不能很好的事件监听和发布管理 会导致数据流的混乱,不易于维护 ps:暂时没用过
第四种 只能达到向内传值 孙组件返不回去 知识点 个人理解就是 inheritAttrs 默认是true,他继承了父组件所有的属性(除了props特定的绑定) 如果不希望继承,可以改成false 但是class跟style不会受影响
attrs继承了父组件所有的属性 除了prop传递的属性,一般用在子组件的子元素
包含了负作用域所有的监听,可以配合v-on=“$listeners” 将所有事件监听器都指向组件特定子元素
实例 A组件（App.vue）
&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 此处监听了两个事件，可以在B组件或者C组件中直接触发 --&gt; &lt;child1 :pchild1="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa904f4e0a800eca839176d7c0e4854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854e420ed856397d65af343ec46ca112/" rel="bookmark">
			规则/流程引擎-ice简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ice简介 视频地址：
https://www.bilibili.com/video/BV1hg411A7jx/
ice简介视频
致力于解决灵活繁复的硬编码问题
官方文档：http://waitmoon.com/zh
背景介绍 规则/流程引擎想必大家并不陌生，耳熟能详的就有Drools，Esper，Activiti，Flowable等，很多大厂也热衷于研究自己的规则引擎，都是用于解决灵活场景下的复杂规则与流程问题，想要做到改改配置就可以生成/生效新的规则，脱离硬编码的苦海。毕竟改改配置和在已有基础上编排规则/流程，比硬编码的成本低很多，但是使用市面上现有的规则引擎来编排，一来接入成本和学习成本都不低，二来随着时间的推移，规则变的越发庞大以及一些场景的不适用，更加让人叫苦不迭。
设计思路 为了方便理解，设计思路将伴随着一个简单的充值例子展开
举例 X公司将在国庆放假期间，开展一个为期七天的充值小活动，活动内容如下：
活动时间：(10.1-10.7)
活动内容：
充值100元 送5元余额 (10.1-10.7)
充值50元 送10积分 (10.5-10.7)
**活动备注：**不叠加送(充值100元只能获得5元余额，不会叠加赠送10积分)
简单拆解一下，想要完成这个活动，我们需要开发如下模块：
图中发现有待发放key，这个key是从哪里来呢：
如图，当用户充值成功后，会产生对应充值场景的参数包裹Pack(类Activiti/Drools的Fact)，包裹里会有充值用户的uid，充值金额spend，充值的时间requestTime等信息。我们可以通过定义的key，拿到包裹中的值(类似map.get(key))。
模块怎么设计无可厚非，重点要讲的是后面的怎么编排实现配置自由，接下来将通过已有的上述节点，讲解不同的规则引擎在核心的编排上的优缺点，并比较ice是怎么做的。
流程图式实现 类Activiti、 Flowable实现
流程图式实现，应该是我们最常想到的编排方式了~ 看起来非常的简洁易懂，通过特殊的设计，如去掉一些不必要的线，可以把UI做的更简洁一些。但由于有时间属性，其实时间也是一个规则条件，加上之后就变成了：
看起来也还好
执行树式实现 类Drools实现(When X Then Y)
这个看起来也还好，再加上时间线试试：
依旧比较简洁，至少比较流程图式，我会比较愿意修改这个。
变动 上面两种方案的优点在于，可以把一些零散的配置结合业务很好的管理了起来，对配置的小修小改，都是信手拈来，但是真实的业务场景，可能还是要锤爆你，有了灵活的变动，一切都不一样了。
理想 不会变的，放心吧，就这样，上
现实 ①充值100元改成80吧，10积分变20积分吧，时间改成10.8号结束吧（微微一笑，毕竟我费了这么大劲，终于提现到价值了！）
②用户参与积极性不高啊，去掉不叠加送吧，都送（稍加思索，费几个脑细胞挪一挪还是可以的，怎么也比改代码再上线强吧！）
③5元余额不能送太多，设置个库存100个吧，对了，库存不足了充100元还是得送10积分的哈（*卒…*早知道还不如硬编码了）
以上变动其实并非看起来不切实际，毕竟真实线上变动比这离谱的多的是，流程图式和执行树式实现的主要缺点在于，牵一发而动全身，改动一个节点需要瞻前顾后，如果考虑不到位，很容易弄错，而且这还只是一个简单的例子，现实的活动内容要比这复杂的多的多，时间线也是很多条，考虑到这，再加上使用学习框架的成本，往往得不偿失，到头来发现还不如硬编码。
怎么办？
ice是怎么做的？ 引入关系节点 关系节点为了控制业务流转
AND
所有子节点中，有一个返回false 该节点也将是false，全部是true才是true，在执行到false的地方终止执行，类似于Java的&amp;&amp;
ANY
所有子节点中，有一个返回true 该节点也将是true，全部false则false，在执行到true的地方终止执行，类似于Java的||
ALL
所有子节点都会执行，有任意一个返回true该节点也是true，没有true有一个节点是false则false，没有true也没有false则返回none，所有子节点执行完毕终止
NONE
所有子节点都会执行，无论子节点返回什么，都返回none
TRUE
所有子节点都会执行，无论子节点返回什么，都返回true，没有子节点也返回true(其他没有子节点返回none)
引入叶子节点 叶子节点为真正处理的节点
Flow
一些条件与规则节点，如例子中的ScoreFlow
Result
一些结果性质的节点，如例子中的AmountResult，PointResult
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/854e420ed856397d65af343ec46ca112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94a1946f2a764a964b6831b2bfadfe1/" rel="bookmark">
			Flink&#43;ice 实现可视化规则编排与灵活配置(Demo)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ice文档站：http://waitmoon.com/zh
1 Demo仓库地址： github：https://github.com/zjn-zjn/flink-ice
gitee：https://gitee.com/waitmoon/flink-ice
2 Demo功能描述 通过netcat制造输入流（nc -l 9000 windows：nc -l -p 9000）
flink接收本地9000端口输入流，以回车(\n)分割单词
输入流经过IceProcessor处理后打印结果流
3 项目搭建 使用flink-quickstart-java快速搭建flink项目
3.1 添加ice依赖 因flink为非Spring项目，需依赖ice-core并手动初始化，Spring项目直接依赖ice-client-spring-boot-starter即可
&lt;dependency&gt; &lt;groupId&gt;com.waitmoon.ice&lt;/groupId&gt; &lt;artifactId&gt;ice-core&lt;/artifactId&gt; &lt;version&gt;${ice.version}&lt;/version&gt; &lt;/dependency&gt; 3.2 编写StreamingJob public class StreamingJob { public static void main(String[] args) throws Exception { // 创建 Flink 执行环境 final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); //接收本地socket9000端口输入流，以回车分割单词 //通过netcat制造输入流 nc -l 9000 (windows nc -l -p 9000) DataStreamSource&lt;String&gt; stream = env.socketTextStream("localhost", 9000, "\n"); //按照单词长度keyBy，使用IceProcessor并打印结果 stream.keyBy(String::length).process(new IceProcessor()).print().setParallelism(1); //执行程序 env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a94a1946f2a764a964b6831b2bfadfe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11aa79870df3809f9c2888560a215e5b/" rel="bookmark">
			编排流程/规则，编排本身也需要很深的逻辑思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是流程/规则编排？ 所谓编排，就是让已有的节点通过不同的组织方式完成不同的需求。
首先，我们需要对既有业务做一定程度的抽象，以一个例子开始：
一个简单的国庆节充值活动：
活动时间 10.1-10.7
充值≥100 元，送 5 元余额
充值≥50 元，送 10 积分，10.5 之后开始
不叠加送， 即充 100 元只送 5 元余额不会叠加再送 10 积分
当充值发生时，我们拥有：充值用户-uid，充值金额-cost，充值时间-time
再有一些制作好的抽象节点，如：
判断充值≥100 的条件节点 ScoreFlow-100，cost≥100 返回 true，否则返回 false判断充值≥50 的条件节点 ScoreFlow-50，cost≥50 返回 true，否则返回 false发放 5 元余额的结果节点 AmountResult，结果也可以有返回，比如正常发放了返回 true，库存不足了等原因导致的没有发放(不是
error)，可以返回 false发放 10 元积分的结果节点 PointResult 那么，为什么要编排，如何编排才是最优的？
为什么要编排？ **屏蔽代码影响：**比如编排者只需要知道 AmountResult 是发放余额的节点，然后在适当的位置运行这个节点即可，不需要关心真实的代码逻辑
**提升效率：**结合可视化给非研发人员编排实现业务逻辑，支持动态修改与生效配置，比如充值条件 100 元改成 200，结合可视化工具直接修改，解放研发，提升生产效率
如何编排？ 流程图式编排 脑海里最先出现的编排方式，也是最常见的编排方式
执行树式编排 When X Then Y
以上两种基本代表了传统的编排思想，在简单的例子下，看起来也是非常直观，但，当变动发生时，尤其是需要灵活调整的场景，他们的表现又如何呢？
变动 ①简单配置修改 充值 100 元改成 80 吧，10 积分变 20 积分吧，时间改成 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11aa79870df3809f9c2888560a215e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b5f334de0bec3efa25c0f839f3be45/" rel="bookmark">
			二重积分的复化Simpson方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般数值计算教材都只讲一重积分，很少讲二重积分和三重积分，这里我写了一个用Simpson方法求解二重积分的程序，供大家参考。程序的要点在于构建一个系数矩阵，具体教程可以参考
https://max.book118.com/html/2018/0419/162077258.shtm（张正印，二重积分的Simpson公式及其误差估计）
import math import numpy as np import matplotlib.pyplot as plt import sys # this code calculate the 2d intergration with simpson method, the coffecient matrix is fixed and being created first, then the results can easily be calculated. . def grid_line1(n):# n is the size of x, should be odd grid=np.zeros(n,dtype=float) for i in range (0,n): if i%2==0: grid[i]=2 else: grid[i]=4 grid[0]=grid[-1]=1 return grid def grid_line2(n):# n is the size of x, should be odd grid=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b5f334de0bec3efa25c0f839f3be45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6bb30163021edec298b00a69ec3ba7/" rel="bookmark">
			Vue特点&#43;Vue简单实例&#43;Vue模板语法&#43;Vue数据绑定&#43;data和el的2种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Vue特点
2.Vue安装
3.Vue第一个实例
4.Vue模板语法
1.{{xxx }} 插值语法
2.v-xxx 指令语法 5.Vue数据绑定
1.数据单向绑定 v-bind 就是一个单向绑定指令
2.数据双向绑定 v-model 就可以实现数据双向绑定
6.data 和 el 的2种写法
1.el 的两种写法 2.data 的2种写法
1.Vue特点 1.采用组件化模式，提高代码复用率，且让代码更好维护
分析：一个.vue文件就是一个组件，各个组件之间不影响，其它项目需要某个组件时，直接把组件移过去就可直接用。
2.编写人员不用直接操作DOM，提高开发效率。 3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点。
2.Vue安装 3.Vue第一个实例 &lt;!-- 引入开发版本的Vue 全局就多了一个 Vue的构造函数 --&gt; &lt;script src="../js/vue.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;!-- 1.准备一个容器 --&gt; &lt;div id="app"&gt; &lt;h1&gt;hello,{{name}}&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; //创建vue实例 配置项里面的key值不能乱改 new Vue({ el:'#app', //el用于指定当前Vue实例为哪个容器服务，通常为CSS选择器字符串 data:{ name:'Vue第一天' //data中用于存储数据，数据供 el所指定的容器 去使用(容器之外就不能使用),指暂时先写为一个对象 } }); &lt;/script&gt; &lt;/body&gt; 分析总结1:
1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象
2.app容器里面的代码依然服务html规范，只不过混入了一些特殊的Vue语法 {{}}
3.app容器中的代码被称为 Vue模板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6bb30163021edec298b00a69ec3ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca65fef300c6029b67f45647762beb6e/" rel="bookmark">
			Linux——把用户加入和移除用户组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.linux是一个多用户/多任务的的操作系统
root用户：系统唯一，是真实的，可以登录系统，可以操作系统中任何文件和命令，拥有最高权限。
虚拟用户：假用户，无登录系统能力，但是系统运行不可缺少的用户。
普通真实用户：这类用户能登录系统，但只能操作自己家目录的内容；权限有限，系统管理员自行添加的
2.什么是用户(User) :
linux是多用户操作系统，所以可以在linux系统中建若干用户。专业事情，专属用户
3.什么是用户组(group)
具有相同特征的用户的集合体。
4.用户和用户组的对应关系
1对一：某个用户可以是某个组的成员
多对一：多个用户可以在同一个组
一对多：一个组内可以有多个成员
多对多：多个用户对应多个组。
5.实际用户和有效用户的区别：
Unix系统通过进程的有效用户ID和有效用户组ID来决定进程对资源的访问权限。
实际用户ID：标识当前用户是谁，当用户登录时取自口令文件。即标识我是谁，也就是登录用户的UID和GID。
6.sudo命令的日志：cat /var/log/auth.log
7.sudo -l 列出用户的权限 8.管理用户的命令：
adduser：添加用户。会自动为创建的用户指定主目录，系统shell版本会在创建时输入密码（推荐）
useradd：添加用户。需要使用参数指定一些基本设置，如果不使用任何参数，则创建的用户无密码/无主目录/没有指定shell版本。需要单独设置用户密码/指定家目录/指定shell等。
usermod:修改已经存在用户的信息
userdel username:删除用户
passwd username:为用户设置密码
chage -l username:更改用户密码过期信息
chfn:改变用户备注信息
chsh:更改登录shell
finger:查看用户信息工具
id:查看用户的UID/GID及所归属的用户组
chfn:更改用户信息工具
更改用户账户名：usermod -l newname oldname
锁定用户： usermod -L 要锁定的用户
解锁用户：usremod -G 要解锁的用户
9.修改用户 加入单个组和多个组
usermod 参数 -G和-g的区别：
将test用户的登录目录改成/home/test,并加入test2组，这里是大G
命令：usermod -d /home/test -G test2 test
使用usermod -G 添加多个组要用“，”隔开
命令:usermod -G groupA,groupB,groupC user
把用户加入某个组织，但不退出当前组，同时属于多个组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca65fef300c6029b67f45647762beb6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58eb7a52b940359a191f97578179026e/" rel="bookmark">
			Docker学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构 镜像:docker镜像,就相当于是一个root文件系统,比如官方镜像像ubuntu就包含了一套完整的ubuntu最小系统的root文件系统容器:镜像和容器的关系,就像是面向对象程序设计中的类和实例一样,镜像是静态的定义,容器是镜像运行时的实体.容器可以被创建 启动 停止 删除和暂停等仓库:仓库可以被看一个代码控制中心,用来保存镜像 docker使用客户端 服务器架构模式,使用远程api来管理和创建docker容器.docker容器通过docker镜像来创建
概念说明docker镜像(images)docker镜像是用于创建docker容器的模板,比如ubuntu系统docker容器(container)容器是独立运行的一个或一组应用,是镜像运行的实体docker客户端(client)docker客户端通过命令行或者其他工具使用docker sdk与docker的守护进行通信docker主机(host)一个物理或者虚拟的机器用于执行docker守护进程和容器docker registrydocker仓库用来保存镜像,可以理解为代码控制中的代码仓库,docker hub提供了庞大的镜像集合供使用.一个docekr registry中可以包含多个仓库,每个仓库可以包含多个标签,每个标签对应一个镜像,通常,一个仓库会包含同一个软件不同版本的进行,而标签就常用于对应该软件的各个版本.我们可以通过[仓库名]:[标签]的格式来指定具体是这个软件那个版本的镜像.如果不给出标签,将以latest作为默认标签docker machinedocker machine是一个简化docekr安装的命令行工具,通过一个简单的命令行即可在对应的平台上安装docker比如virtualbox digital ocean microsoft azure docker使用 docker helloworld docker允许你在容器内运行应用程序.在容器内运行一个应用程序并输出helloworld
docker run ubuntu:15.10 /bin/echo "Hello world" docker:docker的二进制执行文件run:与前面的docker组合来运行一个容器ubuntu15.10:指定要运行的镜像,docker首先从本地主机上查找镜像是否存在,如果不存在,docker就会从镜像仓库docker hub下载公共镜像/bin/echo “hello world”:在启动的容器里面执行的命令 以上命令的含义:docker以一个ubuntu15.10镜像创建一个新容器,然后再容器里面执行 /bin/echo “helloworld”,然后输出结果
交互式容器 通过docker的两个参数-i -t ,让docker运行的容器实现对话能力
docker run -i -t ubuntu:15.10 /bin/bash -t :在新容器内指定一个伪终端,或者终端
-i :允许你对容器内的标准输入(STDIN)进行交互
cat /proc/version 查看当前系统的版本信息
运行exit命令或者ctrl+d来退出容器
后台启动容器 创建一个以进程方式运行的容器
docker run -d ubuntu:15.10 /bin/sh -c "while true;do echo hello world;sleep 1; done" 这个长字符串叫做容器的id,对每个容器来说都是唯一的,我们可以通过容器的id来查看对应的容器发生了什么.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58eb7a52b940359a191f97578179026e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150cac2678caf68fd2e59af2e5ab9318/" rel="bookmark">
			C语言之 goto语句怎么了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自学习随笔记，属于【扩展讨论】初学者可以围观看看，看不懂也没关系。
goto语句也称为 无条件转移语句，其一般格式如：
goto 语句标号；
其中语句标号是标识符规定书写的符号， 放在某一语句行的前面，标号后半角冒泡“:”。语句标号起标识语句的作用，与 goto 语句配合使用。
GOTO语句使程序的静态结构和动态结构不一致，从而使程序难以理解，难以查错。
有人认为GOTO语句使用起来比较灵活，而且有些情形能提高程序的效率。
1974年，D·E·克努斯对于GOTO语句争论作了全面公正的评述，其基本观点是：不加限制地使用GOTO语句，特别是使用往回跳的GOTO语句，会使程序结构难于理解，在这种情形，应尽量避免使用GOTO语句。但在另外一些情况下，为了提高程序的效率，同时又不至于破坏程序的良好结构，有控制地使用一些GOTO语句也是必要的。用他的话来说就是：“在有些情形，我主张删掉GOTO语句；在另外一些情形，则主张引进GOTO语句。”
后来，G·加科皮尼和C·波姆从理论上证明了：任何程序都可以用顺序、分支和重复结构表示出来。这个结论表明，从高级程序语言中去掉GOTO语句并不影响高级程序语言的编程能力，而且编写的程序的结构更加清晰。
goto语句的结果：
在C/C++等高级编程语言中保留了goto语句，但被建议不用或少用。在一些更新的高级编程语言，如Java不提供goto语句，它虽然指定goto作为关键字，但不支持它的使 用，使程序简洁易读；尽管如此后来的c#还是支持goto语句的，goto语句一个好处就是可以保证程序存在唯一的出口，避免了过于庞大的if嵌套。
可以考虑使用goto的情形：
1.从多重循环中直接跳出 ；2. 出错时清除资源；　3.可增加程序的清晰度的情况。 不加限制地使用goto：
破坏了清晰的程序结构，使程序的可读性变差,甚至成为不可维护的"面条代码"。经常带来错误或隐患，比如它可能跳过了某些对象的构造、变量的初始化、重要的计算等语句。
goto语句问题的提出直接推动了结构化程序设计（structured programming）的思想和程序设计方法学的诞生和发展。
结构化程序设计方法引入了工程思想和结构化思想，使大型软件的开发和编程都得到了极大的改善。结构化程序设计方法的主要原则可以概括为自顶向下，逐步求精，模块化，限制使用goto语句。 下列关于使用goto语句的原则可以供读者参考。 1) 使用goto语句只能goto到同一函数内，而不能从一个函数里goto到另外一个函数里。 2) 使用goto语句在同一函数内进行goto时，goto的起点应是函数内一段小功能的结束处，goto的目的label处应是函数内另外一段小功能的开始处。 3) 不能从一段复杂的执行状态中的位置goto到另外一个位置，比如，从多重嵌套的循环判断中跳出去就是不允许的。 4）应该避免像两个方向跳转。这样最容易导致"面条代码"。 举个栗子：输入整数金额（0-10元），计算兑换为各几张1角、2角、5角。
运行结果：
源码如下：
#include &lt;stdio.h&gt; int main() { int x; int one, two, five; printf("请输入需要兑换的(0-10)金额："); scanf("%d", &amp;x); for ( one = 1; one &lt; x*10; one++ ) { for ( two = 1; two &lt; x*10/2; two++ ) { for ( five = 1; five &lt; x*10/5; five++ ) { if ( one + two*2 + five*5 == x*10 ) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/150cac2678caf68fd2e59af2e5ab9318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21148b0ad69e6c8141bca17d92754c99/" rel="bookmark">
			pytorch安装教程新手入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch环境搭建 引言
PyTorch是一个开源的Python机器学习库，其前身是2002年诞生于纽约大学的Torch。它是美国Facebook公司使用python语言开发的一个深度学习的框架，2017年1月，Facebook人工智能研究院（FAIR）在GitHub上开源了PyTorch。
第一步：安装anaconda Anaconda包括Conda、Python以及一大堆安装好的工具包。
1.下载anaconda安装包 官网链接https://www.anaconda.com，选择自己需要的版本，文档中选择的官网最新版22.9.0。
2.安装anaconda 双击下载好的anaconda.exe文件如图所示
点击Next-&gt; I agree-&gt; Just me -&gt; 选择安装路径next -&gt; 选中勾选框add和register后Install -&gt; 验证是否安装成功。
验证是否安装成功方法为Win+R键输入cmd打开命令行输入命令
conda --version 如图所示说明anaconda安装成功。
第二步：安装CUDA（非必须安装） CUDA(Compute Unified Device Architecture)，是一种新的操作GPU计算的硬件和软件架构，是建立在NVIDIA的GPUs上的一个通用并行计算平台和编程模型，它提供了GPU编程的简易接口，基于CUDA编程可以构建基于GPU计算的应用程序，利用GPUs的并行计算引擎来更加高效地解决比较复杂的计算难题。
1. 下载CUDA 根据电脑NVDIA驱动程序版本同时考虑PyTorch安装选择CUDA版本，11.3版本官网链接https://developer.nvidia.com/cuda-11.3.0-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local。
选择配置Download。
2. 安装CUDA 双击下载下来的cuda.exe如图所示
选择安装路径
同意并继续 -&gt; 自定义安装 -&gt; 选择组件下一步 -&gt; 下一步 -&gt; 安装完成 -&gt; 验证是否安装成功。
验证是否安装成功到bin目录下查看nvcc.exe是否存在如图
然后打开cmd输入命令
nvcc -V 安装成功。
第三步：用conda创建环境安装Pytorch 1.用conda创建环境来安装不同版本的PyTorch 每次都安装删除会很麻烦，可以通过使用conda指令来为不同的版本创建单独的环境。进入cmd后输入指令： conda create -n pytorch python=3.9
-n后的pytorch是指环境名称
等号后面为python的版本号
安装过程会出现y/n提示，输入y即可。安装的速度与网速有关，如若期间有未安装成功的部分再重新输入语句继续安装即可。 安装结束后，可输入以下语句查看自己新安装的环境： conda info --envs
输入语句：切换不同空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21148b0ad69e6c8141bca17d92754c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2544b79f59e196d9461b078becad0e21/" rel="bookmark">
			渗透学习之PHP--细节篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 任意代码执行 evalassertcall_user_func 1.2 执行系统命令 pcntl_execexecpassthrupopenshell_execsystemproc_open 1.3 Magic函数 __construct() 构建对象的时被调用__destruct() 销毁对象或脚本结束时被调用__call() 调用不可访问或不存在的方法时被调用__callStatic() 调用不可访问或不存在的静态方法时被调用__get() 读取不可访问或不存在属性时被调用__set() 给不可访问或不存在属性赋值时被调用__isset() 对不可访问或不存在的属性调用 isset 或 empty() 时被调用__unset() 对不可访问或不存在的属性进行 unset 时被调用__sleep() 对象序列化时被调用__wakeup() 对象反序列化时被调用，其中序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup的执行__toString() 当一个类被转换成字符串时被调用__invoke() 对象被以函数方式调用时被调用__set_state() 调用 var_export() 导出类时被调用__clone() 进行对象clone时被调用__debugInfo() 调用 var_dump() 打印对象时被调用 1.4 文件相关敏感函数 move_uploaded_filefile_put_contents / file_get_contentsunlinkfopen / fgets 1.5 低精度 php中并不是用高精度来存储浮点数，而是用使用 IEEE 754 双精度格式，造成在涉及到浮点数比较的时候可能会出现预期之外的错误。 比如 php -r "var_dump(0.2+0.7==0.9);" 这行代码的输出是 bool(false) 而不是 bool(true)。这在一些情况下可能出现问题。
1.6 弱类型 如果使用 == 来判断相等，则会因为类型推断出现一些预料之外的行为，比如magic hash，指当两个md5值都是 0e[0-9]{30} 的时候，就会认为两个hash值相等。 另外在判断字符串和数字的时候，PHP会自动做类型转换，那么 1=="1a.php" 的结果会是true
另外在判断一些hash时，如果传入的是数组，返回值会为 NULL, 因此在判断来自网络请求的数据的哈希值时需要先判断数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2544b79f59e196d9461b078becad0e21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/160764c50b872b20150ba9e4946617a3/" rel="bookmark">
			VS Code用久了后，启动速度变慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前提发现过程解决方法方法一方法二方法三 前提 不是因为电脑性能或者插件装太多导致的
是在使用一段时间后，逐渐变慢
看结论直接跳转到解决方法
发现过程 困扰了很久，这次一鼓作气找出问题，太激动了，记录一下
经过百度得知，VS Code有两个文件夹：
VS Code安装的扩展包位置：C:\Users\&lt;USERNAME&gt;\.vscode
VS Code缓存文件位置：C:\Users\&lt;USERNAME&gt;\AppData\Roaming\Code
扩展包应该是没影响的，因为我删掉了之后，启动软件的速度没变化。
然后我删掉了缓存目录里的Cache和CacheData两个文件，启动软件的速度依旧没变化。
最后我干脆把缓存目录里文件全删掉了，软件打开速度恢复了，就跟刚安装的时候一样。此时嗨皮的一比！
然而，总是要删掉整个文件夹肯定不是个解决办法，而且文件里都是我的设置项。所以就开始一个文件一个文件地删除掉再测试打开速度，最终定位到了这个文件
C:\Users\&lt;USERNAME&gt;\AppData\Roaming\Code\User\globalStorage\state.vscdb
不难看出这是个数据库文件，使用SQLLite打开后看到是一个存储键值对的数据库
接下来就是要排查出究竟是哪条数据影响的：
也是运气好，我从最大的数据开始看，几次测试之后就定位到了key为history.recentlyOpenedPathsList的数据，只要删掉这条数据，启动软件的速度就恢复了
这条数据的value是一个json字符串，包含着最近打开的文件的绝对位置
我的这个数据其实就420条，启动慢的时间肯定不是花在读取文件上，也许是vscode…不知道他加载完后干了什么，不管了，这个文件名一眼可见存储的是最近打开的目录以及文件的名称，所以只要设置一下存储的最近打开文件数量应该就可以了
当时没着急设置，闲得慌，先复制了1000个文件，然后一起用vscode打开，发现这条数据最大只存储500条记录，应该就是默认值了
在vscode设置里没找到相关的设置，逛了逛各大搜搜引擎，没找到…
解决方法 方法一 VS Code里，点击文件-最近打开的文件-清除最近打开记录，每隔一段时间，感觉启动速度慢了，就清除一下
方法二 去提issus等官方更新…
方法三 既然已经知道了数据库文件的位置，有能力可以写个脚本，配合windows的计划任务，每天或者每周第一次开机时清除history.recentlyOpenedPathsList这条数据的值。
注意：因为我只是把vscode当作一个文本编辑器来用，不用来开发，所以最近文件功能对我没用。如果最近文件功能对你有用，还请自行决定如何处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a4ed5100e003c8f064a0688dd7685e/" rel="bookmark">
			解决PCL报错: Assertion `point_representation_-＞isValid (point) &amp;&amp; “Invalid (NaN, Inf) point coordinates
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考资料:
https://github.com/PointCloudLibrary/pcl/blob/master/kdtree/include/pcl/kdtree/impl/kdtree_flann.hpphttps://blog.csdn.net/AileenNut/article/details/80170146 先说结论: 如果在使用PCL库时遇到了上述报错, 很有可能是程序中调用nearestKSearch()函数处出现了Nan点, 需要对这些点进行剔除或跳过处理.
首先, 需要定位到出错的代码, 这里调用了nearestKSearch()其次, 可以在函数nearestKSearch()之前打印出nearestKSearch()中第一个参数的内容, 以确定是否是出现了Nan点, 进而导致程序终止, 如: std::cout &lt;&lt; "point value: " &lt;&lt; point.x &lt;&lt; " " &lt;&lt; point.y &lt;&lt; " " &lt;&lt; point.z &lt;&lt; " " &lt;&lt; point.intensity &lt;&lt; std::endl; 若是出现了Nan点导致的程序挂掉, 那么需要对这些点进行剔除或跳过处理. 剔除的方式可以参考此博客, 这里提供一种跳过处理的方式:
if (!pcl_isfinite(point.x) || !pcl_isfinite(point.y) || !pcl_isfinite(point.z) || !pcl_isfinite(point.intensity)) { continue; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f53ee7ff85d462973a98cb4a299d791/" rel="bookmark">
			【Python】利用format方法保留三位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 format方法是内置的Python字符串格式化方法。
基本语法为：str.format()，它增强了字符串格式化的功能。
基本语法是通过 {} 和 : 来代替以前的 % 。
format 函数可以接收多个参数，位置可以不按顺序。
具体实例如下：
print("{:.0f}".format(3.1415926)) 3 print("{:.2f}".format(3.1415926)) 3.14 print("{:.3f}".format(3.1415926)) 3.142 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb82872be9968b562c4cb66717f281a/" rel="bookmark">
			开关电源学习(一) MP2315S简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、电容的作用二、电感的作用三、二极管的作用四、电路的拓扑结构五、同步和异步的区别总结 前言 MP2315S 是一款内置功率 MOSFET 的高效率同步整流降压开关变换器。它是 MP2315 的下一代产品。它提供了非常紧凑的解决方案，在宽输入范围内可实现 3A 连续输出电流，具有极好的负载和线性调整率。MP2315S 在输出负载范围内采用同步整流模式工作以达到高效率。电流控制模式提供快速瞬态响应，并使环路更易稳定。全方位保护功能包括过流保护（OCP）、过压保护（OVP）和过温关断保护。MP2315S 最大限度地减少了现有标准外部元器件的使用，采用 TSOT23-8 封装。
产品特性和优势
宽工作输入电压范围：4.5V 至 24V
3A 负载电流
110mΩ/55mΩ 低导通阻抗内部功率 MOSFET
低静态电流
高效同步工作模式
500kHz 固定开关频率
AAM 节电模式
内部软启动
输出过压保护（OVP）
过流保护（OCP）自动恢复功能
过温关断保护
输出电压可调节低至 0.8V
采用 TSOT23-8 封装
一、电容的作用 我们经常看到开关电源芯片或多或少都如上图所示，但可以确定的是，一定会有输入电容，输出电容，电感的身影，我们学习这个电路，首先要搞明白电路中的元器件作用是什么，这样我们才能更好地掌握这个电路，那么我们今天就来学习一下开关电源的原理，搞明白开关电源的原理，电路才算入门。
首先，比如我们12V转5V，我们理想的波形是一条平直的直线，但是我们实际的波形，通过开关管的开通与关断，肯定是一上一下的，但是他们是等效的，因为他们的面积是相等的，等效的意思是我实际的波形可以不断逼近或者想办法变成我的理想的电压波形。
我们很容易想到电容的滤波作用，但是波形并不理想，并且电路中的电流还会有一个明显的尖峰，原因是电容两端的电压不能突变，根据电容两端的电流公式I=C*du/dt，电容两端的电压发生突变，dt就相当于无穷小，那么电路就会变得无穷大。所以我们很自然得想到了要限制电流的大小。
二、电感的作用 那么如果我们在这里串入一个电阻来限制电流，确实是达到了相应效果
但是电阻消耗的能量很大，所以不现实
什么元件可以限制电流的大小又不消耗能量？电感
加入电感后，由于电感上面的电流不能突变，所以电感要有放电的回路
三、二极管的作用 这样当mos管导通时，就直接到地了，所以我们要加入具有单向导电性的二极管
四、电路的拓扑结构 那么我们最后就得到了我们电路的拓扑结构
Ua是一个周期性的方波，Ub经过电感和电容的滤波，变成一个5V的直流输出，当然现实中这个直流电压是有一定的波动的，也就是所谓的纹波
我们再来看一下电感的波形，流过电感的电流是一个三角波，把这个三角波一分为二，一个直流分量，一个交流分量，这个直流分量就是流过负载的电流，这个交流分量就是流过电容的电流，电容上的电流为什么有正有负，原因就是，电容充电时，电流为正，电容放电时，电流为负。
五、同步和异步的区别 同步和异步的区别是把二极管变成了开关管，使得效率更高了，原因是，电流较大时，二极管消耗的能量也是比较大的。因为就算你二极管导通电压为0.4V，当电流1A时，功率还是达到了0.4W，还是很大的、
总结 主要介绍了同步和异步的电路的拓扑结构，以及电容电感。二极管等元件在其中的作用，至于说这些 元器件的参数怎么选，如何计算，电容容值对输出电压的影响，电感是越大越好还是越小越好，电源的芯片如何选择，这些在下期我们继续讲解。
参考视频：开关电源原理
参考博文：MP2315高频同步整流降压x芯片电路原理图
常用芯片数据手册——MP2315S/3A、24V、500kHz、高效率同步降压变换器（MPS）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad98decea16646a882fe28ce345edf5/" rel="bookmark">
			深入理解Python深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝----看了还不懂找我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程中难免会遇到copy（浅拷贝）与deepcopy（深拷贝）问题，一不小心就会掉进坑中了，或许很多人只知道有深浅拷贝，但是你又知道copy和"="拷贝有什么区别么？也许很少有人对二者的区别能讲出一二三吧！下面这篇文章就对深拷贝(deepcopy)、浅拷贝（copy）、等号拷贝进行深入的讲解。
本文不是在网上抄袭别人的，而是本人通过研究学习后的自我总结，我想当你看完这篇文章后，1. 你会知道python的变量存储机制；2. 你会深浅拷贝以及等号拷贝的差异所在了；3. 你会理解为什么有的值改变，有的拷贝跟着变化，有的不会变化的根本原因所在了。当然如果本文有不正确的地方，欢迎大家批判指正。
首先在python中，什么是浅拷贝，什么是深拷贝呢？什么是等号拷贝（形如：bb = aa）呢？有谁能一句话解释清楚，他们的区别又在哪里？-----一定记住针只有对复杂对象才有区别意义！！！因为对于简单对象，他们是没有区别的！
主要是针对复杂结构对象，复杂结构对象就是嵌套两层及以上的子对象，比如：即列表中嵌套子列表,像[1, [2, 3]]这种结构
复杂对象中的深浅拷贝：
一句话解释(=)等号拷贝：当于对于电脑中某个文件夹新建了一个快捷图标，快捷图标永远和原文件是一致的。
一句话解释（copy）浅拷贝：相当于对于电脑中某个文件夹内部的所有子文件夹新建了快捷图标，放到新的文件夹中，所以内部子文件夹内数据会跟着原来文件的改变而改变。
一句话解释（deepcopy）深拷贝：相当于对于电脑中某个文件夹用u盘拷贝了一个备份。所以原来电脑中文件夹内文件改变时，u盘的文件是不会变化的。
官方解释：
浅层拷贝 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 引用 插入其中。
深层拷贝构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 副本 插入其中
要弄清楚拷贝原理，首先应该弄清楚Python变量存储机制
Python中变量的存储机制 1. aa = 1的存储机制 当aa = 1 时，首先Python会在内存中新开辟一个空间存储数字“1”，然后将该内容的地址赋值给变量‘aa’。有点像如下图所示
2. bb = aa的复制机制 对于正常的“=” 赋值， 比如 bb = aa，则有
3. 形如or_list = [1, [2, 3]]的复制对象，他们的存储机制是如何的呢？ 读者可以先自我思考一下，在本文的后面讲解中，会给出解释。
Python中复杂对象，等号拷贝，copy浅拷贝，deepcopy深拷贝机制 1. 三者拷贝后的ID差异 看以下代码初始列表为 or_list = [1, [2, 3]]，分别进行"="拷贝，copy浅拷贝，deepcopy深拷贝
操作如下 eq_list = or_list sh_list = copy(or_list) de_list = deepcopy(or_list)， 通过id可以看出三者和原来list的内存地址信息，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad98decea16646a882fe28ce345edf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01290f6acf006e68de1fc028dc62a2ad/" rel="bookmark">
			vue中使用animate.css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先要安装animate.css npm install animate.css --save 2.引入animate.css import 'animate.css' 3.使用animate.css vue组件中
&lt;transition name="animate__animated animate__bounce" enter-active-class="animate__XXX" leave-active-class="animate__XXX"&gt; &lt;h2&gt;内容文字&lt;/h2&gt; &lt;/transition&gt; 其中XXX表示动画名，如swing，bounce等等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4da013cc3dbf84b552f25e9d635873/" rel="bookmark">
			《算法导论》学习（十八）----动态规划之矩阵链乘（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、矩阵链乘1.问题描述 二、问题解决1.最优化的子问题结构2.动态规划3.最优解构造 三、C代码1.代码2.结果 总结 前言 本文主要讲解了动态规划中的矩阵链乘问题：给定一个矩阵链，得到它的最小代价计算次序。给出了动态规划方案的分析，并且给出了C语言实现。
一、矩阵链乘 1.问题描述 给定一个n个矩阵的序列（矩阵链） &lt; A 1 , A 2 , A 3 , A 4 , . . . , A n &gt; &lt;A_1,A_2,A_3,A_4,...,A_n&gt; &lt;A1​,A2​,A3​,A4​,...,An​&gt;，现在我们希望计算它的乘积
A 1 A 2 A 3 A 4 . . . A n A_1 A_2A_3A_4...A_n A1​A2​A3​A4​...An​
对于矩阵链乘来说，我们可以通过加括号的手段来确定先让哪两个矩阵进行相乘。无论乘的次序如何，最终都不影响结果。
但是不同次序之间的矩阵相乘，计算机所要付出的代价完全不一样。
比如所 &lt; A 1 , A 2 , A 3 &gt; , 其中 A 1 为 2 ∗ 3 ； A 2 为 3 ∗ 4 ； A 3 为 4 ∗ 1 &lt;A_1,A_2,A_3&gt;,其中A_1为2*3；A_2为3*4；A_3为4*1 &lt;A1​,A2​,A3​&gt;,其中A1​为2∗3；A2​为3∗4；A3​为4∗1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4da013cc3dbf84b552f25e9d635873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de06b275995f1a05f3a0a255649b590/" rel="bookmark">
			抓包微信小程序openid的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.所需设备 windows 电脑
二、步骤 1、下载安装Charles，官网版有30天试用。地址：https://www.charlesproxy.com/download/
或者自行找方法安装该软件即可。
2、打开Charles软件，同时打开微信电脑版并登录。
3、设置 Charles 开启https抓包。点击Proxy - SSL Proxying Settings
在弹出的窗口中，在左侧的 include 中添加 * : *，如下图所示
添加完成后的界面如下图：
4、进行抓包，过程中保持charles打开。以青春浙江为例，在微信电脑端打开 青春浙江公众号 并点击 大学习
进入到内容界面后停留几秒钟，此时查看charles，左侧会多出很多条记录：
openid就隐藏在其中，按下ctrl+f 直接查找 openid，红色箭头所指都是，建议打开我选中的那条，比较清晰一些。
双击可以打开，数据显示在右侧，openid类似于 oO-3fg4g5w5ghhfdwefqsk。注意，openid不要给其他人，它表示的是你在该微信公众号下的识别码。
获取到openid后，如要进行其他操作，不能取关该公众号，否则openid会失效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2bc584b9a588e2da6e333a90e540624/" rel="bookmark">
			【数据安全】2. Android 全盘加密（Full Disk Encryption）技术介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FDE (Full disk encryption) 的发展经历了几个阶段：
基于软件/硬件实现的 dm-crypt基于硬件 GPCE 实现的 request-dm-crypt基于硬件 ICE 实现的 dm-req-crypt 1. 术语解释 dm-crypt / request-dm-crypt / dm-req-crypt
它们都是位于 linux kernel block 层， 用于加解密数据的 Device Mapper 驱动模块，下文统称 dm crypt 驱动。Device Mapper 可以将整个 block 设备或 block 设备的部分映射到单个设备。
这些 dm crypt 驱动模块使用这个特性将整个用户数据分区，即用户数据分区中的所有扇区映射到另一个设备，例如/dev/dm-N。此时用户数据分区上的任何操作都由设备映射层处理，dm crypt 驱动模块加密所有写操作，并解密所有的读操作。最终整个加密和解密数据的过程对于用户来说是透明的。
至于这些 dm crypt 驱动模块的区别则是拥有更好的 I/O 性能，主要表现在 I/O 吞吐量和 I/O 延时，下文详细介绍。
GPCE
general-purpose crypto engine，ARM 体系结构提供的通用加密引擎。
ICE
inline crypto engine，一般由 SOC 厂商实现，内嵌到存储器控制器的加密引擎。
2. 基于软件/硬件实现的 dm-crypt 该方案已经被废弃，这里只做简单介绍，架构如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2bc584b9a588e2da6e333a90e540624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143e32fe74fa112c0839176bac93e7fc/" rel="bookmark">
			matlab绘制图像的直方图、杆状图和折线图等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.imhist函数： h=imhist(f,b) 其中，f为输入图像，h是该图像的直方图数据，b是用来形成直方图的“容器”数目，即把所有灰度级分成几份的数量（b默认为256)。若按上面一行代码中使用imhist函数，则并不会画出图像对应的直方细杆图，而是得到直方图数据的一个向量（h)。若要画出直方细杆图，则要写成这种形式：
imhist(f,b) 就会直接画图了。
2.bar函数： bar(horz,z,width) 上述形式就可直接绘制直方条形图，其中参数z是一个包含将被绘制的点的行向量，即对应上面imhist函数得到的h；horz是一个与z同维数的向量，对应水平刻度,若horz省掉，水平轴会从0-length(z)等分为若干个单位；witdth是一个介于0和1之间的数，默认为0.8，对应条形的宽度。
3.stem函数： stem(horz,z,'LineSpec') 上述形式就可直接绘制直方细杆图，其中参数horz、z和bar函数中的一样；LineSpec是对应下表的一个三元组：
LineSpec对应的三元组表 颜色说明符线型说明符标记点说明符 符号颜色符号线型符号标记m深红-.虚点线h六角星y黄:点线p五角星c青--虚线&lt;左指三角形b蓝-实线&gt;右指三角形g绿v下指三角形r红^上指三角形w白d菱形k黑s方形叉.点*星号o圆+加号 例如，当LineSpec=’y-o‘，生成的杆状图其线条和标记点都是黄色，线条为实线，标记点为圆。若LineSpec='fill'，则默认颜色为蓝色，线条为实线，标记点为圆。
4.plot函数： plot(horz,z,'LineSpec') 上述形式就可直接绘制直方折线图，其参数与上述几个函数对应的相同参数意义一致。
四种函数画直方图的演示代码如下： img=imread('e.jpg'); figure1=figure; imshow(img)%展示原始图像 %绘制细杆状图 figure2=figure; subplot(121) imhist(img)%得到每一个灰度级对应的像素点个数组成的向量，并画出来对应的细杆状图 subplot(122) imhist(img,50) %绘制直方图 h=imhist(img,20); %将0-255的灰度值分成20分 horz=linspace(0,255,20); figure3=figure; bar(horz,h) %绘制杆状图 figure4=figure; stem(horz,h,'fill') %绘制折线图 figure5=figure; plot(horz,h,'b-o') 结果如下： 感谢阅读！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a1dbc6c80a8ed4d1a0f51766de6135/" rel="bookmark">
			渗透学习之PHP--序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1什么是序列化 序列化. 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程
1.2PHP如何序列化数据？ 大多数情况下，我们需要将复杂的数组存储在数据库中或PHP中的文件中。有些人可能会使用PHP内置函数来完成这项任务。所谓复杂数组是具有多个数据类型或数组的元素的数组。
1.3序列化实现 PHP序列化处理共有几种，分别为php、php_serialize、php_binary和WDDX(需要编译时开启支持)，默认为php，可通过配置中的 session.serialize_handler 修改。
如果 PHP 编译时加入了 WDDX 支持，则只能用 WDDX，WDDX从PHP 7.4版本后开始弃用。从 PHP 5.5.4 起可以使用 php_serialize。 php_serialize 在内部简单地直接使用 serialize/unserialize 函数，并且不会有 php 和 php_binary 所具有的限制。
其中PHP处理器的格式为：键名 + 竖线 + 经过serialize()函数序列化处理的值。
其中php_binary处理器的格式为：键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值。
其中php_serialize处理器的格式为：经过serialize()函数序列化处理的数组。
1.4 序列化格式 boolean b:&lt;value&gt;; b:1; // true b:0; // false integer i:&lt;value&gt;; double d:&lt;value&gt;; NULL N; string s:&lt;length&gt;:"&lt;value&gt;"; s:1:"s"; array a:&lt;length&gt;:{key, value}; a:1:{s:4:"key1";s:6:"value1";} // array("key1" =&gt; "value1"); object O:&lt;class_name_length&gt;:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a1dbc6c80a8ed4d1a0f51766de6135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519c94a05749127e10384901cc1615d5/" rel="bookmark">
			[技能]-git克隆连接超时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当在github上克隆项目到本地仓库时，一直出现连接超时问题，后面试了两种方法，但对于我这种情况均没用，我把这两种方式放在这，大家遇到了可以先试试这两种方法：
①将gihub.com改成github.com.cnpmjs.org（镜像网站）；
②将https改成git。
下面开始讲解第三种方法：
打开cmd，ping github.com，ping不同，证明超时原因是本地DNS无法解析导致。
打开C:\Windows\System32\drivers\etc下的hosts文件，然后在文件最下方添加两行内容：192.30.255.112 github.com git
185.31.16.184 github.global.ssl.fastly.net（也就是红色框中的内容）
然后再ping github.com就可以ping通了，此时git克隆也能使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b81bc7f169bcad64a9c933236a94999/" rel="bookmark">
			[技能]-修改hosts文件后，不能直接保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先，找到hosts文件，一般在C:\Windows\System32\drivers\etc目录下。
2.右击hosts文件，打开属性，进行以下步骤：
点击安全
点击你的用户
点击编辑
和前两步一样，点击你的用户
勾上修改，读取与执行，读取，写入权限
点击应用，再点击确定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c3268a1e7020c1ea4cc846418724253/" rel="bookmark">
			n个互异字符串的全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节讨论通过递归调用实现互异字符串的全排列。
考虑两个字符的全排列为两者交换顺序；三个字符的全排列则可以用抽取一个交换到第一个位置，剩下的两个字符仿照两个字符的情况实现全排列；以此类推，当n个字符全排列，先抽取一个 交换到第一个位置，剩下的n-1个字符实现全排列，此时则是递归调用的形式。
下面为p位置到q位置的全排列示意图：
先编写交换函数swap()
// 交换位置 void swap(char a[], int p, int q) { char temp = a[p]; a[p] = a[q]; a[q] = temp; } 由于过程中需要打印出字符数组的元素，故需要编写打印函数printArray()
// 打印数组 void printArray(char a[],int n){ for(int i=0; i&lt;n; i++) cout&lt;&lt;a[i]; } 整合以上可编写全排列函数perm()
// 全排列 void perm(char a[],int p,int q) { if (p == q) { printArray(a,q+1); cout&lt;&lt;endl; }else { int i; for(i=p; i&lt;=q; i++) { swap(a,p,i); perm(a,p+1,q); swap(a,p,i); } } } 注意到要求字符串互异，为增强程序的鲁棒性，可编写判定互异的函数difference()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c3268a1e7020c1ea4cc846418724253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e5e54422a237cf9f7fe31c335c59f2/" rel="bookmark">
			Unity的UI框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI框架 UI框架的含义 含义：UI框架用于管理场景中所有的面板，负责控制面板之间的跳转
UI框架的意义 1、随着游戏系统的复杂化，UI控件越来越多，各个UI之间的直接通讯，已经UI与GameObject之间的关系会越来越复杂
2、代码耦合性会很强
UI框架的实例 1、框架面板的设计 MainMenuPanel：主菜单面板
BagPanel：背包面板
ItemMessagePanel：物品信息面板
ShopPanel：商城面板
SkillPanel：技能面板
SystemPanel：系统面板
TaskPanel：技能面板
我们将设计好的面板做成预制体，放在Resources的目录下。
2、Json数据的读取 UIPanelInfo.json
{ "infoList": [ { "panelTypeString": "ItemMessage", "path": "UIPanel/ItemMessagePanel" }, { "panelTypeString": "BagPanel", "path": "UIPanel/BagPanel" }, { "panelTypeString": "MainMenu", "path": "UIPanel/MainMenuPanel" }, { "panelTypeString": "Shop", "path": "UIPanel/ShopPanel" }, { "panelTypeString": "Skill", "path": "UIPanel/SkillPanel" }, { "panelTypeString": "System", "path": "UIPanel/SystemPanel" }, { "panelTypeString": "Task", "path": "UIPanel/TaskPanel" } ] } 将所有信息作为一个infolist类的对象 UIPanelType
public enum UIPanelType { BagPanel, ItemMessage, MainMenu, Shop, Skill, System, Task, } UIManager
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e5e54422a237cf9f7fe31c335c59f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1c1d0801505a58ff6be6ae75a5e7d2/" rel="bookmark">
			串的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		掌握串的基本操作、初始化字符串 生成一个值为chars常量串的字符串S、返回字符串的长度、复制字符串、比较两个字符串、将字符串清为空串，并释放该字符串所占空间、在串S1的第pos个字符之前插入串S2、删除主串中指定位置之后一定长度的子串、用T返回由S1和S2联接而成的新串、用T返回串S的第pos个字符起长度为len的子串、返回子串T在主串S中第pos个字符之后的位置、用KMP算法实现返回子串T在主串S中第pos个字符之后的位置、遍历串S；
#include &lt;iostream&gt; #include &lt;vector&gt; #define MAXSIZE 50 using namespace std; typedef struct { char ch[MAXSIZE+1]; int length; }TString,*HString; HString InitString();//初始化字符串 bool StrAssign (HString S,char chs[]);//生成一个值为chars常量串的字符串S int StrLength(HString S);//返回字符串的长度 bool StringCopy(HString S1,HString S2);//将串S2复制到S1 int StrCompare(HString S,HString T);//比较两个字符串，若S&gt;T,则返回值&gt;0; 若S&lt;T,则返回值&lt;0 ;若S=T，则返回值=0 bool ClearString(HString S);//将S清为空串，并释放S所占空间 bool StrInsert(HString S1,HString S2,int pos);//在串S1的第pos个字符之前插入串S2 bool DeleteString(HString S,int pos,int len);//删除主串中指定位置之后一定长度的子串 bool Concat(HString T,HString S1,HString S2);//用T返回由S1和S2联接而成的新串 bool SubString(HString T,HString S,int pos,int len);//用T返回串S的第pos个字符起长度为len的子串 int Index(HString S,HString T,int pos);//返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0 vector&lt;int&gt; getNext(HString T); //next数组的实现 int Index1(HString S,HString T,int pos);//用KMP算法实现返回子串T在主串S中第pos个字符之后的位置，若不存在，则函数值为0 bool traverString(HString S);//遍历串S int main(){ cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1c1d0801505a58ff6be6ae75a5e7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834ddf8ca1da41ed3c7ed3462eeb7309/" rel="bookmark">
			稀疏矩阵的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）掌握稀疏矩阵基础知识，实现初始化稀疏矩阵、销毁稀疏矩阵、输出稀疏矩阵、复制稀疏矩阵、稀疏矩阵的相加、相减与相乘、将指定值插入到稀疏矩阵的指定位置、返回指定稀疏矩阵的指定行列的值等操作；
2）掌握稀疏矩阵简单转置方法和快速转置方法的实现。
#include &lt;iostream&gt; #define MAXSIZE 12500//假设非零元素的最大值为12500 typedef int ElemType; using namespace std; typedef struct { int i,j;//该元素的行下标和列下标 ElemType e; }Triple,*pTriple; typedef struct{ Triple data[MAXSIZE+1];//非零元三元组表，data[0]未用 int mu,nu,tu;//矩阵的行数 列数 和 非零元素个数 }TSMatrix; bool initMatrix(TSMatrix &amp;M);//初始化稀疏矩阵 bool DestroySMatrix(TSMatrix &amp;M);//销毁稀疏矩阵 bool PrintSMatrix(TSMatrix &amp;M);//输出稀疏矩阵 bool CopySMatrix(TSMatrix &amp;M,TSMatrix &amp;T);//由稀疏矩阵M复制得到T bool AddSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的和Q=M+N bool SubMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的差Q=M-N bool MultSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M的列数与N的行数对应相等时，求稀疏矩阵乘积Q=M X N; bool TransposeSMatrix1(TSMatrix &amp;M,TSMatrix &amp;T);//求稀疏矩阵M的转置矩阵T bool TransposeSMatrix2(TSMatrix &amp;M,TSMatrix &amp;T); //求稀疏矩阵M的快速转置矩阵T bool setItem(TSMatrix &amp;M,int i,int j,ElemType e);//将指定值插入到稀疏矩阵的指定位置 void getItem(TSMatrix &amp;M,int i,int j,int &amp;x);//返回指定稀疏矩阵的指定行列的值 int main(){ TSMatrix A; if (initMatrix(A)){ cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834ddf8ca1da41ed3c7ed3462eeb7309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1c0dd54166f838f39de64faf4dffaf/" rel="bookmark">
			基于优化ＬＳＴＭ 模型的股票预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LSTM自诞生以来，便以其在处理时间序列方面的优越性能在预测回归，语音翻译等领域广受青睐。今天，主要研究的是通过对LSTM模型的优化来实现股票预测。其实，关于股票预测，LSTM模型已经表现的相当成熟，然而，其以及具有很大的提升空间，比如，股市的影响因素多种多样，这篇论文的重点，便是从若干个影响因素中，挑选出占比最大的几个特征，从而能够达到减少模型运算消耗的目的，下面，便是论文的相关介绍。
理论基础 由于神经网络预测模型具有显著的非线性，我们把神经网络模型归为非线性预测模型。神经网络分为两大类。第一类 人 工 神 经 网 络 （ＡＮＮ），如 ＭＰ 神 经 网 络 和ＢＰ神经网络。ＡＮＮ 作为早期的神经网络模型，在 股 票 预 测方面亦做出了杰出贡献：Ｄｅｎｇ提出 ＤＡＥ－ＢＰ模 型 对 股 票 先进行 ＤＡＥ降维，再 使 用 ＢＰ神 经 网 络 进 行 股 价 预 测，取 得 了不错的预测结果。可 惜 的 是，ＡＮＮ 模 型 结 构 过 于 单 一，存 在以下问题：
１）过拟合，导致模型的泛化能力大大减弱；
２）存在局部极值问题，即梯度下降过程中达到局部极小值点就停止工作，不能精准下降至全局极小值点，导致模型预测能力大大减弱；
３）优化过程中容易因为神经元权重过多、过 繁，导 致 梯度消失或者梯 度 爆 炸 问 题，最终使神经网络模型预测失效。
第二类神经网络则是相对于 ＡＮＮ 来说，更深层次、更 高 效 的深度神经网络模型（ＤＮＮ），如卷积神经网络（ＣＮＮ）、循 环 神经网络（ＲＮＮ）和长短期记忆神经网络（ＬＳＴＭ）。这一类神经网络模型是当前研究金融预测领域最高效、前沿的预测模型，其具有多方面优势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1c0dd54166f838f39de64faf4dffaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144c97ccbf46c83fe525ad3060c771a1/" rel="bookmark">
			node-crypto-js可逆数据加密与解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载 npm install crypto-js 作用 对数据进行加密与解密
实例 const CryptoJS = require("crypto-js"); // 加密 // key：密钥，text：明文 function encrypt(key, text) { return CryptoJS.AES.encrypt(text, key).toString(); } // 解密 // key：密钥，cipherText密文 function decrypt(key, cipherText) { let bytes = CryptoJS.AES.decrypt(cipherText, key); return bytes.toString(CryptoJS.enc.Utf8) } let key = "abc" let text = "猪二哥" let ciphertext = encrypt(key, text) console.log("密文：" + ciphertext) let originalText = decrypt(key, ciphertext) console.log("明文：" + originalText) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349aecbc0b505e6b5047a41bec800add/" rel="bookmark">
			数据结构——非线性结构（图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 非线性结构的概述二. 图的基本概念1. 定义2. 无向图、有向图2.1 无向图2.2 有向图2.3 简单图2.4 多重图 3. 顶点的度、出度、入度3.1 对于无向图3.2 对于有向图 4. 边的权、带权图 (网）5. 点到点的关系5.1 顶点与顶点之间的关系描述5.2 连通的、强连通的、连通图、强连通图 6. 图的局部6.1 无向图子图、生成子图6.2 有向图子图、生成子图6.3 连通分量6.4 强连通分量 7. 几种特殊形态的图7.1 生成树7.2 生成森林7.3 无向完全图和有向完全图7.4 稀疏图和稠密图7.5 生成树和有向树 三. 图的存储1. 邻接矩阵法1.1 定义1.2 邻接矩阵存储有向图和无向图1.3 邻接矩阵存储带权图（网）1.4 邻接矩阵法的性能分析1.5 邻接矩阵法的性质 2. 邻接表法2.1 来源2.2 定义（采用顺序存储和链式存储结合）2.3 邻接表法的性质2.4 邻接表和邻接矩阵的比较 3. 十字链表（只能存储有向图）3.1 来源3.2 定义3.3 十字链表法性能分析 4. 邻接多重表（只能存储无向图）4.1 来源4.2 定义4.3 邻接多重表性能分析 5. 四种存储结构的比较 四. 图的基本操作五. 图的遍历1. 广度优先搜索（BFS遍历）1.1 概述1.2 复杂度分析1.3 广度优先生成树 2. 深度优先搜索（DFS遍历）2.1 概述2.2 复杂度分析2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349aecbc0b505e6b5047a41bec800add/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65af79f1da1b48c773532f02971f5319/" rel="bookmark">
			将csv数据转换成张量格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：将csv数据转换成张量格式 1.1 读取数据集 先创建一个数据集，然后读出。
os.makedirs(os.path.join("..", "data"), exist_ok=True) data_file = os.path.join("..", "data", "house_test.csv") with open(data_file, 'w') as f: f.write('NumRooms,Room_age,Price\n') f.write('NA, 10, 188888\n') # 每⾏表⽰⼀个数据样本 f.write('3, 15, 166666\n') f.write('4, 20, 178100\n') f.write('NA, NA, 140000\n') data = pd.read_csv(data_file) data 注：Python os.makedirs函数介绍
os.makedirs(name, mode=0o777, exist_ok=False)
作用: 用来创建多层目录，单层使用os.mkdir参数说明： name：创建的目录名mode：要为目录设置的权限数字模式，默认的模式为 o777 (八进制)，为所有用户开通读、写、执行权限exist_ok：是否在目录存在时触发异常。 exist_ok=False（默认值），在目标目录已存在的情况下触发FileExistsError异常exist_ok=True，在目标目录已存在的情况下不会触发FileExistsError异常。 1.2 处理缺失值 连续型数据用均值填充 inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2] inputs = inputs.fillna(inputs.mean()) inputs 离散型数据编码成one_hot inputs = pd.get_dummies(inputs, dummy_na=True) inputs 1.3 转换成张量 X, y = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65af79f1da1b48c773532f02971f5319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bcc041917539a38f2763adf14862f35/" rel="bookmark">
			SQL语言---数据更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、数据更新之插入数据1.插入单个元组（1）语句格式（2）语法说明INTO子句VALUES子句插入规则 （3）举例讲解例子1：例子2：易犯错误 2.插入子查询结果（1）语句格式（2）语法说明INTO子句(与插入单条元组类似)子查询查询规则 （3）举例讲解例子1：新建一张表存放每部门员工的平均工资。 二、数据更新之修改数据1.修改某一个元组的值（1）语法格式（2）语法说明SET子句WHERE子句语法规则 （3）举例讲解例子1：部门调整 2.修改多个元组的值（1）举例讲解例子1：为员工发放薪金 3.带子查询的修改语句（1）语法结构（2）举例讲解例子1：不知道部门编号的情况下发奖金 三、数据更新之删除数据1.删除某一元组的值（1）语法格式（2）语法说明FROM子句WHERE子句 （3）举例讲解例子1：删除离职人员信息 2.删除多个元组的值（1）举例讲解例子1：解散部门 3.带子查询的删除语句（1）语法格式（2）举例讲解例子1：不知道部门编号的情况下解散部门 4.删除的易错点（1）违反完整性约束条件（2）DELETE不支持CASCADE 总结 前言 本文主要讲解了SQL语言中的数据更新的语法，并且举例进行相关知识的说明和讲解。
一、数据更新之插入数据 1.插入单个元组 插入单个元组可以理解为给表插入一行数据
（1）语句格式 功能：将新元组插入指定表中
INSERT INTO &lt;表名&gt; [(&lt;属性1&gt;[,&lt;属性2&gt;...])] VALUES (&lt;常量1&gt;[,&lt;常量2&gt;]...); （2）语法说明 INTO子句 指定要插入数据的表名及属性列属性列的顺序可与表定义中的顺序不一致没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致指定部分属性列：插入的元组在其余属性列上取空值（ORACLE这条不适用） VALUES子句 提供的值必须与INTO子句匹配
– 值的个数
– 值的类型 插入规则 DBMS在执行插入语句时会检查所插元组是否破坏表上已定义的完整性规则
a.实体完整性
b.参照完整性
c.用户定义的完整性
对于有NOT NULL约束的属性列是否提供了非空值对于有UNIQUE约束的属性列是否提供了非重复值对于有值域约束的属性列所提供的属性值是否在值域范围内 （3）举例讲解 首先给出目前表的完整性情况：
1、DEPT表有三个字段，分别为DEPTNO、DNAME、LOC
2、其中DEPTNO是主键，不能为空值
3、DNAME和LOC 可以为空值
4、DEPTNO的字符类型是2位整数，DNAME和LOC是字符串
例子1： 插入单个元组进入表：
INSERT INTO DEPT VALUES ('50','MARKETING','BEIJING'); 结果：
例子2： 目前公司打算组建一个技术部（部门编号为60，部门名称为TECHNOLOGY，部门还没想好落户在哪个城市）。
插入方法1：
INSERT INTO DEPT VALUES ('60','TECHNOLOGY',''); 插入方法2：
INSERT INTO DEPT VALUES ('60','TECHNOLOGY',NULL); 易犯错误 NULL值多了单引号，表示插入的是NULL这个单词，而不是插入的空值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bcc041917539a38f2763adf14862f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2796681c182d449bf382549d48aae79a/" rel="bookmark">
			关于 Gojs 你可能用到的方法 / gojs自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、阻止键盘事件 myDiagram.commandHandler.doKeyDown = function （） { var e = myDiagram.lastInput; // Meta（Command）键代替Mac命令的“控制” var control = e.control || e.meta; var key = e.key; //退出任何撤销/重做组合键，具体键值根据需求而定 if（control &amp;&amp;（key === 'Z' || key === 'Y'））return ; //调用没有参数的基础方法（默认功能） go.CommandHandler.prototype.doKeyDown.call（this）; }; 2、监听连线完成事件 myDiagram.addDiagramListener("LinkDrawn",function(e){ (e.subject.data ) //这是这个线条的数据 }) ； 同时要在linkTemplate 配置上 selectable: true,这样 再监听连线成功时 的回调中调 myDiagram.commandHandler.deleteSelection() 才行 ,才能删除这个连线。 3、拖拽框选功能 myDiagram.toolManager.dragSelectingTool.box = $(go.Part, { layerName: "Tool", selectable: false }, $(go.Shape, { name: "SHAPE", fill: null, stroke: "chartreuse", strokeWidth: 3 }) ); 4、监听新拖拽到画布的节点 diagram.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2796681c182d449bf382549d48aae79a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757b58a994d0e3b5a28af835417e53d5/" rel="bookmark">
			windows 安装Docker步骤以及在每一个步骤遇到问题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 安装Docker 简述Hyper-V问题一、开启Hyper-V二、下载Docker三、安装Docker四、下载 Linux 内核更新包五、win10开启wsl系统安装linux发行版打开Ubuntu ，显示错误参考的对象类型不支持尝试的操作。安装 Windows 终端（可选） 简单使用docker配置阿里云镜像加速地址验证docker可以正常使用 简述 Hyper-V Hyper-V 是一个虚拟环境，是微软自己的虚拟化技术，也是微软第一个采用Vmware与CitrixXen一样基于hypervisor的虚拟化技术，对windows的支持基本是没有问题的，而根据官方的资料介绍，它甚至可以安装专门为Linux设计的Integrated Components（里面包含磁盘和网络适配器的VMbus驱动）以使Linux虚机也能获得高性能，同样的，和主流的虚拟化技术相似，hyper-v也支持半虚拟化与全虚拟化，但它的半虚拟化仅支持与宿主机相同版本的系统，如果你不喜欢它的图形化界面，那你也可以在Server Core（命令行的windows）上安装hyper-v虚拟化程序，来满足自己的需求。
总而言之，hyper-v虚拟化技术继承了它的缔造者，微软图形化界面方便操作与直观展示的好处，按它的说法，它的虚拟化性能不比业界主流的虚拟化性能差，那就让时间来检验它的真伪吧。
问题一、开启Hyper-V 在windows专业版安装docker时可以在powerShell控制台，以管理员身份运行一下命令
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 专业版在运行以上命令后可以完成开启。但家庭版和学生版开启时会报错(即使是管理员模式下也没用)
enable-windowsoptionalfeature : 功能名称 microsoft-hyper-v 未知。
解决方法：
新建文本文件
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 编辑完保存后将文件后缀改为.cmd，建议用因为命名文件名比如：Hyper-V
保存完成后双击运行当前文件。文件执行完成后会在命令行提示重启电脑，在命令行输入y后电脑将自动重启。(下图为运行截图)
运行结束之后
重启之后打开程序面板-&gt;选择程序-&gt;启用或关闭window功能。之后就可以看到配置成功了。
二、下载Docker 首先给出官网的安装地址：官网链接
进去之后点击下面进行下载即可。
三、安装Docker 进入安装后保持默认已勾选选项点击继续
安装完成后点击关闭按钮电脑将进行重启。(如下图所示)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/757b58a994d0e3b5a28af835417e53d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a0964054ec8da9844667aab979d5ac/" rel="bookmark">
			EasyNLP 带你实现中英文机器阅读理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 机器阅读理解是自然语言处理（NLP），特别是自然语言理解（NLU）领域最重要的研究方向之一。自1977年首次被提出以来，机器阅读理解已有近50年的发展史，历经“人工规则”、“传统机器学习”、“深度学习”、“大规模预训练模型”等多个发展阶段。
机器阅读理解旨在帮助人类从大量文本中，快速聚焦相关信息，降低人工信息获取成本，增加信息检索有效性。作为人工智能在自然语言理解方向上的“集大成者”，机器阅读理解任务考察了从 “词” 到 “句” 乃至 “篇章”，每一个语言粒度的理解能力，这使得在人工智能发展的每个阶段，它都是非常困难、也颇为重要的“兵家必争之地”。以SQuAD为代表的阅读理解数据集，见证了深度学习大发展时代里，各大公司刷榜创新方案的你方唱罢我登场，随后又在大规模预训练时代，成为BERT等预训练模型的评测基准。可以说近十年里，机器阅读理解极大促进与见证了自然语言处理领域的繁荣与发展。
形式化来讲，机器阅读理解任务的输入为一段篇章文本（context），与一个问句（question），通过学习模型，输出预测的答案文本（answer）。根据获取答案方式的不同，当前业界主流将阅读理解任务分为四大类：完型填空式（Cloze tests）、多项选择式（Multi-choice）、片段抽取式（Span extraction）及自由生成式（Free answering）。其中片段抽取式根据问句（question），直接从篇章文本（context）中预测答案文本（answer）的起止位置（start/end positions），从而抽取出答案。由于其与真实场景接近，难度适中，易于评测，且有SQuAD等高质量数据集支撑，因此成为当前的主流阅读理解任务。随着预训练语言模型的发展，近年来片段抽取式阅读理解的效果屡创新高。在英文场景下，传统的BERT、RoBERTa、ALBERT等模型都能取得超越人类的效果；而在中文场景下，MacBERT等模型（Pre-Training with Whole Word Masking for Chinese BERT）通过引入一种纠错型掩码语言模型（Mac）预训练任务，缓解了“预训练-下游任务”不一致的问题，也更好地适配了中文场景，在包括机器阅读理解在内的多种NLP任务上取得了显著的性能提升。因此，我们在EasyNLP框架中集成了MacBERT算法和模型，配合EasyNLP中原有的BERT、RoBERTa等模型，使用户能够方便地使用这些模型进行中英文机器阅读理解任务的训练和预测。
EasyNLP（https://github.com/alibaba/EasyNLP）是阿⾥云机器学习PAI 团队基于 PyTorch 开发的易⽤且丰富的中⽂NLP算法框架，⽀持常⽤的中⽂预训练模型和⼤模型落地技术，并且提供了从训练到部署的⼀站式 NLP 开发体验。EasyNLP 提供了简洁的接⼝供⽤户开发 NLP 模型，包括NLP应⽤ AppZoo 和预训练 ModelZoo，同时提供技术帮助⽤户⾼效的落地超⼤预训练模型到业务。机器阅读理解作为自然语言理解的集大成者，同时也是文本问答、信息抽取等领域的基础任务，具有较高的研究价值。因此，EasyNLP增加了对中英文机器阅读理解任务的支持，希望能服务更多的NLP/NLU算法开发者和研究者，也希望和社区一起推动NLU相关技术的发展和落地。
本⽂将提供对MacBERT模型的技术解读，以及如何在EasyNLP框架中使⽤MacBERT及其他预训练语言模型，进行中英文机器阅读理解任务的训练与预测。
MacBERT模型解读 主流的大规模预训练语言模型（如BERT、RoBERTa等）主要针对英语语言设计，将其直接迁移到中文场景时，会面临中英文语言本身的差异，如：中文词间无空格、无需切分子词、多个单字组成具有完整意义的词语等。例如下图中原始语句“使用语言模型来预测下一个词的概率”，按单字切分后，某些单字由于会组成完整的词语（如：语言模型、预测、概率），此时若只mask掉其中一个字，会影响掩码与语言模型预训练的效果。此外，传统语言模型在预训练时会采用 [MASK] 字符进行mask，而在下游任务文本中却并不存在 [MASK] 标记，这在两阶段中天然引入了gap。为缓解上述问题，MacBERT等模型修改传统MLM任务，引入了一种纠错型掩码语言模型（Mac）预训练任务，包括wwm (whole word masking)、NM（n-gram masking）、相似词替换等mask方案，更好地适配了中文的语言场景，减少了“预训练-下游任务”不一致的问题，提升了预训练模型在多种NLP任务上的效果。另外，由于MacBERT的主要框架与BERT完全一致，可在不修改现有代码的基础上进行无缝过渡，这为开发者的代码迁移带来了很大的便利。
具体来讲，MacBERT等模型在MLM时，对中文整词中所有单字同时进行mask，并采用n-gram mask策略，从unigram到4-gram对应的mask概率分别为40%-10%。在mask时不再采用 [MASK] token，而改为使用词语的近义词，近义词采用基于word2vec相似度计算的Synonyms toolkit获取，在极少数情况没有近义词时，使用随机词进行替换。模型总体对输入15%的词进行mask，mask时80%的概率替换为近义词、10%的概率替换为随机词、10%的概率保留为原始词。此外，BERT原版的NSP模型长期为研究者们所诟病，MacBERT模型中将NSP修改为SOP (Sentence Order Prediction)，其正例为连续文本，负例为交换原始文本顺序，这样很好提升了模型在多句篇章型任务上的效果。模型的实验结果表明，去除上述MLM中任一改进都会导致平均性能下降，这表明几处掩码修改都有助于语言模型学习；同时去除SOP任务后，在机器阅读理解任务上的效果会明显下降，这也表明句子级预训练任务在篇章学习中的必要性。
机器阅读理解模型使用教程 以下我们简要介绍，如何在EasyNLP框架中使用MacBERT及其他预训练语言模型，进行机器阅读理解任务的训练及预测。
安装EasyNLP 用户可以直接参考GitHub（https://github.com/alibaba/EasyNLP）上的说明安装EasyNLP算法框架。
pipeline接口快速“尝鲜”体验效果 为了方便开发者使用，我们在EasyNLP框架内实现了Inference Pipeline功能。用户可以在不需要自己训练或微调模型的情况下，直接“尝鲜”，使用pipeline接口一步调用finetune好的中英文机器阅读理解模型。只需执行如下命令即可：
from easynlp.pipelines import pipeline # 输入数据 data = [{ "query": "杭州什么时候发布了《杭州市亚运城市行动计划纲要》？", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75a0964054ec8da9844667aab979d5ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd4cdcd4067854adda148fe4c1b1330/" rel="bookmark">
			若依 springBoot2.5 &#43;vue2前后端分离，实现图片上传及下载功能。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 图片上传2.图片下载 1. 图片上传 vue 前端，引入&lt; image-upload /&gt;组件。 &lt;el-row&gt; &lt;el-col :span="12"&gt; &lt;el-form-item label="头像" prop="avatar"&gt; &lt;image-upload v-model="form.avatar" :limit="1"/&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt; image-upload /&gt;组件 源码：
&lt;template&gt; &lt;div class="component-upload-image"&gt; &lt;el-upload :action="uploadImgUrl" list-type="picture-card" :on-success="handleUploadSuccess" :before-upload="handleBeforeUpload" :limit="limit" :on-error="handleUploadError" :on-exceed="handleExceed" ref="imageUpload" :on-remove="handleDelete" :show-file-list="true" :headers="headers" :file-list="fileList" :on-preview="handlePictureCardPreview" :class="{hide: this.fileList.length &gt;= this.limit}" &gt; &lt;i class="el-icon-plus"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;!-- 上传提示 --&gt; &lt;div class="el-upload__tip" slot="tip" v-if="showTip"&gt; 请上传 &lt;template v-if="fileSize"&gt; 大小不超过 &lt;b style="color: #f56c6c"&gt;{{ fileSize }}MB&lt;/b&gt; &lt;/template&gt; &lt;template v-if="fileType"&gt; 格式为 &lt;b style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd4cdcd4067854adda148fe4c1b1330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a0fa3cb7e5f97d0231f380be306341/" rel="bookmark">
			Apache-Log4j-Server-反序列化（CVE-2017-5645）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述
Apache Log4j是一个用于Java的日志记录库，其支持启动远程日志服务器。Apache Log4j 2.8.2之前的2.x版本中存在安全漏洞。攻击者可利用该漏洞执行任意代码。
kali 环境配置
安装https协议、CA证书、dirmngr
apt-get update
apt-get install -y apt-transport-https ca-certificates
apt-get install dirmngr
添加GPG密钥并添加更新源
curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -
echo ‘deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable’ | sudo tee /etc/apt/sources.list.d/docker.list
系统更新以及安装docker
apt-get update&amp;&amp;apt install docker-ce
启动docker服务器 和compose
service docker start || apt install docker-compose
下载安装vulhub
git clone https://github.com/vulhub/vulhub.git
漏洞复现
启动环境/vulhub-master/log4j/CVE-2017-5645
docker-compose up -d
nmap扫描ip
nmap 192.168.1.240 -p 4712 使用ysoserial生成payload ，创建CVE-2017-5645_is_success
java -jar ysoserial.jar CommonsCollections5 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a0fa3cb7e5f97d0231f380be306341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc70dd44df94984a8f2d70ebb6406c6/" rel="bookmark">
			CSS之height: 100%和height: auto的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		height: auto —— 是指根据块内内容自动调节高度（高度自然撑开）
height:100% —— 是指其相对父块高度而定义的高度，也就是按照离它最近且有定义高度的父层的高度来定义高度
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/122/">«</a>
	<span class="pagination__item pagination__item--current">123/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/124/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>