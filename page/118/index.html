<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4201650dc40116963d0098558e173837/" rel="bookmark">
			vue3.0有哪些哪些更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的 反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制 （1）监测机制的改 变 ： （2）只能监测属性，不能监测对象检测属性的添加和删除；检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 （3）模板作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 （4）对象式的组件声明方式 vue2.x 中 的 组 件 是 通 过 声 明 的 方 式 传 入 一 系 列 option， 和TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和TypeScript 的结合变得很容易 （5）其它方面的更改 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 tree shaking 优化，提供了更多的内置功能。 35.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4201650dc40116963d0098558e173837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024972e2e20fdbc4ca3a40d0b38a14f4/" rel="bookmark">
			【C语言】数组详解，初学者一看就懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你每天都在做很多看起来毫无意义的决定，但某天你的某个决定就能改变你的一生。——《西雅图不眠夜》 目录
什么是C语言数组？
1、一维数组的创建与初始化
1.1数组的创建格式
1.2数组的初始化
1.3一维数组的使用
1.4一维数组在内存中的存储
2、二维数组的创建与初始化
2.1二维数组的创建格式
2.2二维数组初始化
2.3二维数组的使用
2.4二维数组在内存中的存储
3、越界数组
4、为什么数组下标是从0开始的？
5、数组作为函数参数
5.1冒泡排序函数的错误设计
5.2数组名到底是什么？
5.3冒泡排序函数的正确设计
什么是C语言数组？ 首先，从字面了解数组是一堆数字组成的集合。C语言中数组是一组固定大小且相同类型元素的集合。数组分为一维数组和二维数组。数组类型的声明并不是对一个元素进行声明而是对整个数组里面的元素类型都进行声明。所有的数组元素都是在一块连续的地址上的存储的，第一个元素占最低的地址，最后一个元素占最高的地址。数组的下标从0开始到元素的个数减1结束。 1、一维数组的创建与初始化 1.1数组的创建格式 数组是由数组类型+数组名+数组大小组成的，其中最重要的是数组大小是一个常量表达式。结合下图理解：
🤼数组的创建格式有四种情况，如下所示：
情况1，定义一个数组并给定数组大小
int arry1[10]；//未初始化的名为arry1的整形数组大小是10
情况2，定义一个常量并给定数组大小为这个常量
const int a=5；//定义一个常量a=5
int arry5[a]；//未初始化的名为arry5的整形数组大小是5
情况3，数组大小为常量表达式
int arry6[5+6]；//未初始化的名为arry6的整形数组大小是11
情况4，空数组
int arry7[]；//未初始化的名为arry7的整形数组大小未知
温馨提示：以上均是用整形定义的，您可以定义其他类型。
注意：数组创建，在C99标准之前， [] 中要给一个常量才可以，不能使用变量。在C99标准支持了变长数组的概念，数组的大小可以使用变量指定，但是数组不能初始化。
1.2数组的初始化 在了解数组的创建格式后，我们来看数组的初始化。初始化就是在创建数组后给定数组里面与数组类型相同的元素。初始化又分为完全初始化和不完全初始化，我们来看代码：
1、int arry[10] = { 0 };//完全初始化 2、int arry1[6] = { 1,2,3 };//不完全初始化 3、int arry2[5] = { 1,2,3,4,5 };//完全初始化 4、char arry3[] = { 'a','b','c' };//完全初始化 5、char arry4[] = { 'a','b',66,'c' };//完全初始化 6、char arry5[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024972e2e20fdbc4ca3a40d0b38a14f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d588506dbbfd4ab38792db72fbc5d9c/" rel="bookmark">
			手机如何实现边充电边传输数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常我们在手机连接电脑或者U盘传输数据的时候，虽然都是传输数据，但是主从关系是不同的，在手机连接电脑的时候可以同时给手机充电，而连接U盘的时候是手机提供电力给U盘，造成这种区别到底是由什么控制呢？
首先我们要知道数据和供电是两个角色，数据和供电都有主从关系。就拿手机的Type-C接口来说，接口里搭载的PD协议里定义了 Data Role 和 Power Role 。
在USB2.0端口的Data Role里，USB根据数据传输的方向定义了HOST/Device/OTG三种角色，其中OTG即可作为HOST，也可作为Device，在Type-C中，也有类似的定义，只是名字有了些许修改。
1.DFP(Downstream Facing Port)：
下行端口，可以理解为Host或者是HUB，DFP提供VBUS、VCONN，可以接收数据。在协议规范中DFP特指数据的下行传输，笼统意义上指的是数据下行和对外提供电源的设备。
2.UFP（Upstream Facing Port）：
上行端口，可以理解为Device，UFP从VBUS中取电，并可提供数据。典型设备是U盘，移动硬盘。
3.DRP（Dual Role Port）：
请注意DRP分为DRD(Dual Role Data)/DRP(Dual Role Power)双角色端口，类似于以前的OTG，DRP既可以做DFP(Host)，也可以做UFP(Device)，也可以在DFP与UFP间动态切换。典型的DRP设备是笔记本电脑。设备刚连接时作为哪一种角色，由端口的Power Role（参考后面的介绍）决定；后续也可以通过switch过程更改（如果支持USB PD协议的话）。
而在Type-C的Power Role里，同样根据USB PORT的供电（或者受电）情况，USB Type-C将port划分为Source、Sink等power角色
Power Role 详细可以分为：
1.Source Only 2.默认Source，但是偶尔能够通过PD SWAP切换为SINK模式
3.Sink Only
4.默认SINK，但是偶尔能够通过PD SWAP切换为Source模式
5.Source/SINK 轮换
6.Sourcing Device （能供电的Device，显示器）
7.Sinking Host（吃电的Host，笔记本电脑）
USB Type-C的插座中有两个CC脚，以下的角色检测，都是通过CC脚进行的，但是对于插头、或者线缆正常只有一个CC引脚，两个端口连接在一起之后，只存在一个CC引脚连接，通过检测哪一个CC有连接，就可以判断连接的方向。如果USB线缆中有需供电的器件，其中一个CC引脚将作为VCONN供电。
CC引脚有如下作用：
1.检测USB Type-C端口的插入，如Source接入到Sink
2.用于判断插入方向，翻转数据链路
3.在两个连接的Port之间，建立对应的Data Role
4.配置VBUS，通过下拉电阻判断规格，在PD协商中使用，为半双工模式
5.配置VCONN
6.检测还有配置其他可选的配置模式，如耳机或者其他模式
再回到实际应用中，正常来说Power Role和Data Role都是同步的，比如手机连接U盘的时候，手机的Power Role是DFP，Data Role也是做host；当手机连接笔记本，手机的Power Role是UFP，Data Role也是做device。如果要让手机Power Role做UFP，Data Role做host就需要用到PD协议芯片切换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d588506dbbfd4ab38792db72fbc5d9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38646456b7c93cac574f30b5ce50bd0/" rel="bookmark">
			libopus 实现pcm 编码到opus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		opus 是一种音频格式，常用于语音通话、视频会议中。最近做了个pcm 到opus 的编码，踩了不少坑，特此记录一下。
目录
1、基础知识
2、使用流程
2.1 创建编码器
2.2 编码器配置
2.3 进行编码
2.4 完整代码
3、结果验证
4、参考资料
1、基础知识 opus 支持2.5、5、10、20、40、60ms 等帧长，对于一个48000khz 的 16bit，双通道，20 ms 的pcm 音频来说，每ms 样本数为 48000/1000 = 48，采用位深为16bit/8 = 2byte，所以需要的pcm 字节数为
pcm size = 48 样本/ms X 20ms X 2byte X 2 channel = 3840 byte 对于采样为16 bit 的2声道的PCM 数据来说，其内存布局如下图所示
LLLL LLLL LLLL LLLL RRRR RRRR RRRR RRRR opus 编码函数是 opus_encode，其输入数组是 opus_int16 数组，2字节，要进行unsigned char 数组到 opus_int16 数组的转换后才能送入编码器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38646456b7c93cac574f30b5ce50bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06867af678952d38aababb0822bc3b28/" rel="bookmark">
			深度学习原理-----循环神经网络（RNN、LSTM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 深度学习原理-----线性回归+梯度下降法 深度学习原理-----逻辑回归算法 深度学习原理-----全连接神经网络 深度学习原理-----卷积神经网络 深度学习原理-----循环神经网络（RNN、LSTM）
时间序列预测-----基于BP、LSTM、CNN-LSTM神经网络算法的单特征用电负荷预测
时间序列预测(多特征)-----基于BP、LSTM、CNN-LSTM神经网络算法的多特征用电负荷预测
系列教学视频 快速入门深度学习与实战
[手把手教学]基于BP神经网络单特征用电负荷预测
[手把手教学]基于RNN、LSTM神经网络单特征用电负荷预测
[手把手教学]基于CNN-LSTM神经网络单特征用电负荷预测
[多特征预测]基于BP神经网络多特征电力负荷预测
[多特征预测]基于RNN、LSTM多特征用电负荷预测
[多特征预测]基于CNN-LSTM网络多特征用电负荷预测
文章目录 系列文章目录系列教学视频前言1、RNN神经网络1.1、权重共享1.2、案例1.3、RNN神经网络存在问题 2、LSTM神经网络2.1、遗忘门2.2、输入门2.3、更新细胞状态2.4、输出门2.5、LSTM神经网络是如何缓解RNN梯度消失的问题 总结 前言 相比较图像这类数据在空间上有一定的特点外，还有一类数据是在时间上有一定的特点的，这类的数据称之为时间序列数据。从定义上来说，就是一串按时间维度索引的数据。比如，自然语言是就是一个很典型的时间序列数据，每个字或者每个词是根据时间维度上不断输出出来，具有很强的先后时间顺序。除了自然语言数据之外还有天气数据、车流量数据、电力负荷数据等数据是时间序列数据，这类数据都是按时间维度索引的数据。
时间序列数据有一个最重要的特征是前一段时间维度的数据对后面一段时刻的数据有着很大的影响，例如自然语言，有这样的一句话：“我在中国生活了很多年，因此我会很流利的说出__”。很显然这里的空格应该填“中文”，“汉语”，“普通话”等和中文相关的词。如果这时候在空格里面填“日语”、“英语”等其他的国家的语言的话，上面这句话就会很容易让人产生歧义，因为前面的“我在中国生活了很多年”，这段话对后面产生很大的影响。
例如天气数据，一份天气数据中包含着每天的温度，湿度，气压、风速是否下雨等气象特征，前一段时刻的气象特征数据必然影响着后面一段时间的气象数据，因此生活当中的温度往往都是缓和的周期变化，有很明显的周期性，季节性变动。
对于这样的时间序列数据，全连接神经网络和卷积神经网络都不能很好的考虑到时间序列数据之间的序列关系。因为全连接神经网络和卷积神经网络都属于前向反馈网络，模型的最终的输出和模型本身没有关联。而循环神经网络模型的前一刻时刻最终输出可以作为下一个时刻的输入从而学习到前面时刻的信息，因此循环神经网络可以很好的学习到时间序列数据中的序列关系，从而在处理时间序列数据的时候往往有很好的效果。
1、RNN神经网络 循环神经网络中比较经典基础的神经网络是RNN神经网络，这个网络基本上阐述了循环神经网络的运行原理，因此想弄懂循环神经网络中的其他改进的神经网络例如LSTM和GRU的话，必须要首先弄懂RNN神经网络。 如上图所示，为RNN神经网络的基本结构，说句实话当我第一次看到这个结构的时候是一脸懵的，从网络结构上来说，这个网络结构图比全连接神经网络和卷积神经网络难懂多了。难懂的原因是因为这个图貌似太简单了，貌似很难从图中理解循环神经网络，下面对这个图进行讲解。
X t X_t Xt​为输入的时间序列数据，输入的数据按时刻输入的，也就是数据的输入是有先后顺序的。
h t \mathrm{h}_t ht​为每个时刻数据通过神经网络计算的隐藏层的输出，因此A就是RNN神经网络的隐藏层，同时这个输出会和下一时刻输入的数据相加，然后作为新的输入送入到神经网络中进行神经网络的计算；
最后输出，不断循环重复上述的过程直至最后一个时刻的输入数据运算结束。由于RNN神经网络是对输入的数据不断进行循环计算的，因此相对来说RNN神经网络的计算速度比较慢。
貌似，上述的RNN神经网络的运行过程还不是那么直观，那么可以将上述的图展开成如下的形状应该容易理解一点。这里要特别提示：看这个图最好不要从全局去看，这样容易将你带入理解的误区，而是应该从左往右一个时刻一个时刻的计算单元去看。这样才能更好的理解RNN神经网络是逐个时刻进行计算的，因此前面时刻对后面时刻的输出是有影响的。 如上图所示，输入数据包含0时刻到t时刻的数据征。
首先输入0时刻的数据特征进行神经网络的计算得到隐藏层输出 h 0 \mathrm{h}_0 h0​，将这个隐藏层输出 h 0 \mathrm{h}_0 h0​和1时刻的输入 X 1 X_1 X1​进行加权求和，此时1时刻的输入中已经包含了0时刻的数据信息了；
然后再将上述的加权求和后的数据输入到神经网络中进行计算得到1时刻的隐藏层输出 h 1 \mathrm{h}_1 h1​ ，再将 h 1 \mathrm{h}_1 h1​和 X 2 X_2 X2​进行加权求和，此时2时刻的输入已经包含了0、1的信息了；
再将加权求和后的数据进行神经网络计算，得到2时刻的隐藏层输出 h 2 \mathrm{h}_2 h2​ ，不断循环上述过程直到t时刻结束，得到t时刻的隐藏层输出 h t \mathrm{h}_t ht​ ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06867af678952d38aababb0822bc3b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb436797a5389cddb7b6945466488e4/" rel="bookmark">
			深度学习原理-----卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 深度学习原理-----线性回归+梯度下降法 深度学习原理-----逻辑回归算法 深度学习原理-----全连接神经网络 深度学习原理-----卷积神经网络 深度学习原理-----循环神经网络（RNN、LSTM）
时间序列预测-----基于BP、LSTM、CNN-LSTM神经网络算法的单特征用电负荷预测
时间序列预测(多特征)-----基于BP、LSTM、CNN-LSTM神经网络算法的多特征用电负荷预测
系列教学视频 快速入门深度学习与实战
[手把手教学]基于BP神经网络单特征用电负荷预测
[手把手教学]基于RNN、LSTM神经网络单特征用电负荷预测
[手把手教学]基于CNN-LSTM神经网络单特征用电负荷预测
[多特征预测]基于BP神经网络多特征电力负荷预测
[多特征预测]基于RNN、LSTM多特征用电负荷预测
[多特征预测]基于CNN-LSTM网络多特征用电负荷预测
文章目录 系列文章目录系列教学视频前言1、图像的本质1.1、灰度图1.2、彩色图 2、整体结构3、卷积层3.1、全连接存在的问题3.2、卷积运算3.3、填充3.4、步幅3.5、多通道数据卷积运算 4、池化层总结 前言 卷积神经网络是深度学习中一个比较重要的知识点，目前深度学习分为三大块：大数据与数据挖掘、计算机视觉、自然语言处理。计算机视觉中深度学习算法几乎都用到了卷积神经网络来作为图像的特征提取，因此卷积神经网络在深度学习中的地位是不可撼动的。
但是卷积神经网络在1998年就被提出了，一直没有被广泛利用的原因是那时候计算机的性能比较低，卷积神经网络的性能很难被发挥。直到2012年AlexNet取得ImageNet比赛的分类任务的冠军，并且分类准确率远远超过利用传统方法实现的分类结果，从此深度学习的发展一发不可收拾。
1、图像的本质 既然卷积神经网络多用于图像的特征提取，在进行卷积神经网络模型的学习之前要搞清图像在计算机中的本质是什么，这样才有利于去学习卷积神经网络。目前比较流行的图片格式有灰度和RGB格式。
1.1、灰度图 灰度图就是我们常见的黑白图像，如下图是一个黑白图像，这是一个数字8，仔细观察图片可以发现，这个图片的边缘貌似是由一个又一个小方格所组成的，事实上这个图片整体就是用一个又一个小方格所组成的。由于这个图像的高度为24，宽度为16，因此这个图片是由24*16一共384个小方格所组成的。
但是从图中可以看到有黑色、白色、灰色的地方，同时灰色的程度还不尽相同。图像中的每一个小块都代表一个像素，每一个小块都有一个像素值，这些像素值表示像素的强度，像素值的大小范围为0到255，其中0为黑色，255为白色，图像越深的地方说明像素值越接近0，图像越浅的地方说明像素值越接近255。因此在计算机中图像保存为一个数字矩阵。具体就如下图所示：
灰度图是由一个数字矩阵表示的，但是我们生活中更加常见的彩色图是由3个数字矩阵表示的。
1.2、彩色图 不知道大家在生活中观察到这样的情况，就是有时候不小心把水溅到了手机屏幕或者电视屏幕上，通过水珠可以观察到一个又一个很小的小方格，这些方格有不同的颜色，但是只有红色、绿色和蓝色。初中的时候学习物理的时候知道，这3个颜色称为3原色，可以按不同的比例生成各种颜色。如下图所示：
因此，计算机表示彩色图的时候是用3个数字矩阵表示的。具体形式如下图所示：
1个用于显示红色的矩阵，矩阵的中的数值大小范围也是在0到255，当数值越接近0的时候红色的表示就越深，当数值越接近0的时候，红色的表示就越浅。
1个用于显示绿色的矩阵，矩阵的中的数值大小范围也是在0到255，当数值越接近0的时候绿色的表示就越深，当数值越接近0的时候，绿色的表示就越浅。
1个用于显示蓝色的矩阵，矩阵的中的数值大小范围也是在0到255，当数值越接近0的时候蓝色的表示就越深，当数值越接近0的时候，蓝色的表示就越浅。
这些像素数值在0到255之间，其中每个数字代表像素的强度，所有这些通道矩阵叠加在一起就变成了三通道图像，当图像的形状加载到计算机中时，像素矩阵为H×W×3。其中H是整个高度上的像素数量，W是整个宽度上的像素数，3表示通道数。
2、整体结构 首先，来看一下卷积神经网络的整体结构，如下图所示，相对于全连接神经网络，卷积神经网络中出现了卷积层和池化层，输入卷积神经网络中的数据特征图通过卷积运算和池化运算，将其中的有效特征提取出来输入到全连接层，并对数据进行分类或者预测。
3、卷积层 卷积神经网络出现了一些特有的术语，比如填充和步幅等。之前对图片在计算中本质进行了讲解，图片在计算机中就是一个数字矩阵，而卷积神经网络的输入就是这样的一个数字矩阵，输入的数据的格式应该是CHW，这里的C就是数据的通道数，以之前灰度图和彩色图为例灰度图的C就是1，彩色图就是3（需要注意的是：这里的C不一定是1或者3，通过卷积计算后特征图的通道会变化，同时输入数据不一定是图片数据，那么构造的数据特征图的通道也不一定是1或者3）；同时这里的H就是数据矩阵的高，W就是数据矩阵的宽。
3.1、全连接存在的问题 在全连接神经网络中，相邻的神经元全部连接在一起，因此一个神经网络层呈现长条状，但是输入的数据是图像这样具有3维形状的数据的时候，全连接神经网络的处理是将数据拉平为一维的状态。如下图所示： 像图像这样的3维形状的数据中应该含有重要的空间信息。比如，空间上相邻的地方像素值应该是相似的值、RGB通道之间分别有着密切的关联性，但是相距比较远的像素之间的关联性比较低。但是全连接层会忽视形状，将全部的信息作为相同的神经元处理，因此无法利用与形状相关的信息。
但是卷积神经网络中的卷积层可以保持形状不变，当输入的数据是图像的时候，卷积层会以3维的数据形式接受数据，同样以3维的形式输出到下一层，因此相对于全连接神经网络，卷积神经网络可以比较好的理解空间形状的数据。
3.2、卷积运算 卷积神经网络的核心就是存在卷积运算的卷积层，卷积运算相当于图像处理中的滤波运算，因此卷积核又被称之为滤波器。下面通过一个具体的例子来理解卷积运算。 如上图所示，输入的数据是一个具有空间形状的数据，卷积核也是一个具有长高方向的维度，假设用（height，width）表示数据和卷积核的形状，在本例中数据和卷积核的形状分别为（3,3）和（2,2），输出数据的大小为（2,2）。但是要注意的是，卷积核的长和高一般是一样大小的（当然也是可以用不一样大小的）。
现在来具体解释一下卷积运算的运算过程。对于输入数据，卷积运算以一定间隔来滑动和卷积核大小一样的窗口的数据和卷积核进行对于位置相乘并求和。如图所示，卷积核的窗口大小为22，那么从数据的左上角取一块和卷积核一样大小的数据块和卷积核对应的位置相乘，最后将数据求和。这里的具体计算如下式所示： 0 ∗ 0 + 1 ∗ 1 + 3 ∗ 2 + 3 ∗ 4 = 19 0 * 0+1 * 1+3 * 2+3 * 4=19 0∗0+1∗1+3∗2+3∗4=19 此时再将这个窗口向右滑动一步，如图所示，取该窗口中的数据和卷积核进行卷积运算，并得出对应值。此时窗口已经不能再向右边滑动了，那么窗口向下滑动一步，继续重复上述窗口从左到右滑动取数据和卷积核进行对应数据相乘最后求和的步骤。具体如图所示： 在全连接神经网络中，神经网络有两种参数，一种是权重参数、一种是偏置参数。在卷积神经网络中，卷积核就是卷积神经网络网络的权重参数，当然卷积神经网络中也是存在偏置参数的。如图所示，偏置参数的形状通常是一个11，这个偏置的参数值会被加到通过卷积运算的所有元素上。具体如图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb436797a5389cddb7b6945466488e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de42672468078af86077916f66982e3/" rel="bookmark">
			[时间序列预测]基于BP、LSTM、CNN-LSTM神经网络算法的单特征用电负荷预测[保姆级手把手教学]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 深度学习原理-----线性回归+梯度下降法 深度学习原理-----逻辑回归算法 深度学习原理-----全连接神经网络 深度学习原理-----卷积神经网络 深度学习原理-----循环神经网络（RNN、LSTM）
时间序列预测-----基于BP、LSTM、CNN-LSTM神经网络算法的单特征用电负荷预测
时间序列预测(多特征)-----基于BP、LSTM、CNN-LSTM神经网络算法的多特征用电负荷预测
系列教学视频 快速入门深度学习与实战
[手把手教学]基于BP神经网络单特征用电负荷预测
[手把手教学]基于RNN、LSTM神经网络单特征用电负荷预测
[手把手教学]基于CNN-LSTM神经网络单特征用电负荷预测
[多特征预测]基于BP神经网络多特征电力负荷预测
[多特征预测]基于RNN、LSTM多特征用电负荷预测
[多特征预测]基于CNN-LSTM网络多特征用电负荷预测
文章目录 系列文章目录系列教学视频前言一、单特征电力负荷数据分析1.1、数据展示1.2、分析电力负荷中的规律 二、基于BP神经网络单特征电力负荷预测2.1、BP神经网络模型应用于单特征电力负荷预测2.2、 数据预处理与数据集划分2.3、模型搭建2.4、模型预测 三、基于RNN、LSTM神经网络单特征电力负荷预测3.1、RNN、LSTM神经网络模型应用于单特征电力负荷预测3.2、数据预处理与数据集划分3.3、模型搭建3.4、模型预测 四、基于CNN-LSTM神经网络单特征电力负荷预测4.1、CNN-LSTM神经网络模型应用于多特征电力负荷预测4.1.1、一维卷积运算4.1.2、一维池化运算 4.2、CNN-LSTM模型应用于多影响因素电力负荷预测4.3、数据预处理与数据集划分4.4、模型搭建4.5、模型预测 五、单特征电力负荷预测模型对比分析总结六、电力负荷预测模型后续更新计划 前言 电力能源是目前人类离不开的能源，但是电力能源又是一个不容易储存的能源，中国目前的电力能源大部分都是由火力进行发电的；一个地区的电力能源消耗随着时间的变化而变化；如果发电量低于人们的用电量，就会导致电压不稳的同时很多人也用不上电，如果发电量高于人们的用电量时，由于电力能源的不易储存性，就会导致电力能源白白的浪费。因此如果可以对未来用电量有一个精准的用电量的预测，可以大大避免电力能源的浪费的同时也可以维护电力系统的稳定。
在上述的背景下，电力负荷预测一直是一个比较火热的科研课题；在目前深度学习技术高速发展下，大量的深度学习神经网络模型被应用到电力负荷预测中，同时也取得了比较好的预测结果。电力负荷预测任务可以分为单特征预测和多特征预测，单特征预测利用的是电力负荷数据去预测电力负荷数据，多特征预测利用的是影响电力负荷的影响因素和电力负荷数据去预测电力负荷数据。
本文主要利用深度学习中的BP神经网络、RNN、LSTM神经网络、CNN-LSTM神经网络进行单特征电力负荷预测，并进行模型的对比。
一、单特征电力负荷数据分析 1.1、数据展示 关于单特征的电力负荷预测深度学习实验数据集如下所示：
具体数据可以去我的课程去获取：
[手把手教学]基于BP神经网络单特征用电负荷预测
[手把手教学]基于RNN、LSTM神经网络单特征用电负荷预测
[手把手教学]基于CNN-LSTM神经网络单特征用电负荷预测
该数据为2014年某地区一年的数据，数据的采样点为15分钟一采样，那么一天就是一共有96个采样点。因此上述的数据一共有365行，96列的数据，每一行分别对应其中一天的电力负荷数据，每一列分别对应其中某一采样点的电力负荷数据。由于是单特征电力负荷预测的研究，数据中除了电力负荷数据没有别的特征。
1.2、分析电力负荷中的规律 如下图所示，是某地区2014年的一整年的电力负荷数据展示图。
从图中可以看出，在2月的时候，该地区的用电量处于一个整个年度最低的状况。同时从6月份到9月份整体的用电量处于一个比较高的水平，这可能是和天气有关，这段时间的天气比较炎热导致用电量比较高。
同时仔细观察图中的用电量，貌似处在一共上下波动反复循环的状态，从生活的常识来看，用电量和人们的作息有很强的相关性的。因此下面来具体看看周电力负荷图是什么样子的。
如上图所示，将该地区的周电力负荷值用图的形式展示出来；从图中可以看出，工作日周一到周五的用电量要比休息日周六和周日所用的点峰值要高，这可能说明电力能源很多是被投入到工作中。同时图中的用电负荷波形处于一种循环的状态，这很显然说明用电量和人的作息有着很强的相关性；当人们休息的时候保持着一种很低的用电状态，当人们工作生活时电力能源的消耗处于一种很高的状态；并且这样的状态不断反复循环。
二、基于BP神经网络单特征电力负荷预测 2.1、BP神经网络模型应用于单特征电力负荷预测 单特征电力负荷预测本质上是回归任务，也就是最终神经网络的输出值是连续的不确定值。
在神经网络中输入的数据称之为特征，一般是用X来表示，神经网络的输出一般用y来表示；同时回归预测任务为监督学习任务，数据有对应的标签，该标签为神经网络的正确答案，一般用Y来表示。神经网络的输出y和标签Y之间有一定的误差，利用这个误差可以进行神经网络的反向传播，利用反向传播使神经网络输出的y和Y之间的误差不断减小直到接近于0。
上述就是单特征负荷预测模型不断从数据中学习到有用的信息从而使模型最终预测结果接近真实值，在单特征负荷预测的任务中电力负荷数据即使输入特征X，也是数据的真实标签Y，并且输入有且只有电力负荷数据，相比较的还有多特征电力负荷预测任务，此时的输入特征就不仅仅还有电力负荷数据了，还可能还有影响电力负荷的影响因素。
下面我们整体看看BP神经网络怎么利用电力负荷数据进行电力负荷预测任务的。在该任务中BP神经网络模型的结构如下所示：
如上图所示是BP神经网络进行单特征电力负荷预测的模型图，从图中可以看出BP神经网络的输入只只含有电力负荷值，神经网络含有两层隐藏层，通过隐藏层的计算最终通过输出层输出神经网络输出值。该值为电力负荷的预测值。
2.2、 数据预处理与数据集划分 如下是单特征电力负荷预测数据集的预处理与划分部分：
# 获取前80%作为数据的训练集80%到90%作为验证集 # 划分训练集和验证集 train = dataset.iloc[0:int(len(a)*0.8), [0]] val = dataset.iloc[int(len(a)*0.8):int(len(a)*0.9), [0]] # 进行数据归一化，将数据归一化到0-1之间 scaler = MinMaxScaler(feature_range=(0, 1)) train = scaler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de42672468078af86077916f66982e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edc4318ecc0fc9fcf25161ed3f21874/" rel="bookmark">
			[时间序列预测]基于BP、RNN、LSTM、CNN-LSTM算法多特征（多影响因素）用电负荷预测[保姆级手把手教学]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 深度学习原理-----线性回归+梯度下降法 深度学习原理-----逻辑回归算法 深度学习原理-----全连接神经网络 深度学习原理-----卷积神经网络 深度学习原理-----循环神经网络（RNN、LSTM）
时间序列预测-----基于BP、LSTM、CNN-LSTM神经网络算法的单特征用电负荷预测
时间序列预测(多特征)-----基于BP、LSTM、CNN-LSTM神经网络算法的多特征用电负荷预测
系列教学视频 快速入门深度学习与实战
[手把手教学]基于BP神经网络单特征用电负荷预测
[手把手教学]基于RNN、LSTM神经网络单特征用电负荷预测
[手把手教学]基于CNN-LSTM神经网络单特征用电负荷预测
[多特征预测]基于BP神经网络多特征电力负荷预测
[多特征预测]基于RNN、LSTM多特征用电负荷预测
[多特征预测]基于CNN-LSTM网络多特征用电负荷预测
文章目录 系列文章目录系列教学视频前言一、多影响因素电力负荷数据分析1.1、数据展示1.2、电力负荷和影响因素对比1.3、分析电力负荷中的规律 二、基于BP神经网络多特征电力负荷预测2.1、BP神经网络模型应用于多特征电力负荷预测2.2、 数据预处理与数据集划分2.3、模型搭建2.4、模型预测 三、基于RNN、LSTM神经网络多特征电力负荷预测3.1、RNN、LSTM神经网络模型应用于多特征电力负荷预测3.2、数据预处理与数据集划分3.3、模型搭建3.4、模型预测 四、基于CNN-LSTM神经网络多特征电力负荷预测4.1、一维卷积运算和池化运算4.1.1、一维卷积运算4.1.2、一维池化运算 4.2、CNN-LSTM模型应用于多影响因素电力负荷预测4.3、数据预处理与数据集划分4.4、模型搭建4.5、模型预测 五、多特征电力负荷预测模型对比分析总结六、电力负荷预测模型后续更新计划 前言 在时间序列预测任务中，一般根据输入分为两种类别的任务，第一种任务是单特征输入的任务，例如在对股票闭盘价格进行预测的时候，输入到神经网络的数据只有股票的闭盘价格，也就是利用闭盘价格来预测闭盘价格，此时的闭盘价格数据既是特征X也是标签Y；还有一种任务是多特征输入的任务，在这样的任务下，神经网络的输入特征就不是单一的特征了，而是多特征的，例如在股票预测这样的案例中预测股票的闭盘价格，可以输入股票的开盘价、最高价、最低价、闭盘价来预测闭盘价，在多特征输入的时间预测任务，数据的预处理可能稍微要比单特征输入任务要复杂一些。
类比上述的股票闭盘价格的预测任务，在电力负荷预测任务中也是一样的，单特征输入电力负荷预测输入的是电力负荷值，利用电力负荷值来预测电力负荷值；多特征电力负荷预测就是本文接下来要讲解的项目，在本项目中输入的特征有温度、湿度、电价和负荷特征，利用上述的特征来进行电力负荷的预测，具体讲解了利用BP神经网络、RNN、LSTM神经网络、组合的CNN-LSTM神经网络进行多特征电力负荷的预测，并最后进行对比。
一、多影响因素电力负荷数据分析 1.1、数据展示 关于多影响因素的电力负荷预测深度学习实验数据集如下所示：
具体数据可以去如下课程所获取，里面有理论到实战的讲解。
[多特征预测]基于BP神经网络多特征电力负荷预测
[多特征预测]基于RNN、LSTM多特征用电负荷预测
[多特征预测]基于CNN-LSTM网络多特征用电负荷预测
从数据的截图可以看出，该数据含有，干球温度、露点温度、湿球温度、湿度、电价和用电负荷数据；其中该数据是2006年到2010年，一共有5年的数据量。其中数据的采样点为半个小时采样一次，一天一共有48个采样点，除了2008年数据有17568个采样外，2006年、2007年、2009、2010年都为17520个采样点，因此数据一共有87648个采样点。
1.2、电力负荷和影响因素对比 从直观的角度来讲，天气因素和电价对用电量是有一定的关系的。因此将电力负荷和天气电价在一个图上绘制出；具体的图如下所示：
通过分析可以发现，不管是干球温度、露点温度还是湿球温度，它们随着时间的变化，其变化的趋势是及其相似的，因此可以判断他们之间存在着很强的相关性。通过观察电力负荷波形和温度数据的波形，发现当温度越高或者越低的时候，正是电力负荷数据越大的时候，因此可以判定温度数据和电力负荷数据之间存在着很强的相关性，温度的大小对电力负荷数据的大小的影响是很大的。进而观察湿度数据和电价数据，相对于温度数据，湿度数据观察不出明显的规律特征和周期特性。而电价数据除了某些时间段有很大的价格变动以外，没有明显的波动。从图中不能很明显的观察出湿度和电价对用电负荷有着很明显的影响。
1.3、分析电力负荷中的规律 如图为该数据2006年到2010年5年的每年的用电负荷曲线图。
从图2-6可以看出，2006年至2010年这5年期间，每年的的用电负荷趋势是大致相同的，呈现一定的周期性特性；每年的用电高峰大致都是在12月至2月、6月至8月，这很明显是和季节相关的。
为了对数据有个更加全面的了解和更深入的解析。选取每年4月份倒数第二周的周电力负荷数据。图所示，图中的电力负荷数据分别为2006年4月17日至23日、2007年4月16日至22日、2008年4月21日至27日、2009年4月20日至26日、2010年4月19日至25日一共5周的周电力负荷数据。
从图中可以看出每年的4月份倒数第二周的周电力负荷数据的趋势是及其相似的，尤其周六和周日的数据是很吻合的。而2006年4月17日和2008年4月25日的用电负荷相对其他年份的用电数据来说出现了明显的降低，但是用电的趋势是相似的。导致该曲线特性的原理可能是由于电力数据是有一定的随机性和外部的多种影响因素相关，不同年份的同一月的同一个星期的用电负荷曲线可能因为当时天气的异常、停电等一系列的外部原因导致有一定的差异。虽然不同的年份的周电力负荷数据有一定的差异，但是从中也可以得出共有的规律；不管是哪个年份，一周的数据呈现很明显的周期性变化，一周的波形近似于正弦波，这很显然和人们的生活作息是相关的，人们在夜间休息的时候用电量急剧下滑，导致用电在夜间处于一个很低的数值，而在白天要维持工作和生活又要消耗大量的电力能源，因此电力的消耗随着人们的休息完毕呈现一个急剧上升的一个状态；反反复复呈现一个周期循环的一个状态。
从上述的分析可以得出一个基本的的结论，天气影响因素对用电量是用一定的影响因素的，同时电力负荷数据又是一个典型的时间序列数据，因为数据不断呈现周期性的变化，该变化和人们的生活作息有着很强的相关性；因此前面时刻的用电数据对后续用电是有着一定的影响的，这是时间序列数据典型的特征。
本文的多特征电力负荷预测实验数据是半个小时一个采样点，也就是一天将会采样48个点。由于前面分析过电力负荷数据是随着人的作息而成周期性变化的，同时还有天气和电价等因素对其产生影响；因而在多特征电力负荷预测中取前面48个采样点中的天气因素、电价、负荷数据作为模型的输入特征来预测第49个采样点的电力负荷数据；以此为规律不断的滚动下去。
二、基于BP神经网络多特征电力负荷预测 2.1、BP神经网络模型应用于多特征电力负荷预测 现在回到多特征电力负荷预测任务上来，从任务的本质上来说，多特征电力负荷预测本质上还是一个回归预测任务，只不过在神经网络输入上相对于单特征电力负荷来说，输出中多了天气影响因素、电价影响因素；就神经网络搭建来说，网络的搭建变化不大，同时在现在深度学习框架发展成熟的情况下，搭建网络就变成一个很简单的事情了；但是相对于单特征电力负荷预测，数据处理，构建成BP神经网络可以学习的数据格式要稍稍复杂一点。
我一直认为对于初学者来说，利用深度学习来训练一个自己任务的网络模型有两点比较复杂；第一点就是环境的搭建、第二点就是数据处理，因此在我的课程中有很详细的手把手教学，大家可以看看。
[多特征预测]基于BP神经网络多特征电力负荷预测
[多特征预测]基于RNN、LSTM多特征用电负荷预测
[多特征预测]基于CNN-LSTM网络多特征用电负荷预测
下面我们整体看看BP神经网络怎么利用多特征电力负荷数据进行电力负荷预测任务的。和前面单特征电力负荷预测一样，BP神经网络模型的结构如下所示：
从上面的图分析可以发现，相对于单特征负荷预测模型来说，他们之间唯一的不同就是，输入数据的不同，单特征的输入数据只有前面采样点的电力负荷数据，而多特征电力负荷预测的输入数据为前面采样点中含有对电力负荷影响因素和电力负荷数据；他们最终的预测值为电力负荷值；因此这两个模型在电力负荷数据处理上有着显然的不同，这也是电力负荷预测模型的难点之一。
2.2、 数据预处理与数据集划分 如下是电力负荷预测数据集的预处理与划分部分：
# 进行数据归一化，将数据归一化到0-1之间 scaler = MinMaxScaler(feature_range=(0, 1)) train = scaler.fit_transform(train) val = scaler.fit_transform(val) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edc4318ecc0fc9fcf25161ed3f21874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274ffb21e575ea1a3e46451034ab3a0a/" rel="bookmark">
			npm 使用简介及 package.json 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm 简介 全称：Node Package Manager
npm 是随同 NodeJS 一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。
使用 npm 命令安装模块 $ npm install &lt;Module Name&gt;	// 本地安装 $ npm install &lt;Module Name&gt;	-g	// 全局安装 package.json 记录项目名称、版本号、项目描述，以及列出当前项目所依赖的其他库的信息和依赖库的版本号。
如何生成 package.json 文件 $ npm init // 或者 $ npm init --yes // 基本内容如下 { "name": "Hello world", "version": "1.0.0", "description": "My first project", "repository": "...", "author": "xxx@gmail.com", "license": "UNLICENSED", "private": true, } //private 字段可以声明当前项目是否是私有的，为 true 则 npm 不能发布它 package.json 常用属性说明 scripts scripts属性用于配置一些脚本命令，以键值对的形式存在配置后通过 npm run 的 key 来执行这个命令对于常用的 start、test、stop、restart 可以省略掉 run 直接通过 npm start 等方式运行 dependencies、devDependencies 和 peerDependencies 的区别 dependencies 是指无论开发环境还是生产环境都需要依赖的包。通常是我们项目实际开发要用到的一些库，如 react、react-dom、react-redux、axios 等。devDependencies 只包含用在 dev 和 test 环境上的包。一些包在生产环境是不需要的，如 webpack、babel 等。如：通过 npm install webpack --save-dev（或-D），安装到 devDependencies。peerDependencies 对等依赖。就是你依赖的一个包，它必须是以另外一个宿主包为前提的；比如 element-plus 是依赖于 vue3 的，ant design是依赖于 react、react-dom； engines 用于指定 Node 和 NPM 的版本号（安装时会检查对应的引擎版本，不符合报错）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274ffb21e575ea1a3e46451034ab3a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d8e8561149fc64a9bb2c094167a33b/" rel="bookmark">
			动态规划——01背包问题（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述： 解题思路： 整体思路： 利用动态规划，其目的就是将原问题分解成几个子问题，通过求解简单的子问题，把原问题给解决，就比如斐波那契数列方程：
f[i]=f[i-1]+f[i-2];
动态规划的核心就是找到原问题与子问题的关系，并列出动态转移方程。
实现方法： 这里我们可以定义一个二维数组，dp[i][j]表示对于背包容量为j的背包，前i个物品的最优解，即最大价值。
对于一个物品，可以分两种情况：
不选：对于dp[i][j]，不选第i个物品时，dp[i][j]的最优解就是dp[i-1][j]的最优解
选：如果选择，我们就让背包容量减去第i件的物品体积，让dp加上物品价值，即dp[i][j]=dp[i-1][j-v[i]]+w[i];
这样我们就得到了状态转移方程，如果要计算对于前N个物品背包容量为V的背包的最优解，只需要一层一层往前推，通过前面的子问题，求得最终答案。
状态转移方程: dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);
代码和注释： #include &lt;iostream&gt; using namespace std; int dp[1010][1010]; int v[1010],w[1010];//体积和价值 int main(){ int N,V; int i,j; //输入数据 cin&gt;&gt;N&gt;&gt;V;//商品个数和背包容量 for(i=1;i&lt;=N;i++) { cin&gt;&gt;v[i]&gt;&gt;w[i];//体积和价值 } for(i=1;i&lt;=N;i++)//依次遍历从第1个物品到第N个物品 { for(j=1;j&lt;=V;j++)//依次遍历从0~背包容量V { if(j&lt;v[i])//如果背包容量小于物品体积 { dp[i][j]=dp[i-1][j];//最优解就是上一个物品时的最优解 } else//否则就是背包容量大于等于物品体积 { dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);//拿或者不拿，选最优 } } } cout&lt;&lt;dp[N][V]&lt;&lt;endl;//输出前N个商品,背包容量为V的最优解 return 0; } 参考自：https://blog.csdn.net/q1411687596/article/details/104827473
完结，撒花撒花… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab071b32bb4f0cbec8a497b2edad8513/" rel="bookmark">
			Radeon Software：Host Application，CPU占用率过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：待机状态下，电脑消耗电量很快，跟正常使用的电量消耗几乎相当，且电脑风扇一直在转
解决过程：不打开任何软件的情况下，打开任务管理器里看到，Radeon Software：Host Application CPU占用率很高；且每次开机都会自启动。
解决办法：找到“我的电脑/视频/”文件夹，在该目录下新建文件夹“Radeon Relive”，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce92759b3ce42a9f79f1fa1be66c72c/" rel="bookmark">
			判断数据类型是否为数组（对象）的六种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js一共有六大数据类型：number、string、object、Boolean、null、undefined。 1、typeof( ) const a=[] console.log(typeof(a)) const b={} console.log(typeof(b)) const c='好好学习！' console.log(typeof(c)) const d=false console.log(typeof(d)) ⚠️ null、对象、数组返回的都是object类型；对于函数类型返回的则是function。
⚠️ 数组是属于Object类型的，也就是引用类型，所以不能使用typeof判断其具体类型！
2、isArray( ) Array.isArray(obj) //obj--需要检测的数据 返回值： 如果值是 Array，则为true; 否则为false。 3.instanceof object instanceof constructor instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。
例如：
const a = []; const b = {}; console.log(a instanceof Array); true console.log(a instanceof Object); true console.log(b instanceof Array); false 4.constructor console.log([].constructor == Array); //true console.log({}.constructor == Object); //true console.log("string".constructor == String); //true console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce92759b3ce42a9f79f1fa1be66c72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3ced157535b0c9fec85dd2d52f2efe/" rel="bookmark">
			以太网通信简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、以太网简介 以太网（Ethernet）是当今最通用的通信协议标准，他规定了包括物理层的连线、电子信号、介质访问协议的内容。
优点：成本低、通信速率高、抗干扰性强
标准以太网：10Mbit/S 快速以太网：100Mbit/S 千兆以太网：1000Mbit/S 1.1、以太网接口 引脚编号引脚名称说明Pin1TX+发送数据+ （发送差分信号：+）Pin2TX-发送数据- （发送差分信号：-）Pin3RX+接收信号+ （接收差分信号：+）Pin4NC未使用Pin5NC未使用Pin6RX-接收信号- （接收差分信号：-）Pin7NC未使用Pin8NC未使用 1.2、PHY芯片 PHY芯片在发送数据时，首先将MAC（主机：单片机或者FPGA）发送过来的并行数据转化成串行数据，按照物理层的编码规则把数据编码转换为模拟信号，通过网口发送出去。
PHY芯片在接收数据时，首先将网络上（RJ45接口）发送过来的模拟信号转化成数据，再通过通信协议（MII、RMII、SMI）发送给MAC（主机单片机或者FPGA）。
当网卡接入网线时，PHY芯片不断发出脉冲信号来检测对端是否有设备，他们互相协商并确定连接速度、双工模式、是否采用流控制等，这个过程叫做“自动协商”。
总结：PHY芯片在网络通信中的作用是：主芯片 和网络设备 之间的 模拟信号 与 数字信号 的相互转换。
1.3、MII接口 MII即媒体独立接口，也叫介质无关接口。它是IEEE-802.3定义的以太网行业标准。它包括一个数据接口，以及一个MAC和PHY之间的管理接口。
名称说明ETH_RXC该信号提供进行RX（主芯片接收）数据传输时的参考时序ETH_RXDVRX（主芯片接收）数据有效信号ETH_RXD[3:0] 数据接收信号。该信号是 4 个一组的数据信号，由 PHY 同步驱动，在MII_RXDV 信号有效时才为有效信号（有效数据）。MII_RXD[0] 为最低有效位，
MII_RXD[3] 为最高有效位。
当 MII_RX_DV 禁止、MII_RX_ER 使能时，特定的MII_RXD[3:0] 值用于传输来自 PHY 的特定信息。
ETH_TXC该信号由主芯片提供，是主芯片TX发送数据传输时的参考时序ETH_TXEN发送数据使能信号ETH_RXD[3:0] 数据发送信号。该信号是 4 个一组的数据信号，由 MAC 子层同步驱动，在MII_TXEN 信号有效时才为有效信号（有效数据）
MII_TXD[0] 为最低有效位
MII_TXD[3] 为最高有效位。
禁止MII_TXEN 时，发送数据不会对 PHY 产生任何影响
ETH_RESETPHY芯片复位信号ETH _MDC 数据线，数据输入/输出比特流，用于通过MDC 时钟信号向/从PHY 设备同步传输状态信息。
（主芯片访问PHY芯片寄存器的接口）
ETH _MDIO 时钟线，周期性时钟，提供以最大频率2.5 MHz 传输数据时的参考时序。
MDC的最短高电平时间和最短低电平时间必须均为160 ns。MDC的最小周期必须为400 ns。在空闲状态下，SMI管理接口将 MDC时钟信号驱动为低电平。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3ced157535b0c9fec85dd2d52f2efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a4b4ddd188006522057c2b660cf8a9/" rel="bookmark">
			jquery明明正常引用但是还是报404错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery明明正常引用但是还是报404错误 引入jquery才能使用 $ 这个语法来进行代码的编写
但是当你正确的引入jquery库后，测试发现控制台一直显示 $ 未定义时，或者控制台报jquery 404的错误，这个时候不是我们的代码哪里出现了错误，而是因为你在引入jquery库的时候，没有重新rebuild你的项目
&lt;script type="text/javascript" src="js/jquery-3.4.1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function (){ alert("1111111111") }) &lt;/script&gt; 报错情况：
遇上以上这些问题我们需要重新rebuild你的项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb45eb419f68f7e2be9e2288ed20b1a/" rel="bookmark">
			C#控制明美显微镜，IntPtr转 Bitmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static bool CopyMenImage(ref dvpFrame frame, IntPtr buff, out Bitmap dst)
{
try
{
PixelFormat pixeFormat = PixelFormat.Format24bppRgb;
switch (frame.format)
{
case dvpImageFormat.FORMAT_BGR24:
pixeFormat = PixelFormat.Format24bppRgb;
break;
case dvpImageFormat.FORMAT_BGR32:
pixeFormat = PixelFormat.Format32bppRgb;
break;
case dvpImageFormat.FORMAT_BGR48:
pixeFormat = PixelFormat.Format48bppRgb;
break;
default:
throw new Exception("该方法未实现 " + frame.format + " 目标图像格式的转换, 请设置工业相机目标图像格式为 BGR24/BGR32/BGR48 格式!");
}
byte[] bBuff = new byte[frame.uBytes];
dst = new Bitmap(frame.iWidth, frame.iHeight, pixeFormat);
BitmapData bmpData = dst.LockBits(new Rectangle(0, 0, dst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb45eb419f68f7e2be9e2288ed20b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8150b1a8a21f5176498901ff15571286/" rel="bookmark">
			使用过的moment对象的用法（至2022/11/03）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 初始化一个moment对象 moment(String|Moment|Date, format) // e.g. moment('19', 'HH') moment(new Date(), 'yyyy-MM-dd') // 字符串转moment对象 moment('2022-11-3 13:12:23', 'YYYY-MM-DD HH:mm:ss') 2. moment对象转字符串(格式化) moment().format() moment().format('YYYY-MM-DD') 3. moment对象转时间戳 moment().valueOf() 4. moment对象的取值 moment.year() // 年份 moment.month() // 月份 moment.date() // 日 moment.hour() // 小时 moment.minute() // 分钟 moment.second() // 秒 5. 比较两个moment对象是否相同 moment.isSame(Moment,String) // e.g. moment('2010-10-20').isSame('2009-12-31', 'year'); // false moment('2010-01-01').isSame('2010-02-01', 'day'); // false, 不同的月份 moment('2010-01-01').isSame('2010-01-01', 'day'); // true 6. 今天之后的日期 // 禁用当天之后的日期 disabledDate(current) { return current &amp;&amp; current &gt; moment().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8150b1a8a21f5176498901ff15571286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ac0035655d75d816e40717f6e792f6/" rel="bookmark">
			软件测试技能，JMeter压力测试教程，Plugins Manager插件管理器（十三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、插件管理器Plugins Manager二、查看插件管理三、解决报错四、插件管理 前言 前面讲了JDBC连接数据库的时候，需下载mysql对应的jar包，放到lib\ext目录下就可以使用了
jmeter 有个插件管理器Plugins Manager，可以方便的管理其他插件的下载和更新
一、插件管理器Plugins Manager 下载地址：https://jmeter-plugins.org/install/Install/
下载插件后把jar包放到 lib/ext 目录，然后重启jmeter
二、查看插件管理 重启jmeter后打开选项-Plugins Manager
出现报错
Failed to download plugins repository. One of the possible reasons is that you have proxy requirement for Internet connection.
Please read the instructions on this page: https://jmeter-plugins.org/wiki/PluginsManagerNetworkConfiguration/
解决文档地址：https://jmeter-plugins.org/wiki/PluginsManagerNetworkConfiguration/
三、解决报错 解决办法：
下载jmeter PluginsManager证书，使用chrome打开如下地址 https://jmeter-plugins.org/ 选择安全证书
证书-详细信息-复制到文件-下一步-使用Base64 编码格式
报错文件名称为 pluginsManager.cer
以管理员身份打开cmd,进入到jdk安装目录，找到jre的bin目录下
执行以下指令,我的cer证书地址C:\Users\dell\Desktop\PluginsManager.cer
.\keytool.exe -import -alias JMeter -keystore ..\lib\security\cacerts -file "C:\Users\dell\Desktop\PluginsManager.cer" 输入口令：changeit
是否信任此证书? [否]: y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66ac0035655d75d816e40717f6e792f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84ff8456c0d7d2b438a456ae9f97c8f/" rel="bookmark">
			随机的颜色，一秒钟切换一个颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;随机产生颜色&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; border-radius:50%; left: 0; right:0; top:0; bottom: 0; margin: auto; position: absolute; } &lt;/style&gt; &lt;script&gt; function getColor() { var str = "#"; //定义一个十六进制的值的数组 let arr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]; // 遍历循环产生 6 个数 for (var i = 0; i &lt; 6; i++) { //随机产生 0~15 的个索引数,然后根据该索引找到数组中对应的值,拼接到一起 let lut = parseInt(Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84ff8456c0d7d2b438a456ae9f97c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207150d023823a485ea693500d98ad36/" rel="bookmark">
			全屏了却判断为未全屏（已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看这种方法 function isFullScreen () { var isFull = false; if (document.fullscreenEnabled || document.msFullscreenEnabled ) { isFull = window.fullScreen || document.webkitIsFullScreen; if (isFull === undefined) { isFull = false; } } return isFull 或者
function isFullScreen () { return document. isFullScreen || document. mozIsFullScreen || document. webkitIsFullScre } 以上的方法如果没有用（意思是明明全屏了函数却返回false
那么请看以下解决方案
…
function isFullscreen () { const screen = window.screen const body = document.body.getBoundingClientRect() return screen.height === body.height &amp;&amp; screen.width === body.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/207150d023823a485ea693500d98ad36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ed1bd425dfc1649af768d969443cfc/" rel="bookmark">
			ResNeXt、DenseNet、CSPNet网络模型总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源代码：https://github.com/xxcheng0708/Pytorch_Image_Classifier_Template ResNeXt 在网络架构设计层面，常见的几种提升网络性能的方法：
网络的宽度width：每层卷积的输出通道数网络的深度depth：网络的层数网络的分辨率resolution：输入图像的分辨率大小网络的增长率growth：随着层数的增加，每层卷积输出通道数的增长比例网络的特征复用：如DenseNet可以使用更浅的网络，更少的参数，提升特征复用，达到与深度网络相当的性能高效特征融合：InceptionNet的split-transforms-merge模式，将输入分别使用不同的转换分支提取特征，然后将多个分支的结果进行合并实现特征融合 ResNeXT借鉴了VGGNet、ResNet中连续堆叠多个相同或相似block的特性，以及借鉴InceptionNet中split-transforms-merge对特征进行高效融合的特性。
如上图所示，右图在卷积核的大小，以及输出通道数量上做了设计，使得左右两种结构在参数量和浮点运算量方面相当。右图中，将原本ResNet中的一条分支扩展程32条分支，并且每条分支是完全相同的，最后将各分支的输出结果相加（有点Transformer里面的Multi-Head Attention那味了，只不过Multi-Head Attention是将多个结果进行concat）。上右图的网络结构与下图网络结构是等价的：
ResNeXt网络在每个分支中使用了bottleneck的结构，也就是先使用1x1卷积进行降维，减少特征图的通道数，然后再进行分组卷积等提取体征，最后再使用1x1卷积进行升维，还原特征图的通道数。ResNeXt中每个block可以表示如下：
C代表block中分支的数量，T_i代表每个分支的子网络，x表示short-cut连接。
基数cardinality：在ResNeXt中，将上述block中的分支数量称作基数，并且认为基数和网络的宽度width、深度depth同等重要，这一点在DenseNet网络中也可以看出，DenseNet是将基数发挥到极致。
ResNeXt涉及的相关工作及概念
多分支卷积网络：ResNeXt中使用了多分支的子网络进行特征融合
分组卷积：ResNeXt中，使用分组卷积来控制网络的参数量和浮点计算量
压缩卷积网络：不同于常见的以损失模型精度为代价的压缩方法，ResNeXt使用多分支的分组卷积等操作，在控制模型参数量和浮点计算量的前提下，还能进一步提升模型的表达能力
集成算法：由于使用了多分支的子网络进行特征融合，这种操作类似于集成学习方法，不同于集成学习方法的是，ResNeXt中各个分支是完全相同的
ResNeXt与Inception-ResNet的关系
ResNeXt中block的每个分支是完全相同的结构，不需要进行特殊的设计，在Inception-ResNet中，block的每个分支是不同的，经过精心设计的。并且，在ResNeXt中，各个分支的结果使用加法进行合并。
ResNet50与ResNeXt50网络模型对比：
上表中的ResNeXt在block内部采用的是分组卷积的方式来实现多分支处理。其中，C=32表示在block中有32个分支或者32组分组卷积，d=4表示在block中的每个分支处理4个通道的输入数据，或者说每个分组卷积处理4个通道的输入。
Pytorch版本中ResNeXt的block结构如下：
可以看到，在128 x 4 x 3 x3卷积部分，将128个通道的输入分成了32组，每组处理4个通道，每组输出4个通道，然后将32组的输出结果concat得到输出的128个通道。
DenseNet 鉴于ResNet等网络使用shot-cut来实现特征的融合，以及缓解梯度消失问题，DenseNet将这种shot-cut的思想发挥到极致，将网络每个Block中前面层所有分辨率相同的feature map进行融合，而不仅仅只融合上一层的feature map，所以DenseNet每个Block中网络层级之间具有L * (L + 1)/2个连接，所以网络起名叫DenseNet。并且，不同于ResNet的shot-cut采用加法运算，DenseNet采用concat进行feature map的连接。用公式表示如下：
DenseNet中，第i层的输入与第i层的输出做concat，作为第i+1层的输入，这就要求输入和输出的分辨率保持不变，就是不做下采样操作，下采样操作在transition层进行。
像上图这样，每一层都可以利用全面所有层学习得到的结果，在使用同样参数量的情况下，特征的重复利用率更高，不需要再进行重复的特征学习。同样的，这种密集连接方式也有利于网络的训练。
DenseNet的网络结构如下：
DenseNet包含以下模块：
Block模块：DenseNet将整个网络划分成多个Block，每个Block里面包含多个conv+BN+Relu的操作，Block内部不做下采样操作（包括卷积下采样和池化下次采样），并且对卷积操作做padding填充，所以这些操作输出相同分辨率大小的feature map，所以在每个Block内部各层的feature map是可以进行concat融合的，在Block模块内部，设置每个卷积层的卷积核数量k，叫做Growth Rate，每层卷积的输入通道为前面所有层的通道数求和 ，输出通道数为k
转换模块：在Block之间的层叫做转换层，转换层使用conv+BN+max pooling完成下采样操作。
瓶颈层Neck：为了进一步提升每个Block模块中卷积操作的效率，在进行每次conv+BN+Relu之前，使用1x1卷积先将输入的feature map在通道维度上进行降维，将原本通道数为 的输入特征图的通道数减少到4k，然后在此基础上进行conv+BN+Relu操作。使用瓶颈层的DenseNet叫做DenseNet-B
通道压缩模块：为了继续降低计算量，提升速度，原本的转换模块使用conv+BN+max pooling完成下采样操作，降低feature map的分辨率大小，在压缩模块，进一步对feature map的通道数进行压缩，假设原本的通道数为m，经过压缩之后的通道数变为 ， 。使用通道压缩的DenseNet叫做DenseNet-C。同时使用瓶颈层和压缩层的叫做DenseNet-BC。
Pytorch版本中DenseNet的部分dense block结构如下： 真是将Dense发挥到极致！！！
CSPNet 【CSPNet 解读】一种增强CNN学习能力的新型骨干网络_AI 菌的博客-CSDN博客_csp net有什么用 以DenseNet为例，DenseNet中，后面层的输入是前面层的输出做concat之后得到的，如下：
在使用后向传播更新参数时，后面层会包含前面层的梯度，如下：
其中f代表参数更新函数，g表示每一层的梯度，可以看出由于后面层的输入中包含前面层的输出，所以后面层计算的梯度也会包含前面层的梯度。这种就导致了梯度计算的重复，对此进行优化可以对模型进一步加速，因此，此种优化方式适用于使用short-cut的网络，比如DenseNet，ResNet, ResNeXt等。
CSPNet思想
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ed1bd425dfc1649af768d969443cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f6ddaefc96e0684a2014474f7fb7fe/" rel="bookmark">
			java学习笔记【1】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis-plus mybatis-plus实现自动填充 /** * 实现自动填充 * 1.在数据库中添加要自动填充的对象 * 2.在实体类中定义属性名并标注@TableField(file=FieldFill.INSERT/FieldFill.INSERT_UPDATE) * 3.创建处理类并实现MetaObjectHandle接口,调用setFieldValByName()方法实现自动填充 */ @Component public class MyFieldFillHandle implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { this.setFieldValByName("createTime", new Date(), metaObject); } @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName("updateTime", new Date(), metaObject); } 主键生成策略/驼峰命名法（mp默认已开启） @Data public class User { // 主键生成策略 @TableId(type = IdType.AUTO) private Integer id; @TableField("NAME") private String name; private Integer age; private String email; @Version private Integer version; // 自动填充 @TableField(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f6ddaefc96e0684a2014474f7fb7fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fda460725d8c491968827b983ea692a/" rel="bookmark">
			Openstack云平台脚本部署之计算节点服务配置（十五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
二、部署脚本
三、参考文档
四、源码
五、系列文章
一、简介 计算节点上服务配置相对于控制节点和网络节点来说比较简单，很多都是配置Openstack服务客户端，这里主要进行集成Ceph的配置，并配置Openstack的nova、neutron、ceilometer的客户端，具体不再赘述，配置内容参考脚本及文档。
二、部署脚本 脚本部署比较简单，操作在控制节点进行，首先执行 install-configure-ceph-auth-client-key.sh进行集成Ceph操作（这个步骤会在控制节点和计算节点配置），完成认证配置，然后再执行脚本install-configure-compute-nodes-services.sh，完成Openstack计算节点上服务配置。
集成Ceph，添加Ceph认证授权，脚本 install-configure-ceph-auth-client-key.sh如下：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
#!/bin/sh
. ../0-set-config.sh
./style/print-split.sh "Ceph Authentication Installation"
###复制ceph配置文件 glance-api, cinder-volume, nova-compute and cinder-backup的主机名,由于存储和计算在同一个节点，不需要复制到自身
./pssh-exe C "mkdir -p /etc/ceph/"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fda460725d8c491968827b983ea692a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed618bd3cf28a57c6152af89123128a/" rel="bookmark">
			Yolov5（6.1）学习历险记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
YOLO系列总体构架：
CBS模块
torch.nn.Conv2d:对由多个输入平面组成的输入信号进行二维卷积。
Batch Normalization 归一化处理
SiLu（Swish）激活函数
C3模块
Bottleneck：瓶颈层
SPPF（快速空间金字塔池化）
SPP：
nn.MaxPool2d:最大池化操作 SPPF ：
YOLO系列总体构架： 对应到YOLOV5中，具体backbone构架如下：
CBS模块 首先CBS模块在common.py中定义为Class Conv：
class Conv(nn.Module): # Standard convolution def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True): # ch_in, ch_out, kernel, stride, padding, groups super().__init__() self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p), groups=g, bias=False) self.bn = nn.BatchNorm2d(c2) self.act = nn.SiLU() if act is True else (act if isinstance(act, nn.Module) else nn.Identity()) def forward(self, x): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed618bd3cf28a57c6152af89123128a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4835ecfe732ad0bd830535e333a7dea5/" rel="bookmark">
			bootstrap5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bootstrap5 文章目录 bootstrap5介绍下载 常用属性基础使用第一个demo移动设备优先 容器类**.container** 类.container-fluid类容器内边距容器的边框和颜色响应式容器 网格系统偏移列 文字排版**Bootstrap 5 默认设置**\&lt;h1&gt; - \&lt;h6&gt;\&lt;mark&gt;\&lt;blockquote&gt;\&lt;code&gt;\&lt;kbd&gt;**.list-inline** 颜色表格条纹表格带边框表格鼠标悬停状态表格黑色背景表格无边框表格指定意义的颜色类较小的表格响应式表格 图像形状圆角图片椭圆图片缩略图图片对齐方式图片居中响应式图片 好使小工具背景颜色浮动与清除浮动居中对齐浮动与清除浮动居中对齐 图片为本地图片，未加载出来，需要可联系我 Bootstrap v5 中文文档 · Bootstrap 是最受欢迎的 HTML、CSS 和 JavaScript 框架，用于开发响应式布局、移动设备优先的 WEB 项目。 | Bootstrap 中文网 (bootcss.com)
介绍 Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。
Bootstrap5 目前是 Bootstrap 的最新版本，是一套用于 HTML、CSS 和 JS 开发的开源工具集。它支持 Sass 变量和 mixins、响应式网格系统、大量的预建组件和强大的 JavaScript 插件，助你快速设计和自定义响应式、移动设备优先的站点
**容易上手：**只要对 HTML 和 CSS 有基本了解的人都可以很快速的使用 Bootstrap。**响应式设计：**Bootstrap 可以根据不同平台（手机、平板电脑和台式机）进行调整。**移动优先：**在 Bootstrap 中，自适应移动端是框架的核心部分。**浏览器兼容性：**Bootstrap5 兼容所有主流浏览器（Chrome、Firefox、Edge、Safari 和 Opera）。 如果您需要支持 IE11 及以下版本，请使用 Bootstrap4 或 Bootstrap3。 下载 两种方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4835ecfe732ad0bd830535e333a7dea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37b4261717982fa28dd754b6da8482d/" rel="bookmark">
			面向对象（四）es6中的类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前都是在es5中创建类的方法，而在es6中为我们提供了更为简单的语法糖供我们创建类，不过其底层还是和之前的原型、原型链相关，所以学习一下还是有必要的，那现在就来看看再es6中我们怎样创建类吧
创建类 class是es6提供给我们创建类的关键字，这样就能和函数有很好的区别了。如果我们要创建一个Person类，方式如下
class Person {} 不过现在也只是定义了一个类而已，这个类中并不包含属性或方法，接下来就看看如何去声明属性与方法
constructor 每一个由class声明的类，都会具有一个构造函数方法constructor，当我们通过new关键字去实例化这个类时，实际上就是调用的该构造函数，之后做的操作就和new一个function创建的对象差不多了，所以在该constructor可以通过this创建属性，并且new操作时，传入的值也会拿到
不写的话默认也会有一个constructor
class Person { constructor(name, age) { this.age = age this.name = name } } const p = new Person("sakurige", 111) 这里的属性都是，外界可以直接访问的，而在es13中，可以在属性前加上一个#使其变为私有属性，外界只能通过getter``setter进行访问
class Person { #name constructor(name, age) { this.age = age this.name = name } get name(){ return this.#name } set name(newName){ this.#name = newName } } const p = new Person("sakurige", 111) console.log(p.#name) // 报错 实例方法 实例方法在之前是挂载到，构造函数的原型上的，这里直接在class中写入方法，就会直接挂载到原型上，所以方法直接写在里面即可
class Person { constructor(name, age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a37b4261717982fa28dd754b6da8482d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a9cb5ba67ad362479720ff53bf8ce8/" rel="bookmark">
			Vue框架背后的故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Vue萌芽Vue名字的由来因着Vue免试进入MeteorVue逐步完善Taylor推荐VueVue因受质疑发布1.0LinusBorg加入萌生全职做Vue想法Vue在恰到好处的时机出现探索经济来源Serah Drasner加入全职投入Vue建设Vue引入国内Vue受拥国内Vue在决策背景方面的独有优势总结本期推荐 前言 Vue框架作为当前主流的前端框架之一，作者尤雨溪更是国内开发者心中男神，作为开发工程师你是否知道Vue框架名字的由来？你是否知道Vue框架作者尤大大创作Vue过程中的几个节点？今天就来带领大家深入Vue背后的故事
Vue萌芽 其实尤大大最初专业为室内艺术，并非计算机，但是尤大大在后面到帕森斯设计学院进修艺术研究硕士学位，学习的是科技与设计项目，它涵盖了编程、设计和新媒体艺术，也正是在这个时候尤大大自学了JavaScript，开始用JavaScript进行创作，毕业后就进入了谷歌，尤大大为谷歌浏览器开发了一些实验性的互动场景，把它们放到了作品集中，尤大大在采访中提到曾在学校期间开发了一个克隆版的Clear应用，它是一个有着很新颖的手势操作的待办事项应用程序，它应该算是“滑动来完成”手势操作的开拓者了，所以就在网页上重置了他的大部分功能，它在黑客新闻（Hacker News）上火了起来，被很多网站报道了，这件事让谷歌的招聘官注意到了尤大大，那时候谷歌有很多为谷歌浏览器开发的实验性场景，包括一些3D动效、2D的物理效果和可视化的处理等，都是尤大大他们在用的浏览器上实现的，这在当时是前所未有的，它真的体现了JavaScript的强大，不知什么缘故尤大大就接到了谷歌招聘官的电话她说，你有兴趣加入我们的创新实验室吗，作为我们招收的五人之一，尤大大当时真的不敢相信，都没给他们发我的简历就直接有人给打电话让加入谷歌，那肯定是要去的，尤大大非常高兴，自己不用也搬家，工作场地就在纽约；
尤大大聊出这段经历：“工作两年多，做一些有意思和实验性的项目，稀奇古怪的点子，比如说，十年后的搜索界面是什么样子的，或者如果整面墙都是可以互动屏幕的会怎样？如果谷歌能够听懂你说的每一句话？讽刺的是这件事现在几乎已经成为现实了，我们要做出一些关于这方面的概念视频和这种交互操作的原型，在2012年。在很长的一段时间内，我都在用原生的JavaScript来手写这些原型，因为这些原型不会使用传统的UI界面，他们需要很多特殊的处理，这些处理手段在如今普通的应用中很难见到，我尝试着去用一些现有的框架进行开发，但是很多时候我发现他们不能解决我的问题，我使用的第一个框架是Backbone，Backbone更像是一个为应用搭建的结构，他不会帮助你控制视图，尽管Angular提供了数据绑定，能将视图和数据状态同步起来，但它太约束你写代码的方式，所以它也不能很好的处理我正在进行的工作项目，因为这些项目很注重交互而不是如何成为一个完整的应用程序，我开始思考如何才能让我的工作变得更高效，就在那时我开始想或许我可以自己开发一个我自己的框架，最初我的目标就是开发一个非常简单专一的工具，仅仅就是同步DOM和一些JavaScript对象，这是最初的想法，在这个初始项目有了一点人气之后，我们开始扩大开发范围，一点点加入一些新功能到这个生态环境中去，最终使他变成了一个框架。”
Vue名字的由来 尤大大对Vue.js进行的首次提交是在2013年的6月份，它刚开始的名字是Seed.js，据尤大大说当时想不到一个更好的名字，但是当尤大大要在NPM上发布的时候，发现Seed.js在NPM上已经被占用了，所以只能再想一个，尤大大表述：“我觉得，这是一个视图（View）的框架，但是就叫他View的话有点太直接了，所以我就把“View”放到谷歌翻译里面，然后我找到了它法语的翻译——vue，只有三个字母，看起来很好，也没有在NPM上被占用，所以我就用了这个名字。”
因着Vue免试进入Meteor 尤大大自述：“我基本上就是为我自己创建的这个框架，所以我的期望是，我希望，开发出一个我自己喜欢的框架，这也是我为什么要做这个框架的原因，我当然还在谷歌创意实验室工作，所以我把它发布成了我的私人项目，应该有几百名用户，我觉的有几百个GitHub的星星，给了我很多初始用户。”
你有没有想过你会通过这个赚到钱？尤大大：“完全没想到，当我出版的时候，并不是真的在说我想将其发布为一个可持续的项目，就像一个音乐爱好者为了乐趣而做一个专辑，你知道那种感觉不是为了赚钱，你发布这个音乐，只是因为你享受创作它的过程，并且你希望其他人能听到它，所以开发Vue.js的过程就像是一个途径像是我在做一个人们在真实世界中真的会用到的东西，相比我在谷歌创意实验室的工作来说，我们把做的东西给经理们看，但谁知道这个东西什么时候会变成现实呢（这里主要的意思是在谷歌中想法的出现到真正的落地的周期都是不确定的，甚至都不知道能否落地）所以我有一种冲动，要开发一个人们真正会用到的东西，我当时并没有想那么多，但有一个热门的开源项目会帮助找到下一个工作，这就是我加入Meteor的方式，他们基本上很倾佩我在Vue上做出的工作，所以他们直接跳过了面试的过程，当场就给了我工作，所以我很高兴，这才是你进行开源项目工作获得的真正的好处之一；
Vue逐步完善 尤大大在Meteor工作的时候，仍然在持续的开发Vue.js，因为尤大大觉得它在那时就像自己的孩子一样，我们可以看到上面尤大大的提交记录，在Github上看到一个非常绿的图表，因为尤大大在每个周末都会完成很多提交，当时进行更多的工作也越来越有必要了，因为Vue的用户越来越多了，据尤大大表述Vue一直在成长所以会出现更多的问题，更多的Bug要被修复。
Taylor推荐Vue 就在那段时间，Taylor发了一条推特提到了Vue.js，那是2014年，Taylor Otwell 是Laravel的作者，Laravel是一个非常流行的PHP框架，大家都知道在2014年那段时间PHP火的一塌糊涂。
Taylor那天在推特上说：“目前自己在学习React，但是状态很迷惑，React很难，我正在学习Vue.js，因为它看起来很简单”，虽然看起来这不像是一个正式的对Vue的认可，他只是在说我正在学习Vue.js"，然后很多人开始问他：你觉得Vue怎么样，它好用吗？基本上在每一条回复中，他都说，没错，它很棒，这开始看起来像是一个对Vue公开的认可，然后所有的Laravel用户就会想，哇，如果Taylor喜欢Vue，那它肯定很好呀，所以我们也应该试一试，所以Vue就获得了很多来之Laravel社区的用户"
Taylor表述：“我当时在网上查找一个JavaScript框架来开发这个叫Laravel Spark的产品，它是一个快速开发脚手架，帮助你开发你自己的软件和服务体系，帮助人们启动他们自己的生意，就像我一样，我感觉到不知所措，我看了其他的框架，他们有复杂的编译流程，需要很多工具才能起步，我尝试了Vue.js发现你可以用Windows笔记本就能写出一个简单的网页应用你不需要其他的编译工具，仅仅需要添加一个CDN链接，写几句JavaScript，你的网页就跑起来了，对于我这个不是很熟悉JavaScript的人，至少可以说这么简单就可以实现那么多功能，真的让人耳目一新而且还不需要学习很多其他的工具，我记得我发布了一条推特说《我发现了这个很棒的新玩意叫Vue.js，像我一样的新手，都可以写出JavaScript应用程序，真的很令人惊叹》因此我们为Laravel Spark采用了Vue.js，最后产生了，你知道的，为Laravel带来了超过一百万美金收入，成千上万个用户搭建了他们自己的生意，所以这真是一件对Vue.js和Laravel都很棒的事情，帮助简化了不知道多少，使用Spark搭建的业务，都同时运用了Laravel和Vue.js”
Vue因受质疑发布1.0 上面说到的这些都发生在尤大大决定全职开发Vue.js之前，在那之前Vue.js还处于只是在前端社区中比较有名的阶段，尤大大还没想过要将它作为自己的全职工作，甚至是从中赚钱，直到尤大大学习到Taylor的做法之后，才知道Laravel是那么庞大，意识到或许自己真的能干点东西出来，但开始有人发起帖子和讨论说：“我到底该用哪个？我应该用Vue.js吗？”，你能看到的很多的回复都是：“不要用，因为它还是起步阶段”、“它不稳定，它仅仅由一个人维护着，天知道它什么时候就消失了”，尤大大想证明这些人是错误的，要让Vue.js变成一个V1.0版本的可生产的框架，所以尤大大花费了整个2015年的假期，用3个星期的时间把所有东西都开发好，更新文档，然后在2015年10月，尤大大发布了1.0版本；
LinusBorg加入 当时Vue.js刚刚发布了1.0版本，还不存在像今天这样的核心团队，只有大概三个人，他们都忙着弄好文档和修复Bug，在1.0发布之后，当时的论坛就像是一个荒地；LinusBorg 就到论坛里去回答很多的问题，在论坛里非常的活跃，LinusBorg 了解到很多。
LinusBorg自述：“ 人们在他们项目中遇到的问题，我都在我空闲时间里干这件事，持续了三到四个月之后，Evan了解到了这个情况，他就给我发了一个Slack邀请，之前我们从未交流过，我也没开启任何问题讨论，没提出合并请求，我没在代码上做出任何贡献，但我从一开始就注意到Vue.js框架不仅是正确的编码，不仅是一个库，还需要一个描述它工作原理的文档，帮助你解决问题，它应该是我们需要的能想到的最好的文档，我们必须要扎身到社区中去，我们需要额外的工具和支持，这就是我被邀请到Vue团队的原因，因为我慢慢成长为社区领袖，我也确实加入到了Vue的核心团队，即便在没有对代码和内容作出贡献的情况下，不过之后我为了我所谓的自尊心，我学习了源码，研究了一些代码库，看了一些问题，然后开始四处作出一些贡献”。
萌生全职做Vue想法 尤大大自述：“我认为在1.0版本之后，我开始尝试着进行全职工作，或者这个东西还真能给我一些收入，让我能够把它当作一个全职工作，这时我开始觉得我在Meteor和我在Vue.js上的工作存在一些差异，在Meteor我只是一个普通的开发者，我没有做决策的权利，虽然我可以提出建议但我还远没到那种，说我们应该怎么做的那种地位，这让我对Meteor的发展有一些悲观，相比之下，Vue.js一直在快速成长。我注意到用Meteor的人比较少，而用Vue.js的人越来越多，所以那时我就觉得或许把Vue.js作为我的全职工作是值得的”
Vue在恰到好处的时机出现 LevelUp教程的Scott Tolinski在Vue火了后，人们一直要求他做一个Vue.js的教程，在这个系列的教程中，会为大家讲到所有关于Vue.js的知识。
Scott Tolinski表示：“Vue.js出现的正是时候，因为很多人从Angular一代出现或更早之前就开始用Angular，人们都觉得Angular一代很简单，但当Angular二代推出的时候它几乎是一个完全不同的版本了，那个时候React也正在被推出，所以很多开发者开始用React，他们觉得React是个能够登上前端宝座的新东西，但这些开发者就会失去使用Angular一代的那种简单，轻松的感觉，就会感觉到有一种差距，这个由Angular一代的缺失而导致的大洞，Vue.js正好在这个时候出现了，它填补了一个空白，因为人们想要更低的入门门槛，还想要React的这种强大和灵活性，而这就是Vue.js的强项了，它吸取了多个框架和平台最强的部分”。
探索经济来源 尤大大自从有了全职开发Vue.js的想法，就在探索能让自己经济上独立的办法，尤大大做的第一件事就是设立一个Patreon（众筹平台）账号，结果发现还真的不错，在建立那个账号不久之后，就能拿到2000美元一个月，尤大大的一位朋友郭达峰，他是“上线了（Strikingly）”的CTO，一个YC投资的公司，他的公司有个小基金用来支持开源项目，纯粹是出于做好事的想法，如果能拿到这个支持的话，尤大大就完全可以辞掉工作，并开始全职开发Vue.js了，这就足以让尤大大迈出这一步，至少可以去尝试一下。
Serah Drasner加入 Serah Drasner在CSS-tricks工作，是一个写手，Serah Drasner问Chris Coyier：“我觉的我要写一篇关于Vue.js的文章”，他说听起来不错，所以Serah Drasner开始写关于Vue.js的一篇文章，感觉要写挺长的，Serah Drasner问Chris Coyier：“什么情况下一篇文章需要分为一个系列来写”他说，什么时候你觉的你需要写一个目录的时候，那个时候Serah Drasner就该分开写了，Serah Drasner自述：这个时候我写的谷歌文档就已经有25页长了，然后我写完了最好一章，动画，最后就有了一个共有五篇文章的一个系列，我接着不断的写关于Vue.js的东西，下个月我写了更多的文章，然后做了一些Demo和一些开源项目，我觉得从那个时候开始，我就对这个框架感到非常激动，我想要投资更多的时间到其中去，所以Evan和Chris Fritz就邀请我和他们一起制作文档，同时进行一个新的项目叫cookbook，然后我就开始领导cookbook项目并且加入了Vue.js核心团队，现在我帮助运营Vue文档的见面会，Vue团队的见面会我真的很喜欢和这个团队一起工作。
全职投入Vue建设 “在家里工作绝对是非常自由的，你可以自己定制时间表，除去不需要通勤的第二大好处可能就是你不需要穿的像Tom Dale一样。”
尤大大：“想象一个在中国的人想要学习一个新的框架，他们去官网发现只有英文的文档，如果这个框架本身就非常难懂的话就更糟了，他们就会很难学会这个框架，但当他们到Vue.js官网的时候发现这里有中文版的文档，他们读了一下发现文档是由母语是汉语的人写的，一些技术性的内容直接用汉语表达的话会有些奇怪，因为你必须对技术名词想出一些很好的译名，比如说绑定（binding），引用（reference）或视图模型（view model），有些东西你甚至都翻译不了，因为汉语是我的母语然后英语版本的文档也是我自己写的，所以我能够改写一些术语，让它的汉语翻译更自然，这种语言上的熟悉让他们能够读懂你的框架，比他们用自己不熟悉的第二语言来学习要快的多，制作这样的中文文档，绝对帮助提高了Vue.js在中国的使用度”；
Vue引入国内 Jinjiang Zhao：“在中国，很少有人在科技界很知名，所以在中国，人们把Evan看作是一个英雄，一个中国开发者开发的人人都喜欢的框架”；
Gu Yiliang：“这在中国真的很不寻常，我们看不到有人能在开源项目上对世界作出这么大的影响，不仅仅是在中国内部，Evan，他是世界顶尖的，而且他还是中国人，所以我觉得这就是他有这么多中国粉丝的原因”；
Taylor：“他是一个中国人，当中国人看到这一点的时候，他们觉得自己是这其中的一部分，觉得自己是Vue社区的一部分，这是一种很真实的感觉因为他们与Vue的创始人是联系在一起的，Evan为中国社区的作为创造了一种强大的现象，它在中国的开发者之间建立了一种强大的联系，每个人都希望成为这个群体的一员，它让你感觉很棒，当你是这个群体中的一员时，Evan能融入这个群体，这种力量是非常强大的，这是他能在中国成功的巨大原因，它能够融入到这个群体中真的很惊人”；
Jinjiang Zhao：“那个时候移动网络非常的复杂并且不稳定，尤其是在中国，很多人还在用GPRS数据，所以我们尝试搭建一些新的，小体积高性能框架，帮助我们开发成千上万个网页，来支持千万级别的流量，这个量是非常非常大的，我在Github发现了Vue，所以我们的故事就开始了”；
Vue受拥国内 尤大大被到阿里巴巴园区，做一个小的科技讲座，介绍Vue背后的基本想法、是怎么开始做它的、用Vue的好处到底是什么、相比一些手写的jQuery。
他们花费了很长时间，一年或一年半，一些开发者终于接受了Vue，并开始使用它，现在越来越多的人都在用Vue，在那之后，阿里巴巴也越来越多的用Vue了，人们也开始对Vue.js有更多的了解，因为尤大大在知乎上的存在，同时也因为Vue.js在中国以外也获得了更多的关注，这些消息也反向流回中国，人们才发现有一个新的框架叫Vue.js，事实上很多人都是以一个开源项目的身份认识到Vue.js，然后他们才意识到原来这是一个中国人写出来的，Gu Yiliang采访中提到：“我们主要是在我们的企业管理应用上使用Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a9cb5ba67ad362479720ff53bf8ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857808c31d56dafb5f23d08013491953/" rel="bookmark">
			基于简单MLP模型的加州房价预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于简单MLP模型的加州房价预测 摘要 机器学习是当前热度非常高的领域，可以对房价数据进行预测，具有很高的研究价值。为了更好地学习机器学习，将理论付诸于实践，本文从加州房价预测实验入手，提出了基于简单MLP的房价预测模型方法研究。
本文的主要研究内容为基于简单MLP模型的方法，提出了加州房价预测的模型。本文首先介绍了研究背景和意义，实验选取了来源于Kaggle上的一次竞赛California House Prices。在实验中，首先观察了训练数据以及测试数据，分析了自变量Sold Price与因变量的相关性，选取了用来训练的特征。接着，对数据进行预处理，对数值类型的特征进行特征归一化和缺失值的补充，使用了独热编码处理了离散值，最终得到了用于训练的特征。构建了一个简单MLP模型，共三个线性层，并对前两层使用了Relu()。训练函数借助了Adam优化器，其优点是它对初始学习率敏感度不强。使用了网格搜索结合K折交叉验证对超参数进行了调整。训练结束后将获得的模型应用于测试集，并将预测保存在CSV文件中提交到Kaggle查看结果。最终我在Kaggle上获得的score为。
将我的预测结果与简单线性模型的预测结果进行对比，结果显示在这次竞赛的数据上，所提出的模型预测精度更好，具有稳健性，适合用于加州房价预测。
关键词 房价预测；机器学习；
1. 数据指标说明及处理 1.1 数据来源 为了验证模型的普适性，本文选择的数据是Kaggle竞赛California House Prices的数据。该竞赛的任务是根据房子的信息，如卧室数量、居住面积、位置、附近的学校和卖家的摘要，预测房子的销售价格。数据包括2020年在加州售出的房屋，测试数据集中的房屋在训练数据集中的房屋之后售出。此外，私人排行榜上的房子也是在公共排行榜上的房子之后出售的。
1.2 数据指标说明 &gt; 读入数据集之后首先对数据进行观察，代码和结果如下。
print(train_data.shape) print(test_data.shape) 图1-1
可以观察到训练集共有47439个数据，40个特征，多出的一列是标签Sold Price。测试集有31626个数据，40个特征。
将训练集和测试集合并之后对数据进行总览，结果如下。
图1-2
1.2.1 影响因素特征 通过分析自变量Sold Price与因变量的相关性，得到的结果如下图。
#查看自变量与因变量的相关性 fig = plt.figure(figsize=(14,8)) abs(train_data.corr()['Sold Price']).sort_values(ascending=False).plot.bar() plt.xticks(fontsize=20) plt.yticks(fontsize=20) 图1-3
结合上面两步，可以看到相关性大于0.5有这些：Annual tax amount，Tax assessed value，Last Sold
Price，Listed Price，Full bathrooms，Bathrooms。它们全是数值类型，将被加入用于训练的特征列。
1.3 数据预处理 在开始建模前，需要对特征进行预处理。
1.3.1 异常值处理 通过画出上一节中分析出的相关性高的特征的值的分布，通过分析剔除异常的值。
#异常值处理 figure=plt.figure() sns.pairplot(x_vars=['Annual tax amount','Tax assessed value','Last Sold Price','Listed Price','Full bathrooms','Bathrooms'], y_vars=['Sold Price'],data=train_data,dropna=True) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/857808c31d56dafb5f23d08013491953/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfebd6c962e27d470c7c51b4bd05fb36/" rel="bookmark">
			javaweb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件 MIME 类
前端部分技术就不做讲解了
一.基础知识 (一)概述 JavaWeb 是指，所有通过 Java 语言编写可以通过浏览器访问的程序的总称，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。
请求：请求是指客户端给服务器发送数据，叫请求 Request。
相应：响应是指服务器给客户端回传数据，叫响应 Response。
请求响应关系
(二)Web资源分类 web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。
静态资源： html.css.js.txt.mp4 视频 , jpg 图片
动态资源： jsp 页面.Servlet 程
(三)Tomcat 的使用 1.安装 找到你需要用的 Tomcat 版本对应的 zip 压缩包，解压到需要安装的目录即可。
2.目录介绍 bin 专门用来存放 Tomcat 服务器的可执行程序
conf 专门用来存放 Tocmat 服务器的配置文件
lib 专门用来存放 Tomcat 服务器的 jar 包
logs 专门用来存放 Tomcat 服务器运行时输出的日记信息
temp 专门用来存放 Tomcdat 运行时产生的临时数据
webapps 专门用来存放部署的 Web 工程。
work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfebd6c962e27d470c7c51b4bd05fb36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc02b09a386a55fc250ac0485c8d9b6/" rel="bookmark">
			vue3.0 特殊语法说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Object.assign()方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
var target={name:'guxin',age:18}; var source={state:'single'} var result=Object.assign(target,source); console.log(target,target==result); let和const与var的区别
一、定义 let和const是ES6新增的声明变量的关键词，之前声明变量的关键词是var。 二、let var定义的变量，可以预解析提前调用的结果是undefined，let定义的变量不能预解析，提前调用的结果是 报错。 var定义的变量，变量名称可以重复，效果是重复赋值，let定义的变量不能重复，否则执行报错。 var定义的变量作用域是全局/局部作用域。let定义的变量如果在{}中只能在{}中调用。 在循环语句中var定义的循环变量和使用let定义的循环变量。执行原理和执行效果不同。 三、const var定义的变量，可以预解析提前调用的结果是undefined，const定义的变量不能预解析，提前调用的结果是 报错。 var定义的变量，变量名称可以重复，效果是重复赋值，const定义的变量不能重复，否则执行报错。 var定义的变量作用域是全局/局部作用域。let定义的变量如果在{}中只能在{}中调用。 const 定义的变量存储的数据数值不能改变，也就是const定义的变量，不能重复赋值。 //基于element-plus数据表的操作 let idx= list.findIndex(itm =&gt; itm== id) // idx= -1 列表中不存在查询的值,查询到的返回索引 let idx= list.findIndex((itm) =&gt; { return itm== id }) //两种写法 加{} 就得加return返回 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6215ed1f0fe5946d6ea68bfe35727b/" rel="bookmark">
			自学PR剪辑04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、导入素材到Premiere 可以直接拖拽素材到Pr项目里，也可以直接鼠标点击导入进去，也可以直接将文件夹导入进去
二、素材脱机与重新链接 1.比如换了一台电脑或者文件进行移动后电脑就不知道原来所导入的素材去哪里了，所以这个时候它并不能去调取这个素材，这个时候它就只能以脱机文件到形式进行显示。
image.png 2.这个时候不要急，可以看一下项目面板右下角的这个浮动条可以左右的移动，移动到文件位置这一栏，如果看不到的话可以在标签任意处点击元数据显示 image.png 3.然后我们需要找到一个文件的路径，勾选下点击确定，然后我们的面板就多出来一个文件路径这样的一个地址。 image.png 4.我们将脱机的文件全部选好后点击右键，选择链接媒体 image.png 5.我们可以重新的将这些媒体链接上，点击查找，找到一个粗略的位置后，系统会自动匹配素材(素材最好放到一个位置。) image.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f9c7d414530ca5c3ae4b646506562e/" rel="bookmark">
			自学PR剪辑03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 了解重要项目参数设置 1、首先打开软件点击Premiere Pro可以看到一个首选项，然后里面有很多的参数设置
image.png image.png 2、先挑选一些比较重要的参数设置，其他默认就可以了 比如常规、音频硬件、自动保存等 其他的参数可以在之后的工作中看情况调整。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6627a3393090b27437be8ad068f7259e/" rel="bookmark">
			操作系统-虚拟存储技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虚拟存储器 虚拟存储器传统存储管理方式局部性原理虚拟内存技术请求分页缺页中断 页面置换算法最佳置换算法先进先出（FIFO）最近最久未使用置换算法（LRU）时钟置换算法（CLOCK，最近未使用）总结 虚拟存储器 当用户看到自己程序能在系统中正常运行，他会认为，该系统所具有的内存容量一定比自己程序大，但用户所看到的大容量只是一种错觉，是虚的，所以人们把这样的存储器称为虚拟存储器
传统存储管理方式 传统存储管理方式特征、缺点：
特征：
一次性：作业必须一次性全部装入内存后才能开始运行
1、作业很大，不能全部装入内存，导致大作业无法运行 2、只有少量作业能运行，导致多道程序并发度下降 驻留性：一旦作业被放入内存，就会一直驻留在内存中，直至作业结束。事实上一个时间段，只需访问作业一小部分数据即可正常运行（GTA场景）。
1、浪费资源 局部性原理 如何应用：
高速缓冲思想：将近期会频繁访问到的数据放到更高速的存储器当中，暂时不用的数据放到更低速的存储器中。
基于局部性原理：
程序装入时可以将很快会用到的部分装入内存中，暂时不用的部分留在外存。 执行过程中，由操作系统负责将信息从外存调入内存中，然后继续执行程序。 内存空间不够，由操作系统负责将内存中暂时不用的信息换出到外存 在操作系统的管理下，用户看来似乎有一个比实际大的多的内存，叫做虚拟内存
虚拟内存只是在逻辑上进行了扩充
三个特征
虚拟内存技术 建立在离散分配的内存管理分配基础上
请求分页 在基本分页的基础上增加了几个表项：
1、状态位：表示页面是否已在内存中（只有调入内存才能根据表项块号得出最终物理地址，不在的话在外存） 2、访问字段：记录最近被访问过几次，或记录上次访问的时间，供置换算法换出页面做参考 3、修改位：表示页面调入内存后是否被修改过， 由于内存中每一页都在外存上有副本，若未被修改，不需要将该页写回到外存。若被修改，则需要写到外存上 4、外存地址：页面在外存中存放的位置 缺页中断 如果一个页面未调入内存则会产生缺页中断信号
属于内中断
一条指令可能产生多次缺页中断
1、找到页表项时需要检查页面是否在内存中 2、若页面不在内存中，需要请求调页 3、若内存空间不够，还需要换出页面 4、页面调入内存后，需要修改相应表项 页面置换算法 进程运行过程中，所访问的页面不在内存，需要把它们调入内存。但内存已无空闲空间。因此系统必须用算法决定将哪个页面调出。
最佳置换算法 淘汰永远不使用，在长时间内不再被访问的页面
先进先出（FIFO） 淘汰最早进入内存的页面
把调入内存的页面先后顺序排成一个队列。需要换出页面时选择队头页面即可
最近最久未使用置换算法（LRU） 淘汰最近最久未使用的页面
时钟置换算法（CLOCK，最近未使用） 简单CLOCK算法：为每个页面设置访问位，将内存的页面通过链接指针链接成一个循环队列
改进型CLOCK算法：考虑到修改的页面替换成本更大（要写入外存）
除了考虑页面最近没有访问过之外，还应考虑有没有修改过，应先淘汰没有修改过的页面，避免I/O操作。用（访问位，修改位）表示各页面形态
后宫方式打开CLOCK算法
1、首先找（0，0）表示未访问，未修改 2、再退而求其次，找（0，1）表示未访问，已修改，*找的过程中把访问位都置为0 3、若前两个都找不到，先把每个访问位都置0，再去首先找（0，0），还找不到再去重复第二步 总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa940db672abea9ecd1d7fef97207eca/" rel="bookmark">
			python批量数据处理脚本——批量删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果是删除一个文件内的所有文件(不存在文件夹)，则使用os库的remove()函数：
import os file_path = "文件夹路径" files = os.listdir(file_path) for file in files: os.remove(os.path.join(file_path, file)) 使用遍历的方法一个一个删除文件，注意删除时需要的是每个文件的绝对路径，而os.listdir()得到的只是文件的文件名，所以需要os.path.join()来得到每个文件的绝对路径。
2.如果要删除的文件夹内有多个文件及文件夹，或者文件夹里面还有文件夹，这种树状关系使用shutil库的rmtree函数删除：
import shutil file_path = "文件夹路径" shutil.rmtree(file_path) 有什么问题或者不懂的地方欢迎私聊，看见就会回答。也欢迎大神指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a7b29b2588dbc291ccb2e97be008ed/" rel="bookmark">
			SqlServer日志文件过大处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bat脚本
@echo off
del /f /s /q D:\sqlserver\sqlserver_example\MSSQL15.SQLEXPRESS\MSSQL\Log\Polybase\dump*.dmp
后面的路径是你装MS sql的路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8453bcb85ac34fb035c1ca58cfb1700e/" rel="bookmark">
			policy gradient详解（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言 policy gradient是强化学习中一种基于概率策略的方法。智能体通过与环境的交互获得特定时刻的状态信息，并直接给出下一步要采取各种动作的概率，然后根据该状态动作的策略分布采取下一步的行动，所以每种动作都有可能被选中，只是选中的概率性不同。智能体直接学习状态动作的策略分布，在强化学习的训练中，用神经网络来表示状态动作分布，给一个状态，就会输出该状态下的动作分布。强化学习算法直接对策略进行优化，使指定的策略能够获得最大的奖励。
2 policy gradient原理介绍 考虑一个随机参数化的策略 π θ \pi_\theta πθ​，强化学习主要目标是最大化期望回报 J ( π θ ) = E τ ∼ π θ [ R ( τ ) ] J(\pi_\theta)=\mathbb{E}_{\tau \sim \pi_\theta}[R(\tau)] J(πθ​)=Eτ∼πθ​​[R(τ)]其中 τ = ( s 0 , a 0 , s 1 , a 1 , ⋯ , s T + 1 ) \tau=(s_0,a_0,s_1,a_1,\cdots,s_{T+1}) τ=(s0​,a0​,s1​,a1​,⋯,sT+1​)， s i s_i si​和 a i a_i ai​分别表示第 i i i时刻的状态和动作。 R ( τ ) = ∑ t = 0 T r t R(\tau)=\sum\limits_{t=0}^Tr_t R(τ)=t=0∑T​rt​表示 T T T时刻内的回报， r t r_t rt​表示第 t t t时刻的回报。通过梯度上升法优化策略即有 θ k + 1 = θ k + α ∇ θ J ( π θ ) ∣ θ k \theta_{k+1}=\theta_{k}+\alpha \nabla_\theta J(\pi_\theta)|_{\theta_k} θk+1​=θk​+α∇θ​J(πθ​)∣θk​​其中 ∇ θ J ( π θ ) \nabla_\theta J(\pi_\theta) ∇θ​J(πθ​)表示策略梯度。策略梯度的具体导数形式的推导如下所示。给定策略 π θ \pi_\theta πθ​，轨迹 τ \tau τ的概率为 P ( τ ∣ θ ) = ρ 0 ( s 0 ) ∏ t = 0 T P ( s t + 1 ∣ s t , a t ) π θ ( a t ∣ s t ) P(\tau|\theta)=\rho_0(s_0)\prod_{t=0}^TP(s_{t+1}|s_t,a_t)\pi_\theta(a_t|s_t) P(τ∣θ)=ρ0​(s0​)t=0∏T​P(st+1​∣st​,at​)πθ​(at​∣st​)其中 ρ 0 ( ⋅ ) \rho_0(\cdot) ρ0​(⋅)表示状态分布。根据链式法则则有 ∇ θ P ( τ ∣ θ ) = P ( τ ∣ θ ) ∇ θ log ⁡ P ( τ ∣ θ ) \nabla_\theta P(\tau|\theta)=P(\tau|\theta)\nabla_\theta \log P(\tau|\theta) ∇θ​P(τ∣θ)=P(τ∣θ)∇θ​logP(τ∣θ)进一步可知轨迹的对数概率表示为 log ⁡ P ( τ ∣ θ ) = log ⁡ ρ 0 ( s 0 ) + ∑ t = 0 T ( log ⁡ P ( s t + 1 ∣ s t , a t ) + log ⁡ π θ ( a t ∣ s t ) ) \log P(\tau|\theta)=\log \rho_0 (s_0)+\sum\limits_{t=0}^T\left(\log P(s_{t+1}|s_t,a_t)+\log \pi_\theta(a_t|s_t)\right) logP(τ∣θ)=logρ0​(s0​)+t=0∑T​(logP(st+1​∣st​,at​)+logπθ​(at​∣st​))因为 ρ 0 ( s 0 ) \rho_0(s_0) ρ0​(s0​)， P ( s t + 1 ∣ s t , a t ) P(s_{t+1}|s_t,a_t) P(st+1​∣st​,at​)与策略参数 θ \theta θ无关 ，所以它们的梯度为 0 0 0，进而可知轨迹的对数概率梯度表示为 ∇ θ log ⁡ P ( τ ∣ θ ) = ∇ θ log ⁡ ρ 0 ( s 0 ) + ∑ t = 0 T ( ∇ θ log ⁡ P ( s t + 1 ∣ s t , a t ) + ∇ θ log ⁡ π θ ( a t ∣ s t ) ) = ∑ t = 0 T ∇ θ log ⁡ π θ ( a t ∣ s t ) \begin{aligned}\nabla_\theta \log P(\tau|\theta)&amp;=\nabla_\theta \log \rho_0(s_0)+\sum\limits_{t=0}^T\left(\nabla_\theta \log P(s_{t+1}|s_t,a_t)+\nabla_\theta \log \pi_\theta(a_t|s_t)\right)\\&amp;=\sum\limits_{t=0}^T\nabla_\theta \log \pi_\theta(a_t|s_t)\end{aligned} ∇θ​logP(τ∣θ)​=∇θ​logρ0​(s0​)+t=0∑T​(∇θ​logP(st+1​∣st​,at​)+∇θ​logπθ​(at​∣st​))=t=0∑T​∇θ​logπθ​(at​∣st​)​综上所述可得 ∇ θ J ( π θ ) = ∇ θ E τ ∼ π θ [ R ( τ ) ] = ∇ θ ∫ τ P ( τ ∣ θ ) R ( τ ) = ∫ τ ∇ θ P ( τ ∣ θ ) R ( τ ) = ∫ τ P ( τ ∣ θ ) ∇ θ log ⁡ P ( τ ∣ θ ) R ( τ ) = E τ ∼ π θ [ ∇ θ log ⁡ P ( τ ∣ θ ) R ( τ ) ] = E τ ∼ π θ [ ∑ t = 0 T ∇ θ log ⁡ π θ ( a t ∣ s t ) R ( τ ) ] \begin{aligned}\nabla_\theta J(\pi_\theta)&amp;=\nabla_\theta \mathbb{E}_{\tau\sim \pi_\theta}[R(\tau)]\\&amp;=\nabla_\theta \int_\tau P(\tau|\theta)R(\tau)\\&amp;=\int_\tau \nabla_\theta P(\tau|\theta)R(\tau)\\&amp;=\int_\tau P(\tau|\theta)\nabla_\theta \log P(\tau|\theta)R(\tau)\\&amp;=\mathbb{E}_{\tau\sim \pi_\theta}[\nabla_\theta \log P(\tau|\theta)R(\tau)]\\&amp;=\mathbb{E}_{\tau\sim \pi_\theta}\left[\sum\limits_{t=0}^T\nabla_\theta \log \pi_\theta(a_t|s_t)R(\tau)\right]\end{aligned} ∇θ​J(πθ​)​=∇θ​Eτ∼πθ​​[R(τ)]=∇θ​∫τ​P(τ∣θ)R(τ)=∫τ​∇θ​P(τ∣θ)R(τ)=∫τ​P(τ∣θ)∇θ​logP(τ∣θ)R(τ)=Eτ∼πθ​​[∇θ​logP(τ∣θ)R(τ)]=Eτ∼πθ​​[t=0∑T​∇θ​logπθ​(at​∣st​)R(τ)]​以上公式是期望的表示形式，可以通过对蒙特卡洛模拟采样均值来估计它的值。假定采样得到一个轨迹集合 D = { τ i } i = 1 , ⋯ , N \mathcal{D}=\{\tau_i\}_{i=1,\cdots,N} D={τi​}i=1,⋯,N​，其中每个轨迹都是在策略 π θ \pi_\theta πθ​下智能体与环境交互得到的，此时估计的策略梯度表示为 g ^ = 1 ∣ D ∣ ∑ τ ∈ D ∑ t = 0 T ∇ θ log ⁡ π θ ( a t ∣ s t ) R ( τ ) \hat{g}=\frac{1}{|\mathcal{D}|}\sum\limits_{\tau\in\mathcal{D}}\sum\limits_{t=0}^T \nabla_\theta \log \pi_\theta(a_t|s_t)R(\tau) g^​=∣D∣1​τ∈D∑​t=0∑T​∇θ​logπθ​(at​∣st​)R(τ)其中 ∣ D ∣ |\mathcal{D}| ∣D∣表示轨迹集合 D \mathcal{D} D的元素个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8453bcb85ac34fb035c1ca58cfb1700e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea23fe7088e2308284e5460da9c1fea/" rel="bookmark">
			所有远程软件无法连接Linux主机，显示拒绝连接，SecureCRT,filezilla都显示拒绝连接....（谨慎，看完再选择尝试！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：filezilla显示拒绝连接，在此之前，我准备使用SecureCRT，也显示会话拒绝连接
然后我在虚拟机上面，输入systemctl restart sshd，准备重启SSH，显示失败
看到错误提示，让我去看SSH的状态，然后输入systemctl status sshd.service
然后，继续看详细错误提示，输入sshd -t
提示信息，显示我的sshd_config配置文件的62行，非常恶劣的错误。。。
然后，输入 vi /etc/ssh/sshd_config，按 i 进入编辑模式，linux没有行数，啊啊啊啊，我一行行数到62行，虽然我大概预料到是哪里错了，因为我昨天才因为nginx改了sshd_config配置文件，谨慎起见，我还是数吧。。。。
昨天，我把这62的几行的#注解全部删掉了，因为nginx的一堆乱七八糟的错误，学习之路永远这么坎坷。
然后，我又把这些注解给加上了。。。。
重启，无异常，查看状态，这朵绿真是我的男神！
打开SecureCRT,filezilla，激动.jpg
全部成功！！！绿儿，我爱你！
结语：
我的成功是因为我昨天改了sshd_config配置文件，所以大概知道可能问题出在哪里，大家要谨慎！！我昨天的nginx错误，也是跟着一些情况雷同的博主改了一通，然后今天就出错了，所以大家一定一定要谨慎，配置文件从来没改过，大家就看看就好，不要轻易尝试，不然真的会崩溃，一个问题还没解决，又出现一些连锁错误！
谨慎啊！！！宝子们！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925b10e89cc08f60dfff1091b484d0cc/" rel="bookmark">
			深度学习入门（二十四）卷积神经网络——填充和步幅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习入门（二十四）卷积神经网络——填充和步幅 前言卷积神经网络——填充和步幅课件填充步幅总结 课本1 填充2 步幅3 小结 前言 核心内容来自博客链接1博客连接2希望大家多多支持作者
本文记录用，防止遗忘
卷积神经网络——填充和步幅 课件 填充 给定(32×32)输入图像，应用(5×5)大小的卷积核
第一层得到输出大小28×28
第七层得到输出大小4×4
更大的卷积核可以更快地减小输出大小
形状从 n h × n w n_h×n_w nh​×nw​减小到 ( n h − k h + 1 ) × ( n w − k w + 1 ) (n_h-k_h+1)×(n_w-k_w+1) (nh​−kh​+1)×(nw​−kw​+1)
填充：在输入周围添加额外的行/列
0 × 0 + 0 × 1 + 0 × 2 + 0 × 3 = 0 0 × 0 + 0 × 1 + 0 × 2 + 0 × 3 = 0 0×0+0×1+0×2+0×3=0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925b10e89cc08f60dfff1091b484d0cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ef3d7e3e101d7dafe5ea174512e060/" rel="bookmark">
			selenium加载插件自动化控制插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景 最近我想把自己在哔哩哔哩上发的视频全部下载下来，发现哔哩哔哩网页版没有下载功能，app客户端只能一个一个缓存，
然后我找到网上的一些教程，发现大多数都是让我去下载一些客户端的软件，我不想用，最后发现一个chrome插件bilibili-helper-2.1.7.crx
可以帮我一个一个下载，但它不能满足我一下子下载的全部视频的功能，然后，我思考了片刻，
决定利用这个插件加上我所学的自动化测试框架，简单写一些代码，尝试完成这个批量下载某个up主的全部视频的功能，
于是就有了这个项目，虽然它很小，而且是寄生在bilibili-helper-2.1.7.crx插件之上的，但不得不说它确实解决了
我当下的小问题。
原理： chromedriver 加载bilibili-helper插件---&gt;打开浏览器---&gt;控制台输入up主的mid ---&gt; 查到它的所有视频id(它是分页的，需要处理下哈)---&gt;根据每个视频id页次访问页面---&gt;使用selenium 点击下载按钮 ---&gt;等待页面出现下载完成文字，然后进行下一个视频的下载--&gt;直至视频列表被遍历完,该up主的所有视频被下载 使用说明: 1.先运行 LoadChromeDriver.py 会自动下载与你浏览器匹配的chromedriver 2.再运行LoadExtensionPlug.py 文件输入up主的mid mid 是每个up主的唯一id，例如up主老番茄的主页url为: https://space.bilibili.com/546195/，那么后面的数字546195即是老番茄的 mid
3.然后生成的视频会在你的 D:\myVideo\ 文件夹下，如果你没有D盘，请更改代码里的path变量，当然你也可以改为其他
4.使用前请关掉你的浏览器，不然会报错，这是一个bug，如果下载失败，请清空一下浏览器的缓存
我用的浏览器版本如下 版本 107.0.5304.88（正式版本） （64 位）
如果你使用的是其他版本的浏览器，请如 chromedriver 下载站点下载与浏览器版本对应的chromedriver
你也可以运行 本项目中的LoadChromeDriver.py 自动帮你下载和你浏览器匹配的chromedriver，但你事先必须安装chrome浏览器、
效果: 输入 up主老番茄 的 mid 并按回车键
![在这里插入图片描述]
参考 1.bilibili-helper 下载地址
2.使用selenium 加载chrome插件
3.selenium 下载文件时 出现保存弹窗让选路径，下载被卡主问题
4.Web自动化遇到shadowDOM节点操作
5.selenium 获取shadow-root的元素
6.自动下载与用户浏览器匹配的ChromeDriver
我的 我的博客
github链接
免责声明 该项目和文章只是用于selenium的学习和研究，不得使用它来进行其他违法行为，使用该教程进行的一切违法行为与本博主
无关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e409e965c4a1b2e1da2010135d1d44c6/" rel="bookmark">
			电子元器件篇---MOS管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
MOS管基本参数
2.1、开启电压VT
2.2、直流输入电阻RGS
2.3、漏源击穿电压BVDS
2.4、栅源击穿电压BVGS
2.5、低频跨导gm
2.6、导通电阻RON
2.7、极间电容
2.8、低频噪声系数NF
2.9、常见封装形式
MOS管种类
3.1、结型场效应管（JFET）
3.2、绝缘栅场效应管
MOS管用途
4.1开关电路
4.2共源极放大电路
4.3共漏极放大电路
4.4共栅极放大电路
4.5电平转换或者隔离电路
4.6、防反接电路
4.7、缓启动电路
4.8、逻辑转换电路
简介 MOS管是金属(metal)—氧化物(oxide)—半导体(semiconductor)场效应晶体管，或者称是金属—绝缘体(insulator)—半导体。MOS管具有输入阻抗高、噪声低、热稳定性好；制造工艺简单、辐射强，因而通常被用于放大电路或开关 电路。场效应晶体管能把输入电压的变化转化为输出电流的变化，场效应晶体管的增益等于它的transconductance， 指输出电流的变化和输入电压变化之比，通常实际使用的场效应晶体管通俗被称为MOS管。
MOS管基本参数 2.1、开启电压VT 开启电压指使得源极和漏极之间形成导电沟道所需要的栅极电压，又称阈值电压，一般MOS管的开启电压是3V到5V之间，源极和漏极之间的导通电阻会随着门极电压的升高而减小。
2.2、直流输入电阻RGS 直流输入电阻RGS指在栅极和源极之间加的电压与流过栅极的电流之比，有时用流过栅极的栅流来表示这一特性，MOS管的直流输入电阻很容易超过1010Ω。
2.3、漏源击穿电压BVDS 在未加栅极电压时，持续增加漏源两极间的电压，使得漏源间击穿时的电压称为漏源击穿电压BVDS，由于不断增加漏源两极间的电压值，会使漏极的耗尽层增大直至扩展到源区，造成漏源间导通，此时源区中的多数载流子，将直接受耗尽层电场的吸引，到达漏区，产生大的ID。
2.4、栅源击穿电压BVGS 栅源击穿电压指使栅氧化层发生击穿时的VGS，BVGS大致正比于删氧化层的厚度，但实际上优惠氧化层的缺陷与不均匀，应至少加50%的安全系数。
2.5、低频跨导gm 低频跨导反映了栅压对漏极电流的控制作用，这一点与电子管的控制作用相似。在VDS为某一固定数值的条件下 ，漏极电流的微变量和引起这个变化的栅源电压微变量之比称为跨导，是小信号建模的重要参数。
2.6、导通电阻RON 导通电阻指在MOS管正常工作时，漏极和源极之间的阻值，该值越小表示MOS管工作时的损耗越小。一般来讲栅极源极间电压越高，导通电阻越小。另外，栅极源极间电压相同的条件下，导通电阻因电流不同而不同。计算功率损耗时，需要考虑栅极源极间电压和漏极电流，选择适合的导通电阻。另外导通电阻也会因温度进行变化。
2.7、极间电容 极间电容是指MOS管的栅极、源极、漏极任两者之间实际存在的等效电容，分别为栅源电容CGS、栅漏电容CGD和漏源电容CDS，从电路上看不到这个电容，是极间实际存在的电容效应的抽象。其大小主要决定于电极的尺寸和电极间的距离，此外与电极引线的长短、间距及所阁介质有关。CGS和CGD约为1～3pF，CDS约在0.1～1pF之间。
2.8、低频噪声系数NF 单位为分贝（dB），噪声是由管子内部载流子运动的不规则性所引起的，由于它的存在，可使放大器即便在没有信号输人时，输出端也会出现不规则的电压或电流变化。噪声系数NF数值越小，代表管子所产生的噪声越小，场效应管的噪声系数约为几个分贝，比双极性三极管的要小。
2.9、常见封装形式 下图列出一些MOS管的常见封装及对应管脚。
MOS管种类 场效应管分为结型场效应管（JFET）和绝缘栅场效应管（MOS管）两大类。
3.1、结型场效应管（JFET） 结型场效应管的分类：结型场效应管有两种结构形式，它们是N沟道结型场效应管和P沟道结型场效应管。结型场效应管也具有三个电极，它们是：栅极；漏极；源极。电路符号中栅极的箭头方向可理解为两个PN结的正向导电方向。
3.2、绝缘栅场效应管 绝缘栅场效应管（MOS管）的分类：绝缘栅场效应管也有两种结构形式，它们是N沟道型和P沟道型。无论是什么沟道，它们又分为增强型和耗尽型两种。
MOS管用途 4.1开关电路 下图是两种MOS管用作开关作用来控制LED亮灭的电路，对于N沟道增强型的MOS管当控制信号为高电平时MOS管导通，低电平时MOS管断开；对于P沟道增强型的MOS管当控制信号为低电平时MOS管导通，高电平时MOS管断开。
4.2共源极放大电路 输入信号是从MOS管的栅极和源极两端输入，输出信号是从MOS管的漏极和源极获得，他们公共端是源极，所以称为共源极放大电路。共源放大电路特点：电压增益高，反向放大，输入阻抗大。下图为一个典型的共源极放大电路。
4.3共漏极放大电路 在共漏极放大电路中，漏极是输入回路和输出回路的公共端。 输入回路为栅极到漏极的回路，输出回路为源极到漏极的回路，他们公共端是漏极，所以称为共漏极放大电路。共漏放大电路特点：电压为1，同向放大，输入阻抗大，输出阻抗低，一般做阻抗变换用。下图为一个典型的共漏极放大电路。
4.4共栅极放大电路 输入信号是从MOS管的栅极和漏极两端输入，输出信号是从MOS管的源极和栅极获得，他们公共端是栅极，所以称为共栅极放大电路。共栅放大电路特点：电压增益高，同向放大，输入阻抗小。下图为一个典型的共栅极放大电路。
4.5电平转换或者隔离电路 电路设计时，不同的子系统之间无可避免的需要数字信号传递，不同的系统之间或者设备之间，数字接口电平经常不一致，故需要用到电平转换电路；下图为使用MOS管搭建起来的电平转换电路。
4.6、防反接电路 在电源接口设计时，有很多场合需要考虑反接的问题，没有相应的电路设计的话很容易将电路烧坏，造成损失；MOS管防反接，好处就是压降小，能规避普通二极管压降大的弊端；PMOS管常用在正极，NMOS管常用在负极；下图只是示意结构，G极具体需要接上阻容器件，同时可以起到缓启动作用；
4.7、缓启动电路 对于有些控制电机的电路或开关电路中负载容性较大的电路等，有时需要加缓启动电路，下图为一个典型的缓启动电路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e409e965c4a1b2e1da2010135d1d44c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c040f4714b4751511e3f856cbb9d2d/" rel="bookmark">
			手把手教你正确地创建一个Servlet项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 常见问题创建 Servlet 项目的完整流程1. 创建一个 Maven 项目2. 完善项目的路径3. 修改配置文件4. 配置 Maven 国内源5. 重新下载 jar 包6. 编写简单代码7. 运行Tomcat 说在后面 常见问题 问题一: 我代码明明跟别人的是一样的, 为什么一直会出现红色感叹号?问题二: 为什么我往 pom.xml 或者 web.xml 中添加依赖后, 一直显示在加载, 没有加载完成, 或者是最后显示加载失败?问题三: 为什么我已经是加载成功了, 然而还是不能正常使用呢? 相信有很多开始想要做项目的小伙伴都会遇到这样的问题, 对此本人整理了一篇比较完整的创建 Servlet 项目的流程, 避免一些初学者踩坑等, 当然, 后面也会有 Spring 项目的创建流程等文章陆续出现.
创建 Servlet 项目的完整流程 本文会以一个简单从开发到调试的流程来进行演示, 如果之前完全没有创建过 Maven 项目的话, 那么直接按照文章顺序往下看即可; 如果是已经创建好项目, 但是运行出现上面常见问题的, 则直接跳到后面修改配置环节开始往后看即可.
1. 创建一个 Maven 项目 按照图片中的顺序, 先点击 Maven, 再点击创建模板, 然后选择其中 webapp 的这个模板, 最后点击 Next.
之后就是一路 Next, 如果在 Finish 之前有出现上面这个界面的话, 就直接选择默认的目录, 以及后面的 Override 也勾选上(如果没有出现这个页面就直接 Finish 即可, 大多数第一次创建 Maven 的都是没有这个界面的, 所以不影响后面的).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c040f4714b4751511e3f856cbb9d2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f427fe47d04a47b5abcc46399133c4d/" rel="bookmark">
			软件测试技能，JMeter压力测试教程，JDBC配置连接mysql数据库（十）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、JDBC 连接配置二、JDBC Driver三、JDBC Request 前言 使用jmeter压测接口的时候，有时候需要批量造数据，需使用jmeter连数据库造对应的测试数据
或者测试结束后，对测试的数据还原，删掉一些垃圾数据，都会用到连接数据库执行sql的操作
一、JDBC 连接配置 添加配置元件-JDBC Connection Configuration
先弄清楚自己的mysql数据库相关信息
配置连接数据库mysql相关的配置内容
Variable Name for created pool: 自己定义连接数据库的名称，自己知道是连的哪个数据库就行
如：jdbc_web
Database URL：数据库url，jdbc:mysql://主机ip或者机器名称:mysql监听的端口号/数据库名称
如：jdbc:mysql://localhost:3306/test
url后面的参数：characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai 设置时区和编码格式
JDBC Driver class：JDBC驱动,我用的mysql选com.mysql.jdbc.Driver
username：登陆数据库的用户名
passwrod：登陆数据库的密码
二、JDBC Driver 不同的数据库和驱动连接方式参考下表
DatebaseDriver classDatabase URLMySQLcom.mysql.jdbc.Driverjdbc:mysql://host:port/{dbname}PostgreSQLorg.postgresql.Driverjdbc:postgresql:{dbname}Oracleoracle.jdbc.driver.OracleDriverjdbc:oracle:thin:user/pass@//host:port/serviceIngres (2006)ingres.jdbc.IngresDriverjdbc:ingres://host:port/db[;attr=value]MSSQLcom.microsoft.sqlserver.jdbc.SQLServerDriverjdbc:sqlserver://IP:1433;databaseName=DBname（或）MSSQLnet.sourceforge.jtds.jdbc.Driverjdbc:jtds:sqlserver://localhost:1433/“+”library” jmeter 连mysql 数据库需安装对应的驱动包，mysql驱动包下载地址：https://dev.mysql.com/downloads/connector/j/
或者直接点这里下载：https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-8.0.22.zip
下载完成后解压zip包
找到mysql-connector-java-8.0.22.jar包，放到jmeter的lib目录下
三、JDBC Request 线程组-添加-取样器-JDBC Request
JDBC Request 请求里面写个简单的查询SQL验证下是否能查到数据
Variable Name for created pool：前面自己定义的连接数据库的名称
Query Type：查询的sql选择 Select Statement选项
Query：写个查询的SQL
select * from apiapp_card; 查看结果数，可以看到查询到数据库表里面的数据了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db57564116ea0d60a1845c1262d5e280/" rel="bookmark">
			我的CV算法岗上岸之路（2023届秋招）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读
在卷成麻花的2022年，一个没有上述背景、没有名校撑腰的普通科班小硕能入坑中大厂的CV算法岗吗？作者亲身经历分享。
写在前面 是的，今年的秋招确实是肉眼可见的难度增加：缩招、裁员、毕业生人数爆炸，这些关键字已然成为2023届秋招的代名词。竞争激烈，算法岗入坑的难度更是直线上升。卡第一学历、卡名校、卡重点实验室......这些“基本操作”早已司空见惯。
在卷成麻花的2022年，一个没有上述背景、没有名校撑腰的普通科班小硕能入坑中大厂的CV算法岗吗？
我的回答是：能，但是很难、很卷，且容错率较低。因为CV算法岗的竞争对手基本都在985分段，且动不动就是某C9高校的重点实验室。
因为身边的人不走算法岗，所以全程基本靠自己摸索，期间遇到了各种困难、走了许多弯路。为了记录这段有意义的经历，同时给自己一样出身普通的师弟们（实验室没有师妹）提供CV算法岗的就业思路，将本人的整个秋招的真实历程分享给大家。【长文警告↓↓↓】
导读：
本篇文章主要分为以下几个章节：
【背景】，【历程】主要介绍了本人秋招前的状态，以及从研究生入学到秋招的过程。
【需要掌握的技能】从硬实力、软实力两个方面介绍秋招时可以增加自己竞争力的点。由于每个人的基础情况不同，CV算法岗也有较多细分方向，本章节仅供参考，大佬请直接略过。
【总结】秋招的一些小的建议。
补充说明：
1. 阅读文章之前，请务必了解“幸存者偏差”这一概念，CV算法岗的秋招形式严峻，请保持理智。
2. 本文的“普通”一词是指本科双非、硕士非985、非重点实验室、无顶会、投递岗位为CV算法岗的计算机科班应届研究生，并无冒犯之意。
背景 概述： 本人本科双非软件工程专业，硕士普通211的计算机技术专业，目前研究方向是计算机视觉。
秋招拿到【虹软、vivo、OPPO三家offer，均为计算机视觉类（CV）算法岗，有SP也有大白菜】（除去国企银行），和大佬们的offer没得比，但感觉基本接近自己的预期。（虽然已于9月获得虹软转正意向书，为了给自己的秋招不留遗憾，同时可以通过不同的offer明确自己在秋招大军的整体定位，所以坚持完整参与了秋招）。
具体情况： 身边的环境
除了我的大大大师兄（高我三四届）拿了某中厂算法offer以外，我们实验室就再也没有人走过算法岗。包括同门在内的同届同学，也基本都是开发。师兄和同学也都劝退我走算法，改开发。
在我找到第一份算法实习之前，大部分人都认为我选择这条路是一个头铁且愚蠢的行为，且常听到阴阳怪气的言论。
每次刷知乎，总能看到“19年算法岗供大于求”、“20年算法岗诸神黄昏”、“21年算法岗灰飞烟灭”，今年又换了个四字词语 --“人间炼狱”。各路“过来人”也都是全方位劝退。
好在自己的家人比较支持我自己做决定，只不过最后选择offer的时候，家人们曾劝我躺平一个随手拿的国企，放弃自己的专业，我要真想躺平还用的着这么卷么，大无语。
总之，身边自始至终支持我走算法岗的，四舍五入就只剩自己了。没关系，意料之中罢了。
自己拥有的一些条件
导师不会push我们给他发论文，且只要完成规定的任务，就允许我们自己出去找实习。【秋招上岸的关键性因素】
实验室有免费使用的入门级计算资源，虽然只是1080Ti这种级别的显卡，且当时还要和师兄一起用。但是拿来学习跑跑实验还是绰绰有余的。同时家里赞助更新了一台2060GPU的笔记本，用来本地调试也挺好使。
学校的线下课程在研一期间全部上完，研一课程结束就可以做实习早鸟。
历程 本节按照时间线的顺序，叙述了本人历时两年的秋招战线。
【初识算法】2020年9月~2020年10月 结束摆烂、确定方向阶段。 研究生入学，之前联系的导师莫名其妙把我鸽 了，不得不重新找导师。
我的选择标准有两个：一是教授，二是允许实习。在本科国奖托底和自己死皮赖脸的坚持下，我现在的导师给加了一个名额，顺利入组。
导师给我明确了CV的研究方向，同时分享了一些资料（因为才学疏浅，当时没能看懂，后面就跑去B站知乎学习了），每周组会汇报自己的学习进度。也是这个时候发现自己对CV挺感兴趣的，也是初生牛犊不怕虎，确定自己走算法岗的方向。
【走出迷茫】2020年11月~2021年2月 夯实基础阶段。 因为导师安排的任务主要偏学术，我也意识到：如果仅仅靠导师的指导、按部就班的学习就去找算法岗工作，是远远不够的。于是，自己找到了一位前辈指点自己系统地入门深度学习。之后制定学习计划、学习基础铺垫知识、筛选和阅读paper、debug源码、参照已开源的工作来复现未开源的论文......在完成导师布置的任务之余，花了大量时间，算是搞明白深度学习的路子了。在此期间，完成导师安排的项目、自己找一些开源的项目补充学习，可以加深自己的理解同时还能润色简历。
当时的部分学习计划（分类&amp;检测篇）
因为搞算法除了python的基本要求外，C++多少也要会一些。也是从这个时候，制定了刷力扣的长期计划，强迫自己学习C++，编程题也全部用C++写。刷题不求多，但重在把思维和语法熟练度锻炼好。
【稳扎稳打】2021年3月~2021年5月 备战实习阶段。 过年给自己放了半个月假，开始着手找第一段实习。听了师兄的建议（当时师兄在鹅厂实习搞开发，respect），开始刷牛客面经，查漏补缺，力扣保证一周刷七题。
同时系统地整理之前学习的笔记，也是这个时候我写了知乎的第一篇博客，并立下了一年写完50篇技术博客的flag（已于2022年4月达成）。
【初露锋芒】2021年5月~2021年6月 第一段实习的投递、面试阶段。 第一次投实习没有经验，先投了一些难度拉满的大厂：商汤、字节都给了面试，但是面得稀烂，商汤的面试官更是在无coding题的情况下问了我两个小时的问题，面试结束后当场自闭。
后来总结了面试失败的经验，也补上了自己面试中没有答出来的知识点。现在想想，当时的我真的是愚蠢至极，就应该先面小厂，积累面试经验，起码不至于面试过后脏了自己的大厂面评（因为秋招的时候，这两家秒挂我的简历，应该是自己作没的 ）。
经历了十多场面试，也积累了足够的经验，最终自己如愿拿到了vivo AI研究院的算法岗实习offer。
【渐入佳境】2021年7月~2022年1月 第一段实习。在我的软磨硬泡下，导师先是同意我出去实习半年（美滋滋）。
入职以后，令人窒息的压力接憧而至：老大给我的研究方向是神经网络结构搜索（NAS）方向 -- 一个自己从来没听说过的预研方向，与此同时，同组的实习生来自武大，还比我早来一个月，需要尽快跟进她的进度。于是，自己白天调研相关工作、复现一些论文、慢慢接手项目，晚上加班读源码、刷博客（卷到了旁边的实习生，实在抱歉）。第一个月顶着压力，总算把进度拉上来，项目步入正轨。
9月，恰好看到Kaggle有个CV新赛，恰好这时候蓝厂取消大小周，于是就报名参加了。之后差不多两个月的时间，白天赶项目，晚上和周末搞比赛。
11月，项目需要优化的模型计算量首次降低到100M以下，同时比赛也拿到了铜牌（第一次参赛，拉胯的成绩，但尽力了）。
后面的时间就是边实习边准备开题，顺利完成了实习阶段的任务，拿到了口头转正（可惜AI研究院今年不招人，靠自己重新走流程拿的影像算法部，权衡了一下，还是想待在自己熟悉且喜欢的组），与nice的同事们告别。
【一波三折】2022年2月~2022年5月 向导师争取了第二次实习的机会，开始着手准备暑期实习，同时和之前实习的武大同学合作一篇论文。但没高兴多久，上海的疫情就爆发了，几乎整个上海的实习HC都没了，与此同时学校疫情封楼，天天牢饭吃到心态爆炸，差点想转开发（庆幸自己没转）。
虽然有了一段大厂实习经历，但找第二段实习甚至更艰难：收到一堆海笔，只收到了三家面试（某周的周一面了美团，面试官很nice，面试也顺利，他还表达了希望我面试通过后早点过去实习，结果周五反手收到个感谢信☺）。磕磕绊绊拿到了第二份offer -- 虹软的计算机视觉算法岗实习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db57564116ea0d60a1845c1262d5e280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1abc41c2df9d056cbb5dcb4bdb5aac7d/" rel="bookmark">
			u盘被格式化了文件还可以恢复吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信不少朋友都喜欢带点文件之类，方便我们随时阅读，而U盘无疑是我们的好助手。让我们把不少的重要文件放置里面，但可能使用中，由于不当的操作或强行拔出等原因而损坏了U盘。这让我们再次使用U盘会提示需要格式化才能使用。这无疑是一件很麻烦的事，只能先尝试撤销看看是否能检查数据，进行备份。如果不行那也只能先格式化操作了，那么u盘被格式化了文件还可以恢复吗?
其实当你的u盘格式化后，不要继续读写u盘，以免数据被覆盖，数据无法完全恢复。建议u盘格式化后用专门的软件恢复数据，这样恢复的数据会更全面，操作也很简单。
这里我们就借助失易得数据恢复软件来看一下具体的操作步骤吧。
第一步：将格式化的U盘连接到电脑上。
注意：当误格式化U盘后，切记不要再对U盘进行任何新的读写操作，以免造成数据破坏。
第二步：运行软件，选择“误格式化磁盘”功能进入，然后选择我们连接到电脑U盘。
第三步：选择自己需要恢复的文件类型，选择完后点击扫描。
第四步：扫描完成后，有很多数据，找到自己认为比较重要和一定要恢复的文件，进行预览，能正常预览就说明文件可以恢复过来，确认自己要恢复的文件之后，勾选起来，点击下方的恢复按键，这样数据就可以全部恢复到电脑上。
保护U盘数据：
1.在用u盘拷贝文件的过程中，尽量减少拷贝数量。
2.文件复制完成后，不要立即关闭相关程序。
3.当系统提示u盘无法拔出时，不要强行拔出u盘，这样会造成u盘的数据丢失。
4.u盘要放在干燥的地方，防止受潮。
5.u盘不用时，及时盖上u盘的盖子，防止表面金属因长期暴露在空气中而被氧化。
6.不要长时间将u盘插入电脑的usb插口，也不要将电影或歌曲放在u盘中播放。
u盘被格式化了文件还可以恢复吗?以上就是解决方法，在日常使用中，要关注u盘的使用细节。希望小编带来的这篇文章能帮到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5032609b18f249000185e2d2352978/" rel="bookmark">
			C语言学习（五）之循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 循环1.1 定义1.2 循环分类1.3 真假判断1.3.1 C语言中真假的示例 二、for()循环2.1 语法2.2 示例程序2.2.1 for循环求和1-102.2.2 for循环求1-10的奇数和2.2.3 for循环求1-100之间能被3整除数的和2.2.4 for循环求1-100之间的奇数之和，奇数的个数，奇数的平均值2.2.2 for循环求1+1/2+...+1/100 2.3 for循环嵌套2.3.1for循环嵌套打印乘法表 三、while()循环3.1 语法3.2 示例程序3.2.1 while循环求和1-100和 3.3 for与while互相转换 四、do...while()循环4.1 语法4.2 示例程序4.2.1 检查输入数字是否正确 五、 break和continue5.1 break5.1.1 示例程序5.1.2 注意事项 5.2 continue5.2.1 for示例程序5.2.2 while示例程序 一、 循环 1.1 定义 在程序中，某些代码会被一直重复循环的执行，直到满足一些条件时，就会退出，这部分的代码就包含在循环结构中。
1.2 循环分类 在C语言中，循环主要有三种，for循环、while循环和do…while()循环。下面会详细介绍。
1、for()循环 2、while()循环 3、do...while()循环 1.3 真假判断 在介绍循环之前，先说明在C语言中对真假的判断。循环是在满足条件为真时，就会退出循环，所以知道对真假的判断就十分重要。在C语言中：
1、非零即真 2、0为假 1.3.1 C语言中真假的示例 #include &lt;stdio.h&gt; int main(){ int num1 = 5; // 5为非零数，则为真。-5时同样的结果 int num2 = 0; // 为0则为假 int num3 = num1 &amp;&amp; num2; // 逻辑与同为真时则为真，有一个为假则为假，所以结果为 0 int num4 = num1 || num2; // 逻辑或同为假时则为假，有真则为1，所以输出结果为 1 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5032609b18f249000185e2d2352978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e05eff969844a0c26fcf365ce9a278/" rel="bookmark">
			SQL数据更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第四章 数据更新
4-1数据的插入（INSERT语句的使用方法）
一、什么是INSERT
二、INSERT 语句的基本语法
三、列清单的省略
四、插入NULL
五、插入默认值（初始值）
六、从其他表中复制数据
4-2 数据的删除（DELETE语句的使用方法）
一、DROP TABLE语句和DELETE语句
二、DELETE 语句的基本用法
三、指定删除对象的DELETE语句（搜索型DELETE）
四、TRUNCATE语句
4-3 数据的更新（UPDATE语句的使用方法）
一、UPDATE语句的基本语法
二、指定条件的UPDATE语句（搜索型UPDATE）
三、使用NULL进行更新
四、多列更新
第四章 数据更新 4-1数据的插入（INSERT语句的使用方法） 一、什么是INSERT INSERT语句可以向表中插入数据（按行插入）。原则上，INSERT 语句每次执行一行数据的插入。
二、INSERT 语句的基本语法 INSERT 语句
INSEERT INTO &lt;表名&gt; （列1，列2，列3，……） VALUES(值1，值2，值3……)；
举个栗子：
INSERT INTO ShohinIns (shohin_id,shohin_mei,shohin_bunrui,hanbai_tanka,shiire_tanka,torokubi) VALUES('0001','T恤衫','衣服',1000,500,'2009-09-20'); 注意：原则上，执行一次INSERT语句会插入一行数据
三、列清单的省略 对表进行全列INSERT时，可以省略表名后的列清单。这是VALUES子句的值会默认按照从左到右的顺序赋给每一列。
四、插入NULL INSERT要想给某一列赋予NULL值时，可以直接在 VALUES 子句中写入NULL。
举个栗子：
INSERT INTO ShohinIns (shohin_id,shohin_mei,shohin_bunrui,hanbai_tanka,shiire_tanka,torokubi) VALUES('0006','叉子','厨房用具',500,NULL,'2009-09-20'); 注意：
想要插入NULL的列一定不能设置NOT NULL约束。向设置了NOT NULL约束的列中插入NULL时，INSERT 语句会出、错，数据插入失败。这里的插入失败是指希望插入的数据无法正常插入到表中，但之前已经插入的数据并不会被破坏。
五、插入默认值（初始值） DEFAULT是对列的一种约束。
举个栗子：
CREATE TABLE ShohinIns ( shohin_id CHAR(4) NOT NULL, hanbai_tanka INTEGER DEFAULT 0; --默认销售单价为0 PRIMARY KEY (shohin_id)); 1、通过显示方式插入默认值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e05eff969844a0c26fcf365ce9a278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20673e65d73dfd0c2187423102cfb057/" rel="bookmark">
			单目深度估计总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 监督的方法单目视频序列深度估计引言方法实验 单目深度估计（单图） 深度图能估计真实的距离吗？如果标签是真实的那么估计的就是真实的，（如果标签是相对的那么估计的就是相对的。） 目前大部分都是用真实的估计 监督的方法 数据集KITTI所提供的的标注来源于激光雷达点云，是离散的，不能获得深度的梯度。如果深度估计方法中用到梯度loss则用KITTI不太好。
四类方向
计算机视觉里的深度是指物体离相机的距离，表示为相机坐标系下的Z坐标值。
相对深度和绝对深度估计
自监督存在尺度不确定性，预测的一般是相对深度。用真值深度图进行训练的监督模型 得到的是绝对深度
为何不用立体视觉估计深度的方法进行单目深度估计？
因为我们针对特定场合使用深度估计需要自己制作数据集，考虑成本等问题使用的是单个相机而不是双相机，就算双目方法可以用于单目深度估计但是训练还是需要双目的数据集。
单目视频序列深度估计 自监督，需要知道时间图像对之间的帧间运动，估计相机的姿态变化或者是否固定【首先找到相邻图像对应点的组合，根据这些匹配的点对计算出相机的位姿（相对初始位置，相机的旋转和平移）】。
论文：MonoDepth2《Digging Into Self-Supervised Monocular Depth Estimation》
本文贡献：提出了
一个最小重投影误差，用来提升算法处理遮挡场景的鲁棒性一种全分辨率多尺度采样方法，可以减少视觉伪影一种auto-masking loss，用来忽略训练像素中违反相机运动假设的像素点 引言 我们提出了 三种架构 和一些可以用来组合的损失项，使得单目深度估计的性能得到大大提升，三种架构分别可以使用 单目视频序列（M），立体双目图像对（S），或者两者结合的方式(MS) 进行训练：
一种新颖的外观表面匹配损失，以解决在使用单目监督时出现的像素遮挡问题一种新颖而简单的auto-masking方法，可以忽略在单目训练图像中没有发生相对相机运动的像素点在输入分辨率下执行所有图像采样的多尺度外观匹配损失，导致深度伪影的减少
基于单目视频训练是一种有吸引力的替代立体图像监督的方法，但它也带来了一系列挑战。除了估计深度外，模型还需要估计训练过程中时间图像对之间的帧间运动。这通常涉及到训练一个以有限帧序列作为输入，并输出相应的摄像机变换的位姿估计网络。
有监督深度估计（可能有单图训练的）
1. 全监督（需要ground-truth depth训练）
代表论文：《Deep Ordinal Regression Network for Monocular Depth Estimation》
数据集：NYU Depth v2（室内，RGB-D）
2.弱监督
论文代表：《Single-Image Depth Perception in the Wild》
数据集：DIW
介绍：这里用的是相对深度标注
论文代表：《Learning Single-View Depth Prediction from Internet Photos》
数据集：Megadepth(合成数据)
介绍：传统的从结构中恢复运动(SfM)管道可以生成摄像机姿态和深度的稀疏训练信号,这里的SFM作为与学习阶段解耦（就是用数学方法将两种运动分离开来处理问题）的预处理。
自监督深度估计
通过对给定图像预测深度，并将其投影到附近的视图中，通过最小化图像重构误差来训练模型。
实验过程：训练时以有限帧序列作为输入，测试时以一个单一的彩色图像作为输入，并预测每个像素的深度作为输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20673e65d73dfd0c2187423102cfb057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf158c79c7d22cb999c4009b7e6c46eb/" rel="bookmark">
			三种家用媒体服务器emby的搭建比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.最简单的是WINDOWS搭建。搜了一下 embyserver下载，下载完成以后解压，双击embyserver.exe就可以完成了，再根据提示输入 本机的IP加端口号，做一些简单设置就完成 了。优点是简单，缺点是WINDOWS相对不太稳定。 2.truenas，truenascale搭建。缺点是下载慢， 步骤稍烦，优点是truenas的zfs，稳定可靠。 3.最方便迁移的搭建。找一台前几年的旧pc， 通常都可以安装vmware esxi6.5，在虚拟机中 安装debian等，再安装docker，portainer，然后 搜索compose emby，找到代码，修改后在portainer中的stack一键部署。最大优点是方便迁移。 缺点是比较复杂。 根据自己的情况，选择这三种，因为他们各有 优缺点。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b337d53b6c8426fa8d05e59f29aa0a/" rel="bookmark">
			【代码记录】pytorch推理及与onnx推理精度对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.pytorch推理 import cv2 import sys import numpy as np import torch, os from torch import nn import torchvision.models as models import torchvision.transforms as transforms from PIL import Image def inference(mat): # preprocess #预处理要保持一致 mean_nom = [0.485, 0.456, 0.406] std_norm = [0.229, 0.229, 0.229] transform_test = transforms.Compose([transforms.Resize((224, 224)),transforms.ToTensor(),transforms.Normalize(mean=mean_nom , std=std_norm)]) img = transform_test(mat) image_data = np.transpose(np.expand_dims(np.array(img, np.float32), 0), (0, 1, 2, 3)) # --- device = torch.device('cpu') net = models.resnet18(pretrained=True) net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b337d53b6c8426fa8d05e59f29aa0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9c9f0e6cdbdeeb8cc34d98bf925570/" rel="bookmark">
			win11鼠标文本选择光标变白色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自 win11--鼠标-文本选择光标变成白色_Loery1314的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d131eddac47d83bbc35e4de826127bd0/" rel="bookmark">
			【Java】String.join()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String.join（）方法 1.语法2.参数3.返回值4.示例 String.join() 方法返回使用指定分隔符拼接一个字符串。
在join() 方法中，为每个元素添加了分隔符。如果为null元素，则添加“null”。
从JDK 1.8开始，Java字符串才包含join() 方法。
1.语法 public static String join(CharSequence delimiter, CharSequence... elements) 或 public static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements) 2.参数 delimiter：每个元素要添加的分隔符
elements：需要添加分隔符的字符串（表示被连接的数组（也可以是集合），或者是要连接的多个字符串）
3.返回值 拼接后的字符串
4.示例 public static void main(String[] args) { // 字符串数组 String []arr={"ab","ce","df"}; System.out.println(String.join(",",arr)); // 集合 List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add("s1"); list.add("s5"); list.add("s3"); System.out.println(String.join("-",list)); // 显示时间 String date = String.join("/","01","25","2020"); System.out.print(date); String time = String.join(":", "12","10","10"); System.out.println(" "+time); } 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d131eddac47d83bbc35e4de826127bd0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/119/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>