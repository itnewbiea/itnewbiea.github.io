<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bf831757b3a2575cac4ecf56358f0d/" rel="bookmark">
			Postman vs JMeter: 如何选择适合你的性能测试工具？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建接口用例集 没区别，Postman是Collections，JMeter是线程组，没什么区别。
步骤的实现 有区别，Postman和JMeter都是创建http请求。
区别1 Postman请求的请求URL是一个整体，JMeter分成了4个部分（协议、主机、端口、路径）。
区别2 Postman可以在请求中直接填写请求头信息， JMeter需要通过添加http请求头管理器添加请求头。
区别3 对于cookie，Postman可以对cookie做管理，但是JMeter只需添加http cookie管理器即可完成cookie的处理，并且是自动处理cookie信息，所以JMeter的cookie管理更简单。
Postman在pre-request script可以添加前置请求，获取响应数据，比较容易进行json结果的处理，很方便地提取json数据。
JMeter不仅可以处理json数据（json提取器），还可以提取其他数据（正则表达式提取器）。
数据用例的实现 区别1 JMeter比较适合进行数据与操作分离，而Postman比较适合把数据和操作放在一起，显然Postman操作更简单，JMeter更便于维护。
区别2 Postman也支持csv数据文件的导入，但是每次执行时都需要收工加载数据文件，不方便（所以只能做半自动化）。
JMeter可以进行完全自动化，特别是引入ant后效果更明显。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：1150305204【暗号：csdn000】 断言的实现 区别1 Postman有很多自带的断言函数，直接引用即可，操作非常方便，JMeter也自带断言组件，操作非常直观。
不过Postman用函数断言，JMeter用元件进行断言。
区别2 JMeter支持正则表达式断言，Postman不支持。
区别3 JMeter的断言更丰富，Postman需要通过编程来实现同样的效果，所以难度更大。
执行 默认执行，Postman不能保存结果，JMeter可以保存结果。
Postman可以通过Newman实现批量执行和保存结果，JMeter可以通过ant实现批量执行和保存结果。
其他 Postman比较适合做手工接口测试，因为简单，可以实现半自动化，一般用来做接口测试，用来发现BUG，验证后台程序。
JMeter比较适合自动化接口测试，因为功能强大并且可以保存脚本，批量执行设置很容易，一般用来做自动化测试，做冒烟测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee1a8c5df8318e49a9cbf23cbe1c25f/" rel="bookmark">
			算法第五天-解码异或后的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解码异或后的数组 题目要求 解题思路 来自[宫水三叶]
这是道模拟（重拳出击）题。
根据题目给定的规则，利用如下异或性质从头做一遍即可：
1.相同数值异或结果为0；
2.任意数值与0进行异或，结果为数值本身；
3.异或本身满足交换律
已知encoded[i-1] = arr[i-1] XOR arr[i]，将等式两边同时[异或]上arr[i-1]。可得：
1.encoded[i-1] XOR arr[i-1] = arr[i-1] XOR arr[i] XOR arr[i-1] 2.结合[性质三]和[性质一]，可简化[右式]得encoded[i-1] XOR arr[i-1] = arr[i] XOR 0
3.结合[性质二]，可简化[右式]得encoded[i-1] XOR arr[i-1] = arr[i]
代码 class Solution: def decode(self, encoded: List[int], first: int) -&gt; List[int]: arr=[first] for num in encoded: arr.append(arr[-1] ^ num) return arr 复杂度分析 时间复杂度： O ( 1 ) O(1) O(1)
空间复杂度： O ( N ) O(N) O(N)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/568a5886053e02bc6f915158716dd549/" rel="bookmark">
			使用pytorch搭建ResNet并基于迁移学习训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里的迁移学习方法是载入预训练权重的方法 net = resnet34() # load pretrain weights # download url: https://download.pytorch.org/models/resnet34-333f7ec4.pth model_weight_path = "./resnet34-pre.pth" assert os.path.exists(model_weight_path), "file {} does not exist.".format(model_weight_path) net.load_state_dict(torch.load(model_weight_path, map_location='cpu')) # for param in net.parameters(): # param.requires_grad = False # change fc layer structure in_channel = net.fc.in_features net.fc = nn.Linear(in_channel, 5) 这里的迁移学习方法是载入预训练权重的方法net = resnet34():注意这里没有传入参数num_classes 因为后面才载入所有的参数，会覆盖我们设定的classes
# change fc layer structure
in_channel = net.fc.in_features # fc 为全连接层 in_features为特征矩阵的深度
net.fc = nn.Linear(in_channel, 5)
如果不想使用迁移学习的方法，则注释阴影部分，在net = resnet34()中传入num_classes参数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65af567bd4c6c3ddcdd19a17b2ce921d/" rel="bookmark">
			Android综合例子——强制下线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为方便管理所有活动，创建ActivityCollector类 //activity管理器 public class ActivityCollector { public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); public static void addActivity(Activity activity){ activities.add(activity); } public static void removeActivity(Activity activity){ activities.remove(activity); } public static void finishAll(){ for (Activity activity : activities){ if(!activity.isFinishing()){ activity.finish(); } }activities.clear(); } } 创建BaseActiviy作为所有类的父类。 （1）注册广播 protected void onResume() { super.onResume(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcastbestpractice.FORCE_OFFLINE");//接收 receiver = new ForceOfflineReceiver(); registerReceiver(receiver,intentFilter); //注册广播接收器 } （2）注销广播 @Override protected void onPause() { super.onPause(); if(receiver !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65af567bd4c6c3ddcdd19a17b2ce921d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93cf7430ccfed833409a9318599e7b2d/" rel="bookmark">
			nexus搭建npm私服 Cannot download “https://github.com/sass/node-sass*******_binding.node“解决办法(亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误看到网上很多帖子都说什么手动下载，什么版本问题，很不实用，我们需要搭建仓库就是为了后面其他同事下载的时候方便，所以就写了这篇经验贴。
在我们本地npm install的时候会有下面两个参数可以配置：
registry=https://registry.npmjs.org/
sass_binary_site=https://npm.taobao.org/mirrors/node-sass/
这两个配置是给大家普及一下，这两个参数，一个是npm的源地址，一个是sass二进制文件源地址。
你在搭建Nexus npm私服时遇到的问题与node-sass的二进制包下载失败有关。这通常是因为node-sass包中包含有本地二进制文件（_binding.node），而在某些情况下，下载过程可能会失败。
解决办法：要在nexus私服中创建另一个类型为 raw(proxy) 的repository，用这个仓库代理淘宝源中的node-sass，也就是相当于我们的sass_binary_site参数
raw就是我们用来代理二进制的库，配置如下：
存储空间这这块，我选择了和之前的三个仓库（npm(group)，npm(hosted)，npm(proxy)）放在同一个存储空间里。
接下来再项目中操作： 在项目根目录下执行以下命令：
npm cache clean --force 清缓存，不然会影响后续操作
第二步： 执行设置代理命令：
npm config set sass_binary_site http://localhost:8888/repository/node-sass 这里的 http://localhost:8888 根据你的nexus仓库地址进行替换。
第三步： 检测代理是否设置成功：
npm config get sass_binary_site 第四步： 重新执行 npm install命令，不再报错，然后run，顺利启动项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64c9c36f14ffcca8c30a0dce0162713/" rel="bookmark">
			Qt不能在线程函数操作UI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt的官方文档虽然并没有明确说明，不能在子线程中操作UI，但是，因为Qt是事件循环机制，所有的UI事件都是在主线程中处理的，如果在子线程中直接操作UI，就会存在线程安全问题，严重时候会使程序挂掉。
但是有些场景确实需要在子线程中操作UI怎么办？以下是几种常用的解决方案：
1. 使用信号槽机制
这种方式是当子线程中需要对ui对象进行操作时，发出一个信号，在与之连接的槽中处理ui操作。信号和槽的连接方式必须是BlockingQueuedConnection 或QueuedConnection 的连接方式连接。
2. 使用自定义event
在子线程中通过QCoreApplication::postEvent 发出自定义的event，在对应的ui对象中重写customevent中处理自定义的event 。
3. 使用QMetaObject::invokeMethod()函数
该函数是一个静态函数，可以直接使用，用于调用对象的元对象方法 。该函数功能很强大，这里是用到了其可以在不同线程之间调用对象方法的特性。
如果是新代码，可以在程序设计之初就处理好子线程与UI操作之间的协调处理，这种情况比较好办，可以使用方法1和方法2进行处理。但是如果是维护历史代码，重新做设计肯定是不现实的，所以就需要使用方法3进行处理，在子线程中操作UI的代码段，修改为QMetaObject::invokeMethod函数调用，可以做到最小程度的代码修改，下面给出具体例子：
// 在子线程中调用 int rowCount = 0； REPORT_DE_INFO reportInfo； bool b = QMetaObject::invokeMethod(this, "initTablewidget", Qt::BlockingQueuedConnection, Q_RETURN_ARG(int, rowCount), Q_ARG(REPORT_DE_INFO&amp;, reportInfo)); 参数说明：
参数1：调用对象指针
参数2：调用的方法名
参数3：连接方式，与信号槽连接函数connect的最后一个参数相同。对于这里是维护历史代码的场景，建议使用BlockingQueuedConnection，原来代码的执行逻辑一定是先执行完函数后才继续往下走，如果这里不给阻塞住，函数还没执行完，子线程就会继续往下走，很显然这与原来的代码逻辑并不相同，很可能会出现错误
参数4：Q_RETURN_ARG宏，用来接收函数的返回值，宏的第1个参数是返回值类型，第2个参数是接收返回值的变量名
参数5：Q_ARG宏，用来向函数传递参数，宏的第1个参数是函数参数的类型，第2个参数是传递参数的变量名，如果函数有多个参数，可以继续往下使用Q_ARG宏来传递
返回值：bool类型，执行成功或者失败
注意：执行的函数一定要是槽函数，否者回执行失败
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e28797f8e845d153455d6642ac687e/" rel="bookmark">
			【获取/etc/passwd文件后的入侵方式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取/etc/passwd文件后的入侵方式 获取到/etc/passwd文件对于黑客来说可能是一个有价值的信息来源，因为这个文件通常包含了Linux系统中所有用户的信息（用户名、用户ID等）。然而，这个文件并不包含用户的密码，密码信息通常存储在/etc/shadow文件中。尽管如此，在获取到/etc/passwd文件后，黑客仍然可以采取一系列步骤来尝试入侵系统：
分析用户信息：
首先，黑客可以分析/etc/passwd文件，了解目标系统上的用户列表，找出可能的弱点。例如，黑客可能会关注具有较高权限的用户（如root用户或其他管理员帐户）或可能未得到适当保护的用户（如默认帐户、服务帐户等）。
暴力破解密码：
通过获取用户名列表后，黑客可以针对这些用户进行暴力破解攻击，尝试猜测用户的密码。这可以通过使用常见的密码字典、暴力破解工具（如John the Ripper、Hashcat等）或使用社会工程技巧（如猜测基于用户信息的密码）来实现。
利用已知漏洞：
黑客可能会针对在/etc/passwd中发现的特定用户或服务，寻找已知的漏洞或弱点。例如，如果黑客发现某个服务帐户使用了过时的软件，他们可能会利用这个软件的已知漏洞来获得对系统的访问权限。
横向移动：
一旦黑客成功入侵了一个用户帐户，他们可能会尝试在系统内部进行横向移动，以获取更高权限的帐户。这可以通过利用本地漏洞、窃取其他用户的凭据（如从内存中提取密码哈希）或利用其他网络资源（如利用已经入侵的帐户访问其他系统）来实现。
提升权限：
当黑客成功入侵一个具有较低权限的用户帐户时，他们可能会尝试提升自己的权限，以便访问更多的系统资源。这可以通过利用内核漏洞、利用配置错误或利用其他已知的权限提升技巧来实现。
数据窃取和勒索：
在成功入侵系统并获得足够权限后，黑客可能会窃取敏感数据（如用户数据、商业秘密等），或者对这些数据进行加密，然后向受害者索要赎金（勒索软件攻击）。
需要注意的是，这些步骤并不是一成不变的，具体的攻击过程可能因黑客的目标、技能和目标系统的具体情况而有所不同。为了防止此类攻击，建议采取一系列安全措施，如定期更新软件、使用复杂的密码、限制用户权限等。
入侵案例1 以下是一个详细的入侵案例，展示了黑客如何利用获取到的/etc/passwd文件来入侵一个Linux系统：
分析用户信息
假设黑客获取到了以下/etc/passwd文件内容： root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin ftp:x:108:65534::/srv/ftp:/usr/sbin/nologin mysql:x:109:114:MySQL Server,,,:/nonexistent:/bin/false 黑客注意到了root用户（拥有最高权限）和mysql用户（可能关联到数据库服务）。
暴力破解密码
黑客决定针对root和mysql用户进行暴力破解攻击。他们使用了暴力破解工具Hydra，结合一个包含常见密码的字典文件（如rockyou.txt），尝试SSH登录： hydra -L users.txt -P passwords.txt ssh://192.168.1.100 在这个例子中，users.txt包含了root和mysql，passwords.txt是包含常见密码的字典文件。
利用已知漏洞
假设暴力破解攻击未能成功，黑客决定寻找可能存在的漏洞。他们发现mysql用户关联到一个MySQL数据库服务，而该服务使用了一个存在已知漏洞的旧版本。黑客使用了名为SQLmap的工具，尝试利用该漏洞： sqlmap -u "http://targetsite.com/vulnerable.php?id=1" --dbms=mysql --os-shell 这个命令尝试利用目标网站上的一个SQL注入漏洞，以获取操作系统Shell权限。
横向移动
假设黑客成功利用了MySQL漏洞并获取了mysql用户的Shell权限。他们现在可以在系统内部进行横向移动。黑客使用了名为Mimikatz的工具，从内存中提取其他用户的密码哈希： mimikatz # sekurlsa::logonpasswords 提升权限
黑客发现了root用户的密码哈希，并使用了John the Ripper工具将其破解： john --format=NT --wordlist=passwords.txt hashes.txt 在这个例子中，hashes.txt包含了从Mimikatz提取的密码哈希。成功破解root用户的密码后，黑客登录到root帐户并获取了最高权限。
数据窃取和勒索
现在，黑客可以自由访问系统上的所有数据。他们决定窃取数据库中的敏感信息，并使用勒索软件加密受害者的文件，要求受害者支付比特币赎金以解密文件。 请注意，这个案例仅用于说明如何利用获取到的/etc/passwd文件进行攻击。实际攻击可能因黑客的目标、技能和目标系统的具体情况而有所不同。为了防止此类攻击，建议采取一系列安全措施，如定期更新软件、使用复杂的密码、限制用户权限等。
入侵案例2 以下是一个详细的入侵案例，展示了黑客如何利用获取到的/etc/passwd文件来入侵一个Linux系统：
分析用户信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e28797f8e845d153455d6642ac687e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec84b4df2826ef8709e0a45d6085182/" rel="bookmark">
			数据结构和算法-B树（B树的查找 B树的最大高度和最小高度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 回顾：二叉查找树五叉查找树如何查找查找成功查找失败如何保证查找效率 B树B树的高度小结 回顾：二叉查找树 五叉查找树 进一步对范围划分，处于不同划分进入不同子树
四个数做划分，此时有五个区间
此时一个节点对应多个关键字,如果叶子节点依然没有对应的关键字，那么即查找失败，然后看看在叶子节点的关键字的哪个区间
此时每个节点可以只有一个关键字，也可以有多个关键字，其对应的子树个数自然也就不同
如何查找 查找成功 9小于22，进入左子树，到左子树的根节点，此时比对关键字，可以顺序找，也可以折半找，此时没找到，但范围区间找到了，此时跳到三个子树的第二个子树上，再次顺序查找，发现找到对应的关键字，查找成功
查找失败 41大于22，首先到右子树去，比对关键字，在对应的第二个子树，进入该子树，再次比对关键字，此时进入对应的第二子树，但此时为空，所以没找到
如何保证查找效率 保证树越矮越好，那么比对次数也就更少
子树个数=关键字个数+1
子树高度都相同
B树 节点多路，然后各个节点的子树的高度都是平衡的，所以称为多路平衡查找树。
m阶B树可为空。此时没有节点
每个节点最多为m颗子树，最多m-1颗关键字
最少的话除根节点的子树最少可以为0，其次是2，如果为1，那么由于此时根节点的关键字含一个树，此时有两个分支，那么其中一个有高度，另一个没有高度，不符合B树的要求
其他节点最少为m/2向上取整。
此时叶节点都是空结点，终端节点不是空节点
非叶节点的结构即当关键字按从小到大排序时，比较关键字时若发现第一个Pi大于所寻找的关键字，那么此时对应的子树根节点为Ki
下面是简单概括
B树的高度 最小高度此时尽可能满，即从根节点开始，都有m个子树，此时每个节点有m-1个关键字。
每行的节点数目是m的次方，每个节点又有m-1个关键字，关键字总树为n
此时n对应上限的是满的m叉树，可以求h的最小值
此时最大高度对应的是分叉最少，此时最少根节点两个分叉，其他节点都是m/2向上取整个分叉
此时利用的是叶子节点的关系
为啥n个关键字的B树必有n+1个叶子节点，是因为此时可以想象一下B树的本质就是分区间，最后对应的区间全部都是落在叶子节点中的，所以说n个关键字的B树，必须有n+1个叶子节点
但此时高度最高的B树对应的叶子节点个数的下限其实为 如图中的第h+1层共有叶子节点……个，因为终端节点的关键字个数可以无限制增加的，
此时假设此时h为最高的B树的高度，那么此时高度最高的B树的除终端节点的节点的关键字数目必须为最小节点关键字总数，终端节点的关键字数目可以大于等于节点最小关键字总数。
所以高度为h的最高的B树，此时的叶子节点树最小就是图中等比得来的，最大得小于终端节点的关键字总数可以多到为此时等比得来得叶子节点的关键字的数模加上终端节点关键字数目，若等于，此时高度还可以增加了
所以此时关键字数目为n的对应的最高的高度为h的B树的叶子节点的关键字的数目一定是大于最高的高度为h的B树的叶子节点的最少数目（等比得来的）
此时利用的是如果关键字总数小于当每个节点的关键字都是最少时构成的树的关键字总数的话，那么此时高度一定小于h，因为此时若依然为h，那么此时由于任何一个节点都不能有更少的关键字，所以失败。所以如果此时最大高度为h时，那么此时关键字总数一定大于高度为h当每个节点的关键字都是最少时构成的树的关键字总数
小结 B：balance。即左右子树平衡，高度一样嘛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dbcdb9d296d46f5dcfd408a333ecbc/" rel="bookmark">
			Hive中支持毫秒级别的时间精度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际上，Hive 在较新的版本中已经支持毫秒级别的时间精度。你可以通过设置 hive.exec.default.serialization.format 和 mapred.output.value.format 属性为 1，启用 Hive 的时间精度为毫秒级。可以使用以下命令进行设置：
set hive.exec.default.serialization.format=1; set mapred.output.value.format=1; 请注意，在设置这些属性之前，请确保你的 Hive 版本支持毫秒级时间精度，并且与底层的存储和查询引擎（如 Hadoop）兼容。
设置完成后，可以使用 TIMESTAMP 数据类型来存储毫秒级时间，例如：
CREATE TABLE my_table( event_time TIMESTAMP ); 然后，可以将毫秒级时间值插入到该表中：
INSERT INTO my_table VALUES ('2023-12-28 10:25:30.123'); 这样，Hive 将能够正确解析和处理毫秒级时间精度。
最后，还需要注意的是，对于旧版本的 Hive，使用字符串或整数来处理毫秒级时间仍然是一种有效的替代方法。这取决于你的具体需求和 Hive 版本。
最好的做法是：
1.将时间的类型转化为字符串类型
2.后面如果要展示进行转化from_unixtime()和unix_timestamp()等函数，来进行时间戳的转换和格式化操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b0660ed97a6add06b85c98f247e789/" rel="bookmark">
			linux x86 setup_arch代码注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人理解加查的资料，不保证正确，有不对可以评论
// 查找个人电脑相关固件占用的地址（来自bootparam中的handler） olpc_ofw_detect(); // 将 early_idts 设置到　idt_table 并应用 lidt，包含 asm_exc_debug asm_exc_int3（breakpoint） idt_setup_early_traps(); // cpu 供应商等简单检查 early_cpu_init(); // 初始化用于动态修改汇编的 jump label 内存 jump_label_init(); // 根据静态调用的结构体生成汇编代码 static_call_init(); // 初始化用于remap的内存，它用于把物理内存映射到pgtable中，用于临时虚拟地址访问，一个remap slot最大可映射32页的内存 early_ioremap_init(); // 将外设的页表项设置到swapper_pg_dir页表的OLPC_OFW_PDE_NR项上，swapper_pg_dir是初始化阶段用的内核页表 setup_olpc_ofw_pgd(); early_reserve_memory(); e820__memory_setup(); // 设置支持 not execute x86_configure_nx(); // reserve boot 的 setup_data中的每个保留内存到页表和e820_table、e820_table_kexec e820__reserve_setup_data(); e820__finish_early_params(); // 为 reserve bft 区域保留内存到页表和memblock 512kB - 1MB reserve_ibft_region(); // 初始化用于访问bios的每个mem设置到dmi_memdev dmi_setup(); // 时钟周期数寄器，可用于计时 tsc_early_init(); // 检测 video system extension adapter 的 rom 区，并注册request_resource x86_init.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b0660ed97a6add06b85c98f247e789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50fba4a2b34361dd68f54f68588fdaa/" rel="bookmark">
			re:Invent 2023技术上新｜Amazon DynamoDB与OpenSearch Service的Zero-ETL集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Amazon DynamoDB 与 Amazon OpenSearch Service 的 Zero-ETL 集成已正式上线，该服务允许您通过自动复制和转换您的 DynamoDB 数据来搜索数据，而无需自定义代码或基础设施。这种 Zero-ETL 集成减少了运营负担和成本，使您能够专注于应用程序。这些负担和成本涉及数据管道架构编写代码、保持数据同步以及通过频繁更改应用程序来更新代码。
通过这种 Zero-ETL 集成，Amazon DynamoDB 客户现在可以使用 Amazon OpenSearch Service 的强大搜索功能（例如机器学习（ML）功能所需的全文搜索、模糊搜索、自动完成和向量搜索），来提供新的体验，从而提高用户参与度并提高对其应用程序的满意度。
这种 Zero-ETL 集成使用 Amazon OpenSearch Ingestion 来同步 Amazon DynamoDB 和 Amazon OpenSearch Service 之间的数据。您可以选择需要同步数据的 DynamoDB 表，然后 Amazon OpenSearch Ingestion 会在数据可用后的几秒钟内将其同步到 Amazon OpenSearch 托管集群或无服务器集合。
您还可以指定索引映射模板，以确保您的 Amazon DynamoDB 字段映射到 Amazon OpenSearch Service 索引中的正确字段。此外，您可以将来自多个 DynamoDB 表的数据同步到一个 Amazon OpenSearch Service 托管集群或无服务器集合，以提供对多个应用程序的全面见解。
开始使用此 Zero-ETL 集成
只需单击几下，您就可以将数据从 DynamoDB 同步到 OpenSearch Service。要在 DynamoDB 和 OpenSearch Service 之间创建集成，请在 DynamoDB 控制台的左侧面板中选择“集成”菜单，然后选择要同步其数据的 DynamoDB 表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50fba4a2b34361dd68f54f68588fdaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd054e92ee8e5ea96269eea8ca0e926/" rel="bookmark">
			易趋产品升级（EasyTrack 11_V1.3） | 集成飞书、WPS、个性化设置，增强团队协作和用户体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业在项目管理过程中，经常会遇到项目信息同步不及时、沟通障碍以及管理软件使用不便捷等难题，导致团队协作效率低下。这种情况下，如果使用了多个办公软件（如：钉钉、企业微信、项目管理软件等），但如果不能支持集成，也会影响信息的流转以及沟通效率。除此之外，如果有管理软件操作复杂、个人工作台页面固定功能过多/过少这些情况，也会进一步影响团队高效协作。
近日，易趋PPM（EasyTrack PPM）为了帮助团队全面提升协作能力，完成了新一轮的产品升级，从“第三方软件集成”以及“个人工作台的个性化设置”这两个维度进行了更新升级。
实现与WPS集成，提升文档在线编辑体验。
实现与飞书集成，高效整合和共享各项数据。
个人工作台支持各种个性化设置，可根据个人工作需求来打造个人工作台，提升使用体验感以及工作效率。
1.实现与WPS、飞书集成，高效协同 1.1实现与WPS集成，支持多人协同在线编辑 在日常项目管理中，一份项目文档可能需要经过多个项目成员的轮流编辑，最终才能定稿。但是由于大家使用的软件不同，可能会出现各种格式不一致的情况，大家也无法做到多人实时进行编辑，这对团队协作工作来说，无疑大大降低了效率。
易趋PPM（EasyTrack PPM）系统的附件与文档支持与WPS集成，能有效提升文档在线编辑体验。
（易趋项目文档—在线编辑视图）
除了支持项目文档的在线预览、编辑、文档转换，还可实现多人实时编辑；同时也支持添加批注与回复，进一步提高企业协同效率。项目文档可自动保存，能查看或恢复历史版本，不必担心数据丢失。
1.2.实现与飞书集成，高效整合和共享各项数据 在企业内部管理中，同时使用办公软件以及项目管理工具的情况很常见，为了确保项目各项信息在企业内部的快速流转，易趋PPM（EasyTrack PPM）支持与飞书集成，通过飞书后台配置后，可通过电脑端和移动端在飞书工作台快捷访问易趋。
（飞书客户端—访问易趋）
（飞书移动端—访问易趋）
易趋（EasyTrack）中产生的消息可推送至飞书端，并支持点击跳转H5页面查看消息详情。同时通过飞书平台访问易趋，其产品功能与易趋移动端的一致，方便用户能随时随地利用碎片化时间处理个人事务，如填报与审批工时、费用、汇报工作以及新建任务等。
(飞书-易趋消息视图）
2.提升团队成员工作效率——满足个性化设置 除了以上与第三方集成的更新，易趋PPM（EasyTrack PPM）为了提升团队成员工作效率，对【个人工作台】也进行了优化，用户可以根据个人工作需求来打造个人工作台，满足个性化设置。
2.1用户可根据个人需求进行 “主题设置”、“常用应用设置” 每位团队成员的工作习惯以及常用的应用都不同，在【个人工作台】，用户根据个人的习惯来设置个人工作台，能进一步提升产品体验感以及工作效率。
首先新增了【主题设置】，支持用户按个人风格设置界面主题色和字体大小。
（易趋-主题设置视图）
（易趋-主题设置视图）
其次为了方便大家能便捷使用常用的应用，新增了【常用应用】菜单，支持将常用应用模块固定在顶部导航栏，提高应用切换效率。
（易趋-常用应用设置视图）
（易趋-常用应用设置视图）
2.2个人工作台新增“常用搜索”， 快速查看各类业务数据 除了常用应用的设置，为了更加快速查看各类数据，在个人工作台还增加了【常用搜索】菜单，可将常用的数据查询添加到个人门户，提高搜索效率，进而提高工作效率。
（易趋-常用搜索设置视图）
（易趋-常用搜索设置视图）
2.3 支持个人自定义列表显示列及位置 各种项目信息内容繁杂，但不同角色的人关注的重点可能不同。在个人工作台，系统新增支持个人自定义列表显示列及位置。
例如在【我的任务】、【我的项目】、【我的会议】以及【搜索】这几个页面，用户可以灵活设置前台列表显示的内容及顺序：可隐藏不关注的内容列，或将更关注的内容移至前面，方便关注重要信息。
（易趋-我的任务显示列设置视图）
3.总结 对于项目管理人来说，影响高效协作的有多个方面，但每天要登录多个软件才能处理完所有的工作、或管理软件操作复杂，应该是主要原因之一。一方面会影响个人体验感，另一方面还要花费大量时间去登录操作。
易趋PPM（EasyTrack PPM）此次产品更新主要从“第三方软件集成”以及“个人工作台的个性化设置”这两个维度进行了升级：实现了与主流办公软件——WPS、飞书的集成；同时支持个人工作台的多项个性化设置，进一步提升体验感，从而全面提高团队协作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a3981e93271ac2191e8a2c54a06ff1/" rel="bookmark">
			金蝶云星空反写规则表结构同步另一个数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 金蝶云星空反写规则表结构同步另一个数据库在BOS找到《反写规则》的表反写规则相关表创建反写规则，或者已经创建好的反写规则定位反写规则数据导出表数据执行脚本BOS导入数据库直接执行 金蝶云星空反写规则表结构同步另一个数据库 在BOS找到《反写规则》的表 反写规则相关表 主表：T_BF_WRITEBACKRULE
多语言表：T_BF_WRITEBACKRULE_L
创建反写规则，或者已经创建好的反写规则 定位反写规则数据 通过反写规则的名字在多语言表找到反写规则的唯一标识，两个表的通过唯一标识关联。
SELECT * FROM dbo.T_BF_WRITEBACKRULE WHERE FID='f899a3be-be66-45ce-b9af-0078e3fa77bf' SELECT * FROM dbo.T_BF_WRITEBACKRULE_L WHERE FID='f899a3be-be66-45ce-b9af-0078e3fa77bf' --FNAME='售后单变更单【保存】反写售后单的变更状态' 导出表数据 两个表都执行以上操作。
同时也会导出xml脚本。
执行脚本 两种方式：BOS导入或者数据库执行执行，选择一个就可以了。
BOS导入 数据库直接执行 /****** 插入主表 ******/ DELETE T_BF_WRITEBACKRULE WHERE FID='f899a3be-be66-45ce-b9af-0078e3fa77bf'; INSERT INTO T_BF_WRITEBACKRULE(FID,FMODELTYPEID,FSUBSYSID,FMODELTYPESUBID,FVERSION,FISTEMPLATE,FKERNELXML,FBASEOBJECTID,FDEVTYPE,FSUPPLIERNAME,FPASSWORD,FINHERITPATH,FMODIFIERID,FMODIFYDATE,FCOMPUTERINFO,FSOURCEFORMID,FTARGETFORMID,FAUTOFITFREEFLOW,FPACKAGEID,FAUTOFITALLFLOWS,FSYSSTATUS,FMAINVERSION) VALUES ('f899a3be-be66-45ce-b9af-0078e3fa77bf',780,null,0,'638351193584503556',null,null,' ',0,'XXXX',null,N' ',102069,{ts'2023-11-09 09:35:59'},'efe6cd0f-95d5-4a44-bb3b-0a11c690664a(MAC:efe6cd0f-95d5-4a44-bb3b-0a11c690664a)&gt;GATE:127.0.0.1;efe6cd0f-95d5-4a44-bb3b-0a11c690664a','XXXX_AS_AfterOrder','XXXX_AS_AfterOrderBG','1',null,'1','0','638351193584503556') ; /****** 插入多语言表 ******/ DELETE T_BF_WRITEBACKRULE_L WHERE FID='f899a3be-be66-45ce-b9af-0078e3fa77bf'; INSERT INTO T_BF_WRITEBACKRULE_L(FPKID,FID,FLOCALEID,FNAME,FKERNELXMLLANG,FDESCRIPTION) VALUES ('6928A260-17DA-41E5-A782-E0496931CBED','f899a3be-be66-45ce-b9af-0078e3fa77bf',2052,N'售后单变更单【保存】反写售后单的变更状态',null,N' ') ; --执行XML的更新，查询被同步的数据库名的表数据，然后执行更新 UPDATE T_BF_WRITEBACKRULE SET T_BF_WRITEBACKRULE.FKERNELXML=t.FKERNELXML FROM ( SELECT FID,FKERNELXML FROM 被同步的数据库名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a3981e93271ac2191e8a2c54a06ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717a05a7dc48f3edd39d3ea7548c6346/" rel="bookmark">
			vue解决执行打包之后打开页面空白问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果我们在执行了build打包命令之后，打开dist目录下的html文件打开页面空白，有几个常见的问题和解决方法
检查控制台报错： 打开浏览器的开发者工具，查看控制台（Console）中是否有报错信息。报错信息通常能够提供有关问题的线索。可能是缺失的文件、错误的路径或其他问题。
相对路径问题： 如果你的应用使用相对路径引用资源，确保这些路径是正确的。在打包后的文件中，相对路径可能会有变化，特别是如果你的应用被部署到不同的路径或服务器上。
服务器配置问题： 如果你尝试在本地服务器上打开 dist 目录中的 HTML 文件，确保服务器正确处理单页应用的路由。如果是使用 Vue Router 并采用了 history 模式，服务器需要配置以支持这种模式。你可能需要配置服务器以在任何路由请求时返回应用程序的入口 HTML 文件。
资源引用问题： 确保在 HTML 文件中引用的资源的路径是正确的。这包括样式表、脚本和其他静态资源。在 index.html 中使用绝对路径或相对路径引用这些资源。
浏览器缓存问题： 尝试清除浏览器缓存，有时候浏览器可能仍然加载旧的文件。
查看打包输出： 在打包过程中，查看控制台输出以确保没有出现任何错误。检查 webpack 打包的日志，确保没有文件缺失或其他异常情况。
本地服务器测试： 尝试使用本地服务器打开应用，而不是直接打开文件。你可以使用一些简单的静态文件服务器，比如 serve 或 http-server。在命令行中进入 dist 目录，然后运行一个本地服务器：
npx serve 或 npx http-server
可以通过以上方法进行检查，我的是路径问题，如下是我的解决方法
首先，在根目录下新建一个vue.config.js文件，然后再文件中输入以下代码
module.exports={ publicPath:'./', } 然后我们再对数据进行打包，打包完成之后再打开html文件就会发现页面已经有内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bad9ee46ed441277d64b7128b45631/" rel="bookmark">
			react pwa应用示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个基于React的PWA应用，你可以使用create-react-app，它自带PWA支持，但默认是关闭的。以下是创建React PWA应用的步骤：
安装create-react-app 如果你还没有安装，你可以通过npm来安装：
npm install -g create-react-app 或者使用yarn：
yarn global add create-react-app 创建新的React应用 npx create-react-app my-pwa 这里的my-pwa是你的应用的名称，你可以根据需要来命名。
将PWA支持激活 进入你创建的应用的目录：
cd my-pwa 然后找到src/index.js文件，将serviceWorker.unregister();改为serviceWorker.register();
启动应用 yarn start 或者
npm start 现在你的应用已经是一个PWA应用了。你可以在浏览器中打开http://localhost:3000/来查看你的应用。
在使用create-react-app初始化的项目中，已经自动包含了一份默认的Service Worker文件，位于src/serviceWorker.js。但是默认情况下，这个Service Worker是未注册的，我们需要手动去注册它。
首先，确保 src/index.js 中已经将Service Worker注册了，如下所示：
import * as serviceWorker from './serviceWorker'; // ... serviceWorker.register(); 修改后，Service Worker就会被注册，并开始控制那些从公共路径访问到的资源。一旦Service Worker被注册，它将开始接收fetch事件并且可以通过一个可配置的响应策略来处理这些事件。
在src/serviceWorker.js文件中，你可以看到预先定义的一些策略。默认，它使用了workbox库来创建一个具有缓存策略的Service Worker。
以下是一个简单的例子，展示了如何使用 Service Worker 缓存应用的静态资源，使得应用在离线状态下仍然可以访问：
// Check if service worker is supported if ('serviceWorker' in navigator) { navigator.serviceWorker .register('./service-worker.js', { scope: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84bad9ee46ed441277d64b7128b45631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c26a3eb7622be603240e77963d6049f/" rel="bookmark">
			PyTorch中各种求和运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先定义张量A
A = torch.arange(20, dtype=torch.float32).reshape(5, 4) tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.], [16., 17., 18., 19.]]) 1. 降维求和
降维求和会沿指定轴降低张量的维度，使它变为一个标量。
A_sum_axis0 = A.sum(axis=0) # 压缩为一行 tensor([40., 45., 50., 55.] A_sum_axis1 = A.sum(axis=1) # 压缩为一列 tensor([ 6., 22., 38., 54., 70.] A_sum = A.sum(axis=[0, 1]) # 结果与 A.sum() 相同 tensor(190.) 2. 非降维求和
保持轴数不变
A_sum_axis0 = A.sum(axis=0, keepdims=True) tensor([[40., 45.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c26a3eb7622be603240e77963d6049f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4d4be265fd99487a2ae80b4f9e2956/" rel="bookmark">
			java基础之-servlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章介绍了servlet，它的生命周期，又介绍了servlet的一个简单demo
一、是什么 servlet是一个运行在web服务器上的， 能接受和响应客户端http请求的，java程序
二、怎么用 一个简单的demo
1、在WEB-INF/web.xml创建一个servlet
&lt;!--名字叫做HelloServlet , 具体的路径是com.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet， url-pattern: 在地址栏上的path 一定要以/打头 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2、写对应的HelloServlet.java文件（需要实现Servlet类的方法）
public class HelloServlet implements Servlet{ public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException { System.out.println("helloServlet..."); } public void init(ServletConfig arg0) throws ServletException { // TODO Auto-generated method stub } @Override public void destroy() { // TODO Auto-generated method stub } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a4d4be265fd99487a2ae80b4f9e2956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3155545d461fefbb6390aa850fd89737/" rel="bookmark">
			算法练习Day23 （Leetcode/Python-回溯算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		46. Permutations
Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
Example 1:
Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 思路：此题可用回溯法做排列问题。待取元素的candiate内无重复，区别于之前的组合问题，这里在横向遍历时for循环需要遍历所有元素，而不是在startIndex之后的元素（因为排列可以取[1,2,3],[1,3,2]这样的元素，组合的话就只能取[1,2,3]，而无[1,3,2]）。但是为了避免与纵向已经取过的元素在一个path里重复，要设置一个used元素记录之前path里已经取过的元素。这个used元素也需要在回溯中调整。 class Solution(object): def backtrack(self, nums, path, result, used): if len(path) == len(nums): result.append(path[:]) # 记得用[:] return for i in range(len(nums)): # use used to remove duplicated item if used[i]: continue used[i] = True path.append(nums[i]) self.backtrack(nums, path, result, used) path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3155545d461fefbb6390aa850fd89737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159d82047940728f046dcf9c73f5d479/" rel="bookmark">
			快速创建一个 Servlet 应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、在 pom.xml 文件中引入 servlet-api 依赖
2、使用注解定义一个 Servlet
3、添加 web.xml 配置文件
4、直接使用 Tomcat 部署 Servlet 程序
5、附：如何在 Idea 中启动一个 Tomcat？
6、解决 Tomcat 控制台乱码问题
1、在 pom.xml 文件中引入 servlet-api 依赖 创建一个普通的 Maven 工程（方便依赖导入），在 pom.xml 中需要引入 servlet-api 的 jar 包，完整的配置信息如下： // Servlet并不是Java SE的一部分，所以引入JDK后，servlet-api 包还要额外引入
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--javax.servlet-api--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建 web 工程的完整目录（主要是明确 web.xml 文件位置，必须在 WEB-INF 文件夹下），参照下图文件结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159d82047940728f046dcf9c73f5d479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09fb3f79d3871cbd5e9e7e87f87cb850/" rel="bookmark">
			svg学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 svg 可缩放矢量图形 svg 使用xml格式定义图像 svg 形状 矩形 &lt;rect&gt; &lt;?xml version="1.0" standalone="no"?&gt; &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt; &lt;svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)" /&gt; &lt;/svg&gt; 代码解释： rect 元素的 width 和 height 属性可定义矩形的高度和宽度style 属性用来定义 CSS 属性CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）CSS 的 stroke-width 属性定义矩形边框的宽度CSS 的 stroke 属性定义矩形边框的颜色x 属性定义矩形的左侧位置（例如，x="0" 定义矩形到浏览器窗口左侧的距离是 0px）y 属性定义矩形的顶端位置（例如，y="0" 定义矩形到浏览器窗口顶端的距离是 0px）CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）CSS 的 stroke-opacity 属性定义笔触颜色的透明度（合法的范围是：0 - 1）CSS 的 opacity 属性定义整个元素的透明值（合法的范围是：0 - 1）rx 和 ry 属性可使矩形产生圆角。 例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09fb3f79d3871cbd5e9e7e87f87cb850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09610508c747f10d965d50a582901348/" rel="bookmark">
			数据可视化——ucharts的使用(自定义修改文字，颜色，自适应屏幕宽度)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.引入 uCharts插件
2.使用组件
1.html 2.css
3.js 4.处理渲染显示宽高问题
3.修改默认渲染数据的内容
1.修改柱状图上面渲染的内容
2.修改点击展示的内容
1.修改展示内容
2.自定义展示内容
4.自定义颜色
5.修改其他设置查看官方文档
官网地址：uCharts官网 - 秋云uCharts跨平台图表库
uCharts是一款基于canvas API开发的适用于所有前端应用的图表库，开发者编写一套代码，可运行到 Web、iOS、Android（基于 uni-app / taro ）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝/京东/360）、快应用等更多支持 canvas API 的平台。
我以微信小程序为例进行展示
1.引入 uCharts插件 https://gitee.com/uCharts/uCharts
到gitee上面下载文件到本地然后在里面找到u-charts.js这个文件放到自己项目里面(放哪里都可以)
在需要用到图表的js页面里面引入这个文件 引入的路径根据自己的位置来
import uCharts from "../../utils/u-charts" 2.使用组件 1.html &lt;canvas canvas-id="column" id="column" class="charts" bindtouchend="tap" /&gt; 2.css // 图表 .charts { display: flex; justify-content: center; align-items: center; width: 100%; min-height: 550rpx; margin-top: 20rpx; } 3.js // 1.定义回款柱状图数据 getData() { //模拟服务器返回数据，如果数据格式和标准格式不同，需自行按下面的格式拼接 // let res = { // 柱状图分类名 // categories: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09610508c747f10d965d50a582901348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1e2b552655064256c879afc3e19589/" rel="bookmark">
			Apache DolphinScheduler 3.1.9 版本发布：提升系统的稳定性和性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀我们很高兴宣布，Apache DolphinScheduler 的最新版本 3.1.9 已正式发布！此版本在 3.1.8 的基础上进行了关键的 bug 修复和文档更新，共计修复了 14 个 bug 和改进了 3 个文档。
主要更新亮点 本次更新重点解决了以下几个关键问题，以提升系统的稳定性和性能：
修复死锁问题：解决了使用任务组抢占资源时可能导致的工作流死锁问题。优化工作流实例：修复了 Master 提交失败后，及时停止工作流实例，避免了无限循环的问题。NPE问题处理：修复了 Master 处理命令时，可能导致 processInstance 出现空指针异常（NPE）的问题。Flink任务命令错误：修复了 Flink 任务生成的命令错误。避免事件堆叠：修复了 Master 重复处理事件，避免了事件堆叠的问题。Switch任务参数检查：增加了 Switch 任务的参数检查，以避免非法情况。任务定义日志问题：解决了任务定义日志可能重复写入的问题。 Changelog 和下载 欲了解完整的更新内容，可以查看 全部 Changelog。
新版本现已可在 官方下载页面 获取。
Bugfix [Bug-15215][Api] non-admin should not modify tenantId and queue #15254 @zhanqian-1993[Bug] fix switch condition #15228 @caishunfeng[Fix-14805] Task definition log may be written twice #15016 @HomminLee[Bug][Master] fix duplicate event, avoid event stacking #14986 @caishunfeng[Fix-14963] Fix the error of using shell task to obtain Home variable in Ubuntu system #14964 @zhuangchong[Fix-14729] fix problem with the command generated by the flink task #14902 @LiuCanWu
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1e2b552655064256c879afc3e19589/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f9cf44e5da3dbb89dbb30ce1d503bf/" rel="bookmark">
			自动化测试与功能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是自动化测试? 自动化测试是指利用软件测试工具自动实现全部或部分测试，它是软件测试的一个重要组成 部分，能完成许多手工测试无法实现或难以实现的测试。能够正确、合理地实施自动测试，可以 快速、全面地对软件进行测试，从而提高软件质量，节省经费，缩短软件发布周期。
自动化测试一般分为UI 自动化测试和接口自动化测试。
UI自动化测试是指基于界面元素的自动化测试。需要先定位界面元素的路径，然后通过脚本 实现自动化。这种方法因为界面需求的变更频繁，脚本更新频繁，不利于后期的维护工作，造成 自动化工作的成本巨大，已经慢慢被各大公司所淘汰。
随即演变出的就是接口自动化了。接口自动化是指模拟程序接口层面的自动化，由于接口不 易变更维护成本小，所以它深受各大公司喜爱。接口自动化也是本书的重点。它包含两个部分， 功能性的接口自动化测试和并发接口自动化测试。
自动化测试与手工测试的区别 自动化测试和手工测试并没有高低贵贱之分，虽然划分在不同的阶层，但只是出于对测试人 员个人的价值评判而已。以下详细解析这两者的区别。
1．测试目的不同
虽然都是测试，但这2种测试的目的却是截然相反的。
手工测试的目的在于通过“破坏”发现系统有bug。自动化测试的目的在于“验证”系统没有bug。 当测试系统处于前期不稳定的时候，做自动化测试将毫无意义，因为程序运行到一半就会因 为某个bug而停止的，而当这个bug未被修复之前所有的自动化测试都会卡在这里无法往下执行。 而当测试系统处于稳定的时候，通过手工测试重复着一样的操作也会变得烦琐和枯燥，所以这两 者在不同的测试阶段都有着不可替代的作用。
2．覆盖范围不同
除了目的的不同，覆盖范围也是不同的。
手工测试可以尽可能地覆盖测试系统的各个角落。自动化测试只能覆盖测试系统的主要功能。 试想把所有的测试用例都弄成自动化是一件多么美好的事情，但代价实在太大了，投入的时 间和产出完全不成正比，不夸张地说如果要做到完全自动化测试，所需要的代码量会远远超过开 发编写程序的代码量。所以自动化测试只能挑一些重要和稳定的功能来做，而更多的一些细节的 测试还需要手工测试来完成。
3．智能判断不同
自动化和手工测试还有一个最大的区别是智能判断方面。 计算机程序对于人而言是绝对的服从和诚实的。
举个例子，用计算机程序去计算1＋1，结果必然等于2（除非你的程序本身写的有bug， 这不是计算机程序的问题），而如果问一个人1＋1等于几，可能会有一个答案“1＋1等于我 们”，那这个结果是对还是错呢？如果交给程序判断必然是错的。因此智能判断是自动化测试的 瓶颈，一个操作出现多种结果可能都是对的，但又可能都是错的。
再举个电商的例子，比如有个特价产品只有一份，需要秒杀，有可能抢到，也有可能抢不到。 对于能抢到来说，只有“他”1个人抢到是对的，如果多个人都能抢到那就是错的。对于不能抢 到来说，已经有1个人抢到就是对的，如果没有一个人抢到的话就是错的，这个时候自动化测试 程序该如何判断结果的对错呢？这样的情况比比皆是，虽然有办法通过程序去预置各种条件让结 果唯一化，但需要花大量的时间和精力去优化自动化测试代码，并且还需要分多个自动化测试程 序完成，这个时候还不如人工介入测试进行判断来得方便。
这样看来其实自动化测试能做的还是非常有限的，而更多的时候还是需要手工测试，利用工具也好，逻辑判断也好，又或者让开发修改程序来配合测试也好，总之能达到测试的最终目的就好，从这个意义上来说手工测试也并非没有技术含量，而自动化测试也没有那么无所不能。
同时，我也为大家准备了一份软件测试视频教程（含面试、接口、自动化、性能测试等），就在下方，需要的可以直接去观看，也可以直接点击文末小卡片免费领取资料文档
软件测试视频教程观看处：
2024年Python自动化测试全套保姆级教程，70个项目实战，3天练完，永久白嫖...
自动化测试的困境 自动化测试具有很大的优势，一劳永逸地用程序代替人力，人力干活8小时，而程序可以24小时不停止地干活。但是自动化测试还有一个很大的困境，即由于自动化测试很难持续维护，导致在大多数公司无法普及这种测试方式。
IT行业的竞争日益激烈，产品要保持自身的竞争力就需要不断高速迭代新版本、新功能。这就意味了原来写的自动化测试程序变得不可用了（其中的部分程序），而留给测试人员的时间又往往是很少的，于是只能手工测试保证按时上线，等上完线之后可能过几天又有新的功能要测试。留给测试的时间不够完成自动化测试程序的维护更新，周而复始，久而久之，原来的自动化测试程序已经和当前版本相去甚远了，最后自动化测试就不了了之了。我想这就是人们常说的“愿望是美好的，但现实总是残酷的”。
既然知道是困境，必然就是很难解决的，那有没有折中的办法来减少一定的维护成本，又可以达到一定的自动化测试的目的呢？回答这个问题之前先要看透自动化测试的核心本质，就是元素识别＋元素操作＋验证结果，大多数自动化测试工具都会提供元素识别和元素操作（鼠标点击、键盘输入、屏幕 touch等），只有在验证结果的时候需要写代码提取实际结果，然后和预期结果进行比较，最后得出测试通过或者不通过的结论。
其实对于写代码的部分来说都是通用的，不同的地方在于获取实际结果的方式变更或者预期结果的变更，工作量并不多。真正烦琐之处在于元素的识别，每个元素其实都由唯一标识来识别，这样才能保证不会操作错元素，好处在于如果元素不变，那唯一的标识也永远不会识别错，这是自动化测试可以实施的基础。但有利自然有弊，一旦元素变了，原来的标识就不可用了，那自动化测试就无法实施了。说到这里如果可以绕过元素识别这一步，将元素操作以接口的形式通过脚本完成，就可以抛弃重量级的自动化测试工具，而通过测试脚本直接实现接口自动化测试。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！凡事要趁早，特别是技术行业，一定要提升技术功底。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d7c7298d1678d13c4072cf2890b68a/" rel="bookmark">
			生成式 AI 原生开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何成为生成式AI原生开发者，快速进入：
下一站 GenAI @ QCon 上海站喊你上车啦！
无限构建，成为生成式 AI 原生开发者，12 月 28 日，下一站 GenAI @ 巴士即将抵达 QCon 全球软件开发大会·上海站，码上出发，Let’s 构！
大会高光环节，提前剧透
主题演讲，高能预警
本次 QCon 全球软件开发大会·上海站，亚马逊云科技大中华区解决方案架构部总经理代闻将和大家分享“云端俭约之道：如何设计出成本优先的技术架构”，大家千万不要错过哦～
主题演讲精彩纷呈，线上直播同样不容错过。12 月 28 日（周四）14:00-17:40，亚马逊云科技资深人工智能产品市场经理宋洪涛作为专题出品人，将与亚马逊云科技人工智能技术专家李元博、亚马逊云科技人工智能技术专家郑昊、亚马逊云科技资深培训讲师张文举博士以及亚马逊云科技解决方案架构师肖元君，带来“加速生成式 AI 落地的最佳实践”的专题直播，深度探讨如何借助亚马逊云科技的技术，打通生成式 AI 应用落地的“最后一公里”，加速项目从 PoC 到 Production 的转化。
感兴趣的小伙伴可以关注【亚马逊云科技】视频号，预约直播！！！
生成式 AI 探索之旅，上车体验
认认真真学，开开心心玩，下一站 GenAI @ 喊你上车！满载 re:Invent 2023 发布惊喜，和开发者们来一同探索生成式 AI 的无限可能！
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/433a3be0c7d74457a3b097ee00f2350e.jpeg#pic_center) 别眨眼！下一站 GenAI @ 快闪详解
构意思！没看够？
上海、南京、杭州
下一站 GenAI @ 在每个城市都留下了精彩瞬间
开发者们快跟云师兄一起来看吧！
下一站 GenAI @ 上海站
（视频1）
下一站 GenAI @ 南京站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d7c7298d1678d13c4072cf2890b68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a52ff581ad2e51271a1b023cb9d0b7/" rel="bookmark">
			从0到1搭建电商数据分析平台：电商分销运营监测、产品销售分析和风控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享就是电商分销场景的数据分析。制作团队实际电商体系运营监测与风险识别预警分析需求，利用FineBI搭建分析监测平台，打通电商分销业务数据分析链路，进行常态化运营监测与风险识别预警。下面就展开看看。
01 背景及痛点 1、背景概况 随着时代发展，公司积极拓展电商业务，开设经销商，销售高速增长，但在持续且快速的攻城略地过程中，产生了一些发展风险，需要更加精细化的数据运营管理进行管控。
2、问题分析 经销商数量快速扩张，经销商、店铺体系运营缺乏实时和高效率监测；电商分销业务销量波动大，存在经销商窜货问题，线下渠道秩序受到干扰；乱价问题时有发生，对公司、经销商盈利造成不利影响；公司销售投入产出缺少完整的专项评估分析平台。 02 业务需求 利用RPA技术获取经销商店铺GMV数据，统筹进出货及费用相关数据进行全量分析，需要搭建分析平台，主要从以下三大模块开展：
整体运营概况分析与监测：为费用投入及管理提供数据分析支撑，常态监测体系健康发展；产品销售分析：从各维度分析产品销售对比，挖掘产品生意机会；风险识别与预警：监测动销、刷单、破价等异常指标，识别潜在风险，协助输出风控策略。 03 整体分析框架分析框架 本文对于电商运营分析与风险识别预警从以下三个角度展开，分别是整体运营概况分析与检测、产品销售分析和非业务分析识别与预警。
整体运营概况分析与监测：体系概况、运营概况和销售费率及运营监测分析；产品销售分析：产品销售结构分析、重点产品销售分析和新产品销售分析；非业务分析识别与预警：预警概览、出货进货比、单订单销量、实际售价。
04 免费获取库存管理模板及工具： 1、报表及图形选取框架 利用多维数据聚合分析，从三大模块做分析报表体系，在实际中结合经营过程需求分别分析问题，支撑决策、干预经营从而促进电商渠道长久健康发展。
2、各模块可视化报表及实现 ①模块一：概况分析与监测结构及实现概览分析：通过客户数、店铺数、销量、价格、订单、退货、毛利等指标常态化通过各类指标监测电商体系运营情况及趋势。
体系运营监测：分销售区域监测客户数、进出货比、店铺数、活跃及销售。
卖力、价格、临期品、退货监测：分销售区域、客户监测订单、均价、大日期、毛利等情况。
客户盈利监测：分销售区域监测进货、出货、投入的费用费率、毛利情况。
投入产出费率监测：费率为重点，单独报表分地域、时间监测投入产出及变化情况。
②模块二：产品销售分析结构及实现概览分析：基于EDI电商销售数据，筛选所需日期及整体/分业务单元数据，从各维度挖掘生意机会辅助和支撑电商销售运营。
渠道维度分析：挖掘电商相对于线下占比更高的产品，属于电商渠道优势产品，重点发展。
平台维度分析：平台销售产品的占比分析，看到不同平台背后消费者的消费偏好，为厂商在不同平台产品发展策略提供数据支撑。
业务单元维度分析：分业务单元产品销售占比及变化，业务单元产品发展指引。
新品发展分析：重点围绕销售渠道、平台、业务单元的新品销售占比分析，挖掘新品发展的薄弱环节，支撑运营改善。
重点产品发展分析：左边按照产品占比降序排列，点击对应产品名称，右边绘制产品的正常日期、大日期产品，分业务单元、平台的销售价格，重点监控破价的地区和渠道。
③模块三：业务风险识别与预警结构及实现风险指标概况：动销、刷单、破价指标整体分业务单元概况。
结案风险分析：累计出货/累计进货指标，如果高于100%，可能存在多结案获取公司费用风险。
动销风险分析：当月出货/当月进货指标，当月出货/进货&gt;200%或≤50%，单位均为提数。理想状态下出货提数与进货提数应该基本相等，过大或过小均有潜在动销问题。如果长期的出货远小于进货，可能存在窜货的风险，出货/进货过大的可能出现刷单的风险，特别是有订单件数、但没有订单金额的，可能出现刷空单的违规行为。
刷单风险分析：单笔订单提数&gt;50定义为大单，出现大单的认为存在刷单风险，通常刷单风险与破价风险关联，单笔提数过大的可能价格非常低。
破价风险：实际售价&lt; (规定售价-5元)定义为本单破价，参考客户组口径考虑到5元优惠券给出一定折扣空间，但是EDI所有SKU平均价格低于电商价盘，存在大量破价问题。
如果经销商同时存在动销风险、刷单风险、破价风险，则需要重点关注。除此之外，其他风险指标还有费用率和窜货次数等可以综合考量。
3、可视化报告案例解析 FineBI完成可视化平台搭建，分别从概况监测、产品销售分析、风险识别与预警模块形成体系，依靠本平台每月实现常规运营监测、产品销售机会挖掘、风险识别预警，以下为实践案例之一：
1、动销比监测与风险分析案例：通过BI看板在常态化的概况监测中识别动销异常，风险分析下钻找到具体风险来源，结合业务场景识别风险、分析风险、策略优化、解决风险，支撑电商体系健康长久发展。
① 2022年9月，我们完成平台搭建，2022年12月月度常态指标监测，发现整体出货/进货动销指标异常，8-12月累计出货/进货比XXX%。
②风险识别下钻分析：我们从区域动销比值维度对比，各销售大区存在出货高于进货的情况，这说明8-12月指标异常属于普遍现象。
③我们再从时间维度查看，发现高出货/进货比出现在11-12月特别异常，11-12月涉及年底，结案费用政策节点，指标异常代表可能出现一定业务层面的问题。
④我们结合业务层面维度分析，通常库存在半个月-1个月属于正常范围，此处出货大于进货异常，这其中可能存在假出库获取补贴风险。⑤我们通过风险分析BI看板继续下钻分析，客户层面也出现指标异常，再通过订单异常分析发现了一些高销售量订单的情况，下图从经销商和订单层面排名分析印证结论：
⑥依据数据分析结果，我们应该如何解决问题，接下来从三个方向解决了此类问题，方向一是全国统一调整了费用策略；方向二是强化常态分析监理手段，通过FineBI平台月度常态监测分析；方向三是开发结案核算工具模型，通过自动对接进货量，解决了核算问题。
下图为风险常态化监测分析月报，常态监测分析风险并输出排名：
下图为结案核算工具图（自动核算应结案金额，避免人为修改进货量问题）：
4、实现价值 2022年8月项目投产后，进出货差异率降低至4.6%，同比下降14.7%，较上线前下降33.8%，产品流向数据真实监测，窜货行为得到明显改善。
本分析案例的作者为伊帆队，作品荣获帆软2023BI数据分析大赛最具业务价值奖。
这份电商数据分析作品，从“整体运营概况分析与检测、产品销售分析和非业务分析识别与预警”三大模块展开，分析框架详尽、相关指标描述清楚，基于企业数据，数据处理逻辑清晰，仪表板规划明确，作品业务实际意义强。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae75a507b7409ed3584ee0bd1e5bace6/" rel="bookmark">
			Ubuntu 2x.04 编译FFmpeg 脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 将脚本放在 FFmpeg 元文件根目录
2. 编译结束后结果放该目录下的install文件夹中
#!/bin/bash THIS_PATH=$(cd $(dirname $0); pwd) BUILD_DIR=${1:-${THIS_PATH}/build} INSTALL_DIR=${THIS_PATH}/install #----------------------------------------------------------------- # refer to https://packages.ubuntu.com/search?keywords=libdav1d-dev # libdav1d-dev is supported since Ubuntu 22.04 #----------------------------------------------------------------- # sudo apt install libunistring-dev libaom-dev libdav1d-dev sudo apt install libgnutls28-dev libass-dev libmp3lame-dev libunistring-dev libaom-dev sudo apt install libfreetype-dev libopus-dev libx264-dev libx265-dev sudo apt-get install libfdk-aac-dev libsvtav* libvorbis-dev libvpx-dev #----------------------------------------------------------------- #----------------------------------------------------------------- #wget -O ffmpeg-snapshot.tar.bz2 https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2 &amp;&amp; \ #tar xjvf ffmpeg-snapshot.tar.bz2 &amp;&amp; \ # cd ffmpeg &amp;&amp; \ ## NUM_CORES=$(nproc) PATH="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae75a507b7409ed3584ee0bd1e5bace6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93228f847d5b014dd126bced7dd71a3/" rel="bookmark">
			C&#43;&#43;基础普及：如何学好常用的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，常用的数据结构包括但不限于以下几种：
数组（Array）：一组相同类型的元素按顺序存储在连续的内存空间中。
链表（Linked List）：由节点组成的数据结构，每个节点包含数据和指向下一个节点的指针。
栈（Stack）：一种后进先出（LIFO）的数据结构，只能在栈顶进行插入和删除操作。
队列（Queue）：一种先进先出（FIFO）的数据结构，只能在队尾插入元素，在队首删除元素。
树（Tree）：一种非线性的数据结构，由节点和边组成，每个节点可以有多个子节点。
图（Graph）：由节点和边组成的非线性数据结构，节点之间可以有多个连接。
哈希表（Hash Table）：通过哈希函数将键映射到存储位置，实现高效的查找和插入操作。
堆（Heap）：一种特殊的树结构，常用于实现优先队列，具有最大堆和最小堆两种形式。
要熟悉掌握这些数据结构，可以采取以下几个步骤：
学习理论知识：了解每种数据结构的基本概念、特点和操作，包括其优缺点和适用场景。
实践编码：使用C++编写各种数据结构的实现代码，包括插入、删除、查找等常见操作。通过实践加深对数据结构的理解。
理解底层原理：了解数据结构的底层实现原理，包括内存分配、指针操作等。这有助于优化代码和理解数据结构的性能特点。
解决问题：尝试使用不同的数据结构解决实际问题，例如使用链表实现LRU缓存，使用树实现文件系统等。通过解决问题来加深对数据结构的应用和理解。
阅读源码和学习库：阅读开源项目或标准库中关于数据结构的实现代码，学习优秀的设计和实现方式。
练习算法题：参与算法竞赛或刷LeetCode等在线平台的算法题，这些问题经常涉及到对数据结构的灵活应用和优化。
通过不断学习、实践和思考，结合实际项目经验，逐渐积累对数据结构的熟悉和掌握。同时，与其他程序员交流和分享经验，参与开源项目等也是提升熟练度的好途径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e476e47c10ca570c53697f6fe280131/" rel="bookmark">
			maven使用笔记、常用命令、环境变量等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境变量基本命令文档： 环境变量 环境变量里面添加
MAVEN_HOME=D:\apache-maven-3.2.5(maven软件所在地址)
path添加 ;%MAVEN_HOME%\bin
如果是win10及以上不要加分号。
查看依赖树
+-表示可能还依赖其他包
\-表示不依赖其他包了
mvn dependency:tree # mvn dependency:tree -Dverbose # 会输出详细内容 mvn dependency:tree -Dincludes=com.alibaba:fastjson # 查看某个具体的依赖(这个不能模糊搜索，不方便) mvn dependency:tree | findstr fastjson # 模糊搜索 基本命令文档： mvn --help #cmd下 man mvn 或 mvn --help #linux环境 apache官网文档：
http://maven.apache.org/
一些在线书籍也很好:
https://books.sonatype.com/mvnref-book/reference/running-sect-options.html#running-sect-define-prop
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641426d22d03e15b6aa2c39fae6a97f5/" rel="bookmark">
			新能源汽车与计算机技术：共创智能出行新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新能源汽车与计算机技术：共创智能出行新时代
一、引言
新能源汽车以其环保、节能的特性逐渐成为未来出行的趋势，而计算机技术的融入则为新能源汽车带来了前所未有的变革。从电池管理到自动驾驶，再到车联网，计算机技术在新能源汽车领域的应用日益广泛。
二、计算机技术在新能源汽车中的应用
1.电池管理系统（BMS）：通过计算机技术对电池进行智能化管理，实现电池的均衡充电、安全保护和高效利用。
2.电机控制技术：利用计算机算法精确控制电机的运行，提高车辆的能效和动力性能。
车载娱乐与信息系统：基于计算机技术的车载娱乐系统、导航系统和信息娱乐系统，提供丰富的用户体验。
3.自动驾驶技术：通过计算机视觉、传感器融合等技术实现汽车的自动驾驶功能。
4.车联网（V2X）技术：利用计算机通信技术实现车与车、车与基础设施、车与行人之间的信息交换，提高行车安全和交通效率。
三、技术革新与市场机遇
1.能效提升：通过计算机技术优化电池管理和电机控制，提高新能源汽车的能效，延长续航里程。
2.智能驾驶体验：借助计算机视觉和传感器融合技术，为用户提供更加安全、舒适的自动驾驶体验。
3.互联互通：车联网技术的发展使得新能源汽车能够更好地融入智慧城市交通体系，提高交通效率和安全性。
4.市场拓展：随着技术的成熟和消费者认知的提高，新能源汽车市场将进一步扩大，为产业链上下游企业带来巨大商机。
政策支持：各国政府对新能源汽车的大力支持，将加速相关技术的研发和市场推广。
5.环境友好：新能源汽车有助于减少碳排放和其他污染物排放，改善空气质量，缓解全球气候变化。这为人类创造一个更加绿色、健康的出行环境。
6.产业带动：新能源汽车产业的迅速发展将带动相关产业链的发展，如电池制造、电机生产、智能硬件等领域。这有助于促进经济的可持续发展和创造更多就业机会。
7.跨界合作与创新：新能源汽车与计算机技术的结合将激发更多跨界合作和创新，如与通信、互联网、人工智能等领域的融合发展，进一步推动产业升级和商业模式创新。
8.教育和培训需求增加：随着新能源汽车技术的不断发展和普及，对相关教育和培训的需求将不断增加。这将促使教育机构和培训机构调整课程设置，培养具备专业技能的人才来满足市场需求。同时，这也为个人提供了学习和提升技能的机会，促进职业发展。
9.国际合作与交流加强：面对全球气候变化和环境问题，各国在新能源汽车领域的合作与交流将进一步加强。国际合作将促进技术共享、标准统一和市场拓展，提高整个行业的竞争力。同时，也为各国企业提供了更多的商业机会和合作空间。
10.基础设施的完善：随着新能源汽车的普及，对充电设施、氢气加注设施等基础设施的需求将大幅增加。这将促使政府和企业加大对基础设施的投入和建设，推动相关产业链的发展和完善。同时，基础设施的完善也将为新能源汽车用户提供更加便捷的服务和更好的使用体验。
12.用户参与和社群建设：新能源汽车的用户群体逐渐形成，通过线上社区、线下活动等方式加强用户之间的交流和互动。这有助于形成良好的用户生态圈，推动新能源汽车文化的传播和发展。同时，也为品牌推广和产品改进提供了宝贵的用户反馈和建议。
13.安全性和可靠性提升：随着技术的不断进步和研究的深入，新能源汽车的安全性和可靠性得到持续提升。通过计算机技术的运用，如智能监测、故障诊断和预防性维护等手段，可以大大提高车辆的安全性能和使用寿命。这将增强消费者对新能源汽车的信任度和接受度。
14.用户体验的优化：借助计算机技术和智能化手段，新能源汽车在驾驶辅助、导航指引、能源管理等方面为用户提供更加便捷、舒适和个性化的服务。这将进一步提升用户对新能源汽车的满意度和忠诚度。
15.品牌塑造和文化传播：新能源汽车企业通过打造品牌形象、推广环保理念和文化活动等方式，增强品牌影响力和社会责任感。这将有助于塑造良好的企业形象和提升品牌价值。同时，也有助于传播绿色出行和可持续发展的理念，推动社会对环保的关注和支持。
四、挑战与前景展望
尽管新能源汽车与计算机技术的结合带来了诸多机遇，但仍然存在一些挑战和需要解决的问题：
1.技术瓶颈：尽管电池技术取得了显著进步，但提高能量密度、缩短充电时间、降低成本等方面仍面临挑战。同时，自动驾驶技术也需要在安全性、可靠性和法规方面取得突破。
2.基础设施不足：充电设施和氢气加注设施的普及仍需时间，尤其是在偏远地区。
3.成本问题：新能源汽车及其相关技术的成本仍高于传统汽车，这限制了部分消费者的购买意愿。
4.市场接受度：尽管政策支持和技术进步都在推动新能源汽车的发展，但消费者对新能源汽车的认知和接受度仍有待提高。
5.数据安全与隐私保护：随着车载计算机系统和车联网技术的发展，数据安全和隐私保护成为重要问题。
五、前景展望
尽管面临挑战，但新能源汽车与计算机技术的结合仍具有广阔的发展前景：
1.技术革新：随着电池技术的进一步突破和自动驾驶技术的成熟，新能源汽车的性能将得到大幅提升。
2.市场规模扩大：随着消费者对新能源汽车认知的提高和基础设施的完善，市场规模将进一步扩大。
3.产业协同发展：新能源汽车的发展将促进与能源、通信、基础设施等产业的协同发展，形成更加完善的产业链。
4.政策支持：各国政府对新能源汽车的支持力度将持续加大，推动其快速发展。
5.环保需求驱动：随着全球环境问题的日益严重，人们对环保出行的需求将更加迫切，这将驱动新能源汽车市场的进一步增长。
6.智慧城市与智能交通的融合：新能源汽车将成为智慧城市和智能交通体系的重要组成部分，推动城市交通向更加高效、绿色和智能的方向发展。
7.国际合作与交流的深化：各国在新能源汽车领域的合作将进一步加强，共同推动技术的进步和应用范围的扩大。
8.跨界创新与商业模式变革：随着技术的不断进步和市场的不断扩大，将涌现出更多创新的商业模式和服务，为用户带来更加便捷和个性化的体验。
9.教育与培训体系的完善：随着新能源汽车产业的不断发展，对相关教育和培训的需求将不断增加。未来将有更多的教育机构和培训机构提供专业的课程和培训，以满足市场对高素质人才的需求。同时，政府和企业也将加大对教育和培训体系的投入，以培养更多的专业技能人才和创新型人才。
10.社区文化与品牌价值的提升：随着用户群体的不断扩大和社群建设的深入，新能源汽车的文化价值和社会影响力将不断提升。品牌将更加注重与用户的互动和沟通，打造独特的品牌文化和价值观，提升品牌知名度和美誉度。同时，新能源汽车也将成为环保出行和社会责任的重要代表，引领社会潮流和价值观的变革。
六、结论
新能源汽车与计算机技术的结合为出行领域带来了革命性的变化。在技术革新、市场需求和政策支持等多重因素的推动下，新能源汽车的发展前景广阔。然而，仍需克服技术瓶颈、基础设施不足和市场接受度等问题。未来，需要进一步加强研发、推广和应用，促进产业链的协同发展，推动新能源汽车成为可持续出行的主导力量。同时，政府、企业和社会各界应共同努力，加强合作与交流，共同应对全球环境挑战，为创造一个更加绿色、智能和美好的未来贡献力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d38d1b3bcfab05eedabf972b44d1f8/" rel="bookmark">
			【PowerMockito:编写单元测试过程中采用when打桩失效的问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 正如上图所示，采用when打桩了，但是，实际执行的时候还是返回null。
解决方案 打桩时直接用any()
但是这样可能出现一个mybatisplus的异常，所以在测试类中需要加入以下代码片段：
@Before public void setUp() { TableInfoHelper.initTableInfo(new MapperBuilderAssistant(new MybatisConfiguration(), ""), SubnetInfoDto.class); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d76fe1ca8baa6921663ef662f2f8db/" rel="bookmark">
			扎根底层技术，推动机器人换代式升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热赛道和冷市场的矛盾之下，机器人需要一次换代式升级。
冷中有热的资本市场
在宏观经济下行的影响下，我国服务机器人产量从2022年开始出现明显放缓，2021年12月至2022年12月，我国服务机器人产量都处于同比下滑的状态，一时间，行业明显转冷。
与此同时，今年的资本市场也到处充斥着寒气。根据中国机器人网统计，2022年机器人行业融资事件超300起，融资金额过亿的超100起，总融资金额超300亿。与去年相比，今年的融资次数和金额明显下降，至6月30日，今年国内机器人行业融资事件共63起，已披露金额的融资事件中亿元级融资18起，融资金额总计约在50~60亿元之间。不过相对于投资市场普遍收缩，机器人赛道热度并没有减少，仍是投资焦点。
事实上，机器人市场出现降温，经济大背景纵然是重要原因，但近几年的爆炸式增长也充斥着大量泡沫，当增长势能难以维系，机器人本身产品力不足的问题就再也无法忽视，如质量问题、价格问题等。
商用机器人目前的价格大多在几万到十几万之间，替代价值不明显，导致终端用户购买意愿不高。根据亿欧数据测算，清洁机器人的替代成本上限约为3.7-6. 3 万元/月；讲解引导机器人的替代成本上限约为0.6-1. 4 万元/月；终端配送机器人的替代成本上限约为0.6-2. 4 万元/月，同时由于实际场景的应用限制，作业效率差距也较大，这会导致替代价值进一步下降。
同时，商用机器人还存在着各种产品问题，部署周期长、场景适应能力差、避障能力差等，机器人并没有发挥出应有的价值。
家用方向的扫地机器人同样有着较多问题。在厂商们的持续堆料下，机器人的清洁能力、导航能力、避障能力、智能化水平都得到了显著提升，消费者们也对这类产品有了一定认可，但堆料带来的成本问题也导致机器人售价不断拔高。
根据奥维云网数据显示，2022年上半年，扫地机器人价格依然维持着上年的增长趋势，线上渠道和线下渠道平均售价较去年同期分别增长了999元、1873元，上涨幅度明显。目前市面上的全功能型扫地机器人售价基本在4000元以上。利润空间虽然更大，迎接来的却是销量下跌。
到2023年，机器人厂商们纷纷采用以价换量策略，但市场销售额却并没有如愿涨起来。根据奥维云网的数据显示，2023年上半年，扫地机器人销量为145万台，同比下滑5.39%，销售额约为47亿元，同比下滑3.66%。堆料没作用、降价也没作用，机器人真的卖不动了？
答案显然不是，没有卖不出去的产品只有卖不出去的价格这句的朴实的真理总是有效，且目前扫地机器人的智能化水平依旧不足，如不支持智能作业等，随着大语言模型的出现，智能化无疑是未来的核心竞争点。
技术创新，赋能机器人加速升级
无论是商用机器人，还是家用机器人，想要适应新的市场，都需要一次“脱胎换骨”。作为国内领先的机器人AI技术公司，INDEMIND一直扎根于技术底层，致力于做整个行业的赋能者。针对现有服务机器人的核心问题，推出了「商用机器人AI Kit」和「家用机器人AI Kit」机器人解决方案，为机器人升级提供方向和选择。
「商用机器人AI Kit」以自研的商用机器人AGI系统INDEMIND OS Fusion为基础，采用以双目立体相机为核心的多传感器融合架构，支持市面上不同品类的主流传感器，满足商用机器人导航定位、智能避障、路径规划、决策交互等核心功能的开发，能够广泛应用于商用清洁、酒店配送、送餐、巡检等商用服务机器人平台。
相较于现有商用机器人方案：
• 无需预部署，开机即用
基于独有的立体视觉技术，搭载「商用机器人AI Kit」机器人能够实时自主构建地图，新机器、新场景无需预部署，开机即用，且变更场景后，机器人也能自主更新地图，无需技术人员参与，大大降低使用成本，这与现有的机器人产品有着天然的区别。
• 精准避障，无惧复杂动态场景
基于系统化的安全决策系统，机器人具备智能避障和主动安全功能。机器人能够稳定检测各类障碍物，支持低矮障碍物避障（地插、桌椅底座等）；高反障碍物避障（玻璃、镜面等）；全高障碍物避障（桌面、警戒线等），根据突发情况，还能够实时进行潜在风险判断（行人等），根据风险分类，提前做出规避策略，实现主动安全。
• 更低成本，成本下降60-80%
「商用机器人AI Kit」相比激光雷达方案，成本下降60-80%，机器人开发成本最低可以下探到2千元以内，包含导航和电池的完整底盘成本则可以下探到5千元以内，成本优势明显。
「家用机器人AI Kit」采用INDEMIND面向家用小型机器人专门研发的纯视觉一体化立体视觉模组，搭载自研的家用机器人AGI系统INDEMIND OS Lite，可为家用机器人导航定位、智能避障、路径规划、决策交互等多种核心功能，相较于上一代激光雷达及激光融合方案，在用户体验及性价比上拥有明显提升，可广泛应用于家用扫地、陪护、教育、玩具等家用服务机器人平台。
相较于现有激光方案：
• 低成本，高鲁棒性
「家用机器人AI Kit」采用轻量化模型，对算力配置要求较低，能够在几美金的计算平台上稳定运行整套VSLAM算法。拥有标准化的控制接口，可快速适配各种机器人平台，以持平单线激光雷达的成本，实现了“激光+视觉传感器”融合方案的导航精度水平，（目前已实现绝对定位精度&lt;1%，姿态精度&lt;1°）。
• 智能决策避障
基于自研的物体识别卷积神经网络模型，可以准确识别家用场景中的低矮障碍物（例如：动物粪便、拖鞋、钥匙串、线材、地插等）、透明玻璃容器类障碍物、动态障碍物（人、宠物）等等，自研的智能决策引擎可结合物体识别信息根据物体分类进行避障，可以有效避开动物粪便、拖鞋等特定障碍物，识别策略可配置，目前精度可达1%，最小尺寸1cm。
• 智能交互作业
通过语音、手势、动作等自然语言指令，命令机器人进行安全、搜寻、跟随、自主寻路、定向清扫等多种智能逻辑。以定向清扫为例，发布语音命令:“清扫一下客厅”可被识别为针对地图上识别到的客厅区域进行一次规划清扫。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13611244ea5c2a02d840d696c02f183e/" rel="bookmark">
			字节跳动 MapReduce - Spark 平滑迁移实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文整理自字节跳动基础架构工程师魏中佳在本次 CommunityOverCode Asia 2023 中的《字节跳动 MapReduce - Spark 平滑迁移实践》主题演讲。
随着字节业务的发展，公司内部每天线上约运行 100万+ Spark 作业，与之相对比的是，线上每天依然约有两万到三万个 MapReduce 任务，从大数据研发和用户角度来看，MapReduce 引擎的运维和使用也都存在着一系列问题。在此背景下，字节跳动 Batch 团队设计并实现了一套 MapReduce 任务平滑迁移 Spark 的方案，该方案使用户仅需对存量作业增加少量的参数或环境变量即可完成从 MapReduce 到 Spark 的平缓迁移，大大降低了迁移成本，并且取得了不错的成本收益。
背景介绍 近一年内字节跳动 Spark 作业数量经历了从 100 万到 150 万的暴涨，天级数据 Flink Batch 从 20 万涨到了 25 万，而 MapReduce 的用量则处于缓慢下降的状态，一年的时间差不多从 1.4 万降到了 1 万左右，基于以上的用量情况，MapReduce 作为我们使用的历史悠久的批处理框架也完成了它的历史使命即将下线。
在正式推动下线之前，我们首先统计了 MapReduce 类型作业的业务方和任务维护方式。
左边的饼图是业务方的占比统计，占比最大的是 Hadoop Streaming 作业，差不多占到了所有作业的 45%，占比第二名的是 Druid 作业 24%，第三是 Distcopy 22%。这里的 Distcopy 和 Hadoop Streaming 没有按照业务线来分的原因是因为这两种类型的作业使用的是完全相同的代码，在我们推动升级的过程中可以视为相同的作业。
右边的饼图是维护方式的占比统计，占比最大的是 Others，占比高达 60%，Others 的意思是不被字节跳动内部任何一个平台管理的作业，这也非常符合 MapReduce 的特定，它是一个历史悠久的框架，很多的 MapReduce 作业在第一次上线的时候，甚至这些平台还没有出现，大部分都是从用户自己管理的容器或者可以连接到 YARN 集群的物理机上直接提交的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13611244ea5c2a02d840d696c02f183e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c277c7e62653688f0303571e04d1de0/" rel="bookmark">
			Spring Boot项目Jar包加密：防止反编译的安全实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 引言2. 背景3. Jar包加密方案3.1 使用Java混淆工具3.2 使用Jar包加密工具3.2.1 示例：使用JCryptor对Jar包进行加密 4. 加密后的Jar包的运行5. 安全性与性能考虑5.1 安全性考虑5.2 性能考虑 6. 拓展功能与未来展望6.1 数字签名与验签6.2 使用加密算法库 7. 结语 🎉Spring Boot项目Jar包加密：防止反编译的安全实践
☆* o(≧▽≦)o *☆嗨~我是IT·陈寒🍹✨博客主页：IT·陈寒的博客🎈该系列文章专栏：架构设计📜其他专栏：Java学习路线 Java面试技巧 Java实战项目 AIGC人工智能 数据结构学习🍹文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️ 1. 引言 在当今互联网高速发展的时代，软件安全问题变得尤为突出。随着开源技术的普及，Spring Boot等框架的应用越来越广泛，但也伴随着代码被反编译的风险。为了保护知识产权和应用程序的安全性，开发者们需要采取一些措施来防止恶意分析和滥用。本文将探讨在Spring Boot项目中对Jar包进行加密，以防止反编译的安全实践。
2. 背景 Java应用程序通常打包成可执行的Jar文件，其中包含了项目的所有源代码和资源。然而，这也使得攻击者可以相对容易地对Jar文件进行反编译，获取源代码甚至敏感信息。为了防止这种情况发生，我们可以考虑对Jar文件进行加密，使得攻击者难以获取可读的源代码。
3. Jar包加密方案 3.1 使用Java混淆工具 Java混淆工具能够重命名类、方法、字段等，使得反编译后的代码难以理解。常见的Java混淆工具有ProGuard、Allatori等。以下是使用ProGuard进行混淆的配置示例：
# proguard-rules.pro # Keep entry points in the application -keep class com.example.Application { public static void main(java.lang.String[]); } # Keep Android activities -keep class com.example.android.** { *; } # Keep all classes in a package -keep class com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c277c7e62653688f0303571e04d1de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1354bebe9dc7438e216602430fe9dfe3/" rel="bookmark">
			【排序算法】合并两个有序数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1354bebe9dc7438e216602430fe9dfe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae737647b21f73b8bb161cebd139eb8b/" rel="bookmark">
			Libevent的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I/O 多路复用技术， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。
Chromium、Memcached、NTP、HTTPSQS等著名的开源程序都使用libevent库，足见libevent的稳定。更多使用libevent的程序可以到libevent的官网查看。
Libevent主要组成 libevent包括事件管理、缓存管理、DNS、HTTP、缓存事件几大部分。事件管理包括各种IO（socket）、定时器、信号等事件；缓存管理是指evbuffer功能；DNS是libevent提供的一个异步DNS查询功能；HTTP是libevent的一个轻量级http实现，包括服务器和客户端。libevent也支持ssl，这对于有安全需求的网络程序非常的重要，但是其支持不是很完善，比如http server的实现就不支持ssl。
Libevent的核心实现 Reactor（反应堆）模式是libevent的核心框架，libevent以事件驱动，自动触发回调功能。之前介绍的epoll反应堆的源码，就是从libevent中抽取出来的。
安装libevent 官方网站: http://libevent.org
源码下载主要分2个大版本：
1.4.x 系列，较为早期版本，适合源码学习2.x 系列，较新的版本，代码量比1.4版本多很多，功能也更完善。 源码包的安装，以2.0.22版本为例，在官网可以下载到源码包libevent-2.0.22-stable.tar.gz，基本安装步骤与第三方库源码包安装方式基本一致。
1、解压源码包：tar -xzvf libevent-2.0.22-stable.tar.gz 2、进入到源码目录：cd libevent-2.0.22-stable 3、执行配置./configure，生成makefile 4、编译源码 :执行make 5、编译后安装，输入本用户的密码: sudo make install 6、安装后验证，简单的先编译一个文件：demo.c
#include &lt;event.h&gt; #include &lt;stdio.h&gt; int main() { char ** methods = event_get_supported_methods();//获取libevent后端支持的方法 int i =0; for(i = 0;methods[i] != NULL ;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae737647b21f73b8bb161cebd139eb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d147886c4c095da5c6d6c22e1aaa49/" rel="bookmark">
			&amp;nbsp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非截断空格符，为了解决前端把多个空格合并成一个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ef96ee6050660a73274a1b4633b762/" rel="bookmark">
			Jtti：UNIX管道和重定向功能在系统备份中怎么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNIX 管道和重定向功能是在系统备份和数据处理中非常有用的工具。它们可以用于将命令的输出传递给其他命令、将输出保存到文件中，以及通过管道传递数据流。以下是一些在系统备份中使用管道和重定向功能的例子：
1. 备份文件并将输出保存到文件：
使用 tar 命令备份文件，并将备份结果保存到压缩文件中：
tar czvf backup.tar.gz /path/to/backup
上述命令将 /path/to/backup 目录备份为一个名为 backup.tar.gz 的压缩文件。
2. 将备份结果通过管道传递给另一个命令：
在备份的同时，可以使用管道将备份结果传递给 ssh 命令，以将备份文件发送到远程服务器：
tar czvf - /path/to/backup | ssh user@remote_server "cat &gt; /path/to/remote/backup.tar.gz"
上述命令将备份结果通过管道传递给 ssh 命令，将备份文件传输到远程服务器。
3. 将备份结果追加到已存在的文件中：
使用 tar 命令备份文件，并将备份结果追加到已存在的备份文件中：
tar czvf - /path/to/more/files | cat &gt;&gt; existing_backup.tar.gz
上述命令将新的备份结果追加到已存在的 existing_backup.tar.gz 文件中。
4. 将命令输出重定向到文件：
将命令的输出保存到文件，例如将 ls 命令的结果保存到 file_list.txt 文件中：
ls -l &gt; file_list.txt
上述命令将当前目录的文件列表输出到 file_list.txt 文件中。
5. 将错误输出和标准输出分别重定向：
使用 2&gt; 将错误输出重定向到文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50ef96ee6050660a73274a1b4633b762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b933a0149b8a71b4c49b0c8b320fca91/" rel="bookmark">
			【经验分享】日常开发中的故障排查经验分享（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介CPU飙高问题1、使用JVM命令排查CPU飙升100%问题2、使用Arthas的方式定位CPU飙升问题3、Java项目导致CPU飙升的原因有哪些？如何解决？ OOM问题（内存溢出）1、如何定位OOM问题？2、OOM问题产生原因 死锁问题的定位频繁Full GC问题1、频繁FullGC会导致哪些问题2、如何排查3、导致频繁FullGC的原因 内存泄露问题的排查磁盘空间不足，如何排查Linux中的大文件位置尾声 简介 众所周知，咱们程序员在日常工作中肯定少不了会碰到系统故障、系统缓慢等问题，该笔记是我在工作中对一些OOM、CPU飙高、内存泄露等问题的排查笔记，现在分享出来，因为平时开发中我就是根据这些步骤进行排查的，没有附图，不喜勿喷。
CPU飙高问题 1、使用JVM命令排查CPU飙升100%问题 第一步：查看系统进程CPU使用率，首先使用【top】命令列出系统各个进程的资源占用，查看是哪个进程的CPU不对劲，看 %CPU 这个数值，然后找到对应的进程ID号。
第二步：查看当前进程号的线程CPU使用率，使用【top -Hp 进程ID】命令查看第一步查询出来的进程ID内的线程CPU使用情况。
第三步：找到CPU使用率高的线程并将PID转化为十六进制，将这个PID转化为十六进制【printf ‘0x%x’ PID】。
第四步：输出当前进程内的该线程的堆栈信息，有两种方式，
一种是使用jstack命令将之前的那个CPU高的进程输出到一个txt文件中【jstack 1677 &gt; 1.txt】，然后使用vim或者grep根据十六进制去搜索。 另外一种就是直接使用【jstack 进程ID | grep 16进制的线程PID -A20】这个命令直接输出后20行，找到对应代码位置。 最后定位到具体业务代码的位置，我们去找到对应代码修改就行了。
2、使用Arthas的方式定位CPU飙升问题 第一步：需要去下载arthas的jar包：wget https://arthas.aliyun.com/arthas-boot.jar
第二步：启动arthas：java -jar arthas-boot.jar
第三步：其实启动的时候就显示了CPU高的类了，但是我们可以通过命令查看：
查看系统整体运行情况：dashboard
查看最繁忙的线程【可以显示具体代码位置】：thread -n 1
查看繁忙的线程具体的代码：jad 【上面查询出来的包名+类名】
找到代码位置后，根据实际业务场景去做修改就行了。
3、Java项目导致CPU飙升的原因有哪些？如何解决？ CPU飙高的原因：
1、代码中存在大量的循环、递归或者重复计算等操作，导致程序运行时消耗大量的CPU资源。
2、代码中需要处理大量的数据，如果数据量过大或者处理不当，会导致CPU占用过高。
3、频繁的IO操作，代码中涉及到频繁访问数据库、频繁读写文件等操作，由于IO操作比较耗时，导致CPU占用过高。
4、代码中创建大量线程并处于长时间忙碌状态，会导致CPU占用过高。
5、多线程之间互相竞争同一资源，导致CPU不断切换线程从而消耗大量资源，会导致CPU占用过高。
6、JVM问题：配置不当或者性能问题导致CPU过高。
7、内存泄露也有可能导致CPU飙高。内存泄露的程序，JVM频繁进行FullGC尝试释放内存空间，进而会导致CPU飙升，内存泄露过多，造成可回收内存不足，程序申请内存失败，结果就是内存溢出。
如何解决：
优化代码逻辑，尽量减少重复计算和不必要的循环合理处理大量数据，可以使用分页或者分批处理的方式。检查并发处理的线程数量，合理控制线程的创建和销毁。对JVM进行适当的配置和调优，如调整堆大小、垃圾回收策略等。 还是要根据具体的业务场景来进行优化。
OOM问题（内存溢出） 1、如何定位OOM问题？ 一般出现OOM问题，java.lang.OutOfMemoryError:Java heap space或者其他，我们都是通过dump文件去定位问题。
方式一（生产环境经常使用的方式）：
我们工作里面都是在启动脚本里面提前加入：
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/logs/dump/
这个配置信息来提前预防，当出现OOM问题时，会将当前内存输出一个dump文件放入到指定的目录下（我这里是放到/logs/dump/目录下），然后将文件下载下来以后，通过MAT或者JProfile或者visualvm工具加载dump文件进行调试，查看最多跟业务有关的对象，然后找到GCRoot，查看线程栈的输出定位到具体代码位置。
方式二：使用命令主动导出
需要导出dump文件：【jmap -dump:format=b,file=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b933a0149b8a71b4c49b0c8b320fca91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349360736c18bcfb5f843010ec618232/" rel="bookmark">
			Python pip换国内源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python pip换国内源 pip自带的源是国外，下载比较慢，可以更换为国内的源。
下载的时候指定源：
pip install XXXXXX -i https://pypi.tuna.tsinghua.edu.cn/simple 临时更换（任选一个即可）：
# 清华源 pip install markdown -i https://pypi.tuna.tsinghua.edu.cn/simple # 阿里源 pip install markdown -i https://mirrors.aliyun.com/pypi/simple/ # 腾讯源 pip install markdown -i http://mirrors.cloud.tencent.com/pypi/simple # 豆瓣源 pip install markdown -i http://pypi.douban.com/simple/ 永久更换（任选一个即可）：
# 清华源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple # 阿里源 pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ # 腾讯源 pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple # 豆瓣源 pip config set global.index-url http://pypi.douban.com/simple/# 换回默认源pip config unset global.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349360736c18bcfb5f843010ec618232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3ab4ea863609b9d68f7b140d2ea367/" rel="bookmark">
			科研常用的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我想和大家分享一些在科研论文写作过程中常用的学术网站、数据分析软件、以及找数据用的一些数据库。这学术网站可以帮助我们快速查找和引用相关文献；数据分析软件帮助我们完成研究中的数据分析部分；数据库能够帮我们找到研究过程中可能用到的数据，以此提高科研论文写作的质量和效率。
一、学术网站 科研论文写作过程中常用的学术网站有以下几个，我国比较知名的有知网、百度学术、万方数据库、中国科技论文在线等。国外比较知名的有谷歌学术、sci-hub、BASE、PMC等等，说明如下：
1、中国知网
网址：http://www.cnki.net/
中国知网（CNKI）是一个中国学术文献、期刊和博硕士论文的数字化出版平台，包含有海量的学术资源，覆盖了多个学科领域。中国知网提供多种检索方式，如关键词检索、高级检索、作者检索等，可以帮助用户快速定位到所需文献。同时，它还提供了在线阅读、下载和打印功能，方便用户获取和使用学术资源，当然缺点是收费的。
2、百度学术
网址：https://xueshu.baidu.com/
百度学术是百度旗下的一个学术搜索引擎，旨在为广大科研人员、学者和学生提供全面、权威、便捷的学术资源搜索和下载服务。百度学术搜索范围覆盖了全球范围内的所有学术领域，包括期刊论文、学位论文、书籍、报告等各类学术资料。与多个权威学术机构合作，如中国知网、万方数据等，确保搜索结果权威、准确。支持关键词检索、高级检索、作者检索等多种检索方式，方便用户快速找到所需文献。
3、万方数据库
网址：http://www.wanfangdata.com.cn/index.html
万方数据库是由万方数据公司开发的，涵盖期刊、会议纪要、论文、学术成果、学术会议论文的大型网络数据库。万方数据库以学术、技术、政策指导类全文文献、数据论文等为主，内容涉及自然科学和社会科学各个专业领域。
4、中国科技论文在线
网址：http://www.paper.edu.cn/
中国科技论文在线作为理工类研究生，你绝对不能错过这个科学论文专业网站。特别是它的科技期刊分类，它就像一个强大的期刊和大学学报通讯录，使你能够轻松地与他们取得联系。此外，该网站还提供了每期的论文下载专区，内容全面。
5、虫部落
网址：https://www.chongbuluo.com/
虫部落是一个专注于学术领域的搜索引擎，它集合了谷歌学术、百度学术、必应学术、CNKI等等众多搜索为一体。虫部落还提供了学术社交网络功能，使用户能够与其他研究人员交流和分享学术见解。是一个开放、自由的学术搜索平台，致力于为全球科研人员提供最好的学术搜索体验。
6、中国专利下载
网址：http://www.drugfuture.com/cnpat/cn_patent.asp
提供下载号，就能下载你需要的专利。
7、谷歌学术
网址：http://scholar.glgoo.org/
备用网址：https://scholar.google.com.hk/
谷歌学术是一个文献检索服务，主要提供维普资讯、万方数据等几个学术文献资源库的检索服务。通过谷歌学术，用户可以查找包括期刊论文、学位论文、书籍、报告在内的各种学术资料。需要注意的是，在使用谷歌学术时，由于各种原因可能会导致无法正常登录或使用的情况。因此，建议用户在使用前先尝试使用其他学术搜索引擎或直接访问相关学术网站来获取文献资源。
8、本地PubMed
网址：https://www.tsgyun.com/
本地PubMed是华中科技大学同济医学院与济南泉方科技有限公司合作开发，是在美国PubMed的基础上，参考CiteScore期刊评价系统、泉方学术搜索、德国的GoPubMed等整合开发的检索平台。
9、sci-hub
网址：http://www.sci-hub.io/
备用网址：http://sci-hub.yncjkj.com
sci-hub是一个免费开放的科研文献下载平台。sci-hub的使命是消除科学研究的障碍，让所有人都可以无限制地访问和下载全球学术期刊。它可以帮助科研人员免费获取来自全球各地的学术文献，包括一些需要订阅或付费的期刊。sci-hub在学术界引起了广泛的关注和争议，因为它违反了出版商对于学术文献的版权控制。然而，它也受到了许多科研人员的欢迎和支持，因为它有助于提高科研的效率和透明度。
10、BASE
网址：http://www.base-search.net/BASE是一个全球范围内的学术搜索引擎，专注于提供高效、精准的学术资源搜索服务。搜索范围涵盖了全球范围内的学术资源，包括期刊论文、学位论文、书籍、报告等各类学术资料。
11、PMC（PubMed Cenral)
网址：https://www.ncbi.nlm.nih.gov/pmc/
PMC（PubMed Central）是NCBI（美国国家生物信息中心）下属的一个机构，提供生物医学方面的论文检索服务以及生物信息学工具。PMC是一个免费的生物医学文献档案集，收录了来自全球各地的生物医学研究论文。
12、DOAJ
网址：https://doaj.org/
DOAJ（Directory of Open Access Journals）是一个开放存取期刊目录，由瑞典隆德大学图书馆创建和维护。它提供了一个免费、开放、高质量的学术期刊目录，DOAJ收录的OA期刊数量非常多，属于目前最好的OA期刊目录网站。
13、OA图书馆
网址：http://www.oalib.com/
OA图书馆（Open Access Library，开放获取图书馆）是一个提供开放获取期刊和论文检索服务的学术资源平台。它涵盖了多个学科领域，包括医学、社会科学、自然科学等。在OA图书馆中，用户可以检索和浏览大量免费、公开获取的学术论文和期刊文章。
14、arXiv
网址：https://arxiv.org/
arXiv是一个开放的档案馆，提供近240万篇物理学、数学、计算机科学、定量生物学、定量金融学、统计学、电气工程和系统科学以及经济学领域的学术文章。它是一个开放获取的资源，可以免费下载和阅读。arXiv的收录文章覆盖了从理论物理到实验物理的各个方面，包括最近的高能物理、非线性科学、相对论、弦理论、统计物理等领域的文章。文章类型内容分类非常专业和全面。
15、PublicLibrary of Science
网址：https://www.plos.org/
公共科学图书馆（Public Library of Science，PLOS）是一个非营利的开放获取的科学出版项目，旨在根据开放内容许可证创建一个开放获取期刊和其他科学文献的图书馆。
二、数据分析软件 科研论文写作过程中常用的数据分析软件包括SPSSAU、SPSS、Excel、R语言、python、Stata、SAS等。
1、SPSSAU
网址：https://spssau.com/
SPSSAU（Statistical Product and Service Software Automatically，自动化统计产品和服务软件）也称“在线SPSS”，是一款在线数据分析软件，其适用场景广泛、功能全面、操作简单，为用户提供“拖拽点一下”就可以完成数据分析的极致体验和智能化分析结果，即便是统计学小白也能完成的复杂的数据分析工作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe3ab4ea863609b9d68f7b140d2ea367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2354bcbf21be14779ceea7e48bfce97/" rel="bookmark">
			Apache DolphinScheduler 社区荣获 “2023年度优秀开源社区” 称号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache DolphinScheduler 社区在由中国科协科学技术传播中心、中国计算机学会、中国通信学会、中国科学院软件研究所共同主办的 2023 开源创新榜评选中，荣获“优秀开源社区”奖项。
榜单评选背景 2023 开源创新榜专家评审会于 12 月 15 日在国家科技传播中心成功举办。王怀民院士担任评委会主任，评委会成员包括来自全国的学会、大学、科研院所、企业、开源基金会、行业联盟等二十多位开源专家。
今年的开源创新榜在权威性、公信力和专业度方面均有显著提升。评选围绕项目、社区、人物三大类别进行，旨在挖掘和推广我国在开源技术领域的优秀成果和先进经验。
Apache DolphinScheduler 社区的成就 Apache DolphinScheduler 社区自成立以来，一直致力于提供高质量的大数据工作流调度平台。通过不断的技术创新和社区共建，我们的社区已成为全球顶尖高科技公司共同努力的成果，受到了业界的广泛认可和尊敬。
未来展望 此次获得“优秀开源社区”提名不仅是对 Apache DolphinScheduler 社区过去努力的认可，更是对未来工作的鼓舞。我们将继续推动高质量的开源发展和高水平的安全建设，为社区成员创造更多展示、交流、推广的机会。
结语 我们感谢主办方的认可，感谢社区每一位成员的不懈努力和贡献。Apache DolphinScheduler 社区将继续努力，不仅推动自身发展，也为整个开源界贡献力量。让我们一起，将 Apache DolphinScheduler 社区打造成为业界最权威、最典型、最具影响力的标杆。
本文由 白鲸开源科技 提供发布支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6b7a7c93038fff74470a8b1290f944/" rel="bookmark">
			AI短视频生成与制作从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 送书第一期 《用户画像：平台构建与业务实践》
送书活动之抽奖工具的打造 《获取博客评论用户抽取幸运中奖者》 送书第二期 《Spring Cloud Alibaba核心技术与实战案例》
送书第三期 《深入浅出Java虚拟机》
送书第四期 《AI时代项目经理成长之道》
送书第五期 《Kubernetes原生微服务开发》
送书第六期 《Offer来了：Java面试核心知识点精讲（第2版）》
送书第七期 《AI摄影绘画与PS优化从入门到精通》
送书第八期 《快速构建AI应用–AWS无服务器AI应用实战》
送书第九期 《AWS解决方案架构师学习与备考》
送书第十期 《AI短视频生成与制作从入门到精通》
文章目录 系列文章目录★前言☆一、内容简介☆二、作者简介☆三、章节介绍★精彩作品★总结 ★前言 AI短视频生成与制作从入门到精通 前言 AI技术的迅猛发展，使得各行各业都迎来了新的机遇和挑战，短视频行业更是发生了颠覆性的变化。以前，要制作一个短视频，我们需要构思文案、准备素材并手动完成作品剪辑。而现在，AI的强大生产力使原本复杂的制作短视频的工作变得简单、轻松，只需一段AI生成的文案、几张AI绘制的图片或几段视频素材，就能够一键生成短视频，创作效率得到了极大提升。 ☆一、内容简介 内容简介 本书分3篇共13章，内容围绕AI短视频的生成、制作和应用3个方面，具体内容如下。 AI视频生成篇
AI视频生成篇，主要介绍了AI文本、图片和视频生成的操作技巧，帮助读者掌握基础的AI创作方法。
(1) AI文本创作：第1章介绍了ChatGPT的使用技巧和运用ChatGPT生成脚本文案的操作方法，并安排了5种热门的短视频文案生成实战演示。
(2) AI素材生成：第2章介绍了使用文心一格和Midjourney生成视频所需的图片素材和具体的操作方法。
(3) AI视频创作：第3～5章分别介绍了使用文本生成视频、使用图片生成视频和使用视频生成视频的操作技巧。
AI视频制作篇
AI视频制作篇，主要介绍了一些实用的AI视频处理功能和基础剪辑功能的使用方法，帮助读者轻松完成视频的智能处理与剪辑。
(1) AI视频处理：第6～8章分别介绍了腾讯智影、一帧秒创和Premiere的AI视频编辑功能的使用方法。
(2) 基础剪辑技巧：第9章介绍了剪映电脑版的5个视频剪辑功能的使用技巧和3种特效制作的操作方法。
AI视频应用篇
AI视频应用篇,主要通过4个综合案例，介绍AI短视频在生活和工作中的实际运用。
(1) AI虚拟形象：第10章介绍了用必剪App制作虚拟形象音乐短片的操作方法。
(2) AI口播：第11章介绍了用ChatGPT、腾讯智影和剪映电脑版制作数字人口播视频的操作方法。
(3) AI演示：第12章介绍了用腾讯智影制作数字人演示视频的操作方法。
(4) AI广告：第13章介绍了用FlexClip制作商品主图视频的操作方法。
本书特别提示如下: (1) 版本更新：本书在编写时，是基于当时各种AI工具和软件的界面截取的实际操作 图片，但图书从编辑到出版需要一段时间，这些工具的功能和界面可能会有所变动，读者在阅读时，可根据书中的思路，举一反三，进行学习。书中使用的工具和软件版本包括：ChatGPT为3.5版，Midjourney为5.1版，剪映电脑版为4.2.1版，剪映App为10.6.0版，必剪App为2.39.0版，快影App为V 6.2.0.602002版，美图秀秀App为9.9.1.5正式版，不咕剪辑App为2.1.403版，Premiere Pro 2023为23.0.0版。 (2) 关键词的定义：关键词又称指令、描述词、提示词，是人们与AI模型进行交流的机器语言，书中在不同场合使用了不同的称谓，主要是为了让读者更好地理解这些行业用语。另外，很多关键词暂时没有对应的中文翻译，强行翻译为中文会让AI模型无法理解。 (3) 关键词的使用：在Midjourney中，尽量使用英文关键词，对于英文单词的格式没有太多要求，如首字母大小写不用统一、单词顺序不必深究等。但需要注意的是，关键词之间最好添加空格或逗号，同时所有的标点符号使用英文字体。再提醒一点，即使是相同的关键词，AI模型每次生成的文案、图片或视频内容也会有差别。 为方便读者学习，本书提供素材文件、案例效果、教学视频、PPT教学课件、教案和教学大纲等资源，读者可扫描右侧的配套资源二维码获取；也可直接扫描书中二维码，观看教学视频。此外，本书赠送AI摄影与绘画关键词，读者可扫描右侧的赠送资源二维码获取。 ☆二、作者简介 作者简介 本书由楚天编著，参与编写的人员有李玲，提供素材和拍摄帮助的人员有向小红、邓陆英、苏苏、向秋萍等。 楚天 • 资深摄影师，中国摄影家协会会员、湖南省摄影家协会会员、长沙市摄影家协会会员、中国人像摄影家协会会员、湖南省青年摄影家协会会员 • AI摄影绘画爱好者，熟练运用ChatGPT、Midjourney、百度文心、Photoshop AI、Firefly AI等智能工具，拥有15年PS使用经验 • “手机摄影构图大全”公众号创始人，分享了300多种构图方法，粉丝30万+ • 摄影作品入选CCTV-1、CCTV-3国庆晚会《中国梦•祖国颂》 •抖音短视频创作者，代表作《一镜看长沙•大河西》，阅读量40万＋。 ☆三、章节介绍 本书分3篇共13章，内容围绕AI短视频的生成、制作和应用3个方面，具体内容如下。 AI视频生成篇 AI视频生成篇，主要介绍了AI文本、图片和视频生成的操作技巧，帮助读者掌握基础的AI创作方法。 (1) AI文本创作：第1章介绍了ChatGPT的使用技巧和运用ChatGPT生成脚本文案的操作方法，并安排了5种热门的短视频文案生成实战演示。 (2) AI素材生成：第2章介绍了使用文心一格和Midjourney生成视频所需的图片素材和具体的操作方法。 (3) AI视频创作：第3～5章分别介绍了使用文本生成视频、使用图片生成视频和使用视频生成视频的操作技巧。 AI视频制作篇 AI视频制作篇，主要介绍了一些实用的AI视频处理功能和基础剪辑功能的使用方法，帮助读者轻松完成视频的智能处理与剪辑。 (1) AI视频处理：第6～8章分别介绍了腾讯智影、一帧秒创和Premiere的AI视频编辑功能的使用方法。 (2) 基础剪辑技巧：第9章介绍了剪映电脑版的5个视频剪辑功能的使用技巧和3种特效制作的操作方法。 AI视频应用篇 AI视频应用篇,主要通过4个综合案例，介绍AI短视频在生活和工作中的实际运用。 (1) AI虚拟形象：第10章介绍了用必剪App制作虚拟形象音乐短片的操作方法。 (2) AI口播：第11章介绍了用ChatGPT、腾讯智影和剪映电脑版制作数字人口播视频的操作方法。 (3) AI演示：第12章介绍了用腾讯智影制作数字人演示视频的操作方法。 (4) AI广告：第13章介绍了用FlexClip制作商品主图视频的操作方法。 本书特别提示如下。 (1) 版本更新：本书在编写时，是基于当时各种AI工具和软件的界面截取的实际操作 图片，但图书从编辑到出版需要一段时间，这些工具的功能和界面可能会有所变动，读者在阅读时，可根据书中的思路，举一反三，进行学习。书中使用的工具和软件版本包括：ChatGPT为3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6b7a7c93038fff74470a8b1290f944/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4edd38aaeb742aa442c4a43bb17cdfa3/" rel="bookmark">
			svg总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		getTotalLength()获取图形总长度 &lt;body&gt; &lt;svg width=600 height=600 style="border:1px solid rgb(6, 6, 5);" id="svg"&gt; &lt;rect x=200 y=200 width=200 height=200 stroke="red" fill="#f3f3f3" id="rect"&gt;&lt;/rect&gt; &lt;/svg&gt; &lt;script&gt; var rect = document.getElementById('rect') // getTotalLength()获取图形总长度 console.log('getTotalLength()获取图形总长度',rect.getTotalLength()); &lt;/script&gt; &lt;/body&gt; getPointAtLength(x)：获取路径（path）上距离起始点长度为x的点的坐标 &lt;body&gt; &lt;svg width=600 height=600 style="border:1px solid rgb(6, 6, 5);" id="svg"&gt; &lt;rect x=200 y=200 width=200 height=200 stroke="red" fill="#f3f3f3" id="rect"&gt;&lt;/rect&gt; &lt;/svg&gt; &lt;svg width=600 height=600 style="border:1px solid black;" id="svg"&gt; &lt;path d="M 0 50 h 100" stroke="blue" id="path1"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;script&gt; // getPointAtLength(x)：获取路径（path）上距离起始点长度为x的点的坐标 var rect = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4edd38aaeb742aa442c4a43bb17cdfa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5508233c428116a62acc141a6e7b2fcc/" rel="bookmark">
			AWS SSM中切换AWS不同的profile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在自己的开发笔记本上面，通过AWS SSM方式访问EC2服务，只需要通过简单的命令就可以访问EC2了，如下：
aws ssm start-session --target i-xxxx12350 这个命令就是利用aws命令行工具中ssm提供的会话管理能力访问ec2服务，这个会话管理的能力，相当于跳板机了。
我如果只有一个aws开发账号还好，如果我有多个aws开发账号，就需要在不同环境上面切换配置才能正常使用上面这个命令，有没有简单一点的配置？
使用上面这个能力，需要在~/.ssh/config,~/.aws/config和~/.aws/credentials这3个文件事先进行如下配置 ：
~/.ssh/config # SSH over Session Manager host i-* mi-* ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p'" 需要在这个文件添加如上的ssh代理命令配置，具体效果如下图：
~/.aws/config [default] region = cn-north-1 output = json [profile demo] region = cn-north-2 output = json 在这个文件中设置两个环境，一个默认环境，一个demo环境，这就是设置aws的profile需要切换的环境。
~/.aws/credentials [default] aws_access_key_id = xxxx aws_secret_access_key = xcvsdafgs [demo] aws_access_key_id = sdfsg aws_secret_access_key = dfurtyuirh34564687u 这是不同环境使用的不同的secret授权。
切换aws profile 假设我们需要登录demo环境的中的ec2机器，只需要在运行aws ssm登录命令之前，设置环境变量AWS_PROFILE即可，具体命令如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5508233c428116a62acc141a6e7b2fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8768bf093d9af6ca9add612276838ace/" rel="bookmark">
			三分钟学完科研论文常用统计图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		统计分析的结果通常包括统计图和统计表。统计图是一种用图形表示数据的方式，它能够直观地展示数据的分布、趋势和关系。科研论文中常见的统计图包括条形图、饼图、折线图、散点图等。这些图形可以帮助人们快速地理解和分析数据，找出其中的规律和特征。今天就来讲一讲常用的科研统计图。
一、统计图结构 统计图一般包括5个部分：分别是标题、横标目、纵标目、刻度、图例。具体的说明以及注意事项如下：
举例：下图为在一篇文献中截的一个统计图，大家可以参考：
知道了统计图的概念和基本结构之后，接下来，我将为大家详细介绍统计图的分类以及SPSSAU在智能分析中的统计图自动输出功能。
二、统计图分类 1、按数据类型选择统计图 每种类型的统计图的特点不同，所呈现出数据的主要特征也不尽相同，结合数据类型选择合适的统计图进行搭配，才能达到最好的效果。不同的数据类型，适用不同的统计图。
数据可分为定类数据和定量数据两大类，按照X和Y的思维，先识别出X和Y分别的数据类型情况，然后找到适合的统计图作图即可，X与Y组合起来常用的图形见下表：
举例说明：比如想要分析不同品种和不同施肥方式下，水稻产量的差异，希望通过图形直观展示差异情况。很明显这里2个X均为定类数据，而水稻产量为定量数据，所以可以使用“簇状图”进行可视化分析。
将数据上传至SPSSAU系统，选择“簇状图”，拖拽变量至右侧相应分析框，操作如下图：
得到簇状图结果如下：
簇状折线图
簇状柱形图
簇状条形图
2、常用统计图说明 常用统计图的适用情况和举例说明如下：
比如：散点图可以很好的展示X随Y的变化情况，所以常用于辅助判断X与Y之间的关系情况。如下图为公司员工起始工资与当前工资的散点图，可以看出二者具有较强的正相关关系。 直方图可以展示数据的分布情况，可以用于辅助判断数据是否服从正态分布。如下图为某班学习成绩的直方图，可以看出满足“中间高，两头低”的钟形分布，具有正态性特征。 箱线图可以展示数据的整体分布情况，可用于探索且展示异常值数据情况。如下图为变量X5的箱线图，可以明显看出该变量存在一个异常值。 SPSSAU当前提供累计共30多类图形，分布于各个方法中自动生成，当然还有一些复杂或者特殊的图形需要自己作图。
三、SPSSAU自动出图 在使用SPSSAU进行数据分析时，选择相应方法进行分析得到分析结果的同时，SPSSAU会默认自动输出对应的统计图分析结果，以及该方法可能涉及的各类统计图。
1、SPSSAU智能化出图 比如使用SPSSAU进行方差分析、t检验等差异性分析方法会自动输出对应的折线图、柱形图等；多选题分析时会自动输出对应的响应率、普及率、帕累托图、交叉汇总图等；回归模型包括线性回归、路径分析、结构方程模型、调节中介等都会自动输出对应的模型图。
举例说明1：使用卡方检验研究不同年龄段是否感染病毒的差异时，SPSSAU会默认输出对应的堆积柱形图、堆积条形图等（右上角切换统计图），如下图：
举例说明2：使用探索性因子分析时，SPSSAU默认输出对应的碎石图和载荷图，如下图：
举例说明3：使用相关分析研究变量间相关性时，SPSSAU默认输出对应的相关分析可视化图，如下图：
举例说明4：构建结构方程模型时，SPSSAU自动输出对应的模型图，如下图：
提示：SPSSAU可视化结合了数据分析方法的思想，默认提供准确的可视化图形展示，这是SPSSAU智能系统的一个组成部分。通常自动输出的第一个统计图是最优的即最合适的。
2、图形调整与美化 SPSSAU当前提供字体、字号、小数位、是否隐藏标签、是否展示Y轴、Y轴颜色设置以及七类色彩风格设置，该设置只需要在任何一个地方设置，后续和其它全部的图都会基于该设置生成‘可视化图’，不需要重复进行设置。
在SPSSAU输出的统计图下方，点击Aa样式进行设置，如下图：
1、散点图 散点图用于考察定量数据之间的关联关系，即查看X和Y之间的关系情况。散点图通常用于探索性研究，直观展示出数据间的关联关系情况。
使用场景 （1） 相关分析之前，查看X和Y之间的关系情况。
（2） 回归分析后模型检验，查看残差分别与自变量间的关联性【回归模型假定残差不应该与自变量有关联性，即异方差性】。
（3） 其它用于直观展示数据关系的场景。
散点图示例 2、直方图 直方图用于直观展示数据分布情况，观察数据的正态分布特性，检验数据是否满足正态性。
使用场景 （1） 相关分析时，数据的正态性查看；
（2） 回归分析后模型检验，将残差进行正态性检验，如果残差呈现出正态性意味着模型构建良好，反之说明模型构建较差。
（3） 其他用于查看数据分布、检验正态性的场景等等。
直方图展示 3、箱线图 箱线图（也称盒图，箱盒图等）是在1977年由美国统计学家John Tukey发明，分析数据需要为定量数据。通过箱线图，可以直观的探索数据特征。
使用场景 （1） 查看可能的异常值数据情况；
（2） 非参数检验时查看不同类别X时，Y的数据分布情况；
（3） 其它涉及查看数据分布或者异常值查看时。
直方图展示 4、词云图 词云图是由美国西北大学新闻学教授Rich Gordon提出，“词云”可对文字中出现频率较高的“关键词”予以视觉上的突出，形成“关键词云层”或“关键词渲染”，从而使浏览者只要一眼扫过文本就可以领略文本的主旨。
使用场景 （1）直观地展示文本信息，并且突出展示关键信息；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8768bf093d9af6ca9add612276838ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75461093f9ea13ea5b0fc8346501ed6c/" rel="bookmark">
			Android通过MOB(袤博）接入短信验证码(包括MD5获取）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
使用 MobPus 免费短信验证玛
官方文档：MobTech集成文档-MobTech
https://www.mob.com/
MOB网页申请部分： 进入开发者平台
创建应用
填写信息
包名：应用程序中获取 MD5 签名获取： 1.方法一 选择 APK-&gt; 选择 Create new-&gt; 打开文件路径
新建时需要全部填写，密码不可以忘记
进入文件夹 , 修改后缀名并解压
进入 META-INF 后在终端中打开，输入以下命令（ubantu 看不到 md5）
keytool -printcert -file CERT.RSA
或以下方法，但须输入密码。（ubantu 看不到 md5）
keytool -list -v -keystore loginkey.jks
2.方法二（个人感觉比方法一好用） 百度搜索“微信开放平台”，或直接进入网址：
https://open.weixin.qq.com/
进入资源中心 -&gt; 资源下载 -&gt;Android 资源下载
下载签名生成工具
https://res.wx.qq.com/wxdoc/dist/assets/media/Gen_Signature_Android.e481f889.zip
下载到手机后安装，输入 APP 包名即可获取签名（md5)
代码参考： 1. build.gradle中添加 plugins { id 'com.android.application' } apply plugin: 'com.mob.sdk' MobSDK { appKey "38ec31857c79c" appSecret "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75461093f9ea13ea5b0fc8346501ed6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491170f67d06aaa5a14e43aaf1a4e6d8/" rel="bookmark">
			什么是通信？什么是通信协议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是通信：
以信件为例进行理解：
试想在古代，我们怎么依靠信件来传递信息：写信–&gt;传信–&gt;读信，这个是我们表面理解的步骤，如果我们看的深层一点，可以理解为：（假设写信人想让收信人去将XX屋子的椅子移动一厘米）
写信人将“将XX屋子的椅子移动一厘米”用双方规定好意思的象形字即汉字表示，并记录在纸张载体上——》通过鸽子或者别人骑马把纸张载体送给收信人——》收信人把信中的象形字翻译成“将XX屋子的椅子移动一厘米”，并按照指示将XX屋子的椅子移动一厘米推广到电子通信：
发送方用一种编码方式对信息进行编码——》通过一种传输介质发送编码信息——》接收方接受编码信息——》 接收方按照这一种编码方式进行解码，得到有效信息 二、什么是通信协议？
通信协议就是上面所讲的编码方式，具体例子就是类似于发电报，电报信息通过专用的交换线路以电信号的方式发送出去，该信号用编码代替文字和数字，通常使用的编码是摩尔斯电码
我们单片机间通信，用高电平和低电平转换成的0，1二进制编码，然后通过预定俗称的关系，将二进制编码转换成文字或者数字，而这些关系就是协议
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4e073bbca9f024b1f0a32dd722654c4/" rel="bookmark">
			maven中dependencyManagement标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 dependencyManagement正如其名，用于项目依赖的统一管理。
在父项目中的pom.xml文件中加入dependencyManagement标签即可完成依赖版本的声明。在声明完成后，子项目（module）中引用相同的依赖时可以不指定version标签自动引入父项目的相同版本。
如果子项目想要有自己的依赖版本，只需要加入version标签填入需要的版本号即可。
注意：dependencyManagement标签只会进行版本声明，而不会实际下载依赖。
代码 父项目中的pom文件： 引用mysql连接依赖
&lt;properties&gt; &lt;mysql.version&gt;8.0.28&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 子项目中的pom文件：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 子项目没有指定版本号也引入了父项目依赖的版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5e59816eecb56f22995c88e7a596d8/" rel="bookmark">
			Ubuntu 22.04 安装ftp实现与windows文件互传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 22.04 安装ftp实现与windows文件互传 1、配置安装 安装：
sudo apt install vsftpd -y 使能开机自启：
sudo systemctl enable vsftpd 启动：
sudo systemctl start vsftpd 创建ftp工作目录：
sudo mkdir -p /home/ftp/uftp 创建一个用于ftp的工作用户uftp：
sudo useradd -d /home/ftp/uftp -m uftp 设置uftp的密码：
sudo passwd uftp 改变ftp工作目录的读写权限：
chmod -R 777 /home/ftp 修改ftp配置文件/etc/vsftpd.conf：
先备份一下原文件：
sudo cp /etc/vsftpd.conf /etc/vsftpd.conf.bak 使用vi编辑器修改：
sudo vim /etc/vsftpd.conf 主要修改的有：
listen=YES listen_ipv6=NO chroot_local_user=YES \\去掉注释 在该文件默认增加：
userlist_deny=NO userlist_enable=YES userlist_file=/etc/allowed_users local_enable=YES write_enable=YES pasv_promiscuous=YES anonymous_enable=NO allow_writeable_chroot=YES 在/etc目录下创建文件allowed_users，该文件中是存储允许ftp登录的本地用户，直接执行以下命令，将我们刚才创建的uftp用户添加进这个文件：
echo uftp &gt;&gt; /etc/allowed_users 最后，重启vsftpd：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d5e59816eecb56f22995c88e7a596d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b0753b9e3749659c94f792b1f9b1b0/" rel="bookmark">
			内网穿透的应用-开源表格工具APITable本地部署结合内网穿透实现公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 部署APITable2. cpolar的安装和注册3. 配置APITable公网访问地址4. 固定APITable公网地址 前言 vika维格表作为新一代数据生产力平台，是一款面向 API 的智能多维表格。它将复杂的可视化数据库、电子表格、实时在线协同、低代码开发技术四合为一，就连一行代码都不懂的普通职员都能轻松上手获得 IT 能力，从而极大降低企业数字化成本。如果你正在寻找快捷可定制的业务系统、安全可靠的可视化数据库、高效协同的办公工具，那么vika维格表能满足你的丰富想象。
结合cpolar内网穿透，可以让你一键拥有自己的多维表格平台，并实时进行公网远程访问，可以私有化部署、代码修改，自主掌控数据并灵活定制你所需要的。
1. 部署APITable 安装环境：
安装docker和docker-compose v2
建议使用4核CPU/8GB RAM或更多
一个bash shell,安装curl等基本实用程序
本机arm64(mac芯片)容器映像尚未准备就绪，可能会导致性能不佳。
要使用 docker compose 安装 apitable，请打开终端并运行以下命令：
curl https://apitable.github.io/install.sh | bash 根据您的环境，您可能需要等待几分钟才能启动所有服务。
然后在浏览器中打开 http://localhost:80 以访问它。
还提供基于 pm2 的多合一映像用于演示或测试目的（不建议用于企业或生产用途）：
sudo docker run -d -v ${PWD}/.data:/apitable -p 80:80 --name apitable apitable/all-in-one:lates 安装完成后，然后在浏览器中输入localhost:80，打开网页，显示成功进入到APITable的登录界面，输入账号密码即可登录。
2. cpolar的安装和注册 完成APITable的部署后，就可以安装cpolar。要在ubuntu系统上安装cpolar，可以使用简便的一键安装脚本进行安装。只要在ubuntu的命令行界面输入以下命令，就可以自动执行安装程序（需要注意的是，可能有的ubuntu版本没有安装curl工具，因此最好先执行命令“sudo aptinstall curl”安装curl工具）。
curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash Cpolar安装完成后，就可以再输入命令“systemctl start cpolar”，启动cpolar。
systemctl start cpolar 当然，我们也可以不使用systemctl级别命令，而是输入“cpolar version”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b0753b9e3749659c94f792b1f9b1b0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/24/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>