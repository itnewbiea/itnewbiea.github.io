<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6eba64f197308f313fb214315f5cf7b/" rel="bookmark">
			杨中科.NET Core 教程 第一部分-2- .NET Core的重要问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 .NETCore 和 .NETFramework区别 尽管绝大部分用法都没变，但是.NET Core不是 .NET Framework的升级版，无法直接升级
用Mono，.NET Framework程序可以直接运行在Linux下。有了Mono，为啥微软还搞.NET Core?
.NET Framework缺点： 1、系统级别的安装，互相影响
2、无法独立部署
3、ASP.NET和IS深度耦合
4、ASP.NET资源消耗大
5、非云原生
NET Framework历史包袱 1、带着手铐脚镜长大的ASP.NET MVC
2、ASP.NET底层不支持很好的单元测试
Mono在移动端单纯，到了服务器端就走不动了
NET Core的优点 支持独立部署，不互相影响彻底模块化没有历史包袱，运行效率高不依赖于IIS跨平台单元测试等符合现代开发理念: 依赖注入、单元测试等。 .NET Core和.NET Framework不同 不支持: ASP.NET WebForms、WCF服务器端WF、.NET Remoting、Appdomain部分Windows-Only的特性.NET core，但是无法跨平台: WinForm、WPF、注册表、Event Log.AD等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ff70a9c3b7a71b4057f1d4ea100773/" rel="bookmark">
			Fiddler 无法抓包手机 https 报文的解决方案来啦！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决手机https无法抓包的问题
当你测试App的时候，想要通过Fiddler/Charles等工具抓包看下https请求的数据情况，发现大部分的App都提示网络异常/无数据等等信息
这时候怎么解决呢？
以软件测试面试提刷题APP为例：
Fiddler上的显示如下： https的报文不能被解密：
你可能开始找证书的问题：是不是Fiddler的证书没有导入的手机中去？删除证书又重新安装，配置一遍又一遍，又开始对比web端浏览器的https发现没问题。
那么这个问题怎么解决呢？ 本文给大家提供一种非常有效的解决方案：VitualXposed框架+JustTrustMe模块。
VitualXposed+JustTrustMe解决https的抓包问题
VitualXposed ，简单来说，可以在不需要设备root的情况下，修改App的行为。此应用的工作原理类似于应用分身功能，会将应用安装到一个虚拟独立的环境当中。
VitualXposed的官网下载地址：
https://vxposed.com/ ，下载apk包，可以直接安装到手机。
JustTrustMe，是xposed中的一个模块，用于禁止SSL证书验证。
下载地址：https://github.com/Fuzion24/JustTrustMe，同样下载apk包，安装到手机上。
第一步：并把两个应用都安装到手机里，然后启动VirtualXposed，点击下图的按钮：
第二步：进入设置页面，点击添加应用：
里面会显示所有安装在这个手机上的APP，选择你要抓包的APP，以及JustTrustMe这个应用，进行安装。
第三步：然后回到设置页面，点击模块管理，勾选JustTrustMe 这个模块：
点击进去之后，勾选JustTrustMe：
第四步：回到主页面后，上滑动可以打开已经安装在VitualXposed的应用，点击你要抓包的应用，如“柠檬”，就可以在VitualXposed中启动这个APP，然后运行并抓包了。
在这里启动这个APP，这样就可以正常运行，并此时，在电脑的fiddler中就可以抓到这个APP的https的报文的明文内容了！
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31c2ab332c4ba7594bd125fa8faee3a/" rel="bookmark">
			JMeter 启动指南：详细解读如何启动 JMeter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache JMeter 的启动方法 Apache JMeter 是一个开源的性能测试工具，常被用来测试静态和动态资源以确定服务器的性能和稳定性。本文将介绍启动 JMeter 的方法。
Windows 系统 如果你已经配置好 Java 环境，启动 JMeter 可以直接在 bin 目录下打开 ApacheJMeter.jar 文件。
你也可以通过打开 bin 目录下的 jmeter.bat 文件来启动 JMeter。
值得注意的是，在打开 JMeter 的同时，会自动打开一个运行 JMeter 的命令行窗口。请不要关闭这个窗口，否则会将 JMeter 也关闭掉。
Mac 和 Linux 系统 在终端中输入以下命令即可启动 JMeter：
sh /path/to/jmeter/bin/jmeter.sh 更加快捷的启动方式是，直接在终端中输入 jmeter 命令。你需要进行以下配置：
在 ~/.bashrc 文件中添加以下内容： export JMETER_HOME=/path/to/jmeter export PATH=$JMETER_HOME/bin:$PATH 请将 JMETER_HOME 替换为实际的 Apache JMeter 所在目录。
如果你使用的是 zsh 终端，你需要修改 ~/.zshrc 文件，并添加与上述内容相同的配置。
让终端配置生效： source ~/.bashrc 或者在 zsh 终端中输入：
source ~/.zshrc 尝试一下吧，你会成功启动 JMeter！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31c2ab332c4ba7594bd125fa8faee3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc65ab8f881715b083560809dc64a31/" rel="bookmark">
			Socket closed 异常解决方案：如何解决 JMeter 压测中的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 JMeter 压测时会报 java.net.SocketException: Socket closed
java.net.SocketException: Socket closed at java.net.PlainSocketImpl.socketConnect(Native Method) at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) at java.net.Socket.connect(Socket.java:589) at sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:668) at org.apache.http.conn.ssl.SSLSocketFactory.connectSocket(SSLSocketFactory.java:542) at org.apache.http.conn.ssl.SSLSocketFactory.connectSocket(SSLSocketFactory.java:414) at org.apache.jmeter.protocol.http.sampler.LazySchemeSocketFactory.connectSocket(LazySchemeSocketFactory.java:97) at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180) at org.apache.jmeter.protocol.http.sampler.hc.ManagedClientConnectionImpl.open(ManagedClientConnectionImpl.java:318) at org.apache.jmeter.protocol.http.sampler.MeasuringConnectionManager$MeasuredConnection.open(MeasuringConnectionManager.java:114) at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:610) at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:445) at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83) at org.apache.jmeter.protocol.http.sampler.HTTPHC4Impl.executeRequest(HTTPHC4Impl.java:695) at org.apache.jmeter.protocol.http.sampler.HTTPHC4Impl.sample(HTTPHC4Impl.java:454) at org.apache.jmeter.protocol.http.sampler.HTTPSamplerProxy.sample(HTTPSamplerProxy.java:74) at org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.sample(HTTPSamplerBase.java:1189) at org.apache.jmeter.protocol.http.sampler.HTTPSamplerBase.sample(HTTPSamplerBase.java:1178) at org.apache.jmeter.threads.JMeterThread.executeSamplePackage(JMeterThread.java:498) at org.apache.jmeter.threads.JMeterThread.processSampler(JMeterThread.java:424) at org.apache.jmeter.threads.JMeterThread.run(JMeterThread.java:255) at java.lang.Thread.run(Thread.java:766) 可能原因 引起 java.net.SocketException: Socket closed 错误的原因通常是未设置连接的超时时间。
解决方案 如果在 “HTTP Request Sampler” 的 Basic 里选中了 “Use KeepAlive”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dc65ab8f881715b083560809dc64a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f842c3475d1f5638e9f2638ef6eb714e/" rel="bookmark">
			SQL Server注入之攻防技战法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 那天下着很大的雨，母亲从城里走回来的时候，浑身就是一个泥人，那一刻我就知道我没有别的选择了 1.Mssql报错注入 0.判断数据库类型 1.爆当前用户名 2.爆版本 3.爆服务器名 4.判断数据库个数 5.获取全部数据库 语句只适合&gt;=2005
爆当前数据库名：
爆其他数据库名：
再爆其他数据库：
爆MSSQL的默认数据库
6.爆表 爆数据库所有表（只限于mssql2005及以上版本）
爆表：
爆表：
爆其他表：
再爆其他表：
7.爆字段 一次爆指定表的所有列（只限于mssql2005及以上版本）：
爆字段
爆其他字段：
再爆其他字段：
8.爆数据 逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）：
爆数据：
9.判断权限 判断是否是DB权限
判断是否是SA权限
2.sqlmap工具注入 判断是否是dba权限
getshell执行命令
文笔生疏，措辞浅薄，望各位大佬不吝赐教，万分感谢。
免责声明：由于传播或利用此文所提供的信息、技术或方法而造成的任何直接或间接的后果及损失，均由使用者本人负责， 文章作者不为此承担任何责任。
转载声明：儒道易行 拥有对此文章的修改和解释权，如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经作者允许，不得任意修改或者增减此文章的内容，不得以任何方式将其用于商业目的。
CSDN: https://blog.csdn.net/weixin_48899364?type=blog 公众号： https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5NTU2NjA1Mw==&amp;action=getalbum&amp;album_id=1696286248027357190&amp;scene=173&amp;from_msgid=2247485408&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect 博客: https://rdyx0.github.io/ 先知社区： https://xz.aliyun.com/u/37846 SecIN: https://www.sec-in.com/author/3097 FreeBuf： https://www.freebuf.com/author/%E5%9B%BD%E6%9C%8D%E6%9C%80%E5%BC%BA%E6%B8%97%E9%80%8F%E6%8E%8C%E6%8E%A7%E8%80%85 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b66edce8302cd184f02a185c4da312/" rel="bookmark">
			假如你现在开始准备春招，拿到offer时，不敢相信你该会是一个多么快乐的程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 还有一个月就要过年了，过完年回来就是春招和金三银四的面试季了，秋招还没拿到意向offer，春招要怎么提前准备，才更有胜算呢？，今天分享一下面试前的准备技巧和一些Android面试要点，这篇文章适用于所有需要就业的小伙伴，不管你是名校毕业，还是双非出身，我相信这篇文章能给你带来一点点的小的收获！
准备技巧 1.复盘你的秋招 如果你秋招投了很多简历，却没有一个offer，那趁着这段时间，一定要好好复盘一下秋招的数据。投了多少家简历？笔试的有多少？进面试的有多少？分析到底是因为简历不够匹配还是面试不够突出。找出漏洞，点对点的去优化加强。
2.增加你的信息渠道 春招其实就是秋招的大规模补录，考的就是你能不能比别人更早更快更多的知道招聘信息。除了市面上大家比较熟悉的招聘软件外，也可以多看下各大企业自己的公众号和官网，一般这上面的信息更及时精准。
除此之外，还可以尝试拓展人脉资源。参加技术沙龙、开源项目、行业会议等活动，结识更多的人。这些人脉不仅可以帮助你了解行业动态，还可以在你求职时提供宝贵的内推机会。
3.充分准备面试环节 简历是你的入场券，面试才是你拿下offer的必杀器。一定要多去总结面试经验。可以对着镜子练习，调整自己的仪态、表情、语气；也可以找同学进行模拟，互相提问，找出自己的不足并加以改进。
4.关注行业动态和技术趋势 想要拿到心仪的offer，你需要对行业动态和技术趋势保持敏锐的洞察力。了解新技术的发展和应用，关注行业的最新动态和趋势，这样在求职过程中就能更有针对性地展示自己的能力和经验。
常见面试tips 不懂不要说不懂：面试官在知识深度上超出我们的掌握范围，如果问到不懂可以参考下面的做法：可以结合自己的理解去回答，无论正确与否，虚心请教若是有标准答案的问题但不懂，可以说：“目前还没有接触到这部分知识，面试完以后会去学习，加强理解！”
引导面试官：面试官抛出一个问题时，围绕该点展开回答，可以串联一些其它知识，但不要说太多，引导面试官
手撕代码：切忌抬手就写，要确定题意，对有不理解的地方要敢于提问。解题时跟面试官说自己的思路，以及每一步干什么，一边写一边向面试官解释。不要一开始就追求最优解，面试官不会太反感粗糙的代码，但他希望你是一个有逻辑、思路严谨的人。面试官会引导你优化你现有的代码，不必因为一开始写不出最优解而苦恼。
反问环节：要从面试官那儿获得对自己的反馈，比如：你觉得我的基础如何，之后该向哪个方向加强？当前企业最主要的技术栈是什么？公司目前的主要业务是什么？该岗位主要负责什么内容？
Android面试题 很多人对Android面试题都难以接受，认为无法衡量出一个程序员的真实水平。还有一部分原因，也是因为太难背了。
那我们到底还要不要背？
当然要背！但也不是死记硬背。在我们背诵的过程中，就把Android的核心知识有了一个深层次的记忆，在面试过程中也就游刃有余了。
这份八股文，高度总结了Android的高频考点以及核心内容。内容言简意赅，用于日常学习或者临阵磨枪都非常适合。
【扫描下方二维码即可免费领取完整的面试题+答案解析！！！】
第一章 算法和数据结构面试题汇总 第二章 Java核心基础面试题汇总 第三章 Java深入泛型与注解面试题汇总 第四章 Java并发编程面试题汇总 第五章 Java虚拟机原理面试题汇总 第六章 Java反射类加载与动态代理面试题汇总 第七章 网络编程面试题汇总 第九章 高级UI面试题汇总 第十章 Framework内核解析面试题汇总 第十一章 Android组件内核面试题汇总 第十二章 程序性能优化与数据持久化面试题汇总 第十三章 开源框架面试题汇总 有需要完整面试题的朋友，可以扫描下方二维码免费领取！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a43d655398b5091fa696f4c5de17483/" rel="bookmark">
			【数学建模美赛M奖速成系列】Matplotlib绘图技巧（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matplotlib绘图技巧（二） 写在前面2. 函数间区域填充函数fill_between()和fill()参数： 3. 散点图 scatter4. 直方图 hist5. 条形图 bar5.1 一个数据样本的条形图参数： 5.2 多个数据样本进行对比的直方图5.3 水平条形图参数 5.4 绘制不同数据样本进行对比的水平条形图5.5 堆叠条形图 6. 等高线图 meshgrid 写在前面 前面我们讲过，好的图表在论文写作中是相当重要的，这里学姐为继续为大家分享一些Matplotlib快速入门内容以及论文绘图的技巧，帮助大家快速学习绘图。这里整理了完整的文档与技巧，有需要的同学看文章最后，另外，如果没有美赛经验想要获奖，欢迎咨询哦~
2. 函数间区域填充函数fill_between()和fill() plt.fill_between(x, y1, y2, where， color, alpha)
参数： x: x轴坐标值，为一个listy1: 第一条曲线对应的函数值，为x对应的函数值listy2: 第二条曲线对应的函数值，为x对应的函数值listwhere: 条件表达式，用于判断某个区间内是否进行填充，如果判断为True，则进行填充，否则不填充color: 填充区域的颜色alpha: 填充区域的透明度，1表示不透明，0表示完全透明
一些实例可以参考基于matplotlib的数据可视化（图形填充函数fill和fill_between） import numpy as np import matplotlib.pyplot as plt n = 256 X = np.linspace(-np.pi,np.pi,n,endpoint=True) Y = np.sin(2*X) plt.axes([0.025,0.025,0.95,0.95]) plt.plot (X, Y+1, color='blue', alpha=1.00) plt.fill_between(X, 1, Y+1, color='blue', alpha=.25) plt.plot (X, Y-1, color='blue', alpha=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a43d655398b5091fa696f4c5de17483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0bd166438731028152e8b70da5e8e3c/" rel="bookmark">
			sublime text 打开 txt 文档乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于 windows 系统使用系统自带的 txt 编辑工具，默认打开和保存文件的文件的格式是 GBK 或者 GB2312，而 sublime 默认仅支持 utf-8，所以当从 windows 系统拷贝文件在 mac 上浏览有时候会出现乱码的问题，这时候就需要安装插件使 submile 对这两种编码格式进行支持
1. 输入快捷键 ctr+shift+p 有如下显示：
安装 ConverToUTF8 插件，问题完美解决了。
步骤：按键 Ctrl+Shift+P -&gt; 输入 IP -&gt; 选择 Package Control: Install Package -&gt; 输入 ConvertToUTF8 -&gt; 回车。
左下角滚动提示正在安装，待安装完成，重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f33157109b5fe33b934f395069521f/" rel="bookmark">
			Linux-DNS域名解析服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正向解析
安装服务
yum install bind -y
修改配置文件
vi /etc/named.conf
listen-on port 53 { any; }; ……
allow-query { any; }; //改成any
修改区域配置文件
vi /etc/named.rfc1912.zones
将选中区域复制一份
将上面的allow删除 如下配置文件 修改为bdqn.com
zone "aa.com" IN { //定义一个正向区，名称是hello.com
type master; //区域类型是主服务器
file "aa.com.zone"; //区域数据文件，正向区通常以zone结尾。
进入目录
cd /var/named/
复制文件
进入配置文件
将选中区域删除
修改配置文件内容
重启服务
进入配置文件
vi /etc/resolv.conf
在named目录下面修改权限 重启服务
查看 正向区域解析域名
反向解析
进入配置文件
vi /etc/named.rfc1912.zones
选择复制的区域 修改
添加数据 进入目录
复制 进入配置文件
10指的是地址
查看 反向区域解析ip地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312b91a99dbe00637de105eedf3c4966/" rel="bookmark">
			机器学习的算法简单介绍-随机森林算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随机森林 随机森林目前在学习的过程中，并未使用到，因此，仅仅简单的介绍一下相应的概念和应用的方面，等后续学习的过程中使用到，会继续进行补充。
随机森林（Random Forest）可以看作是一种集成学习方法，属于 Bagging（Bootstrap Aggregating） 类型的算法。它建立在决策树的基础上，通过构建多个决策树并将它们整合在一起，提高了模型的性能和鲁棒性。以下是随机森林的主要特点和工作原理：
主要特点：
1.集成学习： 随机森林通过构建多个弱学习器（决策树）并组合它们来形成一个强学习器。 2.决策树基学习器： 随机森林的基学习器通常是决策树。每个决策树都是独立训练的，通过对训练数据的不同采样得到。 3.随机抽样： 随机森林使用自助采样（Bootstrap Sampling）技术，从原始训练集中随机抽取多个样本形成新的训练子集，有放回地采样。 4.随机特征选择： 在每次决策树的构建过程中，对于每个节点的划分，随机选择一部分特征进行考虑，而不是全部特征。这有助于增加决策树之间的多样性。 5.投票机制： 针对分类问题，随机森林使用投票机制来确定最终的预测结果。对于回归问题，通常取所有决策树预测值的平均值。 工作原理：
随机采样： 从原始数据集中有放回地抽取一定数量的样本，构建一个新的训练子集。 随机特征选择： 在每个节点的决策树构建过程中，随机选择一部分特征进行划分。 构建决策树： 使用随机采样的训练子集和随机选择的特征构建决策树。 重复步骤： 重复上述步骤，构建多个独立的决策树。 集成： 针对分类问题，通过投票机制汇总每个决策树的预测结果；对于回归问题，取所有决策树预测值的平均值。 优点：
随机森林对于高维数据和大规模数据集表现良好。 具有较强的鲁棒性，能够处理不平衡数据集。 不容易过拟合，无需复杂的参数调整。 缺点：
对于少数类别的样本可能预测性能较差。 模型的可解释性相对较差。 随机森林是一种强大且广泛应用的机器学习算法，适用于分类和回归问题。由于其高性能和鲁棒性，随机森林在实际应用中得到了广泛的应用。
随机森林的应用 随机森林的一些常见应用：
分类问题： 随机森林在分类任务中表现优秀。它可用于垃圾邮件过滤、文本分类、图像识别、医学诊断等领域。 回归问题： 随机森林也可用于解决回归问题，如股票价格预测、房价预测、销售量预测等。 异常检测： 随机森林可以用于检测异常值或异常模式，例如在网络安全中检测异常的网络活动。 特征选择： 随机森林可以用于评估特征的重要性，帮助进行特征选择或降维，提高模型的解释性和训练效率。 集成学习： 随机森林是一种集成学习方法，可与其他算法结合使用，提高模型的泛化能力和鲁棒性。 医学应用： 在医学领域，随机森林可用于疾病诊断、药物设计、患者风险评估等方面。 金融领域： 随机森林可应用于信用评分、欺诈检测、投资组合优化等金融问题。 农业预测： 用于作物预测、土壤分析和农业管理。 生态学研究： 随机森林可以帮助分析和预测生态系统的变化，包括植被覆盖、野生动物迁徙等。 工业制造： 随机森林可用于预测设备故障、优化生产流程和质量控制。 分类问题： 垃圾邮件过滤 文本分类 图像识别 医学诊断 回归问题： 股票价格预测 房价预测 销售量预测 异常检测： 异常网络活动检测 特征选择： 评估特征的重要性 特征选择 数据降维 集成学习： 与其他算法结合使用 提高模型的泛化能力和鲁棒性 医学应用： 疾病诊断 药物设计 患者风险评估 金融领域： 信用评分 欺诈检测 投资组合优化 农业预测： 作物预测 土壤分析 农业管理 生态学研究： 植被覆盖分析 野生动物迁徙预测 工业制造： 设备故障预测 生产流程优化 质量控制 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7aa48519c581de5a35b13f8b435bfe2/" rel="bookmark">
			JavaSE学习笔记 2024-1-3 --JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC « 上一篇
个人整理非商业用途，欢迎探讨与指正！！
文章目录 JDBC1.JDBC简介2.JDBC连接步骤3.JDBC入门案例3.1加载驱动3.2第一个JDCB程序 4.JDBC的CRUD操作4.1insert操作4.2delete操作4.3修改操作4.4查询单个操作4.5查询多条数据 5.工具类的封装6.封装DTO和DAO6.1封装DTO6.2使用DTO封装查询结果6.3使用DTO作为DML方法参数 1.JDBC简介 Java与数据库的连接方案，数据库编程
Java DataBase Contectivity
分为两个部分:
JDK:配置完成
SDK:是由数据库厂商提供的api,可以帮助我们连接java
根据数据库版本下载jar包
2.JDBC连接步骤 1.加载驱动
2.创建连接
3.准备语句对象
4.执行SQL指令
5.处理结果
6.关闭资源
3.JDBC入门案例 3.1加载驱动 我们需要预先准备数据库厂商提供的SDK(jar文件)
jar文件:其实就是一个压缩包,内部存放的是.class文件(第三方为我们编辑好的,可以直接使用的)
例如:mysql-connector-java-8.0.17.jar
mysql主流有两个版本:5.x 和 8.x 都有对应的jar文件提供
将驱动的jar文件,添加到java项目(工程)中
1.在java项目下创建lib文件夹
2.将下载好的jar文件,复制粘贴到lib中
3.选择jar文件,右键"Build Path"
3.2第一个JDCB程序 package com.qf.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class Demo01 { public static void main(String[] args) throws Exception { //	1.加载驱动(之前已经"biu"成功) //	将SDK中提供的驱动类,可以帮助我们进行JDBC连接的一个类,添加到JVM中 Class.forName("com.mysql.cj.jdbc.Driver"); //	2.创建连接 //	通过JDK提供的,DriverManager类获取数据库连接 //	url:数据库统一的资源定位器(为了连接到指定的数据库资源使用的) String url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7aa48519c581de5a35b13f8b435bfe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e781c3541c9995406e26d532e4bae7c/" rel="bookmark">
			【LeetCode每日一题】2487. 从链表中移除节点（调用栈&#43;递归&#43;翻转链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024-1-3
文章目录 [2487. 从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/)方法一：调用栈方法二：递归方法三：翻转链表 2487. 从链表中移除节点 方法一：调用栈 1.将所有节点按顺序压入栈中
2.从栈顶依次查看元素
3.当栈顶节点的值大于新链表表头的值，将该节点插入新链表的表头
4.否则移除该节点
public ListNode removeNodes(ListNode head) { Deque&lt;ListNode&gt; stack = new ArrayDeque&lt;&gt;(); while (head!=null){ stack.push(head); head = head.next; } while (!stack.isEmpty()){ if (head==null||stack.peek().val&gt;=head.val){ stack.peek().next = head; 将该节点插入新链表的表头 head = stack.peek(); //表头前移 } stack.pop(); } return head; } 方法二：递归 1.节点为空返回
2.不为空，对右侧节点进行判断
3.比右侧节点小，移除当前结点，返回下一个结点
4.比右侧节点大，返回当前结点
public ListNode removeNodes(ListNode head) { if (head == null){ return null; } head.next = removeNodes(head.next); if (head.next!=null &amp;&amp; head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e781c3541c9995406e26d532e4bae7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d373ec8b9f37a1c81c936d086793e738/" rel="bookmark">
			百度搜索&amp;金融：构建高时效、高可用的分布式数据传输系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 搜索技术平台研发部
导读 introduction
分布式数据传输系统是一种用于在多个计算节点之间高效传输大量数据的系统，诣在高效的解决大规模数据迁移、备份、跨地域复制等问题，其广泛应用在实时数据流传输、跨数据中心数据迁移、多媒体传输等场景，在大多数企业中的日志管理、业务数据建库等场景中也都会使用到。众所周知，数据的高效传输往往直接影响着企业对市场先机的把握，对企业发展有重要意义，特别是在金融领域，如证券行业，它对分布式数据传输系统的设计提出了更高的要求，证券领域数据变化飞快，一个高时效、稳定的数据流传输系统不仅能有效的提升用户体验，更能提供用户一手的投资信息，有助于用户的投资决策，进而拉进企业与用户的距离。本文将通过一个百度搜索下的金融案例来分享分布式数据传输系统的设计。
全文7584字，预计阅读时间19分钟。
GEEK TALK
01
背景
作为百度搜索场景下时效性要求较高的业务，金融承载着每天数千万次的用户搜索请求，而在2021年以前，金融业务的数据一直都是采用传统的互联网引入方式，该方式的特点是接入成本较低，但受公网等不可控因素影响，数据时效性较差，且数据断流、错误等问题频出，随即而来的就是业务维护成本较高，十分不利于产品迭代，基于此发起了一个证券数据直连项目，诣在通过接驳全球各大证券交易所数据中心来构建一个高时效、高可用的分布式传输系统，从而有效的解决传统数据引入方式（公网抓取、推送）所带来的时效性、稳定性、正确性等问题，进而满足全国乃至全球用户的金融需求。
GEEK TALK
02
设计目标
业务
接驳全球各大证券交易所Level-1行情数据（简称LV1行情，是交易所根据交易规则发布的即时行情信息，数据格式包括基于FIX/FAST协议的接口和TXT文件、二进制数据流等，行情通过交易所信息技术公司的高速地面网和宽带广播卫星系统发布或上证所信息网络有限公司的互联网和专线传输。），来覆盖全量上市公司股票、外汇、期货、ETF、涡轮牛熊等证券业务来满足用户需求，时效性追平金融行业竞品，为打造强大的金融生态做数据基建储备。
技术
1、基础设施建设：协同交易所、运营商完成物理专线的链路部署，通过物理专线接入的方式在百度云机房接入上海、深圳、香港、纳斯达克证券交易所数据中心，适配交易所单、组播协议将二进制流/文本数据引入到百度内部，再分别完成华南、华北、华东、香港（支持海外访问）地域的数据存储与转发，同时支持负载和流量调度来支撑各地域的用户请求。
2、时效性&amp;稳定性提升：行情数据检索99分位耗时不超过200ms，数据稳定性从99%提升至99.99%以上，数据灾备能力从1主0备升级至1主2备。
3、数据安全：基于百度安全能力，构建类似的防火墙策略来严格控制每一个机房、每一个集群的出入权限，并且配置好相应的安全组策略。
△注：这里的物理专线特指光缆 GEEK TALK
03
关键思路
从功能和网络拓扑上来看，一个高时效、高可用的金融数据传输系统至少需要包含以下几个部分：
接入层：适配全球各大交易所单、组播传输协议，确保数据能在专线物理网络正常传输。
接入主要有2种方式，一种是走互联网，一种是走物理专线，前者相对比较灵活，各类数据协议基本都可以支持，有直接走HTTP（GET/POST），或者是走消息队列的发布订阅等等，接入成本较低，属立即接入那种，但受公网的不可控因素影响，在传输效率和安全性上相对后者会有比较大的差距，我们一般会把互联网的方式当做一个灾备能力存在；专线方式的特点是仅点对点传输，由于用的是独立的光缆，在有限带宽内理论可以做到无争用状态，不受公网影响，属可靠传输，传输协议私有化，增加了更多的认证机制，因此也更安全，区分不同应用场景，像证券类数据传输，一般交易所采用的是单播、组播方式，当下用的多的是组播，另外专线中也有主备的概念，一般会预留1-2条线路做灾备，整体下来，专线的费用要更昂贵一些，接入的周期也更长，往往长达几个月。
网络层：完成华南、华北、华东百度云机房虚拟网络架构建设，包括子网、路由、网关等。
虚拟网络的核心组成部分主要是子网、路由、网关、虚拟机，其中每个子网关联着一个虚拟机集群，我们把整个组成部分（域）统称为一个VPC（Virtual private Cloud），路由又区分为TGW路由和对等连接，这里主要关注对等连接，它是为用户提供了VPC级别的网络互联服务，使用户实现在不同虚拟网络之间的流量互通，实现同区域/跨区域，同用户/不同用户之间稳定高速的虚拟网络互联，其核心是基于对路由表的操作，对等连接也支持配置地域级的DNS同步；网关又分位NAT网关和专线网关，一个对外，比如设置SNAT和DNAT规则用于统一网段的外网出口，一个对内，对内其实就是确保能够走专线和内部网络打通。
传输层：完成各机房内的数据解析、存储、同步、转发等。
对于接入层获取到的数据我们分为三个级别，像交易所主要是二进制流、文本为一级数据，我们需要保留近一段时间的原始数据落在本地（一级数据管理集群），以便用作应急回放；而解码后的数据为二级数据，落在二级数据管理集群上，主要用于跨地域同步；最后，对解码后的数据进行计算&amp;加工，作为三级数据，落在三级数据管理集群用于承接应用服务，同时，按协议解码后的数据按照使用场景区分为实时流（如分时）、延时流（如K线），延时流经过实时流计算得来，实时流同步进内存用于提升IO效率，延迟流通过实时流的计算后异步进DB，DB维护在三级数据管理集群上。
应用层：负载/流量调度、监控能力等建设。
应用层的设计，主要有两个方面的考虑，一方面是对于接入层的负载和流量调度，如通过部署websocket/http服务来支撑百度用户流量，使用BLB（Baidu Load Balance）将同一区域的多台百度智能云服务器虚拟成一个组，设置一个内网或外网的服务地址，将前端并发访问转发给后台多台云服务器（BCC），实现应用程序的流量均衡，性能上实现业务水平扩展。负载均衡还通过故障自动切换及时地消除服务的单点故障，提升服务的可用性，支持服务器调度权重策略配置，并支持TCP、HTTP等协议；一方面是对监控的应用，如请求/数据传输日志落盘、统计、分析以及流量和sla监控等。
将以上四层能力建设后，此时单机房内的网络拓扑应该如下图所示：
△注：DCC/BBC/BCC都是百度云范畴的机器类型，更多细节可以参考百度智能云私有网络（https://cloud.baidu.com/doc/VPC/s/Vjwvytu2v） GEEK TALK
04
核心难点&amp;解决方案
难点1
公网&amp;私有网络方式下如何在云上完成多协议适配，尤其是在私有网络中适配单播、组播协议以及如何做组播转单播。
公网&amp;私有网络接入介绍
对于一个数据传输系统来说，最重要的一点其实就是能支持多协议的数据适配来提升系统的灵活性，证券交易所一般提供的接入方式有公网接入和私有网络接入，公网接入的成本较低，一般周粒度就可完成，没有复杂协议约束；而私有网络往往会有更高的要求，协议上大部分都要求具备单播介入能力，少部分像纳斯达克和深圳交易所会要求下游支持组播接入。绝大多数的云厂商是无法直接在虚拟机上适配的，传统券商基本都是完全使用昂贵的物理机资源来承载，虽然物理机插拔更方便也更稳定，但运维管理成本也更高，两种方式在效果和成本上也有本质的区别：
1、公网接入：公网比较常见的数据接入方式主要是HTTP/HTTPS方式，当然也会有RPC/FTP，只是用的相对少一些，为了提升数据传输安全，双方可以在调用前协商好数据加密算法和密钥，优点是接入成本较低，能快速应用，尤其在跨洋传输上会有体现，缺点是走的公共线路，网络不可靠，且数据易被截获，当攻击者捕获两端的数据包后，哪怕不能完全解析，也可以实施一些流量攻击手段以影响服务稳定性，总的来说，一般不会对于安全性、时效性要求较高的数据采用该方式接入，更多是只是一种备用方式（特殊场景除外，如跨洋传输）。
2、私有网络接入：公司内网其实就属于一个私有网络，但是对于跨公司传输数据的场景，要想构建私有网络，一般会走物理专线接入的方式，这种点对点传输方式的显著优点是专网专用且安全性较高，基本不受公共网络影响（自然灾害等不可抗力除外），在带宽范围内基本可以做到无网络争用状态（数据即发即达），由于是私有网络（双端内网传输），基本不用担心数据安全问题，而且往往还会增加额外的数据校验手段，尤其在金融场景，会有严格的token（硬/软）认证，该方式的缺点是成本相比公网传输接入成本更高，一般要持续数月，费用更昂贵，一般在上百万元，依赖选取的传输介质（一般选择光纤）和带宽。
私有网络中单播、组播协议接入方案
私有网络有单播、广播、组播之分，单播相对比较好适配一些，走静态路由的方式在同一个VLANID下分别配置云端和IDC端的IP段作为IPV4专线互联地址即可；广播一般是对于服务端而言，比如证券交易所下游对接着全球范围的所有券商，数据源是相同的，一般会采用广播的机制把数据推送给所有下游；组播协议一般是要求下游需要适配，现如今大部分业务都已经上公有云，在云上常用虚拟化技术来完成服务器集群的部署，对于虚拟机来说，更多的支持单播传输，不支持组播传输，往往需要在专门的物理设备（组播路由器、或特定的组播软件）上配置转发组播报文的路由，路由表关联着具体的路由协议（如PIM），再用IGMPV3协议来完成组播成员和报文的管理，通过动态BGP维护邻居关系（现在的云厂商上对BGP的可能是固定分配AS号，如果有AS的要求还是需要在物理机上单独做），我们可以圈出一部分物理资源专门承载组播数据传输，通过配置IGMP Snooping（可以将组播报文转发到二层数据链路层，实现组转单，注意版本需要是3，否则无法转发IGMPV3报文） + AP完成组播转单播配置，再通过双网卡（WAN口+LAN口）形式实现专线网络数据接入&amp;同步到百度内网，物理机通过三层交换机来关联，构造出类似下面的网络拓扑：
难点2
数据管理&amp;跨地域同步，数据灾备能力、时效性提升。
数据的分层管理主要是应对单机房内的场景，而对于跨机房或者说跨地域的主要难点是数据同步，后者需要更多的考虑跨机房数据传输效率和灾备管理，核心是网络设计：
1、数据管理：按使用场景的不同，将数据分交易所二进制流数据（原始数据流）、文本数据、业务数据/日志等：
原始数据流主要应对单机房、跨机房传输场景，当出现下游业务服务异常导致的数据展现错误时，存储的原始数据流可以很好的对数据进行回放，以便快速恢复业务，尤其是应对金融证券数据传输场景，证券交易所一般不会推送重复数据，如果下游业务服务异常导致存储的业务数据全部失效或为脏数据，那可能只能通过refresh主动请求上游来重新获取，但这样做可能会出现核心数据丢失，由于这种方式的效率较低，还会扩大业务受损的影响面，因此一般会先存储交易所下发的原始数据流，业务可以自定义存储方式和周期，当出现问题时，可以通过『重播』原始数据流来止损，另外原始数据流还能用于在对等网络中的跨机房恢复业务数据。
业务数据流主要应对单机房传输的场景，根据模块分工的不同，分证券的实时行情、历史行情等等，对于单机房数据集群的管理我们有很多方式，对于自研的DB，在调度上可以用一些标准的分布式管理手段（如zk），数据同步的手段一般需要自定义，对于传统的DB如Mysql、Redis、Mongo等，一般有标准化的数据同步方式和调度模式。
2、跨地域同步：跨机房地域同步的前提是多个机房之间需要有直接或间接关联关系的专用物理网络，即确保网络是可达的，然后再结合虚拟网络完成子网及路由配置，对于具有直接网络关联关系的2个机房来说，我们的对等网络（Peer Connection）设计稍微简单一些，现在各个云厂商也基本都支持直接配置了，其原理是首先在同一个VPC下划分好子网并规划好集群规模，其次通过配置路由表的方式完成本端和对端的下一跳关联，这样就完成了2个直接对端的对等网络建设，接着再配置和内网专线的路由，就能做到云机房-&gt;内网机房的网络互通；但如果2个机房没有直接关联关系，而又需要完成本端和对端数据同步怎么办呢，比如有A B C三个机房，只有A-B B-C有直接关联关系，而我们想要让A-C关联，这时候不可能说再建立一条物理链路，我们可以采用类似桥接的方式（或者叫隧道），同时关联A-B-C三个机房，其中B作为一个"网桥"，再通过NAT技术完成IP地址转换，确保C可以识别从A过来的路由，而A-B B-C 正常采用对等网络的方式完成基础网络配置，这样就可以胯多个机房进行通信，由于是物理网络传输，机房间的耗时不会有很大差别（30ms内）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d373ec8b9f37a1c81c936d086793e738/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800243c56ebfdf3cf3d96cf1592c778b/" rel="bookmark">
			JavaSE学习笔记 2023-12-28 --MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 1.数据库介绍 数据库:数据仓库 DataBase:简称DB,用于长期存储有结构的,大量的,共享的数据 长期的:持久存储,永久存储 有结构: 有类型,有内部的数据类型 有关系,数据与数据之前是有关联的 大量的: 大多数据库都是以文件系统存在的,可以将数据存储在磁盘中 共享的: 多个应用之间可以共享一个或多个数据库资源 2.数据库的分类 关系型数据库 关系型数据库采用关系表的形式进行数据的存储 可以通过表与表之间的关系来维护数据的关系 例如:用户 --- 购买 --- 商品 用户信息 --- 用户类 --- 用户表 常用的库:MySQL,Oracle,SQLServer... 非关系型数据库 采用键值对的数据模型来存储数据的,只完成数据的记录,不会有任何的关联关系 NoSQL:Not Only SQL 常见的库:redis,MongoDB... 3.数据库中的常用术语 数据库(DataBase):存储数据的集合 数据(Data):被描述的事物符号记录 数据库管理系统(DBMS,DataBase Management System) 用于管理数据库软件系统 数据库管理员(DBA,DataBase Administrator) 负责创建数据库,使用以及维护数据库的专业人员 数据库系统(DBS,DataBase System) 数据库管理员,数据库管理系统以及数据库组成的整个单元结构 4.数据库安装和配置 MySQL环境准备 下载,安装,配置,卸载 版本: 企业中主流的版本5.x和8.x 本次使用mysql8 安装: 参考攻略 mysql服务的启动和停止: 此电脑---&gt;右键---&gt;管理---&gt;服务和应用程序---&gt;服务---&gt;mysql相关 服务停止的原因:1.计算机改名 2.手动停止 3.外部的一些游戏加速器会停止该服务 软件卸载: 官方:关闭服务---&gt;控制面板点击程序卸载---&gt;自带的卸载程序---&gt;删除目录:mysql安装目录---&gt;删除注册表:win+r输入regedit geek:直接卸载所有内容 管理工具: 可视化工具,数据库的一个图形管理工具 mysql自带clc(免费的) Navicat for MySql(需要破解的) mysql8配合navicat12+ mysql5配合navicat11- SQLyog(需要破解的) DBeaver(免费的) 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800243c56ebfdf3cf3d96cf1592c778b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b0299dc7bbacafd227fae3f8690f7d/" rel="bookmark">
			训练神经网络(上)激活函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍几种激活函数,只作为个人笔记.观看视频为cs231n
文章目录 前言
一、Sigmoid函数
二、tanh函数
三、ReLU函数
四、Leaky ReLU函数
五、ELU函数
六.在实际应用中寻找激活函数的做法
总结
前言 激活函数是用来加入非线性因素的，提高神经网络对模型的表达能力，解决线性模型所不能解决的问题。
一、Sigmoid函数 这个函数大家应该熟悉在逻辑回归中曾用到这个sigmoid函数
这个函数可以将负无穷和正无穷映射到(0,1)上即
如果你有一个非常大的输入值那么就会接近于1
如果你有一个非常小的输入值那么就会接近于0
但这个函数会出现几个问题.
1.饱和神经元使得梯度消失
梯度下降法（以及相关的L-BFGS算法等）在使用随机初始化权重的深度网络上效果不好的技术原因是：梯度会变得非常小。具体而言，当使用反向传播方法计算导数的时候，随着网络的深度的增加，反向传播的梯度（从输出层到网络的最初几层）的幅度值会急剧地减小。结果就造成了整体的损失函数相对于最初几层的权重的导数非常小。这样，当使用梯度下降法的时候，最初几层的权重变化非常缓慢，以至于它们不能够从样本中进行有效的学习。这种问题通常被称为“梯度的弥散”.
从图中我们可以看到在图的两端的梯度越来越接近为0,经过链式法则后会让梯度流消失,这样在使用梯度下降法时参数会更新的非常缓慢,也就是上面所说的梯度弥散问题.
2.sigmoid函数是一个非零中心的函数
神经网络：激活函数非0中心导致的问题 - 知乎 (zhihu.com)
这里有篇知乎文章可以帮助大家更好理解,其实大家把公式推一下就可以理解了,最后导致所有的w参数只能每次沿正或者负方向变换就导致,以z字形逼近最优参数,导致梯度下降的收敛较慢.
3.对e指数的计算量有一点大
二、tanh函数 双曲正切函数是双曲函数的一种。双曲正切函数在数学语言上一般写作 tanh。它解决了Sigmoid函数的不以0为中心输出问题，然而，梯度消失的问题和幂运算的问题仍然存在.
三、ReLU函数 ReLU，全称为：Rectified Linear Unit，是一种人工神经网络中常用的激活函数，通常意义下，其指代数学中的斜坡函数，即
ReLU函数的优点
SGD算法的收敛速度比sigmoid和 tanh 快;(梯度不会饱和，解决了梯度消失问题)计算复杂度低，不需要进行指数运算;适合用于后向传播。 ReLU函数的缺点
ReLU的输出不是zero-centered;ReLU在训练的时候很"脆弱”，一不小心有可能导致神经元"坏死”。举个例子:由于RelU在x&lt;0时梯度为0，这样就导致负的梯度在这个ReLU被置零，而且这个神经元有可能再也不会被任何数据激活。如果这个情况发生了，那么这个神经元之后的梯度就永远是0了，也就是ReLU神经元坏死了，不再对任何数据有所响应。实际操作中，如果你的learning rate很大，那么很有可能你网络中的40%的神经元都坏死了。当然，如果你设置了一个合适的较小的learning rate，这个问题发生的情况其实也不会太频繁。，DeadReLU Problem （神经元坏死现象)︰某些神经元可能永远不会被激活，导致相应参数永远不会被更新(在负数部分，梯度为0)。产生这种现象的两个原因:参数初始化问题; learning rate太高导致在训练过程中参数更新太大。解决方法:采用Xavier初始化方法，以及避免将learning rate设置太大或使用adagrad等自动调节learning rate的算法。ReLU不会对数据做幅度压缩，所以数据的幅度会随着模型层数的增加不断扩张。
四、Leaky ReLU函数 Leaky ReLU函数通过把x xx的非常小的线性分量给予负输入0.01 x 来调整负值的零梯度问题。
Leaky有助于扩大ReLU函数的范围，通常α 的值为0.01左右。
Leaky ReLU的函数范围是负无穷到正无穷。
五、ELU函数 没有Dead ReLU问题，输出的平均值接近0，以0为中心。ELU 通过减少偏置偏移的影响，使正常梯度更接近于单位自然梯度，从而使均值向零加速学习。ELU函数在较小的输入下会饱和至负值，从而减少前向传播的变异和信息。ELU函数的计算强度更高。与Leaky ReLU类似，尽管理论上比ReLU要好，但目前在实践中没有充分的证据表明ELU总是比ReLU好。 六.在实际应用中寻找激活函数的做法 总结 本文介绍了神经网络的几种激活函数,后面还会更新剩余几个激活函数,大致了解一下每个函数的图像的样子,以及在实践中我们一般寻找激活函数的做法.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14945e6489ed6e764cb88bdd240a01a5/" rel="bookmark">
			JavaSE学习笔记 2023-12-27 --Java8.0新增特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二十三、Java8.0中新增的特性 « 上一篇
个人整理非商业用途，欢迎探讨与指正！！
文章目录 二十三、Java8.0中新增的特性23.1Lambda表达式23.2函数式接口23.2.1自定义函数式接口23.2.2常见的函数式接口 23.3Lambda简化23.4Stream流23.5新增时间API 23.1Lambda表达式 就是特殊的匿名内部类,简化匿名内部类的写法
允许将一个函数(接口)作为方法的参数,把代码向参数一样传递
能被简化的接口中要求只能有一个方法
语法:箭头语法
() -&gt; {}
package com.qf.test; import java.io.File; import java.io.FileFilter; import java.io.FilenameFilter; import java.util.Arrays; public class Demo01 { public static void main(String[] args) { //	使用内部类的写法 new Thread(new Runnable() { @Override public void run() { System.out.println("内部类的形式启动线程"); } }).start(); //	使用Lambda表达式 无需管理接口是什么,只要保证接口中只有一个方法 new Thread(()/*无参方法*/ -&gt; { System.out.println("Lambda的形式启动线程"); }/*方法体*/).start(); //	省略 当且仅当只有一条语句时,{}可以省略 //	简化写法 new Thread(() -&gt; System.out.println("Lambda的简化形式启动线程")).start(); System.out.println("----------------------------"); File file = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14945e6489ed6e764cb88bdd240a01a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9954e28e807fbc650c2570c0cf01160/" rel="bookmark">
			HTML5-简单文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件操作 简介 概念：可以通过file类型的input控件或者拖放的方式选择文件进行操作
语法格式：
&lt;input type="file" multiple&gt; 属性
multiple：表示是否选择多个文件
accept：用于设置文件的过滤类型（MIME类型）
如果想要同时设置多个过滤类型，可以用英文逗号（,）隔开
&lt;input type="file" accept="image/jpeg,image/png" /&gt; 常见的acept属性取值/MIME类型
属性值说明image/jepgJEPG图片image/pngPNG图片image/gifGIF图片text/plainTXT文件text/htmlHTML文件text/cssCSS文件text/JavaScriptJS文件text/xmlXML文件audio/mpegMP3文件audio/mp4MP4文件application/mswordWord文件application/vnd.ms-powerpointPPT文件application/vnd.ms-excelExcel文件application/pdfPDF文件image/*所有图片文件audio/*所有声音文件video/*所有视频文件 实例
&lt;form action=""&gt; &lt;!-- 选择单个文件 --&gt; &lt;input type="file"/&gt;&lt;br/&gt; &lt;!-- 选择多个文件 --&gt; &lt;input type="file" multiple /&gt; &lt;/form&gt; 运行结果
注意：为元素添加multiple属性后，就可以选择多个文件了。当选择成功后，按钮右侧不再显示文件的名称，而是显示文件的总量。当鼠标指针移到上面时，就会显示全部上传文件的详细列表
File对象 概念：在文件上传元素中，将会产生一个FileList对象，这是一个类数组对象，表示所有文件的集合。
其中，每一个文件就是一个File对象
想要获取某一个File文件对象
首先需要获取FileList对象
然后通过数组下标形式来获取
File对象属性
属性说明name文件名称type文件类型size文件大小（单位为B）lastModifiedDate文件最后的修改时间 实例：File对象的属性
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;file对象的属性&lt;/title&gt; &lt;script&gt; window.onload=function(){ //获取FileList对象 var oFile=document.getElementById("file"); oFile.onchange=function(){ //获取第1个文件，即File对象 var file=oFile.files[0]; console.log("图片名称为:"+file.name); console.log("图片大小为:"+file.size+"B"); console.log("图片类型为:"+file.type); console.log("修改时间为:"+file.lastModifiedDate); }; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt;	&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9954e28e807fbc650c2570c0cf01160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70df1c286c74d1e89e06b0cfed5c1d86/" rel="bookmark">
			深度学习框架解读—Yolov5/Yolov7/Halcon对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名机器视觉深度学习算法工程师，我从技术实现、性能、适用场景和易用性等方面来评价YOLOv5、YOLOv7和Halcon中的深度学习框架。以YOLOv5和YOLOv7进行比较，并结合Halcon的深度学习功能进行综合评价。
Yolov5 优点： 1. 速度快：YOLOv5在保持较高准确度的同时，具有极快的推理速度，非常适合实时应用场景。
2. 轻量化：YOLOv5的模型相较于其他版本更轻量，易于部署在资源受限的设备上。
3. 社区活跃：YOLOv5由于其开源和易于使用的特性，拥有非常活跃的社区支持，这意味着问题可以快速得到解答，且不断有新的改进和特性加入。
擅长领域： -实时目标检测
-移动和边缘计算设备
快速原型开发和研究
使用建议： 对于需要在边缘设备上实现实时目标检测的场景，YOLOv5是一个非常好的选择。
利用其轻量化的特点，可以在不牺牲太多准确度的情况下进行快速部署。
利用活跃的社区资源，可以快速迭代和改进模型。
Yolov7 优点： 1. 准确度高：YOLOv7在多个标准数据集上展现了优秀的性能，准确度通常高于YOLOv5。
2. 架构改进：YOLOv7在网络架构上进行了多项改进，增强了模型的表现力。
3. 多尺度检测：YOLOv7在处理不同尺度的目标上表现更为出色，这得益于其改进的多尺度检测能力。
擅长领域： 需要高准确度的复杂场景识别
大规模视觉任务
研究和开发，需要最新的目标检测技术
使用建议： 在对准确度有较高要求的应用中，YOLOv7是更好的选择。
在处理多尺度目标检测问题时，YOLOv7的性能通常优于YOLOv5。
适合研究人员和开发人员，他们需要最新的目标检测技术来解决复杂问题。
Halcon 优点： 1. 集成度高：Halcon提供的是一个集成的机器视觉解决方案，包括预处理、特征提取、分类、定位等多种功能。
2. 工业标准：Halcon在工业界被广泛采用，符合工业应用的稳定性和可靠性要求。
3. 易用性：Halcon为非深度学习专家提供了易于使用的接口，可以快速上手并部署到生产环境中。
擅长领域： 工业质量检测
高精度测量
适用于非深度学习专家的视觉应用开发
使用建议： 对于工业应用，特别是在质量控制和自动化检测方面，Halcon提供了强大的工具集。
在需要集成多种视觉处理技术的复杂应用中，Halcon能够提供全面的解决方案。
对于不熟悉深度学习的工程师，Halcon提供了一个较为简单的入门路径。
综合评价及建议 在选择适合的深度学习框架时，我们需要根据项目需求、资源限制和开发周期来做出决策。YOLOv5和YOLOv7（或未来的YOLOv8）在实时目标检测领域有着无可争议的优势，特别是在需要快速推理和资源有限的场景中。而Halcon作为一个成熟的工业级机器视觉软件，其深度学习框架在工业应用中表现优异，特别是在不需要深度学习背景的工程师可以快速部署和利用的场景中。
在实际应用中，我们可以根据以下原则来选择合适的框架：
1.如果项目对速度要求极高，并且资源有限，YOLOv5可能是最佳选择。
2.如果项目需要最新的目标检测技术，并且对准确度要求很高，可以考虑使用YOLOv7或未来的YOLOv8。
3.如果项目是工业级的，并且需要集成多种机器视觉技术，Halcon可能是更好的选择。
总之，每个框架都有其独特的优势和适用场景。作为工程师，我们应当根据实际需求和条件，选择最适合的工具来完成任务。同时，不断跟进技术进步和社区动态也是保持竞争力的关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd33c4cb29e4163a07f82f9dae0dd3b/" rel="bookmark">
			中国专利公布公告 网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国专利公布公告
http://epub.cnipa.gov.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df320e2c412eb7f1af5a4515a3a15735/" rel="bookmark">
			引导过程的解析以及如何利用systemd去管理nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bios加电自检------mbr--------grub-------加载内核文件------启动第一个进程
bios的主要作用：检测硬件是否正常，然后根据bios中的启动项设置，去找内核文件
boot开机启动项顺序，你可以把内核文件放在何处？
1.硬盘 2.移动设备（u盘、移动硬盘、光驱）3.网络启动
统一启动加载器(mbr grub)
mbr的前446个字节不是文件，而是二进制，去引导操作系统寻找内核文件，因为grub程序太大，第一扇区存不下所有的grub程序，所以分为2部分，知道硬件找到内核文件
grub 根据grub配置文件中记录的位置，去找到内核文件
加载内核：把内核运行在内存中
启动进程：启动第一个祖宗进程 pstree-p =====&gt;systemd
centos 6 ：init 普通用户为500以后
centos7：systemd 普通用户为1000以后
区别：init是串行启动后续的程序，一个一个按顺序启动
systemd 是并行启动的程序，全部一起启动
文字描述：加电后bios程序会自检硬件，硬件无故障后，会根据第一启动项去找内核，一般来说第一启动项是硬盘，找到硬盘后悔根据mbr的指引，找到完整的grub程序，再根据grub的配置文件找到内核文件的具体位置，然后将内核文件加载到内存中运行，内存加载好后会启动第一个程序。
按shit+ 移到boot里的顺序 systemd 是系统级的程序，代为管理系统上的服务程序，如果要用 就要手写
rpcbind 1.启动时，会监听111端口
2.没有启动
systemd 保姆级程序 代为管理服务程序
如是yum、rpm安装的软件可以直接使用systemctl去启动关闭、重启、开机自启等功能
如是编译安装，不可以使用systemctl命令去管理程序，需要手写配置文件
systemd unit（单元）systemd方便管理程序，将程序按照特定的功能，分成了很多单元，（服务单元、文件路径单元、挂载单元、、、、）
linux操作系统有运行级别
例如：init 0 关机 systemctl get -default 查看默认的运行级别
systemctl set-default 设置默认级别
去字符界面
runlevel 3 5 =====》 3是上一级别，5是当前级别 实验操作：
1.模拟破坏mbr 和分区表 然后修复
新建一块磁盘 将备份文件拷贝到新盘里
3 2 1 修复grub文件及程序
先模拟破坏grub.cfg配置文件
按住重新启动 并且立即按住esc 选择2 hard brive
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df320e2c412eb7f1af5a4515a3a15735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9563155b07eba55b605b60358aedf01c/" rel="bookmark">
			ByteTrack算法流程的简单示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ByteTrack ByteTrack算法是将t帧检测出来的检测框集合 D t {\mathcal{D}_{t}} Dt​ 和t-1帧预测轨迹集合 T ~ t − 1 {\tilde{T}_{t-1}} T~t−1​ 进行匹配关联得到t帧的轨迹集合 T t {T_{t}} Tt​。
首先使用检测器检测t帧的图像得到检测框集合 D t {\mathcal{D}_{t}} Dt​，再根据置信度阈值将检测框集合划分为高置信度检测框集合 D t h {\mathcal{D}^{h}_{t}} Dth​ 和低置信度检测框集合 D t l {\mathcal{D}^{l}_{t}} Dtl​。
然后ByteTrack使用卡尔曼滤波，根据t-1帧的轨迹集合 T t − 1 {T_{t-1}} Tt−1​ 预测轨迹在t帧的位置；得到t帧的预测轨迹集合 T ~ t − 1 {\tilde{T}_{t-1}} T~t−1​。
在ByteTrack第一阶段，先将高置信度检测框和预测轨迹相匹配；匹配结果有三种情况：
高置信度检测框和预测轨迹匹配成功，则更新到t帧的轨迹集合中。高置信度检测框没能和预测轨迹匹配，也更新到t帧的轨迹集合中。预测轨迹没有高置信度检测框与它匹配，则放入到未匹配的预测轨迹 T ~ t − 1 u \tilde{T}^{u}_{t-1} T~t−1u​。 在ByteTrack第二阶段，先将未匹配的预测轨迹集合 T ~ t − 1 u \tilde{T}^{u}_{t-1} T~t−1u​划分为活跃轨迹 T ~ t − 1 u , a \tilde{T}^{u,a}_{t-1} T~t−1u,a​和非活跃轨迹 T ~ t − 1 u , i \tilde{T}^{u,i}_{t-1} T~t−1u,i​；非活跃的预测轨迹直接放入到t帧的轨迹集合中，活跃的预测轨迹用于和低置信度检测框进行匹配关联。同样，匹配结果有三种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9563155b07eba55b605b60358aedf01c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a98b39eda74eb844bbc1114590c9f86/" rel="bookmark">
			分布式（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
31.基于Zookeeper如何实现分布式锁？
32.什么是ACID？
33.什么是分布式的XA协议？
34.什么是2PC？
35.什么是3PC？
31.基于Zookeeper如何实现分布式锁？ 顺序节点
创建一个用于发号的节点“/test/lock",然后以他为父亲节点的前缀为”/test/lock/seq"依次发号：
获得最小号得锁
由于序号的递增性，可以规定排号最小的那个获得锁。所以，每个线程在尝试占用锁之前，首先判断自己是排号是不是当前最小，如果是，则获取锁。
节点监听机制
每个线程抢占锁之前，先抢号创建自己的ZNode。同样，释放锁的时候，就需要删除抢号的Znode。抢号成功后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知呢？不需要其他人，只需要等前一个Znode的通知就可以了。当前一个znode删除的时候，就是轮到了自己占用锁的时候。第一个通知第二个，第二个通知第三个，击鼓传花似的依次向后。
32.什么是ACID？ 一个事务有四个基本特性，也就是我们常说的（ACID）：
Atomicty(原子性）：事务是一个不可分割的整体，事务内所有的操作要么全做成功，要么全失败。
Consistency(一致性）：事务执行前后，数据从一个状态到另一个状态必须是一致的（A向B转账，不能出现A扣了钱，B却没收到）。
Isolation(隔离性）：多个并发事务之间相互隔离，不能互相干扰。
Durability（持久性）：事务完成后，对数据库的更改是永久保存的，不能回滚。
33.什么是分布式的XA协议？ XA协议是一个基于数据库的分布式事务协议，其分为两部分：事务管理器和本地资源管理器。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。二阶段提交协议（2PC）和三阶段协议（3PC）就是根据此协议衍生出来而来。主流的诸如Oracle，MySQL等数据库均已实现了XA接口。
XA接口是双向的系统接口，在事务管理器以及一个或者多个资源管理器之间此女工程通信桥梁。也就是说，在基于XA的一个事务中，我们可以针对多个资源进行事务管理，例如一个系统访问多个数据库，或即访问数据库，又访问像消息中间件直接实现全部提交，或全部取消的事务。XA规范不是Java规范，而是一种通用的规范。
34.什么是2PC？ 两段提交顾名思义就是要进行两个阶段的提交：
第一阶段，准备阶段（投票阶段）；
第二阶段，提交阶段（执行阶段）。
下面还那下单扣库存举例子，简单描述一下两段提交（2PC）的原理：
之前说过业务服务化（SOA）以后，一个下单流程就会用到多个服务，各个服务都无法保证调用的其他服务的成功与否，这个时候就需要一个全局的角色（协调者）对各个服务（参与者）进行协调。
一个下单请求过来通过协调者，给每一个参与者发送Prepare消息，执行本地数据脚本但不提交事务。
如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中被占用的资源，显然2PC做到了所有操作要么全部成功，要么全部失败。
两段提交（2PC）的缺点：
二阶段提交看似能够提供原子性的操作，但他存在着严重的缺陷：
网络都懂导致的数据不一致：第二阶段中协调者向参与者发送Commit命令之后，一旦此时发生网络抖动，导致一部分参与者接收到了Commit请求并执行，可其他未接到Commit请求的参与者无法执行事务提交。进而导致整个分布式系统出现了数据不一致。
超时导致的同步阻塞问题：
2PC中的所有的参与者节点都为事务阻塞型，当某一个参与者节点出现通信超时，其余参与者都会被动阻塞占用资源不能释放。
单点故障的风险：
由于严重的依赖协调者，一旦协调者发生故障，而此时参与者还都处于锁定资源的状态，无法完成事务commit操作。虽然协调者出现故障后，会重新选举一个协调者，可无法解决因前一个协调者宕机导致的参与者处于阻塞状态的问题。
35.什么是3PC？ 三阶段提交（3PC）是对两段提交(2PC)的一种升级优化，3PC在2PC的第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的Commit请求后，会对本地事务进行Commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从根本上解决数据一致性的问题。
3PC的三个阶段分别是CanCommit,PreCommit,DoCommit:
CanCommit:协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。
PreCommit:协调者向所有参与者发送PreCommit命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回YES响应，进入最终Commit阶段。一旦参与者中有向协调者发送了NO相应，协调者向所有参与者发送abort请求，参与者接收abort命令执行事务的中断。
DoCommit:在前两个阶段中所有参与者的响应反馈均是YES后，协调者向参与者发送DoCommit命令正是提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送abort请求命令，执行事务的中断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb34186c92725e8b5099becf5e09f61/" rel="bookmark">
			LeetCode刷题---矩阵置零
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解题思路：
本题要求原地置换元素
对矩阵进行第一轮遍历，使用第一行第一列来充当该行该列是否要置换为0的标记位，如果第一行或第一列本身就含有零元素，我们使用colZero和rowZero变量来对其标记。如果第i行第j列的那个元素为0，我们就将[i][0]和[0][j]的元素置换为0，接着判断i和j是否为0，即第一行第一列，如果是，则colZero和rowZero都赋值为true。
对矩阵进行第二轮遍历：即对不包含第一行或第一列进行处理，根据第一轮遍历得到的标记将对应的行和列中的元素置换为0。
对矩阵进行第三轮遍历：即对第一行和第一列本身就含有0元素的情况进行处理，如果第一行或者第一列本身就包含0元素，则将其对应的行或列元素都置换为0。
代码实现：
public void setZeroes(int[][] matrix) { int m=matrix.length; int n=matrix[0].length; boolean colZero=false;//第一行是否有0 boolean rowZero=false;//第一列是否有0 for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(matrix[i][j]==0) { matrix[0][j]=matrix[i][0]=0;//标记位 //判断是否第一行第一列为0 if(i==0) rowZero=true; if(j==0) colZero=true; } } } //第二轮遍历，将标记的行和列置换为0 for(int i=1;i&lt;m;i++) { for(int j=1;j&lt;n;j++) { if(matrix[i][0]==0 || matrix[0][j]==0) { matrix[i][j]=0; } } } //如果第一行或第一列本来就有0，则进行0置换 for(int i=0; colZero &amp;&amp; i&lt;m;i++) matrix[i][0]=0; for(int j=0; rowZero &amp;&amp; j&lt;n;j++) matrix[0][j]=0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1d7c1e64c4189f9bc865762cb3889e/" rel="bookmark">
			开源编辑器Swagger Editor本地部署并实现远程协作编写管理API文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Swagger Editor本地接口文档公网远程访问
1. 部署Swagger Editor
2. Linux安装Cpolar
3. 配置Swagger Editor公网地址
4. 远程访问Swagger Editor
5. 固定Swagger Editor公网地址
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。 点击跳转到网站
Swagger Editor本地接口文档公网远程访问 Swagger Editor是一个用于编写OpenAPI规范的开源编辑器。它提供了一个可视化的界面，使得用户可以更加方便地编写和管理API文档。
Swagger Editor远程访问的好处是您可以随时随地访问和编辑您的Swagger API文档，而不需要在本地安装Swagger编辑器。此外，还可以轻松地与团队成员共享和协作编辑Swagger API文档，以确保文档的实时更新和一致性。
下面介绍使用Docker安装部署Swagger Editor并且结合Cpolar内网穿透工具实现远程访问，当然，这里是方便演示，所以在docker安装，有些在项目中已经集成了，也是一样的设置远程方式的方法。
1. 部署Swagger Editor Docker 简单几步即可运行，简化了繁琐的安装步骤，首先拉取Swagger Editor 容器
docker pull swaggerapi/swagger-editor 运行容器，其中把容器的8080端口映射到宿主机的8088，这个端口可以自定义
docker run -p 8088:8080 -d swaggerapi/swagger-editor 运行后，在本地浏览器访问Linux 8088端口，即可看到Swagger Editor 界面，本地部署就成功了，下面我们安装cpolar内网穿透工具，实现远程访问!
2. Linux安装Cpolar 上面在本地Docker中成功部署了Swagger Editor，并局域网访问成功，下面我们在Linux安装cpolar内网穿透工具，通过cpolar 转发本地端口映射的http公网地址，我们可以很容易实现远程访问，而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar cpolar安装成功后，在外部浏览器上访问Linux 的9200端口 即:【http://局域网ip:9200】，使用cpolar账号登录(如没有账号，可以点击下面免费注册)，登录后即可看到cpolar web 配置界面，结下来在web 管理界面配置即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1d7c1e64c4189f9bc865762cb3889e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdfae89c5d018a1d85cccd256ccbb33/" rel="bookmark">
			MybatisPlus—快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.使用MybatisPlus的基本步骤
1.1引入MybatisPlus的起步依赖
1.2 定义Mapper
2.MybatisPlus常用注解 2.1 @TableName
2.2 @TableId
2.3 @TableField
2.4 小结 3. 常用配置
4. 总结
1.使用MybatisPlus的基本步骤 1.1引入MybatisPlus的起步依赖 MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter替换Mybatis的starter。(如果不替换，同时添加两个依赖会报错)
MybatisPlus的starter：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt; &lt;/dependency&gt; 1.2 定义Mapper 将自定义的Mapper继承MybatisPlus提供的BaseMapper接口:
//在&lt;&gt;中填入需要进行CRUD的实体类型 public interface UserMapper extends BaseMapper&lt;User&gt; { } 通过继承接口，可以使用 BaseMapper 中大量现有的方法，而不需要我们自己编写，方便快捷。
2.MybatisPlus常用注解 思考1：MybatisPlus是怎么通过传入的实体类类型，自动找到数据库对应的表，并且对其进行CRUD的操作呢？
答1：MybatisPlus会通过MP约定，寻找数据库中对应的表。
约定1.类名驼峰转下划线作为表名
约定2.名为id的字段作为主键
约定3.变量名驼峰转下划线作为表的字段名
思考2：如果自己使用的表名或属性名不符合MP约定，应该怎么做才能让MybatisPlus识别到？
答2：使用注解
注意：一定要让MybatisPlus知道哪个属性代表id字段，否则无法进行CRUD，会导致报错；
2.1 @TableName 作用：用来指定表名
2.2 @TableId 作用：用来指定表中的关键字段(id)信息
可以通过设置type的值来选择合适的id策略：
idType.AUTO：数据库自增加；
idType.INPUT：通过set方法自行输入；
idType.ASSIGN _ID(默认选择)：自动分配 ID，接口ldentifierGenerator的方法nextld来生成id默认实现类为DefaultldentifierGenerator雪花算法。
2.3 @TableField 作用：用来指定表中的普通字段信息
常用场景：
1.成员变量名与数据库字段名不一致
2.成员变量名以is开头，且是布尔值
3.成员变量名与数据库关键字冲突
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bdfae89c5d018a1d85cccd256ccbb33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e752ca934c876a6545feb8a8a1620c/" rel="bookmark">
			Python编程基础：Python简介及开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种跨平台的计算机程序设计语言，将用户的想法传达给Python，它再以计算机所认识的方式告诉计算机，它充当着用户与计算机之间交流的工具；它是一种解释型语言，在开发的过程中没有编译这个环节，在这一点上它与Java不一样；它是一种面向对象的语言，在它的世界里一切皆对象。
一、Python开发环境搭建 1.1 Python解释器1.2 程序解读 IDLEPython 3.8(64-bit)Python 3.8 Manuals(64-bit)Python 3.8 Module Docs(64-bit) 二、第一个Python程序 2.1 通过IDLE2.2 通过Python交互式开发环境 三、第三方开发环境 3.1 下载安装步骤3.2 汉化 一、Python开发环境搭建 1.1 Python解释器 Python官网点此访问
Python解释器下载点此访问
通过上方链接可以访问官网以及解释器下载页面，进入后将页面拉至底部，选择自己电脑的版本进行下载；基于windows64位系统进行开发的小伙伴选择可执行的安装文件下载即可。
下载好后安装运行，先勾选下方的两个复选框，然后点击上方的Install Now
等待进度条加载完成
界面显示 SetUp was successful即安装成功
通过搜索界面查看
组合键win+r，输入python，检查是否安装成功并查看其版本，如下图所示即可
1.2 程序解读 安装后的程序目录如下
IDLE IDLE是python自带的开发环境，在这里可以输入简单的代码
Python 3.8(64-bit) python 3.8(64-bit)是交互式命令行程序，同样亦可在此输入代码运行
Python 3.8 Manuals(64-bit) Manuals上面带着问号，看着就很眼熟了，这是他的技术文档，也就是API，后续再使用时再详细介绍这些接口
Python 3.8 Module Docs(64-bit) Module Docs是已安装的模块的文档，运行之后会自行打开浏览器。
二、第一个Python程序 python是一种交互式语言，可以在它的提示符【&gt;&gt;&gt;】后直接执行代码
2.1 通过IDLE 在尖括号后输入代码回车即可
print('Hello World') 2.2 通过Python交互式开发环境 使用交互式开发环境输出亦是同理
三、第三方开发环境 简单的代码使用自带的环境没有问题，但这样下去终究也不是持久之计，通常的时候开发者们会使用第三方的开发环境：
PyCharm
下载地址点此访问
3.1 下载安装步骤 访问网址后可以看到界面如下，Professional是专业版，它有一个试用期，试用期过后需要付费使用；Community是社区版免费使用的，这里可以根据个人喜好选择下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e752ca934c876a6545feb8a8a1620c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0aaff66ba4b9b6c9431d9ca401aedec/" rel="bookmark">
			电脑提示找不到vcruntime140.dll,无法继续执行代码的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你的电脑是否出现过找不到vcruntime140.dll,无法继续执行代码的问题，遇到这种情况你是怎么解决的，你了解过vcruntime140.dll文件吗，今天给大家介绍几种关于电脑缺少vcruntime140.dll文件快速解决的办法。
一. 什么是vcruntime140.dll文件 vcruntime140.dll文件是VC++2015库非常重要的系统文件，少了它很多游戏，软件都无法正常运行。它是Microsoft Visual C++ Redistributable的一部分，是一种动态链接库（DLL）文件。它提供了一些用于C和C++语言开发的函数，而这些语言是很多Windows程序和游戏的基础。vcruntime140.dll文件包含了一些常用的运行时函数和变量，这些函数和变量是在程序运行时所需的。
二. vcruntime140.dll文件缺失的解决办法 方法一：重新安装软件 如果vcruntime140.dll文件缺失的提示是在安装某一软件后出现的提示，可以尝试将这个软件进行卸载，将软件卸载后重新安装。这种情况通常是因为软件在安装的过程中某些文件被迫坏，导致安装失败，或者是软件在下载的过程中就是缺少这个文件的，这就需要大家在官方网站上下载软件，官方网站上的软件通常是不会出现错误的。或者找到靠谱的站点下载，不要下载到乱七八糟的东西，容易使电脑中病毒。
方法二：使用dll修复工具 这种办法是小编自己在用的方法，这是一个很好解决关于dll文件的工具，操作简单方便。基本上关于dll缺失的问题它都可以解决。具体如下：
1.在浏览器顶部找：dll修复.site 切记要在顶部才能正确的进入站点，否则无效或者找不到。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
2.进入页面后，找到立即下载，将工具进行下载安装，
3.安装后将工具打开，打开后利用这个dll修复工具直接进行一键修复就可以了，它会根据你电脑系统缺失了哪些dll文件，然后进行相关的修复，也可以选择手动修复，选择你需要修复的文件。
方法三：重新安装Visual C++ Redistributable Package vcruntime140.dl属于Microsoft Visual C++软件包里的一部分，因此，重新安装软件包也可能会解决vcruntime140.dll缺失的问题。具体操作步骤如下：
1. 打开浏览器在浏览器上俞入：Visual C++ Redistributable Package找到官方网站，
2. 下载最新版本的Microsoft Visual C++ 包。双击下载的安装程序，按照提示进行安装。
3. 安装完成后，将电脑重新启动，在尝试运行应用程序或游戏，查看是否已经解决了vcruntime140.dll错误。
三. vcruntime140.dll文件功能 1. vcruntime140.dll文件包含了许多C++运行时库，这些库提供了许多常用的函数和类，可以帮助程序员更方便地编写和调试软件和游戏。
2. vcruntime140.dll文件提供了C++异常处理机制，程序员可以更加方便地处理应用程序和游戏中的异常情况。异常处理机制可以帮助程序员更好地保护软件和游戏的稳定性和安全性。
3. vcruntime140.dll文件提供了C++内存管理功能，这些功能可以帮助程序员更好地管理软件和游戏的内存使用，避免内存泄漏和内存溢出等问题。
以上就是关于找不到vcruntime140.dll，无法继续执行代码的问题，希望能够有效的帮助大家解决vcruntime140.dll丢失的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cde671559679ffbf5ca5997cd8c376a/" rel="bookmark">
			力扣232. 用栈实现队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false 题解 根据栈后进先出的性质，可将两个栈分别设置为只压入元素的栈和只弹出元素的栈，以此来满足队列先进先出的性质。
代码如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;errno.h&gt; #include &lt;stdbool.h&gt; typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; void STInit(ST* pst); void STDestroy(ST* pst); void STPush(ST* pst, STDataType x); void STPop(ST* pst); STDataType STTop(ST* pst); bool STEmpty(ST* pst); int STSize(ST* pst); void STInit(ST* pst) { assert(pst); pst-&gt;a = NULL; pst-&gt;top = 0; //指向栈顶元素的下一个位置 pst-&gt;capacity = 0; } void STDestroy(ST* pst) { assert(pst); free(pst-&gt;a); pst-&gt;a = NULL; pst-&gt;top = 0; pst-&gt;capacity = 0; } void STPush(ST* pst, STDataType x) { if (pst-&gt;top == pst-&gt;capacity) { int newcapacity = pst-&gt;capacity == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cde671559679ffbf5ca5997cd8c376a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6c7a073cf92b21cce810d1799c29a8/" rel="bookmark">
			编程笔记 html5&amp;css&amp;js 021 JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程笔记 html5&amp;css&amp;js 021 JavaScript 一、HTML &lt;script&gt; 标签二、HTML`&lt;noscript&gt;` 标签小结 网页的以一重要的角色JavaScript开始登场。它能使 HTML 页面更具动态性和交互性。
一、HTML HTML &lt;script&gt; 标签用于定义客户端脚本（JavaScript）。
&lt;script&gt; 元素即可包含脚本语句，也可通过 src 属性指向外部脚本文件。
JavaScript 的常见用途是图像处理、表单验证和内容的动态更改。
如需选取 HTML 元素，JavaScript 最常用 document.getElementById() 方法。
这个 JavaScript 示例向 id="demo" 的 HTML 元素内写入 "Hello JavaScript!"：
&lt;script&gt; document.getElementById("demo").innerHTML = "Hello JavaScript!"; &lt;/script&gt; JavaScript 能够更改样式：
document.getElementById("demo").style.fontSize = "25px"; document.getElementById("demo").style.color = "red"; document.getElementById("demo").style.backgroundColor = "yellow"; JavaScript 能够更改属性：
document.getElementById("image").src = "picture.gif"; 二、HTML&lt;noscript&gt; 标签 HTML &lt;noscript&gt; 标签定义了替代内容，这些内容将显示给在浏览器中禁用了脚本或浏览器不支持脚本的用户：
&lt;script&gt; document.getElementById("demo").innerHTML = "Hello JavaScript!"; &lt;/script&gt; &lt;noscript&gt;抱歉，您的浏览器不支持 JavaScript！&lt;/noscript&gt; 小结 这里先认识一下哈！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68089b012d911192a13b399fc4e050e/" rel="bookmark">
			FreeRTOS——队列及其实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.队列概念 1）队列是任务到任务、任务到中断、中断到任务数据交流的一种机制（消息传递）
2）队列类似数组，只能存储有限数量、相同类型的数据，在创建时需指定队列长度与队列项大小
3）出队入队阻塞：
若阻塞时间为0 ：直接返回不会等待；
若阻塞时间为0~port_MAX_DELAY ：等待设定的阻塞时间，若在该时间内还无法入队，超时后直接返回不再等待；
若阻塞时间为port_MAX_DELAY ：死等，一直等到可以入队为止。出队阻塞与入队阻塞类似；
4）数据传递方式：FreeRTOS中队列采用实际值传递，即将数据拷贝到队列中进行传递， FreeRTOS采用拷贝数据传递，也可以传递指针，所以在传递较大的数据的时候采用指针传递
2.队列结构体 typedef struct QueueDefinition
{
int8_t * pcHead /* 存储区域的起始地址 /
int8_t * pcWriteTo; / 下一个写入的位置 /
union
{
QueuePointers_t xQueue;
SemaphoreData_t xSemaphore;
} u ;
List_t xTasksWaitingToSend; / 等待发送列表 /
List_t xTasksWaitingToReceive; / 等待接收列表 /
volatile UBaseType_t uxMessagesWaiting; / 非空闲队列项目的数量 /
UBaseType_t uxLength； / 队列长度 /
UBaseType_t uxItemSize; / 队列项目的大小 /
volatile int8_t cRxLock; / 读取上锁计数器 /
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68089b012d911192a13b399fc4e050e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec78584dd88e46293df15a2dca824dc/" rel="bookmark">
			【Matlab】LSTM长短期记忆神经网络时序预测算法（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源下载： https://download.csdn.net/download/vvoennvv/88688439
目录 【Matlab】BP 神经网络时序预测算法
【Matlab】CNN卷积神经网络时序预测算法
【Matlab】ELM极限学习机时序预测算法
【Matlab】基于遗传算法优化BP神经网络 (GA-BP)的数据时序预测
【Matlab】LSTM长短期记忆神经网络时序预测算法
【Matlab】PSO-BP 基于粒子群算法优化BP神经网络的数据时序预测
【Matlab】RBF径向基神经网络时序预测算法
【Matlab】RF随机森林时序预测算法
【Matlab】SVM支持向量机时序预测算法
一，概述 LSTM（Long Short-Term Memory）是一种常用的循环神经网络（Recurrent Neural Network，RNN）结构，由于其对于长序列数据的处理能力，被广泛应用于语音识别、自然语言处理、图像处理等领域。 LSTM 网络的主要特点是增加了一个称为“记忆单元（Memory Cell）”的结构，用于控制网络的信息流动。这个结构可以记忆信息并在需要的时候将其加入到当前的处理中，从而更好地处理长序列数据。另外，LSTM 网络还引入了三个称为“门（Gates）”的结构，包括输入门（Input Gate）、遗忘门（Forget Gate）和输出门（Output Gate），用于控制信息的输入、遗忘和输出。这些门的作用是通过一个 sigmoid 函数将输入信息映射到 0~1 之间的值，然后与记忆单元中的信息进行运算，控制信息的流动。通过这种方式，LSTM 网络可以有效的捕捉序列中的长期依赖关系，从而提高了神经网络处理序列数据的能力。
二，代码 代码中文注释非常清晰，按照示例数据修改格式，替换数据集即可运行，数据集为excel。
部分代码示例如下：
%% 清空环境变量 warning off % 关闭报警信息 close all % 关闭开启的图窗 clear % 清空变量 clc % 清空命令行 %% 导入数据（时间序列的单列数据） result = xlsread('数据集.xlsx'); %% 数据分析 num_samples = length(result); % 样本个数 kim = 15; % 延时步长（kim个历史数据作为自变量） zim = 1; % 跨zim个时间点进行预测 %% 划分数据集 for i = 1: num_samples - kim - zim + 1 res(i, :) = [reshape(result(i: i + kim - 1), 1, kim), result(i + kim + zim - 1)]; end %% 数据集分析 outdim = 1; % 最后一列为输出 num_size = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fec78584dd88e46293df15a2dca824dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81cdeda5effb15395e9993daad128e17/" rel="bookmark">
			【Linux驱动】Linux中断（一）—— 设备树中断节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		裸机使用中断需要通过寄存器手动配置，但有了 Linux 系统后，Linux内核提供了完善的中断框架，我们只需要申请中断，然后注册中断服务函数即可。
一、设备树中断属性 既然驱动中要注册中断服务函数，我们首先需要知道三个点:
中断类型: GIC 目前存在的中断请求有128种，每一种对应一个中断控制器中断引脚: 指定具体是哪一个引脚会触发触发方式: 上升沿触发、下降沿触发、高电平触发、低电平触发 设备树中涉及到中断的属性主要有四个
1、指定中断类型 在设备树中每一种中断请求表现为一个节点，且包含属性 interrupt-controller。涉及到的属性还有 #interrupt-cells，指定引用节点中 interrupts 属性中包含的信息个数（注意不是当前节点的interrupts属性）
当某个外设节点要引入中断时，需要通过 interrupt-parent 属性描述自己属于哪一种类型的中断，比如下面的 sii902x 节点的中断类型属于 gpio1。gpio1节点的 interrupts 属性已经包含了中断号等内容，后续与 gpio1 相关的子节点直接引用即可。 2、指定中断引脚、触发方式 中断的触发需要借助引脚的高低电平实现，所以当某个外设节点引入中断后，需要指定是哪个引脚会触发中断，使用的设备树属性为 interrupts，该属性包含两个信息（中断引脚、触发方式）
格式如下:
interrupts = &lt;引脚编号 触发方式&gt;, ··· &lt;引脚编号 触发方式&gt;; 引脚编号：引脚编号可以直接使用数字，如果是 gpio1_IO10，这里可以填 10
触发方式：Linux内核提供了宏定义来表示触发方式（irq.h）
#define IRQ_TYPE_NONE	0 /* 无触发 */ #define IRQ_TYPE_EDGE_RISING	1 /* 上升沿触发 */ #define IRQ_TYPE_EDGE_FALLING	2 /* 下降沿触发 */ #define IRQ_TYPE_EDGE_BOTH	(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING) /* 双边沿触发 */ #define IRQ_TYPE_LEVEL_HIGH	4 /* 高电平触发 */ #define IRQ_TYPE_LEVEL_LOW	8 /* 低电平触发 */ 二、设备树中断节点 为便于触发中断，这里以按键 key0 为例，key0 使用的引脚为 GPIO1_IO18，引脚编号为 18，触发类型为下降沿触发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81cdeda5effb15395e9993daad128e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626c18cad0c48b7cdd9814f1d0408d23/" rel="bookmark">
			如何打开wps的备份中心查找备份文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备份中心在我们使用WPS Office时扮演着重要的角色。经常保存文件的同时，我们也应该学会备份文件，以免意外损失。本文将向您介绍如何使用WPS备份中心来查找并恢复备份文件，方便您在需要时快速找到所需文件。
图片来源于网络，如有侵权请告知
如何打开wps的备份中心查找备份文件 要打开WPS的备份中心查找备份文件，您可以按照以下步骤进行操作：
1、首先，任意打开一文档或者表格，在菜单栏中，点击"文件"选项。
2、在下拉菜单中，找到“备份与恢复”选项，在右侧菜单中即可找到”备份中心“点击它。
或者点击“选项”，在弹出的窗口中，找到在左下角的“备份中心”并点击它即可打开。
3、在备份中心界面中，您可以看到已备份的文件列表。您可以根据文件名、备份时间或文件类型等条件，对备份文件进行搜索和筛选。
5、找到您要恢复的备份文件后，点击文件名旁边的“打开”按钮或者双击打开，然后将备份文件保存到指定的位置即可。
温馨提示： 请注意，如果您没有进行文件备份，或者备份中心中没有对应的备份文件，那么您将无法在备份中心中找到备份文件。建议启用WPS的备份功能，登录相关账号后，WPS软件提供了三种本地自动备份设置选择，分别是智能备份、定时备份、增量备份，您还可以指定本地备份存放位置。
WPS软件三种本地自动备份设置详细介绍：
智能备份：根据文档备份所需时长智能调整备份频率，所需时长较短时备份频率更高。
定时备份：文档修改后，到达设置的时间间隔时自动生成备份。时间间隔可以自主设置。
增量备份：对文档的变化进行实时备份，备份速度快且可以节约存储空间，此方案需要重启WPS后生效。
同时，它还支持云端备份，用户可以将文档、表格和演示文稿等文件保存到WPS云文档中，以备份和随时访问。通过登录WPS账号，用户可以在不同设备上同步和共享文件。
您可以根据自身需求和使用习惯，选择适合自己的备份方式。通过合理设置备份选项，我们可以更好地保护和管理我们的文件，确保工作的安全和顺利进行。
扩展阅读：WPS文件丢失如何恢复 如果您养成了备份的习惯，那么能够有效预防文件丢失的发生。但如果不幸遇到WPS文件丢失的情况且没有进行备份，WPS文件丢失如何恢复？您还有一些方法来尝试恢复失去的文件。
方法1：在WPS软件最近中恢复文件 一般而言，我们在WPS软件中编辑的文件都会被自动记录下来。用户可以在软件的【最近】选项中查找之前编辑过的文件，如果有需要恢复的文件，直接进入文件中。
方法2：利用电脑的回收站恢复文件 如果你使用了上述方法仍然无法找回WPS文件，可能是文件被错误地删除并且被放入回收站中。那么，WPS文件不小心删除怎么恢复？你可以尝试利用电脑的回收站来恢复文件。
双击打开回收站，搜索并找到丢失的WPS文件，然后右键点击文件，并选择“还原”来将文件恢复到原来的位置。
方法2：利用专业软件恢复WPS文件 如果WPS文件丢失回收站找不到了怎么办？在未备份文件的情况下，使用专业的数据恢复软件或许是一个有效的解决方案，软件能够扫描电脑硬盘上的已删除或丢失文件并尝试恢复。 需要注意的是，当文件被删除后，最好不要再往存储设备上写入新的数据，以免覆盖掉原来的文件内容，从而降低恢复成功的机会。及时采取行动，以增加恢复丢失文件的可能性。
对于“WPS文件丢失可以找回吗”的问题，可以选用支持免费扫描和预览的云骑士数据恢复软件进行预判，只要能扫描出来且能预览都是可以恢复。
该软件操作起来简单，无论你对电脑是否熟悉，都可以轻松使用。下面将介绍大致的操作步骤：
步骤1：下载并安装文件恢复软件在未丢失wps文件所在磁盘，打开软件，你会看到一个简洁清晰的操作界面。 步骤2：在界面上选择合适的恢复模式，选择包含被误删除WPS文件的驱动器，点击“开始扫描”按钮开始扫描。 步骤3：扫描完成后，根据WPS文件的特征进行筛选查找，然后预览文件内容并确认是否是你需要恢复的文件。 步骤4：选中要恢复的文件，点击“立即恢复”按钮，选择恢复到指定位置（记得是一个不同于原位置的位置，以防覆盖原有文件）。
总结： 通过使用WPS备份中心，我们可以方便地查找并恢复备份文件，保护我们的工作不受损失。无论是意外删除还是其他原因丢失，备份中心都将成为我们重要的数据保护工具。在日常使用中，我们应该充分利用备份中心功能，并定期检查备份文件，以确保数据安全和完整性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c9d9aeb86bbfbc185e28c85b47a001/" rel="bookmark">
			Apache DolphinScheduler 社区 2023 年度工作报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着 2023 年的日历逐渐翻至最后一页，我们欣喜地回顾 Apache DolphinScheduler 社区在这一年中所取得的成就和进步。这一年，我们不仅在社区规模和技术发展上取得了显著成就，还发布了大量的技术文章和博客，进一步丰富了我们的知识库。
展望未来 🔮 展望 2024 年，我们将继续丰富我们的技术文章和Github库，以及加强社区成员间的交流和协作。我们期待与所有社区成员一起，实现这些目标。
感谢致辞 🙏 感谢每一位社区成员在过去一年中的贡献和努力。正是有了你们，Apache DolphinScheduler 社区才能取得今天的成绩。让我们携手并进，共创一个更加繁荣的开源未来！
我们期待与大家在新的一年中再创佳绩！
Apache DolphinScheduler 社区团队
本文由 白鲸开源科技 提供发布支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b9b729c8fe9316d34a5f1396c2fbcd/" rel="bookmark">
			Unity报错：InvalidOperationException: Insecure connection not allowed的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在导入Steam VR 插件后报错：
InvalidOperationException: Insecure connection not allowed
UnityEngine.Networking.UnityWebRequest.SendWebRequest () (at &lt;4139bb31c03640e7b650db6ec39d5754&gt;:0)
UnityEngine.WWW..ctor (System.String url) (at &lt;384e0fe1666848ef9ddc0b495902df33&gt;:0)
Valve.VR.SteamVR_Update.Update () (at Assets/SteamVR/Editor/SteamVR_Update.cs:42)
UnityEditor.EditorApplication.Internal_CallUpdateFunctions () (at &lt;7b4f3dc961684c98b64a8a94a10cd68d&gt;:0)
原因分析 该错误是由于新版本的Unity默认是不允许HTTP请求的
问题解决 点击Edit-&gt;Project Settings…，选中Player，在Other Settings中找到Allow downloads over HTTP*，修改其访问权限为Always allowed即可。
后记 选择Always allowed，会弹出一个警告：
Plain text HTTP connections are not secure and can make your application vulnerable to attacks. （释义：纯文本HTTP连接不安全，可能会使您的应用程序容易受到攻击。）
备注：如果你是用的接口地址使用的都是Https，建议选择第二个，仅仅在开发环境使用http。如果你的接口地址存在Http协议，建议选择Always allowed，否则在发布后，接口可能会不通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243c3aefcea2cb4829d109addcda564c/" rel="bookmark">
			nginx在国产服务器上stream配置项无法识别的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在搭建k8s+ranchar，需要用到nginx做负载均衡，之前在系统中也会用到，之前一直使用http选项，做转发配置。
基本格式如下图所示：
但是在ranchar的安装中默认方式使用stream配置项。
使用yum默认安装的nginx不支持该关键字。
默认使用的版本是1.23.0，后来查了资料，可能是版本太高了，于是降低了版本，发现还是不支持，于是从官网下载源码包。
官网地址：https://nginx.org/en/download.html
使用需要进行配置、编译、安装，在配置过程中添加上对stream选项的支持即可。
# 添加使用--with-stream=dynamic 配置./configure --prefix=/usr/local/nginx/ --with-stream=dynamic# 然后make make# 然后make installmake install 安装之后，nginx就会被安装在/usr/local/nginx/路径下，测试可以进入/usr/local/nginx/conf路径下，使用stream的配置选项了
Nginx 的stream与http对比
问题是解决了，但是为什么要有两个类型的配置项？他们有什么区别呢？
Stream模块用于处理TCP、UDP和TLS协议，可以用来代理和负载均衡各种不同类型的流量。它能够支持代理和负载均衡TCP流量，例如SMTP、MySQL和Redis等。NGINX Stream模块支持按需加载，并提供配置选项来控制代理和负载均衡流量的行为。
HTTP模块则是用于处理HTTP请求和响应的模块。它作为一个反向代理，可以实现HTTP服务器上的负载均衡和缓存功能。HTTP模块还支持SSL/TLS终止、请求转发以及访问控制等功能。NGINX HTTP模块支持HTTP 1.0、HTTP 1.1和HTTP/2协议，并提供许多配置选项来调整HTTP交互的行为。
因此，NGINX Stream和HTTP之间的主要区别在于它们处理的协议和使用的功能不同。Stream模块适用于TCP、UDP和TLS流量的代理和负载均衡，而HTTP模块则专注于处理HTTP请求和响应。
而且我还做了实验，使用http模式来配置，nginx确实能启动，但是却不能在浏览器上打开rancher的页面，换成stream版本的就可以顺利打开~
结束~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f334356e242555b96772ac94b66cbe/" rel="bookmark">
			WSL 与真实 linux 环境区别有多大？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着 Windows 系统的不断发展和完善，WSL（Windows Subsystem for Linux）作为 Windows 10 的一个功能，为 Windows 用户提供了一个可以在 Windows 环境下运行 Linux 二进制可执行文件的环境。然而，尽管 WSL 为用户提供了一个类似 Linux 的环境，但它与真实的 Linux 环境还是存在一些区别的。本文将详细探讨 WSL 与真实 Linux 环境之间的区别。
一、系统内核
首先，WSL 和真实 Linux 环境最根本的区别在于它们的系统内核。WSL 使用的是 Windows 内核，而 Linux 是一个独立的 Unix-like 操作系统，有自己的内核。由于内核的不同，WSL 在执行 Linux 二进制可执行文件时，实际上是通过 Windows 内核进行模拟和转换的。这使得 WSL 在某些方面可能存在性能上的差异。
二、系统组件和功能
设备驱动程序：WSL 主要针对常见的 Linux 系统进行了优化，但在某些特定设备或驱动程序方面可能存在限制。例如，图形驱动程序和网络设备等在 WSL 中可能无法正常工作。系统工具和软件包：WSL 提供了一套基本的 Linux 系统工具和软件包，但与真实的 Linux 环境相比，其软件包管理、系统配置等方面可能存在差异。安全性：WSL 的安全性可能与真实 Linux 环境有所不同。例如，WSL 可能受到 Windows 安全策略、UAC（用户帐户控制）等方面的限制。 三、交互和兼容性
文件系统交互：WSL 支持与 Windows 系统的文件交互，用户可以在 WSL 和 Windows 之间共享文件。但与真实的 Linux 环境相比，某些文件系统的特性可能存在差异。网络交互：WSL 支持与 Windows 网络环境进行交互，例如通过 Windows 的网络共享功能访问网络资源。但在某些特定场景下，如访问 Linux 特有的网络服务或配置时，可能会遇到限制。软件兼容性：由于 WSL 是基于 Windows 的模拟环境，因此一些针对 Linux 平台开发的软件可能无法在 WSL 中正常运行。这通常涉及到对特定系统调用或库的依赖。 四、使用体验和社区支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f334356e242555b96772ac94b66cbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f646caf26980264911555b7366fddc57/" rel="bookmark">
			粒子群优化pso结合bp神经网络优化对csv文件预测matlab(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.csv数据为密西西比数据集，获取数据集可以管我要，数据集内容形式如下图：
2.代码
这里参考的是b站的一位博主。
数据集导入教程在我的另一篇文章bp写过，需要的话可以去看一下
psobp.m
close all clc %读取数据 input=X; output=Y;%10000行1列 %设置训练数据与测试数据 input_train=input(1:8000,:)'; output_train=output(1:8000,:)'; input_test=input(8001:10000,:)'; output_test=output(8001:10000,:)';%2000列1行 %节点个数 inputnum=26;%输入层节点数量 hiddennum=12;%隐藏层节点数量 outputnum=1;%输出层节点数量 w1num=inputnum*hiddennum;%输入层到隐藏层的权值个数 w2num=outputnum*hiddennum;%输出层到隐藏层的权值个数 N=w1num+hiddennum+w2num+outputnum;%待优化的变量个数 %训练数据归一化 [inputn,inputps]=mapminmax(input_train); [outputn,outputps]=mapminmax(output_train); %%定义pso算法参数 E0=0.001;%允许误差 MaxNum=10;%粒子最大迭代次数 narvs=N;%目标函数的子变量个数 particlesize=10;%粒子群规模 c1=2;%个体经验学习因子 c2=2;%社会经验学习因子 w=0.6;%惯性因子 vmax=0.8;%粒子最大飞行速度 x=-5+10*rand(particlesize,narvs);%粒子所在位置，规模是粒子群数和参数需求数设置x的取值范围[-5,5] v=2*rand(particlesize,narvs);%粒子飞行速度，生成每个粒子飞行速度，只有一个变量，所以速度是一维的 trace=zeros(N+1,MaxNum);%寻优结果的初始值 objv=objfun(x,input_train,output_train,input_test,output_test);%计算目标函数值 personalbest_x=x;%用于存储个体最优，存储每个粒子经历的x值 personalbest_faval=objv;%存储个体最优的y，每个个体的误差的群体 [globalbest_faval,i]=min(personalbest_faval); globalbest_x=personalbest_x(i,:);%全局最优的x k=1;%开始迭代 while k&lt;=MaxNum objv=objfun(x,input_train,output_train,input_test,output_test); for i=1:particlesize if objv(i)&lt;personalbest_faval(i) personalbest_faval(i)=objv(i);%将第i个粒子作为个体最优解 personalbest_x(i,:)=x(i,:);%更新最优解位置 end end [globalbest_favalN,i]=min(personalbest_faval); globalbest_xn=personalbest_x(i,:); trace(1:N,k)=globalbest_xn;%每代最优x值 trace(end,k)=globalbest_favalN; %%粒子更新 for i=1:particlesize v(i,:)=w*v(i,:)+c1*rand*(personalbest_x(i,:)-x(i,:))+c2*rand*(globalbest_x-x(i,:)); %rand会随机生成一个（0，1）的随机降低学习因子的比例 for j=1:narvs%确定每个变量的速度，不超过最大速度 if v(i,j)&gt;vmax v(i,j)=vmax; elseif v(i,j)&lt;-vmax v(i,j)=-vmax; end end x(i,:)=x(i,:)+v(i,:); end globalbest_faval=globalbest_favalN; globalbest_x=globalbest_xn; k=k+1; end %%画图 figure(1); plot(1:MaxNum,trace(end,:)); grid on; xlabel('遗传代数'); ylabel('误差变化'); title('进化过程'); objfun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f646caf26980264911555b7366fddc57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f32a4629750e86cbf1c53eab147fb82/" rel="bookmark">
			如何做一个炫酷的Github个人简介（3DContribution）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言3D-Contrib第一步第二步第三步第四步第五步第六步 前言 最近放假了，毕设目前也不太想做，先搞一点小玩意玩玩，让自己的github看起来好看点。也顺便学学这个action是怎么个事。
3D-Contrib 先给大家看一下效果
我的个人主页：https://github.com/MengFanjun020906/MengFanjun020906
原仓库链接：https://github.com/yoshi389111/github-profile-3d-contrib
PS：不要在意我这个少得可怜的contributions
要做这样一个效果，就需要用到github的action，之前一直没用过，今天才知道是干啥用的。
第一步 在你的个人仓库下找到Actions
第二步 点击New workflow
第三步 创建一个新的文件，名为profile-3d.yml
第四步 文件输入这些信息，替换你自己的名字即可
name: GitHub-Profile-3D-Contrib on: schedule: # 03:00 JST == 18:00 UTC - cron: "0 18 * * *" workflow_dispatch: jobs: build: runs-on: ubuntu-latest name: generate-github-profile-3d-contrib steps: - uses: actions/checkout@v3 - uses: yoshi389111/github-profile-3d-contrib@0.7.1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} USERNAME: 你自己的名字 - name: Commit &amp; Push run: | git config user.name github-actions git config user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f32a4629750e86cbf1c53eab147fb82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa119c701708a80cdb50d6d027ae657c/" rel="bookmark">
			前端cdn、ajax、code等加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于众所周知的原因，国外的ajax、js等库的网速较慢，我们可以采取国内的中科大镜像：
fonts.googleapis.com fonts.lug.ustc.edu.cn ajax.googleapis.com ajax.lug.ustc.edu.cn themes.googleusercontent.com google-themes.lug.ustc.edu.cn fonts.gstatic.com fonts-gstatic.lug.ustc.edu.cn 也即是将googleapis.com 改写为lug.ustc.edu.cn 另外发现https://code.jquery.com/jquery-3.7.0.js
也比较慢，将其下载到本地，然后放入static/jquery目录，修改代码（比如templates/base.html文件）：
src="https://code.jquery.com/jquery-3.7.0.js" 修改为： src="/static/jquery/jquery-3.7.0.js" 同样的jquery-2.2.4.min.js文件也做同样处理 参考这篇文章国内外优秀前端 CDN，Google Fonts 国内镜像_字体库 cdn地址-CSDN博客，还有很多镜像可以使用：
CDN要求速度快，项目多，版本更新快，国内BootCDN.cn我觉得是最好的，没有之一，什么新浪，百度，360的都是给内部用的。 最近发现的css.net也不错啊，还反代了Google字体库，够快，很方便。 CDN BootCDN www.bootcdn.cn CSS.NET 同步国外cdnjs.com，速度够快 https://css.net/ https://cdn.css.net/libs/ CDNJS 原 cdnjs.cloudflare.com https://cdnjs.com/ JSDELIVR https://www.jsdelivr.com/ UNPKG 跟npm仓库同步，绝对是最全的，速度不够快 https://unpkg.com/ Google Fonts 源地址 https://fonts.googleapis.com/ 国内镜像 CSS.NET 推荐 https://fonts.css.network/ 中国科学技术大学 主页 https://lug.ustc.edu.cn/wiki/start https://fonts.proxy.ustclug.org 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ebcccf1859c5dd899994409b829472/" rel="bookmark">
			AI边缘计算智能分析网关V4如何配置周界入侵检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旭帆科技的智能分析网关V4内含近40种智能分析算法，包括人体、车辆、消防、环境卫生、异常检测等等，在消防安全、生产安全、行为检测等场景应用十分广泛，如常见的智慧工地、智慧校园、智慧景区、智慧城管等等，还支持抓拍、记录、告警、平台级联等功能。算法稳定，识别高效，感兴趣的用户可以前往演示平台进行体验或部署测试。
智能分析网关V4的功能十分丰富，今天小编就带大家学习一下，如何在V4中配置周界入侵检测算法。
1）首先进入到智能分析网关V4的管理平台；
2）点击【设备管理】—【智能一体机】；
3）选择【一体机设备】找到【算法配置】，点击进入；
4）选择需要周界入侵算法，选择摄像机，此时就会出现预览画面；
5）在右侧可以根据自己的实际需求进行设置周界入侵的上线与下线；
6）保存完毕后即可选择该摄像机，查看正在生效的算法了。
AI智能分析网关V4是TSINGSEE青犀视频旗下的一款高效边缘计算分析网关，可实现人体行为检测、车辆事件检测、环境卫生检测与消防事件检测等等，广泛应用在工地、工厂、园区、楼宇、校园、仓储等场景中。将智能分析网关V4结合我们的视频融合平台EasyCVR一起使用，可以实现多现场的前端摄像头等设备统一集中接入与视频汇聚管理，并能进行视频高清监控、录像、存储、检索与回放、AI智能分析、级联共享等视频能力与智能化服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321cf7da4c62ec0e783ed773f2736d6b/" rel="bookmark">
			【MySQL】窗口函数 Lead 和 Lag 的运用（MySQL版本8&#43;）以及 时间差函数 TIMESTAMPDIFF 的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣题 1、题目地址 1939. 主动请求确认消息的用户
2、模拟表 表：Signups
Column NameTypeuser_idinttime_stampdatetime user_id is the primary key for this table.每行包含有关 ID 为 user_id 的用户的注册时间的信息。 表：Confirmations
Column NameTypeuser_idinttime_stampdatetimeactionENUM (user_id, time_stamp) is the primary key for this table.user_id is a foreign key with a reference to the Signups table.action is an ENUM of the type (‘confirmed’, ‘timeout’)此表的每一行都表示 ID 为 user_id 的用户在 time_stamp 请求了确认消息，并且该确认消息已被确认（‘confirmed’）或已过期（‘timeout’）。 3、要求 编写 SQL 查询以查找在 24 小时窗口内两次请求确认消息的用户的 ID。
两个正好相隔 24 小时的消息被认为是在窗口内。 该操作不会影响答案，只会影响请求时间。
以任意顺序返回结果表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/321cf7da4c62ec0e783ed773f2736d6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5045392ddda25085c61a81531c3a440c/" rel="bookmark">
			简单工厂，工厂方法，抽象工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简单工厂模式简单工厂模式的角色简单工厂的介绍 工厂方法UML图片代码工厂方法总结： 抽象工厂代码实现 简单工厂模式 简单工厂模式（Simple Factory Pattern）专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。
简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。
简单工厂模式的角色 （1）Factory工厂角色（工厂类）：
工厂角色即工厂类，是简单工厂模式的核心，负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。
（2）Product（抽象产品角色）：
抽象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其子类对象。
（3）ConcreteProduct（具体产品角色）：
具体产品角色是简单工厂模式的创建目标。每个具体产品角色都继承了抽象产品角色，需要实现定义在抽象产品中的方法。
简单工厂的介绍 简单工厂（Simple Factory）不属于标准的OOP设计模式中的一项，在编写大型C++软件的时候，代码里面会出现很多的类，每次创建对象的时候，都需要通过new 类名称的方式来生成对象，这样一来，用户需要记忆很多类的名称，暂且不管记不记得住，这样的设计使得代码很难维护，类名如果做了改变，那么所有使用类名称的地方都需要去修改，耦合性太强，不符合我们软件设计的思想，Simple Factory就是在这样的需求下诞生的。
我们把对象的创建全部都封装在了SimpleFactory的create方法中，在这里我们传入一个Product就可以创建一个对象，省略了new的过程
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //产品类型的声明,抽象产品 class Product { public: Product(string name) : ProductName(name) {}; virtual void show() = 0; protected: string ProductName; }; //具体产品的声明 class BaoMa :public Product { public: BaoMa(string name) : Product(name) {}; void show() { std::cout &lt;&lt; "This is BaoMa Product" &lt;&lt; char(10); std::cout &lt;&lt; ProductName &lt;&lt; char(10); } }; //具体产品2 的申明 class BengChi :public Product { public: BengChi(string name) : Product(name) {}; void show() { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5045392ddda25085c61a81531c3a440c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51cc0db8e8b9b9477d7e6c25b368e98/" rel="bookmark">
			性能测试之（十）：JMeter录制脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JMeter录制脚本
应用场景：在没有接口文档的旧项目当中，快速录制web页面产生的http接口请求，帮助编写接口测试脚本
原理：Jmeter在客户端服务器之间做代理。收到所有的请求和响应数据后，JMeter在进行逆向解析的动作，将数据报文转化为脚本。
1、首先添加一个HTTP代理服务器：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/df2b06fbe09a4155aab9654c55f92993.png = 500x)2、设置本机代理服务器的配置:
3、点击启动。并进入浏览器进行web页面操作，脚本会自动生成并存放在指定的线程组下；
4、可以在Request Filtering进行过滤，包含的内容和不包含的内容都需要以正则表达式形式展示：
5、若需要cookie的情况下，可在录制之前在测试计划下添加：HTTP Cookie管理器；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2395ff6f594f5c7df3da226f5434525/" rel="bookmark">
			算法基础之区间分组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区间分组 核心思想：贪心
若所有组中右端点最大值都比当前遍历的区间的左端点大 则需要开新组
为了让组数最多 根据左端点排序
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int N = 100010; struct Range{ int l,r; bool operator&lt; (const Range &amp;W)const{ return l&lt;W.l; //左端点排序 } }range[N]; int main() { int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;range[i].l&gt;&gt;range[i].r; priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt;&gt; heap; //小根堆 找最小右端点 //heap中每一个位置相当于一个组 当需要让区间入组时 将该位置删掉 再加上 sort(range,range+n); for(int i=0;i&lt;n;i++) { auto r = range[i]; //当前遍历区间 if(heap.empty() || heap.top() &gt;= r.l) heap.push(r.r); //空或最小右端点都比左端点大 则开新组 else { heap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2395ff6f594f5c7df3da226f5434525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6d75514c69a5040b1624335296e0cc/" rel="bookmark">
			[运维|数据库] mysql8报Public Key Retrieval is not allowed错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 连接数据库的url中，加上allowPublicKeyRetrieval=true参数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c713d7747512c4b4a61132a4647dcab/" rel="bookmark">
			从0开始python学习-38.pytest的parametrize结合yaml实现数据驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 数据驱动
2. 定制化allure报告
1. 数据驱动 yaml文件中写入
- data: 1 ces: 2 - test: data: 3 数据驱动：@pytest.mark.parametrize("参数名","参数值（可以是list或tuple）")
注意：这里参数值只能是列表或者元组，由于yaml的特性，最好写成列表，如果写成了字典则无法读取
@pytest.mark.parametrize("caseinfo",YamlUtil("./common/test_api.yaml").read_yaml()) def test_b(self,caseinfo): print(caseinfo) print(caseinfo["data"]) 打印结果：
注意：这里有多个case的情况，每个case下的key值最好一致
2. 定制化allure报告 - title: 用例1 - test: title: 用例2 定制化title，定制其他的同理即可
@allure.epic('测试报告') @allure.feature('测试模块') @pytest.mark.parametrize("caseinfo",YamlUtil("./common/test_api.yaml").read_yaml()) def test_b(self,caseinfo): allure.dynamic.title(caseinfo["title"]) print(caseinfo["data"]) allure报告：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4babbeca4d93a718fd5551a0ee7a721/" rel="bookmark">
			台式电脑通过网线，连接笔记本电脑wifi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 台式电脑通过网线，连接笔记本电脑wifi wifi笔记本电脑，选中网线的网络（没有，则反复关闭共享，再开启共享，直到弹出可选网络） 台式电脑设置为自动获取IP地址 成功的细节 笔记本网络会自动改为192.168.137.1 牢记：不行就反复关闭重启 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528a628241fb78214d7bfc9b786d7a48/" rel="bookmark">
			Java基础-----集合类（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Arraylist2. Arraylist常用方法 今天主要学习集合类框架 1. Arraylist Collection:是List和Set的父接口，里面包含了一些公用的方法
List:是一个有序的、不唯一的接口
ArrayList：是List的一个实现类，底层数据结构是数组
public class Test { public static void main(String[] args) { /*Collection collection=new ArrayList(); List list; ArrayList arrayList;*/ //ArrayList的特点：有顺序的，不唯一 ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;(); System.out.println(list.toString());//[] list.add(12); list.add(23); list.add(45); list.add(10); list.add(10); System.out.println(list.toString());//[12, 23, 45, 10,10] } } ArrayList循环遍历
public class TestArrayList { public static void main(String[] args) { List&lt;String&gt; list=new ArrayList&lt;&gt;(10); list.add("AAA"); list.add("BBB"); list.add("CCC"); //集合的循环遍历方式 //遍历方式1 /*for(int i=0;i&lt;list.size();i++){ System.out.println(list.get(i)); }*/ //遍历方式2 /*for (String s : list) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528a628241fb78214d7bfc9b786d7a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf964db321cecfcc15801f8f5c376a42/" rel="bookmark">
			MySQL取出N列里最大or最小的一个数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，现在有3列，都是数字类型，要取出这3列里最大或最小的的一个数字
-- N列取最小 SELECT LEAST(temperature_a,temperature_b,temperature_c) min FROM infrared_heat -- N列取最大 SELECT GREATEST(temperature_a,temperature_b,temperature_c) max FROM infrared_heat (注意:是3列! 不是3行! 3行直接用max() min()函数就行...)
实际应用, 取出3列中某个值最大的那一行数据 :
SELECT *	FROM infrared_heat a, ( SELECT MAX(max) max,station_name,device_name,location FROM ( SELECT GREATEST(temperature_a,temperature_b,temperature_c) max -- 取出3列最大值 ,station_name,device_name,location FROM infrared_heat WHERE test_date &gt;='2024-1-1' and test_date&lt;'2024-1-31' ) temp GROUP BY station_name,device_name,location )b WHERE a.test_date &gt;='2024-1-1' and a.test_date&lt;'2024-1-31' and a.station_name=b.station_name and a.device_name=b.device_name and a.location=b.location and GREATEST(a.temperature_a,a.temperature_b,a.temperature_c)=b.max -- 3列最大值 原始的数据,添加一个3列的最大值列max:
取出3列最大值后,再分组(group by)后的数据, 查询的结果外面还要套一层用于取出max对应的uid:
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/12/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>