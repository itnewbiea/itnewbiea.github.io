<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7ba099cce1e5450f06e5de0c5708a3/" rel="bookmark">
			使用Git克隆Github项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载 Git
打开Git官网下载地址Git download
Git for Windows Setup和Git for Windows Portable(便携版)两个版本都可以，我选择的是基本版本，点击”64-bit Git for Windows Setup”。
下载完成后，进行安装：参考此链接进行安装，写的非常好！
二、GitHub官网注册自己账号
gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。
参考链接：怎样使用GitHub
三、使用SSH建立Git和GitHub之间的连接
1.在Git上设置自己的用户名和邮箱参考链接
git config –global user.name “你的github用户名”
git config –global user.email “你的github邮箱地址”
2.生成SSH
ssh-keygen -t rsa -C “自己的邮箱”
SSH文件存放在C:/User/用户/.ssh下，id_rsa为私钥，id_rsa.pub为公钥。
3. 在GitHub上配置SSH
接下来打开id_rsa.pub文件，全选，复制全文
接下来打开GitHub右上角头像处的Settings，选择SSH and GPGkeys，New SSH key。
测试SSH连接 ssh -T git@github.com
连接成功
从GitHub仓库clone项目正式开始
1、在本地建好将要存放项目的文件夹
2、在当前文件夹下鼠标右键，Git Bush Here
3、git init (初始化git )
4、去到你将要clone的github仓库，如图将其网址copy下来
5、如图所示，输入git clone 然后将复制好的项目地址贴下来，回车，就可以了
然后再去文件夹下看，就会看到下载好的项目信息
如果git clone 的时候遇到问题：可以参考博文进行问题解决。也许多git clone 几次就可以解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5601724512fdc8e6bc21f739831c3ca/" rel="bookmark">
			VTK源码编译安装记录与教程（VS2019&#43;QT5.15.2&#43;PCL1.12.1&#43;VTK9.1.0配置，超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为PCL库（傻瓜式安装）中自动安装的VTK库并不完整，不支持QT环境的UI界面开发，于是，想用QT在VS2019上开发图形界面程序，需要单独自己通过VTK源码编译安装，再进行配置。本人安装时开发环境已经装好的是VS2019+QT5.15.2+PCL1.12.1，供参考，其他版本基本上大同小异，需要注意的是在自动安装的PCL库中，看到里面VTK库的版本是9.1.0，于是，在源码编译安装VTK过程中，为了保险也用的是9.1.0版本。
目录 下载VTK源码：用CMake编译源码在VS中生成库替换PCL库中的VTK配置QT项目属性测试点云显示（QT项目PCL读取+VTK显示） 下载VTK源码： 下载VTK源码
VTK官网下载链接，点击进入找到源码地址，找到官方在gitlab上的官方仓库，根据自己需要的版本下载源码。
进入gitlab官方仓库，点击标签
找到自己需要的版本进行下载
下载安装CMake
进入CMake官网进行下载，Windows系统下载二进制的安装文件直接点击就可以安装。
用CMake编译源码 准备好以下空目录，并把下载到的源码解压到VTK-Source中（目录命名仅作参考，读者可根据自己情况定义，但是建议目录中不要有中文字符，避免出现字符编码问题）
打开CMake-GUI
我是以管理员身份运行的CMake，不知道是不是必须条件，没有试过，运行后首先配置路径：
勾选grouped和advanced这两个选项（为了configure之后显示的结果进行分组归整，容易查看），再点击configure选择合适的编译器，点击Finish开始进行编译。
经过一定时间的等待，可以看到有很多红色选项是需要手动去检查或设置的，大家不要被一堆红色吓到了，这里的红色并不是报错了，只是编译器检测到了有这么多项需要配置，根据需要核查和设置几个最主要的项就行了。
配置关键属性项
1） BUILD_SHARED_LIBS 这个默认是勾选的，如果没勾选，勾选即可，作用是生成动态链接库dll，如果不勾，就是静态链接了，一般都是勾选的。
2）CMAKE_INSTALL_PREFIX是VTK的安装目录，默认是C盘中的一个目录，这里把它改为我们希望的目录地址，我这里改就是事先准备好的VTK-Install下的release（我后来在VTK-Install这个目录下又分别创建了release和debug两个目录，是为了以后万一要再生成一个debug版的库）
PS(事后补充）：除非只打算编译一种（release或debug或其他，见下一条设置），这里可以不用分，或者说事后再分。因为如果下一条编译类型写了多个的话（还是见下一条），那么在最后生成库的时候（VS中生成INSTALL这个项目时，后面会讲到），其实会全部生成到这个选项所设置的目录当中去，如果要区分，只能自己在生成过程中或者之后，手动剪切粘贴来完成（尝试过在VS中修改输出目录，但没起作用，欢迎大神解答或者以后再研究）。
3）CMAKE_CONFIGURATION_TYPES 是设置编译的类型（release或者debug等），默认是“Debug;Release;MinSizeRel;RelWithDebInfo”，这样一来生成的VS解决方案里(就是上面Buld这个目录）的工程打开，就可以支持四种不同设置的工程。这个根据需要来设置即可，也可以按默认的来。
4）与QT有关的配置，可以用关键词来搜索相关的配置项，默认都是DEFAULT，咱也不知道这个默认值到底是啥（有兴趣的伙伴可以试试），按照网上说的教程选了WANT，有的版本是只有勾选框，就直接勾选就好了，我这个版本有四个选项（YES，NO，WANT，NO_WANT），我也不知道YES和WANT有啥区别（搜了一下也没找到答案，有知道的大佬欢迎评论指正）。
以上这些主要的配置完了之后，再次点击“Configure”，会把大部分的配置项清除（或者变为白色，个人理解就是系统不需要向用户确认了）。但是由于我们在QT相关的配置项做了修改（主要是WANT了QT相关内容），所以又会出现一些红色配置项（系统需要我们补充配置或向我们确认），情况如下：
这里出现了一个小插曲：由于我的机器之前装了anaconda3且配置了环境变量，里面可能以前装了（不记得是默认装的还是手动装的了）QT，所以这里目录自动检索到了anaconda3里的目录，但是我实际上是单独安装了QT5.15.2且选择了对应的msvc2019编译器，也装了vs的QT插件，显然这个需求和anaconda3里的QT是不符合的。所以手动重新按照自己单独安装QT的目录重新设置了（如果在系统环境变量中，自己装的QT的目录在anaconda之前，应该可以直接避免这种情况），如下：
设置好后再次点击Configure，理想情况，应该是没有红色的事项了，然而意外还是发生了：
这里还有一个红色的警告，和QML有关，警告内容上面截图没截到，内容是“CMake Warning (dev) at GUISupport/QtQuick/qml/CMakeLists.txt:93 (message): Qt5 is configured in both Debug and Release modes. Due to Qt issue 47774 (https://bugreports.qt.io/browse/QTBUG-47774), skipping generation of qmltypes file. Using the one provided with the source tree instead.”,网上搜索一番，有人说是QML不能编译release版的，具体解决方法没有深究，只是一个告警，再次点击configure，会被直接忽略，如下图：
点击Generate,如下，大功告成？！
在VS中生成库 好了，上面那步的Generate只是生成了VS的解决方案，也就是build里的东西，接下来，点击旁边的“Open Project”，会自动启动Visual Studio并打开Build目录下的解决方案。如下图：
可以看到，上图中，编译类型有四种，跟我们之前在CMake中配置的一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5601724512fdc8e6bc21f739831c3ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34abb90027f8006a63b2572564b0ace/" rel="bookmark">
			CSDN编写技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34abb90027f8006a63b2572564b0ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905bf6588ced82bd85d58133c6347434/" rel="bookmark">
			CMake使用介绍2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正式工程构建 正式的源码工程应该有以下几个目录：
-bin 存放最终的可执行文件 -build 存放编译中间文件 -include 头文件 -src 源代码文件 --main.cpp -CMakeLists.txt 其中CMakeLists.txt文件中的内容如下：
cmake_minimum_required (VERSION 3.10.2) project (math) # 设置cmake的全局变量 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) #添加头文件路径，相当于makefile里面的-I include_directories(${PROJECT_SOURCE_DIR}/include) aux_source_directory (src SRC_LIST) add_executable (main main.cpp ${SRC_LIST}) 然后执行cmake..，所有的编译中间文件都会在build目录下，最终可执行文件在bin目录下。
CMake常用的预定义变量 PROJECT_NAME : 通过 project() 指定项目名称 PROJECT_SOURCE_DIR : 工程的根目录 PROJECT_BINARY_DIR : 执行 cmake 命令的目录 CMAKE_CURRENT_SOURCE_DIR : 当前 CMakeList.txt 文件所在的目录 CMAKE_CURRENT_BINARY_DIR : 编译目录，可使用 add subdirectory 来修改 EXECUTABLE_OUTPUT_PATH : 二进制可执行文件输出位置 LIBRARY_OUTPUT_PATH : 库文件输出位置 BUILD_SHARED_LIBS : 默认的库编译方式 ( shared 或 static ) ，默认为 static CMAKE_C_FLAGS : 设置 C 编译选项 CMAKE_CXX_FLAGS : 设置 C++ 编译选项 CMAKE_CXX_FLAGS_DEBUG : 设置编译类型 Debug 时的编译选项 CMAKE_CXX_FLAGS_RELEASE : 设置编译类型 Release 时的编译选项 CMAKE_GENERATOR : 编译器名称 CMAKE_COMMAND : CMake 可执行文件本身的全路径 CMAKE_BUILD_TYPE : 工程编译生成的版本， Debug / Release 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3a216ffadfa106f76a6f6d9faffe49/" rel="bookmark">
			非要问Glide的源码吗？不会 会影响我开发吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 16年时候会布局会简单的listView 咱就能工作了，现在非要这么卷吗？ 问你缓存策略，问你生命周期、问你里面各中设计模式 都是同行为什么要这样死逼呢？
Glide的缓存 简单的使用：
Glide.with(this).load("").into(null) 先简单的记 with是绑定页面生命周期(防止内存泄露) load 是构建请求(像 okhttp 构建Request一样) into方法就像okhttp client执行enqueue方法一样
那么缓存我们就从into方法看 前面的先不看 因为咱们主要是看缓存
注意这里的Target 我们把它作一个回调(像okhttp 的 CallBack一样)
image.png image.png 我们进入到super.into(view)
image.png image.png image.png 注意这里 (看英文意思 开始请求)
image.png 这里Request是一个接口
image.png 我们找它的实现类：GenericRequest image.png image.png image.png 至此我们找到了入口
image.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af983255b660fd7ddfd53f4e403babd/" rel="bookmark">
			Linux 线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 线程1. 前言2. 线程3. 轻量化进程4. 线程栈5. 进程和线程 线程 1. 前言 在 Linux 中，一个进程涉及到各种大量的数据结构，当发生进程切换的时候，操作系统要做的工作非常多，比如保存并切换上下文数据，切换进程的虚拟地址空间，页表…，同时创建和销毁进程也是一个不小的性能开销，而且由于需要保证进程的独立性，带来的问题就是进程间通信效率并不高。
于是就引入了线程技术，故事不讲了
2. 线程 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。（来源：百度百科）
反正关键就是：一个进程包括多个线程，以及，线程可以执行任务，还可以参与调度，在 Linux 中，下面瞅瞅这些能力是怎么表现出来的
目前，在Linux 中，描述进程的结构体叫 task_struct，为了简化，描述线程的结构体也叫 task_struct，即线程复用了进程的代码。
不同于 Windows，Windows 专门设计了描述线程的结构体，设计了各种线程需要的数据结构和算法，非常复杂 ① 一个进程可以包括若干个线程 —— 对于同一个进程中的线程，这些线程共享进程的数据结构，比如虚拟地址空间，页表，文件描述符表…
进程包含一个或者多个 task_struct，还包括属于进程的各种数据结构，而这些 task_struct，是共用这些数据结构的。一个线程的创建和销毁不会让这些共享资源消失，而进程的销毁会带走这些数据结构以及线程，所以线程的创建和销毁是轻量级的
② 线程可以执行任务，并参与调度
如果没有线程，那么参与调度的就是进程了，我们理解这种进程为：只有一个线程的进程。
而现在一个进程中有多个线程，这些线程都可以独立作为一个执行流来让 CPU 进行调度，现在 Linux 中最小的调度单位就是线程了
3. 轻量化进程 所以，进程就有点像一个外壳 / 工具人了
线程被设计出来后，进程在操作系统中的角色就更偏向于申请资源的角色了，当进程创建的时候，总会分配一大堆内核数据结构，对于一个进程中的线程来说，这些资源都是共享的，直接用就好了而线程作为一个个task_struct，被称为执行调度的基本单位，对于同一个进程中的线程来说，线程的切换开销对于进程来说是很小的，基本上恢复这个线程的 PCB 上下文数据就完成了大部分切换工作，不像进程 所以说，Linux 中认为线程是轻量级的进程，线程复用了进程的数据结构，进程负责申请一大片空间，线程作为进程的一个个执行流参与调度，线程的切换开销很小。
并且线程之间共享进程的资源，操作系统并不需要单独为这些线程分配和管理资源，线程的创建和销毁都不影响进程的共享资源，虽然线程也有自己独立的数据结构，但是这些数据结构相对来说都比较小，比如后面要说的线程独立栈
如果从一个线程切换到另一个进程中的线程，这相当于进程切换了，那么还是会有很大的开销，因为需要进行进程各种数据结构的切换，所以轻量级是对同一个进程中的线程来说的，不是所有线程 总结一下
线程的轻量化是对同一个进程中的所有线程来说的，这些线程共享进程的资源，所以他们在创建和销毁的时候都不需要再为这些共享资源重新分配空间和初始化操作创建和销毁的时候涉及到的数据结构都比较小巧，比如线程栈，task_struct，寄存器中的相关数据，不需要大规模的数据拷贝，所以开销也就比较小 4. 线程栈 （线程的实现逻辑和代码，在 Linux 中并没有完全写完，还有一部分代码是在 pthread 库中的，即libpthread.so动态库）
一个程序要运行起来，必须得有栈结构，像进程，或者说进程中的 main 线程，它在运行过程中依赖的栈结构是虚拟地址空间中的栈，但是该进程中的其他线程用的栈就不是这个了
每个线程都有一个自己独立的栈，方便自己运行起来，其他线程中的栈结构是 pthread 库中提供的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af983255b660fd7ddfd53f4e403babd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a4a2e70586e175dcd835beb5e6623e/" rel="bookmark">
			人工智能实战项目(python)&#43;多领域实战练手项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能实战项目 大家好，我是微学AI，本项目将围绕人工智能实战项目进行展开，紧密贴近生活，实战项目设计多个领域包括：金融、教育、医疗、地理、生物、人文、自然语言处理等；帮助各位读者结合机器学习与深度学习构建智能而且实用的人工智能简单系统，创建有影响力的AI应用，项目中提供项目原码，一步一步地运行每行代码，了解每行代码在做什么，由浅入深，不断地解决多领域的问题。
开源地址：https://github.com/shenqiang0601/deep_learning.git
目录 一、人工智能基础部分
1.人工智能基础部分1-人工智能的初步认识
2.人工智能基础部分2-一元一次函数感知器
3.人工智能基础部分3-方差损失函数的概念
4.人工智能基础部分4-梯度下降和反向传播
5.人工智能基础部分5-激活函数的概念
6.人工智能基础部分6-神经网络初步认识
7.人工智能基础部分7-高维空间的神经网络认识
8.人工智能基础部分8-深度学习框架keras入门案例
9.人工智能基础部分9-深度学习深入了解
10.人工智能基础部分10-卷积神经网络初步认识
11.人工智能基础部分11-图像识别实战
12.人工智能基础部分12-循环神经网络初步认识
13.人工智能基础部分13-LSTM网络：预测上证指数走势
14.人工智能基础部分14-蒙特卡洛方法在人工智能中的应用及其Python实现
15.人工智能基础部分15-自然语言处理中的数据处理上采样、下采样、负采样是什么？
16.人工智能基础部分16-神经网络与GPU加速训练的原理与应用
17.人工智能基础部分17-隐马尔科夫模型在序列问题的应用
18.人工智能基础部分18-条件随机场CRF模型的应用
...(待更新)
二、机器学习实战项目
1.机器学习实战1-四种算法对比对客户信用卡还款情况进行预测
2.机器学习实战2-聚类算法分析亚洲足球梯队
3.机器学习实战3-利用决策树算法根据天气数据集做出决策
4.机器学习实战4-教育领域:学生成绩的可视化分析与成绩预测-详细分析
5.机器学习实战5-天气预测系列:利用数据集可视化分析数据，并预测某个城市的天气情况
6.机器学习实战6-电子商务网站用户行为分析及服务推荐
7.机器学习实战7-服务员公司客户价值分析与流失分析
8.机器学习实战8-基于基站定位数据的商圈分析
9.机器学习实战9-售车逃税店铺自动识别
10.机器学习实战10-企业关联规则挖掘
...(待更新)
三、深度学习实战项目
1.深度学习实战1-(keras框架)企业数据分析与预测
2.深度学习实战2-(keras框架)企业信用评级与预测
3.深度学习实战3-文本卷积神经网络（TextCNN）新闻文本分类
4.深度学习实战4-卷积神经网络（DenseNet）数学图形识别+题目模式识别
5.深度学习实战5-卷积神经网络（CNN）中文OCR识别项目
6.深度学习实战6-卷积神经网络(Pytorch)+聚类分析实现空气质量与天气预测
7.深度学习实战7-电商产品评论的情感分析
8.深度学习实战8-生活照片转化漫画照片应用
9.深度学习实战9-文本生成图像-本地电脑实现text2img
10.深度学习实战10-数学公式识别-将图片转换为Latex(img2Latex)
11.深度学习实战11(进阶版)-BERT模型的微调应用-文本分类案例
12.深度学习实战12(进阶版)-利用Dewarp实现文本扭曲矫正
13.深度学习实战13(进阶版)-文本纠错功能，经常写错别字的小伙伴的福星
14.深度学习实战14(进阶版)-手写文字OCR识别，手写笔记也可以识别了
15.深度学习实战15(进阶版)-让机器进行阅读理解+你可以变成出题者提问
16.深度学习实战16(进阶版)-虚拟截图识别文字-可以做纸质合同和表格识别
17.深度学习实战17(进阶版)-智能辅助编辑平台系统的搭建与开发案例
18.深度学习实战18(进阶版)-NLP的15项任务大融合系统，可实现市面上你能想到的NLP任务
19.深度学习实战19(进阶版)-SpeakGPT的本地实现部署测试，基于ChatGPT在自己的平台实现SpeakGPT功能
20.深度学习实战20(进阶版)-文件智能搜索系统，可以根据文件内容进行关键词搜索，快速找到文件
21.深度学习实战21(进阶版)-AI实体百科搜索，任何名词都可搜索到的百科全书
22.深度学习实战22(进阶版)-AI漫画视频生成模型，做自己的漫画视频
23.深度学习实战23(进阶版)-语义分割实战，实现人物图像抠图的效果（计算机视觉）
24.深度学习实战24-人工智能(Pytorch)搭建transformer模型,真正跑通transformer模型，深刻了解transformer的架构
25.深度学习实战25-人工智能(Pytorch)搭建T5模型,真正跑通T5模型,用T5模型生成数字加减结果
26.深度学习实战26-(Pytorch)搭建TextCNN实现多标签文本分类的任务
27.深度学习实战27-Pytorch框架+BERT实现中文文本的关系抽取
28.深度学习实战28-AIGC项目：利用ChatGPT生成定制化的PPT文件
29.深度学习实战29-AIGC项目：利用GPT-2(CPU环境)进行文本续写与生成歌词任务
30.深度学习实战30-AIGC项目：自动生成思维导图文件，解放双手
31.深度学习实战31-开发基于机器学习的在线图像识别工具
...(待更新)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79a4a2e70586e175dcd835beb5e6623e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ee89c481827589695d8d0737aaf97e/" rel="bookmark">
			pyflink 读取kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# -*- coding: utf-8 -*-
from pyflink.datastream import StreamExecutionEnvironment
from pyflink.datastream.functions import MapFunction, RuntimeContext, KeyedProcessFunction
from abc import ABC, abstractmethod
from pyflink.datastream import StreamExecutionEnvironment
from pyflink.datastream.functions import MapFunction, RuntimeContext, KeyedProcessFunction
from pyflink.datastream.state import MapStateDescriptor
from pyflink.datastream.connectors.kafka import FlinkKafkaConsumer
from pyflink.common.typeinfo import Types, TypeInformation
from pyflink.datastream.connectors.elasticsearch import Elasticsearch7SinkBuilder, ElasticsearchEmitter, FlushBackoffType
from pyflink.datastream.connectors import DeliveryGuarantee
from pyflink.common.serialization import SimpleStringSchema
import json
import re
from datetime import datetime
from elasticsearch import Elasticsearch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ee89c481827589695d8d0737aaf97e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c5a0a75c55c99799b4b744a1e7c88d/" rel="bookmark">
			docker安装nacos2.2.0并配置持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、docker拉取nacos镜像 docker pull nacos/nacos-server:v2.2.0 二、创建映射容器的文件目录 # 创建logs目录 mkdir -p /mydata/nacos/logs/ # 创建配置文件目录 mkdir -p /mydata/nacos/conf/ #授予权限 chmod 777 /mydata/nacos/logs chmod 777 /mydata/nacos/conf 三、创建application.properties文件并放入/mydata/nacos/conf/中 自行配置db数据源，账号密码
# # Copyright 1999-2021 Alibaba Group Holding Ltd. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c5a0a75c55c99799b4b744a1e7c88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8609cb65544dad1fc22b6e14164a8f63/" rel="bookmark">
			SpringBoot整合rabbitmq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pom.xml 添加rabbitmq依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 添加rabbit配置信息 rabbitmq: host: 1.1162.199.18 port: 56721 username: xxxx password: xxxx 编写消息常量类Mqconst.java package com.atguigu.yygh.common; public class MqConst { /** * 预约下单 */ public static final String EXCHANGE_DIRECT_ORDER = "exchange.direct.order"; public static final String ROUTING_ORDER = "order"; //队列 public static final String QUEUE_ORDER = "queue.order"; /** * 短信 */ public static final String EXCHANGE_DIRECT_MSM = "exchange.direct.msm"; public static final String ROUTING_MSM_ITEM = "msm.item"; //队列 public static final String QUEUE_MSM_ITEM = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8609cb65544dad1fc22b6e14164a8f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1fa8befb12c39421bbbede6886dcb29/" rel="bookmark">
			【博学谷学习记录】超强总结，用心分享 | 陌陌案例-离线与实时查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#博学谷IT技术支持#
一、案例需求 选择合理的存储容器进行数据存储，支持即席查询与离线分析实时统计消息总量实时统计各个地区收发消息的总量实时统计每一位客户发送和接收消息数量 二、架构流程 2.1 数据采集操作：基于flume实现消息数据采集 监听数据源文件，一旦文件中有新的内容出现，将对应数据写入Kafka中，同时既能监听文件，也能监听目录
操作步骤
1. 确定三大组件
Source组件：Taildir Source
Sink组件：Kafka Sink
channel组件：Memory Channel
2. 调整采集配置信息
3. 配置采集文件
4. 在Kafka中创建MOMO_MSG的Topic
5. 启动Flume组件，准备进行数据采集工作
6. 测试是否正常采集
2.2 写入到HBase 1. 在HBase中创建一个名称空间：MOMO_CHAT
2. 在HBase中创建表
列族设计：C1是否需要压缩：GZ预分区：基于Hash预分区，6个版本号：仅需要保留1个TTL：数据永久保存不需要考虑 3. 创建一个消费者完成数据写入到HBase
4. 测试操作
启动相关的软件：zookeeper、hadoop、hbase、kafka启动消费者代码启动陌陌数据源检测hbase表中是否有数据 2.3 对接Phoenix 创建视图
create view MOMO_CHAT.MOMO_MSG( "id" varchar primary key, C1."msg_time" varchar, C1."sender_nickyname" varchar, C1."sender_account" varchar, C1."sender_sex" varchar, C1."sender_ip" varchar, C1."sender_os" varchar, C1."sender_phone_type" varchar, C1."sender_network" varchar, C1."sender_gps" varchar, C1."receiver_nickyname" varchar, C1."receiver_ip" varchar, C1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1fa8befb12c39421bbbede6886dcb29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6412bc77fd314dc6a82b6d50dc7c05c0/" rel="bookmark">
			Prometheus 实践操作 -＞ prometheus配置部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		prometheus下载解压
Prometheus
下载后直接把这个压缩包丢到服务器上面，然后解压。
tar -zxvf prometheus-2.44.0.linux-amd64.tar.gz 一、prometheus 系统自启动 需新增系统服务 /etc/systemd/system/prometheus.service [Unit] Description=Prometheus After=network.target [Service] Type=simple ExecStart=/opt/prometheus/prometheus --config.file=/opt/prometheus.yml --web.enable-lifecycle Restart=on-failure [Install] WantedBy=multi-user.target ExecStart为prometheus解压位置。 –config.file为prometheus解压目录配置文件的位置 系统服务新增后 #1.加载系统服务 systemctl daemon-reload #2.启动服务 systemctl start prometheus.service #3.设置为系统自启动 systemctl enable orimetheus.service 二、手动启动prometheus 启动成功后访问一下：ip+端口，端口默认为9090； 在服务器查看启动是否成功 1.使用以下命令查看是否有进程 ps -ef|grep prometheus 2.如果是系统服务启动的，使用以下命令可查看服务器是否启动成功 systemctl status prometheus.service 热更新 1.进入其目录下 直接输入命令 ./prometheus 启动 在后面加入 --web.enable-lifecycle 同样可以实现热更新 启动成功后，修改了prometheus.yml配置可使用以下命令进行服务热更新 curl -X POST http://ip:9090/-/reload prometheus.yml 需要的配置 后面再记录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29142094e3234ac568dbe2e02f5fd01f/" rel="bookmark">
			数据结构之二叉树及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树及其应用 1.用递归和非递归两种方式实现先序，中序，后序遍历 （1）递归： ​ 递归序：每个节点会三次回到自己，在此基础上引申出了先序，中序，和后序遍历
​ ①先序遍历（头左右）：在递归序的基础上，第一次出现时打印（或进行操作）
public static void preOrderRecur(Node head){ if(head == null){ return; } System.out.print(head.value + " "); preOrderRecur(head.left); preOrderRecur(head.right); } ​ ②中序遍历（左头右）：在递归序的基础上，第二次出现时打印（或进行操作）
public static void inOrderRecur(Node head){ if(head == null){ return; } inOrderRecur(head.left); System.out.print(head.value + " "); inOrderRecur(head.right); } ​ ③后序遍历（左右头）：在递归序的基础上，第三次出现时打印（或进行操作）
public static void posOrderRecur(Node head){ if(head == null){ return; } posOrderRecur(head.left); posOrderRecur(head.right); System.out.print(head.value + " "); } （2）非递归： ​ ①先序遍历（同上）：
​ 第一步：从栈中弹出一个节点car；
​ 第二步：打印（或处理）car；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29142094e3234ac568dbe2e02f5fd01f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1db61e74d3c1c64797bf8d44e2818e/" rel="bookmark">
			＜!DOCTYPE＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE&gt; 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。
在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明需引用 DTD （文档类型声明），因为 HTML 4.01 是基于 SGML （Standard Generalized Markup Language 标准通用标记语言）。DTD 指定了标记语言的规则，确保了浏览器能够正确的渲染内容。HTML5 不是基于 SGML，因此不要求引用 DTD
提示：总是给您的 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，确保浏览器能够预先知道文档类型
HTML 4.01 规定了三种不同的 &lt;!DOCTYPE&gt; 声明，分别是：Strict、Transitional 和 Frameset。
HTML5 中仅规定了一种：
&lt;!DOCTYPE html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d802b7df691bcea21b2e1df348e1da4/" rel="bookmark">
			深度学习应用篇-计算机视觉-OCR光学字符识别[7]：OCR综述、常用CRNN识别方法、DBNet、CTPN检测方法等、评估指标、应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深度学习入门到进阶】必看系列，含激活函数、优化策略、损失函数、模型调优、归一化算法、卷积模型、序列模型、预训练模型、对抗神经网络等
专栏详细介绍：【深度学习入门到进阶】必看系列，含激活函数、优化策略、损失函数、模型调优、归一化算法、卷积模型、序列模型、预训练模型、对抗神经网络等
本专栏主要方便入门同学快速掌握相关知识。后续会持续把深度学习涉及知识原理分析给大家，让大家在项目实操的同时也能知识储备，知其然、知其所以然、知何由以知其所以然。
声明：部分项目为网络经典项目方便大家快速学习，后续会不断增添实战环节（比赛、论文、现实应用等）
专栏订阅：
深度学习入门到进阶专栏深度学习应用项目实战篇 1.OCR综述 OCR(Optical Character Recognition,光学字符识别)是指对图像进行分析识别处理，获取文字和版面信息的过程，是典型的计算机视觉任务，通常由文本检测和文本识别两个子任务构成。
文字检测：将图片中的文字区域位置检测出来（如图1(b)所示）；文字识别：对文字区域中的文字进行识别（如图1©所示）。 OCR发展历程 早在60、70年代，人们就开始对OCR进行研究。在研究的初期，主要以文字识别方法研究为主，而且识别的文字仅为0-9的数字。数字识别主要应用在识别邮件上的邮政编码。
在深度学习出现之前，传统算法(如积分投影、腐蚀膨胀、旋转等)在OCR领域占据主导地位。其标准的处理流程包括：图像预处理、文本行检测、单字符分割、单字符识别、后处理。
其中：
图像预处理主要是对图像的成像问题进行修正，包括几何变换（透视、扭曲、旋转等），去模糊、光线矫正等；
文本检测通常使用连通域、滑动窗口两个方向；
字符识别算法主要包括图像分类、模版匹配等。
受传统算法的局限性，传统OCR仅在比较规整的印刷文档上表现比较好，但在复杂场景(图像模糊、低分辨率、干扰信息)之下，文字检测、识别性能都不够理想。
自2012年AlexNet在ImageNet竞赛夺冠以来，深度学习方法开始在图像视频领域大幅超越传统算法，OCR领域也引入了深度学习，包括基于卷积神经网络（Convolutional Neural Network, CNN）来取代传统算法提取特征。深度学习OCR主要分为2步，首先是检测出图像中的文本行、接着进行文本识别。
1.1 OCR 常用检测方法 OCR文字检测就是将图片中的文字区域检测出来。
常用的基于深度学习的文字检测方法一般可以分为基于回归的、基于分割的两大类，当然还有一些将两者进行结合的方法。
1.1.1基于回归的方法 基于回归的方法又分为box回归和像素值回归：
1) box回归 采用box回归的方法主要有CTPN、Textbox系列和EAST
**优点：**对规则形状文本检测效果较好
**缺点：**无法准确检测不规则形状文本。
2) 像素值回归 采用像素值回归的方法主要有CRAFT和SA-Text，这类算法能够检测弯曲文本且对小文本效果优秀但是实时性能不够。
1.1.2 基于分割的算法 如PSENet，这类算法不受文本形状的限制，对各种形状的文本都能取得较好的效果，但是往往后处理比较复杂，导致耗时严重。目前也有一些算法专门针对这个问题进行改进，如DB，将二值化进行近似，使其可导，融入训练，从而获取更准确的边界，大大降低了后处理的耗时。
1.3 OCR常用识别方法 Rosetta
CRNN
STAR-Net
RARE
SRN
1.4 OCR常用评估指标 （1）检测阶段：先按照检测框和标注框的IOU评估，IOU大于某个阈值判断为检测准确。这里检测框和标注框不同于一般的通用目标检测框，是采用多边形进行表示。检测准确率：正确的检测框个数在全部检测框的占比，主要是判断检测指标。检测召回率：正确的检测框个数在全部标注框的占比，主要是判断漏检的指标。
（2）识别阶段： 字符识别准确率，即正确识别的文本行占标注的文本行数量的比例，只有整行文本识别对才算正确识别。
（3）端到端统计： 端对端召回率：准确检测并正确识别文本行在全部标注文本行的占比； 端到端准确率：准确检测并正确识别文本行在 检测到的文本行数量 的占比； 准确检测的标准是检测框与标注框的IOU大于某个阈值，正确识别的的检测框中的文本与标注的文本相同。
1.5 应用场景 在日常生活中，文字内容无处不在，根据拍摄的内容，自动分析图像中的文字信息已经成为人们的广泛诉求。而通过深度学习技术，可以自动的定位文字区域，并且学习包含丰富语义信息的特征，识别出图像中的文字内容。当前这一技术已经广泛应用于金融、交通等各行各业中。
通用场景：办公文档、广告图、表格、手写数字、自然场景图等；卡证：身份证、银行卡、营业执照、名片等；汽车：车牌、驾驶证、合格证等；财务票据：火车票、飞机票、银行支票等；医疗票据：医疗发票、病例首页等；… 1.6 OCR面临的挑战 对应到OCR技术实现问题上，则一般面临仿射变换、尺度问题、光照不足、拍摄模糊等技术难点； 另外OCR应用常对接海量数据，因此要求数据能够得到实时处理；并且OCR应用常部署在移动端或嵌入式硬件，而端侧的存储空间和计算能力有限，因此对OCR模型的大小和预测速度有很高的要求。
2.OCR检测方法 2.1 CTPN CTPN(Connectionist Text Proposal Network)[1]是目标检测算法Faster R-CNN 的改进算法，用于文字检测。CTPN根据文本区域的特点做了专门的优化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d802b7df691bcea21b2e1df348e1da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bbdf9ac020c6186d26a2c5220c1d59/" rel="bookmark">
			《Java 基础篇》之终止线程的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、正常运行结束
二、使用退出标志退出线程
三、interrupt[ɪntəˈrʌpt]方法结束线程
四、stop()方法终止线程（不安全）
五、线程相关
5.1 sleep()和wait()区别
5.2 start()和run()的区别
5.3 Java后台线程(守护线程
一、正常运行结束 所谓正常运行结束，就是程序正常运行结束，线程自动结束
public class ThreadTest extends Thread { public void run() { //do something } } 二、使用退出标志退出线程 一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。他们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志位true或false来控制while循环是否退出，下面放代码：
public class ThreadTest extends Thread { public volatile boolean exit = false; public void run() { while (!exit){ //do something } } } 三、interrupt[ɪntəˈrʌpt]方法结束线程 使用interrupt()方法来中断线程是分两种情况的：
线程处于阻塞状态：如使用了sleep()，同步锁的wait()，socket中的receiver()，accept()等方法时，会使线程处于阻塞状态。当调用线程interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出此异常，通过代码可以捕获此异常，然后跳出循环状态，从而让我们有机会结束这个线程的执行。并不是只要调用interrupt()方法，线程就会结束，实际上是不正确的，一定要先捕获InterruptException异常之后通过break来跳出循环，才能正常结束run()方法。线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会为true，和使用自定义的标志来控制循环是一样的道理 public class ThreadTest extends Thread { public void run() { while(!isInterrupted()) { try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bbdf9ac020c6186d26a2c5220c1d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8e13ff4feeeee29ae4535127f857e0/" rel="bookmark">
			MySQL错误代码：1045
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录mysql_1045错误 【报错原因】密码错误
【解决方案】重置密码
（1）找到 mysql 配置文件
linux：/etc/my.cnf （可通过 whereis my 命令查找）
windows：my.ini （在安装目录下查找）
（2）修改 mysql 配置文件
在 [mysqld] 后添加 “skip-grant-tables” ，用来跳过密码验证
（3）保存
（4）重启 mysql
# linux /etc/init.d/mysql restart # 或 /etc/init.d/mysqld restart # windows：在服务里重新启动 MySQL 服务 （5）终端输入 mysql -u root -p 然后回车，当需要输入密码时，直接按enter键，便可免密登录数据库
（6）修改用户密码
# 进入 mysql 数据库 mysql&gt; use mysql; # 修改用户密码 mysql&gt; update user set password='password' where user='username'; # 刷新权限 mysql&gt; flush privileges; # 退出 mysql&gt; quit; 注意：如果在执行update操作时报错ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement，则先执行 flush privileges 命令，再执行update操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8e13ff4feeeee29ae4535127f857e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08d183f004fb5192b13eaad5ca641ad/" rel="bookmark">
			基于python实现Web自动化测试（selenium）、API自动化测试(requests)&amp;附学习视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 web自动化API测试1.什么是接口测试？2.内外部接口3.fiddler抓包工具4.Python实现接口测试4.1简单看一下测试文档4.2Requsets库发送http请求4.3检查http响应4.4三种请求消息体格式: XML,urlencode,JSON, 5.三种鉴权机制（cookie,session,token）5.1session机制5.2python实现session Pytest测试框架下常用函数1.yield2.package下的_init_.py3.装饰器(语法糖)-就是函数4.with语句：用于对象上下文的管理 另一篇文章：自动化测试框架（pytest）&amp;附学习视频
web自动化 学习视频，学习文档-白月黑羽
说明：
1紧跟着写的不加/,不加空格-表示同一级别信息，加空格表示后代
2.css定位tag,id,class时分别有不同的标识，其他属性都要加[]进行搜索，
Xpath所有属性都要都加【】,tag不用
3. css在使用tag，id，class定位时可以不写全信息，其他要写全
4.//用在xpath 空格用在css
5.xpath 写属性时，前面一定要加标签，或者是* //*[@id=‘west’]&gt;
6. //div/button[1] xpath的1就是list的0
API测试 1.什么是接口测试？ 对软件系统消息交互接口的测试，叫接口测试。链接
SMS系统前端 和 后端服务器之间是消息交互接口，2.使用美团订餐， 美团APP和美团服务器之间， 也是消息交互的。HTTP协议的特点是，客户端发出一个HTTP请求给 服务端，服务端就返回一个HTTP响应。好像程序的API调用。API接口请求消息，通常都需要 服务端程序进行 一番处理，比如：对请求的权限检查，从数据库中读出数据，进行信息过滤和 格式转换，最后在HTTP响应中返回给客户端。为什么 获取网页、图片这些 HTTP消息 通常不叫 API 接口消息呢？
答：网页、图片、css 这些资源，都是 静态资源 ， 就是一个个文件存储在服务器上的，获取这些信息，服务端直接读取文件，返回给客户端即可，无需特别的数据处理。基于 HTTP 的接口测试工具， 常见的 有 Postman、Jmeter等，这些工具核心功能都是类似，都是用来构建HTTP请求消息，并且解析收到的HTTP响应消息， 用户来判断是否符合预期，也完全python+requsets库实现自己开发测试工具，进行测试。web测试，测试的是整个系统（前段+后端），接口测试就是前后端之前的消息交互 2.内外部接口 内部接口： 产品（也就是被测系统） 内部子系统之间 的接口。
外部接口：产品（也就是被测系统）和 另外的系统交互的接口。
3.fiddler抓包工具 浏览器，F12可以查看http请求消息，http响应消息。
Requests 库 是用来发送HTTP请求，接收HTTP响应的一个Python库。
当软件运行时，发送的http请求会经过fiddler，关闭软件，恢复正常
4.Python实现接口测试 4.1简单看一下测试文档 根据下面的这种测试接口文档的要求，我们利用requests库进行http的请求，看服务器是否返回我们的需求。
大量工作时，建立一个package, 将相应方法封装到类中。
4.2Requsets库发送http请求 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08d183f004fb5192b13eaad5ca641ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d8d550686bc3371bb0218eda57a0b0/" rel="bookmark">
			linux网络配通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux网络配置：
vim /etc/sysconfig/network-scripts/ifcfg-ens33 ONBOOT="yes"
DNS=8.8.8.8
IPADDR=192.168.118.90
NETMASK=255.255.255.0
GATEWAY=192.168.118.2
BOOTPROTO="static"
vim /etc/resolv.conf
nameserver 8.8.8.8
systemctl restart network
ping baidu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da48c378ab16c2ee47fcb28ef79d709/" rel="bookmark">
			【python】—— python的基本介绍并附安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
今天，我将给大家讲解关于python的基本知识，让大家对其有个基本的认识并且附上相应的安装教程以供大家参考。接下来，我们正式进入今天的文章！！！
目录
前言
（一）Python 背景知识
（二）Python 都能干啥?
（三）Python的优缺点
（四）Python 的前景(钱景)咋样?
（五）Python的安装和运行
Windows安装
1、安装 Python
2、安装 PyCharm
Linux安装
总结
前言 编程语言大体可以分成三个大类
机器语言汇编语言高级语言 💨 其中机器语言和汇编语言都是更贴近计算机的, 人类理解起来并不容易. 💨 因此目前程序员使用的编程语言主要是高级语言.
高级语言的种类有很多很多. 以下列出的都是实际开发中常用的编程语言. 💨 可以看到, Python 在这个走势中是名列前茅的. 因此，除了我们一直学习的C++之外，额外的对其他语言的学习（python）进行相关的学习将极大的提高以后我们在竞争岗位时候的优势。 （一）Python 背景知识 首先给大家明确一点：Python是一种高级编程语言，是一门简单易学的语言，具有优雅、明确、简洁的语法和动态类型系统，且具有丰富的类库和第三方模块，被广泛应用于Web开发、数据分析、人工智能等领域。
【由来】
Python由Guido van Rossum在1989年圣诞节期间创建，最初是为了解决ABC语言的一些问题而设计的；Guido将Python命名为Python（大蟒蛇）来表达对Monty Python的喜爱之情。Python是一种开源软件，可以免费使用、修改和分发。第一个正式版本发布于 1991 年.（1991 年是一个神奇的年份. Python, 万维网, Linux, Vim, Qt, 第一台笔记本电脑, 都诞生于 1991 年） （二）Python 都能干啥? 经历了多年的发展, Python 目前是一个应用场景非常广泛的编程语言.
Python可应用于各种领域：
科学计算&amp;数据分析：Python拥有众多的科学计算库和数据分析库，如NumPy、Pandas、Matplotlib等，在数据建模和分析方面表现优异。Web 开发(搭建网站)：Python 可以通过Django、Flask等框架用于Web应用程序的开发。这些框架提供了丰富的功能和易于使用的工具，简化了Web开发的流程。自动化运维 人工智能：Python在机器学习和人工智能领域也广泛应用，如TensorFlow、Keras等库被广泛应用于图像、音频和自然语言处理任务。爬虫程序 自动化测试 （三）Python的优缺点 优点
简单易学：Python具有简单明了的语法和动态类型系统，易于上手。库丰富：Python拥有大量的类库和第三方模块，可以完成各种任务。可移植性：Python可以运行在不同的操作系统和硬件平台上，具有较强的可移植性。面向对象：Python支持多种编程范式，如面向对象、过程式、函数式等，可以进行复杂的程序设计。开源：Python是一种开源软件，具有庞大的用户群体和活跃的社区。 缺点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8da48c378ab16c2ee47fcb28ef79d709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8886fc57896628f26a33b661dd406ab7/" rel="bookmark">
			基于springboot&#43;vue技术的在线考试系统源码数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码看这里 https://download.csdn.net/download/2301_76965813/87881785
前台
学生登录：
如果没有账号，首先需要以学生的身份进行注册，即输入姓名、性别、密码以及班级，注册成功之后输入账户名和密码进行登录，进入考试系统。
首页：
在首页信息框中，将展示该学生用户的姓名以及所有完成的试卷信息，在下方展示试卷的类型，以及对该试卷的一个整体评价。在右上方，设置了考试模块与记录模块。
记录模块：
在记录模块中，学生用户在完成试卷之后进行提交将立即得到该试卷的成绩结果，并且所有完成的试卷信息将保存在记录模块中，便于后期的管理，以及对自身的学习水平有一个很好的认识。该结果将展示准确率以及得分情况，并且点击详情按钮，可以查看没得选项的正确答案的解析，使学生用户得到自我检查，提高水平。
考试模块：
在考试模块中，学生用户点击考试按钮，将出现授课教师发布的需要及时完成的试卷，点击下方的开始按钮，即可进入考试系统，在考试系统左边，显示考试开始时间以及结束时间，在学生完成所有题目之后点击提交，即可查看最终的得分，结果将以正确率以及具体得分数值显示。这大大的为试卷批改的工作人员带来了便利，同时方便方便了整体的管理操作。
后台：
管理员登录：
首先以管理员的身份输入账户名和密码进行登录。
首页：
在首页信息框中，将展示所有登录该在线考试系统用户数量、所完成的试题的总数量以及共录入的试卷的总套数。同时在下方，设置了公告信息栏模块，将在线考试系统的实时信息及时的通知所有用户。并且为了给所有的学生用户给予荣誉以及竞争性，设置了榜单模块功能，基于高分高准确率，对所有学生的做题情况以此标准进行排名，该模块将降序展示学生的排名、姓名、考试类型、总得分以及以1为满点给出点。
学生管理：
在学生管理中，可实现批量录入学生信息，查看学生信息功能。用户填写完个人信息，即姓名、账号、性别、邮箱、密码以及所在班级，管理员可以查看每个用户的具体信息状态，并且可对其信息进行重新编辑以及删除操作，可点击编辑信息按钮，填入相应的信息即可修改一条用户信息，然后点击确认即可完成，并且还有选择显示密码。
教师管理：
在教师管理功能中，可实现查询教师信息、查询教师所带课程。在该列表中可查看教师用户的所有信息，包括姓名、账号、邮箱、密码，更重要的是，将该用户的所具有的权限设置了类型划分，即作为管理员与普通，对于不同身份所赋予的权限功能不同。当发现需要修改的信息时，管理员可以对用户的信息进行编辑或者删除操作。
班级管理：
在班级管理中，主要以教师用户作为班级划分的对象，在整个列表中，将显示班级名，即专业名称，班主任姓名，通过该列表可以有效且方便的查询每个老师所在的班级，这样可对该课程信息进行更好的管理。同时，管理员也可以进行编辑和删除功能，点击班级添加按钮就可以对其进行添加。
试题管理：
在试题管理模块中，可实现添加考试信息、考试信息存档功能。在该信息列表中，将展示试题的所有题型，试题的知识类型，具体的题目以及所有参考选项的具体内容，并在后一栏给出正确的参考答案，同时，这也给予了管理员的编辑与删除的功能。在列表信息的上方，设置了试题添加模块，以及可根据试题知识类型的名称进行筛选查看，为后续的编辑与删除的管理操作给予了很大的便利。
试卷管理：
在试卷管理中，主要以试卷作为划分的对象，在整个列表中，会展示所有题型的得分情况。包含单选题、多项题以及判断题得分情况。同时，管理员也可以对该课程信息进行编辑和删除操作，在上方点击班级添加按钮可以对其进行添加功能并且可以进一步对试题进行管理，即对所有的试题可通过人工或者随机组成一套试卷，可通过输入试题科目类型以及试题的数量进行试卷生成。
考试管理：
在考试管理中，以管理员的身份可以增加考试信息，点击添加按钮，会以模态框的形式展示给用户输入的表单数据，用户输入相应的数据，即试题类型、开始考试时间以及结束时间，便可以添加成功。同时，也可根据试卷的完成情况显示目前的试卷状态，管理员由权对其进行删除操作。
源码看这里 https://download.csdn.net/download/2301_76965813/87881785
记录管理：
在记录模块中，学生用户在完成试卷之后进行提交将立即得到该试卷的成绩结果，并且所有完成的试卷信息将保存在记录模块中，便于后期的管理，以及对自身的学习水平有一个很好的认识。该结果将展示准确率以及得分情况，管理员可以对其数据信息进行删除以及添加操作。
在学生管理中，可实现批量录入学生信息，查看学生信息功能。用户填写完个人信息，即姓名、账号、性别、邮箱、密码以及所在班级，管理员可以查看每个用户的具体信息状态，并且可对其信息进行重新编辑以及删除操作，可点击编辑信息按钮，填入相应的信息即可修改一条用户信息，然后点击确认即可完成，并且还有选择显示密码。
图6.2.1.3a 用户列表
图6.2.1.3b 信息修改
在教师管理功能中，可实现查询教师信息、查询教师所带课程。在该列表中可查看教师用户的所有信息，包括姓名、账号、邮箱、密码，更重要的是，将该用户的所具有的权限设置了类型划分，即作为管理员与普通，对于不同身份所赋予的权限功能不同。当发现需要修改的信息时，用户管理员可以进行用户信息进行编辑或者删除操作。 在班级管理中，主要以教师用户作为班级划分的对象，在整个列表中，将显示班级名，即专业名称，班主任姓名，通过该列表可以有效且方便的查询每个老师所在的班级，这样可对该课程信息进行更好的管理。同时，管理员也可以进行编辑和删除功能，点击班级添加按钮就可以对其进行添加。
在试题管理模块中，可实现添加考试信息、考试信息存档功能。在该信息列表中，将展示试题的所有题型，试题的知识类型，具体的题目以及所有参考选项的具体内容，并在后一栏给出正确的参考答案，同时，这也给予了管理员的编辑与删除的功能。在列表信息的上方，设置了试题添加模块，以及可根据试题知识类型的名称进行筛选查看，为后续的编辑与删除的管理操作给予了很大的便利。 在试卷管理中，主要以试卷作为划分的对象，在整个列表中，会展示所有题型的得分情况。包含单选题、多项题以及判断题得分情况。同时，管理员也可以对该课程信息进行编辑和删除操作，在上方点击班级添加按钮可以对其进行添加功能并且可以进一步对试题进行管理，即对所有的试题可通过人工或者随机组成一套试卷，可通过输入试题科目类型以及试题的数量进行试卷生成。 在考试管理中，以管理员的身份可以增加考试信息，点击添加按钮，会以模态框的形式展示给用户输入的表单数据，用户输入相应的数据，即试题类型、开始考试时间以及结束时间，便可以添加成功。同时，也可根据试卷的完成情况显示目前的试卷状态，管理员由权对其进行删除操作。 源码看这里 https://download.csdn.net/download/2301_76965813/87881785
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a598f6c7ad3345bfa028249e74833f/" rel="bookmark">
			CH573-07-ADC——RISC-V内核BLE MCU快速开发教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 ch573提供一个 12 位逐次逼近型模拟数字转换器 ADC，提供多达 12 个通道，CH573 支持 10 个外部信号源和 2 个内部信号源，CH571 仅支持前 6 个外部信号源和 2 个内部信号源，支持的引脚为： PA4（AIN0）、PA5（AIN1）、PA12（AIN2）、PA13（AIN3）、PA14（AIN4）、PA15（AIN5）、PB6（AIN9）、PB0（AIN8）、PA8（AIN12）、PA9（AIN13）
2. 新建工程 复制并粘贴“CH573_01_led”工程，并重命名为“CH573_07_ADC”。
3. ADC初始化与采集 1) 精简代码 将与串口无关的LED相关程序删除，如下所示：
2) 串口1初始化 复制上一讲的UART1初始化程序，初始化串口1，仅使用PRINT完成串口字符串发送。
GPIOA_SetBits(GPIO_Pin_9); GPIOA_ModeCfg(GPIO_Pin_8, GPIO_ModeIN_PU); GPIOA_ModeCfg(GPIO_Pin_9, GPIO_ModeOut_PP_5mA); UART1_DefInit(); PRINT("OK\r\n\r\n"); 3) ADC初始化（单通道） //ADC初始化 /* 单通道采样：选择ADC通道0做采样，对应 PA4引脚， 带数据校准功能 */ GPIOA_ModeCfg(GPIO_Pin_4, GPIO_ModeIN_Floating); ADC_ExtSingleChSampInit(SampleFreq_3_2, ADC_PGA_0);//3.2M 采样频率,无增益 RoughCalib_Value = ADC_DataCalib_Rough(); // 用于计算ADC内部偏差，记录到全局变量 RoughCalib_Value中 ADC_ChannelCfg(0); //设置ADC采样通道AIN0(PA4) 除了上述普通单通道方式，还支持中断单通道采样、DMA单通道采样、差分通道采样、TouchKey采样等，详细实现方法可以参考官方资料“\EVT\EXAM\ADC”下的工程文件。
4) ADC采样 首先定义ADC采样数据保存的缓冲区：
uint16_t adcBuff[40]; uint32_t adc_get=0; #define ADC_COUNT 20 //ADC连续采样次数 连续采样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a598f6c7ad3345bfa028249e74833f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1643d16bd049846fdcaae079c10c8a02/" rel="bookmark">
			Linux：samba服务 （smbd）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		smb服务器为centos7
使用的yum安装（如果不会搭建本地yum仓库可以查看） Linux：rpm查询安装 &amp;&amp; yum安装_鲍海超-GNUBHCkalitarro的博客-CSDN博客
samba 简介 samba 使用了
1.SMB 协议
Server Message Block，服务消息块
2.CIFS 协议
Common Internet File System，通用互联网文件系
samba有两项主程序分别是
smbd和nmbd。这两个守护进程在服务器启动到停止期间持续运行，功能各异。Smbd和nmbd使用的全部配置信息全都保存在smb.conf文件中。Smb.conf向smbd和nmbd两个守护进程说明输出什么以便共享，共享输出给谁及如何进行输出。
Samba提供了基于CIFS的四个服务
文件和打印服务、授权与被授权 ———— smbd提供 名称解析、浏览服务 ———— nmbd提供
smbd进程的作用是处理到来的SMB软件包，为使用该软件包的资源与Linux进行协商
nmbd进程使主机(或工作站)能浏览Linux服务器。
我们本章将smbd进程 用于文件传输 安装samba yum -y install samba
# 安装samba服务
安装完毕
systemctl start smb 启动smb
systemctl start nmb 启动nmb
systemctl enable smb 开机自启smb
systemctl enable nmb 开机自启nmb
将start 替换为 stop 就是关闭
将enable 替换为 disable 就是开机自动关闭
成功开启服务
netstat -anput | grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1643d16bd049846fdcaae079c10c8a02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c11f65254e5d9c62371abbe5fe7eb1b/" rel="bookmark">
			ES文档字段类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 Meta-Field （元字段） 元字段可以理解为每个文档都会有的字段。不是用户定义的。以下划线"_" 开头。
1、有些字段只是为了存储，如_source。它是原始JSON文档（也就是源数据的内容）他们会出现在文档检索的结果中， 却不能通过这个字段做检索。
2、有些字段是标识，如_id，_index等。
下面是关于元字段的介绍：
序号名称说明1_id 文档的唯一标识id2 _index 文档所属索引3 _type 文档所属类型4 _uid 在索引内唯一，由映射类型和id组成，在6.0版本已废弃5 _source 源JSON文档6 _size _source的字节数7
_all 所有字段一起创建的索引，在6.0版本已废弃8 _field_names 为文档非空字段名创建索引9 _ignored 为忽略字段创建索引10 _routing 文档到具体分片的路由11 _meta 应用相关元信息 1.2 Field（字段） 字段也就是属性，它是自定义的，可以指定类型。默认情况下，每一个字段都是被索引的（使用倒排）
1.2.1 字符串类型 类型描述string从ElasticSearch 5.x开始已废弃text用于全文索引，该类型的字段会被分词keyword不分词，只能通过精确值搜索，如果字段需要进行过滤、排序、聚合，设置keyword类型。 1.2.2 数值类型 类型描述整型byte、short、integer、long 尽可能选择范围小的数据类型，占用空间小，索引效率高浮点型double、float、half_float、scaled_float 1.2.3 布尔类型 类型描述booleantrue、false 1.2.4 日期类型 类型描述date日期类型表示格式可以是这种“2018-01-13” 或 “2018-01-13 12:10:30” 1.2.5 范围类型 类型描述integer_range整数的范围float_range单精度的范围long_range长整形的范围double_range双精度的范围date_range日期的范围ip_rangeip的范围 gt是大于，lt是小于，e是equals等于。
插入or更新文档|字段时，值写成json对象的形式：
"age_limit" : { "gte" : 20, "lte" : 40 } 1.2.6 二进制类型 二进制字段是指用base64来表示索引中存储的二进制数据，可用来存储二进制形式的数据，例如图片。默认情况下，该类型的字段只存储不索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c11f65254e5d9c62371abbe5fe7eb1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4638bea070324baf90e7eb0fcbd86e35/" rel="bookmark">
			实验五 二叉树的建立及遍历应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、【实验目的】
1、掌握二叉树的建立方法
2、掌握二叉树遍历的基本方法（先序、中序、后序）
3、掌握递归二叉树遍历算法的应用
二、【实验内容】
1.构造一棵二叉树,打印出先序遍历、中序遍历、后序遍历的遍历序列。
2.选择一种遍历方式计算该树中叶子结点的个数，并打印出叶子结点。
提示:
先根据给定的树，写出此树的扩展先序遍历序列，然后根据此遍历序列建立二叉树。
3.选作题:编写一个层序遍历算法，利用队列结构按层次（同一层自左至右）输出二叉树中所有的结点。
三、【实验源代码】
头文件 typedef struct LBinaryTreeNode { ElemType data; struct LBinaryTreeNode *lchild; struct LBinaryTreeNode *rchild; }LPBTreeNode; void Initiate(LPBTreeNode *p) /*初始化创建二叉树的头结点*/ { p=(LPBTreeNode *)malloc(sizeof(LPBTreeNode)); p-&gt;lchild =NULL; p-&gt;rchild=NULL; } LPBTreeNode *createbintree() { LPBTreeNode *pbnode; char ch; scanf("%c",&amp;ch); if(ch=='#')pbnode=NULL; else { pbnode=(LPBTreeNode *)malloc(sizeof(LPBTreeNode)); if(pbnode==NULL) { printf("out of space!\n"); return pbnode; } pbnode-&gt;data =ch; pbnode-&gt;lchild =createbintree(); pbnode-&gt;rchild =createbintree(); } return pbnode; } void preorder(LPBTreeNode *t) { if(t==NULL)return; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4638bea070324baf90e7eb0fcbd86e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b76bd7412b3b9a25f3a5a49a5f2f35/" rel="bookmark">
			【C语言】关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、const1、修饰局部变量2、修饰全局变量3、常量指针和指针常量（1）const修饰指针（常量指针）（2）const修饰常量（指针常量）（3）const既修饰指针又修饰常量 4、修饰函数形参5、修饰函数返回值 二、volatile1、一句话总结功能2、编译器优化是什么？3、被优化后会带来什么问题？4、什么情况下会导致a的值突然发生变化？5、用volatile关键字解决上述问题 三、static1、static修饰局部变量2、static修饰全局变量或者函数 三、答疑1、define为什么不是C语言关键字？2、特别说明，关于存储类型和特征修饰3、定义常量的方式？4、C语言中变量和常量本质上的区别？ 参考资料 前言 传统的c语言（ANSI C）有32个关键字
1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：
2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：
下面将对部分关键字进行总结
一、const const就是常量的意思，用它修饰变量后，该变量就变成只读的了，也就是说const功能的本质就是降低数据操作权限。
特别注意：由于const修饰后变量的值就不可以修改了，因此需要在定义的时候就初始化完毕。
1、修饰局部变量 正常情况下修改局部变量的值：
#include &lt;stdio.h&gt; int main() { int n=5; printf("%d\n",n); n=10; printf("%d\n",n); return 0; } 5 10 如果加了const后，直接通过变量名修改就会出错：
#include &lt;stdio.h&gt; int main() { const int n=5; printf("%d\n",n); n=10; printf("%d\n",n); return 0; } 就没办法修改被const修饰的局部变量了吗？
也是有办法的：
#include&lt;stdio.h&gt; int main() { const int i = 10;//将i定义为局部变量 printf("before modication: i=%d\n",i); int *p = &amp;i; *p = 20; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b76bd7412b3b9a25f3a5a49a5f2f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac79b1da7dd2f4097233b2c07d9725c/" rel="bookmark">
			Lecture 21 Summarisation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Extractive: Single-DocExtractive: Multi-DocAbstractive: Single-DocEvaluationConclusion summarisation Distill the most important information from a text to produce shortened or abridged versionExamples outlines of a documentabstracts of a scientific articleheadlines of a news articlesnippets of search result what to summarise Single-document summarisation Input: a single documentOutput: summary that characterise the content Multi-document summarisation（find overlapping information） Input: multiple documentsOutput: summary that captures the gist(要点，主旨) of all documentsE.g. summarise a news event from multiple sources or perspectives how to summarise Extractive summarisation Summarise by selecting representative sentences from documents Abstractive summarisation Summarise the content in your own wordsSummaries will often be paraphrases of the original content goal of summarisation Generic summarisation Summary gives important information in the document(s) Query-focused summarisation Summary responds to a user query“Non-factoid” QAAnswer is much longer than factoid QA Extractive: Single-Doc summarisation system Content selection: select what sentences to extract from the document
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac79b1da7dd2f4097233b2c07d9725c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4312732e9366daba9108ec3c6fcfaa/" rel="bookmark">
			Lecture 20 Topic Modelling
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Topic ModellingA Brief History of Topic ModelsLDAEvaluationConclusion Topic Modelling makeingsense of text
English Wikipedia: 6M articlesTwitter: 500M tweets per dayNew York Times: 15M articlesarXiv: 1M articlesWhat can we do if we want to learn something about these document collections? questions
What are the less popular topics on Wikipedia?What are the big trends on Twitter in the past month?How do the social issues evolve over time in New York Times from 1900s to 2000s?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b4312732e9366daba9108ec3c6fcfaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495b0d67985753b8206a30c875ffa4e6/" rel="bookmark">
			Linux 信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 信号1.1 前言1.2 信号的位置1.3 接口1.3.1 sigset_t1.3.2 信号集操作接口1.3.3 signal1.3.4 sigprocmask1.3.5 sigpending 2. 信号的处理2.1 内核态和用户态2.2 信号的监测和处理 1. 信号 1.1 前言 在 Linux 中，信号是一种用于进程之间的通信机制，通常是异步的，也就是进程随时都可以收到信号，可以通过信号来通知进程发生了什么事，并且进程可以马上对这个信号做出反应和处理
在 Linux 中输入 kill -l可以得到信号的编号以及这些信号大概代表的是什么，常见的比如 9 号信号就是常见的强制杀死进程信号，以及 11 号就是段错误，具体点就是空指针，指针越界这些异常了，还有Ctrl + C 终止信号是 2 号信号。
(注意：信号是从 1 开始的，没有 0 号信号)
虽然总共有 64 个信号，但是前 32 个信号被称为核心信号，现在更关注的也是这前 32 个信号，用的也很频繁，通常用于程序的各种异常问题
1.2 信号的位置 操作系统随时都可能会给进程发送信号，而且还可能连续发送，进程收到信号之后，可能也不会马上处理，手头可能有优先级更高的事，甚至有可能直接忽略这个信号
先来了解一下信号的三种状态
① 递达（Delivery）
当进程收到信号之后，就直接执行该信号的处理方法，称为 信号递达，也就是 处理信号 ② 未决（Pending）
当信号到达的时候，进程不会马上处理这个信号，先放着，称为 未决，即暂时不处理 ③ 阻塞 （Block）
如果某个信号被设为阻塞，那么进程收到这个信号的时候，会将这个信号置为 未决 状态，并且阻塞如果不取消，这个信号会一直得不到处理 在 task_struct 中，可以理解成存储了关于 32 个信号对应的 3 个数据结构，这三结构就是 block，pending，delivery。并且 pending 和 block 可以理解为位图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495b0d67985753b8206a30c875ffa4e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e94c70e39d9249d52529ca2fb96e23b/" rel="bookmark">
			pinia搭配vue3(setup)的使用（保姆级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们为什么要使用Pinia pinia是Vue的一个状态管理库，跨组件通信的一种方式。可以让我们更加方便的组件通信。
Pinia 提供了一个更简单的 API，具有更少的规范，提供了 Composition-API 风格的 API，最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持。
话不多说，先来看一个简单的小demo 1.引入包：npm i pinia
2.在main.js里面配置：
import { createPinia } from 'pinia' app.use(createPinia()) 3.创建一个store文件夹，store里面再创建一个index.js（注意：一定要加这个return）
import { defineStore } from 'pinia'; export const useStore=defineStore('main',{ state:()=&gt;{ return{ num:10 } } }) export default useStore; 4.在页面中使用
import { useStore} from "../store/index" let store= useStore() console.log(store.num,2222); 看看效果,可以看到成功拿到了num的值
接下来就是取值和设置值，才能符合我们的需求 直接修改 store.num++; console.log(store.num,2222); 效果图可以看到num已经自增了
通过$patch进行修改 store.$patch({ num:store.num+1 }) console.log(store.num,2222); 效果图
$patch也可以修改多值 store.$patch(state =&gt; { state.c++; state.num++; }) getters:相当于计算属性,利用defineStore()中的getters属性定义，他们接收状态作为第一个参数一鼓励箭头函数使用 getters:{ cityVal:(state)=&gt;state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e94c70e39d9249d52529ca2fb96e23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ade8d9714f7400ccc0c0784f79ce4ba/" rel="bookmark">
			HTML制作导航栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;西安工商学院&lt;/title&gt;
&lt;style&gt;
* {border: 1px solid black;
padding: 0;
margin: 0;
}
.nav{
width: 1020px;
line-height: 70px;
margin-left: auto;
margin-right: auto;
}
.constaner {
height: 70px;
width: 100%;
background-color: #9a3032;
}
.nav&gt;div {
height: 70px;
text-align: center;
line-height: 70px;
float: left;
color: white;
margin-left: 10px;
padding-left: 10px;
padding-right: 10px;
position: relative;
}
.nav&gt;div:hover {
background-color: white;
color: #9a3032;
}
.nav&gt;div:hover&gt;div {
display: block;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ade8d9714f7400ccc0c0784f79ce4ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c583310d5c125c954fabd7205ac828c5/" rel="bookmark">
			最详细整理，HttpRunner接口自动化框架Hook机制详解（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 httprunner 4.x可以支持hook机制，在发送请求前做一些预处理或在请求完成后后置处理
setup_hooks ：主要用于处理接口的前置的准备工作，也可以对请求 request 参数签名加密等操作
teardown_hooks：主要用于后置清理工作，也可以对返回 respone 解密等操作
测试步骤添加hook
在项目根目录新建 debugtalk.py，名称一定要一样
# debugtalk.py def hook_up(): print("前置操作：setup!") def hook_down(): print("后置操作：teardown!") 只在第一个步骤添加 setup_hooks 和 teardown_hooks
test_h.yml
config: name: logincase variables: {} teststeps: - name: step1 login request: url: http://www.example.com method: GET setup_hooks: - ${hook_up()} teardown_hooks: - ${hook_down()} 执行用例
hrp run test_h.yml --gen-html-report 执行用例发现有报错
8:58AM ERR gRPC Call() failed error="rpc error: code = Unknown desc = Exception calling application: Function return type &lt;class 'NoneType'&gt; not supported!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c583310d5c125c954fabd7205ac828c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980c7c502a1886dda611e7adf37435fa/" rel="bookmark">
			数据分析基础项目一、餐厅订单数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		——————————————学习资料和数据来源于B站-Python-学习库——————————
一、初识数据需求 1.拿到数据，加载数据，初步认识数据并确定数据待清洗方向（空值列、重复值、格式不符等）
#明确文件类型，加载数据，看数据信息 #数据类型：xlsx data1= pd.read_excel("meal_order_detail.xlsx"，sheet_name='meal_order_detail1') data2= pd.read_excel("meal_order_detail.xlsx"，sheet_name='meal_order_detail2') data3= pd.read_excel("meal_order_detail.xlsx"，sheet_name='meal_order_detail3') data=pd.concat([data1,data2,data3],axis=0) #将每行数据合并 print(data.info())#读取数据信息，判断数据预处理方向（删除空值、重复值、修改数据格式） print（data.describe())#看数据整体分布情况，包括中位数，平均值之类 使用info初识数据信息，包括数据行列数、占内存大小、有无NA列等
运行结果表明数据存在空值列，需要删除空值列
二、数据清理 #删除空值列 data=data.dropna(axis=1) 三、数据分析及可视化 基于需求分析数据
2016整个8月所卖菜品的平均价格2016整个8月最受欢迎的菜（点的频率最高）点菜种类数较多的订单ID和该ID所点种类数总消费排名前十的订单ID平均消费排名前十的订单ID订餐数量与时间的关系（以hour计，以day计，以星期计）从消费情况看，判断大部分食客是偏向于聚餐高消费还是低消费 #1-8月份所有销售菜品的平均值，结果保留三位小数 avg_pandas = round(data['amounts'].mean(),3)#pandas自带的mean（）函数 avg_numpy = round(np.mean(data['amounts']),3)#numpy自带的mean（）函数，数据量大时建议使用，因为numpy底层由C++编写，运行效率高 #2-最受欢迎的菜品 dishes_f=data['dishes_name'].value_counts()[:10]#统计dishes_name列下不同菜品的个数，默认结果降序排列,切片取前十名 #可视化-绘制柱状图堆加折线图 dishes_f.plot(kind='bar',fontsize=8,color=['r','g','b'])#plt的plot函数绘图 dishes_f.plot(kind='line',color='r') for x,y in enumerate(dishes_f):#给图添加参数 plt.text(x,y+2,y,ha='center',fontsize=4)#设置数据标签 plt.show()#图展示出来 #3-点菜种类数较多的订单ID和该ID所点种类数
以订单ID分组，然后取出counts列，进行sum求和，求完排序，取前十
data_count=data.groupby(by='order_id')['counts'].sum().sort_values(ascending=False)
data_count[:10].plot(kind='bar',fontsize=8,color=['r','m','b','y','g'])
#4-总消费排名前十的订单ID
先计算每道菜的价格，放在total_amounts列
类似3-将counts改成total_total_amounts
data['total_amounts']=data['counts']*data['amounts'] data_total_amounts=data.groupby(by='order_id'）['total_amounts'].sum().sort_values(ascending=False) data_total_amounts[:10].plot(kind='bar',fontsize=8,color=['r','m','b','y','g']) #5-平均消费排名前十的订单ID
提取total_amounts列，counts列，并按order_id分组，分组后对每列求和
计算平均消费，放入avg_amounts列，排序，取前十
data['total_amounts']=data['counts']*data['amounts'] data_total_amounts=data[['order_id','total_amounts','counts']].groupby(by='order_id').sum()#分组取列时分组标准列要一起取出 data_total_amounts['avg_amounts']=data_total_amounts['total_amounts']/data_total_amounts['counts'] data_total_amounts['avg_amounts'].sort_values(ascending=False)[:10].plot(kind='bar',fontsize=8,color=['r','m','b','y','g']) #6-order_id个数与时间关系（时间维度）
提取hour，day，week（对日期做映射，提取其中的hour（用于datetime64格式））
data['hour']=data['place_order_time'].map(lambda x:x.hour) data['day']=data['place_order_time'].map(lambda x:x.day) data['week']=data['place_order_time'].map(lambda x:x.weekday()) data['status']=1#订单状态，用于计算订单数量 分组计算订单数量
data_hour=data.groupby(by='hour').count() data_day=data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980c7c502a1886dda611e7adf37435fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3f7f9c7120972b67914563be217538/" rel="bookmark">
			append方法和extend方法的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		extend方法和append方法是用于向列表（或其他可迭代对象）添加元素的方法，但它们有一些区别。
append方法：将传入的元素作为整个对象添加到列表的末尾。如果传入的是一个可迭代对象（如列表），则该可迭代对象作为一个整体被添加到列表中
extend方法：将传入的可迭代对象中的元素逐个添加到列表的末尾。如果传入的是一个列表，则列表中的每个元素都会被添加到原列表中。
总结：
append方法用于将整个对象作为一个元素添加到列表末尾。
extend方法用于将可迭代对象中的元素逐个添加到列表末尾。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f17402eef870cae7dabb227410590a4/" rel="bookmark">
			你值得拥有——流星雨下的告白（Python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 前言
2 霍金说移民外太空
3 浪漫的流星雨展示 4 Python代码 1 前言 我们先给个小故事，提一下大家兴趣；然后我给出论据，得出结论。最后再浪漫的流星雨表白代码奉上，还有我自创的一首诗。开始啦：
2 霍金说移民外太空 霍金说我们将来外星上生存；埃隆.马斯克也是这样想的。
我前面讲外星人来不到地球，这个道理已经很清楚。我再说几个数据，大家听听，我们且不要说到更远的外星，我们人类今天登上月球，把一个字航员送上月球，他在月球上待一分钟，要消耗地球一百万美元的资源才能在月球上待一分钟 。
我们说未来在火星上殖民，想想你在月球上一个人待一分钟，要消耗地球一百万美元的资源，你在火星上殖民几千人、几万人，你得把整个地球资源毁灭掉，都调到火星上去。然后你只把七十亿人调过去了几千、几万人，然后他在那可能死得更快，这根本不是出路，这怎么会成为出路呢?
我们再看，移居外星，离我们地球最近的另一个恒星系叫半人马座。半人马座，阿尔法星
也叫比邻星。大家注意，这都是恒星，比邻星距离太阳最近，有多近? 4.2光年，光以每秒钟三十万公里，走4.2年，就这我们还不知道比邻星的那个恒星旁边有没有行星。
就算有行星有没有宜居行星、类地行星。这我们还全然不知道。我们就假定那个地方有好了另一个地球，你按照今天人类火箭和卫星的最高速度，你单程从地球上飞到比邻星，需要一万五千年到三万年。
请注意我们文明史，文明有文字，以后的文明迄今才五千年，你单程飞到那个地方要一万五千年以上。我说过有没有行星都不知道。这个前途存在吗?根本不存在。就像外星人来不了我们这儿一样，我们也到不了任何外星存在。
我们今天连太阳系都没有走出去，没有在太阳系的任何一个行星上殖民，所以移民外星根本不是出路。
3 浪漫的流星雨展示 浪漫的流星雨
4 Python代码 def bgpic(self, picname=None): """Set background image or return name of current backgroundimage. Optional argument: picname -- a string, name of a gif-file or "nopic". If picname is a filename, set the corresponding image as background. If picname is "nopic", delete backgroundimage, if present.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f17402eef870cae7dabb227410590a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45af110c5c6b8457ed411782e364a4e/" rel="bookmark">
			深度学习系列10：人脸识别概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考https://zhuanlan.zhihu.com/p/76513217
1. 基础 这是一篇review的文章。下图是基本流程：
1.1 数据集 公开数据集的变迁如下：
1.2 前处理 人脸处理的变迁如下：
1.3 网络架构 主架构的变迁如下图：
1.4 目标函数 通常，人脸识别可分为人脸识别和人脸验证。前者将一个人脸分类为一个特定的标识（identification），而后者确定一对图片是否属于同一人（Verification）。
闭集（open-set）是测试图像在训练集中可能出现过；开集（close-set）是测试图像没有在训练集中出现过。开集人脸识别比闭集人脸识别需要更强的泛化能力。过拟合会降低性能。Open-set FR对特征要求的准则：在特定的度量空间内， 需要类内的最大距离小于类间的最小距离。
标签预测（最后一个全连接的层）就像一个线性分类器，深度学习的特征需要容易分离（separable） 。此时softmax损失能够直接解决分类问题。但对于人脸验证任务，深度学习的特征不仅需要separable，还需要判别性（discriminative） 。 可以泛化从而识别没有标签预测的未见类别。
下面两图分别从不同的角度对问题进行分类：
1.5 Metric 人脸识别的DCNNs有两个主要的研究方向：分类学习(softmax loss)、度量学习(triplet loss等)。
2014年的Deepface和DeepID标志着基于深度学习的FR诞生，用的是Softmax loss（多分类问题，交叉熵损失）。多分类问题只具有可分离性(separable)，即将类间分离，而没有判别性(discriminative)，即不能类内聚合。而人脸识别需要有可分离性+判别性，可以泛化到对未知人脸的同类与不同类的分类，所以有了后面的损失函数。
2015年之后，基于欧氏距离的损失在损失函数中一直扮演着重要的角色，如对比损失（Contrastive loss）、三元组损失（Triplet loss）、中心损失（Center loss）。
Contrastive loss 最初源于Yann LeCun于2006年发表的 Dimensionality Reduction by Learning an Invariant Mapping，该损失函数原本主要是用于降维中，即本来相似的样本，在经过降维（特征提取）后，两个样本仍旧相似；而原本不相似的样本，在经过降维后，两个样本仍旧不相似。同样，该损失函数也可以很好的表达成对样本的匹配程度。对比损失，需要用成对样本X1和X2来训练，还需要标注Y标签是否相似。公式如下：
梯度计算公式如下，非常像受力模型，最后形成了在空间中的一种平衡状态。
三元组损失（Triplet Loss）源于google在2015发表的 FaceNet: A Unified Embedding for Face Recognition and Clustering，伴随FaceNet。三元组损失要求最小化锚点和具有相同的身份的正例之间的距离，并最大化锚点和不同身份的负例之间的距离。目标是让相同标签的两个示例使其嵌入在嵌入空间中靠近在一起，不同标签的两个示例的嵌入距离要很远，但不希望推动每个标签的训练嵌入到非常小的簇中。 唯一的要求是给出同一类的两个正例和一个负例，负例应该比正例的距离至少远margin。 这与SVM中使用的margin非常相似，这里希望每个类的簇由margin分隔。
损失函数如下： Facenet论文中采用了随机的semi-hard negative构建triplet进行训练。2017的《In Defense of the Triplet Loss for Person Re-Identification》提出batch hard的表现最好，即对于每一个anchor，选择hardest positive(距离anchor最远的positive example) 和 hardest negative(距离anchor最近的negative example)。假设一个batch的数据包含P*K张人脸，P个人，每人K张图片，则产生PK个triplet，这些triplet是最难分的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45af110c5c6b8457ed411782e364a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d554a69fa22f9f4aef9196d4b06a5d9/" rel="bookmark">
			RSAC2023：ITDR成为下一代身份安全平台的关键能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字化转型、云迁移、远程办公推动了身份数量和类型的激增，传统的身份和访问管理解决方案在过去的IT架构中行之有效。但面临当下日益险峻的身份威胁时，进一步增强主动身份安全防御能力至关重要。
在今年的RSA Conference上，RSA Security首席执行官Rohit Ghai发表了题为“The Looming Identity Crisis”（迫在眉睫的身份危机）的开幕式演讲，拉开了本届大会关于身份安全的探讨序幕。
RSA Security首席执行官Rohit Ghai发表演讲
Rohit提出身份的脆弱性呈指数级增长，组织机构平均需要277天才能识别和控制数据泄露。为了使身份安全平台在防御方面表现更加出色，Rohit建议使用覆盖身份全生命周期管理的技术——身份威胁检测与响应（ITDR）。
从近五年创新沙盒看身份安全的创新趋势
创新沙盒大赛一直是RSAC备受瞩目的活动，展示了网络安全产业的热点技术和发展趋势。回顾大赛的入围企业情况，身份安全始终具有较高的行业关注度。在创新沙盒近五年（2019-2023）50家10强企业中，身份安全赛道占比14%。
创新沙盒近五年（2019-2023）十强入围身份安全企业
在2019年的创新沙盒大赛中，共有2家身份安全相关的企业入围，分别是：
– Arkose Labs（反欺诈）：结合全球遥感技术，在不影响用户体验和业务开展的情况下实现阻断欺诈行为。
– Cloudknox Security（身份与特权管理）：提供统一的混合云身份特权生命周期管理平台，以降低凭证丢失、误操作等造成的风险。
尽管网络安全资产管理公司Axonius在这一年摘得桂冠，但是2家身份安全领域的代表性企业收获了非常高的人气。在这之后，Arkose Labs获得由微软风险投资M12领投的2200万美元B轮融资，Cloudknox Security被微软收购。
2020年，虽然十强名单并无身份安全相关企业，但在一年后，身份安全赛道迅速复苏。
2021年，共有3家身份安全相关企业入围大赛十强。业务云化带来了许多安全挑战，这次入围的2家厂商虽然来自不同的细分领域，但都在尝试解决云端的身份安全问题。Axis Security主打零信任架构的云安全解决方案，它提供了一种更加简单和安全的无代理模式；Strata则通过创建一个编排和多云身份管理平台，解决了本地旧有应用与云服务、以及多云服务之间的身份碎片和孤岛问题。
另外一家厂商Deduce专注于通过身份情报网络解决业务欺诈问题。
到了2022年，零信任继续高速发展，从理念普及走向应用落地。入围十强的厂商BastionZero，其产品除了可提供对基础设施的零信任的远程访问外，还能够解决传统零信任架构面临的单点攻陷问题。
今年，在AI大潮席卷一切的形势下，仍然有1家身份相关企业入围十强。Astrix Securty主打云应用身份安全，核心竞争力在IaaS、PaaS与SaaS环境下的非人类身份攻击的保护。
纵观这五年RSAC创新沙盒大赛的发展，无论是零信任，还是云应用身份安全，都体现出业务场景的复杂化。一个完善的身份安全产品要和企业的业务场景相结合，才能做到全面提升身份安全的最终效益。
AI是身份安全的新机会吗？
近几个月，风靡全球的ChatGpt让人们看到，人工智能的发展有了质的飞跃，预示着无限可能，RSA首席执行官Rohit Ghai在RSAC2023上也特别提到了AI对于身份安全变革的重要意义。
Rohit指出，合规性、便利性、安全性是网络安全的三个主要特征。合规性在互联网时代处于第一位，而在移动和云时代，便利性更为重要。随着人工智能时代的到来，安全性成为核心目的，组织亟需一个比身份访问和管理平台更为先进的身份安全平台来验证身份。
Rohit在演讲中给出了关于下一代身份安全平台的构想，他建议下一代身份安全平台在数据层开放和集成，由ITDR和AI联合提供支持。AI能够使决策更加容易，实现大多数工作流程自动化；AI可以在几分钟内管理数百万次的身份权限变更。
至于对AI另一面的担忧，Rohit表示 “人类有责任确保AI保持良好状态”。AI技术不能完全替代人类在网络安全领域的作用，仍然需要人类的教育、监督和调节。
ITDR与其他安全产品的协同联动
2023年RSAC的主题是“Stronger Together”（强强联合）。身份安全产品往往是相辅相成的，组合在一起才能发挥出更大的价值。
RSA Security首席执行官在本次大会开幕式演讲中建议“身份安全平台加入ITDR技术”，Gartner在2023年9大顶级网络安全趋势中也曾指出，身份结构免疫系统可以通过身份威胁和检测响应（ITDR）保护结构中现有的和新的IAM组件。
作为国内最早落地ITDR技术的安全厂商，中安网星认为，ITDR能够有效补足IAM、零信任方案中的安全缺口。
IAM和零信任着重解决的是管理问题。它去管理谁可以访问这个业务系统，以及经过认证后，可以允许他访问哪一个业务系统。但在对抗更激烈的攻防场景下，实际的攻击者一定会试图绕过登录，绕过IAM，绕过二次验证，最终一定会获取到一个合法的用户身份实现在内网中横向移动。无论是IAM、动态认证还是更多基于身份管理的技术手段，实际上都已经失效。
而ITDR的重心更多的是放在安全这一侧，通过检测用户的真实身份，检测用户是否在盗用凭证发起攻击，从身份认证协议上去解析出攻击者的异常行为，进而实时检测出攻击事件。
因此，ITDR可以与IAM、零信任，从管理和安全两个角度对企业身份安全进行全面防护。
中安网星ITDR平台主要围绕identity及infrastructure为核心进行防护，涵盖主流身份基础设施及集权设施，围绕从攻击的事前加固、事中监测、事后阻断，产品的设计思路覆盖攻击者活动的全生命周期。
目前中安网星ITDR产品和解决方案已在金融、交通、能源、科技、消费等领域超100家大型企业落地应用，获得了客户的高度认可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fb8715eb69d85ab22131d9fbc35bf8/" rel="bookmark">
			MySQL优化五-高性能的8个索引策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正确创建和使用索引策略是实现高性能查询的基础，本文总结7个索引策略。
一、独立的列 独立的列是指索引不能是表达式的一部分，也不能是函数的参数。
mysql&gt;select id from actor where id+1 = 5; //错误 mysql&gt;select id from actor where id = 5-1; //正确 二、前缀索引和索引的特性 有时索引的很长的字符列，会让索引变得很慢且大，一个策略是使用模拟的哈希索引MySQL优化四-MySQL Innodb 自定义Hash索引_一个高效工作的家伙的博客-CSDN博客
但有时候这样做还不够，需使用前缀索引。
前缀索引是指，将字符列的前N位，作为索引列，而不是索引整个字符。比如
mysql&gt; alter table city_demo add KEY ( city(7) ) 前缀索引是一种能使用索引更小，更快的办法，但同时也有一个缺点，mysql无法用前缀索引做order by 和 group by ，也无法使用前缀索引做覆盖扫描。
同时还出现一个问题，选择前几位作为前缀索引，选太多则索引变大，选太少则选择性太低，同一索引的结果数据太多。
根据以上地市的例子，使用前3，前4，前5。。。前7位分别计算其选择性。
mysql&gt; select count(distinct left(city,3))/count(*) as sel3, count(distinct left(city,4))/count(*) as sel4, count(distinct left(city,5))/count(*) as sel5, count(distinct left(city,6))/count(*) as sel6, count(distinct left(city,7))/count(*) as sel7, from city_demo ; 当前缀长度到7的时候，再增加前缀长度，其选择性提升的幅度很小了。此时可以将长度为7，作为前缀索引的字符长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83fb8715eb69d85ab22131d9fbc35bf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aab26cf1f98368cbbfc49291d9d9387/" rel="bookmark">
			STM32CubeIDE 入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装教程 1.1 去ST 官网下载软件安装包：https://www.st.com/content/st_com/en.html
1.2软件安装：
2.创建工程 2.1 双击打开软件，选择工作区路径，不要出现中文名称
2.2 选择直接创建STM32 工程，我们这里以STM32F103C8 为例驱动LED 灯。
2.3 参数配置时钟源选择：
2.4 时钟树配置：
2.5 配置GPIO 口
LED1--PB6 ;LED2--PB7; LED3--PB8 ;LED4--PB9
2.6 GPIO 口基本参数配置，以PB6 为例，其她三个配置相同。
2.7 工程参数设置：
2.8 生成代码：
2.9 实现500ms 闪烁一次：
Alt+/ ：补全代码
CTRL+ “-”:缩小字体
CTRL+SHIFT+”+”:放大字体
CTRL+TAB: .c 和.h 文件切换
CTRL+/:注释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe4db0c5e8180390b1c44c71ae8d88d/" rel="bookmark">
			# Windows 专业版安装 Hyper-V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 专业版安装 Hyper-V 文章目录 Windows 专业版安装 Hyper-V检查要求硬件要求安装方式使用 PowerShell 启用 Hyper-V使用 CMD 和 DISM 启用 Hyper-V通过设置启用 Hyper-V 角色 创建虚拟机Hyper-v 管理器创建Hyper-V Quick Create 完整官网地址：Windows 10 上的 Hyper-V 简介 | Microsoft Learn
Hyper-V 让你可以在 Windows 上以虚拟机形式运行多个操作系统。
Hyper-V 可用于 64 位 Windows 10 专业版、企业版和教育版。 它无法用于家庭版。
检查要求 Windows 10 企业版、专业版或教育版具有二级地址转换 (SLAT) 的 64 位处理器。CPU 支持 VM 监视器模式扩展（Intel CPU 的 VT-c 技术）。最少 4 GB 内存。 请勿在 Windows 10 家庭版上安装 Hyper-V 角色。
打开设置”&gt;更新和安全”&gt;激活”，从 Windows 10 家庭版升级到 Windows 10 专业版。 硬件要求 虽然本文档未提供兼容 Hyper-V 的硬件完整列表，但需要具备以下各项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe4db0c5e8180390b1c44c71ae8d88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a455871d0c97872c577f51f93e2017cf/" rel="bookmark">
			list列表删除元素的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		listname = [5,1,2,1,3,4]
###方法一：remove，需要注意remove只移除给定元素在列表中的第一个值
listname.remove(1)
print(listname)
输出：[5,2,1,3,4]
###方法二：pop，根据给定索引值删除列表中对应的值
listname.pop(0)
print(listname)
输出：[1,2,1,3,4]
###方法三：del，不仅可以根据索引值删除列表中对应的值，还可以删除列表中的一段
del listname[0]
print(listname)
输出：[1,2,1,3,4]
del listname[1:3]
print(listname)
输出：[5,1,3,4]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cfeb6535b55e0064e7d760e824742c4/" rel="bookmark">
			CentOS 7.6一键安装 nginx及生产跨域配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.运行一键安装命令 yum install -y make cmake gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel &amp;&amp; wget http://nginx.org/download/nginx-1.12.2.tar.gz &amp;&amp; tar zxvf nginx-1.12.2.tar.gz &amp;&amp; cd nginx-1.12.2 &amp;&amp; ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx
2.默认安装路径 /usr/local/nginx/sbin/nginx
3.启动 #启动 #1.直接启动 #进入nginx目录，执行启动命令 cd /usr/local/nginx/sbin ./nginx # 或者直接 /usr/local/nginx/sbin/nginx #2.指定配置文件方式启动 #进入nginx目录，执行启动命令 cd /usr/local/nginx/sbin ./nginx -c /usr/local/nginx/conf/nginx.conf #或者 /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 4.检查nginx配置文件 #进入nginx目录 cd /usr/local/nginx/sbin #检查配置文件是否有语法操作 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cfeb6535b55e0064e7d760e824742c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a599b67bd56e3fdf2fb3008521eda2/" rel="bookmark">
			Diverse Embedding Expansion Network and Low-Light Cross-Modality Benchmark for V-I Re-ID:如何有效利用生成嵌入？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目：Diverse Embedding Expansion Network and Low-Light Cross-Modality Benchmark for Visible-Infrared Person Re-identification （多种嵌入扩展网络和低光交叉模态的可见-红外行人重识别）研究背景论文分析网络框架1、Diverse Embedding Expansion Module（多种嵌入扩展模块）2、Center-Guided Pair Mining Loss（中心引导对挖掘损失）3、Multistage Feature Aggregation Block（多级特征聚合块）4、Multi-Loss Optimization（多重损失优化） 实验 题目：Diverse Embedding Expansion Network and Low-Light Cross-Modality Benchmark for Visible-Infrared Person Re-identification （多种嵌入扩展网络和低光交叉模态的可见-红外行人重识别） 期刊合集：最近五年，包含顶刊，顶会，学报&gt;&gt;网址
文章来源：CVPR 2023
官方代码：GitHub
研究背景 VIS 和 IR 图像之间存在额外的跨模态差异是跨模态行人重识别的巨大挑战。作者系统分析了以往研究，并总结相关的研究方法：第一，特征级方法，思路： 将 VIS 和 IR 特征投影到一个共同的嵌入空间中，最小化模态差异。出现的问题： 由于模态差异较大，难以将跨模态图像直接投影到公共特征空间中。第二，图像级方法，思路： 通过使用Gans网络生成相反图像来减少模态差异。出现的问题： 缺乏 VIS-IR 图像对，生成的跨模态图像通常伴随着一些噪声。
论文分析 网络框架 多样性嵌入的网络模型（DEMN），使用双流的 ResNet-50 网络，将 VIS-IR 特征输入到所提出的多元嵌入扩展(DEE)模块中，以生成更多嵌入，之后，使用了中心引导对挖掘(CPM)损失，使生成的嵌入尽可能多样化，以学习信息特征表示。
1、Diverse Embedding Expansion Module（多种嵌入扩展模块） 提出的DEE模块采用多分支卷积生成结构，生成更多的嵌入，以缓解训练数据不足的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a599b67bd56e3fdf2fb3008521eda2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a7652a86c74cc694c5ac43ac4693201/" rel="bookmark">
			Java自带常用工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Objects：专为操作Java对象而生的工具类 1.对象判空
Objects 的 isNull 方法用于判断对象是否为空，而 nonNull 方法判断对象是否不为空。
示例代码如下:
import java.util.Objects; /** * @author qinxun * @date 2023-06-08 * @Descripion: Objects工具测试 */ public class ObjectTest { public static void main(String[] args) { String name = null; // 输出true System.out.println(Objects.isNull(name)); // 输出false System.out.println(Objects.nonNull(name)); } } 2.判断两个对象是否相等
我们经常需要判断两个对象是否相等，Objects 给我们提供了 equals 方法。
示例代码如下:
import java.util.Objects; /** * @author qinxun * @date 2023-06-08 * @Descripion: Objects工具测试 */ public class ObjectTest { public static void main(String[] args) { String name1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a7652a86c74cc694c5ac43ac4693201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176ce15f4fb848a810e65234cf94d7b2/" rel="bookmark">
			基于springboot的大学外卖系统源码数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码资源在这里 https://download.csdn.net/download/2301_76965813/87881744
1 系统分析 1.1 需求分析 该系统的开发，主要是用在了各个订餐网站的系统，用户可以通过网站进行外卖订餐的信息挂了，并能够对客户进行外卖菜品的订单提交等。该系统也是一个通用的管理系统。
系统初步定为采用BS架构的模式开发，分为三个权限，每个权限都有各自管理的功能，根据功能和需求的调研和分析，我得出结论，需要管理员权限实现对系统的整体的管理，工作人员用户可以对订单信息进行管理，也能够对订餐的信息进行统计，员工也是本系统的一个重要的用户，还可以实现菜品的查看等，客户功能实现了对客户的基本信息情况进行管理，也能够对菜品进行查看，并且可以选择在线进行订餐。
本人通过在企业的实习和需求调研，了解到外卖系统的订餐管理后台的一些功能需求，根据需要进行设计，进行系统的设计开发。主要功能如下所示：
1.管理员： 管理员是系统的一个重要的功能，通过管理员就能够实现员工的管理，客户的管理以及实现了对餐品信息的管理，能够对外卖菜品，菜品的类别进行管理。
2.员工： 员工是本系统的一个重要的用户，员工可以实现对自己信息进行修改，也能够对订单信息进行管理，并且可以实现对订餐信息的统计分析，统计订餐金额等。
3.客户： 客户的管理，是本系统的一个重要的用户管理，客户管理能够实现菜品预订的管理，客户可以在网上进行菜品的预订，并且能够实现个人资料的修改。
1.2 性能需求 该系统在性能功能上应达到如下需求：
系统性能的需求，主要包括了网站的网站展示的速度和用户体验方面的性能需求。网站的响应速度是检验一个网站性能的准则，通过快速的响应，一方面体现了网站的性能的优秀性，另一方面增加了用户的体验，带动了用户的体验的兴趣，本系统的美观大气的界面，让员工提高了操作的兴趣，也提升了用户体验。
性能的另一方面主要是针对系统的数据库的管理进行性能的优化的，一个好的数据库可以让网站的数据的管理得到一个良好的保障，数据库的设计低耦合可以加快数据的读取等。
所以在性能需求的方面，主要是针对两个方面进行的，一个方面是网站响应速度，另一个方面是网站数据库的管理。数据库的管理，是本系统的重要的管理，由于外卖订餐的存储等的数据量比较大，针对外卖信息的存储比较频繁，所以专门有一个数据库管理员对数据库的信息进行管理使用和分配。
2 系统总体框架 2.1 模型结构 系统的架构采用了简单的BS架构的模式开发，采用了典型的后台的管理系统模式进行开发，通过后台管理员的管理以及相关的人员的操作，各个权限可以实现系统的无缝对接。能更好地区分各个权限的内容和对各个权限进行操作。
2.2 功能模块简介 图2.2.1列出系统的功能模块图：
图2.2.1系统结构图
工作流程为：
本系统，主要是根据外卖公司的需要，针对外卖公司的信息和业务的需求，可以实现外卖菜品的管理。管理员可以发布菜品，客户进行在线的预订，并且能够对某个时间段的菜品的预订情况进行统计，更好地了解菜品销售情况。
本系统没有太多的业务流，通过简单的业务的使用，就能够实现本系统的一个重要的工作模式。可以实现系统的单一模式的管理。
源码资源在这里 源码资源在这里 https://download.csdn.net/download/2301_76965813/87881744
4.1.2 主要数据表 本系统主要采用了mysql数据库进行数据库表结构的设计，根据系统的需求和调研，我们开发了关于项目的十四个表，具体的表的介绍如下：
表4.1.2.1 用户信息表
Table 4.1.2.1 allusers
数据库字段名称
类型
长度
说明
id
Int
4
自动增长字段，不允许空，主键
username
varchar
50
用户名
pwd
varchar
50
密码
cx
varchar
50
权限
addtime
timestamp
0
添加日期
表4.1.2.2 菜品类别记录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176ce15f4fb848a810e65234cf94d7b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732df175b8d1180292767dcad8df5aa5/" rel="bookmark">
			用OpenSSH 配置 SFTP 服务器 (OpenSSH for Windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 通过IIS配置了FTP服务器,无法满足公司IT的安全性要求,按理说FTP+SSL证书也是安全的,但是IT要求只能用SFTP,无力反抗则第一时间查csdn和github.于是乎找到了openSSH这一神器.其实win10 18H1之后和Windows Server 2019 是自带安装功能,这部分不再细说. 可参考微软官网
适用于 Windows 的 OpenSSH 概述 | Microsoft Learn
Installing SFTP/SSH Server on Windows using OpenSSH :: WinSCP
无奈手头这台服务器是Windows Server 2012,以64bit为例,所以只能手动按部就班进行安装,安装步骤记录如下:
网上的资源从来只说一半，花点时间整理一篇完整版，希望对各位有用。
第一步:github网站下载压缩包 https://github.com/PowerShell/Win32-OpenSSH/releases
以64为系统为例,选择OpenSSH-Win64.zip链接下载即可.如果没有github账户（我担心那一天被封了，论及时备份的重要性），也可到我的资源里面进行下载。https://download.csdn.net/download/ericwuhk/12821190
第二步:将压缩包解压至C:\Program Files\OpenSSH-Win64,并在此目录下执行cmd指令 1#控制台调用powershell-&gt;In an elevated Powershell console, run the following powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1 2#防火墙开端口22-&gt;Open the firewall for sshd.exe to allow inbound SSH connections New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22 Note: New-NetFirewallRule is for Windows 2012 and above servers only.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/732df175b8d1180292767dcad8df5aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c690373ed206a5dbe1b95f64decaad/" rel="bookmark">
			Linux 进程间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 匿名管道1.1 前言1.2 pipe1.3 底层原理1.4 总结 2. 命名管道2.1 前言2.2 mkfifo2.3 原理 3. 共享内存3.1 实现原理3.2 接口3.2.1 shmget3.2.2 ftok3.2.3 shmat3.2.4 shmdt3.2.5 shmctl 3.3 小试牛刀3.4 小结 1. 匿名管道 背景：Linux 2.6
所谓通信，就是让一方能够看到另一方发送的数据，也就是，两个进程间要通信，首先要让这两个进程能够访问同一份空间，而访问的空间的不同也就决定了通信方式的不同
1.1 前言 匿名管道，是一种半双工的通信机制。可以把管道想象成水管，而水在水管中的流动都是单向的，管道也一样
半双工：只允许数据在两个方向之间进行单向传输，同一时刻，不同方向的数据不能同时传输 并且匿名管道只能用于具有父子关系或者具有共享父进程的进程之间的通信。
1.2 pipe 先来认识创建匿名管道的接口 int pipe(int pipefd[2])
参数int pipefd[2] 是一个输入输出型参数，使用的时候，创建一个 int[2] 参入，当函数执行完成的时候，返回值不为 0 说明管道创建失败否则进程会在内核打开一个文件，然后int[2] 会被赋值，pipe[0] 表示该文件读端的文件描述符，pipe[1] 表示该文件写的端文件描述符。⭐下标 0 固定表示读端，下标 1 固定表示写端也就是说，该进程会打开一个文件，并且进程的文件描述符表中多个两个元素，下标分为是 pipe[0] 和 pipe[1] 使用的时候通常是用于父子进程间的通信，父进程创建完管道之后，创建子进程，这时候会发生子进程的拷贝，而子进程也会拷贝父进程的文件描述符表（Important）
所以父子间匿名管道通信的时候，只需要让一方关闭读端，另一方关闭写端，就可以实现进程的单向通信
放一张图片理解一下匿名管道的大致（来源：Bing 图片）
以下是简单的父子进程利用匿名管道通信的代码，
📃任务：子进程给父进程发送三次 “阿巴阿巴阿巴”
代码加了详细注释：
int main() { // 进程间通信 —— 匿名管道 // 场景：子进程一直给父进程发送 ： “阿巴阿巴阿巴” // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c690373ed206a5dbe1b95f64decaad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f4f048b0fdabe5aed9b7c73611df6d/" rel="bookmark">
			在vue3中使用富文本编辑wangEditor上传自定义图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		富文本编辑器wangEditor的安装和使用我就不在这里做介绍了，大家可以去官网进行查看。
wangeditor官网：https://www.wangeditor.com/
接下来，进入主题，上传本地图片到后端，后端返回图片地址，在插入编辑器中
const editorConfig = reactive({ MENU_CONF: { uploadImage: { // fieldName: 'file', // base64LimitSize: 10 * 1024 * 1024, // 10M 以下插入 base64 // server: '/api/common/uploadFile', // 自定义的接口地址 // headers: { // 'Content-Type': requestConfig.contentType, // 'Authorization': getToken() // }, // 跨域是否传递 cookie ，默认为 false withCredentials: true, // 超时时间，默认为 10 秒 timeout: 30 * 1000, // 30 秒 async customUpload(file, insertFn) { const form = new FormData() form.append('file', file) uploadImage(form).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f4f048b0fdabe5aed9b7c73611df6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b9e2afa88bdf1a3166f81480ebbc3e/" rel="bookmark">
			使用flex布局，el-table自适应失效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
el-table只能自适应变大，不能自适应变小
问题原因
el-table 组件的宽度是动态计算的，源码中resize事件绑定在 this.$el 上，flex容器下的width:100%会一直向上继承，直到flex容器下第一级子元素，但是当某个子元素的宽度出现固定值并且大于flex伸展的宽度的时候，那么容器就不会收缩，也就触发不了resize事件了。
解决方案一（推荐）
在右侧区域，即 flex：1；区域 添加 overflow-x：hidden 即可解决。（给表格的父元素加）
解决方法二
flex属性的容器设置相对定位
el-table外多包裹一层div，包裹的容器设置绝对定位及宽度，继承父级宽度
注意：这样会影响下面的元素
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82547f2796d760a48284152bf0dce1f1/" rel="bookmark">
			Linux系统的三种挂载方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器使用过程中，mount挂载几乎是最常用的一种操作了，今天就给大家介绍一下linux文件挂载相关介绍。 介绍： mount是Linux下的一个命令，它可以将分区挂载或挂接到Linux的一个文件夹下，从而将分区和该目录联系起来，当我们只要访问这个文件夹时，就相当于访问该分区了。
一、手动挂载 命令格式：
mount [-t vfstype] [-o options] device dir 1、-t vfstype 指定文件系统的类型，通常不必指定，mount 会自动选择正确的类型。
光盘或光盘镜像：iso9660
DOS fat16文件系统：msdos
Windows 9x fat32文件系统：vfat
Windows NT ntfs文件系统：ntfs
Mount Windows文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs
2、-o options 主要用来描述设备或档案的挂接方式。
loop：用来把一个文件当成硬盘分区挂接上系统
ro：采用只读方式挂接设备
rw：采用读写方式挂接设备
iocharset：指定访问文件系统所用字符集
3、device 要挂接(mount)的设备。
4、dir设备在系统上的挂接点(mount point)。
挂接光盘镜像文件 ---从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。
#cp /dev/cdrom /home/xiuxiu/mydisk.iso 或 #dd if=/dev/cdrom of=/home/xiuxiu/mydisk.iso 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/xiuxiu/mydisk.iso
---将文件和目录制作成光盘镜像文件，执行下面的命令，genisoimage和mkisofs是同一个命令，-r或-rational-rock表示使用Rock Ridge Extensions，并开放所有的文件读取权限，针对 UNIX系统的 ISO-9660文件系统，-J或-joliet表示使用Joliet格式的目录或者文件名称，微软公司自定义的光盘文件系统 ，也是ISO-9660 的一种扩展，-V &lt;光盘ID&gt;或-volid &lt;光盘ID&gt;表示指定光盘的卷册集ID
mkisofs -r -J -V mydisk -o /home/xiuxiu/mydisk.iso /home/xiuxiu/mydir 注：这条命令将/home/xiuxiu/mydir目录下所有的目录和文件制作成光盘镜像文件/home/xiuxiu/mydisk.iso，光盘卷标为：mydisk
---光盘镜像文件的挂接(mount)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82547f2796d760a48284152bf0dce1f1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/74/">«</a>
	<span class="pagination__item pagination__item--current">75/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/76/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>