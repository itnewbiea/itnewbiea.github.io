<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb37bf6a351858595022303d7a7bc9ae/" rel="bookmark">
			MATLAB多个子图 用一个 colorbar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% 多个子图使用同一个colorbar % [left bottom width height] ps42 = zeros(8,4); ps42(:,3) = 0.44;ps42(:,4) = 0.20; ps42([7 8],2) = 0.08;ps42([5 6],2) = 0.30;ps42([3 4],2) = 0.52;ps42([1 2],2) = 0.74; ps42([1 3 5 7],1) = 0.05;ps42([2 4 6 8],1) = 0.54; pscol = [0.2 0.95 0.6 0.02]; figure() subplot('position',ps42(1,:)) subplot('position',ps42(3,:)) subplot('position',ps42(5,:)) subplot('position',ps42(7,:)) subplot('position',ps42(2,:)) subplot('position',ps42(4,:)) subplot('position',ps42(6,:)) subplot('position',ps42(8,:)) h42 = colorbar('horiz'); % 设定子图8的colorbar为水平方向，若不设定，则默认colorbar方向为垂直方向 set(h42,'position',pscol) % 设定colorbar 到图的最上方 set(h42,'ticks',2.^(-5:1:3)) 注意： 我们的做法是把最后一个子图的colorbar作为所有子图的colorbar ，但是8个子图的colorbar它们的caxis的范围不一定完全相同，如子图1的范围为[-6,3] ,子图8的范围为[-5,4]，这时用子图8的colorbar表示所用子图的颜色是不合理的，因为有些数值超出了子图8的范围，这里的解决方法是 在绘图前获取每一个子图的范围，设定一个公共的caxis范围，并在每一张绘图命令后输入 caxis([colmin colmax])，这样做才能使所有子图的颜色有可比性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb37bf6a351858595022303d7a7bc9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7fab49280e786016408230afc966ff/" rel="bookmark">
			Web前端，CSS中的浮动、清除浮动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 持续总结输出中，今天分享的是Web前端，CSS中的浮动、清除浮动。浮动和清除浮动是我们常用的css样式。今天我们就来了解他们。
1、浮动的作用 早期的作用:图文环绕
现在的作用:网页布局
• 场景:让垂直布局的盒子变成水平布局，如:一个在左，一个在右
2、浮动的代码 属性：float 浮动 属性名效果left左浮动right右浮动 3、浮动的特点 浮动元素会脱离标准流(简称:脱标)，在标准流中不占位置
• 相当于从地面飘到了空中浮动元素比标准流高半个级别，可以覆盖标准流中的元素浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动浮动元素有特殊的显示效果
• 一行可以显示多个
• 可以设置宽高 注意点:
• 浮动的元素不能通过text-align:center或者margin:0 auto
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 浮动的标签 顶对齐 */ /* 浮动: 在一行排列, 宽高生效 -- 浮动后的标签具备行内块特点 */ .one { width: 100px; height: 100px; background-color: pink; float: left; margin-top: 50px; } .two { width: 200px; height: 200px; background-color: skyblue; float: left; /* 因为有浮动, 不能生效 - 盒子无法水平居中 */ margin: 0 auto; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7fab49280e786016408230afc966ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e420142d383d46aaa61cc82709c3fa5c/" rel="bookmark">
			Android studio开发常见错误集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Connection refused: connect
连接失败，连接被拒绝，这个一般是由于改了代理的原因导致的。但是你可能把代理改了之后也是编译不通过。
解决：File-&gt;Settings
先把这个No proxy勾上，然后去gradle目录下把gradle.properties文件删了然后重新build
Could not find com.android.tools.build :gradle: x.x.x
gradle插件与所需gradle版本不一致
可以直接在File-&gt;projectStructure-&gt;project 修改对应的版本号，也可以在文件里修改
gradle插件与所需gradle版本对照表我这截个图，如果过期了就去官网看
官网链接
R.id.xx的R报红
这个可能是你复制了其他人的代码并把他的包名路径都复制过来了，将包名路径改成自己的路径即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f3528772bb837c8c30cb03d68c1f8c/" rel="bookmark">
			视觉SLAM②--初识SLAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
2.0 本章主要内容
2.1 引子：小萝卜的例子
2.2 经典视觉SLAM框架
2.2.1 视觉里程计 2.2.2 后端优化 2.2.3 回环检测 2.2.4 建图 2.3 SLAM的数学问题描述 2.4 实践 编程基础
2.4.1 安装Linux操作系统
2.4.2 Hello Slam
2.4.3 使用cmake
2.4.4 使用库 SLAM是 Simultaneous Localization and Mapping 的缩写，中文译作“同时定位与地图构建”。它是指搭载特定传感器的主体，在没有环境先验信息的情况下，于运动过程中建立环境的模型，同时估计自己的运动。如果这里的传感器主要为相机，那就称为"视觉SLAM"。
2.0 本章主要内容 Ⅰ.理解一个视觉SLAM框架由哪几个模块组成，各模块的任务是什么。 Ⅱ.搭建编程环境,为开发和实验做准备。
Ⅲ.理解如何在Linux下编译并运行一个程序，如果程序出了问题，又该如何调试它。
Ⅳ.掌握cmake的基本使用方法。
2.1 引子：小萝卜的例子 假设我们组装一台叫做小萝卜的机器人，大概的样子如图所示
图2-1 一个简易机器人 1.这个机器人能干什么
自主运动能力：
自主运动能力是许多高级功能的前提。不管是扫地还是搬东西，首先要让它动起来。要移动就得有轮子和电机，所以我们在小萝卜的下方安装了轮子(足式机器人步态很复杂)。有了轮子，机器人就能够四处行动了，但不加规划和控制的话,小萝卜不知道行动的目标，就只能四处乱走，更糟糕的情况下会撞上墙造成损毁。而要规划和控制,首先需要感知周边的环境。为此，我们在它的脑袋上安装了一个相机。安装相机的主要动机，是考虑到这样一个机器人和人类非常相似——从画面上一眼就能看出。有眼睛、大脑和四肢的人类，能够在任意环境里轻松自在地行走、探索，我们觉得机器人也能够完成这件事。为了使小萝卜能够探索一个房间，它至少需要知道两件事:
Ⅰ．我在什么地方?——定位
Ⅱ．周围环境是什么样?——建图
2.定位与建图
“定位”和“建图”，可以看成感知的“内外之分”。作为一个“内外兼修”的小萝卜，一方面要明白自身的状态（即位置)，另一方面也要了解外在的环境（即地图)。当然，解决这两个问题的方法非常多。例如，我们可以在房间地板上铺设导引线,在墙壁上贴识别二维码,在桌子上放置无线电定位设备（这其实是现在很多仓储物流机器人的做法)。如果在室外，还可以在小萝卜脑袋上安装GPS信号接收器（像手机或汽车一样)。有了这些东西，定位问题是否就解决了呢?我们不妨把这些传感器分为两类
一类传感器是携带于机器人本体上的，例如机器人的轮式编码器、相机、激光传感器,等等。另一类是安装于环境中的，例如前面讲的导轨、二维码标志，等等。安装于环境中的传感设备,通常能够直接测量机器人的位置信息，简单有效地解决定位问题。然而，由于它们要求环境必须由人工布置,在一定程度上限制了机器人的使用范围。例如，室内环境往往没有GPS 一类传感器是携带于机器人本体上的，例如机器人的轮式编码器、相机、激光传感器，等等.另一类是安装于环境中的，例如前面讲的导轨、二维码标志，等等.安装于环境中的传感设备，通常能够直接测量机器人的位置信息，简单有效地解决定位问题.然而，由于它们要求环境必须由人工布置，在一定程度上限制了机器人的使用范围。例如，室内环境往往没有全球定位系统信号，绝大信号，绝大多数园区无法铺设导轨，这时该怎么定位呢? 多数园区无法铺设导轨，这时该怎么定位呢？
这类传感器约束了外部环境。只有在这些约束满足时，基于它们的定位方案才能工作。反之，当约束无法满足时，我们就无法进行定位。所以，虽然这类传感器简单可靠，但它们无法提供一个普遍的、通用的解决方案。相对地，那些携带于机器人本体上的传感器，比如激光传感器、相机、轮式编码器、惯性测量单元（Inertial Measurement Unit，IMU)等，它们测量的通常都是一些间接的物理量而不是直接的位置数据。例如，轮式编码器会测量轮子转动的角度,IMU测量运动的角速度和加速度，相机和激光传感器则读取外部环境的某种观测数据。我们只能通过一些间接的手段，从这些数据推算自己的位置。虽然听上去这是一种迂回战术，但更明显的好处是，它们没有对环境提出任何要求，从而使得这种定位方案可适用于未知环境。
3.相机的分类
按照工作方式的不同,相机可以分为单目(Monocular)相机、双目(Stereo）相机和深度（RGB-D)相机三大类。直观看来，单目相机只有一个摄像头，双目有两个，而 RGB-D的原理较复杂，除了能够采集到彩色图片，还能读出每个像素与相机之间的距离。深度相机通常携带多个摄像头,工作原理和普通相机不尽相同。此外，SLAM中还有全景相机、Event相机等特殊或新兴的种类。虽然偶尔能看到它们在SLAM 中的应用。
Ⅰ.单目相机
只使用一个摄像头进行SLAM的做法称为单目SLAM ( Monocular SLAM )。这种传感器结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f3528772bb837c8c30cb03d68c1f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2c72a2c887ff02e0fafa191014cdbf/" rel="bookmark">
			【深度学习知识点扫盲】病态、病态条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深度学习知识点扫盲】病态、病态条件 文章目录 【深度学习知识点扫盲】病态、病态条件花书内容1. 概念定义1.1 病态/ 良态问题1.2 适定/ 非适定问题 2.数学解释2.1 良态/病态矩阵2.2 机器学习和条件数2.3 病态的根源2.3.1 示例2.3.2 特征值和特征向量2.3.3 机器学习中的应用 参考资料 花书内容 先看看花书大致的内容如下：
关于病态，书中多次提及这个概念，实际上，在CV领域大部分问题都是非适定问题（ill-posed problem）。但是书中对其的解释却不是很直观。当（4.2）式的值很大的时候，一种比较有特点的网络就是这个样子：
对于这样的网络，训练中存在的问题是对于不同的权重参数，需要的学习率可能不同，对于平坦的误差曲面需要较大的学习率来加速收敛，而这个较大的学习率可能在错误曲面的峡谷区发散，此时单一学习率的方法不能很好地训练模型。
推荐一个优秀的博客。我这里对其内容进行一个大致的整理。
1. 概念定义 1.1 病态/ 良态问题 病态问题（ill-conditioned problem）：问题的解关于条件非常敏感。条件（或数据）中即使存在极微妙的噪声，也会对问题的解造成剧烈的变化。
反之，关于条件不敏感的问题，我们称之为良态问题（well-conditioned problem）。
显然，我们能把这两个概念拓展至病态/ 良态系统（算法），“条件”即系统的输入，“问题的解”即系统的输出。
举一些例子：
人体体温调控系统是良态的，因为体表温度微小的变化也只会带来微小的体温调控；汽车动力系统是良态的，因为微踩油门时，汽车动力也只会稍作改变。 再延伸至机器学习算法：
如果一个算法对噪声非常敏感，即病态的，那么其健壮性（robustness）也不佳（健壮性就是说系统抗扰动的能力）。如果一个算法是过拟合的，那么该算法一定是病态的。 1.2 适定/ 非适定问题 **适定问题（ill-posed problem）**的定义来源于1903年哈达玛（Hadamard）的演讲：一个问题是适定的，当其满足以下3个条件：
解存在；解是唯一的；解连续依赖于输入（解随着初始条件的改变而连续改变）（The solution depends continuously on the input）。 只要不满足其中一个条件，那么该问题就是非适定的（ill-posed）。
注意：（非）适定问题既可以是良态的，也可以是病态的。
2.数学解释 2.1 良态/病态矩阵 2.2 机器学习和条件数 2.3 病态的根源 既然已经定义了条件数，定义了什么是病态，什么是良态，我们不禁会想，引起病态的根源是什么，或者说什么样的矩阵具备病态特征。
当然，你可能会说，前面不是定义了条件数较大的矩阵属于病态矩阵吗，这不是多此一问吗？
过大的条件数会导致矩阵病态只是我们的结论，并不是根本的原因。最根本的原因在于矩阵的列之间的相关性过大。
2.3.1 示例 2.3.2 特征值和特征向量 可以看出，输入分别沿着两个特征向方向增加1%后，而特征向量ξ1、ξ2对应的特征值（λ1=1300）远大于特征向量ξ2对应的特征值（λ1=1.57）。
因此，当矩阵的特征值差异过大时，即使输入沿着较大特征值的方向有微小的改变，也会导致最终的输出结果的较大改变。 原因很简单，较大的特征值意味着对应特征方向上较大的自由度。
2.3.3 机器学习中的应用 参考资料 《深度学习》（花书）https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f2c72a2c887ff02e0fafa191014cdbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f4379bd08a8335aee90c0c9cd3fa27/" rel="bookmark">
			vue{{}} 拼接字符串和换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实用JavaScript一行代码 const Utils = { // 反转字符串 reverse = str =&gt; str.split('').reverse().join(''), // 是否是字符串 isString = (value)=&gt; Object.prototype.toString.call(value) === "[object String]", // 是否是布尔值 isBoolean = (value)=&gt; Object.prototype.toString.call(value) === "[object Boolean]", // 是否是数字 isNumber = (value)=&gt; Object.prototype.toString.call(value) === "[object Number]", // 是否是Underfined isUndefined = (value)=&gt; Object.prototype.toString.call(value) === "[object Undefined]", // 是否是null isNull = (value)=&gt; Object.prototype.toString.call(value) === "[object Null]", // 是否是NaN isNaN = (value)=&gt; Number.isNaN(value), // 是否是对象 isObject = (value)=&gt; Object.prototype.toString.call(value) === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f4379bd08a8335aee90c0c9cd3fa27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597bb5172c7c282531a8ce97c0989ab7/" rel="bookmark">
			smart-doc初体验-springboot生成自动文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		smart-doc初体验 一.为什么要引入smart-doc?二.对比swagger三.使用四.讨论1.设计先行模式2.代码先行 五.体验六.附录1.完整的配置项:2.官方地址: 一.为什么要引入smart-doc? 1.非侵入式生成接口文档
2.减少接口文档的手动更新麻烦&amp;保证了接口文档和代码的一致
3.随时可生成最新的接口文档
4.保持团队代码风格一致:smart-doc支持javadoc，必须按照这个才能生成有注释的接口文档
二.对比swagger 小结：
swagger
侵入式接口文档生成
每个接口及每个实体类都需要添加注解
配置复杂，需要添加依赖然后需要添加相关配置
编译后自动生成接口文档
需要启动后才能查看，如果配置了安全框架还需要开放相关接口
smart doc
非侵入式接口文档生成
需要按照java文档注释规范对接口及相关对象添加注释
编译文件后需要手动运行插件生成接口文档
配置简单，只需要引入插件，配置文档输出位置即可。相关更加复杂的配置根据需要自行配置。
无需启动项目，生成文档后可直接浏览
smart-doc主要是基于源代码和JAVADOC标注注释来生成文档，是在开发期或者是项目的编译期执行生成文档， 在最终在打包运行的jar内你是找不到smart-doc的依赖的，因此是完全不侵入项目运行期的， 也就不能像swagger一样项目启动时更新文档。
swagger主要原理是利用JAVA的注解和反射机制去生成文档。如果项目文档要比较清晰就必须使用大量的注解。 注解和业务代码强绑定，当然最终构建产出的部署包里也就必须包含swagger的依赖了。也因为swagger是利用反射 来生成文档，所以可以做到项目启动时更新文档
三.使用 1.引入jar包;
&lt;plugin&gt; &lt;groupId&gt;com.github.shalousun&lt;/groupId&gt; &lt;artifactId&gt;smart-doc-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt; &lt;configuration&gt; &lt;configFile&gt;./src/main/resources/smart-doc.json&lt;/configFile&gt; &lt;projectName&gt;Smart-Doc初体验&lt;/projectName&gt; &lt;/configuration&gt; &lt;/plugin&gt; 配置smart-doc.json { "serverUrl": "http://localhost:17150", "outPath": "src/main/resources/static/doc", "isStrict": false, "#####": "allInOne:true 此参数表示记录文档变更的记录", "createDebugPage": false, "packageFilters": "com.it.zqm.controller.*", "style":"xt256", "showAuthor":true, "inlineEnum": true, "revisionLogs": [{ "version": "文档版本号", "version": "1.0", "_revisionTime": "文档修订时间", "revisionTime": "2020-12-31 10:30"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/597bb5172c7c282531a8ce97c0989ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0af601220510ba017d556df1b2804b/" rel="bookmark">
			[CISCN2021 Quals]upload
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：unicode字符替代，二次渲染绕过，目录结构识别 upload.php，中限制了图片的大小，长宽，以及一些字母。
&lt;?php #Quals]upload if (!isset($_GET["ctf"])) { highlight_file(__FILE__); die(); } if(isset($_GET["ctf"])) $ctf = $_GET["ctf"]; if($ctf=="upload") { if ($_FILES['postedFile']['size'] &gt; 1024*512) { die("这么大个的东西你是想d我吗？"); } $imageinfo = getimagesize($_FILES['postedFile']['tmp_name']);#获取图片大小 if ($imageinfo === FALSE) { die("如果不能好好传图片的话就还是不要来打扰我了"); } if ($imageinfo[0] !== 1 &amp;&amp; $imageinfo[1] !== 1) {#图片长宽为1 die("东西不能方方正正的话就很讨厌"); } $fileName=urldecode($_FILES['postedFile']['name']); if(stristr($fileName,"c") || stristr($fileName,"i") || stristr($fileName,"h") || stristr($fileName,"ph")) {#过滤关键字母,忽略大小写 die("有些东西让你传上去的话那可不得了"); } $imagePath = "image/" . mb_strtolower($fileName);#使字符串小写，这边encoding参数被省略。 if(move_uploaded_file($_FILES["postedFile"]["tmp_name"], $imagePath)) {#将上传的文件移动到image位置下。 echo "upload success, image at $imagePath"; } else { die("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0af601220510ba017d556df1b2804b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb89580e9500107597c3a6e820331bd4/" rel="bookmark">
			【软考高级：信息系统项目管理师】【信息化和信息系统】第五天：信息系统安全技术及信息化的发展应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 信息系统安全技术及信息化的发展应用 1.信息安全的有关概念信息安全概念信息安全技术信息安全法律法规信息安全保护等级（12345级）人员管理 2.信息解密加密信息加密概念对称加密技术非对称加密技术（RSA算法）Hash函数概念数字签名概念认证的概念 3.信息系统安全计算机设备安全网络安全防火墙入侵检测入侵防护VPN安全扫描，网络蜜罐（入侵检测），无线网络技术 操作系统安全数据库安全应用系统安全 4.信息化发展与应用的新特点5.国家信息化发展的战略6.电子政务7.电子商务安全协议SSLSET 8.工业化和信息化相融合9.智慧化BI 商业智能十四五规划相关法律 1.信息安全的有关概念 信息安全概念 信息安全技术 信息安全法律法规 不重要
信息安全保护等级（12345级） 人员管理 不重要
2.信息解密加密 信息加密概念 对称加密技术 非对称加密技术（RSA算法） Hash函数概念 数字签名概念 认证的概念 3.信息系统安全 计算机设备安全 网络安全 防火墙 入侵检测 入侵防护 VPN DDN是专线，有物理隔离
安全扫描，网络蜜罐（入侵检测），无线网络技术 操作系统安全 数据库安全 应用系统安全 4.信息化发展与应用的新特点 5.国家信息化发展的战略 6.电子政务 7.电子商务 EDI是连接传统电子商务和网络电子商务的枢纽
安全协议 SSL SET 8.工业化和信息化相融合 9.智慧化 前面章节已经学过
智慧城市&amp;工业互联网
BI 商业智能 十四五规划 相关法律 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1a9aae95c4695cb45cd6f871590179/" rel="bookmark">
			发送http请求状态码报415
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端发送http或https的post请求时，返回415状态码 后台使用了springmvc框架，参数使用了@RequestBody注解进行绑定，用了这个注解进行数据绑定，只能接受数据类型为 Content-Type类型为application/json
其他类型就会报415，服务器无处处理当前内容类型的数据
关于@RequestBody注解，主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)，后台使用@RequestBody注解，前端是需要使用的Content-Type类型为application/json传入时才能被后端方法接收到，如果使用Content-Type为其他类型时则接收不到。
415错误的解释是说，服务器无法处理请求附带的媒体格式。以下是HTTP的状态码关于415返回码的说明：
415 Unsupported Media Type
服务器无法处理请求附带的媒体格式 如果前端post请求时，在请求头里的Content-Type 设置为：application/x-www-form-urlencoded，类型的，就会报415的状态码
两种解决方案
第一种是后台修改，去掉@RequestBody注解
第二种是前台修改，设置Content-Type类型为application/json
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934b535800b1cba8f96a5d72f72f1611/" rel="bookmark">
			2222
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DisQ 介绍 {以下是 Gitee 平台说明，您可以替换此简介 Gitee 是 OSCHINA 推出的基于 Git 的代码托管平台(同时支持 SVN)。专为开发者提供稳定、高效、安全的云端软件开发协作平台无论是个人、团队、或是企业，都能够用 Gitee 实现代码托管、项目管理、协作开发。企业项目请看 https://gitee.com/enterprises}
软件架构 软件架构说明
安装教程 xxxx xxxx xxxx 使用说明 xxxx xxxx xxxx 参与贡献 Fork 本仓库 新建 Feat_xxx 分支 提交代码 新建 Pull Request 特技 使用 Readme_XXX.md 来支持不同的语言，例如 Readme_en.md, Readme_zh.md Gitee 官方博客 blog.gitee.com 你可以 https://gitee.com/explore 这个地址来了解 Gitee 上的优秀开源项目 GVP 全称是 Gitee 最有价值开源项目，是综合评定出的优秀开源项目 Gitee 官方提供的使用手册 https://gitee.com/help Gitee 封面人物是一档用来展示 Gitee 会员风采的栏目 https://gitee.com/gitee-stars/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0baee9d279d34fa1dfd71aadb908c3f/" rel="bookmark">
			11111
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DisQ Description {When you're done, you can delete the content in this README and update the file with details for others getting started with your repository}
Software Architecture Software architecture description
Installation xxxxxxxxxxxx Instructions xxxxxxxxxxxx Contribution Fork the repositoryCreate Feat_xxx branchCommit your codeCreate Pull Request Gitee Feature You can use Readme_XXX.md to support different languages, such as Readme_en.md, Readme_zh.mdGitee blog blog.gitee.comExplore open source project https://gitee.com/exploreThe most valuable open source project GVPThe manual of Gitee https://gitee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0baee9d279d34fa1dfd71aadb908c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502f06ab6cd0cee9d2311cec73366153/" rel="bookmark">
			【腾讯云代码分析】四月上新&#43;新功能前瞻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tencent Cloud Code Analysis
TCA开源版
前言/ foreword
腾讯云代码分析（TCA）开源版四月发布新新功能汇总如下。
另附五月上新预告（各项功能和内容以上线后版本介绍为准）。
上新一
上新合规检查规则包
此规则包在内部使用多年，现已在开源版上线。帮助简化开源合规流程，助力规避版权、安全、公关等问题。
详情可查看专题文章：【腾讯云代码分析】开源合规检查规则包上线！
上新二
新增健康状态勘测功能
增加健康探测接口，在启动前后探测各项内容是否正常启动。
在启动前对python命令及版本、所需依赖包是否安装、pip下载源、可用磁盘空间、可用内存等进行探测；启动后通过访问健康状况探测接口监测服务健康状况及异步任务执行状态。
.
上新三
新增部分PHP安全相关规则
有限支持：SQL注入, XSS, Deser反序列化, SSRF, 会话固定, PHPINFO, URL重定向, FileInclusion等安全漏洞检查。
上新四
上线工具管理
1.支持接入自定义工具。
（工具权限默认为仅团队内可用，如需调整工具权限需平台管理员处理）
2.支持为自定义工具创建规则。
3.支持编辑自定义工具基础信息及运营状态。
上新五
License鉴权
支持部分子工具的License鉴权。
上新六
增加工具管理
（管理员权限）
1.支持查看平台已支持的工具列表。
2.支持调整自定义工具权限。
以上功能代码已提交开源版，欢迎使用！
下月更新功能前瞻，敬请期待！👇👇
五月上新预告
1.上线工具依赖管理
可自定义工具依赖项，拉取工具依赖时仅拉取指定项，提高任务效率。
2.支持自定义分析节点私有标签
可自定义标签实现项目私有机器分类管理。
3.支持各主流SCM平台Oauth授权，便捷高效接入主流SCM平台代码库。
4.自研工具正式版开放使用
支持更多语言，支持自定义规则。
5.支持API扫描，助力隐私合规分析。
关注我们，
持续为您的代码助力！
QQ交流群：361791391
腾源会是腾讯云成立的汇聚开源项目、开源爱好者、开源领导者的开放社区，致力于帮助开源项目健康成长、开源爱好者能交流协助、开源领导者能发挥领袖价值，让全球开源生态变得更加繁荣。
点击 阅读原文 立即获取开源版地址！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48be3772e52bc2492cdbde9e3096ff29/" rel="bookmark">
			【树莓派】 Qt 界面 点灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装QT5和QT Creator二、编写控制代码三、运行效果参考文档： 一、安装QT5和QT Creator 这里只安装QT基础的部分，还有其他模块。
// 安装QT的基本库 sudo apt-get install qt5-default // 安装QT的IDE sudo apt-get install qtcreator //新的树莓派如4B， 需更新wiringpi(控制IO库) cd /tmp wget https://project-downloads.drogon.net/wiringpi-latest.deb sudo dpkg -i wiringpi-latest.deb 验证wiringpi 安装是否成功
执行gpio readall
可以看到很直观的看到IO的IO模式,是输出还是输入。
另外编程时需要使用的 IO端口号也列出来的，这里使用wiringpi 控制的话 关注wpi那列的端口，和python使用RPi库控制IO编号不一样。
二、编写控制代码 1、新建工程
2、选择QWidget
3、pro工程添加LIBS += -lwiringPi 4、widget.ui添加两个按钮 改名为b1,b2
右键按钮 转到槽
这里都选clicked()
这样就可以在两个clicked 加入点亮LED和熄灭LED的代码，就可以实现按钮控制了
5、widget.cpp 写入完整的IO控制代码
这里我们使用pin12，也就是对应wpi 1的口
widget.cpp 完整代码：
#include "widget.h" #include "ui_widget.h" #include "wiringPi.h"//添加头文件 Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); wiringPiSetup();//初始化 pinMode(1,OUTPUT); //PIN12 use "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48be3772e52bc2492cdbde9e3096ff29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a80bdb510533d30daf97d9c5343bfa/" rel="bookmark">
			ASP.NET Web程序设计——数据绑定控件详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据绑定控件简介: 数据绑定是ASP.NET提供的另一种访问数据库的方法。数据绑定技术可以让程序员不关注数据库连接、数据库命令以及如何格式化这些数据以显示在页面上的环节，而是直接把数据绑定到HTML元素和Web控件。数据控件则是用来显示从数据军中获取的数据
数据绑定控件分为： 列表型控件表格型控件层次型控件 属性/方法描述DataSource 指定数据绑定控件的数据来源，程序会从该数据源中获取数据并显示DataBind()显示绑定的数据 数据绑定控件简介 数据绑定控件描述DropDownList下拉数据绑定控件RepeaterRepeater控件是一个数据绑定容器控件，用于生成各个子项的列表，这些子项的显示方式可以完全由编程者自己编写，不支持分页、排序和编都、仅提供重复模板内容GridView以表格的形式进行数据展示，有自带分页，支持删、改、排序、分页外观设置以及自定义显示数据DetailsViewDetails View控件以表格形式显示数据，且一次仅显示数据源的单条记录，并且 table标签下的每行（ tr标签）表示记录中的一个字段。这个控件同样支持数据的编辑、插入和删除操作，并可以轻松地设置分页功能DataListDataList 控件，类似于Repeater控件，用于显示限制于该控件的项目的重复列表。不过，DataLis t控件会默认地在数据项目上添加表格，且具有内置样式设置ListView按照编程者编写的模板格式显示数据。与 DataList和Repeater控件相似，提供了增、删、改、排序和分页等功能，还可以支持用户自定义模板FromViewForm View控件与DetailsView控件很相似，Form View控件仅可显示数据源中的单条记录 数据绑定原理 首先要设置控件的数据源和数据的显示格式，设置完成后，控件就会自动处理剩余的工作，把要显示的数据按照要显示的格式显示在页面上。
数据绑定类型
单值绑定:通过单值绑定的方式把数据添加到ASP.NET页面的任何地方。
多值绑定:可显示一个表中的所有内容。
单值绑定：
1.属性： &lt;%# 属性%&gt; 2.表达式：&lt;%= 内容%&gt; 3.​​​​​​​&lt;%$ XXX %&gt; 只能调用Web.config中的值 ​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b45b6efb6c1e18ab8f7c394c21a21b6/" rel="bookmark">
			(CVPR 2019) PointRCNN: 3D Object Proposal Generation and Detection From Point Cloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract 在本文中，我们提出PointRCNN用于从原始点云进行3D目标检测。整个框架由两个阶段组成：stage-1用于自下而上的 3D proposal生成，stage-2用于在规范坐标中细化proposal以获得最终检测结果。我们的第一阶段子网络不是像以前的方法那样从RGB图像生成proposals或将点云投影到鸟瞰图或体素，而是通过分割以自下而上的方式直接从点云生成少量高质量的3D proposals将整个场景的点云分为前景点和背景。stage-2子网络将每个proposal的池化点转换为规范坐标，以学习更好的局部空间特征，并结合stage-1中学习的每个点的全局语义特征进行准确的框细化和置信度预测。在KITTI数据集的3D检测基准上进行的大量实验表明，我们提出的架构通过仅使用点云作为输入，以显着的优势优于最先进的方法。该代码可在https://github.com/sshaoshuai/PointRCNN获得。
1. Introduction 深度学习在2D计算机视觉任务上取得了显着进展，包括目标检测[8,32,16]和实例分割[6,10,20]等。除了2D场景理解之外，3D目标检测对于许多真实的世界应用，例如自动驾驶和家用机器人。虽然最近开发的2D检测算法能够处理图像中的大量视点变化和背景杂波，但是具有点云的三维物体的检测仍然面临着来自3D目标的6自由度的不规则数据格式和大搜索空间的巨大挑战。
在自动驾驶中，最常用的3D传感器是LiDAR传感器，它可以生成3D点云来捕捉场景的3D结构。基于点云的3D目标检测的难点主要在于点云的不规则性。最先进的3D检测方法要么利用成熟的2D检测框架，将点云投影到鸟瞰图[14, 42, 17]（见图1(a)），再到正面视图[4, 38 ]，或常规的3D体素[34, 43]，它们不是最优的，并且在量化过程中会丢失信息。
图1.与最先进方法的比较。我们的方法不是从鸟瞰图和前视图的融合特征图[14]或RGB图像[25]生成proposals，而是直接从原始点云以自下而上的方式生成3D proposals。
Qi等人并没有将点云转换为体素或其他常规数据结构来进行特征学习。[26, 28]提出了PointNet，用于直接从点云数据中学习3D表示，用于点云分类和分割。如图1(b)所示，他们的后续工作[25]将PointNet应用于3D目标检测，基于从2D RGB检测结果中裁剪的截锥体点云来估计3D边界框。然而，该方法的性能在很大程度上依赖于2D检测性能，不能利用3D信息的优势来生成鲁棒的边界框proposals。
与2D图像中的目标检测不同，自动驾驶场景中的3D目标由带注释的3D边界框自然且良好地分离。换句话说，用于3D目标检测的训练数据直接为3D目标分割提供了语义掩码。这是3D检测和2D检测训练数据之间的关键区别。在2D目标检测中，边界框只能为语义分割提供弱监督[5]。
基于这一观察，我们提出了一种新颖的两阶段3D目标检测框架，名为PointRCNN，它直接对3D点云进行操作，并实现了鲁棒和准确的3D检测性能（见图1（c））。提出的框架由两个阶段组成，第一阶段旨在以自下而上的方案生成3D边界框proposal。通过利用3D边界框生成ground-truth分割掩码，第一阶段分割前景点并同时从分割点生成少量边界框proposals。这种策略避免了在整个3D空间中使用大量的3D锚框，就像以前的方法[43,14,4]所做的那样，并且节省了大量的计算量。
PointRCNN的第二阶段进行规范的3D框细化。在生成3D proposals后，采用点云区域池化操作来池化来自stage-1的学习点表示。与现有的直接估计全局框坐标的3D方法不同，池化的3D点被转换为规范坐标，并与池化点特征以及来自stage-1的分割掩码相结合，用于学习相对坐标细化。该策略充分利用了我们强大的第一阶段分割和proposal子网络提供的所有信息。为了学习更有效的坐标细化，我们还提出了完整的基于bin的3D框回归损失用于proposal生成和细化，并且消融实验表明它比其他3D框回归损失收敛更快并实现更高的召回率。
我们的贡献可以概括为三个方面。(1)我们提出了一种新颖的基于自下而上点云的3D边界框proposal生成算法，该算法通过将点云分割为前景目标和背景来生成少量高质量的3D proposals。从分割中学习到的点表示不仅擅长生成proposal，而且有助于后期的框细化。(2)提出的规范3D边界框细化利用了我们从stage-1生成的高召回率框proposals，并学习在规范坐标中预测框坐标细化，并具有鲁棒的基于bin的损失。(3)我们提出的3D检测框架PointRCNN在仅使用点云作为输入的情况下，在KITTI的3D检测测试板上，在截至2018年11月16日的所有已发表作品中以显着的优势优于state-of-theart方法，并且在所有已发表的作品中排名第一。
2. Related Work 从2D图像中检测3D目标。 现有的工作是从图像中估计3D边界框。[24, 15]利用3D和2D边界框之间的几何约束来恢复3D目标姿态。[1, 44, 23]利用3D目标和CAD模型之间的相似性。陈等人[2, 3]将目标的3D几何信息表示为能量函数，以对预定义的3D框进行评分。由于缺乏深度信息，这些作品只能生成粗略的3D检测结果，并且会受到外观变化的极大影响。
来自点云的3D目标检测。 最先进的3D目标检测方法提出了各种从稀疏3D点云中学习判别特征的方法。[4, 14, 42, 17, 41]将点云投影到鸟瞰图，并利用2D CNN学习点云特征以生成3D框。宋等人[34]和周等人将点分组为体素，并使用3D CNN学习体素的特征以生成3D框。然而，鸟瞰投影和体素化由于数据量化而遭受信息丢失，并且3D CNN的内存和计算效率均较低。[25, 39]利用成熟的2D检测器从图像中生成2D proposals，并减少每个裁剪图像区域中3D点的大小。然后使用PointNet[26, 28]学习点云特征以进行3D框估计。但是，在一些只能从3D空间很好观察的具有挑战性的情况下，基于2D图像的proposal生成可能会失败。3D框估计步骤无法恢复此类故障。相比之下，我们自下而上的3D proposal生成方法直接从点云生成鲁棒的3D proposals，既高效又无量化。
学习点云表示。 Qi等人没有将点云表示为体素[22、33、35]或多视图格式[27、36、37]。[26]提出了PointNet架构，直接从原始点云中学习点特征，大大提高了点云分类和分割的速度和准确性。后续工作[28, 12]通过考虑点云中的局部结构进一步提高了提取的特征质量。我们的工作将基于点的特征提取器扩展到基于3D点云的目标检测，从而产生了一种新颖的两阶段3D检测框架，该框架直接从原始点云生成3D框proposals和检测结果。
3. PointRCNN for Point Cloud 3D Detection 在本节中，我们将介绍我们提出的两阶段检测框架PointRCNN，用于从不规则点云中检测3D目标。整体结构如图2所示，由自下而上的3D proposal生成阶段和规范边界框细化阶段组成。
图2. PointRCNN架构，用于从点云进行3D目标检测。整个网络由两部分组成：（a）以自下而上的方式从原始点云生成3D proposals。(b)用于在规范坐标中细化3D proposals。
3.1. Bottom-up 3D proposal generation via point cloud segmentation 现有的2D目标检测方法可以分为一阶段和两阶段方法，其中一阶段方法[19, 21, 31, 30, 29]通常更快，但直接估计目标边界框而无需细化，而两阶段方法方法[10, 18, 32, 8]首先生成proposals，并在第二阶段进一步细化proposals和置信度。然而，由于巨大的3D搜索空间和不规则的点云格式，将两阶段方法从2D直接扩展到3D并非易事。AVOD[14]在3D空间中放置80-100k个锚框，并在多个视图中为每个锚汇集特征以生成proposals。FPointNet[25]从2D图像生成2D proposals，并根据从2D区域裁剪的3D点估计3D框，这可能会错过只能从3D空间清晰观察到的困难目标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b45b6efb6c1e18ab8f7c394c21a21b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10fc9af71c01984fadac7ef2d923e9c1/" rel="bookmark">
			Java获取24小时制的时间方法（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void main(String arg[]) {
（一）获取24小时制中的时刻)
Date today = new Date();
// 格式化时间
SimpleDateFormat sf = new SimpleDateFormat(“HH”)；
String time = sf.format(today);
System.out.println(time);
// 参考数据
1、yyyy表示年，如2013；
2、MM表示月，如12；
3、dd表示天，如31；
4、hh表示用12小时制，如7；
5、HH表示用24小时制，如18；
6、mm表示分，如59；
7、ss表示秒，如59；
8、SSS表示毫米，如333
（二）Java时间string转换成时间：
String time = “2020-03-14”；
Long Time = parseTime(time);
System.out.println(Time);
SimpleDateFormat sf = new SimpleDateFormat(“yyyy-MM-dd”);
Systom.out.println(sf.format(Time));
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7af26c8b4ded5e2defcc3e5a877e5b5/" rel="bookmark">
			jQuery的Ajax实例（附完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 写在前边什么是AjaxAjax基本结构实例实例1实例2 小结 写在前边 作为一个前端刚入门没多久的小白，想在这里分享一下我的学习内容，就算是学习笔记了。因为前端的大部分学习都是通过网站上的教程，所以遇到不懂得问题，也只有求助于网络，通过度娘，了解到了一些论坛、博客。在发现了众多技术大牛的同时，我也发现，一些像我这样的小白，由于能力有限，在查找相关资料的时候，对于大佬的一些操作理解困难，虽说能照猫画虎的做下来，但是可能自己也没有理解为什么要这么做。当然，我说的就是自己在查资料时曾经遇到的问题，这也是我写这篇笔记的主要原因。我下面就根据我自己的理解跟大家说说Ajax，如果大家看到什么问题，欢迎批评指正。
什么是Ajax Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。
通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
由上面的定义可以看出，Ajax的主要目的是为了，在不需要重新加载整个网页的前提下，使网页的一部分更新。同时，为了实现部分更新，就需要前端和后台之间的数据交换，包括前端向后台提交数据和前端从后台读取数据。
Ajax基本结构 因为学习的是jQuery中Ajax方法，所以所说的结构即是$.ajax()的结构。
$.ajax()方法中的参数很多，我在实例中使用的只是一小部分，这里只介绍实例中所需要的参数的使用，其余更多参数还将继续学习。
$.ajax({ url:"发送请求（提交或读取数据）的地址", dataType:"预期服务器返回数据的类型", type:"请求方式", async:"true/false", data:{发送到/读取后台（服务器）的数据}, success:function(data){请求成功时执行}, error:function(){请求失败时执行} }); 注：（这些参数均为选填，如果不设置，按默认值处理）
&lt;1&gt; url 默认为当前页地址
&lt;2&gt; dataType 可用类型：
（如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递）
xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息。script：返回纯文本JavaScript代码。json：返回json数据。jsonp：(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。text：返回纯文本字符串。
说明：对于json和jsonp的区别，本小白暂时没有深入了解，目前只知道jsonp可以跨域读取数据，有待进一步学习~ &lt;3&gt; type 可用类型主要为post和get两种（默认为get）
get：从指定的资源请求数据（从服务器读取数据）post：向指定的资源提交要被处理的数据（向服务器提交数据） &lt;4&gt; async 异步方式，默认为true，即异步方式。当设置为false时，为同步方式。
异步方式：ajax执行后，会继续执行ajax后面的脚本，直到服务器端返回数据后，触发ajax里的success方法，这时候执行的是两个线程。同步方式：在没有返回值之前，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
说明：这里的同步和异步有待深入理解，以下实例均使用默认的异步方式 &lt;5&gt; data 请求的数据，{ }中可以填入多项数据。如果不填（一般为get请求），则读取对应地址的全部数据，此时可以在console中通过console.log(res)显示数据情况。
&lt;6&gt; success 和 error 两个函数 一般需要设置，方便确定请求是否成功，以及请求成功后的提示或是对数据的处理和显示。
实例 介绍了ajax的基本结构之后，就来看看下边这两个简单的例子
实例1 实现在页面上输入一个地址，点击获取经纬度，弹出该地址的经纬度。
url=“https://restapi.amap.com/v3/geocode/geo” key:“7486e10d3ca83a934438176cf941df0c”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7af26c8b4ded5e2defcc3e5a877e5b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193ca6a48f056de6c79c9058692686c0/" rel="bookmark">
			C/C&#43;&#43;嵌入BS架构的页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目要用C/C++来嵌入BS的网页，经调研发现使用QT Creator工具有直接能用的组件。废话不多说直接上代码。
第一步：创建Qt Widgets项目并修改项目.pro文件添加如下一句
QT += core gui webenginewidgets 第二步：在main.cpp代码里直接调用代码
#include "mainwindow.h" #include &lt;QWebEngineView&gt; #include &lt;QWebEngineView&gt; #include &lt;QApplication&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); QWebEngineView *myWeb = new QWebEngineView(); myWeb-&gt;setUrl(QUrl("https://www.baidu.com")); myWeb-&gt;show(); return a.exec(); } 第三步，直接运行代码即可。
注意： 如果BS架构里有打开新的页签操作上面的代码是无法打开页面的，解决方案是重载QWebEngineView里的createWindow函数，也就是要继承QWebEngineView，重载createWindow方法。代码转载自：QT5.12 webengineview鼠标左键点击打开链接_feinxer的博客-CSDN博客_qwebengineview 超链接
第一步，自定义mywebengine组件，添加headers组件自定义代码，mywebengine.h如下
#include &lt;QWebEngineView&gt; #include &lt;QWebEnginePage&gt; #include &lt;QUrl&gt; #include &lt;QtWidgets&gt; class MyWebEngine: public QWebEngineView { Q_OBJECT public: MyWebEngine(QWidget *parent=nullptr); protected: // 鼠标左键点击触发 QWebEngineView * createWindow(QWebEnginePage::WebWindowType type) override; private slots: void onUrlChanged(QUrl url); }; 第二步，在sources组件里添加实现方法，mywebengine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193ca6a48f056de6c79c9058692686c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8779aa10b944d5d43e10ca5eb9d3452/" rel="bookmark">
			PHP For IIS 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745ee85dec7091d31d9c469e08ba8d12/" rel="bookmark">
			python提取COCO，VOC数据集中特定类，实现xml转coco(voc转coco)格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python提取COCO，VOC数据集中特定类，实现xml转coco(voc转coco)格式 主要是踩坑（搜索）记录，已使用成功。
参考博客和github链接贴在文章末尾。如果使用过程中有问题，请留言告知，感谢各位大佬指正。
1.实现python提取COCO2017特定类别，适用于之前版本 原始coco2017 train文件数量为：118287
原始coco2017 val文件数量为：5000
指定需要提取的类别时注意不要写错类别名称，否则会得到许多object为None的xml文件，也可以通过提取之后的文件数量检查是否提取成功（应少于原始数量）
完整代码如下：
from pycocotools.coco import COCO import os import shutil from tqdm import tqdm import skimage.io as io import matplotlib.pyplot as plt import cv2 from PIL import Image, ImageDraw #the path you want to save your results for coco to voc savepath="/data/dataset/My_coo2017/COCO/" #保存提取类的路径 train_dir=savepath+'train2017/' val_dir=savepath+'val2017/' train_anno_dir=savepath+'train_Annotations/' val_anno_dir=savepath+'val_Annotations/' # datasets_list=['train2014', 'val2014'] # 记得修改名称 datasets_list=['train2017','val2017'] # datasets_list=['val2017'] classes_names = ['person', 'bicycle'] #coco有80类，这里写要提取类的名字，以person和bicyle为例，继续添加列表即可，但要注意不要写错类别，会导致出现很多没有object的文件 #Store annotations and train2014/val2014/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/745ee85dec7091d31d9c469e08ba8d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd1ca31e1c18db3766cdcb23961c53b/" rel="bookmark">
			(zichao)jQuery笔记（仅作简单整理，未深入探究）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、jQuery基础（一）初识jQuery（二）jQuery引入（三）jQuery两大核心1、jQuery核心函数（1）作为一般函数调用: $(param)，参数为函数（2）作为一般函数调用: $(param)，参数为选择器字符串（3）作为一般函数调用: $(param)，参数为DOM对象（4）作为一般函数调用: $(param)，参数为参数为html标签字符串 (用得少)（5）作为对象使用: $.xxx() 2、jQuery核心对象（1）size()/length: 包含的DOM元素个数（2） [index]/get(index): 得到对应位置的DOM元素（3） each(): 遍历包含的所有DOM元素（4） index(): 得到在所在兄弟元素中的下标 二、jQuery选择器（一）基本选择器1、id选择器2、元素选择器3、类选择器4、通用选择器5、交集并集选择器 （二）层次选择器1、ancestor descendant2、parent&gt;child3、prev+next4、prev~siblings （三）过滤选择器1、第一个2、最后一个3、排除4、单数偶数5、索引值6、索引值范围7、动画效果的元素8、内容9、可见性10、特定属性 （四）子元素选择器1、匹配第一个子元素2、匹配最后一个子元素3、匹配其父元素下的第N个子或奇偶元素4、父元素中唯一的子元素 （五）表单选择器1、匹配所有 input, textarea, select 和 button 元素2、匹配所有的单行文本框3、匹配所有密码框4、匹配所有单选按钮5、匹配所有复选框6、匹配所有提交按钮7、匹配所有图像域8、匹配所有重置按钮9、匹配所有按钮10、匹配所有文件域11、所有不可见元素12、匹配所有可用元素13、匹配所有不可用元素14、匹配所有选中的被选中元素15、匹配所有选中的option元素 三、常用的工具方法（一）$.each()（二）$.trim()（三）$.type(obj)（四）$.isArray(obj)（五）$.isFunction(obj)（六）$.parseJSON(json) 四、属性（一）操作任意属性1、attr()2、removeAttr()3、prop()4、removeProp() （二）操作class属性1、addClass()2、removeClass()3、toggleClass() （三）操作HTML代码/文本/值1、html()2、val()3、取得所有匹配元素的内容 四、CSS（一）获取设置样式1、css() （二）获取/设置标签的位置数据1、offset()2、position() （三）元素滚动1、scrollTop()2、scrollLeft() （四）元素的尺寸1、内容尺寸2、内部尺寸3、外部尺寸 五、过滤（一）first()（二）last()（三）eq()（四）filter()（五）not()（六） has() 六、查找（一）children()（二）find()（三）parent()（四）prevAll()（五）nextAll()（六）siblings() 七、文档操作（一）append(content)（二）prepend(content)（三）before(content)（四）after(content)（五）replaceWith(content)（六）empty()（七）remove() 八、事件（一）事件绑定(2种)：（二）事件解绑：（三）事件的坐标（四）事件相关处理（五）事件的委派1、事件委托(委派/代理)2、使用事件委托的好处3、设置 九、动画（一）淡入淡出1、fadeIn()2、fadeOut()3、fadeToggle() （二）滑动动画1、slideDown()2、slideUp()3、slideToggle() （三）显示隐藏1、show()2、hide()3、toggle() （四）自定义动画1、animate()2、stop() 一、jQuery基础 （一）初识jQuery jQuery 是一个 JavaScript 库。
jQuery 极大地简化了 JavaScript 编程。
实例
&lt;!--使用原生DOM--&gt; &lt;script type="text/javascript"&gt; window.onload = function () { var btn1 = document.getElementById('btn1') btn1.onclick = function () { var username = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd1ca31e1c18db3766cdcb23961c53b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/751da5583b0613148e2a394ce28170af/" rel="bookmark">
			强推一个讲解卡尔曼滤波的网站，比我见过的所有国内blog都好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先直接上链接：https://www.kalmanfilter.net/default.aspx
（不需要梯子）
网站的第一句就说明了作者有多自信，然而确实也是讲的很好。不像很多blog上来就是先把五个公式摆上来给人干迷糊。个人认为要想理解卡尔曼滤波，有必要知道卡尔曼滤波是怎么一步步推导出来的，这里得推导不单单是推公式，而是为什么我们要在工程上进行卡尔曼滤波，卡尔曼滤波之前的算法是怎么实现的，之前的算法有什么劣势，卡尔曼滤波相比于之前的算法有什么优势，卡尔曼滤波的思想是什么，然后才是卡尔曼滤波的公式推导。刚好这个网站上都说了。这个大佬从最基础的开始介绍，一步一步推导到卡尔曼滤波的五个核心公式，而且在推导公式的过程中，几乎是一步一步来推的，没有什么显然…、综上…、几乎是完全把人当小白来对待，也可见确实作者是真学透了。
唯一的缺点可能是太长了，然后后小部分好像没有中文翻译。但是，老板要我们看的论文好多也是英文的，我们还是得照样看，不是么？耐心看下去吧，肯定会有很多收获的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ed08f18e0d17a637944ab35341a358/" rel="bookmark">
			C语言——链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言——链表 链表是一种基础的数据结构类型，一种能够动态维护数据的线性数据表。链表的数据以结点形式存储信息，并通过结点之间的指针实现结点之间的衔接。
为什么要用链表？
链表和数组类似，但是功能比数组强大得多，数组的空间是固定的，在定义数组的时候，数组的大小已经被固定，在使用时有可能会造成空间的浪费或者面临空间不够的风险，而链表的空间是动态的，则避免了这一问题。
我们来看最基础的单向链表：
1.首先要定义结构体作为链表的结点：
typedef struct node { int data; struct node * next; } Node; 链表的每个结点就如图中所示，结点的两部分一部分用来存储要存储的数据，另一部分存储指向下一结点的指针。
2.初始化链表：
在链表的创建时，首先要创建链表的头结点
Node * InitList() { Node * head = (Node * )malloc(sizeof(Node)); head-&gt;next = NULL; return head; } 3.链表的尾插法：
将先插入的结点放在链表的尾部：
void CreatTail(Node *head) { Node * r, * newNode; r = head; int data; scanf("%d", &amp;data); while (data != -1) { newNode = (Node * )malloc(sizeof(Node)); newNode-&gt;data = data; newNode-&gt;next = r-&gt;next; r-&gt;next = newNode; r = newNode; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ed08f18e0d17a637944ab35341a358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de23a8f7b4b1c7f1c45289c29d6d3d6/" rel="bookmark">
			vant手机端点击下拉框数据过多-添加搜索功能 下拉模糊搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提需求：
vant 并没有提供可搜索的选择器。因为项目下拉项太多，而且不好记，所以需要这个模糊查询的选择器。类似于element-ui 的可搜索Select选择器
&lt;template&gt; &lt;div style="margin-left: 13%"&gt; &lt;van-field style="width: 80%" required readonly clickable name="meetingId" :value="pagelook.position" label="" right-icon="arrow-up" placeholder="选择与我相关的会议进行筛选" @click="changePicker(1)" :rules="[{ required: true, message: '选择与我相关的会议进行筛选' }]" /&gt; &lt;van-popup position="bottom" v-model="showPicker"&gt; &lt;van-search placeholder="请输入会议名称" v-model="positionSearch" @search="onSearch2(positionSearch)" /&gt; &lt;van-picker cancel-button-text="取消" value-key="lable" show-toolbar :columns="ret" @confirm="onConfirmPicker" @cancel="showPicker = false" /&gt; &lt;/van-popup&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { QueryAboutMeMeetingList, } from '../../../api/oa' export default { data() { return { ret: [], typeFlag: '', positionList: [], showPicker: false, positionSearch: '', pagelook: { position: '' }, meetingId: '' } }, methods: { changePicker(flag) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de23a8f7b4b1c7f1c45289c29d6d3d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f3d9e22fce7bbd9b7cc7cf3eb89eaf/" rel="bookmark">
			给MATLAB安装runtime插件，将MATLAB程序打包成exe文件方法(亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面:本方法是本人通过整合网上方法试出来的，所以和别的很多方法有一样的地方。我只是整合了一下，没有啥技术原创性。
1.查看已安装的MATLAB是否有runtime插件。操作:在command窗口直接输入mcrinstaller。
如果如图上所示，那就是没有。(2019版本以后包括2019一般均没有)
2.下载MATLAB对应子版本的runtime。(很多方法是官网下载，但在官网下载还是会版本不对应，所以直接在你所用的MATLAB里搜索安装链接最靠谱)(！！！这一步记得连网，不连网不行)
操作:命令行输入compiler.runtime.download(分自动和手动下载两种，我介绍手动下载，成功率高)。此时一般显示不成功，那么在compiler.runtime.download指令运行结束前按Ctrl + C 键提前终止，会报错显示在下载XX文件过程中被用户终止，复制文件下载网址链接到浏览器下载对应子版本runtime。(小白提示:将网址复制在浏览器网址栏里按回车，记住下载压缩包的文件夹位置)
3.下载完成后，在matlab中设置MATLAB complier编译器的路径。
操作:预设→MATLAB Compiler→路径设置
输入你刚刚下载压缩包的位置(小白提示:在 此电脑 中找到压缩包位置，右键属性复制位置)(！！！记得加上\MATLAB_Runtime_R2019a_win64.zip)(如果出现错误可能是你地址格式没写对，不要省略任何一个\和.zip)(版本以你已下载压缩包的版本为准)
点确定
4.再次查看已安装的MATLAB是否有runtime插件。
出现以上情况即可。
5.可以打包程序了(你发送文件的人电脑里没有MATLAB也可以查看运行你的程序了)
操作:在APP中找到Application Complier
首先点击Add main file右边的加号添加主程序文件，然后选择Runtime included in package，运行时不用进行联网，打包好以后可以直接进行运行，打开Settings如下图所示，包括Log Folder（日志文件夹）、Testing Files（测试文件）、End User Files（最终用户文件）、Packaged Installers（库安装器），可以修改他们输出的路径
设置好以后然后填写下面输出exe文件的信息，包括文件的名字、作者、Email、公司、概述、描述，下面还可以选择额外的安装选项，exe文件运行需要的其他文件（图像、子程序等）、提供给用户的文件（readme.txt等）
然后点package就可以了，第一次打包可能会时间比较久。
然后在输出文件中点击彩色图标就可以看到你写的程序的运行结果啦。
写在最后:
打包MATLAB为exe文件整个操作的难度主要在找到与MATLAB版本匹配的runtime并下载。我这个方法的简易之处是不用到处找合适版本的下载网址，不用解压压缩包。至于下载好runtime之后打包的地方，有不懂的可以再看看别的答案。
大型软件都比较复杂，大家耐心一点多试几次，一点点纠错总会成功的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb231f37f7f39c1a00bccb372479e4ed/" rel="bookmark">
			LLVM 学习(三) -样例学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLVM 学习(三) -样例学习 @2022-04-17 09:28:38
@sizaif
LLVM IR 样例学习 1. 基本语法 编写c代码 # hello.c #include &lt;stdio.h&gt; int add(int a,int b){ return a + b; } int main() { int a = 10; int b = 22; printf("%d\n",add(a,b)); return 0; } 将c源码转换为LLVM IR-ll格式 $ clang -emit-llvm -S hello.c -o hello.ll 生成的hello.ll内容如下 ; ModuleID = 'hello.c' source_filename = "hello.c" target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128" target triple = "x86_64-unknown-linux-gnu" @.str = private unnamed_addr constant [4 x i8] c"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb231f37f7f39c1a00bccb372479e4ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d04cf576a3d53c758da64f59b3327a/" rel="bookmark">
			LVS 原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVS 原理 一、概述
LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。
访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选取一个服务节点响应用户的请求。 在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。
二、LVS NAT 模式
客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP)，目标地址为 VIP(负载均衡器前端地址)。负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，并将响应报文返还给 LVS。然后 lvs 将此报文的源地址修改为本机并发送给客户端。
在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端
三、LVS DR 模式（局域网改写 mac 地址）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78d04cf576a3d53c758da64f59b3327a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d030259213f24c9b407e239b1c9ac4a2/" rel="bookmark">
			Mybatis快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.一条完整的Mybatis使用过程1.创建数据库和表，并插入数据2.新建maven项目,添加依赖和插件3.idea添加数据库可视化操作4.写jdbc属性文件5.核心配置文件（配置数据源、jdbc连接参数、注册mapper文件）6.编写数据库实体类7.编写映射文件（SQL语句）8.测试类 2.Mybatis的增删改查1.查询1.查询所有字段2.查询单个字段3.模糊查询 2.增加3.删除4.更改 3.mybatis数据映射4.mybatis对象分析5.简化之前的测试代码6.优化映射文件——为实体类注册别名1.单个实体类别名的注册2.批量注册 7.设置日志输出查看底层执行 1.一条完整的Mybatis使用过程 目录结构：
1.创建数据库和表，并插入数据 CREATE DATABASE `mybatis` /*!40100 DEFAULT CHARACTER SET utf8mb4 */ CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `email` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 并插入数据：
2.新建maven项目,添加依赖和插件 新建maven项目（quickstart模板）
添加mybatis依赖
&lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt; 然后要添加 资源文件的指定
&lt;!--添加资源文件的锁定--&gt; &lt;build&gt; &lt;resources&gt; &lt;!--锁定java目录下的文件--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d030259213f24c9b407e239b1c9ac4a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73908a6bef971244b780e8a4c1b00dac/" rel="bookmark">
			动态系统MATLAB分析的初步研究（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
用MATLAB进行部分分式展开
用MATLAB求B（s）/A（s）的零点和极点
求多项式的根
动态系统数学模型的变换
传递函数模型到状态空间模型的变换。
状态空间到传递函数的变换。
连续时间系统到离散时间系统的变换。
用MATLAB进行部分分式展开 现在讨论函数（一般形式）
已知传递函数：
对该函数，可以通过下列命令求得其部分分式展开
&gt;&gt; num=[2 5 3 6] num = 2 5 3 6 &gt;&gt; den=[1 6 11 6] den = 1 6 11 6 &gt;&gt; [r,p,k]=residue(num,den) r = -6.0000 -4.0000 3.0000 p = -3.0000 -2.0000 -1.0000 k = 2 可以看出，留数由向量r给出，极点位置由向量p给出，直接项则由向量k给出。上述结果的部分分式展开式为：
命令residue还能用来根据部分分式展开式构成(分子和分母)多项式。即上述过程的反过程。
假设我们知道函数的部分分式展开和（如上图所示），如何求出原先的传递函数？
r = [-6	-4	3]; p = [-3	-2	-1]; k = 2; &gt;&gt; [num,den] = residue(r,p,k) num = 2 5 3 6 den = 1 6 11 6 再借助printsys()函数直接构造成传递函数（采用s的多项式的比来显示num/den）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73908a6bef971244b780e8a4c1b00dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7778f11109c70192d4374e8d04b39e61/" rel="bookmark">
			IDEA 中 ANTLR 4 的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）在 File - Settings - Plugins 中，安装 ANTLR v4 插件
（2）创建 maven 项目
File - New - Project… 中，选择 maven，
然后一路 next 即可（当然，可以自己取个名字，换个位置）
（3）在 pox.xml 中添加 antlr 的依赖项
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4-runtime&lt;/artifactId&gt; &lt;version&gt;4.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4-maven-plugin&lt;/artifactId&gt; &lt;version&gt;4.10.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;antlr&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;antlr4&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;none&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;outputDirectory&gt;src/test/java&lt;/outputDirectory&gt; &lt;listener&gt;true&lt;/listener&gt; &lt;treatWarningsAsErrors&gt;true&lt;/treatWarningsAsErrors&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 添加位置如下所示，注意在 &lt;version&gt; 的地方修改成自己的 antlr 版本！
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7778f11109c70192d4374e8d04b39e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6d92b57e1e71c3873200c0d8a22f4c/" rel="bookmark">
			测试了几款基于electron的笔记本软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间测试了基于 electron的 几个不错的笔记本软件,说下我自己的看法，（不是复制粘贴过来的）
mark text 优点:所见即所得、简约、开源、快捷。缺点1、点击文本内容大纲不会同步，2、没有中文版，可以翻译，但麻烦
zttlr 优点:所见即所得，开源。缺点1、点击文本内容大纲会同步，但大纲似乎不会跳转，只会显示在哪里。2、居然不支持下载图片到本地？？？
Typora 优点:所见即所得、简约、优雅。缺点： 1、收费。2、1.1版本后越来越卡。3、不开源封闭式，自定义需要一定电脑基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ad33d8f6ac55a9344a88be215868eb/" rel="bookmark">
			【计算机网络-7】IPv6协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、背景 IPv4只能支持43亿设备，不够用拆分子网 二、IPv6的工作原理 IPv6和IPv4两者工作原理相似，为切片、增加封包头、路由(寻址)几个阶段
三、IPv6和IPv4的主要区别 地址寻址 1、区别一：地址 地址数量：IPv4有4个8位，共16位，IPv6有8个16位，共128位分割符号： IPv4的地址用户 . 分割，如102.28.7.35。每一个是8位，用0-255的数字表示。IPv6的地址用：分割，如0123:4567:89ab:cdef:0123:4567:89ab:cdef。每个是一个16位的16进制数字，就是4个字符。 书写方式：IPv6地址可简写 2、区别二：寻址 全局单播本地单播分组多播 2.1、全局单播 站点前缀(Site Prefix):48bit，一般是由ISP(Internet Service Provider，运营商)或者RIR(Regional Internet Registry,地区性互联网注册机构)。RIR将IP地址分配给运营商。子网号(Subnet ID)：16bit，用于站点内部区分子网。接口号(Interface ID)：64bit，用于站点内部区分设备。 2.2、本地单播 定义：给定地址，本地网定位设备
例子：feb0::123e:456d
Link-local必须以feb0开头
2.3、分组多播 需要以8个1，也就是ff00开头，后面跟上一个分组的编号。所在的网络中已经定义了该分组编号，而且有设备可以识别这个编号拥有分组下设备的完整清单，并把数据发送给对应的设备们。IPv4也支持分组多播，单需要网络配置整体配合。 四、新设备接入 新设备接入IPv6后，会使用IPv6的邻居发现协议(Neighbor Discover Protocol)为自己申请一个IP地址。当新设备需要发送消息到目的地时，还可以通过ND协议广播查询目标设备。然后如果需要路由，还可以通过ND查找路由器。
传统：ARP协议(Address Resolution Protocol,地址解析协议)。每个节点存储许多额外信息。
IPv6：更加无状态化，减少数据冗余带来的风险和负担
五、IPv6的主要优势 解决了IP地址耗尽的问题解决了网络区域、站点划分的问题协议层支持多播。IPv6可以有专门的地址用作多播支持邻居发现协议，自动分配地址，做到了无状态接入设备。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268ce585b43702c33fd81d04ba6bab91/" rel="bookmark">
			关于Typora的卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在尝试了 Typora 1.02 1.03 1.13 1.15 1.24 .1.25 等等这些版本之后,
并在千百次打包,测试等等之后,
我放弃再使用1.03 之后的版本,
原因是1.03 之后的版本,在启动时会莫名其妙的卡顿几秒
(后面的版本应该是和goolge 的chrome 浏览器有某种冲突,就是 如果你打开了chrome,随便运行点什么,再开 Typora 它就会卡顿一下.
我在https://blog.csdn.net/Mao_Jonah/article/details/120533879 这个链接中找到禁用显卡的办法 ,似乎在启动1.15 ,或者 1.25这类的版本时,会稍微好一点点,但只要你运行了chrome ,在某个时间上,Typora又会在启动时突然 卡顿,
以下是引用 链接的方法:
电脑上运行较多应用，内存占用较高，发现Typora特别卡顿，但是同时chrome同时开着40+网页也没有卡顿，多个Pycharm也正常，打开任务管理器发现 Typora使用了0号显卡，怀疑是导致其卡顿的原因。 于是决定关闭GPU, 找到Typora的配置文件 大概在如下所示位置 c:\Users\\AppData\Roaming\Typora\conf\conf.user.json 1 打开后修改flags, 保存并重启typora，就不再使用GPU了: "flags": [["disable-gpu"]] 1 禁用GPU之后，软件启动的时候比之前慢，但是打开之后不卡顿了。 怀疑是跟Chromium，GPU驱动有冲突。 我的0卡是集显，1卡是nvidia独显；有兴趣的同学可以试一下换1号GPU支持来试一下。 ———————————————— 原文链接：https://blog.csdn.net/Mao_Jonah/article/details/120533879 总结:就算是弄了上面这个禁用显卡什么的,1.15 之后的版本还是会卡,就是不行,还是得用1.03或1.02版本
另外 似乎1.15版本之后,自定义菜单 变得困难了,不能添加自定义菜单,就没什么意思了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17d8c382af06c792765c696d7008888/" rel="bookmark">
			web前端做汽车之家官网，HTML5&#43;CSS3&#43;JS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大一写的代码，那时候没有接触到技术博客，没有及时记录下来，如今大三回顾前两年所学，发现好多知识已有所遗忘，现在重新复习web前端语言，当时写代码时所遇到的问题已经记不清楚了，但大体的解决办法还牢记于心，大家有哪里不会的可以直接私信我，我会专门写一个解决那个问题的博客提供给你。现把这个项目分享给大家，小白可以作为参考，代码较为简单，可以帮助大家更好的理解WEB前端。
这个项目是写在一个html里面的
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;img src="汽车.png"&gt;汽车之家官网&lt;/title&gt; &lt;style type="text/css"&gt; #div0{width: 100%;height:1000px;} #div1{width:100%;height:80px;} #div2{width:100%;height:50px; background: blue; line-height: 50px;} .span1{margin:auto auto;display:block;position:absolute;top:40px;left:17%;} .span2{margin:auto auto;display:block;position:absolute;top:40px;left:20%;} a{color: black;} a:hover{color: orange;text-decoration: none;} .text{margin:auto auto;display:block;position:absolute;top:30px;left:40%; border-radius: 20px; width: 500px; height: 40px;} .submit1{margin:auto auto;display:block;position:absolute;top:30px;left:68%; border-radius: 20px; width: 80px; height: 45px; background: orange; color: white; font-size: 20px;border: 0 solid white;} .span3{margin:auto auto;display:block;position:absolute;top:40px;left:85%;} .span4{margin:auto auto;display:block;position:absolute;top:40px;left:88%;} .a1{ float: left; width: 5%; list-style-type: none; padding-left: 10px; font-size: 20px; color: white; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f17d8c382af06c792765c696d7008888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8887606be6d748945a2ea5bc66093ca0/" rel="bookmark">
			潮鞋购物网站，html5&#43;css3&#43;js，实现基本的添加购物车，自动计算金额等功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目展示效果 实现添加购物鞋数量总金额自动变化
实现连接购物车功能
实现在购物车里收藏与删除
下面是购物页面代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;购买精选&lt;/title&gt; &lt;style type="text/css"&gt; body{width: 1350px;height: 100%;} #div0{width: 100%;height: 2100px;} #div1{width: 35%;height: 100px;float: left;} #div2{width: 65%;height: 100px;float: left;} #div2 ul{margin: 40px;} #div2 ul li{float: left;list-style: none;width: 20%;font-size: 20px;color: #789;} #div2 ul li a{text-decoration:none; color: gray;} #div2 ul li:hover{color: black;} #div3{width: 10%;height: 2000px;float: left;} #div4{width: 80%;height: 400px;float: left;} #div4 ul li{width: 20%;list-style: none;float: left;margin: 2%;} #div4 ul li:hover{transform: translate(0,10px);} #div6{width: 80%;height: 400px;float: left;} #div6 ul li{width: 20%;list-style: none;float: left;margin: 2%;} #div6 ul li:hover{transform: translate(0,10px);} #div7{width: 80%;height: 400px;float: left;} #div7 ul li{width: 20%;list-style: none;float: left;margin: 2%;} #div7 ul li:hover{transform: translate(0,10px);} #div8{width: 80%;height: 400px;float: left;} #div8 ul li{width: 20%;list-style: none;float: left;margin: 2%;} #div8 ul li:hover{transform: translate(0,10px);} #div9{width: 80%;height: 400px;float: left;} #div9 ul li{width: 20%;list-style: none;float: left;margin: 2%;} #div9 ul li:hover{transform: translate(0,10px);} #div10{position: fixed;top: 100px;right:10px;width: 50px;height: 400px;background: black;} #div10 ul{padding: 10px;} #div10 ul li{list-style: none;height: 100px;} #div10 ul li img:hover{background: orange;} &lt;/style&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8887606be6d748945a2ea5bc66093ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c89f45bee2fa95f1e7fb6c68c755c3e/" rel="bookmark">
			Android studio--Activity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		附录：练习源码https://download.csdn.net/download/m0_51152186/83607964
Activity使用 什么是Activity Activity是一个Android的应用组件，它提供屏幕进行交互。每个Activity都会获得一个用于绘制其用户界面的窗口，窗口可以充满哦屏幕也可以小于屏幕并浮动在其他窗口之上。
一个应用通常是由多个彼此松散联系的Activity组成，一般会指定应用中的某个Activity为主活动，也就是说首次启动应用时给用户呈现的Activity。
将Activity设为主活动的方法，如下面代码所示需要在AndroidManifest文件中添加以下内容
&lt;application&gt;
....
&lt;activity android:name=".MainActivity"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.MAIN" /&gt;
&lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
....
&lt;/application&gt;
在 android 中，Activity 拥有四种基本状态：
1.Active/Runing 一个新 Activity 启动入栈后，它在屏幕最前端，处于栈的最顶端，此时它处于可见并可和用户交互的激活状态。
2.Paused 当 Activity 被另一个透明或者 Dialog 样式的 Activity 覆盖时的状态。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。
3.Stoped 当 Activity 被另外一个 Activity 覆盖、失去焦点并不可见时处于 Stop ed 状态。
4.Killed Activity 被系统杀死回收或者没有被启动时处于 Killed 状态。
如果一个活动在处于停止或者暂停的状态下，系统内存缺乏时会将其结束（finish）或者杀死（kill）。这种非正常情况下，系统在杀死或者结束之前会调用onSaveInstance()方法来保存信息，同时，当Activity被移动到前台时，重新启动该Activity并调用onRestoreInstance()方法加载保留的信息，以保持原有的状态。
当一个 Activity 实例被创建、销毁或者启动另外一个 Activity 时，它在这四种状态之间进行转换，这种转换的发生依赖于用户程序的动作。下图说明了 Activity 在不同状态间转换的时机和条件：
生命周期 在上面的四中常有的状态之间，还有着其他的生命周期来作为不同状态之间的过度，用于在不同的状态之间进行转换，生命周期的具体说明见下
函数
是否可终止
说明
onCreate()
否
Activity启动后第一个被调用的函数，常用来进行Activity的初始化，例如创建View、绑定数据或恢复信息等。
onStart()
否
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c89f45bee2fa95f1e7fb6c68c755c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0616f3820978f68f6031e1db13c6bdf3/" rel="bookmark">
			【论文摘要】ImageNet：A Large-Scale Hierarchical Image Database
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImageNet系列1《ImageNet：A Large-Scale Hierarchical Image Database》
ImageNet系列2《ImageNet Large Scale Visual Recognition Challenge》（待完成）
ImageNet系列2《Scalable multi-label annotation》（待完成）
ImageNet：A Large-Scale Hierarchical Image Database 前言： 2009年李飞飞团队发表，提出了21k的ImageNet基准数据集
ImageNet官网：https://www.image-net.org/challenges/LSVRC/index.php
论文分为摘要、介绍、ImageNet的特性、ImageNet和相关数据集、构造ImageNet、ImageNet应用、未来工作
摘要 (问题)互联网上图像数据的爆炸式增长有可能训练出更复杂、更健壮的模型和算法，用于索引、检索、组织图像和多媒体数据并与之交互，但如何组建数据集是个问题。
(创新点)提出了从WordNet结构构建的大型图片数据集“ImageNet”。
(具体介绍)ImageNet旨在用平均500-1000个干净和高分辨率的图像构成WordNet的8w个同义词(synsets)中的大部分，所以会由WordNet构建ImageNet数千万图片的语义树。ImageNet目前由12个子树、5247个同义词集、320w图片。ImageNet数据集比目前现有数据集更大、多样且准确。我们使用了Amazon Mechanical Turk来搜集数据。
(下游和优势)我们展示了目标识别、图像分类和自动目标聚类方面展示了应用。
1. 介绍 结构: 使用WordNet结构。
具体: WordNet中大约8w个名词同义词，在ImageNet中，我们为每个同义词提供了500-1000个图片。ImageNet包含12个子树：mammal, bird, fish, reptile, amphibian, vehicle, furniture, musical instrument, geological formation, tool, flower, fruit。包含了5247个同义词和320w图片
文章结构: section2展示了ImageNet，section3描述了如何使用Amazon Mechanical Turk建立，section4为应用
2. ImageNet特性 ImageNet旨在提供5kw数据，在paper公布时(2019)，ImageNet包含12个子树，大部分分析基于mammal和vehicle。
规模(Scale): 12个子树，320w图片，超过5274个类别，每个synset中平均超过600张图片（20%图片非常少）。fig2展示了分布。
层次结构(Hierarchy)： ImageNet将不同类别的图像组织在一个密集的语义层次结构中。与WordNet类似，ImageNet中图像的语法集通过几种类型的关系相互关联，“IS-A”关系是最全面、最有用的关系。尽管可以使用WordNet将任何带有类别标签的数据集映射到语义层次结构中，但是ImageNet的密度是其他数据集无法比拟的。fig3比较了ImageNet和ESP的树，可以看到ImageNet的树更大更密。
准确性(Accuracy)： 图 4 显示了在不同树深度随机分布的总共 80 个合成集的标记精度。平均达到99.7%的精度。因为同义集在层次结构中越低，就越难进行分类。
多样性(Diversity)： ImageNet的构建目标是图像中的对象应该具有不同的外观、位置、视点、姿势以及背景杂波和遮挡。为了解决图像多样性量化的难题，我们计算了每个synset的平均图像，并测量了反映图像中信息量的无损JPG文件大小。图5比较了ImageNet的mammal子树和Caltech101随机四个采样结果
2.1 ImageNet和相关数据集 table1对比了几个数据集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0616f3820978f68f6031e1db13c6bdf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58f5ef64afb0ea0df01470e2c4ff214/" rel="bookmark">
			Pytorch实现Warm up &#43; 余弦退火
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch实现Warm up + 余弦退火 1.Warm up 由于刚开始训练时,模型的权重(weights)是随机初始化的，此时若选择一个较大的学习率,可能带来模型的不稳定(振荡)，选择Warmup预热学习率的方式，可以使得开始训练的几个epoches或者一些steps内学习率较小,在预热的小学习率下，模型可以慢慢趋于稳定,等模型相对稳定后再选择预先设置的学习率进行训练,使得模型收敛速度变得更快，模型效果更佳。
2.余弦退火 当我们使用梯度下降算法来优化目标函数的时候，当越来越接近Loss值的全局最小值时，学习率应该变得更小来使得模型尽可能接近这一点，而余弦退火（Cosine annealing）可以通过余弦函数来降低学习率。余弦函数中随着x的增加余弦值首先缓慢下降，然后加速下降，再次缓慢下降。这种下降模式能和学习率配合，以一种十分有效的计算方式来产生很好的效果。
3.代码（每个batch学习率更新一次） import matplotlib.pyplot as plt import math import torch from torchvision.models import resnet50 from math import cos, pi def adjust_learning_rate(optimizer, current_epoch, max_epoch, lr_min=0, lr_max=0.1, warmup=True): warmup_epoch = 10 if warmup else 0 if current_epoch &lt; warmup_epoch: lr = lr_max * current_epoch / warmup_epoch elif current_epoch &lt; max_epoch: lr = lr_min + (lr_max - lr_min) * ( 1 + cos(pi * (current_epoch - warmup_epoch) / (max_epoch - warmup_epoch))) / 2 else: lr = lr_min + (lr_max - lr_min) * ( 1 + cos(pi * (current_epoch-max_epoch) / (max_epoch))) / 2 for param_group in optimizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a58f5ef64afb0ea0df01470e2c4ff214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d623b7f7e9347d2c13d938202f8769fa/" rel="bookmark">
			(zichao)我的Spring5学习笔记（仅作简单整理，未深入探究）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、IOC容器（一）什么是IOC（二）IOC底层原理（三）BeanFactory 接口1、IOC思想2、Spring 提供 IOC 容器实现两种方式（1）BeanFactory（2）ApplicationContext （四）基于注解进行bean管理1、什么是注解2、Spring 针对 Bean 管理中创建对象提供注解3、基于注解方式实现对象创建（1）开启组件扫描（2）创建类，在类上面添加创建对象注解（3）属性的注入（4）完全注解开发（5）编写测试类 （五）bean 作用域1、scope2、scope 属性值3、singleton 和 prototype 区别 （六）bean 生命周期1、bean 生命周期2、bean 的后置处理器，bean 生命周期有七步3、最终生命周期 二、AOP（一）什么是AOP1、面向切面编程（方面）2、通俗描述3、术语4、通知的多种类型 （二）切入点表达式（三）流程1、创建要增强的类和增强类2、开启注解扫描以及开启生成代理对象3、生成两个类的bean对象4、在增强类上面添加注解 @Aspect5、配置不同类型的通知6、设置增强类优先级7、提取相同切入点表达式8、执行结果 三、JdbcTemplate（一）什么是 JdbcTemplate（二）执行步骤（基于完全注解开发）1、配置配置类2、编写实体类3、编写Service和DAO4、编写测试类5、修改和删除6、查询返回某个值7、查询返回对象8、查询返回集合9、批量操作 四、Spring中队事务的管理（一）什么事务（二）事务四个特性（ACID）（三）事务操作过程（四）Spring 事务管理介绍（五）具体操作1、编写配置类（在上一个模块基础上）2、在 service 类上面（或者 service 类里面方法上面）添加事务注解3、对一些重要参数进行解释（1）propagation：事务传播行为（2）ioslation：事务隔离级别（3）timeout：超时时间（4）readOnly：是否只读（5）rollbackFor：回滚（6）noRollbackFor：不回滚 五、Spring5 框架新功能（一）代码整理（二）Spring 5.0 框架自带了通用的日志封装（三）Spring5 框架核心容器支持@Nullable 注解（四）Spring5 核心容器支持函数式风格GenericApplicationContext（五）Spring5 支持整合 JUnit5（六）SpringWebflux 一、IOC容器 （一）什么是IOC ①控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理
②使用 IOC 目的：为了耦合度降低
（二）IOC底层原理 xml 解析、工厂模式、反射
（三）BeanFactory 接口 1、IOC思想 IOC思想基于IOC容器完成，IOC容器底层就是对象工厂（即BeanFactory 接口）
2、Spring 提供 IOC 容器实现两种方式 （1）BeanFactory IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用。
特点：加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象
（2）ApplicationContext BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d623b7f7e9347d2c13d938202f8769fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cee49ab5ebabbfcd171c0a7c49712c/" rel="bookmark">
			【玩转RT-Thread】 RT-Thread Studio使用（2） 内核实战篇（线程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细原理参考：【玩转RT-Thread】线程管理（详细原理）
文章目录 一、线程创建1、函数原型2、线程定义3、线程创建判断4、线程入口函数5、总结6、补充 二、线程启动三、初始化线程1、函数声明2、函数定义3、线程入口函数4、判断创建状态5、实验结果 一、线程创建 1、函数原型 // 线程创建 rt_thread_t rt_thread_create(const char* name, void (*entry)(void* parameter), void* parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick); 首先我们来看看线程创建函数返回值类型：
可以看到线程创建函数的返回值类型为：rt_thread_t，找到定义处（如下图），可以看到它的返回值类型是一个结构体指针变量。
2、线程定义 那么我们先定义一个结构体指针的线程th1_ptr，这样通过rt_thread_create函数创建的进程控制块的地址就能直接赋值给th1_ptr变量：
rt_thread_t th1_ptr = NULL 接下来就是我们给进程控制块传参了
3、线程创建判断 由于线程创建有返回值，所以我们此处再加入一个判断函数去判断线程是否创建成功
我们先来看下线程返回值（如下图）
如果成功创建的话，返回值是会返回我们所创建的线程对象的
如果创建失败的话，可以看到是会返回一个RT_NULL，也就是0
// 判断	if(th1_ptr == RT_NULL) { //错误信息打印 LOG_E("rt_thread_create create failed...\n"); return -RT_ENOMEM; // 设定当线程th1_ptr创建失败后，返回一个空间不足的标志 } //打印debug调试信息 LOG_D("rt_thread_create create successed ...\n"); 4、线程入口函数 我们在线程的入口处理函数写一个循环函数：
void th_entry(void* parameter) { while(1) { rt_kprintf("th_entry running ...\n"); rt_thread_mdelay(1000); } } 注意：我们在使用线程的处理函数的循环函数的时候，一定要记得及时释放资源，也就是出让CPU资源，不然这个线程会一直执行并占用系统资源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04cee49ab5ebabbfcd171c0a7c49712c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5848c0d936975b18f530fd400101db3c/" rel="bookmark">
			第四单元 用python学习微积分（二十八）参数方程、弧长和表面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-参数方程、弧长和表面积-网易公开课
Bullseye：第一单元 用python学习微积分（一） 安装开发环境Anaconda 和 导数（上）- 1/x的导数
目录
一、弧长
1、前提
2、对一小段曲线进行长度计算：
(1) 公式1： ​
(2) 公式2： ​
3、总弧长公式 ​
4、例1-直线的长度
5、例2 -- 半圆的弧长 ( 弧长和sin的定义推导 )
6、例3 -- 抛物线的长度
二、表面积
1、抛物线旋转成面的表面积
(1) 表面积计算公式，类壳层法
2、球面的表面积(Surface Area of A Sphere)
三、参数方程（Parametric Curves)
1、前提
2、例1 -- ⚪
(1) 形状
(2) 方向
(3) 弧长
一、弧长 ​
1、前提 曲线 S 经过点 , 这些点均匀分布，并分别投影在x轴上
当计算曲线 S 的长度时，我们可以通过用直线连接这些点，并且累加这些线段的长度以求得近似解。
2、对一小段曲线进行长度计算： ​
每一小段弧长的长度
而微积分的思想是，当在极限的情况下，也就是当曲线被分为无限多的份数时， 无限小, 有
（注意： 这里老师提到上式可以简写作 ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5848c0d936975b18f530fd400101db3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e6735473ef82414e9528c7e7396e894/" rel="bookmark">
			Docker基础指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Docker概述Docker为什么出现Docker的历史Docker的安装Docker的基本组成安装Docker卸载Docker阿里云镜像加速底层原理 Docker常用命令帮助命令镜像命令不知道命令，进行找命令的两种方法**docker images****docker search 搜索镜像****docker pull** 下载镜像docker rmi 删除镜像 容器命令新建容器并且启动查看所有运行的容器退出容器删除容器启动和停止容器的操作 常用其他命令**后台启动容器**查看日志查看容器中的进程信息查看镜像的元数据进入当前正在运行的容器从容器拷贝文件到主机上 小结作业练习Docker安装NginxDocker装Tomcat Docker概述 Docker为什么出现 解决问题：
1.在我的电脑上可以运行，但是到别人的电脑上就不能运行了
2.出现版本更新，导致服务不能用
3.环境配置麻烦，不是有的项目可能不支持跨平台
传统： 开发打jar包，运维来部署
现在：开发打包部署上线，一套流程做完
拿app应用商店距离
java -apk发布 ——用户使用apk ——安装即可以使用
java -jar(环境)—— docker：应用商店 ——直接运行即可用
docker思想:
dockere的思想来源于集装箱， 采用隔离思想，集装箱内物品有一个损坏，并不影响另外一个集装箱的物品
Docker的历史 2010年docker的前身dotCloud在美国成立了
dotCloud主要是基于PaaS(Platform as a Serivce),在PaaS平台，所有服务都应经配置好了，开发者只需要选择服务类型，上传代码，就可以对外服务，但是因为PaaS市场还在培育阶段，dotCloud表现的不温不火
Docker开源：
Docker为什么火，因为Docker比较小巧
虚拟机： 在windows装一个VMware，通过这个软件我们可以虚拟一台或者多台电脑，比较笨重
docker:使用隔离技术，采用镜像(最核心环境) 小巧
Docker开发
Docker使用go语言开发的
官网地址：https://www.docker.com/
文档地址：https://docs.docker.com/
容器化技术
Docker和传统虚拟机的区别
传统虚拟机： 虚拟一条硬件，运行完整的操作系统，然后在这个系统安装和运行软件容器直接运行宿主机的内容，容器没有内核，也没有我们虚拟的硬件，十分小巧容器之间相互隔离，容器都有一个属于自己的文件系统，互不影响 DevOps （开发 运维）
1.应用可以迅速交付和部署
传统：需要有很多帮助文档
Docker:直接打包镜像发布测试
2.更便捷的升级和扩容缩容
项目打包为一个镜像，直接部署到另外一个服务器
3.更简单的系统运维
4.更高效的资源利用
Docker的安装 Docker的基本组成 这里的镜像和容器的关系，就像Java里面的Class和对象的关系，我们根据镜像去生成容器
镜像(image):
docker镜像好比一个模板，我们通过这个模板进行容器创建，通过一个镜像可以创建多个容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e6735473ef82414e9528c7e7396e894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5902ae57715fc41dd2ad4b16fa003aa/" rel="bookmark">
			【编程之路（006）三子棋游戏】（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
main函数的整体逻辑
菜单的打印
游戏的实现
棋盘的初始化与打印
玩家下棋
电脑下棋
判断胜负平
棋盘是否为满
源码
引言 这是学完循环，数组和函数之后写出来的一个小游戏，也没有用到什么特别复杂的知识点。
代码对于初学者来说有点多，所以对于整体与局部的把控就显得尤为重要，所以就把代码分成了三个板块。一个是用来写函数声明，预处理的头文件；一个是用来写函数功能的源文件；另一个是用来测试函数功能的源文件。
其中main函数是在测试功能的源文件中，所以我们就从main函数说起。
main函数的整体逻辑 int main() { int choice = 0; srand ((unsigned int)time(NULL));//先不看这一步，后面会用到 do { Menu();//游戏的菜单 printf("请选择是否开始游戏，1 为开始，0 为退出\n"); scanf("%d", &amp;choice); switch(choice) { case 1: { Game();//游戏的具体实现在此函数中，暂时不用管 break; } case 0: printf("退出游戏\n"); break; } } while (choice); return 0; } 游戏一上来就要先给玩家一个选择，玩还是不玩，一把结束后还是否继续。所以我们选择了do while语句。有了整体概念后，我们要继续实现当中的功能。那就先从菜单开始说起。
菜单的打印 void Menu() { printf("*****************\n"); printf("**1.开始 0.退出**\n"); printf("*****************\n"); } 菜单的打印虽然简单，但是为什么还要单独拿出来说呢？因为还是前面提到的整体与局部的关系。这个函数是一个局部，虽然它很简单，但是还是与其他函数又相等的地位。菜单就没有什么值得注意的地方，看自己的喜好打印就好。
游戏的实现 棋盘的初始化与打印 棋盘是3×3的，我们很容易想到用二维数组来创立。
void InitBoard(char board[ROW][COL], int row, int col) { int i = 0; for (i = 0; i &lt; row; i++) { int j = 0; for (j = 0; j &lt; col; j++) board[i][j] = ' '; } } 用这样的方法方便以后棋盘大小的改动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5902ae57715fc41dd2ad4b16fa003aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1129f55cc9b7d8cd5091a0f36a7c26c/" rel="bookmark">
			QTablewidget样式滚动条表头Qss样式设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图所示设置Qtablewidget样式，表头颜色设置，选中列背景色设置等
QTableWidget { background: #303033; } QTableWidget::item { color:rgba(255,255,255,150); background: #303033; text-align:center; } QTableWidget::item:hover { color:#FFFFFF; background: #4B4B4D; } QTableWidget::item:selected { color:#FFFFFF; background: #4B4B4D; } QHeaderView::section,QTableCornerButton:section { text-align:center; padding:3px; margin:0px; color:#DCDCDC; border:1px solid #242424; border-left-width:0px; border-right-width:1px; border-top-width:0px; border-bottom-width:1px; background:qlineargradient(spread:pad,x1:0,y1:0,x2:0,y2:1,stop:0 #646464,stop:1 #525252); } QHeaderView::section:selected { color:#FFFFFF; border:1px solid #242424; } QScrollBar:vertical{ width:8px; border-style:flat; border-radius: 4px; border:0px; background: #19191A; } QScrollBar::handle:vertical{ background: rgba(255,255,255,0.50); border-radius: 4px; width:8px; min-height:91px; border-style:flat; } QScrollBar::handle:vertical::hover{ background: rgba(255,255,255,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1129f55cc9b7d8cd5091a0f36a7c26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b2a150c368b69eba5f170d8d3f448b/" rel="bookmark">
			单片机常用的几种字符串处理函数对比记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.strstr 函数包含在标准C库&lt;string.h&gt;中
1.1函数原型 char *strstr(const char *S1, const char *S2)，在字符串S1中查找第一次出现S2字符串的位置。
1.2函数返回值 该函数返回在 S1 中第一次出现 S2字符串的位置，如果未找到则返回 null
通常用来查找S1中是否包含S2
二.strcmp 函数包含在标准C库&lt;string.h&gt;中
2.1函数原型 int strcmp(const char *S1, const char *S2)，比较S1与S2字符串，查看是否完全一样
2.2函数返回值 如果返回值小于 0，则表示 str1 小于 str2。
如果返回值大于 0，则表示 str1 大于 str2。
如果返回值等于 0，则表示 str1 等于 str2
三.strcpy 函数包含在标准C库&lt;string.h&gt;中
3.1函数原型 char *strcpy(char *S1, const char *S2),把S2字符串复制到S1中，使用时要注意数量大小，S2&gt;S1时会导致溢出，出现错误
3.2函数返回值 函数返回一个指向最终的目标字符串 S1的指针
四.strcpy 函数包含在标准C库&lt;string.h&gt;中
4.1函数原型 char *strncpy(char *S1 const char *S2, size_t n),把S2字符串复制到S1中，最多复制 n 个字符。当 S2 的长度小于 n 时，S1 的剩余部分将用空字节填充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b2a150c368b69eba5f170d8d3f448b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b54bf0b49b6b1b2efd93cd401591b7/" rel="bookmark">
			canal&#43;rabbitmq解决mysql与redis缓存数据一致性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 mysql1.1 开启 MySQL的binlog1.2 重启mysql1.3 查看binlog是否已被开启1.4 修改密码策略1.5 新建canal用户并授权 2 rabbitmq2.1 拉取rabbitmq镜像2.2 运行rabbitmq镜像2.3 进入Rabbitmq Management 3 canal3.1 下载canal3.2 创建解压目录并解压3.3 修改配置文件3.3.1 conf/canal.properties3.3.2 conf/example/instance.properties 3.4 启动canal 4 Spring Boot集成rabbitmq4.1 在pom.xml中添加maven依赖4.2 yml文件4.3 RabbitConfig配置文件4.4 CanalMessage.java4.5 RabbitmqListener.java 1 mysql 1.1 开启 MySQL的binlog vi /etc/my.cnf log-bin=mysql-bin #开启 binlog binlog-format=ROW #选择 ROW 模式 server_id=1 #配置MySQL replaction需要定义，不要和canal的 slaveId重复 ROW：模式 除了记录sql语句之外，还会记录每个字段的变化情况，能够清楚的记录每行数据的变化历史，但会占用较多的空间。
STATEMENT：模式只记录了sql语句，但是没有记录上下文信息，在进行数据恢复的时候可能会导致数据的丢失情况；
MIX：模式比较灵活的记录，理论上说当遇到了表结构变更的时候，就会记录为statement模式。当遇到了数据更新或者删除情况下就会变为row模式；
1.2 重启mysql systemctl restart mysqld 1.3 查看binlog是否已被开启 SHOW VARIABLES LIKE 'log_bin'; 1.4 修改密码策略 set global validate_password_policy=LOW; set global validate_password_length=5; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b54bf0b49b6b1b2efd93cd401591b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0c6417aad8e9e0a40c9d7f2233ae36/" rel="bookmark">
			VSCode无go的代码提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我安装的是go的1.17版本，之后安装了VScode，VScode版本应该不会影响编程。首先遇到了VSCode下载go插件失败的问题，经过一系列折腾找出了问题，如果你也有此问题，可参考如下。
VS Code 安装go插件失败分析及解决方案_一越王超的博客-CSDN博客
接下来准备编程，可是遇到了没有代码提示的问题，在网上找了很多方法，如下：
方法一：在setting.json添加如下配置：
"go.useLanguageServer": true 结果，失败！！！
方法二：处理gocode
问题：自动补全功能停止工作。应该怎么做？
1. 在终端中运行 gocode close，然后再试试。
2. 如果仍然有问题，运行go get -u github.com/mdempsky/gocode ，更新下工具。
3. 如果还有问题，运行 gocode -s -debug，然后再试试。
结果，失败！！！
方法三：GO111MODULE设置为off
将环境变量中GO111MODULE改成auto或者 off然后去 重新下载go get -v github.com/veandco/go-sdl2/sdl go-sdl2 将会安装到src/github.com/...目录下。下载完成之后在开发工具vscode中使用 sdl2. 将会发现原来的配方，熟悉的提示。亲测公司和本人的两台电脑管用。之后你可以在切换为GO111MODULE=on,代码提示不受影响。题外话:go module的出现可以使你开发代码目录下不会出现过多的第三方包. 结果，失败！！！
方法四：还是处理gocode 初学go，配置好后一直没用，今天用vscode编辑go，突然发现go代码不提示了，非常难受，上网查了一下，加上自己测试，得出如下解决方法。
go get -u -v github.com/mdempsky/gocode 先运行这个，重新编译gocode程序，gocode程序就是负责代码提示的，不提示了，一是可能没安装，二是可能安装了，但是代码旧了，我这就属于这种情况，以前安装了，后来升级了go，但是gocode没有升级编译，这个代码就是重新下载新的，然后重新编译。
编译完成后，如果还不管用，就关闭gocode gocode close
gocode exit 然后关闭vscode，再重新启动vscode。
另外，还要记得把vscode的目录配置到当前编辑的目录。
结果，失败！！！
方法5：配置环境变量 后重启
配置环境变量
1.1 打开“开始”并搜索“env”
1.2. 选择“编辑系统环境变量”
1.3. 点击“环境变量…”按钮
1.4. 在“&lt;你的用户名&gt; 的用户变量”章节下（上半部分）
1.5. 点击“新建…”按钮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c0c6417aad8e9e0a40c9d7f2233ae36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0353b9c7000f1c1c961338bbae007d/" rel="bookmark">
			解决AbortController中断请求无法再次请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios新方式中断请求
文档:GitHub - axios/axios: Promise based HTTP client for the browser and node.js
官网的示例
const controller = new AbortController(); axios.get('/foo/bar', { signal: controller.signal }).then(function(response) { //... }); // cancel the request controller.abort() 如果按照这种方法后,再次点请求就无法发送了,因为signal里面的属性aborted是只读属性,改不了,你点击发送请求,他会读取signal的aborted值为true,就不发送了,咋办?看下去
我看了一下api,文档:AbortSignal - Web API 接口参考 | MDN,AbortController - Web API 接口参考 | MDN
这家伙是个只读属性,咋办?方法总是有的,把控制器定在外面为空,用的时候再设置
let controller = null//在外面定一个控制器,设置为空 document.getElementById('one').onclick = async () =&gt; { try { // 如果控制器存在,说明有上个请求,就它取消并设置为空 if (controller) { controller.abort() controller = null } //没有的话就到这一步 controller = new AbortController() let res = await request({ url: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0353b9c7000f1c1c961338bbae007d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5441fc4c4b5ce696619a029d2f2113fa/" rel="bookmark">
			第三单元 用python学习微积分（二十三）第三单元总结（下）-- 切面法求体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-第三次考试复习-网易公开课
开发环境准备：CSDN
目录
二、刨切
1、回顾
2、老师这节课说的问题， 是用切片法求​对z轴旋转形成的体的体积。
二、刨切 回顾Bullseye：第三单元 用python学习微积分（二十二）功、平均值、概率（下）和 数值积分 (1)
中的概率问题
1、回顾 概率的经典问题，投飞标问题， 问如果一个人向靶心投飞镖，击中的次数与 (c是常数,假设为1)成正比，
有多大的概率会射到靶子旁边的人。至于这个计算有没有实际意义呢？这里老师提到，二战时有人研究德国的V-2导弹瞄准伦敦发射，会击中哪里，用的就是这个函数 （结果相近！）。
这里击中的概率与距离靶心的长度 r 相关，类正态分布
2、老师这节课说的问题， 是用切片法求对z轴旋转形成的体的体积。 ​
老师这里预设了一个常量
用旋转法画出这个体
from sympy import * import numpy as np import matplotlib.pyplot as plt import numpy as np from enum import Enum from itertools import product, combinations from matplotlib import cm from matplotlib import pyplot as plt from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection from mpl_toolkits.mplot3d import Axes3D fig = plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5441fc4c4b5ce696619a029d2f2113fa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/144/">«</a>
	<span class="pagination__item pagination__item--current">145/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/146/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>