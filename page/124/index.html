<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e195f2359a1347feea8485bde37029f/" rel="bookmark">
			Echarts柱状图的宽度设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图中柱图只需要设置series中的坐标系属性barWidth就可以，
这种图柱状图，折叠柱状图都适应
eg：
/** * 堆积柱状图 * @param xaxisdata x轴：标签（数组） * @param serieszs 柱状图图数据（数组） * @param seriesyx 柱状图图数据（数组） */ function drawDJZZT(xaxisdata,serieszs,seriesyx){ var myChart = echarts.init(document.getElementById('main1')); myChart.setOption({ title : { text : "" }, tooltip : { trigger : 'axis', showDelay : 0, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data:['做市', '协议'] }, xAxis : [{ type : 'category', data : xaxisdata, axisLabel:{ textStyle:{ color:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e195f2359a1347feea8485bde37029f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5266fd4d5823eff2780f0c474e0af9ac/" rel="bookmark">
			鸿蒙开发实例 ｜ 可复用列表项的ListContainer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简短的列表可以通过定向布局实现，但是如果列表项非常多，那么使用定向布局就不合适了。与许多其他的移动开发技术一样，鸿蒙操作系统也提供了可复用列表项的列表组件，这就是本篇文章要介绍的ListContainer。
01、可复用列表项的ListContainer 简短的列表可以通过定向布局实现,但是如果列表项非常多,则使用定向布局就不合适了。例如,需要创建100个列表项的列表,那么用定向布局实现至少需要创建100个以上的组件了。然而,限于设备屏幕大小的限制,绝大多数组件不会显示在屏幕上,却会占据大量的内存资源,甚至造成应用“闪退”。
与许多其他的移动开发技术一样,鸿蒙操作系统也提供了可复用列表项的列表组件ListContainer。
注意: 在Android和iOS系统中,均提供了与ListContainer类似的可复用列表项的列表组件。在Android系统中,这种组件被称为RecyclerView; 在iOS系统中,这种组件被称为UITableView。
ListContainer继承于ComponentContainer,属于布局的一种。在ListContainer中,每个列表项都是一个组件或者子布局,即列表项组件。不过,ListContainer非常“吝啬”。
例如,利用ListContainer实现具有100个列表项的列表,ListContainer绝对不会实实在在地创建100个组件,而是仅创建屏幕当前能够显示的列表项组件。
例如,当前的设备屏幕只能够显示6个列表项,那么ListContainer只创建6个列表项组件。当用户上下滑动到其他的列表项时,被滑出去的列表项组件会被新的列表项复用,重新更换数据后再次进入用户的视野,如图1所示。
■ 图1 “吝啬”的列表组件ListContainer
在图1中,Item 1组件被滑出列表,随后被ListContainer“换装”填入新的数据后再次从列表底部重新进入ListContainer。Item 1组件和Item 7组件实际上是1个组件,组件还是原来的组件,只不过数据已经不是原来的数据了。这种按需创建组件的思想对于应用程序能够流畅稳定地运行非常重要。这么说来,ListContainer就像一个掌管着系统资源的大臣,时时刻刻打着精细的算盘,用最少的内存资源来干更多事情。
那么,我们应该如何来使用ListContainer呢? 实际上,ListContainer已经封装好复用列表项的机制了,不需要开发者过多操心。作为开发者,只需为ListContainer提供需要显示的列表项所需要的数据和组件就可以了,而这项工作就全权交给RecycleItemProvider类完成了。RecycleItemProvider是一个抽象类,开发者在使用它之前需要至少实现以下4种方法。
(1) getCount(): 提供列表项数量。
(2) getItem(int i): 提供当前列表项的数据。
(3) getItemId(int i): 提供当前列表项ID。
(4) getComponent(int id,Component cpt,ComponentContainer ctn): 创建组件与数据绑定,即创建属于这个列表项的组件,然后绑定该列表项数据。在这种方法中,id表示这个列表项ID,cpt对象为上一次这个列表项的组件对象。作为开发者可以直接复用这个组件对象,当然也可以创建一个新的组件对象。ctn是cpt组件的父布局对象。
接下来,演示ListContainer和RecycleItemProvider的具体使用方法。
首先,通过布局文件(recycle_item.xml)创建列表项的用户界面,代码如下:
/javaUI/entry/src/main/resources/base/layout/recycle_item.xml &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;DirectionalLayout xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:height="match_content" ohos:width="match_parent" ohos:orientation="vertical"&gt; &lt;Text ohos:id="$+id:item_text" ohos:height="match_content" ohos:width="match_parent" ohos:margin="4vp" ohos:text_size="16fp" ohos:text_alignment="center"/&gt; &lt;/DirectionalLayout&gt; 这个列表项非常简单,仅仅显示了一个文本组件,用于显示列表项数据,但是,这个用户界面与之前介绍的AbilitySlice界面不同,这个列表项界面仅仅显示在屏幕的某一个部位,因此不能使用之前的setUIContent方法了。
此时,需要LayoutScatter类来解析这个布局文件,LayoutScatter并不能直接被初始化,需要通过其getInstance(Context context)方法获取,其中content为当前的上下文对象。获取LayoutScatter 对象后,通过其parse(int xmlId,ComponentContainer root,boolean attachToRoot)方法即可解析所需要的XML布局文件,并且转换为组件对象。在parse方法中,xmlId表示需要解析的布局资源ID。当attachToRoot参数为true时,可以将解析出来的组件对象自动添加到root布局中,但是,在绝大多数情况下并不需要这么做,此时传递root参数为null,传递attachToRoot参数为false即可。
因此,通过以下代码即可将上面创建的列表项组件转换为DirectionalLayout对象,代码如下:
LayoutScatter scatter = LayoutScatter.getInstance(getContext()); DirectionalLayout layout = scatter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5266fd4d5823eff2780f0c474e0af9ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1ce9d2953484eeee37538b26bd2a22/" rel="bookmark">
			Linux-Samba文件共享服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解samba：
Samba是著名的开源软件项目之一，它在Linux/UNIX操作系统中实现了微软公司的SMB/CIFS网络协议，从而使平台的文件共享变得更加容易，选用Samba可以很好地解决不同操作系统之间的文件互访问题。
一，Samba软件的组成 1.Samba软件包的构成：
Samba大部分软件包已经在CentOS系统中安装好了，用户可以通过以下操作查询系统中samba相关软件包的安装情况。 [root@localhost ~]# rpm -qa | grep "^samba" samba-common-4.4.4-9.el7.noarch samba-common-libs-4.4.4-9.el7.x86_64 samba-libs-4.4.4-9.el7.x86_64 samba-client-libs-4.4.4-9.el7.x86_64 samba-common-tools-4.4.4-9.el7.x86_64 samba-4.4.4-9.el7.x86_64 2.Samba服务的程序组件
Samba服务器提供smbd，nmbd两个程序，分别完成不同的功能。其中，smbd负责为客户端提供服务器中共享资源（目录和文件等）的访问；nmbd负责提供基于NetBIOS协议的主机名称解析，以便windows网络中的主机提供查询服务。
安装完samba软件包后，管理员可以通过systemctl工具来控制samba服务器的启动，中止，开机自启。
[root@localhost ~]# systemctl start smb [root@localhost ~]# systemctl start nmb [root@localhost ~]# systemctl enable smb Created symlink from /etc/systemd/system/multi-user.target.wants/smb.service to /usr/lib/systemd/system/smb.service. [root@localhost ~]# systemctl enable nmb Created symlink from /etc/systemd/system/multi-user.target.wants/nmb.service to /usr/lib/systemd/system/nmb.service. 二，主配置文件smb.conf 1.smb.conf配置文件
Samba服务的配置文件位于/etc/samba/目录中，其中smb.conf是主配置文件。
[root@localhost ~]# grep -v "#" /etc/samba/smb.conf [global] workgroup = SAMBA security = user passdb backend = tdbsam printing = cups printcap name = cups load printers = yes cups options = raw [homes] comment = Home Directories valid users = %S, %D%w%S browseable = No read only = No inherit acls = Yes [printers] comment = All Printers path = /var/tmp printable = Yes create mask = 0600 browseable = No [print$] comment = Printer Drivers path = /var/lib/samba/drivers write list = root create mask = 0664 directory mask = 0775 在smb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1ce9d2953484eeee37538b26bd2a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97191a5dc4d7ea6226175f50661f3afb/" rel="bookmark">
			Antd Select选择器 treeSelect 选择树 解决异步数据无法设置默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;treeSelect dataType="fiveLevel" onChange={reginChange} treeMode="limits" defaultValue={treeCheck} key={treeCheck} //设置和defaultValue相同的值 /&gt; 因为defaultValue只设置了一次，异步获取数据时候会加载设置的默认值，这个时候还无法拿到，解决思路就是利用diff算法的原理，给Select选择器动态绑定key值，从而实现重新生成一个新的Select选择器挂载到DOM树上，实现defaultValue的动态绑定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae781219f4d7a8f81342bfde6eb84642/" rel="bookmark">
			lintcode算法题判断 2 的幂（Python 版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目:判断 2 的幂（Python 版）
写这道题的时候在网上看到c版本以及python版本都有下面的解法,但是下面的解法并不能满足算法要求计算消耗时间的条件
下面这个方法的思路是,当n为2的幂时,在二进制形式下有一个规律,就是都只含有一个1,剩下都是0,
思路:所以减1在进行&amp;(位与运算)的时候就会发现二进制形式下只剩0了,位与本身就是找不同,所以都是0找不到不同,就等于0了,那么这样一来只要是2的幂，按下面位运算找不同只要没有不同的,就都是2的幂
n = int(input()) if n &amp; (n - 1) == 0: print("It's a power of two") else: print("It's not a power of two") 下面是官方的答案，自己跟着写了一遍
n = int(input()) while n % 2 == 0: n //= 2; if n == 1: print("It's a power of two") else: print("It's not a power of two") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eba8c880733f04b76aa542a8692f012/" rel="bookmark">
			MyBatis&#43;Oracle ORA-01861: 文字与格式字符串不匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述: 1.前端传的值: "2022-09-28 12:09:32" 这种格式日期
2.后端是字符串接收然后存map里了
3.mybatis如下图
4.报错信息:ORA-01861: 文字与格式字符串不匹配
解决: 我是一直在用mysql的,最近这个项目才开始接触oracle,有些细节不是很熟悉,这些数据我存的时候是转成yyyy-mm-dd的格式的
但是存到数据库,它自动又变成斜杠格式了(这里用select假装一下,但是你看结果并不是横线的格式)
!!!因为这个字段设置的是date类型 而且默认是sysdate,也就是根据你windows系统的格式有关,当然你也可以去设置系统格式或者plsql的格式,然后重启plsql
所以你要保证比较的日期类型是一样的,可以把数据库的日期用to_char('2022/09/27 12:12:12','yyyy-mm-dd hh24:mi:ss') 转换了在比较
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc4d5eaa867dcd7b34e62b07e363249/" rel="bookmark">
			检测到目标URL存在http host头攻击漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.添加java过滤器 import com.xx.sys.core.util.ResourceUtil; import org.springframework.http.HttpStatus; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; /** * @Description: 检测到目标URL存在http host头攻击漏洞 * @Author: t * @Createtime: 2022/9/28 11:30 */ public class HostCheckFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //从配置文件或其他地方获取 正确的值 例：public.cnemc.cn,192.168.1.1 String hostName = ResourceUtil.getConfigByName("127.0.0.1"); String[] split = hostName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc4d5eaa867dcd7b34e62b07e363249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77337beaf44b5686010c2a2c7e2a8cf8/" rel="bookmark">
			16.redis如何导入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shiguanghui1001（你懂的），本篇文章是通过技术手段自动写的，大家可以来分析一下是如何完成的？我平常工作的时候，总会遇到这样那样的问题，每次都要搜好久，才能找到好一点的文章，解决我的问题，故此整理出这些文章，方便你我查看。慢慢地，我会收录各个技术方向的内容，python，java，go，redis，mysql等。如果有其他需求或者互相交流一下 全网最新相关内容 标题-链接
发布日期
简介
来源
如何用建木CI导入导出Redis数据
2022-02-07 18:20:01
Redis数据导入在建木CI中,可以通过redis数据导入节点 来完成数据导入,节点底层使用的是redis-dump命令查看节点文档可以看到,...
公众号-开源建木+
Redis数据的导出和导入：dump和load方式 - 简书
2021-11-18 01:57:22
6、redis-load 导入数据. 如果你导出的是1号库的数据，然后你要把它导入到新redis的19号库，将导出文件中的所有"db":1, 换成"db":19,然后保存，上传后导入即可，在新redis无密 …
其他
Spring Boot 操作 Redis 的各种实现
2021-09-12 23:06:57
starter-data-redis org.redisson redisson 3.8.2 true org.redisson ... 15 #选择使用哪个数据库0~15 idleConnectionTimeout: 10000 ...
公众号-好好学java
Redis 16 大应用场景,竟然这么多..
2021-08-23 23:06:18
先写入Redis再定时同步到数据库6、限流int类型,incr方法以访问... 15 withscores图片原文链接:https://blog.csdn.net/qq_39938758/...
公众号-好好学java
干掉Redis,看腾讯这个技术有多牛逼!
2021-05-16 21:04:46
并行数据导入 存储层 Tendis服务无状态, 故障重新拉起数据自动路由Tendis 冷热混合存储的一些重要特性介绍:缓存层 Redis Cluster...
公众号-IT码徒
ETL工具Kettle - 数据同步/迁移(So Easy)
2021-02-22 08:41:36
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77337beaf44b5686010c2a2c7e2a8cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/729462134a929cb8cc538410da9b6d30/" rel="bookmark">
			k8s创建pod - 启动pod的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
知识点一：启动一个pod
1、使用命令启动一个nginx pod
1.1、访问刚才创建的pod的nginx服务
1.2、删除deployment
2、将pod里的服务发布出去
首先创建根据yaml文件创建pod
2.1、创建Service
2.2、访问发布的pod
3、利用yaml文件创建pod
3.1、根据yaml文件启动pod
3.2、删除pod
4、pod的几种状态 知识点二：启动pod的流程
知识点三：pod有哪些调度算法
1、 kubectl describe node k8s-master 输出一个node的详细信息
2、pod的重启策略
知识点四：pod的通信方式
知识点五：k8s的各种控制器
1、k8s里面有哪些控制器？
1.1、ReplicaSET 副本控制器 1.2、DaemonSet 1.3、Job
2、deployment，replicaSET，pod的关系
2.1、既然pod是replicaSET启动的，那么删除replicaSET会发生什么？
知识点一：启动一个pod 1、使用命令启动一个nginx pod deployment 控制器：专门负责在k8s里安装部署pod
kubectl create deployment ：创建部署控制器
k8s-nginx ：是控制器的名字
--image=nginx ：指定控制器去启动pod使用的镜像
-r 3 ：启动3个nginx的pod
副本控制器replicaSET（rs）：作用就是监控pod副本的数量，如果某个node节点挂了，这个节点上的pod也会挂，副本控制器就会在其他的node节点上启动新的pod，数量总数达到副本控制器当时设置的数量 -- 》高可用的体现
[root@k8s-master ~]# kubectl create deployment k8s-nginx --image=nginx -r 3 deployment.apps/k8s-nginx created [root@k8s-master ~]# kubectl get pod NAME READY STATUS RESTARTS AGE k8s-nginx-6d779d947c-58j42 1/1 Running 0 114s k8s-nginx-6d779d947c-mphkp 1/1 Running 0 114s k8s-nginx-6d779d947c-zwplb 1/1 Running 0 114s [root@k8s-master ~]# kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE k8s-nginx 3/3 3 3 3m10s [root@k8s-master ~]# kubectl get pod -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES k8s-nginx-6d779d947c-58j42 1/1 Running 0 13m 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/729462134a929cb8cc538410da9b6d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a48dd38d3544af3c6c894fa5b568228/" rel="bookmark">
			ppt包装数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让数据自己说话的三大技巧：
Excel&amp;PPT联动表达观点瘦身&amp;配色 1 】excel与ppt联动：图形展示
插入-组合图-编辑数据-在excel中粘贴数据，选中需要的数据
2】表达观点：图形的形状：折线图、柱状图等表达
3】瘦身&amp;配色
强调突出
瘦身：删掉多余的
配色：设计-填充
更改柱状图的颜色：
选中柱状-右键-设置数据系列格式-填充与线条-纯色填充-无线条
柱状显更胖：
选中柱状-右键-设置数据系列格式-系列-主坐标轴-系列重叠0%，分类间距 110%
小结：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fcab41beb1cc30d5875b04cabe6df02/" rel="bookmark">
			【报错解决】org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于这种错误，一般在于mapper接口与xml文件无法绑定。
解决方案：
1.检查xml文件名是否与mapper接口名一致。
2.检查xml文件中namespace是否与mapper接口的全类名一致。（按住ctrl点击能跳转就没问题）
3.是否在主启动类上标注了@MapperScan（“mapper接口所在包的全包名”）或在mapper接口类上标注了@Mapper（两者不能同时使用）
4.检查mapper接口方法名是否与xml文件中id属性一致。
5.如果打包时xml文件没有自动复制到class输出目录的mapper类包下，则需要在pom文件中添加mybatis加载配置文件的配置。
&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 6.clean掉target，重新编译。
7.在配置文件中声明xml文件的路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c46a4a81b237adabef54f285547ca060/" rel="bookmark">
			使用webSocket实现对数据的实时推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用webSocket实现对数据的实时推送详解 1.什么是webSocket? 相对于 HTTP 这种非持久的协议来说,websocket是 HTML5 出的一个持久化的协议。
2.实时推送数据的实现方式以及应用场景 实现方式
1.轮询:客户端通过代码定时向服务器发送AJAX请求,服务器接收请求并返回响应信息。
优点:代码相对简单,适用于小型应用。
缺点:在服务器数据没有更新时,会造成请求重复数据,请求无用,浪费带宽和服务器资源。
2.长连接:在页面中嵌入一个隐藏的iframe,将这个隐藏的iframe的属性设置为一个长连接的请求或者xrh请求,服务器通过这种方式往客户端输入数据。
优点:数据实时刷新,请求不会浪费,管理较简洁。
缺点:长时间维护保持一个长连接会增加服务器开销。 3.webSocket:websocket是HTML5开始提供的一种客户端与服务器之间进行通讯的网络技术,通过这种方式可以实现客户端和服务器的长连接,双向实时通讯。
优点:减少资源消耗;实时推送不用等待客户端的请求;减少通信量;
缺点:少部分浏览器不支持，不同浏览器支持的程度和方式都不同
应用场景:聊天室、智慧大屏、消息提醒、股票k线图监控等。
1. 为什么叫心跳包呢？
它就像心跳一样每隔固定的时间发一次，来告诉服务器，我还活着。
2. 心跳机制是？
心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了。需要重连~
3.实现心跳检测的思路：
每隔一段固定的时间，向服务器端发送一个ping数据，如果在正常的情况下，服务器会返回一个pong给客户端，如果客户端通过 onmessage 事件能监听到的话，说明请求正常，这里我们使用了一个定时器，每隔3秒的情况下，如果是网络断开的情况下，在指定的时间内服务器端并没有返回心跳响应消息，因此服务器端断开了，这个时候我们使用ws.close关闭连接，在一段时间后(在不同的浏览器下，时间是不一样的，firefox响应更快)，可以通过 onclose事件监听到。因此在onclose事件内，我们可以调用 reconnect事件进行重连操作。
3.后台代码详解 MyWebSocket
package com.socket; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.ServerEndpoint; import java.io.IOException; import java.util.Date; import java.util.concurrent.CopyOnWriteArraySet; @ServerEndpoint(value = "/gpsDataPush") @Component public class MyWebSocket { private static int onlineCount = 0; private static CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;MyWebSocket&gt;(); private Session session; @OnOpen public void onOpen(Session session) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c46a4a81b237adabef54f285547ca060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b179658b88f6ad7850bed6bbd6593c70/" rel="bookmark">
			vue-simple-uploader实现多文件/文件夹以及可拖拽上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-simple-uploader的简单使用 1.效果图展示2.安装3.vue2使用（vue3使用会报错）4.代码 vue-simple-uploader是基于simple-uploader.js的vue上传组件 支持多文件/文件夹上传，拖拽上传可暂停、继续上传上传错误处理支持“秒传”，通过文件判断服务端是否已存在从而实现“秒传”支持进度、预估剩余时间、出错自动重试、重传等操作 这里有参考文档和事例
1.效果图展示 后面有使用拖拽上传文件/文件夹
上传遇到同名的文件会有一个弹框提示，并有相关的操作
2.安装 npm install vue-simple-uploader --save 3.vue2使用（vue3使用会报错） import uploader from 'vue-simple-uploader' //已经创建Vue实例了 Vue.use(uploader) 4.代码 这里我只贴主要的内容，代码也都给有注释哦
&lt;uploader ref="uploader" :options="options" :auto-start="false" :file-status-text="fileStatusText" class="uploader-example" @file-added="onFileAdded" @files-added="onFilesAdded" @file-error="onFileError" @file-complete="onFileComplete" &gt; &lt;uploader-unsupport /&gt; //不支持上传时显示内容 //这个组件也有两个上传的按钮 但是我这边给隐藏了 自定义了下拉框 点击的时候 获取对应的实例 然后触发点击事件 &lt;uploader-btn id="uploader_btn" ref="uploadBtn" &gt;选择文件&lt;/uploader-btn&gt; &lt;uploader-btn id="uploader_btn" ref="uploadFolderBtn" :directory="true" &gt;选择文件夹&lt;/uploader-btn&gt; //可拖拽的区域 &lt;uploader-drop class="drop"&gt; //我把这个table区域变成可拖拽的了 具体看自己写的内容吧 &lt;el-table&gt;&lt;/el-table&gt; &lt;/uploader-drop&gt; //这是上传文件显示的上传弹框，在右下角 有文件上传时显示 默认是隐藏 &lt;div v-show="isShowDropUploadFileLists" class="drog_list" &gt; &lt;uploader-list&gt; &lt;div slot-scope="props" class="file-panel" :class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b179658b88f6ad7850bed6bbd6593c70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61bd23bcd0f898a16c5dc1c6a0b7b8ac/" rel="bookmark">
			Python时间序列分析--ARIMA模型实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python时间序列分析–ARIMA模型实战案例,利用ARIMA模型对时间序列进行分析的经典案例（详细代码） **本文将介绍使用Python来完成时间序列分析ARIMA模型的完整步骤与流程,绘制时序图，平稳性检验，单位根检验，白噪声检验，模型定阶，参数估计，模型检验等完整步骤。Python建立时间序列分析–ARIMA模型实战案例时间序列指的是将带有同一指标单位的数值按照产生时间的先后顺序排成的数列，对时间序列分析的主要目的是对目前已有的数据对未来进行预测。本文将使用将差分移动自回归模型(ARIMA)来对中国区域CH4浓度未来变化趋势做预测。
步骤：
（1） 首先判断时间序列数据是否平稳，若平稳，则进行下一步，若不平稳，就通
过差分处理将序列变为平稳，为保证数据的准确性，差分次数应该不超过2。
（2） 判断时间序列是否是白噪声序列，如果是白噪声序列，那么该不序列并不适合ARIMA 模型分析，若不是，则进行下一步。
（3） 模型定阶，通过自相关函数 ACF 和偏自相关函数 PACF 来决定模型的阶数
P、Q,也可以通过Bayesian Information Criterion（贝叶斯信息量BIC）准则来确定。
（4） 建模并进行残差分析和白噪声检验。
（5） 对时间序列数据使用训练完成的 ARIMA 模型进行预测，并对差分的数据进
行还原。
参考文章：
https://blog.csdn.net/qq_45176548/article/details/111504846#comments_14302892
https://blog.csdn.net/weixin_41013322/article/details/111221251
https://blog.csdn.net/u010414589/article/details/49622625
所用csv文件形式，只用这一列即可。
第一步导包 import decimal import sys import os import statsmodels from math import sqrt from sklearn.metrics import mean_absolute_error from sklearn.metrics import mean_squared_error from sklearn.metrics import r2_score import warnings import seaborn as sns import matplotlib as matplotlib import math import matplotlib from keras.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61bd23bcd0f898a16c5dc1c6a0b7b8ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ff67f38f71d1decacafb14e3735555/" rel="bookmark">
			angular同一页面跳转重新执行方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：当收到导航到当前URL的请求，Angular路由器会忽略，重复点击同一链接页面不会刷新，也不会重新执行ngOnInit函数
解决：
1、跳转时给Router中增加参数
this.router.navigate([path],{queryParams:{lang:'zh-cn'}}) 2、在组件中订阅queryParamMap，判断有lang字段就重新执行init方法
constructor( private sanitizer: DomSanitizer, private routerInfo: ActivatedRoute,) { this.routerInfo.queryParamMap.subscribe(params =&gt; { if (params.get('lang')) { this.init(); } }); } init(): void{ console.log('重新执行了') } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcadfc1322019c92a3fe4559abd88590/" rel="bookmark">
			面试题 01.02. 判定是否互为字符重排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
首先我们想到用hashmap因为她可以记录键值对，hashmap是按键查找所以我们把字符串里的每个字符遍历出来作为键
而他们出现次数作为值
通过hashmap的getOrDefault方法我们可以得到字符的出现次数
遍历完s1开始遍历s2
再为s1量身打造的map基础上根据s2对value进行更改
如果出现负数说明s2某个字母出现次数比在s1多直接返回false
我们还需要一个特判那就是：s1比s2长，那就不会出现负数
import java.util.HashMap; public class Solution0102 { public static boolean CheckPermutation(String s1, String s2){ HashMap&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;s1.length();i++){ map.put(s1.charAt(i),map.getOrDefault(s1.charAt(i),0)+1); } for(int i=0;i&lt;s2.length();i++){ map.put(s2.charAt(i),map.getOrDefault(s2.charAt(i),0)-1); if(map.get(s2.charAt(i))&lt;0)return false; } if(s1.length()&gt;s2.length())return false; return true; } public static void main(String[] args) { //在Java中，静态方法对应工具类，非静态方法对应对象 boolean b = CheckPermutation("abc","cab"); System.out.println(b); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69775cf440d0e31268c074fd4c18a208/" rel="bookmark">
			数据分析师是怎样的岗位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：上海数聚
如果要说当下最热门的职业，数据分析师绝对可以算得上一个。但是这个职业到底是做什么的？相信很多人还不甚了解，本文就带大家来简单了解一下这个岗位。
按技能来说，当前数据分析涵盖的内容主要有如下几大方面：
1.BI软件操作（Microstrategy、Tableau、Power bi、帆软、Qlik、IBM、Oracle等）（前端报表开发）
2.统计分析软件：SAS、Sass等（跟BI软件有趋同和取代趋势）
2.SQL、数据库开发、ETL（后端数据库及数据仓库搭建）
3.统计学
4.运营模型（业务向分析模型）
5.Python或者R（数据挖掘、AI）
2015年开始，敏捷BI软件开始挤占市场并迅速取代传统BI的统治地位，进而国内还是国外都开始大肆涉足BI领域，其实敏捷BI并不是比传统BI高级，但是敏捷BI可以代表BI的重要发展方向，其最主要的一个特征就是 ：个人及小型团体获取并分析数据的门槛大大降低。而也由于这个核心特征，数据分析师这个岗位自16年起被宣传得很热。但目前其涵盖的内容其实偏广，需要求职者们仔细的考量和权衡。
从岗位职责来看，数据分析师这个岗位所涵盖的工作内容可以分为以下几个方向：
1.业务数据分析。在互联网企业，专业的业务型数据分析师主要是通过数据模型和专业知识，对用户和业务如何“增长”做出分析，或者对产品本身的效果，通过数据的维度进行监控，并得出建议。总得来说是一个支持沟通岗位，要求对业务十分了解，有清晰的逻辑和沟通能力，输出形成各种分析报告。对于技术的要求主要停留在Excel、敏捷BI软件的基本使用和出色的文字及PPT能力上，需要能用SQL语言进行基本的数据获取。
2.BA（Business Analytics）这既是一个岗位，也是一个国外兴起的新兴专业。作为岗位来说：要懂技术而不需要会技术，要懂业务并且化为技术逻辑。核心职责是“需求分析”，即结合客户业务需求，归纳文档，制作报表/产品原型，形成数据字典，提供给技术实施（前端后端）人员查看。业内的话，这个岗位还会要兼顾售前（区别于销售，主要是投标、报价方面的工作）、产品经理、项目经理的部分或者全部职能。视公司情况而定（此岗位以乙方公司居多）（甲方乙方也会有区别，但核心职能不变）。作为专业来说：这是一门统计学+商科（偏经济、财会、金融）+计算机科学的复合学科。
3.技术实施人员（偏前端报表方向）：一般来说，要求精通BI软件、会Excel、会用SQL进行ETL工作。乙方公司的主要职责是前端报表开发（做好前端图表计算逻辑、完善交互、美观界面、与后端ETL核对数据）；甲方公司的主要职责是：结合新需求制作报表、运维（修改前端报表）、取数等。
4.数据挖掘和AI大数据开发，这个需要结合python和R，技术向更深，同时需要掌握较为复杂的技术逻辑和统计学模型。也有称其为数据科学家（data scientist）
趋势上来说，数据分析师的第一、二种是沟通型+技术型复合岗位，第四种是高级技术岗位，但第三种，目前市面上基数最大，但很容易被学会了BI前端软件的业务人员取代。数据分析师这个岗位，长远来看是容易被“边缘化”的一个岗位，很难作为一个独立的岗位存在，必然是依附于业务或者IT，而逐渐地化为IT或者业务人员的一种技能。单纯地“帮助决策、设定目标”“提供数据分析支持”这种类似于“军师”一般的存在，并非不可能，但现实角度来说，做到这样很难。当然比起很多职业，它有其特殊性和优势，但这是建立在对岗位和技能清晰的认知之上的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473bbffa32ce8bb023833864914edd83/" rel="bookmark">
			设计模式 组合模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 介绍
二 示例和代码
一 介绍 又叫做整体-部分模式
属于结构型设计模式。
定义:
将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
主要优点:
1 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象还是组合对象。简化了客户端代码。
2 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。
适用场景：
描述整体与部分的关系时。
二 示例和代码 比如要统计一个中学的全校学生人数，学校是包括年级的，年级又包括班级，学校--年级--班级 就是整体与部分的关系，我们可以先汇总班级的人数，得到年级的人数，再汇总年级的人数，得到全校总共的人数。
package com.qing.compose; public interface ICounter { int count(); } package com.qing.compose; public class Classes implements ICounter { private int sum = 0; public Classes(int sum) { this.sum = sum; } @Override public int count() { return sum; } } package com.qing.compose; import java.util.ArrayList; import java.util.List; public class Container implements ICounter { private List&lt;ICounter&gt; list = new ArrayList&lt;&gt;(); public void add(ICounter counter) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473bbffa32ce8bb023833864914edd83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d36ef0526c39fdd74a2256b9c63f7f/" rel="bookmark">
			Android Studio如何修改AVD（模拟器）路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟器默认的存放位置为C:\Users\用户名\.android
那么我们如何修改呢
首先我们需要新建一个环境变量（系统变量）名为"ANDROID_SDK_HOME"，变量值为存模拟器的地址
之后我们再删除之前的默认存放地址，就可以啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c866921fa474ff6b14a4d8428a44fb/" rel="bookmark">
			Linux系统离线安装包及其依赖的下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 我们在Linux系统下进行项目开发时，经常会出现缺少某些依赖库或者开发包的情况，这时候一般会通过使用apt命令去联网下载。但在某些特殊情况下（例如终端硬件不支持网络连接，周边缺少有线与无线网络，或者需要批量安装程序到很多终端上时），就需要我们先将对应的依赖环境安装包下载下来，然后拷贝到对应终端上手动安装。以下就针对Linux系统下载与安装离线安装包以及依赖包的相关知识进行整理。
二、APT-Linux软件包管理工具 APT(Advanced Packaging Tool)，是一个命令行实用程序，是工作于Debian, Ubuntu等相关linux发行版上的软件包管理系统。它提供了如自动检索、配置和安装软件包等功能来简化软件的管理。通过apt命令，能够从互联网的软件仓库中搜索、安装、升级、卸载软件等。大多数apt命令必须以具有sudo权限的用户身份运行。
APT命令可以简单分为两类，一类是apt-xxx(例如apt-get、apt-cache)系列命令，一类是apt。两者都能够用于处理软件包，但apt-xxx系列命令将对软件包的管理操作分的很细致与分散，对于新手终端用户不太友好。而apt是在原有 apt-get 和 apt-cache 基础上，对基础软件包管理操作进行简化和优化，专为新手终端用户设计的命令行工具，可以看作 apt-get 和 apt-cache 命令的子集, 可以为包管理提供必要的命令选项。
从上面的表格可以知道，使用apt命令，我们可以不用关注在进行不同操作时需要使用apt-get还是apt-cache命令，简化了软件包命令操作。不过由于apt命令是专为终端用户设计，对于基础的软件包管理操作，在交互性上相对传统的 apt-xxx 命令有了一定的提升，但这是通过牺牲向后兼容性得到的，因此在脚本等场景下，应当使用更强调向后兼容性的传统 apt-xxx 命令。并且由于apt作为一个志在简化基础软件包管理操作的命令，对于许多高级操作，例如使用 apt-mark 固定软件包版本，是完全没有涉及的，因此在需要用到一些对软件包的高级操作时，应当使用apt-xxx命令。而在进行一些软件包基础操作时，使用apt命令即可。
1、语法 apt [options] [command] [package ...] options：可选，选项包括 -h，-y等等。command：要进行的操作。package：要进行操作的包名。 2、常用option 选项作用-h显示帮助信息-y在需要确认的场景中回应 yes-v显示APT详细的版本号-d仅下载，不安装-f尝试修正系统依赖损坏处 3、常用command 命令作用list根据名称列出软件包search搜索软件包描述show显示软件包细节install安装软件包reinstall重新安装软件包remove移除软件包autoremove卸载所有自动安装且不再使用的软件包update更新可用软件包列表upgrade通过安装/升级软件来更新系统full-upgrade通过卸载/安装/升级来更新系统edit-sources编辑软件源信息文件download下载 以下对常用的apt命令进行简要说明：
1)sudo apt update 从远程仓库更新可用软件包列表到本地。如果长久不更新，那么新版本的软件包将不会被其他apt相关命令下载安装。
2)sudo apt upgrade [package_name] 若指定包名，则升级指定软件包；若未指定包名，则升级所有可更新的软件包。（如果升级某个包需要卸载其他包则不做处理）
3)sudo apt [-y] [-d] install package_name1 [package_name2] … 安装指定软件包，若安装多个包，则使用空格隔开，也可以用来安装本地deb文件。可以添加"-y"选项用来跳过安装过程中的确认步骤；可以添加"-d"选项用来下载对应的软件离线安装包,下载的软件包默认存放位置是/var/cache/apt/archives。
4)sudo apt remove package_name1 [package_name2] … 卸载指定软件包，若卸载多个包，则使用空格隔开。使用remove会保留配置文件，使用purge可以完全移除软件包。
5)apt download package_name 下载指定的软件包，存放位置为执行命令的窗口所在目录。
6)sudo apt list 显示出所有可用的软件包。存在以下几种扩展用法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c866921fa474ff6b14a4d8428a44fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c23b3a7898d27732091677dff5fc96/" rel="bookmark">
			对接海康设备-vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康官方Demo
海康开放平台
对接海康综合安防管理摄像头
说明：官方Demo是原js代码，自己改改就能用，非常简单，下面这个是改成vue的
浏览器需要装的插件↓↓↓↓
https://download.csdn.net/download/qq_39654518/86723796
首先要在index.html页面引入相关插件，建议在这个页面引入，其他页面引入可能无效
&lt;!-- 海康摄像头 --&gt; &lt;script src="./static/plugins/hik/jquery-1.12.4.min.js"&gt;&lt;/script&gt; &lt;script src="./static/plugins/hik/jsencrypt.min.js"&gt;&lt;/script&gt; &lt;script src="./static/plugins/hik/jsWebControl-1.0.0.min.js"&gt;&lt;/script&gt; 项目发布打包需要的配置(否则发布后可能找不到资源)：
// 海康摄像头 window.SITE_CONFIG.cdnUrl + '/static/plugins/hik/jquery-1.12.4.min.js', window.SITE_CONFIG.cdnUrl + '/static/plugins/hik/jsencrypt.min.js', window.SITE_CONFIG.cdnUrl + '/static/plugins/hik/jsWebControl-1.0.0.min.js', 看回放vue页面：
&lt;template&gt; &lt;el-dialog title="测试" :close-on-click-modal="false" :visible.sync="visible" :modal="false" :show-close="false" width="1040px" &gt; &lt;!-- 用于播放的容器 --&gt; &lt;div id="playWnd" class="playWnd"&gt;&lt;/div&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;el-button type="primary" @click="close()"&gt;关闭&lt;/el-button&gt; &lt;el-button type="primary" @click="startPlayback"&gt;重新连接&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { visible: false, initCount: 0, pubKey: '', oWebControl: '', cameraIndexCode: '', // 设备编码 enforcementStartTime: '', // 开始时间 enforcementEndTime: '' // 结束时间 } }, activated () { }, methods: { // 创建WebControl实例与启动插件 initPlugin (cameraIndexCode, enforcementStartTime, enforcementEndTime) { // vue弹框调这个方法进来，，传入 【摄像头code，回放开始时间，结束时间】 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67c23b3a7898d27732091677dff5fc96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c897294ca783c855f013db9ac92d9d0/" rel="bookmark">
			PPT文字排版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4种排版策略：亲密性、对齐、对比、万能配色发法
亲密： 对比：对比主要分为大小的差异（包括加粗、字号等等）、以及颜色的差异 对齐：对齐即把两个以上的元素排版整齐，这会给人稳定、安全的感觉 工具：视图-网格和参考线
配色法则：631法则 6：背景色占60% 3：辅助色占30% 1：点缀色占10%
小结：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2432c4d153a60110323f4a488150f463/" rel="bookmark">
			git下载错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git下载错误
git 下载出现以下错误
error: RPC failed; curl 56 Recv failure: Connection was reset fetch-pack: unexpected disconnect while reading sideband packet fatal: early EOF fatal: fetch-pack: invalid index-pack output 网上大部分说是网络不稳定问题，使用以下指令可解决
git config --global http.postBuffer 524288000 尝试可以解决，在下载的时候最好必要跳到别的界面去，可能会导致下载不成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d67dc37230f7f5f169d509d4e053c5c/" rel="bookmark">
			设计模式 备忘录模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 介绍
二 示例和代码
一 介绍 又叫做快照模式。
属于行为型模式。
定义:
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
主要角色:
1 发起人：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。
2 备忘录：存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。
3 管理者：对备忘录进行管理，提供保存和获取备忘录的功能，但其不能对备忘录的内容进行修改。
主要优点:
1 提供了一种可以恢复状态的机制。
2 实现内部状态的封装。
缺点:
如果状态数据很大很多，那么备忘录对象会非常耗内存。
应用场景:
需要后悔药的时候，比如各种编辑器的恢复撤销功能，数据库与操作系统的备份操作。都可以使用备忘录模式。
二 示例和代码 比如京剧变脸，可以变不同颜色的脸，比如变到某种脸的时候，撤销成上次的脸。
把要保存的信息（脸）放在memo中
package com.qing.memo; public class Memo { private String face; public Memo(String face) { this.face = face; } public String getFace() { return face; } public void setFace(String face) { this.face = face; } } 提供创建备忘录和恢复备忘录数据的功能，它可以访问备忘录里的所有信息。
package com.qing.memo; public class Initiator { private String face; public String getFace() { return face; } public void setFace(String face) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d67dc37230f7f5f169d509d4e053c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad753653a9976fd8b1bbf858d53b70f/" rel="bookmark">
			千字word转ppt技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、大纲
将word文字复制到ppt中的大纲中，分段（分成多页ppt）
2、文字排版
标题和内容的文字大小调整
3、转动效果
实现幻灯片间自然过渡：复制粘贴出另外一张ppt，第一张突出标题，复制粘贴出来的那一张图片内容
4、美化封面
设置背景图，文字部分了插入虚化图片，图层置于下一层
小结：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0428ce60f63cb9bce19a0f38f9912e31/" rel="bookmark">
			Ubuntu 18.04下通过Matlab runtime使用c&#43;&#43;调用自己编写的matlab函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 18.04下通过Matlab runtime使用c++调用自己编写的matlab函数 文章目录 Ubuntu 18.04下通过Matlab runtime使用c++调用自己编写的matlab函数前言一、安装Matlab runtime1.1下载Matlab runtime1.2安装Matlab runtime 二、matlab .m文件编译C++1.实例2.编译 三、运行走起来1.实例2.编译3.运行 下载地址 前言 写这篇博文的主要目的就是记录一下自己在linux系统下，通过Matlab runtime，使用c++调用自己编写的matlab函数所需要的问题，网上教程很多，但是对自己来说，有一点乱。通过记录，帮助自己及别人熟悉这个过程，说一下自己安装过程中的问题及浅薄见解。
一、安装Matlab runtime Matlab runtime作用就是在电脑没有安装MATLAB环境下，去调用MATLAB的相关函数，安装过程如下：
环境下载：https://ww2.mathworks.cn/products/compiler/matlab-runtime.html
安装帮助：https://ww2.mathworks.cn/help/compiler/install-the-matlab-runtime.html
1.1下载Matlab runtime 注：一定要注意，下载的版本一定要跟你编译的matlab版本相对应。
我的matlab版本为R2018b，所有我下载的Matlab runtime的版本为9.5
1.2安装Matlab runtime 先将压缩包进行解压
unzip MCR_R2018b_glnxa64_installer.zip 然后进入我们的解压文件夹，进行安装，网上很多是使用默认安装方式进行安装的，
./install -mode silent -agreeToLicense yes 但是他会有一个东西安装不上，于是我就采用另外的方法，直接通过他文件夹里面的install的方式进行安装。
sudo ./install 这样安装的话，会弹出图形化安装界面，按照下一步，下一步进行操作。
安装文件夹最好按照默认的，也可以改成自己的想要设置的目录。
最后会出现这个环境变量，我的没有添加到 ~/.bashrc 里面，网上很多教程都是进行设置的，我没有，但是最后成功了。
不知道为什么，我添加完成之后，所有的工作空间和功能包进行catkin_make的时候，都会报错，注释掉之后，就不会有问题。不知道为什么。
经过上面操作，Matlab runtime就安装完成了。
二、matlab .m文件编译C++ 1.实例 代码如下（示例）：
function [ C ] = myFunc(A, B) C = A+B; end 2.编译 windows环境下的matlab编译的话是生成 dll 之类的文件，linux环境下生成的是 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0428ce60f63cb9bce19a0f38f9912e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c770b2fa9b19adc304de4e6e63d91f40/" rel="bookmark">
			微信公众平台服务器TOKEN验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php
define("TOKEN", "weixin");
$wechatObj = new wechatCallbackapiTest();
//token 验证
//$wechatObj-&gt;valid();
//输出
$wechatObj-&gt;responseMsg(); class wechatCallbackapiTest{
public function valid(){
$echoStr = $_GET["echostr"]; //valid signature , option
if($this-&gt;checkSignature()){
echo $echoStr;
exit;
}
}
public function responseMsg(){
//get post data, May be due to the different environments
$postStr = $GLOBALS["HTTP_RAW_POST_DATA"]; //extract post data
if (!empty($postStr)){ $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);
$fromUsername = $postObj-&gt;FromUserName;
$toUsername = $postObj-&gt;ToUserName;
$keyword = trim($postObj-&gt;Content);
$time = time();
$textTpl = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c770b2fa9b19adc304de4e6e63d91f40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213ca665c3bffe99841b4ce71106619d/" rel="bookmark">
			错误解决：failed calling webhook “dec-autonomy.xxx.io“: failed to call webhook：post
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 今天在删除资源时，发现删除pod命令报错（强制删除也报错），如下：
因此，网上找了一下，有一个这个答案：应该有种资源MutatingWebhookConfiguration或 ValidatingWebhookConfiguration实际上注册了 webhook使用 Kubernetes API 服务器。您需要先删除该资源，从而从 Kubernetes API 服务器取消注册 webhook。
解决方法 查询是否存在资源：MutatingWebhookConfiguration或者ValidatingWebhookConfiguration，发现存在，则删除
删除完成后，即可成功删除对应的pod，如下：
好了，问题成功解决～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189177ca10e74aee9978937a9cab4dea/" rel="bookmark">
			深度学习，识别红绿灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#准备工作，导入所需要的库 import cv2 import numpy as np #读取视频 cap = cv2.VideoCapture(r"红绿灯.mp4") #获取帧率 fps = cap.get(cv2.CAP_PROP_FPS) while cap.isOpened(): ret, frame = cap.read() cv2.namedWindow("frame", 0) #0可调大小 cv2.resizeWindow("frame", 960, 540) #设置长和宽 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) #将视频以灰度图展示 cv2.putText(gray, 'fps: ' + str(fps), (0, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2) # 在展示窗口中显示帧率 # 划定三个感兴趣区域分别为R, Y, G # ROI划定规则:图像矩阵名称[上 : 下, 左 : 右] R = gray[452:454, 594:596] Y = gray[446:448, 630:632] G = gray[444:446, 672:674] # 为划定的感兴趣区域赋予变量 sum_R = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189177ca10e74aee9978937a9cab4dea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e9190708d1027b0436a6284a683e64/" rel="bookmark">
			u盘格式化后数据能恢复吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在u盘可以放在你身边某个犄角旮旯里，不占地方，需要的时候翻出来，直接插在电脑里，把存储文件资料找回即可，可以带到任何地方。但是在使用u盘的过程中，难免会因为一些故障而导致u盘格式化。这一下子难住我们了，很多时候我们并不会去备份u盘上的内容。如果操作了难免删除u盘里的很多重要文件。那么遇到u盘格式化后数据能恢复吗?接下来不妨与小编一起来看看吧。
如果出现这样的问题，请先关闭弹出的格式化提示窗口，然后尝试使用以下方法进行恢复:
一;用电脑系统修复u盘
第一步:右击u盘，选择“属性”进入属性页面;
第二步:在属性栏找到“工具”页面，点击“开始检查”按钮;
第三步:点击确认后检查修复。一般问题可以通过系统修复来解决。
二;借助专业的失易得数据恢复软件来进行恢复，具体操作如下：
第一步：打开浏览器，输入“失易得数据恢复”，下载安装软件并登录，并且在“分区与设备”中选择符合自己情况的恢复模式，即可快速扫描磁盘数据。或者软件操作不太熟练的朋友们还可以点击下方的“标准模式”进行切换，根据引导进行更简便的操作;
第二步：把U盘连接到电脑上，运行软件， 选择“误格式化磁盘”功能。
第三步：选择要恢复文件的U盘，下一步。
第四步：选择要恢复文件的数据类型，开始扫描。
第五步：扫描完成，在文件里找到我们要恢复的文件，预览确认一下，无误后勾选点击恢复按钮即可。
u盘格式化后数据能恢复吗?不妨使用上述的方法，就可以解决此问题了。有需要的朋友可以去试试看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5fe81681a604939710a50717d2b508/" rel="bookmark">
			springboot整合mybatis-plus代码生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.baomidou.mybatisplus.generator.FastAutoGenerator;
import com.baomidou.mybatisplus.generator.config.OutputFile;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import java.util.Collections;
@Test
void CG2() {
FastAutoGenerator
// 数据源配置
.create("jdbc:mysql://localhost:3306/mybatis-plus", "root", "123456")
// 全局配置
.globalConfig(builder -&gt; {
builder.author("cyr") // 设置作者
.outputDir(System.getProperty("user.dir") + "/src/main/java") // 指定输出目录
.commentDate("yyyy-MM-dd") //注释日期
.disableOpenDir(); //禁止打开输出目录，默认:true
})
// 包配置
.packageConfig(builder -&gt; {
builder.parent("com.cyr") // 设置父包名
.moduleName("mp") // 设置父包模块名
.entity("pojo") // pojo 实体类包名,其它包名同理
.other("utils") // 自定义文件包名
.pathInfo(Collections.singletonMap(OutputFile.xml, System.getProperty("user.dir")+"/src/main/resources/mapper1")); // 设置mapperXml生成路径
})
// 策略配置
.strategyConfig(builder -&gt; {
builder.addInclude("user", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc5fe81681a604939710a50717d2b508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b2d065f4d77c19238543968b2c7f5e/" rel="bookmark">
			i.MX6ULL - Ubuntu 18.04.05 LTS根文件系统移植教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		i.MX6ULL - Ubuntu 18.04.05 LTS根文件系统移植教程 目录 i.MX6ULL - Ubuntu 18.04.05 LTS根文件系统移植教程1、根文件系统配置及测试3、SSH远程登录测试2、samba与windows数据互传测试4、如何将开发板设置为静态IP地址 1、根文件系统配置及测试 根文件系统的移植很简单的，ubuntu官方已经帮我们做好了，可以下载下来直接时候，但是这个根文件系统太过于精简(例如连ifconfig都没法使用)，一些常用的工具都没有，所以我们还需要自己简单的配置一下才行。
ubuntu-base文件系统下载地址：http://cdimage.ubuntu.com/ubuntu-base/releases/
注：以下操作均在root下进行！
安装运行模拟器：
sudo apt install qemu-user-static 创建用于ubuntu-base根文件系统目录，并解压到该文件夹：
mkdir /ubuntu-18.04.5-lts-rootfs tar xvf ubuntu-base-18.04.5-base-armhf.tar.gz -C /ubuntu-18.04.5-lts-rootfs cd /ubuntu-18.04.5-lts-rootfs 拷贝CPU架构为ARM的模拟器到根文件系统：
sudo cp /usr/bin/qemu-arm-static ./usr/bin/ 拷贝主机下的DNS配置文件，没有这个文件的话我们无法使用apt-get下载软件：
sudo cp /etc/resolv.conf ./etc/resolv.conf 添加源，打开sources.list这个文件，在这个文件最后追加中科大源：
vi etc/apt/sources.list 添加：
deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-backports main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-proposed main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-security main multiverse restricted universe deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b2d065f4d77c19238543968b2c7f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd899d2bea8a79b42af289390b48403/" rel="bookmark">
			Vue组件间通信（消息订阅与发布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用pubsub-js 来实现在vue中消息的订阅与发布 1.安装 pubsub-js npm i pubsub-js 2.导入 pubsub-js import pubsub from "pubsub-js" 3.需要数据的组件订阅消息 pubsub.subscribe("消息名",(msg,data)=&gt;{ //msg中保存的是消息名 console.log("XXX发布了消息,接收到的数据为：",data) }) 4.发送数据的组件发布消息 pubsub.publish("消息名",data) //data为要发送的数据 这样，就可以实现组件间的通信了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f0017ec4d16806bf4a73431921a699/" rel="bookmark">
			axios取消请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios取消请求方法一
let send_btn = document.getElementById("send_btn") //发送请求按钮 let cancel_btn = document.getElementById("cancel_btn")	//取消请求按钮 let cancel = null; send_btn.onclick = function(){ if(cancel != null){ cancel() //如果上一次的请求还在继续，则取消 } axios({ method:"get", url:"http://localhost:3000/test.php", cancelToken:new axios.CancelToken(function(c){ cancel = c }) }).then(response=&gt;{ //处理响应数据 cancel = null }).catch(reason=&gt;{ //错误处理 }) } cancel_btn.onclick = function(){ //取消请求 cancel() } axios取消请求方法二
//利用source对象创建canceltoken let send_btn = document.getElementById("send_btn") //发送请求按钮 let cancel_btn = document.getElementById("cancel_btn") //取消请求按钮 let source = axios.CancelToken.source(); send_btn.onclick = function(){ // 判断上一次的请求是否还在继续，如果还在继续，则取消上一次的请求 if(source.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f0017ec4d16806bf4a73431921a699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71fdaa5bf2a4da070624de7bec48e017/" rel="bookmark">
			Oracle数据库中的集合（联合数组，嵌套表和可变数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.集合
1.联合数组
（1）格式定义
2.嵌套表
（1）格式定义
（2）初始化
（3）元素有序性
4.可变数组
5.集合的属性和方法
（1）COUNT属性
（2）DELETE方法
①DELETE方法形式
（3）EXTEND方法
② EXTEND具体形式
（4）EXISTS方法
（5）LIMIT属性
（6）FIRST/LAST属性
（7）NEXT/PRIOR方法
（8）TRIM方法
①TRIM形式
Oracle学习的相关知识点（汇总）
1.集合 PL/SQL中使用如C/C++等高级语言一样的数组形式，用来管理多行数据的结构体。
集合就是一个列表，如python中的列表一样，这些存在列表中的元素可以是有序的，也可以是无序的。其中有序的索引是唯一性的数字下标，而无序列表的索引是唯一性的标识符，这些标识符可以是数字，哈希值以及字符串名（比如映射）。
以下主要讲述三种类型的集合：联合数组，嵌套表和可变数组。 1.联合数组 这里的联合数组就如同C/C++中的二维数组。
（1）格式定义 TYPE &lt;联合数组名&gt;
IS
TABLE OF &lt;数据类型&gt; INDEX BY BINARY_INTEGER;
如果要访问已经赋值了的联合数组：
&lt;联合数组名&gt;[index];
其中index表示第几个元素（下标索引），其数据类型属于BINARY_INTEGER； 例子：
--使用联合数组访问数据 SET SERVEROUTPUT ON; DECLARE TYPE V_NAME IS TABLE OF XSB.sid%TYPE INDEX BY BINARY_INTEGER; --声明变量 vx_name V_NAME; cnt number:=0; BEGIN select count(*) into cnt from xsb; DBMS_OUTPUT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71fdaa5bf2a4da070624de7bec48e017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb3c05e9c48d22bf00594863d4150b8/" rel="bookmark">
			Anaconda 虚拟环境 安装spyder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.激活环境: activate xxxx后
2.输入安装命令
pip install -U spyder -i https://pypi.tuna.tsinghua.edu.cn/simple --ignore-installed qtconsole --user 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ef3e934ee03603e8053b512aed93d9/" rel="bookmark">
			从git主分支创建新分支进行开发的流程及需要注意的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际开发过程中可能需要从git的主分支创建新分支以满足不同功能的开发需要与版本管理，下面记录从git的主分支(默认为master)创建新分支进行开发的步骤： 查看当前所在分支： git status 以及查看当前所有分支：
git branch -a 如果之前没创建过分支进行开发，一般只有本地master分支和远程master分支
创建新分支并切换至新创建的分支： git checkout -b '自定义分支名' 再利用
git status 正常的话可以看到已经切换到新创建的分支上
(Note: git checkout -b ‘自定义分支名’ 是在本地新建了一个和本地master内容一样的分支)
把新建的分支push到远端： git push origin '自定义分支名' 该步是为了在origin端创建新的分支
将本地分支与远端分支关联： git branch --set-upstream-to=origin/'自定义分支名' 这一步很重要，它是为了将本地新建分支与远端分支关联，以便后续push和pull等操作，如果没有这一步操作会在后续push操作时出现fatal: The current branch ‘自定义分支名’ has no upstream branch等问题
之后就可以在新的分支上进行开发，且不会影响主分支(master)的内容，如果想删除本地和远程分支，可以采取： git branch -d '自定义分支名' ##删除本地分支 git push origin --delete '自定义分支名' ##删除远程分支 上述流程不仅适用于从主分支新建分支，还适用于从分支新建分支
ps: 目前还没有对新建分支与主分支进行合并的需求，后续用到再来补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/273ced72f55be6cb008824e5585012c5/" rel="bookmark">
			CUDA安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 cuda的下载及安装 1.1 查看适合的cuda版本 我电脑上支持的cuda是11.6的
1.2 cuda toolkit下载 ​​​​​kCUDA Toolkit Archive | NVIDIA Developer
进入上述网页，找到适合的cuda
1.3 cuda toolkit安装 双击exe文件进行安装即可
1.4 配置环境 打开 设置-&gt;高级系统设置-&gt;环境变量 红框里的是系统自动添加的，蓝框里的有些情况系统不会自动添加，需要手动添加，添加时注意自己的路径。
NVCUDASAMPLES_ROOT C:\ProgramData\NVIDIA Corporation\CUDA Samples\v11.6 NVCUDASAMPLES11_6_ROOT C:\ProgramData\NVIDIA Corporation\CUDA Samples\v11.6 1.4 验证 win+R，输入cmd，输入nvcc --version查看版本号，输入set cuda查看设置的环境变量
2 cuANN下载及安装 2.1 cuDNN下载 下载地址如下，下载之前需要注册一下
https://developer.nvidia.com/rdp/cudnn-download
如下链接，有适合自己的版本
cuDNN Archive | NVIDIA Developer
2.2 cuDNN配置 将cuDNN解压到D盘
将三个文件夹拷贝到到cuda的安装目录下。默认的安装路径为
C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6 2.3 添加环境变量 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.6\bin C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/273ced72f55be6cb008824e5585012c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5fbe795400b08bb1cb63036881d9c3/" rel="bookmark">
			win11 解决Android Virtual Device Manager HAXM is not installed 报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录如何解决HAXM报错的记录供大家参考
我的电脑是win11系统
报错如下 HAXM is not installed
首先我点击install Haxm
然后出现下面的报错了。
接下来就是解决错误问题了，首先进入任务管理器
点击性能看下虚拟化是否已启用，我的已经启用了，如果你的没有启用搜索下启用的方法先启用起来在看下面的操作步骤。
然后点击Settings，去安装HAXM。
按下面的指示进入SDK Tools 安装HAXM，点击Apply开始安装。
安装中…
我安装完后，还是报错，然后接着来下面的操作
找到控制面板点击系统和安全
点击启用或关闭Windows
勾选下面箭头所指的windows虚拟机监控程序平台；虚拟机平台；然后点击确定。
接下来进入windows终端（管理员）
进入下面的页面
输入下面的内容：Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All 点击Enter
然后在重新安装下HAXM
然后重启电脑可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdcc5e7b0655297c419fe913a9430f3/" rel="bookmark">
			关于RGB888和RGB565互转代码实现方案推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么RGB888要转RGB565呢，这个问题尤其在嵌入式lcd屏中，因为RGB888占用24位，RGB565占用16位及2个字节。
2、例如嵌入式中的LCD屏接口一般位IIC、SPI、8080等，如果传送RGB888每个像素点就要多送一个字节，320*240的LCD屏就要多送76800字节的数据。
3、我看到的一般驱动代码中均是将RGB888进行相与移位等操作得到R，G、B类似操作。速度慢代码不精简。如何优化呢，这里我就开门见山了，使用结构体就能很好解决RGB888和RGB565互转。单使用结构体还不够好，就把结构体和共用体结合了。
4、以下是测试部分，使用原始方案RGB888转RGB565，及原始方案RGB565转RGB888，及新的方案。不难发现新方案测试结果和旧方案一样。
5、最后贴出具体代码，当前使用的是小端模式，切记51单片机一般位大端模式。
//作者：金丝草 //时间：2022/09/24 #include &lt;iostream&gt; //这里重申下，以下为小端模式 /***********************************RGB888 RGB565*************************************/ typedef union { uint32_t RGB888; struct { uint32_t dummy0:3; uint32_t RGB_B :5; uint32_t dummy1:2; uint32_t RGB_G :6; uint32_t dummy2:3; uint32_t RGB_R :5; uint32_t dummy3:8; }Work; }RGB888_struct; typedef union { uint16_t RGB565; struct { uint16_t RGB_B :5; uint16_t RGB_G :6; uint16_t RGB_R :5; }Work; }RGB565_struct; //输入一个RGB888的32位数据地址，返回转换后的RGB565 static uint16_t RGB888_To_RGB565(const RGB888_struct *RGB888) { RGB565_struct RGB565 = { 0 }; RGB565.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cdcc5e7b0655297c419fe913a9430f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b8b21415c87a162acecd1dd4f510ac/" rel="bookmark">
			vue表单中输入框事件的使用@input、@keyup.enter、@change、@blur
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、@input（v-on:input） 此触发方法适合在查询条件或实时规则校验中使用。
&lt;input type="text" placeholder="请输入查询内容条件" v-model="inputVal" v-on:input="search" value="" /&gt; 2、@keyup.enter 此触发方法与v-on:input方法区别在于：input事件是实时监控，每次输入都会触发调用，而@keyup.enter则是在键盘点击回撤按键触发，且在手机端则需要点击输入键盘上的确定按键触发。
3、@change 此触发方法和enter事件相似，在手机端都是要经过触发虚拟键盘的搜索键才会触发事件。使用方式同上input。
⚠️在iOS手机上可能出现的问题：
效果是输入值不用虚拟键盘触发方法就调查询接口进行数据查询，在安卓手机上没有问题，但iOS手机则回出现多次触发的情况。
解决办法：
通过使用watch对input的值进行监听，把需要绑定在input框的事件在监听到变动时进行调用。
4、@blur 失去焦点方法要满足输入框在输入完成、移到其他地方进行输入或操作是，触发该事件方法。使用该事件方法直接绑定验证发放即可。
⚠️如果使用mintui中的mt-field标签是，对应的blur（失焦）事件要执行时，要用@blur.native.capture=""来代替@blur。
&lt;mt-field label="用户名" placeholder="请输入用户名" type="text" v-model="username" @blur.native.capture="testUser"&gt;&lt;/mt-field&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9170a04ac032274060166cd0b8bb997/" rel="bookmark">
			Android Q 要来了，给你一份很“全面“的适配指南！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Q 越来越近了，最近 Google 又发布了 Android Q Beta 的第五个版本，眼瞅着这进度，在今年 Q3 季度，Android Q 就正式和用户见面了，在此之前，开发者必然又是面临的一波让人头疼的适配。
了解新特性，首推应该去看官方文档，官方已经给出了一份完整的新特性文档，在发布的这段时间，也一直在保持同步的更新。而作为开发者，我们更关心的是如何解决在我们现有的 App 上，保证 Android Q 的兼容性问题。
今天就给推荐给大家一份适配文档，以开发者的角度列一份适配清单，在 Android Q 还没来之前，先了解需要做什么，以及怎么做，到时候才不至于措手不及。
这份文档的出自 OPPO 开放平台，可能有人会觉得是 KPI 工程，但是你想想这些厂商每年耗巨资研发的旗舰机，用着最新的硬件，当然要搭配最新的系统，而用户在旗舰机上的体验，也是他们最关心的，所以每次 Android 发布新系统，这些厂商也在推进自己应用市场上 App 的适配工作。
你只需要想想他们做这件事的动机，就能知道这份文档肯定是花了心思的。文档我看过一遍，从场景出发来分析原因，并附上解决方案，很有参考意义。
文档比较长，大家可以先收藏，再跳跃阅读看自己关注的点。
一. 背景说明 本文档是基于谷歌安卓 Q 的 beta4 版本的变更输出的兼容性整改指导，如果后续 beta 版本有新的变更和新的特性，我们也会刷新文档的相关章节内容，请开发者持续关注。
二. 存储空间限制 2.1 背景 为了让用户更好地控制自己的文件，并限制文件混乱的情况，Android Q 修改了 APP 访问外部存储中文件的方法。外部存储的新特性被称为 Scoped Storage。
Android Q 仍然使用 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE 作为面向用户的存储相关运行时权限，但现在即使获取了这些权限，访问外部存储也受到了限制。APP 需要这些运行时权限的情景发生了变化，且各种情况下外部存储对 APP 的可见性也发生了变化。
在 Scoped Storage 新特性中，外部存储空间被分为两部分：
● 公共目录：Downloads、Documents、Pictures 、DCIM、Movies、Music、Ringtones 等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9170a04ac032274060166cd0b8bb997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25cd14049befa7d3699cafc58d5a4fa1/" rel="bookmark">
			Unity Pico Neo3 基础开发流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity Pico Neo3 基础开发流程 Pico 基础模块Pico 开发者平台Pico 管理中心Pico 实时预览 测试 Unity 模块项目创建基础XR 模块传送 模块锚点传送 模块射线抓取 模块手柄碰撞抓取 模块XR UI模块射线碰撞事件响应 模块Pico XR 健值操作 Unity Pico 简单应用 Pico 基础模块 Pico 开发者平台 链接: PICO 开发者平台
链接: PICO 文档中心
链接: Pico GitHub
链接: PicoXR SDK 官方存储库
如果是第一次进入需要先注册成为开发者。 然后下载SDK。 这个是 Unity相关的 SDK 注意下载的平台，并下载最新版。 我这里下载的是：PICO UnityXR Integration SDK v207。 解压： 最有用的就是这个 package.json 文件。 这个是 实时预览 和 Pico Neo3 串流工具。 解压之后的文件夹状态： 再把 PreviewTool_0402_Release.7z 解压。 PreviewTool_0402.apk ： 这个文件是 Pico Neo3 的安装包 在用 USB 数据线 连接到 PicoNeo3 把PreviewTool_0402.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25cd14049befa7d3699cafc58d5a4fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589d5507e0e63fa7490e380fdf2a85ca/" rel="bookmark">
			建筑物监测解决方案 GNSS北斗监测终端 建筑安全监测 位移监测 沉降监测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计讯物联建筑物监测解决方案基于GNSS北斗高精度定位技术，具备毫秒级感知能力，可迅速获取监测点建筑物的实时变化状态。其中，GNSS北斗高精度定位终端机TN521作为此方案数据采集传输中枢，拥有高精度变形监测实力、远程控制能力与智慧化管理能力，高度适配高精度卫星定位系统GNSS、形变、裂缝、渗压、位移、压力、应力、舞动、倾角、沉降、加速度、报警器等传感器。适用于高层建筑物、古建筑物、地下建筑、桥梁、高架桥、隧道等监测场景。
GNSS北斗高精度定位终端建筑物监测原理
计讯物联TN521定位遥测终端具备采集、通信、高精度定位能力，对接前端传感器、摄像头等仪器仪表，目标数据通过北斗、5G/4G蜂窝无线远传服务器，丰富协议库对接主流云平台，工作人员远程在线实时多维度监控，在线高清视频现场画面同步监控，目标数据24小时连续动态监测，精准监控建筑物细微变化，异常第一时间报警反馈，避免安全事故灾害。
计讯物联建筑物监测解决方案实例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/157bd065026d1f406890984e06cc88bb/" rel="bookmark">
			AJAX 识AJAX实现输入用户名实时查询数据库（POST）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		似沧海一粟，若寰宇一埃
文章目录 前言一、post请求，页面部分二、后端部分总结 前言 在注册的时候，你填入用户名，可以实时得知，是否重名
一、post请求，页面部分 四步：
创建XMLHttpRequest对象写回调函数开启通道发送请求
在开启通道之后（opened）在发送请求之前
设置请求头的内容类型来模拟form发送数据，才不会是null xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded") 还要再send（）方法中填写提交的数据（注意遵循HTTP协议name=value&amp;name=value）
xhr.send("username="+username) 用span，如果是div会自动提行
二、后端部分 去看代码
ajax1/ajax/src/com.bjpowernode.ajax.servlet.AjaxRequest4Servlet
总结 小技巧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efd3dfb296d1dc6a6d34b5f04ee3843/" rel="bookmark">
			SSL与SSH、TCP、UDP与ICMP解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSL与SSH、TCP与ICMP解析 1 SSL与SSH 从高层次来说，SSH与SSL都是帮助加密和验证两台计算机（例如：我们的笔记本电脑和我们网站的服务器）之间传递的数据的技术。基本上，它们都可以让事情变得更加安全。
通俗来讲，通常SSL用于加密两个位置之间传输的数据，例如我们的Web浏览器和我们正在访问的站点的服务器。SSL是在浏览器中添加"绿色挂锁"的东西，如果我们想在我们的网站上安全地接受信用卡信息（或其他敏感数据），那么SSL就是我们要使用的东西。
SSH主要用于远程登录到另一台计算机（例如我们的云服务器）并创建安全连接以发出命令（通过SSH隧道的形式）。例如，如果我们想要连接到站点的服务器以使用WP-CLI执行命令，这个时候我们就可以使用SSH。当我们想要使用SFTP访问连接到我们的服务器时，我们也会用到SSH。
1.1 SSL（Secure Sockets Layer，安全传输信息） SSL代表安全套接层，它是一种网络协议可在非安全网络中提供安全传输。SSL需要证书并适用于公钥加密。SSL在网络环境的各种操作中实现，例如网页浏览、消息传递、电子邮件和FTP等其他协议。
1.1.1 产生原因 传统的HTTP协议采用明文传输数据，用户数据存在被窃取和篡改的风险。而部署了SSL证书的网站，就可以使用安全的HTTPS息协议进行访问（例如：百度）。当浏览器访问以https://开头的URL时，浏览器通过SSL连接使用HTTP。SSL协议会在数据传输之前对数据进行加密再进行网络传输，保证了用户护具在数据链路上的安全。
主要原因：就是保证用户数据的安全【传输用户数据之前，前进行加密】 1.1.2 作用 SSL证书，主要是部署在网站服务器中，通过SSL协议实现浏览器客户端与网站服务器通信链路上的数据加密，并认证网站服务身份，防止钓鱼网站。它用来保证我们的浏览器和网站服务器之间的安全通信，避免网络"中间人"窃取信息。
1.1.3 拓展（SSL两个子协议） SSL协议包含了两个子协议：
记录协议（SSL Record Protocol）：说明了该如何封装SSL的数据包。位于OSI七层模型的会话层，为不同机器上的用户建立和管理会话。握手协议（SSL Handshake Protocol）：说明通信双方如何协商共同决定使用什么算法以及算法使用的key。它在OSI七层模型会话层的下一层— — 表示层上，对他们之间的网络连接进行加密解密。 1.2 SSH（Secure Shell，安全登录远程服务器） SSH代表安全外壳，是一种加密的网络协议，提供了一种安全的方式来远程登录到另一台计算机并发出命令，同时允许我们通过网络将文件从一台机器传输到另一台机器。（本地文件上传到云服务）
1.3 SSL与SSH区别 编号SSLSSH1SSL没有像SSH这样的用户名/密码验证系统SSH是加密隧道协议，有用户名/密码认证系统2工作在443端口工作在22端口3是异步的，因为它取决于证书完全依赖于网络隧道4SSL加密浏览器和服务器之间的通信SSH加密了两台计算机之间通过互联网的通信5SSL通常适用于X.509数字证书以进行服务器和客户端身份验证SSH适用于服务器和客户端身份验证过程的三阶段过程6SSL最适合安全传输信用卡和银行等关键数据使用有效地在互联网上安全地执行命令7SSL采用对称、非对称加密算法的组合来提供数据隐私SSH通过对称密钥算法提供数据机密性 2 TCP、UDP与ICMP TCP、UDP都是网络传输协议，承载数据包传输用的
TCP（TCP，Transmission Control Protocol）：传输控制协议，特点：可靠传输，有3次握手保证数据传输的可靠性。如果有丢包，则重新传输数据。像FTP文件传送，远程登录，POP3电子邮件，这些都是基于TCP协议的，因为他们需要保证传输的完整性。UDP（UDP，User Datagram Protocol）：用户数据报协议，特点：实时性强，有丢包还继续传输，通常像语音、电话、视频都是UDP传输，偶尔丢几个报不影响通信。ICMP（Internet Control Message Protocol）：Internet控制报文协议，它是TCP/IP协议簇的一个子协议。不承载数据，不是用来传输用户数据的，是用来传递控制消息的。即：网络通不通，主机是否可达。ping命令就是基于ICMP的。IGMP（Internet Group Management Protocol）：因特网组管理协议，是TCP/IP协议簇中负责IP组播成员管理的协议，在组播网络中，IGMP协议在最后一跳路由器与组播接收者间运行，通俗说即：“IGMP协议运行于主机与主机直接相连的组播路由器之间，主要用于维护组播成员关系。”【将一个ip包拷贝给多个host】 关系：
- TCP、UDP、ICMP、IGMP都是TCP/IP协议簇的 - TCP、UDP：传输数据 - ICMP：不传数据，只传输控制消息 - IGMP：将一个ip包拷贝给多个host，查询特定子网的组哪些是活动的，哪些是非活动的 3 拓展（TCP/IP协议簇） 3.1 TCP/IP协议簇 TCP/IP(Transmission Control Protocol/Internet Protocol,传输控制协议/网际协议)是指能够古在多个不同网络间实现信息传输的协议簇。
TCP/IP协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，只是因为在TCP/IP协议簇中TCP与IP协议最具代表性，所以被称为TCP/IP协议。
TCP/IP协议簇中常见协议：
SLIP 协议、 PPP协议 、IP协议、 ICMP协议 、 ARP协议 、 TCP协议 、 UDP协议 、 FTP协议 、 DNS协议 、 SMTP协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efd3dfb296d1dc6a6d34b5f04ee3843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a222cab05db2ebe5cf2f17bb454980ef/" rel="bookmark">
			python实现既定后缀名的文件移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		""" 问题描述： 输入文件夹路径，设定文件后缀要求，筛选文件移动到待保存文件路径。需保证筛选文件依然保留文件夹的子目录关系。 输入文件夹路径：r"C:\Users\deng\Desktop\kpi"; 后缀名筛选：[txt,xlsx,bmp]; 保存文件路径："F:\xxxx\123\sample" ex: 符合条件的文件：C:\Users\deng\Desktop\kpi\2\3\ni.txt 需要保存到：F:\xxxx\123\sample\kpi\2\3\ni.txt """ import os import shutil import traceback def filterfile(file_dir,save_dir,suffix): outsidefile=[] outsiderfolder=[] path=os.listdir(file_dir) print(path) #['1', '2', 'plan.txt'],只返回文件夹和文件的name for i in path: if os.path.isfile(file_dir+"\\"+i): outsidefile.append(file_dir+"\\"+i) elif os.path.isdir(file_dir+"\\"+i): outsiderfolder.append(file_dir+"\\"+i) print(outsidefile,outsiderfolder) #['C:\\Users\\deng\\Desktop\\kpi\\plan.txt'] ['C:\\Users\\deng\\Desktop\\kpi\\1', 'C:\\Users\\deng\\Desktop\\kpi\\2'] if len(outsidefile)!=0: for file in outsidefile: file_type = file.split(".")[-1] # 返回后缀名 outsidefileheadpath=file.split("\\")[-2] if (file_type in suffix): # 后缀名属于suffix内 isExists=os.path.exists(save_dir+"\\"+outsidefileheadpath) if not isExists: os.makedirs(save_dir+"\\"+outsidefileheadpath) print("文件夹创建成功") else: print("文件夹已经创建了") shutil.copy(file,save_dir+"\\"+outsidefileheadpath) #接下来对文件夹进行第二层的处理， for inside in outsiderfolder: insiderfile=[] insiderfolder=[] path1=os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a222cab05db2ebe5cf2f17bb454980ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b929c2a04d8966cb430158c418f506/" rel="bookmark">
			react基础--原理揭秘：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、setState
1.1 setState() 是异步更新数据的
1.2 推荐语法（setState的第一个参数）
1.3 setState的第二个参数
1.4 综合示例
二、组件更新机制
三、组件性能优化
3.1 减轻state
3.2 避免不必要的重新渲染--shouldComponentUpdate(nextProps, nextState)
四、纯组件
4.1 纯组件的基本使用
4.2 纯组件的浅层对比说明
一、setState 1.1 setState() 是异步更新数据的 注意：使用该语法时，后面的 setState() 不要依赖于前面的 setState()
1. 当你调用 setState 的时候，React.js 并不会马上修改 state （为什么） 2. 而是把这个对象放到一个更新队列里面 3. 稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。 可以多次调用 setState() ，只会触发一次重新渲染
index.js /** * 1. 导入react和react-dom * 2. 创建 react 元素 * 3. 把 react 元素渲染到页面 */ import React from 'react'; import ReactDom from 'react-dom/client'; import { Component } from 'react'; class App extends Component { state = { count: 20, money: 100 } render() { return ( &lt;div&gt; &lt;h4&gt;APP组件&lt;/h4&gt; &lt;div&gt;点击次数：{this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9b929c2a04d8966cb430158c418f506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1324165c68f231afa022e4a0e15470/" rel="bookmark">
			运放如何通过自激振荡产生正弦波？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家分享下运放自激振荡的电路，它的电路如下图所示，它和我们之前的运算放大电路最大的区别就是在同相端引入了一个带通滤波器。
运放产生自激振荡主要包含两个回路：选频网络，就是我们前面说的带通滤波器，就是运放正相端的那RC，他决定着自激振荡信号的频率，f0=12πRC，一般我们产生1MHZ以下的信号是可行的。
然后就是稳幅网络，就是运放反相端的电阻和二极管，需要注意的是二极管在这里是充当一个非线性环节，流过二极管的电流增大时，其动态电阻rd变小，反之变大，从而稳定输出信号的幅值，但是我们这里的放大倍数Au=1+Rf+rdR1 ,其中rd为二极管的动态电阻，阻值随电流变化而变化，由于自己振荡电路起振和幅值平衡条件是Au≥3
运放自激振荡产生正弦波的原理就是如果运放的同相端有个很小的信号，，那么这个信号通过负反馈放大电路进行放大，然后再通过RC的带通滤波器到同相端，通带频率为f0，并且f0满足f0=12πRC，这样小信号会逐步放大，变成大信号，从而在输出会产生一个频率为f0的振荡信号。
下面我们来实际看一下自激振荡电路的实测波形以及一些参数对其的影响
运放如何通过自激振荡产生正弦波？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb941d3ffaf541385f231963e50cf2a/" rel="bookmark">
			AJAX 识XMLHttpRequest与发送AJAX请求与ajax提交数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		东篱把酒黄昏后，有暗香盈袖
文章目录 前言一、XMLHttpRequest的readyState二、onreadyStatechange三、发送AJAX请求步骤四、ajax提交数据五、ajax get请求缓存问题六、ajax发送post请求总结 前言 耳鸣，真烦人
一、XMLHttpRequest的readyState readyState属性用于记录XMLHttpRequest对象的状态：
值 状态 描述
0 UNSENT 代理被创建，但尚未调用 open() 方法。（请求未初始化）
1 OPENED open() 方法已经被调用。（服务器连接已建立）
2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。（请求已收到）
3 LOADING 下载中；responseText 属性已经包含部分数据。(正在处理请求)
4 DONE 下载操作已完成。(请求已完成且响应已就绪)
当XMLHttpRequest对象的readyState属性的值变成4的时候，表示这个AJAX请求以及响应，已经全部完成了
二、onreadyStatechange 当readyState发生改变时调用onreadyStatechange（）
三、发送AJAX请求步骤 四步
第一步，创建AJAX核心对象，XMLHttpRequest var xhr = new XMLHttpRequest(); 第二步，注册回调函数 xhr.onreadystatechange = function () { if (this.readyState == 4) { if (this.status == 200) { //通过XMLHttpRequest对象的responseText属性可以获取到服务器响应回来的内容 //并且不管服务器响应回来的是什么，都以普通文本的形式获取（服务器可能响应回来，普通文本、XML、JSON、HTML....） document.getElementById("myspan").innerHTML = this.responseText this.responseText }else { alert(this.status) } } } 第三步，开启通道(open只是浏览器和服务器建立连接，通道打开，并不会发送请求) xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb941d3ffaf541385f231963e50cf2a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/125/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>