<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd5b6c41a387bfd5e4a7aec0ce060d9/" rel="bookmark">
			双指针应用之旋转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
示例 1:
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
示例 2:
输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL
分析 题意
题目可以理解为：把指针移动到链表的倒数第k个结点，将倒数第（k-1）个结点的next改成null，再移动到链表最后一个结点，并使其指向初始的链表头节点。判定移动类型
假设链表长度=len；
当k&gt;len，则链表循环了k/len圈，到达的链表位置为k%len；
当k&lt;len，则链表循环0圈，到达位置为k；int len = 0; // 链表长度 while (fast!=null){ len++; fast = fast.next; } k = k % len; fast = head; if (k == 0) return head; // 刚好转了 k/len 圈 /** * 找到链表的第 k%len 结点 */ while (k&gt;0){ fast = fast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd5b6c41a387bfd5e4a7aec0ce060d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1e421a3e01cb8698f48ccc51dc0f85/" rel="bookmark">
			Git常用命令记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分支相关 # 查看远程分支情况 git remote show origin # 更新最新分支情况（注：只是分支，不涉及具体内容），与远程同步 git remote prune origin # 查看本地分支与远程分支关联情况 git branch -vv # 建立本地分支与远程分支的关联 git branch -u origin/xxx # 删除远程分支 git push origin --delete xxx 二、暂存点相关 # 暂存本地修改, -u 选项是包括未追踪的文件，即新添加没有 git add 的文件，save 是添加一个暂存点描述 git stash save -u "message" # 查看暂存点记录 git stash list # 恢复暂存点, 恢复到 stash@{id} 这个暂存点，并不会删除此暂存点 git stash apply stash@{id} # 删除指定暂存点 git stash drop stash@{id} # 清空暂存点 git stash clear # 应用最近的一次暂存点，应用完成后删除此暂存点 git stash pop 三、撤销操作 # 撤销某个文件的修改 git checkout filename # 撤销所有修改 git checkout .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1e421a3e01cb8698f48ccc51dc0f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce5fc317a8c6b3d3b04a883c24a26e5/" rel="bookmark">
			JAVA我的世界怎么弄TNT大陆_我的世界tnt大陆--大爆炸！创建方法分享！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的世界是一款沙盒类型的游戏，在游戏里玩家都可以充分发挥自己的想象力创造力去打造一个自己喜欢的世界。其中方法也是多种多样啊。那么今天小编就带来其中一个，那就是我的世界tnt大陆创建方法。
我的世界tnt大陆
我的世界tnt大陆创建方法：
我的世界是一款风靡全球的高自由度沙盒游戏，由瑞典Mojang AB和4J Studios开发。在这款游戏中，玩家是整个游戏世界的中心，无人干涉，玩家的创造欲和占有欲让整个游戏充满了无尽的乐趣和自由，一旦上手，爱不释手。
首先要讲的是填充指令，在对话框输入“/fill x1 y1 z1 x2 y2 z2 minecraft:”+“方块名”这样就可以快速在一定区域填充某种方块。(xyz是游戏内的坐标)例如在对话框输入/fill x1 y1 z1 x2 y2 z2 minecraft:air，就可以快速在x1y1z1到x2y2z2范围内快速填充空气方块。如果想填充TNT就需要输入/fill x1 y1 z1 x2 y2 z2 minecraft:TNT。警告：不要手贱用打火石去点TNT哦。
你需要重建存档。
把世界预设超平坦，点进“自定义”然后“使用预设”随便选中一个预设(这里设置生物群系)在把上面的一些参数删掉，输入：100*tnt 即可得到100层厚度的TNT大陆。对于孩子们喜爱的TNT大陆而言，那可谓就是简单设置了，只要把minecraft:grass改为minecraft:TNT，再生成世界就搞定了，不过是，如果你是想要纵火，那么你的显卡还是得先烧着啊！那么这个方法就是超平坦预设了，对于低版本的玩家而言，毫不在乎，因为他们只知道方块的代码就可以创造一个大陆了。然而，有些高版本的玩家就不知道怎么使用预设去创造钻石大陆，其实这个过程也是相当的简单的，你只需要知道方块的英文是什么就可以创造出来了。
我的世界tnt大陆
好了，以上这些就是我的世界tnt大陆的创建方法。是不是很有趣呢？告诉大家当你建成tnt大陆的时候会更加有趣哦，那么学会的小伙伴赶快去我的世界里试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6723ae22be1c1c400fed7e7cfe892c/" rel="bookmark">
			终于有人把数据挖掘讲明白了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01
什么是数据挖掘
数据挖掘（Data Mining）应该是一门大家都听说过，但又不太容易说清楚的课程。在数据科学领域，乃至在更大的计算机科学领域，数据挖掘就好比山东蓝翔，大家不一定都知道挖掘机要怎么开，但一定都知道挖掘机技术到底哪家强。
不过，知名度高也未必全是好事，尤其是啤酒尿布的故事太经典，反而会让大家以为这活很“高端”，离自己太远，不会用也用不上。其实，很多人未必学过数据挖掘，甚至可能没有听过这四个字，但实际已经早就开始在进行数据挖掘。譬如说股民。
很多人说今年的行情很有希望，要去学炒股。学炒股就是学股市中的数据挖掘，流派很多，譬如说技术分析流，认为K线图或者其他什么图，和股市后市走势关系密切；价值投资流则认为，通过一整套考察公司的指标体系，才能更好地推测股票的未来价值；当然也有一些旁门左道，譬如说门口大妈流，就是看到门口卖菜的大妈开始谈论股票的时候，说明行情就见顶了，要赶紧抽身。不管你钟情哪种方法，所要做的事都非常类似，就是把从各种地方收集的信息，也就是“数据”，加以整理分析，挖掘出和你关心的对象的目标关系。
这样的例子还有很多，譬如数据挖掘非常非常常用的异常检测，别看这词挺学术，我举个例子大家肯定就知道了，体检。虽然这是个枸杞配啤酒的朋克养身时代，不过预防疾病还得靠体检。但是，体检的结果是一堆的指标项，是数值，但数值本身是不会告诉你身体有没啥毛病，得首先有一个标准区间，然后发现指标异常，接着还要建立指标和疾病之间的关联关系，完成了这些前期工作，最后才能通过体检告诉你身体是不是还能再战五百年。这些前期工作就是数据挖掘。说回我们的老本行计算机，异常就更多了，譬如说WEB日志，经常需要进行异常检测从而发现网络入侵。
这都是数据挖掘。不是按某本名叫《数据挖掘》的书的某某方法依样画葫芦才叫数据挖掘，正好相反，是大家在各种数据挖掘的实践中形成了一些方法和工具，大家都觉得很好用，研究人员就加以收集整理，理清条理形成体系，才最终诞生了“数据挖掘”这门课。
02
数据挖掘和机器学习、模式识别
当你真的开始去学数据挖掘，遇到的第一个问题很可能是犯迷糊。数据科学领域有三朵金花，分别是数据挖掘、机器学习和模式识别，而数据挖掘的知识体系，和同样非常热门的机器学习以及模式识别有很高的重合度，那种感觉，不是在同一赛道有三名选手，而更像是在三条赛道看到了同一名选手。当然，就我的意见，这三个名词究竟存在怎样的我心中有你你心中有Ta的复杂三角关系，其实一点也不影响学习，毕竟有位红帽白须的老爷爷曾经说过，小孩子才做选择，成年人当然是全都学。三角关系越是复杂，要学的内容越是分不清你我，总的学习成本反而会更低。
但是，问题确实存在，不管看着有多像，但毕竟是有三个词，加上“到底该学哪个”这类的问题常年盘踞提问排行榜，这里我还是想尝试先回答。首先要说的是，数据挖掘、机器学习和模式识别三者并不存在什么无法逾越的鸿沟，经常出现一个算法到处客串的情况，边界越来越模糊已经是肉眼可见的大趋势。就核心内容来看，机器学习主要是工具集，数据挖掘和模式识别，则是这套工具集的两块用武之地，所以，在学习数据挖掘和模式识别的课上，你不用意外，无论选用什么教材，肯定都会看到非常多机器学习的老面孔。
再说模式识别。模式识别的重点在于两个字，识别，所以一般的应用形式都叫XX识别，譬如说现在大家都很熟的人脸识别，往大了说就是图像识别。除了图像，模式识别也研究其它各种数据形式，譬如音频类的语音识别，以及文本类的自然语言识别，当然，现在更习惯称之为自然语言理解。
最后回到我们今天的主角，数据挖掘。在写作时，我很想找到一条对数据挖掘的形式化定义，让大家能有一些具象的感觉，翻了很多资料，最后也只能宣告放弃。不过，这些资料虽然没有，我姑且取个交集，结论大概是所谓的数据挖掘，就是在各种数据之中，通过一定的方法和工具，挖掘发现感兴趣的知识。
归结来说，数据挖掘就是要解决三个问题，去哪挖、挖什么和怎么挖。下面我们就分三个部分分别介绍，数据挖掘是怎样思考这三个问题的。
03
去哪挖
数据挖掘数首先要解决的问题自然就是“数据”的问题，也就是去哪挖的问题。很多人也许觉得，这算个啥问题，数据挖掘数据挖掘，当然就是去有“数据”的地方挖。我听过一些数据挖掘的课程，也参加过一些数据挖掘的比赛，给我的一个很深的感觉就是，数据是现成的，它就摆在那里，看得见摸得着，你要做的就是上家伙削它。
真的是这样吗？不对。数据在哪里是一个非常值得花时间仔细思考的问题。很多书把数据挖掘称作数据掘金，这个比喻恰如其分，挖数据也好挖金子也罢，是不是可以随便找个什么地方盘腿坐下，只要一套组合技高水平地施展完毕，金子就能“哗”地蹦出地面？肯定不是。你要挖着金子，那个地方首先得有金子。在没金子的地方挖金子，不管再怎么努力，用什么方法工具，都不可能挖到金子，因为这叫缘木求鱼。
这个问题许多书本都不太爱展开，确实，数据挖掘和哈姆雷特差不多，一千个挖掘项目有一千种挖掘需求，怎么总结也很难避免落一个挂一漏万的结果。不过，前面我们说什么是数据挖掘的时候，举了学炒股做例子，不妨多说两句，也许可以给大家带来一点思考。
我们说炒股有很多流派，有技术分析流，有价值投资流，还有门口大妈流，这些流派要解决的都是同一个问题，后市走势问题，但是，到底什么才和后市走势相关、最好是密切相关呢？不同流派有不同看法，结果就是大家所选择要去挖掘的数据并不相同，技术分析流看的是K线图，价值投资流看的是公司运营情况，门口大妈流则选择去看门口大妈。我们假设一个极端的情况，假设K线图真的是像一些人说的，准确性还不如找猴子掷飞镖来得高，也就是K线图和后市走势实际没啥关系，那水平再高的大牛花再多的时间研究，最终也不可能从K线图中找出真正有价值的信息。
去哪挖？去有金子的地方挖。
04
挖什么
数据挖掘，挖的当然是数据了。不过，数据的形式有很多种。按数据类型来分，数据挖掘主要处理非依赖性数据和依赖型数据。非依赖性数据相对简单，也就是我们通常所说的“多维数据”，一条记录包括多个项目。这么说也许比较抽象，其实我们都见过，回忆一下填过的各种表格，譬如说报名表，需要填姓名、性别、年龄等等信息，这就是典型的多维数据
不过，想也知道，这些不同的项目，里面的数据格式是不尽相同的。譬如说姓名填写的是文本，性别通常是二选一，而年龄则是一个数字。在数据挖掘中，这些不同的格式也要区别对待。我看过一些数据挖掘的教材，把这些类型分得很细，充分体现了学术的严谨性。不过有些类型的名字起得太学术，还要对名字本身进行解释，这样文章篇幅就长了。这里我按经验整理，大致可以化为以下三种：
连续型数据。连续型数据首先是数值数据，而“连续”是相对于“离散”而言的，数值序列中间不会出现中断或者跳跃，譬如说年龄、气温就是此类。
离散型数据。离散型数据同样也是数值数据，简单来说就是“不连续”的数据。你可能会好奇，什么样的数据会不连续呢？很多，譬如说性别，我们用0表示女，1表示男，那性别这一栏就要么是0要么是1，中间不会有其它的值，这就是典型的离散数据。
文本型数据。前面我们一直在强调数值数据，但文本型数据在自然环境中同样非常常见，譬如说姓名，又譬如说前面提到的门口大妈流，这些都是以文本形式存储的数据。不过众所周知，文本型数据是没法直接进行计算的，一般需要通过转换成向量来进行分析。
非依赖型数据最大特点就是各个数据项彼此独立，相互之间没有依赖关系，不会“牵一发而动全身”，所以操作难度相对较低。
说完了非依赖型数据，再说说依赖型数据，所谓的“依赖”，也就是数据项之间存在某种关联变化的关系，数据挖掘将这种关系又具体分为隐式依赖关系和显示依赖关系，二者的区别在于前者的依赖比较含蓄，后者更加赤果果。但我觉得两者边界十分模糊，这里只说“依赖”究竟是怎么一回事。
数据挖掘将依赖型数据分为以下三种：
序列数据。序列数据是可以再细分的，包括连续型序列数据和离散型序列数据，但它们的特点都是明显存在着上下文依赖关系，譬如说最常见的时序数据，也就是时间序列数据。这是一种连续型的序列数据，上一个时间片和下一个时间片存在着显式或隐式的依赖关系。我们在前面已经介绍了一种序列数据，K线图。K线图是典型的时序数据，大家一般认为，行情的当前走势和未来走势是存在着某种依赖关系的，细分来说，是隐式依赖关系。
空间数据。空间数据通常就是坐标数据，最容易联想到地理位置坐标，也就是经纬度，但“坐标”的应用非常广泛，譬如说宏观经济的各种指标，不同的国家通过逻辑编码，同样可以构成坐标。就我的经验，空间数据经常和时间密切关联，形成某种轨迹性质的图像，也叫时空数据，和时序数据可能会存在交集。
图数据。图是计算机科学中很常用的一种数据结构，经常用来表示几个节点之间的关系，而在我们生活中也经常能看到各种“关系图”，所以，图数据自然也是一种典型的依赖型数据，而且往往是显示依赖关系。
05
怎么挖
怎么挖是数据挖掘的重点内容，有很多道工序，每一道工序展开又能是一整套方法体系。总的来说，数据挖掘有三大块工序，数据采集、数据预处理和数据分析。
先说这个数据采集吧，在很多人的直觉中，“数据”就是一个文件，它就岁月静好地躺在那里，你写程序去读了就好，许多数据比赛也强化了这一印象。但实际上，数据可能产生于多个不同的地方，譬如说类型完全不同的传感器，又譬如说各种不同的Web网站，火了很久还将火很久的大数据，就是从Web开始的。Web数据有最大的特点就是“大”，动不动就说我几秒产生多少个T的数据，到底有多大不要问，问就是海量。那海量数据采哪些怎么采、怎么存储、流式数据怎么分析，每一步都是一个问题，都需要你需要想各种办法。完成数据采集，将各种所需数据存入数据库，这就形成了数据仓库。这是数据挖掘的基础。
数据预处理主要是特征提取和数据清洗，包括了对原始数据进行类型转换、缺失值填补、将文本数据数据化向量化、缩放标准化等等等等。数据预处理将直接决定数据的最终质量，对挖掘结果产生十分显著的影响，有非常多的经验和技巧，完全可以再写一篇文章。
最后才是数据分析。我刚学的时候，以为“数据挖掘”就是数据分析，相信很多朋友都有过同样的误会，现在知道了，需要经历前面的千山万水才能走到这一步。但是，虽然在流程上，数据分析是最后一步，但这是最核心的一步，最终能挖到金子还是钻石，还得靠这一步。在另一方面，到了数据分析阶段，任务的背景相对就淡化了，而问题的共性明显增加，根据不同的问题积累的工具和方法，也更加容易形成“套路”。所以，数据分析自然也是数据挖掘作为一门课程的重点章节。
数据挖掘都归纳了哪些问题呢？主要包括分类问题、聚类问题、关联模式挖掘、关联模式和异常检测这四个大类，了解机器学习的朋友肯定很有亲切感，分类问题和聚类问题是机器学习最经典的两大类问题，这就是数据挖掘为什么会看到机器学习的内容。这四个问题还可以细分，譬如经典的啤酒尿布，就是关联模式问题下的频繁项挖掘问题。这些问题都有对应的算法，不同的环境下又有不同的应对方法。
这部分内容很多，是数据挖掘的重头戏，我推荐两本书，一本是韩家炜教授的《数据挖掘:概念与技术》，这是数据挖掘领域知名度最高、也是最经典的一本教材，大家肯定不陌生。另一本则是新出的《数据挖掘：原理与实践》，分为“基础篇”和“进阶篇”，篇幅上就明显增加，而且新书都有一个优点，补充了对新热点的介绍，如怎样挖掘图数据和社交网站数据，可以通过阅读本书追踪数据挖掘的最新进展。
作者简介：
莫凡，网名木羊同学。娱乐向机器学习解说选手，《机器学习算法的数学解析与Python实现》作者，前沿技术发展观潮者，擅长高冷技术的“白菜化”解说，微信公众号“睡前机器学习”，个人知乎号“木羊”。
扫码关注作者
RECOMMEND
推荐阅读
01
《数据挖掘：原理与实践（基础篇）》 作者：[美] 查鲁·C. 阿加沃尔
译者：王晓阳、王建勇、禹晓辉、陈世敏
推荐理由
大数据和人工智能时代的数据挖掘教材和工具书。从四个“超级问题”出发，不仅详解数据挖掘的基础知识，而且还介绍高级数据类型，结合复杂多样的实际数据环境，探讨数据挖掘的应用场景和使用方法。
本书中文版分为基础篇和进阶篇。基础篇（包括原书的第1-13章）详细介绍了针对数据挖掘的四个主要问题（聚类、分类、关联模式挖掘和异常分析）的各种解决方法、用于文本数据领域的特定挖掘方法，以及对于数据流的挖掘应用。
02
《数据挖掘：原理与实践（进阶篇）》 作者：[美] 查鲁·C. 阿加沃尔
译者：王晓阳、王建勇、禹晓辉、陈世敏
推荐理由
大数据和人工智能时代的数据挖掘教材和工具书。从四个“超级问题”出发，不仅详解数据挖掘的基础知识，而且还介绍高级数据类型，结合复杂多样的实际数据环境，探讨数据挖掘的应用场景和使用方法。
进阶篇（包括原书的第14-20章）主要讨论了用于不同数据领域（例如时序数据、序列数据、空间数据、图数据）的特定挖掘方法，以及重要的数据挖掘应用（例如Web数据挖掘、排名、推荐、社交网络分析和隐私保护）。
03
《数据挖掘导论（原书第2版）》
作者：[美]陈封能、迈克尔·斯坦巴赫等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b6723ae22be1c1c400fed7e7cfe892c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab5a07b4110262971e1ad1f1ca2ff36/" rel="bookmark">
			我的世界seus光影java版下载_我的世界seus光影mod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的世界seus光影mod能够为你展现一片新的视觉世界，玩家使用它可以明显的感受到游戏的画质好了很多，从此告别渣渣画质，能够为玩家起到很好的照明效果，非常的好用哦~当然该MOD对显卡的要求也是极高的，需要的玩家快来下载吧~
我的世界seus光影mod介绍
我的世界seus光影mod提供了绚丽的光照效果。兼容单机联机模式，遇上下雨天，所有的效果看起来是那么的真实。
白天太阳下的光照，和晚上月光下的光照是不同的，月光光照更加的柔和，让夜晚更显得静谧!
我的世界seus光影mod详情
这款神级贴图包就是国外作者Sonic Ether开发的“Unbelievable Shaders”，俗称SEUS，彻底改变了《我的世界》画面。
尽管MOD能改变或在游戏中加入东西，比如之前的Momo Suicide游戏MOD，但这个贴图包直接是加入了新的渲染系统和贴图，让游戏看起来异常的美丽。
我的世界seus光影mod点评
我的世界seus光影mod进一步升级优化，加入了类似光线追踪的渲染效果，无论是地板的反射光线，还是透过窗户的阳光，都十分真实自然，网友纷纷表示这简直是我的世界堪称最强高画质光影 。
|我的世界SEUS光影MOD安装流程
1、下载文件，不要解压
2.确认客户端已安装Forge。(如果不确定或者不会安装请在本站客户端栏目下载带Forge的懒人包)
3、打开游戏所在文件夹，找到shaderpacks文件夹!
4、将光影包拖入minecraftishaderpacks文件夹即可!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4b77595dde572df3f3655a3f46fb32/" rel="bookmark">
			java 服务器 卡死_一次服务器卡死以及引申出的java_opts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		年前，前端拨测发现某业务卡死，后台top一看，大约3个java进程占据了大概3G内存，其余还有几个java进程虎视眈眈，占据2G内存。开始定位。
首先，为什么会有这么多个叫java的进程呢？一问，是在一个用户下使用了10个tomcat(为什么会在一个tomcat里起10个tomcat，而不是一个tomcat调大一点线程池数量？连接数？或者用2个或者5个的集群设计？服务器资源不够，为什么不只用一个tomcat？)后话，先不管了，问服务人员，当时的研发给的答复是：过段时间重启。每隔一段时间重启这也算解决方案？
继续看，发现不管是catalina.sh还是setevn.sh，没有需要是java_opts，如我们常用到的限制
JAVA_OPTS="$JAVA_OPTS -Xmn768m -Xms2048m -Xmx2048m -XX:PermSize=128m -XX:MaxPermSize=256m" 于是，先不讨论内存泄露可能情况下的问题原因在于没有设置mx值，导致某个tomcat容器的jvm不断吃内存，终于吃不消了，参见
http://www.voidcn.com/article/p-ayhmkxoi-bsn.html，不设置mx情况下，最大可以吃到物理内存的1/4，于是内存很容易的满了，比重启好一点的解决方法，设置mx值，在setenv.sh中添加如上类似内容，后面在修改10个tomcat的问题。问题解决
关于JAVA_OPTS的一些，可以参考java官网文档。搜到的很多文档都会讲怎么去设置mn，ms，mx等，只有从官方文档才能找到默认值，比如我不设，会怎么样，比如http://www.oracle.com/technetwork/java/javase/6u18-142093.html，ms，初始堆大小，如果不设置，最小8M，一般为物理内存的1/64(主要是服务器现在哪儿找1G内存以下的啊)
常见的设置可以参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24476cbe93b4ef468441cfaea6017613/" rel="bookmark">
			微信公众平台开发Token验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：微信公众号扫码登录--URL、Token配置；
配置URL:https://www.XXXXXXXX.com/WechatTest.jsp
Token:XXXXXXX
WechatTest.jsp代码：
&lt;%@page import="com.wechat.SignatureVerify"%&gt; &lt;%@page import="org.apache.xmlbeans.impl.xb.xsdschema.Public"%&gt; &lt;%@ page language="java" contentType="text/plain; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;%@ page import="org.apache.commons.lang.StringUtils"%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/plain; charset=utf-8" charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt;this is wechat test page &lt;/body&gt; &lt;/html&gt; &lt;% try { if (StringUtils.isNotBlank(request.getParameter("signature"))) { String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); String echostr = request.getParameter("echostr"); SignatureVerify.VerifySignature(response, signature, timestamp, nonce, echostr); } } catch (Exception e) { // TODO: handle exception } %&gt; 后端Java的SignatureVerify.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24476cbe93b4ef468441cfaea6017613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811226156f3ba3bfb78808dcea0b1857/" rel="bookmark">
			海康工业相机功能模块-参数保存、加载、批量复制参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康工业相机功能模块-参数保存与加载 前言相机参数保存的快速方法相机参数导入导出的操作方法UserSetLoad 加载相机内部参数FeatureLoad/FeatureSaveFileAccess 功能MVS导入导出功能 几种方法的优缺点比较 前言 前面一篇文章，讲了工业相机参数如何设置与获取，使用sdk能够将自己想要的参数快速的配置进自己的程序，但是，在实际使用中，我们会发现，sdk配置的参数似乎在断电只会就消失啦，不能实现断电生效？？？
软件开发过程中，只能够配置常见的参数，一些偏门的参数，非常见的相机调试参数，如何批量设置进相机、如果断电能够保存？？？
这一篇文章就是来介绍、解决这个问题
相机参数保存的快速方法 MVS如何操作 参考相机用户手册提供的方法,主要操作分为3步
修改参数后，通过User Set Selector 参数下拉选择其中一套User Set 参数，例如选择"User Set 1"（你的参数保存在哪里）通过User Set default参数下拉选择其中一套User Set 参数，例如选择"User Set 1"（相机重新上电后，加载那套参数）点击User Set Save 处的“Execute”，即可将参数保存到用户参数中（实际有效的保存操作)
sdk接口如何调用-UserSetSave方法
参考在MVS里面的操作，主要是三句话的调用 //初始化部分，放在Opendevice之后即可 nRet = MV_CC_SetEnumValue(handle, "UserSetSelector", 1); if (MV_OK != nRet) { printf("error: SetEnumValue UserSetSelector fail [%x]\n", nRet); } nRet = MV_CC_SetEnumValue(handle, "UserSetDefault", 1); if (MV_OK != nRet) { printf("error: SetEnumValue UserSetDefault fail [%x]\n", nRet); } //设置Command型节点-发送参数保存命令 //大部分参数修改完成后，调用此命令进行保存，不建议频繁调用 nRet = MV_CC_SetCommandValue(m_handle, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811226156f3ba3bfb78808dcea0b1857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103545842c25e3ef86839076e032513a/" rel="bookmark">
			关于csv文件转化为张量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1使用pandas导入 train = pd.read_csv('train_data_head_Chinese.csv', encoding="gb18030") 如果是用的中文的话，记得encoding参数设置为gb18030
2 获取值 pandas是一个数据框，里面也含有表头。我们只关心它的内容，所以，我们使用.values方法来获取
具体操作为：
data = train.values 3 转换为浮点类型数据 data = data.astype(float) 此时，有一个小tips，如果数字里面有许多逗号（千位分隔符），需要进入到csv文件中改一下格式，改为“常规”
4 转化为张量 y = torch.from_numpy(data) 通过以上步骤，可以顺利转化为张量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30b68a199e3d60dd0d8cc33b0c4ef64/" rel="bookmark">
			CryptoJS C/C&#43;&#43; openssl Java AES_256_ecb 加密解密互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CryptoJS &lt;script type="text/javascript" src="crypto-js.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 加密 var ciphertext = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse('123456'), CryptoJS.enc.Utf8.parse('12345678901234567890123456789012'), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }).toString(); console.log(ciphertext); // 解密 var bytes = CryptoJS.AES.decrypt(ciphertext, CryptoJS.enc.Utf8.parse('12345678901234567890123456789012'), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }); var originalText = bytes.toString(CryptoJS.enc.Utf8); console.log(originalText); &lt;/script&gt; 效果
解析base64查看原始密文
Java public static byte[] AES_256_ecb_encrypt(byte[] input, byte[] byteKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException { Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); SecretKey key = new SecretKeySpec(byteKey, "AES"); cipher.init(Cipher.ENCRYPT_MODE, key); byte[] encrypted = cipher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30b68a199e3d60dd0d8cc33b0c4ef64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f073c2b1de6dbbf1c7cb8163e80dc8c/" rel="bookmark">
			px和毫米的换算_像素跟毫米换算(像素和毫米换算器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		像素与毫米的区别，两者如何换算？尤其是在网页设计中如何换算其图片的格.
1. 像素仅仅只是分辨率的尺寸单位，而不是画质。从定义上来看，像素是指基本原色素及其灰度的基本编码。 像素是构成数码影像的基本单元，通常以像素每英寸PPI(pixels .
像素和毫米之间没有换算的有公式！要看你图片是多大的分辨率，要通过分辨率来换算！例如分辨率是300像素/英寸的10寸照片(20.3X25.4厘米)的像素是2400X3000像.
92mm*56mm 把单位换算成像素是多少？
像素与毫米的转换 转换还需要知道另一个参数：DPI(每英寸多少点) 象素数 / DPI = 英寸数 英寸数 * 25.4 = 毫米数 对于显示设备，不管是打印机还是屏幕，都有一种通用.
设计网页的时候，会用到像素这个单位。请问这个像素与厘米之间的换算关系.
像素和厘米不能直接转换，只有分辩率(dpi)下才能转换 平时经常使用72和300dpi，电脑显示器用72dpi，照片用300dpi72dpi 1厘米=28.346像素300dpi 1厘米=118.11像素
1:300
一毫米等于4.428像素，A4纸宽930像素，210毫米算了就知道了
在Excel 软件里，行高和列宽的单位是英寸还是像素？如果换算成毫米，是怎.
1像素=1/96*25.4=0.264583333333333333毫米
像素好比是一张纸上的格子，格子的多少取决于格子的大小和纸的大小，所以这是个相对值。毫米是个绝对值，1000分之1米，是个长度单位。如果长宽相乘得出的面积上.
毫米与像素是两种概念 像数是指组成一个画面或图片的单元点，长乘宽(如800*600=480000为48万像素 做封面，用每毫米100以上的分辨率都够了
我想在cdr里做个屏幕大小的图`` 屏幕是1024*768象素 换成毫米是好多啊？。
水平方向的换算： x * px /25.4 垂直方向的换算： y * py /25.4 像素换算为毫米 x * 25.4 / px 头都晕了`` 哎`` 你真苦啊`
1mm=(10/43)px≈0.2325px43mm≈10px(px是pixel的缩写， 意思是像素)，所以1mm=(10/43)px≈0.2325px 分辨率决定了位图图像细节的精细程度。通常情况下，图像的分辨.
1 像素 = 1/96 英寸1 英寸 = 25.4毫米那么一像素等于多少毫米？
照你说的话，1像素=1/96*25.4=0.264583333333333333毫米
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f073c2b1de6dbbf1c7cb8163e80dc8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88487f5dc93aaa423d64b866e7f04328/" rel="bookmark">
			php yield mysql_PHP 5.5 新特性关键字 yield
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP 5.5 增加了个新的关键字 yield，这个也是本人今天在看开源应用 tencent-php tsf 的源码的时候发现的，其中大量的使用到了 yield。
通俗一点的讲，yield 是 generator 发生器，配合迭代 iterator 使用。在函数迭代的某一步遇到 yield 语句时返回一个值，下次生成时从 yield 语句的地方继续运行，直到再次遇到 yield 再次返回值，这样就可以达到更好的迭代 iterate 的效果。
看官方文档上有个例子讲到了将 range() 实现为生成器，当数据量很大的时候不会消耗太多内存，代码示例如下：&lt;?php function xrange($start, $limit, $step = 1) {
if ($start &lt; $limit) {
if ($step &lt;= 0) {
throw new LogicException('Step must be +ve');
}
for ($i = $start; $i &lt;= $limit; $i += $step) {
yield $i;
}
} else {
if ($step &gt;= 0) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88487f5dc93aaa423d64b866e7f04328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e448db61f88a57fa70b4992b3814e27/" rel="bookmark">
			ClassNotFoundException/NoClassDefFoundError出现原因及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。
ClassNotFoundException的产生原因： Java支持使用Class.forName方法来动态地加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。
ClassNotFoundException解决 解决该问题需要确保所需的类连同它依赖的包存在于类路径中，常见问题在于类名书写错误。
另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。通过控制动态类加载过程，可以避免上述情况发生。
NoClassDefFoundError产生的原因： 如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError.
造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。
NoClassDefFoundError解决 解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0372194c525804e8be420c0796d8d194/" rel="bookmark">
			mysql数据库join查询默认值_深入理解mysql数据库join查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在日常开发中，时常会面临sql优化的问题，通常情况下，我们总会说join查询比普通的关联查询效率会高很多，话虽如此，但是为何join查询效率通常情况下比关联查询效率高呢，我们一起探究一下。
我们知道，关联查询，会将符合条件的查询结果显示出来；而join查询，不光显示符合条件的数据，还会将符合左表但是不符合右表的全部数据都查询出来。
假如我有两张数据库表，分别是h_user(7条数据) 和 h_user_info(999条数据) ，两个表的主键分别是user_id和info_id，且并无其它索引字段。
如果使用关联查询和join查询，那么，sql语句通常是如下所示：
-- 关联查询
SELECT
a.user_type
FROM
h_user a , h_user_info b where a.user_id = b.info_id
-- 左查询
SELECT
a.user_type
FROM
h_user a
LEFT JOIN h_user_info b ON a.user_id = b.info_id
关于上面的sql语句关联查询和左查询的区别：
1、如果是关联查询的话，只有1条符合条件的数据，则只会显示1条记录出来，有n条记录，则显示n条。
2、如果是使用左查询，当查询记录为1对1时，则显示7条记录；左右表有1对多(m)的情况，且左表有n条这样的记录，则总记录数为7 + ( m – 1 ) * n 。并且，当符合左表的记录，不符合右表，在查询出来记录列表中，右表的字段值为null；同理，当左右表顺序切换时，也是一样的规则计算。
上述sql语句，关于查询效率一块，两者查询效率是相同的。根据mysql查询计划显示结果如下：
从上图中，我们可以看到，两者的查询计划是相同的，查询条件为a.user_id = b.info_id，此时左表需进行全表扫描然后和右表进行匹配，至于为什么，稍后再做解释。而右表也命中索引，只需要和左表进行匹配即可。但是如果将两表切换位置，得到的执行计划，则是另外一回事，如下图：
但是，对于关联查询，将两表切换位置，得到的执行计划依然和上图一致，这里面的原因，暂时未知，也不再本文探讨范围内，后期有机会会单独研究。
看到这里，是不是对join查询感觉很是奇怪？那么，join查询的底层是如何实现的呢，我们一起探索一番。
简单来说，join查询，就类似于java中的for循环，通过两层for循环嵌套，从而遍历两张表中所有的数据并筛选出符合条件的数据集合，如下图所示：
/**
* TODO 为了方便理解，所以命名使用中文，勿效仿
*/
for (行 左表具体行 : 左表所有行){
for (行 右表具体行: 右表所有行){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0372194c525804e8be420c0796d8d194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689ae211c71a44301c83a1b7183007dd/" rel="bookmark">
			CNN之手写数字识别（Handwriting Recognition）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN之手写数字识别（Handwriting Recognition） 目录
CNN之手写数字识别（Handwriting Recognition）
1、常用的包
2、常见概念
3、手写数字识别器实现
3.1 数据准备
3.2 构建网络
3.3 运行模型
3.4 测试模型
3.5 查看卷积核与特征图
参考文献
1、常用的包 torchvision.datasets：数据集，对整个数据的封装，统一处理图像或张量等原始数据torch.utils.data.DataLoader：数据加载器，负责在程序中对数据集的使用，可实现自动化批量输出数据torch.utils.data.sampler：采样器，为加载器提供一个每一批抽取数据集中样本的方法，可实现顺序抽取，随机抽取或按概率分布抽取 2、常见概念 卷积（Convolution）：在原始图像中搜索与卷积核相似的区域，即用卷积核从左到右、从上到下地进行逐个像素的扫描和匹配，并最终将匹配的结果表示成一张新的图像，通常被称为特征图（Feature Map） 输出特征图有多少层，这一层卷积就有多少个卷积核，每一个卷积核会完全独立地进行运算锐化图像（强调细节）、模糊图像（减少细节）都可以看作某种特定权重的卷积核在原始图像上的卷积操作一般情况下，底层卷积操作的特征核数量少，越往后越多特征图中，一个像素就是一个神经元卷积计算的两个阶段： 前馈运算阶段（从输入图像到输出概率分布）：所有连接的权重值都不改变，系统根据输入图像计算输出分类，并根据网络的分类与数据中标签进行比较，计算出交叉熵作为损失函数反馈学习阶段：根据前馈阶段的损失函数调整所有连接上的权重值，从而完成神经网络的学习过程补齐（Padding）：将原始图扩大，用0来填充补充的区域池化（Pooling）：将原始图变小，获取粗粒度信息、提炼大尺度图像信息的过程，是对原始图像的缩略和抽象超参数：人为设定的参数值，决定整个网络的架构，如网络层数、神经元数量、卷积核窗口尺寸、卷积核数量、填充格点大小、池化窗口尺寸等参数：不需要人为设定，在网络的训练过程中网络自动学习得到的数值激活函数：提供网络的非线性建模能力损失函数：度量神经网络的输出的预测值与实际值之间的差距dropout技术：在深度学习网络的训练过程中，根据一定的概率随机将其中的一些神经元暂时丢弃，这样在每个批的训练过程中，都是在训练不同的神经网络，最后在测试时再使用全部的神经元，这样可以增强模型的泛化能力 3、手写数字识别器实现 3.1 数据准备 import torch import torch.nn as nn from torch.autograd import Variable import torch.optim as optim import torch.nn.functional as F import torchvision.datasets as dsets import torchvision.transforms as transforms import matplotlib.pyplot as plt import numpy as np %matplotlib inline device = torch.device("cuda:0" if torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/689ae211c71a44301c83a1b7183007dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6991e238b552b4a56c28eeaaff52abf/" rel="bookmark">
			mysql5.6 远程导入_mysql开启远程连接方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql5.6/5.7开启远程连接方法
更新时间：2016-05-26 19:09 来源：电脑技术网 作者：电脑技术网 查看评论
文章简介
mysql一般为了方便管理人员的维护，一般都开启了远程访问，一般来说默认的mysql有多个root用户，一般命令是无法使用，本文就说一下作者在mysql5.6及5.7个这两个版本上如何开启的远程访问。
演示软件及适用范围
演示软件：mysql5.6
演示系统：FreeBSD
适用范围：mysql各版本
mysql开启远程连接方法
第1步：使用终端工具登录到服务器终端。
电脑技术网注：作者使用的是Shell。
第1步：在终端上执行登录mysql数据库命令mysql -u root -p。
第2步：在终端上切换到mysql数据库use mysql。
第3步：执行命令开启所有人连接到这台服务器，命令GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;。
电脑技术网注：第3步中的mysql开启远程访问命令是允许所有人可以连接到这台mysql数据库，如果想指定某ip的话，可执行以下命令。
GRANT ALL PRIVILEGES ON *.* TO 'PC515'@'192.168.1.5' IDENTIFIED BY 'PC515.COM' WITH GRANT OPTION;
http://www.pc515.com/wangzhan/weihu/95.html
电脑技术网注2：其中的PC515是登录名在192.168.1.5这个IP地址上以PC515.COM密码登录。
第4步：最后一步执行完命令后，需要刷新用户权限flush privileges;。
电脑技术网注：一般来说，执行完第4步后，都可以远程访问mysql数据库了，但是在mysql5.6及5.7比较新的mysql数据库，还需要再次修改一些其它的系统参数。
第5步：需要修改my.cnf数据库，在shell终端中执行命令vi /etc/my.cnf。
电脑技术网注：不同的服务器，不同的mysql其中的mysql配置文件my.cnf可能存放位置不同，可在终端执行命令find / -name "my.cnf" -ls进行搜索mysql配置文件目录。
第6步：找到mysql配置文件后，找到bind-address = 127.0.0.1代码，并在前面加上#号，就是允许任何ip远程访问这个mysql数据库，修改完后，保存my.cnf文件即可。
电脑技术网注1：在vi中保存方法是按一下ESC键，输入:wq!并确定即可保存。
电脑技术网注2：如果想指定某个ip访问，直接将127.0.0.1修改为指定的ip访问。
第7步：最后完成后，执行一下，重启mysql服务即可生效。
有关mysql | 的文章推荐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71a9cc03e4ee9e077e456c27d609870/" rel="bookmark">
			数据解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据解析分类数据解析原理正则匹配爬取糗事百科图片 bs4环境安装对象的实例化数据解析的方法和属性爬取三国演义所有标题和内容 xpath环境安装对象的实例化xpath表达式爬取58同城北京二手房名称爬取4k网站图片爬取全国城市名 数据解析分类 正则bs4xpath（***） 数据解析原理 解析的局部文本内容都会在标签之间或者标签对应属性中进行存储进行指定标签定位标签或标签对应属性中存储的数据值进行提取 正则匹配 先学习正则表达式
import re // \w 匹配数字、字母、下划线 print(re.findall('\w','abc123_*()-=')) # findall是从左到右匹配字符串 // ['a', 'b', 'c', '1', '2', '3', '_'] // \W 匹配非数字字母下划线 print(re.findall('\W','aAbc123_*()-=')) //['*', '(', ')', '-', '='] // \s 匹配任意空白字符，等价于\t\n\r\f print(re.findall('\s','aAb\tc\r123_*()-= ')) //['\t', '\r', ' '] // \S 匹配任意非空字符 print(re.findall('\S','aAb\tc\r123_*()-= ')) //['a', 'A', 'b', 'c', '1', '2', '3', '_', '*', '(', ')', '-', '='] // \d 匹配任意数字，等价于[0-9] print(re.findall('\d','aAb\tc\r123_*()-= ')) //['1', '2', '3'] // \D 匹配任意非数字 print(re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71a9cc03e4ee9e077e456c27d609870/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e84a442e72ebfae292ae1764a04952d/" rel="bookmark">
			海康工业相机功能模块-IO输入输出控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海康工业相机功能模块sdk调用介绍
IO输入输出控制 前言IO输入IO输出 前言 机器视觉行业里面，相机作为最重要的图像传感器，除了主要的拍摄功能外，它也承担了一部分信号控制功能.
一方面能够接受外部的触发信号例如PLC、光电传感器等，进行指定时刻拍照；另外一方面，能够输出IO信号，控制外围机构进行机械运动；
海康标准工业相机，支持1路GPIO输入，1路GPIO输出，一路可配置的IO输出（非光耦），本文主要讲一下如何使用SDK进行IO配置以及注意事项
IO输入 IO输入的主要作用就是，相机通过IO管脚，收到1个IO信号，相机就立即拍摄一帧图像；
通用的使用方法如下代码依次设置：
触发模式：TriggerMode设置为1，开启触发模式触发源选择：TriggerSource设置为0，选择line0，也可以选择line2，或者选择anyway；line0、line2取决于硬件电路接线，anyway支持软触发、硬触发同时使用，需要看相机是否支持沿信号TriggerActivation：默认上升沿触发（可以不设置）触发缓存TriggerCacheEnable：默认不开启。当相机同时收到两个触发信号时，不开启此功能，相机只会响应1个信号，出一张图；开启后，相机会自动缓存第二个信号，上个信号处理完毕后，立即处理缓存信号触发延时TriggerDelay：收到信号后，固定延迟一段时间再曝光滤波设置 LineDebouncerTime：去除信号毛刺抖动，根据实际情况进行调节 //C语言代码段：硬触发模式初始化配置 //参数值，仅针对海康工业相机，其他品牌相机需根据对应节点微调 nRet = MV_CC_SetEnumValue(handle, "AcquisitionMode", 2); //0:SingleFrame 1:MultiFrame 2:Continuous nRet = MV_CC_SetEnumValue(handle, "TriggerMode", 1);//0：off 1：on nRet = MV_CC_SetEnumValue(handle, "TriggerSource", 0);//line2也可做输入源，非光耦 //0:Line0 1:Line1 2:Line2 7:Software 8:FrequencyConverter 13：anyway nRet = MV_CC_SetEnumValue(handle, "TriggerActivation", 0);//0：Rising Edge 1：Falling Edge 2：LevelHigh 3：LevelLow nRet = MV_CC_SetFloatValue(handle,"TriggerDelay",0);//根据实际情况设置，默认0 us nRet = MV_CC_SetBoolValue(handle,"TriggerCacheEnable",TRUE);//开启后会默认缓存1个信号 //滤波设置 nRet = MV_CC_SetEnumValue(handle, "LineSelector", 0);//0:Line0 2:Line2 nRet = MV_CC_SetIntValue(handle,"LineDebouncerTime",10);//硬件滤波时间，可加大此参数防抖us 触发配置：
滤波：
IO输出 IO输出，参考用法主要分为两类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e84a442e72ebfae292ae1764a04952d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f943e59d3ab5bdf14bf08d87e82dbe/" rel="bookmark">
			java多线程学习之七—如何优雅的停止线程（池）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中内容整理自《Java并发编程实战》
方法一：使用中断标志 使用 cancelled 标志，当标志状态为true的时候，停止线程。
示例：
public class Test0701CancelThread implements Runnable { public static void main(String[] args) { Test0701CancelThread cancelThread = new Test0701CancelThread(); try { cancelThread.aSecondOfPrimes(); } catch (InterruptedException e) { e.printStackTrace(); } } private final List&lt;BigInteger&gt; primes = new ArrayList&lt;&gt;(); private volatile boolean cancelled; @Override public void run() { System.out.println("执行线程"); BigInteger p = BigInteger.ONE; while (!cancelled) { p = p.nextProbablePrime(); synchronized (this) { primes.add(p); } } } public void cancel() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f943e59d3ab5bdf14bf08d87e82dbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c89f888b6cdd62830e1e6c57a97303bc/" rel="bookmark">
			java最新版安装教程_手把手教你安装Eclipse最新版本的详细教程 （非常详细，非常实用）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
首先声明此篇文章主要是针对测试菜鸟或者刚刚入门的小伙们或者童鞋们，大佬就没有必要往下看了。
写这篇文章的由来是因为后边要用这个工具，但是由于某些原因有部分小伙伴和童鞋们可能不会安装此工具，为了方便小伙伴们和童鞋们的后续学习和不打击他们的积极性，因为80%的人都是死在工具的安装这第一道门槛上，这门槛说高也不高说低也不是太低。所以宏哥就抽时间水了这一篇文章。
第一步：下载eclipse，并安装。
1、首先打开官方地址(见下面)
Eclipse官方下载地址：点击打开官方链接
下载链接：http://www.eclipse.org/downloads/
2、点击 Download Packages;
4、下载安装包
如图：根据自己的系统选择64位的，点击相应链接下载(可能会弹出一个需要你付费的页面，并不是eclipse需要付费，这只是请求你捐钱的，无需理会)
下载完成后，解压安装包，解压路径随意。
打开之后，选中图中的文件，在桌面创建快捷方式，安装告一段落，可以尝试双击打开运行一下，应该会有bug。(这是因为没有安装JDK)
第二步：下载JDK。
1、下载JDK安装包
2、点击java之后，在第一个框中，点选Accept License Agreement
3、下载完成后，打开一路确定安装即可。
第三步：java环境变量配置。
1、我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量设置
2、变量配置
要让系统变量中(第二个框是系统变量)有path和classpath这两个变量，方法是：
点击新建，变量名：path，变量值：刚刚JDK的安装路径，例如我的：C:\Program Files\Java\jdk1.8.0_121\bin。
同样新建，变量名：classpath，变量值:C:\Program Files\Java\jdk1.8.0_121\jre\lib\rt.jar
到这里，就已经配置完成了，接下来可以打开DOS命令(开始菜单右键，运行：CMD)输入javac，显示如下图一样就可以了。
3、第二种配置方法：
“变量名”：JAVA_HOME
“变量值”：C:\Program Files\Java\jdk1.7.0_07//你安装的jdk的磁盘路径
“变量名”：Path
“变量值”：%Java_Home%\bin;%Java_Home%\jre\bin;
“变量名”：ClassPath
“变量值”：.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar
注：上面的代码最好也是一个字符不变的贴上去，“变量值”最前面的 .; 不要漏掉。
做完上面的三个步骤之后，环境变量的配置已经完成了。
检查环境变量搭好了：调出“cmd”检查
1、输入：“java”，你应该看到下面的东西：
2、输入“javac”，你应该看到下面的东西：
3、输入“java -version”，你应该看到下面的东西：
安装和配置完环境变量，再次双击桌面上的Eclipse图标，Eclipse启动成功。
小结
好了，菜鸟们到此Eclipse的安装就已经全部结束和完成。
您的肯定就是我进步的动力。如果你感觉还不错，就请鼓励一下吧！记得点波 推荐 哦！！！(点击右边的小球即可！(^__^) 嘻嘻……)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b60aa7455145e2feaa5ee7390b4d7b/" rel="bookmark">
			java二进制细节转base64_Java如何将二进制数据编码为Base64字符串？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package org.nhooo.example.commons.codec;
import org.apache.commons.codec.binary.Base64;
import java.util.Arrays;
public class Base64Encode {
public static void main(String[] args) {
String hello = "Hello World";
//encodeBase64方法采用byte []作为参数。字节[]
// 可以来自本示例中的简单字符串，也可以来自
// 图像文件数据。
byte[] encoded = Base64.encodeBase64(hello.getBytes());
// 打印编码的字节数组
System.out.println(Arrays.toString(encoded));
// 打印编码的字符串
String encodedString = new String(encoded);
System.out.println(hello + " = " + encodedString);
}
}
我们程序的结果：[83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 61]
Hello World = SGVsbG8gV29ybGQ=
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b60aa7455145e2feaa5ee7390b4d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982a30ef86ea06196a2cf724d95bb5e6/" rel="bookmark">
			java nio socketchannel_Java NIO学习笔记六   SocketChannel 和 ServerSocketChannel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java NIO SocketChannel是连接到TCP网络socket(套接字)的通道。Java NIO相当于Java Networking的socket(套接字)。有两种创建SocketChannel的方法：
打开SocketChannel并连接到互联网上的某个服务器。
当一个连接接入到一个ServerSocketChannel时，SocketChannel就会被创建。
打开一个SocketChannel
打开一个SocketChannel：
SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(“http://jenkov.com”，80));
关闭SocketChannel
使用完SocketChannel后，可以通过调用SocketChannel的close()方法，将其关闭。
代码展示：
socketChannel.close();
从SocketChannel读取数据
要从SocketChannel您那里读取数据，可以调用read()方法。
代码：
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf);
首先：进行Buffer分配，从SocketChannel中读取的数据到Buffer中。
然后：调用SocketChannel的read()方法。将数据从SocketChannel中读入Buffer。返回值是int，表示有多少字节数据被读入到Buffer缓存中。如果返回-1，则到达端到端(连接已关闭)。
数据写入SocketChannel
SocketChannel使用SocketChannel的write() 方法来写入数据，该方法使用Buffer做参数。
代码展示：
String newData =“要写入文件的新字符串...”+ System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()){
channel.write(buf);
}
注意SocketChannel.write()在while循环中如何调用该方法。不能保证write()方法写入SocketChannel的字节数。因此，我们重复调用write()，直到Buffer没有字节可以写入。
非阻塞模式
您可以将SocketChannel设置为非阻塞模式。在非阻塞模式下，你可以以异步方式调用connect()，read()并write()方法。
connect()
如果SocketChannel是非阻塞模式，并且您调用connect()，方法可能会在建立连接之前返回。要确定连接是否建立，可以调用finishConnect()方法，如下所示：
socketChannel.configureBlocking(假);
socketChannel.connect(new InetSocketAddress(“http://jenkov.com”，80));
while(！socketChannel.finishConnect()){
//做其他的事情
}
write()
在非阻塞模式下，write()方法在不写任何数据的情况下可以返回。因此，你需要在循环中调用write()方法。代码同上。
read()
在非阻塞模式下，read()方法可以在没有读取任何数据的情况下返回。因此，您需要注意返回的值int，这表示读取了多少个字节。
具有选择器的非阻塞模式
这种非阻塞模式的SocketChannel效果要比Selector好点。通过使用Selector注册一个或一个以上SocketChannel，你可以访问已经准备读、写通道的Selector。
Java NIO ServerSocketChannel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/982a30ef86ea06196a2cf724d95bb5e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b399d93b32c505904ca1e4c938f57732/" rel="bookmark">
			Java NIO之SocketChannel和ServerSocketChannel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SocketChannel SocketChannel是java nio 提供的用于连接两台计算机进行通信的套接字通道，把Channel去掉就剩下Socket，可见与Socket有着相似的功能。
SocketChannel可以实现非阻塞的功能，包括连接非阻塞，IO非阻塞。SocketChannel与Selector多路复用器配合还可以实现基于select或者epoll的多路复用机制的网络IO模型。SocketChannel安全地给多个线程并发使用，但是多个线程使用该SocketChannel是互斥的。同一时间只能给一个线程使用。SocketChannel支持OP_READ、OP_WRITE、OP_CONNECT事件。 获取API:
//打开并返回一个SocketChannel，但是此时通道还未连接。 public static SocketChannel open() //打开并返回一个SocketChannel ，并且进行将其连接到远程地址。 public static SocketChannel open(SocketAddress remote) 读写API:
//往套接字通道写数据ByteBuffer，用于传输到远程地址计算机上。 public abstract int write(ByteBuffer src) //往套接字通道写数据ByteBuffer，用于传输到远程地址计算机上。 /** * 往套接字通道写数据，用于传输到远程地址计算机上。 * srcs ：ByteBuffer数组，会对里面的ByteBuffer成员顺序进行读取写入。 * offset ：读取ByteBuffer数组的起始下标。 * length：读取ByteBuffer数组的元素个数。 * 与FileChannel该方法一样，详情可以参考博主另一篇FileChannel详解文章。 */ public abstract long write(ByteBuffer[] srcs, int offset, int length) /** * 往套接字通道写数据，用于传输到远程地址计算机上。 * srcs ：ByteBuffer数组，会对里面的ByteBuffer成员顺序进行读取写入。 */ public final long write(ByteBuffer[] srcs) /** * 读取远程套接字通道传输过来的数据。 */ public abstract int read(ByteBuffer dst) /** * 读取远程套接字通道传输过来的数据。 * 与FileChannel该方法一样，详情可以参考博主另一篇FileChannel详解文章。 */ public abstract long read(ByteBuffer[] dsts, int offset, int length) /** * 读取远程套接字通道传输过来的数据。 * 与FileChannel该方法一样，详情可以参考博主另一篇FileChannel详解文章。 */ public final long read(ByteBuffer[] dsts) 其他API：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b399d93b32c505904ca1e4c938f57732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850748047ffab8a713cf842816a36582/" rel="bookmark">
			maxon motor 471486电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于maxon motor 471486电机的探索记录 最近工作遇到了这款maxon motor 471486的电机，记录一下折腾他的成果
电机结构 maxon motor 471486这款电机分为三个部分，分别是齿轮箱，电机与编码器。
要写控制代码主要看种传感器【MR 编码器, M 型, 32 线, 2 通道】
驱动方式与参数 找到该编码器的文档（只有一个目录页……不知道本体在哪……）查看接线引脚
由上图所示，VCC与接地是编码器的电源，VCC范围在2.7~5.5V。电机+与电机（下文称为电机-）引脚为电机的控制引脚，电压只要看电机的文档，这里我给的是5V左右。电机的方向靠电机+与电机-来决定，两边相同电压时就停止，当电压差为正时则正传，负电压是为反转。
正转反转停止停止电机+1011电机-0111 通道A、通道B则为反馈引脚，当电机转动的时候通道AB会产生高低电平变化
所以，使用外部中断即可判断电机转了多少度。当电机停止后，通道A和通道B会保持一种状态，这个需要自己上示波器测量看是低电平还是高电平。
以下附上以上点击的相关代码，希望能帮助到大家
sbit motor_1=P2^6;//电机控制脚1 sbit motor_2=P2^7;//电机控制脚2 sbit motor_feedback=P3^2;//电机脉冲反馈【外部中断，获取】 sbit motor_direction=P3^3;//电机前进后退反馈【1为前进，0为后退】 uint motor_pulse_count=0;//脉冲计数变量 uchar motor_direction_sign=0;//前进后退标志位 /***************************************************************** 函数名	：Motor_Action 函数输入： 返回	：无 函数作用： 电机设置函数，控制电机前进、后退与速度 *******************************************************************/ void Motor_Action(){ switch(motor_direction_sign){ case 1:{//动作-前进 P_SW2 = 0x80;//设置初值 PWM6T1= 0;//在计数值为XX地方输出高电平 PWM6CR= 0x80;//使能PWM0输出 PWM7T1= motor_speed*100+700;//在计数值为XX地方输出高电平 PWM7CR= 0x80;//使能PWM0输出 P_SW2 = 0; }break; case 2:{//动作-后退 P_SW2 = 0x80;//设置初值 PWM6T1= motor_speed*100+700;//在计数值为XX地方输出高电平 PWM6CR= 0x80;//使能PWM0输出 PWM7T1= 0;//在计数值为XX地方输出高电平 PWM7CR= 0x80;//使能PWM0输出 P_SW2 = 0; }break; default :{//动作停止 P_SW2 = 0x80;//设置初值 PWM6T1= 200;//在计数值为XX地方输出高电平 PWM6CR= 0x80;//使能PWM0输出 PWM7T1= 200;//在计数值为XX地方输出高电平 PWM7CR= 0x80;//使能PWM0输出 P_SW2 = 0; } } } /***************************************************************** 函数名	：Motor_One_Action 函数输入：无 返回	：无 函数作用： 电机推针一次【定时器中运行】 *******************************************************************/ void Motor_One_Action(){ unsigned int jjj;//缓存步进数 if(execute_one_motor_operation==1){ motor_direction_sign=1;//开启电机前进 if(motor_pulse_count&gt;5000){//当标志位值1后 motor_direction_sign=0;//停止电机前进 dms++;if(dms&gt;2000){ttt=1;dms=0;}//计时语句 if(ttt==1){//当ttt暂停标志为置一后，结束一推流程 jjj=motor_pulse_count;//将该次的步进数存入jjj motor_pulse_count=0;//脉冲计数清零，准备下一次计数 Used_pricknum++;Used_pricknum_sign=1;//更新已打次数 execute_one_motor_operation=0;//结束标志 ttt=0; } } } if(motor_direction==1){ //前进了几步 motor_scope=motor_scope+jjj; }else{ //后退了几步 motor_scope=motor_scope-jjj; } } 以上即是基于STC8A4K16S2A12主控对maxon motor 471486电机的控制代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850748047ffab8a713cf842816a36582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a0d20290e5d2f24dd9c82e5b05c1e6/" rel="bookmark">
			C语言程序设计  设计用函数实现模块化程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 函数是什么 函数就是功能。每一个函数用来实现一个特定的功能。函数的名字反映其代表的功能。
一个C程序可由一个主函数和若干个其他函数构成。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。
例题 想输出以下的结果，用函数调用实现。
编写程序和运行结果：
分析：
print_star和print_message都是用户定义的函数名，分别实现输出一行“*”号和一行信息的功能。两个函数的类型为void，意为函数为空类型，即无函数值，执行这两个函数后不会把任何值带回main函数。
说明：
(1)一个源程序文件可以为多个C程序所调用。
(2)在程序编译时是以源程序文件尾单位进行编译的。
(3)在程序执行时总是main函数开始执行的。
(4)函数间可以相互调用，但不能调用main函数
(5)从用户使用的角度来看，函数有两种。
一，库函数，是由编译系统提供的。二，用户自定义函数，是用户自己设计的，用来实现用户指定的功能。
从函数的形式来看，函数分两类。
一，无参函数。主函数和调用函数之间不发生传递的数据。无参函数应指定为void类型。二，执行被调用函数时会得到一个函数值，供主函数使用。有参函数应定义与返回值相同的类型。
2 函数的定义和调用 2.1 定义函数 所有函数，必须“先定义，后使用”。指定它的功能和它的名字。
定义函数应包括以下4个内容：
(1)指定函数的名字，以便以后按名调用。
(2)指定函数的类型，即函数值的类型。
(3)指定函数的参数的名字和类型，以便在调用函数时向它们传递数据。对无参函数不需要这项。
(4)指定函数的功能。
2.1.1 定义无参函数 定义无参函数的一般形式：
类型名 函数名()
{
函数体
}
函数体包括声明部分和执行部分。
类型名指定函数值得类型，即函数带回来的值的类型。
2.1.2 定义有参函数 定义有参函数的一般形式：
类型名 函数名(形式参数表列)
{
函数体
}
例如：
return z的作用是将z的值作为函数的值带回到主函数中，成为函数返回值。
2.2 调用函数 2.2.1 调用无参函数的形式 函数名()
如 print_star()
2.2.2 调用有参函数的形式 函数名(实参数表列)
如max(a,b)
实参数表列包含多个实参，各参数用逗号隔开。实参与形参的个数应相等，类型一致。实参与形参按顺序对应，实参向形参传递数据。
例题：输入两个整数，求输入两者中的大者。要求主函数中输入两个整数，用一个函数max求出其中的大者，并在主函数输出此值。
编写程序和运行结果：
分析：
定义函数是函数后面括号中的变量名称为形参。在主函数中调用一个函数时，函数名后面括号中的参数称为实参。
函数名max和两个形参x，y以及形参的类型int。max后面的括号内的a和b是实参。a=1传给x，b=2传给y。
函数调用的过程：
(1)在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。
(2)将实参对应的值传给形参。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a0d20290e5d2f24dd9c82e5b05c1e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1872d664aafef40fa5d4642cfa8fc0a0/" rel="bookmark">
			安卓开发软件培训！腾讯3轮面试都问了Android事件分发，面试必问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 相信前几天在朋友圈晒无聊的小伙伴们，也陆续结束了假期。很多公司为了员工的健康考虑，启动了远程办公模式。
床在桌边，饭在桌上，家里一切都那么安逸，专心工作真的是一件难事。远程工作最大的敌人就是：你的自制力。战胜自己，以后你一定是做成大事的人。
除了好好工作，远程办公还有一个好处是时间比较自由，抓紧一些自由的时间赶紧充电学习。越是空闲时间，越是你追赶别人的绝佳机会。
企业开始上班，就意味着大批量的招聘需求正在路上。所以利用好这段时间，开工后就是你进入大厂的最佳时机。
拉勾网通过与近百家知名企业的深入沟通，结合拉勾 50w+ Java 岗位需求和国内外一线实战讲师，历时 15 个月，对标阿里 P7 技术要求打磨而成**《Java工程师高薪训练营》**是你在这个假期，非常值得学习的内容。
二、显示系统基础知识 在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：
2.1 基础概念 屏幕刷新频率 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。刷新频率取决于硬件的固定参数（不会变的）。
逐行扫描 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 / 60 ≈ 16ms。
帧率 （Frame Rate） 表示 GPU 在一秒内绘制操作的帧数，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。
画面撕裂（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图
2.2 双缓存 2.2.1 画面撕裂 原因 屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU/GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。
简单说就是Display在显示的过程中，buffer内数据被CPU/GPU修改，导致画面撕裂。
2.2.2 双缓存 那咋解决画面撕裂呢？ 答案是使用 双缓存。
由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。
双缓存，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 Back Buffer，而显示器使用 Frame Buffer，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1872d664aafef40fa5d4642cfa8fc0a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4d14521d5de4a264f3e948ad9f0329f/" rel="bookmark">
			面试官：说说 typeof 与 instanceof 区别?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、typeof typeof 操作符返回一个字符串，表示未经计算的操作数的类型
使用方法如下：
typeof operand typeof(operand) operand表示对象或原始值的表达式，其类型将被返回
举个例子
typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof null // 'object' typeof [] // 'object' typeof {} // 'object' typeof console // 'object' typeof console.log // 'function' 从上面例子，前6个都是基础数据类型。虽然typeof null为object，但这只是JavaScript 存在的一个悠久 Bug，不代表null就是引用数据类型，并且null本身也不是对象
所以，null在 typeof之后返回的是有问题的结果，不能作为判断null的方法。如果你需要在 if 语句中判断是否为 null，直接通过===null来判断就好
同时，可以发现引用类型数据，用typeof来判断的话，除了function会被识别出来之外，其余的都输出object
如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a)， 若a未声明，则报错)
if(typeof a != 'undefined'){ //变量存在 } 二、instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4d14521d5de4a264f3e948ad9f0329f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6334be92c11ebd5f445607f841e224b3/" rel="bookmark">
			java通过poi进行导出_java操作Excel之POI（5）利用POI实现使用模板批量导出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台导出方法：
在源文件夹src下面放个准备好的模板：/com/cy/template/userExportTemplate.xls，这个模板有头部一行；
/**
* 后台导出方法
* 利用POI实现使用模板批量导出数据
*/
public String export2() throws Exception{
Connection con = null;
try{
con = dbUtil.getCon();
ResultSet rs = userDao.userList(con, null);
Workbook wb = ExcelUtil.fillExcelDataWithTemplate(rs, "userExportTemplate.xls");
//把wb以流的形式输出
ResponseUtil.export(ServletActionContext.getResponse(), wb, "利用模板导出Excel.xls");
}catch(Exception e){
e.printStackTrace();
}finally{
try{
dbUtil.closeCon(con);
dbUtil.closeRs(rs);
}catch(Exception e){
e.printStackTrace();
}
}
return null;
}
处理Excel的Util：
先读取这个模板，创建一个工作簿Workbook，然后塞数据，再返回这个工作簿，相当于对模板做了修改。
/**
* 处理Excel的util
*/
public class ExcelUtil{
public static Workbook fillExcelDataWithTemplate(ResultSet rs, String templateFileName) throws Exception{
InputStream is = ExcelUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6334be92c11ebd5f445607f841e224b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eeee9d47fad012b7ef4a932c003dba2/" rel="bookmark">
			python 如何截取特定字符前或后的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似之前R语言的处理思路：
R语言 如何截取字符串特定字符前或后的字符串
可以借助split()函数来实现
split()函数使用方法 string.split() 其中string是字符串名字
分割后会返回一个列表，其中的元素是切割后的字符串。再提取其中元素，即可得到特定字符前或后的字符串
下面来看一个例子
例子 url = http://jwxk.ucas.ac.cn/courseManage/saveCourse?s=9aa012dd-f96a-47c7-ba1d-ed4c824b42b6 需要截取出：url后半段的
9aa012dd-f96a-47c7-ba1d-ed4c824b42b6
用作下一步的参数提交
print(url.split("s=")) # 未加序号 print(url.split("s=")[1]) # 提取分割后的后半部分 结果分别是：
['http://jwxk.ucas.ac.cn/courseManage/saveCourse?', '9aa012dd-f96a-47c7-ba1d-ed4c824b42b6'] '9aa012dd-f96a-47c7-ba1d-ed4c824b42b6' url.split(“s=”)[1]实现了需要的功能
如果要提取前半部分，把代码中的数组下标由1替换为0即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83edb5d765058687c240d37be0fa8321/" rel="bookmark">
			Git提示Another git process seems to be running in this repository, e.g. an editor opened by ....错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Another git process seems to be running in this repository, e.g. an editor opened by ‘git commit’. Please make sure all processes are terminated then try again. If it still fails, a git process may have crashed in this repository earlier: remove the file manually to continue.
它的翻译是：
另一个git进程似乎在这个存储库中运行，例如由’git commit’打开的编辑器。 请确保所有流程终止然后再试一次。 如果它仍然失败，那就是一个git进程可能早先在此存储库中崩溃：手动删除文件以继续。
大概意思就是说，当前已经有了一个编辑器打开了“git commit”指令，请关闭所有git相关的进程重试，否则，请手动删除那个文件。
windows对于进程的同步互斥管理，是有资源上锁机制的。猜测这里肯定是有进程对某资源进行了加锁，但是由于进程突然崩溃，未来得及解锁，导致其他进程访问不了
我们删除互斥的一个文件就行了，进入工作区目录下的隐藏文件.git，其中的index.lock文件删除掉，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddfbe9cd6413954943c6b25211f389de/" rel="bookmark">
			小型PHP论坛搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单整理了一下之前开发的PHP论坛，测试可以使用，欢迎star
https://github.com/bealright/Small-forum-based-on-PHP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263e70a887ef26f71380a5e48addea7a/" rel="bookmark">
			C#登陆后获取另一个网页数据带验证码和token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章是有关模拟登录网站方面的。URL信息我是goole下面的开发者工具中获得
实现步骤；
使用HttpWebRequest和HttpWebResponse
启用一个web会话获取验证码（POST或者GET）在获取验证码的时候提取CooKie和token拼接另一页面的URL获取数据 首先我建了HTTPHELPER类 如下： using System; using System.Collections.Generic; using System.Collections.Specialized; using System.IO; using System.Linq; using System.Net; using System.Reflection; using System.Text; using System.Text.RegularExpressions; using System.Threading.Tasks; namespace WindowsFormsApp4 { class HTTPHELPER { public static CookieContainer container = null; //存储验证码cookie #region 登录 public string requestM(string vaildate) //密码和账号我是直接复制页面中header里面的 { HttpWebRequest request = null; HttpWebResponse response = null; try { request = (HttpWebRequest)HttpWebRequest.Create("登录页面URL"); request.Method = "Post"; request.ContentType = "application/x-www-form-urlencoded; charset=UTF-8"; request.UserAgent = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263e70a887ef26f71380a5e48addea7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e30d5715ee73c121a5be72c0017eea2/" rel="bookmark">
			前端解析csv文件（文本文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端解析csv文件（文本文件） CSV文件格式实际上就是以逗号为分隔符的文件形式（实际也就是一种纯文本文件），在业务中经常用来批量存储数据用来批量上传至服务器存储在数据库中。
一般情况下前端只需要将文件上传至后台交给后台的同学去处理和解析，但也不排除某些特殊场景下需要前端自己去处理；
处理步骤：上传文件 -&gt; 前端自己拿到上传的文件 -&gt; 将文件解析成文本 -&gt; 建文本按照自己需要的形式处理成数据。
比如上图所示的csv文件，我们用fileReader的readAsText方法读取后得到如下结果：
fileReader读取文件方法：
const fileReader = new FileReader(); fileReader.readAsText(file); fileReader.onload = function() { console.log(this.result); }); fileReader读取文件结果：
Variable Name,Variable Alias,Group,Read Write Acess,Node Id Counter1,CounterAlias,,1,ns=sdsd&amp;vf=1,default_group Counter2,CounterAlias,,2,ns=sdsd&amp;vf=2 Counter3,CounterAlias,,0,ns=sdsd&amp;vf=3 ,CounterAlias,,0,ns=sdsd&amp;vf=4 这个结果就是以换行符和逗号分隔得到的一个字符串：
然后调用字符串的方法将其分隔成我们需要的格式（数组）：
方法：
const fileReader = new FileReader(); fileReader.readAsText(file); fileReader.onload = function() { let data = this.result.split("\n"); let variables = []; data.map(v =&gt; { if (v) { variables.push(v.split(",")); } }); }; 得到结果：
[ ["Variable Name"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e30d5715ee73c121a5be72c0017eea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6198edddcbac16faedd24d43e8a91d70/" rel="bookmark">
			java中servlet dal bll model_GitHub - Tolerating/leave-jsp-Servlet: 使用jsp &#43; Servlet搭建的mvc,学习java web 开...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发工具为IntelliJ IDEA 2019.1.3 x64
数据库为 Sql Server 2008R2
该项目并非完整的,只是对Servlet和java和jdbc学习的实践
项目结构
![src目录](data:img/jpg;base64,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
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6198edddcbac16faedd24d43e8a91d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ca0d4c9d193c4fbc025878703d46bc/" rel="bookmark">
			python3之多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程简介 我们进行程序开发的时候，肯定避免不了要处理并发的情况，一般并发的手段有采用多进程和多线程，但线程比进程更轻量化，系统开销一般也更低，所以大家更倾向于用多线程的方式处理并发的情况。
python3 中多线程使用threading模块中的Thread类来实现多线程并发的，threading为python3标准库中的模块，无需安装，直接导入使用即可。
Thread类 Thread类的主要参数如下所示，仅需重点关注target与args两个参数即可，target参数表示要传入的函数名，args参数则是出入函数需要使用的参数，格式必须为元组，不然报错。
class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) 对上面的常用参数的解释
target 传入要运行的函数名name 线程名称，默认格式为Thread-N,N为数字args 传入需要的参数值，格式为元组，最后以“,”结尾（a,b,）daemon 属性默认是 False Thread类基本使用方法 python 中使用多线程有两种方式，一种是创建threading.Thread的实例对象，传入需要执行的函数和参数来使用，另一种则是继承Thread类，重写run()方法来确定执行的内容。
创建Thread对象实例来执行的示例
Thread类中常用的函数
start(),启动线程join() 阻塞调用线程，个人实验中以为，join()线程调用该函数之后，将在执行完该线程之后继续主线程，否则主线程会与启动的子线程同步执行isAlive()，线程是否存活getName()，获取线程名称setName(),设置线程名称 join 函数作用的实验 实验时调用join函数，则done均为最后输出，若注实掉join函数的两行代码则done在中间便会输出。
import threading def pr1(): for i in range(100): print("pr1 " + str(i)) def pr2(): for i in range(100): print("pr2 " + str(i)) thread1 = threading.Thread(target=pr1) thread2 = threading.Thread(target=pr2) thread1.start() thread2.start() thread1.join() thread2.join() print("done") Thread模块使用 直接使用
from threading import Thread def test(value): print(value) for i in range(10): a = Thread(target=test, args=(i,)) #建议这样写，以免报错 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ca0d4c9d193c4fbc025878703d46bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a4fce82f955d4e448dfc84119fa9b4/" rel="bookmark">
			URL报错：unknown protocol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		URL报错：unknown protocol，未知协议 问题分析： 在使用new URL(filePath)出现此错误，原因是传入的字符串不是一个URL，所以无法识别。
解决方法： 若是本地文件，检查路径前面是否添加了file://
示例：String filePath = "D:/Users/Administrator/Desktop/test.txt"; // 添加文件协议 filePath = "file://"+filePath; URL url = new URL(filePath); 2.若是网络路径， 检查传入的字符串是否以http:// 开头，或者以https://开头
扩展 报错：unknown protocol: f
解决一： 解析的文件包括路径不能有中文字符
解决二：将URL路径转码
URLEncoder.encode(filePath, "utf-8"); URL常用协议类型：
① file 资源是本地计算机上的文件。格式file://
② ftp 通过 FTP访问资源。格式 FTP://
③ http 通过 HTTP 访问该资源。 格式 http://
④ https 通过安全的 HTTPS 访问该资源。 格式 https://
⑤ mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ce7a79ca6c4b32cfd636d6c6235de0/" rel="bookmark">
			【蓝桥杯省赛JavaB组真题详解】剪邮票（2016）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 剪邮票
如【图1.jpg】, 有12张连在一起的12生肖的邮票。
现在你要从中剪下5张来，要求必须是连着的。
（仅仅连接一个角不算相连）
比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。
请你计算，一共有多少种不同的剪取方法。
请填写表示方案数目的整数。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。
解题思路 使用暴力枚举，从 12 个格子中枚举出 5 个格子，然后判断这 5 个格子是否连通，判断连通可以用 DFS
参考代码
import java.util.*; public class Main { static boolean[] book = new boolean[13]; static int[] path = new int[5]; static int[][] map = new int[3][4]; static Set&lt;String&gt; set = new HashSet&lt;String&gt;(); static int ans; public static void main(String[] args) { dfs(0); System.out.println(ans); } static void dfs(int idx) { if (idx == 5) { int[] tmp = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ce7a79ca6c4b32cfd636d6c6235de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79068c04fac765f87095a07dd74cc028/" rel="bookmark">
			java中一个父类可以有几个子类_JAVA的单继承中允许一个父类有多个子类吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
java中对于继承，java只支持单继承。java虽然不e5a48de588b63231313335323631343130323136353331333365646262直接支持多继承，但是保留了这种多继承机制，进行改良。
单继承：一个类只能有一个父类。
多继承：一个类可以有多个父类。
为什么不支持多继承呢?
因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢?因为父类中的方法中存在方法体。
但是java支持多重继承。A继承B B继承C C继承D。
多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。
所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。
简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。
子父类出现后，类中的成员都有了哪些特点：
1：成员变量。
当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。
如果想要调用父类中的属性值，需要使用一个关键字：super
This：代表是本类类型的对象引用。
Super：代表是子类所属的父类中的内存空间引用。
注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce33e448671858fa8778be009c96579/" rel="bookmark">
			Nginx 错误页面无法显示add_header设置的响应头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 错误页面无法显示add_header设置的响应头 nginx在使用add_header指令设置了返回的请求头后
add_header X-Frame-Options "SAMEORIGIN"; 请求如果返回的是200的状态码，在返回的响应头中会包含设置的值
但是如果请求返回的状态码是404这类错误的响应时，设置的值会失效。
解决办法：
在nginx 1.7.5以后的版本，新增了always参数，在设置请求头后增加该参数即可。如：
add_header X-Frame-Options "SAMEORIGIN" always; 增加该参数后404页面也会显示add_header设置的值
404页面也会显示add_header设置的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef57a74afee51421df535694c2431c4/" rel="bookmark">
			MDK5.25以上版本解决j-link “the connected j-link is defective“ 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题
MDK更新到5.32之后，无论是使用J-LinkOB烧写程序还是在线仿真都会提示如下：
然后轻则每次都需要把这个警告去掉，仿真可能遇到问题，重则程序直接闪退（我遇到每次都是闪退）。实测从5.25开始就遇到了这类问题，更低版本的没有测试
二、原因 MDK在5.25之后，使用了更高版本的J-link驱动（可以在MDK安装路径下的ARM/Segger文件夹下找到），某宝十几块钱的盗版J-linkOB会被识别出来，所以提示J-link是虚假的（defective）
三、解决办法 白嫖党买正版j-link是不可能的，通过百度总共找到两种办法：
一、安装较低版本的J-Link驱动，找到其安装目录，我的如下
并使用JLink_V512（这是我安装的版本，可变）文件夹中的文件替换MDK5安装目录下的ARM/Segger中的相同的文件，应该就俩个，如下：
不过我更换之后还是没有解决问题，不知道是否操作有误。
二、简单粗暴，不是低版本的MDK不会遇到这样的问题吗，那么我们就直接把低版本的MDK的Segger文件夹直接替换我们安装版本的Segger文件夹，问题完美解决，接下来就是怎么得到低版本的文件。我把它上传到网盘，我用的就是这个文件，可以放心下载，目前我使用的版本是5.32.
链接：https://pan.baidu.com/s/1mcJokBjiPTnQbixXFzFsvQ 提取码：wo21 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d8de92fe8e766b196d933e9b8aea9e/" rel="bookmark">
			解决git clone后无法找到文件的问题（通过指定地址）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天从github上clone了代码，最后出来形如：
但是话说我的东西下载到哪里去了呢？？？？摸不着头脑，然后百度之，发现一般会放在命令行对应的路径下，也就是
win + R &gt; cmd 查看命令行地址：
然后去此路径下寻找之，果然在这里。
那么，如何才能clone到自己指定的路径下呢？百度之得如下说法：
git clone https://github.com/jquery/jquery.git e:/myJQuery/ 以上命令行的结尾，指定你想要的目录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76da8272b832722c8add7200f3ac97a4/" rel="bookmark">
			R语言中的管道函数操作 %＞%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 R语言中的管道操作
%&gt;% ：相当于将左边的作为右边函数的第一个参数。
快捷键：ctrl+shift+M
例如：f(x,y)等价于x %&gt;% f(y)
g(f(x,y),z)等价于x %&gt;% f(y) %&gt;% g()
下面的例子就可以看出管道操作很方便
library(ggplot2) library(dplyr) cut_depth &lt;- group_by(diamonds,cut,depth) cut_depth &lt;- summarise(cut_depth,n=n()) cut_depth &lt;- filter(cut_depth,depth&gt;55,depth&lt;70) cut_depth &lt;- mutate(cut_depth,prop=n/sum(n)) cut_depth library(ggplot2) library(dplyr) library(tidyr) cut_depth1 &lt;- diamonds%&gt;% group_by(cut,depth)%&gt;% summarise(n=n())%&gt;% filter(depth&gt;55,depth&lt;70)%&gt;% mutate(prop=n/sum(n)) cut_depth1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45a345056b1bcfd68a4fd920a6cc42f/" rel="bookmark">
			istio-1.8.2 离线安装中出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		istio-1.8.2 离线安装中出现的问题 1.出现的istio-ingressgateway与istio-egressgateway的探针检测问题 这个问题国内外经常出现，google，百度都很多，但是没有人最终给一个确切的解决方法，分析很多，具体解决很少。在困扰半个多月，解决问题之后希望记录下来，让大家可以参考。
istio的版本为1.8.2，是这个时间较为新和稳定的一个版本，K8S的版本为1.18也是比较新和稳定的版本，集群环境为K8S上搭建了antrea网络，在此基础上搭建istio环境。以上环境全部为离线安装。后面可能会更新所有的离线安装的步骤。
该问题查看log日志为:（公司内网没有图片，所以只是贴一些打印信息）
Envoy proxy is NOT ready: config not received from Pilot (is Pilot running?): cds updates: 0 successful, 0 rejected; lds updates: 0 successful, 0 rejected
failed to create upstream grpc client: rpc error: code = Unavailable desc = connection error: desc = transport: Error while dialing dial tcp: lookup istiod.istio-system.svc on read udp i/o timeout
Error while dialing dial tcp: lookup istiod.istio-system.svc on 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45a345056b1bcfd68a4fd920a6cc42f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/111265bd96d1abb4dfb4490c63c8018a/" rel="bookmark">
			java开发必须安装jre吗_安装jdk后还需要安装jre吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
不需要，安装jdk的时候就会把jre一起安装了。
J2RE是Java2 Runtime Environment，即Java运行环境，只是强62616964757a686964616fe59b9ee7ad9431333431356637调其匹配Java2平台，有时简称JRE。如果要开发 Java软件，下载安装JDK就可以，在JDK中附带有JRE。
如果需要安装多个版本的JDK，Java的解决办法是每个程序自己携带一套JRE，也不需要额外安装，且互不影响。
扩展资料
1、 JDK和JRE的作用和关系
JRE是Java的运行环境，面向Java程序的使用者，而不是开发者。
如果你仅下载并安装了JRE，那么你的系统只能运行Java程序。JRE是运行Java程序所必须环境的集合， 包含JVM标准实现及 Java核心类库。它包括Java虚拟机、Java平台核心类和支持文件。它不包含开发工具(编译器、调试器等)。
JDK又称J2SDK(Java2 Software Development Kit)，是Java开发工具包，它提供了Java的开发环境(提供了编译器javac等工具，用于将java文件编译为class文件)和运行环境(提 供了JVM和Runtime辅助包，用于解析class文件使其得到运行)。
如果你下载并安装了JDK，那么你不仅可以开发Java程序，也同时拥有了运 行Java程序的平台。JDK是整个Java的核心，包括了Java运行环境(JRE)，一堆Java工具tools.jar和Java标准类库 (rt.jar)。
2、JDK和JRE的区别
JRE主要包含：java类库的class文件(都在lib目录下打包成了jar)和虚拟机(jvm.dll)；
JDK主要包含：java类库的 class文件(都在lib目录下打包成了jar)并自带一个JRE。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc787b0d1b878ad44ba136bb1db1dc0b/" rel="bookmark">
			Java入门教学第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java入门教学第一天 个人简介什么是程序？Java的发展史？Java的优势？Java分为三个体系：JAVA的编译器JDK安装JAVA的开发工具IDEA的安装打开IDEA汉化IDEA编写第一个Java程序创建一个Java文件 个人简介 本文由JAVA小白：林夕—梦雪编写
林夕—梦雪（本人）为自学者
如有错误请练习修改
欢迎各位道友提出建议
QQ:2190287907
Q群:1045395348
什么是程序？ 为了让计算机执行某些操作或解决某个问题
而编写的一系列有序指令的集合。
Java的发展史？ Java 是由Sun公司于1995年５月推出的，
Java面向对象程序设计语言和Java平台的总称。
后来Sun公司被Oracle（甲骨文）公司收购，
Java也随之成为Oracle公司的产品。
Java的优势？ Java的兼容性最强，Java的程序运行在Java虚拟机中，
由Java虚拟机去适配不同的系统，以达到同一份代码不同系统皆可用。
Java分为三个体系： JavaSE－Java标准版 JavaEE－Java企业版 JavaME－java微型版 JAVA的编译器JDK安装 进入官网 https://www.oracle.com/cn/java/按下面的步骤进行下载并安装
JAVA的开发工具IDEA的安装 1.进入官网https://www.jetbrains.com/zh-cn/下载
打开IDEA 汉化IDEA 编写第一个Java程序 创建一个Java文件 1.创建一个项目
2.创建包（用英文命名）
3.创建类（用英文命名）
4.编写程序并运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6784c613f21138e803123acbe0fe71/" rel="bookmark">
			java double 精度范围_float 和 double 范围和精度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做java已经有段时间了，可是遇到什么范围啊，精度啊就迷糊，虽然自己经常使用，自己的数据也从未超过int型的范围，但还是多了解下，用着才放心嘛……
1. 范围
float和double的范围是由指数的位数来决定的。
float的指数位有8位，而double的指数位有11位，分布如下：
float：
1bit(符号位) 8bits(指数位) 23bits(尾数位)
double：
1bit(符号位) 11bits(指数位) 52bits(尾数位)
于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。
其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。
float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。
2. 精度
float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。
float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；
double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc3960cbbb5eaa2b6a0ed7b9da424bc/" rel="bookmark">
			Pytorch：几行代码轻松实现Warm up &#43; Cosine Anneal LR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Warm up与Cosine Anneal 浅谈 warm up是深度学习炼丹时常用的一种手段，由于一开始参数不稳定，梯度较大，如果此时学习率设置过大可能导致数值不稳定。使用warm up有助于减缓模型在初始阶段对mini-batch的提前过拟合现象，保持分布的平稳，其次也有助于保持模型深层的稳定性。
详见 https://www.zhihu.com/question/338066667/answer/771252708
余弦退火是常用的学习率调整策略，目前在Pytorch中已经集成了相应API，见官方文档。其原理如下式，其中 η m a x \eta_{max} ηmax​为学习率最大值， η m i n \eta_{min} ηmin​为最小值， T c u r T_{cur} Tcur​为当前轮次， T m a x T_{max} Tmax​为半个周期：
实例如下：
图来自：https://zhuanlan.zhihu.com/p/93624972
torch.optim.lr_scheduler.LambdaLR 虽然Pytorch已经提供了余弦退火的相应API，但是要结合Warm up和Cosine Anneal就没有了相应的操作。
pytorch给我们提供了很多调整学习率的策略(详见官方文档)，其中有一个LambdaLR策略，让我们自己能够很方便地制定规则来调整学习率。其中，最重要的参数就是 lr_lambda，传入自定义的函数或lambda表达式，可以对Optimizer中的不同的param_groups制定不同的调整规则。
简单地理解，传入的lr_lambda参数会在梯度下降时对optimizer对应参数组的学习率乘上一个权重系数。
warm up + Cosine Anneal 代码实现 根据上小节介绍的LambdaLR，我们就可以很方便地实现warm up + Cosine Anneal。
需要注意，传入的lr_lambda参数是在原先的学习率上乘以一个权重，因此在实现Cosine Anneal时需要注意在最后除以base_lr。其他细节见代码注释：
import math import torch from torchvision.models import resnet18 model = resnet18(pretrained=True)	# 加载模型 optimizer = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc3960cbbb5eaa2b6a0ed7b9da424bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054fe8e6011192c82c406fef5ea91762/" rel="bookmark">
			java变量圆_（4）根据下面的要求实现圆类Circle.Java① 圆类Circle的成员变量：radius表示圆的半径.　② 圆类Circle的方法成员：　　　Circle（）：构造方法,将半径置...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Circle类：
import java.lang.Math;
public class Circle {
// 圆半径
private double radius;
// 构造方法,半径置零
public Circle(){
radius=0;
}
// 构造方法,创建Circle对象时将半径初始化为r
public Circle(double r){
radius=r;
}
// 获得圆半径
public double getRadius(){
return radius;
}
// 获得圆周长
public double getPerimeter(){
return 2*Math.PI* radius;
} }
测试类：
public class Test {
/**
* @param args
*/
public static void main(String[] args) {
// 创建Circle对象
Circle c = new Circle(5);
// 获取圆周长
System.out.println(c.getPerimeter());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/054fe8e6011192c82c406fef5ea91762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7fb9237f17d7b9b60e52e5714b93c6/" rel="bookmark">
			NPOI.HSSF 导入excel数据(记录)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://download.csdn.net/download/ttbat/15435334 NPOI.HSSF.Dll 下载地址。
在项目引用 NPOI.HSSF.Dll 后 using NPOI.HSSF.UserModel;
PS：excel文件只能读取1997-2003版本的，2007以上的excel版本无法读取。
/// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name="path"&gt;文件地址&lt;/param&gt; /// &lt;param name="_syptktService"&gt;&lt;/param&gt; /// &lt;param name="success"&gt;成功数量&lt;/param&gt; /// &lt;param name="failure"&gt;错误数量&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string ImprotSXSC(string path, ISYPTKTService _syptktService, out int success, out int failure) { string errorMsg = string.Empty; success = failure = 0; try { HSSFWorkbook hssfworkbook; using (FileStream file = new FileStream(path, FileMode.Open, FileAccess.Read)) { #region 检查excel数据 hssfworkbook = new HSSFWorkbook(file); HSSFSheet sheet = hssfworkbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af7fb9237f17d7b9b60e52e5714b93c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e7a87de85fcadfd05ce2a1408978e6/" rel="bookmark">
			单相机标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：单相机标定目的 1）校正畸变
2）变换到世界坐标系，用于实际物理尺寸的测量
2：标定过程 通过标定助手，过程很简单。
HALCON通过标定板进行标定的。标定板的选取：标定板占视野的三分一左右。
标定板图像的数量：大概左右10-20张，并不是越多越好。但要求移动标定板尽量覆盖相机视野。
具体过程参考博文：
https://blog.csdn.net/cashmood/article/details/100089295
https://blog.csdn.net/weixin_43197380/article/details/90438976
3: 算子 gen_caltab ：生成标定板文件
change_radial_distortion_cam_par：校正径向畸变，得到新的相机内参
gen_radial_distortion_map：根据标定得到的相机内参，生成畸变变换关系
gen_image_to_world_plane_map：根据标定得到的相机内外参，生成世界坐标变换关系
map_image：根据上面的两个变换，进行图像映射，校正畸变，变换到世界坐标系
4：畸变校正例子 *相机内参 CameraParameters := [0.00219846, -78129.2, 5.46495e-06, 5.5e-06, 318.206, 236.732, 640, 480] *相机外参，畸变校正只和内参有关 *CameraPose := [-0.0091626,-0.00625214,0.700967,2.46926,358.933,179.443,0] *校正径向畸变 change_radial_distortion_cam_par ('adaptive', CameraParameters, 0, CamParamOut) *对畸变生成投影映射 gen_radial_distortion_map (Map, CameraParameters, CamParamOut, 'bilinear') *对图像进行畸变校正 read_image (Image, 'pioneer') map_image (Image, Map, ImageMapped) 畸变校正只和内参有关。左图是原图，右图是畸变校正后图像
5： 畸变校正 + 坐标变换例子 参考博文https://blog.csdn.net/weixin_43197380/article/details/90438976，“三、实战：以一元硬币为例”
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/190/">«</a>
	<span class="pagination__item pagination__item--current">191/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/192/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>