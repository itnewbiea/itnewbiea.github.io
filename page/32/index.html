<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73ddfe3a4911ff65305ca9e58685c14/" rel="bookmark">
			vue3写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. &lt;script setup&gt; 1. 引入组件 import Head from "./conponents/head.vue" 2. 声明变量 // 引入 ref import { ref } from 'vue' const isNeedNav = ref(true) 3. 声明方法 const changeLossd = () =&gt; { lossdVisible.value = !lossdVisible.value } 4.生命钩子函数 onBeforeMount(() =&gt; {}) onMounted(() =&gt; {}) onBeforeUpdate(() =&gt; {}) onUpdated(() =&gt; {}) onBeforeUnmount(() =&gt; {}) onUnmounted(() =&gt; {}) 5.父传子参数 父：
&lt;Body :twentyFour="twentyFour"&gt;&lt;/Body&gt; 子：
const porps = defineProps({ twentyFour: String, }) JS 中取值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73ddfe3a4911ff65305ca9e58685c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2096ea684d608063fa1257274a15b178/" rel="bookmark">
			中国法拍房数量统计预测模型_2023和2024年法拍房数量竟是...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		法拍房主要平台
法拍房主要平台有3家，分别是阿里、京东和北交互联平台。目前官方认定纳入网络司法拍卖的平台共有7家，其中阿里资产·司法拍卖平台的挂拍量最大。
阿里法拍房数据显示2017年，全国法拍房9000套；2018年，法拍房数量2万套；2019年，法拍房数量50万套；2020年，法拍房数量133万套；2021年，法拍房数量168万套。2021年6月之后，阿里拍卖便不再发布法拍房的月报或周报；
2022年3月后，阿里拍卖平台上不再直接显示各地法拍房挂拍次数。但从上述统计机构来看，过去一年法拍房数量仍在持续增加中，挂牌量接近百万套。有的媒体预测2022年阿里法拍房数据为325-380万套，但这个数据没法核实，仅作参考。
为了核实2022年法拍房数据，Toby老师调用math，pylab,numpy三个库，纯手工写了2000多行代码，实现了6个中国法拍房预测模型，模型可以根据喂养数据自动筛选最优模型，然后预测下一年法拍房数据。Toby老师写的代码均采用函数封装，可实现极速预测。
给模型代入2017年到2021年阿里法拍房数据
list_x=[1,2,3,4,5]list_y=[9000,20000,500000,1330000,1680000] 我的模型通过智能筛选，判断模型6为最佳预测模型，R方为0.958，模型性能优越。预测2022年法拍房数据为264万套。
下图可见，我的模型6的数据拟合效果相当不错。模型显示法拍房增量是非常陡峭的。
如果按照今日头条媒体描述10月法拍房新增挂牌数量9.9898万，推测一下，2022年6-12月，每月保持不增长的新增，到现在估计也有380万套。
输入2017年至2022年阿里平台法拍房数据，程序自动筛选子模型6为最佳预测模型，其R方为0.945，模型性能优秀。
#代码bug咨询作者邮件 231469242@qq.com list_x=[1,2,3,4,5,6] list_y=[9000,20000,500000,1330000,1680000,3800000] 模型数据拟合情况如下图，数据拟合整体情况也比较好。
模型残差分析2021年和2022年的wrong number数据有的大，因此2022年法拍房为380万套可能有偏差。大概率介于260-380万套之间。
最后，我们把2022年法拍房数据设置为300万套，用模型来预测一下2023年法拍房数据。2023年阿里平台法拍房预测结果接近400万套。网络司法拍卖的平台共有7家，阿里法拍平台并不完全统计全国所有法拍房。全国真是法拍房数据可能明显高于模型预测结果。当然400万套是非常令人吃惊数据，这意味着无数企业和家庭财务破产。
当然我希望阿里法拍房内部工作人员给我私信或邮箱留言，验证我的模型预测结果是否准确，邮箱231469242@qq.com。
业务意义分析
阿里法拍房平台统计数据中可见2018年为关键转折点，2018年后法拍房数量激增，2019年法拍房数量是2018年的25倍。
法拍房的本质是债务违约。产权人资不抵债，其房屋被银行抵押拍卖。
那么2018年，中国金融圈发生了什么大事件？
1.P2P暴雷
2018年6月份，央妈和银保监会开始向P2P市场释放加强监管的信号，P2P市场的发展，戛然而止。6月1日至7月12日的42天内，全国108家P2P平台爆雷，涉及的资金超过7万亿。Toby老师认为P2P平台爆雷造成多个企业或个人破产，和法拍房数据上涨有重要原因。中国绝大多数人是贷款买房，且很多居民被高利率诱惑，把钱投资p2p。随着P2P暴雷，居民或企业资产变为泡影，必然无力继续还银行房贷，法拍房数量当然激增。
有个案例，阿姨所投的4个平台，40万元，一家已经跑路，剩下的，不是资金无法取出，就是强行被投入下一轮。“我觉都睡不着，明天我就要去北京看看那家公司到底还在不在！我高铁票都买好了！”
2.中国楼市经历“史上最严调控”
2018年，中国楼市经历“史上最严调控”，多地围绕“房住不炒”定位密集出台调控政策。“坚决遏制房价上涨，加快建立促进房地产市场平稳健康发展长效机制”成为房地产市场主基调。楼市紧缩代表信贷紧缩，这和债务违约，法拍房数据上涨也有一定相关性。中国央行在2018年１月、４月、７月和10月，先后四次实施定向降准，向市场净释放资金约2.3万亿元，以保持流动性合理充裕。央行4次降准也说明了当时市场资金紧缩多么严重。信贷紧缩意味着大量企业瘦身，优化员工，失去工作后，居民无力偿还房贷，也会造成法拍房数量激增。
3.中国居民债务攀升
据统计，国内的家庭债务一直不断攀升。截至2017年，我国家庭债务与可支配收入之比高达107.2%，这意味着居民挣得钱还不够还债，而这些数据还不包括潜在的的民间借贷等这些没有办法被统计的部分。不断飙升的债务下，还银行房贷自然是亚历山大，而且房屋贷款是长期的，一般是20-50年，30年的居多。每年逐步上升的医疗，教育内卷，物价上涨都在减少居民的可支配收入。居民手里的钱越来越少，但要坚持30年房贷不中断，这难度不压于西游记的西天取经。一时买房爽，30年还债步步艰难。
4.股票下跌
2018年上证综指、深圳成指全年分别下跌24.6%、34.4%，均创10年来最大跌幅。创业板指、中小板指分别下跌28.7%、37.8%。股票市场也是居民的重要投资途径，居民在股票市场赔的惨，可支配收入自然减少，这也会影响到还房贷。
美元是全球经济的不稳定因素
这次数据分析也有意外收获，就是发现以美元为结算货币的金融体系并不稳定，而是周期性发生金融危机。
第一次金融危机是1988—1989，第二次金融危机是1998—1999，之间相差10年；第三次金融危机是2008—2009，也是相差10年；那第四次金融危机，难道就是2018—2019，着预测的很准。2018年确实是艰难的一年。
去美元化，全球结算货币多元化是以后必然发展趋势。所以我们在新闻上经常看到下面信息。
中国法拍房数量统计预测模型和业务分析就为大家介绍到这里。我们在做机器学习建模，统计分析时一定要核实业务逻辑，不能盲目相信机器算法计算结果。我们要尽可能做到算法和业务的交叉验证。
欢迎学习更多风控建模相关知识《python金融风控评分卡模型和数据分析微专业课》，我们提供专业评分卡模型等知识，实现自动化信用评分功能，打造金融风控信贷审批模型，降低风险。微信二维码扫一扫收藏课程。
我们公司提供一对一机器学习模型定制服务，用于企业建模，论文定制服务，提供公司正规发票，。如果你需要建模项目定制服务，商务留言联系作者。
作者Toby，来源公众号python风控模型，中国法拍房数量统计预测模型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85eb9116f7c38bb89a5af12fe68014bd/" rel="bookmark">
			​kubernetes文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​kubernetes文档 链接
Changes to the location of Linux packages for Kubernetes
k8s的linux包位置的变化
The legacy Linux package repositories
遗留的linux包仓库
(apt.kubernetes.io and yum.kubernetes.io AKA packages.cloud.google.com)
have been frozen starting from September 13, 2023 and are going away in January 2024, users must migrate.
Please read our announcement for more details.
Kubernetes Documentation
Documentation
Kubernetes is an open source container orchestration engine
开源容器引擎
for automating deployment, scaling, and management of containerized applications.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85eb9116f7c38bb89a5af12fe68014bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e06e3443274143f40b21ee61d13b15/" rel="bookmark">
			k8s简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 k8s简介 mtlion
一、为什么需要 k8s？ 1. 应用部署模式的演进
虚拟化模式
容器化模式
相比虚拟机和容器
容器更加轻量级，启动更快（秒级）容器可移植性更好 2. 管理大量的容器带来了新的挑战
容器编排调度引擎 —— k8s 的好处
简化应用部署提高硬件资源利用率健康检查和自修复自动扩容缩容服务发现和负载均衡 二、k8s 的集群架构 主节点，承载 k8s 的控制和管理整个集群系统的控制面板 工作节点，运行用户实际的应用
k8s 集群组件
三、pod —— k8s 调度的最小单元 1. 一个 pod 包含一组容器，一个 pod 不会跨越多个工作节点
pod 不会跨越工作节点
2. 了解 pod
pod 相当与逻辑主机，每个 pod 都有自己的 IP 地址pod 内的容器共享相同的 IP 和端口空间默认情况下，每个容器的文件系统与其他容器完全隔离 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe16e1f3cffdf4d7fc631618022382f9/" rel="bookmark">
			《三十》模块化打包构建工具 Rollup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Rollup4。
Rollup 是一个 JavaScript 的模块化打包工具，可以帮助编译微小的代码到庞大的复杂的代码中（例如一个库或者一个应用程序）。
Rollup 和 Webpack 的区别： Rollup 也是一个模块化的打包工具，但是它主要是针对 ESModule 进行打包的（当然也有解决办法可以处理其他模块化代码）；Rollup 更多时候是专注于处理 JavaScript 代码（当然也可以处理其他文件）；配置理念相对于 Webpack 来说更加简洁和容易理解。
Rollup 中处理任何文件都是使用对应的插件。
Webpack 是一个模块化的打包工具，可以针对各种模块代码；可以通过 Loader 处理各种类型的文件以及它们之间的依赖关系。
Webpack 中是通过 Loader 来转换文件，通过 Plugin 来执行其他的逻辑。
通常在实际开发中都会使用 Webpack，例如 React、Vue、Angular 项目都是基于 Webpack 的；在对库文件进行打包时，通过会使用 Rollup，例如 React、Vue、dayjs 源码本身都是基于 Rollup 的。
Rollup 的基本使用： 在命令行中使用 Rollup： 新建一个 rollup-demo 文件，运行 npm init -y 对其进行初始化。安装 Rollup：npm install rollup -D。新建 src/index.js 文件，并编写代码。const sum = (num1, num2) =&gt; { console.log(num1 + num2) } export { sum } 运行 npx rollup .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe16e1f3cffdf4d7fc631618022382f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a0fe18db8b81caa198720d284af770/" rel="bookmark">
			js-json 对象字符串相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // "\{\}" 这种字符串也能装换成对象 var obj = JSON.parse(str); //由JSON字符串转换为JSON对象 var last = JSON.stringify(obj); //将JSON对象转化为JSON字符 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b7c88fe2cdec08855b3564bbb61a67/" rel="bookmark">
			Js Vue 汉字转拼音 —— pinyin-pro （包含提取拼音首字母，多音字，自定义拼音等）- 附完整示例 &#43; 附源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pinyin-pro ：是一个专业的 JavaScript 中文转拼音的库，具备多音字识别准确、体积轻量、性能优异、功能丰富等特点。
在同类产品中，pinyin-pro 无论是多音字识别准确率、体积、性能还是功能的支持度上，都做到了全网领先。以下是关于性能及准确率方面和同类竞品 pinyin、@napi-rs/pinyin 的具体对比数据。
效果 特色功能 支持拼音/声母/韵母/首字母/音调/全部信息支持人名姓氏模式支持文本和拼音匹配支持自定义拼音支持获取带拼音汉字的 HTML 字符串支持获取汉字的所有拼音极致的性能和极高的拼音识别准确率 一、介绍 1、官方文档：介绍 | pinyin-pro 介绍 | pinyin-projs汉字转拼音库。获取中文拼音、韵母、声母、声调、首字母，支持拼音匹配https://pinyin-pro.cn/guide/compare.html
2、API （1）pinyin: 拼音转换
（2）match: 拼音汉字匹配
（3）customPinyin:自定义拼音
（4）html: HTML字符串
（5）polyphonic: 全部读音
3、部分API及示例 4、源码 https://github.com/zh-lx/pinyin-pro
二、准备工作 1、安装依赖包 # 选择一个你喜欢的包管理器 # NPM $ npm install pinyin-pro --save # Yarn $ yarn add pinyin-pro # pnpm $ pnpm install pinyin-pro 注：也可以通过浏览器的 script 标签导入 CDN 文件使用
快速开始 | pinyin-pro
2、示例版本 "pinyin-pro": "^3.16.3", 三、使用步骤 1、在单页面引入 'pinyin-pro' import { pinyin } from 'pinyin-pro'; 2、具体使用（这里以获取拼音首字母为例） pinyin('中国', { pattern: 'first', toneType: 'none', }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b7c88fe2cdec08855b3564bbb61a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aa77e69334cff782e1e9bc94359352/" rel="bookmark">
			Python语言：随机生成几个数案例分析讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
在某一节课上，老师使用xx通软件随机生成几个学号，并让对应学号同学回答问题。虽然我对xx通软件没啥好感，不过感觉这个随机生成学号功能挺不错的。今天我用python实现一个这个功能。
其实原理挺简单的，就是就是在一堆数字里随机挑选几个数字打印输出。
方法实现
""" 我们首先导入 random 模块。 然后，使用 random.randint(a, b) 方法 生成一个范围在 a 和 b 之间（包括 a 和 b）的随机整数。 将生成的随机数赋值给变量， 并使用 print 函数将其打印出来。 """ 写一个案例，此案例为Python语言在实际教学生活中的运用。
import random print("随机生成5个学号，对应学号同学进行早八点名签到") for i in range(1,6): a = random.randint(1,51) print(a) 运行结果如下：
总结
这个案例估计许多老师都喜欢吧
本文结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddec5bff564f56eaf527e09401a065cb/" rel="bookmark">
			并发&amp;多线程编程-synchronized、Volatile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc] 基础知识并发编程的优缺点缺点优点 并发编程三要素多线程的劣势： Synchronized概述四个特性使用方式1：修饰实例方法方式2：修饰代码块方式3：修饰静态方法具体使用：双重校验锁单例模式 synchronized 底层实现原理 volatile三大特性可见性防止指令重排无原子性 基础知识 并发编程的优缺点 缺点 并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如**：内存泄漏、上下文切换、线程安全、死锁**等问题。
优点 充分利用多核CPU的计算能力：通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升方便进行业务拆分，提升系统并发能力和性能：在特殊的业务场景下，先天的就适合于并发编程。现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。
并发编程三要素 并发编程三要素（线程的安全性问题体现在）：
原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。 可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile） 有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序） 出现线程安全问题的原因：
线程切换带来的原子性问题 缓存导致的可见性问题 编译优化带来的有序性问题 解决办法：
JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题synchronized、volatile、LOCK，可以解决可见性问题Happens-Before 规则可以解决有序性问题 并行和并发有什么区别？
并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。
并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。
串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。
做一个形象的比喻：
并发 = 两个队列和一台咖啡机。
并行 = 两个队列和两台咖啡机。
串行 = 一个队列和一台咖啡机。
多线程的劣势： 线程也是程序，所以线程需要占用内存，线程越多占用内存也越多； 多线程需要协调和管理，所以需要 CPU 时间跟踪线程； 线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。 Synchronized 概述 在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。
另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddec5bff564f56eaf527e09401a065cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffc38d9a34a6faa95f89823d851ebc9/" rel="bookmark">
			【K8S in Action】服务：让客户端发现pod 并与之通信（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务是一种为一组功能相同的 pod 提供单一不变的接入点的资源。当服务存在时，它的 IP 地址和端口不会改变。 客户端通过 IP 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 pod 上。
外部客户端无须关心服务器数量而连接到前端 pod 上。
前端的 pod需要连接后端的数据库。 由于数据库运行在 pod 中， 它可能会在集群中移来移去， 导致 IP 地址变化。 当后台数据库被移动时， 无须对前端pod 重新配置。
pod 是短暂，会删除增加，调度到其他节点，数量变更。
在 pod 启动前会给已经调度到节点上的pod 分配 IP 地址，即客户端提前不知道Pod的IP地址。
水平仲缩意味着多个 pod 可能会提供相同的服务。 无需关注提供服务 pod 的数量，以及每个Pod的IP。
1 服务与服务发现 1 创建Service 服务 创建了一个名叫kubia的服务，它将在端口80接收请求并将连接路由到具有标签选择器是app=kubia的pod的8080端口上。 Kubernetes服务代理截取的该连接， 在根据标签选择器选中的Pod 中，任意选择了一个pod, 然后将请求转发给它。
apiVersion: vl kind: Service metadata： name: kubia spec: ports: - name: http port: 80 targetPort: 8080 转发到容器端口 - name: https 同一服务暴露多个端口 port: 443 targetPort: 8443 selector: 标签选择器适用的服务 app: kubia sessionAffinity: ClientIP 会话亲和性,统一客户端产生的所有请求每次都指向同一个pod kubectl get svc NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ffc38d9a34a6faa95f89823d851ebc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526d40b0d83682c3d0e60724ab2710b9/" rel="bookmark">
			python使用requests提交post请求并上传文件（multipart/form-data）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、请求接口上传文件
2.1、分析接口
2.2、python进行请求
三、总结
一、背景 也是前几天，有一个需求上传文件需要自动化。具体是上传到系统一个文件，并收到返回结果。考虑使用python的requests，一般这种查询或上传文件的接口都是post请求。所以就直接使用requests的post请求。但是在开发过程中，遇到一些问题需要注意。所以在此记录一下。
二、请求接口上传文件 2.1、分析接口 首先浏览器f12查看接口内容（主要看接口类型、请求头、Payload）。发现上传文件的接口是post类型，请求头中Content-Type也很重要，指定内容类型及请求体的一个分隔符。详见下图。
Payload里是接口的请求体，详见下图。接口参数：type、orgType、file ，分别对应下图。其中，file的值为上传的文件（转换为二进制数据） 对应参数的请求内容，其中------WebKitFormBoundary5rEpBecoRZ2tj60k为分割符，每两个分割符之间对应一个参数。
2.2、python进行请求 # 请求头 ''' 这里注意，要将Content-Type注释掉。因为在请求的时候，会自动加上。 ''' header = { 'Authorization': '1677034306556', 'Connection': 'keep-alive', # 'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryFXTT4S1LKA1LUDBd', 'Cookie': 'SHIROJSESSIONID=75ace860-0f00-4db0-9440-6c6d53cdf101', 'Host': 'host:8088', 'Origin': 'http://host:8088', 'Referer': 'http://host:8088/njfxq/search/clue/clueFeedBackDetailAll?id=1574192996457648130&amp;Paramspage=clue&amp;caseId=1567439544410976257', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36' } # 请求体Payload ''' 这里有必要解释下： 如果请求体按照页面显示的配置如下： fileObject = { 'type':'6', 'orgType': 'B', 'file': open('上传文件.xlsx','rb') } 是错误的（第一次花费半天才调通） // 正确的格式应该是传入一个元组，格式为：(&lt;fileName&gt;,&lt;fileObject&gt;,&lt;Content-Type&gt;) ，这里的fileObject是指具体的值。 正确的请求体应为： fileObject = { 'type':(None,'6',None), 'orgType': (None,'B',None), 'file': ('上传文件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526d40b0d83682c3d0e60724ab2710b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39e8826e016b1551d6de213736f2ad4/" rel="bookmark">
			六款常用 SSH 远程连接工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Xshell
介绍：
xshell 是一个非常强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Windows 平台的 TELNET 协议。Xshell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。
官网：
https://www.netsarang.com/zh/xshell/ 2、secureCRT
介绍：
SecureCRT 支持 SSH，同时支持 Telnet 和 rlogin 协议。SecureCRT 是一款用于连接运行包括 Windows、UNIX 和 VMS 的理想工具。通过使用内含的 VCP 命令行程序可以进行加密文件的传输，网工应该很熟这个软件，经常使用它连接设备。
官网：
https://www.vandyke.com 3、WinSCP
介绍：
WinSCP 是一个 Windows 环境下使用 SSH 的开源图形化 SFTP 工具客户端。同时支持 SCP 协议。它的主要功能就是在本地与远程计算机间安全的复制传输文件。
官网：
https://winscp.net/ 4、PuTTY
介绍：
PuTTY 是 SSH 和 telnet 客户端，最初由 Simon Tatham 为 Windows 平台开发。用 MIT 许可证授权。包含的组件有：PuTTY, PuTTYgen,PSFTP, PuTTYtel, Plink, PSCP, Pageant, 默认登录协议是 SSH，默认的端口为 22。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39e8826e016b1551d6de213736f2ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc3df2543d4ba5a7b910b8c1c341540/" rel="bookmark">
			Android RecyclerView 动画处理 流程 原理（源码分析第二篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、本文主题 本文要解决的问题：
1. Recyclerview 动画的实现原理是什么？
2. 处理的主要流程大概是怎样的？
一、核心原理 我们抛开代码，想一下，RecyclerView中的view动画有几种？
添加一个view：添加的View 显示出来，它下面的所有view向下移动一格距离
删除一个view：删除的View 渐隐掉，它下面的所有view向上移动一格距离
上下滑动：所有子view上下滑动
移动：…
归纳起来，最终实现动画的时候，无外乎会执行几个操作：
添加或删除View的 透明度动画 0-&gt;1 或 1-&gt;0
子view的y轴坐标，由动画前的位置，滑动到 动画后的位置（我们暂时只讨论常见的竖向布局）
所以，看似复杂的RecyclerView动画处理，经过分解后，其实就是一个view的简单动画，没有任何新奇的玩意或算法。
所有需要做的就是，记录下动画执行前view的状态（透明度，y坐标），以及计算出动画的目的地（透明度，y坐标），然后执行动画，仅此而已，这就是RecyclerView动画实现的核心原理。
二、源码分析 - 主流程 经过上面的分析，其实我们的重点变成了，view数据的组织与记录（动画前），view的数据的计算（动画后），心里要有这个数。
然后，我们大概看一下，整个流程：
2.1 最终执行动画的 核心接口：RecyclerView.ItemAnimator
核心实现类：DefaultItemAnimator
核心实现方法：DefaultItemAnimator.runPendingAnimations()
调用栈如下：
DefaultItemAnimator.runPendingAnimations() — 核心方法
|
RecyclerView.mItemAnimatorRunner
|
RecyclerView.postAnimationRunner()
|
ViewInfoStore.ProcessCallback
|
ViewInfoStore.process(ProcessCallback callback)
|
RecyclerView.dispatchLayoutStep3() 触发动画的根
=== RecyclerView.java private void dispatchLayoutStep3() { ...... // Step 4: Process view info lists and trigger animations mViewInfoStore.process(mViewInfoProcessCallback); } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cc3df2543d4ba5a7b910b8c1c341540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef1f6a5b6dd3dc8806e1a77936346d8/" rel="bookmark">
			el_table的this.$refs.MainTable.toggleRowSelection(row, true)；事件会触发selection-change
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们遇到需求：
在点击时el-table行时，同时选中el-table的多选框。
&lt;el-table border ref="MainTable" :height="'100%'" :data="tableLeft" @select="handleSelect" @row-click="handleClick" &gt; handleClick(row){ this.$refs.MainTable.toggleRowSelection(row, true); }, 在点击el-table行时，需求同时选中跟当前行人不同的申请单。比如点击当前人名叫小雪，那么同时选中el-table中小雪的所有不同申请单。
&lt;el-table border ref="MainTable" :height="'100%'" :data="tableLeft" @select="handleSelect" @row-click="handleClick" @selection-change="handleSelectionChange" &gt; handleClick(row){ this.curRow = JSON.parse(JSON.stringify(row)) // hisIsOne：选中一个人是否选中其所有的申请单标识 if (this.hisIsOne === "0") { let arr = []; let requisitionId = this.curRow.requisitionId; this.tableLeft.forEach((i) =&gt; { if (i.patientSoid === this.curRow.patientSoid) { arr.push(i); } }); if (arr.length &gt; 0) { arr.forEach((j) =&gt; { if (j.requisitionId !== requisitionId) { this.$refs.MainTable.toggleRowSelection(j, true);//①---多选框选中 } }); } } }, // ①处就会触发这一行代码 handleSelectionChange(val){ //多选框做的事。。。。。。。 } ①处的代码因为是循环遍历，所以肯定会多次触发多选事件，那么如何拿到最后一次的多选事件呢（因为多选事件中，最后一次的事件获取的才是最终的）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef1f6a5b6dd3dc8806e1a77936346d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e529972c2522d531f5c72595c4f543ec/" rel="bookmark">
			滤光片的作用和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滤光片的作用和原理
滤光片是一种可以选择性地传透或者吸收特定频率范围内光线的光学元件。它的主要作用是控制光的颜色和强度,常用于调节光线的亮度、改变光线的色彩、过滤掉杂乱的光线等。
滤光片的原理基于光的干涉和吸收。一般来说,滤光片的材料具有特定的能级结构,能够选择性地吸收特定波长的光线。当光线通过滤光片时,只有与滤光片能级结构匹配的波长的光被吸收,而非匹配的波长的光则被传透。这样,滤光片可以选择性地过滤掉不需要的波长的光线,只留下特定波长的光线通过。
滤光片的材料和结构决定了它能够过滤掉的波长范围。常见的滤光片包括分光镜、偏振片、彩色滤光片等。其中,分光镜能够将光线按照不同的波长分离出来;偏振片能够选择性地传透或者阻挡特定方向的偏振光;彩色滤光片能够选择性地吸收特定颜色的光线。
总之,滤光片通过选择性地吸收或者传透特定频率的光线,实现了控制光线颜色和强度的功能。这使得滤光片在摄影、光学仪器、光谱分析等领域有着广泛的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d06af426c03cc6998be4ba201f673de/" rel="bookmark">
			Windows Knowledge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 GRUB简介
1.1 MBR和PBR
MBR分为GRUB.MBR和DOS.MBR。
由于硬盘上扇区从偏移0到偏移62属于同一个磁道0，虽然DOS.MBR仅占用一个扇区，但是需要将DOS.MBR后面的偏移1到偏移62保留，所以磁盘上第一个分区的第一个扇区是从偏移63开始的。fbinst软件会保留1-16064扇区，等于硬盘1个柱面的大小255 x 63 x 512 = 8MB，所以第一个分区是从扇区16065开始的。
USB-ZIP和USB-FDD会将U盘的第一个扇区格式化成DOS.PBR而不是DOS.MBR。
USB-FDD和USB-ZIP的来历：软盘的容量小，没有分区结构，所以软盘是没有MBR的，整个软盘只有一个分区，第一个扇区就是PBR；FDD和ZIP模式在DOS下启动后U盘的盘符是A。
1.2 GRUB
- GRUB又叫OS Loader；在Android系统上，kernelflinger是OS Loader的一个EFI应用
- GRUB镜像组成：GRUB.MBR（boot.img）, 硬盘扇区offset 1 到offset 62放置GRUB的core.img，/boot分区的boot/grub/grub.cfg
1.3 创建USB-FDD或者USB-ZIP格式U盘步骤
1）Android上：dd if=/dev/zero of=/dev/block/sda bs=512 count=4
2）Windows上：快速格式化该U盘，这个U盘就只有PBR扇区而没有MBR扇区
2 Windows安装
2.1 BIOS设置
进入BIOS设置，一般有Del、Enter、Esc等键。
2.2 Windows ISO刻录方法
Windows上的Universal USB Installer工具软件：刻录操作系统ISO文件到U盘
Linux下将操作系统ISO文件刻录到U盘：dd if=xxx.iso of=/dev/sda 注意使用的是整个磁盘，所以用的是sda而不是sda1
2.3 Windows GHO镜像安装方法 - 比较常见
1) 制作PE启动U盘
2) 下载Windows ISO镜像后（番茄花园），解压出来，里面包含GHO文件，拷贝到PE启动U盘的GHO文件夹（或者提前将文件.gho拷贝入待装系统的电脑D盘根目录）。
3) 插入PE启动U盘到电脑USB 2.0口，选择从U盘启动，启动到PE界面后，选ghost方式安装，ghost镜像的后缀名.gho。
2.4 Win10临时关闭驱动签名
This PC - Advanced system settings - Advanced - Environment Variables
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d06af426c03cc6998be4ba201f673de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c756acfb01a4a7790ea159b6faadf07/" rel="bookmark">
			Spark RDD的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按颜色区分转换：
绿色是单 RDD 窄依赖转换黑色是多 RDD 窄依赖转换紫色是 KV 洗牌型转换黄色是重分区转换蓝色是特例的转换 单 RDD 窄依赖转换 MapPartitionRDD 这个 RDD 在第一次分析中已经分析过。简单复述一下：
依赖列表：一个窄依赖，依赖上游 RDD分区列表：上游 RDD 的分区列表计算流程：映射关系（输入一个分区，返回一个迭代器）分区器 ：上游 RDD 的分区器存储位置：上游 RDD 的优先位置 可见除了计算流程，其他都是上游 RDD 的内容。 map 传入一个带“值到值”转化函数的迭代器（例如字符串到字符串长度）mapPartitions 传入一个“迭代器到迭代器”的转化函数，如果需要按分区做一些比较重的过程（例如数据库连接等）flatMap 传入一个“迭代器到迭代器的迭代器”的转化函数（例如，统计字母，“字符串的迭代器”到“‘字符的迭代器’的迭代器”）filter 传入了一个带“值到布尔值”筛选函数的迭代器 PartitionwiseSampledRDD 在分区中采样的RDD
分区列表：在上游的分区的基础上包装一个采样过程，形成一个新的分区PartitionwiseSampledRDDPartition计算流程：采样器返回的迭代器其他成分：与上游 RDD 相同 PartitionwiseSampledRDD，有放回的采样用泊松采样器，无放回的采样用伯努利采样器，传给分区器。 多 RDD 窄依赖 UnionRDD 依赖列表：每个上游 RDD 一个RangeDependency，每个RangeDependency依赖上游 RDD 的所有分区分区列表：每个上游 RDD 一个UnionPartition，构成列表计算流程：获得目标分区的迭代器分区器 ：None存储位置：每个上游 RDD 的优先位置 CartesianRDD 笛卡尔积，是两个 RDD 每个数据都进行一次关联。下文中两个 RDD 的关联中，两个 RDD 分别称为 rdd1、rdd2。
依赖列表：两个窄依赖组成的数组，分别依赖 rdd1、rdd2分区列表：“rdd1的分区数 乘以 rdd2的分区数”个分区计算流程：rdd1的一条记录与 rdd2的一条记录合成元组分区器 ：None存储位置：rdd1、rdd2的存储位置的积 洗牌型转换 洗牌型转换，是多个 RDD 关联的的转换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c756acfb01a4a7790ea159b6faadf07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2a067a93c8b2a5d4fb8e364518f5b7/" rel="bookmark">
			RDD是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDD是Spark的基础，是对大数据的抽象，所以先破解Spark，首先从RDD开始。
* RDD 是什么？有什么特点？
* RDD 包含什么？
* RDD 能做什么？
文尾有结论
RDD 的注释
org.apache.spark.rdd.RDD 类源代码中有详细的注释：
A Resilient Distributed Dataset (RDD), the basic abstraction in Spark.
翻译：弹性的 分布式 数据集是 Spark 基础的抽象。
解释：弹性的（可复原的），说明数据集具有容错性、可修复性。 分布式，说明数据集可以分布在不同的机器上
Represents an immutable, partitioned collection of elements that can be operated on in parallel.
翻译：RDD 是不可变的 分区的 可并行处理的 元素集合
解释：不可变的，这和 Scala 的设计理念相同，数据集一旦构建完成，就不能再修改，这样能轻松解决多个线程读数据的一致性问题。 分区的=可并行处理的=分布式
This class contains the basic operations available on all RDDs, such as map, filter, and persist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c2a067a93c8b2a5d4fb8e364518f5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7cd7ac165d55619104084c63fef7587/" rel="bookmark">
			iptables v1.6.1: can‘t initialize iptables table `filter‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux系统：AlmaLinux 9.2
容器内部加载iptables失败：
bash-4.4# iptables -nvL iptables v1.6.1: can't initialize iptables table `filter': Table does not exist (do you need to insmod?) Perhaps iptables or your kernel needs to be upgraded. 分析：
理论上来说，宿主机和容器是公用内核的，iptables是基于 iptable_filter这个模块的，
使用lsmod查看内核有没有加载这个模块，发现的确没有加载，
加载内核模块iptable_filter
[root@localhost ~]# modprobe iptable_filter [root@localhost ~]# lsmod | grep ip iptable_filter 16384 0 ip_tables 28672 1 iptable_filter nf_defrag_ipv6 24576 1 nf_conntrack nf_defrag_ipv4 16384 1 nf_conntrack 成功加载iptable_filter以后发现容器内就可以使用iptables了
bash-4.4# iptables -nvL Chain INPUT (policy ACCEPT 8847 packets, 1353K bytes) pkts bytes target prot opt in out source destination Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 9207 packets, 1257K bytes) pkts bytes target prot opt in out source destination 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea776a795d14e6cad9af16ddfc59396/" rel="bookmark">
			python安装库问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.basicsr库安装 pip install -i https://mirrors.aliyun.com/pypi/simple tb-nightly pip install -i https://pypi.tuna.tsinghua.edu.cn/simple basicsr==1.4.2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46731ee9a39169de9deb735e3f12df3/" rel="bookmark">
			uniapp使用webview嵌入vue页面及通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近刚做的一个需求，web端（Vue）使用了FormMaking库，FormMaking是一个拖拉拽的动态设计表单、快速开发的一个东西，拖拽完之后最终可以导出一个很长的json，然后通过json再进行回显，快速开发，但是因为FormMaking是基于Vue和ElementUI的，uniapp中不能直接使用，只能采用webview的方式进行嵌入。就是把Vue项目中的要嵌入的页面加入到白名单，也就是不需要登陆就可以访问该页面，直接将该页面通过webview嵌入到uniapp中即可
本来想着是将uniapp中的token传到webview页面中，在要嵌入的webview页面（Vue页面）中去获取json进行渲染的，但是通过webview嵌入到uniapp中，在webview页面去发请求会有问题，本来uniapp做的就少一些，更是第一次做webview，所以这两天还是碰到不少坑。
最终方案就是在uniapp中获取那一大串儿json，然后传递到webview页面进行渲染，然后提交表单的时候再通知webview页面（Vue页面）将表单json再传递给uniapp进行提交。所以就涉及到了uniapp与webview之间的通信问题，接下来介绍：
1、uniapp中嵌入外部网页： &lt;template&gt; &lt;view class="index"&gt; &lt;web-view :update-title="false" :src="wvSrc" &gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { wvSrc: "" } }, onLoad() { // #ifdef APP-PLUS this.wvSrc = `http://192.168.124.19:3000/#/index`; // #endif }, } &lt;/script&gt; &lt;style scoped&gt; .index { width: 100%; height: 100%; position: relative; } &lt;/style&gt; 就是直接给src复制就可以。上面给webview标签设置了update-title为false，它默认的是true，也就是默认webview嵌入进来上面的标题会跟随webview的自动更新，就会覆盖掉uniapp自身的标题，设置为false就不会覆盖
2、uniapp向webview页面传值 2.1. 先看第一种：通过路径传递 就是在嵌入的时候就直接在后面拼接上参数，但是这个最好只传递字符串，因为传递json对象的话在解析的时候可能会出问题，并不太推荐这种方式，如果只是一两个简短的字符串的话，还是可以的啦。
uniapp页面传递：
let tk = 'test_token' let id = 'pppppppiiiiiigggg' let status = 'start' this.wvSrc = `http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46731ee9a39169de9deb735e3f12df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f824e1a8ac055f30337c3570dfcb76/" rel="bookmark">
			Unity - 各向异性 - 丝绸材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的环境主观美术效果的[假]丝绸基于物理的方式参考 谷歌的 pbr filament 的文档（代码+文档）实验结果1 - blinn phong 修改 specular 为 anisotropy model实验结果2 - unity BRP standard (metallic flow) shader 修改 sepcular 为 anisotropy model第一步是 directly light 的 specular 高光部分第二步是 IBL 的 reflect 的 normal最终查看效果 实验结果3 - anisotropy model 微调 glossy、normal tilling实验结果4 - 增加 detail albedo, mix, normal 的功能 A站参考ProjectPBR filament web captureReferences 目的 拾遗，备份
环境 Unity : 2020.3.37f1
Pipeline : Builtin Rendering Pipeline
主观美术效果的[假]丝绸 非常简单 :
half specualr = pow(1 - NdotV, _Edge_Pow) * _Edge_Scale + pow(NdotV, _Enter_Pow) * _Center_Scale; specular *= _Tint; 这个效果不是物理的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f824e1a8ac055f30337c3570dfcb76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34614b8620bf4a62c33f915447a99835/" rel="bookmark">
			华为OD机试真题-抢7游戏-2023年OD统一考试（C卷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
A、B两个人玩抢7游戏，游戏规则为A先报一个起始数字X(10&lt;起始数字&lt;10000)，B报下一个数字Y(X-Y&lt;3),A再报一个数字Z(Y-Z&lt;3)，以此类推，直到其中一个抢到7，抢到7即为胜者；在B赢得比赛的情况下，一共有多少种组合？
输入描述：
起始数字M，如100；10&lt;=M&lt;=10000
输出描述：
B能赢得比赛的组合次数
补充说明：
示例1
输入：
10 输出：
1 说明：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80dab8b2e8c8cbc8c58ced0ce3b4f84d/" rel="bookmark">
			VScode 中 Python 代码不高亮显示怎么办？_vscode的python语法不高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在用 VScode 写代码的时候，发现 Python 代码不高亮显示：
这样用起来体验感不好，网上查询资料，可能存在的原因为：
安装Python扩展： 确保你已经安装了VS Code的Python扩展。如果没有安装，打开VS Code并在左侧的扩展面板中搜索"Python"，然后选择并安装由Microsoft提供的"Python"扩展。选择正确的语言模式： 确保在VS Code底部状态栏中的语言模式选择器中选择了正确的语言，即Python。点击语言模式选择器，然后选择Python。检查文件扩展名： 确保你的Python文件的扩展名是".py"，这有助于VS Code识别文件的语言类型。重启VS Code： 有时，VS Code可能需要重新启动才能正确加载语言扩展和高亮显示。检查VS Code设置： 确保你没有在VS Code的设置中禁用了代码高亮显示。你可以通过点击菜单中的"文件" &gt; “首选项” &gt; "设置"来访问设置界面，然后搜索"高亮显示"相关的设置。 Python拓展已经安装：
语言模式已经正确：
文件拓展名正确。
VScode的设置也没问题：
后来终于发现，是Python的Language Server出现了问题：
将其改为Pylance即可！
大功告成！
-END-
Python入门全套学习资料附带源码： Python全套学习路线 （以下所有资料文末免费领取）
Python安装包
链接：https://pan.baidu.com/s/1QfarmLxpa2zkrx7_9BuPhg?pwd=0wmw
提取码：0wmw
–来自百度网盘超级会员V5的分享
Python零基础入门视频 Python项目源码 Python入门到进阶电子书籍和实战案例 👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 上述这份完整版的Python全套学习资料已经上传CSDN官方，朋友们如果需要可以微信扫描下方CSDN官方认证二维码输入“领取资料” 即可领取
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb39f5f3721127ded10400144391b31c/" rel="bookmark">
			【腾讯云云上实验室】探索向量数据库背后的安全监控机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今数字化时代，数据安全成为了企业和个人最为关注的重要议题之一。随着数据规模的不断增长和数据应用的广泛普及，如何保护数据的安全性和隐私性成为了迫切的需求。
今天，我将带领大家一起探索腾讯云云上实验室所推出的向量数据库，这个强大的工具不仅能够有效地存储和处理大规模的向量数据，更有着卓越的安全监控机制，为用户提供了一道坚实的数据安全之盾。本文将深入剖析腾讯云向量数据库的安全监控机制，并从多个维度进行评估。 目录
一、初识腾讯云向量数据库
二、体验性过程测试与评估
三、个性体验与系统兼容性
四、数据可视化和数据安全
五、安全监控机制实操过程
六、个人总结及其未来展望
一、初识腾讯云向量数据库 腾讯云向量数据库(Tencent Cloud VectorDB)：是一款全托管的自研企业级分布式数据库服务，专用于存储、检索、分析多维向量数据。该数据库能够被广泛应用于大模型的训练、推理和知识库补充等场景。是国内首个从接入层、计算层到存储层提供全生命周期AI化的向量数据库。腾讯云向量数据库最高支持10亿级向量检索规模，延迟控制在毫秒级，相比传统单机插件式数据库检索规模提升10倍，同时具备百万级每秒查询的峰值能力。跳转链接：
数据存储与处理性能：在数据存储和处理性能这一方面，官方给我们介绍了在腾讯云向量数据库中在数据存储方面单索引支持10亿级向量数据规模，在处理性能方面可支持百万 QPS 及毫秒级查询延迟，腾讯集团自研的向量检索引擎 OLAMA，近40个业务线上稳定运行，日均处理搜索请求高达千亿次，可见其服务的连续性和稳定性之高。具体的使用优势可参考官方文档给出的具体详解：
向量特征相似度查询：向量数据库可以将用户的所有数据存储在向量数据库当中，当用户输入数据进行查询时，向量数据库会根据用户输入的数据进行计算向量之间的相似度，检索最相关的问题信息并返回对应的答案信息，所以向量数据库在大模型及其问答推荐系统领域方面，应用十分广泛：
安全监控机制：在腾讯云向量数据库的对安全的处理中，腾讯云处理的方式是将向量数据库运行于私有网络环境中。该私有网络是一块在腾讯云上自定义的逻辑隔离网络空间，基于隧道技术在物理网络上构造虚拟网络，使用虚拟化技术，实现不同私有网络之间内网完全隔离。俗称VPC：
专有网络是自己完全掌控的网络，例如选择 IP 地址范围、配置路由表和网关等，可以在自己定义的专有网络中使用腾讯云或阿里云资源，专有网络支持连接到其他专有网络，或本地网络，形成一个按需定制的网络环境，实现应用的平滑迁移上云和对数据中心的扩展，而专有网络VPC是基于阿里云构建的一个隔离的网络环境，专有网络之间逻辑上彻底分离：
VPC特点：
安全隔离：使用隧道技术达到传统VLAN相同隔离的效果；实现了不同云服务器间二层网络隔离；专有网络内的ECS使用安全组防火墙进行三层网络访问控制。
访问控制：灵活的访问控制规则，满足政务金融等安全隔离规范。
软件定义网络：按需配置网络设置，软件定义网络；管理操作实时生效等。
丰富的网络连接方式：支持软件VPN；支持专线连接
安全组介绍：
安全组是一种虚拟防火墙,用于控制安全组内ECS实例的入流量和出流量,从而提高ECS实例的安全性。安全组具备状态检测和数据包过滤能力,您可以基于安全组的特性和安全组规则的配置在云端划分安全域，在下文我们将详细介绍安全组的配置过程。
其他具体的安全防护手段也可以参考 官方文档 的讲解，这里不再过多的一一介绍，详情如下：
二、体验性过程测试与评估 1】注册与登录 访问腾讯云 官方链接，初次使用腾讯云的朋友需要注册并完成实名认证才可以继续使用。然后在导航栏的搜索框当中输入向量数据库关键字回车，选择第一个文档消息进行向量数据库的体验：
2】创建实例 进入向量数据库界面选择体验，然后在进入的后台中点击 新建 创建一个新的实例：
点击新建后进入新建向量数据实例页面进行相关配置即可：
配置数据库相应选择的参数可以参考官方文档给我们的详细解释：跳转链接 ：
3】管理实例 创建完向量数据库实例之后，在控制台可点击管理按钮查看向量数据的具体信息：
我们可以在管理实例中看到需要可视化的管理选型，可以根据自己的选择查看具体信息：
4】开启外网 单击实例 ID 进入实例详情页面，在网络信息区域，单击外网地址后面的开启。在开启外网访问的小窗口，在允许访问白名单的输入框，配置外网访问的白名单列表，如下：
5】登录数据库管理控制台 我们在上面的管理实例中找到密钥管理的选项，下面记载的名称和API密钥就是我们登录控制台的账户密码：
在控制台点击登录按钮进行到登录页面输入即可：
登录控制台之后，我们可以看到后台提供给我们需要的可视化选项，我们可以根据需求选择：
这里我们可以选择创建体验 Embedding，使用向量数据库提供给我们的基础数据简单的体验一下
6】删除实例 如果你想将创建的实例进行删除的话，方式很简单，只需要登录控制台点击更多在下拉框中点击销毁即可：
三、个性体验与系统兼容性 接下来简单的介绍一下关于腾讯云向量数据库是否支持用户根据需求进行配置和定制：
我们在创建向量数据库实例的时候可以根据需求定制一下基础的配置和规格信息：
在规格信息的具体实例类型方面，可以根据需要求进行更多规格的申请，而不单单只是一些基础的配置， 在填写申请表的阶段，可以详细描述一下自己所使用向量数据库的应用场景，这样的话可以腾讯云可以根据我们的需求推断出我们当前最适用的向量数据库：
在登录向量数据库后他之后，腾讯云针对向量数据库，推出数据库管理、开发工具，可帮您在线管理数据库、管理集合、快速查找更新数据等。后续腾讯云也将针对向量数据库持续推出更多的功能哦，我们期待未来它给我们更多的惊喜。
腾讯云向量数据库在主流操作系统（如Windows、Linux、MacOS等）和主流IDE（如Visual Studio Code、IntelliJ IDEA等）上都有良好的稳定性和兼容性。 它提供了多种客户端和SDK，可以方便地集成到各种开发环境和工具中。无论你使用哪种操作系统或IDE进行开发，都可以通过腾讯云向量数据库的客户端进行连接和操作。这里可以看到官方文档给我们相应的API文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb39f5f3721127ded10400144391b31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3d5e7140d848d20e25b50e7b84f66f/" rel="bookmark">
			macOS报错——Error: The maximum number of open files on this system has been reached
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 完整的报错信息：
Error: The maximum number of open files on this system has been reached. Use `ulimit -n` to increase this limit. 按照提示：
(base) ⇄ ↺ ✿ ♬  ~  ulimit -n 256 (base) ⇄ ↺ ✿ ♬  ~  ulimit -Sn 524288 (base) ⇄ ↺ ✿ ♬  ~  ulimit -Hn 10485760 (base) ⇄ ↺ ✿ ♬  ~  ulimit -n 524288 参考：
No Longer Able to Increase Maxfile Limits MacOS Recent Versions 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771cdb01fe11883001148cb92366ac9c/" rel="bookmark">
			OpenCV 单目测距实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要做一个小项目，要完成相机的测距实现，最先考虑的是三角激光测距，但是实现起来太麻烦了，基本要搭一个简易的激光测距雷达...然后是双目测距，然而一个便宜的双目工业相机也要四五百，而且以前也没接触过双目测距...
于是就想试试单目测距的效果怎么样，通过参考网络上的各种资料，加上以前玩过三角激光测距，所以也算比较顺利的写出来个简易实现单目测距的代码，精度还算差强人意。
原理大概是这样的 ：
这是三维情况下的小孔成像模型 ：
我们把它简化成更为直观的二维平面模型（渣画勿喷...）:
这里要说明下，这是一个典型的小孔成像模型，与单目相机的成像原理类似。
中间通过红蓝的垂线是相机的主光轴，d是被测物体至镜头的距离，f为相机镜头的焦距，w为被测物体的实际宽度（高度），w'为物体在成像平面（感光元件）上的宽度（高度）。 根据相似三角形公式可得：f / d = w' / w
由于f（相机镜头焦距）一般都是已知参数（买相机的时候总要选镜头焦距吧...），即使不清楚也可以通过计算得出，这里就不具体说了，w（实际物体宽或高）则是可以实际测得的常量。 重点说下怎么通过计算得出w'（物像宽或高）。举个栗子，假设你手上的相机是200w像素捕获画面尺寸为1920*1080，感光元件尺寸为1/2.7''，宽高分别为5.3mm和4mm（估值），被测物体在画面上的像素宽高都为600 pixel，那么w'(x) = (5.3 / 1920 * 600)(mm)，同样的，w'(y) = (4 / 1080 * 600)(mm)。关于感光元件尺寸和画面尺寸可以通过查看相机参数手册获得，而感光元件的宽和高可以通过其尺寸计算出来，这里直接扔张感光元件靶面尺寸表作为参考，图来源自网络：
这样，得知了 f，w，w' ，就可以根据上文提到的相似三角形公式计算得出d啦。
不过以上考虑的的是理想情况，前提是保证物像光线通过主光轴，相机是完全无畸变的，且被测物体平面要与相机成像平面保持平行状态。在这里我使用的相机是无畸变工业相机（低程度畸变，完全没畸变的相机是不存在的...），如果是较为廉价的相机或者是广角镜头相机都会存在较大程度的画面畸变，可以通过软件进行校正。准确来说这些情况都属于无法完全消除的偏差，只能通过后期软件来尽量减少这种偏差。
以上也就是为什么单目测距的精度要比双目测距差的多的原因，但是在所需测量精度不需要很精确的情况（偏差 &lt; 10% ~ 15%），以及成本受限的情况下，单目测距依然是首选方案，何况其实现起来也十分简单。
如果想了解更加复杂的情况和更详细的原理可以参考这篇文章：【机器视觉】 单目视觉测距_机器视觉测距-CSDN博客
以下是代码实现部分，使用 OpenCV 3.4.0
// 单目测距.cpp: 定义控制台应用程序的入口点。 // #include "stdafx.h" #include "opencv2/opencv.hpp" #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;vector&gt; // 单位像素宽/高(cm/pixel) #define UNIT_PIXEL_W 0.0008234375 #define UNIT_PIXEL_H 0.000825 using namespace std; int main(void) { cv::Mat frame; cv::VideoCapture capture(0); const double f = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771cdb01fe11883001148cb92366ac9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b8d674cc2a72859a7f9eb47204d3e8b/" rel="bookmark">
			程序员心中应该有点B树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一 . 基本搜索结构
二 . B-树的概念
三 . B-树的插入分析
四 . B树的插入实现
4.1 B-树的节点设计
五 . B-树的性能分析
六 . B+树和B*树
6.1 B+树
6.2 B*树
总结
前言 大家好,今天给大家介绍一下B树
一 . 基本搜索结构 种类数据格式时间复杂度顺序查找无要求二分查找有序二叉搜索树无要求二叉平衡树无要求-最后随机哈希无要求位图无要求布隆过滤器无要求 以上结构适合用于数据量不是很大的情况，如果数据量非常大，一次性无法加载到内存中，使用上述结构就不是很 方便。比如：使用平衡树搜索一个大文件
上面方法其实只在内存中保存了每一项数据信息中需要查找的字段以及数据在磁盘中的位置，整体的数据实际也在 磁盘中。
缺陷：
1. 树的高度比较高，查找时最差情况下要比较树的高度次
2. 数据量如果特别大时，树中的节点可能无法一次性加载到内存中，需要多次IO
注: 一般来说，内存的读写速度通常在几十GB/s的数量级，而传统机械硬盘的读写速度通常在几十MB/s到几百MB/s的数量级，因此磁盘I/O的速度通常比内存的速度慢几个数量级，可以达到1000倍以上的差距。这个差距在现代计算机系统中是非常显著的。当然，随着固态硬盘（SSD）等新技术的发展，磁盘的速度已经有所提高，但仍然远远落后于内存的速度。
那如何加速对数据的访问呢？
1. 提高IO的速度
2. 降低树的高度---多叉树平衡树(减少IO次数)
二 . B-树的概念 1970年，R.Bayer和E.mccreight提出了一种适合外查找的树，它是一种平衡的多叉树，称为B树(有些地方写的是B树，注意不要误读成"B减树")。一棵M阶(M&gt;2)的B树，是一棵平衡的M路平衡搜索树，可以是空树或者满足一下性 质：
1. 根节点至少有两个孩子
2. 每个非根节点至少有M/2-1(上取整)个关键字,至多有M-1个关键字，并且以升序排列
例如：当M=3的时候，至少有3/2=1.5，向上取整等于2，2-1=1个关键字，最多是2个关键字
3. 每个非根节点至少有M/2(上取整)个孩子,至多有M个孩子
例如：当M=3的时候，至少有3/2=1.5，向上取整等于2个孩子。最多有3个孩子。
4. key[i]和key[i+1]之间的孩子节点的值介于key[i]、key[i+1]之间 5. 所有的叶子节点都在同一层
三 . B-树的插入分析 为了简单起见，假设M = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b8d674cc2a72859a7f9eb47204d3e8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024a1d133347bfbc901ec4e5f2beb023/" rel="bookmark">
			【探讨】bp神经网络是前馈还是后馈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、BP神经网络简介
1.1 什么是BP神经网络
1.2 BP神经网络的结构
二、BP神经网络的前馈与后馈
2.1 什么是BP神经网络的前馈
2.2 什么是BP神经网络的后馈
三、BP神经网络前馈与后馈的关系
3.1 BP神经网络前馈与后馈的区别
3.2 BP神经网络前馈与后馈的意义
四、BP神经网络前馈与后馈-实例
本文部分图文代码借鉴《老饼讲解-BP神经网络》
一、BP神经网络简介 1.1 什么是BP神经网络 BP神经网络也称为误差反向传播神经网络，是1986年由Rumelhart和McClelland为首的科学家提出的概念，是一种按照误差逆向传播算法训练的多层前馈神经网络，是应用最广泛的神经网络模型之一。
BP算法的基本思想是通过将输入样本输入网络中，然后将网络的输出与目标输出进行比较，计算误差，并将误差进行反向传播，以更新网络的权重。反向传播过程中，误差被分配给前一层的神经元，以及与神经元之间的连接权重，然后根据误差大小调整权重值。这个过程不断重复，直到网络的输出与目标输出接近。
BP神经网络具有任意复杂的模式分类能力和优良的多维函数映射能力，解决了简单感知器不能解决的异或和一些其他问题。BP算法的优点是可以对复杂的非线性问题进行建模，并且可以通过调整网络结构和参数来改进模型的性能。但它也存在一些问题，比如容易陷入局部最小值，并且计算量较大。
总的来说，BP算法是人工神经网络中最常用的训练算法之一，可以用来解决各种问题，包括分类、回归和模式识别等。
1.2 BP神经网络的结构 BP神经网络由输入层、隐藏层和输出层组成，其中隐藏层可以包含多个神经元。它的训练过程可以分为前向传播和误差反向传播两个阶段。在前向传播阶段，输入数据经过权重和偏置的变换后，经过激活函数处理后传递到下一层，最终产生输出。在误差反向传播阶段，根据实际输出与目标输出的误差计算损失函数，并通过反向传播算法计算各层的误差，再利用梯度下降算法调整各层之间的权重和偏置，以使损失函数最小化。
二、BP神经网络的前馈与后馈 2.1 什么是BP神经网络的前馈 BP神经网络的前馈是指信息从网络的输入层传递到输出层的过程。在前馈过程中，每个神经元将它的输入与相应的权重进行加权求和，并通过激活函数进行非线性变换处理，然后将结果传递给下一层的神经元，直到信息传递到输出层。
具体步骤如下：
1. 输入层接收外部的输入数据，并将数据传递到下一层隐藏层的神经元。
2. 隐藏层的神经元将输入与相应的权重进行加权求和，并通过激活函数进行非线性变换处理，然后将结果传递到下一层隐藏层的神经元。
3. 重复步骤2，直到信息传递到输出层的神经元。
4. 输出层的神经元将输入与相应的权重进行加权求和，并通过激活函数进行非线性变换处理，得到网络的输出结果。
在前馈过程中，每个神经元的输入值和输出值都会经过计算和传递，直到达到输出层产生最终的输出结果。这个过程是单向的，信息只能从输入层向输出层传递，没有反向传递。
总的来说，计算BP神经网络的输出时，BP神经网络是以前馈的方式计算得出网络的输出值，前馈往往指的就是BP神经网络计算输出的过程或方式。
2.2 什么是BP神经网络的后馈 BP，全称为"Backpropagation"，翻译为中文就是”向后传播“，也就是通常所说的”后馈“，那么，后馈指的是什么呢？这就涉及到BP神经网络的训练算法。通常训练BP神经网络使用的是梯度下降等等之类的算法，由于BP神经网络的特殊结果，这类型的训练算法在训练权重阈值时是以反向传播误差的方式来更新神经网络的权重，以使网络能够逼近目标输出。
在BP神经网络中，首先使用随机初始化的权重参数进行前向传播，将输入样本通过网络的多层连接传递，经过激活函数的处理，得到输出结果。然后，将输出结果与标签进行比较，得到误差。接下来，将误差从输出层开始，按照权重的反向方向，通过链式法则将误差逐层传递回隐藏层和输入层。在传递过程中，根据误差值和梯度下降算法，更新连接权重和偏置，使得网络的输出逼近于目标输出。这个过程不断迭代，直到网络的输出与目标输出的误差达到预设的阈值或训练轮次达到预设的次数。
通过后馈过程，BP神经网络可以利用误差信号来调整网络参数，使网络能够自我学习和适应输入输出关系，从而提供更准确的预测和分类能力
三、BP神经网络前馈与后馈的关系 3.1 BP神经网络前馈与后馈的区别 BP神经网络的前馈与后馈的区别如下：
1.阶段不同：BP神经网络的前馈发生在网络输出的计算阶段，而BP神经网络的后馈过程发生在训练的阶段。
2.计算对象不同：BP神经网络的前馈计算的是BP神经网络神经元的值，而BP神经网络的后馈计算的是BP神经网络参数的梯度。
3.影响不同：BP神经网络的前馈影响的是网络的准确性，BP神经网络的后馈影响的是网络的训练。
3.2 BP神经网络前馈与后馈的意义 BP神经网络既有前馈，也有后馈，也即网络是前馈的，但训练是后馈的。
1.BP神经网络的前馈与后馈的意义
BP神经网络的前馈与后馈都给网络带来了极大的好处，它使得网络的计算和训练都不受层数的影响，只是类似套娃式一直向前或向后传播就可以。
2.BP神经网络训练中的前馈与后馈
比较需要注意的是，由于BP神经网络的梯度计算同时也依赖于神经元的值，所以往往在反馈之前 ，需要先前馈算出所有神经元的值，再进行后馈计算梯度，并更新权重阈值。
四、BP神经网络前馈与后馈-实例 在matlab中训练一个BP神经网络
x1 = [-3,-2.7,-2.4,-2.1,-1.8,-1.5,-1.2,-0.9,-0.6,-0.3,0,0.3,0.6,0.9,1.2,1.5,1.8]; % x1：x1 = -3:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024a1d133347bfbc901ec4e5f2beb023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358ef2b019a6281f18ae376814f16df1/" rel="bookmark">
			毕业设计-基于深度学习的交通标志检测与识别系统 YOLO 卷积神经网络 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计思路
一、课题背景与意义
二、算法理论原理
2.1 卷积神经网络
2.1 YOLOv5算法
三、交通标志检测的实现
3.1 数据集
3.2 实验环境搭建
3.2 实验及结果分析
实现效果图样例
最后
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是海浪学长毕设专题,本次分享的课题是
🎯基于深度学习的交通标志检测与识别算法
设计思路 一、课题背景与意义 近几年经济社会的不断发展，人们物质水平得到显著提高，相应的私人汽车数量迅速扩增，在方便人们出行、提升城市化发展的同时，也给道路交通状况产生了不小的压力，包括着由于城市化快速发展造成的交通堵塞问题及道路安全问题。为了解决这些道路交通安全问题，智能交通系统应运而生，交通系统的智能化是当前发展的主流，发展更加智能化的道路交通系统在很大程度上可以缓解道路交通压力，减少交通事故的发生。
二、算法理论原理 2.1 卷积神经网络 卷积神经网络是一个深度学习框架，可直接将识别图像作为输入，不像传统算法那样复杂，这种网络结构更不会受到一些常见变形的干扰。大体来说，卷积网络核心部分为局部感受野、权值共享、汇聚。卷积神经网络基本结构为卷积层、汇聚层、全连接层。其整体结构如图2-1所示。由图可知，卷积神经网络包含N个连续卷积块和K个全连接层，而每个卷积块又包含连续的M个卷积层和b个汇聚层。
Faster R-CNN，直接利用RPN（Region Proposal Network）网络计算候选框。在性能方面，不仅会获得更快的收敛速度，更会通过RPN和CNN联合训练提升整体效果。Faster R-CNN摒弃了选择性搜索的方法，新引入RPN区域候选网络，将提名、分类、回归处理共用卷积特征，对网络进一步加速。
为了在提高检测准确率的同时，达到较好的实时性，出现了基于端到端的目标检测方法，这些方法避免了区域提名过程的高计算复杂度。基于端到端的方法包括SSD和YOLO。SSD网络分前后两部分，前半部分是完成图像的分类任务；后半部分是完成图像检测任务多尺度特征映射层，SSD同时将不同尺度特征进行映射，检测不同大小的物体。
YOLO提出一个新方法：通过输出层进行回归候选框来完成分类任务。说的简单一些，其实就是只浏览一次目标，然后把目标判定和识别任务合为一种任务，在识别速度上可达到每秒45帧，明显提升识别速度。对于一幅图片，YOLO的处理是首先把输入图片归一化为一定大小，然后输入到卷积网络中，最后对模型置信度设定阈值得到目标的位置和具体类别。
2.1 YOLOv5算法 通道注意力机制在特征提取时可以增强小目标的有效特征，抑制无关特征，因此将通道注意力机制引入到YOLOv5网络的Backbone部分。其中，F为残差学习，目的是在引入注意力机制的同时并不会使得网络退化。该网络在进行特征提取时，采用引入的通道注意力机制重新对特征在通道维度上标示，加强有效特征，抑制无关特征的干扰，在新得到的注意力特征上实现对交通标志的检测。因此，通道注意力机制是YOLOv5网络特征提取部分的核心。
通道注意力模块中的全连接网络结构：首先分别对特征IF全局平均池化、全局最大池化，然后将得到的特征进行拼接，最后经三个全连接层得到最终的输出特征。
根据交通标志检测场景存在小目标样本以及含有大量无关信息干扰的特点，对SENet通道注意力机制进行改进，保留了有利于检测任务的有效信息，抑制了无关信息对检测结果的干扰。
对Backbone部分进行改进，引入多个GhostBottleneck网络结构替换之前的BottleneckCSP结构，并引入SENet通道注意力机制。
直接用EfficientNet来进行交通标志数据集的细分类，分类准确率尚不够好，还有提升的空间。在这一部分中，在EfficientNet网络中每次下采样之前引入CBAM注意力机制，提升网络对于交通标志重要特征图的注意力。使用CBAM模型旨在对所使用的交通标志图像数据集提取最有效的特征图，从而进一步提高细分类准确率。
在这一部分中，通过在预训练网络中每次下采样之前加入CBAM注意力机制，来提升网络对交通标志某些特征和空间的注意力，以此更好的提升对交通标志分类的准确率。引入CBAM之后的网络结构如图4-5所示。
三、交通标志检测的实现 3.1 数据集 对于提出的基于改进后的YOLOv5的交通标志检测与分类算法，实验采用公开的交通标志检测数据集。数据集共有900幅不同场景下的交通标志图像，每幅图中的交通标志在0到6个不等。图片均为RGB三通道图片，道路交通标志分为禁止、警告、指示、其它四大类别，包含43小类。交通标志图片分辨率为1360x800，其中每张图像包含的交通标志的分辨率则从16x16到128x128不等。
3.2 实验环境搭建 实验中用到的方法都是基于深度学习框架Pytorch。训练和测试步骤在CPU为Intel Core i7-9750H，GPU为NVIDIA GTX 2080Ti的环境上运行，运行软件为Pycharm，加速环境为CUDA10.0和cuDNN7.3。实验相关超参数设置如表3-2所示。
3.2 实验及结果分析 改进前后YOLOv5的损失函数：改进前的YOLOv5网络在迭代次数为140时，损失值出现明显的断崖式下降，极不稳定，而改进后的YOLOv5网络在中间出现明显的迭代次数在0-50左右时，损失值急剧下降，随着迭代次数持续增加，损失值下降速率开始减缓，迭代次数到200左右时趋于平缓，而且后续损失值都在0.01左右，达到了理想的效果。
引入了改进的通道注意力机制，首先对注意力中不同特征压缩方法进行对比，将四种特征压缩方法分别引入到YOLOv5中，保证四种方法采用同样的训练和测试方法，在德国GTSDB数据集上进行实验对比，实验结果如表3-3所示。
通道注意力的特征压缩方法中，单一的全局最大池化稍微优于单一的全局平均池化，对特征全局最大池化(MaxPool)和全局平均池化(AvgPool)的通道直接相加稍微好于单一的特征维度压缩方法，而对特征拼接检测效果是最优的，证明所修改的通道注意力特征压缩方法是有效的，所以在通道注意力中选择对全局最大池化和全局平均池化拼接的方法进行交通标志的检测。
为了对比改进后的YOLOv5网络与其他主流端到端的目标检测方法在街景交通标志图像上的检测性能，分别计算模型预测结果在GTSDB数据集上的Precision和Recall值，以Precision为纵坐标，Recall为横坐标，绘制出P-R曲线如下所示。
改进后的YOLOv5级联改进后的EfficientNet组成。其算法步骤如下所示。
将改进后的YOLOv5与改进后的EfficientNet级联后的网络与单一的YOLOv5网络识别精确率对比来说，在识别精确率方面提升了4%，有了明显的提升。虽然在识别每帧图像时间方面要差于单一YOLOv5网络，但仍优于Faster R-CNN以及SSD网络，满足较好的实时性和精确率要求。
部分代码如下：
traffic_signs = ['stop', 'yield', 'speed_limit', 'no_entry', 'pedestrian_crossing'] def detect_traffic_signs(image_path): # 打开图像 image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358ef2b019a6281f18ae376814f16df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf02f8e3e734df9c3cddb70d42d8c323/" rel="bookmark">
			项目经理的年终总结没写好，一年全白干
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又到年底了，办公室的项目经理们好不容易能聚在一起，大家在交流工作时，对这一年的工作状态简要吐槽了几句。每一句都堪称经典，但无不透露出各种心酸。
项目经理小王：感情状态——继续单身，根本没空谈恋爱；身材体重——过劳肥。
项目经理小刘：每天日常就是上班+加班，上班时间取决于前一天加班到几点，没有下班这一说。
项目经理老李：周末安排：加班；加班原因：开会；攒钱是为了植发。
项目经理老赵：以上我都感同身受！但最委屈的还不是这些，而是去年我天天加班交付了8个项目，由于没空写年终总结，所以寥寥几笔带过，结果领导认为我工作还不够努力。而隔壁老王项目做的没我多，但他提前一个月就开始准备年终总结，堪比毕业论文，然后领导认为老王工作做的很不错，考虑今年多涨点薪…
那么问题来了，一份能加薪升职的年终总结到底应该怎么写？
本期文章主要结合了行业内各位大佬的经验，围绕年终总结的内容展开，以供大家参考，争取今年的年终总结成为明年升职加薪的敲门砖。
1.年终总结思路梳理 对于项目经理来说，工作汇报可谓是家常便饭，各种项目汇报充斥着整个项目管理全过程，但汇报的对象不同，准备的内容和角度自然也不同。
所以年终总结的思路可以通过思考以下几个问题来梳理：
汇报的对象是谁？
他们的关注点是哪些？
汇报的目的是什么？
汇报的内容有哪些？
如果能做到目标明确、思路清晰以及准备充分这几点，则可以称为一次成功的年终总结。那么具体应该包含哪些内容呢？
2.项目经理岗位年终总结具体包含哪些内容？ 对于项目经理来说，年终总结不仅是一个自我总结和反思的途径，还能充分展示一年以来工作的业绩和价值，让领导知道你做了哪些工作，并且觉得你做的还不错，同时也能帮助你解决工作中遇到的一些难题。
项目经理岗位年终总结汇报的对象，通常是自己部门的直属领导，领导层更加关注的是：
完成了哪些项目；
各个项目的完成情况以及结果；
是否达成了既定的目标；
所遇到的问题和分析；
以及未来的工作规划这几点。
那么总结来说，年终总结主要可以包含工作业绩、问题总结以及未来计划这三个方面的内容。
2.1第一部分：工作业绩 年终总结的第一部分，主要是总结一整年的工作业绩；可以采用结论先行的方式，开篇做一个工作概况。例如：
今年承接了多少个项目；
截止目前，成功交付并顺利回款的项目有多少个；
延伸出来的价值有…（例如，客户介绍新客户、客户满意度高、第二年续签等等）。
接下来的内容就是上述工作概况的展开分享，但内容不能像流水账一样，要主次分明，集中在重点工作，常规工作简明扼要列举出来。重点工作可包括：
实现公司战略目标的项目；
自己主导、全权负责的项目；
领导关心的项目和工作等。
详细的情况也可以从业绩是否达标、工作进展程度以及核心价值来展开。注意：工作的业绩尽量用数据展现，更加直观。
2.2第二部分：问题总结 工作中遇到的一系列难题就可以在第二部分展现，主要是总结项目中以及日常工作中所遇到的问题和分析原因。阐述的思路可参考：“在什么情况下，做了什么事，产生了什么结果，解决了什么问题等。”具体可以从这三方面展开：
在遇到这个问题时，是怎么解决的？
在这个问题的处理上，有哪些不足可以改进的？哪些教训是需要注意的？
有哪些经验是以后可以持续复用的？如何能做的更好？
2.3第三部分：未来计划 第三部分就是来年的工作目标和计划，主要包括：可落地的目标，需要获取的资源支持，详细且全面的计划（任务分解，完成时间节点等），也可从三个维度来展开：
制定工作目标并量化，目标要符合SMART原则；
明确需要哪些资源和支持；
自我能力提升的规划。
在年度总结的初稿完成后，一定要预留时间进行修改和完善，尤其是工作业绩部分，要针对一些重大项目将业绩的亮点充分提炼出来。
在这个过程中，对于繁忙的项目管理人来说，数据的梳理是最大的难点之一。例如：手里负责的项目多，数据繁多，还有很多项目交付的比较早，一些项目的情况都不太清楚了，整理起来工作量巨大。那么这种情况下，如果借助专业的项目管理软件开展项目，项目数据的整理是如何做的呢？
3.借助项目管理工具，年终总结数据收集更加高效 3.1全年项目汇总—我的项目 一整年下来，项目经理负责或参与的项目可能很多，难免会有一些项目信息有所遗忘。如果是借助项目管理软件进行项目管理，在【我的项目】中就可以查询到所负责/参与的所有的项目，一目了然掌握项目当前的状态、进度、完成的时间、当前所处阶段以及在项目中所担任的角色。
点击项目名称，即可快速跳转至项目详细管理页面，在这个模块，项目经理就可以轻松梳理出自己所负责/参与的所有项目。
（易趋-我的项目视图）
除了以上项目相关的数据，项目经理还可以在【我的任务】模块，查看其他常规工作的详细数据。一些部门日常事宜，例如采购、招投标的工作等，项目经理都会填报工时，提交给领导审批。
（易趋—我的任务视图）
3.2项目产生的业绩—项目概况 对于项目产生的业绩，一些具体的数据可能还需要其他部门支持提供，但是借助项目管理软件后，项目经理可以清晰具体的自主查看项目的成本收益情况。
在【项目概况】视图，除了能查看项目的基础信息（项目进度、交付物完成情况、项目里程碑等），还能查看项目的成本跟踪数据、成本预算执行情况以及项目收益情况等等，系统还会根据数据自动生成饼状图、折线图，便于项目经理快速制作年终总结文档时使用。
（易趋—项目概况视图）
除了在【项目概况】模块查看数据，项目经理还能在商业论证—成本预算计划以及收益预算计划这两个地方查看更为详细的数据，具体哪个阶段的收益未达标一目了然。
（易趋—项目收益预算视图）
3.3项目的问题及风险全面无遗漏—项目工作项（问题/风险） 第二部分的问题总结分析，则能在项目工作项—【风险】以及【问题】查看，系统支持数据导出，项目经理使用起来更加便捷。
在这两个模块，能查到项目全面的情况，如问题模块，包含了问题的优先级、类别、类型以及解决方案。项目所有的问题都记录在系统，不会有遗漏的情况出现。
（易趋-项目问题视图）
借助项目管理软件能使项目经理的年终总结内容更加准确、全面；所有的项目运营数据，都能快速查看、支持导出，能更加高效产出年度总结报告。
4.总结 年终总结报告写的好，来年升职加薪才有望，项目经理无论再忙都要重视这项工作，最好能提前半个月准备。一个全面的年终总结报告可以分为三个部分：工作业绩、问题总结以及未来规划；年度总结的难点在于各项数据的收集耗时耗力，如果借助专业的项目管理软件则能有效解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b5e87b81f14dd5eb2c6587f47a640a/" rel="bookmark">
			倾斜三维模型生成DOM、DSM（附下载软件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、准备数据 倾斜三维模型数据
2、加载瓦片 打开Dasviewer软件
3、按范围选择瓦片 如果数据太大需要对数据进行部分选择，可以用这个步骤
左键双击结束
导出选择瓦片，会生成新的瓦片文件夹
4、导出DOM、DSM 根据需求设置参数
结果
软件下载地址
https://www.daspatial.com/cn/download
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e67a43938b5d01c608ef6ac3be1361b2/" rel="bookmark">
			Gradio使用教程-检测分割界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from ultralytics import YOLO from PIL import Image import cv2 import gradio as gr model_seg = YOLO('/home/user-f381/Python_Project/pytorch_project/ultralytics/runs/segment/train/weights/best.pt') # 加载自定义模型 model_detect = YOLO('/home/user-f381/Python_Project/pytorch_project/ultralytics/runs/detect/train/weights/best.pt') def seg(image): results = model_seg([image]) # 返回 Results 对象列表 for r in results: im_array = r.plot() # 绘制包含预测结果的BGR numpy数组 im = Image.fromarray(im_array[..., ::-1]) # RGB PIL图像 # im.show() # 显示图像 # im.save('results_seg.jpg') # 保存图像 return im def det(image): results = model_detect([image]) # 返回 Results 对象列表 for r in results: im_array = r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e67a43938b5d01c608ef6ac3be1361b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b7d3fcdb5bb6284ded4990099ddf8a/" rel="bookmark">
			LIO-SAM的安装与运行 --ubuntu18.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1安装ROS相关依赖
sudo apt-get install -y ros-melodic-navigation sudo apt-get install -y ros-melodic-robot-localization sudo apt-get install -y ros-melodic-robot-state-publisher LIO-SAM采用因子图优化库gtsam,安装gtsam:
wget -O ~/Downloads/gtsam.zip https://ghproxy.com/https://github.com/borglab/gtsam/archive/4.0.2.zip cd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/ cd ~/Downloads/gtsam-4.0.2/ mkdir build &amp;&amp; cd build cmake -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF .. sudo make install -j8 直接wget github地址来下载gtsam会很慢，加代理网址https://ghproxy.com/，能够显著加速下载。gtsam的版本为4.0.2，安装其他版本可能会导致LIO_SAM运行报错
2安装LIO-SAM
cd ~/catkin_ws/src git clone https://ghproxy.com/https://github.com/TixiaoShan/LIO-SAM.git cd .. catkin_make 3运行LIO-SAM
roslaunch lio-sam run.launch
LIO-SAM源码做点修改才能跑，幸好有人做过了，用的这个项目：https://github.com/nkymzsy/LIO-SAM-MID360.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61c88fc7b1cd4bfd4c83c76715fc4fb/" rel="bookmark">
			推荐 5 个令人惊艳的 GitHub 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期推荐开源项目目录：
1. 机器人工具
2. 图片高分辨率
3. PowerToys
4. AI 编程助手
5. Airtable 开源替代品
01 机器人工具
CopilotKit 是一个为开发者提供应用内聊天机器人和 AI 智能文本区域的开源项目。该项目包括两个主要功能：
CopilotPortal: 在应用中构建 AI 聊天机器人，它可以“看到”当前的应用状态并在应用内执行操作。可与应用的前端和后端交互，也可以通过插件与第三方英语哦那个进行交互。这是用户的AI“第二大脑”。
CopilotTextarea: 提供AI辅助文本生成，是 &lt;textarea /&gt; 的替代品。它提供上下文感知的自动补全、 AI 编辑和从头开始生成文本等功能。目前支持 React，可以使用任何 LLM（语言模型）。
开源地址：https://github.com/CopilotKit/CopilotKit/blob/main/README.md
02 图片高分辨率
该开源项目基于论文《DemoFusion: Democratising High-Resolution Image Generation With No Money》，它的愿景是让更多人群能够轻松使用高分辨率图像生成技术。
提供了多种演示和使用方式，使用户能够快速上手并体验该技术。DemoFusion框架采用了渐进放大、跳跃残差和扩散采样机制，以实现更高分辨率的图像生成。
开源地址：https://github.com/PRIS-CV/DemoFusion
03 PowerToys
PowerToys 是微软开源的一组针对电脑高级用户的实用工具集，旨在调整和简化 Windows 使用体验，提高工作效率。
PowerToys 提供了各种功能，包括窗口置顶、文字提取工具、文件批量重命名、取色器、跨电脑鼠标控制、文件操作等等，以提高用户的生产力。该项目的功能包括但不限于：
开源地址：https://github.com/microsoft/PowerToys
04 AI 编程助手
Tabby 是一个 AI 编程助手，称 GitHub Copilot 的替代版。它易于与现有基础设施集成（如云 IDE）。支持消费级 GPU。
该项目提供了详细的文档，包括安装、IDE/编辑器扩展和配置等方面的指南。您可以通过 Docker 命令轻松启动 Tabby 服务器，并且还提供了构建和贡献代码的说明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61c88fc7b1cd4bfd4c83c76715fc4fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433cc512ce8686b3601249a6b26b1552/" rel="bookmark">
			Spark分布式内存计算框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Spark简介
（一）定义
（二）Spark和MapReduce区别
（三）Spark历史
（四）Spark特点
二、Spark生态系统
三、Spark运行架构
（一）基本概念
（二）架构设计
（三）Spark运行基本流程
四、Spark编程模型
（一）核心数据结构RDD
（二）RDD上的操作
（三）RDD的特性
（四）RDD 的持久化
（五）RDD之间的依赖关系 （六）RDD计算工作流 五、Spark的部署方式
一、Spark简介 （一）定义 Spark是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark是一个大数据并行计算框架，是对广泛使用的MapReduce计算模型的扩展。
（二）Spark和MapReduce区别 Spark有着自己的生态系统，但同时兼容HDFS、Hive等分布式存储系统，可以完美融入Hadoop的生态圈中，代替MapReduce去执行更高的分布式计算。两者区别如图所示，基于MapReduce的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而Spark则是将中间结果尽量保存在内存中以减少底层存储系统的I/O，以提高计算速度。
Spark，拥有Hadoop MapReduce所具有的优点；但不同于MapReduce的是——Job中间输出结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。
Spark是一种与 Hadoop 相似的开源集群计算环境，但是两者之间还存在一些不同之处，这些有用的不同之处使 Spark 在某些工作负载方面表现得更加优越，换句话说，Spark 启用了内存分布数据集，除了能够提供交互式查询外，它还可以优化迭代工作负载。
Spark 是在 Scala 语言中实现的，它将 Scala 用作其应用程序框架。与 Hadoop 不同，Spark 和 Scala 能够紧密集成，其中的 Scala 可以像操作本地集合对象一样轻松地操作分布式数据集。尽管创建 Spark 是为了支持分布式数据集上的迭代作业，但是实际上它是对 Hadoop 的补充，可以在 Hadoop 文件系统中并行运行。通过名为 Mesos 的第三方集群框架可以支持此行为。
（三）Spark历史 Spark最初由美国加州大学伯克利分校（UC Berkeley）的AMP实验室于2009年开发，项目采用Scala编写。是基于内存计算的大数据并行计算框架，可用于构建大型的、低延迟的数据分析应用程序。
2010年开源。
2013年6月成为Apache孵化项目。2013年Spark加入Apache孵化器项目后发展迅猛，如今已成为Apache软件基金会最重要的三大分布式计算系统开源项目之一（Hadoop、Spark、Storm）。
2014年2月成为Apache顶级项目。Spark在2014年打破了Hadoop保持的基准排序纪录：Spark/206个节点/23分钟/100TB数据； Hadoop/2000个节点/72分钟/100TB数据；Spark用十分之一的计算资源，获得了比Hadoop快3倍的速度。
（四）Spark特点 1、运行速度快：与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。计算的中间结果是存在于内存中的。
2、易用：Spark支持Java、Python、Scala和R等多种语言的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的Shell，可以非常方便地在这些Shell中使用Spark集群来验证解决问题的方法。
3、通用性：Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。减少了开发和维护的人力成本和部署平台的物力成本。
4、兼容性：Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/433cc512ce8686b3601249a6b26b1552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb5a5a8ccd8c99985faf4241342e1ee/" rel="bookmark">
			ADB安装及使用详解（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ADB简介 1、什么是adb ADB 全称为 Android Debug Bridge，起到调试桥的作用，是一个客户端-服务器端程序。其中客户端是用来操作的电脑，服务端是 Android 设备。
ADB 也是 Android SDK 中的一个工具，可以直接操作管理 Android 模拟器或者真实的 Android 设备。
2、为什么要用adb 运行设备的 shell(命令行)
管理模拟器或设备的端口映射
计算机和设备之间上传/下载文件
可以对设备的应用进行卸载安装等
在 App 遇到 ANR/Crash 等 bug 时，可以通过 ADB 来抓取日志
简而言之，ADB 就是连接 Android 手机与 PC 端的桥梁，所以ADB又称为安卓调试桥（注意：是安卓，不是iOS），可以让用户在电脑上对手机进行全面的操作！
二、准备工具 单独安装adb，不安装sdk
1、下载adb Google很好心，直接放出ADB的zip供人下载。路径如下：
Windows版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Mac版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Linux版本：https://dl.google.com/android/repository/platform-tools-latest-linux.zip
2、配置环境变量 解压安装后，把解压路径放到系统变量里去（Path），
环境变量如何配置，比如我的配置如下图：
3、连接 可以通过模拟器连接，也可以通过数据线连接。
通过数据线连接时，手机进入“开发者选项”，打开“usb调试”。
不同品牌安卓机型，首次打开“开发者选项”方式不一样，大多是双击手机版本号3~5次，会toast提醒“开发者模式已打开”，具体打开方式可根据手机品牌进行百度查询
4、电脑打开cmd窗口 输入 adb version ：显示 adb 版本，说明安装成功
三、ADB命令详解 1、基本命令 adb version ：显示 adb 版本
adb help：帮助信息，查看adb所支持的所有命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb5a5a8ccd8c99985faf4241342e1ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42da194d0cb69d43fac4d1a6d299d80b/" rel="bookmark">
			RT-Thread Studio使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 RT-Thread Studio是官方出品的一款专门针对RT-Thread嵌入式开发、部署、调试、测试的集成开发环境，它基于Eclipse开源项目开发，极大的提高了嵌入式开发者的开发效率，目前最新版本是2.26
下载 使用浏览器打开RT-Thread官网，选择左上角资源点击RT-Thread Studio，打开RT-Thread Studio页面，点击立即下载
在弹出的下载页面，选择点击网站下载
安装 打开下载的软件包RT-Thread Studio-v2.2.6-setup-x86_64_202305191040.exe，点击下一步(N)
点击我同意此协议(A)，然后点击下一步(N)
点击浏览(R)...选择安装路径，然后点击下一步(N)
创建开始菜单和快捷方式，这里默认就可以，点击下一步(N)
点击安装，安装需要一定的时间
点击完成(F)，打开RT-Thread Studio
输入用户名和密码登录RT-Thread Studio，然后点击登录，没有账户的话请点击会员注册
登录成功后显示RT-Thread Studio的主界面
创建工程 以英飞凌的开发板PSoc 62使用调试为例，PSoc 62是RT-Thread和英飞凌合作开发推出的一块demo板
点击左上角菜单栏文件(F) -&gt; 新建(N) -&gt; RT-Thread 项目
在新建项目页面，点击基于开发板，在开发板处下拉框选择添加更多...
在弹出的RT-Thread SDK管理器页面，下拉找到Board_Support_Packages，再找到Infineon，选中PSOC62-IFX-EVAL-KIT
检查ToolChain_Support_Packages，这里IDE已经默认安装了5.4.1的Tool Chain
在Debugger_Support_Packages下找到OpenOCD-Infineon并勾选，然后点击安装2资源包
安装完成后，点击退出SDK管理器
再次新建项目，发现开发板处多了PSOC62-IFX-EVAL-KIT，此次确认以下信息，然后点击完成(F)
工程创建成功，界面如下，常用的几个功能区域如图所示，示例代码是一个循环点灯程序
调试 点击左上角build图标构建工程
调试部署，进入调试界面
设置串口打开terminal查看运行日志
terminal成功打开界面
通过命令查看系统工作状况
RT-Thread Studio常用的快捷键
功能按键继续F5中止Ctrl + F2单步跳入F11单步跳过F10单步返回F7下载程序Ctrl + Alt + D 至此，RT-Thread Studio安装和使用示范就完结了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de61e5d0a8c29f1913b43d403cd99880/" rel="bookmark">
			往adobe illustrator中添加latex字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到如下字体所在路径 /path/to/miktex/type1\public\amsfonts\cm 然后copy相应的字体文件
cmmi10.pfb 将相应的pfb文件复制到Adobe illustrator字体文件夹:
/path/to/illustrator/Support Files/Required/Fonts 然后重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83056be71ee934add455686a2b04f13/" rel="bookmark">
			【力扣100】238.除自身以外数组的乘积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加链接描述
class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: # 构造第i个数的左右数组 n = len(nums) left,right,res = [1]*n,[1]*n,[1]*n for i in range(1,n): left[i] = nums[i-1]*left[i-1] for i in range(n-2,-1,-1): right[i] = nums[i+1]*right[i+1] for i in range(n): res[i] = left[i]*right[i] return res 思路：
左边一个“前缀和”，右边一个“前缀和”然后相乘这个数组下标直接把我搞晕了老铁 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546724f100a956b1adb5cfaabf0c2794/" rel="bookmark">
			RabbitMQ反序列化未经授权的类异常解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置好生产者消费者后，消费者项目启动后出现如下异常：
Caused by: java.lang.SecurityException: Attempt to deserialize unauthorized
这是反序列化未经授权的类，解决办法是设置信任所有消息发起者，可以将环境变量：
SPRING_AMQP_DESERIALIZATION_TRUST_ALL
或者系统属性：
spring.amqp.deserialization.trust.all 设置为true。
但是注意这里并不是springboot项目的yml配置设置，而是应该设置环境变量。按照以下步骤操作即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4e9e1d135783007efedfc7bf116420/" rel="bookmark">
			LeetCode 1631. 最小体力消耗路径：广度优先搜索BFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】1631.最小体力消耗路径：广度优先搜索BFS 力扣题目链接：https://leetcode.cn/problems/path-with-minimum-effort/
你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。
一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。
请你返回从左上角走到右下角的最小 体力消耗值 。
示例 1：
输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2：
输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3：
输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] 输出：0 解释：上图所示路径不需要消耗任何体力。 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe4e9e1d135783007efedfc7bf116420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f6b2c095de0f7938040517a5bc1912/" rel="bookmark">
			数据结构和算法-图的基本概念及邻接矩阵法和邻接表法和十字链表法和链表链表法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 图的概念总览图的定义图逻辑结构的应用无向图和有向图简单图和多重图顶点的度，入读，出度顶点-顶点的关系描述连通图，强连通图研究图的局部-子图无向图有向图 连通分量强连通分量生成树生成森林边的权，带权图/网几种特殊形态的图小结 邻接矩阵总览邻接矩阵求顶点的度，入度，出度邻接矩阵存储带权图性能分析邻接矩阵法的性质 小结 邻接表顺序+链式存储对比 树的孩子表示法有向图vs无向图求顶点的度，入度，出度表示方式不唯一小结 十字链表总览前提问题十字链表存储有向图性能分析邻接矩阵，邻接表存储无向图的缺点邻接多重表存储无向图小结 图的概念 总览 图的定义 顶点不能为空，边可以为空，且边对于两端必须要有顶点
图逻辑结构的应用 无向图和有向图 简单图和多重图 顶点的度，入读，出度 无向图中一条边对应两个节点产生两个度
有向图中一条边对应两个节点，一个节点产生入读，另一个节点产生出度
顶点-顶点的关系描述 连通（无向图中）：两个顶点有路径存在
强连通（有向图中）：两个顶点有来回路径
连通图，强连通图 对于n个顶点的无向图G
若要为连通图，则保证n个顶点连成一条线即可，那么有n-1条边
若要为非连通图，则将一个顶点隔离，将剩余的节点的边连满，相当于是计算从n-1个顶点中选两个顶点的种类数有多少，此时连满后再增加任意条边，只能是隔离的那个顶点连接到剩余的节点上，此时将连通，所以不行。所以只需计算将剩余的节点的边连满的边数
对于n个顶点的有向图
若要为强连通图，则最少有n条边（即形成回路，此时任意一个顶点沿回路方向出发都能到达任何一个顶点）
研究图的局部-子图 无向图和有向图对于子图相关的概念差不多
子图也是一个图，所以也要符合图的要求
无向图 有向图 连通分量 强连通分量 生成树 生成森林 边的权，带权图/网 几种特殊形态的图 有向树不是强连通的
小结 邻接矩阵 总览 邻接矩阵 就是横坐标和纵坐标都为点的图，相连为1，不相连为0
领结的意思就是是否相邻连接
求顶点的度，入度，出度 无向图对应左边，有向图对应右边
邻接矩阵存储带权图 性能分析 邻接矩阵法的性质 小结 邻接表 顺序+链式存储 用一维数组存图，每个顶点有对应边的指针相关信息
对比 树的孩子表示法 有向图vs无向图 同一条边无向图需要存储两次，而有向图只需存储一次，所以空间复杂度有所不同
求顶点的度，入度，出度 无向图的度：只需遍历该节点对应的边链表
有向图的出度：只需遍历该节点对应的边链表
有向图的入度：需要遍历该节点之外的所有节点的边链表（麻烦）
有向图的度：即入度+出度
表示方式不唯一 即点的边链表不唯一
但图的邻接矩阵唯一
小结 十字链表 总览 前提问题 邻接矩阵存储空间复杂度高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7f6b2c095de0f7938040517a5bc1912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f90d2021d953562a5ab9a0fcf9bf366/" rel="bookmark">
			网络安全习题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全试题 1. 密码学与加密 描述对称加密和非对称加密的区别。什么是哈希函数？举例说明其在网络安全中的应用。解释公钥基础设施（PKI）的作用和组成部分。 2. 网络协议安全性 解释SSL/TLS协议的作用和工作原理。什么是DDoS攻击？如何防范这类攻击？解释DNS劫持，并提供几种防御方法。 3. 网络攻击与防御 描述SQL注入攻击，并提供防范措施。什么是恶意软件？列举几种不同类型的恶意软件。解释零日漏洞的概念，并讨论对策。 4. 网络漏洞扫描和渗透测试 说明渗透测试的目的和步骤。什么是OWASP Top Ten？列举其中的几个安全风险。 5. 防火墙和入侵检测系统 描述防火墙的工作原理及其在网络安全中的角色。什么是入侵检测系统（IDS）？它们如何工作？ 6. 安全策略和风险管理 说明安全策略的重要性，并提供实施安全策略的几个步骤。什么是风险评估？为什么它对网络安全至关重要？ 7. 社会工程和安全意识培训 解释社会工程攻击，并提供预防方法。为什么安全意识培训对组织的整体安全性至关重要？ 8. 法规和合规性要求 描述GDPR的目的和主要原则。解释PCI DSS标准是如何保护支付卡数据的。 答案： 1. 密码学与加密 对称加密和非对称加密的区别：
对称加密： 同一密钥用于加密和解密信息。非对称加密： 使用一对密钥，公钥用于加密，私钥用于解密。 哈希函数和应用：
哈希函数： 将输入数据转换为固定长度的哈希值。应用： 存储密码的哈希，数字签名，数据完整性验证。 公钥基础设施（PKI）：
作用： 提供安全的密钥管理和数字证书颁发。组成部分： 数字证书、证书颁发机构（CA）、注册机构（RA）等。 2. 网络协议安全性 SSL/TLS协议：
作用： 加密通信，确保数据传输的安全性。工作原理： 握手、密钥交换、数据传输阶段。 DDoS攻击防范：
防范方法： 使用CDN、流量过滤、负载均衡等技术。 DNS劫持：
描述： 恶意修改DNS解析结果。防御： 使用DNSSEC，定期检查DNS设置。 3. 网络攻击与防御 SQL注入攻击：
描述： 攻击者通过恶意SQL代码注入数据库查询。防范措施： 使用参数化查询，输入验证，最小权限原则。 恶意软件：
类型： 病毒、蠕虫、木马、勒索软件等。防御： 定期更新防病毒软件，教育用户防范社会工程攻击。 零日漏洞：
概念： 未被软件供应商修补的安全漏洞。对策： 及时更新软件、使用网络防火墙、监测异常流量。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f90d2021d953562a5ab9a0fcf9bf366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6f3dfbd64abc33f00a28b8e05ff69b/" rel="bookmark">
			【力扣100】56.合并区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加链接描述
class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: # 队列，每次加进来两个元素：1.不包含：第一个元素出去，并放入result；2.包含：合并 n=len(intervals) result=[] que=collections.deque() if n==0: return [[]] if n==1: return [intervals[0]] # 初始化 intervals=sorted(intervals,key=lambda x:x[0]) for i in intervals: if len(que)&lt;2: que.append(i) if len(que)==2: start=max(que[0][0],que[1][0]) end=min(que[0][1],que[1][1]) left_border=min(que[0][0],que[1][0]) right_border=max(que[0][1],que[1][1]) if start&lt;=end: que.append([left_border,right_border]) que.popleft() que.popleft() else: result.append(que.popleft()) while que: result.append(que.popleft()) return result 思路：
不存在的条件这道题目其实找的是所有区间里的交集，那么这些区间的在数组中的先后顺序其实就无所谓先用每一个一位数组的第一个值排序，目的是找到最开始的起点sorted(array,key=lambda x:x[0])然后就是如何判断两个区间有交集？ interval1 = [3, 7] interval2 = [5, 10] # 获取交集的起始点和结束点 start = max(interval1[0], interval2[0]) end = min(interval1[1], interval2[1]) # 检查是否存在交集 if start &lt;= end: intersection = [start, end] print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6f3dfbd64abc33f00a28b8e05ff69b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6ace9c2a4799ee68db8f46d66ee5a6/" rel="bookmark">
			解决vue3 动态引入报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前这样写的，能使用，但是有警告
警告，查了下，是动态引入的问题，看到说要用glob
然后再我的基础上，稍微 改了下，就可以了：
最后打印了下，modules['../../components/flowchart/edge/dbedgeview/dbedgeview.vue']
和我那个defineAsyncComponent里面直接import也一样啊，真的是，非要加个glob
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf007180d91e1c19bc5cd55f3e7bf788/" rel="bookmark">
			php think run 和springBoot的main启动的顺序，有什么相同与不同的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相同的地方： 虽然 PHP（特别是 PHP 语言本身）和 Java（Spring Boot 是基于 Java 的）是两种不同的编程语言，但在应用程序的启动过程中，有一些通用的概念和步骤。以下是 PHP ThinkPHP 框架的 php think run 命令和 Spring Boot 的 main 方法启动过程的一些相似之处：
加载配置：
PHP ThinkPHP：加载应用程序的配置，包括数据库配置、路由配置等。Spring Boot：加载应用程序的配置，可以是 application.properties、application.yml 等。 初始化上下文：
PHP ThinkPHP：创建和初始化应用程序上下文，包括加载框架的配置和组件。Spring Boot：创建和初始化 Spring 应用程序上下文，包括加载应用程序的配置和管理 bean。 执行启动命令：
PHP ThinkPHP：执行 php think run 命令，触发应用程序的启动。Spring Boot：执行 main 方法中的 SpringApplication.run()，触发应用程序的启动。 自动配置：
PHP ThinkPHP：ThinkPHP 框架使用约定大于配置的原则，通过自动加载类和配置文件，自动配置应用程序。Spring Boot：Spring Boot 通过自动配置来简化应用程序的配置，基于类路径下的依赖和项目中的配置。 启动嵌入式的服务器（可选）：
PHP ThinkPHP：如果应用程序是一个 Web 应用，ThinkPHP 会启动 PHP 内置的 Web 服务器。Spring Boot：如果应用程序是一个 Web 应用，Spring Boot 会根据配置自动配置和启动嵌入式的 Web 服务器（如 Tomcat）。 执行应用程序逻辑：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf007180d91e1c19bc5cd55f3e7bf788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ec6b44dd172cb83d70e9b6f7f03556/" rel="bookmark">
			IAR嵌入式解决方案发布全新版本，增强云调试和仿真功能，推动下一代嵌入式软件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过先进的Arm虚拟硬件集成和Linux系统中增强的基于云的协作，赋能下一代嵌入式软件开发
瑞典乌普萨拉，2023年12月7日 - 嵌入式开发软件和服务的全球领导者IAR宣布推出旗舰产品IAR Embedded Workbench for Arm及IAR Build Tools for Arm最新9.50版本。此次更新在嵌入式软件开发领域实现了显著进展，引入了一系列增强功能，例如在Linux上进行先进的云调试和仿真。这次更新还包括Arm虚拟硬件（AVH）的集成和针对Linux的增强的IAR C-SPY调试器和模拟器，进一步彰显了我们为满足嵌入式系统行业不断演进的需求而致力于提供高效解决方案的承诺。
新版本的特色功能：
Arm虚拟硬件（AVH）支持：引入AVH以在云端模拟各种基于Arm的硬件。这允许在实际硬件可用之前进行早期软件开发，并与CI/CD和MLOps工作流无缝集成，极大加速上市时间。针对Linux的增强的IAR C-SPY调试器和模拟器：为Linux提供了先进的调试器和模拟器，支持自动化工作流程和IAR I-jet硬件调试。这些增强功能优化了CI/CD流水线中的测试流程，提高了效率并减少了时间消耗。Linux的运行时分析插件集成：将IAR C-SPY和IAR C-RUN插件整合到Linux环境中，通过先进的分析和测试功能提升了开发和测试效率，提高了代码质量和可靠性。基于云的开发和协作：便于整合到云原生和协作环境中，支持远程团队合作，并利用云基础设施进行仿真和虚拟化。这符合现代软件开发趋势。 Arm嵌入式高级总监Reinhard Keil表示：“Arm致力于确保开发者能够简洁、顺畅地获取创新所需的工具。在IAR最新版本中集成Arm虚拟硬件，可助力加速开发流程，支持现代化工作流程，如基于测试的开发与持续集成，这些都会对嵌入式开发者产生深远影响。”
新版本为嵌入式系统开发者提供了重要的优势，包括：
模拟和虚拟化工具：提供了增强的工具，用于模拟和虚拟化各种环境和条件，对于测试和验证嵌入式软件至关重要。这确保了在各种场景下的稳健性和功能性。协作和基于云的开发：与远程工作的趋势一致，该版本实现了灵活高效的开发流程。它支持无论位置在何处的团队协作，并利用云计算进行开发和测试。 IAR首席技术官Anders Holmberg表示：“随着基于云的软件开发的发展，AVH支持和针对Linux的IAR C-SPY调试器和模拟器对于CI/CD尤为重要，特别是考虑到不断增长的嵌入式设备范围。通过将DevOps与云和嵌入式开发相结合，我们可赋能开发人员提高效率和加速市场推出的能力。”
新版本的功能巩固了IAR提供满足软件开发者不断变化需求的先进解决方案的承诺，并将显著提升嵌入式开发人员的效率和灵活性。有关IAR Embedded Workbench for Arm的更多详细信息，以及支持的超过8800款Arm芯片，请访问IAR Embedded Workbench for Arm 9.40 | IAR。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98904a5bc598cd674fefa40765106c0/" rel="bookmark">
			自动驾驶右向辅助功能规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 Contents
目录
1. 介绍 Introduction. 8
1.1 此文档的范围和目的 Scope and Purpose of This Document 8
1.2 参考文档References. 9
1.3 文档的维护 Maintenance of the Document 10
1.4 缩略词Abbreviations. 10
1.5 文档概述Document Overview.. 11
1.6 功能区域Function Area. 12
1.7 成熟度Maturity. 12
2. Function Area &lt;右向辅助功能&gt;.. 13
2.1 右向行驶行为触发Drive Right To Trigger 15
2.1.1 功能场景... 15
2.1.2 功能逻辑... 16
2.1.3 功能框图... 17
2.1.4 功能映射... 18
2.1.5 功能接口... 19
2.1.6 故障诊断... 19
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c98904a5bc598cd674fefa40765106c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75eccd73eea3c56fb3d7b904a959bacf/" rel="bookmark">
			Win 11 使用H3C Cloud Lab无法启动交换机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win 11 使用H3C Cloud Lab无法启动交换机 问题描述解决方案 问题描述 win11安装H3C Cloud Lab软件，无法正常启动添加的交换机设备。
项值电脑版本Win11软件版本V5.10.0问题无法启动交换机 解决方案 [1]网上方法：Win+R，输入optionalfeatures，在弹窗内取消勾选Hyper-V组件。
效果：重启电脑后仍然无法正常启动；
[2]找到VirualBox.exe和H3C Cloud Lab.exe，右键属性修改兼容性为Windows 7，点击应用，Win+R，输入optionalfeatures，在弹窗中找到Windows虚拟机监控程序平台和虚拟机平台两项，均取消勾选。
效果：重启电脑后可以启动交换机设备。
注：已确认和软件的兼容性无关，主要还是关闭[2]中的两个虚拟机的组件。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/33/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>