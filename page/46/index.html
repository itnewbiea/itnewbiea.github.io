<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eec8ff71aa4ae2126c740d4637537a7/" rel="bookmark">
			VS2022 无法打开源文件“stdio.h”问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 相信大家在下载完VS2022后，编写C语言程序时可能会出现下面问题：
这个问题就是因为你下载是SDK出了问题。
操作步骤： 1、首先，点击Windows的开始菜单，在所有应用里选择Visual Studio Installer
2、打开Visual Studio 安装程序界面，点击右侧的修改
3、打开修改页面，右侧选择展开通用Windows平台开发，在右方可选栏里勾选Windows 10SDK，点击右下角修改
注意：当你的Windows系统是11时一定要下载Windows 11SDK，不然还是会报错，如果W10SDK还是有问题那就都下载一遍，就可以了
4、安装完成后，点击启动。
进入软件后就可以正常运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b08b709b9bfed20cd706898c10281f/" rel="bookmark">
			深度学习标注工具（包括自动标注）总结——持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首次记录日期2023年10月24日
名称
导出格式支持形状地址1 anylabeling 支持yolov5和v8，自动标注的软件
沿物体轮廓分割
https://github.com/vietanhdev/anylabeling
2 RectLabel 使用Core ML模型自动标记图像
对象、属性、热键和快速标签的设置。
以PASCAL VOC XML格式读写，导出到YOLO、KITTI、COCOJSON与CSV
绘制边界框、多边形、三次bezier、直线和点
使用骨架绘制关键点
使用笔刷和超级像素工具标记像素
https://rectlabel.com/
3 LableBox Labelbox还提供了API接口，可以与其他自然语言处理工具和机器学习平台无缝集成。导出Json。Labelbox提供了许多先进的功能，如自动标注、质量控制、标注审核等，可以大大提高标注效率和标注结果的准确度。
支持图像标注和文本标注，可以进行分类、边界框、实体、关系等多种标注类型，支持对象检测框、实例分割数据标注。
https://github.com/Labelbox/Labelbox
4 PixelAnnotationTool 快捷，半自动化，类似PS蒙版，基于OpenCV中分水岭算法实现（不足：标注对象若颜色分布不均匀，软件无法识别；如果识别出来，大概率覆盖掉周围物体，很难修改）
图像语义分割与实例分割标注神器
https://github.com/abreheret/PixelAnnotationTool
5 LabelImg VOC，tfrecord（批注以PASCAL VOC格式存储为XML文件）
矩形
https://github.com/tzutalin/labelImg
6 Labelme JSON、VOC与COCO
矩形、圆形、线段、点（多边形分割、语义分割、2D框、线标注、点标注（可用于目标检测，图像分割等任务）视频标注）
https://github.com/wkentaro/labelme
7 OpenCV/CVAT CVAT for video、CVAT for images、PASCAL VOC、(VOC) Segmentation mask、YOLO、COCO、TFRecord、MOT、LabelMe 3.0、Datumaro
支持图像分类、对象检测框、图像语义分割、实例分割数据标注在线标注工具，它能够对图像、视频做矩形、关键点、图像分割、目标追踪、3D等标注（多边形分割、语义分割、2D框、线标注、点标注，3D点云，视频标注）
https://github.com/opencv/cvat
8 VOTT 导出CNTK/Pascal VOC，TFRecord、CSV、VoTT格式
（支持点、线、2D框、语义分割与视频数据标注）支持图像与视频数据标注
https://github.com/microsoft/VoTT
9 VIA-VGG Image Annotator CSV、JSON
能标注矩形、圆、椭圆、多边形、点和折线标注，VGG 有一个亮点，根据标签 ID 可以自定义不同的标签名称，在遇到复杂难懂的标签名称时，我们也能轻松搞定，支持对象检测、图像语义分割与实例分割数据标注，人脸数据标注首选工具
http://www.robots.ox.ac.uk/~vgg/software/via/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b08b709b9bfed20cd706898c10281f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5930a09e4b11bf1df22f08bb092e89/" rel="bookmark">
			EPPlus库的安装和使用 C# 中 Excel的导入和导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 工具栏-&gt;NuGet 包管理器-&gt;管理解决方案的NuGet程序包
安装到当前项目中
使用 将 DataGridView 数据导出为Excel 首先，需要将数据DataGridView对象转换为DataTable private void btnExport_Click(object sender, EventArgs e) { // 1.将当前页面的dataGridView获取并且转换为datatable对象用于转换数据 DataTable dt = new DataTable(); // 创建一个新的DataTable，并添加列 for (int i = 0; i &lt; dvgame.ColumnCount; i++) { dt.Columns.Add(dvgame.Columns[i].HeaderText); } // 添加行数据 for (int i = 0; i &lt; dvgame.RowCount; i++) { DataRow dr = dt.NewRow(); for (int j = 0; j &lt; dvgame.ColumnCount; j++) { dr[j] = dvgame.Rows[i].Cells[j].Value.ToString(); } dt.Rows.Add(dr); } // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5930a09e4b11bf1df22f08bb092e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175bfe3ecbe11bb7849d2ca9f2b972cf/" rel="bookmark">
			Linux系统编程学习 NO.8 ——make和Makefile、进度条程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天是1024程序员节，不知不觉离第一次写博客已经过去了一年了。在此祝各位程序员不写bug，不再秃头。
make和Makefile 什么是make和Makefile？ make和Makefile是软件开发时所用到的工具和文件。make是一个指令工具。Makefile是一个当前目录下的文件。make和Makefile可以提高我们在Linux下的开发效率。
简单演示 下面用一份c代码来进行演示。
在当前目录下新建一个Makefile文件，并写上相应的依赖关系与依赖方法。
接着使用一下make指令。
依赖关系和依赖方法的解释 这里使用一个生活中的例子来解释依赖关系和依赖方法。现在已经是10月23日了，月底来了，相信不少同学的钱包也已经见底了。这是该怎么办呢？当然是打电话给你的老爸要生活费。找老爸要生活费这一行为也需要对应的依赖关系和依赖方法。你打一个电话过去说，“爹啊，月底了我没钱了，你给我的xx上转1500元当做生活费。”。此时，这你打电话给你爹，首先声明的是依赖关系，要到生活费的前提必须是他是你爹。毕竟你总不能打电话给你舍友的爹要生活费吧。那么往你手机上转账的行为就是对应的依赖方法。你要生活费总不能只给你爹说，“爹啊！”。你只声明依赖关系却没有依赖方法，你的老爹也不会给你转账的。
make会自动推导Makefile的依赖关系 下面我写一个稍微复杂一点的场景来演示make自动推导Makefile的依赖关系。
上面的依赖关系的代码顺序可以随意交换，但是依赖关系的逻辑关系不能缺失，否则make无法自动推导依赖关系。
make的默认动作 make将文件的第一个依赖方法和依赖方法设置成为make指令的默认动作。
.PHONY 为什么make了之后不能接着make呢？
这是因为操作系统为了提高编译效率而是实现的机制。由于你的源文件的生成时间是大于可执行性程序的生成时间的。此时make就不会编译你的源文件。如果你修改了源文件，此时你的源文件的生成时间是小于你的可执行程序的。故make会生成新的可执行程序。
那么它是如何实现按的呢？这里需要引出一个概念即，一个文件的时间属性。一个文件的时间属性分为三种， Access时间(最近被访问时间)、Modify时间（修改时间）、Change时间（改变时间）。 几乎你对文件的任何操作都会修该Access时间。在介绍Modify时间和Change时间前，在这里再次提及一个概念。文件本质等于文件的内容加文件的属性。这里的Modify时间显示的是最近一次文件内容被修改的时间。而Change时间则表示最近一次文件属性被修改的时间。这里介绍一个指令stat，用于查看文件状态。
stat 文件名 为什么最近访问时间没有变呢？其实早期的linux系统的最近访问时间实惠随着你的操作而实时更新的。后来由于处于对性能的优化，最近访问时间不会随着访问而修改。因为文件是存储在磁盘上的，而磁盘属于外部设备。它的访问效率是比较低的，为了进一步优化性能所以最近访问时间默认情况下不会随着被访问而修改。那么我想要让他修改呢？那就是用touch命令。
只要修改源文件的最近修改时间，make就就可以通过依赖关系来进行在次编译。
所以make的对于是否可以再次编译的条件是源文件的最近修改时间小于可执行程序的最近修改时间。
如果我希望每次编译都执行呢?需要在Makefile文件中加入.PHONY来修饰,使它总是被执行。
但是这种写法并不好，因为有时候我们的一些编译问题还是需要我们手动清理后再编译才能解决的。这里建议.PHONY来修饰clean。
特殊符号 由于每次都要手写gcc命令比较麻烦，可以尝试使用特殊符号来代替对应的可执行程序和源文件。
这里的$@可以替换成的是:左边的内容， $^ 可以替换成:右边的内容。
在对应的方法前加上@符号可以不回显指令的内容。
进度条程序 经过了一段时间的Linux操作系统的学习，下面就带着大家用一个简单进度条程序来练练手吧。
前言 回车和换行的概念 这里需要提前知道一个概念，即回车和换行的概念。c语言中的’\n’就可以同时实现回车和换行的操作，但是它还有别的功能，且听为等会讲述。换行大家一定不会陌生，就是从一行跳转到下一行，c语言中，\n表示换行+回车（注：c语言没有单独换行的转义字符）。回车表示将光标移动到文档的开头，在c语言中，\r表示回车。
这里我举一个生活中的例子，在19/20世纪的欧洲，一些上层阶级往往会有当时比较潮流的科技设备，打字机。
在打字机上编写文字时，纸张是不断向上走的。这其实就是一个换行。每写一行文字，就需要手动将印章挪到每行的开头，这其实就是回车。
缓冲区的概念 下面我直接用代码举例
sleep函数是一个系统调用接口。当执行这个函数时，会休眠n秒。那么上面的代码输出结果是什么呢？答案是会先在显示器上打印hello linux，随后下一行休眠了一秒钟又输出了bash命令行。
如果不带上\n呢？结果会是什么呢？答案是当程序执行时，第一秒钟休眠了，随后在下一行中hello linux于bash同时输出在了一行。
这究竟是为什么呢？我相信在大家初步c语言学习的时候，一定听过一个概念就是c语言三大结构之一的顺序结构。代码是从main函数自上而下依次被执行的。那为什么是先休眠后输出呢？因为在sleep期间，程序的数据被暂时保存起来了。保存它的地方就是缓冲区。在这里进需要记住一个简单的概念，即缓冲区是一段被c语言所维护的内存空间。
下面介绍如何强制刷新缓冲区，使我们对应的printf语句先被执行。c程序默认会为用户打开三个输入输出流，标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。这里介绍一个函数fflush()，它接受一个文件流stream，会强制刷新这个流，使得缓冲区内的数据立刻被写到文件中（补充：Linux下一切皆文件，也包括显示器）。
实现一个进度条程序 10秒倒计时小程序 简单写一个10秒倒计时程序来为进度条程序做一个铺垫。
这里我就简单说一下程序的实现思路，当程序在屏幕上输出数字时，我们需要让它立刻被刷新出来并写入显示器文件。随后休眠一秒后，又会在显示上一个数字的位置，用上一个数字-1的值将它覆盖。因为使用了\r回车转义字符。这里的%-2d其实是输出格式控制。
进度条程序简易版 这里实现采取定义与生命分离的方式进行。这里创建三个文件，分别用于声明方法和实现方法以及测试方法。
先简单配置一下Makefile文件。
这里的：右边有两个.c文件，不过$^还是会默认带上这两个.c文件。.PHONY修饰clean表示该指令总是被执行。
第二步，在头文件中包含相关头文件以及声明函数方法。
第三步，实现进度条程序。定义一个字符串数组存储进度条的输出样式，为了让精度条执行时，有一个相应的动画效果。开辟一个数组来存储进度条的内容样式，通过循环来控制进度条在屏幕上的显示。每次回车打印完内容后将进度条的添加进度条内容，搭配上usleep就能达到控制进度条的速度。
进阶版进度条 下面以模拟下载软件时的场景，带大家看一个关于回调函数版本进度条的实现。
首先，我们对原来的processbar.c进行一个修改。
使用回调函数的设计思路将进度条模块独立成回调函数，当下载时，download函数内部控制具体的进度条逻辑。主函数中只需要传一个回调函数就能使进度条跑起来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae44406eb3d7f8d593bdd4e75884459/" rel="bookmark">
			Java实现连接SQL Server解决方案及代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面展示了连接SQL Server数据库的整个流程：
加载数据库驱动建立数据库连接执行SQL语句处理结果关闭连接 在连接之前，前提是确保数据库成功的下载，创建，配置好账号密码。
运行成功的代码：
import java.sql.*; public class sqlserverConnection { //驱动 private static String cxDriver = "com.microsoft.sqlserver.jdbc.SQLServerDriver"; //连接地址 private static String cxUrl = "jdbc:sqlserver://172.16.100.1:1433;databaseName=abc;encrypt=false"; //用户名 private static String cxUser = "abc"; //用户密码:数据库的密码 private static String cxPassword = "abc"; public static void main(String[] args) { try{ Class.forName(cxDriver); //加载sqlserver的驱动类 System.out.println("加载SQLServer驱动类成功!"); } catch(ClassNotFoundException a){ System.out.println("加载SQLServer驱动失败!"); a.printStackTrace(); } Connection dbcon=null; //处理与特定数据库的连接 try{ dbcon=DriverManager.getConnection(cxUrl,cxUser,cxPassword); System.out.println("数据库连接成功!"); dbcon.close(); } catch(SQLException e){ System.out.println("数据库连接失败!"); e.printStackTrace(); } } } 报错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae44406eb3d7f8d593bdd4e75884459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743baf1148392344262fcc1e9367e4ce/" rel="bookmark">
			进阶JAVA篇-深入了解 Stream 流对象的创建与中间方法、终结方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.0 Stream 流的说明
2.0 Stream 流对象的创建
2.1 对于 Collection 系列集合创建 Stream 流对象的方式
2.2 对于 Map 系列集合创建 Stream 流对象的方式
2.3 对于数组创建 Stream 流对象的方式
3.0 Stream 流的中间方法
3.1 Stream 流的 filter() 中间方法
3.2 Stream 流的 sorted() 中间方法
3.3 Stream 流的 limit(x) 中间方法
3.4 Stream 流的 skip(x) 中间方法
3.5 Stream 流的 map() 中间方法
3.6 Stream 流的 distinct() 中间方法
3.7 Stream 流的 concat() 中间方法
4.0 Stream 流的终结方法
4.1 Stream 流的 forEach 终结方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/743baf1148392344262fcc1e9367e4ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a70861b0b351e1ba7ca55fab860f5d/" rel="bookmark">
			C# winform 系统中获取接口api信息的HttpClient和HttpWebResponse方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用HttpClient 访问接口 //post请求-- auth为Basic Auth private void getdata() { string BUKRS = "1000"; string WERKS = ""; DateTime MON = DateTime.Now; string ZDEPA = ""; string ZREPTYPE = "1"; string url = "http://xxxxxx"; string username = "xxxxx"; string password = "xxxxxxx"; // 将用户名和密码组合成 Basic Authentication 的凭据 string credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($"{username}:{password}")); string[] DAPA = new string[] { "DB01", "DB02" }; foreach (string item in DAPA) { ZDEPA = item; for (int i = 1; i &lt; 20; i++) { string ZMON = MON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a70861b0b351e1ba7ca55fab860f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd0b84b04c3cb851dc273542771c6ac/" rel="bookmark">
			Spring初步了解到深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Spring1.1简介1.2优点1.3组成1.4拓展 2.IOC理论推导3.Hello Spring下面牵扯到的地址: 4.IOC创建对象的方式1.使用无参构造创建对象，默认2.假设我们要使用有参构造创建对象1.下标赋值2.类型3.参数名 5.Spring配置5.1别名5.2bean的配置5.3import 6.依赖注入6.1构造器注入6.2Set方式注入\[重点]6.3拓展方式注入list这些p命名**其实C命名空间就对应构造器注入，p命名空间就对应Set方式注入**userbeans.xml(使用)User.java(包装)MyTest.java(测试) 6.4 bean的作用域1.单例模式(Spring默认机制)2.原型模式3.其余的request,session,application,这个只能在web开发中使用到 7.Bean的自动装配7.1测试7.2ByName自动装配7.3ByType自动装配7.4 使用注解实现自动装配重要：&lt;context:annotation-config/&gt;**@AutoWired**@Qualifier@Resource小结： 8.使用注解开发1.bean2.属性如何注入3.衍生的注解 9.使用Java的方式配置Spring10、代理模式10.1 静态代理10.2加深理解10.3动态代理Interface InvocationHandlerClass Proxy反射ServiceImplTestProxyInvocationHandler 11.AOP使用AOP需要导入的依赖11.3使用Spring实现扫描AOP方式一：使用API接口【主要是SpringAPI接口的实现】UserServiceImpl提供信息Log日志当执行前出入AfterLog日志 在执行后AOP负责连接最后的测试类 方式二：使用自定义类【主要是切面定义】自定义了一个Java文件 方式三：使用注解开发AOP新建一个类使用注解xml导入bean 12.整合MyBatis12.1回忆Mybatis 1.Spring 1.1简介 Spring—&gt;给软件行业带来了春天Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架2002，首次推出了Spring框架的雏形Spring框架以interface21框架为基础,经过重新设计，并不断丰富内涵，与2004年发布1.0正式版SSH：Struct2+Spring+HibernateSSM: SpringMVC + Spring + Mybatis官网:https://spring.io/projects/spring-framework下载地址：https://repo.spring.io/release/org/springframework/spring/GitHub地址：https://github.com/spring-projects/spring-boot &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2优点 Spring是一个开源的免费的框架Spring是一个轻量级的非入侵式的框架控制反转(IOC),面向切面编程(AOP)支持事务的处理，对框架整合的支持 总结：Spring是一个轻量级的控制反转(IOC)和面向切面编程(AOP)的框架
1.3组成 1.4拓展 Spring Boot
快速开发的脚手架基于SpringBoot可以快速开发单个的微服务约定大于配置 Spring Cloud
SpringCloud是基于SpringBoot实现的 弊端：发展了太久之后，违背了原来的理念，配置十分繁琐
2.IOC理论推导 1.UserDao接口2.UserDaoImpl实现类3.UserService业务接口4.UserServiceImpl业务实现类 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求修改源代码！如果程序代码量非常大，修改一次的代价十分昂贵！
我们使用Set接口实现对接口的切换
private UserDao userDao ; //利用set动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } //然后在MyTest中 ((UserSeriviceImpl) userService).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd0b84b04c3cb851dc273542771c6ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e3088f20fa1d59aaa1adcf302ed983/" rel="bookmark">
			vue实现三级省市区三级联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.效果 2.VUE 代码 &lt;template&gt; &lt;div class="app-container"&gt; &lt;el-cascader v-model="value" :options="options" @change="handleChange" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {options} from "@/utils/city"; export default { name: "test", data() { return { value: [], options: options, }; }, methods: { handleChange(value) { console.log(value); } } }; &lt;/script&gt; 3.JS 文件 city.js export const options = [{ children: [{ children: [{ value: "360101", label: "市辖区" }, { value: "360102", label: "东湖区" }, { value: "360103", label: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e3088f20fa1d59aaa1adcf302ed983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366606f06b5d482dcecb9b45911c6dfd/" rel="bookmark">
			CentOS6.6图文安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打开虚拟机，点击“创建新的虚拟机”； 2．进入“新建虚拟机向导”，默认“典型”配置，点击“下一步”； 3.进入“安装客户机操作系统”，选择“稍后安装操作系统”，点击“下一步”； 4.进入“选择客户机操作系统”，在“客户机操作系统”里选择“Linux(L)”,然后在“版本”项选择“CentOS 6 64位”，点击“下一步”； 5.进入“命名虚拟机”，在“虚拟机名称（V）”输入自己喜欢的名称，然后点击“浏览”，在“位置（L）”处选择安装位置，也可以全部默认选择，点击“下一步”； 6.进入“指定磁盘容量”，最大磁盘大小可以调整，选择“将虚拟磁盘拆分成多个文件（M）”，点击“下一步”； 7.进入“已准备好创建虚拟机”，点击“自定义硬件（C）”进行设置； 8.进入“硬件”设置项，设置完成后，点击“关闭”； 9.点击“完成”； 10.进入以下界面，点击“开启此虚拟机”进行安装，进入“Welcome to CentOS 6.6!”； 11.进入虚拟机，方向键选择“Install or upgrade an existing system” 12.进入“Disc Found”，选择“Skip”; 13.进入如下界面，点击“Next”； 14.进入语言选择界面，选择“中文（简体）”，然后点击“Next”； 15.进入“键盘”界面，选择“美国英语式”，点击“下一步”； 16.进入“安装设备”界面，选择“基本存储设备”，点击“下一步”； 17.弹出“存储设备警告”，选择“是，忽略所有数据”，然后点击“下一步”； 18.进入如下界面，命名“主机名”； 19.进入时区界面，把“系统时钟使用UTC时间”前面的勾选去掉，点击“下一步”； 20.进入根帐号密码设置，输入密码，点击“下一步”； 21.进入如下界面，选择“使用所有空间”，勾选“查看并修改分区布局”，点击“下一步”； 22.进入如下界面，点击“下一步”； 23.弹出“格式化警告”，点击“格式化”； 24.点击“将修改写入磁盘”； 25.进入如下界面，点击“下一步”； 26.进入如下界面，选择默认“Desktop”,点击“下一步”； 27.等待安装 28.安装完毕，点击“重新引导”重启； 29.然后配置； 30.登陆，主界面如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a18d415342132b358b8efc59b48d15/" rel="bookmark">
			npm报错npm ERR! A complete log of this run can be found in
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上有很多解决的办法，有的是删除node＿modules从新npm install.还有的解决办法是删除npm的缓存，但是这个报错还有一种根本性的原因–node版本太低，如果node的版本太低，而项目需求的版本较高，就有可能报这个错误，而且如果版本太低像删除node＿modules从新npm install也是没有用的，我遇到的就是这种问题，然后将node卸载从新安装高版本npm install就不会遇到这种问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb5948e73802232932b1ee0f78d1265/" rel="bookmark">
			前端（二十一）——WebSocket：实现实时双向数据传输的Web通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤨博主：小猫娃来啦
🤨文章核心：WebSocket：实现实时双向数据传输的Web通信协议
文章目录 前言WebSocket原理如何使用WebSocket建立WebSocket连接:数据传输: WebSocket的真实使用场景即时通讯:多人协作:实时数据更新: WebSocket的优势与局限性结论 前言 在当今互联网时代，实时通信已成为很多应用的需求。为了满足这种需求，WebSocket协议被设计出来。WebSocket是一种基于TCP议的全双工通信协议，通过WebSocket，Web应用程序可以与服务器建立持久的连接，实现实时双向数据输，提供极低的延迟和高效的数据传输。
WebSocket原理 HTTP请求-响应协议 在理解WebSocket原理之前，我们需要了解HTTP请求-响应协议。HTTP是一种无状态的请求-响应协议，客户端通过发送HTTP请求到服务器，服务器接收并处理请求，并返回HTTP响应给客户端。但是，在传统的HTTP协议中，客户端只能发送请求，而服务器只能通过响应来处理客户端的请求。
WebSocket协议 WebSocket协议是在HTTP协议的基础上进行扩展的。在建立WebSocket连接时，客户端首先发送一个HTTP请求到服务器，并将Upgrade头部字段设置为"websocket"，表示希望升级到WebSocket协议。服务器接收到这个请求后，如果支持WebSocket协议，会返回一个状态码101 Switching Protocols的HTTP响应，并通过Upgrade头部字段将连接升级为WebSocket连接。
升级完成后，客户端和服务器之间的通信不再遵循HTTP请求-响应模式，而是通过WebSocket协议进行双向的实时通信。客户端和服务器可以直接发送消息给对方，不需要等待对方的请求。
如何使用WebSocket 建立WebSocket连接: 要建立WebSocket连接，需要在客户端和服务器之间进行系列的握手操作。下面是详细的代码教程，示了如何在Web应用程序中建立WebSocket连接。
在户端（JavaScript）：
// 创建WebSocket对象并指定服务器地址 var socket = new WebSocket("ws://example.com/socket"); // 监听连接建立事件 socket.onopen = function() { console.log("WebSocket连接已建立"); // 在连接建立后，可以发送消息到服务器 socket.send("Hello Server!"); }; // 监听接收到服务器发送的消息 socket.onmessage = function(event) { var message = event.data; console.log("接收到服务器发送的消息：" + message); }; // 监听连接关闭事件 socket.onclose = function(event) { console.log("WebSocket连接已关闭"); }; // 监听连接错误事件 socket.onerror = function(event) { console.error("WebSocket连接错误：" + event}; 在服务器端（示例使用Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdb5948e73802232932b1ee0f78d1265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7db5b8dc4ad218b8d4b95495b8d996/" rel="bookmark">
			源码编译安装Apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
✨apache安装步骤
🍭挂载镜像
🍭解压并安装
🍭安装主程序
🍭优化链接及服务
🍭查看httpd模块
🍭查看mpm配置文件
🍭查看apache主页
🍭使用ab命令进行压力测试
🦐博客主页：大虾好吃吗的博客
🦐专栏地址：Linux从入门到精通
apache安装步骤 检查是否已经rpm安装httpd服务，已安装则卸载服务。 [root@localhost ~]# rpm -e `rpm -qa | grep httpd` --nodeps 开发工具安装 如果编译安装无法执行，可能是开发工具没有安装，执行下面命令即可安装。（如已安装则跳过即可）。
[root@localhost ~]# yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel httpd安装 挂载镜像 查看虚拟机使用ISO镜像，设备状态勾选已连接和启动时连接后确定即可。
解压并安装 [root@localhost ~]# mkdir /sh [root@localhost ~]# cd /sh [root@localhost sh]# vim add.sh #!/bin/bash mount /dev/cdrom /media/ tar zxf /media/apr-1.5.2.tar.gz -C /usr/src cd /usr/src/apr-1.5.2 ./configure --prefix=/usr/local/apr &amp;&amp; make &amp;&amp; make install tar zxf /media/apr-util-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7db5b8dc4ad218b8d4b95495b8d996/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8240c39e125248f28c57a378790beb/" rel="bookmark">
			用nodejs爬虫台湾痞客邦相册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景:是这样的,我想保存一些喜欢的小伙伴的照片,一张张保存太慢了, 所以我写了个js,放在国外服务器爬,国内的自己解决~
使用方法
1.点相册随便一张, 复制url, 这张开始接下来的图片都会保存
/** * 2023年10月23日 22:58:44 * 支持解析痞客邦相册 * 只需要复制相册第一张图片的url就行* * * */ const axios = require('axios'); const cheerio = require('cheerio'); const fs = require('fs'); const path = require('path'); const https = require('https'); let i = 0 //计算照片数量 // 示例用法 替换为您要解析的相册地址第一张图 let url = 'https://用户id.pixnet.net/album/photo/100898948#after=100899621' //默认延迟时间, 爬太快我怕出问题 let delay = 3000 //获取图片和下一个网页函数 async function parseImgTags(url) { try { const response = await axios.get(url); const html = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8240c39e125248f28c57a378790beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a650a3308093ddf6f293b791c361adef/" rel="bookmark">
			java怎么将string转int数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你有一个包含整数的字符串，想要将它们转换成整数数组，你可以使用Java的split()方法和parseInt()方法。首先，你需要使用split()方法将字符串分割成单个整数的字符串数组，然后使用parseInt()方法将这些字符串转换成整数并存储到一个整数数组中。以下是一个示例代码：
public class StringToIntArray { public static void main(String[] args) { // 包含整数的字符串 String numbersString = "1 2 3 4 5"; // 使用split()方法将字符串分割成单个整数的字符串数组 String[] numbersArray = numbersString.split(" "); // 创建一个整数数组，用于存储转换后的整数 int[] intArray = new int[numbersArray.length]; // 使用parseInt()方法将字符串转换成整数并存储到整数数组中 for (int i = 0; i &lt; numbersArray.length; i++) { intArray[i] = Integer.parseInt(numbersArray[i]); } // 输出整数数组 for (int num : intArray) { System.out.println(num); } } } 另外还可参考：string转int数组
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ab293fc42c0829c0de72fac8ab2a63/" rel="bookmark">
			【单片机学习笔记】Windows&#43;Vscode&#43;STM32F4&#43;freeRTOS&#43;FatFs gcc环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为摒弃在接受keil邮件，研究了下gun编译，以STM32F407为例，简单记录
1. 软件包准备 Git
选择对应版本直接安装即可https://git-scm.com/download/winmakegcc
​
1）将上述软件包放置于C盘根目录
2）添加环境变量
3）cmd命令行测试环境
分别输入
make -v gcc -v 2. 编写makefile # ------------------------------------------------ # # @file Makefile (based on gcc) # @author urien # @version v1.0.0 # # ChangeLog : # 2023-10-20 # ------------------------------------------------ ###################################### # target ###################################### TARGET = update ###################################### # building variables ###################################### # debug build? DEBUG = 1 # optimization OPT = -Og ####################################### # paths ####################################### # Build path BUILD_DIR = build ###################################### # source ###################################### # C sources C_DIRS += .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ab293fc42c0829c0de72fac8ab2a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4efa6e42d5fb1d7c931614a1a7d83f85/" rel="bookmark">
			Ubuntu 22.04 更新完内核重启卡在 grub 命令行解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		倒霉伊始 升级内核过程中出现如下警告，然后重启引导失败：
Warning: os-prober will not be executed to detect other bootable partitions
屏幕内容如下：
GNU GRUB version 2.06 Minimal BASH-like line editing is supported. For the first word, TAB lists possible command completions. Anywhere else TAB lists possible device or file completions. ESC at any time exits. grub&gt; 从 GRUB 2 命令行界面启动系统 因为卡在 Grub 2 命令行界面，我们需要手动输命令引导。
一般情况只需要输入 normal 并回车，就能像往常一样正常启动。 grub&gt; normal 如果报不认识该命令，那就加载 normal 模块，再来一遍前面的操作。 grub&gt; insmod normal grub&gt; normal 进系统修复配置 根据知乎专栏作者 ayamir 写的文章 2021 Archlinux双系统安装教程（超详细）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4efa6e42d5fb1d7c931614a1a7d83f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c1c751f6e0b575174eb1ebe7aabc14/" rel="bookmark">
			优优嗨聚集团：旅游经济繁荣，助力当地外卖市场崛起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着全球旅游经济的飞速发展，越来越多的人选择在假期或周末出游。而在旅游过程中，餐饮是一个不可或缺的环节。近年来，随着移动支付和互联网技术的普及，外卖行业逐渐崛起，为旅游经济注入了新的活力。
一、旅游经济带动外卖市场发展
旅游经济的繁荣为当地外卖市场提供了广阔的发展空间。一方面，随着游客数量的增加，餐饮需求量相应增长，为外卖行业提供了更多的订单来源；另一方面，旅游经济的快速发展也提升了当地居民的消费水平，他们更愿意选择便捷、高效的外卖服务来满足日常饮食需求。
二、外卖服务提升旅游体验
外卖服务的兴起为游客提供了更加便捷、个性化的餐饮体验。在旅游过程中，游客可以随时随地通过手机下单，享受当地特色美食。此外，外卖服务还可以为游客提供更多种类的餐饮选择，满足不同口味和需求。
四、总结
旅游经济的发展对当地外卖市场产生了积极的影响。一方面，旅游经济为外卖市场提供了广阔的发展空间；另一方面，外卖服务也提升了游客的旅游体验。为了吸引更多读者关注，自媒体平台文章应具备引人入胜的标题、突出亮点的内容、情感共鸣的表达、实用信息的提供以及图文并茂的展示等特点。通过这些方法，我们可以写出具有吸引力的文章，让更多人了解旅游经济与外卖市场之间的紧密联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5ee12a211d430e2b3d5d4a7f5791ee/" rel="bookmark">
			VsCode中安装PHP和PHP扩展Windows篇（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装vscode,相信大家都会，我就主要介绍php安装； 二、php环境手工安装 1、PHPStudy安装：https://public.xp.cn/upgrades/phpStudy_64.zip
2、进入页面后启apache服务
3 、防火墙允许访问
4、访问apache服务，在浏览器中访问127.0.0.1或本机ip地址，出现以下页面说明服务器搭建成功
5、 配置php语言环境
第一步：下载php:Download PHP(一定要下正确的64位)
第二步：下载后是压缩包，注意先双击打开，看看有没有根目录，没有根目录不要直接解压，会把文件混在一起，如图
第三步： 右键选择解压***，解压到当前文件夹或者.64\都可以
第四步：配置环境变量
打开php安装目录， 找到一会需要配置的路径
第五步：打开控制面板，找到系统=》高级系统设置=》环境变量=》系统变量下的PATH=》编辑，将上图的路径添加，如图：
第六步：测试，win+r,输入cmd,在cmd中输入 php -v 三、在VSCode中配置php 第一步：更换成中文语言
第二步： 配置xdebug插件环境
1、方法一：下载地址Xdebug: Downloads不建议这种方法，不稳定
方法二： 我将自己电脑上的后缀为dell的文件已上传，将文件解压为dell文件，然后复制到以下路径
2、添加配置，用记事本打开以下路径文件D:\phpstudy_pro\Extensions\php\php7.3.4nts，修改配置 3、在.ini文件末行添加：
[xdebug]
zend_extension="D:\phpstudy_pro\Extensions\php\php7.3.4nts\ext\php_xdebug-2.9.8-7.3-vc15-nts-x86_64.dll"
xdebug.remote_enable = 1
xdebug.remote_autostart = 1
第三步： 配置php编程环境
1、在VSCode中安装PHPDebug
2、 配置PHP执行环境
文件=》首选项=》设置=》扩展=》php=》在setting.json中编辑
3、配置：“D:\\phpstudy_pro\\Extensions\\php\\php7.3.4nts\\php.exe"（是我们文件的位置，但是要把\变成双斜杠\\，这样不会被扩展，更稳定并且\时报错）
4、 运行第一个php文件
1.放在小皮建立的网站根目录下的文件夹（自己建的一个php）：
2、新建test.php文件，运行，输出“hello world” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c38dfe9f7bda0cffcb9adbd44230d29/" rel="bookmark">
			意向后端的同学看过来，GO业务在招24届，机会多多！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		金山WPS2024校招，还有大量坑位
金山WPS2024届校园招聘计划比2023届多一倍研发名额，友友们有需要的自取内推码进行投递。投递地址：https://join.wps.cn/campus-r
大华C++一面（大数据研究院）10.23
面试官介绍了一下部门主要业务（数据挖掘、分布式存储、机器学习、虚拟化）动态多态的实现原理虚函数表是属于类的还是类对象的静态成员函数可以是虚函数吗为什么析构函数默
题解 | #查询结果去重#
SELECT DISTINCT universityFROM user_profileDISTINCT 关键词去重
南京荣耀oc
10.17座谈会，10.23 14:01荣耀oc啦，来还愿啦。产品线云服务数据开发。忙活一个月，这是我第一个南京offer！
题解 | #删除链表的节点#
/* * function ListNode(x){ * this.val = x; * this.next = null; * } *//** * 代
题解 | #查询结果限制返回行数#
SELECT device_idFROM user_profileLIMIT 2;使用LIMIT限制结果集LIMIT 子句可以被用于强制 SELECT 语句返回
题解 | #加号运算符重载#
#include &lt;iostream&gt;using namespace std;class Time {public: int hours; 科大讯飞 安卓开发 一面
自我介绍实习经历实习项目介绍实习主要做了什么单元测试的代码覆盖率怎么实现的怎么做的单元测试项目经历项目介绍怎么做的用户权限控制加密存储用户密码时，怎么加salt
招商银行济南分行线下面试
求问有必要去嘛，想知道这个竞争是不是超级激烈。主要人在外地，回去需要蛮大的精力的，如果有些希望 那我就勇敢冲，要是当kpi 就算了
被研究生包围，本科鼠鼠要吓死了
群面，全是研究生，只有我一个是本科生，这怎么打😨😨😨😨😨鼠鼠我啊，真的要被吓死了，这怎么打这怎么打
蔚来数分 秋招进度
鼠鼠想问问各位大佬们都进行到哪一步了呀 听说蔚来比较海 担心hr面完以后排序会挂很多人😢
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c38dfe9f7bda0cffcb9adbd44230d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53e2d8f12b396e7ff59b6b431ad113e/" rel="bookmark">
			MySQL 如何避免克隆失败后再次初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章讨论了当您没有足够的磁盘空间来存储两个数据集时，使用带有安全选项DATA DIRECTORY 的 CLONE INSTANCE 命令。
作者：Sveta Smirnova，数据库专家。
本文来源：https://www.percona.com/，爱可生开源社区翻译。
本文约 800 字，预计阅读需要 3 分钟。
在我之前关于 CLONE INSTANCE 命令的博客文章《MySQL 克隆插件不是你的备份》中，我提到使用选项 DATA DIRECTORY 有助于避免在克隆操作失败时需要从头开始重新初始化副本和克隆相关设置的情况。
MySQL 克隆插件简化了新副本的配置，但不会简化失败后的服务器恢复，除非您准备从头开始重新安装 MySQL 实例。
但是，当您克隆一个已经有巨大数据集的复制副本时，您可能没有足够的空间容纳两个数据集：一个来自源服务器，另一个来自复制副本上的数据。
由于您决定从另一台服务器克隆复制副本，因此您同意丢失当前数据。DATA DIRECTORY 选项的唯一需要是在出现故障时保持与克隆相关的权限和设置不变。您可以使用以下策略之一安全地执行克隆操作。
从头开始 要执行此操作，请停止当前服务器，删除数据目录，再次初始化它，进行连接，并设置与克隆相关的权限和选项。这样，您将拥有一个带有小数据目录的新实例，因此您可以使用选项 DATA DIRECTORY ，而不用担心超出可用磁盘空间。
保留现有 MySQL 架构 如果不想重新安装实例，可以从中删除用户数据。
列出所有带查询的非系统数据库。 SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME NOT IN ('mysql', 'sys', 'information_schema', 'performance_schema'); 将它们逐一移除。您可以使用以下存储过程来执行此操作。 CREATE PROCEDURE p1() BEGIN DECLARE done INT DEFAULT FALSE; DECLARE dbname VARCHAR(64); DECLARE c1 CURSOR FOR SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53e2d8f12b396e7ff59b6b431ad113e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c59f45e8ab2b5562b37a6078a69094/" rel="bookmark">
			C# 实现软件证书授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中，我们可以使用第三方库如AssemblyInfo.cs来编写软件授权功能。以下是一个简单的示例：
1. 首先，在项目中创建一个名为"LicenseKey.cs"的新文件。
2. 在"LicenseKey.cs"文件中，添加以下代码：
using System; using System.IO; using System.Security.Cryptography; using System.Text; namespace LicenseKey { public class LicenseManager { private const string _licenseKeyFileName = "LicenseKey.txt"; private const string _encryptionKey = "your-encryption-key"; public bool IsLicenseValid() { string licenseKey = GetLicenseKeyFromFile(); if (string.IsNullOrEmpty(licenseKey)) { return false; } string decryptedLicenseKey = DecryptString(licenseKey); if (string.IsNullOrEmpty(decryptedLicenseKey)) { return false; } return decryptedLicenseKey == "valid-license-key"; } private string GetLicenseKeyFromFile() { if (!File.Exists(_licenseKeyFileName)) { return null; } string licenseKey; using (StreamReader reader = new StreamReader(_licenseKeyFileName)) { licenseKey = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c59f45e8ab2b5562b37a6078a69094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18476e59ba58870e64052ddb1b68bce/" rel="bookmark">
			文件解锁器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源直达 1、场景预设 不用我猜，在你删除文件的时候，肯定遇到过这种情况：
解决这个问题，最简单的办法是打开任务管理器手动“杀”进程
打开任务管理器通用快捷键 Ctrl + Alt + Delete
Win10上的快捷键 Ctrl + Shift + ESC
但这个方法最大的问题是：Windows并不会提示是哪个进程占用了这个文件，所以很多时候你不知道该关闭哪个进程
当然另一个办法就是重启大法了，不过阿虚今天是来推荐软件的，所以这个就不多说啦
2、LockHunter LockHunter 的功能：显示锁定进程信息，提供解锁、复制、移动、删除或重命名操作，重启后删除，命令行工具等等。
然而这个软件也缺点还是挺多：
只能单个解锁想使用汉化版会比较麻烦（需要先安装正版，再替换文件）绿色版不支持拖动方式添加文件(文件夹)，需要手动选择目录 但软件功能不多，其实汉不汉化影响不大：下方的4个按钮依次是 Unlock It! (解锁文件)， Delete It! (删除文件)，Other…(更多操作)，Exit (退出)
点击下载：LockHunter3汉化安装版，可添加右键菜单点击下载：LockHunter3单文件版（英文），无右键菜单功能 3、IObit Unlocker 推荐这款IObit公司推出的软件，简单原因有这三个：
简单好用，自带中文支持批量添加单文件版 其实我不需要软件在右键菜单集成功能，我只需要在我遇到问题的时候，能快速打开软件，轻松的把「被占用」的文件拖进去解锁，而单文件版，无需安装，下载后双击即可使用，可谓完美契合阿虚想要的功能
软件下载
点击下载：IObit Unlocker 1.2绿色版，可添加右键菜单点击下载：IObit Unlocker 1.2单文件版，无右键菜单功能 原文链接：zhuanlan.zhihu.com/p/82037319
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74abc179819d031deb89117d84d5df4a/" rel="bookmark">
			CUDA学习笔记（十二） CUDA库简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA Libraries简介 上图是CUDA 库的位置，本文简要介绍cuSPARSE、cuBLAS、cuFFT和cuRAND，之后会介绍OpenACC。
cuSPARSE线性代数库，主要针对稀疏矩阵之类的。cuBLAS是CUDA标准的线代库，不过没有专门针对稀疏矩阵的操作。cuFFT傅里叶变换cuRAND随机数 CUDA库和CPU编程所用到的库没有什么区别，都是一系列接口的集合，主要好处是，只需要编写host代码，调用相应API即可，可以节约很多开发时间。而且我们完全可以信任这些库能够达到很好的性能，写这些库的人都是在CUDA上的大能，一般人比不了。当然，完全依赖于这些库而对CUDA性能优化一无所知也是不行的，我们依然需要手动做一些改进来挖掘出更好的性能。
下图是《CUDA C编程》中提到的一些支持的库，具体细节可以在NVIDIA开发者论坛查看：
如果大家的APP属于上面库的应用范围，非常建议大家使用。
A Common Library Workflow 下面是一个使用CUDA库的具体步骤，当然，各个库的使用可能不尽相同，但是不会逃脱下面的几个步骤，差异基本上就是少了哪几步而已。
创建一个库的句柄来管理上下文信息。分配device存储空间给输入输出。如果输入的格式并不是库中API支持的需要做一下转换。填充device Memory数据。配置library computation以便执行。调用库函数来让GPU工作。取回device Memory中的结果。如果取回的结果不是APP的原始格式，就做一次转换。释放CUDA资源。继续其它的工作。 下面是这几个步骤的一些细节解释：
Stage1：Creating a Library Handle
CUDA库好多都有一个handle的概念，其包含了该库的一些上下文信息，比如数据格式、device的使用等。对于使用handle的库，我们第一步就是初始化这么一个东西。一般的，我们可以认为这是一个存放在host对程序员透明的object，这个object包含了跟这个库相关联的一些信息。例如，我们可定希望所有的库的操作运行在一个特别的CUDA stream，尽管不同的库使用不同函数名字，但是大多数都会规定所有的库操作以一定的stream发生（比如cuSPARSE使用cusparseSetSStream、cuBLAS使用cublasSetStream、cuFFT使用cufftSetStream）。stream的信息就会保存在这个handle中。
Stage2：Allocating Device Memory
本文所讲的库，其device存储空间的分配依然是cudaMalloc或者库自己调用cudaMalloc。只有在使用多GPU编程的库时，才会使用一些定制的API来实现内存分配。
Stage3：Converting Inputs to a Library-Supported Format
如果APP的数据格式和库要求的输入格式不同的话，就需要做一次转化。比如，我们APP存储一个row-major的2D数组，但是库却要求一个column-major，这就需要做一次转换了。为了最优性能，我们应该尽量避免这种转化，也就是尽量和库的格式保持一致。
Stage4：Populating Device Memory with Inputs
完成上述三步后，就是将host的数据传送到device了，也就是类似cudaMemcpy的作用，之所说类似，是引文大部分库都有自己的API来实现这个功能，而不是直接调用cudaMemcpy。例如，当使用cuBLAS的时候，我们要将一个vector传送到device，使用的就是cubalsSetVector，当然其内部还是调用了cudaMemcpy或者其他等价函数来实现传输。
Stage5：Configuring the Library
有步骤3知道，数据格式是个明显的问题，库函数需要知道自己应该使用什么数据格式。某些情况下，类似数据维度之类的数据格式信息会直接当做函数参数配置，其它的情形下，就需要手动来配置下之前说的库的handle了。还有个别情况是，我们需要管理一些分离的元数据对象。
Stage6：Executing
执行就简单多了，做好之前的步骤，配置好参数，直接调用库API。
Stage7：Retrieving Results from Device Memory
这一步将计算结果从device送回host，当然还是需要注意数据格式，这一步就是步骤4的反过程。
Stage8：Converting Back to Native Format
如果计算结果和APP的原始数据格式不同，就需要做一次转化，这一步是步骤3的反过程。
Stage9：Releasing CUDA Resources
如果上面步骤使用的内存资源不再使用就需要释放掉，正如我们以前介绍的那样，内存的分配和释放是非常大的负担，所以希望尽可能的资源重用。比如device Memory、handles和CUDA stream这些资源。
Stage10：Continuing with the Application
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74abc179819d031deb89117d84d5df4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db04606ebac0cafb277d17f350f10e16/" rel="bookmark">
			Java 数据结构与算法-树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树的基础知识 树是算法面试经常遇到的数据结构之一，在实际工作中也有可能经常用到……
应聘者在准备算法面试时最需要重视的是二叉树……
二叉树是一种典型的具有递归性质的数据结构。二叉树的根节点可能有子节点，子节点又是对应子树的根节点，它可能也有自己的子节点。这就类似于 “子又生孙，孙又生子，子子孙孙无穷尽也”。由于二叉树本身就是递归的数据结构，因此很多与二叉树相关的面试题用递归的代码解决就很直观
……
二叉树的深度优先搜索 与二叉树相关的面试题绝大部分都是为了考查二叉树的遍历。第 7 章介绍了二叉树的广度优先搜索，本节将深入探讨二叉树的深度优先搜索及典型的面试题。二叉树的深度优先搜索可以细分为中序遍历、前序遍历和后序遍历
中序遍历
……
第一，递归有其固有的局限性。如果二叉树的深度（从根节点到叶节点的最长路径的长度）太大，那么递归的代码可能会导致调用栈溢出的问题。第二，递归的代码实在过于简单，面试官也希望增加面试的难度，因此在面试的时候经常会限制编写递归的中序遍历的代码
把递归代码改写成迭代的代码通常需要用到栈，改写中序遍历的代码也不例外……
前序遍历
……
前序遍历的递归代码实现和中序遍历的递归代码实现类似……
前序遍历的迭代代码实现和中序遍历的迭代代码实现也很类似……
后序遍历
后序遍历的递归代码实现和中序遍历的递归代码实现类似……
和中序遍历、前序遍历相比，后序遍历的迭代代码要稍微复杂一点。当达到某个节点时，如果之前还没有遍历过它的右子树就得前往它的右子节点，如果之前已经遍历过它的右子树那么就可以遍历这个节点。也就是说，此时要根据它的右子树此前有没有遍历过来确定是否应该遍历当前的节点。如果此前右子树已经遍历过，那么在右子树中最后一个遍历的节点应该是右子树的根节点，也就是当前节点的右子节点。可以记录遍历的前一个节点。如果一个节点存在右子节点并且右子节点正好是前一个被遍历的节点，那么它的右子树已经遍历过，现在是时候遍历当前的节点了
3 种遍历方法小节
下面比较中序遍历、前序遍历和后序遍历这 3 种不同遍历算法的代码。它们的递归代码都很简单，只需要调整代码的顺序就能写出对应算法的代码
它们的迭代代码也很类似，如它们都需要用到一个栈，而且代码的基本结构很相像，都有两个 while 循环并且它们的条件都一样。需要留意遍历当前节点的时机。前序遍历一边顺着指向左子节点的指针移动一边遍历当前的节点，而中序遍历和后序遍历则顺着指向左子节点的指针移动时只将节点放入栈中，并不遍历遇到的节点。只有当到达最左子节点之后再从栈中取出节点遍历。后序遍历最复杂，还需要保存前一个遍历的节点，并根据前一个遍历的节点是否为当前节点的右子节点来决定此时是否可以遍历当前的节点
不管是哪种深度优先搜索算法，也不管是递归代码还是迭代代码，如果二叉树有 n 个节点，那么它们的时间复杂度都是 O(n)。如果二叉树的深度为 h，那么它们的空间复杂度都是 O(h)。在二叉树中，二叉树的深度 h 的最小值是 log2(n+1)，最大值为 n……
3 种不同的二叉树深度优先搜索算法都有递归和迭代两种代码实现。这 6 段我们一定要深刻理解并能熟练写出正确的代码。这是因为很多与二叉树相关的面试题实际上都是在考查二叉树的深度优先搜索，理解中序遍历、前序遍历和后序遍历算法并能熟练写出代码，这些面试题都能迎刃而解。请看下面几个例题
面试题 47：二叉树剪枝
题目：一棵二叉树的所有节点的值要么是 0 要么是 1，请剪除该二叉树中所有节点的值全都是 0 的子树
public static TreeNode pruneTree(TreeNode root) { if (root == null) { return null; } root.left = pruneTree(root.left); root.right = pruneTree(root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db04606ebac0cafb277d17f350f10e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd71317e5f031aad6ff9ea531ae0cbc/" rel="bookmark">
			秋招测试开发面经总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安克创新-软件测试 一面 自我介绍讲一下实习经历？实习期间有没有遇到过难解决的问题？如何解决的？接口测试是怎么做的？讲一下你对测试的理解？你对安克有什么了解吗？你用过智能家居或者电器之类的吗？说一下你印象中电子产品做的很不好的地方？如何解决？ 说了windows的分屏逻辑和蓝牙耳机，说苹果耳机滑动调节做的很好~~那我用的airpods pro2也出现过误触的情况是什么原因？给你一个智能摄像头你会怎么测？反问 二面HR 自我介绍为什么想做测试这个岗位？你现在看的岗位都是以什么为主，都是测试吗？分享一个你在过往经历中，超越目标达成的事？所以当时竞选班委的时候目标也就是班长吗？还剩一些其他的干部？那你现在来看你当选班长成功的原因是什么？整个大学期间班长的经历给你带来的收获是什么？班长工作过程中，有没有哪个和你的初衷是不符合的，或者职责外的事情？你给班级带来的最大价值是什么？实习过程中最大的收获在哪些方面呢？实习期间你的工作内容主要是什么呢？实习过程中mentor给过你一些有用的反馈吗？实习过程中因为不熟悉而造成过一些问题吗？如何处理？没有写到测试用例里吗？对项目有影响吗？给你带来的经验是什么？ 好像hr蛮在意的，建议直接说无失误跨部门协作的时候出现过意见分歧的情况吗？如何处理的？你怎么看待测试岗在整个流程的作用？你在研发过程发现过哪些风险点吗？如何提出的？有没有让你荣誉感很强的事情最近？问了一下博客为什么大一大二想着考研，现在改变想法去工作？过往有没有什么让你很有挫败感的事情？评价一下自己，你的优势和不足在哪？反问 一嗨租车--软件测试 一面 自我介绍你对测试的理解？为什么不做开发选择测试？实习都做些什么？实习期间单独做过的需求？反问 二面 自我介绍测试主要职责是什么？进程和线程的区别？为什么要用到进程？项目里怎么用的多线程？有用到线程池吗？http和https的区别？反问 三面 自我介绍实习期间主要做的什么？接口测试怎么做的？接口测试在什么阶段去做？给你一个登录页你去设计一下测试用例为什么不做开发干测试？未来三年职业规划？入职后你会怎么做？大概什么时候可以入职？反问 四面hr 自我介绍何时能够入职实习？现在有其他offer吗？期望薪资？反问 同程旅行 一面 自我介绍实习？实习都做过什么？接口测试怎么做的？你的项目如何做接口测试？出现bug如何定位？两个sql：联合查询，两个表然后对结果排序算法：两个数相加你如何对你这个算法进行测试？测试思路是什么？除了边界值还有其他想法吗？算法：把上一个算法改成加减乘除的对这个算法测试？和上一个比有什么新的想法？ 诗悦网络 一面 自我介绍实习主要做什么？为什么不干开发干测试？说一说测试开发和游戏测试这俩岗位的区别都玩过什么游戏？英雄联盟的盲僧q技能让你去测试你会如何测？游戏测试的流程知道不？学的什么语言？如何学习的？反问 二面hr 自我介绍对测试的理解？为什么学的都是开发技能干测试？考虑过游戏开发吗？都知道哪些游戏公司？如何看待加班？什么时候可以入职？反问 诺瓦星云 一面 自我介绍实习期间主要做什么？实习业务主要是哪方面的？有遇到过什么问题吗？讲一下你的项目吧?多线程如何在项目中体现的？为什么要用到多线程？HashMap和CurrentHashMap的区别？实习期间接口测试怎么做的？Linux指令会不会？设计测试用例：微信发送红包你对诺瓦星云有什么了解？为什么想干测试不干开发？反问 二面 自我介绍简历都是开发内容为什么投测试岗？你和推荐人是什么关系？你学习这些相关的知识是什么时候开始学的？讲一下整个学习经历和过程参加过什么比赛吗？你平常学习这些知识的途径有哪些？对自己的职业规划是什么样的？你后续的测试发展是什么样的？或者说达到一个什么目标？为了这个目标你能说一说你最近的行动吗？实习的时候主要做的什么内容？你们的一个测试流程是什么？你如何看待开发和测试的关系？介绍一下项目，项目的背景？项目的成绩？你觉得你做项目的时候，最大的困难是什么？项目做完之后有没有测试过？现在回想一下，如果重新去做这个项目，你会做哪些改进，提高项目质量？这个项目你有没有通过自己的实践创新去提高质量或者提高用户体验？讲一下你做过的UI自动化的东西吗？取得了什么成果？你在哈罗实习的时候做过的自动化东西有哪些嘛?你是想做一个纯测试岗呢还是有测开的属性在呢？相比于其他人你的优势是什么？实习经历给你带来的最大收获是什么？反问 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae382f379ad1f64944599e6924203d96/" rel="bookmark">
			Css三角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果想要一个指向下面的三角形，可以让 border 的上边可见，其他边都设置为透明：
.triangle { width: 0; height: 0; border-top: 50px solid skyblue; border-right: 50px solid transparent; border-left: 50px solid transparent; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148c1c1e88dd2e4e70534df7e44a3355/" rel="bookmark">
			json入参取特定分段值--mirth
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入参
{ "HEADER": { "MSGID": "000", "MSGSENDDATE": "2023-10-12 00:00:00", "MSGTYPE": "TJ025", "AccepterID": "", "SenderID": "HIS", "MSGSTATUS": "" }, "DATA": [ { "PackageBarcode": "4546546", "TransType": "2", "CreateUser": "9390", "CreateTime": "2023-10-12 00:00:00", "CheckUser": "9390", "SendDept": "01220109", "SendUser": "9390", "SampleCount": "10", "VisitType": "0", "barcodeinfo": [ { "Barcode": "1901203036304", "Seq": "1" }, { "Barcode": "1901203036305", "Seq": "1" }, { "Barcode": "1901203036306", "Seq": "1" } ] } ] } 部分代码
//取数组长度
var num = msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148c1c1e88dd2e4e70534df7e44a3355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8f8f5e8111b8e228ef04bf682120b2/" rel="bookmark">
			2023-HCIA-Datacom题库刷题分享！984分高分通过！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HCIA-Datacom，是华为数通认证的初级考试，培训与认证具备数通基础通用知识和技能水平的工程师，只是入门了解数通的一些基础通用知识，适用于小白了解和学习数通知识点起点。
本人在2023年7月已通过HCIA-Datacom考试，个人分享是考试题目简单，实际考试时间大概20分钟左右都可以考完。
本人根据考试前的刷题经验，以及考试后的考试总结，自己弄了一个付费的HCIA-Datacom刷题小程序，题库约有900多题，大部分都带解析，有兴趣的各位可以看看。有需要可以送ENSP安装包、以及官网下好的理论和实验资料，有需要的可以私信联系我。
HCIA-Datacom理论和实操资料、ENSP安装包：HCIA-Datacom https://www.aliyundrive.com/s/1WDn3A4h6RB 点击链接保存，或者复制本段内容，打开「阿里云盘」APP ，无需下载极速在线查看，视频原画倍速播放。
HCIA-Datacom考试分为单选、多选、判断，考试题目60题，考试时间90分钟，总分1000分，600分及格。
华为人才在线官网：职业认证 (huawei.com)
官网考试大纲：HCIA-Datacom V1.0 考试大纲：
华为认证 HCIA-Datacom 认证考试
认证名称考试代码考试名称语言考试费用考试时长通过分数/总分HCIA-DatacomH12-811HCIA-Datacom V1.0CHS/ENU200USD90min600/1000 考试内容 HCIA-Datacom V1.0 考试覆盖数通础知识，包括TCP/IP 协议栈基础知识，OSPF 路由协议基本原理以及在华为路由器中的配置实现，以太网技术、生成树、VLAN 原理、堆叠技术以及在华为交换机中的配置实现，网络安全技术以及在华为路由交换设备中的配置实现，WLAN 相关技术与基本原理以及在华为无线设备中的配置实现，SNMP 等网络管理的基本原理，PPP 等广域网协议基本原理以及在华为路由器中的配置实现，IPv6 的基础知识以及 ICMPv6、DHCPv6 协议基本原理和配置实现，SDN 基本原理以及华为相应产品与解决方案的实现，编程自动化基本原理。
知识点占比 章节占比数据通信与网络基础8%构建互联互通的IP 网络27%构建以太交换网络28%网络安全基础与网络接入8%网络服务与应用5%WLAN 基础10%广域网基础3%网络管理与运维3%IPv6 基础5%SDN 与自动化基础3% 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1bfc6aabb12f2ecd9c63fa435a2b506/" rel="bookmark">
			如何使用前端桌面应用程序框架（Electron等）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚沙成塔·每天进步一点点
⭐ 专栏简介 前端入门之旅：探索Web开发的奇妙世界 欢迎来到前端入门之旅！感兴趣的可以订阅本专栏哦！这个专栏是为那些对Web开发感兴趣、刚刚踏入前端领域的朋友们量身打造的。无论你是完全的新手还是有一些基础的开发者，这里都将为你提供一个系统而又亲切的学习平台。在这个专栏中，我们将以问答形式每天更新，为大家呈现精选的前端知识点和常见问题解答。通过问答形式，我们希望能够更直接地回应读者们对于前端技术方面的疑问，并且帮助大家逐步建立起一个扎实的基础。无论是HTML、CSS、JavaScript还是各种常用框架和工具，我们将深入浅出地解释概念，并提供实际案例和练习来巩固所学内容。同时，我们也会分享一些实用技巧和最佳实践，帮助你更好地理解并运用前端开发中的各种技术。
无论你是寻找职业转型、提升技能还是满足个人兴趣，我们都将全力以赴，为你提供最优质的学习资源和支持。让我们一起探索Web开发的奇妙世界吧！加入前端入门之旅，成为一名出色的前端开发者！ 让我们启航前端之旅！！！
今日份内容：如何使用前端桌面应用程序框架（Electron等）？
使用前端桌面应用程序框架（如 Electron）可以让您使用前端技术（HTML、CSS、JavaScript）构建跨平台的桌面应用程序。下面是如何使用 Electron 框架的详细步骤：
步骤 1: 安装 Node.js 和 npm Electron 是基于 Node.js 构建的，所以首先确保您已安装 Node.js 和 npm（Node 包管理器）。
安装 Node.js：您可以从 Node.js 官方网站 下载适合您系统的 Node.js 安装程序，并按照安装指南进行安装。
步骤 2: 创建一个新的 Electron 项目 创建一个新的目录并进入它： mkdir my-electron-app cd my-electron-app 初始化 Node.js 项目，创建 package.json 文件： npm init 在初始化过程中，您需要提供一些关于您的项目的信息。一旦初始化完成，将创建 package.json 文件。
步骤 3: 安装 Electron 在项目目录下，使用以下命令来安装 Electron：
npm install electron 这将在项目中安装 Electron 并将其添加到 package.json 文件的依赖项中。
步骤 4: 创建主进程和渲染进程 Electron 应用程序通常包括两种主要类型的进程：主进程（Main Process）和渲染进程（Renderer Process）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1bfc6aabb12f2ecd9c63fa435a2b506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d594be858a616564687382f9e53e607e/" rel="bookmark">
			【Python学习笔记】循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中有两种类型的循环: while 循环 和 for 循环
1. while 循环 while循环是： 检查一个条件表达式，只要条件表达式计算结果为True 时， 就执行下面缩进的代码。
如此反复，直到条件表达式计算结果为False时，结束 循环。
比如:
command = input("请输入命令:") while command != 'exit': print(f'输入的命令是{command}') command = input("请输入命令") 其中 while command != 'exit' 会判断用户输入的命令 (command 变量) 是否等于字符串 'exit'
如果不等于, 就执行下面缩进的代码。下面缩进的代码就是循环体内的代码，还会再次让用户输入命令到变量command中。
如果等于字符串 'exit'， 就结束循环。
如果用户输入的命令一直都不是字符串 'exit'， 就会一直执行循环。
用 while 循环要注意 循环条件的设置，处理不当，有可能导致 循环的条件始终为True，循环永远不会结束，变成了死循环。
比如，我们要打印出 从 1 到 100 的数字，应该写成下面这样
i = 1 while i &lt;= 100: print(i) i += 1 如果不小心，漏掉最后一句，变成
i = 1 while i &lt;= 100: print(i) 这样 i 的值始终不变， 循环的条件 i &lt;= 100 一直都是满足的，就变成死循环了。程序一直打印 i 值为 1 ，永不结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d594be858a616564687382f9e53e607e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b486a6aa0d225fd5031b24ffeaa91371/" rel="bookmark">
			【2023最新教程】超详细！！！有道翻译js逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一 表单sign字段加密二 返回值AES解密三 完整代码四 效果展示 前言 有道翻译两个加密
第一个是表单的sign 用MD5加密
可以点击目录的 加密字段实现 直接跳转
第二个是返回值AES加密，而且AES的密匙他还用md5加密了一下
可以点击目录的 函数实现解密返回值 直接跳转
一 表单sign字段加密 确定加密字段
表单根据多次请求发现 sign这个字段不断变化，所以是加密了
mysticTime一看就是时间戳，不管他
破解加密字段
在右上角点击搜索
输入sign:
要加英文的冒号，这样结果更精准
可以看到有4个文件含有sign
接着我们打开 发起程序
可以看到app这个文件也是程序发起之一，而且都是排在前面 ，很可疑 ，直接从他开始一个一个查找
可以看到，这段代码可疑，很多字段表单中都有，打个断点测试一下
记得打两个断点，开始一个断点，结束一个断点
因为这样可以直接运行到这段代码的结束位置，这样就可以查看中间的值，不至于直接跳出断点
很明显，K(o,e)返回的值就是 sign，这里直接运行退出去看下是不是
很明显，就是他 ，一模一样，所以我们直接找到 k函数就行
点击跳转
看着这里，已经非常明显了，
k(o,e) 函数解读
o 是时间戳
e是一个固定的字符串
k函数的作用 就是组成一个 除了时间戳 不一样，其他都一样的字符串
然后交给 j函数 进行MD5加密
digest(‘hex’)的意思就是返回16进制的值
最后返回的结果，就是 sign的值
加密字段实现
我们直接上实战
先把md5加密写出函数
我们先使用之前的时间戳，看看和表单上的是否一样
看的出来，我们sign值就破解成功了
直接写成函数装进请求头中
这五个请求头都是要的
import time import requests import hashlib # 导入hash库函数 # 时间戳 ti = str(int(time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b486a6aa0d225fd5031b24ffeaa91371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebd86dd4a55eda5978c809d4275a25e/" rel="bookmark">
			重积分 | 二重积分中值定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考来源
一次性彻底搞懂大纲新增的二重积分中值定理_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d50a9d9d82d4b0f2487fbe2327ed934/" rel="bookmark">
			Hive 中级练习题（40题 待更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近快一周没更了，主要原因是最近在忙另一件事情（关于JavaFX桌面软件开发），眼看大三上一半时间就要过去了，抓紧先学Hive，完了把 Spark 剩下的补了，还有 Kafka、Flume，任务还是不少的，最后再放假前做一个小的大数据项目，希望一切顺利。
环境准备 这部分直接上代码，反正也没人看哈哈哈。
-- SQL 中级 show databases ; create database practice2; use practice2; create table user_info( `user_id` string COMMENT '用户id', `gender` string COMMENT '性别', `birthday` string COMMENT '生日' ) COMMENT '用户信息表' ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'; insert overwrite table user_info values ('101', '男', '1990-01-01'), ('102', '女', '1991-02-01'), ('103', '女', '1992-03-01'), ('104', '男', '1993-04-01'), ('105', '女', '1994-05-01'), ('106', '男', '1995-06-01'), ('107', '女', '1996-07-01'), ('108', '男', '1997-08-01'), ('109', '女', '1998-09-01'), ('1010', '男', '1999-10-01'); CREATE TABLE sku_info( `sku_id` string COMMENT '商品id', `name` string COMMENT '商品名称', `category_id` string COMMENT '所属分类id', `from_date` string COMMENT '上架日期', `price` double COMMENT '商品单价' ) COMMENT '商品属性表' ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'; insert overwrite table sku_info values ('1', 'xiaomi 10', '1', '2020-01-01', 2000), ('2', '手机壳', '1', '2020-02-01', 10), ('3', 'apple 12', '1', '2020-03-01', 5000), ('4', 'xiaomi 13', '1', '2020-04-01', 6000), ('5', '破壁机', '2', '2020-01-01', 500), ('6', '洗碗机', '2', '2020-02-01', 2000), ('7', '热水壶', '2', '2020-03-01', 100), ('8', '微波炉', '2', '2020-04-01', 600), ('9', '自行车', '3', '2020-01-01', 1000), ('10', '帐篷', '3', '2020-02-01', 100), ('11', '烧烤架', '3', '2020-02-01', 50), ('12', '遮阳伞', '3', '2020-03-01', 20); create table category_info( `category_id` string, `category_name` string ) COMMENT '品类表' ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'; insert overwrite table category_info values ('1','数码'), ('2','厨卫'), ('3','户外'); create table order_info( `order_id` string COMMENT '订单id', `user_id` string COMMENT '用户id', `create_date` string COMMENT '下单日期', `total_amount` decimal(16, 2) COMMENT '订单总金额' ) COMMENT '订单表' ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t'; insert overwrite table order_info values ('1', '101', '2021-09-27', 29000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d50a9d9d82d4b0f2487fbe2327ed934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0771efa84ebf7b0083c7d9cb69e564b/" rel="bookmark">
			HAXM无法安装问题Android系统找不到指定的批处理标签 - in_exit9009（完美解决方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在桌面上建立文件任意文件夹，然后打开。 然后将上面地址 复制 ，一般结果如下 C:\Users\XXXXX\Desktop\新建文件夹 (2)
如果自己电脑的xxxxxx是中文，就把他换成英文，中间不允许有空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b6c7f49b8b1e014b79315d2369fadb/" rel="bookmark">
			C&#43;&#43;——类和对象（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 一、面向过程和面向对象初步认识二、类的引入三、类的定义类的两种定义方式 四、类的访问限定符及封装1、访问限定符2、封装 五、类的作用域六、类的实例化七、类对象模型1、类大小的计算2、结构体内存对齐数规则 八、this指针引出特性 总结 一、面向过程和面向对象初步认识 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。 C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成。 二、类的引入 由于c语言的结构体中，只能用来定义变量，而在C++中，结构体不仅可以定义变量，还可以定义函数。 struct stack { int a; int c; void push(int x) { a = x; } void print() { cout &lt;&lt; a &lt;&lt; endl; } }; int main() { stack s1; s1.push(5); s1.print(); } 上面结构体的定义，在C++喜欢用class来代替。 三、类的定义 class className { // 类体：由成员函数和成员变量组成 }; // 一定要注意后面的分号 class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。 类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数。 类的两种定义方式 声明和定义全部放在类体中。 需注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。 class Date { int _year; int _mouth; int _day; void Init() { _year = 2020; _mouth = 8; _day = 15; } }; 类声明放在.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b6c7f49b8b1e014b79315d2369fadb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c866eec0d7de04429ff86ed80b2850/" rel="bookmark">
			jmeter如何测试websocket接口？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmeter做接口测试，很多人都是做http协议的接口，就有很多人问websocket的接口怎么测试啊？
首先，我们要明白，websocket接口是什么接口。
然后，我们怎么用jmeter测试？
jmeter要测试websocket接口，需要先下载安装一个websocket samplers by peter doornbosch 的插件，插件安装成功后，再次启动jmeter，会在jmeter取样器最下面显示6个socket相关的取样器
如果你想学习自动化测试，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的自动化测试教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 【已更新】B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）_哔哩哔哩_bilibili【已更新】B站讲的最详细的Python接口自动化测试实战教程全集（实战最新版）共计200条视频，包括：1、接口自动化之为什么要做接口自动化、2、接口自动化之request全局观、3、接口自动化之接口实战等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV17p4y1B77x/?spm_id_from=333.337 websocket close 用于正常关闭websocket连接；
websocket open connection 用于显式设置websocket连接；
websocket ping-pong 用于发送ping和接收 pong请求；
websocket single read sampler 用于接收一个文本或二进制的websocket请求；
websocket single write sampler 用于发送一个文本或二进制的websocket请求；
websocket request-response sampler 用于执行基本的请求-响应请求；
日常测试时，使用websocket request-Response sampler就足够了。
日常测试时，使用websocket request-Response sampler就足够了。
connection，有两个单选，一个是使用已经建立的连接，如果选择这种，那么，在该取样器之前要使用 websocket opnen connection先连接；
如果选择新建一个连接，则该取样器中，需要配置serverURL信息。
serverURL中，首先是协议，下拉框有两个选项，ws和wss. ws是明文数据传输，wss是密文数据传输，相当于http和https的差别。
server name or ip 就填写服务器的域名或ip地址
server name or ip 就填写服务器的域名或ip地址；
port 对应服务的端口；
path 对应服务路径，可以用 /；
data 就是发送的数据，支持两种，text文本，和binary 二进制；
request data为发送的数据，当数据类型为文本式，可以带jmeter的参数，如果为binary 二进制时，则输入的为二进制内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c866eec0d7de04429ff86ed80b2850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b90bd1bc9f6272b5ecee6c824c32fb/" rel="bookmark">
			基于STM32单片机三色全彩RGB LED灯控制系统 原理图PCB程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件电路的设计 链接：https://pan.baidu.com/s/15vD6FJNKvQrnr42TNkQsUA 提取码：p3yh
系统硬件系统分析设计
系统功能设计
本系统由STM32F103C8T6单片机核心板、RGB灯驱动、按键组成。
1、系统实时驱动RGB灯进行显示不同颜色，颜色调整可以通过三个按键或者蓝牙驱动。
2、三个按键分别对应RGB灯的RGB值，通过调节不同的R/G/B值可以对灯颜色进行变换
3、蓝牙也可以对R/G/B值进行设置，显示不同的颜色。通过蓝牙APP直接设置R/G/B值，滑块操作；也可以直接点击APP底部默认颜色方框直接设置成已有颜色。
设备接收蓝牙命令：
*R050G010B123#
R050 //设置R值50
G010 //设置G值10
B123 //设置B值123
蓝牙上传命令：
*R5G10B123#
R5 //当前R值5
G10 //当前G值10
B123 //当前B值123
系统硬件系统分析设计
1、STM32单片机核心电路设计
STM32系列处理器是意法半导体ST公司生产的一种基于ARM 7架构的32位、支持实时仿真和跟踪的微控制器。选择此款控制芯片是因为本系统设计并非追求成本的最低或更小的功耗，而是在实现本设计功能的前提下能够提供更丰富的接口和功能以便于设计实验系统各实验项目所需的外围扩展电路。此款控制芯片在完成单片机课程的学习后上手较为容易，在医疗器械中应用广泛，具有很好的学习、实验研究价值。
一、STM32的主要优点：
（1）使用ARM最新的、先进架构的Cortex-M3内核
（2） 优异的实时性能
（3） 杰出的功耗控制
（4） 出众及创新的外设
（5） 最大程度的集成整合
（6） 易于开发，可使产品快速将进入市场
二、STM32——最佳的平台选项
对于使用同一平台进行多个项目开发而言，STM32是最
佳的选择：
（1） 从仅需少量的存储空间和管脚应用到需要更多的存储空间和管脚的应用
（2） 从苛求性能的应用到电池供电的应用
（3） 从简单而成本敏感的应用到高端应用
（4） 全系列脚对脚、外设及软件的高度兼容性，给您带来全方位的灵活性。您可以在不必修改您原始框架及软件的条件下，将您的应用升级到需要更多存储空间或精简到使用更少存储空间/ 或改用不同的封装的规格。
STM32F103C8T6单片机核心板接口电路图如下图所示。
核心板设计：
3、LY蓝牙模块电路设计
蓝牙模块是指集成蓝牙功能的芯片基本电路集合，用于无线网络通讯。本蓝牙模块就是为了只能无线数据传输而专门打造的，本模块支持串行接口，支持SP蓝牙串口协议，具有成本低、体积小、收发灵敏性高等特点，只需配备少许的外围元件就能实现大功能。
一、模块特点
（1）支持蓝牙 SPP 串口协议
（2）内置 PCB 天线
（3）支持 UART 接口
（4）蓝牙 Class 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b90bd1bc9f6272b5ecee6c824c32fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98250a6f7989d455e683c2d2a0359dbb/" rel="bookmark">
			Foxit PDF 基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Foxit PDF 福昕PDF 软件，可以很好的编辑PDF文档。
调整ＰＤＦ页面大小 PDF文档中，一个页面大，一个页面小
面对这种情况,打开Foxit PDF
右键单击需要调整的页面,然后选择"调整页面大小".
可以选择"自定义",可以查找该页面的大小信息(如英寸),然后依据该数据信息,调整其它页面.于是可以统一PDF大小.
设置PDF格式号码 如果需要调整PDF的格式名称，可以选中后右键单击
选择＂格式化页面＂，然后就可以将页面重新命名．
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8277e38df669675bf32243f075b434d0/" rel="bookmark">
			shell脚本中循环中定义的数值变量，输出结果不是循环，为什么被错误的解释为文本字符串？【附解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例子：以下shell脚本中的内容我执行完成后输出{1..4}，而不是循环
count=$(pgrep -c bash) for i in {1..$count} do echo $i done 理想结果：
1
2
3
4
实际结果却是字符串：
{1..4}
=============================
你的Shell脚本的目的是循环打印从1到当前bash进程数的数字。如果你发现它没有按预期执行，可能是由以下原因导致的：
1、【pgrep命令未能正确找到bash进程数】：确保系统中存在bash进程，且pgrep命令能够正确地计数。如果你在非交互式Shell（例如，在脚本或后台任务中）中运行此脚本，可能会发现bash进程数大于实际你看到的终端会话数。
2、【变量插值问题】：在bash中，大括号 {} 用于创建数字范围，但你需要注意，它们在这里是作为文本字符串处理的。因此，{1..$count}实际上会被解释为文本字符串的枚举，而不是从1到$count的数字范围。这是为什么你的输出结果不是循环，而是被解释为文本字符串{1..4}。
要解决这个问题，你可以使用seq命令来创建数字序列：
bashcount=$(pgrep -c bash) for i in $(seq 1 $count) do echo $i done 这个修改后的脚本使用了seq命令来生成从1到bash进程数的数字序列，然后将这些数字逐个打印出来。注意，seq命令在bash中是可用的，因此这个脚本应该可以正常工作在大多数常见的Linux发行版上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c038f32bd0caa9c7087d7caab2f870fd/" rel="bookmark">
			Es集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
组件全家套
版本说明
主机准备
1.解压安装
2.运行环境配置
2.1修改每个节点linux系统限制
2.2 修改每个节点 linux 系统配置 2.3 调整vm.max_map_count的大小
2.4 重启验证配置
3. 配置ES
3.1 每个节点创建ES用户，ES不能使用root启动
3.2 每个节点创建数据目录，日志目录
3.3 配置es文件目录，跨域请求,修改每个节点特殊的内容
3.4修改JVM启动参数
3.5 配置开机启动，启动服务
组件全家套 LogStash数据同步组件相关
Lostash同步Mysql数据到Elasticsearch（一）服务介绍及环境配置
Lostash同步Mysql数据到ElasticSearch（二）logstash脚本配置和常见坑点
Lostash同步Mysql数据到Elasticsearch（三）Elasticsearch模板与索引设置
Lostash同步Mysql数据到Elasticsearch（四）通过kibana辅助查看同步情况kibana开发工具相关
Kibana开发工具安装 版本说明 组件版本备注Elasticsearchelasticsearch-7.7.1-linux-x86_64.tar.gz 主机准备 主机名ipnode144172.168.9.144node145172.168.9.146node146172.168.9.146 1.解压安装 注意：Elasticsearch需要安装JDK环境，配置前请先行安装JDK环境
tar -zxvf elasticsearch-7.7.1-linux-x86_64.tar.gz -C /usr/local/ 2.运行环境配置 2.1修改每个节点linux系统限制 vim /etc/security/limits.conf * hard nproc 4096 * soft nproc 4096 * hard nofile 655300 * soft nofile 655300 * soft memlock unlimited * hard memlokc unlimited 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c038f32bd0caa9c7087d7caab2f870fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f799740441082a033dc086502ca08889/" rel="bookmark">
			JVM第十七讲：调试排错 - Java 问题排查之Linux命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调试排错 - Java 问题排查之Linux命令 本文是JVM第十七讲， Java 问题调试排错。Java 在线问题排查主要分两篇：本文是第一篇，通过linux常用命令排查。
文章目录 调试排错 - Java 问题排查之Linux命令在项目中，日志操作的常用命令1、在终端中登录日志系统2、查看模块位置的指令3、查看错误日志 1、文本操作1.1、文本查找 - grep (常用)1.2、文本分析 - awk (不常用)1.3、文本处理 - sed (不常用) 2、文件操作2.1、文件监听 - tail (常用)2.2、文件查找 - find (常用)2.3、pgm (不常用) 3、查看网络和进程3.1、查看所有网络接口的属性 (常用)3.2、查看防火墙设置 (不常用)3.3、查看路由表 (不常用)3.4、netstat (不常用)3.5、查看所有进程 (常用)3.6、top (常用) 4、查看磁盘和内存相关4.1、查看内存使用 - free -m (常用)4.2、查看各分区使用情况 (常用)4.3、查看指定目录的大小 (常用)4.4、查看内存总量 (常用)4.5、查看空闲内存量 (常用)4.6、查看系统负载磁盘和分区 (常用)4.7、查看系统负载磁盘和分区 (常用)4.8、查看挂接的分区状态 (常用)4.9、查看所有分区 (常用)4.10、查看所有交换分区4.11、查看硬盘大小 5、查看用户和组相关5.1、查看活动用户5.2、查看指定用户信息5.3、查看用户登录日志5.4、查看系统所有用户5.5、查看系统所有组 6、查看服务，模块和包相关7、查看系统，设备，环境信息8、tsar 在项目中，日志操作的常用命令 1、在终端中登录日志系统 账号： ssh developer@172.16.101.123 密码： zcy 日志中心 2、查看模块位置的指令 find -name web-item* 或 find ./ -name item-mi* (模糊搜索以web-item开头的模块) 3、查看错误日志 方式1： tail -f filename（filename为前一个命令查到的路径）方式2：通过 vi filename 来查询 可以更加方便地搜索日志中的关键字 注意事项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f799740441082a033dc086502ca08889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6898e1661a3bb72bf567493ac879820/" rel="bookmark">
			STM32驱动RGB LED彩灯模块闪烁GPIO_Write（）函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于标准库来实现驱动LED灯闪烁的状态，利用这个实验更加清楚明白的了解GPIO输出引脚的应用，以及对子函数——延时函数的调用
上一篇文章用的是GPIO_Resetbit()已经GPIO_Setbits（）两个函数，文中我们使用多一个GPIO_Write（）函数。
文章目录
一、LED彩灯模块介绍及实验现象
1、模块介绍
2、实验现象
二、程序编写前的准备
1、延时函数的调用
2、GPIO _write()函数
3、硬件电路接线
三、程序编写
1、端口配置
2、主函数的编写
一、LED彩灯模块介绍及实验现象 1、模块介绍 LED彩灯模块，具有三个LED灯，高电平驱动，三个LED灯为红（R）、绿（G）、蓝（B），三个灯单独亮时则对应其颜色，其中两个亮或三个同时亮时，可以组合成多种颜色。
如 当三个灯同时亮时，灯光 分为三块，但整体亮度较强，无明显变色现象。 当蓝灯与红灯同时亮起时，灯光颜色有点像紫色。
2、实验现象 本实验为两个状态，一个是初始化状态，一个是正常工。初始化状态会进行三次红——绿——蓝灯交替切换，然后进入正常工作状态，即彩灯模块三个灯同时闪烁（同时亮同时灭），在彩灯模块灭的时候stm32板上的灯会亮，当彩灯模块亮时stm32板上的灯灭，二者交替闪烁。
STM32驱动RGB LED彩灯模块闪烁
二、程序编写前的准备 1、延时函数的调用 简单的延时函数，可以利用for循环，或者while循环，让程序运行一段时间（定义变量i，赋予一个值，让这个值从某数值减小到0），这样就可以实现粗略的一个延时。下面提供的是一个比较精准的延时函数。即Delay.c文件。
#include "stm32f10x.h" /** * @brief 微秒级延时 * @param xus 延时时长，范围：0~233015 * @retval 无 */ void Delay_us(uint32_t xus) { SysTick-&gt;LOAD = 72 * xus;	//设置定时器重装值 SysTick-&gt;VAL = 0x00;	//清空当前计数值 SysTick-&gt;CTRL = 0x00000005;	//设置时钟源为HCLK，启动定时器 while(!(SysTick-&gt;CTRL &amp; 0x00010000));	//等待计数到0 SysTick-&gt;CTRL = 0x00000004;	//关闭定时器 } /** * @brief 毫秒级延时 * @param xms 延时时长，范围：0~4294967295 * @retval 无 */ void Delay_ms(uint32_t xms) { while(xms--) { Delay_us(1000); } } /** * @brief 秒级延时 * @param xs 延时时长，范围：0~4294967295 * @retval 无 */ void Delay_s(uint32_t xs) { while(xs--) { Delay_ms(1000); } } 主函数调用这个delay函数前需要声明，这里用delay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6898e1661a3bb72bf567493ac879820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c048e0e6579ce6996af1af3ffe065b38/" rel="bookmark">
			基于Opencv&#43;python的车流量检测项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项目介绍
整体流程
调试环境
项目流程
1.预处理
2.汽车识别——去背景算法（KNN/MOG2）
3.统计车流量数目
结尾
源代码
测试视频资料
流程图
项目介绍 本次项目主要采用了传统视觉的方法，对车道车流实现检测，能较为准确的识别出来车道上的车辆数目。由于传统视觉算法本身的局限性，因此也会有识别不准的地方。
整体流程 话不多说，先讲思路，直接上流程图
这里把所有预先设定的参数和变量统一称为了“宏”，然后对识别到的每一帧图像进行处理，最后得到理想的效果图。
效果图如下：
调试环境 Jupyter Notebook(Anaconda)Python 3.9.12OpenCv 4.5.5 项目流程 1.预处理 #灰度 cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY) #高斯去噪 blur=cv2.GaussianBlur(frame,(5,5),5) mask=removebg.apply(blur) #腐蚀 erode=cv2.erode(mask,kernel,iterations=2))#iteration=n 迭代n次 #膨胀 dilate=cv2.dilate(erode,kernel,iterations=2 #cv2.imshow("x",dilate) dst=cv2.morphologyEx(dilate,cv2.MORPH_CLOSE,kernel) 2.汽车识别——去背景算法（KNN/MOG2） 先介绍KNN算法（因为本次采用的算法为KNN）
KNN最邻近分类算法的实现原理：为了判断未知样本的类别，以所有已知类别的样本作为参照，计算未知样本与所有已知样本的距离，从中选取与未知样本距离最近的K个已知样本，根据少数服从多数的投票法则（majority-voting），将未知样本与K个最邻近样本中所属类别占比较多的归为一类。
在Opencv中，KNN算法已经被封装好了，所以我们直接调用就可以。
#KNN算法去背景 removebg=cv2.createBackgroundSubtractorKNN() MOG2是一个以混合高斯模型为基础的前景/背景分割算法。使用 K(K=3 或 5)个高斯分布混合对背景像素进行建模。使用这些颜色(在整个视频中)存在时间的长短作为混合的权重。背景的颜色一般持续的时间最长，而且更加静止。这个函数有些可选参数，比如要进行建模场景的时间长度，高斯混合成分的数量，阈值等。将他们全部设置为默认值。然后在整个视频中我们是需要使用backgroundsubtractor.apply() 就可以得到前景的掩模了。移动的物体会被标记为白色，背景会被标记为黑色的。使用方法同上，在此不过多赘述。
3.统计车流量数目 本次统计采用的方法为：找到矩形框的中心点经，当该点经过提前所设定好的直线时，车辆数+1
计算中心点的函数:
def center(x,y,w,h): x1=int(w/2) y1=int(h/2) cx=x+x1 cy=y+y1 统计车流量的代码部分：
cpoint=center(x,y,w,h) cars.append(cpoint)#将中心点储存到cars数组中 for (x,y) in cars: if(y&gt;lineHeight-7 and y&lt;lineHeight+7): Car_nums +=1 cars.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c048e0e6579ce6996af1af3ffe065b38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7565e618c126b2616bd885a4b1cd7726/" rel="bookmark">
			【网络】‘‘三层交换机‘‘配置详解，看一遍就会！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三层交换机： 1、三层交换机是什么 三层交换机就是在交换机上添加虚拟的逻辑子接口，这个接口设置为vlan的网关地址，同时支持vlan tag的剥离和添加，通过vlanif接口实现不同的vlan通信
既有三层路由转发的功能，又有二层交换转发的功能，能实现不同vlan之间的通信
2、三层交换机的工作原理 第一步：主机A想要给主机B通信，会先判断主机B与自己是不是在一个网段，如果是一个网段直接给到交换机进行二层转发；如果不是一个网段，求助相应的虚拟网关1，发送ARP广播获取虚拟网关1的mac地址；
第二步：主机A封装数据帧发送给三层交换机的虚拟网关1，三层交换机会拆包查询，同时三层交换机会自动学习主机A的信息（主机A的ip地址，mac地址，vlan，相应的接口）记录在MLS条目中，在MLS条目中查找目的主机B的信息，发现查不到主机B，则会通过FIB表查询（相当于路由表），判断发送到主机B的网段需要通过虚拟接口2，数据包被重新封装转发给主机B；
第三步：主机B会回复一个数据给到主机A，这时主机B发送ARP请求，三层交换机可以直接通过查询MLS表格给到主机A的mac地址，主机B封装数据发送到三层交换机，三层交换机会再次自动学习主机B的信息（主机B的ip地址，mac地址，vlan，相应的接口）记录在MLS条目中，同时查询MLS条目，能查到主机A的信息，直接通过相应的接口进行转发（这里不再查FIB表！！！）
最后：主机A与主机B后期可以直接单播通信（一次路由多次转发），大大提高了传输速度！！并节省了资源！！
3、总结三层交换机的特点？ 3.1总结：一次路由，多次交换，加快大型局域网内部的数据交换
3.2三层交换机与路由器对比：没有路由器的NAT,ACL,VPN等功能
3.3与单臂路由向对比：
相同点：都能实现不同vlan之间的通信
不同点：①单臂路由是在路由器上虚拟交换机的功能，三层交换机是在二层交换机上虚拟路由器的网关；②三层交换机更快，因为查路由表更消耗资源，三层交换机能实现高速转发；③在实际生产中路由器比交换机贵，更节约成本；
3.4MLS条目形成：
FIB转发信息库：与路由表对应
邻接关系表：与mac表对应
4、三层交换机模拟实验：实现pc之间互相访问 配置二层交换机
vlan batch 10 20 30 #接口1配置 int e0/0/1 port link-type access (p l a) port default vlan 10 (p d v 10) #接口2配置 int e0/0/2 port link-type access (p l a) port default vlan 20 (p d v 20) #接口3配置 int e0/0/3 port link-type access (p l a) port default vlan 30 (p d v 20) #接口4配置 int e0/0/4 port link-type trunk (p l t) port trunk allow-pass vlan all (p t a v a) 三层交换机配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7565e618c126b2616bd885a4b1cd7726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1daf27ecb97fe55d1254a5d26e41297a/" rel="bookmark">
			进阶JAVA篇-深入了解 List 系列集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.0 List 类的说明
1.1 List 类的常用方法
1.2 List 集合的遍历方式
2.0 ArrayList 集合的底层原理
2.1 从 ArrayList 集合的底层原理来了解具有该特性的原因：
2.2 ArrayList 集合的优缺点
3.0 LinkedList 集合的底层原理
3.1 从 LinkedList 集合的底层原理来了解具有该特性的原因：
3.2 LinkedList 集合的优缺点
3.3 LinkedList 集合的特有方法
1.0 List 类的说明 在 Java 中，List 类是 Java 集合框架中的一种接口，它是一种有序的、可重复的集合，用于存储多个元素。List 接口是 Collection 接口的子接口，它定义了一系列方法来操作和访问列表中的元素，所以 List 接口继承了 Collection 接口的方法。
有关的 Collection 接口的常用 API 介绍在以下链接：
进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式-CSDN博客
1.1 List 类的常用方法 以代码的形式来介绍这些方法：
import java.util.ArrayList; import java.util.List; public class Text_List { public static void main(String[] args) { //由于 List 是一个接口，不能直接去创建对象， //所以用 List 的实现类来创建一个对象，比如 ArrayList List&lt;String&gt; list = new ArrayList&lt;&gt;();//这是一行经典的代码！！！ list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1daf27ecb97fe55d1254a5d26e41297a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc823106f5a28b83a30d4c6dfe38646/" rel="bookmark">
			实现vue项目和springboot项目前后端数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装node.js 太高版本的win7不支持
这里安装node-v12.16.2-x64.msi，指定安装位置后直接按下一步就可以。npm是node内置的工具
这里配置npm的镜像cnpm（提高下载速度，以后用到npm的命令都可以用cnpm命令替换）不指定cnpm版本使用如下命令会报错： npm install -g cnpm --registry=https://registry.npm.taobao.org 错误信息： npm WARN notsup Unsupported engine for npm-normalize-package-bin@3.0.1: wanted:{"node":"^14.17.0 || ^16.13.0 || &gt;=18.0.0"} (current: {"node":"12.16.2","npm":"6.14.4"}) npm WARN notsup Not compatible with your version of node/npm: npm-normalize-package-bin@3.0.1 检查错误，参照网上的对应版本图，node12要用cnpm 6版本，输入如下命令： npm install -g cnpm@6 --registry=https://registry.npm.taobao.org 查看node和npm版本 node -v npm -v 2、安装vue-cli脚手架 vue-cli是在node基础上构建的工具，而vue-cli又可以快速搭建含vue功能的模块（即模块化开发）。安装vue-cli 3.x脚手架命令如下： cnpm install @vue/cli -g 查看版本 vue -V 3、创建vue项目 vue-cli脚手架创建的是模块化项目，使用模块化开发（.vue后缀的文件为单文件组件，一个文件里封装了html、js、css代码）。项目属于单页面应用（SPA），通过路由跳转链接，不利于SEO（爬虫抓取不到内容），可以用Nuxt框架解决该问题（这是后话）。所以说vue比较适合做后台管理系统。但前端分离的插拔特性，可以让它方便地切换为移动端浏览器、app或小程序。
这里有两种方法创建，第一种是用命令（会在当前文件夹下创建文件夹）： vue create 项目名 第二种用UI可视化界面创建： vue ui 启动vue可视化工具，会在浏览器中打开，创建过项目的需要返回主页：
选手动配置
点创建即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc823106f5a28b83a30d4c6dfe38646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f1a3d34990a611688811448bac6075/" rel="bookmark">
			learn C&#43;&#43; NO.11——string类模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章主要是讲string类的模拟实现，模拟实现的是string类的常用接口以及成员函数。让读者对string类有更深的理解。适当的“造轮子”，有助于我们的语言学习。
简单描述string类 string类其实就是一个管理字符数组的线性表，我们可以使用string头文件内提供的接口来对string类进行数据的增删查改。
第一部分：初步搭建一个string类最基本的框架 我们以上面图中的一个简单的程序为模拟实现的第一个部分。首先，我们需要定义一个string类。然后，定义string类的成员变量。提供构造函数和析构函数。最后，提供一个c_str接口能够是&lt;&lt;运算符能够提取出模拟实现的string类的数据。
定义成员变量 我们将要实现的string类实现的成员变量如下，定义一个char类型指针的成员变量_str，来保存在堆上动态开辟的内存空间。分别定义两个无符号整型成员变量_size和_capacity，顾名思义_size用于记录string类对象的有效数据个数，_capacity用于记录string类对象的在堆上开辟空间的大小。需要将成员变量私有，以防止在类域外面能够访问修改数据。仅提供对应接口让用户能够访问成员变量的内容。
构造函数的模拟实现 这里我们实现的是通过一个c字符串的内容来构造一个string类的全缺省构造函数。它同样可以完成string类的默认构造的对应功能。
实现思路： 首先，我们先通过strlen()求出需要形参部分的字符串的长度，并将结果保存到一个临时变量中。然后，new一块长度为形参部分长度的空间+1赋值给_str（这里+1是为了放’\0’）。将形参部分的字符串的长度赋值给_size和_capacity。最后，在函数体内直接通过c库函数strcpy来将形参的内容拷贝给_str。
这里我们在默认参数中给的是一个空串，其实这里是一个很妙的处理。c语言中规定""引起的字符串内容中包含一个隐藏的’\0’。当我们不传参数时，我们还是会开辟一个字节的空间存放’\0’字符来初始化string类对象。
析构函数的模拟实现 因为string类的数据需要存放在堆区上，所以析构函数需要我们实现，编译器默认生成的析构函数无法完成对堆区资源的释放。只需要将堆区空间释放并处理_size和_capacity即可。
c_str()函数的模拟实现 c_str()函数是获取string类的内筒，以c字符串形式返回。简而言之，c_str()接口返回的是成员变量_str。需要注意的是需要使用const来修饰一下返回值，以保护成员变量_str。
至此第一部分的最最基本的string类的框架就搭建好了，下面我们再稍微完善完善模拟实现的string类。
第二部分：进一步完善功能 size()函数的模拟实现和capacity()的模拟实现 size()函数用于获取string类有效元素的个数，本质其实就是返回_size的值。capacity()函数用于获取string类在堆区开辟的空间的长度，返回的是成员变量_capacity。
[]运算符重载的模拟实现 由于库里string类是重载了操作符[]，使得string类像数组一样。这极大程度上方便用户对于string类的某一个位置的数据进行增删查改。
实现思路： 实现思路就是返回_str的某一个位置的字符。需要注意的是库里面对于下标有效性的检查是assert的暴力检查。
迭代器及相关成员函数模拟实现 string类的迭代器其实就是一个类似于指针的一个东西，本质是其成员函数_str，但是迭代器不一定都是指针。例如list，其迭代器就不是指针，具体细节等模拟实现list时再说。begin()其实就是返回string类对象第一个元素的地址，end()返回的是string类对象有效字符的下一个地址（'\0’的地址）。
有了迭代器就可以支持范围for语法。因为范围for的底层是通过迭代器来实现的。这里就简单做个演示。
reserve()函数的模拟实现 reserve函数用于将_str在堆区申请的空间大小进行调整。
实现思路：当调整的值 &gt; _capacity时就进行扩容，当n&lt;_capacity不做处理。开辟一段长度为n的堆区空间，将_str的值拷贝给新开辟的空间（需要拷贝’\0’），随后释放_str。最后将tmp赋值给_str,将_capacity修改成n。
resize(size_t n, char ch = ‘\0’)函数的模拟实现 resize()函数用于调整string类对象有效字符的长度至指定的长度，也支持指定字符来进行初始化。
实现思路：当n小于当前string对象有效长度时，将n赋值给_size，有效长度的后一个位置添上’\0’。当n大于string对象有效长度时，先用reserve来调整有效的空间大小，然后从_size后开始写入字符ch直到有效长度达到n。修改_size的值为n。
push_back()函数 的模拟实现 push_back()函数就是在string类对象的有效长度的下一位插入元素。这里以插入一个字符的版本为例进行模拟实现。
实现思路：先判断空间是否足够，若不够就扩容。然后在第_size个位置插入字符。随后++_size，并在_size下标位置上放上’\0’。
append()函数的模拟实现 append()函数就是在string类对象的有效长度后追加数据，这里以常用的追加一个c字符串为例模拟实现。
实现思路：首先，判断堆区空间是否足够。然后，在_size下标出，将c字符串拷贝c字符串长度个数据到_size后的空间。最后更新string类对象的有效长度。
operator += 重载的模拟实现 由于上面我们已经实现了push_back()和append()接口，这里我们至今进行一波复用就可以啦。
insert()函数的模拟实现 这里我们分别模拟实现两个版本，一个是在pos位置插入n个字符，另一个是在pos位置插入一个c字符串。再此之前我要引入一个新的成员变量npos，他是一个静态的公用成员变量，它表示的是最大的无符号整型值，即-1（2^32-1）。
实现思路：首先,判断一下pos下标的合法性。然后，判断堆区空间是否足够，不够就扩容。接下来，从pos位置开始向后挪动数据（需要注意边界控制），挪动n位。在pos位置插入n个字符或者一个c字符串。最后，更新一下_size。
find()函数的模拟实现 find接口用于从pos下标处开始查找一个字符或者一个字符串在当前string类对象的下标，没有找到则返回npos，所以我们还是实现两个版本。
实现思路：先判断下标的合法性。字符串版本进行strstr匹配，成功找到的话返回strstr的返回值-_str的偏移量，没有找到则返回npos。字符版本，直接使用一个for循环遍历string类对象，找到了就返回对应下标，否则返回npos。
erase()函数的模拟实现 erase函数用于删除从pos下标处开始，删除长度为len个数据。
实现思路：首先，判断pos下标的合法性。然后，根据len来判断删除的方式，若len = npos或者pos + len &gt; _size，即从pos位置开始直接删完。若pos + len &lt; _size，则需要挪动数据覆盖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f1a3d34990a611688811448bac6075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08cf406543b76caed9635815e04d0d6/" rel="bookmark">
			Kibana开发工具安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本说明 名称版本备注kibana kibana-7.7.1-linux-x86_64.tar.gz 安装配置 tar -zxvf kibana-7.7.1-linux-x86_64.tar.gz -C /usr/local/ cd /usr/local/ mv kibana-7.7.1-linux-x86_64/ kibana-7.7.1/ #编辑配置文件，在末尾添加 vim /usr/local/kibana-7.7.1/config/kibana.yml 授权 chown -R elasticsearch. /usr/local/kibana-7.7.1/ 配置文件修改 # Kibana is served by a back end server. This setting specifies the port to use. # server.port: 5601 # Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values. # The default is 'localhost', which usually means remote machines will not be able to connect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08cf406543b76caed9635815e04d0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebce51e9bde8431ba321932a8c6c764f/" rel="bookmark">
			小巧加密软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 目前为止加密的方法非常的多，比如windows自带BitLocker、Windows通过修改文件名加密、通过注册表隐藏盘符加密、通过第三方软件加密等等。今天我要讲的是属于第三方软件如何对文件夹加密的方法。
2、准备 小工具名称：移动加密、加密猫
兼容系统：WINDOWS11、Windows10、Windows7
安装方面：便携单文件无需安装，打开就可以使用。
大小方面：406KB特别小巧
是否收费：否
加密可否移植：可以
3、加密工具演示 3.1 加密过程 复制移动加密小工具。
打开需要加密的文件夹。
在文件夹空白处右击粘贴。
双击打开移动加密小工具。
输入加密密码——点击加密。
文件夹加密后如下图所示：只剩下咱的那个小工具
3.2 解密过程 解密很简单，直接双击那个移动加密小工具——输入密码——默认完全解密——点击“解密”。
解密后正常显示所有文件。
我们也可以选择临时解密，临时解密后，会有一个提示框弹出，防止我们忘记加密。
临时解密显示如图
文件使用后，我们想恢复加密，直接点击——恢复加密状态即可。
4、加密文件夹可移动到其它电脑的windows系统上依然可用 这个工具加密后的文件夹还有另外一个特点，移动到其它地方，他依然是加密的。下面我把这个文件夹移动到另一台电脑上。
我们解密下
成功解密
5、总结 所有的加密方法几乎都用了一遍，感觉这个是比较简单的并且软件是免费的，最重要的是这种加密方法问题很少。加密的安全性我只能说没有任何一款加密软件是100%安全的。另外加密过程中需要注意：所加密的文件不能是正在使用中的。 https://zhuanlan.zhihu.com/p/452544470
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/47/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>