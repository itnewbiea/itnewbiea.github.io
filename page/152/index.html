<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1304fa5fefe64c824e44bf6a45a0d0b5/" rel="bookmark">
			SLAM学习笔记（一）Lio-sam安装与运行 ubuntu18.04&#43;ros melodic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三维激光SLAM入门 Lio-sam安装与运行 ubuntu18.04+ros melodic
文章目录 前言一、环境要求二、复现步骤1.安装ROS依赖2.安装Lio-sam3.下载给定数据集4.运行Lio-sam5.播放数据包5.保存Pcd建图结果 总结 前言 最近在学习激光SLAM，本文将介绍了ubuntu18.04+ros melodic下部署复现LIO-SAM的过程。2020年TIxiaoshan在IROS发表了Lio-sam算法，LiO-sam是Lego-Loam的拓展版本，添加了IMU预积分因子和GPS因子，Loam与Lego-Loam纯靠激光雷达点云信息SLAM，Lio-sam结合了Lidar、IMU与GPS
一、环境要求 我的环境：
ubuntu18.04
ROS melodic
二、复现步骤 1.安装ROS依赖 代码如下：
sudo apt-get install -y ros-melodic-navigation sudo apt-get install -y ros-melodic-robot-localization sudo apt-get install -y ros-melodic-robot-state-publisher Lio-sam中使用了因子图优化，在此对因子图优化库gtstam进行安装
浏览器中复制下方网址下载gtstam
https://github.com/borglab/gtsam/archive/4.0.2.zip 打开终端，对压缩包进行解压和安装
cd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/ cd ~/Downloads/gtsam-4.0.2/ mkdir build &amp;&amp; cd build cmake -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF .. sudo make install -j8 2.安装Lio-sam 首先，创建新的工作空间：
makdir -p ~/catkin_ws/src cd ~/catkin_ws catkin_make echo "source ~/catkin_ws/devel/setup.bash" &gt;&gt; ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1304fa5fefe64c824e44bf6a45a0d0b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7149d2bc54525022412a9861a65fd6f2/" rel="bookmark">
			python读取csv文件命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python操作csv文件命令大全（一） 读文件和看文件 df = pd.read_csv（'文件名.csv'） df.head() #默认前五行，若是想看更多行，括号里自行输入 合并文件 pd.merge(left, right, how=' ', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=True, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None) 各参数如下：
left: 拼接的左侧DataFrame对象right: 拼接的右侧DataFrame对象on: 要加入列或索引的名称，名称必须在两个DataFrame对象中都能找到，因为是根据该名称就行合并。（如果未传递且left_index和right_index为False，则DataFrame中的列的交集将被推断为连接键）。left_on:左侧DataFrame中的列或索引级别用作键。 可以是列名，索引级名称，也可以是长度等于DataFrame长度的数组。right_on: 左侧DataFrame中的列或索引级别用作键。 可以是列名，索引级名称，也可以是长度等于DataFrame长度的数组。left_index: 如果为True，则使用左侧DataFrame中的索引（行标签）作为其连接键。
对于具有MultiIndex（分层）的DataFrame，级别数必须与右侧DataFrame中的连接键数相匹配。right_index: 与left_index功能相似。how: One of ‘left’, ‘right’, ‘outer’, ‘inner’.默认inner。inner是取交集，outer取并集，left为左连接，right为右连接，标签不能对齐的部分，用NAN进行填充。sort: 按字典顺序通过连接键对结果DataFrame进行排序。 默认为True，设置为False将在很多情况下显着提高性能。suffixes: 用于重叠列的字符串后缀元组。 默认为（‘x’，’ y’）。copy: 始终从传递的DataFrame对象复制数据（默认为True），即使不需要重建索引也是如此。indicator:在pd.concat()中可以通过参数设定显示拼接后的表中哪些信息来自于哪一个表格，在pd.merge()中也可以进行这样的操作，就是通过indicator参数设置，默认是False不显示数据来源，把参数设置为True就可以了。
例子： dff = all_data.merge(df,on = 'start_id',how = 'left') 左连接保留左表的信息，把右表中主键与左表一致的信息拼接进来，标签不能对齐的部分，用NAN进行填充。
文件保存为csv 保存路径 df.to_csv('text.csv') #相对位置，保存在getwcd()获得的路径下 df.to_csv('C:/Users/name/Desktop/text.csv') #绝对位置 查询当前工作路径 import os os.getcwd() #获取当前工作路径 分隔符 df.to_csv('text.csv',sep='?')#使用?分隔需要保存的数据，不写则默认是 替换空值 df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7149d2bc54525022412a9861a65fd6f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5da7232d421394a26d6c8e948191ac/" rel="bookmark">
			安装华为eNSP2019亲测有用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 eNSP它是华为的一个网络模拟器,借助这个模拟器,可以模拟网络架构和建设。
安装 1、前置条件，需要先安装winPcap，Wireshark，VirtualBox V5.2.X版本的，这是我准备的安装包
建议：所有软件金量安装在非C盘
2、安装winPcap，一直点击下一步，默认安装到最后
一定要先安装winPcap，因为安装wireshark时会默认安装nPcap，导致无法安装winPacp，导致无法安装eNSP
3、安装wireshark，基本保持默认安装，但是要注意下面几点
3.1 如果想要桌面图标就在下图勾选圈到的
3.1选择安装路径，建议更换到非C盘下
3.2一定不要勾选install nPacp，可能会卸载到安装ensp的必须条件，winPacp
3.3是否安装usb插件，USBPcap是一个很专业的对USB设备的数据包进行检测与捕获工具，随兴趣
4、安装VirtuslBox ，记得选择安装路径
5、安装eNSP，默认安装到最后
然后就可以开心地使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b573ed543df4f3d27a9acf360ea6ceeb/" rel="bookmark">
			ROS2_Foxy学习8——launch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ROS2_Foxy学习8——launch launch文件的Python模板参考 The launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described. The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS specific conventions which make it easy to reuse components throughout the system by giving them each different configurations. It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b573ed543df4f3d27a9acf360ea6ceeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c3d0d9cba517baecbff32ebd0f8cb9/" rel="bookmark">
			【C&#43;&#43;】函数重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 函数重载的概念重载的原理 在自然语言中一个词可以有多种含义，人们可以通过上下文来判断这个词的真是含义，即该词被重载了 比如：以前有一个笑话，国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了！”，后者是“谁也赢不了！” 函数重载的概念 C++允许在同一个作用域声明几个功能类似的同名函数。这些函数要满足三个不同：参数的个数，参数的类型和参数的顺序，即构成函数重载。
我们来看一下构成重载的几个函数
int f(int a,int b); double f(double a,double b); void f(int a,double b); void f(double a,int b); void f(); 需要注意的是：返回值相同与否并不影响是否重载，所以只有返回值不同的函数不构成重载。
下面来区分一下两队比较容易出错的函数重载
void f(int a); void f(int a=0); 这两个函数的区别是缺省值不同，而函数重载的定义是三个不同，关注的是形参的类型，与缺省值无关，所以不构成重载。
void f(); void f(int a=0); 这两个函数就构成函数重载，因为他们的参数个数不同，第一个无参，第二个有一个参数，但是当我们在使用这两个函数时，如果我们没有给函数传值，那么这时调用两个函数都是可以的，这就出现了歧义，编译器也不能确定调用哪一个，所以我们不能这样写重载函数。
重载的原理 C++是如何支持函数重载的呢？C语言又为什么不能支持函数重载呢？
首先我们要了解一下编译的过程
编译分为4步，我大致的梳理一下
1.预处理–头文件的展开，宏替换，条件编译，去掉注释等。生成(.i)文件
2.编译–检查语法，生成汇编代码。生成(.s)文件
3.汇编–把汇编代码转换成二进制的机器码。生成(.o)文件
4.链接-把二进制的机器码和在一起。生成(.out)文件
要理解函数重载的原理，我们就可以看一下生成的汇编代码，可以帮助我们理解计算机是如何实现函数的调用的。
我们先写两个重载函数
void f() { cout&lt;&lt;"f()"&lt;&lt;endl; } void f(int a) { cout&lt;&lt;"f(a)"&lt;&lt;endl; } int main() { f(); f(1); return 0; } 在VS编译器下，我们可以在调试时点鼠标右键—&gt;进入反汇编 看当前代码对应的汇编代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c3d0d9cba517baecbff32ebd0f8cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d22e2f7cbe709b567af8c7ecf71c8a/" rel="bookmark">
			DM8数据库redo日志损坏恢复办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重做日志（redo日志）是实时记录着数据库对象的增、删、改操作的日志文件，所以也叫联机日志文件，数据库在正常运行的情况下是用不上重做日志的，但数据库在发生故障停机，在恢复数据库服务时，就需要用到重做日志将故障前的操作进行恢复。
但如果重做日志因某种原因丢失或损坏，则数据库将无法启动，需要将重做日志恢复后，才能正常启动数据库服务。单机重做日志恢复流程是先利用dminit+时间.log文件中故障数据库的信息，去重新初始化库，新初始化库会产生两个与原有数据库同名同大小的重做日志文件；再将此两个重做日志copy到要恢复的数据库的目录下；然后利用dmmdf工具将着两个重做日志的db_magic的值改为原重做日志的db_magic值；这时再重启数据库就能正常启动了。
---------------------------------------------------------------------------------------------------------------------------------
目录
一、测试前准备
二、恢复redo日志
一、测试前准备 1. 启动库，查看故障前的数据情况：
2. 模拟重做日志出现意外丢失或损坏，可以将DAMENG0*.log文件移到其他目录下：
[dmdba@hsdmdb ~]$ cd /home/dmdba/dmdbms/data/DAMENG [dmdba@hsdmdb DAMENG]$ mv DAMENG0*.log /mvfile 此时重启数据库服务，就不能正常的启动了：
[dmdba@hsdmdb DAMENG]$ cd ../../bin [dmdba@hsdmdb bin]$ ./DmService restart 二、恢复redo日志 1. 查看故障数据库的信息，在dminit+时间.log文件中显示：
[dmdba@hsdmdb DAMENG]$ cat dminit20220215112000.log 2. 利用此信息，重新初始化一个新的数据库：
[dmdba@hsdmdb bin]$ ./dminit path=/dm8/data page_size=16 charset=0 port_num=5237 db_name=DAMENG instance_name=DMS [dmdba@hsdmdb bin]$ ll /dm8/data/DAMENG 3. 新初始化的实例，会生成两个redo日志文件DAMENG01.log和DAMENG02.log，将这两个redo日志文件cp到故障库的目录下：
[dmdba@hsdmdb DAMENG]$ cp DAMENG0*.log /home/dmdba/dmdbms/data/DAMENG/ 4. 进入$DM_HOME/bin下，进入dmmdf工具，查看使用说明：
[dmdba@hsdmdb bin]$ ./dmmdf help 5. 查看故障库的db_magic值：这里为db_magic=33988343
[dmdba@hsdmdb bin]$ ./dmmdf TYPE=1 FILE=/home/dmdba/dmdbms/data/DAMENG/SYSTEM.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53d22e2f7cbe709b567af8c7ecf71c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/692d1f5a548ce0b10eba046a488cc4c2/" rel="bookmark">
			windows11的ps界面字体显示过小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows11的ps界面字体显示过小 最近更新了windows11发现以前使用的ps软件打开时候界面字体显示非常小。
在设置中设置了界面字体显示为中，还是不行。折腾了一番。
原因：windows11对ps显示的兼容性设置问题。
解决方法：
右键桌面的ps图标快捷键选择属性
如图，将高DPI更改为系统，重启ps软件即可
有问题欢迎留言…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed456c3996e50f51f41aee77acf9785/" rel="bookmark">
			Python绘图：turtle库基础语法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、turtle库的导入
二、绘图命令介绍
1. 画布属性设置
2. 画笔属性设置
3. 移动画笔和转角绘图
4. 图形绘制与图形填充
三、turtle绘图实例：绘制太阳花
Python语言的turtle库是一个直观有趣的图形绘制函数库，是python语言标准库之一。turtle库的绘图原理是在一个横轴为x、纵轴为y的坐标平面中，以原点（0,0）位置为开始点，根据一组函数指令的控制来移动，从而在它爬行的路径上绘制图形。
一、turtle库的导入 方法一：import turtle
方法二：import turtle as t
方法三：from turtle import *
二、绘图命令介绍 1. 画布属性设置 语法含义turtle.screensize(width,height,bg) 设置画布的宽、高、背景颜色turtle.setup(width,height,startx,starty) 设置画布显示窗口的大小、位置，前两个参数为窗口大小，后两个参数为起始点位置 2. 画笔属性设置 语法含义turtle.shape("turtle")设置画笔的形状（turtle-海龟；arrow-箭头；circle-圆圈；square-实心正方形；triangle-三角形；classic-默认箭头）turtle.pensize(width)设置当前画笔线条的宽度为width像素turtle.colormode(1.0[255])设置画笔颜色模式turtle.pencolor(colorstring)设置画笔的颜色，参数colorstring可以是"green"、"red"、"blue"、“yellow”等英文字符串turtle.speed(5)设置画笔的移动速度，画笔绘制的速度范围在[0,10]整数之间，数字越大，画笔移动的速度越快。 3. 移动画笔和转角绘图 语法含义turtle.penup()/pu()/up()提起画笔，不绘图turtle.pendown()/pd()/down()画笔移动时绘制图形turtle.forward(100)/fd(100)画笔向当前方向移动100像素距离turtle.backward(100)/bk(100)画笔向相反方向移动100像素距离turtle.right(45)/rt(45)画笔顺时针移动45度turtle.left(45)/lt(45)画笔逆时针移动45度turtle.setheading(45)/seth(45)设置当前画笔朝向为45度turtle.goto(x,y)移动画笔到指定坐标位置turtle.hideturtle()隐藏画笔turtle形状turtle.showturtle()显示画笔turtle形状 实例代码
# coding:utf8 import turtle as t t.setup(500, 500) # 设置画布大小 t.reset() # 清空窗口 t.pensize(4) # 设置画笔大小为4 # 绘制外层正方形 t.penup() # 提起画笔 t.pencolor("red") # 设置画笔颜色 t.goto(-200, -200) # 设置外层正方形起点坐标 t.pendown() t.forward(400) # 外层正方形边长为400像素 t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fed456c3996e50f51f41aee77acf9785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f58dc1e77af3bd36006b32c54e3209d/" rel="bookmark">
			JS高级--数据、变量和内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是数据？ 数据是存储在内存中特定信息的“东东”，本质上是 011101010...
数据的特点：可传递、可运算
一切皆数据
内存中所有操作的目标：数据
二、什么是内存？ 内存是内存条通电后产生的可储存数据的空间（临时的）
内存的产生和死亡：
内存条（电路板）==》通电 ==》产生内存空间 ==》存储数据 ==》处理数据 ==》断电 ==》内存空间和数据都消失 一块小内存的两个数据：
内部储存的数据地址值 内存分类：
栈：全局变量/局部变量堆：对象注意：函数（对象）本身在堆里，但函数名（表示对象的变量）在栈中 三、什么是变量 变量是可变化的量，由变量名和变量值组成
每个变量都对应一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据（变量值可以是基本数据或者地址值）
四、内存、数据、变量三者的关系 内存是用来存储数据的空间，变量是内存的标识
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0eb8242df735fee85b0d131e332441/" rel="bookmark">
			前端面试笔试题目-JS专项练习（基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源：牛客网：https://www.nowcoder.com/
1、JS数据类型 JS数据类型6种值类型(基本类型)符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol（独一无二的值）3种引用数据类型（对象类型）对象(Object)、数组(Array)、函数(Function)2种特殊的对象正则（RegExp）和日期（Date） &lt;script&gt; console.log(typeof "John") // string console.log(typeof 3.14) // number console.log(typeof NaN) // number console.log(typeof false) // boolean console.log(typeof [1, 2, 3, 4]) // object console.log(typeof { name: 'John', age: 34 }) // object console.log(typeof new Date()) // object console.log(typeof function () { }) // function console.log(typeof myCar) // undefined console.log(typeof null) // object console.log(typeof undefined) // undefined &lt;/script&gt; 2、检测数据类型（四种方法） 1、请补全JavaScript函数，要求以字符串的形式返回参数的类型 function _typeof(value) { // 补全代码 return typeof(value); } 2、请补全JavaScript函数，要求以Boolean的形式返回第一个参数是否属于第二个参数对象的实例。 function _instanceof(left,right) { // 补全代码 return (left instanceof right); } 总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0eb8242df735fee85b0d131e332441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37df77251420217e2e50ad16839a7ff/" rel="bookmark">
			torch中tensor数据类型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转换为float32类型：
points = points.type(torch.float32) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf7001067ae6b2eda49a996c4878c23/" rel="bookmark">
			计算机图形学实验一：openGL安装和代码测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 OpenGL配置 1. 对于每个项目分别安装 （直接用NuGet管理器 安装nupengl）
这样相当于将openGL的组件（FreeGLUT,GLFW,GLEW）安装到了项目内，每个项目都需要再安装一次，比较麻烦。
2. 安装到系统（所有项目均可使用） 这样安装比较麻烦但课以使用到所有项目，只需操作一次。
（1）安装GLEW 连接：GLEW: The OpenGL Extension Wrangler Library (sourceforge.net) OpenGL的扩展库。
解压后有四个文件夹：
· include为头文件。将其中.h文件放入VS的工具文件夹下，我电脑的路径为C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\include\GL
·bin为动态链接库和可执行文件。其中两个可执行文件是用于检查dll信息的，单机运行可产生txt格式的信息文件。 将bin\Realease内两个文件夹（分别针对64位 32位）中的glew32.dll，根据版本复制到C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30037\bin中的Hostx64和Hostx86下的x64和x86文件夹中。
|-bin
|-Hostx64
|- x86 glew32.dll （glew-2.1.0\bin\Release\Win32中）
|- x64 glew32.dll （glew-2.1.0\bin\Release\x64中）
|- Hostx86（同理）
|- x86
|- x64
·lib为静态链接库文件。也是有两个版本，将Win32中的lib拷贝到...\MSVC\14.29.30037\lib\x86中；x64内容拷贝到...\MSVC\14.29.30037\lib\x64中。
· doc文件夹为官方说明文档，不用管。
（2）安装GLFW 下载链接：Download | GLFW 用于创建、管理窗口和输入输出
·VS2019选择64位版本安装
文件安装：
·将include文件夹内的.h头文件放入...\MSVC\14.29.30037\include\GL中
·将lib-vc2019中的glfw3.dll放入...\MSVC\14.29.30037\bin内的Hostx64、Hostx86下的x64和x86文件夹中。
·将lib-vc2019中的glfw3.lib和glfw3dll.lib放入...MSVC\14.27.29110\lib的x64和x86文件夹中
（3）安装FreeGLUT。 连接：freeglut Windows Development Libraries FreeGLUT和GLUT功能基本相同，处理窗口、鼠标等事件，但GLUT已不再维护。
三个子文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaf7001067ae6b2eda49a996c4878c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fee03d28abb63fce79ee11f68072360/" rel="bookmark">
			TextView内容过多，超过n行显示“...全文”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TextView内容过多，超过n行显示“...全文”，“查看全文”等 一、需求图片二、上代码三、其他需求 一、需求图片 内容超过两行时，在末尾显示“… 全文”
二、上代码 /** * TextView超过两行，末尾显示"...全文" * 为避免抖动，需在xml中设置TextView的maxHeight * @param maxLine 最多几行 * @param strNum 末尾显示字符数 * @param str 末尾显示字符 */ open fun setOnGlobalLayout( it: TextView, maxLine: Int = 2, strNum: Int = 3, str: String = "...&lt;font color='#212126'&gt; 全文&lt;/font&gt;" ) { val observer = it.viewTreeObserver observer.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener { override fun onGlobalLayout() { if (it.width &gt; 0 &amp;&amp; it.height &gt; 0) { it.visibility = View.VISIBLE if (observer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fee03d28abb63fce79ee11f68072360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96dac107de0b3f24bda49f1ac1095d8c/" rel="bookmark">
			常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构) 数据结构和算法作为程序员的基本功，一定得稳扎稳打的学习，我们常见的框架底层就是各类数据结构，例如跳表之于redis、B+树之于mysql、倒排索引之于ES，熟悉了底层数据结构，对框架有了更深层次的理解，在后续程序设计过程中就更能得心应手。掌握常见数据结构和算法的重要性显而易见，本文主要讲解了几种常见的数据结构及基础的排序和查找算法，最后对高频算法笔试面试题做了总结。本文会持续补充，希望对大家日常学习或找工作有所帮忙。
文章目录 常见数据结构和算法实现(排序/查找/数组/链表/栈/队列/树/递归/海量数据处理/图/位图/Java版数据结构)1、什么是数据结构？(研究应用程序中数据之间逻辑关系、存储方式及其操作的学问就是数据结构)2、为什么学习数据结构和算法？3、有哪些常见的数据结构？4、说一下几种常见的排序算法和分别的复杂度，java提供的默认排序算法(数组排序)4.1、排序算法4.2、排序工具类Arrays？如何实现一个通用的、高性能的排序函数？(Java语言采用==堆排序==实现排序函数，C语言使用快速排序实现排序函数)4.3、常见的查找算法？4.4、复杂度分析4.5、如何高效地判断无序数组中是否包含某特定值？4.6、查找算法实战？4.7、哪些数据结构有序？ 纳尼，好奇怪的问题 5、数组部分面试题6、链表部分面试题6.1、单链表：next指针 (尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表上最后一个结点)6.2、描述一下链式存储结构6.3、倒排一个LinkedList（即链表的反转）6.4、判断一个单链表中是否有环？ 阿里 LeetCode1416.5、判定给定的链表是否已NULL结束，如果链表中存在环，返回环的长度？6.6、快慢指针能解决的问题？ 阿里6.7、实现两个有序的链表合并为一个有序链表(双重遍历) LeetCode23 合并k个排序链表6.8、在有序链表中插入一个结点6.9、求两个单向链表的合并点，合并后成为一个单向链表。假设链表list1和链表list2在相交前的节点数量分别为n和m，n/m大小不确定，求两个链表的合并点。6.10、如何判断一个字符串(链表)是否是回文字符串的问题(字符串是通过单链表来存储)(上海自来水来自海上)6.11、O(1)时间内删除单链表中某一个节点6.12、如何逐对逆置链表？初始1-&gt;2-&gt;3-&gt;4-&gt;X,逐对转置后，为2-&gt;1-&gt;4-&gt;3-&gt;X。6.13、约瑟夫环(N个人想选出一个领头人，他们排成一个环，沿着环每数到第M个人就排除该人，并从下一个人开始重新数，求最后留在环中的人) 7、栈(一种特殊的线性表，只能固定在一端进行插入、删除操作 可分为顺序栈结构和链式栈结构)7.1、栈的特性7.2、栈的使用场景 美团 8、队列部分知识点(关键点：确定队空/队满的判定条件)8.1、具有某种特性的队列：循环队列、阻塞队列、并发队列(在片底层的系统、框架、中间件开发中，起着重要的作用，如高性能队列Disruptor、Linux环形缓存，用到了循环并发队列8.2、队列使用场景 美团8.3、高性能队列Disruptor(内存消息队列) kafka8.4、写一个生产者-消费者队列 政采云问到了 ***非常好的题目 通过arrayblockingqueue的put/take+callable实现，详见后面的阻塞队列 9、递归方法10、散列表相关知识点(HashMap/LinkedHashMap)10.1、什么是hash算法，他们用于什么？10.2、hash函数是怎么实现的？10.3、hash冲突解决方案：(开放定址法/链表法)10.4、面试题 11、字符串处理算法总结：11.1、用Java写一个递归遍历目录下面的所有文件11.2、给定一个txt文件，如何得到某字符串出现的次数11.3、实现一个字符集，只包含a～z这26个英文字母的Trie树（也称为字典树/键树）11.4、实现朴素的字符串匹配算法(暴力匹配算法/BF算法) 12、树部分面试题12.1、如何遍历一棵二叉树？12.2、二叉查找树(二叉搜索树)(Mysql索引的底层)12.3、红黑树的应用场景(TreeMap 红黑树：一种近似平衡的二叉查找树：二叉树中任意一个节点的左右子树的高度相差不能大于1。包括完全二叉树、满二叉树) 红黑树一定得掌握12.4、数据结构 堆12.5、AC自动机：如何用多模式串匹配实现敏感词过滤功能？(使用Trie树)12.6 B树和B+树的区别(为什么 MongoDB 索引选择B树，而 Mysql 选择B+树)? 13、海量数据的处理思路问题13.1、大数据量的问题：13.2、有10G大小的文件，每行记录一条运单信息，机器大小是500M，求出出现次数最多的前1000条运单号，给出思路。13.3、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？13.4、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。13.5、怎么在海量数据中找出重复次数最多的一个？13.6、如果你所在的省有50万考生，如何通过成绩快速排序得出名次呢？13.7、假设我们有10万个手机号码，希望将这10万个手机号码从小到大排序，你有什么比较快速的排序方法呢？13.8、假设我们有1000万个整型数据，每个数据占8个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这1000万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过100MB，你会怎么做呢？13.9、如何在海量数据中快速查找某个数据？(索引)(在计算机组成中称为寻址)13.10、并行计算：利用并行处理提高算法的执行效率(分治的思想) 14、图的应用14.1、如何存储微博、微信等社交网络中的好友关系？14.2、如何在内存中存储图这种数据结构？14.3、图的其他领域应用？14.4、如何找出社交网络中的三度好友关系？(深度优先和广度优先搜索算法)(存储使用邻接表)(无向图)14.5、如何确定代码源文件的编译依赖关系？(拓扑排序 有向无环图)14.6、最短路径算法 (Dijkstra/A*)14.7、A*搜索算法(实现游戏中的寻路功能) 15、位图(bitmap)与推荐算法15.1、什么是布隆过滤器，其实现原理是？（java.util的BitSet类，实现类位图） False positive指的是？（蚂蚁问到）15.2、概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？15.3、推荐系统 16、断点续传思路和算法 1、什么是数据结构？(研究应用程序中数据之间逻辑关系、存储方式及其操作的学问就是数据结构) 程序中数据大致有四种基本逻辑结构：集合(同属一个集合)/线性关系(一对一)/树形结构(一对多)/图状结构或网状结构(多对多)物理存储结构：顺序存储结构/非顺序结构(链式存储/散列结构)算法的设计取决于逻辑结构；算法的实现依赖于存储结构 2、为什么学习数据结构和算法？ 有3点比较重要 (王争)
1、直接好处是能够有写出性能更优的代码；数据结构：存储；算法：计算； 算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算。 2、算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面；3、长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。 推荐的书籍及教程
《大话数据结构 程杰》入门
《算法图解》
《数据结构与算法分析：Java语言描述》(大学课本 伪代码)
《剑指offer》 使用的C++语言来实现的，现在我不怎么使用了
《程序员代码面试指南:IT名企算法与数据结构题目最优解》左程云，现在正在看的书
《编程珠玑》(对大数据量处理的算法)
《编程之美》(超级难)
《算法导论》(很厚很无聊)
《算法第四版》(推荐 本书没有动态规划)
《数据结构与算法 极客时间》 王争google
《算法帝国》
《数学之美》
《算法之美》(闲暇阅读) https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96dac107de0b3f24bda49f1ac1095d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0fbaa01a68575b9c769ca0487db2567/" rel="bookmark">
			GL3510创维一路进四路出HUB芯片方案，扩展坞方案，资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创维的GL3510是一款与VL817相同的一出四HUB芯片
Genesys GL3510 is a 4-port, low-power, and configurable hub controller. It is compliant with the USB 3.1
specification. GL3510 integrates Genesys Logic self-developed USB 3.1 Gen 1 Super Speed transmitter/receiver
physical layer (PHY) and USB 2.0 High-Speed PHY. It supports Super Speed, Hi-Speed, and Full-Speed USB
connections and is fully backward compatible to all USB 2.0 and USB 1.1 hosts. GL3510 has built-in 5V to
3.3V and 5V to 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0fbaa01a68575b9c769ca0487db2567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a2bb393285a0bf6f05119d16d36dbd/" rel="bookmark">
			USB转8串芯片CH348 Windows系统使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows系统上使用USB转8串口芯片CH348时，需要安装厂商提供的虚拟串口驱动，驱动安装完成后，将USB插入主机会在设备管理器生成8个不同的COM口。芯片各串口独立工作，互不影响。用户可通过COM口前面的名称区分各物理串口，后缀A~H依次对应芯片物理串口UART0~UART7，如下所示：
安装流程： 1、将CH348设备的USB连接主机，未安装驱动时设备管理器状态：
注：若USB连接主机后设备管理器未能成功出现如上设备信息，一般需要检查CH348的硬件设计。
2、下载官网Windows串口驱动并安装：USBMSER.exe - 南京沁恒微电子股份有限公司 3、安装成功的提示如下：
推荐资料链接： 技术手册链接：CH348DS1.PDF - 南京沁恒微电子股份有限公司
参考设计：CH348EVT.ZIP - 南京沁恒微电子股份有限公司
Windows串口驱动链接：USBMSER.exe - 南京沁恒微电子股份有限公司
Linux串口驱动链接：CH9344SER_LINUX.ZIP - 南京沁恒微电子股份有限公司
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0627fa8aa365f7f58e8b5fa9ae2638/" rel="bookmark">
			JavaScript监听按键，禁止F12，禁止右键，禁止保存网页【Ctrl&#43;s】等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		禁止右键 document.oncontextmenu = new Function("event.returnValue=false;") //禁用右键 禁止按键 其他键码：键盘键码keyCode对照表
// 监听按键 document.onkeydown = function () { // f12 if (window.event &amp;&amp; window.event.keyCode == 123) { alert("F12被禁用"); event.keyCode = 0; event.returnValue = false; } // ctrl+shift+i if (window.event.ctrlKey &amp;&amp; window.event.shiftKey &amp;&amp; window.event.keyCode == 73) { alert("ctrl+shift+i被禁用"); event.keyCode = 0; event.returnValue = false; } // ctrl+s if (window.event.ctrlKey &amp;&amp; window.event.keyCode == 83) { alert("ctrl+s被禁用"); event.keyCode = 0; event.returnValue = false; } } 禁止先打开控制台然后强行进入 function a() { // 这里我做的是跳转首页，可以根据实际需要进行其他限制 var domain = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb0627fa8aa365f7f58e8b5fa9ae2638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffd49d8d1ad0d6a51f5d54d361d3cf5c/" rel="bookmark">
			键盘键码keyCode对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字母和数字键的键码值（keyCode）按键键码按键键码按键键码按键键码A65J74S83149B66K75T84250C67L76U85351D68M77V86452E69N78W87553F70O79X88654G71P80Y89755H72Q81Z90856I73R82048957 数字键盘上的各键键码值（keyCode）功能键键码值（keyCode）按键键码按键键码按键键码按键键码0968104F1112F91201979105F2113F10121298*106F3114F11122399+107F4115F121234100Enter108F5116 5101-109F6117 6102.110F7118 7103/111F8119 控制键键码值（keyCode）按键键码按键键码按键键码按键键码BackSpace8Esc27Right Arrow39-_189Tab9Spacebar32Dw Arrow40.&gt;190Clear12Page Up33Insert45/?191Enter13Page Down34Delete46`~192Shift16End35Num Lock144[{ 219Control17Home36;:186\|220Alt18Left Arrow37=+187]}221Cape Lock20Up Arrow38,&lt;188'"222 多媒体键码值（keyCode）按键键码按键键码音量加175浏览器172音量减174邮件180停止179搜索170静音173收藏171 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef72dc397e5402b32d4a23d6eb2d2f8/" rel="bookmark">
			入门必备案例——用Python实现九九乘法表的几种方式，超级简单~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在学习Python的过程中需要不断的积累和练习，这样才能够走的更远，今天一起来学习怎么用Python写九九乘法表~
第一种方法、for-for
代码：
for i in range(1, 10): for j in range(1, i+1): print(f'{j}x{i}={i*j}\t', end='') print() 效果展示
第二种方法、while-while
代码
i = 1 while i &lt;= 9: j = 1 while(j &lt;= i): # j的大小是由i来控制的 print(f'{i}*{j}={i*j}', end='\t') j += 1 print('') i += 1 效果展示
第三种方法、while-for
代码
i = 1 while i &lt;= 9: for j in range(1, i+1): # range()函数左闭右开 print(f'{i}*{j}={i*j}', end=' ') i += 1 print() 效果展示
第四种方法、for-while
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ef72dc397e5402b32d4a23d6eb2d2f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8dbbe27defba8c299006e85f7e6367/" rel="bookmark">
			postman参数化导入csv文件中文乱码解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在接口测试中，往往需要参数化导入文件进行批量测试，但是经常遇到csv文件中的中文字符导入到postman中会显示乱码的问题，可用以下方式解决该问题：
1、把csv文件在notepad++中打开；
2、设置文件的编码格式：选择转为utf-8编码
3、保存文档，再次导入即可
注意：保存文件时保证csv文件没有在Excel中打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0274db9c94780bf80ac9c30f9084a7ed/" rel="bookmark">
			CommonJS模块与ES6模块及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS模块和ES6模块 在ES6之前，js本没有模块体系之说，最主要使用的是CommonJS和AMD两种。前者用于服务器，后者用于浏览器，ES6后在语言标准的层面上实现了模块功能，使用简单，称为浏览器和服务器通用的模块解决方案。
CommonJS模块化规范 Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖，规定每个模块内部，规定 module 变量代表当前模块，module 变量是一个对象，它的 exports 属性（即 module.exports ）是对外的接口，加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。
let { start , exist , readFile } = require('fs'); //也等同于 let fs1 = require('fs'); let start = fs1.start; let exist = fs1.exist; let readFile = fs1.readFile; ES6模块 ES6中提供了模块的概念，我们可以向使用模块引用的方式引用模块
import { start, exists, readFile } from 'fs' 首先建一个文件 index.js 定义变量并暴露出去
let num = 10 ; let obj = {} ; let arr = [] ; let func = functiom(){}; export { num , obj , arr , func }; 然后想要在另一个文件接收这个变量就需要引入 import命令加载这个模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0274db9c94780bf80ac9c30f9084a7ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8b7dd7343f9fb8996805088f5e09cb/" rel="bookmark">
			解决报错FileNotFoundError: Could not find module.... Try using the full path with constructor syntax.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileNotFoundError: Could not find module ‘D:\anaconda\envs\pybullet-stb3\lib\site-packages\atari_py\ale_interface\ale_c.dll’ (or one of its dependencies). Try using the full path with constructor syntax.
今天在debug的时候发现自己用的gym库的版本是0.19.0但是发现项目的requirement的版本是0.21.0，于是pip uninstall gym，然后pip install gym==0.21.0。后面又改变了一些库的版本，然后运行出现上面的报错。之后，在stackoverflow上看到一些方案，出现这个报错就是因为gym版本的变动，因为 gym 0.21.0 支持 ale-py 并且不再使用 atari-py，所以导致了冲突。之后重新安回gym的0.19.0版本错误解除。
stackoverflow上也提供了几种解决方案：
https://stackoverflow.com/questions/63080326/could-not-find-module-atari-py-ale-interface-ale-c-dll-or-one-of-its-dependenc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8b50a0356abe753b4a9a7aff425276/" rel="bookmark">
			MobaXterm创建虚拟环境以及在虚拟环境中对pytorch的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conda创建python3.6的虚拟环境 创建虚拟环境不会让pytorch环境和其他环境冲突，因此，强烈建议创建虚拟环境
a、创建虚拟环境 输入命令：-n后边的py36是虚拟环境名，你可以修改；python是3.6版本的，如果你的anaconda安装的是3.7版本的就改成3.7
conda create -n py36 python=3.6 还可以在创建虚拟环境的时候，加上自己会用到的基本的包：
conda create -n py36 python=3.6 pandas numpy matplotlib 创建成功后的结果如下：
b、激活与退出虚拟环境py36 激活虚拟环境：source activate py36
退出虚拟环境：source deactivate
c、删除虚拟环境 方法1： conda remove -n ‘your_name’ --all 方法2：
直接删除虚拟环境所在目录 https://blog.csdn.net/kefnbsow/article/details/107003302
安装pytorch a、进入虚拟环境py36 b、版本查看 查看cuda版本：cat /usr/local/cuda/version.txt或nvcc -V
查看cudnn版本：cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A
去官网找到适合的版本用conda安装
c、设置镜像 因为Anaconda.org的服务器在国外，使用国外的服务器的时候，速度会很慢并且经常失败，其中出现”CondaHTTPError: HTTP None None for url……”这类错误时。因此，我们可以用清华TUNA镜像源或者包含Anaconda仓库的镜像，将其加入conda的配置。
第一步、添加清华镜像站到Anaconda： conda config --add channels http://mirror.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirror.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 其中 conda config --set show_channel_urls yes：表示设置搜索时显示通道地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db8b50a0356abe753b4a9a7aff425276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1098ca6befed1ae234b0099e64d3fc93/" rel="bookmark">
			【Vue】通过文本输入的字数限制button的disabled可用状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		界面如图：通过在文本框里输入，获取输入的长度来判断button是否可用
&lt;div id="app"&gt; &lt;textarea v-model="message" v-focus @keyup="TextLeng"&gt;&lt;/textarea&gt;&lt;/br&gt; &lt;label style="color:dimgrey"&gt;当前字数：&lt;span&gt;{{mesleng}}&lt;/span&gt;&lt;/label&gt;&lt;/br&gt; &lt;button type="button" @click="Clk" v-bind:disabled="dis"&gt;提交&lt;/button&gt; &lt;/div&gt; @keyup事件每输入一个字符触发一次，而change是当文本框的onbulr触发后触发，效果不是很好，所以这边用keyup，具体代码如下
&lt;script&gt; /* 获得焦点 */ Vue.directive('focus', { inserted: function(el) { el.focus(); } }); var vue = new Vue({ el: "#app", data: { message: "", mesleng: "",	/*获取长度*/ dis: false	/*控制button可用状态，true为不可用*/ }, methods: { TextLeng: function() { var leng = this.message.length; this.mesleng = leng; if (leng &gt; 50) { this.dis = true; } else { this.dis = false; } }, Clk: function() { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1098ca6befed1ae234b0099e64d3fc93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9badf672517d2c61c713b89d00a3e48/" rel="bookmark">
			AcWing每日一题----社交距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、社交距离Ⅰ 原题链接：https://www.acwing.com/problem/content/1661/
一种新型疾病，COWVID-19，开始在全世界的奶牛之间传播。
Farmer John 正在采取尽可能多的预防措施来防止他的牛群被感染。
Farmer John 的牛棚是一个狭长的建筑物，有一排共 N 个牛栏。
有些牛栏里目前有奶牛，有些目前空着。得知“社交距离”的重要性，Farmer John 希望使得 D 尽可能大，其中 D 为最近的两个有奶牛的牛栏的距离。
例如，如果牛栏 3 和 8 是最近的有奶牛的牛栏，那么 D=5。
最近两头奶牛新来到 Farmer John 的牛群，他需要决定将她们分配到哪两个之前空着的牛栏。
请求出他如何放置这两头新来的奶牛，使得 D 仍然尽可能大。
Farmer John 不能移动任何已有的奶牛；他只想要给新来的奶牛分配牛栏。
输入格式
输入的第一行包含 N。
下一行包含一个长为 N 的字符串，由 0 和 1 组成，描述牛棚里的牛栏。
0 表示空着的牛栏，1 表示有奶牛的牛栏。
字符串中包含至少两个 0，所以有足够的空间安置两头新来的奶牛。
输出格式
输出 Farmer John 以最优方案在加入两头新来的奶牛后可以达到的最大 D 值（最近的有奶牛的牛栏之间的距离）。
数据范围
2≤N≤105
输入样例：
14 10001001000010
输出样例：
2
样例解释
在这个例子中，Farmer John可以以这样的方式加入奶牛，使得牛栏分配变为 10x010010x0010，其中 x 表示新来的奶牛。此时 D=2。不可能在加入奶牛之后取到更大的 D 值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9badf672517d2c61c713b89d00a3e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bf5aaa6d4090d93464d48223e76ff5/" rel="bookmark">
			JPA &amp; H2内存数据库 demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于SpringBoot工程，引用的依赖包有thymeleaf、springmvc、jpa、h2、mysql，考虑篇幅，有些代码省略。
1、使用JPA需继承CrudRepository接口 继承CrudRepository接口的好处是不用写sql语句。
创建com.zzz.ssjpa.repository.UserRepository.java接口（repository层相当于dao层），代码如下：
public interface UserRepository extends CrudRepository&lt;User, Long&gt;{ } com.zzz.ssjpa.controller.UserController.java添加测试代码如下：
/** * @Title: register * @Description: * 注册页面的表单提交user数据到这里, * 调用repository的save方法存储数据到h2内存数据库中 * @param: @param user * @param: @return 参数 * @return: ModelAndView 返回类型 * @throws */ @RequestMapping("/user/register.action") public ModelAndView register(User user) { System.out.println(user); //System.out.println("register已经运行"); userRepository.save(user);//并没有具体实现，因为遵循了JPA return new ModelAndView("redirect:/index.action"); } 2、配置h2控制台 application.properties内容如下：
#thymeleaf编码 spring.thymeleaf.encoding=UTF-8 #热部署静态文件 spring.thymeleaf.cache=false #使用HTML5标准 spring.thymeleaf.mode=HTML5 #使用h2控制台显示，在项目网址后加/h2-console回车后在浏览器中显示 spring.h2.console.enabled=true 3、运行测试 在注册表单中提交user数据后，查看h2数据库，在浏览器中输入网址http://localhost:8080/h2-console：
需要h2的jdbc地址才可以登录，在eclipse控制台中找到jdbc地址，复制粘贴上去，就可以connect了：
查询提交并存储的user数据：
看到数据就成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8d268d98a535861c2b6271bdc99caa/" rel="bookmark">
			babel-plugin-import：babel.config.js 按需引入插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		babel-plugin-import 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。
babel.config.js
module.exports = { presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ ['import', { libraryName: 'vant', libraryDirectory: 'es', style: true }, 'vant'] ] } presets：预置
plugins：插件
libraryName：库名
libraryDirectory：库目录
es：
之前：看来bable-plugin-import这几天有更新，现在配置项 libraryDirectory 的默认值时 lib，即使用通过 require (commonjs) 引用模块的文件。而先前我在配置的时候并没有默认值，如果没有显示配置 libraryDirectory，打包结果会出现重复的内容。
采用了 es6 module 的项目建议配置 libraryDirectory 为 es，即使用通过 import (es6 module) 引用模块的文件。这种情况打包后的体积要更小一些。
按需引入插件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302a0704a341b6821069c530c1430c92/" rel="bookmark">
			【python】conda配置python项目环境（Conda常用命令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conda配置python项目环境 1.Conda安装1.1 Conda安装1.2 指定镜像源1.2.1 添加清华源1.2.2 添加中科大源1.2.3 Linux下 2.Conda常用命令2.1 环境相关操作2.2 操作环境中的包2.3 tensorflow相关 3.运行已有python项目3.1 txt环境文件3.2 yml环境文件 并不是所有现成项目都会在README.MD上手把手教你运行的步骤，而且很多时候，就算把要求的包都安装了一样运行失败。 1.Conda安装 你需要一个用于管理python环境的工具，它就是conda，安装了可跳过。
1.1 Conda安装 # Conda installation # For Linux curl -o ~/miniconda.sh -O https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh # For OSX curl -o ~/miniconda.sh -O https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh chmod +x ~/miniconda.sh ./miniconda.sh source ~/.bashrc # For Linux source ~/.bash_profile # For OSX Windows还用什么命令行，直接搜索conda安装
1.2 指定镜像源 建议如果下载速度真的很慢再指定源
1.2.1 添加清华源 命令行中直接使用以下命令
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302a0704a341b6821069c530c1430c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecbe647898f44f6b4d688f5e2c862e8/" rel="bookmark">
			[C语言] [游戏] 三子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏简介&gt;&gt;&gt; 三子棋的游戏如下图，游戏规则是 两个玩家分别在 3x3 的棋盘上下棋，只要有一个玩家下的3个棋子先连成一条了直线，那么他就获胜。如果棋盘满了还没有分出胜负那么就定为平局。
接下来我们使用C语言写一个玩家与电脑PK的三子棋游戏。
注意： 我们在写一些重要的代码时，最好把自定义函数的声明、定义以及整个程序的实现，分别放在不同的文件里面。这样写不仅会让你的逻辑更清晰、更容易调试代码还便于后续对整个代码的保密操作。
关于三子棋代码，我按照上文分为 game.h \ game.c \ test.c 三个文件，分别写自定义函数的声明、定义以及整个程序的实现。然后记得一边写一边测试，这样有错误的话改起来不费力。
三子棋代码的实现思路&gt;&gt;&gt; 先来分析一下三子棋游戏的组成成分和动作：游戏开始和结束的提示、棋盘、两种棋子、玩家下棋、判断输赢和电脑下棋。
游戏开始和结束的提示&gt;&gt;&gt; 游戏的第一步一般都是让玩家选择“开始游戏”或者“退出游戏”，因为有人可能只是手滑而点进了这个游戏。还得注意为了方便以后写代码不繁琐且逻辑清晰，我们尽量都自定义函数来实现这些需要重复的操作，包括接下来的各种功能。 所以这里需要写一个函数 menu 让玩家选择是否开始游戏。
//像这样自定义一个功能单一的函数menu只负责打印选项单 void menu() { printf("********************\n"); printf("****** 1.play ******\n"); printf("****** 0.exit ******\n"); printf("********************\n"); } //当玩家选择1后开始游戏，进入 game函数 void test() { int a = 0; do { menu(); scanf("%d", &amp;a); if (1 == a) { game(); break; } else { printf("输入错误，请重新输入：\n"); } } while (a); printf("退出游戏。\n"); } //当玩家不想玩后选择0，即结束游戏 这里使用 do while 循环是因为一开始就先要让玩家判断是否开始游戏，如果玩家输入错误需要重新输入（先执行一次，后判断是否循环），所以输入这个操作也要放在循环里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cecbe647898f44f6b4d688f5e2c862e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b01e4b4d724a4ab24f6e0126e24a023/" rel="bookmark">
			Android Studio patch使用 git patch使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先：是androidStudio导出patch文件。
第一步，在androidStudio的底部git提交记录里找到需要导出patch的那条提交记录。右键--选择createPatch这一项。t
第二步，点击 “Crate Patch" 弹框，选择保存.patch文件的路径和 输入文件名或者使用默认文件名。
使用androidStudio导入patch文件到工程中，
第一：在andrdoid最上面工具栏中，”GIT“ ---&gt; patch ----&gt; apply patch。下一步会弹框出来文件夹目录。
第二步：从弹框出来的文件夹目录中选择要导入的patch文件，从文件夹按钮可以切换其它的patch文件，选择好patch文件后点击右下角确定按钮。
到此全部完成了androidstudio git patch文件的导出和导入工作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd63eefcb99b96193a51f70344df2e2/" rel="bookmark">
			postman和apifox如何参数化断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman接口测试参数化： 1、准备接口信息：
2、接口传参参数化：
3、断言参数化：
断言内容写为data.变量名的形式，具体断言脚本根据需要写即可，我的例子因为返回值不是json格式，所以需要转换一下，这个变量名，与之后测试用例文档中的变量保持一致。
4、测试用例文档
需要注意，postman支持csv文件和txt文件，每一行代表一组数据，变量名需与数据对应上，同一行数据之间，用英文逗号分开，若文档中有中文，需要保存为utf-8格式。
5、执行测试用例
（1）批量执行用例步骤：
（2）执行用例结果，根据断言判断用例pass或fail，因为我只执行了两条用例，一条为预计成功，一条为预计失败，可以看出这是我需要的结果
apifox接口测试参数化： 1、维护接口信息且参数化变量：
此步骤与postman基本一致，不再赘述
2、添加后置操作-断言：
断言处断言内容的变量方式与postman不一致，这是与postman最大的不同
3、准备测试数据：
与postman一样，注意变量名对应上，也是支持csv或txt文件。
4、执行测试用例：
（1）自动化测试处，添加该测试用例；
（2）导入准备好的测试文件数据；
（3）执行测试用例，注意，要启用测试数据；
（4）查看执行结果。
总结： Postman和apifox对接口批量自动化测试的逻辑和操作基本一致，都是将变量参数化，断言内容也可以和入参一样参数化，只是参数化的形式稍有不同：入参参数化都是{{变量名}}，但是断言参数化不同，postman形式为：data.变量名或data[变量名]；apifox形式为：{{变量名}}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bebfa7e856a815ea82b325959b1308/" rel="bookmark">
			浪漫星空python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码如下：
from turtle import* from random import* def star(): speed(1000) pencolor('#B7C5D2') fillcolor('#B7C5D2') begin_fill() n=randint(3,10) for i in range(5): fd(n) rt(144) end_fill() def move(x,y): pu() goto(x,y) pd() def starry_sky(): setup(800,400) hideturtle() bgpic('xingkong.gif') for i in range(100): starx=randint(-400,400) stary=randint(-200,200) move(starx,stary) star() starry_sky() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13c4027424635a5e7a88086dcca3284/" rel="bookmark">
			vue3封装table组件 element Plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="scTable" ref="scTableMain" :style="{ height: theight }" v-loading="loading"&gt; &lt;div :class="!hideDo ? 'scTable-table' : 'scTable-table-noPag'"&gt; &lt;el-table v-bind="$attrs" :data="tableData" :row-key="rowKey" :key="toggleIndex" ref="scTable" height="100%" @sort-change="sortChange" @filter-change="filterChange" &gt; &lt;slot&gt;&lt;/slot&gt; &lt;template v-for="(item, index) in userColumn" :key="index"&gt; &lt;el-table-column v-if="!item.hide" :column-key="item.prop" :label="item.label" :prop="item.prop" :width="item.width" :sortable="item.sortable" :fixed="item.fixed" :filters="item.filters" :filter-method="remoteFilter || !item.filters ? null : filterHandler" &gt; &lt;template #default="scope"&gt; &lt;slot :name="item.prop" v-bind="scope"&gt; {{ scope.row[item.prop] }} &lt;/slot&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/template&gt; &lt;el-table-column min-width="1"&gt;&lt;/el-table-column&gt; &lt;template #empty&gt; &lt;el-empty :description="emptyText" :image-size="80"&gt;&lt;/el-empty&gt; &lt;/template&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13c4027424635a5e7a88086dcca3284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab98d859e2f07f112b4ba1e0cbcab8db/" rel="bookmark">
			趋势线公式公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据数据求：指数函数和R平方根
1、选择单元格区域，插入散点图，并完成对图表的基本设置，如添加图表标题、设置坐标轴格式等操作，最终完成散点图如图1所示。
2、选中散点图图表，为该散点图添加指数趋势线，趋势线添加结果如图所示。
3、双击插入的趋势线，完成趋势线格式设置，本例中需向前预测两月的销量，固在“趋势预测”选项区中“向前”文本框中输入2，选中“显示公式”和“显示R平方值”复选框，结果显示如图3所示。
4、预测值在EXCEL中计算公式：
输入公式=194*EXP(0.1595*11)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ae34c0b302a16b64dc0d531fc42670/" rel="bookmark">
			vue-element-admin 遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git配置淘宝镜像源
npm config set registry https://registry.npm.taobao.org 1.‘vue-cli-service’ 不是内部或外部命令，也不是可运行的程序 npm install -g @vue/cli-service 2.Host key verification failed. ssh-keygen -R 你要访问的IP地址 3. git访问github.com的资源时 “Please make sure you have the correct access rights and the repository exists.” 重新配置你的ssh
配置完后执行
ssh -T git@github.com 输入yes
4.The unauthenticated git protocol on port 9418 is no longer supported git config --global url."https://".insteadOf. git:// 然后执行
npm install 5.OpenSSL SSL_read: Connection was aborted, , errno 10053 git config --global http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3ae34c0b302a16b64dc0d531fc42670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92091d402c82e4d13aea84c6352982b/" rel="bookmark">
			【ButterKnife被弃用】Resource IDs will be non-final by default in Android Gradle Plugin version 8.0, avoi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://blog.csdn.net/u014653815/article/details/109216216
Resource IDs will be non-final by default in Android Gradle Plugin version 8.0, avoid using them as annotation attributes 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0968d4edfe260bde5b0c76cbcbc8436b/" rel="bookmark">
			集成学习介绍——Random Forest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机森林是一个非常直观，理解起来也比较容易的Bagging算法。前面我们介绍过决策树，其最大的一个缺点就是容易过拟合。随机森林则是由若干决策树组成的模型，其思想就是“三个臭皮匠顶个诸葛亮”。比如下图，就是由9个决策树组成的一个随机森林，其中6个决策树预测值为1，三个预测为0 ，所以最终预测值取多数方：1。如果是回归问题，一般取所有决策树预测结果的均值。
理解随机森林的关键点在于理解“ 相关度低甚至不相关的多个决策树组合在一起的效果好于其中任何一个决策树 ”。这里拿一个例子做论证（注：此例来自第一个参考文章），做一个游戏：使用一个均匀分布的随机数产生器产生一个数字，如果这个数字大于等于40，则算你赢，可以获得一些钱；如果小于40，则算你输，你需要给对方同样数额的钱。现在有三种玩法供选择：
玩法1（Game1）：玩100次，每次的筹码是1元。玩法2（Game2）：玩10次，每次筹码是10元。玩法3（Game3）：玩1次，筹码是100. 你会怎么选哪一个？我们计算一下赢钱的期望值：
$E_1 = (0.6*1+0.4*(-1))*100=20$$E_2=(0.6*10+0.4*(-10))*100=20$$E_3=(0.6*100+0.4*(-100))=20$ 三种选择赢钱的期望值是一样的，那到底该如何选？我们做一个模拟：每种情况都模拟10000次，代码如下：
import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set_theme() # Game 1 simulations = 10000 # number of Monte Carlo Simulations games = 100 # number of times the game is played threshold = 40 # threshold where if greater than or equal to you win bet = 1 # dollar bet for the game # outer loop is Monte Carlo sims and inner loop is games played sim_results_1 = [] for sim in range(simulations): result = [] for g in range(games): number = int(np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0968d4edfe260bde5b0c76cbcbc8436b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cbbd78fb3936b9338070dcbeeeb1b61/" rel="bookmark">
			net1. Reactor关键结构——EventLoop事件循环类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		muduo的简化类图
时序图：
EventLoop类
EventLoop事件循环类，是对事件循环的抽象。one loop per thread意思是说每个线程最多只能有一个EventLoop对象。EventLoop对象构造的时候，会检查当前线程是否已经创建了其他EventLoop对象，如果已创建，终止程序（LOG_FATAL）。EventLoop构造函数会记住本对象所属线程（threadId_）。创建了EventLoop对象的线程称为IO线程，其功能是通过EventLoop::loop()运行事件循环(while循环)。一个EventLoop可以有多个Channel和FileDescriptor。EventLoop::loop()主要有四个作用，按顺序处理定时器事件，IO多路复用检测，处理检测返回的活动通道事件，处理自己的额外消息事件 数据成员：
当前是否处于循环状态即是否在loop()函数中
bool looping_：当前是否处于循环状态即是否在loop()函数中 atomic
bool quit_：当前是否退出循环状态即是否退出loop()函数 atomic
bool eventHandling_：当前是否处于事件处理的状态 atomic
bool callingPendingFunctors_：当前是否处于调用pending函数的状态atomic
const pid_t threadId_：当前对象所属线程ID
Timestamp pollReturnTime_：调用poll()函数时所返回的时间戳
boost::scoped_ptr&lt;Poller&gt; poller_：一个用于I/O复用的Poller对象poller_，调用智能指针，Poller的生存期由EventLoop()来控制
boost::scoped_ptr&lt;TimerQueue&gt; timerQueue_：指向TimerQueue的timerQueue_
int wakeupFd_：用于eventfd所创建的文件描述符，线程间事件通知
boost::scoped_ptr&lt;Channel&gt; wakeupChannel_：wakeupFd_所对应的通道，该通道将会纳入poller_来管理
ChannelList activeChannels_：Poller返回的活动通道列表activeChannels_ Channel* currentActiveChannel_：当前正在处理的活动通道
MutexLock mutex_：互斥量mutex_
std::vector pendingFunctors_：该IO线程的任务队列，pending函数集合pendingFunctors_
typedef
typedef std::vector&lt;Channel*&gt; ChannelList
成员函数：
EventLoop()：构造函数，调用Poller::newDefaultPoller(this)初始化poller_对象
~EventLoop()：析构函数
void loop()：事件循环函数loop()该函数不能跨线程调用,只能在创建该对象的线程中调用
void quit()：事件循环终止函数quit()，可以跨线程调用
Timestamp pollReturnTime() const ：返回时间戳pollReturnTime_
void runInLoop(const Functor&amp; cb)：runInLoop()在I/O线程中执行某个回调函数，该函数可以跨线程调用，loop对象在其他线程中异步调用runInThread，则会调用queueInLoop将cb添加到该loop对象所属的IO线程
void queueInLoop(const Functor&amp; cb)：当调用者并非当前EventLoop所在线程时，将Functor存入EventLoop的任务队列
从而保证Functor由IO线程执行，这是线程安全的保证之一
TimerId runAt(const Timestamp&amp; time, const TimerCallback&amp; cb)：在某个时刻运行定时器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cbbd78fb3936b9338070dcbeeeb1b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb26406a5bcd3773e2fb0b2ecb928813/" rel="bookmark">
			ElasticSearch概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
ElasticSearch概述 一、ElasticSearch是什么？二、ElasticSearch对⽐Solr三、ElasticSearch相关概念(术语)索引 index类型 type字段Field映射 mapping文档 document集群 cluster节点 node 一、ElasticSearch是什么？ Elaticsearch，简称为es， es是⼀个开源的⾼扩展的分布式全⽂检索引擎，它可以近乎实时的存储、检索数据；本⾝扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使⽤Java开发并使⽤Lucene作为其核⼼来实现所有索引和搜索的功能，但是它的⽬的是通过简单的RESTful API来隐藏
Lucene的复杂性，从⽽让全⽂搜索变得简单。
二、ElasticSearch对⽐Solr Solr 利⽤ Zookeeper 进⾏分布式管理，⽽ Elasticsearch ⾃⾝带有分布式协调管理功能;Solr ⽀持更多格式的数据，⽽ Elasticsearch 仅⽀持json⽂件格式；Solr 官⽅提供的功能更多，⽽ Elasticsearch 本⾝更注重于核⼼功能，⾼级功能多有第三⽅插件提供；Solr 在传统的搜索应⽤中表现好于 Elasticsearch，但在处理实时搜索应⽤时效率明显低于Elasticsearch 三、ElasticSearch相关概念(术语) Elasticsearch是⾯向⽂档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个⽂档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进⾏索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：
Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns
Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields
索引 index ⼀个索引就是⼀个拥有⼏分相似特征的⽂档的集合。比如可以有⼀个客户数据的索引，另⼀个产品⽬录的索引，还有⼀个订单数据的索引。⼀个索引由⼀个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的⽂档进⾏索引、搜索、更新和删除的时候，都要使⽤到这个名字。在⼀个集群中，可以定义任意多的索引。
类型 type 在⼀个索引中，你可以定义⼀种或多种类型。⼀个类型是你的索引的⼀个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有⼀组共同字段的⽂档定义⼀个类型。⽐如说，我们假设你运营⼀个博客平台并且将你所有的数据存储到⼀个索引中。在这个索引中，你可以为⽤户数据定义⼀个类型，为博客数据定义另⼀个类型，当然，也可以为评论数据定义另⼀个类型。
字段Field 相当于是数据表的字段，对⽂档数据根据不同属性进⾏的分类标识
映射 mapping mapping是处理数据的⽅式和规则⽅⾯做⼀些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射⾥⾯可以设置的，其它就是处理es⾥⾯数据的⼀些使⽤规则设置也叫做映射，按着最优规则处理数据对性能提⾼很⼤，因此才需要建⽴映射，并且需要思考如何建⽴映射才能对性能更好。
文档 document ⼀个⽂档是⼀个可被索引的基础信息单元。⽐如，你可以拥有某⼀个客户的⽂档，某⼀个产品的⼀个⽂档，当然，也可以拥有某个订单的⼀个⽂档。⽂档以JSON（Javascript Object Notation）格式来表⽰，⽽JSON是⼀个到处存在的互联⽹数据交互格式。在⼀个index/type⾥⾯，你可以存储任意多的⽂档。注意，尽管⼀个⽂档，物理上存在于⼀个索引之中，⽂档必须被索引/赋予⼀个索引的type。
集群 cluster ⼀个集群就是由⼀个或多个节点组织在⼀起，它们共同持有整个的数据，并⼀起提供索引和搜索功能。⼀个集群由⼀个唯⼀的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为⼀个节点只能通过指定某个集群的名字，来加⼊这个集群
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb26406a5bcd3773e2fb0b2ecb928813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7820a9fb6bb960f6457acf82d26d5ba5/" rel="bookmark">
			在Anaconda的python虚拟环境中，装spyder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先：我也是瞎jb装出来的，不知道啥意思。不明所以。有智之士 对就是这个智，如果有清晰的思路可留言。
谢谢！
如下操作，执行了n遍，装了2台机器。 都成功了，不知道为啥，时而不对时而成功。
要么spyder闪退。要么说要装kernels，要么spyder打开卡在connect的状态。
如下操作： 最后一次我的操作流程是这样的：
spyder --reset，重置spyder配置
//-- 在虚拟环境下卸干净（如果先前没装可以不用干）
conder uninstall spyder
pip uninstall spyder
//–装spyder
conder install spyder
//-- 开始执行了个这个，不知道干啥的。不知道有没有用。
conda update spyder ipykernel tornado pyzmq
//-- 安装spyder-kernels
conda install spyder-kernels
spyder 命令行发现还不对，再
pip install spyder-kernels
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple spyder-kernels
//-- 发现执行spyder缺东西啥的，又执行了一遍。
pip install spyder
//-- 最后打开spyder
spyder
安装完之后，在spyder中点击Tools–preference–python interpreter中将编译器设置为你想用的（注意这里可以是你在anaconda中建立的环境中python编译器，也可以是你自己单独下载的编译器），比如我现在想用我自己之前一直用的python3.8.5,。
选择并确认后，还需要点击consoles–Restart kernals，出现输命令行的界面就说明成功了
PS: 20220321追加
今天又开了一个虚拟环境，原来我配置好后，还是用原先的terminal开启的spyder 发现没成功， 重开terminal 开旗spyder就好了。
由于下载过慢，我用了下述下载
pip install 包名 -i http://pypi.douban.com/simple --trusted-host pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7820a9fb6bb960f6457acf82d26d5ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6956967f8583d3c31cf418d3cfe6dfa9/" rel="bookmark">
			C&#43;&#43; --- 对象指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是Joe本人的学习笔记，如果能帮助到你，那我受宠若惊！
对象指针的一般概念： 类的对象在初始化的时候会在内存中占有内存空间，既可以通过对象名，也可以通过对象地址来访问每个对象。（这时就用到了对象指针）
对象指针的声明：
语法形式：
类名*对象指针名；
Point * pointer;//声明对象指针 Point p1;//创造对象 Pointper=&amp;p1//把对象p1的地址赋给指针 用对象指针访问对象的成员：
对象指针名-&gt;成员名
指向类的非静态成员的指针、 指向对象成员的指针需要先声明、再赋值、最后引用
声明：
类型说明符 类名：：*指针名；//指向数据成员的指针
类型说明符 （类名：：*指针名）（参数表）；//指向函数成员的指针
赋值：
数据成员： 指针名 = &amp;类名：：数据成员名；
函数成员： 指针名 = &amp;类名：：函数成员名；
注意：
（关于数据成员）
由于类是通过对象而实例化的，在声明类的对象时才会为具体的对象分配内存空间。
访问数据成员时，可以通过以下两种语法实现：
对象名.*类成员指针名对象名-&gt;类成员指针名 （关于函数成员）
类的成员函数虽然并不在每个对象中复制一份副本，但是由于需要确定this指针，因而必须通过对象来调用非静态成员函数。
因此，经过上述对成员函数指针的赋值，也还不能用指针直接调用成员函数，而是需要声明类的对象，然后用以下形式利用指针调用成员函数：
（对象名.*类成员指针名）（参数表）
或
（对象指针名--&gt;*类成员指针名）（参数表）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021dbd4fa07f75b49b10aef2246593bf/" rel="bookmark">
			springboot和springcloud 和springcloud Alibaba的版本选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本说明与选择 一、boot和cloud版本1.1、SpringCloud 版本号说明1.2、大致对应关系：1.3、查下详细对应版本1.4、方法2查下 二、cloud Alibaba 适配 springcloud1.1、版本对应关系如图：1.2、阿里组件版本选择1.3、如何使用 总结 一、boot和cloud版本 1.1、SpringCloud 版本号说明 版本号版本用途BUILD-XXx开发版一般是开发团队内部使用GA稳定版内部开发到一定阶段了，各个模块集成后，经过全面测试发现没有问题，可对外发行了。这个时候叫GA(General Availability)。基本上可以使用了。PRE(M1 M2)里程碑版(a)、由于cA还不属于公开发行版，里面还有些功能不完善或者bug，于是就有了里程碑版 milestone(里程碑版)。
(b)、ilestone版主要修复了一些bug调整。
©、一个GA后，一般会有多个里程本版。例如M1 M2、M3… . …RC候选发布版(a)、从BILD后到cA在到M基本上系统就算定型了,这个时候系统就进入Release Candidate（候选发布版）。
(b)、该阶段的软件类似于最终发行前的一个现察期，该期间只对一些发现的等级高的bug进行修复。发布RC1 RC2等版本SR公开正式发布正式发布版一般也有多个发布，例如SR1、 SR2、 SR3等等，一般是用来修复大bug或者优化 snapshot (快照)，也即开发版Release：该版本表示最终版 版本号： 2.0.2.RELEASE
2： 主版本号。 当功能模块有较大更新或者整体架构发生变化时， 主版本号会更新
0： 次版本号。 次版本表示只是局部的一些变动。
2： 修改版本号。 一般是 bug 的修复或者是小的变动
RELEASE：表示该版本最终版。
推荐使用GA稳定版本
1.2、大致对应关系： 官网地址
1.3、查下详细对应版本 如图：官网地址
官网地址
这样springboot和springcloud的版本就适配完成了
1.4、方法2查下 官网地址
注明：推荐采用上面cloud官网查看的方式比较好
maven查看详细版本
spring-cloud-dependencies 版本列表可查看：
https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies
spring-boot-starter-parent 版本列表可查看：
https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-parent
二、cloud Alibaba 适配 springcloud 1.1、版本对应关系如图： 官网地址
1.2、阿里组件版本选择 1.3、如何使用 Spring Cloud Alibaba BOM 包含了它所使用的所有依赖的版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021dbd4fa07f75b49b10aef2246593bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40121040a4b08ea907088333793229e7/" rel="bookmark">
			C# socket操作类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections.Generic; using System.Configuration; using System.Net; using System.Net.Sockets; using System.Text; using System.Windows.Forms; namespace Control { public class SocketHepler { SocketHepler() { } #region 拍照socket //创建连接的Socket //public static Socket socketSend; public static void Connect() { try { string host = Global.host;// ConfigurationManager.AppSettings["socket_host"]; string port = Global.port;// ConfigurationManager.AppSettings["socket_port"]; Global.socketSend = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); IPAddress ip = IPAddress.Parse(host); //获取ip地址. Global.socketSend.Connect(ip, Convert.ToInt32(port)); //连接成功,就可以接收服务器发送的信息了. //Thread th = new Thread(ReceiveMsg); //th.Start(); } catch (Exception ex) { MessageBox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40121040a4b08ea907088333793229e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7694701a437944fa2f1ef225d9669ca8/" rel="bookmark">
			联想Thinkpad E15插电源开机报错“The connected AC adapter has a lower wattage than the recommended AC“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		" The connected AC adapter has a lower wattage than the recommended AC adapter
which was shipped with the system. To use AC power, please connect the AC
adapter which was shipped with the system
Press the ESC key to continue "
解决方式：根据系统下载驱动
https://tools.lenovo.com.cn/searchTools/drive/downloadList/id/2210951
https://newdriverdl.lenovo.com.cn/newlenovo/alldriversupload/86788/Thunderbolt-r1eta06w.exe
https://newdriverdl.lenovo.com.cn/newlenovo/alldriversupload/86957/Intelchip-r1ech04w.exe
安装驱动后重启。如果问题还没解决，升级BIOS。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f0d51da91055343f09e0b5fec67d6c/" rel="bookmark">
			Redis 常用 API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 常用命令
1. 设置键的过期时间（单位：秒）
expire key second
2. 查看键的过期时间（单位：秒）
ttl key（其中，如果是， -1：说明没有设置过期时间，-2：说明不存在该键）
3. 查看键的类型
type key
4. 查看内部编码
object encoding key
5. 键自增
incr key
6. 切换数据库
select dbIndex
7. 迁移键到别的数据库
move key db
8. 清除当前数据库
flushdb
9. 清除所有数据库
flushall
2. 数据结构
1. 五种基本的数据结构
（1）string
内部编码 raw、int、embstr
（2）hash
内部编码 hashtable、ziplist
（3）list
内部编码 linkedlist、ziplist
（4）set
内部编码 hashtable、intset
（5）zset
内部编码 skiplist、ziplist
3. String
可以存储简单的字符串、也可以是复杂的字符串（例如：JSON、XML）、数字（整数、浮点数）、也可以是二进制（图片、音频、视频）；但是最大不能超过 512 MB。
常用命令
设置值
1. set key value [ex seconds] [px milliseconds] [nx|xx]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f0d51da91055343f09e0b5fec67d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86becd794df1e0eb68511914a7b5a0b2/" rel="bookmark">
			【C语言】实现三子棋（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是Abert
今天我们用C语言来实现三子棋
文章目录 1.配置运行环境
2.实现各种功能并处理逻辑关系
2.1 创建游戏初始界面（进入\退出）
2.2创建一个名为board的二维数组并初始化
2.3 搭建棋盘
2.4 玩家下棋并打印新的棋盘
2.5 电脑下棋并打印新的棋盘
2.6 判断最终的结果
3.整体程序的实现：
3.1 创建游戏主体文件test.c
3.2 创建存放头文件的文件game.h
3.3 创建游戏的实现文件game.c
前言 三子棋是一款经典小游戏，用C语言实现它也是一个很奇妙的过程，下面就开始详细讲解具体步骤.
1.进行环境配置 本游戏用到三个文件，分别是两个源文件test.c game.c 和一个头文件game.h
main函数在test.c文件中，游戏实现的函数在test.c中被引用，而函数的实现主要是在game.c文件中完成。game.h文件中包含了程序所需的各种头文件并且包换对实现游戏功能的各种函数的声明。
在本次游戏设计中，使用到了3个文件，为什么不能放在一个文件中？三子棋的实现需要多个模块的功能相互串联，多个文件可以分别处理各自模块的功能，能更好处理各个模块之间的逻辑并且便于后期调试，也使得代码的可读性提高。
2.实现各种功能并处理逻辑关系 为了便于理解，2中代码暂且只用test.c文件中的代码来解释 2.1实现游戏的初始界面 int main() { test(); return 0; } 打印菜单。
void menu() { printf("********************************\n"); printf("********* 1. play *********\n"); printf("********* 0. exit *********\n"); printf("********************************\n"); } 玩家选择是否（1\0）是否进入游戏
void test() { int input = 0; srand((unsigned int)time(NULL)); do { menu(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86becd794df1e0eb68511914a7b5a0b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d8e74a31745aadcd35e463daae578b/" rel="bookmark">
			JavaScript中关于数据变量与内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据变量与内存的相关问题 1、var a = xxx ; a内存中到底保存的是什么？ xxx 是基本数据类型时，保存的就是这个数据内容。xxx 是对象时，保存的就是这个对象的地址值。xxx 是一个变量时，保存的是 xxx 的内存内容（可能是基本数据，也可能是地址值）。 2、引用变量赋值问题 var a = {name:"Tom",age:18}; function fun(obj){ obj = {age:20}; }; fun(a); 问题：这里的a.age是多少？ console.log(a.age); //out:18 3、js在调用函数传递变量参数时，是值传递还是引用传递？ 理解1：都是值（基本数据 / 地址值）传递。理解2：可能是值传递，也可能是引用传递（地址值）。 一篇博客：关于函数传参时是值传递和引用传递的看法
4、js引擎如何管理内存？ 内存生命周期
分配小内存空间，得到它的使用权。
储存数据，可以反复操作数据。
释放小内存空间。
释放内存
局部变量：函数执行完自动释放。对象：成为垃圾对象 --&gt; 被垃圾回收器回收。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1feaba9b3b151dd6f19d300858861b26/" rel="bookmark">
			c#考试，答题系统制作（窗体）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考试答题窗体设计 效果展示： 1. 进入页面：
2. 答题界面：
3. 时间截止界面：
4. 提交界面：
起始页代码 public partial class Start : Form { public Start() { InitializeComponent(); } private void button2_Click(object sender, EventArgs e) { Application.Exit(); } private void button1_Click(object sender, EventArgs e) { Test t = new Test(); t.Show(); this.Hide(); } } 考试页面代码 public partial class Test : Form { public int currentTime = 0; public int num = 0; public Test() { InitializeComponent(); button2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1feaba9b3b151dd6f19d300858861b26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8f1f7fd19129dd9304dfa8090625cc/" rel="bookmark">
			acwing蓝桥杯c&#43;&#43;A/B组辅导课--第六讲双指针、BFS与图论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.日志统计 法1： 用双指针i,j枚举时间段，如果i-j&gt;=d，就将超出范围的cnt[]--，且j++，这样就会始终有一个长度为d的区间
vector&lt;int&gt; f[t] 记录了在t时刻里获赞的所有编号
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5+10; vector&lt;int&gt; f[N];//f[t]记录了所有在t时刻获赞的编号 int cnt[N];//cnt[id]表示id的获赞数,是动态的,超过了时间长度d会-- bool st[N];//st[id]判断编号id是不是热帖 int main() { int n,d,k; cin&gt;&gt;n&gt;&gt;d&gt;&gt;k; for(int i=0;i&lt;n;i++) { int ts,id; cin&gt;&gt;ts&gt;&gt;id; f[ts].push_back(id); } for(int i=0,j=0;i&lt;=1e5;i++)//i,j维护一个长度为d的时间区间 { if(i-j&gt;=d)//长度超过d了,原来j时刻的那些获赞就会-- { for(auto x:f[j]) { cnt[x]--; } j++; } for(auto x:f[i])//遍历所有在i时刻获赞的编号 { cnt[x]++; if(cnt[x]&gt;=k) st[x]=true;//如果长度一旦&gt;=k,就说明曾经是热帖 } } for(int i=0;i&lt;N;i++) { if(st[i]) cout&lt;&lt;i&lt;&lt;endl; } return 0; } 法2： pair&lt;int，int&gt; logs记录 ，获赞时刻和id
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d8f1f7fd19129dd9304dfa8090625cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e128eaeb5c400618b910b7f8003bb41/" rel="bookmark">
			Ubuntu解决网络连接优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu解决网络连接的优先级 1. 查看网关：ip route show2.查看ip：ipconfig3.删除默认的有线网关4. 添加wifi ip为默认地址（ip，不是网关地址） ubuntu下无线连接网络，有线连接板卡，解决网络连接的优先级 1. 查看网关：ip route show default via 192.168.2.1 dev enx00e04c689947 proto static metric 100 default via 10.159.0.1 dev wlp2s0 proto static metric 600 10.159.0.0/23 dev wlp2s0 proto kernel scope link src 10.159.0.177 metric 600 10.201.109.45 via 10.159.0.1 dev wlp2s0 proto dhcp metric 600 169.254.0.0/16 dev wlp2s0 scope link metric 1000 192.168.2.0/24 dev enx00e04c689947 proto kernel scope link src 192.168.2.22 metric 100 2.查看ip：ipconfig default via 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e128eaeb5c400618b910b7f8003bb41/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/151/">«</a>
	<span class="pagination__item pagination__item--current">152/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/153/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>