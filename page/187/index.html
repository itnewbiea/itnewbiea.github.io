<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ecae9a02e8317ba137e59cc9f5ceb4/" rel="bookmark">
			大数据课程实验总结（四）--hadoop-2.7.3的安装和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop-2.7.3的安装和配置 实验准备hadoop安装文件安装hadoop-2.7.3配置hadoop将hadoop命令加入到PATH验证hadoop注意事项 实验准备 本实验是在大数据课程实验总结（三）的实验基础上继续进行的，为确保实验完整，进行此次实验前请确保Xshell已经成功与四台虚拟机建立会话，建议打开Xshell工具中的“发送键输入到所有会话”功能以减少重复操作。
本次实验所需资源为：大数据课程实验（四）资料包hadoop-2.7.3.zip
hadoop安装文件 在实验环境下，hadoop安装文件已经放置在 /usr/local目录下，文件名为：hadoop-2.7.3.tar.gz，如图所示：
安装hadoop-2.7.3 将hadoop-2.7.3.tar.gz进行解压缩：
tar -xvf hadoop-2.7.3.tar.gz 等待解压完成：
解压完成后当前目录下会出现一个hadoop-2.7.3的文件夹，ls 进行查看：
为方便操作，将此文件夹进行改名，改为" hadoop "
mv hadoop-2.7.3 hadoop ls查看：
配置hadoop 解压完成之后，进行hadoop的配置：
进入目录：
cd /usr/local/hadoop/etc/hadoop 此路径下存在"hadoop-env.sh"文件，如图：
编辑此文件：
vim hadoop-env.sh 按i进入编辑内容
添加内容为：
export JAVA_HOME=/usr/java/default 编辑完成后按Esc退出编译状态,之后:wq保存并退出;
将hadoop命令加入到PATH 编辑文件profile：
vim /etc/profile 按a进入编辑内容状态
在末尾添加内容：
export PATH=$PATH:/usr/local/hadoop/bin:/usr/local/hadoop/bin:/usr/local/hadoop/sbin 编辑完成后按Esc退出编译状态,之后:wq保存并退出;
输入命令：
source /etc/profile 使设置生效；
此处开始出现的问题为：/usr/local/hadoop/bin：/usr/local/hadoop/sbin’: 不是有效的标识符
原因：出现了中文“：”应改为英文：":"
修改后重新执行：
验证hadoop 输入命令：
hadoop 如图所示：
验证成功，本次实验结束。
注意事项 由于此次实验中需要输入的字符较多，在输入的内容过程中容易出现少输入空格或者字符输入错误及中英文切换不当等问题，需要在操作过程中进行留意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2d5ead78a65a60288e24de61d03eae/" rel="bookmark">
			Maven 模块管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着项目的不断发展，需求的不断细化与添加，代码越来越多，结构也越来越复杂，这时候就会遇到各种问题
不同方面的代码之间相互耦合，这时候一系统出现问题很难定位到问题的出现原因，即使定位到问题也很难修正问题，可能在修正问题的时候引入更多的问题。多方面的代码集中在一个整体结构中，新入的开发者很难对整体项目有直观的感受，增加了新手介入开发的成本，需要有一个熟悉整个项目的开发者维护整个项目的结构（通常在项目较大且开发时间较长时这是很难做到的）。开发者对自己或者他人负责的代码边界很模糊，这是复杂项目中最容易遇到的，导致的结果就是开发者很容易修改了他人负责的代码且代码负责人还不知道，责任追踪很麻烦。 将一个复杂项目拆分成多个模块是解决上述问题的一个重要方法。 拆分的好处
多模块的划分可以降低代码之间的耦合性（从类级别的耦合提升到jar包级别的耦合）每个模块都可以是自解释的（通过模块名或者模块文档）模块还规范了代码边界的划分，开发者很容易通过模块确定自己所负责的内容… 自解释性就是要求程序代码、配置、脚本能够充分清晰的表明自己的业务意图、业务步骤、参数类型、参数值范围、约束、修改方法等信息。
对于程序代码，类和对象名字要反映出执行者（actor）在场景中角色，通常采用名词命名。方法名字要充分反映业务意图。通常可以采用动词或动词短语命名。如果参数过多，使用具有结构的对象封装参数，而不是将参数胡乱塞入Map&lt;String,Object&gt;传递。同时，方法要充分注释，写清楚参数和返回值的含义，可能抛出的异常和其他需要注意的地方。脚本也是一种程序源代码，因此可采用和程序代码同样的原则。
模块拆分策略 推荐按照功能拆分，后期方便转换成微服务架构
按职责划分
–module-test –module-test-service–module-test-po–module-test-controller–module-test-dao–module-test-common–module-test-util 按功能拆分
例如，在电商系统中如下module
–module-test –module-test-common公共部分–module-test-order订单–module-test-checkout购物车–module-test-pay支付–module-test-catory类目–module-test-product商品–module-test-price价格–module-test-account账号 搭建多模块项目 搭建多模块项目，需要使用 maven 的继承和聚合，其中聚合负责将多个模块集中在一起进行管理，继承则负责各子模块中的公共配置
创建项目
我使用的是idea
删掉src
pom文件内容
创建子模块 在项目下创建子模块
套路与创建普通项目一致
注意变化
module 的 pom 文件发生了变化
新增了两段配置
&lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;module-util&lt;/module&gt; &lt;/modules&gt; pom 是最简单的打包类型。不像jar和war，它生成的构件只有它本身。将 packaging 申明为 pom 则意味着没有代码需要测试或者编译，也没有资源需要处理。
由于我们使用了聚合，所以打包方式必须为pom，否则无法构建。
&lt;modules&gt; &lt;module&gt;module-util&lt;/module&gt; &lt;/modules&gt; module的值是子模块相对于当前 POM 的路径。
再看子模块中的 pom
也是分成两个部分
&lt;parent&gt; &lt;groupId&gt;com.wqlm&lt;/groupId&gt; &lt;artifactId&gt;module&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;module-util&lt;/artifactId&gt; &lt;parent&gt; &lt;groupId&gt;com.wqlm&lt;/groupId&gt; &lt;artifactId&gt;module&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--&lt;relativePath/&gt;--&gt; &lt;/parent&gt; 声明了该模块继承自 com.wqlm:module:1.0-SNAPSHOT，其实这里面还省略了
&lt;relativePath&gt;&lt;/relativePath&gt; 由于 relativePath 默认是 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2d5ead78a65a60288e24de61d03eae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac2e4354c060bacde56b312c6c7b220/" rel="bookmark">
			C&#43;&#43;删除非空文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数参数必须带’/'结尾
void rmdir(const std::string&amp; dir) { struct _finddata_t fb; long long handle = _findfirst((dir + '*').c_str(), &amp;fb);//查找第一个子文件: . if(handle != -1){// _findnext(handle, &amp;fb);//去除第二个子文件: .. while(0 == _findnext(handle, &amp;fb)){//查找下一个子文件 if(fb.attrib == 16){//16代表是目录 rmdir(dir + fb.name + '/');//递归调用删除目录 }else{ remove((dir + fb.name).c_str());//用标准函数删除文件 } } _findclose(handle); } rmdir(dir.c_str());//用标准函数删除目录 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a518c76b86dba6c71940bb335c9510/" rel="bookmark">
			爬虫 第二讲 urllib模块和requests模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、urllib模块1.什么是urllib模块？1.urllib.request模块2.响应对象3.urllib.parse模块5.练习1：输入指定内容在百度中搜索，并保存网页内容6.练习2：输入指定内容在百度贴吧中搜索，并保存多个网页内容7.优化代码 二、requests模块1.安装2.requests常用方法3.响应对象response的方法4.requests模块发送 POST请求5.requests设置代理6.处理不信任的SSL证书7.cookie8.会话 一、urllib模块 1.什么是urllib模块？ python的内置网络请求模块
为什么要学习这个模块？
1，有些比较老的爬虫项目用的就是这个技术
2.有的时候我们去爬取一些数据需要请求和urllib的配合使用
3.内置模块是标准库
示例1
# 保存'未来汽车'图片到本地 import requests response = requests.get( 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fphotocdn.sohu.com%2F20120823%2FImg351337268.jpg&amp;refer=http%3A%2F%2Fphotocdn.sohu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1621479722&amp;t=5cda4533dad4056d5809bf5f2450a22f').content with open('未来汽车.jpg', 'wb') as f: f.write(response) 示例2
# 保存'未来汽车'图片到本地 from urllib.request import urlretrieve response = urlretrieve( 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fphotocdn.sohu.com%2F20120823%2FImg351337268.jpg&amp;refer=http%3A%2F%2Fphotocdn.sohu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1621479722&amp;t=5cda4533dad4056d5809bf5f2450a22f', '未来汽车.jpg') 1.urllib.request模块 python2：urllib2，urllib
python3：把urllib和urllib2合并常用的方法
urllib.request.urlopen(“网址”) 作用 ：向网站发起一个请求并获取响应字节流 = response.read()字符串 = response.read().decode(“utf-8”)urllib.request.Request"网址",headers=“字典”) urlopen()不支持重构User-Agent 示例1
# urllib.request实现 # urllib.request.urlopen('网址') # 作用：向网站发起请求并响应 import urllib.request response = urllib.request.urlopen('https://www.baidu.com/') print(type(response)) # &lt;class 'http.client.HTTPResponse'&gt; print(response.read()) ''' b'&lt;html&gt;\r\n&lt;head&gt;\r\n\t&lt;script&gt;\r\n\t\tlocation.replace(location.href.replace("https://","http://"));\r\n\t&lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n\t&lt;noscript&gt;&lt;meta http-equiv="refresh" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a518c76b86dba6c71940bb335c9510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d1be357aa035334aee52fee3ce2ef7/" rel="bookmark">
			svn ： svn: E200033: database is locked, executing statement ‘RELEASE   s0‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 操作：svn提交代码时，发现提交了错误代码，ctrl + z 终止，接着出现报错，用svn cleanup也报错。
解决方法：
$ cd /your project path/.svn $ mv wc.db wc.db.old #做事都要有备份的习惯 $ sqlite3 wc.db.old #打开copy的数据库 sqlite&gt; .backup main wc.db sqlite&gt; .exit 之后可能会出现.tmp已经有了不能写,但是进去也找不到. cd .svn mkdir aa mv aa ./tmp rm -rf ./tmp cd .. svn cleanup svn update 这样就可以了. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a91c836010aada6964e6ffcb5754698/" rel="bookmark">
			当图片缩小后失真和用固定定位时失效的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 标题当图片失真时我们可以用 1，background-size的cover的属性值介绍
缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。
2、background-position的属性值介绍
background-position后可跟2个值，2个值用空格间隔开，第一个值，固定代表水平方向（横向）左、中、右距离，第二个值，固定代表垂直上、下距离
下面我们来看一下缩小后图片失真的效果图
是不是感觉好难看?这时候我们可以在他css样式里面添加
这个两个属性和属性值
background-position: center center; background-size: cover; 可以看看添加后的效果图
用固定定位时滚轮下调时img把导航条给该压住了解决方法 这时可以看看被遮挡住时的效果图由于是这图片有些img图片不能外传 所有我把他给涂鸦了 还请大家见谅！为了大家能看的更清楚 所有我给他导航条盒子容器添加了border边框
当往下翻的时候 img 会被图片遮挡
下面我们来看一下解决后的效果
这时我们可以给固定定位的容器添加z-index：999 就可以解决这个问题
position: fixed; top: 0px; left: 0; z-index: 9999; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0572d01463f1c61071528ecb00939215/" rel="bookmark">
			Graph学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复杂的图 2.1 异构图 同构图只有一种节点类型，一种边的类型。异构图即边与节点的类型都不止一种的图。二分图： G = { V , E } \mathcal G=\left\{\mathcal V,\mathcal E\right\} G={V,E}，节点集 V \mathcal V V可以被划分为两类 V 1 \mathcal V_{1} V1​, V 2 \mathcal V_{2} V2​，图里的边只存在与这两个集的节点的相互连接。多维图：在许多现实世界的图形中，一对节点之间可以同时存在多个关系。比如电商网站里用户与商品之间的关系可以为：‘点击’，‘购买’，‘评论’符号图：包含正边与负边，比如在社交网络里，有些节点之间的关系是屏蔽，有些是无关系，可以把这两类的的关系都用负边来表示，而’关注‘则是正边。定义： G = { V , E + , E − } \mathcal G =\left\{\mathcal V,\mathcal E^{+},\mathcal E^{-}\right\} G={V,E+,E−}
超图：在现实生活中关系往往并不是成对出现的。比如下图这个学术论文的关系图，特定作者可以发表两篇以上的论文。 因此，作者可以看作是连接多篇论文（或节点）的超边，
动态图：上述提到的图都是静态的，节点之间的连接在观测时时固定的。然而在现实世界的很多应用中，随着向图上添加新的节点，图也在不断地发展，节点之间的边的数量也会增多。比如像Fcebook这样的社交网络，用户可以不断与他人建立友谊，新用户也可以随时加入Facebook。 这些类型的演化图可以表示为动态图，其中每个节点或边都与时间戳关联。节点的时间戳代表着当这个节点第一次与其他节点相连接的时刻。定义：动态图 G = { V , E } \mathcal G=\left\{\mathcal V,\mathcal E\right\} G={V,E}，节点的集合KaTeX parse error: Expected '}', got 'EOF' at end of input: …v_{1},.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0572d01463f1c61071528ecb00939215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc7bfcf541ade32e806b31dcc7d4b3f/" rel="bookmark">
			css属性小结之文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css属性小结之文本 （1）用text-decoration设置文本修饰线 要对文本增加一些装饰性的效果，可以使用元素的text-decoration属性，该属性的值有：underline、 overline、line-through 、none；分别对应：下划线、上划线、删除线和去除装饰。
演示效果 (a).设置文本下划线： &lt;p style=" text-decoration:underline"&gt;使用text-decoration设置文本下划线演示效果&lt;/p&gt; 对应效果：
(b).设置文本上划线： &lt;p style=" text-decoration:overline"&gt;使用text-decoration设置文本上划线演示效果&lt;/p&gt; 对应效果：
©.设置文本删除线： &lt;p style=" text-decoration:line-through"&gt;使用text-decoration设置删除线演示效果&lt;/p&gt; 对应效果：
(d).取消文本装饰： &lt;a href="#" style=" text-decoration:none"&gt;取消文本装饰演示效果&lt;/p&gt; 对应效果：
注：演示为使用“text-decoration:none”去除了超链接的默认下划线；字体颜色仍然为默认蓝色，若修改此字体颜色则需使用 " color "属性；详细说明见另一篇博客：css属性之字体
（2）text-align 设置文本对齐方式（水平） text-align属性用来设置文本在水平方向*的对齐方式，属性的值分别为：“left”,“center”,“right”,“justify”
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;css属性之文本演示&lt;/title&gt; &lt;style type="text/css"&gt; body { border: 1px solid orange; width: 400px; } #text1 { text-align: center; } #text2 { text-align: left; } #text3 { text-align: right; } #text4 { width: 100px; text-align: justify; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc7bfcf541ade32e806b31dcc7d4b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c080cc8fac22aba09739899f45e9978e/" rel="bookmark">
			Flink批处理将数据写入Hbase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink写出通过自定义Sink实现
pom如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wy&lt;/groupId&gt; &lt;artifactId&gt;flink&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-streaming-scala --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-scala_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka-0.11_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--flink -hdfs--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- flink sql模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table_2.11&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-common&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 保存mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c080cc8fac22aba09739899f45e9978e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763106464f717010cabc8906369ca9b8/" rel="bookmark">
			maven同一个项目中，一个子模块引用另一个子模块的类的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先在一个项目中创建两个子模块，如：
2、在common-api的pom.xml添加版本号，如：
3、在use-common-api的pom.xml中添加如下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.best&lt;/groupId&gt; &lt;artifactId&gt;common-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注意：最关键的就是scope的值一定要是compile。
4、然后再common-api添加一个类，如：
5、最后在use-common-api使用Log类，如下图所示：
6、运行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3885917e0d712d945d88515a069a261a/" rel="bookmark">
			在matplotlib中设置中文字体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在matplotlib中设置中文字体 matplotlib库中默认使用的字体是不支持中文的，所以如果需要中文的标签或标题则我们手动去重新设置一个支持中文格式的字体。因为之前我在设置的时候犯了一个很蠢的问题，但是也可能是很多其它小白也会遇到的问题，所以，赶紧做好笔记，防止自己以后犯蠢，也供大家参考和指正！！！
问题 这里可以看到直接用title()输入中文的时候，图中不会出现中文，是因为matplot的默认字体不支持中文格式，所以下面我会为大家演示两种中文字体的设置方式，另外也会演示我的错误，供大家参考。
环境版本：windows系统，JupyterLab，python3.8，matplotlib 3.4.1
设置中文字体的方式 通过FontProperties() 设置默认字体 先贴代码
#先导入相关库 import matplotlib.pyplot as plt import matplotlib from matplotlib import font_manager #调用font_manager中的FontProperties()设置自己的字体 font_path = "C:\\Windows\\Fonts\\simhei.ttf" #这里需要传入字体的路径 #传参 my_font = font_manager.FontProperties(fname = font_path,size =20 ) #自己的字体就定义完成了 #查看效果 plt.plot([1,2,3],[3,4,5]) plt.title("中文出现了",fontproperties = my_font) plt.show() windows系统的字体存放路径都在C:\Windows\Fonts\目录下
FontProperties()中也可以设置字体的大小，通过传入参数size即可
调用自己的字体时，通过fontproperties = my_font即可
设置全局字体 还是先贴代码
#在matplotlib中提供一个方法可以查看我们可以设置的默认字体，先查看一下有哪些可以使用 from matplotlib.font_manager import FontManager import subprocess all_fonts = set(f.name for f in FontManager().ttflist) print('all font list get from matplotlib.font_manager:') for f in sorted(all_fonts): print('\t' + f) 结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3885917e0d712d945d88515a069a261a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1b6a879c6958c2dec4e8a550836237/" rel="bookmark">
			二叉树遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		22332 http://6520874.blog.163.com/blog/static/72582719201111711719270/ /********************************************** Author:tmw date:2018-2-13 **********************************************/ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #define MAXSIZE 100 /**二叉树数据结构定义**/ typedef struct BiTreeNode { char data; struct BiTreeNode *left; struct BiTreeNode *right; }BiTreeNode,*BiTree; /**二叉树的建立--按照先序方式建立--插入**/ void CreateBiTree(BiTree *T) { char val; scanf("%c",&amp;val); if(val == '@') *T = NULL; //null表示为空枝 else { *T = (BiTree)malloc(sizeof(BiTreeNode)); (*T)-&gt;data = val; CreateBiTree(&amp;(*T)-&gt;left); CreateBiTree(&amp;(*T)-&gt;right); } } /**先序遍历 根左右**/ void PreOrderTravel(BiTree T) { if(T==NULL) return; printf("%c ",T-&gt;data); PreOrderTravel(T-&gt;left); PreOrderTravel(T-&gt;right); } /**中序遍历 左根右**/ void InOrderTravel(BiTree T) { if(T==NULL) return; InOrderTravel(T-&gt;left); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b1b6a879c6958c2dec4e8a550836237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583324ab3ac82d65cf86cb5f00553b8c/" rel="bookmark">
			使用EPPlus实现Excel导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用EPPlus实现Excel导出 引言一、如何获取对象(类)属性和值？1.1 创建对象(类)1.2 获取对象(类)的属性1.3 获取对象(类)的属性值 二、通过对象(类)的属性和值进行导出2.1 NuGet:EPPlus2.2 创建EPPlus导出Excel的辅助类2.3 Web层调用导出 引言 使用EPPlus导出Excel我们在封装之前，需要明白怎么去根据一个对象(类)获取到其属性和属性的值，当我们提前弄清楚这个东东的话，对我们后续的工作就好开展了！因为EPPlus导出Excel是需要进行行列对应的，不能每导出一个列表，我们都要手动去控制这个对象所需多少行，多少列吧，明显太费事也行不通。所以获取对象(类)获取到其属性和属性的值是我们前提必备的要件！
一、如何获取对象(类)属性和值？ 1.1 创建对象(类) public class FyLogDto { /// &lt;summary&gt; /// 标识 /// &lt;/summary&gt; public string ID { get; set; } /// &lt;summary&gt; /// IP /// &lt;/summary&gt; public string IP { get; set; } /// &lt;summary&gt; /// 机器名称 /// &lt;/summary&gt; public string MachineName { get; set; } /// &lt;summary&gt; /// 日志类型 /// &lt;/summary&gt; public string Level { get; set; } /// &lt;summary&gt; /// 日志内容 /// &lt;/summary&gt; public string Message { get; set; } /// &lt;summary&gt; /// 记录器名称 /// &lt;/summary&gt; public string Logger { get; set; } /// &lt;summary&gt; /// 调用站点 /// &lt;/summary&gt; public string Callsite { get; set; } /// &lt;summary&gt; /// Url /// &lt;/summary&gt; public string Url { get; set; } /// &lt;summary&gt; /// 控制器 /// &lt;/summary&gt; public string Controller { get; set; } /// &lt;summary&gt; /// 控制器的的方法 /// &lt;/summary&gt; public string Action { get; set; } /// &lt;summary&gt; /// 请求方式：GET,POST,PUT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583324ab3ac82d65cf86cb5f00553b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f748e075efe98e3e77eefcd027e91f/" rel="bookmark">
			16.Flink开发笔记一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink开发笔记 1. pom.xml2. 并行度优先级问题3. wordcount再standalone结点（默认配置）提交资源不足的问题4. 集群提交常用命令5. 执行图6. slot共享组7. 自定义Source8. KeyedStream9. SplitStream（Please use side outputs instead of split/select）10. ConnectedStreams11. 富函数12. Broadcast流 1. pom.xml &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;flink.version&gt;1.11.3&lt;/flink.version&gt; &lt;scala.binary.version&gt;2.11&lt;/scala.binary.version&gt; &lt;/properties&gt; &lt;!--在idea中调试flink程序--&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;2.11.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_2.11&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--重点1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-scala_2.11&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--重点2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-scala_2.11&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;build&gt; &lt;!--注意maven版本太低导致的问题，当前用的3.6.3--&gt; &lt;plugins&gt; &lt;!--重点3--&gt; &lt;!--该插件用于将scala代码编译成class文件--&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt; &lt;version&gt;4.4.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!--重点1--&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f748e075efe98e3e77eefcd027e91f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/408f44baa51c7b7230c62f32b2acadc2/" rel="bookmark">
			Altium Dsigner 16,自己画的封装连不上线，手动连线焊盘处变绿——分析解决全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己画的元器件，原理图连线也是没问题的，生成PCB时，连不上线，
并且手动布线选择“交互式式布线连接”，焊盘处也连不上，没办法只能用“放置走线”
手动布线
下面是的PCB出现的问题 自己画的三个元器件的封装都没有连线
检查——在错误的道路上越走越远 编译，没有错误，有几处警告
检查，百度所述，引脚带有“米”字形状的朝外，没问题呀！
找了几种解决方案，迷迷糊糊的，然后也没解决
网上解决方案：
1、off sheet at***：
是因为你原件的原点设置的离原件很远导致的，你在封装里把原件原点设置在原件上就ok了。
2、是因为你原理图中的元件引脚尺寸和你设置的栅格尺寸不对应，导致系统无法识别而报错，引脚长度尺寸必需设置成栅格尺寸的整数倍！
百度的方法试了，并未解决
各种检查，貌似都没问题
自己画的元器件各管脚电气类型也都设置了
元器件和封装管脚也是一一对应的
有经验的，或许一眼就看出了问题，但作为一个新手真的不明白为题所在，！大佬，勿喷！
就是因为前面的一个小问题，后面引发了一连串的大问题，往往入局者迷，然后注意力全都放在了后面，结果越错越远，后面花了大量时间，怎么检查好像都是没问题的，正当百思不得其解时，忽然醒悟！
下面继续越错越远
封装正常
生成PCB执行页面正常，0错误
但结果自己画的封装就是没有连线，各种折腾，无果
重新画封装、引用库文件已有封装修改成自己的封装…
PCB下，设计-&gt;类-&gt;component classes-&gt;删除目标文件
PCB下，设计-&gt;网格表-&gt;清除全部网络
。。。。。
反反复复折腾了好多遍，任然无果！
放弃，反正也是业余，那就手动布线吧！
手动布线再次出问题 手动布线选择“交互式式布线连接”，焊盘处也连不上，没办法只能用“放置走线”
手动布线
手动连线起点正常，终点焊盘处变绿
线宽规则也设置了，线的粗细也调整了，无论怎么修改线宽，都是绿色！
突然醒悟 上下对比
库里的封装印引脚
我画封装引脚，但是这里没法修改呀，可能是前面的问题
难道是这里？
于是将名字和标识换了一下
然后自己画的元件改成这样
都改好了，再试试
问题解决了 如果，还有问题的话，是之前运行产生的网络冲突错误
PCB下，设计-&gt;类-&gt;component classes-&gt;删除目标文件
PCB下，设计-&gt;网格表-&gt;清除全部网络
但这个警告任然存在，不知道是不是还有什么之前生成的文件没有清理干净，但是不影响使用。
越错越远原因 除了新手不熟主观外，
最主要的客观原因是，本电路中芯片少，大多都是Header 接线端口，二接线端口引脚标号，也都是放在元器件内部，
结果，我在画元器件时，管用Header的方式去标注芯片的管脚标号，
很自然地吧1,2,3…数字标号写在里面，
这么低级的错误，却一直觉得很对，导致了很面一系列奇怪的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2184db14abe146e91210d03e30cae5a/" rel="bookmark">
			oracle dat 文件怎么打开,DAT后缀的文件是用什么软件打开的呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		也有数据文件的后缀名为。DAT，文件格式不确定，任何文件的后缀名都可以设为。DAT，因为读取数据不是从后缀名判断的，而是从文件格式判断DB：数据库文件，Thumbs。db是缩略图缓存DBF：dBASE文件，一种由Ashton-Tate创建的格式，可以被ACT！、Lipper、FoxPro、Arago、Wordtech、Xbase和类似数据库或与数据库有关产品识别；可用数据文件(能被Excel97打开)；Oracle8。
1。
x表格空间文件DBX：DataBearn图像；MicrosoftVisualFoxPro表格文件DCF：数码照相机统一记录格式，DCF也有音频格式DCT：MicrosoftVisualFoxPro数据库容器DCU：Delphi编译单元文件DCX：MicrosoftVisualFoxPro数据库容器；基于PCX的传真图像；宏DIR：MacromediaDirector文件DLF：一种INI配置文件格式的语言文件DLL：动态链接库DOC：MicrosoftWord2003文档文件DOCX：MicrosoftWord2007文档文件Perfect文档、Microsoft：Word文档；DisplayWrite文档DOT：MicrosoftWord文档模板DPL：BorlandDelph3压缩库DRV：驱动程序DRW：MicrografxDesigner/Draw；Pro/E绘画文件DSF：MicrografxDesignerVFX文件DSG：DOOM保存的文件DSM：DynamicStudio音乐模块(MOD)文件DSP：MicrosoftDeveloperStudio工程文件DSQ：CorelQUERY(查询)文件DST：刺绣机图形文件DSW：MicrosoftDeveloperStudio工作区文件DTA：WorldBank(世界银行)的STARS数据文件DTD：SGML文档类型定义(DTD)文件DTED：地面高度数字数据(图形的数据格式)文件DTF：SymantecQA相关的数据库数据文件DTM：DigiTrakker模块文件DUN：Microsoft拔号网络导出文件DV：数字视频文件(MIME)DWG：AutoCAD工程图文件；AutoCAD或GenericCADD老版本的绘图格式DXR：MacromediaDirector受保护(不可编辑)电影文件文件格式EE：易语言代码源文件EC：易语言模块文件EDA：EnsoniqASR磁盘映像EDD：元素定义文档(FrameMaker+SGML文档)EDE：EnsoniqEPS磁盘映像EDK：EnsoniqKT磁盘映像EDQ：EnsoniqSQ1/SQ2/Ks32磁盘映像EDS：EnsoniqSQ80磁盘映像EDV：EnsoniqVFX-SD磁盘映像EFA：EnsoniqASR文件EFE：EnsoniqEPS文件EFK：EnsoniqKT文件EFQ：EnsoniqSQ1/SQ2/Ks32文件EFS：EnsoniqSQ80文件EFV：EnsoniqVFX-SD文件EMD：ABT扩展模块EMF：Windows增强元文件EML：MicrosoftOutlookExpress邮件消息(MIMERTC822)文件EOT：是一种压缩字库，目的是解决在网页中嵌入特殊字体的难题，只有微软的IE浏览器支持EXE：可执行文件(程序)文件格式FFAV：MicrosoftOutlook导航条FAX：传真类型图像FCD：虚拟CD-ROMFDF：AdobeAcrobat表单文档文件FLA：MacromediaFlash动画源文件FLAC：无损音频压缩编码FLV：Flash视频文件FNE：易语言的其中一种支持库文件，用于在易语言中装载和提供对应的命令和方法，易语言支持库还有FNR格式、NPK格式以及LPK文件包等。
全部
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1bc2d2255600f6b3bfb395d310c3024/" rel="bookmark">
			oracle recordtype,Oracle  type/rowtype/record
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RECORD: 记录类型，可以理解为是几列数据的集合，使用的时候注意结果集只能有一行 ，引用时使用.来引用内部元素 declare type v_my_record is record (v_ename emp.ename%type, v_job emp.job%type); v_dname dept.dname%type; v_my v_my_record; --需要先定
RECORD: 记录类型，可以理解为是几列数据的集合，使用的时候注意结果集只能有一行
，引用时使用.来引用内部元素
declare type v_my_record is record
(v_ename emp.ename%type,
v_job emp.job%type);
v_dname dept.dname%type;
v_my v_my_record; --需要先定义type 再声明变量
begin
v_dname:=&amp;dname;
select ename,job into v_my
from emp inner join dept
on emp.deptno=dept.deptno
where upper(dept.dname)=upper(v_dname) and rownum=1;
dbms_output.put_line(v_my.v_ename||' '||v_my.v_job);
exception when no_data_found then
dbms_output.put_line('nononono..');
end;
ROWTYPE：可以理解为是几列数据的集合，可以对表、视图使用，应用的时候使用 "." 和record类似：
create or replace view v_emp
as
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1bc2d2255600f6b3bfb395d310c3024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e36da3a4c39ce697a9a99ef98001e62/" rel="bookmark">
			oracle程序不能连接,安装oracle后不能连接问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装oracle之前，还特意找了几篇博客和百度经验看过，因为知道oracle的只能安装一次，如果装不上，OK，基本排除安装的可能了(安装的残留文件卸不完)
然而，我的问题没有出在这里，安装很顺利，一个小时左右就装好了(当然是在虚拟机里 ^_^)
然后。。。
打开自带的sql developer，输入连接
可以连接，但是使用本地ip(192.168.1.103)不行
打开oracle的 Net Manager
修改Listener，改为本地ip。。
然后，localhost又不能连接了。
最后解决办法：
1. 打开oracle的Net Configuration Assistant
2.选择 Listener configuration 点击Next
3. Delete ，点击Next
4. 点击Next(知道退出第一步界面)
5. 选择 Listener configuration 点击Next
6. Add ，点击Next
(输一下密码，其他的默认就好了，重启Oracle的Listener，ip和localhost都可以连接了)
在网上还看到一种解决办法，没有用过，估计是可以的：
1、修改配置文件listener.ora将HOST=你自己的主机名
LISTENER =
(DESCRIPTION_LIST =
(DESCRIPTION =
(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))
(ADDRESS = (PROTOCOL = TCP)(HOST = sweetboy_pc)(PORT = 1521))
)
)
文件所在路径：
C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN
2、检查监听设置，重新启动监听服务。
注：使用有风险，请勿在生产环境随意操作，如产生不可预料的后果，请自己负责。
当然，自己电脑最好也不要随便乱搞，搞坏了还有重装(系统或者oracle)，推
荐使用虚拟机学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f3e5fffdbb6103ce88ad8806f895b7/" rel="bookmark">
			伍翀(阿里云技术专家-----云邪的blog)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伍翀(云邪的blog)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed86d8ee3b559c5bac76ab895bd84410/" rel="bookmark">
			前端开发者必备的代码开源平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个前端开发者，写代码处理BUG是日常，我们可以通过去看一些大神的代码来学习大神的思路，今天小千就来给大家介绍几个国内可以访问的开源代码平台，记得收藏转发哦~
1、GitHub 这个就不用多说了，程序员都知道。全球知名开发者空间,聚集了超过两千万的程序员在这里一起工作，探讨代码，管理项目。
2、gitee 相当于是中文版的GitHub，使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务。和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。
3、开源中国 在国内程序员圈子里名气最大的开源技术社区，程序员社区，提供了技术、学习、开发、甚至职业发展的各种互动，收录超过两万款开源软件。
4、CodeForge 非常全面、好用的源码分享、下载网站，提供了各种开发代码，从java web到php开发。
5、Demo大师
一个Demo案例分享平台，有很多有价值的案例源码，可以为开发中的一些模块提供参考价值，唯一不足的就是，这个平台是收费的。
6、源码之家
提供了网站源码、静态页面模板的下载，平台上的后台管理系统模板还是比较有价值的，对于接私活的小伙伴，可以在这里找到好用的后台系统静态页面模板。
7、jQuery插件库 一个很好用的前端插件库，收集的特别多的前端特效代码，包括导航、分页、拖拽、播放器等，还有很多H5开发的网页版小游戏。
本文来自千锋教育，转载请注明出处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825520d28029194ea08933bf77ccc8d4/" rel="bookmark">
			数据结构-树的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树的定义 n(n&gt;=0)个结点构成的有限集合，非线性数据结构，n=0时为空树
对于任意一棵非空树具备以下性质：
有一个Root，用r表示
其余结点可分为m个互不相交的有限集T1,T2, ... ,Tm，其中每个集合本身又是一棵树，称为原来树的子树SubTree
判定树与非树？ 子树不相交
除了根结点外，每个节点有且仅有一个父结点
一棵N个结点的树有N-1条边
树是保证结点连通的最少边的方式
树的基本术语 结点的度（degree）：结点的子树个数
树的度：数的所有结点中最大的度数
叶结点（leaf）：度为0的结点，也叫终端结点
非终端结点：也叫分支结点，指度不为0的结点。除了根结点外的终端结点也叫内部结点
父结点（parent）、子结点（child)
兄弟结点（sibling）：具有同一parent的各个结点彼此互为sibling
路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2, ... ,nk,ni是ni+1的父结点。路径所包含边的个数为路径长度
祖先结点（ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点
子孙节点（descendent）：某一结点的子树中的所有结点时这个结点的子孙
结点的层次（level）：即以该结点为根的层数，根节点算1层
树的深度/高度（depth）：树所有结点中最大层次是这棵树的深度
堂兄弟：父结点在同一层的两个结点互为堂兄弟
有序树：树中结点的子树从左到右有次序无法互换
无序树：树中结点的子树没有顺序可以任意交换
丰满树：理想平衡树，要求除最底层外其他层都是满的
森林：若干棵互不相交的树的集合
树的表示方法（存储结构） 顺序存储结构 双亲存储结构
利用结构体数组和字符型数组实现，前者存储结点关系信息，后者在结点是字符型时完成字符到数组下标的映射
typedef struct { int Data; int Parent; } Tree; char Data[maxsize]; Tree tree[maxsize]; 简单情况下也可以用一维数组存储一棵树的信息。数组下标表示树的结点，数组元素的内容表示该结点的Parent
int tree[maxsize]; 注意：树的双亲存储结构在Kruskal算法中有重要应用！
链式存储结构 儿子存储结构
typedef struct Node *Tree; typedef Tree Position; typedef int ElementType; typedef struct{ ElementType Element; Tree child1; Tree child2; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825520d28029194ea08933bf77ccc8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb855efa92cfa28125ab7420968f5c9e/" rel="bookmark">
			input框输入内容限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		限制 input 输入框只能输入纯数字
1、onkeyup = "value=value.replace(/[^\d]/g,'')"
使用 onkeyup 事件，有 bug ，那就是在中文输入法状态下，输入汉字之后直接回车，会直接输入字母
2、onchange = "value=value.replace(/[^\d]/g,'')"
使用 onchange 事件，在输入内容后，只有 input 丧失焦点时才会得到结果，不能在输入时就即时做出响应
3、oninput = "value=value.replace(/[^\d]/g,'')"
使用 oninput 事件，
输入大小写字母、数字、下划线：
&lt;input type="text" οnkeyup="this.value=this.value.replace(/[^\w_]/g,'');"&gt;
输入小写字母、数字、下划线：
&lt;input type="text" οnkeyup="this.value=this.value.replace(/[^a-z0-9_]/g,'');"&gt;
输入数字和点
&lt;input type="text" οnkeyup="value=value.replace(/[^\d.]/g,'')"&gt;
输入中文: &lt;input type="text" οnkeyup="this.value=this.value.replace(/[^\u4e00-\u9fa5]/g,'')"&gt; 输入数字: &lt;input type="text" οnkeyup="this.value=this.value.replace(/\D/g,'')"&gt; 输入英文: &lt;input type="text" οnkeyup="this.value=this.value.replace(/[^a-zA-Z]/g,'')"&gt; 输入中文、数字、英文: &lt;input οnkeyup="value=value.replace(/[^\w\u4E00-\u9FA5]/g, '')"&gt; 输入数字和字母：
&lt;input onKeyUp="value=value.replace(/[\W]/g,'')"&gt; 除了英文的标点符号以外，其他的都可以中文，英文字母，数字，中文标点
&lt;input type="text" οnkeyup="this.value=this.value.replace(/^[^!@#$%^&amp;*()-=+]/g,'')"&gt;
只能输入数字代码(小数点也不能输入)
&lt;input οnkeyup="this.value=this.value.replace(/\D/g,'')" onafterpaste="this.value=this.value.replace(/\D/g,'')"&gt;
只能输入数字,能输小数点.
&lt;input οnkeyup="if(isNaN(value))execCommand('undo')" onafterpaste="if(isNaN(value))execCommand('undo')"&gt;
&lt;input name=txt1 οnchange="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb855efa92cfa28125ab7420968f5c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ebccdc86c9b63d40b581daccfbf0b1/" rel="bookmark">
			2021年8个顶级Node.js框架推荐，Web开发必备干货！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Node.js的特别之处是什么？
市场对Node.js的反应如何？
NPM的趋势
使用Node.js框架的好处
8常用的Node.js框架推荐，Web开发必备！
1. Hapi.js
hapi.js框架的普及
Hapi.js可以用于-
Hapi.js的关键特性
何时使用Hapi.js –
2. Express.js
express.js流行性
Express.js可以用于-
Express.js的主要特性
何时使用Express.js-
3. Nest.js
Nest.js流行度
Nest.js可以用于-
Nest.js 关键特性 –
何时使用Nest.js –
4. Koa.js
Koa.js框架的普及度
Koa.js可以用于-
Koa.js -的主要特性
何时使用Koa.js-
5. Socket.io
socket.io的流行度
Socket.io组成
Socket.io可以用于-
Socket.io-的主要特性
何时使用Socket.io –
6. Meteor.js
js可以用于-
Meteor.js的关键特性 –
何时使用Meteor.js-
谁在用Meteor.js –
7. Adonis.js
adonis.js框架(npm趋势)
Adonis.js可以用于-
Adonis.js 关键特性 –
何时使用Adonis.js –
谁使用Adonis.js –
8. Sails.js
sails.js框架(npm趋势)
Sails.js可以用于-
Sails.js主要特点
何时使用Sails.js –
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ebccdc86c9b63d40b581daccfbf0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d424b7683e1ce0a0157ff5925f7b66/" rel="bookmark">
			oracle创建record,oracle record | 学步园
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、oracle record结构类型，定义方式如下：
1，自定义
type type_name is record(var1 datatype,var2 datatype2...);
例子：
declare
type v_row is record(deptno number(2):=0,--指定默认值
dname varchar2(14),
loc varchar2(13));--定义一个结构类型
v_dept v_row;--定义一个结构变量
begin
v_dept.deptno :=1;
v_dept.dname :='Linux';
v_dept.loc :='linux';
dbms_output.put_line(v_dept.name);
end ;
2，rowtype方式
declare
v_dept dept%rowtype;--定义一个结构变量，其结构与表dept结构一样
begin
select * into v_dept from dept where deptno=10;
dbms_output.put_line(v_dept.dname);
end ;
二、结构应用
declare
type v_row is record(deptno number(2),dname varchar2(14),loc varchar2(13));
v_dept v_row;
begin
v_dept.deptno :=10;
v_dept.dname :='Linux';
v_dept.loc :='linux';
update dept set row=v_dept where deptno=10;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d424b7683e1ce0a0157ff5925f7b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ea0d07fb5dcc2238389112b32c818e/" rel="bookmark">
			linux文件管理和IO重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、文件系统目录结构1.1、文件系统的目录结构1.2 常见的文件系统目录功能1.3 应用程序的组成部分1.4 CentOS 7 以后版本目录结构变化1.5 Linux下的文件类型 2、文件操作命令2.1 显示当前工作目录2.2 绝对路径和相对路径（面试常见问题）2.3 更改目录2.4 文件通配符模式2.5 复制文件和目录2.6 目录操作2.6.1 显示目录树tree2.6.2 创建目录 mkir2.6.3 删除非空目录rmdir 3 文件元数据和节点表结构3.1 inode表结构3.2 目录3.3 cp和inode3.4 rm和inode3.5 mv和inode3.6 硬链接3.7 符号链接或软连接3.8 硬链接和软连接区别（面试题重点） 4、IO重定向和管道4.1 标准输入和输出4.2 I/O重定向4.2.1 标准输出和错误重定向 4.2.2 标准输入重定向4.2.3 tr命令4.2.2.4 把多行重定向 4.3、管道4.3.1 管道4.3.2 tee 命令 5、文件管理练习题 1、文件系统目录结构 1.1、文件系统的目录结构 文件和目录被组织成一个单根倒置树结构文件系统从根目录下开始，用“/“表示根文件系统（rootfs）：root filesystem以.开头的文件为隐藏文件路径分隔为/文件名最长255个字节包括路径在内的文件名称最长4095字节蓝色–&gt;目录 绿色–&gt;可执行文件 红色–&gt;压缩文件 浅蓝色–&gt;链接文件 灰色–&gt;其他文件除了斜杠和NUL，所有字符都有效，但使用特殊字符的目录名称和文件不推荐使用，有些字符需要用引号来引用每个文件都有两类相关数据：元数据 metadata,即属性，数据：data,即文件内容
Linux的文件系统分层结构：FHS===Filesystem Hierarchy Standard
参考文档：http://www.pathname.com/fhs/ 1.2 常见的文件系统目录功能 /boot: 引导文件存放目录，内核文件（vmlinuz）、引导加载器(bootloader,grub)都存放于此目录 /boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录 /bin：所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的程序 /sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序 /lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules) /lib64：专用于x86_64系统上的辅助共享库文件存放位置 /etc：配置文件目录 /home/USERNAME：普通用户家目录 /root：管理员的家目录 /media：便携式移动设备挂载点 /mnt：临时文件系统挂载点 /dev：设备文件及特殊文件存储位置 b: block device，随机访问 c: character device，线性访问 /opt：第三方应用程序的安装位置 /srv：系统上运行的服务用到的数据 /tmp：临时文件存储位置 /usr: universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序 sbin: lib：32位使用 lib64：只存在64位系统 include: C程序的头文件(header files) share：结构化独立的数据，例如doc, man等 local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share /var: variable data files cache: 应用程序缓存数据目录 lib: 应用程序状态信息数据 local：专用于为/usr/local下的应用程序存储可变数据 lock: 锁文件 log: 日志目录及文件 opt: 专用于为/opt下的应用程序存储可变数据 run: 运行中的进程相关数据,通常用于存储进程pid文件 spool: 应用程序数据池 tmp: 保存系统两次重启之间产生的临时数据 /proc: 用于输出内核与进程信息相关的虚拟文件系统 /sys：用于输出当前系统上硬件设备相关信息虚拟文件系统 /selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36ea0d07fb5dcc2238389112b32c818e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ae9d1a8b765d860fe9683e3f04f16d/" rel="bookmark">
			Markdown中的换行符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在需要换行的地方加上&lt;br /&gt;即可，注意中间有空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da21c65cbca3273a0c0100a18c3eaea/" rel="bookmark">
			【Python 脚本报错】AttributeError:‘module‘ has no attribute ‘xxx‘的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、出现的问题 最近在编写Python脚本过程中遇到一个问题比较奇怪：
File "/home/anirrudh/.virtualenvs/ml4t2/local/lib/python2.7/site-packages/numpy/ma/core.py", line 30, in &lt;module&gt; import numpy.core.umath as umath AttributeError: 'module' object has no attribute 'core' Python是脚本正常的，但执行报错”AttributeError: ‘module’ object has no attribute ‘xxx’”，其实是.pyc文件存在问题。
2、问题解决 问题定位：查看import库的源文件，发现源文件存在且没有错误，同时存在源文件的.pyc文件。
问题解决方法：删除该库的.pyc文件，重新运行代码；或者找一个可以运行代码的环境，拷贝替换当前机器的.pyc文件即可。
参照以上通用解决方法并没有解决我的报错，最后发现自己犯了一个大错误，就是自己新建的python文件名字和内置的函数名冲突，修改了python文件的名字就可以正常运行无报错了。
3、pyc文件 3.1 pyc文件介绍 pyc文件，是python编译后的字节码（bytecode）文件。只要你运行了py文件，python编译器就会自动生成一个对应的pyc字节码文件。这个pyc字节码文件，经过python解释器，会生成机器码运行（这也是为什么pyc文件可以跨平台部署，类似于java的跨平台，java中JVM运行的字节码文件）。下次调用直接调用pyc，而不调用py文件。直到你这个py文件有改变。python解释器会检查pyc文件中的生成时间，对比py文件的修改时间，如果py更新，那么就生成新的pyc。
3.2 pyc文件位置 在Python2.x中，为导入的模块创建的 .pyc 文件，会被放置在和.py文件同一目录中；在Python 3.x中，.pyc文件保存在__pycache__目录中；如果你想创建.pyc文件，启动一个Python解释器，只需import你选择的模块，并且根据创建它们的Python解释器的不同而命名。然而，没有为程序的主脚本创建.pyc文件，换句话说，如果在命令行上调用“python myscript.py”，myscript.py将没有.pyc文件。（即 .pyc文件它们是为导入的模块而不是直接运行的文件创建的） 参考：https://www.cnpython.com/qa/60180
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7750a688163196e01ab0cf1a041521d/" rel="bookmark">
			BS架构和CS架构的区别（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接: BS架构和CS架构的区别.
本人觉得该博主解释的例子挺容易懂
1、CS架构
是Client/Service这两个单词的首字母，指的是客户端服务器架构的意思，很多常见的软件都是这种架构。
解释：对于CS架构，最为常见的例子就是网络游戏，比如LOL、WOW如果不联网无法使用，你在软件内的所有操作通过互联网能够传递到其他的玩家身上。
优点：第一，性能较高：可以将一部分的计算机工作放在客户端上，这样服务器只需要处理数据即可。第二，界面炫酷：客户端可以使用更多系统提供的效果，做出更为炫目的效果。
缺点：第一，更新软件：如果推出了新版本，不更新客户端无法登录使用（一部分）。第二，不同设备访问：如果使用其他的电脑，没有安装客户端的话就无法登录软件。
2、BS架构
是Browser/Server这两个单词的首字母，指的是浏览器服务器，是WEB兴起后的一种架构。
解释：现在所有的网站都是BS架构，较为常见的例子有知乎、百度、网易云音乐Web等等，所有只需要通过浏览器即可使用。
优点：第一，更新简洁：如果需要更新内容了，对开发人员而言需要更改服务器的内容，但是对用户而言只需要刷新浏览器即可。第二，多设备同步：所有数据都在网上，只要能够使用浏览器即可登录使用。
缺点：第一，性能较低：相比于客户端应用性能较低，但是随着硬件性能的提升，这个差距在缩小。第二，浏览器兼容：处理低版本的浏览器显示问题一直是开发人员头疼的问题之一，移动设备兼容性较好，ie6已经越来越少人用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15edb7a156397858d1c53b3f978158ed/" rel="bookmark">
			网易云音乐歌单解析易语言源码 附带成品软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍： 先进自己网易云音乐主页获取自己的uid，然后在右上角框框输入uid获取
自己全部歌单，选择一个即可批量下载，大部分api都带在源码里。
网盘下载地址： http://kekewangLuo.net/SrnMezP0lFR
图片： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58bbc72d384ac6458cfbd5aa8b78efc/" rel="bookmark">
			java 可视化冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 效果1. gif2. 开始3. 结束 2. 代码2.1 定制数组 (会触发数组元素变更的事件)2. 绘图程序3. 主方法 1. 效果 （清除原有内容时会有闪屏 后面看看怎么搞）
1. gif （录到结束的）
2. 开始 3. 结束 2. 代码 2.1 定制数组 (会触发数组元素变更的事件) 继承自ArrayList 重载 set 方法 当调用 set 函数时 释放 set事件
public class MyArray&lt;T&gt; extends ArrayList&lt;T&gt; { private List&lt;OnChange&lt;T&gt;&gt; listeners; public MyArray (List&lt;OnChange&lt;T&gt;&gt; listeners, List&lt;T&gt; ori) { super(ori); this.listeners = listeners; doNotify(l -&gt; l.onInit(ori)); } @Override public T set(int i, T ele) { T old = super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58bbc72d384ac6458cfbd5aa8b78efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaaf35550fa4857e31be4c66ff07c0cf/" rel="bookmark">
			Ryu代码解读------simple_switch_13.py 解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		simple_switch_13.py实现传统L2-switch功能 传统的简单二层交换机实现的功能 連接到連接埠的 host 之 MAC 位址，並記錄在 MAC 位址表當中。對於已經記錄下來的 MAC 位址，若是收到送往該 MAC 位址的封包，則轉送該封包到相對應的連接埠。對於未指定目標位址的封包，則執行 Flooding 进阶到SDN的OpenFlow交换机实现功能 對於接收到的封包進行修改或針對指定的連接埠進行轉送對於接收到的封包進行轉送到 Controller 的動作(Packet-In)對於接收到來自 Controller 的封包轉送到指定的連接埠(Packet-Out) 这里其实就是涉及到之前学的之前学的交换机接收到数据报有匹配和无匹配流表 的情况下的两种处理数据包形式，不过这里就是简单的mac_to_port的映射表。 如果是已經存在記錄中的 host：使用 Packet-Out 功能轉送至先前所對應的連接埠如果是尚未存在記錄中的 host：使用Packet-Out 功能來達到 Flooding 图片理解 from ryu.base import app_manager from ryu.controller import ofp_event from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER from ryu.controller.handler import set_ev_cls from ryu.ofproto import ofproto_v1_3 from ryu.lib.packet import packet from ryu.lib.packet import ethernet from ryu.lib.packet import ether_types # 继承ryu.base.app_manager.RyuApp # 基类ryu.base.app_manager.RyuAPP是所有开发APP必备继承的类， # 可以理解成开发APP的环境，而且有了它都不用注册，非常方便 class SimpleSwitch13(app_manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaaf35550fa4857e31be4c66ff07c0cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1819f8ec6ef87b35ae736d811d0cd7b7/" rel="bookmark">
			第一次学习Linux的经验和遇到的问题分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关安装地址 VMware16.0版本下载地址：https://my.vmware.com/en/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_pro/16_0
VMware15.0版本下载地址：
https://my.vmware.com/en/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_pro/15_0
VMware14.0版本下载地址：https://my.vmware.com/en/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0
Ubuntu下载建议国内镜像站下载：
http://mirrors.ustc.edu.cn（中科大镜像网站）
http://mirrors.tuna.tsinghua.edu.cn（清华大学镜像站）
http://mirrors.zju.edu.cn（浙江大学镜像站）
http://mirrors.cqu.edu.cn（重庆大学镜像站）
http://mirror.lzu.edu.cn（兰州大学镜像站）
ps：选择离自己近的大学镜像网站较好
Ubuntu安装 1,第一步，新人就用的经典（根据个人）
2，安装光盘镜像文件。
3，接下来就是虚拟机的安装路径
4，然后指定磁盘容量
5，最后就安装完成了
遇到的蓝屏问题 在第一次安装中，第一次启动虚拟机时，结果立刻蓝屏，然后重启之后，打开虚拟机后就出现了上述图片的情况，在参考了许多大佬的博客后，最后发现可能是win10版本和VMware1.6版本冲突导致的，最后换成VMware1.5后成功解决了问题。写在这里希望在其他人遇到时可以参考借鉴。
这是萌新第一次写博客，有许多不好的地方，希望大佬们可以理解并批评指正，Linux序列以后会一直更新下去，写一下自己的理解和体会，希望可以帮助到别人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e1c398b5d9f313904fcdd1a848e40a/" rel="bookmark">
			带你认识AIOps智能运维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AIOps智能运维 早在2016年之前，著名IT研究机构Gartner在其词库就添加了AIOps[1]这一词条，彼时AIOps是Algorithmic IT Operations的缩写，按照字面理解，AIOps是一种基于算法的运维方式。
清华大学裴丹教授对AIOps的定义是：AIOps将人工智能应用于运维领域，基于已有的运维数据（日志、监控信息、应用信息等），通过机器学习的方式来进一步解决自动化运维没办法解决的问题。AIOps 不依赖于人为指定规则，主张由机器学习算法自动地从海量运维数据中不断地学习，不断地提炼并总结规则。
智能运维（AIOps），根据 Gartner 的最新阐释，意指整合大数据和机器学习能力，通过松耦合、可扩展方式去提取和分析数据量（volume）、种类（variety）和速度（velocity）这三个维度不断增长的 IT 数据，进而为 IT 运维管理产品提供支撑。
云智慧: AIOps与其说是产品，不如说是一种理念和策略。通过以数据为基础、算法为支撑，场景为导向的AIOps平台，为企业现有运维管理工具和管理体系赋予统一数据管控能力和智能化数据分析能力，全面提升运维管理效率。现阶段AIOps的目标不是NoOps，而是BetterOps，通过更高效的运维帮助企业快速洞察人力难以企及的故障和问题，准确预测风险，化被动运维为主动运维。
二、AIOps智能运维的出现 在过去二十年里，人工智能技术的发展间歇性影响了ITOM[2]的进步，而AIOps只是这种影响的最新例证。因此，对于传统企业来说，智能运维并不是一个全新的理念，而是IT运营分析/运维管理（ITOA[3]/ITOM）体系与大数据和人工智能技术结合的产物。AIOps智能运维平台以ITOM/ITOA系统所采集的运维大数据为基础，利用人工智能和机器学习算法对运维数据进行深入分析，涵盖IT监控，应用性能管理、外网监控、日志分析，系统安全等方面。
通过如下一张图就可以看到运维发展的几个阶段，早期的手工运维，到流程化、标准化运维，再到平台化、自动化运维，最后到近十年的 DevOps[4]（研发运营一体化）和 AIOps（智能运维）。
市面上流行的ITOM平台，其核心组件缺少大数据采集、分析和机器学习的能力，需要AIOps平台予以完善。AIOps智能运维平台能够接入不同业务系统、监控系统、管理系统的海量IT数据，并运用各种算法进行快速分析、学习甚至预测。立足于AIOps，IT部门可以获得强大的IT决策和运营管理能力，并能对业务质量和用户体验进行准确检测和持续优化。
三、AIOps智能运维构建 3.1 AIOps能力 AIOps平台主要通过整合分析IT基础设施、APM[5]、NPM[6]、日志、数字化体验监测数据，来提升IT运维流程的效率，而AIOps平台能力的ROI多是基于平均故障接手时间（MTTA）和平均故障修复（MTTR）时间这两个指标的降低进行评估的。
目前 AIOps 的主要应用场景有异常告警、告警收敛、故障分析、趋势预测、异常检测、根因分析等
现阶段，数字化转型的IT挑战在于一方面要控制IT成本，另一方面又要提供支持更高复杂度的运维管理能力。传统ITOM产品在处理海量、多种类和高速数据时常常会遇到极大的压力。更重要的是，这些监控工具无法提供横向业务追踪和根因定位所需的多系统数据。
数字化业务要求IT运维提供更快的响应速度和更高的处理效率，因此AIOps智能运维平台需要提供如下能力：
提供独立、开放的历史/实时数据采集、算法分析平台，整合IT数据和业务指标数据；
提供告警消噪（包括告警抑制、告警收敛等），消除误报或冗余事件；
提供跨系统追踪和关联分析，有效进行故障的根因分析；
设定动态基线捕获超出静态阈值的异常，实现单/多指标异常检测；
根据机器学习结果，预测未来事件，防止潜在的故障；
直接或通过集成启动解决问题的动作；
AIOps将基于自动化运维，将AI和运维很好地结合起来，这个过程需要三方面的知识：
行业、业务领域知识，跟业务特点相关的知识经验积累，熟悉生产实践中的难题。
运维领域知识，如指标监控、异常检测、故障发现、故障止损、成本优化、容量规划和性能调优等。
算法、机器学习知识，把实际问题转化为算法问题，常用算法包括如聚类、决策树、卷积神经网络等。
AIOps具体的能力框架如下所示:
3.2 团队建设 AIOps团队内部人员根据职能可分为三类团队，分别为SRE团队、开发工程师（稳定性保障方向）团队和算法工程师团队，他们在AIOps相关工作中分别扮演不同的角色，三者缺一不可。
SRE能从业务的技术运营中，提炼出智能化的需求点，在开发实施前能够考虑好需求方案，产品上线后能对产品数据进行持续的运营。
开发工程师负责进行平台相关功能和模块的开发，以降低用户的使用门槛，提升用户的使用效率，根据企业AIOps程度和能力的不同，运维自动化平台开发和运维数据平台开发的权重不同，在工程落地上能够考虑好健壮性、鲁棒性、扩展性等，合理拆分任务，保障成果落地。
算法工程师则针对来自于SRE的需求进行理解和梳理，对业界方案、相关论文、算法进行调研和尝试，完成最终算法落地方案的输出工作，并不断迭代优化。
各团队之间的关系图如下所示：
四、AIOps演变路线 在质量保障方面的诉求最迫切，服务运维部先从故障管理领域探索AIOps实践。在故障管理体系中，从故障开始到结束主要有四大核心能力，即故障发现、告警触达、故障定位、故障恢复。故障发现包含了指标预测、异常检测和故障预测等方面，主要目标是能及时、准确地发现故障；告警触达包含了告警事件的收敛、聚合和抑制，主要目标是降噪聚合，减少干扰；故障定位包含了数据收集、根因分析、关联分析、智能分析等，主要目标是能及时、精准地定位故障根因；故障恢复部分包含了流量切换、预案、降级等，主要目标是及时恢复故障，减少业务损失。
故障管理体系核心能力关系图:
其中在故障管理智能化的过程中，故障发现作为故障管理中最开始的一环，在当前海量指标场景下，自动发现故障和自动异常检测的需求甚为迫切，能极大地简化研发策略配置成本，提高告警的准确率，减少告警风暴和误告，从而提高研发的效率。除此之外，时序数据异常检测其实是基础能力，在后续告警触达、故障定位和故障恢复环节中，存在大量指标需要进行异常检测。所以将故障发现作为当前重点探索目标，解决当前海量数据场景下人工配置和运营告警策略、告警风暴和准确率不高的核心痛点。
整个AIOps体系的探索和演进路线如下图所示。每个环节均有独立的产品演进，故障发现-Horae（美团服务运维部与交易系统平台部共建项目）、告警触达-告警中心、故障定位-雷达、故障恢复-雷达预案。
参考文档:
[1] zsfruyi.个人图书馆: http://www.360doc.com/content/19/0418/18/29088297_829711343.shtml ,2019-04-18.
[2] 王雅琪 ,陈思.智能运维系列（一）| AIOps 的崛起与实践: https://www.infoq.cn/article/fqUfkjhecOla1zKUKycN ,2020-6-24
[3] 胡原,锦冬,俊峰,长伟,永强.AIOps在美团的探索与实践——故障发现篇:https://tech.meituan.com/2020/10/15/mt-aiops-horae.html ,2020-10-15
AIOps: 智能运维, Algorithmic IT Operations ↩
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e1c398b5d9f313904fcdd1a848e40a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa40d1bb3b9be32b4001279a64f0f7d/" rel="bookmark">
			Win8 10截图快捷键  whiteboard 微软白板虚拟画布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，类似于qq微信钉钉，快捷键截图，如果电脑没有安装这些软件，如何实现快捷键截图？win10 有内置类似的功能。
1、普通截图，框选快捷键
Win+Shitf+s组合按键
可以尝试下很方便
2、全屏截图快捷键
Win+Printscreen组合键
Win+W组合键
屏幕右下角，弹出可选择截屏、裁剪、编辑等等
如上图，可以安装或启动微软的whiteboard软件
非常方便、简单的画布软件，易操作。
3、全屏截图快捷键
PrintScreen组合键，截图保存在剪切板中，可以粘贴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377168a55d47f2abb97d3c9277ac416e/" rel="bookmark">
			C#中linq表达式用法的归纳总结(上)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从事了将近两年的.net core开发，给我印象最深的，无疑就是C#中linq表达式了。
linq表达式，全称语言集成查询，语言集成查询 (LINQ) 是一系列直接将查询功能集成到 C# 语言的技术统称。 数据查询历来都表示为简单的字符串，没有编译时类型检查或 IntelliSense 支持。 此外，需要针对每种类型的数据源了解不同的查询语言：SQL 数据库、XML 文档、各种 Web 服务等。 借助 LINQ，查询成为了最高级的语言构造，就像类、方法和事件一样。
以上是微软官方给的定义，平日里我对linq使用的比较多的一般就是针对集合和数据库的增删改查，废话不多说，直接上代码
where用法 官方定义：where 子句用在查询表达式中，用于指定将在查询表达式中返回数据源中的哪些元素。 它将一个布尔条件（谓词）应用于每个源元素（由范围变量引用），并返回满足指定条件的元素。 一个查询表达式可以包含多个 where 子句，一个子句可以包含多个谓词子表达式。
简单的说，where就是查询用的，根据特定的表达式获取自己想要的结果
List&lt;string&gt; testList = new List&lt;string&gt;() { "apple", "watermelon", "pear" }; var result = testList.Where(c =&gt; c.Equals("apple")).FirstOrDefault(); // Output // apple select用法 官方定义：在查询表达式中，select 子句指定在执行查询时产生的值的类型。 根据计算所有以前的子句以及根据 select 子句本身的所有表达式得出结果。
官方的定义不容易理解，例如有一个student列表，我想把student列表的所有name转换成一个List&lt;string&gt;，这个时候 select就可以派上用场了
List&lt;Student&gt; students = new List&lt;Student&gt;() { new Student() { Name = "xiaoming", Age = 10 }, new Student() { Name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377168a55d47f2abb97d3c9277ac416e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c80cd4ebd7206c08de22972e797067/" rel="bookmark">
			oracle v.,Oracle VARRAY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle VARRAY
The SQL Anywhere 16 - Oracle ODBC driver supports the use of Oracle VARRAY in stored procedures. Using VARRAY in upload scripts
(upload_insert, upload_update, and upload_delete) that are written in stored procedures may improve performance of the MobiLink
server, compared with upload scripts written in stored procedures that do not use VARRAY. Simple SQL statements such as INSERT,
UPDATE and DELETE without stored procedures usually offer the best performance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c80cd4ebd7206c08de22972e797067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e99e36d642162526fe35951bf8c0067/" rel="bookmark">
			在iframe下存储不上cookie，nginx配置iframe和主窗体同源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在非同源的iframe存储不上cookie 需求描述: 公司的系统A需要嵌入公司系统B的页面。 系统A为C#程序，启动在IIS。在系统A中一个页面通过 iframe嵌入系统B的页面，系统B是shiro的安全框架，前后端接口身份验证通过后端在response设置cookie存 储上Jsessionid。 在谷歌浏览器中存在保护机制，当不同源的页面时无法在子页面存储cookie。导致在嵌套页面无 法正常访问接口。 解决方法： 在请求头加入p3p（可自行百度）没有成功。 最后通过测试发现如果是同源的界面则可以存储上cookie。 同源策略（可自行查询 跨域相关知识 简单说就是 http协议 + IP + 端口 + 域名都要相同才可以算是同源）。最 后通过nginx配置转发代理实现同源解决问题。 // nginx配置 程序B的配置 server { listen 10000; #location ~ ^/login[^.]+ { #location ~ ^/[a-z]+/login$ { location ^/(?!(pms|platform))[^/]+/login$ { rewrite .* /login/login.html; } location / { add_header Cache-Control no-cache; root D:\pms-hzj\hzx-front-pc; index login.html; } location /pms/teamwork { proxy_pass http://192.168.0.191:12002/pms-teamwork; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; } location /pms { proxy_pass http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e99e36d642162526fe35951bf8c0067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28df835a4086b56a5dc9666c61389a31/" rel="bookmark">
			vue中使用import引入的（方法）function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3种使用import引入的方法
vue3废弃了过滤器的写法，但是很多时候我们对数据进行处理的时候是需要一些转化的，比如我最近遇到的时间转化的问题。刚开始我的做法是
然后在用的地方引入
一开始的时候我在用的地方直接用了
然而。。控制台报错是这样的
研究一番之后发现是html里面的内容引用的function必要要export default之后才能使用，所以vue3的话就是把import的方法return 出去就可以
vue2的话就是在methods里面声明一下也可以
这样就可以在html中使用import的方法啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e066c9c1eeb4b93d88eac5aae454fff/" rel="bookmark">
			排障集锦：九九八十一难之第二十九难！Add correct host key in /root/.ssh/known_hosts to get rid of this message.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象：
ssh 远程到远端服务器报错
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:NHg/pDwRdtQThZzY3Z4Uwq/Rz93FgmL3UdBAFleWFWk. Please contact your system administrator. Add correct host key in /Users/yuanting/.ssh/known_hosts to get rid of this message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e066c9c1eeb4b93d88eac5aae454fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1222fffe8d765642a3c2410502fa5f/" rel="bookmark">
			RIP路由协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RIP简介 RIP是Routing Information Protocol（路由信息协议）的简称，它是一种较为简单的内部网关协议（Interior Gateway Protocol）
RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的距离。设备到与他直连网络的设备跳数为0，然后每经过一个三层设备跳数增加1，也就是度量值等于从本网络到达目网络间的三层设备数量，但并不等于所经过的网段数
RIP通过UDP报文进行路由信息的交换，使用的端口号为520。所以它又是一个不可靠的路由协议
由于RIP的实现较为简单，在配置和维护管理方面也远比OSPF和IS-IS容易，因此RIP主要应用于规模较小的网络中，例如校园网以及结构较简单的地区性网络。对于更为复杂的环境和大型网络，一般不使用RIP协议
RIP包括RIP-1和RIP-2两个版本，RIP-2对RIP-1进行了扩充，使其更具有优势
二、RIP原理 RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离
在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用
RIP协议有两种更新机制：
一是定期更新，二是触发更新。定期更新是根据设置的更新计时器定期发送RIP路由通告。而触发更新是RIP路由器一旦察觉到网络变化，就尽快甚至是立即发送更新报文，而不等待更新周期结束。只要触发更新的速度足够快，就可以大大地防止“计数到无穷大”的发生，但是这一现象还是有可能发生的
无论是定期更新，还是触发更新，RIP路由的更新规则如下：
如果更新的某路由表项在路由表中没有，则直接在路由表中添加该路由表项如果路由表中已有相同目的网络的路由表项，且来源端口相同，那么无条件根据最新的路由信息更新其路由表如果路由表中已有相同目的网络的路由表项，但来源端口不同，则要比较它们的度量值，将度量值较小的一个作为自己的路由表项如果路由表中已有相同目的网络的路由表项，且度量值相等，保留原来的路由表项 三、RIP运行例子 1. 在一开始，所有路由器中的路由表只有自己所直接连接的网络的路由表项信息。但不是RIP路由表项，是直连路由表项，无需下一跳（用“--”表示），度量“距离”也均为0 ，各路由器的初始路由表如图所示，均只有两条直连网络的路由表项
2. 接下来，各路由器就会按设置的周期（默认为30秒）向邻居路由器发送路由更新了。具体哪个路由器会先发送路由更新，取决于哪个路由器先开了。现假设路由器R2先收到来自路由器R1和R3的路由更新，然后就更新自己的路由表，如图所示。从中可以看出，它新添加了分别通过R1和R3到达10.0.0.0网络和30.0.0.0网络的路由表项，度量值均为1，因为它只经过了一跳
3. R2更新自己的路由表后，会把完整的路由表发给邻居路由器R1和R3。路由器R1和R3分别再进行更新。根据前面介绍的RIP路由表更新的规则可以知道，R1对每项度量进行加1，得到的路由表如图所示
4. 然后R1再把图8-9所示的路由表与自己原来的路由表进行比较，凡是新添加的，和度量值小于等于原来的路由表项均将更新，度量值更大的路由表项将忽略更新。经过行比较发现有两条新的路由表项，其目的网络分别为30.0.0.0和40.0.0.0，直接在路由表中添加。而原来已有的两条10.0.0.0和20.0.0.0表项，发现路由度量（“距离”）值1比原来的0还大，忽略更新，结果就得到R1更新后的路由表，如图所示
四、其他 RIP封装在UDP之上，端口为520
组播，为了降低那些没有监听RIP Version 2 报文的主机的不必要的开销，IP多目传送地址被用于定时广播。IP 多目地址是224.0.0.9
作者：语文小子
链接：https://www.jianshu.com/p/f542d5b415a1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17c905e776669d1d82fb2014504cece/" rel="bookmark">
			C&#43;&#43;——引入python函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加环境 #include&lt;Python.h&gt; 2、添加库路径 3、函数剖析 //初始化python解释器
void Py_Initialize(void);
//检查是否初始化成功
int Py_IsIntialized(void);
//导入python模块
PyObject* PyImport_ImportModule(char *name);
//执行Python代码
int PyRun_SimpleString(const char *command);
//构建参数列表， 把C类型转化成Python支持类型
PyObject* Py_BuildValue(char* format, ...)
//储存python导入的方法字典
PyModule_GetDict
//获取方法
PyObject* PyDict_GetItemString(PyObject*, const char*);
4、实例运用 如下有一个temp.py（pyhon文件）
def hello(name): print("hello world, ", name) return 0 #include &lt;Python.h&gt; void importPython() { PyObject *pName = NULL; PyObject *pModule = NULL; PyObject *pFunc = NULL; PyObject *pDict = NULL; PyObject *pArgs = NULL; Py_Initialize(); if(!Py_IsInitialized()) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e17c905e776669d1d82fb2014504cece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2afe9791be711ad66291c279523091c/" rel="bookmark">
			oracle varray长度,Oracle VARRAY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle VARRAY
iAnywhere Solutions 12 - Oracle ODBC 驱动 支持在存储过程中使用 Oracle VARRAY。与在存储过程编写的上载脚本(upload_insert、upload_update 和 upload_delete)中不使用
VARRAY 相比，在存储过程编写的上载脚本中使用 VARRAY 可以提高 MobiLink 服务器的性能。通常不具有存储过程的简单 SQL 语句(如 INSERT、UPDATE 和 DELETE)可以提供最佳性能。但是，使用存储过程(包括 VARRAY
技术)，可以有机会应用简单语句不具备的业务逻辑。
以下是使用 VARRAY 的简单示例：
创建一个包含 3 列名为 my_table 的表。
create table my_table ( pk integer primary key, c1 number(20), c2 varchar2(4000) )
使用 VARRAY 创建用户定义的收集类型。
create type my_integer is varray(100) of integer;
create type my_number is varray(100) of number(20);
create type my_varchar is varray(100) of varchar2(8000);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2afe9791be711ad66291c279523091c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea324ec3eeb95f00326c7f76179204f/" rel="bookmark">
			pytorch简单代码实现deep dream图（即CNN特征可视化 features visualization）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文给出完整代码实现CNN特征的可视化输入图像，也就是简单的deep dream图，有助于更好的理解CNN工作原理，并掌握用梯度上升法生成满足要求输入图像的技术。更清晰美观的deep dream图需要加入一些其他技巧，可以参考我另一篇文章。
1，原理 深度网络的常规工作过程是，给定输入样本及标签，前向处理后的输出结果和标签计算出某种损失函数，再由损失函数反向传播求网络各参数的梯度，根据此梯度更新参数，以使损失函数减小，逐渐训练得到一个逼近标签的网络。
有趣的是，我们也可以反向思维，固定网络的参数不变，而是优化输入图像。根据某项指标求得输入图像的梯度，再根据此梯度优化输入，就可以得到满足要求的输入图像。由于往往需要最大化某种指标，与通常最小化损失函数的梯度下降法不同，所以这种方法也被称为梯度上升法。在程序实现上，为了利用SGD，Adam等成熟的梯度下降优化算法，我们只需要给指标加个负号，也就变成和梯度下降一样了。
如果我们把特征图的某个部分的均值作为最大化的指标，此时就可以得到使指定特征图部分最大响应的输入图，也就能够直观的看出指定部分的特征图到底处理的是什么类型的特征。这个指定的特征图部分可以是某个层，也可以是某个层的某个通道，甚至也可以是某个通道上某个元素。我们先来看单个元素的情况：
2，指定特征图单个元素的最大响应输入图像可视化 import torch import torchvision.models as models import cv2 import time t0 = time.time() model = models.resnet18(pretrained=True).cuda() batch_size = 1 for params in model.parameters(): params.requires_grad = False model.eval() def hook(module,inp,out): global features features = out data = torch.rand(batch_size,3,224,224).cuda() data.requires_grad=True mu = torch.Tensor([0.485, 0.456, 0.406]).unsqueeze(-1).unsqueeze(-1).cuda() std = torch.Tensor([0.229, 0.224, 0.225]).unsqueeze(-1).unsqueeze(-1).cuda() unnormalize = lambda x: x*std + mu normalize = lambda x: (x-mu)/std #optimizer = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ea324ec3eeb95f00326c7f76179204f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de3c10dd58cb57f823d0c723b67a722/" rel="bookmark">
			十分钟读完《金字塔原理》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十分钟读完《金字塔原理》 作者简介
芭芭拉·明托 （Barbara Minto）
哈佛商学院第一批女学员之一，麦肯锡顾问公司有史以来第一位女性顾问。一个致力于为人们提供训练思考、表达和解决问题的逻辑的专业咨询培训人士，1973年成立个人公司-明托国际公司(Minto International Inc.)，为社会各界人士讲授金字塔原理，该理论应用遍及美国、欧洲、澳大利亚、新西兰等国家和地区绝大部分公司和管理咨询公司。
推荐语
比起欣赏一朵花漫溢的馨香，我们需要更加关注它盛开的过程。
一些人在表达和思考问题时，容易思维混乱，分不清主次重点，而这本书可以提供有序高效的解读论和方法论——金字塔原理，从而帮助你提炼逻辑思考和与人高效沟通的能力，进而让你更好的解决学习和生活中的问题。
这本书依托于金字塔原理展开，分为四个部分:
· 表达的逻辑: “说”，使用金字塔原理的原因和具体构建方法;
· 思考的逻辑:“想”，使用金字塔原理过程中的应用逻辑要素;
· 解决问题的逻辑:“做”，在实例中界定、解构、分析和解决问题;
· 演示的逻辑:“表演”，在PPT演示和文字中呈现金字塔;
第一部分: 表达的逻辑，使用金字塔原理过程中的应用逻辑要素
I. 使用金字塔原理的原因——逻辑关联
· 从大脑思考逻辑的角度看， 人们思考的方式倾向于对获取的信息进行自动关联分类; 而对于没有逻辑关联的信息则很容易被大脑忽略。因此，采用金字塔结构表达，加强逻辑关联，能让我们的交流和沟通更加高效。
· 采用金字塔结构的目的——使读者更加容易读懂你的文章。
II. 概述金字塔结构的构建原理:
1) 归类分组，将思想组织成金字塔。
2) 找出逻辑关系，抽象概括。
3) 自上而下表达，结论先行。
图例:
III. 写作表达准备——梳理逻辑关系（纵向&amp;横向）
在写作伊始，往往脑中的想法还是模糊不成形的，因此在构建金字塔结构之前，首先我们需要做的是梳理想要表达思想之间的逻辑关系。
这里所说的逻辑关系包括纵向关系和横向关系。所谓的纵向关系即疑问/回答式的表达方式，简单来说，就是让读者产生“为什么会这样”“怎么才能这样”的想法。这种类似多米诺骨牌式的寻疑致理的层层递进表述方式，就如同带领从山顶一步一步走到山脚的纵向过程。而横向关系意味着在某一层次的表述需要能够承上启下，确保上下不同层次的内容合乎逻辑，就好像建立下山过程中不同路线的休息站。
IV. 序言的书写方式——讲故事
1) 此外，我们需要在构建金字塔结构之前考虑序言的书写方式。因为，在我们试图向读者传递信息并引起他们问题之前，我们需要介绍清楚相关的背景资料，以此引导读者了解你的思维过程，并且引起读者的兴趣。
2) 序言应当介绍四要素: 介绍背景、指出冲突、引发疑问、给出答案。
V. 如何构建金字塔——自上而下法&amp;自下而上法
· 自上而下法，即从金字塔的顶端开始，向下逐步构建不同的层次。换言之，从文章的主题开始，一步一步扩展。
· 自下而上法，即身为作者的你在落笔前还不能确定文章的主题。列出你想表达的所有思想要点，找出各个要点间的逻辑关系，得出结论。(此方法也比较适用于资料的重新整合)
第二部分: 思考的逻辑，应用金字塔原理过程中的逻辑要素
I. 如何逻辑行文——演绎推理和归纳推理
a. 演绎推理——线性推理/三段论:大前提+小前提=结论
图例:
b. 归纳推理——概括共性: 小前提+小前提+小前提=结论
图例:
c. 行动优先，解释在后——先给出结论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de3c10dd58cb57f823d0c723b67a722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f682983d71ded9ae1b4f4f84ee3bc13/" rel="bookmark">
			Redis集群-哨兵（笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哨兵 定义： 哨兵（sentinel）是一个分布式系统，用于对主从复制的每一台服务器进行监控，当出现故障投票选出新的master其他slave进行连接。
相关配置 port 26379 (sentinel的端口)
sentinel monitor mymaster 127.0.0.1 6379 2
(mymaster是名字 必须统一，127是master的地址，6379是端口 ，2指的是sentinel为3个的时候2个认为挂掉的了就是挂掉了)
sentinel down-after-millisecands mymaster 3000
sentinel paralled-syncs mymaster 1 （1是挂了后同步越大服务器压力越大）
sentinel failover-time mymaster 18000 （挂了后同步的超时时间）
3个哨兵这个配置文件复制3份修改一下就可以
架构图 哨兵们相互通信 每一个哨兵都监视所有的节点
工作原理 监控阶段 step1. sentinel1连接master
step2.master返回所有slave节点信息
step3.sentinel1 分别连接master下的所有slave
多哨兵都重复之前1-3的步骤
在sentinel1连接后，sentinel2连接的时候会从master中获取master已经连接sentinel1
这时候sentinel1与sentinel2开始通信，发布订阅模式消息共享
通知阶段 保持通信
故障转移 step1.发现异常
step2.竞选sentinel负责人 投票选出
step3.sentinel负责人选取新的master
（在线的，响应快的，原master断开时间短的 slave offset大的都一样选runid小的）
step4.其他slave
连接新的master
故障恢复 故障恢复的时候已经有新的slave担任master 原来挂掉的master变成slave 去连接新上任的master
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c231f5747d87e2b45ce4b08f8041497/" rel="bookmark">
			关于学生课程分数的SQL查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 建表 有如下4张表：
学生表：student(s_id,s_name,s_birth,s_sex) ——学生编号,学生姓名, 出生年月,学生性别
课程表：course(c_id,c_name,t_id) ——课程编号, 课程名称, 教师编号
教师表：teacher(t_id,t_name)——教师编号,教师姓名
成绩表：score(s_id,c_id,s_s_score) ——学生编号,课程编号,分数
1.2 学生表 -- 1 创建表格 CREATE TABLE IF NOT EXISTS student( s_id VARCHAR(20) not null, s_name VARCHAR(20) NOT NULL, s_birth VARCHAR(20) NOT NULL, s_sex VARCHAR(10) NOT NULL, PRIMARY KEY(s_id) ) engine=innodb default charset=utf8; -- 2 插入数据 insert into student(s_id,s_name,s_birth,s_sex) values('01' , '赵雷' , '1990-01-01' , '男'); insert into student(s_id,s_name,s_birth,s_sex) values('02' , '钱电' , '1990-12-21' , '男'); insert into student(s_id,s_name,s_birth,s_sex) values('03' , '孙风' , '1990-05-20' , '男'); insert into student(s_id,s_name,s_birth,s_sex) values('04' , '李云' , '1990-08-06' , '男'); insert into student(s_id,s_name,s_birth,s_sex) values('05' , '周梅' , '1991-12-01' , '女'); insert into student(s_id,s_name,s_birth,s_sex) values('06' , '吴兰' , '1992-03-01' , '女'); insert into student(s_id,s_name,s_birth,s_sex) values('07' , '郑竹' , '1989-07-01' , '女'); insert into student(s_id,s_name,s_birth,s_sex) values('08' , '王菊' , '1990-01-20' , '女'); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c231f5747d87e2b45ce4b08f8041497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84493633843d627419963afd1c4e50b4/" rel="bookmark">
			视觉SLAM入门十四讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视觉SLAM入门十四讲 写在前面的话什么是视觉SLAM视觉SLAM中所使用的摄像头传感器单目摄像头双目摄像头深度摄像头 经典视觉SLAM框架 写在前面的话 考研期间迷上了SLAM，买来了高翔、张涛等著的《视觉SLAM十四讲——从理论到实践》，感悟颇深，作文记之。愿心之所向，梦亦同趋。
什么是视觉SLAM SLAM是Simulataneous Location and Mapping的缩写，中文译为“同时定位与地图构建”。通俗来讲就是两个部分，“定位”与“建图”。同时此处所用的传感器主要为摄像头，故称为视觉SLAM。
视觉SLAM中所使用的摄像头传感器 如上所讲，视觉SLAM需要实现的两个部分——“定位”与“建图”，即带有哲学性质的两个提问，“我在哪里？”，“我周围是怎么样？”。通过眼睛观察，人类可以轻而易举地回答这两个问题，而机器人要实现这个目标，也需要有眼睛，传感器，就是机器人的眼睛。而安装于环境中的传感器，对环境的要求比较高，实际应用中，机器人的使用环境往往是多种多样的，这就意味着，使用携带式的传感器是我们重点关心的一个问题。而视觉SLAM中所需要的摄像头，需要以一定速率拍摄周围的环境，形成一个连续的视频流。按照工作方式不同，摄像头可以分为单目摄像头（Monocular）、双目摄像头（Stereo）以及深度摄像头（RGB-D）。下面对着三种摄像头以及它们的工作方式分别进行介绍。
单目摄像头 顾名思义，单目摄像头只有一个镜头。而摄像头所拍摄的图像是三维图像在二维世界的投影，要想恢复三维结构，必须移动摄像头。通过一个很简单的生活常识：近处的物体移动得快，看起来大，远处的物体移动地慢，看起来小。 我们可以通过摄像头在移动时产生的视差来对物体远近进行相对的定量的判断。需要注意此处得到的物体远近是相对的，可以通过特摄剧来理解，我们无法判断是怪兽摧毁了高楼大厦，还是穿着怪兽皮套的演员摧毁了高楼模型。进一步理解，我们可以认为，单目摄像机得到的图像，是将真实的三维世界的投影乘以一个因子进行了缩放，这个因子可称为尺度，由于这个尺度是不确定的，故单目摄像头具有尺度不确定性。但要注意，单目摄像机可以确定深度，但需要平移之后才能计算深度，加上无法确定尺度，这给"SLAM“带来了很大的麻烦。
双目摄像头 双目摄像头，双目摄像头是由两个单目摄像头组成，该两个单目摄像头的距离是已知的，我们称他为基线，据此通过复杂的计算可以得到深度，但此处的计算是通过软件算法实现的，比较占用系统资源，需要使用GPU、FPGA等设备来进行加速。计算量是双目摄像头目前最主要的问题。
深度摄像头 深度摄像头即RGB-D摄像头，它最大的特点是通过红外结构或Time-of-Flight(ToF)原理，笔者参加全国大学生智能汽车竞赛时曾使用过ToF模块进行距离测量，效果比较好。深度摄像头通过主动发出红外光并接收返回的光，来得到物体与摄像头之间的距离。通过物理的方式进行深度的获取，在对比双目摄像头来说有较大的优势，可以很好地节省计算资源。
经典视觉SLAM框架 经典视觉SLAM的结构框架由以下步骤组成：
传感器信息读取。传感器是机器人的眼睛。在视觉SLAM中，主要是对相机获取的图像进行预处理。前端视觉里程计（VO）。 视觉里程计的任务是估算相邻图像间相机的运动，以及局部地图是如何的。又称为前端。后端（非线性化）优化。 后端接收前端获取的相机位姿信息以及回环检测的信息，进行优化、处理，得到较好的全局地图。回环检测。 判断机器人之前是否到过同样的位置。
经典视觉 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f111318ec07de6519ebe22f7f7f0b0/" rel="bookmark">
			oracle 错误06512,处理ORA-06512错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理ORA-06512错误&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;
在BDUMP目录下追踪文件中发现如下错误：
*** ACTION NAME:(AUTO_SPACE_ADVISOR_JOB) 2008-06-10 22:00:03.413
*** MODULE NAME:(DBMS_SCHEDULER) 2008-06-10 22:00:03.413
*** SERVICE NAME:(SYS$USERS) 2008-06-10 22:00:03.413
*** SESSION ID:(260.22625) 2008-06-10 22:00:03.413
*** 2008-06-10 22:00:03.413
ORA-12012: error on auto execute of job 8887
ORA-20000: ORA-20000: Content of the tablespace specified is not permanent or tablespace name is invalid
ORA-06512: at "SYS.PRVT_ADVISOR", line 1624
ORA-06512: at "SYS.DBMS_ADVISOR", line 186
ORA-06512: at "SYS.DBMS_SPACE", line 1338
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f111318ec07de6519ebe22f7f7f0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c681d2a5835f8171f56cb642eefbbe/" rel="bookmark">
			报错：＜%@ taglib prefix=“c“ uri=“http://java.sun.com/jsp/jstl/core“ %＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 报错：&lt;%@ taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt;
方法： 找到tomcat的这个路径下的两个文件2. 把这两个文件导入到这个路径下
添加一下
示例：
开发工具：IDEA
把鼠标停留在&lt;c:位置，alt+Enter，快速导包
然后我的就导入下边这个包
&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core_1_1" %&gt; &lt;c:forEach items="${users}" var="user" varStatus="s"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox"&gt;&lt;/td&gt; &lt;td&gt;${s.count}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.gender}&lt;/td&gt; &lt;td&gt;${user.age}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;td&gt;${user.qq}&lt;/td&gt; &lt;td&gt;${user.email}&lt;/td&gt; &lt;td&gt;&lt;a class="btn btn-default btn-sm" href="${pageContext.request.contextPath}/findUserServlet?id=${user.id}"&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class="btn btn-default btn-sm" href="javascript:deleteUser(${user.id});"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;%-- &lt;a class="btn btn-default btn-sm" href="${pageContext.request.contextPath}/delUserServlet?id=${user.id}"&gt;删除&lt;/a&gt;&lt;/td&gt;--%&gt; &lt;/tr&gt; &lt;/c:forEach&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02c6d815f1eb5aa23f77eebb6395f3a/" rel="bookmark">
			oracle record 类型,Pl/SQL 复合类型 RECORD 用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、复合数据类型：内部存在分量的数据类型。
复合数据类型在oracle内部是不自动提供的，需要自己定义。
二、复合数据类型的种类：
1、记录型：内部很多分量，每个分量都有自己的名字及数据类型。类似于结构体
2、PLSQL表类型：内部存在两个分量，分别叫做主键和列。而且主键必须是binary_integer类型的。
类似于数组。
三、记录型的使用。
1、记录型的创建：
TYPE 记录类型名 IS RECORD (分量列表);
例：type emp_record_type IS RECORD (empno NUMBER,ename VARCHAR2(20),sal emp.job%TYPE);
说明：1、该语句写在Declare部分，而且有效范围只能是当前的块。
2、分量列表格式为：分量名　数据类型，每个分量之间用,分割。
2、记录型变量的创建：
变量名 记录类型名；
emp_record emp_record_type;
3、引用变量：
引用其中的分量：变量名.分量名 ， 如：emp_record.ename
引用整个记录型变量。
例：使用记录类型，显示员工7839的姓名，职位，工资，部门编号。
DECLARE
TYPE emp_record_type IS RECORD (ename emp.ename%TYPE,job emp.job%TYPE,sal emp.sal%TYPE,
deptno emp.deptno%TYPE);
emp_record emp_record_type;
BEGIN
SELECT ename,job,sal,deptno INTO emp_record FROM emp WHERE empno= 7839;
--注意：select后面的列名列表一定要和记录数据类型的分量名列表在个数及数据类型上一致。
dbms_output.put_line(emp_record.ename||emp_record.job||emp_record.sal||emp_record.deptno);
END;
练习：使用记录类型，查询部门20中工资最低的人员姓名，工资。
DECLARE
TYPE emp_record_type IS RECORD (ename emp.ename%TYPE,sal emp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02c6d815f1eb5aa23f77eebb6395f3a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/186/">«</a>
	<span class="pagination__item pagination__item--current">187/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/188/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>