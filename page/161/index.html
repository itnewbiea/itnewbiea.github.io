<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eac871ad82a904fa279ae33118fefe5/" rel="bookmark">
			2021中国大学MOOC 机器学习(温州大学) 最新中国大学MOOC满分章节测试答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 引言课后测试
1、 问题:哪一个是机器学习的合理定义？
选项：
A:机器学习从标记的数据中学习
B:机器学习能使计算机能够在没有明确编程的情况下学习
C:机器学习是计算机编程的科学
D:机器学习是允许机器人智能行动的领域
答案: 【机器学习能使计算机能够在没有明确编程的情况下学习】
2、 问题:一个计算机程序从经验E中学习任务T，并用P来衡量表现。并且，T的表现P随着经验E的增加而提高。假设我们给一个学习算法输入了很多历史天气的数据，让它学会预测天气。什么是P的合理选择？
选项：
A:计算大量历史气象数据的过程
B:正确预测未来日期天气的概率
C:天气预报任务
D:以上都不
答案: 【正确预测未来日期天气的概率】
3、 问题:回归问题和分类问题的区别是什么？
选项：
A:回归问题有标签，分类问题没有
B:回归问题输出值是离散的，分类问题输出值是连续的
C:回归问题输出值是连续的，分类问题输出值是离散的
D:回归问题与分类问题在输入属性值上要求不同
答案: 【回归问题输出值是连续的，分类问题输出值是离散的】
4、 问题:以下关于特征选择的说法正确的是？
选项：
A:选择的特征越多越好
B:选择的特征越少越好
C:选择的特征需尽可能反映不同事物之间的差异
D:以上说法均不对
答案: 【选择的特征需尽可能反映不同事物之间的差异】
5、 问题:一个包含n类的多分类问题，若采用一对剩余的方法，需要拆分成多少次？
选项：
A:1
B:n-1
C:n
D:n+1
答案: 【n-1】
6、 问题:机器学习方法传统上可以分为( )类。
选项：
A:3
B:4
C:7
D:2
答案: 【3】
7、 问题:哪些机器学习模型经过训练，能够根据其行为获得的奖励和反馈做出一系列决策？
选项：
A:监督学习
B:无监督学习
C:强化学习
D:以上全部
答案: 【强化学习】
8、 问题:机器学习这个术语是由( )定义的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eac871ad82a904fa279ae33118fefe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6efe56348d258abd577737cace49fe/" rel="bookmark">
			VUE中eslint报错： Expected linebreaks to be ‘LF‘ but found ‘CRLF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个的原因：windows 环境下， git 在我们 pull 代码的时候，会自动识别当前的系统环境。将原本的（linux/unix）换行改成对应系统的，在我们提交代码的时候又会转成远程系统环境的（Linux/unix）,然后又装了 eslint，默认就是使用 LF，所以就会报这个错误
各种环境下换行符格式
window：CRLF(\r\n 或者^M\n)
mac: CR(\r 或^M)
linux/unix: LF(\n)
解决方式：
1. 在 vscode 的文件代码底部的 CRLF 手动切成 LF, 这样只能让eslint暂时不报错。但是实际上我们 再次pull 下来的时候，git 还是会自动把所有文件全部转成 CRLF，也还是会有报错信息
2. eslint 中的规则配置，在 window 环境下关闭换行符校验，让它提交的时候自动把 CRLF 转成 LF 就可以（貌似我们都没有根本解决这个问题）
"linkbreak-style":["off","windows"] 3. 从 git 拉取代码的时候入手，让 git 依据远程的代码的换行符（LF）pull，不再根据系统去转换格式。同时配置 vscode 换行符为 LF,我的做法是配置好 git 的拉取格式，再把本地原仓库整个删了，然后重新远程拉取一份代码。这样就可以了，命令如下：
git config --global core.autocrlf 有三个配置（看情况选择，我选择了 input）
true： push 的时候自动将 crlf 转成 LF， pull 的时候转成 crlf（这条配置就需要配置eslint关掉window环境下的换行符校验） git config --global core.autocrlf true input：push 的时候自动将 crlf 转成 LF， pull 代码的时候不自动将 LF 转成 crlf（这条配置，不需要配置eslint，代码格式与远程保持一致，我是用这个） git config --global core.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c6efe56348d258abd577737cace49fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0978d35e488518ec889a32793c037546/" rel="bookmark">
			2021图机器学习有哪些新突破？麦吉尔大学博士后一文梳理展望领域趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选自Medium
作者：Michael Galkin
机器之心编译
机器之心编辑部
图机器学习领域的热门趋势和重大进展。
又一年又接近尾声，还有三天我们就要告别 2021 年了。
各个 AI 领域也迎来了年度总结和未来展望，今天来讲一讲 AI 圈始终大热的图机器学习（Graph ML）。
2021 年，图机器学习领域涌现出了成千上万篇论文，还举办了大量的学术会议和研讨会，出现了一些重大的进展。2022 年，图机器学习领域又会在哪些方面发力呢
Mila 和麦吉尔大学博士后研究员、专注于知识图谱和图神经网络（GNN）研究的学者 Michael Galkin 在一篇博客中阐述了他的观点。在文中，作者对图机器学习展开了结构化分析，并重点介绍了该领域的主要进展和热门趋势。作者希望本文可以成为图机器学习领域研究者的很好的参考。
本图由 ruDALL-E 生成。
作者主要从以下 12 个部分进行了详细的梳理：
图 Transformers + 位置特征
等变 GNNs
分子的生成模型
GNNs + 组合优化 &amp; 算法
子图 GNN：超越 1-WL
可扩展和深度 GNN：层数 100 及以上
知识图谱
利用 GNN 做很酷的研究
新的数据集、挑战和任务
课程和书籍
库和开源
如何保持更新
图 Transformers + 位置特征 GNN 在（通常是稀疏的）图上运行，而 Graph Transformers (GT) 在全连接图上运行，其中每个节点都连接到图的其他节点。一方面，在节点数为 N 的图中，图的复杂度为 O(N^2) 。另一方面，GT 不会过度平滑，这是长程消息传递的常见问题。全连接图意味着你有来自原始图的真边和从全连接变换添加的假边，你需要进行区分。 更重要的是，你需要一种方法来为节点注入一些位置特征，否则 GT 不会超过 GNN。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0978d35e488518ec889a32793c037546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd980ecb2d5c49aecbbe26ade67cf08d/" rel="bookmark">
			电力系统潮流计算案例（MATLAB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算例信息 系统网络结构图：
基础数据（标幺值）：
（1）母线数据
母线名
1
2
3
4
5
6
7
8
9
基准电压
230
230
230
230
230
230
18
13.8
16.5
（2）交流线数据
I侧母线
J侧母线
电阻
电抗
电纳的1/2
6
1
0.01
0.085
0.088
1
4
0.032
0.161
0.153
4
3
0.0085
0.072
0.0745
3
5
0.0119
0.1008
0.1045
5
2
0.039
0.17
0.179
2
6
0.017
0.092
0.079
（3）变压器数据
I侧母线
J侧母线
电抗
变比
9
6
0.0576
1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd980ecb2d5c49aecbbe26ade67cf08d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff17ddb8c36aad1ba2bd140fbbce95aa/" rel="bookmark">
			计算机的端口以及tcp/ip中的端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理端口和TCP/IP协议中的端口 在网络技术中，端口（Port）大致有两种意思：
一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等。
二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。
端口分类 按保留端口和动态端口分类：
0-1023端口分配给一些已经知的程序。如http的80。
1024-65535是动态端口。这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。当程序关闭，也会同时释放这些端口供其他程序使用。
端口绑定 每个套接字需要绑一个端口，且只能绑定一个端口。一个端口也只能被一个套接字绑定。这就形成了一一对应的关系。
这个端口绑定类似于获取一个住址，服务器通过这个地址来找到相应的套接字。
在实际编译中，一般只在服务器端绑定固定的端口。而在客户端并不做端口绑定。客户端发送消息时，会自动分配一个端口。
为什么客户端一般不绑定一个端口呢？ 因为一个端口只能被绑定一次。这些端口当然要优先让级服务端，由于服务端的端口不能变更，需要被其他的客户端所知。而客户端的端口不需要被其他多端知晓。
问题集 为什么tcp/ip中的端口范围为65535？ 在TCP/IP协议的开头，会分别有16位来存储源端口号和目标端口号，这16位所支持的数值范围即为端口范围。由于2^16-1=65535，所以端口范围为0-65535。 在新的IPV6和ipv4上的端口限制都为65535。
一个端口上是否能同时建议udp和tcp服务器监听？ 能过实验发现，可以使用在ipv4和ipv6上同时使用tcp、udp协议监控20000端口。
测试代码如下：
tcp server
from socketserver import BaseRequestHandler, TCPServer class EchoHandler(BaseRequestHandler): def handle(self): print('Got connection from', self.client_address) while True: msg = self.request.recv(8192) if not msg: break self.request.send(msg) if __name__ == '__main__': serv = TCPServer(('', 20000), EchoHandler) serv.serve_forever() udp server
from socketserver import BaseRequestHandler, UDPServer import time class TimeHandler(BaseRequestHandler): def handle(self): print('Got connection from', self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff17ddb8c36aad1ba2bd140fbbce95aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b010db194c37aa4c7330b5a0671d44/" rel="bookmark">
			通过遗传算法进行超参数调整和自动时间序列建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在以前的文章中我们介绍过一些基于遗传算法的知识，本篇文章将使用遗传算法处理机器学习模型和时间序列数据。
超参数调整（TPOT ） 自动机器学习（Auto ML）通过自动化整个机器学习过程，帮我们找到最适合预测的模型，对于机器学习模型来说Auto ML可能更多的意味着超参数的调整和优化。
在这里我们使用python的一个名叫Tpot 的包来操作，TPOT 是建立在 scikit-learn 之上，虽然还是处在开发中，但是他的功能已经可以帮助我们了解这些概念了，下图显示了 Tpot 的工作原理：
from tpot import TPOTClassifier from tpot import TPOTRegressormodel = TPOTClassifier(generations=100, population_size=100, offspring_size=None, mutation_rate=0.9, crossover_rate=0.1, scoring=None, cv=5, subsample=1.0, n_jobs=1, max_time_mins=None, max_eval_time_mins=5, random_state=None, config_dict=None, template=None, warm_start=False, memory=None, use_dask=False, periodic_checkpoint_folder=None, early_stop=None, verbosity=0, disable_update_check=False, log_file=None) 通过上面的代码就可以获得简单的回归模型，这是默认参数列表
generations=100, population_size=100, offspring_size=None # Jeff notes this gets set to population_size mutation_rate=0.9, crossover_rate=0.1, scoring="Accuracy", # for Classification cv=5, subsample=1.0, n_jobs=1, max_time_mins=None, max_eval_time_mins=5, random_state=None, config_dict=None, warm_start=False, memory=None, periodic_checkpoint_folder=None, early_stop=None verbosity=0 disable_update_check=False 我们看看有哪些超参数可以进行调整：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b010db194c37aa4c7330b5a0671d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd2f252488d8acfb97a647ab4b45f7a/" rel="bookmark">
			ant design vue 表格Table使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ant design vue 表格Table使用 1.嵌套子表 &lt;a-table rowKey="arcId" :columns="columns" :dataSource="loadData" @expand="handldOnExpand" :loading="tableLoading" &gt; &lt;span slot="action" slot-scope="text, record"&gt; &lt;a v-if="record.status !=0" @click="getarcListByStaus(record)"&gt;填表归档&lt;/a&gt; &lt;a-divider v-if="record.status !=0" type="vertical" /&gt; &lt;a v-if="record.status !=0" @click="getarcListByStaus2(record)"&gt;上传归档&lt;/a&gt; &lt;a v-else @click="updateByStaus(record.arcId)"&gt;取消归档&lt;/a&gt; &lt;/span&gt; // 子表格 &lt;a-table slot="expandedRowRender" slot-scope="record,text" :columns="innerColumns" :data-source="record.newchildren" :pagination="false" // 不显示表头 :showHeader="false" &gt; &lt;span slot="operation" slot-scope="text,record"&gt; &lt;a v-if="record.status !=0" @click="getarcListByStaus2(record)"&gt;上传归档&lt;/a&gt; &lt;a v-else @click="updateByStaus(record.arcId)"&gt;取消归档&lt;/a&gt; &lt;/span&gt; &lt;/a-table&gt; &lt;/a-table&gt; // 展开闭合按钮事件 handldOnExpand(expanded, record) { console.log(expanded,record); if (!expanded) return //如果是关闭就返回 if (record.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bd2f252488d8acfb97a647ab4b45f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbcfa324ab26bd34deed240e586f48c/" rel="bookmark">
			几个服务器下很占存储的 隐藏缓存文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		18G ./.pylint.d
18G ./.gnome2_private
27G ./dataset
99G ./vpr
18G ./.cache
42G ./anaconda3
Pylint 是一个 Python 代码分析工具，它分析 Python 代码中的错误，查找不符合代码风格标准（Pylint 默认使用的代码风格是 PEP 8，具体信息，请参阅参考资料）和有潜在问题的代码。
GNOME 2.0 Release Notes
.gnome GNOME 2 uses $HOME/.gnome2 and $HOME/.gnome2_private as directories for storing stuff. However, you could not completely remove $HOME/.gnome, since gnome-vfs needs it and did not create it, so any modifications that gnome-vfs needs to save in the user's directory would not be saved. Thus, users needed to create a $HOME/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbcfa324ab26bd34deed240e586f48c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08518a6f504083926d8c1f8d70650356/" rel="bookmark">
			Python实现消消乐小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍了Python实现消消乐小游戏，文中通过示例代码介绍的非常详细，具有一定的参考价值，感兴趣的小伙伴们可以参考一下，编程学习资料点击免费领取
提到开心消消乐这款小游戏，相信大家都不陌生，其曾在 2015 年获得过玩家最喜爱的移动单机游戏奖，受欢迎程度可见一斑，本文我们使用 Python 来做个简单的消消乐小游戏。
实现 消消乐的构成主要包括三部分：游戏主体、计分器、计时器，下面来看一下具体实现。
先来看一下游戏所需 Python 库。
1
2
3
4
5
import os
import sys
import time
import pygame
import random
定义一些常量，比如：窗口宽高、网格行列数等，代码如下：
1
2
3
4
5
6
7
8
WIDTH = 400
HEIGHT = 400
NUMGRID = 8
GRIDSIZE = 36
XMARGIN = (WIDTH - GRIDSIZE * NUMGRID) // 2
YMARGIN = (HEIGHT - GRIDSIZE * NUMGRID) // 2
ROOTDIR = os.getcwd()
FPS = 30
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08518a6f504083926d8c1f8d70650356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4cde04843db650bc53e28dbf111f38/" rel="bookmark">
			Java正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式中的特殊字符： 一、？ ?是一个限定符，它代表它前面的字符“r”需要出现0次或者1次；
例子：
正则表达式：user? 字符串：user hava you use aaa bbb ccc 匹配结果：可以匹配到user和use 二、* 星号是一个限定符，可以匹配0个或者多个字符；
例子：
正则表达式：ab*c 字符串：	ac abc abbbc adc adddc abbbbc 匹配结果：ac abc abbbc abbbbc 三、+ ab+c
+是一个限定符，可以匹配出现一次以上的字符；
例子：
正则表达式： ab+c 字符串：ac abc abbbc adc adddc abbbbc 匹配结果：abc abbbc abbbbc 四、{} {}可以精确匹配指定数量的字符，举例子说明：
指定b字符要连续出现六次，可以这样编写：
正则表达式：ab{6}c 字符串：ac abc abbbc adc adddc abbbbc abbbbbbc 匹配结果为：abbbbbbc 指定b字符要连续出现2-6次，可以这样编写：
正则表达式：ab{2,6}c 字符串：ac abc abbbc adc adddc abbbbc abbbbbbc 匹配结果为：abbbc abbbbc abbbbbbc 指定b字符要连续出现2次及以上，可以这样编写：
正则表达式：ab{2,}c 字符串：ac abc abbbc adc adddc abbbbc abbbbbbc 匹配结果为：abbbc abbbbc abbbbbbc 以上实现的都是一个字符的正则表达式。如果是多个字符，可以使用（）将它括起来，再加限定符修饰，也就是把多个字符看成是一个整体即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4cde04843db650bc53e28dbf111f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f010a99dc6202c8bfb7b3a27567d14/" rel="bookmark">
			Centos最小化安装系统实现KVM图形化管理虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos最小化安装系统实现KVM图形化管理虚拟机 需求：初学者不会对KVM的命令行不太了解，而Centos7系统为了节省资源也是最小化安装的，那么就需要这篇文章来帮助你-利用SSH的X11-forword。
Linux下执行一个GUI程序通常需要两个部分来协调完成，X server与X client。X server是专门负责显示用户界面的，它管理你的显示器，键盘以及鼠标，通常你看到的桌面系统即是由它在背后驱动的，X client则负责程序的逻辑，如果需要使用用户界面，则通过给X server发送请求来完成。通常情况下，X server与X client都运行在同一台机器上。
Secure Shell (SSH)是一种加密协议，专为远程登录会话和其他网络服务提供安全性的协议。X11- forwarding是一个安全的shell特性，它允许通过现有的SSH shell会话转发X11连接，用于在服务器上运行X11程序，而ssh-client通过用户的X11-server显示图形窗口。
SSH允许用户在客户机上远程连接服务器，但是这种Shell访问只允许用户和服务器应用程序之间基于文本的交互。而X11是一个允许服务器应用程序显示图形界面的系统(本质上是基于像素的输出，显示自己的窗口)。这是一个长期建立的协议，但它传输数据没有加密。
X11-forwarding允许通过已经建立和加密的SSH连接安全地运行X11程序。
1.准备软件–Xmanager7 这里附上百度网盘连接供下载Xmanager7
链接：https://pan.baidu.com/s/1F8pcbKMPfEWlCvZXwwvblA
提取码：1234
2.安装依赖包 安装KVM图形化管理工具
[root@virsh1 ~]# yum -y install virt-manager openssh-askpass 安装x11图形化管理工具
[root@virsh1 ~]# yum -y install xorg-x11-font-utils xorg-x11-server-utils xorg-x11-utils xorg-x11-xauth xorg-x11-xinit 解决使用时出现乱码
[root@virsh1 ~]# yum -y dejavu-lgc-sans-fonts [root@virsh1 ~]# yum groupinstall -y "Fonts" 开启ssh的X11转发功能
[root@virsh1 ~]# vim /etc/ssh/sshd_config X11Forwarding yes [root@virsh1 ~]# systemctl restart sshd 3.配置Xmanager-Passive Xmanager－Passive用来接收由SSH转发至本地的图形界面信息。
如下图为xmanager7工具集合
打开该Xmanager-PassiveXshell7设置X11隧道转发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f010a99dc6202c8bfb7b3a27567d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98fdf8c5866a79f1ae3dd46d42bf92f9/" rel="bookmark">
			Ros使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ros使用 参考ROS——工程路径问题
roscd出现No such package/stack或者rosed出现Couldn’t find package问题
仅用于学习使用，如有侵权，请联系我删除
1. 建立工作空间 mkdir -p catkin_ws/src
-p的目的是递归建立文件夹。
源码放入，git clone或者自己的源码
注意将该工作空间加入环境变量。
echo "export ROS_PACKAGE_PATH"=~/[newfilename]:"$ROS_PACKAGE_PATH " &gt;&gt; ~/.bashrc 将[newfilename]替换为你创建的新文件夹，如果此文件夹不在根目录，注意把其路径也一起加上
第二种加入的方式
临时解决方案: source ~/catkin_ws/src/devel/setup.bash 永久解决方案: vim ~/.bashrc
在.bashrc文件最下面中加入ROS工程的setup.bash 输入命令立即生效
source ~/.bashrc 显示ros的界面采用命令：
rosrun rviz rviz 日后再添加。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e531a146e75a8f11ce4ce491652bad/" rel="bookmark">
			fabricjs&#43;vue3.x-车辆定位与轨迹追踪（章节目录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fabricjs+vue3.x-车辆定位与轨迹追踪（章节目录）（点击跳转）（尚未完成，维护中....） 1.初始化项目1.1.目录结构说明1.2.源码 2.核心功能讲解2.1.区域地图2.2.实时定位2.3.轨迹追踪 3.区域地图3.1.基础数据维护3.1.1.案例预览3.1.2.知识讲解3.1.3.源码 3.2.实现区域地图3.2.1.案例预览3.2.2.知识讲解3.2.3.源码 3.3.界面优化3.3.1.案例预览3.3.2.知识讲解3.3.3.源码 4.实时定位4.1.实现思路4.2.代码实现4.2.1.案例预览4.2.2.知识讲解4.2.3.源码 5.轨迹追踪4.1.实现思路4.2.当前轨迹路线4.3.历史轨迹查询 课程完整源码 fabricjs官方文档：http://fabricjs.com/docs/ 1.初始化项目 1.1.目录结构说明 1.2.源码 2.核心功能讲解 2.1.区域地图 2.2.实时定位 2.3.轨迹追踪 3.区域地图 3.1.基础数据维护 3.1.1.案例预览 3.1.2.知识讲解 3.1.3.源码 3.2.实现区域地图 3.2.1.案例预览 3.2.2.知识讲解 3.2.3.源码 3.3.界面优化 3.3.1.案例预览 3.3.2.知识讲解 3.3.3.源码 4.实时定位 4.1.实现思路 4.2.代码实现 4.2.1.案例预览 4.2.2.知识讲解 4.2.3.源码 5.轨迹追踪 4.1.实现思路 4.2.当前轨迹路线 4.3.历史轨迹查询 课程完整源码 进行中
撒 花 ❀❀❀❀❀❀❀❀❀❀❀❀
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14334fcf01dd03bad6acf834f40304e4/" rel="bookmark">
			JAVA把InputStream 转 字节数组(byte[])
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引入依赖
&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 2. 使用
import org.apache.commons.io.IOUtils; byte[] bytes = IOUtils.toByteArray(inputStream); 参考文章：
Java: InputStream转化为byte数组 - 夜行过客 - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669f624bd7acd51074e94f5b1eea4bcc/" rel="bookmark">
			supermicro安装centos7(U盘启动)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 公司服务器因为升级glibc除了问题，导致lib64下的软链接和一些依赖文件出现了版本问题以及文件缺失的情况，最后选择了重装系统，以前没有安装过linux系统，特此记录一下。
1.制作启动U盘
1)下载UltraISO软件(最好用最新版本)，下载centos系统iso文件
官网地址：UltraISO软碟通中文官方网站 - 光盘映像文件制作/编辑/转换工具
2)打开UltraISO的窗口后依次点击左上角的"文件"-"打开"，如图
3) 找到存放镜像文件的目录，选中该目标文件，点击"打开"按钮
4)然后回到UltraISO窗口，点击菜单栏中的"启动"选"写入硬盘镜像"
5) 选择写入方式选择为“USB-HDD+或者USB-HDD v2”，如果不是这个模式，可能导致电脑无法通过U盘正常启动，并打钩刻录校验，并格式化U盘
6)等待片刻，正在将安装系统的镜像文件数据写入到U盘里
以上步骤完成之后，系统U盘制作完成
2.安装系统
1）插入系统U盘（使用UltraISO制作系统U盘，见后面补充说明），重启服务，按Del/delete进去bios界面，然后切换到boot页面
2） 选中Dual Boot1 Order #1，回车，然后选择UEFI USB KEY：UEFI:你的USB名称，再回车
3） 点击F4，服务器会重启。bios界面上说明了F4是save &amp; exit
4）重启之后进入安装界面，选择install(第一个选项)，然后会报错，点击esc会退出报错进入到安装界面(忘记拍图了，找了一张网图)
5）安装完成之后会进入下面界面，输入查询插入usb的位置，最后一个就是你的usb的位置(我的是/dev/sdb4)，然后输入reboot,回车
6)重启之后会再次进入第4步说的安装界面，使用键盘↑↓选择第一个命令(不要回车！！！)，然后点击e修改执行命令(具体点击哪个键进入修改要看屏幕上的提示)，
vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4 quiet 主要修改红色部分
修改完成之后根据屏幕提示按Ctrl + X开始进入安装
7)重启之后会自动安装，然后出来图形界面
8) 选择安装位置和软件选择，个人比较喜欢图形界面，选择GNOME，后面就是直接往下走
9)安装完成之后重启，需要再次进入bios界面，boot页面把第一启动改为硬盘
UEFI Hard Disk:centos，然后F4，重启
至此，系统安装完成！
参考文章：
Supermicro服务器的重装Centos系统体验_lxx333666的博客-CSDN博客_supermicro服务器进入bios
win7 系统安装教程 游戏多开 超微服务器bios设置u盘启动安装系统_哔哩哔哩_bilibili 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2318a23750592992396757806894314/" rel="bookmark">
			centos7安装SqlServer2019数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司新服务器安装SqlServer数据库，最开始网上找文档安装后服务一直启动不起来，报了一个莫名的错误(code=exited,status=127)，上网查了好久都没有发现问题原因，也排除了内存等其他原因，一顿操作还把服务器环境弄坏了，最后含泪重装系统，按照官方文档安装，成功了！！！记录一下历程。
1.服务器环境：
centos7
gcc9.3.0
glibc2.31
python环境
2.安装SqlServer数据库
1)下载 Microsoft SQL Server 2019 Red Hat 存储库配置文件：
sudo curl -o /etc/yum.repos.d/mssql-server.repo https://packages.microsoft.com/config/rhel/7/mssql-server-2019.repo 2)运行以下命令以安装 SQL Server：
sudo yum install -y mssql-server 3)包安装完成后，运行 mssql-conf setup，按照提示设置 SA 密码并选择版本。
sudo /opt/mssql/bin/mssql-conf setup 4)完成配置后，验证服务是否正在运行：
systemctl status mssql-server 5)若要允许远程连接，请在 RHEL 的防火墙上打开 SQL Server 端口。 默认的 SQL Server 端口为 TCP 1433。 如果为防火墙使用的是 FirewallD，则可以使用以下命令：
sudo firewall-cmd --zone=public --add-port=1433/tcp --permanent sudo firewall-cmd --reload 此时，SQL Server 2019 正在 RHEL 计算机上运行，随时可以使用！ 3.安装 SQL Server 命令行工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2318a23750592992396757806894314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfa8d6fae230b99767f33cb81b78f28/" rel="bookmark">
			centos7升级gcc&amp;glibc(踩坑)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司新到的服务器，需要安装常用的数据库，在mysql，postgresql等安装的时候都非常的顺利，但是在安装SqlServer的时候发现缺少依赖的glibc2.18和glibc2.27，于是便有了这次的踩坑之旅。
刚开始是看缺什么就装什么，先下载了glibc2.18和glibc2.27，2.18版本的安装很顺利，但是在2.27安装的时候就开始报错了(最后发现是缺少一个libc-2.27.so的文件，但是一部分文件已经变成了2.27版本，一部分还是2.18的，导致版本不一致，环境就出问题了)，然后各种百度尝试解决，还有修改lib64里面的软链接，*.so文件等，最后系统坏了只能含泪重装了一次。
然后重装后依然采用第一次升级的方式，发现还是这个坎没有过去，系统又坏了，于是含泪第二次重装了系统，也学到了一些知识：glibc生成的*.so文件和一些软链接什么的都是系统运行依赖的，一旦出了问题，系统运行就会受影响，升级的时候一定要慎重以及安全操作，最好做备份。
第二次重装之后没有着急去升级glibc，而是先升级了gcc(系统默认的是4.8.5，升级到了9.3.0)，升级了make(系统默认是3.X来着，升级到了4.3)，最后才升级了glibc(直接升级到了2.31，会包含之前的老版本)，最后终于成功了，具体操作请看下面。
1.源码编译升级gcc9.3.0
1）编译升级gcc
wget https://mirrors.aliyun.com/gnu/gcc/gcc-9.3.0/gcc-9.3.0.tar.gz cp gcc-9.3.0.tar.gz /opt cd /opt tar -zxf gcc-9.3.0.tar.gz cd gcc-9.3.0/ ./contrib/download_prerequisites #建议先手动下载依赖的这四个包，下载地址ftp://gcc.gnu.org/pub/gcc/infrastructure/ cat /proc/cpuinfo| grep "processor"| wc -l mkdir build cd build ../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr make -j6 make install 2)升级成功后gcc版本检查
cd /usr/lib64 ll libstdc++* gcc -v gcc --version 2.源码编译升级make
1）编译升级make
wget https://mirrors.aliyun.com/gnu/make/make-4.3.tar.gz cp make-4.3.tar.gz /opt cd /opt/ tar -zxf make-4.3.tar.gz cd make-4.3/ mkdir build cd build ../configure --prefix=/usr &amp;&amp; make &amp;&amp; make install 2)检查升级后的make版本信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dfa8d6fae230b99767f33cb81b78f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f498a8d2941e6c8665425d7039cb45c/" rel="bookmark">
			Dubbo之入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dubbo之入门 Dubbo简介什么是RPCDubbo核心能力 Dubbo架构服务注册中心ZookeeperZookeeper安装Zookeeper启动、停止Zookeeper Dubbo快速入门服务提供方开发服务消费方开发 Dubbo管理控制台安装使用 Dubbo简介 Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的、轻量级的Java RPC框架，可以和Spring框架无缝集成，2018年阿里巴巴把这个框架捐献给apache基金会。
什么是RPC RPC全称为remote procedure call，即远程过程调用。
比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器想要调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要网络来表达调用的语义和传达调用的数据。RPC不是一个具体的技术，而是指整个网络远程调用过程。
RPC是一个泛化的概念，严格来说一切远程调用的手段都属于RPC范畴。Java的RPC框架有：RMI、Hessian、Dubbo等。 Dubbo核心能力 面向接口的远程方法调用、智能容错和负载均衡、服务自动注册和发现
Dubbo架构 节点角色名称Provider暴露服务的服务提供方Consumer调用远程服务的服务消费方Register服务注册与发现的注册中心Monitor统计服务的调用次数和调用时间的监控中心Container服务运行容器 调用关系说明:
0.服务容器负责启动、加载、运行服务提供者
1.服务提供者在启动时，向注册中心注册自己提供的服务
2.服务消费者在启动时，向注册中心订阅自己所需的服务
3.注册中心返回服务提供者地址列表给消费者，如有变更，注册中心将基于长连接推送变更数据给消费者
4.服务消费者，从提供者地址列表中，基于软负载均衡算法，选择一台提供者进行调用，如果调用失败，再选另一台调用。
5.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心
服务注册中心Zookeeper Dubbo官网推荐使用Zookeeper作为服务注册中心
Zookeeper Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。
Zookeeper树型目录服务：
流程说明：
服务提供者(Provider)启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的URL 地址服务消费者(Consumer)启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址监控中心(Monitor)启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者URL 地址 安装Zookeeper 下载地址：http://archive.apache.org/dist/zookeeper/
第一步：安装 jdk https://blog.csdn.net/weixin_43915128/article/details/121090963
第二步：把 zookeeper 的压缩包上传到 linux 系统
第三步：解压缩压缩包 tar -zxvf zookeeper-3.4.6.tar.gz -C /usr 第四步：进入zookeeper-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f498a8d2941e6c8665425d7039cb45c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c190b7d03a0b766df3154bcdd1025e9f/" rel="bookmark">
			实例化Servlet类[com.cos0du.web.SelectAllServlet]异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在开发新的时候启动调用Servlet时报500错误，实例化Servlet类[com.cos0du.web.SelectAllServlet]异常.
在网上找了好多，有说是tomcat版本和servlet版本不兼容的问题，我排查了不是；有说是没有对应Servlet.class文件生成，但是我的是生成了的，都没找到问题所在，最后我重新建了一个项目，启动成功了，两者逐个对比，发现问题是resources下的对应Mapper.xml配置文件中的标签的id内容和和对应的Mapper接口中注解@ResultMap(“diaryResultMap”)对应错误
将两者修改为一致问题即解决。
两者对应改成一样就解决问题了。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959d701cd2f33a5f306949e131d46b65/" rel="bookmark">
			数电_第九章_数模模数转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数模转换电路(DAC)D/A转换关系权电阻DACR-2R梯形DAC 模数转换电路(ADC)A/D转换关系工作原理量化四舍五入法只舍不入法 并行比较ADC有舍有入并行比较ADC只舍不入并行比较ADC 并/串型ADC 自然界许多量都是连续变化的模拟量。要对这些量进行自动控制，需要通过传感器将这些非电学量转化为电学量 ( V , I , R , C ) (V,I,R,C) (V,I,R,C)，然后进入数字系统进行信号处理。这期间需要进行模数转换(A/D)和数模(D/A)转换。 数模转换电路(DAC) D/A转换关系 特点：
一一对应：每个二进制数转换成满刻度值的一个确定的分数；归一化：将数字量表示成满刻度值(FSR)模拟量的一个分数值。 对于三位DAC来说，001对应的 1 2 3 F S R \frac{1}{2^3}FSR 231​FSR被称为最低有效位LSB。
更普通的， L S B = 1 2 n F S R LSB=\frac{1}{2^n}FSR LSB=2n1​FSR。
权电阻DAC R-2R梯形DAC 结构还是和权电阻DAC差不多的，就是电阻的配置有了明显的改变，另外权重的位置也倒置了。
其特点为：
整个网络只有两种电阻。网络由相同的电路环节组成，每节有两个电阻和一个开关，每节对应二进制一位数。每个节点(C/B/A)，对地等效电阻都是R。 从右端开始，每左移一个节点，等效电路中电源电压便衰减为它的一半。
我们采用戴维南定理分析 X 1 , X 2 , X 3 X_1,X_2,X_3 X1​,X2​,X3​单独作用时的结果，即分析对A位置的电压大小。
戴维南定理：
含独立电源的线性电阻单口网络N，就端口特性而言，可以等效为一个电压源和电阻串联的单口网络。电压源的电压等于单口网络在负载开路时的电压uoc；电阻R0是单口网络内全部独立电源为零值时所得单口网络N0的等效电阻。电压源置零相当于短路。 优点：电阻种类少，易集成，开关工作条件相同。
缺点：工作速度慢。
模数转换电路(ADC) A/D转换关系 工作原理 转换过程为采样、保持（采样保持电路）、量化、编码（ADC电路）
合理的取样频率由取样定理给出。也就是说，我取样频率的最小值要超过信号频率的两倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/959d701cd2f33a5f306949e131d46b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e678c9faf0aaa6dfe93b1d67ac411a/" rel="bookmark">
			gezabo变黑闪退，报错[gazebo_gui-2] process has died
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开Gezabo时，开着开着就爆红，详细报错信息如下(pid编号可能各不相同)：
[gazebo_gui-2] process has died [pid 40363, exit code 139, cmd /opt/ros/kinetic/lib/gazebo_ros/gzclient __name:=gazebo_gui 不知道是咋回事，网上搜解决办法，主要有三种办法，都试了一下，我的被第三种方法解决了，每个人条件不一样，在此做一下列举，希望都能顺利解决：
方法一：
https://blog.csdn.net/u011304078/article/details/102584462
方法二：
https://www.cnblogs.com/rjjhyj/p/12268181.html
方法三：
https://blog.csdn.net/qq_44775361/article/details/117945525
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf1f56e7b1832b3a07af2b7f6e89778/" rel="bookmark">
			Qt程序发布（Qt6.2.2&#43;MinGW11.2.0&#43;win10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近几天，又有小伙伴问我程序发布的事，这个问题本不复杂，但对一个新手来说，还是有点难度的。为此，笔者简单介绍下Qt在windows下，发布程序的一般方法
本次以Qt6.2.2+MinGW11.2.0+win10为例，其他版本的方法类似，请读者自行尝试。
一、工具准备 process explorer
下载地址:Process Explorer - Windows Sysinternals | Microsoft Docs
第三方下载也很多，笔者只是用它来查看使用的动态库
二、发布Qt Widgets Application 传统的C++桌面程序，发布较简单，动态库也相对较少，笔者以一个自带的示例，演示下如何打包。
开始前，先理解下，控制台程序和非控制台程序。可能有的教程里，控制台程序是指没有图形界面的程序；非控制台程序是有图形界面的程序。这种理解是不合理的。在Qt中，控制台程序是可以有图形界面的。笔者换一种方式解释下，在运行时，若程序会自己弹出控制台，则可称为控制台程序。但本质上，两种程序使用起来，没什么区别。笔者过会演示下
1.打开示例http 2.选择正确的开发套件 3.选择Release模式，并运行 注：
在Debug模式下，也可以发布程序，但这种模式下，程序带有很多调试信息，发布的库也会异常大。
4.找到生成的exe文件 若运行成功，可以到编译目录找到生成的exe文件，笔者的文件在D:/Qt/Examples/Qt-6.2.2/network/build-http-Desktop_Qt_6_2_2_MinGW_64_bit-Release/release
若读者自定义编译输出目录，可以到目标目录找下
笔者的文件名是http.exe
注：
若不指定，exe文件名默认就是项目文件的名字；
若在项目文件添加 TARGET = httpclient 则生成的文件就是 httpclient.exe
小技巧：
若目标目录中有大量的文件，不方便找exe文件时，可以执行编译－&gt;清理
此时再去目标目录，会发现，只剩下exe文件了
将生成的exe文件复制到一个单独的目录中，注意，目录不要有中文或空格
5.执行windeployqt.exe windeployqt.exe是Qt自带的打包工具，但这个工具不完美，经常会多库或少库，需要我们手工调整下。
打开cmd，并切换到exe文件的目录，执行如下使用
D:\Qt\6.2.2\mingw_64\bin\windeployqt.exe http.exe #请读者按照自己的实际目录修改 注：
使用的windeployqt.exe一定要是程序编译时，选择的套件里的
执行完成后，需要的动态库或插件，就会复制到目标目录中
若是运气好，直接运行exe可执行文件，就可以正常运行了
但很遗憾，笔者运行时报错了
6.补充必要的运行库 必要运行库，运行时不能少，若是缺少会直接弹窗提示
笔者提示如上，只要找到对应的动态库，直接复制到打包目录
若是Qt自带的库，基本都是套件的bin目录中，笔者的是D:\Qt\6.2.2\mingw_64\bin
同样的方法，找到libgcc_s_seh-1.dll、libstdc++-6.dll、libwinpthread-1.dll，复制到打包目录
此时就可以正常运行程序了
7.补充非必要的运行库 非必要的运行库，非必要是相对的。若是不使用时，可以不添加，这可以减少打包后的程序大小；若是需要用动，则必要放入打包程序中。这种动态库以插件居多，即便缺少，一般也不会报错，但在控制台上会打印出信息。根据提示复制相关的动态库就可以了。
本次http示例，可以正常下载http的文件，但可能无法下载https的文件（若可以正常下载，说明你已经安装过openssl了），这时需要将openssl的库放入打包目录
8.打印控制台信息 可能有小伙伴发现了，运行程序时，没有控制台，即使直接在cmd中执行，也没任何输出。有时程序没图形界面，或想输出了下信息到控制台上，这时就需要控制台了。
调用方法也很多简单，在项目文件中，添加如下
CONFIG += console CONFIG -= app_bundle 然后重新编译一次，再次运行程序，控制台就会自己弹出了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acf1f56e7b1832b3a07af2b7f6e89778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9df27ef61ee61602f6bb2ed0ddf92c7/" rel="bookmark">
			js文件名数字、英文、中文优先级递减排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗯，一个对象列表，因为是批量上传的，有排序的一个要求，依据文件名由数字、英文、中文优先级递减来排序，数字就是从小到大，英文是首字母字母表排序，中文是首字符拼音排序。
上图就是我 选择 后批量上传的对象列表，点击自动排序后就会成上图的样子
export default function arraySortByName(list) { // 前在前return 1,后在前return -1 if (list === undefined || list === null) return [] list.sort((a, b) =&gt; { // b是数组前一个，a是数组后一个 // 去除.jpg,.jpeg,.gif,.png let strA = a.name.replace(/\.(jpg|jpeg|png)/, ''); let strB = b.name.replace(/\.(jpg|jpeg|png)/, ''); // 谁为非法值谁在前面 if (strA === undefined || strA === null || strA === '' || strA === ' ' || strA === '　') { return -1 } if (strB === undefined || strB === null || strB === '' || strB === ' ' || strB === '　') { return 1 } let mB = strB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9df27ef61ee61602f6bb2ed0ddf92c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c61bce686119deee4d522d047e16b8/" rel="bookmark">
			Android开发前景如何？2021年，Android开发者的前行方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		速成班涌现了出来，参差不齐的开发能力，与这个供不应求的市场，相得益彰。
3、开源魅力，基于linux系统的架构，很容易的让linux那些人，利用c 的基础，以及linux技能，来进行挖宝，这里面很有名的是八门神器，root工具。
快节奏下的市场，让Java这个快速上手的语言，变成了宠儿。
这个时候，没人注意到这个Java是有垃圾回收机构的，越往后，越受制于这个瓶颈，所以当前性能优化，启动提升这块，系统裁剪，还是很吃香。
安卓当前发展到一个平稳期，一个市场蔓延到极限，在手机这个市场，已经做到了天花板。
从当前安卓迭代的版本来看，创新性功能已经不多，发展也是陷在一个迷茫阶段。
不知有多少人关注过phonegap，那个之前最早的跨平台框架，被人诟病的慢，卡的问题，
随着webview技术的突破，以及硬件性能提升，当前已经不是主要问题了。
安卓在这一役下，显然失了先机，不过还好的是，当下安卓也在发力这个热更框架，在Google的加持下，相信这块会有一片天地。
安卓当前发展，为什么凉了，只是因为基础的应用开发，被小程序以及跨平台前端替代，之前是因为性能问题而选择了原生开发，
当前已经全线退到这个前端开发，这块需求的人员，刚好落到了Web开发的那一波。
而安卓另一场战役在哪里呢？
电视盒子，这里不要求性能，但大多数主界面用的原生实现的框架，这里面就是围绕开发一个Launcher ，所以那些做桌面的人，会进入到这个领域。
物联网，以及车载网，把前后端拉通，很大程度是把web那一个团队引入，同时招几个系统裁剪，和系统研发，框架设计的人来协调。
系统裁剪，是把之前嵌入式开发，移植的那一波人用了起来，同时系统大拿解决从底层驱动上来，到应用层的接口对接。
应用这块变数很大，因为系统大拿很大程度能够做一些事情，很有可能应用这里重要性被忽视，需求量急剧下降。
安卓整体来说，有几个问题一直没能解决，性能问题，适配问题，以及破解问题。
更有甚者，手机被改的面目全非，个人信息被无限挖掘，安全问题更为担忧。
整体来说，安卓不是凉了，而是门槛突然变高，整个环境的初级处在饱和状态，
所以那些还想通过基础培训几个月入门快速找到安卓工作的人，确实会觉得安卓凉了。
就如同2013年转去安卓的时候，我们一波人都不晓得Java语法，就这么磕磕绊绊的琢磨，研究，也是突破了这个语言。
所以语言这个不是考量的关键，安卓也是。它凉不凉，只代表它自身的发展轨迹。
就如同功能机时代一样，它被遗弃在历史舞台，但那些开发功能机的大部队，还是安然的度过了寒冬，转成智能机时代的弄潮者。
当下的直播，把安卓音视频需求拉了上来，如果你懂的opengl ，那么迁移过来来做安卓的视频特效，
你懂音视频编码，yuv rgb565等这些格式的拆分，显示，那么你当下还是很吃香。
视觉，听觉，摄像机，人脸识别，美颜特效，AI智能检测，安卓是一个平台框架，
它被选择在那些节省时间成本的领域，相对于嵌入式的领域，这块需求还是值得期待。
当然，直播这一块，也被webrtc webgl蚕食，性能问题已经不是差距，而快速迭代才是，以及跨平台的痛点。
安卓，下一站会是哪里呢？
安卓当前的市场，初级确实不好进了，所以感觉是凉了。
所以当下环境，只靠会Android就想混饭吃的这类人，已经离我们远去了，而真正热爱学习、
热爱技术、热爱安卓的（生活所迫的）已经进入了高级层次！
所以经常可以看到大佬从某大厂开始，跳来跳去，高薪Offer离他们并不远；
同时你也经常听到总有人在传播“Android凉了”的讯息，这类人又是什么情况，我就不予置评了……
所以说，作为Android开发者，最重要的还是保持自身的核心竞争力，也就是技术能力，只有技术能力跟上，才能从众多开发者当中突围而出！
有时候我们没有方向，不知道如何去努力，完全可以看看现在一线大厂的Android工程师招聘标准，按照上面的要求去提升，去学习：
大厂求职所需要的无非就是以下一些知识点：
以下资料全部免费赠送，需要的可以点击这里免费自取！！
架构师筑基必备技能
目前Android APP开发主流语言就是Java语言，Java语言最大的特性就是提高了软件的交互可能性，可以说安卓手机几乎所有应用程序都是利用Java语言来进行编写的。
JAVA知识要点：
1、 Java序列化、泛型与反射
2、虚拟机底层原理
3、Android内存原理
4、 Java高级并发原理详解
5、 编译时技术掌握与实战
6、JDK高级动态代理
7、高级数据结构与算法
8、 Java IO操作
9、
。。。。
Android R FrameWork源码与UI
在Android中，Framework泛指系统架构层。Framework的中文意思是“框架”，在软件开发中通常指开发框架，在一个系统中处于内核层之上，为顶层应用提供接口，被设计用来帮助开发者快速开发顶层应用，而不必关心系统内核运行机制，通常Framework都会隐藏main函数等应用程序必须的组件，开发人员只需把精力放在功能代码的实现上。说简单点，Framework具体的工作也就是为android应用开发的开发人员提供了一系列的服务和API的接口。
UI其实并不是单纯指用户看到的效果。因为在Android开发中，每个控件背后都有一套深层次的体系在支撑，自然而然，会UI不单纯指的是会自定义控件，我们还应该知道自定义控件背后的执行流程，包括从Activity的创建，XML的解析，到每个控件的测量、布局、绘制。当然在中间还夹杂着比如动画、事件分发机制、嵌套滑动机制等知识点。还有谷歌提供的一些UI框架也使我们要掌握的对象，比如Jetpack组件库、Material Design等。
知识要点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c61bce686119deee4d522d047e16b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/860f6f9e1e2fa7eb51b2ff0b75d897d1/" rel="bookmark">
			C语言程序设计期末考试试题(含答案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截止到目前我已经写了 600多道算法题，其中部分已经整理成了pdf文档，目前总共有1000多页（并且还会不断的增加），大家可以免费下载
下载链接：https://pan.baidu.com/s/1hjwK0ZeRxYGB8lIkbKuQgQ
提取码：6666
总共6页，就不在一一展示，可以扫描最上面的二维码，关注微信公众号“数据结构和算法”，回复“2020”即可下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42faf81de3014bb7f23b08e2fc31e5d9/" rel="bookmark">
			[LVM] Linux resize2fs: Bad magic number in super-block错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：当我LVM扩容逻辑卷区后，检查硬盘（lv）完整性和重置硬盘(lv)容量报错
错误截图：
[root@localhost ~]# lvextend -L 246G /dev/cl/home Size of logical volume cl/home changed from 200.00 GiB (51200 extents) to 246.00 GiB (62976 extents). Logical volume cl/home successfully resized. [root@localhost ~]# [root@localhost ~]# e2fsck -f /dev/cl/home e2fsck 1.42.9 (28-Dec-2013) ext2fs_open2: Bad magic number in super-block e2fsck: 超级块无效, trying backup blocks... e2fsck: Bad magic number in super-block 当尝试打开 /dev/cl/home 时 The 超级块 could not be read or does not describe a correct ext2 文件系统.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42faf81de3014bb7f23b08e2fc31e5d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6ec8703bce8586109cb76172834b48/" rel="bookmark">
			超酷的13个CSS有趣学习网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		13个CSS有趣学习网站 今天来给大家推荐13个辅助你学习巩固知识的网站，让你边玩边学边记！
因为这些网站大多都是国外的大佬们做的，所以网页大多都是英文，为了更好地使用，给你们推荐两个翻译的方式：
使用Chrome浏览器自带的翻译功能，可以中英随意切换 chrome浏览器自带的翻译功能
下一个"Google 翻译"插件，遇到不懂的英文直接选中点击翻译即可 插件划词翻译
好了，希望英文的存在不要成为你学习的障碍（更重要的还是要私底下多背单词，提升自己的英语水平，毕竟程序员免不了看英文文档）
一、CSS学习网站 1. Flex Box 冒险游戏 网址：Flex Box 冒险游戏[1]
简介：这是一个通过使用 flex box 相关知识来完成闯关的冒险游戏，一共24个关卡，更生动地带你体验 Flex 的真实应用场景
Flex Box 冒险游戏 2. Flexbox 格子骑士 网址：Flexbox 格子骑士[2]
简介：这个游戏能帮助你学习不同层面的Flex Box规范，一共有18个关卡，并且你在该游戏中写CSS类时，不是用原生写的，而是用Tailwind，一举两得，技能学习Flex，又能学习Tailwind
Flexbox 格子骑士 3. Flex Box 青蛙🐸 网址：Flex Box 青蛙[3]
简介：游戏中每个青蛙对应不同的关卡难度，每个难度对应着Flex相关的知识点
Flex Box 青蛙 4. Flex Box 打僵尸 网址：Flex Box 打僵尸[4]
简介：这是个学习Flex语法的游戏，每一关会有一个打僵尸的情节，并给你输送一个 Flex 相关知识，你可以用该知识进行游戏的存活
Flex Box 打僵尸 5. Flex Box 保卫战 网址：Flex Box 保卫战[5]
简介：这是一款塔防战略游戏，它教会你使用 Flexbox 语法来阻止敌人越过你的防线。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd6ec8703bce8586109cb76172834b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d5d8efbf14be19df9c28b3eb8787bd/" rel="bookmark">
			完美 幻塔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高自由度探索多武器连携切换战斗捏脸功能拟态系统联机共斗天气系统 未实现：
7. 轻功系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60456a4ab1d403e2be733120f62213e2/" rel="bookmark">
			UMAP分析及可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是UMAP？和PCA一样，一种降维的算法，如果不是统计学或者数据专业的人，我建议不要去看它的原理，知道如何用就足够了。
也许听到UMAP最多的是对单细胞数据的分析降维，类似于下图：
然而其他数据，像大样本的转录组在PCA降维效果不好的时候，可以使用UMAP，毕竟现在转录非常便宜，随便测几十个样品和玩似的。
首先构建一个数据集，行为样本，列为基因，并对样本的特征进行分组。
读入数据： setwd("E:/生物信息学")options(stringsAsFactors= F)####A &lt;- read.csv("UMAP.csv",header = T,row.names = 1) 安装R包：
install.packages("umap")library(umap) UMAP分析：
A_umap &lt;- A[,colnames(A)!= c('label2', 'label3','label4')]#新构建一个表，不含有labelA_umap &lt;- data.frame(t(apply(A_umap,1, function(v){(v-mean(v,na.rm=T))/sd(v,na.rm=T)})), stringsAsFactors=F)#标准化umap &lt;- umap(A_umap,method='naive',n_neighbors = 10) head(umap$layout) ##################### [,1] [,2]r1 16.16427 -11.32371r2 16.26652 -11.21803r3 16.28917 -11.45600r4 16.28618 -11.56981r5 16.15085 -12.07527r6 16.65784 -12.28240 提取分析结果用于作图：
B &lt;- data.frame(umap$layout)B$label &lt;- A$label2 colnames(B) &lt;- c('UMAP_1','UMAP_2','label') 作图是由ggplot实现的，应该很熟悉了：​​​​​​​
ggplot(B, aes(x=UMAP_1, y=UMAP_2, colour=label)) + geom_point(size=1)+ xlab("UMAP_1")+ ylab("UMAP_2")+ theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), legend.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60456a4ab1d403e2be733120f62213e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfdb3f2f28fcfa824be75bdc1494665a/" rel="bookmark">
			Duplicate keys detected: ‘/index‘. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台报这个错误，原因是因为v-for的key值重复，可能引起一个自增的错误，虽然只是警告，但是控制台一片红也不太好看
解决办法就是，key值取后台for循环返回的唯一id值，或者使用字符串加index,如:key="'a'+index"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be822070ecf83f1ef5f218f8f065d44/" rel="bookmark">
			数电_第三章_逻辑代数基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 逻辑代数基础基本公式(8)基本规则(2)注意事项 常用公式(4) 逻辑函数的标准形式最小项及标准与或式真值表标准与或式题型四：转化成标准与或式 最大项及标准或与式真值表标准或与式 两种标准式之间的关系 逻辑函数的公式化简最简表达式题型五：用公式法化简卡诺图化简逻辑函数卡诺图题型六：用卡诺图表示逻辑函数K-map化简逻辑函数求最简与或式(圈1法)题型七：用K-Map化简函数 逻辑代数基础 基本公式(8) 基本规则(2) 反演规则：
与或互换；01互换；原反互换。 所得到的逻辑函数为 F F F的反函数，即 F ˉ \bar{F} Fˉ。
如果 F F F成立，那么 F ˉ \bar{F} Fˉ也成立。
对偶规则：
与或互换；01互换 所得到的逻辑函数为 F F F的对偶函数，即 F ′ F' F′。
如果 F F F成立，那么 F ′ F' F′也成立
注意事项 运算顺序不变；不是一个变量上的反号不变（就是说底下按规则换，这个反号不要动）。 常用公式(4) 逻辑函数的标准形式 最小项及标准与或式 与项：变量相乘。
最小项（标准与项）：n变量函数，一项中每个变量都出现。
这意味着n个变量有 2 n 2^n 2n个最小项。
真值表 每种取值只有一个最小项值是逻辑高； m i m_i mi​中的 i i i是二进制对应的十进制数。 标准与或式 与或式，就是将一堆与项相加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1be822070ecf83f1ef5f218f8f065d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be50670ce47fb5779c1db79091769e62/" rel="bookmark">
			YYYY-MM-DD格式日期正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 YYYY-MM-DD格式日期正则表达式
// 通用 const reg=/ ([\d]{4}(((0[13578]|1[02])((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|11)((0[1-9])|([12][0-9])|30))|(02((0[1-9])|(1[0-9])|(2[0-8])))))|((((([02468][048])|([13579][26]))00)|([0-9]{2}(([02468][048])|([13579][26]))))(((0[13578]|1[02])((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|11)((0[1-9])|([12][0-9])|30))|(02((0[1-9])|(1[0-9])|(2[0-9])))))/ const a='2021-02-12' console.log(reg.test(a))//true const b='2021-02-30' console.log(reg.test(b))//false const c='2021-13-12' console.log(reg.test(c))//false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7293d2ab0ce140a8d9bd35f638a2bf4f/" rel="bookmark">
			JS如何去除 HTML标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JS如何去除 HTML标签 通常采用的方法是正则匹配法。
1、匹配&lt;开始&gt;结束的全局正则：
var regex = /(&lt;([^&gt;]+)&gt;)/ig
2、body内部的p标签
, body = "&lt;p&gt;test&lt;/p&gt;"
3、根据正则表达式直接替换为""
, result = body.replace(regex, "");
4、打印结果，显示test
console.log(result);
转载于：JS如何去除 HTML标签 - 陈小鑫 - 博客园 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba48102fd4ac2bd27d27844bd04823d4/" rel="bookmark">
			itextPdf~将PDF页面大小转为A4格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章向大家介绍将PDF页面大小转为A4格式---itextPdf实现，主要包括将PDF页面大小转为A4格式---itextPdf实现使用实例、应用技巧、基本知识点总结和需要注意事项，具有一定的参考价值，需要的朋友可以参考一下。
将PDF页面大小转为A4格式（itextPdf实现） 1. 引入相关jar包
&lt;!-- https://mvnrepository.com/artifact/com.itextpdf/itextpdf --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.2&lt;/version&gt; &lt;/dependency&gt; 2. 实现代码
package com.fan.study.common.util; import com.itextpdf.text.Document; import com.itextpdf.text.PageSize; import com.itextpdf.text.pdf.PdfContentByte; import com.itextpdf.text.pdf.PdfImportedPage; import com.itextpdf.text.pdf.PdfReader; import com.itextpdf.text.pdf.PdfWriter; import java.awt.geom.AffineTransform; import java.io.FileOutputStream; public class PdfConvertA4Utils { /** * @Param source 源文件 * @Param target 转换后文件 * @Description 将PDF转为A4格式 * @Date: 2021/4/25 **/ private static void convert(String source, String target) { try { PdfReader pdfReader = new PdfReader(source); Document doc = new Document(); PdfWriter writer = PdfWriter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba48102fd4ac2bd27d27844bd04823d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d07af76bd0a36ce391b39ca8e3a88c7b/" rel="bookmark">
			String 截取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将正则传入split()。返回的是一个字符串数组类型。不过通过这种方式截取会有很大的性能损耗，因为分析正则非常耗时。
将String str=“1，2，3，0” 转成 1 2 3 0 String str1 = "1,2,3,0"; String[] strs1=str1.split(","); for(int i=0,len=strs1.length;i&lt;len;i++){ System.out.println(strs1[i].toString()); } 结果是： 1 2 3 0 将int[] num={1,2,3}转成String str=“123” int[] list2={1,2,3}; String str2=""; for (int i = 0; i &lt; list2.length; i++) { str2=str2+list2[i]; } System.out.println(str2); 结果是 123 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ca2847b86b8c01c216e806bb1cdf71/" rel="bookmark">
			req.getParameter参数获取为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用form表单，servlet接收数据为空：
entype类型改为"application/x-www-form-urlencoded"
详见博客：解决httpServletRequest.getParameter获取不到参数_lgxzzz的博客-CSDN博客_getparameter获取不到参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0b8f41320c5e9a9a2d520608badf7f/" rel="bookmark">
			CC6...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录...... 1. 前言........2. 分析CC6..2.1 TiedMapEnrty.....2.2 开始构造 poc2.3. 为什么没有弹出来计算器2.4 理解最后的反射，讲解2.4.1 反射 filed.set.... 3. 反思......缺点111111......缺点22222........ 4.这个是没有版本限制的5. 参考 标题要大于5个字，弄了一会，，原来是最上面的标题。 1. 前言… 接着P神的CC1，往后分析，CC1是真能够解决8u71之前的使用的，遇到的问题就是CC1用到了AnnotationInvocationHandler类，但是AnnotationInvocationHandler类的readObject()方法在8u71以后逻辑就发生了改变，不能再利用了，所以需要找一个可以解决高版本Java的利用链。
先看P神的简化调用链：
Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() 看着链子大致就能懂了，反序列化的对象是HashMap对象。联想一下URLDNS，HashMap的readObject中调用了hash()，hash()函数中调用了key的hashCode()，TiedMapEntry的hashCode()函数：
我们需要看的主要是从最开始到 org.apache.commons.collections.map.LazyMap.get()的那⼀部分，因为LazyMap#get() 后⾯的部分在上⼀篇⽂章⾥已经说了
所以简单来说，解决Java高版本利用问题，就是找上下文中是否还有其他调用 LazyMap#get()的地方, ，get()不存在的键的时候，就会调用transform()方法，
2. 分析CC6… 我们找到的类是 org.apache.commons.collections.keyvalue.TiedMapEntry，在其 getValue()⽅法中调⽤了 this.map.get() ，⽽其hashCode⽅法调⽤了getValue⽅法 。
2.1 TiedMapEnrty… 还是看一下源码：
翻译：一个绑定到下面的map的一个map entry，它能让一个map enrty 来改变底层map，然后，这可能会弄乱任何一个迭代器。 。 翻译的一塌糊涂，，，
/** * A Map Entry tied to a map underneath. * &lt;p&gt; * This can be used to enable a map entry to make changes on the underlying * map, however this will probably mess up any iterators.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab0b8f41320c5e9a9a2d520608badf7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fd9b72d2ec701de2aef89e5733e43a0/" rel="bookmark">
			CC1-下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 前言2. 前置知识2.1 LazyMap2.2 动态代理补充动态代理重点： 3. LazyMap 分析3.1为什么要使用动态代理3.2 漏洞触发点3.3 构造poc 4.从反序列化的角度来看poc4.1跟着debug4.2 利用链分析：4.3 唯一比较绕的点是 5. 版本问题6.参考： 1. 前言 JDK版本需要时 8u71之前，尽管使用了动态代理…
也就是说**LazyMap + 动态代理** == TransformedMap。。。。。
相比较于 TransformedMap 链相比，多出来的就是我们要了解 LazyMap ，还有动态代理。
LazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap 是在写入元素的时候执行transform()，就是在put()数据，写入键值对的时候，会调用它的第二个，第三个参数的 transform() 函数。还有Map.Entry的方法，现在知道，至少setValue()能够了。
The Map put methods and Map.Entry method are affected by this class LazyMap是在其 get方法中执行的 factory.transform()方法。 为什么是这样的呢？
像P神说的： LazyMap 的作用就是懒加载，在 get 找不到值的时候，他就会调用 factory的transform 方法去获取一个值：
public Object get(Object key) { // create value for key if key is not currently in the map if (map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fd9b72d2ec701de2aef89e5733e43a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a6f89e2f2f3c252b806858fc6cd036/" rel="bookmark">
			CC1-上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		放个目录 1.前言2. 前置知识2.1 入门demo2.2 TransformedMap2.2.1 触发 put 的位置**小结：** 2.3 ConstantTransformer小结： 2.4 InvokerTransformer小结; 2.5 ChainedTransformer小结： 3. TransformedMap 分析3.1 Runtime 问题对反射参数进行详细解释 3.2 AnnotationInvocationHandler3.4 AnnotationInvocationHandler反序列化的过程跟踪3.4.0 对于 Anno... 小结一下3.4.1 到了 setValue()了 3.3 readObject中的细节3.4 最后的注解那里不懂 4. 后记5. 参考: 1.前言 URLDNS还是不放了吧，不够丢人的，
推荐feng师傅的：https://ego00.blog.csdn.net/article/details/119701408
先是利用 TransformedMap这个。最终的触发点，就是 那一串Invokertransform 那里，就那一坨东西导致最终的危险。 然后手写demo是通过 map.put() 导致执行Transformed#tranform()，从而触发的。
那么在序列化实战中，我们就要找一个类，在它的反序列化readObject()中，能够触发执行Transformed#tranform()，这里使用的是AnnotationInvocationHandler 的 readObject() 。它里面用了 map.enrty()的·setValue() , 这个也能够触发transform()。可以看3.4.0
构造器的 default 知识
2. 前置知识 2.1 入门demo import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a6f89e2f2f3c252b806858fc6cd036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a831746c9125a315617cb99eafdc9f1/" rel="bookmark">
			面试题：请写出一个jdbc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题：请写出一个jdbc package com.neutech.jdbc; import java.sql.*; /** * @Author rxj * @Date 2021/12/20 9:53 * @Version 1.0 */ public class JdbcTest { public static final String URL = "jdbc:mysql://localhost:3306/fruits?serverTimezone=Asia/Shanghai&amp;useSSL=false";//连接数据库 public static final String USER_NAME = "root";//数据库名字 public static final String PASSWORD = "123456";//数据库密码 public static void main(String[] args) { // 编写JDBC步骤 Connection conn = null; Statement stmt = null; // 只用于DQL语句 ResultSet rs = null; try { //0.使用反射获取驱动 Class.forName("com.mysql.jdbc.Driver"); //1.创建连接 long start = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a831746c9125a315617cb99eafdc9f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48310ce816194a50a7e56a401aff7307/" rel="bookmark">
			Log4j2中2.15.0版漏洞（CVE-2021-45046）的注入原理、复现步骤和如何修复(2.16.0修复原理)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 2.15.0之前版漏洞相关文章
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(一)—开篇与基础知识
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(二)—漏洞原理
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(三)—复现步骤(攻击方法)
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(四)—漏洞修复原理
2.15.0版漏洞相关文章
Log4j2中2.15.0版存在的漏洞（CVE-2021-45046）的注入原理、复现步骤和如何修复(2.16.0修复原理)
2.16.0版漏洞相关文章
Log4j2中2.16.0版中DOS攻击（CVE-2021-45105）的漏洞原理、复现步骤和修复方法(2.17.0修复原理)
一、前言 当Log4j2发布2.15.0版修复了Log4j2基于Ldap的注入漏洞之后。2.15.0的版本很快就被爆出了新的注入漏洞。但是这次漏洞爆出之后，大家却不怎么着急升级，到底是为什么呢？这就需要从该漏洞的原理以及影响说起了。
接下来我们就一起来探索下该漏洞的原理、复现步骤、影响范围，以及官方在2.16.0版本中是如何修复的。
学习该漏洞之前，请先学习理解Log4j2在2.15.0的漏洞的原理。否则你可能很难理解该文中部分内容。具体如下：
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(一)—开篇与基础知识
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(二)—漏洞原理
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(三)—复现步骤(攻击方法)
Log4j2注入漏洞(CVE-2021-44228)万字深度剖析(四)—漏洞修复原理
二、漏洞原理 1、漏洞简介 通过Log4j2官方介绍Log4j – Apache Log4j 2，我们对该漏洞能有如下初步的认识。
该漏洞是因为使用者在日志中打印出了ctx（线程上线文信息）相关的信息。而该信息如果来自用户输入，则会给攻击者可乘之机。其同样可以发起ldap注入攻击，实现执行远程代码或者本地类。
2、具体原理 在介绍给漏洞之前，我们先简单回顾下2.15.0之前版本的漏洞的基本原理和解决步骤 ，根据之前分析，可知原来的漏洞流程大致如下：
1、攻击者发送消息(包含ldap远程执行指令)
2、log4j2打印该日志
3、log4j2解析其中的ldap，于是执行lookup操作
4、触发java的ldap的lookup功能，最终远程指令或者本地存在风险的类被执行。
为了解决该漏洞，官方做了如下两个修改（具体参考下图）：
1、在MessagePatternConverter中默认关闭了lookup功能
2、在JndiManager中新增了域名、协议和解析类的白名单
3、在JndiManager中禁止了远程javaFactory的加载。
由上图可以看到，2.15.0改版之后，攻击者要完整的执行远程代码加载攻击链（图中红色链路），则基本不可能了。因为消息处理中lookup默认被关闭了。同时提供了白名单，给让用户在开启Lookup的时候，能够控制允许哪些域名、协议和类支持调用底层lookup。
那么在2.15.0的版本下，怎样可以绕过这个lookup开关限制呢？
在Log4j2中，我们在配置日志格式的时候，通过需要配置变量来打印日志时间、打印线程ID等。
如上图，其中的ctx前缀表示从线程上下文获取参数api版本信息。当我们在代码执行的时候，将该变量set到ThreadContext中后，该变量就会打印到日志中。
这个功能看似很正常，但是却存在一个问题。即：它支持对其配置内容进行lookup，且其和消息的Lookup完全是两个分支。在继续介绍之前，我们需要简单了解下，Log4j2对日志规则中的变量的处理逻辑。
其对所有的变量都有不同的PatternConverter类来处理解析，从而获取到不同的字符串内容。其对应的子类非常多，部分如下：
我们之前所的2.15.0之前的漏洞就是因为处理消息（配置%m， %msg）的处理类MessagePatternConverter默认开启了lookup功能。
而我们这里介绍的ctx则使用的LiteralPatternConverter处理类，其也开启了lookup功能。
其lookup的功能的实现如下：
1、首先在日志规则中做如下配置。表示日志中需要打印线程上下文中的变量apiVersion对应的值。
2、在代码请求的位置设置apiVersion=${jndi:ldap://localhost:9999/Test}
3、当打印日志的时候，log4j2会解析日志规则。并使用 LiteralPatternConverter类解析${ctx:apiVersion}，将其解析成${jndi:ldap://localhost:9999/Test}
4、解析完成后，发现其还存在${}占位符，于是继续对齐进行解析。判断为ldap
5、于是调用JndiManager执行底层ldap的lookup逻辑。从而触发恶意代码执行。
那么这个功能怎样才会被攻击者利用尼？
因为有些时候，可能log4j2的使用者，会将用户的某个入参传递到ContextMap中，供日志打印出来。将入参直接设置到apiVersion中（为了默认直接设置，实际通常是从header中获取）。
如果是这样的场景，则攻击者即可以想利用2.15.0之前的漏洞一样，传入恶意的ldap串，进行攻击。
其整个攻击原理图如下：
可以看到其和2.15.0版本中的消息处理逻辑很相似。唯一不同的是：
1、该LiteralPatternConverter中默认就允许执行lookup操作。
2、LiteralPatternConverter解析后得到的字符串用于替换${ctx:xxx}所占的位置，最终随日志一起打印。
三、复现步骤 1、基本介绍 接下来，我们来尝试一起复现。其实通过上面的攻击原理图，大家应该比较清楚。我们要构造请求很容，但是因为2.15.0在JndiManager中新增了域名、协议和加载类的白名单。我们还是很难让其调用外部的ldap服务。
但实际上是可以通过构造DNS的方式，让其调用外部服务，从而实现攻击。其官方说法是其已经在MacOS上复现了。参考：Log4j Vulnerability CVE-2021-45046 Now a Critical 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48310ce816194a50a7e56a401aff7307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08700d341062d87f823755e2aac5ab46/" rel="bookmark">
			css 使用:checked实现自定义单选框、复选框、开关、标签复选、素材单选等实用实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义单选框 效果见 https://demo.cssworld.cn/selector/9/2-3.php
&lt;p&gt; &lt;input type="radio" id="radio1" name="radio" checked&gt; &lt;label for="radio1" class="cs-radio"&gt;&lt;/label&gt; &lt;label for="radio1"&gt;单选项1&lt;/label&gt; &lt;input type="radio" id="radio2" name="radio"&gt; &lt;label for="radio2" class="cs-radio"&gt;&lt;/label&gt; &lt;label for="radio2"&gt;单选项2&lt;/label&gt; &lt;input type="radio" id="radio3" disabled&gt; &lt;label for="radio3" class="cs-radio"&gt;&lt;/label&gt; &lt;label for="radio3"&gt;单选项disabled&lt;/label&gt; &lt;input type="radio" id="radio4" checked disabled&gt; &lt;label for="radio4" class="cs-radio"&gt;&lt;/label&gt; &lt;label for="radio4"&gt;单选项checked + disabled&lt;/label&gt; &lt;/p&gt; /* 单复选框 */ [type="radio"], [type="checkbox"] { position: absolute; width: 20px; height: 20px; opacity: 0; cursor: pointer; } /* 单选框 */ .cs-radio { display: inline-block; width: 20px; height: 20px; border: 1px solid gray; border-radius: 50%; background-color: #fff; box-sizing: border-box; vertical-align: -.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08700d341062d87f823755e2aac5ab46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c457e17232dd8ce71e3015ba02260888/" rel="bookmark">
			灰度直方图均衡化讨论【个人原创】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、定义
二、几条性质
2.1 有界性
2.2 单调性
2.3数量稳恒性
2.3.1 均衡化前后对应灰度级数量不变
2.3.2 均衡化前后对应灰度级像素数量不变
三、对计算结果q处理的讨论
3.1 q=-1→q=0
3.2 q=-1 ~首个“空隙”整体+1
3.3 最大连续“空隙”缩减
四、说明
一、定义 我们在灰度直方图(grayscale histogram)的讨论中，对于输入图像中任意一像素(pixel)的灰度级 ，在输出图像中总能找到像素的灰度级 使得
由①式我们显而易见可以得出：
显然仅仅根据①式，想要实现直方图的均衡化是达不到的。如果使图像在所有灰度级上直方图均衡化，则需要在数学上求平均值，即理想状态下输出图像每个灰度级的个数：
([1]由于直方图横纵坐标取值均为非负整数，因此本文讨论一些数学关系需要根据实际做≈处理)
([2]每个直方图底边长为1，其右下角与所对应灰度级坐标刻度对齐，因此所有灰度级直方图底边长之和最大为255+1)
然而做到平均可能会造成原有亮度关系发生改变，为了保持这一关系不被均衡化打乱，那么在输出图像中对于任意灰度级q，需要有
②式即为经过均衡化后输出图像中灰度级q的计算式。
二、几条性质 2.1 有界性 对于 ，代入②式得
2.2 单调性 已知对于 ，则有
对于 ，易得
那么可知即随着k增加，和也随之增加。
2.3数量稳恒性 2.3.1 均衡化前后对应灰度级数量不变 假设原图数量级x经过均衡化后，对应生成灰度级y、z(y&lt;z)，那么根据单调性
即z较y而言，更加亮。然而根据均衡化定义，可知
显然与上述不等式结论相矛盾，因此假设不成立。(其他假设情况可同理证明)
故均衡化前后对应灰度级数量保持不变。
2.3.2 均衡化前后对应灰度级像素数量不变 假设原图数量级x，其像素数量 经过均衡化后，分配至灰度级y、z(y&lt;z)上，分别为 和 。
对于a&lt;y，
即z较y而言，更加亮。然而根据均衡化定义，可知
显然与上述不等式结论相矛盾，因此假设不成立。(其他假设情况可同理证明)
故均衡化前后对应灰度级像素数量保持不变。
三、对计算结果q处理的讨论 根据有界性的讨论可知，对于 ，通过②式计算可得 。但实际上 ，因此我们需要对②式计算结果做出调整以达到均衡化结果的可输出。
根据单调性可知，对于 ，易得
进而可得
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c457e17232dd8ce71e3015ba02260888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f56f748bebfb8a360e81acb6ef9b5ad/" rel="bookmark">
			多台华三交换机堆叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本次在项目中使用了4台华三交换机对堆叠，印象中堆叠最多不能超过15台交换机，优先级最高不能超过30，记不清了，此外优先级越高应该是越有利于选举为主交换机；
2、为了防止配置时候乱套，4台交换机都以23端口做irf虚拟端口1，24端口做irf虚拟端口2，网上很多都是用两台交换机做的，网文里irf-port 1/2和irf-port 2/1，irf-port 2/1和irf-port 1/2，和下边配置里做一下对比，应该就会明白对应序号的意思了，不做赘述了；
3、为了提高堆叠可靠性，可以考虑融合后边缀上的链路聚合参考配置【本文没有这部分具体配置】
物理连接： 1号交换机23口——2号交换机24口
2号交换机23口——3号交换机24口
3号交换机23口——4号交换机24口
4号交换机23口——1号交换机24口
配置： 1号交换机
//设置优先级
system-view
irf member 1 priority 11
//关闭堆叠前端口
int range interface GigabitEthernet 1/0/23 to GigabitEthernet 1/0/24
shutdown
quit
//设置irf虚拟端口1
irf-port 1/1
port group interface GigabitEthernet 1/0/23 （mode normal）
quit
//设置irf虚拟端口2
irf-port 1/2
port group interface GigabitEthernet 1/0/24 （mode normal）
quit
//开启irf物理端口
interface range GigabitEthernet 1/0/23 to GigabitEthernet 1/0/24
undo shutdown
quit
save
2号交换机
//更改设备号
system-view
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f56f748bebfb8a360e81acb6ef9b5ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc3b2f13d7efc1fa3826f82c4fba6c3/" rel="bookmark">
			机器学习(深度学习)算法必备高等数学基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 机器学习、深度学习算法必备高等数学基础知识 在入坑机器学习算法之后，总结了一些关于数学的必备基础知识。
资料百度网盘自取：
链接：https://pan.baidu.com/s/1UfyD-PRAmkrVgVOft1mzvQ
提取码：cvhb
机器学习(深度学习)算法必备线性代数基础知识
1. 函数基础 1. 1收敛与发散
1. 2极限定义
1. 3极限性质
1. 4函数连续性
1.5函数间断点
1. 6导数公式
2. 微积分 2. 1定积分
2. 2中值定理
3牛顿-莱布尼茨公式 3. 梯度 3. 1偏导数
3. 2方向导数
3. 3梯度
4. 拉格朗日乘子法 5. 泰勒公式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f87008d1c1dc02d85807e28fe7dcef1/" rel="bookmark">
			el-carousel在vue项目中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div class="carousel"&gt; &lt;el-carousel indicator-position="outside" @change="changeCarousel"&gt; &lt;el-carousel-item v-for="(item, index) in images" :key="index"&gt; &lt;img class="carousel-img" :src="item.src" /&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;div class="carousel-text"&gt; &lt;label&gt;{{ this.labelCh }}&lt;/label&gt; &lt;label&gt;{{ this.labelEn }}&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; // 幻灯片轮播时赋值text changeCarousel(active, val) { //active为进入幻灯片的索引值 //val 为离开幻灯片的索引值 console.log("active", active); console.log("val", val); this.labelCh = this.texts[active].labelCh; this.labelEn = this.texts[active].labelEn; }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5978ce0d5ef6fdc18e5514e16c5b0929/" rel="bookmark">
			Java中a&#43;&#43;和&#43;&#43;a的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//首先a++和++a都是a=a+1的简写过程，只是方便，所以这么写，在后面for循环里要经常用到a++
public class Demo01{
public static void main(String[] args){
int m = 7;
int n = 7;
int x = 2*m++;
int y = 2*++n;
System.out.println(x+" "+y);// x输出 14 y，输出16,m和n都是8，通过运行结果可以看出，m++是先将m=7的值运算后 ，m才+1。x=2*7，m=7+1。而++n就是先将n=7+1=8算出后在进行赋值。y=2*（7+1）；
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2571bb56f9c2d1dd81ee1ac8783cf29/" rel="bookmark">
			oauth2授权码模式——微信第三方登录原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oauth2有四种授权模式，授权码模式是最常用的模式
oauth2其实就是一种通用的协议，如果你的应用想要支持这种协议就需要通过代码来实现它
不过也没有谁会从头开始去实现这个协议，各种编程语言已经有现成的框架已经实现了oauth2协议，直接引入框架就可以开发一个支持oauth2协议的服务器了
首先思考一个问题：oauth2授权码模式是为了解决什么问题？
解决的问题：
方便用户登录，一个普通用户相比于输入号码和验证码，直接点击微信授权然后登录app，这样使用成本会低很多，降低新用户的使用成本，提升拉新数据安全授权，开放一部分的访问权限 大部分第三方登录采用的都是oauth2授权码模式，下面我们以微信第三方登录为例，理解和学习授权码模式
登录流程：
1 用户访问app点击登录界面，点击第三方登录按钮，比如：QQ，微信，微博。引导用户跳转到第三方授权页面，用户进行授权操作，比如：允许访问头像和昵称
3 用户授权之后携带client_id和client_secret向微信授权服务器申请code
4 微信服务器返回code（授权码）
5 app拿到code后访问app后台接口
11 后台携带code访问授权服务器
12 授权服务器返回token，此时后台需要生成自己userid标识用户，方便下次登录
后台需要自己维护用户信息，自己根据jwt原理生成自己系统的token
虽然使用了第三方登录，但这是为了方便用户，开发人员的工作量并没有因此减少，反而增大了
7 后台携带登录时候获得的token访问资源服务器
9 资源服务器不知道这个token是否是有效的，需要访问授权服务器认证token是否有效
10 认证token结果返回
8 如果token是有效的就给后台返回用户的信息
6 后台给app返回结果，包含用户信息，登录成功
2 用户看到头像信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67609b09ec84e5c4f5b654c56c17fd8/" rel="bookmark">
			二进制与运算、或运算、非运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与运算 "与"运算是计算机中一种基本的逻辑运算方式，符号表示为&amp;，运算法则为遇0得0。也就是说只要有0，结果即为0。
举例
或运算 "或"运算符号表示为|，运算法则为遇1得1。也就是说只要有1，结果即为1。
举例
非运算 "非"运算符号表示为~，运算法则为按位取反，也就是遇1取0,遇0取1，即 ~1 = 0 , ~0 = 1
举例
异或运算 "异或"运算符号表示为^，运算法则为相同取0，不同取1。异或运算，关键在异上面，异为1，否则为0。
举例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/471bac8be057d70d34bd9076775e0ec1/" rel="bookmark">
			【机器学习】利用AdaBoost实现人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cv2 import numpy as np import matplotlib.pyplot as plt import random import math face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_alt.xml') eye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml') img = cv2.imread('01.jfif') imgNew = cv2.resize(img,(1280,960),interpolation=cv2.INTER_LINEAR) gray = cv2.cvtColor(imgNew, cv2.COLOR_BGR2GRAY) #red = cv2.cvtColor(imgNew,cv2.COLOR_BGR2RGB) faces = face_cascade.detectMultiScale(gray,1.1,1) #eyes = eye_cascade.detectMultiScale(red,1.1,1) for (x,y,w,h) in faces: r = random.randint(200, 255) g = random.randint(255-r, 255) b = random.randint(0, 50) roi_face= gray[y:y+h,x:x+w] cv2.circle(imgNew, (math.ceil(x+w/2), math.ceil(y+h/2)), (math.ceil((w+h)/4)), (b, g, r), 6) #eye = eye_cascade.detechMultiScale(roi_face) #cv2.circle(imgNew,(x,y),((w+h)),(0,0,255),2)#用颜色为BGR（255,0,0）粗度为2的线条在img画出识别出的矩型 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/471bac8be057d70d34bd9076775e0ec1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/160/">«</a>
	<span class="pagination__item pagination__item--current">161/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/162/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>