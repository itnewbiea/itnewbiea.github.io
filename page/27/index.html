<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d35a3d25c095f7574c507c6a5563e4/" rel="bookmark">
			Python生成excel文件的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们做平常工作中都会遇到操作excel，那么今天写一篇，如何通过python操作excel。当然python操作excel的库有很多，比如pandas，xlwt/xlrd，openpyxl等，每个库都有不同的区别，具体的区别，大家一起来看看吧~
xlwt/xlrd
xlrd是对于Excel进行读取，xlrd 操作的是xls/xlxs格式的excel
xlwt是对于Excel进行读取，xlwt操作的是xls格式的excel
安装
xlrd是python的第3方库，需要通过pip进行安装
pip install xlrd 1、导入xlrd模块
2、打开Excel完成实例化
3、通过下标获取对应的表（可以通过表名获取）
4、通过列，行或者坐标获取表格的数据
安装
xlwt属于python的第3方库，需要通过pip进行安装
pip install xlwt 写入Excel数据
1、首先导入xlwt第3方库
2、创建一个workbook模块，相当于创建一个xlwt文件
3、通过add_sheet创建一个表格
4、使用write函数进行对表完成写的操作
5、把写完的数据导入到Excel中
openpyxl
OpenPyXl是一个Python的模块 可以用来处理excle表格
安装：
xlrd是python的第3方库，需要通过pip进行安装
pip install openpyxl 使用时在代码内 from openpyxl import Workbook或者from openpyxl import load_workbook
区别在于前者不需要有excle文件存在 后者需要传入一个excle文件
前者可以凭空产生一个 后者不行
使用openpyxl 写入Excel数据 1、获取workbook 2、获取 worksheet 3、再然后 获取单元格 进行操作 4、保存文件 pandas
写入Excel中数据的除了xlwt和openpyxl之外。Pandas也是可以实现这种功能的。
它纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具，能使我们快速便捷地处理数据。接下来我们就看看如何用pandas读写excel。
1. 读取excel 读取excel主要通过read_excel函数实现，除了pandas还需要安装第三方库xlrd。
2. 写入excel 写入excel主要通过pandas构造DataFrame，调用to_excel方法实现。
今天我们准备读取的数据是之前爬取瓜子二手车网站的一些数据，部分数据展示如下：
我们今天要展示的就是使用上述介绍的三种方法将txt文档的数据写入到excel中。
# 标题列表 columns = [] # 数据列表 datas = [] with open('二手车.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d35a3d25c095f7574c507c6a5563e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2eb7e299a11d8779b3220f4950bfd68/" rel="bookmark">
			Jtti 香港服务器使用RAID技术的优势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RAID(冗余磁盘阵列)技术在服务器中的应用为数据存储提供了冗余、性能优化和容错能力。在香港服务器中使用RAID技术可以带来一些优势：
数据冗余：
RAID 提供了数据冗余功能，通过在多个磁盘上存储相同的数据，使得即使其中一个磁盘发生故障，数据仍然可用。这提高了数据的可靠性和安全性。
性能优化：
RAID 技术可以通过在多个磁盘上并行读取和写入数据来提高数据访问速度。具体性能提升取决于 RAID 级别，例如 RAID 0 和 RAID 10 提供了较好的读写性能。
容错能力：
部分 RAID 级别提供容错能力，例如 RAID 1、RAID 5 和 RAID 10.在某一个磁盘发生故障时，系统仍然可以继续运行，直到故障磁盘被更换。
热插拔支持：
一些 RAID 控制器支持热插拔，即在系统运行时添加或替换磁盘。这可以提高服务器的可用性，无需关闭服务器即可进行硬盘维护。
数据恢复：
在某些 RAID 级别下，如果一个磁盘发生故障，系统可以通过冗余的数据或校验信息进行数据恢复，而不会造成数据丢失。
RAID级别选择：
根据实际需求，可以选择不同的 RAID 级别。例如，RAID 0 提供了较高的性能，但没有冗余;RAID 1 提供了完全冗余，但使用了更多的磁盘空间;RAID 5 和 RAID 6 提供了冗余和性能平衡。
提高存储容量：
通过将多个磁盘组成 RAID 阵列，系统可以提高整体存储容量。在一些 RAID 级别下，存储容量增加的同时也能够保持较好的性能和容错能力。
RAID卡缓存：
一些高级 RAID 控制器具备缓存功能，可以加速读写操作，提高数据访问速度。
总体而言，RAID 技术在香港服务器中的应用提供了对数据的保护、性能优化和容错能力的一系列优势。然而，具体选择应根据服务器应用的需求和预算进行权衡，因为不同的 RAID 级别和配置会有不同的权衡点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c01282a500bbd0b61f3fddb6c0aa5e6/" rel="bookmark">
			【浏览器】-- Chorme 常用命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、列出所有支持的命令 直接浏览器地址栏输入：
chrome://about 2、快速退出和重启浏览器 chrome://quit chrome://restart 3、恢复网页翻译支持 chrome://translate-internals/ 4、查询浏览器的版本 chrome://version 5、打开扩展程序界面 chrome://extensions 6、开启实验室功能 chrome://flags/ 7、查看 gpu 状态 chrome://gpu/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6e957c528fc2567b0c52ec847281f9/" rel="bookmark">
			[Qt5] QJson库进行存储、加载数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 一. Boost库介绍二. QJson库介绍三. QJson库生成与解析结构体数据四. QJson库读、存数据的完整代码操作 本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（Qt实战项目视频教程+代码，C++语言基础，C++设计模式，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
一. Boost库介绍 利用Boost库对视觉任务参数的存读时，有一个缺陷就是如果UI界面新增参数时，在界面初始化的时候会读取不到这个新增的参数，导致原任务设置好的的参数会被清掉进而变成默认参数，需要重新做任务保存参数。这对项目初期开发阶段而言非常不友好，增大调试时间成本。
一般需要增加版本号来解决上述的问题：
namespace boost { namespace serialization { template&lt;typename Archive&gt; void serialize(Archive &amp; ar, MS_CreateModelSingle_Params &amp; d, const unsigned int version) { //VISION_LOG_INFO("%d", version);查看版本号 ar &amp; BOOST_SERIALIZATION_NVP(d.m_isPreventReverse);//是否启用防反 ar &amp; BOOST_SERIALIZATION_NVP(d.m_threshLow); //阈值下限 ar &amp; BOOST_SERIALIZATION_NVP(d.m_threshHigh); //阈值上限 ar &amp; BOOST_SERIALIZATION_NVP(d.m_area); //面积 if(version == 2) //只有 version = 新版本号才读取新参数 { ar &amp; BOOST_SERIALIZATION_NVP(d.m_areaRatio); //面积占比 } } } } BOOST_CLASS_VERSION(MS_CreateModelSingle_Params, 2);//当前新版本号，重新保存任务版本号将会更新 这样的话，在初始化的时候就不会读取到新增的参数，也就不会崩溃了。只有在重新保存参数的时候，才会将新增的参数保存到任务文件中。
二. QJson库介绍 本文使用QJson库来作为参数的保存与读取，不使用版本信息也可解决上述Boost库存在的缺陷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b6e957c528fc2567b0c52ec847281f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f776c5d3ffe731f4760c33835013096/" rel="bookmark">
			运筹帷幄，质效兼修：源启云原生基础设施管理平台助推企业IT基础资源能效跃迁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语
数字化大潮席卷，企业需要建设一套能够满足云原生环境下基础资源一体化管理和快速交付的基础设施自动化管理系统，系统需要具备“云上”“云下”“容器”等多维度视角，以及多种类型资源协同编排与一键式能力，能够面向应用实现云原生资源以及周边基础设施资源的快速部署与持续交付。中电金信​应用基础设施即代码（Infrastructure as Code，简称IaC）技术，研发推出源启云原生基础设施管理平台，助力提升基础资源一体化管理和交付效率，以更先进的基础设施管理方式来满足现代企业业务持续扩展和复杂化的需要。
源启云原生基础设施管理平台是源启基础运行支撑平台中基础设施管理层的主要构成部分，也是源启金融级数字底座的重要组成部分。
​
日前，源启云原生基础设施管理平台正式发布。源启云原生基础设施管理平台是实现数据中心服务器​、网络设备、存储设备等物理资源以及虚拟机、容器等虚拟资源统一管理的开放云架构管理软件，是一款基础设施即代码工具，能够进一步提升企业IT基础资源的管理和交付效率、提高安全性和合规性、优化资源配置和成本管理，助推企业IT系统数字化转型。
风起云涌
企业IT基础设施管理如何实现质效兼顾
数据中心基础设施是最早推进信息化、规模化、集约化的高技术领域，整体的技术架构经历了几十年的沉淀，从开始的大型机、小型机、IP网络、存储、安全，到后来的云计算、云原生，在过程中不断完备和成熟，并初步具备了一定的数字化能力。现如今，随着云原生技术的爆炸性发展，数据中心基础设施作为底层算力供给的重要承载、云原生转型的关键一环，如何实现质效兼顾的发展、加速企业IT系统云原生技术转型，成为当下以一持万的破局点。
金融行业作为数字化转型先行者，金融数据中心发展历经虚拟化、云化、云原生等多个发展阶段，当前整体上正处于“稳态+敏态”“传统+云原生”“云上+云下”多模架构共存的阶段，在此阶段多技术栈​相互交叠，应用节点规模爆炸性增长、技术复杂度、管理复杂度持续攀升。以应用发布场景为例，通常涉及对容器、虚拟化、硬件设备等多种资源进行配置，涉及“云上”“云下”等多套环境，整个发布流程需要在外部流程的驱动下多个专业条线协同完成，工作流程冗长，技术复杂度高，资源发放效率亟须提升。
为了解决上述问题，企业需要建设一套能够满足云原生环境下基础资源一体化管理和快速交付的基础设施自动化管理系统，系统需要具备“云上”“云下”“容器”等多维度视角，具备多种类型资源协同编排与一键式能力，能够面向应用实现云原生资源以及周边基础设施资源的快速部署与持续交付。
软件定义
以基础设施即代码实现基础设施自动化
在这样的背景下，“基础设施即代码(Infrastructure as Code，简称IaC)”作为一种新兴的基础设施管理方法，正逐渐成为企业IT数字化转型的关键技术之一。为了以更先进的基础设施管理方式来满足现代企业业务持续扩展和复杂化的需要，中电金信应用基础设施即代码技术，研发推出源启云原生基础设施管理平台。
顾名思义，基础设施即代码是一种使用代码来自动管理和配置基础设施的技术，用户可以通过编写代码的方式来自动设置和调整基础设施，而不是通过手动设置单个硬件设备和操作系统。IaC​使得基础设施的管理工作可以像管理应用程序代码一样进行版本控制、持续集成和自动化部署。
源启云原生基础设施管理平台是源启基础运行支撑平台中基础设施管理层的主要构成部分，也是源启金融级数字底座的重要组成部分。源启云原生基础设施管理平台聚焦数据中心基础设施管理领域，一方面对接“稳态+敏态”“传统+云原生”“云上+云下”等多种形态基础资源，实现各类基础资源的一体化管理；另一方面应用基础设施即代码技术，实现基础设施配置的代码化管理，支持基础配置的一键式部署和快速回退，与DevOps平台对接实现基础设施的持续交付和持续部署。
源启云原生基础设施管理平台主要分为驱动层、编排层、服务层三层架构。
■　驱动层：驱动层提供的多形态基础资源的原子化操作能力，通过云驱动模块、硬件驱动模块、虚拟化/容器驱动模块对接主流云管平台，服务器、网络设备、存储设备、集中备份产品、容器云管理平台，实现对于“云上+云下”“传统+云原生”多形态基础设施的统一管理。
■　编排层：针对多数据中心、多集群、多技术栈共存的复杂场景，依托基础设施即代码技术，实现异构资源的跨集群编排；面向应用发布等复杂运维场景，实现基础设施部署工作流的可视化配置。
■　服务层：基于基础设施即代码技术对各类原子化操作进行组合编排，以代码的方式实现多形态基础设施的协同配置，并提供面向多云管理、多云部署等场景的基础设施持续交付、持续部署服务。
调度有方
源启云原生基础设施管理平台
助推企业数字化转型扬帆远航
源启云原生基础设施管理平台支持主流虚拟化、容器、网络、存储、服务器等基础资源的统一纳管，同时，围绕多云管理、多云部署、多云监控场景，提供可视化的资源编排与流程串接服务。此外，平台采用可插拔式模块管理结构，具备良好的可扩展性，可以基于客户需求进行功能扩展和持续改进；支持容器化部署、多地多中心高可用部署，并全面支持国产化操作系统、芯片及数据库。
通过应用源启云原生基础设施管理平台，在数据中心可以实现多形态基础设施的统一纳管，基于软件工程方法论实现基础设施的持续交付与敏捷供应，提升企业业务敏捷性；可以通过代码管理基础设施，确保每次部署的全局一致性，避免了手工操作中的错误和不一致，提升系统整体可用性；能够推动基础设施维护人员从“面向技术”“面向服务”向“面向业务”转型，基础设施维护人员与应用开发人员共同对业务的整体可用性与敏捷性负责，推动运维向运营的转变；并且由于平台兼容传统技术体系与云原生技术体系，可以基于客户管理流程与需求进行持续改进，能够快速适应业务变化，加速创新；在现有基础上大幅度提升基础设施的敏捷性和可用性，用运营代替运维并实现对需求的迅速响应和持续改进。
源启云原生基础设施管理平台已在多个项目中实践运用。在新一代数据中心建设过程中，平台结合云原生基础设施运行架构最佳实践，能够有效提升企业IT系统的敏捷发布能力，加强系统的可靠性和可伸缩性，降低维护成本，提高运维效率，助推企业数字化扬帆远航。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4399734750aa25bae2679a1d4b212a/" rel="bookmark">
			JWT简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。
优点 1、JWT基于json，非常方便解析。
2、可以在令牌中自定义丰富的内容，易扩展。
3、通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。
4、资源服务使用JWT可不依赖认证服务即可完成授权。
缺点 JWT令牌较长，占存储空间比较大。
JWT组成 一个JWT实际上就是一个字符串，它由三部分组成，头部（header）、载荷（payload）与签名（signature）。
头部（header） 头部用于描述关于该JWT的最基本的信息：类型（即JWT）以及签名所用的算法（如HMACSHA256或RSA）等。
然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分。
载荷（payload） 载荷就是存放有效信息的地方，包含三个部分：
1、标准中注册的声明（建议但不强制使用）
2、公共的声明
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。
3、私有的声明
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。
签名（signature） 这个部分需要base64加密后的header和base64加密后的payload使用 . 连接组成的字符串，然后通过header中声明的加密方式进行加盐 secret 组合加密。
签名信息由三部分组成：
1、header (base64后的)
2、payload (base64后的)
3、secret(盐，一定要保密）
secret是保存在服务器端的，JWT的签发生成也是在服务器端的，secret就是用来进行JWT的签发和验证。它就是服务端的私钥，在任何场景都不应该泄露出去。一旦客户端得知secret, 那就意味着客户端是可以自我签发JWT了。
JWT应用场景 一次性验证 比如用户注册后需要发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性:能够标识用户，该链接具有时效性(通常只允许几小时之内激活)，不能被篡改以激活其他可能的账户…
这种场景就和JWT的特性非常贴近，JWT的 payload 中固定的参数: iss签发者和exp过期时间正是为其做准备的。
restful API的无状态认证
使用JWT来做restful API的身份认证也是值得推崇的一种使用方案。客户端和服务端共享secret，过期时间由服务端校验，客户端定时刷新，签名信息不可被修改。
使用JWT做单点登录 + 会话管理(不推荐) JWT是无状态的，在处理注销，续约问题上会变得非常复杂。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54df5add3efff12398da46d96bff9945/" rel="bookmark">
			自学黑客（网络安全）技术——高效学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.网络安全是什么 网络安全可以基于攻击和防御视角来分类，我们经常听到的 “红队”、“渗透测试” 等就是研究攻击技术，而“蓝队”、“安全运营”、“安全运维”则研究防御技术。
2.网络安全市场 一、是市场需求量高； 二、则是发展相对成熟入门比较容易。 安全不是独立存在的，而是建立在其他技术基础之上的上层应用技术。脱离了这个基础，就很容易变成纸上谈兵，变成“知其然，不知其所以然”，在安全的职业道路上也很难走远。
如果你是原本从事网工运维，那么可以选择网络安全方向入门； 如果你原本从事程序开发，推荐选择Web安全/渗透测试方向入门。 当然学到一定程度、或者有了一定工作经验，不同方向的技术耦合会越来越高，各个方向都需要会一点。
3.所需要的技术水平 需要掌握的知识点偏多（举例）：
4.国家政策环境 对于国家与企业的地位愈发重要，没有网络安全就没有国家安全
更有为国效力的正义黑客—红客联盟
可见其重视程度。
5.自学网络安全学习的误区和陷阱 1.不要试图先成为一名程序员（以编程为基础的学习）再开始学习 行为：从编程开始掌握，前端后端、通信协议、什么都学。
缺点：花费时间太长、实际向安全过渡后可用到的关键知识并不多。
很多安全函数知识甚至名词都不了解 unserialize outfile
2.不要把深度学习作为入门第一课 很多人都是冲着要把网络安全学好学扎实来的，于是就很容易用力过猛，陷入一个误区：就是把所有的内容都要进行深度学习，但是把深度学习作为网络安全第一课不是个好主意。原因如下：
【1】深度学习的黑箱性更加明显，很容易学的囫囵吞枣
【2】深度学习对自身要求高，不适合自学，很容易走进死胡同
3.以黑客技能、兴趣为方向的自学误区： 行为：疯狂搜索安全教程、加入各种小圈子，逢资源就下，逢视频就看，只要是黑客相关的。
缺点： 就算在考虑资源质量后的情况下，能学习到的知识点也非常分散，重复性极强。
代码看不懂、讲解听不明白，一知半解的情况时而发生。
在花费大量时间明白后，才发现这个视频讲的内容其实和自己看的其他知识点是一样的。
4.不要收集过多的资料 网上有很多关于网络安全的学习资料，动辄就有几个G的材料可以下载或者观看。而很多朋友都有“收集癖”，一下子购买十几本书，或者收藏几十个视频
网上的学习资料很多重复性都极高而且大多数的内容都还是几年前没有更新。在入门期间建议“小而精”的选择材料，下面我会推荐一些自认为对小白还不错的学习资源，耐心往下看
6.网络安全学习路线 网络安全（黑客技术）学习路线图
需要高清pdf可以留言
第一阶段：安全基础 网络安全行业与法规
Linux操作系统
计算机网络
HTML PHP Mysql Python基础到实战掌握
第二阶段：信息收集 IP信息收集
域名信息收集
服务器信息收集
Web网站信息收集
Google hacking
Fofa网络安全测绘
第三阶段：Web安全 SQL注入漏洞
XSS
CSRF漏洞
文件上传漏洞
文件包含漏洞
SSRF漏洞
XXE漏洞
远程代码执行漏洞
密码暴力破解与防御
中间件解析漏洞
反序列化漏洞
第四阶段：渗透工具 MSF
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54df5add3efff12398da46d96bff9945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f14354dc8be030fbcf75dcebcf39c8d/" rel="bookmark">
			python股票分析挖掘预测利器Numpy,Pandas，Matplotlib库知识点（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜了，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包，
其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
俗话说的好，工欲善其事，必先利其器，我们要做好项目，必先打好基础，那我们一起学习一下这三个数据分析库，上一章简单的讲了Numpy的基础，这一章我们讲Pandas
（二）Pandas库基础 pandas库是基于Numpy库的一个开源python库，主要运用数据快速分析，清洗和准备等工作，某种程度来说可以把Pandas当成python版的Excel，与Numpy相比，Pandas库更擅长处理二维数组，Pandas库有处理一维数据结构的Series和二维数组的DataFrame.
一维数据结构的Series用法
import pandas as pd s = pd.Series(['李四', '王二', '张三']) print(s) 二维数组的DataFrame.的用法
# 二维数据表格DataFrame的创建** import pandas as pd a = pd.DataFrame([[1, 2], [3, 4], [5, 6]]) print(a) （1）Series入门 Series（系列、数列、序列）是一个带有标签的一维数组，是由一组数据以及与这组数据有关的标签（索引）组成，Series对象可以存储整数、浮点数、字符串、Python对象等多种数据类型的数据，是pandas最基础的数据结构。
（1）Series对象创建 #series对象的创建 import pandas as pd data=[12,22,25,118] index=['章三','里斯','王儿','刘武'] s=pd.Series(data=data,index=index) print(s) (2)Series索引创建 #位置索引 data=[13.14,21.34,5.08,10.18] s=pd.Series(data=data) print(s) print(s[2])#s[2]---获取位置索引为2的值 （3)获取Series的索引和值 data=[13.14,21.34,5.08,10.18] index=['Zhang','liu','wang','haima'] s=pd.Series(data=data,index=index) print(s.index) print(list(s.index))#通常将索引转换成列表输出 print(s.values) (2)DataFrame入门 DataFrame是一个表格型的数据结构。每列都可以是不同的数据类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，这两种索引在DataFrame的实现上，本质上是一样的。但在使用的时候，往往是将列索引作为区分不同数据的标签。DataFrame的数据结构与SQL数据表或者Excel工作表的结构非常类似，可以很方便地互相转换。
下面先来创建一个DataFrame，一种常用的方式是使用字典，这个字典是由等长的list或者ndarray组成的，示例代码如下：
data={'A':['x','y','z'],'B':[1000,2000,3000],'C':[10,20,30]} df=pd.DataFrame(data,index=['a','b','c']) print(df) 显示结果： 从上图我们可以看到，DataFrame主要由如下三个部分组成。
数据，位于表格正中间的9个数据就是DataFrame的数据部分。索引，最左边的a、b、c是索引，代表每一行数据的标识。这里的索引是显式指定的。如果没有指定，会自动生成从0开始的数字索引。列标签，表头的A、B、C就是标签部分，代表了每一列的名称。 （1）DataFrame常用函数及参数 data：ndarray/字典/类似列表 | DataFrame数据；数据类型可以是ndarray、嵌套列表、字典等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f14354dc8be030fbcf75dcebcf39c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec90a6bbd48d208bb8fbb9347f7eb763/" rel="bookmark">
			uview表单校验带星号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uView表单校验带星号可以通过设置required属性来实现。在uView中，可以使用组件来实现表单校验，具体步骤如下：
1、在需要校验的表单元素上添加required属性，例如：
&lt;u-form :model="detailInfo" ref="detailInfo" :labelWidth="133" :rules="rules"&gt; &lt;u-form-item label="出车里程（公里）" prop="drivingMileage" required&gt; &lt;u-input v-model="detailInfo.drivingMileage" placeholder="请填写数值" border="none"/&gt; &lt;/u-form-item&gt; &lt;u-form-item label="回车里程（公里）" prop="returnMileage" required&gt; &lt;u-input v-model="detailInfo.returnMileage" placeholder="请填写数值" border="none"/&gt; &lt;/u-form-item&gt; &lt;/u-form&gt; 2、接着，在需要校验表单的时候，确保你调用了 validate 方法，例如：
this.$refs.detailInfo.validate().then(validate =&gt; {	console.log('校验通过'); }).catch(errors =&gt; { console.log("校验失败"); }) 3、在上面的代码中，我们为每个表单项设置了 prop 属性，并且属性值与校验规则（rules）中的属性名一一对应。这样，在调用 validate方法时，就能正确地触发表单校验了。
data() { return { rules:{ drivingMileage:[{ type: 'number', required: true, message: '请填写出车公里数', trigger: ['blur', 'change'] }], returnMileage:[{ type: 'number', required: true, message: '请填写回车公里数', trigger: ['blur', 'change'] }] } } }, 如果未触发：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec90a6bbd48d208bb8fbb9347f7eb763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de19f267ca5641fb854c653f39584dc1/" rel="bookmark">
			【JavaScript】原型对象 =＞ 原型链的深入浅出解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 先知概念：原型 prototype隐式原型 __ proto __原型链 先知概念： 在了解原型与原型链之前，我们应该要先明确以下几个概念：
1. 在 JS中 所有的普通对象 都是 通过 new 一个函数来创建的。
2. 在 JS中 所有的函数 本质上也是一个对象，它是通过 new Function产生的。
诠释：【1】
我们平时所写的 let a = {};，其实本质上 相当于 let a = new Object(); 我们所简写的 {} 算是一个语法糖，同理 let b = [];，相当于 let b = new Array();，我们简写的 [] 也是一个语法糖
let a = {}; //等同 new Object() console.log(a); let b = []; //等同 new Array() console.log(b); 案例说明：当我们自定义一个函数，并通过 new 来创建一个对象。
问：下面 new test()是否会产生一个对象，并且是哪个构造函数的对象？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de19f267ca5641fb854c653f39584dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8e72f357326d4fcc43192e3b5d928e/" rel="bookmark">
			background-size的几种取值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 background-size:100%: 总是X轴100%铺满整个容器，Y轴可能被剪裁会出现空白填不满的部分，图片不变形。
2、background-size:100% 100%: 图片不保持比例放大或缩小使X轴与Y轴都铺满整个容器，图片可能会变形。
3、background-size:cover: 图片保持比例放大或缩小使X轴Y轴都铺满整个容器，但图片超出容器部分会被剪裁掉，图片不变形。
4、background-size:contain: 图片保持比例放大或缩小，若不能完整填充容器，X轴或Y轴都有可能出现白边，图片不变形。
w3school在线测试工具 v1.2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f41c291f9bcade008428973c71b734/" rel="bookmark">
			如何通过「迭代分支」提高 API 开发的升级效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在软件快速迭代的今天，“敏捷开发”已经成为大多数软件公司的首选。通过小步快跑的方式快速更新产品，持续高效升级，提升用户体验，从而保证产品的竞争力和价值。
在使用敏捷方式进行产品迭代的过程中，必然会碰到以下场景：
本次迭代需要对原有生产环境的 API 进行升级；本次迭代需求的新功能需要引入新的 API。 针对于这类场景，Apifox 推出了「迭代分支」功能，提供了灵活可控的 API 迭代协作机制，既保证了主分支稳定性，又提升了团队工作效率。非常适合敏捷开发的团队，主要优势有：
主分支稳定：开发者基于已存在的 API 开发新版本，但不破坏原有的 API 定义与调用参数。每个迭代分支包含独立的接口、数据模型、响应组件等数据，数据互不影响，保证各分支数据的稳定性和独立性。协作并行：不同团队角色可在不同分支上同时工作，互不干扰，提升协作效率。快速合并：新分支开发完成后，可轻松快速地对比两个分支之间的内容差异，并将迭代分支的内容合并回主分支。 创建与管理迭代分支 当你的 项目角色为「管理员」 时，你可以在「项目设置 - 项目资源 - 管理迭代分支」内创建和管理迭代分支。每条迭代分支都拥有独立的名称、创建时间、创建者信息及资源统计数据。
系统默认内置主分支（main），所有生产环境的 API 文档 都要处于这个主分支内。
对已上线且相关数据资源都已并入主分支的迭代分支，你可以 执行「归档」 操作将其收起，释放分支席位。当前，一个项目中暂时仅支持含有一个未归档的迭代分支。
在子分支上维护 API 文档 在创建未被归档的迭代分支后，你可以点击接口管理的右上角的分支按钮组件，对迭代分支进行切换。切换到分支时，目录树的 UI 背景为淡蓝色渐变，与主分支的纯白背景有明显区别。
新建的迭代分支中默认不包含任何内容。这里的最佳实践是：
对需要升级调整的接口，从主分支创建副本到此迭代分支中；对需要新增的接口，直接在此迭代分支中添加。 需要注意的是，在子分支创建副本时，尽量不要将本次迭代中无需改动的接口导入其中，这会导致数据冗余，降低功能可用性。这里与 Git 的 Fork 概念有区别，研发同学需要区分和理解。
从主分支拉取的副本会在目录树右侧显示关联图标，代表该资源是现有的线上资源，需要进行升级。在迭代分支内编辑资源不会影响到主分支及其他分支的资源内容。
在子分支中完成 API 定义后，团队成员就需要根据子分支的内容进行研发协同了。前端 Mock 数据来写页面，后端生成服务端代码写接口，测试根据文档写用例。
合并至主分支 当实际的研发测试工作已完成，本次迭代的代码也已经发布到线上之后，我们需要回到 Apifox 对应的迭代分支中，对 API 文档、数据模型、响应组件等资源执行「合并至主分支」操作。
合并入口位于目录树右上角分支组件的下拉菜单中，也可以在切换至具体子分支后，在目录最底部找到。只有项目管理员才有权限执行整分支合并的操作。
选择合并后，系统会根据资源具体变更情况及主分支关联关系，自动推荐最合适的处理方式。处理方式有三种：
覆盖：当子分支资源是主分支的关联副本时，默认选择「覆盖」方式，将会用子分支内容完全替换主分支的对应资源。常用于已有接口的升级场景；新增：当此子分支资源是新增的资源，与主分支没有对应关联时，默认选择「新增」方式将该资源在主分支中新增。常用于迭代开发的新功能新接口的场景；不合并：此子分支资源在合并后不对主分支资源做任何操作。常用于此资源没有实际发生变动，或实际上线代码内容与资源内容不匹配不可直接合并至主分支，需要后续调整的场景。 合并分之前，你可以通过「对比」功能，以 YAML 形式查看当前分支与主分支资源间的细节差异对比。
其中数据模型支持可视化 对比。
当然，也可以根据实际情况针对单资源进行合并、对比，只需选中子分支资源后右键即可执行这些操作。
合并完成后，就可以在主分支中查看合并后的资源了。建议在完成合并之后，把已完成的迭代分支归档。
常见疑问 Q ：所有类型的接口都支持迭代分支功能吗？
A ：目前只支持 HTTP 接口使用迭代分支功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71f41c291f9bcade008428973c71b734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f73ad4f771e0ca93fe9bc3a656660a/" rel="bookmark">
			el-date-picker周选择器获取选择的日期范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-date-picker v-model="formData.date" type="week" format="yyyy 第 WW 周" placeholder="选择周" @change="weekChange" &gt; &lt;/el-date-picker&gt; // 方法一： weekChange(val) { let startTime = new Date(val.getTime()); //开始时间 let endTime = new Date(val.getTime() + (24 * 60 * 60 * 1000) * 6); //结束时间 let timeArr = [startTime.toISOString().slice(0, 10), endTime.toISOString().slice(0, 10)]; console.log(timeArr) }, // 方法二： weekChange(val) { let timeStamp = val.getTime(); //标准时间转为时间戳，毫秒级别 let startTimeStamp = this.getDateTime(timeStamp - 24 * 60 * 60 * 1000); //开始时间 let endTimeStamp = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f73ad4f771e0ca93fe9bc3a656660a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1e2cc4a5be6d9e43ddbbc9078a7d18/" rel="bookmark">
			积水监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		积水监测识别摄像机是一种利用摄像技术来监测和识别道路、桥梁、隧道等区域积水情况的设备，它可以有效地提供实时的积水监测信息，帮助交通部门和相关单位及时采取应对措施，确保道路交通的畅通和人员安全。 积水监测识别摄像机通过安装在适当位置的摄像头，实时捕捉和传输积水区域的影像信息，并利用图像识别算法对积水情况进行分析和判断。根据监测要求，摄像机可以实现对不同角度和范围的积水监测，包括普通道路积水、隧道内积水、桥梁附近积水等多种情况。在积水监测识别摄像机的应用中，关键技术包括图像实时传输技术、图像识别算法、智能分析技术等。通过这些技术手段，摄像机能够准确地识别出积水区域，判断积水深度和覆盖面积，并根据预设的阈值进行报警和预警处理。摄像机在道路交通管理、城市防洪系统、自然灾害监测等领域具有广泛的应用前景。它可以为交通管理部门提供及时、准确的积水信息，帮助其做好路况预警和交通疏导工作；同时也可以在防洪预警系统中发挥重要作用，为城市管理部门提供宝贵的监测数据，帮助其做出科学的决策。
值得注意的是，积水监测识别摄像机在应用过程中需要充分考虑隐私和数据安全等问题，确保监测数据的合法、安全使用。另外，对于摄像机设备的选型和布设位置也需要科学规划，以确保监测效果和成本效益。总的来说，积水监测识别摄像机能够为交通管理和城市防洪等领域提供重要的监测信息，为预防和减轻自然灾害带来的损失发挥积极作用。随着科技的不断发展，这一领域的技术和设备会越来越智能化和便捷化，为人们的生活和安全保障提供更加有力的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d627169adf0f619e2e4392c6d944ed6f/" rel="bookmark">
			Electron &#43; Vue 项目从零创建，不使用 vue-electron-template
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Electron + Vue 项目创建 1. vite项目框架搭建 按照一般的开发流程，用命令行创建一个vite项目：
# use npm or yarn or pnpm npm(yarn | pnpm) create vite 根据自己的需要，选择相应的选项。创建完成后，进入项目，安装依赖并运行，一个基础的vite项目就创建好了。
ex：默认创建时，可能需要的额外操作 TS支持
由于vite默认使用esbuild处理TS，天然支持它，因此只需要添加TS相关依赖，并编写tsconfig.json以应用TS检查即可。
# use npm or yarn or pnpm npm install -D typescript vue-tsc // tsconfig.json { "compilerOptions": { "target": "esnext", "module": "esnext", "strict": true, "jsx": "preserve", "moduleResolution": "node", "isolatedModules": true, "skipLibCheck": true, "esModuleInterop": true, "allowSyntheticDefaultImports": true, "forceConsistentCasingInFileNames": true, "useDefineForClassFields": true, "sourceMap": true, "baseUrl": ".", "types": [ "webpack-env" ], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d627169adf0f619e2e4392c6d944ed6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a643eeb5bf3c322741e29410ea1f152b/" rel="bookmark">
			Vue Echarts 多折线图只有一条X轴（合并X轴数据并去重排序） - 附完整示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts：一个基于 JavaScript 的开源可视化图表库。
目录
效果
一、介绍
1、官方文档：Apache ECharts
2、官方示例
二、准备工作
1、安装依赖包
2、示例版本 三、使用步骤
1、在单页面引入 ' echarts '
2、指定容器并设置容器宽高
3、数据处理（关键点）
四、完整示例
tips
效果 一、介绍 1、官方文档：Apache ECharts Apache EChartsApache ECharts，一款基于JavaScript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。https://echarts.apache.org/zh/index.html
2、官方示例 二、准备工作 1、安装依赖包 npm install echarts --save 2、示例版本 "echarts": "^5.4.2", 三、使用步骤 1、在单页面引入 ' echarts ' import * as echarts from "echarts"; 注：上面的代码会引入 ECharts 中所有的图表和组件，如果你不想引入所有组件，也可以使用 ECharts 提供的按需引入的接口来打包必须的组件。详见官方文档：在项目中引入 ECharts - 入门篇 - Handbook - Apache ECharts
2、指定容器并设置容器宽高 &lt;template&gt; &lt;div id="main"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as echarts from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a643eeb5bf3c322741e29410ea1f152b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a82f3257edce254ca42bd884465c980/" rel="bookmark">
			Microsoft刷题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PASS区 串联字符串的最大长度通知所有员工所需的时间单词搜索最大子序和删除字符串中的所有相邻重复项 II压缩字符串行星碰撞 PASS但想再练一次 车队 PASS但非最优 合并区间实现 Trie (前缀树)搜索二维矩阵 非PASS区 将石头分散到网格图的最少移动次数去除重复字母和为K的子数组颜色分类基本计算器 II和为K的子数组火柴拼正方形 注意 dfs 应该是i+1，而不是idx+1，老容易写错 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f78e7d2c910b138ee1dca70a2b57b7/" rel="bookmark">
			ensp实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 vlan实验LSW二号口操作LSW 三号口跟上面一样配置完成后到他的中心链路上配置一号口另一个lsw2以此类推注意 静态路由实验动态路由ofpsRIP 动态路由协议dhcp实验本次用的是global的方式使用interface的方法 三层交换机实验静态路由 单臂路由设置路由器做交换 删除重复路由实战R1配置 vlan实验 access是只能允许一个vlan口通过，而trunk是允许多个
#先设置二号口和三号口
#创建两个vlan
#LSW1
vlan batch 10 20
LSW二号口操作 #配置access口
port link-type access
#只允许通过vlan10
port default vlan 10
LSW 三号口跟上面一样 配置完成后到他的中心链路上配置一号口 #进入一号口配置trunk模式
port link-type trunk
#配置vlan10 20都可以通过串口通过
port trunk allow-pass vlan10 20
另一个lsw2以此类推 注意 如果你想让两个不同的vlan网段进行通信，比如vlan10 vlan20通信那就需要静态路由。
ip route-static 192.168.2.1 255.255.255.0 192.168.1.2
ip route-static 192.168.2.1 255.255.255.0 192.168.1.1
如果还不通
查看路由表
display ip routing-table
静态路由实验 如果两个网段要传输数据的话需要用到下一跳。
比如ar2要传数据到ar1
配置下一跳地址 r2回传数据到r1
#ip route-static 192.168.1.0 24 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f78e7d2c910b138ee1dca70a2b57b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528d5a0dbc1a33d2018bc43e786a8264/" rel="bookmark">
			.NET 8 网络改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：
Máňa - Software Engineer, .NET Natalia
Kondratyeva - Software Engineer, .NET
排版：Alan Wang
随着新的 .NET 版本的发布，发表有关网络空间中新的有趣变化的博客文章已经成为一种传统。今年，我们要介绍 HTTP 部分的变化、新增指标、新的 HttpClientFactoryAPI 等。
HTTP 指标 .NET 8 使用 .NET 6 中引入的 System.Diagnostics.Metrics API 将内置 HTTP 指标添加到 ASP.NET Core 和 HttpClient。Metrics API 和新内置指标的语义都是与 OpenTelemetry 密切合作设计的，确保新指标符合标准，并与 Prometheus 和 Grafana 等流行工具良好配合。
System.Diagnostics.MetricsAPI 引入了许多 EventCounters 所缺少的新功能。新的内置指标广泛利用了这些功能，从而通过更简单、更优雅的工具实现了更广泛的功能。举几个例子：
Histograms 允许我们能够报告持续时间，例如请求持续时间（ http.client.request.duration）或连接持续时间（http.client.connection.duration）。这些是没有 EventCounter 对应项的新指标。Multi-dimensionality 允许我们将标签（又名属性或标签）附加到测量值上，这意味着我们可以将 server.address （标识 URI 来源）或 error.type（描述请求失败时的错误原因）之类的信息与测量值一起报告。多维还可以实现简化：为了报告打开的 HTTP 连接数，SocketsHttpHandler 使用 3 个 EventCounters：http11-connections-current-total、http20-connections-current-total 和 http30-connections-current-total，而这些计数器的 Metrics 等效项是单个工具 http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528d5a0dbc1a33d2018bc43e786a8264/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d645f3230edc0c76679a77b224c35626/" rel="bookmark">
			C&#43;&#43;结构体的内存分配细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用C++处理固定长度和结构的数据传输时，直接把接收的数据视为字符数组并按协议约定的数据格式拼接，会涉及大量编程。因此，博主在做项目的时候倾向于在结构体中按协议定义数据类型，然后将接收的数据直接拷贝到结构体的内存中，以实现高效的数据解析。这样既减少了代码量，也提高了处理效率。
在执行这种操作时，需要精确掌握结构体中内存分配的细节。因此博主对其进行了一番研究，总结如下：
空结构体长度为1，验证代码如下： //创建一个空结构体 struct emptyStruct { }; int main() { int emptyStructSize = sizeof(emptyStruct); std::cout &lt;&lt; "emptyStructSize = " &lt;&lt; emptyStructSize &lt;&lt; std::endl; } 输出“emptyStructSize = 1”。 有同一类型数据成员的结构体占用空间为结构体成员占用的空间。验证代码如下： //创建一个对齐的结构体 struct alignedStruct { char a;//1字节 char b;//4字节 }; int main() { int alignedStructSize = sizeof(alignedStruct); std::cout &lt;&lt; "alignedStructSize = " &lt;&lt; alignedStructSize &lt;&lt; std::endl; } 输出“alignedStructSize = 2”。
有不同类型数据成员的结构体占用的空间为结构体成员中，占字节最大的数据成员的空间的整数倍。验证代码如下： //创建一个非对齐的结构体 struct notalignedStruct { char a;//1字节 int b;//4字节 }; int main() { int notalignedStructSize = sizeof(notalignedStruct); std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d645f3230edc0c76679a77b224c35626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789a2f3553f97c61543eebdd6dd163ed/" rel="bookmark">
			【工具】HxD Hex Editor 的安装、使用详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 HxD Hex Editor 是一款功能强大的十六进制编辑器和磁盘编辑器，它可以让你直接查看和编辑二进制文件的内容。你可以使用HxD Hex Editor来分析、修改和处理各种数据格式，包括程序文件、磁盘映像、内存转储以及其他二进制文件。
安装步骤 下载地址：HxD | https://mh-nexus.de/en/hxd
在首页中，鼠标下滑至图片所示处：
选择电脑版本对应的version，安装后解压：
点击HxDSetup.exe，选择中文：
点击下一步：
接受协议并点击下一步：
选择安装位置：
接着一路点击下一步即可完成安装
功能介绍 HxD Hex Editor具有以下主要功能：
(1) 以十六进制表示方式显示文件内容，并允许直接编辑其中的字节。
图示为在gif图像数据中添加一句话木马：
(2) 支持将数据按特定数据类型进行解析和显示，方便对结构化数据进行编辑和分析。
(3) 可用于比较两个文件的差异，以找出变更或修改的部分。
(4) 可以执行文本或二进制数据的搜索和替换操作，帮助您定位和修改特定的数据。
搜索特定关键词：
搜索结果：
(5) 支持将数据导入到文件中或将文件导出为不同的数据格式。
(6) 能够处理非常大的文件，并且在编辑和浏览时保持快速响应。
了解更多详情：https://mh-nexus.de/en/hxd/
用途 HxD Hex Editor通常用于以下几个方面：
帮助软件开发人员进行反汇编、调试和逆向工程。它可以让你查看和修改程序的二进制代码，以理解其内部结构、修复漏洞或进行功能定制。
对于受损的文件或存储介质，HxD Hex Editor可以帮助您直接浏览并修复数据错误。你可以通过查看和编辑二进制数据来识别并修复文件中的损坏部分，如磁盘映像、内存转储等。
HxD Hex Editor提供了强大的数据分析和处理功能，一些游戏会使用二进制文件格式来存储游戏数据。HxD Hex Editor可以让你直接修改游戏文件，如修改游戏参数、分析游戏数据结构、调整游戏难度等。
总结 以上为HxD Hex Editor 工具的安装、使用详细教程，读者可结合官方文档躬身实践。
HxD工具使用案例： 基于HxD编辑器的upload-labs Pass-17 解题详析
我是秋说，我们下次见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07456ed72b162966f15684374c26b0f1/" rel="bookmark">
			NumPy教程（二）—— 数据存储及各种常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.文件输入和输出 1.1 CSV文件的存取 csv文件的读取（读） 语法：np.loadtxt（frame，dtype=np.float，delimiter=None，unpack=False）
参数： frame：文件、字符串或产生器的名字，可以是.gz或.bz2的压缩文件
dtype：导入时需要将csv文件中的元素由字符串指定为一个固定格式
delimiter：分割字符串，默认是空格（存储CSV文件，要改为逗号）
unpack：读入的属性是否写入不同变量（默认False，写入同一个变量）
将数据写入文件（存） 语法：np.savetxt（frame，array，fmt = ‘%.18e’，delimiter = None）
参数： array：要存入文件的数组
fmt：写入文件时每个元素使用的格式（默认科学计数法保留18位小数） %d：整数
import numpy as np a = np.arange(100).reshape(5,20) np.savetxt('a.csv', a, fmt="%d", delimiter=",") #存储 b = np.loadtxt('a.csv',delimiter=",") #读取 print(b) 1.2 numpy的便捷文件存取 numpy可以在硬盘中将数据以文本或二进制的形式进行存入硬盘或由硬盘载入
下述函数是numpy高效存取硬盘数据的工具函数
函数描述np.save（frame，array） 将数组存储到文件中
但必须以.npy为文件名
np.savez（frame，a=arr1, b=arr2） 将多个数组保存到一个文件中
必须以.npz为文件名
数组以类似键值对形式传入
导入时，会得到一个类似字典的对象
np.savez_compressed
（frame，a=arr1, b=arr2）
将多个对象存入压缩文件中np.load（frame）读取 .npy 或 .npz 格式的数据 import numpy as np a = np.random.randn(5,5) b = np.random.randn(3,3) np.save("a.npy",a) np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07456ed72b162966f15684374c26b0f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d486d26fc1d98ecb801eab5e51c2ac11/" rel="bookmark">
			Vue-Pinina基本教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 官网地址：Pinia | The intuitive store for Vue.js (vuejs.org)
看以下内容，需要有vuex的基础，下面很多概念会直接省略，比如state、actions、getters用处含义等
1、什么是Pinina Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。 如果您熟悉 Composition API，您可能会认为您已经可以通过一个简单的 export const state = reactive({}). 这对于单页应用程序来说是正确的，但如果它是服务器端呈现的，会使您的应用程序暴露于安全漏洞。 但即使在小型单页应用程序中，您也可以从使用 Pinia 中获得很多好处：
dev-tools 支持 跟踪动作、突变的时间线Store 出现在使用它们的组件中time travel 和 更容易的调试 热模块更换 在不重新加载页面的情况下修改您的 Store在开发时保持任何现有状态 插件：使用插件扩展 Pinia 功能为 JS 用户提供适当的 TypeScript 支持或 autocompletion服务器端渲染支持 2、与vuex比较 Pinia 最初是为了探索 Vuex 的下一次迭代会是什么样子，结合了 Vuex 5 核心团队讨论中的许多想法。最终，我们意识到 Pinia 已经实现了我们在 Vuex 5 中想要的大部分内容，并决定实现它 取而代之的是新的建议。
与 Vuex 相比，Pinia 提供了一个更简单的 API，具有更少的规范，提供了 Composition-API 风格的 API，最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d486d26fc1d98ecb801eab5e51c2ac11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021c88c11f013d673056b9bfff8355de/" rel="bookmark">
			城市的冬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雪尽南坡雁北飞，
草根春意胜春晖。
南湖永日无人到，
独绕寒池又独归。
---裴夷直
冬日的南湖
就像一幅静谧美好的画卷
不同的风景中
有着不一样的魅力
那么，你最喜欢你的城市那个季节呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82dda2248fef348518f9cd5fb9960fc/" rel="bookmark">
			【开源】基于JAVA语言的大学生相亲网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块三、系统展示四、核心代码4.1 查询会员4.2 查询相亲大会4.3 新增留言4.4 查询新闻4.5 新增新闻 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的大学生相亲网站，包含了会员管理模块、新闻管理模块、相亲大会模块、留言管理模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，大学生相亲网站基于角色的访问控制，给相亲管理员、红娘老师使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 本系统包含容纳了各所高校人员的信息管理，另外还有站内新闻，交友信息，相亲大会活动，在线留言板等内容。
本系统共有账号管理、会员信息管理、新闻管理、相亲大会管理、留言管理五大模块。会员信息管理模块，记录了注册的会员的详细信息，管理注册的用户，进行审核、修改、删除信息等操作。账号管理模块包括对用户名、密码、确认密码、权限的管理。新闻管理模块主要有添加新闻、查询新闻，包括标题、内容、人等。相亲大会管理模块进行添加活动、查询活动，包括活动标题、时间、地点、费用、备注等。留言管理模块通过搜索姓名，留言概要查找会员的信息，可进行回复、修改、删除操作。
本系统将使用B/S体系结构，进行需求分析、体系结构设计、代码构建和测试，以Java、HTML5、CSS3、javaScript.,作为编程语言，使用Mwsa…数据库，以idea、VSCode 作为开发工具，采用三层架构模型，运用一些 Java 中经典框架如Spring、SpringBoot、SpringMVC、Mbatis等来进行开发。使用Maven构建工具来配置开发需要的环境。
可以实现会员注册，查看新闻（会员们的交友信息），交友查询，相亲大会活动，在线留言。
账号管理：用户名、密码、确认密码、权限。会员管理：注册会员管理（管理注册的用户，审核、修改、删除信息等操作）。新闻管理：添加新闻、查询新闻，包括标题、内容、人等。相亲大会管理：添加活动、查询活动，包括活动标题、时间、地点、费用、备注等。留言管理：通过搜索姓名，留言概要查找会员的信息，可回复、修改、删除。 三、系统展示 四、核心代码 4.1 查询会员 @RequestMapping(value = "/getByPage", method = RequestMethod.GET) @ApiOperation(value = "查询会员") public Result&lt;IPage&lt;Member&gt;&gt; getByPage(@ModelAttribute Member member ,@ModelAttribute PageVo page){ QueryWrapper&lt;Member&gt; qw = new QueryWrapper&lt;&gt;(); if(!ZwzNullUtils.isNull(member.getName())) { qw.like("name",member.getName()); } if(!ZwzNullUtils.isNull(member.getResidence())) { qw.like("residence",member.getResidence()); } if(!ZwzNullUtils.isNull(member.getAddress())) { qw.like("address",member.getAddress()); } if(!ZwzNullUtils.isNull(member.getHouse())) { qw.like("house",member.getHouse()); } if(!ZwzNullUtils.isNull(member.getSchooling())) { qw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a82dda2248fef348518f9cd5fb9960fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac252936eaa1420469022a278f1b9ef/" rel="bookmark">
			YOLO系列算法在实际项目中的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLO（You Only Look Once）算法在AI领域目标检测方向的优势主要体现在速度、精度和效果上。以下是详细介绍：
速度快：YOLO算法只需进行一次前向传播即可完成整张图像的检测，因此处理速度非常快，能够实现实时处理视频流数据。具体而言，该算法在CPU上运行时速度可以达到30 FPS，而在GPU上运行时速度更可达到100 FPS以上。精度高：YOLO算法采用全局损失函数，能够在不同尺度的特征图上进行检测，从而提高了检测的精度。此外，该算法还采用交叉损失函数，能够同时预测目标的类别和位置，进一步提升了检测的精度。目标检测效果好：YOLO算法在目标检测方面表现优异，能够检测出各种大小、形状和旋转角度的目标，并且在复杂背景下也具有较好的检测效果。 在作用方面，YOLO算法主要用于识别和定位图像或视频中的目标物体，它可以应用于多个领域，如自动驾驶、视频监控和安防、工业质检、零售和物流等。以下是YOLO算法的一些具体使用场景：
自动驾驶：YOLO目标检测可以帮助自动驾驶系统识别和定位道路上的车辆、行人、交通标志等，从而提高驾驶安全性和智能化水平。视频监控和安防：将YOLO目标检测应用于视频监控系统中，可以实时监测和识别异常行为、物体入侵等，提供及时的安防预警。工业质检：YOLO目标检测可以用于工业生产线上的质量检测，例如检测产品的缺陷、计数产品数量等，提高生产效率和质量。零售和物流：利用YOLO目标检测技术，可以实现商品的自动识别和计数，提高零售业和物流业的自动化水平，减少人工成本。 此外，在医疗、农业等领域中，YOLO算法也有广泛的应用。例如，在医疗领域中可以用于胃镜息肉检测、药品表面缺陷检测、CT医疗图像检测等；在农业领域中可以用于病虫害检测、成熟度检测、生育期检测等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e15da6b6e125180159fa58e7c8e8f3/" rel="bookmark">
			Google Chrome 默认安装路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		'''
环境：win10 + chrome 120.x.x.x
可执行文件路径 C:\Program Files\Google\Chrome\Application\chrome.exe
个人资料路径 C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default
环境：win7 + chrome 80.x.x.x
可执行文件路径 C:\Users\用户名\AppData\Local\Google\Chrome\Application\chrome.exe
个人资料路径 C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default
'''
'''
参考：
https://blog.csdn.net/goldentec/article/details/104795479
https://blog.csdn.net/RadiantJeral/article/details/114404785
'''
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc63d621e709f544e9437cbd71e86c78/" rel="bookmark">
			Skywalking系列之本地Plugin测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有机会参与Skywalking插件开发的同学，除了根据官方文档来本地测试，希望这篇文档也能帮到你。
1、关于 Plugin-test 官方文档解读2、基础镜像依赖3、测试用例项目介绍 startup.shexpectedData.yamlconfiguration.ymlsupport-version.list 实际测试 1、关于 Plugin-test 官方文档解读 官方文档Plugin-test说明链接
环境需求：
MacOS/LinuxJdk8 及以上docker环境 2、基础镜像依赖 主要涵盖JDK和Container两块:
仅JVM环境，无需tomcat的情况：面向内嵌的Web应用服务器，比如SpringBoot项目，默认eclipse-temurin:8-jdk，如果JDK调整可以自行去搜索其他版本，比如eclipse-temurin:17-jdk需要额外Tomcat环境：面向无Web应用服务器的项目，比如Spring项目，默认tomcat:8.5-jdk8-openjdk，如果JDK调整可以自行去搜索其他版本，比如tomcat:10.1-jdk17-temurin 3、测试用例项目介绍 测试用例项目什么时候写？
有新增插件类型，现有的测试用例通过增加版本已经不满足流程测试需求，此时需要增加额外的一个测试用例项目，便于他们快速熟悉插件的使用逻辑测试用例项目怎么写？
可以参照下面的流程来组织项目测试项目提交前需要满足什么？
按照下面的流程完成本地的自测，跑通后可以提交如果项目跑起来测试能够正常，测试工具无法跑通，怎么办？
可能是测试工具中的一次不适配，可以自己研究测试工具的源码 项目主体架构
JVM类型基础项目结构
[plugin-scenario] |- [bin] |- startup.sh |- [config] |- expectedData.yaml |- [src] |- [main] |- ... |- [resource] |- log4j2.xml |- pom.xml |- configuration.yml |- support-version.list [] = directory Tomcat类型基础项目结构
[plugin-scenario] |- [config] |- expectedData.yaml |- [src] |- [main] |- ... |- [resource] |- log4j2.xml |- [webapp] |- [WEB-INF] |- web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc63d621e709f544e9437cbd71e86c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc3ae62947ea465189d3ef14aeef006/" rel="bookmark">
			【高压电路】高压电路测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、注意事项： 1、高压电路测试要注意安全；使用电压源，限制电流。
2、高压电路首先在低压下调试，先调试低压部分正常工作。例如：310V转15V，15V转3.3V电路。那么可以首先将15V电源部分引出来，电压源直接给15V左右，检查15V和3.3V部分工作正常。
示波器电压输入 示波器能够输入的电压是40Vpp，当需要输入大于40Vpp的电压时，需要使用探头。
例如：
测量400V电压的信号，需要使用普通探头，10：1衰减。
测量1600V电压的信号，需要使用高压差分探头，100：1衰减。
2、示波器测试带宽的意义： 带宽就是频率宽度。示波器探头是一个低通RC滤波器，高频信号会被衰减。示波器的带宽就是低通滤波器的带宽。。示波器频率是被测信号的5倍，遵循5倍法则，此时测量信号是原信号的98%，例如20M的正弦信号，用100MHz的带宽测量合适。
注意：如果原信号是方波，那么5倍法则也会丢失原信号的特征，因为方波信号由很多高频信号组成，高频信号丢失，方波也就不够方了。
3、示波器的差分探头的意义：？？？ 浮地测量；
注：输入线双绞，能够消除噪声？？；
5、DCDC电路和LDO电路：？？？
6、二极管的种类及其应用：
应用领域：
常规二极管用来整流和线圈续流；
肖特基二极管：开关速度快，弥补了常规二极管速度的不足。重要参数反向恢复电流很小，10ns左右。常规二极管反向恢复电流2000ns左右。常用于200V以下的低压大电流场合，用于开关电源中续流二极管。
稳压二极管：用来钳位电压。
电压抑制二极管：用来抗住尖峰电压，如静电。
二极管本质还是应用其正向导通和反向截至的作用。如续流，整流，钳位。
7、二极管自激振荡电路？？
8、倍压整流电路：对交流电实现整流和倍压作用的电路。例如下面的二倍压整流电路。电容和二极管的组合，利用电容充电特性和电容两端电压不会突变的特性，实现电压的叠加。
单相串励电机 串励电机指的是转子和定子都是线圈绕组构成，并且转子电阻和定子绕组是串联的，属于交流异步电机。交直流都能用的电机，因为带有电刷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc43993e3dbf2c4c0be781d1ddc0e0d/" rel="bookmark">
			React Native 从类组件到函数组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 发展趋势 React Native社区中的趋势是朝向使用函数组件（Functional Components）和Hooks的方向发展，而不是使用类组件（Class Components）。
React Native自推出Hooks API以来，函数组件和Hooks的使用变得更加普遍和推荐。Hooks提供了更简洁、可读性更高的代码，并且在状态管理、生命周期等方面提供了更强大的功能。使用Hooks可以更容易地共享逻辑和状态逻辑，而无需使用类组件的复杂结构。
以下是一些关于为什么React Native社区更倾向于使用函数组件和Hooks的理由：
可读性和简洁性： 函数组件通常比类组件更短，更易于阅读和理解。Hooks的引入使得在函数组件中管理状态和副作用变得更为直观。
逻辑复用： Hooks使得逻辑的复用更加容易。你可以使用自定义Hooks将组件之间的逻辑进行抽象和共享，而不需要使用高阶组件或渲染属性。
更直观的副作用处理： 使用useEffect等Hooks来处理副作用相对于类组件中的生命周期方法更为直观。
更容易集成现代JavaScript特性： 使用函数组件和Hooks可以更容易地与ES6+和TypeScript等现代JavaScript特性集成。
更好的性能优化： Hooks使得React能够更好地进行性能优化，并且React Native的未来版本也更加注重性能。
2. Hooks vs Class Hooks 提供了在函数组件中执行副作用和访问状态的能力。下面是一些常见的 Hooks 及其在类组件中对应的生命周期方法：
useState - setState: 函数组件： 使用 useState 来声明和更新状态。类组件： 使用 this.setState 来更新状态。 useEffect - componentDidMount, componentDidUpdate, componentWillUnmount:
函数组件： 使用 useEffect 来执行副作用，可以模拟生命周期方法的行为。类组件： componentDidMount: 在组件挂载后调用。componentDidUpdate: 在组件更新后调用。componentWillUnmount: 在组件卸载前调用。 useEffect(() =&gt; { // componentDidMount 和 componentDidUpdate 的逻辑 return () =&gt; { // componentWillUnmount 的逻辑 }; }, [dependencies]); useContext - contextType: * 函数组件： 使用 `useContext` 来访问 React 上下文。 * 类组件： 使用 `contextType` 来访问 React 上下文。 useReducer - setState 和 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc43993e3dbf2c4c0be781d1ddc0e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c04331baa207ae60016b461eaba5c39/" rel="bookmark">
			大创项目推荐 深度学习OCR中文识别 - opencv python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 实现效果3 文本区域检测网络-CTPN4 文本识别网络-CRNN5 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **基于深度学习OCR中文识别系统 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 在日常生产生活中有大量的文档资料以图片、PDF的方式留存，随着时间推移 往往难以检索和归类 ，文字识别（Optical Character
Recognition，OCR ）是将图片、文档影像上的文字内容快速识别成为可编辑的文本的技术。
高性能文档OCR识别系统是基于深度学习技术，综合运用Tensorflow、CNN、Caffe
等多种深度学习训练框架，基于千万级大规模文字样本集训练完成的OCR引擎，与传统的模式识别的技术相比，深度学习技术支持更低质量的分辨率、抗干扰能力更强、适用的场景更复杂，文字的识别率更高。
本项目基于Tensorflow、keras/pytorch实现对自然场景的文字检测及OCR中文文字识别。
2 实现效果 公式检测
纯文字识别
3 文本区域检测网络-CTPN 对于复杂场景的文字识别，首先要定位文字的位置，即文字检测。
简介
CTPN是在ECCV
2016提出的一种文字检测算法。CTPN结合CNN与LSTM深度网络，能有效的检测出复杂场景的横向分布的文字，效果如图1，是目前比较好的文字检测算法。由于CTPN是从Faster
RCNN改进而来，本文默认读者熟悉CNN原理和Faster RCNN网络结构。
相关代码
​
def main(argv): pycaffe_dir = os.path.dirname(__file__) parser = argparse.ArgumentParser() # Required arguments: input and output. parser.add_argument( "input_file", help="Input txt/csv filename. If .txt, must be list of filenames.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c04331baa207ae60016b461eaba5c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/426665856b50f5410b809cf1b41a21c7/" rel="bookmark">
			【案例】简单的账号短信登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="loginhome" :style="backgroundContentright"&gt; &lt;div class="content" :style="{ position: 'absolute', 'top': '30%', left:loginwidth &lt; 500? '15%':'40%' }"&gt; &lt;table style="width:100%;height:100%;"&gt; &lt;tr&gt; &lt;td colspan="3"&gt;&lt;div class="title"&gt;&lt;span&gt;系统登录&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="3"&gt;&lt;div&gt;&lt;el-input type="text" style=" width:96%;margin:0 2% 0 2%;" v-model="phone" placeholder="手机号"&gt;&lt;/el-input&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="3"&gt; &lt;div v-if="loginway == false"&gt; &lt;el-input show-password v-model="pass" style="width:96%;margin:0 2% 0 2%;" placeholder="密码"&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;div v-if="loginway == true"&gt; &lt;el-input placeholder="验证码" v-model="code" style="width:96%;margin:0 2% 0 2%;" &gt; &lt;el-button slot="suffix" style="font-weight:600;" type="text" @click="iClick"&gt;获取验证码&lt;/el-button&gt; &lt;/el-input&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/426665856b50f5410b809cf1b41a21c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf42985102a3e7378e53df7f025608ef/" rel="bookmark">
			C&#43;&#43; Qt开发：Charts折线图绑定事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 是一个跨平台C++图形界面开发库，利用Qt可以快速开发跨平台窗体应用程序，在Qt中我们可以通过拖拽的方式将不同组件放到指定的位置，实现图形化开发极大的方便了开发效率，本章将重点介绍QCharts折线图的常用方法及灵活运用。
本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（Qt实战项目视频教程+代码，C++语言基础，C++设计模式，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓
本章将继续为绘图组件绑定事件，通常在未绑定事件的图形上所有的元素都是被禁用状态的，我们无法直接操作这些功能，通过绑定图形组件事件将可以实现对图形的各种操作模式，例如可以控制图形的大小，控制线条的显示与消除等。
首先，我们来实现动态显示与隐藏线条功能，还是使用之前的代码这里稍作改进增加一个十五分钟负载统计，接着我们在MainWindow主构造函数中通过markers()得到所有的标签，然后先调用disconnect()断开信号的连接，接着在使用connect()将当前上方三个按钮进行绑定，当按钮被点击则会触发on_LegendMarkerClicked()槽函数；
// 图例被点击后触发 foreach (QLegendMarker* marker, chart-&gt;legend()-&gt;markers()) { QObject::disconnect(marker, SIGNAL(clicked()), this, SLOT(on_LegendMarkerClicked())); QObject::connect(marker, SIGNAL(clicked()), this, SLOT(on_LegendMarkerClicked())); } 接着，我们需要来实现on_LegendMarkerClicked()槽函数的功能，这里需要介绍一个类，QLegendMarker 类是 Qt Charts 模块中用于表示图例标记的基类。这个类有几个派生类，每个派生类代表一种类型的图例标记。
以下是一些常见的派生类：
QLegendMarker::LegendMarkerTypeXY： 代表 XY 数据系列的图例标记，通常用于折线图、散点图等。QLegendMarker::LegendMarkerTypeBar： 代表柱状图数据系列的图例标记。QLegendMarker::LegendMarkerTypePieSlice： 代表饼图数据系列的图例标记。QLegendMarker::LegendMarkerTypeArea： 代表面积图数据系列的图例标记。 这些类型分别对应于不同种类的数据系列，因为不同类型的数据系列可能需要不同的图例标记。当你处理 QLegendMarker 的点击事件时，通过检查标记的类型，你可以判断点击的是哪一种类型的图例标记，并作出相应的处理，比如切换数据系列的可见性。
// 在槽函数中获取图例标记的类型 void MainWindow::on_LegendMarkerClicked() { QLegendMarker* marker = qobject_cast&lt;QLegendMarker*&gt;(sender()); // 获取图例标记的类型 QLegendMarker::LegendMarkerType type = marker-&gt;type(); // 根据标记的类型执行相应的操作 switch (type) { case QLegendMarker::LegendMarkerTypeXY: // 处理 XY 数据系列的图例标记 break; case QLegendMarker::LegendMarkerTypeBar: // 处理柱状图数据系列的图例标记 break; case QLegendMarker::LegendMarkerTypePieSlice: // 处理饼图数据系列的图例标记 break; case QLegendMarker::LegendMarkerTypeArea: // 处理面积图数据系列的图例标记 break; default: break; } } 上述示例中，我们通过 QLegendMarker::type() 方法获取了图例标记的类型，并根据类型执行相应的操作。其中marker变量则是用户点击过的标签指针，这可以帮助你在处理图例标记点击事件时更灵活地根据标记的类型进行不同的逻辑处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf42985102a3e7378e53df7f025608ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bbceae2a5540ae12cc05cb21e0c496/" rel="bookmark">
			中国信通院「星熠」案例公布，个推消息推送获评绿色SDK产品优秀案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月22日，由中国信息通信研究院安全研究所主办、大数据应用与安全创新实验室承办的“数据安全共同体计划成员大会（2023）”在京举行。每日互动（个推）作为“数据安全共同体计划”的联合发起单位及首批成员单位受邀出席大会。大会现场还公布了2023年度数据安全“星熠”案例入选名单，个推消息推送SDK凭借在数据安全保护方面的技术积累和丰富实践成功入选“绿色SDK产品优秀案例”。
▲个推消息推送SDK
入选“绿色SDK产品优秀案例”
如今数据成为国家基础性战略资源及关键生产要素，全社会对数据安全的重视程度达到了前所未有的高度。为推动数据安全产业蓬勃、可持续发展，发挥优秀案例示范引领作用，加强优秀案例推广，今年7月份，“数据安全共同体计划”正式启动了2023年度数据安全“星熠”案例评选工作。
本次评选吸引了金融、IT、科研、制造等行业的众多企业积极参报，申报案例涉及数据安全合规体系建设等实践类，数据安全技术与产品等应用类，以及绿色SDK产品案例等方向。经过5个月的案例征集、初评和终评工作，最终共有54个案例入选数据安全“星熠”案例，个推申报的“消息推送SDK”成功入选为“绿色SDK产品优秀案例”。
个推以提供消息推送技术和服务起家，是国内APP消息推送领域的领跑者。在产品层面，个推消息推送SDK不仅集成便利，具有省电、省流量、省成本等显著性能，在618、双11等高并发、大流量场景下，能充分保障APP推送消息的稳定、高效下发，同时在数据智能时代，个推更是结合APP精细化运营痛点和需求，对消息推送服务进行了升级，推出了大数据标签推送、文案圈人模型、AI文案生成等全新功能，帮助APP更加智能地与用户沟通和连接。
作为SDK产业和国内数据要素市场的参与者，个推从成立之初就高度敬畏和重视数据安全。个推坚守“严把数据采集入口、划清数据流转边界、守正数据运用场景”三大原则，建立了全链路数据安全管控机制和体系，全面、有效地保障了SDK产品安全和数据安全。包括消息推送SDK在内，个推旗下的多款产品和服务率先通过了信通院“安全专项评测”，并多次获得来自中央网信办、工信部、公安部等多个主管部门的认可。
此外，个推还深度参与政策法规研讨、标准研制等工作，共建数据安全发展生态。公司不仅积极参与“绿色SDK产业生态共建行动”等一系列行业实践，并携手中国信通院共建面向移动互联网应用程序的检测及认证公共服务平台，助力行业向开放、创新、合规方向发展。
在有关部门的指导下，个推还参与起草了多个国家标准、指引规范和团体标准。其中由个推牵头起草编制的首份SDK安全国家标准《信息安全技术 移动互联网应用程序（App）软件开发工具包（SDK）安全要求》于今年12月份正式获批发布，有力助推了数据要素的安全保护和价值释放。
作为一家数据智能服务商，个推依靠“让数好用，把数用好”的专业积累和领域知识，助力产业数智化升级。此次入选2023年度数据安全“星熠”案例是对个推多年来数据安全实践工作的肯定，更是新的责任和企盼。未来，个推将继续以切实行动参与构建数据安全生态共同体，助力数据要素产业有序、健康、绿色发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3445cd24f3e86274b65dba04a3ee657/" rel="bookmark">
			linux系统中，常用服务端口号大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/bin/bash 计算机中的端口总共有多少个TCP0-65535UDP0-65535 总共有65536*2=131072个端口
服务软件服务名配置文件端口号 SSH
远程服务
ssh
sshd
服务器端/etc/ssh/sshd_config
客户端/etc/ssh/ssh.config
TCP/22
DHCP
动态分配
dhcp
dhcpd
配置文件/etc/dhcp/dhcpd.conf
模板文件：/usr/share/doc
/dhcp*/dhcpd.conf.example
UDP/67
接收客户端的请求
UDP/68
回应客户端的请求
DNS
域名服务
bind
named
主配置文件：/etc/named.conf
区域配置文件：
/etc/named.rfc1912.zones
数据文件：/var/named/*
正向解析：named.localhost
反向解析named.empty
TCP/53数据同步
UDP/53数据通信
FTP
文件传输
vsftpd
vsftpd
主配置文件
/etc/vsftpd/vsftpd.conf
用户控制文件：
/etc/vsftpd/ftpusers、
/etc/vsftpd/user_list
控制连接：TCP/21
数据连接：
20/随机端口
nfs
共享目录
rpcbind
nfs-utils
rpcbind
nfs
主配置文件：/etc/nfs.conf
存储配置文件：/etc/exports
rpc：远程过程调用；管理nfs端口,111端口
nfs：2049
iscsi
共享磁盘
Iscsi
-initator-utils
iscsi
iscsi
iscsi服务器端管理界面：
targetcli
认证文件：
/etc/iscsi/initiatorname.iscsi
IP地址：3260
apache
web网站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3445cd24f3e86274b65dba04a3ee657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff9a14c1496164b74d64205c95809e6e/" rel="bookmark">
			【STM32】TIM1在电机应用时的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互补通道OC和OCN的输出极性 OC1和OC1N同时使能的时候，两个才是互补的，OC相对OCREF高电平有效，OCN相对OCREF低电平有效。当OC1或OC1N只选中一个通道，那么就没有互补的概念，都是OCxREF有效时OC或OC1N有效。
举例：测试电机Driver的导通极性，需要打开U相的上半桥和V相的下半桥。如果采样电阻上有电流经过，证明两个半桥均导通，进而可以判断driver导通极性。
使能OC1和OC2N，如果采样电阻上有电流，那么说明两个半桥导通了。两个引脚输出的波形是同向的，因为这两个不属于一组互补通道，所以都是OCxREF有效的时候有效。由此可知，上下半桥都是高电平导通。
TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; // 输出有效电平 TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High; // TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset; // 空闲状态输出 TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset; 1、输出有效电平，OC和OCN都是高电平有效的话，输出的信号就是互补的。
2、空闲状态输出，指的是MOE没有使能的情况下，OC和OCN的输出电平。当前的两个电平都是低电平。
TIM_BDTRStructure.TIM_OSSRState = TIM_OSSRState_Enable; TIM_BDTRStructure.TIM_OSSIState = TIM_OSSIState_Enable; // MOE = 0 时的配置 1、OSSI = 1，决定了OIS和OISN是否生效。也就是上面的 TIM_OCIdleState_Reset,TIM_OCNIdleState_Reset两个配置是否生效。
具体看表75.
OCxEN是OC引脚输出的使能信号。当OCxEN = 1时，是输出状态。 =0时，是输入高阻。F0和F4是这样，F1不是。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ae43ecc157be8b836ac15a981f965c/" rel="bookmark">
			Javaweb考前复习冲刺(不断更新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Javaweb考前复习冲刺 第一章： JavaWeb 入门 JavaWeb是指：以Java作为后台语言的项目工程。
javaweb项目创建的过程：
首先集成Tomcat服务器环境新建dynamic web project部署工程运行 路由含义：
​ http://localhost:8080/工程项目名/(文件夹)/页面名。
&lt;%=application.getRealPath("") %&gt; 工程部署路径 # D:\java_exerise\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\component\ 第二章 静态网页设计： ​ 一个网页是动态网页还是静态网页就是否还有 前端三件套(HTML、CSS、Javascript）之外的内容。
​ 动态网页是指网页中有需要服务器执行的元素，文件扩展名是jsp，动态页面中除了上述静态元素外，还包括服务器端脚本代码（Java）、指令、动作标签，表达式语言等。
动态网页中 静态成分和动态成分的执行顺序：
&lt;%@ page pageEncoding="UTF-8" import="java.util.Date" %&gt; &lt;html&gt; &lt;body&gt; &lt;script&gt; document.write(new Date()); &lt;/script&gt; &lt;br/&gt; &lt;% out.print(new Date()); %&gt; &lt;/body&gt; &lt;/html&gt; Sun Dec 17 2023 12:43:16 GMT+0800 (中国标准时间) Sun Dec 17 12:43:15 CST 2023 网页会先执行java代码，再执行js代码。我们可以理解为out.print(new Date()); 属于后台代码，只不过我们的服务器本地而已。
HTML： 网页的基本框架是由一个个标签组成的，标签又分为块级标签和行内标签。
块级标签：
块级标签以新行开始，占据一整行的宽度，不与其他元素并排显示。
常见的块级标签有 &lt;div&gt;、&lt;p&gt;、&lt;h1&gt; - &lt;h6&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;、&lt;table&gt; 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ae43ecc157be8b836ac15a981f965c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe85f1827c89f7ca77e2ce50496f2049/" rel="bookmark">
			【C&#43;&#43;】特殊类设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计一个类，不能被拷贝 拷贝只会发生在两个场景中：拷贝构造函数和赋值运算符重载。
因此想要让一个类禁止拷贝，只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。
1、C++98 将拷贝构造函数与赋值运算符重载只声明不定义，并且将其访问权限设置为私有即可。
class CopyBan { public: CopyBan() {} private: CopyBan(const CopyBan&amp; cb); // 拷贝构造函数声明 CopyBan&amp; operator=(const CopyBan&amp; cb); // 赋值运算符重载声明 }; 【原因】 设置成私有：如果只声明而没有设置成 private，用户自己如果在类外定义了，就可以不能禁止拷贝了。只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没什么意义，不写反而更简单，而且如果定义了就不能防止成员函数内部拷贝了。 如上图代码，在对这个特殊类进行拷贝和赋值的时候，因为这两个成员函数私有而无法调用。
拷贝构造以及赋值运算符重载等成员函数，在调用时都是编译器在域外调用，所以必须是公有的。
2、C++11 C++11 扩展了 delete 的用法，delete 除了释放 new 申请的资源以外，如果在默认成员函数后跟上 = delete，表示让编译器删除掉该默认成员函数，此时编译器也不会自动生成默认的拷贝构造和赋值运算符重载函数。
class CopyBan { public: CopyBan() {} private: CopyBan(const CopyBan&amp; cb) = delete; // 拷贝构造函数声明 CopyBan&amp; operator=(const CopyBan&amp; cb) = delete; // 赋值运算符重载声明 }; 二、设计一个类，只能在堆上创建对象 正常创建类对象时，会在栈上创建，并且自动调用构造函数来初始化。下面设计一个类，只能在堆上创建对象。
1、实现方式 只能在创建在堆上时，就需要让该对象只能通过 new 来创建，并且调用构造函数来初始化。
将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝在栈上生成对象。 提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建。 class HeapOnly { public: static HeapOnly* CreateObject() { return new HeapOnly; } private: //构造函数 HeapOnly() {} HeapOnly(const HeapOnly&amp; hp) = delete; // 禁止拷贝 }; 定义一个静态成员函数，在该函数内部 new 一个 HeapOnly 对象。将构造函数和拷贝构造函数私有，并且禁止生成拷贝构造函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe85f1827c89f7ca77e2ce50496f2049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f6c085e6628c04824a4a62bccabbe5/" rel="bookmark">
			云原生MeetUp| 1222 KubeSphere &#43; 敏捷 主题分享会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		date： 2023-12-22
location：西交利物浦大学
全文概要
Section-1 Agile-头部智能电动车公司敏捷转型实践分享Section-2 KubeSphere 可查吧架构下 DevOps 插件实现方法Section-3 KubeSphere 在 vsleem 的落地实践Section-4 Zabbix+SkyWalking 实现全域监控Section-5 AI 时代的战略思维Section-6 闪电演讲 —— 在校学生如何参与开源项目 &gt;&gt; Background
什么是KubeSphere?
KubeSphere 是在 Kubernetes 之上构建的面向云原生应用的分布式操作系统，完全开源，支持多云与多集群管理，提供全栈的 IT 自动化运维能力，简化企业的 DevOps 工作流。它的架构可以非常方便地使第三方应用与云原生生态组件进行即插即用 (plug-and-play) 的集成。
开源地址：https://github.com/kubesphere/kubesphere
什么是敏捷？
敏捷是一种通过创造变化和响应变化在不确定和混乱的环境中取得成功的能力。
Section-1 Agile-头部智能电动车公司敏捷转型实践分享 此部分，俞老师主要介绍了自身再给企业做敏捷规划的过程中，敏捷的过程方法对目前提效降本的大环境的重要性
过程中，也有小伙伴提出了很多实际业务开展中的很多问题和难点：
敏捷在职能型团队如何开展，开展的困难性从运维角度出发，为开发团队提出敏捷思想的建议，但难于推广敏捷的阶段和目标不那么明确或者是优先级不明的多任务同步推进，敏捷的周期目标、周期交付成果的界限就逐步模糊化，敏捷的过程就逐步扭曲了 Section-2 KubeSphere 可插拔架构下 DevOps 插件实现方法 此部分，主要有KubeSphere开源工程师余老师介绍，着重讲述KubeSphere DevOps部分功能以及迭代的历程。
DevOps主要涵盖：
功能需求管理(JIRA/WIKI)源代码(Source Code)代码管理工具(Github/Gitlab…)构建【CI工具(Jenkins…)，CD功能(ArgoCD…)】代码质量检查(Code Analysis)测试(UT)构建报告镜像推送K8S部署监控与运维 讲述在KubeSphere 3.x时代，CI/CD流程主要依赖 Jenkins + ArgoCD 来完成，但是逐渐意识到对更多CI/CD框架的需求，此外KubeSphere 还面临着版本发布周期较长、组件耦合、社区扩展繁琐等问题，为了应对上述问题，在 4.0 版本引入了全新的微内核架构，代号为 “LuBan”。
不局限于原来的选型，支持前后端动态扩展，使得默认安装的 KubeSphere 变得更加轻量。
新的架构，对于使用者、贡献者、维护者来说，都是一个好消息。
Section-3 KubeSphere 在 vsleem 的落地实践 此部分，是方老师开讲。主要讲述KubeSphere部分功能在企业落地情况，对于AllInOne部署、云边架构一体化、多集群管理给公司的快速开发、生产带来了极大便利。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f6c085e6628c04824a4a62bccabbe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ce0e0c40d4143c75f4e9418d014969/" rel="bookmark">
			戴口罩监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着冬季的到来，安分一段时间的病毒也慢慢的爆发，口罩作为一种重要的防护物品受到了广泛关注。为了加强对口罩佩戴情况的监测和识别，许多场所开始引入了戴口罩监测识别摄像机。这种摄像机通过图像识别技术可以自动检测出人们是否佩戴口罩，实现对公共场所的管理和安全控制。戴口罩监测识别摄像机主要由硬件设备和软件系统组成。硬件部分通常包括摄像头、处理器和存储设备等，用于采集、处理和存储视频数据。软件系统则主要包括图像识别算法和后台管理系统，通过口罩佩戴识别检测技术实现对口罩佩戴情况的实时监测和识别。 使用过程中，戴口罩监测识别摄像机通过图像识别算法对人脸进行识别和分析。一旦检测到人脸上没有佩戴口罩，系统就会发出警告信号并记录相关信息，以便后续管理和处理。同时，系统还可以通过后台管理系统实现对监测数据的实时监控和分析，为相关管理人员提供决策支持和数据统计。在公共场所的应用可以有效提高口罩佩戴的管理效率和精度。例如在地铁、机场、商场等人流密集的场所，摄像机可以快速准确地识别出未佩戴口罩的人员，并及时提醒或劝阻。这不仅有利于遏制病毒传播，还可以减轻人工管理的负担，提升场所安全管理水平。
综上所述，戴口罩监测识别摄像机可以作为一种有效的辅助手段，帮助公共场所管理和安全控制。不断完善相关政策和技术，使其更好地为社会安全和健康服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78afd73a104803cfc4f87336e00ca56/" rel="bookmark">
			八年老程序员｜2023 年我输出的内容汇总（文章、直播、开源库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是拭心，一位工作八年的程序员。
2023 还有一周就结束了，我开始回顾这一年做了什么。
乍一想好像没做成什么，今年的空闲时间有很大部分都花在了打游戏、刷短视频上，对外输出的内容比预想的少了很多。
这篇文章整理了今年我对外输出的内容，如果对你有用，欢迎留言点赞转发❤️。
部分链接由于公众号限制无法点击，请点击“阅读原文”在原文中查看。
文章 总结类文章 # 一名工作七年安卓开发的 2022 总结：8k 阅读；总结回顾 2022。去年是大事比较多的一年，疫情结束、亲人离世、换工作、完成书稿，件件都让我印象深刻，反观今年，就显得平淡了很多。
# 30 岁了！通过 AI 问答完成了这篇思考文章：1.2k 阅读；三十岁，工作和生活对我的要求更高了，在迷茫中逐步摸索、适应，通过 ChatGPT 得到了一些问题的答案。有时候打的字越多，越渴望得到认可，这种感觉 ChatGPT 给到了。
# 一名七年老安卓的一二月小结：7.9k 阅读；还好有这篇文章，要不然我都忘记一二月做了这么多事：工作里分享了两个提效工具、开源内存分析工具、完成一次直播技术分享。
# 七年老程序员的三四月总结：三十岁、准备婚礼、三次分享：2.2w 阅读；三四月状态也不错：发表了七篇文章、完成三次分享（公司内 2 次、社区 1 次）。这让十一二月的我非常佩服，最近俩月我基本没输出什么😭
# 经过半年的努力，终于成为了谷歌开发者专家（GDE）：2.4w 阅读；记录我成为谷歌开发专家的过程，核心就四个字：社区贡献。
# 七年老程序员的五六月总结：十一件有意义的事：4k 阅读；五六月我的生活里发生了这几件重要的事：顺利举办了婚礼、回高中看望老师时给学弟学妹做了“优秀学长分享”😂、陪老丈人逛上海、加入鱼皮知识星球、完成两次直播分享。
# 七年老程序员的七八月总结：又夺冠了：2.6k 阅读；七八月是丰收的月份，有 2 个好消息：内部创新大赛夺冠🏆（上一次夺冠还是上一次）、正式成为 GDE。另外也鼓起勇气在公司活动上摆了自家羊肉的易拉宝哈哈。需要重点记得的是，这个月工作上犯了一个大错，这个错误以后都要铭记！
# 七年老程序员的九十月总结：上热榜、社区分享、重学后端：1.7k 阅读；九月十月参加了三场线下活动，认识了不少新的朋友😊；国庆除了上口语课再次学习了后端，明年一定要拿一些作品出来！
技术类文章 # Android 资深开发需要掌握的常用框架原理：1.7w 阅读；之前写的文章系统整理了一下，时隔几年，一些框架可能 API 有了不同，但底层架构和实现还是变化不大的，再次证明学习原理优于 API。
# React/ReactNative 状态管理: redux 如何使用：2.4k 阅读；介绍了 ReactNative 状态管理最热门的框架 redux 的使用。
# React/ReactNative 状态管理: redux-toolkit 如何使用：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78afd73a104803cfc4f87336e00ca56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ae2136d019e6782219ff5573c80309/" rel="bookmark">
			【Unity】入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述常用组件各类文件基础知识创建工程工程目录介绍五个窗口面板创建代码和场景 脚本与编程鼠标的输入键盘的输入代码来操作组件获取物体API资源的使用API定时调用与线程向量的基本运算预制体与实例 物理系统与组件案例实操作快捷键来源 Unity已广泛运用到各个领域： 游戏（VR/AR…）影视工业仿生/模拟数字孪生全息投影······ 概述 1、物体与空物体
物体（Game Object），其实是一个节点或容器。一般所谓的“物体”，即有形状的东西，对应的Mesh，网格信息代表了物体（形状）。
空物体（Empty Object），即空对象、空节点。空物体不可见（没有网格），但空物体也有坐标，可以移动。空物体常用于节点的组织和管理，或用于标记一个位置。
2、父子关系
父子关系，指两个物体之间的关系。在Hierarchy窗口中，拖动物体B，到物体A下，子物体会随着父物体一并移动。删除父物体时，子物体也会一并删除。子物体的坐标是相对于父物体的，即相对坐标。
3、世界坐标系与本地坐标系
Global，即世界坐标系。以世界中心为轴，6个方向代表了上、下、东、西、南、北。
Local，即本地坐标系。以物体自身为轴，6个方向代表了上、下、前、后、左、右。
Y轴称为Up，Z轴称为Forward，X轴称为Right。一般地，在建模软件里建模时，模型的正面与Z轴的方向一致。移动一个物体时，一般就是让这个物体向前运动，Forward。
4、轴心与几何中心
Pivot，即轴心。指一个物体的操作基准点。
Center，即几何中心。对于基本体来说，轴心点默认位于几何中心，但并不是所有物体的轴心都在几何中心点。
在Unity中，默认情况下显示的是Pivot操作模式，即轴心模式。另外一种模式是几何中心点模式。可选择切换物体在移动、旋转和缩放时，是以哪个点作为操作基准点。一般使用的是Pivot模式。
5、组件
Component，即组件。代表一个具体功能，例如，Light，光源。Directional Light，平行光源。Mesh Filter，网格过滤器，用来加载网格数据。Mesh Renderer，负责渲染。
常用组件 1、摄像机
Camera，即摄像机。负责拍摄游戏画面。摄像机的Z轴指向，即为拍摄方向。拍到的画面，呈现在Game窗口中，也就是玩家最终看见的画面。
调整摄像机的角度，可用两种方式。第一种，手动。手工移动、旋转摄像机，对准目标。第二种，GameObject-&gt;Align With View，与3D视图对齐。先在3D视图里摆好角度，此为观察者视角，然后选中Main Camera，执行Align With View。此时，摄像机视角与观察者视角完全相同。
2、Transform组件
Transform，即变换组件。物体的基本参数有Position，位置（相对坐标）、Rotation，旋转（欧拉角）、Scale缩放。Transform就是用来描述一个物体在空间中的位置坐标、旋转量和缩放量。所有物体都有Transform组件，而且不能被删除。
3、AudioSource组件
AudioSource组件，用于播放音乐/音效。创建一个物体，Add Component，Audio | Audio Source，将音乐文件（*.mp3/wav/aiff）拖到AudioSource.AudioClip属性。
各类文件 1、资源文件
Assets目录下的文件，即为资源。使用Meta来描述文件，每个资源文件/文件夹，都对应一个*.meta描述文件。
常见的类型有，模型文件Model（.fbx）、图片文件Texture（.jpg/png/tif/psd等）、音频文件AudioClip（.mp3/wav/aiff）、脚本文件Script（.cs）、材质文件Material（.mat）、场景文件（.unity）等等。
2、场景文件
场景文件*.unity，记录了场景中的节点数据。包含场景全局设置、节点、节点下挂载的组件、各组件的参数值等。一个场景往往代表一个关卡，可以创建多个不同的场景。
3、资源包
Unity中的资源包（Unity Package），即对Assets下的资源进行打包。选择一个资源文件，或一个目录。右键，Export Package，生成*.unitypackage资源包。
基础知识 创建工程 （1）点击Unity hub,新建即可
提示：若无法新建可能是未登录且没有激活许可证。操作如下
工程目录介绍 在新建完成后会在创建的目录下生成相关工程文件:
Assets: 资源（场景脚本模型）
Library: 库（系统）
Logs: 日志
Packages: 导入的包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ae2136d019e6782219ff5573c80309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339e731922af4425013eaf7f47fed483/" rel="bookmark">
			【3D Max】入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述界面介绍常用功能保存和导入基本建模编辑模型材质和贴图光源和阴影动画制作渲染设置导出和打印来源 概述 3 ds MAX是由 Discreet (后来被 Autodesk (Autodesk)合并)开发的一款基于 PC系统的3 d Max或3 ds MAX三维动画绘制和制作软件，其主要功能有建模、动画、渲染、特效等，可用于多种领域。
界面介绍 当你启动3D Max时，你会看到以下几个主要组件构成的界面：
菜单栏：位于软件窗口的顶部，提供了许多操作和功能的选项。你可以在这里找到文件、编辑、视图、创建、渲染等各种菜单。
工具栏：通常位于菜单栏的下方，包含了常用的工具按钮。例如，选择工具、移动工具、旋转工具、缩放工具等。通过工具栏上的按钮，你可以快速访问并选择所需的工具。
视图窗口：占据了主要区域，用于显示和编辑3D场景。默认情况下，界面中会有四个视图窗口：顶视图、前视图、左视图和透视视图。你可以通过视图控制按钮切换视图窗口的显示方式和视角。
控制面板：位于窗口的右侧或底部，显示了当前选中对象或操作的选项和属性。控制面板的内容根据你所选中的对象或操作而变化。例如，在选择一个模型对象时，你可以通过控制面板设置其大小、位置、旋转和材质等。
此外，还可以在界面中找到其他辅助工具和面板，例如资源管理器、时间轴、层管理器、材质编辑器等。这些辅助工具提供了更多的功能和控制选项，用于更高级的建模、渲染和动画制作操作。
菜单栏
在屏幕界面最上面是菜单栏，如图所示。如果菜单上的命令有省略号，就表示弹出了相应的对话框，用小箭头表示下一级菜单。
在相应的命令面板、工具栏或快捷菜单中可以找到菜单栏中的大多数命令，这要比在菜单栏中执行命令方便得多。
工具栏
这个3 DsMax菜单栏下面有一个被称为主工具栏的工具栏按钮，它能让3 dMax中许多常见任务快速访问工具和对话框。
若主工具栏的命令未完全显示，则在主工具栏的空白处按下鼠标左键或中键，拖动鼠标回车即可显示(此时鼠标箭头将变为手形)。
单击主工具栏的空白处的右键将显示快捷面板，隐藏了它，我们可以勾选它，以便命令出现在视图的位置上，并且位置可以随意拖动。点击“X”可将其关闭，而无需再使用它。
命令面板
在视图区域的最右侧是命令面板。命令面板集成了3dsMax中的大部分功能和参数控制项。可以说是核心工作区，也是最复杂最常用的区域。创建任何对象或场景都需要通过命令面板进行操作。
视图区
在3 dMax软件中，视图界面被表示为四个视图，即分别显示一个物体的三个相对面，即顶视图、左视图、透视图，可以理解为，可以看到物体的三个面。
在绘制过程中，视图可以互相切换，也就是说，一种视图可以根据需要迅速地转换到其他视图，或者在任何时候恢复。上视图、下视图、左视图操作界面不能随意旋转，因为旋转的是正交视图，正交视图没有物体修改操作功能，只能在透视图中旋转。
视图控制区
在右下角的工作界面上有一个软件控制区，它主要用来调整视图中对象的显示状态。采用放大、移动和旋转等操作来达到便于观测的目的。
动画控制区
工具主要是用来控制动画的设置和播放的动画控制区。在屏幕下面是动画控制区，如图所示。在3 dMax视图区下设置用于滑动动画帧的时间滑块。
信息提示区与状态栏
用来在3 dMax视图中显示物体的动作效果，如移动，旋转坐标，缩放等等。
时间滑块与轨迹栏
用来设置动画、浏览动画和设置动画帧数量等等。
常用功能 物体的创建
对象的创建通常是从“标准基础”开始，或者是从“扩展基础”开始，创建或者修改软件自带的基础对象，或者使用“样条”绘制。对于3 dmax来说，这是必要的基本功能。
移动物体
在3 dmax工具栏中单击移动按钮。即可完成3 dmax的对象移动操作。
它是一种通用的移动按钮，可实现点、边、面、边界、元素等多边形的移动。运动对象函数是3 dmax的基础入门。该对象的位置在底部有坐标显示，通过改变坐标值可以直接改变其位置。
复制物体
按下“Shift”之后移动对象，将弹出复制类型选项，以使用3 dmax复制对象。使用“实例”选项得到的对象将随着源对象的变化而变化。拷贝函数同样适用于点等多边形编辑单元的拷贝。(还可以通过选择菜单栏中的克隆和右键选项来实现复制功能")
旋转物体
转对象函数是3 dMax的常用函数，可通过单击工具栏上的旋转按钮使用。这是一种通用的旋转功能按钮，多边形的编辑单元都可以用这种方式旋转。
缩放物体
使用3 dMax缩放对象功能，单击工具栏上的缩放按钮。这是一种通用缩放功能按钮，多边形的编辑单元都可以用这种方式进行缩放。
创建物体镜像
用3 dMax创建一个镜像对象，点击工具栏上的镜像按钮即可。这一常见的功能可以方便我们复制多个3 dMax对象，这也是我们使用3 dMax的基础之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/339e731922af4425013eaf7f47fed483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb345e408a19d88fa10a02b0d2a3c113/" rel="bookmark">
			Android查缺补漏（线程篇）-- AsyncTask的使用及原理详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AsyncTask的使用 AsyncTask是一种轻量级的异步任务类，可以很方便的在线程池中执行异步任务，并且将进度和结果传递给主线程。其底层由Thread+handler实现。
AsyncTask是一个抽象的泛型类，其类的声明如下：
public abstract class AsyncTask&lt;Params, Progress, Result&gt; 其中三个泛型参数代表的意义如下：
Parmas：参数类型Progress：异步任务的执行进度类型Result：异步任务执行完毕后返回结果的类型 在使用AsyncTask执行异步任务需要创建一个类，让这个类继承AsyncTask，并实现相关方法，具体形式如下，在下面代码中实现了几个重要的方法，每个方法代表的意义可以见注释：
/** * Created by liuwei on 18/2/28. */ public class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; { /** * 在异步任务执行之前调用 * 执行在主线程中 */ @Override protected void onPreExecute() { super.onPreExecute(); } /** * 执行异步任务 * 执行在线程池中 * @param params * @return */ @Override protected String doInBackground(String... params) { return null; } /** * 当异步任务被取消时执行此方法，此时将不会再调用onPostExecute方法 */ @Override protected void onCancelled() { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb345e408a19d88fa10a02b0d2a3c113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ced0ed901f041df76b7f2cfd5bdc7b0/" rel="bookmark">
			Java研学-JSP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 JSP概述 1 介绍 JSP——Java Server Page运行在服务器端的 Java 页面(本质上是一个简化的Servlet设计)， HTML 运行在浏览器端，而 JSP是运行在服务器上，最终还是解析成静态的HTML，运行在浏览器。浏览器上看到的HTML页面，其实是 JSP 在服务器上运行的结果。JSP的主要目的是将逻辑从Serlvet中分离出来。
2 优势 技术特点HTML静态页面
优点：方便页面美化操作，写JS脚本和CSS代码都比较方便。
缺点：不能写动态的内容Servlet运行在服务器上小 Java 程序 优点：制作动态内容
缺点：不方便写 HTML 以及 CSS 和 JS 代码JSPJSP = HTML + Servlet 特点：既有 HTML 的优点：方便美化和编写 JS 代码。
又有 Servlet 优点：可以在页面写 Java 代码，可以制作动态内容 3 入门事例 &lt;%--导入包--%&gt; &lt;%@ page import="java.util.Date" %&gt; &lt;%--page:指定页面内容的类型，编码。(Java)--%&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;浏览器输出服务器当前的时间&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;span style="color:rosybrown;"&gt; &lt;%=new Date()%&gt; &lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 4 运行过程 JspServlet 首先会将 jsp 文件代码翻译成 Servlet 的 Java 代码，然后再编译成字节码文件执行,底层就是一个 Servlet
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ced0ed901f041df76b7f2cfd5bdc7b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530ee97d8785ff807bbe2537dedb8c45/" rel="bookmark">
			GitHub 热点速览年度盘点，四年的精华合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-小鱼干
今年是 GPT 年，无论是 GitHub 还是朋友圈还是技术平台，即便你不关心 GPT 的发展情况，同大模型、AI 相关的项目总能进入你的信息流。到这期为止，热度速览也连载了四年，从一开始习惯看 GitHub Trending 找寻有意思的项目，到后来每期收录当周的热点，并每期整理一个主题相关开源项目，到去年的年末点单，再到今年的回归平常只论开源项目。这四年，热点趋势也换过名，减少过每期的介绍项目，也配合 HG 的主站增加当周的 HG 网站热门项目。而我也见证了从一开始的 500 阅读，到后来的 1,000 阅读，到现在每期的 5k 起步的阅读，越来越多的人每周一阅读上周热门的开源项目。
是时候来个年度盘点，不只是盘点 2023 年，而是 2020-2023 年这四年那些让我印象深刻的期数。从明年开始，热点速览不会再由小鱼干更新，也许它会换个作者，或者换个形式同你见面。
很高兴你能阅读本期『GitHub 热点速览』，接下来是这四年个人觉得也许你该读一读的那些开源项目。
1. 希望你能喜欢我的最爱 正如一开始说的，热点速览一开始是因为我想第一时间看到那些有意思的项目，所以在这个章节里我会介绍那些个人觉得有意思的项目，希望你也能喜欢。
1.1 万能 Excel：computer-vision-basics-in-microsoft-excel 这是一个演示项目，通过在 Excel 中实现一系列一行公式的样本算法，从基础开始学习计算机视觉。作者用一个令人惊喜的技巧，向我们演示如何在 Excel 可视化诸如人脸检测、霍夫变换等算法，而无需依赖任何脚本或第三方插件。当然你还需要具备一些数学背景，比如加权平均数、偏微分、特征值等。
出自：2020 年《上周 GitHub 热点速览 vol.08：系统设计必看 The System Design Primer》
GitHub 地址→https://github.com/amzn/computer-vision-basics-in-microsoft-excel
1.2 手机变显示器：HDMI-PI 主语言：C
稚晖君想必大家都知道，而 HDMI-PI 则是我的启蒙开源项目，从此之后让我记住一个玩硬件的 UP 主叫稚晖君。
HDMI-PI 是一个 HDMI 转 MIPI 模块，可以用于驱动各种手机屏幕当显示器用的工具。大家知道现在的手机屏幕素质非常高，且价格低廉（毕竟有智能手机的普及量撑腰，作为维修配件买的话非常便宜），相比于绝大多数桌面显示器拥有十分无敌的分辨率、像素密度、可视角、色彩还原甚至刷新率。项目作者对于小巧精致的电子产品有执着的追求，可市面上几乎找不到用手机屏幕做的迷你显示器，所以本项目就是为了解决这个需求。至于迷你 HDMI 显示器有什么用，电视盒子、单反相机、树莓派之类的开发板都带 HDMI 接口，即插即用随身携带的高分屏它不香吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/530ee97d8785ff807bbe2537dedb8c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e3cfdbc86e55c42b9102c3adc6a408/" rel="bookmark">
			木工手工笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 连接两根木棍两根电线连接榫卯连接隔空划线塑料热熔密封万能的502扳手模具修复模具修复进阶 靠尺台钳自制台锯切割铝材电烙铁的改用 手工活真的很解压。简单整理下吧。 以前对物理知识不是很重视，现在发现很有用，很多地方都能用到。 连接两根木棍 中心划线，螺丝钉打入，去掉顶帽，打入木工胶。 木棍2拧到螺丝上即可。这样非常结实。
两根电线连接 顺时针转肯定不结实，技巧是先顺时针来一圈，往左绕一圈，再顺时针绕一圈，这样就相当于自锁，非常结实。
榫卯连接 榫卯结构真的是非常经典的一项技艺。
不但美观，而且结实，只不过逐利的时代，越来越少有人塌下心来做这个了。
隔空划线 例如墙体凸出一块，如何弄出一块。
塑料热熔密封 不用的塑料瓶可以切下来带盖的一半，套到瓶瓶罐罐上，用热风枪吹的锁紧，就是一个简单的密封容器。
万能的502 502搭配棉花、水泥、泡沫等有奇效。谁试谁知道。
扳手 扳手拧螺丝
模具修复 复杂一点的可以通过锡纸包边，蜡油脱模，然后去掉锡纸，在蜡油外侧涂抹502+水泥，构筑外壳。
模具修复进阶 弧形面的修复，只有细细一条连接线肯定是不够的，接触面积太小。
可以通过加筋的方式增强牢固性，原理是增大受力面积。
线性开口可以利用
靠尺 手工误差太大，借助工具可以让误差在一定范围内，做出合格的产品。
例如划线，切割等。
靠尺是一种检测工具，糅合起来可以实现多种功能。
T形靠尺。 主要用于检测是否垂直，在延伸杆上加笔可以划线，加角磨机可以切割。
靠尺的扩展：
划线时，圆规也可以起到靠尺的作用。
台钳 钳工用的比较多，加工一些小零件时起固定作用。
这种设备有点重了，家用一般用不到。
自制台锯 台锯太重，携带不便。
利用一个开口木箱子，云石机固定在一块木板上，倒放在木箱子上，就是个台锯，很方便。
切割铝材 较大的铝材用角磨机，小的铝条用剪刀更方便。
电烙铁的改用 拆下烙铁头，安装颗螺丝，用来挤压塑料。
一是丢掉了也不可惜，二是螺丝是平头，方便挤压。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13392a1f4c5166d1ff1816a91abbe01b/" rel="bookmark">
			AI绘画与多模态原理解析：从CLIP到DALLE1/2、DALLE 3、Stable Diffusion、SDXL Turbo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 终于开写本CV多模态系列的核心主题：stable diffusion相关的了，为何执着于想写这个stable diffusion呢，源于三点
去年stable diffusion和midjourney很火的时候，就想写，因为经常被刷屏，但那会时间错不开去年11月底ChatGPT出来后，我今年1月初开始写ChatGPT背后的技术原理，而今年2月份的时候，一读者“天之骄子呃”在我这篇ChatGPT原理文章下面留言：“点赞，十年前看你的svm懂了，但感觉之后好多年没写了，还有最近的AI绘画 stable diffusion 相关也可以写一下以及相关的采样加速算法
我当时回复到：哈，十年之前了啊，欢迎回来，感谢老读者、老朋友
确实非常非常多的朋友都看过我那篇SVM笔记，影响力巨大，但SVM笔记之后，也还是写了很多新的博客/文章滴，包括但不限于：xgboost、CNN、RNN、LSTM、BERT等
今后基本每季度都有更新的计划，欢迎常来
关于Stable Diffusion，可以先看下这篇图解Stable Diffusion的文章”(此篇文章也是本文的参考之一)今年3月中旬，当OpenAI宣称GPT4具备了CV多模态的能力之后，让我对AI绘画和CV多模态有了更强的动力去研究探索，并把背后的技术细节写出来
其实当时就想写了，但当时因为写各种开源平替模型的原理、部署、微调去了，所以一直没来得及写，包括之前计划的100篇论文也因此耽搁 4.23，我所讲的ChatGPT原理课开课之后，终于有时间开写这篇多模态博客，然想写清楚stable diffusion和midjourney背后的技术细节，不得不先从扩散模型开始，于此便有了上一篇《AI绘画能力的起源：从VAE、扩散模型DDPM、DETR到ViT/MAE/Swin transformer》「且如果你此前不了解何谓扩散模型、何谓DDPM，务必先看该文，不然没法看懂本文」
援引上一篇文章的这段话“AI绘画随着去年stable diffusion和Midjourney的推出，使得文生图火爆异常，各种游戏的角色设计、网上店铺的商品/页面设计都用上了AI绘画这样的工具，更有不少朋友利用AI绘画取得了不少的创收，省时省力还能赚钱，真香”，此外，包括我司LLM项目团队开发的AIGC模特生成系统也用到了这方面的技术：基于SD二次开发
沿着上文之后，本文将写清楚下面表格中带下划线的模型
1月3月4月5月6月8月9月10月11月20年DETRDDPM DDIM
VisionTransf.. 21年 CLIP
DALL·E
SwinTransformer MAE
SwinTransf..V2
22年BLIPDALL·E 2 StableDiffusion BEiT-3
Midjourney V3
23年BLIP2 VisualChatGPT GPT4
Midjourney V5
SAM(Segment Anything Model) FastSAM
(中科院版SAM)
MobileSAM
DALLE3 且过程中会顺带介绍MiniGPT-4、VisualGPT到HuggingGPT、AutoGPT这几个模型
第一部分 从CLIP到BLIP1、BLIP2 1.1 CLIP：基于对比文本-图像对的预训练方法 我第一次见识到CLIP这个论文的时候，当时的第一反应是，特么也太强悍了.. ​
CLIP由OpenAI在2021年1月发布
通过超大规模模型预训练提取视觉特征，进行图片和文本之间的对比学习 (简单粗暴理解就是发微博/朋友圈时，人喜欢发一段文字然后再配一张或几张图，CLIP便是学习这种对应关系)且预训练好之后不微调直接推理 (即zero-shot，用见过的图片特征去判断没见过的图片的类别，而不用下游任务训练集进行微调)
使得在ImageNet数据集上，CLIP模型在不使用ImageNet数据集的任何一张图片进行训练的的情况下，最终模型精度能跟一个有监督的训练好的ResNet-50打成平手 (在ImageNet上zero-shot精度为76.2%，这在之前一度被认为是不可能的) 为了训练CLIP，OpenAI从互联网收集了共4个亿的文本-图像对，论文称之为WIT(Web Image Text，WIT质量很高，而且清理的非常好，其规模相当于JFT-300M，这也是CLIP如此强大的原因之一，后续在WIT上还孕育出了DALL-E模型)
其训练过程如下图所示：
如下图的第一步所示，CLIP的输入是一对对配对好的的图片-文本对（比如输入是一张狗的图片，对应文本也表示这是一只狗），这些文本和图片分别通过Text Encoder和Image Encoder输出对应的特征。然后在这些输出的文字特征和图片特征上进行对比学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13392a1f4c5166d1ff1816a91abbe01b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7118737bd8c416bb61a08101eb87252/" rel="bookmark">
			【Matlab股票价格预测】基于BiLSTM双向长短期记忆网络的股票价格时间序列预测（附MATLAB代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 在当今高度数字化的金融市场中，股票价格预测一直是金融领域的热门话题。随着人工智能和机器学习技术的不断发展，利用这些技术进行股票价格预测已经成为可能。在本文中，我们将探讨如何使用Matlab中的BiLSTM（双向长短期记忆网络）来进行股票价格时间序列预测。
背景 股票市场的波动性使得股票价格预测成为一项具有挑战性的任务。传统的基于统计学方法的预测模型通常难以捕捉到市场的非线性特征和复杂动态。因此，人们开始转向机器学习和深度学习技术，希望能够更准确地预测股票价格。
BiLSTM简介 BiLSTM是一种深度学习模型，它结合了长短期记忆网络（LSTM）和双向循环神经网络（BRNN）的特点。LSTM是一种特殊的循环神经网络（RNN），它能够有效地处理时间序列数据，并且能够捕捉到长期依赖关系。双向循环神经网络则可以同时从过去和未来的信息中进行学习，从而更好地理解时间序列数据的动态特性。
Matlab中的BiLSTM Matlab是一种功能强大的数学计算软件，它提供了丰富的工具和函数用于进行数据分析和深度学习任务。Matlab中的深度学习工具包含了对LSTM和BiLSTM等深度学习模型的支持，使得我们可以方便地构建和训练这些模型。
使用BiLSTM进行股票价格预测 在使用BiLSTM进行股票价格预测时，我们需要准备好股票价格的时间序列数据。这些数据通常包括股票的开盘价、收盘价、最高价、最低价以及成交量等信息。我们可以使用Matlab中的数据处理工具对这些数据进行预处理和特征工程，以便输入到BiLSTM模型中进行训练。
一旦数据准备就绪，我们可以使用Matlab中的深度学习工具包来构建和训练BiLSTM模型。在构建模型时，我们需要考虑模型的结构、层数、以及超参数的选择。通过合理地调整这些参数，我们可以得到一个既能够充分挖掘时间序列数据特征，又不至于过度拟合的预测模型。
评估和优化 在训练完成后，我们需要对模型进行评估和优化。我们可以使用一些常见的评估指标如均方误差（MSE）、均方根误差（RMSE）以及平均绝对误差（MAE）来评估模型的预测性能。同时，我们也可以通过调整模型的超参数，如学习率、批大小等来优化模型的性能。
结论 在本文中，我们探讨了如何使用Matlab中的BiLSTM模型进行股票价格时间序列预测。通过合理地准备数据、构建模型、训练优化，我们可以利用这一强大的深度学习技术来更准确地预测股票价格。然而，需要注意的是，股票价格受到多种因素的影响，而且市场也可能发生剧烈变化，因此任何预测都存在一定的不确定性。
希望本文能够为对股票价格预测感兴趣的读者提供一些参考和启发。深度学习技术的不断发展将为股票价格预测带来更多可能性，我们期待在未来能够看到更多关于这方面的研究和应用。
📣 部分代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input);t_train = ind2vec(T_train);t_test = ind2vec(T_test ); ⛳️ 运行结果 🔗 参考文献 [1] 黄敬峰.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7118737bd8c416bb61a08101eb87252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297b038051ae0dde3555261d77e8d0ed/" rel="bookmark">
			使用iframe遇到的问题及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下使用iframe遇到的bug 动态的iframe src与返回的bug 场景：iframe嵌入页面，有多个tab，切换tab修改iframe的src，显示不同的页面
&lt;ul&gt; &lt;li v-for="tab in tabList" :key="tab.tabName" class="tab-item" :class="{ activeTab: activeTabName === tab.tabName }" @click="changeTab(tab)" &gt; {{ tab.tabName }} &lt;/li&gt; &lt;/ul&gt; &lt;iframe :src="iframePath" frameborder="0" width="100%" height="600" id="iframe" &lt;/iframe&gt; data() { return { tabList: [ { path: "http://www.test.com/firstPage.html", tabName: "hover页面", }, { path: "http://www.test.com/secondPage.html", tabName: "关系图谱", }, { path: "http://www.test.com/thirdPage.html", tabName: "echart页面 ", }, ], activeTabName: "hover页面", iframePath: "http://www.test.com/firstPage.html", }; }, methods: { changeTab(tab) { if(this.iframePath===tab.path) return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297b038051ae0dde3555261d77e8d0ed/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/26/">«</a>
	<span class="pagination__item pagination__item--current">27/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/28/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>