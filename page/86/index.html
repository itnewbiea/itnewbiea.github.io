<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666ea06b3545e64a11964ef4785d7f9c/" rel="bookmark">
			ORA-12704字符集不匹配 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有客户新上线反馈，查询的时候报错：ORA-12704字符集不匹配。
通过日志发现是一个UNION ALL的连接语句出现的，根据资料发现，UNION ALL用法必须前后两个结果集的字段类型要完全相同才行。
检查客户的数据库发现，果然有一个字段类型不同：
由于oracle如果该字段有内容，不能直接修改类型，需要新建个字段把旧数据拷贝过去，再把旧字段的内容清空才能修改类型。
类型修改成一致后，可以正常查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dfd2e7c78eff1342d89731729a2d00b/" rel="bookmark">
			电脑系统坏了，如何重装系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重启电脑：在当前状态正常重启电脑，或按主机重启键重启电脑，或先长按电源键强制关机再重新开机，如果不再出现错误提示并且能够正常进入系统操作，说明上次不正常只是偶尔的程序或系统运行错误，无关紧要。
二、修复错误：如果频繁无法正常进入系统，则开机后马上按F8，看能否进入安全模式或最后一次配置正确模式，如能则进入后系统会自动修复注册表，并回忆前几次出现不正常现象时进行了什么操作，并根据怀疑是某个应用软件（或驱动程序）导致问题产生，将其卸载，然后正常退出，再重启就应当能进入正常模式。如安装有安全软件，可在安全模式下使用360安全卫士加360杀毒或者金山毒霸等等类似安全软件进行全盘木马、病毒查杀。
三、重装系统：如果以上操作无效，则需要重装系统（注：如果c盘有重要数据则事先需要进行备份）。电脑安装系统方法很多，以下所列可择一操作。
1、硬盘安装：
（1）开机或重启后按F11键或F8键，看有没有安装一键GhoSt或类似软件，有则选择一键还原按回车确定；
（2）进入一键还原操作界面后，再选择“还原”确定即可。如果以前刚进行过一键备份，则能恢复到备份时的状态。
另外，如果能够进入现在的系统或开机时按F8能够进入命令行模式，可搜索windowS版或doS版的GhoSt.exe程序和Gho系统文件，然后手工运行GhoSt程序装载系统Gho文件也能重装系统。
2、U盘安装：如果没有一键还原，则使用系统U盘重装系统。启动U盘制作及U盘重装系统的操作步骤为：
（1）制作启动U盘：到实体店买个容量8G以上的U盘，上网搜索下载老毛桃或大白菜等启动U盘制作工具，将U盘插入电脑运行此软件制作成启动U盘，再到系统之家或类似网站下载winXP或win7等操作系统的Gho文件，复制到U盘或启动工具指定的U盘文件夹下并按要求重命名。也可以上网搜索下载iSo格式的系统镜像文件（内含Gho系统文件或完整的系统安装文件），通过ultraiso等工具释放到U盘制作成包含系统的启动U盘。
（2）设置U盘启动：开机按deL键（笔记本一般为F2或其它）进入bioS设置界面，进入boot选项卡设置U盘（有USb-hdd、USb-Fdd等不同格式，优先选择USb-hdd）为第一启动项（注：部分电脑需要在此时插入U盘进行识别才能设置），再按F10保存退出重启。部分新主板支持开机后连按F12或F11进入启动选项菜单，可不进cmoS界面直接选择U盘（事先插入U盘即识别出来的U盘的型号）或Generic Flash disk（通用闪存盘）或Removable device（移动磁盘）启动电脑。
（3）U盘重装系统：插入U盘启动电脑，进入U盘功能菜单之后，选择“安装系统到硬盘第一分区“，回车确定后按提示操作，或者进入Pe系统后，运行桌面上的“一键安装系统”，电脑会自动运行GhoSt软件并自动搜索U盘上的Gho文件克隆安装到c区，整个过程基本无需人工干预，直到最后进入系统桌面。
3、光盘安装：电脑使用光盘重装系统，其操作步骤如下：
（1）准备系统光盘：如果没有可以去电脑商店购买，需要安装什么系统就买什么系统的最新版光盘。如果有刻录光驱，也可上网自行下载iSo格式的系统文件刻录成系统光盘。
（2）设置光盘启动：开机后按deL键（笔记本一般为F2或根据屏幕底行提示的热键）进入cmoS，并在boot选项卡中设置光驱（cd-Rom或dVd-Rom）为第一启动项（老主板需要进入advanced bioS Features选项卡后，在“1st boot device”处回车，再选择cd/dVd-Rom），再按F10保存退出重启。重启电脑时及时将系统光盘插入光驱。
（3）克隆安装系统：光盘启动成功后会显示功能菜单，此时选择菜单中的“安装系统到硬盘第一分区”，回车确定后按提示操作，或者进入Pe系统后，运行桌面上的“一键安装系统”，电脑会自动运行GhoSt软件自动载入Gho文件克隆安装到c区，整个过程基本无需人工干预，直到最后进入系统桌面。
注意：在安装系统完成后，先安装安全软件如360安全卫士加360杀毒或者金山毒霸之类其它安全软件，进行全盘查杀木马、病毒，再打好系统补丁、安装常用软件，并下载安装使用一键还原工具进行系统备份，以备不时之需。
一、机器内灰尘过多，接触不良会引起死机故障，清洁机箱，将所有的连接插紧、插牢。
二、检查cPU和显卡散热，除尘，上油，或更换风扇。
三、电源电压不稳，电源功率不足，更换质量高的功率大的电源。
四、更换主板电池，将bioS设置为出厂默认值。
五、重启，按F8打开"win高级选出项菜单"-用键盘↑↓键选"最后一次正确配置"-回车。或重启，按F8打开"win高级选出项菜单"-用键盘↑↓键选"安全模式"-回车-在"桌面"警告选"是"-重启。
六、为了不损失该盘中的数据，拿到朋友家把需要保存的东西，保存到另一块硬盘中，修复、格式化硬盘，重装系统。
来源：https://www.weidianyuedu.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3dbdbca06876e67372a4f8f6cab16bc/" rel="bookmark">
			填充和步幅在卷积神经网络中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填充和步幅在卷积神经网络中的应用 引言填充理论推导计算步骤例子 步幅理论推导计算步骤例子 结构图结论参考文献 引言 在卷积神经网络中，填充和步幅是两个重要的概念。填充是指在输入数据周围添加一定数量的虚拟数据，以便增加输出的大小。步幅则是指卷积核在输入数据上滑动的步长。本文将详细介绍填充和步幅的概念、应用以及计算方法，并使用PyTorch给出具体的例子。
填充 填充可以增加输出的大小，从而使得卷积层能够更好地保留输入数据的边缘信息。在卷积神经网络中，通常使用两种类型的填充：零填充和边缘填充。
理论推导 假设输入数据为 X X X，卷积核大小为 K K K，输出数据为 Y Y Y，则使用零填充的输出数据大小为：
Y s i z e = ( X s i z e − K s i z e + 2 P ) / S + 1 Y_{size} = (X_{size} - K_{size} + 2P) / S + 1 Ysize​=(Xsize​−Ksize​+2P)/S+1
其中， P P P是填充大小， S S S是步幅大小。为了使输出大小与输入大小相等，可以解出 P P P的值：
P = ( K s i z e − 1 ) / 2 P = (K_{size} - 1) / 2 P=(Ksize​−1)/2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3dbdbca06876e67372a4f8f6cab16bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24a2a7c9b5c815c040710c4bd39d2ae/" rel="bookmark">
			【uni-app】uni-app实现聊天页面功能——功能篇（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、聊天框随键盘抬起思路代码实现 二、聊天消息列表随着聊天框的增高而滚动到最底部思路 三、问题完整代码实现总结 前言 前面我有写关于如何进行聊天页面布局和实现聊天消息滚动到最底部的文章。
【uni-app】uni-app实现聊天页面功能——功能篇（上）
【uni-app】uni-app实现聊天页面功能（小程序）——布局篇
这篇文章是基于这两篇的基础上完善的。
主要还是实现以下两个功能：
点击聊天框的时候，聊天框随键盘抬起且聊天消息列表滚动到最底部，但整体页面不抬起
聊天框textarea根据内容自适应高度，且聊天消息列表随着聊天框的增高而滚动到最底部（说白了就是最底部的消息不会被增高的聊天框给挡住）
一、聊天框随键盘抬起 uni-app官方文档中其实有给出关于这个的解决方案，只用设置一个属性。
textarea | uni-app官网 (dcloud.net.cn)
textarea的属性：
adjust-position —— 键盘抬起时，是否自动上推页面（默认值为true）
cursor-spacing —— 指定光标与键盘的距离，单位px（就是设置键盘与输入框的距离，默认值为0）
&lt;textarea cursor-spacing = "60"&gt;&lt;/textarea&gt; 虽然这种方法简单，但是有一个不好的地方是：页面整体会上移
如果想让聊天框随键盘抬起的同时不想让页面上移，可以参考下面这个方法。
思路 首先我们需要在键盘抬起的时候获取到键盘的高度，然后给聊天框动态设置合适的bottom值（键盘的高度），最后给textarea的属性adjust-position设置为false。
至于在点击聊天框的时候聊天消息定位到最底部（不会被遮挡）我将放到第二个板块去讲！！！
获取键盘高度采用官方给出的api（最快且稳定的）实现：uni.hideKeyboard() | uni-app官网 (dcloud.net.cn)
我们在页面加载时设置uni.onKeyboardHeightChange监听事件去获取到键盘高度，在页面卸载时使用uni.offKeyboardHeightChange解除监听键盘高度事件。
代码实现 视图部分（简写）：
&lt;template&gt; &lt;view class="chat"&gt; &lt;scroll-view :style="{height: `${windowHeight-keyboardHeight}rpx`}" id="scrollview" scroll-y="true" :scroll-top="scrollTop" :scroll-with-animation="true" class="scroll-view" &gt; &lt;view id="msglistview" class="chat-body"&gt; ... &lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 底部消息发送栏 --&gt; &lt;view class="chat-bottom"&gt; &lt;view class="send-msg" :style="{bottom:`${keyboardHeight}rpx`}"&gt; &lt;view class="uni-textarea"&gt; &lt;textarea v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24a2a7c9b5c815c040710c4bd39d2ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8b4fa7f2c92e9ddfeac9b54e7501d2/" rel="bookmark">
			Java实现文件预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求背景 项目需要实现一个在Android端群文件上传后支持预览的功能。
PS：常见文件格式如pdf、html、txt、图片在线预览较为简单，word，excel，ppt在线预览较为困难
二、技术方案调研 方案1：通过腾讯TBS代替原生WebView（还有Google doc、Office Web 365等也需付费使用）
优点：安卓端集成SDK方式，效率高，功能强大
缺点：目前新版本已收费（若没有成本预算顾虑，直接选择该方案即可）
详见：Android 通过腾讯TBS实现文件预览功能-编程学习网
方案2：安卓端使用Apache的poi组件读取word、excel，结合itext生成pdf
优点：安卓端实现方便
缺点：预览效果差，不支持ppt的转换，且存在jwt的jar包无法调用问题（这里不作展开）
方案3：服务端jodconverter+openOffice实现office文档转换为pdf，安卓端使用AndroidPdfViewer预览pdf文档
优点：一般格式预览效果还行，linux可使用中文路径，跨平台
缺点：复杂格式可能有错位，jodconverter依赖于openOffice，需在linux服务安装openOffice
详见：Java实现word、excel、ppt、txt等办公文件在线预览功能 - 腾讯云开发者社区-腾讯云
方案4：服务端Aspose实现office文档转换为pdf，安卓端使用AndroidPdfViewer预览pdf文档
优点：实现简单，无需安装插件服务，文件转换较快，跨平台
缺点：使用Aspose破解版，商用涉及版权问题，使用中文路径会乱码（这里不作展开）
方案5：使用kkfileview+openOffice实现转换和预览
优点：开源项目，支持文件格式齐全，不用开发，文件转换较快，跨平台（emmm，真香~）
缺点：需在linux服务安装openOffice（安装简单，兼容性较差）或libreOffice（建议采用，centOS系统低版本安装较麻烦），kkfileview（可详见下述步骤）
最终决策：选择方案5
三、安装libreOffice/openOffice 安装libreOffice参考（kkFileView 4.0.0之后的版本，建议安装libreOffice），安装教程参考：centos7 安装LibreOffice（超级详细）_刘奶奶向柳奶奶借牛奶的博客-CSDN博客
参考安装教程：centos7 安装LibreOffice（超级详细）_刘奶奶向柳奶奶借牛奶的博客-CSDN博客
1.解压
新建目录：mkdir /data/libreOffice7.4
上传并解压：tar -zxvf LibreOffice_7.4.5.1_Linux_x86-64_rpm_helppack_zh-CN.tar.gz
LibreOffice_7.4.5.1_Linux_x86-64_rpm_langpack_zh-CN.tar.gz
2.更新配置（参照教程）
vim /etc/profile
export LibreOffice_PATH=/opt/libreoffice7.4/program
export PATH=$LibreOffice_PATH:$PATH
source /etc/profile
3.进入目录：cd /data/libreOffice/LibreOffice_7.4.5.1_Linux_x86-64_rpm/RPMS
执行（安装所有rpm文件）：su -c 'yum install *.rpm'
默认安装目录：/opt/libreoffice7.4/program
4.启动
执行启动命令：/opt/libreoffice7.4/program/soffice --headless --accept="socket,host=127.0.0.1,port=8100;urp;" --nofirststartwizard &amp;
检查启动情况，查看进程：ps -ef|grep libreoffice
5.卸载：
cd /data/libreOffice
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba8b4fa7f2c92e9ddfeac9b54e7501d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42ed57f1e716dd962ae9b83407fccda/" rel="bookmark">
			【uni-app】uni-app实现聊天页面功能（小程序）——布局篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言划分区域问题内容溢出关于调试聊天框 代码实现 前言 在工作中使用uni-app参与开发一个小程序，其中要写一个简单的聊天页面，虽然功能不多（只有一个发送文字的功能），但是其中的细节比较多，也踩过很多坑，特此记录下来。要实现的页面如图所示，该篇主要讲讲如何布局（参考了很多文章之后根据页面需求进行一个整合）。
划分区域 先划分大区域，主要包含两个（顶部导航栏用的小程序自带的，所以就没有自己写，后续有需求可能会自定义导航栏）聊天内容区和底部发送框。
其中因为要实现发送内容页面会自动滚到最底部，所以聊天内容区在布局上是采用了scroll-view,必须要给它设置一个基础的高度（这里设置为屏幕的高度），而聊天消息列表的高度是根据内容来撑开。
注意！底部聊天框是采用固定定位固定在页面的底部，它不遵循标准流，当聊天内容充满整个屏幕时，最底部的消息会被聊天框遮挡，为了避免这种情况发生，需要在聊天框外再套一层有固定高度的view来占位。
问题 内容溢出 而实际测试时还发现了一个问题：连续的数字会溢出内容框！
因为连续的数字被浏览器误认为是英文单词，而英文单词在默认情况下是不会分开换行的，解决方案是在css内容框中加入如下代码（二选一即可）：
//写法一 word-wrap: break-word; //写法二 word-break: break-all; 这样就解决了！
关于调试聊天框 小程序模拟器和真机上在聊天框中会略微有点差别！！！
（我设置了padding，模拟器上文字是贴着，但真机上文字居中）
模拟器：
真机：
代码实现 下面是整个页面的完整代码（已更新）：
&lt;template&gt; &lt;view class="chat"&gt; &lt;scroll-view :style="{height: `${windowHeight}rpx`}" id="scrollview" scroll-y="true" :scroll-top="scrollTop" :scroll-with-animation="true" class="scroll-view" &gt; &lt;!-- 聊天主体 --&gt; &lt;view id="msglistview" class="chat-body"&gt; &lt;!-- 聊天记录 --&gt; &lt;view v-for="(item,index) in msgList" :key="index"&gt; &lt;!-- 自己发的消息 --&gt; &lt;view class="item self" v-if="item.userContent != ''" &gt; &lt;!-- 文字内容 --&gt; &lt;view class="content right"&gt; {{item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42ed57f1e716dd962ae9b83407fccda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b84173bbb344c03afada8a6ffbc9869/" rel="bookmark">
			【uni-app】uni-app实现聊天页面功能——功能篇（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言思路坑代码实现 前言 上一篇讲到了如何布局，这一篇将讲一下如何用uni-app实现小程序聊天页面的最主要的功能——发消息后页面滚动到最底部（参考过很多文章最后找到比较适合的方法）。
其他的功能（参考微信），之后的文章会讲述到具体实现方法
点击聊天框的时候，聊天框随键盘抬起且聊天消息列表滚动到最底部，但整体页面不抬起聊天框textarea根据内容自适应高度，且聊天消息列表随着聊天框的增高而滚动到最底部（说白了就是最底部的消息不会被增高的聊天框给挡住） 思路 由于我们在布局上聊天滚动用的是scroll-view，里面嵌套着一个存放消息列表的容器（如左图所示），scroll-view中的一个重要属性是scroll-top，官方文档解释设置竖向滚动条位置。
当消息列表的长度超过scroll-view的高度时，它们之间的高度差就是scroll-view要滚动的距离（如右图所示）。
获取节点信息用boundingClientRect这个函数，具体方法可以参考官网uni.createSelectorQuery() | uni-app官网 (dcloud.net.cn)
坑 原本js部分的代码是这样写的：
scrollToBottom(){ let query = uni.createSelectorQuery().in(this); // 获取节点信息 query.select('#scrollview').boundingClientRect(); query.select('#msglistview').boundingClientRect(); query.exec((res) =&gt;{ if(res[1].height &gt; res[0].height){ this.scrollTop = res[1].height - res[0].height } }) }, 但是，在实测时（小程序模拟器和真机）发现滚动的位置有时滚动不到最底部（如图所示，其实下面还有一条消息被遮住了没显示出来），有时又可以滚动到最底部。
初步怀疑是节点信息获取不准确，我就去搜了关于boundingClientRect()这个函数的相关信息，官方文档上并没有对这个问题的解释，后来找到解决方案
参考文章：微信小程序 boundingClientRect 获取元素节点位置信息不准确_LGDmar的博客-CSDN博客
问题所在：页面未渲染完成而去获取了节点信息
解决方案：
方法一：可以设置一个延时函数setTimeout，因为我们不知道渲染的时间是多少，所以我是经过试验得出一个满足需求的延时时间。
// 滚动至聊天底部 scrollToBottom(){ // 外层加一个延时函数是为了能获取到节点的准确信息 setTimeout(()=&gt;{ let query = uni.createSelectorQuery().in(this); // 获取节点信息 query.select('#scrollview').boundingClientRect(); query.select('#msglistview').boundingClientRect(); query.exec((res) =&gt;{ if(res[1].height &gt; res[0].height){ this.scrollTop = this.rpxTopx(res[1].height - res[0].height) } }) },15) }, 方法二：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b84173bbb344c03afada8a6ffbc9869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c78ec925bf396e609bdb9c8e3eaf3e2/" rel="bookmark">
			Java，excel大量百万数据导出优化措施，SXSSFWorkbook流式、分批次导出示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在导出百万级的数据时，如果不采用适当的优化措施，确实可能会造成死机和内存崩溃等问题。
为避免这些问题，可以采用以下优化措施：
分批次读取数据：将需要导出的数据分成多个批次进行读取和写入，每次读取部分数据，写入 Excel 后即时清除内存。这样可以避免一次性加载全部数据导致内存占用过大的问题。使用流式写入方式：在遍历结果集的同时，使用流式写入方式（如 SXSSF）将数据写入 Excel 表格中，避免一次性将所有数据都写入内存中。关闭不必要的连接：在写代码时应当及时关闭 ResultSet、Statement 和 Connection 连接，以释放资源，减轻系统负担。使用合适的服务器硬件配置: 导出数据量较大的情况下，建议使用高性能的服务器，如配备更多的 CPU和内存， 以提高系统处理能力和速度。合理设置 JVM 内存分配：如果 JVM 内存分配不合理，则可能会导致内存溢出等问题。可以通过调整-Xmx、-Xms 等参数，来合理设置 JVM 的内存分配。 在 pom.xml 文件中添加以下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; public void exportExcel() throws Exception{ // 加载驱动程序 Class.forName("com.mysql.cj.jdbc.Driver"); // 连接数据库 Connection conn = DriverManager.getConnection(url, username, password); // 查询语句 String sql = "SELECT * FROM user"; Statement stmt = conn.createStatement(); ResultSet rs = null; // 创建一个 Excel 文档 SXSSFWorkbook workbook = new SXSSFWorkbook(100); try { // 设置表格格式 Sheet sheet = workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c78ec925bf396e609bdb9c8e3eaf3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeaf7322e1168ed4e3a6ff9506f6cb74/" rel="bookmark">
			互相关运算和卷积运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互相关运算和卷积运算是两种常用的图像处理方法。它们都是用于在图像处理中进行滤波操作的。
1. 互相关运算 互相关运算是一种基于滤波的图像处理方法，它用于对图像进行平滑和增强等操作。在互相关运算中，我们将一个滤波器（也称为卷积核或核函数）应用于图像的每个像素，以产生一个输出图像。
互相关运算的计算公式如下：
y i , j = ∑ k , l x i + k , j + l h k , l y_{i,j} = \sum_{k,l} x_{i+k,j+l}h_{k,l} yi,j​=k,l∑​xi+k,j+l​hk,l​
其中， x x x 表示输入图像， y y y 表示输出图像， h h h 表示滤波器。
下面是一个简单的例子，展示了如何使用 PyTorch 实现互相关运算：
import torch import torch.nn.functional as F # 创建一个 1x3x3 的输入张量和一个 1x2x2 的滤波器 x = torch.tensor([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], dtype=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeaf7322e1168ed4e3a6ff9506f6cb74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700fb35476f8ed4b4e9690a922ca8496/" rel="bookmark">
			特征图和感受野
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特征图和感受野是深度学习中非常重要的概念，本文将从理论和实践两个方面详细解释它们的含义和作用。
1.特征图 特征图是深度学习中常用的一种数据结构，它是卷积神经网络（CNN）中的一个重要概念。特征图是由一系列卷积核对输入图像进行卷积操作得到的结果。它可以看作是原始图像的抽象表示，其中每个像素点表示一些特定的特征。
在CNN中，特征图是网络中的中间层结果，它们可以被进一步处理和传递到后续的层中。特征图的大小和数量取决于卷积核的大小和数量，以及卷积的步长和填充方式等参数。
下面是一个简单的PyTorch代码示例，它演示了如何使用卷积层生成特征图：
import torch import torch.nn as nn # 定义一个简单的卷积神经网络 class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1) self.conv2 = nn.Conv2d(16, 32, kernel_size=3, stride=1, padding=1) self.pool = nn.MaxPool2d(kernel_size=2, stride=2) def forward(self, x): x = self.conv1(x) x = nn.functional.relu(x) x = self.pool(x) x = self.conv2(x) x = nn.functional.relu(x) x = self.pool(x) return x # 创建一个输入张量 x = torch.randn(1, 3, 32, 32) # 创建网络对象 net = Net() # 使用网络处理输入张量 output = net(x) # 打印输出张量的形状 print(output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700fb35476f8ed4b4e9690a922ca8496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b3dca9c5a8e8ef010ba0e20100c458/" rel="bookmark">
			【cmake学习】cmake 引入第三方库（头文件目录、库目录、库文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序的编写需要用到头文件，程序的编译需要lib文件，程序的运行需要dll文件，因此cmake引入第三方库其实就是将include目录、lib目录、bin目录引入工程。
目录
1、find_package（批量引入库文件和头文件）
2、include_directories（引入头文件目录）
3、link_directories（引入库文件目录到当前工程）
4、link_libraries (引入库文件到当前工程)
5、target_link_libraries（引入库文件到子工程）
6、target_include_directories（引入头文件目录到子工程）
1、find_package（批量引入库文件和头文件） find_package 的详细使用：find_package 的详细使用
find_package 需要通过 .cmake 为后缀的文件引入，能够将 .cmake 包含的库和头文件全部引入工程。不同的库的达到的效果不同。有时需要搭配关键字使用：
REQUIRED：必须找到该库，找不到就报错COMPONENTS：从库中找子库（模块）xx，比如COMPONENTS Widget表示找到子模块Widget 以OpenCV库为例，OpenCV库提供的是 OpenCVConfig.cmake文件，只需引入一次，便可以将OpenCV所有的库文件和头文件引入到当前工程。OpenCVConfig.cmake 也给出了详细的说明。
find_package(OpenCV REQUIRED) # OpenCV_INCLUDE_DIRS 是预定义变量，代表OpenCV库的头文件路径 include_directories(${OpenCV_INCLUDE_DIRS}) # OpenCV_LIBS 是预定义变量，代表OpenCV库的lib库文件 target_link_libraries(MY_TARGET_NAME ${OpenCV_LIBS}) 以QT库为例，QT库是一个大型库，内部还包含了许多子库，在引入的时候最好按需引入
# 含义：必须找到Qt5库的子模块Core，找不到就报错 find_package(Qt5 COMPONENTS Core REQUIRED) # 链接时需要加上前缀Qt::(这里是Qt5的库) target_link_libraries(qt_test Qt5::Core ) 注意：无论是上面的Widget，还是Core，都是去掉了前缀Qt5。实际上，Qt的子库名字都是有前缀 "Qt5" 的！只不过在引入的时候，要去掉。
2、include_directories（引入头文件目录） include_directories表示引入头文件搜索路径，当工程要用到某个头文件的时候，就会去该路径下搜索。一般都是在顶层的CmakeList文件中添加搜索路径。
include_directories(完整路径) # 绝对路径引入 include_directories("D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64\\include") # 普通变量引入(可以理解为把D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64放入一个集合INCLUDE_PATH) # ${变量名} 可以获取集合内容，允许拼接 set (INCLUDE_PATH D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64) include_directories(${INCLUDE_PATH}/include) # 环境变量引入 # 假设环境变量是INCLUDE_PATH = D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64 # #ENV{环境变量名} 可以获取环境变量的内容，允许拼接 include_directories($ENV{INCLUDE_PATH}/include) 一个cmake总工程可以包含多个子工程，总工程引入的头文件，并不代表子工程就可以用，就好比幼儿园老师（总工程）买来一箱苹果，小朋友（子工程）根据需求拿苹果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b3dca9c5a8e8ef010ba0e20100c458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d58bc3e0472e2e72bcd1b99ca200950/" rel="bookmark">
			Spring-学习修改尚硅谷最新教程笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、Spring 1、Spring简介 1.1、Spring概述 官网地址：https://spring.io/
Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用
Spring 框架来创建性能好、易于测试、可重用的代码。
Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首
次在 Apache 2.0 许可下发布。
Spring 是轻量级的框架，其基础版本只有 2 MB 左右的大小。
Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应
用程序是需要扩展的。 Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO
编程模型来促进良好的编程实践。
1.2、Spring家族 项目列表：https://spring.io/projects
1.3、Spring Framework Spring 基础框架，可以视为 Spring 基础设施，基本上任何其他 Spring 项目都是以 Spring Framework为基础的。
1.3.1、Spring Framework特性 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常 小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会
破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d58bc3e0472e2e72bcd1b99ca200950/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0283157af7a372481f07d99b1983cd/" rel="bookmark">
			pandas中对df进行多条件筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个df，有的时候希望对df中每个列指定不同的筛选条件，并希望根据这个条件，直接筛选出最终的df结果。
例子：有一个df，字段有：性别，身高，体重
性别身高体重男高140男矮90女矮85女高85 现在我想根据以下条件："性别==男"，'身高==高or身高==矮'，'体重&gt;100'。直接筛选出最终的df 代码如下：
def mutquery(self,df,listquary):
'''
多条件筛选
listquary:列表，分别指定每列的筛选条件
'''
#定义一个空列表，用来保存最终的索引条件
list_tiaos=[]
def fun_t(key):
'''
定义方法,将如'A列&gt;15'这样的筛选条件按照&gt;号分割成A列和15,,以便使用df['A']&gt;15进行df的筛选
'''
if '&gt;' in key:
#获取条件左右对应的字段和判断值
target=key.split('&gt;')[0]
value=key.split('&gt;')[1]
tiao=df[target]&gt;eval(value)
elif '&lt;' in key:
target=key.split('&lt;')[0]
value=key.split('&lt;')[1]
tiao=df[target]&lt;eval(value)
elif '==' in key:
target=key.split('==')[0]
value=key.split('==')[1]
try:
#如果判断值是数字,则将其转化为数字再判断
tiao=df[target]==eval(value)
except:
#否则将其作为字符处理
tiao=df[target]==value
elif '&gt;=' in key:
target=key.split('&gt;=')[0]
value=key.split('&gt;=')[1]
tiao=df[target]&gt;=eval(value)
elif '&lt;=' in key:
target=key.split('&lt;=')[0]
value=key.split('&lt;=')[1]
tiao=df[target]&lt;=eval(value)
return tiao
#循环遍历每一个条件
for key in listquary:
#得到二维数组,[[bool1],[bool2]]
if 'or' in key:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0283157af7a372481f07d99b1983cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c60485a49598d7e1574df748d13f515/" rel="bookmark">
			GRU实现时间序列预测(PyTorch版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💥项目专栏：【深度学习时间序列预测案例】零基础入门经典深度学习时间序列预测项目实战（附代码+数据集+原理介绍）
文章目录 前言一、基于PyTorch搭建GRU模型实现风速时间序列预测二、时序数据集的制作三、数据归一化四、数据集加载器五、搭建GRU模型六、定义模型、损失函数、优化器七、模型训练八、可视化结果完整源码 前言 👑 最近很多订阅了🔥《深度学习100例》🔥的用户私信咨询基于深度学习实现时间序列的相关问题，为了能更清晰的说明，所以建立了本专栏专门记录基于深度学习的时间序列预测方法，帮助广大零基础用户达到轻松入门。
👑 本专栏适用人群：🚨🚨🚨深度学习初学者，刚刚接触时间序列的用户群体，专栏将具体讲解如何快速搭建深度学习模型用自己的数据集实现时间序列预测，快速让新手小白能够对基于深度学习方法进行时间序列预测有个基本的框架认识。
👑 本专栏整理了《深度学习时间序列预测案例》，内包含了各种不同的基于深度学习模型的时间序列预测方法，例如LSTM、GRU、CNN（一维卷积、二维卷积）、LSTM-CNN、BiLSTM、Self-Attention、LSTM-Attention、Transformer等经典模型，💥💥💥包含项目原理以及源码，每一个项目实例都附带有完整的代码+数据集。
正在更新中~ ✨
🚨 我的项目环境：
平台：Windows10语言环境：python3.7编译器：PyCharmPyTorch版本：1.11.0 💥 项目专栏：【深度学习时间序列预测案例】零基础入门经典深度学习时间序列预测项目实战（附代码+数据集+原理介绍）
一、基于PyTorch搭建GRU模型实现风速时间序列预测 高精度、可靠的风速预报是气象学家面临的挑战。由对流风暴引起的强风，造成相当大的破坏(大规模森林破坏、停电、建筑物/房屋损坏等)。雷暴、龙卷风以及大冰雹、强风等对流事件是有可能扰乱日常生活的自然灾害，特别是在有利于对流启动的复杂地形上。即使是普通的对流事件也会产生强风，造成致命和昂贵的损失。因此，风速预测是一项重要的工作。
本篇文章我们采用了经典的循环神经网络 GRU 来对我们的时序数据建模处理，作为该专栏的第一篇文章，本篇将💎 详细介绍项目的每个实现部分以及细节处理，帮助新手小白快速建立起如何处理时序数据的框架。
二、时序数据集的制作 对于实现时间序列预测，我们使用的原始数据集往往不能够直接送入模型，需要进行预处理，这里说的预处理并不是处理空值、归一化这种处理方式，而是基于原始数据构建模型需要的时序数据集。
为了介绍什么是时序数据集，我们举个例子：
假设我们的原始数据如下：
第一列为时间刻度，代表每个样本的时间，第二列则为建模数据，由于数据集中只有一列特征，所以 WIND 既是输入的特征，又是模型的输出（预测值），由于是时序预测，那么我们就需要基于以前时间发生的数据来预测未来的数据。
DATE	WIND	1961-01-01	13.67 1961-01-02	11.50 1961-01-03	11.25 1961-01-04	8.63 1961-01-05	11.92 如果我们设置 timestep 为2的话（timestep就是时间窗口，用户滑动制作时序数据），那么我们将会产生如下的时序样本：
T1	T2 target 13.67	11.50	11.25 11.50	11.25	8.63 11.25	8.63	11.92 其中 T1 代表前2天的数据，T2代表前1天的数据，该数据维度为【3，2】，代表3个时序样本，2天数据（也就是timestep的值），这里发现时序数据集相对于原始数据集少了2个，这是因为前2个样本没有以前数据的参照，只有从第3个样本开始，他才有前两天的数据，所以我们的时序数据集的个数应该是 len(data)-timestep 个。
这个时序数据集的意思就是利用前2天的风速去预测未来1天的风速，所以我们需要基于原始数据来提取出这种的数据集，进而送入模型进行训练，我们可以根据我们的业务需求来调整 timestep 的大小，有些任务可能定为24，这个意思就是利用前24个样本去预测未来的样本，这种一般时间周期为24小时，这个数据集是针对单特征输入的，也就是整个数据中只有一个特征 WIND，这里说的一个特征是原始特征，也就是每天（每个样本）的特征维度。
如果每天的特征存在多个，这就是多变量输入，其实制作方法是一样的，只不过相对于单特征多了一个维度，举例：
DATE	WIND	TEMPERATURE	RAIN 1961-01-01	13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c60485a49598d7e1574df748d13f515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cccecc5fd53c4ae05ede0ecc33f33a8c/" rel="bookmark">
			控制台输出vue实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台输出vue实例的两种方法:
在这里我想介绍一下在控制台输出vue实例的两种方法，我觉得其中一种不管是vue框架还是其他框架都是适用的， 我就不说是哪种方法了 大家都可以试一遍：
1、前后端分离的项目中，如果挂载的id名是app,我们可以在控制台中这么打印获取：
2、如果你是在直接是在某一个html文件里面创建一个实例，我们可以这么操作:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc9568c28887cc3ac6e9a682775d036/" rel="bookmark">
			如何搭建Vsftpd服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vsftpd是“very secure TTP daemon”的缩写，是一个完全免费的、开放源代码的ftp服务器软件。同时它也是Linux发行版中最受推崇的ftp服务器程序。
一、创建用户
#创建用户并指定主目录 useradd -d /home/ftp/Test -s/sbin/nologin -g ftp Test #设置密码 password Test 二、分配权限
2.1 创建用户目录
mkdir -p /home/ftp/Test 2.2 将刚创建的目录拥有者更换为ftp用户组下的Test用户
chown root:ftp /home/ftp/Test 2.3 为Test目录设置访问权限，700的意识是除目录拥有者外同组或其他用户均无权限
chmod 700 /home/ftp/Test 三、安装Vsftps
3.1 检查是否安装了Vsftpd
rpm -qa | grep vsftpd 3.2 如果没有任何显示即没有检测到安装包 ，接下来就可以安装Vsftps
yum install -y vsftpd 注意：可能出现下面两种情况
1. /var/run/yum.pid已被锁定,PID为xxxx的另一个程序正在运行
解决方案：只需要卸载 yum.pid 就好，具体操作：
rm -f /var/run/yum.pid 2. 进程在睡眠中......
解决方案：查看该进程ID，一般会列出或使用下面的命令查询：
ps -aux | grep yum 然后杀死进程后重新开始进程
kill 进程号 四、配置文件
4.1 编辑ftp配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc9568c28887cc3ac6e9a682775d036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2d13850119a221870a8b63880c9392/" rel="bookmark">
			wangEditor 实现ctrl&#43;v粘贴图片并上传、word粘贴带图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前在工作中遇到在富文本编辑器中粘贴图片不能展示的问题，于是各种网上扒拉，终于找到解决方案，在这里感谢一下知乎中众大神以及TheViper。
通过知乎提供的思路找到粘贴的原理，通过TheViper找到粘贴图片的方法。
其原理为一下步骤：
监听粘贴事件；【用于插入图片】
获取光标位置；【记录图片插入位置】
获取剪切板内容；【主要是获取文件】
上传剪切板图片；
在指定光标位置插入图片。
以下是代码部分：
1.获取光标代码部分，大部分都是直接利用TheViper的代码，只是做了简单的修改，在获取光标的位置添加了插件子集document对象，因为直接使用document对象获取不到光标位置
var isSupportRange = typeof document.createRange == 'function';
var currentRange,
_parentElement;
// 获取当前光标多在位置
function getCurrentRange(target) {
var selection,
range;
if (isSupportRange) {
selection = target.getSelection();
if (selection.getRangeAt &amp;&amp; selection.rangeCount) {
range = selection.getRangeAt(0);
_parentElement = range.commonAncestorContainer;
}
} else {
range = target.selection.createRange();
_parentElement = range.parentElement();
}
return range;
}
function saveSelection(target) {
currentRange = getCurrentRange(target);
}
function _restoreSelection() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea2d13850119a221870a8b63880c9392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329d0e98aa308948e5f891fb8aa79493/" rel="bookmark">
			C语言 怎么输入3个数 输出最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键入三个数 输出最大值问题 #include&lt;stdio.h&gt; int main(){ int a,b,c; printf("请输入三个整数:\n"); scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if (a&gt;b&amp;&amp;a&gt;c) printf("%d",a); else if(b&gt;a&amp;&amp;b&gt;c) printf("%d",b); else printf("最大值为 %d",c); return 0; } 初入C#，有不正确欢迎大佬指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d763d04b8785660144d8782005b58904/" rel="bookmark">
			vue&#43;js&#43;html实现购物车总价求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;计算属性&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; 总价：{{prices}} &lt;/div&gt; &lt;script&gt; var app=new Vue({ el:'#app', data:{ //一般通过接口获取数据 package1:[ { name:'aaff', price:555, count:3 },{ name:'as', price:100, count:1 } ], package2:[ { name:'3', price:535, count:3 },{ name:'dds', price:145, count:1 } ], }, computed:{ prices:function(){ var p=0; for(var i=0;i&lt;this.package1.length;i++) p+=this.package1[i].price*this.package1[i].count; for(var i=0;i&lt;this.package2.length;i++) p+=this.package2[i].price*this.package2[i].count; return p; } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7225fbce128173974625e04bbb1f502b/" rel="bookmark">
			MapReduce＆YARN学习入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、MapReduce概述1.分布式计算框架- MapReduce2.MapReduce执行原理3.MapReduce的运行机制 二、YARN概述1.资源调度2.YARN的资源调度3.MapReduce和YARN的关系 三、YARN架构1.YARN核心架构1.1.YARN容器 2.YARN辅助架构2.1Web应用代理（Web Application Proxy）2.2JobHistoryServer历史服务器2.2.1JobHistoryServer历史服务器功能2.2.2JobHistoryServer配置 3.MapReduce的配置＆YARN的部署3.1部署说明3.2集群规划3.3MapReduce配置文件3.4YARN配置文件3.5分发配置文件3.6集群启动命令介绍 四、MapReduce＆YARN初体验1.集群启停命令1.1一键启动脚本1.2单进程启停 2.提交MapReduce任务到YARN执行2.1提交wordcount示例程序2.1.1报错记录2.1.1.1 org.apache.hadoop.yarn.exceptions.YarnException: Failed to submit application_1680768899138_0002 to YARN : root is not a leaf queue2.1.1.2 org.apache.hadoop.hdfs.BlockMissingException: Could not obtain block: BP-2110899144-100.66.8.128-1682069026390:blk_1073741825_1001 file=/input/words.txt No live nodes contain current block Block locations: Dead nodes: 2.1.2查看运行日志 2.2.提交求圆周率示例程序 一、MapReduce概述 1.分布式计算框架- MapReduce MapReduce是“分散-&gt;汇总”模式的分布式计算框架，可供开发人员开发相关程序进行分布式数据计算。
MapReduce提供了2个编程接口：
•Map
•Reduce
其中
•Map功能接口提供了“分散”的功能， 由服务器分布式对数据进行处理
•Reduce功能接口提供了“汇总（聚合）”的功能，将分布式的处理结果汇总统计
用户如需使用MapReduce框架完成自定义需求的程序开发
只需要使用Java、Python等编程语言，实现Map Reduce功能接口即可。
•注：MapReduce尽管可以通过Java、Python等语言进行程序开发，但当下年代基本没人会写它的代码了，因为太过时了。尽管MapReduce很老了，但现在仍旧活跃在一线，主要是Apache Hive框架非常火，而Hive底层就是使用的MapReduce。所以对于MapReduce的代码开发，课程会简单扩展一下，但不会深入讲解，对MapReduce的底层原理会放在Hive之后，基于Hive做深入分析。
2.MapReduce执行原理 假定有4台服务器用以执行MapReduce任务
可以3台服务器执行Map，1台服务器执行Reduce
3.MapReduce的运行机制 •将要执行的需求，分解为多个Map Task和Reduce Task
•将Map Task 和 Reduce Task分配到对应的服务器去执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7225fbce128173974625e04bbb1f502b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95b8a515c927ac54b60c8a65dbd5207/" rel="bookmark">
			遗传算法 (Genetic Algorithm, GA)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法（Genetic Algorithm， GA） 遗传算法简介类比达尔文进化论达尔文进化理论遗传算法对应概念基因型 (Genotype)种群 (Population)适应度函数 (Fitness function)选择 (Selection)交叉 (Crossover)突变 (Mutation)编码补充二进制编码格雷码浮点编码法符号编码法 遗传算法常用术语 遗传算法理论图式定理 (schema theorem) 遗传算法与传统算法的差异遗传算法的优缺点优点局限性 遗传算法应用场景遗传算法的基本特征遗传算法的组成要素算法的基本流程创建初始种群计算适应度选择、交叉和变异算法终止条件 其他精英主义 (elitism)小生境与共享 遗传算法实践（deap框架初体验）OneMax问题介绍遗传算法实践 遗传算法解的进化 遗传算法简介 遗传算法（Genetic Algorithm，简称GA）起源于对生物系统所进行的计算机模拟研究，是一种随机全局搜索优化方法，它模拟了自然选择和遗传中发生的复制、交叉(crossover)和变异(mutation)等现象，从任一初始种群（Population）出发，通过随机选择、交叉和变异操作，产生一群更适合环境的个体，使群体进化到搜索空间中越来越好的区域，这样一代一代不断繁衍进化，最后收敛到一群最适应环境的个体（Individual），从而求得问题的优质解。
简单的说 能够生存下来的往往不是最强大的物种，也不是最聪明的物种，而是最能适应环境的物种。
类比达尔文进化论 达尔文进化理论 遗传算法是类比自然界的达尔文进化实现的简化版本。
达尔文进化论的原理概括总结如下：
**变异：**种群中单个样本的特征(性状，属性)可能会有所不同，这导致了样本彼此之间有一定程度的差异
**遗传：**某些特征可以遗传给其后代。导致后代与双亲样本具有一定程度的相似性
**选择：**种群通常在给定的环境中争夺资源。更适应环境的个体在生存方面更具优势，因此会产生更多的后代
换句话说，进化维持了种群中个体样本彼此不同。那些适应环境的个体更有可能生存，繁殖并将其性状传给下一代。这样，随着世代的更迭，物种变得更加适应其生存环境。而进化的重要推动因素是交叉 (crossover) 或重组 (recombination) 或杂交——结合双亲的特征产生后代。交叉有助于维持人口的多样性，并随着时间的推移将更好的特征融合在一起。此外，变异 (mutations) 或突变(特征的随机变异)可以通过引入偶然性的变化而在进化中发挥重要作用。
遗传算法对应概念 遗传算法试图找到给定问题的最佳解。达尔文进化论保留了种群的个体性状，而遗传算法则保留了针对给定问题的候选解集合(也称为 individuals)。这些候选解经过迭代评估 (evaluate)，用于创建下一代解。更优的解有更大的机会被选择，并将其特征传递给下一代候选解集合。这样，随着代际更新，候选解集合可以更好地解决当前的问题。
基因型 (Genotype) 在自然界中，通过基因型表征繁殖，繁殖和突变，基因型是组成染色体的一组基因的集合。
在遗传算法中，每个个体都由代表基因集合的染色体构成。例如，一条染色体可以表示为二进制串，其中每个位代表一个基因：
种群 (Population) 遗传算法保持大量的个体 (individuals) —— 针对当前问题的候选解集合。由于每个个体都由染色体表示，因此这些种族的个体 (individuals) 可以看作是染色体集合：
适应度函数 (Fitness function) 在算法的每次迭代中，使用适应度函数(也称为目标函数)对个体进行评估。目标函数是用于优化的函数或试图解决的问题。
适应度得分更高的个体代表了更好的解，其更有可能被选择繁殖并且其性状会在下一代中得到表现。随着遗传算法的进行，解的质量会提高，适应度会增加，一旦找到具有令人满意的适应度值的解，终止遗传算法。
选择 (Selection) 在计算出种群中每个个体的适应度后，使用选择过程来确定种群中的哪个个体将用于繁殖并产生下一代，具有较高值的个体更有可能被选中，并将其遗传物质传递给下一代。
仍然有机会选择低适应度值的个体，但概率较低。这样，就不会完全摒弃其遗传物质。
交叉 (Crossover) 为了创建一对新个体，通常将从当前代中选择的双亲样本的部分染色体互换(交叉)，以创建代表后代的两个新染色体。此操作称为交叉或重组：
突变 (Mutation) 突变操作的目的是定期随机更新种群，将新模式引入染色体，并鼓励在解空间的未知区域中进行搜索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b95b8a515c927ac54b60c8a65dbd5207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558d19f9cb40a3487ac915fa0f39a8d7/" rel="bookmark">
			mongodb6.0版本：window安装mongdb和启动操作数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载
配置环境变量
将mongodb安装目录下的bin目录添加到系统环境变量path中
在mogodn安装目录下着的data目录中新建db目录
# 启动，将数据保存在指定路径 mongod --dbpath D:\mongodb\data\db 可以在返回的信息中查询到端口号27017
浏览中如果出现以下界面则成功启动。
另启一个cmd窗口，操作数据库
查看版本
输入mongo命令显示不是内部指令，因为MongoDB6.0版本需要做以下操作
进入网址进行下载：https://www.mongodb.com/try/download/shell
将bin添加到系统环境变量中
操作数据库 show dbs; #查看数据库 use egg_db; # 使用数据库，不存在则创建 //switched to db egg_db db;# 查看当前使用的数据库 //egg_db db.createCollection('user_table'); #创建集合，即数据表 //{ ok: 1 } #插入一条数据 db.user_table.insert({name: 'Yan',id:'20230423164226',tel:'123456789',role:2}); DeprecationWarning: Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite. { acknowledged: true, insertedIds: { '0': ObjectId("6444ef9a4d3f827294f02cee") } } db.user_table.find();#查询数据 [ { _id: ObjectId("6444ef9a4d3f827294f02cee"), name: 'Yan', id: '20230423164226', tel: '123456789', role: 2 } ] #插入一条数据 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558d19f9cb40a3487ac915fa0f39a8d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e71c89b0657086a94379889275baef9/" rel="bookmark">
			SpringCloud3.0&#43;Sa-token&#43;Gateway网关实现鉴权和token登录拦截功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本： Springboot3.0.5以及对应的Springcloud，SpringcloudAlibaba依赖nacos 2.2.0，sa-token1.34.0，Mysql8.0 前提： 我这边是主要是对管理员进行鉴权的，所以划分了管理员以及网关服务，而sa-token的统一鉴权是在网关服务里面设计的。Sa-token官方网址：Sa-Token 父依赖： &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;!-- springboot 3 对应mybatis 3.0.0以上，否则会报错--&gt; &lt;mybatis-spring-boot-starter.version&gt;3.0.0&lt;/mybatis-spring-boot-starter.version&gt; &lt;spring-cloud-alibaba.version&gt;2022.0.0.0-RC1&lt;/spring-cloud-alibaba.version&gt; &lt;spring.cloud.dependencies&gt;2022.0.1&lt;/spring.cloud.dependencies&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.26&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.dev33&lt;/groupId&gt; &lt;artifactId&gt;sa-token-dao-redis-jackson&lt;/artifactId&gt; &lt;version&gt;1.34.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e71c89b0657086a94379889275baef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf7f72b13051a836831dadc77206f32/" rel="bookmark">
			JavaScript 数字精度丢失的问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、场景复现 一个经典的面试题
0.1 + 0.2 === 0.3 // false
为什么是false呢?
先看下面这个比喻
比如一个数 1÷3=0.33333333......
这是一个除不尽的运算，3会一直无限循环，数学可以表示，但是计算机要存储，方便下次再使用，但0.333333...... 这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，这么存储后再取出时自然就出现精度丢失问题。
二、浮点数 “浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储
我们也可以理解成，浮点数就是小数
在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码
这样的存储结构优点是可以归一化处理整数和小数，节省存储空间
对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了
而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下：
其中，a的值为0或者1，e为小数点移动的位置
举个例子：
27.0转化成二进制为11011.0 ，科学计数法表示为：
前面讲到，javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特
64位比特又可分为三个部分：
符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023
尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零
如下图所示：
举个例子：
27.5 转换为二进制11011.1
11011.1转换为科学记数法
符号位为0(正数)，指数位为4+，1023+4，即1027
因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即：1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`
所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示
0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaf7f72b13051a836831dadc77206f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7309d047a41d97b093f89395347e441/" rel="bookmark">
			MYSQL 查询表中字段信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种: 表中所有字段信息
select COLUMN_NAME,COLUMN_COMMENT from information_schema.columns where table_name='表名' 第二种: 查询指定字段信息
select COLUMN_NAME,COLUMN_COMMENT from information_schema.columns WHERE column_name='字段名' and table_name = '表名' 第三种: 查询表信息与字段信息
SELECT * FROM information_schema.columns WHERE COLUMN_NAME='字段' and table_name = '表名'; SELECT * FROM information_schema.columns WHERE table_name = '表名'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1438d1b38dc2e793ac71aa8908daa8/" rel="bookmark">
			JS对Json数组进行抽取 获取key: “value“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章不是拿key或value 是抽取需要的 key: “value” 【必须是单一数组 若是多组数据需要for循环】
// row 是json串 !!!
一、我有一个单一的json【row】 只要 id 和 appStatus 且分开成新数组
let list = []; for (var key in row) { var temp = {} if (key == "id") { temp.id = row[key] list.push(temp) } if (key == 'appStatus') { temp.appStatus = row[key] list.push(temp) } } console.log(list) 二、我有一个单一的json【row】 只要 id 和 appStatus 不分开在一起
方式1：row[0] 括号里面用数字获取对应的key: “value”
方式2：自定义
var satusJson = { "id": row.id, "appStatus": row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1438d1b38dc2e793ac71aa8908daa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74117e8b335aa8e2b90d608780a938e3/" rel="bookmark">
			NOMA（非正交频分多址接入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NOMA（Non-Orthogonal Multiple Access）技术与FDMA，TDMA和CDMA等OMA技术有着本质的不同，在 NOMA 中，每个用户都在相同的频段和同一时间操作，值得注意的是其分辨不同用户的方式主要是按照功率等级，NOMA的基本思想是以增加接收机复杂度作为最终代价来支持用户之间的非正交资源分配，从而达到支持的用户数更多的目的，也因此分离非正交信号为一个必须的手段。
NOMA主要采用叠加编码技术（superposition coding）和SIC（successive interference cancellation）来实现让所有用户使用相同的频谱。
下面首先简略介绍一下叠加编码技术：
在一个典型的叠加编码系统中，发送端将按照预定的功率分配策略，为每个用户分配不同的功率等级。信号具有较高功率的用户将被认为是强用户，而信号具有较低功率的用户将被认为是弱用户。在发送端，所有用户的信号将按照功率等级叠加在一起，并作为一个复合信号发送。
下图为OFDMA与NOMA频谱资源使用的辨析（UE1和UE2表示两个用户设备）：
其次是SIC连续干扰消除技术：
在发送器端，所有单独的信号的讯息都会叠加成为一个波形，而在接收器中则需要SIC这个技术来助个解码信号，直到找到所需的信号为止。如图，以不同颜色表示的三个信号分别被叠加在发送器端上，而接收器端所接收的信号包括了这三个信号的叠加
SIC 解码的第一个信号是最强的，而其他信号是干扰信号。然后从接收信号中减去第一个解码信号，如果解码完美，则可以准确获得包含其余信号的波形。SIC 重复该过程，直到找到所需的信号。SIC 的成功取决于迭代步骤中信号的完美消除。
所以发射机应该准确地分配用户信息波形之间的功率并将它们叠加。上行链路和下行链路信道的功率分配方法不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63770a10cebb47cc68e6d1812dd9a1a/" rel="bookmark">
			ubuntu开机自启程序设置教程（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu开机自启程序设置教程（以自启clash为例） 参考以下官方教程
https://github.com/Sitoi/SystemdClash
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2922fa4f9f7fcfa5e2bbfa494e7de4/" rel="bookmark">
			oracle-超全的多表查询连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle-聚合函数
Oracle-日期/时间函数
一、简述 1、两个表的连接，是通过将一个表中的一列或者多列同另一个表中的列连接而建立起来的。用来连接两张表的表达式组成了连接条件。当连接成功后，第二张表中的数据就同第一张表连接起来了，并形成了复合结果集。
2)、有5种基本类型的的连接，inner，outer，natural，cross连接，自连接。
SQL的标准语法： select table1.column,table2.column from table1 [inner | left | right | full ] join table2 on table1.column1 = table2.column2;----说明inner join 表示内连接；left join表示左外连接；right join表示右外连接；full join表示完全外连接；on子句用于指定连接条件。 注意：
若使用from子句指定内、外连接，则需要使用on子句指定连接条件; 若使用（+）操作符指定外连接，则必须使用where子句指定连接条件。
二、说明与例子
2.1、内连接 inner join 特点：只有满足条件的数据。和用select查询多表(使用where)是一样的效果，所以内连接用地很少。（inner join可简写为join）
内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。 1、等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复属性。（区别于自然连接）
2、不等连接：在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt; 和 &lt;&gt;。 teacher 和 student 表
select * from student s inner join teacher t on s.teacheid=t.teacheid; select * from student s join teacher t on s.teacheid=t.teacheid;--使用多表查询select * from student s,teacher t where s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2922fa4f9f7fcfa5e2bbfa494e7de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156a4a8aa5f1692e1b31136d427a5651/" rel="bookmark">
			MySQL的索引与SQL优化策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 存储引擎常见的存储引擎 索引索引结构B+Tree的优点索引分类索引语法explain执行计划索引的使用原则最左前缀法则范围查询索引列进行运算操作字符串不加引号模糊查询or连接的条件数据分布影响 覆盖索引前缀索引索引的设计原则 SQL优化insert优化主键优化order by优化group by优化limit分页查询优化count优化update优化 存储引擎 存储引擎就是存储数据，建立索引，更新/查询数据等技术的实现方式，存储引擎是基于表而不是基于数据库的（不同的数据库表可以选择不同的存储引擎），所以存储引擎也可被称为表类型
mysql5.5之后，默认存储引擎是InnoDB
使用show关键字查看建表情况
show create table student; 那如何在建表的时候指定存储引擎呢？
create table student( id int, name varchar(10) )ENGINE=INNODB; 查看当前数据库支持的存储引擎
show engines; 常见的存储引擎 InnoDB存储引擎
一种兼顾高可靠性和高性能的存储引擎，MySQL5.5之后，InnoDB是默认的存储引擎
特点：
增删改语句（DML）遵循ACID，支持事物行级锁，提高并发访问性能支持外键约束，保证数据的完整性和正确性 InnoDB会为每张表都生成一个表空间文件xxx.ibd，存储表结构，数据，索引
MyISAM存储引擎
是MySQL早期的默认存储引擎
特点：
不支持事务，不支持外键支持表锁，不支持行级锁访问速度快 Memory存储引擎
表数据存储在内存中，会受到断电，硬件问题的影响，这些表只能当作临时表和缓存使用
特点：
数据存储在内存中，访问速度快支持hash索引（默认） InnoDB与MyISAM区别
InnoDB支持事务，支持外键，支持行级锁MyISAM不支持事务，支持表锁，不支持外键 索引 索引就是一种帮助我们快速高效获取数据的有序的数据结构
例如这样一条sql：
select * from student where age = 20; 在无索引的情况下，会依次遍历整张表直到找到全部复合条件的
在有索引的情况下，会很快速的找到复合条件的全部数据
优点：
提高查询数据的效率，降低数据库IO的开销 提高了数据排序效率，降低CPU消耗 缺点：
索引需要用一个数据结构来维护，本身是需要占用空间的降低了表的更新效率，因为插入，删除，修改的同时也要更新索引的结构 索引结构 MySQL的索引是在引擎层实现的，也就是不同的引擎有不同的索引结构
B+Tree结构：最常见的索引类型，大部分引擎都支持B+Tree索引Hash索引：底层使用哈希表实现，可精确匹配列的查询，但是不支持范围查询（只有Memory存储引擎支持）Full-text（全文索引）：是一种通过建立倒排索引，快速匹配文档的方式 二叉树
但是如果插入元素的时候就是按顺序插入，该树就变为单支树
此时查询性能大大降低，大数据量情况下层级较深，检索速度慢
为了解决上述单分支情况，我们可以使用红黑树（自平衡的二叉树），但是红黑树一个结点也只有两个分支是一个二叉树，当数据量大的时树的高度也会很深，导致检索速度慢
B-Tree
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/156a4a8aa5f1692e1b31136d427a5651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c014c79a6cafa603c0367d798e7479/" rel="bookmark">
			说说“集成平台”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成平台（Integration Platform）是一个软件系统或者基础架构，用于实现不同应用、业务流程和数据源之间的互联、集成和协作。它可以将各种应用程序、数据源和服务连接起来，实现数据共享、通信协作和工作流自动化等功能，从而提高企业的数字化转型效率和数据利用价值。
集成平台需要实现以下功能：
连接不同的应用程序和系统：集成平台需要支持连接不同类型的应用程序和系统，包括云端和本地应用，以及不同的数据源。
实现数据转换和映射：不同的应用程序和系统之间通常使用不同的数据格式和结构，因此需要进行数据转换和映射，以使得数据能够在各个系统之间正常流通。
支持工作流程设计和调度：集成平台应提供可视化的工作流程设计工具，使得开发人员可以快速搭建集成流, 并支持执行和调度。
提供安全性保障：集成平台需要具备安全性保障机制，例如身份认证、访问控制等，以确保数据在传输和处理过程中的安全性。
提供监控和故障排除功能：集成平台需要提供监控功能，以便用户可以实时监测集成流运行状态，并及时发现和修复故障。
支持消息传递：集成平台需要支持消息传递机制，以便将信息从一个应用程序或系统发布到其他应用程序或系统。
多种集成方式：集成平台应支持多种集成方式，例如点对点集成、服务总线、数据集线器等，以满足不同场景和需求的集成要求。
数据清洗和质量控制：集成平台需要支持数据清洗和质量控制功能，以确保数据的准确性和一致性。
业务流追踪：集成平台应该提供业务流追踪功能，以便开发人员和管理员可以跟踪业务流程的实际执行情况，并做出相应优化和调整。
可扩展性：集成平台需要具备良好的可扩展性，以应对未来业务增长和技术变革带来的挑战。
提供数据分析和报告功能：集成平台应该提供数据分析和报表功能，以帮助用户深入了解数据和业务流程的情况。
实现开放和分类别名体系：为不同的互联网组件提供标准的分类别名和开放的命名空间，以使其易于发现和使用。
以上是国内几个较为知名的集成平台产品，它们都拥有一定的技术优势和市场渗透力，能够为企业在数字化转型中提供可靠的集成解决方案。
总的来说，集成平台需要提供丰富的功能和工具，以支持企业在数字化转型过程中的各种集成需求，从而有效地提高业务效率和协同能力。
目前市场上成熟的集成平台包括以下几个方面的产品：
MuleSoft Anypoint Platform：该平台提供全面的集成能力，包括微服务、API 管理、数据集成和文件传输。MuleSoft 基于开源 ESB 架构，可以将现有的系统、应用程序和数据源连接起来。
IBM Cloud Pak for Integration：这是一种企业级混合集成平台，提供了 API 管理、事件驱动架构以及数据集成等功能。IBM Cloud Pak for Integration 可以帮助企业加快数字化转型。
Dell Boomi：这是一种基于云的集成平台，提供了可视化的集成开发环境，支持多种连接方式和数据格式。Dell Boomi 可以轻松地将企业现有系统和应用程序连接起来。
Oracle Integration Cloud：该平台提供全球范围内的云集成解决方案，包括 API 管理、企业集成和流数据处理等功能。Oracle Integration Cloud 可以轻松地连接企业的各个系统和应用程序。
Google Cloud Pub/Sub：这是一种基于云端的消息传递服务，可以帮助企业实现异步消息传递和事件驱动型的应用程序开发。
Microsoft Azure Integration Services：该平台提供了 API 管理、企业集成和 B2B 集成等功能，同时还提供了丰富的连接器和预定义的工作流程。
国内目前较为知名的集成平台产品包括：
RestCloud iPaaS：正如之前提到的，RestCloud iPaaS 是国内首款专注于私有化部署的全域集成平台，实现了服务集成、数据集成、设备集成、saas 集成和消息集成等功能。同时，该平台提供了可视化的工作流程设计界面，使得开发者可以方便地进行集成流搭建和管理。
Huawei Cloud ROMA：ROMA 是华为云推出的企业级集成平台，提供了 API 管理、数据集成、工作流程设计等功能。同时，华为云也提供了丰富的连接器和多种集成方式支持，能够满足不同场景和需求的集成要求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c014c79a6cafa603c0367d798e7479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6909c9aae10aee54d1c44b2ae56ec40/" rel="bookmark">
			LDR6328 PD QC诱骗取电用电SINK端全协议芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着无线充电技术的普及，5W无线充电的功率已经无法满足消费者对充电速度的需求，基于Qi EPP标准的10W，15W快速无线充电成为了必备技术。但是工程师在设计过程中，往往会遇到一个问题，那就是电源诱骗。需要去识别适配器的类型，QC2.0，QC3.0，PD2.0，PD3.0等，然后再去选择合适的电压，进行调控。让无线充的工程师不得不在处理负载的Qi兼容性的同时，还要分心去解决复杂的电源输入系统兼容性问题。
有没有办法让无线充的工程师更专注于无线充本身的效率及兼容性问题，而不用再去理会电源问题。乐得瑞科技近期就推出了一颗体积小，兼容性好的PD/QC电源诱骗芯片。让无线充电工程师的电源烦恼一扫而光。
LDR6328是乐得瑞科技针对无线快充而推出的电源诱骗芯片。可以支持QC2.0/QC3.0/PD2.0/PD3.0协议的电压诱骗。支持从 USB PD 和 QC 协议的适配器取电，然后供电给设备。比如可以配置适配器 输出需要的功率，给无线充电器设备供电。具有BPP和EPP两种模式，第2引脚外部下拉电阻到地表示EPP（扩展功率）诱骗适配器按照优先顺序输出 12v、9v、5v，没有就选择下一个，直到输出支持 的电压。引脚悬空表示BPP（基准功率）诱骗适配器优先输出 9v，没有就是 5v。
乐得瑞科技推出针对无线快充电源管理的芯片LDR6328，可以针对Qi协议中的EPP和BPP模式，选择最合适供电电压，为无线充电系统提供快充模式的电源供应。让无线充电的工程师，彻底解决电源管理的烦恼，安心做好无线充电本身的设计。
LDR6328 的输入端为 USB Type-c 母座，连接适配器。CC1 和 CC2 用于 USB PD 协议通信，D+和 D-用于 QC 通信。LDR6328 也可用于不支持 USB PD 和 QC 协议的适配器。 快充协议优先级为 PD&gt;QC，即首选 PD，如果不支持 PD 就选择 QC。
参考原理图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858f6e945f86671a69756783ea098cf3/" rel="bookmark">
			untiy发布webgl开发记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Unity3d并导入unitypackage 版本选择：
untiy发布webgl经测试
2020版本系列的PC端网页打开都会报错，不能正常打开；
2019系列的发布后PC端可以正常打开并运行，一切正常；但手机端除了火狐浏览器可以正常进入体验，其他浏览器和直接从微信打开链接都会出现黑屏，无法正常进入体验。
2018系列的可以正常发布PC端和手机端，运行也一切正常。
安装：安装的时候要把WebGL选上。
开发注意事项： 1、刚开始的build and run默认是不能选的，要先按Switch settings，然后再选。新建一个项目后，默认平台是PC，要想开发其他平台的项目最好一开始就选择自己想要的平台点击Switch settings进行平台的转化，否则如果项目过大到后期开发完成后再进行转化会非常耗时；
2、webgl不支持Arial字体，开发中所有文字均需开发者自己导入一个字体库，并选择已导入的字体库；
3、发布了WebGL之后，网页运行有时候发现灯光会变暗，因为WebGL不支持实时光照的问题；所以我们将光照可以做成LightingMap 使用，可以缓 解这一问题。
4、WebGL的渲染和Unity的渲染差异，部分材质是不可以用的；开发时多做测试，对于显示不出来的材质进行更换&amp;修改Shader。
5、一些图片UI会在打包webGL之后在网页中会显示模糊；美术制作UI时候分辨率&amp;比例调整好。
6、尽量避免使用第三方插件（有些插件可以解决Bug或者大大提高效率，我们视情况而定）。
7、Unity自带的视频播放器在开发webGL时候是不能用的；用AVpro视频插件来代替Unity自带播放器。
8、场景加载实现异步加载PC端适用的webgl不适用；通过协程方法来实现异步加载；
IEnumerator Start() { AsyncOperation scene = Application.LoadLevelAsync(""); yield return scene; Debug.Log("加载完毕"); } 9、对于场景中不同距离的模型我们采用LOD进行场景优化；LOD：Level Of Details多层次细节，unity中自带的一个组件，在场景中添加&amp;设置即可。
10、在开发过程中由于WebGL的资源限制，我们要和数据库进行数据传输时候不能直接访问数据库；通过JS作为中转站来访问（JS页面），我们可以使用Application.ExternalCall()来调用，可以传递一些参数和信息。
11、Getcomponent Gameobject.find（）等这些方法尽量少用，而且千万不要放在Update中循环执行
12、Update里面的逻辑尽量不要太复杂
13、WebGL 端无法支持任何多线程代码，因为 JavaScript 没有多线程的实现，C# 端使用的类似 System.Threading 等库最终都不会被编译成相应的 js 代码。
14、WebGL 端无法支持using System.IO;
15、WebGL是一个AOT(静态编译)平台，所以它不允许动态生成的代码中使用system.reflection.emit。这是对所有其他il2cpp平台，如iOS，和大多数控制台是相同的。 发布设置： 1、Development Build不要选，下面两个选项选上（先选了Development Build，把下面两个选项选上，再剔除Development Build）。
发布： 弄好之后发布，打包的每一级目录必须为全英文，不能出现中文；项目的路径和名字也为全英文；
发布了之后，文件夹中会有三样东西：
IIS部署 部署参考链接完整流程；创建完网站后本地就可以访问了，内网访问，不能外网访问；
MIME类型添加： .json text/json 、 .unity3d application/octet-stream、.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858f6e945f86671a69756783ea098cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75e1ce9cffc695e75536e6d0771a40c/" rel="bookmark">
			Java23种设计模式之策略模式【普通写法以及spring中的写法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 设计模式简介策略模式的简介普通写法案例基于注解式改造的案例优缺点策略模式的使用场景 设计模式简介 将设计者的思维融入大家的学习和工作中，更高层次的思考！
• 创建型模式：
– 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
• 结构型模式：
– 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
• 行为型模式：
– 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。
本次文章介绍的是策略模式。
策略模式的简介 策略设计模式是一种行为型设计模式，它允许在运行时根据不同的情况选择算法或策略。
这种模式提供了一种灵活的方法来改变算法或策略，而无需修改代码。
定义一系列算法，封装每个算法，并使他们可以互换，不同的策略可以让算法独立于使用它们的客户而变化。 以上定义来自设计模式之美
这个模式主要由三个角色组成：Context（上下文）、Strategy（策略）和 ConcreteStrategy（具体策略）。
Context（上下文）：它是包含了一个Strategy接口的引用，用来调用具体策略的方法。上下文可以根据需要改变策略。Strategy（策略）：它是一个接口，定义了一个算法族，这些算法可以相互替换。具体策略可以实现这个接口，这样就可以提供不同的实现方式。ConcreteStrategy（具体策略）：它是具体的策略实现，实现了策略接口中定义的方法。每个具体策略都实现了一种算法。 普通写法案例 假设有一个在线支付系统，支持多种支付方式，如支付宝、微信支付、银联支付等。为了方便用户选择支付方式，系统提供了一个支付方式选择页面，用户可以在该页面选择一种支付方式并进行支付。
为了实现这个功能，可以采用策略设计模式。具体实现过程如下：
1、定义支付策略接口
/** * 策略接口（对扩展开放） */ public interface PaymentStrategy { // 支付 void pay(double amount); // 或者其他业务... } 2、定义支付方式的具体实现类，如支付宝、微信支付和银联支付
/** * 支付宝支付策略 */ public class AliPayStrategy implements PaymentStrategy { @Override public void pay(double amount) { // 调用支付宝支付接口 // ... System.out.println("使用支付宝支付：" + amount + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a75e1ce9cffc695e75536e6d0771a40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27216ee422a6433d22a0cd8fffb77e9d/" rel="bookmark">
			electron安装【纯详细版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、首先node.js的下载二、node.js安装1.检查node.js和npm是否安装成功2.读入数据 总结 前言 Electron是一个使用JavaScript构建桌面应用程序的框架， HTML 和 CSS。通过将 Chromium 和 Node.js嵌入到其 二进制，Electron允许您维护一个JavaScript代码库并创建 在 Windows、macOS 和 Linux 上运行的跨平台应用程序 — 无需本机开发 需要经验。
Node.js 可以做什么？
轻量级、高性能的 Web 服务前后端 JavaScript 同构开发便捷高效的前端工程化 一、首先node.js的下载 根据自己电脑系统及位数选择，我的电脑是Windows系统、64位、想下载稳定版的.msi（LTS为长期稳定版）这里选择windows64位.msi格式安装包。
node.js官网下载
二、node.js安装 直接将下载后的安装包安装即可。
安装完成！
1.检查node.js和npm是否安装成功 代码如下（示例）：
node -v npm -v 建议把npm的仓库切换到国内taobao仓库，
注册cnpm命令，如下
npm install -g cnpm --registry=https://registry.npm.taobao.org 安装electron
cnpm install -g electron 验证electron安装，我自己首先使用的electron -v验证，但是我的电脑这个操作命令不支持，所以换了以下命令。
npx electron -v 安装成功，启动electron。
npx electron 2.读入数据 总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3131b31e851cfc887cb31700bc886e/" rel="bookmark">
			PTA Python实验1 熟悉python环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
7-1 Hello World
7-2 介绍一下你自己
7-3 美化姓名
7-4 半圆弧的长度
7-5 输出工资表
7-6 华氏温度到摄氏温度的转换
7-1 Hello World 这是学习每种程序设计语言的第一个实例。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬
输出Hello World，注意大小写。
输入格式: 无
输出格式: Hello World
输入样例: 在这里给出一组输入。例如：
输出样例: 在这里给出相应的输出。例如：
Hello World print ("Hello World") 7-2 介绍一下你自己 作者 李体新
单位 保定学院
本题目要求输入你的姓名、年龄和籍贯，然后输出一个自我介绍的字符串。
输入格式: 输入你的姓名、年龄和籍贯。
输出格式: 对每一组输入，在一行中输出一个自我介绍的字符串。
输入样例: 小明 20 北京 输出样例: 大家好！我是小明，今年20岁，来自北京。 a=input() b=input() c=input() print("大家好！我是{}，今年{}岁，来自{}。".format(a,b,c)) 7-3 美化姓名 作者 马杨珲
单位 浙江科技学院
输入姓名，美化后输出。
输入格式: 输入一个姓名，如“张无忌”、“哪吒”、“Fiona”
输出格式: 在姓名的左右各加上一个星号，如“*张无忌*”、“*哪吒*”、“*Fiona*”
输入样例: 在这里给出一组输入。例如：
Tom 输出样例: 在这里给出相应的输出。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc3131b31e851cfc887cb31700bc886e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e517d4af928a1c77884fed3a2ef166/" rel="bookmark">
			VMware虚拟机安装win11教程.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机安装win11 前期工作：1.安装VMware；2.下载win11镜像。需要安装包和系统激活工具评论区留言。 打开VMware workstation，在主页中点击创建新的虚拟机。
选择自定义（高级），并点击下一步
选择最高版本的workstation 16.x，并点击下一步
选择稍后安装，并点击下一步
客户机操作系统根据自己的操作系统进行选择，我的操作系统是window11，所以在这里选择Microsoft Windows；版本(V)目前最高版本只有window10，我们选择它，并点击下一步。
虚拟机名称可以自己设置，我这里起的名称是Win11（方便以后区分其他版本操作系统），并选择存放虚拟机的路径（可自定义），我这里存放的路径是E:\Program Files (x86)\VM16\win11，点击下一步
选择UEFI，点击下一步
设置处理器数量（注意不要超过本机处理器数量，否则虚拟机可能无法运行），我这里选择2个处理器数量，每个处理器的内核数量为3，点击下一步。
设置虚拟机内存大小（建议设置本机内存的1/3或1/4），我这里选择4GB，点击下一步
接着选择桥接模式，点击下一步。
选择LSI Logic SAS，点击下一步
选择NVMe，点击下一步
创建新的虚拟机，点击下一步
安装win11会占用30~40个G，所以这里分配磁盘大小建议在80到100，我这里选择80；选择将虚拟机磁盘拆分成多个文件，点击下一步
文件的存放位置我选择刚才创建的文件夹，E:\Program Files (x86)\VM16\win11\Win11.vmdk，点击下一步
进入自定义硬件，
点击新CD/DVD选项，在连接下面选择使用ISO映像文件，找到自己提前下载好的win11系统，设置完成之后点击关闭，返回到新建虚拟机向导界面中点击完成
点击编辑虚拟机设置
进入虚拟机设置后，第一步点击选项界面，第二步点击访问控制，第三步点击加密，设置自己想设置的密码并点击加密。
设置完成后点击硬件界面，选择添加，点击可信平台模块，并点击完成，最后点击确认。
回到VMware 主页面，点击开始此虚拟机
切记！！！！当虚拟机显示press any key to boot from CD or DVD时候要立马按下回车键，否则虚拟机进不去。
点击下一步，现在安装。
点击“我没有产品秘钥”
根据自己想要安装的版本，点击下一步
选择接受协议，下一步
选择自定义安装
如果需要给新装的win11虚拟机分盘，选择驱动器0，点击新建并选择分配的磁盘空间大小，我这里不打算分盘，所以直接点解下一页。
win11安装中…
安装完成后点击是
到此win11安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b62ec1b03b62b548c1accd54d50f47d/" rel="bookmark">
			Linux笔记（二）重定向详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.标准输入，标准输出和标准错误 到目前为止，我们使用过的很多程序生成了不同种类的输出。这些输出通常包含两种类型。一种是程序运行的结果，即该程序生成的数据；另一种是状态和错误信息，表示当前程序的运行状况。比如输入ls命令，屏幕上将显示它的运行结果以及它的相关错误信息。
与UNIX“一切都是文件”的思想一致，类似ls的程序实际上把它们的运行结果发送到了一个称为标准输出（standard output,通常表示为stdout）的特殊文件中，他们的状态信息则发送到了另一个称为标准错误（standard error,通常表示为stderr）的文件中。默认情况下，标准输出和标准错误都将被链接到屏幕上，并且不会被保存在磁盘文件中。
另外，许多程序从一个称为标准输入（standard input,表示为stdin）的设备来得到输入。默认情况下，标准输入连接到键盘。
I/O重定向功能可以改变输出内容发送的目的地，也可以改变输入内容的来源地。通常来说，输出内容显示在屏幕上，输入内容来自于键盘。但是使用I/O重定向功能可以改变这一惯例。
（1）标准输出重定向 I/O重定向功能可以重新定义标准输出内容发送到哪里。使用重定向操作符“&gt;”，后面接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上。
为什么我们需要这么做呢？它主要用于把命令的输出内容保存到一个文件中。比如，我们可以按照下面的形式把ls命令的输出保存到ls-output.txt文件中，而不是输出到屏幕上。
ls -l /sur/bin &gt; ls-output.txt 这里我们将创建/usr/bin目录的一个长列表信息，并把这个结果输出到ls-output,txt文件中。检查下该命令被重定向的输出内容。
这是一个不错的大型文本文件。如果使用less命令查看这个文件，我们可以看到ls-output.txt文件确实包含了ls命令的执行结果。
现在我们重复重定向测试，但是这次做一点变化。我们把目录名称换成一个不存在的目录。
我们会收到一个错误信息。因为我们指定的是一个不存在的目录/bin/usr，所以这个错误信息是正确的。但是为什么这个错误信息显示在屏幕上，而不是重定向到ls-output.txt文件中呢？原因是ls程序并不会把它运行的错误信息发送到标准输出文件中。而是与大多数写的很好的UNIX程序一样，它把错误信息发送到标准错误文件中。因为我们只重定向了标准输出，并没有重定向标准错误，所有这个错误信息仍然输出到屏幕上。
当前这个文件大小为零！
这是因为当使用重定向符“&gt;”来重定向标准输出时，目的文件通常会从文件的开头部分重新改写。由于ls命令执行后没有输出任何内容，只是显示一条错误信息，所以重定向操作开始重新改写这个文件，并在出现错误的情况下停止操作，最终导致了该文件内容被删除。
事实上，如果我们需要删除一个文件内容（或者创建一个新的空文件），可以采用这种方式。
&gt; ls-output.txt 仅仅使用重定向符，并在它之前不加任何命令，就可以删除一个已存在的文件内容或者创建一个新的空文件。
那么，我们如何能够不从文件的首位置开始覆盖文件，而是从文件的尾部开始添加输出内容呢？
我们可以使用“&gt;&gt;”来实现，比如：
ls -l /usr/bin &gt;&gt; ls-output.txt 使用重定向符“&gt;&gt;”将使的输出内容添加在文件的尾部。如果这个文件并不存在，将与操作符“&gt;”的作用一样创建这个文件。
重复执行这条命令三次，系统将最终生成一个为原来三倍大小的输出文件。
（2）标准错误重定向 标准错误的重定向并不能简单的使用一个专用的重定向符实现。要实现标准错误的重定向，不得不提到它的文件描述符（file descriptor）。一个程序可以把生成的输出内容发送到任意文件流中。如果把这些文件流中的前三个分别对应标准输入文件，标准输出文件和标准错误文件，那么shell将在内部用文件描述符分别索引它们为0,1和2。shell提供了使用文件描述符编号来重定向文件的表示法。由于标准错误等同于文件描述2，所以可以使用这种表示法来重定向标准错误。
ls -l /bin/usr 2&gt; ls-error.txt 文件描述符“2”紧放在重定向符之前，将标准错误重定向到ls-error.txt文件中。
（3）将标准输出和标准错误重定向到同一个文件 在许多情况下，我们会希望把一个命令的所有输出内容都放在同一个独立的文件中。为此，我们必须同时重定向标准输出和标准错误。有两种方法可以满足要求。
第一种是传统的方法，在旧版本的shell中使用。
ls -l /bin/usr &gt; ls-output.txt 2&gt;&amp;1 使用这个方法，将执行两个重定向操作。首先重定向标准输出到ls-output.txt文件中，然后使用标记符2&gt;&amp;1把文件描述符2（标准错误）重定向到文件描述符1（标准输出）中。
注意：这些重定向操作的顺序是非常重要的。标准错误的重定向操作通常发生在标准输出重定向操作后，否则它将不起作用。在上面的例子中，&gt; ls-output.txt 2&gt;&amp;1 把标准错误重定向到ls-output.txt文件中，但是如果顺序发生改变为 2&gt;&amp;1 &gt; ls-output.txt，那么标准错误将会重定向到屏幕上。
第二种方式更为高效
ls -l /bin/usr &amp;&gt; ls-output.txt ***在这个例子中，只使用一个标记符“&amp;&gt;”就把标准输出和标准错误都重定向到了ls-output.txt文件中。
（4）处理不想要的输出 有时候“沉默是金”，命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。系统提供了一种方法，即通过把输出重定向到一个称为/dev/null 的特殊文件中来实现它。这个文件是一个称为位桶（bit bucket）的系统设备，它接受输入但是不对输入进行任何处理。以下命令可以用来抑制（即隐藏）一个命令的错误信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b62ec1b03b62b548c1accd54d50f47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4cf04cd3dd1bd63e975b38c8955c4c/" rel="bookmark">
			自制ST-LINK V2 ，ST-LINK 固件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：
1.自己制作一个ST-LINK V2
2.学会使用 flash_loader_demo_v2.8.0 通过MCU的UART口烧录程序。
目录
一.步骤：
二.材料：
三.操作步骤
3.1 : ST LINK V2 原理图，接口部分
3.2 ：升级ST LINK V2 的固件
四：连接编译器下载程序
参考资料：ST-LINK 接口定义
相关固件和原理图可以到以下链接下载：
https://download.csdn.net/download/yutian0606/87713350
一.步骤： 1：改现成的 STM32F103C8T6 最小系统核心板，核心板 PB12 与 PB14之间用 100R电阻连接。
2：给核心板烧录 固件 V2.J16.S4.hex ，这个版本较老，需要再升级。
3：升级 ST LINK V2 的固件。
4：工具，需要电烙铁，USB 转 TTL 工具。
二.材料： 硬件：STM32F103C8T6 最小系统板一个,用来改 ST LINK V2 ,省去自己打PCB，焊接的麻烦，某宝12RMB左右买一个包邮。
软件：flash_loader_demo_v2.8.0，用来烧录核心板的第一版 固件，通过uart串口烧录。
2：STM32 ST-LINK Utility ,用来升级ST LINK V2 的固件
软件包：STM32 ST-LINK Utility v4.2.0 setup
ST LINK V2 资料：包含
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4cf04cd3dd1bd63e975b38c8955c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae96b279bb36f6dc0219e66b98ffa4c/" rel="bookmark">
			ROS-kinetic中Gazebo中的机械臂仿真报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.警告（其实是错误，但也要解决）：
[WARN] [1682069601.434351, 0.000000]: Controller Spawner couldn't find the expected controller_manager ROS interface.
错误原因：应该是Gazebo的lib库有问题。
解决办法：卸载gazebo7，重装gazebo8（因为是kinetic版本，就装了8）。
查看gazebo版本：dpkg -l | grep gazebo
卸载gazebo7：sudo apt-get remove gazebo7 gazebo7-common gazebo7-plugin-base libgazebo7:amd64 libgazebo7-dev:amd64
安装gazebo8：sudo apt-get install gazebo8
安装依赖：sudo apt-get install libgazebo8-dev
安装gazebo-ros-conrtol：sudo apt-get install ros-kinetic-gazebo8-ros-pkgs ros-kinetic-gazebo8-ros-control
2.解决了上面的错误后，又出现了新的错误，说插件找不到，安装就行了
解决办法：
sudo apt-get install ros-kinetic-joint-state-controller
rospack profile
sudo apt-get install ros-kinetic-position-controllers
====================================================
接下来就好使了，运行我们的代码：
roslaunch marm_gazebo arm_gazebo_control.launch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584f66dbe3fd218f1db9efa7e3f6d545/" rel="bookmark">
			YumRepo Error: All mirror URLs are not using ftp, http[s] or file解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、问题背景二、问题原因三、解决方法 一、问题背景 CentOS6.5利用yum -y install gcc命令安装程序报错YumRepo Error: All mirror URLs are not using ftp, http[s] or file.Eg. Invalid release/repo/arch combination/
removing mirrorlist with no valid mirrors: /var/cache/yum/x86_64/6/base/mirrorlist.txt
Error: Cannot find a valid baseurl for repo: base
、以及利用yum makecache命令时报错Error: Cannot retrieve repository metadata (repomd.xml) for repository: base. Please verify its path and try again。
二、问题原因 对应的镜像库中无法找到对应的repomd.xml文件
原因分析：CentoS 6 停止维护更新日期2020年11月30日，其中
CentOS 7 停止维护更新日期2024年6月30日
CentOS 8 停止维护更新日期2021年12月31日，其他具体信息可参阅官网https://wiki.centos.org/zh/About/Product
三、解决方法 原centos/6/ 下已经没有相关的文件，尝试修改本地镜像配置文件
步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/584f66dbe3fd218f1db9efa7e3f6d545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dbd452a0e3ba512bb23014bf5593d3e/" rel="bookmark">
			python实现两张图片左右（横向）和纵向（上下）拼接组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现两张图片左右（横向）和纵向（上下）拼接组合- 主要用于对两幅图像进行左右组合或者上下组合，详细代码如下： from PIL import Image def comb(png1, png2, style='horizontal'): img1, img2 = Image.open(png1), Image.open(png2) # 统一图片尺寸，可以自定义设置（宽，高） img1 = img1.resize((1500, 1000), Image.ANTIALIAS) img2 = img2.resize((1500, 1000), Image.ANTIALIAS) size1, size2 = img1.size, img2.size if style == 'horizontal': joint = Image.new('RGB', (size1[0] + size2[0], size1[1])) loc1, loc2 = (0, 0), (size1[0], 0) joint.paste(img1, loc1) joint.paste(img2, loc2) joint.save('horizontal.jpg') elif style == 'vertical': joint = Image.new('RGB', (size1[0], size1[1] + size2[1])) loc1, loc2 = (0, 0), (0, size1[1]) joint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dbd452a0e3ba512bb23014bf5593d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26baef44792a2fa4aa71199c2732e78a/" rel="bookmark">
			＜ elementUi 组件插件： el-table表格拖拽修改列宽及行高 及 使用注意事项 ＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elementUi 组件插件： el-table拖拽修改列宽及行高 及 使用注意事项 👉 资源Js包下载及说明👉 使用教程&gt; 实现原理&gt; 局部引入&gt; 全局引入 （在main.js中） 👉 注意事项&gt; 问题补充：拖拽时导致表格滚动条消失&gt; 问题补充：当一个页面存在两个及两个以上表格时，无法监测拖拽多个表格表头解决方案 往期内容 💨 👉 资源Js包下载及说明 由于项目需求，需要给定原先使用的element列表新增一个列宽动态拖拽功能。结合在网上找到的资源，出一期 “ 使用事项 ” 及 使用过程中的问题汇总
&gt; &gt; 点击跳转资源下载 &lt; &lt; 👉 使用教程 由于是后期加的功能，相信大部分人都不太可能去动原先的组件。所以这个插件正好符合需求，全部代码基于原生js,不依赖任何插件，可以直接声明使用。
&gt; 实现原理 列宽的调整最终是通过调整如上图的col元素的width属性实现列宽调整的。
行高的调整是动态改变tbody的 el-table__row 的高度实现调整的。
注意事项：
由于是直接引用的Js文件，代码内容是针对提前预设获取dom标签，给其增加事件监听。因此，是针对当前引入页面的所有表格都有效，如需要只针对某个表格，可以在查找元素的地方传参进行判断。判断代码如下：
const ths = document.querySelectorAll('.el-table__header th') const tBodyTr = document.querySelectorAll('.el-table__body tbody') const tbodys = document.querySelectorAll('.el-table__body-wrapper') &gt; 局部引入 import resizeTable from "@/utils/tabelleAnpassen"; // 调用方法 mounted() { this.$nextTick(() =&gt; { resizeTable(); }); } &gt; 全局引入 （在main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26baef44792a2fa4aa71199c2732e78a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d9c8827521f1fca690e38d22a3bfa9/" rel="bookmark">
			（四）Open Stack（M）----Nova服务安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢指剑大佬发表的博客与视频！感谢所 爱大佬的支持！
（三）Open Stack（M）----Glance安装和配置
一，安装和配置控制节点(在controller节点执行) 1.创建nove,nove_api数据库 1.进入数据库
mysql -uroot -p000000 2.创建数据库（nova,nova_api）
create database nova; create database nova_api; 3.创建nove用户并授予所有权限本地登陆并设置密码
GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'localhost' IDENTIFIED BY '000000'; 4.创建nove用户并授予所有权限任意地点登陆并设置密码
GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'%' IDENTIFIED BY '000000'; 5.创建nove_api用户并授予所有权限本地登陆并设置密码
GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'localhost' IDENTIFIED BY '000000'; 6.创建nove_api用户并授予所有权限任意地点登陆并设置密码
GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'%' IDENTIFIED BY '000000'; 7.退出数据库
\q 截图如下
2.创建服务凭证和API端点 1.获得管理员访问权限
. /root/admin-openrc 2、创建服务凭证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d9c8827521f1fca690e38d22a3bfa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c747710039d9dbc9ccff54241622ed87/" rel="bookmark">
			linux服务器时间不同步问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux服务器时间不同步问题处理
linux服务器时间不同步问题处理 现象：处理前服务器时间和本地时间相差是8小时
解决方法 1、删除当前默认时区
rm -rf /etc/localtime
2、使用亚洲上海时区
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
验证 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfde3856c9c62877c7e0c4e29037fc1f/" rel="bookmark">
			OpenGL 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL 简介 一、GPU 接口规范 对于刚接触 OpenGL 的初学者,常常会有这样一个疑问: OpenGL 的源码在哪里,如何编译?
然而实际上 OpenGL 并不是一个软件实现,更多的是一个标准协议; OpenGL 更像是一种显卡驱动标准,由各个硬件厂家适配,各个硬件厂商根据 OpenGL 接口规范编撰对应的驱动.
换句话说,对于各个硬件厂商 OpenGL 确实是一个基于 GPU 的软件实现,但是对于普通的应用层开发者 OpenGL 就是一个由硬件厂商提供的驱动程序罢了,也就是为什么你找不到 OpenGL 源代码实现的原因了.
OpenGL 是操作 GPU 的其中一种方法,但绝不是唯一的途径; OpenGL 由 Khronos 进行管理,在 Khronos 的官网下,你可以找到下面这张图:
在这里,你可能看到一些熟悉的名称,比如 EGL 、glTF、OpenCL、OpenGL 以及 Vulkan等等,这里定义了许多标准规范;这里我们仅仅谈及真正直接操作GPU的标准协议,也就是下图中 3D Graphics 的部分:
然后呢,这就是全部了吗? 实际并不是, Khronos 更多像是一个联盟,有着许多成员如 Apple、Intel、AMD、Google、ARM、Qualcomm、Nvidia 等等成员.
所以,也就会出现"分道扬镳"的现象,比如:
微软下的 Direct X (D3D9、D3D11、D3D12),对标 OpenGL:
苹果下的 Metal, 还是对标 OpenGL:
以及英伟达大名鼎鼎的 CUDA, 对标 OpenCL:
可以看到关于一个 GPU 接口规范的指定,出现了很多不同的角色比如硬件产商、操作系统提供者等等;为什么会出现这么多种规范呢?其中一部分原因来自于某一种标准实现并不适用于某些场景,但还有其他一部分原因就是跟为什么有这么多中编程语言类似的原因.
二、GPU 接口分类 GPU(Graphic Processing Unit)按我的理解可以分为两大类 GL(Graphic Language) 和 CL(Compute Language):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfde3856c9c62877c7e0c4e29037fc1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6c9b2812e940a972b36ea3c552ba8b3/" rel="bookmark">
			Doris-1.2.0升级到Doris-1.2.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 在使用doris-1.2.0版本时发现BE节点无故宕机，自己尝试解决无果后再官网寻找解决方案，发现在doris-1.2.0版本中存在这样的隐患bug导致BE节点宕机。
而在咨询社区之后建议对doris进行升级，升级版本doris-1.2.4。该版本是解决1.2.x问题的修复版本
1 准备升级 1.1 下载1.2.4安装包 https://dist.apache.org/repos/dist/dev/doris/1.2.4-rc01/
注意：① 除下载BE和FE的安装包外，还需要下载1.2.4版本udf对应的依赖jar包
② 需要将下载好的udf的jar包(java-udf-jar-with-dependencies.jar)拷贝到be节点的lib目录下
1.2 备份FE节点元数据 fe元数据默认在fe/doris-meta目录下，压缩文件
tar -zcvf doris-meta.tar.gz dors-meta 1.3 备份BE节点数据 be元数据默认在be/storage目录下，压缩文件
tar -zcvf storage.tar.gz storage 1.4 准备工作 关闭集群副本修复和均衡功能，升级过程中会有节点重启，所以可能会触发不必要的集群均衡和副本修复逻辑。可以先通过以下命令关闭：
# 关闭副本均衡逻辑。关闭后，不会再触发普通表副本的均衡操作。 $ mysql-client &gt; admin set frontend config("disable_balance" = "true"); # 关闭 colocation 表的副本均衡逻辑。关闭后，不会再触发 colocation 表的副本重分布操作。 $ mysql-client &gt; admin set frontend config("disable_colocate_balance" = "true"); # 关闭副本调度逻辑。关闭后，所有已产生的副本修复和均衡任务不会再被调度。 $ mysql-client &gt; admin set frontend config("disable_tablet_scheduler" = "true"); 注意：升级完成后需要用同样的方法还原设置的值
2 测试BE升级正确性 ① 任意选择一个 BE 节点，部署最新的 doris_be 二进制文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6c9b2812e940a972b36ea3c552ba8b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f06c9c94b961be07469f51507c991c9/" rel="bookmark">
			代理与反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 代理和反射是 ES6 新增的两个特性。他们为开发者提供了拦截对象基本操作并向其嵌入额外行为的能力。可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。本文内容为详读《JavaScript 高级程序设计（第4版）》的笔记。
ES6 学习系列笔记
ES6 总结Symbol、Map、SetES6 中的类（class）代理与反射Promise 与异步函数迭代器和生成器 目录 前言1 代理1.1 代理基础语法1.2 定义捕获器1.3 捕获器参数和反射 API1.4 捕获器不变式和可撤销代理1.5 反射 API 的实用性1.6 代理多层拦截和代理的不足 2 代理捕获器与反射方法2.1 get()2.2 set()2.3 has()2.4 defineProperty()2.5 getOwnPropertyDescriptor()2.6 deleteProperty()2.7 ownKeys()2.8 getPrototypeOf()2.9 setPrototypeOf()2.10 isExtensible()2.11 preventExtensions()2.12 apply()2.13 construct() 3 代理模式 1 代理 在 ES6 之前，ECMAScript 中并没有类似代理的特性。它是一种新的基础性语言能力，很多转译程序都无法将其转为 ES6 之前的兼容性代码。所以只能在支持他们的平台上使用，如果不支持则需提供后备代码或者不能使用代理和反射。
1.1 代理基础语法 代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。这两个参数是必需的，而且是 Object 类型数据，不传或者数据类型不对都会抛出 TypeError 。如下列示例代码创建了一个处理程序对象为空对象的代理 proxy 。
const target = { id: 'target' }; const handler = {}; const proxy = new Proxy(target, handler); // 对代理对象的操作会同时放映在两个对象上 proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f06c9c94b961be07469f51507c991c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28904fb94dd159a02d991870ffa0f8b2/" rel="bookmark">
			ES6 中的类（class）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ES6 引入的 class 关键字具有定义类的能力。类是 ECMAScript 中新的基础性语法糖。虽然 ES6 表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的依旧是原型和构造函数的概念。（笔记内容参考《JavaScript 高级程序设计（第 4 版）》章节 8.4 类）。以前在笔记《js 中原型、原型链和继承概念（详细全面）》中简要提过部分内容，这里系统看一次。
ES6 学习系列笔记
ES6 总结Symbol、Map、SetES6 中的类（class）代理与反射Promise 与异步函数迭代器和生成器 1 类的定义 定义类有两种主要方式：类声明和类表达式。两种方式都需要使用 class 关键字加大括号定义。类表达式与函数表达式类似，在它们被求值前都不能被引用。但是类声明与函数声明不同，类声明不能提升，即在声明之前引用该类都会抛出引用错误 ReferenceError（类似暂时性死区，因为类受块级作用域限制，个人认为这两者是存在关系的，书中没有说明）。
// 类声明 class Person { } // 类表达式 const Tree = class {}; // 类声明不提升 // ReferenceError: Cannot access 'C' before initialization console.log(C); class C {} // function 和 class 关键字类似于 var 和 let、const 的区别。 // 函数声明受函数作用域限制，类受块作用域限制。 { function f() { console.log('f'); } class Cx {} } f(); // 'f' // ReferenceError: Cx is not defined console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28904fb94dd159a02d991870ffa0f8b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee50fadf67a268b12fca29f6735f434/" rel="bookmark">
			GDOUCTF web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、hate eat snake 第一次正式接触这种题，打开页面发现是个贪吃蛇类游戏，审计源码发现snake.js，点开审计后发现，当你坚持时长达到60秒后会显示flag，我的思路是看看代码中有没有分数限制，长度之类的，通过修改其的值来直接回显flag，但我却不知如何下手（第一次做，工具也不太熟悉），接下来参考大佬wp。
先把网页以及js代码下载到本地，审计一下代码，发现给snake设置了初始速度，那我们继续寻找有关snake速度的代码看看
window.onload = function(){ new Snake('eatSnake',10,false); } var Snake = function(snakeId,speed,isAuto){ this.width = arguments[3] || 35 ;	this.height = arguments[4] || 35 ; this.snakeId = snakeId || 'snake' ;	this.Grid = [] ;	this.snakeGrid = [] ;	this.foodGrid = [] ;	this.derectkey = 39 ; this.goX = 0 ; this.goY = 0 ; this.speed = this.oldSpeed = speed || 10 ;	this.stop = true,	this.snakeTimer = null ;	this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ee50fadf67a268b12fca29f6735f434/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/85/">«</a>
	<span class="pagination__item pagination__item--current">86/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/87/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>