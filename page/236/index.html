<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f0c7ab27c311a5c0388e771e384c28/" rel="bookmark">
			centos7 VM 关闭防火墙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 centos7关闭防火墙 使用命令：
查看防火墙状态
systemctl status firewalld.service 执行后可以看到绿色字样标注的“active（running）”，说明防火墙是开启状态
使用命令：
关闭运行的防火墙
systemctl stop firewalld.service 查看防火墙是否关闭
systemctl status firewalld.service 可以看到，disavtive（dead）的字样，说明防火墙已经关闭
如果觉得 每次开机都要关闭防火墙 麻烦那就把防火墙禁用
systemctl disable firewalld.service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44453887864f1b8f7103d042f5fef321/" rel="bookmark">
			笨鸟的平凡之路-CDH集群角色和节点数规划建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 CDH组件角色说明 Hadoop 集群服务器按照节点任务的不同可以分为管理节点和工作节点。管理节点上部署各组件的管理角色，工作节点部署各角色的存储、容器或计算角色。但因为Hadoop 不同组件之间兼容性的问题，所以一般使用Cloudera 套件。 在CDH套件中就有如下角色。
2、 CDH 节点数量建议 2.1 小规模集群 一般来说，小于20个节点的都属于小规模集群，受限于集群的存储和处理能力，小规模集群不太适合用于多业务的环境。可以部署成 HBase 的集群，也可以部署成分析集群，包含 YARN、Impala 。在小规模集群中，为了最大化利用集群的存储和处理能力，节点的复用程度往往比较高。
2.2 中等规模集群 一个中等规模的集群，集群的节点数一般在20到200左右，通常的数据存储可以规划到几百TB，适用于一个中型企业的数据平台，或者大型企业的业务部门数据平台。节点的复用程度可以降低，可以按照管理节点、主节点、工具节点和工作节点来划分。
这些节点中包含：
1个CM管理节点：用来安装 Cloudera Manager 和Cloudera Management Service，以对CDH进行管理。
3个主节点：用来安装 CDH 服务以HA 的组件。如3个ZKServer、两个 NameNode（主备）、两个ResourceManager，3个HBase Master1个Hive Metastore 、1个spark History Server之类管理角色。角色分配可以参考下图：
N个工具节点：用来部署HIVE Server2，、Hue Server、Oozie Server、Flum Agent 、Sqoop Client 、Gateway等。
N个工作节点：部署HDFS DataNode,YARN NodeManager,Implala Daemon,HBase Region Server。
3、 大规模集群 大规模集群的节点数量一般会在 200 以上，存储容量可以是几百TB甚至是PB级别的数据，适用于大型企业搭建的数据平台。大型集群的架构和中型集群的类似，只是主节点的数量从3个增加到5个，从而增加了主节点的可用性。剩下都是工作节点的增加。
当主节点增加到5个后，HDFS JournalNode 也从3个增加到5个，ZooKeeper Server 和HBase Master 也从3个增加到5个，Hive Metastore 由1个增加到3个。
4、 CDH 节点推荐的硬件配置 业务类型不同，集群具体配置也有区别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44453887864f1b8f7103d042f5fef321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3dd63080cf95c07014c827ebcad0bb/" rel="bookmark">
			Linux 系统硬盘不能识别挂载 bad magic number in super-block问题的修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司Linux编译服务器外挂硬盘盒不能挂载， 提示信息 “Structure needs cleaning”，
用 xfs_repair -n /dev/sdb1 硬盘检测 提示 “Bad magic number in super-block”，
super block 是硬盘分区开头——开头的第一个byte是byte 0，从 byte 1024开始往后的一部分数据。由于 block size最小是 1024 bytes，所以super block可能是在block 1中（此时block 的大小正好是 1024 bytes），也可能是在block 0中。 超级块中的数据其实就是文件卷的控制信息部分，也可以说它是卷资源表，有关文件卷的大部分信息都保存在这里。例如：硬盘分区中每个block的大小、硬盘分区上一共有多少个block group、以及每个block group中有多少个inode.
尝试各种方法， 最终用如下方法解决， 分享给有需要多同学.
1. mke2fs -n /dev/sdb1 。。。。。。。。。。。。。。 backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736
2. e2fsck -b 32768 -y /dev/sdb1 成功修复
3. mount /dev/sdb1 /mnt/d
若是怀疑硬盘是否有坏块，检测坏块命令如下，后面多txt是检测结果输出多记录文件
badblocks -v /dev/sda10 &gt; badsectors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d3dd63080cf95c07014c827ebcad0bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f66950b32934554b8fa27ee270c8902/" rel="bookmark">
			QT 文件操作 QFile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
QFile类介绍
写入数据到txt文件（实例代码）
从txt文件中读取所有数据（实例代码）
从txt文件中一行一行读取数据（实例代码）
部分函数参数及作用
QFile类介绍 QIODevice 类是 Qt 中所有 I/O 设备的基础接口类，为诸如 QFile、QBuffer 和 QTcpSocket 等支持读/写数据块的设备提供了一个抽象接口。。
QFile类提供一个用于读/写文件的接口，它是一个可以用来读写文本文件、二进制文件和Qt资源的 I/O 设备。
QFile可以单独使用，也可以和QTextStream 或者QDataStream 一起使用。
一个文件使用open()打开，使用close()关闭，使用flush()刷新。
写入数据到txt文件（实例代码） QFile file("C:\\Users\\admin\\Desktop\\test.txt"); if(!file.open(QIODevice::WriteOnly))//以写的方式打开文件，如果文件不存在则创建， qDebug()&lt;&lt;file.errorString(); QByteArray buf = "bbbbbbbbbbb"; file.write(buf);//写入文件，支持QByteArray和 char * 类型数据写入 file.close();//关闭文件 从txt文件中读取所有数据（实例代码） QFile file("C:\\Users\\admin\\Desktop\\test.txt"); if(!file.open(QIODevice::ReadOnly))//以读的方式打开文件 qDebug()&lt;&lt;file.errorString(); QByteArray buf = file.readAll();//读取文件所有数据 qDebug()&lt;&lt;"buf: "&lt;&lt;buf; file.close();//关闭文件 从txt文件中一行一行读取数据（实例代码） QFile file("C:\\Users\\admin\\Desktop\\test.txt"); if(!file.open(QIODevice::ReadOnly))//以读的方式打开文件 qDebug()&lt;&lt;file.errorString(); while(file.atEnd() == false)//文件没到末尾就执行循环体内容 { QByteArray buf = file.readLine();//读取一行的数据 qDebug()&lt;&lt;buf; } file.close();//关闭文件 部分函数参数及作用 文件的数据读/写一般使用QDataStream 或者 QTextStream 来完成，不过也可以使用继承自 QIODevice 类的一些函数，如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f66950b32934554b8fa27ee270c8902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a7ab6bd94e757317015c6639e27912/" rel="bookmark">
			vue项目里setTimeout方法执行时获取不到data中的变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目里setTimeout方法
输出：
发现在setTimeout执行时this变为了window，这是由于setTimeout函数调用的代码运行在与所在函数完全分离的执行环境上，this指向的是window对象。
要缓存this，定义一个方法去执行setTimeout函数（用箭头函数更方便）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2807f4b2eb29d38b7a663f67f92d2b/" rel="bookmark">
			学习R语言编程——常用算法——二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		############################常用算法——二分法#################################
###用二分法求下面方程在(-10,10)的根.2*x^3-4*x^2+3*x-6 = 0
#while
f = function(x) 2*x^3-4*x^2+3*x-6
x0 = -10;x1 = 10
while(abs(x0-x1)&gt;1e-6){
if(f(x0)*f(x1)&gt;0){
print("no root")
break
}
x2 = (x0+x1)/2
if(f(x2)==0){cat(x2);break}
if(f(x0)*f(x2)&lt;0){
x1 = x2
}else{
x0 = x2
}
}
x0
#repeat
f = function(x) 2*x^3-4*x^2+3*x-6
x0 = -10;x1 = 10
repeat{
if(f(x0)*f(x1)&gt;0){
print("no root")
break
}
x2 = (x0+x1)/2
if(f(x2)==0){cat(x2);break}
if(f(x0)*f(x2)&lt;0){
x1 = x2
}else{
x0 = x2
}
if(abs(x0-x1)&lt;1e-6){
cat(x0)
break
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58fff203eef80d2ddc5db04eb329976d/" rel="bookmark">
			在WEB服务器上设置可以同时运行两个网站，端口法和IP地址法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给web服务器配置静态IP地址 WEB服务器的安装 1、打开服务管理器，点击“角色”，点击“添加角色”
2、点击“下一步”
3、勾选“WEB服务器（IIS）”，点击“下一步”
4、点击“下一步”
5、点击“下一步”（如果网页为动态网页，再勾选“应用程序开发”，但是不是很安全）
6、点击“安装”
7、点击“关闭”
网站内容的创建 打开“计算机”——“本地磁盘C”——“inetpub文件”——新创建文件夹“wangzhan1”和“wangzhan2”——分别在两个文件夹里面右击新建“文本文档”——打开文本文档，在里面输入内容——另存为.html文件
端口法（适用于使用的人比较少，小范围内，公网私网都可以） 1、点击“开始”——“管理工具”——打开“Internet信息服务（IIS）管理器”
2、右击“网站”——点击“添加网站”
3、输入“网站名”，选择“应用程序池”，选择“物理路径，点击“确定”。（如果这里的端口依然为80，请将默认网站（Default Web Site）停止运行）
4、用同样的方式添加第二个网站，需要注意的是：这里的端口不能和上一个端口一样
5、单机“wangzhan1”，双击“默认文档”，点击右侧“添加”
6、输入刚才创建的用于wangzhan1的html文件名称，点击确定
7、用同样的方式将用于wangzhan2的html文件名称添加上
8、打开“计算机”，在搜索栏输入“hosts”搜索hosts文件，用记事本打开第二个hosts文件
9、添加两个域名（注意:IP地址相同），保存
10、在浏览器用域名访问两个网站，一个加端口，一个不加端口（前提是此端口为80端口）
IP地址法（公网上最好不要使用因为费用太高，适用于私网内） 1、在一个网卡上添加多个IP，点击“高级”，
2、点击“添加”，这里又新添加了一个192.168.18.2的地址
3、点击“wangzhan1”右侧的“绑定”，弹出“网络绑定”窗口，选中信息，点击“编辑”
4、IP地址选择192.168.18.1，端口为80，点击“确定”
5、用同样的方式将“wangzhan2”进行“网络绑定”设置，注意：端口号都应改为80，点击“确定”
6、打开hosts文件，不同的IP地址对应不同的域名，点击保存
7、在浏览器用域名访问网站
注意： 1、端口号可以跟在IP地址后面，也可以跟在域名后面 2、HOSTS文件解析时不可带端口号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d657b92de24e96b4cf0a7475619db6/" rel="bookmark">
			618查看商品历史价格的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用　法：
在地址栏中的电商域名后加入字母asd即可查询当前商品历史价格，如：
第一步：
正常浏览商品，假设商品原链接为：
https://item.jd.com/3505714.html
第二步：
在地址栏中域名后添加“asd”后回车，添加“asd”后的商品页面为：
https://item.jdasd.com/3505714.html
第三步：
网页从商品页面跳转至本页，显示历史价格。
PS：不支持手机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23bebe6512e61c368c7df2522c6651a4/" rel="bookmark">
			【进阶 6-4 期】深入浅出防抖函数 debounce
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 上一节我们认识了节流函数 throttle，了解了它的定义、实现原理以及在 underscore 中的实现。这一小节会继续之前的篇幅聊聊防抖函数 debounce，结构是一样的，将分别介绍定义、实现原理并给出了 2 种实现代码并在最后介绍在 underscore 中的实现，欢迎大家拍砖。
有什么想法或者意见都可以在评论区留言，下图是本文的思维导图，高清思维导图和更多文章请看我的 Github。
定义及解读 防抖函数 debounce 指的是某个函数在某段时间内，无论触发了多少次回调，都只执行最后一次。假如我们设置了一个等待时间 3 秒的函数，在这 3 秒内如果遇到函数调用请求就重新计时 3 秒，直至新的 3 秒内没有函数调用请求，此时执行函数，不然就以此类推重新计时。
举一个小例子：假定在做公交车时，司机需等待最后一个人进入后再关门，每次新进一个人，司机就会把计时器清零并重新开始计时，重新等待 1 分钟再关门，如果后续 1 分钟内都没有乘客上车，司机会认为乘客都上来了，将关门发车。
此时「上车的乘客」就是我们频繁操作事件而不断涌入的回调任务；「1 分钟」就是计时器，它是司机决定「关门」的依据，如果有新的「乘客」上车，将清零并重新计时；「关门」就是最后需要执行的函数。
如果你还无法理解，看下面这张图就清晰多了，另外点击 这个页面 查看节流和防抖的可视化比较。其中 Regular 是不做任何处理的情况，throttle 是函数节流之后的结果（上一小节已介绍），debounce 是函数防抖之后的结果。
原理及实现 实现原理就是利用定时器，函数第一次执行时设定一个定时器，之后调用时发现已经设定过定时器就清空之前的定时器，并重新设定一个新的定时器，如果存在没有被清空的定时器，当定时器计时结束后触发函数执行。
实现 1 // 实现 1 // fn 是需要防抖处理的函数 // wait 是时间间隔 function debounce(fn, wait = 50) { // 通过闭包缓存一个定时器 id let timer = null // 将 debounce 处理结果当作函数返回 // 触发事件回调时执行这个返回函数 return function(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23bebe6512e61c368c7df2522c6651a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6f314c3efe4d2acc3993a0833731d2/" rel="bookmark">
			java中常用的几个集合类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//TODO //未完成 //不过先发了吧 //包含Collection（集合），List，Set，Map（图），以及其Iterator，Comparator ，Cloneable，还有常用的具体实现类 //List&lt;List&lt;String&gt;&gt;集合的嵌套使用 //1、是否允许空 //2、是否允许重复数据 //3、是否有序，有序的意思是读取数据的顺序和存放数据的顺序是否一致 //4、是否线程安全 JAVA SE 8官方文档 JAVA官方文档中集合类的关系 目录
概览
瞎说几句
对第一张图(集合类的关系)的解析
具体的几个集合类（List，Set，Map）
List ArrayList
LinkedList
Set
HashSet
TreeSet
Map
HashMap
TreeMap
概览 瞎说几句 JAVA中有许多的集合，常用的有List，Set，Queue，Map。
其中List，Set，Queue都是Collection（集合），其每个元素都是单独的一个对象，如List&lt;String&gt;，Set&lt;Integer&gt;等，String和Integer就是单独的一个对象。
而Map是一种图，其每个元素都是两个对象的一一对应，如Map&lt;Integer, String&gt;中的Integer是键 (key)，String是这个键所对应的值(value)。每个元素都是一对Integer和String
tip 1: List&lt;String&gt;中&lt;&gt;的内容表示其中元素的类型，是泛型的一种使用。
tip 2: Integer是一个对象(可从首字母大写的命名方式中看出)，可以粗略地将其视作int。
tip 3: 由于这些集合类的元素必须是对象或者由对象构成，所以不能直接使用int这种简单数据类型将Map定义为Map&lt;int, String&gt;，而应该使用Integer将Map定义为Map&lt;Integer, String&gt;。
tip 4: 不能直接使用简单数据类型的更深层次的原因在于：
集合类（比如Set）在进行各种 "操作" ( 如contains()) 时都会调用元素本身提供的 "方法" ( 如hashCode()和equals())，而不是由集合类自身去实现这些 "方法"。这就要求如果某人想要用这个集合执行某些 "操作"，那就必须在要加入集合的元素中实现相应的 "方法"。
由于简单数据类型 (如int)，只是单纯的一个数值，而无法在其中实现方法，所以应该使用实现了各种所需"方法"的类 (如Integer) 作为元素。
对第一张图(集合类的关系)的解析 从第二行 java.util.AbstractCollection&lt;E&gt; (implements java.util.Collection&lt;E&gt;) 看起
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6f314c3efe4d2acc3993a0833731d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742bf7d77dde725b102fdd581c105bb9/" rel="bookmark">
			Flink  WaterMark的生成以及获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是WaterMark WaterMark是Flink用来处理时间乱序的一种机制。用来过滤掉由于网络或者其他原因，而迟来的脏数据。
2.基本使用 WaterMark绝大部分时候是和eventTime配合使用，可能有的同学非要用Processing Time，那也是可以的，只要加上env.getConfig().setAutoWatermarkInterval(200); 这句话就可以了，是没有任何效果的，下文就讲到。
先上用法，本文都是按照时间进行处理的，暂时不介绍按照事件处理的，因为用到的极少极少。
import org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks; import org.apache.flink.streaming.api.watermark.Watermark; import javax.annotation.Nullable; public class MyWaterMark implements AssignerWithPeriodicWatermarks&lt;TestAA&gt; { Long currentMaxTimestamp = 0L; Long maxOutOfOrderness = 10000L;//允许的最大乱序时间是10s @Nullable @Override public Watermark getCurrentWatermark() { return new Watermark(currentMaxTimestamp-maxOutOfOrderness); } /** * 每来一条数据，就会调用这个方法 * 其中TestAA是我个人定义的一个pojo类，里面只有三个属性name，id，times * @param element * @param previousElementTimestamp * @return */ @Override public long extractTimestamp(TestAA element, long previousElementTimestamp) { System.out.println("mark:"+element); Long timestamp = element.getTimes(); currentMaxTimestamp = Math.max(timestamp,currentMaxTimestamp); return timestamp; } } 先自定义一个 AssignerWithPeriodicWatermarks类，然后使用的话
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/742bf7d77dde725b102fdd581c105bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e777c2914a98ca4305ff3e13818ec57a/" rel="bookmark">
			linux  centos 搭建wordpress 服务器 网站建设lamp php apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 搭建wordpress 服务器 网站建设
linux 说是很难学，其实深度倒是没有，随便敲敲完成个东西原来可以很快的ok，当然离好还很远。不过有那么点样子是可以的，去他的也大同小异。
一门语言没有什么深奥不深奥之说，只有常用不常用之分，只要是敲过，能用就是可以的。很多时候不像数学什么的需要太深奥的一层层演绎的。
两周敲看看书。然后centos系统下，搭建apache，php 安装连接mysql 建设wordpress 服务。为了服务器建设过程，这里不用一键安装的lamp包，而是分开几个部分安装。
实则：centos是两年前就安装在了笔记本上，和 wind7共存。毕竟是电脑增加了固态硬盘在第一个磁盘位置，老磁盘放在了第二位，所以目前两个硬盘。另外，win7安装在了第一个硬盘，ocentos安装在了第二个硬盘。 之前开机用easybcd也引导不了，每次需要开启并选择linux，但是进不了系统，强制断电重起才可以选择linux进入。麻烦，所以两年了也没怎么进入linux 。今年忽然开始敲打命令，思考很久启动的问题。用grub其实不会，但是大概知道不就是去挂载系统位置吗。所谓引导不就是听说有个磁盘引导分区，既然叫磁盘那就是属于磁盘了，我这两个磁盘那不就是第一个引导分区挂在不了第二个的问题？ 如果是，然后 恍然想起可能是因为两个硬盘启动引导区需要切换的问题，在一个引导上没能挂载上分别安装在两个磁盘上的系统吧。
灵机一动，开机然后按一下esc，然后果然进入了磁盘引导区的选择上，所以选择第二个磁盘的引导区就能直接进入linux，原来两个系统分别安装在两个磁盘是需要切换引导区告诉电脑从哪个盘的引导区开始启动引导的问题。大明白，忽然有决心好好敲命令的动力了。
在这个2年前装的centos7上，建这个题目上的服务器，顺便知道下搭建路径并理解下相关连接。这个系统不求新其实已经足够新了，太新并不好。最爱用最新版前面的稳定版，都知道为什么哈哈。
1、安装 apache
yum -y install httpd
2.开启apache服务
systemctl start httpd.service
3.设置apache服务开机启动
systemctl enable httpd.service
4.验证apache服务是否安装成功
在本机浏览器中输入虚拟机的ip地址，CentOS7查看ip地址的方式为：
ip addr
2、安装php ;Php 7.1以上版本安装(比较高的php才支持最新的wordpress)
参考：https://www.cnblogs.com/Kevin-1967/p/9282740.html
#CentOs 7.X：
rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm
rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm
安装 php71命令：
yum install -y php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-fpm php71w-gd php71w-mbstring php71w-mysqlnd php71w-opcache php71w-pdo php71w-xml php71w-ldap php71w-mcrypt
3、安装mysql 不是mybias
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e777c2914a98ca4305ff3e13818ec57a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5151c14eea32948ca99e2fffe918394a/" rel="bookmark">
			dyn_threshold（动态阈值）解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在图像处理的时候会遇到背景和ROI区域难以提取的情况。不能简单的使用一个全局阈值来对图像进行分割。此时会用到动态阈值分割的方法： 转自：dyn_shreshold（动态阈值）解析 1. 算子结构 首先看dyn_threshold 算子参数 dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark ) 参数分析： OrigImage:需要进行阈值分割的原始图像
ThresholdImage: 通过一定图像预处理得到的阈值图像（这个预处理通常是对原图应用mean_image/gauss_image/binomial_filter 处理后的图像）
RegionDynThresh: 对原图进行阈值分割后输出图像
Offset: 是一个阈值调节值，在做对比时，需要和ThresholdImage上某一点像素值同时作用。
LightDark：是一个关键选择，’dark’, ‘light’, ‘equal’, ‘not_equal’一共有4种选择，明、暗、同、不同
2. 关键点分析 根据Halcon帮助文档种给出的 dyn_threshold的分割阈值的计算方式 g_o=g_[OrigImage] g_t=g_[ThresholdImage] 当选择light模式 阈值计算公式： for LightDark = ‘light’ is: g_o &gt;= g_t + Offset 即为原图中大于等于g_t + Offset点的像素值被选中。
当选择dark 模式 For LightDark = ‘dark’ the condition is: g_o &lt;= g_t - Offset 即为原图中小于等于g_t - Offset点的像素值被选中。
当选择equal 模式时： For LightDark = ‘equal’ it is: g_t - Offset &lt;= g_o &lt;= g_t + Offset 原图中像素值在g_t - Offset 和 g_t + Offset之间的像素点被选中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5151c14eea32948ca99e2fffe918394a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3374b6d6a0f866ca9f148ac76fb7af18/" rel="bookmark">
			线程以及pthread库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是线程 你可以想象你一边听歌一边打游戏，如果是操作系统会怎么做呢？先执行 ListenMusic 再执行 PlayGame，还是先执行 PlayGame 再执行 ListenMusic 呢？好像都不太合适。为了实现这个目的，就需要引入线程这个概念。线程是 CPU 调度的最小执行单位，你可以创建一个线程用于 ListenMusic，再创建一个线程去 PlayGame，这样操作系统就是同时处理这两个任务的（并发）。
二.pthread库 (1) 使用说明 POSIX 标准定义了一套线程操作相关的函数，用于让程序员更加方便地操作管理线程，函数名都是以前缀 pthread_ 开始，使用时要包含 &lt;pthread.h&gt;，而且在链接的时候要手动链接 pthread 这个库，如：gcc main.c -lpthread -o main。 (2) 常用函数 1. pthread_create 函数原型：int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
功能说明：创建一个线程。
参数说明
thread：线程句柄，需要先定义一个 pthread_t 类型变量 thread，将该变量的地址 &amp;thread 传递到该参数中去。这是一个传出参数，传递进去的 thread 会得到系统为我们创建好的线程句柄。
attr：线程属性，通过该参数可以设置创建的线程属性，如果要使用默认属性直接传递 NULL 即可。
start_routine：线程函数，它是一个函数指针类型，返回类型为 void *，参数为一个 void * 类型变量，创建好这样类型的一个函数，将函数名传递进去即可。
arg：线程参数，代表需要在主线程传递给子线程的参数，给 arg 赋值后可以在线程函数的参数中取到。
返回值说明
成功情况下返回 0，失败情况下返回错误码，并且 tid 的值是不确定的。Linux 环境下所有线程函数调用失败时均是返回错误码，除了部分返回值为 void 的函数。关于错误码的说明在这里的第 8 小节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3374b6d6a0f866ca9f148ac76fb7af18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a1fe874b77dc7f603a8e5415495d2f/" rel="bookmark">
			Ubuntu下crontab定时任务详细总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义： cron是服务名称，crond是后台进程，cron的配置文件称为“crontab”，是“cron table”的简写，crontab是定制好的计划任务表。
cron服务提供crontab命令来设定cron服务的。
2、安装： 安装：apt-get install cron
一般情况下ubuntu自带cron服务
3、crond服务操作命令 /sbin/service crond start //启动服务
/sbin/service crond stop //关闭服务
/sbin/service crond restart //重启服务
/sbin/service crond reload //重新载入配置
service cron status //检查状态
service cron //查询cron可用的命令
查看服务是否已经启动 ps -ax | grep cron
4、crontab命令 crontab -u //设定某个用户的cron服务 -u指定一个用户 crontab -l //列出某个用户cron服务的详细内容 -l列出某个用户的任务计划 crontab -r //删除没个用户的cron服务 -r删除某个用户的任务 crontab -e //编辑某个用户的cron服务 -e编辑某个用户的任务 5、crontab任务配置基本格式 分 小时 日 月 星期 命令 0-59 0-23 1-31 1-12 0-6 command (取值范围,0表示周日、一般一行对应一个任务) 其中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a1fe874b77dc7f603a8e5415495d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06fafcbc21c9d46b94ef33a563252cc/" rel="bookmark">
			python3 AttributeError: module &#39;string&#39; has no attribute &#39;uppercase&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string.lowercase
string.uppercase
均已取消
使用
string.ascii_uppercase
string.ascii_lowercase
替代
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab2a1ee018dc6bd19131f042b90224b/" rel="bookmark">
			在Unity里使用光线步进（Raymarching）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图中光滑球为光线步进产生，粗糙球为Unity的场景物体 概念 光线步进和光线投射类似，都是从屏幕发射射线，然后求射线和物体的焦点，但是光线投射是一次性算出交点，而光线步进是一步步的前进，不断的向交点趋近，光线步近中的物体使用一种距离场函数来表示（SDF,Signed-distance-field 有向距离场）。通过这个函数你可以知道当前点的位置位置和物体的最近距离，如果距离趋向于0，就说明到达了交点，
每次前进的步长等于计算的距离，这样可以更快的趋近与交点。
如图所示，射线一步步向前，最后到达近似于交点的位置。
光线步进可以看做一个屏幕特效，怎么让shader应用一个屏幕特效我就忽略了，另外shader创建一个Image Effect Shader即可，
直接在上面改就好了，基本的设置几乎不需要变。
射线方向 首先我们需要得到每个像素的射线发射方向，这里我共看到了两种
第一种比较方便，但是可能会比较耗性能，因为每个像素都要计算一次。 思路看这里
Ray CreateCameraRay(float2 uv){ float2 p=uv*2.0f-1.0f; //内置的矩阵unity_CameraToWorld 左右手坐标系需要切换，所以要修改一下 //tips：外部传入的_camera.cameraToWorldMatrix就是反的 float4x4 negativeMat=float4x4( 1,0,0,0, 0,1,0,0, 0,0,-1,0, 0,0,0,1 ); float4x4 n_CameraToWorld=mul(unity_CameraToWorld,negativeMat); float3 origin=mul(n_CameraToWorld,float4(0.0f,0.0f,0.0f,1.0f)).xyz; float3 direction=mul(unity_CameraInvProjection,float4(p.xy,1.0f,1.0f)).xyz; direction=mul(n_CameraToWorld,float4(direction,0.0f)).xyz; direction=normalize(direction); return CreateRay(origin,direction); } 值得一提的是在实际使用中我发现shader中内置的相机世界矩阵和外界传入的相机世界矩阵有所不同，内置的并没有包含左右手坐标系的转换，所以用的时候要么用外面传入的，要么修改一下内置的。如果直接用内置的，你以为的正面其实是背面。
第二种需要shader外的配合，核心思路就是预先计算好屏幕空间四个顶点的发射向量，然后通过插值器得到每个像素点的发射方向
在c#部分，我们预先计算好四个顶点的向量，打包成矩阵传入shader；
//返回一个矩阵，分别表示四个点的向量，在shader里插值后可以得到各像素点的方向 Matrix4x4 CamFrustum() { Matrix4x4 mat=Matrix4x4.identity; float fov = Mathf.Tan(_camera.fieldOfView * 0.5f* Mathf.Deg2Rad) ; //得到向上向右的位移偏亮 进而推出屏幕面片四个点的发射方向 Vector3 up = Vector3.up * fov; Vector3 right = Vector3.right * _camera.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab2a1ee018dc6bd19131f042b90224b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c33d7fe56222d958e83434fcef97664/" rel="bookmark">
			mysql安装遇到的问题，提示 api-ms-win-crt-runtime-l1-1-0.dll丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前使用的数据库是5.5的，最近想换新的8以上的，下载解压后安装的时候出现了问题，提示 api-ms-win-crt-runtime-l1-1-0.dll丢失，最终百度了好多帖子解决
，在这里记录整理下。
提示 api-ms-win-crt-runtime-l1-1-0.dll丢失
解决方案】
api-ms-win-crt-runtime 就是MFC的运行时环境的库，python在windows上编译也是用微软的visual studio C++编译的，底层也会用到微软提供的C++库和runtime库，安装Visual C++ Redistributable for Visual Studio 2015 组件即可解决此问题。
链接：https://www.microsoft.com/zh-cn/download/details.aspx?id=48145
点击直达
需要注意：安装前请删掉已有的 api-ms-win-crt-runtime-l1-1-0.dll（具体路径：C:\Windows\System32 和 C:\Windows\SysWOW64 检查下），vc_redit.exe安装完成会重新生成的！安装完后，如果不能正常启动MySQL Workbench，则重新启动一下电脑即可。
安装完后，重启电脑！
链接的时候还出现了Navicat 报错:1130-host ，
Navicat连接MySQL 8出现2059，貌似是5.0和8.0的密码这块的差异，没详细了解，下面有提到解决方法
安装流程
mysql-8.0.15-winx64 解压版安装 图文详解
1、官网下载
https://dev.mysql.com/downloads/mysql/
2、解压到合适的目录
3、配置环境变量
①、 path
②、MYSQL_HOME
4、新建一个my.ini 用记事本打开，复制以下代码， 没有my.ini 数据库启动时无法初始化参数
[mysql]
#;设置mysql客户端默认字符集
default-character-set=utf8
[mysqld]
#;设置3306端口
port = 3306
#; 设置mysql的安装目录
basedir=D:\home\MySql\mysql-8.0.16-winx64
#; 设置mysql数据库的数据的存放目录
datadir=D:\home\MySql\mysql-8.0.16-winx64\data
#; 允许最大连接数
max_connections=200
#; 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
#; 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c33d7fe56222d958e83434fcef97664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8728edec6f693b56da63f08275d67e1f/" rel="bookmark">
			使用Clang作为编译器 —— 使用 Clang 交叉编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Clang 交叉编译 1. 介绍2. 交叉编译问题(Cross compilation issues)3. Clang中的一般交叉编译选项(General Cross-Compilation Options in Clang)3.1 Target Triple3.2 CPU、FPU、ABI3.3 工具链选项 4. 特定目标的库(Target-Specific Libraries)5. Multilibs 本文为译文，点击 此处查看原文。 1. 介绍 本文档将指导您选择正确的 Clang 选项，以便将代码交叉编译到不同的体系结构。它假定您已经知道如何为主机体系结构编译相关代码，并且知道如何选择附加的include和库路径。
然而，这个文档不是一个“如何做”的文档，也不会帮助您设置build系统或Makefiles，也不会帮助您选择正确的 CMake 选项，等等。此外，它没有涵盖所有可能的选项，也没有包含特定架构的特定示例。对于一个具体的例子，交叉编译LLVM本身的说明可能会很有趣。
阅读本文之后，您应该熟悉与交叉编译相关的主要问题，以及 Clang 为执行交叉编译提供了哪些主要编译器选项。
2. 交叉编译问题(Cross compilation issues) 在 GCC 世界中，每个主机/目标(host/target)组合都有自己的一组二进制文件、头文件、库等。因此，通常很容易下载一个包含所有文件的包，解压缩到一个目录，然后将build系统指向该编译器，该编译器将知道其位置，并在编译代码时找到所需的所有内容。
另一方面，Clang/LLVM 本质上是一个交叉编译器，这意味着一组程序可以通过设置-target选项编译到所有目标。对于希望编译到不同平台和体系结构的程序员，对于只需要维护一个build系统的编译器开发人员，对于OS发布，只需要一组main包，这使得编译变得容易得多。
但是，与任何交叉编译器一样，考虑到不同体系结构、操作系统和选项的复杂性，要找到头文件、库或binutils来生成目标特定的代码并不总是那么容易。因此，您需要指定选项(options)来帮助 Clang 了解您要编译的目标、工具的位置等等。
另一个问题是编译器只附带标准库(如compiler-rt、libcxx、libgcc、libm等)，因此您必须找到并提供给构建系统，以及构建软件所需的每个特定于您的目标(target)的其他库。仅仅安装主机(host)的库是不够的。
最后，并不是所有的工具链(toolchains)都是相同的，因此，并不是每个 Clang 选项都能神奇地工作。有些选项，比如--sysroot(它可以有效地更改头文件和库的逻辑根)，假设所有二进制文件和库都在同一个目录中，当发行版的包管理安装了交叉编译器时，这可能不是真的。因此，对于每个特定的情况，您可以使用多个选项，并且在大多数情况下，您最终将手动设置include paths (-I)和library paths (-L)
综上所述，不同的工具链可能：
特定于 host/target 或更灵活放在一个目录中，或者分散在整个系统中默认情况下有不同的库集和头文件集需要特殊的选项，这是您的构建系统无法自己解决的 3. Clang中的一般交叉编译选项(General Cross-Compilation Options in Clang) 3.1 Target Triple 基本选项是定义目标体系结构。为此，使用-target &lt;triple&gt;。如果不指定目标，CPU 名称将不匹配（因为 Clang 假设host triple），编译将继续进行，为主机平台创建代码，稍后在汇编或链接时代码将中断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8728edec6f693b56da63f08275d67e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/622c21495955729d46b13569e50a5058/" rel="bookmark">
			Win10 蓝牙已配对但无法连接的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10 蓝牙已配对但无法连接的问题 今天打开笔记本，发现ikbc的dc87键盘的蓝牙怎么也连不上，尝试了在蓝牙设置和设备管理器里删除该设备，后再重新配对，然而无法解决。
sigh… 好吧，决定开始排查问题：
键盘恢复出厂设置，重新请求配对时，win10里的设备列表里已经显示有配对的键盘：HM_KBxairpods能连上电脑，排除了笔记本蓝牙硬件问题键盘能连上手机，排除了键盘蓝牙硬件问题 至此，可以判断出是win10系统的问题。问题比较奇葩，我的推断是在win10里没法彻底删除蓝牙设备，其中的现象是我在蓝牙设置删除了HM_KBx后，随后隔几秒钟HM_KBx又出现在列表中，显示的是已配对。
然后找到了这篇救命文章：How to completely remove a Bluetooth device from Win 10? 里面的人也是类似问题，跟着下面的Solution执行一遍，把所有已配对的设备删除之后，再重新配对键盘，fixed！
wouldn’t normally necro a thread but i spent two weeks trawling the
internet trying to sort this out and this thread is pretty high up on
the search rankings, hopefully can help someone.
My symptoms:
Previously working bluetooth speaker (UE BOOM 2 in my case) stops connectingWindows 10 ‘Bluetooth and other devices’ menu shows the device as PairedPressing connect makes it attempt to connect but fails then it goes back to PairedRemove device hides the device from the menu, but as soon as you turn bluetooth on and off, or restart the computer, the device comes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/622c21495955729d46b13569e50a5058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e2cd21dd82cecaed84e88ba6881aaf1/" rel="bookmark">
			csv文件、ini文件处理、序列化和反序列化、json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.CSV文件 逗号分割值Comma-Separeted-Values
CSV是一个被行分隔符、列分隔符划分成行和列的文本文件。CSV不指定字符编码。
行分隔符为\r\n,最后一行可以没有换行符。
列分隔符为逗号或制表符
每一行都称为一条记录record
字段可以使用双引号括起来，也可以不使用，如果字段中出现了双引号、逗号、换行符必须使用双引号括起来，如果字段的值是双引号，使用两个双引号表示一个转义。
表头可选，和字段列对齐就行了。
1.1 手动生成CSV文件 from pathlib import Path import csv p1 = Path('c:/my.csv') # csv文件 csv_body = """\ id,name,age,comment 1,tom,20,"i am 20" 2,jerry,18,"(""123"")" 3,ben,28,"这是 一 段 中文 " """ # with p1.open('w+') as f: # f.write(csv_body) with p1.open() as f: body = csv.reader(f) for line in body: print(line) # csv存在的问题就是无法确定字段的数据类型 1.2CSV模块 reader(csvfile, dialect=‘excel’, **fmtparams)
返回reader对象，是一个迭代器。
默认使用excel方言，如下：
dilimiter列分隔符，逗号
lineterninator行分隔符\r\n
quotechar字段的引用符号，缺省为"双引号
双引号的处理：
doublequote双引号的处理，默认为True，如果碰到数据中有双引号，而quotechar也是双引号，True则使用两个双引号表示，False表示使用转义字符作为双引号的前缀。
escapechar一个转义字符，默认为None
write = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e2cd21dd82cecaed84e88ba6881aaf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d9101dc086d680b59e2488bc57f3aa/" rel="bookmark">
			java.lang.IllegalArgumentException: object is not an instance of declaring class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java反射的时候报错。
原因是因为没有实例化一个类
setMethod.invoke(t, new Object[]{columnValue}); 这一行报错。
应该继承泛型类的空构造方法
setMethod.invoke(clazz.newInstance(), new Object[]{columnValue}); OK，这样就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304c2b0ace7265d5468d19612a93c9a6/" rel="bookmark">
			吴恩达-deeplearning-第四课卷积神经网络-第四周 课程笔记 神经风格转换与人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程来源：网易云课堂与coursera
一、神经风格转化 1、理论 问题描述：给定一张需要转化的内容图像（C）一张想要转化成的风格的图像（S），通过无监督学习的方法将其转化为有S风格的内容图像G。
解决方案：对C、S、G三个图像定义一个损失函数J，在对损失函数的优化过程中完成对G的训练，也就是说C、S是固定输入，G是通过训练优化的参数。 损失函数J分为两个部分：内容损失函数，与C、G有关；风格损失函数，与S、G有关。内容损失函数定义：C图像的某一层的卷积输出与G图像的某一层的卷积输出的相似程度，公式如下，C和G的大小都是（nH，nW，nC），a表示某一层激活层的输出：
J c o n t e n t ( C , G ) = 1 4 × n H × n W × n C ∑ all entries ( a ( C ) − a ( G ) ) 2 J_{content}(C,G) = \frac{1}{4 \times n_H \times n_W \times n_C}\sum _{ \text{all entries}} (a^{(C)} - a^{(G)})^2 Jcontent​(C,G)=4×nH​×nW​×nC​1​all entries∑​(a(C)−a(G))2风格损失函数定义：定义Gram matrix表示图像的风格表征，也就是下面公式中的Gij。计算图像S和图像G各自风格表征的接近程度。
J s t y l e ( S , G ) = ∑ l λ [ l ] J s t y l e [ l ] ( S , G ) J_{style}(S,G) = \sum_{l} \lambda^{[l]} J^{[l]}_{style}(S,G) Jstyle​(S,G)=l∑​λ[l]Jstyle[l]​(S,G)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/304c2b0ace7265d5468d19612a93c9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a097f922e498d2724f5d0b31565aa6f/" rel="bookmark">
			Matlab横向colorbar【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ch = colorbar('horiz');% 横向坐标轴
set(get(ch,'title'),'string','[m]','position',[590 -15]);% title的位置，590代表左右，-15代表上下，可以不加position发现默认位置在colorar中间
set(ch,'position',[0.135 0.075 0.75 0.015],'ticks',(-1:0.2:1),'ticklength',0.015,'fontsize',12,...
'ticklabels',{'&lt;-1.0',(-0.8:0.2:0.8),'&gt;1.0'}) % colorbar的位置，[左 下 宽 高]
转载：http://blog.sciencenet.cn/home.php?mod=space&amp;uid=3386114&amp;do=blog&amp;quickforward=1&amp;id=1163914
转载于:https://www.cnblogs.com/liupeng23/p/10963157.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18faedbbadc277883e71c689db9a074/" rel="bookmark">
			QT connect()连接函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数重载：
连接函数后多种重载方法，常用的有：
函数4个参数：发射信号的对象，发射的信号，接受信号的对象，要执行的槽；
//按键单击信号连接到按键槽函数 //方法1： connect(ui-&gt;pushButton,SIGNAL(clicked(bool)),this,SLOT(on_pushButton_clicked())); //方法2： connect(ui-&gt;pushButton,&amp;QPushButton::clicked,this,&amp;Widget::on_pushButton_clicked); 1：首先要链接的两个类必须继承于QObject，同时添加Q_OBJECT。
2：在QT中的QObject ::连接中填写的信号和槽函数，一定要填写参数类型。
因为类中的函数可以，也就是，重载函数名一样，参数不一样，如果的QObject ::连接中的函数没有参数类型，则无法正确连接
3：QObject :: connect中的signal和slot函数一定要有参数类型，但是，不可以有参数：
指定信号和方法时，必须使用SIGNAL（）和SLOT（）宏，例如：
QLabel *label = new QLabel; QScrollBar *scrollBar = new QScrollBar; QObject::connect(scrollBar, SIGNAL(valueChanged(int)), label, SLOT(setNum(int))); 此示例确保标签始终显示当前滚动条值。请注意，signal和slots参数不能包含任何变量名，只能包含类型。例如，以下不起作用并返回false：
// WRONG -- 必须有参数类型，但是不能有变量名 QObject::connect(scrollBar, SIGNAL(valueChanged(int value)), label, SLOT(setNum(int value))); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f17c67b54f69bccaf8cf33bd321b6aa/" rel="bookmark">
			QT qrand()随机函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Qt中，生成随机数的函数为 qrand()。该函数是标准C++函数 rand 的线程安全版本。
如果我们仅仅只是调用该函数来生成随机数，那么每次得到的随机数都将是相同的，这是因为Qt生成的随机数严格来说是一个“伪随机”，它的产生是根据随机数种子计算得到的。如果种子相同，那么所得到的随机数也是相同的。因此，为了使我们的随机数看起来更为“随机”一些，我们在每次获取随机数之前都需要初始化一个不同的随机数种子，这就需要用到qsrand()函数，该函数只有一个整型参数，即要设置的随机数种子。
函数原型
void qsrand(uint seed);
int qrand();
QT生成随机数和C语言差距不大，C语言用srand（）和rand（），QT是用Qsrand（）和qrand（）；
QT生成随机数的格式是：
qsrand(QTime(0,0,0).secsTo(QTime::currentTime())); qrand(); 注意：qsrand用来设置一个种子，该种子为qrand生成随机数的起始值。如果不用qsrand设置种子会导致每次运行程序得到的随机数
一样。
例子：
//使用了一个 label 和 pushButton
#include &lt;QTime&gt; //使用了QTime函数 #include &lt;QtGlobal&gt; //qsrand和qrand这两个函数在这里面 void Widget::on_pushButton_clicked() { //在这个示例里，每次点击按钮就在标签显示一个随机数 qsrand(QTime(0,0,0).secsTo(QTime::currentTime())); //设置随机数种子 int rand = qrand() % 10; //产生十以内的随机数(0-9) ui-&gt;label-&gt;setText(tr("产生的随机数：%1").arg(rand)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7fd19baa4fdc92b30e5c588c5a60dab/" rel="bookmark">
			Linux 十四 修改文件操作权限 用户文件权限详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux 权限ls -l 中显示的内容如下：0-9位说明rwx权限详解 ls -l 文件目录权限解析案例 Linux 权限管理chmod 改变权限chown 改变所有者chgrp 改变所属组 Linux 权限 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组。
从左到右的10个字符表示，如图1-154所示：
如果没有权限，就会出现减号[- ]而已。从左至右用0-9这些数字来表示:
ls -l 中显示的内容如下： -rwxrw-r-- 1 root police 1213 Feb 2 09:39 abc.txt 0-9位说明 第0位确定文件类型(说明: -:普通文件, d:目录，l : 连接文件, c: 字符设备文件[键盘,鼠标] b:块设备文件[硬盘] )第1-3位确定所有者（该文件的所有者）拥有该文件的权限。R: 读 ， w : 写权限 x: 执行权限第4-6位确定所属组（同用户组的）拥有该文件的权限第7-9位确定其他用户拥有该文件的权限1: 如果是文件，表示硬链接的数目， 如果是目录，则表示有多少个子目录1213： 表示文件大小，如果是目录，则统一为 4096 rwx权限详解 rwx作用到文件(重要)
[ r ]代表可读(read): 可以读取,查看[ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.[ x ]代表可执行(execute):可以被执行 rwx作用到目录(重要)
[ r ]代表可读(read): 可以读取，ls查看目录内容[ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录[ x ]代表可执行(execute):可以进入该目录 ls -l 文件目录权限解析案例 -rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc 10个字符确定不同用户能对文件干什么
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7fd19baa4fdc92b30e5c588c5a60dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5347804bd1a05e7c7b307a9c8488471a/" rel="bookmark">
			C# 反射调用方法与特性调用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些高级的开源项目中通常会使用到反射和打特性，如果对于c#初级的程序员第一眼看到肯定一脸懵逼，我以前也是这样过来的所以今天公司没啥事情可以干，就写一下笔记 ，unity 开源项目ET（以前看et项目时只知道原理不知其中的代码所以今天自已实现一下原理） 中就使用了这种方式实现。在此我解析一下反射与自定义特性的主要功能（反射网上搜索一大堆这里主要是介绍自定义特性的与反射结合使用的好处）：
反射：反射就是通过加载程序集（什么是程序集，程序集就是一个文件，一个存放了IL语句的dll，它可以是C#所有的语法或者说一个项目中所有的cs文件，打包成IL语言，在此我们不学习IL语法只知道它是什么）获取类（class）再获取类中的属性、方法、字段；
所以下面主要实现的功能是 例子 一： 通过反射调用方法
自定义 一个 类（可以是抽象类也可以是普通类）
//命名空间 namespace ConsoleApp1 { //一个基类 abstract class Game { public virtual void start() { } public virtual void updata() { } } //继承Game class Compent : Game { public override void start() { Console.WriteLine("my start"); } public override void updata() { Console.WriteLine("updata"); } } } 然后在主线程中解析程序集调用方法
namespace ConsoleApp1 { class Program { //存放所有继承Game的子类 private static List&lt;Game&gt; Games = new List&lt;Game&gt;(); //是否退出 private static bool isexit = false; static void Main(string[] args) { //获取程序集所有的类 Type[] types = typeof(Program).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5347804bd1a05e7c7b307a9c8488471a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204b92c53821ea8cd2e4ec5dda7b002e/" rel="bookmark">
			解决JsonResponse接口返回值中文是乱码的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.初学Django，写了一个接口，但是返回值中文为乱码
2.views.py代码为
from django.http import JsonResponse from django.views.decorators.csrf import csrf_exempt @csrf_exempt def test_api(request): return JsonResponse({"result": 0, "msg": "成功"}) 3.解决方法，
JsonResponse({"result": 0, "msg": "成功"},charset='utf-8') from django.http import JsonResponse from django.views.decorators.csrf import csrf_exempt @csrf_exempt def test_api(request): return JsonResponse({"result": 0, "msg": "成功"},charset='utf-8') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c8192de89d31957c2cac2838d4282ab/" rel="bookmark">
			社交网络与社会计算课程内容梳理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 引言2 复杂网络的图要素3 复杂网络度量4 复杂网络模型5 网络表示学习6 主题模型 1 引言 社会计算是指社会科学和计算技术交叉融合而成的一个研究领域，研究如何利用计算系统帮助人们进行沟通与协作，研究如何利用计算技术分析社会运行的规律与发展趋势，即以社交网络和社会媒体为研究对象，从中发现社会关系、社会行为的规律。
社会计算的研究内容包括：
社交网络服务，包括：社会关系强度、信息的绝对价值和相对价值、新鲜事排序算法、隐私性以及社会化搜索；内容计算，包括：舆情分析、人际关系挖掘、微博应用；群体智慧，比如百度百科和维基百科。 社会计算的研究理论工具：
从数学和社会心理学等其他学科借鉴来的理论，比如图论、平衡论、社会比较理论、六度分割理论、150定律；本源的社会网络理论，比如异质性理论、结构角色理论；网络时代大数据的研究方法 社会媒体是指互联网上基于用户关系的内容生产与交换平台，其特点有：1）多对多；2）丰富的用户交互特性。
社会媒体数据通常用图或者矩阵的形式进行表示。现实世界中的大规模网络往往具有一些共同的性质：无标度分布、小世界效应、强社区结构。
社会媒体挖掘的意义：
社会媒体挖掘研究将是推动社会学与信息科学交叉发展的着力点；社会媒体数据研究已经成为提高国家信息产业科学化水平和舆情态势感知能力的支撑点；社会媒体挖掘是引领新型互联网经济发展的制高点。 社会媒体挖掘的挑战：
可扩展性；混杂性；演化；集体智慧 本课程关注的社会计算任务：
社区发现与演化分析，包括1）如何发现社区？2）社区结构时如何演化的？3）怎样评价发现的社区；信息传播与影响建模，包括1）如何建模社会媒体上的信息扩散？如何挖掘社会媒体上的关键节点？3）用户间是如何相互影响的？4）如何求解影响最大化问题？5）如何对网络传播进行追踪溯源？6）如何预测信息热度？兴趣发现与推荐系统，包括1）经典的推荐算法有哪些？2）基于社会媒体的推荐系统如何构建？3）如何评价推荐系统的性能？话题发现与演化追踪，包括1）话题发现的模型和算法有哪些？2）话题演化的模型和算法有哪些？3）如何应对大规模、动态、多源数据的挑战？链接预测与网络推断，包括1）链接预测的基本方法有哪些？2）异质社会媒体上连接预测如何实现？3）网络推断的效果如何评价？行为分析与建模预测，包括：如何刻画用户的采纳和忠诚程度？2）如何建模用户个体的使用行为？3）如何建模用户群体的互动行为？社会媒体的情感分析、任务分析、安全、可视化，等等。 2 复杂网络的图要素 复杂网络是指那些结构复杂、无规则、随时间动态变化的网络。
哥尼斯堡七桥问题：只有当图中度为奇数的顶点不超过两个，这样的路径才存在。
图的基础知识：
节点与边；有向边与有向图；邻居；度和度的分布 图的表示：
邻接矩阵；邻接表；边列表 图的类型：
零图和空图；有向图、无向图、混合图；简单图与多重图；带权图；标号图 通路是指依次遍历相邻边产生的边序列，分为开通路和闭通路。通路可以用边序列或者节点序列表示。通路的长度是指经过的边的数量。边不重复的通路称为简单通路，闭合的简单通路称为环路。节点和边都不重复的通路称为路径，闭合的路径称为回路。欧拉环路是指图中所有边均只被遍历一次的环路，哈密尔顿回路是指遍历了图中所有节点的回路。如下图所示：
图的连通性：如果节点 v i v_i vi​和节点 v j v_j vj​之间有路径连接，那么称节点 v i v_i vi​可连接到节点 v j v_j vj​，即可达。无向图的可达性对称，有向图的可达性不一定对称。任意节点相互可达的有向图称为强联通有向图，不考虑相互约束，称为弱连通有向图。同理可以基于子图和连通性定义连通分支、强连通分支和弱连通分支。
最短路径可以使用Dijstra算法和Prim算法进行求解。
图的直径是指任意两个节点之间距离中的最大值。图的平均距离是指图中所有节点对的距离的平均值。
特殊图包括：树、森林、生成树、完全图、平面图、二分图、正则图
图算法：最大流算法、Prim算法、Dijstra算法。
3 复杂网络度量 度中心性认为具有更多链接关系的节点具有更高的中心性，我们可以使用最大可能度数(n-1)、最大度数、度数和对度中心性进行归一化。
特征向量中心性是度中心性的一种扩展，其试图通过结合无向图中的邻居节点的重要性来修正度中心性，计算如下： c e ( v i ) = 1 λ ∑ j = 1 n A j , i c e ( v j ) c_{e}\left(v_{i}\right)=\frac{1}{\lambda} \sum_{j=1}^{n} A_{j, i} c_{e}\left(v_{j}\right) ce​(vi​)=λ1​∑j=1n​Aj,i​ce​(vj​)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c8192de89d31957c2cac2838d4282ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c7e65de2efb11a6cd55e8a104fb74f/" rel="bookmark">
			Python3.7 环境下安装wxPython教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3.7环境下安装wxPython教程 我的环境安装步骤运行代码和结果 我的环境 我的安装环境：
系统： Windows10专业版；Python版本： Python3.7；
wxpython版本： ：wxPython 4.0.6；
安装步骤 下载wxpython安装包
确定你的Python版本，比如我这里是Python3.7，到官网
wxPython-4.0.6-cp37
下载对应的wxpython安装包，我这里下载的是wxPython-4.0.6-cp37-cp37m-win_amd64.whl这个版本。
注意：有同学私信我whl文件，恰好我没将它删除。现已经将实示例的whl文件，上传我的资源中心，免费下载（安装使用后请删除源文件，不可用于商业行为！！！）
或者 点击这里 wxPython4的目录（包含所有版本） 🤣🤣take whatever
you want.
注意：wxpython的版本一直在更新，所以下载最新版本就行了。另外，不要去其他的小网站下载这些whl文件，很容易出错，有官方就去官方的。
安装wxpython
（1）anaconda环境下安装
我电脑上安装了anaconda环境，其实和非anaconda环境没什么区别，只不过路径要注意。
其中，base这个虚拟环境就是Python3.7的，那我在Python3.7下安装wxpython，首先把下载好的wxPython-4.0.6-cp37-cp37m-win_amd64.whl文件拷贝到Python3.7环境的Scripts目录下面，然后启动命令行，进入到Python3.7环境的Scripts目录，执行命令：pip install wxPython-4.0.6-cp37-cp37m-win_amd64.whl
安装成功。
（2）非anaconda环境
也是下载好对应的wxpython安装包，把下载好的whl文件拷贝到PythonX.X环境的Scripts目录下面，然后启动命令行，进入到PythonX.X环境的Scripts目录，执行命令：pip install XXX.whl
运行代码和结果 这时候打开pycharm，把下面的代码复制进去。
// 一个简单的demo import wx app = wx.App() window = wx.Frame(None, title="wxPython", size=(400, 300)) panel = wx.Panel(window) label = wx.StaticText(panel, label="Hello World", pos=(100, 100)) window.Show(True) app.MainLoop() 运行结果：
至此，就完成啦！
图形界面安排辽！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88acdd260aac4ffc60e53922650051b3/" rel="bookmark">
			UmiJS CDN 部署之 publicPath
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 静态资源在非根目录或 cdn 这时，就需要配置 publicPath。至于 publicPath 是啥？具体看 webpack 文档，把他指向静态资源（js、css、图片、字体等）所在的路径。
export default { publicPath: "http://yourcdn/path/to/static/" } 使用 runtime 的 publicPath 对于需要在 html 里管理 publicPath 的场景，比如在 html 里判断环境做不同的输出，可通过配置 runtimePublicPath 为解决。
export default { runtimePublicPath: true, }; 然后在 html 里输出：
&lt;script&gt; window.publicPath = &lt;%= YOUR PUBLIC_PATH %&gt; &lt;/script&gt; https://umijs.org/zh/guide/deploy.html
转载于:https://my.oschina.net/leili/blog/3055880
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6565506cc3acdae4d630677d7b6c3eb/" rel="bookmark">
			Knative 核心概念介绍：Build、Serving 和 Eventing 三大核心组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 阿里云智能事业群高级开发工程师 元毅
划重点
初识 Knative: 跨平台的 Serverless 编排框架 让我们对于 Knative 有了初步了解，Knative 主要由 Build、Serving 和 Eventing 三大核心组件构成。Knative 正是依靠这三个核心组件，驱动着 Knative 这艘 Serverless 巨轮前行，本文就来分别介绍一下这三个核心组件。
Build
Knative Build 是基于现有的 Kubernetes 能力之上，提供的一套标准化、可移植、可复用的容器镜像构建方式。通过在 Kubernetes 上运行复杂的构建任务，Knative Build 使你不必再单独开发和重复这些镜像构建过程， 从而通过系统化、工程化的方式，减少了镜像构建时间及成本。
Build 通过 Kubernetes 自定义资源定义(CRD)实现。 通过 Build 你可以自定义一个从运行到结束的构建流程。例如，可以使用 Knative Build 来获取、构建和打包代码。Build 具备以下功能：
支持 Source 源挂载，目前支持的 Source 源包括：
* git 代码仓库
* 任意容器镜像
支持通过 BuildTemplate 创建可重复执行构建的模板
支持 K8s ServiceAccount 身份验证
典型的 Build 示意图：
虽然目前 Knative Build 并不提供完整的独立 CI/CD 解决方案，但它却提供了一个底层的构建模块，用户可单独使用该构建模块在大型系统中实现集成和利用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6565506cc3acdae4d630677d7b6c3eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd7a33a90a3f7394803f17e1df6e894/" rel="bookmark">
			解决 aka com.chaozh.iReader:style/Theme.AppCompat.Light.NoActionBar) not found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们项目本来是可以编译通过的，但是自从接入了DoraemonKit 之后，就编译不通过。
报错如下：
error: resource style/Theme.AppCompat.NoActionBar (aka com.chaozh.iReader:style/Theme.AppCompat.NoActionBar) not found. error: resource style/Theme.AppCompat.Light.NoActionBar (aka com.chaozh.iReader:style/Theme.AppCompat.Light.NoActionBar) not found. error: resource style/Widget.AppCompat.Light.ActionBar.Solid (aka com.chaozh.iReader:style/Widget.AppCompat.Light.ActionBar.Solid) not found. AGPBI: {"kind":"error","text":"error: style attribute \u0027attr/titleTextStyle (aka com.chaozh.iReader:attr/titleTextStyle)\u0027 not found.","sources":[{"file":"F:\\git\\iReader_vivo\\iReader\\src\\main\\res\\values\\style_overwrite.xml","position":{"startLine":12,"startColumn":4,"startOffset":565,"endLine":14,"endColumn":12,"endOffset":762}}],"original":"","tool":"AAPT"} AGPBI: {"kind":"error","text":"error: style attribute \u0027attr/contentInsetStart (aka com.chaozh.iReader:attr/contentInsetStart)\u0027 not found.","sources":[{"file":"F:\\git\\iReader_vivo\\iReader\\src\\main\\res\\values\\style_overwrite.xml","position":{"startLine":12,"startColumn":4,"startOffset":565,"endLine":14,"endColumn":12,"endOffset":762}}],"original":"","tool":"AAPT"} AGPBI: {"kind":"error","text":"error: style attribute \u0027attr/contentInsetEnd (aka com.chaozh.iReader:attr/contentInsetEnd)\u0027 not found.","sources":[{"file":"F:\\git\\iReader_vivo\\iReader\\src\\main\\res\\values\\style_overwrite.xml","position":{"startLine":12,"startColumn":4,"startOffset":565,"endLine":14,"endColumn":12,"endOffset":762}}],"original":"","tool":"AAPT"} error: resource style/TextAppearance.AppCompat.Widget.ActionBar.Title (aka com.chaozh.iReader:style/TextAppearance.AppCompat.Widget.ActionBar.Title) not found. error: resource style/Widget.AppCompat.ActionMode (aka com.chaozh.iReader:style/Widget.AppCompat.ActionMode) not found. AGPBI: {"kind":"error","text":"error: style attribute \u0027attr/background (aka com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd7a33a90a3f7394803f17e1df6e894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8019fc41f99fe353c0fa63bce3865a6/" rel="bookmark">
			小程序事件传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 button绑定事件：
&lt;button size="default" type="primary" plain="true" bindtap="send" data-id="{{id}}" data-read-id="{{readId}}"&gt;事假传参&lt;/button&gt; 传递参数：
send(e) { console.log(e); console.log(e.currentTarget.dataset.id); console.log(e.currentTarget.dataset.readId); var id = e.currentTarget.dataset.id; var readId = e.currentTarget.dataset.readId; wx.navigateTo({ url: '../index/index-item/index-item?readId=' + readId + '&amp;id=' + id }) }, 接受参数：
&lt;view&gt;{{readId}}&lt;/view&gt; js：
onLoad: function(options) { console.log(options);//通过options获取所有传过来的所有参数 var readId = options.readId; this.setData({ readId: readId }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e40e41a364f4cb078b6eff915369305/" rel="bookmark">
			什么是虚拟机（virtual machine）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机（virtual machine ）是一种说明计算机硬件和软件关系的有效方法。
在安德鲁 · 塔嫩鲍姆（Andrew Tanenbaum）的书《结构化计算机组织》（Structured Computer Organization）中可以找到对这个模型广为人知的解释。要说明这个概念，先从计算机的最基本功能开始，即执行程序。
计算机通常可以执行用其原生机器语言编写的程序。这种语言中的每一条指令都简单到可以用相对少量的电子电路来执行。为了简便，称这种语言为 L0。
由于 L0 极其详细，并且只由数字组成，因此，程序员用其编写程序就非常困难。如果能够构造一种较易使用的新语言 L1，那么就可以用 L1 编写程序。有两种实现方法：
解释（Interpretation）：运行 L1 程序时，它的每一条指令都由一个用 L0 语言编写的程序进行译码和执行。L1 程序可以立即开始运行，但是在执行之前，必须对每条指令进行译码。翻译（Translation）：由一个专门设计的 L0 程序将整个 L1 程序转换为 L0 程序。然后，得到的 L0 程序就可以直接在计算机硬件上执行。 虚拟机 与只使用语言描述相比，把每一层都想象成有一台假设的计算机或者虚拟机会更容易一些。通俗地说，虚拟机可以定义为一个软件程序，用来模拟一些其他的物理或虚拟计算机的功能。
虚拟机，将其称为 VM1，可以执行 L1 语言编写的指令。虚拟机 VM0 可以执行 L0 语言编写的指令：
每一个虚拟机既可以用硬件构成也可以用软件构成。程序员可以为虚拟机 VM1 编写程序，如果能把 VM1 当作真实计算机予以实现，那么，程序就能直接在这个硬件上执行。否则，用 VM1 写出的程序就被翻译 / 解释为 VM0 程序，并在机器 VM0 上执行。
机器 VM1 与 VM0 之间的差异不能太大，否则，翻译或解释花费的时间就会非常多。如果 VM1 语言对程序员来说还不够友好到足以用于应用程序的开发呢？
可以为此设计另一个更加易于理解的虚拟机 VM2。这个过程能够不断重复，直到虚拟机 VMn 足够支持功能强大、使用方便的语言。
Java 编程语言就是以虚拟机概念为基础的。Java 编译器把用 Java 语言编写的程序翻译为 Java 字节码（Java byte code）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e40e41a364f4cb078b6eff915369305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a738dbfae4a69f885cb8d7be874dccf3/" rel="bookmark">
			【MQTT学习】lesson6.详解 QoS0 和 QoS1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的课程中我们多次提到了 QoS（Quality of Service）的概念，CONNECT、PUBLISH、SUBSCRIBE 中都有 QoS 的标识，那么 MQTT 提供的 QoS 是什么呢？本节课核心内容：
MQTT 中的 QoS 等级QoS0QoS1代码实践 6.1 MQTT 中的 QoS 等级
作为最初用来在网络带宽窄、信号不稳定的环境下传输数据的协议，MQTT 设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次 QoS：
QoS0，At most once，至多一次；QoS1，At least once，至少一次；QoS2，Exactly once，确保只有一次。 什么意思呢，QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：
QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，但是因为重传的原因，Receiver 有可能会收到重复的消息；QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。 要注意的是，QoS 是 Sender 和 Receiver 之间达成的协议，不是 Publisher 和 Subscriber 之间达成的协议。也就是说 Publisher 发布一条 QoS1 的消息，只能保证 Broker 能至少收到一次这个消息；至于对应的 Subscriber 能否至少收到一次这个消息，还要取决于 Subscriber 在 Subscribe 的时候和 Broker 协商的 QoS 等级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a738dbfae4a69f885cb8d7be874dccf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e307806f4dca7e3eb78bcb8e7a5bad/" rel="bookmark">
			Prometheus学习系列（十三）之配置解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prometheus通过命令行标志和配置文件进行配置。 虽然命令行标志配置了不可变的系统参数（例如存储位置，保留在磁盘和内存中的数据量等），但配置文件定义了与抓取作业及其实例相关的所有内容，以及哪些规则文件 载入。
要查看所有可用的命令行参数，执行./prometheus -h
Prometheus可以在运行时重新加载其配置。 如果新配置格式不正确，则不会应用更改。 通过向Prometheus进程发送SIGHUP或向/-/reload端点发送HTTP POST请求（启用--web.enable-lifecycle标志时）来触发配置重新加载。 这也将重新加载任何已配置的规则文件。
一、配置文件 要指定要加载的配置文件，请使用--config.file标志。
该文件以YAML格式编写，由下面描述的方案定义。 括号表示参数是可选的。 对于非列表参数，该值设置为指定的默认值。
通用占位符定义如下：
&lt;boolean&gt;：一个可以取值为true或false的布尔值&lt;duration&gt;：与正则表达式匹配的持续时间[0-9] +（ms | [smhdwy]）&lt;labelname&gt;：与正则表达式匹配的字符串[a-zA-Z _] [a-zA-Z0-9 _] *&lt;labelvalue&gt;：一串unicode字符&lt;filename&gt;：当前工作目录中的有效路径&lt;host&gt;：由主机名或IP后跟可选端口号组成的有效字符串&lt;path&gt;：有效的URL路径&lt;scheme&gt;：一个可以取值http或https的字符串&lt;string&gt;：常规字符串&lt;secret&gt;：一个秘密的常规字符串，例如密码&lt;tmpl_string&gt;：在使用前进行模板扩展的字符串 其他占位符是单独指定的。
可以在此处找到有效的示例文件。
全局配置指定在所有其他配置上下文中有效的参数。 它们还可用作其他配置节的默认值。
global: # 默认情况下抓取目标的频率. [ scrape_interval: &lt;duration&gt; | default = 1m ] # 抓取超时时间. [ scrape_timeout: &lt;duration&gt; | default = 10s ] # 评估规则的频率. [ evaluation_interval: &lt;duration&gt; | default = 1m ] # 与外部系统通信时添加到任何时间序列或警报的标签 #（联合，远程存储，Alertma# nager）. external_labels: [ &lt;labelname&gt;: &lt;labelvalue&gt; ... ] # 规则文件指定了一个globs列表.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e307806f4dca7e3eb78bcb8e7a5bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb55776bde4fb8d8ecdd87627935c6c/" rel="bookmark">
			AD15 从原理图导入PCB stm32芯片管脚全部为绿色叉解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 显示绿色叉表示该处的焊盘间距不符合你之前设定的导线间距规则。（也有可能是没有专门设定该芯片本身的规则） 解决建议： 1. 进入PCB界面，键盘 d+r ,进入规则设置界面 上图中 _inpoly是覆铜规则，_U10是针对U10芯片（stm32芯片对应的标号）的规则，如果没有可以新建。 2. 进入_U10的界面 修改 “全部查询语句” 下方为 “InComponent('这里写自己芯片的标识！')” ，下方最小间隔改为6mil，然后点确定。 3. 重新编译和更新PCB。 （工程-Recompile PCB....）or（设计-update schematics...） 注：如果recompile和update没有效果，可以考虑重新从原理图导入，可以解决该问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f94f457b9c86eadf9b5907cb0e186e1/" rel="bookmark">
			layui表格（table）操作与form操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;table class="layui-hide" id="test" lay-filter="table"&gt;&lt;/table&gt;
操作
&lt;script type="text/html" id="toolBar"&gt;
&lt;a class="layui-icon" style="font-size: 25px; color: #1AA094;" lay-event="edit"&gt;&amp;#xe642;&lt;/a&gt;
&lt;a class="layui-icon" style="font-size: 25px; color: #1AA094;" lay-event="del"&gt;&amp;#xe640;&lt;/a&gt;
&lt;script type="text/javascript"&gt; layui.use(['form','layer','table','upload'], function(){ var table = layui.table ,form = layui.form, upload = layui.upload, layer=layui.layer; table.render({ elem: '#test' ,url:'manager/store/list' ,cellMinWidth: 80 ,cols: [[ {type:'numbers'} ,{field:'storeName', title:'店铺名'} ,{fixed: 'right',title: '操作', width:180, align:'center', toolbar: '#toolBar'} //绑定tpl表达式 ]] ,page: true //开启分页 ,id: 'testReload' //这个id挺重要的 你对table做操作时候需要使用到 比如reload的时候 }); &lt;!-- 这是表格查询的 这里根据店铺名和用户昵称还有手机号码查询 查询框自己任意放位置 这里注意的方法是 table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f94f457b9c86eadf9b5907cb0e186e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f7e43d5d02b7210e1bf5b58da844e6c/" rel="bookmark">
			向数据库中插入数据的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库中，向数据库中插入数据，使用insert into关键字。在数据库中插入数据有三种方法。
1）插入单个字段的情况
insert into table_name(列名) values(值);
2）插入多个字段的情况
2.1） 插入两个字段以上
insert into table_name(列名1，列名2，列名3,) values(值1,值2，值3);
2.2）插入全部所有字段
insert into table_name values(值1，值2，值3);//值要和表中的字段顺序类型一致
3）使用子查询向表中插入数据
insert into table_name 子查询select语句;//需要注意的是不能违反表table_name的约束条件，以及需要和table_name的字段一致，或者少于它，但是不能多于它。
转载于:https://www.cnblogs.com/jasonboren/p/10921377.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206d1584e9b0e2ee61db9d9f710471e2/" rel="bookmark">
			httpclient中文乱码返回Unicode解决方法之一(参考)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 发现用EntityUtils用toString方法utf-8编码并不起作用，最后用JSONObject.parseObject试了一波ok了 Apache httpclient乱码返回entity，解决方法： 用 org.apache.http.util包下的EntityUtils类 entity = EntityUtils.toString(response.getEntity(), "GBK"); JSONObject json = JSONObject.parseObject(entity); 这样就ok了，获取到的json就是unicode之后的了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32dfcf1511735810549464114da82a71/" rel="bookmark">
			zabbix的自定义监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程和日志 有的时候zabbix提供的监控项目，不能满足我们生产环境下的监控需求，此时我们就要按照zabbix的规范自定义监控项目，达到监控的目的 zabbix_get:模拟zabbix_server和agent获取数据 相关概念 item: Items是从agnet主机里面获取的所有数据。通常情况下我叫itme为监控项,item由key+参数组成Key：我们可以理解为key是item的唯一标识，在agent端有很多监控项，zabbix-server根据key区分不同的监控项trigger：触发器是建立在item数据上的，具有阈值触发事件的功能
基本格式: :.()}
server:agent名称，加入主机时配置的
key：就是上面说的key
function：对阈值进行操作的函数，以下函数
operate：表达式
constant：常量 例如：{docker02:proc.mysql.last()}&lt;&gt;1
不用担心trigger表达式不好写，在定义好item后，在zabbix点点就自动生成了 zabbix_get -s 192.168.161.67 -k ckproc[postfix] 3 # -s:指定agent地址 # -p：agent端口 # -k：指定item的key # [postfix]:向脚本传递的参数(用逗号分隔) 下面以监控postfix服务进程为例，做了自定义监控 1. zabbix_server与zabbix_agent zabbix_server通过发送key给zabbix_agent,然后agent端口根据key，把所要监控的item的最新数据返回给server端 2. 自定义监控项 自定义脚本格式 key[*],[command|sh] # &lt;key[参数]&gt;，&lt;命令或者脚本&gt; # [*]：固定格式，表示server端是否传过来参数，在命令或者脚本中用$1,23...引用，shell脚本中的引用$$1,2,3..引用， # 如果server端不传参数，[*]可以不写 2.1 修改agent端配置文件，自定义key vim /usr/local/etc/zabbix_agentd.conf 做以下修改 UnsafeUserParameters=1 # 默认为0，表示不允许自定义key # 监控*进程是否存在，[*]是server端传递参数，是服务名称 UserParameter=ckproc[*],/usr/bin/bash /scripts/proc.sh $1 然后写脚本
mkdir /scripts vim /scripts/proc.sh #!/bin/bash proc_count=$(ps -ef|grep -Ev "grep|$0" |grep -c $1) echo $proc_count chown -R zabbix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32dfcf1511735810549464114da82a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc623e99b7e1810f63b023aafe77e34b/" rel="bookmark">
			linux系统目录详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系统目录详解 1. /bin文件夹相关1.1 /bin1.2 /sbin1.3 /usr/bin1.4 /usr/sbin1.5 /PATH/TO/SOME/BIN（/usr/local/bin）1.6 /PATH/TO/SOME/SBIN（/usr/local/sbin） 2. /boot文件夹2.1 /boot/config-2.6.18-194.17.1.el5文件2.2 /boot/initrd-2.6.18-194.17.1.el5.img文件2.3 /boot/vmlinuz-2.6.18-194.17.1.el5文件2.4 /boot/grub/grub.conf 3. /dev文件夹3.1 /dev/alarm3.2 /dev/autofs3.3 /dev/block文件夹3.4 /dev/cdrom，/dev/dvd，/dev/cdrw，/dev/dvd-rw等3.5 /dev/char3.6 /dev/console，/dev/tty， /dev/tty1 到 /dev/tty63，/dev/ttys，/dev/ttys0 到 /dev/ttys31文件和 /dev/pts 文件夹3.7 /dev/loop(/dev/loop0 到 /dev/loop7)3.8 /dev/sda，/dev/hda等3.9 /dev/random 和 /dev/urandom3.10 /dev/null和/dev/zero3.11 /dev/ppp 4. /etc文件夹4.1 LINUX/UNIX中/etc文件夹的历史4.2 LINUX /etc文件夹中的表文件(***tab)4.3 /etc文件夹中的运行配置文件(RC)4.4 /etc文件夹中的配置文件4.5 /etc文件夹中的deny/allow文件4.6 /etc文件夹中的目录4.7 /ETC文件夹中的其他文件 5. /home 和 /root 文件夹5.1 LINUX/UNIX中的/home目录简介5.2 用户主目录是做什么的?5.3 /HOME文件夹的属性?5.4 LINUX中的/ROOT目录如何?5.5 一些关于用户主目录的常见问题 6. /lib文件夹6.1 /lib文件夹内容6.2 /lib 的姊妹文件夹：/lib32 和 /lib646.3 Linux 其他的库文件 7. /usr 文件夹8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc623e99b7e1810f63b023aafe77e34b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76079475682cd413e792bbc370aef6d2/" rel="bookmark">
			修改echarts上下左右边离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		myChart.setOption({
tooltip: {
trigger: ‘axis’
},
grid: {
x: 20,
y: 20,
x2: 20,
y2: 50 //距离下边的距离
},
toolbox: {
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f87b04f4431ee3f85423a888fbf265c/" rel="bookmark">
			qt 合并单元格 tablewidget 合并单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		合并单元格效果的实现：
tableWidget-&gt;setSpan(1, 1, 2, 2) # 其参数为： 要改变单元格的 第一个单元格 行数 列数 要合并的 几行 几列
代表从(1,1)单元格开始合并，要合并两行两列，即图片红色标注部分
tableWidget-&gt;insertColumn(0); tableWidget-&gt;insertColumn(1); tableWidget-&gt;insertColumn(2); tableWidget-&gt;insertColumn(3); tableWidget-&gt;insertColumn(4); tableWidget-&gt;insertRow(0); tableWidget-&gt;insertRow(1); tableWidget-&gt;insertRow(2); tableWidget-&gt;insertRow(3; tableWidget-&gt;insertRow(4); tableWidget-&gt;setSpan(1, 1, 2, 2); //合并单元格 合并前：
（0，0）（0，1）（0，2）（0，3）（0，4）（1，0）（1，1）（1，2）（1，3）（1，4）（2，0）（2，1）（2，2）（2，3）（2，4）（3，0）（2，1）（2，2）（2，3）（2，4）（4，0）（4，1）（4，2）（4，3）（4，4） 合并后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97ebb49092581a2b58ef2f1cc8c349f1/" rel="bookmark">
			小程序已授权之后，自动获取用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		index.wxml:
&lt;view class="Box"&gt; &lt;button wx:if="{{canIUser &amp;&amp; !hasUserInfo}}" size="mini" type="primary" plain="true" loading="true" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt;获取用户信息&lt;/button&gt; &lt;view wx:else&gt; &lt;image class="avatar" src="{{userInfo.avatarUrl}}"&gt;&lt;/image&gt; &lt;text&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; index.wxss:
.Box, .Box&gt;view { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; } .avatar { width: 200rpx; height: 200rpx; margin-top: 250rpx; } .Box text { margin-top: 250rpx; } .Box button { margin-top: 750rpx; } index.js
var app = getApp(); data: { userInfo: null, // 防止微信版本过低不能使用open-type属性 canIUser: wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97ebb49092581a2b58ef2f1cc8c349f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c68890d21bec0e75e08bb73bf28870/" rel="bookmark">
			小程序手动获取用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 wxml：
&lt;view class="Box"&gt; &lt;image class="avatar" src="{{userInfo.avatarUrl}}"&gt;&lt;/image&gt; &lt;text&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;button size="mini" type="primary" plain="true" loading="true" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt;获取用户信息&lt;/button&gt; &lt;/view&gt; open-type="getUserInfo"：getUserInfo获取用户信息
bindgetuserinfo="getUserInfo"：用户点击该按钮时会返回获取到的用户信息，回调的detail数据与wx.getUserInfo返回的一致
wxss：
.Box{ display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; } .avatar{ width: 200rpx; height: 200rpx; margin-top: 250rpx; } .Box text{ margin-top: 250rpx; } .Box button{ margin-top: 250rpx; } js：
data: { userInfo: null, }, /* 获取用户信息 */ getUserInfo(res) { console.log(res); this.setData({ userInfo: res.detail.userInfo }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386e06a06ed77b0d488ce6dd269d7fb2/" rel="bookmark">
			apache的默认设置（端口，发布文件，发布目录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：apache的概念
Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。
它可以运行在几乎所有广泛使用的计算机平台上
目录文件：
程序目录：/usr/sbin/httpd
默认网站主页存放目录： /var/www/html/
日志文件存放目录：/var/log/httpd/
主配置目录：/etc/httpd/conf/
主配置文件：/etc/httpd/conf/httpd.conf
从配置目录：/etc/httpd/conf.d/
apache的默认端口是80
二：apache的默认发布文件
/var/www
默认情况下将要发布的网页文件应该置于/var/www目录下，这一默认值可以同过主配置文件中的DocumentRoot 选项修改。
实验如下：
前提：
为了实验的纯净，我们将这台虚拟机reset
设置ip
修改主机名为apache.westos.com
搭建yum源
将图形界面转化为无图形界面，并用ssh去连接（看个人意愿）
此使我们在浏览器里输入172.25.254.115显示不能连接，如下图所示：
为了解决这个问题，我们需要做以下的实验。
实验如下：
&lt;1&gt;安装软件
yum search apache yum install httpd.x86_64 -y 安装httpd软件包 搜索出来的结果中安装这个软件包
安装
安装完成
&lt;2&gt;启动服务
systemctl start httpd systemctl enable httpd systemctl status httpd &lt;3&gt;对防火墙进行设置（若是嫌麻烦，可直接关掉防火墙）
firewall-cmd --permanent --add-service=http 防火墙允许的服务有http firewall-cmd --reload 重新加载 firewall-cmd --list-all 查看 &lt;4&gt;编辑默认发布文件
cd /var/www/html ls vim index.html （必须是index.html。服务默认的共享文件（默认发布文件）只有这一个） 在里面写入
重启服务
测试：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386e06a06ed77b0d488ce6dd269d7fb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0831a51cabf9384ddda0ad8968c7bbc/" rel="bookmark">
			Windows上通过VLC播放器搭建rtsp流媒体测试地址操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 从https://www.videolan.org/index.zh.html 下载最新的windows 64bit 3.0.6版本并安装；
2. 打开VLC media player，依次点击按钮：”媒体” --&gt; “流”，如下图所示：
3. 点击”添加”按钮，选择一个视频文件，然后点击”串流”按钮，如下图所示：
4. 点击”下一步”按钮，如下图所示：
5. 目标设置，在”新目标”框中选中”RTSP”，如下图所示：
6. 点击”添加”按钮，填写端口号，默认为8554，填写路径，如为/test，点击”下一步”按钮，如下图所示：
7. 转码选项，取消勾选”激活转码”，配置文件选中”Video - H.265 + MP3 (MP4)”，点击下一步按钮，如下图所示：
8. 选项设置，修改sdp设置，将”sdp=rtsp://8554/test”调整为”sdp=rtsp://10.1.125.144:8554/test”，其中”10.1.125.144”为本机IP地址，点击”流”按钮，服务端开始流传输，如下图所示：
9. 如果视频较短，可选中”循环播放”按钮，如下图所示，不要关闭此VLC media player：
10. 测试通过rtsp是否可以正常播放：再打开一个VLC media player，依次点击”媒体” --&gt; “打开网络串流”，在url中输入” rtsp://10.1.125.144:8554/test”，点击”播放”，如下图所示，即可通过rtsp流播放视频：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/235/">«</a>
	<span class="pagination__item pagination__item--current">236/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/237/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>