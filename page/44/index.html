<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66bdee6e963d61f4fee456a3673fb7ac/" rel="bookmark">
			ROS中/odom,/map,/base_link几个坐标系的含义：从ROS的REP105严谨介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两日看lego-loam，其中的坐标系定义很混乱。
在lego-loam的一个issue中，作者指出他坐标系定义是完全按照ROS的REP103和105的建议的。
然后又看到了关于/odom, /map, /base_link 几个坐标系的含义的说明，因此整理一下。
关于ROS的REP 关于REP：https://ros.org/reps/rep-0000.html
The REP contains the index of all ROS Enhancement Proposals, known as REPs. REP numbers are assigned by the REP Editor, and once assigned are never changed.
简单来说，REP是对ROS的一些提议，即某些人建议对这些问题这样操作。
REP103 测量和坐标系习惯 REP103: Standard Units of Measure and Coordinate Conventions
简要概括：
传感器坐标系采用：x-前，y-左，z-上
用于地理定位的短距离笛卡尔坐标系：东北天坐标系
光学传感器：z-前，x-右，y-下
REP105 移动机器人平台坐标系定义 REP105 Coordinate Frames for Mobile Platforms
移动机器人建议有这么几个坐标系：
/base_link：与移动机器人基座固连的坐标系，建议采用REP103的方式进行定义。/odom：与world固定的一个frame The coordinate frame called odom is a world-fixed frame. The pose of a mobile platform in the odom frame can drift over time, without any bounds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66bdee6e963d61f4fee456a3673fb7ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08498b9b3bbefa04f8cf0a370dff6b49/" rel="bookmark">
			plink在GWAS的里面的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.plink的下载和安装（2.0） wget https://s3.amazonaws.com/plink2-assets/plink2_linux_x86_64_20231005.zip
unzip plink2_linux_x86_64_20231005.zip
ll
./plink2
vim ./bashrc
alias plink2='~plink2‘
source ~/.bashrc
plink2
二.plink格式的基本转化 ###########插入#plink数据格式转化##########
#VCF转ped/map
plink --vcf 文件.vcf --recode --out 文件--chr-set 24
#ped/map转bim/bed/fam
plink --file wenjain --make-bed --out wenajian --chr-set 24
#bim/bed/fam转VCF
plink --bfile wenjain --export vcf --out wenajin --chr-set 24
#bim/bed/fam转ped/map
plink -bfile xian1 -recode -out xian1 --chr-set 24
#ped/map格式的文件(mydata.ped/mydata.map)，就用**–file**
#是bed/fam格式的文件(mydata.bed/mydata.fam)，就用**–bfile**
三.plink提取指定的染色体，SNP，样本个体 1.染色体 从bed/fam转出VCF格式的，其他的类似
plink --bfile 文件 --export vcf --chr 1 --out 文件#提取1号染色体--chr-set 24 2.提取SNP 单纯提取的代码（这个我还没用到过，网页复制的）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08498b9b3bbefa04f8cf0a370dff6b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9547218492cf1208790744d93873c66/" rel="bookmark">
			C&#43;&#43;深拷贝（含有子类数据的）父类指针到新的父类指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class A { public: A() { cout &lt;&lt; "A()" &lt;&lt; endl; }; virtual ~A() { cout &lt;&lt; "~A()" &lt;&lt; endl; }; int a; string b; }; class B : public A { public: B() { cout &lt;&lt; "B()" &lt;&lt; endl; c = "789"; }; B(B* Bb) { *this = *Bb; } B(A* Bb) { B* bb = dynamic_cast&lt;B*&gt;(Bb); *this = *bb; } ~B() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9547218492cf1208790744d93873c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371a62cb0db42f3eceadc6f9111f5954/" rel="bookmark">
			RabbitMQ 脑裂丢数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是脑裂？ 所谓的脑裂问题，就是在多机集群中节点与节点之间失联，都认为对方出现故障，而自身裂变为独立的个体，各自为政，那么就出现了抢夺对方的资源，争抢启动，至此就发生了事故。rabbitmq 脑裂问题，实质上是个网络分区问题，rabbitmq集群的网络分区容错性不好，在网络比较差的情况下容易出错，最明显的就是脑裂问题了。
举个栗子：
A和B是集群上的两个节点，分别拥有一部分集群的数据a,b， 如果这时发生分区问题，两个节点无法通信，A以为B宕机，B以为A宕机，于是就出现了：
（1）如果A存在B的备份，那就以完整数据运行，B存在A的数据备份，也是同样， 那这里就造成共享数据损坏。
（2）如果 A,B 各自仅拥有a,b 的数据，那要么都无法恢复/启动，要么就瓜分数据运行。
分析 从RabbitMQ启动，数据加裁逻辑过程中，可以看出
在从节点队列启动的时候，你是会先把当前队列所在文件夹下的索引 进行清空，同时清空当前节点上当前队列的内存数据。
然后再从队列主节点上同步数据回来。
如果在脑裂出现的情况下，又连接到队列的从节点所在服务器上，并写了数据，那数据就在从节点上，并没有同步到原本的主节点上，假如这个时候把当前这个RabbitMQ节点进行重启，那RabbitMQ上的数据就会丢失，重新从主节点上进行数据同步。
按上面图逻辑顺序，理论上在 第四步（写入2）中 写入的数据，在重启RabbitMQ_B节点后，数据是会丢失的 出现脑裂的现象 1、通过rabbitmqctl工具查看
即采用rabbitmqctl cluster_status命令.未发生分区的情况,如下图:
[root@rmq-node3 ~]# rabbitmqctl cluster_status Cluster status of node 'rabbit@rmq-node3' [{nodes,[{disc,['rabbit@rmq-node2','rabbit@rmq-node1']}, {ram,['rabbit@rmq-node3']}]}, {running_nodes,['rabbit@rmq-node1','rabbit@rmq-node2','rabbit@rmq-node3']}, {cluster_name,&lt;&lt;"rabbit@rmq-node1"&gt;&gt;}, {partitions,[]}, #注意，这里为空数组，表明没有发生网络分区 {alarms,[{'rabbit@rmq-node1',[]}, {'rabbit@rmq-node2',[]}, {'rabbit@rmq-node3',[]}]}] 发生分区的情况:
[root@rmq-node3 ~]# rabbitmqctl cluster_status Cluster status of node 'rabbit@rmq-node3' [{nodes,[{disc,['rabbit@rmq-node2','rabbit@rmq-node1']}, {ram,['rabbit@rmq-node3']}]}, {running_nodes,['rabbit@rmq-node1','rabbit@rmq-node2','rabbit@rmq-node3']}, {cluster_name,&lt;&lt;"rabbit@rmq-node1"&gt;&gt;}, {partitions,[{'rabbit@rmq-node1',['rabbit@rmq-node2','rabbit@rmq-node3']}]}, #这里是发生了network partitions {alarms,[{'rabbit@rmq-node1',[]}, {'rabbit@rmq-node2',[]}, {'rabbit@rmq-node3',[]}]}] 2、通过RabbitMQ管理控制台查看
恢复方式 1.人工方式 （1）部分重启。选择受信分区即网络环境好的分区，重启其他分区，让他们重新加入受信分区中，之后再重启受信分区，消除警告⚠️
（2）全部重启。停掉整个集群，然后启动，不过要保证第一个启动的是受信分区。不然还没等所有节点加入，自己就挂了。
2.自动处理 （1）ignore 默认配置，即分区不做任何处理。发生网络分区时，需要人工介入。要使用这种，就要保证网络高可用，例如，节点都在一个机架上，用的同一个交换机，这个交换机连上一个WAN，保证网络稳定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371a62cb0db42f3eceadc6f9111f5954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9cf1fef598887c25ccac1b8de51843b/" rel="bookmark">
			深度学习之基于Yolov8的汽车车流量统计系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家点赞、收藏、关注、评论啦 ，由于篇幅有限，只展示了部分核心代码。
文章目录 一项目简介二、功能三、汽车车流量统计系统四. 总结 一项目简介 基于YOLOv8的汽车车流量统计系统是一种利用深度学习技术进行车辆检测和统计的系统。YOLOv8是一种目标检测模型，能够准确地识别图像中的多个车辆并提供车辆的位置和分类信息。以下是该系统的介绍：
数据采集：系统通过摄像头或视频源采集道路上的实时图像或视频。这些数据将作为模型训练和车流量统计的输入。
深度学习模型：系统使用YOLOv8深度学习模型进行车辆检测。YOLOv8模型具有高准确率和实时性能，能够在监测视频中实时地检测和识别车辆。
车流量统计：系统通过分析检测到的车辆，可以计算车流量、车速以及车道占有率等信息。这些统计数据可以用于交通管理、道路规划和安全评估等应用。
可视化界面：系统还可以提供一个可视化界面，用于实时显示车流量统计结果和图像/视频展示。用户可以通过界面查看和分析监测到的车辆数据。
系统优化：为了提高系统的实时性能，可能需要在硬件端使用加速器（如GPU）或在软件端进行模型优化和推理加速。
该系统的优点包括准确性高、实时性强、功能全面等。它在城市交通管理、道路监控和交通安全等领域具有广泛的应用前景。然而，系统的性能也受到数据质量、环境条件和模型训练等因素的影响，需要进行充分的测试和调优，以确保其在实际应用中的可靠性和稳定性。
二、功能 使用YOLOv8模型和对象跟踪框架(abewley/sort)从视频中检测和跟踪汽车在感兴趣的区域进行检测和跟踪
YOLOv8是最新的最先进的YOLO模型，可用于对象检测、图像分类和实例分割任务
SORT是基于基本数据关联和状态估计技术的视觉多对象跟踪框架的基本实现
环境：Python3.10、torch2.0、Pycharm
三、汽车车流量统计系统 四. 总结 基于YOLOv8的汽车车流量统计系统是一种具有较高实时性和准确率的监测系统，能够精确地检测和识别道路上的车辆，并提供可靠的车流量统计信息。
综上所述，基于YOLOv8的汽车车流量统计系统是一种强大的监测工具，能够有效地提高交通管理和安全性，但在实际应用过程中仍需要进行测试和优化以确保其在实际应用中的可靠性和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313d17a20722f38fcb86e6e88a8d5ec1/" rel="bookmark">
			微信小程序获取最新隐私协议授权 以及涉及隐私API权限申请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近小程序新推出的隐私政策，导致之前小程序一些相关api无法调用，甚至连登录都出现了问题...
话不多说，来点实在的 提示用户同意隐私授权的弹窗结构，样式就不粘了...
&lt;u-popup :show="showPrivacy" mode="center" :safeAreaInsetBottom="false"&gt; &lt;view class="privacy_box"&gt; &lt;view class="privacy_hd"&gt;隐私保护指引&lt;/view&gt; &lt;view class="privacy_hd"&gt; xxxx&lt;text @click="openPrivacyContract"&gt;《xxxxx小程序隐私保护指引》&lt;/text&gt;xxx &lt;/view&gt; &lt;view class="privacy_btn"&gt; &lt;button class="reject" @click="exitMiniProgram"&gt;拒绝&lt;/button&gt; &lt;button id="agree-btn" class="agree" open-type="agreePrivacyAuthorization" @agreeprivacyauthorization="handleAgreePrivacyAuthorization"&gt;同意&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/u-popup&gt; 接下来看下对应的方法
// 同意小程序隐私政策 handleAgreePrivacyAuthorization(res) { this.showPrivacy = false this.loginDirect() }, // 拒绝并退出小程序 exitMiniProgram(){ uni.exitMiniProgram({}) }, // 跳转隐私政策详情 openPrivacyContract() { uni.openPrivacyContract({}); }, 到这里还没有完全解决，这时候调用涉及隐私的api的时候，可能会报错，举个栗子（getUserInfo:fail api scope is not declared in the privacy agreement）这时候需要去管理后台去申请,首先去勾选所需要的权限，然后去申请就行了
之后即可解决... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766532c7f1efd9f4de520ebd901a31f4/" rel="bookmark">
			利用STM32实现按键控制LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用野火开发版，一下是说明
/*********************************************************************************************/
【*】程序简介
-工程名称：GPIO输入--按键
-实验平台: 野火STM32 F429 开发板
-MDK版本：5.16
-ST固件库版本：1.5.1
【 ！】功能简介：
使用两个按键控制彩灯的红、绿灯反转，按一下KEY1 红灯反转一次，按一下KEY2,绿灯反转一次。
学习目的：学会检测GPIO引脚输入的基本方法。
【 ！！】注意事项：
跳线帽：彩灯需要用跳线帽连接J35 (出厂默认已连接，J35位置在彩灯附近)
/*********************************************************************************************/
【*】 引脚分配
KEY:
两个按键均有硬件去抖，按下的时候均为高电平，不按时为低电平。
KEY1&lt;---&gt;PA0
KEY2&lt;---&gt;PC13
LED：
RGB彩灯的三个阴极接到STM32三个引脚上，LED低电平亮。
R&lt;---&gt;PH10
G&lt;---&gt;PH11
B&lt;---&gt;PH12
LED4&lt;---&gt;PD11
/*********************************************************************************************/
【*】 时钟
A.晶振：
-外部高速晶振：25MHz
-RTC晶振：32.768KHz
B.各总线运行时钟：
-系统时钟 = SYCCLK = AHB1 = 180MHz
-APB2 = 90MHz -APB1 = 45MHz
C.浮点运算单元：
不使用
main代码 /**
******************************************************************************
* @file main.c
* @author fire
* @version V1.0
* @date 2015-xx-xx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766532c7f1efd9f4de520ebd901a31f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c1d96bc890d94411302486bc380e07/" rel="bookmark">
			激光雷达点云基础-点云滤波算法与点云配准算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		激光雷达点云处理在五年前就做了较多的工作，最近有一些新的接触发现激光雷达代码原理五年前未见重大更新，或许C++与激光雷达结合本身就是比较高的技术门槛。深度学习调包侠在硬核激光雷达技术面前可以说是完全的自愧不如啊。
1、点云滤波 在获取点云数据时，由于设备精度、操作者经验、环境因素等带来的影响，点云数据中将不可避免地出现一些噪声点。而滤波的作用就是利用数据的低频特性剔除离群数据，并进行数据平滑或者提取特定频段特征。
对应的问题是什么时候需要做点云滤波？大概可以分为以下四个方面：1、点云数据密度不规则需要平滑；2、因为遮挡等问题造成离群点需要去除；3、大量数据需要进行下采样；4、噪音数据需要去除。
1.1 常用的点云滤波器： 直通滤波器 条件滤波器
高斯滤波器 双边滤波器 统计滤波器 半径滤波器 频率滤波器
体素滤波器
从功能层面以上点云滤波器可以分为三类使用：直通和条件滤波用于预处理的最前端提取出感兴趣区域；体素滤波用于对密集点云进行下采样减少数据量；其他滤波器用于平滑点云同时去除离散点。
1.2 点云滤波器介绍： 直通滤波器 原理：在点云的指定维度上设置一个阈值范围，将这个维度上的数据分为在阈值范围内与不在阈值范围内，从而选择过滤与否。能够快速过滤掉用户自定义区间范围内的点云。
在实际应用中，由于激光扫描采集的距离较远，但是根据功能需求的不同可能只关心一定区域内的数据，比如低速物流车的运营场景，可能在X方向只关心前后60米，Y方向只关心左右20米的范围。此时就可以利用直通滤波器提取出感兴趣区域，可较快剔除部分点云，达到第一步粗处理的目的。
条件滤波器 原理：通过设定滤波条件进行滤波，类似于分段函数，判断点云是否在规则的范围则中，如果不在则舍弃。上述的直通滤波器就是一种较简单的条件滤波器。
高斯滤波器 原理：采用加权平均方式的一种非线性滤波器，在指定域内的权重是根据欧式距离的高斯分布，通过权重加权平均的方式得到当前点的滤波后的点。
特点：利用标准差去噪，适用于呈正态分布的数据平滑效果较好，但是边缘角点也会被较大的平滑。
双边滤波器 原理：通过取邻近采样点的加权平均来修正当前采样点的位置，在高斯滤波器只考虑空间域点的位置基础上，增加了维度上的权重。一定程度上弥补了高斯滤波的缺点。
特点：既有效地对空间三维模型表面进行降噪，又可以保持点云数据中的几何特征信息，避免三维点云数据被过渡光滑。但是只适用于有序点云。关于高斯滤波和双边滤波，本身在图像领域其实已经有广泛的应用，具体的算法原理可以参考保边滤波–bilateral filter and guided filter
。
体素滤波器 原理：通过对输入的点云数据创建一个三维体素栅格，然后在每个体素内，用体素中所有点的重心来近似显示体素中的其他点，这样该体素内所有点就用一个重心点最终表示。也有另外一种相似的表达形式：利用每一个体素立方体的中心来近似该体素立方体内的所有点，相比上一种方法计算速度较快，但是损失了原始点云局部形态的精细度。
特点：可以达到向下采样同时不破坏点云本身几何结构的功能。点云几何结构不仅是宏观的几何外形，也包括其微观的排列方式，比如横向相似的尺寸，纵向相同的距离。随机下采样虽然效率比体素网格滤波器高，但会破坏点云微观结构。
以上几种滤波器不会针对离散群点做相关操作，但是实际上离散群点这类噪声点会对整体算法带来比较严重的干扰。离散群点会破坏点云的表达准确性。使得局部点云特征（例如表面法线或曲率变化）的估计变得非常复杂，这往往导致错误的估计结果，从而可能导致点云配准失败。
统计滤波器 原理：对每个点的邻域进行一个统计分析，并修剪掉那些不符合一定标准的点。我们的稀疏离群点移除方法基于在输入数据中对点到临近点的距离分布的计算。
具体方法如下：计算每个点到其最近的k个点平均距离，（假设得到的结果是一个高斯分布，其形状是由均值和标准差决定），那么平均距离在标准范围之外的点，可以被定义为离群点并从数据中去除。
特点：主要是根据密度去除离群点，对密度差异较大的离群点去除效果较好。
半径滤波器 原理：与统计滤波器类似，只是操作更加暴力直观，根据空间点半径范围临近点数量来滤波。
具体方法如下：
在点云数据中以某点为中心画一个圆计算落在该圆中点的数量，当数量大于给定值时，则保留该点，数量小于给定值则剔除该点。此算法运行速度快，依序迭代留下的点一定是最密集的，但是圆的半径和圆内点的数目都需要人工指定。
特点：用于去除离群点，在一定程度上可以用来筛选边缘点。
频率滤波器 原理：在点云处理中，点云法线向量差为点云所表达的信号。用点云的曲率来表示频率信息，如果某处点云曲率大，则点云表达的是一个变化高频的信号。如果点云曲率小，则点云表达的是一个不变低频的信号。例如：地面曲率小，它表达的信息量也小；障碍物处曲率大，频率就会更高。
以DoN算法为例，根据不同尺度下法向量特征的差异性，利用pcl::DifferenceOfNormalsEstimation实现点云分割，在处理有较大尺度变化的场景点云分割效果较好，利用不同支撑半径去估算同一点的两个单位法向量，单位法向量的差定义DoN特征。具体如下：在小尺度上计算点云法线1，在大尺度上计算点云法线2，法线1-法线2，滤去3中值较小的点，根据第三步得到的法线差，进行欧式分割。
特点：在小尺度上是可以对高频信息进行检测的，可以很好的小尺度高频信息。其在大规模点云中优势尤其明显。
DoN特征源于观察到基于所给半径估计的表面法向量可以反映曲面的内在几何特征，因此这种分割算法是基于法线估计的，需要计算点云中某一点的法线估计。而通常在计算法线估计的时候都会用到邻域信息，很明显邻域大小的选取会影响法线估计的结果。
而在DoN算法中，邻域选择的大小就被称为support radius。对点云中某一点选取不同的支持半径，即可以得到不同的法线估计，而法线之间的差异，就是是所说的法线差异。
2、点云配准匹配算法 2.1 什么是点云配准 点云配准是指将多个点云数据集在相同坐标系下进行对齐的过程，使得它们在空间中具有一致的位置和姿态。在点云配准中，需要估计点云之间的转换关系，包括平移、旋转和尺度等变换。点云配准在三维重建、物体检测、环境感知、机器人导航和虚拟现实等领域有着广泛的应用。点云配准的主要目标是最小化点云之间的误差，通常通过匹配点云中的对应点来实现。在匹配点云时，需要考虑到点云中的噪声、不完整性和采样密度等问题，以及在不同的场景下可能出现的变形和运动。常见的点云配准方法包括ICP（Iterative Closest Point）和NDT（Normal Distribution Transform）。
2.2 点云ICP算法 点云ICP算法是一种经典的点云配准算法，其全称为Iterative Closest Point算法，是一种迭代优化的方法，用于将两个或多个点云数据集对齐。该算法通过迭代找到最优的刚体变换矩阵，使得两个点云之间的重叠部分最大化，从而实现点云的配准。
2.2.1 ICP算法简介 ICP算法的基本思路是：假设我们有得到初始的P、Q两部分点云。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c1d96bc890d94411302486bc380e07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e140f71ce58a3604660378251f988e1/" rel="bookmark">
			使用 docker-compose 部署 SpringBoot 项目 &amp; nginx 部署前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Docker 自动下载 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 检查是否安装成功
docker -v 配置镜像仓库 更换镜像加速器（推荐阿里云）
容器镜像服务 (aliyun.com)
扫码登录后找到镜像仓库
每个人都不同，复制自己的镜像仓库
复制好上面的地址后，编辑到 daemon.json 中
vi /etc/docker/daemon.json 按ESC ，使用 :wq 保存
启动 docker systemctl start docker 安装 docker-compose 安装命令行 curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 设置文件权限 chmod +x /usr/local/bin/docker-compose 查看版本 docker-compose -v 编写 Dockerfile Dockerfile 可以将我们的项目打包好的 jar 包转换为镜像
这里我将 dockerfile 以及 docker-compose 放在了项目包中，这里位置可随意，最后要上传到服务器上的
文件内容 Dockerfile 的文件内容为
# 设置jdk版本 FROM java:8 # 设置我们的个人信息，大家根据需求随便写 MAINTAINER daqi &lt;daqi_email@163.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e140f71ce58a3604660378251f988e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d5ad5ce8a5957dbd6340f58d13552e/" rel="bookmark">
			记一次提高依赖PCL的C&#43;&#43;代码编译速度的经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近调试S-Fast-LIO算法，包含PCL的C++ Lidar SLAM算法，编译时间总是很长难以忍受。
花了小半天，探究了下方法，并做总结。
1. Debug模式和Release模式，优化等级的影响 SET(CMAKE_BUILD_TYPE "Debug")	// Release set( CMAKE_CXX_FLAGS "-std=c++14 -O3" )	// -O3，最优化；-O0，不进行任何优化；-O1，默认，均衡优化 在代码中只修改一行，重新编译：
Debug模式，-O3优化：用时1m20s
Debug模式，-O0优化：用时1m19s（没有显著变化）
Release模式，-O0优化：50s
因此，Release模式会大大减少编译时间。
2. 使用ccache: sudo apt install ccache 据说ccache可以在部分文件未修改的情况下提高编译速度，以空间换取时间。但我实际测试的时候，发现对于工程并不是很大、每次编译文件基本只有那么几个的，并不是非常友好。
只有当编译过这个代码，修改以后，再修改回来，会有显著的提升，但只要是有那么一丢丢的不一样，就白干。
Debug模式， -O3优化，使用ccache：
第一次编译：1 min 11s
修改1行后编译: 1min 5s
退回这次修改再编译：10.9s
3. PCL官方给出的一些注意事项 Building time of a project which depends on PCL is too long 建议：
如无必要，不要添加用不到的头文件；多线程编译：make -jxxx使用最新版的PCL可能做了优化拆分多个文件，方便修改后编译更快 4. 使用 include-what-you-use 精简头文件 整理混乱的头文件，我用include what you use
安装：
从源码编译clang（编译很久，过程中容易爆内存，用-j1指令）：安装 nuxxx，这个被IWYU依赖； sudo apt-get install libncurses5-dev libncursesw5-dev 安装IWYU： 装了半天然后放弃了……编译太麻烦了，也担心把自己的系统环境搞崩，所以没有继续。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d5ad5ce8a5957dbd6340f58d13552e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b0635d1a612a30f8fa9e9e820a5fe9/" rel="bookmark">
			防抖节流适用于input输入查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 当监听input 输入变化做接口查询时，会出现疯狂的请求接口。这里用计时器做时间段查询。当用户输入完成1s后再走查询 4次输入1，不做节流会打印：1 11 111 1111 1 当监听input 输入变化做接口查询时，会出现疯狂的请求接口。这里用计时器做时间段查询。当用户输入完成1s后再走查询 let searchTime = null changeInput (e) { if(searchTime)clearTimeout(searchTime) searchTime = setTimeout(() =&gt; { console.log('time里面', e.detail.detail.value) api.post('url', {}).then(res =&gt; {}) clearTimeout(searchTime) }, 1000); }, 4次输入1，不做节流会打印：1 11 111 1111 而效果很明显，只打印了一次 1111
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abdd031c83fd01c72139e4026b471761/" rel="bookmark">
			js根据id获取数组对象,js根据内容获取元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈js中哪个方法是根据id来获取元素信息的，以及js中哪个方法是根据id来获取元素值的，希望对各位有所帮助，不要忘了收藏本站喔。
js 根据id获取页面元素 1.getElementById(id)
&lt;div id="divId"&gt;用java获取Id的方法getElementById()的使用方法&lt;/div&gt; var obj = document.getElementById("divId"); 以上是通过div的id号divId获取div这个对象，然后就可以对div进行各种操作 如删除其内容，设置其属性，将其隐藏等等 值得注意的是：div 必须先于 java 代码加载 也就是 div 要放在 var obj = document.getElementById("divId") 的前面，否则因找不到对象而报错 2.$(id)
本质：通过getElementById()方法获取到html元素对象
首先需要定义$： var $ = function (objId) { return ("string" == typeof (objId)) ? document.getElementById(objId) : objId; } 其实是把 $ 定义为一个函数（方法），在这个函数中仍然是通过 getElementById 方法获取元素的这个对象 也就是 $ 本身并不具备获取元素对象的功能，它只是一个字符，不过是把它定义为了一个获取元素对象的方法 获取上述的div元素通过$表示为： var obj = $("divId"); 用getElementById方法获取要写一长串字母，现在只需写一个字符 方便快捷，尤其要获取很多元素对象的时候，优势更明显 获取元素的值 obj.value 获取元素的文本 obj.innerHTML ... 3.js 判断 html 元素是否存在
if (document.getElementById("id" ) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abdd031c83fd01c72139e4026b471761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ebe4ede123ed9876a2f99521c91fd2/" rel="bookmark">
			解决谷歌浏览器翻译插件不能用的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chrome浏览器右键翻译页面现在已经不能用了
这是因为谷歌关闭了大陆内的谷歌翻译服务，
所以我们需要将Chrome浏览器的翻译域名指向国内可以用的域名
首先ping一下谷歌cn域名
ping google.cn PING google.cn (108.177.97.100) 56(84) bytes of data. 64 字节，来自 108.177.97.100: icmp_seq=1 ttl=101 时间=46.7 毫秒 64 字节，来自 108.177.97.100: icmp_seq=2 ttl=101 时间=45.9 毫秒 64 字节，来自 108.177.97.100: icmp_seq=3 ttl=101 时间=45.8 毫秒 ^C --- google.cn ping 统计 --- 已发送 3 个包， 已接收 3 个包, 0% 包丢失, 耗时 2003 毫秒 rtt min/avg/max/mdev = 30.488/30.931/31.332/0.345 ms 可以看到，这个ip是可以用的，所以我们将这个域名映射给我们的操作系统加上即可。
windows修改：
"C:\Windows\System32\drivers\etc\hosts" 添加： 108.177.97.100 translate.googleapis.com Linux修改：
vim /etc/hosts 108.177.97.100 translate.googleapis.com 现在谷歌翻译就可以用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409effda5a05c90b95f38b4d310cb6de/" rel="bookmark">
			为什么前端数值精度会丢失?(BigInt解决办法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信各位前端小伙伴在日常工作中不免会涉及到使用 JavaScript 处理 数值 相关的操作，例如 数值计算、保留指定小数位、接口返回数值过大 等等，这些操作都有可能导致原本正常的数值在 JavaScript 中确表现得异常（即 精度丢失）。
精度丢失场景 浮点数的计算 1、加法和减法
0.1 + 0.2 // 结果为 0.30000000000000004 0.3 - 0.1 // 结果为 0.19999999999999996 // 这是因为浮点数的二进制表示无法准确表示某些十进制小数，导致计算结果存在微小的误差。 2、乘法和除法
0.1 * 0.2 // 结果为 0.020000000000000004 0.3 / 0.1 // 结果为 2.9999999999999996 // 在进行乘法和除法时，浮点数计算结果的精度问题更为突出，可能会产生更大的误差。 3、比较运算
0.1 + 0.2 === 0.3 // 结果为 false // 直接比较浮点数可能会导致不准确的结果，因为计算结果的微小误差可能使它们不完全相等。 超过最值 所谓 超过最值（最大、最小值） 指的是超过了 Number.MIN_SAFE_INTEGER（- 9007199254740991），即 +（2^53 – 1） 或 Number.MAX_SAFE_INTEGER（+ 9007199254740991），即 -（2^53 – 1） 范围的值，项目中最常见的就是如下几种情况：1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409effda5a05c90b95f38b4d310cb6de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e89b0b43299933da9a3d56d2284c3d2/" rel="bookmark">
			uniapp使用腾讯地图组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNIAPP CHOOSELOCATION 在H5端定位不准确解决方案 标签： uni-app
前言 项目需要通过选取地址来获取经纬度，进而计算两点的距离。直接使用uni.chooseLoaction 发现偏差实在是太大。
解决方案 使用腾讯的 地图选点组件
传送门：地图组件 | 腾讯位置服务
第一步 申请KEY设置REFERER 注意：这里的应用名称填英文，我设置的中文，后面的链接填写referer的时候总是报错，换成英文就好了
第二步 UNIAPP页面 1.在需要获取位置信息的页面加个跳转
这里我们是跳转到webview页面去获取地址
2.在onload里面加个判断，解析返回的数据信息
当我们在webview页面获取信息之后还要跳转回当前页面，带着数据信息
onLoad(options) { if(options.loc){ let loc = JSON.parse(options.loc); //做你的数据处理 } }, methods: { openAddres:function(){ uni.redirectTo({ url:"../getAddress/getAddress" }) } } 3.webview页面
&lt;template&gt; &lt;view&gt; &lt;web-view src="https://apis.map.qq.com/tools/locpicker?search=1&amp;type=1&amp;key=your key&amp;referer=your appname"&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { } }, onLoad(options) { window.addEventListener('message', event=&gt; { // 接收位置信息，用户选择确认位置点后选点组件会触发该事件，回传用户的位置信息 var loc = event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e89b0b43299933da9a3d56d2284c3d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a40e1d63e61f52361289a874666c42/" rel="bookmark">
			【问题分析解决】git添加.gitignore后不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git rm -r --cached 目标目录或者文件
git add .
git commit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d4a43a84d4aeba104f42310886679e/" rel="bookmark">
			《动手深度学习》线性回归简洁实现实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎈 作者：Linux猿
🎈 简介：CSDN博客专家🏆，华为云享专家🏆，Linux、C/C++、云计算、物联网、面试、刷题、算法尽管咨询我，关注我，有问题私聊！
🎈 欢迎小伙伴们点赞👍、收藏⭐、留言💬
本文是《动手深度学习》线性回归简洁实现实例的实现和分析，主要对代码进行详细讲解，有问题欢迎在评论区讨论交流。
一、代码实现 实现代码如下所示。
import torch from torch.utils import data # d2l包是李沐老师等人开发的动手深度学习配套的包, # 里面封装了很多有关与数据集定义，数据预处理，优化损失函数的包 from d2l import torch as d2l # nn 是神经网络 Neural Network 的缩写，提供了一系列的模块和类，实现创建、训练、保存、恢复神经网络 from torch import nn ''' 1. 生成数据集，共 1000 条 true_w 和 true_b 是临时变量用于生成数据集 生成 X, y ：满足关系 y = Xw + b + noise ''' true_w = torch.tensor([2, -3.4]) true_b = 4.2 features, labels = d2l.synthetic_data(true_w, true_b, 1000) ''' 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07d4a43a84d4aeba104f42310886679e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d298ec6bcdaac0bee9c96914e3726949/" rel="bookmark">
			centos7.4安装tcpreplay显示No package tcpreplay available.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7.4安装tcpreplay显示No package tcpreplay available. 不要换源，换源也不行
先 yum -y install epel-release
后 yum -y install tcpreplay
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5a8bdb90bac71dcd27f5bc986ab94f/" rel="bookmark">
			用 C&#43;&#43; 实现线性拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 线性拟合是一种常见的数据分析方法，用于找到一条最佳拟合直线来描述数据点的趋势。在C++中，我们可以使用最小二乘法来实现线性拟合。最小二乘法是一种通过最小化残差平方和来拟合数据的方法。
最小二乘法 最小二乘法是一种常用的拟合方法，它通过最小化实际观测值与拟合值之间的残差平方和来确定拟合直线的参数。在线性拟合中，我们假设拟合直线的公式为y = kx + b，其中k是斜率，b是截距。
1. 程序概述 我们的目标是编写一个程序，可以接受一组数据点作为输入，并使用最小二乘法来拟合一条直线。最小二乘法是一种常用的拟合方法，它通过最小化数据点到拟合直线的垂直距离的平方和来确定最佳拟合直线的参数。
2. 程序实现 2.1 数据输入
我们首先需要定义一个结构体来存储数据点的x和y坐标：
struct DataPoint { double x; double y; }; 然后，我们可以使用一个向量来存储所有的数据点：
std::vector&lt;DataPoint&gt; dataPoints; 用户可以通过键盘输入或从文件中读取数据点，并将它们存储在dataPoints向量中。
2.2 最小二乘法计算
接下来，我们需要实现最小二乘法的计算过程。我们可以定义一个函数leastSquares来执行计算，并将拟合直线的斜率和截距作为输出参数：
void leastSquares(const std::vector&lt;DataPoint&gt;&amp; dataPoints, double&amp; slope, double&amp; intercept) { // 计算斜率和截距 // ... } 在函数内部，我们可以使用最小二乘法的公式来计算斜率和截距。具体的计算过程可以参考相关的数学资料[1]。
2.3 结果输出
最后，我们可以将拟合直线的斜率和截距输出到屏幕上：
std::cout &lt;&lt; "拟合直线的方程为: y = " &lt;&lt; slope &lt;&lt; "x + " &lt;&lt; intercept &lt;&lt; std::endl; 简单示例 假设我们有一组散点数据：
P1（1, 3） P2（2, 5） P3（3, 7) P4（4, 9) P5（5, 11) P6（6,13 ) P7（7, 15) P8（8, 17) P9（9, 19) 我们希望用一条直线来拟合这些数据点，我们可以通过数学方法得到拟合直线的表达式为y = 2x + 1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5a8bdb90bac71dcd27f5bc986ab94f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7c2786e491ab8d84e02ccfb9b4111f/" rel="bookmark">
			使用Objective-C和ASIHTTPRequest库进行Douban电影分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Douban是一个提供图书、音乐、电影等文化内容的社交网站，它的电影频道包含了大量的电影信息和用户评价。本文将介绍如何使用Objective-C语言和ASIHTTPRequest库进行Douban电影分析，包括如何获取电影数据、如何解析JSON格式的数据、如何使用代理IP技术和多线程技术提高爬虫效率，以及如何对电影数据进行简单的统计和可视化。本文将为您提供一种详细的方法，以便在Objective-C环境下进行网络爬虫和数据处理。
正文 1. 引入ASIHTTPRequest库 首先，我们需要在我们的Objective-C项目中引入ASIHTTPRequest库。这是一个强大的HTTP请求库，它将帮助我们轻松处理HTTP请求和响应。ASIHTTPRequest库支持同步和异步请求、文件上传和下载、缓存等功能，可以满足我们的各种需求。要引入ASIHTTPRequest库，我们需要在我们的项目中添加ASIHTTPRequest文件夹，并在我们的代码中导入ASIHTTPRequest头文件：
#import &lt;Foundation/Foundation.h&gt; #import "ASIHTTPRequest.h" 2. 设置代理服务器 在本示例中，我们将使用爬虫代理，您需要替换为自己的域名、端口、用户名和密码。这些信息将用于配置代理服务器。使用爬虫代理的好处是可以隐藏我们的真实IP地址，防止被目标网站封禁或限制访问。爬虫代理提供了高速稳定的代理服务，支持HTTP和HTTPS协议，可以满足我们的爬虫需求。要设置爬虫代理，我们需要在我们的代码中添加以下内容：
// 亿牛云 爬虫标准版 代理服务器配置（域名、端口、用户名、密码） NSString *proxyHost = @"www.16yun.cn"; int proxyPort = 12345; NSString *proxyUsername = @"16YUN"; NSString *proxyPassword = @"16IP"; 3. 创建多线程任务 为了提高采集效率，我们可以使用多线程技术。在本示例中，我们将创建多个线程以并行处理请求。多线程技术可以让我们同时发送多个请求，利用CPU的多核性能，减少等待时间和网络延迟。要创建多线程任务，我们可以使用GCD（Grand Central Dispatch）库，它是一个Objective-C的并发编程库，支持同步和异步执行、串行和并行队列、分组等功能。下面是一个使用GCD创建多线程任务的示例代码：
// 获取全局并行队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 异步执行任务 dispatch_async(queue, ^{ // 创建并配置ASIHTTPRequest对象 ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:[NSURL URLWithString:@"https://movie.douban.com/top250"]]; // 设置爬虫代理服务器信息 [request setProxyHost:proxyHost]; [request setProxyPort:proxyPort]; [request setProxyUsername:proxyUsername]; [request setProxyPassword:proxyPassword]; // 开始请求 [request startSynchronous]; // 处理响应数据 NSData *responseData = [request responseData]; NSString *html = [[NSString alloc] initWithData:responseData encoding:NSUTF8StringEncoding]; // 在这里进行HTML解析和数据处理 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7c2786e491ab8d84e02ccfb9b4111f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fc8ee81f36a1f6a65b48f380c52d28/" rel="bookmark">
			Nginx的非HTTPS的网站重定向到其他网站HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nginx配置文件加入模块
server { listen 443 ssl http2; server_name ship.zhonggu56.com; rewrite ^/(.*) http://$server_name/$1 permanent; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a722411de368c306e530d6315e3e30a7/" rel="bookmark">
			深度学习中的卷积运算计算公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积运算是深度学习中常用的操作，用于从输入数据中提取特征。以下是卷积运算的基本计算公式，包括输入输出关系、输出维度和参数量，我将通过一个简单的示例来说明。
卷积运算的基本公式：
输入和输出关系：
输入图像的大小为 ( I H I_H IH​, I W I_W IW​)，其中 I H I_H IH​ 表示输入的高度， I W I_W IW​ 表示输入的宽度。
卷积核的大小为 ( K H K_H KH​, K W K_W KW​)，其中 K H K_H KH​ 表示卷积核的高度， K W K_W KW​ 表示卷积核的宽度。
输出特征图的大小为 ( O H O_H OH​, O W O_W OW​)，其中 O H O_H OH​ 表示输出的高度， O W O_W OW​ 表示输出的宽度。
输出维度计算：
输出特征图的大小可以通过以下公式计算：
O H = ( I H − K H + 2 ∗ P H ) / S + 1 O_H = (I_H - K_H + 2 * P_H) / S + 1 OH​=(IH​−KH​+2∗PH​)/S+1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a722411de368c306e530d6315e3e30a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa936e2968ef8c09763b50b9b7b8303d/" rel="bookmark">
			Git 概述、命令、分支，免密登录；及 Idea 集成 GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git Git 概述 Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目
Git 易于学习，占地面积小，性能极快。它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具
集中化的版本控制系统诸如 CVS、SVN 等、都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法
这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌握每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易
事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作
像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份
分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷
服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全） Git 分为工作区（本地磁盘）-暂存区（临时存储）-本地库（历史版本）-远程库（托管中心）
Git 的当前版本是基于上一版本的，因此不能删除历史版本代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库 局域网：GitLab互联网：GitHub、Gitee Git 安装 略
Git 命令 常用命令
命令名称作用git config --global user.name设置用户签名git config --global user.email设置用户签名git init初始化本地库git status查看本地库状态git add 文件名添加到暂存区git commit -m “提交说明” 文件名提交到本地库git reflog查看历史记录（含版本号前七位）git reset --hard 版本号版本穿梭 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码
这里设置的用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系
较之于 git reflog，git log 可以看到更完整的历史记录（包含日期、用户名、邮箱和完整版本号）
Git 版本穿梭的底层是修改指针引用
head → master → second（指向 master 分支的第二版）head → master → first（指向 master 分支的第一版） Git 分支 在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支的底层其实也是指针的引用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa936e2968ef8c09763b50b9b7b8303d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e808bce8d8743f46a9f904745c9f80e/" rel="bookmark">
			【2023 week1】0xgame-CTF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 找不到且不对劲的flag永远进不去的后门随便乱搞的shellcode⾼端的syscall我后门呢got-it字符串和随机数 找不到且不对劲的flag ls -a 显示隐藏文件 cd .secret cat flag 即可 永远进不去的后门 read函数之前的关于参数的汇编得出buf与rbp相差0x40
from pwn import* context(os="linux",arch="amd64",log_level="debug") file=remote("8.130.35.16",51002) print(p64(0x401298)) payload=b"a"*0x48+p64(0x401298) file.send(payload) file.interactive() 随便乱搞的shellcode mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享
time（）当参数为NULL时，返回值是从1970年1月1日至今所经历的时间（以秒为单位）
rand()需要一个“种子”来进行生成伪随机数。而如果我们仅仅调用rand()函数，而没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1。随机种子相同，每次产生的随机数也会相同。解决办法就是使用srand()函数产生随机种子
如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。
函数返回值类型 (* 指针变量名) (函数参数列表);
void(*)(void) --表示一个返回值为void，没有参数的函数指针 (void(*)(void))--表示将函数强转成返回值为void，没有参数的函数的类型转换 在Linux中一切皆文件，文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。
标准输入输出的指向是默认的，默认打开一个终端后，0，1，2都指向同一个位置也就是当前终端。我们可以修改它们的指向，也即重定位
close（1）关闭了标准输出
沙盒（英语：sandbox，又译为沙箱），计算机专业术语，在计算机安全领域中是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。
换行符对应十六进制ascll码 0x0a
从0x20230000写入
bufa（）的函数地址为0x20230000~0x20230000+255 即0x20230100（但不包括该地址）
NOP指令即“空指令”。执行到NOP指令时，CPU什么也不做，仅仅当做一个指令执行过去并继续执行NOP（地址增加的方向）后面的一条指令
内存中的十六进制90为nop指令
shellcraft.sh() 生成的是shell的汇编代码
asm(shellcraft.sh() ) 生成的是shell的二进制码（在内存中存放和该码一样）
b"90"在内存中存放是90的十六级进制ascll码
b"\x90"在内存中存放就是90（十六进制形式）
from pwn import* context(os="linux",arch="amd64",log_level="debug") file=remote("8.130.35.16",51003) payload=asm(shellcraft.sh()).rjust(0x100,b"\x90") file.sendlineafter("code:",payload) file.interactive() ⾼端的syscall 首先可以发现一个alarm函数，修改其参数，不然影响调试
syscall和int 80都是系统调用
ROPgadget --binary 文件名 --only “pop|ret” | grep rdi
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e808bce8d8743f46a9f904745c9f80e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21c3a13d702be8ae58c401b320c3d409/" rel="bookmark">
			python字符串压缩以及还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串压缩是将一个字符串的长度减小，使其占据更少的存储空间。字符串还原则是将压缩后的字符串还原成原始字符串。
Python中可以使用多种方法实现字符串压缩和还原：
方法一：使用字符串替换的方法实现压缩和还原 压缩方法： def compress_string(string): compressed = "" count = 1 for i in range(len(string)-1): if string[i] == string[i+1]: count += 1 else: compressed += string[i] + str(count) count = 1 compressed += string[-1] + str(count) return compressed 还原方法： def decompress_string(compressed): decompressed = "" for i in range(0, len(compressed), 2): decompressed += compressed[i] * int(compressed[i+1]) return decompressed 方法二：使用Python内置库zlib进行压缩和还原 压缩方法： import zlib def compress_string(string): compressed = zlib.compress(string.encode()) return compressed 还原方法： import zlib def decompress_string(compressed): decompressed = zlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21c3a13d702be8ae58c401b320c3d409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c502d055558d2fe66935dbcfdfec81c/" rel="bookmark">
			Vue3最佳实践 第八章 ESLint 与 测试 ( ESLint )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESLint ​在所有的JavaScript 项目开发中我们都会接触到 ESLint 这个词，ESLint 是个什么样的组件会给为项目做些什么吗？ESLint 是一种检查语法错误以及代码是否按照预定规则编写的工具。ESLint 可以帮助开发者发现代码中潜在的错误。在Vue项目中Eslint一般都会配合其他语法检测工具一起使用，最经典的组合是Eslint+ Prettier 。
​Eslint 和 Prettier 并不局限于 Vue.js，而是掌握 JavaScript 的必备知识，所以推荐给不懂 ESLint 的同学。即使你看了这篇文章，你也会无法理解 ESLint 和 Prettier 的所有规则，但是通过查看运行你可以完全理解 ESLint 和 Prettier 是做什么的。下面让我们通过实际检查操作而不是用文字解释来轻松理解 ESLint 的作用与使用。
目录 ESLint1 ESLint创建2 ESLint 规则设置3 ESLint验证设置4 ESLint格式化设置5 ESLint自动修复6 Prettier7 Babel8 airbnb 与 standard9 ESLint 中TypeSript设置 第一章 Vue3项目创建 1 Vue CLI 创建vue项目
第一章 Vue3项目创建 2 使用 Webpack 5 搭建 vue项目
第一章 Vue3项目创建 3 Vite 创建 vue项目
第二章 Vue3 基础语法指令
第三章 Vue Router路由器的使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c502d055558d2fe66935dbcfdfec81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f1a3297d0180ada255dc6de0589f3e/" rel="bookmark">
			vue3中动态设置网页图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据后端返回的配置数据来设置网页图标
在App.vue中加入
let link = document.querySelector("link[rel*='icon']") || document.createElement("link"); link.type = "image/x-icon"; link.rel = "shortcut icon"; link.href = respon.Data.applic_ico document.getElementsByTagName("head")[0].appendChild(link); 其中link.href就是图标的地址，这里用的是请求配置接口的返回值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e71ef2a20fe35a65d68093253c39ead/" rel="bookmark">
			前端（二十五）——前端实现 OCR 图文识别的详细步骤与示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁博主：小猫娃来啦
😁文章核心：前端实现 OCR 图文识别的详细步骤与示例代码
文章目录 OCR技术的介绍第一步：确定使用的 OCR API第二步：创建前端界面第三步：添加图像上传功能第四步：发送识别请求和处理识别结果第五步：完善代码添加注释结论附录 OCR技术的介绍 什么是OCR？
它是一种将印刷体和手体文字转换为可编辑和可搜索的电子文本的技术。OCR通过将图像或扫描文件中的文字识别并转录成机器可读的文本格式，从而实现自动化的文字识别和提取。OCR技术可以应用于各种场景，包括文字文档的扫描与转录、数字化图书馆、自动化数据录入、机器翻译、自动化表单填写等。OCR技术可以极大地提高处理文档和数据的效率，使得文字信息更容易访问和利用。
在现代应用程序中，OCR（Optical Character Recognition）技术被广泛应用于将图像转换为可编辑的文本数据。本文将详细介绍如何在前端实现 OCR 图文识别功能，并提供了相应的代码示例。无论你是一个前端开发新手还是有经验的开发者，本文将以简洁明了的步骤帮助你实现这一功能。
第一步：确定使用的 OCR API 这一步需要根据你选择的 OCR API 来进行相应的准备工作。每个 OCR API 都有相应的文档和示例代码，你需要注册账户并获取 API 密钥。
OCR API 概述和选择：
OCR API 是一种提供图像文本识别功能的服务。它能够将包含文本的图像转换为可编辑的文本数据。在选择 OCR API 之前，你可以了解各个 OCR API 的功能、支持的图像类型、识别准确度、速度、文档和使用案例等方面的信息。
常用 OCR API 的比较和推荐：
一些常用的 OCR API 包括 Google Cloud Vision API、Microsoft Azure OCR API、Tencent OCR API 等。在选择 OCR API 时，你可以考虑其可靠性、易用性、性能、定价和适用场景。
注册和获取 API 密钥的步骤：
为了使用 OCR API，你需要注册一个账户，并获取 API 密钥。通常，在 OCR API 提供商的官方网站上，你可以找到注册页面并完成注册。一旦注册成功，你会获得一个 API 密钥，用于身份验证和向 OCR API 发送识别请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e71ef2a20fe35a65d68093253c39ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fbc0866e69eb2a6fbec5fb188ad6653/" rel="bookmark">
			使用CMake构建Qt程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文作者：黄邦勇帅(原名：黄勇)，QQ：42444472 (读者意见可发至QQ)
本系列文章是对**《C++语法详解》和《Qt5.10 GUI完全参考手册》**的增补，以增加读者对构建C++程序底层的了解。
主要对Makefile和CMake进行讲解，文章由浅入深，浅显易懂，看似简单却很有深度，是一本难得的比较全面的深入且细致的讲解Makefile和CMake的文章。
本系列文章主要参考文献为Microsoft官方文档，GNU make官方文档，CMake官方文档。
本文摘自本人所作《CMake、Makefile指南》 百度网盘地址
链接：https://pan.baidu.com/s/1ynEyr3Sqhv1SWvxmE5RLHQ?pwd=w9v3
提取码：w9v3
由于本人能力有限，文中难免有错漏之处，望广大读者指出更正，不胜感激
本文为原创文章，转载请注明出处，并注明转载自“黄邦勇帅(原名：黄勇)”，本文作者拥有完全版权
本文使用的工具及其版本情况
 本文使用的操作系统为windows10 22H2(64bit)
 cmake的版本为CMake 3.27.0-rc4
 本文使用mingw32-make生成器，其版本为GNU Make 4.2.1。
 本文使用的编译器为VC++，其版本为Visural Studio 2022，主要使用其中的cl、link等命令工具。编译器由CMake根据当前系统自动选择，若要指定自已的编译器，则需要手动配置比较多的CMake变量，详见对交叉编译和工具链的讲解。
第14章 使用CMake构建Qt程序 14.1 使用CMake构建一个简单的Qt程序 14.2 CMake自动调用uic.exe工具生成头文件的过程及原理 14.21 Qt构建工具 14.2.2 CMake自动调用uic.exe工具生成头文件的过程及原理 14.3 CMake自动调用moc.exe工具处理Qt的元对象系统 14.3.1 moc简介 14.3.2 Qt专有宏位于头文件中 14.3.3 Qt专有宏位于源文件中 14.3.4 与moc有关的其他变量和属性 14.4 使用Qt提供的CMake命令构建Qt程序 14.4.1 qt_standard_project_setup()命令 14.4.2 qt_add_executable()命令 14.4.3 qt_add_library()命令 14.4.4 qt_finalize_target()命令 14.5 在Qt中使用CMake构建Qt程序 参考文献：CMake官方帮助文档、Qt官方帮助文档
作者：黄邦勇帅(原名：黄勇） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac83ec9f48486240f1c92d50eb6d89e5/" rel="bookmark">
			python中的迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，迭代器（Iterator）是一个用于遍历可迭代对象的对象。迭代器提供了一种逐个访问元素的方式，而不需要提前知道可迭代对象的全部内容。迭代器基于迭代协议，需要实现__iter__()和__next__()两个特殊方法。
以下是迭代器的特点和使用方法：
特点：
迭代器是惰性计算的，只在需要时逐个生成下一个元素，节省内存和计算资源。迭代器只能前进，不可后退，每次调用__next__()方法返回下一个元素。 创建迭代器：
可以通过实现一个类并在类中定义__iter__()和__next__()方法来创建迭代器。__iter__()方法返回迭代器本身，而__next__()方法返回迭代器的下一个元素。 使用迭代器：
使用iter()函数将可迭代对象转换为迭代器，或者直接调用可迭代对象的__iter__()方法获得迭代器。使用next()函数或调用迭代器的__next__()方法获取迭代器的下一个元素。在迭代结束后，迭代器会引发StopIteration异常，可通过捕获异常来结束迭代。 以下是一个示例，展示如何使用迭代器遍历一个列表：
my_list = [1, 2, 3, 4, 5] my_iterator = iter(my_list) # 将列表转换为迭代器 print(next(my_iterator)) # 输出: 1 print(next(my_iterator)) # 输出: 2 # 使用循环遍历迭代器 for item in my_iterator: print(item) # 输出: 3 4 5 在上述示例中，通过调用iter()函数将列表my_list转换为迭代器my_iterator。然后，使用next()函数逐个获取迭代器的下一个元素。最后，使用for循环遍历迭代器输出剩余的元素。
迭代器是Python中一种强大且灵活的工具，常用于遍历大型数据集或实现自定义的可迭代对象。它提供了一种高效的方式来处理逐个访问元素的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b958a3b676c40195e2c6fa2b84b7e6/" rel="bookmark">
			java try throw exception finally 遇上 return break continue造成异常丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下所示，是一个java笔试题，考察的是抛出异常之后，程序运行结果，但是这里抛出异常，并没有捕获异常，而是通过finally来进行了流程控制处理。
package com.xxx.test; public class ExceptionFlow { public static void main(String[] args) { try { System.out.println("hello " + func()); } catch (Exception e) { e.printStackTrace(); } } public static int func() { int a = 0; for (int i = 0; i &lt; 3; i++) { try { throw new RuntimeException("xx"); } finally { continue; } } return a; } } 运行程序，打印结果如下所示：
这里结果有些出人意料，并没有打印异常信息，其实就是try finally遇到了continue，导致异常信息丢失。如果这里，我们稍微改变一下，把finally中的continue注释，再来看看结果：
这次打印了异常信息。
下面再来看看另一个例子：
package com.xxx.test; public class ExceptionDemo { public static void main(String[] args) { try { func(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b958a3b676c40195e2c6fa2b84b7e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c488e334a40a74af35f6a63ad96f571/" rel="bookmark">
			python中的with
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，with语句是一种上下文管理器的用法，用于提供对资源的自动管理和释放。with语句的作用是确保在代码块结束后，相关资源会被正确释放，无论代码块是否发生异常。
通常，with语句用于处理文件、数据库连接、网络连接等需要显式打开和关闭的资源，以确保在使用完资源后正确地释放它们。使用with语句可以简化资源管理的代码，并提高代码的可读性。
with语句的基本语法结构如下：
with &lt;expression&gt; as &lt;variable&gt;: # 执行一些操作，使用资源 # 在代码块结束后，自动释放资源 在上述代码中，&lt;expression&gt;表示一个上下文管理器对象，它必须具有__enter__和__exit__方法。&lt;variable&gt;是一个可选的变量名，用于引用上下文管理器的返回值。
with语句的执行过程如下：
执行&lt;expression&gt;的__enter__方法，获取上下文管理器对象，并将其赋值给&lt;variable&gt;（如果指定了变量名）。执行with语句内部的代码块，使用相关资源进行操作。不论代码块是否发生异常，都会执行&lt;expression&gt;的__exit__方法，用于释放资源。如果发生异常，异常信息会传递给__exit__方法。 使用with语句的好处是，无论代码块是否发生异常，都会自动确保资源的正确释放，避免资源泄露和错误处理的繁琐。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51368cc58d9a8c4f8e09207345b0a43/" rel="bookmark">
			git建仓库小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git建仓库小记 1.新建远端git仓库2.新建本地仓库3.添加ssh key4.将本地仓库关联到远端5.push &amp; pull 每次新建git项目的时候都要翻翻之前收藏的几篇帖子，索性自己汇总一下记录，以后一次粘贴搞定。
1.新建远端git仓库 这个比较简单，网页上点两下就能创建完毕。
2.新建本地仓库 打开git终端，先创建本地账户
git config --global user.email "you@example.com" git config --global user.name "Your Name" git init 这样就可以在项目目录下多出一个.git文件夹，里面保存着相关项目的基本信息。
3.添加ssh key 如果是首次使用git管理项目，需要添加ssh key，这样后续push和pull更加方便。
ssh-keygen -t rsa -C "you@example.com" 这样就生成了自己的公钥和私钥，windows系统默认存放在C:/Users/{user name}/.ssh目录下，linux存放在 ~/ 目录。将公钥id_rsa.pub的内容粘贴到git上的ssh-key上即可。
4.将本地仓库关联到远端 git remote add origin https://github.com/&lt;remote&gt;.git 5.push &amp; pull 由于初始远端为空仓库，推送需要用以下命令：
git push -u origin master 后续直接用：
git push origin master 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9196fbe3533bc8477ab5dc0eae0c9ba1/" rel="bookmark">
			【TCP/IP协议详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TCP/IP协议简介 TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。
TCP/IP协议是Internet最基本的协议，其中应用层的主要协议有Telnet、FTP、SMTP等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有TCP、UDP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网络接口层或数据链路层，主要协议有ARP、RARP，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。
二、OSI七层参考模型 OSI的参考模型共有7层，是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。由低层至高层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
2.1 OSI七层参考模型与TCP/IP协议模型各层对应关系 三、TCP报文结构 下图为TCP首部结构定义，定义了TCP协议如何读取和解析数据。
3.1 TCP端口 TCP的连接需要四个要素来确定唯一的连接：源IP + 源端口、目的IP + 目的端口， 因此TCP首部预留了两个16位作为端口号的存储，IP地址由上一层IP协议负责传递。源端口和目的端口各占16位，即两个字节，因此端口号的范围为216=65536（0 ~ 65535）。此外0 ~ 1023端口是系统保留的，1023 ~ 65535是用户使用的端口范围。
3.2 TCP的序号和确认号 ① 序号（Sequence number，缩写seq，32位）：用于标识数据包在数据流中的位置。发送数据包时数据比较大时则需要分片，序号则用来区分不同的分片并排序，确保了数据的顺序性。
② 确认号（Acknowledge number，缩写ack，32位）：确认数据是否被收到，一般为收到的序号值 + 1。只有 ACK 标志为 1 时确认序号字段才有效。
3.3 数据偏移 表示TCP报文首部长度， 即TCP报文段的数据起始处距离TCP报文段的起始处的长度。以4字节为单位，占4位，取值范围为0~15。由此可计算出TCP首部的最大字节数为 4 * 15 = 60。TCP首部长度 - 20(固定首部长度) = 选项长度。
如果数据偏移值为5，则整个TCP报文头的长度是4 * 5 = 20字节，相当于TCP首部不包含选项。
如果数据偏移值为15，则整个TCP报文头的长度是4 * 5 = 60字节，相当于TCP首部中选项占40字节。
3.4 保留位 占6位，默认为0。
3.5 TCP控制位 URG：紧急标志位，表示数据包的紧急指针生效，数据具有高优先级，优先传送，而不按照原先的队列顺序传送，督促中间设备尽快处理；
ACK：确认标志位，对已接收的数据包进行确认；
PSH：推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
RST：重置标志位，用于连接复位、拒绝错误和非法的数据包；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9196fbe3533bc8477ab5dc0eae0c9ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb2016ad95913a27cba08a40774eb2c/" rel="bookmark">
			将输入流（InputStream）转换为字节数组（byte[]）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段代码是一个Java方法，用于将输入流（InputStream）转换为字节数组（byte[]）。
方法的实现过程如下：
创建一个ByteArrayOutputStream对象，用于存储从输入流中读取的数据。定义一个大小为1024的字节数组b，用于临时存储从输入流中读取的数据。使用while循环不断从输入流中读取数据，直到读取完毕（即is.read(b)返回-1）。 在每次循环中，调用is.read(b)方法将数据读取到字节数组b中，并将实际读取到的字节数赋值给变量len。使用bos.write(b, 0, len)方法将读取到的数据写入到ByteArrayOutputStream对象中。调用bos.toByteArray()方法将ByteArrayOutputStream对象转换为字节数组array。关闭ByteArrayOutputStream对象。返回转换后的字节数组array。 package day28.UpLoad; import java.io.BufferedReader; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; /** * 此类用于演示关于流的读写方法 * */ public class StreamUtils { /** * 功能：将输入流转换成 byte[] * * @param is * @return * @throws Exception */ public static byte[] streamToByteArray(InputStream is) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream();//创建输出流对象 byte[] b = new byte[1024]; int len; while ((len = is.read(b)) != -1) { bos.write(b, 0, len); } byte[] array = bos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb2016ad95913a27cba08a40774eb2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad8cba9145d145b9805ab4d7b93de235/" rel="bookmark">
			进阶JAVA篇- Java 综合基本语法实践（习题一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路漫漫其修远兮，吾将上下而求索。—— 屈原
目录
第一道题：集合的灵活运用
第二道题：基础编程能力
第三道题： 手写 ArrayList 集合（模拟实现 ArrayList 核心API）
第四道题：二分查找的应用
第五道题：手写单链表（模拟实现 LinkedList 集合的核心API）
第一道题：集合的灵活运用 题目如下：
对题目进行分析：
可以根据囚犯的编号、所占的位置信息，可以封装成一个囚犯类，接着就是遍历 100 个人的信息了，推荐可以用 for 来遍历。这里要注意的是不能重复出现相同的编号，这里可以单独构造一个方法，去除重复的编号。对于删除奇数位置上的数据，那么新 new 一个集合来接收占位为偶数的元素就好了。这题不算难，可以根据题目自己试着敲一敲。
具体代码如下：（答案肯定是不唯一的，答案对了，还有逻辑清晰即可）
先定义了囚犯类：
public class People { private int number; private int location; public People(int number, int location) { this.number = number; this.location = location; } public People() { } public int getNumber() { return number; } public void setNumber(int number) { this.number = number; } public int getLocation() { return location; } public void setLocation(int location) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad8cba9145d145b9805ab4d7b93de235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f628b791b08085287de095045eaaf78e/" rel="bookmark">
			基于单片机的温湿度和二氧化碳检测系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘 要... 2
第一章 绪论... 5
1.1 研究课题背景... 5
1.2 国内外发展概况... 7
1.3 课题研究的目的... 8
1.4 课题的研究内容及章节安排... 9
第二章 二氧化碳和温湿度检测系统控制系统的设计方案... 11
2.1 设计任务及要求... 11
2.2 二氧化碳和温湿度检测系统总体设计方案... 11
2.3 方案的论证与分析... 12
第三章 系统硬件部分设计... 13
3.1 总体设计... 13
3.2 主控制器设计... 14
3.2.1 芯片介绍... 14
3.2.2 最小系统电路设计... 16
3.2.3 时钟电路设计... 17
3.2.4 复位电路设计... 17
3.2.5 下载电路设计... 18
3.3 显示模块... 18
3.4 二氧化碳检测电路... 20
3.5 温湿度检测电路... 22
3.6 报警电路... 24
第四章 系统软件部分设计... 25
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f628b791b08085287de095045eaaf78e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e03ce7ddf63730a00782e914e23f9264/" rel="bookmark">
			什么是迭代器，Python迭代器及其用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面章节中，已经对列表（list）、元组（tuple）、字典（dict）、集合（set）这些序列式容器做了详细的介绍。值得一提的是，这些序列式容器有一个共同的特性，它们都支持使用 for 循环遍历存储的元素，都是可迭代的，因此它们又有一个别称，即迭代器。
从字面来理解，迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这​ 些 Python 提 ​供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。
我们已经学会了如何自定义一个序列类，但该序列类对象并不支持迭代，因此还不能称之为迭代器。如果要自定义实现一个迭代器，则类中必须实现如下 2 个方法：
__next__(self)：返回容器的下一个元素。__iter__(self)：该方法返回一个迭代器（iterator）。 例如，下面程序自定义了一个简易的列表容器迭代器，支持迭代：
class listDemo:def __init__(self):self.__date=[]self.__step = 0def __next__(self):if self.__step &lt;= 0:raise StopIterationself.__step -= 1#返回下一个元素return self.__date[self.__step]def __iter__(self):#实例对象本身就是迭代器对象，因此直接返回 self 即可return self#添加元素def __setitem__(self,key,value):self.__date.insert(key,value)self.__step += 1mylist = listDemo()mylist[0]=1mylist[1]=2for i in mylist:print (i) 程序执行结果为：
2
1
除此之外，Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：
iter(obj[, sentinel])
其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象，具体功能后面会讲。
可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 __call__() 方法，就可以将该类的实例对象编程可调用对象。有关 __call__() 方法，可阅读《Python __call__()》做详细了解。
我们常用的是仅有 1 个参数的 iter() 函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的 __next__() 方法即可实现迭代。例如；
# 将列表转换为迭代器myIter = iter([1, 2, 3])# 依次获取迭代器的下一个元素print(myIter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e03ce7ddf63730a00782e914e23f9264/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43be102a147f09d7c2e90e91fe4067ed/" rel="bookmark">
			正则表达式包含数字和字符匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		至少6位。
pattern : (?=.[0-9])(?=.[A-Za-z])[0-9A-Za-z]{6,}
正则表达式中的“?=”是一个正向预查字符，它的意思是匹配前一个字符出现的最少一次。具体来说，当一个匹配出现时，它会检查前一个字符是否符合要求，如果符合，则继续匹配下一个字符，否则停止匹配。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765472486413a3d6b0a43179a79615e5/" rel="bookmark">
			【2023最新】Python 百度贴吧 爬取文本作者以及图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1 分析百度贴吧2 请求url获取源代码3 解析源代码 获取数据4 保存到csv文件5 完整源代码5 效果展示 前言 今天爬取百度贴吧
先看效果
可以输入爬取贴吧名，爬取的总页数，爬取的字段有帖子id，标题，内容，发表作者，发表时间，最后回帖人，最后回帖时间，图片
爬取的时候看到中间有几个url请求了0条评论，我们看下
不是反爬的问题，是网站没有
我们再看看爬取的图片
可以看到，图片也是大图没有问题
教程开始
1 分析百度贴吧 首先搜索贴吧
可以看到url后面多了几个参数，我们翻到第二页继续观察
可以看到，百度贴吧的参数就是 kw 为搜索的关键词 ie为编码 pn为页码 一页为50
分析好url后我们就开始看他是静态资源还是动态资源
右键查看页面源代码
在源代码中搜索页面的内容，很明显，这个是静态资源
我们就不需要抓包了，只需要请求url就行
2 请求url获取源代码 右键检查，或者F12,打开开发者工具
查看请求的url，可以看到星空那俩字被编码了，所以我们请求的时候也要编码
复制请求标头下的"User-Agent"
首先尝试请求头只有一个 “User-Agent” 能不能请求成功
可以看到，请求头只放一个 UA也可以请求成功
所以我们使用UA库来防止被反爬
关于UA库点击查看 2023最新!!!Python爬虫获取 UA 工具 让你爬虫时如鱼得水的工具和模块
import random import urllib.parse import requests from fake_useragent import UserAgent # 获取网页源代码 def get_HTML(url): headers = { "User-Agent": random.choice(ua_list), } response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/765472486413a3d6b0a43179a79615e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8638563b283527ad87982a555792a8aa/" rel="bookmark">
			在arcgis地图上简单添加一个图层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Add a feature layer，这次来个简单的arcgis学习例子。在arcgis地图上简单添加一个图层展示。
一、创建一个基图 // create a map with the BasemapStyle topographic val map = ArcGISMap(BasemapStyle.ARCGIS_TOPOGRAPHIC) // set the map to be displayed in the layout's MapView mapView.map = map 这里也可以是下面方式来创建基图 val url = "http://map.geoq.cn/arcgis/rest/services/ChinaOnlineCommunity/MapServer" //val url = "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer" val arcGISTiledLayer = ArcGISTiledLayer(url) val map = ArcGISMap(Basemap(arcGISTiledLayer)) 二、设置一个展示目标位置 // set the viewpoint, Viewpoint(latitude, longitude, scale) mapView.setViewpoint(Viewpoint(34.0270, -118.8050, 200000.0)) 三、创建一个新的图层 // create the service feature table val serviceFeatureTable = ServiceFeatureTable("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8638563b283527ad87982a555792a8aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5220993e731bc53550cc2a3bac6eaa18/" rel="bookmark">
			1.40 基于WiFi的室内定位深度学习方法综述（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文献来源：Feng X, Nguyen K A, Luo Z. A survey of deep learning approaches for WiFi-based indoor positioning[J]. Journal of Information and Telecommunication, 2022, 6(2): 163-216.
以下为文章的中文翻译版
摘要 最流行的室内定位方法之一是WiFi指纹识别，从一开始，它就被当作一个传统的机器学习问题来解决，平均精度达到几米。近年来，深度学习作为一种替代方法出现，大量出版物报告了亚米级的定位精度。因此，这项调查及时、全面地回顾了用于WiFi指纹识别的最有趣的深度学习方法。在此过程中，我们的目标是在各种定位评估指标下为不同的读者识别最有效的神经网络。我们将证明，尽管出现了新的WiFi信号测量(即CSI和RTT)，RSS在深度学习下仍能产生有竞争力的表现。我们还将展示，在某些环境中，简单的神经网络比更复杂的神经网络表现得更好。
1. Introduction 在室内定位应用的技术中，WiFi是最常用的技术之一。由于智能手机无处不在，过去十年见证了WiFi设备的激增，包括电脑、智能手机和众多接入点(ap)。现在，办公室、医院、商场和工厂都密集地安装了WiFi接入点，为用户提供互联网服务。因此，利用这种技术进行室内定位是很方便的。然而，提出一个亚米级精度的wifi导航系统仍然是一个研究挑战。
这类系统的问题是高维数据。为了准确定位室内环境中的目标人物或物体，该系统需要分析来自附近数百个WiFi ap的信号。传统的机器学习方法在处理这种高维数据集时速度很慢。然而，最近的系统通过应用深度学习来利用这些大数据，这是一种相对较新的机器学习方法，可以提供输入数据的新表示。深度学习的本质使其适合处理大量高维数据。除了从离散输入数据中提取层次信息的能力外，深度学习还可以直接生成准确的位置估计。与传统的机器学习方法类似，深度学习可以作为回归器或分类器进行修改，以执行区分定位任务。因此，在目前基于wifi的室内定位系统中，深度学习可以作为一种特征提取方法，也可以作为一种定位预测方法。
作者在谷歌学术上汇集了1000多篇研究论文，满足以下三个条件:（1）必须包含“indoor”和“WiFi”关键字。（2）至少包含以下关键字之一:‘navigation’, ‘positioning’, ‘localization’, ‘tracking’。（3）至少包含以下关键词之一：‘deep learning’, ‘neural network’, ‘CNN’, ‘ANN’, ‘RNN’.
然后，每一篇论文被仔细审查，以确定其相关性和适合这篇文章。最后选取了150多篇研究论文进行进一步详细的比较分析。在此过程中，我们的目标是回答以下研究问题。室内定位系统最准确的WiFi信号测量是什么?接收信号强度、信道状态信息和往返时间是文献中报道的WiFi信号最常用的测量方法。基于wifi的室内定位系统最有效的神经网络是什么?普遍的看法是，具有复杂结构的神经网络将提供更好的结果(例如，CNN具有数十或数百个隐藏层)，广泛报道用于图像分类。同样的假设是否适用于WiFi室内定位?
1.1. 综述范围 室内定位只关注在受限环境下(如办公楼、医院、火车站、商场等)预测用户的位置。这样的环境往往包含多个房间、走廊和楼层，并挤满了家具、墙壁和人。因此，电磁信号在室内环境中传播时，通常会被阻挡、衰减和反射。本综述所涵盖的所有系统都在上述有限条件下的室内环境中进行实验。
虽然WiFi室内定位和深度学习已经独立存在，但直到最近几年才有研究人员开始将深度学习和神经网络应用到WiFi室内定位中。从一开始，传统的机器学习方法(即浅学习)在这一领域就占据了垄断地位。然而，浅学习无法有效利用海量的高维数据，难以达到亚米级的精度。深度学习的进步使研究人员能够找到WiFi数据的有效表示。这一趋势促使本文的写作。
在深度学习、神经网络和室内定位的交叉领域已经有了一些研究。然而，它们中的大多数要么专注于所有相关的机器学习方法，要么涵盖了广泛的室内技术。相比之下，本综述只强调基于wifi的系统，使用深度学习和神经网络，为读者提供对这种新兴方法的简明理解。
1.2. 文章的贡献 这篇综述的贡献如下。
（1）我们将基于深度学习的系统分为两类:使用深度学习作为特征提取方法的系统和使用深度学习作为定位预测方法的系统。所有的比较都是在每个类别中单独进行的。
（2）我们特别分析了不同WiFi信号作为深度学习系统输入的效果。
（3）我们充分考虑了不同类型神经网络的各种系统的结果，以找出WiFi室内定位系统最准确的解决方案。
（4）我们推导了一套标准的评估指标来评估和比较150多个基于深度学习的室内定位系统的性能。
本文的其余部分组织如下。第2节介绍WiFi指纹识别的基本思想。第3节介绍了室内定位系统中使用的WiFi技术的主要类型和数据测量。第4节侧重于深度学习和神经网络的一般概念，并进一步讨论了所涵盖论文中使用的主要神经网络类型。第5节概述了本综述中采用的常用评估指标。定位系统类别的分类将在第6节和第7节中提出，其中每个类别将在这两个节中进行彻底和单独的研究。最后，第8节总结全文并展望未来。
2. WiFi fingerprinting WiFi指纹识别是基于WiFi的室内定位中最流行的方法，它首先建立一个数据库，其中包含在目标室内环境中每个参考点收集的WiFi信号。WiFi指纹识别的目的是将用户接收到的实时WiFi信号与数据库中的WiFi信号进行匹配，从而根据两者的相关性对用户当前的位置进行定位估计。由于复杂的室内环境会严重影响WiFi信号的传播，因此目标区域内的每个位置都会有自己独特的WiFi信号模式，即WiFi指纹。环境越复杂，WiFi指纹就越明显。因此，定位系统可以利用WiFi指纹的这些特征来准确地对用户进行位置估计。
WiFi指纹识别方法通常分为离线阶段和在线阶段。WiFi室内指纹识别系统的基本结构示例如图1所示。离线阶段是准备阶段，在此阶段收集数据并进行预处理，然后将数据存储到数据集中。在室内定位系统中，数据集中的样本是在特定的环境中收集的，并标记为它们的目标，要么是它们所属的建筑物/楼层/网格，要么是它们的确切地面真值坐标。为了更好地提取数据中有用和有意义的信息，许多研究人员采用了归一化、填充缺失数据、选择接入点、增强和校准等预处理方法。一些从业者甚至应用机器学习方法来提取数据中最强大的特征，同时降低数据的维数和预测的计算复杂性。在离线阶段，利用采集到的数据对定位预测算法进行预训练，学习输入数据与输出预测之间的关系。在在线阶段，用户或接收器将在未知位置检测到的WiFi信号报告给定位系统，系统使用相同的预处理方法对新数据进行过滤。然后，将与脱机阶段相同格式的数据馈送到定位算法中。最后，利用定位算法对用户当前位置进行预测。
图1。以机器学习为定位算法的经典WiFi室内指纹识别系统的基本架构。该系统分为离线阶段和在线阶段。在离线阶段，采集WiFi指纹信号，即这里的WiFi RSS数据，进行预处理、标记并存储在数据库中。在在线阶段，通过机器学习定位算法将用户接收到的RSS信号与数据库中的信号进行比较，得到最终的位置估计。基于深度学习的WiFi室内指纹识别系统的基本架构如图9和图19所示。
3. WiFi signal measures 本节介绍本文所涉及的WiFi室内定位系统的主要技术类型和信号措施。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5220993e731bc53550cc2a3bac6eaa18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275bce0c0df6fd86e51b3c46b6dc7be4/" rel="bookmark">
			nodejs打包无法读写目录报错pkg new Error(‘Cannot mkdir in a snapshot. Try mountpoints instead.‘) ^
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把__dirname改为process.cwd()
完美运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c99fa8418f32493ffe6b653e4fb271b/" rel="bookmark">
			36基于matlab的对分解层数和惩罚因子进行优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于matlab的对分解层数和惩罚因子进行优化。蚁狮优化算法优化VMD,算术优化算法优化VMD，遗传优化算法优化VMD，灰狼优化算法优化VMD，海洋捕食者优化算法优化VMD，粒子群优化VMD，麻雀优化算法优化VMD，鲸鱼优化算法优化VMD。程序已调通，可直接运行。
36matlab各类优化VMD算法信号处理 (xiaohongshu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d808b092070b2b7546ffb8f1deaad2/" rel="bookmark">
			单片机的电子琴-仿真 毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 1 简介
Hi，大家好，今天向大家介绍一个学长做的单片机项目
单片机的电子琴-仿真
大家可用于 课程设计 或 毕业设计
🔥 项目分享:
https://gitee.com/feifei1122/simulation-project
2 项目介绍 根据要求，设计以单片机为核心的多音阶电子琴系统，可随意弹奏想要表达的音乐。针对要求控制的对象完成程序的编制。硬件软件联调，完成题目所要求的功能。有高中低三个音阶，并有显示电路。 用独立式键盘的7个按键分别对应相应的音符，当按下某一个按键时，产生一个相应音符，操作者按一定的节奏、规律进行输入时，信号经过单片机处理，然后经音频放大后经扬声器输出音频信号，产生乐曲。本次设计有一个创新，就是预先存放一段音乐程序在芯片内，整个设计既可以作电子琴用又可以作音乐盒用，且带显示功能
最后 🔥 项目分享:
https://gitee.com/feifei1122/simulation-project
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac7c893b693cec1fdb50ef063ab7aa1/" rel="bookmark">
			单元测试，集成测试，系统测试的区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际的测试工作当中，我们会从不同的角度对软件测试的活动进行分类，题主说的“单元测试，集成测试，系统测试”，是按照开发阶段进行测试活动的划分。这种划分完整的分类，其实是分为四种“单元测试，集成测试，系统测试，验收测试"。这四类测试，其实是一种从局部到整体测试思想。
为了给题主以及各位同学介绍清楚这4类测试的区别，我以汽车生产测试的过程为例，来分别阐述下单元测试，集成测试，系统测试，验收测试。
一、单元测试 1、汽车制造举例
在汽车的生产制造器过程当中，要先针对汽车的零部件进行测试。比如说我们可以把轮胎进行全面的一个测试。轮胎的这个测试就可以认为“单元测试”。
2、测试工作中的理解
所谓的单元测试就是我们针对程序的最小单元先进行这个小规模的测试验证。
补充：单元测试也叫单侧，是针对代码的测试，一般是由【开发】来测试（单元开发完成后，开发自测）
二、集成测试 1、汽车制造举例
上面的轮胎测试通过之后，我们就要轮胎和其他测试正常的零部件进行组装。比如说我们把轮胎和车架这两个部分进行了组装，那么在组装后是不是也要进行测试？这就集成测试。
2、测试工作中的理解
集成测试，就是把通过单元测试的各个小模块，组装成更大的模块后，进行测试验证的过程。
补充：
1）集成测试，也叫组装测试，常发生在"软件还没开发完，但部分单元模块已开发完”的这个阶段。
2）集成测试最简单形式，就是把两个已经测试过的单元组合成一个组件，测试他们的接口。
3）集成测试，一般也认为是接口测试。
三、系统测试 1、汽车制造举例
当所有的汽车零部件都组装完毕之后，也就是形成了整车。我们还需要进行整车测试验证。整车测试就是系统测试。
2、测试工作中的理解
系统测试，就是把我们整个软件系统开发完毕之后，在模拟的真实环境下进行全面测试的过程。
补充：
1）系统测试是，软件开发完成，整理架构上的测试。
系统测试一般可以认为是功能测试。 四、验收测试 1、汽车制造举例
实车的测试验证之后，车企是不是就可以直接进行汽车的发布上市了？还不会，通常车企还会进行一些第三方专业汽车评测机构的测试，或者邀请一些汽车大V使用，进行试用反馈。这就是验收测试。
最终通过这四个测试环节，我们把汽车生产过程当中发现的所有问题都进行解决，才能保障汽车产品它的质量是符合最终的一个需求。这时候我们才能进行产品的发布和上市。
2、测试工作中的理解
在我们这款软件产品发布到用户之前，我们也会邀请不同的用户人群来进行测试反馈。
验收测试又分为内侧和公测。
举例游戏，所谓的内测，就是邀请少量的游戏重度使用用户，来进行游戏软件的使用反馈。
所谓公测，就是我们把这款软件产品发布到这个线上，让所有的用户来进行游戏产品的一个试用反馈。
通过这个内测和公测，最终我们的软件的问题解决完毕之后，才会进行正式版本的一个对外发布。
补充：验收测试，虽说是邀请用户来测试，但测试人员也需要全程跟踪参与。
五、写在最后 很多人经常把“黑盒测试、白盒测试、灰盒测试”和“单元测试，集成测试，系统测试，验收测试”搞在一起。
其实这几个测试分类要区分清楚也很清楚。
按照开发阶段划分，就是：单元测试，集成测试，系统测试，验收测试。
按照代码的可见度划分，就是：白盒测试（没有界面，只看见代码）、黑盒测试（只有界面，看不见代码）、灰盒测试（既看不到界面，又不深入代码）。
为什么这两类测试经常混在一起呢？原因是
白盒测试是代码级的测试，也就是单元测试。
黑盒测试，没有代码，只有界面测试，可认为是点点点的功能测试，这就是系统测试。
灰盒测试，看不到界面（非界面），又不深入代码，只是在代码的交界处（接口层）进行的校验，就是接口测试，也是集成测试。
希望今天的文章，0基础的同学能彻底清楚这几个测试分类概念。
Python接口自动化测试零基础入门到精通（2023最新版）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e27593ef9425fc407ed0fac121ab3cba/" rel="bookmark">
			C&#43;&#43;版-----信息学奥赛一本通-----编程启蒙--- #M1001. 石头剪刀布(game.cpp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】 AB两人石头剪刀布，0是石头，1是剪刀，2是布。赢一局加两分，平局各加一分。
【输入描述】 读入文件game.in
一个正整数n(n&lt;=100)
以下n行分别是AB两人出的是什么
【输出描述】 输出文件game.out
两个正整数分别是AB两人的分数
【样例输入】 3 0 1 2 2 0 2 Copy
###【样例输出】
3 3 代码 下载
#include&lt;bits/stdc++.h&gt; using namespace std; int A,B,C=0,D=0,n; int main(){ freopen("game.in","r",stdin); freopen("game.out","w",stdout); cin&gt;&gt;n; while(n&gt;0){ cin&gt;&gt;A&gt;&gt;B; if((A==0&amp;&amp;B==1)||(A==1&amp;&amp;B==2)||(A==2&amp;&amp;B==0)){ C=C+2; } else{ if(A==B){ C++; D++; } else{ D=D+2; } } n--; } cout&lt;&lt;C&lt;&lt;' '&lt;&lt;D; fclose(stdin);fclose(stdout); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726e1f4dcbf2ed2f02776780f3af1a3e/" rel="bookmark">
			java通过jol-core库分析对象内存分布以及查看Synchronized锁升级过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java开发中，我们可以借助jol-core这个库来查看对象内存信息。
引入依赖：
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.17&lt;/version&gt; &lt;/dependency&gt; 要查看对象内存信息，我们只需要调用ClassLayout.parseInstance(object).toPrintable() 如下所示的代码，是查看两个对象信息：
package com.xxx.mem; import org.openjdk.jol.info.ClassLayout; public class ObjectPrintExample { public static void main(String[] args) { Object object = new Object(); System.out.println(ClassLayout.parseInstance(object).toPrintable()); Object[] arr = new Object[10]; System.out.println(ClassLayout.parseInstance(arr).toPrintable()); } } 运行程序，打印信息如下所示：
从打印内容来看，我们看到了对象包含：对象头，对象体，对齐字节。
其中对象头包括： mark word,klass word,数组长度。如果对象不是数组，数组长度可以忽略不记，上图中，我们打印object，数组长度就没有体现（array length）。
我们这里重点关注一下对象头中的mark word，如下所示：
这里面通过对象头64位中的最后3位的值，我们看到它们取值不同，可能会出现几种状态，其中无锁 、偏向锁、轻量级锁，重量级锁正是Sychronized锁升级过程中表现出来的升级状态。
下面我们通过一段代码的运行来感受一下这几个状态的变化：
package com.xxx.mem; import org.openjdk.jol.info.ClassLayout; import java.util.concurrent.TimeUnit; public class LayoutPrintExample { public static void main(String[] args) throws InterruptedException { Object o = new Object(); // Step 1 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/726e1f4dcbf2ed2f02776780f3af1a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26167d9378a3ec2f17ce76d3936e867/" rel="bookmark">
			nginx: [alert] could not open error log file: open() “/usr/local/nginx/logs/error.log“ failed 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
错误现象：
问题分析：
解决方式：
方式一：重新编译
方式二：使用参数-p（推荐）
方式三：将nginx bin文件拷贝到默认prefix里运行
错误现象： 我在容器内运行nginx，运行方式是：
/app-service/cloudland/nginx/sbin/nginx -c /app-service/cloudland/nginx/conf/nginx.conf
报了上述的错误，全面的错误如下
nginx: [alert] could not open error log file: open() "/usr/local/nginx/logs/error.log" failed (2: No such file or directory)
2021/08/19 14:22:51 [emerg] 8956#0: mkdir() "/usr/local/nginx/client_body_temp" failed (2: No such file or directory)
问题分析： 我在编译机器上编译nginx，编译出的nginx编译参数是：
然后拷贝到容器或者其他的运行机器上运行报上述错误，
chek了一下nginx.conf也没有发现问题，我nginx日志相关的配置
是个绝对路径， 日志文件也存在，奇怪报了上述错误，
最后发现是nginx编译是prefix的路径与运行的路径不一致，使用了默认的/usr/local,而不是我存放nginx bin文件的运行路径，即/app-service/cloudland/nginx，而导致了上述错误，
解决方式： 方式一：重新编译 重新编译nginx，编译时指定你以后要运行nginx bin文件的路径，我这里是--prefix=/app-service/cloudland/nginx，然后在运行下面的命令即可，这种方式比较麻烦，还要重新编译nginx
/app-service/cloudland/nginx/sbin/nginx -c /app-service/cloudland/nginx/conf/nginx.conf
方式二：使用参数-p（推荐） 运行nginx时候，加上-p参数重新指定prefix路径，就可以了
/app-service/cloudland/nginx/sbin/nginx -p /app-service/cloudland/nginx -c /app-service/cloudland/nginx/conf/nginx.conf
方式三：将nginx bin文件拷贝到默认prefix里运行 即按默认方式，将nginx bin文件拷贝到/usr/local/nginx/sbin下运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac474b3d465f7061854e02acb7b6a54/" rel="bookmark">
			C&#43;&#43;模板类用作参数传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
在模板类&lt;&gt;传递参数的一种实现。记不住，以此记录。
// dome.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。 // #define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt; //#include "tools.h" #include &lt;functional&gt; using namespace std; #include &lt;vector&gt; template &lt;class T&gt; class A { public: T name; }; template &lt;class T&gt; class AA { public: T name; }; template &lt;template&lt;class&gt; class TT, class T, class T1&gt; //声明形式 class B { public: TT&lt;T&gt; a; T1 age; }; int main() { //传递的是对象A或者AA B&lt;A, string, int&gt; b; b.a.name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac474b3d465f7061854e02acb7b6a54/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/45/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>