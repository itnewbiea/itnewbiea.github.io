<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551259f379d2e46e9b3f697db6e8a5c1/" rel="bookmark">
			MySQL数据库 - 数据库和表的基本操作（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：插入数据 任务描述 本关任务：为表同时插入多条我们规定的记录。
相关知识 为了完成本关任务，你需要掌握：如何为表一次性插入多条记录。
为表的所有字段插入数据 向表中插入数据最简单的方法就是使用INSERT语句。INSERT语句需要你声明要插入内容的表(table)名和内容(values)。
语法规则：INSERT INTO 表名 (字段名) VALUES (内容); 举个例子： 假设我们现在有一张空表MyUser如下：
接下来，我们要往空表中插入一条内容，插入(INSERT)语句为：
insert into MyUser(name,age) values('zhnagsan',18); 结果为：
插入过程如下：
我们检索到了一条数据的结果，一条完整的内容已经被填入了空表中。
分析： 在插入数据时，我们指定了所有的字段名，这样的好处是：即使我们打乱了原本字段的排列顺序，只要插入的数据与之匹配，插入都不会出错。其实，还有一种偷懒的办法，就是我们可以不填字段名，但是这样的话，就必须老老实实的按字段顺序来填入相应的数据。
为表的指定字段插入数据 有的时候，我们并不想往某个字段内插入完完整整的值，或者说，有的时候我们并没有完整的数据可以整整齐齐插入某个字段。这时候就需要我们只为指定好的字段插入数据了，其他的我们都不用管。换句话说，就是： 为表的指定字段插入数据，就是在INSERT中只向部分插入值，而其他字段的值为表定义时的默认值。
举个例子
假设我们现在有一张空表 MyUser 如下：
我们忽略字段 age，为表 MyUser 插入内容:
insert into MyUser(name) values('lisi'),('fawaikuangtu'),('zhangsan'); 结果为：
插入过程如下：
可以看到，由于我们建表时给字段 age 设置的默认值为 Null，所以插入数据时忽略该字段，就会默认给它赋值为空。
编程要求 根据提示，在右侧编辑器Begin-End处补充代码：
我们为你新建了一个空数据表tb_emp，请你为它同时添加3条数据内容；空数据表结构如下，注意字段3 为DeptId，倒数第二个字母为大写的i： 需要你同时添加的数据内容为： （注意，是同时插入多条记录） 测试说明 我会对你编写的代码进行测试，最终结果会如下图所示：
开始你的任务吧，祝你成功！
USE Company; #请在此处添加实现代码 ########## Begin ########## ########## bundle insert the value ########## INSERT INTO tb_emp (Id,Name,DeptId,Salary) VALUES (1,'Nancy',301,2300),(2,'Tod',303,5600),(3,'Carly',301,3200); ########## End ########## SELECT * FROM tb_emp; 第2关：更新数据 任务描述 有道是：人生在世，孰能无过。过而能改，善莫大焉!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551259f379d2e46e9b3f697db6e8a5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7180746398f7bad4721991bdc2aec1b7/" rel="bookmark">
			optionsapi和componsitonapi区分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ed63973359625e9538658d614f4f94/" rel="bookmark">
			边缘产品UnixBench测试结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Benchmark of EG900A-G22/4 Core BYTE UNIX Benchmarks (Version 5.1.3)
Test System Information System:EG900A-G22: GNU/LinuxOS:GNU/Linux -- 4.19.232 -- #2 SMP Wed Jun 22 11:13:28 CST 2022Machine:aarch64: aarch64Language:en_US.utf8 (charmap="ANSI_X3.4-1968", collate="ANSI_X3.4-1968")Uptime:06:28:32 up 2:21, 5 users, load average: 0.14, 0.26, 1.83; runlevel 5 Benchmark Run: 0 CPUs; 1 parallel process TestScoreUnitTimeIters.BaselineIndexDhrystone 2 using register variables10252783.3lps10.0 s7116700.0878.6Double-Precision Whetstone2860.5MWIPS10.0 s755.0520.1Execl Throughput1481.6lps30.0 s243.0344.6File Copy 1024 bufsize 2000 maxblocks143922.1KBps30.0 s23960.0363.4File Copy 256 bufsize 500 maxblocks41297.0KBps30.0 s21655.0249.5File Copy 4096 bufsize 8000 maxblocks397890.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ed63973359625e9538658d614f4f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc63aa01b5b39b0839a93b99fe094ed0/" rel="bookmark">
			LinuxIO总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU访问IO的方式 程序查询 cpu持续访问寄存器是否完成IO输入，直到检测到了完成会取出数据
程序中断（interrupt） cpu去干别的事，IO接口根据寄存器状态判断是否写入结束。结束后给cpu发送信号让cpu来取数据
中断并不是是指程序中断，只是一个提醒。类似于通知，比如处理器收到了软件或者硬件的提示该做某事了，这就是一个中断。
通常来说外围设备发送的是异步信号。
DMA接口 cpu和DMA（Direct Memory Access）总线直接链接，cpu告诉DMA接口需要把数据存在哪，DMA接口就会直接把数据写入主存（内存）
允许外设可以直接读写主存而不需要cpu干预。硬盘控制器，显卡，网卡，声卡等。
系统调用中的IO 系统调用（syscall）是一系列系统的函数，区别于用户自定义的函数(User)。系统调用通常是运行于内核态(Kernel)，更接近系统底层。系统调用可以直接访问硬件设备或者与内核交互，而用户程序是不可以的。用户想访问内核得先调用系统调用。
内存：brk，nmap，free。unmap等函数
文件：open，read.write,close
网络:select,poll,epoll.sendfile
linux中网络的IO模型 以下例子数据流向 网卡缓冲区&gt;内核缓冲区&gt;用户缓冲区
阻塞IO 一个syscall会变成阻塞状态，直到内核完成工作（比如成功把数据发送到用户缓冲区），这时才会解开阻塞。
一个线程只能有一个链接
非阻塞IO 在内核就绪前（比如已经把网卡缓冲区的数据拷贝到了内核区）可以一直发起syscall。当内核状态为就绪时启动阻塞。
一个线程可以多个链接，但是频繁的syscall很吃资源。
初步判断这么设计是可以让多个链接的请求放成一个队列，增加并发能力。
多路复用 在linux中，fd全称“File descriptor”，中文名为“文件描述符”，它是内核为了高效管理这些已经被打开的文件所创建的一种索引；它其实是一个非负整数，用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。
在windows中句柄和fd是一个意思，用来标记被系统打开的资源，
两者在形式上都是“唯一的整数”，是int类型
select/poll 当发起syscall时阻塞执行。当内核变为就绪态，其他syscall可以直接已经就绪的数据。此时阻塞与否都可以。然后内核继续工作。
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 调用后 select 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout 指定等待时间，如果立即返回设为 null 即可）， 函数返回。当 select 函数返回后，可以 通过遍历 fdset，来找到就绪的描述符。 优点：一次可以处理多个请求，返回批量数据。返回数据是用户自己遍历。这两者降低了syscall次数。
缺点：整个数据传递的过程是拷贝整个数组，开销特别大。同时该函数返回值只有个数，具体数据仍需read自己遍历读取。
epoll //创建epollFd，底层是在内核态分配一段区域，底层数据结构红黑树+双向链表 //size用来告诉内核这个监听的数目一共有多大 int epoll_create(int size)； //往红黑树中增加、删除、更新管理的fd int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； //用来阻塞等待就绪的fd，类似select调用 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 流程是create先创建epoll fd，在用ctl添加scoket fd 。打开 wait等待数据写入。当有异步IO变化时，wait返回有IO事件的FD。此时只返回有变动的FD。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc63aa01b5b39b0839a93b99fe094ed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783ec20746b7fc98863a725bb1b435a0/" rel="bookmark">
			mpc模型预测控制原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mpc模型预测控制原理详解 前言mpc算法步骤mpc算法推导 前言 本文是对mpc模型预测控制学习的记录，主要参照了DR_CAN老师的视频进行学习。视频专栏链接：DR_CAN老师mpc视频专栏。在这篇博客中博主也针对DR_CAN老师的讲解做了详尽的笔记和代码实现。读者可以相结合地进行学习。
mpc算法步骤 MPC算法主要包括以下三步：
估计/测量读取当前系统状态基于 u k , u k + 1 , . . . u k + N u_k,u_{k+1},...u_{k+N} uk​,uk+1​,...uk+N​来进行最优化；只取 u k u_k uk​。（Receding Horizon Control）滚动优化控制
为什么只取 u k u_k uk​那？这是因为如果系统一次预测太多的控制输入，当系统发生变化或者受到外部扰动的时候，接下来的k+1、k+2等时刻预测的未必准。只取 u k u_k uk​的滚动优化控制，可以避免这个问题。 mpc算法推导 考虑一个离散系统，其状态空间表达式为：
系统输出参考值 R = 0 R=0 R=0，误差为 E = y − R = x − 0 = x E=y-R=x-0=x E=y−R=x−0=x。
选取这样简单的系统有利于在推导时降低难度。
在k时刻时，我们令：
其中 u ( k + 1 ∣ k ) u(k+1|k) u(k+1∣k)表示在k时刻预测的k+1时刻的的系统输入u， u ( k + i ∣ k ) u(k+i|k) u(k+i∣k)表示的含义类似于 u ( k + 1 ∣ k ) u(k+1|k) u(k+1∣k)，N表示预测区间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783ec20746b7fc98863a725bb1b435a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac88765bf4f58c2be4f7177f91d2a2e/" rel="bookmark">
			快手上线知识产权保护平台；升级“磁力金牛”投流能力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、快手上线知识产权保护平台 10月14日，快手宣布正式上线知识产权保护平台，以提升权利人或品牌方的投诉维权体验，构建快手电商“信任”的心智和平台良好生态。
据悉，快手知识产权投诉平台受理商标权、著作权、专利权等知识产权维权投诉。无论是否是快手商家，只要是知识产权权利人及其利害关系人均可使用知识产权保护平台发起投诉。
用户可以在知识产权保护平台注册账户，登录知识产权保护平台并根据平台指引提交相应权利人的身份信息和知识产权权属信息发起维权投诉。
2、快手本地生活开启招聘，总岗位数超50个 近日，快手在其招聘官网上线了一批本地生活相关职位，涵盖工程、算法、运营、设计、分析、产品等多个类别，总岗位数超过50个。
其中涉及“大区拓运方向”的岗位同时在北京、杭州、成都、广州展开，正好对应的是快手北区、东区、西南区、南区这“四大战区”。
从招聘岗位来看，每个大区基本都包含渠道运营、区域运营、活动运营、商家运营、达人运营等岗位，涉及的职责包括招商、活动策划、市场拓展、策略制定等。
3、快手申请“116心意购物”商标 天眼查显示，9月30日，快手关联公司北京达佳互联信息技术有限公司申请注册2枚“快手116心意购物”商标，国际分类为广告销售、教育娱乐，当前商标状态均为申请中。
此前，快手已申请注册多个“快手 116”“快手116购物狂欢节”“快手116超值夜”等多个商标。
4、快手调整“消费者极致保障”规则，将于10月18日生效 10月11日，快手电商发布调整“消费者极致保障”的公告称，将调整《快手小店售后服务管理规则》、《快手小店商家客户服务管理规则》，并于2022年10月18日生效。
修订后的《快手小店售后服务管理规则》新增一项服务要求。若消费者购物过程中出现品质问题或服务违规等极端情况时，平台有权根据消费者历史交易及诚信情况，以及商品或商家历史数据，直接对该订单进行处置，处置包括仅退款及退货退款，退款赔付金从商家资金账户（货款/保证金）中扣除（本条规则仅适用子订单金额≤200元的订单）。
《快手小店商家客户服务管理规则》新增一条售后服务要求，若消费者购物过程中出现品质问题或服务违规等极端情况时，平台有权根据消费者历史交易及诚信情况，以及商品或商家历史数据，直接对该订单进行处置，处置包括仅退款及退货退款，退款赔付金从商家资金账户（货款/保证金）中扣除（本条规则仅适用子订单金额≤200元的订单）。
5、快手小店升级“磁力金牛”投流能力，提升商家投放体验 10月11日，快手磁力金牛官方宣布升级快手小店后台的投流能力，以提升商家的经营与投放体验。
具体来说，快手小店后台跟播助手、商品管理等模块内提供“插件式”投流能力，将投流与经营融合使得投流体验更加原生，缩短投流路径使得操作更加便捷，升级投放能力。具体包括以下功能：
1. 在小店后台直接闭环完成投流，无需多个平台跳转；
2. 覆盖电商经营活动全链路，从商品到短视频和直播；
3. 投流能力对齐磁力金牛移动端，满足多样化营销诉求；
4. 在不同经营场景提供不同投流能力，在商品管理、跟播等场景进行区分。
5、快手与Akamai联合落地QUIC协议，提升海外用户视频体验 10月11日，快手宣布与负责支持和保护数字化体验的解决方案提供商阿卡迈技术公司全面落地QUIC协议，提升海外用户视频体验，将QUIC使用率提升至平均90%的水平。
据介绍，QUIC协议是一个基于UDP的传输协议，因其高效的传输效率和多路并发的能力，已成为下一代互联网协议HTTP/3的底层传输协议。 6、快手理想家推出“小麦计划”，七省房产主播每月获超1亿流量扶持 近日，快手理想家正式发起“快手房产小麦计划”，该计划主要面向快手理想家尚未覆盖城市中的房产创作者。
据了解，“快手房产小麦计划”第一批试点地区为浙江、湖南、海南、福建、江西、安徽及贵州，粉丝数大于100且近30天在快手发过视频或开播的房产主播均可申请。除去工具升级等相关赋能外，参与到“小麦计划”的房产创作者们可获得每月超1亿流量资源扶持。
7、快手打击违规健康科普内容，共处置相关视频超26万条 10月7日，快手发布关于打击违规健康科普内容的处罚公告，数据显示，2022年9月，快手共处置相关视频26万余条。
公告称为营造积极、健康、正能量的社区环境，向用户传递科学严谨、真实可信的健康科普内容，快手持续打击涉及健康科普的违规内容，禁止不具备快手健康资质认证的帐号进行专业健康科普，禁止发布可能对用户产生不良影响的健康科普内容。
快手已通过技术手段与人工审查等方式对违规帐号进行核查，并根据违规情况对相关帐号做出了不限于限流、视频下架、视频不适宜公开等处罚。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad7fb6dd3f8ccc2c2ece2c75e30b9136/" rel="bookmark">
			【InputNumber】 计数器默认值改为空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-input-number v-model="num" :min="1" :max="10" label="描述文字"&gt;&lt;/el-input-number&gt;
当num设置为 null 或者 "" 都不能将输入框的值变为空，而是0
但是当有时候，我们的需求，需要它为空
&lt;template&gt; &lt;div class="content-el-array"&gt; &lt;el-input-number size="medium" v-model="data1.num1"&gt;&lt;/el-input-number&gt; &lt;el-input-number size="medium" v-model="data1.num2"&gt;&lt;/el-input-number&gt; &lt;el-input-number size="small" v-model="data1.num3"&gt;&lt;/el-input-number&gt; &lt;el-input-number size="mini" v-model="data1.num4"&gt;&lt;/el-input-number&gt; &lt;div&gt;加了其他属性也是一样 :min="1" :max="10" &lt;/div&gt; &lt;el-input-number size="medium" :min="1" :max="10" v-model="data1.num1"&gt;&lt;/el-input-number&gt; &lt;el-input-number size="medium" :min="1" :max="10" v-model="data1.num2"&gt;&lt;/el-input-number&gt; &lt;el-input-number size="small" :min="1" :max="10" v-model="data1.num3"&gt;&lt;/el-input-number&gt; &lt;el-input-number size="mini" :min="1" :max="10" v-model="data1.num4"&gt;&lt;/el-input-number&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { data1: { num1: 11, num2: 22, num3: 33, num4: 44, }, }; }, methods: {}, mounted() { //我们就看到第二个给了默认值'' this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad7fb6dd3f8ccc2c2ece2c75e30b9136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c95a33aff4149a4862d401f001bf317/" rel="bookmark">
			Python毕业设计基于django的就业系统项目（含源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Python毕业设计基于django的就业系统项目（含源码）
二、基于django的就业系统项目文件说明
一、Python毕业设计基于django的就业系统项目（含源码） 源 码 免 费 下 载 链 接：python毕设基于django就业系统源码.zip-Python文档类资源-CSDN下载
所需工具如下：
pycharmDjango第三方库后羿采集器爬虫python3.6 + Django2.2 + MySQL8.0 话不多说，直接看代码，有需要的点击上面链接即可免费下载了。
admin.py
from django.contrib import admin # Register your models here. from .models import comp from .models import stu,job # Register your models here. from import_export.admin import ImportExportModelAdmin from .resource import StuResource,JobResource class PersonAdmin(ImportExportModelAdmin): resource_class = StuResource list_display = ('name', 'stuid', 'stuclass', 'academy') # 列表显示字段 list_per_page = 10 # 每页显示数据数 # list_display_links = ('') #控制list_display中的字段哪些可以链接到修改页 # date_hierarchy = 'pub_date' #按日期月份筛选 list_filter = ['stuclass'] # 以字段过滤，也就是过滤器 search_fields = ['name'] # 添加搜索框进行模糊查询 list_editable = ['stuclass','stuid','academy'] # 添加可在列表页编辑的字段 ordering = ('-stuclass',) # 排序 admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c95a33aff4149a4862d401f001bf317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8158242c3cf19c089b26b17539d947c3/" rel="bookmark">
			# Puml 语法说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Puml 语法说明 文章目录 Puml 语法说明Idea 插件Puml 官网地址类图语法属性可见性元素声明类之间的关系 用例图对象图活动图部署图包图状态图时序图思维导图 Idea 插件 Idea安装 PlantUML diagramming、PlantUml Diagram Generator Puml 官网地址 友情链接：https://plantuml.com/zh/
类图语法 属性可见性 public 用+表示 private 用-表示 protected 用#表示 package 用~表示 元素声明 abstract 抽象 abstract class 抽象(等同abstract) annotation 注解 circle 圆 () 圆缩写形式 class 类 diamond 菱形 &lt;&gt; 菱形写形式 entity 实例 enum 枚举 interface 接口 类之间的关系 类型符号扩展`&lt;组成*--聚合o-- 关系代码 @startuml 'https://plantuml.com/class-diagram left to right direction '泛化和实现' abstract class AbstractList extends AbstractCollection implements List{ + add():boolean } abstract class AbstractCollection&lt;E&gt; implements Collection { + add():boolean } interface List&lt;E&gt; extends Collection { + add():boolean } interface Collection{ + add():boolean } '关联' class LoginForm { JButton loginButton; } class JButton { } LoginForm --&gt; JButton:关联 ClassOne -- ClassTwo:关联 '聚合' class Car { + Engine engine; + Car(Engine engine):void + setEngine(Engine engine):void } class Engine { } Car o--Engine:聚合 '组合' class Head { - Mouth mouth; + Head(); } class Mouth { } Head *--Mouth:拥有 '依赖' class Driver { + drive(Car car):void } class Car { + move():void } Driver .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8158242c3cf19c089b26b17539d947c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c80de495acd88cd5182533e61746c5/" rel="bookmark">
			脚本or工具类的知识的积累
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、用txt写脚本注意事项
自己喜欢在txt上写脚本，用notepad++编辑。需要注意的是，右下角。是unix格式。编码是UTF8。
上传到Linux之后，把后缀txt去掉，并且给脚本授权限。
2、Kafka脚本
#!/bin/bash if [ $# -lt 1 ] then echo "Usage: kf.sh {start|stop|kc [topic]|kp [topic] |list |delete [topic] |describe [topic]}" exit fi case $1 in start) for i in hadoop102 hadoop103 hadoop104 do echo "====================&gt; START $i KF &lt;====================" ssh $i kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties done ;; stop) for i in hadoop102 hadoop103 hadoop104 do echo "====================&gt; STOP $i KF &lt;====================" ssh $i kafka-server-stop.sh done ;; kc) if [ $2 ] then kafka-console-consumer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c80de495acd88cd5182533e61746c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303aba7438357019b21b9e775e98660b/" rel="bookmark">
			t-SNE可视化模型的特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不深究t-SNE的原理，直接调包“from sklearn.manifold import TSNE”完成可视化深度神经网络模型的特征。我这里只分两类上色，可以根据需要修改get_color函数，改color.append(colors[labels[i]])这样。
import numpy as np import matplotlib import matplotlib.pyplot as plt import pandas as pd from sklearn.manifold import TSNE import joblib import random matplotlib.use('Agg') #np.set_printoptions(threshold=np.inf) num1, num_sum = 150, 350#根据样本的实际情况自己改数值，Y的维度也就是len(标签)=num_sum num2 = num_sum - num1 def get_color(labels): colors=["#C05757","#3939EF"]#,"g","y","o"#根据情况自己改配色 color=[] for i in range(num1): color.append(colors[0]) for i in range(num2, num_sum): color.append(colors[1]) return color #class_out是需要t-SNE可视化的特征，可以来自模型任意一层，我这里用的是最后一层 #feats = np.array(class_out)#t-SNE可视化的特征输入必须是np.array格式 #print(feats.shape) #joblib.dump(feats, 'feat.pkl')#保存特征 X = joblib.load('feat.pkl')#读取预保存的特征信息 Y = [i for i in range(num_sum)] print(type(X))#必须是np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303aba7438357019b21b9e775e98660b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d804228b4390a76c59a666e0d675c4/" rel="bookmark">
			Vue中的路由守卫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.全局前置路由守卫
问题：如果要对很多路由切换时都需要做出判断，为了判断语句不显得代码很繁琐，应该怎么做？
2.全局后置路由守卫
3.独享路由守卫
4.组件内路由守卫
路由守卫：保护路由的安全(需要某种权限)
一般情况下，路由组件点击就可以跳转，但是现在有需求是，在某种条件达成时，路由组件才能进行跳转。
1.全局前置路由守卫 全局前置路由守卫: 初始化的时候被调用，每次 路由切换之前 被调用。
//全局路由守卫----初始化的时候被调用，每次路由切换之前被调用 router.beforeEach((to, from, next) =&gt; { if (to.name == 'Message' || to.name == 'News') { if (localStorage.getItem('school') === 'skyblue2') { next() }else{ alert('localStorage值不对'); } }else{ next() } }) 参数说明：
1. to: 要去到的路由
2.from：从哪个路由去
3.next :允许去否 允许就 next()
分析：在路由器里面配置路由规则时，一定要写name属性，方便路由守卫使用。
问题：如果要对很多路由切换时都需要做出判断，为了判断语句不显得代码很繁琐，应该怎么做？ if判断那里就显得很拥挤，所以我们可以在 路由配置项里面，设置一个值，来判断该路由是否需要鉴权。 可以在路由配置项的meta(路由元信息)里面，设置我们自定义的一些信息
授权News路由可以通过。
2.全局后置路由守卫 全局后置路由守卫---初始化的时候被调用，每次路由切换之后被调用。
//全局后置路由守卫----初始化时执行，每次路由切换后执行 router.afterEach((to,from)=&gt;{ //to:去到哪个路由组件 from:从哪个路由组件去 if(to.meta.title){ document.title = to.meta.title; //修改网页的title }else{ document.title = 'vue_project' } }) 注意点：要用的meta中title的话，需要提前在配置路由时，配置好meta。后置路由守卫可以用来在切换到某个路由组件后，修改对应页面的标题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d804228b4390a76c59a666e0d675c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54d2d15d5265d2ee9debb69229496b7/" rel="bookmark">
			flask解决WARNING: This is a development server. Do not use it in a production deployment.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 pycharm flask项目无法正常运行
报错如下：WARNING: This is a development server. Do not use it in a production deployment.
解决方法：更改启动服务器 使用WSGI.
我的python版本为python 3.7所以只能使用gevent包来启用WSGI
下载gevent包:在控制台输入：
pip install gevent 之后在代码中导入个gevent后调用，再run app就ok了
from gevent import pywsgi if __name__ == '__main__': server = pywsgi.WSGIServer(('0.0.0.0', 5000), app) server.serve_forever() 但在使用pip下载gevent时出现问题，在我将gevent包下载完成后，仍无法在项目中调用gevent包。解决方案是直接在编译器内导入gevent包
直接点加号 ，输入gevent 下载即可（pip版本不够，无法下载，可以先更新下pip版本）
其他包下载也可以使用这个方法，比控制台简单好用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb73cc3e1134a943e40ba509eaa6f872/" rel="bookmark">
			GitHub 邀请成员进行团队开发步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 登录GitHub 2 进入需要团队协作的项目 3 点击Settings 4 点击Collaborators，输入登录密码进行验证 5 点击 Add people 6 输入账户名或者邮箱名，并点击 7 将邀请函链接地址发送给邀请的人，等待对方确认即可 总结：对方接受邀请成为团队成员后，便可共同开发项目了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2267ef3abed777180358b1abc89c5c/" rel="bookmark">
			神经网络中的Dropout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络中的Dropout 在神经网络中，dropout层是一种减少过拟合的常用方法。
1. dropout解决了什么问题？ ​ 在深度神经网络中通常有各种不同的网络结构，有的是浅层的，有的是深层的网络结构。但是在努力追求从数据集中学习出不同的特征的同时神经网络也从数据集中学到了噪声。这就造成了网络在训练集上的性能好，但是在新的数据(测试集)上的性能不好，这种现象就是过拟合现象。为了解决过拟合问题，我们使用了各种正则化技术来惩罚网络的权重，但是这还不够。
​ 减少过拟合的最佳方法是从所有可能的参数设置中获得平均预测，并聚合最终输出。但是，这在计算上过于昂贵，对于实时推断/预测来说是不可行的。
​ 另一种方法是受到集成技术(如AdaBoost、XGBoost和Random Forest)的启发，我们使用不同体系结构的多个神经网络。但这需要对多个模型进行训练和存储，但是随着网络的深入，这将成为一个巨大的挑战。
​ 我们有一个很好地解决方案叫做dropout 层。
2. dropout是什么？ ​ 如图1所示，在神经网络中，dropout指的是以概率p随机删除输入层和隐藏层中的部分节点，与已删除节点的所有向前和向后连接都将被临时删除，从而创建一个新的网络体系结构。每个节点被丢弃的概率为p。
​ 举个例子：给定一个输入 x : { 1 , 2 , 3 , 4 , 5 } x:\{1,2,3,4,5\} x:{1,2,3,4,5}， 将x输入一个全连接网络。我们设定dropout层的概率p=0.2(节点留下的概率是0.8)。在网络训练阶段，在输入x开始的正向传播过程中，20%的节点将会被丢弃，比如x可能会变成 x : { 1 , 0 , 3 , 4 , 5 } x:\{1,0,3,4,5\} x:{1,0,3,4,5}或者 x : { 1 , 2 , 3 , 0 , 5 } x:\{1,2,3,0,5\} x:{1,2,3,0,5}等等。
​ 在隐藏层中也是如此，比如，隐藏层中有1000个神经元节点，dropout设置为0.5，那么在每次迭代(batch)过程中，隐藏层中会随机丢弃500个神经元。
3. dropout如何解决过拟合问题？ ​ 在过拟合问题中，网络学习到了噪声。网络训练的主要动机是在给定所有单元(神经元)的情况下，减少损失函数。所以在过拟合中，一个单位的改变可能会弥补其他单位的错误。这导致了复杂的共适应，进而导致过拟合问题，这种复杂的共适应无法在未见的数据集上推广。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2267ef3abed777180358b1abc89c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43adba3bfa41a085c4f91b5fefd97a1/" rel="bookmark">
			实验5继承和派生（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分别定义Teacher(教师)类和Cadre（干部）类，采用多重继承方式由这两个类派生出新类Teacher_ Cadre（教师兼干部）。要求：
在两个基类中都包含姓名、年龄、性别、地址、电话等数据成员。
在Teacher类中还包含数据成员title（职称），在Cadre类中还包含数据成员post（职务），在Teacher_ Cadre类中还包含数据成员wages(工资)。
对两个基类中的姓名、年龄、性别、地址、电话等数据成员用相同的名字，在引用这些数据成员时，指定作用域。
在类体中声明成员函数，在类外定义成员函数。
在派生类Teacher_ Cadre的成员函数show中调用Teacher类中的display函数，输出姓名、年龄、性别、职称、电话，然后再用cout语句输出职务和工资。
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; class Teacher { protected: string TC_name = "富强"; int TC_age = 10; string TC_sex = "民主"; string TC_address = "文明"; string TC_tel = "和谐"; string Te_title = "自由"; public: void Te_display(); }; void Teacher::Te_display() { cout &lt;&lt; "姓名：" &lt;&lt; TC_name &lt;&lt; endl; cout &lt;&lt; "年龄：" &lt;&lt; TC_age &lt;&lt; endl; cout &lt;&lt; "性别：" &lt;&lt; TC_sex &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43adba3bfa41a085c4f91b5fefd97a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef553e6cbff8bfcf0b38739ec461d1c/" rel="bookmark">
			OpenCascade源码分析之BRepMesh_IncrementalMesh(网格离散化操作)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCascade源码分析之BRepMesh_IncrementalMesh(网格离散化操作) 一、引言 在使用opencascade读取连续曲面模型的时候，一般来说我们都会调用BRepMesh_IncrementalMesh对其进行离散化，然而可能对于离散过程的执行还是没有什么概念，接下来从源码出发来看看它进行了什么操作。
二、源码分析 在调用离散的时候，我们一般会用到下面的代码
TopoDS_Shape cur;	//需要离散的拓扑 IMeshTools_Parameters aMeshParams;	//离散化的参数 BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh(cur, this-&gt;aMeshParams); BRepMesh_IncrementalMesh.cpp 的代码为
//======================================================================= //function : Constructor //purpose : //======================================================================= BRepMesh_IncrementalMesh::BRepMesh_IncrementalMesh( const TopoDS_Shape&amp; theShape, const IMeshTools_Parameters&amp; theParameters, const Message_ProgressRange&amp; theRange) : myParameters(theParameters) { myShape = theShape; Perform(theRange); } //======================================================================= //function : Perform //purpose : //======================================================================= void BRepMesh_IncrementalMesh::Perform(const Message_ProgressRange&amp; theRange) { //新建一个上下文 //myParameters.MeshAlgo返回了参数中的IMeshTools_MeshAlgoType //如果没有设置IMeshTools_MeshAlgoType默认为Delaunay三角化Watson方法 //也可以设置为Delabella方法 Handle(BRepMesh_Context) aContext = new BRepMesh_Context (myParameters.MeshAlgo); //theRange消息进度条，没什么用 不用管 Perform (aContext, theRange); } //======================================================================= //function : Perform //purpose : //======================================================================= void BRepMesh_IncrementalMesh::Perform(const Handle(IMeshTools_Context)&amp; theContext, const Message_ProgressRange&amp; theRange) { //对于我们自己设置的离散参数进行判断，修改一些不合理的值 //例如当Deflection&lt;Precision::Confusion()时，提醒用户值无效 精度太低 initParameters(); //IMeshTools_Context继承至IMeshData_Shape //IMeshData_Shape中的SetShape()设置了成员变量TopoDS_Shape myShape theContext-&gt;SetShape(Shape()); //设置离散参数 theContext-&gt;ChangeParameters() = myParameters; // 算法结束时不清理临时的数据类型 theContext-&gt;ChangeParameters().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef553e6cbff8bfcf0b38739ec461d1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09956d212646a84e279677d9bb6026ee/" rel="bookmark">
			Pytorch实现Warm up&#43;余弦退火，亲测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch实现Warm up + 余弦退火 1.Warm up 由于刚开始训练时,模型的权重(weights)是随机初始化的，此时若选择一个较大的学习率,可能带来模型的不稳定(振荡)，选择Warmup预热学习率的方式，可以使得开始训练的几个epoches或者一些steps内学习率较小,在预热的小学习率下，模型可以慢慢趋于稳定,等模型相对稳定后再选择预先设置的学习率进行训练,使得模型收敛速度变得更快，模型效果更佳。
2.余弦退火 当我们使用梯度下降算法来优化目标函数的时候，当越来越接近Loss值的全局最小值时，学习率应该变得更小来使得模型尽可能接近这一点，而余弦退火（Cosine annealing）可以通过余弦函数来降低学习率。余弦函数中随着x的增加余弦值首先缓慢下降，然后加速下降，再次缓慢下降。这种下降模式能和学习率配合，以一种十分有效的计算方式来产生很好的效果。
3.代码（每个batch学习率更新一次） import matplotlib.pyplot as plt import math import torch from torchvision.models import resnet50 from math import cos, pi def adjust_learning_rate(optimizer, current_epoch, max_epoch, lr_min=0, lr_max=0.1, warmup=True): warmup_epoch = 10 if warmup else 0 if current_epoch &lt; warmup_epoch: lr = lr_max * current_epoch / warmup_epoch elif current_epoch &lt; max_epoch: lr = lr_min + (lr_max - lr_min) * ( 1 + cos(pi * (current_epoch - warmup_epoch) / (max_epoch - warmup_epoch))) / 2 else: lr = lr_min + (lr_max - lr_min) * ( 1 + cos(pi * (current_epoch-max_epoch) / (max_epoch))) / 2 for param_group in optimizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09956d212646a84e279677d9bb6026ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1364b7e8ccafe4fa27dc8a9cf9cfab84/" rel="bookmark">
			微信小程序开发实战9_2 小程序页面转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序页面转发是小程序分享的一个重要方式，在设计小程序应用时就需要考虑那些页面需要实现转发功能，以及页面的转发参数。本节介绍如何进行小程序页面的分享，并介绍如何获取小程序卡片的分享票据。
9.2.1小程序页面转发 微信小程序提供了页面的转发的功能，用户在在打开小程序的页面时，可把该页面以消息卡片的形式转发给其他用户或微信群。微信小程序转发功能的实现方法有两种：
第一种方式
第一种方式是在page.js中实现onShareAppMessage，便可在小程序右上角显示分享菜单： onShareAppMessage: function () { return { title: '分享标题', desc: '分享页面的内容', path: '/pages/share_recv?code=123' } } 第二种方式
如果觉得小程序原生的转发用户体验不够友好，可以在页面自定义转发按钮，通过给 button 组件设置属性 open-type=“share”，可以在用户点击按钮后触发Page.onShareAppMessage事件，实现分享功能。 &lt;view style="padding:5px"&gt; &lt;button open-type='share'&gt;分享&lt;/button&gt; &lt;/view&gt; 获取分享传递的参数
上面的例子中，path属性指向的是/pages/share_recv页面，并附带code=123的参数。我们只需在share_recv.js的onLoad函数中，通过options获取传递过来的参数： Page({ onLoad: function (options) { console.log(options); } }) 9.2.2小程序分享票据 小程序分享票据shareTickets
通常开发者希望转发出去的小程序被二次打开的时候能够获取到一些信息，例如群的标识。在小程序中调用wx.showShareMenu并且设置 withShareTicket为true，当用户将小程序转发到微信群之后，此转发卡片在群聊中被其他用户打开时，可以在App.onLaunch 或App.onShow获取到一个shareTicket。通过调用wx.getShareInfo(shareTicket) 接口可以获取到转发信息。
分享前调用wx.showShareMenu方法，否则不会带有分享票据： Page({ onLoad: function (options) { wx.showShareMenu({ withShareTicket: true }) }, onShareAppMessage: function () { return { title: '分享标题', desc: '分享页面的内容', path: '/pages/share_recv?code=123' } } }) 小程序获取票据shareTickets
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1364b7e8ccafe4fa27dc8a9cf9cfab84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08465f4f7859569f7d244a2b8228d3cc/" rel="bookmark">
			【Windows Server 2019】网络负载均衡服务配置与管理——理论&#43;网络拓扑及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 负载均衡的基本概念1.1 负载均衡的定义（1）一个没有负载均衡的Web服务架构（2）加入负载均衡器的Web服务架构 1.2、负载均衡的工作原理1.3、负载均衡三要素（1）分发策略（2）会话保持（3）服务器健康检查 2. Windows Server Network Load Balancing（网络负载均衡）2.1 特性（1）高可用性（2）可扩展性（3）可管理性 2.2 部署NLB服务群集的要求（1）硬件要求（2）软件要求 3. 网络拓扑及说明参考资料关联博文 1. 负载均衡的基本概念 1.1 负载均衡的定义 Load balancing，将网络请求或其他形式的负载“均摊”到不同的计算机上，达到最优化资源使用、最大化吞吐率、最小化响应时间和避免过载的目的。配置服务器负载均衡可以避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。负载均衡可分为软件负载均衡和硬件负载均衡。
示例：
（1）一个没有负载均衡的Web服务架构 问题：如果大量用户同时访问该Web服务器，或遭受DOS/DDOS攻击，该服务器可能出现宕机情况，这时候普通用户将无法正常访问，服务中断，可能造成大量损失。
（2）加入负载均衡器的Web服务架构 在服务器集群中加入负载均衡器后，负载均衡器可根据负载均衡算法将用户请求转发到服务器集群中空闲的服务器中。（具体请查阅1.2小节）负载均衡器可以是软件也可以是硬件。
1.2、负载均衡的工作原理 负载均衡器通过更改请求的目的地址对请求进行转发，在服务器返回数据包的时候，更改返回数据包的源地址，保证客户端请求的目的和返回包是同一个地址。
具体示例
某游戏运营商申请到一个公网IP1.1.1.1，玩家的用户登录验证需要连接这个地址，玩家请求数据包会先通过防火墙，达到负载均衡器。负载均衡器根据其内置算法决定玩家将连接哪一台服务器进行登录验证，这里假设负载均衡器将该玩家分配给Web服务器1。接着负载均衡器将用户请求数据包中的目的地址换成对应的Web服务器1的IP地址，Web服务器的IP地址可能是内网IP地址（例如192.168.82.223），玩家的请求数据包会到达Web服务器1上进行验证。
内置算法即决定服务器集群中哪台服务器可以处理用户请求。例如，有A、B、C三台服务器，服务器A使用率已经达到60%，服务器B和服务器C使用率均为0%，且正常运行时，负载均衡器中的内置算法将用户请求转发到服务器B或服务器C中，具体需要查看B和C哪台服务器的优先级更高。
当验证成功后，Web服务器1会发送一个响应数据包返回给负载均衡器，负载均衡器会将收到数据包中的源地址由192.168.82.223改为1.1.1.1，再把响应数据包发送给玩家。
这样就保证了用户的请求目的地址和响应数据包的源地址是同一个地址。
1.3、负载均衡三要素 包括分发策略、会话保持和服务器健康检查。
（1）分发策略 指负载均衡设备，根据什么样的策略（即算法）把请求分发到不同的后台服务器上，最简单的算法是轮巡，把用户请求依次分配到服务器上。
（2）会话保持 在大部分的应用中都会涉及到服务器 Session控制。而且这些Session通常不会在服务器之间进行复制的。即用户A在登录时负载均衡器将其分配到服务器1处理，那么以后所有关于用户A的所有请求都将会转发到服务器1中，而不会转发到其他服务器上。如果分配到其他服务器上，其他服务器上没有关于A的记录，会导致请求失败。
最简单的会话保持策略是源地址会话保持。
（3）服务器健康检查 指负载均衡设备必须检测后台服务器是否在正常工作，如果有某台服务器出现故障，无法正常工作，那么负载均衡器会把这台服务器从负载均衡组中剔除。当故障服务器恢复时，再把该服务器重新加载到负载均衡组中。
2. Windows Server Network Load Balancing（网络负载均衡） NLB增强了Internet服务器应用程序的可用性和可伸缩性，例如在Web，FTP，防火墙，代理，虚拟专用网（VPN）和其他关键任务服务器上使用网络负载平衡服务。
网络负载平衡(NLB)特性是通过使用TCP/IP协议在多个服务器之间分配流量。通过将运行应用程序的两台或多台服务器合并到一个虚拟集群中，NLB为web服务器和其他关键任务服务器提供了可靠性和性能。
NLB集群中的服务器称为主机，每个主机都运行着相同服务的单独副本。NLB会将客户端的请求转发到集群中的各个主机上。系统管理员可以配置由每个主机处理客户端请求。还可以动态地向集群添加主机来处理增加的负载。NLB还可以将所有流量定向到指定的主机中，该主机称为默认主机。
NLB允许群集中的所有服务器使用相同的IP地址集进行寻址，并且为每个主机维护一组唯一的专用IP地址。对于负载平衡的应用程序，当主机发生故障或脱机时，负载会自动在正常工作的服务器之间重新分配。准备就绪后，脱机的服务器可以透明地重新加入群集并重新获得其工作负荷的份额，这使群集中的其他计算机可以处理较少的流量。
2.1 特性 Windows Server 的网络负载均衡有三个重要特性，包括高可用性、可扩展性和可管理性。
（1）高可用性 高可用性系统可靠地提供了可接受的服务水平，并且停机时间最少。为了提供高可用性，NLB包括内置功能，这些功能可以自动：
检测发生故障或脱机的群集主机，然后进行恢复。添加或删除主机时，平衡网络负载。在10秒之内恢复并重新分配工作负载。 （2）可扩展性 可伸缩性是衡量计算机，服务或应用程序在满足不断增长的性能要求的能力的度量。对于NLB群集，可伸缩性是当群集的整体负载超过其能力时，可以向现有群集中增量添加一个或多个系统的能力。为了支持可伸缩性，系统管理员可以对NLB执行以下操作：
平衡NLB群集中各个TCP / IP服务的负载请求。单个群集中最多支持32台服务器。在群集中的多个主机之间平衡多个服务负载请求（来自同一客户端或来自多个客户端）。随着负载增加，将主机添加到NLB群集中，而不会导致群集发生故障。当负载降低时，可以从群集中删除主机。通过完整的流水线实施实现高性能和低开销。流水线化允许将请求发送到NLB群集，而无需等待对先前请求的响应。 （3）可管理性 为了支持可管理性，系统管理员可以对NLB执行以下操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08465f4f7859569f7d244a2b8228d3cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/992d708085c3da8e4c33affe6dd610a6/" rel="bookmark">
			python学习1.1--将数据集写入csv文档中，从csv文档读取数据集，数据值缺失处理，转换为张量格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅仅是个人学习笔记，以及记录学习过程中出现的一些问题。
学习参考书网站
deep learning在线学习文档
文章目录 将数据集写入csv文档中读取数据集处理缺失值转换为张量格式 将数据集写入csv文档中 首先我们需要手动写一些数据到csv文件中，文档中使用以下代码。
os库是对文件或者文件夹进行操作的一个工具os.makedirs()函数，递归目录创建函数，和os.mkdir()很像，但是os.mkdir()只创建最后一层的目录。而对于os.makedirs()来说，如果路径中哪一层不存在，则自动创建。os.makedirs：的exist_ok参数设置为True时，可以自动判断当文件夹已经存在就不创建（我感觉这个超方便） import os os.makedirs(os.path.join('..', 'data'), exist_ok=True) data_file = os.path.join('..', 'data', 'house_tiny.csv') with open(data_file, 'w') as f: f.write('NumRooms,Alley,Price\n') # 列名 f.write('NA,Pave,127500\n') # 每行表示一个数据样本 f.write('2,NA,106000\n') f.write('4,NA,178100\n') f.write('NA,NA,140000\n') 但是运行之后在我的电脑上会报以下错误
解决办法是将以下2句修改一下，参考文章：报错： [WinError 5] 拒绝访问。: ‘…\data‘
os.makedirs(os.path.join('\\', 'data'), exist_ok=True) data_file = os.path.join('\\', 'data', 'house_tiny.csv') 此时，创建成功后，在电脑C盘的data文件夹中会出现一个house_tiny.csv的文件夹。
读取数据集 导入pandas包并调用read_csv函数，由上一问可知，这个数据集有4行3列，
如果没有安装pandas，可以使用下行来安装pandas
!pip install pandas
import pandas as pd data = pd.read_csv(data_file) print(data) 运行可以得到以下结果
处理缺失值 上图中的NAN即为缺失值，我们需要将缺失值补起来。对于NumRooms列，缺失值就可以用该列的平均值来代替。
通过位置索引 iloc，我们将data分成inputs和outputs， 其中前者为data的前两列，而后者为data的最后一列。data.iloc[ A:B ,C:D ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/992d708085c3da8e4c33affe6dd610a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36b789ca85faa04a5be3fe7bea82276/" rel="bookmark">
			算法——查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 基本概念和评价1. 相关概念2. 查找表2.1 常见操作2.2 分类 3. 查找算法的评价指标 二. 线性结构查找1. 顺序查找算法1.1 定义1.2 算法思想1.3 特点1.4 分类1）无哨兵的无序线性表的顺序查找2）有哨兵的无序线性表的顺序查找3）对有序表进行顺序查找4）各关键字被查概率不同 1.5 查找判定树1.6 查找效率分析（ASL） 2. 折半查找算法2.1 算法思想2.2 算法实现2.3 查找判定树1）定义2）构造3）特性 2.4 查找效率分析（ASL） 三. 树形结构查找1. 二叉排序树（二叉查找树/BST）1.1 相关概念1.2 基本操作1）查找操作2）插入操作3）构造二叉排序树、4）删除操作 1.3 查找效率分析（ASL）1）查找成功2）查找失败3）二叉排序树与二分查找的比较 2. 二叉平衡树（AVL）2.1 相关概念1）为什么需要平衡二叉树2）定义 2.2 基本操作1）插入2）调整最小不平衡子树 2.3 查找效率分析（ASL） 3. B树（多路平衡查找树）3.1 基本概念1）来源2）如何保证查找效率4）B树定义5）m阶B树的核心特性 3.2 B树的高度3.3 B树的基本操作1）B树的查找2）B树的插入3）B树的删除 4. B+树4.1 基本概念4.2 基本操作1）B+树的查找 4.3 B树和B+树的区别 5. 红黑树 四. 索引结构查找1. 分块查找（索引顺序查找）算法1.1 算法思想1）用折半查找查索引2）用顺序查找查索引 1.2 查找效率分析（ASL） 五. 散列结构（哈希结构）查找1. 基本概念2. 哈希函数 (散列函数) 的构造方法2.1 概述2.2 常见的散列函数1）除留余数法2）直接定址法3）数字分析法4）平方取中法 3. 处理冲突的方法3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36b789ca85faa04a5be3fe7bea82276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3444210ddde71d597ac4fe5b8b24beb5/" rel="bookmark">
			git windows 免密操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果已经在linux服务器上生成了密钥对（rd_rsa，id_rsa.pub），也可以跳过前第三部，将服务器上的密钥对复制到PC端，然后执行5，6，7；
Linux服务器上查看密钥对指令：
cd ~/.ssh
ls 2.在pc端安装git后，直接在桌面上点击鼠标右键，弹出菜单，选择Git Bush here，打开Git bush，类似于pc端的cmd命令窗口；
3.输入指令：cd ~/.ssh //查看密钥是否存在，如果不存在，创建一个；
4.注册邮箱：
git config –global user.name “name”（引号里写自己的用户名）；回车
git config –global user.name “name@xiongmaitech.com”（填写邮箱）；回车
ssh-keygen –t rsa –C “name@xiongmaitech.com”(输入注册的邮箱)；回车
提示输入密钥目录，不用管，回车（默认放到C:\Users\Administrator.ssh）；
输入密码：123456 回车
输入密码：123456 回车
完成以上操作后，会在路径：C:\Users\Administrator.ssh，下生成两个文件：rd_rsa id_rsa.pub;
5.制作rd_rsa.ppk文件：
Win-&gt;所有程序（启动）-&gt;Tortoisegit-&gt;PuTTYgen
打开软件后，选择最上面：Conversions-&gt;Importkey
进入密钥生成路径：C:\Users\Administrator.ssh，选择私钥：rd_rsa，打开，输入之前设置的密码：123456，点击Save private key按钮，在提示框中，将生成文件命名为：rd_rsa.ppk，点击OK；
6.将密钥加入pc端git环境：
Win-&gt;所有程序（启动）-&gt;Tortoisegit-&gt;Pageant
打开软件后，点击Add Key，选择第5步生成的ppk文件，加入即可
7.如果执行了234步骤，需要将生成的秘钥加入git服务器，在pc端安装git后，直接在桌面上点击鼠标右键，弹出菜单，选择Git Bush here，打开Git bush，类似于pc端的cmd命令窗口；
输入命令：cat ~/.ssh/id_rsa.pub
选择显示的全部字符串，复制到剪切板，
网页登录GitLab服务器，选择 Profile Settings -&gt; SSH Keys，将复制的字符串粘贴到Key区域，Title可随意填写，点击 Add key即可
8.将Pageant加入设备自启动功能：
一、Pageant开机启动
首先打开win7的自启动文件夹,方式 win键-&gt;所有程序-&gt;启动-&gt;右键-&gt;打开 ,
WINDOWS 10的看这里：
在打开此电脑窗口的地址栏中输入：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3444210ddde71d597ac4fe5b8b24beb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b21e10f634f161958ec71c78e592bd0/" rel="bookmark">
			GRU时间序列数据分类预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：通过一段时间的数据，预测后面一段时间的类别，比如输入数据是1-50步的变量，预测的是50-60步的类别。
输入变量的数目：15
预测的类别数：0,1,2,3,4,10 （1类数目最多，数据不均衡）
GRU模型参数解释： 参考链接：[Pytorch系列-54]：循环神经网络 - torch.nn.GRU（）参数详解_文火冰糖的硅基工坊的博客-CSDN博客_nn.gru参数
input_size: 输入序列的变量的数目。
hidden_size: 隐藏层的特征的数目。
num_layers: GRU层的数目。
bias：是否需要偏置，默认是True（需要）。
batch_first: 用于确定batch size是否需要放到输入输出数据形状的最前面。
若为True， 则输入、输出的tensor的格式为(batch， seq_len， feature)
若为False，则输入、输出的tensor的格式为(seq_len，batch，feature)
默认是False。
为什么需要该参数呢？
在CNN网络和全连接网络，batch通常位于输入数据形状的最前面。
而对于具有时间信息的序列化数据，通常需要把seq放在最前面，需要把序列数据串行地输入网络中。（那我的模型不能设置为True？？？）
seq_len: 输入序列的长度。在我的情形下可以为50。
搭建GRU网络： 参考链接：pytorch使用torch.nn.Sequential快速搭建神经网络 - pytorch中文网
self.gru = nn.GRU(self.input_size, self.hidden_size, self.num_layers, batch_first=True, dropout=self.dropout) self.fc = nn.Sequential(nn.Linear(self.hidden_size, self.output_size), nn.Sigmoid()) self.gru = torch.nn.GRU(self.input_size, self.hidden_size, self.num_layers, batch_first=True) self.fc1 = torch.nn.Linear(self.hidden_size, 4) self.fc2 = torch.nn.Linear(self.hidden_size, 4) self.fc3 = torch.nn.Linear(self.hidden_size, 4) self.fc4 = torch.nn.Linear(self.hidden_size, 4) self.fc5 = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b21e10f634f161958ec71c78e592bd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea56c692dba9a3fac60046c39e43d9a/" rel="bookmark">
			SpringBoot配置多个DataSource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot配置多个DataSource application.properties spring.datasource.db1.driver-class-name= spring.datasource.db1.jdbc-url= spring.datasource.db1.username= spring.datasource.db1.password= spring.datasource.db2.driver-class-name= spring.datasource.db2.jdbc-url= spring.datasource.db2.username= spring.datasource.db2.password= DataSourceConfig DB1配置 @Configuration @MapperScan(basePackages = "com.example.mapper.db1", sqlSessionFactoryRef = "MySQLSqlSessionFactory") public class MySQLDataSourceConfig { @Bean(name = "MySQLDataSource") @Primary @ConfigurationProperties(prefix = "spring.datasource.db1") public DataSource getDateSource1() { return DataSourceBuilder.create().build(); } @Bean(name = "MySQLSqlSessionFactory") @Primary public SqlSessionFactory test1SqlSessionFactory( @Qualifier("MySQLDataSource") DataSource datasource) throws Exception { MybatisSqlSessionFactoryBean bean = new MybatisSqlSessionFactoryBean (); bean.setDataSource(datasource); // 设置mybatis的xml所在位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath*:mapper/db1/*.xml")); return bean.getObject(); } @Bean public PlatformTransactionManager transactionManager(@Qualifier("MySQLDataSource")DataSource dataSource) { return new DataSourceTransactionManager(dataSource); } @Bean("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea56c692dba9a3fac60046c39e43d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fc1490250ae02431ca1506723ce9605/" rel="bookmark">
			Rabbitmq 核心知识、集群部署、springboot集成MQ集群实现高可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQ核心知识如下： 1、MQ的基本使用（hello world ，pubsub ， topic ， header ， direct ， rpc ），可以先去官网或者相关平台学习如何使用，这里跳过； 2、topic 和 header 方式的区别 可以说topic 包含 header ， 所以header 粒度更小， 粒度小代表更灵活 ； 所以当业务是灵活多变的就用header， 如果没啥特殊要求，就直接用topic；
3、RabbitMQ死信队列 所谓“死信”， 从文字角度理解就是“消息死了，无声了”；rabbitmq作为一个消息中间件，什么情况下存在“需要消息死了，无声了”的场景；----- 消息延时，延时队列；说的没错，比如若有需求说，若订单一只未付款延时15分钟将订单自动取消、微信定时回复、钉钉定时日志等等都可以用延时队列。
消息被塞入到死信队列有2种方式：
消费者拒绝消费或者NACK的方式驳回消息、超时未消费队列消息(包括发送消息时设置生存时间 / 队列消息生存时间)生产者生产的消息大于队列设置的最大长度，或者消息载体大于设置的最大长度 上述情况消息不会回到原队列，而是进入到死信队列。
死信队列实现方式：
1）、首先定义死信队列的交换机 exchange 和队列 Queue ， 然后再将其与正常的交换机绑定；
@Configuration public class DeadLetterConfig { public static final String NORMAL_EXCHANGE = "normal-exchange" ; public static final String NORMAL_QUEUE = "normal-queue"; public static final String NORMAL_ROUTING_KEY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fc1490250ae02431ca1506723ce9605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608c3cbc1105947d616ea8640ce40599/" rel="bookmark">
			DQN算法实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from pydoc import render_doc import torch import torch.nn as nn import torch.nn.functional as F #激励函数都在这RelU等 import numpy as np import gym # Hyper Parameters BATCH_SIZE = 32 LR = 0.01 # learning rate EPSILON = 0.9 # greedy policy GAMMA = 0.9 # reward discount TARGET_REPLACE_ITER = 100 # target update frequency MEMORY_CAPACITY = 2000 env = gym.make('CartPole-v1',render_mode = "human") env = env.unwrapped N_ACTIONS = env.action_space.n N_STATES = env.observation_space.shape[0] ENV_A_SHAPE = 0 if isinstance(env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608c3cbc1105947d616ea8640ce40599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113e7c065bee3a9e57daa24be4fb83a3/" rel="bookmark">
			13. 罗马数字转整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值
I 1
V 5
X 10
L 50
C 100
D 500
M 1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113e7c065bee3a9e57daa24be4fb83a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b7ee76e52b5b24501abc43fb183b25/" rel="bookmark">
			pom.xml存在依赖标红
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6243bec71fbad8c5c7e815aad1f8830c/" rel="bookmark">
			通过Shell脚本检查进程是否存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 需要一个shell 脚本检测一下进程是否存在，如果存在则直接kill 掉
问题处理 查看进程id
ps -ef|grep node_exporter|grep -v grep|awk '{print $2}' 如果应用进程是存在的且只有一个进程，在脚本中打印会发现有三个进程id,其中有两个进程是用不到的，且多出来的两个进程id和当前脚本子进程相关,为什么会有两个无关的进程id呢？理论上来讲主机上只有这一个关键词的进程，排查发现是因为定义的脚本名称包含了node_exporter所导致。
知识点补充 shell脚本在执行时，会启动子shell的进程。作为主shell的子进程，子shell将shell脚本中的命令作为批处理运行（因此称为“批处理进程”）。
在bash中，子shell进程的PID存储在一个特殊的变量‘$$’中。这个变量只读，你不可以在脚本中修改它。
除了$$, bash shell还会导出其他的只读变量。比如，PPID存储子shell父进程的ID（也就是主shell）。UID存储了执行这个脚本的当前用户ID
echo $PPID echo UID 解决方法 优化获取进程id方式
ps -ef|grep node_exporter|grep -v grep|grep -v $$|awk '{print $2}' 这样获得的进程就会过滤掉当前脚本的进程，问题处理
脚本伪代码供参考
# 检查 node_exporter 进程是否存在，存在则直接kill 掉 check_node_exporter_status(){ echo "check node exporter status start " node_exporer_proc=`ps -ef|grep node_exporter|grep -v grep|grep -v $$|awk '{print $2}'` if [[ $node_exporer_proc != "" ]]; then echo "node_exporter process id is $node_exporer_proc"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6243bec71fbad8c5c7e815aad1f8830c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d460b628c1207eb1936ab679c27bc425/" rel="bookmark">
			安装Anaconda，pytorch下载，验证是否安装成功案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【参考文章：【Anaconda教程01】怎么安装Anaconda3 - 知乎】
下载Anaconda
推荐清华镜像Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
点击下面链接可直接下载Anaconda3-5.2.0安装包。【装anaconda，就不需要单独装python了】anaconda包含了python中的许多科学计算类的库
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Windows-x86_64.exe
安装步骤：
1.下载安装包——【Next】-【All ueser】-【可直接默认安装路径C:\ProgramData】-
【第二项 是说要默认使用python的版本，选上！！】-【Next】直至安装进度条走完，最后两个方框不勾选【Finish】
2.检查控制面板是否有添加【Path】
3.安装pytorch【pip版本】
打开cmd，运行conda create -n py python==3.8（创建一个名字是py的环境），接着运行activate py（激活环境），再运行pip3 install torch torchvision torchaudio -f https://download.pytorch.org/whl/torch_stable.html -i https://pypi.tuna.tsinghua.edu.cn/simple；等等安装-出现Proceed([y]/n？)【输入:y】-【等待安装，不要关闭cmd】
验证是否安装成功：
输入【python】敲回车--再输入下面代码。出现黄色框代码表示pytorch安装成功。
import torch import torchvision a=torch,rand(1,2) a=a.cuda() print(a) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15874528ca0d51dbf38a5c6423fc91e2/" rel="bookmark">
			SpringBoot整合ssh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：测试环境连接生产环境的数据库，无法本地调试 环境：
JDK8 Maven:3.6.3 Springboot:2.1.4 jsch:0.1.55 Jsch百度百科介绍：JSch 是SSH2的一个纯Java实现。它允许你连接到一个sshd 服务器，使用端口转发，X11转发，文件传输等等。
Jsch Maven依赖包：
&lt;!-- https://mvnrepository.com/artifact/com.jcraft/jsch --&gt; &lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; 连接配置工具类：
import com.jcraft.jsch.JSch; import com.jcraft.jsch.Session; import java.util.Properties; /** * @author dcf * @date 2022-09-23 17:51 **/ public class SshConnectionTool { //ssh连接的用户名 private final static String SSH_USER = “XXX"; //ssh连接的密码 private final static String SSH_PASSWORD = “****"; //ssh远程连接的ip地址 private final static String SSH_REMOTE_SERVER = “XXX.XXX.XXX.XXX"; //ssh连接的端口号 private final static int SSH_REMOTE_PORT = 22; //本地mysql发起连接的数据库IP地址 private final static String MYSQL_REMOTE_SERVER = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15874528ca0d51dbf38a5c6423fc91e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f24ed20c99316ab0000179002cbecb/" rel="bookmark">
			element table 拖动改变列宽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果如图：
实现的代码：
添加一个border
&lt;el-table border :data="tableData" style="width: 100%"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b51d0980a82b7fc30144dae729051f2/" rel="bookmark">
			阿里云服务器上rabbitMQ报错；解决方案Error: unable to connect to node rabbit@localhost: nodedown
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因是安全组没设置好，端口没开放，检查一下15672,5672，mq集群通信端口是否都打开，建议直接暴力设置全部端口开放
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f19e8605abd830e6096a9a565c4873b/" rel="bookmark">
			大数据毕业设计 - 选题推荐（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 开题指导1.1 起因1.2 如何避坑(重中之重)1.3 为什么这么说呢？1.4 难度把控1.5 题目名称1.6 最后 选题建议3 最后 毕设帮助，开题指导，资料分享，疑问解答(见文末)
1 开题指导 1.1 起因 近期开题的同学越来越多，很多同学不知道怎么选题，不知道老师分配的题目应该怎么做，指导老师分享的信息不多，无从下手。
1.2 如何避坑(重中之重) 毕设选题实际上对很多同学来说一个大坑， 每年挖坑给自己跳的人太多太多，选题选得好后面的答辩以及论文撰写会轻松很多，选的不好就是一个无穷无尽的折磨。。。。
1.3 为什么这么说呢？ 其实这主要是由于大部分同学对某种具体场景所需要的技术不清晰而导致的，定题的时候想当然的觉得某种功能是很好实现的，但是实际上往往并非如此。
所以，建议对课题实现技术不清晰的同学，最好是找自己的研究生学长或者老师详细的把关机技术以及实现流程理清楚，当然也可以来问我。
1.4 难度把控 (对于只要求顺利毕业的同学)定题不能定的太难，也不能定的太简单。太难了，自己做不出；太简单了，工作量不够，论文也没法写， 甚至进不了答辩。
1.5 题目名称 还有，最近很多同学跟学长反应，自己定的题目总是被老师打回去，这还真不怪老师，我看到你们定的题目也是哭笑不得。。。。。
学长在这里给你们分享一个定题标准，跟着这个标准定题准没错：
“使用了什么算法(技术) + 在什么场景下 + 解决了哪一类问题”
1.6 最后 学长限时开放免费开题指导，对开题有任何不明白的，对某项技术或算法不理解的，不知道怎么下手毕设的，都可以问学长，学长会根据你的情况提供帮助，希望能帮助到你。
选题建议 以下为学长手动整理的适合大数据毕业设计的项目，完全可以作为本科生当前较新的毕业设计题目选择方向。
贝叶斯网络模型在旅游大数据分析中的应用
大数据时代用户数据利益保护中的权利平衡
SPARKSQL系统查询优化的研究与实现
多功能情趣休闲沙发开发研究
基于Hadoop的中医病案数据挖掘系统研究与设计
大数据环境下我国政府数据开放平台建设策略研究
基于Hadoop平台的个性化图书推荐系统的研究
HS公司绿色创新战略研究
大数据时代下网络媒体体育新闻可视化研究
基于Key值解决MapReduce中Reduce负载不均衡算法
基于扎根理论的大数据时代商业模式创新研究
风力发电机组机舱温度场分析与热布局优化方法研究
物联网大数据聚类分析方法和技术研究
动车组全生命周期数据集成平台安全防护技术的研究
奥迪汽车网络营销策略研究
基于Hadoop的电梯安全大数据挖掘研究
基于数据挖掘的用电数据异常的分析与研究
基于电子病历数据的疾病预测模型构建研究
我国大数据技术发展的政策体系研究
大数据战略下边疆政府治理的技术变革研究
云计算中MapReduce分布式并行处理框架的研究
海卖宝邮政跨境电商供销服务平台发展策略研究
品牌汽车大数据评分研究 基于大数据的个性化学习环境构建研究
生鲜电商OO模式网络营销研究
“互联网+”背景下我国税收征管模式的研究
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f19e8605abd830e6096a9a565c4873b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4bf1b5d1894f9761bcd7483aab0f912/" rel="bookmark">
			Ubuntu18.04 安装使用uwsim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UWSIM主页 UWSim 安装教程链接： Installing UWSim - UWSim
与UWSIM交互教程 First steps: Interacting with UWSim - UWSim
配置和创建场景 Configuring and creating scenes - UWSim
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ebe5686f28784589994a9b72a165fdb/" rel="bookmark">
			如何使用css完成视差滚动效果?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是什么
视差滚动（Parallax Scrolling）是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验
我们可以把网页解刨成：背景层、内容层、悬浮层
当滚动鼠标滑轮的时候，各个图层以不同的速度移动，形成视觉差的效果
二、实现方式
使用css形式实现视觉差滚动效果的方式有：
background-attachment transform:translate3D 方式一：background-attachment
作用是设置背景图像是否固定或者随着页面的其余部分滚动
值分别有如下：
scroll：默认值，背景图像会随着页面其余部分的滚动而移动 fixed：当页面的其余部分滚动时，背景图像不会移动 inherit：继承父元素background-attachment属性的值 完成滚动视觉差就需要将background-attachment属性设置为fixed，让背景相对于视口固定。及时一个元素有滚动机制，背景也不会随着元素的内容而滚动
也就是说，背景一开始就已经被固定在初始的位置
核心的css代码如下：
section { height: 100vh; } .g-img { background-image: url(...); background-attachment: fixed; background-size: cover; background-position: center center; } 整体例子如下：
&lt;style&gt; div { height: 100vh; background: rgba(0, 0, 0, .7); color: #fff; line-height: 100vh; text-align: center; font-size: 20vh; } .a-img1 { background-image: url(https://images.pexels.com/photos/1097491/pexels-photo-1097491.jpeg); background-attachment: fixed; background-size: cover; background-position: center center; } .a-img2 { background-image: url(https://images.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ebe5686f28784589994a9b72a165fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2d9f96a46b0dd8e9c4ed933e2e176df/" rel="bookmark">
			数据库怎么查看死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询台输入 SHOW PROCESSLIST; 然后 查看state是否有 Waiting for table metadata lock
lock字眼，有的话 那张表就有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54f9a0988128e7296ea6bca478c673e/" rel="bookmark">
			Vue报错：“Duplicate keys detected:‘***‘.This may cause an update error”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue开发的时候遇到一个报错
原文：Duplicate keys detected: ‘1000’. This may cause an update error.
翻译后大概信息是说key重复了
其中detected的value应该是你重复的key值
错误原因：使用v-for时通常标准化的需要一个唯一的key值。当使用了两个循环，且循环遍历的是同一个数组/对象时，key同时也一样就会报这个错误。
解决方案
1、先找到重复的key值，修改即可
2、如果是两个for 在key后加字符 如：:key="item + ‘不同字符串’ "
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd7d7530509cfba0ee856dab02917cb/" rel="bookmark">
			linux将前台运行的进程转入后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：
当我们在Linux系统下执行Shell命令时，运行的时间可能会非常久。这期间如果电脑锁屏导致网络中断或者关闭客户端，这条命令的执行就会中断。在这种情况发生时，我们需要一个办法把这条正在执行的命令挪到后台执行。
方法如下：
1、CTRL+Z 先暂停这条命令并返回客户端。
2、jobs ##运行jobs命令，查看任务号(可以看到test.sh对应的任务号是1)
3、bg 1 ##运行bg命令，将任务从前台转到后台
其他小技巧：
1、部分堡垒机限制可以导致CTRL+Z失效，可以通过其他终端使用kill STOP pid 命令实现同样的效果。
2、运行fg命令，可以将任务从后台转到前台
fg 1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbbedca18a5fa5bad51db668cb7f710c/" rel="bookmark">
			js中创建对象、集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候有些数据需要在内存中完成，等用户确认后才能持久化，这个时候就需要在前台页面中创建对象、集合，保存用户的操作
js中创建集合 var list=[]; js中创建cs对象 var cs = { "id"：1, "name":'admin', "password":'admin' } 保存对象 list.push( cs ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bf56672450eb143f24b0cc3290ea1a/" rel="bookmark">
			MySQL学习笔记（五）—MySQL索引详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注： 本文基于InnoDB引擎
一、数据库索引简介 加快数据库查询速度而建立的目录
二、创建索引语法 首先创建一个表：create table t1 (id int primary key,username varchar(20),password varchar(20));创建单个索引的语法：CREATE INDEX 索引名 on 表名（字段名）索引名一般是：表名_字段名给id创建索引：CREATE INDEX t1_id on t1(id);创建联合索引的语法：CREATE INDEX 索引名 on 表名（字段名1，字段名2）给username和password创建联合索引：CREATE index t1_username_password ON t1(username,password)其中index还可以替换成unique，primary key，分别代表唯一索引和主键索引删除索引：DROP INDEX t1_username_password ON t1alter 表名 add index 索引名（field1，filed2）这种写法也可以创建索引 三、索引数据结构 MySQL数据索引使用的是B+树，多路平衡查找树。
特性：
由于磁盘预读，数据库每次读取行数据时会读取该行所在的页
设二叉树的阶数为m，则m/2 &lt;= k &lt;= m
B+树的节点存储元素数量为k - 1，所以树节点的元素数量等于数据库的页大小，默认16k
B+树的叶子节点都在同一层，按顺序形成一个有序链表,所以表会按照主键索引自增排序
问题1：为什么使用B+树，不使用二叉查找树？ 假设有1亿页数据，二叉树有1亿节点，该二叉树太高，查询效果差，而使用B+树存储， 100阶的B+树，高度为3，最多3次IO即可查到数据
B+树每一个节点，可以存放多个元素，二叉查找树每个节点只能保存一个数据，B+树的IO次数在数据量较大情况下会远远小于二叉查找树，数据比较次数相差不大
B+树中间节点不保存数据，只保存索引，同样大小的节点可以存储更多数据，树会更加矮胖
问题2：为什么不使用B树,散列表？ 1）B树查找性能不稳定，不需要遍历到叶子节点可能就查询到数据
2）索引需要支持范围查找，在B树中范围查找只能使用中序遍历，还需要跨层，而B+树在查到最小值 只需要遍历链表即可，同理散列表不支持范围查询
四、索引分类 主键索引
每张表有且只有一个主键索引树
主键索引B+树中，叶子节点存储所有数据，中间节点只保存索引
聚集索引
聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引
在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。主键索引默认是聚集索引，如果表中没有定义主键，InnoDB会选择一个唯一的非空索引代替，这个一般是InnoDB自动创建的隐式主键
辅助索引(联合索引，二级索引)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bf56672450eb143f24b0cc3290ea1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1bad51e8020fbdb4e5408505612fa6/" rel="bookmark">
			jquery&#43;wordexport&#43;FileSaver导出word文件(doc格式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作
//必要的js文件 &lt;script type="text/javascript" src="jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="FileSaver.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="jquery.wordexport.js"&gt;&lt;/script&gt; 这个链接是几个JS源文件的压缩包需要的小伙伴自行下载
提取码是 Mont
百度网盘 请输入提取码
//pdf handleExportPDF(){ var self=this; var exportMain = $("#exportPDF").clone(); exportMain.find("input").each(function() { if ($(this).attr("type") != "hidden") { if ($(this).attr("type") == "radio") { if ($(this).is(":checked")) { $(this).after("√"); } } else { var html = $(this).val(); $(this).after("&lt;lable&gt;" + html + "&lt;/lable&gt;"); } } $(this).remove(); }); exportMain.find("button").each(function() { $(this).remove(); }); exportMain.find(".el-input").each(function(i,item) { var html = item.innerText; $(this).after("&lt;lable&gt;" + html + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1bad51e8020fbdb4e5408505612fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375a637be2829715cb09d1a4cbb74298/" rel="bookmark">
			u盘格式化后数据恢复，3个简单步骤帮你恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		u盘作为一个重要的存储设备，里面保存着我们很多重要的数据，但是里面的数据被格式化了之后呢？u盘格式化后数据恢复可以恢复原本的数据吗？可以的。尝试下小编总结的3个步骤，教你快速找回格式化的数据。
一. u盘数据丢失的常见原因 u盘格式化有很多原因，各种原因会导致u盘格式化后打不开了。为了更好地解决大家的问题，建议大家先看看u盘格式化的常见原因，好找到对应的解决方法。
原因1：由于电脑系统问题 ，造成系统丢失某个与磁盘有关的文件，在电脑识别u盘时，造成无法识别的情况。
原因2：电脑的usb接口或者u盘本身出现了问题。
原因3：电脑驱动系统没有关于u盘的驱动或者驱动不全等。
原因4：在使用u盘时，不小心删除里面的文件，或者选错了u盘，我们不小心把重要的数据格式化。
如果是电脑系统问题，可以重装系统后再次尝试连接u盘或者换一台电脑试试；usb接口问题或者u盘本身问题，usb接口问题的话可以换主机后面的口试一下，u盘本身问题建议换新的u盘；驱动器问题，可以重装这种特殊u盘或者sd卡的驱动；误删或者格式化u盘问题，又没有备份，这时比较简单有效的方法就是通过专门的数据恢复软件来帮助。
二. u盘数据丢失如何恢复 了解了上面的常见原因之后，就可以根据对应的方法来解决。u盘提示格式化后数据能恢复吗？可以的。如果是误删或者自己不小心格式化了u盘数据，就可以通过数据蛙数据恢复专家来恢复数据，而且这个软件有免费试用的版本哦！
数据蛙数据恢复专家
具体的操作步骤：
步骤1：将u盘与电脑连接，打开数据蛙官方软件。选择“所有文件类型”，可以单独选择你要恢复的数据类型，也可以全选（建议第一次使用的用户全选）。然后选择可移动驱动器里面的u盘，点击页面右下角的“扫描”选项。
备注：该软件下载是免费的。
步骤2：扫描后的结果，查看是否有自己要恢复的数据。可以在页面左侧一个个点击查看，或者通过“筛选器”来搜索文件的名字、大小、日期等等。上述是快速扫描的结果，如果还是没有找到你要恢复的数据，就通过“深度扫描”来扫描更多内容。
步骤3：选择要恢复的数据，点击“恢复”。把要恢复的文件保存在D盘或者E盘，方便你自己查看，保存好后，重新打开电脑点击你保存的磁盘就可以看到恢复的文件了。
当你的u盘被格式化，不要对u盘继续进行读写，防止数据被覆盖，导致数据没有办法完整的被恢复。u盘格式化后数据恢复建议使用专门的软件来恢复，这样恢复的数据会比较全面，而且操作也是很简单的，电脑小白也能轻松操作。
往期推荐：
文件删除如何恢复？电脑数据恢复，4个详细方法https://mp.csdn.net/mp_blog/creation/editor/127258627
如何修复u盘？不如试试我这3个方法https://mp.csdn.net/mp_blog/creation/editor/127258682
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f2b10632891ffe77e87efe788ac1c2/" rel="bookmark">
			跨时代的Type-C接口显示器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人类感官有视觉、听觉、嗅觉、味觉、触觉、（第六感），其中视觉最为重要，一张图胜过千言万语。
图像对我们的影响是不言而喻的，比如查看信息，办公，电子游戏 ，观看影视剧， 网上冲浪 ， 学习， 展示 ，人机交互（家电显示屏，汽车仪表盘、中控，机械设备控制、状态监控等），千里眼（远程视频通话），拓展人眼的视野（光学显微镜，电子显微镜，望远镜通过摄像头采集后展示） ，手机 ，电脑 ，VR/AR/MR/XR 元宇宙等等。
显示器发明到如今也有一百多年的历史，最早进入消费者生活的是CRT阴极射线管显示器，俗称“大屁股”，90年代与洗衣机、冰箱、空调俗称结婚“四大件”。
尽管分辨率不堪入目，但是当时坐在家里看电视是最能体现家庭条件的娱乐活动，电视一开，门口挤满了人，就为了能看看电视。
如今时代飞速发展，显示器的进步也是日新月异，从厚重的身板变成了小蛮腰，分辨率更是提高到了16K，这在90年代看来是根本不敢想象的变化。
随着显示器的发展，各个厂商推出的显示器逐渐出现差异化，单视频传输接口就多达几十种，尽管不同接口各有千秋，但对于消费者来说，接口繁杂也意味着消费者要付出更多的操作学习成本。
为了解决接口繁杂的问题，跨时代的Type-C接口登场了，Type-C接口拥有不输于其他接口的传输速率，小巧便携，而且可以反向给设备提供快速充电。在手机上基本已经实现了统一，电脑也基本都配备了Type-C接口， 如今显示器接口也开始往这方面过度。
Type-C接口显示器不仅可以一线连接手机，游戏机，笔记本投屏，而且还可以反向给投屏设备实现快速充电，在投屏的同时，顺便还把电充满，在这个电量焦虑的时代，这种投屏反充的功能无疑深受消费者的青睐。
接下来我们看看Type-C接口是如何应用在显示器上的，在一款Type-C显示器的PCB板卡上可以知道，Type-C接口要传输电力，数据，视频必须要靠PD协议芯片去管理控制，PD协议可以说是Type-C接口搭载的逻辑通讯协议，在协议的基础上实现管理控制电力，数据，视频的切换。
本次测试的PD协议芯片是来自深圳乐得瑞科技的LDR6282，这款PD协议芯片具有双DRP及USB PD3.0功能，可以实现对两个Type-C接口的逻辑控制，而且具备两个C口可以任意盲插的功能，并支持任天堂Switch游戏机视频扩展。用户不必区分哪一个是充电口，哪一个是智能设备。LDR6282会根据USB PD协议解析，自动分配两个C口的连接关系。正如Macbook Pro对多个C口所做的智能适配。
双口DRP USB PD Controller LDR6282，顺利通过了USB-IF的PD3.0认证，TID: 2127。LDR6282芯片具有双C口DRP及USB PD3.0控制功能，广泛应用于USB-C Docking，USB-C 显示器，USB-C手机音频转接器，嵌入式安卓/linux系统等场合，在支持标准USB PD3.0/QC2.0/QC3.0协议的础上，还专门针对任天堂游戏机Switch的视频扩展功能进行了特别适配，兼容性非常优秀。
该芯片还内置64K flash可以通过云端连接升级内部固件。让复杂的产品设计也可以安枕无忧，即使产品已经交付到了终端消费者手里仍然可以通过手机端APP或者是PC端应用程序进行固件升级。
部分原理图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eea4975b03118f7013ceb6988aacf60/" rel="bookmark">
			Component name “School“ should always be multi-word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Component name "School" should always be multi-word的报错解决方法：
multi-word-component-names 意为多单词组件名
也就是命名的组件名不能只有一个单词(App除外)，并且多单词间要遵顼驼峰命名规则(推荐)，或者使用短横杠-连接
所以可以将组件名School改为SchoolName，但我们通常会遇到组件名不能修改的情况，所以还有另一种解决方式：
把.eslintrc.js换为下面这个代码：（如果没有.eslintrc.js就在根目录下创建一个）
module.exports = { root: true, env: { node: true }, extends: [ 'plugin:vue/essential' // '@vue/standard' ], parserOptions: { parser: 'babel-eslint' }, rules: { 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'space-before-function-paren': 0, 'eqeqeq': false, 'vue/valid-template-root': false, 'spaced-comment': false, 'quotes': false, 'eol-last': false, 'key-spacing': false, 'vue/valid-v-for':false, 'vue/no-unused-vars':false, 'vue/no-parsing-error':false } } 这样就可以顺利解决啦🙂
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fad239ab3e687759686a3f197139b25b/" rel="bookmark">
			【脚本】绘制矩形框，文字（用cv2）【草稿暂存】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 getTextSize()和putText() 截取的yolov5中绘制矩形框的代码 p1, p2 =(int(box[0]), int(box[1])), (int(box[2]), int(box[3])) # 绘制矩形box cv2.rectangle(self.im, p1, p2, color, thickness=self.lw, lineType=cv2.LINE_AA) # 绘制box上面的文字 if label: tf = max(self.lw - 1, 1) # font thickness w, h = cv2.getTextSize(label, 0, fontScale=self.lw / 3, thickness=tf)[0] # text width, height outside = p1[1] - h &gt;= 3 p2 = p1[0] + w, p1[1] - h - 3 if outside else p1[1] + h + 3 cv2.rectangle(self.im, p1, p2, color, -1, cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fad239ab3e687759686a3f197139b25b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4a31dd77d3d226b2dcaa9ede857f3c/" rel="bookmark">
			[护网杯 2018]easy_tornado1 刷题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本题考察的是SSTI注入的问题）
打开网站，发现有三个能访问的txt文件，分别是：
其实这里没有什么发现，看一下网址
render是一个渲染函数，属于tornato里面
Tornado全称Tornado Web Server，是一个用Python语言写成的Web服务器兼Web应用框架。
其实这里就已经可以猜测一下，可能和ssti模板注入有关。
补充一个知识点（大概）：
先测试一下是否存在ssti漏洞
输入error?msg={{2*2}},发现回显orz。查询了一下发现可能存在过滤。
那就根据hint去做题。先找到cookie_secrect是什么东西 。百度了一下，看到大佬解释说:
cookie_secret在tornado.web.RequestHandler中的application的settings中，也就是需要传参RequestHandler.application.settings。 但是这个没办法进行传参，真正的传参在提示里面，用handler.settings进行传参 放个链接
因此，构造查询语句：/error?msg={{handler.settings}}
得到cookie_secrect的值，再通过md5加密和脚本计算出md5(cookie_secret+md5(filename)
构造payload
http://fcd55237-10f0-4235-8a32-6d08a58863ac.node4.buuoj.cn:81/file?filename=/fllllllllllllag&amp;filehash=007ec658648c35e90601e3ffd8087aa1 得到flag 还得继续加油啊，还有好多注入模板不熟练！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5af6adeef21f64ce0722f7558ae111f/" rel="bookmark">
			WIN10安装Hyper V
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WIN10安装Hyper V 正常情况： Hyper-V是微软提出的一种系统管理程序虚拟化技术，能够实现桌面虚拟化。
正常情况下直接在控制面版-》程序-》程序和功能-》启用和关闭Windows功能中就可以开启Hyper V
异常情况： 然而有的win10电脑没有这个选项，所以需要我们手动安装。
具体步骤如下：
新建一个记事本文件，将下面的内容复制到其中
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 将文件名更改为Hyper-V.cmd，右键使用管理员运行。
等待运行完成后会出现确认重启电脑标识，输入Y自动重启电脑。
电脑重启完成后就可以在开始菜单下的Windows管理工具中找到Hyper V了
教程来自：链接: link
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb20644ef330e981e149ccb25820537f/" rel="bookmark">
			Android中 实现输入框搜索,清除历史记录的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先导入依赖:
compile 'com.carson_ho:SearchLayout:1.0.1' ------------------SearchActivity----------------------
package com.example.earl.mysearch_demo; import android.support.v7.app.AppCompatActivity; import android.os.Bundle; public class SearchActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_search); } } -----------------SearchListView-----------------
package com.example.earl.mysearch_demo; import android.content.Context; import android.util.AttributeSet; import android.widget.ListView; /** * Created by Carson_Ho on 17/8/10. */ public class SearchListView extends ListView { public SearchListView(Context context) { super(context); } public SearchListView(Context context, AttributeSet attrs) { super(context, attrs); } public SearchListView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } //通过复写其onMeasure方法、达到对ScrollView适配的效果 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int expandSpec = MeasureSpec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb20644ef330e981e149ccb25820537f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/123/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>