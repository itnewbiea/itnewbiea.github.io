<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e4ad6309d3495a427ae4d0dc9c0ae0/" rel="bookmark">
			Oracle进阶篇之查看执行计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、查看执行计划的方式
1.1、设置autotrace
1.2、使用第三方工具
1.3、EXPLAIN PLAN FOR
二、清除SGA缓存
三、分析执行计划
3.1、创建测试表
3.2、查看执行计划
3.2.1、执行计划
3.2.2、谓词说明：
3.2.3、统计信息
四、部分信息解释
4.1、SQL*Net roundtrips to/from client的计算方式
4.2、consistent gets
今天谈一谈Oracle查看执行计划的方式，以及怎样看执行计划。
一、查看执行计划的方式 1.1、设置autotrace autotrace命令如下
序号
命令
解释
1
SET AUTOTRACE OFF
此为默认值，即关闭Autotrace
2
SET AUTOTRACE ON EXPLAIN
只显示执行计划
3
SET AUTOTRACE ON STATISTICS
只显示执行的统计信息
4
SET AUTOTRACE ON
包含2,3两项内容
5
SET AUTOTRACE TRACEONLY
与ON相似，但不显示语句的执行结果
1.2、使用第三方工具 比如PL/SQL Develop的explain窗口
1.3、EXPLAIN PLAN FOR 据说在执行的SQL前加上 EXPLAIN PLAN FOR 可以查看执行计划，还没搞明白，后续补上
举例：
SQL&gt; EXPLAIN PLAN FOR SELECT * FROM EMP;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2e4ad6309d3495a427ae4d0dc9c0ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2aa9ac6671c62233c202fa3e93e15e9/" rel="bookmark">
			你不知道的并发/继发请求操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你需要知道的知识 async是 Generator 函数的语法糖，总是返回一个promise。async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 继发请求 使用 for循环 async function dbFuc(db) { let docs = [{}, {}, {}]; for (let doc of docs) { await db.post(doc); } } 使用reduce async function dbFuc(db) { let docs = [{}, {}, {}]; await docs.reduce(async (_, doc) =&gt; { await _; await db.post(doc); }, undefined); } } 并发请求 1.promise.all
async function dbFunc(db){ let docs = [{},{},{}]; let promises = docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2aa9ac6671c62233c202fa3e93e15e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580cc2e4554854183b8e591df9749211/" rel="bookmark">
			web3j的基础用法-6合约的监听器事件Event和过滤器EthFilter，以及NullPointed，调用失败导致的bug解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的监听一下某个合约的Transfer事件 本篇以Uniswap为例（https://uniswap.org/） 合约地址 ：0x1f9840a85d5af5bf1d1762f925bdaddc4201f984 （Uni） 监听合约Tranfer事件
调用代码 private void run1() throws Exception { log.info("hello eth,hello web3j"); Web3j web3j = Web3jInfo.connect(); // BigInteger total = TokenClient.getTokenTotalSupply(web3j, "0xff9c1b15b16263c61d017ee9f65c50e4ae0113d7"); // System.out.println("loot（0xff9c1b15b16263c61d017ee9f65c50e4ae0113d7） total:" + total); TransMonitor.getInstance().setWeb3j(web3j); TransMonitor.getInstance().subscribeContract("0x1f9840a85d5af5bf1d1762f925bdaddc4201f984", new Action1&lt;Log&gt;() { @Override public void call(Log log) { System.out.println("transBlockNo:" + log.getBlockNumber()); System.out.println("transHash:" + log.getTransactionHash()); List&lt;String&gt; topics = log.getTopics(); for (String topic : topics) { System.out.println("transTopic:" + topic); } } }); } 核心代码实现在这里 /** * 监听合约的交易事件 **/ public Subscription subscribeContract(String contractAddress, final Action1&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580cc2e4554854183b8e591df9749211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5588e83bac7bc4d2d8bb4ecb1ef9894/" rel="bookmark">
			Conv1d参数与输入数据均无nan，结果出现nan的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法： 极有可能是CUDA和pytorch版本适配的问题。博主在复现LaneGCN时，由于我们学校的服务器上的CUDA版本是11.1，与GitHub上官方代码给的pytorch的版本不一致，所以导致了这一令人完全摸不着头脑的问题。不过这也给我积累了一些经验，就是当你认为输入没有问题，模型没有问题（结构和参数没有问题），那就多半是一些不适配的问题（例如，CUDA和pytorch）。
由于服务器上的CUDA好像不能更改（似乎是可以的，但是挺麻烦），因此，我使用conda创建一个新的虚拟环境，在其中，使用pytorch官方的代码进行对应版本pytorch的配置:
conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch-lts -c nvidia 由于博主还是使用pytorch进行神经网络训练的小白，这篇博客是博主含泪用了一周半的时间好不容易找出的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21600a1cd592c65432ef55928b6ff5c0/" rel="bookmark">
			2021 年全国职业院校技能大赛（中职组）网络安全竞赛 A 模块评分标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 年全国职业院校技能大赛（中职组）
网络安全竞赛 A 模块评分标准
A-1 任务一 登录安全加固（ Windows, Linux）
请对服务器 Windows、 Linux 按要求进行相应的设置， 提高服务
器的安全性。
1.密码策略（ Windows, Linux）
a1. 密 码 策 略 必 须 同 时 满 足 大 小 写 字 母 、 数 字 、 特 殊 字 符
（ Windows）， 将密码必须符合复杂性要求的属性配置界面截图：
a2.密码策略必须同时满足大小写字母、 数字、 特殊字符（ Linux），
将/etc/pam.d/system-auth 配置文件中对应的部分截图：
b1.最小密码长度不少于 8 个字符（ Windows）， 将密码长度最小值的
属性配置界面截图：
b2.最小密码长度不少于 8 个字符（ Linux）， 将/etc/login.defs
配置文件中对应的部分截图：
2.登录策略
a.设置账户锁定阈值为 6 次错误锁定账户， 锁定时间为 1 分钟，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21600a1cd592c65432ef55928b6ff5c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eec489f6a4d4628cad97b232102c46c/" rel="bookmark">
			表格元素及其他元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格元素 表格的各部分元素 表格：table元素标题：caption元素分框：(1)表头：thead元素；(2)主体：tbody元素；(3)表尾：tfoot元素；框内子元素：(1)表格行：tr元素；(2)单元格——标题格：th元素、一般格：td元素。 样式及合并 边框折叠： border-collapse：collapse；——会使相邻单元格的边框重叠
单元格合并 ——给框内子元素加属性：
colspan=“ ”；——指几列单元格合并rowspan=“ ”；——指几行单元格合并 注：现在，表格不再适用于网页布局，其原因：表格的渲染速度过慢。
其他元素 time元素 提供给浏览器或搜索引擎阅读的时间 br元素 主要用于在文本中换行 hr元素 主要用于分割 meta元素 用于搜索引擎优化（SEO） link元素 链接外部资源（CSS、图标） rel属性：relation，表示链接的资源和当前网页的关系。
type属性：链接的资源的MIME类型。
链接外部样式： &lt;link rel="stylesheet" href="地址"&gt; 链接网站图标： &lt;link rel="icon" href="地址"&gt; /*注意：图标的形式要为：XXX.ico。*/ iframe元素 行盒，表示网页的嵌入 实现操作：在a链接的点击下，跳转相应网页框
在a元素中设置target="name名"；在iframe元素中设置name="name名"及src=“网站地址”。 以上内容了解即可，总体篇幅较短。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089b77a2f5ddd132069f72e6cdfc00b3/" rel="bookmark">
			表单元素及美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单元素 其下包含一系列元素，主要用于收集用户数据，其通常为行盒。
input元素 ——为输入框元素，且其为空元素。
内部属性 type属性（输入框类型）
type: text——普通文本输入框
type：password——密码框
type: date,——日期选择框
type: search——搜索框
type: checkbox——多选框
type: radio——单选框
注意：当type值为checbox或radio时，要给对应框设置name来区分组别。
value属性(输入框的值)
placeholder属性(显示提示的文本，文本框没有内容时显示)
select元素 ——下拉列表选择框元素
1.常见子元素： 通常和option元素配合使用，option作为其中选项。
2.内部可搭配属性： selected属性（被选中的值）
multiple属性（多选，搭配可使其变为下拉多选框）
textarea元素 ——文本域，多行文本框
button元素 ——按钮键
内部可搭配属性 type属性设置：
type: reset——重置按钮
type：submit——呈递按钮（默认）
type: button——普通按钮
表单状态 readonly属性：布尔属性，是否只读——不会改变表单显示样式
disabled属性：布尔属性，是否禁用——会改变表单显示样式
配合表单元素的元素 label元素 ——使字与按钮键产生关联，通常配合单选和多选框使用
注意：不能在内部加div盒子，可以加span元素
具体方式 显示关联，可以通过for属性，让label元素关联某一个表单元素，for属性下书写表单元素id的值隐式关联，直接将其书写为引用元素父元素。例如：&lt;label&gt;&lt;input......&gt;&lt;/label&gt; fieldset元素 ——表单分组元素，将对内容分组。
表单元素美化 两种伪类选择器 ：focus ——元素聚焦时的样式
input:focus { outline:1px solid #008c8c; outline-offset:0; } ：checked ——单选或多选框被选中的样式
文本框边缘到内容的距离 padding；——控制边缘的内边距text-indent；——控制文本缩进 美化单选框： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089b77a2f5ddd132069f72e6cdfc00b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107843fbb66eeee269d6acad5ab4d14f/" rel="bookmark">
			[代码分析]思维导图流程图drawio使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List Table Container 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f64cb0d2119d1d3095721901a13de8c4/" rel="bookmark">
			web3j的基础用法-3ETH交易监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ETH的交易监听器 demo简单实现了4种 监听区块 public Subscription subscribeBlock(final Action1&lt;? super EthBlock&gt; onNext) { if (this.web3j == null) return null; return this.web3j.blockObservable(true).subscribe(onNext); } public void unsubscribeBlock(Subscription subscription) { if (this.web3j == null) return; subscription.unsubscribe(); } 监听所有交易 /** * 监听新交易事件 * 已经交易的事件 **/ public Subscription subscribeHasTrans(final Action1&lt;? super Transaction&gt; onNext) { if (this.web3j == null) return null; return web3j.transactionObservable().subscribe(onNext); } /** * 取消订阅信息 **/ public void unsubscribeHasTrans(Subscription subscription) { if (this.web3j == null) return; subscription.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f64cb0d2119d1d3095721901a13de8c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79034fa79c2add71cc9c6e6cf0629ce/" rel="bookmark">
			vue脚手架如何从4降到3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想让vue从4到3，需要两个命令
卸载
npm uninstall -g @vue/cli
重装
npm install -g @vue/cli@3.11.0
然后就可以得到一个vue 3.11.0的版本了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67d00be2c1e97a2f0c41666f8767c94/" rel="bookmark">
			【深度学习】Layer Normalization
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深度学习】Batch Normalization_littlemichelle-CSDN博客
与BN的原理一致，只是归一化的对象不同。
目录
Normalization
Batch Normalization
Batch Normalization的优势、劣势
Layer Normalization
CNN为什么要用BN， RNN为何要用layer Norm？ - 子不语的回答 - 知乎
Normalization 不管是Batch Normalization还是Layer Normalization，Normalization的目的是为了把输入转化成均值为0方差为1的数据。换句话说，这里的Normalization其实应称为Standardization（标准化），而不是Normalization（归一化）。
Normalization一般是在把数据送入激活函数之前进行的，目的是希望输入数据不要落在激活函数的饱和区。
Batch Normalization Batch Normalization是用来解决“Internal Covariate Shift”问题的，其计算如下图所示：对于神经元 k ，假设某个 Batch 包含 n 个训练实例，那么每个训练实例在神经元 k 都会产生一个激活值，也就是说 Batch 中 n 个训练实例分别通过同一个神经元 k 的时候产生了 n 个激活值，BatchNorm 的集合 S ，选择入围的神经元就是这 n 个同一个神经元被 Batch 不同训练实例激发的激活值。划定集合 S 的范围后，计算其均值与方差，进行标准化即可。
重要的结论：1、ICS不是训练不好的真正原因；2、在更规范的定义下，BN不能减少ICS。
最后一步是进行尺度缩放和偏移操作，目的是实现恒等变换，使其可以变换回原始的分布。此举亦可补偿网络的非线性表达能力，因为经过标准化之后，偏移量丢失。当gamma等于标准差，β等于均值的时候，就实现了恒等变换。
从某种意义上来说，gamma和beta代表的其实是输入数据分布的方差和偏移。对于没有BN的网络，这两个值与前一层网络带来的非线性性质有关，而经过变换后，就跟前面一层无关，变成了当前层的一个学习参数，这更加有利于优化并且不会降低网络的能力。
Batch Normalization在CNN中的使用 BN层是对于每个神经元做归一化处理，甚至只需要对某一个神经元进行归一化，而不是对一整层网络的神经元进行归一化。既然BN是对单个神经元的运算，那么在CNN中卷积层上怎么办??
假如某一层卷积层有6个特征图，每个特征图的大小是100*100，这样就相当于这一层网络有100*100*6个神经元，如果采用BN，就会有100*100*6个参数γ、β，这样岂不是太恐怖了。因此卷积层上的BN使用，其实也是使用了类似权值共享的策略，把一整张特征图当做一个神经元进行处理。
CNN经过卷积后得到的是一系列的feature map，如果min-batch sizes为m，那么网络某一层输入数据可以表示为四维矩阵(m,f,p,q)，m为min-batch sizes，f为特征图个数，p、q分别为特征图的宽高。在CNN中我们可以把每个特征图看成是一个特征处理（一个神经元），因此在使用Batch Normalization，mini-batch size 的大小就是：m*p*q，于是对于每个特征图都只有一对可学习参数：γ、β。说白了吧，这就是相当于求取所有样本所对应的一个特征图的所有神经元的平均值、方差，然后对这个特征图神经元做归一化。
Batch Normalization的优势、劣势 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67d00be2c1e97a2f0c41666f8767c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe0a5338b8e1f1cda04fcf54fbc778e/" rel="bookmark">
			Android 底部按钮被软键盘顶起问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们目前的项目是采用单 Activity 多 Fragment 的架构模式， AndroidManifest.xml 内 MainActivity 的配置如下所示。
&lt;activity android:name=".MainActivity" android:exported="true" android:windowSoftInputMode="stateHidden|adjustResize"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; stateHidden
状态隐藏，如果我们设置了这个属性，键盘状态就一定是隐藏的，不管上个界面是什么状态，也不管当前界面有没有输入的需求，就是不显示软键盘。adjustResize
调整大小状态，这个属性表示 Activity 的主窗口总是会被调整大小来保证软键盘的显示空间。如果界面中有可滑动控件，显示效果跟 adjustUnspecified 显示效果一样；如果界面中没有可滑动控件，软键盘可能会盖住一些控件(布局的位置不会发生变化，可能获取了焦点的控件被软键盘盖住)。
一般来说，我们的布局分为两种
底部按钮被滚动布局包裹底部按钮不被滚动布局包裹 第一种布局是不会出现软键盘把底部按钮顶起的情况，首先软键盘的打开实际上是一个 Dialog，而我们在配置文件内的 adjustResize 属性是在页面的根布局 decorView 的子 view 也就是一个线性布局内通过设置 paddingBottom = 软键盘高度，这样其实相当于把整个滚动布局的高度减少了，所以底部的按钮也只是变为需要滚动才能看到。
第二种情况通常为一个继续按钮始终处于页面的底部，中间的内容可以滚动，当根布局的内边距等于软键盘高度时，底部按钮就看起来像是被顶起。
从大的方向来说可以通过修改 windowSoftInputMode 来设置布局对软键盘的处理方式，当然也可以通过监听软键盘，这种修改的细粒度更小。 1、监听软键盘的打开收起
const val SOFT_KEY_BOARD_MIN_HEIGHT = 100 fun Fragment.registerFragment(bottomView: View){ view?.registerView(bottomView) } fun Activity.registerActivity(bottomView: View){ window?.decorView?.findViewById&lt;View&gt;(android.R.id.content)?.registerView(bottomView) } fun View.registerView(bottomView: View){ var keyboardVisible = false viewTreeObserver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe0a5338b8e1f1cda04fcf54fbc778e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd060b802d9739d0a46f2ae340429be8/" rel="bookmark">
			Golang sort包排序（详细全集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、整型倒序 二、浮点型三、字符串型四、真的使用的是快速排序算法吗？五、稳定性六、结构体类型排序 一、整型 首先用下里面提供的最简单的例子，排序一下整形
package main import ( "fmt" "sort" ) func main() { a := sort.IntSlice{2, 8, 3, 7, 9, 4, 1, 6} fmt.Println("排序前", a) sort.Sort(a) fmt.Println("排序后", a) } 你最好奇的应该是 sort.IntSlice 这个是什么东西。点进去查看源码，可以看到它是 []int 类型并绑定了四个方法，前三个是对排序的对象必须得拥有的（也就是说如果自己想对一个对象排序时，必须实现这些方法），但sort包已经给我们实现了。然后还绑定了一个 Sort() 方法
基于这些信息，我们就可以改造一下前面的示例，直接调用该对象里面绑定的 Sort() 方法，而不是使用sort包中提供的 Sort() 方法，结果不变。
func main() { a := sort.IntSlice{2, 8, 3, 7, 9, 4, 1, 6} fmt.Println("排序前", a) // sort.Sort(a) a.Sort() fmt.Println("排序后", a) } 如果我们不使用里面的提供的 sort.IntSlice 类型，而是自己实现一个，怎么写，直接复制里面 IntSlice 的实现，然后换一个名字即可【苦笑.jpg】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd060b802d9739d0a46f2ae340429be8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/864470d993ccb0a67c7e5bd9e17f8893/" rel="bookmark">
			web3j的基础用法-2多种创建钱包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建钱包 分为3方式 创建助记词钱包，并返回助记词到指定文件 public static boolean createWallet(String filePath, String destFile) throws CipherException, IOException { FileUtil.createOrExistsDir(new File(filePath)); Bip39Wallet bip39Wallet = WalletUtils.generateBip39Wallet("", new File(filePath));//助记词钱包生成 bip39Wallet.getMnemonic(); System.out.println("生成助记词:" + bip39Wallet.getMnemonic()); return FileUtil.writeFileFromLineString(new File(destFile), bip39Wallet.getMnemonic(), true); } 创建完整类型的钱包 /** * return fileName **/ public static String createWalletFull(String password, String destFile) throws CipherException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, IOException { FileUtil.createOrExistsDir(new File(destFile)); return WalletUtils.generateFullNewWalletFile(password, new File(destFile)); } 创建一个简单钱包 /** * return fileName ***/ public static String createWalletLight(String password, String destFile) throws CipherException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, IOException { FileUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/864470d993ccb0a67c7e5bd9e17f8893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d285a396bfd5068505673873fa27beb/" rel="bookmark">
			关于Java.Swing中Graphics 的应用（简单的一篇就够）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Graphics中可画的图形 graphics中可以画出的简单图形以及相关函数 图形调用的函数说明划线drawLine(int x1,int y1,int x2,int y2) 在（x1,y1）与（x2,y2）之间画出一条直线，当然两个坐标相等就是点矩形drawRect(int x,int y,int width,int height)x,y是其左上角的位置，其他是矩形的长和宽fillRect(int x,int y,int width,int height)利用此方法可以对矩形的颜色进行填充圆角矩形drawRoundRect(int x,int y,int width, int height, int arcWidth, int arcHeight)是用线围起来的圆角矩形。其中参数x和y指定矩形左上角的位置；参数width和heigth是矩形的宽和高；arcWidth和arcHeight分别是圆角弧的横向直径和圆角弧的纵向直径。fillRoundRect(int x,int y,int width,int height,int arcWidth,int archeight)是用预定的颜色填充的圆角矩形。各参数的意义同前一个方法三维矩形draw3DRect(int x,int y,int width,int height, boolean raised)画一个突出显示的矩形。其中x和y指定矩形左上角的位置，参数width和height是矩形的宽和高，参数raised是突出与否fill3DRect(int x,int y,int width,int height,boolean raised)用预定的颜色填充一个突出显示的矩形圆弧drawArc(int x,int y,int width,int height,int startAngle, int arcAngle)椭圆的中心是它的外接矩形的中心，其中参数是外接矩形的左上角坐标(x,y)，宽是width，高是heigh。参数startAngle的单位是 “度”，起始角度0度是指3点钟方位.参数startAngle和arcAngle表示从startAngle角度开始，逆时针方向画arcAngle度的弧，约定，正值度数是逆时针方向，负值度数是顺时针方向，例如-90度是6点钟方位。fillArc(int x,int y,int width, int height, int startAngle, int arcAngle)用setColor()方法设定的颜色,画着色椭圆的一部分椭圆drawOval(int x, int y, int width, int height)用线条围起来的椭圆fillOval(int x, int y, int width, int height)可以填充颜色 上述代码举例： 划线代码 import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d285a396bfd5068505673873fa27beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca5a2a7e98308d52d066f6a0215785f/" rel="bookmark">
			Python--爬取任意贴吧网页信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python–爬取任意贴吧网页信息并且保存在本地 提示：
①.需要提前使用pip安装requests库，或者pycharm自行安装，在py文件中能够入requests库即可。
②.本文可爬取任意贴吧，只需要加上你需要爬取的参数即可。
③.本文不做任何教学，只将代码附上，有需要学习的或者借鉴的从代码中自行学习！，介意勿看。
完整代码附上 """ 需求： 爬取任意贴吧的网页信息，并保存在本地。 """ import requests class Spider_Tieba: def __init__(self, tieba_name): self.tieba_name = tieba_name self.url = "https://tieba.baidu.com/f?kw=" + tieba_name + "&amp;ie=utf-8&amp;pn={}" self.headers = { "User-Agent": "Mozilla/5.0"} def get_url_list(self): # 得到需要爬取的所有贴吧url，放到列表中 url_list = [] for i in range(50): #*****此处50意味着我设定爬取五十页，您可以按照自己需求修改 url_list.append(self.url.format(i * 50)) return url_list def parse_url(self, url): # 发送请求，得到相应信息 print(url) response = requests.get(url, headers=self.headers) print(response.status_code) return response.content.decode() def save_html(self, html_str, page_num): # 保存在本地 file_path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca5a2a7e98308d52d066f6a0215785f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b102366c07ad6a96d083c6f973def3/" rel="bookmark">
			Win10如何查看显卡驱动是否运行正常？Win10查看显卡驱动正常运行方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是大飞，今天带了win10的相关问题及解决办法。
我们有时候在使用Win10电脑玩游戏的时候会遇到游戏掉帧或者卡顿的现象，这个时候有可能是显卡驱动运行不正常，那么Win10要如何查看显卡驱动是否运行正常呢？下面就和大飞一起来看看怎么操作吧。
Win10查看显卡驱动运行正常的方法 1、在桌面模式右键地点击此电脑选择属性。
2、进入计算机属性点击i设备管理器。
3、按下图展开的设备管理器界面显示适配器。
4、这时就可以看到你的显卡列表了，如果你的显卡名称前面没有黄色感叹号，就说明你的显卡驱动基本正常，继续往下。
5、右键单击显卡驱动选择属性进一步查询。
6、进入显卡属性面板，检查设备状态是否是正常运行，如果是需要进一步安装就是驱动还有问题，我们可以更新解决。
以上便是大飞为大家带来的Win10如何查看显卡驱动是否运行正常的全部内容，希望对大家有所帮助，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061673031b5506a201d0b29058de216d/" rel="bookmark">
			选择大于努力，学习要看笔记，牛人笔记真牛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选 恰逢求职季，招聘季，很多求职者的技术水平和视野越来越高，竞争激烈。宜未雨而绸缪，毋临渴而掘井。有时候，你只要比其他人多答对一道题，机会就属于你了。
诚意推荐几位过来人，他们职场工作经验丰富，公众号内容重视求职面试。关注他们，让你在不知不觉间学习成长，提升并强大自己，更得心应手地应付求职面试中的各种大问题和小问题。
择大于努力，学习要看笔记，牛人笔记真牛！
IT巅峰技术 公众号简介: RocketMQ技术内幕第二版作者，主要以中间件（Redis/MQ/ES），大数据（Spark/Flink/CK），微服务/容器等热门技术分享为主，同时也会输出生产架构设计案例及实战。
公众号分享的技术均在日均百亿规模的生产环境下使用，如：RocketMQ日均消费量1000亿+条，Redis单集群日请求量110亿+次等，ES非日志类数据量均在百亿级别，Kafka就更大了，等等；
点击如下名片，便可关注：
李哥技术笔记 号主小李同学，计算机硕士，公众号长期分享数据结构与算法、编程语言和后台开发相关资料！推文相当硬核，墙裂建议大家关注。
关注李哥技术笔记，后台回复算法刷题，获取Leetcode刷题资料。
更多学习资料，关注回复加群，群里可以提各种技术、产品、管理、认知等问题，大家一起学习，共同进步！
点击如下名片，便可关注：
五角钱的程序员 五角钱的程序员是一个非常硬核的公众号，号主是个95后的重庆小哥，本科就读某三本院校，通过自己的不断努力，现在已经是一名计算机技术的硕士研究生，可是说是一位非常厉害的小哥了。
号主主要研究方向大数据，公众号专注大数据，java等相关知识，除了分享很多干货，同时分享自己的成长经历，从三本一路考上研究生的经历和生活等等。同时，公众号配图和排版都非常的漂亮，强烈推荐给大家哦。
点击如下名片，便可关注：
七天小码哥 "Python 之父" 推荐的国内唯一 Python 入门书《零基础轻松学 Python》作者。每天分享 Python 干货，从数据分析、人工智能等技术文章、到 Python 工具资源、热点资讯、学习资料等，还有小白原创系列文章。
点击如下名片，便可关注：
Lucifer三思而后行 个人简介：CSDN全站前100，HDZ核心组成员，华为云享专家全栈领域博主，CSDN原力计划作者，掘金优秀作者，资讯创作者，公众号【Lucifer三思而后行】，全网粉丝6万+。我是一枚喜欢学习，专研，输出的数据库DBA，专注于各种数据库、Linux等后端技术，分享各种干货实战文！灵感来源于生活，故而热爱生活~ QQ：2689352866
QQ交流群：761812625
微信：Lucifer-4622
记得点击 "Lucifer三思而后行, 设为星标⭐
后台回复【进群】，申请加入Lucifer数据库学习交流群
教你学懂大数据 号主三少，新晋互联网大数据工程师，带领大家学会大数据，用最简单的案例，教你学懂最难的技术，可以关注我微信：bigdatayyds,学懂大数据不再难。关注【教你学懂大数据】，在会话栏回复“大数据”，获取超全的大数据学习资料！
点击如下名片，关注即可获取：
程序猿阿星 阿星自学转行，对技术充满热情，公众号里定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，文章风格图文并茂，通俗易懂，干货多多~ 强烈推荐关注！
关注『程序猿阿星』，回复 白嫖 获取Java就业、架构师视频资源（全套体系资源，质量绝对高）
点击如下名片，关注即可获取：
行走的数据智能 数智侠，计算机小硕，目前通讯行业从事大数据研发工作。专注于大数据平台、日志系统、数据仓库、数据中台、实时数仓、企业数字化转型等数据技术领域。公众号分享大量干货，包括数据中台/数字化转型方案和案例、大数据架构、数据治理、数据处理优化技巧等。希望大家持续关注，不断给大家惊喜。
码农开花 某大厂技术人；定期分享 Java 、大数据等技术干货，包括 Java 基础、Java 并发、JVM、分布式、微服务、消息队列、源码解析、数据库、设计模式、面经等，助你编程之路少走弯路，当然也有必不可少的优质资源，回复【资料】等等有惊喜哦！期待你的加入，共同成长
点击如下名片，便可关注：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bf1d59c371f3094f8289b4dc816318/" rel="bookmark">
			【转】词嵌入的人话解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 词嵌入是单词的一种数值化表示方式，一般情况下会将一个单词映射到一个高维的向量中（词向量）来代表这个单词。例如我们将：
1.‘机器学习’表示为 [1,2,3]
2.‘深度学习‘表示为[2,3,3]
3.‘英雄联盟‘表示为[9,1,3]
对于词向量，我们可以使用余弦相似度在计算机中来判断单词之间的距离：
‘机器学习’与‘深度学习‘的距离：
‘机器学习’与‘英雄联盟‘的距离：
通过这篇文章你可以学习到下面内容：
1.文本的词嵌入是什么，以及它与其他特征提取方法有什么区别。
2.介绍3种主流的从文本数据中学习词嵌入的方法。
3.怎么训练新的词嵌入以及如何在日常的NLP任务中使用预先训练好的词嵌入。
什么是词嵌入? 词嵌入是一种对文本算法学习后的表示形式，甚至，你可以理解为一个单词在算法中的储存形式。大家知道存入计算机的都是0101的数值化序列，这里也是同理，词嵌入就是将文本数值化以方便拟合算法。这种将单词或者文档数字化表示的方式被认为是深度学习在自然语言处理任务中最具有挑战性的问题之一。
使用密集和低维向量的一个好处是方便计算：大多数神经网络工具包不能很好地处理非常高维，稀疏的向量。…密集表示的主要好处是泛化能力，如果我们认为某些特征可能提供类似的线索，那么提供能够捕获这些相似性的表示是值得的。
— Page 92, Neural Network Methods in Natural Language Processing, 2017.
词嵌入实际上是一种将各个单词在预定的向量空间中表示为实值向量的一类技术。每个单词被映射成一个向量（初始随机化），并且这个向量可以通过神经网络的方式来学习更新。因此这项技术基本集中应用与深度学习领域。
这项技术的关键点在于**如何用密集的分布式向量来表示每个单词。**这样做的好处在于与one-hot这样的编码对比，使用词嵌入表示的单词向量往往只有几十或者几百个维度。极大的减少了计算和储存量。
将词汇表中的每个词与分布式词特征向量相关联…特征向量表示词的不同方面特征，每个词与向量空间中的点相关联。特征的数量…远小于词汇的大小
— A Neural Probabilistic Language Model, 2003.
这种分布式的词向量表示方式依赖于单词的使用习惯，这就使得具有相似使用方式的单词具有相似的表示形式。这个怎么理解呢？回想我们在看游戏直播，IG获得冠军时候的弹幕，很多主播（无论游戏还是娱乐）的直播间都在发‘IG牛逼’和 ‘77777’，所以我们算法能学习到，‘IG牛逼’和 ‘77777’是向量空间中很相近的2个词。
虽然看起来有些粗糙，但是这个方法背后有很深的语言学理论支撑。即Zellig Harris的“distributional hypothesis”。这个假设可以归纳为：具有相似语境的词语具有相似的含义。有关更深入的信息，请参阅Harris的1956年论文 “Distributional structure“。
这种使用语境定义单词的概念可以通过John Firth经常重复的谚语来概括：
You shall know a word by the company it keeps!
— Page 11, “A synopsis of linguistic theory 1930-1955“, in Studies in Linguistic Analysis 1930-1955, 1962.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0bf1d59c371f3094f8289b4dc816318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78be56eb00ef6cc3e7222dedaab2948/" rel="bookmark">
			数字图像学习——双线性插值方法部分的讨论【个人详细推导】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：
虽然该部分内容属于基础中的基础，然而学习中会有“熟知≠真知”的情况，故决心写下笔记。本文着重对简单原理的详细推导，对你在免费文章和课程中不涉及的“坑”进行细致地数学剖析，结合自己做的图示，通过问题带动思考的引导方式系统地进行分情况讨论等……更加适合专业人士复习和初学者学习！
一、准备工作：
1.1认清几个事实：
(I).数字图像在计算机中是以矩阵形式储存，其行列下角标从0开始；
(II).矩阵中每个元素中储存对应数字图像中的像素值(可能不只一个通道)；
(III).矩阵中元素信息对应数字图像对应位置中的位置和像素值信息，却不包含实际图像中像素点本身大小。
(IV).将图像放置于坐标系中，y轴正方向向下，x轴正方向向右。
1.2提出几个设定：
(I).下述讨论中，为了便于理解，假设所有图像中的像素点均为边长1的正方形
(II).原图像尺寸(H=m, W=n)，原图像矩阵
(III).原图像中各点像素值(矩阵中元素值)与位置坐标满足映射
图 1 数字图像与对应矩阵图示
二、坐标变换讨论：
2.1 原图像、目标图像和插值点阵
设：目标图像尺寸(H=r, W=s), 图像矩阵
因此y方向(即H方向)变换比例为 ，
同理x方向(即W方向)变换比例为 。
那么在进行插值之前，我们就要试图找到图像B中各像素点与图像A中各像素点的“某种’位置’对应关系”，在此对应关系基础上，才可以应用插值算法。
那么位置对应关系如何建立？
我们很自然地认为只需要将B中像素坐标
即可得到 作为 的插值点并与A中相关的4个点进行插值运算得到像素值。
但是！请稍作思考，我们就会发现由于1.1(I)(即A、B矩阵中元素下角标规律)和1.2(I)的存在，图像尺寸之间的比例缩放与坐标换算之间存在差异，这种差异会导致我们的坐标按照③式变换后得到B的插值点阵 的坐标偏向左上角且与A于左上角对齐。这种“不对称”会给插值结果带来“不可接受”的偏差，因此我们需要消除。
那么，的坐标到底要如何做？
图 2 缩放前后数字图像与对应矩阵图示
图 3 图像B经比例变换后的点阵M与其矩阵图示
2.2几何中心的对齐
也许解决这个问题的思路之一就是“修正” 的坐标，方法就是对齐进行坐标平移变换使二者几何中心坐标相等，即所谓对齐。
那么，平移向量如何取？我们不妨以y轴方向(H方向)举例推导，x轴方向同理。
原图像几何中心坐标 ，
图像B的插值点阵 几何中心坐标 ，
无论向量直接对A、直接对B、直接对M或者对A、B同时平移，在数学上均可以推导出大家在很多文章中看到的“左右各 ”的形式，下面是直接对M平移的推导过程：
设：对M平移k个单位与A对齐，则根据④=⑤+k式可以得，
将k值代回⑥到得，
看！我们成功得到的大家在资料中看到的⑦式同样形式的“左右各 ”结论。
但是，请注意！不要过度喜出望外，还记得我们仅仅是将“M几何中心坐标通过坐标平移变换与A的几何中心坐标重合”了么？
那么，M中其他坐标变换后的坐标表达式是什么呢？
2.3 关于插值矩阵中坐标的讨论【原创】
2.3.1 平移后插值点阵所对应矩阵坐标的取值范围
根据上一节知，我们对M中坐标进行平移变换，变换后得到新的插值点阵 ，则
图 4 点阵M经过坐标平移变换T的插值点阵与矩阵坐标图示
由于 ，我们可以得到y方向插值点阵 的坐标取值范围为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d78be56eb00ef6cc3e7222dedaab2948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f46b076562f9397da6617a377d4541/" rel="bookmark">
			Java并发编程之AQS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容摘抄自Java并发之AQS详解 - waterystone - 博客园、深入理解Java中的AQS - 夏末秋涼 - 博客园
目录
一、概述
二、框架
三、源码解析
3.1、结点状态waitStatus
3.2、acquire(int)
3.2.1 tryAcquire(int)
3.2.2 addWaiter(Node)
3.2.3 acquireQueued(Node, int)
3.2.4、小结
3.3、release(int)
3.3.1、tryRelease(int)
3.3.2 unparkSuccessor(Node)
3.3.3、小结
3.4、acquireShared(int)
3.4.1 doAcquireShared(int)
3.4.2、小结
3.5、releaseShared()
3.5.1、doReleaseShared()
3.6、小结
一、概述 AbstractQueuedSynchronizer抽象队列同步器简称AQS，它是实现同步器的基础组件，juc下面Lock的实现以及一些并发工具类就是通过AQS来实现的，如常用的ReentrantLock、Semaphore、CountDownLatch...... 这里我们通过AQS的类图先看一下大概，下面我们总结一下AQS的实现原理。
二、框架 AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。 state的访问方式有三种:
getState()setState()compareAndSetState() AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。
不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：
isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。
再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。
一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。
AQS的设计师基于模板方法模式的。使用时候需要继承同步器并重写指定的方法，并且通常将子类推荐为定义同步组件的静态内部类，子类重写这些方法之后，AQS工作时使用的是提供的模板方法，在这些模板方法中调用子类重写的方法。其中子类可以重写的方法：
//独占式的获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态 protected boolean tryAcquire(int arg) {	throw new UnsupportedOperationException();} //独占式的释放同步状态，等待获取同步状态的线程可以有机会获取同步状态 protected boolean tryRelease(int arg) {	throw new UnsupportedOperationException();} //共享式的获取同步状态 protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException();} //尝试将状态设置为以共享模式释放同步状态。 该方法总是由执行释放的线程调用。 protected int tryReleaseShared(int arg) { throw new UnsupportedOperationException(); } //当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占 protected int isHeldExclusively(int arg) {	throw new UnsupportedOperationException();} 三、源码解析 本节开始讲解AQS的源码实现。依照acquire-release、acquireShared-releaseShared的次序来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f46b076562f9397da6617a377d4541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76b08929eff0de0478d563aaea8920c/" rel="bookmark">
			关于matlab runtime的配置,及runtime error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用matlab的自.exe工具箱时,需要安装对应runtime,博主因为在配此环境时,看了配置runtime很多帖子写的乱七八糟,索性自己就写写一篇吧(亲测有效)
首先,去 官网 下载对应版本的或者自己想要的runtime版本,不需要子版本一致(很多文章里都说要),但我没有按照他们的来也可以,没有那么苛刻.
博主这里是2020b,下载9.9的版本,但前后相差不大的版本也可(试过9.8的也行)
双击.exe文件
点下一步
选择matlab安装路径下的下图路径
安装完毕, 此时去matlab命令窗口输入mcrinstaller,会如上图显示ans=空,但不用按照许多博主说的那样安装对应子版本
mcrinstaller 此时只需在命令行再输入compiler.runtime.download
compiler.runtime.download matlab会从网上自行检测下载对应版本,但已经安装的话会检测出来如下图
再输入mcrinstaller检测一下,就显示已经安装了
mcrinstaller 大功告成,别忘了一键三连哦!!!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3796b2cb7c933c4d603ae59f9193a716/" rel="bookmark">
			构造三栏布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三栏布局 题意： 写一个三栏布局，中间自适应，两边固定。
方法一：定位 1.使用相对定位处理两边的盒子；
2.对中间盒子的宽度不限定；
3.控制中间盒子margin使其不被挡住。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;三栏布局&lt;/title&gt; &lt;style&gt; .sanlan1{ height: 100%; width: 200px; background-color: blue; position: absolute; left: 0; top: 0; } .sanlan3{ height: 100%; width: 200px; background-color: rgb(129, 42, 83); position: absolute; right: 0; top: 0; } .sanlan2{ height: 100%; margin:0 200px; background-color: rgb(12, 42, 83); } &lt;/style&gt; &lt;/head&gt; &lt;body style="position:relative;"&gt; &lt;div class="sanlan1"&gt;&lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3796b2cb7c933c4d603ae59f9193a716/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814404efbd9e362d5ad96aa04a78a5a7/" rel="bookmark">
			Intel HAXM is required to run this AVD. No emulator installed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天Android Studio运行模拟器莫名其妙报错，昨天还好好的，错误如下图：
在网上查了很多解答，说是Intel HAXM问题，但很明显这个问题出在“No emulator installed”这里。
解决办法 解决办法如下图，去掉Android Emulator勾选-&gt;点击Apply-&gt;apply成功后再勾选Android Emulator-&gt;点击Apply；问题解决。
以上解法参考了stackoverflow上的一个回答，如果以上方法无法解决你的问题可以参考它 stackoverflow.
Google的官方github上也有该问题的详细描述， 链接在此.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80f92211c1c66358b0e0b84ac5b4d47/" rel="bookmark">
			跟 React 学设计模式：掌握编程“套路”，打造高质量应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟 React 学设计模式：掌握编程“套路”，打造高质量应用 与性能优化的视角相似，当我们谈论 React 设计模式时，实际上是在谈论“React 组件的设计模式”。在 React 设计模式中，最重要、也是最为大家所津津乐道的几个模式分别是：
高阶组件（HOC）Render Props剥离有状态组件与无状态组件 这些形态各异的 React 设计模式虽然实现思路有所不同，但本质上基本都是为了实现这样一个终极目标——以尽可能优雅的姿态，实现组件逻辑的复用。
本篇学习目标如下：
每一种设计模式到底是什么、怎么用给弄清楚。对“单一职责”和“开放封闭”这两个非常重要的设计原则有所认知思考这样一个问题：设计模式是否是万能的？对框架来说，还有没有更加深刻、彻底的解法呢？ 高阶组件（HOC）：最经典的组件逻辑复用方式 什么是高阶组件 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。——React 官方
高阶组件（Higher Order Components）在概念上沿袭了高阶函数（Higher-Order Function）。这里再复习一下高阶函数的概念：接收函数作为输入，或者输出另一个函数的一类函数，就是高阶函数。
相应的，高阶组件指的就是参数为组件，返回值为新组件的函数。没错，高阶组件本质上是一个函数。下面是一个简单的高阶组件示例：
const withProps = (WrappedComponent) =&gt; { const targetComponent = (props) =&gt; ( &lt;div className="wrapper-container"&gt; &lt;WrappedComponent {...props} /&gt; &lt;/div&gt; ); return targetComponent; }; 在这段代码中，withProps就是一个高阶组件。
高阶组件是如何实现逻辑复用的？ 现在我们考虑这样一种情况：我有一个名为 checkUserAccess的方法，这个方法专门用来校验用户的身份是否合法，若不合法，那么一部分组件就要根据这个不合法的身份调整自身的展示逻辑（比如查看个人信息界面需要提示“请校验身份”等）。
假如说页面中的 A、B、C、D、E 五个组件都需要甄别用户身份是否合法，那么这五个组件在理论上都需要先请求一遍 checkUserAccess这个接口。但一个一个对组件进行修改未免太麻烦了，我们期望对“获取 checkUserAccess接口信息，并通知到对应组件”这层逻辑进行复用，这时候就可以请出高阶组件来帮忙了。
我们可以像下面代码这样在高阶组件中定义这层通用的逻辑：
// 假设 checkUserAccess 已经在 utils 文件中被封装为了一段独立的逻辑 import checkUserAccess from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c80f92211c1c66358b0e0b84ac5b4d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72311381cad940e6db8b0cd416fa0d17/" rel="bookmark">
			Java实现office(word,excel,ppt)文档在线预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要实现word或者其他office文件的在线预览，大部分都是用的两种方式，一种是使用openoffice转换之后再通过其他插件预览，还有一种方式就是通过POI读取内容然后预览。
一、使用openoffice方式实现word预览 主要思路是：
1.通过第三方工具openoffice，将word、excel、ppt、txt等文件转换为pdf文件
2.通过swfTools将pdf文件转换成swf格式的文件
3.通过FlexPaper文档组件在页面上进行展示
我使用的工具版本：
openof：3.4.1
swfTools：1007
FlexPaper：这个关系不大，我随便下的一个。推荐使用1.5.1
JODConverter：需要jar包，如果是maven管理直接引用就可以
操作步骤：
1.office准备
下载openoffice：
Apache OpenOffice - Official Download
从过往文件，其他语言中找到中文版3.4.1的版本
下载后，解压缩，安装
然后找到安装目录下的program 文件夹
在目录下运行
soffice -headless -accept="socket,host=127.0.0.1,port=8100;urp;" -nofirststartwizard 如果运行失败，可能会有提示，那就加上 .\ 在运行试一下
扫VX 领Java资料，前端，测试，python等等资料都有
这样openoffice的服务就开启了。
将flexpaper文件中的js文件夹(包含了flexpaper_flash_debug.js，flexpaper_flash.js,jquery.js,这三个js文件主要是预览swf文件的插件)拷贝至网站根目录;将FlexPaperViewer.swf拷贝至网站根目录下(该文件主要是用在网页中播放swf文件的播放器)
项目结构：
页面代码：
fileUpload.jsp
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;文档在线预览系统&lt;/title&gt; &lt;style&gt; body {margin-top:100px;background:#fff;font-family: Verdana, Tahoma;} a {color:#CE4614;} #msg-box {color: #CE4614; font-size:0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72311381cad940e6db8b0cd416fa0d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d374bf4f2860a29d99796dec32bd885/" rel="bookmark">
			sql 函数 if 和 ifnull
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if函数：
if(a,b,c) if判断，如果a满足条件，返回b，否则返回c
例子：
select sid, count(if(score&gt;=60,sid,null)) from SC group by sid; 运行代码满足及格条件的返回学号sid，不满足条件的返回null
ifnull函数
IFNULL(expression_1,expression_2); 如果expression_1不为NULL，则IFNULL函数返回expression_1; 否则返回expression_2的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b04d7d9851174be62d3d416b889c14/" rel="bookmark">
			在Ubuntu系统下安装Gitlab，搭建实验室自己的代码托管平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu系统下安装Gitlab，搭建实验室自己的代码托管平台 一、安装Docker 1.使用管理员用户运行 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
这里配置了镜像源
其他安装方式和操作参考菜鸟教程菜鸟教程
2.创建gitlab文件夹
打开路径 cd /home/用户名
创建文件夹mkir gitlab
可以使用docker -v查看docker版本
二、拉取镜像 搜索Docker官方网址，进入注册页面注册好后，在搜索栏搜索Gitlab，找到星标最多的那个项目
复制拉取代码 docker pull gitlab/gitlab-runner默认应该为最新版本
出现一串长数字和字母即为成功
三、运行Gitlab镜像 $ docker run -d -p 443:443 -p 80:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce # -d：后台运行 # -p：将容器内部端口向外映射 # --name：命名容器名称 # -v：将容器内数据文件夹或者日志、配置等文件夹挂载到宿主机指定目录 运行成功出现一片数字
注：可以在此处配置端口设置，例如不想80被占用，可以在第一个80位置改为8080 例如 -p 80:80
四、配置 按上面的方式，gitlab容器运行没问题，但在gitlab上创建项目的时候，生成项目的URL访问地址是按容器的hostname来生成的，也就是容器的id。作为gitlab服务器，我们需要一个固定的URL访问地址，于是需要配置gitlab.rb
# gitlab.rb文件内容默认全是注释 $ vim /home/gitlab/config/gitlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24b04d7d9851174be62d3d416b889c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ccc4a24b4b24eee139280d82b47cea4/" rel="bookmark">
			【MBP】苹果电脑使用SFTP无法可视化连接服务器的解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上个月底，我翘首期盼已久的搭载M1芯片的MacBookPro终于到手了！😊
上周末，一场突如其来的重感冒席卷了我😭，让我想到了利用新电脑在宿舍学习的解决方案。然而事情远没有想象中的那么顺利，我卡在了无法可视化显示服务器的远程文件夹，在尝试了Transmit、FileZilla等多个软件后。我开始怀疑，问题是否出在我的电脑本身。。。。
Filezilla如图，transmit也显示无法连接 在各种百度×n尝试×n都没有结果后，我发现即使是用电脑自带的终端，都无法运行scp/sftp命令与服务器上的文件建立联系，于是我转而开始解决mac终端无法连接的问题（但与此同时可以用终端的ssh连接服务器进行操作） 运行： sftp -P lvcy@172.16…xxx 报错 ：Received message too long 976887913 Ensure the remote shell produces no output for non-interactive sessions.
未找到解决方法
运行： scp-r lvcy@172.16…xxx:服务器文件路径 本地路径 （尝试把远程文件夹复制到本地）
报错：:: initializing oneAPI environment …
解决方法：我发现这个报错命令和我每次进入服务器的提示行是一样的，而这些提示行是在之前某一次师姐为了让我们可以在服务器上使用CDO而在bashrc文件中添加了命令后出现的，因此我尝试将该命令注释掉并运行之后重新打开服务器，发现终端可以进行文件传输，上述两个软件也都可以可视化显示了。
但是问题是这样我就在服务器上无法使用CDO了。为了解决这一问题，我将该命令重新写入一bash_login文件中，在需要使用CDO时重新source这一文件即可，这样也不会影响Mac连接服务器和服务器上的文件。
toda~⭐ 总结：虽然问题解决了。。但是我还是不知道OneAPI是个什么东东，为啥有它CDO才能用，为啥有它MAC又不能连，已经为什么我同学之前的MAC有它也能连。。总是还是疑惑重重。不过好歹解决啦！
参考网站：https://zhuanlan.zhihu.com/p/429448702 等等等等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046f57111e125af258a84d20252e7ec3/" rel="bookmark">
			关于vueX的五个属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuexdiyi是我们经常使用的组件之间传值的一个vue插件，需要我们进行引入，vuex呢有五个属性，我们下面具体介绍一下五个属性及使用方法。
1.state：他的作用就是声明遍历，存储状态数据，有点类似于Vue里的data都是用来存放数据的
2.getters：是(state)的计算属性，和Vue里的的computed 计算属性是一样的作用
3.mutations：提交更新数据的方法，必须是同步的(如果需要异步使用action)。
4.actions： 他的异步的，很多数据获取的工作，比如调用api接口都在这里完成。
5.modules：模块化vuex可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。
接下来通过代码看清怎么使用vuex
第一步：
需要在vue项目的里创建一个store文件夹然后创建一个js文件引入vue及vuex
接下来还需要我们在main.js里面导入该文件夹
第二步：创建我们的vuex的五个属性
写完具体结构后我们在vue里面调用函数，
同步的话：基本函数我们使用：this.$store.commit('函数名')来调用
异步的话：一般用于接口函数的使用，this.$store.dispatch('函数名')
关于使用的话是还有四个map方法熟练之后再来续写
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a27eaee61fb6514a845f0e2c940ca44/" rel="bookmark">
			layui.table.reload 会携带上次的where 参数解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 table.render({ id: "tableId" , ...... , done: function() { this.where = {} //本次加载完成直接置空where搜素条件!!!!!!! } }); //重载的时候重新携带参数 table.reload('tableId',{ where: data,//表格重载时设置新的搜索参数 }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c85a9ccf96b7af21af8cd8c597f79ea8/" rel="bookmark">
			VS2019 无法解析的外部符号 cublasSgemm_v2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2019 无法解析的外部符号 cublasSgemm_v2问题解决方案 在使用vs2019编译cuda时出现一下错误 1. 首先找到自己的环境配置，看看是否出现问题 win+R输入cmd启动
nvcc -V 之后进入cuda 的默认安装目录，一般时C盘：
cd C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.2\extras\demo_suite 注意不同版本对应的版本号不一样，之后分别执行
deviceQuery.exe bandwidthTest.exe 若上述都返回Result = PASS，则表示CUDA配置成功。 2.查看自己的环境变量是否配置好 一般环境变量在安装时会自动配置，出现以下证明环境变量配置成功。
3.项目配置 一般出现问题时都是项目的配置问题
（1）.目录配置 右键点击项目属性–&gt;属性–&gt;配置属性–&gt;VC++目录–&gt;添加包含目录
$(CUDA_PATH)\include （2）.库目录配置 同样是在项目属性中找到库目录配置，并加入
$(CUDA_PATH)\lib\x64 （3）.配置依赖项 在项目属性中的链接器中的输入里添加依赖项
cublas.lib cublas_device.lib 项目配置的效果图如下： 图中黑体字是配置时需要添加的量，最后就可以正常运行了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6abbca5d91400790d5f00c8e067a0322/" rel="bookmark">
			Ant design vue 的组件禁用属性 disabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		disabled
使组件处于禁用状态，例如，日期组件，下拉菜单和输入框等。
以日期组件为例：
isTime是一个布尔值，isTime=true，表示该组件处于禁用状态，即：
isTime=false，表示该组件处于非禁用状态，即：
注意：isTime=false，表示不禁用，isTime=true，表示禁用。千万别弄混了，我就搞混了，特意写篇博客加深一下记忆。
共勉！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e1256806bd0f5aa85578d51809ede9/" rel="bookmark">
			Type-C接口桌面显示器方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 都到2021年了，不会大家还有不知道type-c接口桌面显示器的吧？那我来普及一下显示器的历史。
最早我们用到的是CRT显示器，采用绿显、单显显像管，不仅大而笨重，而且显示效果并不理想。当时这些显示器都是阴极射线管（CRT）显示器，采用的是孔状荫罩，其显像管断面基本上都是球面的，因此被称作球面显像管，这种显示器的屏幕在水平和垂直方向上都是弯曲的，这种弯曲的屏幕造成了图像失真及反光现象，也使实际的显示面积较小。
接下来我们开始用上了LCD显示器（液晶显示器），无辐射、全平面、无闪烁、无失真、可视面积大、体积重量小、抗干扰能力强。
再来就是LED显示器，它是一种通过控制半导体发光二极管的显示方式，用来显示文字、图形、图像、动画、行情、视频、录像信号等各种信息的显示屏幕。显示效果比LCD好了很多。
显示器的接口也是随着技术在不断进步着，前几年比较熟悉的是VGA接口，VGA接口即电脑采用VGA标准输出数据的专用接口。VGA接口共有15针，分成3排，每排5个孔，显卡上应用最为广泛的接口类型，绝大多数显卡都带有此种接口。当然有些显示器用的是DVI接口。
目前大家比较熟悉应该是HDMI接口，英文全称是“High Definition Multimedia”，中文的意思是高清晰度多媒体接口。HDMI接口可以提供高达5Gbps的数据传输带宽，可以传送无压缩的音频信号及高分辨率视频信号。同时无需在信号传送前进行数/模或者模/数转换，可以保证最高质量的影音信号传送。当然还有DP（DisplayPort）接口，DisplayPort是第一个依赖数据包化数据传输技术的显示通信端口，这种数据包化传输技术可以在以太网、USB和PCI Express等技术中找到。它既可以用于内部显示连接，也可以用于外部的显示连接。
浅谈了其他接口后，终于到了今天的主角，type-c接口显示器，从USB3.2开始，数据协议必须是用type-c接口，视频传输也不例外，而传输速率USB4更是达到了40Gbps，配合DP2.0协议，最高可以输出8K@60Hz HDR的视频。
type-c接口显示器不仅可以从手机，笔电，平板，Switch输出视频投射到显示器上，还可以反向给手机，平板等设备充电，接下来我们详细看看原理。
单USB Type-C接口，同时具有DP/USB扩展和直流供电，桌面式显示器的典型形态，整个显示器通过DC圆头接口输入大功率电源，除了满足本身的功率需求，还可以为通过USB Type-C接口给接入到显示器的手机或者笔记本电脑提供PD快充,最高可达到100W反向输出给接入设备供电，这里面涉及data和power的角色控制，得益于乐得瑞推出的LDR6290，就是专门为这种单USB Type-C接口桌面显示器而设计的专用解决方案。 LDR6290芯片是乐得瑞科技设计的单USB C口的PD3.0协议通信芯片，并且具有USB口升级和Billboard的功能，以及通过VDM协商让智能设备进入Alternate Mode输出DP信号的功能，特别适用于DC供电的台式显示器和转接器方案。
主要框架如下：
上图分别从Date和Power两个方面阐述了LDR6290的主要框架。首先从Date上面来看，通过与LDR6290 CC PIN的协议通讯，USB Type-C接口输入DP信号与Date信号，给到单USB Type-C接口桌面显示器的相关功能模块，实现音视频显示与USB3.0/2.0的功能。
再从Power上面来看，DC接口的22V-32V的电源输入，经过DC-DC芯片，从USB Type-C接口输出5V-9V-12V-15V-20V的电压，当然这个电压输出多少，决定于插入单USB Type-C接口桌面显示器的手机或者显示器跟LDR6290的CC协议通讯，再由LDR6290控制DC-DC芯片的FB产生。
单USB Type-C接口桌面显示器专用解决方案，LDR6290部分电路如下：
PS：此方案适合那些专门做显示器板卡的供应商或者显示器成品组装厂。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20d5d239d0faa9b21421f0714cfe1e3/" rel="bookmark">
			一、opencv详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、opencv详细介绍 文章目录 一、opencv详细介绍1.1 什么是opencv1.2 opencv历史1.3 为什么用OpenCV1.4 opencv的应用场景1、图像分类2、目标检测3、图像分割4、风格迁移5、图像重构6、超分辨率7、图像生成8、人脸识别9、其他 opencv官方资料教程地址： https://opencv.org/
1.1 什么是opencv OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在Linux、Windows、Android和Mac OS操作系统上。 它轻量级而且高效——由一系列 C 函数和C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。
1.2 opencv历史 1999 年，Gary Bradski（加里·布拉德斯基）当时在英特尔任职，怀着通过为计算机视觉和人工智能的从业者提供稳定的基础架构并以此来推动产业发展的美好愿景，他启动了 OpenCV 项目。
OpenCV 库用C语言和 C++ 语言编写，可以在 Windows、Linux、Mac OS X 等系统运行。同时也在积极开发 Python、Java、Matlab 以及其他一些语言的接口，将库导入安卓和 iOS 中为移动设备开发应用。
OpenCV 自项目成立以来获得了来自英特尔和谷歌的大力支持，尤其需要感谢 Itseez，该公司完成了早期开发的大部分工作。此后，Arraiy 团队加入该项目并负责维护始终开源和免费的 OpenCV.org。
Itseez 是俄罗斯的一家视觉公司，专门从事计算机视觉算法。2016 年 5 月，英特尔收购该公司，以“帮助英特尔的用户打造创新型深度学习的 CV 应用，如果自动驾驶、数字安全监控和工业检测”（英特尔物联网总经理 Doug Dacies 如此说）
1.3 为什么用OpenCV 计算机视觉市场巨大而且持续增长，且这方面没有标准API，如今的计算机视觉软件大概有以下三种：
研究代码（慢，不稳定，独立并与其他库不兼容）耗费很高的商业化工具（比如Halcon, MATLAB+Simulink）依赖硬件的一些特别的解决方案（比如视频监控，制造控制系统，医疗设备）这是如今的现状，而标准的API将简化计算机视觉程序和解决方案的开发，OpenCV致力于成为这样的标准API。 OpenCV致力于真实世界的实时应用，通过优化的C代码的编写对其执行速度带来了可观的提升，并且可以通过购买Intel的IPP高性能多媒体函数库（Integrated Performance Primitives）得到更快的处理速度。
IPPICV 加速
如果希望得到更多在英特尔架构上的自动优化，可以购买英特尔的集成性能基元（IPP）库，该库包含了许多算法领域的底层优化程序。在库安装完毕的情况下 OpenCV 在运行的时候会自动调用合适的 IPP 库。
从 OpenCV 3.0 开始，英特尔许可 OpenCV 研发团队和 OpenCV 社区拥有一个免费的 IPP 库的子库（称 IPPICV），该子库默认集成在 OpenCV 中并在运算时发挥效用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20d5d239d0faa9b21421f0714cfe1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47c2a662011e4311c92e36d4613803f/" rel="bookmark">
			k8s、ServiceAccount权限详解、RBAC 详解(基于角色的访问控制)，常用操作指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Service Account应用示例RBAC 详解(基于角色的访问控制)创建一个角色（role）---权限实验二常用操作指令 Service Account应用示例 概念图权限关系
我自己的理解就是，Service Account就是pod的权限
1、创建serviceaccount
[root@kub-k8s-master ~]# kubectl create serviceaccount mysa serviceaccount/mysa created 2、查看mysa
[root@kub-k8s-master ~]# kubectl describe sa mysa Name: mysa Namespace: default Labels: &lt;none&gt; Annotations: &lt;none&gt; Image pull secrets: &lt;none&gt; Mountable secrets: mysa-token-cknwf Tokens: mysa-token-cknwf Events: &lt;none&gt; 3、查看mysa自动创建的secret
[root@kub-k8s-master ~]# kubectl get secret NAME TYPE DATA AGE db-user-pass Opaque 2 11h default-token-6svwp kubernetes.io/service-account-token 3 4d23h mysa-token-cknwf kubernetes.io/service-account-token 3 76s mysecret Opaque 2 11h mysecret-01 Opaque 2 6h58m pass Opaque 1 7h6m user Opaque 1 7h7m 4、使用mysa的sa资源配置pod
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47c2a662011e4311c92e36d4613803f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e607123eb65569960a1b0e49d31325/" rel="bookmark">
			Docker基本操作之联网仓库仓库和本地仓库的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仓库（Repository）是集中存放镜像的地方。
一、Docker Hub Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。
1、注册
你可以在Docker官网 https://cloud.docker.com 免费注册一个 Docker 账号。
2、 登录
注册完成后，我们就可以利用下面的命令进行登录登出
#入用户名及密码来完成在命令行界面登录 Docker Hub docker login #退出登录 docker logout 3、拉取镜像
你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。
#查找镜像 docker search 镜像名 #拉取镜像 docker pull 镜像 4、上传镜像
用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。
以下命令中的 username 请替换为你的 Docker 账号用户名。
#打包镜像 docker tag 镜像 #列出镜像 docker image ls #上传镜像 docker push 文件名 #查看是否上传成功 docker search 文件名 5、自动创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95e607123eb65569960a1b0e49d31325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ca8d3586c4fae0db38b5463df8a043/" rel="bookmark">
			找工作前练手前端项目实战2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章千锋长沙前端培训机构整理了10个前端实战项目，大家可以从当中选择自己想做的项目进行参考学习练手，你也可以从中寻找灵感去做自己的项目。
1、仿小米电商网站：本项目是基于原生JavaScript等前端技术实现的仿小米电商网站。本项目前端代码设计技术栈有（JQuery、scss、Gulp、模块化开发），后台构造技术包括（PHP、MySQL）等后台编程知识。（建议先去学习这些知识点以后，再去入口本项目）。学完掌握的知识点： 完成本项目以后，能够让你熟练的掌握前端搭建网站的所有流程。当然如果你是最近忙于毕设的大学生，该项目也可以作为你的毕业设计，非常具有及时含量，祝你能够拿到优秀毕业生。
2、最新前端毕设项目大合集：如果你是最近忙于毕设的大学生，该项目合集也可以作为你的毕业设计，非常具有及时含量，祝你能够拿到优秀毕业生。
3、仿网易云音乐：课程通俗易懂，手把手从0搭建项目。并且高度还原真实项目，包括：云音乐首页分类、音乐列表页展示、音乐详情页、音乐播放器、推荐音乐、用户留言、音乐搜索、加载骨架屏等实现。
4、React全家桶-新闻发布管理系统：此视频不求开宗立派，只为帮你快速打通React任督二脉，一站式应用React全家桶打造企业级后台系统，无缝对接各大门派需求，让你不入江湖，便知江湖风雨。课程面向的同学是：需要有React开发基础，熟悉React 组件开发，组件通信以及基础路由开发。
5、简书后台管理系统：本项目目标： 理解RESTful API的6个限制和若干最佳实践；掌握Koa2. Postman. MongoDB、JWT等技术 ；运用上述技术搭建简书后台管理系统的API接口 ；掌握云服务器的线.上部署方法。
6、移动端网站布局-打造自己的“手机APP”：随着5G技术的到来,人们的生活方式发生了翻天腹地的改变,同时也让开发者们的脚步逐渐踏入了移动端互联网中.学习完本节课可以让大家领略到如何开发一个专属于您自己的“手机APP”。
7、Web支付开发（支付宝和微信支付）：本项目为web支付开发，讲解了最常用的两钟支付：支付宝支付和微信支付；课程内容：1、前期准备，账号申请2、服务器配置3、微信API对接4、支付宝API对接。 学完本课程可以学会微信支付、和支付宝支付开发。
8、贪吃蛇小游戏：JS 前端模块化的发展历史， 优缺点及应用（IIFE， AMD， CMD， ES6）， 包含一个模块化案例贪吃蛇。
9、Vue实战项目之喵喵电影：全新打造Web前端教程，Vue实战项目之喵喵电影，详细讲解项目演示与开发流程。
10、小程序全栈开发之喵喵交友：微信小程序全栈项目之喵喵交友，包括项目的：前期准备，项目开发，多账号测试，项目发布等多个环节，并手把手一步步带大家搭建自己的小程序项目，内容由浅入深，循序渐进。小程序知识点覆盖95%以上，包括：内置组件、WSS、常见客户端API、服务端API、自定义组件、云开发、云函数、云存储、HTTP API等。功能涉及消息推送、附近人查找、添加好友、获取微信昵称与头像、小程序鉴权、CMS管理系统等。
以上千锋长沙前端培训机构分享的10个前端小项目希望可以给您在前端学习中带来帮助，这些例子都很简单实用，非常适合前端初学者用来练习。大家也可尝试根据项目的目的及提示，自己构建解决方法，提高编程水平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb502bc2c8ae398fb90f2b46dced12cb/" rel="bookmark">
			如何使用fiddler过滤请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用场景二、请求过滤 一、使用场景 背景：
1、未设置过滤条件时，默认捕获所有请求
2、进行测试时，我们一般都是对指定的网站或系统测试，访问的域名基本上不会变
原因：
1、为了提高工作效率，把只需要的请求进行展示，不需要的屏蔽
二、请求过滤 1、查看当前的过滤条件
2、设置启用过滤条件
3、只捕获指定的hosts
4、发送请求时，只展示blog.csdn.net的请求到会话列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d68da11a9f34c52249f0951c915e36c/" rel="bookmark">
			【Blender】UV贴图相关学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Blender中打开UV的方法：打开编辑模式后框选物体再按下A;
（p.sr若是新建一个立体物体，选择带网格的）
功能简介：
1、UV选区同步:
UV工作流：
一、标记缝合边
如何制作UV贴图：
1、首先要给集合做个备份，并且注意重命名；
2、在修改器中添加表面细分修改器，并且把参数都调整为1，使得物体笼子和实际形状比较接近。
3、打开UV
4、寻找物体的缝合边（尽量选择和别的地方接触最多的地方），然后标记缝合边，展开。（可以使用快捷键Alt然后选择鼠标左键点击所选择的线）然后右键标记缝合边。
5、展开UV：首先全选物体（可以用先选中物体然后再按A）然后在用户透视面板工具栏的UV菜单中选择展开。
设置UV着色：
1、进入Layout面板设置UV着色。
2、直接给物体添加棋盘格纹理
需要点击基础色左边的黄色按钮找到棋盘纹理。然后将纹理运用到物体上面去，注意，要打开渲染模式才能看到物体被添加了纹理。
于是出现了这样的结果，我们可以看到这里某些链接并不理想，于是打开
并选择
让我们的物体的连接变得光滑。
这样我们的物体就可以得到一个沿着缝合面给出来的Uv贴图纹理
在缩放处调整比例
然后得到如下的图：
二、拉伸、解封、UV空间：
展开：
点击最左边这个蓝色的可以实时看见我们在用户透视中所选中的UV：
如果想要让我们的棋盘格UV更加整齐一些：
首先选中一条纵向的线标记为缝合线，然后全选物体后UV展开。
拉直UV贴图：
下载插件后操作（如果有必要关掉实时UV视图模式）。
给一些没有网格的物体添加网格：
打开prefence，
下滑到有关于网格制作有关插件，具体选哪个可以参照官方说明：
https://docs.blender.org/manual/zh-hans/2.91/addons/add_mesh/archipack.html
棋盘格纹理的制作：
1、打开工具栏中的shading模式，进入渲染界面：
Shift+A然后找到棋盘格纹理。
关于卷轴的制作
先将一个平面平均分成多段：
然后找出一段曲线：
调整曲线的位置以及曲线的分段数目：
切回原来的模式，将两者绑定
卷起来了！
other：
渲染快捷键的打开：物体模式中shift+z
UV映射快捷键：U（最好关闭输入法）
Ctrl+V点两条边即可将两条线进行缝合.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e1822c09a4c19da3f5c663393dabf40/" rel="bookmark">
			Windows ssh-copy-id : 无法将“ssh-copy-id”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： ssh-copy-id : 无法将“ssh-copy-id”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。
解决办法 在终端先执行以下内容：
function ssh-copy-id([string]$userAtMachine, $args){ $publicKey = "$ENV:USERPROFILE" + "/.ssh/id_rsa.pub" if (!(Test-Path "$publicKey")){ Write-Error "ERROR: failed to open ID file '$publicKey': No such file" } else { &amp; cat "$publicKey" | ssh $args $userAtMachine "umask 077; test -d .ssh || mkdir .ssh ; cat &gt;&gt; .ssh/authorized_keys || exit 1" } } 再执行ssh-copy-id username@ip即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b9e72e556badf1103386cd581f9244/" rel="bookmark">
			ARP攻击与ARP欺骗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.ARP攻击与ARP欺骗的原理和应用
1.1. ARP攻击的原理
1.2ARP 欺骗的原理
2.防御ARP攻击和ARP欺骗并查找攻击主机
2.1预防ARP攻击和ARP欺骗
2.2查找进行ARP攻击或ARP欺骗的主机
1.ARP攻击与ARP欺骗的原理和应用 1.1. ARP攻击的原理 一般情况下，ARP 攻击的主要目的是使网络无法正常通信，它主要包括以下两种行为。
攻击主机制造假的 ARP应答，并发送给局域网中除被攻击主机之外的所有主机。ARP应答中包含被攻击主机的IP地址和虚假的MAC地址。
攻击主机制造假的 ARP应答，并发送给被攻击主机。ARP 应答中包含除被攻击主机之外的所有主机的IP地址和虚假的MAC地址。
只有执行上面ARP攻击行为中的任意一种，就可以使被攻击主机和其他攻击主机无法通信
1.2ARP 欺骗的原理 一般情况下， ARP 欺骗并不会使网络无法正常通信，而是通过冒充网关或其他主机使到达网关或主机的流量通过攻击主机进行转发。攻击主机通过转发流量可以对流量进行控制和查看，从而控制流量或得到机密信息。
ARP欺骗发送ARP应答给局域网中其他主机，其中包含网关的IP地址和进行ARP欺骗的主机MAC地址;并且也发送ARP应答给网关，其中包含局域网中所有主机的IP地址和进行ARP欺骗的主机MAC地址(有的软件只发送ARP应答给局域网中的其他主机，并不发送ARP应答欺骗网关)。当局域网中主机和网关收到ARP应答更新ARP表后，主机和网关之间的流量就需要通过攻击主机进行转发
2.防御ARP攻击和ARP欺骗并查找攻击主机 2.1预防ARP攻击和ARP欺骗 防御ARP攻击和 ARP欺骗最有效的方 法是进行ARP绑定，即分别在主机和网关进行ARP绑定这样ARP表将不会受到虚假的ARP应答信息的影响而出现网络故障。如果网络中的主机较多进行ARP绑定的工作量十分大，并且主机ARP绑定后重启系统就需要重新绑定，所以，可以使用ARP防火墙自动抵御。
注：如果网关是路由器而不是主机，则需要在网关设备上手动绑定AP。这是因为ARP攻击是双向的，只攻击网关就可以导致网络通信瘫痪。
2.2查找进行ARP攻击或ARP欺骗的主机 当网络出现故障时，可通过ARP协议查到有问题主机的MAC地址，但是如果MAC地址没有记录或攻击者使用的是虚假的MAC地址，那么应该如何找到问题主机呢?
在网络出现ARP病毒时，可以知道中病毒主机的MAC地址(MAC 地址可能是虚假的)。经查表没有发现对应的主机，这说明ARP病毒可能伪造了一个虛假的MAC地址。这时要查找出问题主机，就要查看交换机的MAC地址表。
由于交换机学习数据帧中的源MAC地址，因此使用show mac address- -table 命令可查看端口学习到的MAC地址。从MAC地址表中找到问题的MAC地址，从而判断发出此MAC地址数据帧的主机下挂在此端口;再查看下挂交换机的MAC地址表，最终确定一个端口下所有问题的主机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a8646053f594797e47a906a264d765/" rel="bookmark">
			联想小新Pro14老是断网问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
方法一
方法二
小结
前言 双十一购入的电脑，可是近两周一直断网（在网络正常的情况下），看视频堪比看PPT，电脑型号是小新Pro14 2021 R5
方法一 下载最新网卡驱动，这种方法我试过之后，只好了半天。驱动可以找联想管家的人工客服要，也可以在联想库中自行下载。
方法二 通过百度查到的方法没有用，今天又去找了客服，说了以下方法。
1.打开windows PowerShell（管理员）
2.输入命令 netsh winsock reset 回车
3.然后再输入命令 ipconfig /flushdns 回车（/斜杠前 有空格的）
4.重启电脑
小结 目前效果还算可以，希望不要再出现这种情况啦，太恼火了！大家如果遇到这种情况，可以尝试一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f2c2505831306038d841a3f3dd9775/" rel="bookmark">
			Spring报错:Error creating bean with name SqlSessionFactory....not find resource com/dao/StudentDao.xml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习spring过程中执行单元测试时提示报错
下面是报错信息的第一行
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'SqlSessionFactory' defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/dao/StudentDao.xml 第一种情况： 根据上述报错可以看出最表层的错误是在spring配置文件中创建SqlSessionFactory失败
看最后的引起错误的原因是Cause: java.io.IOException: Could not find resource com/dao/StudentDao.xml
是找不到mapper文件，所以想到指定mapper文件的地方，应当是mybatis的主配置文件的中，注意这里的mapper路径应该从target/classes下开始，如果这一步检查没有出错的话，另外考虑是下面这种情况
第二种情况： 一般情况下资源文件（各种xml，properites，xsd文件等）都放在src/main/resources下面，利用maven打包时，maven能把这些资源文件打包到相应的jar或者war里，但是我们为了方便一般都把mapper.xml和dao文件放在一起。
有时候，比如mybatis的mapper.xml文件，我们习惯把它和Mapper.java放一起，都在src/main/java下面，这样利用maven打包时，就需要修改pom.xml文件，来把mapper.xml文件一起打包进jar或者war里了，否则，这些文件不会被打包，maven会认为src/main/java只是java的源代码路径。
所以需要在pom.xml文件build中加入以下代码：
&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resource&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f2c2505831306038d841a3f3dd9775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7cb13e8e6052c4644912d1d3e537f8/" rel="bookmark">
			linux服务器时间不同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装ntpdate，执行以下命令# yum install ntpdate -y
2、手工同步网络时间，执行以下命令，将从time.nist.gov同步时间# ntpdate 0.asia.pool.ntp.org
3、若上面的时间服务器不可用，也可以选择以下服务器同步时间
time.nist.gov
time.nuri.net
0.asia.pool.ntp.org
1.asia.pool.ntp.org
2.asia.pool.ntp.org
3.asia.pool.ntp.org
4、使用crontab计划任务定时更新网络时间，修改crontab文件，在末尾增加* */1 * * * ntpdate 0.asia.pool.ntp.org，每隔1小时同步一次时间。
# vi /etc/crontab#crontab -e / crontab -l 编辑crontab定时任务
5、使用date命令查看当前时间
6、系统时间同步到硬件，防止系统重启后时间呗还原# hwclock --systohc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2780c209f6c3ca99c4e3c4e2481040d1/" rel="bookmark">
			VS2019_C&#43;&#43;_Opencv视觉库配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Visual Studio 2019 OpenCV库配置步骤 ①打开VS，选择创建新项目
②选择空项目，并点击下一步
③设置项目名称，并点击创建
④在属性管理器中选择Debug | x64，然后右键它，选择添加新项目属性。
如果没有属性管理器，就点击视图 → \to →其他窗口 → \to →属性查看器
⑤选择添加新属性表，再选择属性表，然后设置名称以及存放的位置。最后选择添加
注意：可以存放在单独的地方，这里将存储所创建的这个属性，下次再创建一个项目时，就可以直接添加这个创建好的opencv属性表，就不用再配置这个了。如果存放的下次找不到了，你还得重新这样来一遍。我是创建了一个属性表的文件夹，自己创建的属性都在里面，用的时候之间调来用就好了，避免重复设置。opencv库还比较简单，但一些复杂的库，像PCL库，要是每次都重新配置，那。。。
此时，Debug | x64 中多一个OpencvSheet，就是你创建的属性。但此时这个属性中还没有设置库，所以接下来要在这属性中添加opencv库文件。
⑥配置库文件。选在OpencvSheet，右键选择属性
选择VC++ 目录 → \to →包含目录 → \to →点击右边的向下的箭头 → \to →编辑
点击添加新行 → \to →点击右边的三个小点...，添加所安装的opencv库中这两个路径（每个人的路径不一样，在自己安装的opencv中，需要提前安装opencv），最后点击确认。
再点击库目录，选择编辑，添加下面这个Opencv库的路径。
⑦设置依赖项，链接器 → \to →输入 → \to →添加依赖项
添加以下文件名，这个文件名如果opencv的版本不一样，那么会不一样，可以在以下路径寻找
...\OpenCV_C\opencv\build\x64\vc15\lib 这个时候，opencv的属性就设置好了。接下来点击解决方案资源管理器，在源文件中创建一个新的C++文件，试试看。
记得将这里选择 x64
编辑下面代码，运行一下
#include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { Mat src = imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2780c209f6c3ca99c4e3c4e2481040d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d99bbbf16dad528051b63c504746526/" rel="bookmark">
			结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是结构体？
结构体就是类似于名片（一个公司为员工做的统一样式的模板的名片，里面包含名字，职务，电话等，但内容是空的，等员工调用时才输入内容，分配空间）形式的数据结合体，可以把它理解为一种由用户自定义的特殊的复合型的“数据类型”，在这个复合型的数据类型中可以包含多个基本类型，我们可以把它当成一个整体来操作。
总结：结构体是多种类型的数据的集合；
结构体是一种由用户自定义的特殊的复合型的“数据类型”；
结构体类似于用于制作统一样式名片的空白模板，或图纸。
2.结构体的声明：
结构体的声明是一种“数据类型”的声明，并不是定义对象（变量）实体。
struct Student 是结构体Student这个复合型“数据类型”的类型名，其使用方式如同表示 int 。
3.结构体对象的定义及初始化
结构体的声明只是定义了一种数据类型，并没有定义实体对象，并没有为其分配空间；
结构体变量的定义和基本类型变量的定义是一样的 ： 类型名+变量名；
结构体变量可以在定义的同时对成员进行初始化赋值，把各个结构体成员的初始值依次排列在花括号中，并用逗号隔开。例如： struct Student { //声明结构体 Student
char name[12];
char sex[3];
}tony={"Tony","男"}; //定义结构体对象tony并初始化
4.结构体对象成员的访问
结构体变量是由结构体成员变量组成的变量集合体，并且像数组一样存储在连续的内存空间中，因而可以单独访问其中的成员变量；访问结构体成员变量时用“.”，称为句点运算符，具体形式为“对象名.成员名”
在设计一个结构体时，不能给结构体中的成员变量赋值，不会给结构体分配空间，相当于它只是个图纸。举个例子：
struct student //student为结构体名，struct student 是结构体类型名；
{ //属性//数据成员描述；
char s_id[10];
char s_name[10];
char s_sex[8]; int s_age; //不能给age,id,等赋值；
} // 在这里设计的结构体不会开辟空间，
int main()
{
struct student s1; //在这里才给s1开辟空间；
}
比较数组和结构体： 相同：1.都是用花括号初始化；例如：struct student s1={ "007","longgege","man","20"}; a[10]={1,2};
2.初始化时 未初始化的值数组与结构体都一律赋0值；
不同：1.数组名代表的是数组的首地址，而结构体名代表他本身；
2.结构体变量可以相互初始化，例如：struct student s2=s1;（前提条件是两个结构体变量类型相同）,但是数组不能,因为地址不能相互赋值，一个地址不能被改变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d99bbbf16dad528051b63c504746526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf586ff27186f9c453c01ae8dba71a0/" rel="bookmark">
			js实现一个简单的发布订阅模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * 简单发布订阅 * @param {Object}} callback * @returns */ export const Observable = { queue: {}, subscribe: function (event, callback) { if (!this.queue[event]) { this.queue[event] = []; } this.queue[event].push(callback); return () =&gt; { this.queue[event] = null; } }, publish: function (event, options = {}) { (this.queue[event] || []).forEach((callback) =&gt; { callback.call(null, options); }); } } 使用如下：
// 订阅方 this.unSubscriber = Observable.subscribe('swipe',（visible） =&gt; { // 操作代码 console.log(visible); // true }) componentWillUnmount() { // 清空任务队列 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cf586ff27186f9c453c01ae8dba71a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd83c9a5ef2ec1a5270f25e4878f9e54/" rel="bookmark">
			Android Studio中模拟器如何输入中文、将模拟器语言设置为中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（都是在模拟器的设置中操作）
如果你的模拟器语言是英文的话，
那么我们首先找到Settings
找到System
选择Languages &amp; input
点击Languages
点击Add a language添加我们想要的语言（我这里已经有中文了）
在最下面找到简体中文，选择中国
之后我们就会在Languages中看到简体中文一项，长按，待到它可以移动时把它拖到第一个位置
之后我们的模拟器语言就是中文了，并且也能够输入中文了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a5e1616f73498ff2d2dfbfb38a9857/" rel="bookmark">
			div实现编辑器效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;div contenteditable style="outline: none;"&gt; &lt;span style="user-select: all;"&gt; Lorem ipsum dolor sitsafsdfasdfsdfasdf amet consectetur &lt;/span&gt; &lt;p&gt;12ww3&lt;/p&gt; &lt;p&gt;465&lt;/p&gt; &lt;div&gt;divsdfsdf&lt;/div&gt; &lt;/div&gt; 增加contenteditable 属性，标签直接化身textarea标签。不同的是，这里面还可以增加img等标签，还可以设置标签样式。编辑器利器！ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/162/">«</a>
	<span class="pagination__item pagination__item--current">163/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/164/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>