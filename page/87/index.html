<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ae9fc91e55e980c1fe1cd36a79d228/" rel="bookmark">
			ODConv详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODConv的代码https://github.com/OSVAI/ODConv/blob/main/modules/odconv.py
ODConv引入了一种多维注意机制，该机制采用并行策略，可以沿核空间的所有四个维度学习卷积核的不同注意。
当kernel_size（图中k）等于1并且kernel_num（图中k_num）等于1时,ODConv架构图
ODConv的代码，得先看懂Attention这个类
class ODConv2d(nn.Module): def __init__(self, in_planes, out_planes, kernel_size, stride=1, padding=0, dilation=1, groups=1, reduction=0.0625, kernel_num=4): super(ODConv2d, self).__init__() self.in_planes = in_planes self.out_planes = out_planes self.kernel_size = kernel_size self.stride = stride self.padding = padding self.dilation = dilation self.groups = groups self.kernel_num = kernel_num self.attention = Attention(in_planes, out_planes, kernel_size, groups=groups, reduction=reduction, kernel_num=kernel_num) self.weight = nn.Parameter(torch.randn(kernel_num, out_planes, in_planes//groups, kernel_size, kernel_size), requires_grad=True) self._initialize_weights() if self.kernel_size == 1 and self.kernel_num == 1: self._forward_impl = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4ae9fc91e55e980c1fe1cd36a79d228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb888e056b33c6a1a33d995162584d28/" rel="bookmark">
			ImportError: DLL load failed while importing _ext: 找不到指定的程序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果是安安装MMDetection后出现这种问题，可能是mmcv-full版本不一致造成的，重新装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb9233522ba64d9b1233cb5e8e16532/" rel="bookmark">
			【Microsoft Whiteboard】微软白板 下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去官网下载地址下载软件
下载完毕后点击如下按钮打开：
点击登录
我这里使用电话号码登录：
输入电话号码后四位
输入手机短信验证码
开始使用：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af85d4ed2e0192b9e3a0d0e1353c0008/" rel="bookmark">
			uniapp开发H5接入友盟、数据监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		友盟+，国内领先的开发者服务及数据智能服务商
在App.vue中 &lt;script&gt; export default { onLaunch: function() { console.log('App Launch') }, onShow: function() { console.log('App Show') }, onHide: function() { console.log('App Hide') }, beforeCreate() { (function(w, d, s, q, i) { w[q] = w[q] || []; var f = d.getElementsByTagName(s)[0], j = d.createElement(s); j.async = true; j.id = 'beacon-aplus'; j.src = 'https://d.alicdn.com/alilog/mlog/aplus/' + i + '.js'; f.parentNode.insertBefore(j, f); })(window, document, 'script', 'aplus_queue', '203467608'); //集成应用的appKey aplus_queue.push({ action: 'aplus.setMetaInfo', arguments: ['appKey', 'xxxxxxxx'] }); /************************以下内容为可选配置内容****************************/ //sdk提供手动pv发送机制，启用手动pv(即关闭自动pv)，需设置aplus-waiting=MAN; //注意：由于单页面路由改变时不会刷新页面，无法自动发送pv，所以对于单页应用，强烈建议您关闭自动PV, 手动控制PV事件 aplus_queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af85d4ed2e0192b9e3a0d0e1353c0008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5053711e637bd53b8fbd4b5c7bcf2c/" rel="bookmark">
			工作记录 根据菜单列表生成路由数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 根据菜单列表，生成路由数据
json
{
"code": 0,
"msg": "success",
"data": [
{
"id": 1,
"name": "系统管理",
"url": null,
"openStyle": 0,
"icon": "icon-setting",
"children": [
{
"id": 11,
"name": "菜单管理",
"url": "menu/index",
"openStyle": 0,
"icon": "icon-menu"
},
{
"id": 12,
"name": "用户管理",
"url": "user/index",
"openStyle": 0,
"icon": "icon-user"
},
{
"id": 13,
"name": "机构管理",
"url": "org/index",
"openStyle": 0,
"icon": "icon-cluster"
},
{
"id": 14,
"name": "角色管理",
"url": "role/index",
"openStyle": 0,
"icon": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5053711e637bd53b8fbd4b5c7bcf2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e5fd99aefd78097f07f783c799bfba/" rel="bookmark">
			tabs导航添加及右侧的关闭和打印printJs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tab.js
store状态
import { defineStore } from 'pinia'
import { RouteLocationNormalizedLoaded } from 'vue-router'
export const tabsStore = defineStore('tabsStore', {
state: () =&gt; ({
visitedViews: [] as any[],
cachedViews: [] as any[]
}),
actions: {
addView(view: RouteLocationNormalizedLoaded) {
if (this.visitedViews.some(value =&gt; value.path === view.path)) {
return
}
this.visitedViews.push(
Object.assign({}, view, {
title: view.meta?.title || 'unknown'
})
)
},
addCachedView(view: RouteLocationNormalizedLoaded) {
if (this.cachedViews.includes(view.name)) {
return
}
if (view.meta.cache) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e5fd99aefd78097f07f783c799bfba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3afc9bd902990fa18b6bca014200b1/" rel="bookmark">
			1002：求三个数最大值 C语言七种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1002：求三个数最大值 问题描述：
编写一个程序，输入a、b、c三个值，输出其中最大值。
输入：一行数组，分别为a b c
输出：a b c其中最大的数
样例输入：10 20 30
样例输出：30
提示：C语言程序设计教程（第三版）课后习题1.6
代码：
方法一：假定a为最大值，引入第四个变量，分别与b,c进行比较
#include&lt;stdio.h&gt; int main() { int a, b, c; int max = 0; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); max = a; if (max &lt; b) { max = b; } if (max &lt; c) { max = c; } printf("%d", max); } 方法二：省去第四个变量 直接将变量a作为最大值。 #include&lt;stdio.h&gt; int main() { int a, b, c; scanf("%d %d %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e3afc9bd902990fa18b6bca014200b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3505c2dde047e6137d1bd9e752db087/" rel="bookmark">
			【Python实现】学员管理系统（详细解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、总体要求2、需求分析3、框架设计4、细节设计4.1 程序入口4.2 学员管理类4.2.1 初始化4.2.2 登录认证4.2.3 功能菜单4.2.4 文件操作4.2.5 新增学员4.2.6 删除学员4.2.7 修改学员4.2.8 查找学员4.2.9 显示全部学员4.2.10 学员数据统计4.2.11 清空系统数据 5、总结 1、总体要求 学员信息管理系统
------ 用于管理学员的相关信息，其中，学号为学员的唯一识别信息，不能重复，姓名和其他的信息可以重复。
以下为基本功能要求：
（1）登录认证：要求先通过用户名和密码验证，通过之后才能进入系统进行相应的功能使用，如果可以有管理员和普通用户的区分会更好，不同的用户分配不同的操作权限。
（2）新增学员信息：可以连续增加多个学员信息，增加完成后提示是否继续、保存、退出等。
（3）删除学员信息：先显示学员列表给用户看，然后再删除对应学员，删除完成后提示是否继续、保存、退出等。
（4）修改学员信息：若添加信息时输入错误可进行修改，同样先把学员列表显示出来，再让用户选择相应信息进行修改，修改完成后提示是否继续、保存、退出等。
（5）查找学员信息：根据学员姓名，查询该学员的相关信息。
（6）显示全部学员：直接展示所有学员的全部信息，可以选择按添加时间顺序或者按学号的顺序来显示。
（7）学员统计分析：对所有学员的相关信息进行统计，显示男女性别分布和年龄分布等情况。
（8）文件操作：进行新增、删除和修改操作的时候，可以自动将学员的信息写入文件，进行永久存储，下次使用管理系统的时候，先读取文件里面的信息，然后进行新的操作。
2、需求分析 基本思路
（1）按照以上要求，可以成设计一个学员管理的类，相关的各个功能以类方法的形式来处理实现；
（2）学员管理系统，由若干个学员的信息组成，每个学员的信息包括：学号、姓名、性别、年龄、爱好，可以以字典来存放；
（3）先设置程序入口，并用学员管理类创建一个学员管理的对象，用此对象来调用类的各种方法：首先调用登录认证，验证通过之后再调用主要的逻辑实现方法，在主方法中去调用增、删、改、查等各个功能实现方法；
（4）类的主方法中显示功能菜单，供用户选择操作。每选择一个功能，都会进入新的页面，每次操作完成后返回主页，依旧显示功能菜单，直至用户退出系统。
3、框架设计 # 定义学员管理类 class Student_Manager(object): # 初始化...（可以把各个功能实现需要用到的临时变量在此处创建并初始化） def __init__(self): pass # 登录认证--不同用户实现不同的功能权限 def login_auth(self): pass # 显示功能选项 def login_welcome(self): pass # 主功能页面--前提是通过了登录认证 def main(self): pass # 新增学员信息--可以连续添加多个学员信息 def add_student_data(self) pass # 删除学员信息 def remove_student_data(self): pass # 修改学员信息 def mod_student_data(self): pass # 查找学员信息--根据姓名查找，重名的需要全部显示出来 def srh_student_data(self): pass # 显示全部学员--可选显示顺序 def display_student_data(self): pass # 数据统计--统计男女学员人数、年龄段分布等 def data_statistics(self): pass # 清空系统数据 def clear_student_data(self): pass # 保存数据--将临时变量self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3505c2dde047e6137d1bd9e752db087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71396e390c0965785f40e5429abb805/" rel="bookmark">
			【小程序】手动实现switch开关中带文字效果（开关左右文字相同/不同都可以）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最终效果：
左右文字宽度相同
左右文字宽度不同
左右长度相同 效果：配合wx:show切换
注意：左右长度相同的话可以设置合适的相同的宽度。
html：
&lt;view class="switch"&gt; &lt;view class="switchNums {{ switchChecked == true ? 'currentNum' : '' }}" bindtap="switchChange" data-index="0" &gt;{{ selectOpen[0] }} &lt;/view&gt; &lt;view class="switchNums {{ switchChecked == false ? 'currentNum' : '' }}" bindtap="switchChange" data-index="1" &gt;{{ selectOpen[1] }}&lt;/view &gt; &lt;/view&gt; css：
.switch { display: flex; align-items: center; justify-content: flex-end; width:120px; height: 54rpx; border-radius: 54rpx; background: #f7f7fb; } .switchNums { width: 112rpx; height: 54rpx; line-height: 54rpx; border-radius: 54rpx; text-align: center; color: #C1C1C1; font-size: 28rpx; font-weight: bold; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71396e390c0965785f40e5429abb805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0cbab6114b5258b28164cd0a9deeeb/" rel="bookmark">
			精心总结十三条建议，帮你创建更合适的MySQL索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章讲到使用MySQL的Explain命令可以分析SQL性能瓶颈，优化SQL查询，以及查看是否用到了索引。
我们都知道创建索引可以提高查询效率，但是具体该怎么创建索引？
哪些字段适合创建索引？
哪些字段又不适合创建索引？
本文跟大家一块学习一下如何创建合适数据库索引。
1. MySQL索引的分类 在创建索引之前了解一下MySQL有哪些索引，然后我们才能选择合适的索引。
常见的索引有，普通索引、唯一索引、主键索引、联合索引、全文索引等。
普通索引 普通索引就是最基本的索引，没有任何限制。
可以使用命令创建普通索引：
ALTER TABLE `table_name` ADD INDEX index_name (`column`); 唯一索引 与普通索引不同，唯一索引的列值必须唯一，允许为null。
创建方式是这样的：
ALTER TABLE `table_name` ADD UNIQUE index_name (`column`); 主键索引 主键索引是一种特殊的唯一索引，并且一张表只有一个主键，不允许为null。
创建方式是这样的：
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`); 联合索引 联合索引是同时在多个字段上创建索引，查询效率更高。
创建方式是这样的：
ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`); 全文索引 全文索引主要用来匹配字符串文本中关键字。
当需要字符串中是否包含关键字的时候，我们一般用like，如果是以%开头的时候，则无法用到索引，这时候就可以使用全文索引了。
创建方式是这样的：
ALTER TABLE `table_name` ADD FULLTEXT (`column`); 2. 哪些字段适合创建索引？ 我总结了有以下几条：
2.1 频繁查询的字段适合创建索引 一张表的字段总会有冷热之分，很明显那些频繁使用的字段更适合为它创建索引。
2.2 在where和on条件出现的字段优先创建索引 为什么不是在select后面出现的字段优先创建索引？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0cbab6114b5258b28164cd0a9deeeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67bd3c035a30adeeafc467d7a2f6bf22/" rel="bookmark">
			服务器最全安装、配置、启动HBase集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装、配置、启动HBase集群 前提必须安装JDK、Zookeeper
在 master 节点操作
（1）切换到 /opt 目录下
cd /opt （2）从官网下载相关版本，上传到服务器
（3）解压HBase文件 到当前目录（/opt）下面，使用相对路径或者绝对路径均可，下面的命令使用绝对命令
tar -zxvf hbase-1.3.1-bin.tar.gz -C /opt/ （4）配置环境变量，编辑 /etc/profile 文件，在文件最后添加 HBase 路径
vim /etc/profile 添加内容如下：
export HBASE_HOME=/opt/hbase-1.3.1 export PATH=$HBASE_HOME/bin:$PATH 使配置文件生效
source /etc/profile （5）修改配置文件
切换到 HBase 的配置文件目录下，这里配置文件的目录为/opt/hbase-1.3.1/conf/
cd /opt/hbase-1.3.1/conf/ 在配置HBase时，我们需要修改三个文件，hbase-env.sh、hbase-site.xml、regionservers
①、修改hbase-env.sh文件，在文件里面添加jdk的路径；关闭掉hbase中自带的zookeeper：
vim hbase-env.sh export JAVA_HOME=/opt/jdk1.8.0_111 export HBASE_MANAGES_ZK=false ②、编辑hbase-site.xml文件，这个是HBase的主要配置文件，添加配置信息：
vim hbase-site.xml &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;master,slave1,slave2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.temp.dir&lt;/name&gt; &lt;value&gt;/opt/data/hbase/temp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/data/zookeeper/&lt;/value&gt; &lt;/property&gt; ③、编辑regionservers文件，将里面的localhost删除，并添加slave1和slave2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67bd3c035a30adeeafc467d7a2f6bf22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5497938a536dea66cde71b40125dcc63/" rel="bookmark">
			深度学习模型个人总结（DNN,CNN,RNN,LSTM,GCN,GAN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习模型个人总结（DNN,CNN,RNN,LSTM,GCN,GAN） 深度学习类属于机器学习，机器学习又类属于人工智能，但是机器学习其实算不上我们普遍理解的人工智能，因为它不够“智能”，而深度学习为何越来越火，因为它已经触摸到了“智能”。深度学习最特别最厉害的地方就是能够自己学习特征提取，对于机器来说，可以说真正做到了自动化。本文介绍深度学习中常见模型的基本原理和区别，不作深入探究。
1 神经网络 神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。
神经网络的每个神经元如下
将上图的单个神经元组织在一起，便形成了神经网络，例如下图中的三层神经网络
无论有多少层，神经网络总体来说分为三层：输入层，隐藏层和输出层。输入输出层顾名思义，而隐藏层是输入层和输出层之间众多神经元和链接组成的各个层面。如果有多个隐藏层，则意味着多个激活函数。
2 深度神经网络（DNN） DNN又叫全连接网络，它是一个很广的概念，CNN（卷积神经网络）、RNN（递归神经网络）等都属于其范畴之内。CNN多用于网络结构数据类型的任务，如图像；RNN多用于时间序列类型的任务，如音频、文本（NLP）等。简单的DNN网络如下图
深度神经网络可以经过大量数据的训练之后，对一个未知事物进行预测。后面要介绍的网络原理与此大同小异，这里不再描述。
3 卷积神经网络（CNN） 例如，在识别手写数字或识别字母时，电脑本身时很死板的。假设我们现在需要识别字母x，那么电脑会讲事先存好的字母x的图片与待识别图片进行对比，这里对比是一个像素点一个像素点的对比，这会导致巨大的误差，例如下图
那我们当然不希望如此，这就是CNN要解决的问题。对于CNN来说，它是一块一块地来进行比对。它拿来比对的这个“小块”我们称之为特征。在两幅图中大致相同的位置找到一些粗糙的特征进行匹配，CNN能够更好的看到两幅图的相似性，如下图
这就是卷积神经网络的作用。那么什么是卷积呢？首先看下图，我们可以将一张图片转换成一个矩阵
卷积就是将此像素矩阵依次与一个过滤器（带着一组固定权重的神经元）进行内积，如下图所示
最后再通过池化层进行选择，就是卷积神经网络的基本原理。
4 循环神经网络（RNN） 先看左半边图，如果不看隐藏层中的W，把它忽略，那么这其实就相当于是第二节介绍的深度神经网络的结构。那么从左图中就可以看出RNN呢其实就只是相当于在全连接神经网络的隐藏层增加了一个循环的操作。至于这个循环的操作具体是怎样的呢？单看左图可能有些懵逼，那么现在看上右图。上右图是RNN网络结构按照时间线展开图。
Xt是t时刻的输入，是一个[x0,x1,x2…xn]的向量
U是输入层到隐藏层的权重矩阵
St是t时刻的隐藏层的值
W是上一时刻的隐藏层的值传入到下一时刻的隐藏层时的权重矩阵
V是隐藏层到输出层的权重矩阵
Ot是t时刻RNN网络的输出
RNN可以被看做是同一神经网络的多次复制，每个神经网络模块会把消息传递给下一个。所以，如果我们将这个循环展开：
这就是循环神经网络的基本原理。
5 长短时记忆网络（LSTM） 人类并不是每时每刻都从一片空白的大脑开始他们的思考。在你阅读这篇文章时候，你都是基于自己已经拥有的对先前所见词的理解来推断当前词的真实含义。我们不会将所有的东西都全部丢弃，然后用空白的大脑进行思考。我们的思想拥有持久性。例如，假设你希望对电影中的每个时间点的时间类型进行分类。传统的神经网络应该很难来处理这个问题——使用电影中先前的事件推断后续的事件。这就是LSTM的优势，同时，它们可以学习只保留相关信息来进行预测，并忘记不相关的数据。简单说，因记忆能力有限，记住重要的，忘记无关紧要的。
从结构上来说，LSTM是一种RNN特殊的类型，可以学习长期依赖信息。所以，LSTM和RNN并没有特别大的结构不同，但是它们用了不同的函数来计算隐状态。具体区别呢？
这是RNN的结构：
这是LSTM的结构：
LSTM的关键就是细胞状态，类似于传送带，直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。就能记住相关性，
6 图神经网络（GCN） 在处理图结构的数据时，CNN、RNN效果不好甚至有时候无法解决。注意，这里说的图结构不是图片，我们做图像识别，对象是图片，是一个二维的结构，于是人们发明了CNN这种神奇的模型来提取图片的特征。CNN的核心在于它的kernel，kernel是一个个小窗口，在图片上平移，通过卷积的方式来提取特征。这里的关键在于图片结构上的平移不变性：一个小窗口无论移动到图片的哪一个位置，其内部的结构都是一模一样的，因此CNN可以实现参数共享。这就是CNN的精髓所在。
再回忆一下RNN系列，它的对象是自然语言这样的序列信息，是一个一维的结构，RNN就是专门针对这些序列的结构而设计的，通过各种门的操作，使得序列前后的信息互相影响，从而很好地捕捉序列的特征。
上面讲的图片或者语言，都属于欧式空间的数据，因此才有维度的概念，欧式空间的数据的特点就是结构很规则。但是现实生活中，其实有很多很多不规则的数据结构，典型的就是图结构，或称拓扑结构，如社交网络、化学分子结构、知识图谱等等；即使是语言，实际上其内部也是复杂的树形结构，也是一种图结构；而像图片，在做目标识别的时候，我们关注的实际上只是二维图片上的部分关键点，这些点组成的也是一个图的结构。
图的结构一般来说是十分不规则的，可以认为是无限维的一种数据，所以它没有平移不变性。每一个节点的周围结构可能都是独一无二的，这种结构的数据，就让传统的CNN、RNN瞬间失效。这时GCN出现了，它也是一个神经网络层，它的层与层之间的传播方式是：
A波浪=A+I，I是单位矩阵
D波浪是A波浪的度矩阵（degree matrix），公式为
H是每一层的特征，对于输入层的话，H就是X
σ是非线性激活函数
这个公式不必要去理解，假设我们手头有一批图数据，其中有N个节点（node），每个节点都有自己的特征，我们设这些节点的特征组成一个N×D维的矩阵X，然后各个节点之间的关系也会形成一个N×N维的矩阵A，也称为邻接矩阵（adjacency matrix）。X和A便是我们模型的输入，然后用此模型提取出特征，效果嘎嘎好。
上图是原论文的附图，可以直观的了解GCN的基本原理。它实际上跟CNN的作用一样，就是一个特征提取器，只不过它的对象是图数据。
7 生成对抗网络（GAN） GAN其实是两个网络的组合：生成网络（Generator）负责生成模拟数据；判别网络Discriminator）负责判断输入的数据是真实的还是生成的。生成网络要不断优化自己生成的数据让判别网络判断不出来，判别网络也要优化自己让自己判断得更准确。二者关系形成对抗，因此叫对抗网络。下边图可以直观的感受：
这就是GAN的基本原理。
参考 1 DNN（全连接神经网络）
2 CNN笔记：通俗理解卷积神经网络
3 史上最小白之RNN详解
4 如何从RNN起步，一步一步通俗理解LSTM
5 理解 LSTM 网络
6 最通俗易懂的图神经网络（GCN）原理详解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5497938a536dea66cde71b40125dcc63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12923ff98b985527aaa9d05fd21be85b/" rel="bookmark">
			基于SpringBoot&#43;vue的文件管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述： 该系统基于角色权限的登录，分为管理员和用户。
管理员账号登录后菜单有：文件管理、用户管理、菜单管理、首页管理
普通账号登录后菜单有：文件管理
技术栈： SpringBoot + Spring + SpringSecurity + MyBatis + Maven + MySQL + Vue + ElementUI + ......
代码结构：
代码地址： 劳烦博客三连！！！
关注微信公众号：可乐大数据
回复：springboot文件系统
体验地址： （只提供普通账号，管理员暂时不提供【防止而已修改】）
地址：39.104.133.94:9999
账号：zzz
密码：zzz
仅作技术交流，不做商业用途谢谢。 1. 文件操作 包括：文件编辑、文件删除、文件下载、文件新增、文件模糊查询
2. 文件分类操作 包括文件分类编辑、文件分类删除、文件分类新增。
3. 用户操作 包括用户新增、用户编辑、用户删除
4. 菜单操作 包括菜单编辑、菜单删除、菜单查询
5. 首页风格操作 修改系统名称等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce63b7f41833cc5c254663016527b1ca/" rel="bookmark">
			运维面试，遇到的SQL笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突然一个朋友给我突然给我发了一份建立，他选择还是在职状态，但是没事的时候他就喜欢投投简历，来更了解现在的工资行情，他是一个智能AI运维工程师，周日的时候呢，他接到了一家小企业的面试要求，还是线下，到了之后人事简单问了一些工作方面的问题，然后就给他丢过来了一张关于SQL的题，但是这个题我第一眼一看好简单啊，可以在我做的时候确不如此，废话少说，我们来帮他做一下吧。
查询SQL的方法有很多，大家可以来做一下，如果有更高效的方法欢迎大家评论，如果发现哪里我有写的不对的地方也欢迎大家来纠正
创建原表：
create table user(id int primary key,name varchar(10),age int,sex char(1)); ​ create table salary(userid int, salary int, month int, year int); alter table salary add foreign key(userid) references user(id); ​ ​ insert into user values(1,'zhangsan',27,'n'),(2,'lisi',28,'n'),(3,'wuwang',29,'v'); ​ insert into salary values(1,1000,1,2004),(1,1000,2,2004),(1,2000,3,2004),(2,2000,1,2004),(2,2000,2,2004),(2,2000,3,2004),(3,2000,1,2004),(3,2000,2,2004),(3,2000,3,2004); 1，求2004年一月份工资最低的员工姓名
mysql&gt; select * from user u join salary s on u.id=s.userid and salary = (select min(salary) from salary where year=2004 and month=1) and year=2004 and month=1; +----+----------+------+------+--------+--------+-------+------+ | id | name | age | sex | userid | salary | month | year | +----+----------+------+------+--------+--------+-------+------+ | 1 | zhangsan | 27 | n | 1 | 1000 | 1 | 2004 | +----+----------+------+------+--------+--------+-------+------+ 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce63b7f41833cc5c254663016527b1ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529386bbab8340a553150668a9b03039/" rel="bookmark">
			【单链表解析】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路 单链表，遍历每一个元素，相同就把这个元素删除然后继续往后
采用一个新的指针指向头指针 head 然后向后遍历链表，删除相同元素，不相同就继续遍历这样方便直接顺序输出结果 代码 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ type ListNode struct { Val int Next *ListNode } func deleteDuplicates(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } curr := head for curr != nil &amp;&amp; curr.Next != nil { if curr.Val == curr.Next.Val { curr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/529386bbab8340a553150668a9b03039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878b7645c332ca2ea2648ec8cdfe9988/" rel="bookmark">
			华为od机试题-2023-最新真题-完整题库-两周350分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD机试题库每半年刷新一次，目前已经整理了90道原题，并提供了java、python、C++三种解法，这就是2023年Q2的完整题库了。
华为OD机试2周350分，高效复习策略：
1、牛客网刷基础算法题，每个算法都了解一下，用一周时间：牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网
2、刷Q2季度真题，完整题库一共90+道，用一周时间：
华为OD机试2023年最新题库（JAVA、Python、C++）_华为od机试题_2023面试高手的博客-CSDN博客
这样复习2周之后，我的很多学生都考到了350分以上~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224a27986f77d00ea071b3345e6d4597/" rel="bookmark">
			mmdetection中代码不懂的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. base_dense_head中forward_train函数
outs = self(x)
python - can anyone explain what "out = self(images)" do in below code - Stack Overflow
在您的情况下，__call__方法是在 super class 中实现的nn.Module。由于它是一个神经网络模块，因此需要一个输入占位符。“out”是数据的占位符，它将把模块的输出转发到模型的下一层或模块。
对于nn.Module类实例（以及从类继承的实例），forward 方法就是用作方法的方法__call__。至少在相对于nn.Module类定义的地方
self是rpn_head，因此进的是rpn_head中的forward_single函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61afddb3ed37547001c3e66bc94c5262/" rel="bookmark">
			Javaweb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、javaweb介绍 Web：全球广域网，也叫万维网(www)，浏览器能访问的网站。
Javaweb：用java技术解决web领域的技术栈
二、HTTP协议 （1）概念 HTTP是一种请求/响应式协议，在客户端和服务器建立连接后，客户端就可以向服务器发生HTTP请求，服务器收到后就会做出HTTP响应 （2）HTTP1.0和HTTP1.1 HTTP1.0：客户端和服务器建立一个TCP连接后，每次只能处理一个HTTP请求
HTTP.1.1：在一个TCP连接上可以传送多个HTTP请求和响应
（3）HTTP请求消息 HTTP请求消息即请求数据
当用户在浏览器访问某个URL地址，点击网页的超链接，提交网页的form表单时，浏览器会向服务器发送HTTP请求消息（即请求数据）。服务器收到请求数据后，处理数据后将HTTP响应消息发送给客户端。
最常用的请求方式是GET和POST方式 GET请求方式和POST请求方式的区别
1.GET请求方式没有请求体，请求参数在请求行中，且请求参数会在URL地址栏中显示，不安全
2.POST请求方式有请求体，请求参数在请求体中，安全
3.GET请求参数大小有限制，POST没有
（4）HTTP响应消息 可以看出，HTTP请求头和HTTP响应头的格式相同，格式都是 键:值 对的形式
三、Servlet （1）Servlet简介 Servlet是运行在Web服务器端的java程序，Servlet的运行需要Servlet容器（Tomcat）的支持，Servlet对象主要封装了对http请求的处理。
Servlet其实就是实现了Servlet接口的类。
（2）Servlet快速入门 （3）Servlet的urlPattern配置 通过WebServlet注解的urlpatterns属性：配置Servlet的请求访问路径
访问Servlet的路径是什么就要写什么
目录匹配是带有通配符的访问路径，只要前面确定了路径，后面的通配符可以是任意的
通过扩展名配置访问路径
（4）Servlet的执行流程 （7）Servlet的继承体系 Servlet其实是一个根接口，GenericServlet是现实了Servlet的抽象类，HttpServlet是继承了GenericServlet的实现类。
（6）Servlet接口中的方法 （5）Servlet对象的生命周期和生命周期方法 service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。
（8）HttpServlet类 开发B/S架构的web项目时，都是针对HTTP协议的，所以一般创建的Servlet类都是继承HttpServlet类，然后再重写它的doGet和doPost方法，就可以完成这个Servlet类的编写
GET 请求来自正常请求URL ，或者来自于一个未指定method的HTML 表单，由 doGet() 方法处理。
POST 请求来自一个指定了method为 POST 的 HTML 表单，它由 doPost() 方法处理。
Request(请求) &amp; Response(响应)对象 概述： 在Servlet API中定义了一个HttpServletRequest接口，继承自ServletRequest接口，专门用于封装HTTP请求消息。request（req）对象封装了请求数据，可以用来获取请求消息数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61afddb3ed37547001c3e66bc94c5262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d093ccc7222f9f8896f9550c297bfaff/" rel="bookmark">
			【Unity URP渲染管线下设置灯光数量上限_灯光不显示问题案例分享】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unity URP通用渲染管线中，灯光有数量限制 1.我的这个项目是在URP渲染管线下，我在场景里创建了六个点灯，转动物体的时候，发现灯显示不全，会一闪一闪的出现。 2.在RenderPipelineAsset配置文件中查看灯光数量上限，首先在Edit&lt;Project Setting 3.在Project Setting里选Quality，在Rendering找到UniversalRP Asset 4.选中UniversalRP Asset文件 5.UniversalRP Asset文件找到Lighting&lt;Per Object Limit，设置数量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9825fb556a4c0437d038ae64db5a824/" rel="bookmark">
			Python真就无所不能？居然还能开发APP软件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Python是脚本语言，可以说它是万能的，只有你想不到，没有它做不到！虽然用它来开发app还是显得有点不对路，但用Python开发的app应当是作为编码练习、自娱自乐所用，加上目前这方面的模块还不是特别成熟，bug比较多，总而言之，大家如果真有需求建议使用Java会好一点！
准备工作 利用Python开发app需要用到Python的一个模块–kivy，kivy是一个开源的，跨平台的Python开发框架，用于开发使用创新的应用程序。简而言之，这是一个Python桌面程序开发框架（类似wxpython等模块），强大的是kivy支持linux、mac、windows、android、ios平台，这也是为什么开发app需要用到这个模块。
虽然kivy是跨平台的，但是想要在不同的平台使用Python代码，还需要将Python代码打包成对应平台的可执行程序，好在kivy项目下有个打包工具项目–buildozer，这是官方推荐的打包工具，因为相对比较简单，自动化程度高，其他项目比如：Python-for-android也能起到类似的作用，这里不展开介绍。
搭建kivy开发环境 需要在pc上安装kivy开发环境，这里演示下mac与linux下的安装过程。
install kivy for mac 安装一些依赖包：
brew install pkg-config sdl2 sdl2_image sdl2_ttf sdl2_mixer gstreamer 安装cython以及kivy：
pip install cython==0.25 pip install kivy 如果安装kivy报错，则使用下面的方式安装kivy：
git clone https://github.com/kivy/kivy python setup.py install 安装后测试：
$python Python 2.7.10 (default, Jul 15 2017, 17:16:57) [GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.31)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; &gt;&gt;&gt; import kivy [INFO ] [Logger ] Record log in /Users/didi/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9825fb556a4c0437d038ae64db5a824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7ead3c808a13fcfca6c5844ce87388/" rel="bookmark">
			Jtti：小程序使用webview内嵌h5页面wx.miniProgram.getEnv失效怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小编给大家分享一下小程序使用webview内嵌h5页面wx.miniProgram.getEnv失效怎么解决的相关知识点，内容详细，逻辑清晰，相信大部分人都还太了解这方面的知识，所以分享这篇文章给大家参考一下，希望大家阅读完这篇文章后有所收获，下面我们一起来了解一下吧。
背景 最近接到一个h6需求，和普通的h6不一样，这个h6页面是嵌入到小程序中使用的，需求简单来说就是展示一个跳转按钮，判断如果是小程序环境下就进行跳转到其他小程序页面。
实现思路 核心逻辑其实就是判断小程序环境这一块，我们可以直接使用wxsdk来进行判断小程序环境，由于公司内部已经有这些api的封装，所以实现起来比较简单。
windows.wx实际上就是wxsdk的对象
//判断是否在微信环境 const isWeixin = /MicroMessenger/i.test(navigator.userAgent); // 获取微信运行环境 const getWxEnv = () =&gt; { return new Promise((resolve) =&gt; { let windows: any = window if (!windows.wx) resolve("wechat"); windows.wx.miniProgram.getEnv((res) =&gt; { if (res.miniprogram) { resolve("miniprogram"); } else { resolve("wechat"); } }); }); } // 判断是否在微信小程序环境 const isMiniprogram = async () =&gt; isWeixin &amp;&amp; (await getWxEnv()) === "miniprogram"; 之后使用isMinnipragram变量即可直接判断是否是小程序环境
问题 wx.miniProgram.getEnv失效，无法正确判断是否为小程序环境。
盘查后发现，无法正确拿到windows对象，原因是小程序中使用webview这个标签去嵌套h6页面，原理其实是使用了原生的iframe标签，导致在子页面中真机无法准确获取页面运行环境
解决 竟然我们在该子页面没法精确拿到windows对象，那我们可以去拿父页面的windows对象，代码实现如下
//判断是否在微信环境 const isWeixin = /MicroMessenger/i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7ead3c808a13fcfca6c5844ce87388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff94be7fc269e09a46dd3b1cdc05240/" rel="bookmark">
			最佳实践：Android应用中的网络请求和数据缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最佳实践：Android应用中的网络请求和数据缓存 网络请求在Android应用中的重要性 在现代移动应用中，网络请求扮演着重要的角色，涉及到数据的获取、上传、更新等功能。网络请求在Android应用中具有关键地位，对于提供优秀的用户体验和功能完善的应用而言，良好的网络请求和数据缓存是不可或缺的。
在移动应用中，网络请求是应用与服务器之间进行数据交互的主要方式。通过网络请求，应用可以从服务器获取所需的数据，例如用户信息、图片、音视频等。同时，应用还可以通过网络请求将数据上传到服务器，例如用户提交的表单数据、用户生成的内容等。此外，应用还可以通过网络请求与服务器进行数据更新，以保持应用数据的最新状态。因此，网络请求在现代移动应用中具有非常重要的地位。
良好的网络请求和数据缓存对于应用性能和用户体验至关重要。优秀的网络请求设计可以有效地减少用户等待时间，提高应用的响应速度，从而提升用户体验。合理的数据缓存策略可以减少对服务器的频繁请求，降低服务器压力，提高应用的性能和稳定性。此外，对于一些离线场景或者网络不稳定的情况，良好的数据缓存策略可以保证应用在无网络连接时仍然能够正常运行，提供更好的用户体验。
在现代移动应用中，用户对于应用的性能和体验要求越来越高，因此，良好的网络请求和数据缓存设计是开发高质量Android应用的重要组成部分。在接下来的内容中，我们将介绍如何选择合适的网络请求库、优化网络请求、最佳的数据缓存实践以及错误处理和安全性考虑等方面的最佳实践，帮助开发者构建性能优越、功能完善的Android应用。
选择合适的网络请求库 网络请求库在 Android 开发中扮演着非常重要的角色，能够大大提高应用的性能和开发效率。目前，市场上有许多不同的网络请求库可供选择，包括 Retrofit、Volley、OkHttp、HttpURLConnection 等等。在选择网络请求库时，需要考虑以下因素：
功能和支持的协议：需要选择能够支持所需功能和所用协议的库。
性能和可扩展性：需要选择具有优秀性能和良好可扩展性的库，以确保应用的流畅度和稳定性。
学习成本和社区支持：需要考虑库的学习成本以及是否有足够的社区支持和文档资料。
下面是常用的网络请求库及其优缺点：
Retrofit Retrofit 是一个基于 OkHttp 的 Type-Safe HTTP 客户端，能够轻松地将 REST API 转换为 Java 接口。Retrofit 具有以下优点：
简单易用：Retrofit 的 API 简单易懂，支持多种数据格式的解析和转换。
易于扩展：Retrofit 支持自定义转换器和拦截器，可以方便地扩展其功能。
完整文档：Retrofit 的文档非常完整，包括了各种使用案例和常见问题的解决方案。
Volley
Volley 是 Google 推出的网络请求库，能够快速、方便地执行网络请求，适用于处理较小的数据量。Volley 具有以下优点： 快速响应：Volley 能够快速响应网络请求，适用于快速加载图片和少量数据的请求。
支持缓存：Volley 支持缓存功能，能够帮助减少网络请求的次数，提高应用性能。
简单易用：Volley 的 API 简单易用，适合初学者使用。
OkHttp
OkHttp 是一个高效、可扩展的网络请求库，可以与 Retrofit 配合使用。OkHttp 具有以下优点： 高效稳定：OkHttp 具有良好的性能和稳定性，能够处理大量的网络请求。
支持缓存：OkHttp 支持缓存功能，能够帮助减少网络请求的次数，提高应用性能。
自定义拦截器：OkHttp 支持自定义拦截器，能够方便地扩展其功能。
HttpURLConnection
HttpURLConnection 是 Android 自带的网络请求库，能够执行 HTTP 请求和处理服务器响应。HttpURLConnection 具有以下优点： 简单易用：HttpURLConnection 的 API 简单易懂，适合初学者使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff94be7fc269e09a46dd3b1cdc05240/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a30452a32656a55030e1eaa23d3170c/" rel="bookmark">
			10.网桥是什么？网桥和路由器及交换机的区别？以太网和令牌环网，nat，查公网ip等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网桥是什么？有什么作用？ 网桥是一种网络设备，它可以在数据链路层（第二层）上连接不同的局域网（LAN），并根据MAC地址转发数据帧。网桥的作用是：
隔离碰撞域，提高网络性能和稳定性。扩展网络范围，连接不同的网段或拓扑结构。进行链路层的协议转换，实现不同类型的LAN之间的互通。 网桥的优点是：
简单易用，不需要复杂的配置和管理。透明性高，对上层协议和应用无影响。价格低廉，成本效益高。 网桥的缺点是：
不能隔离广播域，广播风暴会影响网络效率。不能连接异构网络，如不同的IP网段或子网掩码。不能实现高级的路由功能，如负载均衡或策略路由。 一些使用网桥的场景和示例？ 在同一局域网内，使用网桥可以将一个大的网段划分为多个小的网段，减少碰撞域，提高网络性能和稳定性。例如，如果一个局域网有100台电脑，可以使用一个两端口的网桥将其分为两个50台电脑的网段，每个网段内部的通信不会影响另一个网段，只有跨网段的通信才需要经过网桥转发。在不同类型的局域网之间，使用网桥可以实现链路层的协议转换，使不同类型的LAN之间可以互通。例如，如果一个局域网使用以太网协议，另一个局域网使用令牌环协议，可以使用一个支持这两种协议的网桥将它们连接起来，网桥会根据目的MAC地址转换帧的格式和速率，并进行适当的缓冲和排队。在有线和无线局域网之间，使用网桥可以实现无线接入点（AP）的功能，使无线设备可以访问有线网络。例如，如果一个局域网使用以太网协议，另一个局域网使用无线802.11协议，可以使用一个支持这两种协议的网桥将它们连接起来，网桥会根据目的MAC地址转换帧的格式和速率，并进行适当的加密和认证。 一个网桥连接不同 局域网的例子 一个网桥连接不同局域网的例子是：
在同一个办公楼里，有两个使用不同类型的局域网的部门，比如一个使用以太网，另一个使用令牌环网。为了让这两个部门的员工可以在数据链路层互相通信，可以使用一个支持这两种协议的网桥将它们连接起来，网桥会根据目的MAC地址转换帧的格式和速率，并进行适当的缓冲和排队。在一个家庭里，有一台有线路由器连接到互联网，另外有一台无线路由器提供无线网络服务。为了让无线网络上的设备可以访问互联网，可以使用一个支持有线和无线协议的网桥将两个路由器连接起来，网桥会根据目的MAC地址转换帧的格式和速率，并进行适当的加密和认证。 网桥是如何实现链路层的协议转换，使不同类型的LAN之间可以互通的 网桥是如何实现链路层的协议转换，使不同类型的LAN之间可以互通的：
网桥是一种工作在数据链路层的设备，它可以连接两个或多个使用不同或相同类型的局域网，比如以太网和令牌环网。网桥的主要功能是根据目的MAC地址存储和转发数据帧，从而实现不同局域网之间的通信。网桥还可以进行地址过滤，缓冲，监控等操作，以提高网络性能和安全性。当网桥收到一个数据帧时，它会检查帧的目的MAC地址，如果目的MAC地址属于本地局域网，它就丢弃该帧；如果目的MAC地址属于另一个局域网，它就转发该帧；如果目的MAC地址是广播地址或者未知地址，它就广播该帧。当网桥需要转发一个数据帧时，它可能需要进行链路层协议的转换，以适应不同类型的局域网。比如，如果一个数据帧是从以太网发送到令牌环网，网桥就需要把以太网帧头拆掉，换成令牌环网帧头，并进行适当的速率和格式调整。反之亦然。网桥也可以支持VLAN功能，即在物理上相连的局域网上划分出逻辑上隔离的子网。这样可以增加网络安全性和灵活性。为了实现VLAN功能，网桥需要在数据帧中添加或删除VLAN标签，并根据VLAN标签进行转发或过滤。 既然网桥可以在不同网段里传输数据，这不就和路由器一样了吗 网桥是一种工作在数据链路层的设备，它可以连接两个或多个使用相同或不同类型的局域网，比如以太网和令牌环网。网桥的主要功能是根据目的MAC地址存储和转发数据帧，从而实现不同局域网之间的通信。网桥还可以进行地址过滤，缓冲，监控等操作，以提高网络性能和安全性。网桥通常只有两个端口，如果有多个端口的网桥称为交换机。网桥不隔离广播，也就是说一个局域网上的广播帧会被网桥转发到另一个局域网上。路由器是一种工作在网络层的设备，它可以连接两个或多个使用相同或不同类型的网络，比如IP网络和IPX网络。路由器的主要功能是根据目的IP地址查找路由表，并选择最佳路径转发数据包，从而实现不同网络之间的通信。路由器还可以进行地址转换，分组过滤，负载均衡等操作，以提高网络性能和安全性。路由器通常有多个端口，每个端口可以连接一个不同的网络。路由器可以隔离广播，也就是说一个网络上的广播包不会被路由器转发到另一个网络上。 网桥和交换机的区别 网桥和交换机都是一种工作在数据链路层的设备，它们可以连接两个或多个使用相同或不同类型的局域网，比如以太网和令牌环网。网桥和交换机的主要功能都是根据目的MAC地址存储和转发数据帧，从而实现不同局域网之间的通信。网桥和交换机还可以进行地址过滤，缓冲，监控等操作，以提高网络性能和安全性。网桥和交换机的主要区别在于端口数量和传输速率。网桥通常只有两个端口，而交换机可以有多个端口。网桥只能在两个端口之间建立一个通道，而交换机可以在多个端口之间建立多个通道。这样，交换机可以提供更高的传输速率和更大的带宽利用率。 什么是以太网，什么是令牌环网 要区别在于传输介质、拓扑结构、访问控制方法和传输速率
以太网是一种使用双绞线或同轴电缆的局域网技术，它的拓扑结构是星型或总线型，它的访问控制方法是CSMA/CD（带有冲突检测的载波侦听多路访问），它的传输速率有10Mbps、100Mbps、1000Mbps等多种。令牌环网是一种使用双绞线或光纤的局域网技术，它的拓扑结构是环型，它的访问控制方法是令牌传递（只有持有令牌的站点才能发送数据），它的传输速率有4Mbps和16Mbps两种。 什么是nat NAT是网络地址转换的缩写，它是一种在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。NAT可以节省合法的公有IP地址，避免重新编址，对外隐藏内部地址，增加网络安全性。NAT有多种类型，根据转换的对象和方式，可以分为源NAT，目的NAT，双向NAT等。NAT的工作原理是通过在网关设备上建立转换表，将报文中的IP地址和端口号进行替换和映射。
nat可以把私有地址转成公网ip, 那么收到公网的回复后怎么知道给哪个私有地址呢？ NAT可以通过在网关设备上建立转换表，将报文中的IP地址和端口号进行替换和映射。NAT可以根据不同的转换方式，区分不同的私有地址。例如，NAPT可以利用端口号的唯一性，实现多个私有地址映射到同一个公网IP地址上。NAT Server可以指定公有地址和端口与私有地址和端口的一对一映射关系，将内网服务器映射到公网。
举一个nat的例子 NAT的例子有很多，比如你在家里用手机或电脑连上WiFi，你的设备会从路由器的DHCP服务器获取一个私有IP地址，比如192.168.1.100。但是这个私有IP地址不能直接访问互联网，所以当你用浏览器打开知乎时，路由器会把你的数据包的源IP地址改成它自己的公网IP地址，比如202.244.174.37，然后把数据包发给知乎的服务器。知乎的服务器回复数据包时，路由器再把目的IP地址改回你的私有IP地址，然后转发给你的设备。这样你就可以通过NAT访问互联网了。这是一个端口复用NAPT的例子。
如何查看nat 映射关系？ 查看NAT映射关系的方法可能取决于你使用的NAT设备的类型和配置。一般来说，你可以通过在NAT设备上执行一些命令或查看一些日志来查看NAT映射关系。例如，如果你使用的是华为的NAT设备，你可以执行display nat session命令来查看NAT会话表，其中包含了内外网地址和端口的映射信息。如果你使用的是其他品牌的NAT设备，你可能需要参考相应的文档或手册来了解具体的操作方法。
一个路由器是有一个公网ip对吧，但是有数十台手机连接他，那这10个手机会不会造成网络堵塞 路由器是否只有一个公网IP，取决于你的网络服务提供商（ISP）给你分配的IP地址类型和数量。一般来说，家庭用户或小型企业用户只会分配一个公网IP，而大型企业用户可能会分配多个公网IP。如果你只有一个公网IP，那么你的路由器会使用NAT技术，将内网的多个私有IP地址转换为一个公网IP地址，从而实现内网用户共享外网访问的功能。
网络堵塞的原因可能有很多，比如带宽不足、网络设备故障、恶意攻击等。如果你的路由器连接了多个手机或其他设备，那么这些设备的网络流量会共享你的公网IP的带宽。如果这些设备同时进行大量的网络请求或下载，那么可能会导致网络速度变慢或延迟增加，这就是一种网络堵塞的表现。为了避免或减轻网络堵塞，你可以采取一些措施，比如限制每个设备的流量、优化网络配置、升级网络设备等。
如何查看我有几个公网IP？ 查看你有几个公网IP的方法有以下几种：
你可以登录你的路由器，查看WAN口的IP地址，这个IP地址就是你的公网IP。如果你有多个WAN口，那么你可能有多个公网IP。你可以在浏览器中访问一些IP查询网站，比如ip138.com，ip.qq.com等，它们会显示你当前的公网IP。如果你使用了代理或VPN等服务，那么显示的可能不是你真实的公网IP。你可以在命令行中使用一些工具，比如curl，ping等，来访问一些提供IP信息的网站或服务器，比如sipv4.com，myip.com等，它们会返回你当前的公网IP。同样，如果你使用了代理或VPN等服务，那么返回的可能不是你真实的公网IP。你可以对比你的路由器分配的IP地址和IP查询网站显示的IP地址，如果它们不一致，那么说明你的路由器分配的是内网IP，而IP查询网站显示的是公网IP。如果它们一致，那么说明你的路由器分配的是公网IP。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e74aab173d6cac4f4096748916caad/" rel="bookmark">
			手把手教你SAM(segment anything)官方代码本地调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新一下如何下载官方本地github代码并在本地进行调用，更新的比较晚，截止发布前已经有28.1k的star了。接下来教大家如何分割一切！
首先我们可以下载SAM在官方的代码链接：https://github.com/facebookresearch/segment-anything
下载好之后需要配置一下SAM需要的环境，用pycharm打开配置虚拟环境，基本上还是比较基础的库的，下载安装好即可，如何有不会安装的可以评论或者csdn里面搜一下看看
pip install git+https://github.com/facebookresearch/segment-anything.git 主要给大家介绍讲解一下如何在本地批量用SAM模型进行分割，如果光在demo上一张一张upload效率实在太慢，也不知道在自己数据集上效果如何，可以批量生成然后看看。
首先，我们需要下载官方给的权重pth下载链接，我下的是VIT-H的链接，大家可以直接点该下载链接进行下载，其他权重文件可以在给的readme.md上的链接下载。如果需要国内下载的话也可以评论留言我可以上传到百度网盘大家进行下载。
下载好权重文件之后，我们就开始配置并调用SAM，主要的文件其实就在amg.py上面进行配置运行即可，其他文件大家有兴趣的可以仔细阅读一下了解了解。
我们下好相应的权重文件后，记得在amg.py的文件里也配置好相应的配置文件，下面我把我在本地运行成功的配置数据和相应结果放在下面，大家可以参考一下。
主要我们就需要一个input文件，放入我们需要分割的文件路径，最好是jpg,png格式的，可以看官方支持什么格式，还有一个output文件路径，放入我们结果生成的文件。model-type就是刚才说的权重文件的类型，我下的是vit-h所以选的是这个，大家下的什么类型填什么类型即可。checkpoint就是权重文件路径，刚才下载的文件，把路径放进去即可。
parser.add_argument( "--input", type=str, required=False, default=r'D:\DATA\AllData\QAdata\JPEGImages', help="Path to either a single input image or folder of images.", ) parser.add_argument( "--output", type=str, required=False, default=r'D:\DATA\AllData\QAdata\JPEGImages\result', help=( "Path to the directory where masks will be output. Output will be either a folder " "of PNGs per image or a single json with COCO-style masks." ), ) parser.add_argument( "--model-type", type=str, required=False, default='vit_h', help="The type of model to load, in ['default', 'vit_h', 'vit_l', 'vit_b']"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e74aab173d6cac4f4096748916caad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa509be81a27c6b7e9fbb8d939140eec/" rel="bookmark">
			机器学习数据集哪家强？Sklearn预制的这16个数据集不容错过~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据是机器学习算法的动力，scikit-learn货sklearn提供了一些高质量的数据集。Scikit-learn（sklearn）是一个建立在SciPy之上的Python机器学习包。其独特之处在于其拥有大量的算法、十分易用以及能够与其他Python库进行整合。
什么是 "Sklearn数据集"？ Sklearn数据集作为scikit-learn（sklearn）库的一部分，是预先安装在库中的。我们可以轻松地访问和加载这些数据集，不需要单独下载它们。
要使用这些其中一个特定的数据集，可以简单地从sklearn.datasets模块中导入，并调用适当的函数将数据加载到程序中。
这些数据集通常都是经过预处理的，可以随时使用，这对于需要试验不同机器学习模型和算法的数据科学家来说，可以节省大量时间和精力。
1. Iris 这个数据集包括150朵鸢尾花的萼片长度、萼片宽度、花瓣长度和花瓣宽度的测量值，这些花属于三个不同的物种：Setosa、versicolor和virginica。鸢尾花数据集有150行和5列，以dataframe的形式存储。
Sepal.Length - 表示萼片的长度，单位是厘米。Sepal.Width - 萼片的宽度，单位是厘米。Petal.Length - 表示花瓣的长度（厘米）。Species - 代表鸢尾花的种类，有三个可能的值：setosa、versicolor和virginica。 可以使用sklearn.datasets模块的load_iris函数直接从sklearn加载鸢尾花数据集。
# To install sklearn pip install scikit-learn # To import sklearn from sklearn.datasets import load_iris # Load the iris dataset iris = load_iris() # Print the dataset description print(iris.describe()) 复制代码 这段使用sklearn加载Iris数据集的代码。 于2023年3月27日从scikit-learn.org/stable/modu… 获取
2. Diabetes 这个sklearn数据集包含了442名糖尿病患者的信息，包括个人数据和临床测量值：
年龄性别身体质量指数(BMI)平均血压六项血清测量（如总胆固醇、低密度脂蛋白（LDL）胆固醇、高密度脂蛋白（HDL）胆固醇）。糖尿病疾病进展的定量测量（HbA1c）。 糖尿病数据集可以使用sklearn.datasets模块的load_diabetes()函数加载。
from sklearn.datasets import load_diabetes # Load the diabetes dataset diabetes = load_diabetes() # Print some information about the dataset print(diabetes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa509be81a27c6b7e9fbb8d939140eec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8896c564fa69feb88d1dd3d97cf1f0ee/" rel="bookmark">
			JS遍历对象，获取key、value的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用for…in let person = { name: '张三', age: '21', } for(let key in person){ if(Object.prototype.hasOwnProperty.call(person, key)){ console.log('key-value',key,person[key]) } } //key-value name 张三 //key-value age 21 为什么使用Object.prototype.hasOwnproperty.call(person, key)而不是person.prototype.hasOwnproperty(key)：
因为hasOwnproperty在js里并不是敏感词，因此可能当前对象有一个属性名叫hasOwnproperty，所以这里直接调原型链上的hasOwnproperty方法
call(person, key)的两个参数，第一个参数是this的指向对象，第二个参数是入参
2. 使用Object.keys() let person = { name: '张三', age: '21', } Object.keys(person).map(key =&gt; { console.log(key) }) //name //age //Object.keys()返回自身的所有可枚举属性的数组:[name,age] //Object.values()返回一个自身的所有可枚举属性值的数组：[张三,21] 3. 使用lodash库的map 平时使用lodash库比较多，最近发现lodash里map的迭代函数第二个参数是可以直接取到key的，原生js的map函数是不支持的。
import _ from 'lodash' let person = { name: '张三', age: '21', } _.map(person, (item, key) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8896c564fa69feb88d1dd3d97cf1f0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9155be20c83e902bdd307ee7025d57/" rel="bookmark">
			PermissionError: [WinError 5] 拒绝访问。: ‘d:\\environment\\anaconda\\envs\\py36\\lib\\site-packages\\num
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 在win10终端cmd中，Anaconda的虚拟环境中，使用pip uninstall进行卸载相关包时，报错如下：
解决办法： 网上大多数帖子都表示，是Anaconda中的python解释器，权限问题。需要找到Anaconda中python解释器
右键属性
点击安全
勾选完全控制
点击应用，然后确定！
但是我这样做了，仍然不行啊！！！ 真正的原因是：你电脑上的其他地方在占用这这个python解释器的权限。 解决办法： 1.关闭你电脑上其他地方，正在使用这个虚拟环境的应用或者窗口，比如：pycharm、jupyter notebook 2.我这里是，还开着jupyter notebook。 3. 把其他地方的这个虚拟环境的应用全部关闭之后 4.然后进行pip uninstall 5.问题就解决了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcef0c8b240230b113fbddc5b29c048/" rel="bookmark">
			NPM Git Yarn 如何设置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NPM Git Yarn 如何设置代理 前言设置方法NPM设置方法查看取消方法 Yarn设置方法查看取消方法 Git设置方法查看取消方法代理某一个域名 前言 由于有时候网络的原因，会导致 npm 、git 、yarn 下载遇到各种各样的问题。而且我们正好会使用科学上网方法。那么我们就可以为 npm 、git 、yarn 设置代理。让它们通过代理的方式的得到更优的下载网络，从而解决疑难杂症。
设置方法 NPM 设置方法 # http http://127.0.0.1:8081 npm config set proxy http://proxy_host:port # https npm config set https-proxy http://proxy_host:port 查看 npm config list 取消方法 npm config delete proxy npm config delete https-proxy Yarn 设置方法 # http yarn config set proxy http://proxy_host:port # https yarn config set https-proxy http://proxy_host:port 查看 yarn config list 取消方法 yarn config delete proxy yarn config delete https-proxy Git 设置方法 http 代理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcef0c8b240230b113fbddc5b29c048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58df9ad0a5e19fa44d4fb3d119269e56/" rel="bookmark">
			2023最新IDEA的下载安装与配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、IDEA的介绍
二、IDEA的下载和安装
1.IDEA的下载
2.IDEA的安装
三、IDEA中的项目结构
1.IDEA项目结构介绍
2.层级关系
3.小结
四、IDEA中的第一个项目
一、IDEA的介绍 IDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。
集成环境：把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。
二、IDEA的下载和安装 1.IDEA的下载 官网地址：https://www.jetbrains.com/idea/download/#section=windows
IDEA 分为两个版本：旗舰版(Ultimate)和社区版(Community)，自行选择即可。
2.IDEA的安装 ​
点击Download进行下载，下载完成后打开安装程序
​
Next下一步
​
选择自己的安装路径，然后Next下一步
​
按照自己需求更改配置后Next
​
快捷方式，直接Install等待安装完成
三、IDEA中的项目结构 1.IDEA项目结构介绍 project（项目、工程）
module（模块）
package（包）
class（类）
2.层级关系 project—module—package—class
3.小结 project中可以创建多个module
module中可以创建多个package
package中可以创建多个class
这些结构的划分，是为了方便管理类文件的。
四、IDEA中的第一个项目 创建project项目
​
选择New Project创建项目
​
设置项目名称、位置，然后创建 ​
创建成功
​
新建Module（File—New—Module） ​
设置模块名、模块位置，然后创建
​
创建成功 ​
运行项目 ​
成功打印Hello world! IDEA中第一个代码成功. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991eec1316887a4bf63cc93a68b253fc/" rel="bookmark">
			使用 crypto 模块进行加密和解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crypto 1 哈希算法 hash2 对称加密 AES crypto模块的主要功能有 哈希算法、对称加密以及非对称加密。 1 哈希算法 hash hash 通常给数据签名，它是一种不可逆的加密算法。
常用的 hash 算法有 md5、sha1、sha256、sha512等等。
MD5 是这一种常用的哈希算法，具有长度固定（输出总是16个字节）。
// 引入 crypto const crypto = require('crypto'); // 使用 crypto.createHash 创建哈希算法，传入一个参数为算法类型，如 mad5、sha1、sha256等 const hash = crypto.createHash('md5'); // 可任意多次调用 update() 进行计算 hash.update('swim'); hash.update('swimming'); // 转换完的结果 // 'hex' 按照 16进制的数字存储 console.log(hash.digest('hex')); // b41dd3655615d7d830e1884ed477e7a5 // 'base64 按照 base64 的格式来展示 // console.log(hash.digest('base64')); // tB3TZVYV19gw4YhO1HfnpQ== Hmac 算法也是一种哈希算法，它可以利用 MD5 或 SHA1 等哈希算法。
不同的是，Hmac 还需要一个秘钥：只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，因此 Hmac 算法是一种增强的哈希算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991eec1316887a4bf63cc93a68b253fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ea8c4c01c5483df4b46d39bfb3617d/" rel="bookmark">
			vue中动态绑定行内样式style的backgroundImage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近遇到这个问题：在网上找了找
比如我有很多张图片，想v-for时在每一个div上添加一个随机的背景图片，实现如下效果：
有两点需要注意：
一是文件路径不能直接使用，而要使用require
二是去拼接“url(文件路径)”，还需要注意要对style进行数据绑定
&lt;div v-for="item in items" :key="item.id" :style="{backgroundImage:'url('+bgimgs[random()].img+')'}"&gt; &lt;/div&gt; data(){ return { //用于随机生成背景图片的文件路径列表 bgimgs:[ {img:require("../assets/imgs/background_imgs/1.png")}, {img:require("../assets/imgs/background_imgs/2.png")}, {img:require("../assets/imgs/background_imgs/3.png")}, {img:require("../assets/imgs/background_imgs/4.png")}, {img:require("../assets/imgs/background_imgs/5.jpg")}, {img:require("../assets/imgs/background_imgs/6.jpg")}, {img:require("../assets/imgs/background_imgs/7.jpg")}, {img:require("../assets/imgs/background_imgs/8.jpg")}, ] } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a3cc0ddad5dbd5867fd4baf70544b6/" rel="bookmark">
			Python学习：构建代理池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在使用爬虫时，高并发的请求很容易造成IP封禁，这个时候就需要用到代理ip访问来进行绕过了。构建代理池这里我用了两种方式：
第一种是github上的一个开源项目 proxy_pool手动编写代码采集（只适合练手，推荐第一种） 一丶proxy_pool 安装步骤
1.下载 ​git clone https://github.com/jhao104/proxy_pool.git 2.下载依赖库 pip install -r requirements.txt 3.配置环境 安装redis，这里我直接用小皮面板安装了 设置redis密码
配置setting.py文件 代理采集以及使用 python proxyPool.py schedule # 采集可用代理ip 开启web服务
python proxyPool.py server 完成后可访问ip:端口/get单条代理ip，ip:端口/all所有可用代理ip
二丶手动采集 1.所用到的库requests,threadpool,bs4,random,json,time(以防请求过快导致ip封禁) 2.定义一个随机请求头部函数，伪装还是必须得要的啦 def req_headers(): ua_list = [ 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71', 'Mozilla/5.0 (Windows NT 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a3cc0ddad5dbd5867fd4baf70544b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4abb018b8895fdb6b6792bccdfe2cc9/" rel="bookmark">
			[GDOUCTF 2023] 部分web题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
hate eat snake
EZ WEB
受不了一点
泄露的伪装
hate eat snake 打开页面，是一个贪吃蛇游戏
打了两把结束后点取消发现卡在下一次隔40s开始按空格键就可以得到flag（也可以找js文件更改score的运算或者speed等）
EZ WEB 参考知识：(1条消息) PUT和POST方法的区别-比较POST和PUT方法_zhangpaopao0609的博客-CSDN博客
打开环境，看看源代码，发现有一个注释
访问看看，是一个flask的模板，要求是PUT方式下访问/super-secret-route-nobody-will-guess，可以def flag():
BP抓包改一下即可
受不了一点 bypass类型的题目，第一层，数组绕过即可，后面md5因为无法解析数组内容，然后会读入一个字符串array，然后两个参数md5值就相等了
第二层cookie方式传入cookie=j0k3r
第三层GET方式传入aaa和bbb参数，且值都为114514，但是不相等，这里的弱比较可以用114514a来绕过，解析后仍为114514。这个是字符串的弱比较，因为== 在进行比较的时候，会先将字符串类型转化成相同，再比较
最后一层可以get方式变量覆盖进行flag的传入， a=flag&amp;flag=a
&lt;ez_ze&gt; 参考和知识的博客：
PayloadsAllTheThings/Server Side Template Injection at master · swisskyrepo/PayloadsAllTheThings (github.com)
Marven11/Fenjing: 一个类似SQLMap的Jinja2 SSTI利用脚本 | A SQLMap-like Jinja2 SSTI cracker (github.com)
(2条消息) GDOUCTF_YAy17的博客-CSDN博客
抓包看看数据怎么传的
并且传入{{}}，发现被过滤，猜测是ssti注入，手注可以参考第三篇师傅写的，我手注也是看师傅们的payload，太强了
在群里聊天后新见识了一个工具，fenjing就可以一把梭
- scan: 扫描整个网站 - crack: 对某个特定的表单进行攻击 Usage: python -m fenjing scan [OPTIONS] Options: --url TEXT 需要扫描的URL --exec-cmd TEXT 成功后执行的shell指令，不填则进入交互模式 --help Show this message and exit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4abb018b8895fdb6b6792bccdfe2cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d33d1df1e936d0b74d42eec18383518/" rel="bookmark">
			在sql中通过特定字符截取String类型的中间值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql自带的substring可以截取固定位置的字符串，也可以截取固定长度的字符串。当遇到要截取两个特殊字符之间的字符串的时候就需要用到SUBSTRING_INDEX(str,delim,count)。
string：用于截取目标字符串的字符串。可为字段，表达式等。
delim：分隔符，string存在且用于分割的字符，比如“，”、“.”等。
count：序号，为非0整数。若为整数则表示从左到右数，若为负数则从右到左数。比如“www.mysql.com”截取字符‘www’，分割符为“.”，从左到右序号为1，即substring_index("www.mysql.com",'.',1)；若从右开始获取“com”则为序号为-1即substring_index("www.mysql.com",'.',-1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47f92ed0eed60f35487cbdd7b9e33c2/" rel="bookmark">
			ubuntu 安装vtk-8.2.0问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VTK安装包是在官网下载的，在make编译过程中，遇到这两个问题：
1、error multiple definition of `exodus_unused_symbol_dummy_1`
2、error aggregate ‘QPainterPath path’ has incomplete type and cannot be defined
针对error1的解决方案 1. error1: multiple definition of `exodus_unused_symbol_dummy_1` 需要对安装包里面的2个文件进行修改。
1.1 文件1路径：VTK-8.2.0/ThirdParty/exodusII/vtkexodusII/src/ex_create_par.c
在最后一行，修改如下：
//const char exodus_unused_symbol_dummy_1； 这是原文件中的内容； const char exodus_unused_symbol_dummy_ex_create_par; //修改为这行代码 1.2 文件2路径：VTK-8.2.0/ThirdParty/exodusII/vtkexodusII/src/ex_open_par.c
在最后一行，修改如下：
//const char exodus_unused_symbol_dummy_1; 这是原文件的代码 const char exodus_unused_symbol_dummy_ex_open_par; //修改为这个 1.3 （可选）文件3路径：VTK-8.2.0/ThirdParty/exodusII/update.sh
参考里面提到了需要对此文件中的修改。在文件的第10行：
//readonly tag="for/vtk-20191230-7.24f-v2019-12-18" //这是原代码 readonly tag="for/vtk-20200128-7.24f-v2019-12-18" //修改为这行代码 我只修改了前两个文件，并没有修改第3个文件，重新make编译发现不报error1的错误，但出现了下面error2的错误。
针对error2的解决方案： 2. error2： aggregate ‘QPainterPath path’ has incomplete type and cannot be defined 这个问题解决相对简单，只需要对两个文件修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a47f92ed0eed60f35487cbdd7b9e33c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49154b31b1efa851a6abb59bc005e310/" rel="bookmark">
			C&#43;&#43;：string类的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.简单介绍几种编码1.1 ASCII1.2Unicode码1.3 GBK 2 了解string类3 string的基本使用3.1 构造函数3.2 string的组成3.3 string类的元素访问3.4 三种遍历string的方法3.4.1 下标 + []3.4.2 迭代器3.4.3 范围for 3.5 string类的容量操作3.5.1 max_size3.5.2 容量修改函数 3.6 string类的修改操作3.6.1 插入操作3.6.2 删除操作3.6.3 替换函数3.6.4 交换函数3.6.5 其他操作 3.7 string类的非成员函数 4 vs和g++下string的结构4.1 vs下string的结构4.2 g++下string的结构 1.简单介绍几种编码 在学习string之前，我们先来了解一下各种编码。
1.1 ASCII 关于ASCII码，百度百科给出了这样的解释：
ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符。
ASCII的长度为一个字节，共8个比特位，理论上能够表示256个字符，至于为什么只有128个，是因为：第一位比特位是符号位，为了能够兼顾数字和字符，就不使用第一位，这样就剩下7位可以编码。后来为了加入更多字符，又把第一位用上了，就形成了扩展ASCII。
1.2Unicode码 统一码（Unicode），也叫万国码、单一码，由统一码联盟开发，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。
统一码是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。
其中包括：UTF-8，UTF-16，UTF-32，最常使用的是UTF-8。
1.3 GBK GBK全称《汉字内码扩展规范》（GBK即“国标”、“扩展”汉语拼音的第一个字母，英文名称：Chinese Internal Code Specification） ，中华人民共和国全国信息技术标准化技术委员会1995年12月1日制订，国家技术监督局标准化司、电子工业部科技与质量监督司1995年12月15日联合以技监标函1995 229号文件的形式，将它确定为技术规范指导性文件。2000年已被GB18030-2000《信息交换用 汉字编码字符集 基本集的扩充》国家强制标准替代。 2005年GB18030-2005发布，替代了GB18030-2000。
2 了解string类 字符串是表示字符序列的类标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作 单字节字符字符串的设计特性。string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信 息，请参阅basic_string)。string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits
和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个 类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。 总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49154b31b1efa851a6abb59bc005e310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143f7a722d3973ab81516ed414fd2acc/" rel="bookmark">
			TFill：Bridging Global Context Interactions for High-Fidelity Image Completion论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-CVPR 2022
-提出问题： 正确桥接全局上下文交互对于使用大掩摸完成高保真图像非常重要。以前的方法通过深或大的感受野（RF）卷积来尝试这一点，但无法摆脱附近相互作用的主导地位，这是劣势。
通过堆叠卷积层得到的全局信息，存在限制：
①由于卷积的平移不变性，信息流主要是局部的，全局信息只是通过多层的类热传播逐渐共享。
②在推理阶段，相邻层之家你的元素通过学习但固定的权重来链接，而不是依赖于输入的自适应权重，这就意味着长距离信息只在一个非常深的层中低效传播，导致网络趋向于以孔洞附近的信息为基础填充孔洞，而不是远距离可见像素。
-主要工作
本文提出将图像修复任务视为无方向的序列-序列的预测任务，使用Transformer可以保证去信息平等的流动到各个像素上。主要贡献如下：
①利用限制性的CNN提出图像表征 token representation，减轻了从局部可见区域传播到缺失区域的影响。
②通过一个以transformer为基础的架构，这些token之间的远程交互被显式地建模，其中掩蔽令牌可以感知其他机会平等的可见令牌，而不管它们的位置如何。这导致了对最先进的方法有了显著的改进。
③本文引入了一种具有自适应注意平衡的新型注意意识层，以获得更高质量和分辨率的结果。
-网络结构
（a）首先将mask input失真图像resize固定为256*256大小，然后输入Restrictive CNN生成token，再喂入transformer中进行远距离交互，得到初步的coarse result。
（b）将mask input 与coarse result重新组合，输入到refinement network中，该network中包含Attention-Aware Layer 从可见区域和生成区域传输高质量的信息。
- Method
① Content Inference Network:TFill-Coarse
考虑到固定长度的位置嵌入和计算成本，本文先将图片任何大小的图片resize至256*256.
Restrictive CNN:该模块的主要作用就是提取感受野不重叠的token。
先前的token representation 方式要不就是采用某个像素点会使得下采样的过程中丢失大量的信息，要不就是整张图像，不同的token之间存在重叠。
本文利用Restrictive CNN来进行token representation。这个模块包括四个block，在每一个block中，利用1x1卷积和layernorm来进行非线性映射，然后再用部分卷积（k=2，s=2）来提取可用信息。通过上述做法，保证每个token只代表局部patch中的可见信息。
Weighted self-attention layer：
为了进一步鼓励模型偏向于重要的可见值，作者用weighted self-attention代替了普通的self-attention。即应用一个权重来衡量注意力分数。初始的权重通过计算一个patch中可见像素的比例。然后在每个编码器层后面按照的方式更新权重。 CNN-based Decoder
利用卷积层组成的decoder端对特征进行上采样，以此生成coarse result初步图像。
② Appearance Refinement Network：TFill-Refined
尽管Coarse网络已经生成合理的结果，但还是存在不足。由于固定的input size 256*256，这使得coarse网络不适用于高分辨率图像。且生成的结果可能会和原始的外观不完全一致。如下图所示：左右眼睛异瞳
为了解决上述问题，提出了refinement network。为了进一步利用全局中可见的高频细节，设计了一个注意力感知层AAL来从编码和解码的特征中远程复制信息。
如下图所示，给定一个解码特征xd，首先计算其注意力分数
再以mask为基础将A分为Av（可见区域相似度）和Am（生成区域相似度），然后经过softmax后与编、解码特征相乘
我们使用1×1滤波器γ和α来调节权重的比值。采用Softmax归一化，确保wv+和=1在每个空间位置：
最终，输出z为两个特征的加权：
③损失函数 两个阶段的网络都使用下列的损失函数进行训练：
其中Lpixel为l1 loss,Lper为感知损失，Lgan为生成对抗损失
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d8d377ac83dce14d2164d350129f07/" rel="bookmark">
			js实现下拉框功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #list{ background: #333; display: none; color: #fff; list-style-type: none; margin:0; padding: 0; text-align: center; } #list&gt;li:hover{ width: 100%; background: rgba(102, 102, 235, 0.514); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="width: 200px;"&gt; &lt;input type="text" onfocus="focus1()" value="" id="inp"&gt; &lt;ul id="list" onclick="dian()"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 获取ul let list = document.getElementById('list') // 获取input let inp = document.getElementById('inp') // 获取焦点时ul显示 function focus1(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11d8d377ac83dce14d2164d350129f07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e2d88c925f296720dcbd2778b077ce/" rel="bookmark">
			微信小程序使用webview内嵌h5页面 wx.miniProgram.getEnv失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近接到一个h5需求，和普通的h5不一样，这个h5页面是嵌入到小程序中使用的，需求简单来说就是展示一个跳转按钮，判断如果是小程序环境下就进行跳转到其他小程序页面。
实现思路 核心逻辑其实就是判断小程序环境这一块，我们可以直接使用wxsdk来进行判断小程序环境，由于公司内部已经有这些api的封装，所以实现起来比较简单。
windows.wx实际上就是wxsdk的对象
//判断是否在微信环境 const isWeixin = /MicroMessenger/i.test(navigator.userAgent); // 获取微信运行环境 const getWxEnv = () =&gt; { return new Promise((resolve) =&gt; { let windows: any = window if (!windows.wx) resolve("wechat"); windows.wx.miniProgram.getEnv((res) =&gt; { if (res.miniprogram) { resolve("miniprogram"); } else { resolve("wechat"); } }); }); } // 判断是否在微信小程序环境 const isMiniprogram = async () =&gt; isWeixin &amp;&amp; (await getWxEnv()) === "miniprogram"; 之后使用isMinnipragram变量即可直接判断是否是小程序环境
问题 wx.miniProgram.getEnv失效，无法正确判断是否为小程序环境。
盘查后发现，无法正确拿到windows对象，原因是小程序中使用webview这个标签去嵌套h5页面，原理其实是使用了原生的iframe标签，导致在子页面中真机无法准确获取页面运行环境
解决 竟然我们在该子页面没法精确拿到windows对象，那我们可以去拿父页面的windows对象，代码实现如下
//判断是否在微信环境 const isWeixin = /MicroMessenger/i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e2d88c925f296720dcbd2778b077ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cc606b3218d3fceae1ecc285ad7f0c/" rel="bookmark">
			CRFill：Generative Image Inpainting with Auxiliary Contextual Reconstruction论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- ICCV 2021
- 提出问题：当前inpainting任务中缺乏对缺失区域与已知区域之间对应关系的监督信号，可能无法找到合适的参考特征，这往往会导致结果中的伪影。
-本文主要工作：①提出了一个辅助上下文重建任务（训练CR loss），训练网络学习已知区域和缺失区域之间patch的相似性 - 网络结构
主要工作：
Generative inpainting network生成网络
① 利用PathchGAN discriminatpr 网络生成对抗进行训练，该部分是的损失函数为：
其中D为判别器，G为生成器，U为失真图像，M为mask（1代表invalid，0代表valid）
②coarse to fine generator 由粗到细的生成器
生成器部分与deepfillv2相似，差别就在于移除了CA层，并加入了CRloss。
在coarse阶段，作者希望它能够学习到全局特征，所以只用在coarse阶段只使用了L1 loss。
在refine阶段，为了能使网络学习到更多细节，使用了l1 loss，adversarial loss 和作者提出的CR loss。refine 阶段的损失函数如下：
其中Y代表refine的输出，Lcr代表CR loss。
Contextual reconstruction 上下文重建 基于注意力的inpainting方法需要将patch-borrowing的方式加入生成器当中，但如果选取的区域不对，则会导致图像出现伪影。这些伪影是基于来自参考区域的特征而产生的，因此类似于它们在图像空间中的外观。
基于上述的结论，我们提出了一种CR Loss，通过最小化由已知区域的图像补丁组成的辅助结果的对抗性损失来鼓励网络找到最优参考区域。之前提出的方法都是将patch-borrow（我个人理解为算出注意力之后，根据注意力权重重新组合特征图）直接嵌入到生成器中。CR loss不一样，它是直接通过loss的方式将信息传递给 attention-free没有注意力的生成器。
Contextual reconstruction Loss
CR Loss计算方式如下图所示：
训练系统由一个相似性编码器和一个辅助的encoder-decoder网络组成。
其中相似性编码器的输入为refine network encoder的特征，然后生成区域之间的相似性分数图。辅助编码器解码器网络生成辅助图像，其中已知区域不变，而缺失区域根据相似性编码器提供的相似性填充相似的已知区域。
CRLoss定义为辅助图像的L1 loss和adversarial loss。通过最小化CR loss以此鼓励refine 网络生成器生成与参考区域联系紧密的图像。
相似性编码器的计算如下：
计算patch之间的相似性：
辅助编码器解码器网络生成辅助图像，其中已知区域不变，而缺失区域根据相似性，用已知区域中patch的加权和替换。
再进行解码，得到辅助输出图像
CRLoss定义为辅助图像的L1 loss和adversarial loss。通过最小化CR loss以此鼓励refine 网络生成器生成与参考区域联系紧密的图像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d2eee46ab419acb39e428b0e8c0c09/" rel="bookmark">
			HDFS学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、为什么需要分布式存储二、分布式的基础架构分析1.分布式系统常见的组织形式？2.什么是主从模式？3.Hadoop是哪种模式？ 三、HDFS的基础架构四、HDFS的Shell操作1.进程启停管理1.1一键启停脚本1.2单进程启停 2.文件系统操作命令2.1HDFS文件系统基本信息2.2命令体系2.2.1创建文件夹2.2.2查看指定目录下内容2.2.3上传文件到HDFS指定目录下2.2.4查看HDFS文件内容2.2.5下载HDFS文件2.2.6拷贝HDFS文件2.2.7追加数据到HDFS文件中2.2.8HDFS移动、重命名操作2.2.9HDFS数据删除操作 2.3HDFS WEB浏览 3.HDFS客户端 -Jetbrains产品插件3.1 Big Data Tools插件3.2 配置Windows3.3配置Big Data Tools插件3.4使用Big Data Tools插件 五、HDFS存储原理1.存储原理2.fsck命令2.1HDFS副本块数量的配置2.2fsck命令检查文件的副本数2.3block配置 3.NameNode元数据3.1edits文件3.2.fsimage文件3.3NameNode元数据管理维护3.4元数据合并控制参数3.5SecondaryNameNode的作用 4.HDFS的读写流程4.1数据写入流程4.2数据读取流程 一、为什么需要分布式存储 •数据量太大，单机存储能力有上限，需要靠数量来解决问题
•数量的提升带来的是网络传输、磁盘读写、CPU、内存等各方面的综合提升。 分布式组合在一起可以达到1+1&gt;2的效果
二、分布式的基础架构分析 1.分布式系统常见的组织形式？ •去中心化模式：没有明确中心，大家协调工作（区块链、P2P）
•中心化模式：有明确的中心，基于中心节点分配工作
2.什么是主从模式？ 主从模式（Master-Slaves）就是中心化模式，表示有一个主节点来作为管理者，管理协调下属一批从节点工作。也称一主多从模式。
3.Hadoop是哪种模式？ 主从模式（中心化模式）的架构
三、HDFS的基础架构 主角色：NameNode
•HDFS系统的主角色，是一个独立的进程
•负责管理HDFS整个文件系统
•负责管理DataNode
从角色：DataNode
•HDFS系统的从角色，是一个独立进程
•主要负责数据的存储，即存入数据和取出数据
主角色辅助角色：SecondaryNameNode
•NameNode的辅助，是一个独立进程
•主要帮助NameNode完成元数据整理工作（打杂）
四、HDFS的Shell操作 1.进程启停管理 1.1一键启停脚本 Hadoop HDFS组件内置了HDFS集群的一键启停脚本。
•$HADOOP_HOME/sbin/start-dfs.sh，一键启动HDFS集群
执行原理：
•在执行此脚本的机器上，启动SecondaryNameNode
•读取core-site.xml内容（fs.defaultFS项），确认NameNode所在机器，启动NameNode
•读取workers内容，确认DataNode所在机器，启动全部DataNode
•$HADOOP_HOME/sbin/stop-dfs.sh，一键关闭HDFS集群
执行原理：
•在执行此脚本的机器上，关闭SecondaryNameNode
•读取core-site.xml内容（fs.defaultFS项），确认NameNode所在机器，关闭NameNode
•读取workers内容，确认DataNode所在机器，关闭全部NameNode
1.2单进程启停 除了一键启停外，也可以单独控制进程的启停。
$HADOOP_HOME/sbin/hadoop-daemon.sh，此脚本可以单独控制所在机器的进程的启停 用法：
hadoop-daemon.sh (start|status|stop) (namenode|secondarynamenode|datanode) $HADOOP_HOME/bin/hdfs，此程序也可以用以单独控制所在机器的进程的启停 用法：
hdfs --daemon (start|status|stop) (namenode|secondarynamenode|datanode) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8d2eee46ab419acb39e428b0e8c0c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a8767e05d4400e4fbe708c3a0c1ec6/" rel="bookmark">
			python批量重命名文件吗，00001，不是补零,在前面插入0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os class ImageRename(): def __init__(self): self.path = r'D:\phone_check\images' # 图片存放地址 def rename(self): filelist = os.listdir(self.path) total_num = len(filelist) i = 1 for item in filelist: if item.endswith('.jpg'): # 此处图片为 .png 格式，也可是 .jpg 格式 src = os.path.join(os.path.abspath(self.path), item) if i &lt; 1000: dst = os.path.join(os.path.abspath(self.path), '0' + format(str(i), '0&gt;3s') + '.jpg') #若要改写成 5 位数，将 1000 改为 10000， '0' 改为 '00', 更高位数以此类推 if i &gt;= 1000: dst = os.path.join(os.path.abspath(self.path), format(str(i), '0&gt;3s') + '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03a8767e05d4400e4fbe708c3a0c1ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7875568975089fa476aaa31590d2d9b0/" rel="bookmark">
			【pytorch】实现简单的CNN卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 卷积层 nn.Conv2d()
参数设置
代码示例
二. 池化层 nn.MaxPool1d() 和 nn.MaxPool2d()
参数设置
代码示例
三. 激活函数层 nn.ReLU()
参数设置
四. CNN的简单实现
一. 卷积层 nn.Conv2d() 参数设置 在Pytorch的nn模块中，封装了nn.Conv2d()类作为二维卷积的实现。参数如下图所示
in_channels：输入张量的channels数out_channels：输出张量的channels数kernel_size：卷积核的大小。一般我们会使用3x3这种两个数相同的卷积核，这种情况只需要写kernel_size = 3就行了。如果左右两个数不同，比如3x5，那么写作kernel_size = (3, 5)stride = 1：步长padding：填充图像的上下左右，后面的常数代表填充的多少（行数、列数），默认为0。padding = 1时，若原始图像大小为32x32，则padding后的图像大小为34x34dilation = 1：是否采用空洞卷积，默认为1（即不采用）groups = 1：决定了是否采用分组卷积，默认为1可以参考一下：groups参数的理解bias = True：是否要添加偏置参数作为可学习参数的一个，默认为Truepadding_mode = ‘zeros’：padding的模式，默认采用零填充 前三个参数需要手动提供，后面的都有默认值
代码示例 class Net(nn.Module): def __init__(self): nn.Module.__init__(self) self.conv2d = nn.Conv2d(in_channels=3,out_channels=64,kernel_size=4,stride=2,padding=1) def forward(self, x): print(x.requires_grad) x = self.conv2d(x) return x # 查看卷积层的权重和偏置 print(net.conv2d.weight) print(net.conv2d.bias) 二. 池化层 nn.MaxPool1d() 和 nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7875568975089fa476aaa31590d2d9b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d1a3fd7ecaf7e92822c2ebf81f1dca7/" rel="bookmark">
			Vue服务端渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue服务端渲染 一、服务端渲染基础 1、概述 我们现在可以使用Vue,React等开发SPA单页面应用，单页面应用的优点，用户体验好，开发效率高，可维护性好等。
缺点：首屏渲染时间长（在客户端通过JS来生成html来呈现内容，用户需要等待客户端解析完js才能够看到页面，这样导致首屏渲染时间变长）
不利于SEO.(单页面的html是没有内容的，需要客户端js解析完才能够生成对应的内容，这样的情况不利于搜索引擎抓取对应的页面内容)
为了解决以上问题，需要借助于服务端的渲染来完成。
在服务端返回生成好的HTML页面内容，以及客户端SPAj脚本，这样既有利SEO,解决首屏加载慢的问题，同时有利于用户的体验。
也就是说通过服务端渲染首屏直出，解决SPA应用首屏渲染慢以及不利于SEO的问题，而通过客户端渲染接管页面内容交互得到更好的用户体验。那么这种方式通常称之为现代化的服务端渲染，也叫同构渲染。而这种方式构建的应用称之为服务端渲染应用或者是同构应用。
为了能够更好的掌握服务端渲染的内容，需要了解一些的相关概念:
什么是渲染传统的服务端渲染客户端渲染现代化的服务端渲染(同构渲染) 2、什么是渲染 渲染简单的理解就是将数据与模板拼接到一起。
对我们前端开发人员来说，我们经常访问服务端的接口，获取数据。然后将获取到的数据通过模板绑定的语法绑定到页面中，最终呈现给用户，这个过程就是我们所说的渲染。
{ "message":'hello vue' } &lt;h1&gt; {{message}} &lt;/h1&gt; &lt;h1&gt; hello vue &lt;/h1&gt; 3、传统的服务端渲染 在早期的WEB页面渲染都是在服务端进行的，也就是在服务端已经将数据和模板构建好，生成html，返回给客户端。所以客户端呈现就是包含具体数据内容的页面。
如下图所示：
在上图中最终最重要的就是第四步。
关于这中应用在前面讲解Node的时候，我们已经学习过。
但是这种方式，有如下的不足：
前后端代码完全耦合在一起，不利于开发和维护前端没有足够发挥空间（不利于前后端分离开发）服务端压力大用户体验一般（查看不同的页面，需要刷新浏览器） 4、客户端渲染 在讲解服务端渲染的时候，我们知道了服务端渲染的一些问题，但是随着客户端AJAX技术的普及，得到了有效的解决。
Ajax使得客户端动态获取数据成为可能，也就是在服务端的渲染的工作，现在可以在客户端完成。这样带来的好处就是前后端代码完全分离，服务端提供接口，客户端访问接口获取数据，而且有利于前后端开发人员协同开发，提高开发效率。同时由于可以在客户端渲染，从而减轻了服务端的压力。而且也提高了用户体验，进行页面的切换的时候，不会刷新浏览器。
客户端渲染的流程如下图所示：
注意：在第二步返回的html中没有具体的数据内容。
通过上图，我们可以看到在服务端仅仅是获取了数据，然后将获取到的数据返回给客户端，并不关心页面的渲染。渲染是有客户端完成。
这样就完成了前后端的分离，不仅项目的架构发生了改变，而且开发人员的配置也发生了变化。
也就是前端更为独立，不再受后端的限制。
当然前端渲染也带了了一定的问题，就是前面我们所说的首屏渲染慢以及不利于SEO的问题。
下面我们先来看一下为什么客户端渲染会出现首屏渲染慢的问题。
5、为什么客户端渲染首屏渲染慢？ 所谓的首屏，是我们在浏览器中输入一个地址后，打开的第一个页面，就是首屏。
我们在浏览器的地址栏中输入了地址，向服务器发送请求，服务器返回的是一个空白HTML,没有具体的数据内容，只有js脚本，这时浏览器还会向服务器发送请求获取数据。
而服务端渲染，是在服务端获取数据，然后构建好对应的模板，生成HTML返回到客户端，这样客户端无需再向服务器发送请求。这样通过对比可以看到，客户端渲染需要多次向服务器发送请求，所以导致渲染慢。
6、为什么客户端渲染不利于SEO 什么是SEO,就是搜索引擎优化。
7、同构渲染 通过前面的介绍，我们知道了在客户端渲染中，带来的两个比较显著的问题就是，首屏渲染慢和不利于SEO,那么应该怎样解决这些问题呢？这就需要用到服务端渲染的内容。当然，我们现在提到的服务端渲染与传统的服务端渲染还是有区别的，这里我们称之为现代化的服务端渲染，或者叫做同构渲染。
所谓同构渲染就是后端渲染+前端渲染的模式。这样就集合了前端渲染的优点也集合了服务端渲染的优点。
下面我们具体看一下关于同构渲染的一些具体的介绍：
同构渲染：还是基于React,Vue等框架，实现了客户端渲染和服务端渲染的结合，具体的流程就是，在服务端执行一次框架的代码，用于实现服务端渲染，实现首屏的输出，然后在客户端再执行一次，用于接管页面交互(后期的交互都是客户端渲染)。这样就解决了SEO和首屏渲染慢的问题，拥有传统服务端渲染的优点，也有客户端渲染的优点。
如何实现同构渲染？
第一种方式：使用Vue,React 等框架的官方解决方案：
​ 这种方式的有点：有助于立即原理。
缺点：需要搭建环境，比较麻烦。
第二种方式：就是使用第三方的解决方案
React生态的Next.js
Vue生态的Nuxt.js
8、同构渲染的问题 同构渲染主要如下问题
开发条件有限涉及构建设置和部署的更多要求更多的服务器负载 首先来看一下开发条件有限：
浏览器特定的代码只能在某些生命周期钩子函数中使用（因为代码既要在服务端渲染运行，也要在客户端渲染运行，这时需要对服务端渲染的生命周期与客户端渲染的生命周期做一定的区分）。
第二就是一些外部扩展库可能需要特殊的处理以后才能在服务端渲染应用中运行。
第三：不能在服务端渲染期间操作DOM.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d1a3fd7ecaf7e92822c2ebf81f1dca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac49284388325c2e1c2482d16faf3b1e/" rel="bookmark">
			Git clone github文件时出现超时中断或下载慢的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以更改git的config参数，取消其http和https代理：
git config --global --unset http.proxy git config --global --unset https.proxy 完美解决以上问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1a2a75a96c2c30c88a21a78ad3eddd/" rel="bookmark">
			v2项目引入echarts并渲染数据，以及解决数据渲染不出来的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、npm i下载echarts
2、页面import * as echarts from "echarts";引入
3、页面结构
--html：&lt;div class="echart" id="mychart" :style="myChartStyle"&gt;&lt;/div&gt;
--data定义：
// 后台传给我的页面数据 list: {}, // 图表需要的数据 sex: [], myChart: {}, myChartStyle: { width: "100%", height: "50%" },//图表样式 需要设置宽高 --mounted
this.initEcharts();// 图表数据初始化 -- methods:
调后台接口获取到数据赋值给页面需要的list和push进图表需要的数据sex里；
定义图表、初始化、赋值；
我这里赋值时页面图表数据没有渲染出来，加了个定时器解决
最终页面图表呈现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f71af14940d0a9a725c5b190a76fb43/" rel="bookmark">
			触发pam_tally2模块机制导致登录失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎹 个人简介：大家好，我是 金鱼哥，华为云社区2022年度十佳博主，华为云·云享专家，阿里云社区·专家博主，CSDN运维领域新星创作者
📚个人资质：CCNA、HCNP、CSNA（网络分析师），软考初级、中级网络工程师、RHCSA、RHCE、RHCA、RHCI、ITIL、PMP😜
💬格言：努力不一定成功，但要想成功就必须努力🔥
🎈支持我：可点赞👍、可收藏⭐️、可留言📝
前言：在生产环境中，如果设置了pam_tally2模块限制，则需要了解好其限制的规则情况，也要知道触发规则出现不能登录时应该如何进行处置。本文以两天所遇到的情景而进行分析和讲述，希望对看到本文的小伙伴有所启示。
文章目录 📜触发机制，登录失败📜学习pam_tally2📑pam_tally2配置格式和选项配置格式常用选项配置举例 📜故障处理📜极端情况 💡总结 📜触发机制，登录失败 无独有偶，两天都遇到有厂商工程师由于触发了PAM的限制而导致机器不能登录。而限制用户登录次数设置会几乎在所有生产环境中的机器进行设置，一旦触发，所登录的用户就不能进行登录，直到符合规则上的锁解时间才可以进行登录。
时间点发生在4月10日和4月11日，分别在两台机器出现如下日志提示：
Apr 10 15:30:01 k8s-node3 login: pam_tally2(login:auth): unknown option: no_magic_root Apr 10 15:30:01 k8s-node3 login: pam_tally2(login:auth): user root (0) tally 30, deny 3 Apr 10 15:30:03 k8s-node3 login: pam_succeed_if(login:auth): requirement "uid &gt;= 1000" not met by user "root" Apr 10 15:30:05 k8s-node3 login: FAILED LOGIN 1 FROM tty1 FOR root, Authentication failure Apr 10 15:30:05 k8s-node3 login: pam_tally2(login:auth): unknown option: no_magic_root Apr 10 10:03:44 k8s-master sshd[19896]: pam_tally2(sshd:auth): user root (0) tally 18, deny 3 Apr 10 10:03:44 k8s-master sshd[19896]: pam_succeed_if(sshd:auth): requirement "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f71af14940d0a9a725c5b190a76fb43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df3ad383ba38540d415b935330c04a23/" rel="bookmark">
			高级前端理解的CommonJS模块和ESM模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阮一峰在 ES6 入门 中提到 ES6 模块与 CommonJS 模块有一些重大的差异：
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
大厂技术 高级前端 Node进阶 点击上方 程序员成长指北，关注公众号 回复1，加入高级Node交流群 再细读上面阮老师提到的差异，会产生诸多疑问：
为什么 CommonJS 模块输出的是一个值的拷贝？其具体细节是什么样子的？
什么叫 运行时加载?
什么叫 编译时输出接口？
为什么 ES6 模块输出的是值的引用？
于是就有了这篇文章，力求把 ESM 模块 和 CommonJS 模块 讨论清楚。
CommonJS 产生的历史背景 CommonJS 由 Mozilla 工程师 Kevin Dangoor 于 2009 年 1 月创立，最初命名为ServerJS。2009 年 8 月，该项目更名为CommonJS。旨在解决 Javascript 中缺少模块化标准的问题。
Node.js 后来也采用了 CommonJS 的模块规范。
由于 CommonJS 并不是 ECMAScript 标准的一部分，所以 类似 module 和 require 并不是 JS 的关键字，仅仅是对象或者函数而已，意识到这一点很重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df3ad383ba38540d415b935330c04a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42342e7bd7afd36307ef0262c94ff3ae/" rel="bookmark">
			GDOUCTF web部分题解 2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hate eat snake 前端小游戏，初始页面不能F12和Ctrl+R。可以右键，但是源码界面（右键后）可以F12控制台。
先玩死自己
然后在源码界面输入这个derectkey = 40，这样之后等一会，应该是一分钟。
然后回到主页面，点击空格。
受不了一点 源码：
&lt;?php error_reporting(0); header("Content-type:text/html;charset=utf-8"); if(isset($_POST['gdou'])&amp;&amp;isset($_POST['ctf'])){ $b=$_POST['ctf']; $a=$_POST['gdou']; if($_POST['gdou']!=$_POST['ctf'] &amp;&amp; md5($a)===md5($b)){ if(isset($_COOKIE['cookie'])){ if ($_COOKIE['cookie']=='j0k3r'){ if(isset($_GET['aaa']) &amp;&amp; isset($_GET['bbb'])){ $aaa=$_GET['aaa']; $bbb=$_GET['bbb']; if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb){ $give = 'cancanwordflag'; $get ='hacker!'; if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag'])){ die($give); } if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ die($get); } foreach ($_POST as $key =&gt; $value) { $$key = $value; } foreach ($_GET as $key =&gt; $value) { $$key = $$value; } echo $f1ag; }else{ echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42342e7bd7afd36307ef0262c94ff3ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443a6f6cd1bf377c41070c6c94bdb322/" rel="bookmark">
			vue3项目中使用pinia
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex 4pinia 小菠萝 vuex和之前vue2使用一致
1.import { createStore } from 'vuex' 引入文件不同 vue3组件setup写法vuex提供了hook //组件中操作store import { useStore } from 'vuex' //提交mutations 进行修改 store.commit('increment'), //dispatch 触发action 同步或者异步提交mutations store.dispatch('asyncIncrement') pinia pinia 类似RTK
pinia优化vuex。
官网
https://pinia.vuejs.org/zh/ 中文文档 https://pinia.web3doc.top/ Vue.js 状态管理库
类型安全、可扩展性以及模块化设计。 甚至让你忘记正在使用的是一个状态库。
优点：
简介
Pinia 最初是在 2019 年 11 月左右重新设计使用 Composition API 。从那时起，最初的原则仍然相同，但 Pinia 对 Vue 2 和 Vue 3 都有效，并且不需要您使用组合 API。 除了安装和 SSR 之外，两者的 API 都是相同的，并且这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的注释，以便 Vue 2 和 Vue 3 用户可以阅读！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443a6f6cd1bf377c41070c6c94bdb322/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/86/">«</a>
	<span class="pagination__item pagination__item--current">87/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/88/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>