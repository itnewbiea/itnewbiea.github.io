<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24426ca48930a1c4d7cb3d4c187a63c/" rel="bookmark">
			[SWPUCTF 2022 新生赛]贪吃蛇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：NSSCTF
下载：题目
下载完查壳，无壳拖入IDA。找到主函数查看代码
进入这个函数：
所以可以看出a1-4为得分，而（-4）是因为贪吃蛇的长度初始是4。获得flag要求得分大于60即a1&gt;64。打开CE,把这个题进程加载到CE。
因为刚开始a1=4，所以先对4进行搜索，结果太多，就让贪吃蛇吃个果子。让a1变为5，直到搜到唯一的结果
这时候只有一个结果，把他放入地址栏，修改值大于64后结束游戏就可以获得flag。
flag为
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef350987a1e89a24c94d7162e8b7d41/" rel="bookmark">
			Briefings in Bioinformatics2021 | 药物挖掘分子设计--生成模型综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文标题：Molecular design in drug discovery: a comprehensive review of deep generative models
论文地址：Molecular design in drug discovery: a comprehensive review of deep generative models | Briefings in Bioinformatics | Oxford Academic
基于smiles的模型和基于图的模型的综述。
一、分子表征（SMILES &amp; Graph） SMILES的缺点：(1)不能捕捉分子结构的相似性。两个相似结构之间的微小变化可能会导致SMILES字符串有很大的不同，从生成模型中学习到的潜在空间并不平滑。(2) SMILES字符串是非唯一的，一个分子可以被编码成多个SMILES表示。
数据库：其中ZINC、ChEMBL、PubChem和DrugBank使用最多。
二、Deep molecular generative models 1、SMILES-based Model
基于序列的方法可以进一步分为基于变分编码器(VAE)、生成对抗网络(GANs)和基于循环神经网络(RNNs)的模型。
VAE-based generative models
VAE分子生成的潜在空间是潜在操作的，如控制特定性质，训练过程是稳定的。然而，训练集的重构限制了在未知化学空间中的探索能力。在没有额外约束的情况下，VAE模型产生无效分子的概率很高
【Automatic chemical design using a data-driven continuous representation of molecules】：使用核密度估计来学习捕获分子的相关特征。然后在维度上学习连续的潜在空间，优化分子的特定性质，允许使用强大的基于梯度的方法来有效地指导搜索。加入多层感知器和编码器的联合训练任务，保证了分子性质的预测能力。
【Grammar variational autoencoder】：将SMILES的语法生成规则纳入模型。它表明可以使用上下文无关语法将离散数据直接表示为解析树。解码器通过按顺序学习这些规则来生成有效的输出。考虑到解析树，该模型可以扩展到其他没有上下文的文本表示学习。
【Syntax-directed variational autoencoder for molecule generation】：提出GVAE缺乏语义，生成的环键必须紧密等结构信息。然而，在GVAE中增加额外的结构约束可能会造成不必要的计算和时间浪费。
GANs-based generative models
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef350987a1e89a24c94d7162e8b7d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c4d0fc1672a1e5e66a08d5c7dcbbde/" rel="bookmark">
			多线程——线程同步器CountDownLatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程——线程同步器CountDownLatch （一）CountDownLatch案例入门【1】CountDownLatch和join的区别【2】CountDownLatch案例一：等待线程等待工作线程【3】CountDownLatch案例二：主线程main等待子线程【4】CountDownLatch案例三：线程池主线程等待子线程 （二）CountDownLatch的实现原理和源码分析【1】构造方法【2】await() 源码解析：阻塞线程进入等待队列里自旋【3】countDown() 源码解析：计数器减1【4】如何唤醒所有调用 await() 等待的线程呢？ （三）CountDownLatch的流程总结 （一）CountDownLatch案例入门 【1】CountDownLatch和join的区别 在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。
之前可以使用join方法实现，但是join方法不够灵活，join方法需要线程Thread调用，而在项目中都避免直接操作线程，而是使用线程池来管理线程，这时候就没有办法直接调用这些线程的join方法了，这个时候就需要使用CountDownLatch了。
CountDownLatch是使用计数器来允许子线程运行完毕或者在运行中递减计数。
【2】CountDownLatch案例一：等待线程等待工作线程 下面代码演示2个等待线程通过CountDownLatch去等待3个工作线程完成操作：工作线程在执行结束后调用countDown方法，等待线程在执行开始前调用await方法
public class CountDownLatchTest { public static void main(String[] args) throws InterruptedException { // 让2个线程去等待3个三个工作线程执行完成 CountDownLatch c = new CountDownLatch(3); // 2 个等待线程 WaitThread waitThread1 = new WaitThread("wait-thread-1", c); WaitThread waitThread2 = new WaitThread("wait-thread-2", c); // 3个工作线程 Worker worker1 = new Worker("worker-thread-1", c); Worker worker2 = new Worker("worker-thread-2", c); Worker worker3 = new Worker("worker-thread-3", c); // 启动所有线程 waitThread1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0c4d0fc1672a1e5e66a08d5c7dcbbde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71864ce8622b9d0bcc4370a1a15c2d7/" rel="bookmark">
			imx6ull 移植ubuntu18.04文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载 ubuntu-base-18.04.5-base-armhf.tar.gz
http://cdimage.ubuntu.com/ubuntu-base/releases/
2 安装运行模拟器：
sudo apt install qemu-user-static
3 创建用于ubuntu-base根文件系统目录，并解压到该文件夹：
mkdir ubuntu_rootfs
tar xf ubuntu-base-18.04.5-base-armhf.tar.gz -C ./ubuntu_rootfs
cd ubuntu_rootfs
4 拷贝CPU架构为ARM的模拟器到根文件系统：
sudo cp /usr/bin/qemu-arm-static ./usr/bin/
5 拷贝主机下的DNS配置文件，没有这个文件的话我们无法使用apt-get下载软件：或者将文件中更改为nameserver 114.114.114.114
sudo cp /etc/resolv.conf ./etc/resolv.conf
6 添加源，打开sources.list这个文件，在这个文件最后追加中科大源：
vi etc/apt/sources.list
deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-backports main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-proposed main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-security main multiverse restricted universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ xenial-updates main multiverse restricted universe deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a71864ce8622b9d0bcc4370a1a15c2d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812dc90dccb6d5361abb3a0c43f1e4db/" rel="bookmark">
			低版本docker cp报错Error: Path not specified未指定路径解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概就是版本过低。此时我们可以通过另外得途径解决
1：查找启动容器得id
docker inspect -f ‘{{.Id}}’ 40e8c27c975f
例如我这里找es得
2：进入到docker容器挂在到本地得共享盘地址
一般就事
以我得乌班图为例
/var/lib/docker
root@ubuntu:/var/lib/docker
3：我们随意创建一个文件
docker exec 40e8c27c975f touch /myfile
这个命令就相当于在容器里创建了一个myfile得文件
4：
sudo find /var/lib/docker -iname myfile 查找myfile在本地磁盘得映射
可以看到 容器id也对得上，我们选择有mnt这个路径
5：进入到这个路径cd /var/lib/docker/aufs/mnt/40e8c27c975fb4558ae0dbfc5c273316882e46cbd0c1519f9366103dea4f0165
可以看到
我们创建得myfile
6：进入到容器我们也可以看到docker exec -it 40e8c27c975f /bin/bash myfile这个文件
所以需要复制文件或者创建文件操作文件啥得，直接在虚拟机中得这个路径操作即可，不需要通过docker cp来操作了，当然按照网上说得 ，高版本1.8后已经解决了这个问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c952dc379fcbd201d2fbf8b727939d71/" rel="bookmark">
			笔记本电脑电源指示灯亮但是黑屏开不了机（或者成功开机之后发现很卡顿）的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 本人电脑是联想拯救者Y7000P，性能如下
近期遇到一个问题，笔记本电脑开机的之后，突然出现卡顿，不管是打开浏览器还是打开软件，都要等上几秒钟，连刷新都要等一会。刚开始还以为是因为自己更新了windows系统的原因，尝试着还原系统，但是还原之后还是有问题，运行还是卡顿，之后去问了联想的客服，也得到的解决。
可能有小伙伴还会出现电源指示灯都是亮着的，但是屏幕是黑屏状态无法开机，遇到这个开机黑屏有一定几率是主板或者内存等问题导致的问题，但是先不要急，以下解决方法也可以尝试一下，说不定可以解决你的问题，下面分享一下笔记本电脑电源指示灯亮但是黑屏开不了机的解决方法。
解决方法： 我们可以使用重启大法，将电脑强制关机后，关机状态下，拔掉电源适配器以及拔掉所有外接设备（充电器）。之后长按电脑电源按键，需按住不要松手，坚持20秒左右再松开，注意！注意！注意！不要按太长时间，等待5秒再单独接上外接电源，释放静电，尝试开机看下效果。
此操作是重置主板EC芯片，让机器重新识别硬件。
产生原因： 联想客服也给我解释一下原因，机子运行温度太低了，导致主板出现问题，采用上述方法可以得到解决。以后要注意机子的性能，让电脑处于最佳性能。
后续 如果不行的话，拆机将内存重新插拔试试，再不行最大几率就是主板或者内存的问题了，需要送修给电脑师傅一一排查了。遇到问题，自己先查找一下原因，还是不行的话，就请教专业人士，关注小杰，分享生活遇到的小问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c6dca9e11f3de4fe46e1c8d3c795c5/" rel="bookmark">
			Selenium&#43;python常见问题，闪退，找不到元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、闪退问题：
由于缺少浏览器对应驱动。谷歌：chromedriver驱动；火狐：geckodriver驱动
查看Chrome版本
查找Chrome和ChromeDriver的对应关系
打开Chrome，在设置 – 关于Chrome下载对应ChromeDriver
ChromeDriver下载地址：
http://chromedriver.storage.googleapis.com/index.html
选择对应版本的ChromeDriver下载
火狐驱动下载时需注意：先查看自己安装浏览器版本，在驱动官方下载对应版本驱动下载完成后，需放在python安装目录下的Scripts文件下，后重启项目，部分电脑需重启电脑。
2、找不到元素分为几种状况：
（1）缺少驱动
缺少驱动：根据上述1、下载驱动，即可。
（2）页面嵌套
查看元素所属标签上方是否存在iframe标签，或者新的、等标签，如存在，就需使用先进入新页面再查找元素。
参考阅读：Selenium常见问题——定位子窗口（frame）内元素失败
（3）页面元素未加载
出现这个问题是由于页面存在异步加载的情况，在网页上，页面已经展示出来，但实际元素，还未加载完成，就去查找元素进行操作，就会造成元素未找到，进而保持错，那么如何避免这种情况呢，那就是等待，强制等待或者隐式等待，等待元素加载完成
强制等待：time.sleep(等待时间)
隐式等待
如果强制等待时间过长，可选择隐式等待，通过添加 implicitly_wait() 方法就可以方便的实现隐式等待；implicitly_wait(30) 的用法应该比 time.sleep() 更智能，后者只能选择一个固定的时间的等待，前者可以在一个时间范围内智能的等待。
# -*- coding:utf-8 -*- from selenium import webdriver import time #调入time函数 driver = webdriver.Chrome() driver.get("https://www.baidu.com/") driver.implicitly_wait(30) #智能等待30秒 driver.find_element_by_id("kw").send_keys("python") driver.find_element_by_id("su").click() 隐式等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。
提醒：隐性等待对整个driver的周期都起作用，所以只要设置一次即可。
（4）浏览器没有设置成最大，导致打开的页面找不到
运行自动化程序时，程序默认打开的浏览器窗口较小，导致后缀栏位显示不足，就会导致找不到对应元素。
解决方法：
只需要在程序打开网站时，设置浏览器最大化。driver.maximize_window()
设置浏览器最大化
# -*- coding:utf-8 -*- from selenium import webdriver import time #调入time函数 driver = webdriver.Chrome() driver.get("https://www.baidu.com/") driver.implicitly_wait(30) #智能等待30秒 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c6dca9e11f3de4fe46e1c8d3c795c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e999dd260b1973b2194a2e37968d17d/" rel="bookmark">
			resultMap与resultType的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 resultmap与resulttype的区别为：对象不同、描述不同、类型适用不同。
一、对象不同
1、resultmap：resultMap如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。
2、resultType：resultType使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。
二、描述不同
1、resultmap：resultMap对于一对一表连接的处理方式通常为在主表的pojo中添加嵌套另一个表的pojo，然后在mapper.xml中采用association节点元素进行对另一个表的连接处理。
2、resulTtype：resultType无法查询结果映射到pojo对象的pojo属性中，根据对结构集查询遍历的需要选择使用resultType还是resultMap。适用于单表查询。
三、类型适用不同
1、resultmap：mybatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap。
2、resulttype：resultType是直接表示返回类型的,而resultMap则是对外部ResultMap的引用，但是resultType跟resultMap不能同时存在。
resultMap属性和元素简介：
属性描述property需要映射到JavaBean 的属性名称。column数据表的列名或者标签别名。javaType一个完整的类名，或者是一个类型别名。如果你匹配的是一个JavaBean，那MyBatis 通常会自行检测到。然后，如果你是要映射到一个HashMap，那你需要指定javaType 要达到的目的。jdbcType数据表支持的类型列表。这个属性只在insert,update 或delete 的时候针对允许空的列有用。JDBC 需要这项，但MyBatis 不需要。如果你是直接针对JDBC 编码，且有允许空的列，而你要指定这项。typeHandler使用这个属性可以覆写类型处理器。这项值可以是一个完整的类名，也可以是一个类型别名。 &lt;!--column不做限制，可以为任意表的字段，而property须为type 定义的pojo属性--&gt; &lt;resultMap id="唯一的标识" type="映射的pojo对象"&gt; &lt;id column="表的主键字段，或者可以为查询语句中的别名字段" jdbcType="字段类型" property="映射pojo对象的主键属性" /&gt; &lt;result column="表的一个字段（可以为任意表的一个字段）" jdbcType="字段类型" property="映射到pojo对象的一个属性（须为type定义的pojo对象中的一个属性）"/&gt; &lt;association property="pojo的一个对象属性" javaType="pojo关联的pojo对象"&gt; &lt;id column="关联pojo对象对应表的主键字段" jdbcType="字段类型" property="关联pojo对象的主席属性"/&gt; &lt;result column="任意表的字段" jdbcType="字段类型" property="关联pojo对象的属性"/&gt; &lt;/association&gt; &lt;!-- 集合中的property须为oftype定义的pojo对象的属性--&gt; &lt;collection property="pojo的集合属性" ofType="集合中的pojo对象"&gt; &lt;id column="集合中pojo对象对应的表的主键字段" jdbcType="字段类型" property="集合中pojo对象的主键属性" /&gt; &lt;result column="可以为任意表的字段" jdbcType="字段类型" property="集合中的pojo对象的属性" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082e1da02a10fc08f5b33d9fd9dfc176/" rel="bookmark">
			全局加载组件 vant loading
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;van-popup :close-on-click-overlay="false" v-model="show" style="background-color:transparent" &gt; &lt;div class="loadingWrap"&gt; &lt;van-loading v-if="show" type="spinner" /&gt; &lt;/div&gt; &lt;/van-popup&gt; &lt;/template&gt; &lt;script&gt; export default { name:'loading', data () { return { show:false, } }, props:{ // show:{ // type:Boolean, // default:false // }, } } &lt;/script&gt; &lt;style lang='scss' scoped&gt; .loadingWrap{ .van-popup{ background-color:rgba(0,0,0,.7) } } &lt;/style&gt; 在component下创建文件，
1.此时若页面调用是以组件的方式,注掉data中show，打开props下代码，然后在页面中一下方式调用
&lt;template&gt; &lt;div class="home"&gt; &lt;loading :show="isloading"&gt;&lt;/loading&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Loading from '../../../../components/Loading.vue'; export default { name: "Index", components: {Loading }, data() { return { isLoading:false, }; }, }, created() { }, methods: { } }; &lt;/script&gt; &lt;style lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082e1da02a10fc08f5b33d9fd9dfc176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e448014e563f8691644919cd143fec1e/" rel="bookmark">
			【Markdown基础教程】段落分段换行详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写一个笔记，如果不能换行，
一直着向右打字，当然不美观了，可能都会无法打印，
这就引出了这篇文章的内容——换行
段落的详解在上一篇文章讲了段落，这篇将讲解分段
那么，肯定有人会尝试写下面这个程序
# 这是标题 这是我的第一个段落 这是我的第二个段落 这么一看这和一些其他教程的分段程序没有区别，但是
运行后却是这个样子
可以看到，即使我这样分段，但是显示后依旧是一行，只有一个空格
接下来看看这个程序
# 这是标题 这是我的第一个段落 这是我的第二个段落 能看出来和上面的区别吗？
其实，这差在两个空格上
在第一个段落后面，连按两次space就可以达到换行的目的，但是这种方法其实有争议的
有人认为一般编译器都是看不到的......
当然不仅这一种方法
还有一种是直接再来一行空格实现换行
# 这是标题 这是我的第一个段落 这是我的第二个段落 这种够清晰了吧。
以上是两种官方的，但是还有另外一种
这是第一个段落&lt;br&gt; 这是第二个段落 因为很多Markdown软件都兼容HTML
所以可以直接用HTML的br标签换行
但是也有一个不推荐使用的方法：
CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (\) 的方式实现换行
但是并非所有Markdown编辑器支持这种格式
三种换行方式预览图：
以上是三种换行方式总结图
由图可见，回车换行的空隙是其他两种的两倍
原因我暂未了解，所以最推荐使用第一种，第二种也不错
本期教程已结束啦，如果内容有问题欢迎指出~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10eea15fbe514b257e49e6fedcb4566/" rel="bookmark">
			git clone 克隆github项目超时 timeout:443
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地SourceTree连接GitHub超时，不能检查clone
经验证超时为本地DNS不能解析：
ping github.com
配置本地Hosts文件
找到路径：C:\Windows\System32\drivers\etc，打开hosts文件。
在文件最后添加两行配置：
192.30.255.112 github.com git 185.31.16.184 github.global.ssl.fastly.net 打开cmd重新ping github.com
ping成功了！git clone就能正常使用了。
参考链接
[技能]-git克隆连接超时问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019eab2fa8cb2997f6cb6836b61a1e33/" rel="bookmark">
			如何从异步调用返回响应？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 如何从发出异步请求的函数 foo 返回响应/结果？
我正在尝试从回调中返回值，并将结果分配给函数内部的局部变量并返回该变量，但这些方法都没有真正返回响应——它们都返回 undefined 或任何初始值变量 result 是。
接受回调的异步函数示例（使用 jQuery 的 ajax 函数）：
function foo() { var result; $.ajax({ url: '...', success: function(response) { result = response; // return response; // &lt;- I tried that one as well } }); return result; // It always returns `undefined` } 使用 Node.js 的示例：
function foo() { var result; fs.readFile("path/to/file", function(err, data) { result = data; // return data; // &lt;- I tried that one as well }); return result; // It always returns `undefined` } 使用承诺的 then 块的示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019eab2fa8cb2997f6cb6836b61a1e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f5316ba8d9a839c5ff9ec68ac2f7cc/" rel="bookmark">
			Git不完全使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为个人实际使用的总结，做笔记留存，仅供参考 开始使用 下载安装 前往Git官网下载并安装：https://git-scm.com/download使用HTTPS同步代码，推荐同时下载并安装Git Credential Manager 推荐理由 该软件可以帮我们将Github的用户名与密码，以windows凭证的方式保存在本地，避免重复输入账号密码. 你可以前往 "控制面板\用户帐户\凭据管理器"，查看Windows凭证 使用SSH同步代码，可参考下述步骤，或搜索 Git配置SSH 关键字查看相关教程1- 先配置提交信息 git config --global user.name "用户名" git config --global user.email "邮箱" 2- 生成 SSH KEY，一直回车即可 ssh-keygen -t rsa -C "xx@xx.com" （-C：添加了密钥的注释，可选） 3- 找到公钥id_rsa.pub，并复制全部内容 C:\Users\xiaoming\.ssh\id_rsa.pub C:\Users\[你的电脑用户名]\.ssh\id_rsa.pub 4- 登录自己的git（github、gitee、gitlab） 5- 到个人设置界面，找到SSH KEYS设置，粘贴刚才复制的公钥，保存即可 6-测试ssh是否连接成功 ssh -T git@xx.com (@后面的是git网站的地址) 如：ssh -T git@github.com / ssh -T git@git.iflytek.com 成功提示： Welcome to GitLab, @xiaoming! 如果失败的话，请自行解决或从头再试下，祝你成功！ 【使用小乌龟(TortoiseGit)配置可能遇到的问题】
如果你使用TortoiseGit配置了git的相关设置失败时，可能会导致无法克隆代码和使用sourseTree等工具。你可以尝试打开sourseTree&gt;&gt;顶部工具栏&gt;&gt;选择工具选项&gt;&gt;找到SSH 客户端配置，选择SSH客户端选项为openSSH，保存再次测试下。 初始化配置 查看配置 git config --global --list // 查看是否已经配置了用户名与邮箱信息 开始配置 在任意位置，右键 &gt;&gt; 点击 Git Bash Here配置提交的基础信息（即用户名、邮箱） git config --global user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f5316ba8d9a839c5ff9ec68ac2f7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27b7a918c7cd89e7f5e1c9f34c79427/" rel="bookmark">
			Linux磁盘管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux磁盘管理 实验目的及要求1.熟悉Linux下磁盘的基本管理方法。2.了解Linux磁盘配额管理的意义和基本方法。3.掌握mount、fdisk、df等常用的磁盘管理命令。 实验原理实验步骤1.使用不同的方法挂载/卸载磁盘并查看相关信息，具体步骤如下：1.挂载一个光驱或U盘。2.用mount、fdisk -l、df -hT等命令查看分区信息。3.卸载光驱或U盘。 2.使用教材上的文本编辑方式或者实操课上演示的命令方式，练习磁盘配额管理：1.设置指定的磁盘为用户(usrquota)或用户组(grpquota)的限额配置。2.创建测试用的用户或用户组。3.设置用户或用户组的磁盘配额。4.查看用户或用户组磁盘使用情况。5.启动磁盘配额。6.测试:分别对磁盘大小限额与文件个数限额进行测试。 具体操作1.使用不同的方法挂载/卸载磁盘并查看相关信息，具体步骤如下：1.挂载一个光驱或U盘。2.用mount、fdisk -l、df -hT等命令查看分区信息。3.卸载光驱或U盘。 2.使用教材上的文本编辑方式或者实操课上演示的命令方式，练习磁盘配额管理：1.设置指定的磁盘为用户(usrquota)或用户组(grpquota)的限额配置。2.创建测试用的用户或用户组。3.设置用户或用户组的磁盘配额。4.查看用户或用户组磁盘使用情况。5.启动磁盘配额。6.测试:分别对磁盘大小限额与文件个数限额进行测试。卸载磁盘 实验目的及要求 1.熟悉Linux下磁盘的基本管理方法。 2.了解Linux磁盘配额管理的意义和基本方法。 3.掌握mount、fdisk、df等常用的磁盘管理命令。 实验原理 Linux文件系统是Linux系统的核心模块，通过使用文件系统，用户可以很好地管理各项文件及目录资源。在Linux中，每一个硬件设备都映射到一个系统的文件，每个硬盘设备最多只能有4个主分区(其中包括扩展分区)。硬盘设备是由大量的扇区组成的，每个扇区的容量为512字节，其中第一个扇区是446字节的主引导记录、64字节的分区表、2字节结束符。命令行模式下使用Linux磁盘管理的方法包括mount、fdisk、df等。
实验步骤 1.使用不同的方法挂载/卸载磁盘并查看相关信息，具体步骤如下： 1.挂载一个光驱或U盘。 2.用mount、fdisk -l、df -hT等命令查看分区信息。 3.卸载光驱或U盘。 2.使用教材上的文本编辑方式或者实操课上演示的命令方式，练习磁盘配额管理： 1.设置指定的磁盘为用户(usrquota)或用户组(grpquota)的限额配置。 2.创建测试用的用户或用户组。 3.设置用户或用户组的磁盘配额。 4.查看用户或用户组磁盘使用情况。 5.启动磁盘配额。 6.测试:分别对磁盘大小限额与文件个数限额进行测试。 具体操作 添加一块硬盘，此硬盘没有做任何操作。
1.使用不同的方法挂载/卸载磁盘并查看相关信息，具体步骤如下： fdisk -l #查看分区 fdisk /dev/sdb #进行分区 选择新建一个主分区
格式化磁盘
mkfs -t xfs /dev/sdb1 1.挂载一个光驱或U盘。 2.用mount、fdisk -l、df -hT等命令查看分区信息。 mkdir /test #在根目录下新建文件夹 chmod 777 /test #设置权限读写执行 mount -t xfs -o usrquota,grpquota /dev/sdb1 /test #把/dev/sdb1挂载到/test目录下 df -hT #查看磁盘挂载情况 3.卸载光驱或U盘。 2.使用教材上的文本编辑方式或者实操课上演示的命令方式，练习磁盘配额管理： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27b7a918c7cd89e7f5e1c9f34c79427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4df8cf19004b22431f1be19b69498f/" rel="bookmark">
			解决git中出现的“bash syntax error near unexpected token ’(‘”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来分享一篇关于我在git使用过程中出现的一个错误。
错误信息：
bash: syntax error near unexpected token `(’
翻译过来就是提示我在’('这里有错误，而这个错误是我在使用git commit提交时候产生的，我当时是这么写的：
git commit 'xxx' -m [测试(xx版)] //这样会报错 然后一回车就提示我上述那个错误，我一看好像就只有写备注信息的[]里面有括号()，于是我就想到应该是这里出现问题，在[]里面是不能这么写’()'的~，然后我就将括号去掉，再次commit提交就成功了
或者如果你要使用()括号，要在前面带上反斜杠‘\’，这样的才不会使git报错，如：
git commit 'xxx' -m [测试\(xx版\)] //在这里我们将()前面都带上\，这样就可以正常使用()了 然后我们这里也通过git实验一下，从下图中是可以看出，将()改为‘\’(和‘)’就可以正常使用：
解决方法：
所以，解决方法有两个：
1、要么去掉[] 方框信息中的()
2、要么就使用’(‘或者’)'来输出()
好了，我的分享到这里就结束了~，如果有其他小伙伴也遇到了这种错误提示，可以以此为参考。
本人水平有限，上述信息仅供学习参考，如有错误和不妥之处，请多多指教。
另外创作不易，请勿抄袭，如果有帮助到大家的话希望大家可以点个赞，谢谢~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68d764fa166090027582d389a1f0c75/" rel="bookmark">
			mycat分库分表实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前我们已经讲解过了数据的切分，主要有两种方式，分别是垂直切分和水平切分，所谓的垂直切分就是将不同的表分布在不同的数据库实例中，而水平切分指的是将一张表的数据按照不同的切分规则切分在不同实例的相同名称的表中。
下面先来描述mycat的分库操作,在进行分库操作的时候需要注意一点：有关联关系的表应该放在一个库里，相互没有关联关系的表可以分到不同的库中。
详情参考：http://www.ysxbohui.com/article/102
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679ea6e9f476c60c73346c5758dc4dc8/" rel="bookmark">
			mycat的全局序列号几种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实现分库分表的情况下，数据库自增主键已经无法保证自增主键的全局唯一，为此，mycat提供了全局sequence，并且提供了包含本地配置和数据库配置等多种实现方式。
1、本地文件方式
使用此方式的时候，mycat讲sequence配置到文件中，当使用到sequence中的配置，mycat会更新sequence_conf.properties文件中sequence当前的值。
详情参考：http://www.ysxbohui.com/article/101
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1248fc584360673932b349350c95a05/" rel="bookmark">
			sharding-proxy使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sharding-Proxy是ShardingSphere的第二个产品。 它定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前先提供MySQL/PostgreSQL版本，它可以使用任何兼容MySQL/PostgreSQL协议的访问客户端(如：MySQL Command Client, MySQL Workbench, Navicat等)操作数据，对DBA更加友好。
详情参考：http://www.ysxbohui.com/article/100
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc50ae56950c72704cf329b50bbb6274/" rel="bookmark">
			《七》实际应用——生产者与消费者模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java并发编程系列文章
《一》多线程基础——Java线程与进程的基本概念
《二》多线程基础——Java线程入门类和接口
《三》多线程基础——Java线程组和线程优先级
《四》多线程基础——Java线程生命周期及转换
《五》多线程基础——Java线程间的通信（互斥与协作）
《六》实际应用——如何优雅的关闭线程
《七》实际应用——生产者与消费者模型
并发编程（多线程）一直以来都是程序员头疼的难题。曾经听别人总结过并发编程的第一原则，那就是不要写并发程序，哈哈哈。后来发现，这样能够显著提高程序响应和吞吐量的利器，哪还能忍得住不会用呢？
整理出《Java并发编程系列文章》，共计7篇，与君共勉。
《七》实际应用——生产者与消费者模型 1、会阻塞的生产者消费者模型，思考为什么？2、正确的生产者消费者模型 1、会阻塞的生产者消费者模型，思考为什么？ 生产者和消费者模型，应用非常广泛。这是一个经典错误的例子，引以为戒。
public class No6_produce_consumer_test{ private int i = 0; final private static Object lock = new Object(); private volatile boolean flag = false; public void produce(){ synchronized (lock){ if(flag){ try { System.out.println(Thread.currentThread().getName()+"--&gt;waiting"); lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else{ i++; System.out.println(Thread.currentThread().getName()+"--&gt;" + i); flag = true; lock.notify(); //todo 通知来消费 } } } public void consumer(){ synchronized (lock){ if(flag){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc50ae56950c72704cf329b50bbb6274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8104ec0bd68b4e9c025012612b97b911/" rel="bookmark">
			《六》实际应用——如何优雅的关闭线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java并发编程系列文章
《一》多线程基础——Java线程与进程的基本概念
《二》多线程基础——Java线程入门类和接口
《三》多线程基础——Java线程组和线程优先级
《四》多线程基础——Java线程生命周期及转换
《五》多线程基础——Java线程间的通信（互斥与协作）
《六》实际应用——如何优雅的关闭线程
《七》实际应用——生产者与消费者模型
并发编程（多线程）一直以来都是程序员头疼的难题。曾经听别人总结过并发编程的第一原则，那就是不要写并发程序，哈哈哈。后来发现，这样能够显著提高程序响应和吞吐量的利器，哪还能忍得住不会用呢？
整理出《Java并发编程系列文章》，共计7篇，与君共勉。
《六》实际应用——如何优雅的关闭线程 1、开关的方式关闭线程2、打断的方式关闭线程2.1、线程处于WAITING、TIMED_WAITING2.2、线程不处于WAITING、TIMED_WAITING 3、自定义封装Thread，暴力关闭线程 1、开关的方式关闭线程 在实际开发中，什么时候会需要主动关闭线程呢？举个例子，当你用多线程读取Excel中的数据存入数据库，要处理的某个Excel中有100万条数据时，假设你代码中设置10万条数据启动一个线程处理，最多同时启动5个线程。如果启动的线程在处理业务逻辑时报错了，你想立即关闭并重新启一个。废话不多说，直接贴Demo代码：
public class Work extends Thread{ private volatile boolean start = true; //设置开关 @Override public void run() { while (start){ System.out.println("业务逻辑正在执行......"); //业务逻辑 } } public void shutdown(){ this.start = false; } } public static void main(String[] args) throws InterruptedException { Work work = new Work(); work.start(); try { Thread.sleep(1000); }catch (InterruptedException e){ e.printStackTrace(); } work.shutdown(); //主动关闭线程 } 2、打断的方式关闭线程 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8104ec0bd68b4e9c025012612b97b911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378e1c4943dd9b077dda479730dc0cf7/" rel="bookmark">
			idea 使用docker插件，实现一键自动化部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： ​ jdk1.8及以上。
Maven 3.2+
​ idea
​ docker
一、 docker开启远程连接访问 首先我们要开启docker的远程连接访问。保证不是docker所在的服务器，也能够远程访问docker。
Linux版的docker：
1.修改docker.service文件，添加监听端口 -H tcp://0.0.0.0:2375
vi /usr/lib/systemd/system/docker.service 找到 ExecStart，在最后面添加 -H tcp://0.0.0.0:2375，如下图所示
2.重启docker
systemctl daemon-reload systemctl start docker 3.如果我们有防火前记得添加防火墙策略或者关闭防火墙。
window版docker
在电脑左下角找到docker图标，鼠标右键选择settings。 将General菜单下的Expose daemon on tcp://localhost:2375 without TLS勾选。无需重启。
安装配置idea的docker插件 1.在File --&gt; Settings --&gt; Plugins 在输入框中搜索Docker，选择并安装。安装完成后重启Docker。
2.配置docker
在File–&gt; Settings–&gt;Build,Execution,Deployment中找到Docker
新建一个docker实例，然后在Engine API URL中将docker所在ip端口号填上，填完如果下面显示Connection successful证明连接docker成功。如果失败，可能是我们上一步docker开启远程连接未成功。
我们设置完成后，回到idea主界面，可以看到页面下面有一个docker窗口。点击绿色箭头，连接docker。连接上后显示Containers和Images就是我们现在docker中已经有的容器和镜像。
创建项目，并配置 一 、 创建项目 我就以一个简单的Eureka项目演示。
File–&gt; New --&gt;Project --&gt; Spring Initializr
二、 配置项目 1.修改pom.xml文件，引入docker-maven-plugin插件相关配置. 改配置在标签内
&lt;!--使用docker-maven-plugin插件--&gt; &lt;plugin&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378e1c4943dd9b077dda479730dc0cf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf04ddb49195625062a7235183607da/" rel="bookmark">
			关于实体类的日期转换中使用@DateTimeFormat、@Pattern()、@JsonFormat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于实体类的日期转换中使用@DateTimeFormat、@Pattern()、@JsonFormat 注解使用场景@DateTimeFormat@DateTimeFormat只会在类似@RequestParam的请求参数（url拼接的参数才生效）上生效，如果@DateTimeFormat放到@RequestBody下是无效的。@Pattern()在实体上对属性进行正则匹配（例如：@Pattern(^\w+$)，只能输入由数字、26个英文字母或者下划线组成的字符串）@JsonFormat在@RequestBody中则可以使用@JsonFormat把传给后台的时间字符串转成Date 简单那来说 ，这三个注解几乎都使用在controller层上，@DateTimeFormat和@JsonFormat用来接收前端请求的body。前者用于将日期转为时间（非@RequestBody下使用），后者在json环境下使用。
而@Pattern()则在实体内变量中进行正则匹配。
所以妄想println的同学，还是写一个日期格式util吧。用simpledateFormat。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015d99c5b6e2531fa23d00c477c648d6/" rel="bookmark">
			vue 设置input只能输入数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
将&lt;input&gt;标签中的​type​属性直接设置为​number​就可以达到只能输入数字。优点：他直接能唤起数字键盘，缺点:它只能作用于网页端，在手机输入的话还是可以输入汉字或英文
&lt;input placeholder="请输入..." v-model="risingValues" type='number'&gt; 方法二：
&lt;input placeholder="请输入..." v-model="risingValues" oninput="value=value.replace(/[^\d]/g,'')"&gt; 重点：οninput="value=value.replace(/[^\d]/g,'')"
这个方法，输入汉字是输入不进去的，只能输入数字，缺点：他只能唤起键盘（不是数字键盘）
我常用的第二种方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0b8f8d661cbe8bb667798a7a255b56/" rel="bookmark">
			vue3之实现响应式数据ref和reactive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用途 ref、reactive都是vue3提供实现响应式数据的方法
ref() 接受一个内部值，返回一个响应式的、可更改的ref对象，此对象只有一个指向其内部的属性.value
ref可以说是简化版的reactive，与reactive的区别则是
ref是对某一个数据类型的单独双向绑定
使用ref在setup读取的时候需要使用.value的形式template中则不需要.调用
function ref&lt;T&gt;(value: T): Ref&lt;UnwrapRef&lt;T&gt;&gt; interface Ref&lt;T&gt; { value: T } reactive() 返回一个对象的响应式代理。
参数必须是对象(json/arr)
本质是转成proxy对象
响应式转换是深层的，它会影响到所有嵌套的属性，一个响应式对象也将深层地解包任何ref属性，同时保持响应性。
shallowReactive浅层次的作用形式
const state = shallowReactive({ foo: 1, nested: { bar: 2 } }) // 更改状态自身的属性是响应式的 state.foo++ // ...但下层嵌套对象不会被转为响应式 isReactive(state.nested) // false // 不是响应式的 state.nested.bar++ toRefs 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的ref。每个单独的ref都是使用toRef()创建的。
把一个响应式对象转换为普通对象对普通对象的每一个属性都进行ref操作 toRefs配合reative使用： 当从组合式函数中返回响应式对象时，toRefs 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性
reactive对象取出的所有属性值都是非响应式的，而利用toRefs可以将一个响应式reactive对象的所有原始属性转换为响应式的ref属性。
function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }) // ...基于状态的操作逻辑 // 在返回时都转为 ref return toRefs(state) } // 可以解构而不会失去响应性 const { foo, bar } = useFeatureX() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7eb9e9e066614fb1bc7cc3def58e8b/" rel="bookmark">
			大雪节气___
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千山鸟飞绝，万径人踪灭。孤舟笠翁，独钓寒江雪。
日暮苍山远，天寒白屋贫。柴门闻犬吠，风雪夜归人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d762d990027e1f58fee2ced473438e7/" rel="bookmark">
			【SRE笔记 2022.9.30 集群知识及Centos基础优化】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SRE笔记 2022.9.30 集群内服务软件集群模板机创建Linux系统优化用户优化ssh远程连接效率提升配置yum源常用软件安装安全优化中文字符集（非必要）时间同步提升命令行安全（可选）加大文件描述符优化内核扩展优化关键文件锁定清楚多余虚拟账户（可选）grub引导加密禁ping（内核参数）补丁升级开机自启精简生产企业最小化原则扩展优化创建规范目录检查端口 集群IP规划配置内网解析安装及配置路径规划拍摄快照克隆 rsync复制软件简介及特性增量复制原理版本三种工作模式local(本地)Access via remote shell(隧道）远程shell企业场景无隧道有隧道 access via rsync daemon(CS架构)(常用)服务端配置文件配置密码文件创建相关备份目录启动服务端客户端配置方法一方法二 测试客户端命令参数 客户端复制报错案例多模块复制排除文件复制 主机之间数据无差异复制断点限速 优缺点优点缺点 集群内服务软件 防火墙：深信服，天融信，华为，思科CDN服务: 阿里CDN，腾讯CDN，网宿CDNDNS服务：阿里云DNS，腾讯DNS,硬件F5,bind，powerDNS负载均衡：ngingx(L4tcp和L7http)，lvs，Haproxy(L4 和L7)高可用：keepalived heartbeat静态web服务：Nginx，Apache IIS动态web服务：php(php-fpm)，java(tomcat，resinm,weblogic)，python(python)关系型数据库服务：mysql(mariadb)，oracle，postgresql非关系型数据库：Mongodb,Redis，hbase存储服务：NFS,MFS,FASTDFS,CEPH,HADOOP复制备份 ：sersync，rsync 定时备份（crond+rsync）实时备份（rsync+sersync）ELFK分布式日志集群
Elasticsearch 数据存储
Filebeat 数据收集
Logstash 数据处理
Kibana 数据分析和展示
Kafaka消息队列服务
Zookeeper集群
Hadoop大数据存储VPN服务：硬件VPN,openvpn，pptp跳板机服务:硬件跳板机，jumperver（可视化、图形化、记录日志）批量管理服务: ssh（key）服务，ansible服务（常用），saltstak，cfengine，expect,ssh-pass,SecureCRT监控服务：nagios(早期的)，zabbix，promothous(普罗米修斯)，grafana(可视化工具)时间服务数据仓库：yum仓库，rpm包变更管理:jira版本管理:git gitlab代码及配置发布：jenkins ants maven代码质量检测：sonarqube代码发布流程：办公室测试-idc测试-idc1/2服务器组-余下的服务器（发布一个地区，灰度发布）运维开发平台，将变更管理、版本管理、代码发布及配置，代码质量检测，监控服务等所有组件整合到一起Vmware workstation:学习使用虚拟主机：xen、kvm云计算服务 ：openstack(私有云)，python语言开发容器化：docker+k8 go语言开发公有云服务：阿里云，腾讯云。未来就是公有云和容器化时代！ 集群模板机创建 使用标准分区配置两个网卡，第二块网卡无需配置网关
Linux系统优化 以下优化方面有部分需要在服务稳定后再进行操作，避免环境出现问题 用户优化 安装系统最后一步将oldboy加了管理员的设置方法。是将新用户加入了wheel组。
[root@zhk ~]# grep wheel /etc/sudoers ## Allows people in group wheel to run all commands %wheel	ALL=(ALL)	ALL #%wheel代表wheel组 # %wheel	ALL=(ALL)	NOPASSWD: ALL 如果没有上述操作，需要新建用户加入sudo管理禁止root远程登录，使用新增的用户登录，并配置xshell连接（复制之前成功会话，无需新建）ssh端口也可修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d762d990027e1f58fee2ced473438e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31937fe14551f422203247aa75ec05dc/" rel="bookmark">
			深度学习--卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
（一）输入层（Input Layer）
（二）卷积层（Convolution Layer）
（三）激活层（Activation Layer）
（四）池化层（Pooling Layer）
（五）全连接层（Full Connected Layer）
（六）输出层（Output Layer）
Definitions：
卷积神经网络（Convolutional Neural Networks,CNN)是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一 。卷积神经网络具有表征学习（representation learning）能力，能够按其阶层结构对输入信息进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）” 。------来自于百度百科的定义
卷积神经网络是一个层次模型。主要结构包括输入层，卷积层，池化层，激活层，全连接层以及输出层。（卷积神经网络中还有隐含层，包含卷积层、池化层和全连接层3类常见构筑，在一些更为现代的算法中可能有Inception模块、残差块（residual block）等复杂构筑。在常见构筑中，卷积层和池化层为卷积神经网络特有。卷积层中的卷积核包含权重系数，而池化层不包含权重系数，因此在文献中，池化层可能不被认为是独立的层。以LeNet-5为例，3类常见构筑在隐含层中的顺序通常为：输入-卷积层-池化层-全连接层-输出。）
（一）输入层（Input Layer） 卷积神经网络的输入层用来江原始数据或经过预处理的数据输入网络。可以处理多维数据，常见地，一维卷积神经网络的输入层接收一维或二维数组，其中一维数组通常为时间或频谱采样；二维数组可能包含多个通道；二维卷积神经网络的输入层接收二维或三维数组；三维卷积神经网络的输入层接收四维数组 。
以图像任务为例，当输入为彩色RGB图像时，为3D张量，组成三维像素矩阵（H*W*3），若指定个数则为（N*H*W*3）；当输入是灰度图像时，由于只有一个颜色通道，可以保存在2D张量中，彩色通道数只有一维，像素矩阵（H*W*1），若指定个数则为（N*H*W*1）.
（二）卷积层（Convolution Layer） 卷积层通常用作对输入层输入的数据进行特征提取。卷积层越多，特征提取能力越强。卷积操做实质上是对俩个像素矩阵进行点乘求和的数学操作。其中一个矩阵为输入的数据矩阵，另一个则是卷积核（滤波器或特征矩阵），所求结果为原始图像中提取的局部特征。
卷积核是会根据设定的步长进行移动，如stride=1则每次平移一位。计算方法就是每个网格元素与卷积核对应网格元素相乘再相加，所得的值作为新的矩阵中的元素。
卷积层中的基本参数
卷积核大小（Kernel Size ）：定义了卷积核的感受野。 从底层优化角度来看，3*3的卷积核最优，但近来超大卷积核7*7，21*21也带来了不错的性能。另外，俩个3*3的卷积核效果相当于一个5*5的卷积核，且计算量与参数量均有减少---轻量化）
步长（stride）：设置卷积核在卷积过程中移动的步长。 一般设置为1，代表每次滑动距离为1--这种方式能够覆盖所有相邻位置的特征，并将其进行组合。如果设置其他数值（&gt;1)则相当于对特征组合进行下采样。
填充（padding）：当卷积核尺寸与输入图像矩阵不匹配时需要进行一定的填充策略。 一般padding用于边界处位置，以保证卷积输出与输入的维度一致。
输入通道数（In Channels）：指定卷积操作时卷积核的深度==卷积核的channel数。 默认为与输入特征矩阵通道数（深度）一致。
输出通道数（Out Channels）：指定卷积核个数。 若设置与输入通道数一样，可以保证输入输出维度的一致性；若采用比输入通道更小的值，则能够减少网络整体的参数量。
Out channel=卷积核个数=下一层卷积的in channel （池化层不改变channel） （三）激活层（Activation Layer） 激活层主要由激活函数构成，即在卷积层输出的线性结果上加入非线性因子，让输出的特征图具有非线性关系，能够更好的拟合那些复杂的函数。
名称图像用途缺点Sigmoid将输入映射（0,1）区间，用来做二分类。对于一个极大的负值输入，它输出的值接近于0；对于一个极大的正值输入，它输出的值接近于1。反向传播时会存在梯度爆炸和梯度消失现象；且输出不是以0为中心，会降低学习效率。tanhtanh可以将输入映射到（-1,1）区间，解决Sigmoid不是以0为中心输出的问题梯度消失问题和幂运算导致训练时间长ReLUReLU将所有负值取作0，正值保持不变解决梯度消失问题且收敛速度快。但输出不是以0为中心，且可能某些神经单元永远不会被激活，导致相应参数不能被更新Leaky ReLULeaky ReLU与ReLU很相似，仅在输入小于0的部分，值为负，且有微小的梯度解决ReLU无效神经元的部分，但效果不一定总是好于ReLUSiLU对于较大的值，SiLU 的激活大约等于ReLU的激活。
与 ReLU最大的不同，SiLU 的激活不是单调递增的。 优点：无上界，有下界，平滑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31937fe14551f422203247aa75ec05dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b75ed4d305465bd44f57dcd1823e2a/" rel="bookmark">
			unity webgl 手机端微信直接打开链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作时间：截止2021年5月8号
使用版本：unity2018（可在微信正常打开）
其他版本：经测试unity2020版本系列发布出的webgl项目在网页运行会报错，可在浏览器开发者工具查看；unity2019版本系列发布出的webgl项目在PC端浏览器运行正常，但到移动端使用微信或一些其他的浏览器打开时，程序运行后会一直处于黑屏状态；
打开移动端权限：
Unity发布webGL后，很多时候我们需要在移动端展示，此时找到UnityLoader.js文件，做下面的修改即可在手机端打开：
compatibilityCheck:function(e,t,r){ UnityLoader.SystemInfo.hasWebGL? UnityLoader.SystemInfo.mobile? t() :["Firefox","Chrome","Safari"].indexOf(UnityLoader.SystemInfo.browser)==-1? :e.popup("Yourbrowse does not support WebGL",[{text:"OK",callback:r}]) }, 或者直接改成可以避险很多不必要的麻烦（平台，浏览器等）
compatibilityCheck:function(e,t,r){t();}, webgl完整开发记录可查看另一篇博客：webgl完整开发记录中相关部分 踩坑记录（先粗略的写下）：
公司想要将发布出来的webgl项目的链接直接从手机端微信打开，方便操作，于是就去网上找了设置允许移动端访问的方法，可以成功使用移动端打开链接了，但问题来了火狐可以正常打开链接并操作，直接从微信打开链接或者从其他浏览器打开确是一直黑屏，点击unity发布webgl时自带的右下角全屏按钮就会出现画面；
坑来了，我使用的unity版本是2019.4.24，测试过其他一两个版本的2019系列版本都是一样的问题，黑屏；
使用unity2020版本系列的部分版本测试的时候发现，发布出来的项目在PC端打开时浏览器控制台都会报错同一个错误不能正常打开；（图等我有空再截补）
最后网上确实有类似的成功案例，但没发现有类似情况的，因为在webgl方面也是第一次开发实际项目，最后发现可能跟unity版本有关系，于是又尝试了2018版本的终于成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f1e2771ea428425a9b1397026f2061/" rel="bookmark">
			扩散模型Diffusion轻松入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要问最近模型领域什么东西最火，应该非扩散模型莫属，火得我觉得不系统学习一下都不行！
本文是我的学习笔记，只能叫入门文章，因为扩散模型的严谨数学推导公式很多，还没有研究透彻，不敢说一文吃透扩散模型。此文适合对生成模型有一些了解，要整体理解什么是扩散模型、模型原理、应用在什么地方的同学。
1
扩散模型能干啥
扩散模型火起来主要原因是在图像生成领域，多个著名的从文本到图像生成应用都使用了扩散模型，如果你听说过某个著名的应用能又快又好地生成了很逼真的图像，估计就是下面3个中的一个：
OpenAI的DALL·E 2
Google的Imagen
最近搞AI开源影响很大的StabilityAI开发的Stable Diffusion
下面是我在Stable Diffusion中输入“mouse is playing guitar”生成图片的例子，花了25秒，效果不错，关键还是免费的效果。我也尝试了在中文版网站输入中文，但网页没反应，估计系统暂时有问题。
除了计算机视觉领域，扩散模型在NLP、波形信号处理、多模态建模、分子图建模、时间序列建模、对抗性净化等领域都有广泛应用（有兴趣的参见扩散模型综述 https://arxiv.org/abs/2209.00796）。
扩散模型是生成模型的一种，为了有一个全局的视角，我们要回顾一下业界已经成熟的典型的两种生成模型--GAN和VAE，然后再来看扩散模型。
2
生成模型回顾--生成对抗网络GAN
生成模型简单点说就是生成数据的模型，不管生成的是图像、文本、声音还是其他数据。通常情况下我们希望生成的数据的分布能逼近某个场景中真实数据的分布。
生成对抗网络GAN在生成模型中占有重要一席，我在生成对抗网络GAN系列之一：基本原理和结构细讲一文中有详细讲解，本文只概括描述一下。
整个网络包含一个生成器和一个判别器。生成器通过输入的随机噪声生成假数据，希望能模仿真实数据。判别器输入有两部分，一是真实数据，二是生成器生成的假数据，判别器的目标就是尽可能分辨出哪些是真数据，哪些是假数据。训练好生成器后，就可以用生成器来生成数据了。
3
生成模型回顾--变分自编码器VAE
要说生成模型，不得不说变分自编码器VAE，网上大家学习用得最多的还是苏剑林苏神这张图。
简要描述整个训练过程就是：假设真实样本符合正态分布，对真实样本
学其分布，就是学习均值和方差，怎么学习呢，神经网络就是一种方法，知道了分布，就可以采样到对应的，再对训练个生成器，输入，生成，让和尽可能接近。要生成数据的时候，根据学习到的分布随机采样，输入生成器即可生成接近真实样本的数据。要进一步学习细节请移步苏神文章。
4
扩散模型原理
上面回顾了GAN和VAE，其实也是为了在其基础上平滑过渡到对扩散模型的理解。
上图是各种资料中常引用来比较GAN、VAE、Flow-based、Diffusion模型的一个经典图，Flow-based模型我没有研究过，直接从GAN、VAE说起，不妨碍我们的理解。
GAN就是粗暴地用神经网络训练生成器和判别器，来学习真实数据的分布，可解释性差，反正就是学出来了，训练时很容易出现不稳定问题。
VAE比起GAN明确要学习数据的分布（Encoder做的），即均值和方差，有了可解释性，然后基于学习到的分布采样到的数据训练生成器（Decoder）。本质上，VAE的Encoder就是对真实数据进行加噪，其一部分学均值，尽量接近0，另一部分学方差，尽量接近1，目的是为了采集到的Z符合标准正态分布N(0,1)，方差就描述了加的高斯噪声的强弱。Decoder在加了高斯噪声的数据上解码，相当于去掉噪声恢复真实数据的作用。所以，一句话总结，VAE通过Encoder加噪和Decoder去噪学习来生成数据。
重点来了，开始过渡到扩散模型。VAE已经有很好的理论可解释性了，但有个问题是Encoder一大步就学了的数据分布进行加噪，Decoder又是一大步解码去噪，步子跨得大，就容易扯到蛋，导致学习得不够细腻，那如何能学得细腻点呢？这就是扩散模型干的事：前向一小步一小步地加噪，逆向一小步一小步地去噪。注意，这个逆向指的是逆向还原数据，不要误解成反向梯度计算，所以我特意用逆向，不用反向。
具体的前向和逆向实现最有名的模型是2020年提出的DDPM(Denoising Diffusion Probabilistic Models)。前向T步对真实数据添加高斯噪声，
，每个时刻t只和t-1时刻有关，所以可以看着是一个马尔可夫过程。逆向过程也对应T步，大佬们已经从理论上证明逆向过程的每一步也是高斯分布，如果能得到这些分布，那么输入一个高斯噪声，就能通过逆向的T步生成像真实数据的数据了。但是如何得到这T步逆向的分布，很难！很难的东西，我们就用神经网络来学习！
不知道到了这儿，你对扩散模型的基本原理有没有理解，更准确点说，是我有没有讲明白，就是一个增强版的VAE。
5
如何训练和推理
既然本文叫入门文章，我有些犹豫要不要加入数学公式，本来我是不想加的。最近学习扩散模型看了好多知乎大佬的解释，光苏剑林就写了13篇文章漫谈扩散模型，每一篇里都有好多数学公式推理，并不是所有公式都搞懂了，但对DDPM的基本逻辑还是看懂了的。
就算是入门文章，也得说明白模型是如何训练和推理的，要说明这个，无法避免得使用点公式，这篇知乎文章https://zhuanlan.zhihu.com/p/566618077是目前我发现公式使用程度拿捏得最好的，以下对于训练和推理的内容主要参考这篇文章。先说下前向、逆向的具体计算。
前向计算，由t-1时刻计算t时刻值：
其中
是预先设定好的超参数，是高斯噪声，由t到t-1的不断迭代，可以得到，其中，也是一个随机高斯噪声，于是t时刻的值可以由0时刻初始值计算得到。具体迭代有一堆推导，此处省略。
逆向计算，由t时刻计算t-1时刻值：
其中
是由和t估计的噪声，是模型超参，是高斯噪声。
好了，前向不断计算加上噪声，逆向不断计算去掉噪声，模型训练的目标就是让每步加的用来搞破环的噪声
和通过模型学习相近，越相近，去噪越好，得到的数据越像真实数据。具体的损失函数：
所以原始论文中训练的算法过程描述：
通过模型训练学习到了
，推理（由噪声生成想要的数据）就简单了，从N(0,1)中随机生成一个噪声，循环T步逐步去噪，就从噪声恢复得到了，算法描述为：
终于可以松一口气，算法描述就这些了。有同学可能会问，随机生成一个噪声得到一个像真实数据的数据
有啥意义呢，这就和GAN里面一样，我们可以加入具体条件要求，比如由文本生成图像，条件要求就是输入的文本。
扩散模型学得更细腻了，需要更多的采样步骤，所以训练时间也增加了，不少研究者都在想办法改进减小训练时间。
6
一个具体例子--Stable Diffusion
理解一种算法，很重要目的是为了落地应用，否则只是飘在空中不踏实，所以我们以Stable Diffusion模型来看看扩散模型究竟是怎么落地实现的。以下内容参考自https://jalammar.github.io/illustrated-stable-diffusion/。
Stable Diffusion的总体结构
总体结构很清晰，输入一段文字，通过Stable Diffusion输出这段文字描述的一张图片，比如上图输入“极乐美丽的沙滩”，输出就是这么一张美丽的沙滩图片。模型由两个组件构成，一是Encoder把文字转换为对应的embedding/representation，这个是NLP文本处理的常规操作，有了文本的embedding，第二个组件Image Generator把这个embedding转换生成图片。论文中说，使用较大的语言模型生成更好的embedding对生成的图像质量的影响大于使用较大的图像生成组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f1e2771ea428425a9b1397026f2061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d35118d03386e77719dcc5b47ba1b6/" rel="bookmark">
			信息量、信息熵、KL散度、交叉熵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、信息量 对于一个离散性总体 X X X，随机抽取得到的样本值为 x x x，该样本值向我们传递的信息量定义为：
I ( x ) = − l o g p ( x ) I(x)=-log\ p(x) I(x)=−log p(x)
p ( x ) p(x) p(x)为取得样本值 x x x的概率，根据总体 X X X的概率密度函数得到。这里的底数既可以为 e e e，也可以是2。底数为 e e e时信息量单位为奈特(nat)，底数为2时信息量单位为比特(bit)，这里我们统一用比特作为单位。
信息量有一个很显著的特点，便是概率越小的事件发生，所蕴含的信息量越大。比如太阳从东边升起，这件事的发生概率无限接近于1，从中并不能获得什么信息。但哪天你看到太阳从西边升起了，这种小概率事件发生所蕴含的信息量就很大，说不定这意味着地球倒着转了或者自己的眼睛出毛病了。
二、信息熵 上面的信息量衡量的是单个样本，如果要衡量随机变量总体 X X X带来的信息量，需要用到信息熵，定义如下：
H ( X ) = E ( I ( x ) ) = ∑ i = 1 n p ( x i ) I ( x i ) = − ∑ i = 1 n p ( x i ) l o g p ( x i ) H(X)=E(I(x))=\sum_{i=1}^np(x_i)I(x_i)=-\sum_{i=1}^np(x_i)log\ p(x_i) H(X)=E(I(x))=i=1∑n​p(xi​)I(xi​)=−i=1∑n​p(xi​)log p(xi​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3d35118d03386e77719dcc5b47ba1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c052602a59b415f45f43a6b569873d/" rel="bookmark">
			Linux软件包管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux软件包管理 实验目的及要求1.了解RPM特点与YUM工作机制。2.熟悉RPM软件包的密钥管理。3.掌握RPM、YUM或DNF包管理方法及其命令。 实验原理实验步骤1.查询当前已安装的RPM包，在安装光盘上查找尚未安装的RPM包，通过命令和图形界面的多种方式进行安装、升级、卸载等操作。2.添加本地源，列出所有可更新的安装包，熟练操作各种形式的安装(在线安装、离线安装)和卸载命令。 具体操作1.查询当前已安装的RPM包，在安装光盘上查找尚未安装的RPM包，通过命令和图形界面的多种方式进行安装、升级、卸载等操作。2.添加本地源，列出所有可更新的安装包，熟练操作各种形式的安装(在线安装、离线安装)和卸载命令。1.创建挂载点2.挂载镜像3.备份yum配置文件4.更新yum缓存5.测试是否建立成功测试安装httpd 实验目的及要求 1.了解RPM特点与YUM工作机制。 2.熟悉RPM软件包的密钥管理。 3.掌握RPM、YUM或DNF包管理方法及其命令。 实验原理 RPM工具包是一种以数据库记录的方式来将你所需要的软件安装到Linux系统的一套管理机制。Yum是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装；可以自动处理依赖性关系，并且一次安装所有依赖的软件包。RPM采用的数字签名为PGP数字签名。
实验步骤 1.查询当前已安装的RPM包，在安装光盘上查找尚未安装的RPM包，通过命令和图形界面的多种方式进行安装、升级、卸载等操作。 2.添加本地源，列出所有可更新的安装包，熟练操作各种形式的安装(在线安装、离线安装)和卸载命令。 具体操作 挂载光盘
1.查询当前已安装的RPM包，在安装光盘上查找尚未安装的RPM包，通过命令和图形界面的多种方式进行安装、升级、卸载等操作。 rpm -qa #查询已安装的RPM包 rpm -qpi [软件包名] #查询未安装的rpm包 rpm -ivh --force [软件包名] #安装rpm包 rpm -Uvh [包文件名] #升级软件包 rpm -e [包文件名] #卸载rpm软件包 2.添加本地源，列出所有可更新的安装包，熟练操作各种形式的安装(在线安装、离线安装)和卸载命令。 yum list updates #列出可更新的安装包 yum erase [软件名] eg：httpd #卸载软件 yum install [软件名] eg：httpd #安装软件 1.创建挂载点 mkdir -p /mnt/cdrom 2.挂载镜像 查看挂载点
df -h mount /dev/cdrom /mnt/cdrom #将/dev/cdrom挂载到/mnt/cdrom之下 3.备份yum配置文件 cd /etc/yum.repos.d cp CentOS-Base.repo CentOS-Base.repo.bak 之后修改源配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c052602a59b415f45f43a6b569873d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b92973d745181714efb52c5db8a736/" rel="bookmark">
			3 ARM架构CentOS7系统下：RabbitMQ 、erlang以及socat的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM架构CentOS7系统下：RabbitMQ 、erlang以及socat的安装
#运行Package Cloud提供的RabbitMQ Server快速安装脚本 curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash #运行Package Cloud提供Erlang环境快速安装脚本 curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash #当在Linux系统中使用yum安装软件时提示 “没有可用软件包”时，代表在linux系统#yum源中已经没有对应的安装包了，这时，我们需要安装EPEL。 yum install -y epel-release #使用yum安装Erlang环境 yum -y install erlang #安装socat, logrotate依赖 yum install socat logrotate -y #卸载erlang yum -y remove erlang-* #按官网的提示操作 #使用存储库安装 wget https://packages.erlang-solutions.com/erlang-solutions-2.0-1.noarch.rpm rpm -Uvh erlang-solutions-2.0-1.noarch.rpm #旧的存储库 wget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm #手动添加存储库条目 rpm --import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc #添加到“/etc/yum.repos.d/”目录文件中 vim erlang_solutions.repo [erlang-solutions] name=CentOS $releasever - $basearch - Erlang Solutions baseurl=https://packages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b92973d745181714efb52c5db8a736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7182b346067d76c85668b50be0b9af/" rel="bookmark">
			RuoYi若依框架的使用（新增侧边栏菜单并可以打开）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.12.06今天我学习了如何使用若依框架做一个侧边栏的菜单，并且可以打开对应的页面。
一、菜单管理页面
首先在菜单管理页面新增主目录。
如：
自己设置一个路由地址。
二、新增子菜单
然后在创建好的主菜单中再新增子菜单。
如：
组件路径和权限字符的路径一样。
路由地址对应的是router.js文件中的path.。
三、配置router.js路由
四、效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22475852af4c95cf07562021c4c19109/" rel="bookmark">
			交叉熵损失函数与最大似然估计的关系理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、softmax分类 对于一般的分类问题，已知一共 m m m组样本(sample)，每组样本 n n n个特征(feature)，令每组样本为列向量 x ( i ) ∈ R n \boldsymbol{x}^{(i)} \in R^n x(i)∈Rn， i i i代表第 i i i组样本( i = 1 , 2 , . . . , m i=1,2,...,m i=1,2,...,m)。假设一共有 q q q种类别，我们可以通过一维的输出 y = 1 , 2 , . . . , q y=1,2,...,q y=1,2,...,q来表示不同的分类识别结果。但这种输出方式本质上是由连续回归问题转化而来，对于分类问题，我们有更合适的softmax分类模型。
softmax分类输出维数等于类别数 q q q，其中每个元素对应某特定分类的概率。对于各训练样本的标签 y ( i ) ∈ R q \boldsymbol{y}^{(i)} \in R^q y(i)∈Rq，我们将该样本真实分类对应元素令为1，其余元素令为0，便可将输出拓展为 q q q维。比如我们要对猫、狗、鸡进行分类，猫对应输出可写为 [ 1 0 0 ] \begin{bmatrix}1\\0\\0\end{bmatrix} ⎣⎡​100​⎦⎤​，狗为 [ 0 1 0 ] \begin{bmatrix}0\\1\\0\end{bmatrix} ⎣⎡​010​⎦⎤​，鸡为 [ 0 0 1 ] \begin{bmatrix}0\\0\\1\end{bmatrix} ⎣⎡​001​⎦⎤​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22475852af4c95cf07562021c4c19109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdba835dfdb98c4f8285f1e25e636bde/" rel="bookmark">
			Linux用户和用户组管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux用户和用户组管理 实验目的及要求1.了解用户和用户组文件2.熟悉图形方式进行用户和用户组管理的方法。3.熟悉命令行操作方式进行用户和用户组管理的方法。 实验原理实验步骤1.学习用户和用户组进行管理的方法，分别用命令行和图形方式完成如下步骤:1.添加一个新的用户组Tester。2.添加一个新的用户user999，并将其设为Tester组。3.修改user999的主目录为"/home/test".4.删除user999用户和Tester用户组。5..用图形界面完成上述类似操作。 具体操作1.添加一个新的用户组Tester。2.添加一个新的用户user999，并将其设为Tester组。3.修改user999的主目录为"/home/test"。4.删除user999用户和Tester用户组。5..用图形界面完成上述类似操作。 实验目的及要求 1.了解用户和用户组文件 2.熟悉图形方式进行用户和用户组管理的方法。 3.熟悉命令行操作方式进行用户和用户组管理的方法。 实验原理 在Linux操作系统中，任何文件都归属于某一个特定的用户，而任何用户都隶属于至少一个用户组。全部的用户信息保存为普通的文本文件。/etc/password文件是UNIX安全的关键文件之一。系统使用UID而不是用户名区别用户。任何UID值为0的用户都有root用户(系统管理员)访问权限，具备对系统的完全控制。/etc/group文件包含关于用户组信息。
实验步骤 1.学习用户和用户组进行管理的方法，分别用命令行和图形方式完成如下步骤: 1.添加一个新的用户组Tester。 2.添加一个新的用户user999，并将其设为Tester组。 3.修改user999的主目录为"/home/test". 4.删除user999用户和Tester用户组。 5…用图形界面完成上述类似操作。 具体操作 1.添加一个新的用户组Tester。 groupadd -g 5400 Tester 2.添加一个新的用户user999，并将其设为Tester组。 gpasswd [选项] 组群名 a：添加用户到组；d：从组删除用户；A：指定管理员；M：指定组成员和-A的用途差不多；r：删除密码；R：限制用户登入组，只有组中的成员才可以用newgrp加入该组。 useradd -d /home/test user999 gpasswd -a user999 Tester 3.修改user999的主目录为"/home/test"。 //usermod-修改用户账户 usermod [选项] 用户名 c&lt;备注&gt; 修改用户帐号的备注文字。d登入目录&gt; 修改用户登入时的目录。e&lt;有效期限&gt; 修改帐号的有效期限。f&lt;缓冲天数&gt; 修改在密码过期后多少天即关闭该帐号。g&lt;群组&gt; 修改用户所属的群组。G&lt;群组&gt; 修改用户所属的附加群组。l&lt;帐号名称&gt; 修改用户帐号名称。L 锁定用户密码，使密码无效。s 修改用户登入后所使用的shell。u 修改用户ID。U 解除密码锁定。 usermod -d /home/test user999 #这一步上面设置过了，可以忽略 4.删除user999用户和Tester用户组。 userdel -r user999 #删除user999用户 groupdel Tester #删除组群 5…用图形界面完成上述类似操作。 图形界面操作的话，在这里就不一一截图操作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a882124a03d26e16ef7d87eb015f6f6/" rel="bookmark">
			关于Position:fixed固定定位后遇到问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Position:fixed固定定位后遇到的问题: 首先要理解 fixed 固定定位以后会使其脱离文档流，脱离文档流以后就会漂浮在页面上不会占据空间，导致以后的元素内容会上移，会被脱离文档流的元素遮挡。
解决方法 一般一个网页header部分会遇到这种问题。
1.这里可以给header部分设置高，然后给header一下的元素给margin-top，可以实现两个分开。另外注意position:fixed，一定要设置top：0； left：0:； 不然会引起margin-top无效。
2.在移动端中，给组件的header，或者其他组件下面在加一个div view 标签 然后给一个高度去占据位置
//组件navbar &lt;template&gt; &lt;view class="navbar"&gt; &lt;view class="navbar-fixed"&gt; &lt;view class="navbar-serach"&gt; &lt;view class="navbar-serach_icon"&gt;&lt;/view&gt; &lt;view class="navbar-serach_text"&gt;uni-app vue&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="" style="height: 45px;"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { }; } } &lt;/script&gt; &lt;style lang="scss"&gt; .navbar{ .navbar-fixed{ position: fixed; top: 0; left: 0; z-index: 99; display: flex; justify-content: center; align-items: center; padding: 0 15px; width: 100%; height: 45px; background-color: $mk-base-color; box-sizing: border-box; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a882124a03d26e16ef7d87eb015f6f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a113a74d752ad447adccd018e46494/" rel="bookmark">
			STP的原理和配置（配置详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STP 以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路。但是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现象，从而导致用户通信质量较差，甚至通信中断。为解决交换网络中的环路问题，提出了生成树协议STP（Spanning Tree Protocol）。与众多协议的发展过程一样，生成树协议也是随着网络的发展而不断更新的，从最初的IEEE 802.1D中定义的STP到IEEE 802.1W中定义的快速生成树协议RSTP（Rapid Spanning Tree Protocol），再到最新的IEEE 802.1S中定义的多生成树协议MSTP（Multiple Spanning Tree Protocol）。
stp概述 为什么要有STP 解决二层环路以下问题：
广播风暴MAC地址表不稳定多帧复制 交换机的角色 根网桥：非根网桥 端口角色 根端口指定端口阻塞端口 端口状态 端口状态
说明
Disabled
端口状态为Down，不处理BPDU报文，也不转发用户流量。
Listening
过渡状态，开始生成树计算，端口可以接收和发送BPDU，但不转发用户流量。
Learning
过渡状态，建立无环的MAC地址转发表，不转发用户流量。
Forwarding
端口可以接收和发送BPDU，也转发用户流量。只有根端口或指定端口才能进入Forwarding状态。
Blocking
端口仅仅接收并处理BPDU，不转发用户流量。
实验一：STP的基本配置 实验目的 在交换机中开启STP协议并通过网桥优先级修改STP的根网桥。
实验拓扑 图7-1 STP的配置
实验步骤 步骤1 开启STP 配置LSW1
&lt;Huawei&gt;system-view [Huawei]undo info-center enable [Huawei]sysname LSW1
[LSW1]stp mode stp // STP的模式为STP，默认是MSTP。
配置LSW2
&lt;Huawei&gt;system-view [Huawei]undo info-center enable [Huawei]sysname LSW2
[LSW2]stp mode stp
配置LSW3
&lt;Huawei&gt;system-view [Huawei]undo info-center enable [Huawei]sysname LSW3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87a113a74d752ad447adccd018e46494/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1d89bc845bbbb9ffcf7c32cbd75b82/" rel="bookmark">
			Android密码输入框内容的显示或隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登录页面密码设计增加了密码显示与隐藏的操作，于是按照设计图增加相关逻辑，一下是该逻辑的三种实现方式（本文采用kotlin）：
方式一：
//显示密码 binding.pwdET.inputType = InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD //隐藏密码 binding.pwdET.inputType = InputType.TYPE_TEXT_VARIATION_PASSWORD or InputType.TYPE_CLASS_TEXT 方式二：
//显示密码 binding.pwdET.inputType =0x90 //隐藏密码 binding.pwdET.inputType =0x81 方式三：（推荐使用）
//显示密码 binding.pwdET.transformationMethod = HideReturnsTransformationMethod.getInstance() //隐藏密码 binding.pwdET.transformationMethod = PasswordTransformationMethod.getInstance() 方式一和方式二有一个共同特点：输入密码默认为隐藏，当点击可见之后再隐藏会增加密文之间的间距，如图：
方式三不会有方式一二的增加间距特征（推荐使用），如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d581a9b396fd48ebc655d33a4bd162/" rel="bookmark">
			算法-指针题目oj
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q1:字符串逆序 Description
编写一个函数，功能是使输入的字符串逆序输出。
Input
输入一串字符串,注意字符串中不要有空格。
Output
输出该字符串的逆序。
Sample Input
ABCDEFG Output
GFEDCBA Hint
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int fuction(char *s, int n) { char *p; for(p=s+n-1;p&gt;=s;p--) printf("%c",*p); printf("\n"); return 1; //题目中并未提出对返回值的要求，随便输出1 } int main() { char str[100]; scanf("%s",str); int len; len=strlen(str); int fuction(char *, int); fuction(str,len); return 0; } Q2:又见回文 Description
“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。现在呢，就是让你判断输入的字符串是否是回文串。
Input
有多组输入，每行输入一串字符，保证字符串长度不会大于 100000，字符串由大小写英文字母和空格组成，以字符串“2022”作为结束标志。
Output
每行输出一个字符串，如果输入是回文串，输出“YES”，否则输出“NO”（注意：判断的时候空格是不作判断的,详见样例）
Sample Input
aaaa ggg g lozxvxoMJBCHsTXooXTsHCBJMoxvxzol i am a good acmer 2022 Output
YES YES YES NO Hint
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d581a9b396fd48ebc655d33a4bd162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709a3109ab96e9fe637b72322c25642d/" rel="bookmark">
			AI关键词怎么写？偷懒指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元宇宙·知识库限量优惠券
本期是#NFT杂志的N3期，介绍了一种AIGC的工作流。
我们知道Prompt工程，需要做大量的实验，研究不同词语的组合效果，要求使用者的词汇量和大量的时间(算力)。
好在有另一项技术，可以从图片里直接反向推理出prompt词，为我们调配新的风格节省大量的时间。于是工作流就变成了到素材网，找风格的灵感，然后通过CLIP Interrogater提取出prompt后，再进行实验。此流程可以节省不少时间。
前面演示的工作流程:图片-&gt;文字-&gt;图片，由于不是端到端的模型，肯定会存在信息的损失。此方法，风格与原图存在差距，得到的结果可以作为初始风格，再通过不断实验来调配出理想风格。
除了在实验prompt词的时候可以“偷懒”，我们还可以自行训练属于自己的提示词--自定义提示词。
Stable Diffusion Conceptualizer，提出了自定义提示词的方法。预训练了上百种风格的自定义词，只需3-5张图片即可完成模型的微调训练。
更多请关注下一期～
#往期
软件3.0#未来职业之提示工程师
原罪？人工智能生成代码#GitHub Copilot遭集体起诉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11e38f0c722c5cf5047bb7820690467/" rel="bookmark">
			数据湖架构落地实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与传统的数据架构要求整合、面向主题、固定分层等特点不同，数据湖为企业全员独立参与数据运营和应用创新提供了极大的灵活性，并可优先确保数据的低时延、高质量和高可用，给运营商数据架构优化提供了很好的参考思路。
运营商数据架构的现状及挑战
从数据的系统归属上看，运营商数据可分为MSS（管理支撑系统）的面向人、财、物管理类数据，BSS（业务支撑系统）的面向客户和产品的营销及客户服务数据，OSS（运营支撑系统）的面向产品和网络的功能及运营服务数据，三者之间既相对松耦合，又有着紧密的协作关系，BSS和OSS的衔接点主要在产品及开通、排障服务，MSS和BSS、OSS的衔接点主要在参与人和资源。从数据分类来看，运营商的数据可分为作为企业核心的功能类实体数据、表示企业所有运营过程的活动类数据、体现内外部客户感知并围绕两大主线所产生的感知类指标数据以及与管理相关的人、财、物及流程数据。电信运营商数据范围示例如图1所示。
由于国内运营商以两级经营模式为主体，系统的集约化建设程度相对较低，以分域（M/B/O）、分省建设为主，即便是同类系统的数据，因为分31个省市建设，各省市的业务管理模式、数据模型标准、主数据等千差万别，跨省、跨域、跨系统的模型标准统一非常困难，即便通过数据副本的模式进行整合汇聚，也存在转换不专业和数据失真等问题。同时，域与域之间虽是松耦合的，但因为使用者和建设者的不同，相互之间会冗余存储对方数据，而建模和主数据又不同，跨域之间数据的关联整合非常复杂，跨域、跨省的端到端应用困难。
运营商的数据还有一个显著的特点，就是与网络密切相关，网络运行数据和网络拓扑数据需要与网络保持实时一致，且数据量比较大，网络智能化后的实时数据应用需求也越来越多。通信网络是一张大网，即便引入云计算、虚拟化技术，依然有大量网络节点遍布31个省市，海量网络数据的实时采集、处理及应用也是运营商数据架构需要考虑的一个重要因素。
国内运营商目前都不同程度地建立了自己的企业级大数据平台，有的分总部/省两级部署，支撑两级数据分析，统一全网的架构、来源、算法、规则，总部数据轻度汇总，按需采集汇聚高价值详单数据；有的采用1+N模式，建设总部和省互补协作平台，总部提供跨域数据和特定的大数据能力，作为N的省向总部提供本地化数据能力与自定义算法。电信运营商数据平台架构示例如图2所示。
不管采用哪种模式，都不同程度地存在其下属各专业公司、各部门根据各自需要，或在生产系统内构建含大数据技术的混搭数据架构，或建设域内自用的大数据平台，因此有很多数据未进入企业级大数据平台，或数据平台的应用未达到预期。其原因可归结为如下几点
平台数据质量不高
平台数据来自于M/B/O的生产系统，而运营商分两级31省市建设的生产系统，不但数据模型、主数据标准不统一，业务管理模式的差异也很大。数据经过多次模型转换，存在严重失真的问题，且很难对数据质量问题追踪溯源。
平台数据不够实时
数据经过多级采集汇聚，处理环节多，采集周期长。网络相关海量数据跨省传输，占用大量带宽，数据时延较大。数据平台目前只能以支撑离线的决策分析为主，难以满足SDN/NFV/云网络及物联网等实时/准实时数据应用需求。
平台的灵活性不足
数据平台的建设以存储计算一体化架构为主，平台与应用紧耦合，多基于公共数据平台和整合后的数据支撑应用创新。对于新的数据整合、数据计算分析技术引入、平台扩容支撑等需求响应不灵活，导致数据平台应用不足。
平台和应用互锁，形成恶性循环
企业级数据平台难以满足生产系统数据应用需求，生产系统就没有动力将自身数据和应用迁入数据平台，进而数据平台的数据质量和可用性越来越差。同时，还导致生产系统和各个大数据平台的数据重复采集、重复存储，且相互之间数据访问技术和管理壁垒严重，建设和维护成本大幅提高。
数据湖方案的价值及可行性分析
数据湖推崇存储原生数据，对不同结构的数据统一存储，使不同数据有一致的存储方式，在使用时方便连接，真正解决数据集成问题。数据湖的本质是一种数据管理的思路，利用低成本技术来捕捉、提炼和探索大规模、长期的原始数据存储的方法与技术。数据湖可存储任何种类的数据，高质量、高效率地存储数据，更快速、更廉价地处理数据，将建模应用问题丢给最终开发者。
数据湖的方案应用可以带来如下几个显著的好处
规模大、成本低
全企业海量数据统一存储，采用开源技术，基于低成本硬件资源，建立和维护成本相比数据仓库低一个数量级。
数据“原汁原味”
数据湖以原始形式保存数据，并在整个数据生命周期捕获对数据和上下文语义的更改，尤其便于进行合规性和内部审计。如果数据经历了转换、聚合和更新，将很难在需求出现时将数据拼凑在一起，而且几乎没有希望确定清晰出处。
数据方便易用
结构化、非结构化、半结构化的数据都是原样加载和存储，以后再进行转换，开发和保存成本低，产生和使用之间时延小。客户、供应商和数据运营者不需要数据拥有者提供太多帮助即可整合数据，消除了数据共享的内部政治或技术障碍。
应用按需建模
数据湖提供数据给灵活的、面向任务的结构化应用，详细的业务需求和艰苦的数据建模都不是数据湖的先决条件。数据湖给予最终用户最大的灵活度来处理数据，对于同一份原始数据，不同的用户可能有不同的理解。
目前，大部分运营商采用传统的以数据为中心的处理架构（存储计算一体化，如主流MPP、Hive和分布式计算厂商产品），好处是计算效率高、技术成熟，缺点也很明显，如灵活性不足，使得数据应用适用于少数人，这也制约了原生数据提供者向平台提供的积极性，进而导致数据的质量、数据的全面性都得不到很好的保障。
引入数据湖概念的一个显著特点就是存储和计算松耦合，可采用以计算为中心的处理模式（存储与计算分离，如Spark技术及AWS、阿里云等云服务提供商产品），使得运营商可以更加专注于数据的存储和管理，存储和计算不用相互制约，从而优先确保数据的高质量、低时延、高可用，并为数据应用的快速构建提供了极大的灵活性。
数据湖按照成熟度可划分为4个阶段：
第一个阶段，应用程序独立建设，部分应用将数据提供给数据仓库，基于数据仓库构建分析应用；
第二个阶段，数据湖和数据仓库并存，应用程序向数据湖提供副本数据，基于数据湖开发分析型应用，数据仓库和应用也可从数据湖提取数据；
第三个阶段，新系统以数据湖为中心构建，应用通过数据湖交互彼此数据，数据湖成为数据架构的核心，数据仓库基于数据湖提供特定的应用需求，数据治理变得重要；
第四个阶段，所有新的应用均基于数据湖构建，数据湖成为弹性的分布式平台，数据的治理和安全需持续加强，支撑企业的数据运营和分析能力。
电信运营商目前普遍处于第二个阶段向第三个阶段演进的过程中，在构建数据技术方案方面具备较好的基础条件。
电信运营商数据湖建设思路及实施要点
调整现有分析型数据平台建设思路，将其数据与应用解耦，引入数据湖概念，强调原生数据入湖，并与全网生产系统模型和主数据标准化协同推进，兼顾层次化的传统数据架构和扁平化的数据湖架构的优点，SchemaonRead和SchemaonWrite并存，统一支撑企业实时、准实时和离线数据应用快速创新，是电信运营商实现以数据为中心IT架构转型的有效途径。
数据湖作为运营商数据存储和访问的唯一出口，成为所有IT系统共享的基础设施，统一存储全企业IT和网络数据，通过开放架构支撑智慧运营，并可作为IT系统集约化演进的纽带。
数据统一存储
统一存储MSS、BSS、OSS及网元平台的实时、历史、在线、离线数据，全网的原生数据只存储一份在逻辑统一的分布式数据湖内，原生数据与生产系统数据模型标准和主数据一致，新IT系统/网元平台的生产数据直接使用数据湖存储。
数据统一管理
所有入湖数据的目录、元数据、数据应用及数据质量、数据标准、数据安全必须统一管理。数据模型标准和主数据动态维护，数据质量集中治理，原生系统的数据问题溯源处理，生产系统建设者全程参与数据管理，责任权利保持一致。
数据统一标准
生产系统管理部门负责31省市系统模型和主数据的标准化；数据湖统一管理生产系统的数据模型及主数据；暂未进行标准化的生产系统数据模型，由对应系统的管理部门负责数据模型的转换和运营，协调推进生产系统数据标准进程。
数据近源采集
提供数据统一采集、实时订阅分发框架，支撑实时/准实时数据、离线数据的采集。各网元/平台数据采集能力以组件方式纳入数据湖，分专业采集、预处理加工，海量实时数可靠近网络近源部署前置采集模块。非网络类数据（如BSS、MSS、OSS流程等），初期以副本采集方式汇聚入湖，远期直接以服务交互方式入湖。
数据与应用分离
数据应用环境与数据存储环境分离，按应用计算的网络带宽需要就近部署。提供统一的服务化访问、小批量数据订阅、数据分析计算云平台环境。基于云平台环境，应用开发者可自行整合数据、构建应用，数据存储、数据整合、平台组件、数据应用间相互解耦，建设的进程不会相互制约。
同时，建立全生命周期数据目录，统一标识各项数据，完善数据治理机制，管理数据湖数据的生产加工流程，对各项数据生成和使用过程进行跟踪记录，支撑数据的应用和溯源，是数据湖方案顺利实施的关键要素。并且还需要加强数据标准的全生命周期流程以及数据标准的元数据及数据质量问题收集、自动稽核、问题溯源、影响分析及跟踪处理等数据管理能力。可以采用爬虫的方式生成数据目录，在不影响数据所有者或用户的情况下自动生成，
决定数据湖能否顺利实施的因素有很多，包括数据湖涵盖哪些数据及如何分区存储、数据湖如何分布式部署、纷繁复杂的现有IT系统数据如何入湖、数据和应用能否分离、数据湖与现有各类数据平台的演进关系等。当然，更重要的是数据管理思维的转变，这是一切的基础。
针对运营商数据湖的实施，提出如下4个方面的关键要点及建议。
要点1：数据湖分区
数据湖逻辑上可划分为生产数据区、原生数据区、整合数据区、汇总数据区4个大的存储区域。数据湖的应用可基于PaaS平台按需使用各个区的数据，4个区的数据目录、元数据、数据加工处理流程及数据应用需要统一管理、维护和治理。
生产数据区
M/B/O系统生产数据的存储区域，涵盖实时交易型数据、实时/准实时网络采集数据等，可以是关系型和非关系型混搭的存储结构，各生产系统需要进行架构优化，数据与应用分层解耦，将数据存入生产数据区。
原生数据区
将各系统的生产数据直接写入数据湖原生数据区，以非关系型数据格式存储生产系统数据，方便各数据应用使用，生产数据和原生数据模型标准、主数据一致。原生数据区涵盖企业的任何内容，无限接近企业各系统、部门的敏感信息。供数据湖科学家和技术人员访问使用。
整合数据区
存储按照数据分析需求建模加工后的公用数据。模型从生产/原生数据模型派生而来，被业务和IT部门熟知，可供企业各种应用程序使用。原生数据区中依然有很多数据或属性没有被真正理解，并未完全包含在这个数据区的模型中。
汇总数据区
存储按需求分析汇总的结果数据，一般可存储在关系型数据存储内，便于数据服务的快速加载呈现。
数据湖生产数据区和原生数据区作为最重要的数据分区，是数据湖内数据整合和汇总的源头数据，数据质量必须得到保障。另外，数据湖虽不鼓励应用特定模型，但也可划分特定数据区给私有应用使用，提供快速构建数据应用的途径，这些应用获取数据湖数据且具有数据处理能力，数据湖构建初期，可将已有业务应用数据导入数据湖特定数据区中。电信运营商数据湖数据分区示例如图4所示。
要点2：数据湖部署
数据湖部署方案的设计需要考虑如下要素：
现有BSS/OSS系统分省/总部两级建设和维护，源系统模型属地管理；网络/平台数据量大，且贴近网络建设归属地，属地应用占比大；
M/B/O及网络/平台之间数据松耦合，主要通过企业主数据进行衔接。数据湖原生数据区和生产数据区与数据源系统就近分布式部署（总部1+省市31模式）。
生产数据云节点由生产系统按需分区、分片部署，即支撑生产应用交易处理，也支撑实时网络数据采集和应用。
原生数据云节点与生产数据云节点就近、集中部署，靠近数据归属地，数据实时从生产数据云节点写入原生数据云节点。原生数据云节点可再细分为核心数据区（如客户、销售品、产品、服务、资源、组织、人员等）、BSS数据区、OSS数据区、MSS数据区、网络/平台数据区。
数据湖整合、汇总数据云节点采用1+N模式部署，统一管理、控制和调度节点环境，兼顾全网统一和个性化应用需求，数据科学家逐步探索和建模数据，开放数据应用。1+N模式中的“1”支撑全网应用，“N”支撑省内应用，并作为创新基地，有条件、数据量大、应用丰富的省可选择建设N分区。分区节点内可按照应用范围（全局需求、特定需求）、地域归属（集团、省）、数据层次（整合、汇总）、数据分级（普通、密级）等进一步分区存储。
电信运营商数据湖部署方案示例如图5所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a11e38f0c722c5cf5047bb7820690467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0d8879baeecf38ecc6d017a5faef5d1/" rel="bookmark">
			CN_@物理层@信噪比@分贝单位@奈奎斯特定理@香农公式@常用编码方式(曼彻斯特编码/差分曼彻斯特编码)波形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CN_@信噪比@分贝单位@奈奎斯特定理@香农公式@常用编码方式(曼彻斯特编码/差分曼彻斯特编码)波形图通信基础概念数据 (data)信号 (signal)基带信号模拟信号 (analogous signal)数字信号 (digital signal) 信道和通信电路狭义信道的分类广义信道信道和通信电路有所区别 信源与信宿载波carrier码元 (code) 🎈码元的离散电平值@码元状态数为V🎈例 码元传输速率信息传输速率🎈以太网速率表示 编码@调制调制分类：基带调制：带通调制：数字调制&amp;模拟调制 编码方式数字数据编码为数字信号1)归零编码2)非归零编码3)反向非归零编码4)曼彻斯特编码5)差分曼彻斯特编码6)4B/5B编码数字数据调制为模拟信号模拟数据编码为数字信号采样采样定理(奈奎斯特定理)采样和速率🎈例例 量化编码例 模拟数据调制为模拟信号 通信数据交换电路交换优点缺点 报文交换分组交换分组交换的优点：分组交换的缺点：例例 @数据报和虚电路和传输媒介的比较 信道复用技术频分复用FDMref波分复用 WDM(Wavelength Division Multiplexing) 时分复用TDM统计时分复用 STDM (Statistic TDM) 码分复用 CDM (Code Division Multiplexing)@码分多址CDMA小结🎈 码片序列(chip sequence)码片正交正交性质例 传输方式基带传输频带传输🎈宽带传输 分贝(dB)计算方法功率量下的分贝计算使用分贝有很多便利之处 信噪比香农定理@香农公式例: 奈奎斯特准则波特率形式比特率形式奈奎斯特频率 总结🎈🎈速率有限性对比两个定理综合:低通信道的极限传输速率🎈🎈叮咛嘱咐W和2W周期内的脉冲数/电平数 CN_@信噪比@分贝单位@奈奎斯特定理@香农公式@常用编码方式(曼彻斯特编码/差分曼彻斯特编码)波形图 通信基础概念 数据 (data) 运送消息的实体 信号 (signal) 数据的电气的或电磁的表现是数据的具体表现形式 基带信号 基本频带信号,来自信源的信号 像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号 基带信号往往包含有较多的低频成分,甚至有直流成分, 而许多信道并不能传输这种低频分量或直流分量因此必须对基带信号进行调制 (modulation) 模拟信号 (analogous signal) 代表消息的参数的取值是连续的 数字信号 (digital signal) 代表消息的参数的取值是离散的 信道和通信电路 信道 (wikipedia.org) 信道、频道或波道,是信号在通信系统中传输的通道,由信号从发射端传输到接收端所经过的传输媒质所构成广义的信道定义除了包括传输媒质,还包括传输信号的相关设备信道与电路并不等同,信道是信号的传输媒介。一个信道可视为一条线路的逻辑部件,一般用来表示向某个方向传送信息的介质 因此一条通信线路往往包含一条发送信道和一条接收信道。 噪声源是信道上的噪声（即对信号的干扰）及分散在通信系统其他各处的噪声的集中表示。 狭义信道的分类 狭义信道,按照传输媒质来划分,可以分为有线信道、无线信道和存储信道三类 广义信道 按照其功能进行划分,可以分为调制信道和编码信道两类.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0d8879baeecf38ecc6d017a5faef5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a440cdbae2aa857cc98ec2332de5eb/" rel="bookmark">
			Day42&amp;&amp;43——分割等和子集、1049. 最后一块石头的重量 II 494. 目标和 474.一和零 （动规）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断了很久了，疲惫，垃圾期末
目录
前言
一、分割等和子集
解题思路：
二、最后一块石头的重量 II
解题思路：
三、目标和
解题思路：
四、一和零
解题思路：
总结
前言 人生就是这样，总有一天会明白一切，只是这时候再不能回到以前。人生，有时候，就是想大哭一场，因为心里憋屈。有时候，就是想疯癫一下，因为情绪低落。有时候，就是想破口大骂，因为心里不爽。有时候，就是想安安静静，因为真的我累了
一、分割等和子集 力扣
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
解题思路： 数组的元素能不能对半分成等和集合，那就是背包能不能装到数组元素和的一半，价值=空间，装满的时候是不是等于目标值。
class Solution { public: bool canPartition(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt;dp(10001,0); int sum=0; for(int i=0;i&lt;nums.size();i++) { sum+=nums[i]; //求出和 } int target=sum/2; //一半，是空间也是目标价值 if(sum%2!=0) //如果是奇数都没有办法分成两份，直接错了 { return false; } for(int i=0;i&lt;nums.size();i++) //遍历物品 { for(int j=target;j&gt;=nums[i];j--) //遍历背包，从后往前 dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]); //找出最大值 } if(dp[target]==target) //因为价值等于容量，背包装满的时候，理论上价值也会一样 return true; return false; } }; 二、最后一块石头的重量 II 力扣
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a440cdbae2aa857cc98ec2332de5eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f585b27035787ceae7f4cfbd1c42312/" rel="bookmark">
			鸢尾花数据种类预测、分析与处理、scikit-learn数据集使用、seaborn作图及数据集的划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、鸢尾花种类预测 Iris数据集是常用的分类实验数据集，由Fisher, 1936收集整理，Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集
鸢尾花数据集包含了
4个属性（特征值） Sepal.Length（花萼长度），单位是cmSepal.Width（花萼宽度），单位是cmPetal.Length（花瓣长度），单位是cmPetal.Width（花瓣宽度），单位是cm3个种类（目标值）： Iris Setosa（山鸢尾）Iris Versicolour（杂色鸢尾）Iris Virginica（维吉尼亚鸢尾） 该虹膜数据集包含150行数据，包括来自每个的三个相关鸢尾种类50个样品：又称为山鸢尾，虹膜锦葵和变色鸢尾
从左到右，Iris setosa (由 Radomil, CC BY-SA3.0)，Iris versicolor (由Dlanglois, CC BY-SA 3.0)和lris virginica(由Frank Mayfield, CC BY-SA 2.0) )
二、scikit-learn中数据集介绍 scikit-learn数据集API介绍
sklearn.datasets：加载获取流行数据集 datasets.load_*()：获取小规模数据集，数据包含在datasets里，安装sciki-learn时已下载，直接调用datasets.fetch_*(data_home=None)：获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录,默认是 ~/scikit_learn_data/sklearn小数据集 sklearn.datasets.load_iris()：加载并返回鸢尾花数据集sklearn大数据集（以下为新闻数据集） sklearn.datasets.fetch_20newsgroups(data_home=None,subset=‘train’) subset：'train'或者'test'，'all'，可选，选择要加载的数据集，训练集的“训练”，测试集的“测试”，两者的“全部”sklearn数据集返回值：load和fetch返回的数据类型datasets.base.Bunch(字典格式) data：特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组target：标签数组，是 n_samples 的一维 numpy.ndarray 数组DESCR：数据描述feature_names：特征名，新闻数据，手写数字、回归数据集没有target_names：标签名 代码如下
from sklearn.datasets import load_iris, fetch_20newsgroups # 数据集获取 iris = load_iris() # 小数据集获取 # news = fetch_20newsgroups() # 大数据集获取 # print(news) # print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f585b27035787ceae7f4cfbd1c42312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25377e1e236409c92261af7a14cc29f4/" rel="bookmark">
			网络技术之链路聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是链路聚合？
链路聚合即是将多条链路捆绑在一起，形成一条聚合链路，此聚合链路的带宽理论上是所有活动链路的带宽之和，同时避免单条链路中以后，网络故障。
链路聚合的作用？
增加带宽，提高可靠性
链路聚合包含两种模式？
手动负载均衡模式与LACP模式。
手动负载均衡模式：Eth-trunk的建立，成员接口的加入由管理人员手工加入，没有链路聚合控制协议的参与。这种模式下所有的链路都参与数据的转发，平均分摊流量，因此称为负载均衡模式。如果某一条活动链路故障，自动在剩余的所有活动链路中均分流量，当需要在两个直连的设备之间提供较大的传输带宽，而设备又不支持LACP协议时，可以使用手动负载分担模式。
LACP模式：LACP两端的设备相互发送LACP报文，协商聚合参数，两台设备确定活动接口与非活动接口。在LACP模式当中，需要手动创建一个Eth-trunk，并添加成员接口，LACP协商选举活动接口与非活动接口。LACP模式也成为M:N模式，M代表活动成员链路，用于数据转发；N代表冗余链路，用于数据备份；如果一条活动链路发生故障，该链路的数据自动被切换到一条优先级高的备份链路上，此时备份链路转为活动链路状态。
手工负载分担模式与LACP模式的区别在于：手工负载分担模式中，所有的链路都参与数据转发，而LACP模式中，某些链路处于备份状态
链路聚合的注意事项：
在一个聚合口中，聚合链路两端的成员端口参数必须一致，接口数量、传输速率、双工模式、流量控制模式。成员接口可以是二层接口或者三层接口。
使用二层端口配置手工负载均摊模式（每个厂家命令不一样，这里以华为模拟器做实验）
手工负载均衡模式配置：两台交换机配置一样
[Huawei]interface Eth-Trunk 1 #配置链路聚合
[Huawei-Eth-Trunk1]trunkport Ethernet 0/0/1 to 0/0/3 #配置聚合链路成员端口
[Huawei-Eth-Trunk1]port link-type trunk #配置链路聚合的类型为中继链路
[Huawei-Eth-Trunk1]port trunk allow-pass vlan all #允许所有vlan透传
此时down掉任何一个端口或者任何一条链路故障都不会引起故障。只有所有端口或者所有链路故障才会发生故障
LACP模式配置：两台交换机配置一样
[switch-a]interface Eth-Trunk 1 # 配置链路聚合
[switch-a-Eth-Trunk1]mode lacp # 配置链路聚合的模式为lacp
[switch-a-Eth-Trunk1]trunkport Ethernet 0/0/1 to 0/0/3 #配置成员端口
[switch-a-Eth-Trunk1]quit #退出
[switch-a]interface Eth-Trunk 1 #进入聚合链路接口视图
[switch-a-Eth-Trunk1]max active-linknumber 2 #设置最大活动链路为2
[Huawei-Eth-Trunk1]port link-type trunk #配置链路聚合的类型为中继链路
[Huawei-Eth-Trunk1]port trunk allow-pass vlan all #允许所有vlan透传
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25377e1e236409c92261af7a14cc29f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76146df3e64183b4fff4843ef408fa1c/" rel="bookmark">
			【第6章】pandas分块读取文件（nrows、chunksize）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pandas全局设置显示最多的行数 #7、设置显示行数为10行 pd.options.display.max_rows=10 # 7-1、读取行只有10条 pd.read_csv(Path('../源代码/examples/ex6.csv')) """ one	two	three	four	key 0	0.467976	-0.038649	-0.295344	-1.824726	L 1	-0.358893	1.404453	0.704965	-0.200638	B 2	-0.501840	0.659254	-0.421691	-0.057688	G 3	0.204886	1.074134	1.388361	-0.982404	R 4	0.354628	-0.133116	0.283763	-0.837063	Q ...	...	...	...	...	... 9995	2.311896	-0.417070	-1.409599	-0.515821	L 9996	-0.479893	-0.650419	0.745152	-0.646038	E 9997	0.523331	0.787112	0.486066	1.093156	K 9998	-0.362559	0.598894	-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76146df3e64183b4fff4843ef408fa1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216358ca4bf43c5c8fc675dd6414fc63/" rel="bookmark">
			ES6-基础语法三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6-基础语法三 1. Set1.1. set基础1.2. set 实战练习 2. Map 1. Set ES6 提供了新的数据结构 Set（集合 。它类似于数组，但成员的值都是唯一的 ，集合实现了 iterator接口，所以可以使用『扩展运算符』和『 for…of…』进行遍历，集合的属性和方法：
size 返回集合的元素个数add 增加一个新元素，返回当前集合delete 删除元素，返回 boolean 值has 检测集合中是否包含某个元素，返回 boolean值clear 清空集合，返回 undefined 1.1. set基础 // state a set let s = new Set(); // state a set with initial value let s2 = new Set(['Lisa', 'jisoo', 'rose', 'jenny']) // size of set console.log(s2.size) // 4 // add new element s2.add('michael') console.log('s2 after adding a new element', s2) // s2 after adding a new element Set(5) { 'Lisa', 'jisoo', 'rose', 'jenny', 'michael' } // delete element s2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216358ca4bf43c5c8fc675dd6414fc63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0476128dcfac179c7d9ebae723be7657/" rel="bookmark">
			C&#43;&#43;：函数指针进阶(二)：指向对象成员函数的指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：普通函数函数指针定义 我们知道 指向普通函数的指针，一般这么定义 ：
数据类型名 (* 指针变量名)（参数列表）
void (*func)(int)
或者前面加一个 typedef typedef 数据类型名（*指针变量名）（参数列表）
typedef void (*funv) (int)
这两种方式都可以，但是建议使用第二种方式：因为第二种方式相当于给 函数指针定义了一个别名，能隐藏笨拙的语法构造以及平台一些相关的数据类型，可以使得代码更美观，可维护性、可移植性、可读性更强。
实例：
如果不带 typedef 关键字
//定义一个函数 void tech(void) { printf("tech dreamer"); } void main() { //定义一个指针，指针的名字叫func，它可以指向一个函数，并通过函数指针调用该函数 void (*func)(); func = &amp;tech; // 将func()函数的入口地址赋给指针变量pf，所以，pf就指向func()函数 func(); //第一种调用方式，带参数也可以 (*func)(); //第二种调用方式，带参数也可以 } 增加 typedef 关键字 void tech(void) { printf("tech dreamer"); } //命名一个类型，那么这个时候func不可以直接调用，而是一个类型了 typedef void (*func)(); void main() { //定义一个可调用的指针变量（函数）：myfunc （这个是主要区别） func myfunc; myfunc = &amp;tech; //将func()函数的入口地址赋给指针变量pf，所以，pf就指向func()函数 myfunc(); //第一种调用方式，带参数也可以 (*myfunc)(); //第二种调用方式，带参数也可以 } 2：对象成员函数函数指针定义 标题1介绍了，普通函数函数指针的定义，对象成员函数指针定义情况相比要复杂一些。 那么复杂在哪里了？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0476128dcfac179c7d9ebae723be7657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb6a5bf374c46506b05f46ba0a34135c/" rel="bookmark">
			vue3element如何通过表格外的按钮来控制表格内部的所有状态全选全不选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要在vue3ui框架的表格外部来控制表格内部的所有状态的话，需要获取到表格的实例来进行控制。vue3如何获取表单的实例呢？
&lt;template&gt; &lt;div&gt; &lt;el-table ref="multipleTableRef" :data="state.carlist" style="width: 100%" @selection-change="handleSelectionChange"&gt; &lt;el-table-column type="selection" width="55" /&gt; &lt;el-table-column prop="name" label="商品名称" /&gt; &lt;el-table-column prop="dic" label="商品描述" /&gt; &lt;el-table-column prop="price" label="商品价格" /&gt; &lt;el-table-column prop="" label="商品小计"&gt; &lt;template #default="scope"&gt;{{ scope.row.price * scope.row.num }}￥&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label="Date" lable="购买数量"&gt; &lt;template #default="scope"&gt; &lt;el-input-number style="width: 150px;" v-model="scope.row.num" :min="1" :max="10" /&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;p&gt; &lt;span&gt; &lt;input type="checkbox" v-model="state.allflag" @click="all"&gt; 全选 &lt;/span&gt; &lt;span&gt;总价：{{ getters.num.price }}&lt;/span&gt; &lt;span&gt;总数：{{ getters.num.num }}&lt;/span&gt; &lt;el-button type="danger" @click="commit('delok')"&gt;删除选中&lt;/el-button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup &gt; import { useStore } from 'vuex'; import { ref } from 'vue'; const { state, commit, getters } = useStore() const multipleTableRef = ref() //选中的 const handleSelectionChange = (val) =&gt; { commit('oklist', val) } const all = () =&gt; { multipleTableRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb6a5bf374c46506b05f46ba0a34135c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddcc939fc64953ff70fc24de489cba86/" rel="bookmark">
			[LUA】元表、元方法、面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、元表二、元方法三、面向对象总结 前言 面试腾讯的时候有问到lua的内容，其中主要集中在热更新和元表、元方法上面，因为踩过了坑所以打算写一篇来记录一下
一、元表
本篇介绍的是元表、元表table是lua中唯一的数据结构，table在我使用来说可以当成很多东西，能够实现类、继承、又能像结构体，table里面能够添加任意元素
t= { a = 10, b = 100, c = "abc" } 这样table就有点像结构体
二、元方法 元方法的存在是为了让我们的元表之间能够相互交互，元方法能够让被赋予的元表之间能够执行特定操作
t = { a = 10, b = 100, c = "abc" } mt = { __add = function(a,b) return a.a + b end, } setmetatable(t, mt) print(t + 2) 其中mt为元方法，setmetatable的方法会将mt中的方法赋予给t元表，这样的话t方法就能够进行操作，这里是lua文档，详细的元方法内容可以看lua文档，在我看来有点像回调，元方法其实是元表，但是在里面写的是函数方法，有需要的元表能够订阅元方法，要注意一点，只有订阅了相同元方法的元表之间才能够相互交互，不然会返回nill或者报错,元表里面还能够在表里面写自己的函数
t = { a = 10, b = 4, c = "abc", __my = function(a,b) return a + b end } print(t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddcc939fc64953ff70fc24de489cba86/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/113/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>