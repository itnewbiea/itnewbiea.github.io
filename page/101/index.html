<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350b2a34b7a96e6eb6afd5c8b2410f21/" rel="bookmark">
			前端开发人员使用的顶级 Node.js 框架介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发人员使用的顶级 Node.js 框架介绍 前端开发人员使用的顶级 Node.js 框架介绍1. 为什么要使用框架？2. Node.js 框架的类型2.1 HTTP Server 框架2.2 MVC 框架2.3 全栈 MVC 框架2.4 REST API 框架 3. 一些统计数据4. Express4.1 Express 特点和优势4.2 Express 的缺点4.3 什么时候使用 Express？ 5. Koa5.1 Express 和 Koa 的区别5.2 Koa 特点5.3 Koa 的优势5.4 Koa 的缺点5.5 什么时候使用 Koa？ 6. Socket.io6.1 Socket.io 的特点6.2 Socket.io 的优势6.3 Socket.io 的缺点6.4 什么时候使用 Socket.io？ 7. Fastify7.1 Fastify 的特点7.2 Fastify 的优势7.3 Fastify 的缺点7.4 什么时候使用 Fastify？ 8. NestJS8.1 NestJS 的特点8.2 NestJS 的优势8.3 NestJS 的缺点8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350b2a34b7a96e6eb6afd5c8b2410f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce4911d017d74155dd70bc867f3cb81/" rel="bookmark">
			OpenCV实例解析（OpenCV初学者）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、计算机视觉
1.定义：给计算机安装上眼睛（照相机）和大脑（算法），让其能感知周围的环境。它是对生物视觉的一种模拟，通常的做法是通过对采集的图像或视频进行处理来获得相应场景的三维信息。
2.应用： 计算机科学和工程、信号处理、物理学、应用数学和统计学
3.OpenCV不但能够实时运行许多不同的计算机视觉算法（高度优化），而且几乎可以兼容所有的平台。OpenCV是开发计算机视觉最流行的库之一。它使我们能够实时运行许多不同的计算机视觉算法。
二、本书主要内容
1.各种操作系统的 安装步骤，介绍人类视觉系统，以及计算机视觉视觉中主要的各种内容。
2.如何在OpenCV中读/写图像和视频，并且介绍如何使用Cmake建立一个项目。
3.介绍如何通过创建一个图形用户界面和鼠标事件检测器来实现交互式应用程序。
4.直方图和滤波器，演示如何卡通化图像。
5.描述各种图像的预处理技术，如如何去噪声、阈值化，以及轮廓分析。
6.处理对象识别和机器学习，并学习如何使用支持向量机建立一个对象分类系统。
7.讨论人脸检测和Harr级联，并解释如何使用这些方法来检测人脸的各个部分。
8.探索背景差分、视频监控和形态学图像操作，并描述它们如何彼此关联。
9.如何使用不同的技术跟踪对象，如基于颜色和基于特征。
10.介绍光学字符识别、文本分割和Tesseract OCR引擎。
11.深入研究Tessertact OCR引擎，介绍如何将它应用于文本检测、提取和识别。
下载本书事例代码
第1 章 OpenCV的探险之旅
1.1理解人类视觉系统
一、人类的视觉系统
1.特点
人类视觉对低频内容敏感程度高于高频内容。低频内容（像素值不迅速改变的平面区域）高频内容（像素值波动很大的角落和边缘区域）人眼敏感度：亮度变化&gt;颜色变化对运动事物敏感。如有东西在视野中运动，即时没有直视，也很快意识到。往往用心记住视野内突出的点。 2.看不同事物的角度
3.人类如何理解图像内容
（1）趋于通过形状和一些重要特征记忆一个对象。大脑创建了可以帮助我们稳健有关位置、缩放和角度方面的不变性层次结构。
（2）很多细胞在视觉皮层。如人轻松识别椅子。
4.机器难以理解图像内容？
（1）形状、尺寸、观点、角度、光线、遮挡。如机器眼里，同样的椅子从侧面看不一样。
（2）一种解决方法：将一个对象的变化存储起来，包括大小、角度、光线等，但很费时且不能将遇到的每一种变化收集起来。当有特殊遮挡时，也无法识别。
（3）构建基本功能块，在各种情况下结合成复杂的算法，OpenCV提供很多功能。可以高效使用它创建有趣的应用。
二、OpenCV可以做什么
1.做很多可以想象出的计算机视觉任务。需要理解哪些函数和模块能达到预期的效果。
2.可以立即使用的方法：
（1）内置数据结构和输入、输出
OpenCV中提供大量内置基元去处理涉及图像和计算机视觉的操作。如果从零开始写，需要定义一些对象包括图像、点、矩阵等。OpenCV中愿意提供基本框架。
imgcodecs模块处理图像文件的读写。当处理图像和创建图像文件时，你可以通过简单的命令将图像保存为PNG或者JPG格式文件。当使用摄像头时 需要处理大量的视频文件。
videoio模块可以处理视频文件所有读写相关的操作。
（2）图像处理方法
当编写计算机视觉算法时，会有一堆反复使用的基本图像处理操作。
imgproc模块：大部分函数。可以处理如图像滤波，形态学操作，几何变换，色彩变换，绘制图像，结构分析，直方图，形状分析等。
ximproc 模块：处理高级用户交互操作。创建用于展示图像或者视频的窗口等一系列函数。还包括等待功能，当用户触发键盘才进行下一步操作。还有一个函数可以检测鼠标移动，可以在输入窗口中绘画长方形，处理被选择的区域。
（3）视频分析
包括分析视频中的连续帧之间的运动，跟踪视频中的不同对象，创建视频监控模型等。（video模块）
videostab模块：视频去抖动
（4）三维重建
将一系列二维图像重建出三维场景。（calib3d模块）
（5）特征提取
从一个给定场景中提取特征点。
（6）目标检测
在给定图像中检测目标的位置。objdetect和xobjdetect模块。
（7）机器学习
使用各种机器学习算法来实现不同的事情。OpenCV提供了ml模块。算法包括贝叶斯分类器、K邻域、支持向量机、决策树、神经元网络。flann模块：包含大量的快速临近搜索算法。
（8）计算摄影
使用先进的图像处理技术来优化相机拍摄的图像。
（9）形状分析
（10）光流算法
用于跟踪在视频的连续帧的特征。
（11）人脸识别和目标识别
（12）曲面匹配
与捕获周围对象的三维结构的设备进行交互。
（13）文本检测和识别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce4911d017d74155dd70bc867f3cb81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694c69906381ca92285e7dc187bfe7c5/" rel="bookmark">
			C&#43;&#43; 字符串长度计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++常用的长度计算方法size()、sizeof() 、strlen()、length()
size()：计算长度，std::string类的成员函数length()：计算长度，std::string类的成员函数sizeof()：计算所占用空间的字节数，是运算符；在编译时计算，获得保证能容纳实现所建立的最大对象的字节大小，因此sizeof不能用来返回动态分配的内存空间的大小strlen()：需要包含头文件cstring或string.h，输入类型位char* string 头文件 #include &lt;string&gt; //C++标准库头文件 //&lt;cstring&gt;是C标准库头文件&lt;string.h&gt;对应的C++标准库版本，如果使用strcmp、strchr、strstr、strlen等函数，需要该头文件 #include &lt;cstring&gt; #include &lt;string.h&gt; std::string长度计算 #include &lt;iostream&gt; #include &lt;string&gt; //#include &lt;cstring&gt; #include &lt;string.h&gt; int main(int argc, char *argv[]) { std::string str_t = "condition"; std::cout&lt;&lt;str_t.size()&lt;&lt;std::endl; std::cout&lt;&lt;str_t.length()&lt;&lt;std::endl; std::cout&lt;&lt;sizeof(str_t)&lt;&lt;std::endl; //计算的不是长度 std::cout&lt;&lt;strlen(str_t.c_str())&lt;&lt;std::endl; return 0; } 输出
9 9 32 9 char*长度计算 #include &lt;iostream&gt; #include &lt;string&gt; //#include &lt;cstring&gt; #include &lt;string.h&gt; int main(int argc, char *argv[]) { char ch_t[]={"condition"}; char* pch = ch_t; std::cout&lt;&lt;strlen(pch)&lt;&lt;std::endl; std::cout&lt;&lt;sizeof(pch)&lt;&lt;std::endl; return 0; } 输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/694c69906381ca92285e7dc187bfe7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab5356f574858cdccc3f997e4b8c41f/" rel="bookmark">
			从0到1实现单机记账APP原理与细节uniApp内含源码 (一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单机记账APP演示及源码 具体演示如下面视频所示。免费下载地址：点击进入
预览APP（内含开屏广告）下载地址：http://8.142.10.182:8888/down/aWHWeGaEQE2W.apk
服务器买的便宜，带宽很小所以下载速度慢，主要还是囊中羞涩，哈哈。
内容有点长，将结构、样式、方法都写进去了，可以复制粘贴直接用，资源就去下载地址直接全部下载下来吧。
单机记账APP 单机记账APP演示及源码一、本章详细讲解记账功能页面的实现1.基本搭建2.记账页面实现（1）收支类型（2）金额输入（3）时间选择、备注（4）记账 小结 一、本章详细讲解记账功能页面的实现 1.基本搭建 首先使用HBuilder新建项目（文件&gt;&gt;新建&gt;&gt;项目&gt;&gt;选择默认模板），然后引入uView2.0的UI框架（官网有详细的指引地址连接）。
总共5个页面结构图所示，别的是之前连接自己的服务器，写的登录设置密码的功能，现在改成单机的另外的页面就不需要了。
2.记账页面实现 先看页面，然后我们分别要实现的是收支类型、金额输入、时间选择、备注以及记账。
（1）收支类型 先行铺写收支类型部分的结构和样式，具体的代码如下：
&lt;!--结构--&gt; &lt;!-- 收支类型 --&gt; &lt;view class="headNav"&gt; &lt;text @click.stop="setType(0)" :class="{'navActive':statusPay == 0}"&gt;支出&lt;/text&gt; &lt;text @click.stop="setType(1)" :class="{'navActive':statusPay == 1}"&gt;收入&lt;/text&gt; &lt;view class="navLine" :style="{'left':lineLeft}"&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 金额 --&gt; &lt;view class="inputBox"&gt; &lt;view class="alignItems"&gt; &lt;u-icon name="rmb-circle-fill" size="26" color="#ffd607"&gt;&lt;/u-icon&gt; &lt;u-icon name="arrow-right" size="20" color="#ffd607"&gt;&lt;/u-icon&gt; &lt;/view&gt; &lt;text @click.stop="showkey = true" style="min-width: 200rpx;text-align: right;flex: 1;"&gt;￥{{money?money:'0.00'}}&lt;/text&gt; &lt;/view&gt; &lt;!-- 分类选择 --&gt; &lt;view&gt; &lt;!-- 支出类别 --&gt; &lt;view v-show="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab5356f574858cdccc3f997e4b8c41f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b7f5f393b2d0c0cf33d115c8d5b359/" rel="bookmark">
			【材料整理】-- numpy、Python、Matlab中常用功能函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 numpy、Python、Matlab中常用功能函数总结一、numpy中常用功能函数总结：二、Pyhton中常用功能函数总结：三、matlab中常用功能函数 numpy、Python、Matlab中常用功能函数总结 一、numpy中常用功能函数总结： 1、 将list类型转换成numpy类型 np.array(a)
将numpy类型转换成list类型 a.tolist()
2、
np.average求平均
np.min 求最小值
np.max 求最大值
np.std 求标准差
3、 np.all(np.array) 对矩阵所有元素做与操作，所有为True则返回True
np.any(np.array) 对矩阵所有元素做或运算，存在True则返回True
4、np.repeat函数，可以重复数字np.repeat(a=3, repeats=4)
5、numpy数组中维度进行交换 np.swapaxes(a,x,y)
6、 如何创建一个三维空数组？ np.zeros()
如何创建一个三维数组？np.ones()
7、将一个[145, 174]扩展成[145,174,90]方法：
8、numpy数据在某一个维度上进行合并 np.concatenate()
二、Pyhton中常用功能函数总结： 1、squeeze函数
2、Python中list的三种操作方法（参考链接）
3、
input = torch.rand(2, 3)
print(input)
生成与input形状相同、元素全为1的张量
a = torch.ones_like(input)
print(a)
#生成与input形状相同、元素全为0的张量
b = torch.zeros_like(input)
print(b)
4、tensor类型
permute 维度调换
transpose 维度调换，只能两个维度调换
三、matlab中常用功能函数 1、统计矩阵A中非零元素的个数
sum(sum(A~=0))
2、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fefeaaba9f7d0301e972af038fad1ffc/" rel="bookmark">
			电脑外接显示屏字体和图标过大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：大概是因为我们的外接显示屏的分辨率过大
解决方法：
桌面右击 -- &gt; 显示设置
切换到外接显示屏的显示器
显示器分辨率 -- 调节 （最好调节为1920 × 1080）
或者根据自己的喜好来调节 调节完成后保存更改
解决电脑外接显示屏字体和图标过大问题啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41f633af9301e578655b6e5a338ce04/" rel="bookmark">
			如何使用Python批量下载图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫程序在采集网页的过程中，需要从网上下载一些图片，比如表情包、壁纸、素材等，如果图片的数量很多，这样做就会非常麻烦和耗时。那么有没有更方便快捷的方法呢？答案是肯定的。我们可以利用Python编程语言来实现批量下载图片的功能。Python是一种简单易学、功能强大、跨平台的编程语言，它有很多优秀的第三方库和模块，可以帮助我们处理各种网络请求和数据处理。
具体来说，我们需要做以下几个步骤：
● 第一步：准备一个URL列表，也就是包含图片地址的文本文件或者Python列表。每个URL占一行或者一个元素。例如下面图片：
https://gw.alicdn.com/bao/upload/O1CN01Rc0Lms1CaTDV8Qbum_!!6000000000097-0-yinhe.jpg_Q75.jpg
https://gw.alicdn.com/bao/upload/O1CN01P9rnvt1FT5gVAczF5_!!6000000000487-0-yinhe.jpg_Q75.jpg
https://gw.alicdn.com/bao/upload/O1CN01EEpS2k1tZZvTCb4om_!!6000000005916-0-yinhe.jpg_Q75.jpg
● 第二步：导入需要用到的模块或库，比如requests、urllib.request、threading、multiprocessing等。
● 第三步：准备爬虫代理，用于提高爬虫采集效率，规避网站的IP限制
● 第四步：定义一个下载图片的函数，传入图片的URL和本地文件名作为参数，并使用相应的模块或库来发送HTTP请求和保存图片数据。
● 第五步：遍历URL列表，并调用下载图片的函数。如果需要提高下载速度和效率，可以考虑使用多线程或多进程来并发执行下载任务。
● 第六步：检查下载结果，统计下载进度。
通过以上几个步骤，在使用多线程或多进程时我们需要将下载任务分解成若干个子任务，并将它们分配给不同的线程或进程。我们可以使用range函数来生成子任务索引，并使用map函数或for循环将索引传递给线程或进程对象。然后，在每个线程或进程中我们可以根据索引选择对应URL和文件名并调用opener对象retrieve方法下载。
下面是代码示例：
# 导入urllib.request和threading模块 import urllib.request import threading # 定义一个列表，存放要下载的图片的URL image_urls = [ "https://gw.alicdn.com/bao/upload/O1CN01Rc0Lms1CaTDV8Qbum_!!6000000000097-0-yinhe.jpg_Q75.jpg", "https://gw.alicdn.com/bao/upload/O1CN01P9rnvt1FT5gVAczF5_!!6000000000487-0-yinhe.jpg_Q75.jpg", "https://gw.alicdn.com/bao/upload/O1CN01EEpS2k1tZZvTCb4om_!!6000000005916-0-yinhe.jpg_Q75.jpg" ] # 定义一个列表，存放要保存的本地文件名 image_filenames = [ "dianqi.jpg", "yifu.jpg", "xiezi.jpg" ] # 定义一个回调函数，用来显示下载进度 def report_progress(block_num, block_size, total_size): # 计算已经下载和总大小的百分比 percent = (block_num * block_size * 100) / total_size # 打印百分比和换行符 print(f"{percent:.2f}%", end="\r") # 定义一个字典参数，表示不同协议的代理服务器URL:www.16yun.com proxy_dict = { 'http': 'http://16yun:16ip@www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a41f633af9301e578655b6e5a338ce04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab54ba4fe02a4767e5ed1dd524d300fb/" rel="bookmark">
			多线程 | 多线程实现方式和差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么要使用多线程呢? 从计算机底层来说： 线程可以⽐作是轻量级的进程，是程序执⾏的最⼩单位,线程间的切换和调度的成本远远⼩于进程。
现在的系统动不动就要求百万级甚⾄千万级的并发量，⽽多线程并发编程正是开发⾼并发系统的基础，利⽤好多线程机制可以⼤⼤提⾼系统整体的并发能⼒以及性能。
提高CPU的利用率 目前大多数CPU都是多核的 可以都利用起来。
耗时的操作使用多线程，可以异步执行提高应用程序响应。
常用场景：客户端请求后可以异步执行不用返回给客户端的数据处理、后台定时任务中的异步分批执行任务、优化复杂查询（FutureTask）等等。
2、线程的生命周期和状态? 3、使用多线程可能带来什么问题? 并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁还有受限于硬件和软件的资源闲置问题。
4、线程创建方式？ 继承 Thread private static void thread() { Thread thread = new Thread(() -&gt; { try { // 业务代码 。。。 //加sleep 试一下执行顺序 Thread.sleep(100); System.out.println("Thread方式执行 新 线程:" + Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } }); //调用 start 才会执行线程中的 run()方法中的业务代码 thread.start(); System.out.println("Thread方式执行 主 线程:"+Thread.currentThread().getName()); } 通过实现Thread类型创建线程（实际开发中用到的不多,直接用线程池，只是为了单开一个线程可以使用）
执行结果:可以看出没有按照顺序执行，异步的。主线程比新开线程先执行。
实现 Runnable private static void runnable() { Runnable runnable = ()-&gt; { // 业务代码 。。。 try { //加sleep 试一下执行顺序 Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab54ba4fe02a4767e5ed1dd524d300fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bba99fe158c7f0702d0a64a367371e6/" rel="bookmark">
			【华为云-开发者专属集市】使用ECS搭建WordPress博客平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、AppBazaar官网二、选择与购买项目三、项目概况四、购买云服务1. 购买ECS1.1 重置ECS 五、搭建应用运行环境1 安装Nginx1.1 添加源并安装1.2 启动并测试 2. 安装MySQL2.1 下载并安装2.2 启动并设置密码 3. 安装PHP3.1 添加源并安装3.2 启动php-fpm服务 4. 启用PHP支持4.1 编辑配置文件4.2 测试LNMP的PHP支持 5. 数据库设置 六、安装并配置WordPress1. 下载并上传软件包1.1 下载英文版本并上传1.2 下载中文版本并上传 2. 解压软件包3. 移动目录并设置权限4. 配置WordPress配置文件4.1 复制模板文件4.2 编辑WordPress的配置文件 5. 安装WordPress6. 登录管理后台7. 查看主页8. 插件安装 七、资源释放八、总结 一、AppBazaar官网 首先，我们来到AppBazaar的官网：https://console.huaweicloud.com/appbazaar/home
AppBazaar现有16个项目，含括了工作中常用的服务架构。我们可在这里选择自己感兴趣的项目或者想要了解的项目来进行玩耍，正如官方的宣言：一键部署，构建应用无负担。
那究竟要如何玩耍呢？
二、选择与购买项目 首先登录平台，如果没有华为云账号，得先注册账号，实名认证后再继续。
然后点选所需的项目进入购买页面。
然后点击 立即购买（PS：现在可是免费呢，而且还是终身的，快去体验啦😘）
点选 用户协议 就可以 提交订单。
购买成功后，可以前往买家中心，在此处可查看到所购买的项目，然后就可以去下载对应的文档来进行参考与学习了。
所下载的文档如下图所示，包含了这个项目的上云指导和操作指导。
接下来，就可以去尝试和体验了，心动不如行动！那就让金鱼哥继续来做先锋队。
三、项目概况 项目名称：WordPress
官网地址：https://wordpress.org
项目简介：WordPress是一款个人博客系统，也可以把 WordPress当作一个内容管理系统（CMS）来使用，它是使用php语言和MySQL数据库开发的，用户可以在支持 php 和 MySQL数据库的服务器上使用自己的博客。
开发语言：php
应用运行环境：CentOS、Nginx、php、MySQL
涉及云服务：弹性云服务器 ECS或者云耀云服务器HECS
四、购买云服务 WordPress 博客平台需要部署到服务器上，所以需要购买一台 ECS 再将服务部署上去 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bba99fe158c7f0702d0a64a367371e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891bed8712e0af78e701da1b3239c508/" rel="bookmark">
			阿白数模笔记之协方差矩阵与相关矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、方差
二、协方差矩阵
①协方差
②自协方差矩阵
互协方差矩阵​编辑
③互协方差矩阵
Ⅰ、数学定义
Ⅱ、MATLAB运算
三、相关矩阵
①person相关系数
②自相关矩阵
③互相关矩阵
Ⅰ、数学定义
Ⅱ、matlab运算
前言 作为数模小白，前天在学习FA算法时看到协方差直接啥也不会，在查阅多方资料后，才算是有所了解，本文介绍数学上协方差矩阵和相关矩阵的定义以及在MATLAB中的运算。
一、方差 这是百度百科所给的定义
n=input('请输入矩阵的行数：'); a=rand(n,1); b=mean(a); s1=0; for i=1:n s1=s1+(a(i)-b)^2; end s1=s1/(n-1)%方差 s=s1^0.5%标准差 s2=cov(a)%方差 s3=var(a)%方差 二、协方差矩阵 ①协方差 该图来自如何直观地理解「协方差矩阵」？
a=[1,2,3,4]; a1=a-mean(a); b=[5,6,7,8]; b1=b-mean(b); c=a1*b1'/(size(a,1)-1);%即为a,b的协方差 ②自协方差矩阵 该图来自如何直观地理解「协方差矩阵」？
互协方差矩阵 a= [5 0 3 7; 1 -5 7 3; 4 9 8 10;1 0 9 8]; b=a-mean(a); n=size(a); cx=zeros(n); for i=1:n(2)%遍历每一列 for j=1:n(2)%遍历每一列 cx(i,j)=b(:,i)'*b(:,j)/(n(1)-1); end end c=cov(a);%matlab中有cov,此处用来检验运算是否正确 &gt;&gt; cx-c ans = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/891bed8712e0af78e701da1b3239c508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a689afaa82f6200bebd6c3025cb2dd1/" rel="bookmark">
			CSDN上传付费资源竟然需要LV4才可以，目前只有LV2，综合贡献分一直为0，本文持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者升级包含创作分、实名认证、原力等级三个条件
其中创作分是由资源量、阅读量、下载量及综合贡献带来的分值组成；每一个单项分值都被满足才认为达成升级条件，且超过单项分值门槛的分数不再计入当前总分
作者等级升级条件创作分实名认证原力等级总分门槛单项分值门槛资源量阅读量下载量综合贡献Lv0/Lv155/////Lv250151520/是/Lv315030304545是/Lv4500100100150150是≥5Lv51000150150300400是≥6 3、如何获得创作分
计分标准计分规则分值说明资源量每上传1个资源（审核通过）+5分若自行或被平台删除及下架则扣除对应分数，分数实时更新阅读量上传资源每获得10次有效阅读+1分历史数据自2020年起计算，分数次日更新下载量上传资源每获得1次有效下载+5分分数次日更新综合贡献基于作者整体资源质量、用户满意度、活跃度等加权计算作者对平台的综合贡献（该项分值从LV2开始计算）分数次日更新 目前本人已发表原创文章20篇，上传资源21个，目前的创作分是102分，
资源量、下载量均已达到，阅读量每天也有增加，不变的是综合贡献分一直是0
经询问客服，综合贡献分比较玄乎，总之，就是综合贡献分无法给出明确的计算方法。
啥时候达成LV3，综合贡献分满足45分时，将再次更新本文，综合贡献分的增长方法还在探索当中，升级后将再次与大家分享
原力值增减规则：
1. 创作者
发布内容 发布高质量原创文章：一次 10 分，每天最多 20 分 （这是我们鼓励的）转载文章: 一次 1 分，每天最多 4 分翻译文章：一次 5 分，每天最多 10 分。发布Blink，回答问题：得分，这些活动每次得分 1 分， 每天最多 2 分左右。 另外请注意，发布资源，如果资源没有得到好评，那是没有分数的，甚至要倒扣分数。 注意：在问答栏目提问没有分数内容获得反馈 （各个单项每天的得分有上限，每天最多不超过 10 分） 被评论，点赞，评价，被关注，资源被评价（分数大于 3 分）提问没有分数，但是提的问题被关注，也有分数被收藏，订阅，下载，下订单，回答被采纳认证：职业认证，企业认证，专家认证 （一次性的得分 100 - 500 不等）创作者收获粉丝，也会获得原力值。但是这些粉丝要符合基本条件（一年内有原创的博客/帖子，粉丝自己要有粉丝），我们要避免水军和低质量的粉丝降低原力值的含金量。 2023年2月19日通过完成成长任务，获得综合贡献值，上传了3个成长任务，获得了3分综合贡献分，目前只知道上传成长任务资源获得综合贡献，其他途径综合贡献尚不得知
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1445fd4cbb81861c06d1949b52ea50/" rel="bookmark">
			yolov5源码解读--数据处理模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5源码解读--数据处理模块 加载数据读取图片加载标签 马赛克数据增强图片标签 其他的数据增强变图像变标签 __getitem__构建Batch 加载数据 create_dataloader
跳转到datasets.py文件中，可以看到支持输入的文件类型非常丰富。。
回归正题
跳转LoadImagesAndLabels
加载图片和标签的函数
读取图片 f = []存储所有图片的路径
bi给当前数组做batch索引
nb就是所有的batch数目
加载标签 label_files所有标签的路径
cache_path、cache是缓存路径和缓存
cache
labels是按照文件名从cache中取出对应图片的标签，
extract_bounding_boxes 是否把框截取出来
create_datasubset、labels_loaded、extract_bounding_boxes和目标检测后续任务有关
nm, nf, ne, ns, nd = 0, 0, 0, 0, 0 # number missing, found, empty, datasubset, duplicate
这些和读取数据进度条打印的数据有关
一张张读取标签数据，做异常处理。。
进度条打印数据
在一次循环遍历读取标签
马赛克数据增强 完成的数据和标签的初始化操作后，
当训练网络时，执行__getitem__函数向网络传递数据
图片 使用了马赛克数据增强
四合一的拼接
yc, xc = [int(random.uniform(-x, 2 * s + x)) for x in self.mosaic_border] 随机中心点
img4 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1445fd4cbb81861c06d1949b52ea50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b613cd6b20e72d760b62ee6d75397a4/" rel="bookmark">
			模电中的负反馈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、反馈是什么？二、负反馈对于放大性能的影响1.负反馈的作用 三、正反馈总结 –
一、反馈是什么？ 反馈的定义：凡是将放大电路输出端信号（电压或电流）的一部分或者全部引回到输入端，与输入信号叠加，就称为反馈。
负反馈：引回的信号削弱了输入信号
正反馈：引回的信号增强了输入信号
对于
负反馈：Xd=Xi-Xf
对于
正反馈：Xd=Xi+Xf
二、负反馈对于放大性能的影响 注意这里A代表开环增益，Af才是闭环增益。
我们知道电阻的阻值是比较稳定的，所以我们的闭环放大倍数是比较稳定的，此时闭环放打倍数仅取决于反馈系数F，而与开环放大倍数A无关，通常反馈网络仅由电阻构成，反馈系数F十分稳定，所以闭环放大倍数必然是稳定的，诸如温度变化，参数变化，电源电压波动等明显影响开环放大倍数的因素，都不会对闭环放大倍数产生多大影响。
1.负反馈的作用 稳定放大倍数，改善输出信号波形
比如：
如某放大器的开环放大倍数A=1000，由于外界因素(如温度，电源波动)使其波动变化 值为10%，若反馈系数F=0.009，则闭环放大倍数为，此时波动10%，，，变化量约等于1，可见放大倍数的稳定性大大提高了，即用降低放大倍数的代价提高放大倍数的稳定性。
例子2
无负反馈时，产生正半周大，负半周小的失真
引入反馈后，失真了的信号经过反馈网络又送回到输入端，与输入信号反向叠加，这样得到的净输入信号，得到的净输入信号为正半周小而负半周大，这样正好弥补了放大器的缺陷，使输出信号比较接近于正弦波。
三、正反馈 正反馈也可以用这张图，将xf的符号改为+即可，符号问题、
总结 以上就是今天要讲的内容，本文简单介绍了反馈相关，以及相应的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da88a9545b52ebfc96415558d47f0833/" rel="bookmark">
			【外接屏幕】Win10外接屏幕缩放比例异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10外接屏幕缩放比例异常 外接屏幕后，由于两个屏幕分辨率不一致，导致外接屏幕中，窗口组件的放大比例过大。
比如，外接屏幕中，某程序全屏时，显示如下，按钮过大，看着就很不舒服：
解决方法：
更改后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9dde2f5ae2bff2e66832aa10774516/" rel="bookmark">
			java实现对字符串逆序排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner; public class String_03 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println("请输入您要进行倒序排序的字符串："); String s1 = scanner.next(); String s2=""; // 使用toCharArray方法，将字符串中的字符转换为字符数组 char[] array = s1.toCharArray(); System.out.println("倒序排序后的字符串为："); // 遍历输出字符 for (int i = array.length-1; i &gt;=0 ; i--) { System.out.printf(s2+array[i]); } } } 输出结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344284b8a6c515d6878f9dd1177300e1/" rel="bookmark">
			C语言比较两个字符串是否相等的案例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路分析
比较两个字符串是否相等要看两个字符串的长度和内容是否一样，如果长度和内容有一个不一样那么这两个字符串不相等。
方法1：strcmp函数可以比较2个字符串的大小和内容是否一样，我们可以使用这个函数来进行判断。
知识补充：
strcmp函数用来比较两个字符串并且根据比较结果返回整数。如果两个字符串的长度和内容都相等，返回0，字符串1大于字符串2返回正数，字符串1小于字符串2返回负数。
strcmp函数的格式为：
strcmp(str1,str2);括号内是字符串名，用户可以自定义。
方法2：先用if语句和strlen函数（求字符串长度函数）判断一下两个字符串的长度是否一样，不一样直接判断两个字符串不等；如果字符串长度相等，那么接下来用for循环和if语句来判断两个字符串的内容是否一样，字符串长度和内容一样就判断两个字符串相等，如果字符串长度一样但内容不一样就判断两个字符串不等。
方法1代码如下
#include &lt;stdio.h&gt; #include &lt;string.h&gt; void main(){ char arr1[20]="hello world"; char arr2[20]="hello worla"; int a=strcmp(arr1,arr2);//如果两个字符串的长度和内容一样，返回0 if(a==0){ printf("相等"); } else{ printf("不等"); }//如果两个字符串的长度和内容有一个不一样，就判断为不等 } 方法1代码运行结果如下
方法2代码如下
#include &lt;stdio.h&gt; #include &lt;string.h&gt; void main(){ char arr1[]="hello world"; char arr2[]="hello world"; int i,a=0;//a的作用：如果字符串长度相等，就判断内容是否一样，内容一样a就累加1 if(strlen(arr1)==strlen(arr2)){ for(i=0;arr1[i]!='\0';i++){ if(arr1[i]==arr2[i]){ a++; } else{ a=0; } } if(a==strlen(arr1)){ printf("相等"); } else{ printf("不等"); } } else{ printf("不等"); } } 方法2代码如下
总结：使用strcmp函数比较两个字符串是否相等比较方便，不过方法2的思路也是可圈可点，不失为一种好办法。
因为方法1使用了string.h头文件下的strcmp函数的知识点，所以就发一下关于string.h头文件下一些常用函数讲解的博客（作者自己写的）作为知识补充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/344284b8a6c515d6878f9dd1177300e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1187b1e1167c6c4da90694cea7ff9796/" rel="bookmark">
			两款HTML动态爱心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码地址：https://download.csdn.net
HTML动态爱心代码一 index.html
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;canvas爱心&lt;/title&gt; &lt;style&gt; html, body { height: 100%; padding: 0; margin: 0; background: #000; } canvas { position: absolute; width: 100%; height: 100%; }&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="pinkboard"&gt;&lt;/canvas&gt; &lt;script&gt; ... HTML动态爱心代码二 index.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;aixin&lt;/title&gt; &lt;/head&gt; &lt;style&gt; #drawing { height: 100%; width: 100%; } &lt;/style&gt; &lt;body&gt; &lt;canvas id="drawing"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; var drawing = document.getElementById("drawing"); //获取canvas元素 var cheight = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1187b1e1167c6c4da90694cea7ff9796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a68a4cf2680c3ffef03e628ebda886/" rel="bookmark">
			计算数组中每个元素出现的次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们常常需要统计到数组中的元素的总个数，我平常用到的这三个就很不错
方法一：使用 reduce 方法 --- 直接获取
const names = ['peter', 'tom', 'mary', 'bob', 'tom','peter']; const nameNum = names.reduce((pre,cur)=&gt;{ if(cur in pre){ pre[cur]++ }else{ pre[cur] = 1 } return pre },{}) console.log(nameNum); //{ peter: 2, tom: 2, mary: 1, bob: 1 } 方法二：创建一个对象 -- 需要在循环内处理其他的数据时，可以用该方法进行计算统计
const arr= ['peter', 'tom', 'mary', 'bob', 'tom','peter'] const obj = {} for (let i = 0; i &lt; arr.length; i++) { const element = arr[i] if (obj[element]) { obj[element]++ } else { obj[element] = 1 } } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a68a4cf2680c3ffef03e628ebda886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34837bba7a7888556656dd42afed44f2/" rel="bookmark">
			【antdesign】树控件 的 搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据关键字搜索出树控件中的数据，
1.树控件的数据另存一份不带层级 ‘allData’，用于搜索，
2.搜索不带层级的那份数据 'allData' ，筛选出他的key或者id，赋值给树控件的展开节点
3.关键字标红则是直接在树控件中控制
创建树控件 - 关键字标红就是在template中直接进行设置；
&lt;template&gt; &lt;Tree :tree-data="treeData" v-model:expandedKeys="expandedKeys" // 展开的节点 :auto-expand-parent="autoExpandParent" // 是否自动展开节点 block-node @expand="onExpand" &gt; &lt;template #title="{ title }"&gt; &lt;span v-if="title.indexOf(searchValue) &gt; -1"&gt; {{ title.substr(0, title.indexOf(searchValue)) }} &lt;span style="color: #f50"&gt;{{ searchValue }}&lt;/span&gt; {{ title.substr(title.indexOf(searchValue) + searchValue.length) }} &lt;/span&gt; &lt;span v-else&gt;{{ title }}&lt;/span&gt; &lt;/template&gt; &lt;/Tree&gt; &lt;/template&gt; 搜索数据
// 将自动展示改为false const onExpand = (keys: string[]) =&gt; { expandedKeys.value = keys; autoExpandParent.value = false; }; // input 的事件，进行搜索 const queryTreeList = (value) =&gt; { expandedKeys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34837bba7a7888556656dd42afed44f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7329d7aea10dfa6e62e86f00afc59ecb/" rel="bookmark">
			【mars3d&#43;vue2】项目打包报错 error in ./node_modules/mars3d-cesium/Build/Cesium/index.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近拉下 mars3d+vue2 最简模板的代码，运行就会报错
类似这种cesium的报错
官方给出的回答是：
目前cesium1.96改变了代码打包方式，在vue2项目下会有这个兼容报错问题。
当然，也给出了几个解决方案：
1、参考 https://gitee.com/marsgis/mars3d-vue-template/tree/master/mars3d-vue2 升级下vuecli到5
2、固定mars3d-cesium版本为1.95，"mars3d-cesium": "1.95.1" 【注意不要^】
3、在html直接引入Cesium资源和import mars3d方式集成 (cdn cesium + import mars3d)
我个人认为第二种方法还不错，但是也有可能问题解决的不彻底，
当第二种方法不行时，可以试试第一种，如果不行，那就只能第三种了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73251af37937533a4e0f1558f28b99b3/" rel="bookmark">
			【mars3d】聚合点更改样式 ， 自定义背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义聚合点的背景图片，图片上显示聚合的数目
问题：绘制出来的效果，经常只有数字，没有背景图，移动过去才有背景图。
1.通过 mars3d的方法 getTextImage （Util - Mars3D API文档http://mars3d.cn/api/Util.html?classFilter=util#.getTextImage）将文字转换成base64图片，但是会出现上面的问题；
在第二步说正确操作
item.graphicLayer = new mars3d.layer.BusineDataLayer({ data: jhData, dataColumn: "data", // 数据接口中对应列表所在的取值字段名 lngColumn: "JD", latColumn: "WD", altColumn: "z", symbol: { type: "billboard", // 对应是 mars3d.graphic.BillboardEntity styleOptions: { image: item.src, horizontalOrigin: Cesium.HorizontalOrigin.CENTER, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, scaleByDistance: new Cesium.NearFarScalar( 1000, 0.7, 5000000, 0.3 ), label: { // text: "{BHMC}", font_size: 19, color: Cesium.Color.AZURE, outline: true, outlineColor: Cesium.Color.BLACK, outlineWidth: 2, horizontalOrigin: Cesium.HorizontalOrigin.LEFT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73251af37937533a4e0f1558f28b99b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d821f5502deb97dbac5d35e32a294d/" rel="bookmark">
			关于JS变量提升以及暂时性死域的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文根据我自身的理解来写作的文章。如有错误，欢迎指正。
在js中有三种申明变量的方式 分别是 var let const 而其中 var 是能被变量提升的。 而let和const是无法被变量提升的。
变量提升 可以看到第一行 使用 var申明的o1 在初始化之前就能够被console.log打印出来 而使用let申明的b1 却无法在变量被初始化前打印 并且直接报错。 这就是因为let是没有被提升到作用域的顶部导致的
暂时性死域
再看第一行打印的 o1 是undefined而不是 123 这是因为虽然变量被提升到作用域的顶部了 但是此时变量是还未被初始化的 所以打印出来的才会是 undefined 而在变量提升 到变量初始化的这片区域 就被称为变量的暂时性死域
函数提升
既然变量能被提升 那么函数是否能被提升呢？
答案是：可以的。
可以看到 通过 function 关键字的函数申明式的 func1 是能够被正常执行的 而通过字面量形式（即使用变量）的无法被执行。所以 直接使用function申明的函数 是会被js提升的 而使用变量字面量形式申明的 其实和上方所说的变量提升及暂时性死域是一样的 let和const无法被提升 所以使用这两个申明的函数 在初始化前调用的话 会爆出 "[functionName] is not defined"而 使用 var 申明的函数 在初始化之前是 undefined 而 undefined 无法作为一个函数来调用 所以会爆出 "[functionName] is not a function"
最后
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d821f5502deb97dbac5d35e32a294d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec134937f4ee485d81aa78d6d5ac176/" rel="bookmark">
			npm命令与package.json包管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、package.json中^和~的区别 (1)
npm i 的时候
~ 前面两位固定 后面一位是最大数字 最新版
^ 前面一位固定 后面两位是最大数字 最新版
(2)
"dependencies": { "css-loader": "~2.1.0", "es6-promise": "^2.0.0", } ~符号
若css-loader有新的版本2.2.0及以上，你咋执行npm install时，只会匹配到2.1.x的最新版本，不会匹配到2.2.0及以上
^符号
若es6-promise有新的版本3.0.0及以上，你咋执行npm install时，只会匹配到2.x.x的最新版本，不会匹配到3.0.0及以上
(3)
webpack 项目的package.json 文件列出了项目所依赖的插件和库，同时也给出了对应的版本说明，但是在版本说明前面还有个符号：'^'（插入符号）和'~'（波浪符号），总结了下他们之间的区别：
例如：
'~'（波浪符号）:他会更新到当前minor version（也就是中间的那位数字）中最新的版本。放到我们的例子中就是："exif-js": "~2.3.0"，这个库会去匹配更新到2.3.x的最新版本，如果出了一个新的版本为2.4.0，则不会自动升级。波浪符号是曾经npm安装时候的默认符号，现在已经变为了插入符号。'^'（插入符号）: 这个符号就显得非常的灵活了，他将会把当前库的版本更新到当前major version（也就是第一位数字）中最新的版本。放到我们的例子中就是："vue": "^2.2.2", 这个库会去匹配2.x.x中最新的版本，但是他不会自动更新到3.0.0。 二、npm install全局安装和本地安装的区别 -g和不-g的区别 一般情况下会以本地模式运行，包会被安装到和你的应用程序代码的本地node_modules目录下（npm的时候不使用-g命令）。
在全局模式下，Node包会被安装到Node的安装目录下的node_modules下（npm的时候使用-g命令）。
1、全局安装命令为$npm install -g moduleName。
获知使用$npm set global=true来设定安装模式，$npm get global可以查看当前使用的安装模式。
2、npm root：查看当前包的安装路径
npm root -g：查看全局的包的安装路径
但是代码中，直接通过require()的方式是没有办法调用全局安装的包的。全局的安装是供命令行使用的，就好像全局安装了vmarket后，就可以在命令行中直接运行vm命令
三、npm install -D 和-S -S 写入package.json的dependencies -D 写入pakage.json的DevDependencies，生产环境需要。 npm install 安装依赖的时候，可以通过如下方式，把依赖写入package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec134937f4ee485d81aa78d6d5ac176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa1fe4040a1f07794b33f0134285614/" rel="bookmark">
			Springboot3.0整合swagger，废弃Springfox改用Springdoc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Springfox Automated JSON API documentation for API's built with Spring
官网地址：springfox.io
什么是Springdoc springdoc-openapi java library helps to automate the generation of API documentation using spring boot projects.
官网地址：https://springdoc.org/v2/
注意：使用的是V2版本，这个版本支持springboot3.0
为什么改用springdoc 之前springboot3.0之前我用的都是Springfox来集成Swagger管理我们的API接口文档，这也就是Springfox和Springdoc最主要的功能。因为Springfox已经停止更新有段时间了，升级Springboot3.0以后会有更多问题暴露出来。Spring官网推荐了Springdoc，应该不会短时间停更，所以改用Springdoc
具体实现 Springdoc使用也很简单，基本上也是开箱即用，不需要任何的配置，直接就可以使用。
首先添加依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-starter-webmvc-api&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 两个依赖添加上，我们就可以直接使用Swagger3的注解了
@Tag(name = "用户管理") @RestController public class UserController { private final Logger logger = LoggerFactory.getLogger(UserController.class); @Operation(summary = "列表") @PostMapping("list") public ResultJson list() { ... return ResultJson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa1fe4040a1f07794b33f0134285614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028a84ea9ab97eb884cd4ca8a492bbf2/" rel="bookmark">
			处理图的开源库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、networkx可视化pyg的Data
from torch_geometric.utils import to_networkx import pylab # one_data是Data类型 G = to_networkx(one_data) nx.draw(G) pylab.show() 2、RDKit 用于化学信息学的开源工具包
基于对化合物2D和3D分子操作，利用机器学习方法进行化合物描述符生成，fingerprint生成，化合物结构相似性计算，2D和3D分子展示等
https://rdkit.org/
# 使用rdkit解析分析分子的信息，生成图信息，构建Data mol = Chem.MolFromSmiles(smiles) # Read the molecule info adj = Chem.GetAdjacencyMatrix(mol) # Get molecule structure # You should extract other features here! data = Data(num_nodes=adj.shape[0], edge_index=torch.Tensor(adj).nonzero().T, y=label) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34d999e8ae2a26d4398121c06c7bdbb/" rel="bookmark">
			img标签alt和title的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其中alt属性是指图片的替换文本，主要有两个作用：
①当根据路径找不到该图片时,作为替换文本出现,不同的浏览器显示形式不一样。
②通过alt 可以让搜索引擎知道该图片的内容是什么,因为搜索引擎无法根据图片识别当前图片显示的内容。
其中的title属性的作用为：
title属性的作用是指当鼠标放在图片上的时候会出现对图片的描述信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec17d71599f78d01ed30a09fb9c2b87c/" rel="bookmark">
			模板（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 泛型编程2. 函数模板2.1 函数模板概念2.2 函数模板格式2.3 函数模板原理2.4 函数模板实例化2.5 模板参数的匹配原则 3. 类模板3.1 类模板的定义格式3.2 类模板实例化 1. 泛型编程 如何实现一个通用的交换函数？
void Swap(int&amp; left, int&amp; right) { int tmp = left; left = right; right = tmp; } void Swap(double&amp; left, double&amp; right) { double tmp = left; left = right; right = tmp; } void Swap(char&amp; left, char&amp; right) { char tmp = left; left = right; right = tmp; } 使用函数重载虽然可以实现，但是有以下几个不好的地方：
重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现，就需要用户自己增加对应的函数代码的可维护性比较低，一个出错可能所有的重载均出错 在C++中，存在一个模具，通过给这个模具中填充不同材料（类型），来获得不同材料的铸件（即生成具体类型的代码）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec17d71599f78d01ed30a09fb9c2b87c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44621fd071f9a44da7c20724650badab/" rel="bookmark">
			Python-Django毕业设计基于框架的毕业生就业管理系统（程序&#43;Lw)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 该项目含有源码、文档、程序、数据库、配套开发软件、软件安装教程
项目运行
环境配置：
Pychram社区版+ python3.7.7 + Mysql5.7 + HBuilderX+list pip+Navicat11+Django+nodejs。
项目技术：
django + python+ Vue 等等组成，B/S模式 +pychram管理等等。
环境需要
1.运行环境：最好是python3.7.7，我们在这个版本上开发的。其他版本理论上也可以。
2.pycharm环境：pycharm都可以。推荐pycharm社区版;
3.mysql环境：建议是用5.7版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
6.Navcat11：这个版本不限10/11/14/15都可以。；
Python-Django毕设帮助，指导，本源码(见文末)，调试部署
4.1登录模块 系统用户登录，在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图4-1所示。
图4-1系统用户登录界面图
4.2管理员功能模块 管理员进行登录，进入系统前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作，如图4-2所示。
图4-2管理员登录界面图
管理员登录系统后，可以对首页，个人中心，专业管理，学院管理，学生管理，辅导员管理，实习就业管理等功能进行相应的操作管理，如图4-3所示。
图4-3管理员功能界面图
专业管理，在专业管理页面可以对索引,专业等内容进行详情，修改和删除等操作，如图4-4所示。
图4-4专业管理界面图
学院管理，在学院管理页面可以对索引,学院等信息进行详情，修改和删除操作，如图4-5所示。
图4-5学院管理界面图
学生管理，在学生管理页面可以对索引,学生学号,学生姓名,班级,性别,专业,学院,手机号,辅导工号,辅导姓名等内容进行详情，修改和删除操作，如图4-6所示。
图4-6学生管理界面图
辅导员管理，在辅导员管理页面可以对索引,辅导工号,辅导姓名,性别,联系电话,学院,专业等内容进行详情，修改和删除操作，如图4-7所示。
图4-7辅导员管理界面图
实习就业管理，在实习就业管理页面可以对索引,学生学号,学生姓名,学院,专业,辅导工号,辅导姓名,企业名称,企业地址,企业电话,岗位,实习时间,实习报告,审核回复,审核状态等内容进行详情，修改和删除操作；如图4-8所示。
图4-8实习就业管理界面图
4.3辅导员功能模块 辅导员登录进入毕业生就业管理系统可以对首页，个人中心，实习就业管理理等功能进行相应操作，如图4-9所示。
图4-9辅导员功能界面图
个人中心，在个人中心页面通过填写辅导工号,辅导姓名,性别,联系电话,学院,专业等内容进行个人信息修改操作，如图4-10所示。
图4-10个人中心界面图
实习就业管理，在实习就业管理页面可以对索引,学生学号,学生姓名,学院,专业,辅导工号,辅导姓名,企业名称,企业地址,企业电话,岗位,实习时间,实习报告,审核回复,审核状态,审核等内容进行详情，修改或删除等操作，如图4-11所示。
图4-11实习就业管理界面图
4.4学生功能模块 学生登录进入毕业生就业管理系统可以对首页，个人中心，实习就业管理等功能进行相应操作，如图4-12所示。
图4-12学生功能界面图
个人中心，在个人中心页面通过填写学生学号,学生姓名,班级,性别,专业,学院,手机号,辅导工号,辅导姓名等内容进行个人信息修改操作，如图4-13所示。
图4-13个人中心界面图
实习就业管理，在实习就业管理页面可以对索引,学生学号,学生姓名,学院,专业,辅导工号,辅导姓名,企业名称,企业地址,企业电话,岗位,实习时间,实习报告,审核回复,审核状态等内容进行详情，修改或删除等操作，如图4-14所示。
图4-14实习就业管理界面图
Python-Django毕设帮助，指导，源码获取������������������，调试部署 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bcd9ec8439c07a8e5102e5eddac04e/" rel="bookmark">
			音乐播放器-- 以及数据库数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境 ： java1.8 数据库以及代码编写工具 ： sqlserver -- mysql 也可以 工具 eclipse 编码gbk
窗体 ： Swing
使用了jaudiotagger 进行了音乐处理 图片展示 ----- 空闲时间 做出来玩的项目 部分功能还没有完善 完善了的功能 音乐 /// 主页 ： 展示 切换主题颜色保存数据库、 以及头像更换、还有搜索功能 推荐： 展示 歌曲列表： 音乐展示 以及播放 、后台 添加音乐 以及图片等等！！！ 本地音乐： 添加本地音乐，批量增加 ，删除 最近音乐： 删除 ， 记录听过的歌曲 播放功能 ： 自动切换、播放暂停、上一首下一首、图片轮播 等等。。。。。 播放 双击音乐即可播放！！！！ 没有完善的功能 歌词读取出来 差没有去完成了
有需要的可以私聊 代码太多了 有需要 私
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c3a7e4bc1580d5766189759a9b8b4a/" rel="bookmark">
			经常用但是不知道什么是BFC？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BFC学习 block formatting context 块级格式上下文
简单理解： 一个独立容器，内部布局不会受到外面的影响
形成条件： 1.浮动元素：float除none之外的值
2.绝对定位：position:absolute,fixed
3.display:inline-block,table-cell,table-caption,flex
4.overflow除visible之外的值（hidden,auto,sccroll)
5.body根元素
BFC特性 1.内部的盒子会在垂直方向上一个接一个的放置；他这里指的是很多个BFC的摆放
2.垂直方向上的距离由margin决定，同一个BFC中的两个相邻的标签外边距会发生重叠
前两点其实就是同一个BFC内部盒子和普通外部盒子排列一样，也有margin重叠的问题
.float-item { width: 100%; height: 200px; background-color: greenyellow; margin: 20px; } .float-father { overflow: hidden; } &lt;div class="float-father"&gt; &lt;div class="float-item"&gt;1&lt;/div&gt; &lt;div class="float-item"&gt;2&lt;/div&gt; &lt;/div&gt; 3.BFC的区域不会与float的元素区域重叠
4.BFC盒子里面与外面互不影响
5.计算 BFC 的高度时，浮动元素也参与计算
前两点就是它内部的盒子摆放规则和外面普通盒子一样，我们主要利用的是后三点
作用： 1 利用BFC避免margin重叠
情景：正常情况下父子盒子的margin会发生重叠，他会取大的；这时我让父盒子变为BFC，他们的边距就不会重叠了；兄弟盒子也一样，他们上下边会取大的，我们可以将一个盒子用父盒子包起来，给父盒子添加overflow:hidden
&lt;style&gt; * { padding: 0; margin: 0; } .first { background-color: pink; height: 100px; margin-bottom: 20px; } .second { background-color: skyblue; height: 100px; margin-top: 50px; } &lt;/style&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c3a7e4bc1580d5766189759a9b8b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7986916f9e9ef63f9e20f928159119d7/" rel="bookmark">
			一文告诉你什么是财务数据治理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是梦想家Alex，今天是周末，就不给大家分享技术文了～应出版社老师推荐，文末给大家送几本DAMA中国主席力荐，20位行业专家历时2年共同打造的《财务数据治理实战》，将数据治理理论应用于财务管理实践，是一本写给财务人员的数据治理体系指南！希望大家喜欢。
为什么需要财务数据治理？ 其一，财务部门牵头数据治理，效果好。财务部门在企业中是权威部门，如果财务部门牵头执行数据治理，有助于在企业内部推动数据治理各项工作顺利开展。尤其是在金融行业，相当一部分金融机构的数据治理部门设置在财务部门之下，由财务部门牵头和负责开展数据治理工作，并经历数年的运行，已经取得了较好的效果。
其二，财务部门对数据治理有着迫切性需求。财务部门是企业的“数据中枢”，汇聚企业从前端业务到后端财务管理的大量数据，其日常管理及统计涉及企业绝大部分的核心业务运营过程中产生的数据，因此财务部门对于数据治理的迫切性远远高于业务部门和技术部门。
其三，财务数据问题将阻碍企业的数字化创新。财务数据的状况取决于企业整体技术与系统、流程与制度、组织与人员的体系构建水平。如果这三个方面建设不足，财务数据问题将日渐暴露，阻碍了财务数字化前进的步伐以及企业的数字化创新。
财务数据存在哪些待解决的问题？ 第一，数据集成方面，存在数据线上断点和信息孤岛这两类问题。
财务部门联通了业务前后端的大量数据，从端到端的过程中，如出现数据依靠手工采集、输入等“掉落线下”的情况，数据的连通会出现断点，数据的准确性、时效性、可靠性等都无法得到控制和保障，从数据源头开始就为财务数据的应用带来隐患。
没有走向财务转型或还在转型路上的企业会因为系统建设时缺乏全局观念、系统缺乏兼容性或者各信息模块由不同部门建设维护而导致编码规则不统一等问题，造成“信息孤岛”。
第二，数据标准方面，存在数据标准不统一、不全面、不规范和缺乏实践性的问题。
一般企业先进行建设再治理，先把信息系统、数据中心建设好，之后发现数据标准不统一造成数据质量、安全等多个方面的问题，再来建设数据标准。这样的做法会让数据上的很大一部分投入付诸东流，但也难以避免。
数据标准体系的制定需要系统性的思考和筹划，涉及面广泛，包括企业主数据的标准、数据质量的标准、数据安全的标准、数据指标的标准等，还要考虑外部监管要求、行业的通用标准、专家的实践经验及企业内部的实际情况等众多方面的内容。因此，即使企业已经完成标准体系的制定和建设，但如果制定得不全面、不规范，也会导致主数据等方面出现混乱。
第三，数据质量方面，存在数据准确性不足、时效性不足、数据不一致、数据重复的问题。
如果一个组织是以劣质的数据为基础去分析探索、指导业务、支持决策、实现创新，那会与“拍脑袋”式的决策创新一样可怕，因为通过“脏数据”进行的数据分析应用往往会带来“精确的误导”，于任何组织而言，这无疑是一场灾难。
第四，财务主数据方面，存在主数据不完善、不规范、维护不及时的问题。
主数据支撑的是企业关键业务与管理流程，并且能够跨部门、跨流程、跨主题、跨系统和跨技术使用。无论是在财务部门还是其他部门中，主数据都应当代表与业务实体相关的、全面完整的、权威规范的、及时准确的一种数据，如果未能达到要求，那么带的影响也会大打折扣。
第五，财务数据安全方面。
从数据安全和全生命周期的角度来看，企业财务数据在采集、传输、存储、处理、交换和销毁的各个方面都不同程度地存在安全隐患。财务数据作为涉及企业核心信息的重要数据，需要制定具有针对性的安全管理制度，并得到格外的安全保护和风险防范。如果财务数据在数据脱敏、安全认证、分级管理、异常监控、风险防御等任何方面出现纰漏，造成的损失都将难以估量。
第六，财务数据应用方面。
财务部门汇聚企业内外部的海量数据，但大量数据在汇集之后就被封存在服务器内处于休眠状态，无法帮助企业管理层从经验支持决策转化为数据驱动决策，数据应用水平较低。尤其受限于算力和算法的不足，许多数据资产丰富的企业也无法利用数据分析进行科学准确的决策。
如何有效开展财务数据治理？ 第一，作为企业资金管控和金融服务的平台，财务数据通过建立数据治理工作体系，对成员单位资金进行动态跟踪，保障资金安全，落实企业财务管控要求。
第二，通过对资源的优化配置，节约企业整体财务成本，提升资金运行效率。
第三，财务部门通过数据治理主动挖掘成员单位需求，提升公司的业务敏捷性，开展精细化管理，降低公司的运营成本，跟踪经营风险数据，满足公司管理风险与内控要求。
内容简介 《财务数据治理实战》是一本写给财务人员的数据治理体系指南，将数据治理理论应用于财务管理实践，针对财务工作场景阐释数据治理方法论，总结常见问题，分析财务数据问题场景，并在不同类型的企业中对解决方案进行了效果验证。
本书特色 ①政策解读——介绍重要数据标准，分析数据治理中各项任务的关键锚点，促进数据标准化发展。
②体系完善——从数据治理的政策背景入手，基于作为标杆的DAMA数据管理知识体系。
③有针对性——针对财务管理中的数据治理应用问题，提出财务数据治理的指南和方案。
④面向实践——以金融机构和多元控股公司为例，逐一攻克数据治理在实践中的难题。
推荐理由 理论结合实际案例，全面、细致地分析了财务数据治理在应用方面的问题，深入剖析原因，基于DAMA数据管理知识体系，从数据组织、数据架构、数据模型、数据标准、数据质量等方面介绍数据管理的方法论，提出财务数据治理的具体解决方案，并结合不同行业的企业案例，分析经验成果。用133张关系图、流程图、结构图等，介绍数据治理中的复杂概念，明晰执行方案，将有效帮助财务人员认识、学习和实践数据治理，已被推荐为数据治理工程师（CDGA）和数据治理专家（CDGP）认证的官方指定教材。由20位行业专家历时两年共同打造，作为数据管理和数字化系列丛书的开篇之作，致力于将实际国情和行业特性融入数据治理理论。针对财务工作场景，归纳财务数据的六大问题表现，包括财务数据集成、财务数据标准、财务数据质量等方面，分析五大财务数据问题场景，提供经验总结和案例分析。解读相关数据标准，基于财务审计领域的实际情况，帮助企业在数据治理工作中少走弯路。 🔚 感谢清华大学出版社的赞助，文末给大家准备了1本新书《财务数据治理实战》，你只需要在评论区留下你想要这本书的原因，我将从评论区挑一位留言最走心的锦鲤，感谢大家的参与！
活动截止：2023/02/22 早上8点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47801a2fd9d92cf601b5a7854f5a39c/" rel="bookmark">
			什么是robotframework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RobotFramework是一种基于Python的自动化测试框架，它可以用于自动化测试Web应用程序，桌面应用程序和命令行界面等。它还可以用来执行数据驱动测试、支持多种测试库，并具有丰富的资源模型，可轻松定义测试用例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd985b4ac3132dcc9a52595387e9b0c/" rel="bookmark">
			设计一个简单的java地图程序：（1）地图包含点（Point）和线（Line）两个要素，点要素包含一个坐标点，线要素包含一个有序的坐标列表。（2）在工具类MapTool中设计一个批量平移的工具函数mo...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X应该为MapElement类型，该类实现了MapElement接口，定义了Point和Line两个子类，它们分别实现了move(double x, double y)方法，用于实现对每一个点和线的平移操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1a14decdef4a46705b876d84361b29a/" rel="bookmark">
			和chatgpd有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT 是一种大型语言模型，由 OpenAI 训练而成，而 chatgpd 则是基于机器学习的自动聊天机器人，他们之间的最大区别在于 chatgpd 可以模仿人的交谈形式，而ChatGPT 则是一种可以被用于自然语言处理的神经网络模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd40c9b26b9265deda26bd0e96c6265/" rel="bookmark">
			delphi XE5如何把其它程序而不是本软件在通知区域的图标隐藏？不是关闭进程。请举个详细代码例子，如Shell_NotifyIcon能真正实际把进程DEVBIT.exe在通知区域隐藏图标...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Shell_NotifyIcon API，你可以在Delphi XE5中实现隐藏指定进程的图标，代码如下：procedure HideIcon(const aProcessName: string); var Hwnd: HWND; NotifyIconData: TNotifyIconData; begin Hwnd := FindWindow(nil, PChar(aProcessName)); if Hwnd &lt;&gt; 0 then begin FillChar(NotifyIconData, SizeOf(NotifyIconData), 0); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b8c15d413c2f136c83ba4938ccfd13/" rel="bookmark">
			js实现发送请求功能，代码如何实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用XMLHttpRequest对象可以实现JavaScript发送请求的功能。 代码示例如下：var xhr = new XMLHttpRequest(); xhr.open('POST', 'url', true);xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');xhr.onreadystatechange = function () { if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) { //获取服务器响应数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee82935b112662a696c35c8fd71f0097/" rel="bookmark">
			JVM学习（四）---类加载过程、类加载器和双亲委派机制的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM学习（四）---类加载过程、类加载器和双亲委派机制的原理 （四）对象的创建过程【1】对象的创建Step1:类加载检查Step2:分配内存Step3:初始化零值Step4:设置对象头Step5:执行 init 方法 【2】对象的内存布局【3】对象的访问定位 【1】基本介绍【2】类加载的过程（2.1）加载（2.2）验证（2.3）准备（2.4）解析（2.5）初始化 【3】卸载【4】类加载器（1）类加载器的作用（2）类与类加载器（3）什么是双亲委派机制？（4）为什么要使用双亲委派机制？（1）jvm认定两个对象同属于一个类型的条件（2）如果没有双亲委派会有哪些问题（3）双亲委派的例子：自定义一个类ArrayList （5）双亲委派的好处（6）如何打破双亲委派机制？（1）如何自定义一个类加载器（2）自定义的类加载器如何打破双亲委派机制（3）注意点 （7）什么情况下要打破双亲委派机制？（8）打破双亲委派机制的案例？（1）认识工具：线程上下文类加载器（2）JNDI、JDBC、JCE、JAXB 和 JBI 等（3）JDBC打破双亲委派机制（4）Tomcat打破双亲委派机制 【5】双亲委派的补充说明（1）通过代码来了解各个类加载器之间的关系（2）双亲委派模型介绍（3）了解双亲委派机制的原理（4）双亲委派模型实现源码分析 【6】自定义加载器，打破双亲委派（1）直接自定义类加载器加载（2）测试（3）进一步修改（跳过AppClassLoader和ExtClassLoader） （四）对象的创建过程 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。
【1】对象的创建 Java 对象的创建过程
Step1:类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
Step2:分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
内存分配的两种方式：
选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的
内存分配并发问题：
在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 Step3:初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee82935b112662a696c35c8fd71f0097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ae85a2bd532c6e86392c10689311a6/" rel="bookmark">
			多级缓存原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先为什么需要多级缓存？
传统的缓存策略一般是请求到达Tomcat服务后，先查询Redis，如果未命中则查询数据库，存在下面的问题：
请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈。
Redis缓存失效时，会对数据库产生冲击。
多级缓存方案:多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能
用户请求 ——》 反向代理Nginx ——》 业务Nginx （通过lua编写业务逻辑） ——》Redis ——&gt; tomcat（本地缓存） ——》数据库。
实现多级缓存我们需要了解到的知识：Lua 编程（针对Nginx中的逻辑编码）、Nginx本地缓存、本地缓存实现、Openresty、Redis缓存预热。
分布式缓存，例如Redis：
优点：存储容量更大、可靠性更好、可以在集群间共享
缺点：访问缓存有网络开销
场景：缓存数据量较大、可靠性要求较高、需要在集群间共享
进程本地缓存，例如HashMap、GuavaCache、Caffeine
优点：读取本地内存，没有网络开销，速度更快
缺点：存储容量有限、可靠性较低、无法共享
场景：性能要求较高，缓存数据量较小
Redis 冷启动与缓存预热
冷启动：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。
缓存预热：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。
缓存预热
@Componentpublic class RedisHandler implements InitializingBean { @Autowired private StringRedisTemplate redisTemplate; @Override public void afterPropertiesSet() throws Exception { // 初始化缓存 ... } } 缓存同步策略
缓存数据同步的常见方式有三种：
设置有效期：给缓存设置有效期，到期后自动删除。再次查询时更新
优势：简单、方便
缺点：时效性差，缓存过期之前可能不一致
场景：更新频率较低，时效性要求低的业务
同步双写：在修改数据库的同时，直接修改缓存
优势：时效性强，缓存与数据库强一致
缺点：有代码侵入，耦合度高；
场景：对一致性、时效性要求较高的缓存数据
异步通知：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据
优势：低耦合，可以同时通知多个缓存服务
缺点：时效性一般，可能存在中间不一致状态
场景：时效性要求一般，有多个服务需要同步
基于MQ的异步同步策略
基于Canal的异步通知：Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。
Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。不过这里我们会使用GitHub上的第三方开源的canal-starter。地址：https://github.com/NormanGyllenhaal/canal-client
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93ae85a2bd532c6e86392c10689311a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae6f809a5c27bddae8c13e53eae7721/" rel="bookmark">
			【博客624】MAC地址表、ARP表、路由表(RIB表)、转发表(FIB表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAC地址表、ARP表、路由表(RIB表/FIB表) MAC地址表 MAC地址表是交换机等网络设备记录MAC地址和端口的映射关系，代表了交换机从哪个端口学习到了某个MAC地址，交换机把这个信息记录下来，后续交换机需要转发数据的时候就可以根据报文的目的MAC地址去根据MAC地址表转发数据。
ARP表 ARP表就是路由器等网络设备记录IP地址和MAC地址对应关系的表项
当我们需要转发数据的时候除了需要对方的目的IP地址，还需要知道对方的MAC地址，那么正常情况下我们优先会在本地ARP表中查看是否有目的IP对应的MAC地址。
RIB与FIB表的关系 在每一个路由器设备中，通常都维护了两张比较相似的表，分别为：
路由信息表（Routing Information Base），简称为RIB表、路由表
路由表是网络设备根据路由协议生成的表
转发信息表（Forwarding Information Base）, 简称为FIB表、转发表
fib表是网络设备根据路由表生成的转发表
RIB与FIB表的关系：
路由表（RIB表）用来决策路由；转发表用来转发分组由于路由器的核心工作便是为经过路由器的每一个数据包找到最佳路径。在众多路径中选择最快、质量最好、路径最短、…等指标选择最优的路径，并将到达不同网络的最优路径对应的路由组成一张新的表格，即FIB表(转发表)。fib表和路由表不一样的地方在于，路由表中可能存在下一跳非直连的情况，而fib表就不存在这种情况。fib表通过下一跳迭代，避免了下一跳非直连的情况发生。路由器通过路由表选择路由，通过FIB表指导报文进行转发。每台路由器中都保存着一张本地核心路由表（即设备的IP路由表），同时各个路由协议也维护着自己的路由表。路由器使用本地核心路由表用来保存决策优选路由，并负责把优选路由下发到FIB表，通过FIB表指导报文进行转发。这张路由表依据各种路由协议的优先级和度量值来选取路由。路由器使用本地核心路由表用来保存决策优选路由，并负责把优选路由下发到FIB表，通过FIB表指导报文进行转发。这张路由表依据各种路由协议的优先级和度量值来选取路由。FIB强调的是作为转发的路由表，RIB是用来做路由管理的。通常有了动态路由协议的参与才能理解这个问题。RIP、OSPF、BGP、ISIS都是动态路由协议，它们学习到的路由首先要通告给RIB表。RIB表把所有路由协议学习到的路由汇总到一起，经过优选，把优选结果的路由加入到FIB表，供转发使用。所以FIB是RIB的一个子集。 路由表(RIB表) 路由表就是路由器用于指导数据包如何转发的表项，记录了去往目的IP的下一跳去哪里
转发表(FIB表) 在路由表选择出路由后，路由表会将激活路由下发到FIB表中。当报文到达路由器时，会通过查找FIB表进行转发。
FIB表中每条转发项都指明到达某网段或某主机的报文应通过路由器的哪个物理接口或逻辑接口发送，然后就可到达该路径的下一个路由器，或者不再经过别的路由器而传送到直接相连的网络中的目的主机。
FIB表的匹配遵循最长匹配原则。查找FIB表时，报文的目的地址和FIB中各表项的掩码进行按位“逻辑与”，得到的地址符合FIB表项中的网络地址则匹配。最终选择一个最长匹配的FIB表项转发报文。
Linux的RIB表与FIB表 注意：当相同路由不存在多路径情况下，RIB表和FIB表几乎相等
RIB表
[luzejia@localhost ~]$ route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default gateway 0.0.0.0 UG 100 0 0 ens192 10.10.10.0 0.0.0.0 255.255.254.0 U 100 0 0 ens192 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 172.18.0.0 0.0.0.0 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae6f809a5c27bddae8c13e53eae7721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12f3036d2b0fad20bdf12a9cde9e548/" rel="bookmark">
			GNN之节点分类任务—Cora数据集分类（半监督）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据集 该数据集为2708个科学出版物，被分成七类。每个出版物为一个点，每个点为1433维向量，每个类别只有20个点有标注，最终要对每个点进行分类。
from torch_geometric.datasets import Planetoid # 下载数据集使用 from torch_geometric.transforms import NormalizeFeatures dataset = Planetoid(root='', name='Cora', transform=NormalizeFeatures()) # transform预处理 print() print(f'Dataset: {dataset}:') print('======================') print(f'Number of graphs: {len(dataset)}') print(f'Number of features: {dataset.num_features}') print(f'Number of classes: {dataset.num_classes}') data = dataset[0] # Get the first graph object. print() print(data) print('===========================================================================================================') # Gather some statistics about the graph. print(f'Number of nodes: {data.num_nodes}') print(f'Number of edges: {data.num_edges}') print(f'Average node degree: {data.num_edges / data.num_nodes:.2f}') print(f'Number of training nodes: {data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12f3036d2b0fad20bdf12a9cde9e548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7a38e75d38b6ff1ab7dcc7df5a8c32/" rel="bookmark">
			websocket 简单入门 代码 前后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		websocket 就是为了 前后端一直交互的，建立一次连接 可以进行多次信息传输 前端代码 这边 ws 里面的连接 地址按自己的 来修改 后面的地址是 在后端的注解@ServerEndpoint（） 上的
&lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/bootstrap/3.3.2/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;script&gt; var websocket = null; //判断当前浏览器是否支持WebSocket，是则创建WebSocket if ('WebSocket' in window) { console.log("浏览器支持Websocket"); websocket = new WebSocket("ws://localhost:8080/websocket/test"); } else { alert('当前浏览器 Not support websocket') } //连接发生错误的回调方法 websocket.onerror = function () { console.log("WebSocket连接发生错误"); setMessageInnerHTML("WebSocket连接发生错误"); }; //连接成功建立的回调方法 websocket.onopen = function () { // setMessageInnerHTML("WebSocket连接成功"); console.log("WebSocket连接成功"); } //接收到消息的回调方法 websocket.onmessage = function (event) { if (event.data) { setMessageInnerHTML(event.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b7a38e75d38b6ff1ab7dcc7df5a8c32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2c084f6e3354e88bffd1a96bcf2171/" rel="bookmark">
			梅科尔工作室-任采薇-鸿蒙笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要目录配置文件作用（stage模型和FA模型下） 1.stage模型
在基于Stage模型开发的应用项目代码下，都存在一个app.json5及一个或多个module.json5这两种配置文件。
app.json5主要包含以下内容：
应用的全局配置信息，包含应用的包名、开发厂商、版本号等基本信息。
特定设备类型的配置信息。
module.json5主要包含以下内容：
Module的基本配置信息，例如Module名称、类型、描述、支持的设备类型等基本信息。
应用组件信息，包含UIAbility组件和ExtensionAbility组件的描述信息。
应用运行过程中所需的权限信息。
app.json5配置文件
app.json5配置文件包含以下标签。
module.json5配置文件
deviceTypes标签​​​​​​pages标签metadata标签abilities标签skills标签extensionAbilities标签requestPermissions标签shortcuts标签distroFilter标签
testRunner标签
2.FA模型
config.json由app、deviceConfig和module三个部分组成，缺一不可。
app对象内部结构
app对象包含应用全局配置信息
表1 app对象内部结构说明
属性名称
含义
数据类型
是否可缺省
bundleName
标识应用的包名，用于标识应用的唯一性。包名是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~127字节。包名通常采用反向域名形式表示（例如，"com.example.myapplication"）。建议第一级为域名后缀"com"，第二级为厂商/个人名，也可以采用多级。
字符串
不可缺省。
vendor
标识对应用开发厂商的描述。字符串长度不超过255字节。
字符串
可缺省，缺省值为空。
version
标识应用的版本信息。
对象
不可缺省。
apiVersion
标识应用程序所依赖的HarmonyOS API版本。
对象
可缺省，缺省值为空。
smartWindowSize
标识应用在模拟器中运行时使用的屏幕尺寸。
字符串
可缺省，缺省值为空。
smartWindowDeviceType
标识应用在模拟器中运行时可以模拟的设备。
字符串数组
可缺省，缺省值为空。
表2 version对象内部结构说明
属性名称
含义
数据类型
是否可缺省
name
标识应用的版本号，用于向应用的终端用户呈现。取值可以自定义，长度不超过127字节。自定义规则如下：API5及更早的版本：推荐使用三段数字版本号（也兼容两段式版本号），如A.B.C(也兼容A.B)，其中A、B、C取值为0-999范围内的整数。除此之外不支持其他格式。
A段，一般表示主版本号(Major)。
B段，一般表示次版本号(Minor)。
C段，一般表示修订版本号(Patch)。API6版本起：推荐采用四段式数字版本号，如A.B.C.D，其中A、B、C取值为0-99范围内的整数，D的取值为0-999范围内的整数。
A段，一般表示主版本号(Major)。
B段，一般表示次版本号(Minor)。
C段，一般表示特性版本号(Feature)。
D段，一般表示修订版本号(Patch)。
数值
不可缺省。
code
标识应用的版本号，仅用于HarmonyOS管理该应用，不对应用的终端用户呈现。取值规则如下：API5及更早版本：二进制32位以内的非负整数，需要从version.name的值转换得到。转换规则为：code值=A * 1,000,000 + B * 1,000 + C例如，version.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2c084f6e3354e88bffd1a96bcf2171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec55189bbac93f4b5d528140a93f52c/" rel="bookmark">
			最全：2023年华为认证HCIA&#43;HCIP题库合集（含答案解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着华为业务也全球领域的迅猛发展，越来越多人开始重视华为认证的重要性。
想要通过华为认证，除了进行专业的学习，练题刷题也是最重要的一环，今天给大家提供一份全真的华为认证HCIA+HCIP真题文档，帮助大家顺利备考，轻松上岸。
一、HCIA+HCIP（HI2-811、821、831） HCIA（H12-811）
大家可以直接点赞+关注后，加作者微信（备注“CSDN”）就可以获取，微信在文章最后！
HCIP(H12-821)
大家可以直接点赞+关注后，加作者微信（备注“CSDN”）就可以获取，微信在文章最后！
HCIP（H12-831）
大家可以直接点赞+关注后，加作者微信（备注“CSDN”）就可以获取，微信在文章最后！
搜索VX小程序【卓应教育joinlabs】在手机上就可以轻松刷题【包更新】
搜索VX公众号【卓应教育joinlabs】在手机上看题库的视频解析
更多好课在https://ke.joinlabs3.com/
二、整卷题目解析（HCIA-821模拟卷）
1、网络管理员给网络中的某台主机分配的IPv4地址为192.168.1.1/28、则这个主机所在的网络还可以增加多少台主机?（ ）
A、12 B、15 C、13 D、14
试题答案：C
试题解析：192.168.1.1/28对应的2进制表示为11000000.10101000.00000001.0000 0000/28。前28位固定为网络位，最后4位为主机位。网络位固定不变，变化主机位！可以看到主机位可以从0000变化到1111，共16种变化！除去主机位全0（代表网络地址）、全1（代表广播地址）的情况，剩下14个合法的IP地址，范围是192.168.1.1~192.168.1.14。故选C。
2、下面哪个OSPF版本适用于IPv6?（ ）
A、OSPFv1 B、OSPFv2 C、OSPFv3 D、OSPFv4
试题答案：C
试题解析：OSPF协议是为IP协议提供路由功能的路由协议。OSPFv2（OSPF版本2）是支持IPv4的路由协议，为了让OSPF协议支持IPv6，技术人员开发了OSPFv3（OSPF版本3），OSPFv3由RFC2740定义。故选C。
3、VRP操作平台、以下哪条命令可以只查看静态路由?（ ）
A、display ip routing-table statistics B、display ip routing-table verbose
C、display ip routing-table D、display ip routing-table protocol static
试题答案：D
试题解析：display ip routing-table protocol static，该命令是只查看路由表中通过静态配置方式获得路由条目。故选D。
4、路由器工作在OSI参考模型的哪一层?（ ）
A、数据链路层 B、传输层 C、应用层 D、网络层
试题答案：D
试题解析：路由器工作在OSI七层模型的第三层网络层，路由器使用IP地址进行寻址，实现源IP到目标IP的端到端的无连接数据报服务。故选D。
5、如果应用层协议为TeInet，那么IPv4首部中Protocol字段取值为?（ ）
A、23 B、17 C、6 D、67
试题答案：C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ec55189bbac93f4b5d528140a93f52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf91a87eb121add0ce6ac36fca0b6c06/" rel="bookmark">
			第十七节 DRM 图形显示框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以往我们在Linux 上为显示设备开发驱动时，通常使用的是FrameBuffer 的驱动框架，在Frame-Buffer 驱动框架下，我们能够快速开发出可供简单使用的显示驱动。但是随着芯片显示外设的性能逐渐增强及GPU 的引入，FrameBuffer 框架看起来似乎就有些落伍了，最直接的体现，就是在传统的框架下，对于许多芯片显示外设的新特性如：显示覆盖（菜单层级）、GPU 加速、硬件光标等功能并不能得到很好得支持，并且FrameBuffer 框架将底层的显存通过用户空间/dev/fb 接口，暴露给了用户空间，这很容易导致不同的应用程序在操作显存时，产生访问冲突，而且这种方式看起来似乎不是那么安全。
在这背景下，就需要一个现代的图形显示框架来解决这些问题，那么DRM（Direct Rendering Manager，直接图形管理器）诞生。
框架简述 那么DRM 图形显示框架是怎么解决FrameBuffer 框架遇到的困境呢？DRM 将现代显示领域中会涉及的一些操作进行分层并使这些模块独立，如过上层应用想操作显存、显示效果抑或是GPU，都必须在一些框架的约束下进行，我们可以来了解一下。
我们可以从用户空间、内核空间的两个角度去了解DRM 框架：
用户空间（libdrm driver）：
Libdrm（DRM 框架在用户空间的Lib） 内核空间（DRM driver）：
KMS（Kernel Mode Setting，内核显示模式设置）GEM（Graphic Execution Manager，图形执行管理器） Libdrm DRM 框架在用户空间提供的Lib，用户或应用程序在用户空间调用libdrm 提供的库函数，即可访问到显示的资源，并对显示资源进行管理和使用。
这样通过libdrm 对显示资源进行统一访问，libdrm 将命令传递到内核最终由DRM 驱动接管各应用的请求并处理，可以有效避免访问冲突。
KMS（Kernel Mode Setting） KMS 属于DRM 框架下的一个大模块，主要负责两个功能：显示参数及显示控制。这两个基本功能可以说是显示驱动必须基本的能力，在DRM 框架下，为了将这两部分适配得符合现代显示设备逻辑，又分出了几部分子模块配合框架。
Planes 基本的显示控制单位，每个图像拥有一个Planes，Planes 的属性控制着图像的显示区域、图像翻转、色彩混合方式等，最终图像经过Planes 并通过CRTC 组件，得到多个图像的混合显示或单独显示的等等功能。
CRTC CRTC 的工作，就是负责把要显示图像，转化为底层硬件层面上的具体时序要求，还负责着帧切换、电源控制、色彩调整等等。
Encoder Encoder 的工作则是负责电源管理、视频输出格式封装（比如要将视频输出到HDMI 接口、MIPI接口等）。
Connector Connector 连接器负责硬件设备的接入、屏参获取等。
上述的这些组件，最终完成了一个完整的DRM 显示控制过程，如下图所示：
参考资料Kernel Mode Setting (KMS) .
GEM（generic DRM memory-management） 顾名思义，GEM 负责对DRM 使用的内存（如显存）进行管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf91a87eb121add0ce6ac36fca0b6c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74628cf233fcaea7913ce1e68c8f411d/" rel="bookmark">
			关于SpringBoot解决前后端分离项目跨域的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在采用前后端分离方式进行项目的开发时，跨域问题是不可避免的。
这里主要采用从后端配置corsFilter的方式解决跨域问题，完整代码如下
CorsFilter @Configuration public class CorsConfig { // 当前跨域请求最大有效时长。这里默认1天 private static final long MAX_AGE = 24 * 60 * 60; @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); // 设置访问源地址 corsConfiguration.addAllowedHeader("*"); // 设置访问源请求头 corsConfiguration.addAllowedMethod("*"); // 设置访问源请求方法 corsConfiguration.setMaxAge(MAX_AGE); source.registerCorsConfiguration("/**", corsConfiguration); // 对接口配置跨域设置 return new CorsFilter(source); } } 解决跨域问题还有很多方法，这里就不一一赘述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effc0ec7365b7c5cd2ce40a4b234d253/" rel="bookmark">
			Topsis算法实践：比较LSTM算法与BP神经网络算法，以chickenpox_dataset为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Topsis简介
模型分类与转化
极小转化为极大型
中间最优型转极大值
区间最优[a,b]转极大型
计算得分并归一化
LSTM算法预测
数据加载处理
定义和训练LSTM网络
预测并返回误差
BP神经网络预测
数据处理
构建BP神经网络并返回预测值与真实值的误差
​编辑
利用Topsis算法比较两方案的优劣性
数据处理
正向化与标准化
归一化并计算得分
排序得出结果
​编辑
补充说明和疑问
LSTM简介
疑问
Topsis简介 TOPSIS算法（Technique for Order Preference by Similarity to Ideal Solution）可翻译为逼近理想解排序法，国内常简称为优劣解距离法。TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据信息，其结果能精确地反映各评价方案之间的差距。
模型分类与转化 X=[xij]m×n;m为评价对象，n为评价指标;
下面是对评价指标的四种分类：极大型（越大越好），极小型，中间型（某点最优），区间最优型
为方便处理，统一转化为极大型来解决
极小转化为极大型 max-x;若对象均为正数，也可使用1/x
中间最优型转极大值 M=max{|xi-xbest|}, x_i=1-|xi-xbest|/M
区间最优[a,b]转极大型 M=max{a-min(xi),b-max{xi}},x_i=
1-(a-xi)/M x&lt;a
1 a&lt;=x&lt;=b
1-(xi-b)/M x&gt;b
计算得分并归一化 参考清风数模笔记
LSTM算法预测 代码来源：matlab help center deep learning toolbox
数据加载处理 data = chickenpox_dataset; data = [data{:}]; %序列的前 90% 用于训练，后 10% 用于测试。 numTimeStepsTrain = floor(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effc0ec7365b7c5cd2ce40a4b234d253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc2b8cb5c036054cd3b7db712055547/" rel="bookmark">
			低代码平台之部署openfaas及基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 OpenFaaS是打包源代码、二进制文件或者容器作为Serverless函数编程的框架，可以在windows、linux等平台上运行。
使用它构建函数的流程如下：
通过模板new创建函数build函数为docker镜像push镜像到docker registrydeploy函数invoke函数 其实这些步骤对应的是faas-cli客户端的几个命令，下面会提到，同时，我也围绕这几个流程来扩展它的实际应用。
学习须知 本博客是基于linux、k8s、dockers、openfaas，使用的是root用户。k8s和docker的版本及安装参见前面的博客，openfaas直接使用的最新的版本。
本博客是使用js的express框架作为发布的函数，其实我们不需要关注这个express框架，只需要记住它帮我们启动了一个nodejs的web服务器。
基于k8s部署openfaas 官网提供了三种方式部署openfaas：arkade、helm3和静态yaml文件。
官网推荐使用arkade，但学习成本高。
helm3稍微麻烦点，但是可以修改配置文件实现细粒度的设置。
静态yaml好像没有过多的介绍，但是在openfaas的git上，看到了faas-netes仓库，通过一些介绍，我猜测是指这个。
现在，咱们就用faas-netes来搞吧，因为最简单，随后再研究helm3部署。
注：我们外网使用的是helm3进行部署的。
使用faas-netes部署 没有安装git的话，就先安装git吧，这里就不多介绍git安装了。
git clone https://github.com/openfaas/faas-netes cd faas-netes kubectl apply -f namespaces.yml kubectl -n openfaas create secret generic basic-auth \ --from-literal=basic-auth-user=admin \ --from-literal=basic-auth-password=admin kubectl apply -f ./yaml/ 上面一大串的代码，直接复制粘贴，其中
kubectl apply -f namespaces.yml
是创建openfaas相关的命名空间，分别为openfaas和openfaas-fn两个，以后发布的函数会被部署在openfaas-fn命名空间下。
kubectl -n openfaas create secret generic basic-auth --from-literal=basic-auth-user=admin --from-literal=basic-auth-password=admin
新建openfaas ui界面的账号密码
kubectl apply -f ./yaml/
执行这个命令后，会启动openfaas相关的pod，kubectl get pods -A查看pod的状态，这些pod可能启动起来会太耗时，我的耗时半小时才全部启动成功，和网速有关系
kubectl delete -f .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc2b8cb5c036054cd3b7db712055547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77707d205114d0118cd86f1cc094a3ed/" rel="bookmark">
			df.drop_duplicates()删除提取重复记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、导入表，查看df 2、df.drop_duplicates()，删除多余的重复值 3、df.drop_duplicates(keep=False)，重复的都删掉，相当于消消乐 4、提取重复记录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0994838ce4bfb0a64ed9f4de1cd09196/" rel="bookmark">
			js的递归基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能很多人在大一的时候，就已经接触了递归了，不过，我敢保证很多人初学者刚开始接触递归的时候，是一脸懵逼的，我当初也是，给我的感觉就是，递归太神奇了！
可能也有一大部分人知道递归，也能看的懂递归，但在实际做题过程中，却不知道怎么使用，有时候还容易被递归给搞晕。也有好几个人来问我有没有快速掌握递归的捷径啊。说实话，哪来那么多捷径啊，不过，我还是想写一篇文章，谈谈我的一些经验，或许，能够给你带来一些帮助。
为了兼顾初学者，我会从最简单的题讲起！
递归的三大要素 第一要素：明确你这个函数想要干什么
对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。
例如，我定义了一个多层数组来求和
const add = (arr) =&gt; { let result = 0; arr.forEach((item,) =&gt; { if (Array.isArray(item)) { result += add(item) } else { result += item } }) return result; }; const arr = [121, 200, 300, 400, [500, 600, [700, 80, [1, 20]]]] console.log(add(arr)); 第二要素：寻找递归结束条件
所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。
第三要素：找出函数的等价关系式
第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。
至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。
这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。
还是不懂？没关系，我再按照这个模式讲一些题。
案例1：斐波那契数列 斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34…，即第一项 f(1) = 1,第二项 f(2) = 1…,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0994838ce4bfb0a64ed9f4de1cd09196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3077dccfb2478ba1d57ee9dedc99f1/" rel="bookmark">
			IDEA国际化资源Key无法全局重命名的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 最近在开发中使用到了HibernateValidator进行入参校验以及错误消息的国际化支持。大家应该都知道在使用HibernateValidator进行校验的时候，我们只需在需要在校验的变量上添加相应的注解，同时在message中指定对应的错误信息的国际化资源Key即可（如下图）。这里的message对应的国际化资源key必须要使用大括号。
上述使用方法是HibernateValidator的标准使用方法，功能实现上并没有什么毛病。但是这种方法却带来了一个弊端，它可能增加咱们得开发工作量，甚至会影响业务。为什么会这个问题呢？接下来咱们一起看看下面这个问题。
如果咱们需要对消息key进行全局重命名，比如将图中的validation.dataSourceVO.name.notBlank修改为validation.dataSourceVO.name.notEmpty，大家想想咱们一般会怎么操作。
很明显我们都会使用IDEA的重命名功能，直接对这个变量进行重命名。修改完成后，注解中的key和message.properties文件中对应的key、以及所有代码中对应的该变量都会同步修改。对么？！
对，也不对！首先这种思路完全没问题，因为使用IDEA的重命名能够将所有关联的地方的内容全部都进行修改。但是这种方式在这里却不行！为什么呢？因为我们使用了大括号对消息key进行包围。使用了大括号后，IDEA根本不会提供重命名功能。
如下图，当有大括号后在refactor中没有rename功能。但当没有大括号后refactor中则出现嘞rename功能。
上面这种现象就导致了当我们要重命名消息key的时候，我们不得不一处一处将所有涉及的地方手动修改。这就带来如下两个问题：
a、增加了工作量。
b、可能因为自己没有修改全面导致业务出错。
为了避免上述问题，咱们就需要在注解中直接使用没有大括号的消息Key。所以我们需要让HibernateValidator支持没有大括号的消息Key。这具体怎么实现呢？经过不断地折腾深入源码，我终于找到了解决办法。下面给大家分享下解决思路和办法。
1、HibernateValidator的流程
首先我们简单整理下HibernateValidator校验失败后提示错误消息的整个流程。如上图：
a、用户提交请求，然后HibernateValidator基于注解内容进行校验。
b、如果未通过校验，则获取注解中的错误消息Key，如：{validation.name.empty}
c、然后进行一些处理，最后去掉错误消息Key的大括号得到真正的错误消息Key，如：validation.name.empty
d、最后根据真实的消息Key(validation.name.empty)去messages.properteis文件中查找对应的错误消息，并返回给调用方。
2、方案1：让Hibernate不判断大括号
基于上述流程，我们可以看到HibernateValidator认为使用了大括号的资源Key才是国际化资源Key。所以咱们可以想到的最简单的办法就是去掉图中2的逻辑，即让HibernateValidator不对大括号进行处理（即没有大括号的资源Key也是国际化资源Key）。于是通过深入源码进行追踪，砸门能够发现大括号的处理在如下的一个私有方法(AbstractMessageInterpolator.removeCurlyBraces)中进行。如下图，其处理还有点暴力，直接去掉消息Key第一个和最后一个字符（前面有地方判断是否有大括号）。
所以如果想从这个地方入手就必须重写其调用位置的逻辑，由于其调用逻辑非常复杂（有兴趣大家可以自己跟踪下代码），所以需要重写很多HibernateValidator的原始逻辑。最终肯定能够实现功能，但是这种方式却不可取。因为咱们在修改源码实现业务的时候有一个基本的原则：尽量减少对原始代码的重写和修改。因为过多的修改会带来很多问题，比如：
a、后续底层框架升级后咱们修改的大量代码逻辑很可能得不到及时升级。从而导致底层BUG得不到及时解决，新功能得不到及时升级。
b、由于修改了大量的底层代码，因此维护成本也会增加。
所以，这种方法咱们暂时放弃，接下来我们另谋出路。
3、方案2：给资源自动添加大括号
让HibernateValidator不判断大括号的方案不可行后，咱们则可以换一种思路。即让注解中配置的时候使用不含大括号的消息Key，但在HibernateValidator处理之前（图中标记1的位置）给他加上去。
于是咱们进一步分析底层源码逻辑，发现所有消息Key从注解中解析出来后，就会调用AbstractMessageInterpolator.interpolate方法进行后续的解析操作（处理消息Key、去除大括号、从messages.properties中获取错误消息等）。该方法本身是一个public方法，子类可以继承和处理。
基于该思路，咱们重写实现了HibernateValidator使用的ResourceBundleMessageInterpolator（AbstractMessageInterpolator的实现类），并修改了interpolate的处理逻辑。即在调用真实的处理逻辑前面，咱们根据条件给消息Key添加上大括号。
已经准备好会后，最后就是将自定义的RasMsgResourceBundleMessageInterpolator设置到HibernateValidator中，如下图在构建HibernateValidator的时候设置即可。
4、方案总结 通过分析可知，两种方案很明显方案2要高级很多。它在解决问题的同时还符合咱们的源码修改基本原则：对源码进行最小的改动！其实通过代码可知，咱们方案2根本就没有对源码进行修改。只是利用继承的原理通过子类重写interpolate方法实现来实现了咱们需要的功能。 三、惯例 如果你喜欢本文或觉得本文对你有所帮助，欢迎一键三连支持，非常感谢。
如果你对本文有任何疑问或者高见，欢迎添加公众号lifeofcoder共同交流探讨（添加公众号可以获得楼主最新博文推送以及”Java高级架构“上10G视频和图文资料哦）。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/100/">«</a>
	<span class="pagination__item pagination__item--current">101/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/102/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>