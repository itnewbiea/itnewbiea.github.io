<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefcd6e372f79c5ed9b471e967ca3000/" rel="bookmark">
			【LeetCode:11. 盛最多水的容器 | 双指针】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 算法题 🚀 🌲 算法刷题专栏 | 面试必备算法 | 面试高频算法 🍀
🌲 越难的东西,越要努力坚持，因为它具有很高的价值，算法就是这样✨
🌲 作者简介：硕风和炜，CSDN-Java领域新星创作者🏆，保研|国家奖学金|高中学习JAVA|大学完善JAVA开发技术栈|面试刷题|面经八股文|经验分享|好用的网站工具分享💎💎💎
🌲 恭喜你发现一枚宝藏博主,赶快收入囊中吧🌻
🌲 人生如棋，我愿为卒，行动虽慢，可谁曾见我后退一步？🎯🎯
🚀 算法题 🚀 🍔 目录 🚩 题目链接⛲ 题目描述🌟 求解思路&amp;实现代码&amp;运行结果⚡ 二分🥦 求解思路🥦 实现代码🥦 运行结果 💬 共勉 🚩 题目链接 11. 盛最多水的容器 ⛲ 题目描述 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。
示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 2：
输入：height = [1,1]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eefcd6e372f79c5ed9b471e967ca3000/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01694cf3b489c10e3cefaa6b9461a79c/" rel="bookmark">
			推荐 5 个近期火火火的 GitHub 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期推荐开源项目目录：
1. 开源聊天机器人框架
2. 大语言模型的知识库问答系统
3. 项目管理工具
4. 基于 JavaScript 的工具集合
01 开源聊天机器人框架
这个开源项目是 Lobe Chat，它是一个高性能的开源聊天机器人框架，支持语音合成、多模态和可扩展的插件系统。
Lobe Chat 的特色功能包括：
支持 OpenAI 的最新 gpt-4-vision 模型，具备视觉识别能力。能够识别图像内容并基于此进行智能对话，创造更智能、多样化的聊天场景。
支持文本转语音 (TTS) 和语音转文本 (STT) 技术，使用户可以选择多种声音与代理进行交互，为用户提供仿佛与真人交谈的体验。
Lobe Chat 的插件生态系统大大扩展了其核心功能，通过插件，ChatGPT 可以进行实时信息检索和处理，例如自动获取最新新闻标题以提供用户即时和相关的信息。
除此之外，Lobe Chat 还具有快速部署、自定义域名、隐私保护、精美 UI 设计和流畅对话体验等基本技术功能。
开源地址：https://github.com/lobehub/lobe-chat 02 大语言模型的知识库问答系统
FastGPT 是一个基于 LLM（Large Language Model）大型语言模型的知识库问答系统。
它提供了一整套开箱即用的功能，包括数据处理、模型调用等能力，并且通过可视化的 Flow 进行工作流编排，从而实现复杂的问答场景。
开源地址：https://github.com/labring/FastGPT 03 项目管理工具
Plane 是一个灵活、可扩展的项目管理工具。它提供了迭代和产品路线图的功能，为开发团队提供了方便和放心的管理工具。它提供了丰富的特性，包括但不限于：
问题规划和追踪：使用强大的富文本编辑器快速创建问题并添加细节。支持附加文件，有助于团队查找和共享重要的项目相关文档。
布局：自定义项目视图，选择列表、看板或日历来直观地查看项目。
迭代计划：通过迭代计划（Cycles）规划项目的迭代，通过燃尽图等功能了解项目进度。
模块：将大型项目拆分为更小、更易管理的模块。轻松追踪和规划项目的进展。
视图：创建自定义筛选器，仅显示对你重要的问题。保存和分享你的筛选器。
开源地址：https://github.com/makeplane/plane 04 基于 JavaScript 的工具集合
Oxc 是一个开源项目，旨在为 JavaScript 和 TypeScript 提供高性能的工具集合。它的目标是构建一系列用 Rust 编写的工具，包括解析器、代码检查器、格式化器、转译器、代码压缩器等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01694cf3b489c10e3cefaa6b9461a79c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570b5d89e4f5ae2d49eedeada416fbc9/" rel="bookmark">
			蓝桥杯单片机进阶教程2——简单模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 温度模块DS18B20 1、比赛过程中的参考资料（比赛会提供，按照这个就不用记忆了） 原理图
文章第四页
文章第十到十二页
2、分析考题 （1）只考最简单的温度转换，温度读取
3、实验 进行最简单的温度转换与温度读取，然后用串口打印到电脑上
参考代码：
https://gitee.com/late-night-study/Tech 第二章 时钟模块DS1302 1、比赛过程中的参考资料 原理图
文章第九页
2、分析考题 （1）一般只考设置、读取时分秒
3、实验 设置当前时间为16小时59分50秒，每一秒读取当前时间，然后用串口打印到电脑上
参考代码：
https://gitee.com/late-night-study/Tech 第三章 E2PROM存储器AT24C02 1、比赛过程中的参考资料 原理图
第十一页
2、分析考题 （1）考察往E2PROM中分多次写入多个结果
（2） 考察上电写入断电之前保存的参数
3、实验 上电前读取之前保存的时间，用延时函数模拟时钟（例 12：50：59），每秒向E2PROM保存一次时分秒，保存完后通过串口将电脑发送当前时间（时间不要求精确，这里只是测试E2PROM是否写入读取成功）
参考代码：
https://gitee.com/late-night-study/Tech 第四章 数模转换模块PCF8591 1、比赛过程中的参考资料 原理图：
第五、六、八、十四页
2、分析考题 主要考察ADC输入与DAC输出，其中ADC考察采集光敏电阻、电位器电压
3、实验 分别读取光敏电阻和电位器电压，输出电位器电压，将光敏电阻、电位器电压通过串口发送到电脑 参考代码：
https://gitee.com/late-night-study/Tech
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f46d80a84a5b8b1c8e7ee4a452ab389/" rel="bookmark">
			html js加载本地文件报错处理，跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题是怎么来的？我写了一个本地html文件，里面通过three.js加载并显示一个本地三维模型，结果报错了。
报错如下：
Access to XMLHttpRequest at 'file:///C:/model/quater.mtl' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.
没玩过前端，看到这个错误不知道从何下手，查了半天了解到大体意思就是：
浏览器html加载本地资源文件，会被阻止。解决方法是搭建一个本地服务器，然后从这个服务器访问这个html文件，这样html和其他资源文件，会被浏览器判定为同一个域。
从这里找到一个解决方法：
Three.js教程
首先下载node.js的windows安装包，安装完以后，打开命令行，查询两个版本号，如果没有报错，就说明node.js和npm都安装好了。
然后继续执行命令：npm install -g live-server来安装一个名字叫live-server的软件，并等待它安装完成。
然后cd命令进入html所在的文件夹，并执行live-server命令
他会自动打开浏览器，并浏览到这个文件夹：
然后打开我们的html文件就可以了，这时html中的js要访问这个文件夹及其子文件夹下的文件，就不会报错了。
还有个问题就是，当修改了html文件以后，浏览器中的文件并不会更新，需要打开html并刷新页面才行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f1f99ff8eb11a1d8a05897feb902d9/" rel="bookmark">
			力扣labuladong一刷day51天单调栈应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣labuladong一刷day51天单调栈应用 一、239. 滑动窗口最大值 题目链接：https://leetcode.cn/problems/sliding-window-maximum/
思路：滑动窗口最大值，既要维护加入的时间顺序，又要
class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int[] res = new int[nums.length - k + 1]; Queue queue = new Queue(); for (int i = 0; i &lt; k; i++) { queue.push(nums[i]); } int j = 0; res[j++] = queue.getMax(); for (int i = k; i &lt; nums.length; i++) { queue.pop(nums[i-k]); queue.push(nums[i]); res[j++] = queue.getMax(); } return res; } class Queue { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); void push(int n) { while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f1f99ff8eb11a1d8a05897feb902d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68857355cd683820dffd6c814953c82e/" rel="bookmark">
			基于ssm的旅游网页开发与设计&#43;jsp论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 信息数据从传统到当代，是一直在变革当中，突如其来的互联网让传统的信息管理看到了革命性的曙光，因为传统信息管理从时效性，还是安全性，还是可操作性等各个方面来讲，遇到了互联网时代才发现能补上自古以来的短板，有效的提升管理的效率和业务水平。传统的管理模式，时间越久管理的内容越多，也需要更多的人来对数据进行整理，并且数据的汇总查询方面效率也是极其的低下，并且数据安全方面永远不会保证安全性能。结合数据内容管理的种种缺点，在互联网时代都可以得到有效的补充。结合先进的互联网技术，开发符合需求的软件，让数据内容管理不管是从录入的及时性，查看的及时性还是汇总分析的及时性，都能让正确率达到最高，管理更加的科学和便捷。本次开发的旅游网站实现了字典管理、论坛管理、公告信息管理、景点管理、景点收藏管理、景点留言管理、用户管理、管理员管理等功能。系统用到了关系型数据库中王者MySql作为系统的数据库，有效的对数据进行安全的存储，有效的备份，对数据可靠性方面得到了保证。并且程序也具备程序需求的所有功能，使得操作性还是安全性都大大提高，让旅游网站更能从理念走到现实，确确实实的让人们提升信息处理效率。
关键字：信息管理，时效性，安全性，MySql
Abstract
Information data has been changing from traditional to contemporary, and the sudden Internet has allowed traditional information management to see a revolutionary dawn, because traditional information management is in terms of timeliness, security, or operability. It was only after encountering the Internet era that it was able to make up for the shortcomings since ancient times, and effectively improve the management efficiency and business level.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68857355cd683820dffd6c814953c82e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4b4c222f5aab30305c92b4f18ff003/" rel="bookmark">
			开源CalDAV和CardDav网页客户端InfCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文应网友 畅天 的要求折腾。他遇到了跨域问题，所以老苏找了个二合一的镜像来规避。其中使用的 Baikal 和 InfCloud 都是最新的版本；
什么是 Baikal ？
Baikal 是一个免费的开源自托管 CalDAV 和 CardDAV 服务器，适用于想要管理其数据并确保其数据是私有的用户。
什么是 InfCloud ?
InfCloud 是一个开源的 CalDAV/CardDAV 网页客户端。
安装 在群晖上以 Docker 方式安装。
在注册表中搜索 baikal-infcloud ，选择第一个 squibbles/baikal-infcloud，版本选择 v1.1。
卷 在 docker 文件夹中，创建一个新文件夹 baikal-infcloud，并在其中建一个子文件夹 data
文件夹装载路径说明docker/baikal-infcloud/data/var/www/baikal/Specific/存放数据库和上传文件等 端口 本地端口不冲突就行，不确定的话可以用命令查一下
# 查看端口占用 netstat -tunlp | grep 端口号 本地端口容器端口88018800 环境 可变值TIMEZONE默认为：Europe/London，改设为 Asia/Shanghai 命令行安装 如果你熟悉命令行，可能用 docker cli 更快捷
# 新建文件夹 baikal-infcloud 和 子目录 mkdir -p /volume1/docker/baikal-infcloud/data # 进入 baikal-infcloud 目录 cd /volume1/docker/baikal-infcloud # 运行容器 docker run -d \ --restart unless-stopped \ --name baikal-infcloud \ -p 8801:8800 \ -v $(pwd)/data:/var/www/baikal/Specific/ \ -e TIMEZONE=Asia/Shanghai \ squibbles/baikal-infcloud:v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b4b4c222f5aab30305c92b4f18ff003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffbf0126cdb12ef4571604abec56da7/" rel="bookmark">
			C&#43;&#43;虚函数浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++虚函数浅析 虚函数的工作原理：基类中的私有虚函数：虚析构函数：C++中的静态联编和动态联编虚函数重载 学习过C++的都知道可以通过虚函数实现多态。在基类中定义一个虚函数，在派生类中可以重写这个虚函数，实现派生类自己的特性。 虚函数的工作原理： C++规定了函数名参数返回值，没有规定实现，可以根据需要自行实现内容。通常编译器处理虚函数的方法是给每个对象添加一个隐藏成员。该成员保存了一个指向函数地址的数组指针，这个数组指针也就是虚函数表。虚函数表中保存了对象中所有虚函数的地址（包括继承的基类的虚函数地址），如果派生类多重继承就会存在多个虚函数表，派生类本身的虚函数表会出现在继承顺序第一个基类后面，下面举例演示一下：
class a{ public: virtual void base_a1(); virtual void base_a2(); ] class b{ public: virtual void base_b1(); virtual void base_b2(); ] class c{ public: virtual void base_c1(); virtual void base_c2(); ] class d:public a,public b,public c{ virtual void derive_d1(); virtual void derive_d2(); } int main(){ d derive_d; } 上面代码中定义derive_d的虚函数表结构如下图：
在对象所占内存的开始位置存在隐藏成员指针a、指针b、指针c，他们分别指向对应的虚函数表，对象自己的虚函数表在第一个继承的基类的后面。
class d:public a,public b,public c{ void base_b2（）； virtual void derive_d1(); virtual void derive_d2(); } 如果派生类重写了基类的函数(方法)，那么在上图base_b2处的地址将变成指向派生类实现base_b2方法的地址。此时用派生类的对象在调用base_b2方法时调用的就是派生类重写的base_b2方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ffbf0126cdb12ef4571604abec56da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63f5503c8a33cbc3315f1a966f5443d3/" rel="bookmark">
			rabbitmq自定义消息序列化与反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rabbitmq自定义消息序列化与反序列化_mq序列化-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc14a53c9d49d48af98e4a5d27a06df7/" rel="bookmark">
			详解Java实现2048小游戏（JavaFX，完整源码&#43;注释说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚完成的一个小游戏，写文章记录一下，如果有任何错误或者可以改进的代码请提出
另一方面也是方便自己几个月或几年后忘记时，来这里翻一翻回顾思路
目录
基本界面：
类的组织：
_CardPane：
_CardMatrixPane：
_CardColor：
_GameMenuBar：
_2048Demo：
基本思路：
卡片：
卡片矩阵：
颜色：
游戏菜单：
控制器：
首先放一下效果图：
基本界面： 所有卡片
分数统计
尺寸为5x5或6x6
类的组织： 五个类，最基础的是_CardPane，继承自BorderPane，作为数字卡片。它里面有一个Rectangle，用来表示卡片的圆角矩形背景，以及一个Label来显示数字
然后是由数字卡片组成的矩阵_CardMatrixPane，继承自StackPane，它包含一个GridPane
_CardColor，里面只有一个静态的Color数组，用来搞卡片的背景颜色
_GameMenuBar作为游戏的菜单栏，继承自MenuBar
最后是_2048Demo，相当于控制器
这里类名前面加下划线是个人习惯，因为我的Eclipse项目名、包名、类名等等都会与图标重合一些，加下划线可以看的方便，如下：
下面放代码：
_CardPane： package _2048._node; import _2048._model._CardColor; import javafx.scene.control.Label; import javafx.scene.layout.BorderPane; import javafx.scene.paint.Color; import javafx.scene.shape.Rectangle; /** * 节点类——数字卡片 * @author 邦邦拒绝魔抗 * */ //若继承自Pane类,缺少需要的setAlignment()方法 //若继承自StackPane类,会出现一些绘制错误 public class _CardPane extends BorderPane { private static final int RC=5;//矩形的圆角 private int type; /* 类型 * type=0	number=0 * type=1	number=2 * type=2	number=4 * type=3	number=8 * .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc14a53c9d49d48af98e4a5d27a06df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193d3b76557c3f5a8e7fe563dba1dce5/" rel="bookmark">
			关于“Python”的核心知识点整理大全58
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
19.2.3 注销
1. 注销URL
urls.py
2. 视图函数logout_view()
views.py
3. 链接到注销视图
base.html
19.2.4 注册页面
1. 注册页面的URL模式
urls.py
2. 视图函数register()
views.py
3. 注册模板
register.html
4. 链接到注册页面
base.html
注意
19.3 让用户拥有自己的数据
19.3.1 使用@login_required 限制访问
1. 限制对topics页面的访问
views.py
settings.py
2. 全面限制对项目“学习笔记”的访问
views.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
19.2.3 注销 现在需要提供一个让用户注销的途径。我们不创建用于注销的页面，而让用户只需单击一个 链接就能注销并返回到主页。为此，我们将为注销链接定义一个URL模式，编写一个视图函数， 并在base.html中添加一个注销链接。
1. 注销URL 下面的代码为注销定义了URL模式，该模式与URL http://locallwst:8000/users/logout/匹配。修 改后的users/urls.py如下：
urls.py --snip-- urlpatterns = [ # 登录页面 --snip-- # 注销 url(r'^logout/$', views.logout_view, name='logout'), ] 这个URL模式将请求发送给函数logout_view()。这样给这个函数命名，旨在将其与我们将在 其中调用的函数logout()区分开来（请确保你修改的是users/urls.py，而不是learning_log/ urls.py）
2. 视图函数logout_view() 函数logout_view()很简单：只是导入Django函数logout()，并调用它，再重定向到主页。请 打开users/views.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193d3b76557c3f5a8e7fe563dba1dce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc3a071e801a2e78fcf05c3feb2ee0a/" rel="bookmark">
			异步爬虫-协程的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协程的基本原理 要想实现异步机制的爬虫，自然和协程逃脱不了关系。
1.案例引入 在介绍协程之前，先引入https://www.httpbin.org/delay/5这个网站，访问这个网站需要服务器强制等待5秒才会返回响应。
我们使用requests写一个遍历程序，直接遍历100次该网站，看下需要多久时间。
import requests import logging import time logging.basicConfig(level=logging.INFO,format='%(asctime)s - %(levelname)s - %(message)s') TOTAL_NUMBER = 10 url = 'https://www.httpbin.org/delay/5' start_time = time.time() for _ in range(1,TOTAL_NUMBER+1): logging.info('scraping %s',url) response = requests.get(url) end_time = time.time() logging.info('total time %s seconds',end_time-start_time) 这里使用的requests是单线程，由于每个页面都要等待至少5秒，请求100次至少花费500秒加上网站本身负载问题，总时间大约会在10分钟以上，耗时比较久，所以开启多线程爬取非常有必要。
2.基础概念知识 阻塞
程序在等待某个操作完成期间，自身无法干别的事情，则该程序在操作上是阻塞的。非阻塞
程序在等待某个操作期间，自身不被阻塞可以继续干别的事情，则该程序在操作上是非阻塞的。同步
不同程序单元为了共同完成某个任务，在执行过程中需要靠某种通讯方式保持一致，此时这些程序单元是同步执行的。
同步意味着有序。异步
异步意味着无序。多进程
就是利用cpu的多核优势，在同一时间内并行执行多个任务。协程
又称微线程，是一种运行在用户态的一种轻量级线程。协程本质上是一个单进程。
进程是线程的集合，一个任务对应一个线程。 3.协程的用法 python中使用协程最常用的库莫过于asyncio。
event_loop：相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，当满足条件发生的时候，就调用对应的处理办法。coroutine：协程。我们可以使用async关键字来定义一个方法，这个方法在调用时不会立即执行，而是会返回一个协程对象。task：任务，这是对协程对象的进一步封装，包括协程对象的各个状态。future：代表将来执行或者没有执行的结果，和task没有本质区别。
async和await。前者来定义一个协程，后者用来挂起阻塞方法的执行。 4.准备工作 Python3.5及以上。
5.定义协程 先来定义一个协程，体验下它和普通进程实现上的不同之处。
import asyncio async def execute(x): print('number:',x) coroutine = execute(1) print('Coroutine:',coroutine) print('After calling exxecute') loop = asyncio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc3a071e801a2e78fcf05c3feb2ee0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1382c845a03734d628b4954d8f82eda1/" rel="bookmark">
			Weblogic安全漫谈(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 继本系列上篇从CVE-2015-4852入手了解T3协议的构造后，本篇继续分析开启T3反序列化魔盒后的修复与绕过。
Weblogic对于10.3.6推出了p20780171和p22248372用于修复CVE-2015-4852，在补丁详情中又提示了p21984589是它的超集，所以可以直接装这个合集。跟着压缩包里自带的README.txt走就行，注意一点是要改一下bsu.sh中的内存限制，不然会遇到Java heap space OutOfMemoryError。
unzip p21984589_1036_Generic.zip -d /u01/app/oracle/middleware/utils/bsu/cache_dir/ cd /u01/app/oracle/middleware/utils/bsu/ sed -i 's/512/1024/' bsu.sh ./bsu.sh -install -patch_download_dir=/u01/app/oracle/middleware/utils/bsu/cache_dir -patchlist=S8C2 -prod_dir=/u01/app/oracle/middleware/wlserver . /u01/app/oracle/middleware/wlserver/server/bin/setWLSEnv.sh /java/bin/java weblogic.version 补丁在重写的ServerChannelInputStream#resolveClass中新增了类名黑名单，加入了CC链比较关键的包。
梳理一下：
原生反序列化依然存在，流程中的各个关键方法可用。
CC链在黑名单以外的部分，仍然可以用作调用链。
黑名单类不在ServerChannelInputStream做反序列化就不受限制。
根据第三点先获取所有用到readObject的地方，用Serializable.class.isAssignableFrom(clazz)筛出可被序列化的类，筛出数据可控的二次反序列化。找到的两个可用类刚好对应两个CVE。
CVE-2016-0638 看到weblogic.jms.common.StreamMessageImpl#readExternal，完成父类readExternal后读到的字节是十进制1时会进入存在readObject的分支。
跟进中间会经过的createPayload方法，读到的整数大于CHUNK_LINK_THRESHOLD会做一些处理。中间这块的处理看不太懂，我们假设它不满足判断继续往后走，一直跟到Chunk.createOneSharedChunk。
虽然中间一些Chunk的判断和操作由于笔者太菜了看不懂，但到了这里就能看出，这个先前读到的被一路传过来的整数是后段数据长度。后面这段数据被完整读出并封装赋值给this.payload，随后进行第二次反序列化。
按照同样的数据顺序重写StreamMessageImpl的writeExternal，写入相应格式的CC链序列化payload，再经过一次正常新建类对象并经过第二次序列化，最后用上一篇的EXP打出去就行。
readExternal:1433, StreamMessageImpl (weblogic.jms.common) readExternalData:1814, ObjectInputStream (java.io) readOrdinaryObject:1773, ObjectInputStream (java.io) resolveClass:110, InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm) readNonProxyDesc:1589, ObjectInputStream (java.io) readClassDesc:1494, ObjectInputStream (java.io) readOrdinaryObject:1748, ObjectInputStream (java.io) readObject0:1327, ObjectInputStream (java.io) CVE-2016-3510 看到weblogic.corba.utils.MarshalledObject#readResolve，是比上一个品相更好的二次反序列化类。this.objBytes属性来自构造函数传入的对象，直接将payload对象作为参数给进去就行。
readResolve:58, MarshalledObject (weblogic.corba.utils) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:39, NativeMethodAccessorImpl (sun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1382c845a03734d628b4954d8f82eda1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1eabde0d0a2774972ae309740585c5c/" rel="bookmark">
			30&#43;后端程序员的2023年总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是阿七 2023 年的年度总结文，2023 年，阿七经历了认知和成果的爆变，希望能给各位读者朋友带来一点启发。
2023 年总结 1、认知：找到了有长期价值且愿意持续去做的事情 做自己的 IP，定位 AI 编程。做 IP 不能能开发出自己的副业收入，还有其他好处：
1、促进主业发展。如果你做的是和主业相关方向的 IP，大概率做 IP 不仅不会阻碍你的职业发展，还会促进主业进步。就说我自己，做 IP 两个月了，本来没有晋升机会的岗位，现在明显感觉领导在培养我，之后大概率能晋升！
2、培养思考复盘的能力。做 IP 一定会督促你不断输入、成长，因为没有输入、没有成长就没有持续的输出；同时，只有不断的成长，才有复盘。循环成长和复盘这个操作，你一定会越来越牛逼！
3、文字表达能力。不管是图文还是视频类，文字表达能力都是必须的。而写作是最重要的元能力之一。
4、突破舒适区。做 IP 就是在做一人企业，所有的产品、营销、财务都需要自己负责，只有突破自己的舒适区才能有成长。比如大部分都是在 IP 路上开始自己的直播之旅。
做 IP 值得！
2、写作：多平台突破、开花 知乎七级 知乎七级、阅读近 50W，经过两个月的输出，成功在 2024 年第一天，晋级知乎七级答主。
粉丝数也达到了 500+，成功开通致知计划，开始知乎写作变现之路！
掘金四级 2023 年度在掘金输出 56 篇原创文章，成功升级到掘金四级，很快五级，大部分文章都会被直接推送到首页。
同时也获得了超过 11W 的阅读。
公众号粉丝 1020 在微信公众号输出了 84 篇文章，其中 90% 以上都是原创。积累了 1020 粉丝。
3、副业：个人 IP 从 0 到 1 打死都要 + 系统化学习 + 有的放矢 + 大佬赋能 + 执行力，干啥都能成！践行这一句话，在 2023 年成功打造了自己个人 IP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1eabde0d0a2774972ae309740585c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf0ea049b6abac5e1c6ab6098521149/" rel="bookmark">
			给抽象的设计模式画个更抽象的图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e169fd48d3d95bd4ce48df1c009dfdcc/" rel="bookmark">
			【webstorm卡顿，占用内存过高解决办法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webstorm卡顿，占用内存过高通常是因为要给新打开的文件建立索引产生的
跟下图这样设置就可以了
编辑器-》文件类型-》忽略的文件和文件夹-》加上node_modules就可以了，这样就不会卡了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a77fa59cf07a5667a6e4e60b24d0281/" rel="bookmark">
			LeetCode 2487. 从链表中移除节点：单调栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】2487.从链表中移除节点：单调栈 力扣题目链接：https://leetcode.cn/problems/remove-nodes-from-linked-list/
给你一个链表的头节点 head 。
移除每个右侧有一个更大数值的节点。
返回修改后链表的头节点 head 。
示例 1：
输入：head = [5,2,13,3,8] 输出：[13,8] 解释：需要移除的节点是 5 ，2 和 3 。 - 节点 13 在节点 5 右侧。 - 节点 13 在节点 2 右侧。 - 节点 8 在节点 3 右侧。 示例 2：
输入：head = [1,1,1,1] 输出：[1,1,1,1] 解释：每个节点的值都是 1 ，所以没有需要移除的节点。 提示：
给定列表中的节点数目在范围 [1, 105] 内1 &lt;= Node.val &lt;= 105 方法一：单调栈 维护一个单调递减栈（严格地说是单调非递增栈）：
遍历链表，在当前节点大于栈顶节点时不断弹出栈顶节点，然后将当前节点入栈。
最终，从栈底到栈顶的元素就是非递增的了。因此也就得到了想要的链表。
时间复杂度 O ( l e n ( l i s t n o d e ) ) O(len(listnode)) O(len(listnode))空间复杂度 O ( l e n ( l i s t n o d e ) ) O(len(listnode)) O(len(listnode)) 然后被丢弃节点的delete操作就靠力扣了hh。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a77fa59cf07a5667a6e4e60b24d0281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f207d49fcb616acf212b3131d13ca4ec/" rel="bookmark">
			Mars3d的BusineDataLayer应该传data格式实现聚合效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
1.通过【Mars3d】加载new mars3d.layer.BusineDataLayer(的如果不用url使用data的话，格式应该是什么样子的呢？
相关说明：实质就是就是GraphicLayer，自己加graphic进去。
使用data的话要否需要用onCreateGraphic代替symbol吗实现添加矢量的效果？
回复：
相关data的格式使用.相关代码：
import * as mars3d from "mars3d"
export let map // mars3d.Map三维地图对象
export let graphicLayer // 矢量图层对象
// 需要覆盖config.json中地图属性参数（当前示例框架中自动处理合并）
export const mapOptions = {
scene: {
center: {"lat":32.632367,"lng":118.899899,"alt":4713595.4,"heading":348,"pitch":-69}
}
}
/**
* 初始化地图业务，生命周期钩子函数（必须）
* 框架在地图初始化完成后自动调用该函数
* @param {mars3d.Map} mapInstance 地图对象
* @returns {void} 无
*/
export function onMounted(mapInstance) {
map = mapInstance // 记录map
addBusinessLayer()
}
let historyFiresRes = {
"msg": "success",
"code": 0,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f207d49fcb616acf212b3131d13ca4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46f2372e9f9fd84b187b93989a7d0af4/" rel="bookmark">
			云计算：OpenStack 分布式架构管理VXLAN网络（单控制节点与多计算节点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验
1.环境
2.各节点新增网卡准备VXLAN网络
3.控制节点配置私有网络
4.计算节点1配置私有网络
5.计算节点2配置私有网络
6.重启服务
7.修改Dashboard
8.新建项目（租户）及用户
9.新建网络与子网
10.新建实例
11.新建路由
12.新增浮动IP关联云主机实例
二、问题
1.私有网络主要组件相互关系
2.VXLAN底层如何实现
一、实验 1.环境 (1) 主机
表1 主机
主机架构IP备注controller控制节点192.168.204.210已部署compute01计算节点1192.168.204.211 已部署compute02计算节点2192.168.204.212已部署storage01存储节点1192.168.204.221已部署storage02存储节点2192.168.204.222已部署nasnfs节点192.168.204.229已部署 （2）官网
OpenStack Docs: OpenStack Installation Guide for Red Hat Enterprise Linux and CentOS
2.各节点新增网卡准备VXLAN网络 （1）控制节点修改eth1网卡
（2）计算节点1修改eth1网卡
（3）计算节点2修改eth1网卡
（4）控制节点新增网络 ping 计算节点新增网络
3.控制节点配置私有网络 （1）编辑/etc/neutron/neutron.conf 文件
① 在[DEFAULT]部分，启用Modular Layer 2 (ML2)插件，路由服务和重叠的IP地址
[DEFAULT] ... service_plugins = router allow_overlapping_ips = True ②备份修改
（2）配置 Modular Layer 2 (ML2) 插件，编辑/etc/neutron/plugins/ml2/ml2_conf.ini文件
① 在[ml2]部分，启用flat，VLAN以及VXLAN网络：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46f2372e9f9fd84b187b93989a7d0af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fb761e408d5419461423bbb45872e0/" rel="bookmark">
			【鸿蒙千帆起】《开心消消乐》完成鸿蒙原生应用开发，创新多端联动用户体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《开心消消乐》已经完成鸿蒙原生应用开发，乐元素成为率先完成鸿蒙原生应用开发的 20+游戏厂商之一。作为一款经典游戏，《开心消消乐》已经拥有 8 亿玩家，加入鸿蒙原生应用生态，将为其带来更优的游戏性能和更多创新体验。自 9 月 25 日华为宣布全新 HarmonyOS NEXT 蓄势待发、鸿蒙原生应用全面启动以来，以游戏为代表的 18 个行业，成为加入鸿蒙生态的先行军，呈现出“鸿蒙千帆起”的景象。
早在 2014 年《开心消消乐》上线之初就接入了华为游戏中心，如今，双方合作已经走过近十个年头。依托长久以来的坚实合作基础、华为游戏中心面向开发者的全周期服务能力，以及华为领先的技术和鸿蒙生态，《开心消消乐》坚定了开发鸿蒙原生应用的信心，走在了鸿蒙生态游戏先锋合作的前列。基于 HarmonyOS 特性，《开心消消乐》可以更好实现游戏体验的优化，比如，通过 HarmonyOS 元服务的应用，可以加强游戏与玩家之间交互的提醒，用户不需要频繁打开游戏就能接收到游戏中的关键信息，比如精力恢复、新关卡开放、活动信息提醒等，给玩家提供了更加便捷的游戏体验。
同时，HarmonyOS 特有的分布式软总线技术还为用户打造出创新的分布式游戏玩法。通过与 HarmonyOS 分布式有机结合，可实现多设备协同的分布式 PK 场景。在此场景下，用户操作各自的 HarmonyOS 设备，使用智慧屏实时显示对战场景，双方就可以通过大屏及时观察对手棋盘的状况，消除自己棋盘的同时，给对方的棋盘消除制造一些障碍，大大提升了游戏的互动性与趣味性！
在当今的全场景时代下， HarmonyOS 不仅仅可以帮助伙伴打造更优质的用户体验，基于强大的 AI 能力还可以实现精准识别、精确投放，为伙伴提供新流量，并共享全场景服务分发，助力生态共赢。数据显示，截至今年 8 月份，鸿蒙生态的设备数已超过 7 亿，鸿蒙生态开发者已超过 220 万。（数据来源于内部统计）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91924bff00d8849c57fe34ec4ad31887/" rel="bookmark">
			springboot&#43;mysql校园招聘系统小程序-计算机毕业设计源码09446
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着智能手机的普及和4G网络的发展，以O20为代表的互联网+服务模式从衣食住行等方方面面改变着我们的生活方式。基于小程序的校园招聘系统主要功能模块包括用户管理，招聘资讯、招聘职位、简历投递、面试邀请等，采取面对对象的开发模式进行软件的开发和硬体的架设，能很好的满足实际使用的需求，完善了对应的软体架设以及程序编码的工作，采取MySQL作为后台数据的主要存储单元，采用Spring boot框架、JSP技术、Ajax技术进行业务系统的编码及其开发，实现了本系统的全部功能。本次报告，首先分析了研究的背景、作用、意义，为研究工作的合理性打下了基础。针对基于小程序的校园招聘系统的各项需求以及技术问题进行分析，证明了系统的必要性和技术可行性，然后对设计系统需要使用的技术软件以及设计思想做了基本的介绍，最后来实现基于小程序的校园招聘系统的部署与运行。
关键词：校园招聘系统；Springboot框架；MySQL数据库
Design and Implementation of Campus Recruitment System Based on Small Programs in Springboot
Abstract
With the popularization of smart phones and the development of 4G networks, the Internet plus service model represented by O20 has changed our lifestyle in terms of food, clothing, housing and transportation. The main functional modules of the campus recruitment system based on small programs include user management, recruitment information, recruitment positions, resume delivery, interview invitation, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91924bff00d8849c57fe34ec4ad31887/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c76d501d790a561744a39e50d8ab09/" rel="bookmark">
			科普vcruntime140.dll文件，解决vcruntime140.dll丢失的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用电脑的过程中是否遇到过关于vcruntime140.dll文件丢失的问题，遇到这样的问题时你是怎么解决的，如果你有别的方法我们可以一起讨论一下，接下来就和大家说说小编知道解决vcruntime140.dll丢失的方法，同时也给大家科普关于vcruntime140.dll文件的问题。
一.什么是vcruntime140.dll文件 在讨论解决vcruntime140.dll文件找不到的问题之前，让我们先了解一下这个文件的背景。vcruntime140.dll是Microsoft Visual C++ Redistributable for Visual Studio 2015的一部分，它是运行在Windows操作系统上的动态链接库文件。这个文件负责提供运行应用程序所需的一些功能和资源。当系统中缺少或损坏vcruntime140.dll文件时，可能导致一些应用程序无法正常启动或运行。在本文中，我们将详细讨论解决vcruntime140.dll文件找不到的问题的方法。
二.vcruntime140.dll缺失的问题所在 当在启动或运行某个应用程序时出现vcruntime140.dll文件找不到的错误提示时，首先应该排除一些基本问题。以下是一些方法帮助您定位问题所在：
1. 重新启动计算机：有时，简单地重新启动计算机可以解决临时的文件缺失或错误。
2. 更新操作系统：确保您的操作系统是最新的版本，因为某些应用程序可能需要特定版本的操作系统才能正常运行。
3. 检查软件完整性：使用系统自带的sfc /scannow命令检查系统文件的完整性，以确保没有任何文件损坏。
4. 检查其他错误信息：尝试查看其他错误信息，可能会给出有关问题的更多线索。在特定应用程序的错误日志、事件查看器或Windows日志中搜索相关错误。
三.解决vcruntime140.dll文件找不到的解决方法 第一种方法：重新安装相关软件 如果您排除了上述基本问题，并确定问题与vcruntime140.dll文件相关，那么您可以尝试重新安装相关软件以解决问题。
1. 卸载Visual C++ Redistributable：首先，在控制面板的程序和功能中找到并卸载已安装的Microsoft Visual C++ Redistributable程序。
2. 下载最新版本的Visual C++ Redistributable：在Microsoft官方网站上下载最新版的Visual C++ Redistributable。确保下载与您的操作系统兼容的版本。
3. 安装Visual C++ Redistributable：运行下载好的安装程序，并按照向导的指示完成安装过程。重启计算机以使更改生效。
4. 更新应用程序：在重新安装了Visual C++ Redistributable后，尝试更新或重新安装与vcruntime140.dll有关的应用程序。这将确保应用程序使用最新的vcruntime140.dll文件。
第二种方法：使用dll修复工具 在浏览器顶部输入：dll修复.site ，点击回车键，进入获取dll修复工具，利用这个dll修复工具直接进行一键修复就可以了，它会根据你电脑系统缺失了哪些dll文件，然后进行相关的修复，如你丢失了vcruntime140.dll就会帮你修复vcruntime140.dll文件，操作比较简单方便。DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法-电脑修复精灵
第三种方法：修复系统文件 如果重新安装相关软件仍然无法解决问题，您可以尝试修复系统文件以确保vcruntime140.dll文件的正常运行。
1. 打开命令提示符：以管理员身份打开命令提示符。
2. 运行DISM命令：在命令提示符中输入以下命令，然后按Enter键运行：
```
DISM /Online /Cleanup-Image /RestoreHealth
```
3. 等待进程完成：此命令可能需要一些时间来完成。请耐心等待，直到进程完成。
4. 运行系统文件检查：在命令提示符中输入以下命令，然后按Enter键运行：
```
sfc /scannow
```
5. 等待修复过程完成：这个命令将扫描和修复系统文件中的任何错误。等待命***，并注意检查任何报告的错误或修复信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c76d501d790a561744a39e50d8ab09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea755eaf39cf508da9ba8a6780b3e999/" rel="bookmark">
			linux shell函数：basename函数 | dirname函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 摘要# 介绍几个shell常用的函数，当然在linux命令行也能直接使用basename函数dirname函数 一、文件名类型函数# basename# 功能：返回完整路径最后/的部分，常用于获取文件名语法：basename [pathname] [suffix]功能描述:basename命令会删掉所有的前缀包括最后一个’/'字符，然后将字符串显示出来。选项：suffix为后缀，如果suffix被指定了, basename会将pathname或string中的suffix去掉。 basename /home/crispycandy/testRead.sh basename /home/crispycandy/testRead.sh .sh dirname# 与basename相反，返回的是目录名 dirname /home/crispycandy/testRead.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e839a2f023343f65c2e5c64b6c0fc238/" rel="bookmark">
			【数据仓库与联机分析处理】数据仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据仓库的概念
二、数据仓库与操作性数据库的区别
三、发展前期
四、数据仓库的系统结构
五、建模划分
六、主要案例 一、数据仓库的概念 目前很难给数据仓库（Data Warehouse）一个严格的定义，不准确地说，数据仓库也是一种数据库，它与操作性数据库进行分开维护。按照数据仓库系统构造方面的领头设计师William H.Inmon的说法，数据仓库是一个面向主题的（Subject Oriented）、集成的（Integrated）、相对稳定的（Non-Volatile）以及反映历史变化（Time Variant）的数据集合，用于支持管理决策。
1、面向主题是指数据仓库会围绕一些主题来组织和构建，如顾客、供应商、产品等，数据仓库关注决策者的数据建模与分析，而不是企业的日常操作和事务处理，因此，数据仓库排除对决策支持过程无用的数据，提供面向特定主题的视图。
2、集成是指通常构建数据仓库会将多个异构的数据源，如关系数据库、一般的文件和事务处理记录等集成在一起，这就需要使用数据清理和数据集成技术，来确保命名约定、编码结构和属性度量等的一致性。
3、相对稳定是指数据仓库大多会分开存放数据，数据仓库不需要进行事务处理、数据恢复和并发控制等机制，通常数据仓库只需要两种数据访问操作：数据的初始化装入和数据的访问。
4、反映历史变化是指数据仓库是从历史的角度提供信息，换句话说，数据仓库中的关键结构都会显式或者隐式地包含时间元素。
二、数据仓库与操作性数据库的区别 为了进一步加深对数据仓库概念的理解，我们把数据库系统和数据仓库进行对比。为了区分，这里把数据库系统称为操作性数据库。操作性数据库的主要任务是执行联机事务和查询处理，这种系统称为联机事务处理（Online Transaction Processing，OLTP）系统，它涵盖了企业组织机构大部分的日常操作，如购物、注册、记账等。 数据仓库系统则是在数据分析和决策方面为用户和决策者提供服务，以特定的主题和格式来组织和提供数据，从而满足不同用户的需求，因此这种系统称为联机分析处理（Online Analytical Processing，OLAP）系统。
OLTP和OLAP的主要区别体现在如下几个方面：
1、系统面向的用户对象不同。OLTP系统面向一般的客户，用于数据库用户的事务处理和查询，而OLAP系统则是面向知识工人或者管理决策人员，提供数据分析功能。
2、数据的内容不同。OLTP管理的是当前的数据，对于数据的操作相对较为细小琐碎，无法用于决策。OLAP则管理了大量的历史数据，如一个销售公司一个月、一年甚至数年的销售数据。OLAP提供了汇总和聚集机制，并且可以在不同的粒度级别、不同的维度视角来存储和管理数据，这些优势使得数据可以用于分析和决策任务。
3、采用的模型和设计不同。通常OLTP系统采用的实体—联系（E-R）模型和面向应用的数据库设计，而OLAP采用的是面向某个主题的星形模式、雪花模式或事实星座模式的数据库设计。
4、访问模式不同。OLTP系统的访问模式主要由短的原子事务所组成，既有读操作也有写操作，这种系统需要考虑事务管理、并发控制和故障恢复等机制。而OLAP的访问模式在完成数据的初始装载以后，基本都是只读操作。
5、数据的视图不同。OLTP主要关注当前生产环境的数据，不太涉及历史数据。而OLAP系统通常要跨越数据库的多个版本，处理来自不同组织的数据信息。由于数据量巨大，OLAP的数据通常会存放在多个存储介质上。
操作性数据库与数据仓库的其他区别，如数据量的大小、操作的频度和性能等，如下表所示：
三、发展前期 计算机发展的早期，人们已经提出了建立数据仓库的构想。“数据仓库”一词最早是在1990年，由Bill Inmon先生提出的，其描述如下：数据仓库是为支持企业决策而特别设计和建立的数据集合。
企业建立数据仓库是为了填补现有数据存储形式已经不能满足信息分析的需要。数据仓库理论中的一个核心理念就是：事务型数据和决策支持型数据的处理性能不同。企业在它们的事务操作收集数据。在企业运作过程中：随着定货、销售记录的进行，这些事务型数据也连续的产生。为了引入数据，我们必须优化事务型数据库。
处理决策支持型数据时，一些问题经常会被提出：哪类客户会购买哪类产品？促销后销售额会变化多少？价格变化后或者商店地址变化后销售额又会变化多少呢？在某一段时间内，相对其他产品来说哪类产品特别容易卖呢？哪些客户增加了他们的购买额？哪些客户又削减了他们的购买额呢？
事务型数据库可以为这些问题作出解答，但是它所给出的答案往往并不能让人十分满意。在运用有限的计算机资源时常常存在着竞争。在增加新信息的时候我们需要事务型数据库是空闲的。而在解答一系列具体的有关信息分析的问题的时候，系统处理新数据的有效性又会被大大降低。另一个问题就在于事务型数据总是在动态的变化之中的。决策支持型处理需要相对稳定的数据，从而问题都能得到一致连续的解答。
数据仓库的解决方法包括：将决策支持型数据处理从事务型数据处理中分离出来。数据按照一定的周期（通常在每晚或者每周末），从事务型数据库中导入决策支持型数据库——既“数据仓库”。数据仓库是按回答企业某方面的问题来分“主题”组织数据的，这是最有效的数据组织方式。
四、数据仓库的系统结构 1、数据源
是数据仓库的数据来源，含外部数据、现有业务系统和文档资料等；对这些数据首先完成数据集成，包括数据的抽取、清洗、转换和加载任务。数据源中的数据采用ETL（Extract-Transform-Load，数据抽取、转换、装载）工具并以固定的周期加载到数据仓库中。
2、数据存储和管理
此层次主要涉及对数据的存储和管理，含数据仓库、数据仓库检测、运行与维护工具和元数据管理等。
3、数据服务
为前端和应用提供数据服务，可直接从数据仓库中获取数据供前端应用使用，也可通过OLAP服务器为前端应用提供负责的数据服务。
4、数据应用
此层次直接面向用户，含数据查询工具、自由报表工具、数据分析工具、数据挖掘工具和各类应用系统。
随着应用需求的发展变化，传统的数据仓库也存在如下几个亟待解决的问题：
（1）无法满足快速增长的数据存储需求，传统数据仓库基于关系型数据库，横向扩展较差，纵向扩展有限。
（2）无法处理不同类型的数据，传统数据仓库只能处理和存储结构化数据。随着应用需求的发展，数据的格式越来越丰富，半结构化、非结构化数据所占比重越来越大，处理需求越来越迫切。
（3）传统数据仓库建立在关系型数据仓库之上，计算和处理能力不足，当数据量达到TB级后性能难以得到保证。
五、建模划分 数据仓库的数据建模大致分为四个阶段：
1、业务建模，这部分建模工作，主要包含以下几个部分：
（1）划分整个单位的业务，一般按照业务部门的划分，进行各个部分之间业务工作的界定，理清各业务部门之间的关系。
（2）深入了解各个业务部门内的具体业务流程并将其程序化。
（3）提出修改和改进业务部门工作流程的方法并程序化。
（4）数据建模的范围界定，整个数据仓库项目的目标和阶段划分。
2、领域概念建模，这部分得建模工作，主要包含以下几个部分：
（1）抽取关键业务概念，并将之抽象化。
（2）将业务概念分组，按照业务主线聚合类似的分组概念。
（3）细化分组概念，理清分组概念内的业务流程并抽象化。
（4）理清分组概念之间的关联，形成完整的领域概念模型。
3、逻辑建模，这部分的建模工作，主要包含以下几个部分：
（1）业务概念实体化，并考虑其具体的属性。
（2）事件实体化，并考虑其属性内容。
（3）说明实体化，并考虑其属性内容。
4、物理建模，这部分得建模工作，主要包含以下几个部分：
（1）针对特定物理化平台，做出相应的技术调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e839a2f023343f65c2e5c64b6c0fc238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246ce4df01f60fced05b7e2f9b6cb583/" rel="bookmark">
			vue3 组件之间传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3 组件之间传值 非常好，为啥突然开这样一篇博文，首先是因为 vue3 是未来发展的趋势。其次，vue 官方已经确认，将于2023年最后一天停止对 vue2 项目的维护，这个是官方发出的通知，并且呢，尤雨溪团队也已经将 vue3 作为了 vue 的默认版本了，同时呢，无论是 elementUI 和 ant-d 组件库团队，也已经很早之前就发布了针对于 vue3 的组件库。接下来，我们要真正的开始内卷 vue3 了家人们！
前言 vue2.7 是现在，也是最后一个 vue2 版本的更新，官方已经发布通告，vue2 版本将于 2023年12月31日 停止维护，但是停止维护不代表不能使用哈，我们可以继续使用 vue2 版本开发我们的项目，只不过，官方团队已经不会在对 vue2 版本进行更新，这个更新包括了安全性和兼容性的更新修复问题。如果我们继续使用 vue2 版本开发项目的话，我们可能就需要面对一个问题，就是如何向用户解释：你买了我们的电脑，但我们给你配的是 window xp 系统。
使用过 vue2 的兄弟们，在开发项目里面最常用的东西是啥子嘞？首先组件通信排第一吧！牛的嘞，这一节，就说一下 vue3 的组件通信方式哈。
好的，首先要注意一点，学习这一部分的话需要用到一些其他的知识点：第一个是 vue3 的基础语法，可以看我之前的博文；再一个就是 TypeScript，当然也可以看我之前的博文。都没有问题了，下面的东西就很简单了。
props 传值 在 vue2 里面可以使用 props 传值，在 vue3 里面依旧可以使用，但是改了个名字，叫 defineProps 获取父组件传递的数据，且在组件内部不需要引入 defineProps 方法就可以直接使用。
下面案例稍微讲一下哈，首先我们创建一个 vue3 的项目，我们编写两个组件：
编写父组件 首先编写一个父组件
&lt;!-- 模板语法 --&gt; &lt;template&gt; &lt;p class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/246ce4df01f60fced05b7e2f9b6cb583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59da44d7f317b60f66c030dbc94db289/" rel="bookmark">
			使用GO开发的IDE简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、IDE介绍
Goland
Goland是由JetBrains公司开发的商业IDE，专门为Go语言开发设计。JetBrains是一家知名的软件开发公司，以其强大的IDE产品如IntelliJ IDEA而闻名。
优点： 基于IntelliJ平台，因此拥有与IntelliJ IDEA相似的强大功能和智能代码补全。提供了强大的代码分析和重构工具。集成了Go插件，提供了对Go语言的特定支持，如代码导航、调试和性能分析。 缺点：作为商业产品，Goland需要付费购买才能完全享受所有功能。 LiteIDE
LiteIDE是一款轻量级的、专门为Go语言开发设计的IDE。它是由一位中国开发者为了更好的Go语言开发体验而创建的。
优点： 轻量级，不占用大量系统资源。支持跨平台，可以在Windows、macOS和Linux上运行。提供了基本的代码编辑、编译和运行功能。 缺点：相对于其他更成熟的IDE，LiteIDE的功能可能较为基础，对于大型项目可能不够用。 Sublime Text
Sublime Text是一款流行的文本编辑器，由于其高效的用户界面和强大的插件系统而受到赞誉。通过安装GoSublime等插件，Sublime Text也可以用于Go语言开发。
优点： 高度可定制的用户界面和快捷键配置。丰富的插件生态系统，可以扩展其功能。快速、轻量级的编辑体验。 缺点：相对于专门的IDE，Sublime Text可能缺乏一些针对Go语言的特定功能和工具。 GoClipse
GoClipse是一款基于Eclipse IDE的插件，为Eclipse IDE提供了对Go语言的支持。它充分利用了Eclipse的强大功能和插件生态系统。
优点： 利用了Eclipse的成熟架构和功能。与其他Eclipse插件可以无缝集成。 缺点：需要先安装Eclipse IDE，并可能需要对Eclipse进行一些配置才能获得最佳的Go开发体验。 二、使用Go开发的IDE的优势
并发支持：由于Go语言的并发特性，使用Go开发的IDE通常会提供对并发编程的强大支持。这包括对goroutines、channels以及其他并发结构的智能提示和帮助。这种支持可以帮助开发者更有效地编写并发代码，减少错误并提高性能。标准库和生态系统：Go拥有一个庞大而强大的标准库，涵盖了许多常见的编程任务。此外，Go的生态系统也相当丰富，有大量的第三方库可供选择和使用。因此，使用Go开发的IDE通常会与这些库紧密集成，提供更好的支持和工具。性能和效率：Go是一种编译型语言，具有很高的执行效率。使用Go开发的IDE通常会利用这一点，提供快速的编译和调试工具，帮助开发者更快地构建和测试应用程序。此外，由于Go语言的简洁性和高效性，使用Go开发的IDE也注重提高开发效率，减少不必要的复杂性。社区支持：由于Go语言的流行度和强大的社区支持，使用Go开发的IDE通常可以获得大量的用户反馈和支持。这意味着开发者可以轻松找到解决问题的方法和资源，从而更快地解决问题和改进开发工具。跨平台兼容性：大多数现代的Go开发的IDE都支持Windows、macOS和Linux等多个操作系统平台。这意味着开发者可以在自己喜欢的操作系统上使用相同的工具进行开发和调试，从而提高工作效率和一致性。安全性：使用Go开发的IDE通常注重安全性问题。由于Go语言的静态类型特性和内存安全模型，使用Go开发的IDE可以提供更好的代码检查和安全提示功能，帮助开发者避免潜在的安全漏洞和问题。这使得在开发过程中更易于检测和处理安全性问题，从而提高应用程序的安全性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f7f6df6d0b2068d8f4c091e6863be0/" rel="bookmark">
			工业物联网上篇——什么是IIOT？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业物联网背后的理念是使用工业设施中“哑巴设备”多年来产生的数据。装配线上的智能机器不仅可以更快地捕获和分析数据，且在交流重要信息方面也更快，这有助于更快、更准确地做出业务决策。
信息技术（IT）和运营技术（OT）的集成推动了工业物联网的发展。它是连接设备和设备的网络矩阵，通过传感器技术收集数据、分析数据，并将其直接集成到作为服务的平台中。工业物联网将预示着工业用例的新时代，有许多经济扩张的机会。
什么是IIOT?
IIoT是指工业物联网，把物联网技术延伸到工业领域，将具有感知、管控能力的各类采集、控制传感器或控制器，通过物联感知和通信技术融入到工业生产过程各个环节，实现将传统工业提升到智能化的阶段。工业物联网主要应用在制造、交通、运输、能源、矿山等行业领域，目的是优化生产过程、提高生产效率、降低制造成本。
从应用形式上，工业物联网的应用具有实时性、自动化、嵌入式（软件）、安全性、和信息互通互联性等特点。
工业物联网与物联网的区别？
工业物联网（IIoT）是物联网（IoT）的变体，旨在处理工业的需求。两者之间的唯一区别是物联网主要用于消费者使用，而工业物联网主要用于工业目的，如制造和大型管理系统。
物联网是把所有物品通过信息传感设备与互联网连接起来，进行信息交换，以实现智能化识别和管理。
工业物联网是通过互联网连接到工业应用的传感器和仪器设备，该网络收集工业应用数据，并对数据进行分析，目的是优化生产过程、提高生产效率并降低制造成本。工业物联网涵盖了机器对机器（M2M）和自动化应用的工业通信技术领域。
工业物联网是物联网的子集，出发点是实现工业制造领域的转型升级，侧重于提高生产现场的安全性和效率。
工业物联网与其他类型的物联网有何不同？
虽然工业物联网与其他类型的物联网有相似之处，例如消费者物联网（CIoT）和智能家居设备，但也有一些关键区别使其与众不同：
规模和复杂性：与其他类型的物联网相比，工业物联网涉及更大的规模和复杂性。工业流程通常需要复杂且互连的系统，其中包含众多设备、传感器和机器。这些系统需要处理大量数据，具有高可靠性和正常运行时间，并在恶劣的环境中运行，因此与其他类型的物联网相比，IIoT更加复杂且实施起来更具挑战性。
专注于工业应用：IIoT主要专注于工业应用，例如制造、物流、能源和农业，而其他类型的物联网更以消费者为中心。IIoT旨在优化流程、提高运营效率并提高行业生产力，而其他类IoT常侧重于增强消费者体验和便利性。
互操作性和标准化：IIoT需要工业环境中使用的各种设备、机器和系统之间的互操作性和标准化。这对于确保IIoT生态系统的不同组件之间的无缝通信和数据交换至关重要。相比之下，其他类型的物联网可能没有相同级别的标准化和互操作性要求。
安全和隐私：由于工业流程的关键性和安全漏洞的潜在影响，IIoT更加重视安全和隐私。工业系统通常受制于严格的法规和标准，IIoT解决方案需要满足这些要求以确保数据完整性、机密性和可用性。
工业物联网的特征
1. 大规模连接
工业物联网可以实现大规模设备的连接，将各种传感器、设备和系统进行互联互通，实现设备之间的数据交换和共享。
2. 实时数据传输与分析
工业物联网可以实现设备数据的实时传输和分析，将设备产生的数据通过网络传输到云端，并进行实时的数据分析和处理，帮助企业及时了解设备状态和生产情况。
3. 自动化控制
工业物联网可以实现设备的自动化控制，通过对设备的远程监控和控制，实现生产过程的自动化和智能化，提高生产效率和产品质量。
4. 数据安全与隐私保护
工业物联网对于数据的安全和隐私保护非常重要，通过采用安全的通信协议和加密技术，保护设备数据的传输和存储安全，防止数据泄露和攻击。
5. 灵活可扩展
工业物联网具有灵活可扩展的特点，可以根据企业的需求进行定制化开发，支持不同类型的设备和系统的接入，满足企业不同的应用需求。
典型工业物联网架构
工业物联网架构组件
（1）现场感知物联网设备　位于尽可能靠近数据源的位置。这些通常是工业环境中的无线执行器和传感器。一个小型处理单元和一个观测端点集合。感知物联网设备可能包括工业环境中的传统设备、摄像头、传感器以及其他仪器仪表和监视器。　物联网关 在这里，传感器数据被收集并转换为数字通道，以便在物联网关进行进一步处理。在获得聚合和数字化的数据后，网关将其通过互联网传输，以便在上传到云端之前可以对其进行进一步处理。网关仍然是边缘数据收集系统的一部分。它们与执行器和传感器相邻，并在边缘执行初步数据处理。 （3）工业物联网平台　工业物联网系统现在能够协调、监控和控制整个价值链的操作。这些平台控制设备数据，并管理边缘设备的分析、数据可视化和人工智能(AI)任务。
常见问题
1、IIOT的发展趋势是什么？
IOT的发展趋势是向着更加终端智能化、联接泛在化、云端化等方向发展，同时注重数据的安全性和隐私保护，这将为工业领域的进一步创新和效率提升提供强有力的支持。
2、工业物联网的应用范围有哪些？
工业物联网的应用范围非常广泛，包括制造业、能源领域、交通运输、农业等。
3、工业物联网如何保证数据的安全性？
工业物联网采用安全的通信协议和加密技术，对设备数据进行加密传输和存储，保证数据的安全性。
4. 工业物联网的挑战有哪些？
工业物联网的挑战包括数据安全和隐私保护、设备兼容性、标准化等方面的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd164307ac810d59bcaf46aa84ca144/" rel="bookmark">
			HTTPS网站安全证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的迅猛发展，网络安全问题日益凸显，而HTTPS网站安全证书作为一项关键技术，正成为保护用户隐私和数据安全的不可或缺的手段之一。本文将介绍HTTPS网站安全证书的定义、作用、种类及部署过程，以帮助读者更好地理解和应用这一重要的网络安全技术。
1. 什么是HTTPS网站安全证书？
HTTPS（HyperText Transfer Protocol Secure）是一种通过安全套接层（SSL）或传输层安全性（TLS）协议来保护网络数据传输安全的协议。而HTTPS网站安全证书则是用来验证网站身份，并加密数据传输的数字证书。它通过在网站和用户之间建立加密连接，确保数据在传输过程中不被恶意攻击者窃取或篡改。
2. HTTPS网站安全证书的作用
2.1 数据加密
HTTPS网站安全证书通过SSL/TLS协议对数据进行加密，使得在传输过程中的数据难以被截取和解密，提高了用户数据的安全性。
2.2 身份验证
证书颁发机构（CA）颁发的证书用于验证网站的身份，确保用户连接的是合法的、真实的网站，防范了中间人攻击和伪造网站的风险。
2.3 增信用户信任
通过使用HTTPS，网站地址栏会显示安全锁定图标，向用户传递了一个安全可信任的信号，提升了用户对网站的信任度。
永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL真正完全且永久免费！不用您花一分钱，SSL证书免费使用90天，并且还支持连续签发。JoySSL携手全球权威可信顶级根，自研新一代SSL证书，全系列支持90天免费使用。在这里，你可以申请到免费单域名证书、免费多域名证书以及免费通配符证书。部署于国内的验签服务器3-5分钟极速签发，而且只需要简单的域名解析验证，即可让您的网站开启https安全协议。https://www.joyssl.com/certificate/select/free.html?nid=7
3. HTTPS网站安全证书的种类
3.1 DV（Domain Validation）证书
验证域名是否合法，是最基本的证书类型，适用于个人网站和小型企业。
3.2 OV（Organization Validation）证书
在DV证书的基础上，增加了对申请者组织身份的验证，适用于中小型企业和电商网站。
3.3 EV（Extended Validation）证书
提供最高级别的身份验证，通过更严格的验证程序，适用于大型企业和金融机构。
4. 部署HTTPS网站安全证书的步骤
4.1 选择合适的证书类型
根据网站规模和用途选择DV、OV、或EV证书。
4.2 选择可信任的证书颁发机构
选择被浏览器广泛信任的CA，确保证书的可靠性和兼容性。
4.3 申请证书并完成验证
按照CA的要求提交证书申请，完成域名或组织的验证流程。
4.4 安装证书
根据CA提供的指南，在服务器上安装配置证书，确保网站能够启用HTTPS。
4.5 更新证书
定期更新证书，确保网站持续享有安全保障。
永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL真正完全且永久免费！不用您花一分钱，SSL证书免费使用90天，并且还支持连续签发。JoySSL携手全球权威可信顶级根，自研新一代SSL证书，全系列支持90天免费使用。在这里，你可以申请到免费单域名证书、免费多域名证书以及免费通配符证书。部署于国内的验签服务器3-5分钟极速签发，而且只需要简单的域名解析验证，即可让您的网站开启https安全协议。https://www.joyssl.com/certificate/select/free.html?nid=7
结论
HTTPS网站安全证书作为网络安全的基石，为用户提供了安全、可信的在线环境。通过采取适当的证书类型和遵循正确的部署流程，网站管理员可以有效地提升网站的安全性，为用户提供更可靠的服务。在网络安全问题日益凸显的今天，HTTPS网站安全证书的重要性愈发显著，我们应当共同努力，推动网络安全的发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a41956823edaadccbb8c998a1218a3b6/" rel="bookmark">
			【Proteus仿真】【Arduino单片机】数控稳压可调电源设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用Proteus8仿真Arduino单片机控制器，使用动态数码管、按键、PCF8591 AD/DAC、LM358放大电路模块等。
主要功能：
系统运行后，系统默认输出直流5V，数码管显示输出电压值。可通过按键K1和K2调节电源输出值，步进为0.1V；按下K3键可直接输出5V。系统最大输出0-10V。
二、软件设计 /* 作者：嗨小易（QQ群：570487280） */ //系统数据设定 void sys_data_set(void) { u8 key=0; key=key_scan(0); //加 if(key==KEY1_PRESS) { sys_ctrl.vol+=2;//0.1V步进 if(sys_ctrl.vol&gt;200)sys_ctrl.vol=200;	} //减 else if(key==KEY2_PRESS) { if(sys_ctrl.vol&gt;=2) sys_ctrl.vol-=2;//0.1V步进	} //5V输出 else if(key==KEY3_PRESS) { sys_ctrl.vol=100;	} //DAC输出 pcf8591_set_dac_out(sys_ctrl.vol); } //系统数据显示 void sys_data_show(void) { u8 buf[4]; u8 temp=sys_ctrl.vol/2; while(1) { //数码管显示输出电压 buf[0]=gsmg_code[temp/100]; buf[1]=gsmg_code[temp%100/10]|0x80; buf[2]=gsmg_code[temp%100%10]; buf[3]=0X3E;//U smg_display(buf,1); break;	} } //应用控制系统 void appdemo_show(void) { sys_parm_init();//系统参数初始化 while(1) { sys_data_set();//系统数据设定 sys_data_show();//系统数据显示	} } 三、实验现象 B站演示视频：https://space.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a41956823edaadccbb8c998a1218a3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa135ae374e7fec399f4230de1dfd76c/" rel="bookmark">
			ansible 配置jspgou商城上线（MySQL版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备环境
准备两台纯净的服务器进行，在实验之前我们关闭防火墙和selinux
systemctl stop firewalld #关闭防火墙 setenforce 0 #临时关闭selinux hosts解析(两台服务器都要去做)
[root@ansible-server ~]# vim /etc/hosts 10.31.162.24 ansible-server 10.31.162.25 ansible-web 安装ansible
10.31.162.24 安装：控制节点 1. 配置EPEL网络yum源 [root@ansible-server ~]# yum install -y epel* 2. 安装ansible [root@ansible-server ~]# yum install -y ansible 3.查看版本 [root@ansiable-server ~]# ansible --version 4.查看配置文件： [root@ansible-server ~]# rpm -qc ansible ---1.主配置文件：/etc/ansible/ansible.cfg #主要设置一些ansible初始化的信息，比如日志存放路径、模块、插件等配置信息 ---2.主机清单文件:默认位置/etc/ansible/hosts 安装nginx
# 配置nginx源 [root@ansible-server ~]# vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true # 下载nginx [root@ansible-server ~]# yum install -y nginx [root@ansible-server ~]# systemctl start nginx [root@ansible-server ~]# systemctl enable nginx 上传压缩包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa135ae374e7fec399f4230de1dfd76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ea740981dc16e57f46e20a0ea94f9d/" rel="bookmark">
			（附源码）SSM酒店预约管理系统 毕业设计40970
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1 绪论 1.1选题的依据及意义 1.2国内外研究现状及发展趋势 1.3Vue.js 主要功能 1.4ssm框架介绍 2
1.5论文结构与章节安排 3
2 酒店预约管理系统分析 4
2.1 可行性分析 4
2.2 系统流程分析 4
2.2.1数据增加流程 5
2.3.2数据修改流程 5
2.3.3数据删除流程 5
2.3 系统功能分析 5
2.3.1 功能性分析 6
2.3.2 非功能性分析 6
2.4 系统用例分析 7
2.5本章小结 3 酒店预约管理系统总体设计 3.1 系统架构设计 3.2 系统功能模块设计 3.2.1整体功能模块设计 3.2.2用户模块设计 3.2.3评论管理模块设计 3.3 数据库设计 3.3.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 4 酒店预约管理系统详细设计与实现 20
4.1用户功能模块 20
4.1.1 前台首页界面 20
4.1.2 用户登录界面 20
4.1.3用户注册界面 23
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ea740981dc16e57f46e20a0ea94f9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a3e2779dde22b37036f07001bace3e/" rel="bookmark">
			分布式【ZooKeeper面试题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZooKeeper 是什么？ ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。
ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
Zookeeper 都有哪些功能？ 集群管理：监控节点存活状态、运行请求等；主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；分布式锁：Zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。Zookeeper 可以对分布式锁进行控制。命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。 说说Zookeeper 的文件系统 Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。
Zookeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为1M。
Zookeeper 怎么保证主从节点的状态同步？ Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。
1、恢复模式
当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。
2、广播模式
一旦 leader 已经和多数的 follower 进行了状态同步后，它就可以开始广播消息了，即进入广播状态。这时候当一个 server 加入 ZooKeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。ZooKeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。
zookeeper 是如何保证事务的顺序一致性的？ zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch 用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a3e2779dde22b37036f07001bace3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1128e3633e2c9aa80af82d1e8894c43d/" rel="bookmark">
			2023春季李宏毅机器学习笔记 02 ：机器学习基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料
课程主页：https://speech.ee.ntu.edu.tw/~hylee/ml/2023-spring.phpGithub：https://github.com/Fafa-DL/Lhy_Machine_LearningB站课程：https://space.bilibili.com/253734135/channel/collectiondetail?sid=2014800 一、機器學習基本原理 机器学习本质：机器自动寻找一个最合适的函数f
根据函数的输出可以分为两类：
Regression（回归）：函数的输出是一个数值
例如：输入输入今天的PM2.5值、温度、臭氧量等，输出明天的PM2.5值Classification（分类）：函数的输出是一个类别（选择题）
例如：判断一封邮件是否为垃圾邮件Structured Learning/Generative Learning（结构化学习/生成式学习）：生成有结构的物件（如影像、文句等），更复杂 寻找函数f的步骤：
第一步：选定候选函数的集合Model；
深度学习中类神经网络的结构（如：CNN、RNN、Transformer、Decision Tree等等）指的就是不同的候选函数集合，函数集合表示为H
目的：缩小选择的范围；技巧性强
训练资料少时，L(f)小但测试差的函数就会多，这个时候画出集合范围要保守（小）；反之测试数据多时，上述L(f)小但测试差的函数就会少
第二步：订出评价函数好坏的标准；
使用Loss函数，将f做出输入，输入L函数：L(f)，根据输出的大小，评价函数（越大越差），L的计算过程取决于training data
常用方法：
supervised Learning（全部都有标准答案）
semi-supervised Learning（没有标准答案，要定义评量标准）
RL(reinforcement Learning)等等 第三步：找出最好的函数，最佳化Optimization
将集合H中的所有函数带入L中，寻找Loss最小值
常用方法：Gradient Descent（Adam，AdamW…），Genetic Algorithm等等
超参数：手调参数
二、生成式学习的两种策略 生成式学习：生成有结构的物件
案例：
生成影片：https://imagen.research.google/video/ 或https://audioldm.github.io/生成语音：https://dongchaoyang.top/InstructTTS/生成声音：https://audioldm.github.io/ 两种策略
策略 1：各个击破AR（Autoregressive Model）：上一个生成才生成下一个策略 2：一次到位NAR（Non-autoregressive Model）：一次性生成所有的策略比较： AR：速度慢，答案质量好，适合生成文字NAR：速度快，答案质量较差，适合生成图像（影像像素过多，AR太慢） 综合使用： 批次
以语音合成为例：生成分为两个阶段，AR决定大方向，NAR生成最后产物
将“一次到位”改为“N此到位”（类似Diffusion Model）
三、能够使用工具的AI New Bing：New Bing是有搜寻网络的，但什么时候进行搜寻是由机器自己决定的
WebGPT：也是文字接龙
步骤：
输入”Which river is longer, the Nile or the Yangtze?”（翻译：拿一条河比较长，尼罗河还是扬子江？）提取关键字（如：”Nile vs Yangtze”、”nile length”、”Yangtze length”）对关键字进行网络搜索，根据算法对搜索网页资料的部分段落进行收藏（注意只收藏文字段落，而不是整个网页）整理生成答案（答案后会附上引用的网址） Toolformer：使用多种不同的工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1128e3633e2c9aa80af82d1e8894c43d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a65e41d6ec440bb7cf8618902dfff81/" rel="bookmark">
			leetcode2487.从链表中移除节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目思路复杂度Code 题目 给你一个链表的头节点 head 。
移除每个右侧有一个更大数值的节点。
返回修改后链表的头节点 head 。
示例 1：
输入：head = [5,2,13,3,8]
输出：[13,8]
解释：需要移除的节点是 5 ，2 和 3 。
节点 13 在节点 5 右侧。节点 13 在节点 2 右侧。节点 8 在节点 3 右侧。
示例 2： 输入：head = [1,1,1,1]
输出：[1,1,1,1]
解释：每个节点的值都是 1 ，所以没有需要移除的节点。
提示：
给定列表中的节点数目在范围 [1, 105] 内
1 &lt;= Node.val &lt;= 105
Problem: 2487. 从链表中移除节点
思路 使用单调栈，保留从左到右单调递减的数组，赋值给节点
在单调栈构造时，我们维护一个非递增的数组
如果发现下一个节点大于栈顶元素，则一直弹出栈顶元素，直到栈为空，或者栈顶元素大于下一个节点
复杂度 时间复杂度:
O ( n ) O(n) O(n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a65e41d6ec440bb7cf8618902dfff81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fcf1b5a997b1622d1d52077e7943138/" rel="bookmark">
			【Electron】Vite&#43;Ts 项目内配置路径别名 “@/“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你在Vite项目内使用绝对路径 "@/" 出现这样报错
[plugin:vite:import-analysis] Failed to resolve import "@/components/HelloWorld.vue" from "src\App.vue". Does the file exist?
C:/Users/ttatt/Desktop/te/getLive/gitee/webElectron/src/App.vue:2:23
1 | import { defineComponent as _defineComponent } from "vue";
2 | import HelloWorld from "@/components/HelloWorld.vue";
| ^
3 | const _sfc_main = /* @__PURE__ */ _defineComponent({
4 | __name: "App",
在 Vite 项目中，路径别名的配置是通过 vite.config.js 文件中的 resolve.alias 字段来完成的。确保项目中有这样的配置，以便正确使用 @/ 路径别名。
1.在 tsconfig.json 中配置路径别名：
// tsconfig.json { "compilerOptions": { "baseUrl": ".", "paths": { "@/*": ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fcf1b5a997b1622d1d52077e7943138/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3d892a875b0478dc84d6d9464f44ac/" rel="bookmark">
			前端Web系统架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.目录结构定义2. 路由封装2.1 API路由定义2.2 组件路由定义 3. Axios请求开发4. 环境变量封装5. storage模块封装(sessionStorage, localStorage)6. 公共函数封装(日期,金额,权限..)7. 通用交互定义(删除二次确认,类别,面包屑...)8. 接口全貌概览 1.目录结构定义 2. 路由封装 react-router6
2.1 API路由定义 2.1 API路由定义
import { Navigate, createHashRouter, createBrowserRouter } from 'react-router-dom' import Login from '@/views/Login' import Welcome from '@/views/Welcome' import Error403 from '@/views/403' import Error404 from '@/views/404' export const router = [ { path: '/', element: &lt;Welcome /&gt; }, { path: '/login', element: &lt;Login /&gt; }, { path: '*',// 匹配路由不到路由, 跳转404. 用Navigate组件重定向到404 element: &lt;Navigate to='/404' /&gt; }, { path: '/404', element: &lt;Error404 /&gt; }, { path: '/403', element: &lt;Error403 /&gt; }, ] export default createBrowserRouter(router) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c3d892a875b0478dc84d6d9464f44ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d45f53e3367f3fbe0d6da6294e92d3/" rel="bookmark">
			react-router-dom4 学习进阶---react-router4五种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v4-v5: https://v5.reactrouter.com/web/example/no-match
v6:https://reactrouter.com/en/main
https://github.com/DudeYouth/react-route-dom-test
https://github.com/supasate/connected-react-router/blob/master/FAQ.md#how-to-migrate-from-v4-to-v5
https://github.com/dL-hx/imoocmanagerhttps://github.com/dL-hx/imoocmanager
文章目录 1. demo1-基础使用2. demo2-嵌套标签组件3. demo3-在子组件中进行嵌套路由4. demo4-测试动态路由功能5. demo4-NoMatch组件 + "react-router-dom": "^4.3.1", 1. demo1-基础使用 src\pages\route_demo\router1\About.js
import React from 'react' export default class About extends React.Component { render() { return ( &lt;div&gt; this is About page. &lt;/div&gt; ); } } src\pages\route_demo\router1\Main.js
import React from 'react' export default class Main extends React.Component { render() { return ( &lt;div&gt; this is Main page. &lt;/div&gt; ); } } src\pages\route_demo\router1\Topic.js
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d45f53e3367f3fbe0d6da6294e92d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5236fff6e6e5c819c8810a6d8b4f801f/" rel="bookmark">
			免费开源 | 基于SpringBoot的众筹平台项目系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本介绍 本项目是一套基于springboot等主流的技术框架开发的众筹平台系统；项目整体包含前、后台两大模块，功能上完整涵盖众筹平台所需要的核心功能， 如从前台用户注册-登录-发起众筹-支持项目-个人中心，再到后台的项目管理审核-用户管理-订单管理，实现了完整的功能流程闭环。同时项目结构分层清晰易懂，程序基于轻量化的设计理念没有额外无关的依赖项，运行方便简单。
适用于计算机相关专业学生或者没有实战项目经验的初级开发者：
用于学期课程设计参考学习
用于毕业设计参考学习
需要实战项目练习的初级开发者
二、技术设计 1. 后台 开发语言：Java（Jdk1.8）
数据库：Mysql
基础框架：spring、springboot
权限安全：SpringSecurity + oauth2
接口文档：swagger2
开发软件：idea
依赖管理：Maven
2. 前台 html + vue + js + jQuery + ajax
三、运行步骤 1. 环境前提 Jdk1.8
Mysql8，可视化程序建议使用Navicat
Maven &gt;= 3.6
2. 运行程序 用Navicat连接本地数据库，新建crowdfunding数据库，然后将 /sql 目录下的脚本执行导入数据库
将程序源代码编译器，进行构建编辑
修改项目配置文件数据库用户名、密码
最后直接启动程序即可
四、功能概述 用户模块 注册 - 登录 - 发起众筹（填写信息、预览、上传照片等） - 个人中心 - 我的项目 - 我的支持
访问地址：http://localhost:9080/ 账号：19988885555/123456
1. 注册登录 2. 发起众筹 基础信息 、 项目信息 、 项目详情 、 回报设置、 编辑预览、查看项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5236fff6e6e5c819c8810a6d8b4f801f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64733f2e8562b23fa2a3136e087c02f3/" rel="bookmark">
			rk3588中编译带有ffmpeg的opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有朋友有工程需要，将视频写成mp4，当然最简单的方法当然是使用opencv的命令
cv::VideoWriter writer; bool bRet = writer.open("./out.mp4", cv::VideoWriter::fourcc('m', 'p', '4', 'v'), 15, cv::Size(640, 512), 1); 但是奈何很难编译成功，其实技巧不多，支持mp4编码有几种方式，ffmpeg，gstreamer，v4l2等，常用的是ffmpeg和gstreamer，个人花了很久终于编译成功
编译好的opencv库文件放置在了以下链接，但是不好意思，会收一些费用，毕竟花了好久才编译成功，大家按需获取吧
另外，自己做的板子也开放销售了，包含两路cameralink接口可以接入红外相机，一路lvds接口可以接入索尼协议机芯，同时集成了spi，rs232，rs422，千兆网，usb3.0和hdmi等，如果你想做一个光电吊舱，这个无疑是特别经济的选择，因为售价就几千元，但是却包含了fpga的协议转换，linux底层的驱动开发，你只需要在应用层进行开发即可，事半功倍，需要的请联系我的qq345989965，愿大家工作顺利
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3519c84e21d9a636c3be163864704bb/" rel="bookmark">
			鸿蒙工程目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程结构 . ├── build ├── build-profile.json5 ├── hvigorfile.ts ├── libs │ └── armeabi-v7a ├── oh-package.json5 ├── oh_modules │ └── @types │ └── libentry.so -&gt; ../../src/main/cpp/types/libentry └── src ├── main │ ├── cpp │ │ ├── CMakeLists.txt │ │ ├── hello.cpp │ │ └── types │ │ └── libentry │ │ ├── index.d.ts │ │ └── oh-package.json5 │ ├── ets │ │ ├── entryability │ │ │ └── EntryAbility.ts │ │ └── pages │ │ └── Index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3519c84e21d9a636c3be163864704bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f6660ecfbd037eeea8f1aea5e90b3a/" rel="bookmark">
			关于“Python”的核心知识点整理大全57
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
3. 模板edit_entry
edit_entry.html
4. 链接到页面edit_entry
topic.html
19.2 创建用户账户
19.2.1 应用程序 users
1. 将应用程序users添加到settings.py中
settings.py
2. 包含应用程序users的URL
urls.py
19.2.2 登录页面
urls.py
1. 模板login.html
login.html
2. 链接到登录页面
base.html
3. 使用登录页面
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
from django.shortcuts import render --snip-- from .models import Topic, Entry from .forms import TopicForm, EntryForm --snip-- def edit_entry(request, entry_id): """编辑既有条目""" 1 entry = Entry.objects.get(id=entry_id) topic = entry.topic if request.method != 'POST': # 初次请求，使用当前条目填充表单 2 form = EntryForm(instance=entry) else: # POST提交的数据，对数据进行处理 3 form = EntryForm(instance=entry, data=request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f6660ecfbd037eeea8f1aea5e90b3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b1f375624e530b9d881903e55073c9f/" rel="bookmark">
			【python】—— 列表和元组详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种强大的编程语言，它提供了许多内置的数据结构，用于存储和处理数据。其中，列表和元组是两种常用的数据类型。这篇文章将介绍这两种数据结构的定义、用途、用法以及它们的异同点。
目录
（一）理解列表和元组
（二）基本操作
2.1 列表的基本操作
2.1.1 创建列表
2.1.2 访问下标
2.1.3 切片操作
2.1.4 遍历列表元素
2.1.5 新增元素
2.1.6 查找元素
2.1.7 删除元素
2.1.8 连接列表
2.2 元组 （三）总结
（一）理解列表和元组 编程中 , 经常需要使用变量 , 来保存 / 表示数据 .。如果代码中需要表示的数据个数比较少, 我们直接创建多个变量即可： num1 = 10 num2 = 20 num3 = 30 ...... 但是有的时候 , 代码中需要表示的数据特别多 , 甚至也不知道要表示多少个数据 . 这个时候 , 就需要用到 列表 . 💨 列表是Python中最常用的数据结构之一，它是一种有序的集合，可以包含不同类型的数据项。列表中的元素可以重复，也可以是基本数据类型（如整数、浮点数、字符串等）。
就像我们去超市买辣条, 如果就只是买一两根辣条, 那咱们直接拿着辣条就走了. 但是如果一次买个十根八根的, 这个时候用手拿就不好拿, 超市老板就会给我们个袋子. 这个袋子, 就相当于 列表 💨 元组 和列表相比, 是非常相似的 , 元组也是一种有序的集合，但它不能修改。与列表相比，元组的主要区别在于它是一个不可变的序列，这意味着一旦创建，就不能添加或删除元素。 （二）基本操作 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b1f375624e530b9d881903e55073c9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06066b6a0bc123f5986a79d2f89b9d59/" rel="bookmark">
			如何学习TS?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 8种内置基础类型.ts二. void、never、any、unknown类型void类型never类型any类型unknown类型总结：void和any在项目中是比较常见的，never和unknown不常用。 三. 数组和函数类型定义.ts四. 元组与交叉类型使用元组数组一般有同类型的值组成，但有时候存在多种类型，我们多种类型定义称为元组。数组定义：同一类型元组定义：不同类型 交叉类型把多个类型合并为一个类型，称为交叉类型。联合类型表示或的关系交叉类型表示取两个类型的并集例子：例子： 五. 接口五种场景与使用接口定义：属性只读或可选任意属性定义函数类型接口继承接口和Type区别？例子： 六. 泛型三种定义与使用方式泛型场景1：如何给arg参数和函数指定类型场景2：多个类型如何传递？回顾一下任意属性场景3：Pick使用例子： 七. 关键知识点 keyof,typeof, in的使用keyoftypeofin例子： 八.tsconfig.json配置基础字段编译配置 总结 一. 8种内置基础类型.ts /* eslint-disable @typescript-eslint/no-unused-vars */ // 定义类型: string const name: string = 'jack' // 定义类型: number const age: number = 30 // 定义类型: boolean const isTrue: boolean = true // 特殊的几个:--------- // 定义undefined类型 let a: undefined // 定义null类型 const b: null = null // 定义object类型 const user: object = {} // 或者 const user1: { name: string; age: number } = { name: 'zhangsan', age: 24 } // 定义bigint类型 const big: bigint = 100n // 定义symbol符号类型 const sym: symbol = Symbol('hepan') export default {} 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06066b6a0bc123f5986a79d2f89b9d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012e963143d45d0adf154fb8cc2ebc0f/" rel="bookmark">
			python pdf2word pdf转word
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用方法20240102 在windows上我没搞定，在linux上还是可以的 github链接：python-fan/pdf2word 使用方法 使用：
1、clone或下载git clone https://github.com/Dontla/pdf2word.git
2、pip install -r requirements.txt安装依赖（安装过程可能会出小问题，比如我这里说跟tensorflow-gpu冲突）
3、修改config.cfg文件并创建文件夹
4、将需要转换的pdf文档放入pdf文件夹
5、执行程序
6、查看结果：空无一物
是不是加密pdf没法转？
貌似这个可以免费转换，用它转了https://smallpdf.com/cn
转换后效果还行吧。。。
20240102 在windows上我没搞定，在linux上还是可以的 步骤一样，就是要执行apt install python3-tk，不然报错。
但是它这个有点坑的就是，转出来变成图片了，根本不能复制文字😂
ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍ᅟᅠ ‌‍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/012e963143d45d0adf154fb8cc2ebc0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0253f3774769e81f132d6efba18969aa/" rel="bookmark">
			基于双闭环PI和SVPWM的PMSM控制器simulink建模与仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.课题概述
2.系统仿真结果
3.核心程序与模型
4.系统原理简介
4.1 双闭环PI控制器设计
4.2 SVPWM技术
4.3 控制系统实现
5.完整工程文件
1.课题概述 基于双闭环PI和SVPWM的PMSM控制器simulink建模与仿真。系统包括逆变桥、PMSM、park变换、clark变换、SVPWM、PI控制器、信号测量等单元模块的Simulink模型。在这个模型中，我们将实现双闭环控制——转速环和电流环都采用PI比例积分控制。这种控制策略可以使电机在不同负载情况下都能够快速和稳定地达到给定的转速和电流值。
2.系统仿真结果 3.核心程序与模型 版本：MATLAB2022a
4.系统原理简介 永磁同步电机（PMSM）由于其高效率、高功率密度和优秀的动态性能，在电动汽车、工业自动化等领域得到了广泛应用。为了实现PMSM的高性能控制，通常采用矢量控制策略，并结合空间矢量脉宽调制（SVPWM）技术。而在控制器设计中，双闭环PI（比例-积分）控制器因其结构简单、调整方便、鲁棒性好等优点，被广泛应用于电机控制系统。
4.1 双闭环PI控制器设计 双闭环PI控制器包括速度环和电流环。速度环作为外环，用于控制电机的转速；电流环作为内环，用于控制电机的电流。通过双闭环结构，可以实现对电机转速和电流的精确控制。
速度环PI控制器：速度环PI控制器的输入为参考转速与实际转速的差值，输出为参考交轴电流。
电流环PI控制器：电流环PI控制器包括直轴电流环和交轴电流环。直轴电流环用于控制直轴电流，以实现磁场定向控制；交轴电流环用于控制交轴电流，以实现转矩控制。
4.2 SVPWM技术 SVPWM（空间矢量脉宽调制）技术是一种高效的PWM调制方法，用于将直流电压逆变为三相交流电压。与传统的SPWM（正弦波脉宽调制）相比，SVPWM具有更高的直流电压利用率和更好的动态性能。SVPWM的基本原理是通过合成不同的电压矢量来逼近理想的圆形旋转磁场。在实际应用中，通常采用查表法或实时计算法来实现SVPWM。
4.3 控制系统实现 基于双闭环PI和SVPWM的PMSM控制系统实现过程如下：
采集电机的转速、电流等反馈信息；
根据给定的参考转速和实际转速计算速度误差；
将速度误差输入到速度环PI控制器中计算参考交轴电流；
根据给定的参考直轴电流和实际直轴电流计算直轴电流误差；
将直轴电流误差输入到直轴电流环PI控制器中计算直轴电压参考值；
将参考交轴电流和实际交轴电流输入到交轴电流环PI控制器中计算交轴电压参考值；
根据直轴和交轴的电压参考值进行SVPWM调制生成PWM波形；
将PWM波形作用于逆变器的开关管驱动电机运转；
重复以上步骤实现闭环控制。
5.完整工程文件 v
v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae96665a9ffe3ccacab0e725554e533/" rel="bookmark">
			Vue3中使用动态组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用方式：使用场景： 在 Vue 3 中，动态组件是一种允许在运行时动态切换组件的机制。Vue 3 提供了 元素以及 is 特性来实现动态组件的切换。 使用方式： 1、使用 元素
在模板中使用 元素，通过 is 特性来动态切换组件：
&lt;template&gt; &lt;div&gt; &lt;component :is="currentComponent"&gt;&lt;/component&gt; &lt;button @click="toggleComponent"&gt;Toggle Component&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import FirstComponent from './FirstComponent.vue'; import SecondComponent from './SecondComponent.vue'; export default { data() { return { currentComponent: 'FirstComponent', }; }, methods: { toggleComponent() { this.currentComponent = this.currentComponent === 'FirstComponent' ? 'SecondComponent' : 'FirstComponent'; }, }, components: { FirstComponent, SecondComponent, }, }; &lt;/script&gt; 2、使用 v-if 或 v-show
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae96665a9ffe3ccacab0e725554e533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ba335278db349e110e8a1a79d1f2a7/" rel="bookmark">
			听GPT 讲Rust源代码--library/core/benches
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File: rust/library/core/benches/slice.rs 文件路径：rust/library/core/benches/slice.rs
这个文件是Rust标准库中的一个示例（benchmark）文件，用来测试切片（slice）在不同情况下的性能。
Rust的切片是对数组（array）的引用，它允许以安全和高效的方式操作数据的一部分。slice.rs文件中的基准测试主要集中在对切片进行各种操作的性能评估上，以便开发人员可以比较不同的实现方式和优化策略。
下面是slice.rs文件中出现的一些结构体和枚举的介绍：
Rgb(u8): 这是一个简单的结构体，表示一个RGB颜色，每个颜色通道都用一个8位无符号整数（u8）表示。
NewType(u8): 这是一个简单的新类型（newtype）结构体，它仅包装一个8位无符号整数（u8）。新类型结构体在某些情况下可能会提供类型安全和更好的表达能力。
Cache枚举： 这是一个枚举类型，在slice.rs文件中用于缓存（cache）的相关测试。
Cache::Hit: 在缓存中找到所需数据的情况，表示缓存命中。
Cache::Miss: 在缓存中未找到所需数据的情况，表示缓存未命中。
Cache::Init: 缓存初始化的情况，用于模拟缓存的初始状态。
Cache::Drop: 缓存项被释放的情况，用于测试释放缓存的开销。
Cache::Padded: 缓存项被填充的情况，用于测试缓存行对齐的性能影响。
这些结构体和枚举类型在slice.rs文件的基准测试中被用来模拟不同的场景，以评估切片相关操作在不同情况下的性能特征和开销。这些测试对于优化标准库中的切片实现、优化底层算法以及性能调优非常重要。
File: rust/library/core/benches/ascii/is_ascii.rs 在Rust的源代码中，rust/library/core/benches/ascii/is_ascii.rs 是一个用于性能测试的文件，它是为了评估 Rust 标准库中与 ASCII 字符相关的功能的性能而创建的。
ASCII（American Standard Code for Information Interchange）是一个用于表示英语字符的字符编码标准。ASCII 编码使用一个字节（8位）来表示每个字符，它包括基本的数字、字母、标点符号和控制字符。
该文件中包含了一系列的性能测试用例，用于测试 Rust 标准库中的 is_ascii 相关函数的性能。这些函数可以用来检查一个字符串或字符是否仅包含 ASCII 字符。测试用例涉及不同长度的字符串、不同类型的字符和不同的边界条件，以评估这些函数在各种情况下的性能表现。
性能测试对于评估函数的性能非常重要，因为它们提供了在不同情况下函数的运行时间、内存使用情况和其他性能指标的度量。通过进行这些性能测试，开发人员可以确定哪些方面需要改进，以便在实际应用中提高 Rust 标准库的性能和效率。
通过详细分析和比较这些测试结果，开发人员可以识别潜在的性能问题并采取适当的优化措施。他们可以尝试不同的算法、数据结构或优化技术，以提高函数在处理 ASCII 字符时的性能。
总之，is_ascii.rs 文件在 Rust 的源代码中起到了性能测试的作用，旨在评估与 ASCII 字符相关的功能的性能，并帮助优化这些功能以提高 Rust 标准库的性能和效率。
File: rust/library/core/benches/char/methods.rs 在Rust源代码中，rust/library/core/benches/char/methods.rs这个文件的作用是用于性能测试和基准测试。
性能测试是用来度量代码在特定条件下的执行速度和资源消耗，以便发现潜在的性能问题。基准测试是一种特殊类型的性能测试，用于比较不同实现之间的性能差异。
该文件包含了对Rust标准库中的char类型的方法进行性能测试的代码。char类型代表Unicode字符，并提供了包括转换、迭代和属性检查等方法。通过性能测试可以评估这些方法的执行速度和资源消耗，以便在实际使用中做出准确的性能决策。
在methods.rs文件中，通过使用Rust语言提供的基准测试框架（Bench），可以定义和运行各种基准测试。基准测试使用随机生成的字符，并对char类型的方法进行多次重复运行，以获取可靠的性能数据。测试结果可以显示每个方法的平均执行时间、标准差和各种统计信息，以及与其他方法的比较结果。
基准测试有助于开发人员更好地了解char类型方法的性能特征，以及如何在不同的场景下使用它们。通过检测性能问题，可以优化代码，提高执行效率，从而改善整体的应用性能和用户体验。
总之，rust/library/core/benches/char/methods.rs文件在Rust源代码中的作用是提供一个基准测试环境，以评估和比较char类型的方法的性能表现。这有助于开发人员优化和改进Rust标准库，提供更高效的Unicode字符处理功能。
File: rust/library/core/benches/char/mod.rs 在Rust的源代码中，rust/library/core/benches/char/mod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ba335278db349e110e8a1a79d1f2a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a3e620a74ae3a81da42c176bcdf2f36/" rel="bookmark">
			Go语言基础简单了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言关于Go学习流程 基础语法注释变量常量数据类型运算符fmt库 流程控制if、switch、selectfor、break、continue遍历String 函数值传递和引用传递deferinit匿名、回调、闭包函数 数组和切片Map结构体自定义数据类型接口协程和channel线程锁异常处理泛型文件读取文件写入反射TCP网络编程Httpwebsocket爬虫正则表达式goquerycolly豆瓣250爬B站评论 前言 简单的入门一下Go、会对基础语法、网络编程、Gin开发进行简单的了解，关键是Gin开发。
关于Go Go语言（也称为Golang）是Google开发的一种开源编程语言。它被设计用于构建高效、可靠和可扩展的软件系统。下面是Go语言的一些主要用途：
服务器端开发：Go语言提供了强大的标准库和并发模型，使其成为构建高性能网络服务器的理想选择。许多大型互联网公司正在使用Go语言来开发后端服务，以处理高负载和并发请求。网络编程：Go语言提供了丰富的网络编程库，可用于开发各种网络应用程序，包括Web服务、API服务器、网络代理等。分布式系统：Go语言的并发模型和原生支持的并发原语（goroutine和channel）使其非常适合构建分布式系统，例如数据处理管道、消息队列等。命令行工具：Go语言的编译速度快，生成的可执行文件体积小，使其成为开发命令行工具的良好选择。许多开发者使用Go语言来构建工具、脚本和自动化任务。嵌入式系统：Go语言可以用于编写嵌入式系统的控制逻辑和驱动程序。它提供了对底层硬件的访问和控制能力，并具有较小的内存消耗。 需要注意的是，Go语言具有简洁而直观的语法，易于学习和使用。它的性能非常好，可以充分利用多核处理器和并发编程来提高应用程序的性能和吞吐量。
学习流程 基础语法-&gt;Web开发-&gt;常见中间件-&gt;云平台
基础语法 注释 增强语言的可读性
单行注释
多行注释
package main import "fmt" // 单行注释 /* 多行注释 多行注释 */ func main() { fmt.Println("hello world") } 变量 var 定义变量，var 变量名 变量类型。简短变量声明，使用:=运算符可以在函数内部声明并初始化变量。匿名变量，使用 _ 占位符可以声明一个匿名变量，忽略不需要的值，任何赋值給这个标识符的值都将被抛弃，并且不会导致变量的冲突定义多个变量，可以使用()包裹，表示定义多个变量注意点：变量名的首个字符不能为数字，全局变量可被局部变量再定义(就近原则 )，定义的变量一定要使用。 变量声明后的默认值：
整数型浮点数变量默认值是0和0.0字符串变量默认值是空字符串布尔型变量默认是false切片，函数，指针变量默认是nil Printf输出时声明的格式
%v：默认格式化输出，会根据变量的类型自动选择合适的格式。%s：输出字符串。%d、%b、%o、%x：输出整数，分别表示十进制、二进制、八进制和十六进制。%t：输出布尔值，结果为 true 或 false。%f、%e、%g：输出浮点数，分别表示十进制表示法、科学计数法和通用格式。%p：输出指针地址。%c：输出字符。%q：输出带引号的字符串。%%：输出一个百分号。 fmt.Printf("内存地址:%p,变量类型:%T",name,&amp;name) //打印内存地址，变量类型等 例子：
package main import "fmt" var name = "Lau" //全局变量(隐式定义) func fun() (int, int) { return 100, 200 } func main() { var name string = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a3e620a74ae3a81da42c176bcdf2f36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93210cb0d13d97f9cdfaf2d1d542315/" rel="bookmark">
			VC6.0 下载的dsw打不开解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有位朋友发了个老项目给我，是十多年前的VC6.0写的，为此我下载了一个VC6。但当选择打开工作空间时，却没有反应，甚至会报错。提示如下：
根据提示内容，Google了一下，找到了这篇帖子：https://www.cnblogs.com/ioriwellings/p/17309458.html
最终使用Notepad++，打开dsw、dsp，另存为修改文件格式，解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505fe471d03e8dabbf23bd6902ce6027/" rel="bookmark">
			ue4-第三人称-教程笔记9AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制作AI 创建目录AI
创建蓝图
创建一个Character蓝图 命名为AIChar
打开AIChar选中Mesh, 修改Mesh的网状结构
选中如下网格
点击查看材质
复制一份对应材质
修改颜色为白色
修改AI的材质
创建AI蓝图结束
创建AI控制器 创建蓝图aicontroler
重命名为AICharController
创建行为树 重命名为AICharBehaviorTree
控制器关联行为树 在AICharController中设置RunBehaviorTree
设置AICharBehaviorTree
AIChar和AICharController关联 打开行为树, 新建一个黑板 重命名为AICharBlackBoard
行为树关联黑板 然后可以再行为树和Blackboard之间来回切换
AI的基本东西都处理好了
接下来制作AI的动画蓝图 选择骨骼
重命名为AIChar_ABP
打开动画蓝图 添加插槽,
添加状态机
重命名为StateMechine
编辑状态机
添加状态
重命名为Idle/Run
添加混合空间 搜索之前的混合空间2D
提升Speed为变量
修改变量名为Speed
为AI 添加武器
添加骨架网格物体
修改名称为Sword
Skeletal Mesh修改为Sword
修改父项插槽
如上继续添加盾Shield
修改剑和盾的颜色
设置动画蓝图的Speed
设置动画蓝图如何获取Speed
修改行为树 添加装饰器名称HavePlayer
修改装饰器如下
在黑板中新建键
TargetPlayer
为装饰器HavePlayer修改targetPlayer属性
为Selector添加装饰器
添加Sequence 添加blackboard
再添加一个
修改KeyQuery
添加move to 目标为TargetPlayer 和wait 设置为2s
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505fe471d03e8dabbf23bd6902ce6027/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/14/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>