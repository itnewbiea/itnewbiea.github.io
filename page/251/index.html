<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876f6fc2a1b3d6b1a10985f64d417e47/" rel="bookmark">
			登录绑定回车事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绑定回车事件写法有很多种，那么以下是我常用的两种方式：
先来说一下键盘事件：
1、keydown() keydown事件会在键盘按下时触发. 2、keyup() keyup事件会在按键释放时触发,也就是你按下键盘起来后的事件 3、keypress() keypress事件会在敲击按键时触发,我们可以理解为按下并抬起同一个按键
第一次种：
$(document).keypress(function(e) { if((e.keyCode || e.which)==13) { $("#login_btn").click(); //login_btn登录按钮的id
} }); $(document).keydown(function(e) { if((e.keyCode || e.which)==13) { $("#login_btn").click(); //login_btn登录按钮的id } }); 如果你用的Eayui框架 最好选择使用keypress 如果你选择keydown() 会出现弹出层一闪而过（个人建议）
第二种：
document.onkeydown = function(e){
if(!e){
e = window.event;
}
if((e.keyCode || e.which) == 13){
checkLogin();//你的登录事件
}
}
最后附上键表 http://www.cnblogs.com/shyy/archive/2012/04/09/2453029.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc2e70982bffa00bc940431ef4f2154/" rel="bookmark">
			tf.train.MonitoredTrainingSession()解析【精】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看了下cifar10源码，训练代码中使用了tf.train.SessionRunHook()，tf.train.MonitoredTrainingSession()；查看官方API后终于有些眉目了，特记录备忘。
首先，先讲下tf.train.MonitoredTrainingSession()；
一 .MonitoredTrainingSession() 首先，tf.train.MonitorSession()从单词的字面意思理解是用于监控训练的回话，返回值是tf.train.MonitorSession()类的一个实例Object, tf.train.MonitorSession()会在下面讲。
MonitoredTrainingSession( master='', is_chief=True, checkpoint_dir=None, scaffold=None, hooks=None, chief_only_hooks=None, save_checkpoint_secs=600, save_summaries_steps=USE_DEFAULT, save_summaries_secs=USE_DEFAULT, config=None, stop_grace_period_secs=120, log_step_count_steps=100 ) Args:
is_chief：用于分布式系统中，用于判断该系统是否是chief，如果为True，它将负责初始化并恢复底层TensorFlow会话。如果为False，它将等待chief初始化或恢复TensorFlow会话。
checkpoint_dir：一个字符串。指定一个用于恢复变量的checkpoint文件路径。
scaffold：用于收集或建立支持性操作的脚手架。如果未指定，则会创建默认一个默认的scaffold。它用于完成图表
hooks：SessionRunHook对象的可选列表。可自己定义SessionRunHook对象，也可用已经预定义好的SessionRunHook对象，如：tf.train.StopAtStepHook()设置停止训练的条件；tf.train.NanTensorHook(loss):如果loss的值为Nan则停止训练；
chief_only_hooks：SessionRunHook对象列表。如果is_chief== True，则激活这些挂钩，否则忽略。
save_checkpoint_secs：用默认的checkpoint saver保存checkpoint的频率（以秒为单位）。如果save_checkpoint_secs设置为None，不保存checkpoint。
save_summaries_steps：使用默认summaries saver将摘要写入磁盘的频率（以全局步数表示）。如果save_summaries_steps和save_summaries_secs都设置为None，则不使用默认的summaries saver保存summaries。默认为100
save_summaries_secs：使用默认summaries saver将摘要写入磁盘的频率（以秒为单位）。如果save_summaries_steps和save_summaries_secs都设置为None，则不使用默认的摘要保存。默认未启用。
config：用于配置会话的tf.ConfigProtoproto的实例。它是tf.Session的构造函数的config参数。
stop_grace_period_secs：调用close（）后线程停止的秒数。
log_step_count_steps：记录全局步/秒的全局步数的频率
Returns: 一个MonitoredSession（） 实例。
下面主要介绍tf.train.MonitoredSession()类
二tf.train.MonitoredSession()类 官方文档给的定义是：
Session-like object that handles initialization, recovery and hooks. 是一个处理初始化，模型恢复，和处理Hooks的类似与Session的类。
Args:
session_creator:制定用于创建回话的ChiefSessionCreator
hooks:tf.train.SessionRunHook()实例的列表
Returns: 一个MonitoredSession 实例。
Example usage:
saver_hook = CheckpointSaverHook(...) summary_hook = SummarySaverHook(...) with MonitoredSession(session_creator=ChiefSessionCreator(...), hooks=[saver_hook, summary_hook]) as sess: while not sess.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc2e70982bffa00bc940431ef4f2154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83684821d3b4947a0ac934d90b5e1ccb/" rel="bookmark">
			AS编译异常Suggestion: use tools:overrideLibrary=&#34;&#34; to force usage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
Error:Execution failed for task ‘:app:processDebugManifest’. Manifest merger failed : uses-sdk:minSdkVersion 14 cannot be smaller than version 16 declared in library [xxx.xxx:1.0.0] /Users/xxx/xxx/app/build/intermediates/exploded-aar/xxx.xxx/1.0.0/AndroidManifest.xml Suggestion: use tools:overrideLibrary=”xxx.xxx.xxx” to force usage
错误原因：
出现这种情况通常是引用第三方库的时候，app module设置的minSdkVersion比第三方的minSdkVersion小导致的，例如app的 android:minSdkVersion=”14”,而库工程的 android:minSdkVersion=”16”，就会导致出错。
解决办法：
有两种解决方法：
设置app的gradle中的minSdkVersion与引用的第三方库的minSdkVersion一致在app的AndroidManifest.xml文件中添加&lt;uses-sdk tools:overrideLibrary="xxx.xxx"/&gt;即可，这样会使用app的minSdkVersion覆盖库中的minSdkVersion，如果有多个冲突的话，用逗号隔开：&lt;uses-sdk tools:overrideLibrary="xxx.xxx, xxx.xxx"/&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;uses-sdk tools:overrideLibrary="com.github.promeg.tinypinyin.android.asset.lexicons"/&gt; &lt;/manifest&gt; 但是这种方式也有个问题，就是第三方库可能使用高版本的api时运行在低版本的手机上会不存在，如app是14，第三方是16，当运行到14的设备上时使用16的api可能会找不到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d10949731b625b602c918a6992edca5/" rel="bookmark">
			Class -- 01 -- System类常用方法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：Class – 01 – System类常用方法解析
相关文章：
Class – 01 – System类常用方法解析
Class – 02 – Arrays类常用方法解析
Class – 03 – Random类常用方法详解析
Class – 04 – Date类常用方法解析
Class – 05 – TimeUnit类常用方法解析
Class – 06 – TimeZone类常用方法详解析
Class – 07 – Modifier类常用方法解析
Class – 08 – Parameter类常用方法解析
Class – 09 – Field类常用方法解析
Class – 10 – Method类常用方法解析
Class – 11 – Math类常用方法解析
Class – 12 – Locale类常用方法解析
Class – 13 – ThreadPoolExecutor类常用方法解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d10949731b625b602c918a6992edca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f4fcca24d73369f1b6689f7722b654/" rel="bookmark">
			[290]python实现简体中文和繁体相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. opencc-python 如果目录上的链接被屏蔽了，请手动复制 https://pypi.python.org/pypi/opencc-python/
首先介绍opencc的python实现库，它具有安装简单，翻译准确，使用方便等优点。对于我们的需求完全能够胜任。使用步骤如下：
1.1 在terminal中安装opencc-python
pip install opencc-python 如果安装中出现了如下错误：
请先下载 distribute_setup.zip，解压缩后，把distribute_setup.py放到C:\Python27\Lib。然后再执行pip命令。
1.2 使用代码：
# -*- coding: utf8 -*- import opencc cc = opencc.OpenCC('t2s') print cc.convert(u'Open Chinese Convert（OpenCC）「開放中文轉換」，是一個致力於中文簡繁轉換的項目，提供高質量詞庫和函數庫(libopencc)。') 输出为：
Open Chinese Convert（OpenCC）「开放中文转换」，是一个致力于中文简繁转换的项目，提供高质量词库和函数库(libopencc)。
这里有四种内建的opencc翻译配置：
t2s - 繁体转简体（Traditional Chinese to Simplified Chinese）s2t - 简体转繁体（Simplified Chinese to Traditional Chinese）mix2t - 混合转繁体（Mixed to Traditional Chinese）mix2s - 混合转简体（Mixed to Simplified Chinese） 2. zhtools 简要步骤如下：
2.1 中文简体和繁体转换所需Python库:zh_wiki.py（在原作者的库中新添近一倍词库）, langconv
2.2 使用代码
from langconv import * def simple2tradition(line): #将简体转换成繁体 line = Converter('zh-hant').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f4fcca24d73369f1b6689f7722b654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d7f5c116453482ef85680eddb9d78d6/" rel="bookmark">
			FreeCAD紧固件自动生成工作台插件推荐：Fasteners workbench
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用FreeCAD用来画各种标注的螺栓螺丝，如果自己从头到尾实现是一件很费时的事情，在网上找到了一个相关的工作台插件，这里记录一下。
（1） 下载安装包，下载地址：
https://github.com/shaise/FreeCAD_FastenersWB
其还有一个网址：http://theseger.com/projects/2015/06/fasteners-workbench-for-freecad/，但是里面提供的安装包没有github里面新，作者在github里面保持了程序的更新。
（2） 下载完成后解压，然后将文件名重命名为Fasteners ，因为github下载后解压默认的文件名为FreeCAD_FastenersWB-master ，重命名之后将整个文件夹复制到路径（以windows系统为例）：C:\Users\admin\AppData\Roaming\FreeCAD\Mod ，这在win10系统下是一个隐藏文件夹，需要显示隐藏文件夹，还有计算机名称需要根据自己电脑进行调整，像本机是admin 。 成功操作后该目录显示如下： （3） 打开FreeCAD，作者电脑安装的是0.17稳定版本，进入工作台【Fasteners】，如下图 接着就可以选择生成自己想要的紧固件了，比如生成一个M6螺丝：
3.1 选择【ISO 4017 Hex head screw】 出来的是没有螺纹的螺丝 没关系，可以设置的。
3.2 点击左上角【组合浏览器】中的【M6*12-Screw】，在【属性】里面设置thread 为True 带螺纹的螺丝就出来了 还有螺帽啊那些都能通过这种方式生成
（4） 除了使用工作台，还可以单独下载宏文件进行宏处理操作，下载.py文件：
https://github.com/shaise/FreeCAD_FastenersWB/blob/master/screw_maker.py
其实就是刚刚那个github项目的其中一个文件，下载之后将其放置到路径："C:\Users\admin\AppData\Roaming\FreeCAD\Macro" ，如下图： 点击【打开宏】 选择刚刚的宏文件 选择需要生成的紧固件，这里任然以M6螺丝为例，长度16mm， 和使用工作台的差别是这里生成的紧固件已经实体化，方便freecad在part工作台进行下一步处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe88c350109bceeecdf286cad9372ce/" rel="bookmark">
			Kepware读取研华ADAM4017总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、150mV至10V
2、20Ma电流时需要在V+和V-之间并联125欧姆电阻，不用的通道也需要短接。否则会收到已接通道的干扰。
3、测量电压时，不用的通道需要短接。
通道0-通道5接线是相同的，6-7是不同的
读取出来的是ASCII码组成的浮点数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a970223a7f8ac6a39acd8708cedef7fa/" rel="bookmark">
			JavaScript Array.some()方法用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定义和用法： some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。
some() 方法会依次执行数组的每个元素：
如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。 注意： some() 不会对空数组进行检测。
注意： some() 不会改变原始数组。
语法：
array.some(function(currentValue,index,arr),thisValue) 参数说明 参数描述function(currentValue, index,arr)必须。函数，数组中的每个元素都会执行这个函数
函数参数:
参数描述currentValue必须。当前元素的值index可选。当前元素的索引值arr可选。当前元素属于的数组对象thisValue可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。
如果省略了 thisValue ，"this" 的值为 "undefined" 实例说明：
var ages = [23,44,3] if (ages.some(age =&gt; age &lt; 10)) { console.log('true') } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9241fb53f1452a8019406571d9bf4e6d/" rel="bookmark">
			pycharm社区版和专业版的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm产品主页：https://www.jetbrains.com/pycharm/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038322ccafed7dd0e3d626eb55839614/" rel="bookmark">
			C&#43;&#43;中volatile的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码编译环境：Windows7 32bits+VS2012。
volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。
1.volatile的作用 定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。
在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。
而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。如下程序对这一现象进行了模拟。
#include &lt;iostream&gt; using namespace std; int main(int argc,char* argv[]) { int i=10; int a=i; cout&lt;&lt;a&lt;&lt;endl; _asm { mov dword ptr [ebp-4],80 } int b=i; cout&lt;&lt;b&lt;&lt;endl; } 123456789101112131415 程序在VS2012环境下生成Release版本，输出结果是：
10 10 12 阅读以上程序，注意以下几个要点： （1）以上代码必须在Release模式下考查，因为只有Release模式下才会对程序代码进行优化，而这种优化在变量共享的环境下容易引发问题。
（2）在语句b=i；之前，已经通过内联汇编代码修改了i的值，但是i的变化却没有反映到b中，如果i是一个被多个任务共享的变量，这种优化带来的错误很可能是致命的。
（3）汇编代码[ebp-4]表示变量i的存储单元，因为ebp是扩展基址指针寄存器，存放函数所属栈的栈底地址，先入栈，占用4个字节。随着函数内申明的局部变量的增多，esp（栈顶指针寄存器）就会相应的减小，因为栈的生长方向由高地址向低地址生长。i为第一个变量，栈空间已被ebp入栈占用了4个字节，所以i的地址为ebp-i，[ebp-i]则表示变量i的存储单元。
那如何抑制编译器对读取变量的这种优化，来防止错误读取呢？volatile可以轻松胜任，将上面的程序稍作修改，将变量i前申明为volatile即可，观察如下程序：
#include &lt;iostream&gt; using namespace std; int main(int argc,char* argv[]) { volatile int i=10; int a=i; cout&lt;&lt;a&lt;&lt;endl; _asm { mov dword ptr [ebp-4],80 } int b=i; cout&lt;&lt;b&lt;&lt;endl; getchar(); } 12345678910111213141516 程序输出结果为： 10 80 也就是说，第二次读取变量i的值的时候，已经获得了变化之后的值。跟踪汇编代码可知，凡是申明为volatile的变量，每次都是从内存中读取变量的值，而不是在某些情况下直接从寄存器中取值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038322ccafed7dd0e3d626eb55839614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d784f4aeef8690c8bb2e999095f5098c/" rel="bookmark">
			KD-Tree 初学（模板&#43;HDU 4347）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KD_Tree的话，一年半以前，那时候翻我们学校给的模板翻到看了，上面写的"by edward_mj"。这个ID浙大的人应该很熟悉，13-14年连续两年带队打进WF。这里我可以吹一下，edward_mj可是和我同一个高中毕业的哟~当时也问了一下学长，学长说KD树是他写的最溜的一个数据结构之一。
直到这几天我才有时间来学学KD树。所谓KD树，顾名思义k-dimension tree，能够存储k维数据的一棵树。这里这个树其实是指BST。朴素的BST，像Treap、Splay这些，节点都是存储一维的信息，但是KD树就是它们的拓展，可以存储多维数据。一维的时候很容易做到，直接把数据大小当作key，小的放在左边大的放在右边即可。其实拓展到高维的时候也是类似的，只不过要考虑多个维度，最显而易见的想法就是对于每一层，我用不同的维度的数值作为key来进行比较。例如说，对于一个二维数据，我第一层用第一维，第二层用第二维，第三层第一维，第四层第二维……这样，一棵树可以比较均匀的建立。下图给出了一个建立好的KD树的案例。
可以看到，这个案例中总共有6个点，画在坐标轴上就如图1所示，然后我们对图1的区域进行划分。按照顺序，显示竖着切(根据横坐标x)再是横着切(根据纵坐标y)。(7,2)作为根节点，竖着切一刀，所有横坐标小于7的在它的左边，大于等于的在它的右边。接着，下一层换作另外一个坐标继续分割，直到所有的点被划分完毕。
KD树的建立就是这样，与普通的BST相差不大。但他的主要功能却与BST不同，一般来说，KD树用来求与已知点距离最近的m个点是哪几个，也即KNN问题k邻近查询问题。给你一个点，第一件要做的事情显然就是往他所在的区域进行查找，所以对于给定点按照其数值在树上遍历，一直找到一个最小的区域再开始回溯。这里我还是用图结合上上面那个案例来说明。
对于给定的查询点(2,4.5)，我们首先要确定他所在的最小的区域，显然就是左图左上角那一个矩形的区域。然后，目前为止我们能够直到的距离查询点最近的点是点(4,7)，于是我们以这两点之间的距离为半径，查询点为圆心做一个圆（如果高维那就做超球体），判断这个这个最近点的父亲是否在圆内或者圆上。如果在，那么说明这个它的兄弟所在的区域里面可能会有比它距离查询点更近的点，所以要对它的兄弟也进行搜索。这样，把所有该搜索的地方都搜索完毕后，剩下的点就是最邻近的点。如果是求K邻近，那么只需要弄一个优先队列，里面始终保证有且仅有K个点即可。
KD树的话，初学就暂时学了这么多。代码实现，见下面我给的模板题的代码吧。模板题是 HDU 4347 。题意就是一个m邻近问题。代码如下：
#include&lt;bits/stdc++.h&gt; #define sq(x) (x)*(x) #define N (55555) using namespace std; int idx,k,n,m,q; struct Node { int x[5]; bool operator &lt; (const Node &amp;u) const { return x[idx] &lt; u.x[idx]; } } P[N]; typedef pair&lt;double,Node&gt; PDN; priority_queue&lt;PDN&gt; que; struct KD_Tree { int sz[N&lt;&lt;2]; Node p[N&lt;&lt;2]; void build(int i,int l,int r,int dep) { if (l&gt;r) return; int mid=(l+r)&gt;&gt;1; idx=dep%k;sz[i]=r-l; sz[i&lt;&lt;1]=sz[i&lt;&lt;1|1]=-1; nth_element(P+l,P+mid,P+r+1); p[i]=P[mid]; build(i&lt;&lt;1,l,mid-1,dep+1); build(i&lt;&lt;1|1,mid+1,r,dep+1); } void query(int i,int m,int dep,Node a) { if (sz[i]==-1) return; PDN tmp=PDN(0,p[i]); for(int j=0;j&lt;k;j++) tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d784f4aeef8690c8bb2e999095f5098c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316fc4ddf74e8882f1dfec138fda685c/" rel="bookmark">
			使用Ray Matching实现云彩渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里先贴一个我实现的云彩效果，使用Direct3D11，并在pixel shader中使用RayMatching方法实现的，感兴趣的可以下载源代码查看，绘制效果如下：
实现过程主要使用perlin noise来进行云彩建模，然后根据云层厚度和高度决定云彩的颜色，最后使用ray matching算法以及体渲染原理进行颜色的累积。
关于perlin noise的简单介绍可以参考这里;
###云彩绘制部分
由于代码中有很多与云彩绘制无关的部分，所以我这里记录以下云彩绘制部分代码的介绍：
1. 代码实现主要在pixel shader的Get3DCloudColor函数里，大致为：
float3 Get3DCloudColor(float2 xy) { return cloudColor; } xy为屏幕坐标，xy中的y要提前进行归一化，范围为（-1，1），主要是一般屏幕的宽度都大于高度；
该函数返回屏幕某一像素的颜色；
2. 首先设置相机矩阵
float3 eye = float3(0, 0, -30); float3 at = float3(0, 20, 0); matrix View = SetViewMatrix(eye, at); 我这里将相机矩阵计算放在了SetViewMatrix函数里，该函数使用eye、at以及默认沿Y轴向上的up向量来计算。
3. 沿像素投射光线
//set ray Ray ray; ray.dir = normalize(float3(xy, 1.732)); //y方向fov为60度 ray.pos = float3(0, 0, 0); ray.dir = mul(float4(ray.dir, 0.0), View).xyz; //变换射线位置和方向 ray.pos = mul(float4(ray.pos, 1.0), View).xyz; 其中Ray为包含pos、dir两个float3类型的结构体。首先构造出从原点发射的射线，然后使用View矩阵将射线变换至相机位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316fc4ddf74e8882f1dfec138fda685c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198a3acf766f206a60f6a344b96d7e88/" rel="bookmark">
			ping命令添加时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping 192.168.0.1 | awk '{ print $0"\t" strftime("%H:%M:%S",systime()) }'
PING 192.168.0.1 (10.37.190.10) 56(84) bytes of data. 16:24:25
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=0.693 ms 16:24:25
把信息输入到文本
ping 192.168.0.1 | awk '{ print $0"\t" strftime("%H:%M:%S",systime()) }' &gt; ping.log
把任务放到后台运行
ping 192.168.0.1 | awk '{ print $0"\t" strftime("%H:%M:%S",systime()) }' &gt; ping.log &amp;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89028cb9c75634a5aa2aeacf5ee4ca2a/" rel="bookmark">
			不使用Jsoup读取xml(处理内存不足问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读取xml时使用jsoup简单方便, 但是一旦xml过大, 使用jsoup就无法parse, 会出现java heap溢出
使用字符串的方式读取,可以按照标签选择读取范围
List&lt;String&gt; xxxList = new ArrayList&lt;String&gt;(); StringBuilder sb = new StringBuilder(); InputStreamReader reader = new InputStreamReader( new FileInputStream(xmlFile), "utf-8"); BufferedReader bufferedReader = new BufferedReader(reader); String line = ""; while ((line = bufferedReader.readLine()) != null) { sb.append(line + "\n"); if(line.contains("&lt;/xxx&gt;")){ xxxList.add(sb.toString()); sb.setLength(0); } } reader.close(); bufferedReader.close(); for (String xxx : xxxList) {	String tag = StringHelper.GetInnerText(xxx, "子标签名").trim(); } 每次内存只加载到&lt;xxx&gt;&lt;/xxx&gt;之间的内容, 解约内存
package CodingHelper; import java.net.URLDecoder; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89028cb9c75634a5aa2aeacf5ee4ca2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1741fd52acd683fca4918aabb68626ef/" rel="bookmark">
			Spring5：就这一次，搞定资源加载器之ServletContextResourceLoader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ServletContextResourceLoader继承自DefaultReourceLoader,并重写了getResourceByPath(String path)方法，该类的扩展功能是可以从Servlet上下文的根目录加载资源。
构造该加载器的时候需要ServletContext,示例如下：
@Controller public class LoginController { @RequestMapping(value="/index.html") public String loginPage(HttpServletRequest request) throws IOException { ResourceLoader resourceLoader=new ServletContextResourceLoader (request.getSession().getServletContext()); Resource resource=resourceLoader.getResource("/WEB-INF/test.xml"); System.out.println(resource.getInputStream()); return "index"; }	} 这段示例程序的意思是在／WEB-INF下存在test.xml文件，咱们用ServletContextResourceLoader加载它，
启动服务器，访问index.html,观察输出：
[INFO] Restart completed at Fri Jul 06 11:44:19 CST 2018 sun.nio.ch.ChannelInputStream@6a3bc065 成功。
接下来，咱们皮一下，传个相对路径进去，像这样：
Resource resource=resourceLoader.getResource("WEB-INF/test.xml"); 观察输出：
[INFO] Restart completed at Fri Jul 06 11:46:51 CST 2018 sun.nio.ch.ChannelInputStream@67203436 也是可以的，因为ServletContextResourceLoader是从上下文的根路径加载资源，上下文的根路径是webapp（在开发工具中比如eclipse中，指的就是webapp,当打成war包以后就是你项目打包的名字了．．．）,拼上WEB-INF/test.xml,没毛病,没毛病。
但是使用该加载器要注意一个问题，就是maven工程打包以后src/main/resources下的资源文件会被打到WEB-INF/classes下，所以WEB-INF/test.xml这种写法spring是加载不到的，因此路径要这么写才可以：
Resource resource=resourceLoader.getResource("WEB-INF/classes/test.xml");但是这不就是classpath？为何不用　classpath:test.xml呢，简单方便！以上纯属个人理解，如有错误，还望指正，谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbebba7b050e8a01b2a186d22e1f50cc/" rel="bookmark">
			Word中序号后面有空格怎么删除？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Word中进行文档编辑的时候，经常会遇到各种各样的问题，今天来和大家分享下怎么删除Word中序号后面多余的空格。
出现的问题界面如下： 重点内容 下面来讲解下操作步骤 1.首先，选中需要修改的文字，然后，右击，找到“段落”，操作界面如下所示。 点击“段落”之后。出现如下界面，找到“制表符”，进入下一个界面。 点击“制表符”之后，进入下图界面，找到图中标红的地方，即“默认制表位”，可以看到原来的默认制表位是2个字符，这也是为什么word中原来的数字序号后面有删除不掉空格的原因。如果想要删除空格，则将默认制表符更改为0即可。 4.修改成功之后，点击确定按钮，则可以看到原来序号后面多余的空白格消失了，如下图所示。 欢迎大家一起交流学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434ba42c95e18fee1af205f966e7acd9/" rel="bookmark">
			vue-i18n使用及踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用步骤 1. 安装 npm i vue-i18n 2. vue-cli下使用 //1. 引入 vue-i18n import Vue from 'vue' import VueI18n from 'vue-i18n' Vue.use(VueI18n) //2. 定义messages const messages = { en: { text: { hello: 'hello world' } }, zh: { text: { hello: '你好、世界' } } } //如果messages字段很多，可以写成文件，然后引入，例： import En from './en' import Zh from './zh' const messages = { en: En, zh: Zh } 其中en.js与 zh.js文件 //en.js export default{ text: { hello: 'hello world' } } //zh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/434ba42c95e18fee1af205f966e7acd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd45b76834443a0d2a5fa1b05dbd2e3/" rel="bookmark">
			《四川省建设工程安全文明施工费计价管理办法》的通知〔2017〕5（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		附件2
安全文明施工基本费费率表
1、工程在市区时
安全文明施工基本费费率表
2、工程在县城、镇时
安全文明施工基本费费率表
3、工程不在市区、县城、镇时
使用说明：
1.表中按工程所在位置分工程在市区时，工程在县城、镇时，工程不在市区、县城、镇时三种标准，其口径与该工程实际缴纳的税金中的城市维护建设税相同。
2.表中所列工程类型均为单独发包工程。
3.房屋建筑与装饰工程、仿古建筑工程、绿色建筑工程、装配式房屋建筑工程、构筑物工程包括未单独发包的与其配套的线路、管道、设备安装工程及室内外装饰装修工程。
4.单独装饰工程包括未单独发包的与其配套的工程。
5.单独通用安装工程包括未单独发包的与其配套的工程。
6.市政工程、综合管廊工程包括未单独发包的与其配套的工程以及单独发包的市政给水、燃气、水处理、垃圾处理机械设备安装、路灯工程，市政维修工程。
7.城市轨道交通工程（不包括单独发包的通信工程、信号工程、供电工程、智能与控制系统安装工程）包括未单独发包的与其配套的工程。
8.园林绿化、总平、运动场工程包括未单独发包的园路、园桥、亭廊等与其配套的工程。
9.房屋建筑维修与加固工程、拆除工程包括未单独发包的与其配套的工程。
10.单独土石方、单独地基处理与边坡支护工程、单独桩基工程包括未单独发包的与其配套的工程。
附件3
建设工程安全文明施工 措施评价及费率测定表 工程名称
发包人 承包人 监理人 四川省住房和城乡建设厅制
填 表 注 意 事 项
一、安全文明施工费的费率测定采取自愿的原则。工程竣工后，自愿申请安全文明施工费费率测定的承包人持施工安全监督机构确认的该工程《建设工程安全文明施工措施评价及费率测定表》和承包合同、城市维护建设税缴税证明复印件等到工程所在地建设工程安全文明施工费费率测定机构申请办理测定。本表可从《四川省工程造价信息网》下载，网址：www.sceci.net。
二、本表不得使用铅笔（或圆珠笔）填写，复印件须盖鲜章。
三、本表由承包人报送。本表封面单位名称需填写全称。第一页由承包人填写，发包人、监理人复核；第二页由发包人填写，承包人、监理人复核；第三页由施工安全监督机构、安全文明施工费费率测定机构分别填写。
1.承包范围指承包合同约定的承包范围；
2.工程特征简介应将承包项目的主要特征作描述，如建筑物高度、层数以及结构类型；道路工程的长度、宽度及面层用料；排水主管的长度、管径和材质等；
3.计税方式指该工程结算时采用的是简易计税法，还是一般计税法计税。
四、施工安全监督机构在填表时，应明确施工期间承包人是否发生一般及以上生产安全事故；应明确工地地面是否应做硬化处理，如该工程工地地面应做硬化处理，还应明确工地地面是否做硬化处理；应明确该工程是否按规定安装和使用视频监控系统以及是否按要求组织专门的安全隐患排查等。
五、安全文明施工费费率测定机构在费率测定时，应依据施工安全监督机构的最终综合评价得分，并查看该工程承包合同、城市维护建设税缴税证明，明确其适用定额及适用工程在市区时，工程在县城、镇时，工程不在市区、县城、镇时三种标准中的哪一种，再进行费率测定。
六、本表一式五份，发包人、承包人、监理人、施工安全监督机构、安全文明施工费费率测定机构各一份。如发包人有直接发包的专业工程纳入总包工程现场评价范围的，份数相应增加。
安全文明施工措施评价及费率测定表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117b0b534abef8901ec648c6956a6f97/" rel="bookmark">
			gradle无法获取‘.pom’文件（Android Studio3.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误内容： Could not GET ‘https://dl.google.com/dl/android/maven2/com/android/tools/build/gradle/3.1.3/gradle-3.1.3.pom ‘. Received status code 400 from server: Bad Request
解决方案： 1. 修改文件 build.gradle 将
buildscript { repositories { google() jcenter() } ... } 修改为：
buildscript { repositories { google() jcenter() maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } } ... } 将maven url配置为国内可访问的（如果已翻墙可以配置为https://maven.google.com）
2. 取消勾选 Disable embedded Maven repository 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40152f43d61f0d6d0d59393cea7d86c/" rel="bookmark">
			mac pip install MySQL-python IndexError: string index out of range
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac pip install MySQL-python IndexError: string index out of range Collecting mysql Downloading https://files.pythonhosted.org/packages/06/ef/c4efbf2a51fb46aba9be03a973638d9539c9ca10a5259b2cbb1a66133b2e/mysql-0.0.1.tar.gz Collecting MySQL-python (from mysql) Using cached https://files.pythonhosted.org/packages/a5/e9/51b544da85a36a68debe7a7091f068d802fc515a3a202652828c73453cad/MySQL-python-1.2.5.zip Complete output from command python setup.py egg_info: Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; File "/private/var/folders/zn/t8xxx4m149s9jqp1810ndrz80000gn/T/pip-install-oHMKPE/MySQL-python/setup.py", line 17, in &lt;module&gt; metadata, options = get_config() File "setup_posix.py", line 53, in get_config libraries = [ dequote(i[2:]) for i in libs if i.startswith(compiler_flag("l")) ] File "setup_posix.py", line 8, in dequote if s[0] in "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40152f43d61f0d6d0d59393cea7d86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b034c7e6514511047607507a2c95fe/" rel="bookmark">
			手机抓包爬取微信公众号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工具：
Charles.抓包工具
一、配置Charles
网上有大部分教程
下面是Charles万能KEY，反正我是能用的
Registered Name: https://zhile.io License Key: 48891cf209c6d32bf4 二、分析
打开charles抓到的包
分析url地址：
‘’https://mp.weixin.qq.com/mp/profile_ext?action=urlcheck&amp;uin=777&amp;key=777&amp;pass_ticket=cQfaZ0JaohZiPviQdAdcS0G70iubt9+p/NgqT20dsaij6ckUL3GfFgd5YlGouqvn&amp;appmsg_token=963_irw07v54QxifUVbUSDWmcsqzPyke2LbLpix7Xw~~&amp;a8scene=3&amp;session_us= ‘’
获取hearders：
返回的jsonText：
最主要的：
next_offser：下个爬取的offset
general_msg_list：内容
ret：说明获取到了这个页面
三：
开始爬取：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd8338d8d6dcf31d3676ac54ae7ab7e6/" rel="bookmark">
			详解 IntelliJ IDEA  配置和启动maven 项目 步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、从svn中检出web项目：
1、如果是maven项目：首先配置仓库
2、从svn中检出maven项目:
3、检查项目是否是maven项目，如果不是转化成maven，然后点击，更新jar
二、配置jdk(SDK) 1、点击 三、配置project Structure 项：很重要 1、 点击1 ，出现默认 project ，设置项目名 2 ，设置 jdk3, 设置版本 4 ，设置编译文件输出路径，注意路径尽量不要和项目路径相同 2、设置Modules 在3处写项目名；4为资源配置 把4加到5中；点击2 加spring和web
3、设置paths,仔细观察自己设置
4、设置dependences 自动加载 jar
5、设置spring 点击后 点击+ 选择3 保存
6、删除1
7、删除后
8、点击 web 设置项目web路径
9、设置libraries 默认 加载jar
10、点击artifacts 默认生成，删除红圈里面的内容，
11、删除后的页面，，然后点击+号
12、生成 重新点击 modules,点击create artifact 13、点击后，自动跳到artifact
14、在此页面点击项目名1；然后右键出现 点击put...,把jar包放到编译后lib文件中，非常重要
15、然后如图显示
四、配置tomcat 1、点击
2、添加tomcat,如图点击3
3、然后出现
4、在name 1出填写项目名，2出配置本地tomcat 3本地ip和端口
5、点击deployment
6、配置url
7、然后 server 显示路径，配置 on’update’ action;如下
8、加web包 很重要
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd8338d8d6dcf31d3676ac54ae7ab7e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0d23051960a70363304f500e99ab20/" rel="bookmark">
			(webpack打包css) You may need an appropriate loader to handle this file type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在使用require("./style.css");的时候,也就是想要把css文件也一并打包,但是webpack本身是不支持的,所以我们需要安装
npm install css-loader style-loader --save-dev 安装成功
接下来指定loader
把 require("./style.css");改为:
require("css-loader!./style.css");//引用这个页面的时候,先经过css-loader处理
require("style-loader!css-loader!./style.css");最后再重新打包就可以了 当然你也可以不在代码中添加style-loader!css-style!, 而是在打包过程中设置绑定依赖,如下命令
npx webpack a.js -o a.bundle.js --module-bind "css=style-loader!css-loader" --mode development 注意: 是双引号.不是单引号...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d2aad3566179fb879758a1328bc060d/" rel="bookmark">
			解决CAS 4.2.7 版本集群部署的各种问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期公司决定使用CAS来做单点登录，选择较为稳定的4.*版本,然而在集群部署时发现了不少问题。今天在这里总结一下，
一、部署条件 安装tomcat7 集群 （demo 两台） 安装redis 集群 （demo 单台） cas 4.2.7版本，单台CAS服务环境下登录、单点、退出皆运行正常 安装nginx ,配置tomcat集群负载均衡；其他负载均衡方式皆可 JDK1.7 二、集群部署问题 需解决集群环境下CAS服务集群session共享问题。 需解决集群环境下多个CAS服务共用一个ticket库。 需解决集群环境和springwebflow框架下CAS登录流程数据加密秘钥统一（或去除登录流程数据加密） 需解决集群环境和springwebflow框架下CAS登录票据加密秘钥统一（或去除票据数据加密） 三、操作部署 配置tomcat服务器session共享： DEMO简单配置： （1）nginx配置两个tomcat服务器,server1、server2 （2）分别向两个tomcat导入所用jar包：E:\*** \***tomcat7***\lib 目录下。 commons-pool-1.6.jar、jedis-2.0.0.jar、tomcat-redis-session-manager-1.2-tomcat-7-java-7.jar （3）分别修改tomcat配置文件：E:\*** \***tomcat7***\conf 目录下context.xml。 &lt;Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"/&gt; &lt;Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager" database="0" host="127.0.0.1" maxInactiveInterval="60" port="6379"/&gt; （4）为了方便测试可修改服务器欢迎页：E:\*** \***tomcat7***\webapps\ROOT\index.jsp。 可删除ROOT目录下文件、重新写一个简单的index.jsp、增加服务器标识、展示sessionId。 启动两台tomcat服务器和nginx。访问服务器欢迎页显示两台服务器sessionId一致即可。 2. CAS登录流程数据加密秘钥统一： （1） 简要说明： 流程数据默认采用对称加密方式（AES），无手动配置的情况下会默认生成随机encryptionKey和signKey， 那么集群条件下就会产生问题，当集群中某个CAS服务在生成加密数据后去另一台CAS服务去解密，由于签名秘钥 分别由不同服务器随机产生的解密过程中就会产生错误。 （2） 涉及代码说明： CAS4.2.7版本使用spring web flow框架，在执行登录流程调用loginFlowCipherBean对流程数据进行加密解密 时 使 用构造方法中默认注入的cipherExecutor子类 webflowCipherExecutor webflowCipherExecutor使用时调用了构造方法，在构造方法中又调用该类的父类BinaryCipherExecutor，此时若无手动配置， 构造参数的secretKeyEncryption和secretKeySigning则皆为空。在BinaryCipherExecutor的构造方法中又判断这两个构造参数，若参数 为空则会产生随机key值用来加密解密。 （3） 解决方法一： 在CAS的配置文件cas.properties中打开webflow.encryption.key、webflow.signing.key注释，并配置值，将KEY值固定。 那么如何获取生成固定KEY值呢，其实源码BinaryCipherExecutor类中已经告诉我们了。自己写个main方法，导入jose4j的jar包就可以随机 生成。 public static void main(String[] args ) { final OctetSequenceJsonWebKey octetKey = OctJwkGenerator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d2aad3566179fb879758a1328bc060d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f967689c064eb8d2af3c9fdfe6cfa5/" rel="bookmark">
			PSV破解流程&#43;软件游戏安装（最简单/最快的方法整理，已测支持3.65~3.68，理论上支持全系列版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载相关工具：
下载qcma https://codestation.github.io/qcma/
下载破解自动打包工具（懒人包，能够根据用户AIDKEY自动生成破解包）
新地址链接：https://pan.baidu.com/s/1gjwfsxupsxiCgCWNgC7F8Q 密码：1dco
（感谢天鷹葉尋原创，来自多玩PSV区：http://bbs.duowan.com/thread-46368649-1-1.html）
=====================
破解流程：
1.打开QCMA, 启动 PS Vita：内容管理气泡--&gt;PSV连接电脑--&gt;复制内容--&gt;个人电脑 -&gt; PS Vita , 选择 应用程序. QCMA会在电脑建立文件夹，类似这个结构，PS Vita/APP/xxxxxxxxxxxxxxxx
2.复制那些 xxxxxxxxxxxxxxxx ，也就是你的PSN的 AID，
3.使用网址http://cma.henkaku.xyz/ 输入你的AID,这里可以兑换你的密钥AID KEY
4.解压懒人包，右键打开懒人包中的“开始打包.bat”，文本编辑。找到 “换成你的密钥”的部分，一共4个。替换为你的AID KEY，保存后，双击运行bat。
5.运行成功后，复制h-encore内的PCSG90096 文件夹到电脑生成的PSV目录中，PS Vita/APP/xxxxxxxxxxxxxxxx/PCSG90096（失败的话请看是否是密钥原因）
6.电脑右下角，QCMA 右键 reflash cqma database，刷新数据库，然后用PSV的内容管理，复制--&gt;电脑 -&gt; PSV,将h-encore复制到PSV中。
7.PSV运行h-encore，然后运行第二项，第三项，安装vitashell，henkaku。（需联网）
PS:部分版本关机后，可能需要再次破解，直接运行7就OK。(据说3.65支持固话，3.68不支持，其他版本可自己测试)
success，破解完毕。
==================
PSV软件游戏安装（支持快速传输和批量传输）：
1.网上下载相关的vpk游戏软件。
2.打开QCMA，右下角右键setting，看到MUSIC文件夹的位置。
3.将.vpk改名成.mp3。
4.PSV打开内容管理了，复制内容，电脑-&gt;PSV，然后将MP3传输到电脑。
5.在PSV上打开设置，kenhaku设置，把“启用不安全自制软件”打勾
6.打开vitashell，在 ux0里面打开music，打开里面的文件夹，有上传的.mp3文件，改后缀名.vpk。
7.运行vpk，直接提醒安装。等待软件游戏安装完毕，完成。
success，软件游戏安装完毕。
===================主要参考资料： h-encore： https://github.com/TheOfficialFloW/h-encore qcma： https://codestation.github.io/qcma/ h-encore 相对简化的懒人版 以及 原版操作流程翻译： http://bbs.duowan.com/thread-46368649-1-1.html
PSV VPK游戏安装图文教程详解： http://www.paopaoche.net/tv/106621.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d851a143762467706f93c4a354ee3ad/" rel="bookmark">
			简单地使用webpack进行打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面的webpack是4.14.0版本的（当时我学的，更新太快了，现在5.10.0了），你学习的时候，用的是最新的，就不要往下看啦，官方文档已经更新教程了
这是我看5.10.0教程后，简单搭建的打包demo，可以参考。或者你也自己去官网看文档搭建webpack5.10.0
webpack5.10.0-demo
之前写的有些零散,现在一步步再重新写.记住: 如果你步骤对,但是始终没成功, 那么请不要烦心, 因为webpack版本4以上, 语义更加严格,命令有一些已经发生改变了,所以并不是你的问题!
一.确保已经安装了nodeJS之后.
二. 创建webpack-demo,我的是f盘下的,
2.然后进入这个文件夹:
3.进行初始化,一路都是选择默认(回车就可以):
查看初始化后的文件夹,里面只有一个json文件:
4. 接下来装webpack
npm install webpack --save-dev
安装完成:
查看项目下,发现已经:
5.然后用编译器打开当前项目,我的是HBuilder,如下图:
在这个文件下创建一个demo.js文件,并创建一个函数.
6.然后我们尝试进行打包,回到命令框
原本输入了 webpack demo.js demo.bundle.js,然后报错了
这是为什么呢?原因是我的webpack版本过高,原来的命令已经不适用了
如下查询版本号:
那应该如何解决?
更换打包命令为: webpack demo.js -o demo.bundle.js
其中 demo.dundle.js是打包后生成的文件的文件名
其中的一些参数值:
Version:webpack版本
time:这次打包所花费的时间
列表信息
Asset:打包这次生成的文件
Size:这次生成文件的大小
Chunks:这次打包的分块
chunk Names:这次打包的名称
接下来查看以下项目:
可以看到demo.js已经被打包为了demo.bundle.js文件,但是,这个并没有打包成功! 因为打包的时候没有出现红色的error了,但是还有黄色的警告.如下图.
黄色警告:是因为webpack4引入了模式,有开发模式,生产模式,无这三个状态
以及打开我们生成的文件,代码如下:
可以看到末尾并没有生成我们所打包的demo.js的信息.
黄色部分的警告的意思是,没有设置模式,有开发模式和生产模式两种,接下来,找到package.json.添加上"dev"和"build"这两个信息以及他们的值.
"scripts": {
"test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
"dev": "webpack --mode deveplopment"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d851a143762467706f93c4a354ee3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096fee44e00bc18e34412a7f0b005ade/" rel="bookmark">
			USART_ClearITPendingBith和 USART_ClearFlag的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起初 stm32 v3.5 库函数里面，对于串口USART有这样两个函数：
USART_ClearFlag()和USART_ClearITPendingBit()
查库函数定义，说一个是清除标志，一个是清除中断预处理位。然后我看了stm32f10x_usart.c文件，发现两个函数都操作的是USART-&gt;SR寄存器，但是这个寄存器只有一组标志位，没有什么中断预处理位。。
实际上两个函数实现的功能是一样的，都是清除相对应的标志位，只是标志位和中断位含义不一样，是标志位但 是不一定会产生中断。例如： #define USART_IT_TXE ((uint16_t)0x0727) #define USART_IT_TC ((uint16_t)0x0626) #define USART_IT_RXNE ((uint16_t)0x0525) 这是中断位，可以产生中断 #define USART_FLAG_TXE ((uint16_t)0x0080) #define USART_FLAG_TC ((uint16_t)0x0040) #define USART_FLAG_RXNE ((uint16_t)0x0020) 这是标志位，有的标志位不能产生中断 标志位在程序中可以作为判定条件，支持程序的运行，中断则是跳转到中断函数执行。两个函数实现的功能是一 样的，在中断程序中可以用两个中的任一个。我想区分两个函数是为了更清晰吧。 还有 #define USART_IT_TC ((uint16_t)0x0626) #define USART_FLAG_TC ((uint16_t)0x0040) 这两个数值不同是因为标志位只是为了清除标志位而设的，而中断位设置成这个值是因为在其他函数中这一位还 有其他用途。而且还要注意： void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG) { /* Check the parameters */ assert_param(IS_USART_ALL_PERIPH(USARTx)); assert_param(IS_USART_CLEAR_FLAG(USART_FLAG)); assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */ USARTx-&gt;SR = (uint16_t)~USART_FLAG; } 这一步 USARTx-&gt;SR = (uint16_t)~USART_FLAG; 似乎应该是 USARTx-&gt;SR &amp;= (uint16_t)~USART_FLAG; 其实状态位只能有硬件置位，软件只能读和清零，所以这样写也是正确的。 没有很明白，所以转在这里，等我哪天灵光乍现了，再来加上我的理解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096fee44e00bc18e34412a7f0b005ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb67a44c4e93dc4d01886d61c7b3f505/" rel="bookmark">
			在react中正确修改state
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，在react中可以通过this.state.{属性}的方式直接获取state，但当我们想要修改state的时候有许多的坑需要注意，以下 为三种常见的陷阱： 不能直接修改state。 组件直接修改state，并不会重新触发render。列如：
this.state.title='React'; 正确修改方式是：
this.setState({title:'React'}); state的更新是异步的 调用setState时，组件state并不会立即改变，而是把要修改的状态放入事件队列中，而react优化了真正的执行时机，并且出于本身性能原因，可能会将多次setState的状态修改合并成一次状态修改。因此不要依靠当前的state计算下一个state，因为当真正执行状态修改时，有时候依赖的this.state并不能保证是最新的state，因为react本身会把多次state合并成一次，这时this.state还是旧state，因此也不能依赖当前的props计算下一个状态，因为props的更新也是异步。如：对于react常用的列子中有一个点击加号数值增加一的操作，点击一次+，数量会加1，如果连续点击两次，还是会加1，这是在react合并修改为一次的情况下，相当与执行了如下代码：
Object.assign( previousState, {quantity:this.state.quantity+1}, {quantity:this.state.quantity+1}, ) 于是后面覆盖前面的操作，最终数值只加1，此时可以使用另一个函数作为参数的setState，这个函数有两个参数，第一个参数是本次组件修改前的状态，第二个参数是当前最新的props。
正确修改方式是：
this.setState((preState, props)=&gt;counter:preState.quantity+1) state的更新是一个合并的过程 当调用ssetState修改组件的状态时，只需要传入发生改变的state，而不是完整的state，因为组件state的更新时一个合并的过程，列如，一个组件的状态为：
this.state={ title:'React', content:'React is an wondeful JS library' } 注：当只需要修改title时，将修改的title传给setState即可：
this.setState({title:'ReactJs'}); react会合并最新的title到原来的状态，同时保留原来状态的content，最终合并state为：
this.state={ title:'ReactJs, content:''React is an wondeful Js library } 二，state与不可变对象 react官方把state当成不可变对象，一方面直接修改this.state,组件并不会重新render；另一方面，state中包含的所有状态都应该是不可变的对象，当state当中的某一个状态发生变化时，应该重新创建这个状态对象，而不是直接修改原来的state状态，那么当状态发生变化时，如何去创建新的状态呢，我们根据状态类型可以分为下面三种情况：
状态类型为不可变类型（number，string，bool，bull,undefined） 这种情况最简单，因为状态是不可变类型，所以直接给要修改的状态赋一个新值即可，列如下面我们要修改的count为number型，title（string）,success(bool)三个状态:
this.setState({ count:1, title:'React', success:true }) 状态类型为数组 假如有一个数组类型的状态books，当想books中增加一本书时，既可使用数组的concat方法或者es6的扩展语法(apread syntax)
方法一：使用preState，concat创建新数组 this.setState((preState)=&gt;books:preState.books.concat(['React Guide'])) 方法二：ES6 spread syntax this.setState(preState=&gt;books:[...preState,''React Guide]) 当我们从books中截取部分元素作为新状态时，可以用数组的slice方法：
this.setState(preState=&gt;books:preState.books.slice(1,3)) 当从books中过滤部分元素后，作为新状态时，可以使用filter方法:
this.setState(preState =&gt; { books: preState.books.filter(item =&gt; { return item !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb67a44c4e93dc4d01886d61c7b3f505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281a889289885397355bc0c531733097/" rel="bookmark">
			获取request里面所有的Parameter所有的请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public static Map&lt;String,Object&gt; showParams(HttpServletRequest request) { Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); Enumeration paramNames = request.getParameterNames(); while (paramNames.hasMoreElements()) { String paramName = (String) paramNames.nextElement(); String[] paramValues = request.getParameterValues(paramName); if (paramValues.length &gt;0) { String paramValue = paramValues[0]; if (paramValue.length() != 0) { map.put(paramName, paramValue); } } } Set&lt;Map.Entry&lt;String, Object&gt;&gt; set = map.entrySet(); logger.debug("=============================================================="); for (Map.Entry entry : set) { logger.debug(entry.getKey() + ":" + entry.getValue()); } logger.debug("============================================================="); return map; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6156d2feb5cd449777472b1914a5111/" rel="bookmark">
			win10、win7 脚本导证书到系统中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--------------------------------------------------------------------------------------------------------
可用的bat，仅测试了win10和win 7
@echo off
rem 注意：：：需要管理员权限，否则运行失败！！ rem 作用：将mongoose的根证书ca.crt导入当前计算机 rem 导入时windows会弹出警告框（ 缺点），提示用户是否信任该根证书，需要管理员权限 rem certmgr.exe /c /add C:\ca.crt /s root win10 ok，win 7没有 certmgr.exe rem 导入证书到可信任证书颁发者,C:\ca.crt 证书路径需根据实际情况更改 certutil -addstore root C:\ca.crt pause exit
-------------------------------------------------------------------------------------------------------------------
certmgr.exe 简介！
证书管理器工具管理证书、证书信任列表 (CTL) 和证书吊销列表 (CRL)。 certmgr [/add | /del | /put] [options] [/s[/r registryLocation]] [sourceStorename] [/s[/r registryLocation]] [destinationStorename] 参数 -------------------------------------------------------------------------------- 参数 说明 sourceStorename StoreFile 类型或系统存储区类型的输入证书存储区。 destinationStorename 输出证书存储区或文件。 选项 说明 /add 将证书、CTL 和 CRL 添加到证书存储区中。 /all 当与 /add 一起使用时添加所有项。当与 /del 一起使用时删除所有项。不带 /add 或 /delete 选项使用时显示所有项。/all 选项不能与 /put 一起使用。 /c 当与 /add 一起使用时添加证书。当与 /del 一起使用时删除证书。当与 /put 一起使用时保存证书。不带 /add、/delete 或 /put 选项使用时显示证书。 /CRL 添加或删除 CRL。不带 /add、/delete 或 /put 选项使用时显示 CRL。 /CTL 添加或删除 CTL。不带 /add、/delete 或 /put 选项使用时显示 CTL。 /delete 从指定的证书存储区中删除证书、CTL 和 CRL。 /e encodingType 指定证书编码类型。 /f dwFlags 指定存储区打开标志。这是传递到 CertOpenStore 的 dwFlags 参数。默认值为 CERT_SYSTEM_STORE_CURRENT_USER。仅当使用 /y 选项时才考虑此选项。 /h[elp] 显示该工具的命令语法和选项。 /n commonName String 指定要添加、删除或保存的证书的公共名。此选项只能用于证书，不能用于 CTL 或 CRL。 /put 将证书存储区中的 X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6156d2feb5cd449777472b1914a5111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaeb20c5bb93f51e862de6e38b7e3b51/" rel="bookmark">
			Java调用cmd 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public static boolean execCmd(String cmd) { Process proc = null; try { proc = Runtime.getRuntime().exec(cmd); proc.waitFor(); if (proc.waitFor() == 0) { // System.out.println("exit code:" + proc.exitValue()); if (proc.exitValue() == 0){ return true; } } } catch (Exception e) { e.printStackTrace(); return false; } finally { if(proc!=null){ proc.destroy(); } } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f16212ca1118d3c392e43fba2011268/" rel="bookmark">
			websphere服务器中（was)连接池属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WAS连接池属性 连接超时：
解释：连接超时是指，当对指定连接池进行请求时，池中没有可用连接（连接全部被使用，或者数据库请求超时），当请求时间到达指定之间时未响应，那麽这个时候就会产生超时异常，通过日志可以发现。指定间隔（以秒为单位）
结果:这个间隔时间过后连接请求超时并抛出 ConnectionWaitTimeoutException。
说明：达到连接特定连接池的最大值（最大连接数）或者数据库请求超时，等待是必需的。例如，如果连接超时设置为 300 并且达到了最大连接数，则池管理器为可用的物理连接等待 300 秒。如果物理连接在此时间内不是可用的，则池管理器抛出 ConnectionWaitTimeoutException。它通常不会重试 getConnection() 方法，因为如果必需更长的等待时间，您应该设置连接超时设置为更高的值。因此，如果应用程序捕捉了此异常，那么管理员应该复查应用程序的期待用法，并相应地调整连接池和数据库。
注：如果连接超时设置为 0，则只要必需，池管理器就会一直等待直到分配一个连接为止（这在连接数下降到最大连接数值以下时发生）。
如果最大连接数设置为 0，其允许无限多个物理连接数，则将忽略连接超时值。
连接超时设置：
数据类型： 整型 单位： 秒
缺省： 180 范围 ：0 到最大整数
好处：连接超时的设置，可以让我们发现哪些程序点有响应速度问题，可能是数据库查询语句问题，也有可能是程序逻辑死循环，再有可能就是数据库表结构需要优化，还有可能是最大连接数到达最大值。
未使用超时 解释：未使用的超时指池中的物理连接空闲未使用的时间间隔，每隔指定时间，系统会为连接标记，帮助收集时间在维护过程中进行关闭。未使用的超时应该小于实效超时时间，并且其以最小连接数为标准，当连接数超过最小连接数时，其才起作用。以秒为单位
说明：这个参数指定一个空闲连接在连接池中能够存活的最大时间。因为在连接池中保持连接会消耗系统资源，因此超过最小连接数的空闲连接会被定时清除。（注：当连接数没有超过最小连接数时，该项不起作用）未使用超时设为0时就不清除空闲连接。
数据类型： 整型 单位： 秒 缺省 ：1800
范围 ：0 到最大整数 好处：未使用超时的设置，帮助我们关闭不必要的空闲连接，释放系统资源，并且减少数据库开销。根据现场环境使用情况，我们可以根据系统访问频繁程序，来定制合理的未使用超时，如果过小，当访问频繁程度大时，总需要重新创建，如果过大，当访问频繁程度不大时，连接池又空闲占用过多。
最小连接数
解释：最小连接数是指当前连接池要保留的最小物理连接，其决定未使用超时维护机制的下限，连接池的创建不是根据最小连接数而特意创建，而是根据用户请求而创建，系统会一直维护最小的连接数目。
说明： 最小连接数使应用服务器保持一定数量的物理连接，利用应用服务器维护机制，合理分配服务器资源。当应用程序访问频繁，但访问人数少的情况下，最小连接数的合理配置，可以将有效的资源进行充分利用，满足特定应用需求。
数据类型： 整型 单位： 个 缺省 ：1
好处：最小连接数使应用服务器保持一定数量的物理连接，利用应用服务器维护机制，合理分配服务器资源。当应用程序访问频繁，但访问人数少的情况下，最小连接数的合理配置，可以将有效的资源进行充分利用，满足特定应用需求。
最大连接数
解释：最大连接数是指当前连接池中允许创建的最大物理连接数，当到达指定值后，将不允许创建物理连接。和连接超时相对应，当达到最大值后，连接请求将等待，直到池中有空闲连接为止，否则报连接超时错误（ConnectionWaitTimeoutException）。当使用集群机制时，会同时存在多个相同连接池，这个时候需要考虑最大数量的设置。
好处：最大连接数可以有效控制创建物理连接的数量，连接池的大小影响着服务器资源的占用情况，若连接池过大，则会长期占用服务器可利用资源，若连接池过小，无法满足现场环境应用高负载使用压力。最大连接数的设置应根据TPV观测数据进行合理配置。
数据类型： 整型 单位： 个 缺省 ：10
获得时间（收集时间）
解释：收集时间是连接池维护机制的核心，是指每次维护连接池的时间间隔。其有两个维护指标，分别为未使用超时和时效超时，其值应该小于两个指标中的任何一个。每一次维护周期中，连接池都会将连接池中超时的物理连接关闭，以减少系统占用资源。
说 明：连接池中的连接由一个定时运行的线程进行维护。这个参数就是指定运行连接池维护线程之间的间隔。例如，如果“获得时间”设置为60，则池维护线程每 60秒运行一次。当池维护线程运行时，它废弃所有未使用的连接（未使用时间长于“不使用超时”中指定的时间值），直到它到达最小连接数中指定的连接数。池维护线程还废弃所有活动时间长于“时效超时”中指定的时间值的连接。获得时间间隔还影响性能，因为更短的间隔意味着池维护线程将更频繁的运行并降低性能。要禁用池维持线程，“获得时间”设置为0，或“不使用超时”和“时效超时”都设置为 0。
好处：合理的收集时间设置，是帮助我们关闭不必要的连接，节省系统资源占用的有效途径。收集时间设置不易过大，因为时间间隔过长，会使很多未被使用的物理连接持续占用资源。若收集时间过小，则频繁的维护会带来很多系统开销，连接池的主要精力都放到了维护上。
时效超时
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f16212ca1118d3c392e43fba2011268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b307a9ad8358171fa4e906ae478066/" rel="bookmark">
			CentOS7的下载安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.CentOS下载
CentOS是免费版，推荐在官网上直接下载，
DVD ISO：普通光盘完整安装版镜像，可离线安装到计算机硬盘上，包含大量的常用软件，一般选择这种镜像类型即可。
Everything ISO：包含了完整安装版的内容，并对其进行补充，集成了所 有软件。
Minimal ISO：这个版本为精简版的镜像，可以安装一个基本的CentOS系 统，包含了可启动系统基本所需的最小安装包。
点击DVD ISO，进入下图
Actual Country 是当前所在国家资源区，任选链接即可直接下载到本地，约4.16G
2.CentOS安装
我是用VMware 12 安装的，下面是安装，打开VM主页
选择创建虚拟机
典型安装：VMwear会将主流的配置应用在虚拟机的操作系统上，对于新手来很友好。
自定义安装：自定义安装可以针对性的把一些资源加强，把不需要的资源移除。避免资源的浪费。
这里我选择自定义安装。下一步。
选择稍后安装，下一步
这个名称写自己喜欢的就可以，为了区分其他虚拟机，位置我改到了D盘
这里的处理器配置我没有改
桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。
NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。
仅主机：虚拟机与宿主机直接连起来
桥接与NAT模式访问互联网过程区别，如下图所示
这里默认选择了，后面会改成自定义
名称默认，下一步后如下，点击自定义硬件，取消不必要的硬件
选择打印机和声卡移除，此时打印机已经移除了，
点击关闭
点击完成，此时已经建好虚拟机。
配置镜像文件，选择刚才建好的虚拟机，右键--点击设置，
点击CD/DVD（IDE）项，然后右侧点击“使用ISO映像文件”，并浏览选择之前在官网上下载好的文件，
将网络适配器改为自定义VMnet8(NAT模式
点击确定。然后点击“开启虚拟机”，开始安装操作系统，
直接回车选择第一项，
以下语言直接continue,
选择时间
选择要安装的软件
然后选择installation destination，如下图我这里配置的是自动分区，点击done
返回后可以点击begin installation
设置密码，
可以再添加用户，
等待进度条完成后重启即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21da1a5a6d05d550f06ef75365d6e3d9/" rel="bookmark">
			Geotrellis学习笔记（一）——核密度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在geotrellis环境下成功运行了helloworld之后，我第一个尝试的核密度计算~整个过程还是挺艰难的。。。因为对scala非常地不熟，基本属于边写边学的状态T^T
嗯。。首先 核密度分析是什么？？？
官方文档里对核密度分析有一段这样的介绍：
Kernel density is one way to convert a set of points (an instance of vector data) into a raster. In this process, at every point in the point set, the contents of what is effectively a small Tile (called a Kernel) containing a predefined pattern are added to the grid cells surrounding the point in question (i.e., the kernel is centered on the tile cell containing the point and then added to the Tile).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21da1a5a6d05d550f06ef75365d6e3d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdfcc25c18da5d61fca891f8bf739a3/" rel="bookmark">
			算法导论：两个n位的二进制整数相加问题之python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 A = [1, 1, 0, 0, 1, 1, 0, 1] B = [1, 1, 1, 0, 1, 0, 1, 1] def sumbinary(A, B): A.reverse() B.reverse() C = [] temp = 0 length = len(A) for i in range(0, length): C.append(A[i] + B[i] + temp) if C[i] &gt; 1: C[i] %= 2 temp = 1 else: temp = 0 print(C[i]) C.append(temp) C.reverse() return C print(sumbinary(A, B)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b32760d122caac89122159f5bea8cde/" rel="bookmark">
			python导入cv2的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在命令行窗口输入python确定自己的版本，我用的是3.6.3
2.我原先就有numpy，就不需要下载了。（没有的自行下载）
3.下载对应版本的opencv，电脑64位的还是32位的要认真看好，下载地址：https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv，我使用的是opencv_python-3.4.1-cp36-cp36m-win_amd64.whl
4.把下载后的文件解压放在site-packages目录下，要是不知道site-packages目录。可以这样寻找：
&gt;&gt;&gt;import site; site.getsitepackages() 5.在import cv2 就可以使用了
6，有时需要重新启动下pycharm就可以使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80ab2cb62aea7b07b1db315e50437b8/" rel="bookmark">
			Webpack下多环境配置的思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于前后端分离的前端应用脱离了后端的支持，在单独开发前端应用时，页面调试时使用固定的开发环境地址还好，如果出现在本地开发时需要调试不同环境的远端API，或者需要将应用部署到不同环境的服务器上时，如果不将这些环境对应的服务器地址、环境专属变量等单独配置，也许每次切换环境都需要修改大量代码。网上关于这部分的资料较少，所以下面将以用vue-cli init命令生成的Vue/Webpack项目作为例子，介绍一下我当前正在使用的简单的多环境配置的思路。
1、理想中的多环境配置 在后端开发中，项目中不同环境对应的参数配置在不同的配置文件中。当需要打包基于Maven的Java项目时，通常只需要在打包命令的后面加上-P参数指定Profile环境，即可打包出对应环境的包，同理前端在使用webpack开发或者打包时如果也能这么做，就会方便很多。
/* maven常用打包命令 */ mvn clean package -P prod 复制代码 而在前端项目中，调试与打包命令vue-cli init已经为我们在package.json中生成好了。
/* /package.json */ "scripts": { "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js", "start": "npm run dev", "lint": "eslint --ext .js,.vue src", "build": "node build/build.js" } 复制代码 如果可以将这些命令改造成后端中类似的打包命令，就很方便了，例如：
/* 改造后的命令，只是打个比方，实际并不一定是这样 */ "scripts": { "start:dev": "npm run dev -P dev", "build:test": "node build/build.js -P test" } /* 命令行 */ $ npm run start:dev //本地调试，开发环境 $ npm run build:test //打包，测试环境 复制代码 所以首先需要解决的是如何把参数传递到调试/打包的脚本中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80ab2cb62aea7b07b1db315e50437b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79ef07e9b4690a4b3553ee68751e9e1a/" rel="bookmark">
			python创建多维数组的3种方式：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python创建多维数组的3种方式：
#coding=utf-8 import numpy as np #1 image =[[(col+1)*(row+1) for col in range(5)] for row in range(3)] a = np.array(image) print(a) #2 new_image =np.zeros((3,5)) #3 b = np.arange(12).reshape(3,4) print(b) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20aa4cafb3d5b960928ae312d25b87fc/" rel="bookmark">
			sys.stdout和print的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 sys.stdout的形式就是print的一种默认输出格式，等于print "%VALUE%"
print函数是对sys.stdout的高级封装，看下print函数的解释
Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. print是默认调用了sys.stdout.write()方法将输出打印到控制台
print 也可通过file参数将输出打印到其他文件中
f = open('test.txt','a') print('this is a test',file=f) 二 sys.stdout.write()输出不会自动换行，没有end,可用转义字符自行控制
/n 换行
/r 回车到本行首，可刷新输出
如用sys.stdout.write() 和\r实现自定义进度条
# -*- coding: utf-8 -*- from tqdm import tqdm import time import sys for i in tqdm(range(100)): time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20aa4cafb3d5b960928ae312d25b87fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53ab0ec66d7981f42933fc0ef377231/" rel="bookmark">
			kubernetes-一些常见的异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. kuber-apiserver: Getting a bunch of 404 when Initializers option is activated
# systemctl status kube-apiserver
Dec 19 12:43:30 rmxk8sctl01 kube-apiserver[7012]: I1219 12:43:30.665129 7012 wrap.go:42] GET /apis/admissionregistration.k8s.io/v1alpha1/initializerconfigurations: (167.967µs) 404 [[kube-apiserver/v1.8.5 (linux/amd64) kubernetes/cce11c6] 127.0.0.1:45026] 在kube-apiserver 增加参数：
--runtime-config=api/all=true,admissionregistration.k8s.io/v1alpha1=true # kubectl api-versions | grep admissionregistration admissionregistration.k8s.io/v1alpha1 admissionregistration.k8s.io/v1beta1 参考： https://github.com/kelseyhightower/kubernetes-the-hard-way/issues/276
2. etcdserver: Fix txn request 'took too long' warnings to use loggable request stringer
升级etcd后(3.1.7-&gt;3.3.7)：
systemctl status etcd -l 查看服务状态，有以下错误，但是并不影响kubernetes的正常运行：
6月 26 11:22:19 etcd-02 etcd[22147]: failed to send out heartbeat on time (exceeded the 100ms timeout for 274.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53ab0ec66d7981f42933fc0ef377231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb9e7932ad7c577e966e627a9dac51a/" rel="bookmark">
			$.ajax()方法详解及get查询案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery中的ajax方法参数总是记不住，这里记录一下。
1.url:
要求为String类型的参数，（默认为当前页地址）发送请求的地址。
2.type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。
3.timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。
4.async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
5.cache: 要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。
6.data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。
7.dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下： xml：返回XML文档，可用JQuery处理。 html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。 script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。 json：返回JSON数据。 jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。 text：返回纯文本字符串。
8.beforeSend： 要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。 function(XMLHttpRequest){ this; //调用本次ajax请求时传递的options参数 } 9.complete： 要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 function(XMLHttpRequest, textStatus){ this; //调用本次ajax请求时传递的options参数 }
10.success： 要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。 function(data, textStatus){ //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 }
11.error: 要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： function(XMLHttpRequest, textStatus, errorThrown){ //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 }
12.contentType： 要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。
13.dataFilter： 要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 function(data, type){ //返回处理后的数据 return data; }
14.dataFilter： 要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 function(data, type){ //返回处理后的数据 return data; }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb9e7932ad7c577e966e627a9dac51a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fc17ec7f8432c07fd9f3576f0bccc4/" rel="bookmark">
			Ubuntu下周期执行任务-cron和crontab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、cron和crontab命令详解 crontab 每分钟、每小时、每天、每周、每月、每年定时执行 crontab每5分钟执行一次
cron机制
cron可以让系统在指定的时间，去执行某个指定的工作，我们可以使用crontab指令来管理cron机制 crontab参数 -u:这个参数可以让我们去编辑其他人的crontab，如果没有加上这个参数的话就会开启自己的crontab crontab -u 使用者名称 -l:可以列出crontab的内容 -r:可以移除crontab -e:可以使用系统预设的编辑器，开启crontab -i:可以移除crontab，会跳出系统信息让你再次确定是否移除crontab crontab时间格式说明 minute(分)可以设置0-59分 hour（小时）可以设置0-23小时 day of month（日期）可以设置1-31号 month（月份）：可以设置1-12月 day of week（星期）：可以设置0-7星期几，其中0和7都代表星期天，或者我们也可以使用名称来表示星期天到星期一，例如sun表示星期天，mon表示星期一等等 crontab时间格式范例 1-3表示123 1-9/2表示13579 crontab范例 每五分钟执行 */5 * * * * 每小时执行 0 * * * * 每天执行 0 0 * * * 每周执行 0 0 * * 0 每月执行 0 0 1 * * 每年执行 0 0 1 1 * 设定cron的权限 /etc/cron.allow /etc/cron.deny 系统首先判断是否有cron.allow这个文件，如果有这个文件的话，系统会判断这个使用者有没有在cron.allow的名单里面，如果在名单里面的话，就可以使用cron机制。如果这个使用者没有在cron.allow名单里面的话，就不能使用cron机制。 如果系统里面没有cron.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fc17ec7f8432c07fd9f3576f0bccc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad9edeb6ebe57cac527852a9395ecb5/" rel="bookmark">
			macbook通过usb共享网络给iphone上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、把iphone通过USB插在macbook pro上，输入密码，信任手机
2、打开macbook pro上的设置-共享，共享端口为iphone usb，共享来源为以太网，点击共享
3、解锁手机屏幕，把wifi 流量等所有网络关闭，直接打开浏览器，输入百度，可以发现已经能上网
4、网速测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be62089e637f4a9ff855ed18c16ab712/" rel="bookmark">
			hive中的distribute by
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.背景 hive中有一个store表，字段分别是"商店所属人标识"(merid)，“商户余额(money)”，“商店名称（name）”。求每个法人下属的商店的余额按照降序排序。
//merid,money,name B 10 store_B_4 A 12 store_A_1 A 14 store_A_2 B 15 store_B_1 B 19 store_B_2 B 30 store_B_3 2.distribute by、sort by hive中（distribute by + “表中字段”）关键字控制map输出结果的分发,相同字段的map输出会发到一个reduce节点去处理。sort by为每一个reducer产生一个排序文件，他俩一般情况下会结合使用。
hive&gt; select * from store distribute by merid sort by money desc; 3.cluster by cluster by 相当于 distribute by 和sort by 的结合，默认只能是升序，以下两种写法查询结果相同
//cluster by hive&gt;select * from store cluster by merid; //distribute by,sort by hive&gt;select * from store distribute by merid sort by merid asc; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5131dd950f6f9625412f59c3e16aae6d/" rel="bookmark">
			KVM虚拟机随宿主机开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形化界面
必须在虚拟机关机情况下完成！！！
在KVM图形化管理工具中设置开机自启动
在Startvirtual machine on host boot up 前勾选即可
命令行界面
virsh autostart 虚拟机名 #设置随宿主机开机自启动
检查在/etc/libvirt/qemu/autostart/下会生成一个（虚拟机名.xml）文件
virsh autostart --disable 虚拟机名 #取消随宿主机开机自启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20ec7682798921b5118861be263a62f/" rel="bookmark">
			整合Spring和Struts时org.springframework.beans.factory.CannotLoadBeanClassException解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在整合Spring和Struts时碰到了这个警告：
org.springframework.beans.factory.CannotLoadBeanClassException: Cannot find class [org.test.service.impl.MyServiceImpl] for bean with name 'myService' defined in ServletContext resource [/WEB-INF/applicationContext.xml]; nested exception is java.lang.ClassNotFoundException: org.test.service.impl.MyServiceImpl
方法一：找了好多解决办法，只有一个行得通，只需要在web.xml中添加如下代码：&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext-*.xml,classpath*:applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt;
此方法来源于：http://www.aiuxian.com/article/p-431262.html
方法二：这个主要问题是，jdk没有编译出class文件造成的（可以D:\apache-tomcat-7.0.61\webapps\xxx(项目名字)\WEB-INF\classes下查看是否有class文件出现，如果没有就是这个原因，可以继续看下面方法，如果不是就不需要往下看了）。 1、查看jre是否是你安装jdk时的jre,如果不是改成如图
2、查看你的tomcat用的jre是否是安装jdk时的jre.如果不是改成如图
最后重启tomcat 。
成功！
此方法来源于：https://blog.csdn.net/u014745465/article/details/51142581
方法三：当使用方法一后，出现了另外一个问题 Caused by: Action class [XXX.XXX.action] not found 如何解决 其实本人这个问题使用方法一后，问题的根本并没有解决，如同方法二所说的情况一样jdk没有编译class文件造成的，在eclipse中存放的tomcat临时文件并没有编译的类文件，所以出现编译的类文件才是关键
解决方式：eclipse-&gt;project-&gt;clean...这里面clean...清除你要启动的项目，重新加载即可
此方法来源于：http://blog.csdn.net/tomcat_2014/article/details/46136133
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35091336508158a48cb6721f9965626c/" rel="bookmark">
			vue使用RouterLink出现Error in render: &#34;RangeError: Maximum call stack size exceeded&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用vue的时候，RouterLink出现Error in render的问题。 Maximum call stack size exceeded意思是，最大调用栈溢出，也就是说在某个地方出现了问题，而你又不知道问题出在哪里的时候，接着往下看。 可以看到问题出现在RouterLink。 可排查的方向：
1、检查是否有循环调用组件的行文，导致无限循环的操作，因为该组件是vue的内部组件，因此，不存在父调用子，子调用父的行为，自定义组件就需要注意了。不过仍需要注意循环无止境，也会出现这个问题。
2、在网上一直找不到这个同样的问题。由于服务器修改了路由为根目录下/wap下为前端项目，之前是直接根目录。我修改了路由的配置为，有一处忘记添加/wap的路由，导致出错了。在所有的路由下，都添加一下/wap，应该就可以处理次问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09e266544d1f741caa24dd034654075/" rel="bookmark">
			Emgu-WPF 激光雷达研究-绘制雷达图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件：Hokuyo URG04LX
环境：VS2017- win10- 64 Emgu_3.2.0.2682
语言：C# WPF 数据解析参考：
https://sourceforge.net/p/urgnetwork/wiki/Home/ https://github.com/bqhdev/urg04lx_data_decoder
http://sourceforge.net/projects/urgnetwork/files/urg_cs_sample/Urg_cs_sample.zip/download
解析后数据：
数据解析封装：
public class SensorData { public string DecodeStr { get; set; } public double TimeStamp { get; set; } public List&lt;double&gt; Distances { get; set; } public int Index { get; set; } } public class UrgSensor { //private bool IsUseSampleDatas_FromDistances = false; //private bool IsUseSampleDatas_FromFiles = true; private bool IsUseSampleDatas_FromDistances = true; private bool IsUseSampleDatas_FromFiles = false; // 每帧数据从离线文件中获取 --- 提前记录了某一时间段实时数据，离线测试使用 private bool IsForceUseMetaDatas = false; private List&lt;string&gt; SampleDatas; private int Index = -1; #region Sample Datas From Distance List Excute If Sensor Exception // 解析后数据 - 用于Emgu离线绘图测试 private void InitSampleDatas() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09e266544d1f741caa24dd034654075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d03b1e313d368249d36fa506945c2f3/" rel="bookmark">
			WPF特效-粒子动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF实现泡泡龙小游戏效果。
/// -Ball to Ball Collision - Detection and Handling
/// http://stackoverflow.com/questions/345838/ball-to-ball-collision-detection-and-handling
/// -Introduction - The World Of Bouncing Balls: /// http://www.ntu.edu.sg/home/ehchua/programming/java/J8a_GameIntro-BouncingBalls.html
/// -How to: Render on a Per Frame Interval Using CompositionTarget /// http://msdn.microsoft.com/en-us/library/ms748838.aspx
/// -The Physics of an Elastic Collision (Part 2): /// http://www.director-online.com/buildArticle.php?id=532
/// -Elastic collision: /// http://en.wikipedia.org/wiki/Elastic_collision
/// -Determine where two circles intersect in C# /// http://blog.csharphelper.com/2010/03/29/determine-where-two-
///https://segmentfault.com/a/1190000012890618
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94bd95399e021bafe243cda7e8373e9a/" rel="bookmark">
			Oracle12C 用户创建、修改、授权、删除、登录等操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.以系统用户命令行登录： sqlplus sys/sys as sysdba; 2. 确认选择CDB select name,cdb from v$database; col pdb_name for a30 select pdb_id,pdb_name,dbid,status,creation_scn from dba_pdbs; select con_id,dbid,NAME,OPEN_MODE from v$pdbs; CON_ID DBID NAME OPEN_MODE ---------- ---------- ------------------------------ ---------- 2 964253477 PDB$SEED READ ONLY 3 3329151580 ORCLPDB MOUNTED在这里补充一下：orace12c 中PDB数据库 默认为ORACLPDB ,用户可以根据自己需求， 再次创建一个或多个PDB数据库表空间，数据库名称不重复即可，如下操作。 找到并点击Database Configurantion Assistant 然后下一步：
按照步骤依次操作即可。
3.创建使用者为test SQL&gt; create user c##test identified by test; SQL&gt; alter session set container=PDBORCL; 会话已更改。 SQL&gt; show con_name; CON_NAME ------------------------------ PDBORCL 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94bd95399e021bafe243cda7e8373e9a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/250/">«</a>
	<span class="pagination__item pagination__item--current">251/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/252/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>