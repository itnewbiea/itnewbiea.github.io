<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf63b75c17a3547d016fc347806b764/" rel="bookmark">
			亲测-windows系统安装Tensorflow2.0版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用anaconda在windows系统中安装Tensorflow。
Anaconda的安装与使用：
（1）官网
https://www.anaconda.com/distribution/
（2）清华大学软件镜像站（https://mirrors.tuna.tsinghua.edu.cn）
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
安装好之后，在anaconda navigator里面【Home】中application on，是运行的环境
【Environments】中base(root)点击右侧三角行，进入terminal终端，输入conda info，到此，anaconda安装结束。
（1）包管理
安装、更新、卸载工具包；
安装时能自动安装相应的依赖包；
conda命令
安装包：conda insatll &lt;package_names&gt;
卸载包：conda remove &lt;package_names&gt;
更新包：conda update &lt;package_names&gt;
模糊查询：conda search pip命令 当conda命令下载不了python包时，可以与pip交互使用； 安装包：pip install &lt;package_names&gt; 卸载包：pip uninstall &lt;package_names&gt; （2）环境管理 在同一台机器上创建几个相互独立的Python开发环境； 隔离不同项目所需的不同版本的工具包； 防止版本的冲突； conda环境管理 创建环境：conda create --name &lt;env_name&gt; &lt;package_names&gt; 激活环境：activate &lt;env_name&gt; 推出环境：deactivate 删除环境：conda remove --name &lt;env_name&gt; --all 查看当前创建环境中列表清单：conda env list Tensorflow2.0的安装
在开始安装之前，我们可以使用镜像安装，这样速度会比较快；
anaconda镜像使用帮助：
https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/
tuna提供了anaconda仓库的镜像：
1）运行
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
或者
conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baf63b75c17a3547d016fc347806b764/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb641339f1f78a33dc9397d0c0dd50b/" rel="bookmark">
			Promise.all和Promise.race的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const f1 = new Promise(function (resolve, reject) { resolve('佳佳') }) const f2 = new Promise(function (resolve, reject) { reject('要') }) const f3 = new Promise(function (resolve, reject) { resolve('自律') }) const f4 = Promise.all([f1, f2, f3]) f4.then(function (value) { console.log(value, '..成功') }).catch(function (error) { console.log(error, '...失败') // 要 }) // 若f2 返回成功，那么这个value就返回一个数组["wo", "ai", "ni"],但是f2返回的值被拒绝了，那么方法所返回的 Promise 就会立刻被 拒绝，而不必等待其他的 Promise 结束 const f5 = new Promise(function (resolve, reject) { setTimeout(() =&gt; { resolve('佳佳') },100) }) const f6 = new Promise(function (resolve, reject) { reject('要') }) const f7 = new Promise(function (resolve, reject) { resolve('自律') }) const f8 = Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb641339f1f78a33dc9397d0c0dd50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a80038d4ed785c33204b1a2602d412/" rel="bookmark">
			[护网杯 2018]easy_tornado 1（STTI模板注入&#43;Tornado的secret_cookie）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为个人刷题记录，不记录完整步骤，主要记录比较有感触的知识点
SSTI注入 参考：SSTI完全学习
SSTI就是服务器端模板注入(Server-Side Template Injection)，也给出了一个注入的概念。
常见的注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。sql注入已经出世很多年了，对于sql注入的概念和原理很多人应该是相当清楚了，SSTI也是注入类的漏洞，其成因其实是可以类比于sql注入的。
sql注入是从用户获得一个输入，然后又后端脚本语言进行数据库查询，所以可以利用输入来拼接我们想要的sql语句，当然现在的sql注入防范做得已经很好了，然而随之而来的是更多的漏洞。
SSTI也是获取了一个输入，然后再后端的渲染处理上进行了语句的拼接，然后执行。当然还是和sql注入有所不同的，SSTI利用的是现在的网站模板引擎(下面会提到)，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。
现在网上提起的比较多的是Python的网站。
题目 再来看题，找到了SSTI注入点为
问题是为什么是{{}}（双花括号吖）
不懂就查，官方文档这样说明：
Template expressions are surrounded by double curly braces: {{ … }}. The contents may be any python expression, which will be escaped according to the current autoescape setting and inserted into the output. Other template directives use {% %}
To comment out a section so that it is omitted from the output, surround it with {# … #}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a80038d4ed785c33204b1a2602d412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c6a9943df49415103df26255ada93c/" rel="bookmark">
			QT : 判断文件是否存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;QFileInfo&gt; #include &lt;QMessageBox&gt; QFileInfo file(FILE_PATH); if(file.exists() == false) { QMessageBox::about(nullptr, "error", "Missing config file!"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6be8b3c3f7cd13dd1306b550e9e50e8/" rel="bookmark">
			Android DNS cache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是DNS？ DNS 是域名系统 (Domain
Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。简单说，DNS就是
域名（我们平时使用的网址，如www.baidu.com等）到 ip 地址的 服务器。
因为计算机访问对方服务器时，只能识别对方服务器的ip地址，所以当我们输入网址时，就需要先到DNS服务器查询对应的IP地址，然后再访问。
DNS缓存 DNS访问是个比较耗时的操作，所以android会把查询到的结果缓存起来，下次查询的时候，就可以直接从缓存中获取，而不需要DNS查询。
DNS解析缓存分为两种：查询成功的缓存，查询失败的缓存（如查询域名不存在等） 。
android 系统对DNS缓存 有两个地方，一个是虚拟机层 ， 一个是 框架层 java.net.InetAddress
类内部维护了一个缓存。
当通过域名解析IP地址时，通过 java.net.InetAddress类来调用相应的方法。它会先查看自身缓存里有没有，木有的话会看虚拟机层有木有缓存，还木有的话才会到DNS服务器查询。
控制DNS缓存 有些情况下，我们不能使用DNS缓存，如服务器IP地址变化等。
虚拟机层默认使用的缓存策略是
成功的查询永久缓存(这里的永久缓存是指整个虚拟机生命周期，虚拟机重启，缓存就没有了) ，
失败的查询只缓存10s。
我们可以设置虚拟机的DNS缓存时间TTL (time-to-live 生命周期):
Security.setProperty("networkaddress.cache.ttl", String.valueOf(0)); Security.setProperty("networkaddress.cache.negative.ttl", String.valueOf(0)); "networkaddress.cache.ttl"表示查询成功的缓存，"networkaddress.cache.negative.ttl"表示查询失败的缓存。第二个参数表示缓存有效时间，单位是秒。
时间 -1 表示永久缓存，0 表示从不缓存，其他表示缓存具体有效时间。
java.net.InetAddress内部的缓存我们没有办法控制。4.0以前是永久缓存，4.0以后是只缓存2s。也就是说4.0以前通过设置虚拟机TTL没有用，因为java.net.InetAddress永久缓存了。
在控制DNS缓存时有两点需要注意：
1. 可以根据实际情况来设置networkaddress.cache.ttl属性的值。一般将这个属性的值设为-1.但如果访问的是动态映射的域名（如使用动态域名服务将域名映射成ADSL的动态IP）， 就可能产生IP地址变化后，客户端得到的还是原来的IP地址的情况。 2. 在设置networkaddress.cache.negative.ttl属性值时最好不要将它设为-1，否则如果一个域名因为暂时的故障而无法访问，那么程序再次访问这个域名时，即使这个域名恢复正常，程序也无法再访问这个域名了。除非重新运行程序。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec6f7aab9ad26c37fedf365ad386f22/" rel="bookmark">
			Spring上下文(ApplicationContext)理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Spring应用上下文呢？？？ 什么是应用上下文呢，应用上下文即是Spring容器的一种抽象化表述；而我们常见的ApplicationContext本质上说就是一个维护Bean定义以及对象之间协作关系的高级接口。Spring的核心是容器，而容器并不唯一，框架本身就提供了很多个容器的实现，大概分为两种类型：一种是不常用的BeanFactory，这是最简单的容器，只能提供基本的DI功能；还有一种就是继承了BeanFactory后派生而来的应用上下文，其抽象接口也就是上面提到的的ApplicationContext，它能提供更多企业级的服务，例如解析配置文本信息等等，这也是应用上下文实例对象最常见的应用场景。有了上下文对象，我们就能向容器注册需要Spring管理的对象了。对于上下文抽象接口，Spring也为我们提供了多种类型的容器实现，供我们在不同的应用场景选择——
① AnnotationConfigApplicationContext:从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式；
② ClassPathXmlApplicationContext：从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式；
③ FileSystemXmlApplicationContext:从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件；
④ AnnotationConfigWebApplicationContext:专门为web应用准备的，适用于注解方式；
⑤ XmlWebApplicationContext:从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。
备注: 通过.class文件获取bean的方法:
public abstract class AbstractCreateRoomHandler implements ApplicationContextAware { //存放商家和处理器的映射关系 private static final Map&lt;Integer, Class&lt;? extends AbstractCreateRoomHandler&gt;&gt; TYPE_HANDLER = new HashMap&lt;&gt;(); private static ApplicationContext applicationContext; static { TYPE_HANDLER.put(BusinessCodeEnum.TUSE.getBusinessCode(), TuSeCreateRoomHandler.class); //todo 新的商家类型添加到此处 } public static AbstractCreateRoomHandler getCreateRoomHandler(Integer productType) { Class&lt;? extends AbstractCreateRoomHandler&gt; clazz = TYPE_HANDLER.getOrDefault(productType, TuSeCreateRoomHandler.class); return applicationContext.getBean(clazz); } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } 延伸: 获取bean的集中方法:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f537039f7c7d3a406c2808f3d13a25/" rel="bookmark">
			Duplicate keys detected: ‘xxxx‘. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Vue 项目中，控制台报如下错误：
Duplicate keys detected: xxxxx'. This may cause an update error. 这是因为，通过 v-for 遍历的数据，有相同的 key，导致的错误提示。
所以解决办法就是寻找哪个地方数据重复了，有可能是两个地方相同遍历使用了相同的 key，这个解决办法可以添加个标识：
`${item.id}-1` `${item.id}-2` 有可能是数组中存在两个一模一样的数据，需要看看代码写没写错。
如果没有马上找到问题所在，可以通过上面提示的 xxxx 这个 key 来寻找哪条数据的 key 是这个。
最后一个提示：在某些情况下，可以看看接口返回的数据有没有重复的！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a064d0220fb14a12f3597bbfa2a9ac/" rel="bookmark">
			Python 爬取前程无忧最新招聘数据 matplotlib数据分析与可视化！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用python爬取在前程无忧网搜索python关键字出现的最新的招聘数据，保存到本地Excel，进行数据查看和预处理，然后利用matplotlib进行数据分析和可视化。
1. 爬取数据 目标url：https://www.51job.com/
在前程无忧网输入关键字python，搜索有关的岗位数据。翻页查看这些招聘岗位信息，可以发现url翻页的规律。
检查网页源代码，可以找到想要提取的数据。
爬虫代码如下：
import asyncio import aiohttp import logging import datetime import re import pandas as pd logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s: %(message)s') start = datetime.datetime.now() class Spider(object): def __init__(self): self.semaphore = asyncio.Semaphore(6) self.headers = { 'Connection': 'Keep-Alive', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Host': 'search.51job.com', 'Referer': 'https://search.51job.com/list/000000,000000,0000,00,9,99,Python,2,1.html?lang=c&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;ord_field=0&amp;dibiaoid=0&amp;line=&amp;welfare=', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24' } async def scrape(self, url): async with self.semaphore: session = aiohttp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a064d0220fb14a12f3597bbfa2a9ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edea901b45cb8a7b559ffee98d267b93/" rel="bookmark">
			【BUG】shell命令过长用\换行报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sh脚本在windos上编写好，上传到linux服务器会报错（sh脚本包含换行符会报错，不包含不报错）。操作系统改变导致格式错误。使用dos2unix转化sh文件即可正常执行。
如run.sh文件
python run_classify.py \ --model_type bert \ --model_name_or_path /data/sfang/BertPretrainedModel/torch/chinese_electra_base_discriminator_pytorch/ \ --do_train \ --do_test \ --data_dir ./data/data \ --output_dir ./model_roberta \ --max_seq_length 256 直接执行会报错：
usage: run_classify.py [-h] --data_dir DATA_DIR --model_type MODEL_TYPE --model_name_or_path MODEL_NAME_OR_PATH [--meta_path META_PATH] --output_dir OUTPUT_DIR [--epochs EPOCHS] [--patience PATIENCE] [--batch_size BATCH_SIZE] [--learning_rate LEARNING_RATE] [--max_seq_length MAX_SEQ_LENGTH] [--do_train] [--do_test] [--do_predict] [--device DEVICE] run_classify.py: error: the following arguments are required: --data_dir, --model_type, --model_name_or_path, --output_dir run_electra.sh:行2: --model_type: 未找到命令 run_electra.sh:行3: --model_name_or_path: 未找到命令 run_electra.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edea901b45cb8a7b559ffee98d267b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f28699d71ad6f7c4407eec3fc5bf4fd/" rel="bookmark">
			必读！信息抽取(Information Extraction)【关系抽取】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源: AINLPer
微信公众号（每日给你好看…）
编辑: ShuYini
校稿: ShuYini
时间: 2020-08-11
引言 信息抽取（information extraction），简称IE，即从自然语言文本中，抽取出特定的事件或事实信息，帮助我们将海量内容自动分类、提取和重构。这些信息通常包括实体（entity）、关系（relation）、事件（event）。 例如从新闻中抽取时间、地点、关键人物，或者从技术文档中抽取产品名称、开发时间、性能指标等。能从自然语言中抽取用户感兴趣的事实信息，无论是在知识图谱、信息检索、问答系统还是在情感分析、文本挖掘中，信息抽取都有广泛应用。
信息抽取主要包括三个子任务：
关系抽取：通常我们说的三元组(triple)抽取，主要用于抽取实体间的关系。
实体抽取与链指：也就是命名实体识别。
事件抽取：相当于一种多元关系的抽取。
关系抽取（RE）是为了抽取文本中包含的关系，是信息抽取（IE）的重要组成部分。主要负责从无结构文本中识别出实体，并抽取实体之间的语义关系，被广泛用在信息检索、问答系统中。本文从关系抽取的基本概念出发，依据不同的视角对关系抽取方法进行了类别划分；最后分享了基于深度学习的关系抽取方法常用的数据集，并总结出基于深度学习的关系抽取框架。
关系抽取基本概念 完整的关系抽取包括实体抽取和关系分类两个子过程。实体抽取子过程也就是命名实体识别，对句子中的实体进行检测和分类；关系分类子过程对给定句子中两个实体之间的语义关系进行判断，属于多类别分类问题。
例如，对于句子“青岛坐落于山东省的东部”，实体抽取子过程检测出这句话具有“青岛”和“山东”两个实体。关系分类子过程检测出这句话中“青岛”和“山东”两个实体具有“坐落于”关系而不是“出生于”关系。在关系抽取过程中，多数方法默认实体信息是给定的，那么关系抽取就可以看作是分类问题。
关系抽取方法分类（基于深度学习方法） 目前，常用的关系抽取方法有５类，分别是基于模式匹配、基于词典驱动、基于机器学习、基于本体和混合的方法。基于模式匹配和词典驱动的方法依靠人工制定规则，耗时耗力，而且可移植性较差，基于本体的方法构造比较复杂，理论尚不成熟。基于机器学习的方法以自然语言处理技术为基础，结合统计语言模型进行关系抽取，方法相对简单，并具有不错的性能，成为当下关系抽取的主流方法，下文提到的关系抽取方法均为机器学习的方法。
关于信息关系抽取，可以从训练数据的标记程度、使用的机器学习方法、是否同时进行实体抽取和关系分类子过程以及是否限定关系抽取领域和关系专制四个角度对机器学习的关系抽取方法进行分类。
根据训练数据的标记程度分类 根据训练数据的标记程度可以将关系抽取方法分为有监督、半监督和无监督三类。
有监督学习，处理的基本单位是包含特定实体对的句子，每一个句子都有类别标注。优点：取能够有效利用样本的标记信息，准确率和召回率都比较高。缺点：需要大量的人工标记训练语料，代价较高。
半监督学习，句子作为训练数据的基本单位，只有部分是有类别标注的。此类方法让学习器不依赖外界交互，自动地利用未标记样本来提升学习性能。
无监督学习，完全不需要对训练数据进行标注，此类方法包含实体对标记、关系聚类和关系词选择三个过程。
根据使用的机器学习方法分类 根据使用机器学习方法不同，可以将关系抽取划分为三类：基于特征向量的方法、基于核函数的方法以及基于神经网络的方法。
基于特征向量的方法，通过从包含特定实体对的句子中提取出语义特征，构造特征向量，然后通过使用支持向量机、最大熵、条件随机场等模型进行关系抽取。
基于核函数的方法，其重点是巧妙地设计核函数来计算不同关系实例特定表示之间的相似度。缺点：而如何设计核函数需要大量的人类工作，不适用于大规模语料上的关系抽取任务。
基于神经网络的方法，通过构造不同的神经网络模型来自动学习句子的特征，减少了复杂的特征工程以及领域专家知识，具有很强的泛化能力。
根据是否同时进行实体抽取和关系分类子过程进行分类 根据是否在同一个模型里开展实体抽取和关系分类，可以将关系抽取方法分为流水线（pipeline）学习和联合（joint）学习两种。
流水线学习是指先对输入的句子进行实体抽取，将识别出的实体分别组合，然后再进行关系分类，这两个子过程是前后串联的，完全分离。
联合学习是指在一个模型中实现实体抽取和关系分类子过程。该方法通过使两个子过程共享网络底层参数以及设计特定的标记策略来解决上述问题，其中使用特定的标记策略可以看作是一种序列标注问题。
根据是否限定关系抽取领域和关系类别分类 根据是否限定抽取领域和关系类别，关系抽取方法可以划分为预定义抽取和开放域抽取两类。
预定义关系抽取是指在一个或者多个固定领域内对实体间关系进行抽取，语料结构单一，这些领域内的目标关系类型也是预先定义的。
开放域关系抽取不限定领域的范围和关系的类别。现阶段，基于深度学习的关系抽取研究集中于预定义关系抽取。
关系信息抽取常用数据集 基于深度学习的关系抽取方法常用的数据集有ACE关系抽取任务数据集、SemEval2010 Task 8数据集、NYT2010数据集等.
ACE关系抽取任务数据集：ACE2005关系抽取数据集包含599篇与新闻和邮件相关的文档，其数据集内包含7大类25小类关系。
SemEval2010 Task 8数据集：该数据集包含９种关系类型，分别是Compoent-Whole、Instrument-Agency、Member-Collection、Cause-Effect、Entity-Destination、Content-Container、Message-Topic、Product-Producer和Entity-Origin。 考虑到实体之间关系的方向以及不属于前面９种关系的“Other”关系，共生成19类实体关系。其中训练数据 8000个，测试数据2717个。
NYT2010数据集是Riedel等人在2010年将Freebase知识库中的知识“三元组”对齐到“纽约时报”新闻中得到的训练数据。该数据集中，数据的单位是句包，一个句包由包含该实体对的若干句子构成。其中，训练数据集从《纽约时报》2005—2006年语料库中获取，测试集从2007年语料库中获取。
面向关系抽取的深度学习模型构建 基于深度学习的关系抽取方法模型构建的重点在于利用不同神经网络的特点来抽取样本的特征，以学习样本的向量表示。在学习过程中，根据所用的神经网络基本结构的不同，可将基于深度学习的关系抽取方法分为基于递归神经网络（recursive neural network,Rec-NN）的方法、基于卷积神经网络的方法、基于循环神经网络（recurrent net neural net-work,RNN）的方法和基于混合网络模型的方法四类。
基于递归神经网络的关系抽取 基于递归神经网络的关系抽取方法首先利用自然语言处理工具对句子进行处理，构建特定的二叉树，然后解析树上所有的相邻子节点，以特定的语义顺序将其组合成一个父节点，如下图３所示。这个过程递归进行，最终计算出整个句子的向量表示。向量计算过程可以看作是将句子进行一个特征抽取过程，该方法对所有的邻接点采用相同的操作。
基于卷积神经网络的关系抽取 基于卷积神经网络的关系抽取方法接受一个特定的向量矩阵作为输入，通过卷积层和池化层的操作将输入转换成一个固定长度的向量，并使用其他特征进行语义信息汇总，再进行抽取。基于卷积神经网络的关系抽取方法框架如图下５所示，除了输入层、数据表示层之外，还有窗口层、卷积层、池化层、语义信息汇总层、分类层。
基于循环神经网络的关系抽取 由于句子含义跟单词出现的顺序是相关的，因此关系抽取可以看作是一个时序学习任务，可以使用循环神经网络来建模。
基于循环神经网络的方法在模型设计上使用不同的循环神经网络来获取句子信息，然后对每个时刻的隐状态输出进行组合，在句子层级学习有效特征。在关系抽取问题中，对每一个输入，关系的标记一般只在序列的最后得到。Zhang等首次使用双向循环神经网络来进行关系抽取，提出了BRNN模型。如下图７ 所示，在双向循环神经网络中某一时刻的输出不仅依赖序列中之前的输入，也依赖于后续的输入。
基于混合网络模型的关系抽取 为了更好地抽取句子中的特征，研究人员使用递归神经网络、卷积神经网络与循环神经网络３种网络及其他机器学习方法进行组合建模来进行关系抽取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f28699d71ad6f7c4407eec3fc5bf4fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69beb63665d8ae14659f5de5f10fb9f5/" rel="bookmark">
			微信公众号jssdk ios第一次签名失败，刷新后签名成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因：ios打开页面，整个项目的签名，只需要签名一次
所以需要判系统；
ios端只需要在项目第一次打开调用签名，所用到的JSSDK接口，都写在 jsApiList里，具体接口执行方法，放在需要执行的时候。
export function shareSignature() { return new Promise(resolve =&gt; { let params = { url: window.location.href, appId: localStorage.getItem('appId') }; wxApi.shareSignature(params, res =&gt; { if (res.succeed) { wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: res.data.appid, // 必填，公众号的唯一标识 timestamp: res.data.timestamp, // 必填，生成签名的时间戳 nonceStr: res.data.nonceStr, // 必填，生成签名的随机串 signature: res.data.signature, // 必填，签名 jsApiList: [ "chooseImage", "uploadImage", "downloadImage", "onMenuShareTimeline", "onMenuShareAppMessage" ] // 必填，需要使用的JS接口列表 }); resolve(); } }); }); } router.beforeEach((to, from, next) =&gt; { if (isIOS()) { if (from.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69beb63665d8ae14659f5de5f10fb9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac16313d6ae46d66843ea7e54ebff23/" rel="bookmark">
			Linux文本过滤某列不为空的值并写入新文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		awk -F"\t" '$3!=""' file1 &gt;&gt; newfile 用awk命令，其中
-F：后跟列分隔符
'$3!=""'：过滤条件，第三列不为空
file1：操作的文本
&gt;&gt; newfile：写入新文本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60971159bf48917af913aa0ccf8a29d2/" rel="bookmark">
			android代码控制安装apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		android代码控制安装apk 平时我们在使用商城的时候，下载完apk就可以自动的弹出安装的画面并且有的手机还会帮你检测apk的来源是否安全。
由于项目上有个需求是远程升级apk，所以需要在自己做的程序中代码控制安装apk。
网上查询了一番后有人给出了下述方法，用PackageInstaller帮助安装apk,这个其实是一个系统预安装的apk,就是我们平时用商城安装程序吊起的界面。
一番查询后网上给出了如下的解决方案：
File apk = new File(path); Uri uri = FileProvider.getUriForFile(mContext, "com.yanfeng.poc.ota.fileProvider", apk); Intent intent = new Intent(Intent.ACTION_VIEW); intent.setDataAndType(uri, "application/vnd.android.package-archive"); intent.setClassName("com.android.packageinstaller", "com.android.packageinstaller.PackageInstallerActivity"); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(intent); 然后发现会报如下的错误：
java.lang.SecurityException: Permission Denial: starting Intent { act=android.intent.action.VIEW dat=content://com.yanfeng.poc.ota.fileProvider/apk/app-debug.apk typ=application/vnd.android.package-archive flg=0x10000001 cmp=com.android.packageinstaller/.PackageInstallerActivity } from ProcessRecord{a4b2c99 12176:com.yanfeng.poc.ota/u0a173} (pid=12176, uid=10173) not exported from uid 10046 一开始我以为是应用权限等级不够，不是系统应用无法拉起这个安装的界面，后来我在adb shell中用am start -n com.android.packageinstaller/.PackageInstallerActivity想要吊起界面依旧失败了，报错也类似有not exported from uid 10046这个字样，于是一番查询后发现uid其实是android资源是否能共享的一个标识符，如果在表单文件中对activity的exported设置为false那么不是同一个uid的进程不能吊起这个activity，也就是说.PackageInstallerActivity这个activity设置了exported为false，它不能用别的应用拉起它，只能是自己的activity跳转的时候拉起这个activity。于是我在adb shell中 敲入pm list package -f | grep install查看包名和apk的路径，我在安卓9.0的系统的板子上查询到了这个apk的路径如下
package:/system/priv-app/PackageInstaller/PackageInstaller.apk=com.android.packageinstaller
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60971159bf48917af913aa0ccf8a29d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef698ed5f2d8cf54c79c2ad659f0fc51/" rel="bookmark">
			Redis的五种常用数据类型、三种特殊数据类型详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简述Redis五种基本数据类型String字符串常用命令应用场景 Hash散列表常用命令使用场景 List链表常用命令应用场景 Set( 集合)常用命令应用场景 SortedSet( 有序集合) zset常用命令介绍应用场景 Redis三种特殊的数据类型Geospatial 地理位置命令介绍底层实现原理 Hyperloglog 基数统计命令介绍应用场景：适合做页面统计。 Bitmap位图场景基本命令应用场景 面试题常问的数据类型寄言 以下总结了关于Redis比较全面的知识笔记以及面试题，方便自己复习的同时希望对大家有所帮助。 序号内容链接地址1Redis的基础知识、单机版安装、数据类型介绍（老版本）https://blog.csdn.net/weixin_43246215/article/details/1074742832Redis常用命令、配置文件介绍、数据持久化方式、集群搭建 （老版本）https://blog.csdn.net/weixin_43246215/article/details/1079475623Redis的五种常用数据类型、三种特殊数据类型详解https://blog.csdn.net/weixin_43246215/article/details/1080417394Redis基本的事务操作以及使用Redis实现乐观锁https://blog.csdn.net/weixin_43246215/article/details/1080459315使用JedisAPI操作Redis以及Jedis实现Redis事务https://blog.csdn.net/weixin_43246215/article/details/1080675426Redis的配置文件详解（中文）https://blog.csdn.net/weixin_43246215/article/details/1080682457Redis数据持久化的两种方式以及Redis实现订阅发布https://blog.csdn.net/weixin_43246215/article/details/1080687978Redis的伪集群搭建以及主从复制原理https://blog.csdn.net/weixin_43246215/article/details/1080694729Redis中哨兵（Sentinel）模式的使用以及相关配置介绍https://blog.csdn.net/weixin_43246215/article/details/10808817910Redis中的缓存穿透、缓存击穿以及缓存雪崩（理论知识）https://blog.csdn.net/weixin_43246215/article/details/10808902611Spring整合Redis实现查询缓存以及同步缓存待更新12SpringBoot整合Redis以及自定义Redis Templatehttps://blog.csdn.net/weixin_43246215/article/details/10847632813Redis常见面试题https://blog.csdn.net/weixin_43246215/article/details/10809009514…待更新 简述 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。
它支持多种类型的数据结构，如 字符串（strings），散列（hashes）， 列表（lists），集合（sets），有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。
Redis的英文官网
Redis的中文官网
Redis的中文命令手册
本文主要介绍Redis五种常用的数据类型、三种特殊的数据类型的使用、应用场景。
Redis五种基本数据类型 String字符串 Redis 字符串是字节序列。Redis 字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512 M为上限，主要的还是操作键值对。
String的数据结构是简单的Key-Value模型，Value可以是字符串，也可以是数字。
常用命令 添加元素（SET命令） 格式：
set key value [expiration EX seconds|PX milliseconds] [NX|XX] ex:秒级过期时间,nx:键不存在时才能设置成功,xx键存在时才能设置成功 (1)普通添加：set key value
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef698ed5f2d8cf54c79c2ad659f0fc51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca75c27242d03de55a75b2b8d96ff53/" rel="bookmark">
			怎样区分充分性、必要性？如何辨别条件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、记住一点：“根据条件推结论就是证明充分性，根据结论推条件就是证明必要性”
二、充要条件证明题的叙述方式一般有这几种：①是“求证：“A是 B的充要 条件”；②是“求证：“A的充要 条件是B”。③A&lt;=&gt;B(等价于②，“A的充要 条件是B”)
怎么看哪个是条件呢？如上提取主谓宾，谁是条件一目了然。在①中，A是条件，由A推出B就是证明充分性，反之由B推出A就是证明必要性；在②③中，条件是B，所以由B推出A就是证明充分性，反之由A推出B就是证明必要性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e49c50b4731cbd2c7ab02120563a77/" rel="bookmark">
			操作系统——进程管理的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 进程控制 1. 什么是进程控制？ 进程控制是进程管理中的最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换功能。
简单来说：进程控制就是要实现进程状态的转换
2. 如何实现进程控制呢？ 3. 进程的切换需要修改PCB的内容，并放到相应的队列中去，假如没有修改PCB中的状态标志就把PCB放入到某个队列中去了，这种情况特别危险，怎么避免呢？ 4. 进程控制原语做了哪些事情呢？ 5. 进程创建 6. 进程终止 7. 进程的阻塞与唤醒 8. 进程的挂起和激活 9. 进程的切换 二. 进程通信 在网络环境的应用领域主流的进程通信实现机制：客户机-服务器系统
1. 什么是进程通信呢？ 2. 共享存储 3. 管道通信 4. 消息传递 三. 处理机调度 1. 什么是调度 在多道程序系统中，调度的实质是一种资源分配。
处理机调度就是对处理机资源进行分配。
2. 处理机调度的层次 在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度
注：作业和进程的区别
作业（Job）是一个总任务，进程（Process）是总任务中的各个子项。 例如：课室大扫除是一项总任务，它是一个作业； 而其中擦桌子、扫地是各个子任务，擦桌子需要多次执行（每桌子执行一次），扫地只需要执行一次，这些就是在作业中调度的进程。 (1). 高级调度 1. 什么是作业 作业（job）：是一个比程序更为广泛的概念，他不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据说明书对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存
作业步：在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。 我们把其中的每一个加工步骤称为一个作业步，各作业步相互联系，上一个作业的输出是下一个作业的输入。 例如：一个典型作业分为：编译作业步、链接装配作业步、运行作业步 2. 作业里面含有什么？ 程序
数据
作业说明书
作业控制块（Job control block，JCB）
作业控制块是作业说明书在系统中生成的一张表格， 在多道批处理系统中，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息 3. 作业运行的三个阶段 收容阶段运行阶段完成阶段 4. 作业调度的主要任务 根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列选取某些作业调入内存，并为它们创建进程、分配资源。然后再将新创建的进程排在就绪队列上等待调度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e49c50b4731cbd2c7ab02120563a77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586d67d093708aae98efb97f6c195b13/" rel="bookmark">
			python程序日志_如何在python应用程序中实现日志记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python程序日志
A practical guide to implementing logging
实施日志的实用指南 Recently, I set about building a Python application to query a PostgreSQL database, process the data and push subsequent trigger events to a Kafka queue. However, before tackling the interesting aspects, I knew I needed to get the basics right. And one very important basic for any application is logging!
最近，我着手构建一个Python应用程序来查询PostgreSQL数据库，处理数据并将后续触发事件推送到Kafka队列。 但是，在解决有趣的方面之前，我知道我需要正确了解基础知识。 对于任何应用程序来说，一个非常重要的基础是日志记录！ In this article I’ll first explain some of the key features of logging in Python and, more importantly, demonstrate how I implemented a logger in my application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586d67d093708aae98efb97f6c195b13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63f2fe50c006ded210defded8c2c7ca/" rel="bookmark">
			为什么要用深浅拷贝、什么是深浅拷贝、以及如何实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、深拷贝和浅拷贝 首先我们要明白一点，js中数据类型分为：
基本数据类型 （Number, String, Boolean, Null, Undefined, Symbol）
对象数据类型 （ Object )
引用数据类型的值是保存在栈内存和堆内存中的对象。栈区内存保存变量标识符和指向堆内存中该对象的指针。当寻找引用值时，解释器会先寻找栈中的地址。然后根据地址找到堆内存的实体。
二、为什么要进行深浅拷贝 首先看下如下代码 let a = b = 2 a = 3 console.log(a) console.log(b) let c = d = [1,2,3] let e = f = {a:1,b:2,c:3} c[0] = 2 e.a = 2 console.log(d[0]) console.log(f.a) 会发现，同一个Array或者Object赋值给两个不同变量时，变量指向的是同一个内存地址，所以就会造成其中一个变量改变属性值，同时改变了另外一个变量的对应属性值。
而大多数实际项目中，我们想要的结果是两个变量（初始值相同）互不影响。所以就要使用到拷贝（分为深浅两种）
三、深浅拷贝的区别： 浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。
深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。
结果：
一次构造
两次析构
编译系统在我们自己没有自定义拷贝构造函数时，会在拷贝对象时候调用默认拷贝构造函数，进行浅拷贝，即对指针name拷贝后出现两个指针指向同一个内存块。所以析构时候就析构了两次，导致内存泄漏。
所以在对“含有指针成员的对象”进行拷贝时，必须要自己定义拷贝构造函数，使拷贝构造后的对象指针成员有自己的内存空间，即进行深拷贝，避免内存泄漏。
test.cpp
结果：
构造一次
拷贝构造一次
析构两次
在这里插入图片描述
综上所述，浅拷贝是只对指针进行拷贝，两个指针指向同一个内存块，深拷贝是对指针和指针指向的内容都进行拷贝，拷贝后的指针是指向不同内的指针。
深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。 深拷贝
深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，
对一个对象的修改并不会影响另一个对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b63f2fe50c006ded210defded8c2c7ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4667e8eacb4ea967d865a21f50190d/" rel="bookmark">
			calcite sql解析框架引擎流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 整体流程图
2. sql parse代码生成流程图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d16895645cc488654c56d500e786bda/" rel="bookmark">
			es如何提升写入性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
前段时间，为了降低用户使用ElasticSearch的存储成本，我们做了数据的冷热分离。为了保持集群磁盘利用率不变，我们减少了热节点数量。ElasticSearch集群开始出现写入瓶颈，节点产生大量的写入rejected，大量从kafka同步的数据出现写入延迟。我们深入分析写入瓶颈，找到了突破点，最终将Elasticsearch的写入性能提升一倍以上，解决了ElasticSearch瓶颈导致的写入延迟。这篇文章介绍了我们是如何发现写入瓶颈，并对瓶颈进行深入分析，最终进行了创新性优化，极大的提升了写入性能。
写入瓶颈分析
▍2.1 发现瓶颈
我们去分析这些延迟问题的时候，发现了一些不太好解释的现象。之前做性能测试时，ES节点cpu利用率能超过80%，而生产环境延迟索引所在的节点cpu资源只使用了不到50%，集群平均cpu利用率不到40%，这时候IO和网络带宽也没有压力。通过提升写入资源，写入速度基本没增加。于是我们开始一探究竟，我们选取了一个索引进行验证，该索引使用10个ES节点。从下图看到，写入速度不到20w/s，10个ES节点的cpu，峰值在40-50%之间。
为了确认客户端资源是足够的，在客户端不做任何调整的情况下，将索引从10个节点，扩容到16个节点，从下图看到，写入速度来到了30w/s左右。
这证明了瓶颈出在服务端，ES节点扩容后，性能提升，说明10个节点写入已经达到瓶颈。但是上图可以看到，CPU最多只到了50%，而且此时IO也没达到瓶颈。
▍2.2 ES写入模型说明
这里要先对ES写入模型进行说明，下面分析原因会跟写入模型有关。
客户端一般是准备好一批数据写入ES，这样能极大减少写入请求的网络交互，使用的是ES的BULK接口，请求名为BulkRequest。这样一批数据写入ES的ClientNode。ClientNode对这一批数据按数据中的routing值进行分发，组装成一批BulkShardRequest请求，发送给每个shard所在的DataNode。发送BulkShardRequest请求是异步的，但是BulkRequest请求需要等待全部BulkShardRequest响应后，再返回客户端。
▍2.3 寻找原因
我们在ES ClientNode上有记录BulkRequest写入slowlog。
items是一个BulkRequest的发送请求数
totalMills是BulkRequest请求的耗时
max记录的是耗时最长的BulkShardRequest请求
avg记录的是所有BulkShardRequest请求的平均耗时。
我这里截取了部分示例。
[xxx][INFO ][o.e.m.r.RequestTracker ] [log6-clientnode-sf-5aaae-10] bulkDetail||requestId=null||size=10486923||items=7014||totalMills=2206||max=2203||avg=37
[xxx][INFO ][o.e.m.r.RequestTracker ] [log6-clientnode-sf-5aaae-10] bulkDetail||requestId=null||size=210506||items=137||totalMills=2655||max=2655||avg=218
从示例中可以看到，2条记录的avg相比max都小了很多。一个BulkRequest请求的耗时，取决于最后一个BulkShardRequest请求的返回。这就很容易联想到分布式系统的长尾效应。
接下来再看一个现象，我们分析了某个节点的write线程的状态，发现节点有时候write线程全是runnable状态，有时候又有大量在waiting。此时写入是有瓶颈的，runnable状态可以理解，但却经常出现waiting状态。所以这也能印证了CPU利用率不高。同时也论证长尾效应的存在，因为长尾节点繁忙，ClientNode在等待繁忙节点返回BulkShardRequest请求，其他节点可能出现相对空闲的状态。下面是一个节点2个时刻的线程状态：
时刻一：
时刻二：
▍2.4 瓶颈分析
谷歌大神Jeffrey Dean《The Tail At Scale》介绍了长尾效应，以及导致长尾效应的原因。总结下来，就是正常请求都很快，但是偶尔单次请求会特别慢。这样在分布式操作时会导致长尾效应。我们从ES原理和实现中分析，造成ES单次请求特别慢的原因。发现了下面几个因素会造成长尾问题：
2.4.1 lucene refresh
我们打开lucene引擎内部的一些日志，可以看到：
write线程是用来处理BulkShardRequest请求的，但是从截图的日志可以看到，write线程也会会进行refresh操作。这里面的实现比较复杂，简单说，就是ES定期会将写入buffer的数据refresh成segment，ES为了防止refresh不过来，会在BulkShardRequest请求的时候，判断当前shard是否有正在refresh的任务，有的话，就会帮忙一起分摊refresh压力，这个是在write线程中进行的。这样的问题就是造成单次BulkShardRequest请求写入很慢。还导致长时间占用了write线程。在write queue的原因会具体介绍这种危害。
2.4.2 translog ReadWriteLock
ES的translog类似LSM-Tree的WAL log。ES实时写入的数据都在lucene内存buffer中，所以需要依赖写入translog保证数据的可靠性。ES translog具体实现中，在写translog的时候会上ReadLock。在translog过期、翻滚的时候会上WriteLock。这会出现，在WriteLock期间，实时写入会等待ReadLock，造成了BulkShardRequest请求写入变慢。我们配置的tranlog写入模式是async，正常开销是非常小的，但是从图中可以看到，写translog偶尔可能超过100ms。
2.4.3 write queue
ES DataNode的写入是用标准的线程池模型是，提供一批active线程，我们一般配置为跟cpu个数相同。然后会有一个write queue，我们配置为1000。DataNode接收BulkShardRequest请求，先将请求放入write queue，然后active线程有空隙的，就会从queue中获取BulkShardRequest请求。这种模型下，当写入active线程繁忙的时候，queue中会堆积大量的请求。这些请求在等待执行，而从ClientNode角度看，就是BulkShardRequest请求的耗时变长了。下面日志记录了action的slowlog，其中waitTime就是请求等待执行的时间，可以看到等待时间超过了200ms。
[xxx][INFO ][o.e.m.r.RequestTracker ] [log6-datanode-sf-4f136-100] actionStats||action=indices:data/write/bulk[s][p]||requestId=546174589||taskId=6798617657||waitTime=231||totalTime=538
[xxx][INFO ][o.e.m.r.RequestTracker ] [log6-datanode-sf-4f136-100] actionStats||action=indices:data/write/bulk[s][p]||requestId=546174667||taskId=6949350415||waitTime=231||totalTime=548
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d16895645cc488654c56d500e786bda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/201c5b87776c0b0a3df886af0d3a84a7/" rel="bookmark">
			第 15 篇：接口的单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-追梦人物
一个完整的项目，无论是个人的还是公司的，自动化的单元测试是必不可少，否则以后任何的功能改动将成为你的灾难。
假设你正在维护公司的一个项目，这个项目已经开发了几十个 API 接口，但是没有任何的单元测试。现在你的 leader 让你去修改几个接口并实现一些新的功能，你接到需求后高效地完成了开发任务，然后手动测试了一遍改动的接口和新实现的功能，确保没有任何问题后，满心欢喜地提交了代码。
代码上线后出了 BUG，分析原因发现原来是新的改动导致某个旧 API 接口出了问题，因为上线前只对改动的接口做了测试，所以未能发现这个问题。你的 leader 批评了你，你因为事故记了过，年终只能拿个 3.25，非常凄惨。
但是如果我们有全面的单元测试，上述情况就有很大概率避免。只需要在代码发布前运行一遍单元测试，受影响的功能立即就会报错，这样就能在代码部署前发现问题，从而避免线上事故。
当然以上故事纯属虚构，说这么多只是希望大家在开发时养成良好的习惯，一是写优雅的代码，二是一定要测试自己写的代码。
单元测试回顾 在上一部教程 Django博客教程（第二版）[1] 的 单元测试：测试 blog 应用[2]、单元测试：测试评论应用[3]、Coverage.py 统计测试覆盖率[4] 中，我们详细讲解了 django 单元测试框架的使用方式。这里我们再对 djnago 的测试框架做一个回顾整体回顾，至于如何编写和运行测试，后面将会进行详细的讲解，如果想对 django 的单元测试做更基础的了解，推荐回去看看关于测试的 3 篇教程以及 django 的官方文档。
下面是 djnago 单元测试框架的一些要点：
django 的单元测试框架基于 Python 的 unittest 测试框架。
django 提供了多个 XXTestCase 类，这些类均直接或者间接继承自 unittest.TestCase 类，因为 django 的单元测试框架是基于 unittest 的，所以编写的测试用例类也都需要直接或者间接继承 unittest.TestCase。通常情况我们都是继承 django 提供的 XXTestCase，因为这些类针对 django 定制了更多的功能特性。
默认情况下，测试代码需要放在 django 应用的下的 tests.py 文件或者 tests 包里，django 会自动发现 tests 包中以 test 开头的模块（例如 test_models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/201c5b87776c0b0a3df886af0d3a84a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17589890cae1230c72b4ee633aa6a650/" rel="bookmark">
			react 简介 路由及生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全局下载react 脚手架
npm install -g create-react-app 创建项目
create-react-app my-app // my-app 为自己的demo名称 更新npm(报错)
npm cache clean --force //清缓存 npm install npm -g // 重新下载npm npm install -g create-react-app //全局下载react 脚手架 create-react-app my-app //创建项目 注意 (vue尽量 npm react尽量 yarn)
react 路由
class home extends React.Component { constructor(props) { super(props); this.state={ } // this.handleClick = this.handleClick.bind(this); } // 路由跳转 nav(child) { console.log(child); this.props.history.push({ pathname: "/css", query: child }); //https://blog.csdn.net/qq8241994/article/details/85074581 路由传参地址介绍 // this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17589890cae1230c72b4ee633aa6a650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e4db108cd0aec5b06f9766ef1495ba9/" rel="bookmark">
			embed标签修饰的pdf文件下载——（embed src=“about:blank“）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天需要在BioLib网站上看点东西，发现都是pdf文件，还不如下载下来
结果查看源代码后发现都是embed标签修饰，一开始有点蒙，因为src属性里没有链接。
最后发现直接用content就可以。淦。
幸亏没用自动化调试。
随便点进去一个
发现没有下载链接
但是！！！，打开它的Network，神奇的事情发生了
Content-Length的大小和pdf文档大小很接近，试着下载了一个，发现没有问题，内容无缺失。
既然已经找到了内容，思路理清后，代码也就水到渠成了
import requests from bs4 import BeautifulSoup import os path = r'E:\desktop\BioLib' url = 'http://www.biolib.de/library/pdf_index_de.html' headers = {'user-agent': 'Mozilla/5.0'} res = requests.get(url, headers) soup = BeautifulSoup(res.text, 'html.parser') box = soup.find('td', class_='boxrot') files = box.find_all('a') for file in files: title = file.text link = file['href'] if not os.path.exists(path + '\\' + title): content = requests.get(link, headers, stream=True) size = 0 chunk_size = 1024 content_size = int(content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e4db108cd0aec5b06f9766ef1495ba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d6f5e925fc437eef0b656111ebbe894/" rel="bookmark">
			vue组件的挂载方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2.0中组件之间有全局注册的组件，有组件内部注册的组件。这两种组件都可以挂载到任何一个组件上，比如有根组件如下
import Vue from 'vue' Vue.component('global-component', { template: '&lt;h2&gt;I\'m a global component &lt;/h2&gt;' }) new Vue({ el: "#app", components: { "layout": layout } }) 上面
上面是我们要实现的流程图
1.根组件挂载全局组件和普通组件
上面注册了一个全局组件，global-component并且初始化了一个vue实例。那么如何在根组件引用global-component?
（1）.挂载全局组件。很简单把global-component放在index.html文件中
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;vue1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;global-component&gt; &lt;/global-component&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; (2).挂载普通组件layout，vue实例加入components属性，并且定义组件layout配置项
let layout = { template: '&lt;div&gt;我是内部挂载的组件&lt;/div&gt;', } new Vue({ el: "#app", //add new attributes components: { "layout": layout } }) 然后修改index.html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d6f5e925fc437eef0b656111ebbe894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4dfb7cf19718635b19db7a16b910e8/" rel="bookmark">
			数学建模方法 — 【02】模糊综合评价方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模糊综合评价方法 1. 概念: 根据多个因素对事物进行评定，称为综合评判。在日常生活中，当要对某种东西作出好、较好、不好等评价时，常常感到不易判断。因为这是一个模糊的概念，同时涉及的因素很多，如果运用模糊数学的方法，将可以较好地解决。
2. 模糊合成算子 B = A ∘ \circ ∘ B = ( a 1 , a 2 , . . . , a m ) ∘ ( b 11 b 12 . . . . b 1 n b 21 b 22 . . . b 2 n . . . . . . . . . . . . b m 1 b m 2 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c4dfb7cf19718635b19db7a16b910e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552cc3b5ae50f4f750231a12ff13c0b4/" rel="bookmark">
			vue   根据后台返回文件流   导出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步
&lt;el-button @click="exportMessage"&gt;批量导出&lt;/el-button&gt;
第二部
methods里面写方法
exportMessage() {
let data = {
search: this.ruleForm.searchPeople, 向后台传的参数
PageIndex: this.PageIndex,
pageSize: this.pageSize
};
let Authorization = localStorage.getItem("token"); token axios.defaults.headers.common["Authorization"] = "Bearer " + Authorization;
axios.post('http://114.55.169.186:1000/web/Export/exportTalent', data, {
responseType: 'blob' 这个 必须得加上
}).then(res =&gt; {
// console.log(res,555)
console.log(res, '返回数据列');
const blob = new Blob([res.data], {
type: 'application/vnd.ms-excel'
});
console.log(blob, '----------0990');
const fileName = '招募人才.xlsx'; 定义文件名字
const linkNode = document.createElement('a'); 添加点击事件
linkNode.download = fileName; //a标签的download属性规定下载文件的名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552cc3b5ae50f4f750231a12ff13c0b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b47c086aadfb56fe9717653fa0d341d/" rel="bookmark">
			hive数据备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive 数据备份
##数据准备 hive&gt; create table demo( &gt; id int comment 'ID', &gt; name string comment '名字') &gt; row format delimited fields terminated by ','; OK Time taken: 0.18 seconds hive&gt; load data local inpath '/data/lilin/demo.txt' into table demo; Loading data to table lilin.demo Table lilin.demo stats: [numFiles=1, totalSize=25] OK Time taken: 0.785 seconds hive&gt; select * from demo; OK 1 aa 2 bb 3 cc 4 dd 5 gg Time taken: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b47c086aadfb56fe9717653fa0d341d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ade774cfc04f10270ac1c978d801285/" rel="bookmark">
			hbase 数据、数据表被误删恢复、备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hbase误删数据
##创建名称空间 hbase(main):006:0&gt; create_namespace 'lilin_test' 0 row(s) in 0.0920 seconds hbase(main):008:0&gt; list_namespace NAMESPACE default lilin_test ##创建表，并插入数据 hbase(main):012:0&gt; create 'lilin_test:demo','f' 0 row(s) in 1.3430 seconds =&gt; Hbase::Table - lilin_test:demo hbase(main):013:0&gt; put 'lilin_test:demo','r1','f:name','aa' 0 row(s) in 0.1270 seconds hbase(main):014:0&gt; put 'lilin_test:demo','r1','f:age','16' 0 row(s) in 0.0080 seconds hbase(main):015:0&gt; put 'lilin_test:demo','r2','f:name','bb' 0 row(s) in 0.0100 seconds hbase(main):016:0&gt; put 'lilin_test:demo','r2','f:age','18' 0 row(s) in 0.0050 seconds hbase(main):017:0&gt; scan 'lilin_test:demo' ROW COLUMN+CELL r1 column=f:age, timestamp=1597126340904, value=16 r1 column=f:name, timestamp=1597126330023, value=aa r2 column=f:age, timestamp=1597126361389, value=18 r2 column=f:name, timestamp=1597126352918, value=bb 2 row(s) in 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ade774cfc04f10270ac1c978d801285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78abbab3f3d2c440bbda028c2e46c631/" rel="bookmark">
			前端JS正则校验密码之3种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		匹配8-16位，至少有一个大写字母或小写字母，至少有一个数字，至少有一个特殊字符包括-`=\[\];',.~!@#$%^&amp;*()_+|{}:"?，不过要注意不同语言的转义字符问题。
方式一和方式二实现如下所示：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;前端JS正则校验密码&lt;/title&gt; &lt;style type="text/css"&gt; *{margin: 0;padding: 0} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; /** * 匹配8-16位，至少有一个大写字母或小写字母，至少有一个数字，至少有一个特殊字符包括-`=\[\];',.~!@#$%^&amp;*()_+|{}:"? * * ^是正则表达式匹配字符串开始位置。 * $是正则表达式匹配字符串结束位置。 * ()是为了提取匹配的字符串，表达式中有几个()就有几个相应的匹配字符串。 * []是定义匹配的字符范围，匹配的字符在[]中。 * {}一般用来表示匹配的长度，比如\s{3} 表示匹配三个空格，\s{1,3}表示匹配一到三个空格。 */ var arrayList = new ArrayList(); arrayList.add("123"); arrayList.add("aaa"); arrayList.add("AAA"); arrayList.add("123a"); arrayList.add("123A"); arrayList.add("123789aOa"); arrayList.add("123789AoA"); arrayList.add("123789A $"); arrayList.add("123789a $"); arrayList.add("123Ao A$"); arrayList.add("123aO a$"); arrayList.add("123789A$"); arrayList.add("123789a$"); arrayList.add("123AoA$-"); arrayList.add("123aOa$-"); arrayList.add("123AoA()$"); arrayList.add("1234567a"); arrayList.add("aaabbb&amp;&amp;&amp;"); arrayList.add("aaabbb&amp;&amp;&amp;1"); arrayList.add("123761123&amp;&amp;&amp;"); arrayList.add(" "); arrayList.add(" 7613&amp;&amp;&amp;"); arrayList.add(" 7613aa&amp;&amp;&amp;"); arrayList.add(" 7613AA&amp;&amp;&amp;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78abbab3f3d2c440bbda028c2e46c631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32e6a30a335aeaa507a4e0ca12da294/" rel="bookmark">
			Winform入门(五) WEBAPI请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 需要引入: using System.Net; using System.IO; 二. 处理get请求 public static string HttpGet(string url, Dictionary&lt;string, string&gt; para) { Encoding encoding = Encoding.UTF8; WebClient webClient = new WebClient(); StringBuilder buffer = new StringBuilder("?");//这是要提交的数据 int i = 0; foreach (string key in para.Keys) { string pk = para[key].Replace('_', '-'); if (i &gt; 0) { buffer.AppendFormat("&amp;{0}={1}", key, pk); } else { buffer.AppendFormat("{0}={1}", key, pk); } i++; } url = url + buffer.ToString(); Stream stream = webClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32e6a30a335aeaa507a4e0ca12da294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be90a1b2dc39412ffe46243a579cb30/" rel="bookmark">
			判断数据类型的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1: typeof 平时我们需要判断数据类型的时候，可能第一个想到的方法就是typeof，但是，我们都知道，是有点小缺陷的
typeof null返回类型错误，返回object
引用类型，除了function返回function类型外，其他均返回object。
其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。
2：toString 应该是最完美的 const isType = (typing) =&gt; value =&gt; { return Object.prototype.toString.call(value) === `[object ${typing}]` } let utils = {} const arr = ['String', 'Number', 'Null', 'Undefined', 'Function', 'Boolean','Symbol'] arr.forEach(typing =&gt; { utils['is' + typing] = isType(typing) }) console.log(utils.isBoolean(true)) console.log(utils.isString('string')) console.log(utils.isNumber(12345)) console.log(utils.isNull(null)) console.log(utils.isUndefined(undefined)) console.log(utils.isFunction(function Foo() { })) console.log(utils.isSymbol(Symbol())) toString() 是 Object 的原型方法，调用这个方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型(注意首字母是大写的)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be90a1b2dc39412ffe46243a579cb30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d1de70de425da28ce1dc663b5d8a7f/" rel="bookmark">
			anaconda创建虚拟环境报错：An HTTP error occurred when trying to retrieve this URL.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述：conda无法创建虚拟环境并且无法安装其他第三方包，报错内容如下：
PS C:\Users\Administrator.DESKTOP-EEN44LR&gt; conda create -n flask_py python=3.8 Collecting package metadata (current_repodata.json): failed CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json&gt; Elapsed: - An HTTP error occurred when trying to retrieve this URL. HTTP errors are often intermittent, and a simple retry will get you on your way. If your current network has https://www.anaconda.com blocked, please file a support request with your network engineering team. 2.错误原因：默认镜像源访问速度过慢，会导致超时从而导致更新和下载失败。
3.解决方案：更换镜像源为清华镜像源，并且删除默认镜像源。
conda config --add channels https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d1de70de425da28ce1dc663b5d8a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50b2e4affef1742ec9a4449b7dde16d/" rel="bookmark">
			Netty架构篇 - NioServerSocketChannel、NioSocketChannel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言服务端Channel的实例化服务端Channel的初始化服务端Channel的注册客户端Channel的实例化客户端Channel的初始化客户端Channel的注册 前言 在解析Netty中的Channel如何应用之前，首先看下如下的代码：
这段代码，一些使用过netty的朋友们，都蛮了解的。
再看一段nio的代码。
ServerSocketChannel channel = ServerSocketChannel.open(); channel.configureBlocking(false); channel.socket().bind(new InetSocketAddress("192.168.0.106", 8080), 1024); Selector selector = SelectorProvider.provider().openSelector(); channel.register(selector, SelectionKey.OP_ACCEPT); 在下面的源码分析中，你可以看到这段nio代码如何被封装到netty中。
接下来从server.channel(NioServerSocketChannel.class)这行代码开始本篇文章的解析旅程。
服务端Channel的实例化 概述：
设置非阻塞模式，建立NioServerSocketChannel与ServerSocket的关联关系，然后通过ReflectiveChannelFactory完成NioServerSocketChannel的实例化。
首先看下外层的channelFactory(…)方法做了什么事。
很显然是设置ChannelFactory属性为一个ReflectiveChannelFactory实例。
然后看下ReflectiveChannelFactory实例如何构造的。
由前文可知，方法的参数，我们传递的是NioServerSocketChannel.class。这里利用反射调用它的无参构造器进行实例化。
后面会分析何时调用这个newChannel()方法。
接下来看下NioServerSocketChannel这个类，声明如下：
接着看下它的无参构造器。
先看下newSocket(…)方法的处理逻辑。
这里的SelectorProvider，通过在ide工具中debug，我们可以知道实际上是KQueueSelectorProvider。（由SelectorProvider.provider()方法生成）
可以看出得到的是nio原生的ServerSocketChannelImpl这个实例，并且将KQueueSelectorProvider作为参数传入。
回到它的构造器方法。
javaChannel()：实际上是我们前面看到的ServerSocketChannelImpl。socket()：构造一个ServerSocket实例。 由此，NioServerSocketChannelConfig将NioServerSocketChannel、ServerSocket与之关联。如同它的名字一样，存储相关的配置。
接着看调用其父类的构造器做了什么事。
ch：ServerSocketChannelImpl类型。 由ch.configureBlocking(false)这行代码，可以看出设置非阻塞模式。同时将readInterestOps属性设置为SelectionKey.OP_ACCEPT，表示监听接收客户端的连接。
接着往下看。
对parent、id、unsafe、pipeline属性进行赋值。
在后续的AbstractBootstrap#initAndRegister()方法有这样一行代码。
由此，由ReflectiveChannelFactory完成NioServerSocketChannel的实例化。
服务端Channel的初始化 这部分从代码样例的server.bind(port)这行代码开始分析。
概述：
将ServerBoostrap#option(…)、attr(…)等方法设置的属性传递给NioServerSocketChannel。然后在DefaultChannelPipeline中添加ServerBootstrap#handler(…)方法定义的ChannelHandler以及ServerBootstrapAcceptor。
bind(…)方法会走到doBind(…)方法，如下：
doBind0()方法经过层层方法，会走到NioServerSocketChannel的如下方法中：
对应nio的ServerSocketChannel#bind(new InetSocketAddress(hostname, port), backlog)方法。
下面重点关注下initAndRegister()方法。(剩余的方法内容会在注册中接着分析)
channelFactory：ReflectiveChannelFactory类型。newChannel()：由ReflectiveChannelFactory完成NioServerSocketChannel的实例化。 在ServerBootstrap#option(…)方法设置的参数传递给NioServerSocketChannelConfig，也就是NioServerSocketChannel的属性。
在ServerBootstrap#attr(AttributeKey, Object)方法设置的key、value传递给NioServerSocketChannel。
接着看init(…)剩余的方法。
在ServerBootstrap#childGroup(…)、childHandler(…)、childOption(…)以及childAttr(…)方法设置的参数传递给ServerBootstrapAcceptor。
在DefaultChannelPipeline中，添加了一个ChannelInitializer。其在initChannel(…)方法，定义了在DefaultChannelPipeline中添加ServerBootstrap#handler(…)方法定义的ChannelHandler、以及ServerBootstrapAcceptor实例。
ChannelInitializer，一个特定的ChannelInboundHandler，提供了便捷的方法（也就是initChannel(…)方法）用于初始化一个Channel。
ServerBootstrapAcceptor，同样是一个ChannelInboundHandler。其封装了如下属性：
服务端Channel的注册 概述：
核心是调用nio原生的ServerSocketChannelImpl#register(Selector sel, int ops, Object att)方法，将Netty的NioServerSocketChannel作为attr参数进行传入，从而与nio原生的ServerSocketChannelImpl建立关联性，最后完成Channel在Selector上的注册。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50b2e4affef1742ec9a4449b7dde16d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fe69bb0a16ad88a90542277957e79c0/" rel="bookmark">
			CountDownLatch、CyclicBarrier和Semaphore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。
以下是本文目录大纲：
一.CountDownLatch用法
二.CyclicBarrier用法
三.Semaphore用法
一.CountDownLatch用法 CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。
CountDownLatch类只提供了一个构造器：
1
public CountDownLatch(int count) { }; //参数count为计数值
然后下面这3个方法是CountDownLatch类中最重要的方法：
1
2
3
public void await() throws InterruptedException { }; //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { }; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public void countDown() { }; //将count值减1
下面看一个例子大家就清楚CountDownLatch的用法了：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fe69bb0a16ad88a90542277957e79c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdb41dbd570453e5ccfd5bdaed979e6/" rel="bookmark">
			java调用第三方接口（项目亲测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接复制过去，就是一个很好的工具类了，直接可以使用
import com.alibaba.fastjson.JSONObject; import com.aliyun.openservices.eas.predict.http.HttpConfig; import com.aliyun.openservices.eas.predict.http.PredictClient; import lombok.extern.slf4j.Slf4j; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.HttpURLConnection; import java.net.URL; import java.nio.charset.StandardCharsets; import java.util.List; import java.util.Map; /** * @author buH * #data 2020/12/4 10:07 * 接口工具类 */ @Slf4j public class HttpUtil { /** * post请求 * * @param URL 请求url * @param param 参数 * @param token 请求携带的token（如果需要） */ public static String doPost(String URL, JSONObject param, String token) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdb41dbd570453e5ccfd5bdaed979e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a2c1c44ea1a8a36ca7607a060df2ad/" rel="bookmark">
			发送HTTP请求返回415状态码的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题出现：
在用POST方式携带token访问一个API接口时，发现返回状态码为415，错误信息为“Unsupported Media Type”
2.分析原因：
415错误的解释是说，服务器无法处理请求附带的媒体格式，不明白什么意思，后来用postman请求，可以成功，确定是我请求的代码问题，查看了HTTP请求头部文件，发现content-type跟我们写的不同，多了
"Content-Type":"application/json" 3.解决办法
在请求头加入"Content-Type":"application/json"
再次请求，发送成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6dfedd22eeb85130d38cde338602838/" rel="bookmark">
			什么是递归，通过这篇文章，让你彻底搞懂递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想了解更多数据结构以及算法题，可以关注微信公众号“数据结构和算法”，每天一题为你精彩解答。也可以扫描下面的二维码关注
啥叫递归 聊递归之前先看一下什么叫递归。
递归，就是在运行的过程中调用自己。
构成递归需具备的条件：
1. 子问题须与原始问题为同样的事，且更为简单；
2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。
递归语言例子 我们用2个故事来阐述一下什么叫递归。
1，从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”
2，大雄在房里，用时光电视看着从前的情况。电视画面中的那个时候，他正在房里，用时光电视，看着从前的情况。电视画面中的电视画面的那个时候，他正在房里，用时光电视，看着从前的情况……
递归模板 我们知道递归必须具备两个条件，一个是调用自己，一个是有终止条件。这两个条件必须同时具备，且一个都不能少。并且终止条件必须是在递归最开始的地方，也就是下面这样
public void recursion(参数0) { if (终止条件) { return; } recursion(参数1); } 不能把终止条件写在递归结束的位置，下面这种写法是错误的
public void recursion(参数0) { recursion(参数1); if (终止条件) { return; } } 如果这样的话，递归永远退不出来了，就会出现堆栈溢出异常(StackOverflowError)。
但实际上递归可能调用自己不止一次，并且很多递归在调用之前或调用之后都会有一些逻辑上的处理，比如下面这样。
public void recursion(参数0) { if (终止条件) { return; } 可能有一些逻辑运算 recursion(参数1) 可能有一些逻辑运算 recursion(参数2) …… recursion(参数n) 可能有一些逻辑运算 } 实例分析 我对递归的理解是先往下一层层传递，当碰到终止条件的时候会反弹，最终会反弹到调用处。下面我们就以5个最常见的示例来分析下
1，阶乘
我们先来看一个最简单的递归调用-阶乘，代码如下
public int recursion(int n) { if (n == 1) return 1; return n * recursion(n - 1);5} 这个递归在熟悉不过了，第2-3行是终止条件，第4行是调用自己。我们就用n等于5的时候来画个图看一下递归究竟是怎么调用的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6dfedd22eeb85130d38cde338602838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41149bbdb66131cfb728223ac9edd033/" rel="bookmark">
			WPF基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF基本介绍 WPF（Windows Presentation Foundation）是（微软推出的）基于Windows的用户界面框架，属于.NET Framework 3.0的一部分。WPF提供了统一的编程模型，语言和框架，做到了分离界面设计人员与开发人员的工作；WPF提供了全新的多媒体交互用户图形界面。 WPF中文译名为“Windows呈现基础”，原来的代号为“Avalon”。从.NET Framework 3.0开始引入。（所以.NET Framework 3.0以下版本没有WPF，.NET Framework 3.0及其之后的版本才支持WPF） WPF最大的特点是页面的动态化，WPF有矢量图的超强支持；兼容2D绘图，3D控件及事件。 WPF使用对象描述语言XAML。（XAML语言和HTML语言都是由XML语言延申而来的。） WPF（Windows Presentation Foundation）由两个部分组成：引擎和编程框架。 WPF应用程序创建的项目，会自动生成这样一个目录文件（如下图）。
默认情况下，WPF的应用程序包含四部分内容。
Properties里面是项目的一些配置资源，Resources是系统里面的资源。
引用，可以通过引用的方式使用外部的插件。
App.config里面是一些配置文件，类似于MVC里面的Web.config。
现在使用的是.NET 4.5开发WPF。
App.xaml文件是整个程序的入口文件，可以指定WPF项目的入口页面是哪一个页面，在“Application”里面通过“StartupUri”这个属性来指定WPF要启动的应用窗体，启动页面默认为“MainWindow.xaml”页面。如下图可以看到整个页面的顶级元素是“Application”。
如下图，WPF在默认情况下带有三个命名空间，在WPF里面前面两个默认命名空间无论在哪里都能用到。第一个通过链接的方式将命名空间加进来，是矢量的命名空间；第二个命名空间带有x的前缀，是xaml的命名空间；第三个命名空间带有local的前缀，local代表着应用程序，加载的是本地的命名空间，不需要通过链接的方式引入，而是利用属性“clr-namespace”引入，但是本地的命名空间一般是用不到的，所以可以去掉。一个完整的XAML页面必须带有两个命名空间（第一和第二个）。
“Application”里面还有一个“Application.Resources”，Resources的意思是资源，那么“Application.Resources”的意思就是应用程序的资源，WPF的样式、模板、动画等资源就是通过Application.Resources引入。
App.xaml文件，下面跟着一个类文件App.xaml.cs文件。这是xaml页面的一个特点，xaml页面后面一定跟着一个xaml.cs类文件,一个页面对应一个xaml.cs类文件。
xaml页面与Html页面不同的是，xaml页面就只是页面设计，不涉及任何的业务逻辑处理。xaml页面也不能通过JS、Jquery来写逻辑代码，而是把逻辑代码写在对应的的xaml.cs类文件里面。
所以App.xaml文件下面的App.xaml.cs类文件里面是App.xaml文件的后台代码，如上图可以看到，App.xaml.cs类文件继承于Application应用程序，处理整个WPF项目的相关应用程序。
MainWindow.xaml是项目默认自带的窗口，WPF的设计界面。MainWindow.xaml页面下面同样跟着一个MainWindow.xaml.cs类文件。MainWindow.xaml.cs是后台类文件，如下图可以看到页面的顶级元素是“Window”，所以MainWindow.xaml.cs类文件继承于Windows。
里面的“Grid”布局相当于Html的“body”标签。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e2319b913f17cbc41aa5cefb13a086/" rel="bookmark">
			ILSVRC-ImageNet历年竞赛冠军
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImageNet 是一个超过15 million的图像数据集，大约有22,000类。
是由李飞飞团队从2007年开始，耗费大量人力，通过各种方式（网络抓取，人工标注，亚马逊众包平台）收集制作而成，它作为论文在CVPR-2009发布。当时人们还很怀疑通过更多数据就能改进算法的看法。
深度学习发展起来有几个关键的因素，一个就是庞大的数据（比如说ImageNet），一个是GPU的出现。（还有更优的深度模型，更好的优化算法，可以说数据和GPU推动了这些的产生，这些产生继续推动深度学习的发展）。
ILSVRC 是一个比赛，全称是ImageNet Large-Scale Visual Recognition Challenge，平常说的ImageNet比赛指的是这个比赛。
使用的数据集是ImageNet数据集的一个子集，一般说的ImageNet（数据集）实际上指的是ImageNet的这个子集，总共有1000类，每类大约有1000张图像。具体地，有大约1.2 million的训练集，5万验证集，15万测试集。
ILSVRC从2010年开始举办，到2017年是最后一届（在算法层面已经刷过拟合了，再比下去意义不是很大了）。ILSVRC-2012的数据集被用在2012-2014年的挑战赛中（VGG论文中提到）。ILSVRC-2010是唯一提供了test set的一年。
ImageNet可能是指整个数据集（15 million），也可能指比赛用的那个子集（1000类，大约每类1000张），也可能指ILSVRC这个比赛。需要根据语境自行判断。
12-15年期间在ImageNet比赛上提出了一些经典网络，比如AlexNet，ZFNet，OverFeat，VGG，Inception，ResNet。
16年之后也有一些经典网络，比如WideResNet，FractalNet，DenseNet，ResNeXt，DPN，SENet。
2012年 AlexNet是2012年ImageNet竞赛冠军获得者Hinton和他的学生Alex Krizhevsky设计的。也是在那年之后，更多的更深的神经网络被提出，比如优秀的vgg,GoogLeNet。AlexNet中包含了几个比较新的技术点，也首次在CNN中成功应用了ReLU、Dropout和LRN等Trick。
2013年 OverFeat：OverFeat是早期经典的one-stage Object Detection的方法，基于AlexNet，实现了识别、定位、检测共用同一个网络框架；获得了2013年ILSVRC定位比赛的冠军。
OverFeat方法的主要创新点是 multiscale 、sliding window、offset pooling，以及基于AlexNet的识别、定位和检测方法的融合。
2014年 GoogLeNet 冠军：从Inception v1到v4。引入稀疏特性和将全连接层转换成稀疏连接。在inception结构中，大量采用了1x1的矩阵，主要是两点作用：1）对数据进行降维；2）引入更多的非线性，提高泛化能力，因为卷积后要经过ReLU激活函数。
VGG（亚军）：VGG模型在多个迁移学习任务中的表现要优于googLeNet。而且，从图像中提取CNN特征，VGG模型是首选算法。它的缺点在于，参数量有140M之多，需要更大的存储空间。
VGG的特点：
小卷积核。作者将卷积核全部替换为3x3（极少用了1x1）；
小池化核。相比AlexNet的3x3的池化核，VGG全部为2x2的池化核；
层数更深特征图更宽。基于前两点外，由于卷积核专注于扩大通道数、池化专注于缩小宽和高，使得模型架构上更深更宽的同时，计算量的增加放缓；
全连接转卷积。网络测试阶段将训练阶段的三个全连接替换为三个卷积，测试重用训练时的参数，使得测试得到的全卷积网络因为没有全连接的限制，因而可以接收任意宽或高为的输入。
2015年 ResNet：
残差网络的特点是容易优化，并且能够通过增加相当的深度来提高准确率。其内部的残差块使用了跳跃连接，缓解了在深度神经网络中增加深度带来的梯度消失问题 。
生成了ResNet-50，ResNet-101，ResNet-152. 随着深度增加，因为解决了退化问题，性能不断提升。作者最后在Cifar-10上尝试了1202层的网络，结果在训练误差上与一个较浅的110层的相近，但是测试误差要比110层大1.5%。作者认为是采用了太深的网络，发生了过拟合
2016年 Trimps-Soushen冠军
ResNeXt（亚军）：
ResNeXt是ResNet[2]和Inception[3]的结合体，不同于Inception v4[4]的是，ResNext不需要人工设计复杂的Inception结构细节，而是每一个分支都采用相同的拓扑结构。ResNeXt的本质是分组卷积（Group Convolution）[5]，通过变量基数（Cardinality）来控制组的数量。组卷机是普通卷积和深度可分离卷积的一个折中方案，即每个分支产生的Feature Map的通道数为 [公式]
2017年 SENet
SENet是ImageNet 2017（ImageNet收官赛）的冠军模型，和ResNet的出现类似，都在很大程度上减小了之前模型的错误率），并且复杂度低，新增参数和计算量小。下面就来具体介绍一些SENet的神奇之处。
SENet的全称是Squeeze-and-Excitation Networks，中文可以翻译为压缩和激励网络。主要由两部分组成：
Squeeze部分。即为压缩部分，原始feature map的维度为HWC，其中H是高度（Height），W是宽度（width），C是通道数（channel）。Squeeze做的事情是把HWC压缩为11C，相当于把HW压缩成一维了，实际中一般是用global average pooling实现的。HW压缩成一维后，相当于这一维参数获得了之前H*W全局的视野，感受区域更广。
Excitation部分。得到Squeeze的11C的表示后，加入一个FC全连接层（Fully Connected），对每个通道的重要性进行预测，得到不同channel的重要性大小后再作用（激励）到之前的feature map的对应channel上，再进行后续操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be91741fc6dec2bbd3ceba1375f2641/" rel="bookmark">
			美团（Leaf）分布式ID生成器，好用的一批！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不了解分布式ID的同学，先行去看《一口气说出 9种 分布式ID生成方式，面试官有点懵了》温习一下基础知识，这里就不再赘述了
美团（Leaf） Leaf是美团推出的一个分布式ID生成服务，名字取自德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world.”（“世界上没有两片相同的树叶”），取个名字都这么有寓意，美团程序员牛掰啊！
Leaf的优势：高可靠、低延迟、全局唯一等特点。
目前主流的分布式ID生成方式，大致都是基于数据库号段模式和雪花算法（snowflake），而美团（Leaf）刚好同时兼具了这两种方式，可以根据不同业务场景灵活切换。
接下来结合实战，详细的介绍一下Leaf的Leaf-segment号段模式和Leaf-snowflake模式
一、 Leaf-segment号段模式 Leaf-segment号段模式是对直接用数据库自增ID充当分布式ID的一种优化，减少对数据库的频率操作。相当于从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，业务服务将号段在本地生成1~1000的自增ID并加载到内存.。
大致的流程入下图所示：
号段耗尽之后再去数据库获取新的号段，可以大大的减轻数据库的压力。对max_id字段做一次update操作，update max_id= max_id + step，update成功则说明新号段获取成功，新的号段范围是(max_id ,max_id +step]。
由于依赖数据库，我们先设计一下表结构：
CREATE TABLE `leaf_alloc` ( `biz_tag` varchar(128) NOT NULL DEFAULT '' COMMENT '业务key', `max_id` bigint(20) NOT NULL DEFAULT '1' COMMENT '当前已经分配了的最大id', `step` int(11) NOT NULL COMMENT '初始步长，也是动态调整的最小步长', `description` varchar(256) DEFAULT NULL COMMENT '业务key的描述', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '数据库维护的更新时间', PRIMARY KEY (`biz_tag`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 预先插入一条测试的业务数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be91741fc6dec2bbd3ceba1375f2641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aede1137cbf8b17150549a253780b871/" rel="bookmark">
			MYSQL &#43; JAVA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在拉钩教育学完了JAVA部分收获非常多，能编写网络程序以及多线程程序，这是我之前任何一门语言都没有达到过的高度，包括面向对象的知识，让我和我对象有了更多的相处时间（误），那么下一个部分就是MYSQL的友情出演了，开心学习叭~
正文（学习笔记） 我的mysql忘了root密码，但是居然非常贴心的登录上去了，我也是非常疑惑，不管了继续吧
基本分类嗷铁子
写个代码试试
美好的一天从创建一个弱智表格开始
如果查看创建了多少表就使用 show tables
可以看到已经创建了三个弱智表了
查看表格的结构信息使用desc 表名
会创建当然也要会删除啦
修改表名
果然非常好用
字段可以创建新的，当然也要会修改
第二种修改
修改结果
实力练习 1.创建学生表
2.插入数据
第一种方式，写字段名，并且赋值
第二种方式，插入全部字段，可以不用写字段名
第三种方式
以上方式完成了对表格的增加，那么如何修改呢，对表格式修改使用alter
对内容修改使用update
接下来试一下使用排序
如果排序的第一列出现了重复那么该如何是好呢
就是再选一列数据然后按照另一列数据的大小进行排序
筛选薪资大于6000的部门
1.把待判断的部门挑选出来
2.筛选薪资大于6000
如何判别where和having的区别
delete不影响自增，从之前最后一个开始
truncate直接将自增清零，从1开始
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15dfb0384b6e5cde6a44f82fe9b7a160/" rel="bookmark">
			在 ES5 中判断函数如何被调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 ES5 中判断函数是不是使用了 new 来调用（即作为构造器）,最流行的方式是使用 instanceof ， 例如：
function Person(name) { if (this instanceof Person) { this.name = name; // 使用 new } else { throw new Error("You must use new with Person.") } } var person = new Person("Nicholas"); var notAPerson = Person("Nicholas"); // 抛出错误 此处对 this 值进行了检查，来判断其是否为构造器的一个实例：若是，正常继续执行；否 则抛出错误。这能奏效是因为 [[Construct]] 方法创建了 Person 的一个新实例并将其赋值 给 this 。可惜的是，该方法并不绝对可靠，因为在不使用 new 的情况下 this 仍然可能 是 Person 的实例，正如下例：
function Person(name) { if (this instanceof Person) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15dfb0384b6e5cde6a44f82fe9b7a160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5f057467038bc744bc91bc9ba70cf0/" rel="bookmark">
			ORA-30926: 无法在源表中获得一组稳定的行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.springframework.jdbc.UncategorizedSQLException: ### Error updating database. Cause: java.sql.SQLException: ORA-30926: 无法在源表中获得一组稳定的行
### The error may involve package.class.method-Inline
### The error occurred while setting parameters
### SQL: MERGE INTO ...
### Cause: java.sql.SQLException: ORA-30926: 无法在源表中获得一组稳定的行
; uncategorized SQLException for SQL []; SQL state [99999]; error code [30926]; ORA-30926: 无法在源表中获得一组稳定的行
; nested exception is java.sql.SQLException: ORA-30926: 无法在源表中获得一组稳定的行
问题复现：假设ID为UUID且是主键
MERGE INTO tableName t1 USING ( SELECT ? AS ID, ? AS XUEHAO, ? AS NAME FROM dual UNION SELECT ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5f057467038bc744bc91bc9ba70cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70d42e9d32ed69948fbf2e8163965d9/" rel="bookmark">
			性能测试系列（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能测试之性能分析命令 1.CPU分析 a.cpu基本信息 命令：lscpu
Cpu架构 64 位Cpu 核心数 6NUMA UMA节点数为 2个（显示值加 1）Cpu的核心频率说明此服务器为虚拟机此服务器的 cpu使用的是 使用的是 numa node0的 0-5号 cpu b.vmstat工具得使用 命令：vmstat 1 60 &gt; /tmp/cpu.txt说明：每秒采样1次，共采集100次格式化显示： cat /tmp/cpu.txt|column -t
1）procs a.r 列表示运行和等待 CPU时间片的进程数，这个值如果长期大于系统 时间片的进程数， 就说明CPU资源不足，可以考虑增加CPU；b.b列表示在等待资源得进程数，比如正在等待I/0或者内存交换等 2）memory a.swpd：表示切换到内存交换区得内存数据量（以KB为单位）。如果swpd得值不为0或者比较大，而且si，so值长期为0，那么这种情况一般不用担心，不会影响系统性能；b.free：表示当前空闲得物理内存数量（以KB为单位）c.buff：表示buffers cache得内存数量，一般对块设备得读写才需要缓冲；d.cache：表示page cached得内存数量，一般作文件系统得cached，频繁访问得文件都会被cached。如果cached值比较大，就说明cached文件数较多。如果次试IO中得bi比较小，就说明文件系统效率比较好； 3）swap a.si：表示由磁盘调入内存，也就是内存进入内存交换区得数量；b.so：表示由内存调入磁盘，也就是内存交换区进入内存得数量；
一般来说：si，so得值都为0，如果si，so得值长期不为0，则表示系统内存不足，需要考虑是否增加系统内存 4）IO a.bi：表示从块设备读入得数据总量（即读磁盘，单位kb/s）；b.bo：表示写入到块设备数据总量（即写磁盘，单位kb/s）；
一般来说：这里设置的bi+bo参考值为参考值为1000，如果超过1000，而且wa值比较大，则表示系统磁盘IO性能瓶颈。（需要根据具体得硬件性能评估） 5）system a.in：表示在某一时间间隔中观察到得每秒设备中断数；b.cs：表示每秒生产得上下文切换次数；
一般来说：上面这两个值越大，会看到内核消耗得cpu时间就越多 6）CPU a.us：显示了用户进程消耗cpu得时间百分比；b.sy：显示了内核进程消耗cpu得时间百分比；sy得值比较高时，就说明内核消耗得cpu时间多；如果us+sy超过80%，就说明cpu得资源存在不足。c.id：显示了cpu处在空闲状态得时间百分比；d.wa：显示IO等待所占用cpu时间百分比。wa值越高，说明io等待越严重。如果wa值超过20%，说明IO等待严重e.st：虚拟机占用的时间百分比（一般不关注） 经验总结：
cpu一般被充分利用的大概的范围
us：65% - 70%
sy：30% - 35%
id：0% - 5%proce中的r运行队列数不要超出每个处理器3个可运行状态线程的限制sy如果比较高一般时in（中断）和cs（上下文切换），可根据情况开启RPS或者减少应用的线程池 c.mpstat工具得使用 命令：mpstat -P ALL 1说明：每秒采样1次CPU各个核心的使用资源情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846dcd0d7acbab570ebe3e51f4e7b6cf/" rel="bookmark">
			城市三级联动vue&#43;elementUI详解(对象数组类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		城市三级联动vue+elementUI详解 效果图一.基础数据引入二.template内的代码三.methods内的代码四.代码解析:五.备注: 效果图 一.基础数据引入 1.在&lt;script&gt;里提前引入area.js文件
area.js文件下载链接(下载资源已通过,下载链接已更新,已设置免费下载)
import area from "../api/area.js"; 2.同时在data()里定义一个变量cityDataStart接收所有城市的对象数组,并建立两个空数组来对应接收市级数组cityArrStart: [],和区级数组 regionArrStart: [],
data() { return { // 城市联动 // 发货 cityDataStart: {}, cityArrStart: [], regionArrStart: [], } 3.在created() { }创建时,给cityDataStart赋值
created() { this.cityDataStart = area.arrAll; } 4.准备工作结束.
二.template内的代码 &lt;template&gt;代码如下:
&lt;el-form-item label="发货省市:" required&gt; &lt;div style="display:flex"&gt; &lt;el-select v-model="editForm.startProvice" @change="updateCityStart()"&gt; &lt;el-option v-for="(option,index) in cityDataStart" :value="option.name" :key="index" @click.native="updateCityStart()" &gt;{{ option.name }}&lt;/el-option&gt; &lt;/el-select&gt; &lt;el-select v-model="editForm.startCity" @change="updateDistrictStart()"&gt; &lt;el-option v-for="(option,index) in cityArrStart" :value="option.name" :key="index" @click.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846dcd0d7acbab570ebe3e51f4e7b6cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c177618d01a2bf0bdfdeb9a47bdf759a/" rel="bookmark">
			MyBatis-Plus的基础使用、以及基础代码自动生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的框架是基于：Spring Boot + MyBatisPlus 实现的。
步骤：
基础操作：
a）、添加maven依赖； &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.dc.xcj&lt;/groupId&gt; &lt;artifactId&gt;issue&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;issue&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus 代码自动生成依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c177618d01a2bf0bdfdeb9a47bdf759a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a047cf5b84c554972f239ea65ff0d9ff/" rel="bookmark">
			minio的安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、概述二、下载二进制文件安装minio三、spring boot整合使用minio1、使用maven引入minio依赖2、在`application.yml`中定义连接`minio`的参数3、定义一个`MinioUtil.java`工具类 四、总结 一、概述 最近在学习使用minio，在这里对自己的学习过程做一个记录和总结，方便自己查阅。
Minio是GlusterFS创始人之一Anand Babu Periasamy发布新的开源项目。Minio兼容Amason的S3分布式对象存储项目，采用Golang实现，客户端支持Java、Python、Javacript、 Golang语言。
Minio可以做为云存储的解决方案用来保存海量的图片，视频，文档。由于采用Golang实现，服务端可以工作在Windows、Linux、 OS X和FreeBSD上。安装和配置非常简单，基本是复制可执行程序，单行命令就可以运行起来。minio还可以通过容器部署以及部署到k8s集群，详细部署方式可以查看官方文档。
minio中文官方文档地址： https://docs.min.io/cn/
minio的源码地址：https://github.com/minio/minio
二、下载二进制文件安装minio 使用如下命令快速安装一个单机minio
# 下载 minio wget https://dl.min.io/server/minio/release/linux-amd64/minio # 添加可执行权限 chmod +x minio # 设置登录minio的 access key export MINIO_ACCESS_KEY=minioadmin # 设置登录minio的 secret key export MINIO_SECRET_KEY=minioadmin # 启动 minio ./minio server /data 安装后使用浏览器访问http://127.0.0.1:9000，如果可以访问，则表示minio已经安装成功。输入上面自定义的access key 和 secret key就可以登录了。
三、spring boot整合使用minio 1、使用maven引入minio依赖 在pom.xml中添加如下依赖，minio的最新依赖版本可以到maven中央仓库搜索，这里使用的最新版7.1.0
&lt;properties&gt; &lt;minio.version&gt;7.1.0&lt;/minio.version&gt; &lt;/properties&gt; &lt;!-- minio --&gt; &lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;${minio.version}&lt;/version&gt; &lt;/dependency&gt; 2、在application.yml中定义连接minio的参数 # minio 连接参数 minio: endpoint: 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a047cf5b84c554972f239ea65ff0d9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f896c3cee8f355aff4830db09033a77f/" rel="bookmark">
			java通过jdbc向数据库中添加数据时汉字出现？？？问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习jdbc时发现向数据库中输入数据时汉字出现乱码
这是因为连接url的编码设置问题。
最简单的方法就是在连接路径后面加：?useUnicode=true&amp;characterEncoding=utf8
加了后在运行就发现数据已经被加入进去了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e556a82cb4833ebedcc0749b45fcf4/" rel="bookmark">
			（3）PCIE中断简介（学无止境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 引言
FPGA与CPU进行数据交互时，一般需要进行DMA操作，包括读DMA和写DMA操作。读/写DMA一些控制信号一般需要通过中断的方式实现；例如：DMA开始、DMA结束等。
2 PCIE中断简介
PCIE有三种中断类型，分别为Leagcy Interupt，MSI Interupt，MSI-X Interupt。DMA控制信号也是通过这三种中断类型之一实现。
一般采用MSI Interupt中断，Leagcy Interupt是延续PCI总线中断机制，也就是说PCIE总线兼容PCI中断。MSI-X Interupt暂时没有研究，后续会学习。MSI Interupt采用Message TLP消息包的方式来传递中断。
3 逻辑设计
基于Xilinx FPGA实现PCIE中断逻辑设计包括两个部分，第一部分，通过PCIE IP核中断配置界面配置中断相关参数；第二部分，通过编写中断模块，控制FPGA中断上报给CPU，CPU接收中断并进行相应得处理。
说明： PCIe IP核发送Interupt时，不需要用户按照Message TLP方式来发送这种信号，只需要控制一些中断控制信号即可（实际上只需要3个信号就能发送中断）。
注意：若想知道PCIE IP核当前被软件启用了哪种中断方式，需要通过两个控制信号来判断。
4 遇到问题
1）FPGA发送中断到CPU，CPU接收不到中断信号？
5 结束语
希望对你有帮助，如果遇到问题，可以一起沟通讨论，邮箱：jhqwy888@163.com。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdfc4d649319379aa3ad1500d620066f/" rel="bookmark">
			js截取逗号（符号可变）前/后的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目开发经常会遇到截取字符串的情况,下面是用split方法来截取,符号以逗号为例,符号可任意改变,看开发需求
1. 截取逗号以前的字符串
//截取逗号前的字符串 var str="1001,1"; console.log(str.split(',')[0]) //打印结果为:1001 2. 截取逗号以后的字符串
//截取逗号后的字符串 var str="1001,1"; console.log(str.split(',')[1]) //打印结果为:1 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/209/">«</a>
	<span class="pagination__item pagination__item--current">210/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/211/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>