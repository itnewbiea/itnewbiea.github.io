<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913b961c0aeebcb2b0271406ad5b656f/" rel="bookmark">
			RFC3261: SIP:11.2 OPTIONS请求的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.2 Processing of OPTIONS Request 11.2 OPTIONS请求的处理 The response to an OPTIONS is constructed using the standard rules for a SIP response as discussed in Section 8.2.6. The response code chosen MUST be the same that would have been chosen had the request been an INVITE. That is, a 200 (OK) would be returned if the UAS is ready to accept a call, a 486 (Busy Here) would be returned if the UAS is busy, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913b961c0aeebcb2b0271406ad5b656f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6423e7900a0602d7dd876014dc13fd81/" rel="bookmark">
			第二章 HTTP请求方法、状态码详解与缓存机制解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 请求方法（GET、POST、PUT、DELETE等）及其应用场景 本质上只有get和post请求，其他都是post请求
1.1 GET 定义：GET是HTTP中最常用的方法，用于从服务器获取资源。特点： 请求参数通常放在URL的查询字符串中，即?key1=value1&amp;key2=value2格式。GET请求可被浏览器缓存，并且会被保存在浏览历史记录中。（不理解没关系，后面会单独说）2m的数据限制。不应有副作用，也就是说，它不应该改变服务器上的资源状态。 应用场景： 获取静态页面内容。查询数据库以获取列表信息或详情信息。 1.2 POST 定义：POST方法用于向指定资源提交数据，请求被包含在请求体中，可能引起服务器端资源的创建、更新或操作。特点： 数据不会显示在URL中，而是通过请求体传输，可以携带大量数据。可能会有副作用，比如新增用户信息、发表评论等操作。非幂等性：多次执行相同的POST请求可能会有不同的结果，例如每次提交都会创建一个新的资源实例。 应用场景： 提交表单数据。创建新的资源，如添加一篇文章、上传文件等。 POST请求的请求体（Body）是用来承载客户端要发送给服务器的数据部分，根据不同的应用场景和内容类型（Content-Type），请求体的内容格式会有所不同。对于上传文件的情况，通常采用multipart/form-data、application/x-www-form-urlencoded、application/json。
multipart/form-data：
这是最常见的文件上传方式，尤其在HTML表单中通过&lt;input type="file"&gt;元素选择文件时，默认使用此Content-Type。请求体被划分为多个部分（parts），每个部分包含一个或多个字段及其对应的值，文件字段则包含了文件内容本身。每个部分都有自己的Header描述信息，例如：
--boundary_string Content-Disposition: form-data; name="field1" value1 --boundary_string Content-Disposition: form-data; name="file"; filename="example.txt" Content-Type: text/plain ... file contents here ... --boundary_string-- 在这个例子中，“boundary_string”是一个由服务器指定或者浏览器自动生成的分隔符，用于区分各个部分。文件字段通过Content-Disposition头部中的filename属性来标识上传文件的名字，并且其内容紧跟在头部后面。
application/x-www-form-urlencoded：
尽管这种Content-Type也能上传少量数据，但不适合大文件或二进制文件的上传，因为这种方式下所有的键值对都会被编码为一串连续的字符序列，例如：
field1=value1&amp;file=encoded_file_contents 对于文件内容，通常是不现实的将其编码成URL安全的形式并作为请求体的一部分。
在实际编程过程中，比如使用Python的requests库、JavaScript的Fetch API或XMLHttpRequest等工具，都需要正确设置Content-Type，并将文件内容以适当的方式添加到请求体中。例如，在requests库中，可以这样上传文件：
import requests url = 'https://example.com/upload' files = {'file': ('example.txt', open('path_to_your_file.txt', 'rb'))} response = requests.post(url, files=files) 这里open('path_to_your_file.txt', 'rb')用来打开文件并以二进制读取模式准备上传，requests库会自动处理请求头和请求体的格式化工作。
在使用multipart/form-data格式上传文件时，除了基本的文件内容传输外，还可以携带其他非文件字段数据。例如，在一个表单中可能同时包含文本输入框和其他控件的数据，整个POST请求体将会包括这些额外信息：
--boundary_string Content-Disposition: form-data; name="title" File Title --boundary_string Content-Disposition: form-data; name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6423e7900a0602d7dd876014dc13fd81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db63b1c140adbafcb1c20e42c68f96e5/" rel="bookmark">
			MyBatis-Plus框架学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先赞后看，养成习惯！！！❤️ ❤️ ❤️
文章码字不易，如果喜欢可以关注我哦！
​如果本篇内容对你有所启发，欢迎访问我的个人博客了解更多内容：链接地址
MyBatisPlus （简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在==简化开发、提高效率==
MP的特性:
无侵入：只做增强不做改变，不会对现有工程产生影响强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作支持 Lambda：编写查询条件无需担心字段写错支持主键自动生成内置分页插件 标准增删查改 分页功能 基础的增删改查就已经学习完了，刚才我们在分析基础开发的时候，有一个分页功能还没有实现，在MP中如何实现分页功能，就是咱们接下来要学习的内容。
分页查询使用的方法是:
IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper) IPage:用来构建分页查询条件Wrapper：用来构建条件查询的条件，目前我们没有可直接传为NullIPage:返回值，你会发现构建分页条件和方法的返回值都是IPage IPage是一个接口，我们需要找到它的实现类来构建它，具体的实现类，可以进入到IPage类中按ctrl+h,会找到其有一个实现类为Page。
@Test void testSelectPage(){ //1 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数 IPage&lt;User&gt; page=new Page&lt;&gt;(1,3); //2 执行分页查询 userDao.selectPage(page,null); //3 获取分页结果 System.out.println("当前页码值："+page.getCurrent()); System.out.println("每页显示数："+page.getSize()); System.out.println("一共多少页："+page.getPages()); System.out.println("一共多少条数据："+page.getTotal()); System.out.println("数据："+page.getRecords()); DQL编程控制 查询相关的操作
增删改查四个操作中，查询是非常重要的也是非常复杂的操作，这块需要我们重点学习下，这节我们主要学习的内容有:
条件查询方式查询投影查询条件设定字段映射与表名映射 条件查询 lt: 小于(
gt：大于(&gt;)
第一种:==QueryWrapper==
第二种:==QueryWrapper的基础上使用lambda==
第三种:==LambdaQueryWrapper==
多条件查询 构建多条件的时候，可以支持链式编程 LambdaQueryWrapper&lt;User&gt; lqw = new LambdaQueryWrapper&lt;User&gt;(); lqw.lt(User::getAge, 30).gt(User::getAge, 10); List&lt;User&gt; userList = userDao.selectList(lqw); System.out.println(userList); 查询数据库表中，年龄小于10或年龄大于30的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db63b1c140adbafcb1c20e42c68f96e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab387380ec67cab5eb172c12b5c586e/" rel="bookmark">
			51单片机四位数码管计算器 Proteus仿真程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概要
仿真图
部分代码
资料下载地址：51单片机四位数码管计算器 Proteus仿真程序 概要 1.系统通过4x4的矩阵键盘输入数字及运算符。 2.可以进行4位十进制数以内的加法运算，如果计算结果超过4位十进制数，则屏幕显示E 3.可以进行加法以外的计算 (乘、除、减) 。 仿真图 部分代码 void main(){ while(1){ keyScan(); pd(); display(num); } } void keyAdd(){ if(numKey&lt;10000){ num=num*10+numKey; numKey=10000; } } void pd(){ keyAdd(); if(fuhao=='c'){ num=0; num0=0; fuhao0='0'; fuhao='0'; } if(fuhao=='+'){ fuhao0='+'; fuhao='0'; num0=num; num=0; } if(fuhao=='-'){ fuhao0='-'; fuhao='0'; num0=num; num=0; } if(fuhao=='*'){ fuhao0='*'; fuhao='0'; num0=num; num=0; } if(fuhao=='/'){ fuhao0='/'; fuhao='0'; num0=num; num=0; } if(fuhao=='='){ if(fuhao0=='+')num=num0+num; else if(fuhao0=='-')num=num0-num; else if(fuhao0=='*')num=num0*num; else if(fuhao0=='/')num=num0/num; fuhao='0'; num0=0; } } void keyScan(){ P3=0xef;//1110 1111 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab387380ec67cab5eb172c12b5c586e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25c349c34436ed5298df6b33785c348/" rel="bookmark">
			小数的精度——加减算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 多个数据的累加操作，传递一个数组即可 // 小数相加精度计算 arr: [1.11, 2.333, 4.2333]，需要多个值累计的操作，调用的时候传递进去一个数组。 // 原理：对数据进行遍历统一先乘以一个较大的整数进行累加，完成后对得到的数据进行除即可解决 export const decimal_NUM = (arr) =&gt; { let initial = 0 arr.forEach(c =&gt; { c = Number(c) * 100000000 initial = initial + Number(c) }) return initial / 100000000 } 2. 小数相减的处理,传递两个参数即可 // 小数相减 5.9 - 3.1 export const Number_SubAll = (arg1, arg2) =&gt; { var re1, re2, m, n try { re1 = arg1.toString().split('.')[1].length } catch (e) { re1 = 0 } try { re2 = arg2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25c349c34436ed5298df6b33785c348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ce49ec834297b12e6752f62a3a8785/" rel="bookmark">
			springboot集成eureka、eureka获取服务列表、EurekaURI路径存在未授权访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分为3个项目来讲解: 注册中心，provider，consumer
文章目录 注册中心provider项目consumer效果其他配置例子eureka清理无效节点的默认时间 eureka获取服务列表eureka后台如何看注册的服务 安全漏洞 EurekaURI路径存在未授权访问 注册中心 注册中心pom.xml添加：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; 再添加(注意这个version目前是Hoxton.SR1，以后升级了可能会变):
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; application.yml
server: port: 8761 eureka: instance: hostname: eureka-server #eureka实例的主机名 client: register-with-eureka: false #不注册本身到Eureka注册中心 fetch-registry: false #不从Eureka注册中心获取服务的注册信息 service-url: defaultZone: http://localhost:8761/eureka/ EurekaSpringBootApplication代码：
@EnableEurekaServer//启用Eureka服务 @SpringBootApplication public class EurekaSpringBootApplication { public static void main(String[] args) { SpringApplication.run(EurekaSpringBootApplication.class, args); } } 启动项目，访问：http://localhost:8761/ 即可看到注册中心页面。
provider项目 除了注册中心刚才添加的，pom.xml额外添加：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ce49ec834297b12e6752f62a3a8785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3deb8b7808f96335653093a3af4f985/" rel="bookmark">
			POD进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pod的生命周期开始
1 k8s的pod重启策略：Always(默认，deployment的yaml文件只能是Always)pod的yaml文件三种模式都可以，不论正常退出还是非正常退出都重启
2 OnFailure:只有状态码非0才会重启，正常退出是不重启的
3 Never：正常退出和非正常退出都不重启
这三个状态都是容器退出了pod才会重启或不重启
Pod可以有多个容器，只要有一个容器退出，整个pod都会重启，pod内 的所有容器都会重启
docker的重启策略
never Docker：的默认策略是never
on-Failure 也就是非正常退出才会重启容器
always 只要容器退出都会重启
Unless-stopped
只要容器退出就会重启，docker守护进程已经停止的容器，不再重启
Yaml文件快速生成
[root@master01 ~]# kubectl create deployment nginx1 --image=nginx:1.22 --replicas=1 --dry-run=client deployment.apps/nginx1 created (dry run) [root@master01 ~]# kubectl create deployment nginx1 --image=nginx:1.22 --replicas=1 --dry-run=client -o yaml &gt; /opt/test1.yaml #--dry-run=client 表示只是调用了api的对象，不执行命令 ， -o yaml表示指定为yaml文件 [root@master01 opt]# kubectl expose deployment nginx-chen --port=80 --target-port=80 --type=NodePort --dry-run=client -o yaml &gt; /opt/test1-service.yaml #生成service模版 Pod状态
常见
Crashloopbackoff：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3deb8b7808f96335653093a3af4f985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b186bb1fe9260853f3662db5d17fbc47/" rel="bookmark">
			为了搞项目，我差点把京东 “爬“ 了个遍。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在重构我的准备 智慧校园助手2.0 ，奈何之前的相关数据放在服务器被小黑子黑了，准备重新搞点数据，借此和大家分享一波我之前做项目没数据该咋搞 👀。
Java面试指南 &amp; 大厂学习导航：www.java2top.cn
完整源码获取：v 搜 [小龙coding] 回复 jd_spider
事情是这样的：
项目中有一个关于电商的模块，奈何没有数据，然后打算爬取京东，淘宝pc端数据，但是有些图片放在手机端尺寸不符合，综合考虑，决定爬取京东手机端网页数据
相关链接：
我的项目《基于人工智能的智慧校园助手v1.0.0》部分功能展示
www.bilibili.com/video/BV1XT…
《京东商城》
so.m.jd.com/webportal/c…
智慧助手2.0做了全新架构迭代与功能升级，后面开源给大家，一个面试求职学习的好项目~
我们先看看最后部分数据截图吧，对啦，爬取的数据全部保存为了json 数据，方便各处使用。
最后得到了几十万条数据，然后全部导入了 ElasticSearch 构建了强大的搜索系统与推荐中心。
在此期间，遇到很多问题，也学到很多新知识。我认为，不是你主要从事Java就只会Java相关，语言只是工具，是为了方便我们自身，所以具体应用场景使用什么方便就怎么来吧。当然，Java也可以爬虫，但是我个人感觉没有python强大与方便。
本文记录了我整个过程的所思所想，从开始到结束所有想法思路的产生与遇到的各种问题，然后是怎样去解决问题的以及自己的一些看法与总结，希望给读者带来新的理解与感悟（无论是从技术还是解决问题的思路）。
补充一句：小龙 python 也不太会，若有不足，欢迎大家留言指正，也可以技术交流大家一起学习讨论进步。
废话不多说，跟着小龙的思路，一步一步来看看吧！！
数据库设计 分类信息表(product_category)
CREATE TABLE product_category( category_id SMALLINT UNSIGNED AUTO_INCREMENT NOT NULL COMMENT '分类ID', category_name VARCHAR(10) NOT NULL COMMENT '分类名称', img VARCHAR(100) NOT NULL COMMENT '分类图片logo', parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '父分类ID--若为0则该层为父类', category_level TINYINT NOT NULL DEFAULT 1 COMMENT '分类层级--该层为该分类第几层', category_status TINYINT NOT NULL DEFAULT 1 COMMENT '分类状态--是否还可继续往下分，是1否0', PRIMARY KEY pk_categoryid(category_id) )ENGINE=innodb COMMENT '商品分类表' 商品信息表(product_info)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b186bb1fe9260853f3662db5d17fbc47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b00944b0ea79ec4500baf3ec2e0dfb5/" rel="bookmark">
			RFC3261: SIP:11.1 OPTIONS请求的构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.1 Construction of OPTIONS Request 11.1 OPTIONS请求的构建 An OPTIONS request is constructed using the standard rules for a SIP request as discussed in Section 8.1.1. ​OPTIONS请求是使用第8.1.1节中讨论的SIP请求的标准规则构建的。 A Contact header field MAY be present in an OPTIONS. OPTIONS中可能存在Contact报头字段。 An Accept header field SHOULD be included to indicate the type of message body the UAC wishes to receive in the response. Typically, this is set to a format that is used to describe the media capabilities of a UA, such as SDP (application/sdp).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b00944b0ea79ec4500baf3ec2e0dfb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32d694884061b2c3e7b089c3aad6d4b/" rel="bookmark">
			C#高级 09 IEnumerable可枚举类型--可迭代类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解Linq操作需先了解IEnumerable可枚举类型–可迭代类型，因为Linq中的很多函数的返回值类型和传入的形参类型都是IEnumerable的。
IEnumerable可枚举类型–可迭代类型
只要一个类型实现了IEnumerable接口，就可以对这个类型进行遍历。
首选来看IEnumerable接口有一个需要实现的方法 GetEnumerator()，它的返回值类型是IEnumerator接口类型的，然后继续深入进去查看IEnumerator接口。
如图IEnumerator接口内部分为三部分：object类型的属性值和两个bool类型的方法
所以当我们使用IEnumerable时，将一个类继承它，然后需要实现一个返回值类型为IEnumerator类型的GetEnumerator()方法。给出示例代码如下所示：
class Student : IEnumerable { public int Id { get; set; } public IEnumerator GetEnumerator() { // yield关键词他是一个迭代器，相当于实现了IEnumerator枚举器 //yield return "Ant编程1"; //yield return "Ant编程2"; //yield return "Ant编程3"; string[] student = { "Ant编程1", "Ant编程2", "Ant编程3" }; return new StudentEnumerator(student); } } internal class StudentEnumerator : IEnumerator { string[] _student; int _position = -1; public StudentEnumerator(string[] student) { this._student = student; } public object Current { get { if (_position == -1) { throw new InvalidOperationException(); } if (_position &gt;= _student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32d694884061b2c3e7b089c3aad6d4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce312b537b72fd2813ece6f072decbc/" rel="bookmark">
			Idea live template
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1:打印入参日志的配置
log.info("$methodName$ 方法入参: $argsLog$",$argsJson$); methodName:methodName()
argsLog:groovyScript( "def result=''; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) { result+= params[i] + ((i &lt; params.size() - 1) ? ':[{}], ' : ':[{}]') }; return result" , methodParameters())
argsJson:groovyScript(" def result=''; def types = 'String,int,Integer,long,Long,float,Float,double,Double,byte,Byte,short,Short,char,Char,boolean,Boolean'; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]','').split(',').toList(); def paramTypes=\"${_2}\".replaceAll('[\\\\[|\\\\]|\\\\s]','').split(',').toList(); for(i = 0; i &lt; params.size(); i++) { if(types.contains(paramTypes[i].replace('java.lang.',''))){ result+=params[i] + ((i &lt; params.size() - 1) ? ', ' : ''); }else{ result+='JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce312b537b72fd2813ece6f072decbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0492ca6b0d342eb31e38a50a4164eeb/" rel="bookmark">
			深入理解Nginx与Ribbon的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Nginx与Ribbon的区别 Nginx的概述 Nginx是一个高性能的反向代理服务器，同时也是一个通用的Web服务器。它最初由Igor Sysoev创建，后来成为了一个开源项目。Nginx的设计目标之一是提供高性能和可扩展性，使其成为处理高流量和并发连接的理想选择。
1. 定位与应用场景 Nginx通常位于服务端，充当客户端和后端服务器之间的中间层。它可以应用于以下场景：
反向代理： 将客户端的请求分发到多个后端服务器上，以提高应用程序的可用性和性能。
负载均衡： Nginx支持多种负载均衡算法，如轮询、IP哈希、最小连接数等，用于均衡地分发请求到后端服务器。
静态文件服务： Nginx能够高效地处理静态文件，提供快速的文件传输服务。
SSL终结： 作为SSL终结点，Nginx负责解密加密的SSL流量，将明文的请求传递给后端服务器。
2. 负载均衡策略 Nginx支持多种负载均衡策略，其中常见的包括：
轮询（Round Robin）： 将请求按顺序分发到后端服务器，每个服务器逐个接收请求。
IP哈希： 根据客户端IP地址将请求发送到固定的后端服务器，这有助于保持会话状态。
最小连接数： 将请求发送到当前连接数最少的后端服务器，以实现负载均衡。
3. 高级特性 Nginx提供了许多高级特性，使其在各种场景中广泛应用：
反向代理缓存： 可以缓存响应，减轻后端服务器的负担，提高响应速度。
反向代理SSL： 可以处理SSL终结，解密SSL流量并将请求传递给后端的非加密服务。
动态模块： 可以通过动态模块的方式灵活扩展功能，满足各种特定需求。
HTTP/2支持： Nginx支持HTTP/2协议，提供更快的页面加载速度和更高的性能。
Ribbon的概述 Ribbon是Netflix开源的一个客户端负载均衡库，旨在帮助服务消费者选择合适的服务实例进行请求。与Nginx位于服务端不同，Ribbon直接嵌入在服务消费者的代码中，为微服务架构提供了强大的负载均衡解决方案。
1. 定位与应用场景 Ribbon的主要定位是服务消费者端的负载均衡，其应用场景主要包括：
服务消费者端的负载均衡： Ribbon在服务消费者端选择合适的服务实例，确保请求得到均衡分发。
微服务架构中的应用： Ribbon是Netflix开源的一部分，因此在Netflix的微服务架构中得到广泛应用。
动态服务实例更新： Ribbon支持动态地获取服务注册中心的服务列表，并实时更新本地的服务实例列表。
2. 工作原理 Ribbon的工作原理主要包括以下几个步骤：
服务注册： 服务提供者将自身注册到服务注册中心，定期发送心跳以保持注册信息的最新状态。
服务发现： Ribbon客户端通过与服务注册中心交互，获取可用服务实例的列表，这个列表是动态更新的。
负载均衡： Ribbon根据配置的负载均衡策略（如轮询、随机、加权轮询等），选择一个合适的服务实例。
请求转发： Ribbon将请求发送到选定的服务实例，确保请求的稳定转发。
3. 负载均衡策略 Ribbon提供了多种负载均衡策略，开发者可以根据具体需求进行配置，例如：
轮询（Round Robin）： 逐个选择服务实例，确保请求均匀地分布到不同的实例。
随机： 随机选择一个服务实例，使请求具有一定的随机性。
加权轮询： 根据服务实例的权重，按比例分配请求，适用于不同性能的实例。
4. 高级特性 除了基本的负载均衡功能之外，Ribbon还提供了一些高级特性，以应对分布式系统中的复杂情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0492ca6b0d342eb31e38a50a4164eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065c12a3bdd71fbc8fe9915e1c569b3a/" rel="bookmark">
			鸿蒙学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DevEco Studio, ArkTS, ArkUI, ArkCompiler, DevEco Testing是啥 DevEco Studio是华为开发的一款集成开发环境（IDE），用于开发基于华为鸿蒙操作系统（HarmonyOS）的应用程序。它提供了丰富的开发工具和功能，包括代码编辑器、调试器、模拟器、版本控制等，使开发者能够方便地创建、调试和发布应用程序。
ArkTS（Ark Type Script）是鸿蒙生态的应用开发语言。它在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了声明式UI、状态管理等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用。
ArkUI是华为鸿蒙操作系统的用户界面框架，用于构建应用程序的用户界面。它提供了一系列的UI组件和布局管理器，开发者可以使用这些组件来创建各种各样的界面，如按钮、文本框、列表等。ArkUI还支持主题定制和动画效果，使应用程序的界面更加美观和交互性强。
ArkCompiler是华为鸿蒙操作系统的编译器，用于将开发者编写的应用程序源代码转换为可执行的二进制代码。它采用静态编译方式，能够在编译时对代码进行优化和验证，提高应用程序的性能和安全性。
DevEco Testing是华为鸿蒙操作系统的测试工具，用于对应用程序进行自动化测试。它提供了一系列的测试框架和工具，包括单元测试、集成测试、UI测试等，帮助开发者检测和修复应用程序中的错误和问题，提高应用程序的质量和稳定性。
OpenHarmony vs HarmonyOS 关于这个可以看鸿蒙、OpenHarmony、HarmonyOS傻傻的分不清楚。。。看这篇就够了
以下是OpenHarmony和AOSP的架构图，虽然画法不一样，但是从架构图看起来架构是差不多，差异就是各家的在各层的功能实现以及上层提供的API和使用语言上的差异了。
相关文档 我是先看了白皮书，知道鸿蒙开发是个啥，了解了基本的概念然后再看的指南，根据指南用到的API再看对应的API参考。
开发者主页：https://developer.huawei.com/consumer/cn/开发者指南：https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/start-overview-0000001478061421-V2?catalogVersion=V2API参考：https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/syscap-0000001408089368-V2?catalogVersion=V2示例代码：https://developer.huawei.com/consumer/cn/hmos/samples/?catalogVersion=V2鸿蒙生态应用开发白皮书： https://developer.huawei.com/consumer/cn/doc/harmonyos-bpsOpenHarmony的示例代码：https://gitee.com/openharmony/applications_app_samplesHarmonyOS的示例代码：https://gitee.com/harmonyos/samples 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22067933670edf8f4177480d9af9a4d9/" rel="bookmark">
			Linux入门攻坚——11、Linux网络属性配置相关知识1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络基础知识：
局域网：以太网，令牌环网，
Ethernet：CSMA/CD
冲突域
广播域
MAC：Media Access Control，共48bit，前24bit需要机构分配，后24bit自己自由使用
IP：Internet Protocol
Routing Protocol
Routed Protocol
传输层协议：tcp、udp、sctp
网络层协议：ip
ip协议：
IPv4地址分类：
点分十进制：0-255
0000 0000 - 1111 1111
0.0.0.0 - 255.255.255.255
A类：
0 000 0000 - 0 111 1111 ： 1-127
网络数：126个,127环回地址；每个网络中的主机数：2^24-2；默认子网掩码：255.0.0.0
私网地址：10.0.0.0/8
B类：
10 00 0000 - 10 11 1111 ： 128-191
网络数：2^14个；每个网络中的主机数：2^16-2；默认子网掩码：255.255.0.0
私网地址：172.16.0.0/16-172.31.0.0/16
C类：
110 0 0000 - 110 1 1111 ： 192-223
网络数：2^21个；每个网络中的主机数：2^8-2；默认子网掩码：255.255.255.0
私网地址：192.168.0.0/24-192.168.255.0/24
D类：组播用
1110 0000 - 1110 1111 ： 224 - 239
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22067933670edf8f4177480d9af9a4d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238877097a7bd06b37f9a056ac8c9140/" rel="bookmark">
			PnP解算及SolvePnp用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 PnP解算 PnP问题：Perspective-n-Point问题。
参考下图，
给定n个3D空间参考点，以及各点在相机图像上对应的成像点，求参考点所在坐标系与相机的空间关系。
即：
已知条件1：给定匹配点对：世界坐标系（图中OwXwYwZw）下的n个3D点坐标及其对应在图像坐标系（图中ouv）下的2D点坐标。
已知条件2：相机的内参。
求：世界坐标系OwXwYwZw与相机坐标系OcXcYcZc之间的位姿变换关系。
PnP问题的用途：相机位姿获取，物体位姿测量，AR/VR，机器人操作，SLAM中位姿初值求解……
常用解法：DLT，P3P，EPnP，UPnP。
2 OpenCV的solvePnP 2.1 函数原型定义 OpenCV提供了PnP问题的解算函数，且包含有多种解法。
有以下两个函数。
1) solvePnP bool solvePnP( InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE ); 作用：根据3D-2D点对应关系，获得物体的位姿。
此函数返回旋转和平移向量，可用来将物体坐标系中的3D点变换到相机坐标系下。
2) solvePnPRansac bool solvePnPRansac( InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238877097a7bd06b37f9a056ac8c9140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9be03a5d2b2935b8511d7ee9b9dc1b1/" rel="bookmark">
			web前端javaScript笔记——（7）Math和Date方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Math
-Math和其他的对象不同，它不是一个构造函数，
它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法
比如
Math.PI 表示的圆周率
使用方法Math.方法();
Math.abs()可以用来计算一个数的绝对值
Math.ceil()可以对一个数进行向上取整
abs(x) 返回数的绝对值。
console.log(Math.abs(-1));
acos(x) 返回数的反余弦值。
asin(x) 返回数的反正弦值。
atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回x的反正切值。
atan2(y,x) 返回从 x轴到点 (x,y)的角度(介于 -PI/2 与 PI/2 弧度之间)。
ceil(x) 可以对一个数进行向上取整，小数位置只要有值就自动进1
cos(x) 返回数的余弦。
exp(x) 返回 e的指数。
floor(x) 可以对一个数进行向下取整，小数部分会被舍掉
log(x) 返回数的自然对数(底为e)。
max(x,y) 返回 x和 y 中的最高值。
min(x,y) 返回 x和 y 中的最低值。
pow(x,y) 返回X的 y次幂。
random() 生成的数字包左不包右
random() 可以用来生成一个0-1之间的随机数
生成一个0-10的随机数 Math.random()*10;
生成一个0-x之间的随机数 Math.random()*x;
round(x) 把数四舍五入为最接近的整数。
可以使用复合的方法 Math.round(Math.random()*X);
生成一个1-10的随机数 Math.round(Math.random()*9+1);
生成一个x-y之间的随机数 Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9be03a5d2b2935b8511d7ee9b9dc1b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dffe47b3621323c27597e62a27569e/" rel="bookmark">
			IMU预计分公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SLAM（Simultaneous Localization and Mapping）中，IMU（Inertial Measurement Unit，惯性测量单元）常用于提供关于移动体（例如机器人或车辆）的加速度和角速度信息，这对于估计运动过程中的位姿变化非常重要。在SLAM中，IMU的数据可以与其他传感器数据（如视觉或激光雷达）一起使用，以更准确地估计系统的运动。
IMU预计分（IMU预积分）是一种方法，它对IMU的测量进行积分，以估计系统的位姿和速度。
实不相瞒，预计分公式推导了N遍了，还是经常会忘，本文不推到公式，仅记录预计分最终结果用于工程使用！！！
以下是IMU预计分的一般形式，其中假设IMU提供的是角速度 ω \omega ω和加速度 a a a：
IMU预计分公式： 1. 位置估计： p ( t + Δ t ) = p ( t ) + v ( t ) Δ t + 1 2 R ( t ) a ( t ) ( Δ t ) 2 p(t+\Delta t) = p(t) + v(t)\Delta t + \frac{1}{2} R(t) a(t) (\Delta t)^2 p(t+Δt)=p(t)+v(t)Δt+21​R(t)a(t)(Δt)2
其中：
p ( t ) p(t) p(t)是时刻 t t t 的位置 v ( t ) v(t) v(t)是时刻 t t t 的速度 R ( t ) R(t) R(t)是时刻 t t t的旋转矩阵 a ( t ) a(t) a(t)是时刻 t t t的加速度 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dffe47b3621323c27597e62a27569e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20460d5b913e3aee30234d1e66646533/" rel="bookmark">
			Java学习——设计模式——行为型模式1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 行为型模式模板方法策略模式命令模式责任链模式 行为型模式 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，涉及算法与对象间职责的分配。
行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分配行为，后者采用组合或聚合在对象间分配行为。由于组合或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。
包括：
1、模板方法
2、策略模式
3、命令模式
4、职责链模式
5、状态模式
6、观察者模式
7、中介者模式
8、迭代器模式
9、访问者模式
10、备忘录模式
11、解释器模式
除了模板方法和解释器模式是类行为型模式，其余都是对象行为型模式
模板方法 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
结构
1、抽象类：给出算法轮廓和骨架
模板方法：定义算法骨架，按顺序调用包含的基本方法基本方法：实现算法各个步骤的方法，是模板方法的组成部分。 抽象方法：由抽象类声明、由其具体子类实现具体方法：由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种 2、 具体子类：实现抽象类中所定义的抽象方法和钩子方法，是一个顶级逻辑的组成步骤
优点
提高代码复用性实现反向控制
通过一个父类调用子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则” 缺点
对每个不同实现都需要定义一个子类，导致类的个数增加，系统更加庞大，设计也更加抽象父类中的抽象方法由子类实现，子类的执行结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度 策略模式 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的用户。
属于对象行为模式，通过堆算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象堆这些算法进行管理。
结构
1、抽象策略类
2、具体策略类
3、环境类
优点
1、策略类之间可以自由切换
2、易于扩展。增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码
3、避免使用多重条件选择语句
缺点：
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2、策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量
命令模式 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。
结构
1、抽象命令类
2、具体命令类
3、实现者/接收者
4、调用者/请求者
优点
1、降低系统耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦
2、增加或删除操作非常方便。
3、可以实现宏命令。
4、方便实现undo和redo操作。
缺点：
1、可能会导致某些系统有过多的具体命令类
2、系统结构更加复杂
责任链模式 又叫职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
结构
1、抽象处理者
2、具体处理者
3、客户类
优点：
缺点：
开始摆烂，学到这里好混乱，感觉学每一种好像懂了，但跟其他的区别又说不上来，又感觉每种模式差不多。。。。。。唉。。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39936b7e7969af6782b8d3c87ef6ad6c/" rel="bookmark">
			第一章 引言-HTTP协议基础概念和前后端分离架构请求交互概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言： 在浩瀚的互联网世界中，HTTP协议如同一座桥梁，将用户与服务器紧密相连。想象一下你正在使用一款在线购物应用：当你浏览商品、添加到购物车或完成支付时，每一次操作都离不开前端页面向后端服务器发送请求，并接收服务器返回的数据。这就是HTTP协议发挥重要作用的生动场景。
HTTP（HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络传输协议，主要用于客户端和服务器之间的通信，特别是在万维网（WWW）上交换数据。它的基础概念包括请求方法（如GET、POST等）、状态码（如200表示成功，404表示未找到资源等）以及头部信息（包含请求头和响应头）。这些概念共同构建了前后端交互的基础规则。
2. HTTP协议基础概念和重要性： HTTP协议（HyperText Transfer Protocol）是互联网上应用最广泛的客户端-服务器通信协议，它为分布式、协作式和超媒体信息系统的应用提供了规范。在Web开发中，HTTP协议扮演着至关重要的角色，负责在浏览器（前端）与服务器（后端）之间传输数据，实现用户界面的动态更新和交互功能。
HTTP基础概念：
2.1 请求/响应模型： 请求（Request）：客户端通过发起HTTP请求来获取资源或提交数据给服务器。请求包括了方法（Method）、URL（Uniform Resource Locator）、HTTP版本、头部（Headers）和可选的请求体（Body）。
GET /api/products HTTP/1.1 Host: example.com Accept: application/json 响应（Response）：服务器接收到请求后，会根据请求内容生成并返回一个HTTP响应。响应也包含了状态码（Status Code）、状态消息（Status Message）、HTTP版本、头部以及可能包含的响应体。
HTTP/1.1 200 OK Content-Type: application/json { "products": [...] } 2.2 请求方法： 就像不同类型的邮递服务一样，HTTP定义了多种请求方法来满足不同的需求。
GET：用于获取指定资源的数据，通常不改变服务器状态。POST：用于向指定资源提交数据，例如提交表单或者创建新资源。PUT：用于替换整个资源，需要客户端提供完整的资源数据。PATCH：用于更新资源的部分内容。DELETE：用于删除指定资源。其他如HEAD、OPTIONS等方法也有特定用途。 例如：
// 使用JavaScript发起一个GET请求获取商品列表 fetch('https://api.example.com/products') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 上述代码展示了如何使用Fetch API发起一个GET请求获取商品列表。而在创建订单时，我们可能会用到POST请求，向服务器发送新订单的数据：
const orderData = { productId: '123', quantity: 2, }; axios.post('https://api.example.com/orders', orderData) .then((response) =&gt; console.log('Order created:', response.data)) .catch((error) =&gt; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39936b7e7969af6782b8d3c87ef6ad6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b356ca0a578eec235311cf1eb776166/" rel="bookmark">
			leetcode 93. 复原 IP 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode 93. 复原 IP 地址
题目 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。
例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
示例 1：
输入：s = “25525511135”
输出：[“255.255.11.135”,“255.255.111.35”]
示例 2：
输入：s = “0000”
输出：[“0.0.0.0”]
示例 3：
输入：s = “101023”
输出：[“1.0.10.23”,“1.0.102.3”,“10.1.0.23”,“10.10.2.3”,“101.0.2.3”]
提示：
1 &lt;= s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b356ca0a578eec235311cf1eb776166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbf263bcee4f391e3b07184975a84b7/" rel="bookmark">
			【附源码】使用python&#43;pygame开发消消乐游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python+pygame开发消消乐游戏附完整源码 消消乐小游戏相信大家都玩过，大人小孩都喜欢玩的一款小游戏，那么基于程序是如何实现的呢？今天带大家，用python+pygame来实现一下这个花里胡哨的消消乐小游戏功能，感兴趣的朋友一起看看吧
目录 一、环境要求二、游戏简介三、完整开发流程 1、项目主结构2、详细配置3、消消乐所有图形加载4、随机生成初始布局、相邻消除、自动下落5、随机初始化消消乐的主图内容 四、如何启动游戏呢？ 1、使用开发工具IDE启动2、命令行启动 效果是这样的 ↓ ↓ ↓
一、环境要求 windows系统，python3.6+ pip21+
开发环境搭建地址
一起来学pygame吧 游戏开发30例（开篇词）——环境搭建+游戏效果展示
安装游戏依赖模块
pip install pygame
二、游戏简介 消消乐应该大家都玩过，或者看过。这个花里胡哨的小游戏
用python的pygame来实现，很简单。
今天带大家，用Python来实现一下这个花里胡哨的小游戏。
三、完整开发流程 1、项目主结构 首先，先整理一下项目的主结构，其实看一下主结构，基本就清晰了
12345678910111213modules：相关定义的Python类位置``——game.py:主模块`` res：存放引用到的图片、音频等等``——audios:音频资源``——imgs:图片资源``——fonts：字体`` cfg.py：为主配置文件`` xxls.py：主程序文件`` requirements.txt：需要引入的python依赖包 2、详细配置 cfg.py
配置文件中，需要引入os模块，并且配置打开游戏的屏幕大小。
1234567891011121314'''主配置文件'''``import os`` '''屏幕设置大小'''`` SCREENSIZE ``= (``700`` , ``700``)``'''元素尺寸'''`` NUMGRID ``= 8`` GRIDSIZE ``= 64`` XMARGIN ``= (SCREENSIZE[``0`` ] ``- GRIDSIZE ``* NUMGRID) ``/``/ 2`` YMARGIN ``= (SCREENSIZE[``1`` ] ``- GRIDSIZE ``* NUMGRID) ``/``/ 2``'''获取根目录'''`` ROOTDIR ``= os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbf263bcee4f391e3b07184975a84b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dfe3b3715945c2da3acf581edc21299/" rel="bookmark">
			Python快速入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Python简介
Python是一门优秀的语言，语法简单、功能强大、可以快速上手，但和众多计算机语言一样，精通也很难。本文是一个快速教程，只要一步步的跟着操作，最后就可以写出Python代码，会介绍数据类型、条件语句、循环语句、函数以及模块的导入。不要纠结语法细节和计算机理论，本文目标是以最简单的方式介绍Python这门语言，回归编程语言的工具属性，效率第一、能用即可。
2 软件安装
2.1 安装Python解释器
打开Python官网https://www.python.org，选择download标签，点击下载版本3.7.9的解释器安装包，没必要追求最新版本，因为最新版本往往bug更多。
以管理员身份安装，安装时需要勾选Add Python3.7 to PATA，将python解释器添加到系统环境变量，假如忘记勾选，也可手动添加，方法自行百度，都很简单。
打开CMD，输入python，运行python解释器，会显示python版本信息等，输入exit()函数即可退出。
2.2 安装PyCharm
打开官网https://www.jetbrains.com.cn/pycharm/download，选择社区版下载安装即可。
以管理员身份安装。安装结束后，新建一个文件夹，文件夹中新建文本文档，将后缀名改为.py格式。用pycharm打开.py文件，即可编写代码。选择“file-&gt;settings-&gt;plugins”，搜索汉化插件，安装后重启pycharm界面就显示中文了。
3 打印hello word
在代码编辑区域输入:
print("hello world") 软件右下角显示无解释器。单机红色方框，弹出添加解释器窗口。
选择系统解释器，软件自动识别已经安装的解释器，确定即可。
返回代码编辑区域，鼠标右键，点击运行，即在下方调试窗口中输出hello word。
4 数据类型
编辑如下代码：
name = "hello" # 字符串，使用单引号和双引号是一样的``online = True # 布尔，python区分大小写``age = 20 # 整数``price = 6.3 # 浮点数``print(name, online, age, price) # 打印变量内容``print(name[0:2]) # 打印字符串name中的第1到第2个字符，即he``print(type(name), type(online), type(age), type(price)) # 打印变量的类型`` ``new_price = float("3") # 将字符串"3"显示转换成浮点型``print(new_price, type(new_price)) # 打印变量的值和类型`` ``array = [1, 2, 3, 4, 5, 6] # 列表``print(len(array)) # 打印列表的长度，即列表中含多少个元素``print(array[0], array[1]) # 打印列表中的第1和第2个元素，列表的索引从0开始`` ``my_dict = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dfe3b3715945c2da3acf581edc21299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9daba3c4e6663d48f15bf3b13298296/" rel="bookmark">
			2023新春版，PyCharm安装与永久使用Mac以及Windows教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 特别声明: 本教程仅供个人学习和研究使用
jetbrains官网:https://www.jetbrains.com/pycharm/
Window 安装 1.先去官网下载最新版:
https://www.jetbrains.com/zh-cn/pycharm/ 2,选择 Window专业版
3.点击安装包,点击Next
4.下载完成选择合适的路径即可。
5.选择创建快捷方式,点下一步。
6.点击下一步install安装即可
7.等待安装完成
8.等待安装完成之后勾选上下面选项，然后点击Finish，它会直接运行。
9.点击接受,继续
10.点击Don’s Send
Mac 安装 先去官网下载最新版:
https://www.jetbrains.com/zh-cn/pycharm/ 选择你对应的平台下载专业版,我这里是Mac,所以选择Mac
下载好之后点安装包安装
Mac安装直接拖进去Applications
然后打开Pycharm ,应该就是如下界面
需要最新专业版PyCharm永久使用权限的扫码获取 ## 学习资源推荐 除了上述分享，如果你也喜欢编程，想通过学习Python获取更高薪资，这里给大家分享一份Python学习资料。
这里给大家展示一下我进的兼职群和最近接单的截图
😝朋友们如果有需要的话，可以点击下方链接领取或者V扫描下方二维码联系领取，也可以内推兼职群哦~
🎁 CSDN大礼包，二维码失效时，点击这里领取👉：【学习资料合集&amp;相关工具&amp;PyCharm永久使用版获取方式】
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
1.Python学习路线 2.Python基础学习 01.开发工具 02.学习笔记 03.学习视频 3.Python小白必备手册 4.数据分析全套资源 5.Python面试集锦 01.面试资料 02.简历模板 因篇幅有限，仅展示部分资料，添加上方即可获取👆 ------ 🙇‍♂️ 本文转自网络，如有侵权，请联系删除 🙇‍♂️ ------ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e023b935fac8a3c7016b67005eb1127/" rel="bookmark">
			用Python制作一个自动抢票脚本，准点原价秒杀演唱会门票，拒绝黄牛交易！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大麦网，是中国综合类现场娱乐票务营销平台，业务覆盖演唱会、 话剧、音乐剧、体育赛事等领域。
但是因为票数有限，还有黄牛们不能丢了饭碗，所以导致了，很多人都抢不到票。
那么，今天带大家用Python来制作一个自动抢票的脚本小程序！
知识点： 面向对象编程
selenium 操作浏览器
pickle 保存和读取Cookie实现免登陆
time 做延时操作
os 创建文件，判断文件是否存在
开发环境： 版 本：python3.8.8
编辑器：pycharm
第一步，实现免登录 确定目标，设置全局变量 # 大麦网主页 damai_url = "https://www.damai.cn/" # 登录页 login_url = "https://passport.damai.cn/login?ru=https%3A%2F%2Fwww.damai.cn%2F" # 抢票目标页 target_url = 'https://detail.damai.cn/item.htm?spm=a2oeg.search_category.0.0.77f24d15RWgT4o&amp;id=654534889506&amp;clicktitle=%E5%A4%A7%E4%BC%97%E7 初始化加载 class Concert: def __init__(self): self.status = 0 # 状态,表示如今进行到何种程度 self.login_method = 1 # {0:模拟登录,1:Cookie登录}自行选择登录方式 self.driver = webdriver.Chrome(executable_path='chromedriver.exe') # 默认Chrome浏览器 登录调用设置cookie def set_cookie(self): self.driver.get(damai_url) print("###请点击登录###") while self.driver.title.find('大麦网-全球演出赛事官方购票平台') != -1: sleep(1) print('###请扫码登录###') while self.driver.title !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e023b935fac8a3c7016b67005eb1127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea0ace4e274f5cc73874794d3b0c94d/" rel="bookmark">
			Jtti：为什么建议企业使用存储型服务器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着企业业务的不断发展，数据存储已成为企业运营中不可或缺的一部分。存储服务器作为数据存储的重要设备之一，在企业中发挥着越来越重要的作用。本文将探讨企业为什么需要使用存储服务器，以及存储服务器对于企业的重要性。
可以满足企业不断增长的数据存储需求。随着企业业务的拓展和数字化转型的推进，企业所需要存储的数据量越来越大，数据类型也越来越多。传统的文件存储方式已经无法满足企业的需求，而存储服务器可以提供更大的存储空间和更高效的数据存储方式，帮助企业更好地应对数据增长带来的挑战。
可以提高企业的数据安全性。数据是企业的重要资产，数据的丢失或泄露会给企业带来巨大的损失。存储服务器可以提供数据备份、恢复和冗余等功能，确保数据的安全性和可靠性。此外，通过数据加密和访问控制等安全措施，存储服务器还可以保护企业的敏感数据不被非法访问和窃取。
可以提高企业的数据管理效率。存储服务器可以集中管理企业的数据资源，并提供数据检索、分析和挖掘等功能，帮助企业更好地利用数据。通过存储服务器的统一管理，企业可以更快地获取所需数据，提高工作效率和决策水平。
还可以降低企业的运营成本。传统的数据存储方式需要耗费大量的人力、物力和财力，而存储服务器可以降低企业在数据存储和管理方面的成本。通过集中管理和自动化控制等技术手段，存储服务器可以减少企业在硬件设备、电力和人力等方面的投入，提高企业的经济效益。
所以，企业需要使用存储服务器来满足不断增长的数据存储需求、提高数据安全性、提高数据管理效率以及降低运营成本。随着技术的不断发展，存储服务器将不断完善和提高性能，为企业的发展提供更加可靠的支撑和服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67c34a58b04b0bb9bf9eddf59ecc154/" rel="bookmark">
			[运维|gitlab] docker Gitlab 命令行后台修改密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考文献 docker Gitlab 初始化账号以及密码是什么呢
修改密码 进入容器 docker exec -it gitlab bash 进入bin目录 进入gitlab的bin目录
cd /opt/gitlab/bin 执行命令 执行gitlab-rails console gitlab-rails console 执行命令
找到root的用户，输入u=User.where(id:1).first，然后回车 u=User.where(id:1).first 修改密码
修改password，输入u.password=‘12345678’，然后回车
执行命令 u.password='12345678' 确认密码 u.password_confirmation='12345678' 保存修改
保存修改，输入u.save，然后回车，等到输出true，这时，密码修改成功
执行命令 u.save 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7db698983620852c3d1fe3140941892/" rel="bookmark">
			Windows下操作Nginx的的各种命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows系统中，可以使用以下命令来操作和管理Nginx：
1.启动Nginx服务： nginx 或者start nginx 两者区别如下：
nginx 命令：
使用该命令启动Nginx服务时，它将在当前控制台窗口中运行，并且会将控制台窗口锁定住，直到您手动停止Nginx服务或关闭控制台窗口。在使用nginx命令启动Nginx服务时，您可以通过按下CTRL+C组合键来停止Nginx服务。 start nginx命令：
使用该命令启动Nginx服务时，它将在一个新的后台进程中运行，并且不会锁定当前控制台窗口。这意味着您可以在启动Nginx后继续使用该控制台窗口执行其他命令。由于Nginx在后台运行，因此您需要使用其他命令（如nginx -s stop）来停止Nginx服务。 2.停止Nginx服务： nginx -s stop 3.优雅停止Nginx服务（等待客户端请求处理完毕后再停止）： nginx -s quit 4.重新加载Nginx配置文件，无需停止服务： nginx -s reload 5.检查Nginx配置文件是否正确： nginx -t 6.在控制台上显示Nginx进程信息： nginx -s status 7.从Windows服务中安装Nginx服务（需要管理员权限）： nginx -i install 8.从Windows服务中移除Nginx服务（需要管理员权限）： nginx -i uninstall 请注意，这些命令需要在Nginx的安装目录下执行，或者将Nginx的可执行文件路径添加到系统环境变量中。默认情况下，Nginx的安装目录在C:\nginx。
希望这些命令可以帮助您在Windows系统上操作和管理Nginx！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d50c1207f33e2584f3ca9c6afff66e7/" rel="bookmark">
			【mac-m1 docker 安装upload-labs靶场】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.搜索upload-labs
docker search upload-labs
2.下载upload-labs
docker pull c0ny1/upload-labs
3.启动
docker run -it -d --name uploadlabs -p 80:80 c0ny1/upload-labs --platform linux/amd64
4.访问127.0.0.1:80
注意点：后续使用的时候会报错
需要手动创建upload文件夹
进入容器
docker exec -it uploadlabs /bin/bash
在/var/www/html目录下添加upload文件夹
然后赋予777权限，即可
mkdir upload &amp;&amp; chmod 777 upload
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247c329ef719a3449fd131ad3cce557f/" rel="bookmark">
			【algorithm】自动驾驶常见常考的几个模型和推导，顺便总结自己遇到的考题经验不断更新之———控制版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本来快达成目标了，没想到公司遭受了问题，公司和同事我感觉还是挺好的，有国企的正规也有小企业的灵活，大家都很有学习欲望。
作为本次再次复习回忆如下：
把之前面试准备的 机器学习（基本搬运到CSDN平台了）、规划（基于之前的公司同事教导和常见算法轨迹 lattice em 路径 diji a star rrt rrt*）、控制（控制器和模型），工具链（matlab ide repo git anaconda ros linux操作）其他（frenet 、大地车辆坐标转换、点到线距离、找投影、插值、离散点求曲率（以及各种几何问题）、卡尔曼 三次道路多项式 地图处理 滤波 轨迹优化）刷题和有cpp相关的作为小白接触到的知识都总结成了word。 本文先总结搬运模型相关，希望大佬们给点方向提建议，渴望进步，其实对于经典现代控制论本身，很多东西都忘记了，只能作为笔记和考试记录存在了，实践中感觉一直用不上或者不需要再推导了。 现在的烦恼是：其中有很多新东西和非规划控制的内容由于工作方向我只能自己demo，最希望讨论和接触的是实践中积累的问题处理办法，还有能实际在工作中部署最新论文的东西，可惜工作就是工作，同时被专业方向卡住，只能积累再积累。
outline stanley pp动力学 运动学 简单推导mpcpidacado 和osqp求解 见另外两篇文章
Acado：https://blog.csdn.net/weixin_46479223/article/details/133743263的实例中展示了acado如何求解mpc问题，
另一篇是osqposqp：https://blog.csdn.net/weixin_46479223/article/details/135107257临时简略EM planner 信息 Stanley and pure pursuit 运动学 动力学 并联pid 预瞄 2个点 近：lateraldisdiff lateraldisdiffrate 远headingdiff headingdiffrateyawrate 要稳 pd要控制好找瞄准点用几何法 串联pid MPC控制横向 pid纵向 （纵向mpc osqp见另一篇文章的demo）https://blog.csdn.net/weixin_46479223/article/details/135107257
会找投影点 预瞄要选好 用acado osqp ，具体模型一会更新
模型推导 在我的文章Acado：https://blog.csdn.net/weixin_46479223/article/details/133743263的实例中展示了acado如何求解mpc问题
可见acado很方便，直接给出车辆模型的微分方程，以及求解时域（步长）、约束、和目标函数就可以生成相关代码。
因此我们直接得出状态量之间的递推表达关系即可（状态转移方程），推导如下（当然也可以使用之前的动力学和运动学的推导来建立mpc，这里展示使用的另一种横向模型）
以下是除了模型之外的，mpc控制部分的处理（找投影点，预瞄点），以及纵向pid的设置 其他： -颠簸
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247c329ef719a3449fd131ad3cce557f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6e9b3d995df5e81994a23f3194e568/" rel="bookmark">
			Python制作【大麦网】抢票程序，看演唱会再也不怕没票了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大麦网，是中国综合类现场娱乐票务营销平台，业务覆盖演唱会、 话剧、音乐剧、体育赛事等领域。
但是因为票数有限，还有黄牛们不能丢了饭碗，所以导致了，很多人都抢不到票
那么，今天带大家用Python来制作一个自动抢票的脚本小程序
【----完整源码文末免费领！----】
知识点： 面向对象编程selenium 操作浏览器pickle 保存和读取Cookie实现免登陆time 做延时操作os 创建文件，判断文件是否存在 开发环境： 版 本：anaconda5.2.0（python3.6.5）编辑器：pycharm 先导入本次所需的模块 import os import time import pickle from time import sleep from selenium import webdriver 第一步，实现免登录 确定目标，设置全局变量 # 大麦网主页 damai_url = "https://www.damai.cn/" # 登录页 login_url = "https://passport.damai.cn/login?ru=https%3A%2F%2Fwww.damai.cn%2F" # 抢票目标页 target_url = 'https://detail.damai.cn/item.htm?spm=a2oeg.search_category.0.0.77f24d15RWgT4o&amp;id=654534889506&amp;clicktitle=%E5%A4%A7%E4%BC%97%E7 初始化加载 class Concert: def __init__(self): self.status = 0 # 状态,表示如今进行到何种程度 self.login_method = 1 # {0:模拟登录,1:Cookie登录}自行选择登录方式 self.driver = webdriver.Chrome(executable_path='chromedriver.exe') # 默认Chrome浏览器 登录调用设置cookie def set_cookie(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b6e9b3d995df5e81994a23f3194e568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e03b0c60f365b4c51e5f8a5c1ffd227/" rel="bookmark">
			vscode和pycharm那个更好用？对比Pycharm、Jupyter优劣势！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前一直是PyCharm+Jupyter的组合，能满足几乎所有的Python开发需求。最近我开始用vscode，发现很香。
PyCharm适合做项目开发，或者平常写写脚本，算是全能型IDE。但PyCharm体积大，对硬件消耗厉害，不够轻便。
Jupyter是近年流行起来的开发工具，基于IPython，主要应用于数据分析、机器学习。
它实质是一个web应用，让你在浏览器上写python，即写即运行，所以适合做数据探索分析。
虽然Jupyter数据开发模式很方便，但它的开发场景毕竟有限，不适合脚本编写和项目开发，debug等功能也处在改善阶段。
如果要为PyCharm和Jupyter找一个替代IDE，能覆盖两者大部分功能，那可能非vscode莫属了。
vscode是微软主推的轻量级代码编辑器，安装Python插件后可以编译代码。
之所以说vscode能替代PyCharm和Jupyter，因为它既可以写Python脚本项目，也可以运行Jupyter notebook，还支持各种文档浏览编辑，以及有大量的插件。
所以说vscode 写Python主要有以下五个优点。
1、支持IDE开发
2、支持Jupyter notebook
3、拥有Python和Jupyter的各类插件
4、轻量、简单、易上手
5、自定义程度高
当然，vscode也有不足的地方，它加插件有时候会出现延缓和错误。而且由于插件过多，需要使用者有很好的技术能力去配置，才能达到PyCharm的功能。
因为PyCharm是专业的python 开发工具，所以开发功能上肯定比vscode 更强，但vscode 胜在拓展强。前者像是ios ，后者像是安卓。
-------- End --------
以下是我整理的一些提升程序员自身能力的资料，都已经整理并打包好了。
Python入门全套学习资料附带源码： Python全套学习路线
Python零基础入门视频 Python项目源码 Python入门到进阶电子书籍和实战案例 👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 这份完整版的Python全套学习资料已为大家备好，朋友们如果需要可以微信扫描下方二维码添加，输入"领取资料" 可免费领取全套资料【有什么需要协作的还可以随时联系我】朋友圈也会不定时的更新最前言python知识。↓↓↓
或者
【点此链接】领取
好文推荐 了解python的前景：https://blog.csdn.net/weixin_49895216/article/details/127186741
了解python的兼职：https://blog.csdn.net/weixin_49895216/article/details/127124870
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd654b5b7a378ef1bc13611b4f28d05/" rel="bookmark">
			基于seatunnel实现mysql同步clickhouse验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 需求想要实现mysql同步到clickhouse，seatunnel部署见前面文档linux环境seatunnel安装运行-CSDN博客。
官方说明文档 Clickhouse | Apache SeaTunnel
mysql同步配置 server-id=1
log_bin=/var/lib/mysql/bin.log
binlog_format=ROW
#binlog-do-db 具体要同步的数据库
binlog-do-db=gisqbpm
gtid-mode=on
enforce-gtid-consistency=on
验证MYSQL同步clckhouse mysql数据库测试表 CREATE TABLE `test` (
`id_` varchar(255) NOT NULL,
`name` varchar(255) DEFAULT NULL,
PRIMARY KEY (`id_`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
clikhouse库测试表 -- gisqbpm.test definition
CREATE TABLE gisqbpm.test
(
`id_` String,
`name` Nullable(String),
`_sign` Int8 MATERIALIZED 1,
`_version` UInt64 MATERIALIZED 1,
INDEX _version _version TYPE minmax GRANULARITY 1
)
ENGINE = ReplacingMergeTree(_version)
ORDER BY tuple(id_)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afd654b5b7a378ef1bc13611b4f28d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f8caee05589ded5b9c2d6d67f8ed03/" rel="bookmark">
			最新自动化测试面试题总结（答案&#43;文档）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、你做了几年的测试、自动化测试，说一下 selenium 的原理是什么？ 我做了五年的测试，1年的自动化测试；
selenium 它是用 http 协议来连接 webdriver ，客户端可以使用 Java 或者 Python 各种编程语言来实现；
2、什么项目适合做自动化测试？ 关键字：不变的、重复的、规范的
第一点，需求变化不能太频繁；
第二点，项目周期要足够长，如果自动化代码还没有写完，公司就倒闭了，那也不需要自动化了
第三点，脚本可以重复使用：在一些典型的场景，比如说 “冒烟测试、回归测试” 的地方就是经常使用自动化测试；
第四点，被测试的软件是否规范：比如说是不是有需求文档、规范的接口文档、是否有原型图、你的接口设计是不是比较规范；
第五点，手工测试是无法完成的；比如说一个性能测试，不能同时有 一千只手一直做好点点点，自动化测试的成本不是特别高
3、Python 生成器 和迭代器的区别？ 作为迭代器必须实现两个特定的方法 “iter()，next()” ；
生成器是一种特许的迭代器，支持所有的迭代操作，除此之外生成器还实现了，普通迭代器没有的一些特性；
比如说它可以通过 send 的方法与生成器内部进行数据交互；还有它可以通过 close 方法去进行关闭；甚至还可以通过 throw 方法，引发内部的异常；
4、为什么用 Mac 写代码？ 表面原因是 Mac 方便易用，颜值也高；深层原因是因为现在的服务器，大多都是采用 Linux 系统，而 Mac 系统 和 Linux 系统其实都是基于原来的 Unix 系统开发的；
而 Mac 基本上能够维持我们的开发环境和线上的一致性；
为什么不用 Linux ？
用 Linux 写代码也是一个很好的选择，但是 Linux 的界面操作和他的娱乐功能不是特别强，而 Mac 做到了很好的平衡；
5、你是怎么开展自动化测试工作的？ 第一，根据产品的业务特性整理出来，可以做自动化的一个功能模板；
第二，我们会根据有限级以及人员现状，来制定自动化测试计划；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f8caee05589ded5b9c2d6d67f8ed03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7e01accf8f2951a3ad701bdefeaa54/" rel="bookmark">
			使用HttpSession和过滤器实现一个简单的用户登录认证的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章分享一下怎么通过session结合过滤器来实现控制登录访问的功能，涉及的代码非常简单，通过session保存用户登录的信息，如果没有用户登录的话，会在过滤器中处理，重定向回登录页面。
创建一个springboot项目，添加springbooot-starter-web和lombok的依赖。创建对应的实体类、controller、service，并创建两个简单的html页面测试过滤器的效果。
一、登录功能实现 controller package cn.edu.sgu.www.login.controller; import cn.edu.sgu.www.login.entity.User; import cn.edu.sgu.www.login.service.UserService; import cn.edu.sgu.www.login.util.UserUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import java.io.IOException; /** * @author heyunlin * @version 1.0 */ @RestController @RequestMapping(path = "/user", produces = "application/json;charset=utf-8") public class UserController { private final UserService userService; @Autowired public UserController(UserService userService) { this.userService = userService; } @RequestMapping(value = "/login", method = RequestMethod.POST) public void login(User user) throws IOException { userService.login(user); UserUtils.getResponse().sendRedirect("/index.html"); } } service UserService
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7e01accf8f2951a3ad701bdefeaa54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1d2079d83ac9db265c6129fe6f56b8/" rel="bookmark">
			预测未来？Python中的时间序列分析模型ARIMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间序列分析：Python中的ARIMA模型，ARIMA模型是一种常用的时间序列预测工具，可以使用statsmodels库在Python中实现。
时间序列分析广泛用于预测和预报时间序列中的未来数据点。ARIMA模型被广泛用于时间序列预测，并被认为是最流行的方法之一。在本教程中，我们将学习如何在Python中搭建和评估用于时间序列预测的ARIMA模型。
什么是ARIMA模型？ ARIMA模型是一种用于分析和预测时间序列数据的统计模型。ARIMA方法明确适用于时间序列中的常见结构，为进行精确的时间序列预测提供了简单而强大的方法。
ARIMA是AutoRegressive Integrated Moving Average的缩写。它结合了三个关键方面：
**自回归（AR）：**使用当前观测值与滞后观测值之间的相关性建立的模型。滞后观测值的数量称为滞后阶数或p。
**积分（I）：**通过对原始观测值进行差分来使时间序列平稳。差分操作的次数称为d。
**移动平均（MA）：**模型考虑了当前观测值与应用于过去观测值的移动平均模型的残差错误之间的关系。移动平均窗口的大小为阶数或q。
ARIMA模型的表示为ARIMA(p,d,q)，其中p、d和q用整数值替代以指定所使用的确切模型。
采用ARIMA模型时的关键假设： 时间序列是由基础的ARIMA过程生成的。
参数p、d和q必须根据原始观测值进行适当的指定。
在拟合ARIMA模型之前，时间序列数据必须通过差分使其平稳。
如果模型拟合良好，残差应该是不相关且服从正态分布的。
总而言之，ARIMA模型为建模时间序列数据提供了结构化和可配置的方法，用于预测等目的。接下来，本文将介绍如何在Python中拟合ARIMA模型。
Python代码示例 在本教程中，我们将使用Kaggle上提供的Netflix股票数据来使用ARIMA模型预测Netflix股票价格。
**【Netflix股票数据】：**https://www.kaggle.com/datasets/kalilurrahman/netflix-stock-data-live-and-latest
数据加载 本示例将加载带有“日期”列作为索引的股票价格数据集。
import pandas as pd net_df = pd.read_csv("Netflix_stock_history.csv", index_col="Date", parse_dates=True) net_df.head(3) [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-66udRjHj-1692328748777)(https://mmbiz.qpic.cn/mmbiz_png/LyCRpnJK7eo2BUw75IQLOgiayricqh3iaZibJRPCa2ZQBoXHVUzfB2r7iaFibLRbTTw9GSb2rH0zWicV4XNGawNq37kZA/640?wx_fmt=png)]
数据可视化 可以使用pandas的plot函数来可视化股票价格和成交量随时间的变化。很明显，股票价格呈指数增长。
net_df[["Close","Volume"]].plot(subplots=True, layout=(2,1)); 滚动预测ARIMA模型 本示例的数据集已经被分成训练集和测试集，并且开始训练ARIMA模型。然后进行了第一次预测。
使用通用的ARIMA模型得到了一个糟糕的结果，生成了一条平直的线。因此，本示例决定尝试滚动预测方法。
注意：代码示例是BOGDAN IVANYUK的notebook的修改版本。
**【notebook】：**https://www.kaggle.com/code/bogdanbaraban/ar-arima-lstm#ARIMA-model
from statsmodels.tsa.arima.model import ARIMA from sklearn.metrics import mean_squared_error, mean_absolute_error import math train_data, test_data = net_df[0:int(len(net_df)*0.9)], net_df[int(len(net_df)*0.9):] train_arima = train_data['Open'] test_arima = test_data['Open'] history = [x for x in train_arima] y = test_arima # 进行第一次预测 predictions = list() model = ARIMA(history, order=(1,1,0)) model_fit = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1d2079d83ac9db265c6129fe6f56b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382e2f1a7917fed8d0c4806952a8a7e6/" rel="bookmark">
			搭建网站环境（IIS&#43;php&#43;mysql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 服务器：window server 2012R2
一、IIS安装地址学习地址：（图文详细）安装配置IIS+MySQL+PHP环境的详细教程（之篇一IIS安装）_php+iis+mysql-CSDN博客
二、PHP安装学习地址
安装配置IIS+MySQL+PHP环境的详细教程（之篇二PHP安装）-CSDN博客
三、VC下载地址（vcredist_x64.exe）
链接: https://pan.baidu.com/s/1Hr_3aiAVRhBf0uL-ZLWgqA?pwd=xut4
提取码: xut4 四、php下载地址
链接: https://pan.baidu.com/s/1A0f_iR0VG4drJ9EAImpzVQ?pwd=gkuy
提取码: gkuy 五、mysql5.5下载地址
链接: https://pan.baidu.com/s/1ix3plg-G3Fa-XOKyXHNDGQ?pwd=7bec
提取码: 7bec 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b124fc93b8d8ca863f1435150006d964/" rel="bookmark">
			震惊!原来这就是JavaScript闭包的秘密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 鸿蒙专栏：想学鸿蒙的，冲
📢 C语言专栏：想学C语言的，冲
📢 VUE专栏：想学VUE的，冲这里
📢 CSS专栏：想学CSS的，冲这里
📢 Krpano专栏：想学VUE的，冲这里
📢 JavaScript专栏：想学JavaScript的，冲这里
🔔 上述专栏，都在不定期持续更新中！！！！！！！
目录
✨ 前言
什么是闭包
闭包的作用
实现闭包的条件
闭包的生命周期
✨ 结语
✨ 前言 闭包(Closure)是JavaScript中一个非常重要却容易让人困惑的概念。明明是一个函数,为什么还能引用外部变量?今天我将为你揭开JavaScript闭包的神秘面纱,通过简单易懂的例子让你明白闭包的实际应用场景和作用。你将会对闭包有一个全新的认识,并能够在以后的代码中灵活运用它。跟着我一起抓住JavaScript闭包的真谛,成为JS高手吧!
什么是闭包 闭包(Closure)是JavaScript一个很重要的概念,它使函数拥有保持其作用域链的能力。
简单说,闭包让函数记住并继续访问定义函数的词法作用域,即使函数是在当前词法作用域之外被执行。
闭包的作用 闭包的主要作用有:
让函数访问外部变量 function outer() { const x = 10; function inner() { return x; } return inner; } const getX = outer(); getX(); // 返回10 封装变量,减少全局变量污染 function counter() { let count = 0; return function() { return count++; } } const c1 = counter(); c1(); // 0 c1(); // 1 实现模块和信息隐藏 function Person(name) { const age = 18; return { getName: function() { return name; }, getAge: function() { return age; } }; } const me = Person('Jack'); me.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b124fc93b8d8ca863f1435150006d964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5292a35b60fb0414a4ad642669ee6cc6/" rel="bookmark">
			Do you know about domestic CPUs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Do you know about domestic CPUs CPU指令集国产CPU CPU指令集 国产CPU 参考文献
国产CPU之4种架构和6大品牌指令集及架构一文深入了解 CPU 的型号、代际架构与微架构国产GPU芯片厂商有哪些深入GPU硬件架构及运行机制详解服务器GPU架构和基础知识 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56959f6a9c79727f5f04a582efe73e25/" rel="bookmark">
			Android studio环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.搜索android studio下载 Android Studio - Download
2.安装 3.配置环境 配置gradle，gradle参考网络配置。最后根据项目需求选择不同的jdk。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a77129d1228bab7003f7758730d659/" rel="bookmark">
			[NISACTF 2022]bingdundun~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [NISACTF 2022]bingdundun~ wp 信息搜集 进入题目：
点一下 upload? ：
注意看上面的 URL ，此时是 ?bingdundun=upload 。
随便找个文件上传一下：
注意看上面的 URL ，此时变成：upload.php 。
那么我有理由怀疑前面在输入 ?bingdundun=upload 时会自动添加 .php 后缀名，因为两种 URL 指向同一个页面，说明 ?bingdundun= 包含的就是 upload.php 文件。
fuzz 一下，发现确实只能上传图片和压缩包。那么猜测是用 phar 伪协议进行文件包含。
用 phar 伪协议进行文件包含 phar 伪协议无论读取什么文件，都会将其视为压缩包进行解压缩，然后作为 php 代码执行，在文件上传类漏洞中经常被用到。
先写个一句话木马，文件名为 shell.php ，再压缩成 zip 文件，因为压缩包可以上传，所以这里就不把后缀名改成图片了： 上传 shell.zip 文件： 上传的文件还是在网站根目录下，只不过换了个名字。
phar 伪协议读取上传的文件 回到 ?bingdundun= 那里，因为会自动加上后缀名 .php ，所以 payload 是：
?bingdundun=phar://66ad472f8ed84878b168fb54c37aa771.zip/shell 蚁剑连接 路径是：
http://node5.anna.nssctf.cn:28582/?bingdundun=phar://66ad472f8ed84878b168fb54c37aa771.zip/shell flag 在根目录下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ea8a4a7d70a97c153945165959601d/" rel="bookmark">
			vue中高德地图使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装
npm i @amap/amap-jsapi-loader --save 2、封装地图组件
&lt;template&gt; &lt;div id="map" ref="mapcontainer"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import AMapLoader from "@amap/amap-jsapi-loader"; export default { beforeCreate() { AMapLoader.load({ key: "aa3dac8335f8831b0bf80a66a28b57e4", // 申请好的Web端开发者Key，首次调用 load 时必填 version: "1.4.15", // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: [], // 需要使用的的插件列表，如比例尺'AMap.Scale'等 AMapUI: { // 是否加载 AMapUI，缺省不加载 version: "1.1", // AMapUI 缺省 1.1 plugins: [], // 需要加载的 AMapUI ui插件 }, Loca: { // 是否加载 Loca， 缺省不加载 version: "1.3.2", // Loca 版本，缺省 1.3.2 }, }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ea8a4a7d70a97c153945165959601d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15168d4cab3d677b289290046ba1402c/" rel="bookmark">
			JVM面试系列-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Java 中 JVM 什么时候会触发 FullGC？ 除直接调用System.gc外，触发Full GC执行的情况有如下四种。
1、旧生代空间不足
旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
2、Permanet Generation空间满
PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
java.lang.OutOfMemoryError: PermGen space 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。
3、CMS GC时出现promotion failed和concurrent mode failure
对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。
promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。
应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。
4、统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间
这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。
实例：程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。
当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，（实例）第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。
除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过：
-java-Dsun.rmi.dgc.client.gcInterval=3600000 2. Java 中什么是对象结构？ Java对象由三个部分组成：对象头、实例数据、对齐填充。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15168d4cab3d677b289290046ba1402c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63705368d80e08d9a2fe08ca037c0eca/" rel="bookmark">
			曝光一些内部群聊天记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐阅读：
《又，租了一个新办公室》
《我，又又又阳了。。。》
1
辛苦钱
昨天有一个读者咨询课程，我们大概聊了两句，他问我们目前做AI实战训练营的这个项目。
是不是赚的辛苦钱？
我觉得这个也算是一个好问题。
他潜在的台词是，我是不是付出了很多时间和精力，结果就赚了一点点的收入，可能不太划算。
刚好我们已经跑了四期训练营，从我们拿到的数据来看，基本上越是收入高的人越忙。
基本不存在你很闲你还能赚到钱。也不存在你非常忙忙的要死，结果一单都出不来。
截图是训练营学员爆单的聊天。学员说忙死了，单子都接不过来。。
大家都在训练营里面，让其他学员帮忙把订单给消化了，这也是训练营拉大群的意义。
2
还有一种
当然，还有一部分人。
他的潜台词是，报名之后，能不能不努力，稍微运营一下，一个月就赚大几千、几万的。
这种人还活在虚幻中。
一般他们都是我们直接劝退的对象。如果真的存在这样的业务，请各位读者一定记得带上我。
我们一般所说的这个项目很好。
指的是，只要你按照老师课程要求去做，每天去操作执行，大概率都会出结果，而且结果都还可以。
给大家看一个，我们培训课在开课的第二个周末，匿名调查问卷的结果图：
大概两周的时间，这还包含了第一周大家不熟悉需要学习的成本。大家能拿到这样的成绩，我看到的时候觉得已经很炸裂了。
肯定还有一部分学员，问为什么还有人没出单。
这个也很简单，每个人的操作不一样，另外平台算法有一定的随机性，爆单有的比较早，有的比较晚。
针对这个问题，保持耐心+多铺量，就可以有效对抗。
我们从来不保证你100%赚到钱，但我们能保证你跟着我们的课程走，大概率可以到达什么效果。
3
月入过万
我们之前训练营密训的时候。
拿到的成绩是：8个人的训练营，不到30天，3个人月营收过万，最高一个已经1.5万，3个人月入几千，2个人大几百，出单率100%。
我们也会不时的去调查一下学员数据，有学员已经跑出月营收过 2 万，1万3的收益！
你说这个学员赚的是辛苦钱吗？
从某种意义上来说也是，我看她的朋友圈，忙的时候连着几天都是凌晨两三点后睡觉的。
但比较欣慰的是，她的忙赚来了让自己满意的钱。
其实对于我自己来讲，真的不怕辛苦也不怕忙，就害怕的是做这件事辛苦还没赚到钱。
这么多年，我其实尝试过很多项目。
能像这个项目这样普遍拿到客观数据的真心不多，而且目前它还处于红利期，不管感不感兴趣我觉得都可以关注一下。
欢迎大家可以添加下面微信，咨询项目的详细情况，也可以先添加微信后围观，都可以的。
（长按二维码加微信咨询）
另外还有大礼包福利相送，对于我公众号粉丝，加甜甜备注“微笑”，会额外送你一份价值99元的《实战级副业项目合集》。
注意！添加务必备注：【微笑】，否则你拿不到大礼包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0548dd0d2a937e8109083097f0b589ef/" rel="bookmark">
			ECharts配置个性化图表：圆环、立体柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECharts配置个性化图表：圆环、立体柱状图 圆环图双纵轴多数据面积图折柱混合图3D立体圆环饼图3D立体饼图圆柱体折线混合图单柱状体折线混合图立体柱状图双柱状体双立体柱状图带背景色+数据label双立体柱状图折线混合图双立体柱状图3D立体饼图参考文章 官网调试地址：点击跳转调试
圆环图 效果图：
配置：
option = { color: ['#29BEFF', '#A2DC00', '#FFC400', '#FF7F5C', '#CA99FC'], // 提示窗 tooltip: { trigger: 'item', show: false }, // 图例 legend: { top: '5%', left: 'center', show: false }, // 数据 series: [ { name: 'Access From', type: 'pie', radius: ['35%', '60%'], //可以设置圆环的宽度 avoidLabelOverlap: false, itemStyle: { borderColor: '#fff', borderWidth: 2 }, label: { show: true, formatter: '{d}%', position: 'outside', fontSize: 11, color: '#999' }, emphasis: { label: { show: false, formatter: ['{a|{b}}', '{b|{c}}'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0548dd0d2a937e8109083097f0b589ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4eb38ec0ffedfde0922cc083e20e7c1/" rel="bookmark">
			深度掌握GitHub Copilot：提高编码效率的终极指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
GitHub Copilot，作为一款由OpenAI和GitHub合作打造的智能代码助手，正在迅速改变开发者的编码体验。本文将深入研究GitHub Copilot，从安装和基础用法到高级应用和实用技巧，助您充分发挥这一工具在提高编码效率和代码质量方面的潜力。
主要内容：
GitHub Copilot简介：
解析GitHub Copilot的背后技术，探讨其如何利用深度学习模型理解上下文并生成准确的代码片段。强调GitHub Copilot在不同编程语言和开发环境中的适用性。 安装与配置：
提供详尽的安装步骤，覆盖主流开发工具如Visual Studio Code，确保读者能够顺利使用GitHub Copilot。介绍个性化配置选项，以便用户充分定制GitHub Copilot以满足个人需求。 基本用法详解：
演示GitHub Copilot的基本用法，包括如何触发代码建议、接受提示等。强调GitHub Copilot如何通过上下文生成更准确、贴近用户习惯的代码。 高级功能探讨：
深入研究GitHub Copilot的高级功能，包括多行代码生成、自定义代码片段等。提供实例演示，展示这些高级功能在实际开发中的应用场景。 实用技巧与最佳实践：
提供一系列实用技巧，帮助用户更有效地使用GitHub Copilot，例如快速调整生成的代码、提高建议准确性的方法等。强调使用GitHub Copilot的注意事项，确保安全、高效地使用这一工具。 常见问题解答：
解答使用GitHub Copilot时可能遇到的常见问题，提供解决方案和优化建议。 结论：
总结GitHub Copilot的核心优势，鼓励开发者将其整合到日常开发流程中，实现更快速、高效的编码体验，并展望GitHub Copilot未来的发展前景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ffa2efd4d5da9abaf6c7b1c3c5b51f/" rel="bookmark">
			Linux中进入目录命令是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。在Linux中拥有诸多命令，为我们的工作带来便利，提高效率，那么Linux中进入目录命令是什么?以下是详细内容介绍。
Linux中进入目录命令是cd，cd命令用于在Linux系统中导航到特定目录。使用cd命令可以进入当前工作目录下的目录，也可以进入其他目录。
下面是一些常用的cd命令用法：
1、进入当前工作目录下的目录：
cd ./
2、进入其他目录：
cd /home/user/documents/
3、进入根目录：
cd /
4、进入指定目录：
cd /home/user/documents/file.txt
5、进入当前目录下的指定目录：
cd ./file.txt
6、进入当前目录下的根目录：
cd ..
7、进入指定目录的父目录：
cd ../
8、进入根目录的父目录：
cd ../../
9、进入指定目录的绝对路径：
cd /user/local/bin/
10、进入当前目录下的所有目录：
cd ./..
除了基本用法之外，cd命令还有许多其他选项和参数可以使用。例如，可以使用-n选项取消当前目录的别名：
cd -n /home/user/documents/
还可以使用-r选项递归地进入目录：
cd -r /home/user/documents/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e285fe49d01940780dae4249b333844d/" rel="bookmark">
			QT5.14 实现ModbusTCP客户端 Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文在QT5.14平台，基于QModbusClientTcp类，实现了客户端对单个寄存器的读写，用ModbusSlave做服务器做测试。
1.界面
(1)更改读按钮的名称为bt_Read
(2)更改写按钮的名称为bt_Write
2.修改pro文件的第三行
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets serialbus 3.修改mainWindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include &lt;QMainWindow&gt;
#include &lt;QModbusTcpClient&gt;
QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE
class MainWindow : public QMainWindow
{
Q_OBJECT
public:
MainWindow(QWidget *parent = nullptr);
~MainWindow();
private slots:
void on_bt_Read_clicked();
void on_bt_Write_clicked();
void ReplyData();
private:
Ui::MainWindow *ui;
QModbusTcpClient *client;
};
#endif // MAINWINDOW_H
4.修改mainWindow.c
#include "mainwindow.h"
#include "ui_mainwindow.h"
MainWindow::MainWindow(QWidget *parent)
: QMainWindow(parent)
, ui(new Ui::MainWindow)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e285fe49d01940780dae4249b333844d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23316c88c76d9ebc4a1234696a2f7cd9/" rel="bookmark">
			新手学编程必会的100个代码_初学编程100个代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是本文的目录 前言 1、for循环中的else条件2、数字求和3、随机数生成4、将列表中的所有元素作为参数传递给函数5、获取列表的所有中间元素6、使用一行代码赋值多个变量7、Python清空列表8、通过Enum枚举同一标签或一系列常量的集合9、重复字符串10、计算每个月天数11、输出指定范围内的素数12、计算两数差值13、奇数移到偶数前14、顺序表元素逆置15、删除顺序表最小值元素16、删除值在x~y之间的所有数据17、打印九九乘法表18、更多资源文末获取 零基础Python学习资源介绍 👉Python学习路线汇总👈👉Python必备开发工具👈👉Python学习视频600合集👈👉实战案例👈👉100道Python练习题👈👉面试刷题👈 资料领取好文推荐 前言 我记得刚开始接触编程的时候，觉得太难了。
也很好奇，写代码的那些人也太厉害了吧？全是英文的，他们的英文水平一定很好吧？
他们是怎么记住这么多代码格式的？而且错了一个标点符号，整个程序都会有影响。
一个程序几千行，错一个标点符号都不行这也太难了吧？
带着新手的灵魂拷问，作为从业单片机编程10年的开发者，我来为大家拨开云雾。
看完以后你就会明白，其实他们也没那么厉害！即便你是初中文凭，也照样能编程。
对于python语言来说，要记得东西其实不多，基本就是几个常用语句加一些关键字而已。
你所看到的那些几千甚至上万行的代码，都是用这些语句和关键词来重复编写的。
只是他们逻辑功能不一样，另外的那些英文，都是程序员自己起的，比如说一些变量的名字，函数的名字。
如果你喜欢你定义成abc都可以，只不过为了程序大了以后为了方便阅读和维护，我们一般起跟要实现的功能相同的英文缩写代替。
比如说我要存储一个电压值，那你可以定义一个变量，名字叫VoltageValue,或者这两个词的缩写VoltVal。
所以，大家不要把这个想得这么神秘和高大上。
【----帮助Python学习，以下所有学习资料文末免费领！----】
1、for循环中的else条件 这是一个for-else方法，循环遍历列表时使用else语句。
下面举个例子，比如我们想检查一个列表中是否包含奇数。
那么可以通过for循环，遍历查找。
numbers = [2, 4, 6, 8, 1] for number in numbers: if number % 2 == 1: print(number) break else: print("No odd numbers") 2、数字求和 # -*- coding: UTF-8 -*- # Filename : test.py # author by : www.runoob.com # 用户输入数字 num1 = input('输入第一个数字：') num2 = input('输入第二个数字：') # 求和 sum = float(num1) + float(num2) # 显示计算结果 print('数字 {0} 和 {1} 相加结果为：{2}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23316c88c76d9ebc4a1234696a2f7cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a3087036d12036222e6db1aa01afdc5/" rel="bookmark">
			TwinCAT 3 tcp程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ST ENUM UNION
TYPE ENUM_tcp_client : ( nInitial:=0, nConnect, nWhetherConnect, nDetermineAction, nSend, nWhetherSend, nReceive, nWhetherReceive, nClose, nWhetherClose ); END_TYPE TYPE ENUM_tcp_server : ( nInitial:=0, nListen, nWhetherListen, nAccept, nWhetherAccept, nDetermineAction, nSend, nWhetherSend, nReceive, nWhetherReceive, nCloseAll, nWhetherCloseAll ); END_TYPE TYPE UNION_tcp_hex_char : UNION nByte:ARRAY[0..255] OF BYTE; sString:STRING(256); END_UNION END_TYPE TYPE ST_tcp_client : STRUCT control:ST_tcp_client_control; parameter:ST_tcp_parameter; status:ST_tcp_client_status; FB:FB_tcp_client; END_STRUCT END_TYPE TYPE ST_tcp_client_control : STRUCT bConnect:BOOL; bReceive:BOOL; bSend:BOOL; bClose:BOOL; END_STRUCT END_TYPE TYPE ST_tcp_client_status : STRUCT bConnectDone:BOOL; bReceiveDone:BOOL; bSendDone:BOOL; bCloseDone:BOOL; END_STRUCT END_TYPE TYPE ST_tcp_parameter : STRUCT sIp:T_IPv4Addr; nPort:UDINT; SendData:UNION_tcp_hex_char; nSendDataLength:UINT:=256; ReceiveData:UNION_tcp_hex_char; nReceiveDataLength:UINT:=256; END_STRUCT END_TYPE TYPE ST_tcp_server : STRUCT control:ST_tcp_server_control; parameter:ST_tcp_parameter; status:ST_tcp_server_status; FB:FB_tcp_server; END_STRUCT END_TYPE TYPE ST_tcp_server_control : STRUCT bListen:BOOL; bReceive:BOOL; bSend:BOOL; bCloseAll:BOOL; END_STRUCT END_TYPE TYPE ST_tcp_server_status : STRUCT bListenDone:BOOL; bAcceptAccepted:BOOL; bReceiveDone:BOOL; bSendDone:BOOL; bCloseAllDone:BOOL; END_STRUCT END_TYPE FB_tcp_client
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a3087036d12036222e6db1aa01afdc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e648dba51777f5dce45d67f70824fa/" rel="bookmark">
			RocketMQ5-01云原生和AI演变下的架构重构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年9月22日，迎来 RocketMQ5 的发版，距离 2017 发布的 4.X 时代，RocketMQ 迎来 5.X 时代。
RocketMQ 4.X 时代已经使众多开发者和项目受益，但是随着关注度、使用量逐步上升以及云原生时代的到来，也对其自身架构带来启发和挑战。
所以 Apache RocketMQ 5.0 的演进目标有三个：
消息基础架构的云原生化演进：充分结合云原生大潮下的基础设施和生态技术，提高资源利用和弹性能力。集成效率的痛点升级优化：从API、SDK多方面重构设计，为开发者提供更加简单易用、轻量易集成的方案；事件、流集成场景拓宽：我们将以当前业务集成的能力为基础进一步聚焦消息领域的后处理场景，支持消息的流式处理和轻计算，帮助用户实现消息的就近计算和分析，并将全面拥抱 Serverless 和 EDA。 所以有什么重大变化？存量业务如何稳定迁移？成了使用者最为关注的问题。
让我们从 What's New 和 Migration from 4.x 中窥探 RocketMQ5 带来的新特性从 What's New 和 Migration from 4.x 中窥探 RocketMQ5 带来的新特性。
关于 RocketMQ 5.0 中的新特性 基础架构云原生化升级轻量API和多语言SDK事件、流处理场景集成 RocketMQ 4.X 升级至 5.0 以下介绍取自官方文档
关于 RocketMQ 5.0 中的新特性 1、基础架构云原生化升级 随着云上架构、云边架构的扩展，虽然 RocketMQ 的组件是简洁轻量的，但是在资源灵活复用、扩展上存在局限性。
RocketMQ 5.0 引入了全新的弹性无状态代理模式，将当前的 Broker 职责进行拆分，对于客户端协议适配、权限管理、消费管理等计算逻辑进行抽离，独立无状态的代理角色提供服务，Broker 则继续专注于存储能力的持续优化。
从使用上最为直观的，就是引入了 Proxy 的模块，承担一个网关的角色，对外对内统一输出，将权限、适配的职能从 broker 身上抽离，是一个重大改造。5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e648dba51777f5dce45d67f70824fa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/5/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>