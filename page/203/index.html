<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b90028ace6765e7886dfd837f46cb7b8/" rel="bookmark">
			京训钉怎么快速看完_钉眼补腻子的方法技巧和注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		钉眼是装修中经常会遇到的问题，它的存在，影响着居室装修的美感和质量，因此有必要通过一些方法处理钉眼的存在，在进行装修的时候，很容易留下这些瑕疵问题，为了不影响装修效果，我们需要进行相应的处理方式。下面上海装修网的小编为大家介绍钉眼修补腻子怎么做? 一、钉眼修补腻子怎么做
1、在进行钉眼修补腻子施工时，先要做好准备工作，也就是检查钉眼没头的大小，标准范围在1到3毫米。再将黑水泥和胶水按照比例混合，进行钉眼的修补，也就是将没头的地方补好，直到看不到钉眼为止。若存在漏底，应返工修补，将表面修补平整。当石膏板上的钉眼补好后，还需对板材的接缝处进行胀缝施工，这样是为了让石膏板装饰更加完美，避免出现缺陷。
2、在使用黑水泥修钉眼时候，需要注意的是如果石膏板存在接缝问题，一定需要将缝隙两边的钉眼一一进行修补工作。不能马虎，一次性修补两三个钉眼，这样很容易将石膏板接缝的地方堵住，在后期使用过程中，容易造成开裂问题。
3、由于石膏板的钉眼是使用螺丝钉所产生的，因此很容易出现氧化作用，从而造成生锈问题。因此在进行修补钉眼时，我们需要进行防锈处理，降低与空气的接触。例如涂刷防锈漆，当然也可以选择不易生锈的螺丝钉，这样可以从源头上，避免问题的发生。
4、另外如果石膏板接缝处的钉眼，使用黑水泥填补好后，没有进行胀缝施工的话，即使后期进行补救工作也是无法解决问题的，极易出现开裂的问题。同时因为石膏板用螺丝钉后，会存在一定的印子，所以即使完全修补好后，还是会看到钉印。这边就需要进行刮腻子的施工，将石膏板表面的钉印覆盖掉，但前提是要做好防锈处理。
二、如何才能让装修无钉眼
1、原子灰，木制品表面缺陷的修补一直是很多业主棘手的问题。有人推荐用原子灰，原子灰具有易刮涂、不易划伤、耐热、柔韧性好等特点，但是原子灰也存在很多问题，如硬度高难打磨，难调色，现调现用麻烦，干得太快，时间久了修补处会鼓起来等问题。也有少许厂家使用猪血灰或自行调制的油灰来修补，效果依然差强人意。
2、液体钉，液体钉，也叫免钉胶，是一种粘合力极强的多功能建筑结构强力胶。液体钉具有以下特点：可粘接几乎所有建材;粘接效果牢固持久;快速固化;具弹性，能随建筑物的收缩移动而移动;可作填缝用途;干燥后不会收缩下陷，可上涂料、油漆;寒冬天气方便易用，甚至可粘接潮湿木材。
3、腻子膏，腻子膏采用少量漆基、大量填料及适量的着色颜料配制而成，所用颜料主要是铁红、炭黑、铬黄等。填料主要是重碳酸钙、滑石粉等。可填补局部有凹陷的工作表面，也可在全部表面刮除，通常是在底漆层干透后，施涂于底漆层表面。
以上内容介绍的是钉眼修补腻子怎么做和如何才能让装修无钉眼。装修会用到许多辅助产品，比如钉子，钉子用过之后会留下钉眼，非常影响美观，装修为的就是美观，现在这一个个的钉眼影响了房子的细节与美观，我们可以选择贴壁纸遮挡，也可以使用以上的方法，避免留下影响美观的钉眼。想要了解更多关于装修这方面的资讯，请继续关注上海装修网。
"钉眼补腻子的方法技巧和注意事项"文章转载来源：上海装修网 http://www.51bozhou.com/thread-823-1-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862cc5d56f10fe0d0db44d96924825c5/" rel="bookmark">
			基于Python Django的疫情人员管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习django的drf框架，就拿了一个图书管理系统，历史一个星期，改造成为一个疫情人员管理系统。分为web 和 app端，可以追踪人员的当前情况，加入了图表统计。文末有下载链接 源码下载
文章目录 实现过程（）相关配置Model设计接口设计前端页面运行情况 实现过程（） 后端使用Python3.6（django、drf框架）
前端使用html（bootstrap框架）
数据库采用的mysql
整体目录结构大概这样
相关配置 Django的一些配置，包括解决csrf、数据库、日志配置、静态文件、跨域请求、Json web token认证这些就不具体描述了，先放配置，大部分在网上都可以搜索到，等有空再统一补充一下有坑的地方。
Web端采用django的session进行认证
App端采用json web token 进行认证
Model设计 根据实际生活，设计了以下几张表
用户表
class MyUser(models.Model): # 用户表 roles = (('manager', "管理员"), ('staff', "普通用户")) account = models.CharField(max_length=20, unique=True, help_text='账户，为手机号') # 账号 password = models.CharField(max_length=20, help_text='用户密码') # 用户密码，明文保存一份，用于web登陆认证 name = models.CharField(max_length=20, null=True, help_text='用户姓名') identification_card = models.CharField(max_length=18, null=True, unique=True, help_text='用户身份证') # 用户身份证 xianshi = models.CharField(max_length=20, null=True, help_text='所属县市') # 所属县市 community = models.ForeignKey(Community, null=True, on_delete=models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862cc5d56f10fe0d0db44d96924825c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a2960e48098a20d17522676a148b03/" rel="bookmark">
			C语言 统计数字字符的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Description 输入一行字符，统计出其中数字字符的个数。
Input 一行字符串，总长度不超过255。 Output 输出为1行，输出字符串里面数字字符的个数。 Sample Input Peking University is set up at 1898. Sample Output 4 Source Code #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(void) { int count=0; char a[1000]; gets(a); for(int i=0;i&lt;strlen(a);i++) { if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') count++; } printf("%d\n",count); return 0; } Computational Results 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82daddd1708554e50264e47281a774c4/" rel="bookmark">
			unity自学第二天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天添加跳跃功能，重点在跳跃速度和重力的计算上。
public class playermove : MonoBehaviour { //void Start()//start()开始函数；当脚本开始加载时，执行下面的函数 //{ //} public float speed; public CharacterController playercontroller;//声明一个叫CharacterController（角色控制器的变量），playercontroller是声明的变量,在unity中要将角色控制器的组件和你创建的脚本中playercontroller相关联 public float jumpspeed = 10; public float gravity = 10;//重力 Vector3 move;//vector3 三维向量 void Update()//每一帧都会执行以下代码 { float x=0, z=0; if (playercontroller.isGrounded)//角色控制器是否在地面上 { x = Input.GetAxis("Horizontal"); z = Input.GetAxis("Vertical"); move = (transform.right * x + transform.forward * z)*speed; if (Input.GetAxis("Jump") == 1) { move.y = jumpspeed; } } move.y = move.y - gravity * Time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82daddd1708554e50264e47281a774c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce6ad65ea5a1ddc411e9bf74c17963b/" rel="bookmark">
			读一篇《基于 Unity3D 的游戏开发》论文有感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一篇论文整体论述了unity3D开发的流程，将一个游戏从无到有的展现在我的面前。这篇论文将游戏划分为两大部分——游戏界面设计和游戏设计。其中又将游戏界面设计划分为开始界面、游戏中界面和结束界面，而游戏设计划分为场景设计、游戏视野设计、游戏主角设计。我更愿意将这两部分称为外在和内里，游戏界面就像是一辆汽车外在设计和表现而游戏设计更是填充在汽车内部更为核心的发动机和其他内部部件，拿现在爆火的游戏《王者荣耀》来说，游戏界面设计就是我们看到的画面感受，而游戏设计就是其中的英雄的技能机制和游戏运行制作机制，两种既相互独立又相互联系才能最终呈现出一个完美的状态。
个人心得：unity开发不仅有宏观的设计还有细节上的美化。要成为一个成熟的unity3d游戏开发者，这些方面都是不可缺少的。在游戏逻辑的方面有这很多考研借鉴设计模式，但是一个游戏光有这些是不够的，像是光影特效、地形场景等方面也都是困难重重。一些特殊的场景一些画面都需要制作者一点一点地拼接起来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1195a368679357103a1e8a4ec2b1a2/" rel="bookmark">
			python中 sys 模块的 sys.stdout 和 sys.stdin 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. sys.stdout
stdout的作用就相当于是把print输出重定向到另一个位置
例如：
import sys print('奥力给') oldPrint = sys.stdout # 用于后期还原 # 把输出重定向到文件 f=open('outfile.log',"a+") sys.stdout=f print('给力奥') sys.stdout = oldPrint # 还原输出位置 运行结果：‘奥力给’会在屏幕中打印，而给力奥则会输出到outfile.log中,不会打印到屏幕上
2. sys.stdin
stdin的作用是标准化输入,可以理解为input
例如：
import sys name=sys.stdin.readline() print(name) 执行到第二行代码的时候,程序会停下,等用户输入数据点击回车后,才会执行下一行
运行结果：打印出用户输入的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b17d279f7a9e576777e4f3ee0a6fde0/" rel="bookmark">
			JSON 语法——03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON 语法 JSON 语法是 JavaScript 语法的子集。
JSON 语法规则 JSON 语法是 JavaScript 对象表示语法的子集。
数据在名称/值对中
数据由逗号分隔
大括号 {} 保存对象
中括号 [] 保存数组，数组可以包含多个对象
JSON 名称/值对 JSON 数据的书写格式是：
key : value 名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：
"name" : "小米" 这很容易理解，等价于这条 JavaScript 语句：
name = "小米" JSON 值 JSON 值可以是： 数字（整数或浮点数）
字符串（在双引号中）
逻辑值（true 或 false）
数组（在中括号中）
对象（在大括号中）
null
JSON 数字 JSON 数字可以是整型或者浮点型：
{ "age":30 } JSON 对象 JSON 对象在大括号 {} 中书写：
{key1 : value1, key2 : value2, ... keyN : valueN } 对象可以包含多个名称/值对：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b17d279f7a9e576777e4f3ee0a6fde0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95fb8de99a5f1315cecc3c3ff851819/" rel="bookmark">
			wget下载kibana5.6.8_球探体育比分app下载-球探体育比分v1.8下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		球探体育比分这是一款体育赛事比分和体育新闻资讯应用，球探体育比分能够第一时间为体育爱好者们带来第一手赛事比分数据和最新体育新闻资讯，球探体育比分让你知道想要知道的一切体育资讯信息。
软件介绍 球探体育比分-足球篮球比分直播,体育赛事精彩数据软件;提供全球足球篮球联赛数据情报,足球即时比分,篮球比分文字直播;体育赛事比分数据直播,联赛资料库历史往绩,赛果概率汇总统计,包括英超NBA,西甲,中超,亚冠,欧冠等足球篮球比分精彩体育竞技直播;
软件特色 1.足球篮球比分直播-即时比分数据分析，体育竞技赛事精彩直播；
2.赛事资料库数据-往绩对比，历史战绩回查；
3.指数对比-赛事数据即时更新对比；
4.赛事即时提醒推送-关注赛事赛前推送，比分进球及时信息通知；
5.球吧球友资讯情报-球吧话题赛事资讯情报，球友圈子即时聊球；
软件亮点 1、即时比分：较快的足球即时比分及比分推送，并提供现场比赛数据直播;
2、即时赔率：较准、较快的即时欧洲赔率、亚洲赔率、竞彩赔率、赔率比较分析;
3、足球推荐: 提供足球原创分析及足球推荐，足球推介;
4、资料库数据：覆盖全球各大小赛事的数据查询;
5、赛事竞猜：体验竞猜乐趣，免费参与，查看亚赔高手，赢取万元彩金;
6、高清视频直播。
软件说明 1、全球赛事尽览掌中：各大联赛球队资料库、赛事比分数据直播
2、百家赔率：百家欧亚赔率公司指数，实时赔率数据专业可靠
3、大数据分析：统计各大赛事历史相同盘口数据，分析胜负平概率
4、盘王竞猜：高手汇聚-免费参与奥运会软件竞猜获巨奖
5、V竞彩/球吧：奥运会专题直播、专业分析推荐集结地
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad54b0e95b0a484470eaba35cb79325c/" rel="bookmark">
			switch手柄可以连电脑吗_掌上游戏不止有switch，你同样可以玩电脑PC游戏《地下城与勇士》...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到掌上游戏机，大家第一个想到的肯定是switch，没有第二个。但是大家也都渴望一件事：掌上游戏机可以玩电脑PC游戏。包括笔者在内，肯定也已经在脑海中想过无数次了。以前受限于各种技术，这只是一个梦想，现在却可以实现！
GPD出了一款掌上PC游戏掌机，真正的为掌上游戏爱好者出的一款专门可以玩PC游戏的掌上笔记本电脑。你没看错，就是全键盘+游戏摇杆的掌上游戏笔记本电脑。
要玩PC游戏，那Windows系统是必不可少的，GPD win2 口袋笔记本电脑出厂预装了win10家庭版系统，正版授权安全可靠。
既然说是掌上PC游戏掌机，那肯定很便携，整体重量只有460g，都不到两个iPhone 11 Pro Max，没错，这就是一台搭载了win10系统的掌上口袋笔记本电脑，真正可以说放到口袋里的笔记本电脑。
GPD win2 口袋笔记本电脑这么小，那都可以玩哪些PC游戏呢？会不会性能不足？答案告诉你——超乎你的想象。不就可以玩PC端的网络游戏，还支持steam游戏，更支持传统的PC游戏，什么《英雄联盟》、什么《地下城与勇士》、什么《魔兽世界》都可以玩！！！
不仅可以玩，还保持了很高的帧率，最近S9夺冠让大家又再次上线的《英雄联盟》更是有这90帧的帧率，完全不用担心游戏性能不够用。真正做到让你走到哪玩到哪的境界。
GPD win2 口袋笔记本电脑做工上丝毫不含糊，酷睿处理器，SSD固态硬盘，专业摇杆手柄，全功能全键盘，多功能接口等。你既可以把它当做是游戏掌机，也可以把它当做是笔记本电脑。不过，这是一台可以放进口袋的笔记本电脑罢了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c08252cadb7a90da9964adb1db61f3e/" rel="bookmark">
			JS基础知识点大汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript基础知识汇总
1、js的简介
JavaScript 是⼀种客户端脚本语⾔（脚本语⾔是⼀种轻量级的编程语⾔，语法和java类似。
JavaScript 通常被直接嵌⼊ HTML ⻚⾯，由浏览器解释执⾏
JavaScript 是⼀种解释性语⾔（就是说，代码执⾏不进⾏预编译）。
特点：弱类型和基于对象。(因为⾯向对象需要具有封装、继承、多态的特征)
JavaScript语⾔中包含三个核⼼：ECMAScript基本语法、DOM、BOM
2、 前端Web技术的组成
HTML、CSS、JavaScript
1)HTML是⼀种标记语⾔，⽤来结构化我们的⽹⻚内容并赋予内容含义，例如定义段落、标题和数据表，或在⻚⾯中嵌⼊图⽚和视频。
2)CSS 是⼀种样式规则语⾔，可将样式应⽤于 HTML 内容， 例如设置背景颜⾊和字体，在多个列中布局内容。
3)JavaScript 是⼀种脚本语⾔，可以⽤来创建动态更新的内容，控制多媒体，制作图像动画，还有很多。
3、js的使用方法
可以像添加CSS那样将 JavaScript 添加到 HTML ⻚⾯中。CSS 使⽤ 元素链接外部样式表，使⽤ &lt;script type="text/javascript" src="my.js"&gt;&lt;/script&gt; 4、JS的基础语法
1）JS的输出：常用的方式有两种：
document.write() ⽅法将内容写到 HTML ⽂档中
console.log() 写⼊到浏览器的控制台
还有两种不经常使用
window.alert() 弹出警告框
innerHTML 写⼊到 HTML 元素
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JavaScript实例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;测试JavaScript的输出&lt;/h3&gt; &lt;div id="did"&gt;div层&lt;/div&gt; &lt;/body&gt; &lt;script&gt; //弹出⼀个信息提示框 window.alert("Hello JavaScript!"); //输出到浏览器⻚⾯中 document.write("这个是⻚⾯中的输出"); //通过写⼊HTML标签中，完成⻚⾯中的输出 document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c08252cadb7a90da9964adb1db61f3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319bb7f04a82c07eb0ea1c40a8665989/" rel="bookmark">
			MATLAB 中的cumsum函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB中的cumsum函数 cumsum（A, n）是求和函数：
其中，第一个参数是要求和的矩阵；
对于第二个参数：当n=1时，对矩阵中的每个元素进行列向上求和；
当n=2时，对矩阵中的每个元素进行行向左求和。
例如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52afb90f568f4c3c86c940b42118162f/" rel="bookmark">
			javascript设计模式_JavaScript经常用的设计模式及其实现方式（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近小编在学习JS设计模式时，经常对其应用场景感到非常不明确。故而专门抽出时间总结一下并分享给大家。今天是第一期分享。
单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
实现：
用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象。
let Singleins = function(name){ this.name = name; this.instance = null;}Singleins.prototype.getName = function(){ console.log(this.name)}Singleins.getInstance = function(name){ if(!this.instance){ this.instancee = new Singleins(name); } return this.instance;}let a = Singleins.getInstance('test1');let b = Singleins.getInstance('test2');alert(a === b); //true 策略模式 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
实现:
策略模式的目的就是将算法的使用与算法的实现分离开来。利用JS实现的策略模式如下：
let strategies = { "S":function(num){ return num * 4; }, "A":function(num){ return num * 3; }, "B":function(num){ return num * 2; }};let useStrategy = function(level,num){ return strategies[level](num);};useStrategy('S', 2000); //8000useStrategy('A', 1000); //3000 代理模式 定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52afb90f568f4c3c86c940b42118162f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e4cc489b3e4f479473884589060b72/" rel="bookmark">
			秀米复制到公众号格式变了_有哪些好用又免费的公众号编辑器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好问题。
对新媒体人来说，选对编辑器，跟选对人结婚一样重要。 新媒体运营人的公众号编辑器，就是鲁迅的笔，关公的刀，姜子牙的鱼竿，哪吒的风火轮，六老师的金箍棒，李云龙的意大利炮，五条人的拖鞋，蔡徐坤的篮球。
选择一个适合自己的公众号编辑器，是当代新媒体人的刚需。
我刚做公众号那会儿，也纠结到底选哪款编辑器。我是个认死理爱钻牛角尖的人，如果用不上最适合自己的工具，总觉得亏了一个亿。
于是就研究，到处看别人的评测，然后自己去找工具，试用，最终弄出了一套让自己满意的评测报告。也就是这篇文章。
我相信这个诚意满满的评测为你节省的时间和精力是无可估量的。
以下为原文。
（3500字干货+多图多表情包警告！ 来不及看完全文的可以收藏再看，也可以拉到文末直接看结论！） 本文我会从最大优点、最大缺点、新人友好度、模板选择度、美观流畅度、氪金性价比这几个维度比较现在最火的四款编辑器：
秀米、135、壹伴、i排版。
秀米——文艺剽悍小野马 http://xiumi.com
秀米，没想到这个充满乡土气息的名字，却是编辑器里的文艺担当。
最大优点：自由度极高。 用秀米最大的感叹就是：自由度实在是太太太高了：
各种小部件数量超多而且颜值普遍能打，菜单一拉拉不到底。
（选择困难症同学：
这还不算最狠的，重点来了：
所有小部件都能自由编辑！
比如下面这个图片框，看起来是一个整体，但它所有的小部件都可以单独调整。
左上角用来装饰的樱花，可以修改贴图、色彩、大小、位置：
图片本身，可以调节的选项就更多了：
PS：
2. 最大缺点：只能输入不能输出！
秀米因为有一套自己的布局系统，所以其他地方的图文，一旦复制粘贴进入秀米，会只剩下文字并且丢失所有的格式！
因此，任何文章导入秀米之后，只能从纯文本的状态开始排版。不能用来修改已有的排版，也不能在其他软件上做好配图之后再导入秀米。
这个巨大缺陷足以劝退很多很多用户了：
《论新媒体人是如何抛弃秀米的》 当然也有导入图文的功能，只有以下三种方式：
但是导入word文档依然会被清除所有格式，导入微信图文则需要VIP，总之就是非常的不友好。
3. 专项评分：
A. 新人友好度：☆☆
进官网之后第一个页面看起来特别简单：
点击 “ 新建一个图文 ” 就可以开始编辑了。
然而这也是新手唯一会觉得简单的时候！从此以后就是一连串的懵逼了！
复杂到什么程度呢？网易云课堂甚至为秀米专门开设了视频课程，而且还是付费课程！
一个本意是给用户提供方便的工具，甚至需要用户另外付费去学习，这就很离谱。
因为！秀米的工作逻辑和我们使用的大多数编辑软件不一样！它有自己的一套叫“流式页面”的东西。在它的官网上是这么解释的：
但是相信大多数人跟我一样，完全看不懂它在说啥。
我用下来之后只能说，总之就是有些地方跟别的软件不一样：
举个例子，你不能像往常一样在把图片在文章里随意拖动位置，也不能按住图片的角就能调整它的大小，这些在秀米里都需要不一样的操作。当然也不是说这种特殊的规则就不好，它能很好地帮你把图文都束缚在一个规则的框架里，这样看起来会更加规整跟美观。
前提是你完全掌握并且熟悉了它的特殊规则。而这对于新手来说是要花费不少的时间成本的。
B. 模板选择度：☆☆☆☆☆
在模板的丰富度和好看程度上，秀米可以很自信地对其他编辑器说：
这点不用我吹太多，大家可以自己进秀米去看看，只能说编辑器与编辑器之间的审美，是有差距的。
C. 美观流畅度：☆☆☆☆
制作团队的审美一直在线，所以秀米的界面还是非常清新的：
但是由于前文所述特殊逻辑的问题，偶尔它的交互体验会令你非常抓狂，可能你加入一个小部件之后发现需要按十几次Delete才能把它彻底删除掉，还可能一个误操作就让你整个排版突然炸了。。。
好在这一切会在使用者熟练度提高之后有所改观。
D. 氪金性价比：☆☆☆
如果说免费版的秀米存在这样那样的问题的话，氪金之后，其中很多会有所缓解，比如直接从微信导入图文。
另外，秀米在氪金之后会拥有海量好看的风格排板，可以一键完成整个文章的排版，而且其B格是其他编辑器比不了的，对于不想在排版上加入自己想法、花费太多精力的懒人来说是个非常好的选择：
模板会员价格：20元/30天，60元/90天，200元/360天。
还是有点肉疼的，然而这就是力量的代价！
4. 综合评价：☆☆☆
如同小标题所说，秀米就是剽悍文艺小野马，好看、选择多、自由度高，但是有自己独特的个性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e4cc489b3e4f479473884589060b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b70bec561eb13e11aa3821fb72cc07f/" rel="bookmark">
			matlab中cumsum函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cumsum函数通常用于计算矩阵中按行或列进行累加求和。计算累加函数后的结果数量和输入元素的数量一样。一般用法如下：
cum(A,dim) cumsum(A)
【注】cumsum累加函数默认是按照列进行计算的
A =
1 2 3
4 5 6
7 8 9
&gt;&gt;B=cumsum(A)
B = 1 2 3
5 7 9 12 15 18
&gt;&gt; B=cumsum(A,1)
B =
1 2 3
5 7 9
12 15 18
&gt;&gt; B=cumsum(A,2)
B =
1 3 6
4 9 15
7 15 24
当传入的是一个向量的时候，
&gt;&gt; cumsum([1,2,3,4])
ans =
1 3 6 10
输出结果为按照行累加的结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13073d3523a8520989441c4154bf9fe/" rel="bookmark">
			matlab--16进制转ASCII代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab–16进制转ASCII代码 前言 由于对RTK设备输出转换的需要，撰写了一个matlab转换16进制到ASCII代码。
一、读文件 1.textscan C = textscan(fileID,formatSpec)
将已打开的文本文件中的数据读取到元胞数组 C。该文本文件由文件标识符 fileID 指示。使用 fopen 可打开文件并获取 fileID 值。完成文件读取后，请调用 fclose(fileID) 来关闭文件。
配合fopen使用！
2.cell数组 1.cell数组的创建
可以直接通过{}类似于矩阵的直接赋值：a={‘winter’,123,‘coming’,‘哈哈’};
2.cell数组的访问
与普通矩阵，数组的主要区别在于：通过（）访问cell数组时访问到的是cell单元,通过{}访问cell数组时访问到的是cell单元储存的内容，举例如下图所示，其他操作基本一样。
元胞数组操作类似但和其赋值一样有区别，区别就在于{}和()
a={1,2,3};
a{1}=[];%并不能删除第一个cell单元,只是变成空值
a(1)=[];%删除第一个单元
3.字符转换命令 hex2dec(data)
16进制转到十进制
char(hex2dec(data))
16进制转到char
4.num2str()与num2double的区别 两者都是能够将数字转为字符串
相同点： 当str为一个含数字的字符串时， str2num 函数与 str2double 函数一样。
不同点：当str为多个字符串构成的数组时， str2num 函数与 str2double 函数有区别。
如：
二、代码 path = 'D:\Rtk主机-2020-11-12-14-27-30.txt'; fid = fopen(path, 'r+'); if fid == -1 disp('fopen failed'); else ReadData = textscan(fid,'%s'); end fclose(fid); data_hex = ReadData{1}; % 取cell len = length(data_hex); % 16进制转为ASCII row_num = 0; % 行 line_num = 0; % 列 data_char = {}; flag_time_trans = 0; % 时间格式转换标志 flag = 0; % 十六进制转ASCII for i=1:len if(char(data_hex(i,1))=='&lt;') row_num = row_num+1; line_num = 1; flag_time_trans = 1; disp(['开始转换第',num2str(row_num),'行！']); continue; elseif(char(data_hex(i,1))=='&gt;') flag = 0; % 完成一行的转换 continue; elseif(char(data_hex(i,1))=='|') flag = 1; continue; elseif(flag == 1) data_char(row_num,line_num) = {hex2char(data_hex(i,1))}; % 16进制数据转换为char line_num = line_num + 1; elseif(flag_time_trans == 1) seconds = seconds_trans(data_hex(i,1),data_hex(i+1,1)); % 时间转换格式 data_char(row_num,line_num) = {seconds}; line_num = line_num + 1; flag_time_trans = 0; end en function data = hex2char(data_hex) % 把0x去掉从十六进制转成10进制再转成char data = char(data_hex); data = data(1,3:4); data = char(hex2dec(data)); end function seconds = seconds_trans(years,hours) % 时间字符转为数字 years = char(years); hours = char(hours); seconds = num2str(str2double(hours(1,1:2))*3600000+str2double(hours(1,4:5))*60000+str2double(hours(1,7:8))*1000+str2double(hours(1,10:12))); end 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e13073d3523a8520989441c4154bf9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943832c7be1fa0e3a4d71bfae8ed982c/" rel="bookmark">
			线性回归，决策树，knn等6种机器学习回归方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 线性回归： 线性回归所能够模拟的关系其实远不止线性关系。线性回归中的“线性”指的是系数的线性，而通过对特征的非线性变换，以及广义线性模型的推广，输出和特征之间的函数关系可以是高度非线性的。
决策树： 在特征选择中通常使用的准则是：信息增益。
决策树生成选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。
ID3 算法 ID3 是最早提出的决策树算法，他就是利用信息增益来选择特征的。
C4.5 算法 他是 ID3 的改进版，他不是直接使用信息增益，而是引入“信息增益比”指标作为特征的选择依据。
CART（Classification and Regression Tree） 这种算法即可以用于分类，也可以用于回归问题。CART 算法使用了基尼系数取代了信息熵模型。
决策树的优缺点 优点
决策树易于理解和解释，可以可视化分析，容易提取出规则；可以同时处理标称型和数值型数据；比较适合处理有缺失属性的样本；能够处理不相关的特征；测试数据集时，运行速度比较快；在相对短的时间内能够对大型数据源做出可行且效果良好的结果。 缺点
容易发生过拟合（随机森林可以很大程度上减少过拟合）；容易忽略数据集中属性的相互关联；对于那些各类别样本数量不一致的数据，在决策树中，进行属性划分时，不同的判定准则会带来不同的属性选择倾向；信息增益准则对可取数目较多的属性有所偏好（典型代表ID3算法），而增益率准则（CART）则对可取数目较少的属性有所偏好，但CART进行属性划分时候不再简单地直接利用增益率尽心划分，而是采用一种启发式规则）（只要是使用了信息增益，都有这个缺点，如RF）。ID3算法计算信息增益时结果偏向数值比较多的特征。 KNN: kNN算法的核心思想是如果一个样本在特征空间中的k个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别
优点
理论成熟，思想简单，既可以用来做分类也可以用来做回归；可用于非线性分类；训练时间复杂度为O(n)；对数据没有假设，准确度高，对outlier不敏感；KNN是一种在线技术，新数据可以直接加入数据集而不必进行重新训练；KNN理论简单，容易实现； 缺点
样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）效果差；需要大量内存；对于样本容量大的数据集计算量比较大（体现在距离计算上）；样本不平衡时，预测偏差比较大。如：某一类的样本比较少，而其它类样本比较多；KNN每一次分类都会重新进行一次全局运算；k值大小的选择没有理论选择最优，往往是结合K-折交叉验证得到最优k值选择； 随机森林： 随机森林是由很多决策树构成的，不同决策树之间没有关联。
当我们进行分类任务时，新的输入样本进入，就让森林中的每一棵决策树分别进行判断和分类，每个决策树会得到一个自己的分类结果，决策树的分类结果中哪一个分类最多，那么随机森林就会把这个结果当做最终的结果。
随机森林的建立过程：
随机森林的优缺点 优点
它可以出来很高维度（特征很多）的数据，并且不用降维，无需做特征选择它可以判断特征的重要程度可以判断出不同特征之间的相互影响不容易过拟合训练速度比较快，容易做成并行方法实现起来比较简单对于不平衡的数据集来说，它可以平衡误差。如果有很大一部分的特征遗失，仍可以维持准确度。 缺点
随机森林已经被证明在某些噪音较大的分类或回归问题上会过拟合。对于有不同取值的属性的数据，取值划分较多的属性会对随机森林产生更大的影响，所以随机森林在这种数据上产出的属性权值是不可信的 boost: 具体过程：
通过加法模型将基础模型进行线性的组合。每一轮训练都提升那些错误率小的基础模型权重，同时减小错误率高的模型权重。在每一轮改变训练数据的权值或概率分布，通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。 优点：
很好的利用了弱分类器进行级联；可以将不同的分类算法作为弱分类器；AdaBoost具有很高的精度；相对于bagging算法和Random Forest算法，AdaBoost充分考虑的每个分类器的权重； 缺点：
AdaBoost迭代次数也就是弱分类器数目不太好设定，可以使用交叉验证来进行确定；数据不平衡导致分类精度下降；训练比较耗时，每次重新选择当前分类器最好切分点； GBDT： 基于残差来做。
GBDT 它的非线性变换比较多，表达能力强，而且不需要做复杂的特征工程和特征变换。GBDT 的缺点也很明显，Boost 是一个串行过程，不好并行化，而且计算复杂度高，同时不太适合高维稀疏特征；传统 GBDT 在优化时只用到一阶导数信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de09739593b61ec8341d1b6239b38e2f/" rel="bookmark">
			LeetCode 915. 分割数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 题目2. 解题 1. 题目 给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得：
left 中的每个元素都小于或等于 right 中的每个元素。left 和 right 都是非空的。left 要尽可能小。 在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。
示例 1： 输入：[5,0,3,8,6] 输出：3 解释：left = [5,0,3]，right = [8,6] 示例 2： 输入：[1,1,1,0,6,12] 输出：4 解释：left = [1,1,1,0]，right = [6,12] 提示： 2 &lt;= A.length &lt;= 30000 0 &lt;= A[i] &lt;= 10^6 可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/partition-array-into-disjoint-intervals
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
2. 解题 用两个数组记录：左侧最大的，右侧最小的遍历上面的数组，找到第一个位置，左侧最大的 &lt;= 右侧最小的 class Solution { public: int partitionDisjoint(vector&lt;int&gt;&amp; A) { int n = A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de09739593b61ec8341d1b6239b38e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3a847ba741b36f0fc1f2ee3439234d/" rel="bookmark">
			Bazel 与 gtest：构建一个最简单的测试驱动开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bazel 介绍 Google 自家的构建工具，相比 CMake 的优势，主要是多语言构建和相比 Make 语法有更好的可读性。最著名的使用 Bazel 的项目大概是 Tensorflow 吧。目前生态上还是不太好和 CMake 相提并论，毕竟下面的命令已经像魔法一样刻在 Unix 的世界里。
./configure make make install 安装 Bazel Mac 用户当然是使用 brew 解决了：
brew install bazel 安装参考官网吧～
Hello Bazel 要使用 Bazel，首先在项目顶层目录创建一个名为 WORKSPACE 的文件。值得一提的是 Bazel 推崇的是 Monorepo ，建议的项目结构是把代码、测试代码放到一起。在 C/C++ 中，意味着更加推荐头文件、源码文件、测试文件都放到同一个目录下。如果按 include、src、lib、test 拆分，在 Bazel 的设计下，反而会增加难度。
因此我们就创建一个 src 文件夹，并在该文件夹下建立 BUILD 文件。WORKSPACE 顾名思义是工作区，BUILD 就是具体的构建目标。
. ├── WORKSPACE └── src ├── BUILD 在 src 下创建一个最简单的 C++ 文件：
#include &lt;iostream&gt; using namespace std; int main(int argc, char* argv[]) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3a847ba741b36f0fc1f2ee3439234d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923c03fed5dcc0bda4ab7fc05021e647/" rel="bookmark">
			有人在开课吧学习过吗？值得信任吗？教学质量如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：开课吧值得信任吗？
答：开课吧是值得信任得！因为开课吧是一家数字化人才在线教育平台，而且成立时间是比较早的，早在2013就已经上线运营了，在国内是最早专注于IT互联网和数字化领域的在线教育机构之一！
如今的开课吧已经成为业界口碑最好的培训机构之一了，为什么这样说呢？因为在开课吧毕业的学员已经超过400万人了，这是什么概念？在你们周边做IT的朋友中，几乎都有在开课吧学习过的经历。
时间是最好的老师，经历7年的开课吧一直在完善人才服务，也经得起岁月的磨练。所以IT培训的老品牌，是值得信任的。
问：开课吧的教学质量如何？交完费后是否就不管了？
这个疑问每位学员都会有的，但是加入开课吧后，所有的学员的疑虑都打消了！为什么会这样的肯定回答？来看看原因吧！
来开课吧学习的学员都知道，开课吧是有师徒制度的，一个老师只带8-15名学生，老师负责带领学生做项目，还有一名专职辅导老师帮助学员解答疑难（24小时辅导），还有班班老师不停的督促你学习，这些班班老师有多厉害？就像唐僧念经一样，一直督促你学习，就算意志力差点的学生，照样能学好！除了吃喝都需要让别人帮你解决的那一些人。所以教学质量绝对是杠杠的！
但是别培训机构就不一样了，一个老师带的学员有30个的，50个的，甚至有的超过百个的，这样老师怎么去给学员解决问题？每个学员一天一个问题，一个老师怎么回答过来？学员肯定就无法提高自己的能力，遇到问题也无法快速得到解决，浪费的只是自己的时间和金钱罢了。
开课吧的师资力量全部是从大厂出来的一线老师，拥有很丰富的履历和能力，教学质量绝对是能保障的。（开课吧是有BAT内推名额的！有些学习差的学员，在开课吧学完后，就收到大厂的offer了！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89c980d9d9bf40785fff0f685fd9440/" rel="bookmark">
			如何获取级联选择器选中的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到了一个级联选择器的问题：如何将选中的值反馈给后端。
问题已解决：亲测有效，成功
查资料的结果：
*this.$ref[‘cascaderAddr’].getcasederNodes[0].label
*this.$ref[‘cascaderAddr’].getcasederNodes
*this.$ref[‘cascaderAddr’].getcasederNodes[0].label ---------//getcasederNodes用了后，控制台报错：说getcasederNodes没有被定义，开始我还想那应该只需调用，结果给了我一巴掌
*this.$refs.cascaderAddr.currentLabels[i]
cascaderAddr这个还需要去注册
里面有些数据是没有完全展示出来，抱歉，由于岗位原因，大家应该都知道这个梗
当时遇到的是sub_org为空（undefined），查了半天的资料，结果发现自己没有加接参的属性值value
在props中加入value这个属性，其对应你要给后端反馈该值的那个属性
注意：这里的value对应着事件中携带的数据value
&lt;el-col :span="4"&gt; &lt;el-form-item prop="two_institutions" :rules="[{ required:false,message:'管理机构不能为空',trigger:'blur' }]"&gt; &lt;el-cascader style="width:480px;" v-model="userForm.two_institutions" :options="options_two" :props="{ expandTrigger: 'hover',value:'id' }" :show-all-levels="true" clearable @change="handleChange" &gt;&lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; methods函数事件： handleChange(value){ this.$http.get('api/user/seekorg/').then(res =&gt; { ++this.cascaderKey this.optionsList = res.data.source this.options_two = res.data.source }).catch(err =&gt;{ }) }, //该函数主要是把后端获取的值赋给级联选择器 //新增事件 Add(){ // const token = sessionStorage.token const params = { // headers:{ 'Authorization': sessionStorage.token }, name:this.userForm.name, //用户名 phone_num:this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89c980d9d9bf40785fff0f685fd9440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241846b3c8f8bd3aa9b795a71c0d5438/" rel="bookmark">
			Event-based vision
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Event-based vision 论文阅读笔记 一下内容仅仅是记录自己的论文阅读。
一、Event-based Vision: A Survey 该论文属于综述性文章，对基于事件视觉做了全面的阐述。论文主要介绍了事件相机的原理及事件的处理等等。
1.事件相机的原理 异步的监察每个像素感知器的亮度变化情况，从而产生一个事件，多个像素的变化就产生了事件流。（DVS128、DAVIS240、ATIS等），输出事件格式为AER格式。
2.事件相机与传统相机的区别 优点：
1)高时间分辨率：能够更快的捕捉亮度的变化，从而不会像传统相机那样产生运动模糊。
2)低延迟：APS相机成像都是按照固定的频率，一般1s/30fps,而事件相机的频率在1kHZ。
3)低能耗：由于事件相机是异步的对每个像素点进行监测，只有当强度变化超过预设阈值时才会产生事件流。故在无运动发生时将会一直处于待机状态。
4)高动态范围：事件相机能够在更大的动态范围内对运动做出响应（120dBvs60dB)。
5)低冗余：只输出动态变化信号，其背景等信息不会输出，故相比APS数据少了很多冗余数据。
3.事件的表示方式 1）一维：将事件作为一个一个单独的脉冲序列进行处理（event-by-event)，常采用基于概率模型的处理方式或SNN（脉冲神经网络进行处理）。
2）二维：二维的表示方式也是最常用的方式，因为它可以与我们传统的方式就行模型的学习。常用的处理方式有：堆积成帧（按事件个数、按时间间隔）、Time-Surface（时间平面）、Grid（随机采样生成图）。
3）三维：直接将T作为三维轴，然后使用PointNet等直接进行特征学习。
应用 由于时间相机只是一种样本的获取方式，所以只要对事件进行合理的处理，其可以应用到APS所能应用的所有的应用中。例如：目标检测、目标跟踪、姿态估计等。
二、A Low Power, Fully Event-Based Gesture Recognition System 主要贡献 1.该文第一次实现了基于事件的端到端的姿态识别系统。
2.发布了真实场景下的用于姿态识别的数据集（DvsGesture)
三、Real-Time 6DOF Pose Relocalization for Event Cameras withStacked Spatial LSTM Networks 主要贡献 1.提出了SP-LSTM 网络结构，按时间片的方式来集成时间帧，采用CNN提取深度特征信息，后采用LSTM。（CNN采用VGG16,LSTM2个隐藏层，加入dropout=0.5防止过拟合）。
2.使用对象损失函数，L(I) =‖ˆp−p‖2+‖ˆq−q‖2 （ˆp、ˆq是从网络中预测的位置和方向在哪里）
3.提出了数据集划分的新方式，将一个时间的帧序列前70%作为训练集，后30%作为测试集。
code https://github.com/nqanh/pose_relocalization（仅采用6-DOF数据集的事件作为输入） 源码是kears，利用pytorch复现了下（误差在0.1左右），效果不是很好（容易过拟合）。
下面两篇发散论文是这篇论文网络结构的启发： ①、Image-based localization using LSTMs for structured feature correlation
主要贡献 1.利用CNN + LSTM 对相机的位置进行回归预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241846b3c8f8bd3aa9b795a71c0d5438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65f83835995ead9768005872ffd7d02/" rel="bookmark">
			微积分(一)笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：这是暑假在B站温习微积分找到的教程，自己做了一些笔记（有时间就翻译）和习题（没有答案，自己做的不保证对），现记录如下。
神秘学校 微积分一 (The School You Don’t Know Which, CASE)
实数理论 omit…
数列极限的定义与性质 Def Let a n ( n ∈ N ) \;a_n(n\in N) an​(n∈N) be a sequence in R R R and L ∈ R L\in R L∈R, we say a n a_n an​ converge to L ( a s n → ∞ ) L\,(as \;n\rightarrow\infty) L(asn→∞) if
∀ ϵ &gt; 0 ∃ N 1 ∈ N s .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65f83835995ead9768005872ffd7d02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/147e782d39f7bdce3fd70396f670c2d9/" rel="bookmark">
			Android 实现首次开机启动wizardsetup程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 实现首次开机启动wizardsetup程序
Android Provision（开机向导setupwizard程序）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991c0b35c5f3ec110ebc5fae1367ddc8/" rel="bookmark">
			electron ant-design-vue 不能用_桌面端跨平台解决方案之Electron简介与快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及到的概念会很多，为了控制篇幅，这里更多的是抛砖引玉，更多资料需要大家到参考资料中自行补充相关知识概念。
Electron简介 Electron（最初名为Atom Shell）是GitHub开发的一个开源框架。它允许使用Node.js（作为后端）和Chromium[^chromium]（作为前端）完成桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端与后端的开发，著名项目包括GitHub的Atom和微软的Visual Studio Code。
Electron是一个由GitHub开发的开源库，通过将Chromium和Node.js组合并使用HTML，CSS和JavaScript进行构建Mac，Windows，和Linux跨平台桌面应用程序.
这不意味着 Electron 是绑定了 GUI 库的 JavaScript。相反，Electron 使用 web 页面作为它的 GUI，所以你可以把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器。
Chromium 枫树浏览器是一个基于Chromium的Windows/Linux浏览器。新增了部分功能，如鼠标手势，链接拖动及IE标签。（最后一次更新于2013-08-29，基带版本27.0.1453.110[11]）世界之窗浏览器极速版（TheWorld Chrome版）搜狗高速浏览器：基于Chromium开发，同时加入了IE内核引擎。360浏览器极速版：基于Chromium开发，同时加入了IE内核引擎。猎豹浏览器：基于Chromium开发，同时加入了IE内核引擎。傲游浏览器：基于Chromium开发，同时加入了IE内核引擎。七星浏览器：基于Chromium开发，同时加入了IE核心引擎。外观和枫树浏览器类似。QQ浏览器：基于Chromium开发，针对IE内核优化。百度浏览器：基于Chromium开发。 Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。
为什么选择 Electron Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。 够火（5w+ star）。Electron 的作者和 NW.js（原 node-webkit）是同一人，大家可以去知乎围观维护一个大型开源项目是怎样的体验？这个问题下作者的回答。官方也有 Electron 和 NW.js 的对比
作者先是在Intel工作开发维护node-webkit（后改名NW.js），之后加入GitHub开发Atom编辑器，编写了一个新的桌面应用框架，当时的名称叫做atom-shell，之后开源，而后改名Electron
Electron基础概念 主进程和渲染进程 Electron 中，入口是一个 js 文件，运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 BrowserWindow 模块可以创建并管理 web 页面，也就是应用的 GUI。
const {BrowserWindow} = require('electron') // 主进程创建web页面 let someWindow = new BrowserWindow(winOpts) // 加载本地的文件 someWindow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991c0b35c5f3ec110ebc5fae1367ddc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f89f7467ba8ebf32001eb59582aa85cd/" rel="bookmark">
			idea项目和部署到tomcat上读取项目文件路径出现乱码，20%等问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在idea上能够正常读取到项目资源上的图片，到了tomcat8上就识别不了，打印发现路径上的空格处竟然变成了20%这样的乱码，现在给出一致性的解决办法，在idea和tomcat上写法一样。我的项目路径如下图所示：项目是运行在idea上的springboot2.X，
现在程序需要读取static/img/front.png文件，那么通用的写法为
import org.springframework.util.ResourceUtils; import javax.imageio.ImageIO; import javax.swing.*; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.net.URLDecoder; //以下为关键代码
File path = new File(ResourceUtils.getURL("classpath:").getPath()); String decoderURL= URLDecoder.decode(path.getAbsolutePath(),"utf-8"); File upload = new File(decoderURL,"static/img/front.png"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7be6a12c75ff469fca1afccc33bea1/" rel="bookmark">
			python中唯一的映射类型是-Python内置类型及常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python的内置数据类型非常丰富，大致可以分为五类：None、数字类型、序列类型、映射类型和集合类型。下面我将分别对他们进行介绍，做个总结以备以后查看。下面的表列出了各个类别下的具体数据类型。*注：本文所讲的内容都是基于python2的，python3会有些不同*。类型分类类型名称描述
NoneType(None)null对象None
数字类型int整数
long长整数，任意精度（python2）
float浮点数
complex复数
bool布尔值（True或False）
序列类型str字符串
unicodeUnicode字符串（python2）
list列表
tuple元组
xrangexrang()创建的整数范围
映射类型dic字典
集合类型set可变集合
frozenset不可变集合
1.NoneNone表示一个null对象，这是一个空对象，如果一个函数没有返回值，则返回null对象。None没有任何属性，在布尔表达式中表示False。
2.数字类型除了布尔类型外，所有数字类型都是有符号的。整数的表示范围在-2147483648和2147483647之间，长整数可以表示任意长度，只受可用内存大小的限制。
#整数
i=123
i=int(123)
#长整数
l=123L
l=long(123)
浮点数是双精度类型(64bit)，和c语言中double相同，数值范围-1.7*10(-308)到1.7*10(308)。f=12.3
f=float(12.3)
复数使用一对浮点数表示，分为实部和虚部，使用real和imag访问，虚部后缀j或J。c=1.0+2.3j
c=complex(1.0,2.3)
printc.real,c.imag
布尔值只有True和False两个值，分别映射为整数1和0。b=False
b=bool(True)
2.1.数字运算除了布尔类型外，int、long、float和complex都可以使用的运算为：加、减、乘、除、整除、幂运算和取余。下面分别举例说明。
&gt;&gt;&gt;1+2# 加法
3
&gt;&gt;&gt;1-2# 减法
-1
&gt;&gt;&gt;2*3# 乘
6
&gt;&gt;&gt;2/4# 整数除
0
&gt;&gt;&gt;2/4.0# 浮点除
0.5
&gt;&gt;&gt;3// 2.0 # 整除
1.0
&gt;&gt;&gt;2%3# 取余
2
&gt;&gt;&gt;3**2# 幂运算 =3^2
9
对于整数还可以进行位运算，共有6种位运算：取反(~)、左移(&lt;&lt;)、右移(&gt;&gt;)、异或(^)、按位或(|)、按位与(&amp;)。&gt;&gt;&gt;~1# 1取反后为-2的补码
-2
&gt;&gt;&gt;8&lt;&lt;1# 左移
16
&gt;&gt;&gt;8&gt;&gt;2# 右移
2
&gt;&gt;&gt;1^3# 01 和 11 异或得到10，就是2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7be6a12c75ff469fca1afccc33bea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd7006772aac034d8559cecece3224a/" rel="bookmark">
			【linux】解决ACL找不到有效的文件系统超级块Bad magic number in super-block
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在查看指定分区详细文件信息时，用dumpe2fs 时却发现报错，
dumpe2fs: Bad magic number in super-block 当尝试打开 /dev/sda1 时找不到有效的文件系统超级块.
这个是因为在安装CentOS7时，根分区默认使用的文件系统类型是xfs,而7以前的版本如6使用的是ext4类型。
具体步骤：
1.我们首先查看下当前系统有哪些分区:
df -h 2.用dumpe2fs查看指定分区详细文件信息:
dumpe2fs -h 分区路径 因为两个版本系统的根目录使用的文件系统类型不一样，dumpe2fs是查看ext2/ext3/ext4 文件系统信息的命令
3.用 xfs_growfs来查看文件系统信息
xfs_growfs 分区路径 结论：
所以在centos6时用 dumpe2fs 命令，在 centos7时 用 xfs_growfs来查看文件系统信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d321ab4f36080b9e6a8832b74b12093b/" rel="bookmark">
			专业之旅——GitHub 热点速览 Vol.45
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-小鱼干
从入门到精通需要什么？AI-Expert-Roadmap 带你开启专业之旅，和 135k+ 高星项目 developer-roadmap 一样， AI-Expert-Roadmap 这个“后辈”刚开源便获得过 4k+ star，可见它的专业深得程序员意。同样出色的还有 Mastering_Go 中文版，HG 微博推荐之后便获得大量转发可见它的受欢迎程度。说到专业，高门槛的 AI 项目 PIFuHD 本周表现也不俗，凭借这照片变 3D 模型的 professional，一日便获得近 1k star…
以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：新发布 | 实用 | 有趣，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 New，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝
本文目录 本周特推 1.1 专业之旅：AI-Expert-Roadmap1.2 玩转 GO：Mastering_Go_ZH_CN GitHub Trending 周榜 2.1 这个安全工具有点秀：NAT Slipstreaming2.2 轻量级编辑器：Ox2.3 照片秒变 3D 模型：PIFuHD2.4 无线渗透套件：Pi-PwnBox-RogueAP2.5 可视化学算法：Algorithm Visualizer2.6 企业级程序引擎：Workflow2.7 超微图标：SuperTinyIcons 推荐阅读 1. 本周特推 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d321ab4f36080b9e6a8832b74b12093b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72dd8e649f61a2565c5043b29ac09b09/" rel="bookmark">
			switch手柄可以连电脑吗_组装电脑见怪不怪，现在游戏手柄也可以组装了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新年伊始，托尼在这里先给大家拜个早年。 ( 大误，新年春节俩年 ) 说起来，今年的农历春节过得特别早，作为一个大门不出、二门不迈的典型宅男，托尼早早的就在 PS4 上囤好了去年的游戏大作，只等放假的时候大快朵颐。 就在这节骨眼上，碰到一件尴尬的事情，手柄口渴喝了水，信仰灯突然就熄灭了。。。 确实，DS4 ( PS4 的手柄 DUALSHOCK4 简称 DS4 ) 可能是唯一 PS4 不如Xbox One 的地方，续航扑街就不多说了，扑街到身为无线手柄大部分时间只能以连着线的状态示人。。。 基操基操~▼
对称摇杆的手感用久了和屎糊的没两样，阻尼和顿挫都有一种说不出来的不舒适，可怕的是，玩的时间长了之后，还有可能患上腱鞘炎，下半生或许只能用脚玩游戏了。 至于 L、R 肩键的手感，DS4 摸上去平平的，丝毫没有摁下去的欲望，而 Xbox 手柄前凸后翘的质感，配合四个马达的震动，在枪战游戏中的冲锋陷阵让人欲罢不能。 PS4 党苦 DS4 久矣。。。 “ 别扯这么多有的没的，完事儿你托尼就是个索黑呗，啥啥都不好，你到底想说啥？” 各位看官老爷也别急，有一说一 DS4 的综合素质的确不如人 Xbox Controller ，但这也不代表这索尼没有相关的产品，看到这个牛皮哄哄的标志了没，这玩意儿比啥众筹 P2P 都管用。 PlayStation 官方认证产品▼
这不，索尼自个儿不愿意再下心思的硬件，自有大把的第三方厂商愿意代劳，老牌外设厂商 Hori、雷蛇自不必说，Nacon 更是直接把外设直接做成了 Xbox 手柄的模样。 看着红圈的信仰灯，多可人儿！▼
说实话托尼是心动的，可指鹿它不是马，鸡再嘎嘎嘎也不是鸭，Nacon 明显就是Xbox手柄的设计，既没有对称的摇杆，怎能称为信仰？ 就在我捂住胯胯轴 ( 发愁 ) ，纠结要不要买 Nacon 的时候，一家名为图斯马特的外设厂商引起了托尼 的注意，他们家这款叫 eSwap Pro 的模块化手柄，瞬间把托尼给看湿了 ( 热泪盈眶 ) 。 简直不能再妙， eSwap Pro 模块化的设计既能变换成 Xbox 手柄的键位排布，也能保留原有的 PS4 键位设计，一柄 N 用，不亦说乎？ 有意思的是， 图马思特这个牌子的英文字儿 Thrustmaster 还贼像 Transformers ( 变形金刚 ) ，如果真如广告里介绍的那样，那也算是名副其实的变形金刚了。 话不多说，托尼兴冲冲打开某宝一看，哇 1499 元。。。 这价格也不算太贵，你看原价要 1899 元呢，之前买的精英手柄二代 不也 是这个价？钱嘛，纸嘛，花嘛，大丈夫男子汉下单从不犹豫！ 就这样吃了几天土，心心念念的手柄终于在前两天到货了！不说别的，光看盒子和外观是有索尼内味儿的。 盒子里除了手柄本体和连接线之外没有别的东西，因为卖点是可替换，托尼还花了 300 块钱买了可以替换的配件。 和广告里介绍的一样，模块化的部分能以磁吸的方式替换，支持热插拔，在游戏过程中可以随时调换 ( 似乎没什么游戏用得到 ) 。 ‍ 同样，握把也是这样的设计，磁吸的拆装不用费什么力。 托尼购买配件中的磨砂握把在触感和摩擦力上都恰到好处，相当可靠。 唯一要吐槽的是背后的扳机肩键，需要用螺丝拧下来，不知道为什么偏偏这部分没有用磁吸的设计。 eSwap Pro 的模块交换逻辑是这样的，由于限于十字键和遥杆的交换，除了两个遥杆和一个十字键的组合之外，别的组合在游戏中都会产生缺键的情况。 也就是说，它只默许两个摇杆和一个十字键的排列组合。 比如在 2019 年年度最佳游戏《 只狼 》中，两个遥杆分别控制的是方向和视角，十字键用来嗑各种药。 但要是换成三个摇杆，或是两个摇杆一个十字，就很好玩了。 装了三个遥杆的话就不能喝药。▼
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72dd8e649f61a2565c5043b29ac09b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35005f1f99581c45c45a5aca53ba7238/" rel="bookmark">
			three.js 给模型加标注（文字注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如下，需要可以联系qq:1582360909
核心代码：
let canvas = document.getElementById('canvas')
let ctx = canvas.getContext('2d')
canvas.width = 300
canvas.height = 300
//制作矩形
ctx.fillStyle = "rgba(255,165,0,0.8)";
ctx.fillRect(0, 0, 300, 300)
//设置文字
ctx.fillStyle = "#fff";
ctx.font = 'normal 18pt "楷体"'
ctx.fillText('标注信息', 100, 20)
let textWord = '测试信息'
//文字换行
let len = parseInt(textWord.length / 10)
for (let i = 0; i &lt; (len + 1); i++) {
let space = 10
if (i === len) {
space = textWord.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35005f1f99581c45c45a5aca53ba7238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a524fa1d0870cb5dd41aed99e1a52ecb/" rel="bookmark">
			leetcade第六天之字母异位词分组49
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 哈希表 public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { if (strs.length==0) return new ArrayList&lt;&gt;(); //用来存储字母相同对应的不同字符串 Map&lt;String,List&gt; map=new HashMap&lt;&gt;(); for (String s:strs){ //先把字符串传递给字符数组 char[] c=s.toCharArray(); //对字符数组排序 Arrays.sort(c); //将排完序的字符数组转换为字符串 String key=String.valueOf(c); //检查map是否中存在key， kay？存进去：新建一个键值对 if (!map.containsKey(key)) map.put(key,new ArrayList()); //通过key去往ArrayList中存字符串 map.get(key).add(s); } return new ArrayList(map.values()); } 学以致用 Map&lt;String,List&gt; map=new HashMap&lt;&gt;(); String，List集合if (strs.length==0) return new ArrayList();map.put(key,new ArrayList()); 新建一个String，Listmap.get(key).add(s); 通过String去存如到List 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321915fbc7915ab7c8aa3de19be1ebcd/" rel="bookmark">
			python字符串的大小写转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 字符串的大小写转换操作：
upper():把字符串中所有字符都转换成大写字母，转换的结果是新的字符串对象（即id不同）lower():把字符串中所有字符都转换成小写字母，转换的结果是新的字符串对象（即id不同）swapcase():把字符串中所有小写字母都转换成大写字母，把字符串中所有大写字母都转换成小写字母，转换的结果是新的字符串对象（即id不同）capitalize():把第一个字符转换为大写，把其余字符转换为小写，转换的结果是新的字符串对象（即id不同）title():把每个单词的第一个字符都转换为大写，把每个单词的剩余字符都转换为小写，转换的结果是新的字符串对象（即id不同） """ 字符串的大小写转换操作： 1.upper():把字符串中所有字符都转换成大写字母，转换的结果是新的字符串对象（即id不同） 2.lower():把字符串中所有字符都转换成小写字母，转换的结果是新的字符串对象（即id不同） 3.swapcase():把字符串中所有小写字母都转换成大写字母，把字符串中所有大写字母都转换成小写字母，转换的结果是新的字符串对象（即id不同） 4.capitalize():把第一个字符转换为大写，把其余字符转换为小写，转换的结果是新的字符串对象（即id不同） 5.title():把每个单词的第一个字符都转换为大写，把每个单词的剩余字符都转换为小写，转换的结果是新的字符串对象（即id不同） """ s = "heLlo,pythoN" print("原字符串为：", s, "\t", "原字符串的id为：", id(s)) s_upper = s.upper() print("upper()后字符串为：", s_upper, "\t", "upper()后字符串的id为：", id(s_upper)) s_lower = s.lower() print("lower()后字符串为：", s_lower, "\t", "lower()后字符串的id为：", id(s_lower)) s_swapcase = s.swapcase() print("swapcase()后字符串为：", s_swapcase, "\t", "swapcase()后字符串的id为：", id(s_swapcase)) s_capitalize = s.capitalize() print("capitalize()后字符串为：", s_capitalize, "\t", "capitalize()后字符串的id为：", id(s_capitalize)) s_title = s.title() print("title()后字符串为：", s_title, "\t", "title()后字符串的id为：", id(s_title)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/474923aa0f1be3a2e8e14d917cb40a09/" rel="bookmark">
			【深度学习】模型部署的错误整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Pytorch部署错误
jetson nano部署错误
Pytorch以及其他框架部署错误 1_错误1：torch.nn.modules.module.ModuleAttributeError: 'MainNet' object has no attribute 'copy'
解决方法：重新打包pt文件，进行加载
1_错误2：TypeError: argument for rectangle() given by name ('thickness') and position (4)
解决方法：先把图片的数据类型转为uint8形式，
img=np.ascontiguousarray(img) 然后调用cv2.rectangle()函数。
1_其他1：在编写YOLOV5后处理代码时，最好使用numpy中的flatten()函数将图片转换为流
import numpy as np data = np.random.rand(3, 640, 640) print(data.flatten().shape) # (1228800,) 注：直接使用 np.flatten() Pycharm会找不到
jetson nano部署错误 2_错误1：onnxruntime.capi.onnxruntime_pybind11_state.InvalidGraph: [ONNXRuntimeError] : 10 : INVALID_GRAPH : Load model from super_resolution.onnx failed:This is an invalid model. Type Error: Type 'tensor(float)' of input parameter (4135) of operator (ConstantOfShape) in node (ConstantOfShape_2526) is invalid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/474923aa0f1be3a2e8e14d917cb40a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10aeeefeb63b82d24463864713be58c8/" rel="bookmark">
			Markdown换行语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown语法直接打一个回车是不会显示换行的。
两种换行方法：
行尾打两个或两个以上的空格之后回车打两个回车
他们的区别是第一种打出来的效果行间距近，而第二种更像是段落之间的分隔，行间距大。 行末两个空格+回车
两个回车
作者：苏啦啦哇咔咔
链接：https://www.jianshu.com/p/923bbf58a926
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0774b611ee91892c2e9a48ceb561b4/" rel="bookmark">
			vue渲染layui table使用input复选框不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;form action="" class="layui-form layer-form" autocomplete="off" style="margin:10px 40px 0 0"&gt; &lt;div class="layui-form-item layui-row"&gt; &lt;label class="layui-form-label"&gt;&lt;/label&gt; &lt;div class="layui-input-inline" style="margin-top: 19px;" @click="addconsumable(model_id)"&gt; &lt;a class="layui-btn layui-btn-warm" href="javascript:void(0);"&gt; &lt;i class="layui-icon"&gt;&amp;#xe608;&lt;/i&gt; 选择耗材 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="layui-table examInfo"&gt; &lt;tr&gt; &lt;td&gt;选择&lt;/td&gt; &lt;td&gt;耗材默认数量&lt;/td&gt; &lt;td&gt;耗材默认数量&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for="(item, index) in device_consumable"&gt; &lt;td&gt; &lt;input type="checkbox" name="like1[write]" lay-skin="primary" title="" checked=""&gt; &lt;/td&gt; &lt;td&gt; &lt;div class="layui-input-inline"&gt; &lt;p type="text" class="content_filed" placeholder="耗材名称" &gt;{{item.consumable_name}}&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;td&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="number" class="layui-input" lay-verify="" name="alarm_quantity" v-model="item.alarm_quantity" placeholder="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d0774b611ee91892c2e9a48ceb561b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7d3b6242b2aaf4299d561221b8b2e9/" rel="bookmark">
			GitHub 上适合新手的开源项目（Python 篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-卤蛋
随着 Python 语言的流行，越来越多的人加入到了 Python 的大家庭中。为什么这么多人学 Python ？我要喊出那句话了：“人生苦短，我用 Python！”，正是因为语法简单、容易学习，所以 Python 深受大家喜爱。（Python！Python！Python！）
Python 初学者在迈过安装编程环境和基本语法的门槛 ，准备大展身手的时候，可能突然就会进入迷茫期：不知道做些什么、再学些什么。然后对编程的兴趣就会慢慢消退，找不到坚持下去的理由，从而慢慢淡忘之前学会的编程知识。所以找到自己感兴趣、能够跟着动手和学习的 Python 项目是特别重要的，这样才能把学会的 Python 知识用起来，不断地提高。最终从新手晋升为高手！
兴趣是最好的老师，HelloGitHub 就是帮你找到编程的乐趣。
这里是 HelloGitHub 的《GitHub 上适合新手的开源项目》系列，共计 5 篇文章：
C++ 篇Python 篇Go 篇Java 篇JavaScript 篇 本期是 Python 篇，下面我将从 HG 推荐过的 197 个 Python 开源项目中，精心筛选出 7 个最适合 Python 新手学习和把玩的开源项目。这些项目包括：
从零开始学也不用愁的 Python 教程让你惊呼 Python 还可以这样用的秘籍（大开眼界）轻轻松松就能跑起来（满满成就感）好玩有趣又能学到东西的项目（编程的乐趣） 我会尽力做到涵盖每一个刚入门阶段在找开源项目的小伙伴。声明：
不纠结项目是 Python2 还是 3我最怕推荐的项目过多让读者“挑花眼”导致都没学好，所以就选了 7 个项目欢迎吐槽和反馈，不定期更新。所以本文暂且称之为 Python 篇 1.0 😂 注意： 为了方便大家学习，我把这些项目整理好放到网盘上供大家下载学习（地址在最下面），另外大家也可以直接 clone 项目。
但不管以哪种方式下载，我都希望大家可以去给这些 GitHub 上的开源项目点一个 star ✨，让作者感受到大家的支持和喜爱。我在这里提前替作者感谢大家了，爱你们呦～❤️
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d7d3b6242b2aaf4299d561221b8b2e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4653a1a8a394b5298b464b1ad85478c/" rel="bookmark">
			正点原子ALPHA_设备树点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正点原子ALPHA_设备树点亮LED 设备树点亮LED灯修改设备树加载设备驱动驱动编写总结 设备树点亮LED灯 基于上一章新字符设备驱动进行设备树的点灯操作。
修改设备树 修改内核的dts文件,找到arch/arm/boot/dts/imx6ull-alientek-emmc.dts的文件，在根节点的最后面添加一个alphaled节点，里面属性内容：
alphaled{ #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = "atkalpha-led"; status = "okay"; reg = &lt;0x020c406c 0x04 0x020e0068 0x04 0x020e02f4 0x04 0x0209c000 0x04 0x0209c004 0x04	&gt;; }; 保存，编译linux内核下的make dtbsdts文件，make dtbs
将编译后的dtb文件拷贝到tftp目录下cp arch/arm/boot/dts/imx6ull-alientek-emmc.dtb /home/zzz/linux/tftpboot/ -f
这里提一下，选择linux内核下的dts文件，之前选择的是之前是、alientek_linux下的dts文件，系统启动以后led一直在闪烁，估计是这个设备树有用到led灯，一直闪烁是验证不了这个实验的，要用linux-imx-rel_imx_4.1.15_2.1.0_ga_alientek这里面的dts文件编译的dtb.
加载设备驱动 启动linux 通过tftp加载刚编译dtb文件
查看设备是否加载cd /proc/device-tree/
/sys/firmware/devicetree/base # ls #address-cells leds #size-cells memory aliases model alphaled name backlight pxp_v4l2 chosen regulators clocks reserved-memory compatible sii902x-reset cpus soc gpio_keys@0 sound interrupt-controller@00a01000 spi4 打开alphaled目录，里面就是这个节点所有的属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4653a1a8a394b5298b464b1ad85478c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e716aead27bb8b26658c5dd2f7b01d9f/" rel="bookmark">
			如何设计一个牛逼的本地缓存！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝色“架构文摘”关注我哟
加个“星标”，每天上午 09:25，干货推送！
来源：ksfzhaohui | http://dwz.win/Ws4
最近在看Mybatis的源码，刚好看到缓存这一块，Mybatis提供了一级缓存和二级缓存；一级缓存相对来说比较简单，功能比较齐全的是二级缓存，基本上满足了一个缓存该有的功能；当然如果拿来和专门的缓存框架如ehcache来对比可能稍有差距；本文我们将来整理一下实现一个本地缓存都应该需要考虑哪些东西。
考虑点 考虑点主要在数据用何种方式存储，能存储多少数据，多余的数据如何处理等几个点，下面我们来详细的介绍每个考虑点，以及该如何去实现；
1.数据结构 首要考虑的就是数据该如何存储，用什么数据结构存储，最简单的就直接用Map来存储数据；或者复杂的如redis一样提供了多种数据类型哈希，列表，集合，有序集合等，底层使用了双端链表，压缩列表，集合，跳跃表等数据结构；
2.对象上限 因为是本地缓存，内存有上限，所以一般都会指定缓存对象的数量比如1024，当达到某个上限后需要有某种策略去删除多余的数据；
3.清除策略 上面说到当达到对象上限之后需要有清除策略，常见的比如有LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)、SOFT(软引用)、WEAK(弱引用)等策略；
4.过期时间 除了使用清除策略，一般本地缓存也会有一个过期时间设置，比如redis可以给每个key设置一个过期时间，这样当达到过期时间之后直接删除，采用清除策略+过期时间双重保证；
5.线程安全 像redis是直接使用单线程处理，所以就不存在线程安全问题；而我们现在提供的本地缓存往往是可以多个线程同时访问的，所以线程安全是不容忽视的问题；并且线程安全问题是不应该抛给使用者去保证；
6.简明的接口 提供一个傻瓜式的对外接口是很有必要的，对使用者来说使用此缓存不是一种负担而是一种享受；提供常用的get，put，remove，clear，getSize方法即可；
7.是否持久化 这个其实不是必须的，是否需要将缓存数据持久化看需求；本地缓存如ehcache是支持持久化的，而guava是没有持久化功能的；分布式缓存如redis是有持久化功能的，memcached是没有持久化功能的；
8.阻塞机制 在看Mybatis源码的时候，二级缓存提供了一个blocking标识，表示当在缓存中找不到元素时，它设置对缓存键的锁定；这样其他线程将等待此元素被填充，而不是命中数据库；其实我们使用缓存的目的就是因为被缓存的数据生成比较费时，比如调用对外的接口，查询数据库，计算量很大的结果等等；这时候如果多个线程同时调用get方法获取的结果都为null，每个线程都去执行一遍费时的计算，其实也是对资源的浪费；最好的办法是只有一个线程去执行，其他线程等待，计算一次就够了；但是此功能基本上都交给使用者来处理，很少有本地缓存有这种功能；
如何实现 以上大致介绍了实现一个本地缓存我们都有哪些需要考虑的地方，当然可能还有其他没有考虑到的点；下面继续看看关于每个点都应该如何去实现，重点介绍一下思路；
1.数据结构 本地缓存最常见的是直接使用Map来存储，比如guava使用ConcurrentHashMap，ehcache也是用了ConcurrentHashMap，Mybatis二级缓存使用HashMap来存储：
Map&lt;Object, Object&gt; cache = new ConcurrentHashMap&lt;Object, Object&gt;()Mybatis使用HashMap本身是非线程安全的，所以可以看到起内部使用了一个SynchronizedCache用来包装，保证线程的安全性； 当然除了使用Map来存储，可能还使用其他数据结构来存储，比如redis使用了双端链表，压缩列表，整数集合，跳跃表和字典；当然这主要是因为redis对外提供的接口很丰富除了哈希还有列表，集合，有序集合等功能；
2.对象上限 本地缓存常见的一个属性，一般缓存都会有一个默认值比如1024，在用户没有指定的情况下默认指定；当缓存的数据达到指定最大值时，需要有相关策略从缓存中清除多余的数据这就涉及到下面要介绍的清除策略；
3.清除策略 配合对象上限之后使用，场景的清除策略如：LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)、SOFT(软引用)、WEAK(弱引用)； LRU ：Least Recently
Used的缩写最近最少使用，移除最长时间不被使用的对象；常见的使用LinkedHashMap来实现，也是很多本地缓存默认使用的策略； FIFO ：先进先出，按对象进入缓存的顺序来移除它们；常见使用队列Queue来实现； LFU ：Least Frequently
Used的缩写大概也是最近最少使用的意思，和LRU有点像；区别点在LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的；可以通过HashMap并且记录访问次数来实现； SOFT ：软引用基于垃圾回收器状态和软引用规则移除对象；常见使用SoftReference来实现； WEAK ：弱引用更积极地基于垃圾收集器状态和弱引用规则移除对象；常见使用WeakReference来实现；
4.过期时间 设置过期时间，让缓存数据在指定时间过后自动删除；常见的过期数据删除策略有两种方式：被动删除和主动删除； 被动删除 ：每次进行get/put操作的时候都会检查一下当前key是否已经过期，如果过期则删除，类似如下代码：
if (System.currentTimeMillis() - lastClear &gt; clearInterval) { clear(); } 主动删除 ：专门有一个job在后台定期去检查数据是否过期，如果过期则删除，这其实可以有效的处理冷数据；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e716aead27bb8b26658c5dd2f7b01d9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c8ce93a4bced83b34a81b5dd90b1b44/" rel="bookmark">
			平板电脑怎么投屏到电视上_ApowerMirror | 让苹果手机投屏到电视、电脑上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早前，如果要做一个完美的 PPT 讲演，你可能需要自备笔记本电脑，以保证格式和特效的完美统一，再附带一支指点江山的荧光笔。而现在，我们只需要一支能够放在口袋里的智能手机；
早前为了玩儿一个重力感应游戏，你可能需要大把大把的配件；而现在，你只需要在任何电脑上安装一款小软件，加上一款智能手机。
如果同时在你的电脑、手机、平板上都安装上一款叫做 ApowerMirror 的软件，你可以轻松地将手机投影到电脑，或者将电脑投影至手机，还有将手机投影到手机。当然，平板也不在话下。
在 PC 上，双击打开已安装好的 ApowerMirror；在手机上也打开这款软件，保证手机和电脑在同一个局域网络。
如果你使用的是安卓手机，点击中间的连接按钮，即可搜索到电脑名称，点击连接，会弹出这样的选项。如果你选择 [ 手机屏幕投射 ]，手机屏幕即可投射到电脑桌面；而如果你选择 [ 电脑桌面投射 ] ，电脑桌面即可投射到手机上，此时，你可以把手机当作遥控器，反向操控电脑。
如果你使用的是苹果手机，操作步骤更加简单，在设置中找到 [ 屏幕镜像 ] 功能，找到电脑名称，即可开始投屏。
当手机投影到电脑中时，你可以做什么呢？
对当前屏幕截图、录屏；在当前屏幕上涂画，还可以更改涂画颜色；在设置中，你可以设置投屏显示分辨率大小、截屏录屏的格式以及输出质量。在你的头像下方，点击全屏按钮即可全屏显示，而刚才的控件都会在右边自动隐藏和显示，供你随时调取。
进行文档演示或者其他讲演时，你只需要拿着手机，借用移动版的 PPT 软件、在线工具或思维导图，即可轻松演示；手机中的游戏也可以投屏到电脑中，让你玩儿得更加畅快。
对于安卓手机来说，因为系统的开源，你甚至可以使用 ApowerMirror 让电脑反向控制手机。不过这需要使用 USB 线激活，并打开手机的 USB 调试功能。比如，这款荣耀当中，我们为它开启开发者模式，进入 [ 开发人员选项 ] ，就可以打开 USB 调试。
然后，我们使用 USB 线连接电脑和手机，在电脑中选择 USB 连接，按照步骤操作即可。这样一来，你就可以在电脑上操作手机发送消息和接收信息通知。所有这些操作步骤，你都可以在 ApowerMirror 的官网找到详细步骤。
总的来说，ApowerMirror 已不仅仅是一款简单的投屏软件，它可以是轻便的演示办公和教学工具、局域网中的电脑遥控器，更可以是一款电脑录屏和媒体分享工具。
最后，任何人都可以免费使用这款软件，个人体验版只在屏幕下方有一块轻水印；付费即可去除水印，年费价格在 69 元，而 179 元可以终身使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a241b8d1c552285d1271c067f9ebe92/" rel="bookmark">
			springboot&#43;thymeleaf跳转页面An error happened during template parsing (template: “class path resource错误解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用springboot+thymeleaf做登陆页面时，出现
An error happened during template parsing (template: "class path resource [templates//site/logiorg.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates//site/login.html]") 错误，网上查阅资料知道是视图层有错误，仔细排查
后来发现是这里
改正为
问题解决！
一定要细心啊！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457179568bfc94faf1f3b9374475ddc9/" rel="bookmark">
			VUEX的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUEX的作用 vuex是什么？ vuex是一个专门为vue.js应用程序开发的状态管理模式。通俗点说就是我们项目中需要共享的一些数据的管理容器，这里的状态就是数据。
vuex的五大核心 State：状态 vuex存放数据的地方，跟data类似
Mutations：方法库 vuex的方法库，是同步操作，用来操作数据的、是唯一一个可以操作state数据的$store.commit(）调用
Action：动作 action是异步操作，可以调用mutations里的方法，$store.dispath(’’)调用
Module：模块 store 的子模块，为了开发大型项目，方便状态管理而使用的
Getters：获取器 vuex通过现有数据计算出新的数据，和计算属性computed类似，$sotre.getters调用
vuex的数据传递流程 主要流程： 组件通过 dispatch 到 actions，actions 是异步操作，再 actions中通过 commit 到 mutations，mutations 再通过逻辑操作改变 state，从而同步到组件，更新其数据状态
流程图 vuex的优点 1.解决了非父子组件的消息传递（将数据存放在state中）
2.减少了AJAX请求次数，有些情景可以直接从内存中的state获取
vuex的缺点 1.刷新浏览器，vuex中的state会重新变为初始状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b98f8ace639128b1a3a115f4d03cfb/" rel="bookmark">
			android系统logcat日志重定向到kernel，可以通过串口来输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改system/core/rootdir/init.rc
chmod 0660 /sys/power/wake_lock
chmod 0660 /sys/power/wake_unlock
+ chmod 0660 /proc/kmsg
# Start logd before any other services run to ensure we capture all of their logs.
start logd
+ start logota
# Start lmkd before any other services run so that it can register them
chown root system /sys/module/lowmemorykiller/parameters/adj
chmod 0664 /sys/module/lowmemorykiller/parameters/adj
@@ -429,6 +431,7 @@ on load_persist_props_action
load_persist_props
start logd
start logd-reinit
+ start logota
# Indicate to fw loaders that the relevant mounts are up.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b98f8ace639128b1a3a115f4d03cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc16f321d318ebf414dfe9d8a8926d51/" rel="bookmark">
			对LSTM中每个batch都初始化隐含层的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道有没有人和我有一样疑惑
在LSTM相关的代码中，为什么每个batch都会将隐藏层重新初始化，
这样不会把以前训练出来的参数丢掉吗？？
比如
代码来自GitHub 看了一些解释是h与c是状态，不是参数，每个batch中都需要初始化为0，LSTM 中的参数是W,b。
网络中训练的是参数，不是状态。
说真的。。。当时我没怎么看懂。。。
咨询了实验室的师兄后，我有了自己的理解
产生误解的主要原因是我对RNN和LSTM的结构理解不深入，我们通常看到RNN结构图基本都是这样的
说实话，这个图对我这种初学者并不友好
RNN实际上应该是这样的
举个例子，解释一下RNN是如何训练的
比如这里有一句话，而这句话，就是一个batch
sentence=“我爱我的国”
进行句字的分词后是：
我 爱 我的 国
可以表示为4个n维的词向量，这里n我用8表示
这里有四个时间步（time_steps），每个时间步分别喂入我 爱 我的 国 四个词向量
参考RNN和LSTM数据是如何喂入的
下一句话是另一个batch，比如 “我 要 漂亮 小姐姐”
在这两个batch之间，并没有啥逻辑关系，如果我们不重新初始化
在测试的时候，batch之间的顺序会去影响 测试的结果。。。
换句话说，如果不重新初始化，两个没有什么逻辑的batch之间，会被我们人为的加上逻辑，上一句的“国”，和下一句的“我”就被联系起来了
而对于下一句的batch而言应该是一个新的开始，所以当然要初始化h和c了
也许有小伙伴要问了，这样初始化，在做文本识别的时候，句与句之间的联系，不也被初始化掉了吗？
师兄给的解释是：“一般不会这么做，一般不考虑句与句之间的联系，如果必须要考虑，那么这一段落都是一个batch中的sampler，这两句话不会分到两个batch中”
在这里偷偷挂上我的大佬级师兄Kenn7，如果他的解释不对。。。请偷偷告诉我，让我去打脸，哈哈哈
今天就分享到这里，祝大家变得更强
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09873d613eb7e2d3e67e3071b0958ba/" rel="bookmark">
			设数组a的定义如下： int a[20] = {2,4,6,8,10,12,14,16}； 已存入数组中的数据值已经按由小到大的顺序存放，现从键盘输入一个数据，把它插入到数组中，要求插入新数据以后，数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
int a[20] = {2,4,6,8,10,12,14,16}; 已存入数组中的数据值已经按由小到大的顺序存放，现从键盘输入一个数据，把它插入到数组中，要求插入新数据以后，数组数据仍然保持有序。请编写一个程序实现上述功能。
提示：
1）定义整型数组并初始化。
2）从键盘输入一个数据。
3）将该数据插入到数组中，由于要保证插入的数组仍然有序，所以需要查找插入的位置。
4）输出插入数据以后的数组。
代码内容：
//觉得不错个赞！谢谢额！ /*从键盘输入一个长度为N（比如10）的整型数组， 设数组a的定义如下： int a[20] = {2,4,6,8,10,12,14,16}; 已存入数组中的数据值已经按由小到大的顺序存放， 现从键盘输入一个数据，把它插入到数组中，要 求插入新数据以后，数组数据仍然保持有序。 请编写一个程序实现上述功能。 提示： 1）定义整型数组并初始化。 2）从键盘输入一个数据。 3）将该数据插入到数组中，由于要保证插入的数组仍然有序，所以需要查找插入的位置。 4）输出插入数据以后的数组。 */ #include&lt;stdio.h&gt; #define N 10 int main() { int i=0,num,temp; int a[N] = {2,4,6,8,10,12,14,16}; int j=0; int k=0; scanf("%d",&amp;num); for(i=0;i&lt;N;i++) { if(a[i]==NULL) { break; } j++; } for(i=0;i&lt;j;i++) { if(num&lt;a[i]) { k=i; break; } } for(i=j+1;i&gt;=k;i--) { a[i+1]=a[i]; } a[i+1]=num; for(i=0;i&lt;j+1;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09873d613eb7e2d3e67e3071b0958ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71701611a6782dfd9ef165a9c0855001/" rel="bookmark">
			SlickGrid是一个完全开源的，JavaScript，客户端网格控件，基于jQuery和jQueryUI并与Bootstrap兼容。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SlickGrid是一个完全开源的，JavaScript，客户端网格控件，基于jQuery和jQueryUI并与Bootstrap兼容。
网格旨在将外部组件用作数据源，这意味着SlickGrid应该与各种现代的以数据为中心的框架兼容。
关键链接 GitHub主存储库 （github.com/6pac/SlickGrid）
*不建议*使用原始的MLeibman SlickGrid存储库，因为自2014年以来未对其进行过维护 支持jQuery 1.x，2.x和3.x 正式发布
Wiki（文档和API参考）
综合实例
当前问题（请仅提供错误修复和功能请求！）
NPM - npm install slickgrid
一般支持-在StackOverflow上询问，标记为“ slickgrid”
Slickgrid背景，替代方法和哲学 Slickgrid是一个开源项目。尽管该项目活跃且稳定，但并未完善或没有完整的文档记录。支持在很大程度上是自助的，但是可以由志愿者贡献者在StackOverflow或GitHub上提供帮助。
如果您希望使用具有类似功能集的更精美的产品，建议使用Ag-Grid。Ag-Grid具有强大的免费功能集，额外的付费功能和出色的文档。
Slickgrid具有出色的架构，模块化且易于定制。最好将其视为工具包-基础坚固，但是您可能需要进行一些细微调整才能使其完全按照您的要求进行。这实际上是它的优势。MLeibman说得最好：
我见过的SlickGrid和其他网格实现之间的主要区别在于，它们过于注重能够理解和处理数据（搜索，排序，解析，Ajax加载等），而不能成为更好的“网格” ”（如果是可编辑的网格，则为电子表格）。如果您要做的只是“整理” HTML TABLE或将前端打入一个简单列表，那太好了，但是对于其他任何事情都太不灵活了。
数据很复杂。它具有业务规则。它具有非本征特性。编辑元素的一个属性可能导致级联更改，从而修改其他属性甚至其他元素。它具有依赖性。我的意思是，最好使用网格控件将数据处理留给开发人员。试图将所有这些都适合网格实现和API只会限制其适用性并增加大量的膨胀。
有许多可用的显示网格。较少的网格支持良好的编辑功能。很少有人能做到优雅而可扩展。Slickgrid的同行可以被认为是一方面。
Slickgrid将支持构建非常复杂的编辑功能，并在编辑和显示方面提供极大的灵活性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024dc8f8670ad63f8a7011ee9ab6865b/" rel="bookmark">
			.NET Reactor的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 作为开发人员，自己辛苦在.net框架下写的dll或者exe文件，不想被别人通过反编译工具轻松查看。那么我们就需要对自己写的代码进行保护。在笔者经过大量的搜索与尝试后，发现一款不错的程序保护工具.NET Reactor。如其名字所示，这是一款针对.net程序进行保护的专门工具，因为专业，所以强大。
下载地址：https://www.jb51.net/softs/547521.html
接下来我们看下它的基本功能：
二、.NET Reactor功能介绍 主要功能如下：
如果涉及到软件本身的保护，我们可以采用给软件设置使用次数或者期限，对于dll保护我们可以对其进行混淆和字符串加密处理。
三、使用方法 首先，我们需要对Quick Settings 里面的东西有个基本认识
源码混淆处理字符串加密NET Reactor强大的许可授权管理功能NET Reactor可以为您的软件创建试用版设置过期日期为软件限制一个安装后的可用天数使用次数限制（如将软件作为一种服务）NecroBit：把程序集转为非托管代码；Native Exe File：生成本机 Exe 文件；Anti ILDASM：反编译；Obfuscation：混淆；Create Mapping File：创建地图文件；Anti Tampering：防篡改；String Encryption：加密字符；Compress &amp; Encrypt Resources：压缩并加密资源；Control FlowObfuscation：混淆控制流。第一步：通过Open找到自己需要加密的dll/exe，然后打开第二步：对加密进行设置 对于dll或者exe加密，笔者这里推荐勾选
Anti ILDASMObfuscationString Encryption
这三个选项。因为这三个选项基本上能够较好地对代码进行较好的保护了，多选了可能会导致dll/exe不能正常加载或运行。测试下面的配置加壳效果更好 第三步：点击左下角的Protect就可以了。等待一会儿，DSOffice-Successfully Protected！ 接下来我们对比一下结果。这里我们用ILSpy反编译工具查看保护前，和保护后的情况。
保护前 保护后
通过对比我们可以看到
类名，方法名，属性名大部分都不能正常显示代码已经不能再被查看 是不是很神奇，大家动手试试吧
四、注意事项 在进行加密设置时，并不是勾选的越多越好，因为勾选多了容易造成dll\exe不能正常加载或运行；如果在open文件后,出现Can’t load assembly这种情况 那么找到LibG.Interface.dll这个文件，然后添加到这里的Addtional Files，即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11d2574452c4e7be3d142f360f531c8e/" rel="bookmark">
			Plugin “GsonFormat“ is incompatible (supported only in IntelliJ IDEA).报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天Android studio升级了最新的4.1正式版，打开老是会报错：
Plugin "GsonFormat" is incompatible (supported only in IntelliJ IDEA). 意思是创建model 的这个插件版本开始仅适用于IntelliJ IDEA，那我本地之前低版本的或者说下载好的GsonFormat移除或者删掉即可。
在系统盘 文件目录如下
移除这个插件，然后重启AS即可。
后面有人问我删除之后还是不能用GsonFormat，毕竟能方便很多，这里建议用GsonFormatPlus，具体使用有问题欢迎留言交流。
书到用时方恨少，纸上得来终觉浅！希望能解决您的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e815519efc7a859ac514bac6653a9025/" rel="bookmark">
			若依微服务版怎样新增业务子模块并使用代码生成实现对表的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 若依微服务版手把手教你本地搭建环境并运行前后端项目：
https://blog.csdn.net/BADAO_LIUMANG_QIZHI/article/details/109363303
在前面已经将若依微服务版的项目在本地搭建起来之后，怎样开发具体的业务。
搭建好之后的项目结构里，ruoyi-modules是存放业务模块的位置。
ruoyi-fzys就是新增的业务。
注： 博客：
https://blog.csdn.net/badao_liumang_qizhi
关注公众号
霸道的程序猿
获取编程相关电子书、教程推送与免费下载。
实现 新增业务模块并配置 按照项目的结构设计，业务模块的位置是在ruoyi-modules下，所以在此模块上右键-new-Module
点击确定后
然后点击next
为了和之前的模块统一风格的命名方式，所以这里新建的module的坐标是ruoyi-fzyscontrol，然后点击next
包括module的名字的命名风格，统一以ruoyi-modules-业务模块名的格式。
新增完模块之后，此业务模块就是上面ruoyi-modules的子模块，可以打开ruoyi-modules的pom.xml
可以看到已经自动将新增的业务模块添加到此业务模块下了
然后打开ruoyi-modules-system的系统模块的pom.xml,将其dependencies下和build下的代码复制到上面新建业务模块的pom.xml文件中
当前是如下代码，具体根据自己版本的pom文件去复制
&lt;dependencies&gt; &lt;!-- SpringCloud Ailibaba Nacos --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringCloud Ailibaba Nacos Config --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringCloud Ailibaba Sentinel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot Actuator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;${swagger.fox.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mysql Connector --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e815519efc7a859ac514bac6653a9025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dbc75a9c44064c93175f39324f8754d/" rel="bookmark">
			antimalware service executable占用内存过高_svchost占用内存过高是怎么回事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机的svchost占用过多内存，这会影响计算机的正常使用，将导致计算机的CPU温度升高，并且冷却风扇会持续转动； svchost.exe是属于微软Windows操作系统的一个系统程序，在(DLL)中运行的服务的通用主机进程名称。前几天有人咨询了小编，如何解决这个问题？让我们来看看！
一：原因：
1.可能是由于系统补丁，病毒，木马引起的，建议使用杀毒软件进行检查和清理，杀毒。
2.可能是驱动程序问题，建议使用Master Lu软件检查驱动程序。
3.使用360软件禁用不需要的启动项并将其关闭。
二：常见解决方案。
(1)在此计算机上单击鼠标右键，然后选择“管理”以输入。
(2)进入管理界面，双击右侧的服务和程序。然后双击该服务以输入。
(3)在服务列表中找到Windows Update服务，双击Windows Update服务以输入，将启动类型设置为“手动”，然后单击“应用”。
(4)接下来，在服务中找到Superfetch服务。
(5)双击Superfetch服务，然后将启动类型更改为“手动”，然后单击“确认”。重新启动计算机和svchost内存使用率将下降。
上面是svchost在计算机上占用过多内存的解决方案，希望对大家有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e621d4887283a0f5c3cfae4a32b4b961/" rel="bookmark">
			SVN（三）利用 IntelliJ IDEA 进行代码对比的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sometimes，我们会有这样的需求，即：想对比出两个不同版本代码的区别。如何实现？
第 1 种：如果我们是从 SVN 检出的项目，并且想比较本地代码与从 SVN 检出时的代码相比都有那些区别，可以按如下步骤操作， 如上图所示，在代码编辑区，右键唤出功能菜单，然后选择Subversion，进而会展示出更多的可选项，例如：
Compare with the Same Repository Version，与 SVN 仓库相同版本做对比；Compare with Latest Repository Version，与 SVN 仓库最新版本做对比；Compare with...，点击后选择本分支的不同版本做对比；Compare with Branch，点击后需要先配置具体要对比的分支，然后与指定分支做比对；Show History，同Compare with...类似，只不过是先展示出此分支的版本历史。 通过上述方法，已经可以满足我们比较线上分支代码的需求啦！
第 2 种：比较本地两份代码的区别，可以按如下步骤操作， 首先，选中目标文件夹（图中选择src文件夹），右键唤出功能菜单，然后点击Compare With：
如上图所示，选中本地另一份想要与之对比的代码的相同目录，然后点击Open或者打开、确定按钮：
如上图所示，清晰明了的展示了两份代码的区别。
———— ☆☆☆ —— 返回 -&gt; 史上最简单的 IntelliJ IDEA 教程 &lt;- 目录 —— ☆☆☆ ————
原文转自：利用 IntelliJ IDEA 进行代码对比的方法
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/202/">«</a>
	<span class="pagination__item pagination__item--current">203/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/204/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>