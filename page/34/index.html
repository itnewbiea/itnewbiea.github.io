<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c6d6d8fe9869e5f895d9429603443f/" rel="bookmark">
			制作一个RISC-V的操作系统五-RISC-V汇编语言编程三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 分析code/asm/add中的makefile相关命令 算数运算指令addadd2sub 练习5-1 分析code/asm/add中的makefile makefile
EXEC = test SRC = ${EXEC}.s GDBINIT = ../gdbinit include ../rule.mk 很明显还要去执行rule.mk
rule.mk
include ../../common.mk .DEFAULT_GOAL := all all: @${CC} ${CFLAGS} ${SRC} -Ttext=0x80000000 -o ${EXEC}.elf @${OBJCOPY} -O binary ${EXEC}.elf ${EXEC}.bin .PHONY : run run: all @echo "Press Ctrl-A and then X to exit QEMU" @echo "------------------------------------" @echo "No output, please run 'make debug' to see details" @${QEMU} ${QFLAGS} -kernel ./${EXEC}.elf .PHONY : debug debug: all @echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5c6d6d8fe9869e5f895d9429603443f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1ea1eab585d3fe1bfd8eca3e8f56e8/" rel="bookmark">
			C语言的控制结构（顺序结构、选择结构、循环结构）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言的三种控制结构 一、顺序结构二、选择结构2.1 if语句（只会匹配一个表达式对应内容）2.2 switch语句 三、循环结构for循环while循环do while循环 四、goto语句 前言：程序由三种基本结构组成： 顺序结构、选择结构、和循环结构，任何程序都由这3种基本结构组合而成。 优点：不会存在无规律的转向，可以使程序结构清晰，易于验证正确性且易于纠错。遵循这种方法的程序设计就是结构化程序设计。 此处简单画出三种结构的执行流程图：
注意：C语言没有布尔类型，在C语言中用数字0表示假，非0表示真，文章后面不在进行说明
一、顺序结构 顺序结构：依照线性顺序依次执行，简单说就是从上到下依次执行
例如下面程序会依次输出1、2、3、4、5
#include &lt;stdio.h&gt; int main(void) { printf("1"); printf("2"); printf("3"); printf("4"); printf("5"); return 0; } 输出：
12345 二、选择结构 选择结构：通过某个给定条件进行判断，条件为真或假时分别执行不同的程序内容,选择结构分if语句和switch语句两种（就像人生不是一帆风顺，直线往前走。比如今天出门看到外面下雨了就会带伞，没有下雨就不用带伞一样进行判断）
2.1 if语句（只会匹配一个表达式对应内容） 语法结构（主要分为三种，下面会一 一举例）：
说明：以 ; 结尾是一条语句，
第一种
if(表达式)
执行语句;
#include &lt;stdio.h&gt; int main(void) { int age = 0; printf("请输入你的年龄:&gt;"); scanf("%d", &amp;age); if (age &gt;= 18) //当if括号内表达式为真时（即非0），才会执行紧接if的第一条语句 printf("成年\n"); return 0; } 输入
18 输出
成年 输入
15 输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1ea1eab585d3fe1bfd8eca3e8f56e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e3befc93c7816a9b4464b608802e74/" rel="bookmark">
			零基础小白怎么准备蓝桥杯-蓝桥杯竞赛经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零基础小白怎么准备蓝桥杯-蓝桥杯竞赛经验分享 前言竞赛简介竞赛目的如何备战1.基础学习2.实战训练（非常重要） 资料分享 前言 博主在蓝桥杯中获得过十四届Java B 组的省一国二，本文为大家介绍一下蓝桥杯并分享一下自己的参赛经验。
竞赛简介 ​ 蓝桥杯全称《蓝桥杯全国软件和信息技术专业人才大赛》，是由国信蓝桥和工信部举办的全国性IT学科赛事。全国1200余所高校参赛，累计参赛人数超过40万人。蓝桥杯大赛连续两年被列入中国高等教育学会发布的“全国普通高校学科竞赛排行榜”，是高校教育教学改革和创新人才培养的重要竞赛项目。对大学生综合评测，奖学金评定，保研加分都有一定助益。
​ 蓝桥杯大赛共包括多个竞赛组别，个人赛-软件类，个人赛-电子类，以及视觉艺术大赛。其中个人赛-软件类的比赛科目包括C/C++程序设计、Java软件开发、Python程序设计。我们常说的蓝桥杯主要是针对的软件类的赛项。
​ 除了上面的C++、JAVA、Python语言分组以外，它还分为A，B，C组，分别对应为985/211，本科，专科组，C组可以报B，A，但是A不能报B，C，防止有高手来虐杀！而且即使你不以院校的名义参加，现在也可以以个人的名义参加比赛。
​ 蓝桥杯分为省赛和国赛，省赛排名的前10%获得一等奖，接下来的20%为二等奖，再下来的30%三等奖。你的排名在前60%你就可以获奖，如果你有幸拿了省一等奖，还可以参加国赛，省赛每个组别设置一、二、三等奖，总决赛每个组别设置一、二、三等奖及优秀奖，具体详见大赛章程。
竞赛目的 通过竞赛驱动学习：通过参加竞赛提高自己视野、编程能力、算法水平，很多人报名的时候都是小白的起点一点点摸索，在比赛准备的阶段不断学习，不断进步，这个备赛的过程给自己带来很大成长，这也是参加竞赛最大的意义。
竞赛加分：参加一些含金量较高的比赛，对有些人保研加分，评奖评优加分。
就业机会：提高编程能力，面试机试都轻松很多，而且能够添加到自己的简历中，现在蓝桥杯的名声很大，很多公司面试中也会注意这一点。
如何备战 1.基础学习 首先，先了解算法能干什么，有个概念，例如链表二叉树，递归，哈希，dfs，bfs，贪心，字符串，常见dp，最短路径，最小生成树等简单先过一遍，推荐看视频讲解详细一点，然后dfs，bfs，贪心这三个最主要，模拟是基本、递归、深搜和广搜。
看书/刷题解：《算法竞赛入门经典》《算法导论》《数据结构》以及各种经典例题等，具有针对性！ 蓝桥杯是oi赛制，其中有5道填空题（5 + 5 + 10 + 10 + 15 = 45），6道大题（15 + 20 + 20 + 25 + 25），4个小时。如果想拿省一，填空题十分重要。
赛前准备：
要把常用的函数（lcm,gcd）以及算法模板背下来，因为蓝桥杯不让带纸质材料。在考试前几分钟，看看自己所用的语言的帮助文档能不能打开。API帮助文档很有用(C、C++、JAVA的那些函数)在编程大题，一定要学会拿部分分。 2.实战训练（非常重要） 实践是检验真理的唯一标准，零基础的同学可以从现在就开始打这场算法双周赛，不要害怕自己是小白！
这是官方今年新出的【蓝桥·算法双周赛】，可以作为为“蓝桥杯模拟赛”来进行练习。这个算法赛是一个月举办两场，没有参赛门槛，免费报名。在得到算法训练的同时，比赛的前10名有丰厚的现金奖励，最高是300元，前10名均可获得现金奖励！ 这样下来到明年四月份比赛前，大概可以参加不下10场比赛，这10多场比赛打下来，拿个省一是很轻松的事情。
比赛地址：https://www.lanqiao.cn/oj-contest/?channel_id=48
进入链接后，我们可以看到又分为【小白入门赛】【强者挑战赛】，大家就可以根据自己的情况点击下方按钮进行报名。
我非常建议大家参加这个【蓝桥·算法双周赛】，还有几个非常重要的原因：
1、这个比赛赛后会有个人、省、学校的排名，从这个排行榜里，不仅可以看到自己的真实水平，还可以看看自己离省奖还差多远，而蓝桥杯的获奖率是60%左右。
2、这个比赛还提供赛后直播讲解，直播时间是当晚比赛结束后21:00，这一点对于新手小白的算法能力提升十分有帮助；在排行榜【时间】部分，你点击它，可以看到其他参赛大佬提交的为true的代码，学习的本质就是模仿＋刻意练习，学习大佬代码，是算法学习中，非常重要的一部分。
3、蓝桥·算法双周赛，算是个“小蓝桥杯”了！每2周就可以参加一次，那等到明年4月蓝桥杯省赛，总共能参加12场！？这12场练下来，蓝桥杯还能不上岸？不拿个省一、国一，怎么都说不过去了吧哈哈哈哈
资料分享 算法双周赛
小码哥-恋上数据结构与算法
拉勾教育-数据结构与算法特训营二期
最后，预祝大家能在十五届的大赛中有个好成绩！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd59748c1e2d235536ee8ff3d20e40fc/" rel="bookmark">
			深入认识：JavaScript中的面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入认识：JavaScript中的面向对象 前言对象与构造函数1. 什么是对象和构造函数：2. 创建对象的多种方式： 原型链深度剖析1. 原型与原型链的概念：2. 原型链的继承机制： 多态和封装的实质1. JavaScript中的多态是如何体现的：2. 使用闭包实现封装： 设计模式在JavaScript中的应用1. 单例模式（Singleton Pattern）：2. 工厂模式（Factory Pattern）：3. 观察者模式（Observer Pattern）： ES6+中的面向对象新特性1. Class语法糖的使用和实质：2. 静态方法和实例方法的区别： 异步编程与Promise的面向对象思想1. 面向对象的异步编程方法：2. Promise的原理和使用： 总结 前言 在JavaScript的舞台上，面向对象编程就像是一场幕后的魔法表演。你可能曾被原型链弄得晕头转向，或在类的概念上感到有点抽象。别担心，今天我们将一同进入这个神秘的编程王国，揭开面向对象编程的神秘面纱。就像Alice走进兔子洞，让我们跟随JavaScript的兔子一起深入探索，看看这个数字奇境中的奥秘是什么。
对象与构造函数 1. 什么是对象和构造函数： 在JavaScript中，对象是一种复合值：它是属性的集合，每个属性都由键和值组成。对象可以看作是键值对的集合，其中值可以是基本数据类型，也可以是其他对象。构造函数是用于创建对象的函数，它定义了对象的结构和行为。
对象： JavaScript中的对象是动态的，可以随时添加、修改或删除属性。例如：
let person = { name: 'John', age: 30, gender: 'male' }; 构造函数： 构造函数是一种特殊类型的函数，通过 new 关键字调用，用于创建和初始化对象。例如：
function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; } let person1 = new Person('John', 30, 'male'); 在这个例子中，Person 就是一个构造函数，通过它可以创建多个具有相同属性的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd59748c1e2d235536ee8ff3d20e40fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16461c0cfacec1034ab73f4197e078d/" rel="bookmark">
			springboot引入swagger2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，pom文件里引入swagger-ui依赖 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 2，在config里添加swagger基础配置 public abstract class BaseSwaggerConfig { @Bean public Docket createRestApi() { SwaggerProperties swaggerProperties = swaggerProperties(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo(swaggerProperties)) .directModelSubstitute(Byte.class, Integer.class) .select() .apis(RequestHandlerSelectors.basePackage(swaggerProperties.getApiBasePackage())) .paths(PathSelectors.any()) .build(); if (swaggerProperties.isEnableSecurity()) { docket.securitySchemes(securitySchemes()).securityContexts(securityContexts()); } return docket; } private ApiInfo apiInfo(SwaggerProperties swaggerProperties) { return new ApiInfoBuilder() .title(swaggerProperties.getTitle()) .description(swaggerProperties.getDescription()) .contact(new Contact(swaggerProperties.getContactName(), swaggerProperties.getContactUrl(), swaggerProperties.getContactEmail())) .version(swaggerProperties.getVersion()) .build(); } private List&lt;ApiKey&gt; securitySchemes() { //设置请求头信息 List&lt;ApiKey&gt; result = new ArrayList&lt;&gt;(); ApiKey apiKey = new ApiKey("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16461c0cfacec1034ab73f4197e078d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3312c854211441d6231c086c1e17f2ed/" rel="bookmark">
			ffmpeg 实现多视频轨录制到同一个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在视频录制中，有时会碰到这样一个需求，将不同摄像头的画面写入到一个视频文件，这个叫法很多，有的厂家叫合流模式，有的叫多画面多流模式。无论如何，它们的实质都是在一个视频文件上实现多路不同分辨率视频的保存。
经过调查，支持这种需求封装格式的有MP4、MOV、MKV 等，这里因为MP4 格式应用最广泛。
原理 ffmpeg 有一个map命令，可以将多路视频轨封装在一个视频容器，掰ffmpeg源码发现其实新建一个新的AVStream，修改stream-&gt;index，就可以实现多流录制的目的。
ffmpeg -i input.mp4 -i test.mp4 -map 0:v:0 -map 1:v -map 0:a -map 1:a -c copy -y mix.mp4 #include &lt;iostream&gt; #include &lt;string&gt; extern "C" { #include &lt;libavutil/timestamp.h&gt; #include &lt;libavformat/avformat.h&gt; } typedef struct { char* file_name; AVFormatContext* fmt_ctx; int video_index; int audio_index; int source_index; double last_pts[2]; double last_dts[2]; AVRational video_time_base; AVRational audio_time_base; bool is_end; }InputStream; int create_stream(InputStream *input_stream, AVFormatContext* out_fmt_ctx, int &amp;stream_num) { int i = 0; int ret = 0; if ((ret = avformat_open_input(&amp;input_stream-&gt;fmt_ctx, input_stream-&gt;file_name, 0, 0)) &lt; 0) //打开输出文件 { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3312c854211441d6231c086c1e17f2ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5877df4be3d9f2a8b29696d848bf9fe/" rel="bookmark">
			学会python如何利用业余时间赚外快？分享几个接单途径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Python，如何利用Python技术变现 &amp; 兼职接单也是大家比较感兴趣的；
这里总结了一些用Python赚外快的方式，大家伙可以自己去尝试一下。
Python兼职分为以下三种：
商家提供接口爬取数据（当然不做违法的爬取）
淘宝、拼多多等商业数据进行分析整理（数据分析、爬虫、办公自动化等）
WEB后端（后台编写或维护）
Python需求多的单，几乎都是爬虫类的；
主要是爬取网站、小程序或APP的数据，对数据进行分析与处理，或直接向客户提供爬虫程序，也有开发之类的需求，不过技术要求比较高。
Python赚外快的方式 01 自 媒 体
自媒体也是个风口，比如很多学编程的都开始发展自媒体；
微信公众号，广告接单；
知乎，赞赏获利；
b站，1000播放量3块钱；
不过自媒体需要积累，如果能够忍受前期0收入0阅读阶段，不断坚持输出有价值的内容的话，后期粉丝量和关注量上来，收入还是很客观的。
这个比较适合不怎么急，作为长期收益来运营的副业。
02 爬虫服务
抓取数据，总有人需要各类网站的数据；
比如facebook、猫眼等大型数据类网站。通过一些外包网站，可以很快接到订单。
一般我们向甲方提供爬虫、数据分析、数据清洗这样的服务。（可以去猪八戒等外包平台）
大概十几分钟就可以写完程序，直接到手几百元，时薪还是很可观的。
03 平台接单
一个非常好用的就是某宝，可以到某宝上搜Python程序，一个月销量好几千的都有。到相应的店里找客服，问他们需不需要兼职，然后拉你进群。
尽量找那种销量大的店，因为它的销量大，所以它的需求也大，跟他们稳定合作几次，你做的单多了，做的好，你接下来拥有稳定兼职的可能性就很大，可选择性会大大增加。
还有就是各种接单网站，一品威客，猪八戒、码市、多为100-30000以内，各种需求都有。
只要你会爬虫、数据分析、机器学习、Web开发或其他门类的任意一项，即可用你的技能换取相应的报酬。
04 熟人介绍
做我们这行的，都会认识一些同行业的朋友，多多少少都会有点资源和渠道。
有时候一个需求一个人是做不完的，相互之间也会有推荐合作，尤其是一些同专业、或者是培训班的同学之间介绍比较多。
或者加入一些行业社群、同行交流群啊，在群里接单，你做的漂亮的话，会不断有人给你介绍需求，积累人脉也还是比较重要的。
05 兼职P图
看了这个，有人可能会说：我没有系统学过美术常识啊，我给别人P图连我自己都不会相信。
其实并不是这样，通过Python可以利用相关代码进行批量处理图片。
不管是缩放、旋转、镜像、裁剪、灰度、添加文本等等，都可以在Python的帮助下完成。
如果学会了Python进行P图，平时可以和一些摄影馆合作，帮助他们处理大量图片，这个尤其推荐大学生，时间比较充足。
06 社群接单
这种主要是一些开了某宝店铺的商家，组织了一个群，然后在群里发布接单任务，由群成员去接，也可以在群里发布接单任务，由群成员去接。
也可以自己搜索python接单之类的关键词，会呈现出许多接单群，有爬虫、大学生作业之类的，难度系数不大。
07 招聘网站
招聘网站不是让你直接去上面挂兼职，而是你直接去找一些公司问他们需不需要兼职。
python现在对于很多非IT公司的需求主要就是办公自动化和数据爬虫。
大概是这么个思路去找：
A 、非IT公司，一个专业的IT公司是不需要我们这种业余的
B 、招一两个程序员的，很大可能就是好工作量简单，但是又必须要的
C 、公司有大数据分析需求，体量又不是很大的，（最好是20人以内的），就像是传统电商、社交电商、直播、团购电商，就是这种互联网销售类的公司就肯定有需求
D 、有大量文字、数据处理的公司，招好几个文员的，也许是需要办公自动化的
学会根据这个公司的需求去准备内容，把自己做的小东西针对这个公司的需求调整一下再去谈，会更有效率。
08 知识付费分享
完全可以在一些编程网站，上传自己的收费课程，一份小额的录播课程可以定价在100-500元不等。
可以将录制的视频发到像腾讯课堂、网易云课堂、头条也有专栏，或者分享一些技术干货文章、技术有偿咨询也是不菲的收入。
这个比较适合技术线的大佬，新手需要一定的技术和经验积累之后再去尝试这个。
接单平台整理 接单网上面的案例都比较简单，可能只需要你十几分钟就能搞定的小案例，都可以获得几百元的金额。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5877df4be3d9f2a8b29696d848bf9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7baf85033e9ea7eb7d801345292b1cab/" rel="bookmark">
			制作一个RISC-V的操作系统四-嵌入式开发介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是嵌入式开发交叉编译查看一些GCC文件夹 调试器GDB相关语法命令 模拟器QEMUQEMU的安装和使用项目构造工具MakeMakeFile的构成make的运行 练习4-1练习4-2练习4-3 什么是嵌入式开发 程序跑到开发板上，或者说运行到硬件上
交叉编译 简单理解交叉编译来说就是生成的程序不在本机上运行，而在与本机架构不同的计算机上运行
build：生成编译程序的计算机
host：运行build计算机生成的编译程序的计算机
target：就是编译结果运行的地方
查看一些GCC文件夹 -&gt;是符号链接
调试器GDB GDB调试包括2个程序：gdb程序和被调试程序。根据这2个程序是否运行在同一台电脑中，可以把GDB的调试模型分为2种:
本地调试：调试程序和被调试程序运行在同一台电脑中
gdb 运行起来后，它会先fork一个子进程，被调试的程序会运行在这个单独的子进程中，gdb这个程序也会单独运行在一个独立的进程里。然后这两个进程通过独特的ptrace系统调用建立连接。
远程调试：调试程序运行在一台电脑中，被调试程序运行在另一台电脑中
在目标机会有一个gdbserver的服务，gdb会与gdbserver交互，由gdbserver代理我们的调试过程，被调试的程序是运行在目标机上的，而调试是在本机上的。两台机器通过网络连接
相关语法命令 p &lt;变量名称&gt; Print的简写，显示指定变量（临时变量或全局变量）的值。 s 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数。相当于其它调试器中的“Step Into (单步跟踪进入)”。 这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 si si命令类似于s命令，但针对汇编指令。 n 执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over (单步跟踪)”。 这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 ni ni命令类似于n命令，但针对汇编指令。 c Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 l List的简写，列出当前位置之后的10行代码；list line_number: 列出line_number之后的十行代码。 模拟器QEMU 此时是模拟用户层的环境（类似操作系统） llk运行在用户层
qemu-riscv32 ./llk #在qemu提供的环境上运行llk 开发操作系统时要模拟系统级别的层次（类似硬件层次）
QEMU的安装和使用 项目构造工具Make 以自动化的方式编译程序
-f指定makefile文件
MakeFile的构成 .DEFAULT_GOAL的特殊变量，可用于告知如果在命令行中未指定目标，(就是只make时候) 应该构建哪个目标（或目标）。否则，Make会简单地使它遇到的第一个目标。
.PHONY:伪目标。伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。 PHONY定义伪目标的命令一定会被执行
对于到下图中就是clean的里面的命令不管clean是否存在，都会执行
$(SRCS_ASM:.S=.o) 就是将SRCS_ASH变量里面的.S都替换为.o make的运行 差不多就是一步步套娃
练习4-1 熟悉交叉编译概念，使⽤ riscv gcc 编译代码并使⽤ binutils ⼯具对⽣成的⽬标文件和可执⾏文件（ELF 格式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7baf85033e9ea7eb7d801345292b1cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8498104ae154dd80e956a8293ecdb9d/" rel="bookmark">
			python 网络爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫基本操作 requests-请求 是否成功 积累程序-爬虫 -requests-请求 是否成功.
import requests response=requests.get("https://www.pku.edu.cn") print(response.status_code)#用来检查请求是否正确响应，如果状态码是200,代表请求成功。 #4XX，客户端错误，403，禁止访问。5XX,服务器错误，503,服务器不可用。3XX，重定向，305,应使用代理访问。1XX，请求收到。2XX，请求成功。 将文件写入本地
import requests webFile=requests.get("https://www.pku.edu.cn/about.html")#爬虫获得html文件 webFile.encoding="utf-8"#爬虫解析网页文件 data=webFile.text#用text文档形式展现 print(data) with open(r"E:/myDownload.html","w",encoding="utf-8") as file1:#将requests获得的网络文件写入本地中。 file1.write(data) 或者用如下代码
#【舉例】 import requests webFile=requests.get("https://www.pku.edu.cn/about.html")#爬虫获得html文件 webFile.encoding="utf-8"#爬虫解析网页文件 data=webFile.text#用text文档形式展现 print(data) with open(r"E:/myDownload.html","w",encoding="utf-8") as file1:#将requests获得的网络文件写入本地中。 file1.write(data) #【舉例】 for i in range(a,a+3):#调试的时候将b换成a+1 webUrl="https://zh.m.wikisource.org/wiki/春秋左傳正義/卷"+str(i) urlList.append(webUrl) webFile=requests.get(webUrl) webFile.encoding="utf-8" data=webFile.text myDfile="myDownload"+str(i)+".html" #第一種 with open(myDfile,"w",encoding="utf-8") as file1:#将requests获得的网络文件写入本地中。 file1.write(data) #第二種，用的是write,而不是print wFile=open(myDfile,"w",encoding="utf-8") wFile.write(data) wFile.close() 观察网站结构 在爬取过程中，需要观察网站的结构。
html = """ &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8498104ae154dd80e956a8293ecdb9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b11827e1aab588dc13ab9350ec91971/" rel="bookmark">
			CUDA中的原子操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA原子操作 CUDA中的原子操作主要包括原子加（atomicAdd）、原子减（atomicSub）、原子与（atomicAnd）、原子或（atomicOr）、原子异或（atomicXor）、原子最小值（atomicMin）和原子最大值（atomicMax）等。
在CUDA中，原子操作是一种同步方法，用于在多个线程之间共享数据。原子操作具有原子性、独占性和排他性，可以确保多个线程对共享资源的并发访问不会同步出错。
原子操作用于对共享内存中的数据进行原子性读写操作，以避免多个线程同时访问同一个内存地址造成的数据竞争问题。在多个线程同时读写同一内存地址时，可能会发生数据不一致的情况。而原子操作可以将多个线程的访问序列化，确保最终结果是正确的。常用的CUDA原子操作有以下几种：
atomicAdd()：对共享内存中的变量进行原子性加法操作。atomicSub()：对共享内存中的变量进行原子性减法操作。atomicExch()：将共享内存中的变量与给定值进行交换，返回原始值。atomicMin()：对共享内存中的变量与给定值进行比较，将较小的值写入共享内存中。atomicMax()：对共享内存中的变量与给定值进行比较，将较大的值写入共享内存中。atomicCAS()：比较共享内存中的变量与给定值，若相等则将共享内存中的变量替换为新值并返回原始值，否则返回当前共享内存中的变量值。 操作原理 它们的原理是通过硬件提供的原子指令来保证在多个线程同时操作同一个全局变量时可以正确完成，避免了数据竞争和不确定性结果的问题。具体来说，当一个线程执行原子操作时，它会在一个特定的时钟周期内尝试修改目标内存位置的值，如果成功，则返回原来的值；如果失败，则重新尝试，直到成功为止。
在CUDA的kernel函数中，原子操作实际上是通过硬件实现的，而不是软件。因此，原子操作的原理是通过硬件锁定内存地址，在同一时刻只允许一个线程访问，并确保操作的顺序是原子的。这可以保证在多个线程同时访问同一内存地址时不会发生竞争问题。
比如，在实现一个并行累加器时，使用原子操作可以避免多个线程同时写入同一内存地址的问题。以atomicAdd()为例，其具体实现原理如下：
读取共享内存中的变量原始值。对原始值进行加法操作，得到新值。若共享内存的值等于原始值，则将共享内存中的变量替换为新值，否则重新读取共享内存中的变量值进行操作。返回原始值。 优势 原子操作的优势在于，它可以有效地避免数据竞争问题，同时也能够提高程序的并发性能。
代码示例1 在CUDA的kernel函数中，可以使用__atomic_前缀和相应的操作名称来实现原子操作。例如，使用atomicAdd实现原子加操作的代码示例如下：
__global__ void sum_kernel(int *sum, int *data, int n) { int tid = blockIdx.x * blockDim.x + threadIdx.x; int stride = gridDim.x * blockDim.x; int local_sum = 0; for (int i = tid; i &lt; n; i += stride) { atomicAdd(&amp;local_sum, data[i]); } atomicAdd(sum, local_sum); } int main() { int n = 1000000; int *data, *sum; cudaMalloc(&amp;data, n * sizeof(int)); cudaMalloc(&amp;sum, sizeof(int)); cudaMemcpy(data, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b11827e1aab588dc13ab9350ec91971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42627b249fc19252a7a474f68a626859/" rel="bookmark">
			【总结】机器学习中的15种分类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、机器学习中的分类算法
1.1 基础分类算法
1.2 集成分类算法
1.3 其它分类算法：
二、各种机器学习分类算法的优缺点
分类算法也称为模式识别，是一种机器学习算法，其主要目的是从数据中发现规律并将数据分成不同的类别。分类算法通过对已知类别训练集的计算和分析，从中发现类别规则并预测新数据的类别。常见的分类算法包括决策树、朴素贝叶斯、逻辑回归、K-最近邻、支持向量机等。分类算法广泛应用于金融、医疗、电子商务等领域，以帮助人们更好地理解和利用数据。
本文介绍15种机器学习中的分类算法，并介绍相关的优缺点，在使用时可以根据优缺点选择合适的算法。
本文部分图文借鉴自《老饼讲解-机器学习》
一、机器学习中的分类算法 机器学习中常用的用于做分类的算法如下：
1.1 基础分类算法 1.决策树：决策树算法通过将数据集划分为不同的子集来预测目标变量。它从根节点开始，根据某个特征对数据集进行划分，然后递归地生成更多的子节点，直到满足停止条件为止。决策树的每个内部节点表示一个特征属性上的判断条件，每个分支代表一个可能的属性值，每个叶节点表示一个分类结果。
2.逻辑回归：逻辑回归算法是一种用于二元分类的算法，它通过使用逻辑函数将线性回归的结果映射到[0,1]范围内。逻辑回归模型将输入特征与输出类别之间的关系表示为线性回归函数，然后通过逻辑函数将线性回归的结果转换为一个概率值，用于预测目标变量。逻辑回归的优点是计算效率高，但在处理高维数据时可能会过拟合。
3.支持向量机（SVM）：SVM算法通过找到一个超平面来划分不同的类别。它试图最大化两个类别之间的边界，这个边界被称为间隔。SVM的目标是找到一个能够将数据集中的点正确分类的超平面，同时最大化间隔。在二分类问题中，SVM通过求解一个二次优化问题来找到这个超平面。
4.朴素贝叶斯：朴素贝叶斯算法是一种基于贝叶斯定理的分类算法，它通过计算每个类别的条件概率来预测目标变量。朴素贝叶斯算法假设每个特征之间是独立的，然后根据这个假设来计算类别的条件概率，并选择概率最大的类别作为预测结果。朴素贝叶斯的优点是在处理高维数据时效率高，并且对数据集的大小和分布不敏感。
5.K-最近邻（KNN）：KNN算法是一种基于实例的学习算法，它根据数据集中的距离度量将新的实例分类到最近的类别中。KNN算法根据距离度量计算待分类项与数据集中每个项的距离，然后选取距离最近的K个项，根据这K个项的类别进行投票，将得票最多的类别作为待分类项的预测类别。KNN的优点是简单、易于理解和实现，但可能会受到数据集大小和维数的影响。
6.神经网络：神经网络是一种基于人工神经元的分类算法，它通过训练神经元之间的连接权重来预测目标变量。神经网络由多个神经元组成，每个神经元接收输入信号并产生输出信号，输出信号通过连接权重与下一个神经元的输入信号相乘得到新的输入信号，最终的输出信号由所有的神经元组成。神经网络的优点是在处理复杂和非线性问题时表现良好，但需要大量的数据和计算资源来训练模型。
7.贝叶斯网络：贝叶斯网络是一种基于概率论的分类算法，它通过建立条件独立关系来构建网络模型，并用于分类和概率推理。贝叶斯网络的优点是在处理不确定性和概率推理时表现良好。
8.线性判别分析（Linear Discriminant Analysis，LDA）：线性判别分析是一种基于判别函数的分类算法，它通过构建一个线性判别函数来划分不同的类别。LDA的优点是在处理高维数据和多个类别时表现良好。
9.最大熵模型（Maximal Entropy Model）：最大熵模型是一种基于概率论的分类算法，它通过最大化熵来构建模型，并用于分类和概率推理。最大熵模型的优点是在处理具有不确定性和噪声的数据时表现良好。
1.2 集成分类算法 10.随机森林：随机森林算法基于决策树算法，通过构建多个决策树并组合它们的预测结果来提高分类精度。它通过随机选择样本和特征来生成多个决策树，然后以投票的方式将最多个数的结果作为最终分类结果。随机森林的优点是可以处理高维数据，并且对数据集的大小和分布不敏感。
11.AdaBoost：AdaBoost是一种迭代算法，它通过将多个弱分类器的结果组合来预测目标变量。AdaBoost算法将数据集分成多个子集，然后针对每个子集训练一个弱分类器，并调整每个弱分类器的权重，使得分类错误的样本得到更大的权重，然后再次训练弱分类器。如此反复迭代，直到达到预设的迭代次数或者弱分类器的精度达到某个阈值为止。最终的预测结果由所有弱分类器的加权和决定。AdaBoost的优点是可以处理多类分类问题，并且对噪声和异常值不敏感。
12.梯度提升决策树（GBDT）：GBDT算法是一种基于梯度提升的分类算法，它通过将多个决策树的结果组合来预测目标变量。GBDT算法通过不断地添加树、更新模型参数和优化目标函数来提高模型的精度。每棵树都是通过对样本特征空间进行划分、寻找最佳划分点来生成的。每棵树生成后，就对应一个残差函数，用当前所有树的残差和作为下一棵树的生成依据。如此反复迭代，直到达到预设的迭代次数或者满足其他停止条件为止。最终的预测结果由所有树的加权和决定。GBDT的优点是在处理复杂和非线性问题时表现良好，并且对数据集的大小和分布不敏感。
13.极端梯度提升（XGBoost）：XGBoost算法是一种改进的梯度提升算法，它通过使用二阶导数信息来优化损失函数。XGBoost算法在生成每棵树时，不仅考虑了一阶导数信息，还考虑了二阶导数信息，从而能够更好地拟合数据集。此外，XGBoost算法还引入了一个正则化项来控制模型的
1.3 其它分类算法： 14.决策树桩（Decision Stump）：决策树桩是一种简化版的决策树算法，它只在一个层级上进行划分，从而简化模型的复杂度。决策树桩的优点是在处理小型数据集和进行实时分类时效率高。
15.K-最近邻朴素贝叶斯（K-Nearest Neighbor Naive Bayes）：K-最近邻朴素贝叶斯算法结合了K-最近邻和朴素贝叶斯的原理，它通过计算每个类别的最近邻数量来进行分类。K-最近邻朴素贝叶斯的优点是在处理大规模数据集和进行实时分类时效率高。
二、各种机器学习分类算法的优缺点 上述分类算法的优缺点如下：
决策树、随机森林和梯度提升决策树（GBDT）：
这些算法都属于集成学习方法，通过将多个弱学习器组合起来提高预测精度。它们能够处理非线性问题，并且对数据量较大的数据集有较好的处理效果。但是，它们可能会过拟合训练数据，导致泛化能力下降。此外，它们也需要较大的计算资源和时间来进行训练。
支持向量机（SVM）：
SVM是一种有坚实理论基础的新颖的小样本学习方法，它基本上不涉及概率测度及大数定律等，因此不同于现有的统计方法。SVM利用内积核函数代替向高维空间的非线性映射，能够处理高维数据，并且不用降维。但是，SVM对特征空间划分的最优超平面是未知的，因此需要人为设定一些参数。
逻辑回归：
逻辑回归是一种简单易懂的分类算法，计算速度快，适用于小数据集。但是，它假设数据服从线性分布，因此对非线性问题处理效果不佳。另外，逻辑回归对多重共线性数据较为敏感，可能导致模型不稳定。
K-最近邻（KNN）：
KNN是一种简单且易于实现的分类算法，适用于小数据集和大规模数据集。但是，它对数据分布的敏感度较高，对于一些特殊的数据分布可能会导致较差的预测效果。
朴素贝叶斯：
朴素贝叶斯算法基于贝叶斯定理，对给定的问题能够提供概率形式的决策支持。它能够处理多类分类问题，并且对缺失数据和不完整数据的处理能力较强。然而，朴素贝叶斯算法假设特征之间相互独立，这在实际应用中往往难以满足。
神经网络：
神经网络具有较强的非线性拟合能力，可以处理复杂的模式识别和预测问题。它具有自学习、自组织和适应性等特点，可以处理大规模的数据集。但是，神经网络的训练过程较为复杂，需要大量的计算资源和时间。此外，神经网络的参数较多，需要仔细调整才能获得最佳的预测效果。
总的来说，不同的机器学习分类算法都有其优缺点，选择哪种算法取决于具体的应用场景和问题特点。在选择算法时，需要考虑数据的规模、特征的复杂性、模型的泛化能力、计算资源和时间等因素。
如果觉得本文有帮助，点个赞吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58f273e5a9c55936333211cc6b8df3e/" rel="bookmark">
			JavaSE学习笔记 Day6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaSE学习笔记 Day6 [上一篇](https://blog.csdn.net/CHiN_951/article/details/134720702?spm=1001.2014.3001.5502)
文章目录 JavaSE学习笔记 Day6···五、方法5.1什么是方法5.2方法组成部分5.3方法名5.4方法的调用5.5自定义方法5.5.1简单方法(无参数无返回值)5.5.2有参无返回值方法5.5.3无参有返回值方法5.5.4有参有返回值方法 5.6return关键字5.7方法的细节和好处5.8方法的重载 ··· 五、方法 5.1什么是方法 可以封装为了解决某个问题的代码片段,称之为方法
方法可以被重复的调用
5.2方法组成部分 public static void main(String[] args) {}
//main方法,又被称为主方法,是现阶段jvm唯一识别的方法,也是程序的入口
解析:
public 公共的,方法的访问权限修饰符,表示任何类都可以直接访问
static 静态的,方法的修饰符
void 空白的,无返回值的 方法返回值类型之一
main 主要的,方法名(可以自定的)
() 方法的参数列表
{} 方法的主体(方法体),在方法体内部可以编写代码段
String[] 参数,类型为字符串数组
args 参数名，参数就是变量
方法的重要组成部分:
方法的定义
方法体
public class Demo01 { //	自定义方法:打印分割线,只要调用就会输出显示 public void myPrint() { System.out.println("-------------分割线-------------"); } public static void main(String[] args) { //	方法的调用 //	1.创建当前类的对象(变量) Demo01 demo01 = new Demo01(); //	2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58f273e5a9c55936333211cc6b8df3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a480e2c5024c777058df2bed5f876bc/" rel="bookmark">
			轻松免费升级overleaf高级账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Overleaf是一个在线LaTeX编辑器，不需要复杂的配置，直接在网页进行LaTeX编写，并且支持包括版本控制，共享协助以及编译预览等功能。 免费的版本有很多限制，特别人只能有一个协作人。但是付费版确实是比较贵：199美金标准版，399美金专业版，实在是买不起。 但是我们只需要关联自己的IEEE collaboration账户就可以免费升级了。 Step1： 登录IEEE collaboration，创建免费账户 网址： https://ieee-collabratec.ieee.org/ step2：填写信息，创建账户。 Step3：注册成功后，登录账户。然后点击Setting， IEEE Account Settings Step4: 接着点击PERSONALIZE, Attached Services， 然后翻找到overleaf。 Step5：点击overleaf后选择连接到你的账户。 Step6：成功后，再次进入overleaf，就会发现已经是Permium账户了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fac3c883e33cb33cf22d795aa6a36f4/" rel="bookmark">
			soapui报错： CXF directory must be set in global preferences
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 下载官网下载网盘下载 配置 soapui生成代码时报错 CXF directory must be set in global preferences 下载 需要下载apache-cxf。
官网下载 官网地址：
https://www.apache.org/dyn/closer.lua/cxf/3.5.4/apache-cxf-3.5.4.zip
点如下地址即可。
The object is in our archive : https://archive.apache.org/dist/cxf/3.5.4/apache-cxf-3.5.4.zip
网盘下载 懒得找的话，也可以用这个网盘地址。
链接：https://pan.baidu.com/s/14JYiuZJeM8NFGTMtwycCzQ
提取码：k8rm
配置 下载完毕后解压，soapui界面 工具栏 | 螺丝刀和扳手 的那个图标(Sets Global SoapUl Preferences) | tools | cxf 这里配置上cxf的路径即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d59a60b6b1601c72723de336fb1ef09/" rel="bookmark">
			git常用操作和常用alias
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用alias配置：
git终端执行
git config --global --edit进入vim编辑config的界面
格式：
[alias]
ga = git add
br = branch
cm = commit
cl = clone
co = checkout
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ed66cb14817ab059eb866f73b9915d/" rel="bookmark">
			使用 nvm 实现对 Node 的多版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目开发过程中，不同项目使用的nodejs版本不同，有时会因为node版本过高或太低，导致报错；
这个时候我们或许就需要自己的电脑上安装不同版本的node切换使用
使用 nvm 进行管理 NVM 全称 Node Version Manager，是一个管理 NodeJS 版本的工具
安装前需要将自己电脑上的node卸载
卸载完成后
点击打开
选择下载：
安装前，事先准备好一个英文路径的文件夹，创建两个目录
nvm、node
双击运行
第一个配置nvm的安装路径；
第二个配置node的安装路径
Finish -&gt;
打开nvm文件夹，配置文件 setting.txt
添加：
arch: 64proxy: node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 注：
arch：Windows 操作系统位数
proxy：代理，淘宝 NodeJS 镜像和 NPM 镜像
node不同版本的切换 安装指定node版本：
nvm install v版本号
查看当前版本：
nvm list
切换版本：
nvm use 版本号
切换版本后，使用 node -v 命令查看是否已完成切换
常用命令汇总：
nvm install &lt;version&gt; // 安装node.js的命名 version是版本号 例如：nvm install 8.12.0 nvm uninstall &lt;version&gt; // 卸载node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9ed66cb14817ab059eb866f73b9915d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8339bb79d92c9fa8beec33c1b702ec5f/" rel="bookmark">
			计算机使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录本人使用电脑的习惯，及经验技巧，后续更新！
文章目录 Linux系统技巧快捷键字体软件源查找并批量删除替换文件中的某一字段修改MAC地址 工具类型文件比较多线程下载 常见错误解决Ubuntu 18 问题系统更新包管理器添加源恢复默认桌面恢复文件管理器 一些奇怪的现象Windows的原因内核原因 搭建服务器FTP服务器GIT服务器Web服务器文件同步 桌面远程控制方法1方法2 休眠挂载磁盘镜像ISO 创建快捷方式Linux磁盘目录其它磁盘目录 系统备份与恢复压缩命令备份与恢复 保存网站音视频播放器添加字体准备字体文件安装字体 图像视频相关屏幕录制 编程显卡切换CUDA切换 Windows系统启动修复失败无法启动 技巧替换文件中的某一字段 查看电脑信息系统信息硬件信息无新建菜单修改MAC地址 搭建服务器Web服务器FTP服务器 工具类多线程下载aria2 Microsoft软件的获取MS Office软件Onenote插件 输入法问题字符不匹配 右键菜单添加“用写字板打开”等快捷操作 查看Linux分区病毒Skypee病毒 服务蓝牙任务栏系统图标失效网络属性空白 双系统时间不一致自动切换更新取消自动更新 第三方软件PythonAnaconda切换 MATLAB以MATLAB Editor打开“.m”文件 多系统 Linux系统 技巧 快捷键 以截图软件FlameShot为例，点击系统Settings，按下图操作
字体 对于缺少的字体，可以从Windows系统里（Windows/Fonts）搜索复制字体文件，将其拷贝到/usr/share/fonts或其下的文件夹下。然后执行fc-cache，如果是matplotlib提示，还需要继续删除rm -rf ~/.cache/matplotlib/。
软件源 每个源的主页都提供了详细的设置方法
清华源阿里源 Ubuntu源: 修改文件 /etc/apt/sources.list，将原始源中的http://archive.ubuntu.com/ 换成 mirrors.tuna.tsinghua.edu.cn 或者 mirrors.aliyun.com，例如：
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8339bb79d92c9fa8beec33c1b702ec5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b213e36e8e630da98741472a17ed21/" rel="bookmark">
			Mars3D小白专属：开发者快速上手实战指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mars3D小白专属：开发者快速上手实战指南 前言Mars3D的基础概念1. Mars3D是什么？2. 其目标和愿景：3. 数字地球技术的演进与Mars3D的关系：搭建Mars3D的开发环境1. 获取API和SDK：2. 配置开发环境： 深入Mars3D的API和SDK1. 地理信息系统 (GIS)的应用：2. 地球科学和虚拟地球建模： 开发者社区与合作1. Mars3D的开发者社区：2. 开发者合作项目： 实际应用案例1. 科学研究和教育领域：Mars3D在地球科学研究中的应用：Mars3D在教育领域中的应用： 2. 创新行业的数字化地球应用：商业领域中的Mars3D应用案例：军事领域中的Mars3D应用案例： Mars3D未来的发展趋势1. 开发者社区的影响：2. Mars3D的未来版本预览： 前言 在这个科技飞速发展的时代，火星已经不再只是夜空中一颗孤寂的星球。它成为了我们数字时代的新大陆，一个由开发者编码而成的数字星球——Mars3D。今天，我们将揭开这个数字星球的神秘面纱，邀请各位开发者一同登上探险之船，穿越代码星际，探索Mars3D的无尽可能性。
Mars3D的基础概念 1. Mars3D是什么？ Mars3D是一项领先的数字地球技术，旨在为用户提供高度交互和可视化的虚拟地球体验。它将地理信息系统（GIS）和先进的三维地球建模技术相结合，使用户能够在虚拟的地球表面上导航、探索和可视化地理信息。Mars3D不仅仅是一个地球浏览器，更是一个开放平台，为开发者提供丰富的工具和API，以创造独特的地理信息体验。
2. 其目标和愿景： Mars3D的目标是打造一个数字地球平台，使用户能够以前所未有的方式与地球交互。其愿景是将地球的复杂信息呈现为直观、可理解的虚拟地球模型，为用户提供更深入、更全面的地理认知。同时，Mars3D致力于促进开发者社区的创新，通过共享和合作，推动数字地球技术的不断发展。
3. 数字地球技术的演进与Mars3D的关系： 随着技术的不断进步，数字地球技术逐渐从简单的地图应用发展为更为复杂、交互性更强的虚拟地球平台。 Mars3D作为数字地球技术的新一代代表，吸纳了先进的三维地球建模、实时渲染等技术，使用户能够更自由、更直观地探索地球表面。它与传统地图应用相比，提供了更真实、更沉浸的地理信息体验，推动了数字地球技术的演进。 Mars3D的出现，标志着数字地球技术进入了一个更高级、更互动的时代。
搭建Mars3D的开发环境 1. 获取API和SDK： 在开始Mars3D的开发之前，首先需要获取Mars3D的API和SDK。以下是获取这些工具的步骤：
访问官方网站： 进入Mars3D的官方网站，通常可以在"开发者"或"文档"部分找到API和SDK的下载链接。注册开发者账号： 有些平台可能需要注册开发者账号，以获取API密钥或访问开发者资源。文档查阅： 仔细阅读Mars3D的官方文档，了解API的功能、使用方法以及SDK的集成方式。下载并安装： 下载所需的API和SDK版本，按照官方指导进行安装。 2. 配置开发环境： 成功获取API和SDK后，接下来是配置开发环境，确保项目能够顺利启动。以下是详细的配置步骤：
选择开发工具： Mars3D通常支持多种开发工具，如Visual Studio Code、Eclipse等。选择一个你熟悉的IDE。新建项目： 使用选定的开发工具创建一个新项目，选择Mars3D的项目模板或初始化配置。引入API和SDK： 在项目中引入下载的Mars3D API和SDK，确保路径配置正确。配置API密钥： 如果需要API密钥，将密钥配置到项目中，以确保正常访问Mars3D服务。配置地图服务： 根据项目需求，配置地图服务的相关参数，如地图图层、坐标系等。检查依赖： 检查项目所需的依赖库和插件，确保它们正确安装和配置。启动项目： 使用选定的开发工具启动项目，检查控制台输出和日志，确保没有错误。 通过按照上述步骤获取API和SDK，并配置开发环境，开发者可以顺利搭建Mars3D的开发环境，为后续的项目开发打下坚实基础。
深入Mars3D的API和SDK 1. 地理信息系统 (GIS)的应用： Mars3D的API提供了丰富的功能，与GIS的集成使得地理信息的处理更为灵活和强大。以下是Mars3D API与GIS集成的关键点：
图层管理： Mars3D API支持与GIS中常见的地图图层进行集成，包括矢量图层、栅格图层等。开发者可以通过API添加、移除和配置这些图层，实现地理信息的叠加展示。地理坐标转换： Mars3D提供了坐标系转换的功能，使得开发者可以在不同坐标系之间进行无缝转换，确保地理数据的一致性和准确性。空间分析： 利用Mars3D API，开发者可以进行空间分析，包括空间查询、缓冲区分析等，与GIS系统实现更丰富的地理信息处理。实时数据更新： Mars3D的API支持实时数据的更新和展示，可以与GIS中的实时地理数据集成，实现实时地理信息展示。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b213e36e8e630da98741472a17ed21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7507cd42a8f4d53b69c092e00fbae507/" rel="bookmark">
			Pytorch 相关 内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch 相关书籍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9e7192a26897ff5be1b3ce73f75aa0/" rel="bookmark">
			浪潮信息 KeyarchOS 安全可信攻防体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. KeyarchOS——云峦操作系统简介 KeyarchOS 即云峦服务器操作系统(简称 KOS)是浪潮信息基于 Linux 内核、龙蜥等开源技术自主研发的一款服务器操作系统，支持 x86、ARM 等主流架构处理器，广泛兼容传统 CentOS 生态产品和创新技术产品，可为用户提供整套可视化 CentOS to KeyarchOS 迁移方案。KeyarchOS 是一款面向政企、金融等企业级用户的 Linux 服务器操作系统，面向行业提供服务器操作系统解决方案。其在 OpenAnolis 社区版的基础上，加入自主研发的软件，其稳定性、安全性、兼容性和性能等核心能力均已得到充分验证。
KeyarchOS 具备稳定可靠、高效软硬件协同、全天候运维、安全可信等特性，增强了对云计算、人工智能等场景的支持，性能稳定性领先，生态完善，符合金融、能源、交通、通信、教育、医疗等关键行业的应用要求在服务器操作系统领域，从最早的 KUX 开始，浪潮信息已经有 10 余年的研发和技术经验，相关产品在关键行业广泛应用，支持光盘、U盘、PXE 等安装方式，可部署在用户物理裸机服务器、虚拟机和容器等环境，同时为用户提供部署、升级和迁移方案，以及完整的生态支持和专业的技术保障，累计装机超 20 万台。
2. EDR Agent简介 EDR 作为 KeyarchOS 的安全工具，通过安装在 KeyarchOS 主机上的本地客户端（Agent）与管理中心联动，提供病毒木马、勒索软件、暴力破解等攻击的查杀防护功能，防御未知程序运行和关键业务文件篡改。为主机提供安全稳定的运行环境，为业务的开展保驾护航。
3. EDR 防病毒能力测试 为了验证 EDR（KeyarchOS 的安全工具）的防病毒能力到底如何，下面准备了三台服务器用来进行测试内容。
KeyarchOS 服务器 A：安装 KeyarchOS 系统的服务器（具备 EDR 工具）；常规服务器 B：未安装 KeyarchOS 系统的服务器；常规服务器 C：未安装 KeyarchOS 系统的服务器。 3.1. 勒索病毒防护能力测试 3.1.1. 已知勒索病毒防护能力 主机 B 测试（不具备 EDR 工具）
首先使用已知的勒索病毒对未安装 EDR 的主机 B 进行钓鱼连接下载恶意文件进行测试，看其是否能自主避免已知的勒索病毒。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9e7192a26897ff5be1b3ce73f75aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c7d6f7c06b084d868ffc175faaaecc/" rel="bookmark">
			一份全面的大模型「幻觉」综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一份全面的大模型「幻觉」综述1. 幻觉的分类2. 幻觉的来源2.1 幻觉来自数据2.2 幻觉来自训练2.3 幻觉来自生成/推理 3. 幻觉的检测3.1 事实性幻觉的检测3.2 忠实性幻觉的检测 4. 幻觉的评估5. 幻觉的解决 一份全面的大模型「幻觉」综述 相信大家在使用ChatGPT或者其他大模型时会遇到这样的情况，模型答非所问甚至自相矛盾。
虽然大语言模型（LLMs）在各种下游任务中展示出了卓越的能力，在多个领域有广泛应用，但存在着幻觉的问题：即生成与用户输入不符、与先前生成的内容矛盾或与已知世界知识不符的内容。
这种现象对LLMs在现实世界场景中的可靠性构成了重大挑战。在准确率要求非常高的场景下幻觉是不可接受的，比如医疗领域、金融领域等。
目前在LLM幻觉问题上已经有无数的研究，比如关于幻觉的检测、幻觉的评估基准分类、缓解幻觉的方法等。
今天我会结合几篇有关LLM幻觉问题的综述论文，来聊聊LLM幻觉的分类、检测方法、评估和基准、减轻方法等。
传送门：《一文读懂：大语言模型LLM的幻觉问题》
最近的一篇是来自哈尔滨工业大学和华为的研究团队，长达49页，对有关LLM幻觉问题的最新进展来了一个全面而深入的概述。
这篇综述（下文简称：综述1）从LLM幻觉的创新分类方法出发，深入探究了可能导致幻觉的因素，并对检测幻觉的方法和基准进行了概述。
论文链接：https://arxiv.org/abs/2311.05232
另外还有一篇综述（下文简称：综述2），来自腾讯AI实验室和一些国内大学的研究团队，综述提出了LLM幻觉现象的分类法和评估基准，分析旨在减轻LLM幻觉的现有方法，并确定未来研究的潜在方向。
论文链接：https://arxiv.org/pdf/2309.01219.pdf
还有一篇有关幻觉的论文（下文简称：论文1），对各种文本生成任务中的幻觉现象进行了新的分类，从而提供了理论分析、检测方法和改进方法。
论文链接：https://arxiv.org/pdf/2309.06794v1.pdf
1. 幻觉的分类 在综述2中，将LLMs幻觉分为三种：输入冲突幻觉、上下文冲突幻觉和事实冲突幻觉。
输入冲突幻觉：是指生成的内容与用户提供的输入不符；上下文冲突幻觉：是指生成的内容与之前生成的信息相矛盾；事实冲突幻觉：是指生成的内容与已知的世界知识不符。 图注：3种幻觉的定义
而在最新的综述1中，将LLM幻觉分为两种：事实型幻觉和忠实度幻觉。
如上图所示，左边是事实型幻觉：当LLM被问到谁是第一个在月球上漫步的人时，LLM编了个人物出来，甚至还说得有模有样。右边是忠实度幻觉：LLM在看到这段新闻后，直接把年份概括错了。
下图是一张更为详细的LLM幻觉种类图，包括更为细致的分类：事实型幻觉包括事实不一致、事实捏造；忠实度幻觉又包括：指令-答案的不一致、文本不一致，以及逻辑不一致。
总的来说，结合事实、上下文、输入的不一致，幻觉的定义和分类上是相似的。
结合常见的下游任务，比如机器翻译、问答系统、对话系统、文本摘要、LLM知识图谱和视觉问答系统，论文1总结了典型的幻觉现象，如下表所示：
2. 幻觉的来源 综述2认为产生幻觉的主要原因有预训练数据收集、知识GAP和大模型优化过程三个方面。
最新的综述1也深入探讨LLM产生幻觉的根本原因，主要分为三个关键方面：数据、训练和推理。
结合起来，我们具体来看下幻觉的来源：
2.1 幻觉来自数据 预训练数据：大模型的知识和能力主要来自与预训练数据，如果预训练数据使用了不完整或者过期的数据，那么就很可能导致知识的错误，从而引起幻觉现象。数据利用：LLMs 往往会捕捉到虚假的相关性，在回忆知识（尤其是长尾信息）和复杂推理场景中表现出困难，从而进一步加剧幻觉。 2.2 幻觉来自训练 预训练阶段：LLMs在这一阶段学习通用表征并捕捉广泛的知识，通常采用基于transformer的架构，在庞大的语料库中进行因果语言建模。但是，固有的架构设计和研究人员所采用的特定训练策略，可能会产生与幻觉相关的问题。对齐阶段：一般涉及两个主要过程，即监督微调和从人类反馈中强化学习（RLHF）。虽然对齐能显著提高 LLM 响应的质量，但也会带来产生幻觉的风险，主要分为两方面：能力不对齐（Capability Misalignment）和信念不对齐（Belief Misalignment）。 2.3 幻觉来自生成/推理 经过预训练和对齐后，解码在体现 LLM 能力方面发挥着重要作用。然而，解码策略的某些缺陷可能导致 LLM 出现幻觉。综述1深入探讨源于解码过程的潜在原因，并强调两个关键因素：
解码策略固有的随机性（Inherent Sampling Randomness）：比如采用采样生成策略（如top-p和top-k）引入的随机性也可能导致幻觉的产生。不完善的解码表示（Imperfect Decoding Representation）：在解码阶段，LLM 使用顶层表示法预测下一个标记。然而，顶层表示法也有其局限性，主要表现在两个方面： 上下文关注不足（Insufficient Context Attention）和Softmax瓶颈（Softmax Bottleneck）。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09c7d6f7c06b084d868ffc175faaaecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326335ba581fb8ce44d2150fb87c42ff/" rel="bookmark">
			2023 年诺贝尔奖花落谁家？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2023 年诺贝尔奖，花落谁家？2023年诺贝尔经济学奖2023年诺贝尔和平奖2023年诺贝尔文学奖2023年诺贝尔化学奖2023年诺贝尔物理学奖2023年诺贝尔生理学/医学奖 2023 年诺贝尔奖，花落谁家？ 2023年诺贝尔奖于10月2日至9日陆续颁布，今年诺奖花落谁家？
2023年诺贝尔经济学奖 10月9日，「2023年诺贝尔经济学奖」授予美国哈佛大学经济学教授克劳迪娅·戈尔丁，以表彰其“发现了劳动力市场性别差异背后的关键因素”。
戈尔丁首次全面梳理了几个世纪以来女性的收入和劳动力市场参与情况。她的研究揭示了这些变化的原因，以及劳动力市场中仍然存在性别差距的主要根源。
全球劳动力市场中女性的代表性严重不足，而且当女性工作时，她们的收入低于男性。戈尔丁搜集了美国200多年来的档案数据，证明了收入和就业率的性别差异是如何以及为何会随着时间推移而变化。
2023年诺贝尔和平奖 当地时间10月6日，「2023年诺贝尔和平奖」颁给了伊朗女权捍卫者、人权活动家纳尔吉斯·穆罕默迪（Narges Mohammadi），以表彰她“为反对伊朗妇女遭受压迫、促进人权与自由而战斗”。
2023年诺贝尔文学奖 瑞典文学院10月5日宣布，将「2023年诺贝尔文学奖」授予今年64岁的挪威作家、诗人和戏剧家约恩·福瑟，获奖理由：“因其创新的戏剧和散文体作品，为不可言说之物发声。”（“for his innovative plays and prose which give voice to the unsayable.”）
约恩·福瑟以新挪威语创作了大量作品，涵盖了各种体裁，包括戏剧、小说、诗集、散文、儿童读物和翻译作品。
约恩·福瑟于1983年出版发行处女作《红、黑》；此后有《有人将至》、《秋之梦》、《醒来》、《奥拉夫的梦》、《疲倦》、《晨与夜》、《船屋》、《拾瓶子的人》、《铅与水》等作品。
2023年诺贝尔化学奖 瑞典皇家科学院10月4日宣布，将「2023年诺贝尔化学奖」授予美籍法国-突尼斯裔化学家Moungi Bawendi、美国化学家Louis Brus和俄罗斯物理学家Alexei Ekimov，以表彰其在“发现和合成量子点”方面做出的贡献。
诺贝尔化学委员会主席约翰·阿奎斯特说：“量子点具有许多迷人和不寻常的特性。重要的是，它们根据大小有不同的颜色。”
那么，什么是量子点呢？
我们所说的量子点，又称半导体纳米晶，是由数百或数千原子组成、尺寸一般小于20纳米的半导体晶体颗粒。半导体材料是信息社会的基石，一般是由具有重复单元结构的晶体组成，其半导体性质是由重复单元的类型所决定。由于量子点的尺寸进入纳米尺度，半导体纳米晶体内部重复单元的数目有限，导致材料的电子结构发生很大的变化。
以目前研究最广泛的硒化镉(CdSe)量子点为例，其本体硒化镉为黑色粉末，通常并没有荧光效应；而溶液合成的硒化镉量子点，可以通过尺寸改变，实现由蓝光到红光的多种颜色发光。
由于量子点丰富的物理化学性质，经过基础研究的不懈探索，形成了很多重要的前沿技术。除了目前已经商业化的量子点液晶显示以外，量子点在未来显示、光源技术和新能源等领域都有巨大的应用潜力。在未来，它们可以为柔性电子产品、微型传感器、更薄的太阳能电池和加密的量子通信做出贡献。
2023年诺贝尔物理学奖 10月3日，瑞典皇家科学院宣布，将「2023年诺贝尔物理学奖」授予美国俄亥俄州立大学名誉教授皮埃尔·阿戈斯蒂尼（Pierre Agostini）、德国马克斯·普朗克量子光学研究所教授费伦茨·克劳斯（Ferenc Krausz）和瑞典隆德大学教授安妮·呂利耶（Anne L’Huillier），三人平分奖金，以表彰他们在“产生阿秒光脉冲以研究物质中电子动力学的实验方法”方面所做出的贡献。
同时，安妮·呂利耶成为第5位获得诺贝尔物理学奖的女性。
24年前，1999年诺贝尔化学奖被授予使用当时世界上最快的“相机”的美国加州理工学院教授艾哈迈德·H·祖瓦伊勒（Ahmed H. Zewail）。他用飞秒激光看到反应过程中化学分子的过渡态。
而今，世界最快“相机”再次升级，速度加快千倍，从飞秒跨越到阿秒，“看到”分子中电子的运动。
阿秒光脉冲（简称“阿秒脉冲”）是一束极短促的闪光，提供了一开一关极快的相机“快门”，能够“拍摄”到狂飙中的电子。发明这种基础科学的新工具、新技术的科学家们，将人类带进了阿秒时代。
阿秒脉冲是目前最短的光脉冲，用最短的光脉冲可以探索电子世界，但是还有比阿秒更短的时间单位——仄秒（10−21秒）、幺秒（10−24秒）等。
图注：1阿秒等于千分之一飞秒，相当于10^-18秒。一秒钟内的阿秒数与138亿年前宇宙诞生以来所经过的秒数相同。一束光从房间里一堵墙照射到另一堵墙，需要100亿阿秒的时间。
2023年诺贝尔生理学/医学奖 10月2日，「2023年诺贝尔生理学或医学奖」揭晓，美国科学家卡塔琳·卡里科（Katalin Karikó）和德鲁·魏斯曼（Drew Weissman）获奖，获奖原因是他们在核苷碱基修饰方面的发现，使得针对 COVID-19 的有效 mRNA 疫苗得以被开发。
传统疫苗开发的周期在10~15年左右，诺奖的发现不仅让 mRNA 新冠疫苗在11个月内快速开发成为可能，更颠覆了人们对于疫苗、药物以及疾病的认识。这一成就已经挽救了百万人的生命，未来还可以应用到癌症、疟疾、HIV和结核等有重大疾病的治疗方法开发中，是未来医学进步发展的曙光。
参考：
https://www.nobelprize.org/prizes/lists/all-nobel-prizes/
欢迎各位关注我的个人微信公众号：HsuDan，我将分享更多自己的学习心得、避坑总结、面试经验、AI最新技术资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0cb2bae1117701932c8e601482bae4/" rel="bookmark">
			《计算机网络原理》第三章 数据通信技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《计算机网络原理》第三章 数据通信技术 3.1 概述3.2 数据通信理论基础3.2.1 傅里叶分析3.2.2 周期矩形脉冲信号的频谱特性 3.3 数据通信系统模型3.3.1 数据通信系统基本结构3.3.2 数据与信号3.3.3 信道通信方式3.3.4 数据传输方式 3.4 传输媒介3.4.1 电磁波谱3.4.2 双绞线3.4.3 同轴电缆3.4.4 光纤3.4.5 无线媒介 3.5 数据编码3.5.1 信号编码3.5.2 调制编码3.5.3 模拟数据数字化编码 3.6 数据通信性能指标3.6.1 时延3.6.2 传输速率3.6.3 可靠性3.6.4 信道极限容量 3.7 信道复用技术3.7.1 频分、时分复用3.7.2 统计时分复用3.7.3 波分复用3.7.4 码分复用 3.8 数字传输系统3.8.1 PCM体制3.8.2 SONET与SDH 3.9 数据交换技术3.9.1 电路交换3.9.2 报文交换3.9.3 分组交换 3.10 物理层规程3.10.1 DTE与DCE3.10.2 物理层接口标准3.10.3 EIA-232 试比较模拟通信方式与数字通信方式的优缺点如何利用话音通道传输计算机数据？试比较电路交换、报文交换、虚电路交换和数据报交换的特点请画出 **011000101111 **的不归零编码、曼彻斯特编码和差分曼彻斯特编码的波形图现在需要在一条光纤上发送一系列计算机屏幕图像。屏幕的分辨率为 480 640 像素，每个像素为 24 位。每秒种有 60 幅屏幕图像。请问：需要多少带宽？在 1.30μm 波长上，这段带宽需要多少μm 的波长？为什么 PCM 采样时间被设置为 125μs？请比较一下在一个【电路交换】网络与在一个轻负载的【分组交换】网络上，沿 k 跳的路径发送一个 x 比特消息的延迟情况。假设电路建立的时间为 s 秒，每一跳的传播延迟为 d 秒，分组的大小为 p 位，数据传输速率为 b bps。试问在什么条件下分组网络的延迟比较短？ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0cb2bae1117701932c8e601482bae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10cf70f1f0bc3c441abeaed0505c2cf6/" rel="bookmark">
			【Linux】基本指令（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文续接上文基本指令（一）
目录 cpmvcatmore &amp;&amp; lesshead &amp;&amp; tail管道： datecal：findgrep cp 语法：cp [选项] 源文件或目录 目标文件或目录
功能: 复制文件或目录
说明: cp指令用于复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，
则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息
关于cp我们需要注意的点：
我们发现cp的语法是cp src dst
由于我们有时也会复制目录，所以通常会cp -fr src dst
同时，带路径的文件名就顺便会重命名
示例:
我们将当前目录的log.txt放到了./a/b下,如若我们使用./a/b/newfilename
就会顺便重命名
mv mv与cp的使用方式是非常类似的
mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命
令，经常用来备份文件或者目录。
语法: mv [选项] 源文件或目录 目标文件或目录
功能:
视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的
目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它
将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至
目标目录中。 常用选项：
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ 举例说明：
我们在进行移动文件时顺便将文件进行了重命名。
cat cat是一个比较简单的指令
语法：cat [选项][文件]
功能： 查看目标文件的内容
常用选项：
-b 对非空输出行编号
-n 对输出的所有行编号
-s 不输出多行空行
举例说明:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10cf70f1f0bc3c441abeaed0505c2cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34302692e32a9675679f37e595da21ba/" rel="bookmark">
			差分基准站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		差分基准站，又称参考接收机，是一种固定式卫星接收机，用于提高卫星定位精度。 差分基准站的作用是提供已知位置和准确的位置信号，以纠正其他移动定位终端接收器接收到的卫星信号中的误差。 卫星定位信号会受到多种因素的影响，例如大气条件、电离层干扰和卫星轨道误差。 这些因素会导致卫星定位出现误差，从而影响卫星定位的准确性。
差分基准站通常放置在已知位置，通过将基准站接收到的卫星信号与基于其已知位置的预期卫星信号进行比较，参考站可以确定卫星信号中的错误。 然后这些错误信息传输给到该地区的其他卫星接收设备，这些接收器可以使用这些信息来校正自己的卫星信号并提高定位精度。
差分基准站的使用在需要高精度定位的应用中尤为重要，例如测量、测绘和导航。 通过提供准确可靠的校正信息，差分参考站可以提高卫星 接收器的定位精度到厘米，从而实现更精确可靠的定位。
应用领域
差分基准站HXZK-CFJZ可为便携式RTK终端提供高精度的差分服务，产品采用IP67防护等级设计，支持BDS：B1、B2、B3，GPS：L1C/A、L2C、L2E、L5，GLONASS：L1 C/A、L1P、L2 C/A(仅GLONASS M)、L2P，GIOVE-A：同步L1 BOC、E5A、E5B和E5AltBOC（支持），GIOVE-B：同步L1 CBOC、E5A、E5B和E5AltBOC （支持）。SBAS:L1 C/A, L5支持WASS, EGNOS 和MSAS，差分基站支持365天*24h连续工作，工业级标准设计，支持恶劣环境使用。
特点
全方位全星座跟踪技术 能够接收中国的北斗定位系统BDS：B1、B2、B3，美国的GPS：L1C/A、L2C、L2E、L5，俄罗斯的GLONASS：L1 C/A、L1P、L2 C/A(仅GLONASS M)、L2P，GIOVE-A：同步L1 BOC、E5A、E5B和E5AltBOC（支持），GIOVE-B：同步L1 CBOC、E5A、E5B和E5AltBOC （支持）。SBAS:L1 C/A, L5支持WASS, EGNOS 和MSAS。
工业级设计 产品采用工业级标准设计，支持24小时*365天连续使用，工作温度-40℃~+80℃，定位稳定可靠。
覆盖范围广 一台差分基准站可覆盖方圆20km距离，为该区域设备提供差分服务。
丰富的通信协议 设置支持TCP/UDP/HTTP协议也可以选配4G传输。
宽电压供电 支持DC12-24V宽电压供电模式。
安装简单 设备安装简单，没有复杂的安装流程。
差分系统架构
差分定位系统架构如下图所示，差分接收机通过馈线和差分天线连接，天线需要固定安装在露天的室外，必要时候需要建设固定安装基座，差分接收机通过4G或者网线的方式将数据传输到服务器，服务器需要有固定的IP地址。
差分基站安装
安装北斗差分基准站是确保高精度定位服务有效运行的关键步骤。以下是在安装差分基准站时需要注意的一些要求和注意事项：
选址和环境： 开阔地带： 差分基准站应尽量选择在视线开阔的地带，避免高建筑物、山脉、树木等阻挡卫星信号；如下图所示天线和天空15度方向要没有建筑物或者遮挡物，如下图黄色区域不能有遮挡物或者建筑物。
低干扰环境： 选择远离电磁干扰源（如高压电线、通讯设施等）的地点，以确保设备正常运行。
防护措施： 如果可能，应选择一个不易受到恶劣天气（如雷电）影响的地点，并为设备提供适当的防护措施，如防水罩。
基站设备安装： 稳定基座： 基准站设备需要安装在稳固的基座上，确保设备不会因为震动而影响定位精度。
水平校准： 在安装基站设备之前，进行水平校准以确保天线水平放置，以避免定位误差。
安全固定： 设备必须牢固地固定在基座上，以避免因风力或其他外力导致设备倾斜或移位。
数据通信和电源： 稳定电源： 提供稳定可靠的电源供应，以确保基站设备的正常运行。
现场安装照片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78cb5c001aae07183c58103f94996208/" rel="bookmark">
			考虑光伏发电的配电网重构策略研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 面对全球日趋严重的能源危机问题，可再生能源的开发和利用得到了人们的高度重视。其中辐射到地球太阳能资源是十分富饶的，绿色清洁的太阳能不会危害我们的生存环境，因而受到了人们的广泛利用。光伏发电作为可再生能源被广泛的应用，技术不断革新。
近年来，随着大量光伏接入配电网，一方面提高了电网应对负荷的能力，一方面间歇性光伏供电也对电网的稳定运行带来了一定的冲击。同时配电网的日常运行中，通常为了应对某些状况，通过开关动作进行网络重构，以保证电网的经济性和稳定性，光伏的接入也会使得配电网网络重构变得更加复杂，使得传统的网络重构方案难以满足复杂网络结构下的电网的运行控制要求。对此，本文展开含光伏发电的配电网重构策略研究。
在MATLAB/Simulink仿真环境下搭建了光伏发电并网的配电网系统仿真模型，研究含光伏配电网的网络重构策略，构建计及经济性、可靠性和安全性的时段性重构模型，采用多智能体体系建立含随机性光伏和波动性柔性负荷的主动配电网动态优化重构策略，实现主动配电网的协同重构，提高主动配电网的自愈能力和负荷供电可靠性。同时对提出的控制方案进行了一系列仿真实验，从多角度验证了所提出控制方法的灵活性和可靠性。
关键词：光伏发电，并网，MATLAB仿真，配电网，动态重构
Abstract In the face of the increasingly serious global energy crisis, the development and utilization of renewable energy has been attached great importance. Which radiation to the earth's solar energy resources are very rich, green and clean solar energy will not harm our living environment, so it has been widely used by people. Photovoltaic power generation is widely used as a renewable energy source, and the technology is constantly innovated.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78cb5c001aae07183c58103f94996208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6406f339800045964ac6bf40562f2c4b/" rel="bookmark">
			室内外融合便携式定位终端5G&#43;UWB&#43;RTK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
便携式定位终端主要用于提供高精度的位置数据，支持室内UWB定位和室外北斗系统定位功能，支持5G公网和5G专网通信功能，便携式定位终端中超宽带(UWB)和实时动态(RTK)技术的集成代表了精确位置跟踪方面的重大进步。这款UWB+RTK便携式定位终端旨在在各种环境下提供高精度、实时位置数据，满足需要精确性和移动性的行业。
二、特点
1)高精度定位：RTK定位精度可到厘米级，UWB定位精度可到亚米级。
2)UWB技术：提供高精度室内定位，精度高达10厘米，非常适合GPS信号弱或无信号的环境。
3)RTK支持：通过修正GPS信号，提高户外定位精度，达到厘米级精度。
4)便携性和便利性:重量轻且易于携带，专为动态环境中的移动使用而设计。
5)续航时间长：RTK差分定位1Hz支持18小时连续使用。
6)多系统兼容性：支持多种卫星导航系统（GPS、GLONASS、北斗等），覆盖全球。
7)耐候性：专为承受恶劣的天气条件而设计，适合户外使用。
8)多种通信方式：5G全网通，WIFI，UWB通信可选。
三、配置选择
融合定位终端型号HXZK-URT根据需求不同分为以下几种不同的配置可以选择：
说明：卫星定位精度是在空旷无遮挡环境下所得到的技术指标
四、北斗/RTK定位架构
室外差分模式系统拓扑图如下所示，差分基准站数据通过5G或者RJ45网口有线传输方式将数据传到服务器，定位终端通过5G从服务器获取差分数据完成高精度位置计算然后在将计算获得的高精度位置数据通过5G发送到服务器。
五、室内定位系统架构
室内定位部分主要由现场需要安装的UWB基站（信标），人员需要佩戴的便携式定位终端，服务器和定位系统平台组成。人员佩戴终端数据可通过5G网络传输到本地服务器或者云服务器，服务器上部署的定位引擎软件计算出终端的实时位置坐标。
六、设备佩戴方式
七、应用场景介绍
首先，说下该方案适合的应用场景，我们的融合定位方案适合在室外区域范围较大，同时又有室内空间需要精确定位的场景下使用。该方案能实现人员、车辆的室内外精确定位，室外精度可到3厘米，室内精度可到30厘米。
该方案可应用的领域有：
1，可用于油库人员定位；
2，可用于钢厂人员定位；
3，可用于露天矿山人员定位；
矿山人员定位案例
4、可用于化工厂，港口码头人员定位；
八、室内外融合定位系统架构
整个室内外融合定位系统的架构，如下图所示，整个定位系统主要由室外定位和室内定位两个部分组成，室外部分主要依靠卫星差分技术实现实时的高精度定位，室外需要建设一台差分基准站；终端由室外进入室内由于没有卫星信号，需要切换为室内基站定位，室内定位主要是无线定位基站，终端定位数据通过5G传输到服务器软件，实现对人员或者车辆的室内外精确定位功能。
应用案例，北京冬奥会运动员训练精确定位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718acce8116e7f87f2a0a5dd89b8ea80/" rel="bookmark">
			软件工程专业英语作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Translate the following passage into Chinese.
Albased Approaches for the Management of Complex Software Projects
Artificial Intelligence (AI) has a fundamental influence on all areas of economy,administration and society. Anunexpected application of AI lies in softwareengineering: for the first time, Al provides robust approaches for software developmentin order to analyze and evaluate complex software and its development processes.Repository Mining, Machine Learning, Big Data Analytics and Software Visualizationenable targeted insights and powerful predictions for software quality ， softwaredevelopment and software project management.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/718acce8116e7f87f2a0a5dd89b8ea80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a230189fa98bb0f13c79c87e02f94ec6/" rel="bookmark">
			job_queue_processes参数讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：job_queue_processes参数讲解作者：rainbow_尧 本文转自【乐沙弥的世界】，在此感谢原作者！
Oracle jobs为Oracle开发人员和数据库管理员提供了数据库层面维护的极大便利性。对于Oracle jobs在Oracle 9i之前，是由dbms_jobs来实现，而到了10g之后，多出了dbms_scheduler方式。两者同样可以添加Oracle job，只不过dbms_scheduler的功能更为强大。在使用Oracle jobs时，我们不得不关注job_queue_processes参数，用于设定job队列可以启动的进程数。本文即是围绕此展开。查看该参数命令：
show parameter job;
1、job_queue_processes参数
alter system set job_queue_processes= 0,,,1000
下面是11g reference的描述：
JOB_QUEUE_PROCESSES specifies the maximum number of job slaves per instance that can be created for the execution of DBMS_JOB jobs and Oracle Scheduler (DBMS_SCHEDULER) jobs. DBMS_JOB and Oracle Scheduler share the same job coordinator and job slaves, and they are both controlled by the JOB_QUEUE_PROCESSES parameter.
If the value of JOB_QUEUE_PROCESSES is set to 0, then DBMS_JOB jobs and Oracle Scheduler jobs will not run on the instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a230189fa98bb0f13c79c87e02f94ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4998667a8fd1f34f447b925f50f5b8a8/" rel="bookmark">
			CTF-虚拟机-QEMU-前置知识-操作流程与源码阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 总览内存PCI设备PCI配置空间前64个字节对应源码Memorry空间的BARIO空间的BAR MMIOPMIOIspci访问PCI设备配置空间中的Memory空间和IO空间MMIOPMIO QQM（qemu object model）简洁概要将 TypeInfo 注册 TypeImpl：ObjectClass的初始化：实例化 Instance(Object)准备自己写mini版QEMU吧，不然实在迷糊 吹爆这篇博客，写得巨好 总览 QEMU能够为用户进程进行CPU仿真提供环境
一个QEMU进程提供一种环境可启动一个虚拟机
KVM是在内核中运行的，让QEMU启动的虚拟机能直接在host的CPU上安全地执行guest的代码，作用为负责虚拟机的创建，虚拟内存的分配，虚拟CPU
// 第一步，获取到 KVM 句柄 kvmfd = open("/dev/kvm", O_RDWR); // 第二步，创建虚拟机，获取到虚拟机句柄。 vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0); // 第三步，为虚拟机映射内存，还有其他的 PCI，信号处理的初始化。 ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem); // 第四步，将虚拟机镜像映射到内存，相当于物理机的 boot 过程，把镜像映射到内存。 // 第五步，创建 vCPU，并为 vCPU 分配内存空间。 ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid); vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0); // 第五步，创建 vCPU 个数的线程并运行虚拟机。 ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0); // 第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。 for (;;) { ioctl(KVM_RUN) switch (exit_reason) { case KVM_EXIT_IO: /* .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4998667a8fd1f34f447b925f50f5b8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e6315543b14d7d242f5c7cce7e6378/" rel="bookmark">
			TypeScript攻略：小白变大神的实用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript攻略：小白变大神的实用指南 前言TypeScript基础**TypeScript是什么？****TypeScript与JavaScript的关系：****安装和设置开发环境：**步骤1：安装Node.js和npm步骤2：安装TypeScript步骤3：创建TypeScript文件步骤4：编写TypeScript代码步骤5：编译TypeScript代码步骤6：运行JavaScript代码 静态类型的好处减少潜在的错误提高代码智能感知优化开发者工作流程 TypeScript高级特性接口与类型别名:接口 (Interfaces):类型别名 (Type Aliases): 泛型编程泛型函数:泛型类:泛型接口: 类与继承类:继承: 工程化实践与常见框架集成（以React为例）安装React和相关类型定义:创建React组件:使用React组件: 通过Webpack进行打包:安装Webpack和相关工具:创建Webpack配置文件:修改 package.json 添加运行脚本:执行打包: 使用TypeScript进行测试安装测试库和类型定义:配置jest.config.js:创建测试文件:添加运行脚本:执行测试: TypeScript生态系统常用库和工具:a. **常用库:**b. **常用工具:** 社区和资源a. **社区:**b. **资源:** 迁移现有项目到TypeScript逐步迁移的实践a. **设置TypeScript配置文件:**b. **选择入口文件:**c. **添加类型注解:**d. **处理第三方库:**e. **逐步迭代:** 遇到的常见问题与解决方法a. **类型错误:**b. **第三方库的缺失或不完整的类型定义:**c. **构建工具配置问题:**d. **旧代码的可维护性问题:** 结语 前言 JavaScript的灵活性是其强大之处，但在大型项目中，这种自由性有时可能导致难以维护的代码。在这个快速发展的Web开发时代，我们需要更多的工具来提高代码的可读性和可维护性。而TypeScript，作为JavaScript的超集，通过引入静态类型系统，为我们提供了一个强大的工具。
TypeScript基础 TypeScript是什么？ TypeScript是一种由微软开发的编程语言，它是JavaScript的一个超集。这意味着每个有效的JavaScript代码都是有效的TypeScript代码，但TypeScript添加了一些额外的功能和语法，使得代码更易于维护和扩展。
关键特点包括：
静态类型系统： TypeScript引入了静态类型，开发者可以在编码阶段指定变量的类型。这有助于在开发过程中捕获潜在的错误，并提供更强大的代码智能感知。面向对象编程支持： TypeScript支持类、接口和模块，使得开发者可以使用更具结构化的面向对象编程风格。编译型语言： TypeScript不直接运行在浏览器中，而是需要先通过编译器将TypeScript代码转换成JavaScript代码。这个过程被称为"transpilation"（转译），将TypeScript代码转化为浏览器可以执行的JavaScript代码。 TypeScript与JavaScript的关系： 超集关系： TypeScript是JavaScript的超集，这意味着任何有效的JavaScript代码都是有效的TypeScript代码。这种关系确保现有的JavaScript项目可以无缝迁移到TypeScript。增强性： TypeScript在JavaScript的基础上添加了一些新的功能，如静态类型、接口、泛型等，提供了更强大的工具来构建大型、复杂的应用程序。逐步采纳： 开发者可以逐步采用TypeScript。在一个项目中，可以选择性地将部分JavaScript文件转换成TypeScript，从而享受到TypeScript的好处，而不需要一次性进行全面的迁移。 总体而言，TypeScript提供了一种改进JavaScript开发体验的途径，尤其在大型项目和团队协作中，它的静态类型和面向对象的特性可以提高代码的可维护性和可读性。
安装和设置开发环境： 安装和设置TypeScript的开发环境相对简单，下面是一个基本的步骤：
步骤1：安装Node.js和npm 首先，确保你的计算机上已安装了Node.js和npm（Node.js包管理器）。你可以从 Node.js官方网站 下载并安装。
步骤2：安装TypeScript 一旦安装了Node.js和npm，你可以通过以下命令安装TypeScript：
npm install -g typescript 上述命令使用了 -g 选项，表示全局安装，这样你就可以在命令行中使用 tsc 命令。
步骤3：创建TypeScript文件 使用你喜欢的文本编辑器（比如Visual Studio Code、Sublime Text、Atom等），创建一个新的文件，将其保存为 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e6315543b14d7d242f5c7cce7e6378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27db146ab0662dba5dc1ba230d3379fc/" rel="bookmark">
			深入探讨网络抓取：如何使用 Scala 和 Dispatch 获取 LinkedIn 图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络抓取是一种从互联网上获取数据的技术，它可以用于各种目的，例如数据分析、信息检索、竞争情报等。网络抓取的过程通常包括以下几个步骤：
发送 HTTP 请求到目标网站解析响应的 HTML 文档提取所需的数据存储或处理数据 在本文中，我们将使用 Scala 语言和 Dispatch 库来实现一个简单的网络抓取程序，该程序的功能是从 LinkedIn 网站上获取用户的头像图片，并保存到本地。我们将介绍如何使用 Dispatch 发送 HTTP 请求，如何使用代理 IP 技术绕过反爬虫机制，以及如何使用 Jsoup 库解析 HTML 文档并提取图片链接。
使用 Dispatch 发送 HTTP 请求 Dispatch 是一个基于 Scala 的 HTTP 客户端库，它提供了一种简洁而强大的方式来构造和执行 HTTP 请求。Dispatch 的核心是一个名为 Http 的对象，它可以接受一个名为 Request 的对象作为参数，并返回一个名为 Response 的对象作为结果。Request 对象可以使用 url 方法来创建，该方法接受一个字符串作为参数，表示请求的 URL。Request 对象还可以使用各种方法来设置请求的属性，例如 GET、POST、PUT、DELETE 等 HTTP 方法，setHeader、addHeader、setContentType 等 HTTP 头部，setBody、setBodyEncoding、setBodyCharset 等 HTTP 正文等。Response 对象可以使用 getStatusCode、getStatusText、getHeaders、getContentType、getCharset、getResponseBody 等方法来获取响应的属性，例如状态码、状态文本、头部、内容类型、字符集、正文等。
为了从 LinkedIn 网站上获取用户的头像图片，我们需要发送一个 GET 请求到用户的个人主页，例如 https://www.linkedin.com/in/username，其中 username 是用户的用户名。我们可以使用以下代码来创建一个 Request 对象：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27db146ab0662dba5dc1ba230d3379fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e23ad90321ce6df04149073a89a96c/" rel="bookmark">
			Vue3的watch函数中，第三个参数配置对象详细分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue 3的watch函数中，第三个参数是一个配置对象，用于定义如何执行watch函数。下面是几个常用的配置项的讲解，并附上代码示例：
1、immediate immediate：当设置为true时，会在初始渲染时立即执行watch函数。默认为false。
// 示例代码 watch( 'count', (newCount, oldCount) =&gt; { console.log(`new count: ${newCount}, old count: ${oldCount}`) }, { immediate: true } ) 2、deep deep：当设置为true时，会深度遍历监听对象的所有属性。默认为false。
// 示例代码 const state = reactive({ obj: { a: 1, b: 2 }, arr: [1, 2, 3] }) watch( () =&gt; state.obj, (newObj, oldObj) =&gt; { console.log(`new obj: ${JSON.stringify(newObj)}, old obj: ${JSON.stringify(oldObj)}`) }, { deep: true } ) 3、flush 在Vue3中，watch函数的第三个参数是可选的配置项，其中一个配置项是flush，它控制何时运行watch的回调函数。flush有三个选项："pre"、"post"和"sync"。 3.1、pre 在侦听器的回调函数运行之前立即运行更新函数，即在dom渲染完毕前调用回调函数（此时获取不到DOM！）。这是默认值。
watch( () =&gt; count.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e23ad90321ce6df04149073a89a96c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d719df53a0881f4b8655da8409f184/" rel="bookmark">
			go语言使用代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Go语言中，使用HTTP代码示例可以帮助我们发送HTTP请求并处理HTTP响应。下面是一个简单的示例，演示了如何使用Go语言发送HTTP GET请求并处理响应。
go复制代码
package main import ( "fmt" "io/ioutil" "net/http" ) func main() { // 创建一个HTTP客户端 client := &amp;http.Client{} // 创建一个GET请求 req, err := http.NewRequest("GET", "https://api.example.com/data", nil) if err != nil { fmt.Println("创建请求失败:", err) return } // 发送请求并获取响应 resp, err := client.Do(req) if err != nil { fmt.Println("发送请求失败:", err) return } defer resp.Body.Close() // 读取响应内容 body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println("读取响应失败:", err) return } // 将响应内容转换为字符串并打印输出 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d719df53a0881f4b8655da8409f184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b634aa8971450151a5c8e9dacc8e0042/" rel="bookmark">
			JWT令牌的获取与过滤器Filter的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JWT，全称JSON Web Token（JSON Web令牌），是一个开放标准 (rfc7519)。它定义了一种紧凑的、自包含的方式，以JSON对象的形式安全地在各方之间传输信息。这种信息可以被验证和信任，因为它是通过数字签名实现的。
JWT可以使用HMAC算法或使用RSA的公钥/私钥对进行签名，防止被篡改。JWT基于json，非常方便解析，可以在令牌中自定义丰富的内容，易扩展。通过非对称加密算法及数字签名技术，JWT防止篡改，安
全性高。
//生成JWT @Test public void testGenJwt(){ Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;(); claims.put("id", 1); claims.put("name", "tom"); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, "monian") //签名算法 .setClaims(claims) //自定义内容(载荷) .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) //设置有效期为1h .compact(); System.out.println(jwt); } //解析令牌 @Test public void testParseJwt(){ Claims claims = Jwts.parser() .setSigningKey("monian") .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTcwMTUxMTAwMH0.3ejLF6AimqpzbmTmN6WPcJvxoXAFPT9c5oNbk-0U5o4") .getBody(); System.out.println(claims); } } 控制台：
eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoidG9tIiwiaWQiOjEsImV4cCI6MTcwMTY2Mzc0NX0.HGgjyiW398CeKGosnOXGxd68KF3nJ_R8LYRrkG8-Ih8 在JWT官网解析可得：
通过测试类解析令牌可得： Demo测试：通过JWT令牌判断用户是否登录，否则不能访问相关的数据： @Slf4j @WebFilter(urlPatterns = "/*") public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b634aa8971450151a5c8e9dacc8e0042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347b21cf7ece6488eec1cf871c07e089/" rel="bookmark">
			流批一体历史背景及基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、历史背景1.BI系统2.传统大数据架构3.流式架构4.Lambda架构5.Kappa架构 二、流批一体与数据架构的关系数据分析型应用数据管道型应用 三、流与批的桥梁Dataflow模型四、Dataflow模型的本质一个基本点两个时间域三个子模型1.窗口模型2.触发器模型3. 增量计算模型 四个分析维度 五、举例固定窗口，批处理固定窗口，流处理，多种触发方式 一、历史背景 1.BI系统 BI（Business Intelligence，商业智能）的概念很早就有了。到了上世纪九十年代，BI系统迎来了它的第一个辉煌时期，Gartner将各种类型的类BI系统全部统称为BI，BI产品也基本确定为了是一套集数据清洗、数据分析、数据挖掘、报表展示等功能于一体的完整解决方案，数据仓库也基于此建立。从此BI系统一统江湖，江湖上再也没了DSS（Decision Support System, 决策支持系统）、EIS
（Executive Information System, 主管信息系统）的名字。
BI系统的核心是Cube，它是一个业务模型抽象，在Cube上可以上钻、下钻、切片，为了更方便多维分析，还配套了MDX查询语言。当然，大多数BI系统都构建在关系型数据库之上，或者说很多BI系统本就是商业关系型数据库的配套产品，因此也都是支持SQL语言的。在计算和存储上可能类似于开源框架Apache Kylin。
初代BI系统没落的原因主要是：
底层构建在传统关系型数据库之上，因为存在数据一致性约束等问题，支持不了大数据。（这也暗合了网传了很多年的阿里技术规范中提到的一条——不要设置外键，要通过其他技术手段保证数据一致性。）不支持非结构化数据。 2.传统大数据架构 为了解决上述问题，一些公司开始研发分布式的计算引擎和分布式的存储平台。其中最成功、最知名的便是Google研发的分布式文件系统与MapReduce计算引擎，后来这套技术被开源重写为了Hadoop体系的多个项目，其生态圈也不断扩大。
在Miravia的技术选型中，通常业务数据通过binlog同步到TT，或者流量日志直接上报到日志服务器，再同步到TT。TT定期将一个时间区间内的数据同步到ODPS，ODPS再通过每日调度的任务对这些数据进行处理，最终落到ADS层的表。结果表的数据再同步到Holo或Lindorm等介质中，供消费方使用。因此单看这整个流程，实际上就是典型的传统大数据架构的一种实现。但需要注意的是，该架构并没有对输入数据有结构化的要求，也没有规定ETL过程使用的工具和编程语言。
下图是一个典型的传统大数据架构
3.流式架构 虽然传统大数据架构在技术选型上与BI系统比已经算是脱胎换骨，但其精神还是一脉相承。流式架构干脆扔掉一整套离线的数据采集、数据同步和ETL工作，直接让流式计算引擎消费业务数据库产生的增量数据，并直接输出给消费方，以此提供实时的计算结果。
而早期的技术储备明显不足以同时高质量保证实时性和结果的准确性，因此只被用在了极少数对结果实时性十分敏感却对准确性要求不高的场景中。随着技术的进步和业务复杂度的提高，这种架构也基本销声匿迹了。
下图是流式架构的典型代表：
4.Lambda架构 Lambda架构的逻辑是，流任务与批任务读取相同的数据源，实时计算结果由流任务产出；批任务通常按天执行，计算T-1的数据，并写入到结果表中。最终数据应用根据自己的需要对两个结果表的结果进行合并。其核心思路是：用流任务保证结果的实时性，同时用批任务保证结果的最终一致性。
有一位叫做Nathan Marz的大佬提出了Lambda架构。先看Lambda架构的示意图：
但Lambda架构有几个显而易见的缺点：
需要开发、维护两套系统，成本太大。两套系统难以保证计算口径的一致。甚至不同计算引擎提供的计算语义完全不同。 5.Kappa架构 在流处理技术不成熟的时期，主要问题之一就是吞吐量上不去。随着Kafka等大数据消息队列的出现，吞吐量不再是瓶颈。Kappa架构的主要贡献之一就是引入了分布式消息队列。如下图所示：
与Lambda架构不通，Kappa架构只保留了流处理层，完全舍弃了批处理层。让其中一个流处理层正常运行，数据应用读取它的输出；当数据出现错误，或是业务逻辑发生变更时，启动另一个流处理层，利用消息队列的重播机制，重新消费先前的数据并输出到另一个结果表中，当确定可以替换线上表时，完成替换。当然，在实际生产中这个过程会复杂得多。而且受限于消息队列数据生命周期的限制，这种架构在生产中被应用得较少。
二、流批一体与数据架构的关系 流批一体听起来很简单，但内涵却十分复杂。它包含了计算语义、编程模型、API、调度、执行、shuffle等各个方面的统一，不过对于我们数据开发的同学来说，我认为流批一体最终想要达到的效果可以这样描述：给定确定的数据源（可以是物理的也可以是逻辑上的），编写一套代码（Java代码或SQL），执行引擎能够根据需要（例如根据用户配置“STREAMING/BATCH”或自动识别）将代码转换为流任务（增量地读取、流式地处理）或批任务（全量地读取、批式地处理），并输出相同的结果。
数据分析型应用 流批一体与Lambda架构结合得最为自然。如下图所示：
这里引入了消息队列，算是Jay Kreps在提出Kappa架构时给我们提供的改进思路。因为流任务和批任务对输入的要求是不一样的，前者一般读取的都是类似Kafka这样的消息流，后者则读取的是数据库在某一刻的全量快照，所以我们暂且认为两个任务需要用不同的连接器读取不同的数据源。
为了保证输入统一，我们可以让流任务直接读取消息队列中的数据，这样它就在一刻不停地读取业务上的增量数据；在离线侧，我们周期性地将消息队列中的数据落盘，然后每日单独处理当天的增量数据，由此批任务也达成了周期性处理增量数据的效果。理想情况下，当批任务把T-1的数据输出时，结果应与流任务先前输出的T-1的结果相同。
这就是流批一体在数据分析型应用中的典型案例，它是Lambda架构的一种高级实现，解决了原Lambda架构中需要开发两套代码、维护两套系统、计算逻辑口径不一致的问题。Dataphin提供给大家的解决方案就是针对这种应用而来的。
不过要特别注意的是，计算逻辑口径一致不是因为你使用了相同的代码，而是基于相同的代码，计算引擎内部将其翻译成批任务和流任务时在语义、编程模型等方面达到了统一。如果计算引擎内部没有做到这一点，即便写了相同的代码也是无济于事的。
数据管道型应用 除了数据分析型应用，还有一类应用，比如数据同步，这部分工作其实也可以通过计算引擎来实现，流批一体在这其中还能发挥大作用。这类应用可以叫做数据管道型应用。
比如需求是将一个线上数据库中的数据迁移到另一个数据库中，在同步的过程中线上数据库仍然会继续发生增删改查等业务操作。以往的方式往往是先通过一个离线同步工具同步全量数据，再通过另一个增量同步工具不断地同步新增数据。在这个过程中选择从哪一时刻开始增量同步是一大难点。如果在同步的过程中需要对数据做一些清洗或转换，则难度又大了一截。
而通过计算引擎的流批一体能力和对应的connector，则可以解决上述问题。我们可以直接通过写SQL的方式声明数据转换的逻辑，配合connector的能力，计算引擎会先批量读取数据，然后在某一时刻自动切换成流任务增量读取后续数据，而计算引擎内部流批一体的能力保证了语义的相同。
三、流与批的桥梁Dataflow模型 流与批的本质区别是什么？两者的本质在于，批处理中数据是完整的、有界的，是可以将其作为一个整体来进行全局处理的，而流处理中数据是不完整的、无界的，在此情况下何时对数据进行聚合计算并将结果发送到下游就成了十分复杂的问题，因为可能存在数据迟到或乱序的情况。
Google于2015年发表了一篇在流式处理领域具有指导性意义的论文——《The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale Unbounded, Out-of-Order Data Processing》，该论文全面系统地阐述了流与批的本质区别，并提出了Dataflow模型作为流与批之间的桥梁（该模型中批处理是流处理的一种特例）。通过对该模型的实现，计算引擎可以在正确性、延迟、成本之间进行调整，无缝地在不同的应用场景间进行切换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347b21cf7ece6488eec1cf871c07e089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845ac61b6bf1a242a7e904cdde697c65/" rel="bookmark">
			yolov5 安全帽检测 全流程 全资源 技术交流（相互学习）！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5 做安全帽检测示例 （全流程、全资源） 文章目录 yolov5 做安全帽检测示例 （全流程、全资源）前言一、追根溯源：目标检测框架 yolov5二、言归正传：软硬件环境搭建我的硬件：软件环境 三、闪转腾挪：闭坑关键点四、摩拳擦掌：开始训练---验证---检测数据集的使用 写在最后： 前言 在业余时间看了很多关于手把手教你搭建yolov5目标识别框架的博主文章，大多涉及的细节不够多，很多内容一笔带过，不够开源。写这篇技术总结性质的文章，主要是1、尽可能详尽，指导闭坑，完全开源。2、技术交流，取长补短，相互学习。
**项目背景：**用yolov5框架来实时检测安全帽佩戴状态。
数据集的获取及标定：1，直接可以在百度飞浆网站上获取相应的数据集（数据集只有两个标签分类：person和hat（带安全帽的），已经标定好，大约7500张，标定的数据集是json格式的，需要进行转化------txt格式。网上很多数据集只有json格式和图片，有这两个就够了，不要想要什么自行车，本文附带了json格式转化成txt格式的代码。欢迎品尝！！！）
硬件：不建议使用cpu来训练大量数据集，太慢了，想出验证结果或者优化参数，CPU不适合做！！！CPU不适合做！！！CPU不适合做！！！别问为什么，因为我已经试过了。可以在百度飞浆上用免费算力进行训练。但百度飞浆的维护又不太好，兼容性太差。感兴趣可以试试。有条件的，最好自己搭建硬件平台。
一、追根溯源：目标检测框架 yolov5 链接: 这是一位博主写的目标检测算法演变及比较，很不错！！！
二、言归正传：软硬件环境搭建 我的硬件： 处理器 12th Gen Intel® Core™ i9-12900K 3.20 GHz
机带 RAM 32.0 GB (31.8 GB 可用)
设备 ID BEE4439A-3A46-43A3-8657-B9F8873A1A5D
产品 ID 00331-10000-00001-AA112
系统类型 64 位操作系统, 基于 x64 的处理器
显卡：英伟达3060
注意程序的版本号！我们使用GPU进行数据集的训练！
软件环境 链接: 软件主要是cuda—cudnn—anaconda—pycharm环境及版本的相互匹配！！！
链接: 快速下载cuda—注意和你的驱动版本匹配
这个链接可以指导你完成cuda—cudnn 的安装。我在这里不详细讲了，很多博主都写了相关文章，很不错。但是！！！！！
他们没有将如何闭坑，示例：
这是cuda的安装好的运行结果。
配置完成后，我们可以验证是否配置成功，主要使用CUDA内置的deviceQuery.exe 和 bandwidthTest.exe：
首先win+R启动cmd，cd到安装目录下的 …\extras\demo_suite,然后分别执行bandwidthTest.exe和deviceQuery.exe（进到目录后需要直接输“bandwidthTest.exe”和“deviceQuery.exe”）,得到下图:
截止到这里，软件环境搭建好了一半，然后安装软件配套环境anaconda和pycharm，他们二者也得搭配起来使用，不然后面涉及到YOLOV5相关环境，很是麻烦，容易出现版本调整，频繁报错的情况。
我这里的anaconda版本是：
Anaconda3-2023.03-0-Windows-x86_64
pycharm版本是：PyCharm 2021.1.3 x64
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845ac61b6bf1a242a7e904cdde697c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd29e0274fca84d2b0141e9de94e826/" rel="bookmark">
			【ARM Cortex-M 系列 1 -- Cortex-M0, M3, M4, M7, M33, M35P 差异】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请阅读【ARM Coresight | AMBA BUS| Armv8/v9 | GCC 专栏导读】
文章目录 Cortex-M 系列介绍Cortex-M0/M0+ 介绍Cortex-M3/M4 介绍Cortex-M7 介绍Cotex-M33 介绍Cortex-M35P 下篇文章：ARM Cortex-M 系列 2 – CPU 之 Cortex-M7 介绍
Cortex-M 系列介绍 Cortex-M0/M0+ 介绍 Cortex-M0 是 ARM 公司推出的一款微控制器（MCU）核心。这个核心是基于 ARMv6-M 架构设计的，只支持 56 条指令的小指令集，大部分指令是 16 位指令, 是 ARM Cortex-M 系列中的入门级产品。
Cortex-M0 的设计目标是提供一种低成本、低功耗的解决方案，适用于简单的微控制器应用。它的特点包括：
小型和低功耗：Cortex-M0 的硬件设计非常紧凑，消耗的功率也非常低，这使得它非常适合在功率和空间受限的应用中使用。
简单的指令集：Cortex-M0 使用的是基于 Thumb 指令集的 ARMv6-M 指令集，该指令集比 ARM 的其他处理器系列使用的指令集更为简单，这使得程序员可以更容易地编写和优化代码。
完全静态设计：Cortex-M0 的所有操作都可以在任何时钟频率下运行，这使得它可以很好地适应各种不同的系统需求和应用。
Cortex-M3/M4 介绍 Cortex-M3和Cortex-M4都是ARM公司推出的微控制器（MCU）核心，它们均基于ARMv7-M架构，具有32位处理能力，并专为低功耗设备和嵌入式应用设计。
Cortex-M3：Cortex-M3是Cortex-M系列中的一款产品，相比Cortex-M0，它在性能和功能上有所提升。Cortex-M3包括了一个高性能的32位CPU，支持高效的数据处理和低延迟中断处理。此外，它还包括了许多高级功能，如嵌套向量中断控制器（NVIC）、微控制器调试接口（Micro Trace Buffer）等。这些功能使Cortex-M3在高性能嵌入式系统中得到了广泛应用。
Cortex-M4：Cortex-M4在Cortex-M3的基础上进一步增强了数字信号处理（DSP）和浮点运算能力，一系列单周期 MAC 指令（Cortex-M3 只支持有限条MAC 指令，并且是多周期执行的）。Cortex-M4包含了一个32位CPU，并增加了专门用于DSP和浮点运算的硬件支持。这使得Cortex-M4特别适合于需要进行复杂数字处理的嵌入式应用，如音频处理、电机控制等。
两者主要的区别在于，Cortex-M4相比于Cortex-M3，增加了DSP（数字信号处理）指令和一个硬件浮点单元（FPU，可选），使其在处理数字信号方面更加高效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd29e0274fca84d2b0141e9de94e826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1940b4da3dcf047aefa2afa3c405f61/" rel="bookmark">
			STM32移植使用mbedtls-2.24.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32移植使用mbedtls-2.24.0 目录 STM32移植使用mbedtls-2.24.0（1）关于PolarSSL（2）mbedtls移植（3）移植测试 （1）关于PolarSSL mbed TLS（以前称为PolarSSL）是TLS和SSL协议的实现，并且需要相应的加密算法和支持代码。这是双重许可与Apache许可证 2.0版（与GPLv2许可也可）。
核心SSL库用C编程语言编写，并实现SSL模块，基本加密功能并提供各种实用功能。与OpenSSL和TLS的其他实现不同，mbed TLS设计为适合小型嵌入式设备，最小完整的TLS堆栈需要60KB的程序空间和64KB的RAM。它也是高度模块化的：每个组件，如加密函数，可以独立于框架的其余部分使用。因为mbed TLS是用C编程语言编写的，没有外部依赖，现在叫MbedTSL，PolarSSL源码，也许是最小巧的ssl代码库。高效、便于移植和集成。尤其适合嵌入式应用。
本章就基于STM32移植mbedtls-2.24.0版本进行测试与使用！
mbedtls下载地址：https://github.com/ARMmbed/mbedtls
本章工程代码下载地址：https://github.com/wowyyy/HAL_STM32_MBEDTLS_DEMO.git
注意：因为本章节只是用了加解密的API，没有使用网络进行SSL认证操作，如果要使用mbedtls的SSL认证，最低的硬件环境最低需要60K的FLASH以及64K的SRAM(内存)，如果你使用的比较低端的STM32，那么无解，没法用embedtls。。。
（2）mbedtls移植 首先使用STM32CubeMX建立裸机工程，我使用的是STM32F103RB，配置了串口一当作信息输出的端口，这里注意，mbedtls所使用的栈空间是比较大的，所以在STM32CubeMX输出工程的时候将栈空间调大，如下图：
下载解压mbedtls源码目录如下：
而我们需要的仅仅是configs(配置头文件)、include(头文件)、library(源码)。
configs，该文件夹内的是配置头文件，可以根据不同需求进行选择，例如我们本次是在嵌入式系统上使用，资源有限，所以就选择config-mini-tls1_1.h这个配置文件，复制该文件内的内容替换mbedtls的默认配置头文件mbedtls/config.h即可。include，所有头文件library，所有源代码 首先在STM32 工程目录下建立文件夹mbedtls，并将mbedtls源码目录下的include和library两个文件夹复制过来，复制config-mini-tls1_1.h文件中的内容替换include/config.h。(注：include/config.h文件是只读的，需要先修改权限为读写)。
打开keil工程将源码添加进来：
添加头文件包含：
修改include/config.h配置文件：
注释掉宏定义MBEDTLS_HAVE_TIME，因为我们目前没有用到时间相关的注释掉宏定义MBEDTLS_NET_C，因为没有用到网络注释掉宏定义MBEDTLS_FS_IO，这是带系统时候需要用到的标准系统调用IO，例如linux下的系统调用函数read、write等，裸机我们没有用到添加一个宏定义MBEDTLS_NO_PLATFORM_ENTROPY，单片机无系统所以需要添加该宏。 然后编译工程即可~！
（3）移植测试 将printf函数重定向到串口一输出：
/// 重定向printf函数到串口一 int fputc(int ch, FILE* fp) { while (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_TXE) != SET); huart1.Instance-&gt;DR = (uint8_t)(ch &amp; 0XFF); return ch; } 下面我们开始编写代码测试，测试两个，一个是base64编码的，另一个是AES加解密的，
需要添加头文件：
#include "mbedtls/config.h" #include "mbedtls/aes.h" #include "mbedtls/base64.h" base64编解码测试代码：
void mbedtls_base64_demo(void) { int i = 0; // 原始数据 uint8_t plaintext[16] = {'A','B','C','D','E','F','G','H','I','J', 'K', 'L', 'M', 'N', 'O', 'P'}; // base64编码和解码输出数据的长度 size_t enclen = 0, declen = 0; // 存放base64编码输出 uint8_t encode[32]; // 存放base64解码输出 uint8_t decode[32]; // 编码 mbedtls_base64_encode(encode, sizeof(encode), &amp;enclen, plaintext, sizeof(plaintext)); // 解码 mbedtls_base64_decode(decode, sizeof(decode), &amp;declen, encode, enclen); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1940b4da3dcf047aefa2afa3c405f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5285523af411a449ab181413c0e81ee/" rel="bookmark">
			python每日一题——22反转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
示例 1：
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：
输入：head = [1,2]
输出：[2,1]
示例 3：
输入：head = []
输出：[]
答案 题目要求反转链表，这是一个常见的链表操作。我们可以定义一个指针，如prev，用来记录反转前的节点，然后遍历链表，将当前节点的下一个节点指向prev，最后将prev更新为当前节点。
链表反转的Python代码实现如下：
class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -&gt; ListNode: # 定义反转前的节点 prev = None # 遍历链表 while head: # 记录当前节点的下一个节点 temp = head.next # 将当前节点的下一个节点指向反转前的节点 head.next = prev # 更新反转前的节点为当前节点 prev = head # 更新当前节点为下一个节点 head = temp return prev 代码注释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5285523af411a449ab181413c0e81ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d060440d5b318039c3b11172b4a099/" rel="bookmark">
			基于Opencv的缺陷检测任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据及代码见文末 1.任务需求和环境配置 任务需求：使用opencv检测出手套上的缺陷并且进行计数
环境配置:pip install opencv-python
2.整体流程 首先，我们需要定义几个参数。
图像大小，原图像比较大，首先将图像resize一下再做后续处理图像阈值处理的相应阈值反转阈值的参数设置边缘检测的阈值轮廓设置及展示相关的字体颜色 ################################ # --- Variables --- ################################ IMAGE_SIZE = (500, 500) # -- Threshold Details -- # *THRESHOLD_VALUE:需要根据数据来实验一下 THRESHOLD_VALUE = 130 MAX_VALUE = 255 # -- Invert Threshold Details -- INV_THRESHOLD_VALUE = 50 INV_MAX_VALUE = 255 # -- Canny Details -- THRESHOLD1 = 100 THRESHOLD2 = 70 # --contour properties-- CON_COLOR = (0, 0, 255) CON_THICKNESS = 1 # -- 字体颜色-- WHITE = (255, 255, 255) BLACK = (0, 0, 0) GREEN = (0, 255, 0) RED = (0, 0, 255) STACK_IMG_SIZE = (200, 200) 整体流程如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d060440d5b318039c3b11172b4a099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e901c8952dbe4b562b858c67a42567/" rel="bookmark">
			三维重建——NeuralRecon项目源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码链接见文末 首先，需要指明的是NeuralRecon项目不支持windows,主要是使用到的例如torchsprase等不支持windows,您也可以在网上查找相应的替代方法。
1.数据与环境配置 ScanNet数据的获取首先需要向作者发送邮件，作者会回复一个下载的脚本，在提供的代码中，提供了这个下载的脚本data.py。
执行这个脚本文件即可下载，但是需要注意两个参数。-o是指定下载后存放的路径，--preprocessed_frames原始数据集太大，有1.2T，指定后，保留场景个数，但是对场景的图片进行采样，下载一个较小的数据集版本，供跑项目使用。
其中，每个文件夹的数据包含以下部分： 代码中提供的train_demo取了四个场景的很小部分，能够供跑通代码使用。
而all_tsdf_9中是对应生成的tsdf标签
2.生成TSDF标签 TSDF标签的生成主要使用NeuralRecon/NeuralRecon-master/tools/tsdf_fusion下的文件，
在这个过程可能会遇到很多路径上的问题，报错方面本博客可能不能涵盖全部，仅仅只展示我本人所遇到的问题。
首先是generate_gt.py文件中的--data_path配置参数，修改为自己下载数据集的路径。
3.环境的配置 进入目录后:使用pip install -r requirements.txt即可配置环境，其中pycuda可能会安装失败
pycuda的安装 pycuda直接使用pip install会报错,建议采用离线安装，参考:
安装pycuda及问题解决_卷中卷的博客-CSDN博客_pycuda安装
在运行过程中，pycuda可能会报错，因为找不到cuda，这时可以进入cmd看看nvcc -v指令是否能够运行，如果不能运行，可能是没有装cuda和没有指定cuda环境变量，可能需要重装cuda。如果能够运行。解决方法参考:uwsgi+pycuda启动报错 pytools.prefork.ExecError: error invoking nvcc --version‘:_qq591840685的博客-CSDN博客
如果只想跑跑代码，进行debug操作，不想重装cuda的话或在这方面耗费过多的时间，源码中提供了已经生成的少量数据的tsdf标签，能够供跑代码使用 此外，还需要安装torchsparse,参考github:GitHub - mit-han-lab/torchsparse: [MLSys'22] TorchSparse: Efficient Point Cloud Inference Engine 使用
sudo apt-get install libsparsehash-dev 或：
pip install --upgrade git+https://github.com/mit-han-lab/torchsparse.git@v1.4.0 进行安装
4.demo 源码中提供的demo文件可以指定预训练模型进行运行，但是设备仅限制于IPhone和MAC。详见： NeuralRecon/DEMO.md at master · zju3dv/NeuralRecon · GitHub
5.训练 训练可以执行train.sh，也可以在main.py配置参数--cfg ./config/train.yaml进行运行，train.yaml为训练配置文件，路径需要自己指定一下:
6.网络结构 （1）backbone得到特征图 在算法中，通过9张图片重构一个片段，因此，输入中每个batch包含一个片段（9张图片）,并对每张图片经过backbone进行特征提取，得到特征图。backbone作者采用的是MNASNet，也可以替换为其他的Backbone。
（2）三维重建模块 整个网络采用由粗到细的网络结构，即首先重构整体框架，然后再重构局部细节。在第一个阶段重构的体素间隔为4，第二个阶段间隔为2，最后一个阶段间隔为1。
第一阶段 在第一个阶段，需要对体素进行初始化，得到体素的索引，后续阶段可由上一阶段进行上采样。初始化过程即以间隔为4初始化网格，代码如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e901c8952dbe4b562b858c67a42567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148d9d53114c16243b191ceaa75f6eea/" rel="bookmark">
			张正友相机标定（全流程，含畸变，matlab源代码解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		张正友标定的具体原理很多文章已经介绍，这里主要结合源代码对其中的基本原理及本人遇到的问题进行介绍。（仅介绍基本原理供本人复习，同时方便他人，如有问题，请及时指正勿喷）
1. 标定基本思路介绍 相机标定，即获取其内参、外参、畸变系数（内参与外参及相机成像模型的解释可以参考SLAM入门之视觉里程计）。
具体可以描述为
s m − = K [ R T ] M s\overset{-}{\mathop{m}}\,=K[\begin{matrix} R &amp; T \\ \end{matrix}]M sm−=K[R​T​]M
其中s为世界坐标系到图像坐标系的尺度因子，K为内参矩阵，具体为
K = [ f x 0 c 1 0 f y c 2 0 0 1 ] K=\left[ \begin{matrix} {{f}_{x}} &amp; 0 &amp; {{c}_{1}} \\ 0 &amp; {{f}_{y}} &amp; {{c}_{2}} \\ 0 &amp; 0 &amp; 1 \\ \end{matrix} \right] K= ​fx​00​0fy​0​c1​c2​1​ ​
[R T]为旋转矩阵与平移向量，M为三维坐标点。
张正友标定方法的核心即是采用平面标定板，从而可以方便的将标定点的真值Z置为0，以此方便计算。
具体流程主要为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148d9d53114c16243b191ceaa75f6eea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2aeea98ab4ed24900eb7d7d4512968e/" rel="bookmark">
			开发工具篇第三讲：你连maven都不懂面试官怎么敢要你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java开发中，常用构建工具ant、maven和gradle, 其中maven相对主流。本文是开发工具篇第三讲：Maven 从入门到实战
文章目录 1、什么是Maven？1.1、Maven的目录结构1.2、如何修改默认的目录配置 2、Maven能为我们解决什么问题？3、说说Maven有什么优缺点？4、什么是Maven的坐标？4.1、定义 GAV 遵从以下规则4.2、二方库版本号命名方式：主版本号.次版本号.修订号4.3、线上应用不要依赖 SNAPSHOT 版本（安全包除外） ；正式发布的类库必须先去中央仓库进行查证，使 RELEASE 版本号有延续性，且版本号不允许覆盖升级。 5、讲一下Maven的生命周期？5.1、Maven的默认构建生命周期：从我们的项目构建，一直到项目发布的这个过程5.2、maven对项目默认生命周期的抽象5.3、Maven各生命阶段行为绑定5.4、如何查看Maven各个生命周期阶段和插件的绑定情况 6、说说你熟悉哪些Maven命令？7、使用二方库的注意事项？8、说说Maven的依赖原则？8.1、依赖路径最短优先原则8.2、pom文件声明顺序优先原则8.3、覆写优先原则 问题1：如何解决依赖传递引起的版本冲突？9、说说Maven依赖的解析机制？10、如何部署第三方JAR包？11、说说Maven插件的解析机制11.1、如何自定义maven插件？11.2、项目中Run Package命令 12、修改maven版本号的常见方法（非常实用，推荐使用）13、工具详解 - Maven私有仓库Nexus13.1、Nexus是什么13.2、Nexus安装13.3、Nexus功能介绍13.4、Nexus配置和使用13.5、Nexus上传第三方jar包 问题1：禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。问题2：底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。问题3：所有 pom 文件中的依赖声明放在`&lt;dependencies&gt;`语句块中，所有版本仲裁放在`&lt;dependencyManagement&gt;` 语句块中。问题4：maven报错，父级 'Unknown:Unknown:Unknown' 有问题问题5：maven下载资源时，选择的是错误的域名，导致下载超时问题6：maven报The POM for com. is invalid, transitive dependencies (if any) will not be available问题解决 1、什么是Maven？ Maven是一款服务于Java平台的自动化构建工具。
构建：以”Java源文件“、”框架配置文件“、”JSP“、”HTML“、”图片“等资源为”原材料“，去“生产”一个可以运行的项目的过程。演化过程：Make-&gt; Ant -&gt;Maven -&gt;Gradle编译：java源文件-&gt;编译-&gt;Class字节码文件-&gt;交给JVM去执行部署：一个项目最终运行的并不是动态Web工程本身，而是这个动态Web工程“编译的结果”搭建：
maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统和用来运行定义在生命周期阶段中插件目标的逻辑。当使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自于一组共享的（或自定义的）插件。
1.1、Maven的目录结构 目录的划分是根据需要来的，每个目录有其特定的功能。目录本质上就是一个文件或文件夹路径而已
1.2、如何修改默认的目录配置 在maven项目工程对应project的 pom.xml中，在&lt;project&gt;--&gt;&lt;build&gt;节点下，你可以指定自己的目录路径信息：
&lt;build&gt; &lt;!-- 目录信息维护,用户可以指定自己的目录路径 --&gt; &lt;sourceDirectory&gt;E:\intellis\maven-principle\phase-echo\src\main\java&lt;/sourceDirectory&gt; &lt;scriptSourceDirectory&gt;E:\intellis\maven-principle\phase-echo\src\main\scripts&lt;/scriptSourceDirectory&gt; &lt;testSourceDirectory&gt;E:\intellis\maven-principle\phase-echo\src\test\java&lt;/testSourceDirectory&gt; &lt;outputDirectory&gt;E:\intellis\maven-principle\phase-echo\target\classes&lt;/outputDirectory&gt; &lt;testOutputDirectory&gt;E:\intellis\maven-principle\phase-echo\target\test-classes&lt;/testOutputDirectory&gt; &lt;!-- 注意，对resource而言，可以有很多个resource路径的配置，你只需要指定对应的路径是resource即可 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;E:\intellis\maven-principle\phase-echo\src\main\resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2aeea98ab4ed24900eb7d7d4512968e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82d5724f3ed82973ef3fb24ddf11bf7/" rel="bookmark">
			软件理论——演进式架构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 市场环境急速变化，业务高速发展，架构设计也要不断演进，以适应业务需要；随着企业规模的壮大，架构设计的腐化无法避免，只能在演进中持续进化；架构可以在不破坏原有架构的基础上增量式变化 所以人们提出一种软件开发的方法——演进式架构设计。
二、理论 演进式设计的基本原则包括：
1. 恰到好处的设计：根据当前需求进行必要的设计，但不必过度设计。
2. 逐渐迭代：在项目的不同阶段，逐步改进设计。
3. 识别和重构疏漏：在迭代过程中识别和重构设计中的疏漏或错误。
通过演进式设计，开发人员可以更快地响应变化的需求，同时也可以更好地控制开发成本。它能够减少设计上的错误，提高软件质量和可维护性。
与传统的瀑布式设计方法相比，演进式设计更加灵活和可适应。在瀑布式设计中，设计通常是在项目的早期阶段完成的，并且需要经过大量的计划和准备。但是，在演进式设计中，设计和开发是相互交织的，随着需求的变化，设计也随之变化。
参考：
演进式设计简介及原则_跨专业测试的博客-CSDN博客
演进式架构从不缺设计方法，最大的阻力在于「人」 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef32a3759a23e755a350ef52002102a/" rel="bookmark">
			力扣572：另一棵树的子树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣572：另一棵树的子树
给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
示例 1：
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
示例 2：
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
提示：
root 树上的节点数量范围是 [1, 2000]
subRoot 树上的节点数量范围是 [1, 1000]
-104 &lt;= root.val &lt;= 104
-104 &lt;= subRoot.val &lt;= 104
递归思想
遍历根节点的左子树和右子树，在左子树和右子树中找是否有相同的子树
如果根节点为空，则返回false，如果存在相同的树，则返回true、
这里需要加一个判断树相同的函数，判断树相同小编在之前也写过–&gt;力扣100：相同的树
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* p, struct TreeNode* q) { if(p==NULL&amp;&amp;q==NULL) return true; if(p==NULL||q==NULL) return false; if(p-&gt;val!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ef32a3759a23e755a350ef52002102a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd57faf327eb0ff8053b66cb8bcde73/" rel="bookmark">
			挖漏洞之SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）漏洞原理 1、 漏洞原理 SQL注入的原理是，是应用系统没有对传递的参数进行过滤，让参数直接拼接到SQL语句中，攻击通过对参数进行篡改，当参数传递到数据库中，逻辑上就会发生变化，就产生新SQL语句，造成一些不好后果
2、案例讲解 假如某业务查询功能，一般实现过程是：后端接受参数，带入查询语句中，再把查询内容返回前端，这是语句的实现：
$userID = $_POST['userID']; $sql = "SELECT * FROM users WHERE userID = '$userID'; 攻击者通过拦截到userID参数，对其植入恶意代码：userID = ' OR 1 = 1 --+
最终SQL语句变成：
SELECT * FROM users WHERE userID = ' ' OR 1 = 1 --+
这条 SQL 语句查询出了 users 表中的所有数据，因为 OR 1=1 永远为真。攻击者可以进一步利用这个漏洞来获取更多的数据或执行其他操作，甚至删除数据表
所以，我认为SQL漏洞的本质，就是想进方法向参数中注入恶意代码，当参数传递到数据库中，SQL语句就发生了变化，执行之后就会产生SQL注入漏洞。
（二）漏洞分类 1、按照请求类型分类： GET型：通过修改URL中的参数值来注入恶意SQL语句。POST型：通过修改POST请求中的参数值来注入恶意SQL语句Cookie注入型：在请求头的Cookie参数中注入恶意的SQL语句， 2、按照字符类型分类： 数字型：攻击者试图将SQL代码注入到数字型的数据字段中。通常在后面加入测试语句：and 1=1字符型：将SQL代码注入到字符型的数据字段中，通常在后面加入测试语句：’or 1=1 3、按照测试方法测试： 报错：这是基于应用程序在处理错误时返回详细信息的漏洞，通过构造恶意的SQL语句来触发应用程序产生错误，并从错误信息中获取敏感数据或执行其他恶意操作，延时：这是一种利用在响应时间上的差异来判断漏洞的攻击方法，通过构造恶意的SQL语句，利用数据库管理系统的延时函数来判断查询是否成功执行，并据此推测SQL注入漏洞的存在，利用sleep()或benchmark()等函数让mysql执行时间变长盲注型：攻击者无法直接从响应中获取有关注入结果的详细信息，然后通过构造特定的SQL语句，利用在不同条件下的响应差异来推断查询的结果，常用构建盲注函数：substr()、Left（）、ORD()布尔型：在响应中的布尔条件语句的结果来判断查询是否成功执行的一种攻击方法。通过构造恶意的SQL语句并观察应用程序的响应，来推断SQL查询的结果，结果根据false和true不返回数据库数据 （三）基本测试方法 1、SQL注入常出现位置： 只要需要带入到数据库中的参数有可能存在SQL注入，常见位置如下：
用户输入表单：用户可以通过网站的表单（如搜索框、注册表单、登录表单等）提交数据给服务器
URL参数：URL参数是传递给应用程序的一种常见方式，产生url参数有两个来源，一是get请求会生成url参数，还有一个是隐藏的参数，网站使用隐藏字段来存储数据，这些字段可以在表单提交时自动包含在请求中。Cookies：cookies本身不会发生sql注入，可能会引发sql注入是因为，cookie是网络中识别用户身份的特殊文本，当开发人员在使用Cookie中存储的数据时，如果未进行适当的数据验证和处理，从而直接将Cookie数据用于SQL查询，就可能导致SQL注入漏洞的发生HTTP头信息：攻击者通过修改HTTP请求的头部信息中的值来注入恶意的SQL语句（UserAgent、Referer，等），这些自动生成并发送给服务器的头信息，本身不会导致sql注入，在某些情况下，攻击者可能会尝试使用特殊字符来触发应用程序中的漏洞， 2、基本测试过程如下： 第一步，找注入点：在参数后面加入单引号等特殊字符，查看是否引起报错，或是修改参数的值，观察对输入是否过滤和转义
第二步，找回显点，没有回显，测试盲注和延时。前面尝试通过加入特殊字符或者修改值引起报错，如果有报错信息就测试抱错型SQL注入，没有则测试盲注和延时注入
第三步，写poc，根据测试结果编写利用该漏洞的 POC，常见的通用payload如下(基于MySQL):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd57faf327eb0ff8053b66cb8bcde73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a2f0f2655bcb0cc01f28ee57847252/" rel="bookmark">
			力扣226：翻转二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 力扣226：翻转二叉树
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：
输入：root = [2,1,3]
输出：[2,3,1]
示例 3：
输入：root = []
输出：[]
提示：
树中节点数目范围在 [0, 100] 内
-100 &lt;= Node.val &lt;= 100
分析：
递归思想
将根节点的左孩子和右孩子交换一下即可，交换时需要传递地址到交换函数中，因此需要用二级指针来接收。
当根结点为空时，结束递归，这是递归返回的条件。
AC代码：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ void swap(struct TreeNode**left,struct TreeNode**right) { struct TreeNode*tmp=*left; *left=*right; *right=tmp; } struct TreeNode* invertTree(struct TreeNode* root) { if(root==NULL) return NULL; swap(&amp;root-&gt;left,&amp;root-&gt;right); invertTree(root-&gt;left); invertTree(root-&gt;right); return root; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8a47a77089c228aac91cdc08648829/" rel="bookmark">
			【公式】逻辑回归的损失函数是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、逻辑回归简介
二、逻辑回归模型的损失函数
2.1 损失函数与其意义
2.2 逻辑回归的损失函数
2.3 从交叉熵角度理解逻辑回归的损失函数
2.4 从对数似然角度推导逻辑回归的损失函数
三、逻辑回归损失函数的梯度
3.1 逻辑回归损失函数的梯度公式
3.2 用梯度下降法实现逻辑回归的求解
本文部分图文借鉴自《老饼讲解-机器学习》
一、逻辑回归简介 逻辑回归模型是机器学习中二分类模型中的经典，它的意义在于它能够解决二分类问题，例如判断一个人是否患有某种疾病，或者预测一个事件是否发生等。它是一种广义的线性回归分析模型，推导过程和计算方式类似于回归分析，但实际上主要是用来解决二分类问题。此外，逻辑回归模型还可以处理多分类问题，例如根据多个特征预测一个人所属于的类别等。
逻辑回归模型最终输出属于类别1的概率，它的模型表达式如下：
二、逻辑回归模型的损失函数 2.1 损失函数与其意义 在机器学习和优化问题中，损失函数（或目标函数）具有重要的意义。它用于衡量模型预测结果与实际结果之间的差异，从而反映模型的性能和准确度。
损失函数的目标是最小化预测结果与实际标签之间的差异。具体来说，它通过对模型的参数进行优化，使得模型的预测结果更接近于实际的观测结果。如果模型的预测结果与实际观测结果相差较大，那么损失函数的值就会较大；反之，如果预测结果与实际观测结果相差较小，那么损失函数的值就会较小。
通过最小化损失函数，我们可以找到一组最优的模型参数，使得模型能够更好地拟合训练数据，提高模型的准确度和泛化能力。因此，损失函数在逻辑回归模型中具有重要的意义，它是评估模型性能和指导模型优化的关键指标。
2.2 逻辑回归的损失函数 对于逻辑回归模型，损失函数是用来衡量模型预测概率与实际标签之间的差距的。在二分类问题中，逻辑回归模型的预测结果通常被解释为概率值，表示样本属于正类的概率。当这个概率值越接近于1时，表示模型预测样本为正类的可能性越大；反之，当概率值越接近于0时，表示模型预测样本为负类的可能性越大。
在逻辑回归中，常用的损失函数是对数似然损失（Log-Likelihood Loss），也称为交叉熵损失（Cross-Entropy Loss）。逻辑回归的损失函数如下：
2.3 从交叉熵角度理解逻辑回归的损失函数 交叉熵损失函数的计算基于概率分布之间的差异。在分类问题中，模型的预测结果通常是一个概率分布，表示每个类别上的预测概率。交叉熵损失函数通过比较模型预测的概率分布与实际的标签分布之间的差异来计算损失值。
从交叉熵角度理解逻辑回归的损失函数几乎不需要推导过程，但需要对熵及交叉熵的意义较为熟悉，可以参考文章《老饼讲解|【逻辑回归】逻辑回归损失函数交叉熵形式的理解》 2.4 从对数似然角度推导逻辑回归的损失函数 对数似然损失函数是一种损失函数，主要用于评估分类器的概率输出。它是在概率估计上定义的，通过惩罚错误的分类来实现对分类器准确度的量化。最小化对数似然损失基本等价于最大化分类器的准确度。对数似然损失函数在机器学习和深度学习中广泛应用，特别是在分类问题中，可以有效地衡量模型预测结果的准确性。
从对数似然角度推导逻辑回归的损失函数时，推导思路流程如下：
模型对单个样本评估正确的概率为：
上式等价于：
从而整体样本评估正角的概率为：
最大化总概率(上式)，即最小化,对其进行化简后就可以得到逻辑回归的操作函数，如下
相关细节过程可参考《老饼讲解|【推导】逻辑回归损失函数推导过程》
三、逻辑回归损失函数的梯度 3.1 逻辑回归损失函数的梯度公式 逻辑回归损失函数的意义主要用于求解逻辑回归模型中的参数，通常使用梯度下降等相关算法来进行求解，因此需要算出逻辑回归损失函数的梯度。
逻辑回归损失函数的梯度公式如下：
3.2 用梯度下降法实现逻辑回归的求解 根据以上公式，就可以使用梯度下降算法来求解逻辑回归模型中的参数。
逻辑回归的梯度下降求解方法可以分为以下几个步骤：
1.初始化参数：选择一个初始的参数向量，例如随机初始化。
2.计算损失：根据当前参数计算逻辑回归的损失函数值。
3.计算梯度：根据损失函数计算每个参数对应的梯度。
4.更新参数：根据梯度的大小，更新每个参数的值。
重复步骤2-4直到收敛或达到预设的最大迭代次数。
在具体实现中，逻辑回归的损失函数通常是对数似然损失函数，而梯度下降算法则是通过迭代更新参数来最小化损失函数。每次迭代中，根据当前的参数计算每个样本的预测概率和实际标签的对数似然损失，然后对损失函数求梯度并更新参数。这个过程一直重复，直到损失函数的值收敛或达到预设的最大迭代次数。
下面是python的实现代码示例：
# -*- coding: utf-8 -*- """ 梯度下降求解逻辑回归 """ from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d8a47a77089c228aac91cdc08648829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e9fa6e4fc8dc909e7d04b96806e4db/" rel="bookmark">
			Java 数据结构篇-用链表、数组实现队列（数组实现：循环队列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 队列的说明
1.1 队列的几种常用操作
2.0 使用链表实现队列说明
2.1 链表实现队列
2.2 链表实现队列 - 入栈操作
2.3 链表实现队列 - 出栈操作
2.4 链表实现队列 - 获取队头元素操作(不删除)
2.5 链表实现队列 - 获取队列有效元素个数操作
2.6 链表实现队列 - 判空处理操作
2.7 用链表实现队列的完整代码
3.0 使用数组实现循环队列说明
3.1 数组实现循环队列的操作
3.2 数组实现循环队列 - 入队列操作
3.3 数组实现循环队列 - 出队列操作
3.4 数组实现队列 - 得到队头元素操作(不删除)
3.5 数组实现队列 - 得到队尾元素操作(不删除)
3.6 数组实现队列 - 判空队列操作
3.7 数组实现队列 - 判满队列操作
3.8 用数组实现队列完整代码
1.0 队列的说明 队列是一种线性数据结构，具有先进先出（First In First Out，FIFO）的特性。它类似于排队的概念，新元素被添加到队列的尾部，而从队列中移除元素时则从队列的头部开始。队列通常用于需要按照特定顺序处理元素的场景，比如任务调度、消息传递等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e9fa6e4fc8dc909e7d04b96806e4db/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/35/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>