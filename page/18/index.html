<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbc6b746c76447902e20a465e5a570fe/" rel="bookmark">
			R语言【base】——table()：使用交叉分类因子来构建每个因子水平组合的计数列联表。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package base version 4.2.0
Parameters table(..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", "ifany", "always"), dnn = list.names(...), deparse.level = 1) as.table(x, ...) is.table(x) ## S3 method for class 'table' as.data.frame(x, row.names = NULL, ..., responseName = "Freq", stringsAsFactors = TRUE, sep = "", base = list(LETTERS)) 参数【...】：一个或多个对象，可以解释为因子（包括数字或字符串），或列表（例如数据框），其组件可以这样解释。（对于 as.table，传递给特定方法的参数；对于 as.data.frame，未使用。）
参数【exclude】：要删除所有参数【...】因子的水平。如果它不包含 NA 且未指定参数【useNA】，则表示参数【useNA】 = “ifany”。有关非因子参数的解释。
参数【useNA】：是否在表中包含 NA 值。可以缩写。
参数【dnn】：要为结果中的维度指定的名称（dimnames names）。
参数【deparse.level】：控制默认参数【dnn】的构造方式。
参数【x】：任意 R 对象，或从 as.data.frame 方法的类 “table” 继承的对象。请注意，对于非表格结构的参数【x】，可以显式调用 as.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbc6b746c76447902e20a465e5a570fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7008d0067d30cbb85d81811de8aab452/" rel="bookmark">
			【K8S in Action】第七章 ConfigMap和Secret配置应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 配置容器化应用程序 容器化应用通常是如何被配置：
以命令行参数的形式配置应用。 随着配置选项数量的逐渐增多， 将配置文件化。借助环境变量，常见方法。Docker 容器中采用配置文件的方式有困难，配置文件打入容器镜像， 抑或是挂载包含该文件的卷。 2 向容器传递命令行参数 容器中运行的完整指令由两部分组成：命令与参数。了解ENTRYPOINT与CMD。
ENTRYPOINT定义容器启动时被调用的可执行程序CMD指定传递给ENTRYPOINT的参数。 这样， 镜像可以直接运行， 无须添加任何参数
docker run &lt;image&gt; 是添加一些参数， 覆盖Dockerile中任何由CMD指定的默认参数值 docker run &lt;image&gt; &lt;arguments&gt; 了解shell与exec形式的区别，上述两条指令均支持以下两种形式，两者的区别在于指定的命令是否是在shell中被调用。：
shell形式 如ENTRYPOINT node app.js。exec形式 如ENTRYPOINT [“node”, “app. js”] docker exec -it e4bad ps x PID TTY STAT TIME COMMAND 1 ? Ss 0:00 /bin/sh -c node app. J s 7 ? Sl 0:00 node app.js 13 ? Rs+ 0:00 ps x 可以看出，主进程(Pid 1)是shell进程而非node进程，node进程(PID 7)在shell中启动。 shell进程往往是多余的， 在fortune脚本中添加VARIABLE变量并用第一个命令行参数对其初始化。 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7008d0067d30cbb85d81811de8aab452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e496c814772344c85c2a9248d819af/" rel="bookmark">
			Python从txt文件中提取特定数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本段代码用于，想要从一段txt文件中只提取目标数据的情况。
代码： def get_data(txt_path: str = '', epoch: int = 100, target: str = '', target_data_len: int = 5): num_list = [] # 将提取出来的数据保存到列表,并在最后返回 data = open(txt_path, encoding="utf-8") # 打开文件 str1 = data.read() # 将文件中读取到的内容转化为字符串 data.close() # 关闭文件 for i in range(0, epoch): index = str1.find(target) # 查找字符串str1中str2字符串的位置 num_list.append(float(str1[index+len(target):index+len(target)+target_data_len])) # 将需要的数据提取到列表中 str1 = str1.replace(target, 'xxxx', 1) # 替换掉已经查阅过的地方,' xxxx '表示替换后的内容，1表示在字符串中的替换次数为1 return num_list 函数参数解释：
txt_path 文件路径
epoch 这份文本文件中要提取出的数据个数,默认100
target 目标数据的前缀
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e496c814772344c85c2a9248d819af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0e55a9ac610c9915513b67d8422db2/" rel="bookmark">
			网络安全领域八大国际认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年互联网行业不景气，企业普遍在裁员、降薪，收缩不赚钱的业务。然而，网络安全行业作为重投入、无明确产出的领域，承受着更大的压力。在这个困境中，应届生找工作和往年相比变得有一些艰难，裁员和降薪会影响产业链上的每个人。
网络安全人才面临双重挑战，一方面是行业内的经济压力，企业因成本考虑削减网络安全支出；另一方面是市场对实际产出的强烈追求，而网络安全的成果往往难以量化。这使得网络安全岗位在裁员和降薪的时候成为首当其冲的目标。在这个背景下，考取网络安全认证成为许多从业者提升自己市场价值的途径之一。
虽然考取网络安全认证不是躲避裁员、降薪的绝对法宝，但它是提升个人职业发展的有力工具。在竞争激烈的环境中，拥有专业的认证是一个加分项，会帮助自己争取更好的职业机会。认证不仅仅是一纸证书，更是对个人技能、知识水平的验证，是在专业领域中的一张通行证。
下面介绍全球网络安全领域的八个认证，以助你在网络安全之路上取得成功。排名不分先后。
1. CISSP（Certified Information Systems Security Professional） CISSP是网络安全领域最著名的认证之一，被誉为“网络安全之母”，涵盖了网络安全的各个方面，包括安全管理、安全架构、密码学等。CISSP认证适用于希望在企业担任高级安全职位的专业人员。考试较长，时长6小时，以选择题形式考试。
2. CEH（Certified Ethical Hacker） CEH认证注重培养“伦理黑客”，旨在让专业人士学习攻击技术，以更好地保护系统。认证内容包括渗透测试、漏洞分析等方面的知识。对于渗透测试员和网络安全专业人士而言，CEH认证是提升技能水平的理想选择。考试相对较短，时长4小时，以选择题形式考试。
3. CompTIA Security+ CompTIA Security+是一个适用于初级网络安全职位的广泛认可证书。该认证覆盖了网络安全的基础知识，包括网络安全、身份验证等。对于初学者而言，Security+是迈入网络安全领域的理想起点。考试相对较短，时长90分钟，以选择题为主。
4. CISM（Certified Information Security Manager） CISM认证聚焦于信息安全管理和策略。持有CISM认证的专业人士在信息安全领域具备高级管理职位的竞争力。认证考试时长4小时，以多项选择题为主。CISM注重于培养信息安全领域的领导者和决策者。
5. CCSP（Certified Cloud Security Professional） 随着云计算的普及，CCSP认证成为专注于云计算安全的重要认证之一。涵盖了云安全架构、数据安全等方面的知识。CCSP认证持有者在云安全领域有着独特的优势。考试时长4小时，以多项选择题为主。
6. CompTIA CySA+（Cybersecurity Analyst） CySA+认证专注于培养网络安全分析师的技能，涵盖威胁管理、漏洞管理等方面的内容。这个认证适用于网络安全领域的初级从业人员。考试时长约为165分钟，包含多项选择题和实验题。
7. OSCP（Offensive Security Certified Professional） OSCP认证是渗透测试领域的权威认证，注重实践能力。考试时长24小时，采用实际渗透测试场景，要求考生在虚拟网络环境中成功完成攻击。这使得持有OSCP认证的专业人士在实际渗透测试项目中更具竞争力。
8. CISA（Certified Information Systems Auditor） CISA认证强调信息系统审计和控制。持有CISA认证的专业人士能够评估信息系统的合规性和安全性，为组织提供可靠的审计服务。考试时长4小时，以多项选择题为主。
这八大认证涵盖了网络安全领域的核心知识和技能，从基础入门到高级专业，为专业人士提供了全面的发展路径。在考取这些认证的过程中，建议深入理解每个领域的实际应用，通过实际项目经验不断提升自己的技能水平。同时，参加相关的培训课程和使用模拟试题也是备考过程中的有效方法。网络安全之路充满挑战，但通过这些认证，你将更有信心和实力在这个领域取得成功。
网络安全领域国际、国内认证很多，选择适合自己的认证即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2682928a74943c0e3241b84b1aa55b89/" rel="bookmark">
			matplotlib绘制柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码 import matplotlib.pyplot as plt import numpy as np # 数据 categories = ['denoise', 'double-digit', '100% 5R'] existence = [0.9778, 0.9768, 0.9767] non_existence = [0.9772, 0.9767, 0.9778] # 设置每组柱状图的宽度 bar_width = 0.25 # 计算每组柱状图的位置 x = np.arange(len(categories)) # 设置全局字体大小 plt.rcParams['font.size'] = 18 # 绘制柱状图 plt.bar(x, existence, width=bar_width, label='Apply') plt.bar(x + bar_width, non_existence, width=bar_width, label="Not apply") # 添加标题、标签和图例 plt.title('Transformer') # plt.ylabel('Acc') plt.xticks(x + bar_width / 2, categories) plt.yticks([0.976, 0.977, 0.978], ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2682928a74943c0e3241b84b1aa55b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaca23585d0584e2f4d735b5dfef0cf2/" rel="bookmark">
			JVM内存分配策略及垃圾收集器简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的内存分配策略 1.对象优先分配在Eden区 大多数情况下，对象都是优先分配在新生代eden区的，当eden区内存不够的时候就会发生Minor GC。
当没有eden区内存不够，开始进行minorGC时，若在这期间又发现已经分配了内存的空间allocation1无法存入存活区Survivor区，只能通过**空间分配担保机制（后面第五点会讲到）**把新生代提前转移到老年代，若老年代上的空间足够存放这个allocation1分区就不会出现fullGC
2.大对象直接进入老年代 什么是大对象？
大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
大对象经常出现会带来什么问题？
经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
如何设置大对象的阈值？
-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
3.长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
如何设置年龄阈值？
-XX:MaxTenuringThreshold 用来定义年龄的阈值。
4.动态对象年龄判断 虚拟机并不是永远都要求对象的年龄必须达到-XX:MaxTenuringThreshold所配置的数字才能晋升老年代，如果在survivor中相同年龄所有对象的大小的总和大于survivor分区的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到满足MaxTenuringThreshold要求的年龄。
5.空间分配担保 在JDK6 Update24后，规则变成—— 只要老年代连续的内存空间大于新生代对象的总大小 或者 历次晋升的平均大小就会进行MinorGC，否则就会进行FullGC。
Java垃圾收集器组合 Serial收集器+Serial Old收集器 Serial**（串行）收集器是最基本、历史最悠久**的垃圾收集器了。
新生代才用标记-复制算法，老年代标记-整理算法
Serial收集器 优点：简单高效，因为是单线程，没有线程交互的开销，因此拥有最高的单线程收集效率
Serial Old收集器 Serial收集器的老年代版本
ParNew收集器+CMS收集器 parNew收集器 负责新生代的收集器
serial收集器的多版本线程，线程的数量跟cpu数量相同（默认）
可以通过-XX:ParallelGCThreads 参数来设置线程数。
新生代才用复制算法，老年代才用标记-整理算法，只能和cms垃圾收集器配合工作
CMS收集器 负责老年代的收集
重视响应速度、低停顿 的一个垃圾收集器（使用“标记-清除”算法
CMS收集器是一种以获取最短回收停顿时间为目标的收集器（针对尤其重视服务的响应速度的情况，挺短时间越短越适合需要与用户交互的程序，良好的相应速度能给用户带来较好的体验）
优点：
并发收集低停顿 缺点：
使用的回收算法“标记-清除”算法会导致收集结束时产生大量的空间碎片，往往出现老年代空间剩余，但无法找到足够大的连续空间来分配当前而不得不提前触发一次Full GC。吞吐量低：CMS的低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不够高。并发收集阶段会降低吞吐量对CPU资源敏感无法处理浮动垃圾，可能出现Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次GC时才能进行回收。（由于浮动垃圾的存在，因此需要预留出一部分内存，意味着CMS手机不能像其他收集器那样等待老年代快满的时候回收。）【若预留的内存不够存放浮动垃圾，就会出现Concurrent Mode Failure，这时虚拟机将临时启用Serial Old来替代CMS】 控制参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaca23585d0584e2f4d735b5dfef0cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022174caa14c0f6367493fbe6b34c0d5/" rel="bookmark">
			MySQL5.7服务器 SQL 模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网地址：MySQL :: MySQL 5.7 Reference Manual :: 5.1.10 Server SQL Modes
欢迎关注留言，我是收集整理小能手，工具翻译，仅供参考，笔芯笔芯.
MySQL 5.7 参考手册 / ... / 服务器 SQL 模式 5.1.10 服务器 SQL 模式 MySQL服务器可以在不同的SQL模式下运行，并且可以根据系统变量的值对不同的客户端应用不同的模式sql_mode。DBA 可以设置全局 SQL 模式来匹配站点服务器操作要求，每个应用程序可以根据自己的要求设置其会话 SQL 模式。
模式影响 MySQL 支持的 SQL 语法及其执行的数据验证检查。这使得在不同的环境中使用MySQL以及将MySQL与其他数据库服务器一起使用变得更加容易。
设置SQL模式
最重要的 SQL 模式
SQL 模式的完整列表
组合 SQL 模式
严格SQL模式
IGNORE 关键字与严格 SQL 模式的比较
MySQL 5.7 中的 SQL 模式更改
有关 MySQL 中服务器 SQL 模式的常见问题的解答，请参阅第 A.3 节“MySQL 5.7 常见问题解答：服务器 SQL 模式”。
使用InnoDB表时，还要考虑innodb_strict_mode系统变量。它可以对表进行额外的错误检查 InnoDB。
设置SQL模式 MySQL 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022174caa14c0f6367493fbe6b34c0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e69a864e881eae41b467d4f3ffb9862/" rel="bookmark">
			独热编码的两种实现形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独热编码的两种实现形式： ​ OneHotEncoder和DictVectorizer是两种常用的特征向量化方法，用于将分类特征转换为数值特征。但还是有一定的区别不管是再输入格式还是在输出类型上都有一些不同。
区别： 输入格式要求： OneHotEncoder：接受二维数组或稀疏矩阵作为输入。需要先对分类特征进行编码为整数标签，然后再使用OneHotEncoder进行转换。DictVectorizer：接受字典列表或Pandas DataFrame作为输入。每个字典表示一个样本，键表示特征名称，值表示特征值。 输出类型： OneHotEncoder：输出稀疏矩阵。对于大规模数据集和高维度特征，可以节省内存空间。DictVectorizer：输出稠密矩阵。对于小规模数据集和低维度特征，输出的是一个数组。 处理缺失值： OneHotEncoder：不直接处理缺失值，需要在进行编码之前对缺失值进行处理。DictVectorizer：可以通过设置sparse=False参数将缺失值编码为0或使用其他指定的值。 特征名称的处理： OneHotEncoder：不保留特征名称，只生成数值编码后的特征。DictVectorizer：保留特征名称，可以通过get_feature_names()方法获取特征名称。 基础铺垫： ​ X.to_dict()这将返回一个字典，其中键是特征列的名称，值是特征列对应的 Series 对象。
import pandas as pd data = { 'age': ['young', 'young', 'young', 'young', 'young'], 'prescript': ['myope', 'myope', 'myope', 'myope', 'hyper'], 'astigmatic': ['no', 'no', 'yes', 'yes', 'no'], 'tearRate': ['reduced', 'normal', 'reduced', 'normal', 'reduced'] } df = pd.DataFrame(data) print(df) print(df.to_dict())# 字典套字典 print('-----------------') print(df.to_dict(orient='records')) # 列表套字典 X.to_dict():
{'A': {0: 1, 1: 2, 2: 3}, 'B': {0: 4, 1: 5, 2: 6}} X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e69a864e881eae41b467d4f3ffb9862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38e3d82c2cddfc41675c5a547f25a17/" rel="bookmark">
			在多Module项目中，给IDEA底部选项卡区域添加Services选项卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般一个spring cloud项目中大大小小存在几个十几个module编写具体的微服务项目。此时，如果要调试测需要依次启动各个项目比较麻烦。
idea其实提供了各module的启动管理工具了，可以快速启动和关闭各个服务，也能批量操作，比如一次性全部启动或者关闭。
默认第一次打开项目的时候，idea会提示是否增加这个选项卡，如果你没点或者选择了否，则需要手动添加这个选项里卡。
手动添加方法很简单，打开项目目目录的.idea/workspace.xml文件。
找到RunDashboard节点，添加一个option节点。
&lt;option name="configurationTypes"&gt; &lt;set&gt; &lt;option value="SpringBootApplicationConfigurationType" /&gt; &lt;/set&gt; &lt;/option&gt; 12345 如果没有找到RunDashboard节点，则增加一个RunDashboard节点
&lt;component name="RunDashboard"&gt; &lt;option name="configurationTypes"&gt; &lt;set&gt; &lt;option value="SpringBootApplicationConfigurationType" /&gt; &lt;/set&gt; &lt;/option&gt; &lt;option name="ruleStates"&gt; &lt;list&gt; &lt;RuleState&gt; &lt;option name="name" value="ConfigurationTypeDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;RuleState&gt; &lt;option name="name" value="StatusDashboardGroupingRule" /&gt; &lt;/RuleState&gt; &lt;/list&gt; &lt;/option&gt; &lt;/component&gt; 1234567891011121314151617 此时再打开项目，idea底部就会出现sevice选项卡了。
参考链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e73c96a533e5cc85b26f12bb391a44/" rel="bookmark">
			红队打靶练习:SAR: 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
信息收集
1、arp
2、netdiscover
3、nmap
4、nikto
5、whatweb
小结
目录探测
1、gobuster
2、dirsearch
WEB
CMS
1、cms漏洞探索
2、RCE漏洞利用
提权
get user.txt
本地提权
信息收集 1、arp ┌──(root㉿ru)-[~/kali] └─# arp-scan -l Interface: eth0, type: EN10MB, MAC: 00:0c:29:69:c7:bf, IPv4: 192.168.12.128 Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.12.1 00:50:56:c0:00:08 VMware, Inc. 192.168.12.2 00:50:56:ec:d1:ca VMware, Inc. 192.168.12.150 00:50:56:3f:48:06 VMware, Inc. 192.168.12.254 00:50:56:f6:29:00 VMware, Inc. 5 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e73c96a533e5cc85b26f12bb391a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b029cbc6c1da036438327af03190ded/" rel="bookmark">
			C&#43;&#43;17中的内联变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++11中：
(1).声明为constexpr的函数隐式地是内联函数;
(2).deleted函数隐式地是一个内联函数。
在内联函数中：
1.所有函数定义中的函数局部静态对象(function-local static object)在所有翻译单元之间共享(它们都引用一个翻译单元中定义的同一对象)。
2.所有函数定义中定义的类型在所有翻译单元中也相同。
inline关键字的最初目的是向优化器指示函数的内联替换优先于函数调用，即不执行函数调用CPU指令将控制权转移到函数体，而是执行函数的副本即函数体在不生成调用的情况下执行。这避免了函数调用(传递参数并检索结果)产生的开销，但可能会导致更大的可执行文件，因为函数的代码必须重复多次。
由于关键字inline的含义是非绑定的(non-binding)，因此编译器可以自由地对任何未标记为内联的函数使用内联替换，并且可以自由地生成对任何标记为内联的函数的函数调用。
C++17引入了内联变量，即允许在多个文件中定义的变量。内联变量的工作方式与内联函数类似，并且具有相同的要求(编译器必须能够在使用该变量的任何地方看到相同的完整定义)。
内联说明符(inline specifier)在具有静态存储持续时间(static storage duration)的变量(静态类成员或命名空间范围内的变量)的decl-specifier-seq(declaration specifiers)中使用时，将该变量声明为内联变量。
声明为constexpr的静态成员变量(但不是命名空间范围内的变量)隐式地是内联变量。
C++的两种链接方式：外部链接(External Linking)和内部链接(Internal Linking)
1.外部链接：函数或变量可以在其它翻译单元中使用。默认情况下，在C++中定义的函数和全局变量都具有外部链接属性。
2.内部链接：函数或变量只能在定义它的翻译单元中使用。
内联函数或内联变量(inline function or inline variable)具有以下属性：
1.内联函数或内联变量的定义必须在访问它的翻译单元(translation unit，源代码文件如.cpp)中可访问
2.具有外部链接(external linkage)(例如未声明为静态)的内联函数或内联变量具有以下附加属性：
(1).程序中可能存在多个内联函数或内联变量的定义，只要每个定义出现在不同的翻译单元中(different translation unit)并且(对于非静态内联函数和内联变量)所有定义都是相同的。例如，内联函数或内联变量可以定义在包含在多个源文件中的头文件中。
(2).它必须在每个翻译单元中声明为内联。
(3).每个翻译单元都有相同的地址(same address).
命名空间范围内的内联const变量默认具有外部链接(与非内联、非易失性、const限定(non-inline non-volatile const-qualified)变量不同)。
因为函数的关键字inline的含义开始意味着"允许多个定义"而不是"首选内联"，所以该含义被扩展到内联变量。在现代C++中，内联已演变为"允许多个定义"的意思。
内联变量消除了将C++代码打包为仅含头文件库的主要障碍(Inline variables eliminate the main obstacle to packaging C++ code as header-only libraries)。
内联变量在未声明为静态时具有外部链接.
如果内联变量有多个定义，编译器会在需要时选择其中一个定义.
与内联函数不同，内联变量可以具有静态存储持续时间(static storage duration)。如果内联变量是在类范围内定义的，则它的行为类似于静态成员变量。此类成员变量可以在类内部初始化。
内联变量在所有翻译单元中具有相同的内存地址。
C++17允许在不同的翻译单元中对内联变量进行多个定义，并且每个翻译单元将拥有自己的变量副本。
内联变量默认具有外部链接。如果我们想定义一个具有内部链接的内联变量，我们可以使用静态说明符。
当我们在全局变量上使用inline关键字时，我们不需要在其他地方将它们定义为"extern"。对于静态成员变量，我们不需要在类外部定义它们。
根据一次定义原则(ODR, One Definition Rule),一个变量或实体的定义只能出现在一个编译单元内----除非该变量或实体被定义为inline的。
内联变量和thread_local:通过使用thread_local你可以为每个线程创建一个内联变量。
注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b029cbc6c1da036438327af03190ded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e0e359ef43a84bfecf6a1650a2d5fd/" rel="bookmark">
			【ASP.NET Core 基础知识】--目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
1.1 什么是ASP.NET Core1.2 ASP.NET Core的优势1.3 ASP.NET Core的版本历史 环境设置
2.1 安装和配置.NET Core SDK2.2 使用IDE（Integrated Development Environment）：Visual Studio Code / Visual Studio 项目结构
3.1 ASP.NET Core项目的基本结构3.2 项目文件和文件夹的作用3.3 配置文件 MVC框架
4.1 什么是MVC模式4.2 创建和理解Controllers4.3 Views和Razor语法4.4 Models和数据绑定 中间件（Middleware）
5.1 什么是中间件5.2 内置中间件的使用5.3 创建自定义中间件 路由和请求处理
6.1 路由的基本概念6.2 Attribute路由6.3 请求处理管道 依赖注入（DI）
7.1 什么是依赖注入7.2 在ASP.NET Core中使用依赖注入7.3 生命周期和作用域 数据库连接
8.1 使用Entity Framework Core进行数据库访问8.2 数据迁移和代码优先开发 身份验证和授权
9.1 用户认证的基本概念9.2 使用Identity进行身份验证9.3 授权和策略 Web API
10.1 创建和配置Web API10.2 RESTful设计原则10.3 Swagger文档生成 前端开发
11.1 集成前端框架（如Angular、React、Vue）11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56e0e359ef43a84bfecf6a1650a2d5fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1469ee5327625e7268ccc7274c7a10e6/" rel="bookmark">
			【C语言】文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单不先于复杂，而是在复杂之后。
文章目录 1. 为什么使用文件2. 什么是文件2.1 程序文件2.2 数据文件2.3 文件名 3. 文件的打开和关闭3.1 文件指针3.2 文件的打开与关闭 4. 文件的顺序读写4.1 对比一组函数4.2 文件版本通讯录 5. 文件的随机读写5.1 fseek5.2 ftell5.3 rewind 6.文本文件和二进制文件7. 文件读取结束的判定7.1 被错误使用的 feof 8. 文件缓冲区 1. 为什么使用文件 在之前自定义类型的文章中，写了通讯录的程序，当通讯录运行起来的时候，可以给通讯录中增加、删除数据，此时数据是存放在内存中，当程序退出的时候，通讯录中的数据自然就不存在了，等下次运行通讯录程序的时候，数据又得重新录入，如果使用这样的通讯录就很不方便。
既然是通讯录就应该把信息记录下来，只有我们自己选择删除数据的时候，数据才不复存在。
这就涉及到了数据持久化的问题，一般数据持久化的方法有：把数据存放在磁盘文件、存放到数据库等方式。
使用文件可以将数据直接存放在电脑的硬盘上，做到了数据的持久化。
2. 什么是文件 磁盘上的文件是文件。
但是在程序设计中，我们一般谈的文件有两种：程序文件、数据文件（从文件功能角度来分类的）。
2.1 程序文件 包括源程序文件（后缀为.c）、目标文件（windows环境后缀为.obj）、可执行程序（windows环境后缀为.exe）。
2.2 数据文件 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。
FILE*可以理解成文件流
任何一个C程序，只要运行起来就会默认打开3个流：
FILE* stdin - 标准输入流（键盘）FILE* stdout - 标准输出流（屏幕）FILE* stderr - 标准错误流（屏幕） 本章讨论的是数据文件。
在之前的文章中所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到显示器上。
其实有时候我们会把信息输入到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上文件。
2.3 文件名 一个文件要有一个唯一的文件标识，以便用户识别和引用。
文件名包含3部分：文件路径+文件名主干+文件后缀
例如：c:\code\test.txt
为了方便起见，文件标识常被称为文件名。
3. 文件的打开和关闭 3.1 文件指针 缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1469ee5327625e7268ccc7274c7a10e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f1d4e326421003d172d7510acf1ae6/" rel="bookmark">
			React 实现 Step组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文将会实现步骤条组件功能。步骤条在以下几个方面改进。
1、将url与Step组件绑定，做到浏览器刷新，不会重定向到Step 1
2、通过LocalStorage 存储之前的Step，做到不丢失数据。
实现 Step.jsx (组件) import {useEffect, useState} from "react"; export const Step = ({name, data})=&gt;{ const submit = (event)=&gt;{ event.preventDefault(); const local = localStorage.getItem(name); console.log(JSON.parse(local)) } const [current, setCurrent] = useState(0); useEffect(()=&gt;{ let paths = window.location.pathname.split('/'); setCurrent(parseInt(paths[paths.length - 1])); }, []) return ( &lt;form className={'Step'} onSubmit={submit}&gt; &lt;div className={'Step-Header'}&gt; &lt;div&gt; { data.map((item, idx) =&gt;{ return &lt;a key={idx} href= {`/step/${idx}`} style={{paddingRight:30}}&gt;{item.name + ((idx === current) ? '√':'')}&lt;/a&gt;; }) } &lt;/div&gt; &lt;/div&gt; &lt;div className={'Step-Content'}&gt; {data[current].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f1d4e326421003d172d7510acf1ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6cb22299d4e1570c76f848a73e950f/" rel="bookmark">
			携手共进，共创 IT 技术新辉煌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲爱的喵叔写技术公众号的读者们：新年的钟声已经敲响，我们迎来了充满希望和挑战的 2024 年。在这个开年之际，我代表喵叔写技术公众号向大家致以最诚挚的祝福，祝愿大家在新的一年里身体健康、工作顺利、学业有成！回顾过去的一年，我们生活在一个快速变化的时代，技术的发展日新月异。人工智能、大数据、云计算、区块链等前沿技术的应用和发展，正在深刻地改变着我们的生活和工作方式。作为 IT 技术从业者，我们需要不断学习和更新自己的知识和技能，以适应这个快速变化的时代。在新的一年里，我们将继续为大家提供最新的 IT 技术资讯、实用的技术教程和案例分析，帮助大家更好地掌握和应用各种 IT 技术。同时，我们也将加强与读者的互动和交流，听取大家的意见和建议，不断改进和完善我们的内容和服务。2024 年是一个新的开始，让我们一起携手共进，共同推动 IT 技术的发展和应用，为实现数字化转型和智能社会做出自己的贡献！再次祝愿大家在 2024 年里取得更大的进步和成就！让我们一起迎接新的挑战和机遇，共同创造更加美好的未来！喵叔写技术2024年01月01日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54dfa3712c50073286bdde02b397164f/" rel="bookmark">
			新年福利！强烈推荐一个Pandas数据分析“神器”(文末送书)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Pandas在Python数据分析领域堪称神器，无论是数据处理还是分析，它都能轻松搞定。
然而，想要真正用好Pandas却并不容易，很多同学要么陷入不必要的琐碎细节，关键知识点掌握不牢一用就忘。要么只钻研数据处理技巧而不会分析，导致做了很多无效的数据处理工作，硬生生把Pandas这把屠龙刀变成了棒槌，实在可惜。
因此，我给大家推荐阿粥（志鹏）的新书《Python电商数据分析实战：从电商实际案例出发洞悉数据分析全流程》，这本书用抓重点的方式从零开始讲透Pandas库，并通过一系列实战案例，把数据技能和分析理论深度结合，让Pandas成为数据分析真正的神器，而且文风幽默风趣，深入浅出，非常推荐一读！
这本书写了什么，有什么不一样？ 市面上已经有不少关于Python数据分析和建模的资料，只是相关内容很多都专注于数据处理技巧本身，较少有业务视角贯穿其中，也鲜有回答“如何从实际业务的视角看问题、给建议，并用分析推动决策”这些问题。
对于数据分析来说，两者都很重要，后者更是分析师价值的体现！数据分析如果没有业务思维，很容易陷入技能的自嗨而不自知。
因此，这本书围绕Python数据分析最重要的Pandas库，同时把技能和思维，理论与实践做了深度融合，一共有15章：
其中八大实战项目都力求做到有分析背景和理论，有分析目标，有实战数据源，有完整Pandas数据处理分析代码，还有数据分析项目的思考。
作者现在是某品牌电商数据分析经理，有非常丰富的实践经验。从电商出发，但不止于电商，既保证了实际业务场景的深度，也兼具了案例的通用性，精选的八大简历级Pandas数据分析案例适用于绝大多数行业，帮助读者在掌握Pandas的同时还熟悉整个数据分析流程，大大强化了技能和思维的融合度。
本书内容结构 内容结构上，围绕基础+实战的方向，附上本书完整目录，可点击大图缩放查看高清版：
本书适合的人群 本书适合任何想要提升Python数据分析和实战能力的读者，无论是否零基础，读完本书跟着案例项目练习后，可以熟练运用Pandas进行数据分析，显著地提升数据处理的效率和分析深度。
大咖推荐&amp;读者反馈 最近，某高校老师看了之后，已经把这本书作为下学期的专业课教材
已经购买的部分读者反馈：
最后，关于购买和福利 购买福利一 购买本书，即可获取对应内容（具体获取方式在本书前言部分）：
数据源和完整项目代码。Pandas基础部分+8大实战项目所有的数据源（部分案例35W+行实战数据）和完整案例代码，拿来就能用。
拓展学习资源，包括不限于原创的《写给分析师的Python极简入门手册》电子书；Excel、SQL、数据分析案例等相关学习资料；以及关于ChatGPT和数据分析的结合。
高质量社群交流答疑，一群人在一起，比一个人跑得更快！
购买福利二 和出版社争取了5折福利（限量仅50本）
原价89元，现价44.5元
点击下方链接或扫描下面二维码购买
👇👇👇
赠书规则 赠送规则：通过留言点赞的方式送出，转发本文至朋友圈+文末留言，留言点赞数量最多的前3位读者将各获得1本。 开奖时间：1月10 日20:00（周三） 注意事项：最终获赠者请在24小时以内添加小编微信👇，并提供朋友圈转发和集赞的截图。如发现机器或者非真实流量刷赞，发现后将进入黑名单，取消获赠资格。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efab4953bea80b178f3584052b9e88cc/" rel="bookmark">
			vue3插件：ace-builds封装ace-editor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装包 npm install ace-builds --save-dev //引入ace报错需要安装 npm install vue-loader-v16 -D 封装文件 ace-editor相关文档参考
webpack环境必备：import "ace-builds/webpack-resolver";
非webpack环境不需要引入
&lt;template&gt; &lt;div ref="editorform" style="height: 300px" class="ace-editor"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { watch, onMounted, onBeforeUnmount, ref} from "vue"; import ace from "ace-builds"; import "ace-builds/webpack-resolver"; import "ace-builds/src-noconflict/mode-yaml"; import "ace-builds/src-noconflict/theme-chaos"; import "ace-builds/src-noconflict/ext-language_tools"; import "ace-builds/src-noconflict/ext-emmet"; import "ace-builds/src-noconflict/snippets/yaml"; //import "ace-builds/src-noconflict/keybinding-vscode"; //import "ace-builds/src-noconflict/keybinding-emacs"; export default { name: "CodeEditor", emits: ["update:value"], props: { id: { type: Number, default: 0, }, // 外部传入的内容，用于实现双向绑定 value: { type: String, default: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efab4953bea80b178f3584052b9e88cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ec7034b9cbd90f36580094500c37eb/" rel="bookmark">
			Tomcat 架构设计 25 年后依旧能打！我学到了什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 是 Sun 公司在 1998 年开发的。当时开发 Tomcat 的目标是成为 Sun 公司的 Java Servlet 和 JSP 规范的参考实现。
如今已经成为业务开发首选的 Web 应用服务器，Spring Boot 直接将 Tomcat 内置作为 Web 应用启动，二十五年宝刀未老。其中的架构设计思维值得我们深入学习和借鉴。
码哥今天带你深入探究，学会借鉴 Tomcat 的设计思想在工作中做好架构设计。
在Tomcat 架构解析到设计思想借鉴中我们学到 Tomcat 的总体架构，学会从宏观上怎么去设计一个复杂系统，怎么设计顶层模块，以及模块之间的关系；
Tomcat 实现的 2 个核心功能：
处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。
加载并管理 Servlet ，以及处理具体的 Request 请求。
所以 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container），连接器负责对外交流，容器负责内部处理。
Tomcat整体架构 管理组件，运筹帷幄 本篇作为 Tomcat 系列的第三篇，带大家体会 Tomcat 是如何构建的？每个组件如何管理组件的？连接器和容器是如何被启动和管理的？
Tomcat 启动流程：startup.sh -&gt; catalina.sh start -&gt;java -jar org.apache.catalina.startup.Bootstrap.main()
Tomcat 启动流程 Bootstrap、Catalina、Server、Service、 Engine 都承担了什么责任？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ec7034b9cbd90f36580094500c37eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a89ce4cee6cb4daa70d7d508eb54d0/" rel="bookmark">
			数据转换的三剑客：Pandas 中 apply、map 和 applymap 方法的应用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据转换的三剑客：Pandas 中 apply、map 和 applymap 方法的应用指南 ​ 在 Pandas 中，apply、map 和 applymap 是常用的数据转换和处理方法，它们为数据分析和数据处理提供了灵活的功能。这些方法可以根据具体的需求选择合适的方法进行操作。
apply： ​ apply 方法是 Pandas 中最常用的方法之一。它可用于在 DataFrame 或 Series 的行或列上应用函数。apply 方法接受一个函数作为参数，并将该函数应用于指定的轴或维度。返回值是一个新的 Series 或 DataFrame 对象，其中包含应用函数后的结果。
import pandas as pd def square(x): return x ** 2 # 创建一个示例 DataFrame data = {'A': [1, 2, 3], 'B': [4, 5, 6]} df = pd.DataFrame(data) print(df) # 应用自定义函数到列 df['A'] = df['A'].apply(square) print(df) 当然，对于这种简单的语句，我们可以直接使用lamba表达式来代替。
如下：
import pandas as pd # 创建一个示例 DataFrame data = {'A': [1, 2, 3], 'B': [4, 5, 6]} df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75a89ce4cee6cb4daa70d7d508eb54d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ae01687a1baeb915726a8ddb1dbb8a/" rel="bookmark">
			C&#43;&#43;使用MINGW64集成Direct3D开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		霸王•吕布 / MinCPlusCompiler · GitCodewindows mingw64 c++简易开发编译工具,集成Direct3D FMOD Cmake编译工具https://gitcode.net/qq_35829452/mincpluscompiler
一.MINGW64编译器
gcc.exe C语言编译器 g++.exe C++语言编译器 mingw32-make.exe -j 4 CMake编译工具 二.MINGW64编译命令
g++编译命令 -mwindows 指定入口函数为WinMain 既windows窗口程序 -static 指定g++编译器将需要依赖的dll和lib打包至exe -I 指定头文件.h所在目录 -L 指定链接dll,lib链接库所在路径 -l 指定链接库名称 .\\ 本级路径 ..\\ 父级路径 g++.exe ..\..\main.cpp ..\..\Common.cpp ..\..\D3DInputManager.cpp ..\..\D3DManager.cpp ..\..\D3DModelManager.cpp ..\..\D3DTextManager.cpp ..\..\D3DTransformManager.cpp ..\..\FModManager.cpp -static -o ..\..\main.exe -mwindows -I ..\..\include\ -L ..\..\lib\ -ld3d9 -ld3dx9 -ldinput8 -ldxguid -lWinMM -lfmod_vc -lfmodL_vc 三.集成Direct3D
将Direct3D-SDK中include头文件和lib文件单独取出并放置在根目录下
四.解析OBJ文件并渲染
实现D3DModelManager完成基本模型加载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf90c06ef82b379edd2938f89d9a0a24/" rel="bookmark">
			信息网络协议基础_绪论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 交换技术基本概念电路交换电话交换网 分组交换数据报交换虚电路交换 网络体系结构新的网络技术和体系结构Delay/Disruption Tolerant Networking(DTN)如何理解间隙性？ Software Define Networking(SDN)Future Internet ArchitectureNDN(Named Data Networking)MobilityFirst 交换技术 基本概念 电路交换 电话交换网 分组交换 数据报交换 虚电路交换 网络体系结构 新的网络技术和体系结构 Delay/Disruption Tolerant Networking(DTN) 如何理解间隙性？ 断断续续的连接：间隙性指的是网络连接的断断续续，即网络中的节点不是始终相互连接，而是时有时无。等待传输机会：在DTN中，数据可能需要在网络节点上等待一段时间，直到下一个传输机会出现。例如，一个在深海中的传感器可能需要等待与之通信的潜水艇或浮标进入其通信范围。非实时通信：由于这种间隙性，DTN中的通信通常不是实时的，而是基于“存储-转发”机制。 Software Define Networking(SDN) 控制平面与数据平面的分离：
在传统网络中，网络设备（如交换机和路由器）同时负责数据转发（数据平面）和路由决策（控制平面）。在SDN中，这两个功能被分离：控制平面被集中到一个中央控制器（SDN控制器），而数据平面仍留在网络设备中。中央控制器：SDN控制器是网络的大脑，负责处理整个网络的路由决策和策略。它为网络提供了全局视图，使网络管理更加集中和高效。
开放接口：SDN控制器通过开放的接口（如OpenFlow）与网络设备通信。这些接口允许控制器动态地调整网络设备的行为。 Future Internet Architecture NDN(Named Data Networking) NDN的核心思想是以数据（或内容）本身而不是数据所在位置（即IP地址）为中心，这代表了一种从基于主机的网络模型（如当前的IP网络）向基于内容的网络模型的根本转变。
数据中心化：在NDN中，通信不是基于发送和接收节点的地址，而是基于数据的名称。这意味着网络层的操作是围绕着数据名称而非主机地址进行的。名称而非位置：NDN使用唯一的、可读的数据名称来识别数据，而不是使用IP地址。这些名称是分层的，类似于文件系统中的路径。消费者驱动的通信模型：NDN网络中的数据传输是由数据的消费者（即请求数据的节点）驱动的，而不是由数据的生产者。 优点:
效率：通过缓存数据，NDN可以减少带宽使用，提高数据检索效率。由于每个数据包都需要验证，NDN天然具有较高的数据安全性。由于数据不是从固定的位置获取，NDN在面对网络变化和故障时更加鲁棒。 MobilityFirst 更好地适应移动性和服务可靠性的需求。
以移动性为中心：“Mobility First” 的核心理念是将移动性作为网络设计的第一要素。在当今世界，移动设备和无线网络的普及要求网络能够更有效地处理移动性。全球名称服务（GNS）：与传统的基于IP地址的网络不同，“Mobility First” 引入了全球名称服务，这是一种全球性的命名和寻址方案，旨在提供更稳定、可靠的网络服务。网络架构的重新设计：这个项目提出了对现有互联网架构的重大改造，包括改进的路由协议、数据传输机制、安全机制等。 特点: 支持高移动性：能够有效处理高速移动中的设备和用户，以及频繁的网络切换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09462e9bec45a23584b28f4cccfc4c6c/" rel="bookmark">
			聚类：聚类的介绍及k-means算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚类：聚类的介绍及k-means算法 什么是聚类 聚类就是在输入为多个数据时，将“相似”的数据分为一组的操作。1 个组就叫作 1 个 “簇”。下面的示例中每个点都代表1 个数据，在平面上位置较为相近、被圈起来的点就代表一 类相似的数据。也就是说，这些数据被分为了 3 个簇。
假设某所高中的某个年级中共有 400 名学生，现在我们想要将这些学生在考试中取得的语 文、数学、英语成绩数据化，并将他们按照“擅长或不擅长的科目相似”进行聚类。
把每个学生都转换成“（语文成绩 , 数学成绩 , 英语成绩）”形式的数据后，就可以将两个数 据（c1, m1, e1）和（c2, m2, e2）之间的差距定义为 (c1-c2)² + (m1-m2)² + (e1-e2)² ，其中差距小的数据 就互为“相似的数据”。
即使定义好了数据间的差距，聚类的方法也会有很多种。我们可以设定各种各样的条件， 比如想把数据分为 10 个簇，或者想把 1 个簇内的数据定在 30~50 人之间，再或者想把簇内数据间的最大距离设为 10，等等。而设定什么样的条件取决于进行聚类的目的。
假如是为了开办暑期补习班而对学生进行分班，那么就要根据老师和教室的数量来确定 “簇的数量”，并根据教室的面积确定“每个簇内的数据量”。现在有很多种可以满足各类条件的聚类算法供我们选择。“k-means 算法”就是其中一种。
k-means算法 k-means 算法是聚类算法中的一种，它可以根据事先给定的簇的数量进行聚类。
首先准备好需要聚类的数据，然后决定簇的数量。本例中我们将簇的数量定为 3。此处用点表示数据，用两点间的直线距离表示数据间的差距。并且随机选择 3 个点作为簇的中心点。
计算各个数据分别和 3 个中心点中的哪一个点距离最近。
将数据分到相应的簇中。这样，3 个簇的聚类就完成了。
计算各个簇中数据的重心，然后将簇的中心点移动到这个位置。而随着中心点的移动，部分数据的“距离自己最近的中心点”也会改变。然后，重新计算距离最近的簇的中心点，并将数据分到相应的簇中。
重复执行“将数据分到相应的簇中”和“将中心点移到重心的位置”这两个操作，直到中心点不再发生变化为止。
4 轮操作结束后，结果如上图所示。即使继续重复操作，中心点也不会再发生变化，操作到此结束，聚类也就完成了。此时我们可以确定，相似的数据已经被恰当地分为一组了。
k-means 算法中，随着操作的不断重复，中心点的位置必定会在某处收敛，这一点已经在数学层面上得到证明。
算法中，随着操作的不断重复，中心点的位置必定会在某处收敛，这一点已经在数学层面上得到证明。
除了 k-means 算法以外，聚类算法还有很多，其中“层次聚类算法”较为有名。与 k-means 算法不同，层次聚类算法不需要事先设定簇的数量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0725236f1159d80bb59af3312173d69c/" rel="bookmark">
			python股票分析挖掘预测技术指标知识大全之KDJ详解(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包。
我们已经初步的接触与学习其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
也简单介绍一下数据获取的二种方法，通过金融数据接口和爬虫获取。
上一章介绍了指标之王MACD，这一章我们重点介绍一下随机指标KDJ.
KDJ指标详解 (1)KDJ指标简介 KDJ指标中文名叫随机指标，是由乔治·蓝恩博士（George Lane）最早提出的。该指标集中包含了强弱指标、动量概念和移动平均线的优点，可以用来衡量股价脱离正常价格范围的偏离程度。
，它起先用于期货市场的分析，后被广泛用于股市的中短期趋势分析，是期货和股票市场上最常用的技术分析工具。
随机指标KDJ一般是用于股票分析的统计体系，根据统计学原理，通过一个特定的周期（常为9日、9周等）内出现过的最高价、最低价及最后一个计算周期的收盘价及这三者之间的比例关系，来计算最后一个计算周期的未成熟随机值RSV，然后根据平滑移动平均线的方法来计算K值、D值与J值，并绘成曲线图来研判股票走势。
(2)KDJ指标计算方法 KDJ指标的计算过程是，首先获取指定周期（一般是9天）内出现过的股票最高价、最低价和最后一个交易日的收盘价，随后通过它们三者间的比例关系来算出未成熟随机值RSV，并在此基础上再用平滑移动平均线的方式来计算K、D和J值。计算完成后，把KDJ的值绘成曲线图，以此来预判股票走势，具体的算法如下所示。
第一步：计算周期内（n日、n周等，n一般是9）的RSV值，RSV也叫未成熟随机指标值，是计算K值、D值和J值的基础。以n日周期计算单位为例，计算公式如下所示。
n日RSV =（Cn－Ln）/（Hn－Ln）× 100
其中，Cn是第n日（一般是最后一日）的收盘价，Ln是n日范围内的最低价，Hn是n日范围内的最高价，根据上述公式可知，RSV值的取值范围是1到100。如果要计算n周的RSV值，则Cn还是最后一日的收盘价，但Ln和Hn则是n周内的最低价和最高价。
第二步：根据RSV计算K和D值，方法如下。
当日K值= 2/3 × 前一日K值＋1/3 × 当日的RSV值
当日D值= 2/3 × 前一日D值＋1/3 × 当日K值
在计算过程中，如果没有前一日K 值或D值，则可以用数字50来代替。
在实际使用过程中，一般是以9日为周期来计算KD线，根据上述公式，首先是计算出最近9日的RSV值，即未成熟随机值，计算公式是9日RSV = （C－L9）÷（H9－L9）× 100。其中各项参数含义在步骤一中已经提到，其次再按本步骤所示计算当日的K和D值。
需要说明的是，上式中的平滑因子2/3和1/3是可以更改的，不过在股市交易实践中，这两个值已经被默认设置为2/3和1/3。
第三步：计算J值。J指标的计算公式为：J = 3×K - 2×D。从使用角度来看，J的实质是反映K值和D值的乖离程度，它的范围上可超过100，下可低于0。
最早的KDJ指标只有K线和D线两条线，那个时候也被称为KD指标，随着分析技术的发展，KD指标逐渐演变成KDJ指标，引入J指标后，能提高KDJ指标预判行情的能力。
在按上述三个步骤计算出每天的K、D和J三个值之后，把它们连接起来，就可以看到KDJ指标线了。
python代码实现：
import pandas as pd import talib import matplotlib.pyplot as plt import matplotlib.ticker as ticker fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111) df = pd.read_csv("600276.csv") df['date'] = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0725236f1159d80bb59af3312173d69c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2260abad421c167ae44f458146d1d103/" rel="bookmark">
			物理内存不够怎么办？？？centos9下如何设置大的swap空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在做数据分析时，大家除了cpu速度不够以外，还有就是内存经常会爆掉，下面就介绍一下如何利用硬盘空间给物理内存扩容。 当然硬盘的速度要慢很多，如果要使用硬盘扩容也建议使用性能较高的ssd盘来做。
在CentOS 9系统下设置或增加大的swap空间，可以按照以下步骤进行：
方法一：使用分区创建swap 创建新的磁盘分区：
如果你有额外的硬盘空间，可以通过fdisk、parted等工具创建一个新的Linux swap类型的分区。 格式化为swap类型：
bash
mkswap /dev/your_new_partition
这里 /dev/your_new_partition 应替换为你的新分区的实际路径，例如 /dev/sda3。
激活swap分区：
swapon /dev/your_new_partition 这个是整个磁盘都用来做swap分区了，当然可以自己将磁盘分一个独立分区来做
永久启用swap：
编辑 /etc/fstab 文件，在文件中添加一行来确保系统启动时自动挂载swap分区： echo '/dev/your_new_partition none swap defaults 0 0' &gt;&gt; /etc/fstab 方法二：使用文件创建swap空间 如果你没有额外的磁盘分区可用，也可以创建一个大文件并将其用作swap空间：
创建swap文件：
fallocate -l SIZE_IN_BYTES /path/to/swapfile # 或者使用dd命令创建 dd if=/dev/zero of=/path/to/swapfile bs=1M count=SIZE_IN_MB 替换 SIZE_IN_BYTES 或 SIZE_IN_MB 为你想要的swap大小。
设置swap文件权限：
chmod 600 /path/to/swapfile #防止随意删除 格式化文件为swap类型：
mkswap /path/to/swapfile 激活swap文件：
swapon /path/to/swapfile 永久启用swap文件：
同样编辑 /etc/fstab 文件添加如下行： /path/to/swapfile none swap defaults 0 0 注意事项： 根据你的实际需求和系统内存大小来决定swap空间的大小。通常建议swap空间至少是物理RAM的两倍，但不建议超过物理RAM的8倍，尤其是对于具有大量内存的现代服务器。在操作前，请确保有足够的磁盘空间，并在执行上述命令前备份重要数据。对于生产环境，请根据官方文档和最佳实践调整swap大小。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88e0d338391a2cc5490ebfe0a692858/" rel="bookmark">
			关于“Python”的核心知识点整理大全54
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
18.4 创建其他网页
18.4.1 模板继承
1. 父模板
base.html
注意
2. 子模板
index.html
注意
18.4.2 显示所有主题的页面
1. URL模式
urls.py
2. 视图
views.py
3. 模板
topics.html
18.4.3 显示特定主题的页面
1. URL模式
urls.py
2. 视图
views.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
18.4 创建其他网页 制定创建网页的流程后，可以开始扩充“学习笔记”项目了。我们将创建两个显示数据的网 页，其中一个列出所有的主题，另一个显示特定主题的所有条目。对于每个网页，我们都将指定 URL模式，编写一个视图函数，并编写一个模板。但这样做之前，我们先创建一个父模板，项目 中的其他模板都将继承它。
18.4.1 模板继承 创建网站时，几乎都有一些所有网页都将包含的元素。在这种情况下，可编写一个包含通用 元素的父模板，并让每个网页都继承这个模板，而不必在每个网页中重复定义这些通用元素。这 种方法能让你专注于开发每个网页的独特方面，还能让修改项目的整体外观容易得多。
1. 父模板 我们首先来创建一个名为base.html的模板，并将其存储在index.html所在的目录中。这个文件 包含所有页面都有的元素；其他的模板都继承base.html。当前，所有页面都包含的元素只有顶端 的标题。我们将在每个页面中包含这个模板，因此我们将这个标题设置为到主页的链接：
base.html &lt;p&gt; 1 &lt;a href="{% url 'learning_logs:index' %}"&gt;Learning Log&lt;/a&gt; &lt;/p&gt; 2 {% block content %}{% endblock content %} 这个文件的第一部分创建一个包含项目名的段落，该段落也是一个到主页的链接。为创建链 接，我们使用了一个模板标签，它是用大括号和百分号（{% %}）表示的。模板标签是一小段代 码，生成要在网页中显示的信息。在这个实例中，模板标签{% url 'learning_logs:index' %}生成一个URL，该URL与learning_logs/urls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e88e0d338391a2cc5490ebfe0a692858/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928098b588090c3afb878bf58de76454/" rel="bookmark">
			PythonAnywhere中运行GitHub代码步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设您已经有一个GitHub仓库，并且您的PythonAnywhere项目目录名为 spb。
在GitHub上提交代码：
在本地终端中，确认所有的更改都已经提交：
git add . git commit -m "Your commit message" git push origin main 登录PythonAnywhere并设置Web应用程序：
登录到您的PythonAnywhere账户。
在Dashboard中，点击 Web 标签。
点击 Add a new web app，遵循指示选择域名，选择手动配置（Manual configuration）以及相应的Python版本。
在配置页面，记下您的源代码路径（通常是 /home/yourusername/spb）和WSGI配置文件的路径。
从GitHub克隆代码到PythonAnywhere：
在PythonAnywhere的Dashboard中，打开一个新的Bash控制台。
克隆您的GitHub仓库到指定的 spb 目录：
git clone https://github.com/yourusername/yourrepository.git /home/yourusername/spb 设置PythonAnywhere数据库：
在Dashboard中，点击 Databases 标签。
创建一个新的MySQL数据库，记下数据库名称、用户名和密码。
在Bash控制台中，使用 mysql 命令行工具导入数据库架构或运行迁移脚本。
配置虚拟环境和安装依赖：
在Bash控制台中，创建一个Python虚拟环境：
mkvirtualenv spb-venv --python=/usr/bin/python3.x # 替换x为你的Python版本 激活虚拟环境，并安装项目依赖：
workon spb-venv pip install -r /home/yourusername/spb/requirements.txt 更新Web应用程序的配置：
在 Web 配置页面，设置虚拟环境路径：
/home/yourusername/.virtualenvs/spb-venv/ 编辑WSGI配置文件，确保它指向您的Flask应用程序。这通常意味着要修改WSGI文件来导入您的应用程序。
设置文件和静态文件路径：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928098b588090c3afb878bf58de76454/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce0b5458f5cbbb6506ef5167b93e861/" rel="bookmark">
			python使用条件检查来区分不同的运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用条件检查来区分不同的运行环境是一个简单且有效的方法。在您的代码中实现这种策略，可以让您使用同一个代码库在本地和PythonAnywhere上运行，而无需更改任何代码。只需根据运行环境的不同，设置不同的环境变量即可。
以下是如何实施这种策略的具体步骤：
在PythonAnywhere上设置环境变量： 在PythonAnywhere上，您可以通过编辑 .bashrc 文件来设置环境变量。您可以在PythonAnywhere的Bash控制台中执行以下命令来编辑这个文件：
nano ~/.bashrc 在文件的底部添加如下行：
export PYTHONANYWHERE_DOMAIN='your-username.pythonanywhere.com' 保存并关闭文件（在nano编辑器中，使用CTRL + X，然后按Y，接着按Enter键）。然后，运行以下命令以应用更改：
source ~/.bashrc 检查配置是否生效 echo $PYTHONANYWHERE_DOMAIN 在您的Python代码中使用条件检查： 您提供的代码片段正是您需要在应用程序中使用的。只需确保替换 'yourPythonAnywhereUsername'、'yourPythonAnywherePassword'、'yourPythonAnywhereHost' 和 'yourPythonAnywhereDbname' 为您在PythonAnywhere上的实际数据库凭证。
import os ​ if os.environ.get('PYTHONANYWHERE_DOMAIN', None): # PythonAnywhere环境 dbuser = 'yourPythonAnywhereUsername' dbpass = 'yourPythonAnywherePassword' dbhost = 'yourPythonAnywhereHost' dbport = '3306' dbname = 'yourPythonAnywhereDbname' else: # 本地开发环境 dbuser = 'root' dbpass = 'xxxx' dbhost = 'localhost' dbport = '3306' dbname = 'spb' 在本地环境中运行代码： 当您在本地运行代码时，由于PYTHONANYWHERE_DOMAIN环境变量不存在，代码将使用else部分的配置。
在PythonAnywhere环境中运行代码： 当您在PythonAnywhere上运行代码时，PYTHONANYWHERE_DOMAIN环境变量会被设置，因此代码将使用if部分的配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce0b5458f5cbbb6506ef5167b93e861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c666ea3485c3f1df73b560b082e78004/" rel="bookmark">
			数据结构OJ实验4-队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. DS队列之银行排队 题目描述 在银行营业大厅共服务3种客户，类型为A\B\C，大厅分别设置了3个窗口分别服务三种客户，即每个窗口只服务一种客户。现有一批客户来银行办理业务，每个客户都有类型和办理业务时间。每个窗口按照客户到来的顺序进行服务。
编程实现它们的办理流程，请使用C++自带的queue必须使用队列实现，其他方法0分！
队列queue的用法如下：
1.包含头文件：#include &lt;queue&gt;
2.定义一个整数队列对象：queue&lt;int&gt; myQe;
3.定义一个整数队列对象数组：queue&lt;int&gt; myQA[10];
4.入队操作：myQe.push(itemp); //把整数itemp进入队列
5.出队操作：myQe.pop(); //把队头元素弹出队列，注意本操作不获取队头元素
6.获取队头元素： itemp = myQe.front(); // 把队头元素放入itemp中，注意本操作不弹出元素
7.判断队列是否为空：myQe.empty();//队列空则返回true，不空则返回false
输入 第一行输入先输入n表示客户数量
第二行输入每个客户的类型，数据之间用用空格隔开
第三行输入每个客户的办理时间，数据之间用用空格隔开
输出 第一行输出A类客户的平均办理时间
第二行输出B类客户的平均办理时间
第三行输出C类客户的平均办理时间
样例查看模式 正常显示查看格式
输入样例1 8
A B C B C A A A
10 20 30 40 50 60 70 80
输出样例1 55
30
40
AC代码 #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;map&gt; using namespace std; int main() { int n; cin &gt;&gt; n; queue&lt;char&gt;q; map&lt;int, int&gt;mp; for (int i = 0; i &lt; n; i++) { char x; cin &gt;&gt; x; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c666ea3485c3f1df73b560b082e78004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7444687007d5e1e9a6b5a3ea592cb377/" rel="bookmark">
			数据结构和算法笔记3：双指针法（快慢指针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 典型习题-移除元素类问题27.移除元素26.删除有序数组中的重复项80.删除有序数组中的重复项II283.移动零844.比较含退格的字符串 2. 典型习题-增加元素类题目1089.复写零 双指针法（快慢指针法）在数组、字符串和链表的操作中是非常常见的，这里结合力扣上的题进行可一下梳理，主要的思路是我们要明确快指针指的是什么，慢指针指的是什么。它可以处理的问题主要有移除元素类问题和增加元素类问题。 1. 典型习题-移除元素类问题 27.移除元素 要我们移除目标元素，返回移动后元素的新长度。
快指针：原数组的索引，这里是fast慢指针：移除后数组的索引，这里是slow 我们循环时一定是快指针遍历整个数组，然后慢指针根据条件移动，如果发现快指针不等于指定的目标元素val：nums[fast] != val，我们对当前的nums[slow]赋值为nums[fast]，让后slow自增。
class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slow = 0; for (int fast = 0; fast &lt; nums.size(); ++fast) { if (nums[fast] != val) nums[slow++] = nums[fast]; } return slow; } }; 26.删除有序数组中的重复项 要我们移除数组重复的元素，返回移动后元素的新长度。
快指针：原数组的索引，这里是fast慢指针：移除后数组的索引，这里是slow 为了看是否有重复项我们一定是比较nums[fast]和nums[fast - 1]看是否相等，如果不相等，说明不重复，我们可以把当前的nums[fast]赋值给nums[slow]，并且slow往前移动一位，为了fast-1不越界，fast的遍历应该从1开始，也是遍历整个数组，既然从1开始，slow的初始值也应该是1，因为第一个元素我们认为不需要删除。
class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int slow = 1; for (int fast = 1; fast &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7444687007d5e1e9a6b5a3ea592cb377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9a370d6b7bad5b3e00f807011ae107/" rel="bookmark">
			L1-076：降价提醒机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 小 T 想买一个玩具很久了，但价格有些高，他打算等便宜些再买。但天天盯着购物网站很麻烦，请你帮小 T 写一个降价提醒机器人，当玩具的当前价格比他设定的价格便宜时发出提醒。
输入格式： 输入第一行是两个正整数 N 和 M (1≤N≤100,0≤M≤1000)，表示有 N 条价格记录，小 T 设置的价格为 M。
接下来 N 行，每行有一个实数 Pi​（−1000.0&lt;Pi​&lt;1000.0），表示一条价格记录。
输出格式： 对每一条比设定价格 M 便宜的价格记录 P，在一行中输出 On Sale! P，其中 P 输出到小数点后 1 位。
输入样例： 4 99 98.0 97.0 100.2 98.9 输出样例： On Sale! 98.0 On Sale! 97.0 On Sale! 98.9 程序代码 #include&lt;stdio.h&gt; int main(){ int N,M; double x; scanf("%d %d",&amp;N,&amp;M); for(int i=0;i&lt;N;i++){ scanf("%lf",&amp;x); if(x&lt;M) printf("On Sale! %.1lf\n",x); } return 0; } 运行结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b4cdabb5896ae3cd0dacb7be6fe372/" rel="bookmark">
			sklearn之load_iris数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from sklearn.datasets import load_iris
from sklearn.preprocessing import MinMaxScaler
from sklearn.cluster import KMeans
iris = load_iris()
iris_data = iris['data']
iris_target = iris['target']
iris_names = iris['feature_names']
scale = MinMaxScaler().fit(iris_data)#训练模型
iris_dataScale = scale.transform(iris_data)
kmeans = KMeans(n_clusters=3,random_state=123).fit(iris_dataScale)
print(kmeans)
result = kmeans.predict([[1.5,1.5,1.5,1.5]])
print(result[0])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f6d1be17c396fed147ad33a823c4a7/" rel="bookmark">
			ubuntu安装xinetd服务报错 invoke-rc.d: policy-rc.d denied execution of restart解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载xinetd安装包 wget http://archive.ubuntu.com/ubuntu/pool/universe/x/xinetd/xinetd_2.3.15.3-1_amd64.deb
wget http://archive.ubuntu.com/ubuntu/pool/universe/n/netkit-telnet/telnetd_0.17-41_amd64.deb
2、安装
dpkg -i xinetd_2.3.15.3-1_amd64.deb telnetd_0.17-41_amd64.deb
3、如果遇到报错invoke-rc.d: policy-rc.d denied ，请尝试以下解决方案
printf '#!/bin/sh\nexit 0' &gt; /usr/sbin/policy-rc.d
chmod +x /usr/sbin/policy-rc.d
printf 'service telnet
{
disable = no
flags = REUSE
socket_type = stream
wait = no
user = root
server = /usr/sbin/in.telnetd
log_on_failure = HOST
}' &gt; /etc/xinetd.d/telnet
systemctl restart xinetd.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a001ecf4a0ea7bb5a294f9dce7b668b9/" rel="bookmark">
			数据结构OJ实验3-堆栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. DS堆栈--逆序输出（STL栈使用） 题目描述 C++中已经自带堆栈对象stack，无需编写堆栈操作的具体实现代码。
本题目主要帮助大家熟悉stack对象的使用，然后实现字符串的逆序输出
输入一个字符串，按字符按输入顺序压入堆栈，然后根据堆栈后进先出的特点，做逆序输出
stack类使用的参考代码
n包含头文件&lt;stack&gt;：#include &lt;stack&gt;
n创建一个堆栈对象s（注意stack是模板类）：stack &lt;char&gt; s;//堆栈的数据类型是字符型
n把一个字符ct压入堆栈：s.push(ct);
n把栈顶元素弹出：s.pop();
n获取栈顶元素，放入变量c2：c2 =s.top();
n判断堆栈是否空：s.empty()，如果为空则函数返回true，如果不空则返回false
输入 第一行输入t，表示有t个测试实例
第二起，每一行输入一个字符串，注意字符串不要包含空格
字符串的输入可以考虑一下代码：
#include &lt;string&gt;
int main()
{ string str;
Int len;
cin&gt;&gt;str; //把输入的字符串保存在变量str中
len = str.length() //获取输入字符串的长度
}
输出 每行逆序输出每一个字符串
样例查看模式 正常显示查看格式
输入样例1 2
abcdef
aabbcc
输出样例1 fedcba
ccbbaa
AC代码 #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main() { int t; cin &gt;&gt; t; while (t--) { string s; cin &gt;&gt; s; stack&lt;char&gt;st; for (int i = 0; i &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a001ecf4a0ea7bb5a294f9dce7b668b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ece6e6ad52a4558e8e7227e9406823d/" rel="bookmark">
			分布式【RPC 常见面试题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、注册中心 策略：服务注册原理、注册中心结构、zookeeper的原理、几个注册中心的区别、分布式算法、分布式事务。
项目细节：服务注册、服务发现、服务注销、监听机制
介绍一下服务注册中心怎么做的？
（1）服务发现：
服务注册/反注册：保存服务提供者和服务调用者的信息服务订阅/取消订阅：服务调用者订阅服务提供者的信息，最好有实时推送的功能服务路由（可选）：具有筛选整合服务提供者的能力。 （2）服务配置（不包括其它无关配置）：
配置订阅：服务提供者和服务调用者订阅微服务相关的配置配置下发（可选）：主动将配置推送给服务提供者和服务调用者 （3）服务健康检测
检测服务提供者的健康情况 一个注册中心,至少需要具备哪些条件?
（项目中RPC服务注册中心需要注意什么?）
（如果让你设计一个服务注册中心，怎么设计？）
服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。
服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。
心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。
服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。
服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。
服务查询接口：查询注册中心当前注册了哪些服务信息。
服务修改接口：修改注册中心中某一服务的信息。
注册中心单机还是分布式的，其中一个挂了怎么办？一致性，可靠性怎么保证的？超时控制，加锁和管道支持并发，单机（考虑了多机情况
常用的服务注册中心, 注册中心的差异
为什么用Zookeeper做注册中心？(优点，与其他选型对比下)
（使用zookeeper有什么好处？）
（说一下zookeeper，为什么使用zookeeper，不选其他注册中心？）
（了解Nacos和Zookeeper的区别吗？）
（为什么不选择Redis作为注册中心？（zookeeper临时节点自动宕机自动清除））
（为什么要用Zookeeper（服务注册、发现））
（Zookeeper和Eureka分别是满足CAP中的哪些）
集群一般有几个节点，为什么？
5个，宕机后选举要大于一半成为leader。
socket过程中发生的系统调用
zookeeper服务发现
zookeeper服务容灾？zookeeper服务节点挂掉之后，怎么删除它？
容灾：在集群若干台故障后，整个集群仍然可以对外提供可用的服务。
一般配置奇数台去构成集群，以避免资源的浪费。
三机房部署是最常见的、容灾性最好的部署方案。
删除：使用临时节点，会话失效，节点自动清除。
Zookeeper有几种角色？
群首（leader），追随者（follower），观察者（observer）
CAP理论解释下？P是什么？
一致性（Consistency）多个副本之间的数据一致性
可用性（Availability）在合理规定的时间内，是否能返回一个明确的结果。
分区容错性（Partition tolerance）在分区故障下，仍然可以对外提供正常的服务。
一个分布式系统在以上三个特性中：最多满足其中的两个特性。
Zookeeper集群节点宕机了怎么发现剔除的？
发现：watcher机制
剔除：临时节点？
服务熔断和服务降级有什么区别？
**服务熔断：**如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。
**服务降级：**当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
zookeeper原理？羊群效应，怎么解决，解决之后又有什么问题，又怎么解决，纯粹搞成了循环依赖了。zab协议，具体说来。
羊群效应：
ZAB算法讲一下（讲了ZAB是paxos的改版，Mysql是paxos、redis sentinel是raft、zookeeper是ZAB、ZAB的具体实现）
zk的分布式算法zab，如果选举的时候zxid都相同呢？（比较SID）
dubbo 怎么注册到zookeeper以及 dubbo 协议，zookeeper协议，
zookeeper的节点类型?（持久，临时，顺序）
分布式数据一致性协议都知道哪些（2PC 3PC Paxos）
Raft了不了解
分布式事务的几种解决方案（2PC，3PC，TCC，基于消息，然后顺带讲了一下优缺点） 分布式事务的几种方式吧（2pc、3pc、tcc、基于消息）以及区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ece6e6ad52a4558e8e7227e9406823d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7115b18abae0f9cf64fc7ce64c2bcdbe/" rel="bookmark">
			【Linux】Linux 下基本指令 -- 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是什么命令，用于什么用途，在 Linux 中，命令有其通用的格式：
command [-options] [parameter]
command：命令本身。-options：[可选，非必填]命令的一些选项，可以通过选项控制命令的行为细节。parameter[可选，非必填]命令的参数，多数用于命令的指向目标等。 语法中的[ ]，表示可选的意思。
一、ls（List Files）指令 1、语法 ls [选项] [目录或文件] 2、功能 对于 目录 ，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。 3、常用选项 -a 列出目录下的所有文件，包括以 . 开头的隐含文件。（表示 all 的意思）-d 将目录像文件一样显示，而不是显示其下的文件。 如：ls –d 指定目录-i 输出文件的 i 节点的索引信息。 如 ls –ai 指定文件-k 以 k 字节的形式表示文件的大小。ls –alk 指定文件 -l 列出文件的详细信息。（以列表（竖向排列）的形式展示内容，并展示更多内容）（语法中的选项是可以组合使用的，比如上图中的 -a 和 -l 可以组合应用。写法1：ls -l -a 写法2：ls -la 写法3：ls -al 三种写法都一样）-n 用数字的 UID,GID 代替名称，UID：用户ID，GID：组ID。（给用户看到的是名字，实际上计算机处理的是这个数字。）-F 在每个文件名后附上一个字符以说明该文件的类型，“*”表示可执行的普通文件；“/”表示目录；“@”表示符号链接；“|”表示FIFOs；“=”表示套接字(sockets)。（目录类型识别）-r 对目录反向排序。 -t 以时间排序。 -s 在l文件名后输出该文件的大小。（大小排序，如何找到目录下最大的文件） -R 列出所有子目录下的文件。(递归) -1 一行只输出一个文件。 当不使用选项和参数，直接使用 ls 命令本体，表示：以平铺形式，列出当前工作目录下的内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7115b18abae0f9cf64fc7ce64c2bcdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6947f5914f0b2895a570c2c694b42e/" rel="bookmark">
			Idea 2022.2 安装教程 安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Idea 2022.2 安装教程 安装步骤 一、下载 1、idea下载： Other Versions - IntelliJ IDEA
2、激活包下载： ( 需关注公众号下载，可私信提供 )
二、激活步骤 1、安装idea 正常安装即可。
2、执行激活脚本 解压 zip包后，执行： install-all-users.vbs ，脚本后，大概会有5-10秒的延迟。
3、脚本执行成功 4、将激活码放到idea界面 xxxx 5、激活成功 （注意： 已验证的idea版本： idea-2022.2 、idea-2023.3 都是可以的； idea-2021.2可以使用之前的 idea-eval 方法进行激活 。）
注意2： 激活成功，步骤中【二-2】的激活脚本目录，是不能删除的！否则需要重新激活。
参考资料： 激活链接请自行搜索or私信
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905ead3203d7994afbd261406fedada1/" rel="bookmark">
			qs.stringify 使用arrayFormat属性 &#43; allowDots的数据处理 - 附示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qs：将url中的参数转为对象；将对象转为url参数形式
一、介绍 1、官方文档： https://github.com/ljharb/qs
https://github.com/ljharb/qshttps://github.com/ljharb/qs
二、准备工作 1、安装依赖包 npm install qs --save 2、示例版本 "qs": "^6.11.0", 三、使用步骤 1、在单页面引入 ' echarts ' import qs from 'qs'; 2、使用 - 这里是在数据请求处理时使用的 qs.stringify(params, { arrayFormat: 'indices', allowDots: true }); 四、arrayFormat 1、参数格式 sorts: [ { name: 'sortOrder', order: 'asc', }, ], 2、属性 arrayFormat四个属性分别为 indices、brackets、repeat、comma，默认值indices
3、示例 - 这里的请求结果是以我需要的数据格式举例的，大家可根据自己的实际情况选择（根据后端需要的数据格式） 代码为qs.stringify(params, { arrayFormat: 'indices'});
1、indices 2、repeat 3、brackets
4、comma
代码为qs.stringify(params, { arrayFormat: 'indices', allowDots: true });
1、brackets 去除下标
2、indices [下标].属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/905ead3203d7994afbd261406fedada1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0193d94b8e3341e36f80d91c06a62609/" rel="bookmark">
			Oracle merge into 语句用法 Oracle merge into 批量更新 关联更新 批量修改 关联修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle merge into 语句用法 Oracle merge into 批量更新 关联更新 批量修改 关联修改 一、概述 在开发任务中，遇到一个需求，同一批次的名单；根据一定的条件判断是否存在，若存在，则进行更新操作；若不存在，进行插入操作。实现方法有两种：
1. java代码中，使用业务逻辑来判断是否存在，存在，修改；不存在，添加。
2、由于使用的Oracle数据库，可以使用merge into语句来实现批量的添加、修改操作
本文将记录和讲解merge into 语句的使用 和 mybatis中使用 merge into 语句 。
二、代码示例 1、 merge into 语法规则 MERGE INTO target_table tt -- 目标表 USING source_table st -- 关联表 ON (tt.id = st.id AND tt.age = st.age ) -- 是否唯一条件，可以是多个 WHEN MATCHED AND tt.name &lt;&gt; st.name THEN -- 1、满足条件--带额外条件 WHEN MATCHED THEN -- 2、满足条件-- 不带额外条件 UPDATE SET -- 执行更新操作，注意没有 表名 update set tt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0193d94b8e3341e36f80d91c06a62609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2f9d66e63893f5278f74422e0195e0/" rel="bookmark">
			案例081:基于微信小程序的移动平台的远程在线诊疗系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员模块的实现
科室信息管理
通知公告管理
用户信息管理
小程序会员模块的实现
系统首页
我的菜单
挂号问诊
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了微信小程序基于移动平台的远程在线诊疗系统的开发全过程。通过分析微信小程序基于移动平台的远程在线诊疗系统管理的不足，创建了一个计算机管理微信小程序基于移动平台的远程在线诊疗系统的方案。文章介绍了微信小程序基于移动平台的远程在线诊疗系统的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本微信小程序基于移动平台的远程在线诊疗系统有管理员，用户，医生三个角色。
管理员功能有个人中心，用户管理，医生管理，科室类型管理，科室信息管理，患者信息管理，通知公告管理，医院介绍管理，留言板管理，系统管理等。医生功能有科室信息管理，预约挂号管理，取消预约管理，用户问诊管理，问诊回复管理，患者信息管理，处方信息管理。用户可以对医生进行预约问诊操作和收藏操作。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得微信小程序基于移动平台的远程在线诊疗系统管理工作系统化、规范化。
系统展示 管理员模块的实现 科室信息管理 管理员可以管理科室信息，可以对科室信息添加修改删除。
通知公告管理 管理员可以对通知公告进行查询修改，删除操作。
用户信息管理 系统管理员可以对用户信息进行增删改查操作。界面如下图所示：
小程序会员模块的实现 系统首页 小程序用户是需要注册才可以进行登录的，登录后在首页可以查看用户信息，并且下面导航可以点击到其他功能模块。界面如下图所示：
我的菜单 在小程序里点击我的，会出现关于我的界面，在这里可以修改个人信息，以及可以点击其他功能模块。界面如下图所示：
挂号问诊 点击科室，可以对医生进行挂号问诊操作，还可以收藏。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2f9d66e63893f5278f74422e0195e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e72dac0c7acd6361657c08f8a3041b16/" rel="bookmark">
			Python-Selenium 调用 JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前环境：
Windows 10 + Python 3.7 + selenium==3.141.0 + urllib3==1.26.2 + Chromium 65.0.3312.0 （32 位）
在 WebDriver 中提供了执行 JavaScript 的方法：
execute_script(script, *args)，JavaScript 代码以字符串的形式构建，然后传给该方法执行。
参数说明：
script: 以字符串形式构建的 JavaScript 代码；
*args: 以可变参数形式接收参数，并将参数传递给 JavaScript 代码。在 JavaScript 代码中会以数组arguments来接收 execute_script() 方法传递的参数。
from selenium import webdriver import time if __name__ == '__main__': import os os.system('chcp 65001') os.system('taskkill /F /IM chromedriver.exe') # Chrome 路径 CHROME_PATH = r'C:\Program Files (x86)\65.0.3312.0\chrome-win32\chrome.exe' # ChromeDriver 路径 CHROMEDRIVER_PATH = r'C:\Program Files (x86)\65.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e72dac0c7acd6361657c08f8a3041b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2d0c7eb55ecac4aaa2ebe66e444830/" rel="bookmark">
			关于“Python”的核心知识点整理大全53
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
18.2.7 Django shell
注意
18.3 创建网页：学习笔记主页
18.3.1 映射 URL
urls.py
urls.py
注意
18.3.2 编写视图
views.py
18.3.3 编写模板
index.html
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
18.2.7 Django shell 输入一些数据后，就可通过交互式终端会话以编程方式查看这些数据了。这种交互式环境称 为Django shell，是测试项目和排除其故障的理想之地。下面是一个交互式shell会话示例：
(ll_env)learning_log$ python manage.py shell 1 &gt;&gt;&gt; from learning_logs.models import Topic &gt;&gt;&gt; Topic.objects.all() [&lt;Topic: Chess&gt;, &lt;Topic: Rock Climbing&gt;] 在活动的虚拟环境中执行时，命令python manage.py shell启动一个Python解释器，可使用 它来探索存储在项目数据库中的数据。在这里，我们导入了模块learning_logs.models中的模型 Topic（见1），然后使用方法Topic.objects.all()来获取模型Topic的所有实例；它返回的是一个列表，称为查询集（queryset）。 我们可以像遍历列表一样遍历查询集。下面演示了如何查看分配给每个主题对象的ID：
&gt;&gt;&gt; topics = Topic.objects.all() &gt;&gt;&gt; for topic in topics: ... print(topic.id, topic) ... 1 Chess 2 Rock Climbing 我们将返回的查询集存储在topics中，然后打印每个主题的id属性和字符串表示。从输出可 知，主题Chess的ID为1，而Rock Climbing的ID为2。 知道对象的ID后，就可获取该对象并查看其任何属性。下面来看看主题Chess的属性text和 date_added的值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2d0c7eb55ecac4aaa2ebe66e444830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a63bf543317a9a41886997113350244/" rel="bookmark">
			玩客云 青龙面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、刷机
需要的工具，镊子，双公头USB（可以自己做），U盘
青龙面板全教程 | Anubis的小窝
powersee教程
玩客云导航固件使用说明 安装教程
玩客云乱七八糟的坑 静态IP配置
玩客云第二版固件说明 docker 下载器 @powersee 😇😇😇😎😎😎 veger.ys168.com 更多内容：https://www.youtube.com/powersee
下载站 青龙安装
终端输入
docker run -dit \ --name qinglong \ --hostname qinglong \ -p 5700:5700 \ -v $PWD/docker/ql/config:/ql/config \ -v $PWD/docker/ql/log:/ql/log \ -v $PWD/docker/ql/db:/ql/db \ -v $PWD/docker/ql/scripts:/ql/scripts \ -v $PWD/docker/ql/jbot:/ql/jbot \ --restart always \ whyour/qinglong:2.11.1 命令解析：
–name qinglong：设置容器名称为qinglong
-p 5700:5700：设置端口映射为5700，可通过IP+5700访问青龙面板，要更改的只需改前面的端口号即可
-v …. 设置青龙面板的存储目录
–restart always：设置容器为开机自启
whyour/qinglong:latest：安装青龙面板最新版本，也可以指定，加版本号即可，如：whyour/qinglong:2.12.2，版本这里特别说一下，截止本文编写的时间，最新的版本是2.13.x，但是会有那么一点小Bug，所以建议不要拉最新版本，等官方稳定后再升级，目前比较稳定的是2.11.1和2.12.2，我这里安装的是2.11.1。
拉取完成之后去浏览器访问青龙面板，IP+5700即可访问
添加到主界面直接访问
面板搭建 内网穿透
在终端安装花生壳，点树莓派，选择32位花生壳客户端官方下载 - 贝锐花生壳官网
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a63bf543317a9a41886997113350244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf06c929447eabeca17dc332bfbd5bd/" rel="bookmark">
			HarmonyOS4.0系统性深入开发10卡片事件能力说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡片事件能力说明 ArkTS卡片中提供了postCardAction()接口用于卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片中可以调用。
接口定义：postCardAction(component: Object, action: Object): void
接口参数说明：
参数名参数类型必填参数描述componentObject是当前自定义组件的实例，通常传入this。actionObject是action的具体描述，详情见下表。 action参数说明：
KeyValue样例描述“action”stringaction的类型，支持三种预定义的类型：“router”：跳转到提供方应用的指定UIAbility。“message”：自定义消息。触发后会调用提供方FormExtensionAbility的onFormEvent()生命周期回调。“call”：后台启动提供方应用。触发后会拉起提供方应用的指定UIAbility（仅支持launchType为singleton的UIAbility，即启动模式为单实例的UIAbility），但不会调度到前台。提供方应用需要具备后台运行权限（ohos.permission.KEEP_BACKGROUND_RUNNING）。“bundleName”string“router” / “call” 类型时跳转的包名，可选。“moduleName”string“router” / “call” 类型时跳转的模块名，可选。“abilityName”string“router” / “call” 类型时跳转的UIAbility名，必填。“params”Object当前action携带的额外参数，内容使用JSON格式的键值对形式。"call"类型时需填入参数’method’，且类型需要为string类型，用于触发UIAbility中对应的方法，必填。 postCardAction()接口示例代码：
Button('跳转') .width('40%') .height('20%') .onClick(() =&gt; { postCardAction(this, { 'action': 'router', 'bundleName': 'com.example.myapplication', 'abilityName': 'EntryAbility', 'params': { 'message': 'testForRouter' // 自定义要发送的message } }); }) Button('拉至后台') .width('40%') .height('20%') .onClick(() =&gt; { postCardAction(this, { 'action': 'call', 'bundleName': 'com.example.myapplication', 'abilityName': 'EntryAbility', 'params': { 'method': 'fun', // 自定义调用的方法名，必填 'message': 'testForCall' // 自定义要发送的message } }); }) 使用router事件跳转到指定UIAbility 在卡片中使用postCardAction接口的router能力，能够快速拉起卡片提供方应用的指定UIAbility，因此UIAbility较多的应用往往会通过卡片提供不同的跳转按钮，实现一键直达的效果。例如相机卡片，卡片上提供拍照、录像等按钮，点击不同按钮将拉起相机应用的不同UIAbility，从而提升用户的体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf06c929447eabeca17dc332bfbd5bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b9acf25ac9f5a0518fd9802b1f393d/" rel="bookmark">
			【AIGC-图片生成视频系列-2】八仙过海，各显神通：AI生成视频相关汇总剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 生成视频中图像的一致性
二. 生成视频中的运动控制注入
移步公众号 「AI杰克王」，更多干货
最近「图片生成视频系列」层出不穷，我拜读并结合实践（对，就是手撕代码，有开源就撕），并对以下几篇文章的相似点以及关键点稍微做个总结：
一. 生成视频中图像的一致性 在图像生成视频的这个过程中，维持生成视频中图像的一致性是个很大的挑战，毕竟我们都不是很能接受，随着视频播放，画风逐渐不对劲。。。
因此，“八仙过海，各显神通”。
1.1 LivePhoto通过引入Reference latent, 并与输入Unet的噪声在通道维度cat操作，同时利用Content Encoder 把输入图片信息注入到Unet网络的每一层（down block, mid block, up block）中，利用‘双保险’来维持生成视频中图像的一致性。
LivePhoto: Real Image Animation with Text-guided Motion Control
1.2 DreaMoving利用Content Guider把人脸信息注入到Unet网络的每一层（down block, mid block, up block）中。其实这里Content Guider的作用与之前腾讯的工作IPAdapter 有点类似，利用IPAdapter的保持“概念”一致的能力来稳住生成视频中图像的一致性。
DreaMoving: A Human Dance Video Generation Framework based on Diffusion Models
1.3 MagicAnimate提出一个Appearance Encoder来专门保留人物的ID 信息，并把相关信息注入到Unet网络的（mid block 和up block）层，以此保证生成视频中人物ID一致性。
MagicAnimate: Temporally Consistent Human Image Animation using Diffusion Model
1.4 Animate Anyone 的做法和MagicAnimate类似, 也是专门训练了一个ReferenceNet, 用来维持Reference Image的人物形象的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b9acf25ac9f5a0518fd9802b1f393d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab50169e9a8650c018333e39c597a082/" rel="bookmark">
			Fortran 编译后Dll依赖问题（libifcoremd.dll）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VS里，点击运行按钮，程序正常运行。
在exe文件目录中，双击exe运行，提示缺少libifcoremd.dll文件，经查阅资料和以往的经验，解决方法如下：
红色是默认的，绿色是能够正常运行的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182dbed1a7874673d9a8f74cbbee84a4/" rel="bookmark">
			配置打开QT designer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在PyCharm中配置打开Qt Designer的外部工具，可以遵循以下步骤。这个配置将允许你直接从PyCharm打开Qt Designer，编辑.ui文件。
打开PyCharm的设置: 选择File &gt; Settings（在macOS上是PyCharm &gt; Preferences）。
导航到外部工具: 在设置中找到Tools &gt; External Tools。
添加新的外部工具:
点击左下角的加号（+）添加新工具。为工具设置Name（例如：Open in Qt Designer）。可以创建一个新的Group（例如：Qt Tools）或将其放入现有组中。 配置工具设置:
在Program字段中，输入Qt Designer的完整路径。这个路径取决于你的Qt安装位置，如果你使用的是虚拟环境并且Qt Designer与之绑定，确保使用的是正确的环境路径。在Windows上通常是[你的Qt安装目录]/5.x/qtcreator/bin/designer.exe，在macOS上可能是/usr/local/Cellar/qt/5.x/bin/designer（如果你使用Homebrew安装的话），或者是[你的Qt安装目录]/Qt Creator.app/Contents/MacOS/Designer。在Arguments字段中，输入$FileName$。这会将当前选中的.ui文件作为参数传递给Qt Designer。在Working directory字段中，输入$FileDir$。这将设置Qt Designer的工作目录为当前文件所在的目录。 保存设置: 点击OK来保存你的新外部工具配置。
使用新配置的工具: 你现在可以在项目视图中选择任何.ui文件，右击选择External Tools &gt; Qt Tools &gt; Open in Qt Designer来打开Qt Designer。
确保你的Qt Designer可以独立运行，并且PyCharm配置的路径是正确的。如果你安装了PyQt5但是没有安装Qt Designer，可能需要单独安装Qt的完整开发包，或者单独安装Qt Designer。使用命令pip install pyqt5-tools安装PyQt5的工具集可能会给你提供Qt Designer（取决于你的操作系统和配置）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69dce2de3d017aa3138819ce802c048a/" rel="bookmark">
			Hive自定义函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.hive函数各种命令 查看系统自带的函数 hive&gt; show functions; -- 显示自带的函数的用法 hive&gt; desc function upper; -- 详细显示自带的函数的用法 hive&gt; desc function extended upper; -- 添加jar包到hive中 add jar /data/xx.jar; -- 创建自定义函数 create function 函数名 as "函数类名"; -- 一次性直接添加自定义函数 create function 函数名 as "函数类名" using jar "hdfs://mycluster/xxx.jar"; -- 删除函数 Drop function 函数名; -- 列出jar包详情 list jars; -- 删除jar包 delete jars /data/xxx.jar; 2.自定义函数 1）Hive 自带了一些函数，比如：max/min等，但是数量有限，自己可以通过自定义UDF来方便的扩展。
2）当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。
3）根据用户自定义函数类别分为以下三种：
（1）UDF（User-Defined-Function）
一进一出
（2）UDAF（User-Defined Aggregation Function）
聚集函数，多进一出
类似于：count/max/min
（3）UDTF（User-Defined Table-Generating Functions）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69dce2de3d017aa3138819ce802c048a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10d02d25bf54e0eecc34fd1a447e02f/" rel="bookmark">
			Hive生产调优介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Fetch抓取 Fetch抓取是指，Hive中对某些情况的查询可以不必使用MapReduce计算。例如：SELECT * FROM employees;在这种情况下，Hive可以简单地读取employee对应的存储目录下的文件，然后输出查询结果到控制台。
在hive-default.xml.template文件中hive.fetch.task.conversion默认是more，老版本hive默认是minimal，该属性修改为more以后，在全局查找、字段查找、limit查找等都不走mapreduce。
&lt;property&gt; &lt;name&gt;hive.fetch.task.conversion&lt;/name&gt; &lt;value&gt;more&lt;/value&gt; &lt;description&gt; Expects one of [none, minimal, more]. Some select queries can be converted to single FETCH task minimizing latency. Currently the query should be single sourced not having any subquery and should not have any aggregations or distincts (which incurs RS), lateral views and joins. 1. none : disable hive.fetch.task.conversion 2. minimal : SELECT STAR, FILTER on partition columns, LIMIT only 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10d02d25bf54e0eecc34fd1a447e02f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8086fe41c914ac8e1ef9ede998cbffd6/" rel="bookmark">
			2024最新Java基础面试题大全（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、SpringBoot 启动方式2、Redis 实现持久化的方式3、MVC、MVVM、MVP是什么，区别MVC：MVP：MVVM：MVP与MVC区别：MVVM与MVP区别 4、JDBC 操作步骤5、Object 类常用的方法有哪些6、StringBuffer、StringBuilder7、Super 和 this 关键字的区别8、线程同步的方法8、线程同步的方法 1、SpringBoot 启动方式 通过 Main 方法启动
SpringApplication.run(Xxxx.class, args); 通过命令行 java -jar 的方式
把项目打成 jar 包，用 java -jar 的方式运行 通过Spring - boot - pluging 方式启动
需要写 maven 配置
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; 因为指定了父模块 spring-boot-starter-parent 所以不需要指定插件版本
执行
mvn spring-boot:run 2、Redis 实现持久化的方式 有两种持久化的方式，分别是 rdb 和 aof，
rdb 默认方式，snapshotting（快照）方式，将内存中以快照的方式写入二进制文件中，默认是 dump.rdb ，我们可以通过设置自动做快照持久化的方式，可以配置 redis在n秒内如果超过 m 个key 修改，就自动快照append-only file （aof方式），reids 会将每一个收到的命令通过 write 函数追加到命令中，当redis 重启后，会重新执行文件保存好的命令，并重新建立数据内容，apeendonly.aof 不是立即写入磁盘的，是通过配置文件修改强制写到磁盘的。 3、MVC、MVVM、MVP是什么，区别 https://www.jianshu.com/p/ff6de219f988
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8086fe41c914ac8e1ef9ede998cbffd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aab85df161b5d34f23e90176309e6f1/" rel="bookmark">
			算法题明明的随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一行先输入随机整数的个数 N 。 接下来的 N 行每行输入一个整数，代表明明生成的随机数。 具体格式可以参考下面的"示例"。
import java.util.Iterator;
import java.util.Scanner;
import java.util.TreeSet;
// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
TreeSet set = new TreeSet();
//输入
for(int i = 0; i &lt; num; i++){
set.add(sc.nextInt());
}
//输出
Iterator iterator = set.iterator();
while (iterator.hasNext()){
System.out.println(iterator.next());
}
}
}
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/19/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>