<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6707fb7e3bb571813104fd798061f0/" rel="bookmark">
			Layui练习(读取mysql数据库表并导出为word)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Layui的练习(读取mysql数据库表并导出为word) 本Demo主要是为了练习layui的使用(Layui+SSH)。
整体流程 页面首先将数据库的所有表名加载到下拉框中，由我们手动选择数据库表之后点击查询，然后将数据库表查询出来，利用分页查询，防止表中数据量过大造成浏览器卡死的情况，加载完成之后，依据是否需要进行导出，点击导出之后利用POI将数据库表导出到word文档中。
页面部分 html部分 &lt;hr align=center width=100% color=black size="1" style="height: 3px;color: black"&gt; &lt;form class="layui-form" action=""&gt; &lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;选择数据表&lt;/label&gt; &lt;div class="layui-input-inline"&gt; &lt;select id="select" name="modules" lay-filter="tablename" lay-verify=""&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="button" id="query" class="layui-btn layui-btn-normal" style="width: 70px;height: 35px;margin-left: 10px" onclick="xxx()"&gt;查询&lt;/button&gt; &lt;button type="button" class="layui-btn layui-btn-normal" style="width: 70px;height: 35px;margin-left: 10px" onclick="word()"&gt;导出&lt;/button&gt; &lt;table id="tableinfo" lay-filter="test"&gt;&lt;/table&gt; js部分 预加载部分，声明Layui模块化，同时从后台获取数据库中的所有数据表
$(function () { layui.use(['form','table'],function () { form = layui.form; var table = layui.table; }); $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6707fb7e3bb571813104fd798061f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2034ab6f931c721409a3846915d41dd9/" rel="bookmark">
			vue&#43;element-UI表格（Table）组件中鼠标（hover）悬停、悬浮时样式的修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue+Element-Ui表格（Table）组件中鼠标（hover）悬停、悬浮时样式的修改 element悬停本身的样式：
修改后的效果
颜色可以换成你自己需要的颜色，我写的这个颜色是真的难看，哈哈哈哈
scss中写法（不会影响其他页面中的表格样式）
&lt;style lang="scss" scoped&gt; //表格鼠标悬停的样式（背景颜色） /deep/ { .el-table { tbody tr { &amp;:hover { td { background-color: #2cce34; } } } } } //表格鼠标悬浮时的样式 （高亮） /deep/ { .el-table--enable-row-hover { .el-table__body tr { &amp;:hover { background: rgb(184, 224, 250); border: 1px solid #313463; } } } } &lt;/style&gt; css写法（会影响其他页面中的表格样式）,可以用一个div把表格包起来给个class名，然后应该就不会影响其他页面中的表格样式了
&lt;style&gt; /* 表格鼠标悬浮时的样式（高亮） */ .el-table--enable-row-hover .el-table__body tr:hover { background: rgb(184, 224, 250); border: 1px solid #313463; } /*表格鼠标悬停的样式（背景颜色）*/ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2034ab6f931c721409a3846915d41dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2002066f87530c6677d99e6efeae6d35/" rel="bookmark">
			排障集锦：九九八十一难之第三难！搭建DNS错误：Host xxxx not found: 2(SERVFAIL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Host www.shang.com not found: 2(SERVFAIL)
错误原因： /var/named/下面xxx.com.zone的权限不够
如：
-rw-r-----. 1 root named 170 Dec 12 18:19 xxx01.com.zone
-rw-r-----. 1 root root 170 Dec 12 18:58 xxx.com.zone
此时，第一个就可以解析出来，第二个解析不出来
解决办法： [root@localhost named]# chown -R root.named shang.com.zone [root@localhost named]# chgrp named shang.com.zone '或者用这个' [root@localhost named]# ls -l -rw-r-----. 1 root named 170 Dec 12 18:19 xxx.com.zone 记得再重新启动重启服务
所以以后cp模板的时候记得将-p 带着文件属性复制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e469a34fd25b4eafe37737cb81947770/" rel="bookmark">
			Python3进阶(六) | 深入理解python多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 什么是多线程?2. Python线程3. 线程模块3.1 threading 模块创建线程3.2 线程同步3.3 线程优先级队列（ Queue） 1. 什么是多线程? 在学习python3多线程之前我们来看看什么是多线程?
线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并行的线程中。
以上是官网给出的解释
多线程类似于同时执行多个不同程序,同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
线程可以被抢占（中断）。
在其他线程正在运行时，线程可以暂时搁置/休眠。
线程可以分为:
内核线程：由操作系统内核创建和撤销。用户线程：不需要内核支持而在用户程序中实现的线程。 2. Python线程 Python中使用线程有两种方式：函数或者用类来包装线程对象。
函数式：调用 _thread模块中的start_new_thread()函数来产生新线程。语法如下:
_thread.start_new_thread ( function, args[, kwargs] ) 参数说明:
function - 线程函数。args - 传递给线程函数的参数,其必须是个tuple类型。kwargs - 可选参数。 示例:
3. 线程模块 Python3 通过两个标准库 _thread和 threading提供对线程的支持。
_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。
threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：
threading.currentThread(): 返回当前的线程变量。threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:
run(): 用以表示线程活动的方法。 start():启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e469a34fd25b4eafe37737cb81947770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba3d8bd811d9472bc5589c6b4addbbb/" rel="bookmark">
			R语言学习之科学计算——求导与积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 说明1 R中的表达式2 求导2.1 求一阶导数2.2求高阶导数2.3 求偏导数 3 积分3.1 定积分3.2 不定积分 说明 R语言的版本为4.0.2，IDE为Rstudio，版本为1.3.959。学习过程中参考了以下文章：
R笔记（1）：formula和Formula（CSDN）
R语言笔记.formula（知乎）
R语言进阶之五：表达式、数学公式与特殊符号（CSDN）
R语言的导数计算（CSDN）
积分_R（CSDN）
1 R中的表达式 要进行求导或者积分运算，首先需要有一个表达式，注意，是表达式，而不是实现了这个表达式的函数，这就要用到 expression 对象。
使用expression() 函数可以创建expression 对象，expression 对象实际上是以列表的形式储存表达式的，例如创建以下表达式：
y = x 3 + s i n ( x ) + e x y = x^{3}+sin(x)+e^{x}\, y=x3+sin(x)+ex
当然除了使用 expression() 函数创建表达式之外，还可以使用formula() 函数创建公式，二者都可以当成参数进行求导和积分运算。
# f1,f2,f3分别创建了表达式、公式和函数 # 区别是函数可以传参并运行，前面两种不行 f1 &lt;- expression(y=x^3+sin(x)+exp(x)) f2 &lt;- formula(y~x^3+sin(x)+exp(x)) f3 &lt;- function(x) x^3 + sin(x) + exp(x) mode(f1) mode(f2) mode(f3) # 输出 # &gt; mode(f1) # [1] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ba3d8bd811d9472bc5589c6b4addbbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf89a4485fe915863b50b82d7b17121/" rel="bookmark">
			软件构造第二章复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1软件生命周期与配置管理 1.传统软件模型 软件的产生过程可以分为以下两种：线性过程与迭代过程
软件模型主要有以下两种：V字模型与螺旋模型
2.软件配置管理(SCM)和版本更替(VCS) SCM：用于追踪和控制软件的变化
VCS：版本控制与基线的确立，一般分为以下三种
(1).本地：仓库存储于开发者本地机器，无法协作与共享
(2).集中式：仓库存储于独立的机器，支持多开发者之间的协作
(3).分布式：仓库存储于独立的机器以及每个开发者的本地机器，进一步方便协作(如Git)
3.Git的使用教学（重点） Git的基本组成 Git可以分为本地仓库和远程仓库，而Git在本地的仓库主要又可以分为以下三部分：
(1).workspace(工作目录：本地文件系统)
(2).staging(暂存区：隔离工作仓库和目录，增强操作的灵活性)
(3).local repository(本地仓库)
Git的基本操作 1.获得项目的Git仓库
(1).到此项目所在的目录，执行git init(也就是初始化仓库)
(2).利用git add 命令进行跟踪提交，例如：git add --.c(跟踪一个.c文件)
(3).通过git commit 命令提交到本地仓库，一般是：git commit -m “版本号”
注：
(1).在Git中commit文件时，只存储了发生变化的文件，不变化的文件则不存储
(2).可以利用git status命令来检查当前文件的状态
2.对远程仓库的操作
(1).添加一个远程仓库：git remote add [name] (仓库名称) [url] (具体网址)
(2).将本地仓库的数据推送到远程仓库：git push [name] [branch] (当前分支)
(3).从一个仓库或本地分支拉取并整合代码：git pull
3.分支的创建与合并
在默认情况下，我们都是在master分支下进行操作的
(1).创建并同时切换到新分支01：git checkout -b 01
(2).返回master分支：git checkout master
(3).j将master分支与01分支合并(假设此时我们在master分支上)：git merge 01
(4).删除分支01：git branch -d 01
2.2软件构造的过程，系统和工具 软件构造基本可以分为以下五个过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf89a4485fe915863b50b82d7b17121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710762023bfd8f2508dfb2ef593254b6/" rel="bookmark">
			软件测试校招面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考完研开始学习测试，凭借大学学的计算机基础+复习+深入学习。面试很多家公司。过程有点煎熬。最后也拿到不错的几个offer。薪资福利不错。平台也能接受（比不上bat哈）。最后统统白费，随意调剂一个学校，被录取，还是选择去读研究生。希望三年后，能够更好。
面经如下（有点乱）
字节跳动面试（秋招随意投+面试，当时考研，因为没准备，没过，但是很简单）
线程和进程
js闭包
http分为那几个部分
三次握手详细过程
贪吃蛇核心算法(为什么不自己写)
智慧党建前端项目
加入工作室有没有应用于实践的代码
前端包括那几个部分。&lt;head&gt;和《body》里面包括哪些内容
http返回码（404是访问页面不存在，505服务不可用）
各大浏览器区别
小米面试（前端，秋招随意投+面试，当时考研，因为没准备，没过，但是很简单）：
写一个闭包（闭包是什么，闭包的优缺点）
浏览器有哪些缓存
两个字符串算法题（公共的最长长度）
position的取值，水平垂直居中的代码
es6
流行框架
js一般，算法还行 css不熟
安克创新集团（因为考研，放弃实习）：
怎么测试一个登录网页（用户名、密码、登录按钮）
1、先看正常密码和用户名，看登录按钮是否提交到正确的地方
2、考虑用户名不存在（电话号码还是邮箱，是否有识别出区别，对于邮箱@符合的识别。电话号码分区号（182 134等等）可以减少服务器那边的压力，因为在本地可以发生错误了）
3、密码不正确情况（密码的长度大小是否越界、特殊字符、与账号是否匹配。）
4、在密码和用户号里面写sql语句会怎么样，是否返回出一堆数据。
要想好测试的发展方向，职业规划怎么样。虽然远离了代码，但是要了解各种语言的特点，在于广度。测完也可以往高层发展，自动化测试（测试开发师）、测试总监。
怎么理解面向对象的？
等价类划分
北京星云互联科技有限公司（寒假找实习）
1、什么是软件测试
2、怎么测试一个登录页面
3、测试用例包括那几个方面
4、使用过什么数据库
5、两个表连接有那些方法，有什么关键字
6、liunx有使用过吗？阻止火狐浏览器访问用什么命令。
7、为什么走软件测试？
8、你了解软件测试的工作状态吗？
长沙郎xxx公司（寒假实习，不难）：
笔试：
1、两个表连接的语句
2、软件测试生命周期
3、写出软件测定用例
4、说出黑盒和白盒测试的区别
面试：
1、为什么走软件测试
2、之后职业规划 目标
3、软件测试是什么？
4、你使用过什么数据库？
5、有过测试经验吗？
6、软件测试有哪些方法
7、软件测试一个过程？
同花顺面试：（过了）
1、怎么测试一个搜索框（用了模拟匹配）
2、你对测试方法了解哪些
3、你怎么测试你那些项目的，用了什么方法
4、你担任班干部，你有什么想法
5、你对加班的看法
6、你对你自己的评价
7、你谈谈一下你对测试这方面了解的知识情况
8、你说一下自动化测试这方面 你的了解
9、你对同花顺的了解，有没有下载过同花顺app
10、其他业务方面
同花顺hr面试:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710762023bfd8f2508dfb2ef593254b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e403bb55cbc22483f4527d546edddc/" rel="bookmark">
			EEGLAB安装、EDF数据导入、EEG预处理（Matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 下载和安装下载安装遇到问题及解决方案 导入EDF数据EEG预处理 下载和安装 下载 链接：https://pan.baidu.com/s/17eMT6B7LgZ4PyqWvD5ixmg
提取码：12gz
安装 第一步： 将下载下来的文件解压，修改名称为eeglab，将此文件夹存放在matlab的安装目录里的toolbox文件夹下，下图是我的路径，需要拷贝到自己相对应的路径中
第二步： 打开Matlab软件，点击主页中的设置路径
设置路径点击添加并包含子文件夹，将eeglab文件夹添加进来，保存然后退出
第三步： 测试，在Matlab运行界面输入eeglab回车
如果出现如下界面，则安装成功
遇到问题及解决方案 遇到问题：添加EEGLAB无法保存路径pathdef.m无法保存的问题
解决方法：通过按照提示把 …\MATLAB\R2016b\toolbox\local 里的pathdef.m拷贝到C:\Program Files\MATLAB\R2016b\bin文件夹下，再次添加就可以了(选择自己的路径)
导入EDF数据 第一步： 下载Biosig包并拷贝到eeglab中
链接：https://pan.baidu.com/s/1MQge_pGMc_cBYfTqvkmAfQ
提取码：ppjg
将下载并解压下来的biosig包拷贝到eeglab文件夹下的plugins文件夹下
第二步： 打开EEGLAB处理界面之后，点击File选择Import data，然后选择Using the BIOSIG interface，然后选择你的 .EDF数据，打开即可
接下来一路点击ok即可
打开界面如下图
第三步： 绘图
点击Plot，然后选择Channel data（scroll）
绘图如下：
EEG预处理 参考如下：
EEGLAB中文操作手册
链接：https://pan.baidu.com/s/1HxqIiHPMW98muVlkULV9mg
提取码：tn19
我的处理过程如下图：
Adjust功能需要导入Adjust包
链接：https://pan.baidu.com/s/1avv6Tp54bltc2O1C-Av5fg
提取码：yvcd
还是解压后拷贝到eeglab文件夹下的plugins文件夹中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0088693baee66dea58c3152ec59d46/" rel="bookmark">
			ECCV 2020 论文汇总（注意力模型、事件相机、知识蒸馏、图像去雾去雨去噪、图像超分辨率、语义分割，等方向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECCV 2020 论文汇总 （注意力模型、事件相机、知识蒸馏、图像去雾去雨去噪、图像超分辨率、语义分割，等方向）
[oral, spotlight]
[Post]
[Dehazing]
[Enhancement]
[Dinoising]
[Deraining]
[Event]
[Attention]
[Super-Resolution]
[Wavelet]
[Bayesian]
[Semantic Segmentation]
[Distillation]
[oral, spotlight] AiR: Attention with Reasoning CapabilityInvertible Image RescalingEnd-to-End Object Detection with TransformersRewriting a Deep Generative ModelConditional Convolutions for Instance SegmentationContent-Aware Unsupervised Deep Homography EstimationGradient Centralization: A New Optimization Technique for Deep Neural NetworksLearning Stereo from Single ImagesDiffraction Line ImagingSemantic Flow for Fast and Accurate Scene ParsingSelf-Challenging Improves Cross-Domain GeneralizationExploiting Deep Generative Prior for Versatile Image Restoration and ManipulationOrientation-aware Vehicle Re-identification with Semantics-guided Part Attention NetworkMining Cross-Image Semantics for Weakly Supervised Semantic SegmentationTowards Streaming Image UnderstandingForkGAN: Seeing into the Rainy NightTopoGAN: A Topology-Aware Generative Adversarial NetworkExchNet: A Unified Hashing Network for Large-Scale Fine-Grained Image Retrieval [Post] Convolutional Occupancy NetworksCircumventing Outliers of AutoAugment with Knowledge DistillationTuiGAN: Learning Versatile Image-to-Image Translation with Two Unpaired ImagesGAN Slimming: All-in-One Unified GAN CompressionBinarized Neural Network for Single Image Super ResolutionSingle-Image Depth Prediction Makes Feature Matching Easier [Dehazing] Nighttime Defogging Using High-Low Frequency Decomposition and Grayscale-Color NetworksHardGAN: A Haze-Aware Representation Distillation GAN for Single Image DehazingPhysics-based Feature Dehazing Networks [Enhancement] PieNet: Personalized Image Enhancement NetworkMulti-level Wavelet-based Generative Adversarial Network for Perceptual Quality Enhancement of Compressed VideoGlobal and Local Enhancement Networks For Paired and Unpaired Image EnhancementLearning Enriched Features for Real Image Restoration and EnhancementEarly Exit Or Not: Resource-Efficient Blind Quality Enhancement for Compressed ImagesLow light video Enhancement using Synthetic Data Produced with an Intermediate Domain MappingURIE: Universal Image Enhancement for Visual Recognition in the WildDynamic Low-light Imaging with Quanta Image Sensors [Dinoising] Reconstructing the Noise Manifold for Image DenoisingBurst Denoising via Temporally Shifted Wavelet TransformsRobust and On-the-fly Dataset Denoising for Image ClassificationLearning Graph-Convolutional Representations for Point Cloud DenoisingStochastic Frequency Masking to Improve Super-Resolution and Denoising NetworksSpatial-Adaptive Network for Single Image DenoisingUnpaired Learning of Deep Blind Image DenoisingSpatial Hierarchy Aware Residual Pyramid Network for Time-of-Flight Depth DenoisingA Decoupled Learning Scheme for Real-world Burst Denoising from Raw ImagesPractical Deep Raw Image Denoising on Mobile Devices [Deraining] Beyond Monocular Deraining: Paired Rain Removal Networks via Unpaired Semantic UnderstandingRethinking Image Deraining via Rain Streaks and VaporsForkGAN: Seeing into the Rainy Night [Event] A Differentiable Recurrent Surface for Asynchronous Event-Based DataLearning Modality Interaction for Temporal Sentence Localization and Event Captioning in VideosTraffic Accident Analysis by Cause and Effect Events LocalizationHow to Train Your Event Camera Neural Network [paper]Entropy Minimisation Framework for Event-based Vision Model EstimationEvent-based Asynchronous Sparse Convolutional NetworksREMIND Your Neural Network to Prevent Catastrophic ForgettingLearning Event-Driven Video Deblurring and InterpolationLearning to See in the Dark with EventsCLAWS: Clustering Assisted Weakly Supervised Learning with Normalcy Suppression for Anomalous Event DetectionStereo Event-based Particle Tracking Velocimetry for 3D Fluid Flow ReconstructionGlobally-Optimal Event Camera Motion EstimationJointly learning visual motion and confidence from local patches in event camerasSpike-FlowNet: Event-based Optical Flow Estimation with Energy-Efficient Hybrid Neural NetworksEvent Enhanced High-Quality Image RecoveryRhyRNN: Rhythmic RNN for Recognizing Events in Long and Complex Videos [Attention] Example-Guided Image Synthesis across Arbitrary Scenes using Masked Spatial-Channel Attention and Self-SupervisionUnsupervised Domain Attention Adaptation Network for Caricature Attribute RecognitionHistory Repeats Itself: Human Motion Prediction via Motion AttentionCAFE-GAN: Arbitrary Face Attribute Editing with Complementary Attention FeatureSupervised Edge Attention Network for Accurate Image Instance SegmentationSPAN: Spatial Pyramid Attention Network for Image Manipulation DetectionForecasting Human-Object Interaction: Joint Prediction of Motor Attention and Actions in First Person VideoAn Attention-driven Two-stage Clustering Method for Unsupervised Person Re-IdentificationSpatiotemporal Attention Cell Search for Video ClassificationLearning Trailer Moments in Full-Length Movies with Co-Contrastive AttentionDeep Surface Normal Estimation on the 2-Sphere with Confidence Guided Semantic AttentionAttention-Based Query Expansion LearningAttention-Driven Dynamic Graph Convolutional Network for Multi-Label Image RecognitionDA4AD: End-to-end Deep Attention Aware Features Aided Visual Localization for Autonomous DrivingFew-shot Action Recognition via Permutation-invariant AttentionOrientation-aware Vehicle Re-identification with Semantics-guided Part Attention NetworkSingle Image Super-Resolution via a Holistic Attention NetworkSOLAR: Second-Order Loss and Attention for Image RetrievalGATCluster: Self-Supervised Gaussian-Attention Network for Image ClusteringCross-Attention in Coupled Unmixing Nets for Unsupervised Hyperspectral Super-ResolutionMonocular Expressive Body Regression through Body-Driven AttentionDeep Reinforced Attention Learning for Quality-Aware Visual RecognitionCharacter Region Attention For Text SpottingTake an Emotion Walk: Perceiving Emotions from Gaits Using Hierarchical Attention Pooling and Affective MappingEnd-to-End Low Cost Compressive Spectral Imaging with Spatial-Spectral Self-AttentionSpatial Attention Pyramid Network for Unsupervised Domain Adaptation [paper]Semantic Line Detection Using Mirror Attention and Comparative Ranking and MatchingLook here!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0088693baee66dea58c3152ec59d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8949b95d7320c0ed4e6b2545962f70/" rel="bookmark">
			**数据就是一个个表格组成的吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据就是一个个表格组成的吗？
数据的含义：“数据是指对客观事件进行记录并可以鉴别的符号,是对客观事物的性质、状态以及相互关系等进行记载的物理符号或这些物理符号的组合。它是可识别的、抽象的符号。 它不仅指狭义上的数字,还可以是具有一定意义的文字、字母、数字符号的组合、图形、图像、视频、音频等,也是客观事物的属性、数量、位置及其相互关系的抽象表示。例如,“0、1、2…`”、“阴、雨、下降、气温”“学生的档案记录、货物的运输情况”等都是数据。数据经过加工后就成为信息。 在计算机科学中,数据是指所有能输入到计算机并被计算机程序处理的符号的介质的总称,是用于输入电子计算机进行处理,具有一定意义的数字、字母、符号和模拟量等的通称。现在计算机存储和处理的对象十分广泛,表示这些对象的数据也随之变得越来越复杂。”
什么是表格？
表格，又称为表，既是一种可视化交流模式，又是一种组织整理数据的手段。人们在通讯交流、科学研究以及数据分析活动当中广泛采用着形形色色的表格。
所以通过合理的运用表格，我们可以让管理者更为方便，更为系统的管理和统计。
关于类和对象，可以理解为表结构对应着类，而一行数据对应着对象。所谓表结构就是字段，根据这些字段，我们可以不断地添加新的记录，比如在eclipse中就可以新建一个类，就可以在其中加入字段，可以是汉字，但在前面要加上字符类型，这样就吧类的基本结构定义好了。当然，除了字段以外还可以添加方法。所以说，类适合表结构对应的。
上面这个雇员表，可以将公司所有员工信息“结构化”、“标准化”，让管理者可以方便的进行统计和管理。
我们也经常将表中的“列”，叫做“字段”，英文中统一叫做“field”。显然，field定义了表的结构。我们可以通过增加新的field(列)，让表中所有的行增加数据面向对象编程中，类对应表的结构（表的field），我们可以定义出“雇员类”：通过上图，可以看到，雇员类和雇员表的结构完全一样。只不过，雇员类增加了数据的类型而已。
表格的动作和类的方法每个公司的雇员都要有相关的动作。
当然，我们也可以根据需求，为雇员定义多个动作。比如：午休、提交工作日志、领取工资等等。
对象对应“表中的行数据”下面三句话大家记住：
表结构对应：类结构一行数据对应：一个对象表中所有数据对应：这个类的所有对象
表格是用来存储数据的，对象也是用来存储数据的，所以表格与对象存在对应关系，不过，需要注意的是，对象里可以新增方法，而表格是没有方法的，表格只能够存储固定的数据。对象可以新增方法，方法可以将数据“活起来”。这就是对象更加强大的功能所在。大家在后续学编程的过程中会逐步深入理解 参考文献：
https://blog.csdn.net/wangpaichengxu/article/details/100078192
https://blog.csdn.net/tianwanli123/article/details/100094570?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
https://blog.csdn.net/guziG/article/details/100097589
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11bd2363ba8bccdd8cba753601395167/" rel="bookmark">
			易语言调用反馈事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用反馈事件 真为同步发送方式 假为异步投递方式 不过都是返回0 默认采用发送方式传递事件。 也就是同步
默认采用异步投递方式更新界面。 也就是异步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904e526942723c62c2d54df9677cceee/" rel="bookmark">
			2019-CS224n-Assignment1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Assignment1(点击下载) 的任务是探索词向量。以基于计数的共现矩阵和基于预测的word2vec两种方式，计算词的相似度，研究近义词、反义词等等性质，从代码层面来理解它们，有更深刻的记忆。
词向量 词向量是下游NLP任务(如问答、文本生成、翻译等) 的基本组件，词向量的好坏能在很大程度上影响下游任务的性能。这里我们将探索两类词向量：共现矩阵 和 word2vec 。
术语解释： “word vectors” 和 “word embeddings” 通常可以互换使用。“embedding” 这个词的内在含义是将词编码到一个底维空间中。“概念上而言，它是指把一个维数为所有词的数量的高维空间嵌入到一个维数低得多的连续向量空间中，每个单词或词组被映射为实数域上的向量。”——维基百科
Part 1：基于计数的词向量 大多数词向量模型都是基于一个观点：
You shall know a word by the company it keeps (Firth, J. R. 1957:11)
大多数词向量的实现的核心是 相似词 ，也就是同义词，因为它们有相似的上下文。这里我们介绍一种策略叫做 共现矩阵
这部分要实现的是，给定语料库，根据共现矩阵计算词向量，得到语料库中每个词的词向量，流程如下：
计算语料库的单词集计算共现矩阵使用SVD降维分析词向量 问题1.1：实现 dicintct_words 计算语料库的单词数量、单词集
def distinct_words(corpus): """ Determine a list of distinct words for the corpus. Params: corpus (list of list of strings): corpus of documents Return: corpus_words (list of strings): list of distinct words across the corpus, sorted (using python 'sorted' function) num_corpus_words (integer): number of distinct words across the corpus "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/904e526942723c62c2d54df9677cceee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28606866ad8192a12e0a4357dc9b6800/" rel="bookmark">
			[867]python提取中文地址描述中的省市区信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 一个用于提取简体中文字符串中省，市和区并能够进行映射，检验和简单绘图的python模块。
举个例子：
["徐汇区虹漕路461号58号楼5楼", "泉州市洛江区万安塘西工业区"] ↓ 转换 |省 |市 |区 |地址 | |上海市|上海市|徐汇区|虹漕路461号58号楼5楼 | |福建省|泉州市|洛江区|万安塘西工业区 | 注：“地址”列代表去除了省市区之后的具体地址
安装说明 代码目前仅仅支持python3
pip install cpca
注:cpca是chinese province city area的缩写
常见安装错误：
有的朋友在我的博客中反映他们在使用的时候会报如下错误：
ModuleNotFoundError: No module named 'jieba' 可能是因为某种原因，依赖未能成功的安装上去，这个时候则需要手动使用pip install jieba命令进行安装。
如果觉得本模块对你有用的话，施舍个star，谢谢。
中国三级行政区划分（爬取自中华人民共和国民政局全国行政区划查询平台） 数据文件在为cpca/resources/pca.csv，数据为2019年2月20日在官网上爬取的最新权威数据
Get Started 分词模式：
本模块中最主要的方法是cpca.transform，该方法可以输入任意的可迭代类型（如list，pandas的Series类型等），然后将其转换为一个DataFrame，下面演示一个最为简单的使用方法：
location_str = ["徐汇区虹漕路461号58号楼5楼", "泉州市洛江区万安塘西工业区", "朝阳区北苑华贸城"] import cpca df = cpca.transform(location_str) df 输出的结果为：
省 市 区 地址 0 上海市 上海市 徐汇区 虹漕路461号58号楼5楼 1 福建省 泉州市 洛江区 万安塘西工业区 2 北京市 北京市 朝阳区 北苑华贸城 注：程序输出的df是一个Pandas的DataFrame类型变量，DataFrame可以非常轻易地转化为csv或者excel文件，如果你对DataFrame不熟悉的话，可以参考Pandas的官方文档：http://pandas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28606866ad8192a12e0a4357dc9b6800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d97118c7f3986fb388f8035bb3a7cc/" rel="bookmark">
			ORACLE计算同比环比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同比环比概念和公式 同比: 同比一般情况下是今年第n月与去年第n月比
环比: 表示连续2个统计周期（比如连续两月）内的量的变化比。
同比增长率=（本期数-同期数）/|同期数|×100%
环比增长率=（本期数-上期数）/上期数×100%
需求: 计算2020年01月到2020年2月, 每个月的本期值和环比和同比率
数据库 表和数据准备 CREATE TABLE test ( "ID" NUMBER NOT NULL , "VALUE" NUMBER , "YEARMONTH" VARCHAR2(6 CHAR) , CONSTRAINT "SYS_C0086930" PRIMARY KEY ("ID") ) INSERT INTO "test"("ID", "VALUE", "YEARMONTH") VALUES ('1', '100', '202002'); INSERT INTO "test"("ID", "VALUE", "YEARMONTH") VALUES ('2', '80', '202001'); INSERT INTO "test"("ID", "VALUE", "YEARMONTH") VALUES ('3', '120', '201912'); INSERT INTO "test"("ID", "VALUE", "YEARMONTH") VALUES ('4', '142', '201911'); INSERT INTO "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d97118c7f3986fb388f8035bb3a7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086825a74f6a52c9d904cfe4c725c545/" rel="bookmark">
			Windows下C&#43;&#43;使用thread时无法识别thread和mutex相关库的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 今天我在Windows下打算尝试C++多线程编程，在CLion上进行编码。CLion的C++编译器是正常的，以前也跑过好几个项目，使用其他STL库函数也正常，唯独使用thread时报无法识别的错，所有thread都划上了红线。如下图所示：
其他错误信息包括但不限于： thread未定义
No member named ‘thread’ in namespace ‘std’;
‘thread’ undefined
找不到thread
mutex contiditional_variable未定义
Use of undeclared identifier ‘thread’; did you mean ‘fread’? (fix available)
问题解决过程 因为thread和mutex是C++11才引入的，所以一开始考虑的是不是CMakeList上没有加编译选项，于是加上
set(CMAKE_CXX_FLAGS$ {CMAKE_CXX_FLAGS} -std = c ++ 11)
经过一番尝试，发现并无效果。
后来受到博客CLion安装mingw并配置以支持c++11多线程编程的启发，重新安装mingw编译器，但是不成功。
又看到博客mingw-w64安装支持c++11中thread（windows下）的操作，发现关键是在安装mingw时需要将Thread选项设为posix。重新安装mingw解决问题。
问题解决，可以愉快多线程啦
总结 不能使用thread是因为mingw的编译器不支持thread，需要重新安装mingw，安装方法在引用的两篇博客里都有。同时需要确保建立工程时使用的是C++11及以上标准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a51c3c9b9826e62540e080171556c32/" rel="bookmark">
			webrtc源码下载和编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webrtc 源码下载和android平台依赖包编译 目录
webrtc 源码下载和android平台依赖包编译
1、概述
2、在云端开个服务器，
3、安装depot tools和下载源码
4、编译android的aar包
4.1 添加安卓平台
4.2同步代码
4.3 进入src目录安装依赖
4.4 生成构建脚本
4.5 build aar
1、概述 对于再国内的开发人员，再编译webrtc源的时候比较费劲，花费的功夫太大，要做android平台的webrtc开发，编译源码需要linux环境，一定要是Ubuntu，否则编译会报错，具体什么版本见下面，CentOs，deepin什么的就不要尝试了，编译会报错，有的说搞虚拟机，但是虚拟机实在太卡了，如果手头没有Ubuntu，可以搞一台，但是翻墙下源码比较费劲，不如开一台云务服器，具体步骤如下：
2、在云端开个服务器， 比如阿里云，具体怎么开通，网上可以查，这里不做详细说明
注意装的环境一定要是如下版本：
Ubuntu 14.04 LTS (trusty with EoL April 2022)
Ubuntu 16.04 LTS (xenial with EoL April 2024)
Ubuntu 18.04 LTS (bionic with EoL April 2028)
Ubuntu 20.04 LTS (focal with Eol April 2030)
Ubuntu 19.04 (disco)
Ubuntu 19.10 (eoan)
Debian 8 (jessie) or later
3、安装depot tools和下载源码 Linux（Android）/Mac（IOS）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a51c3c9b9826e62540e080171556c32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3657a6505798e85783dfc052e9278ce/" rel="bookmark">
			请不要将OFFSET和LIMIT用于分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不再需要担心数据库性能优化的日子已经一去不复返了。 随着时代的发展，每个新企业家都希望建立下一个Facebook，并结合收集每个可能的数据点以提供更好的机器学习预测的心态，作为开发人员，我们需要比以往更好地准备我们的API，以提供可靠，高效的端点，应该能够毫不费力地浏览大量数据。 如果您已经进行了一段时间的后端或数据库体系结构，则可能已经完成了分页查询，如下所示： 对？ 但是，如果您确实建立了这样的分页，很遗憾地说，您做错了。 你不同意我吗？ 你 并不 需要 到 。 Slack， Shopify和Mixmax使用我们今天将要讨论的相同概念对API进行分页。 我想请您说说一个单一的后端开发人员，该人员从来没有为了分页目的而需要处理OFFSET和LIMIT。 对于MVP和低数据列表中的分页，它“有效”。 但是，当您想从头开始构建可靠而有效的系统时，也可以直接进行。 今天，我们将讨论（错误地）广泛使用的实现所存在的问题以及如何实现高效的分页。 OFFSET和LIMIT有什么问题？ 正如我们在上几段中简要探讨的那样，OFFSET和LIMIT非常适合于数据使用量很少甚至没有的项目。 当数据库开始收集的数据量超出服务器可以存储在内存中的数据量时，仍然会出现问题，而您仍然需要对它们全部进行性能分页。 为此，每次您请求分页时，数据库都需要执行低效的全表扫描 （插入和删除可能同时发生，我们不希望数据过时！）。 什么是全表扫描？ 全表扫描（又称顺序扫描）是在数据库中进行的扫描，其中顺序读取表中的每一行，然后检查遇到的列是否符合条件。 由于从磁盘进行大量的I / O读取（包括多次搜寻）以及昂贵的磁盘到内存传输，这种类型的扫描被认为是最慢的。 这意味着，如果您有100.000.000用户，而您要求的偏移量为50.000.000，则它将需要获取所有这些记录（甚至不需要！），并将它们存储在内存中，只有在获得之后， LIMIT中指定了20个结果。 因此，要在网站上显示这样的分页： 50.000至50.020之100.000 它首先需要获取50.000行。 看看这效率低下吗？ 如果您不相信我，请看一下我创建的这个小提琴 。 在左侧面板中，您有一个基本架构，该架构将为我们的测试插入100.000行，而在右侧，则是有问题的查询和我们的解决方案。 只需单击顶部的“运行 ”，然后比较每个执行时间。 ＃1（问题查询）至少需要30秒钟的时间才能运行。 随着更多的数据，情况变得更加糟糕。 看看我的1000万行概念证明 。 现在，这应该使您对幕后发生的事情有所了解。 如果您喜欢阅读的内容，请在此处订阅以获取更多类似内容。 TLDR； 偏移量越高，查询将花费的时间越长。 您应该使用什么 这是您应该使用的： 这是基于游标的分页 。 您应该存储最后接收到的主键（通常是一个ID）和LIMIT，而不是在本地存储当前的OFFSET和LIMIT并随每个请求传递它，因此查询最终可能与此类似。 为什么？ 因为通过显式传递最新的读取行，您可以根据有效的索引键告诉数据库确切从哪里开始搜索，而不必考虑该范围之外的任何行。 以下面的比较为例： 针对我们的优化版本： 接收到的记录完全相同，但是第一个查询花费了12.80秒，第二个查询花费了0.01秒。 你能体会到差异吗？ 注意事项 为了使Cursor Pagination无缝地工作，您将需要具有一个唯一的顺序列（或多个列），例如唯一的整数ID或时间戳记字段，在某些特定情况下，这可能会破坏交易。 与往常一样，我的建议是始终考虑每种表体系结构的优缺点以及在每种表体系结构中需要执行哪种查询。 如果您需要在查询中处理大量相关数据，Rick James的“ 列表”文章可能会为您提供更深入的指导。 如果我们遇到的问题与没有主键有关，例如，如果我们有多对多关系表，则在这些情况下始终可以使用传统的OFFSET / LIMIT方法，但这将重新引入潜在的较慢查询。 因此，我建议在要分页的表中使用自动递增的主键，即使只是出于分页的目的。 结论 这样做的主要要点是始终检查查询的性能是1k行还是1M。 可伸缩性至关重要，如果从一开始就正确实施，肯定会避免将来出现很多麻烦。 哦。 并且，请不要忘记学习索引 。 并解释查询 。 如果您喜欢这篇文章，请 在此处订阅 以获取更多类似内容。 先前发布在 https://ivopereira.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3657a6505798e85783dfc052e9278ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc1688e389e144124cec8dba74d4bfd/" rel="bookmark">
			如何在不花一分钱的情况下精通Lockdown的Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我一直想学习编程 。 编写代码，使算法始终令我兴奋。 作为机械工程师，我从来没有深入地学习过这些课程。 我尝试了各种在线课程，但同时管理工作和学习变得很困难。 我什至想到辞掉工作，休息一下，学习一些可以帮助我提升职业生涯的东西。 幸运的是，我不必这样做。 由于锁定，我有足够的时间专注于学习。 我想从事数据 科学和机器学习事业，所以我选择python作为我的第一门编程语言。 预算也是一个制约因素。 在研究了免费的Python课程之后，我从评论中找出了两门在线课程。 一个是Udacity，另一个是Codecademy。 我的首选始终是Codecademy，但是要学习Python 3，需要在那里提供付费版本。 我想先品尝python，然后再购买任何在线课程。 因此，我参加了Udacity的Python免费课程。 由于我是一个初学者，因此该课程花了我将近2个月的时间才能完成。 我在头两周内就学习了基本语法。 该课程的结构适合任何初学者，以了解python的所有基本概念。 讲师的知识也渊博，流利。 在每一章之后，我都必须经历一些问题和测验，这些知识和测验需要从该模块中学到的知识。 不幸的是，这门免费课程并没有像我期望的那样包含高级项目，但无论如何，它对我清除基本概念很有帮助。 下一步是进入项目。 因此，我下载了《 用Python自动化无聊的东西 》这本书的免费版本。 我必须说这本书对理解python有很大帮助。 本书分为两部分。 第一部分专注于理论，后来致力于项目。 理论部分修改了我在Udacity学习的所有概念。 做下载Python编译器所需的项目。 我选择了Pycharm （确保下载社区版本） PyCharm是Pythons IDE（集成开发环境） 它以其简单而闻名。 多亏了这本书，我才从事涉及网络抓取和正则表达式的项目。 现在，我的下一步是学习数据科学工具Numpy。 另外，我计划参加Udacity的数据科学家课程 ，因为它的评论给我留下了深刻的印象。 我不能说我已经掌握了这些资源，但是现在我非常有信心在数据科学和机器学习领域开始我的事业。 祝好运。 翻译自: https://hackernoon.com/how-i-mastered-python-in-lockdown-without-spending-a-penny-r9i3uzn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a4cc58a6fe1fa49043d57b4290e25d/" rel="bookmark">
			Supermicro服务器的重装Centos系统体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我是一穷二白啥也不懂，从师兄那里接手的服务器。之前一直安装显卡驱动出毛病，主要原因是升级了一下所有文件，这个升级以后不能乱用，
首次接触linux系统，第一次终于安装了显卡驱动，但是重启后图形界面打不开，原因是Nvidia驱动默认安装OpenGL,而OpenGL与GNOME桌面冲突,所以桌面崩了。所以安装的时候要不安装OpenGL后,桌面确实起来了. //sh NVIDIA*.run --no-opengl-files
第二次安装显卡驱动安装成功了，但是在装cuda时不小心把显卡驱动也一同安装上了，导致桌面又崩了，删了驱动重新安装显卡驱动，但是这次不知道怎么的，怎么也装不上驱动，大概率原因是没删除干净之前的显卡驱动。最后只好重装一下系统。顺便换个低版本centos7.7。
制作U盘 这是物理机重装系统，不管怎么样都是和重装window大同小异。都是第一步制作u盘。
首先准备一个16g的u盘，最好把之前的u盘数据备份好。（因为在刻录时会格式化你的u盘）
下载centos系统，最好是在官网，但是太慢，国内的镜像网站完美解决：http://mirrors.aliyun.com/centos/ 选择想要的版本，选择好版本，一定要点开isos文件，选择x86（毕竟因特尔的玩意，没得选，如果你的不是因特尔的我也不知道怎么选）。
下载刻录的工具：各种各样的都有，这里使用一种常见的：https://cn.ultraiso.net/软通碟，当然还有Win32DiskImage刻录工具，进去这个网站，会推荐给你好多免费的刻录工具。
打开软通碟，烧录进去下载好的系统。
双击打开
2.文件 —— 打开 ——找到你下载好的系统
3.启动 ——写入硬盘映像
U盘制作完成。 服务器bios设置u盘启动 这是一个坑爹的玩意，只能说每个机子都有自己独特的设置方式，我这台是超微服务器，并不是网上所说的是在boot界面设置u盘启动，乖乖！打开一堆usb选项，直接懵了，并没有找到Boot Device Priority选项，也可能是是菜不会设置。
也不是直接快捷方式F12直接u盘启动，而是先按Del进去bios界面，然后exit推出，按F12，直接u盘启动。（我也不知道为什么）
u盘启动安装 进入此画面，看到提示说按 tab键，进入设置。
修改这个命令为vmlinuz initrd=initrd.img linux add quiet
注意quiet前面是空格，不是_ 拍照的时候光标在那里没有注意
回车
**注意：**这里本来应该直接会显示几个盘的名称以及里边的类型，但是我的并没有这样，而是上面的界面。可以输入指令。
输入指令：ls /dev |grep sd。可以得到现在的盘
dracut:/# ls /dev |grep sd sda sda1 sda2 sdb sdb3 sdc sdc4 #重启服务器 darcut:/# reboot sda表示第一块硬盘，sdb表示第二块硬盘，以此类推。sdc4就是所插入的u盘。之后输入指令进行重启。
再次进入以下画面
将命令修改为vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4 quiet
回车
图形centos安装界面 以下就是虚拟机安装的步骤了，网上老多了。
参考 https://blog.csdn.net/qq_28189423/article/details/82216620?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%B6%85%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85centos%E7%B3%BB%E7%BB%9F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-5-82216620
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48a4cc58a6fe1fa49043d57b4290e25d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d8ca97a473ead3685f73252b640da4/" rel="bookmark">
			远程电脑不能复制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑不能复制怎么办？ 1.使用Win+R快捷键打开运行窗口
2.输入rdpclip.exe 运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a2ce57336bb5d6be4b2b0d96afddd6/" rel="bookmark">
			合并多个文件夹中的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在目标目录中新建一个文本文档
2.打开新建的文本文档输入：将文件夹1，文件夹2，文件夹3的文件合并到文件夹3
for /f “delims=” %%p in (‘dir /b/ad’) do move %%p*.* D:\测试\3
pause
3.更改文件的后缀名为bat,双击运行即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5807e109b7ed565577fb5e7a9a576389/" rel="bookmark">
			基于APNS的语音播报实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于项目需求，对基于APNs的语音播报做一个预研探究。如场景：收到转账消息，实时收到推送并播放语音。
历史方案总结, 经过多方尝试验证，以下方式都已过时 以下方案均为调研过程中无法成功的方案一览；
方案一： App收到推送，通过sound指定播放固定音频（“收到一笔转账”）。前提：mp3\caf\m4a音频文件需要内置在bundle中，推送下发时指定文件名称。缺点：无法根据具体金额播报。
方案二： App在前台收到推送时，通过AVAudioSession 或者 AVSpeechSynthesisVoice播报。缺点：1 App在前台播报时，可以通过音量键调整音量。正常的推送抵达时，音量键或者关机键会即刻中断播放推送声音，所以本方案不是真正的推送音。2 App杀死情况下无法播报。
方案三： 通过通知扩展（Notification Service）播放音频。App通知扩展收到推送时，调用AVAudioSession 或者 AVSpeechSynthesisVoice 播报。可能在通知扩展刚推出的时是允许这种做法的。但现在苹果已经不支持在通知扩展中播放音频，即使调用相关函数也不会生效。
方案四： 通过通知扩展（Notification Service）发送本地通知播报。App通知扩展收到推送时，顺序创建多个本地通知，每个通知都播放内置音频，从而组成一句完整的播报音频。缺点：1 苹果已不支持在通知扩展发送本地通知。2 播放推送音频时，音量键或者关机键 会中断当前本地通知的音频播放。
方案五：基于VOIP的语音播报，iOS13之后苹果对VOIP做了很大的限制，必须配合CallKit使用，否则收到VOIP推送后直接中断crash，没有机会再做更多事情了。
现有方案 基于通知扩展（Notification Service）来处理推送，可以保证 App被杀死 或者 App在前后台时 都能够处理推送并实时播报。
也可以通过发送静默通知，来实时播报。收到静默通知时，App会被系统拉活然后然后执行application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]),可以在内部播放音频播报。但是由于苹果官方文档有说明，静默通知是有限制的：（所以该方式我们放弃了）
APNs若检测到较高频率的静默通知发送请求，可能会终止其发送静默通知唤醒后台App，最多有30秒的时间处理系统回调静默推送的优先级低，系统不能保证推送必达，大量的静默推送通知可能被系统将限制。苹果官方建议一个小时不超过2-3条静默推送静默通知官方文档 准备工作：
需要在Bundle中内置音频文件，如（0-9，元，点）等基础音频。设置AppGroup 当接收通知时：
读取aps中的播报数据，读取Bundle中音频文件进行合并音频（如"您收到.mp3"+“1.mp3”+“元.mp3”），输出到指定目录。修改本次推送声音标识sound，指定合并后的音频文件播报。最后达到语音播报目的。 注意点：
需设置AppGroup，通过共享目录创建音频目录和文件。若有指定sound:“abc.mp3”，系统会逐级查找是否有可用的abc.mp3文件： 查找AppGroup共享目录查找App NSHomeDirectory()+"/Library/Sounds/"查找bundle中是否有可用的abc.mp3查找系统音频库 GitHub Demo GitHub Demo ApnsDemo
资源文件如有侵权 请联系删除。
Test Payload 建议使用SmartPush来测试推送
{ "aps": { "alert": { "title": "title", "body": "body" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5807e109b7ed565577fb5e7a9a576389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3551d150636f8fd6d5800f368edda2f/" rel="bookmark">
			Python小白学习笔记    如何将一个正整数分解为质因数相乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python源代码：
* coding:utf-8 * Group:NET Developer:FANXINYANG Time:2020/6/21 13:41 Name:practice1.py Tool:PyCharm 大家好，小白今天给大家分享一道Python练习题，源码在下面。希望能和大家交流学习。嘤嘤嘤~~~
def reducenum(n): # 定义一个函数
print('{}='.format(n)) # 打印传入的实参n if not isinstance(n, int) or n &lt; 0: # 首先得先判断输入的n是否为正整数 print('请输入一个正确的数字！') exit(0) # 如果不是那就退出，报错哦 elif n in [1]: # 那还要考虑输入的是不是1呢？如果是那就把它打印出来吧，完成啦！ print('{}'.format(n)) while n not in [1]: # 幸运地是它不是1，啊，这该怎么办呢? 不怕给它来个遍历吧，嘿嘿 for index in range(2, n + 1): # 怎么写（2，n+1）呢？哇，你忘了range函数左闭右开了么,呜呜呜~~ if n % index == 0: # 如果取出的数可以被n整除，那就一直整除吧，哈哈哈~~ n //= index if n == 1: # 现在输出它吧 print(index) else: # 已经到底了，那就把它按题目要求打印出来吧。我好厉害啊啊啊 print('{}*'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3551d150636f8fd6d5800f368edda2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2deaa7cfafab907ad47fe768bc63e766/" rel="bookmark">
			小米手机解锁BL一直显示未解决（终极方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图 方案 手机开机，下载一个奇兔，或者豌豆荚类的连接手机的软件，连上以后，把手机进入 fastboot 模式
我的电脑-》右键-》管理-》设备管理器=》找到安卓设备=》启用即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad35674fa1ca7a9ee3032bb3027c5a4/" rel="bookmark">
			springboot图片上传大小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当图片大小设置超过springboot默认的大小时，就会报错，
he maximum size 1048576 for an individual file in a multipart request was exceeded
java.lang.IllegalStateException:如下图所示:
如何解决:
在配置文件里，修改单个上传的文件大小即可：
首先要看spring-boot版本，不同版本的变量名字不一样：
找到这个文件瞧一瞧MultipartProperties，该文件在spring-boot.autoconfigure.web文件夹下
上图是1.5.x版本的
配置:
#单个文件 spring.http.multipart.maxFileSize=10MB #总文件 spring.http.multipart.maxRequestSize=100MB 补充：文件上传接口，接受图片的相关代码
/** * 接受多个文件参数， **/ public Object uploadImg(@RequestParam(value = "files", required = false) MultipartFile[] files) { if (files == null || files.length == 0) { Preconditions.checkArgument(false, "未检测到上传图片"); String imgPattern = ".+(.JPEG|.jpeg|.JPG|.jpg|.png|.PNG)"; Pattern pattern = Pattern.compile(imgPattern); //校验图片格式 for (int i = 0; i &lt; files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad35674fa1ca7a9ee3032bb3027c5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61250cdd9346a30e84b0a59965dd545b/" rel="bookmark">
			加速Python列表和字典，让你代码更加高效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我们将讨论Python中的优化技术。在本文中，您将了解如何通过避免在列表和字典中进行重新计算来加快代码的速度。
我们先编写一个装饰器函数来计算函数的执行时间，方便测验不同代码的速度：
import functools import time def timeit(func): @functools.wraps(func) def newfunc(*args, **kwargs): startTime = time.time() func(*args, **kwargs) elapsedTime = time.time() - startTime print('function - {}, took {} ms to complete'.format(func.__name__, int(elapsedTime * 1000))) return newfunc 避免在列表中重新评估 在循环内
代码：
@timeit def append_inside_loop(limit): nums = [] for num in limit: nums.append(num) append_inside_loop(list(range(1, 9999999))) 在上面的函数中.append每次通过循环重新计算的函数引用。执行后，上述函数所花费的总时间：
o/p - function - append_inside_loop, took 529 ms to complete 在循环外
代码：
@timeit def append_outside_loop(limit): nums = [] append = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61250cdd9346a30e84b0a59965dd545b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83544a0d1e73f4f387545f2fabcfa28d/" rel="bookmark">
			GAMIT/GLOBK 10.71处理GNSS/GPS数据入门介绍及简单应用（视频教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版本（10.71）的gamit/globk讲解，从最基础知识开始，把10年前的无声视频进行完善与拓展，形成了这个全面的、基础的、快速的入门教程。
视频教学内容：
题目：GAMIT/GLOBK 10.71处理GNSS/GPS数据入门介绍及简单应用
视频课程内容如下：
GAMIT/GLOBK 10.71介绍GAMIT/GLOBK软件申请（如何申请和注意事项）需要掌握的Linux背景知识 Linux基础知识（发行版本、系统分区、基础命令、环境变量）需要知道并会用到的linux工具程序（awk、grep、sed、sort、paste/join、tr、echo/cat）GAMIT/GLOBK 10.71安装 安装绘图软件GMT（安装、使用以及版本6说明）GAMIT/GLOBK 10.71编译安装（编译环境、gfortran问题、环境变量配置、格网文件）GAMIT/GLOBK的升级与卸载需要定期更新的几个重要表文件（更新地址和相应文件说明）关于几个GNSS卫星系统（了解能处理的卫星基本情况）GAMIT自带示例运行 关于tssum故障问题（内存限制与调整编译）处理示例工程验证安装正确性RINEX格式的观测数据（版本说明、预处理、teqc）GAMIT/GLOBK实例演练 工程规划（基本流程、测站准备10个站、日期、工程名、设备信息、起算坐标、igs站分布图）数据准备（广播星历、精密星历、电离层格网文件、测站观测o文件）tables文件夹表文件准备（3个测站相关文件、3个处理控制文件）sh_gamit 基线解算批处理（命令讲解、结果讲解、天空图）基线解算中需要注意的问题（GAMIT约束问题、负荷模型使用）GLOBK基本介绍（主要用途）生成二进制h文件（htoglb）GLOBK平差需要的命令文件（globk.cmd、glorg.cmd）globk.cmd内容讲解glorg.cmd内容讲解sh_glred坐标重复性分析合并时段文件，获得平均位置与PowerNet平差的结果对比求解测站速度(1-3)GAMIT提供的有用的命令（convertc、doy）常见问题解决 视频教材网址（可试学）：
https://ke.qq.com/course/2769588?tuin=10fbe80d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdbe16ed61d8d1b9e8004dbea51044d2/" rel="bookmark">
			手把手教你源代码编译安装httpd服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码编译安装httpd服务 实验环境 安装有CentOS 7.6版本的虚拟机，apache服务器安装包httpd-2.4.25.tar.gz，两个底层运行的工具环境apr-1.4.6.tar.gz、apr-util-1.4.1.tar.gz
实验步骤及排障 1.在/opt目录下添加服务的安装包httpd-2.4.25.tar.gz和两个底层运行的工具环境apr-1.4.6.tar.gz、apr-util-1.4.1.tar.gz，它们支撑着apache服务能够跨越Windows和Linux的平台。
2.使用tar zxvf命令将其全部解压缩到当前目录下。
3.将底层运行的两个包放进apache的源码包中。
4.安装编译工具以及支撑网站运行的开发语言工具。
5.在如下目录中配置添加安装路径。
./configure --prefix=/usr/local/apache
6.make编译，将源代码文件编译成计算机可以识别的二进制文件。
7.make install 安装
8.启动apache服务有两种方式：
（1）进入如下目录，运行apachectl启动脚本，适合只启动一次
（2)通过创建启动脚本，将其添加到/etc/init.d中，下次可以使用service httpd start/stop来管理，无需切换到那个较长的目录中启动apache。
报错！将脚本添加到/etc/init.d后，开启服务时出现“权限不够”。
解决方法：
原来是/etc/init.d/httpd文件没有可执行权限（因为新创建的文件默认权限是644），只需输入如下命令即可。
chmod +x /etc/init.d/httpd
现在就可以通过service httpd start/stop/status来管理httpd服务了。
9.建立配置文件的软链接，便于管理（原文件位置太长了！）
10.更改配置文件，设置监听地址、端口以及域名。
11.想要在真机上成功访问刚才设置的监听地址，必须关闭防火墙，这样就能成功在真机上访问监听地址了。
systemctl stop firewalld.service
12.如果想要更改首页内容，可以在/usr/local/apache/htdocs/index.html中进行修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca55786ddb2ab85fb5133622c4271ec/" rel="bookmark">
			pycharm顶部菜单栏消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先是进入全屏模式，后是取消了main menu前的对勾，真的做的一手好死。下面开始解决方法：
1.退出全屏
双击shift,单击view mode,选择exit full screen
奥利给！！！
2.显示菜单栏
从菜单栏顶部找到view–&gt;appearence–&gt;main menu前打对勾
奥利给！！！！
所以说，不要瞎搞啊，瞎搞什么瞎搞T_T
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4199641e53607b3586cecc234cece6/" rel="bookmark">
			MySql计算两日期时间之间相差的天数,秒数,分钟数,周数,小时数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计算两日期时间之间相差的天数，秒数，分钟数，周数，小时数，这里主要分享的是通过MySql内置的函数 TimeStampDiff() 实现。 函数 TimeStampDiff() 是MySQL本身提供的可以计算两个时间间隔的函数， 语法为： TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2) 返回日期或日期时间表达式 datetime_expr1 和datetime_expr2the 之间的整数差。 其中unit单位有如下几种，分别是：FRAC_SECOND (microseconds), SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, YEAR 。该参数具体释义如下： FRAC_SECOND 表示间隔是毫秒 SECOND 秒 MINUTE 分钟 HOUR 小时 DAY 天 WEEK 星期 MONTH 月 QUARTER 季度 YEAR 年 例如： #计算两日期之间相差多少周 select timestampdiff(week,'2011-09-30','2015-05-04'); #计算两日期之间相差多少天 select timestampdiff(day,'2011-09-30','2015-05-04'); 另外计算两日期或时间之间相差多少天还可以使用 to_days 函数，但是该函数不用于阳历出现(1582)前的值，原因是当日历改变时，遗失的日期不会被考虑在内。因此对于1582 年之前的日期(或许在其它地区为下一年 ), 该函数的结果实不可靠的。具体用法如： to_days(end_time) - to_days(start_time); #计算两日期/时间之间相差的秒数： select timestampdiff(SECOND,'2011-09-30','2015-05-04'); 另外还可以使用 MySql 内置函数 UNIX_TIMESTAMP 实现，如下： SELECT　UNIX_TIMESTAMP(end_time) - UNIX_TIMESTAMP(start_time);　#计算两日期/时间之间相差的时分数：　select timestampdiff(MINUTE,'2011-09-30','2015-05-04'); 另外还可以如下实现： SELECT　SEC_TO_TIME(UNIX_TIMESTAMP(end_time) -　UNIX_TIMESTAMP(start_time)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d55d2bcedd9c6e049dc3d624f684b7e/" rel="bookmark">
			MYSQL查询一个表中的所有字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select CONCAT(COLUMN_NAME ,',') from information_schema.COLUMNS where table_name = '表名' and table_schema = '库名'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e92b865d5c21c71a412cf8c27da36a/" rel="bookmark">
			MYSQL查询一个月前的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日期格式 SELECT (DATE_ADD(now(),INTERVAL -1 month)) 时间戳格式 SELECT UNIX_TIMESTAMP(DATE_ADD(now(),INTERVAL -1 month)) 更多：
~~~ select * FROM t_user where time&gt;DATE_SUB(CURDATE(), INTERVAL 1 WEEK) --一周 select * FROM t_user where time&gt;DATE_SUB(CURDATE(), INTERVAL 3 MONTH) --三月 select * FROM t_user where time&gt;DATE_SUB(CURDATE(), INTERVAL 1 YEAR) --一年 ~~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db0d2e711c0597eaa2cab74f789a6f3/" rel="bookmark">
			Vue：npm ERR！missing script：build
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在终端使用npm run build打包的时候出现了报错问题，具体显示情况如下。
其实多数时不同项目的打包方式可能有所不同，这个时候可以查看下配置文件package.json，里面的script字段相关，会提示你启动项目或者打包项目时用的哪些方式，或者命令。
这个问题是我们所用创建的Vue模板在创建过程中出现的配置文件的操作。所以查看package.json文件就可以在package.json文件中找到build这一块后面，发现附带了这个:prod，具体情况如下图所示。
只要使用以下这个命令就可以打包了。
npm run build:prod --report 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a264a90dc47410abb1caf24267f5ed/" rel="bookmark">
			复化求积方法 | 复化梯形公式、复化Simpson公式、复化Cotes公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从Newton-Cotes的截断误差公式可以看出，当积分区间 [ a , b ] [a,b] [a,b]较大时，低阶的Newton-Cotes求积公式截断误差都比较大。由于高阶Newton-Cotes求积公式是数值不稳定的，因此通过不断增加阶数来提高求积公式的精度是不可行的。但是，如果将积分区间 [ a , b ] [a,b] [a,b]分成几个小区间（任意的），在每个小区间上应用Newton-Cotes求积公式，其截断误差必然会减小，然后再把每个小区间上的积分值累加起来，这样却能大大提高整个积分的精度。这种方法称为复化求积方法。
常用的复化求积方法采用等分区间的做法，具体如下：
将区间 [ a , b ] [a,b] [a,b]划分为n等分，步长为 H = ( b − a ) n H=\frac{(b-a)}{n} H=n(b−a)​，分点为 x k = a + k H , k = 0 , 1 , 2 , ⋯ , n x_k=a+kH,k=0,1,2,\cdots,n xk​=a+kH,k=0,1,2,⋯,n。先用低阶Newton-Cotes求积公式求得每个子区间 [ x k , x k + 1 ] [x_k,x_{k+1}] [xk​,xk+1​]上的积分值 I k I_k Ik​，然后将它们累加起来求和，用 ∑ k = 0 n − 1 I k \sum_{k=0}^{n-1}I_k ∑k=0n−1​Ik​作为所求积分 I = ∫ a b f ( x ) d x I=\int_a^bf(x)dx I=∫ab​f(x)dx的近似值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7a264a90dc47410abb1caf24267f5ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb16dee417ce7c0c779df0a2c5e9e1fe/" rel="bookmark">
			如何监视Python程序的内存使用情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用Python和它的数据处理库套件(如panda和scikiti -learn)进行大量数据处理时候，可能使用了大量的计算资源。如何监视程序的内存使用情况就显得尤为重要。
1.询问操作系统 跟踪内存使用情况的最简单方法是使用操作系统本身。您可以使用top来提供您在一段时间内使用的资源的概述。或者，如果您想要现场检查资源使用情况，您可以使用ps命令:
$ ps -m -o %cpu,%mem,command %CPU %MEM COMMAND 23.4 7.2 python analyze_data.py 0.0 0.0 bash m标志指示ps按照进程使用最多内存的顺序显示结果。o标志控制显示每个进程的哪些属性——在本例中是使用的CPU百分比、消耗的系统内存百分比和正在执行的进程的命令行。
CPU百分比将一个完整的CPU核心计算为100%的使用率，因此如果您有一个4核的机器，可能会看到总计高达400%的CPU使用率。还有其他输出选项用于显示其他进程属性，以及用于控制显示哪些进程的ps的其他标志。
结合一些创造性的shell脚本，可以编写一个监视脚本，使用ps跟踪任务的内存使用情况。
2.tracemalloc Python解释器的操作中有大量的hooks，可以在Python代码运行时用于监视和内省。pdb使用这些钩子来提供调试;覆盖率也使用它们来提供测试覆盖率。tracemalloc模块还使用它们来提供一个了解内存使用情况的窗口。
tracemalloc是在Python 3.4中添加的一个标准库模块，它跟踪Python解释器分配的每个单独的内存块。tracemalloc能够提供关于运行Python进程中内存分配的非常细粒度的信息:
import tracemalloc tracemalloc.start() my_complex_analysis_method() current, peak = tracemalloc.get_traced_memory() print(f"Current memory usage is {current / 10**6}MB; Peak was {peak / 10**6}MB") tracemalloc.stop() 调用tracemplugin .start()启动跟踪进程。在进行跟踪时，您可以询问分配了哪些内容的详细信息;在本例中，我们只要求当前和峰值内存分配。调用tracemplugin .stop()将删除hook并清除已经收集的任何跟踪。
不过，这种程度的细节是要付出代价的。tracemalloc将自己深深地注入到正在运行的Python进程中——正如您所预期的那样，这会带来性能损失。在我们的测试中，我们观察到在运行分析时使用tracemalloc的速度下降了30%。在分析单个进程时，这可能是可以的，但在生产中，您确实不希望仅仅为了监视内存使用情况而降低30%的性能。
3.抽样 幸运的是，Python标准库提供了另一种观察内存使用情况的方法—resource模块。resource模块为程序分配的资源提供基本控制，包括内存使用:
import resource usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss getrusage()的调用返回程序所使用的资源。常量RUSAGE_SELF表示我们只对这个进程使用的资源感兴趣，而不是它的子进程。返回的对象是一个结构，它包含一系列操作系统资源，包括CPU时间、信号、上下文切换等;但就我们的目的而言，我们感兴趣的是maxrss——最大驻留集大小——它是进程当前在RAM中持有的内存量。
但是，与tracemalloc模块不同的是，资源模块不随时间跟踪使用情况—它只提供点采样。因此，我们需要实现一种方法来随时间对内存使用情况进行采样。
首先，我们定义一个类来执行内存监控:
import resource from time import sleep class MemoryMonitor: def __init__(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb16dee417ce7c0c779df0a2c5e9e1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3506ee31958fb83454f3618a1efaf0b8/" rel="bookmark">
			vue父子组件的创建及挂载顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue的created和mounted执行顺序，created自上而下，mounted自下而上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d4536ba68844a3458458eec4342eb1/" rel="bookmark">
			简单的认识Java，了解Jre、Jdk、Jvm三者之间的关系，以及Java运行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Java是一门面向对象的编程语言，不仅吸收了c++语言的各种优点，但是摒弃了c++难以理解的多继承、指针等概念。因此Java语言具有功能强大和简单易用两个特征。
Java语言作为静态面向对象编程语言的代表，极好的实现了面向对象的理论，允许程序员以优雅的思维方式进行复杂的编程。
Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立性、可移植性、多线程、动态性等特点。
Java可以编写桌面应用程序、web应用程序、分布式系统、嵌入式系统等应用程序。
JVM JVM (Java Virtual Machine) Java虚拟机Jvm是Java平台无关性实现的关键引入Jvm之后，Java在不同的编译平台上运行是不需要重新编译的。 JRE 1、 jre （Java Runtime Environment）Java运行环境
2、包括Java虚拟机(jvm) 、Java核心类库和支持文件
3、如果只需要运行开发好的Java程序，下载并安装jre就可以
4、如果开发Java软件，就需要下载jdk
5、在jdk中附带jre
JDK jdk（Java Development Kit） Java语言的软件开发工具包提供给Java开发人员使用的包含JRE、Java的开发工具两个主要组件： 1、javac 编译器 将源程序转成字节码
2、java 运行编译后的Java程序（.class后缀的）
Jdk是面向开发人员的，而jre是面向使用者。
在JDK的安装目录下有一个jre目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib合起来就称为jre
Java运行机制图解 首先将编写的Java源文件编译生成后缀名为.class的字节码文件，Java字节码在Java虚拟机(JVM)中运行，将字节码文件翻译成机器代码
这样利用JVM就可以把Java字节码程序和具体的硬件平台以及操作系统环境分隔开来，只要在不同的计算机上安装对应操作系统的JVM，Java程序就可以运行，而不用考虑当前具体的硬件平台及操作系统环境，也不用考虑字节码文件是在何种平台上生成的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c260d0f7290f1a3581b664c7624be3/" rel="bookmark">
			Element Ui 下拉选择框内追加添加按钮，点击可以追加新的选项内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能需求，在下拉选项框内，追加一个添加的按钮，点击可以添加新的被选项内容；
效果展示如下：
代码实现封装组件：
&lt;template&gt; &lt;span&gt; &lt;el-cascader ref="cascader" v-model="selectedOptions" size="medium" style="width:100%" :props="defaultParams" :options="brands" :clearable="true" @change="handleChange" @visible-change="v =&gt; visibleChange(v, 'cascader', categoriesClick, '添加品牌')" /&gt; &lt;!-- 添加品牌 --&gt; &lt;add-brand :open-off="openOff" @changeAddclose="closeAdd" /&gt; &lt;/span&gt; &lt;/template&gt; &lt;script&gt; import { brandAllList } from '@/api/item/brand.js' import AddBrand from './components/addbrand.vue' export default { name: 'AboutAddBrand', components: { AddBrand }, data() { return { brands: [], // 品牌选项 selectedOptions: [], // 品牌被选 defaultParams: { // 转品牌选项 label: 'name', value: 'brand_id', children: 'children' }, openOff: false // 添加品牌信息弹框 } }, async mounted() { await this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c260d0f7290f1a3581b664c7624be3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c69f80f2df42567569c0c6e2338a1cf/" rel="bookmark">
			千兆网口Freescale-ETSEC-&#43;-Marvell-88E1111-uboot-Linux-驱动分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千兆网口Freescale-ETSEC-+-Marvell-88E1111-uboot-Linux-驱动分析 1 千兆以太网的物理层
千兆以太网的物理层分为物理编码子层PCS（Physical Coding Sublayer）、物理介质连接子层PMA（Physical Medium Attachment）和物理介质相关子层PMD（Physical Medium Dependent）三层，如下图所示：
其中PCS子层负责8b10b编码，它可以把从GMII口接收到的8位并行的数据转换成10位并行的数据输出。因为10比特的数据能有效地减小直流分量，降低误码率，另外采用8b10b编码便于在数据中提取时钟和进行首发同步。可以把PCS两头看成GMII接口和TBI接口。
PMA子层进一步将PCS子层的编码结果向各种物理媒体传送，主要是负责完成串并转换。PCS层以125M的速率并行传送10位代码到PMA层，由PMA层转换为1.25Gbps的串行数据流进行发送，以便实际能得到1Gbps的千兆以太网传送速率。可以把PMA子层的两头分别看做TBI接口和SGMII接口。
PMD子层将对各种实际的物理媒体完成接口，完成真正的物理连接。由于1000BASE-X支持多种物理媒介，如光纤和屏蔽双绞线，它们的物理接口显然不会相同。有的要进行光电转换，有的要完成从不平衡到平衡的转换。PMD层将对这些具体的连接器作出规定。
2 Freescale 的ETSEC与PHY之间的接口
Freescale的MPC8314和P2020都自带了三速以太网控制器ETSEC，可以提供10M，100M，1000M三种速率的接口。当作为以太网时，需要外部的PHY芯片或者Serdes设备与其相连接。每个ETSEC都支持多标准的MII接口，总体结构如下图所示，可以提供GMII，RGMII，MII，RMII，RTBI，SGMII 六种接口，下图为从MPC8314 datasheet中截取的ETSEC的结构图。
如果CPU与PHY之间是GMII接口或RGMII接口，那么PHY将提供完整的PCS，PMA，PMD三层工作；如果CPU与PHY之间是RTBI接口，那么PCS层的工作在ETSEC中已经做完了，ETSEC中的TBI模块可以做PCS层的工作，PHY只需要做PMA和PMD的工作即可；如果CPU与PHY之间是SGMII接口，那么PHY只需要完成PMD的工作，ETSEC中的PCS由TBI完成，而PMA由CPU自带的Serdes模块完成。
3 BD表结构
在千兆以太网的驱动中，现在一般都使用一个叫BD表的东西来管理MAC层发送和接收的内存区域，如下图所示：
在IMMR映射的寄存器空间中有两组寄存器TBASEn和RBASEn，分别为TxBD Ringn 和 RxBD Ringn的指针。MPC8314的ETSEC允许有8个TxBD Ring和8个RxBD Ring，他们都存放在内存的某个区域中。每个Buffer Descriptor 都是有8个字节构成，两个字节的状态，两个字节的数据长度和四个字节的数据指针，这个指针指向内存的另一块地方，这才是真正存储发送接收数据的地方。Buffer Descriptor必须在网口初始化的时候初始化，并将自己的地址赋给TBASEn和RBASEn。
在网口驱动程序中可以看到，每个BD Ring中的BD数量是可变的（我们设为64），而他们之间并没有指针连接，只是一段连续的空间，顺序下来的，所谓的环只是一个虚拟的概念，在最后一个BD时，需要将BD状态位中的W位（Wrap）置一，表示这是最后一个BD，他的下一个BD就是第一个BD。如下图所示：
下面一节将结合uboot源码分析一下网口初始化以及PHY配置的过程，再下一节会分析内核中的驱动。为什么先说uboot，因为在我看来，驱动程序就是分为两个部分，1 按照Datasheet的说明去配置寄存器，2 添加符合操作系统规范去融入操作系统。在uboot下系统很简单，代码一目了然，所以我们应该在boot下先把寄存器配置好，再去分析复杂的多的内核代码。
这节分析uboot中的网口驱动代码。 1 网口驱动函数列表
函数名
函数用途
tsec_initialize()
网口初始化函数
tsec_init()
网口启动函数
tsec_local_mdio_write()
MDIO口写函数
tsec_local_mdio_read()
MDIO口读函数
tsec_send()
网口发送函数
tsec_recv()
网口接收函数
tsec_configure_serdes()
配置TBI PHY的函数
fsl_serdes_init()
Serdes模块初始化函数
init_phy()
PHY初始化函数
adjust_link()
根据PHY状态配置MAC的函数
2 tsec_initialize()函数
该函数为ETSEC的初始化函数，在该函数中要初始化eth_device结构和私有的tsec_private结构，并初始化PHY。
int tsec_initialize(bd_t * bis, int index, char *devname)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c69f80f2df42567569c0c6e2338a1cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e4f254d1736b7201aa101ccdcbe3d1/" rel="bookmark">
			对于Google Earth Engine的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Google Earth Engine的介绍 关于GEE的总体介绍GEE的优势GEE的学习资料 关于GEE的总体介绍 Google Earth Engine （GEE），又称谷歌地球引擎，是当今世界上最先进的基于云计算的地理信息处理平台。谷歌地球引擎免费给用户提供PB数量级的可公开下载的地球观测数据、用于分析数据的算法以及创建和运行这些算法的编程界面。尤其是在谷歌地球引擎中进行的计算和分析是基于谷歌基础架构的自动并行处理，意味着成百上千的处理器可以同时用于某个用户的定制计算中。谷歌地球引擎的功能是通过JavaScript和Python中提供的应用编程接口API来实现的。该API支持复杂的地理空间分析，包括叠加、地图代数、数组操作、图像处理、分类、变化检测、时间序列分析、图像拼接、栅格矢量转换、 基于矢量的图像统计提取等等。算法不断地被添加、增强和更新。通过API，用户可以自由地编写更复杂的分析，并创造性地重新组合现有的算法。相比传统方法，谷歌地球引擎前所未有地提高了地理空间 数据的计算效率，可用于全球尺度研究，同时也更易于用户学习掌握。限于篇幅原因，关于谷歌地球引擎的更多详细介绍，请访问其官方网站（链接: https://developers.google.com/earth-engine/）。
GEE的优势 GEE当前已收集MODIS、Landsat、Sentinel 等常用遥感数据集，可利用在线或离线的编程方式获取和处理共享数据，并基于强大的谷歌云平台，利用云计算进行遥感数据分析与处理，避免了传统遥感分析模式带来的数据下载、预处理等繁琐过程。
GEE的学习资料 在上面的官方网站进行学习
B站大佬：王金柱老师、吴秋生老师
知乎大佬：无形的风
一个优秀的GEE案例网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c466d7b8a6486b5cbc583688b407e8b/" rel="bookmark">
			搭建一个基于端口号、域名访问的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建一个基于https://www.zuoye.com:11111或者https://wwww.zuoye.com:11111访问的web网站，网站首页在/www/zuoye/,内容为homework。
注意：防火墙和selinux
1.创建网页文件根目录，定义网页内容
[root@hp ~]# mkdir /www/zuoye
[root@hp ~]# echo homework &gt;/www/zuoye/index.html
2.安装mod-sslr软件
mod_ssl是一种以openssl 的工具箱为基础专门为apache webserver 提供密码保护的软件。
3.切换目录到/etc/pki/tls/certs公钥基础设施，制作ca证书添加密码
4.定义根据端口、域名访问网站的配置文件
在ssl.conf找基础配置复制粘贴到我们的配置文件里
我们配置文件的内容
5定义hosts文件添加上ip地址及其对应域名
6关闭防火墙及SElinux状态
7重启httpd服务
输入密码
8测试
Curl -k https://www.zuoye.com:11111（使用-k跳过证书验证）
作业2：实现客户端使用http协议从服务端获得软件包并安装
1、服务端：/etc/httpd/conf.d/*.conf
2、客户端：写好yum源
1切换目录到/var/www/html查看挂载情况
2把/dev/sr0挂载到/var/www/html下
3工作目录切换到配置文件/etc/httpd/conf.d下，编辑欢迎界面
更改内容options indexes
重启服务
4编写红帽七yum源
查看源情况
5测试红帽7
6服务器上添加光盘，使用红帽8镜像
7查看挂载点情况
8将/dev/sr0挂载到guangpan
9编写红帽8配置文件
重启服务
10客户端红帽8上切换目录到/etc/yum.repos.d/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8eb94d253504207df2c295eef41d3aa/" rel="bookmark">
			Rhel7及8使用yum安装软件包httpd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 **
Rhel7使用yum安装软件包httpd **
1首先挂载光盘到/mnt或者新建的目录
2配置源
或者
gpgcheck=0 不进行校验
3使用yum安装httpd（或者其他）包
RHEL8使用yum安装 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06fcd18202a1f93ab0f37d2a04d216bd/" rel="bookmark">
			数字图像处理（冈萨雷斯版）学习笔记(2)第2-3章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.8 数组索引 2.8.1 向量索引 维数为1 x N的数组称为行向量。行向量中元素的存取是使用一维索引进行的。因此，v(1)是向量v(1)的第一个元素，v(2)是第二个元素，以此类推。MATLAB中向量的元素使用方括号括起，并由空格或逗号隔开。例如
&gt;&gt; v = [1 3 5 7 9] v = 1 3 5 7 9 &gt;&gt; v(2) ans = 3 使用转置运算符(.’)可将行向量转换为列向量：
&gt;&gt; w = v.' w = 1 3 5 7 9 要存取元素的数据块，我们可使用MATLAB的冒号。例如，要存取v的前三个元素，可使用语句
&gt;&gt; v(1:3) ans = 1 3 5 使用如下语句存取第三个到最后一个元素：
&gt;&gt; v(3:end) ans = 5 7 9 其中，end表示向量中的最后一个元素。
&gt;&gt; v(:) ans = 1 3 5 7 9 产生一个列向量，而语句
&gt;&gt; v(1:end) ans = 1 3 5 7 9 产生一个行向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06fcd18202a1f93ab0f37d2a04d216bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed55e9bf38f57c405ccea5b74eb695aa/" rel="bookmark">
			python3进阶篇（三）——多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3进阶篇（三）——多线程 前言：
阅读这篇文章我能学到什么？
一个应用程序就相当于一个进程，该进程创建时就具有一个主线程(内核线程)，主线程可以创建其他子线程（用户线程），当存在子线程时就形成了多线程。多线程可以使得运行程序在宏观上同时执行多个任务，在一定程度上加快软件执行速度。线程的操作涉及到：线程创建、同步、退让、抢占等。请阅读这篇文章学习它。
——如果你觉得这是一篇不错的博文，希望你能给一个小小的赞，感谢您的支持。
1 了解并创建线程 1.1 了解线程 当进程被创建时，操作系统将会为它创建一个主线程，也即内核线程，注意它是操作系统创建的。用户可以通过主线程创建子线程，或称用户线程。不论主线程还是子线程，每个独立的线程都有一个程序的入口，对应在代码中就是入口函数。一个进程可以有多个线程，线程是进程的执行单元。宏观上各个线程可以是同时执行的，微观上依然是CPU分时间片执行。Python3为我们提供了操作线程的类，这简化了线程开发的步骤。旧的线程模块是_thread，Python3提供了新的模块’threading’操作线程。
1.2 创建线程 我们尝试通过模块’_thread’进行线程创建。
代码示例：
import _thread import time def Run(ThreadName, Speed): while True: time.sleep(Speed) #延迟一定时间，单位为s print(ThreadName, "----", time.ctime(time.time())) _thread.start_new_thread(Run, ("Thread-1", 3)) _thread.start_new_thread(Run, ("Thread-2", 5)) Run("ThreadMain", 4) 运行结果：
Thread-1 ---- Sun Jun 21 13:02:44 2020 ThreadMain ---- Sun Jun 21 13:02:45 2020 Thread-2 ---- Sun Jun 21 13:02:46 2020 Thread-1 ---- Sun Jun 21 13:02:47 2020 ThreadMain ---- Sun Jun 21 13:02:49 2020 Thread-1 ---- Sun Jun 21 13:02:50 2020 Thread-2 ---- Sun Jun 21 13:02:51 2020 ThreadMain ---- Sun Jun 21 13:02:53 2020 Thread-1 ---- Sun Jun 21 13:02:53 2020 Thread-2 ---- Sun Jun 21 13:02:56 2020 Thread-1 ---- Sun Jun 21 13:02:56 2020 ThreadMain ---- Sun Jun 21 13:02:57 2020 Thread-1 ---- Sun Jun 21 13:02:59 2020 该示例中总共有三个线程，函数start_new_thread()用于创建线程并指定线程的入口函数，并且开始开始运行线程。最后别忘了主线程也在运行。从打印的时间信息可以看出，三个线程是各自独立运行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed55e9bf38f57c405ccea5b74eb695aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861795afc58174edbb68b147076c6ceb/" rel="bookmark">
			数据就是由一个个表格内容组成的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本上数据的存储格式就是这样的：
可以发现表格的最上面的那一行，即表格的属性就是整个表格的一个模板，结构。下面的一行行数据就是表格的内容，实际体现。
放到java中来就是：
class Employee{//定义的类
String name;
String sex;
String age;
String job;
String pay;
String time;//类的属性
}
稍稍观察，对比便可以发现:java中的类和对象的概念可以用表格的模板和表格的内容来理解。
那么，还可以延伸的是：每一个公司的员工，每天都会打卡。这个打卡的动作，也可以放到模板中去，写成方法的形式；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c619b3dbe372a813896e28bb559db7/" rel="bookmark">
			Hive中行列转换详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive中行列转换详解 1 行转列 1.1 多行转多列 数据表 row2col col1 col2 col3 a c 1 a d 2 a e 3 b c 4 b d 5 b e 6 现在要将其转化为： col1 c d e a 1 2 3 b 4 5 6 此时需要使用到max(case … when … then … else 0 end)，仅限于转化的字段为数值类型且为正值的情况 创建表：
create table row2col(col1 string,col2 string,col3 int) row format delimited fields terminated by ','; 加载数据：
load data local inpath '/root/hivedata/row2col.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c619b3dbe372a813896e28bb559db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b92583f7fb9d8dae46a25b5e6abd374/" rel="bookmark">
			使用zkui 操作Zookeeper的web页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用zkui 操作Zookeeper的web页面 除了命令行客户端的方式访问zookeeper外，现在有一个可以可视化操作zookeeper的web页面，具体的安装步骤
1，下载源代码https://github.com/DeemOpen/zkui，或者码云地址https://gitee.com/ilanni/zkui.git，如图所示，解压后的目录结构
#获取并查看源码 git clone https://gitee.com/ilanni/zkui.git cd zkui/ ll #使用mvn命令进行编译、构建和打包 mvn clean install maven打包后生成了zkui-2.0-SNAPSHOT.jar和zkui-2.0-SNAPSHOT-jar-with-dependencies.jar两个文件，其中zkui-2.0-SNAPSHOT-jar-with-dependencies.jar才是我们需要的jar文件。
启动zkui zkui运行的jar文件生产后，我们就可以直接运行该文件了。但是在运行该文件之前，我们还需要修改zkui的配置文件config.cfg。
config.cfg文件中配置了，zkui需要连接的zookeeper集群的IP地址和端口，访问ui的用户名和密码，以及zkui监听的端口号。
zkui默认的用户名和密码是admin/manager，在此我们修改为admin/admin。
现在使用如下命令启动zkui，如下：
#启动zkui nohupjava -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &amp; #查看启动后端口信息 netstat -tunlp |grep 9090 通过web浏览器访问http://IP:9090/login，输入用户名和密码登录即可
浏览器访问http://IP:9090/login，输入用户名和密码登录即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564051e033ce5d9c1bfb88ee87760cf0/" rel="bookmark">
			vue全屏组件screenfull的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue使用screenfull进入全屏 1.安装依赖
npm install --save screenfull 2.在需要设置的页面导入
import screenfull from "screenfull"; 3.一个按钮，一个点击事件
//dom &lt;el-button type="primary" class="button" @click="click"&gt;按钮&lt;/el-button&gt; //点击函数 click() { // 判断是否支持 if (!screenfull.enabled) { this.$message({ message: "不支持全屏", type: "warning" }); return false; } screenfull.toggle(); } 效果图
1.💴
2.后
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbda479ebdbe28a0832551e22282b1dc/" rel="bookmark">
			CommonJS 和 ES6 Module 究竟有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS 和 ES6 Module 究竟有什么区别？
作为前端开发者，你是否也曾有过疑惑，为什么可以代码中可以直接使用 require 方法加载模块，为什么加载第三方包的时候 Node 会知道选择哪个文件作为入口，以及常被问到的，为什么 ES6 Module export 基础数据类型的时候会有【引用类型】的效果？
带着这些疑问和好奇，希望阅读这篇文章能解答你的疑惑。
CommonJS 规范 在 ES6 之前，ECMAScript 并没有提供代码组织的方式，那时候通常是基于 IIFE 来实现“模块化”，随着 JavaScript 在前端大规模的应用，以及服务端 Javascript 的推动，原先浏览器端的模块规范不利于大规模应用。于是早期便有了 CommonJS 规范，其目标是为了定义模块，提供通用的模块组织方式。
模块定义和使用 在 Commonjs 中，一个文件就是一个模块。定义一个模块导出通过 exports 或者 module.exports 挂载即可。
exports.count = 1; 导入一个模块也很简单，通过 require 对应模块拿到 exports 对象。
const counter = require('./counter'); console.log(counter.count); CommonJS 的模块主要由原生模块 module 来实现，这个类上的一些属性对我们理解模块机制有很大帮助。
Module { id: '.', // 如果是 mainModule id 固定为 '.'，如果不是则为模块绝对路径 exports: {}, // 模块最终 exports filename: '/absolute/path/to/entry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbda479ebdbe28a0832551e22282b1dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf30b63769675eb665e7d37e4511af00/" rel="bookmark">
			VSCode Go Golang不能跳转到定义解决办法 (问题排查)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明 mac vscodeGo版本: go version go1.13 darwin/amd64.使用go modules模式: go.mod文件表明模块和vendor目录存储第三方依赖. 遇到的问题一 vscode PROBLEM窗口提出出错: missing $GOPATH 解决办法: 检查go是否安装成功, GOPATH是否设置成功.
安装VScode-Go插件 在vscode extensions中安装Go插件.
插件配置: 使用gogetdoc和goimports. (后续也可以尝试 Docs Tool使用guru, 跳转到定义很快速)
不要选择language server!!! (我选择了, 不能用)
安装go Install/Update Tools:
选择如下的所有工具
gocode gopkgs go-outline go-symbols guru gorename gotests gomodifytags impl fillstruct goplay godoctor dlv gocode-gomod gogetdoc goimports golint 在workspace setting中设置vender目录, 先选择如下打开设置:
然后添加如下:
"go.toolsEnvVars": { "GOFLAGS": "-mod=vendor" } 重新加载窗口:
注意: 工程下要要有go.mod和vendor, 工程文件结构示例如下:
参考资源和提示 go无法掉转到定义解决办法: https://blog.csdn.net/tongxin13/article/details/104245905, 里面说了进行其他的设置也有可能成功, 还要自己尝试才行.如果是要远程SSH运行vscode的话, 需要在服务器安装相应的插件和tools, 设置好也能进行跳转.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf30b63769675eb665e7d37e4511af00/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/212/">«</a>
	<span class="pagination__item pagination__item--current">213/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/214/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>