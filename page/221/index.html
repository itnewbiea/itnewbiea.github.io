<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f82a790f00ab1f1b018a78581f1acc/" rel="bookmark">
			nodeJS中的异步编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs 不是单线程 在博客项目中关于异步问题： 1.当用户添加一条博客时 需要通过post方式向服务器发送数据 后台获取用户以post方式拿到传送过来的数据 然后存入数据库： 上面的代码：创建一个空字符串 当用户向服务器发送请求时出发data事件将依次获取来数据进行拼接 当用户请求结束后出发end事件 将拼接后的字符串赋值给req.postData属性 理想中的代码执行顺序如下： 但是代码中的data和end事件 都是属于异步 SO 真正执行如下： 因为同步代码优先执行 异步代码等同步代码之行结束后再根据规则执行 这就造成后台接收不到传送的数据 使用Promise解决异步问题：将异步代码放入Promise中 将要传送的数据放到resolve方法中作为参数 当上面代码执行完成后才执行下面的then里面的代码 同时也回想resolve中的参数传到下面的形参result中 在将其赋值给req.postData 将后续代码放在then中 2.当nodeJS操作数据库时也存在异步： var mysql = require('mysql'); var connection = mysql.createConnection({ host: 'localhost', user: 'root', password: 'root', database: 'nodeblog' }); //开始连接 connection.connect(); //查询所有数据 let sql = 'SELECT * FROM student' connection.query(sql, (err, result) =&gt; { if (err) { console.log('sorry'); return; } console.log(result); }); console.log('查询结束') 上面代码的执行结果为： 说明：虽然查询学生表的代码书写在前 但是优先输出“查询结束”可见后续代码不会等到查询学生表代码执行结束后才执行 解决方法：也是通过Promise 红色框内为异步代码 黄色框内为后续代码！！！ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f82a790f00ab1f1b018a78581f1acc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e051b14745dd0fed087e1de51e6c902/" rel="bookmark">
			关于Element-UI Upload 上传图片第二次或第N次无反应的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果我们设置了 :limit="1" ，在我们上传完成第一张图片后，如果想更改当前的图片那么很幸运的告诉你，不行、没效果。发现后是不是立刻百度，会发现很多错综复杂的解决方案！直到自己眼晕脑胀也没有一点办法，那么很幸运的告诉你，你找到了我！
导致整个问题的原因是因为你没有清除当前 files，导致他一直保存这你第一次上传文件的信息，只要你把他一刀切掉就好了！
那么问题来了，应该怎么清除呢！看下面的代码：
//只需要给你的el-upload 定义一个ref就可以 &lt;el-upload class="upload-demo" ref="upload"&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; 然后，我们既然定义了ref 那么是不是就可以拿到它的document元素，那么岂不是很简单了，只需要在每次成功后给它清除掉就可以了，看码：
successUpload(response, file, fileList) { this.$refs.upload.clearFiles(); //上传成功之后清除历史记录 } 这样就能解决你不能继续长传的问题了！
希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。
如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f391fdc4ffe1a4da39358a365fbcec04/" rel="bookmark">
			Code::Blocks工具栏消失的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Code::Blocks时，有时候不知道点到了什么，工具栏全部消失了： 解决方法： View -&gt; perspectives -&gt; Code::Blocks default
然后就恢复正常了： By the way，左侧的工具栏通过Shift + F2打开： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01b630abd6033cd94bf3a712fce4b8c/" rel="bookmark">
			HCL安装问题(二)——创建设备时提示启动设备失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HCL问题(二)——创建设备时提示"启动设备失败" 遇到的问题如图所示：
由于将HCL和VirtualBox的兼容性调成一致都不行，于是将这两个软件分别进行卸载
1. 先安装HCL2.1.1，安装时不勾选安装VirtualBox的选项 2. 然后下载VirtualBox4.2.4 VirtualBox4.2.4下载地址
根据自己的需要下载，我的系统是Win10，选的是这个
3. 分别勾选两个软件的兼容模式 4. 结果 ————————————————————————————————— See the logfile ‘xxx’ for details问题解决：HCL安装问题(一)——打开软件提示“See the logfile ‘xxx’ for details”
其他问题可以看这个网址：关于HCL 安装遇到的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54f43b6d2309b9e9d432b4225d9f09d/" rel="bookmark">
			正高、正常高、大地高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 三高 大地水准面：与平均海水面重合并延伸到大陆内部的水准面，重力等位面（正高也叫海拔高度、绝对高程）。
似大地水准面：相对精度比较高的一个接近大地水准面的起算面（正常高、相对高程）。
正高没办法准确测量。根据某地纬度以平均重力g代入重力计算公式，得到的即是正常高。由于平均重力值的改变，其效果相当于重力起算面的改变，因此不再称其为大地水准面，而是似大地水准面，其特征就是海洋上与平均海水面重叠，陆地上则有差异。
参考椭球面：为处理大地测量成果而采用的与地球的大小、形状接近并进行定位的椭球体表面（大地高）。
2. 联系 大地高（参考椭球面）=正高（大地水准面）+N
N为大地水准面差距，大地水准面与参考椭球面之间的高程差。
大地高（参考椭球面）=正常高（似大地水准面）+ξ
ξ为高程异常，似大地水准面和参考椭球面之间的高程差。
3. 总结 正高不能准确测量，所以这个大地水准面仅仅是个理想化的模型。
正常高（似大地水准面）是能够准确测量的。
大地高仅是一个纯粹的几何概念，用来表示GPS中高程，同一个点在不同的椭球高基准下，大地高不同。例如千寻CORS的两个端口，WGS84和CGCS2000，使用不同的端口，即采用不同的椭球高基准，其测量的大地高都是不同的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c49b4ce45bea91555d727c5824a4c4/" rel="bookmark">
			5.Flink对接Kafka入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink Connector Kafka 1. Kafka1.1. [Kafka官网](http://kafka.apache.org/)1.2. Kafka 简述1.3. Kafka特性1.4. kafka的应用场景1.5. kafka-manager的部署1.6. `使用Kafka Connect导入/导出数据`1.7. [Kafka日志存储原理](https://blog.csdn.net/shujuelin/article/details/80898624) 2. Kafka与Flink的融合2.1. kafka连接flink流计算,实现flink消费kafka的数据2.2. flink 读取kafka并且自定义水印再将数据写入kafka中 3. Airbnb 是如何通过 balanced Kafka reader 来扩展 Spark streaming 实时流处理能力的4. 寄语：海阔凭鱼跃，天高任鸟飞 1. Kafka 1.1. Kafka官网 1.2. Kafka 简述 Kafka 是一个分布式消息系统：具有生产者、消费者的功能。它提供了类似于JMS 的特性，但是在设计实现上完全不同，此外它并不是JMS 规范的实现。 1.3. Kafka特性 消息持久化:基于文件系统来存储和缓存消息高吞吐量多客户端支持:核心模块用Scala 语言开发，Kafka 提供了多种开发语言的接入，如Java 、Scala、C 、C＋＋、Python 、Go 、Erlang 、Ruby 、Node. 等安全机制 通过SSL 和SASL(Kerberos), SASL/PLA时验证机制支持生产者、消费者与broker连接时的身份认证；支持代理与ZooKeeper 连接身份验证通信时数据加密客户端读、写权限认证Kafka 支持与外部其他认证授权服务的集成 数据备份轻量级消息压缩 1.4. kafka的应用场景 Kafka作为消息传递系统
Kafka 作为存储系统
Kafka用做流处理
消息，存储，流处理结合起来使用
1.5. kafka-manager的部署 Kafka Manager 由 yahoo 公司开发，该工具可以方便查看集群 主题分布情况，同时支持对 多个集群的管理、分区平衡以及创建主题等操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c49b4ce45bea91555d727c5824a4c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8db94443df466ea8bb577d59a7b3d27f/" rel="bookmark">
			微信小程序连续点击多次跳转页面问题的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
在view标签中（或button标签）添加了一个bindtap点击方法，点击跳转到指定页面。当你快速连续点击多次的时候会跳转多次页面，特别是网络卡或者手机卡顿的时候，非常影响用户使用体验。
点击方法
moreNewsClick:(function () { wx.navigateTo({ url: '../newsList/newsList', }) }, 解决办法
函数节流(throttle)：在一段时间内多次点击按钮只会执行第一次的函数。代码如下：
在/utils/util.js(工具类)中写入throttle方法:
function throttle(fn, gapTime) { if (gapTime == null || gapTime == undefined) { gapTime = 1500 } let _lastTime = null return function () { let _nowTime = + new Date() if (_nowTime - _lastTime &gt; gapTime || !_lastTime) { fn.apply(this, arguments) _lastTime = _nowTime } } } module.exports = { throttle: throttle } 在需要跳转的页面方法中如下的使用throttle方法:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8db94443df466ea8bb577d59a7b3d27f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c85a15abbc71bb4cb217d0818126af2/" rel="bookmark">
			蓝桥杯基础练习所有非VIP习题解答C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数列排序 资源限制
时间限制：1.0s 内存限制：512.0MB
问题描述
给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200
输入格式
第一行为一个整数n。
第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。
输出格式
输出一行，按从小到大的顺序输出排序后的数列。
样例输入
5
8 3 6 4 9
样例输出
3 4 6 8 9
代码如下：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { int n, i, j, k, t; do { scanf("%d",&amp;n); }while(n&lt;1||n&gt;200); int a[n]; for(i=0;i&lt;n;i++) { scanf("%d",&amp;a[i]); } for(i=0;i&lt;n;i++) { k = i; for(j=i+1;j&lt;n;j++) { if(a[j]&lt;a[k])k = j; } if(i!=k) { t=a[i]; a[i]=a[k]; a[k]=t; } } for(i=0;i&lt;n;i++) { printf("%d\t",a[i]); } return 0; } 十六进制转八进制 资源限制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c85a15abbc71bb4cb217d0818126af2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1ed31c5bec7df44d14d4ac53e388df/" rel="bookmark">
			JS获取对象长度大小！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景: 前端处理时会经常涉及DOM相关的操作,期间遇到获取对象长度的问题,特此纪要! 问题: 前端如何通过JS获取对象的长度大小? 解决办法: /** * js对象无法直接通过.length来获取对象的长度大小。 * 获取方式： * var length = Object.keys(obj).length; */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34887bd8e293c97c2051e4b7674c41d5/" rel="bookmark">
			解决项目启动报错：找不到类，Cannot find class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错内容： 在开发Maven企业项目时，报错找不到某个类，报错内容：
Error creating bean with name ‘sqlSessionFactory’ defined in class
path resource [spring/spring-mybatis.xml]: Invocation of init method
failed; nested exception is
org.springframework.core.NestedIOException: Failed to parse mapping
resource:
‘file[D:\projects\tools\apache-tomcat-8.5.30\webapps\lixin_web\WEB-INF\classes\mapper\jieshaoMapper.xml]’;
nested exception is org.apache.ibatis.builder.BuilderException: Error
parsing Mapper XML. Cause:
org.apache.ibatis.builder.BuilderException: Error resolving class.
Cause: org.apache.ibatis.type.TypeException: Could not resolve type
alias ‘com.lixin.framework.beans.JieShao’. Cause:
java.lang.ClassNotFoundException: Cannot find class:
com.lixin.framework.beans.×××
解决办法： 1. 右击项目→Maven→Update Project
2. 勾选报错的项目，勾选Force Update of Snapshots/Releases，点击OK
3.重新启动项目试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3958909ac0dc17d4843a9ce47da3c9da/" rel="bookmark">
			微积分基本定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前为止，我们通过逼近和的极限，得到了一个相当复杂的连续函数定积分的定义，
∫baf(x)dx=limmax Δxk→∞∑k=1nf(x∗k)Δxk(1)
之前我们已经用这个定义计算了一些简单的积分，例如
∫b0xdx=b22,∫b0x2dx=b33,and∫b0x3dx=b44(2)
这些计算有两个目的：通过提供一些逼近和的直观经验来强调积分的基本性质，并且这种方法得到的极限值可以作为计算其他积分的实用工具。那么，我们可以利用极限和的方方求解下面更复杂的积分吗？
∫10x47+x5−−−−−√3dxand∫21(1+1x)4dxx2(3)
这显然是不可能的，所以我们该何去何从呢？显然我们需要的是一种更高效、更强大的计算积分方法，而这种方法就是牛顿和莱布尼兹的想法。
牛顿-莱布尼兹解决(1)那样积分问题的计算方法乍一看似乎是自相矛盾的。为了解决这个问题，我们用更难的问题来替换它。我们不求解图1左那样固定的面积，而是图1右边变化的面积，图像右边的边界是可以移动的，这样的话面积就是x
的函数。面积函数用A(x)表示，那么显然左边图中A(a)=0,A(b)表示固定的面积。我们的目标是找到一个A(x)的显示公式，然后通过设置x=b
来确定所需的面积。在这个过程中有几个步骤，为了清楚起见，我们单独考虑。
图1
步骤1：我们通过建立重要的事实
dAdx=f(x)(4)
开始。这是说面积A
关于x
的变化率等于区域右边界的长度。为了证明这个命题，我们必须考虑导数的定义
dAdx=limΔx→0A(x+Δx)−A(x)Δx
现在A(x)
是图像下边a,x之间的面积，A(x+Δx) 是a,x+Δx之间的面积。因此，分子A(x+Δx)−A(x)是a,x+Δx之间的面积(看图2中阴影部分的面积)。很容易看出面积等于有着相同底，高为f(x¯)的矩形面积，其中x¯是x,x+Δx
之间的某个点。由它我们继续(4)的证明：
dAdx=limΔx→0A(x+Δx)−A(x)Δx=limΔx→0f(x¯)ΔxΔx=limΔx→0f(x¯)=f(x)
利用到f(x)
是连续函数。为了更加详细的解释最后一步，我们指出Δx→0等价于x+Δx→x；因为x¯位于x,x+Δx之间，所以x¯→x，现在利用函数的连续性得f(x¯)→f(x)
图2
步骤2：方程(4)告诉我们，找到面积函数A(x)
就能实现我们的目标。根据(4)，A(x)是函数f(x)的反导之一。但是，如果F(x)是任何一个f(x)
的反导，根据前面不定积分的知识我们有
A(x)=F(x)+c(5)
c
是常数值。为了确定c，我们令x=a，从而得到A(a)=F(a)+c；但是因为A(a)=0，从而得出c=−F(a)
。因此
A(x)=F(x)−F(a)(6)
就是需要的公式。
步骤3：根据(6)和A(x)
的意义，其余的工作就是观察
∫baf(x)dx=A(b)=F(b)−F(a)
我们用正式地微积分基本定理总结我们得到的结论：
如果f(x)
是闭区间[a,b]上的连续函数，并且F(x)是f(x)的任何一个原函数，即(d/dx)F(x)=f(x)
或等价地
∫f(x)dx=F(x)(7)
那么
∫baf(x)dx=F(b)−F(a)(8)
这个定理将计算极限和的问题转变成更容易的找原函数的问题，从而减小了评估定积分问题。因此，为了找出∫baf(x)dx
的值，我们没必要考虑求和；我们只是找到原函数即可，可以用任何方式如猜测、常规计算、巧妙计算或查书，然后计算F(b)−F(a)
的值。
例如，在上篇文章中，我们利用许多代数技巧得到了公式(2)。现在，借助基本定理，下面简单的公式就像明显的事实：
∫b0xdx=b22,∫b0x2dx=b33,and∫b0x3dx=b44
更一般地，对任何指数n&gt;0
，明显可以得出
∫baxndx=bn+1n+1−an+1n+1,because∫xndx=xn+1n+1
注解1： 在计算问题的过程中，使用括号是很方便的
F(x)∣∣ba=F(b)−F(a)(9)
符号的意思就是说：x
上限为b时的F(x)值减去x下限为a时的F(x)就是我们要找的数。例如x2∣∣43=42−32=16−9=7
。利用这个符号，(8)可以写成
∫baf(x)dx=F(x)∣∣ba
注解2：从这次讨论中可以看出，任何f(x)
的原函数都用(8)解决。如果对此还有疑问，那么回顾一下，如果F(x)是一个原函数，那么其他任何一个都可以通过添加一个常数c得到即F(x)+c
；因为
F(x)+c∣∣ba=[F(b)+c]−[F(a)+c]=F(b)−F(a)
常数c
对结果没有影响。因此当计算定积分要找原函数时，我们可以忽略常数。(然而，当我们要解决微分方程时，这些常量是不可或缺。)
例1：计算下面的定积分：
(a)∫2−1x4dx(b)∫161dxx−−√(c)∫278x−−√3dx(d)∫1413(x−13)10dx
解：通过观察每个原函数都比较容易得到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3958909ac0dc17d4843a9ce47da3c9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424ea5c82976f2b4a0bac3b24ef529ee/" rel="bookmark">
			数据库 sqlite top写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlite 本身没有top功能，无法向tsql一样下select top 100 * from tb_table，但sqlite提供了一个limit关键字用来取得相应行数的资料
具体语法实例：select * from tb_table order by tb_ser limit 5 offset 2（从tb_table表中从第3行取5笔资料，offset不是必须，如果只是取前几笔可以只用limit即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83750b261b6f29a4c9fa2238b1efb52/" rel="bookmark">
			机器学习-线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习-线性回归算法简单理解 一、基本含义 线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w’x+e，e为误差服从均值为0的正态分布。
回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。
二、拟合方程 我们所采用的拟合方程为最小二乘法，可以计算出对于y=bx+a的直线。
可以计算出对于y=bx+a的直线。同时可以表示为y = x.T*w , x = [x0 x1].T , w = [b w].T;
三、损失函数 其原理为真实值与预测值的差值
实现过程 一、导入相关模块
import pandas as pd import matplotlib.pyplot as plt import numpy as np import random 二、生成数据集
x,y= [],[] for i in range(1,100): x.append([1,2*(i+random.uniform(-0.3,0.3))+3+random.random()]) y.append([i+random.uniform(-5,5)]) x = np.matrix(x) y = np.matrix(y) 三、可视化数据，观察变化特性
plt.scatter(y.A,x[:,1].A,c='b',s=5) plt.show() 四、计算参数矩阵
xtx = x.T*x; if(np.linalg.det(xtx)==0): #判断行列式是否等于0，如果等于0则不可逆，求伪逆 ws = np.linalg.pinv(xtx) * (x.T*y) else ws = xtx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e83750b261b6f29a4c9fa2238b1efb52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb50fe5d5db4a7d719081c8e09048f31/" rel="bookmark">
			分享一些压箱底的福利网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一些压箱底的福利网站
里面的网站都是完全免费的，可以放心使用
电影网站：
http://www.928kan.com 928观影
https://v.2ha.cn 爱哈影视
http://52mxtv.com 米熊影视
http://top.pptv.com pp视频
https://www.6080.tv 6080电影网
www.aishang118.cn 爱上118影视
自学网站：
http://www.icourses.cn/home/ 爱课程
https://www.yxgapp.com 译学馆
http://www.dxzy163.com 大学资源网
https://www.51zxw.net 我要自学网
https://www.icourse163.org 中国大学mooc
https://open.163.com 网易公开课
副业网站：
https://www.mi46.cn/GHK.do 软件体验网
前端：
https://www.html.cn/tool/ html中文网
http://tools.bugscaner.com 在线工具库
https://tool.oschina.net 在线工具
https://www.php.cn php中文网
https://juejin.im 掘金
设计网站：
https://www.fotor.com.cn 懒设计
http://www.aigei.com/course/ 爱给
https://www.17sucai.com 17素材网
http://www.lanrentuku.com 懒人图库
http://www.16xx8.com ps教程自学网
https://color.adobe.com 配色网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7cd5e7539774753867704c96162a560/" rel="bookmark">
			最长公共子序列 -- C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。
示例 1: 输入：text1 = "abcde", text2 = "ace" 输出：3 解释：最长公共子序列是 "ace"，它的长度为 3。
示例 2: 输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
示例 3: 输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
提示: 1 &lt;= text1.length &lt;= 1000
1 &lt;= text2.length &lt;= 1000
输入的字符串只含有小写英文字符。
思路 使用动态规划法，建立dp；dp[i][j] 表示 s1[0....i-1]和s[0...j-1]的公共子串大小，如果 s1[i-1] 和 s2 [j -1] 相同，那么又找到了一个公共字符，所以 dp[i][j] = dp[i - 1][j - 1] + 1; 如果不相同，从最长的两个子串（“s1[i-1] 和 s2 [j] ” 或 “s1[i] 和 s2 [j -1] ”）中，选出LCS较大的那个作为 dp[i][j] , dp[i][j] = MAX(dp[i - 1][j], dp[i][j - 1]); 注意，下标是从0开始标记的，所以这里应该变为 i - 1 和 j - 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7cd5e7539774753867704c96162a560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a3fb5716913f54db93dab9d9a03c71/" rel="bookmark">
			npm报错：A complete log of this run can be fund in: cache_logs 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm报错：A complete log of this run can be fund in: cache_logs 解决方案 项目运行出现如下错误：
PS D:\SoftData\WebstormProjects\vue2\vue-cms&gt; npm start npm ERR! missing script: start npm ERR! A complete log of this run can be found in: npm ERR! d:\Program Files\nodejs\node_cache\_logs\2020-03-08T23_03_16_099Z-debug.log 解决方法：
首先确定出现问题的原因，核对是否因为包未完整下载再核对package.json中配置的脚本命令 "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --mode development --open --port 3000 --hot --disableHostCheck" } 包未完整下载 删除原始node_modules文件夹先删除清理缓存npm cache clean --force重新安装npm i 问题解决
未包含所使用的脚本命令 脚本中只存在test、dev命令使用npm run 命令时，只能使用npm run dev或npm run test,使用npm run start会报错 一定要确保只能使用package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a3fb5716913f54db93dab9d9a03c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef5330491489c652c3139cb1b64dcff/" rel="bookmark">
			卷积操作后特征图大小计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，卷积操作 若图像为正方形：设输入图像尺寸为WxW，卷积核尺寸为FxF，步幅为S，Padding使用P,经过该卷积层后输出的图像尺寸为NxN：
若图像为矩形：设输入图像尺寸为WxH，卷积核的尺寸为FxF，步幅为S，图像深度(通道数)为C，Padding使用P，则：
卷积后输出图像大小：
， ， 输出图像的通道数=C 注意：Padding的作用用于解决图像边缘信息损失的问题
如same：(same模式只有步长为1时，输入和输出的尺度才相同) 输入特征图为5x5，卷积核为3x3，外加padding 为1，则其输出尺寸为 二，池化操作 设输入图像尺寸为WxH，其中W:图像宽，H:图像高，D:图像深度（通道数），卷积核的尺寸为FxF，S:步长
池化后输出图像大小：
池化后输出图像深度为D
当进行池化操作时，步长S就等于池化核的尺寸，如输入为24x24，池化核为4x4，则输出为
若除不尽，则取较小的数，如池化核为7x7，则输出为，不是用四舍五入，就是取最小的整数，即使为3.9，也是 取3
三，空洞卷积(也称扩张卷积，膨胀卷积)--dilated convolution 其中 d为空洞卷积的空洞率（正常的卷积d=1），p为padding，k为kernel size
举个例子：
下面的空洞卷积核是d=2，k=2的空洞卷积卷积核。
当d=2，k=2时，-d(k-1)-1 = -3，即相当于 一个k=3的正常卷积核。下图的正好是3x3的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c5452498bebc8677c77dca6805c2ac/" rel="bookmark">
			新版unity的log输出地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在旧版unity（2017）之前，如果unity要发布成pc端的exe，unity中的log会输出在Data文件下，但是新版之后，log不再这里了，output_log.txt会生成在C盘。C:\Users\xxx用户\AppData\LocalLow\xx公司\xx项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbdd3f870337c8ab5205400280828ff/" rel="bookmark">
			python 列表 分割 list.split( )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 列表 分割 list.split( )
list.split() 就是以字符串或列表里某个字符把字符串或列表进行分割成新的字符串或列表。
list.split(“，”) 这就是以“，”来分割，如果原来字符串或列表里没有“，” 则无法成功。
引用网上一个例子更经典！！！！
str="hello boy&lt;[www.doiido.com]&gt;byebye" str.split("[")[1].split("]")[0] # 输出 'www.doiido.com' str.split("[")[1].split("]")[0].split(".") # 输出 ['www', 'doiido', 'com'] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4cdd167ff27cdf22abd8f5cd7a96e00/" rel="bookmark">
			论文解读 | 基于正则化图神经网络的脑电情绪识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©PaperWeekly 原创 · 作者｜张玮玮
学校｜东北大学硕士生
研究方向｜情绪识别
引言
论文动机 现有的基于脑电图的情绪识别方法大多不能很好地解决以下三个方面的问题：
1. 脑电图信号的拓扑结构没有被有效地利用来学习更多的有鉴别性的脑电图特征然而，大多数方法需要在头皮上对脑电图通道进行 2D 表示，这可能会在 flatten 过程中造成信息丢失，因为通道实际上是在 3D 空间中排列的；
2. 不同受试者的脑电图信号差异较大，不利于训练分类器的泛化；
3. 参与者在观看引发情绪的刺激时，可能并不总是产生与刺激一致的预期情绪。
目前研究中，在基于脑电图的情绪识别方面，还没有人试图解决噪音标签的问题。作者提出了一个正则化的图神经网络（RGNN）来解决上述三个问题。
论文标题：EEG-Based Emotion Recognition Using Regularized Graph Neural Networks
论文链接：https://arxiv.org/abs/1907.07835
源码链接：https://github.com/zhongpeixiang/RGNN
论文工作 脑电信号中的每个通道看作是图形中的一个节点。RGNN 模型扩展了简单图卷积网络（SGC），利用了脑电图信号的拓扑结构，即根据脑网络组织的经济性，作者提出了一个符合生物原理的稀疏邻接矩阵来捕捉局部和全局的通道间关系。局部通道间关系连接附近的神经元群，可以显示解剖学上的连通性。整体的通道间关系连接左右脑半球之间的神经元群，可以揭示与情绪相关的功能连接。
此外，作者提出一个节点域对抗训练（NodeDAT）来正则化图模型，以更好地解决跨被试分类场景，并且还提出了一种基于情绪感知的分布学习（EmotionDL）方法来解决数据集中的噪声标签问题。
RGNN知识基础
简单图卷积网络
给定图 ， 表示节点集， 表示边集。 表示特征矩阵， 表示节点的数目， 输入特征的维度。 可以用加权邻接矩阵 表示。
一般情况下，GNNs 对输入 学习一个特征变换函数，生成输出 , 表示输出的维度。特征转换可以写成： ，这里 ， 。
GCN (graph convolution network) 的方法如公式所示：
其中 表示 的对角度矩阵，规范化邻接矩阵 可以防止 变得过大。
SGC 方法消除非线性函数 和将所有层之间的所有线性变换 重新参数化为一个线性变换 ，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4cdd167ff27cdf22abd8f5cd7a96e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8223287c4ce184c08041c1483ac8042/" rel="bookmark">
			GB/T 35273—2020《信息安全技术个人信息安全规范》正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GB/T 35273—2020《信息安全技术个人信息安全规范》 2020年3月6日，国家市场监督管理总局国家标准化管理委员会正式发布 GB/T 35273—2020《信息安全技术个人信息安全规范》
GB/T 35273—2020《信息安全技术个人信息安全规范》标准是按照GB/T
1.1—2009给出的规则起草，2020年10月1日正式实施，届时将代替原GB/T 35273-2017《信息安全技术个人信息安全规范》标准
GB/T 35273—2020 与 GB/T 35273-2017相比，主要有变化如下:
增加了“多项业务功能的自主选择”修改了“征得授权同意的例外;增加了“用户画像的使用限制”增加了“个性化展示的使用”增加了“基于不同业务目所收集个人信息的汇聚融合”修改了“个人信息主体注销账户”增加了“第三方接入管理”(见9.7);修改了“明确责任部门与人员”;增加了“个人信息安全工程”;增加了“个人信息处理活动记录”;修改了“实现个人信息主体自主意愿的方法” 附下载地址：download.csdn.net/download/weixin_46192679/12234069
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0fd0d7b20701b329a9805ee4759f3c2/" rel="bookmark">
			【Python计算机视觉编程】第二章 SIFT特征提取与检索及RANSAC实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.SIFT描述子1.SIFT特征简介1.1 SIFT算法可以解决的问题1.2 SIFT算法实现步骤1.3 关键点检测相关概念1.3.1 尺度空间1.3.2.关键点检测-Dog 2.检测感兴趣点（例题）3.描述子匹配（例题） 二.SIFT特征提取与检索（实验）1. 数据集准备2. 特征提取2.1 运行结果2.2 分析 3. 描述子匹配4. 输出匹配图片4. 1 代码4. 2 运行结果 三. 地理标记图像匹配3.1 代码3.2 运行结果 四. 实验中遇到的问题和得出的结论五. RANSAC原理及运用5.1 RANSAC——随机一致性采样5.2 示例5.3 使用RANSAC算法匹配5.3.1 源代码5.3.2 结果分析 一.SIFT描述子 1.SIFT特征简介 1.1 SIFT算法可以解决的问题 (1) 目标的旋转、缩放、平移（RST）
(2) 图像仿射/投影变换（视点viewpoint）
(3) 弱光照影响（illumination）
(4) 部分目标遮挡（occlusion）
(5) 杂物场景（clutter）
(6) 噪声
1.2 SIFT算法实现步骤 SIFT算法的实质可以归为在不同尺度空间上查找特征点（关键点）的问题。
实现特征匹配流程如下：
(1) 提取关键点；
(2) 对关键点附加 详细的信息（局部特征），即描述符；
(3) 通过特征点（附带上特征向量的关 键点）的两两比较找出相互匹配的若干对特征点，建立景物间的对应关系。
1.3 关键点检测相关概念 这些点是一些十分突出的点不会因光照、尺度、旋转等因素的改变而消失，比如角点、边缘点、暗区域的亮点以及亮区域的暗点。既然两幅图像中有相同的景物，那么使用某种方法分别提取各自的稳定点，这些点之间会有相互对应的匹配点。
1.3.1 尺度空间 尺度空间理论最早于1962年提出，其主要思想是通过 对原始图像进行尺度变换，获得图像多尺度下的空间表示。从而实现边缘、角点检测和不同分辨率上的特征提取，以满足特征点的尺度不变性。
尺度越大图像越模糊。
1.3.2.关键点检测-Dog 1.Dog的局部极值点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0fd0d7b20701b329a9805ee4759f3c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db8dbc7901a7d547e7b8c1ef4a2a13c/" rel="bookmark">
			计算机视觉-SIFT特征提取及匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、SIFT描述子介绍1.1 SIFT描述子定义1.2 SIFT特征1.3 SIFT检测过程1.4算法介绍 2、数据集准备3、图片的SIFT特征提取并展示特征点3.1 代码实现3.2 结果展示3.3 实验分析 4、特征匹配4.1代码实现4.2结果展示4.3实验结果 5、图像匹配5.1代码实现5.2结果展示5.3 实验结果 6、数据集匹配6.1代码实现6.2结果展示6.3实验结果 7、RANSAC算法去除误匹配7.1RANSAC算法原理7.2RANSAC算法步骤7.3RANSAC实现7.3.1景深丰富7.3.2景深单一 7.4 实验结果分析 8、实验问题及总结 1、SIFT描述子介绍 1.1 SIFT描述子定义 SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换，由加拿大教授David G.Lowe提出的。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。
1.2 SIFT特征 1、图像的局部特征，对旋转、尺度缩放、亮度变化保持不变，对视角变化、仿射变换、噪声也保持一定程度的稳定性。
2、独特性好，信息量丰富，适用于海量特征库进行快速、准确的匹配。
3、 多量性，即使是很少几个物体也可以产生大量的SIFT特征
4、高速性，经优化的SIFT匹配算法甚至可以达到实时性
5、 扩招性，可以很方便的与其他的特征向量进行联合。
1.3 SIFT检测过程 1.构造高斯差分空间图像。
2.寻找极大极小值点
3.精确定位极值点
4.选取特征点主方向
5. 构造特征点描述算子。
1.4算法介绍 1.尺度空间极值检测——即找特征点
对于二维图像I(x，y)，建立图像的DOG （difference of guassians，即高斯差分）金字塔，DOG尺度空间含义为：可以用一个尺度空间的高斯函数和图像的卷积来表示。
G为尺度可变的高斯函数，***I***为空间坐标，其中西伽马为尺度。
为确定特征点所在的位置，首先需要建立一个高斯金字塔。
得到高斯金字塔后，再通过两个相邻的高斯尺度空间做差，得到高斯差分DOC金字塔，整个过程的公式如下:
高斯差分金字塔建立后，特征点就是DOG尺度空间众多极值点，（个人认为对其进行求偏导数即可得到特征点的位置坐标），查找该极值点需要把每个点与邻域内的周围的26个点进行比较，这些点包括，在同一尺度上相邻的8个点，以及相邻尺度上相邻的18个点。
2.特征点的尺度方向的确定
得到了特征点的坐标是完全不够的，必须要增加方向尺度信息。
· 采用有限差分的方法，求出在以特征点为圆心，以3倍西伽马为半径的范围内的图像梯度的幅值和相位。
· 利用直方图统计方法，求助邻域内所有像素点的梯度方向以及幅值。特征点的主方向就是直方图的峰值所代表的方向，确定了主方向就可以使SIFT算法具备旋转不变性。
3.特征向量的生成
特征向量最终是通过求得的特征点的邻域梯度信息来计算的。
· 先把坐标轴位置旋转到特征点所在的主方向上
· 接着以特征点为圆心，选择特征点附近的16个点作为种子点，分别求出8个方向上的梯度大小
· 最后得到的128维向量即为所求的特征向量
4.特征点的匹配
通常采用最邻近的方法，即查找每一个特征点在另外一副图像中的最邻近，即最短的欧式距离。
欧式距离的含义就是：两点连线的距离长度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4db8dbc7901a7d547e7b8c1ef4a2a13c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c15b22e9dbd50c9470722a0c050455/" rel="bookmark">
			蓝桥杯题库 算法提高非vip部分（C&#43;&#43;、Java）代码实现（101-200）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ADV-103 逆序排列cpp:java: ADV-112 c++_ch02_01cpp:java: ADV-120 6-17复数四则运算cpp:java: ADV-123 概率计算cpp:java: ADV-127 日期计算cpp:java: ADV-141 判断名次cpp:java: ADV-143 扶老奶奶过街cpp:java: ADV-144 01背包cpp:java: ADV-147 学霸的迷宫cpp:java: ADV-150 周期字串cpp:java: ADV-151 金陵十三钗cpp:java: ADV-155 上帝造题五分钟cpp:java: ADV-158 新建Microsoft Word文档cpp:java: ADV-162 题目1 最大最小值cpp:java: ADV-164 金明的预算方案cpp:java: ADV-167 快乐司机cpp:java: ADV-171 身份证号码升级cpp:java: ADV-175 三个整数的排序cpp:java: ADV-178 简单加法cpp:java: ADV-188 排列数cpp:java: ADV-193 盾神与条状项链cpp:java: ADV-197 P1001cpp:java: ADV-200 求最大值cpp:java: 将定期更新蓝桥杯习题集的解题报告~
ADV-103 逆序排列 cpp: #include &lt;iostream&gt; using namespace std; int a[25]; int main() { int i = 0, j, temp; while (cin &gt;&gt; temp) { if (temp == 0) break; a[i] = temp; i++; } if (i == 0) cout &lt;&lt; endl; else { for (j = i - 1; j &gt; 0; j--) cout &lt;&lt; a[j] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c15b22e9dbd50c9470722a0c050455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f808919022564afe5cb81b463a878f/" rel="bookmark">
			Linux基于Docker安装Jenkins及相关Java部署插件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux基于Docker安装Jenkins及相关Java部署插件安装 1、安装Docker2、下载Jenkins镜像3、创建Jenkins挂载目录，并设置其权限4、创建并启动Jenkins容器5、开启端口或关闭防火墙6、进入我们Jenkins搭建完成的页面中7、获取密钥文件地址8、回到Linux系统，打开文件，获取密钥9、使用密码10、选择安装推荐的插件11、设置用户12、进入系统设置语言13、安装Maven插件14、设置JDK15、设置Maven16、保存17、语言转换成中文18、重启Jenkins19、安装完成 1、安装Docker 首先，我们需要先安装DockerDocker安装教程连接地址，请点击这里 2、下载Jenkins镜像 docker pull jenkinsci/blueocean:latest 由于我latest版本下载太慢，我换了一个版本 docker pull jenkinsci/blueocean:1.22.0-bcc31d32159f 如果下载地址太慢建意切换镜像加速地址 http://hub-mirror.c.163.com 腾讯云docker镜像加速，只用用他的云主机下载才能加速（幸好买了一台，简直就是秒下） https://mirror.ccs.tencentyun.com 3、创建Jenkins挂载目录，并设置其权限 mkdir -p /home/jenkins chmod 777 /home/jenkins 4、创建并启动Jenkins容器 这里不使用8080端口做映射，是因为我用云服务器搭建，8080端口经常会被网警拦截
docker run -d --name jenkinsci -p 5500:8080 -p 50000:50000 -v /home/jenkins:/var/jenkins_home jenkinsci/blueocean:1.22.0-bcc31d32159f 5、开启端口或关闭防火墙 临时关闭防火墙命令systemctl stop firewalld 开启相关端口（推荐）firewall-cmd --zone=public --add-port=5500/tcp --permanent firewall-cmd --zone=public --add-port=50000/tcp --permanent 更新防火墙规则firewall-cmd --complete-reload 查看当前所开放的端口firewall-cmd --zone=public --list-ports 6、进入我们Jenkins搭建完成的页面中 IP地址加端口 127.0.0.1:5500 7、获取密钥文件地址 在进入刚搭建完成的Jenkins页面中会出现，需要密钥的情况。此时它会告诉我们密钥的文件路径，由于我们设置了挂载目录，我们就无须进入容器内部去看了，直接在外部 /home/jenkins/secrets/initialAdminPassword 8、回到Linux系统，打开文件，获取密钥 cat /home/jenkins/secrets/initialAdminPassword 9、使用密码 我们将密钥复制，并在网页上使用 10、选择安装推荐的插件 进入网页后会有选择，一个是安装推荐的插件，另一个是安装自定义的插件，我们选择推荐的插件，也就是第一个
安装过程中请耐心等待，注意联网
11、设置用户 首次登录将会提示需要创建用户，我们在此创建一个用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72f808919022564afe5cb81b463a878f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609583a5cc21001442e20977f94fb153/" rel="bookmark">
			【工具-IDEA】如何在IDEA里面只运行一个java文件，而不是编译运行整个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击Edit Configurations...
点击build，然后点击上面的—，不让它编译整个项目即可。你运行的时候直接点run xxx.main就可以运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34e3e1f5689f1be30467b129c14cb47/" rel="bookmark">
			k8s（8）—— k8s存储之ConfigMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、ConfigMap简介 1、ConfigMap的概念 二、Cofigmap配置管理 创建Cofigmap的方式有4种
1、使用字面值创建 2、使用文件进行创建 3、使用目录进行创建 4、编写cofigmap的yaml文件年创建 三、使用configmap设置环境变量 （一）、方法一：
1、创建yaml文件2、查看更新的情况 （二）、方法二：
1、修改yaml文件的配置内容2、测试 （三）、直接指定答应的key对应的值
1、修改yaml文件 2、测试 （四）通过数据卷使用configmap
1、查看官网信息2、创建yaml文件 四、configmap热更新 （一）、热更新的验证 1、创建yaml文件
2、修改文件cm4-config文件的内容查看更新
（二）、configmap热更新后，并不会触发相关的pod的滚动更新，需要手动触发：
1、创建nginx.conf文件 nginx端口服务的文件
2、以nginx.config 来创建configmap
3、要使yaml文件生效改变 pod的更新需要手动更新
一、ConfigMap简介 1、ConfigMap的概念 ConfigMap 资源提供了向 Pod 注入配置数据的方法。 ConfigMap 对象中存储的数据可以被 configMap 类型的卷引用，然后被应用到 Pod 中运行的容器化应用。
当引用 configMap 对象时，你可以简单的在 Volume 中通过它名称来引用。 还可以自定义 ConfigMap 中特定条目所要使用的路径。 例如，要将名为 log-config 的 ConfigMap 挂载到名为 configmap-pod 的 Pod 中
cofigmap 配置管理
Cofigmap由于保存配置数据，以键值对形式存储
Cofigmap资源提供了向Pod注入配置数据的方式
旨在让镜像和配置年文件解析藕，以便实现景象的可移植性和可复制性
典型的使用场所：
填充环境变量的值
设置容器内的命令行的参数
填充卷的配置文件
官网信息：https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34e3e1f5689f1be30467b129c14cb47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef57df8fbc2bbacc90559406403098c/" rel="bookmark">
			求字符串‘abaabcac’的next数组和nextval数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天刷到一个笔试题，求一个字符串在KMP算法下的next数组和nextval数组
几番百度和看题解，居然大多数的题解都有毛病被一顿吐槽
几番周折终于搞懂了怎么求next数组和nextval数组，在此记录下
题目是：
求字符串abaabcac的next数组和nextval数组：
结果如下：
注意： 这里的数组下标从1开始数
首先，通过一个动图来了解下求next数组的过程
本图来自这个博客
我觉得这张图已经很直观了，下面我就对求解的方法做一点自己的总结
求next数组 next[1] = 0next[2] = 1当i &gt; 2 时，如：求next[5] 求next[0]~next[i - 1]所构成的串的首子串和尾子串（首子串不包括最后一个，尾子串不包括第一个）
next[0]~next[4]为：abaa
首子串：a，ab，aba
尾子串：baa，aa，a计算首尾子串中相同的子串的长度
相同的子串为a，长度为1next[i] = length + 1
求得长度为1,1+1 = 2，所以next[5] = 2 求nextval数组 求nextval[i]的值，我们要比较String[i]和String[next[i]]的值 如果String[i]和String[next[i]]的字符相等，那么nextval[i]的值就等于nextval[next[i]]的值，如果String[i]和String[next[i]]的字符不相等，那么nextval[i]的值就等于next[i]的值。 就上面的串进行演示：
i = 1
nextval[1] = 0i = 2
nextval[2] = 1i = 3
next[3] = 1
String[3] = a
String[1] =a == a
nextval3] = nextval[1] = 0i = 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef57df8fbc2bbacc90559406403098c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d820e861b08f66dd6ed0d549f98819fc/" rel="bookmark">
			Kali Linux 2020.1 修改系统语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.背景信息二.操作步骤三.相关总结 一.背景信息 在安装完 kali linux 2020.1 时，其操作系统默认语言为英文的，我们操作起来比较麻烦，为了以后操作方便起见，这边将其操作系统默认语言更改为中文。本篇文章将带领各位小伙伴们一起去将操作系统默认语言更改为中文
二.操作步骤 打开Terminal Emulator 界面，查看当前系统语言为默认英文 在Terminal Emulator 中执行dpkg-reconfigure locales命令 注意：如果是root用户可直接执行dpkg-reconfigure locales命令，如果是kali用户则需先切换成root用户登陆再进行执行
具体切换成root用户登陆请参考下列链接地址：https://blog.csdn.net/weixin_46192679/article/details/104474829
3.找到en_US.UTF-8 UTF-8选项，按空格键将其进行取消
4.找到[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8两个选项，使用空格将[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8其两项勾选上
5.勾选完毕以后，在&lt;0k&gt; 处按下空格，进行下一步
6. 在此处选择zh_CN.UTF-8字符编码，在&lt;0k&gt; 处按空格键进行确认 ，并完成相关配置操作
7.配置完毕以后，使用reboot命令重启系统使其生效
8.重启完毕以后，可以看到相关登陆登陆页面已经是中文显示了，至此配置完毕。
三.相关总结 1.打开Terminal Emulator 界面，查看当前系统语言为默认英文
2.在Terminal Emulator 中执行dpkg-reconfigure locales命令
3.使用空格键取消勾选en_US.UTF-8 UTF-8选项
4.勾选[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8两个选项
5.使用reboot命令重启机器使其配置生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43298121c6edefd0a0177f171a11ea9/" rel="bookmark">
			oracle数据库备份还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入sqlplus界面登录数据库 : conn 用户名/密码
(1)删除用户和表空间
/*步骤一:删除用户USER*/
DROP USER ETL_EXT_KY CASCADE;
COMMIT;
/*删除不掉时*/
SELECT SID,SERIAL# FROM V$SESSION WHERE USERNAME = 'ETL_EXT_KY';
ALTER SYSTEM KILL SESSION '9,16585';
ALTER SYSTEM KILL SESSION '411,1807';
ALTER SYSTEM KILL SESSION '46,21725';
ALTER SYSTEM KILL SESSION '221,7440';
ALTER SYSTEM KILL SESSION '231,15475';
ALTER SYSTEM KILL SESSION '234,1490';
ALTER SYSTEM KILL SESSION '391,10664';
ALTER SYSTEM KILL SESSION '398,1678';
ALTER SYSTEM KILL SESSION '596,17417';
ALTER SYSTEM KILL SESSION '606,4638';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d43298121c6edefd0a0177f171a11ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb2525e03df7e89ae50ca52dcd0b6ff/" rel="bookmark">
			android仿地铁行进线路图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在坐地铁的时候，能看到有些地铁上是有地铁行进动画和站点到达动画的，最近在做项目的时候，就有一个类似这样的需求，不同的是展示的点有限制，多出来的点是需要是折贴起来的，当需要展示时再拉出来，大致动画如下：
看到这样一个动画，你有什么想法呢？对于这个动画，我有一个同事使用的是RecycleView去做的，做出来后差不多有十几个类，里面的逻辑还是比较复杂的，由于同事离职，这里面还有一些问题存在，由我接手修改，确实不太好改，没办法，尝试自己撸一个。对于这样一个动画，我首先想到的是使用自定义View来解决。先来说一下绘制这个View的大致思路：先绘制静态的，在绘制动态的。
1、如何绘制静态的呢，这个比较简单，不过这里需要考虑一个问题，站点抽出是向左抽出的，所以绘制时应该从右边开始画，主要的界面是由圆还有线绘制成的，这些都很简单，现在主要来说说这写点线位置的计算，首先一开始左右位置的间隙是对称的，这里可以根据预先设置的点的个数，根据屏宽和预先设置的参数计算出线的长短，这样就可以画出这些点还有线了，点还有线绘制完后，就差文字及其背景了，文字这个不多说，背景其实也就是一条线，只不过是比较宽而已。
2、比较难的是动态绘制的处理，可以看出，点一次可以拉出1~3个，这里将一个点和一条线看做是一段长，这里先上一段代码：
private void initAnimator() { animator = new ValueAnimator(); animator.addUpdateListener(animation -&gt; { changeX = (float) animation.getAnimatedValue(); if ((int) (changeX / lineWithdotWidth) == flag) { headPositionIndex++; flag++; } changeX = changeX % lineWithdotWidth; isScrolling = true; invalidate(); }); animator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); isScrolling = false; flag = 1; } }); } 后面动画用到的主要就是这个changeX，根据这个changX去绘制点和线，由于拉出的过程都是在一个点和线之间的距离变化的，所以这个changeX就是在这个范围内变化的，大致的思路就是这样，当然里面还有好多细节需要去处理，代码主要分为三个类，其中两个是处理点位数据的，比较简单：
public class IndicatorPositionDatas { private List&lt;PositionData&gt; positionList = new ArrayList&lt;&gt;(); public IndicatorPositionDatas(List&lt;String&gt; list) { boolean isTextUp; int size = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fb2525e03df7e89ae50ca52dcd0b6ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f7e3b69a25ed71985bb4a55b9289d1/" rel="bookmark">
			C&#43;&#43;那些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接： https://light-city.club/sc/https://chenxiaowei.gitbook.io/cpp_concurrency_in_action/ static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。
由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量由对象共享。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。
类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化
静态对象的范围是贯穿程序的生命周期
一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。
在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。
当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n)。
this在成员函数的开始执行前构造，在成员的执行结束后清除。
this类型为const A* const。A为类。
内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。
虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
sizeof： 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小
sizeof：虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！
sizeof： 静态变量不影响类的大小
sizeof：对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。
sizeof： 派生类虚继承多个虚函数，会继承所有虚函数的vptr。
抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。
如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。
抽象类至少包含一个纯虚函数
不能创建抽象类的对象
抽象类的指针和引用 指向 由抽象类派生出来的类的对象
派生类没有实现纯虚函数，那么派生类也会变为抽象类，不能创建抽象类的对象
虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。
默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型。
静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰
为什么构造函数不可以为虚函数？
解：尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。
虚函数可以被私有化，但有一些细节需要注意。
1 基类指针指向继承类对象，则调用继承类对象的函数；
2 int main()必须声明为Base类的友元，否则编译失败。 编译器报错： ptr无法访问私有函数。
3 当然，把基类声明为public， 继承类为private，该问题就不存在了。
volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78f7e3b69a25ed71985bb4a55b9289d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8df5f8a8a9b0b1b850f1488f317f53/" rel="bookmark">
			make update-api 的由来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌对于所有的类和API，分为开放和非开放两种，当我们修改framework目录中的java文件时，比如添加API、删除API、声明变量，编译器都需要我们决定API是开放还是非开放。
对于开放的类和API，可以通过“Javadoc标签”与源码同步生成“程序的开发文档”，方便开发者查看接口说明，同步生成“程序的开发文档”的方法就是先执行 make update-api (编译会修改文件 framework/base/api/current.txt)，再执行大编译 make -j4 。
对于非开放的类和API，将该接口加上非公开的标签：/**{@hide}*/
如果不做上述处理，在添加新API时会报如下错误：
******************************
You have tried to change the API from what has been previously approved.
To make these errors go away, you have two choices:
1) You can add "@hide" javadoc comments to the methods, etc. listed in the
errors above.
2) You can update current.txt by executing the following command:
make update-api
To submit the revised current.txt to the main Android repository,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8df5f8a8a9b0b1b850f1488f317f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c0cd4bc74b3c256adafd51e648a611/" rel="bookmark">
			Genymotion模拟器安装Genymotion-ARM-Translation来兼容ARM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当安装软件到Genymotion上时，如果提示：
genymotion Installation failed with message INSTALL_FAILED_CPU_ABI_INCOMPATIBLE。
那么说明当前模拟器不兼容ARM结构，你的本机处理器很可能是×86的。
解决方案：
下载Genymotion-ARM-Translation.zip文件，并拖拽进模拟器，完成后重启模拟器。
此时再次安装之前安装报错的安装包，就ok了。
下载链接（参考这位老哥的简书）：
https://www.jianshu.com/p/97b8250f359e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85642dea87a9545cae50514ed122e046/" rel="bookmark">
			PCL固定视角显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用PCL是经常需要自行调节到某一个视角去看点云的表现，如果是做算法，有时还需要在同一角度去对比不同算法得到的结果，因此获得点云在某一视角下的参数，然后设置其下次启动时位于此视角是非常常见的需求。
获得PCL视角参数代码如下：
pcl::visualization::Camera camera; viewer-&gt;getCameraParameters(camera); printf("%lf,%lf,%lf,", camera.pos[0], camera.pos[1], camera.pos[2]); printf("%lf,%lf,%lf\n", camera.view[0], camera.view[1], camera.view[2]); 可以把代码放在键盘响应函数内，然后通过按键来打印当前视角。获得当前视角后，直接用如下代码进行初始化视角即可：
viewer-&gt;setCameraPosition(-29.570503, -52.226951, 51.029257, 0.540905, 0.478015, 0.692043); 上面的参数次序和上一段代码打印出的次序一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b67409d696f4e47b7e86ebe005aba01/" rel="bookmark">
			BigDecimal类型非空校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案其实很简单，如下：
//这里unlockNumber可能为空 BigDecimal unlockNumber = unlockAccountInfo.getUnlockNumber(); if (unlockNumber == null) { //错误提示，或者进行其它操作 throw new BusinessException(CommonErrorCode.UNLOCK_NULL); } 对，用 == 来进行BigDecimal非空判断就行。
关于 BigDecimal 类型数据的加减乘除，其余帖子都有介绍，所以我就不过多赘述了，之所以写这篇帖子，是因为我在做 BigDecimal 的非空校验时，想到了 BigDecimal 的特性就百度了下如何非空校验，发现网上有的帖子提供的非空校验的方法是错的，方法本身就会报空指针异常，如：
if (unlockNumber.toString() == "") if (unlockNumber.equals(null)) //这个应该是是否等于0的判断，我看有个帖子里也当作非空判断了 if (unlockNumber.compareTo(BigDecimal.ZERO) == 0) 好了，这就是我的第一篇博客啦，（PS：本人技术较菜，也不知道我的帖子有没有错误的地方，如果有的话，还请读者大老爷在评论里指出呀）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0414cdbc9f60134e83c6e4e43cde6888/" rel="bookmark">
			react中click事件的优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做react优化的时候，想到了click的延迟事件；
引入了react-fastclick模块；
想要探究一下fastclick插件背后原理，由于react-fastclick中的事件都是合成事件，可能会稍微复杂一些，所以在网上找了一个原生js可用的的fastclick.js模块。
插件的注释写得真的太友好了，几乎可以无障碍阅读，比jquery简单。
大概思路就是，先判断它是不是一个滑动（如果是一个滑动，就好比你滑动页面，不小心经过了该div，是不会触发的。）以及点击从开始到结束时间间隔是否&gt;100ms，（这个应该是一个约定俗成的东西）,判断结束之后就dispatch一个事件
接着，取消实际绑定的click事件,(我觉得是这个插件里面我觉得最精妙的部分)
```
// Prevent any user-added listeners declared on FastClick element from being fired.
if (event.stopImmediatePropagation) {
event.stopImmediatePropagation();
} else {
// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
event.propagationStopped = true;
}
// Cancel the event
event.stopPropagation();
event.preventDefault();
```
除了这些还判断是否是focus事件，textaera事件等等，
还有兼容性到了iso4...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03bbc7ab1d5a71d2c14ed5eb32432513/" rel="bookmark">
			linux查看 rsync 服务状态，如何启动rsync服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux查看 rsync 服务状态，如何启动rsync服务 [root@localhost ~]# lsof -i tcp:873 开启状态：
未开启状态：
启动rsync服务命令:
[root@localhost ~]# rsync --daemon --config=/etc/rsyncd.conf 启动时报错：failed to create pid file /var/run/rsyncd.pid: File exists
错误信息，及解决办法，请查看文章：两台linux服务器互相自动备份，及报错解决办法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30dbdfd75257b4d91f5e99a62ec6718/" rel="bookmark">
			mysql中几类基本语句的完整使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中几类基本语句的完整使用 最近在进行数据库的一些学习，所以来mark一下几个基本语句的用法。
长期更新。
1.select
详见：mysql学习之完整的select语句
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74dcb26a5bdac12153e76ac1eb7d7b0/" rel="bookmark">
			STM32F103的Systick无法进入SysTick_Handler中断的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做了一个小实验，使用STM32的嘀嗒定时器做一个LED闪烁（一秒亮，一秒灭），可是调试了好一阵子，没能达到目的。其实很简单，只不过我忽视了中断文件的存在；其次我的低级错误导致了调试时间过长，LED闪烁的方法写错了。
1、不加Systick中断，先保证LED灯闪烁可用。
2、保证配置Systick的代码是正确的。
3、一定要#include "stm32f10x_it.h"头文件，工程中也要引入该文件。
下面是测试的主函数代码
#ifndef __STM32F10X_H #define __STM32F10X_H #include "stm32f10x.h" #endif #ifndef __Z_HARDWARE_LED_H #define __Z_HARDWARE_LED_H #include "z_hardware_led.h" #endif #ifndef __Z_UTIL_TIME_H #define __Z_UTIL_TIME_H #include "z_util_time.h" #endif int main(void) { init_led(); systick_configuration(); for(;;) {	if(systick_timestamp_ms %1000 == 0) { func_led1_toggle(); } } } 其次是LED灯的代码
#ifndef __Z_HARDWARE_LED_H #define __Z_HARDWARE_LED_H #include "z_hardware_led.h" #endif void init_led() { GPIO_InitTypeDef GPIO_InitStructure_A; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE); GPIO_InitStructure_A.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9; GPIO_InitStructure_A.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure_A.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure_A); } void func_led1_on() { GPIO_SetBits(GPIOA, GPIO_Pin_8); } void func_led1_off() { GPIO_ResetBits(GPIOA, GPIO_Pin_8); } void func_led1_toggle() { if(GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_8) == Bit_SET) { GPIO_ResetBits(GPIOA, GPIO_Pin_8); } else { GPIO_SetBits(GPIOA, GPIO_Pin_8); } } void func_led2_on() { GPIO_SetBits(GPIOA, GPIO_Pin_9); } void func_led2_off() { GPIO_ResetBits(GPIOA, GPIO_Pin_9); }	LED的头文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74dcb26a5bdac12153e76ac1eb7d7b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7acb06818ffc158a52ec0cb8113c6a6c/" rel="bookmark">
			3. Flink集群配置文件以及日志系统概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 常用Scope区别2. [Flink集群搭建](https://www.jianshu.com/p/c47e8f438291)2.1. 独立集群2.2. yarn集群2.3. [Flink 1.10.0 分布式高可用集群搭建](https://blog.csdn.net/RivenDong/article/details/104416464)2.4. 配置文件 3. [SLF4J和Logback和Log4j和Logging的区别与联系](https://www.cnblogs.com/suger43894/p/9543685.html)3.1. ==一个著名的日志系统是怎么设计出来的==3.2. 在standalone集群模式下运行案例遇到的一个问题 4. [Flink DataStream API 编程指南](https://blog.csdn.net/lixgjob/article/details/86594601)4.1. Flink程序剖析4.2. 第一个Flink程序（WordCount） 5. [Flink任务提交流程（Standalone和Yarn）](https://blog.csdn.net/u013337425/article/details/102696305)6. 寄语：天行健，君子以自强不息 1. 常用Scope区别 compile
默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会打到包里去。 test
该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit runtime
依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。此类的驱动都是为runtime的类库。 provided
该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。 2. Flink集群搭建 要求： Java 1.8.x或更高版本ssh免密登录相同的目录结构 2.1. 独立集群 JAVA_HOME 配置
conf/flink-conf.yaml 通过 env.java.home键设置此变量env.java.home: /usr/lib/jdk1.8.0_162 Flink配置
选择一个master结点， 配置conf/flink-conf.yaml
jobmanager.rpc.address: 192.168.1.27 conf / slaves 配置从结点
其他重要配置
官网配置参数
分发安装包
scp -r flink hadoop@192.168.1.28:$PWD scp -r flink hadoop@192.168.1.29:$PWD scp -r flink hadoop@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7acb06818ffc158a52ec0cb8113c6a6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b40dd06d81492775d6083aa0f737eea/" rel="bookmark">
			javascript 递归调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归调用简介： 递归调用是一种特殊的嵌套调用，是某个函数调用自己或者是调用其他函数后再次调用自己的，只要函数之间互相调用能产生循环的则一定是递归调用，递归调用一种解决方案，一种是逻辑思想，将一个大工作分为逐渐减小的小工作。
通俗的说，就是：自己调用自己，从后面往前推。
递归调用包含： 终止条件 =&gt; 包裹在if之中的 return；运算条件 =&gt; 算法; =&gt; 极简算法;；返回结果 =&gt; return ; 递归调用的典型例题： 累加 : 1 + 2 + 3 + 4 + 5 + 6 …
var count = 0; function sum( num ){ // 这个运算的起始值， 归到起始点; count ++; // 查看递归函数执行的次数; // 终止条件 if( num === 1){ return 1; } // 运算条件 return sum( num - 1 ) + num; } var res = sum(100); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b40dd06d81492775d6083aa0f737eea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c033c2740c0ef0c8b490f1446d30335/" rel="bookmark">
			Vuex的基本介绍及Vuex的五个核心属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex是什么？ vuex官网
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，统一管理和维护vue的可变状态。
什么情况下应该使用vuex？
多组件共享状态 多个组件使用同一个数据任何一个组件发生改变 其他的组件也要跟着发生相应的变化 vuex的五个核心属性
五个核心概念：State、Getter、Action、Mutation、Module
一、State
state是vuex的全局状态数据
由于vuex状态存储是响应式的，所以vue组件从store中获取状态最简单的方法就是写在计算属性中
通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到
// 创建一个 Counter 组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return this.$store.state.count } } } mapState辅助函数
当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。
// 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex' export default { computed: mapState({ // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c033c2740c0ef0c8b490f1446d30335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6027281bb290f7908eb2da73ac78d4/" rel="bookmark">
			Error in render: &#34;RangeError: Maximum call stack size exceeded&#34; 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般遇到这样的问题，先不要慌，慢慢的分析。
问题一：
你的路由写的有问题。例如：即检查你的路由router.js中的是否含有参数，但是你的路由中并没有写。
问题二：
是二级路由的path不可以写“/”，所以注意检查。
问题三：
就是在传参数的时候，类型不一致的问题，虽然这个问题，只有报错，依旧可以运行，但是对于强迫症的我来说，不可原谅。
所以将进行强制类型转化。将字符串转换为整型即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580c3a3f1ca77d5e8025239e3f64c0da/" rel="bookmark">
			opening visual studio--（新手使用Unity时打开C# 弹出opening visual studio一直停在这个界面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是新手，打开C# 弹出opening visual studio一直停在这个界面，起初我以为是加载的慢，等了将近一个小时，发现还是这样，才发现有些不对劲。
解决方法： 先打开visual studio，再双击打开c#，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8691bdb9bd170fcf88003264ad1fbd37/" rel="bookmark">
			松弛变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先引用百度里的介绍：
若所研究的线性规划模型的约束条件全是小于类型，那么可以通过标准化过程引入M个非负的松弛变量。松弛变量的引入常常是为了便于在更大的可行域内求解。若为0，则收敛到原有状态，若大于零，则约束松弛。
对线性规划问题的研究是基于标准型进行的。因此对于给定的非标准型线性规划问题的数学模型，则需要将其化为标准型。一般地，对于不同形式的线性规划模型，可以采用一些方法将其化为标准型。其中，当约束条件为“≤”（“≥”）类型的线性规划问题，可在不等式左边加上（或者减去）一个非负的新变量，即可化为等式。这个新增的非负变量称为松弛变量（剩余变量）。在目标函数中一般认为新增的松弛变量的系数为零。
其实约束条件中的不等式也是特殊的等式，引入松弛变量后，可使用的工具更多，求解也会更容易。下面还会介绍人工智能中松弛变量的应用。
常用的求解方法就是，拉格朗日乘数法：
带有不等式约束的问题的基本形式如下：
具体的例子：
首先引入拉格朗日函数：
对函数中四个变量进行求导，并令其导数为0：
求解出解，之后带入函数中求得极值。
人工智能中松弛变量
人工智能中的线性分类约束，通常都属于“硬间隔”分类法，即要求每个节点都必须满足响应的约束，这样对噪声是非常敏感的，当大量样本中出现一些不符合规律的点时，会对结果产生严重的影响。所以引入松弛变量，给分类的阈值加一个非负的变量。这样对于原本小于阈值1的点（离群点），就放弃对它的精确分类，这作为一种损失，好处就是不用移动分类的间隔线。如下，但对于离群点添加了松弛变量后，必然造成损失，那么对于优化的问题就要体现出损失，那么就要衡量损失，通常或。把损失放入目标函数中还需添加一个惩罚因子C。对比如下：
对于添加了松弛变量后的优化问题，只有离群点才有松弛变量，即未离群的点松弛变量为0。对于离群越远的点，松弛变量越大。C代表了一个权重，即离群的点造成的损失比重，而且C是在解优化问题之前必须确定的值，是一个定值，优化其实也是调C参数的过程（不断迭代尝试），每个C值对应一个分类器。C对于处理数据集偏斜很多作用，当正负两类样本节点数量差距过大时，可以适当增大样本节点少的类别的C值。每个分类器都有分类线，每次调整的时候线都有可能移动；此时有些点不离群，调整之后可能离群了，反之亦然，调整之后都要计算目标函数的值，优化的过程就是这样的迭代过程。在原始的低维空间中，样本相当的不可分，无论你怎么找分类平面，总会有大量的离群点，此时用核函数向高维空间映射一下，虽然结果仍然是不可分的，但比原始空间里的要更加接近线性可分的状态（就是达到了近似线性可分的状态），此时再用松弛变量处理那些少数“冥顽不化”的离群点。对比如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d95d1e01aabc840fc5a1dc7fa0b506/" rel="bookmark">
			event Delegate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyDelegate.h
#pragma once #include &lt;typeinfo.h&gt; #include &lt;list&gt; #include &lt;vector&gt; namespace Delegate { // IDelegate 提供接口的基类 template&lt;typename ReturnType, typename ...ParamType&gt; class IDelegate { public: IDelegate(){} virtual ~IDelegate(){} virtual bool isType(const std::type_info&amp; _type) = 0; virtual ReturnType invoke(ParamType ... params) = 0; virtual bool compare(IDelegate&lt;ReturnType, ParamType...&gt; *_delegate) const = 0; }; //StaticDelegate 普通函数的委托 template&lt;typename ReturnType, typename ...ParamType&gt; class CStaticDelegate : public IDelegate&lt;ReturnType, ParamType...&gt; { public: typedef ReturnType(*Func)(ParamType...); CStaticDelegate(Func _func) : mFunc(_func) { } virtual bool isType(const std::type_info&amp; _type) { return typeid(CStaticDelegate&lt;ReturnType, ParamType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d95d1e01aabc840fc5a1dc7fa0b506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/745866f07acc86ebe967c68bc81030df/" rel="bookmark">
			关于mysql更新数据的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mysql中执行更新语句，如果更新内容和未更新之前的内容一致的话，是不会有任何效果的，不会报错只会显示受影响的行数为0
所有有必要在更新之前对两个对象进行判断看更新前的数据与要更新的数据是否一致！如果一直则会没有效果
这是我自己踩到的一个坑，希望对大家有所帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ef3b0387c89433d13a8cf8744000da/" rel="bookmark">
			python爬虫实例之小说爬取器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家分享一个爬取盗版小说的实例。
如今的网络小说可谓是百家齐放各领风骚，玄幻科幻穿越修仙都市… 各种套路看得我是心潮澎湃，笔者曾经也蛮喜欢看小说的，以前经常是拿着一台诺基亚看到深夜，第二天带着黑眼圈去上学。
以前看小说都是txt格式的文件，每次都需要拿着在电脑上搜索‘***txt小说免费下载’，往事不堪回首
学以致用，为了以后下载小说能够超微显得高端一点，今天就给大家分享一个爬取盗版小说的爬虫实例。
当然还是希望大家支持正版哈
这次我选择的网站是笔趣阁，一个可以免费在线看小说的网站，而且貌似可以免费直接下载（手动狗头）
在本实例中我们选择的是孑与2大大的经典之作《唐砖》
点开唐砖我们可以看到是这个样子的
（图片暂无）
查看原码后发现它的目录里面所有章节都存放在一个名为list的div里面，并且所有链接都可以直接访问
我们先用代码获取它的所有目录信息并存放在两个列表chaptername 和chapteraddress 中
def getchapter(html): soup = BeautifulSoup(html,'lxml') try: alist = soup.find('div',id='list').find_all('a') for list in alist: chaptername.append(list.string) href = 'http://www.paoshu8.com'+list['href'] chapteraddress.append(href) return True except: print('未找到章节') return False 这样我们就得到了所有的章节信息，接下来只要遍历链接地址就可以得到每一节的详细内容
在每一节详细内容中我们发现，小说的文字都存放在了一个名为content的div里面，我们只需利用BeaufulSoup里面的find函数就可以找到这个div，并且我们可以看到，他的文字都是存放在了p标签里面，所以接下来我们再利用find_all函数找到div里面的所有p标签便可。
在这次爬虫中，我遇到的一个问题就是在小说中遇见了两个特殊符号，比如说’\u30fb’，’\u2660’，对于这样的错误，我直接用replace替代了这些特殊符号，最终不算很完整的爬完了整部小说。
下面上代码：
import requests from bs4 import BeautifulSoup import time start = time.clock() #获取页面html源码 def getpage(url): headers = { 'user-agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7ef3b0387c89433d13a8cf8744000da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff598b9c15629e26fd4566a33b84dc2a/" rel="bookmark">
			PTA｜浙大版《C语言程序设计（第3版）》题目集：习题6-1 分类统计字符个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做题地址：https://pintia.cn/problem-sets?tab=0 C语言在线开发环境：https://clin.icourse163.org/ 本题要求实现一个函数，统计给定字符串中英文字母、空格或回车、数字字符和其他字符的个数。
函数接口定义： void StringCount( char s[] ); 其中char s[]是用户传入的字符串。函数StringCount须在一行内按照
letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数 的格式输出。
裁判测试程序样例： #include &lt;stdio.h&gt; #define MAXS 15 void StringCount( char s[] ); void ReadString( char s[] ); /* 由裁判实现，略去不表 */ int main() { char s[MAXS]; ReadString(s); StringCount(s); return 0; } /* Your function will be put here */ 输入样例： aZ &amp; 09 Az 输出样例： letter = 4, blank = 3, digit = 2, other = 1 我的答案： void StringCount(char s[]) { int letter = 0; int blank = 0; int digit = 0; int other = 0; int length = strlen(s); for(int i = 0; i &lt; length; i++) { if(('A' &lt;= s[i] &amp;&amp; s[i] &lt;= 'Z') || ('a' &lt;= s[i] &amp;&amp; s[i] &lt;= 'z')) { letter++; } else if((s[i] == ' ') || (s[i] == '\n')) { blank++; } else if('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') { digit++; } else { other++; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff598b9c15629e26fd4566a33b84dc2a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/220/">«</a>
	<span class="pagination__item pagination__item--current">221/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/222/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>