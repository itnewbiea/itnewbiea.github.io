<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9a8f539f8ba1de7822f468c0f34b65/" rel="bookmark">
			一组惊艳的NodeJs包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A curated list of delightful Node.js packages and resources.
Inspired by the awesome list thing.
Packages Mad scienceCommand-line appsFunctional programmingHTTPDebugging / ProfilingLoggingWeb frameworksCommand-line utilitiesPackage managersBuild toolsHardwareTemplatingDocumentationFilesystemControl flowStreamsReal-timeDateImageTextMathData validationParsingHumanizeCompressionNetworkStatic site generatorsContent management systemsForumBloggingDatabaseTestingBenchmarkingMinifiersAuthenticationNode.js managementEmailPolyfillsNatural language processingProcess managementASTWeirdMiscellaneous Mad science webtorrent - Streaming torrent client for Node.js and the browser.peerflix - Streaming torrent client.dat - Real-time replication and versioning for data sets.ipfs - Distributed file system that seeks to connect all computing devices with the same system of files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9a8f539f8ba1de7822f468c0f34b65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5592beb10b93d233dee18396791491ea/" rel="bookmark">
			单例模式（Singleton）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用条件： 当系统中只需要某个类的唯一对象时，可以使用该模式。
为什么会用到该模式？：因为有时候某些对象的创建需要耗费大量的资源、使用单一（唯一）的对象实例来维护某些共享数据等，在这些场景下即可采用单例模式进行设计，可以适当地渐少内存开销，因为此时该唯一对象不会（被限制了）频繁地创建。
第一种:饱汉模式
public class SingleTon{
private SingleTon（）{ }；
private static SingleTon instance = new SingleTon();
public static SingleTon getInstance()
{ return instance;
}
}
第二种：饥汉模式
public class SingleTon{
private SingleTon(){};
private static SingleTon instance = null;//new SingleTonight();
public static synchronized SingleTon getInstance()
{
if(instance==null) instance = new SingleTon();
return instance;
}
}
这个方法比上面方法有所改进，不用每次都进行生成对象，只是第一次使用生成实例，提高效率。
注意到第二种形式中的synchronized，这个synchronized很重要，如果没有synchronized线程同时访问时则可能出现混乱，所以我们可以在该方法前加上synchronized关键字来保证其被同步访问。
综合来说呢，
就是不给外界调用自己构造方法的机会，
而只能通过类似于getInstance()之类的方法得到此类的实例，
而此实例早已生成，
只能调用，
不能新建，
从而保证了在java应用程序中，一个类只有一个实例存在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cede629c5a92f850e7cac1dbb55a195b/" rel="bookmark">
			filter 配置文件如何过滤多个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 web.xml 中，配置 filter 来过滤多个文件的方式可以归结为以下三种：
1. 过滤某个文件夹下的所有文件；
&lt;filter&gt; &lt;filter-name&gt;log&lt;/filter-name&gt; &lt;filter-class&gt;filter.LogFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;log&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤某个文件夹下的个别几个文件，可以将要过滤的几个文件放在一个新建的文件夹下，就如同方式1 一样； 3. 如果要单独过滤的几个文件个数不多，则可以分开写过滤映射配置：
&lt;filter&gt; &lt;filter-name&gt;userLogin&lt;/filter-name&gt; &lt;filter-class&gt;filter.UserLoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 分别写n个filter-mapping 来指定要拦截的url --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;userLogin&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/myinfor.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;userLogin&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/setsecurity.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;userLogin&lt;/filter-name&gt; &lt;url-pattern&gt;/pages/myorder.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ad9b4b01234b8998817382f95fa488/" rel="bookmark">
			HDU 5475 An easy problem(用大数模板，你就上当了)——2015 ACM/ICPC Asia Regional Shanghai Online
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		An easy problem Time Limit: 8000/5000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others) Problem Description One day, a useless calculator was being built by Kuros. Let's assume that number X is showed on the screen of calculator. At first, X = 1. This calculator only supports two types of operation. 1. multiply X with a number. 2. divide X with a number which was multiplied before. After each operation, please output the number X modulo M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2ad9b4b01234b8998817382f95fa488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9bf27c1f42298855b30c841e78d306/" rel="bookmark">
			常见的socket出错总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见错误 ECONNREFUSED(111): 没有这个端口
EAGAIN(11): buff已满
EPIPE(32): 客户端断掉了
ECONNRESET（104）: 客户端先可以正常连接服务端，并可以进行数据收发，
但当客户端突然掉电，即没有正常的关掉网络资源，
重启后，客户端还是可以连接服务端，但是发送（send函数）数据给服务端时，
send函数返回－1，捕捉errno为104，即ECONNRESET。
ENOBUFS(105): 例如：使用udp发送&gt;=128K的消息会报ENOBUFS的错误
EPIPE和ECONNRESET区别 EPIPE和ECONNRESET是网络编程实践中很常见的错误。二者都是出现send调用出错的时候，可它们有什么区别呢？ 简而言之，二者的区别是本端的socket是否收到过对方socket发出的FIN。
/* When we get a reset we do this. */ static void tcp_reset(struct sock *sk) { /* We want the right error as BSD sees it (and indeed as we do). */ switch (sk-&gt;sk_state) { case TCP_SYN_SENT: sk-&gt;sk_err = ECONNREFUSED; break; case TCP_CLOSE_WAIT: sk-&gt;sk_err = EPIPE; break; case TCP_CLOSE: return; default: sk-&gt;sk_err = ECONNRESET; } /* This barrier is coupled with smp_rmb() in tcp_poll() */ smp_wmb(); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e9bf27c1f42298855b30c841e78d306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe269b553ec1e5b34ebd774aac9a0362/" rel="bookmark">
			SlickGrid 基本方法篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自http://blog.csdn.net/besley/article/details/8894348 SlickGrid 基本方法篇 分类： Javascript MVC 2013-05-07 11:26 3834人阅读 评论(2) 收藏 举报 SlickGrid javascript 前言：SlickGrid 是一个Javascript编写的数据控件，其采用数据虚拟显示的特性备受后来的Grid推崇，如ExtJS DataGrid，其架构设计优秀，UI交互功能非常丰富，插件化的可扩展功能开发非常值得Web开发人员学习，本文列出基本方法的使用，供开发人员参考；并在后文继续总结列出已经开发出的插件，以供开发人员参考。
0. SlickGrid 基本样式示例
功能包括：
1）首列复选框；
2）编辑器：文本编辑框，下拉框，复选框，日期控件，长文本编辑器，数字格式编辑器，YesNo编辑器等；
3）列排序，列字段值过滤，列冻结；
4）分页：客户端分页和服务端分页；
5）多字段组合查询；
6）各种列样式指定，行样式设定；
其它扩展功能依然可以通过插件完成。
1. Grid初始化及数据绑定 new、setItems、setSelectionModel
[javascript] view plain copy var gridView; var grid; var data = []; var columns = [ { id: "id", name: "id", field: "id", behavior: "select" }, { id: "code", name: "入库单编号", field: "code"}, { id: "ctemp1", name: "明细款号", field: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe269b553ec1e5b34ebd774aac9a0362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e907abc06bdf7bc6bd185b3bd030e6ac/" rel="bookmark">
			slickgrid表格控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://www.oschina.net/p/slickgrid/similar_projects?sort=time&amp;lang=22
可以在上述网址进行下载
支持下面的功能
可以隐藏任意列，可以排序(most comprehensive) Using a filtered data view to drive the grid-----example4-model.html 可以调整行、列顺序/example9-row-reordering.html--Row selection &amp; reordering 可以在表格中插入图表曲线Using background post-rendering to add graphs 排序功能Multi-column sorting 可以在第一列插入checkbox:Plugin: Checkbox row selectors with CheckboxSelectColumn plugin 支持输入功能：Making it editable 可以进行输入，同时可以用较复杂的输入方式，如日历、进度条、checkbox等。 支持撤销功能：Implementing Undo 排序：Sorting by an index, getItem method 选择框，复制粘贴某个元素：Spreadsheet: cell range selection, copy’n’paste and Excel-style formula editor 合并某些组：Interactive grouping and aggregates. 如何合并单元格（其它功能都有了）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d84adf700cd3bcc848c7be18ccea36/" rel="bookmark">
			3110: [Zjoi2013]K大数查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 有N个位置，M个操作。操作有两种，每次操作如果是1 a b c的形式表示在第a个位置到第b个位置，每个位置加入一个数c
如果是2 a b c形式，表示询问从第a个位置到第b个位置，第C大的数是多少。
Input 第一行N，M
接下来M行，每行形如1 a b c或2 a b c
Output 输出每个询问的结果
Sample Input 2 5 1 1 2 1 1 1 2 2 2 1 1 2 2 1 1 1 2 1 2 3 Sample Output 1 2 1
思路：线段树套线段树，外层线段树表示权值，内层线段树维护出现的位置及次数
PS：空间动态开。这里懒惰标记可以不PushDown，感觉PushDown会访问一些本来可以不访问也就是不用开辟的节点，省空间。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; #define maxn 50080 #define maxm 30058000 int root[maxn&lt;&lt;2]; int sum[maxm],lazy[maxm],lson[maxm],rson[maxm]; int n,m,cnt; void scanf_f(int &amp; x) { x = 0; char c = getchar(); while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d84adf700cd3bcc848c7be18ccea36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cc3e60233701197271076d0cff20dd/" rel="bookmark">
			char data[0] 用法及意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用法：
struct MyData { int nLen; char data[0]; };
在结构中，data是一个数组名；但该数组没有元素；该数组的真实地址紧随结构体MyData之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）。常用于构成动态缓冲区buffer。
采取这样：struct MyData *p = (struct MyData *)malloc(sizeof(struct MyData )+strlen(str))这样就可以通过p-&gt;data 来操作这个str。
int main()
{
int nLen = 10;
char str[10] = "123456789";
cout &lt;&lt; "Size of MyData: " &lt;&lt; sizeof(MyData) &lt;&lt; endl;
MyData *myData = (MyData*)malloc(sizeof(MyData) + 10);
memcpy(myData-&gt;data, str, 10);
cout &lt;&lt; "myData's Data is: " &lt;&lt; myData-&gt;data &lt;&lt; endl;
free(myData);
return 0;
}
输出：
Size of MyData: 4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41cc3e60233701197271076d0cff20dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab804c50259e79d009d39b24e96048a/" rel="bookmark">
			GTK&#43;浅谈之八表格列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
Gtk+2.0表格控件十分有用，（GtkCList）可以向表格中添加图像、文字，对数据进行排序，设定表格控件的背景，设置各单元格的属性等。但不能编辑单元格（需要使用树视图控件GtkTreeView）。
二、详解
1、代码 #include &lt;gtk/gtk.h&gt; static gchar *titles[5] = {"编号", "姓名", "出生年月", "电子邮件"}; const gchar *new_row[5]; static GtkWidget *clist; static GtkWidget *add_win; static GtkWidget *entry_id; static GtkWidget *entry_name; static GtkWidget *entry_sex; static GtkWidget *entry_birthday; static GtkWidget *entry_email; gint current_row = 0; gint row_count = 0; static GtkWidget *window; void on_ok_clicked(GtkWidget *button, gpointer data) { new_row[0] = gtk_entry_get_text(GTK_ENTRY(entry_id)); new_row[1] = gtk_entry_get_text(GTK_ENTRY(entry_name)); new_row[2] = gtk_entry_get_text(GTK_ENTRY(entry_sex)); new_row[3] = gtk_entry_get_text(GTK_ENTRY(entry_birthday)); new_row[4] = gtk_entry_get_text(GTK_ENTRY(entry_email)); if (g_strcmp0(new_row[0], "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab804c50259e79d009d39b24e96048a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c734f832e8644717453f5f6d7db9b9bc/" rel="bookmark">
			2002: [Hnoi2010]Bounce 弹飞绵羊（分块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description 某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。
Input 第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1,接下来一行有n个正整数，依次为那n个装置的初始弹力系数。第三行有一个正整数m，接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。对于20%的数据n,m&lt;=10000，对于100%的数据n&lt;=200000,m&lt;=100000
Output 对于每个i=1的情况，你都要输出一个需要的步数，占一行。
Sample Input 4 1 2 1 1 3 1 1 2 1 1 1 1 Sample Output 2 3
将N个装置从左到右分为sqrt(N)段，维护两个数组，f[i][j]表示第I段的第J个位置开始在该段弹多少次，to[i][j]表示第I段的第J个位置弹飞到哪个位置。
每次询问，跑sqrt(N)个段。
每次更新，比如修改i点，只需要更新与i同段且在i左边的f[][]和to[][]
复杂度为N*sqrt(N)
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; #define maxn 200080 #define maxm 508 int f[maxm][maxm];//第I快，第J个位置，跳多少次 int to[maxm][maxm];//第I快，第J个位置，跳到哪个位置 int a[maxn]; int main() { //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); int n; while(scanf("%d",&amp;n)!=EOF) { for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); int len = sqrt(double(n))+1; int num = n/len; if(n%len) num++; for(int i = num;i &gt;= 1;i--) { for(int j = len;j &gt;= 1;j--) { int pos = (i-1)*len+j; if(pos&gt;n) { f[i][j] = 0; to[i][j] = pos; continue; } if(j+a[pos]&lt;=len) { f[i][j] = f[i][j+a[pos]]+1; to[i][j] = to[i][j+a[pos]]; } else { f[i][j] = 1; to[i][j] = pos+a[pos]; } } } int m; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c734f832e8644717453f5f6d7db9b9bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90618e96f2f2db684240be52864272d3/" rel="bookmark">
			Windows-svchost.exe大量占用内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		svchost.exe 是用来启动系统服务的，所以某个 svchost.exe 占用内存过大，可能就是它启动的那个服务占用内存过大，所以只要停止并禁用那个服务就行了。
一般来说占用内存最大的服务是 Superfetch 。
解决办法为：
开始菜单 –》控制面板 –》系统和安全 –》管理工具 –》服务
在列表中找到 Superfetch ，右键停止，再右键属性，常规选项卡中选择启动类型为“手动”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63fe6401e5be428f2d8c7496b185f6cc/" rel="bookmark">
			白话空间统计十七：聚类和异常值分析（Anselin Local Moran&#39;s I）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们聊的各种指数，无论是莫兰指数还是P值Z得分，都是整体数据的结论，也就是所谓“全局莫兰指数（Globe Moran's I）”，也就说，不管我给你多少数据，最后你就吐出一个来给我！这算神马！当然，从名字上来看，全局数据嘛，有一个给你就不错了。实际上作为我们玩GIS的人，最喜欢的就是出一张花花绿绿的地图，比如这样的：
或者是这样的：
所以我们更希望的是将我们输入的数据，标示出明显的数值来，比如我输入1000个要素，那么你别就给我1个数据啊，怎么也得吐出1000个数据来吧，甭管什么莫兰指数，P值Z得分啥的，不能给我省了。所以这里就要用到今天我们说的Anselin LocalMoran's I方法了，而它与GlobeMoran's I的区别，如下：
所以，这种算法比较符合我们做GIS的人的思维，那么这种可视为地理信息强迫症的特效药的Anselin Local Moran's I算法，是哪位大爷提出来的呢？下面进入我们的算法科普时间：
上面这个脑门像土豆神一样明亮的老帅哥，就是ASU(美国亚利桑那州立大学)的地理与规划学院院长Luc Anselin教授，也是Anselin Local Moran'I算法的提出者，所以也就用了他的大名来标示这种算法。
如果做地理分析的，一定听说一个叫做GeoDa的软件，这个软件就是Anselin教授领导的ASU的地理空间分析和计算中心弄出来的神器。后来他的这个中心，就一直被人称为“GeoDa Center”
他在2008年的时候，当选为了美国科学院院士，与中国一样，当选院士被认为是美国学术界最高荣誉之一。
好了，起源介绍完了，下面我们来看看这种算法有些啥神奇的地方。
首先，他还是会计算各种常规的指数，比如Moran's I以及P值Z得分啥的，但是他是针对整份数据中，每一个要素都会去记录一个相应的值，算出来就会变成这个样子：
用中国每个省的GDP进行计算，算完对每一个省都会对应有一系列数据，前面三个就是每个省的Moran's I和Z得分以及P值，这个就不解释了，大家有兴趣去看以前的文章，Anselin Local Moran's I最强大的地方，就是他能够用自己身的数据，与周边的数据进行比较，生成COType这样一个字段。
COType是：聚类/异常值类型的简写（clustering / outlier Type），这个东西是啥东东呢，我们来看下面的解释：
首先，正常情况下，聚类我们认为是这样的：
就是相同的类别会被放到一起。但是我们这个工具不但要计算聚类类型，还要计算的是异常的类型，何谓异常呢？异常自然就是下面这样的情况：
当然，还有一种情况，就是随机了，如下：
抛开随机不谈，我们谈聚类和异常的话，就会出现4种组合，如下：
而因为在地理空间上，不同的要素之间会出现相邻或者包围这种情况，所以就用了如下这种描述：周围一圈都是低值，围绕一个高值，这种情况被表示为HL，反之，周围都是一圈高值，围绕着一个低值，那么就表示为LH。
这种方式，能够明确的发现空间数据以及参与计算字段值中的一些规律，比如采用2008年的各省GDP进行计算的结果如下：
山东、江苏、浙江出现了明显的高值聚类，也就是说，他们的GDP与空间分布，不但自己的GDP处于高位，且旁边省份的GDP也是在高位。
而全国唯一个高值被低值包围的省，就是广东省，HL的意思是他自身的GDP处于高位，但是在空间分布上，它身边的省份都处于低值的情况。
从这里可以看出，采用AnselinLocal Moran's I能够在更细粒度的范围下，对空间关系进行探索，至于如何使用这个工具，我们下次再说。
待续未完。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f68a6c287aace892135fdbfa8bf46c4/" rel="bookmark">
			android开发步步为营之76:android导出anr日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看是否有日志
C:\Users\test&gt;adb shell ls /data/anr/
traces.txt
导出到电脑的d:/mytraces.txt
C:\Users\test&gt;adb pull /data/anr/traces.txt d:/mytraces.txt
导出后就可以打开d:/mytraces.txt 这个文件了，建议用editplus打开，记事本打开会乱
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49cf6e5096b14516632bfe4be8e6acdc/" rel="bookmark">
			MVC,MVP,MVVM框架剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MVC,MVP,MVVM框架剖析MVC,MVP,MVVM框架剖析MVC,MVP,MVVM框架剖析MVC,MVP,MVVM框架剖析MVC,MVP,MVVM框架剖析MVC,MVP,MVVM框架剖析 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81984602e48e90a7c21ff3445815c97/" rel="bookmark">
			保存dialog的位置和大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* @Override protected IDialogSettings getDialogBoundsSettings() { IDialogSettings dialogSettings = Activator.getDefault().getDialogSettings(); String dialogKey = EventSearchDialog.class.getCanonicalName(); IDialogSettings boundsSettings = dialogSettings.getSection(dialogKey); if (boundsSettings == null) { boundsSettings = dialogSettings.addNewSection(dialogKey); } return boundsSettings; } */ 不管使用JFace的dialog，或者SWT的dialog。覆盖getDialogBoundsSettings方法就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c05a3772d6e4713761f1cd4a65d3cad/" rel="bookmark">
			【MySQL】MetaData Lock 之三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 简介 通过前面两篇文章的介绍，相信读到这里的各位对MDL 锁已经有了比较深入的了解了,本文将结合理论知识介绍几组MDL 锁的案例。 二 常见MDL 锁的场景 1 Waiting for global read lock 我们先构造一个Waiting for global read lock场景： session1: alter table t1 add c3 bigint; //大表执行需较长时间 session2: set global read only=on; //等待 查看 mysql&gt; show processlist;
+----+------+-----------------+------+---------+------+------------------------------+------------------------------+
| Id | User | Host | db | Command | Time | State | Info |
+----+------+-----------------+------+---------+------+------------------------------+------------------------------+
| 1 | root | localhost:5202 | test | Query | 12 | altering table | alter table t1 add c3 bigint |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c05a3772d6e4713761f1cd4a65d3cad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b19fe10f93a9fcd952c8b080b6fa3f/" rel="bookmark">
			设置三个Slider控件,管理背景颜色,任意改变一个控件,背景颜色都会发生改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-(void)loadView
{
[super loadView];
_slider = [[UISlider alloc]initWithFrame:CGRectMake(50, 200, 275, 40)];
_slider.minimumValue = 0;
_slider.maximumValue = 1;
[_slider addTarget:self action:@selector(sliderAction) forControlEvents:UIControlEventValueChanged];
[self.view addSubview:_slider];
[_slider release];
_slider1 = [[UISlider alloc]initWithFrame:CGRectMake(50,_slider.frame.origin.y + _slider.frame.size.height + 30 , 275, 40)];
_slider1.minimumValue = 0;
_slider1.maximumValue = 1;
[_slider1 addTarget:self action:@selector(sliderAction) forControlEvents:UIControlEventValueChanged];
[self.view addSubview:_slider1];
[_slider1 release];
_slider2 = [[UISlider alloc]initWithFrame:CGRectMake(50, _slider1.frame.origin.y + _slider1.frame.size.height + 30, 275, 40)];
_slider2.minimumValue = 0;
_slider2.maximumValue = 1;
[_slider2 addTarget:self action:@selector(sliderAction) forControlEvents:UIControlEventValueChanged];
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b19fe10f93a9fcd952c8b080b6fa3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20739462e9773e6de00a77efee739c25/" rel="bookmark">
			用循环语句while或for循环编写一个验证登陆的小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：当用户名与密码全部正确时提示登陆成功，否则，提示登陆失败，三次验证失败退出系统。
while循环
代码如下：
import java.util.Scanner; /** * */ /** * @author Administrator * */ public class Text6 { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub Scanner sc = new Scanner(System.in); int i = 1; while (i &lt;= 3) { System.out.println("请输入用户名："); String name = sc.next(); System.out.println("请输入密码："); String pass = sc.next(); if (name.equals("admin") &amp;&amp; pass.equals("admin")) { System.out.println("您已成功登陆！"); return; } else { System.out.println("登陆失败，请重新登录!"); i++; } } if (i &gt; 3) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20739462e9773e6de00a77efee739c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fcd2f967d7f36059099f7719462614b/" rel="bookmark">
			svchost.exe大量占用CPU和内存的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天新增了一个西数的服务器。可开机上去就被一个svchost.exe进程大量占用了CPU和内存资源，经反复检查，终于发现是被一个windows update的更新服务托耗了。关闭，即可万事大吉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3af2334ac17d9ab4b162258ebb756643/" rel="bookmark">
			String[]数组初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建数组： //一维数组 String[] str = new String[5]; //创建一个长度为5的String(字符串)型的一维数组 String[] str = new String[]{"","","","",""}; String[] str = {"","","","",""}; //二维数组 String[][] str = new String[2][2]; //创建一个2行2列的二维数组 String数组初始化区别: String[] str = {"1","2","3"}与String[] str = new String[]{"1","2","3"}在内存里有什么区别？ 编译执行结果没有任何区别。更不可能像有些人想当然说的在栈上分配空间，Java的对象都是在堆上分配空间的。 这里的区别仅仅是代码书写上的：　String[] str = {"1","2","3"}; 这种形式叫数组初始化式（Array Initializer），只能用在声明同时赋值的情况下。 而 String[] str = new String[]{"1","2","3"} 是一般形式的赋值，=号的右边叫数组字面量（Array Literal），数组字面量可以用在任何需要一个数组的地方（类型兼容的情况下）。如： String[] str = {"1","2","3"}; // 正确的 String[] str = new String[]{"1","2","3"} // 也是正确的 而 String[] str; str = {"1","2","3"}; // 编译错误 因为数组初始化式只能用于声明同时赋值的情况下。 改为： String[] str; str = new String[] {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3af2334ac17d9ab4b162258ebb756643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2c6d88a8253467eed088ffcced1b45/" rel="bookmark">
			《游戏引擎架构》读书笔记（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一．游戏性系统 （1）游戏世界一般分为静态元素和动态元素，静态元素和动态元素有时候没有特别明显的分界线。但是静态元素消耗资源较少，可以用笔刷等工具绘制静态元素。
（2）游戏世界一般分为各个组块，如关卡，地图，地区等。建立在这之上的是高级游戏流程，即玩家的目标，比如任务。
（3）游戏动态元素通常以面向对象的方式进行设计，通常称为游戏对象（Game Object），实体（entity），演员（actor）或者代理人（agent）等。
a）游戏对象通常会扩展引擎本身的语言，加一些高级功能比如反射，并且会提供脚本语言比如lua的访问。
b）对象模型在有的引擎中可能会分为工具方对象模型和运行时对象模型，不过这两者一定有联系，甚至是相同的实现。
（4）数据驱动游戏引擎：当游戏的行为可以全部或者部分由美术和策划所提供的数据所控制，而不是由程序员编写的软件完全控制，该引擎就称为数据驱动。数据驱动可以减少迭代次数，不需要修改游戏本身的代码。但是数据驱动也有很大的代价，需要提供足够强大的编辑工具以及容错能力。但是不管怎么样，数据驱动也是为了使游戏开发更简单，而不要过于盲目的复杂化，记住Kiss原则。
（5）游戏世界编辑器，游戏世界编辑器包括但不限于下面的功能：
a）世界组块创建及管理：levelsystem
b）可视化的游戏世界：所见即所得的编辑最适合美术和策划的开发啦。
c）导航：在编辑器中必须要有灵活的摄像机，有绕物体旋转和自由飞翔等不同模式。
d）选取：一般是以光线投射的方式进行拾取。最好支持框选多选，然后以视图的或者树形图表示出来。
f）图层：在一些编辑器中支持自定义分组，能够独立载入一组图层，在不同的图层安排不同的内容。
g）属性编辑：选中游戏世界中的物体后，可以通过编辑器调节对象的属性。可以考虑增加公共属性修改，修改一个，相同类型对象的对应属性值全部修改。
h）特殊对象模型：比如光源，粒子发射器，区域，样条等本来在游戏世界中不可见的东东，我们可以给其增加一个实际的包围盒等，让其在世界中可见，方便移动操作等。
i）读写世界组块：当然，编辑这么多，还是要把编辑完的东西存起来，供引擎读写。有的引擎使用二进制文件，有的引擎使用XML等文本格式，有的引擎将所有信息存储在一个文件中，也有的分组块存储。
j）快速迭代：当我们修改游戏世界后，越早能看到修改的效果越好。这点感觉CE3做的很好，CE3的编辑器中按下Ctrl + G后可以立即进入游戏模式，测试效果。感觉这个真的是灰常灰常好的设定！！
k）集成的资产管理工具：游戏中所有需要使用的资源最好可以随时浏览，方便查看与编辑，更高级的就是可以直接在这个资产管理工具中直接进行相关修改。
二. 运行时游戏性基础系统 （1）运行时对象模型架构:
a）以对象为中心的架构：每个游戏对象都是单个类实例，每个对象含有一组属性及行为，被封装在对象中。
这种类型的架构最简单的就是单一庞大的类层次结构，一个基类，向下派生出N多子类。不过随着派生的层数越深，整个系统就越难理解维护和修改。（这里涉及到一个冒泡效应，即本来是下层类需要的功能，但是又增加了另一个类需要这个功能，为了适应这个功能，即把这个功能提到上层的类中，导致上层的类越来越庞大。）
进一步的话，可以不仅仅扩展类的深度，而是从派生的宽度来扩展。不过这种情况容易造成多重继承，这个就比价麻烦了。
更好的办法是使用聚合，而不是传统的继承方式。即使用Has a来代替Is a。将一些对象具有的功能提取出来，作为一个单独的类，然后游戏对象只要包含这个类的对象就具有了这种功能或者特性。
聚合再进化一下，就变成了传说中的组件模型。各种功能和性质都属于一个组件，而GameObject是由若干个这样的组件构成。每个组件可以独立的维护扩充或者重构，而不影响其他功能。最简单的就是GameObject含有所有可能有的组件的指针，在初始化的时候可以根据参数甚至是配置文件来决定这个对象需要哪些组件。
组件的终极进化的话就是只有组件没有GameObjec，或者GameObject中只包含一个GUID，这些组件中也包含GUID，不过还是有GameObject好一点，如果没有这个，组件间的通信等问题就会比较棘手。
b）以属性为中心的对象模型架构：
这种的话，主要就是存储各个对象的各个属性，这些属性都存储在同一个地方，通过对象的唯一索引来获得这个属性。与对象为中心的架构的区别在于：这种情况为数组的结构，即整个游戏的对象属性为一个结构体，而该结构体的每个子项都是一个数组，通过各个对象的索引获得该值。而对象为中心的情况则为结构的数组：每个对象的属性为一个结构体，整个游戏世界是有这个结构体的数组构成的。
（2）世界组块的数据格式：
对于游戏世界中的各种东东，我们在编辑器中编辑好之后，都需要存储起来，并且在游戏引擎中重现出来。有二进制的序列化方式，但是更好的方法是只存储游戏状态属性到文本文件中，比如XML文档。
由于C++没有反射机制，所以对于创建对象通常采用类工厂等方式，根据数据表创建不同的类对象。
在编辑器中需要和游戏中有相同的表现，有时候是将引擎的接口直接暴露给编辑器，这样的好处是编辑器和游戏世界中完全一样，而且减少了工作量，更有可能直接在编辑器中开启模拟游戏的方式（比如CE3）。有时候，如果不需要其他的功能，也可以直接使用生成器，即将引擎中的对象的一部分属性等提取出来，不必要的不添加到编辑器中。
对于各种对象的属性最好添加一个默认的属性，而且需要提供一次性修改所有对象属性的方法。
（3）游戏世界的加载和串流：
a） 简单的关卡加载：一般使用堆栈分配器，进入一关前，集中加载本关的资源，使用完后，直接全部清除，然后进入一个过场画面（loading界面），等资源加载完成后，继续游戏。
b） 阻隔室：这个是为了避免加载动画使用的一种简单的方法，不过需要配合游戏的玩法。最简单的办法是将为资源分配的内存分为两块，一块为当前场景的，然后在后台加载下一个关卡的。而如果玩家返回原来的场景就会穿帮…而阻隔室就是应对这种情况的。当玩家进入阻隔室后，原来的资源卸载，加载新的资源，让玩家在阻隔室不要闲下来就好。
c） 游戏世界的串流：这个技术赶脚吊炸天啊…
串流需要做的是一方面保证玩家要玩的资源在内存中，另一方面还需要保证资源加载不能出现内存碎片的问题。这时就需要更细的粒度，设置多个缓冲区，循环加载。
在每个组块设置一个包围盒，保证玩家不会看到穿帮镜头。
（4）对象生成和内存管理：
游戏资源载入内存后，需要管理世界对象中的对象生成。而动态分配内存可能很慢，而且游戏对象大小不同，可能会造成内存碎片。所以内存管理是很重要的。
a） 对象的离线内存分配：说离线其实是一种极端情况，这种分配的特点是一次性全部分配内存，然后不需要的对象保持为休眠状态或者不可见。使用时再激活，模拟生成的情形。但是这种方法比较死板，不能真正的动态生成对象。
b） 动态内存分配：主要要对付的问题就是内存碎片的问题。
对于相同大小的对象，可以采用池分配器。但是游戏对象各种各样，所以一种方法是采用多种池分配器，为每种对象设置一个池分配器。不过这个需要把握好，防止有的对象内存池不够，而有的对象内存池剩余。
另一种方法是采用类似操作系统的内存分配模式，设置一组内存分配器，从小到大，遇到需要分配的时候，先从小的找起，直至大的，如果还没有，直接转堆内存，因为大块内存碎片问题相对小块内存碎片还不是那么严重。
最残暴的一种方法就是内存重定位，隔一段时间，将内存整理一下。
（5）游戏存档：
a）存档点：这个的好处在于玩家到达该存档点时，游戏状态是确定的，所以存档的内容可以相对较少。
b）任何地点都可以存档：这个难度就要比上个大了，存储的状态也要多许多。
不过不管是哪种情况，都要注意尽可能的不存储无关信息。
（6）世界查询：
游戏对象需要提供某种唯一标识符，使各种对象能够区分，并且能在运行时找到对象。而找到对象的需求也不同，比如直接查询，搜寻范围内的敌人等等。
a） 以唯一标识符搜寻游戏对象：将游戏的指针或句柄存储于以游戏的唯一标识符为健值的散列表或者二叉查找树中。
b） 将游戏对象预先排序，存储在不同的链表中。比如玩家周围的怪物链表。
c） 搜寻投射路径碰撞物体：通常使用碰撞系统实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2c6d88a8253467eed088ffcced1b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a08675d970c35d3cc4b371125a0c2c/" rel="bookmark">
			一些loadrunner自学以及问题解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、LR 脚本为空的解决方法：
去掉ie设置中的第三方支持取消掉
在系统属性－高级－性能－数据执行保护中，添加loadrunner安装目录中的vugen.exe文件.
有可能是由于录制的URL地址采用的是localhost的问题，改成分配的IP地址或127.0.0.1试试。
2、插入文本检查点步骤时，使用web_reg_find，通常TextPfx和TextSfx中会包含双引号，需要进行转义（用斜杠），例如：
web_reg_find("Search=Body",
"SaveCount=Welcome",
"TextPfx=欢迎",
"TextSfx=",
LAST)
3、LoadRunner录制脚本时为什么不弹出IE浏览器?
当一台主机上安装多个浏览器时，LoadRunner录制脚本经常遇到不能打开浏览器的情况，可以用下面的方法来解决。
启动浏览器，打开Internet选项对话框，切换到高级标签，去掉“启用第三方浏览器扩展(需要重启动)”的勾选，然后再次运行VuGen即可解决问题
提示：通常安装Firefox等浏览器后，都会勾选上面得选项，导致不能正常录制。因此建议运行LoadRunner得主机上保持一个干净的测试环境。
4、HTML-based script与URL-based script的脚本有什么区别?
使用“HTML-based script”的模式录制脚本，VuGen为用户的每个HTML操作生成单独的步骤，这种脚本看上去比较直观;
使用“URL-based script”模式录制脚本时，VuGen可以捕获所有作为用户操作结果而发送到服务器的HTTP请求，然后为用户的每个请求分别生成对应方法。
通常，基于浏览器的Web应用会使用“HTML-based script”模式来录制脚本;而没有基于浏览器的Web应用、Web应用中包含了与服务器进行交互的Java Applet、基于浏览器的应用中包含了向服务器进行通信的JavaScript/VBScript代码、基于浏览器的应用中使用了HTTPS安全协议，这时使用“URL-based script”模式进行录制。
5、运行时的Pacing设置主要影响什么?
Pacing主要用来设置重复迭代脚本的间隔时间。共有三种方法：
A:上次迭代结束后立刻开始、 B:上次迭代结束后等待固定时间、C:按固定或随机的时间间隔开始执行新的迭代。
根据实际需要设置迭代即可。通常，没有时间间隔会产生更大的压力。
6、运行时设置Log标签中，如果没有勾选“Enable logging”，则手工消息可以发送吗?
Enable logging选项仅影响自动日志记录和通过lr_log_message发送的消息。即使没有勾选，虚拟用户脚本中如果使用lr_message、lr_output_message、lr_error_message,仍然会记录其发出的消息。
7、VuGen支持Netscape的客户证书吗?
不支持。目前的VuGen 8.0版本中仅支持Internet Explorer的客户端证书。录制脚本时可以先从Netscape中导出所需的证书，然后将其导入到Internet Explorer中，并确保以相同的顺序导出和导入这些证书。而且，在每台将要录制或运行需要证书的Web Vuser脚本的计算机上都要重复执行前面的过程。
8、VuGen会修改录制浏览器中的代理服务器设置吗?
会修改。在开始录制基于浏览器的Web Vuser脚本时，VuGen首先会启动指定的浏览器。然后，VuGen会指示浏览器访问VuGen代理服务器。为此，VuGen会修改录制浏览器上的代理服务器设置。默认情况下，VuGen会立即将代理服务器设置更改为Localhost:7777。录制之后，VuGen会将原始代理服务器设置还原到该录制浏览器中。因此，在VuGen进行录制的过程中，不可以更改代理服务器设置，否则将无法正常进行。
9、在LoadRunner脚本如何输出当前系统时间?
LoadRunner提供了char *ctime(const time_t *time)函数，调用参数为一个Long型的整数指针，用于存放返回时间的数值表示。
调用语句与返回值如下示例：
typedef long time_t;
Action()
{
time_t t;
lr_message(“Time in seconds since 1/1/70: %ld\n”,time(&amp;t));
lr_message(“System time and date: %s”,ctime(&amp;t));
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a08675d970c35d3cc4b371125a0c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493e3f707115f5dd15ef2a7160aaccee/" rel="bookmark">
			一个关于中国省市区的字典,数组嵌套使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步: 去云盘的资料目录下下载一个名字为area.txt的文件(内容为中国的省市区),将这个文件导入到自己的工程里(导入时会有一个界面,勾选copy items if needed)
// 第二步: 将以下代码拷贝到主函数里:
// NSString *path = @“这里是拖入工程的area.txt文件的路径,从左边文件夹区域自己拖过来”;
// NSString *string = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
// NSLog(@"%@", string);
// 第三步:如果前两步没问题,你会看到文件里面的内容在控制台打印了出来,所有内容都在string这个字符串里.
// 问题: 1.获取所有省份的名字,放到一个数组里,最后打印数组(提示:”\n”可以用来分割字符串)
//创建最外层省数组
// NSMutableArray *provinceArray = [NSMutableArray array];
// // NSString *path = @"/Users/dllo/Desktop/资料 09-29-01-843/area.txt";
// NSString *string = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
// NSArray *array = [string componentsSeparatedByString:@"\n"];
// // NSLog(@"%@", array);
// for (NSString *str in array)
// {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/493e3f707115f5dd15ef2a7160aaccee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579c9986921d6f834817fb1198ffa636/" rel="bookmark">
			tips: 监听radio的变化以及获取radio选中值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- listen to the OperatingSystem radios change --&gt;
$("input:radio[name='operatingSystem']").change(function(){
var operatingSystem = $("input[name='operatingSystem']:checked").val(); alert(operatingSystem);
});
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d72acf425b8f8789d1721c7fa9307f/" rel="bookmark">
			Qt-Style-Sheets-语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt样式表语法英文原文
Qss的术语和语法几乎和HTML CSS相同，如果你已经熟悉CSS，你可以快速的浏览本文。
##样式规则
样式表由一系列的样式规则组成。一条样式规则由一个选择器和一个声明语句组成，选择器指明了哪个（或者说是哪种）部件将会受***规则***影响，而声明语句则指明了哪些属性会设置到这个（这些）部件.
举个例子：
QPushButton {color: red} 在上面的样式规则中，QPushBbutton就是*选择器***，而{ color： red}则是*声明语句***。该规则指明了QPushButton和它的子类（如：MyPushButton）应该使用红色作为它们的前景色。Qt样式表通常是不区分大小写的（比如：color, Color, COLOR, 和 cOloR 都是表示同一个属性）。当然也有区分大小写的，类名、对象名、Qt属性名（与color这些属性不是一回事，后面详细解释）这几个都是需要区分大小写的。
几个选择器可以指定同样的声明语句，使用(,)来隔开不同的选择器，举个例子，如下规则：
QPushButton, QLineEdit, QComboBox { color: red } 与下面三个规则是等价的：
QPushButton { color: red } QLineEdit { color: red } QComboBox { color: red } 样式规则的声明语句部分是一个**属性:值对列表，由({})包闭，由分号作为分割，举个例子：
QPushButton { color: red; background-color: white } 查看更多由Qt widgets提供的属性列表（属性名大概看一下就知道什么意思了，有时间再详细说吧）
##选择器类型
到目前为止，所有例子所使用的都是简单的选择器，即类型选择器。Qt样式表支持所有的CSS2定义的选择器。下表总结了几种最常用的选择器类型。
选择器实例描述通用选择器*匹配所有的widget类型选择器QPushButton匹配所有的QPushButton实例和继承于它的子类属性选择器QPushButton[flat=“false”]匹配所有非flat的QPushButton(通常情况下，使用Q_PROPERTY宏来声明你的属性，比如此例中的flat),并且要注意，你的属性类型要受 QVariant::toString()支持(查看toString()方法的帮助文档以获取更详细的解释).
这个选择器类型也可以用来判断动态属性，要了解更多使用自定义动态属性的细节，请参考使用自定义动态属性 。
除了使用=，你还可以使用~=来判断一个QStringList中是否包含给定的QString。
警告：如果在设置了样式表后，相应的属性值发生了改变(如：flat变成了"true")，则有必要重新加载样式表，一个有效的方法是，取消样式表，再重新设置一次,下面的代码是其中一种方式：
style()-&gt;unpolish(this);
style()-&gt;polish(this);// force a stylesheet recomputation
类选择器.QPushButton匹配所有的QPushButton实例，但不包括它的子类，与*[class~=“QPushButton”]是等价的。ID选择器QPushButton#okButton匹配所有object name为"okButton"的QPushButton实例。后裔选择器QDialog QPushButton匹配所有继承于QDialog(包括其所有子孙)的QPushButton实例。子选择器QDialog &gt; QPushButton匹配所有直接继承与QDialog的QPushButton实例。 ##Sub-Controls
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d72acf425b8f8789d1721c7fa9307f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0eef2b3e970ef04059f64dfc1e31b9/" rel="bookmark">
			PopupWindow setOutsideTouchable 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为Android开发者，很可能在使用PopupWindow时出现各种各样的问题
比如调用setOutsideTouchable方法没有效果的情况
以下说几点：
如果要使用点击区域外使对话框消失，必须调用以下方法：
popupWindow.setFocusable(true);//这里必须设置为true才能点击区域外或者消失
popupWindow.setTouchable(true);//这个控制PopupWindow内部控件的点击事件
popupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
popupWindow.setOutsideTouchable(true);
popupWindow.update();
这样做就可以了；但是问题又来了,如何让点击区域外不消失呢:
除了上面的设置外
popupWindow.setOutsideTouchable(false);
光设置这一行是没有效果的
popupWindow.setFocusable(false);//点击区域外不会消失，点击返回会执行back事件
必须添加这一行将其设置为false才能实现点击区域外不消失
好了，就到此吧！下次见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b99a2e65e164e7ef0ba34834bc2d8db/" rel="bookmark">
			ural1960Palindromes and Super Abilities（回文树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文树根据以下博客学的，写得很好
传送门：http://blog.csdn.net/u013368721/article/details/42100363
After solving seven problems on Timus Online Judge with a word “palindrome” in the problem name, Misha has got an unusual ability. Now, when he reads a word, he can mentally count the number of unique nonempty substrings of this word that are palindromes. Dima wants to test Misha’s new ability. He adds letters s 1, ..., s n to a word, letter by letter, and after every letter asks Misha, how many different nonempty palindromes current word contains as substrings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b99a2e65e164e7ef0ba34834bc2d8db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36de261890048772ec2b2c6f6db8dbdc/" rel="bookmark">
			mysql中的tinyint在C#中的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中的tinyint在C#中的类型 在C#中对应的类型是System.SByte，不是byte。 转载于:https://www.cnblogs.com/huxiaolin/p/4685321.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229589b37b7f2c0cc05ebf04ab0091ff/" rel="bookmark">
			[Android] 修改Android Virtual Device Manager 创建虚拟机默认路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的环境： 系统：win7 x64IDE：adt-bundle-windows-x86_64-20140702杀软：360处理器：intel-i5 修改方法： 添加环境变量：
变量名：ANDROID_SDK_HOME
变量值：[你要存放位置的绝对路径] 如：D:\MyVD
注意：路径里不要有中文与空格，按照编程里变量命名规则命名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70817c84d48b39f9fcdb0f6b4044d0c4/" rel="bookmark">
			每天一个linux命令（4）：mkdir命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 1．命令格式： mkdir [选项] 目录… 2．命令功能： 通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 3．命令参数： -m, –mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, –parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v, –verbose 每次创建新目录都显示信息 –help 显示此帮助信息并退出 –version 输出版本信息并退出 4．命令实例： 实例1：创建一个空目录 命令： mkdir test1 输出：
[root@localhost soft]# cd test [root@localhost test]# mkdir test1 [root@localhost test]# ll 总计 4drwxr-xr-x 2 root root 4096 10-25 17:42 test1 [root@localhost test]# 实例2：递归创建多个目录 命令： mkdir -p test2/test22 输出：
[root@localhost test]# mkdir -p test2/test22 [root@localhost test]# ll 总计 8drwxr-xr-x 2 root root 4096 10-25 17:42 test1 drwxr-xr-x 3 root root 4096 10-25 17:44 test2 [root@localhost test]# cd test2/ [root@localhost test2]# ll 总计 4drwxr-xr-x 2 root root 4096 10-25 17:44 test22 [root@localhost test2]# 实例3：创建权限为777的目录 命令： mkdir -m 777 test3 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70817c84d48b39f9fcdb0f6b4044d0c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b79447445b3cdee4969c17f98dcc6f12/" rel="bookmark">
			debian支持ll命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		debian支持ll命令 $ ll -bash: ll: command not found 没有ll这个命令，虽然也知道ll其实 是ls -l 这个命令的别名，但是总感觉不是很习惯，因为之前一直用centos的。 如果想让debian也支持 ll 命令的话则需要修改用户目录下面的.bashrc 配置文件 cd #进入当前用户目录 vim .bashrc #使用vim 编辑.bashrc配置文件 我们找到这样几行 # You may uncomment the following lines if you want `ls' to be colorized: # export LS_OPTIONS='--color=auto' # eval "`dircolors`" # alias ls='ls $LS_OPTIONS' # alias ll='ls $LS_OPTIONS -l' # alias l='ls $LS_OPTIONS -lA' 我们之间把alias ll=’ls $LS_OPTIONS -l’前面的#号去掉，如下 # You may uncomment the following lines if you want `ls' to be colorized: export LS_OPTIONS='--color=auto' # eval "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b79447445b3cdee4969c17f98dcc6f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c8f242e6354923e8b17f24a838044b/" rel="bookmark">
			failed to load ldlinux.c32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 failed to load ldlinux.c32 用UltraISO制作Ubuntu 或 Debian 的U盘启动盘后， 在机器用U盘启动时有时会报这个错误： failed to load ldlinux.c32 是因为UltraISO的问题，需要换刻录软件； 请换刻录软件 linux的用mkusb， windows的用Win32DiskImager 具体用法： https://wiki.ubuntu.com/Win32DiskImager/iso2usb https://help.ubuntu.com/community/mkusb 准备工作： 请到官方网站下载win32diskimager 工具。 下载地址http://sourceforge.net/projects/win32diskimager/files/latest/download 下载U-NAS系统的ISO包 1.先插入U盘，再打开win32diskimager。 2. 选择接入U盘的盘符(电脑中最好只接入一个U盘，以免选错) 3.在Image File中，选择系统ISO软件包。(注意：ISO包需要放在英文或数字目录下，即不能放在中文目录下) 将“保存类型”选择*.*，这样才能发现ISO系统包。 4.点击Write按扭。 注意： 在写入过程中，如果ISO系统包放在带有中文目录的情况下会出现此类问题 需要把ISO包放在英文或数字目录下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc226b0b1d99dfdc39605f014351985/" rel="bookmark">
			编译原理项目--比特大战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍
1.1游戏简介
1.2游戏的策略
1.3问题的描述
1.项目设计
2.1设计目标
这里设计了一个编译语言称作C-Minus（或简称为C-），这是一种适合编译器设计方案的语言，它比TINY语言更复杂，包括函数和数组。本质上它是C的一个子集，但省去了一些重要的部分，因此得名。首先，我们列出了语言惯用的词法，包括语言标记的描述。其次，给出了每个语言构造的BNF描述。同时还有相关语义的英语描述，包括语言标记的表述，再者给出了C-的几个示例程序。最后生成目标可执行代码（汇编代码）。
2.2项目环境
2.2.1开发与运行平台
Windows
2.2.2开发工具
VC6.0、Masm6.15以上版本
2.2.3项目设计模型
图1编译器的阶段
（1）扫描程序（scanner）
在这个阶段编译器实际阅读源程序（通常以字符流的形式表示）。扫描程序执行词法分析（Lexical analysis）：它将字符序列收集到称作记号（token）的有意义单元中，记号同自然语言，如英语中的字词相似。因此可以认为扫描程序执行与拼写相似的任务。
例如在下面的代码行（它可以是C程序的一部分）中：
a [index] = 4 + 2
这个代码包括了12个非空字符，但只有8个记号：
a 标识符
[ 左括号
i n d e x 标识符
] 右括号
= 赋值
4 数字
+ 加号
2 数字
每一个记号均由一个或多个字符组成，在进一步处理之前它已被收集在一个单元中。
（2）语法分析程序（parser）
语法分析程序从扫描程序中获取记号形式的源代码，并完成定义程序结构的语法分析（syntax analysis），这与自然语言中句子的语法分析类似。语法分析定义了程序的结构元素及其关系。通常将语法分析的结果表示为分析树（parse tree）或语法树（syntax tree）。
例如，还是那行C代码，它表示一个称为表达式的结构元素，该表达式是一个由左边为下标表达式、右边为整型表达式的赋值表达式组成。这个结构可按下面的形式表示为一个分析树：
（1）语义分析程序（semantic analyzer）
程序的语义就是它的“意思”，它与语法或结构不同，程序的语义确定程序的运行，但是大多数的程序设计语言都在执行之前被确定而不易由语法表示和由分析程序分析的特征。这些特征被称作静态语义（staticsemantic），而语义分析程序的任务就是分析这样的语义（程序的“动态”语义具有只有在程序执行时才能确定的特性，由于编译器不能执行程序，所以它不能由编译器来确定）。一般的程序设计语言的典型静态语义包括声明和类型检查。由语义分析程序计算的额外信息被称为属性（attribute），它们通常是作为注释或“装饰”增加到树中（还可以将属性添加到符号表中）。
（2）代码生成器（codegenerator）
代码生成器得到中间代码（IR），并生成目标机器的代码，尽管大多数编译器直接生成目标代码，但是为了便于理解，本项目用汇编语言来编写目标代码。正是在编译的这个阶段，目标机器的特性成为了主要因素。当它存在与目标机器时，使用指令不仅是必须的而且数据的形式表示也起着重要的作用。
3.项目文件定义
3.1文件描述
C-编译器包括以下的文件，（为了包含而）把它的头文件放在左边，他的代码文件放在右边：
globals.h main.cpp
util.h util.cpp
scan.h scan.cpp
parse.h parse.cpp
symtab.h symtab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc226b0b1d99dfdc39605f014351985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54c708d8d4dee580796e50f882b3e6b/" rel="bookmark">
			多任务与AD转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、实验目的
1．进一步理解ARM芯片的A/D转换原理。
2．进一步熟悉uCOS-II的多任务调度机制以及消息循环、图形控件的使用。
3．学习多通道数据采集的方法。
二、实验内容
采用多任务编程方法，每个任务监视一路AD转换，每一路AD的转换结果在液晶屏上用一个条形图的长短来表示，直观地显示每路模拟输入电压的大小。可以通过文本框给每路AD设置警戒值，某路输入超出警戒线之后条形图中超出的部分会以闪动的方式显示。
三、预备知识
1、用ARMADS1.2集成开发环境，编写和调试程序的基本过程。
2、基于uCOS-II操作系统应用程序的框架结构。
3、了解uCOS-II多任务调度的原理。
4、会使用图形控件和绘图API函数。
四、实验设备及工具
硬件：ARM嵌入式开发平台、用于ARM920T的JTAG仿真器、PC机Pentium100以上。
软件：PC机操作系统Win2000或WinXP、ARMADS1.2集成开发环境、仿真器驱动程序、超级终端通讯程序。
五、实验步骤
1．启动ADS1.20新建工程，将“Exp17 多任务与AD转换”中的文件添加到工程。
2. 在ADS集成开发环境中编译、调试和运行工程程序。其中，修改部分代码，分别在主函数main.c的部分代将”int WarnningData[3]={33,33,33};”的值设置为10，20，30。
3.编译生成system.bin文件,方法和实验一一样，这里就不重复了。
七、实验结果 开发板上的显示器会出现下图的图形界面。扭动旋转按钮可以调整黑色矩形长度，当第一个矩形的长度超过第一条临界值的时候会闪烁报警，其他也以此类推。
八、实验心得 通过实验，加深了对AD转换的理解，收益良多，但是还有一个问题没有很好地得到解决。做本实验之前将u12x12和u16x16字库下载到Flash中ucos目录下的实验出现错误。过程描述如下：
查阅资料得知，在ucos 系统中用到的文件（图片、文本文件等）都是通过启动一个 ucos 系统的应用程序来下载文件到指定目录的。
① 先打开超级终端，超级终端的设置如前所述。
② 运行列表框的控件的使用实验，运行方法 a：将列表框的控件的使用实验的映
象文件下载到 flash 中。方法 b：用仿真器调试的方式运行列表框的控件的使用
实验。
③ 新建 ucos 目录，命令是 mkdir ucos 回车，然后在 sys&gt;提示符下键入 ls，若新建
目录成功可看见此文件名，然后进入ucos目录下，在 sys&gt;提示符下键入 cd ucos
回车，进入 ucos 。
④ 将字库 u12x12 和u16x16下载到 ucos目录下，下载命令 dl u12x12.fnt -d 回车，
然后选择超级终端中的传送菜单下的发送文件。
但是在执行过程中发现，在第三步新建ucos目录的时候出现错误，屏幕不断闪现00ff的乱码，因为运行方法a失败。由于缺少仿真器，不能进行实验方法b，因此这个字库的问题还不能很好地解决。
需要“Exp17 多任务与AD转换”中的文件请联系邮箱269872441@qq.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ec1d7856c464432cc3c143effd3cf2/" rel="bookmark">
			UC/OS-II在ARM微处理器上的移植及编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1．了解uCOS-II内核的主要结构。
2．掌握将uCOS-II内核移植到ARM920T处理器上的基本方法。
二、实验内容
1．将uCOS-II内核移植到ARM920T微处理器上。
2．编写两个简单任务，在开发板显示器上观察两个任务的切换。
三、预备知识
1．掌握在ARMADS1.2集成开发环境中编写和调试程序的基本过程。
2．了解ARM920T处理器的结构。
3．了解uCOS-II系统结构。
四、实验设备及工具
硬件：ARM嵌入式开发平台、用于ARM920T的JTAG仿真器、PC机Pentium100以上。
软件：PC机操作系统Win2000或WinXP、ARMADS1.2集成开发环境、仿真器驱动程序、超级终端通讯程序。
五、实验原理
所谓移植，指的是一个操作系统可以在某个微处理器或者微控制器上运行。虽然uCOS-II的大部分源代码是用C语言写成的，仍需要用C语言和汇编语言完成一些与处理器相关的代码。比如：uCOS-II在读写处理器、寄存器时只能通过汇编语言来实现。因为uCOS-II在设计的时候就已经充分考虑了可移植性，所以，uCOS-II的移植还是比较容易的。
要使uCOS-II可以正常工作，处理器必须满足以下要求：
1．处理器的C编译器能产生可重入代码。
可重入的代码指的是一段代码（如一个函数）可以被多个任务同时调用，而不必担心会破坏数据。也就是说，可重入型函数在任何时候都可以被中断执行，过一段时间以后又可以继续运行，而不会因为在函数中断的时候被其他的任务重新调用，影响函数中的数据。下面的两个例子可以比较可重入型函数和非可重入型函数：
程序1：可重入型函数
void swap(int *x, int *y)
{
int temp;
temp=*x;
*x=*y;
*y=temp;
}
程序2：非可重入型函数
int temp;
void swap(int *x, int *y)
{
temp=*x;
*x=*y;
*y=temp;
}
程序1中使用的是局部变量temp作为变量。通常的C编译器，把局部变量分配在栈中。所以，多次调用同一个函数，可以保证每次的temp互不受影响。而程序2中temp定义的是全局变量，多次调用函数的时候，必然受到影响。
代码的可重入性是保证完成多任务的基础，除了在C程序中使用局部变量以外，还需要C编译器的支持。笔者使用的是ARM ADS的集成开发环境，均可以生成可重入的代码。
2．在程序中可以打开或者关闭中断。
在uCOS-II中，可以通过OS_ENTER_CRITICAL()或者OS_EXIT_CRITICAL()宏来控制系统关闭或者打开中断。这需要处理器的支持,在ARM920T的处理器上，可以设置相应的寄存器来关闭或者打开系统的所有中断。
3．处理器支持中断，并且能产生定时中断（通常在10Hz1000Hz之间）。
uCOS-II是通过处理器产生的定时器的中断来实现多任务之间的调度的。在ARM920T的处理器上可以产生定时器中断。
4．处理器支持能够容纳一定量数据的硬件堆栈。
5．处理器有将堆栈指针和其它CPU寄存器存储和读出到堆栈（或者内存）的指令。
uCOS-II进行任务调度的时候，会把当前任务的CPU寄存器存放到此任务的堆栈中，然后，再从另一个任务的堆栈中恢复原来的工作寄存器，继续运行另一个任务。所以，寄存器的入栈和出栈是uCOS-II多任务调度的基础。
图3-1说明了uC/OS的结构以及它与硬件的关系。
图3-1 uCOS-II硬件和软件体系结构
ARM920T处理器完全满足上述要求。接下来将介绍如何把uCOS-II移植到Samsung公司的一款ARM920T的嵌入式处理器——S3C2410X上。
六、实验步骤
1．启动ADS1.20新建工程，将“Exp10 系统移植实验”中的文件添加到工程。由于开发商对源代码进行了封装，有些功能函数在“Exp10 系统移植实验”中的文件中没有实现，固可以尝试修改实验二的“Exp17 多任务与AD转换”主函数代码来实现本次实验。
2. 在ADS集成开发环境中编译、调试和运行工程程序。其中，修改部分代码，分别在主函数main和两个任务函数Task1和Task2。代码如下：
int main(void)
{ ARMTargetInit(); // do target (uHAL based ARM system)initialisation //
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33ec1d7856c464432cc3c143effd3cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f1350b1418e156e8cedac05546a2ad/" rel="bookmark">
			ubuntu下使用HDMI时输出无声音的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题碰到几次了，第一次是刚给显示器接用HDMI线的时候，后来给Ubuntu更新内核后又碰到了,特此记录一下
使用HDMI会默认将视频和声音都由其输出，然后声音经由HDMI线从主机直接走到显示器后出来(好像不走声卡直接输出？)，可以接音箱或者耳机，但插孔在背后，操作很麻烦，一般还是习惯使用主机上的接口。所以目的很明确，就是将声音分隔出来走原来的通道
步骤如下：
确保音频输出正常
进入终端，在alsa中设置音频输出，使其不为静音状态
$ alsamixer 找到&lt;S/PDIF 1&gt;那项，有些机器可能是&lt;S/PDIF&gt;。如果其值为'MM'，按ｍ键将其调为'00',　按Esc退出
设置输出模式
进入Ubuntu声音设置中的‘硬件’选项卡，将配置设为'模拟立体声双工'。顺利的话，这时声音就出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32eec81fcf2dc60925e5501a629af822/" rel="bookmark">
			Java计算阶乘(n!)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算阶乘--求n!的值
两种方法
1.使用递归方式实现
2.使用循环方式实现
public class TestRecursive { public static void main(String[] arg) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(factorial(n)); } /** * 使用递归方法计算n的阶乘 * * @param n * @return */ private long factorial(int n) { if (n == 0) { System.out.println(n + "! = " + 1); return 1; } else { long num = n * factorial(n - 1); System.out.println(n + "! = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32eec81fcf2dc60925e5501a629af822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0a7a3385bfaa6a5383b193ebeccd4f/" rel="bookmark">
			POJ2395 -- Prim算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。Prim算法和Dijkstra算法
1. Prim算法： 最小生成树，主要用于，N个村庄修路，怎么样成本最低。
2.Dijkstra算法：最短路径计算，主要用于，任何一个点到点1的最短距离。
区别：
Prim算法和Dijkstra算法在代码实现上，几乎一样，唯一有个区别在于：
Prim： Graph[k][j] &lt; dis[ j ] // dis[ j ]表示到j点最小的权值
Dijkstra： min+Graph[k][ j ] &lt; dis[ j ] // dis[ j ]表示点1到j点最小的距离
二。该题求得是最小生成树的最长边。需要注意的有俩点： 1. 输入的边上重复的，需要去重。
2.把最大值定义大点，否则容易WA。#define INFI 999999999
三。查看全部代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX 2001 #define INFI 999999999 int N,M; int Graph[MAX][MAX]; int dis[MAX]; //任意一个点到点i的最小距离 int vis[MAX]; //标志位 int outMax; //输出的最大值 void prim(){ int i,j; for(i=1;i&lt;=N;i++){ dis[i] = Graph[1][i]; } vis[1]=1; for(i=1;i&lt;N;i++){ //求到其余N-1个点的最短距离，N-1次 int min=INFI; int k=0; for(j=2;j&lt;=N;j++){ //寻找距离顶点1的最大重量 if(vis[j]==0 &amp;&amp; min&gt;dis[j]){ //求到点1最短的那个点 min = dis[j]; k=j; } } vis[k]=1; if(outMax &lt; min){ outMax = min; } for(j=2;j&lt;=N;j++){ //更新到点j的最小距离。 if(vis[j]==0 &amp;&amp; Graph[k][j] &lt; dis[j]){ //与Dijsktra的唯一区别在于：min+Graph[k][j] &lt; dis[j] dis[j]= Graph[k][j]; } } } } int main() { //freopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a0a7a3385bfaa6a5383b193ebeccd4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81c9d941b6ff71a6d287f65f6f718f6/" rel="bookmark">
			[深入学习C#]LINQ查询表达式详解(1)——基本语法、使用扩展方法和Lambda表达式简化LINQ查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在Git上下载源码 在工程中我们少不了要定义类或者结构去储存数据，这些数据将被临时地储存在内存中，现在我们想要对其完成一些类似于查找、过滤等等常见的任务的时候，我们该如何去做呢？ 我们可以自己写代码去对集合中的每个对象进行遍历，检查变量的每个字段看其是否满足条件。这样的故事已经发生太多次了，微软怎么可能容忍在C#里发生如此弱智的事情呢？于是，C#的设计者决定在C#中集成查询的语法，以最大限度地减少程序员书写类似代码的情况。 这也就是我们说的LINQ(Language Intergated Query)也就是语言集成查询，我们可以使用同样的语法访问不同的数据源。
为什么要使用LINQ？ 几乎所有的应用程序都需要对数据进行处理，大部分的程序都通过自定义的逻辑来完成这些操作。这样做的弊端之意就是，代码逻辑将会跟它处理的数据的结构紧密耦合在一起，如果数据结构发生了改变，也许将会带来海量的代码改动。 为了解决这个问题，C#将这些处理数据的代码都抽象出来，提供给了广大开发者。这就是LINQ。 LINQ的语法类似于关系和分层查询语言(SQL和XQuery)，我们可以在不更改查询代码的情况下对数据结构进行更改。LINQ比之SQL要更加灵活，可以处理更广泛的逻辑数据结构。当然，这些数据结构都需要实现了IEnumerable或者IEnumerable&lt; T &gt;接口，才可以进行LINQ查询。
LINQ查询表达式语法详解 表达式基础语法 LINQ查询表达式以from子句开始，以select或者group子句结束。在这两个子句之间可以跟零个或者多个from、let、where、join或者orderby子句。 每个from子句都是一个生成器，该生成器将引入一个包括序列(Sequence)的元素的范围变量(range variable)。每个let子句都会引入一个范围变量，以表示通过前一个范围变量计算的值。每个where子句都是一个筛选器，用于从结果中排除项。每个join子句都将指定的源序列键与其他序列的键进行比较，以产生匹配对。每个orderby子句都会根据指定的条件对各项进行重新排序。而最后的select或者group子句根据范围变量来指定结果的表现形式。最后可以使用into子句来连接查询，将某一查询结果的视为后续查询的生成器。
标准查询操作符 在了解LINQ查询表达式之前，怎么能不了解下它的查询操作符呢？下面列表列出了LINQ定义的标准查询操作符。 表1:LINQ标准查询操作符 标准查询操作符说明where OfType&lt;TResult&gt;筛选操作符定义了返回元素的条件。在Where查询操作符中，可以使用谓词，例如Lambda表达式定义的谓词，来返回布尔值。OfType&lt;TResult&gt;根据类型筛选元素，只返回TResult的类型元素Select 和SelectMany投射操作符用于把对象转换为另一个类型的新对象。Select和SelectMany定义了根据选择器函数选择结果值的投射。OrderBy、ThenBy 、OrderByDescending 、ThenByDescending 、Reverse排序操作符改变所返回的元素的顺序。OrderBy按升序排列，OrderByDescending按降序排列。如果第一次排序结果很类似，就可以使用ThenBy和ThenByDescending操作符进行第二次排序。Reverse反转集合中的元素顺序。GroupBy、ToLookUp组合运算符把数据放在组里面。GroupBy操作符组合有公共键的元素。ToLookUp通过创建一个一对多的字典，来组合元素。Join、GroupJoin链接运算符用于合并不直接相关的集合。使用Join操作符，可以根绝键选择器函数连接两个集合，这类似于SQL中的Join。GroupJoin操作符连接两个集合，组合其结果。Any、All、Contains如果元素序列满足指定的条件，两次操作符就返回布尔值。Any、ALll和Contains都是限定符操作符。Any确定集合中是否有确定满足谓词函数的元素。ALll确定集合中的所有元素是否都满足谓词函数。Contains检查某个元素是否在集合中。这些操作符都返回一个布尔值。Take、Skip、TakeWhile、SkipWhile分区操作符返回集合的一个子集，Take、Skip、TakeWhile、SkipWhile都是分区操作符。使用它们可以得到部分结果，使用Take必须指定要从集合中提取的元素个数；Skip跳过指定个数的元素，提取其它元素；TakeWhile提取条件为真的元素。Distinct、Union、Intersect、Except、ZipSet操作符返回一个集合。Distinct从集合中删除重复的元素，除了Distinct之外，其它的Set操作符都需要两个集合。Union返回出现在其中一个集合中的唯一元素。Intersect返回两个集合中都有的元素。Except返回值出现在一个集合中的元素。Zip是.NET 4新增的，它把两个集合合并为一个。First、FirstOrDefault、Last、LastOrDefault、ElementAt、ElementAtOrDefault、Single、SingleOrDefault这些元素操作符仅返回一个元素。First返回第一个满足条件的元素。FirstOrDefault类似于First，单如果没有找到满足条件的元素，就返回类型的默认值。Last返回最后一个满足条件的元素。ElementAt指定了要返回的元素的位置。Single只返回一个满足条件的元素。如果有多个元素都满足条件，就抛出一个异常。Count、Sum、Min、Max、Average、Aggregate聚合操作符计算集合的一个值。利用这些聚合操作符，可以计算所有值的总和、所有元素的个数、值最大和最小的元素，以及平均值等等。ToArray、ToEnumerable、ToList、ToDictionary、Cast&lt;TRsult&gt;这些转换操作符将集合转换为数组：IEnumerable、IList、IDictionary等。Empty、Range、Repeat这些生成操作符返回一个心机和。使用Empty时集合是空的；Range返回一系列数字；Repeat返回一个始终重复一个值的集合。 设置案例背景 假设我们有4个类，Customer，Order，Detail，Product，它们的定义如下：
Customer类字段字段类型CustomerIDintCountrystringNamestringCitystringOrdersList&lt;Order&gt; Order类字段字段类型OrderIDintCustomerIDintTotalintOrderDateDateTimeDetailsList&lt;Detail&gt; Detail类字段字段类型DetailIDintOrderIDintUnitPricedoubleQuantitydoubleProductIDint Product类字段字段类型ProductIDintProductNamestring 假设现在它们各自有一个List集合，分别为Customers，Orders，Details，Products。我们在这基础之上来一步步阐述LINQ查询表达式。 customers数据：
CustomerIDCityCountryNameOrders0北京中国小米orders.FindAll(c =&gt; c.CustomerID == 0)1首尔韩国三星orders.FindAll(c =&gt; c.CustomerID == 1)2加州美国苹果orders.FindAll(c =&gt; c.CustomerID == 2)3台北中国HTCorders.FindAll(c =&gt; c.CustomerID == 3)4珠海中国魅族orders.FindAll(c =&gt; c.CustomerID == 4)5北京中国华为orders.FindAll(c =&gt; c.CustomerID == 5)6上海中国索尼orders.FindAll(c =&gt; c.CustomerID == 6)7北京中国联想orders.FindAll(c =&gt; c.CustomerID == 7)8上海中国诺基亚orders.FindAll(c =&gt; c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81c9d941b6ff71a6d287f65f6f718f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf355378d57f55f57cab9760579a3aa/" rel="bookmark">
			IOS已解决 在构建版本上传后, 一直处于处理状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天上传 iTunes connect ，遇到一个问题，结果网上搜到一个解决方案，先和大家共享下，据说有人这样解决了问题，
应用程序上传app的时候有一个构建版本， 我上传了的版本但是哪个都选不了 ，一直显示正在处理！百度查到重新上传就好了，应该是以前上传的因为网络原因没有上传完整！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b34215c3d000720e5f4282330fd2d3/" rel="bookmark">
			BP神经网络非线性函数拟合应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% BP神经网络的输入输出数据 % clear all % clc % x=rand(1,1500); % y=rand(1,1500); % p=[x;y]'; % z=x.^2-y.^2+3; % save x x % save y y % save p p % save z z %% clear all clc %% 训练数据预测数据提取及归一化 % 下载输入输出数据 % load x y z p x=rand(1,1500); y=rand(1,1500); p=[x;y]'; z=x.^2-y.^2+3; % 从1到1500间随机排序 k=rand(1,1500); [m,n]=sort(k); % 找出训练数据和预测数据 input_train=p(n(1:1400),:)'; output_train=z(n(1:1400)); input_test=p(n(1401:1500),:)'; output_test=z(n(1401:1500)); % 训练样本输入输出数据归一化 [inputn,inputps]=mapminmax(input_train); [outputn,outputps]=mapminmax(output_train); %% BP网络训练 % 初始化网络结构 net=newff(inputn,outputn,5); net.trainParam.epochs=500; net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b34215c3d000720e5f4282330fd2d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d2710acc45d1f66d8dfcea62e0b19b/" rel="bookmark">
			Debian下怎样以不同颜色显示不同的文件或目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在~/.bashrc文件沒有作任何调整的情況下，输入ls命令文件或目录均以同一种颜色显示的。为了让不同的文件类型及目录以其它的颜色显示，则需要作如下的设置。不作任何修改也可以以不同的颜色显示文件及目录，那就是在ls后面加上--color即可，不过每次这样输入比较麻烦，还是修改.bashrc文件来得方便。将~/.bashrc文件与ls相关几行前面的#去掉（红色标注），然后执行source .bashrc就生效了。
#vi ~/.bashrc
# ~/.bashrc: executed by bash(1) for non-login shells.
# Note: PS1 and umask are already set in /etc/profile. You should not
# need this unless you want different defaults for root.
# PS1='${debian_chroot:+($debian_chroot)}\h:\w\$ '
# umask 022
# You may uncomment the following lines if you want `ls' to be colorized:
export LS_OPTIONS='--color=auto'
eval "`dircolors`"
alias ls='ls $LS_OPTIONS'
alias ll='ls $LS_OPTIONS -l'
alias l='ls $LS_OPTIONS -lA'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7d2710acc45d1f66d8dfcea62e0b19b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf42ed42a5a99f25ac9e9497a9b2d5c9/" rel="bookmark">
			linux Centos 下非 root  用户执行shell的一些问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在linux系统上只有root用户才可以访问1024以下的端口号，其余用户不能访问
今天在centos系统下，用非root用户启动 tomcat，默认端口是80，结果启动失败。
解决办法：
用sudo执行：
sudo ./startup.sh 结果报：
username is not in the sudoers file. This incident will be reported 需要设置 用户 可以用sudo执行命令
2、让用户能够以 sudo 执行命令
以 root 用户执行：
visudo 命令，编辑/etc/sudoers 文件。
在 root ALL=(ALL) ALL 下面添加一行
username ALL=(ALL) ALL
如果不想每次都输入密码可以用这一行
username ALL=(ALL) NOPASSWD:ALL
wq保存。
再次用 加入的用户执行以下命令：
sudo ./startup.sh 结果，每次都需要输入密码。
3、sudo执行脚本无需输入密码
执行：
visudo 编辑，将 #%wheel 前面的#去掉：
## Allows people in group wheel to run all commands %wheel ALL=(ALL) ALL ## Same thing without a password %wheel ALL=(ALL) NOPASSWD: ALL wq保存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf42ed42a5a99f25ac9e9497a9b2d5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f43b200192f0c9ea3967dde3b0e1b398/" rel="bookmark">
			Android开发技巧——使用Dialog实现仿QQ的ActionSheet菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近看到有人用Dialog来实现QQ的仿ActionSheet的自定义菜单，对于自己没实现过的一些控件，看着也想实现一下。于是动手了一下，发现也不难，和大家分享一下。
本文原创，转载请注明出处：http://blog.csdn.net/maosidiaoxian/article/details/46119197
在这里我也是用Dialog来实现，代码不多，这里说一下实现的过程。
菜单的布局文件 首先我们写先一下菜单的布局文件，很简单，一个ListView菜单再加一个取消的Button。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ListView android:id="@+id/menu_items" android:layout_width="match_parent" android:layout_height="wrap_content" android:listSelector="@android:color/transparent"/&gt; &lt;Button android:id="@+id/menu_cancel" android:layout_width="match_parent" android:layout_height="45dp" android:layout_marginBottom="8dp" android:layout_marginTop="8dp" android:text="取消"/&gt; &lt;/LinearLayout&gt; 在这里我们先是写一下最基本的布局文件，因为我急着想知道实现上的可行性，所以背景那些暂未修改。
继承Dialog实现自己的菜单 我们的对话框有几个特点，一是弹出的位置在底部，二是没有对话框的那些windowFrame层也没有标题和contentOverlay层，并且背景透明。 所以我们要先写一个Dialog的Style，继承自系统主题:
&lt;style name="ActionSheetDialog" parent="android:Theme.Dialog"&gt; &lt;item name="android:windowContentOverlay"&gt;@null&lt;/item&gt; &lt;item name="android:windowFrame"&gt;@null&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt; 接下来我们需要写一个类继承Dialog，来实现自己的弹出菜单。在构造方法中调用super(Context context, int theme)方法。并且我们尝试设置gravity，来使它显示在底部。
public class ActionSheet extends Dialog { private Button mCancel; private ListView mMenuItems; private ArrayAdapter&lt;String&gt; mAdapter; public ActionSheet(Context context) { super(context, R.style.ActionSheetDialog); getWindow().setGravity(Gravity.BOTTOM); initView(context); } private void initView(Context context) { View rootView = View.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f43b200192f0c9ea3967dde3b0e1b398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d464d0e66ccbbdd28e20a9ea158b3c/" rel="bookmark">
			passwd --stdin 选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;pre name="code" class="sql"&gt;--stdin This option is used to indicate that passwd should read the new password from standard input, which can be a pipe. 这个选项用于 从标准输入 管道读入新的密码 [root@master ~]# ssh 10.10.17.2 "echo 'a2p13mvh' | passwd --stdin root" root@10.10.17.2's password: Changing password for user root. passwd: all authentication tokens updated successfully. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a226a213fe0f24e12545a61425622dc/" rel="bookmark">
			Ajax实例（一）$.ajax的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 这是在nanjinonline项目中的user_main.html页面中，Ajax局部事件 &lt;script&gt; $(function() { var usrcustid = $('#UsrCustId_query').val();//取值 if (usrcustid == "") { alert("您还没注册汇付天下账号！") $('#acc_bal').html("0.00");//填充值 $('#avl_bal').html("0.00"); $('#frz_bal').html("0.00"); } else { var UsrCustId = $('#UsrCustId_query').val(); var data = "UsrCustId=" + UsrCustId; //$.ajax方法，详细见下文 $.ajax({ type: "POST", url: "/?huifu&amp;do=queryBalance", beforeSend: function(XMLHttpRequest) { var html = ''; html += "&lt;img alt=\"loading\" src=\"themes/nanjin/images/loading.gif\" style=\"height:20px;width:20px;\" /&gt;";//点开账户中心，个人详细信息，那个转动的加载图标 $('#acc_bal').html(html); $('#avl_bal').html(html); $('#frz_bal').html(html); }, success: function(response) { $('#acc_bal').html("");//给个人信息置空，取消掉转动的加载图标 $('#avl_bal').html(""); $('#frz_bal').html(""); if (response == "error") { alert("获取汇付余额失败，请刷新重试！"); $('#acc_bal').html("0.00"); $('#avl_bal').html("0.00"); $('#frz_bal').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a226a213fe0f24e12545a61425622dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fca95dc73f0fa20d62061abd0c7ace4/" rel="bookmark">
			java--18位身份证号最后一位（检验码）是怎么算出来的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		身份证的最后一位是根据前17位数字计算出来的检验码。计算方法是：将身份证号码前17位数分别乘以不同的系数。从第1位到第17位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2；将乘积之和除以11，余数可能为0 1 2 3 4 5 6 7 8 9 10。则根据余数，分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2。编写程序，输入身份证号码前17位，输出对应的检验码。 package acm;import java.util.*;public class Main3 {public static void main(String[] args) {Scanner scanner = new Scanner(System.in);String string = scanner.nextLine();int[] x = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};char[] y = {'1','0','x','9','8','7','6','5','4','3','2'};int sum=0;for (int i = 0; i &lt; string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fca95dc73f0fa20d62061abd0c7ace4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539fdab18b16b1ae630846a847c9a70c/" rel="bookmark">
			通过JS的事件处理取得radio的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.sina.com.cn/s/blog_50a1e17401017pik.html
提前知识准备：
在一个HTML文档中，每个元素都可以设置ID和NAME属性。
其中ID属性是唯一属性，不可以重复，一个ID值只能对应一个元素；
而NAME属性是可以重复的，一个NAME值可以对应一组元素。
所以，使用document.getElementByIdx_x(ID)时返回的只有一个被选中的HTML元素；
而使用document.getElementsByName(NAME)时返回的是一个由多个HTML元素组成的数组
（哪怕HTML页面中只有一个符合要求的元素，返回的也是数组）。
document.getElementsByName(NAME)多用于在FORM表单中选取一组checkbox或radio
方法1：
&lt;html&gt;
&lt;head&gt;
&lt;script type ="text/javascript"&gt;
function change()
{
var radio =document.getElementsByName("form1");
//var radio =document.getElementByIdx_x("form1");
// 用ById就不能取得全部的radio值,而是每次返回都为1
varradioLength = radio.length;
for(var i =0;i &lt; radioLength;i++)
{
if(radio[i].checked)
{
varradioValue = radio[i].value;
alert(radioValue);
}
}
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type ="radio" id = "form1" name = "form1" value = "1" onchange ="change();"&gt;选择1
&lt;input type ="radio" id = "form1" name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539fdab18b16b1ae630846a847c9a70c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f8e35cdd80aabe9449e51ab57df76d/" rel="bookmark">
			matlab中如何获取当前日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：http://blog.sina.com.cn/s/blog_50cfd0fc0100r3g0.html
matlab中如何获取当前日期时间函数的具体应用如下：
一、date ,now,clock
1.date：按照日期字符串格式返回当前系统日期 2.now：按照连续的日期数值格式返回当前系统时间 3.clock：按照日期向量格式返回当前系统时间
date,now,clock
ans =
09-Apr-2011 ans =
7.3460e+005 ans =
1.0e+003 *
2.0110 0.0040 0.0090 0.0170 0.0430 0.0470 二、year,month,day,hour,minute,second matlab中分别使用year,month,day,hour,minute,second从上面讲到的字符串和连续型日期时间格式中提取年月日时分秒等信息
[year(date),year(now)] ans = 2011 2011 注意：上面的函数是没法从向量型日期时间格式中正确读取上述信息的 year(clock) ans = 5 0 0 0 0 0 三、Matlab中处理日期与时间的函数详解
Matlab用三种格式来表示日期与时间 （1）双精度型日期数字：一个日期型数字代表从公元0年到某一日期的的天数，例如，2008年8月26日夜时0点钟被表示为733646，而这同一天的中午12点就被表示为733646.5，也就是说任何一个时刻都可以用一个双精度型数字表示。 （2）不同形式的日期字符串：Matlab定义了28种标准日期格式的字符串。 （3）数值型的日期向量：用一个6元数组来表示一个日期时间，例如，[2008 8 26 12 5 0]表示2008年8月26日12点05分0秒；用一个3元数组来表示一个日期，例如，[2008 8 26]表示2008年8月26日。 用日期数字表示日期使计算机更容易计算，但是不直观，因此Matlab提供了许多函数来实现三种日期格式之间的转化。 （1）datestr: 实现将日期数字和日期向量转化为日期字符串，可以在Matlab命令窗口中输入help datestr来查看关于datestr的用法。 （2）datenum: 实现将日期字符串和日期向量转化为日期数字，可以在Matlab命令窗口中输入help datenum来查看关于datenum的用法。 （3）datevec: 实现将日期数字和日期字符串转化为日期向量，可以在Matlab命令窗口中输入来help datevec查看关于datevec的用法。 Matlab中其他常用的函数： （1）clock：将当前时间和日期返回到一个（6元）数组中。
T = clock T = 2008 8 26 12 31 32.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54f8e35cdd80aabe9449e51ab57df76d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/268/">«</a>
	<span class="pagination__item pagination__item--current">269/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/270/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>