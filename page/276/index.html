<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35401f8f1fb288a59fa1c90ea14cf70c/" rel="bookmark">
			分享：C语言的三种不定参数，省略号用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. #define log(...) log2(__VA_ARGS__) 2. #deinfe log(fmt...) log2(fmt) 3. #define log(fmt,...) log2(fmt, ##__VA_ARGS__)
三者作用一样，只是表示方法不一样。
无论哪种情况，当用户使用 log("xxxx") 时，将被替换为 log2("xxxx")
#include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; void sum(char *msg, ...) { int total = 0; va_list p; int arg; va_start(p, msg); while ((arg = va_arg(p,int)) != 0) { total += arg; } printf(msg, total); va_end(p); } #define log(fmt...) printf(fmt) #define log1(fmt,...) printf(fmt, ##__VA_ARGS__) #define log2(...) printf(__VA_ARGS__) int main() { int a = 10; log("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35401f8f1fb288a59fa1c90ea14cf70c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ae875a203b669c8392e6f02d6a08a3/" rel="bookmark">
			TCP/IP详解学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转：http://blog.csdn.net/goodboy1881/article/details/758034
TCP/IP详解学习笔记(1)-基本概念
为什么会有TCP/IP协议
在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。就好像圣经中上帝打乱了各地人的口音，让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。 但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。
TCP/IP协议分层
提到协议分层，我们很容易联想到ISO-OSI的七层协议经典架构，但是TCP/IP协议族的结构则稍有不同。如图所示 TCP/IP协议族按照层次由上到下，层层包装。最上面的就是应用层了，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次（不要告诉我你没用过udp玩星际）。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据（后面会讲到）以确定传输的目标。第四层是叫数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。再往下则是硬件层次了，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等（这些我们就不用关心了，我们也不做网卡），所以有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构非常有栈的味道，所以某些文章也把tcp/ip协议族称为tcp/ip协议栈。
一些基本的常识
在学习协议之前，我们应该具备一些基本知识。
· 互联网地址(ip地址) 网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。
· 域名系统
域名系统是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。
· RFC
RFC是什么？RFC就是tcp/ip协议的标准文档，在这里我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。 · 端口号(port)
注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。
· 应用编程接口
现在常用的编程接口有socket和TLI。而前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。
TCP/IP详解学习笔记(2)-数据链路层
数据链路层有三个目的：
· 为IP模块发送和 接收IP数据报。 · 为ARP模块发送ARP请求和接收ARP应答。 · 为RARP发送RARP请 求和接收RARP应答 ip大家都听说过。至于ARP和RARP，ARP叫做地址解析协议，是用IP地址换MAC地址的一种协议，而RARP则叫做逆地址解析协议，在tcp/ip协议的后面章节会介绍它们（在局域网里面用ARP协议可以很容易的搞瘫痪网络哦）
数据链路层的协议还是很多的，有我们最常用的以太网（就是平时我们用的网卡）协议，也有不太常见的令牌环，还有FDDI，当然，还有国内现在相当普及的PPP协议（就是adsl宽带），以及一个loopback协议。
联系linux里面的ifconfig -a命令，这个命令通常会得到如下的结果
eth0 Link encap:Ethernet HWaddr 00:01:4A:03:5B:ED
inet addr:192.168.11.2 Bcast:192.168.11.255 Mask:255.255.255.0
inet6 addr: fe80::201:4aff:fe03:5bed/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:2819 errors:0 dropped:0 overruns:0 frame:0
TX packets:76 errors:0 dropped:0 overruns:0 carrier:0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99ae875a203b669c8392e6f02d6a08a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61300b860810c946069b63dc5b6506be/" rel="bookmark">
			System类 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。
由于该类的构造方法是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。
1、成员变量
System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。
例如：
System.out.println(“Test”);
该行代码的作用是将字符串”Test”输出到系统的标准输出设备上，也就是显示在屏幕上。
后续在学习完IO相关的知识以后，可以使用System类中的成员方法改变标准输入流等对应的设备，例如可以将标准输出流输出的信息输出到文件内部，从而形成日志文件等。
2、成员方法
System类中提供了一些系统级的操作方法，这些方法实现的功能分别如下：
a、arraycopy方法
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
该方法的作用是数组拷贝，也就是将一个数组中的内容复制到另外一个数组中的指定位置，由于该方法是native方法，所以性能上比使用循环高效。
使用示例：
int[] a = {1,2,3,4};
int[] b = new int[5];
System.arraycopy(a,1,b,3,2);
该代码的作用是将数组a中，从下标为1开始，复制到数组b从下标3开始的位置，总共复制2个。也就是将a[1]复制给b[3]，将a[2]复制给b[4]，这样经过复制以后数组a中的值不发生变化，而数组b中的值将变成{0,0,0,2,3}。
b、currentTimeMillis方法
public static long currentTimeMillis()
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。例如：
long l = System. currentTimeMillis();
则获得的将是一个长整型的数字，该数字就是以差值表达的当前时间。
使用该方法获得的时间不够直观，但是却很方便时间的计算。例如，计算程序运行需要的时间则可以使用如下的代码：
long start = System. currentTimeMillis();
for(int i = 0;i &lt; 100000000;i++){
int a = 0;
}
long end = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61300b860810c946069b63dc5b6506be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970da0efcbbce1634130c58532d10f54/" rel="bookmark">
			C&#43;&#43;变量与基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++变量与基本类型
---学习笔记
一、 从键盘输入文件结束符
Windows系统：control+Z；
Unix、OS-X、Mac：control+D；
二、 基本内置类型
算数类型表
类型
含义
最小存储空间
取值范围
bool
布尔型
-
char
字符型
8位
-2^7 ~ 2^7-1
wchar_t
宽字符型
16位
short
短整型
16位
-2^15 ~ 2^15-1
int
整型
16位
-2^31 ~ 2^31-1
long
长整型
32位
-2^31 ~ 2^31-1
float
单精度浮点数
6位有效数字
+/- 3.40282e+038
double
双精度浮点数
10位有效数字
+/- 1.79769e+308
long double
扩双精度浮点数
10位有效数字
+/- 1.79769e+308
整数型：
Short、int、long:
Short类型表示半个机器字（word）长，int类型表示一个机器字长，而long类型为一个或两个机器字长（在32位机器中，int类型和long类型通常字长是相同的）。
三、 字面值常量
1、字面值规则
以0（零）开头的字面值整数产量表示八进制；
以0x或0X开头的表示十六进制；
通过在数值后面加L或l指定常量为long类型；
通过在数值后面加U或u指定常量为unsigned类型；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970da0efcbbce1634130c58532d10f54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d815f46a97d934da772474353ba188/" rel="bookmark">
			ruby预先定义变数(Pre-defined Variable)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预先定义变数(Pre-defined Variable) 与异常相关: $! raise设定的异常资讯讯息。 $@ 最近被掷出之异常的追踪资讯阵列。 与最近字样比对动作相关: $&amp; 符合字样之内容。 $` 符合字样之字串左侧的内容。 $' 符合字样之字串右侧的内容。 $+ 符合最后一个字样分组的内容。 $1 to $9 符合第1 到9 个字样分组的内容。 $~ 比对动作相关资讯。 $= The flag for case insensitive, nil by default. $/ The input record separator, newline by default. $\ The output record separator for the print and IO#write. Default is nil. $, The output field separator for the print and Array#join. $; The default separator for String#split.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9d815f46a97d934da772474353ba188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a98e3072c41204981b6b9b8ca10618/" rel="bookmark">
			install snipMate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # install snipMate cd /tmp wget http://www.vim.org/scripts/download_script.php?src_id=10801 -O vim_plugin_snipMate.zip rm -rf vim_plugin_snipMate unzip -d vim_plugin_snipMate vim_plugin_snipMate.zip cp -r vim_plugin_snipMate/* ~/.vim rm -rf vim_plugin_snipMate rm vim_plugin_snipMate.zip # install rails.snippet cd /tmp git clone git://github.com/scrooloose/snipmate-snippets.git snipmate-snippets cd snipmate-snippets &amp;&amp; rake deploy_local cd .. rm -rf snipmate-snippets 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5e47153b3896c59d55ddf7247ed21e/" rel="bookmark">
			vim ruby 格式化代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1）复制 /usr/share/vim/vim72/indent/ruby.vim 至 /usr/share/vim/vimfiles/indent (indent目录可能需要自己创建) 2）在indent目录中修改ruby.vim 最后一行添加 set sw=2 3）在 ~/.vimrc 中添加如下代码 if has("autocmd") filetype indent on endif 4）在ruby文件中，普通模式下使用 gg=G 进行自动格式化，其中： gg : 跳到文件头 = : 使用自动缩进 G : 至文件尾 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2088c9a2dd12821c4307549e6ab6fc12/" rel="bookmark">
			QTextBrowser的一些设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ui-&gt;textBrowser-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//设置垂直滚动条不可见
ui-&gt;textBrowser-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//设置水平滚动条不可见
QTextCursor text_cursor(ui-&gt;textBrowser-&gt;textCursor());//设置光标的位置
text_cursor.movePosition(QTextCursor::End);
ui-&gt;textBrowser-&gt;setTextCursor(text_cursor); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7636871b751f1f593ccd37401da97be6/" rel="bookmark">
			PLSQL Developer 你用的很方便吗，看看就方便了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、登录后默认自动选中My Objects 默认情况下，PLSQL Developer登录后，Brower里会选择All objects，如果你登录的用户是dba，要展开tables目录，正常情况都需要Wait几秒钟，而选择My Objects后响应速率则是以毫秒计算的。
设置方法： Tools菜单 --&gt; Brower Filters，会打开Brower Folders的定单窗口，把“My Objects”设为默认即可。 Tools菜单－－Brower Folders，中把你经常点的几个目录（比如：Tables Views Seq Functions Procedures）移得靠上一点，并加上颜色区分，这样你的平均寻表时间会大大缩短，试试看。
2、记住密码 这是个有争议的功能，因为记住密码会给带来数据安全的问题。 但假如是开发用的库，密码甚至可以和用户名相同，每次输入密码实在没什么意义，可以考虑让PLSQL Developer记住密码。
设置方法：菜单Tools --&gt; Preferences --&gt; Oracle --&gt; Logon History --&gt; Store With Password
3、双击即显示表数据
鼠标双击表或者视图时的默认响应实在让我感到失望，因为我最关心的是表结构和数据，但是双击后这两件事情都没有发生，也许默认响应是高手们需要的，但对我来说查看数据和表结构是最主要的，其他的我不关心。不过好的是这是可以设置的，你可以给鼠标双击和拖放绑定需要的事件，比如：双击编辑数据，拖放显示表结构，Yeah！
设置方法：菜单Tools --&gt; Preferences --&gt; Browser，在右侧，为不同的Object Type绑定双击和拖放操作。
4、SQL语句字符全部大写
自认为这是个好习惯，信息系统的核心是数据库，系统出问题时最先要查的就是SQL语句，怎样在浩瀚的日志中快速找到那条SQL语句是件比较痛苦的事情。 SQL语句全部大写并不能彻底解决这一问题，但在一堆代码中间找一行全部大写的字符相对容易些，你的眼睛会感谢你。 设置方法：菜单Tools --&gt; Preferences --&gt; Editor --&gt; Keyword Case --&gt; Uppercase
5、特殊Copy 在SQL Window里写好的SQL语句通常需要放到Java或者别的语言内，就需要转成字符串并上加上相应的连字符，这一个事不需要再重复做了，在写好的SQL上点右键，使用特殊Copy即OK！
设置方法：鼠标右键 --&gt; Special Copy
6、自定义快捷键 PLSQL Developer里预留了很多键让用户自定义，这是件很Hight的事情。不像霸道的Word，基本上所有的键都已预定义了功能，修改起来很是头疼。 通常情况下，打开PLSQL Developer后，最经常干的事就是打开SQL Window和Command Window，就给这两个操作定义了快捷键，ALT+S和ALT+ C，这样拿鼠标点三下的事情只需要按一下键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7636871b751f1f593ccd37401da97be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3d200384eed23c7d3b008204e3d284/" rel="bookmark">
			addEventListener第二个参数的handleEvent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天无意中看到一篇老外的文章，文章提到了addEventListener第二个参数可以传入object，并且对象中handleEvent为事件处理函数。例如下面的javascript代码：
var obj = { handleEvent: function() { alert('body clicked'); } }; document.body.addEventListener('click',obj,false); 测试发现这段代码在IE9+，chrome，FF，opera等浏览器是正确的（测试范围可能不够宽），而且可以成功的绑定click事件。在Qwrap群里一问才知道是DOM2中接口，很有意思的一个发现，@貘大大 也发微博说自己先入为主了，我相信很多人跟@貘大大 一样都先入为主了。
addEventListener的handleEvent应用 发现了这个“新大陆”有什么用法呢？哈哈~首先想到的是对象引用。看下面的javascript代码：
&lt;script type="text/javascript"&gt; var obj = { handleEvent: function() { alert('body clicked'); } }; document.body.addEventListener('click',obj,false); function fn2(){ obj.handleEvent = function(){ alert('fn2'); }; } &lt;/script&gt; &lt;button οnclick="fn2();"&gt;change&lt;/button&gt; 因为对象的引用关系，点击下button就可以切换绑定事件的处理函数，而不需要remove之前的事件，然后重新绑定一个新的处理函数。
如果你觉得这个不够炫，那么下面的javascript代码可能就更有吸引力了哦~ var obj2 = { addEvent:function(el){ el.addEventListener('click',this,false); }, handleEvent:function(e){ alert(e.target); } }; obj2.addEvent(document.body); addEventListener handleEvent缺点 显而易见，IE6~IE8不能使用……可是如果是高级浏览器还是不错的功能哦~
扩展阅读 http://peter.michaux.ca/articles/our-backwards-dom-event-libraries
http://ajaxian.com/archives/an-alternative-way-to-addeventlistener
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f14b01af45f5746e43a14c2568d8cd0/" rel="bookmark">
			python 简单的Http服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
''' Created on 2012-3-13 @author: Administrator ''' #!/usr/bin/env python from os import curdir,sep from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer class MyHandler(BaseHTTPRequestHandler): def do_GET(self): try: f=open(curdir+sep+self.path) self.send_response(200) self.send_header('Content-type','text/html') self.end_headers() self.wfile.write(f.read()) f.close() except IOError: self.send_error(404, 'File Not Found: %s' % self.path) def main(): try: server = HTTPServer(('',80),MyHandler) print 'welcome to the ,machine...', print 'Press ^C once or twice to quit' server.serve_forever() except KeyboardInterrupt: print '^C received,shutting down server' server.socket.close() if __name__=='__main__': main() 运行： welcome to the ,machine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f14b01af45f5746e43a14c2568d8cd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad8c557ae34d67c7ad3ccdbf7e94e4c/" rel="bookmark">
			对于 join, 如果不写 left ,inner ,right ，默认是什么联接呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认是 inner join #1. select * from a join b on a.id = b.id #2. select * from a inner join b on a.id = b.id #3. select * from a, b where a.id = b.id 上面的三个是相等的. #4.剩下的join类型有: left join right join cross join full join #5.2005新加 cross apply outer apply SQL Server 2005 新增 cross apply 和 outer apply 联接语句，增加这两个东东有啥作用呢？ 我们知道有个 SQL Server 2000 中有个 cross join 是用于交叉联接的。实际上增加 cross apply 和 outer apply 是用于交叉联接表值函数（返回表结果集的函数）的， 更重要的是这个函数的参数是另一个表中的字段。这个解释可能有些含混不请，请看下面的例子： -- 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad8c557ae34d67c7ad3ccdbf7e94e4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cde07c20cfebf5e6510efbfa845604e/" rel="bookmark">
			用wmi连接远程服务器时提示：“RPC 服务器不可用。 (异常来自 HRESULT:0x800706BA)”的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在用wmi写dns解析的程序，在本机测试时好的，但是连接远程服务器时一直提示“RPC 服务器不可用。 (异常来自 HRESULT:0x800706BA)”，开始怀疑相关服务没启动，检查后发现服务已经启动且状态正常。关闭服务器上的防火墙测试，程序运行正常，开启防火墙就会报上面的错误，确定是防火墙阻止了远程的连接，在网上找了些资料，最终找到一条解决方法：使用命令：netsh firewall set service RemoteAdmin 使防火墙允许远程的登录，开启防火墙，测试程序运行正常。
原文链接： http://blog.csdn.net/vince6799/article/details/4312819 转载于:https://my.oschina.net/chen106106/blog/45837
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc92b461e2144c854bd5ac7eb3f7f0b/" rel="bookmark">
			Qt4中的QButtonGroup类使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用惯了qt3的朋友在使用qt4的时候肯定会有些不适应，包括构建界面，一些类的使用上，都有一些区别，总得来说Qt4在编程方式上设计的更加合理了，因为它把界面代码和操作代码完全的“隔离”开了，这样就避免了我们在后期修改界面然后编译的时候会重写操作代码带来的尴尬局面了。qt4除了在界面设置上做了优化，还对一些类做了精简。比如原来Qt3上面的QButtonGroup类，在qt4的designer上面就没有表现出来。只是保留了原来qt3的ButtonGroup。是不是qt4上面就没有QButtonGroup类了呢，当然不是了。在qt4的assistant上面介绍QButtonGroup时说到：“QButtonGroup provides an abstract container into which button widgets can be placed. It does not provide a visual representation of this container (see QGroupBox for a container widget), but instead manages the states of each of the buttons in the group”。其中提到QButtonGroup 提供的是一个放置按键控件的虚拟容器，但它不是个可视的容器。意思就是QButtonGroup 在qt4中变成了一个抽象的类。但是还可以像以前那样管理里面的按键。用法如下：
首先就是要先声明一个QButtonGroup类的对象：QButtonGroup *buttonGroup;
接着在初始化或者构造函数里面给这个指针对象分配空间：buttonGroup = new QButtonGroup;
然后就可以用addButton（）函数把想要放置的按键添加进去：
buttonGroup-&gt;addButton( ui.pushButton0, 0 ); buttonGroup-&gt;addButton( ui.pushButton1, 1 ); buttonGroup-&gt;addButton( ui.pushButton2, 2 ); buttonGroup-&gt;addButton( ui.pushButton3, 3 ); buttonGroup-&gt;addButton( ui.pushButton4, 4 ); buttonGroup-&gt;addButton( ui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbc92b461e2144c854bd5ac7eb3f7f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab2a22b07c68dc3913eaa830f7239cdd/" rel="bookmark">
			QLabel上显示图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pix已经在头文件中声明了
void Widget::paintEvent(QPaintEvent *)
{
update（）；
pix=QPixmap("E:\QTpro\farmer\1.png");
ui-&gt;label-&gt;setPixmap(pix);
ui-&gt;label-&gt;show();
}
只需要在你Widget的构造函数中放如下一条语句( 假定你没贴出的部分不存在其他问题)
ui-&gt;label-&gt;setPixmap(QPixmap("E:\\QTpro\\farmer\\1.png"));
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8677639539d96bd522510dd28df7dfdf/" rel="bookmark">
			Qt 窗体布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		布局相关对象及简介 窗体上的所有的控件必须有一个合适的尺寸和位置。Qt提供了一些类负责排列窗体上的控件，主要有：QHBoxLayout，QVBoxLayout，QGridLayout，QStackLayout。（布局管理类）这些类简单易用，无论在代码中还是用Qt Designer开发程序都能用到。
1） 布局类简介
QHBoxLayout：水平布局
QVBoxLayout：垂直布局
QGridLayout： 表格布局
QGridLayout::addWidget()语法
layout-&gt;addWidget(widget, row, column, rowSpan, columnSpan);
参数widget：为插入到这个布局的子控件；
参数（row，column）为控件占据的左上角单元格位置；
参数rowSpan是控件占据的行数，
参数colunmSpan是控件占据的列的个数。
（rowSpan和colunmSpan默认值为1）
Stacked Layouts：分组布局
QStackedLayout类把子控件进行分组或者分页，一次只显示一组或者一页，隐藏其他组或者页上的控件。
使用这些Qt布局管理类的另一个原因是，在程序、系统改变字体，语言或者在不同的平台上运行时，布局管理器能够自动调整窗体里所有控件的大小和尺寸。
其他可进行布局管理的类：这些类的共同特点是提供了更加灵活的布局管理，在一定程度上用户能够控制窗体内控件的大小。
QSplitter，QScrollArea，QMainWindow，QWorkspace（对多文档的支持）
2） 布局管理中结合控件的sizePolicy属性，进行调整
结合控件的SizePolicy属性，来控制布局管理中的控件的尺寸自适应方式。
控件的sizePolicy说明控件在布局管理中的缩放方式。Qt提供的控件都有一个合理的缺省sizePolicy，但是这个缺省值有时不能适合所有的布局，开发人员经常需要改变窗体上的某些控件的sizePolicy。一个QSizePolicy的所有变量对水平方向和垂直方向都适用。下面列举了一些最长用的值：
A. Fixed：控件不能放大或者缩小，控件的大小就是它的sizeHint。
B. Minimum：控件的sizeHint为控件的最小尺寸。控件不能小于这个sizeHint，但是可以
放大。
C. Maximum：控件的sizeHint为控件的最大尺寸，控件不能放大，但是可以缩小到它的最小
的允许尺寸。
D. Preferred：控件的sizeHint是它的sizeHint，但是可以放大或者缩小
E. Expandint：控件可以自行增大或者缩小
注：sizeHint（布局管理中的控件默认尺寸，如果控件不在布局管理中就为无效的值）
1.1.1. 布局管理的三种方式 Qt中有三种方式对窗体上的控件进行布局管理：绝对位置定位（absolute positioning），手工布局（manual layout），布局管理器（layout managers）
1.1.1.1. 绝对位置定位（控件布局是固定位置，没有自适应功能） 例子：
QWidget *pWidget = new QWidget;
QLabel label(pWidget);
label.setText(QObject::tr("姓名："));
label.setGeometry(10,10,20,20);
QLineEdit namedLineEdit("小明",pWidget);
namedLineEdit.setGeometry(35,10,50,20);
QPushButton *btn = new QPushButton(QObject::tr("关闭"),pWidget);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8677639539d96bd522510dd28df7dfdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551e627f3f07f87f9bc6acbd2d28382e/" rel="bookmark">
			silverlight 各种常用应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 背景颜色
这里以按钮为例：
1、设置背景颜色
//通过包装的属性设置按钮的背景颜色
btn_ButtonC.Background　=　new　SolidColorBrush(Colors.Red);
或者 menujbsz.Background = new SolidColorBrush(Color.FromArgb(47,0,255,255));
//　通过依赖性属性的SetValue设置按钮的背景颜色
SolidColorBrush　brush　=　new　SolidColorBrush(Colors.Blue);
btn_ButtonD.SetValue(
Button.BackgroundProperty,　brush);
2、获取背景颜色
//　通过包装的属性获取ButtonB的背景颜色
SolidColorBrush　b_Brush1　=　(SolidColorBrush)　(btn_ButtonB.Background);
txt_Value1.Text　=　b_Brush1.Color.ToString();
//　通过依赖性属性的 GetValue获取ButtonB的背景颜色
SolidColorBrush　b_Brush2　=　(SolidColorBrush)　(btn_ButtonB.GetValue(
Button.BackgroundProperty));
txt_Value2.Text　=　b_Brush2.Color.ToString();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379091422f8839a2fcb18086cf04ec95/" rel="bookmark">
			u盘格式化后数据恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U盘不小心格式化了，里面还有重要的数据，怎么办呢，这时就需要通过软件来恢复内容了，网上tvb数据恢复软件很多，基本都可以实现。今天介绍一下我前几天用过的一款顶尖数据恢复软件吧。
1.下载并安装顶尖数据恢复软件。
2.把U盘与电脑连接。
3.运行顶尖数据恢复软件，然后在软件左侧的列表中选中U盘的盘符，再单击“深度扫描”。
4.稍等一段时间，因为深度扫描要对U盘内所有数据进行深层次分析，所以需要较长时间。
5.漫长的等待后，软件就会自动显示出U盘格式化之前的文件，选中我们要恢复的文件，然后单击“恢复文件”。
6.这时，软件会弹出一个窗口，让你选择恢复文件保存的文件夹，一般来说，按默认的目录保存就好了，单击确定即可完成U盘格式化后的数据恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f8d911f08ca3721674d0e3d53f7908f/" rel="bookmark">
			GtkButton 透明按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int main(int argc, char *argv[]) { GtkWidget *window; GtkWidget *button; GtkWidget *hbox; GtkWidget *eventbox; GdkGC *gc; GdkColormap *colormap; GdkBitmap *window_shape_bitmap; GdkColor black; GdkColor white; gtk_init(&amp;argc, &amp;argv); window = gtk_window_new(GTK_WINDOW_TOPLEVEL); gtk_window_set_title(GTK_WINDOW(window), "圆形窗口测试程序！"); gtk_window_set_default_size(GTK_WINDOW(window), 400, 300); g_signal_connect(G_OBJECT(window), "destroy", G_CALLBACK(gtk_main_quit), NULL); hbox = gtk_hbox_new(FALSE, 10); gtk_container_add(GTK_CONTAINER(window), hbox); gtk_widget_show(hbox); eventbox = gtk_event_box_new(); gtk_box_pack_start_defaults(GTK_BOX(hbox), eventbox); gtk_widget_show(eventbox); button = gtk_button_new_with_label("Hello,World!你好，世界！"); gtk_container_add(GTK_CONTAINER(eventbox), button); gtk_widget_show(button); GtkWidget *button2 = gtk_button_new_with_label("Hello,World!你好，世界！"); gtk_box_pack_start_defaults(GTK_BOX(hbox), button2); gtk_widget_show(button2); gtk_widget_show_all(window); colormap = gdk_colormap_get_system (); gdk_color_black (colormap, &amp; black); gdk_color_white (colormap, &amp; white); window_shape_bitmap = (GdkBitmap *) gdk_pixmap_new (NULL, 400, 300, 1); gc = gdk_gc_new (window_shape_bitmap); gdk_gc_set_foreground (gc, &amp; black); gdk_gc_set_background (gc, &amp; white); gdk_draw_rectangle (window_shape_bitmap, gc, TRUE, 0, 0, 400, 300); gdk_gc_set_foreground (gc, &amp; white); gdk_gc_set_background (gc, &amp; black); gdk_draw_arc(window_shape_bitmap, gc,TRUE, 0, 0, 400, 300, 0, 360*64); gtk_widget_shape_combine_mask(eventbox, window_shape_bitmap, 0, 0); gtk_main(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469e79bceb95aa24836d5b27af0072e5/" rel="bookmark">
			JSTL常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、JSTL中的常用EL函数 由于在jsp页面中显示数据时，常常需要对数据进行处理，因此SUN公司定义了一套函数供开发者使用。下面为一些常用的函数： 要使用EL函数库，必须在页面中导入EL函数库，语法如下： &lt;%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%&gt; 1、fn:toLowerCase函数： 将一个字符串中的所有字符转为小写形式并返回（接收一个字符串参数）。与之对应的是fn:toUpperCase函数。 例如：${fn:toLowerCase("Hello") }结果为："hello"。 2、fn:trim函数： 删除指定字符串的首尾空格，并返回去除空格后的字符串（接收一个字符串参数）。 例如：${fn:trim(" how are you ! ") }结果为："how are you !"。 3、fn:indexOf函数： 检索指定字符［串］在一个字符串中第一次出现的索引值(int)并返回（第一个参数：源字符串；第二个参数：待检索的字符［串］）。如果第一个字符串中包含第二个字符［串］，无论它在第一个字符串出现几次，此函数总是返回第一次出现的索引值；如果第一个字符串不包含第二个字符［串］，则返回-1。如果第二个参数为空字符串，则此函数总是返回0。 例如：${fn:indexOf("Hello! How are you !","o") }结果为：4. 4、fn:contains函数： 检测第一个字符串中是否包含第二字符串（大小写敏感），并返回布尔类型的值（接收两个参数）。如果第二个参数的值为空字符串，则此函数总是返回true。如果第二个参数的值为空字符串，则此函数总是返回true。 fn:containsIgnoreCase函数是忽略大小写的。 例如：${fn:contains("How are you !","how") }结果为：false。 ${fn:containsIgnoreCase("How are you !","how") }结果为：true。 5、fn:startsWith函数： 检测第一个字符串是否以第二个字符串开始，并返回布尔类型的值（接收两参数）。如果第二个参数值为空字符串，则此函数总是返回true。与之对应的是fn:endsWith函数。 例如：${fn:startsWith("How are you !","How") }结果为true。 6、fn:substring函数： 截取一个字符串的子字符串并返回子字符串（三个参数：第一个,源字符串；第二，开始索引值int［包含］；第三个，结束索引值int［不包含］。索引值皆从0开始）。 例如：${fn:substring("Hello! How are you !",3,8) }结果为："lo! H"。 7、fn:substringAfter函数： 截取一个字符串中从指定子字符串第一次出现之后的子字符串,并返回子字符串（两个参数：第一个，源字符串；第二个，指定的子字符串）。与之对应的是fn:substringBefore函数。 例如：${fn:substringAfter("Hello! How are you !","lo") }结果为："lo! How are you !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/469e79bceb95aa24836d5b27af0072e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853c4e6df62a83e4be9d17f19c6e9f49/" rel="bookmark">
			Konig定理：最大匹配==最小顶点覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Konig定理： 二分图的最小顶点覆盖数等于最大匹配数。 证明： 比如最大匹配是M。为了求最少的点让每条边都至少和其中一个点关联。 M个点是足够的。就是说他们覆盖最大匹配的那M条边后，假设有某边e没被覆盖，那么把e加入后会得到一个更大的匹配，出现矛盾。 M个点是必需的。匹配的M条边，由于他们两两无公共点，就是说至少有M个点才能把他们覆盖。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fedf9ee03069d9bd20f06bef050db4d/" rel="bookmark">
			C#抓取需要登录的页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抓取需要登录的页面的内容，原理主要是：先模拟登录，获取到COOKIE，然后接下来的访问，都使用这个COOKIE，就可以访问到需要登录的页面。
理论上，浏览器可以做到的事情，程序应该也可以。
不过，模拟登录，说起来容易，但不同站点有不同的处理方式，复杂程度不同。
1、最简单的，是POST适当的数据，不用验证码
2、象Discuz!系列的，要先访问某一个页面，获得随机码，然后置于POST数据中，才可以登录
3、需要验证码。验证码识别是另外一个课题。
无论如何，POST数据必须的。那么，模拟登录，需要POST哪些数据呢？
其实，需要POST哪些数据，每个站点都有所不同，所以要有一个合适的工具来进行分析。我装的是firefox的扩展控件：HttpFox。利用它，可以很方便的获取登录指定站点时，所需要提交的数据串。
模拟登录的代码是这样的：
//sPostData，待提交的数据串，如何http://www.test.com/login.aspx?user=admin&amp;pwd=123456 public static CookieContainer Login(string url, string sPostData, CookieContainer cc) { CookieContainer container = (cc == null) ? new CookieContainer() : cc; ASCIIEncoding encoding = new ASCIIEncoding(); byte[] data = encoding.GetBytes(sPostData); HttpWebRequest resquest = ResquestInit(url); resquest.Method = "POST"; resquest.ContentLength = data.Length; resquest.CookieContainer = container; Stream newStream = resquest.GetRequestStream(); newStream.Write(data, 0, data.Length); newStream.Close(); try { HttpWebResponse response = (HttpWebResponse)resquest.GetResponse(); response.Cookies = container.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fedf9ee03069d9bd20f06bef050db4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a964a6c823ee504e627fd1c01e818ca/" rel="bookmark">
			关于sqlite3使用top的一些规则总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于sqlite3使用top的一些规则总结 最近需要做一些关于sqlite3里使用像在sqlserver 里top的一些语法，即根据条件显示前几条的数据记录，在sqlite3中没有top这样的语法，查了好多资料终于找到了可以实现相同效果的sqlite3 sql语句，供大家交流： sqlite3 sql是用limit这样的语法来实现的：
例：select * from table where name='Xiao ming' order by id limit 0,5;
意思为查找table表里，字段name为Xiao ming的记录 根据字段id显示0到5条记录；
当然还有需求更为严格的：
例：select * from table where name='Xiao ming' order by date desc,id limit 0,5;
这条语句的意思为根据条件找到的0到5条记录然后根据字段date 去倒序排列；
例：select * from table order by id desc limit 0,5;
意思为根据id 找到0-5条记录并倒序排列：
大家还有什么需求可以贴上来共同探讨！
转载于:https://www.cnblogs.com/weixing/archive/2012/02/04/2338025.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9cb092f7f37fda0dd40fb79c081523/" rel="bookmark">
			算法的博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/v_JULY_v
奥地利符号计算研究所（Research Institute for Symbolic Computation，简称RISC）的Christoph Koutschan博士在自己的页面上发布了一篇文章，提到他做了一个调查，参与者大多数是计算机科学家，他请这些科学家投票选出最重要的算法，以下是这次调查的结果，按照英文名称字母顺序排序。
A* 搜索算法——图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。
集束搜索（又名定向搜索，Beam Search）——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。
二分查找（Binary Search）——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。
分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。
Buchberger算法——一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。
数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。
Diffie-Hellman密钥交换算法——一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。
Dijkstra算法——针对没有负值权重边的有向图，计算其中的单一起点最短算法。
离散微分算法（Discrete differentiation）
动态规划算法（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法
欧几里得算法（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。
期望-最大算法（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。
快速傅里叶变换（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。
梯度下降（Gradient descent）——一种数学上的最优化算法。
哈希算法（Hashing）
堆排序（Heaps）
Karatsuba乘法——需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。
LLL算法（Lenstra-Lenstra-Lovasz lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。
最大流量算法（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。
合并排序（Merge Sort）
牛顿法（Newton's method）——求非线性方程（组）零点的一种重要的迭代法。
Q-learning学习算法——这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。
两次筛法（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。
RANSAC——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。
RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。
Schönhage-Strassen算法——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。
单纯型算法（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。
奇异值分解（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。
求解线性方程组（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9cb092f7f37fda0dd40fb79c081523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94ad3dd0e86144d5eeaf65efff372fed/" rel="bookmark">
			2812的C语言中的.reset段的含义以及其在存储器中的定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如下：
疑问一：仿真调试下载程序或把程序已烧写至FLASH后脱机上电运行程序时，程序是不是必须要执行“从0X3F FFC0处复位→执行0X3F FC00地址处的初始化引导函数(Initboot) →根据GPIO选择引导模式→确定用户程序入口地址→从入口处开始执行用户程序”这一系列过程吗？对于用C语言编程时，通常在复位地址向量处（对于F240而言，复位地址在0X0000地址处？），常需要放置指令：“B _c_int0”来规定初始化入口地址，意即C语言函数“_c_int0”完成的功能就是初始化引导函数(Initboot)的功能吗？但对F2812来说，复位向量地址为0X3F FFC0，处于ROM区，是一次性编程ROM，怎么把_c_int0这个入口地址放在0X3F FFC0处呢？
疑问二：由于引导模式由GPIO引脚状态决定，那对于一个已经设计好的DSP最小系统，引脚状态在硬件上已经固定好了，意即是不是此时只能局限于一种引导模式了？不能同时进行仿真调试和烧写至FLASH内进行硬件调试吗？(因为仿真调试时，用户程序入口地址一般在SARAMH0处，烧写至FLASH内进行允许时，用户程序入口地址在FLASH处。)
解答如下：
1：上电运行时根据MP/MC引脚的状态决定是从片外的3fffc0处读取复位向量或者时从片内的rom的3fffc0处读取复位向量。MC方式下从片内读取，MP方式下从片外读取。
2：一般我们用的是MC方式，即从片内读取复位向量，在片内的rom 3fffc0处有一个地址为3ffc00。
3：复位后处理器从3fffc0处读取3ffc00这个地址，所以程序从3ffc00处开始执行
4：3ffc00处开始的就是initboot过程吧，根据IO管教的状态判断该进入那一种引导方式
5：在SCITXA{即GPIOF4脚}引脚为高电平时就是flash boot方式，此时置PC=3F7FF6
6：在片内flash的3F7FF6和3F7FF7处有一个跳转指令，该跳转指令就是LB _c_int00
7：执行这个跳转指令后程序就开始运行c_int00这个函数了
8：这个函数就是建立一个c程序的运行环境，等建立完c运行环境后c_int00调用main函数
9：main函数开始就是我们自己编写的应用程序了。
以上是2812上电（复位）后运行过程的描述
如果你选择了MP方式，那么3fffc0处的复位向量可以自己设置，因为此时处理器从片外的ZONE7区的ram中读取复位向量的，当然初始化引导过程也可以自己编写。
lhfnjj 2005-12-6 14:29
在第5步中，为选择片内FLASH，则使SCITXA为高电平。如果SCITXA还用作串口通讯，那怎么办？
haomaru 2005-12-7 08:13
SCITXA引脚有内部上拉，所以只要没有强制下拉的话，DSP检测的都是高电平。
对于通讯不影响。
SCITXA不用在外部上拉。不能直接接到高电平上。
我自己理解的是，即 ： .reset段表示跳转到_c_int00处的一个程序段 首先： .reset段区别于处于复位向量3fffc0（即复位指针，即DSP复位时PC所装的地址，在这个地址中存放了初始化BOOT的程序地址3ffc00，其事先已固化在bootrom的程序）
即系统复位以后首先跳转到复位向量3fffc0处，然后从此处跳转到初始化intboot （3ffc00）处，执行完初始化BOOT.并根据GPIOF口选择启动模式，例如选择从FLASH启动，则退出初始化BOOT程序时，程序则会跳到0x3F7FF6处执行，此处距0x3F7FF8（密码设置区）只有两个字的距离，故在此也就只能放一个跳转指令，即跳转到C语言程序入口，即_c_int00处，个人认为当CMD文件将.reset段配置到0x3F7FF6时，起到的作用就是：即在0x3F7FF6处使程序跳转到_c_int00处。
MEMORY
{
PAGE 0 : 。。。
BEGIN : origin = 0x3F7FF6, length = 0x000002 。。。 PAGE 1 : 。。。 } SECTIONS
{
.reset : &gt; BEGIN PAGE = 0 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94ad3dd0e86144d5eeaf65efff372fed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4b7d47e91693d24083d23c48f663c1/" rel="bookmark">
			Ext.core包与Ext详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Ext.core.Element
概述：它是组件和控件的基础，它对一个DOM对象的封装(Document Object Model)
1、如果得到Element
Ext.core.Element.fly(String/HTMLElementel) :Element
Ext.get(Mixedel) : Element
2、Element 相关方法
addClsOnClick(StringclassName) 参数为一个css样式的一个类名 触发的是当点击这个组件的时候变化 AddClsOnOver(StringclassName) 参数与上相同，当鼠标滑过时候触发，滑出时候移除
AddKeyMap(Objectconfig) 传入参数为一个配置的对象 配置的属性是与Ext.util.KeyMap配置一样
AddKeyListener(Number/Array/Object/Stringkey,Function fn,[Object scope]) 参数第一个可以传入键盘上的值
或者一个数组，也可以讹传入一个配置对象，第二个参数为触发函数，第三个作用域
appendChild(String/HTMLElement/Array/Element/CompsiteElementel) 在此组件中追求一个还孩子的组件，参数可为元素对象
createChild(Objectconfig,[HTMLElement insertBefore],[Boolean returnDom]) 参数为一个dom的配置对象
代码实现：
//使用fly方法得到Element对象
vardiv01=Ext.core.Element.fly("div01");
//1.鼠标滑过的时候增加一个样式滑出的时候移除样式
div01.addClsOnOver("divC");
//2.得到el的方法是Ext.get()
varinput01=Ext.get("input01");
//3.定义函数并增加组件的添加注册事件
varfn1=function(){
alert("单机B触发的事件"); };
input01.addKeyMap({
key:Ext.EventObject.B,
ctrl:false,
fn:fn1,
scope:input01
});
input01.addKeyListener({key:Ext.EventObject.X,ctrl:true},function(){
alert("单机Ctrl+X");
},this);
//4.在当前组件中追加一个孩子元素
functioncreateChild(){
varel=document.createElement("h5");
el.appendChild(document.createTextNode("我是被追加的"));
returnel;
};
Ext.get("div02").appendChild(createChild());
//5.创建一个节点并添加到当前组件中
Ext.getBody().createChild({
tag:"li",
id:"item1",
html:"我是第一个节点"
});
二、Ext
主要方法：
1.onReady方法是执行在文件加载完和onload和image加载完之后
2.get()传入id值，它返回的是一个Ext.core.Element对象
3.query(Stringpath,[Node root]) ：返回的是Array
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4b7d47e91693d24083d23c48f663c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf31f9ec1fa1acb0e40f8a5f9f5d7c53/" rel="bookmark">
			android开发年总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从事android开发一年来，在andorid领域突飞猛进。
说说几大收获。
1.andorid基本上就是建立在binder机制上，来实现模块与模块之间的通信。
所谓的service，activity，provider，receiver四大金刚之间的通信都是通过binder进行的。
对客户端来说，binder本身是一个int。
对于服务端来说，binder是一块内存地址。
从客户端的binder转换到服务端的binder的过程是在内核中实现的。
2.android输入输出这一块底层采用的是 管道+共享内存的方式实现进程间的通信。从而将事件从驱动层过度到各个window。
3.android的View这一块采用经典的树状结构。用了一些设计模式，效率较低。这个比较简单。就不说了。opengl本身已经使用了双缓冲。所以双缓冲在android中的概念已经不存在。多级缓冲的效率并不高，所以也就不要再使用了。
4.Surface这一块。一个window对应一个surface。而一个surface仅仅存在于客户端。在服务端叫做layer，layer是通过共享内存的方式实现的，这样就可以达到服务端和客户端的缓冲区共享起来。一共8M。使用那一部分，主要是由offset和size决定。
5.关于特效等的制作都是matrix在作怪。学习矩阵和openGL是做特效的基础课程。不管中间经历了什么。从本质上来说，都是一个二维图形，到一个二维图形的映射。我们肉眼看到的东西始终是二维的。这是本质属性。
所谓的3D，也只是一种视觉欺骗罢了。照相机本身出的图实际上就是3D的。
6.明年准备涉入jni这一块。对于openGL的深入理解是打通android图形的关键所在。egl之类的库也是很重要的东东。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550dd51755d027271d871b778a3c74d1/" rel="bookmark">
			基于DTS的软件测试管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DTS(Defect Trace System)在软件测试中缺陷跟踪管理系统主要完成对缺陷报告的记录、分析和状态更新等管理。一个完善的缺陷跟踪管理系统对于测试的成功实施是非常重要的。 [1] 【摘要】通过对软件测试管理的必要性和组成结构的分析，提出了三层架构的支持多角色协同测试的网络解决方案，设计了基于ASP.NET的软件缺陷跟踪系统。该系统有助于软件开发及测试活动的组织、管理和评价，提高软件开发效率及其质量。
三层架构(3-tier application) 通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。
软件测试是软件质量保证的关键步骤。美国质量保证研究所对软件测试的研究结果表明：越早发现软件中存在的问题，开发费用就越低；在编码后修改软件缺陷的成本是编码前的10倍，在产品交付后修改软件缺陷的成本是交付前的10倍；软件质量越高，软件发布后的维护费用越低。另外，根据对国际著名IT企业的统计，它们的软件测试费用占整个软件工程所有研发费用的50% 以上。
经过近几年激烈国际信息产业市场竞争的磨练，中国软件企业积累了一定的经验，具备了一定抵抗冲击的能力，然而与发达国家相比仍有很大的差距。中国软件企业必须通过提高软件产品的质量和自身的管理水平来提高自身竞争力，尽快与国际化标准接轨以适应国际市场需求。首先，要在认识上重视软件测试，软件项目的如期完成不仅取决于开发人员，更取决于测试人员；其次，要建立有效、规范的软件测试管理体系，改变管理上的随意、简单与紊乱；另外，开发与使用自动化工具，在软件测试时采用软件测试管理系统，提高软件测试管理水平与效率。
1、软件测试管理概述
软件测试管理是一种活动，可以对各阶段的测试计划、测试用例、测试流程、测试文档等进行跟踪、管理并记录其结果。采用软件测试管理可以为软件开发提供一个多阶段、逐步递进的实施方案。通过对测试的管理，可以用有限的时间和成本完成软件开发，确保产品的质量，进一步提高计算机软件在市场上的竞争能力。
一般采用过程方法和系统方法来进行软件测试管理，构建完善的管理体系，对软件测试中的各个过程或活动加以识别和管理，以实现设定的总体目标（即在设定的约束条件下，尽可能发现和排除软件缺陷）。软件测试管理主要包括以下5个相互关联、相互作用的过程或活动：
1）测试规划：确定各测试阶段的目标和策略。这个过程将输出测试计划，明确要完成的测试活动，评估完成活动所需要的时间和资源，设计测试组织和岗位职权，进行活动安排和资源分配，安排跟踪和控制测试过程的活动。 测试规划与软件开发活动同步进行。对于测试计划的修订部分，需要进行重新评审。
2）测试设计：根据测试计划设计测试方案。测试设计过程输出的是各测试阶段使用的测试用例。测试设计也与软件开发活动同步进行，其结果可以作为各阶段测试计划的附件提交评审。测试设计的另一项内容是回归测试设计，即确定回归测试的用例集。对于测试用例的修订部分，也要求进行重新评审。
3）测试实施：使用测试用例运行程序，将获得的运行结果与预期结果进行比较和分析，记录、跟踪和管理软件缺陷，最终得到测试报告。
4）配置管理：测试配置管理是软件配置管理的子集，作用于测试的各个阶段。其管理对象包括测试计划、测试方案（用例）、测试版本、测试工具及环境、测试结果等。
5）资源管理：包括对人力资源和工作场所，以及相关设施和技术支持的管理。如果建立了测试实验室，还存在其他的管理问题。
软件测试管理就是采用适宜的方法对上述过程及结果进行监视，并在适合时进行测量，以保证上述过程的有效性。如果没有实现预定的结果，则应进行适当的调整或纠正。此外，软件测试与软件修改是相互关联、相互作用的。软件测试的输出（软件缺陷报告）是软件修改的输入。反过来，软件修改的输出（新的测试版本）又成为软件测试的输入。
2、测试管理系统的架构
由于测试是一个复杂的过程，而且需要反复不断地对被测试应用施加测试，单纯通过手工的方式已经不能在交付时间上及测试质量上给予保证。所以，开发使用软件测试管理系统以实现测试过程及其管理的自动化是软件测试必然的发展方向。
由于测试管理包含了测试的规划、设计、实施、管理等多个过程，参与测试活动的角色又有多种（主要有项目经理、开发人员和测试人员等），所以我们采用图1所示的3 层架构来设计测试管理系统，以支持多角色协同测试。第1 层是表示层，与用户进行交互，负责处理客户请求，根据请求调用Web 服务，然后返回结果；第2层是业务逻辑层，又称为中间层，将表示层和数据库层紧密联系到一起，业务逻辑层不但支持客户端读取和存储数据，而且在业务方面也对表示层起到支持作用；第3 层是数据库服务器，包含各类数据库，如测试用例数据库、项目管理数据库等。其中客户端既可以是浏览器，也可以是Windows 应用程序或者其他应用程序，Web客户端由ASP.NET的窗体完成，服务器端业务逻辑由ASP.NET Web 服务程序完成。
图1. 支持协同测试的测试管理系统架构图
3、缺陷跟踪子系统的设计
软件缺陷是指软件的实际运行现象与软件需求不一致或错误的现象。软件缺陷跟踪系统（Defect Tracking System， DTS）是软件测试管理系统的核心部分，对软件缺陷处理过程最基本的要求包括以下几个方面：1）整个处理过程应该是闭合的，即确保每一个被发现的问题在过程中都能得到解决，在整个过程中追踪缺陷的状态，问题记录在整个合同期内都得到维护；2）每一个被发现的软件缺陷都应该按类别和优先级进行分类；3）对软件缺陷的改正应该进行验证，以确保问题确实被解决、不利的影响已经被消除，并且解决该问题所引起的变化不会带来新的问题。
根据1988 年公布的美国国防部软件开发标准 [DOD - STD - 2167A ][5]和 1995 年公布的软件开发与文档标准 [MIL - STD - 498][6]，在缺陷跟踪子系统中，将软件缺陷生命周期划分为6个生命状态：open（打开）、working（修改）、verify（验证）、cancel（取消）、close（关闭）和defer（延迟），能详细记录、跟踪和管理每个软件缺陷的生命过程，直至排除这个缺陷。还为软件缺陷设定了严重级别、处理优先级、缺陷类型等属性，可自动分清软件缺陷的轻重缓急，并能提供相关的分析和统计功能。
在此基础上我们建立了图2所示的软件缺陷处理过程模型，根据有效性、完备性和正交性等原则，确定软件缺陷的状态及状态之间的转换关系，然后确定状态同角色、活动、信息之间的关系。软件缺陷处理过程模型的建立提高了对软件缺陷处理过程的理解，并为软件测试管理系统的实现打下了基础。
图2. 软件缺陷的处理过程模型
软件缺陷处理过程模型在设计时体现了以下的思想：1）软件缺陷状态在整个软件缺陷处理过程中的核心地位。软件缺陷当前所处的状态决定了目前应负责任的角色、下一步应该进行的活动。在软件缺陷状态发生变化时自动通知下一个应负责的角色；2）角色是一定权利和义务的体现。不同级别的用户对同一个软件缺陷拥有不同的处理权限。在具体实现时，对于软件缺陷处理过程模型中的每个活动，都提供相应的命令来支持；对于每个级别的用户，只能实施同相应角色符合的命令；状态转换时，以MAIL等形式通知下一个应负责的角色。
4、基于DTS的软件测试管理体系
组织结构决定运行机制，软件生产组织结构在一定程度上决定了软件测试能否有效和高效进行。因此，要提高软件测试效率和软件开发质量，除了要建立独立于软件开发的软件测试队伍之外，还必须有一个合理的组织结构和运行机制，从而形成完善的软件测试管理体系。
合理的软件生产组织结构应该如图3所示：以项目为中心，为每个项目设一个项目经理，负责整合开发部、测试部以及市场部中的人力资源和协调各部门软件生产、销售活动，形成“三位一体”的组织结构。这个组织结构包含了多种不同的身份：项目经理、部门经理、软件设计师及程序员、软件测试师及测试员、市场销售人员及技术支持人员等。这个结构的最大好处就是有效的制衡了软件开发和软件测试，协调了软件生产与市场销售，使得测试、开发和销售都能高效的开展。
图3. 合理的软件生产组织结构
有了合理的组织结构，软件项目团队的全体成员就能以软件缺陷跟踪系统（DTS）为工作的参照物，形成良好的工作流程和运行机制，构建如图4所示的软件测试管理体系：测试人员（包括软件测试师和测试员）向缺陷跟踪系统报告新bug，在新版本上执行回归测试验证bug是否正确修改；开发人员（包括软件设计师和程序员）每天浏览属于自己需要修改的bug，修正bug后及时更新bug的状态；项目经理及部门经理根据缺陷跟踪系统的bug分布信息，跟踪和控制软件开发过程；市场销售人员和技术支持人员根据缺陷跟踪系统的bug状况，估计软件的发布期限。
图4. 缺陷跟踪系统驱动的软件测试管理体系
5、小结
本文针对国内软件企业对软件测试及其管理的需求，提出了三层架构的支持多角色协同测试的网络解决方案，设计了基于ASP.NET技术的软件缺陷跟踪系统，并以此为基础建立了完善的软件测试管理体系。实践表明，该测试管理体系对于提高软件开发效率及其质量具有良好的效果。
转载于:https://www.cnblogs.com/qileilove/archive/2012/01/10/2318151.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db24cf869c0f1a8b07866d85ea4e6314/" rel="bookmark">
			android自定义Dialog，仿QQ手机浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前一直不大喜欢android系统的对话框，这两天上班比较空闲，就试着模仿一下QQ浏览器的对话框。 本来以前想写个类继承Dialog，但受水平限制，没有实现。主要代码如下：
public class CustomAlertDialog { private AlertDialog dialog; private LayoutInflater inflater; private Button leftBtn, midBtn, rightBtn; private LinearLayout titleLay, bottomLay; private ScrollView contentLay; private TextView title, contentMsg; private Context context; private View dialogView; public CustomAlertDialog(Context context) { this.context = context; inflater = LayoutInflater.from(context); dialogView = inflater.inflate(R.layout.dialog, null); bottomLay = (LinearLayout) dialogView.findViewById(R.id.dialog_btns); contentLay = (ScrollView) dialogView.findViewById(R.id.dialog_content_lay); dialog = new AlertDialog.Builder(context).create(); } public void show() { dialog.show(); dialog.getWindow().setContentView(dialogView); } public void dismiss() { if (dialog !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db24cf869c0f1a8b07866d85ea4e6314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781acaa641f9291c6abb52633e2db189/" rel="bookmark">
			mysql 左连接、右连接和内连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以MySql为例。在MySQL数据库中建立两张数据表，并分别插入一些数据。
&lt;
脚本如下：
drop table table1;
CREATE TABLE`andrew`.`table1`
(
`name` VARCHAR(32)NOT NULL,
`city` VARCHAR(32)NOT NULL
)
ENGINE = MyISAM;
insert intoTABLE1(name, city) values ('Person A', 'BJ');
insert intoTABLE1(name, city) values ('Person B', 'BJ');
insert intoTABLE1(name, city) values ('Person C', 'SH');
insert intoTABLE1(name, city) values ('Person D', 'SZ');
commit;
drop table table2;
CREATE TABLE`andrew`.`table2`
(
`name` VARCHAR(32)NOT NULL,
`city` VARCHAR(32)NOT NULL
)
ENGINE = MyISAM;
insert intoTABLE2(name, city) values ('Person W', 'BJ');
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781acaa641f9291c6abb52633e2db189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f92b50742fa8a6edb700104a825975/" rel="bookmark">
			C中double类型数据的输入和输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		double a;
scanf("%f",&amp;a); //应用scanf("%lf",&amp;a);
执行上面语句时，发现double类型的输入不能使用%f进行输入，得用%lf才能正常得到a的值。
而在输出double类型时却可以用%f，这是因为printf("%f",a);在执行时C自动将float型的参数转换成double型。
故double型的输入输出形式如下：
double a;
scanf("%lf",&amp;a);
printf("%f",a);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ccbdf8debc400198fed52bcd96bd397/" rel="bookmark">
			java web 开发入门心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从事Java Web开发这一段时间来，对Java 面向对象的思想和MVC开发模式可以说已经熟悉了。我当前参与的项目使用的框架是Spring、SpringMVC、Hibernate。作为刚刚参加工作的入门者，我下面谈自己的几点心得，还恳请前辈指正。
想必流行的做法都是把后台部分的代码分为entity（或domain）、dao、service、web几个层吧。
实体类
实体类就是对现实世界事物的建模，往往正是跟现实中的“实体”相对应，但也有些不是，只是为了将数据封装起来便于传输和表现（这一点，在做客户端软件时尤其如此，毕竟内存是相当有限的，拉出的数据最好全部用于表现，多余就意味着浪费内存）。
我有个观点：连接处是难点。Java代码需要连接的有两个：跟前台的页面，即视图相连接，这个靠web层；另外，就是跟数据库相连接，这个靠的是entity层。而这两个层相比，实体类又是更重要的，它就像是一幢大楼的地基。对实体类的设计，我感觉是一个项目的关键。要想设计好实体类，简单的说，需要远见，具体地说，需要不仅仅理清项目业务逻辑，还需要有较丰富的开发经验。因为理清业务逻辑，可能只是能穷举出所需要的实体以及它们直观的属性，但有时那些实体还需要拆分合并（以前参与过一个求职招聘网的项目，在建表时是把求职和招聘信息分开建的表，但到后来发现，在用户登录后需要呈现的是所有的信息，这下带来了代码的不小改动），并且有些属性虽然不那么直观，但却是有必要的，常见的就是一些flag、status之类的属性，这就需要在设计时就最好能预见到，不然在开发过程经常修改数据库中的表结构，也会开发进度。
综上，俗话说得好，磨刀不误砍柴工，实体类设计好了，往上走，将势如破竹。
另外，公司的做法是在实体类中建一个BaseObject作为一个项目中所有实体类的父类，定义几个都要用到的成员变量，如id,version，createTime。这样做，一方面减少了重复的代码，另一方面，在设计后续的BaseDao时也很方便。
数据访问对象DAO
dao中的方法就是对数据库中的数据进行“单纯”的增删改查（之所以说单纯，就是因为它并没不牵涉业务），其中较复杂多变的是查找，这一点和sql语句是对应的。
对于DAO层，我们通常的做法也是创建一个父类，即BaseDao, 并且使用Java 的泛型将BaseObject作为它要操作的数据类型，这样，在不同实体类对应的DAO去继承BaseDao时，就可以用各自的实体去替换BaseOject了（假如entity层没有采用继承BaseObject的模式，那么可以用在BaseDao中可以用Object作占位符）。
这个BaseDao还可以继承框架中已有的Dao,如HibernateDaoSupport，当然也可以自己写。
在做求职招聘网时，我们就是自己写的，形如：public class BaseDao&lt;T, PK extends Serializable&gt; ，特别注意：该类不由Spring管理。这里边有两个难点：①如何获取Hibernate中的session对象？可以采用注释注入SessionFactory，通过调用它的getCurrentSession方法获取Session对象。②在编写查询方法时需要用到继承BaseDao的dao类所对应的实体类的类型，如何动态地获取呢？比如当UserDao继承BaseDao时，在BaseDao中如何动态地获知相应的实体类是User类型呢？这里边用到了反射和构造方法，由于子类在创建时会驱动BaseDao的创建，所以在BaseDao中的构造方法中使用this关键字，和反射中的方法获取子类泛型参数中第一个参数的类型，即为所需的entityClass
业务逻辑层Service层
业务逻辑层的方法就是对信息进行加工处理用的，业务逻辑层，顾名思义，就是根据业务对数据进行处理，主要通过调用dao中的方法实现（看了一个帖子，链接地址为：http://www.iteye.com/topic/35907，说Service层的方法也可以互相调用）。业务层中的类往往都用事务管理，因为一个业务往往就是一个事务，比如银行的转账业务，既要从一方扣钱，又要给另一方加钱，在扣钱和加钱的间隙出问题了，事务就要回滚，不然是不合情理的。
在开发过程中我发现，大家的service层的方法，都和dao层差不多，甚至名字很多都一样，反倒是把真正的业务处理都放在了web层。这样做，我认为是很不科学的，web层是没有事务控制的，一旦发生异常，就可能产生脏数据。因而还是应该把业务放在本来属于它的位置上来。
发布层Web层
这又是一个连接处，它联系的是http请求/响应和Java模型，是开发中的关键点。我现在的做法通常是在有了实体类以后，从web层着手向下开发，比较喜欢点击那个不存在的方法提示出的“creat method in xxxService/xxxDao”了，这样开发非常有动力，好像打一场围歼战，最后把敌人都消灭在了Dao层。 web层通常是要调用Service中的方法完成的，它起到的作用是就是调度。与Service相比，web层该是瘦子，Service该是胖子。我的一点心得是：在web层中的一个方法中不宜调用多个涉及到更新数据的Service，但可以调用多个只进行数据查询的Service方法。这样做，我想着也是怕发生异常时，同一个方法中某个事务已经提交，而另外一个事务却没有提交的情况出现。但是，如果确实在Service层中按照业务定义了方法，这种情况按说也不会出现，
其他想法
有一种声音：说目前的Java Web开发是很没技术含量的，因为有成熟的框架。这样的说法对我是挺刺激的，毕竟，自己堂堂一个本科生，心底里总还是想做点有技术含量的工作，我有个愿望，想成为一名软硬兼通的工程师，大概也是基于这样的观念吧——技术含量。
我仿佛并没有考虑自己是否感兴趣，只是觉得只要努力，便能做到。道理我也懂，先把目前的工作搞好，既然从事的是软件，就老老实实把软件先做好。别人说的话，听听是对的，但还要想一想。我觉得，能把一个庞大的系统分析设计出来，能解决这中间出现一系列问题，其实并不容易。有句话说得好，做好平凡事，你就不平凡。
最近的想法是如果觉得自己能胜任工作，那就换一个角度想一想，比如自己不依靠一些现成的东西（比如框架），也可以把自己想象成项目经理，看看自己是否有能力解决掉所有项目经理要处理的事情，如果不能，那就还是去练内功吧。
找一些有难度的事情给自己点挑战，要保证自己一直在进步，一直在成长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355c4b796106aacf21a339450b88f04b/" rel="bookmark">
			C语言中对scanf输入非法字符的检查和处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在C中scanf()函数返回成功读入的变量的个数。如果它没有读取任何项目（输入非法字符，例如：希望得到数字，而用户却输入的是字符），scanf()返回值为0.当检测到“文件结尾”是，会返回EOF(EOF是在文件stdio.h中定义的特殊值，一般，#define指令把EOF的值定义为-1).
利用scanf()以上的性质，可对输入值进行检验，代码如下：
#include&lt;stdio.h&gt; int main(void) { int num; int status; printf("input the value of num:"); status = scanf("%d",&amp;num); if(status ==0) { printf("enter error"); fflush(stdin);//清除输入缓冲区的错误数据 } else if(status == EOF) { printf("Input failure occurs!\n"); } else printf("\nnum = %d\n",num); fflush(stdin); getchar(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d5492252ee1a6c6b9be94d4795ab2f/" rel="bookmark">
			linux用tar解压文件无法 open: 没有该文件或目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux下，我解压一个/home/user/*.tgz的文件时，使用tar -zxvf *.tgz，刚开始一切顺利，过了一会出现“无法 open: 没有该文件或目录”，且一直出现不断。
分现原因如下：
（1）是否因帐号权限不足造成的,建议用sudo执行
（2）原tar包损坏
（3）可能磁盘空间不足，df /home -h 查看/home是否已满
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05de2e34144430cb1558c603087d0d43/" rel="bookmark">
			Prism学习笔记-模块之间通信的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发大型复杂系统时，我们通常会按功能将系统分成很多模块，这样模块就可以独立的并行开发、测试、部署、修改。使用Prism框架设计表现层时，我们也会遵循这个原则，按功能相关性将界面划分为多个模块，每个模块又包含多个Region。这就需要解决模块之间、Region之间经常需要进行通信的问题，Prism提供了以下几种方式：
1、聚合事件（Event aggregation）
使用方式，先在一个公共模块中定义一个事件MyEvent ，传输数据为MyEntity。
public class MyEvent : CompositePresentationEvent&lt;MyEntity&gt;
{
}
然后在需要等待处理事件的模块中订阅事件，如下所示：
private IEventAggregator eventAggregator;
eventAggregator = (IEventAggregator)ServiceLocator.Current.GetService(typeof(IEventAggregator));
eventAggregator.GetEvent&lt;MyEvent&gt;().Subscribe(MyEventHandler, true);
public void MyEventHandler(MyEntity myEntity)
{
}
eventAggregator 相当于一个全局的集合，保存了所有订阅的事件。
在发起通信的模块中发布事件，如下所示：
eventAggregator.GetEvent&lt;CreatePlanEvent&gt;().Publish(new MyEntity());
2、全局命令
使用方式，在公共模块中定义一个全局命令类：
public static class GlobalCommands
{
public static CompositeCommand OpenCommand = new CompositeCommand();
}
在使用该命令的View中：
&lt;Button Command="{x:Static s:GlobalCommands.OpenCommand }" &gt;
在响应该命令的模块中：
public ICommand OpenCommand { get; set; }
OpenCommand = new RelayCommand(param =&gt; this.Open(param));
GlobalCommands.OpenCommand.RegisterCommand(OpenCommand);
不用绑定时可以这样执行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05de2e34144430cb1558c603087d0d43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42490406b6acc8585dc09694063213f/" rel="bookmark">
			JSTL函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSTL函数
为了简化在JSP页面操作字符串，JSTL中提供了一套EL自定义函数，这些函数包含了JSP页面制作者经常要用到的字符串操作。#￥例如，fn:toLowerCase将字符串中的字符变为小写，fn:indexOf返回一个指定字符串在另一个字符串中第一次出现的索引位置。
JSTL中提供的EL自定义函数必须在EL表达式中使用，例如，${fn:toUpperCase("www.it315.org")}。
8.7.1 fn:toLowerCase函数 fn:toLowerCase函数将一个字符串中包含的所有字符转换为小写形式，并返回转换后的字符串，它接收一个字符串类型的参数。
fn:toLowerCase函数的应用举例：
l fn:toLowerCase("Www.IT315.org") 的返回值为字符串“www.it315.org”
l fn:toLowerCase("")的返回值为空字符串
8.7.2 fn:toUpperCase函数 fn:toUpperCase函数将一个字符串中包含的所有字符转换为大写形式，并返回转换后的字符串，它接收一个字符串类型的参数。
fn:toUpperCase函数的应用举例：
l fn:toUpperCase("Www.IT315.org") 的返回值为字符串“WWW.IT315.ORG”
l fn:toUpperCase("")的返回值为空字符串
8.7.3 fn:trim函数 fn:trim函数删除一个字符串的首尾的空格，并返回删除空格后的结果字符串，它接收一个字符串类型的参数。需要注意的是，fn:trim函数不能删除字符串中间位置的空格。
例如，fn:trim(" www.it 315.org ") 的返回值为字符串“www.it 315.org”。
8.7.4 fn:escapeXml函数 fn:escapeXml函数将字符串中的需要进行转义的HTML特殊字符按表8.2进行HTML编码转换，并返回转换后的字符串，这样就可以在浏览器中显示出HTML特殊字符。fn:escapeXml函数接收一个字符串类型的参数。
例如，运行包含如下代码的JSP文件后浏览器将跳转到“http://www.it315.org”页面，这是因为这些代码被浏览器作为HTML标签解释执行：
&lt;meta http-equiv="refresh" content="0;url=http://www.it315.org"/&gt;
如果用fn:escapeXml函数处理上面的代码，运行JSP文件后就在浏览器窗口输出这行代码，例程8-54是使用fn:escapeXml函数处理上面的代码的例子程序。
例程8-54 fn_escapeXml.jsp
&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %&gt;
${fn:escapeXml('&lt;meta http-equiv="refresh" content="0;url=http://www.it315.org"/&gt;')}
fn_escapeXml.jsp页面的运行结果如图8.46所示。
图8.46
8.7.5 fn:length函数 fn:length函数用于返回一个集合或数组对象中包含的元素的个数，或返回一个字符串中包含的字符的个数，返回值为int类型。fn:length函数接收一个参数，这个参数可以是&lt;c:forEach&gt;标签的items属性支持的任何类型，包括任意类型的数组、java.util.Collection、java.util.Iterator、java.util.Enumeration、java.util.Map等类的实例对象和字符串。
如果fn:length函数的参数为null或者是元素个数为0的集合或数组对象，则函数返回0；如果参数是空字符串，则函数返回0。例程8-55是使用fn:length函数的实例程序。
例程8-55 fn_length.jsp
&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %&gt;
&lt;%@ page contentType="text/html;charset=gb2312" %&gt;
&lt;%@ page import="java.util.*, org.it315.UserBean" %&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42490406b6acc8585dc09694063213f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7132de3362dba32aa1b476f06792ba83/" rel="bookmark">
			查看80端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo netstat -anpt | grep 80 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/858491e2f530abe92e102b12d44ad84e/" rel="bookmark">
			用异或来交换两个变量效率分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用异或来交换变量是错误的
陈硕 (giantchen_AT_gmail)
Blog.csdn.net/Solstice
翻转一个字符串，例如把 "12345" 变成 "54321"，这是一个最简单的不过的编码任务，即便是 C 语言初学者的也能毫不费力地写出类似如下的代码：
// 版本一，用中间变量交换两个数，好代码
void reverse_by_swap(char* str, int n)
{
char* begin = str;
char* end = str + n - 1;
while (begin &lt; end) {
char tmp = *begin;
*begin = *end;
*end = tmp;
++begin;
--end;
}
}
这个代码清晰，直白，没有任何高深的技巧。
不知从什么时候开始，有人发明了不使用临时变量交换两个数的办法，用“不用临时变量 交换 两个数”在 google上能搜到很多文章。下面是一个典型的实现：
// 版本二，用异或运算交换两个数，烂代码
void reverse_by_xor(char* str, int n)
{
// WARNING: BAD code
char* begin = str;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/858491e2f530abe92e102b12d44ad84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7051a687b9073f035467ae3215410b86/" rel="bookmark">
			Adobe查看pdf字体变模糊（粗糙）问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Adobe Acrobat或者Adobe Reader有时跳出个设置助手，一步步点下去后字体变得很粗糙模糊，以前我为此重装过软件，今天细心看一下，可以这样解决。
1、Adobe Acrobat，高级，辅助工具，设置助手，字体平滑的那个选项勾掉。
2、Adobe Reader，文档，辅助工具设置助手，字体平滑的那个选项勾掉
清晰
粗糙
源自：http://hi.baidu.com/yuzhounh/blog/item/43650f8beee963639e2fb4a5.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09208291c15aaaedc8363b4c049a7a6e/" rel="bookmark">
			jquery调用页面后台方法‏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源地址：http://www.cnblogs.com/liyuxin/archive/2011/03/01/1967776.html
jquery调用页面后台方法‏如下：
给出了两个简单的例子，无参数的和有参数的，返回的都是json数据。
&lt;%@Page Language="C#"AutoEventWireup="true"CodeBehind="JqueryCSMethodForm.aspx.cs"Inherits="JQuerWeb.JqueryCSMethodForm"%&gt;
&lt;!DOCTYPEhtml PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;htmlxmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;headrunat="server"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script type="text/javascript"src="JS/jquery-1.4.2.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
$(document).ready(function() {
$("input[type='button'][value='GetDate']").click(function() {
$.ajax({
type:"post",
url:"JqueryCSMethodForm.aspx/GetNowDate",
datatype:"json",
contentType:"application/json; charset=utf-8",
success:function(data) {
$("input#showTime").val(eval('(' + data.d +')')[0].nowtime);
},
error:function(XMLHttpRequest, textStatus, errorThrown) {
alert(errorThrown);
}
});
});
$("input[type='button'][value='GetOneDayLater']").click(function() {
$.ajax({
type:"post",
url:"JqueryCSMethodForm.aspx/GetOneDayLate",
data:"{days:1}",
datatype:"json",
contentType:"application/json; charset=utf-8",
success:function(data) {
$("input#showTime").val(eval('(' + data.d +')')[0].nowtime);
},
error:function(XMLHttpRequest, textStatus, errorThrown) {
alert(errorThrown);
}
});
});
});
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09208291c15aaaedc8363b4c049a7a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994bbaeecf0168e0c068d01148679968/" rel="bookmark">
			xbmc addons
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XBMC新版“扩展功能”简介
目录
1. 扩展功能模块结构2. 图片文件指引 2.1 icon.png2.2 fanart.jpg3. addon.xml 3.1 &lt;addon&gt;元素3.2 &lt;requires&gt;元素3.3 &lt;extension&gt;元素3.4 xbmc.addon.metadata extension4. extension类别 本贴介绍将在即将发布的XBMC Dharma（10.05）中采用的扩展功能管理系统。XBMC要推出的这个新插件系统使得第三方开发的增强功能可以被用户直接通过XBMC内置用户界面获取。这个插件系统基于插件功能库
c-pluff 扩展功能模块结构 每个扩展功能模块保存在独立的目录中，并用名这addon.xml的XML文件来描述。还有一些相关文件，名为icon.png、 changelog.txt和fanart.jpg。这几个文件是可选择使用的，不过建议至少要有icon.png。这些文件要存在扩展功能模块的“根” 目录中。其他文件应该包含在resources/子目录中，如语言文件和设置描述文件。
图片文件指引 每个扩展功能有2个相关的图片文件：一个图标文件（icon.png）和一个可选的同人画文件（fanart.jpg）。如果你想要为你的扩展功能制作高质量的图标或同人画，可以随时向XBMC论坛的社区提出请求－－那里有许多天才的设计师们乐于为你的扩展功能设计美图。
icon.png 我们建议icon.png做成正方形的PNG文件，规则如下：
· 它应该以图形方式向用户表述这个扩展功能的作用；
· 它应该是256x256的PNG文件；
· 它不应该有阴影、光泽或类似特效－－XBMC皮肤系统会处理这些；
· 建议采用在平面背景（非透明）下的logo图标形式（例如采用扩展功能在线获取媒体的服务商的logo图标）。
fanart.jpg 我们建议fanart.png做成16:9的JPG文件，规则如下：
· 它用作背景，所以应该简洁没有文字内容；
· 建议为1280x720的JPG文件，通常分辨率不要高于1920x1080；
· 建议在合理范围内尽可能让文件字节数小些，要知道有成千上万人要下载它。
addon.xml addon.xml是一个很重要的文件，它告诉XBMC这个扩展功能模块是干吗的（比如是哪一类扩展功能）以及要依赖哪些扩展功能、正常运行需要的XBMC最低版本。addon.xml文件范例如下：
复制内容到剪贴板 代码: &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;addon
id="skin.confluence"
version="1.1.0"
name="Confluence"
provider-name="Jezz_X, Team XBMC"&gt;
&lt;requires&gt;
&lt;import addon="xbmc.gui" version="2.11"/&gt;
&lt;/requires&gt;
&lt;extension
point="xbmc.gui.skin"
defaultresolution="720p"
defaultresolutionwide="720p"
defaultthemename="textures.xbt"
effectslowdown="0.75"
debugging="false"/&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/994bbaeecf0168e0c068d01148679968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab330147d99d0a40fa4528bd89c6e06/" rel="bookmark">
			项目经理的商务指南系列之四：认识谈判（不做传声筒，不做顶门闩，进退之策，进退之法，有机事者必有机心)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是项目经理的商务指南系列中的第四篇。（之一：序言及项目本质，之二：认识责任，之三：认识客户，之四：认识谈判，之五：认识项目进展，之六：认识回款，之七：将项目推向不败之地）
谈判是一件让大门不出二门不迈的项目经理很头疼的事情，谈判的技巧很多，要完全掌握不是一天两天的事情，但也不难。随便搜索“谈判技巧”，都可以找到一大堆，本文不再详述。本文主要涉及如何向正确的谈判心态迈出第一步的问题，剩下的问题，自然读者会自己找到答案。
本人管理过销售和实施，中间有大量的谈判发生，有初期售前、报价、合同相关的，也有后期回款、结项乃至救火相关的，其中的“技巧”五花八门，自己都记不住，也没总结过。以下描述的，是其中最重要的也最普适的几条。
不做传声筒 传声筒是最可怕的商务方法，就是把客户的原话送回领导定夺，而将领导的原话又反馈给客户。
曾经有一次，销售人员带回一个信息：客户在第二期采购中，希望我们用“微软和惠普的方式结帐”，这种方式的金额，只有一期合同单价的十分之一。当时我们都很奇怪，问他感觉客户的真实意图是什么，因为这个价格在很大程度上甚至表明客户不再想和我们继续合作，想让我们自己提出。销售人员回答说：“我当时听到也感到很奇怪（他当时在客户现场面谈的），所以回来和大家商量一下，看大家的想法如何。”面对这个问题，大家能有什么想法呢？所以最后结论是：“请去问问客户，他们对第二期的价格这么低，有什么想法。”
大家猜结果如何？过了两天这个销售回来报告说：“客户解释说是想让结帐的方式与微软和惠普相同，而不是指金额。我说呢怎么会这么奇怪，百思不得其解……”“那这次的金额呢？”大家追问。他想了想说：“等我打个电话问问……”
在项目的前期，销售是整个环节的纽带；后期则是项目经理。作为核心人员，这些角色所能了解的信息是最多的，因此必须发挥核心思考功能。
核心思考功能和决策是两码事，就像计算机的CPU一样，所有信息和计算都在这里完成了，显示在屏幕上的只是几个按钮，让用户选择。
千万不要把原始数据抛出来，要知道销售和项目经理之外的人，对项目的认识都是片面的，很难了解到项目的全貌。让他们（包括自己的领导和老板）盲目地做出判断，是一件很不负责任的事情。
不做顶门闩 顶门闩是那些只管关门，而不开窗的人。
公司运作到一定阶段，里边存在的所有问题，都是那些一个部门自己解决不了的问题。而跨部门的问题，都因为每个部门对别人关上了门，而又不开窗造成的。
有一次开会，市场人员代表问销售（兼项目经理）：“客户有时候打电话来，问我产品的大致价格，我应该怎样回答？”
“市场人员怎么能回答价格问题呢，一定不要告诉客户。”“如果告诉客户，我们的工作就很难做了”“这个问题应该我们来回答。”“告诉他们这件事情不归你管。”“说我们公司有规定，市场人员不能报价”……等等答案，大约持续了5分钟。
这时候我打断大家，问那个市场人员代表：“他们的答案你满意吗？”市场人员苦笑了一下，摇头。
当然不满意了，客户想知道产品的大致价格，而不是想知道我们公司的规定，也不是想知道销售人员的联系电话，答非所问的答案，不能让客户满意，连自己公司的市场人员也不会满意。
但是最后给出满意答案的，还是那堆销售。因为在看到市场代表摇头后，我问各位销售：“你们有谁能给出一个完整的说得过去的回答方法，无论是什么，但要让市场人员觉得现实的。”最后结果是大家给出了5个答案，市场人员对其中2个点了头，从此他们有了标准的回答。
不要问我那2个答案是什么，其实任何时候只要不做顶门闩，都会发现自己脑子其实挺聪明的，立刻就能发现答案。
心法：客户之于公司，市场之于销售，销售之于项目经理，前者敲响后者的门，都是想送钱来。这个时候不要试图把门顶住，而是要想想开门之后说什么。
进退不离 心也开了，门也开了，要解决的事情千变万化，应该怎样思考呢？总结了半天，只有4个字最直观普适：进退不离。
无论从甲方还是乙方，双方都认为谈判过程是一个不断向对方让步的“退”的过程。为什么呢？因为两者都不认为结果在两者利益的中点，而都认为应该在偏向自己的一方。
因此自己每退一步，对方必须也要退一步（对方退就是我方进），否则就会直接到达对方的利益点，而失去谈判的价值，这就叫进退不离。
也就是说对方每次提出一个条件，我们可以答应，但是必须同时还以另外一个条件；我们每次提出一个条件，也要想好可以给客户一个让步以作为交换。
能做这件事情的前提，是我们不能做传声筒（不替老板想好，很容易只退不进），不能做顶门闩（只替自己想，很容易只进不退而失去客户）。
“哦，明白了，是不是敌进我退敌退我进的进退呢？”不是。
进退之策 之一项目本质中曾经提到，项目是互利的交易。既然如此，就不能想象和过独木桥一样，我进一步，你必退一步。
那怎么想呢？就是要做到进退的目标：我进一大步，你只退一小步；你进一大步，我也只退一小步，才能共赢。怎样才能做到呢？
其实仔细分析一下甲乙双方的价值观，会发现两者截然不同。
乙方的核心利益点是盈利，即总价-成本，这两者都是最不能退的地方。
比如如果客户有400人，想为其中300人买一个软件的300个许可，乙方报价100万，甲方只有80万预算。那么对乙方而言，比较好的策略就是总价保持100万，而赠送一些额外的许可，让对方400人都能用起来。
这样会不会损害远期利益？有可能，也有可能不。所以说上述方法是一个心法，它会产生更多选择，然后从各种选择中挑选最好的一个，每个企业每个项目的选择可能都不同，但是比只能闷头就80万还是100万死磕要好。
甲方的核心利益是效果，由功能、可用性、实施效果等组成，这几个都是最不能退的地方。
为什么说价格（乙方的核心利益）不是甲方考虑的重点？因为若甲方考虑钱，就不会发起项目了，那样最省钱；就是因为甲方获得效果后的利益远远大于花掉的钱，才会出钱给乙方开发。
本人在做造价管理标准的时候接触过一些政府部门的采购方，有一个话很准确地说明了他们的心态：“不怕花钱怕浪费”。什么是浪费呢？就是花了钱却没有效果。
处理进退的心法，就是用双方都用多余的次要的东西，换取自己缺少的重要的东西。
进退之法 如果觉得心法太空，初期可以考虑使用下面的几种技法。
下面几句话有点绕，是上述心法的几种变形技法（从乙方角度，其实双方都通用）：
若对方提出侵害自己核心价值的条件，力求不退，而换之以自己多余而对方是之为核心价值的东西（如上面提到的总价与许可之交换，对方有无数的钱，我们有无数的许可证）。
若对方提出不侵害自己核心价值的条件，力求退，但不能白退，要换之以我们喜欢而对方不在意的东西。
反之我们提出条件时，也如法做好心理准备，甚至替客户做好准备（有没有听说一个故事：去谈判的时候本来准备了两个条件，结果高人加上第三个不可能条件，与对方争论良久后，划掉第三个条件，对方如释重负地同意了最初的两个条件）。
有机事者必有机心 大致意思就是天天算计各种事情，迟早就会变成多疑狡猾的人。具体可参考文末链接。
这也是本文不想多说具体谈判技巧的原因。
无论谈判多么巧妙，为公司赚来了多少多余的利益，若忘记了项目的两个本质：互利的交易+交付价值，迟早成也谈判，败也谈判。
记住这一点，才能进不进在对方的核心价值上，退要退在自己该退之处，才能保持与客户的共赢，才能让项目短期成功，让企业长期生存。
这一点，也是为什么有的项目经理在掌握了商务技能后，会比传统销售更能促成单子的原因，因为对比与项目管理技能，商务技能更容易顿悟。
参考阅读：有机事者必有机心，理解很深刻 http://hi.baidu.com/zhiyanzhai33/blog/item/6498d73ff92e03c47d1e71b5.html
转载于:https://blog.51cto.com/cheny/1101139
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e906f369199e1892c8bcebc929871509/" rel="bookmark">
			Windows 不能在 本地计算机 启动 SQL Server 服务 错误代码126
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows 不能在 本地计算机 启动 SQL Server 服务 错误代码126 在使用SQL2005（或2008）是可能会遇到错误提示：
“Windows 不能在 本地计算机 启动 SQL Server 。
有关更多信息，查阅系统事件日志。如果这是非 Microsoft 服务，请与服务厂商联系，并参考特定服务错误代码126 ”
解决方法：
在2005（2008）的“配置工具”中有个“SQL Server Configuration Manager”--&gt;SQLserver 2005（2008） 的网络配置，
在MSSOLSERVER和SQLEXPRESS中都有个VIA的属性，你那个服务无法启动就把那个VIA设置禁用。
然后重启一下服务，就可以了。
我试过了是在2008中无法启动服务，
查看MSSOLSERVER和SQLEXPRESS中都有个VIA的属性，
将VIA设置为禁用，然后重启服务，就可以了，服务能正常启动。
。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d4433c11ab59101ff09e872894f772/" rel="bookmark">
			项目经理的商务指南系列之三：认识客户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被动而弱小的客户 客户常常被认为是主动的一方，可以蛮横，强硬地与乙方谈判，但事实其实不是这样。
多数甲方的信息中心，尽管也签署过若干项目，但每种软件，却都只有一次机会立项；这和我们乙方能同时给多个甲方开发相同的软件比，信息不可谓不闭塞，经验不可谓不缺乏；乙方可谓知己知彼，既懂业务又懂开发还懂成本，而对方经常只知道预算（其实他们连应该预算多少都不知道）；最致命的一点是，在整个开发过程中，开发进展对甲方几乎完全不透明，令其凭空生出恐惧心；最后一点则是，若项目失败，乙方只会损失钱，而甲方常常带来无法挽回的损失（比如高铁事故）。
因此，客户完全处于是一种“外强中干”的状态，理解这一点，就能理解客户的各种“古怪，无理，强硬的举动”。
理解客户的古怪行为 理解了上面客户的真实立场，就能更好地了解下面这些古怪举动（其实我们在购买东西尤其是装修房屋的时候，也会有此类举动）：
要买东西，却不说有多少钱（怕说完了，实际上不需要那么多；俗话说买的不如卖的精，连卖家都说不出价格的东西，买家怎么会说呢）
要买东西，却不说具体需求（客户身在此山中，常常不如我们了解，怕说少了，我们顺水推舟少做，结果用不了）
评审需求，却不签字确认（本来就不太懂怎样分析需求，万一签字了却少了什么，背一身责任）
不断变更，却从不多加钱（客户其实很难分清“变更”和“细化”的差别，他们觉得我只是把需求更详细地描述一番，你们就像加钱？）
项目完了，却迟迟不验收（万一付款了，再有缺陷或修补，乙方撂下挑子怎么办）
……
理解了这些之后，就不应该把项目理解为对抗与博弈的战场，而是要通过帮助化解客户的疑虑，来达到共赢。
怎样化解？上述种种问题，并没有普适的答案，但若建立了正确的心法，每个项目、每个客户，都能为其找到即使不完美至少算是说的过去的化解方法。
其实敏捷开发中的很多内容，都能解决或缓解上述问题中的一部分，但很多人都只把敏捷方法当作内部管理的方法，削弱了其应有的作用。
喜欢上客户 说归说，无论我们怎样理解客户了，客户可能都还不知道我们正在想共赢而不是对抗，所以他们仍一样地蛮横、强硬、古怪。
作为从直来直去的程序员进化过来的项目经理，怎样才能“简单地”喜欢上客户，进而为其着想呢？
几年前曾经在一家欧洲的咨询公司工作过，被外派到欧洲学习了一段时间。诸种培训内容都忘光了，但还记得一位头发都白了的资深销售给我们讲“selling XXX”（XXX是我们公司的名字），他的核心思想是：“与客户打交道最多的，是公司的咨询师（就是我们这些被培训的人），而不是销售；因此咨询师必须建立一种销售意识。”这非常像现在我们正在讨论的话题：与客户打交道最多的不是销售人员，而是项目经理；因此项目经理必须建立销售意识。
他在一张PPT中引用了这张图片：
原来欧洲人是很不喜欢这位美国总统的，但他要求我们从此照片上为此人找出5个值得尊敬的好地方，而不是用既有的观念戴着有色眼镜看他……结果是，居然找到不止5处，包括“着装好、直率、幽默”等等原来意想不到的方面。
努力找到对方的优点而不是盯着对方的缺点，这就是一种很简便的快速喜欢上客户的方法，很多销售人员都在使用。
其实当一个项目经理与一位“弱势的，外行的，被动的，需要帮助的”客户坐在一起，而不是与一位“蛮横的，强硬的，古怪的”客户坐在一起的时候，心态，思想，行为，效果，都会有很大的不同。从这一点上说，心法变了，技法也就不难自悟了。
无论我们再怎么喜欢客户，难免还是会有博弈的时候。下一篇将谈到一些谈判时所应持有的心法和技法。
转载于:https://blog.51cto.com/cheny/1101148
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4a40d91dc30c37cb6e6a802b3da6f5/" rel="bookmark">
			项目经理的商务指南系列之一：序言及项目本质（敏捷开发，客户，沟通，回款）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是项目经理的商务指南系列中的第一篇。（之一：序言及项目本质，之二：认识责任，之三：认识客户，之四：认识谈判，之五：认识项目进展，之六：认识回款，之七：将项目推向不败之地）
编程语言的逐渐高层化导致了需求分析与架构设计的逐渐合并，敏捷开发等更加扁平的开发方法论导致了项目团队将直接与客户的业务流程以及业务人员打交道。在这种变革中，项目经理将越来越需要掌握一些商务知识，而不是固守原来课本上对进度、质量、成本的认识。
本系列博文将涉及这一内容。
目录及内容提要 序言及项目本质 从项目经理的角度看，项目常常是博弈、对抗的战场，而甲乙双方当初当然不是因为博弈或对抗而发起项目的。本章节将重新回到项目起点，去挖掘甲乙双方应共同持有的项目价值观。 认识责任 软件项目经理常常被认为是关注进度、质量、成本、需求四个维度的内部管理者，而对于谈判、回款、维护客户关系等活动并不负有责任。而实际上，早在谈判期间就为未来的内部管理维度的要求达成了初步共识；而这些初步共识的实现程度，与未来客户的回款、关系进展又密切相关。 本章节从责权利对等的角度，分析为何应将传统的项目管理内容与商务沟通内容融会贯通，及其对项目经理们未来职业生涯的影响。 认识客户 本章节将从客户角度，分析客户对“项目”的态度，从而揭示项目谈判、报价、执行、验收过程中客户种种“难以理解”的举动背后的原因；理解这些，是与客户进入合作而非对抗状态的前提条件。本章节的末尾，还将提供一些技巧，掌握与客户打交道的基本心法与技法。 认识谈判 本章节将从客户角度，分析客户为何在谈判中表现得强硬而又迟疑，从而揭示客户在项目早期实际所处的“被动”状态。若能理解客户在项目中遇到的实际困难和追求的核心价值，并将其置于项目管理的同侧而非对立面，就更有可能与客户达成共赢。 认识项目进展 本章节将从客户角度，分析客户眼中的进度、质量、成本、需求、变更为何物，进而理解如何才能想客户可视化地呈现项目状态，以及如何令客户信任项目正在顺利进展。 认识回款 本章节将从客户角度，分析客户如何认识回款，以及哪些行动及结果能让客户放心地结款。项目面临的首要问题，是要转换到客户的角度理解项目完成的定义，而不是固守研发管理中的定义。 将项目推向不败之地 本章节将从项目管理的角度，观察和分析项目可能的发展路径，以及在这些发展路径上项目可能处于的状态。从商务的角度看，这些状态中的一部分进可攻退可守，是项目所应不断追求的不败之地。 项目本质 项目经理的眼中，项目常常是与客户进行博弈和对抗的战场。
在一家国际顶级企业的演讲者在被问及他们如何处理频繁的变更时，回答是“我们在签订合同时顺便会签订一个很繁琐的变更流程，每个变更的流程有40个环节，时间可长达一个月，因此多数客户都放弃了没有必要的变更。”而在提到敏捷开发的“拥抱变化”时，被最常问到的问题就是：“如果客户需求不断变化，导致项目延期超支怎么办”。
甲方缘何投入数以万亿计的资金，乙方缘何投入成百上千的人员，来打造一个博弈和对抗的战场呢？这当然不是当年的本意。
以下的内容，需要开发人员能站在甲方角度做一些基本的设想。最简单的方法，是假设自己要装修房子，能比较快速地入戏。
项目是一次互利的交易 其实与我们采购物品相同，项目的基本属性就是交易，我们把自己擅长的、多余的东西，来换取对方擅长的、多余的东西；在整个过程完成后，双方都会得利；无论“价格买高了还是买低了”，交易后的状态总归是优于交易前的状态。
有了这个基本认识后，对某些现象就能建立正确的认识。
比如“客户不加钱却提出大量变更”，就不应该被认为是“客户故意提出大量变更，然后又不加钱，从而想占我们的便宜”，而是应该被理解为“由于某些限制，客户需要获得更多利益，又无法为我们争取利益。”
这两者有何区别呢？前者无解，后者有解。有句俗话叫做不怕没好事，就怕没好人。前者就是没好人，而后者不过是没好事而已。
至于怎么解，以后的章节会提到。
客户最终购买的是软件价值 这是什么意思呢？举个例子。
两家软件公司，人数相同，开发完全相同的东西，一家100个销售+100个开发人员，另外一家则是只有200个开发人员。刚开始头一年会如何？应该是有销售的公司厉害一些，因为他们能把100块钱的东西，卖到200块钱，赚100块；而没有销售的公司，尽管人多，造出来的软件值两倍，也就是200块钱，但他们只能卖到210，赚10块。
但是10年之后，软件的价值差距就出来了，前者的软件已经值1000块钱了，销售人员也能把它卖到2000块钱，赚1000。但是后者的软件值2000，只卖2100，赚100。谁的客户多？当然是后者，因为时间长了，两家的产品差别这么大，价格又接近，客户不可能熟视无睹的。
后者的客户会直线上升，软件有个特点，只卖一个的时候，成本很高，得按2000算，但卖两个的时候，成本就几乎归零了，第二个2100整个都是净利，立刻就超过了第一家公司。
那第一家公司有销售人员，和客户关系好，会不会获得市场呢？会，但是不会很多。客户的决策者，也不是靠购买关系在甲方立足的，他们也迟早会倒向提供价值更多的乙方。
这对我们有什么启示？那就是任何时候，所谓商务、谈判、博弈……这些活动，都只是项目管理活动的附属品；正常最后赢得客户乃至乙方利益的，是向甲方交付价值丰厚的产品。因此切勿本末倒置。
由此得到的一个推论，是商务、谈判、博弈的核心目的，是保证双方的利益都最大化，不可持有零和心态。
掌握好这两种主要本质，就能在下面所说的过程中保持正确的心态。
点击下载免费的敏捷开发教材：《火星人敏捷开发手册》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafa47a6156b9ea72f71414cdc7eb43c/" rel="bookmark">
			项目经理的商务指南系列之一：序言及项目本质（敏捷开发，客户，沟通，回款）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是项目经理的商务指南系列中的第一篇。（之一：序言及项目本质，之二：认识责任，之三：认识客户，之四：认识谈判，之五：认识项目进展，之六：认识回款，之七：将项目推向不败之地）
编程语言的逐渐高层化导致了需求分析与架构设计的逐渐合并，敏捷开发等更加扁平的开发方法论导致了项目团队将直接与客户的业务流程以及业务人员打交道。在这种变革中，项目经理将越来越需要掌握一些商务知识，而不是固守原来课本上对进度、质量、成本的认识。
本系列博文将涉及这一内容。
目录及内容提要 序言及项目本质 从项目经理的角度看，项目常常是博弈、对抗的战场，而甲乙双方当初当然不是因为博弈或对抗而发起项目的。本章节将重新回到项目起点，去挖掘甲乙双方应共同持有的项目价值观。认识责任 软件项目经理常常被认为是关注进度、质量、成本、需求四个维度的内部管理者，而对于谈判、回款、维护客户关系等活动并不负有责任。而实际上，早在谈判期间就为未来的内部管理维度的要求达成了初步共识；而这些初步共识的实现程度，与未来客户的回款、关系进展又密切相关。本章节从责权利对等的角度，分析为何应将传统的项目管理内容与商务沟通内容融会贯通，及其对项目经理们未来职业生涯的影响。认识客户 本章节将从客户角度，分析客户对“项目”的态度，从而揭示项目谈判、报价、执行、验收过程中客户种种“难以理解”的举动背后的原因；理解这些，是与客户进入合作而非对抗状态的前提条件。本章节的末尾，还将提供一些技巧，掌握与客户打交道的基本心法与技法。认识谈判 本章节将从客户角度，分析客户为何在谈判中表现得强硬而又迟疑，从而揭示客户在项目早期实际所处的“被动”状态。若能理解客户在项目中遇到的实际困难和追求的核心价值，并将其置于项目管理的同侧而非对立面，就更有可能与客户达成共赢。认识项目进展 本章节将从客户角度，分析客户眼中的进度、质量、成本、需求、变更为何物，进而理解如何才能想客户可视化地呈现项目状态，以及如何令客户信任项目正在顺利进展。认识回款 本章节将从客户角度，分析客户如何认识回款，以及哪些行动及结果能让客户放心地结款。项目面临的首要问题，是要转换到客户的角度理解项目完成的定义，而不是固守研发管理中的定义。将项目推向不败之地 本章节将从项目管理的角度，观察和分析项目可能的发展路径，以及在这些发展路径上项目可能处于的状态。从商务的角度看，这些状态中的一部分进可攻退可守，是项目所应不断追求的不败之地。 项目本质 项目经理的眼中，项目常常是与客户进行博弈和对抗的战场。
在一家国际顶级企业的演讲者在被问及他们如何处理频繁的变更时，回答是“我们在签订合同时顺便会签订一个很繁琐的变更流程，每个变更的流程有40个环节，时间可长达一个月，因此多数客户都放弃了没有必要的变更。”而在提到敏捷开发的“拥抱变化”时，被最常问到的问题就是：“如果客户需求不断变化，导致项目延期超支怎么办”。
甲方缘何投入数以万亿计的资金，乙方缘何投入成百上千的人员，来打造一个博弈和对抗的战场呢？这当然不是当年的本意。
以下的内容，需要开发人员能站在甲方角度做一些基本的设想。最简单的方法，是假设自己要装修房子，能比较快速地入戏。
项目是一次互利的交易 其实与我们采购物品相同，项目的基本属性就是交易，我们把自己擅长的、多余的东西，来换取对方擅长的、多余的东西；在整个过程完成后，双方都会得利；无论“价格买高了还是买低了”，交易后的状态总归是优于交易前的状态。
有了这个基本认识后，对某些现象就能建立正确的认识。
比如“客户不加钱却提出大量变更”，就不应该被认为是“客户故意提出大量变更，然后又不加钱，从而想占我们的便宜”，而是应该被理解为“由于某些限制，客户需要获得更多利益，又无法为我们争取利益。”
这两者有何区别呢？前者无解，后者有解。有句俗话叫做不怕没好事，就怕没好人。前者就是没好人，而后者不过是没好事而已。
至于怎么解，以后的章节会提到。
客户最终购买的是软件价值 这是什么意思呢？举个例子。
两家软件公司，人数相同，开发完全相同的东西，一家100个销售+100个开发人员，另外一家则是只有200个开发人员。刚开始头一年会如何？应该是有销售的公司厉害一些，因为他们能把100块钱的东西，卖到200块钱，赚100块；而没有销售的公司，尽管人多，造出来的软件值两倍，也就是200块钱，但他们只能卖到210，赚10块。
但是10年之后，软件的价值差距就出来了，前者的软件已经值1000块钱了，销售人员也能把它卖到2000块钱，赚1000。但是后者的软件值2000，只卖2100，赚100。谁的客户多？当然是后者，因为时间长了，两家的产品差别这么大，价格又接近，客户不可能熟视无睹的。
后者的客户会直线上升，软件有个特点，只卖一个的时候，成本很高，得按2000算，但卖两个的时候，成本就几乎归零了，第二个2100整个都是净利，立刻就超过了第一家公司。
那第一家公司有销售人员，和客户关系好，会不会获得市场呢？会，但是不会很多。客户的决策者，也不是靠购买关系在甲方立足的，他们也迟早会倒向提供价值更多的乙方。
这对我们有什么启示？那就是任何时候，所谓商务、谈判、博弈……这些活动，都只是项目管理活动的附属品；正常最后赢得客户乃至乙方利益的，是向甲方交付价值丰厚的产品。因此切勿本末倒置。
由此得到的一个推论，是商务、谈判、博弈的核心目的，是保证双方的利益都最大化，不可持有零和心态。
掌握好这两种主要本质，就能在下面所说的过程中保持正确的心态。
转载于:https://blog.51cto.com/cheny/1101154
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb4298521c8ee941e69fd53605c12ab/" rel="bookmark">
			计算机概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.主频 主频也叫时钟频率，单位是MHz，用来表示CPU的运算速度。CPU的主频＝外频×倍频系数。很多人认为主频就决定着CPU的运行速度，这不仅是个片面的，而且对于服务器来讲，这个认识也出现了偏差。至今，没有一条确定的公式能够实现主频和实际的运算速度两者之间的数值关系，即使是两大处理器厂家Intel和AMD，在这点上也存在着很大的争议，我们从Intel的产品的发展趋势，可以看出Intel很注重加强自身主频的发展。像其他的处理器厂家，有人曾经拿过一快1G的全美达来做比较，它的运行效率相当于2G的Intel处理器。 所以，CPU的主频与CPU实际的运算能力是没有直接关系的，主频表示在CPU内数字脉冲信号震荡的速度。在Intel的处理器产品中，我们也可以看到这样的例子：1 GHz Itanium芯片能够表现得差不多跟2.66 GHz Xeon/Opteron一样快，或是1.5 GHz Itanium 2大约跟4 GHz Xeon/Opteron一样快。CPU的运算速度还要看CPU的流水线的各方面的性能指标。 当然，主频和实际的运算速度是有关的，只能说主频仅仅是CPU性能表现的一个方面，而不代表CPU的整体性能。 2.外频 外频是CPU的基准频率，单位也是MHz。CPU的外频决定着整块主板的运行速度。说白了，在台式机中，我们所说的超频，都是超CPU的外频（当然一般情况下，CPU的倍频都是被锁住的）相信这点是很好理解的。但对于服务器CPU来讲，超频是绝对不允许的。前面说到CPU决定着主板的运行速度，两者是同步运行的，如果把服务器CPU超频了，改变了外频，会产生异步运行，（台式机很多主板都支持异步运行）这样会造成整个服务器系统的不稳定。 目前的绝大部分电脑系统中外频也是内存与主板之间的同步运行的速度，在这种方式下，可以理解为CPU的外频直接与内存相连通，实现两者间的同步运行状态。外频与前端总线(FSB)频率很容易被混为一谈，下面的前端总线介绍我们谈谈两者的区别。 3.前端总线(FSB)频率 前端总线(FSB)频率(即总线频率)是直接影响CPU与内存直接数据交换速度。有一条公式可以计算，即数据带宽＝(总线频率×数据带宽)/8，数据传输最大带宽取决于所有同时传输的数据的宽度和传输频率。比方，现在的支持64位的至强Nocona，前端总线是800MHz，按照公式，它的数据传输最大带宽是6.4GB/秒。 外频与前端总线(FSB)频率的区别：前端总线的速度指的是数据传输的速度，外频是CPU与主板之间同步运行的速度。也就是说，100MHz外频特指数字脉冲信号在每秒钟震荡一千万次；而100MHz前端总线指的是每秒钟CPU可接受的数据传输量是100MHz×64bit÷8Byte/bit=800MB/s。 其实现在“HyperTransport”构架的出现，让这种实际意义上的前端总线(FSB)频率发生了变化。之前我们知道IA-32架构必须有三大重要的构件：内存控制器Hub (MCH) ,I/O控制器Hub和PCI Hub，像Intel很典型的芯片组 Intel 7501、Intel7505芯片组，为双至强处理器量身定做的，它们所包含的MCH为CPU提供了频率为533MHz的前端总线，配合DDR内存，前端总线带宽可达到4.3GB/秒。但随着处理器性能不断提高同时给系统架构带来了很多问题。而“HyperTransport”构架不但解决了问题，而且更有效地提高了总线带宽，比方AMD Opteron处理器，灵活的HyperTransport I/O总线体系结构让它整合了内存控制器，使处理器不通过系统总线传给芯片组而直接和内存交换数据。这样的话，前端总线(FSB)频率在AMD Opteron处理器就不知道从何谈起了。 4、CPU的位和字长 位：在数字电路和电脑技术中采用二进制，代码只有“0”和“1”，其中无论是 “0”或是“1”在CPU中都是 一“位”。 字长：电脑技术中对CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长。所以能处理字长为8位数据的CPU通常就叫8位的CPU。同理32位的CPU就能在单位时间内处理字长为32位的二进制数据。字节和字长的区别：由于常用的英文字符用8位二进制就可以表示，所以通常就将8位称为一个字节。字长的长度是不固定的，对于不同的CPU、字长的长度也不一样。8位的CPU一次只能处理一个字节，而32位的CPU一次就能处理4个字节，同理字长为64位的CPU一次可以处理8个字节。 5.倍频系数 倍频系数是指CPU主频与外频之间的相对比例关系。在相同的外频下，倍频越高CPU的频率也越高。但实际上，在相同外频的前提下，高倍频的CPU本身意义并不大。这是因为CPU与系统之间数据传输速度是有限的，一味追求高倍频而得到高主频的CPU就会出现明显的“瓶颈”效应—CPU从系统中得到数据的极限速度不能够满足CPU运算的速度。一般除了工程样版的Intel的CPU都是锁了倍频的，而AMD之前都没有锁。 6.缓存 缓存大小也是CPU的重要指标之一，而且缓存的结构和大小对CPU速度的影响非常大，CPU内缓存的运行频率极高，一般是和处理器同频运作，工作效率远远大于系统内存和硬盘。实际工作时，CPU往往需要重复读取同样的数据块，而缓存容量的增大，可以大幅度提升CPU内部读取数据的命中率，而不用再到内存或者硬盘上寻找，以此提高系统性能。但是由于CPU芯片面积和成本的因素来考虑，缓存都很小。 L1　Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，在CPU管芯面积不能太大的情况下，L1级高速缓存的容量不可能做得太大。一般服务器CPU的L1缓存的容量通常在32—256KB。 L2　Cache(二级缓存)是CPU的第二层高速缓存，分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频相同，而外部的二级缓存则只有主频的一半。L2高速缓存容量也会影响CPU的性能，原则是越大越好，现在家庭用CPU容量最大的是512KB，而服务器和工作站上用CPU的L2高速缓存更高达256-1MB，有的高达2MB或者3MB。 L3　Cache(三级缓存)，分为两种，早期的是外置，现在的都是内置的。而它的实际作用即是，L3缓存的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。降低内存延迟和提升大数据量计算能力对游戏都很有帮助。而在服务器领域增加L3缓存在性能方面仍然有显著的提升。比方具有较大L3缓存的配置利用物理内存会更有效，故它比较慢的磁盘I/O子系统可以处理更多的数据请求。具有较大L3缓存的处理器提供更有效的文件系统缓存行为及较短消息和处理器队列长度。 其实最早的L3缓存被应用在AMD发布的K6-III处理器上，当时的L3缓存受限于制造工艺，并没有被集成进芯片内部，而是集成在主板上。在只能够和系统总线频率同步的L3缓存同主内存其实差不了多少。后来使用L3缓存的是英特尔为服务器市场所推出的Itanium处理器。接着就是P4EE和至强MP。Intel还打算推出一款9MB L3缓存的Itanium2处理器，和以后24MB L3缓存的双核心Itanium2处理器。 但基本上L3缓存对处理器的性能提高显得不是很重要，比方配备1MB L3缓存的Xeon MP处理器却仍然不是Opteron的对手，由此可见前端总线的增加，要比缓存增加带来更有效的性能提升。 7.CPU扩展指令集 CPU依靠指令来计算和控制系统，每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。指令的强弱也是CPU的重要指标，指令集是提高微处理器效率的最有效工具之一。从现阶段的主流体系结构讲，指令集可分为复杂指令集和精简指令集两部分，而从具体运用看，如Intel的MMX（Multi Media Extended）、SSE、 SSE2（Streaming-Single instruction multiple data-Extensions 2）、SEE3和AMD的3DNow!等都是CPU的扩展指令集，分别增强了CPU的多媒体、图形图象和Internet等的处理能力。我们通常会把CPU的扩展指令集称为"CPU的指令集"。SSE3指令集也是目前规模最小的指令集，此前MMX包含有57条命令，SSE包含有50条命令，SSE2包含有144条命令，SSE3包含有13条命令。目前SSE3也是最先进的指令集，英特尔Prescott处理器已经支持SSE3指令集，AMD会在未来双核心处理器当中加入对SSE3指令集的支持，全美达的处理器也将支持这一指令集。 8.CPU内核和I/O工作电压 从586CPU开始，CPU的工作电压分为内核电压和I/O电压两种，通常CPU的核心电压小于等于I/O电压。其中内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低；I/O电压一般都在1.6~5V。低电压能解决耗电过大和发热过高的问题。 9.制造工艺 制造工艺的微米是指IC内电路与电路之间的距离。制造工艺的趋势是向密集度愈高的方向发展。密度愈高的IC电路设计，意味着在同样大小面积的IC中，可以拥有密度更高、功能更复杂的电路设计。现在主要的180nm、130nm、90nm。最近官方已经表示有65nm的制造工艺了。 10.指令集 （1）CISC指令集 CISC指令集，也称为复杂指令集，英文名是CISC，（Complex Instruction Set Computer的缩写）。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。其实它是英特尔生产的x86系列（也就是IA-32架构）CPU及其兼容CPU，如AMD、VIA的。即使是现在新起的X86-64（也被成AMD64）都是属于CISC的范畴。 要知道什么是指令集还要从当今的X86架构的CPU说起。X86指令集是Intel为其第一块16位CPU(i8086)专门开发的，IBM1981年推出的世界第一台PC机中的CPU—i8088(i8086简化版)使用的也是X86指令，同时电脑中为提高浮点数据处理能力而增加了X87芯片，以后就将X86指令集和X87指令集统称为X86指令集。 虽然随着CPU技术的不断发展，Intel陆续研制出更新型的i80386、i80486直到过去的PII至强、PIII至强、Pentium 3，最后到今天的Pentium 4系列、至强（不包括至强Nocona），但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集，所以它的CPU仍属于X86系列。由于Intel X86系列及其兼容CPU（如AMD Athlon MP、）都使用X86指令集，所以就形成了今天庞大的X86系列及兼容CPU阵容。x86CPU目前主要有intel的服务器CPU和AMD的服务器CPU两类。 （2）RISC指令集 RISC是英文“Reduced Instruction Set Computing ” 的缩写，中文意思是“精简指令集”。它是在CISC指令系统基础上发展起来的，有人对CISC机进行测试表明，各种指令的使用频度相当悬殊，最常使用的是一些比较简单的指令，它们仅占指令总数的20％，但在程序中出现的频度却占80％。复杂的指令系统必然增加微处理器的复杂性，使处理器的研制时间长，成本高。并且复杂指令需要复杂的操作，必然会降低计算机的速度。基于上述原因，20世纪80年代RISC型CPU诞生了，相对于CISC型CPU ,RISC型CPU不仅精简了指令系统，还采用了一种叫做“超标量和超流水线结构”，大大增加了并行处理能力。RISC指令集是高性能CPU的发展方向。它与传统的CISC(复杂指令集)相对。相比而言，RISC的指令格式统一，种类比较少，寻址方式也比复杂指令集少。当然处理速度就提高很多了。目前在中高档服务器中普遍采用这一指令系统的CPU，特别是高档服务器全都采用RISC指令系统的CPU。RISC指令系统更加适合高档服务器的操作系统UNIX，现在Linux也属于类似UNIX的操作系统。RISC型CPU与Intel和AMD的CPU在软件和硬件上都不兼容。 目前，在中高档服务器中采用RISC指令的CPU主要有以下几类：PowerPC处理器、SPARC处理器、PA-RISC处理器、MIPS处理器、Alpha处理器。 （3）IA-64 EPIC（Explicitly Parallel Instruction Computers，精确并行指令计算机）是否是RISC和CISC体系的继承者的争论已经有很多，单以EPIC体系来说，它更像Intel的处理器迈向RISC体系的重要步骤。从理论上说，EPIC体系设计的CPU，在相同的主机配置下，处理Windows的应用软件比基于Unix下的应用软件要好得多。 Intel采用EPIC技术的服务器CPU是安腾Itanium（开发代号即Merced）。它是64位处理器，也是IA－64系列中的第一款。微软也已开发了代号为Win64的操作系统，在软件上加以支持。在Intel采用了X86指令集之后，它又转而寻求更先进的64-bit微处理器，Intel这样做的原因是，它们想摆脱容量巨大的x86架构,从而引入精力充沛而又功能强大的指令集，于是采用EPIC指令集的IA-64架构便诞生了。IA-64 在很多方面来说，都比x86有了长足的进步。突破了传统IA32架构的许多限制，在数据的处理能力，系统的稳定性、安全性、可用性、可观理性等方面获得了突破性的提高。 IA-64微处理器最大的缺陷是它们缺乏与x86的兼容，而Intel为了IA-64处理器能够更好地运行两个朝代的软件，它在IA-64处理器上（Itanium、Itanium2 ……)引入了x86-to-IA-64的解码器，这样就能够把x86指令翻译为IA-64指令。这个解码器并不是最有效率的解码器，也不是运行x86代码的最好途径（最好的途径是直接在x86处理器上运行x86代码），因此Itanium 和Itanium2在运行x86应用程序时候的性能非常糟糕。这也成为X86-64产生的根本原因。 （4）X86-64 （AMD64 / EM64T） AMD公司设计，可以在同一时间内处理64位的整数运算，并兼容于X86-32架构。其中支持64位逻辑定址，同时提供转换为32位定址选项；但数据操作指令默认为32位和8位，提供转换成64位和16位的选项；支持常规用途寄存器，如果是32位运算操作，就要将结果扩展成完整的64位。这样，指令中有“直接执行”和“转换执行”的区别，其指令字段是8位或32位，可以避免字段过长。 x86-64（也叫AMD64）的产生也并非空穴来风，x86处理器的32bit寻址空间限制在4GB内存，而IA-64的处理器又不能兼容x86。AMD充分考虑顾客的需求，加强x86指令集的功能，使这套指令集可同时支持64位的运算模式，因此AMD把它们的结构称之为x86-64。在技术上AMD在x86-64架构中为了进行64位运算，AMD为其引入了新增了R8-R15通用寄存器作为原有X86处理器寄存器的扩充，但在而在32位环境下并不完全使用到这些寄存器。原来的寄存器诸如EAX、EBX也由32位扩张至64位。在SSE单元中新加入了8个新寄存器以提供对SSE2的支持。寄存器数量的增加将带来性能的提升。与此同时，为了同时支持32和64位代码及寄存器，x86-64架构允许处理器工作在以下两种模式：Long Mode(长模式)和Legacy Mode(遗传模式)，Long模式又分为两种子模式(64bit模式和Compatibility mode兼容模式)。该标准已经被引进在AMD服务器处理器中的Opteron处理器。 而今年也推出了支持64位的EM64T技术，再还没被正式命为EM64T之前是IA32E，这是英特尔64位扩展技术的名字,用来区别X86指令集。Intel的EM64T支持64位sub-mode，和AMD的X86-64技术类似，采用64位的线性平面寻址，加入8个新的通用寄存器（GPRs），还增加8个寄存器支持SSE指令。与AMD相类似，Intel的64位技术将兼容IA32和IA32E，只有在运行64位操作系统下的时候，才将会采用IA32E。IA32E将由2个sub-mode组成：64位sub-mode和32位sub-mode，同AMD64一样是向下兼容的。Intel的EM64T将完全兼容AMD的X86-64技术。现在Nocona处理器已经加入了一些64位技术，Intel的Pentium 4E处理器也支持64位技术。 应该说，这两者都是兼容x86指令集的64位微处理器架构，但EM64T与AMD64还是有一些不一样的地方，AMD64处理器中的NX位在Intel的处理器中将没有提供。 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb4298521c8ee941e69fd53605c12ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c31844fe8b4c00943c52466667b94f/" rel="bookmark">
			SQLite3中按时间范围分类排名(top 10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间单位是C#中的DateTime.ToFileTime() / 1000000000
创建表：
create table if not exists table_wpp_status( wpp_id integer primary key autoincrement not null, wpp_sn varchar(64) not null, wpp_emp_id varchar(32) not null, wpp_class varchar(32) not null, wpp_state integer default(0), wpp_in_time integer default(0), wpp_out_time integer default(0)) 插入表数据：
insert into table_wpp_status( wpp_sn, wpp_emp_id, wpp_class, wpp_state, wpp_in_time, wpp_out_time) values ('XBX20091021', 'Perry1', 'ABC', 0, 129384821, 0) insert into table_wpp_status( wpp_sn, wpp_emp_id, wpp_class, wpp_state, wpp_in_time, wpp_out_time) values ('XBX20091022', 'Perry2', 'ABC', 0, 129384824, 0) insert into table_wpp_status( wpp_sn, wpp_emp_id, wpp_class, wpp_state, wpp_in_time, wpp_out_time) values ('XBX20091023', 'Perry3', 'ABC', 0, 129384829, 0) insert into table_wpp_status( wpp_sn, wpp_emp_id, wpp_class, wpp_state, wpp_in_time, wpp_out_time) values ('XBX20091024', 'Perry3', 'ABC', 0, 129384830, 0) 修改数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c31844fe8b4c00943c52466667b94f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761032d34646cc0276b43e56c8e20f3d/" rel="bookmark">
			VirtualBox 4.1.2 联网方式 Host-Only &#43;NAT 实现 上网 &#43; 双通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目标：实现虚拟机与宿主机互相ping通，虚拟机可以访问网络。（宿主机为Win7，虚拟机随意）
1. 在virtualbox安装完成之后，会出现一张虚拟网卡.
本地连接手动配置如下（根据实际情况设置静态IP）：
IP地址：192.168.1.103
子网掩码：255.255.255.0
DNS；(根据实际情况)
2. 打开本地连接属性的高级选项卡，勾选“Internet连接共享”的第一个复选框。
3.VirtualBox Host-Only Network 也设置静态IP。如下：
IP地址：192.168.2.102
子网掩码：255.255.255
DNS:192.168.2.100
4.设置虚拟机的网卡，网络连接1的设置为Host-Only， 网络连接2设置为NAT。设置完成后开启虚拟机。
5.启动虚拟机后，设为Host-Only Adapter的网卡手动配置如下：
IP地址：192.168.2.103（与VirtualBox Host-Only Network同一网段）
子网掩码：255.255.255.0
默认网关：192.168.2.102（将VirtualBox Host-Only Network设为网关）
DNS:192.168.2.100 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694af4debeefea564ddacd9582308245/" rel="bookmark">
			(程序员情感三部曲之二)程序员如何找女朋友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 程序员如何找女朋友
根据我十多年的职业生涯观察，程序员90%为男性。在当今这个剩男剩女，大龄青年盛行的时代，作为程序员如何找女朋友，也是一个当下十分关心的热门话题。男大当婚，女大当嫁，找女朋友，谈婚论嫁也是一个很现实社会问题。
程序员的职业特点：
1.沟通交流偏弱，因为大部分时间是呆在电脑面前，写程序，调试，更多时间跟电脑机器打交道，跟人打交道，沟通交流的时间偏少；
2.自由时间少，因为软件开发加班多，晚上9点下班比较普通，周末加班也不少见,此外还要花大把时间用来学习新技术，如Android开发技术；
3.理性思维多一点，感性思维少一点，毕竟软件开发讲究严格的逻辑推理，思考问题全面；
4.接触的人群偏窄，有限，程序员大部分接触的是跟工作相关的人员，如测试、产品、SCM/SQA；
5.不愿意积极主动的争取，程序员有一个思维，没有100%把握，不敢贸然行事，瞻前顾后；
6.薪水算不上高，尤其在北京、上海、深圳、广州这类一线城市，比程序员高的职位有的是，如销售、广告等；
7.有房有车的没有女朋友程序员不多，尤其最近2年，能买得起房的程序员不多，除非他去了500强公司，或者软件研发经理，或者技术总监等等什么职位，要不家里经济环境殷实；
8.对未来的女朋友，未来的生活伴侣理想化程度偏高，因为程序员跟外界人群交往较少，不太清楚女孩子对异性具体要求。上过大学的女孩，本身就不多。以笔者为例,高中的时候，女孩才12人，但全班70多人；上大学的时候，学的是计算机专业，全班32人，女生8个。
上过大学的女生，相较上过大学的男生而言，是稀有动物。
程序员作为一个特殊的社会人群，如何找女朋友呢？
1.需求分析
根据自己的性格特点、经济实力，合理定位：适合自己的女性范围，也就是软件工程里常谈到：需求分析。自己最想找什么样的女孩，譬如：身高在什么范围，年龄在什么范围，学历在什么范围，相貌有什么要求，对性格有什么偏好，喜静还是偏活泼。你越能更多了解自己，知道自己喜欢什么类型的女孩，越能精准定位自己的女性人群。作为程序员，深刻明白需求分析的重要性，需求分为：功能性需求和非功能性需求。如果对找女朋友而言，非功能性需求，就是：女性性格、脾气等，譬如：有的脾气大，有的情绪很敏感，这些只能通过接触才能发现。
2.技术可行性研究
就是自己想找的女性，自己是否可以搞定。偶觉得门当户对是一个重要的因素。对条件好（聪明或者漂亮或者有才华或者善解人意或者高学历或者高薪）的女性，自己是否有足够的信心，时间、精力、财力。毕竟这是一个双向选择。程序员要是想找范冰冰，几乎不可能。
就是这个道理。因为程序员没有时间飞来飞去，陪人家，也没有这个财力，还有就是生活的圈子，也格格不入，没有共同语言。
3.广种薄收
其实，就是编程序，写代码中常用的方法之一，枚举法或者穷举法。充分发动同学、朋友、同事、亲戚等，来帮你推荐符合自己要求的女性。
为什么说程序员思维严谨，就是思考问题全面，就是把各种问题的可能性都考虑到；
同样的道理，找女朋友，也要通过各种各样的关系、场合来结识、去发现一个真正属于自己的好女孩。
多多参加各种活动，如同学的生日聚会、同事的婚礼，各个旅游网站的组织的旅行活动，如爬山、野炊等；
4.三大婚恋交友网站
世纪佳缘 www.jiayuan.com
百合网 www.baihe.com
珍爱网 www.zhenai.com 5.真诚
显示自己的诚意，显示自己的真诚。程序员多年跟电脑打交道，1+1=2,很实在，不做作。记得一定要把自己的真情实意表达出来，让对方感受到。女孩是很容易感动的。一旦她感动地眼泪汪汪，不能自已，她就很容易决定嫁给你。
6.做自己爱情的引擎
经常我们说，搜索引擎，地图导航引擎，但我要说，作为程序员，我们要做自己爱情的引擎，大胆的追求自己的爱情，引导自己爱情发展。去约会、看电影、吃烛光晚餐等。不要畏畏缩缩，瞻前顾后。我对引擎的理解，就是发动机，就是发挥骨干作用，领导作用，自己是导航灯。
7.不要用理性思维来相处
两个人相处的世界里，不能用理性思维来对待。究竟谁对谁错，没有必要弄清楚。这不是写程序，这是两个人感情世界。程序员，最好哄着女孩，逗她开心，逗她快乐。女朋友的，永远都是对的。只要不涉及原则问题，就OK啦！
8.不要过早跳出循环
有些朋友，好不容易，找了个女朋友，相处交往不到2个礼拜，或者1个月，就拜拜了。觉得女友太敏感，觉得脾气合不来等等原因，而分道扬镳了。这就是程序员再写程序时，常犯的错误，过早的跳出了循环，跳出程序。其实，在北京、上海、深圳、广州这些大城市，2个礼拜或者1个月，能真正见面的机会，也就1-3次。往往第1次印象不是全面准确的。
只有多交往，多接触，才能更多的理解对方，发现对方的优点。自己是否适合对方，对方是否适合自己。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/275/">«</a>
	<span class="pagination__item pagination__item--current">276/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/277/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>