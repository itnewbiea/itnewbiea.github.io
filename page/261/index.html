<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb4f5f3044074313439fdf9665b1375a/" rel="bookmark">
			Java对日期Date类进行加减运算一二三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多 ，代码说话： 一、充分利用SimpleDateFormat
import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class DateTestUtil { public static void main(String[] args) throws Exception { SimpleDateFormat sdf=new SimpleDateFormat("yyyyMMdd"); String str="20110823"; Date dt=sdf.parse(str); Calendar rightNow = Calendar.getInstance(); rightNow.setTime(dt); rightNow.add(Calendar.YEAR,-1);//日期减1年 rightNow.add(Calendar.MONTH,3);//日期加3个月 rightNow.add(Calendar.DAY_OF_YEAR,10);//日期加10天 Date dt1=rightNow.getTime(); String reStr = sdf.format(dt1); System.out.println(reStr); } } 注：在Calendar对象的add方法中，第二个参数为正数表示“加”，负数表示“减”。
二、java date 日期加减天数
import java.text.SimpleDateFormat; import java.util.Date; public class DateTest { public static void main(String[] arg){ Date now = new Date(); addAndSubtractDaysByGetTime(now,-5); addAndSubtractDaysByGetTime(now,5); addAndSubtractDaysByCalendar(now,-5); addAndSubtractDaysByCalendar(now,5); } public static Date addAndSubtractDaysByGetTime(Date dateTime/*待处理的日期*/,int n/*加减天数*/){ //日期格式 SimpleDateFormat df=new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb4f5f3044074313439fdf9665b1375a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e541286e23550c044566e5be22239f/" rel="bookmark">
			微软分段推出电子墨水白板应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软星期二宣布将分段推出旗下的Windows 10协作电子墨水白板应用程序，第一阶段的Surface Hub白板应用程序预览版已经推出。该白板应用程序今年晚些时候将会在更多的Windows 10设备上推出，包括Surface Studio和Surface Pro，提供协作电子墨水、几何识别、表格转换和自动表格着色以及一些只有Office 365订阅者可用的功能。
微软分段推出电子墨水白板应用程序
新白板应用程序的推出时间与微软的Surface Pro的更新时间相同，而同时，白板市场的竞争也日趋激烈。谷歌周二开始销售旗下的Jamboard，Jamboard附带的应用程序汇集了了手写、自由形状素描、照片和其他功能。
另外，微软周二还宣布，旗下的电子墨水技术推出新的改进。例如，使用新的Surface笔时，电子墨水对用户触摸响应的压力敏感度达到4,096个压力点，之前的压力点为1,024。而且，电子墨水的厚度和质地可以根据笔的角度调整。微软表示，新的Surface笔在与Office 应用程序一起使用时的延迟几乎为零。
同时，Word、Excel和PowerPoint用户的墨水效果选择更多了，如彩虹、星系、 熔岩、海洋、金银等。新的Office应用程序还包括一个涵括最爱笔、铅笔和荧光笔的画廊，画廊具有在各种移动应用和设备上的漫游功能。
本文转自d1net（转载）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b541a04300e749d043d002c8be5704e/" rel="bookmark">
			Java集合(2)HashSet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashSet是Set接口的典型实现，大多数时候使用Set的集合是就是使用这个实现类，hashSet按Hash算法来存储集合中的元素的，因此具有很好的存取和查找性能。此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问。
注意：如果需要把某个类的对象保存到HashSet集合中，重写这个类的equals()方法和hsahCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，他们的hashCode方法返回值也相等。
当向HashSet中添加可变对象时，必须十分小心，如果修改HashSet集合中的对象，有可能导致该对象与集合中的对象相等，从而导致HashSet无法准确的访问该对象。
class R{
intcount;
publicR(int count){
this.count=count;
}
publicString toString(){
return"R[count:"+count+"]";
}
publicboolean equals(Object obj){
if(this==obj){
returntrue;
}
if(obj!=null&amp;&amp;obj.getClass()==R.class){
Rr=(R)obj;
returnthis.count==r.count;
}
returnfalse;
}
publicint hashCode(){
returnthis.count;
}
}
public class HashSetTest2 {
publicstatic void main(String[] args) {
HashSeths=new HashSet();
hs.add(newR(5));
hs.add(newR(-3));
hs.add(newR(9));
hs.add(newR(-2));
System.out.println(hs);
Iteratorit=hs.iterator();
//取出第一个元素
Rfirst=(R)it.next();
//将第一个元素和第二个元素相等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b541a04300e749d043d002c8be5704e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abcc537ba7923f22851c2926d00b0be6/" rel="bookmark">
			java集合（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java集合类是一种特别有用的工具类，可用于存储数量不等的对象，并实现常用的数据结构，如栈，队列等。Java集合大致可分为set,List,queue,和map，其中Set代表无序，不可重复的集合，List代表有序，可重复的集合。集合类和数组是不一样的，数组中的元素可以是基本类型，也可以是对象（实际上保存的是对象的引用变量）；而集合里只能保存对象（实际上保存的是对象的引用变量,但是通常习惯上认为集合里保存的是对象）。Collection和Map是Java集合框架的根接口。
Collection集合体系的继承树：
Map集合体系的继承树：
Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。Collection接口的操作如下操作集合元素的方法。
boolean add(Object e) ： 该方法用于向集合中添加一个元素，如果添加元素成功返回true。 boolean addAll(Collection c) ：把集合c中的所有元素都添加到此 指定的集合中。 voidclear() ：删除集合里的所有元素，将集合长度变为0。 boolean contains(Object o) ：判断集合是否包含指定的元素o,如果包含返回true。
boolean containsAll(Collection c) ：判断集合是否包含指定的集合c中所有的元素,如果包含返回true。
int hashCode() ：返回此collection 的哈希码值。 boolean isEmpty() ：如果此collection 不包含元素，则返回 true。 boolean remove(Object o) ：删除集合中指定的元素o, 当集合中包含了一个或多个元素o时该方法只删除第一个符合条件的元素，该方法将返回true。
booleanremoveAll(Collection&lt;?&gt; c) ：从集合中删除集合c中包含的所有元素（相当于用调用该方法的集合减去集合c）如果删除一个或一个以上的元素，返回true,。
boolean retainAll(Collection&lt;?&gt; c) :仅保留此 collection 中那些也包含在指定 collection 的元素,如果该操作改变了调用该方法的集合，则返回true
intsize() :返回此 collection 中的元素数。 Object[] toArray() :该方法把集合转换成一个数组，所有的集合元素变成对应的数组元素。
用Collection集合的一些方法操作集合里的元素。
使用Lambda表达式遍历集合 Java8为Iterable接口新增了一个forEach（Consumer action） 默认方法，该方法所需的类型是一个函数式接口，而Iteratle接口是Collection接口的父接口，因此Collection集合也直接调用该方法。
当程序调用Iterable的forEach(Consumeraction)遍历集合元素时，程序会依次将集合元素传给Consumer的accept（T t）方法（该接口唯一的抽象方法）。正因为Consumer是函数式接口，因此可以使用Lambda表达式来遍历集合元素。
使用Lambda表达式来遍历集合元素。
public class CollectionEach {
public static void main(String[] args) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abcc537ba7923f22851c2926d00b0be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7026244ab6489d8fce346fa48b298c6a/" rel="bookmark">
			An entity object cannot be referenced by multiple instances of IEntityChangeTracker错误解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		折腾了一晚上才搞明白，如果你也遇到该问题，那恭喜你不是第一个踩到这个坑的。
简而言之，对于有外键的数据模型，在进行数据库操作的时候不可以用不同的数据上下文来操作。
听起来有点抽象，我来举个栗子：
article类，主键int id，外键user userinfo
user类，主键int id，string username
当你在某个类里写了个方法new了个数据上下文td，用td.users.Where(u =&gt; u.username == username).FirstOrDefault()之类的方式操作数据库获取到一个user。
然后在其他地方调用这方法，准备将这个user作为外键，放到一个article.userinfo里，然后new个数据上下文插入数据库时，就会出现这个错误。
解决方法：在同一个数据上下文内操作外键数据，譬如：
TrDAL td = new TrDAL();
article article1=new article()
{
user=td.users.Where(u =&gt; u.username == username).FirstOrDefault();
};
td.articles.Add(article1);
td.SaveChanges();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac538ce148753fa07df31328d7badea/" rel="bookmark">
			ubuntu16开启root账号登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开启root账户登录 ubuntu16桌面版默认不开启root账户登录，按照以下步骤设置：
sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf
在末尾添加:
greeter-show-manual-login=true
保存修改后，sudo passwd root设置root用户密码，重启即可
登录root账户时报错：mesg:ttyname failed:Inappropriate ioctl for device 这是读取/root/.profile时发现错误：对设备不适当的ioctl操作，有两种方法解决：
将/root/.profile文件中的mesg n替换成
tty -s &amp;&amp; mesg n
重启
将非root账户目录中的.profile复制到/root/，例如：
cp /home/username/.profile /root/
重启
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33f2222e1db89672f5aebf1c443b729/" rel="bookmark">
			ASP.NET HttpContext.Current在新建线程中会返回null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先挖个坑，刚刚写异步方法的时候发现HttpContext.Current在新建线程里会返回null，如何异步调用还有待研究 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23eb005c01f390fb591c69f38b4ee739/" rel="bookmark">
			数据表自增ID，在删除全部行后插入新行ID如何再从1开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 truncate table [tablename] 即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1238bb29f852be071b1ca9814a0b33/" rel="bookmark">
			Windows服务器CPU使用过高(svchost.exe)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cpu使用率的查看一般可以通过任务管理器中的cpu使用百分比排序，依次查看哪些进程导致使用率过高。 不同的程序不同的处理。
以下主要讲解svchost.exe进场占用cpu过高的问题。
svchost.exe 进程，一般都是与系统服务相关的，大部分均是来自服务。 1、服务导致。找到cpu使用率比较大的进程，右键-》转到服务，若是是由服务启动的，会自动定位到相应的服务。 可以点击，右下角的服务按钮，开启服务管理，根据服务器名称查找到相应的服务，判定是否停止服务。(一般情况windows的自动更新服务，若是有待更新的信息时，或者取消更新后，可能导致占用cpu可能过高)
2、非服务导致。可以使用process Explorer程序查看进程的详细信息。process Explorer 非系统自带的需要网上自行下载。
process Explorer 简略使用说明 界面 查看进程的详细信息 可查看映像信息来确定，是为什么启动此进程。 路径：exe位置 命令行：启动的方式
详细例子分析： 遇到svchost使用率过高，但非服务导致服务器cpu使用率，80%。 路径：C:\windows\fonts\svchost.exe 命令行：”svchost.exe” -a cryptonight -o stratum+tcp://wakuang.aimezi.com:7777 -u 498PMu3rGgrXdv9b371URch3eDbEJqPnoXTp717FtUhvFuFSJfjY4Gf1chnSxVtTRoQCkfNRozGfBbDshdMDKhUQ358oQby -p x -t 24
查看此非系统服务，有点像是被植入挖矿病毒。强制关闭此进程，一会进程强制重启。不存在服务，那只能通过注册表进行查询。
开启注册表， 运行-》regedit 全文搜索 wakuang.aimezi.com 找到相应的注册表删除后。关闭此进程后问题解决。其实际的注册表目录[HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\services\Servc]
以下为此项中的全部信息，看到最后有个程序退出后重启的项。(以下请勿注册，以防系统出现问题，仅供学习)。
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\services\Servc] "Description"="Performance library information from Windows Management Instrumentation (WMI) providers to clients on the network. This service only runs when Performance Data Helper is activated.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1238bb29f852be071b1ca9814a0b33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d4db78ad5a581531773d37cf0f6b0b/" rel="bookmark">
			使用fastcoll进行md5碰撞，两个不同的文件md5值一样。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成两个文件
fastcoll_v1.0.0.5.exe -p C:\windows\notepad.exe -o D:\notepad1.exe D:\notepad2.exe
比较 md5 校验是一样的，但是文件内容不一样。
两个程序的文件内容不一样，运行的效果打印的东西不一样，一个打印循环打印Goodbye World，一个只打印Hello world。但是md5却一样。
使用 certutil 命令查看一下md5
说明了用 md5 做文件校验并不安全。
然后我们看一下SHA1的结果，两个文件的SHA1值不一样，是没有问题的。
文件下载地址：
http://www.win.tue.nl/hashclash/SoftIntCodeSign/HelloWorld-colliding.exe
http://www.win.tue.nl/hashclash/SoftIntCodeSign/GoodbyeWorld-colliding.exe
快速 MD5 碰撞生成器
http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip
源代码：
http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5_source.zip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37da5a6e7b2fdcb927a43794e3fefe4f/" rel="bookmark">
			Mysql5.6设置远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 root权限连接MySQL后
mysql&gt;use mysql; mysql&gt; GRANT ALL PRIVILEGES ON *.* TO root@"%" IDENTIFIED BY "root"; //为root添加远程连接的能力 mysql&gt; flush privileges; mysql&gt; exit mysql&gt;select host,user from user; //查看修改是否成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4151441b72bfef0cdde7f16886300a/" rel="bookmark">
			Eclipse防止定义变量名时后面追加类型后缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家使用eclipse或者MyEclipse敲代码的时候，是不是都被这样一个问题困扰着。就是你键入一个变量名的时候，会自动提示补全，就是在你的变量名后面加上类型的名字。 增强的补全功能，这个大家应该有设置吧。这么好用的功能。！！这里照顾一下新手，我先讲一下怎么设置增强的补全功能。。 一、打开 Eclipse -&gt; Window -&gt; Perferences 找到Java 下的　Editor 下的　Content Assist ,　右边出现的选项中，有一个Auto activation triggers for Java: 会看到只有一个"."存在。表示：只有输入"."之后才会有代码提示,把"."的地方修改成".abcdefghijklmnopqrstuvwsyzABCDEFGHIJKLMNOPQRSTUVWSYZ_" 点最下面的"OK"来保存设置。 Ps：如果你的版本比较低，不能直接修改的话，就导出配置文件，然后修改配置文件。最后再导入配置文件就可以了。。 二、接下来就是重点啦，按照下面的方法，就可以彻底解决eclipse帮你自动补全变量名了。 1,先找到相关的插件： window -&gt; show view -&gt; plug-ins 找到插件org.eclipse.jface.text,右键点击,选择import as Source Project,导入完成后,在你的workspace就可以看到这个project了 2.修改代码 在src/org/eclipse/jface/text/contentassist/CompletionProposalPopup.java文件中,找到这样一行代码 char[] triggers = t.getTriggerCharacter(); if(contains(triggers,key)) 在那行if判断里面,eclipse会判断key(就是你按下的键)是否在triggers中,如果是,那就触发下面的第一行提示上屏的代码.所以我们要做的就是把空格和=号排除就可以了: if(key != '=' &amp;&amp; key != 0x20 &amp;&amp;contains(triggers,key)){ ......... } 代码修改成这样后，提示的时候按下空格或者等号，提示就会没掉，也不会自动补全了咯！！！ 3.把修改好的org.eclipse.jface.text导出 右键点击你的workspace里的org.eclipse.jface.text,选择export--&gt;Deployable plugins and fragments, next,destination 选择 archive file，然后finish.你就可以在zip文件里看到生成好的jar ,用它替换掉eclipse/plugins里面的同名jar包,就可以了。 转载地址：http://www.cnblogs.com/w-wfy/p/5861274.html 修改后的插件下载地址： 点我下载jar 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f8faa77428106a71dab0a7524b6a61/" rel="bookmark">
			select * from a,b是否为内连接？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天代码中写脚本用了select * from a,b where a.id = b.id.然后同事说让我写内连接，我说这就是内连接啊。结果同事说这怎么会是内连接，这是笛卡尔乘积。我当时有点惊呆了，在原来公司都是这样写啊，难道这不是内连接，后来百度一下，发现：
单纯的select * from a,b是笛卡尔乘积。
但是如果对两个表进行关联:select * from a,b where a.id = b.id 意思就变了，此时就等价于：
select * from a inner join b on a.id = b.id。即就是内连接。
原来是这样。
但是据说这种写法并不符合规范，可能只对某些数据库管用，如sqlserver。推荐最好不要这样写。最好写成inner join的写法。
————
评论区的同学说以上实际也是笛卡尔乘积，只不过对a,b两表笛卡尔积结果进行了where限制；输出的结果等同于内连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20eec1d7f0f5784cbdf87a0ecc24c83/" rel="bookmark">
			在项目启动时（无request）获取Tomcat端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇说的将非Spring Boot项目注册到Eureka Server并提供服务也说到，配置文件里eureka.port必须要与本机tomcat端口号相同，但不同环境往往有不同的tomcat端口号，以往我使用不同环境的配置文件以确保eureka服务端口与tomcat一致。
1.读tomcat配置文件
这是最先想到的方法，通过classpath一层层找到conf下的server.xml拿端口号，因为路径基本不会变，所以也是一种方法，由于发现了更好的方法，此处并无代码…
2.通过Jmx 的MBeanServer
package com.kowalski.demo; import javax.management.MBeanServer; import javax.management.MalformedObjectNameException; import javax.management.ObjectName; import javax.management.Query; import java.lang.management.ManagementFactory; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.Set; public class IPAddressKowalski{ public static String getIpAddressAndPort() throws MalformedObjectNameException, NullPointerException, UnknownHostException { MBeanServer beanServer = ManagementFactory.getPlatformMBeanServer(); Set&lt;ObjectName&gt; objectNames = beanServer.queryNames(new ObjectName("*:type=Connector,*"), Query.match(Query.attr("protocol"), Query.value("HTTP/1.1"))); String host = InetAddress.getLocalHost().getHostAddress(); String port = objectNames.iterator().next().getKeyProperty("port"); String ipadd = "http" + "://" + host + ":" + port; System.out.println(ipadd); return ipadd; } public static int getTomcatPort() throws MalformedObjectNameException, NullPointerException { MBeanServer beanServer = ManagementFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a20eec1d7f0f5784cbdf87a0ecc24c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bb83fe897284bd01e0f6b6fdc018bd/" rel="bookmark">
			开发技术分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢大神，原帖链接http://bbs.pediy.com/showthread.php?t=182393 -------以下是转贴内容-----
看雪论坛视频篇 1、Win32Asm与RadAsm开发教程 链接: http://pan.baidu.com/s/1pJlW8T9 密码: pd94 2、浴血凤凰DNF辅助系列教材 链接: http://pan.baidu.com/s/1bnjA3j5 密码: pb1w 3、(零基础系列)黑客学习基地菜鸟系列之批处理教程 链接: http://pan.baidu.com/s/1eQ3horg 密码: iqc6 4、(零基础系列)黑客学习基地黑客攻防系列课程 链接: http://pan.baidu.com/s/1zR6d4 密码: gsco 5、Show me Why 软件破解(超强脱壳系列)VIP培训教程 链接: http://pan.baidu.com/s/1gdh05Q7 密码: nt9u 6、播布客VC网络项目实战共32集 链接: http://pan.baidu.com/s/1c0h6APy 密码: ipll 8、天道酬勤_delphi商业辅助开发教程 链接: http://pan.baidu.com/s/1sj8k2a5 密码: 316h 9、天道酬勤_VC++游戏辅助开发教程(第二套) 链接: http://pan.baidu.com/s/1c0syZcs 提取密码:yidn 10、天道酬勤DNF游戏辅助系列VIP培训教程 链接: http://pan.baidu.com/s/1qWCZrBI 密码: amvu 11、天道酬勤 VC++Com开发系列VIP培训教程 链接: http://pan.baidu.com/s/1sjsBwLn 密码: yxub 12、天道酬勤_VC++游戏辅助开发教程(第一套) 链接: http://pan.baidu.com/s/1kTHnlQn 密码: iywj 13、泰克CCSP课程-SNRS 链接: http://t.cn/RvcBiVD 17、Visual C++开发入行真功夫 链接: http://pan.baidu.com/s/1bn1l2Zd 密码: 9ojv 20、美河出品_六个月成为网络专家 链接: http://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38bb83fe897284bd01e0f6b6fdc018bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93cbfe65728992c175d410254e83670/" rel="bookmark">
			线性代数学习感悟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性代数学习感悟 目录 1 学习路线
1.1 实际学习路线
1.2 优化路线
2 《理解矩阵》读后感
2.1 句子摘抄
2.2 书籍推荐
1.学习路线 1.1实际学习路线 《线性代数》同济五版 + 《张宇带你学》精选书后习题 —&gt;&gt; 线性代数先修课（清华大学） 学堂在线 —&gt;&gt; 线性代数的本质（可汗学院）哔哩哔哩 —&gt;&gt; 《线性代数及其应用（原书第4版）》David C.Lay
1.2 优化路线 《线性代数及其应用（原书第4版）》David C.Lay ——&gt;&gt; 线性代数的本质（可汗学院）哔哩哔哩
2.《理解矩阵》读后感 2.1句子摘抄 如果不熟悉线性代数的概念，要去学习自然科学，现在看来就和文盲差不多。......线性代数是通过公理化来表述的，它是第二代数学模型。——Lars Garding
线性空间+范数 = 赋范线性空间
赋范线性空间 + 完备性 = 巴那赫空间
赋范线性空间 +角度　＝　内积空间
内积空间 + 完备性 = 希博尔特空间
凡是讨论数学问题，都得有一个集合。
容纳运动是空间的本质特征。
“空间”是容纳运动的一个对象集合，变化则规定了对应空间的运动。
向量是很厉害的，只要你找到合适的基，用向量可以表示线性空间里任何一个对象。
线性空间中的运动，被称为线性变换。
使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。
用向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。
矩阵的本质是运动的描述。
初等数学是研究常量的数学，是研究静态的数学，高等数学是变量的数学，是研究运动的数学。
矩阵是线性空间里跃迁的描述。
所谓变换，其实就是空间里从一个点（元素/对象）到另一个点（元素/对象）的跃迁。
尽管描述一个三维对象只需要三维向量，但所有的计算机图形学变换矩阵都是 \(4 \times 4\) 的，是因为计算机图形学里应用的图形变换，实际上是在仿射空间而不是向量空间中进行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93cbfe65728992c175d410254e83670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b35b92d9735e04de2cb4f349841e09/" rel="bookmark">
			caffe 网络结构参数介绍及可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		caffe/examples/mnist/lenet_solver.prototxt # The train/test net protocol buffer definition net: "examples/mnist/lenet_train_test.prototxt" //用户训练／预测的网络描述文件（ProtoBuffer文本格式） # test_iter specifies how many forward passes the test should carry out. ／／预测阶段迭代次数。在mnist例程下，预测样本组（test batch）大小为100 # In the case of MNIST, we have test batch size 100 and 100 test iterations, # covering the full 10,000 testing images. //设置预测阶段迭代次数为100可以覆盖全部10000个测试样本 test_iter: 100 # Carry out testing every 500 training iterations. //训练时每迭代500次，进行一次预测 test_interval: 500 # The base learning rate, momentum and the weight decay of the network.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b35b92d9735e04de2cb4f349841e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/672e7ec34a1237c58d2bc9076c00bca1/" rel="bookmark">
			Android自定义view最小刷新时间为16ms问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从安卓4.1以后,安卓框架所有的绘图和动画统一使用VSYNC计时锁定16ms响应,所以自定义view中的刷新时间一般是16ms.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1295181e7cee9f60139f9133ea9aafa7/" rel="bookmark">
			Python3 类包装实现多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#-*-encoding:utf-8-*-import threadingimport timeexitFlag = 0class myThread(threading.Thread):def __init__(self, threadID, name, delay):#用delay模拟运行时间threading.Thread.__init__(self)self.threadID = threadIDself.name = nameself.delay = delaydef run(self):print("Starting", self.name)threadLock.acquire()#获得锁，成功锁定后返回trueprint_time(self.name, self.delay, 5)threadLock.release()#释放锁，开启下一个线程print("Exiting",self.name)def print_time(threadName, delay, counter):while counter:if exitFlag:threadName.exit()time.sleep(delay)print("%s:%s"%(threadName, time.ctime(time.time())))counter -= 1threadLock = threading.Lock()threads = []#创建线程 thread1 = myThread(1, "thread-1", 1)thread2 = myThread(2, "thread-2", 1)thread3 = myThread(3, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1295181e7cee9f60139f9133ea9aafa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d99dd43ee50493ec90ecbef17e775aa/" rel="bookmark">
			PHP&#43;MySQL导出大量数据（Iterator yield）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中经常遇到这样的场景
产品汪：我要在后台做一个功能，可以导出自定义时间范围的订单信息。开发小哥二话不说，半天就把功能做完并上线了。结果，第二天一上班产品汪过来就是拍桌子：MD，我想把去年一整年的订单都导出来，结果后台直接就挂了！
开发小哥一查，原来是内存溢出了，一年下来的的订单量足足有1000W条。于是，开发小哥跟产品汪吵了起来：你TM色不色傻，1000W的数据你导出来干diao，你是不是想把服务器给搞挂掉？
于是，产品汪与程序狗就这么结下梁子了。
但是。产品的需求你敢这样怼回去，那如果是老板提的这个需求呢，就是硬要把1000W条记录导出来，你还不得乖乖回去码代码？
那么，这个如果真要导出这大量数据，该怎么做呢？开发中我们经常会使用框架来提高我们的开发效率，但也意味着框架会对一些数据进行封装。
比如Yii2，当我们想获取去年一年的订单时，我们的代码会这样写：
Order::find()-&gt;where("create_time between '2016-01-01' AND '2016-12-31'")-&gt;all();
当我们将上面代码得到的结果集再拿去遍历时，数据量一大，就会内存溢出。 原因是：Yii2中，对all方法进行了封将，将大量的数据存入了数组中，而遍历大数据，必然会导致内存迅速上升。 那如何取出大量数据，而又不存到数组中呢？这就要用到了PHP中的迭代器：Iterator。如果有看过PDO::query的返回值类型的话，我们会发现，这个方法返回的 PDOStatement，正是对 Iterator 的实现。关于 Iterator，请自行脑补。
即然框架帮我们做了多余的封装，那么我们就改用原生API来实现。以下是完整代码
$sql = 'select * from user'; $pdo = new \PDO('mysql:host=127.0.0.1;dbname=test', 'root', 'root'); $pdo-&gt;setAttribute(\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false); $rows = $pdo-&gt;query($sql); $filename = date('Ymd') . '.csv'; //设置文件名 header('Content-Type: text/csv'); header("Content-Disposition: attachment;filename={$filename}"); $out = fopen('php://output', 'w'); fputcsv($out, ['id', 'username', 'password', 'create_time']); foreach ($rows as $row) { $line = [$row['id'], $row['username'], $row['password'], $row['create_time']]; fputcsv($out, $line); } fclose($out); $memory = round((memory_get_usage() - $startMemory) / 1024 / 1024, 3) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d99dd43ee50493ec90ecbef17e775aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e61829196b53f147801243313f71e2/" rel="bookmark">
			新命令在Centos 7快速开启端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近安装了CentOS7.3.1611之后，使用redis时，发现无法使用iptables控制Linux的端口，百度之后发现Centos 7.3使用firewalld代替了原来的iptables。下面这篇文章将给大家介绍如何在Centos 7.3中使用firewalld快速开发端口，
一、介绍 CentOS 7 默认没有使用iptables，所以通过编辑iptables的配置文件来开启80端口是不可以的，
防火墙守护 firewalld 服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。
CentOS 7 采用了 firewalld 防火墙
1.如何查询是否开启6379端口： [root@localhost ~]# firewall-cmd --query-port=6379/tcp no 注：no 表示端口没有开启。
2.开启6379端口： [root@localhost ~]# firewall-cmd --add-port=6379/tcp success 注：success 表示开启了6379端口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb2b8cbab100ec71acce5e6d66797a0/" rel="bookmark">
			SQL SERVER 注册服务器使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql server 远程连接服务器时，常用的服务器信息：服务器名称信息，登录名，密码等信息。通过连接-》数据库引擎中的记住密码，能记住一段时间，且无法快速识别此连接是那个数据库的。 1、注册服务器：视图-》已注册服务器 。打开管理面板 2、管理已注册服务器的信息，可以分组进行管理。右键-》新建服务器组，输入组名称进行管理。 3、新建服务器注册，对数据库登录信息进行管理。录入相应的登录信息，已注册的服务器名称，可以起一个易于识别的名称进行存储。
4、下次登录时直接双击列表中的注册服务器，即可快速登录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7cd9bc071e4f3bcf0b44e67859e17a7/" rel="bookmark">
			java通过HttpServletRequest获取post请求中的body内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java web应用中，我们如何获取post请求body中的内容？以及需要注意的问题。
通常利用request获取参数可以直接通过req.getParameter(name)的方式获取url上面或者ajax data提交上来的参数。但是body是没有名字的，无法通过参数名字这种方式获取。这时候需要用到io流的方式来获取body中的内容。
这里先贴出一段代码：
package com.lenovo.servlet; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.lang.StringUtils; import org.apache.log4j.Logger; import com.alibaba.dubbo.common.utils.IOUtils; import com.lenovo.service.BusinessService; import com.lenovo.utils.WebContext; public class BusinessServlet extends HttpServlet{ public static final Logger log = Logger.getLogger(BusinessServlet.class); /** * */ private static final long serialVersionUID = 1L; private static BusinessService service; static{ service = (BusinessService) WebContext.getBean("businessService");	} @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7cd9bc071e4f3bcf0b44e67859e17a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f4ed903d6d52bf25ffe4dd3e0ec5331/" rel="bookmark">
			360网站安全提示＂X-Frame-Options头未设置＂怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X-Frame-Options 响应头 X-Frame-Options HTTP响应头是用来确认是否浏览器可以在frame或iframe标签中渲染一个页面，网站可以用这个头来保证他们的内容不会被嵌入到其它网站中，以来避免点击劫持。
危害： 攻击者可以使用一个透明的、不可见的iframe，覆盖在目标网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击iframe页面的一些功能性按钮上，导致被劫持。
X-Frame-Options 响应头 X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 &lt;frame&gt;, &lt;/iframe&gt; 或者 &lt;object&gt; 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。
使用 X-Frame-Options X-Frame-Options 有三个值:
DENY 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN 表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM uri 表示该页面可以在指定来源的 frame 中展示。 换一句话说，如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。
配置 Apache 配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 ‘site’ 的配置中:
Header always append X-Frame-Options SAMEORIGIN 1 1 配置 nginx 配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’ 的配置中:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f4ed903d6d52bf25ffe4dd3e0ec5331/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d4e2764b4d9f439bd19b465cdb11943/" rel="bookmark">
			错误ORA-06512的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接
终于找到毛病了，原来是没有权限。虽然当前用户执行语句是有权限的，但是放到存储过程中就必须要显式的赋个权限给当前用户。以下是我找到的资料，贴出来给大家也看一下吧。 ===================== 【IT168 技术文档】我们知道，用户拥有的role权限在存储过程是不可用的。如： SQL&gt; select * from dba_role_privs where grantee= 'SUK' ; GRANTEE GRANTED_ROLE ADMIN_OPTION DEFAULT_ROLE ------------ ------------ ------------ ------------ SUK DBA NO YES SUK CONNECT NO YES SUK RESOURCE NO YES --用户SUK拥有DBA这个role --再创建一个测试存储过程： create or replace procedure p_create_table is begin Execute Immediate 'create table create_table(id int)' ; end p_create_table; --然后测试 SQL&gt; exec p_create_table; begin p_create_table; end ; ORA-01031: 权限不足 ORA-06512: 在 "SUK.P_CREATE_TABLE" , line 3 ORA-06512: 在line 1 --可以看到，即使拥有DBA role，也不能创建表。role在存储过程中不可用。 --遇到这种情况，我们一般需要显式进行系统权限，如grant create table to suk; --但这种方法太麻烦，有时候可能需要进行非常多的授权才能执行存储过程 --实际上，oracle给我们提供了在存储过程中使用role权限的方法： --修改存储过程，加入Authid Current_User时存储过程可以使用role权限。 create or replace procedure p_create_table Authid Current_User is begin Execute Immediate 'create table create_table(id int)' ; end p_create_table; --再尝试执行： SQL&gt; exec p_create_table; PL/SQL procedure successfully completed --已经可以执行了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945b74bf76f9632acd3a1c2099b9bb8c/" rel="bookmark">
			【视频开发】【电子电路技术】监控球机PTZ的功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要分模拟球机和网络球机两种 1.模拟球机 模拟球机除了需要接电源外，还需要接视频线和485控制线才能实现视频传输和云台控制，并且需要配置波特率，地址位和协议。 升级版：HDTVI球机 ① 同轴视控。搭配HDTVI录像机，不用再接485线，不用配置485信息，可看即可控。 ② 模拟高清。清晰度大大提升，有720P，1080P和300w可选，让视频更加清晰。 2. 网络球机 网络球机则直接是通过一根网线传输视频信号和控制信号，无需485线。支持网页web 访问球机IP 地址，可以实时预览，回放和配置。 云台功能配置 以下介绍的配置以录像机本地接显示器，进入主菜单——通道管理——云台配置举例，云台功能配置也支持网页登录球机IP 地址配置。 预置点 预置点是对球机云台坐标位置，镜头变倍参数等信息的记忆，调用预置点时球机自动运行到该预置点信息所对应的位置状态。 配置要点：把球机转动到想要的位置，点击预置点X的“设置”或者“编辑”。（X为预置点的序号，海康球机一般共支持256个预置点） 巡航 把多个预置点串起来，形成一个线路，设置好后调用巡航，球机会自动重复这个线路。 配置要点：设好几个预置点后，点击巡航的设置，把每个预置点都添加进去，配好每个点停留的时间和点到点的速度。 轨迹/花样扫描 花样扫描功能是记录球机的一组操作动作，可被记录的操作包括云台的水平，垂直运动，变倍操作，预置点调用。 配置要点：点击“开始记录”，手动控制球机进行一系列的操作，完成后点击“结束记录”。 云台功能调用 设置好后，可以到录像机预览界面，右键单击，选择“云台控制”。 调用预置点预置点，调用巡航，调用轨迹即可。 PTZ功能介绍 以下再给大家介绍的PTZ容易被忽略的功能 。 3D定位 通过鼠标点击图像某一点，即可将点视频画面转移至屏幕中心，鼠标拖动控制，场景放大缩小，便于跟踪车辆，行人等。 守望 当在一段时间内没有控制信号到来时，如果有预设的自动运行动作，球机就会执行该动作。 守望支持预置点、花样扫描、巡航扫描、水平扫描、垂直扫描、随机扫描、帧扫描、全景扫描等。 定时任务 球机在设定时间段内执行设定的动作，设定相应运作包括：预置点、花样扫描、巡航扫描、水平扫描、垂直扫描、随机扫描、帧扫描、全景扫描。 掉线记忆 球机重启后自动回到开机前的状态，包括云台状态、镜头状态。 转载于:https://www.cnblogs.com/huty/p/8517159.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d90e15ec8b1965d56bdcc06206a2142/" rel="bookmark">
			RestTemplate 中文乱码配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		restTemplate作为spring web client下的一个工具类 对http请求做了一层封装，用起来也更加简洁容易，但最近遇到一个问题就是在发送请求时由于请求中包含中文导致乱码，都变成???????一堆问号，网上很多解决方案，但很多都比较…..
先看说如何解决： @Bean配置方法：
@Bean public RestTemplate restTemplate() { RestTemplate restTemplate = new RestTemplate(); restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); return restTemplate; } applicationContext.xml配置方法：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-autowire="byName" default-lazy-init="true"&gt; &lt;!--方式一、使用jdk的实现--&gt; &lt;bean id="ky.requestFactory" class="org.springframework.http.client.SimpleClientHttpRequestFactory"&gt; &lt;property name="readTimeout" value="10000"/&gt; &lt;property name="connectTimeout" value="5000"/&gt; &lt;/bean&gt; &lt;bean id="simpleRestTemplate" class="org.springframework.web.client.RestTemplate"&gt; &lt;constructor-arg ref="ky.requestFactory"/&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.FormHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 然后在使用的地方自动注入就好啦~~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d90e15ec8b1965d56bdcc06206a2142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bcfdca91e34b050ad0bba9f3bcf3e83/" rel="bookmark">
			网络共享遇到系统错误1219   “不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接。中断与此服务器或共享资源的所有连接，然后再试一次。”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用命令：net use * /del /y
先删除所有连接
再使用共享：
net use \\192.168.192.2\itdev password /user:username
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e12694e50075a222b93ad533739df7b/" rel="bookmark">
			char data[0]问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：当进行内存管理时，经常需要一个额外的结构，例如
struct MyData
{
char*data; // 指向分配的内存空间
intlen; // 记录空间大小
};
这样，需要进行四步操作，先分配MyData结构体，再分配要管理的内存，再让data指针指向该内存空间，再把空间大小赋给len。问题，该结构在64位系统上sizeof结果是多少？可以修改结构体的情况下有什么办法能够减少操作？
这实际上是有关char data[0]的问题。
struct MyData {
int len;
char data[0]; // 一定是结构体的最后一个字段，且前面必须有其他字段
};
在结构中，data是一个数组名；但该数组没有元素；由于数组没有元素，该数组在该结构体中不占用空间，所以sizeof(struct Mydata) = 4，这不同于char* data，要占用一个指针的大小（32位系统下4字节，64位系统8字节）。该数组的真实地址紧随结构体MyData之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）；这种声明方法可以巧妙的实现C语言里的数组扩展。
使用：
struct MyData *p = (struct MyData *)malloc(sizeof(struct MyData)+strlen(str))
这样就可以通过p-&gt;data 来操作这个str。
这是个广泛使用的常见技巧，常用来构成缓冲区。比起指针，用空数组有这样的优势：
1.不需要初始化，数组名直接就是所在的偏移；
2.不占任何空间，指针需要占用空间；
3.结构体和内存可以一起分配，连续空间。
一次分配解决问题，省了不少麻烦。大家知道为了防止内存泄漏，如果是分两次分配（结构体和缓冲区），那么要是第二次malloc失败了，必须回滚释放第一个分配的结构体。这样带来了编码麻烦。其次，分配了第二个缓冲区以后，如果结构里面用的是指针，还要为这个指针赋值。同样，在free这个buffer的时候，用指针也要两次free。如果用空数组，所有问题一次解决。
其次，大家知道小内存的管理是非常困难的，如果用指针，这个buffer的struct部分就是小内存了，在系统内存在多了势必严重影响内存管理的性能。要是用空数组把struct和实际数据缓冲区一次分配大块问题，就没有这个问题。
补充说明：
char data[0]柔性数组，只能放在struct末尾，表示该struct是可变长度的，多余的容量分配给data数组，实现可变长度的数组。
在早期有些技术牛人都爱这样写，不过在今天这是一种不安全的写法，不推荐，不要指望在所有的编译器上都能得到比想要的结果。
char data[0]是否合法？
ISO/IEC 9899-1999里面，这么写是非法的，这个仅仅是GNU C的扩展，gcc可以允许这一语法现象的存在。
结构体最后使用0或1的长度数组的原因，主要是为了方便的管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，（见下面的例子），反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。
其实就是分配一段连续的的内存，减少内存的碎片化。
这个仅仅是在C99没有出台的情况下，gcc为了使用类似于C99 flexible array member而做出的一个work-around，但是现在C99出现了，并且正式支持了flexiblearray member的语法，这样的一个GNU C扩展就有点显得不合时宜了……按照ISO/IEC 9899-1999的要求，flexible array member的定义应当是这样：
struct foo
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e12694e50075a222b93ad533739df7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03374069d8343edd6f61c52e5d96aec8/" rel="bookmark">
			Mongodb基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mongodb基础操作
1、 下载mongodb，下载地址：https://www.mongodb.com/download-center#community，这里使用的是mongodb3.4.2版本进行讲解
2、 安装
下载后双击该文件，按操作提示安装即可。
安装过程中，你可以通过点击 "Custom(自定义)" 按钮来设置你的安装目录。
3、 在mongodb的安装路径下，新建一个data目录，在data目录中再新建一个db目录，用于存放数据库的数据文件（因为这些目录mongodb安装后不会自动创建，所以需要手动创建）
4、 启动mongodb服务，有两种方式：
1） 进入mongodb安装目录中的bin目录（或者也可以配置环境变量，这样就可以在任何目录下执行mongodb的命令了），执行mongod.exe文件，如：
mongod.exe --dbpath c:\data\db 这里的路径是自己创建存放数据文件的路径
2） 将MongoDB服务器作为Windows服务运行（创建服务后，以后方便些）
使用管理员权限打开cmd，执行如下命令：
mongod.exe --bind_ip yourIPadress --logpath"C:\data\dbConf\mongodb.log" --logappend --dbpath"C:\data\db" --port yourPortNumber --serviceName"YourServiceName" --serviceDisplayName "YourServiceName" –install
上面这段配置，需要根据自己的环境，更改yourIPadress、logpath、yourPortNumber 、dbpath、serviceName、serviceDisplayName的值
下面为mongodb启动的参数说明：
--bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP
--logpath 定MongoDB日志文件，注意是指定文件不是目录
--logappend 使用追加的方式写日志
--dbpath 指定数据库路径
--port 指定服务端口号，默认端口27017
--serviceName 指定服务名称
--serviceDisplayName 指定服务名称，有多个mongodb服务时执行。
--install 指定作为一个Windows服务安装。
一个修改好了的完整的配置：
mongod.exe--bind_ip localhost --logpath "D:\Program Files\MongoDB\data\dbConf\mongodb.log"--logappend --dbpath "D:\Program Files\MongoDB\data\db" --port 27017--serviceName "mongodb" --serviceDisplayName "mongodb" –install
5、 登录mongodb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03374069d8343edd6f61c52e5d96aec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76929193d29b164e294034df081c9ccc/" rel="bookmark">
			mySQL （关系型数据库管理系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。
MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
由于其社区版的性能卓越，搭配 PHP 和 Apache 可组成良好的开发环境。
应用环境
与其他大型数据库相比例如 Oracle、DB2、SQL Server，MySQL 自有它的不足之处，但是这丝毫也没有减少它受欢迎的程度。对于一般的个人使用者和中小型企业来说，MySQL提供的功能已经绰绰有余，而且由于 MySQL是开放源码软件，因此可以大大降低总体拥有成本。
Linux作为操作系统，Apache 或Nginx作为 Web 服务器，MySQL 作为数据库，PHP/Perl/Python作为服务器端脚本解释器。由于这四个软件都是免费或开放源码软件（FLOSS)，因此使用这种方式不用花一分钱（除开人工成本）就可以建立起一个稳定、免费的网站系统，被业界称为“LAMP“或“LNMP”组合。
系统特性
1．使用 C和 C++编写，并使用了多种编译器进行测试，保证了源代码的可移植性。
2．支持 AIX、FreeBSD、HP-UX、Linux、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows等多种操作系统。
3．为多种编程语言提供了 API。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby,.NET和 Tcl 等。
4．支持多线程，充分利用 CPU 资源。
5．优化的 SQL查询算法，有效地提高查询速度。
6．既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入到其他的软件中。
7．提供多语言支持，常见的编码如中文的 GB 2312、BIG5，日文的 Shift_JIS等都可以用作数据表名和数据列名。
8．提供 TCP/IP、ODBC 和 JDBC等多种数据库连接途径。
9．提供用于管理、检查、优化数据库操作的管理工具。
10．支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
11．支持多种存储引擎。
12.MySQL 是开源的，所以你不需要支付额外的费用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76929193d29b164e294034df081c9ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd0a767a3b852ccd779f2639cdf8a023/" rel="bookmark">
			缺失数据处理-插值法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 在数据挖掘中，原始数据中存在着大量不完整、偏离的数据。这些问题数据轻则影响数据挖掘执行效率，重则影响执行结果。因此数据预处理工作必不可少，而其中常见工作的就是数据集的缺失值处理。
数据缺失值处理可分两类。一类是删除缺失数据，一类是进行数据插补。前者比较简单粗暴，但是这种方法最大的局限就是它是以减少历史数据来换取数据的完备，会造成资源的大量浪费，尤其在数据集本身就少的情况下，删除记录可能会直接影响分析结果的客观性和准确性
本文介绍数据常用的插补方法。对拉格朗日插值法和滑动平均窗口法进行重点介绍和实现。
2. 介绍 2.1 常用的插值方法如下： 这里只对插值法和窗口滑动平均进行介绍。
2.2 滑动平均窗口法 一个列表a 中的第 i 个位置数据为缺失数据，则取前后 window 个数据的平均值，作为插补数据。例如：
a = [3,4,5,6,None,4,5,2,5] 、 window = 3
则 None位置的数据为：(4+5+6+4+5+2)/6 = 2.67
2.3 拉格朗日插值法 根据数学概念可知，对于平面上已知的n个点（无两点在一条直线上）可以找到一个n-1次的多项式，使此多项式通过这n个点。
因此我们需先求得多项式函数L(x)，然后将缺失值对应的点x带入插值多项式得到缺失值的近似值L(x)。多项式函数L(x)的求法如下：
3. 实现 3.1 代码 # coding:utf-8 # 拉格朗日插值代码 import pandas as pd # 导入数据分析库Pandas from scipy.interpolate import lagrange # 导入拉格朗日插值函数 # 构建原始数据 data = pd.DataFrame([ ["2015/3/1", 59], ["2015/2/28", 2618.2], ["2015/2/27", 2608.4], ["2015/2/26", 2651.9], ["2015/2/25", 3442.1], ["2015/2/24", 3393.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd0a767a3b852ccd779f2639cdf8a023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4099c1a6ae712dbfe9d465069e587287/" rel="bookmark">
			arduino读取处理UWB（匿名科技的）数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		byte inbyte[19];
int h[13];
void setup() { Serial.begin(115200); //设置串口波特率
} void loop()
{
while (Serial.available() &gt; 0) { //判断是否获取到数据
for(int b=0;b&lt;19;b++){ //19个字节为一组
inbyte[b]=Serial.read(); //获取数据
// delay(10);
if(inbyte[b]==170&amp;&amp;inbyte[b+1]==48) //识别标识位（手册可查）
{for(int a=b+4;a&lt;b+12;a+=2){
h[a] = (inbyte[a]/16)*16*16*16+(inbyte[a]%16)*16*16+inbyte[a+1]; //根据规则计算出实际测量距离
Serial.print(h[a]); //输出
Serial.print(",");
Serial.write(16);
}
}
}
Serial.println();
while(Serial.read() &gt;= 0){} } delay(2);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61eb5188940ed4260a255deb2840dcc1/" rel="bookmark">
			Oracle创建表语句(Create table)语法详解及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle创建表语句(Create table)语法详解及示例 创建表(Create table)语法详解 1. ORACLE常用的字段类型
ORACLE常用的字段类型有 VARCHAR2 (size) 可变长度的字符串, 必须规定长度 CHAR(size) 固定长度的字符串, 不规定长度默认值为１ NUMBER(p,s) 数字型p是位数总长度, s是小数的长度, 可存负数，最长38位. 不够位时会四舍五入. DATE 日期和时间类型 LOB 超长字符, 最大可达4G CLOB 超长文本字符串 BLOB 超长二进制字符串 BFILE 超长二进制字符串, 保存在数据库外的文件里是只读的.数字字段类型位数及其四舍五入的结果 原始数值1234567.89 数字字段类型位数 存储的值 Number 1234567.89 Number(8) 12345678 Number(6) 错 Number(9,1) 1234567.9 Number(9,3) 错 Number(7,2) 错 Number(5,-2) 1234600 Number(5,-4) 1230000 Number(*,1) 1234567.9
2. 创建表时给字段加默认值 和约束条件 创建表时可以给字段加上默认值 例如 : 日期字段 DEFAULT SYSDATE 这样每次插入和修改时, 不用程序操作这个字段都能得到动作的时间 创建表时可以给字段加上约束条件 例如: 非空 NOT NULL 不允许重复 UNIQUE 关键字 PRIMARY KEY 按条件检查 CHECK (条件) 外键 REFERENCES 表名(字段名) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61eb5188940ed4260a255deb2840dcc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c7e8663e1670f44f0f289b92483a17/" rel="bookmark">
			C#调用java程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为项目交接需要，需要用C#提交一个估算草原干旱指数的WinForm程序。这个算法师兄已经用Java实现了，再用C#重写一个Java程序显然太费时了。于是问题就变成了我想要在.NET平台上用C#完成Java的部分功能。应该如何让C#调用Java编译好的Jar包呢。 最容易想到解决方案就是的将java的jar包转换为.dll控件，再在C#项目中添加所需的控件实现调用，具体实现方法见：C#实现调用Java类中方法 然而实际操作中因为算法的Java实现依赖于欧空局Java开源遥感处理库BEAM，转为.dll时依赖关系太复杂，不太好操作。 于是就换了个思路，直接在C#中使用Process新开一个java进程调用.jar包。这里的path1-10为文件路径，p_Exited()为进程结束事件。
Process p = new Process(); string path11 = " -Xmx2048M -jar ./java/GDI.jar " + path1 + " " + path2 + " " + path3 + " " + path6 + " " + path4 + " " + path9 + " " + path8 + " " + path5 + " " + path7 + " " + path10; p.StartInfo.FileName = "java.exe"; p.StartInfo.UseShellExecute = false; p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c7e8663e1670f44f0f289b92483a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b527666b89a43e9bda6102584f1556da/" rel="bookmark">
			圆和椭圆的扫描转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c/c++ code voidCMy1400801119View::OnDraw(CDC* pDC) { CMy1400801119Doc* pDoc = GetDocument(); ASSERT_VALID(pDoc); // TODO: add draw code for native data here int R=100; int x0=0,y0=R; int x,y,e; e=1-R; x=x0; y=y0; while(y&gt;=x){ pDC-&gt;SetPixel(x+300,y+300,RGB(20,180,29)); pDC-&gt;SetPixel(x+300,-y+300,RGB(20,180,29)); pDC-&gt;SetPixel(-x+300,y+300,RGB(20,180,29)); pDC-&gt;SetPixel(-x+300,-y+300,RGB(20,180,29)); pDC-&gt;SetPixel(y+300,x+300,RGB(20,180,29)); pDC-&gt;SetPixel(y+300,-x+300,RGB(20,180,29)); pDC-&gt;SetPixel(-y+300,x+300,RGB(20,180,29)); pDC-&gt;SetPixel(-y+300,-x+300,RGB(20,180,29)); if(e&lt;0){ e=e+2*x+3; x=x+1; } else{ e=e+2*(x-y)+5; x=x+1; y=y-1; } } float RR=100; float xx0=0,yy0=RR; float xx,yy; xx=xx0; yy=yy0; float a2=150*150,b=100,b2=100*100;floatee1,ee2; ee1=b2+a2*(-b+0.25); while(b2*(xx+1)&lt;a2*(yy-0.5)){ pDC-&gt;SetPixel(xx+600,yy+300,RGB(20,180,29)); pDC-&gt;SetPixel(xx+600,-yy+300,RGB(20,180,29)); pDC-&gt;SetPixel(-xx+600,yy+300,RGB(20,180,29)); pDC-&gt;SetPixel(-xx+600,-yy+300,RGB(20,180,29)); if(ee1&lt;0){ ee1=ee1+b2*(2*xx+3); xx=xx+1; } else{ ee1=ee1+b2*(2*xx+3)+a2*(-2*yy+2); xx=xx+1; yy=yy-1; } } ee2=b2*(xx+0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b527666b89a43e9bda6102584f1556da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a847df1efd782e9526759619f91b9cb0/" rel="bookmark">
			【电子产品】ThinkPad S5   Intel(R) Dual Band Wireless-AC 3165 网卡驱动莫名其妙挂掉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备管理器 检查网卡驱动和网络设备 设备管理器 – 网络设备 Intel(R) Dual Band Wireless-AC 3165 出现黄色感叹号。
该设备无法启动。 (代码 10) Intel(R) Dual Band Wireless-AC 3165 属性
常规 – 设备状态 该设备无法启动。 (代码 10)
{操作失败}
请求的操作不成功。
检查网络设置 – 找不到Wlan选项卡 检查网络连接【更改适配器选项】 – 也没有WLAN的网络设备 更新驱动程序软件 - Intel(R) Dual Band Wireless-AC 3165 您希望如何搜索驱动程序软件？ →自动搜索更新的驱动程序软件（S）
Windows将在你的计算机和Internet上查找用于相关设备的最新驱动程序软件，除非在设备安装设备中禁用该功能。
已安装合适设备的最佳驱动程序软件 Windows已确定该设备的驱动程序软件是最新的。
Intel(R) Dual Band Wireless-AC 3165
解决方案： 从已经按照的驱动中选择合适的驱动，如果最新的有问题就换老版本驱动。
设备管理器 -&gt; 更新驱动程序软件（P）… 更新驱动程序软件 - Intel(R) Dual Band Wireless-AC 3165 您希望如何搜索驱动程序软件？ →自动搜索更新的驱动程序软件（S）
Windows将在你的计算机和Internet上查找用于相关设备的最新驱动程序软件，除非在设备安装设备中禁用该功能。
→浏览计算机以查找驱动程序软件(R)
手动查找并安装驱动程序软件
浏览计算机上的驱动程序文件 在一下位置搜索驱动程序软件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a847df1efd782e9526759619f91b9cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b282c2a05d90605bbd7eb5e092c41b/" rel="bookmark">
			C&#43;&#43;学习（23）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分析下述代码运行：
#include&lt;iostream&gt; using namespacestd; int main() { int a[10]={0,1,2,3,4,5,6,7,8,9}; int *p=a; cout&lt;&lt;p[6]&lt;&lt;""&lt;&lt;*(a+6)&lt;&lt;" "&lt;&lt;*(p+6)&lt;&lt;""&lt;&lt;p+6&lt;&lt;endl; return 0; } 2、用关键字virtual修饰的成员函数叫做虚函数，虚函数是为了实现多态而存在的，必须有函数体；
纯虚函数的声明，是在虚函数声明的结尾加=0，没有函数体。在派生类中没有重新定义虚函数之前是不能调用的纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加"=0"
如果一个类中至少含有一个纯虚函数，此时称之为抽象类。所以抽象类一定有纯虚函数
基类类型的指针可以指向任何基类对象或派生类对象
3、下列代码输出结果？
auto fn(unsignedchar a) {
cout&lt;&lt;std::hex&lt;&lt;(int)a&lt;&lt;endl;
}
fn(-1);
分析：32位-1的原码1000 0000 0000 0001 补码1111 1111 1111 1111（求反加一）
则fn()后8位为1111 1111
int 后0000 0000 1111 1111
Hex16进制后ff
int型-1的存储方式为补码（32位，4字节），1111 1111 1111 1111
转换为unsigned char（8位，1字节）发生字节截断，取最后八位为1111 1111 ；
再转换为int后为0000 0000 0000 0000 0000 0000 1111 1111 ，即为ff
4、
#include&lt;iostream&gt; #include&lt;string.h&gt; using namespacestd; struct st_t{ int status; short *pdata; char errstr[32]; }; int main() { st_t st[16]; char *p=(char *)(st[2].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b282c2a05d90605bbd7eb5e092c41b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320bf391cbe06e1d87992d8e56213f6a/" rel="bookmark">
			二分法查找示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二分法，又称分半法，是一种方程式根的近似值求法。对于区间[a,b]上连续不断且f(a) ·f(b)&lt;0的函数y=f(x)，通过不断地把函数f(x)的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫做二分法(bisection)。
&lt;?php function binarySearch($a, $val){ $low = 0; $high= count($a) - 1; while($low &lt;= $high){ $mid = intval(($low+$high)/2); if($a[$mid] == $val) return $mid; if($a[$mid] &gt; $val){ $high = $mid - 1; }else{ $low = $mid + 1; } } return -1; } $a=array(8888,56,1,29,3,448,4,5,8,69,22,81,9999,100,555);//先从小到大排序，再进行二分 echo "你查找的数是从左到右第".(binarySearch($a,100)+1)."个数"; ?&gt; 结果: 你查找的数是从左到右第14个数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905be0278a817df2128a245721613fc3/" rel="bookmark">
			java调用批处理bat文件调用python pdfkit把动态html转pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中用到生成pdf征信报告的需求，最近尝试了好多方法
1.传统的方法，使用pdfbox itext方法，生成的pdf不仅难看，而且不容易控制
2.freemarker技术，首先创建个word模板，转xml模型，通过freemarker技术填充数据到xml模型中，生成word文件，然后转pdf文件。
这种方法，适合于表格填充数据，我就不贴代码了
3.wkhtmltopdf技术，这种html直接转pdf的方法，因为我用java来开发的，好多参数不管用，封面控制，页头，页尾不好控制
4.python pdfkit技术。最后我用的这种方法，因为我不是很懂python开发，既然用到了这个技术，我花了一天来研究，能写些简单的脚本语言就可以了。
总是思路，首先html预览数据样式，可以加入一些echarts效果图等，然后java调用bat批处理文件，把当前html转成pdf文件，最后html页面下载并预览本地磁盘文件。
这里碰到个很头疼的问题，java直接调用python是可以的，也可以传入参数，但是python脚本中加入了页头，页尾和封面等等 主要是import pdfkit 不能直接调用，所以最后写了个批处理文件来启动这个python脚本。很无语。
下面贴代码
java调用bat文件出
python脚本
当然由于不能直接调用pthon传入参数 所有这里使用的是 pdfkit.from_url方法，这里有个问题，如果你的html数据是动态渲染的，请求时间不能太长，否则转成的pdf是空的。 然后就是页面下载并预览本地磁盘的pdf文件了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa2239551d2dda4e08a4e2dda15a87d/" rel="bookmark">
			基于OpenCV和VTK的冠脉三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
具体文献可以参考：
1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献
这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。
图A 图B
图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。
有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。
匹配的结果如下：
上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。
以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）
/*-----Editored by HuangWang-2017年2月21日-----*/ /*-----功能描述：读取手工匹配的两幅冠脉造影的二维匹配点坐标,*/ /*-----利用冠脉造影算法进行三维点重建，并在VTK中使用大小不一的圆柱管道进行重建-----*/ /*-----程序员专用分割线-----*/ //包含C++标准输入输出头文件，用到的OpenCV类以及VTK类的头文件 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;math.h&gt; #include &lt;vector&gt; #include &lt;vtkActor.h&gt; #include &lt;vtkCamera.h&gt; #include &lt;vtkCellArray.h&gt; #include &lt;vtkPoints.h&gt; #include &lt;vtkPolyData.h&gt; #include &lt;vtkPolyDataMapper.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkProperty.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa2239551d2dda4e08a4e2dda15a87d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803bb6fd00e11b46988cf1a91cefee68/" rel="bookmark">
			解决“error C2872: “ACCESS_MASK”: 不明确的符号	“报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了给程序添加延时System(1000),添加windows.h头文件。发生报错。
”error C2872: “ACCESS_MASK”: 不明确的符号 “报错原因是在winnt.h中也有一个cv的命名空间，与opencv的cv::ACCESS_MASK发生冲突。
故使用opencv中的延时函数
cvWaitKey(1000)； 代替
#include &lt;windows.h&gt; System(1000) 就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b19a3962a00a111703c03df053b6075/" rel="bookmark">
			明朝首辅/太师，辅佐明朝四代国之重臣杨士奇后世传人在松滋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明朝首辅/太师，辅佐明朝四代国之重臣杨士奇后世传人在松滋
杨氏60字家谱
建林远发枝，永志必丹忠，
春一大邦首，兴开起秀龙，
太运贞元会，英俊明圣逢，
治安尚文德，辅政用武功，
道学传心法，训诲尊孔孟，
相贤克纯祖，荣华颖应宗。
松滋地点：凤香岭、朱家、民田湾、黑冲子
【小虎分析过程】
1.建文年间，发迹，家谱首句，开门见山就指出了；
建林远发枝
2.入翰林院，家谱提及了“治安尚文德”；
建林远发枝
3.永志必丹忠；
永指永乐，既然建文帝提拔的，他当然要发誓立志，永远一片丹心，忠心耿耿。
4.晋升为“左春坊大学士”官职；
家谱有体现：春一大邦首
5.三杨的领军人物，在家谱中有体现；
春一大邦首
6.在位辅佐英宗，家谱有体现；
英俊明圣逢，都是在第一个体现。
7.君臣关系融洽，家谱中，得到了具体的体现；
英俊明圣逢
8.著名的“仁宣之治”盛世局面；
家谱有体现：太运贞元会
就是：文景之治，与贞观之治的交汇。
9.治国安邦，崇尚文德，家谱有体现：“英俊明圣逢”；
遇到了，英明，有才俊的圣上
10.当首辅，家谱中有体现：“辅政用武功”；
11.当兵部尚书，家谱中体现：“辅政用武功”；
12.经历五朝，辅佐4位皇帝，是因为：；
13.群臣弹劾
相贤克纯祖，就是说：臣相，臣贤，弹劾于他，所以：叫：克。
所谓一物克一物。
家谱有证：
14.英宗年间逝世，家谱说的很清楚。
荣华颖应宗
小虎怀疑：应，是不是：英，是不是缪误呢！
就是：应，因为：家谱中：英俊明圣逢
已经有，英字。
明朝首辅/太师，辅佐明朝四代国之重臣杨士奇后世传人在松滋
杨氏60字家谱
建林远发枝，永志必丹忠，
春一大邦首，兴开起秀龙，
太运贞元会，英俊明圣逢，
治安尚文德，辅政用武功，
道学传心法，训诲尊孔孟，
相贤克纯祖，荣华颖应宗。
【小虎分析过程】
1.建文年间，发迹，家谱首句，开门见山就指出了；
建林远发枝
2.入翰林院，家谱提及了“治安尚文德”；
建林远发枝
3.永志必丹忠；
永指永乐，既然建文帝提拔的，他当然要发誓立志，永远一片丹心，忠心耿耿。
4.晋升为“左春坊大学士”官职；
家谱有体现：春一大邦首
5.三杨的领军人物，在家谱中有体现；
春一大邦首
6.在位辅佐英宗，家谱有体现；
英俊明圣逢，都是在第一个体现。
7.君臣关系融洽，家谱中，得到了具体的体现；
英俊明圣逢
8.著名的“仁宣之治”盛世局面；
家谱有体现：太运贞元会
就是：文景之治，与贞观之治的交汇。
9.治国安邦，崇尚文德，家谱有体现：“英俊明圣逢”；
遇到了，英明，有才俊的圣上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b19a3962a00a111703c03df053b6075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a533262f0365333da0e1188ffdd331f5/" rel="bookmark">
			spring mvc（六）实现REST接口GET/POST/PUT/DELETE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于springmvc实现restful样式的api接口。 [b]1.Restful[/b] Restful样式的接口将功能抽象为资源resource路径映射，以HTTP GET /resource/{id} 的方式访问。主要分为以下几类接口： [table] |[b]地址[/b]|[b]请求方法[/b]|[b]说明[/b]| |/resources|GET|获取所有资源| |/resources|POST|创建新资源，content中包含资源内容| |/resource/{id}|GET|获取编号为id的资源| |/resource/{id}|PUT|更新编号为id的资源，content中包含资源内容| |/resource/{id}|DELETE|删除编号为id的资源| [/table] {id}称为路径变量，告诉restful你要对哪个资源进行查、改、删。 接口一般返回json/xml格式数据，方便服务端程序、浏览器脚本调用接口并处理返回数据。 按照Restful样式，teacher模块设计为两个资源地址：/restMvc/teachers和/restMvc/teachers/{id}。 基础的spring配置、springmvc配置、各层对象接口实现见前几节内容。 [b]2./teachers[/b] 新建TeachersMvcResource资源类： package com.sunbin.test.restMvc;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.view.json.MappingJackson2JsonView;
import org.springframework.stereotype.Controller;
import org.springframework.beans.factory.annotation.Autowired;
import com.sunbin.test.teacher.pojo.Teacher;
import com.sunbin.test.teacher.service.TeacherService;
@Controller
@RequestMapping("/restMvc/teachers")
public class TeachersMvcResource {
@Autowired
private TeacherService teacherService;
@RequestMapping(method = { RequestMethod.GET })
public ModelAndView get(HttpServletRequest arg0, HttpServletResponse arg1)
throws Exception {
System.out.println("RestMvc TeachersResource.get");
ModelAndView modelAndView = new ModelAndView(
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a533262f0365333da0e1188ffdd331f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e59aeedc401b207568a38fb7391d4024/" rel="bookmark">
			非Spring Boot Web项目 注册节点到Eureka Server并提供服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信有很多团队在老Web项目（zookeeper，dubbo，tomcat）想要过渡到新的Eureka注册管理的Spring Boot都会遇到这样一个问题，新项目想调用老项目提供的服务，或者不想采用Spring Boot 而是直接想使用Eureka 替换掉原有的zookeeper和dubbo，那怎么办0.0 能不能将老项目注册到Eureka Server？
1.项目jar依赖： gradle:
compile "com.netflix.eureka:eureka-client:1.4.12" maven:
&lt;dependency&gt; &lt;groupId&gt;com.netflix.eureka&lt;/groupId&gt; &lt;artifactId&gt;eureka-client&lt;/artifactId&gt; &lt;version&gt;1.4.12&lt;/version&gt; &lt;/dependency&gt; 此处主要依赖的是Netflix的eureka-client jar包（spring boot也是对它的一个简单封装）要注意这里的jar包版本要与Spring Boot项目依赖的eureka-client jar包版本一致 不然可能不兼容 下面是该jar包所有的依赖（有jar包冲突的要处理解决一下~） 2.添加Listener用于将节点注册到Eureka Server
package com.kowalski.web.eureka; import com.netflix.appinfo.ApplicationInfoManager; import com.netflix.appinfo.InstanceInfo; import com.netflix.config.DynamicPropertyFactory; import com.netflix.discovery.DefaultEurekaClientConfig; import com.netflix.discovery.DiscoveryManager; import lombok.extern.slf4j.Slf4j; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; /** * Created by Kowalski on 2017/5/18 * Updated by Kowalski on 2017/5/18 */ @Slf4j public class EurekaInitAndRegisterListener implements ServletContextListener { private static final DynamicPropertyFactory configInstance = DynamicPropertyFactory .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e59aeedc401b207568a38fb7391d4024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a4ccd24e8d4447e608b6de33da557b/" rel="bookmark">
			找到一个适合的分布式文件系统之各种分布式文件系统优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、各种分布式文件系统对比 1.1 表格对比 技术
优点
缺点
总结
1、 HDFS
1、大数据批量读写，吞吐量高；
2、一次写入，多次读取，顺序读写；
1、交互式应用，低延迟很难满足；
2、不支持多用户并发写相同文件。
如果是很多小文件，nameNode压力大
2、 googleFs
1、成本低，运行在廉价的普通硬件上
1、不开源
不开源，使用困难
3、 Tfs
1、 开源
1、小于1M的文件
2、TFS内部是没有任何数据的内存缓冲的
适合单个文件比较小的系统
4、 Lustre
1、 开源
2、 支持POSIX
3、 文件被分割成若干的Chunk，每个chunk是一般为1MB－4MB
5、 Ceph
1、支持POSIX
2、开源
1、 在Linux主流内核中找到ceph
2、不成熟，处于测试推广阶段
6、 MogileFs
1、开源
比FastDFS 差
7、 FastDFS
1、 开源
2、 适合以文件为载体的在线服务
3、 FastDFS没有对文件做分块存储
4、 不需要二次开发即可直接使用
5、 比mogileFS更易维护和使用
6、 直接使用socket通信方式，相对于MogileFS的HTTP方式，效率更高。
1、文件访问方式使用专有API，不支持POSIX
8、swiftfs 1、基于HDFS
9、NFS 1、用户和程序可以象访问本地文件一样访问远端系统上的文件
开源的分布式文件/对象系统比较有名的包括Lustre（HPC）GlusterFS（NAS NFS）、HDFS（hadoop）、ceph（虚机块存储）、swift（restful对象存储），各有不同的领域。
1.2 相关链接 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31a4ccd24e8d4447e608b6de33da557b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1187b40015d49fd4015599011277d77d/" rel="bookmark">
			Springboot&#43;SpringData&#43;jpa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Springboot+SpringData+jpa
Eclipse中搭建过程：
本案例使用maven方式构建项目
1、 首先在eclipse中创建一个maven工程
2、 修改pom.xml文件，完整pom.xml代码如下：
&lt;projectxmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lhc.springbootjpa&lt;/groupId&gt; &lt;artifactId&gt;SpringBoot_jpa_test1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring boot 引用Thymeleaf模板依赖包（Thymeleaf模板如果不适用，这里也可以不添加这段配置，Thymeleaf模板使用在下面会讲到） --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 3、 如果项目中需要连接数据库，还需要添加数据库相关的驱动包
4、 在src/main/resources目录下，新建application.properties或application.yml类型的配置文件（本案例使用的是application.properties这种类型的配置文件），配置文件内容如下：
#更改springboot端口号(默认是8080) server.port=8089 spring.datasource.driver-class-name=oracle.jdbc.OracleDriver spring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl spring.datasource.username=scott spring.datasource.password=tiger #jpaconfiguration spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true 5、 src/main/java下新建一个包，如：com.lhc.springbootjpa，并新建一个类，如：Application.java，代码如下：
package com.lhc.springbootjpa; import org.springframework.boot.SpringApplication; importorg.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication /** * 要将Application放在最外层，也就是要包含所有子包。 比如你的groupId是com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1187b40015d49fd4015599011277d77d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ea558bdcd0360e34b9942adb0d8aa6/" rel="bookmark">
			重磅清单 | 当前AI领域尚未攻克的29个难题及进展评估（附百篇文献）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
本文列出了人工智能中的开放性问题，根据人工智能路线图研究所重点关注的“ 开放性研究问题 ”主题，简要介绍该领域的最大挑战和现有技术水平。(译者注：人工智能路线图研究所是一个旨在研究和比较由人工智能领域工作者提出的各种人工智能路线图的新机构。)
这些挑战可分为：人工智能完备（AI-complete）问题，封闭域问题，以及常识推理、学习和感觉运动能力的基本问题。（译者注：对于计算机来说最困难的问题，被非正式地称为“人工智能完备”（AI-complete）的，以此说明解决了这些计算性问题就相当于解决了人工智能的核心问题——让计算机和人类或者强人工智能一样聪明。）
可以预见的是，作为第一次对人工智能开放性问题的调研，下面的清单难免有疏漏之处。欢迎读者提供反馈。
为了促进强人工智能的发展，GoodAI（https://www.goodai.com/）正在组织强人工智能挑战赛。这个比赛旨在通过从2017年初开始的一系列里程碑挑战赛解决下面列出的一些问题。（译者注：早在1956年，人工智能的先驱们就梦想着用当时刚刚出现的计算机来构造复杂的、拥有与人类智慧同样本质特性的机器。这就是我们现在所说的“强人工智能”。这个无所不能的机器，有着我们所有的感知（甚至比人更多），我们所有的理性，可以像我们一样思考。而GoodAI是一家捷克公司，他们的长期目标是开发出能够实现科学、技术、商业等领域自动认知过程的通用人工智能。）
来源，方法和相关工作
本文罗列的人工智能问题来源于以下领域的文献：
● 机器学习
● 机器感知和机器人
● 开源人工智能问题
● 人工智能系统的评估
● 测试人类水准的人工智能的实现
● 基准和竞赛
筛选本文研究问题的三个标准如下：
1. 必须与强人工智能的实现高度相关
2. 问题有封闭的范围，不接受开放式扩展
3. 可被测试
这些问题所在的范围不同但常有交集。其中一些问题可以被完全包含在其他问题中。第二个标准（封闭范围）排除了一些有趣的问题，比如学习人类的所有职业；几个这种类型的问题将列在主要问题之后。为了确保问题具有可测试性，每个问题之后都附有示例测试。
下面列出的几个网站提供了一些具有挑战性的人工智能问题：
● 常识推理问题页面 （http://commonsensereasoning.org/problem_page.html）提出了几个常识推理领域中的问题，例如“通俗心理学”（与心智理论和社会认知相关）和“物理推理”（与直观／朴素物理学相关）。
● 常识推理的Winograd架构页面 （http://commonsensereasoning.org/winograd.html）介绍了Winograd架构和其他需要理解这个世界才可以解决的代词歧义问题。（译者注：Winograd架构是一个比图灵测试更有效的方法来确定一个计算机程序是否具有展示智能的能力。它观察计算机程序是否能够利用大量的知识来正确推理出故意含混的语句。而代词消歧问题是参与挑战的计算机程序需要回答一种特殊但简易的常识问题。人类可以根据常识和上下文信息了解代词的意义，但对这人工智能系统来说这是个很大的挑战。）
● OpenAI的研究请求 （https://openai.com/requests-for-research/）展示了不同难度的机器学习问题，强调深层和强化学习。（译者注：OpenAI是微软与马斯克所创建的位于美国旧金山的人工智能研究团队。）
● AI•ON列出的开放式研究问题（http://ai-on.org/projects/）包含人工智能的应用问题和基本问题，同时强调深度学习。（译者注：AI•ON是一个致力于推进人工智能的开放社区。）
人工智能的挑战
本文剩下的部分将按下面的顺序列出人工智能领域的一些挑战：
1. 人工智能完备问题
2. 闭域问题
3. 共同推理
4. 学习
5. 感觉运动问题
人工智能完备问题
人工智能完备问题包含了所有或绝大多数符合人类智力水平的强人工智能问题。这个类别中的一些问题如下所列：
1. 开放领域对话（Open-domain dialog）
2. 文本理解
3. 机器翻译
4. 人类智力和能力测试
5. 核心解析（Winograd构架）
6. 复合词理解
（1）开放领域对话
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ea558bdcd0360e34b9942adb0d8aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004aedff64bef5796d241a9839011eaf/" rel="bookmark">
			SpringBoot配置属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot配置属性 mvc
spring.mvc.async.request-timeout设定async请求的超时时间，以毫秒为单位，如果没有设置的话，以具体实现的超时时间为准，比如tomcat的servlet3的话是10秒.
spring.mvc.date-format设定日期的格式，比如dd/MM/yyyy.
spring.mvc.favicon.enabled是否支持favicon.ico，默认为: true
spring.mvc.ignore-default-model-on-redirect在重定向时是否忽略默认model的内容，默认为true
spring.mvc.locale指定使用的Locale.
spring.mvc.message-codes-resolver-format指定message codes的格式化策略(PREFIX_ERROR_CODE,POSTFIX_ERROR_CODE).
spring.mvc.view.prefix指定mvc视图的前缀.
spring.mvc.view.suffix指定mvc视图的后缀.
messages
spring.messages.basename指定message的basename，多个以逗号分隔，如果不加包名的话，默认从classpath路径开始，默认: messages
spring.messages.cache-seconds设定加载的资源文件缓存失效时间，-1的话为永不过期，默认为-1
spring.messages.encoding设定Message bundles的编码，默认: UTF-8
mobile
spring.mobile.devicedelegatingviewresolver.enable-fallback是否支持fallback的解决方案，默认false
spring.mobile.devicedelegatingviewresolver.enabled是否开始device viewresolver，默认为: false
spring.mobile.devicedelegatingviewresolver.mobile-prefix设定mobile端视图的前缀，默认为:mobile/
spring.mobile.devicedelegatingviewresolver.mobile-suffix设定mobile视图的后缀
spring.mobile.devicedelegatingviewresolver.normal-prefix设定普通设备的视图前缀
spring.mobile.devicedelegatingviewresolver.normal-suffix设定普通设备视图的后缀
spring.mobile.devicedelegatingviewresolver.tablet-prefix设定平板设备视图前缀，默认:tablet/
spring.mobile.devicedelegatingviewresolver.tablet-suffix设定平板设备视图后缀.
spring.mobile.sitepreference.enabled是否启用SitePreferenceHandler，默认为: true
view
spring.view.prefix设定mvc视图的前缀.
spring.view.suffix设定mvc视图的后缀.
resource
spring.resources.add-mappings是否开启默认的资源处理，默认为true
spring.resources.cache-period设定资源的缓存时效，以秒为单位.
spring.resources.chain.cache是否开启缓存，默认为: true
spring.resources.chain.enabled是否开启资源 handling chain，默认为false
spring.resources.chain.html-application-cache是否开启h5应用的cache manifest重写，默认为: false
spring.resources.chain.strategy.content.enabled是否开启内容版本策略，默认为false
spring.resources.chain.strategy.content.paths指定要应用的版本的路径，多个以逗号分隔，默认为:[/**]
spring.resources.chain.strategy.fixed.enabled是否开启固定的版本策略，默认为false
spring.resources.chain.strategy.fixed.paths指定要应用版本策略的路径，多个以逗号分隔
spring.resources.chain.strategy.fixed.version指定版本策略使用的版本号
spring.resources.static-locations指定静态资源路径，默认为classpath:[/META-INF/resources/,/resources/,/static/, /public/]以及context:/
multipart
multipart.enabled是否开启文件上传支持，默认为true
multipart.file-size-threshold设定文件写入磁盘的阈值，单位为MB或KB，默认为0
multipart.location指定文件上传路径.
multipart.max-file-size指定文件大小最大值，默认1MB
multipart.max-request-size指定每次请求的最大值，默认为10MB
freemarker
spring.freemarker.allow-request-override指定HttpServletRequest的属性是否可以覆盖controller的model的同名项
spring.freemarker.allow-session-override指定HttpSession的属性是否可以覆盖controller的model的同名项
spring.freemarker.cache是否开启template caching.
spring.freemarker.charset设定Template的编码.
spring.freemarker.check-template-location是否检查templates路径是否存在.
spring.freemarker.content-type设定Content-Type.
spring.freemarker.enabled是否允许mvc使用freemarker.
spring.freemarker.expose-request-attributes设定所有request的属性在merge到模板的时候，是否要都添加到model中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004aedff64bef5796d241a9839011eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473d4f6e80df0cd02cbdfeebecc68af8/" rel="bookmark">
			R可视化学习代码（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章：散点图 1.基本散点图
attach(heightweight) heightweight[,c("ageYear","heightIn")] ggplot(heightweight,aes(x=ageYear,y=heightIn))+geom_point() ggplot(heightweight,aes(x=ageYear,y=heightIn))+geom_point(shape=21)#shape参数修改点的形状 ggplot(heightweight,aes(x=ageYear,y=heightIn))+geom_point(size=1.5)# 2、使用点形和颜色属性，并基于某变量对数据进行【分组】
`heightweight[,c("sex","ageYear","heightIn")] ggplot(heightweight,aes(x=ageYear,y=heightIn,shape=sex))+geom_point() ggplot(heightweight,aes(x=ageYear,y=heightIn,colour=sex))+geom_point() PS:分类因子变量必须是因子
ggplot(heightweight,aes(x=ageYear,y=heightIn,shape=sex,colour=sex))+geom_point()#将一变量同时映射给shape和colour 分组后颜色和形状都不同
ggplot(heightweight,aes(x=ageYear,y=heightIn,shape=sex,colour=sex))+ geom_point()+scale_shape_manual(values=c(1,2))+ scale_colour_brewer(palette="Set1")#根据分组变量将分属不同组的数据点设置为不同点形和颜色 3、使用不同于默认设置的点形
ggplot(heightweight,aes(x=ageYear,y=heightIn,shape=sex))+ geom_point(size=3)+scale_shape_manual(values=c(1,4))#利用scale_shape_manual调整,自定义点形 #点是否实点，边框颜色都可以设置 hw=heightweight#副本 hw$weightGroup=cut(hw$weightLb,breaks=c(-Inf,100,Inf),labels=c("&lt;100","&gt;=100"))#大于100磅的一组 #可以按2个变量对数据进行分组，一个是因子sex，一个是连续型变量（做了分类处理）——刻画了两个变量 ggplot(hw,aes(x=ageYear,y=heightIn,shape=sex,fill=weightGroup))+ geom_point(size=2.5)+ scale_shape_manual(values=c(21,24)) #上面的代码运行后没有虚点，和标示不同 ggplot(hw,aes(x=ageYear,y=heightIn,shape=sex,fill=weightGroup))+ geom_point(size=2.5)+ scale_shape_manual(values=c(21,24))+ scale_fill_manual(values=c(NA,"black"),guide=guide_legend(override.ase=list(shape=21))) 4、将连续型变量映射到点的颜色或大小属性上
###如何来刻画第三个连续型变量——必须将第三个变量映射到其他的图形属性（颜色、大小）——必须放在aes中 heightweight[,c("sex","ageYear","heightIn","weightLb")] ggplot(heightweight,aes(x=ageYear,y=heightIn,colour=weightLb))+geom_point()#该图点的颜色越深weightLb越小 ggplot(heightweight,aes(x=ageYear,y=heightIn,size=weightLb))+geom_point()#该图点越大weightLb越大 #此时对第三个变量解释精度较低，适用于不需要高精度解释的变量，点的大小差不代表值的大小差 ggplot(heightweight,aes(x=ageYear,y=heightIn,fill=weightLb))+ geom_point(shape=21,size=2.5)+scale_fill_gradient(low="black",high="white")#scale_fill_gradient #将色阶设置为黑白,黑白渐变，增大数据点大小 ggplot(heightweight,aes(x=ageYear,y=heightIn,fill=weightLb))+ geom_point(shape=21,size=2.5)+scale_fill_gradient(low="black",high="white",breaks=seq(70,170,by=20), guide=guide_legend()) #scale_fill_gradient()中breaks设置断点，会以离散点的图例代替色阶（渐变色） ggplot(heightweight,aes(x=ageYear,y=heightIn,size=weightLb,colour=sex))+ geom_point(alpha=0.5)+scale_size_area()+ scale_colour_brewer(palette="Set1")#scale_fill_gradient #alpha=0.5指定点为半透明，scale_size_area()设置点面积正比于变量值，scale_colour_gradient()修改调色板 #PS:将某变量映射给size时，避免将其他变量映射给shape属性。【不同点形的大小不好比较】 5、处理图像重叠
###数据量大时，如何避免互相重叠？——重叠度低的时候可以用不同的点形或虚实区别 #（1）用半透明的点处理 sp=ggplot(diamonds,aes(x=carat,y=price)) sp+geom_point()#5万多数据，很难区分不同区域数据点的相对密度 sp+geom_point(alpha=0.1)#设置点透明度为90%，重叠后颜色越重表示该区域点越密集 sp+geom_point(alpha=0.01)#设置点透明度为99%，重叠后颜色越重表示该区域点越密集 #（2）将数据点分箱，并以矩阵来表示，将数据点的密度映射为矩阵的填充色 sp+stat_bin2d()#stat_bin2d()分别在横纵轴方向将数据分隔20组，总计900个箱子 #数据点默认颜色区分不大（黑蓝） sp+stat_bin2d(bins=50)+ #将箱数设置为50 scale_fill_gradient(low="lightblue",high="red") sp+stat_bin2d(bins=50)+ #将箱数设置为50 scale_fill_gradient(low="lightblue",high="red",limits=c(0,6000)) #scale_fill_gradient重新设定数据点颜色，最小色阶为浅蓝，最大色阶为红色，默认图例不含最小值，颜色标度范围不是从0开始 #limits手动设定范围为0,6000 install.packages("hexbin") library(hexbin) sp+stat_binhex()+ scale_fill_gradient(low="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473d4f6e80df0cd02cbdfeebecc68af8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/260/">«</a>
	<span class="pagination__item pagination__item--current">261/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/262/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>