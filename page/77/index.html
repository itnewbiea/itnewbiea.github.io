<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a18cb4c4bd1d38318b2caf017dcc20c/" rel="bookmark">
			深度学习AI编译器-LLVM简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是LLVM LLVM的命名最早来源于底层语言虚拟机（Low Level Virtual Machine）的缩写。它是一个用于建立编译器的基础框架，以C++编写。创建此工程的目的是对于任意的编程语言，利用该基础框架，构建一个包括编译时、链接时、执行时等的语言执行器。目前官方的LLVM只支持处理C/C++，Objective-C三种语言，当然也有一些非官方的扩展，使其支持ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java bytecode、Objective-C、Python、Ruby、Rust、Scala以及C#。
LLVM是一个编译器框架。LLVM作为编译器框架，是需要各种功能模块支撑起来的，你可以将clang和lld都看做是LLVM的组成部分，框架的意思是，你可以基于LLVM提供的功能开发自己的模块，并集成在LLVM系统上，增加它的功能，或者就单纯自己开发软件工具，而利用LLVM来支撑底层实现。LLVM由一些库和工具组成，正因为它的这种设计思想，使它可以很容易和IDE集成（因为IDE软件可以直接调用库来实现一些如静态检查这些功能），也很容易构建生成各种功能的工具（因为新的工具只需要调用需要的库就行）。
常见的结构如下图
主要由三个部分组成。
前端：将高级语言例如C或者其他语言转换成LLVM定义的中间表达方式 LLVM IR。例如非常有名的clang, 就是一个转换C/C++的前端。
中端：中端主要是对LLVM IR本身进行一下优化，输入是LLVM, 输出还是LLVM， 主要是消除无用代码等工作，一般来讲这个部分是不需要动的，可以不管他。
后端：后端输入是LLVM IR， 输出是我们的机器码。我们通常说的编译器应该主要是指这个部分。大部分优化都从这个地方实现。
至此，LLVM架构的模块化应该说的比较清楚了。很大的一个特点是隔离了前后端。
如果你想支持一个新语言，就重新实现一个前端，例如华为“仓颉”就有自己的前端来替换clang。
如果你想支持一个新硬件，那你就重行实现一个后端，让它可以正确的把LLVM IR映射到自己的芯片。
前端 经过词法分析、语法分析、语义分析、LLVM IR生产，最终将C++转化成后端认可的LLVM IR。
词法分析：将编程语言取出一个个词，遇到不认识的字符就报错。例如将a=b+c 拆成a,= ,b ,+, c
语法分析：将语法提取出来，例如你写了个a+b=c, 明显不符合语法，直接报错
语义分析：分析一下你写的代码实际含义是不是对，例如a=b+c, a,b,c有没有定义，类型是不是对的
LLVM IR生产：经过上述三步，将你写的代码转化成树状描述（抽象语法树），然后再转化成IR定义的IR即可。
举个直观的栗子，你写的C++
// add.cpp int add(int a, int b) { return a + b; } 生产的LLVM IR
（这个地方你不需要看懂每个细节，知道大概想类汇编的语言就行了， 专业的形式叫SSA, Static Single Assignment (SSA）
; ModuleID = 'add.cpp' source_filename = "add.cpp" target datalayout = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a18cb4c4bd1d38318b2caf017dcc20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53debf43692806d604b4f66d5a55a6cb/" rel="bookmark">
			基因名称转换-在线工具版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.网页工具 g:Profiler 转换
g:Profilerhttps://biit.cs.ut.ee/gprofiler/convert
常见的选项如下参考：
选择项描述 ENSG
Ensemble IDENTREZGENENCBI的gene数据库中的基因名ENTREXGENE_ACCNCBI的gene数据库中的基因编号（Accession），即Entrez IDUNIPROT_GNUniprot数据库中的基因名UNIPROT_GN_ACCUniprot数据库中的基因序号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591346e5ced30bbcbe58d361130e0b99/" rel="bookmark">
			mac adt识别 手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 中断输入 system_profiler SPUSBDataType system_profiler SPUSBDataType 2. 找到 Vendor ID
Vendor ID: 0x2a45
3.
echo "0x2a45" &gt; ~/.android/adb_usb.ini
4. adb kill-server
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fc328c8dee58f82254311eccca4ca3/" rel="bookmark">
			python采集数据保存csv, 文件内容乱码了怎么解决?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你的 Python 程序采集到的数据在保存成 CSV 格式的文件时出现了乱码，那么可尝试以下解决方法：
1. 在打开 CSV 文件时指定编码方式
你可以使用 Python 中的 open() 函数打开 CSV 文件，并在 open() 函数中指定文件编码方式为 CSV 文件原始编码方式。如果 CSV 文件原始编码方式为 UTF-8，则可以在 open() 函数中指定编码方式为 "utf-8-sig"。示例代码如下：
import csv with open('output.csv', 'w', newline='', encoding='utf-8-sig') as csvfile: writer = csv.writer(csvfile) writer.writerow(['列1', '列2']) writer.writerow(['a', '1']) writer.writerow(['b', '2']) 在这个示例中，我们打开 output.csv 文件，并将编码方式指定为 "utf-8-sig"，并使用 csv.writer() 函数向文件中写入数据。
2. 将数据转换成 Unicode 编码
在将数据写入 CSV 文件之前，将数据转换成 Unicode 编码也是一种常见的解决方法。你可以使用 Python 中的 unicode() 函数将字符串类型的数据转换成 Unicode 编码，示例代码如下：
import csv with open('output.csv', 'w', newline='') as csvfile: writer = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39fc328c8dee58f82254311eccca4ca3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995c18ece51d73e6a899fac33b10c684/" rel="bookmark">
			Mongodb在docker容器中的集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拉取镜像 docker pull mongo 2.创建网络 docker network create mongo-rs 3创建容器 docker run --rm --network mongo-rs --name mongo1 -d -v /data/mongo1/db:/data/db -p 27021:27017 mongo:latest --replSet "rs0" docker run --rm --network mongo-rs --name mongo2 -d -v /data/mongo2/db:/data/db -p 27022:27017 mongo:latest --replSet "rs0" docker run --rm --network mongo-rs --name mongo3 -d -v /data/mongo3/db:/data/db -p 27023:27017 mongo:latest --replSet "rs0" docker run --rm --network mongo-rs --name mongo4 -d -v /data/mongo4/db:/data/db -p 27024:27017 mongo:latest --replSet "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995c18ece51d73e6a899fac33b10c684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983af2a73a1db2fb7beaa4e629498a7c/" rel="bookmark">
			浏览器多线程到事件循环机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器多线程到事件循环机制 进程与线程 进程
进程是CPU分配资源的最小单位，它是一个可以自己独立运行且拥有自己资源空间的任务程序；包括程序以及程序所使用的内存及系统资源
当我们启动一个程序时就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用的状态都保存再该内存空间里；应用关闭时，应用空间就会被回收；进程可以启动更多的进程来执行任务，由于进程之间分配的内存空间是独立的；如果连个进程之间需要传递某些数据 ；则需要通过进程间的通信管道 IPC ；很多进程是多进程，是为了避免一个进程卡死，影响整个应用程序
进程可以将任务划分为多个小任务，启动多个线程并行执行不同的任务；同一个进程中的线程是可以直接通信，共享数据的
线程
线程是CPU调度的最小单位，它就是程序中的一个执行流；也可以理解为一个进程代码的不同执行路径
一个进程中只有一个执行流就是单线程，程序按照顺序执行，前面的处理好才执行后面的；一个进程中有多个执行流就是多线程，多个线程并行执行各自的任务
JS为什么是单线程
单线程就是同一时间只能做一件事情；JS是单线程是因为JS的主要作用是用户的交互，dom的操作；如果它是多线程，一个线程修改dom的内容；另一个线程也改了dom内容，那么到底怎么显示呢；为了避免这种复杂的问题，JS就是单线程（多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期）
为了提高效率，新的标准（html5提出的web worker标准）允许JS创建多个线程，但是子线程完全收主线程控制，且不得操作DOM，所以它本质上还是单线程
谷歌浏览器的进程模型 process-per-site-instance ​ 谷歌浏览器默认模型；访问不同站点或者同一站点的不同Tab标签页都会单独创建一个渲染进程；比如如果跨域使用了iframe，那么iframe的渲染进程是一个单独的进程
​ 它是最安全的，因为每个站点互补影响；但是它进程多，占用的内存空间也多
process-per-site
同一站点使用同一个渲染进程
process-per-tab
每个标签页所有站点使用同一个渲染进程
single process
浏览器 JS 引擎和渲染引擎共用一个进程；不推荐，因为不安全
浏览器从关闭状态进行启动，然后新开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个进程；后续再新开标签页，浏览器、网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。
最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。
如果我们打开多个Tab标签页，其中一个Tab标签页崩溃了，影响整个浏览器，那体验肯定是不行的，所以不可能是单进程；每个进程有多个线程都会占用资源，所以我们打开多个标签页可能会卡，谷歌浏览器就有标签页限制
浏览器多进程 浏览器（Broswer）进程 浏览器的主进程，该进程只有一个，主要负责与其他进程之间的协调、主控的作用
负责浏览器的页面展示、交互；（前进后退、书签等）
负责页面的子进程管理，创建和销毁其他进程
网络资源的管理，下载等
UI 线程：只有一个，浏览器主进程，负责处理选项卡页面之外的内容，用于控制用户可见的 UI 部分
（比如地址栏，书签，后退、前进按钮）
网络线程：发送请求，接收数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983af2a73a1db2fb7beaa4e629498a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f938c3d832ab8636e1098dc37242110/" rel="bookmark">
			【Python开发】FastAPI 02：请求参数—路径参数、查询参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进行接口请求时，请求参数是重中之重了！请求参数指客户端向服务端发送请求时，需要传递给服务端的参数，包括路径参数、查询参数、请求体等。举个例子，如果客户端想要获取某个用户的信息，可以向服务端发送一个 GET 请求，并在请求中传递用户的 ID，这个 ID 就是请求参数。本篇文章介绍路径参数和查询参数。
目录
1 基础_路径参数
1.1 声明路径参数
1.2 声明路径参数声明的类型
1.3 路径操作顺序
1.4 预设值
① 创建一个 Enum 类
② 声明路径参数
③ 使用 Python 枚举类型
1.5 包含路径的路径参数
2 基础_查询参数
2.1 声明查询参数
2.2 默认值
2.3 可选参数
2.4 类型转换
3 数值校验_查询参数
3.1 Query 使用
3.2 通过 Query 校验
① default—默认值
② max_length/min_length—字符最大/小长度
③ regex—正则表达式
④ 声明必需参数
⑤ 声明更多元数据
3.3 查询参数设定为列表/多个值
① List[str]
② list
4 数值校验_路径参数
4.1 Path 使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f938c3d832ab8636e1098dc37242110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46f1d754522b85d39900f930cd47cab/" rel="bookmark">
			攻防世界-基础android
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载链接：下载
参考链接：攻防世界-Mobile-基础android (Misc经验解法）_攻防世界基础android_Q_yt的博客-CSDN博客
方法一： 这是个偏向Misc的解题思路，下载完是个apk文件，载入010 Editor看一下，
发现是50 4B开头，而50 4B正是zip压缩包的开头编码，所以把apk改为zip然后解压。发现里面的assets文件夹下也是个zip压缩包，载入010看一看
FF D8是jpg文件的编码开头，所以把这个zip改为jpg。然后打开可获得flag
方法二 逆向思路：把apk文件载入jadx进入AndroidManifest.xml。
可以知道入口点是MainActivity
并且注册了一个广播
进入入口点：
点击按钮把输入内容送到str并且进行‘check.checkPassword(str)’操作，跟进Check类：
发现是对输入的内容进行变化操作然后最后等于'0'，所以写一个简单脚本可以求str
key=list('000000000000') flag='' for i in range(12): flag+=chr(255-i-100-48) print(flag) # kjihgfedcba` 输入正确的str后进入MainActivity2，跟进
通过进一步查看manifest.xml知道触发该广播内容是"android.is.very.fun"，而GetAndChange是广播接收器，跟进GetAndChange
广播接收器接收到广播后启动NextContent，跟进：
这里就是NextContent主要操作，把time_2.zip变为jpg图片形式(和第一种方法对应了)。
所以就可以求flag。
输入第一个密码
触发广播
获得flag
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4465e27bbf5c7ccc561047ca0bdfeb58/" rel="bookmark">
			人鼠同源基因列表转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.、进入Ensemble官网
http://asia.ensembl.org/index.html 2、点击BioMart进入
选择人类基因组，如图所示
3、点击Attribute，右边选择homologues下方选择需要的类别（此处Gene stable ID，Gene name）
4、在ORTHOLOGUES [K-O]选项里找Mouse Orthologues到，选择需要的类别
5 点击Results，等待结果出现右边
左边列人的基因ID、基因名。。。对应右边列鼠的基因ID、基因名。。。
6、点击右上方Go按钮下载全部数据
7、获取到人鼠基因转换表后，复制到我们需要转换的表格中，使用 excel自带的 vlookup 函数进行对照转换就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946611d8cb4b5ea27bbc897c3f241b82/" rel="bookmark">
			matplotlib - 确保 0 在 RdBu 颜色条中变为白色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matplotlib - 确保 0 在 RdBu 颜色条中变为白色 matplotlib - 确保 0 在 RdBu 颜色条中变为白色 - IT工具网
标签 matplotlib colormap
我使用以下代码段创建了一个热图:
&lt;span style="color:#212529"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#212529"&gt;&lt;code style="margin-left:2px"&gt;&lt;span style="color:#5f9182"&gt;import&lt;/span&gt; numpy &lt;span style="color:#5f9182"&gt;as&lt;/span&gt; np &lt;span style="color:#5f9182"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color:#5f9182"&gt;as&lt;/span&gt; plt d = np.random.normal(&lt;span style="color:#ae7313"&gt;.4&lt;/span&gt;,&lt;span style="color:#ae7313"&gt;2&lt;/span&gt;,(&lt;span style="color:#ae7313"&gt;10&lt;/span&gt;,&lt;span style="color:#ae7313"&gt;10&lt;/span&gt;)) plt.imshow(d,cmap=plt.cm.RdBu) plt.colorbar() plt.show() &lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 结果如下图: 现在，由于数据的中间点不是 0，因此颜色图值为 0 的单元格不是白色，而是略带红色。
如何强制颜色图使 max=blue、min=red 和 0=white？ 最佳答案
使用 DivergingNorm .
注:从 matplotlib 3.2 开始 DivergingNorm更名为 TwoSlopeNorm
import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946611d8cb4b5ea27bbc897c3f241b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9084b066e59bf77f52e428a2f64324d3/" rel="bookmark">
			【软件测试】白盒测试与黑盒测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		白盒测试与黑盒测试 测试用例定义生成的基本准测设计步骤作用测试数据和测试用例的区别 黑盒测试定义优点缺点黑盒测试的实施过程等价类划分法边界值分析法错误推测法因果图判定表判定表例题 白盒测试介绍覆盖程度基本路径覆盖程序流程图简化成控制流图计算圈复杂度导出测试用例准备测试用例 例题1) 绘制控制流图2）列出所有决定及其条件分支3） 使用判定/条件覆盖测试方法来设计测试用例4） 请使用条件组合测试方法来设计测试用例5） 请使用路径覆盖方法来设计测试用例6） 请使用基本路径测试方法来设计测试用例 本文介绍白盒测试与黑盒测试有关内容，并伴随例子讲解 测试用例 测试用例就是一个文档，描述输入、动作、或者时间和一个期望的结果，其目的是确定应用程序的某个特性是否正常的工作。
软件测试用例的基本要素包括测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果。
定义 满足特定目的的测试数据、测试代码、测试规程的集合
是发现软件缺陷的最小测试执行单元
有特殊的书写标准和基本原则
生成的基本准测 代表性：能够代表并覆盖各种输入数据、操作和环境设置等
可判定性：测试结果的正确性是可判定的
可再现性：对同样的测试用例，系统的执行结果应当是相同的
设计步骤 为测试需求确定测试用例-&gt;为测试用例确定输入输出-&gt;编写测试用例-&gt;评审测试用例-&gt;跟踪测试用例
作用 避免盲目测试；估算测试工作量；减少回归测试的复杂程度；方便书写软件测试缺陷报告；实施不同级别的测试
测试数据和测试用例的区别 测试数据：被用来测试系统的输入数据（输入）
测试用例：被测试系统的输入和根据规格说明书预测的该系统的输出（输入&amp;输出）
黑盒测试 定义 黑盒测试又称功能测试、数据驱动测试或基于规格说明书的测试，是一种从用户观点出发的测试。
等价性划分、边值分析、组合测试、随机测试和误差猜测、场景测试
黑盒测试主要测试的错误类型有：
①不正确或遗漏的功能；
②接口、界面错误；
③性能错误；
④数据结构或外部数据访问错误；
⑤初始化或终止条件错误等等。
优点 （1）有针对性地寻找问题，并且定位问题更准确。
（2）黑盒测试可以证明产品是否达到用户要求的功能，符合用户的工作要求。
（3）黑盒测试与软件如何实现无关，如果实现发生变化，黑盒测试用例仍然可用（可重用性，面向回归测试）
（4）测试用例开发可以与软件开发同时进行，可节省软件开发时间，通过软件的用例就可以设计出大部分黑盒测试用例。
（5）能重复执行相同的动作，测试工作中最枯燥的部分可交由机器完成。
缺点 （1）需要充分了解待测试软件产品所用到的各项技术，测试人员需要具有较多经验。
（2）测试用例数量较大
（3）测试用例可能产生很多冗余
（4）功能性测试的覆盖范围不可能达到100%
（5）在测试过程中很多是手工测试操作。
（6）测试人员要负责大量文档、报表的编制和整理工作。
黑盒测试的实施过程 （1）测试计划阶段
（2）测试设计阶段
依据程序需求规格说明书或用户手册，按照一定规范化的方法进行软件功能划分和设计测试用例。
（3）测试执行阶段
按照设计的测试用例执行测试;
自由测试(作为测试用例测试的补充)。
（4）测试总结阶段
等价类划分法 等价类是指某个输入域的子集合。 在该子集合中,各个输入数据对于揭露程序中的错误都是等效的。
并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试，因此每个等价类取一个数据就行
有效等价类
是指对于程序的规格说明来说是合理的,有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。一般只有规定输入数据的一组值且对每一个输入值分别处理的时候才会有N个有效等价类和一个无效等价类，其他规则一般都只有一个有效等价类 无效等价类
与有效等价类的定义恰巧相反。无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9084b066e59bf77f52e428a2f64324d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd1623c4742e9b97112dfd0e9272260/" rel="bookmark">
			购买手机之前不妨先查询一下价格走势图,了解手机历史价格趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今手机市场百花齐放,各大品牌纷纷推出自己的旗舰手机。如果您正准备购买一款手机,那么在选择时,不仅需要考虑性能、外观、功能等方面,还需要了解价格趋势。通过使用历史价格工具查询手机历史价格走势图,可以更加全面地了解各种手机的价格变化情况。
在当前市场上,苹果、华为、小米等品牌的手机备受消费者青睐。根据市场调查数据,苹果的iPhone系列、华为的Mate系列以及小米的Mi系列是当前市场上的三大热门品牌。这些品牌的手机均具有强大的性能和卓越的用户体验,受到广大消费者的青睐。
但是,不同品牌、不同型号的手机价格也存在巨大的差异。因此,在购买手机时,了解各种手机的价格趋势非常重要。通过历史价格工具查询京东上的手机价格走势图,可以更加全面地了解各种手机的价格变化情况。
例如,如果您正在考虑购买苹果的iPhone 13,那么可以通过历史价格工具查询京东上iPhone 13的价格走势图,从而更加全面地了解iPhone 13的价格变化情况。此外,如果您发现iPhone 13当前的价格较高,可以通过实时优惠券查询查找适用于iPhone 13的优惠券,以帮助您节省一定的资金。
类似地,如果您正在考虑购买华为的Mate 40 Pro或小米的Mi 11,也可以通过历史价格工具查询京东上的价格走势图,从而更好地了解这些手机的价格趋势。同时TbKong也提供实时的优惠券查询工具,帮助您节省一定的资金。
总之,通过使用历史价格工具,您可以更加全面地了解手机价格的趋势和变化情况,避免假优惠的陷阱,从而做出更加明智的消费决策。在购买手机之前,不妨先查询一下京东上的手机价格走势图,了解手机的价格趋势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d319a45f2654d4ab0d916732a1777512/" rel="bookmark">
			施耐德M580与ATV930的以太网通讯指导书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 通过M580 PLC和ATV930的以太网通讯实验，了解Modbus TCP/IP和Ethernet IP通讯具体的实现过程，理解多种实现方式的区别。
二、实验设备清单 名称
型号
注释
PLC
BME H58 2040
包含机架、电源等。
变频器
ATV930U07M3
通讯电缆
网络电缆
实验环境使用普通网线即可，现场应用推荐使用超六类网线。
编程电缆
Mini USB接口电缆
一头为标准USB接口，一头为Mini USB接口。
三、实验准备工作
1. M580 PLC与ATV930变频器通讯端口介绍
BME H58 2040的正面和背面如图所示：
BME H58 2040各个部位的功能如表所示：
编号
名称
注释
1
LED诊断显示面板
2
PC和PLC连接的Mini USB接口
3
RJ45以太网连接端口
4
RJ45以太网双重连接端口
支持分布式设备和RIO子站
5
SFP插座
用于铜芯缆线或光纤热备链路连接
6
热备状态链路LED
7
SD存储卡插槽
8
A/B/清除旋转选择开关
用于将CPU制定为A或B（热备），或清除现有应用程序。
ATV930的控制模块如图所示：
上图中3是控制电源类型选择拨码开关，5和6是扩展模块的插槽。需要注意的是，1,2,4都是RJ45端口，但是1是用于控制面板连接的，2的两个端口才是以太网通讯端口，4是用于Modbus RTU通讯的。
在我们的实验中，网线一头插入BME H58 2040的3或4中的任意一个端口，另一头插入ATV930U07M3的2中的任意一个端口即可实现以太网硬件连接。PC和PLC直接使用Mini USB电缆连接即可。需要注意的是，如果是使用添加DTM的方式来连接PLC和变频器，而且想在PLC在线修改变频器的DTM，PC和PLC必须通过网线连接。
2. 变频器通讯参数设置 本实验需要使用以太网通讯对变频器实现控制和监视，变频器参数的设置主要在控制通道和以太网通讯上。
在SoMove界面的“参数列表”中，选择“完整设置”中的“命令和参考”，将“参考频率通道1”设置为“嵌入式以太网”，将“控制模式配置”设置为“组合通道模式”，如图所示：
在SoMove界面的“参数列表”中，选择“通信”中“端口-Modbus TCP/以太网 IP”里的“常规设置”，将“IP分配模式”设置为“固定地址”，将“IP地址”、“子网掩码”、“网关地址”分别设置为“192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d319a45f2654d4ab0d916732a1777512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762562f87111e26c3921e2414e90bf42/" rel="bookmark">
			通用唯一识别码 UUID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和随机数。
UUID由以下几部分的组合：
（1）UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
（2）时钟序列。
（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。
UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。 [2] （4）在 hibernate（Java orm框架）中， 采用 IP-JVM启动时间-当前时间右移32位-当前时间-内部计数（8-8-4-8-4）来组成UUID
UUID.randomUUID().toString().replace("-", "") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67d8f9c019e706a872180df79e33582/" rel="bookmark">
			C# Replace：一个熟悉而又陌生的替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言一、String.Replace() 的几个重载 1、Replace(Char, Char)2、String.Replace(String, String) 3、Replace(String, String, StringComparison)4、Replace(String, String, Boolean, CultureInfo)二、Regex.Replace() 的几个常用重载 1、Replace(String, String) 2、Replace(String, String, String)3、Replace(String, String, Int32, Int32)4、Replace(String, String, MatchEvaluator, RegexOptions, TimeSpan)三、关于 Replace 的实际需求简单示例 1、全部替换匹配项2、仅替换第一个匹配项3、仅替换最后一个匹配项 回到顶部
前言 Replace 的作用就是，通过指定内容的替换，返回一个新字符串。
返回值中，已将当前字符串中的指定 Unicode 字符或 String 的 所有匹配项，替换为指定的新的 Unicode 字符或 String。
回到顶部
一、String.Replace() 的几个重载 String.Replace() 总共有四个重载，分别是：（详见官网：String.Replace 方法）
Replace(Char, Char)、
Replace(String, String)、
Replace(String, String, StringComparison)、
Replace(String, String, Boolean, CultureInfo)。
下面来逐个简单介绍下。
1、Replace(Char, Char) // 作用：// 将实例中出现的所有指定 Unicode 字符都替换为另一个指定的 Unicode 字符。// 语法：public string Replace (char oldChar, char newChar); 代码示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67d8f9c019e706a872180df79e33582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61759c27fdcc129cb82938d7604514d/" rel="bookmark">
			docker删除镜像和容器后,磁盘空间未释放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用下列命令: docker container prune -f docker image prune -f docker volume prune -f 它们将释放被停止容器、悬空图像和悬空卷使用的空间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499f6f97d46231423058a939344f105a/" rel="bookmark">
			vmvare的centos重启之后不能上网，ficonfig只有lo，无ens33
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：ifconfig后
解决：
输入指令： sudo dhclient ens33 sudo ifconfig ens33 验证：
ping www.baidu.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec39823cad62ed3884617f8dd5b79007/" rel="bookmark">
			vue 粘贴事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@paste 就是粘贴事件, 鼠标移入到文本上，window 按下ctrl + c 可以触发此事件，mac可以按command + c 可以触发此事件
&lt;div @paste="copy"&gt;复制&lt;/div&gt; &lt;el-button @paste.native="copy"&gt;复制&lt;/el-button&gt; element-ui 组件中需要加 .native 因为这个是原生的组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d56225b5e0072ed4899ca3e7d4b5224/" rel="bookmark">
			GeoServer系列-java发布样式和应用样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，官方接口文档 https://docs.geoserver.org/latest/en/api/#1.0.0/styles.yaml
2，准备sld样式文件 能导出样式文件的软件很多，比如QGIS,ARCGISPRO,Udig,但是亲测只有udig导出的sld文件上传到geojson能正常预览
3，测试demo 根据官方文档的rest接口，实现上传，设置图层默认样式，删除样式,查询所有样式
实际生产中一个图层在前端可能会以多种样式展示，实际渲染哪种样式是有前端设置
import cn.hutool.http.HttpException; import cn.hutool.http.HttpRequest; import cn.hutool.json.JSONArray; import cn.hutool.json.JSONObject; import com.cqdh.group.its.db.model.MapDispositionDO; import okhttp3.*; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.Base64; import java.util.List; public class GeoServerStyle { public static void main(String[] args) throws IOException { //GeoServer的连接配置 String url = "http://127.0.0.1:8016/geoserver"; String username = "admin"; String passwd = "geoserver"; String styleFile = "D:/测试文件/geoserver样式/绿地-蓝底绿边.sld"; //上传样式 publishStyle(url, username, passwd, styleFile); //设置图层默认样式 String layerName = "test:faa87f497ac4f9a172b2bf5179ec9ccc"; //applyStyle(url + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d56225b5e0072ed4899ca3e7d4b5224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a247829d55520849ee1dfe656026fab/" rel="bookmark">
			Oracle数据库死锁检测以及处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先先确保账号有对应的kill权限以及查看权限。 -- 查看死锁ID select username,lockwait,status,machine,program from v$session where sid in (select session_id from v$locked_object); /*查看死锁语句*/ select sql_text from v$sql where hash_value in (select sql_hash_value from v$session where sid in (select session_id from v$locked_object)); -- 1. 查询死锁sql: SELECT object_name, machine, s.sid, s.serial# FROM gv$locked_object l, dba_objects o, gv$session s WHERE l.object_id　= o.object_id AND l.session_id = s.sid; -- 2. 释放死锁 -- alter system kill session '51,585'; -- 3.上方命令不行换OS杀死进程 select spid, osuser, s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a247829d55520849ee1dfe656026fab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80055814fcd92f5648b33a02fd12d76e/" rel="bookmark">
			C&#43;&#43;库函数——string类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 简介
①什么是string类
②string类的作用
2. string类的常见接口
①string类对象的常见构造
②string类对象的容量操作
⑴size、length、 capacity
⑵reserve、resize
⑶clear、shrink_to_fit
③string类对象的访问及遍历操作
⑴使用[]
⑵使用迭代器iterator
⑶使用范围for
④string类对象的修改操作
⑴+=、append、push_back与insert
⑵assign、erase、replace与pop_back
⑶c_str、substr
⑷find、rfind、find_first_of、find_last_of、find_first_not_of、find_last_not_of
⑤string类的非成员函数
⑴operator+
⑵relational operators
⑶operator&lt;&lt;、operator&gt;&gt;
⑷getline
1. 简介 ①什么是string类 源文档
译：
1. 字符串是表示字符序列的类 2. 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。 3. string 类是使用 char( 即作为它的字符类型，使用它的默认 char_traits 和分配器类型 ( 关于模板的更多信息，请参阅basic_string) 。 4. string 类是 basic_string 模板类的一个实例，它使用 char 来实例化 basic_string 模板类，并用 char_traits和allocator 作为 basic_string 的默认参数 ( 根于更多的模板信息请参考 basic_string) 。 5. 注意，这个类独立于所使用的编码来处理字节 : 如果用来处理多字节或变长字符 ( 如 UTF-8) 的序列，这个类的所有成员( 如长度或大小 ) 以及它的迭代器，将仍然按照字节 ( 而不是实际编码的字符 ) 来操作。 ②string类的作用 string类是一个用于处理字符串的类，它可以存储任意数目的字符。它可以用来表示文本或其他字符串数据，例如：文本文件内容、网络传输的数据、数据库中的文本列、用户输入或输出等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80055814fcd92f5648b33a02fd12d76e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65dfd745d604e75c208d817ce2a3d8e/" rel="bookmark">
			通过day.js获取一个月有多少天,生成日历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 项目中需要实现一个月日历的功能,通过dayjs进行封装实现获取一个月共有多少天,通过获取到的数据渲染生成日历
功能流程 根据输入的时间,利用dayjs获取每月第一天及最后一天在while循环中使用isBefore方法,生成当月数据通过dayjs中的day()方法获取星期,根据星期添加日历中上月天数日历中下月天数通过 42减去 dayjs中daysInMonth()方法加上月天数最后将moment格式日期进行格式化处理 代码实现 //e:`2023-1` const getMonth = e =&gt; { const startDay = dayjs(e).startOf('month'); const endDay = dayjs(e).endOf('month'); let list = []; let currentDay = startDay; while (currentDay.isBefore(endDay)) { list.push({ day: currentDay }); currentDay = currentDay.add(1, 'day'); } //上个月补充 let week = list[0].day.day(); if (week == 0) { week = 7; } for (let i = 1; i &lt; week; i++) { // ishow:区分是否是本月日期 list.unshift({ day: startDay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65dfd745d604e75c208d817ce2a3d8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2192a4840d953c2b7dfe3de48aed4074/" rel="bookmark">
			golang kafka客户端 sarama，segmentio/kafka-go ，confluent-kafka-go，franz-go比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择适当的Kafka客户端取决于不同的考虑因素，而每个客户端库都有其各自的优点和缺点。下面是对其中几个常见Kafka客户端库的简要比较：
1. sarama：Sarama是最受欢迎和广泛使用的Golang Kafka客户端之一，它具有广泛的社区支持，文档丰富，功能强大且易于使用。尤其是对比其他客户端库，Sarama的分区重分配和故障恢复功能非常强大，这是处理Kafka集群中动态节点更改、故障转移等情况时非常重要的功能。
2. segmentio/kafka-go：Kafka-go是另一个非常流行的Kafka客户端库，它与Kafka集群的协议实现非常接近。它易于使用，性能优异，同时支持使用TLS连接Kafka集群。
3. confluent-kafka-go：Confluent-Kafka是一个由Confluent赞助维护的客户端，相对于其他客户端，它支持更高的性能和可靠性，同时还提供了许多高级功能（如TLS、SASL等）。然而，Confluent-Kafka的文档和社区支持可能相对其他客户端不够充分，其API也具有一些独特的特性。
4. franz-go：Franz-Go是一个Golang Kafka客户端库，它专注于高性能和低延迟。与其他客户端不同，Franz-Go不支持所有Kafka协议的功能，但是可以更快地处理消息，在延迟敏感的应用中可能是更好的选择。
综上所述，选择适当的Kafka客户端取决于具体的应用场景和需求。如果你正在处理Kafka集群中动态变化和节点故障的情况，Sarama可能是一个不错的选择；如果你需要更高的性能和较低的延迟，你可以考虑Franz-Go。而如果你需要更高级的功能和插件，则可以选择Confluent-Kafka。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/025369f2ca277548221a9501be9b9f6e/" rel="bookmark">
			下载idea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：下载idea 1. 进入idea的官网下载，官网地址IntelliJ IDEA – the Leading Java and Kotlin IDE (jetbrains.com)
2. 点击Download
3. 点击.exe，选择自己需要下载的包，然后直接点击Download。// 安装包需要一步步下载，压缩包解压后直接可以使用。
4. 点击Download，不管是压缩包还是安装包都会进入下面的这个界面，自动下载！！！
第二步. 下载完成后查找路径 1.下载完成后查找路径
2.创建一个桌面快捷模式
3.右键使用管理员身份运行
弄完以后就需要买了，建议大家在官方上买正版的，支持正版。
要是有什么不懂的可以私聊博主！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/943ef529542ffbca3dee8a3a004bb266/" rel="bookmark">
			Bellhop 从入门到上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Bellhop 简介二、Bellhop 结构1、输入文件2、输出文件 三、Bellhop 环境文件1、OPTIONS12、OPTIONS23、OPTIONS34、OPTIONS45、其他参数 四、BELLHOP（Matlab_GUI）实例1、bellhop 工具箱自取2、解压缩工具箱3、设置路径4、添加并包含子文件夹5、运行 BELLHOP 五、声速剖面与声线轨迹1、环境文件2、第一步：绘制声速剖面3、第二步：计算声场并检查输入文件4、第三步：绘制声线轨迹 六、绘制本征声线1、环境文件2、第一步：计算声场并检查输入文件3、第二步：绘制本征声线 总结 前言 本文介绍了 Bellhop 工具箱的具体使用，通过介绍官方 demo 实例，对绘制声速剖面、声线轨迹和本征声线进行了讲解，便于新手快速入门。
一、Bellhop 简介 Bellhop，是一种水声工具箱，可以进行水下声学仿真，通过 env 文件设置环境参数，可得到与之对应的声线信息、多途等仿真；
目前 BELLHOP 可以用 Fortran、MATLAB 和 Python 实现，并可以用于（MAC，Windows 和 Linux）的多种平台。我们在 BELLHOP（MATLAB GUI）中输入海洋环境参数：信道几何结构、声速剖面、海底地形、界面反射损失等得出多径的数目 N，入射角、幅度和延时，进而可以给出系统的冲激响应，从而可以在后续的信道建模的修正及信道估计领域应用提供有效的参照。
二、Bellhop 结构 1、输入文件 BELLHOP 的整体结构图如下图所示：
输入文件有以下几个：
*.env：描述水体环境，必选。*.ati：描述海面形状，可选。*.bty：描述海底形状，可选。*.trc：描述顶部反射系数，可选。*.brc：描述底部反射系数，可选。*.ssp：描述声速剖面图，可选。 2、输出文件 输出文件有以下几个：
*.ray：描述声线和本征声线；*.shd：描述声线的传播损失；*.arr：描述声线到达的时间-幅度序列等参数 BELLHOP 的结构可以用下图直观的表示出来。
三、Bellhop 环境文件 *.env 文件，这是 Bellhop 调用的环境参数文件，其中包括了设置的海洋环境、计算选项等。
*.env 文件主要有 TITLE 和 OPTIONS1 至 OPTIONS5，各个部分相互独立并完成对水体环境不同方面的描述
1、OPTIONS1 OPTION1 是单引号中的五个字母组成的，下面我们分别介绍其含义。
&lt;1&gt;、OPTIONS1(1)
注： OPTIONS1（1）所指为 OPTIONS1 的第一个字母
主要描述了 BELLHOP 为了计算声速以及沿着声线相关的其他参数而采用的一些插值方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/943ef529542ffbca3dee8a3a004bb266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677bb4a45f5ba0360045240d33e9a533/" rel="bookmark">
			Windows环境下如何用GPT3微调自己的模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 环境搭建 1.1 安装Anaconda3 1.2 创建虚拟环境 conda create -n GPT python=3.7 -y conda activate GPT 2 安装 安装openai包，以此使用OpenAI命令行界面
因为我们后续需要使用pandas库转换数据格式，因此这里需要安装pandas。
pip3 install openai -i https://pypi.doubanio.com/simple/ pip install pandas OPENAI_API_KEY通过将以下行添加到您的 shell 初始化脚本（例如 .bashrc、zshrc 等）或在微调命令之前的命令行中运行它来设置您的环境变量：
set OPENAI_API_KEY="&lt;OPENAI_API_KEY&gt;" 注：OPENAI_API_KEY获取方式
3 准备训练数据 这里我们以kaggle上的某个数据集为例，下载链接：https://www.kaggle.com/datasets/egorovm/patient-disease?resource=download
下载解压后如下所示，我们使用disease_clean_symptoms.csv为例。
用EXCEL打开disease_clean_symptoms.csv如下图所示。
然后我们运行process.py处理下这个数据。
import pandas as pd df = pd.read_csv('disease_clean_symptoms.csv',header=None,index_col=False,nrows=500,names=['prompt','completion']) df.to_csv("disease_clean_symptoms_new.csv",index=False) 运行后打开生成的文件disease_clean_symptoms_new.csv，如下图所示。
4 CLI数据准备工具 OpenAI开发了一个工具来验证、提供建议和重新格式化您的数据：
openai tools fine_tunes.prepare_data -f disease_clean_symptoms_new.csv 此工具接受不同的格式，唯一的要求是它们包含提示和完成列/键。您可以传递CSV、TSV、XLSX、JSON或JSONL文件，它会在指导您完成建议的更改过程后将输出保存到 JSONL 文件中以备微调。
运行时根据提示输入Y，最终得到jsonl格式文件，如下图所示。
5 创建微调模型 openai api fine_tunes.create -t "disease_clean_symptoms_new_prepared.jsonl" --batch_size 64 --model ada 成功！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677bb4a45f5ba0360045240d33e9a533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11aa68cd67cdb5a09cc201eb82f7d55/" rel="bookmark">
			关于kotlin一个报错的记录 （java.lang.NullPointerException: Parameter specified as non-null is null: method ......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析错误: image.png 空指针异常：
java.lang.NullPointerException:
参数规定是非null 但现在返回了null
Parameter specified as non-null is null
参数名是：
savedInstanceState
定位错误 在哪个位置呢？ image.png 在ReportAct下onCreate方法中 $1(匿名类)onItemClick 下的onViewCreated方法
找到项目中代码：
image.png 也就是说这个回调方法 onViewCreated 里面的 savedInstanceState 返回了null 所以这里我们加上可空就ok了
修改代码：
image.png 测试代码： 一个java接口
public interface IUserInfo { void setInfo(String idCard,String name,String age); } 一个java实现类：
public class NonNullText implements IUserInfo { /** * 下面这几个参数我们如果在java代码中是可以传null的 但如果在 kotlin中呢 kotlin中如果直接调用话也不会报错 如果在kotlin 中 如果不加可空 "?"的话会报错的 * * @param idCard * @param name * @param age */ @Override public void setInfo(String idCard, String name, String age) { } } 在kotlin中测试：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c11aa68cd67cdb5a09cc201eb82f7d55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b41d7814cfa8dde06b9824d263616cc3/" rel="bookmark">
			npm run dev 和 npm run serve
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm run dev 和 npm run serve 都是用于启动前端开发服务器的命令，但是它们通常用于不同的开发框架和工具中。
npm run dev 命令通常用于 Vue.js 和 Nuxt.js 框架中，用于启动本地开发服务器并监视文件更改。当你在开发模式下运行应用程序时，这个命令会编译和打包应用程序的代码，并启动一个本地开发服务器，以便你可以在浏览器中预览应用程序并进行调试。在 Vue.js 和 Nuxt.js 中，你可以在 package.json 文件的 scripts 部分中配置 "dev" 命令。
{ "scripts": { "dev": "nuxt" } } 在这个配置中，"dev" 命令会运行 "nuxt" 命令，该命令会启动本地开发服务器。
npm run serve 命令通常用于 Angular 和 React 框架中，用于启动本地开发服务器并监视文件更改。当你在开发模式下运行应用程序时，这个命令会编译和打包应用程序的代码，并启动一个本地开发服务器，以便你可以在浏览器中预览应用程序并进行调试。在 Angular 和 React 中，你可以在 package.json 文件的 scripts 部分中配置 "serve" 命令。
{ "scripts": { "serve": "react-scripts start" // 或 "ng serve"，具体命令根据不同的框架而异 } } 在这个配置中，"serve" 命令会运行 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b41d7814cfa8dde06b9824d263616cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb2156caf63e15d28d0de6b530ae718/" rel="bookmark">
			Python识别图片指定区域文字内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python批量识别图片指定区域文字内容 简介所需Python模块Python代码 简介 对于一张图片，需求识别指定区域的内容
截取原始图上的指定图片当做模板根据模板相似度去再原始图片上识别准确坐标根据坐标剪切出指定位置图片，也就是所需的内容区域对指定位置图片进行ocr识别 环境
Ubuntu18.04
Python2.7
所需Python模块 aircv
用于识别模板再原始图的位置坐标
pip install aircv Pillow
用于剪裁图片 pip install Pillow Tesseract
文字识别
在此也可以用平台端的API进行更精准的识别
ubuntu下Tesseract环境安装 sudo apt-get install libpng12-dev sudo apt-get install libjpeg62-dev sudo apt-get install libtiff4-dev sudo apt-get install gcc sudo apt-get install g++ sudo apt-get install automake 1.tesseract-ocr安装
sudo apt-get install tesseract-ocr 2.pytesseract安装
pip install pytesseract Python代码 识别对应位置
#!/usr/bin/python2.7 # -*- coding: utf-8 -*- import aircv def matchImg(imgsrc, imgobj, confidence=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb2156caf63e15d28d0de6b530ae718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6738e5d14f4e9e13914e66079c7d2a7/" rel="bookmark">
			vue项目中实现SVG的定制化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在做项目时，常常会用到各式样的图片，但有些图片只是内部的颜色变了，整体的结构没变，这样如果每个样式都用一张比如.png图片的话，一方面会造成上线后包体积过大，进而影响到真实用户的体验，另一方面也是会频繁的找UI要图片，影响工作效率。所以用SVG代替png，具体原因及使用步骤如下：
目录
一：SVG简介
二：SVG与PNG的对比
三：vue项目中实现SVG的定制化
一：SVG简介 SVG是可缩放矢量图形（Scalable Vector Graphics）的缩写，它是一种基于XML的矢量图形格式，可以无损地缩放和变换，不会失真。SVG图像可以在任何分辨率下显示清晰，因此非常适合用于响应式设计和移动设备。另外，SVG图像可以通过CSS和JavaScript进行动态修改和交互，比如动画效果、鼠标悬停等。
二：SVG与PNG的对比 可缩放性：SVG是可缩放矢量图形，可以无损缩放和变换，不会失真。而PNG是位图格式，缩放会导致像素失真和模糊。
文件大小：SVG图像通常比PNG图像更小，因为SVG是基于矢量的，可以通过数学公式描述图像，而不需要存储大量的像素点。这使得SVG图像在网络传输和加载时更加高效。
渲染效果：SVG图像可以使用CSS和JavaScript进行动态修改和交互，并且支持搜索引擎 SEO 。而PNG图像只能通过静态的CSS样式进行修改，无法实现复杂的交互效果。
三：vue项目中实现SVG的定制化 1.查询是否有SVG格式的对应图片，如果没有转步骤2，否则转步骤3
2.找负责此模块的UI同学要svg格式的图片，拿到后不要急着用，用svgo对格式进行优化下
svgo:GitHub - svg/svgo: ⚙️ Node.js tool for optimizing SVG files
这样SVG文件中的内容就会简洁不少，方便处理的同时减小了无用的代码体积
3.对svg文件改造成组件形式，首先在svg文件中用&lt;template&gt;标签进行包裹，将要修改的样式比如颜色等用CSS变量currentColor代替
注意：CSS里你可以在任何需要写颜色的地方使用currentColor这个变量，这个变量的值是当前元素的color值。如果当前元素没有在CSS里显示地指定一个color值，那它的颜色值就遵从CSS规则，从父级元素继承而来。它可以应用于元素的 color、background-color、border 等属性中，也可以作用于 svg 和 canvas
4.其次，在用到图片的vue文件中进行组件的注册，用新注册的SVG组件代替原先的div或者img等标签，比如
&lt;template&gt; &lt;Logo class="xxx"&gt;&lt;/Logo&gt; &lt;/template&gt; &lt;script&gt; import Logo from "xxx" .... components:{ Logo } &lt;/script&gt; 5.将之前用到该图片的地方进行修改。比如将background-img修改为color：xxx
注意：如果要更改的样式是多色，可能是SVG标签中的fill、stroke等，可以在父元素的CSS中进行设置，如果出现多个标签重名的情况，可以在标签中设置class
svg g { fill: white } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a67716fd052b060420079951b7d0f71/" rel="bookmark">
			Mybatis插件MyBatisCodeHelperPro使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MyBatisCodeHelperPro的安装（IDEA插件的两种安装方式）
通过IDEA连接MySQL数据库，方便后续的数据库操作
MyBatisCodeHelperPro的使用
1、新建项目工程测试
2、在pom文件中引入依赖（后面测试需要用到）
3、编写entity实体类
4、生成entity实体类对应的数据库表
5、通过数据库表生成mapper和mapper.xml文件
6、在mapper中增加方法，并通过Alt+Enter快速生成对应的sql语句
7、在不启动容器的情况下直接测试mapper中的方法
MyBatisCodeHelperPro是一个可以帮助我们使用Mybaits时通过entity实体类快速生成对应的数据库表和mapper以及mapper.xml的插件
MyBatisCodeHelperPro的安装（IDEA插件的两种安装方式） 第一种（在plugins中直接安装）：打开IDEA，在File---&gt;Setting---&gt;Plugins中搜索MyBatisCodeHelper-Pro插件直接安装，完成后重启IDE即可
第二种（通过本地Install到IDE中安装）：其实插件可以简单理解为一个jar包，先下载好插件jar包，然后打开File---&gt;Setting---&gt;Plugins插件安装设置，点击设置，选择Install Plugin from Disk...
打开插件选择界面，找到下载好的插件jar包选中点击ok即可将插件安装到IDE中，完成后重启IDE
通过IDEA连接MySQL数据库，方便后续的数据库操作 使用test数据库做演示，当前test数据库下有四张表
MyBatisCodeHelperPro的使用 1、新建项目工程测试 2、在pom文件中引入依赖（后面测试需要用到） &lt;dependencies&gt; &lt;!--单元测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3、编写entity实体类 @Data public class User { //主键id private Integer userId; //姓名 private String userName; //年龄 private Integer userAge; @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a67716fd052b060420079951b7d0f71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b7c4f8aca755c4a10bdf7eee1d16ad/" rel="bookmark">
			springcloud项目使用Hystrix配置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hystrix是Netflix开源的一款容错框架，旨在解决分布式系统中的故障和延迟。通俗来讲，它就是一个线程池和断路器的组合，能够在短时间内侦测到系统故障，并防止故障的扩散，从而提高系统的可靠性和稳定性。
使用Hystrix的步骤如下：
1.添加Hystrix依赖
在项目中添加Hystrix的依赖，可以通过Maven或Gradle管理。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 2.创建HystrixCommand
HystrixCommand是Hystrix的核心组件，用于包装请求操作。它拥有一个run()方法，该方法包含请求操作的逻辑代码，可以在其中调用外部服务。HystrixCommand还可以设置一些熔断、降级和超时等配置。
public class HystrixTestService { public String defaultValue(String key) { return "defaultValue:" + key; } @HystrixCommand(fallbackMethod = "defaultValue") public String getTestValue(String key) { throw new IllegalArgumentException("key:" + key); } } 3.创建Fallback
Fallback是在请求出错或者超时时Hystrix返回的降级方法，用于返回备选的数据或者告诉客户端请求失败。defaultValue方法是降级方法。
public class HystrixTestService { public String defaultValue(String key) { return "defaultValue:" + key; } @HystrixCommand(fallbackMethod = "defaultValue") public String getTestValue(String key) { throw new IllegalArgumentException("key:" + key); } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b7c4f8aca755c4a10bdf7eee1d16ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d39ada8d945ef6c209f305dfe5dd3a/" rel="bookmark">
			麒麟操作系统-01-java环境说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01-麒麟V10服务器上的java环境说明 本文档的背景是需要在国产Kylin-Server-V10-SP1-x86_64操作系统上搭建大数据环境。
当然，在开始搭建之前，我们需要弄清楚，系统自带的环境是怎样的。
本系统自带openjdk1.8，无论是自己搭建大数据组件，还是部署CDH6，其实都是不需要更换的，亲测。
1、在全新的系统上操作的时候，先查看自带的jdk：
java -version #输出如下： openjdk version "1.8.0_312" OpenJDK Runtime Environment (build 1.8.0_312-b07) OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode) 2、我们知道，java的shell命令jps可以查看系统运行的java进程，我们试一下：
jps #输出如下： 275271 Jps 当然，很有可能使用此命令时，提示jps未找到命令。这是因为缺少一个devel依赖，我们将其安装：
yum -y install java-1.8.0-openjdk-devel.x86_64 之后就有了jps命令。
同时java的环境变量也自动配置好了，为：JAVA_HOME=/usr/lib/jvm/java
3、如果没有装上面的devel依赖。java的安装目录在/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.ky10.x86_64/jre/下。
具体的查询方法，可以自行百度，这里就不累述了。
4、当然我们也可以删除自带的jdk，安装我们想要安装的jdk。具体方法如下：
查询自带jdk
rpm -qa | grep java #输出如下： javapackages-tools-5.3.0-2.ky10.noarch java-1.8.0-openjdk-headless-1.8.0.312.b07-2.el8_5.x86_64 tzdata-java-2021e-1.el8.noarch java-1.8.0-openjdk-devel-1.8.0.312.b07-2.el8_5.x86_64 java-1.8.0-openjdk-1.8.0.312.b07-2.el8_5.x86_64 javapackages-filesystem-5.3.0-2.ky10.noarch 删除自带jdk
rpm -e --nodeps [除noarch结尾的，其他的都删除即可] 安装新的jdk &amp; 配置环境变量
这一步比较简单，不累述。无非就是两步：
解压；将解压路径配置到环境变量。 5、经过本人自己的测试，其实自带的jdk，就够用。除非需要其他版本的jdk用于开发或者其他环境，那么强烈建议你重装自己指定的jdk。
另外，国产麒麟系统的内核也是linux，大部分命令和软件的安装环境参考linux即可，网络上这方面的分享比较少，我们需要多琢磨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78a50759049ced1a15363b2f16d5cbf/" rel="bookmark">
			java 利用poi根据excel模板导出数据（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是 java 利用poi根据excel模板导出数据（一） 的优化版本
主要针对于 fillBodyData 方法这块，具体如下
源代码：
private static void fillBodyData(Sheet sheet, int startRow, List&lt;NutMap&gt; bodyList, int[] colWidth) { // 碰到 时间、金额等需要转换的 在setCellValue 里面操作 for (int rowNum = 0; rowNum &lt; bodyList.size(); rowNum++) { NutMap map = bodyList.get(rowNum); Row row = sheet.createRow(rowNum + startRow); int colNum = 0; // comm Cell accountNumberCell = row.createCell(colNum++, CellType.STRING); String accountNumber = map.getString("comm"); colWidth[colNum - 1] = Math.max(colWidth[colNum - 1], Strings.charLength(accountNumber)); accountNumberCell.setCellValue(accountNumber); // a Cell accountNameCell = row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f78a50759049ced1a15363b2f16d5cbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d66772701a61b1f6895af59372b5f14c/" rel="bookmark">
			java 利用poi根据excel模板导出数据（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是 java 利用poi根据excel模板导出数据（一） 的续篇
经常有poi的开发一定会碰到三个名词：
HSSFWorkbook 、 XSSFWorkbook、SXSSFWorkbook；
这三个都是导出excel的形式，具体区别：
HSSFworkbook,XSSFworkbook,SXSSFworkbook区别总结
我们在上篇用的是XSSFWorkbook，上篇我这边需求最多100行，所以用了XSSFworkbook，
但是由于需求不同、所导出的数据量不同，包括导出的文件大小等等，应选择不同的形式。考虑到别的需求有超过65535的，本文就以SXSSFworkbook来补充上篇
因为SXSSFworkbook在使用Excel模板下载数据时将不能直接动态改变表头，所以我们需要
去获取初始模板的行数据,并操作。
首先，我们直接把XSSFworkbook 改成SXSSFworkbook，看看会有什么效果
为什么getRow是空呢？
SXSSFWorkbook是streaming版本的XSSFWorkbook,它只会保存最新的excel rows在内存里供查看，在此之前的excel rows都会被写入到硬盘里（Windows电脑的话，是写入到C盘根目录下的temp文件夹）。被写入到硬盘里的rows是不可见的/不可访问的。只有还保存在内存里的才可以被访问到。
还有就是，模板数据存在于XSSFWorkbook中，你需要用sxssfWorkbook.getXSSFWorkbook()方法去获取初始模板的行数据。
为什么POI模板中的数据获取不到？
我们来试试 （只贴修改的方法代码，其他的和上篇一样）
public static void doExportLongArrearsData() { // 要导出的数据 NutMap nutMap = NutMap.NEW(); nutMap.addv("comm","1111"); nutMap.addv("a","1111"); nutMap.addv("b","2222"); nutMap.addv("c","11333311"); nutMap.addv("d","1114441"); nutMap.addv("e","555"); nutMap.addv("f","6666"); nutMap.addv("g","7777"); nutMap.addv("h","88888"); List&lt;NutMap&gt; list = Lists.newArrayList(); list.add(nutMap); // 导出列 列数 int colNum = 9; int[] colWidth = new int[colNum]; for (int i = 0; i &lt; colNum; i++) { colWidth[i] = 23; } // 从XX行开始为数据内容 excel 第一行为0 int startRow = 5; // 2003版本的Excel （xls） ---- HSSFWorkbook // 2007版本以及更高版本 (xlsx)---- XSSFWorkbook // 2007版本以及更高版本 (xlsx)---- SXSSFWorkbook //SXSSF与XSSF的对比： // //a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d66772701a61b1f6895af59372b5f14c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facaf2fb8b706d086cd13a31f1ff9f6e/" rel="bookmark">
			java 利用poi根据excel模板导出数据（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
作为B端开发，导出数据是不可以避免的，但是有时候需求很变态，表头复杂的一笔，各种合并单元格，如下图：
这些虽说用代码可以实现，但是很繁琐，而且代码并不能通用，遇到更复杂的更难受。为了追求更简单，高效率，我们需要换个方法-------利用模板导出数据！
？？？？？能用模板？？？？？
sure!
本文所用的excel样式,如果列更多、更复杂,直接套用就行 （下方图片中的数字是列名），行序号为1的是表格标题名称，行序号为2的是适应导出时把条件也导出来的情况，别怀疑，就是有这种需求！！
正文开始
1.需要用到的包
poi
&lt;!-- json4excel,poi --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; nutz(工具包，非必须，公司框架，本文与之相关的就只有一个NutMap==Map&lt;String,Object&gt;,不用这个请手动替换)
&lt;!-- https://mvnrepository.com/artifact/org.nutz/nutz --&gt; &lt;dependency&gt; &lt;groupId&gt;org.nutz&lt;/groupId&gt; &lt;artifactId&gt;nutz&lt;/artifactId&gt; &lt;version&gt;1.r.68.v20200427&lt;/version&gt; &lt;/dependency&gt; 2.直接上代码
入口
public static void doExportLongArrearsData() { // 要导出的数据 NutMap nutMap = NutMap.NEW(); nutMap.addv("comm","1111"); nutMap.addv("a","1111"); nutMap.addv("b","2222"); nutMap.addv("c","11333311"); nutMap.addv("d","1114441"); nutMap.addv("e","555"); nutMap.addv("f","6666"); nutMap.addv("g","7777"); nutMap.addv("h","88888"); List&lt;NutMap&gt; list = Lists.newArrayList(); list.add(nutMap); // 导出列 列数 int colNum = 9; int[] colWidth = new int[colNum]; for (int i = 0; i &lt; colNum; i++) { colWidth[i] = 23; } // 从XX行开始为数据内容 excel 第一行为0 int startRow = 5; // 2003版本的Excel （xls） ---- HSSFWorkbook // 2007版本以及更高版本 (xlsx)---- XSSFWorkbook XSSFWorkbook workbook = null; try { // 此处linux和windows通用 /files/cq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/facaf2fb8b706d086cd13a31f1ff9f6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51caf619842a1b1ba319ddd61a1bf864/" rel="bookmark">
			window鼠标文本选择项（I）显示为白色解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window鼠标文本选择项显示为白色时，容易丢失鼠标位置
解决办法：
在开始菜单搜索控制面板 进入控制面板选择鼠标选项，
如果没有找到，可以尝试把右上角的查看方式改为小图标
点击最上方的指针（这个时候你应该是window默认（系统方案））
选择windows黑色（系统方案）
这个时候你的鼠标会变成黑色。
如果你不讨厌黑色，那么到这一步就结束了。
如果你讨厌黑色，那么下一步：
选中你想要改回白色的图标，点击使用默认值，这样它就会变成白色。
不要忘记点击确定！
好的，到这里结束了。
这是写给我自己的，如果可以对你也能有帮助那就再好不过了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc88fbea7d608d6f17d19e958cf04622/" rel="bookmark">
			列表的差集，并集，交集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		差集
1、set(a).difference(set(b)) 2、set(a) - set(b) 并集
1、set(a).union(set(b)) 2、set(a) | set(b) 交集
1、set(a).intersection(set(b)) 2、set(a) &amp; set(b) 注意点：
交集，并集，差集中，a与b的位置不同，它所得到的集合结果也是不一样的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3845fe5e32d2219dc78ac26960068034/" rel="bookmark">
			删除列表元素的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# del删除需要知道元素的索引 1、del listname[index] # pop也是需要知道元素的索引位置 2、pop listname[index] # remove只能删除列表中第一个该元素【该元素在列表中有很多个】 3、listname.remove(item) # clear删除列表中全部元素 4、listname.clear() 针对以上的方法，我做个补充，比如怎么确认列表中元素的索引
1、mylist.index(item, start, end) item是元素，前提是要保证该元素在列表中，不然会报错
2、enumerate（）方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910566126ac83afe48d3353c0f689235/" rel="bookmark">
			python去掉字符串中空格的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.strip()：把头和尾的空格去掉 2.lstrip()：把左边的空格去掉 3.rstrip()：把右边的空格去掉 4.replace('c1','c2')：把字符串里的c1替换成c2。故可以用replace(' ','')来去掉字符串里的所有空格 5.''.join(split(''))：通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 s.split()将s按照空格（包括多个空格，制表符\t，换行符\n等）分割，并返回所有分割得到的字符串。 s.split(sep)以给定的sep为分隔符对s进行分割。 ​ 连接 与分割相反，s.join(str_sequence)的作用是以s为连接符将字符串序列str_sequence中的元素连接起来，并返回连接后得到的新字符串：
s = ',' s.join(numbers) '1,2,3,4,5' 在python中存在继承了回车符\r 和 换行符\n 两种标记
aa.replace(’\n’, ‘’).replace(’\r’, ‘’) 去掉 aa字符内所有的回车符和换行符
声明：s为字符串，rm为要删除的字符序列
s.strip(rm) 删除s字符串中开头、结尾处，位于 rm删除序列的字符
s.lstrip(rm) 删除s字符串中开头处，位于 rm删除序列的字符
s.rstrip(rm) 删除s字符串中结尾处，位于 rm删除序列的字符
注意：
1. 当rm为空时，默认删除空白符（包括'\n', '\r', '\t', ' ')
&gt;&gt;&gt; a = ' 123'
&gt;&gt;&gt; a.strip()
'123'
&gt;&gt;&gt; a='\t\tabc'
'abc'
&gt;&gt;&gt; a = 'sdff\r\n'
&gt;&gt;&gt; a.strip()
'sdff'
2.这里的rm删除序列是只要边（开头或结尾）上的字符在删除序列内，就删除掉。
&gt;&gt;&gt; a = '123abc'
&gt;&gt;&gt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910566126ac83afe48d3353c0f689235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/006662d09e1b6c6a5d694a32a1202a40/" rel="bookmark">
			给文件名后加时间后缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们写项目时，总是想让生成的文件后面加上时间戳，我总结了以下方法，久用不衰！！！
time = datetime.datetime.now().strftime("%Y%m%d%H%M%S") print('cfg_analyse_{}.xlsx'.format(time)) 这里的格式中不能有在命名中不合法的字符，比如说空格和冒号
strftime:日期时间对象 =》字符串，控制输出格式
strptime: 字符串 =》日期时间对象，解析字符串
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88749577c619055aa1196cccd985317/" rel="bookmark">
			​Mirth调用存储过程报错ORA-01861: 文字与格式字符串不匹配​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mirth调用存储过程报错.ORA-01861: 文字与格式字符串不匹配
这种绝对是日期的错误，要进行日期格式转换,具体呢需要自己一步步测试
上业务场景
function func_CreateCardPatInfo(request) { var ret = new XML("&lt;response&gt;&lt;/response&gt;"); ret["returncode"] = "22002"; var TransCode =msg['ControlActProcess']['Request']['TransCode'].toString() ; var CardType =msg['ControlActProcess']['Request']['CardType'].toString() ; var CardNo =msg['ControlActProcess']['Request']['CardNo'].toString() ; var PatientName =msg['ControlActProcess']['Request']['PatientName'].toString() ; var Sex =msg['ControlActProcess']['Request']['Sex'].toString() ; var Birthday1 =msg['ControlActProcess']['Request']['Birthday'].toString() ; var Birthday2 = Birthday1.replace(/-/g, "/"); var Birthday = new java.text.SimpleDateFormat("yyyy/MM/dd").parse(Birthday2); var Age =msg['ControlActProcess']['Request']['Age'].toString() ; var IDCardNo =msg['ControlActProcess']['Request']['IDCardNo'].toString() ; var BankCardNo =msg['ControlActProcess']['Request']['BankCardNo'].toString() ; var Identity =msg['ControlActProcess']['Request']['Identity'].toString() ; var Charge_Type =msg['ControlActProcess']['Request']['Charge_Type'].toString() ; var nation =msg['ControlActProcess']['Request']['nation'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88749577c619055aa1196cccd985317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c7c9e99d9a78ae1f52980bfe569163/" rel="bookmark">
			代理模型：最小二乘支持向量回归(LSSVR)--- MATLAB程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开头：
代理模型是工程问题中常用的一个优化方法。当实际问题计算量很大、不容易求解时，可以使用计算量较小、求解迅速的简化模型来替代原模型，加速优化过程。代理模型采用一个数据驱动的、自下而上的办法来建立：首先，通过抽样得到有限个样本点【输入，计算原模型的响应（输出）】；然后，基于抽样得到的样本点，建立代理模型替代高精度模拟模型。这一过程也被称为行为建模或者黑箱模型。如果只涉及唯一的变量，这一过程也被称为曲线拟合---转自：http://t.csdn.cn/kLWGh
目前代理模型通常有多项式响应面（RSM）模型、Kriging模型、径向基函数（RBF)、神经网络（NN)、支持向量回归（SVR)、多变量插值和回归（MIR）、多项式混沌展开（PCE)等等。在这里简单介绍一下最小二乘支持向量回归（LSSVR）。
LSSVR是一种优秀的基于统计学习理论的建模方法，具有训练速度快、泛化性能好和拟合非线性函数能力强等优点，其被广泛应用于建模、预测和模式识别等领域。
本文的理论部分引用了哈尔滨工业大学高润鹏博士的博士学位论文---《最小二乘支持向量回归机算法及应用研究》---第二章
一、最小二乘支持向量回归(LSSVR)
支持向量机是 Vapnik 于 20 世纪 90 年代初提出的统计学习方法，其被广泛应用于建模预测、模式识别等领域。支持向量回归（Support vector regression SVR）是支持向量机的一个重要分支，用于解决建模问题。它通过非线性映射将输入空间映射到高维特征空间，在特征空间中求取最优线性函数，如图2-1所示。高维特征空间的维数可能是无穷维，并且通常不知道非线性映射的具体表达式，而采用核函数技术， ，（其中 是满足 Mercer 条件的核函数），通过非线性映射的内积代替非线性映射的直接计算，可明显简化计算。
LSSVR是 SVR的变形算法，Suykens 将不等式约束转变为等式约束， 将损失函数由误差和转变为误差的平方和，求解算法由解凸二次优化问题转变为求解线性方程组问题，求解变量个数由 2n+1个减少到 n +1个，（n 为训练样本个数），因此 LSSVR 算法较 SVR算法求解难度降低，并且训练速度加快。
通过求解式(2-9)可得
二、MATLAB实现
Case 1：
clear all close all clc S=[0.700000000000000,59.6000000000000;2.10000000000000,82.7000000000000;4.70000000000000,75.1000000000000;4.80000000000000,52.8000000000000;5.90000000000000,67.1000000000000;6,35.7000000000000;6.40000000000000,33.7000000000000;7,46.7000000000000;8.20000000000000,40.1000000000000;13.3000000000000,0.600000000000000;13.3000000000000,68.2000000000000;13.4000000000000,31.3000000000000;17.8000000000000,6.90000000000000;20.1000000000000,66.3000000000000;22.7000000000000,87.6000000000000;23,93.9000000000000;24.3000000000000,73;24.8000000000000,15.1000000000000;24.8000000000000,26.3000000000000;26.4000000000000,58;26.9000000000000,65;27.7000000000000,83.3000000000000;27.9000000000000,90.8000000000000;29.1000000000000,47.9000000000000;29.5000000000000,89.4000000000000;30.1000000000000,6.10000000000000;30.8000000000000,12.1000000000000;32.7000000000000,40.2000000000000;34.8000000000000,8.10000000000000;35.3000000000000,32;37,70.3000000000000;38.2000000000000,77.9000000000000;38.9000000000000,23.3000000000000;39.4000000000000,82.5000000000000;43,4.70000000000000;43.7000000000000,7.60000000000000;46.4000000000000,84.1000000000000;46.7000000000000,10.6000000000000;49.9000000000000,22.1000000000000;51,88.8000000000000;52.8000000000000,68.9000000000000;52.9000000000000,32.7000000000000;55.5000000000000,92.9000000000000;56,1.60000000000000;60.6000000000000,75.2000000000000;62.1000000000000,26.6000000000000;63,12.7000000000000;69,75.6000000000000;70.5000000000000,83.7000000000000;70.9000000000000,11;71.5000000000000,29.5000000000000;78.1000000000000,45.5000000000000;78.2000000000000,9.10000000000000;78.4000000000000,20;80.5000000000000,55.9000000000000;81.1000000000000,51;83.8000000000000,7.90000000000000;84.5000000000000,11;85.2000000000000,67.3000000000000;85.5000000000000,73;86.7000000000000,70.4000000000000;87.2000000000000,55.7000000000000;88.1000000000000,0;88.4000000000000,12.1000000000000;88.4000000000000,99.6000000000000;88.8000000000000,82.9000000000000;88.9000000000000,6.20000000000000;90.6000000000000,7;90.7000000000000,49.6000000000000;91.5000000000000,55.4000000000000;92.9000000000000,46.8000000000000;93.4000000000000,70.9000000000000;94.8000000000000,71.5000000000000;96.2000000000000,84.3000000000000;98.2000000000000,58.2000000000000] Y=[34.1000000000000;42.2000000000000;39.5000000000000;34.3000000000000;37;35.9000000000000;36.4000000000000;34.6000000000000;35.4000000000000;44.7000000000000;37.8000000000000;37.8000000000000;43.9000000000000;37.7000000000000;42.8000000000000;43.6000000000000;39.3000000000000;42.3000000000000;39.7000000000000;36.9000000000000;37.8000000000000;41.8000000000000;43.3000000000000;36.7000000000000;43;43.6000000000000;42.8000000000000;37.5000000000000;43.3000000000000;38.8000000000000;39.2000000000000;40.7000000000000;40.5000000000000;41.4000000000000;43.3000000000000;43.1000000000000;41.5000000000000;42.6000000000000;40.7000000000000;42;39.3000000000000;39.2000000000000;42.2000000000000;42.7000000000000;40.1000000000000;40.1000000000000;41.8000000000000;40.1000000000000;40.9000000000000;41.7000000000000;40.8000000000000;38.7000000000000;41.7000000000000;40.8000000000000;38.7000000000000;38.6000000000000;41.6000000000000;41.5000000000000;39.4000000000000;39.8000000000000;39.6000000000000;38.8000000000000;41.6000000000000;41.3000000000000;41.2000000000000;40.5000000000000;41.5000000000000;41.5000000000000;38.9000000000000;39;39.1000000000000;39.7000000000000;39.7000000000000;40.3000000000000;39.5000000000000] S=max_min(S); Y=max_min(Y); figure(1) plot3(S(:,1),S(:,2),Y,'.k', 'MarkerSize',10)%绘制原始散点数据 St=S; Kenel_Matrix=Kenel(St,St); n=size(St,1); C=100; %最小二乘支持向量回归 b_alpha=inv([[0,ones(1,n)];[ones(n,1),Kenel_Matrix+eye(n)/C]])*[0;Y]; b=b_alpha(1); a=b_alpha(2:end); %% %预测 X = gridsamp([0 0;1 1], 40); [m,~]=size(X); YX=zeros(m,1); for i=1:size(X,1) x=X(i,:); y=sum(a.*Kenel(St,x))+b; YX(i)=y; end X1 = reshape(X(:,1),40,40); X2 = reshape(X(:,2),40,40); YX = reshape(YX, size(X1)); figure(2), mesh(X1, X2, YX)%绘制预测表面 hold on plot3(S(:,1),S(:,2),Y,'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7c7c9e99d9a78ae1f52980bfe569163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb15f2ea6eefe59fd42ef7896c27105/" rel="bookmark">
			CSS文本溢出显示省略号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、单行文本溢出显示省略号
width: xxxpx; /* (设置文本限定宽度) */ overflow: hidden; /* (文字长度超出限定宽度，则隐藏超出的内容） */ white-space: nowrap; /* (（设置文字在一行显示，不能换行） */ text-overflow: ellipsis; /* (（规定当文本溢出时，显示省略符号来代表被修剪的文本） */ 2、多行文本溢出显示省略号
-webkit-line-clamp: 3; /*（用来限制在一个块元素显示的文本的行数，3 表示最多显示3 行。为了实现该效果，它需要组合其他的 WebKit 属性）*/ display: -webkit-box; /*（和 webkit-line-clamp 结合使用，将对象作为弹性伸缩盒子模型显示 ）*/ -webkit-box-orient: vertical; /*（和 webkit-line-clamp 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）*/ overflow: hidden; /*（文本溢出限定的宽度就隐藏内容）*/ text-overflow: ellipsis; /*（多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本)*/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d7823e93c09b83888082671a3da25b/" rel="bookmark">
			Androidstudio去掉标题栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入项目 res/values/themes.xml里面添加一个新的style
记住name这个(name="Theme.AppCompat.NoActionBar")
进入AndroidManifest.xml这个（）
更改 application里面的 android:theme="@style/Theme.AppCompat.NoActionBar"
注意@style/后面的是上面的name，一定要一样的哦！！！
之在要生效的activity中的onCreate里面添加以下代码，去除默认标题栏
ActionBar actionBar=getSupportActionBar(); if(actionBar!=null){ actionBar.hide(); } 这样就完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a9ca1c524085dd9b5dacba26e6a61a/" rel="bookmark">
			JavaScript基础：通过id值、class值、tagName值、name属性获取相应的一个或多个元素节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;JavaScript基础：通过id值、class值、tagName值、name属性获取相应的一个或多个元素节点&lt;/title&gt; &lt;!-- 闭包： 可简单理解为子方法可以使用父方法里的变量（不建议使用闭包，变量不易释放） DOM: 1、DOM: 即 Document Object Model 。 2、DOM用于操作html文档，准确地说是操作html标签里的内容。 3、JavaScript中将每一个标签当作对象处理。 4、在html中，每个标签都拥有自己的属性，如：style、id、class等，也拥有触发事件、方法。 同样在JavaScript中，作为对象处理的标签也拥有属性、事件、方法等成员。 5、操作DOM对象，一般使用document关键字调用。 JavaScript获取元素的方法： 根据id值获取一个元素节点： document.getElementById(id); 根据class值获取一组元素节点： document.getElementsByClassName(className); 根据name值获取一组元素节点： document.getElementsByName(name); 根据tagName（标签名称）值获取一组元素节点： document.getElementsByTagName(tagName); 根据id值、class值、tagName值获取一个元素节点，不能使用name属性获取： 注意：如果获取了一组元素节点，默认只返回第一个元素节点 document.querySelector(id | className | tagName); 根据id值、class值、tagName值获取一组元素节点，不能使用name属性获取： 注意：即使只获取了一个元素节点，也会返回NodeList数组 document.querySelectorAll(id | className | tagName); --&gt; &lt;style&gt; div{ width: 160px; height: 160px; margin: 10px; display: inline-block; } input{ width: 160px; height: 50px; margin-right: 20px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a9ca1c524085dd9b5dacba26e6a61a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd2ddaa4eef9f9355de50a72bf3cbc5/" rel="bookmark">
			R语言数据降维——主成分分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言数据降维——主成分分析 一、项目环境 开发工具：RStudioR：3.5.2相关包：sqldf，dplyr 二、导入数据 # 这里我们使用的是鸢尾花数据集（iris） data(iris) head(iris) Sepal.LengthSepal.WidthPetal.LengthPetal.WidthSpecies15.13.51.40.2setosa24.93.01.40.2setosa34.73.21.30.2setosa44.63.11.50.2setosa55.03.61.40.2setosa65.43.91.70.4setosa 相关数据解释：
Sepal.Length：萼片长度
Sepal.Width：萼片宽度
Petal.Length：花瓣长度
Petal.Width：花瓣宽度
Species：鸢尾花品种
三、 数据划分 library(dplyr) library(sqldf) # 为数据集增加序号列（id） iris$id &lt;- c(1:nrow(iris)) # 将鸢尾花数据集中70%的数据划分为训练集 iris_train &lt;- sample_frac(iris, 0.7, replace = TRUE) # 使用sql语句将剩下的30%花费为测试集 iris_test &lt;- sqldf(" select * from iris where id not in ( select id from iris_train ) ") # 去除序号列（id） iris_train &lt;- iris_train[,-6] iris_test &lt;- iris_test[,-6] 【注】：这里使用到sqldf包的函数sqldf函数来时间在R语言中使用SQL语句
四、 进行主成分分析 # 对鸢尾花数据集的前4列进行主成分分析 iris_train_pca &lt;- princomp(iris_train[,1:4]) # 绘制碎石图 screeplot(iris_train_pca, npcs = ncol(iris_train),type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd2ddaa4eef9f9355de50a72bf3cbc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be6fc9d5c4983aee2ace75272e86e02c/" rel="bookmark">
			MoMent时间工具类（JS）的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MoMent的基本使用 以下是 Moment.js 的所有 API 及其参数介绍，按照功能分类，方便查阅。其中，参数类型为 Moment 表示参数应该是一个 Moment 对象，String 表示参数应该是一个字符串，Object 表示参数应该是一个对象，Number 表示参数应该是一个数字。
创建 Moment 对象 方法名参数说明moment()无返回当前时间的 Moment 对象moment(String)String根据字符串创建 Moment 对象moment(String, String)String, String根据字符串和格式创建 Moment 对象moment(Moment)Moment根据另一个 Moment 对象创建 Moment 对象 获取和设置 Moment 对象的值 方法名参数说明year()Number获取或设置年份month()Number获取或设置月份，范围是 0 到 11，0 表示一月date()Number获取或设置日期day()Number获取或设置星期几，范围是 0 到 6，0 表示星期日hour()Number获取或设置小时数，范围是 0 到 23minute()Number获取或设置分钟数second()Number获取或设置秒数millisecond()Number获取或设置毫秒数 格式化 Moment 对象 方法名参数说明format(String)String格式化 Moment 对象为指定格式的字符串 操作 Moment 对象 方法名参数说明add(Number, String)Number, String在原有的 Moment 对象上添加指定的时间量，并返回一个新的 Moment 对象subtract(Number, String)Number, String在原有的 Moment 对象上减去指定的时间量，并返回一个新的 Moment 对象startOf(String)String将 Moment 对象设置为指定时间单位的开始，例如 startOf('day') 表示将 Moment 对象设置为当天的开始endOf(String)String将 Moment 对象设置为指定时间单位的结束，例如 endOf('day') 表示将 Moment 对象设置为当天的结束 获取 Moment 对象的值 方法名参数说明valueOf()无获取 Moment 对象的时间戳unix()无获取 Moment 对象的 UNIX 时间戳toDate()无获取 Moment 对象的 Date 对象toISOString()无获取 Moment 对象的 ISO 8601 格式字符串toArray()无获取 Moment 对象的值的数组，格式为 [年份, 月份, 日期, 小时数, 分钟数, 秒数, 毫秒数]toJSON()无获取 Moment 对象的 JSON 格式字符串 比较 Moment 对象 方法名参数说明isBefore(Moment, String)Moment, String判断当前 Moment 对象是否在指定 Moment 对象之前isSame(Moment, String)Moment, String判断当前 Moment 对象是否与指定 Moment 对象相同isAfter(Moment, String)Moment, String判断当前 Moment 对象是否在指定 Moment 对象之后isBetween(Moment, Moment, String)Moment, Moment, String判断当前 Moment 对象是否在指定的两个 Moment 对象之间 处理时区 方法名参数说明tz()String设置或获取 Moment 对象的时区utc()无将 Moment 对象设置为 UTC 时间local()无将 Moment 对象设置为本地时间 解析字符串 方法名参数说明parseZone(String)String解析带时区信息的字符串，返回 Moment 对象utc(String)String解析 UTC 时间的字符串，返回 文档 好的，下面是 Moment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be6fc9d5c4983aee2ace75272e86e02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9475f3234bcd593818f66a8f502b57/" rel="bookmark">
			R语言数据预处理——离散化（分箱）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言数据预处理——离散化（分箱） 一、项目环境 开发工具：RStudioR：3.5.2相关包：infotheo，discretization，smbinning，dplyr，sqldf 二、导入数据 # 这里我们使用的是鸢尾花数据集（iris） data(iris) head(iris) Sepal.LengthSepal.WidthPetal.LengthPetal.WidthSpecies15.13.51.40.2setosa24.93.01.40.2setosa34.73.21.30.2setosa44.63.11.50.2setosa55.03.61.40.2setosa65.43.91.70.4setosa 相关数据解释：
Sepal.Length：萼片长度
Sepal.Width：萼片宽度
Petal.Length：花瓣长度
Petal.Width：花瓣宽度
Species：鸢尾花品种
三、 数据划分 library(dplyr) library(sqldf) # 为数据集增加序号列（id） iris$id &lt;- c(1:nrow(iris)) # 将鸢尾花数据集中70%的数据划分为训练集 iris_train &lt;- sample_frac(iris, 0.7, replace = TRUE) # 使用sql语句将剩下的30%花费为测试集 iris_test &lt;- sqldf(" select * from iris where id not in ( select id from iris_train ) ") # 去除序号列（id） iris_train &lt;- iris_train[,-6] iris_test &lt;- iris_test[,-6] 【注】：这里使用到sqldf包的函数sqldf函数来时间在R语言中使用SQL语句
四、 无监督分箱 常见的几种无监督分箱方法
等宽分箱法等频分箱法kmeans分箱法 1、 分箱前准备法 # 导入无监督分箱包——infotheo library(infotheo) # 分成几个区域 nbins &lt;- 3 2、 等宽分箱法 ### 等宽分箱的原理非常简单，就是按照相同的间距将数据分成相应的等分 # 将连续型数据分成三份，并以1、2、3赋值 equal_width &lt;- discretize(iris_train$Sepal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d9475f3234bcd593818f66a8f502b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a44437ffde8e341bc80b0ef3019cf42/" rel="bookmark">
			R语言中的管道操作——magrittr包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言中的管道操作——magrittr包 一、项目环境 开发工具：RStudioR：3.5.2相关包：magritter 二、数据准备以及问题阐述 这次要解决的问题是如何使用提取数据框中所有包含缺失值的列。我们知道当我们在处理缺失值时，我们经常会使用平均数、中位数、回归、甚至机器学习等方式来填补数据框中的缺失值。但是在实际的分析过程中，在进行缺失值处理之前，我们往往会花大量的时间来探究缺失值之间的相关性。那么在进行分析之前，首要任务自然就是先将所有包含缺失值的列提取出来。下面我们将会用几种方法来进行这一操作，并说明管道操作的优势。
# 首先我们先导入相关包和数据集 # 导入magrittr包 library(magrittr) # 导入VIM包中的包含缺失值的数据集“sleep” data(sleep,package = "VIM") # 查看数据集的前几行数据 head(sleep) BodyWgtBrainWgtNonDDreamSleepSpanGestPredExpDanger6654.0005712.0NANA3.338.66453531.0006.66.32.08.34.5423133.38544.5NANA12.514.0601110.9205.7NANA16.5NA255232547.0004603.02.11.83.969.062435410.550179.59.10.79.827.0180444 BodyWgt： 体重
BrainWgt： 脑重
NonD： 不做梦时长
Dream： 做梦时长
Sleep： 睡眠时长
Span： 寿命
Gest： 妊娠期
Pred： 物种被捕食的程度
Exp： 睡眠时暴露的程度
Danger： 面临的总危险程度
三、提取包含缺失值的列 1、常规形式 library(dplyr) # 将原始数据赋值到一个临时变量中 data &lt;- sleep # 在R语言中，FALSE转换成数值会变成0，TRUE转换成数值会变成1 # 之所以用abs绝对值函数，是为了在将其转换成数值的前提下不破坏数据框的结构 data &lt;- apply(as.data.frame(abs(is.na(data))),2,sum) # 使用dplyr包的select函数选取所有包含缺失值的列 data &lt;- select(sleep,one_of(names(data[data &gt; 0]))) [注]：这是处理这类数据的一张常规的编写方法，但是会发现中间嵌套了很对层，不方便阅读和修改。同时中间变量data在这个计算的过程中重复出现了多次。
2、函数形式 library(dplyr) # 整体操作没什么变化，只是以函数的形式包裹起来，便于多次使用 na_col_plot &lt;- function(data){ data &lt;- as.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a44437ffde8e341bc80b0ef3019cf42/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/76/">«</a>
	<span class="pagination__item pagination__item--current">77/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/78/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>