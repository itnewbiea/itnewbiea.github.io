<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171de4b7878413e10d6509d1d1d7d290/" rel="bookmark">
			【React系列】非父子组件通信—Context.Provider共享数据、events库事件总线通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自#React系列教程：https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5MDAzNzkwNA==&amp;action=getalbum&amp;album_id=1566025152667107329)
一. Context使用 1.1. Context应用场景 非父子组件数据的共享：
在开发中，比较常见的数据传递方式是通过props属性自上而下（由父到子）进行传递。但是对于有一些场景：比如一些数据需要在多个组件中进行共享（地区偏好、UI主题、用户登录状态、用户信息等）。如果我们在顶层的App中定义这些信息，之后一层层传递下去，那么对于一些中间层不需要数据的组件来说，是一种冗余的操作。 我们来看一个例子：
import React, { Component } from 'react'; function ProfileHeader(props) { return ( &lt;div&gt; &lt;h2&gt;用户昵称: {props.nickname}&lt;/h2&gt; &lt;h2&gt;用户等级: {props.level}&lt;/h2&gt; &lt;/div&gt; ) } class Profile extends Component { render() { return ( &lt;div&gt; &lt;ProfileHeader nickname={this.props.nickname} level={this.props.level} /&gt; &lt;ul&gt; &lt;li&gt;设置1&lt;/li&gt; &lt;li&gt;设置2&lt;/li&gt; &lt;li&gt;设置3&lt;/li&gt; &lt;li&gt;设置4&lt;/li&gt; &lt;li&gt;设置5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) } } export default class App extends Component { constructor() { super(); this.state = { nickname: "coderwhy", level: 99 } } render() { const { nickname, level } = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171de4b7878413e10d6509d1d1d7d290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9311d48fab3945ead8239dfa9b6a1e1/" rel="bookmark">
			Ubuntu18.04 升级Ubuntu20.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景升级方法遇到的问题 背景 因项目环境需要，欲将Ubuntu18.04升级至Ubuntu20.04，参考网上其他小伙伴的方法，也遇到了一个问题，特此记录一下，希望能帮助其他有同样问题的小伙伴。
升级方法 参考：第十五章 Ubuntu18.04LTS升级到20.04LTS
主要的步骤：
sudo apt update sudo apt upgrade sudo apt install update-manager-core sudo do-release-upgrade 遇到的问题 在执行“do-release-upgrade”时，遇到“Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings”的问题。
参考：修复 Ubuntu 无法进行版本更新的错误
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8eace6db7e024fe941a18c7b170d570/" rel="bookmark">
			【React系列】React生命周期、setState深入理解、 shouldComponentUpdate和PureComponent性能优化、脚手架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自#React系列教程：https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg5MDAzNzkwNA==&amp;action=getalbum&amp;album_id=1566025152667107329)
一. 生命周期 1.1. 认识生命周期 很多的事物都有从创建到销毁的整个过程，这个过程称之为是生命周期；
React组件也有自己的生命周期，了解组件的生命周期可以让我们在最合适的地方完成自己想要的功能；
生命周期和生命周期函数的关系：
生命周期是一个抽象的概念，在生命周期的整个过程，分成了很多个阶段； 比如装载阶段（Mount），组件第一次在DOM树中被渲染的过程；比如更新过程（Update），组件状态发生变化，重新更新渲染的过程；比如卸载过程（Unmount），组件从DOM树中被移除的过程； React内部为了告诉我们当前处于哪些阶段，会对我们组件内部实现的某些函数进行回调，这些函数就是生命周期函数： 比如实现componentDidMount函数：组件已经挂载到DOM上时，就会回调；比如实现componentDidUpdate函数：组件已经发生了更新时，就会回调；比如实现componentWillUnmount函数：组件即将被移除时，就会回调； 我们可以在这些回调函数中编写自己的逻辑代码，来完成自己的需求功能；
我们谈React生命周期时，主要谈的类的生命周期，因为函数式组件是没有生命周期函数的；（后面我们可以通过hooks来模拟一些生命周期的回调）
1.2. 常用生命周期解析 我们先来学习一下最基础、最常用的生命周期函数：
上图第一个区域解析：
当我们挂载一个组件时，会先执行constructor构造方法来创建组件；紧接着调用render函数，获取要渲染的DOM结构（jsx），并且开始渲染DOM；当组件挂载成功（DOM渲染完成），会执行componentDidMount生命周期函数； 上图第二个区域解析：
当我们通过修改props，或者调用setState修改内部状态，或者直接调用forceUpdate时会重新调用render函数，进行更新操作；当更新完成时，会回调componentDidUpdate生命周期函数； 上图第三个区域解析：
当我们的组件不再使用，会被从DOM中移除掉（卸载）；这个时候会回调componentWillUnmount生命周期函数； 1.3. 生命周期函数 constructor
constructor(props) 如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。
constructor中通常只做两件事情：
通过给 this.state 赋值对象来初始化内部的state；为事件绑定实例（this）； componentDidMount
componentDidMount() componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。
componentDidMount中通常进行哪里操作呢？
依赖于DOM的操作可以在这里进行；在此处发送网络请求就最好的地方；（官方建议）可以在此处添加一些订阅（会在componentWillUnmount取消订阅）； componentDidUpdate
componentDidUpdate(prevProps, prevState, snapshot) componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。
当组件更新后，可以在此处对 DOM 进行操作；如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。 componentDidUpdate(prevProps) { // 典型用法（不要忘记比较 props）： if (this.props.userID !== prevProps.userID) { this.fetchData(this.props.userID); } } componentWillUnmount
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8eace6db7e024fe941a18c7b170d570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dba8c9c88decb21a3f0d5d83586ef35/" rel="bookmark">
			使用acado生成mpc控制器c&#43;&#43;代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装Acado 见：Linux配置Acado
第二步：配置环境变量 在ACADOtoolkit/build下找到环境变量配置脚本acado_env.sh，右键打开属性，并在Allow executing file as program处打勾。
在~/.bashrc中添加如下脚本信息，注意填写自己的安装路径
source /home/your_username/your_install_path/ACADOtoolkit/build/acado_env.sh 可能需要重启后生效。
第三步：定义待求解的优化控制问题 建立一个文件夹用于存放后续生成的代码，例如model。
在model下，建立一个.cpp文件用于定义优化控制问题，如my_pendulum.cpp。该文件的变量定义及函数调用参考acado提供的例子，注意，应该是code_generation下的，也即与代码生成相关的例子。
关键字样：
第四步：配置cmake 在acado安装目录下，找到FindACADO.cmake文件，将其复制进model
在model中，编写CMakeLists.txt文件
# Minimum required version of cmake CMAKE_MINIMUM_REQUIRED( VERSION 2.8 ) # Project name and programming languages used PROJECT( model ) # CMake module(s) path SET( CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${PROJECT_SOURCE_DIR} ) # activate c++ 11 IF(CMAKE_COMPILER_IS_GNUCC) SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x") ELSE() SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11") ENDIF() FIND_PACKAGE( ACADO REQUIRED ) INCLUDE_DIRECTORIES( . ${ACADO_INCLUDE_DIRS} ) ADD_EXECUTABLE( quadrotor_model_codegen my_pendulum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dba8c9c88decb21a3f0d5d83586ef35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b980819ad9fe11ae1656fea8792b71/" rel="bookmark">
			什么是华为OD？怎么才能通过华为OD机试？华为OD机试怎么刷题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是华为OD，什么是华为OD机试？二、华为OD面试流程？三、华为OD机试通过率高吗？四、华为OD薪资待遇？五、大家比较关注问题的FAQ🪐Q：应聘个OD为什么HR第一次联系我就要提供身份证号码？🪐Q：OD转华为必须连续两次绩效A吗？🪐Q：OD转华为后会有明显涨薪吗？🪐Q：OD试用期转正难吗？🪐Q：如何知道自己的机考成绩？ 🚀六、怎么刷题？通过华为OD机试？华为OD最新刷题列表 作者：KJ.JK 一、什么是华为OD，什么是华为OD机试？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是同薪同酬，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的，OD其实简单说就是外包，现在有很多公司都在给华为供给外包服务，比如中软，因为华为有很多业务部门，去年一个很熟的猎头给我推荐了几个技术岗位的华为OD都通过了
而华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式，
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环
🔥2024华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2024华为OD机试真题(C语言) B+C+D卷🔥
🔥2024华为OD机试真题(Python语言) B+C+D卷🔥
🔥2024华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++语言) B+C+D卷🔥
🔥2024华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2024华为OD机试真题(Golang语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++ Java Python) 🔥
二、华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
1、笔试：考察候选人的基础知识、算法设计和编程能力等多个方面，题目通常包括算法题、编程题、数据结构题等
2、性格测试(综合测试)：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等
3、技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决，围绕计算机/编程基础+项目经验+代码能力进行考察，如应届生无项目经验，重点复习八股文+刷算法题
4、HR面：围绕求职动机、稳定性、薪酬期望、Gap经历、延毕等异常情况进行考察
5、终面：终面是在参加完所有面试后进行的最后一轮面试，，主要考察候选人的综合素质和领导潜力；其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同，最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数
全流程线上进行，一般机考通过后2-3周内出offer，特殊情况时间过长的话需要积极联系接口人HR
三、华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试
四、华为OD薪资待遇？ 薪资结构：
1、基本工资+绩效工资+年终奖（2-4个月，一般绩效A-4个月，B-2个月）；
2、D1-D5分别对应华为13-17级，参考范围10-40K；
3、试用期内（6个月）工资不打折，按B绩效发绩效工资，转正时重新评绩效，一般分A、B、C三档（主要A或B，C概率较小），和正式员工分开评，半年评一次；
4、五险一金基数按基本工资，公积金比例5%-12%，具体看base地。
5、福利补贴：带薪年假、入职&amp;年度免费体检、免费夜宵、班车/加班打车免费、下午茶、节假日礼品等
13级薪资：9k-13k
14级薪资：13k-17k
15级薪资：17k-21k
16级薪资：21k-25k
17级薪资：25k-29k
五、大家比较关注问题的FAQ 🪐Q：应聘个OD为什么HR第一次联系我就要提供身份证号码？ 招聘系统规则和流程需要，一是需要身份证号码查重，确保你目前没有在任何部门流程中（名字+手机号码有时不一定准确）；二是需要录入系统生成唯一有效简历ID（当然系统会对部分数字打码保护隐私）；三是机考和综测申请等都需要身份证号码作为查重凭证，确保半年内你没有或只参加过这一次机考和综测。如果了解某个部门的业务/岗位是自己比较感兴趣的，或者觉得这个HR是比较靠谱的，正常提供即可
🪐Q：OD转华为必须连续两次绩效A吗？ 最好是，但不一定，一般最近拿过一次也行，绩效A占比大概在20%左右，主要取决于你所在部门转的指标多不多，和你同符合基本条件OD同事间的竞争情况。
本部门OD基数多还是少对转正编难易不是绝对关键因素，关键还是指标！指标！指标！（其实有些部门的主管看你考过了专业级，你干得也还行，会主动创造机会让你负责更容易拿A的项目）
🪐Q：OD转华为后会有明显涨薪吗？ 一般按同级转，比如D3转15级，但是薪酬是否涨不好说的，综合因素太多，比如你当时以OD进来的时候也许已经倒挂同级正式老员工了。
（你也许会说：他有股票呀！但实际情况有些老员工真的配的那点股票+绩效一般一直没怎么涨的那点工资真不如OD）
或者当时因为上一份流水base太低，进来也不高，又或者你进来后虽然成功转了，但实际能力不一定真的强到能一下子加很多薪。
个人建议你转了之后，奋斗一下争取正式满2年后绩效好看到能不能配点股吧，或者升一升级。对了，转正式后，也要满一年才能通过”内部人才市场“转其他部门。
🪐Q：OD试用期转正难吗？ 工作态度没问题的情况下，一般要求D1-D2通过入门级可信认证，D3-D5通过工作级可信认证，如果没通过，会进行备案，要求一年内通过（华为内部有持证上岗的要求）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b980819ad9fe11ae1656fea8792b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f0da5f8b745f61dcdc4acb183a6737/" rel="bookmark">
			深度学习在机器视觉领域的应用：分类、目标检测与语义分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着深度学习技术的不断进步，机器视觉领域已经发生了革命性的变化。深度学习的算法在图像和视频的理解上展现出了前所未有的效果，尤其在图像分类、目标检测和语义分割这三个核心任务上取得了显著的成就。本文将从深度学习算法工程师的角度，探讨这三个任务的技术要点、使用场景以及它们之间的关联。
图像分类（Image Classification） 图像分类是深度学习中的基础任务，它的目的是将图像分配到预先定义的类别中。图像分类的任务相对简单，只需要识别出图像中的主要内容是什么即可，不需要定位或者分割出物体的具体位置。
​
技术要点： 1. 卷积神经网络（CNN）：CNN是图像分类中最常用的深度学习模型，通过多层卷积层和池化层来提取图像的特征，并通过全连接层来进行分类。
2. 数据增强：为了让模型具有更好的泛化能力，通常会对训练数据进行各种变换，如旋转、缩放、裁剪等。
3. 模型结构：从LeNet、AlexNet到VGG、Inception、ResNet等，模型结构的创新也是提升分类性能的关键。
4. 迁移学习：在数据量不足时，可以通过迁移学习的方式使用预训练模型，迁移已有的知识以提高性能。
使用场景： 图像分类被广泛应用于内容检索、安全监控、医疗诊断、自动驾驶等多个领域。例如，在医疗诊断中，图像分类可以帮助识别X光或MRI图像中的异常区域；在自动驾驶中，可以对道路上的障碍物进行分类。
目标检测（Object Detection） 目标检测不仅要识别图像中的对象，还要确定它们的位置和大小，通常以边界框（bounding box）的形式表示。
技术要点： 1. 两阶段检测器：如R-CNN、Fast R-CNN和Faster R-CNN，首先生成候选区域（region proposal），然后对这些区域进行分类和边界框回归。
2. 单阶段检测器：如YOLO和SSD，直接在单个网络中预测类别和边界框，速度更快，但可能牺牲一些准确性。
3. 锚框（Anchor boxes）：用于预定义不同尺寸和比例的边界框，以改善检测器的性能。
4. 非极大值抑制（NMS）：用于去除多余的边界框，保留最优的检测结果。
使用场景： 目标检测在视频监控、无人零售、智能交通等领域有着广泛的应用。比如，在智能交通系统中，目标检测可以用来识别和跟踪行人和车辆，进而实现交通流量控制和事故预防。
语义分割（Semantic Segmentation） 语义分割旨在对图像中的每个像素进行分类，实现对图像中每个物体的精确边界的划分。
技术要点： 1. 全卷积网络（FCN）：将传统CNN中的全连接层替换为卷积层，使得网络可以接受任意尺寸的输入图像，并输出相应尺寸的分割图。
2. 上采样和跳跃连接：通过上采样和跳跃连接结构，FCN能够结合低层次的细节信息和高层次的语义信息，提高分割的准确性。
3. 分割网络架构：如U-Net、SegNet、DeepLab等，这些架构通过特殊的设计来改善分割的性能。
4. 条件随机场（CRF）：后处理步骤，用于优化分割的细节，使边界更加清晰。
使用场景： 语义分割在医疗图像分析、自动驾驶、机器人感知等方面有着重要的应用。例如，在自动驾驶领域，语义分割可以帮助车辆对路面、行人、车辆等进行精确的像素级识别，从而实现安全导航。
​
图像分类、目标检测和语义分割是深度学习在机器视觉领域的三个核心任务，它们分别解决了“是什么”、“在哪里”和“具体边界在哪里”的问题。尽管这些任务在技术和应用上有所不同，但它们都依赖于深度学习模型的强大特征提取能力。随着技术的不断发展，这些任务的界限也在逐渐模糊，例如，目标检测和语义分割的结合产生了实例分割任务。未来，随着算法的进一步创新和计算资源的提升，深度学习在机器视觉领域的应用将更加广泛和深入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc771e2e7a546b2f412a1e6d6b142b8/" rel="bookmark">
			how2heap-2.23-01-fastbin_dup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; int main() { fprintf(stderr, "This file demonstrates a simple double-free attack with fastbins.\n"); fprintf(stderr, "Allocating 3 buffers.\n"); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, "1st malloc(8): %p\n", a); fprintf(stderr, "2nd malloc(8): %p\n", b); fprintf(stderr, "3rd malloc(8): %p\n", c); fprintf(stderr, "Freeing the first one...\n"); free(a); fprintf(stderr, "If we free %p again, things will crash because %p is at the top of the free list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdc771e2e7a546b2f412a1e6d6b142b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64df250723bcf857eb7b059334ba06cf/" rel="bookmark">
			我的2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽大家好，我是咸鱼。
果然出来工作后地球转速加快是正常现象，不知不觉 2023 年就结束了，我到现在都有种昨天刚过完 2023 年春节的恍惚。
工作时长已有一年多，刚开始接触工作的时候，有许多工作上的东西能够让我去学习，无论是技术方面还是业务方面都进步很快。
随着工作逐渐得心应手，感觉进步的曲线开始逐渐平缓。
即使偶尔逼自己看一些书籍或学习一门技术来提升自己，但是过一段时间之后就偃旗息鼓开始放弃了（例如之前热情高涨地要学 FLask ，买了书学了三分之一写了两篇文章之后就再也没打开过）。
我开始感到焦虑和纠结，不学的时候担心如果每天除了工作外没有额外的学习，自己将无法有所进步，与他人的差距逐渐加大；学的时候发现自己并不享受这个过程，或者每当学习时，内心就会出现一个声音：工作了一天这么累了，别再学了，好好休息刷刷短视频不好吗？
每当纠结时不出意外的话往往最后多半躺在床上玩手机刷短视频，至多做些明天的规划。
大脑 现在我一般通过两种途径去驱动自己学习：
写文章工作 工作这块就不细说了，写文章是我主动学习的一个有效途径，现在基本能保持一周 2~3 的文章更新速度，现在已经有 169 篇原创了。
前 100 篇以自己的学习笔记居多，100 篇之后的文章更多的是译文。虽然说是译文，但是我觉得写翻译文章也是比较耗费精力的，远不是简单使用翻译软件就能完成的工作。
下面分享一些我觉得比较优质的信息源/个人博客：
阮一峰的网络日志：https://www.ruanyifeng.com/blog/ 计算机科普博主，每周五准时更新 酷 壳 – CoolShell：https://coolshell.cn/ 耗子叔，我之前的文章多次提及过 豌豆花下猫：https://pythoncat.top/ 优质的 python 信息源 李辉：https://greyli.com/ Flask 维护者，《Flask Web 开发实战：入门、进阶与原理解析》作者 卡瓦邦噶：https://www.kawabangga.com/ 一位很厉害的 SRE，转发过他很多文章 栋哥的赛博空间：https://liuyandong.com/ 每天都会去上面听栋哥讲故事 RealPython：https://realpython.com/ 很好的 Python 学习网站，很多国外学校会拿上面的内容当课程 今年开始尝试在掘金、阿里云等平台上发布文章
CSDN
自从我把 CSDN 上面的文章改成粉丝可见之后，我的粉丝量嘎嘎涨，后悔没早点意识到这一点哈哈哈。
不出意外的话这个月就能拿到 CSDN 的专家认证。
知乎
接近 50w 的阅读量，有一篇文章还被官方收录进去。
不得不说，知乎在创作者福利这块还是挺好的，每年传统节日都能收到知乎送的礼物。
阿里云
拿了个阿里云专家博主的证书，以及一些小礼品啥的。
小红书
小红书可以说是 2023 年新尝试的赛道了，区别于其他平台，小红书内容更多的是图文形式，而且小到昵称头像，大到个人简介笔记文案都有自己的规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64df250723bcf857eb7b059334ba06cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80063a7ff7d3f6b82f0f7ce51f704599/" rel="bookmark">
			Keras常用的激活函数详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Keras中，常用的激活函数包括以下几种，我将为您详细介绍它们：
线性激活函数 (Linear)： 公式：(f(x) = x)特点：线性激活函数实际上不对输入进行任何改变，它直接输出输入值。这通常在回归问题或神经网络的最后一层中使用，当需要输出任意实数值时。Sigmoid激活函数： 公式：(f(x) = \frac{1}{1 + e^{-x}})特点：Sigmoid函数将输入压缩到0和1之间，通常用于二分类问题的输出层。然而，由于其梯度在极端值处接近于0，可能导致梯度消失问题。双曲正切激活函数 (Tanh)： 公式：(f(x) = \frac{e^{x} - e^{-x}}{e^{x} + e^{-x}})特点：Tanh函数将输入压缩到-1和1之间。与Sigmoid相比，Tanh在原点附近的梯度更大，收敛速度可能更快。然而，它同样存在梯度消失的问题。ReLU (Rectified Linear Unit) 激活函数： 公式：(f(x) = \max(0, x))特点：ReLU是近年来非常流行的激活函数。它在输入大于0时直接输出该值，在输入小于等于0时输出0。ReLU能够加速神经网络的训练，因为它在激活区的梯度为1，避免了梯度消失问题。然而，ReLU在输入小于0时梯度为0，可能导致神经元“死亡”。Leaky ReLU激活函数： 公式：(f(x) = \alpha x)（当 (x &lt; 0)），(f(x) = x)（当 (x \geq 0)）其中 (\alpha) 是一个小的正数。特点：Leaky ReLU是ReLU的变体，允许小的负激活值。这有助于避免神经元“死亡”问题，并在某些情况下表现得比ReLU更好。Softmax激活函数： 公式：对于多分类问题的输出层，Softmax将输入向量归一化为概率分布。(f(x)i = \frac{e^{x_i}}{\sum{j=1}^{N} e^{x_j}}) 其中 (i) 是类别索引，(N) 是类别总数。特点：Softmax通常用于多分类问题的最后一层，输出每个类别的概率分布。它能够突出最大值并抑制其他值，从而得到一个概率分布。Softplus激活函数： 公式：(f(x) = \log(1 + e^{x}))特点：Softplus可以看作是ReLU的平滑版本，在输入值较小时也能有非零的输出。它更接近生物神经元的激活模型。 在Keras中，这些激活函数可以通过在模型定义时指定相应的参数来使用。例如，在Dense层中使用ReLU激活函数可以写成Dense(units=64, activation='relu')。通过选择合适的激活函数，您可以构建出适用于特定任务的神经网络模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b13fd5a5d2753ecb7d0225e14498d0/" rel="bookmark">
			大数据毕设分享 flink大数据淘宝用户行为数据实时分析与可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1、环境准备1.1 flink 下载相关 jar 包1.2 生成 kafka 数据1.3 开发前的三个小 tip 2、flink-sql 客户端编写运行 sql2.1 创建 kafka 数据源表2.2 指标统计：每小时成交量2.2.1 创建 es 结果表， 存放每小时的成交量2.2.2 执行 sql ，统计每小时的成交量 2.3 指标统计：每10分钟累计独立用户数2.3.1 创建 es 结果表，存放每10分钟累计独立用户数2.3.2 创建视图2.3.3 执行 sql ，统计每10分钟的累计独立用户数 2.4 指标统计：商品类目销量排行2.4.1 创建商品类目维表2.4.1 创建 es 结果表，存放商品类目排行表2.4.2 创建视图2.4.3 执行 sql , 统计商品类目销量排行 3、最终效果与体验心得3.1 最终效果3.2 体验心得3.2.1 执行3.2.2 存储 4 最后 0 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 flink大数据淘宝用户行为数据实时分析与可视化
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 1、环境准备 1.1 flink 下载相关 jar 包 flink-sql 连接外部系统时，需要依赖特定的 jar 包，所以需要事先把这些 jar 包准备好。说明与下载入口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66b13fd5a5d2753ecb7d0225e14498d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5809721a152b044dd97496ba12b647d/" rel="bookmark">
			【设计模式】观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、概述结构 二、案例实现三、分析优缺点使用场景 四、JDK中提供的实现总结 前言 【设计模式】观察者模式——行为型模式。
一、概述 定义：
又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。
结构 在观察者模式中有如下角色：
Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。 二、案例实现 【例】微信公众号
在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。
类图如下：
代码如下：
定义抽象观察者类，里面定义一个更新的方法
public interface Observer { void update(String message); } 定义具体观察者类，微信用户是观察者，里面实现了更新的方法
public class WeixinUser implements Observer { // 微信用户名 private String name; public WeixinUser(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + "-" + message); } } 定义抽象主题类，提供了attach、detach、notify三个方法
public interface Subject { //增加订阅者 public void attach(Observer observer); //删除订阅者 public void detach(Observer observer); //通知订阅者更新消息 public void notify(String message); } 微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5809721a152b044dd97496ba12b647d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517b549ae8e21f3cea3d9c2389221ea3/" rel="bookmark">
			Django 8 通用视图基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是通用视图 1. 在terminal 输入 django-admin startapp the_12回车
2. tutorial\settings.py 注册 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', "the_3", "the_5", "the_6", "the_7", "the_8", "the_9", "the_10", "the_12", ] 3. tutorial\urls.py
urlpatterns = [ path('admin/', admin.site.urls), path('the_3/', include('the_3.urls')), path('the_4/', include('the_4.urls')), path('the_5/', include('the_5.urls')), path('the_7/', include('the_7.urls')), path('the_10/', include('the_10.urls')), path('the_12/', include('the_12.urls')), ] 4. the_12\views.py
from django.http import JsonResponse from django.shortcuts import render from django.views import View # Create your views here. class Chello(View): def get(self,request): return JsonResponse({"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517b549ae8e21f3cea3d9c2389221ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06c5a8513aed4e491e7f39e3d02bde6/" rel="bookmark">
			介绍一个Python模块，绘制超级惊艳的可视化动图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天小编给大家介绍一款可视化模块，使用它可以绘制出十分惊艳的动图效果，那么当然第一步我们首先是要安装一下该模块，通过pip命令行来安装
pip install ipyvizzu 牛刀小试 我们首先来简单地使用该模块来绘制一张动图，用Pandas导入数据集，代码如下
import pandas as pd from ipyvizzu import Chart, Data, Config data_frame = pd.read_csv("titanic.csv") 在导入数据集完毕之后，小编先来介绍一下使用该模块的大致步骤，我们实例化Data()对象，然后将导入的数据集放置其中，代码如下
data = Data() data.add_data_frame(data_frame) 然后我们再实例化图表对象Chart()，将含有数据集的data放置其中
chart = Chart() chart.animate(data) 接下来我们开始绘制图表，需要指定好的是图表的一些属性，例如直方图的话就是X轴Y轴该放置什么样的数据，颜色选择是默认的还是需要另外指定的，以及标题等等
chart.animate(Config({"x": "Count", "y": "Sex", "label": "Count","title":"Passengers of the Titanic"})) output
然后我们再此基础之上，在添加上下面的代码，
chart.animate(Config({"x": ["Count","Survived"], "label": ["Count","Survived"], "color": "Survived"})) output
因此该模块绘制出来的所谓的动图，其实就是若干张静态图表的叠加，我们不妨来看一下完整的案例
import pandas as pd from ipyvizzu import Chart, Data, Config data_frame = pd.read_csv("titanic.csv") data = Data() data.add_data_frame(data_frame) chart = Chart() chart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d06c5a8513aed4e491e7f39e3d02bde6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45cc41ae321b04935a3470110547076/" rel="bookmark">
			C# 加载列表 报错：Nullable object must have a value.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可为null的对象必须有一个值。
原因：查询的表中存在某字段的值是null，然后代码对应的实体属性字段没有设置可为null，如：public int Age {get;set;}
排查：将查询后转换的对象里的属性字段设置可为null，如：public int? Age {get;set;}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ccc9679f92547ff156229df8ab46dc/" rel="bookmark">
			【力扣100】35.搜索插入位置 || 二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加链接描述
class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: n=len(nums) i,j=0,n-1 while i&lt;=j: mid=i+(j-i)//2 if nums[mid]==target: return mid elif target&lt;nums[mid]: j=mid-1 else: i=mid+1 #包含两种情况，1.target在mid右边 2.没有找到target，返回mid+1 return i 思路是：
经典二分查找，框架就是i，j 分别指向数组的首尾出查找条件是i&lt;=j 注意else里包含的两种情况 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a342b5d24923ceb96e35e1241a92991d/" rel="bookmark">
			Android 项目适配64位架构后，腾讯X5内核加载失败解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个蛮有意思的人工智能学习网站,8个字形容一下"通俗易懂，风趣幽默"，感觉非常有意思,忍不住分享一下给大家。
👉点击跳转到教程
在接入最新腾讯X5内核后，发现初始化会失败，在APP模块的build.gradle文件中放入对应的依赖，依赖由官网提供。
腾讯X5内核官方文档
这个目前是最新的依赖，sync后
implementation 'com.tencent.tbs:tbssdk:44286' 在MyApplication中进行初始化操作
class MyApplication : Application() { override fun onCreate() { super.onCreate() QbSdk.initX5Environment(applicationContext, object : QbSdk.PreInitCallback { override fun onCoreInitFinished() { } override fun onViewInitFinished(p0: Boolean) { LogUtils.d("腾讯X5内核：$p0") } }) } } 这个时候我们把真机上原有的APP删掉，之后重新运行，不然无法真实的测试是否能正常加载。运行后会发现输出logcat日志
腾讯X5内核：false 解决方案一：
疑惑官网虽然给出了说明，说64位手机无法加载X5内核，但是我已经下载的是最新SDK版本依然不行。
解决方案二：
用这个将包更改为2020年发布的版本即可使用，X5内核也能正常加载了，大家也能发现仓库名成也变了
最新的依赖是来自 com.tencent.tbs 组织的项目
这个可用的依赖是来自 com.tencent.tbs.tbssdk 组织的项目，具体原因不得而知，但是已经解决了加载失败的问题。
implementation 'com.tencent.tbs.tbssdk:sdk:43903' 如果知道原因的朋友们，可以在评论区一起讨论一下，一起成长，一起进步！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c9ad77fc091a820d3c0b8bed9be5cf/" rel="bookmark">
			八股文打卡day20——操作系统（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 面试题：线程同步的方式有哪些？ 我的回答： 多线程同时访问和修改某个数据的话，会造成数据的不一致和冲突问题，所以就需要线程同步，线程同步的方式有：
1.互斥锁
互斥锁就是，当一个资源被访问和操作时，会对这个资源加锁，把这个资源锁定，其他线程不能对其进行操作。直到上一个线程操作完成之后，会释放互斥锁，其他资源才可以进行操作。
2.信号量
信号量是互斥锁的扩展。允许多个线程同时访问同一个资源，当信号量大于1时，可以对资源进行访问；信号量为0时，其他线程阻塞。信号量为几，代表可以同时几个线程访问该资源。
3.条件变量
线程可以睡眠等待，而不是忙等待，这样可以节约CPU的资源。等某个条件成立的时候，线程再被唤醒。
4.读写锁
多个线程可以同时读取同一个数据，但是只允许一个线程对其进行写操作。读写锁适用于读多写少的场景。
5.自旋锁
类似于互斥锁。当资源被锁定之后，其他线程会在一个循环中等待，直到锁被释放。自旋锁适用于锁被持有时间较短的场景。
6.原子操作
确保某个操作是在单个步骤中完成，不会被其他线程所干扰。一般由硬件支持。
7.栅栏
就是允许多个线程等待，直到所有的线程都到达一个点之后，再同时执行。
8.事件
线程等待某个事件发生时，某个事件被触发了，等待的线程会被唤醒。
回答八股的时间：2024.01.04 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2deb5137f3d95aa057c029bc5e97d1/" rel="bookmark">
			keras 深度学习框架实现 手写数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读本文之前，请先参考--------win10搭建keras深度学习框架
安装运行环境
阅读本文之前，请先参考--------keras人工智能框架 MNIST 数据集 随机展示
查看训练图片
完整代码如下图：
在sublimeText中 使用ctrl+B运行代码，结果如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bdd58122a79fa3ba98509f414c339f7/" rel="bookmark">
			神经网络中的重要概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络是一种模拟生物神经网络结构和功能的计算模型，由许多节点（或称为神经元）和它们之间的连接构成。以下是一些神经网络中的重要概念，并对它们进行细致的讲解：
神经元（Neuron）：神经元是神经网络的基本单元，它接收来自其他神经元的输入信号，并通过激活函数产生输出信号。每个神经元都有一个权重（Weight），用于调整输入信号的重要性。神经元的输出可以通过连接传递给其他神经元，形成网络中的信息传递。
权重（Weight）：权重是神经网络中的可调参数，用于表示连接两个神经元之间的强度或影响程度。在训练过程中，通过调整权重来优化神经网络的性能，使其能够更好地适应输入数据并产生准确的输出。
偏置（Bias）：偏置是神经元中的一个固定值，用于调整激活函数的输入范围。它可以看作是神经元对输入的额外偏好或倾向性。偏置和权重一样，也是神经网络中的可调参数。
激活函数（Activation Function）：激活函数用于将神经元的输入转换为输出信号。它引入了非线性特性，使得神经网络能够学习和模拟更复杂的模式。常见的激活函数包括Sigmoid、ReLU（Rectified Linear Unit）、Tanh等。
层（Layer）：神经网络由多个层组成，每层包含一定数量的神经元。不同层之间的神经元通过连接进行信息传递。常见的神经网络层类型包括输入层、隐藏层和输出层。其中，输入层负责接收原始数据，隐藏层用于提取特征和学习表示，输出层则生成最终的预测结果。
前向传播（Forward Propagation）：前向传播是指从输入层开始，逐层计算每个神经元的输出值，直到达到输出层的过程。在前向传播中，输入数据经过各层的权重和激活函数的计算，最终生成神经网络的输出。
反向传播（Backpropagation）：反向传播是一种通过计算梯度来调整神经网络权重的方法。它从输出层开始，根据误差反向逐层计算每个神经元的梯度，并根据梯度更新权重，以最小化预测误差。反向传播是神经网络训练中的关键步骤之一。
批量处理（Batch Processing）：在训练神经网络时，通常将输入数据划分为多个小批量（Batch），每个批量包含一定数量的样本。然后对每个批量进行前向传播和反向传播的计算，以更新权重和偏置。批量处理可以提高计算效率，并且有助于避免过拟合现象。
迭代次数（Epoch）：一个迭代次数（Epoch）是指对整个训练数据集进行一次完整的前向传播和反向传播的过程。多个迭代次数的训练可以帮助神经网络逐步优化权重和偏置，提高模型的性能。
学习率（Learning Rate）：学习率是神经网络训练中的一个超参数，用于控制权重更新的步长大小。较大的学习率可能导致训练不稳定或收敛速度较慢，而较小的学习率可能导致训练时间过长或陷入局部最优解。因此，选择合适的学习率对于神经网络的训练非常重要。
这些概念在神经网络的构建、训练和优化过程中起着重要作用。通过理解和调整这些概念所代表的参数和结构，可以构建出适用于特定任务的强大神经网络模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a0ffb2030b098132f7956439075963/" rel="bookmark">
			echarts实现3D柱状图（视觉层面）和3D饼图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.3D柱状图 原理：
立体图形从一个方向只能看到三个面，于是我们通过echarts图表实现 顶部，明面，和暗面。
效果图如下：
需要四份数据，两个柱子的数据+X轴数据+颜色数据，
通过setData和setColor生成需要的数据，横向柱状图同理，参照代码中注释。
以下是完整案例代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf8"&gt;&lt;/meta&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.2/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; * { margin: 0; padding: 0; box-sizing: border-box; } .border { border: 1px solid #000; } .left { width: 25%; height: 100%; margin: 0 auto; }	&lt;/style&gt; &lt;body&gt; &lt;div class="left border"&gt; &lt;div id="litiBar1" style="width:100%;height:400px;background-color: #000;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; //组织数据 let setData = function(data, constData, showData) { data.filter(function(item) { if (item) { constData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a0ffb2030b098132f7956439075963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de52631f5264279b0d0d42dc472cde54/" rel="bookmark">
			自动驾驶货车编队行驶系统功能规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		货车编队行驶功能规范
Truck Platooning Functional Specification
目录
1 概述... 7
1.1 目的... 7
1.2 范围... 7
1.3 术语及缩写... 7
1.4 参考法规标准... 8
2 功能规范... 9
2.1 功能描述... 9
2.1.1 功能用途... 9
2.1.2 功能架构... 10
2.1.3 基本参数... 11
2.1.4 运行设计区域ODD.. 11
2.1.5 通用性要求... 15
2.2 感知需求及方案... 16
2.2.1 Sensor Fusion需求... 16
2.2.2 Sensor Lanes需求... 19
2.2.3 Reference Line需求... 19
2.2.4 传感器方案-OBU.. 20
2.3 整车及执行器方案... 20
2.3.1 整车需求... 20
2.3.2 横向控制执行器需求... 20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de52631f5264279b0d0d42dc472cde54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e1a8db3ad337ded67114764aaa88af/" rel="bookmark">
			月薪15000，在大西安的生活现状。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 点击上方 "大数据肌肉猿"关注, 星标一起成长 点击下方链接，进入高质量学习交流群 今日更新| 1052个转型案例分享-大数据交流群 转自 | 菜鸟学python 看到我前同事写的一个帖子，挺有感触的。
文中说到的“偶尔和邻居同事聚一下，花个200-300”中的同事，波哥就是其中之一。
当年，我和作者曾在一个项目组共事，一起去公司食堂吃午饭，下午工作累了会一起在园区散步摸鱼，每隔一两个月，我们几位比较关系好的同事，会相约一起喝点小酒，配着花生毛豆加上几把烤肉，花个二三百。
聊天也没有专门的目的，就是吹会牛吐吐槽，聊聊各自的“光辉经历”。不为什么，就是平时工作忙，借着这个机会放松下心情。
今天无意中看到同事的这个帖子，挺有感触。文字不长，只是简单陈述了自己的日常生活，但字里行间却流露着中年人的无奈。
同事讲的是自己的生活，但这其实也是很多中年职场人的现状，拿着看似还不错的收入，每天也仍需要精打细算。从帖子数据上也看得出一些问题，没发表多久就引起了大众的共鸣，目前已经获得了45万的展现量，以及500多条评论。
我们简单聊下这个话题，月薪15000在西安到底够不够花？
实话实说，这个薪资水平综合来看是处于上游的，按到手薪资，月入过万的也只是很少一部分人。
但是否够花这个问题，不能只看账面数字，还要综合考虑很多外在条件，几个主要的点：
1、是否准备买房？
如果你能全款买房，那自然不在我们这个话题讨论范围之内。对于大多数普通人来说，贷款买房的第一道经济门槛肯定是首付，在凑够首付的这几年工资基本是剩不下的。
2、是否有房贷车贷？
贷款每个月雷打不动，比如波哥目前房贷是6000元，如果按15000的工资来算的话，到手收入就变成了9K。
3、另一半是否有收入？
换句话说，就是这15000是一人的收入，还是一个家庭的收入，这点也很关键；
4、父母是否有退休金？是否正在抚养孩子？
这两点不用多解释。
当然，以上只是几个主要的点，还有很多琐碎的固定开销这里就不讲了。
如果有房无贷，另一半也有工作收入，父母身体健康且均有不错的退休金，满足这些条件的话，在西安月入1.5W是相当不错的。但这只是“理想状态”的情况。
大家有什么看法呢？欢迎留言探讨。
--end--
扫描下方二维码 添加好友，备注【交流】 可围观朋友圈，也可私信交流 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8541968b3aa3ac684d939caa1dae9f94/" rel="bookmark">
			力扣labuladong一刷day52天LRU算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣labuladong一刷day52天LRU算法 文章目录 力扣labuladong一刷day52天LRU算法概念一、146. LRU 缓存思路一：使用双向链表加map来手动实现。思路二：使用LinkedHashMap 概念 LRU的全称为Least Recently Used，翻译出来就是最近最少使用的意思，它是一种内存淘汰算法，当内存不够时，将内存中最久没使用的数据清理掉。 LUR算法是内存管理的一种页面置换算法，就是用来删除内存中不被使用的数据，腾出空间来把常用的数据存进去。
一、146. LRU 缓存 题目链接：https://leetcode.cn/problems/lru-cache/
思路一：使用双向链表加map来手动实现。 class Node { public int key, val; public Node next, prev; public Node(int k, int v) { key = k; val = v; } } class DoubleList{ private Node head, tail; private int size; public DoubleList() { head = new Node(0, 0); tail = new Node(0, 0); head.next = tail; tail.prev = head; size = 0; } void addLast(Node x) { x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8541968b3aa3ac684d939caa1dae9f94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d947ee80dbc8c7f6b8ed086ca2b1d9/" rel="bookmark">
			mfc140u.dll丢失的解决方法，了解mfc140u.dll文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实关于mfc140u.dll丢失的解决方法是有非常的多种的，而且每种解决方法都有其适用的情况，并不是每种都能好用的，好了，下面一起来了解一下mfc140u.dll这个文件。
一.mfc140u.dll文件 MFC140u.dll文件是Microsoft Visual Studio所用的一个动态链接库文件之一。它是基于MFC（Microsoft Foundation Class）库开发的，用于提供许多C++应用程序所需的函数和工具。
当你在运行依赖于MFC140u.dll文件的应用程序时，如果系统无法找到或加载该文件，可能会出现错误消息，例如“找不到mfc140u.dll”或“mfc140u.dll丢失”。这可能导致应用程序无法启动或执行所需的功能。
二.mfc140u.dll丢失解决方法 重新安装应用程序： 尝试重新安装触发错误的应用程序。重新安装应用程序的过程可能会自动修复缺失的MFC140u.dll文件。
使用Visual C++ Redistributable组件： MFC140u.dll文件是由Visual C++ Redistributable组件提供的，因此你可以尝试安装适用于你操作系统位数的Visual C++ Redistributable包。这可以补充缺失的dll文件，并为应用程序提供所需的支持。
使用dll修复工具： 在浏览器顶部输入：dll修复.site，点击回车键进入，官方站点下载一个dll修复工具，利用这个dll修复工具直接进行一键修复就可以了，它会根据你电脑系统缺失了哪些dll文件，然后进行相关的修复，如你丢失了mfc140u.dll就会帮你修复mfc140u.dll文件，操作比较简单方便。DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法-电脑修复精灵
手动复制MFC140u.dll文件： 从可信赖的来源下载适用于你操作系统位数（32位或64位）的MFC140u.dll文件，并将其复制到应用程序所在的目录中。确保将文件复制到应用程序根目录或系统路径中。
运行系统文件检查： 打开命令提示符窗口（以管理员身份运行），输入" sfc /scannow "命令并按回车键。系统文件检查工具将扫描并自动修复受损的系统文件，包括MFC140u.dll。
更新操作系统和驱动程序： 定期更新操作系统和驱动程序可以确保系统文件的完整性和最新性。执行Windows更新，并定期检查硬件制造商的官方网站以获取最新的驱动程序更新。
以上就是mfc140u.dll丢失的解决方法的全部分享，选择适合自己的方法去修复就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee3f5a2b97ce87fd2d4dfe6338e3b89/" rel="bookmark">
			送给小白的 7 个 python 小坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 缩进，符号和空格不正确2. 错误使用类变量3. 误解python范围规则4. python闭包变量绑定5. 名称与Python标准库模块发生冲突6. is和==/=和==7. 滥用\_\_init\_\_ Python入门全套学习资料附带源码：Python零基础入门视频Python项目源码Python入门到进阶电子书籍和实战案例👉100道Python练习题👈👉面试刷题👈 资料领取 前言 今天给大家总结一些易犯的小错误，让你轻松进行不踩坑的python学习。
1. 缩进，符号和空格不正确 写代码时大家会使用缩进、对齐、空格等，其目的是为了提高代码的可读性。
但在python语言中，许多功能都依赖于缩进。
比如在创建一个新类时，该类中的所有内容都在声明下缩进，决策、循环还有其它结构语句也会出现类似的情况，
如果你在代码执行时发现问题，可以查看一下是否使用了正确的缩进。
来看看下面的例子，在使用IF语句时，请确保使用正确且合适的冒号和缩进，因为它们会导致语法和缩进错误。
在上面的代码当中，出现了两处错误：if语句后面的：缺失；下一行没有进行正确的缩进，执行代码出错。
val = 500
if val &gt; 100:
print(“value is grater then 100”)
value is grater then 100
当你更正上述代码中的两个问题后，你会发现整段代码能够很好的运行。
2. 错误使用类变量 class A(object):x = 1
class B(A):pass
class C(A):pass
print( A.x, B.x, C.x)
1 1 1
这里输出的值都是1，然后我们试着来改变一下A.x和B.x的值看看有什么变化。
B.x = 2
print (A.x, B.x, C.x)
A.x = 3
print (A.x, B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cee3f5a2b97ce87fd2d4dfe6338e3b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5d8edc6d7ae78d30f73e9217ac316e/" rel="bookmark">
			依赖包和项目版本不一致的冲突解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下
npm WARN ERESOLVE overriding peer dependency npm WARN While resolving: vant@2.12.34 npm WARN Found: vue@2.5.21 npm WARN node_modules/vue npm WARN vue@"^2.5.21" from the root project npm WARN 3 more (vue-cli-plugin-i18n, vue-echarts, vuex) npm WARN npm WARN Could not resolve dependency: npm WARN peer vue@"&gt;= 2.6.0" from vant@2.12.34 npm WARN node_modules/vant npm WARN vant@"^2.2.16" from vue-scale@1.2.0 npm WARN node_modules/vue-scale npm WARN npm WARN Conflicting peer dependency: vue@3.4.4 npm WARN node_modules/vue npm WARN peer vue@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e5d8edc6d7ae78d30f73e9217ac316e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/996f757a8b0fafc614132882561bb245/" rel="bookmark">
			【力扣100】51.N皇后 || 斜线判断逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加链接描述
class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: # 思路是使用递归和回溯，然后判断斜线上是否存放值的逻辑 # 斜线只需要判断左上和右上，因为是一行一行遍历的 col=[0]*n ans=[] on_path=[False]*n left=[False]*(2*n-1) right=[False]*(2*n-1) def dfs(r): if r==n: ans.append(['.'*c + 'Q' + '.'*(n-c-1) for c in col]) return for c in range(n): if not on_path[c] and not left[r+c] and not right[r-c]: col[r]=c on_path[c] = left[r+c] = right[r-c] = True dfs(r+1) on_path[c] = left[r+c] = right[r-c] = False dfs(0) return ans 思路：
经典题目，这道题的难点在于斜线判断逻辑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f453a9c15ea9eb6e0bcd86fb85a44b66/" rel="bookmark">
			大数据编程期末大作业2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Hadoop基础操作
二、RDD编程
三、Spark SQL编程
四、Spark Streaming编程
五、Flume的安装配置
一、Hadoop基础操作 按要求完成以下操作：
1、在HDFS中创建目录 /user/root/你的名字。 例如：李四同学 /user/root/lisi，后同。
首先需要启动hdfs，在终端输入如下命令：
start-dfs.sh 在终端输入如下命令创建目录：
hdfs dfs -mkdir -p /user/root/***（你自己的名字全拼，下同） 2、创建本地文件lisi.txt，文件内容为包括Lisi love Hadoop等其他任意输入的6行英文句子，并将该文件上传到HDFS中第1题所创建的目录中。
在终端的root目录下面创建本地文件并输入题目要求的内容：
vim ***.txt 然后我们再在终端输入上传命令：
hdfs dfs -put ***.txt /user/root/*** 3、查看上传到HDFS中的lisi.txt文件的内容。
直接在终端输入查看命令：
hdfs dfs -cat /user/root/***/***.txt 4、在Hadoop官方的示例程序包hadoop-mapreduce-examples-3.1.3.jar中，包括计算Pi值的测试模块，使用hadoop jar命令提交计算Pi的MapReduce任务。
首先，启动yarn，命令如下：
start-yarn.sh 然后进入到hadoop下的mapreduce目录中： cd /usr/local/servers/hadoop/share/hadoop/mapreduce/ 最后执行如下命令即可计算Pi： hadoop jar hadoop-mapreduce-examples-3.1.3.jar pi 4 4 可以看出精度不是很高，上面命令后面的两个数字含义是，第一个4是运行4次map任务，第二个4是每个map任务投掷次数，总投掷次数就是两者相乘，想要提高精度就可以让数字变大，但是很容易出现作业计算失败的异常，这是因为计算内存不够，所以不能调的太大。 5、直接将第4题的计算结果保存到/user/root/lisi目录中lisiPi文件里。
先将计算结果保存到本地系统home目录下：
hadoop jar hadoop-mapreduce-examples-3.1.3.jar pi 4 4 &gt; /home/zhanghc/***PI.txt 然后将***PI.txt文件上传到HDFS的“/user/root/***”目录下并查看结果：
hdfs dfs -put /home/zhanghc/***PI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f453a9c15ea9eb6e0bcd86fb85a44b66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a2a120d88af8fe9726a43cfbd95a45/" rel="bookmark">
			React Hooks中useState的介绍，并封装为useSetState函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		useState 允许我们定义状态变量，并确保当这些状态变量的值发生变化时，页面会重新渲染。
useState 返回值 const [state, setState] = useState(initialState); useState 返回一个长度为 2 的数组。通常，我们这样定义状态变量：
const [key, setKey] = useState(0); 但实际上，我们也可以这样写：
const keyArr = useState(0); const key = keyArr[0]; const setKey = keyArr[1]; 这种写法显得有些繁琐，但它有助于我们理解 useState 的返回值类型。
useState 定义初始值 useState 定义初始值有两种用法：
传入一个初始值传入一个函数 传入一个初始值 const [key, setKey] = useState(0); 传入一个函数 const [key, setKey] = useState(() =&gt; { return 0; }); useState 更新状态 更新状态有两种用法：
import { useState } from "react"; import { Card, Button, Space } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a2a120d88af8fe9726a43cfbd95a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b98447ec4d36a8669471944fa9003c/" rel="bookmark">
			如何使用ArcGIS Pro转换单个点坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		坐标转换作为基础的功能，一般的GIS软件都支持，大多数情况下，我们是转换整个图层，如果想要转换单个坐标点，在ArcGIS Pro内也是支持的，这里为大家介绍一下转换方法，希望能对你有所帮助。
拾取坐标点 在菜单栏上选择地图，点击坐标转换，如下图所示。
点击坐标转换
默认的是地图点工具，可以在地图上点击需要转换坐标的位置，右侧会展示对应的坐标系数值，如下图所示。 单点坐标
点击多个点过后会在地图上标注出来所有转换过坐标的点并在右侧列出来转换记录，如下图所示。
坐标转换记录
输入坐标点 除了在地图上拾取点之外，还可以直接输入坐标点，输入后敲回车会在地图上标注出来对应的点，同时在转换记录内添加一条记录，如下图所示。
输入坐标点
修改坐标显示格式 如果想要修改坐标点的显示格式，可以在属性内修改，点击编辑属性按钮，如下图所示。 点击编辑属性
在显示的编辑属性对话框内，选择坐标格式为DMS，如下图所示。
修改坐标格式
点击确定后可以看到显示的坐标格式已经变成了度分秒格式，如下图所示。 修改后坐标显示
修改标注点样式 如果想要修改标注点的样式，也可以在编辑属性对话框内修改，如下图所示。 修改标注点样式
修改后的标注点如下图所示。
修改后标注点
结语 以上就是如何使用ArcGIS Pro转换单个点坐标的详细说明，主要包括了拾取坐标点、输入坐标点、修改坐标显示格式和修改标注点样式等功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552940015af1bd481796b1cbb63a791e/" rel="bookmark">
			一体化运维方案：摄像头故障监控与网络设备监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言
随着企业信息化的快速发展，摄像头和网络设备在各行各业得到了广泛应用。然而，随着设备数量的增加和系统复杂度的提升，摄像头故障监控和网络设备监控成为了一个重要的挑战。为了提高运维效率和管理水平，我们提出了一体化运维方案，整合摄像头故障监控和网络设备监控，实现统一管理。
二、方案介绍
方案目标 本方案旨在整合摄像头故障监控和网络设备监控，通过一个统一的平台进行集中管理和监控，提高管理效率，确保设备安全稳定运行，降低潜在风险。
方案构成 （1）摄像头故障监控
摄像头故障监控主要对已有的摄像头进行实时监控，及时发现和解决故障问题。通过安装智能摄像头和接入监控易平台，可以实时监测摄像头的视频质量、设备状态等信息。当出现异常情况时，系统将自动触发告警通知，及时通知管理人员进行处理。
（2）网络设备监控
网络设备监控主要对已有的网络设备进行实时监控，确保设备正常运行。通过安装网络监控设备和接入监控易平台，可以实时监测网络设备的端口状态、流量信息、故障信息等。当出现异常情况时，系统将自动触发告警通知，及时通知管理人员进行处理。
（3）一体化平台
一体化平台是本方案的核心部分，负责整合摄像头故障监控和网络设备监控的数据，进行集中管理和监控。平台可实现各项参数的实时展示、历史数据的查询与分析、异常事件的告警通知等功能。通过一体化平台，管理人员可以全面了解设备和网络运行状况，提高管理效率。
三、实施流程
需求分析：对已有的摄像头和网络设备进行详细调研，了解实际需求和现场情况。系统设计：根据需求分析结果，设计出符合实际需求的系统架构和功能模块。系统集成：将摄像头故障监控和网络设备监控的数据集成到一体化平台中，实现数据的统一管理和监控。系统测试：对整个系统进行测试，确保各项功能正常运行。上线运行：正式投入使用，并进行长期维护和优化。 四、优势分析
集中管理：通过一体化平台，管理人员可以集中管理设备和网络设备，提高管理效率。实时监控：实时监测设备和网络的运行状态，及时发现和解决问题。异常告警：当监测数据出现异常时，系统将自动触发告警通知，及时通知管理人员进行处理。数据存储与分析：系统可对监测数据进行存储和分析，为管理人员提供决策依据。扩展性强：可根据实际需求进行扩展和优化，满足不同企业的需求。提高安全性：通过对摄像头和网络设备的实时监控，可以及时发现潜在的安全风险并采取相应的措施进行防范和应对。提高可靠性：通过对设备和网络的实时监控，可以及时发现潜在的故障并采取相应的措施进行维修和维护，从而提高系统的可靠性和稳定性。提高效率：通过自动化监控可以减少人工干预的频率和提高故障处理的效率从而提高整个运维工作的效率。 本方案通过整合摄像头故障监控和网络设备监控，实现了统一管理，提高了管理效率。同时保障了设备的安全稳定运行和网络的安全性。在实施过程中需要注意设备选型、系统集成等方面的问题，以确保系统的稳定性和可靠性。同时需要加强对管理人员的培训和维护工作的开展，以确保系统的正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953a22071bd15cb3bebc18dcfc0440a3/" rel="bookmark">
			前端web页面性能的指标有哪些?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web 页面性能的评估通常依赖于多个指标，这些指标提供了有关页面加载速度、交互性和用户体验的信息。以下是一些常见的 Web 页面性能指标：
加载时间（Load Time）：
页面加载完成所需的总时间。这包括从开始加载到加载完成的整个时间。 首次渲染时间（First Paint）：
浏览器首次将像素渲染到屏幕的时间。即使只是一部分内容，用户仍然可以看到页面的渲染。 首次内容渲染时间（First Contentful Paint，FCP）：
浏览器首次将页面的实际内容（文本、图像等）渲染到屏幕的时间。这是用户可以看到实际内容的时间点。 首次有意义渲染时间（First Meaningful Paint，FMP）：
用户认为页面开始有意义渲染的时间。这通常是用户可以开始与页面进行交互的时间。 白屏时间（Time to First Byte，TTFB）：
从发起页面请求到浏览器收到来自服务器的第一个字节的时间。较低的 TTFB 通常意味着更快的加载时间。 页面完全加载时间（Page Load Time）：
页面上所有资源都加载完成并准备好交互所需的时间。 资源加载时间（Resource Load Time）：
单个资源（如图像、脚本、样式表）加载完成所需的时间。 可交互时间（Time to Interactive，TTI）：
页面加载完成后，用户可以开始与页面进行交互的时间。这包括 JavaScript 执行完毕、事件监听器绑定完成等。 DOMContentLoaded 时间：
当 HTML 文档被完全加载和解析完成时触发的事件。在这个事件触发之前，页面的 DOM 是完全可用的。 内容加载完成事件（Load Event）：
当整个页面和依赖资源（如样式表、图像）都加载完成时触发的事件。 这些指标可以通过使用浏览器的开发者工具或性能分析工具进行监测和测量。综合考虑这些指标可以帮助开发者了解其网站的性能状况，进而进行优化以提供更好的用户体验。Google 的 Lighthouse 工具是一个常用的工具，可以评估 Web 页面性能并提供改进建议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33111b7ad579ae35d37b671038b52bf/" rel="bookmark">
			2024华为OD机试真题目录汇总 B&#43;C&#43;D卷（470道）（Python语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀前言🚀其他华为OD机试题清单一、什么是华为OD，什么是华为OD机试？二、华为OD面试流程？三、华为OD机试通过率高吗？四、华为OD薪资待遇？🚀五、怎么刷题？通过华为OD机试？华为OD机试真题刷题列表🔰部分文章试读演示🔰部分思路及代码参考演示🔰刷题列表：华为OD机试真题（Python） B+C+D卷2024年B+C+D卷 新题库(100分)2024年B+C+D卷 新题库(200分) 作者：KJ.JK 🚀前言 本文是华为OD机试真题（Python 语言） 专栏的目录贴（持续更新中…）
🚀其他华为OD机试题清单 🔥2024华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
🔥2024华为OD机试真题(C语言) B+C+D卷🔥
🔥2024华为OD机试真题(Python语言) B+C+D卷🔥
🔥2024华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++语言)B+C+D卷🔥
🔥2024华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2024华为OD机试真题(Golang语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++ Java Python) 🔥
一、什么是华为OD，什么是华为OD机试？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是同薪同酬，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的，OD其实简单说就是外包，现在有很多公司都在给华为供给外包服务，比如中软，因为华为有很多业务部门，去年一个很熟的猎头给我推荐了几个技术岗位的华为OD都通过了
而华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式，
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环
二、华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
1、笔试：考察候选人的基础知识、算法设计和编程能力等多个方面，题目通常包括算法题、编程题、数据结构题等
2、性格测试(综合测试)：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等
3、技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决，围绕计算机/编程基础+项目经验+代码能力进行考察，如应届生无项目经验，重点复习八股文+刷算法题
4、HR面：围绕求职动机、稳定性、薪酬期望、Gap经历、延毕等异常情况进行考察
5、终面：终面是在参加完所有面试后进行的最后一轮面试，，主要考察候选人的综合素质和领导潜力；其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同，最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数
全流程线上进行，一般机考通过后2-3周内出offer，特殊情况时间过长的话需要积极联系接口人HR
三、华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试
四、华为OD薪资待遇？ 薪资结构：
1、基本工资+绩效工资+年终奖（2-4个月，一般绩效A-4个月，B-2个月）；
2、D1-D5分别对应华为13-17级，参考范围10-40K；
3、试用期内（6个月）工资不打折，按B绩效发绩效工资，转正时重新评绩效，一般分A、B、C三档（主要A或B，C概率较小），和正式员工分开评，半年评一次；
4、五险一金基数按基本工资，公积金比例5%-12%，具体看base地。
5、福利补贴：带薪年假、入职&amp;年度免费体检、免费夜宵、班车/加班打车免费、下午茶、节假日礼品等
13级薪资：9k-13k
14级薪资：13k-17k
15级薪资：17k-21k
16级薪资：21k-25k
17级薪资：25k-29k
🚀五、怎么刷题？通过华为OD机试？华为OD机试真题刷题列表 🔥2024华为OD机试真题(C C++ Java Py JS) B+C+D卷🔥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33111b7ad579ae35d37b671038b52bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd43062a22323375f6821dcf078ed6a5/" rel="bookmark">
			MySQL：表操作&amp;数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建表 create table 表名(
列名 列属性 comment `对列的描述`，
第二列 不能带逗号
)character set 字符集 collate 检验集 engine 存储引擎
右括号的这些可以省略，采用数据库的默认字符集和检验集表括号内的结构，像结构体的定义，只不过名字在左类型在右 不同的存储引擎在存储表的时候，生成的数据库文件个数不同
表修改 增加表的列
alter table 表名 add 列名 列属性 comment `解释` after 列名2
向列名2后插入新列
修改表中的列属性字段
alter table 表名 modify 列
删表的某列
alter table 表名 drop
修改表的列名
alter table 表名 change 旧列名 新列名 列属性 comment `解释`
修改表名
alter table 旧表名 rename 新表名
删除表 drop table 表名
数据类型 1整形 tinyint1字节smallint2int4bigint8 默认是有符号整数
create table t1（
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd43062a22323375f6821dcf078ed6a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a98fe6e51e8ef2054c371f93116b03b/" rel="bookmark">
			高速自动驾驶安全停靠功能规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全停靠功能规范
Safe Stop Functional Specification
目录
1 概述....................................................................................................................... 7
1.1 目的............................................................................................................... 7
1.2 范围............................................................................................................... 7
1.3 术语及缩写.................................................................................................. 7
1.4 设计与实验标准......................................................................................... 7
1.4.1 设计参考标准...................................................................................... 7
2 功能规范.............................................................................................................. 9
2.1 功能描述...................................................................................................... 9
2.1.1 功能用途............................................................................................... 9
2.1.2 基本性能参数...................................................................................... 9
2.1.3 运行设计区域ODD........................................................................... 9
2.1.4 通用性要求........................................................................................ 13
3 使用场景描述................................................................................................... 13
3.1 场景_01——HWC激活过程触发安全停靠...................................... 13
3.1.1 巡航行驶过程中触发安全停靠..................................................... 19
3.1.2 加速或匀速跟车过程触发安全停靠............................................ 23
3.1.3 减速跟车过程触发安全停靠......................................................... 27
3.1.4 隧道巡航行驶过程中触发安全停靠............................................ 31
3.1.5 隧道加速或匀速跟车行驶过程触发安全停靠.......................... 35
3.1.6 隧道内减速跟车行驶过程触发安全停靠................................... 39
3.2 场景_02——ALC向左变道过程触发安全停靠............................... 43
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a98fe6e51e8ef2054c371f93116b03b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74fcda2ce935810c70205319499b25d7/" rel="bookmark">
			面试问题整理若干
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.数据库测试时关注的要点 1.数据库连接测试：确保数据库可以正常连接，并且连接稳定。
2.数据库结构测试：验证数据库的结构设计是否符合需求，包括表、字段、索引等的设计。
3.数据库数据测试：验证数据库中的数据是否准确、完整，并且符合业务规则。
4.数据库性能测试：测试数据库的读写性能，包括查询速度、插入速度、更新速度等。
5.数据库安全测试：验证数据库的安全策略是否有效，包括用户权限管理、数据加密等。
6.数据库并发测试：模拟多个用户同时访问数据库的情况，测试数据库的并发处理能力。
7.数据库兼容性测试：验证数据库是否可以在不同的操作系统、硬件环境下正常运行。
8.数据库恢复性测试：验证数据库的备份和恢复机制是否有效，确保在发生故障时可以快速恢复数 据。
9.数据库压力测试：通过模拟大量数据访问和操作的场景，测试数据库的负载能力和稳定性。
10.数据库事务处理测试：验证数据库的事务处理机制是否正确，确保数据的完整性和一致性。
二.如何开展软件测试中的逆向测试 1.确定测试目标：明确要测试的系统或软件的功能和特性。
2.设计测试用例：根据测试目标和系统架构，设计逆向测试用例。
3.制定测试计划：制定测试计划，包括测试场景、测试用例、测试环境和测试数据。测试场景应该模拟攻击者可能采取的各种方法，例如尝试未经授权的访问、注入恶意代码、篡改数据等。
4.执行测试：根据测试计划执行测试，并记录测试结果和发现的漏洞。
5.分析和整理测试结果：对测试结果进行分析和整理，以确定哪些漏洞需要修复和如何修复它们。
提供测试报告：汇总测试结果并生成测试报告，包括发现的漏洞、建议的解决方案和测试过程中的所有细节。
三.常用的接口测试方法，接口测试质量评估标准是什么 功能测试：验证接口是否按照设计要求正常工作，是否能够正确地处理输入和输出数据。
性能测试：测试接口的响应时间、吞吐量、并发性等性能指标是否符合要求。
安全测试：测试接口是否具有足够的安全性，是否能够防止未经授权的访问和攻击。
可靠性测试：测试接口是否具有足够的可靠性，是否能够处理异常情况和错误输入。
可维护性测试：测试接口是否易于维护和修改，是否具有良好的文档和注释。
接口测试质量评估标准包括以下几个方面： 准确性：测试结果是否准确反映了接口的实际表现。
完整性：测试是否覆盖了接口的所有功能和场景。
一致性：测试结果是否与预期结果一致。
可重复性：测试是否可以在相同条件下重复进行，并得到相同的结果。
及时性：测试是否在规定的时间内完成。
易用性：测试工具或测试环境是否易于使用。
可靠性：测试结果是否稳定可靠，是否存在误报或漏报的情况。
可维护性：测试用例和测试环境是否易于维护和更新。
可扩展性：测试框架和测试用例是否易于扩展和适应新的需求变化。
性能测试中线程和进程测试有什么区别，LoadRunner和Jmeter分别使用什么进行加压 性能测试中线程和进程测试的主要区别如下： 独立性：进程是独立运行的，而线程是在进程内部运行的。一个线程只能属于一个进程，但一个进程可以拥有多个线程。
资源占用：线程作为调度和分配的基本单位，而进程作为拥有资源的基本单位。进程会分配独立的地址空间，不同进程之间不共享地址空间，即不共享内存。而同一进程下的不同线程共享该进程的地址空间。
稳定性：由于进程互相独立，所以一个进程的崩溃不会影响其他进程，这有助于保持主程序的稳定性。而线程之间需要协作同步，不同进程的线程间要利用消息的办法实现同步。
开销和处理方式：多进程调度开销较大，而多线程方式消耗的总资源比多进程方式少。线程方式可以尽量减少线程加锁与解锁的影响，从而极大地提高了性能。
LoadRunner和Jmeter在加压方面的应用： LoadRunner首先通过虚拟用户脚本生成器生成基于协议的虚拟用户脚本，然后根据性能测试场景设计的需求，通过压力控制器控制协调各个压力产生器以并发的方式执行虚拟用户脚本。
Jmeter通过下载引入 plugins-manager.jar 工具进行梯度加压
五.列表list33 = [1,2,3,4,5,6,7,8,9] 切片:list33[-1:2:-1] 输出结果: [9, 8, 7, 6, 5, 4]
六．linux系统中buffer和cache均是做什么的,内存占用有大量的buffer和cache是异常情况吗 Buffer：是原始磁盘块的临时存储，即将缓存数据写入磁盘。它通常不会很大（大约 20MB）。这样，内核就可以将分散的写入集中起来，从而对磁盘写入进行统一优化。例如，多个小的写入可以合并为一个大的写入等。
Cache：是用于从磁盘读取文件的页面缓存，用于缓存从文件中读取的数据。这样，下次访问这些文件数据时，可以直接从内存中快速取回，而无需再次访问缓慢的磁盘。
内存占用有大量的Buffer和Cache不一定是异常情况。缓存占用的大小会根据系统的负载和可用内存而变化。当系统有足够的可用内存时，内核会增加缓存的大小以提高性能。当内存紧张时，内核会回收部分缓存以释放内存供其他进程使用。
七.APP冷启动和热启动的命令 冷启动命令：adb shell am start -W packageName/ActivityName。这个命令会启动指定的应用程序，并返回启动时间等相关信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74fcda2ce935810c70205319499b25d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9882673726a1b38c22215ae3c80333ca/" rel="bookmark">
			通俗易懂的双线性插值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双线性插值这个算法和公式，着实有点晦涩难懂，花了我很长时间。现在用图文并茂的方法，把我的理解记录一下。
一、先看一下线性插值法 学双线性插值法之前，先把线性插值法学懂，这个很重要，因为后面需要直接套公式。
上个图（网上盗的……）：
假设我们已知坐标(x0,y0)与(x1,y1),要得到[x0,x1]区间内某一位置x在直线上的值。根据上图中所示，我们从两点式直线方程:
将这方程化解一下可得：
这个是有公式的，直接套就行：‘两点式方程公式’：已知直线1上的两点P1(x1, y1)、P2(x2, y2), (x1≠x2)，那么可得：(y-y1)/(y2-y1)=(x-x1)/(x2-x1)。
二、再来看双线性插值法 知道了线性插值法学了之后，再来看双线性插值法。
要是不乐意看公式的，可以直接跳到图片演示，示例能看懂也行。
下面是关于双线性插值的经典说明图例：
首先，图中有5个像素点：Q00, Q01, Q10, Q11, P。
其中四个红色点Q是原图的点，绿色点P则是目标图片上像素点在原图上的投影。
四个红色点Q就是投影点P的四周最近的点，通过这四个红色点Q，可以计算出投影点P的像素值，这样目标图片上的像素点点值就求出来了。
三、目标图的点如何投影到原图上？ 已知：
1. 原图的高、宽、通道数为：height_src, width_src, channel_src。
2. 目标图的高、宽、通道数为：height_dst, width_dst, channel_src。因为通道要相同嘛
可以计算出投影公式为：h = h_dst * height_src / height_dst, w = w_dst * width_src / width_dst。
举个例子：原图大小是33， 目标图大小是99， 目标图的中心点坐标是(4,4)。按照上面的投影公式，计算目标图的中心点投影到原图中心点的坐标为：h = 4 * 3 / 9 = 1.3333, w = 4 * 3 / 9 = 1.3333，中心点坐标为(1.3333, 1.3333)。
这里就发现一个问题了，原图的大小为3*3，中心点坐标应该是(1,1)啊，公式计算出来的明显不一样。
之所以会出现这个情况，原因是每个像素点实际上是一个边长为1的正方形，所以对于坐标为(h,w)的像素点，它的中心其实是(h+0.5,w+0.5)。
所以精确的算法应该是： 和 ，转换一下得到正确的投影公式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9882673726a1b38c22215ae3c80333ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8473a95be774e17a4efb674bc3fcbab/" rel="bookmark">
			【力扣100】131.分割回文字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加链接描述
class Solution: def partition(self, s: str) -&gt; List[List[str]]: # 思路是回溯 n=len(s) res=[] path=[] def backtrack(i): if i == n: res.append(path[:]) return for j in range(i,n): t=s[i:j+1] if t==t[::-1]: path.append(t) backtrack(j+1) path.pop() backtrack(0) return res 思路是：
递归加回溯 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98be65956abd1d904dcd633badf72281/" rel="bookmark">
			RabbitMQ（八）消息的序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、为什么需要消息序列化？二、常用的消息序列化方式1）Java原生序列化（默认）2）JSON格式3）Protobuf 格式4）Avro 格式5）MessagePack 格式 三、总结 RabbitMQ 是一个强大的消息中间件，广泛应用于 分布式系统 中。在使用 RabbitMQ 时，选择 合适的方式来序列化 消息可以提高：性能、可靠性、扩展性。
一、为什么需要消息序列化？ 在使用 RabbitMQ 时，消息需要在生产者和消费者之间进行传递。由于网络通信只能传输二进制数据，因此需要对消息进行 序列化（将对象转换为二进制数据）和反序列化（将二进制数据转换回对象）。这样才能实现生产者与消费者之间的无缝通信。
消息序列化的目标是：将对象转换为字节流。以便于在网络上进行传输。在选择序列化方式时，我们 需要考虑以下因素：
性能： 序列化和反序列化的效率直接 影响消息传输的速度和延迟。空间开销： 序列化后的字节流大小会 影响网络带宽的利用 和 存储空间的占用。可读性： 序列化后的字节流是否 易于解析和理解，方便调试和维护。兼容性： 序列化方式是否 支持不同的编程语言 和 版本之间的交互。 二、常用的消息序列化方式 RabbitMQ 本身不直接处理消息内容的序列化，它主要负责消息的路由、存储和传递。当发送或接收消息时，客户端库（如：Java 中的 RabbitTemplate 或 Spring AMQP 框架）会根据内部配置或默认设置来决定如何对消息体进行序列和反序列化。
1）Java原生序列化（默认） Java 自带的 Serializable 接口和 ObjectOutputStream/ObjectInputStream 可以将对象转换为字节数组进行传输。在 Java Spring AMQP 中，默认的消息序列化方式就是 Java 原生序列化。 优点：
简单易用： Java 内置支持，只需让需要序列化的类实现 Serializable 接口即可。 缺点：
效率低： 生成的数据流可能比 JSON、Protocol Buffers 等二进制格式更大，导致存储和传输效率低。安全风险： 由于序列化机制中包含了类的信息，存在安全风险，如：恶意攻击者可以构造特殊序列化数据以执行任意代码（例如通过 readObject 方法的重写）。语言独立性差： Java 原生序列化只适用于 Java 环境，不便于与其他编程语言间的通信。 为了克服这些限制并提供更好的性能和互操作性，开发者通常会选择更现代和灵活的方式，如 JSON 或 Protobuf 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98be65956abd1d904dcd633badf72281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe182e34b7b71483c3302453fefad472/" rel="bookmark">
			Linux配置Acado
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果需要使用acado的matlab接口，请移步：Linux Matlab配置Acado
首先，安装必要的软件包：
sudo apt-get install gcc g++ cmake git gnuplot doxygen graphviz 在自定义目录下，下载源码
git clone https://github.com/acado/acado.git -b stable ACADOtoolkit 在ACADOtoolkit目录下建立build文件夹，用于存放编译文件：
cd ACADOtoolkit mkdir build cd build 进行编译（大概需要七分钟）：
cmake .. make 执行一个例程以检查配置是否成功：
cd .. cd examples/getting_started ./simple_ocp 运行结果如下：
如果你想在debug模式下编译acado，可以运行如下命令：
cmake -DCMAKE_BUILD_TYPE=Debug .. 参考：Linux installation
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9c51639afd3b7a5f3c24be39fbb86b/" rel="bookmark">
			leetcode2967. 使数组成为等数数组的最小代价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目思路复杂度Code 题目 给你一个长度为 n 下标从 0 开始的整数数组 nums 。
你可以对 nums 执行特殊操作 任意次 （也可以 0 次）。每一次特殊操作中，你需要 按顺序 执行以下步骤：
从范围 [0, n - 1] 里选择一个下标 i 和一个 正 整数 x 。 将 |nums[i] - x| 添加到总代价里。 将
nums[i] 变为 x 。 如果一个正整数正着读和反着读都相同，那么我们称这个数是 回文数 。比方说，121 ，2552 和 65756
都是回文数，但是 24 ，46 ，235 都不是回文数。
如果一个数组中的所有元素都等于一个整数 y ，且 y 是一个小于 109 的 回文数 ，那么我们称这个数组是一个 等数数组 。
请你返回一个整数，表示执行任意次特殊操作后使 nums 成为 等数数组 的 最小 总代价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9c51639afd3b7a5f3c24be39fbb86b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb3f095c1ee2b51af449af2c7cb8d32/" rel="bookmark">
			MybatisPlus—IService接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. IService接口介绍
2. IService接口的使用
3. 实例
4. 总结
1. IService接口介绍 MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。
MybatisPlus提供的通用接口为IService，默认实现为ServiceImpl。
其中封装的方法由前缀命名方式区分，可以分为以下几类：
save： 新增
remove： 删除
update： 更新
get： 查询单个结果
list： 查询集合结果
count： 计数
page： 分页查询
具体见：MyBatis-Plus/CRUD接口
2. IService接口的使用 由于Service中经常需要定义与业务有关的自定义方法，因此我们不能直接使用IService，而是自定义Service接口，然后继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl，这样就不用自己实现IService中的接口了。
首先，定义IUserService，继承IService：
public interface UserService extends IService&lt;User&gt; { // 拓展自定义方法 } 然后，编写UserServiceImpl类，继承ServiceImpl，实现UserService：
@Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { } 3. 实例 @SpringBootTest class UserServiceTest { @Autowired UserService userService; //添加单条数据 @Test void test1() { //1. 初始化数据 User user = new User(); user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb3f095c1ee2b51af449af2c7cb8d32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1424d995e7f630fafc3e04c96d917b0/" rel="bookmark">
			BMS开发之面向对象思想（adbms1818）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借鉴adbms1818的底层驱动代码
前言：adbms1818的主要用途就是不同种类的寄存器里面存储不同的数据，程序员需要通过特定的协议往寄存器里面写入或者读出数据
（1）定义一个结构体 里面存储了adbms1818的所有寄存器的信息。然后我们看定义，首先就是配置寄存器config，其次是配置寄存器configB，然后就是电压寄存器cells,辅助寄存器aux，状态寄存器stat，COMM寄存器组com......，但是我们不知道最前面的数据类型，他并不是我们熟知的int , char,short等等。
/*! Cell variable structure */ typedef struct { ic_register config; ic_register configb; cv cells; ax aux; st stat; ic_register com; ic_register pwm; ic_register pwmb; ic_register sctrl; ic_register sctrlb; uint8_t sid[6]; BOOL isospi_reverse; pec_counter crc_count; register_cfg ic_reg; long system_open_wire; }cell_asic; （2）跳转到ic_register定义 已知信息是配置寄存器组A占48个位，6个字节，其次协议规定的发送数据格式是 CMD0 CMD1 PEC0 PEC1 6个字节数据 PEC0 PEC1，此处我们只需要考虑红色字体，PEC0,PEC1类似于CRC校验码。
再次返回来看结构体，首先tx_data[6]里面存储的就是寄存器里面所有位的数据，rx_data[8]收到的数据（包括PEC0 PEC1),rx_pec_match是标志位，判断接收到的PEC和根据6位数据计算出来的PEC是否相同，相同数据接收正确，不同数据接收错误。
typedef struct { uint8_t tx_data[6]; //!&lt; Stores data to be transmitted uint8_t rx_data[8]; //!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1424d995e7f630fafc3e04c96d917b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cecb6b58d448d789b6b514e0000b2f/" rel="bookmark">
			JS新手入门笔记整理：JS语法基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量与常量 变量 语法
var 变量名=值； 1、在JavaScript中，给一个变量命名，需要遵循以下2个方面的原则：
变量由字母、下划线、$或数字组成，并且第一个字母必须是字母、下划线或$。变量不能是系统关键字和保留字。 2、变量的命名一定要区分大小写，如变量“age”与变量“Age”在JavaScript中是两个不同的变量。
3、在JavaScript中，如果想要使用一个变量，一般需要两步：
第1步，变量的声明。第2步，变量的赋值。 4、所有JavaScript变量都由var声明，一个var也可以同时声明多个变量名，其中，变量名之间必须用英文逗号（,）隔开。
var a=10,b=20,c=30; 5、变量的值在程序运行过程中是可以改变的。
常量 1、在JavaScript中，常量指的是一个不能改变的量。也就是说，常量的值从定义开始就是固定的，一直到程序结束都不会改变。
2、一般情况下，常量名全部采用大写形式，这样一看就知道这个值很特殊，有特殊用途，如var DEBUG = 1。
数据类型 数据类型，指的是变量的“值”的类型。在JavaScript中，数据类型可以分为两种：一种是“基本数据类型”，另外一种是“引用数据类型”。其中，基本数据类型只有一个值，而引用数据类型可以含有多个值。
在JavaScript中，基本数据类型有5种：数字、字符串、布尔值、未定义值和空值。常见的引用数据类型只有一种：对象（数组也是属于对象的一种）。
数字
数字是最基本的数据类型，指的是数学上的数字，如10、-10、3.14等。JavaScript中的数字是不区分“整型（int）”和“浮点型（float）”的。 字符串
字符串就是一串字符。在JavaScript中，字符串都是用英文单引号或英文双引号（注意都是英文）括起来的。在用单引号括起来的字符串中，不能含有单引号，只能含有双引号。同样的道理，在用双引号括起来的字符串中，也不能含有双引号，只能含有单引号。如果给数字加上双引号，JavaScript会把这个数字当作“字符串”来处理，而不是当作“数字”来处理。 布尔值
布尔类型的值只有两个：true和false。true表示“真”,false表示“假”。布尔值最大的用途：选择结构的条件判断。 未定义值
未定义值指的是一个变量虽然已经用var声明了，但是并没有对这个变量进行赋值，此时该变量的值就是“未定义值”。其中，未定义值用undefined表示。 空值
数字、字符串等数据在定义的时候，系统都会分配一定的内存空间。在JavaScript中，空值用null表示。如果一个变量的值等于null，如“var n = null”，则表示系统没有给这个变量n分配内存空间。
运算符 运算符指的是“变量”或“值”进行运算操作的符号。
算术运算符 运算符
说明
举例
+
加
10+5 //返回15
-
减
10-5 //返回5
*
乘
10*5 //返回50
/
除
10/5 //返回2
%
求余
10%4 //返回2
++
自增
var i=10;i++; //返回11
--
自减
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88cecb6b58d448d789b6b514e0000b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cdb4ee7576771c46cc6b37b20b3be38/" rel="bookmark">
			三种解密 HTTPS 流量的方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web 安全是一项系统工程，任何细微疏忽都可能导致整个安全堡垒土崩瓦解。拿 HTTPS 来说，它的「内容加密、数据完整性、身份认证」三大安全保证，也会受到非法根证书、服务端配置错误、SSL 库漏洞、私钥被盗等等风险的影响。很多同学认为只要访问的网站地址前有一把小绿锁就绝对安全，其实不然。本文通过介绍三种最常规的 HTTPS 流量解密方法及原理，浅谈一下 HTTPS 的安全风险。
Man-in-the-middle Man-in-the-middle（中间人，简称为 MITM），能够与网络通讯两端分别创建连接，交换其收到的数据，使得通讯两端都认为自己直接与对方对话，事实上整个会话都被中间人所控制。简而言之，在真正的服务端看来，中间人是客户端；而真正的客户端会认为中间人是服务端。
实现中间人攻击有各种各样的手段，这里不展开讨论。一些常见的 HTTP/HTTPS 抓包调试工具，都是通过创建本地 Proxy 服务，再修改浏览器 Proxy 设置来达到拦截流量的目的，他们的工作原理与中间人攻击一致。我用过的这一类工具有：Fiddler、Charles 和 whistle。我在「HTTP 代理原理及实现（一）」一文中介绍的 HTTP 普通代理，扮演的就是 HTTP 中间人角色。
本文主要讨论 HTTPS 中间人，简单示意如下：
Server &lt;---&gt; Local Proxy &lt;---&gt; Browser ^ ^ HTTPS(1) HTTPS(2) 上述 HTTPS(1) 连接，是中间人冒充客户端，与服务端建立的连接，由于 HTTPS 服务端一般不认证客户端身份，这一步通常没有问题。而对于 HTTPS(2) 连接来说，中间人想要冒充服务端，必须拥有对应域名的证书私钥，而攻击者要拿到私钥，只能通过这些手段：1）去网站服务器上拿；2）从 CA 处签发证书；3）自己签发证书。
要防范前两点，需要网站做好各个方面的安全防护，从主机安全到网站安全（避免私钥被盗），从域名解析安全到域名邮箱安全（避免攻击者重签证书）。而攻击者自己签发的证书，无法通过系统内置根证书的验证，默认无法用于中间人攻击。
对于 Fiddler 这一类调试工具来说，能够解密 HTTPS 流量的关键在于他们会往系统受信任的根证书列表导入自己的证书，这样他们的自签证书就能被浏览器信任。进入 Fiddler 设置中的「HTTPS」Tab，勾选相关功能后，就可以顺利解密和修改 HTTPS 流量。这时在浏览器中可以看到这样的证书链：
RSA Private Key 我在「使用 Wireshark 调试 HTTP/2 流量」这篇文章中写到：Wireshark 的抓包原理是直接读取并分析网卡数据，要想让它解密 HTTPS 流量，有两个办法：1）如果你拥有 HTTPS 网站的加密私钥，可以用来解密这个网站的加密流量；2）某些浏览器支持将 TLS 会话中使用的对称密钥保存在外部文件中，可供 Wireshark 加密使用。那篇文章介绍了第二种方案，本文简单介绍第一种。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cdb4ee7576771c46cc6b37b20b3be38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1bc39aee3aa2e408c3b40b6fb600297/" rel="bookmark">
			置顶＞ 个人学习记录一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人学习记录一览表 写个说明
知识学的好，不如笔记记得好，知识点的遗忘在所难免，这里记录我个人的学习过程，以备后面二次学习使用。
Linux 操作系统 Linux 操作系统 001-介绍
Linux 操作系统 002-VMware Workstation的相关操作
Linux 操作系统 003-系统目录介绍
Linux 操作系统 004-远程连接
Linux 操作系统 005-使用vi进行文本编辑
Linux 操作系统 006-操作系统的启动与关闭
Linux 操作系统 007-用户管理
Linux 操作系统 008-文件目录操作指令
Linux 操作系统 009-时间和日期
Linux 操作系统 010-压缩与下载
Linux 操作系统 011-定时任务
Linux 操作系统 012-磁盘分区机制
Linux 操作系统 013-NAT网络原理
Linux 操作系统 014-服务管理
Linux 操作系统 015-进程操作
Linux 操作系统 016-动态监控系统
Linux 操作系统 017-CentOS7 Minimal安装
Linux 操作系统 018-远程文件传输工具
Linux C语言 Linux C语言 01-简介
Linux C语言 02-基础知识（编译环境）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1bc39aee3aa2e408c3b40b6fb600297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca92fa7204e11c3978d2d23d112211c8/" rel="bookmark">
			uniapp 分享例子做个记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt;
&lt;view class="content"&gt;
&lt;view class="invite-wrapper" v-if="inviteUrl"&gt;
&lt;uni-qrcode class="invite-qrcode" ref="qrcode" cid="invite-qr-canvas" :text="inviteUrl" :margin="10" makeOnLoad
@makeComplete="qrcodeComplete" /&gt;
&lt;view class="share-btn"&gt;
&lt;button type="primary" @click="shareLink"&gt;分享链接&lt;/button&gt;
&lt;button type="primary" @click="shareImage"&gt;分享图片&lt;/button&gt;
&lt;/view&gt;
&lt;view class="share-btn"&gt;
&lt;button type="primary" @click="toInvitedUser"&gt;我邀请的用户&lt;/button&gt;
&lt;/view&gt;
&lt;uni-popup id="popupShare" ref="popupShare" type="share"&gt;
&lt;uni-popup-share title="分享到" :shareType="shareType" @select="select"&gt;&lt;/uni-popup-share&gt;
&lt;/uni-popup&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
import {
mapState
} from 'vuex'
export default {
data() {
return {
inviteUrl: '',
qrcodeImagePath: '',
qrcodePath: '',
shareType: ''
}
},
onLoad() {
uni.showLoading({
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca92fa7204e11c3978d2d23d112211c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342aab35a34df07369794ee228b75a9c/" rel="bookmark">
			电动车低速提示音系统(AVAS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电动汽车的迅速发展，以及电动汽车的保有量也越来越多，根据车辆的特征来说电动汽车相比于传统的内燃机汽车要安静，为了保护行人，减少事故的发生，欧盟最近发布了一项关于电动车的新法规。自2019年7月1日开始，欧盟关于电动汽车的最新法律正式生效：所有新的低排放和电动汽车在驾驶过程中必须要产生一定程度的噪音。欧盟表示这些汽车、货车如果处于安静状态可能会危及骑行者和行人，因为他们无法听到后方即将驶来的车辆。
为了满足欧盟制定的新要求，所有带有四个车轮的新型电动车都需要有一个发出适当声音的声学车辆警报系统（AVAS）。新规要求汽车的AVAS系统在车速低于19km/h的时候前进或者后退的时候必须要发出噪声。这是因为欧盟认为当车辆倒车或者低速行驶的时候，行人最容易受到伤害。英国广播公司进一步报道，所有现有的电动汽车都必须在2021年之前安装AVAS，已经上路的电动汽车则需要改装。
电动车低速提示音系统(AVAS)-有驾
另外，随着新修订的国家标准《机动车运行安全技术条件》把加装电动车低速提示音列为要求，国内会有越来越多的新上市电动车、插电车加入这个阵营。
电动车低速提示音系统(AVAS)-有驾
根据上表，我们可以看出自主品牌的新能源车型，几乎都安装了低速提示音。比如，上汽和吉利在纯电和插电车型上全都配备了该装置。由此看出，国内对于此事非常重视。
电动车低速提示音系统(AVAS)-有驾
汉得利（常州）电子股份有限公司作为电动汽车低速提示音（AVAS）国标研发主起单位，历时5年，自主研发，掌握核心技术，还参与制定右转向提示音及倒车报警器两项国家标准。
该产品将自动发出模拟汽车发动机引擎的提示音声响，适用于M1、N1类的纯电动汽车，具有纯电动行驶模式的混合动力车辆以及燃料电池电动汽车，该装置符合汽车的环境使用要求，结构灵活，便于整车安装，因为是外置设备，所以对于这款低速提示音装置，汉得利在防尘防水方面做了很多工作，客户不必为产品外置而担心产品的性能。
关于汉得利
汉得利（常州）电子股份高限公司成立于2002 年，隶属于常州波速投资合伙企业是一家集研发、生产、销售为一体的高新技术企业。公司自创立以来，始终专注于电子元器件、发声器件、超声器件和压电陶瓷晶体等微电声领域的研发和制造，主要产品包括传感器、扬声器、蜂鸣器、微型麦克风、受话器、陶瓷元器件等，广泛应用在移动通讯设备、汽车相医疗器械等领域。
汉得利参与发布《电动汽车低速行驶提示音技术要求》征求意见稿，于2017年7月28日由专家组审核通过，将于2018年8月发布该标准。
关于电动车低速提示音系统(AVAS)
01电动汽车低速提示音装置：防止电动汽车在纯电动模式下以低速行驶时，由于噪声低使得道路行人不容易察觉到车辆的接近，发生交通事故。
02车辆右转弯提示音装置：防止货车在右转弯时，由于转弯影响区域较大以及驾驶员在一定程度上存在视觉盲区，导致的行人、非机动车等道路使用者被撞的交通事故。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88bb3f7ccb8aa4b60d848818e1907c26/" rel="bookmark">
			北京大学漏洞报送证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取来源：edusrc（教育漏洞报告平台）
url：教育漏洞报告平台(EDUSRC) 兑换价格：30金币
获取条件：北京大学任意中危或以上级别漏洞
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69be63f642e1baefd0c256b16f5ea616/" rel="bookmark">
			Django集成第三方标签功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django-taggit模块是一个可重用的应用程序，它主要提供一个标签模型和一个管理器，可以轻松地向任意模型添加标签。
https://github.com/alex/django-taggit
目录
安装django-taggit
添加taggit到setting.py中的INSTALLED_APPS
编辑models.py，将标签应用到post模型
更新数据库
重构blog应用程序的views.py文件
添加标签路径到urls.py
更新list.html模版，为标签增加链接
安装django-taggit python -m pip install django-taggit 添加taggit到setting.py中的INSTALLED_APPS INSTALL_APPS = [ #... 'taggit', ] 编辑models.py，将标签应用到post模型 from taggit.managers import TaggableManager class Post(models.Mocel): #... tags = TaggableManager() 标记管理器将允许您从Post对象中添加、检索和删除标记。
更新数据库 python manage.py makemigrations blog python manage.py migrate 重构blog应用程序的views.py文件 导入标签模型表单django-taggit，并将post_list视图更改为根据标签筛选帖子。视图最终是这样的。
def post_list(request,tag_slug=None): object_list = Post.published.all() tag = None if tag_slug: tag = get_object_or_404(Tag, slug=tag_slug) object_list = object_list.filter(tags__in=[tag]) paginator = Paginator(object_list,3) page = request.GET.get('page') try: posts = paginator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69be63f642e1baefd0c256b16f5ea616/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/8/">«</a>
	<span class="pagination__item pagination__item--current">9/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/10/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>