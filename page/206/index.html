<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd34b3ad9f7d64f415f5fea6dda2b0e/" rel="bookmark">
			USART 、SPI、IIC、常用的通信方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.我们首先呢，我们谈谈要通信几大要点 1.1串行和并行 串行通信就是设备之间通过少量的线，进行一位一位的数据传输
并行通信就是使用多根数据线同时进行数据传输
1.2 全双工、半双工、单工 全双工：在同一时刻，两个设备之间可以同时收发数据 半双工:两个设备之间可以收发数据，但不能在同一时刻进行 单工：在任何时候都只能进行同一个方向的通信，即一个固定位发送设备，另一固定位接收设备
1.3同步和异步 同步：以时钟线来传输数据的，就是说，发送和接收的时序相同（iic、SPI）
异步：没有时钟线，以数据帧格式来传输数据的(RS485、串口)
1.4 传输速度 这个我认为比较重要的，首先，我们我们提到传输速度，就会想到比特率（Bit/s）和波特率，比特率是从单位看就可以知道是指每秒传输二进制的位数，而波特率是指每秒传输的码元；这里的码元我们给具体化，大家都知道串口，他的数据以帧格式传输的，即一个起始位+8位数据位+1位奇偶位+1位结束位，那么这里时候，这11位加在一起就是一个码元，就是说多位算一个单位。
2 串口通讯 在我看来，通讯都分为物理接口和软件时序（物理层和协议层），掌握这两，就可以基本掌握一种通讯方式，物理层主要还是电压特性，数据位高低的电压；协议层主要就是数据传输的规则
2.1 物理层 串口通信的物理层有很多标准，我们一般有两种电平标准，TTL标准和RS485标准
这里呢，我画个简易图吧，来表示电平的转换，其中设备时STM32,设备B是内一个STM32
USB转串口
当然，这里也可以用CH340
电平标准
2.2 协议层 2.2.1串口的数据传输的帧格式 1位起始位+6/7/8位数据位+1位奇偶位+1位结束位（可以不要校验位）
也就是说数据就按照这种格式发送出去的，这样比直接发送数据位更加的准确和安全
但是在两个设备进行串口通信的时候，要注意的就是他们的波特率要相同，因为他是异步的没有时钟，所以两个设备发送接收之前必须约定好波特率
3 USART 3.1 USART的简单介绍 （1）串口是串行异步全双工的以这种通信方式
（2）串口的数据传输是通过两根数据线传输，即RX、TX，发送和接收
（3）USART 支持使用 DMA （4）我们在用USART最多的还是printf的作用，即用来上位机的调试
3.2 USART的功能框图 3.3.2 ①功能引脚 我们能看到的就是外部引脚
TX：发送数据输出引脚。
RX：接收数据输入引脚。 STM32F103VET6 系统控制器有三个 USART 和两个 UART，其中 USART1 和时钟来源于 APB2 总线时钟，其最大频率为 72MHz，其他四个的时钟来源于 APB1 总线时钟，其最大频率为 36MHz。 3.3.3 ②数据寄存器 （1）数据字长
USART数据寄存器USART_DR只有低9位有效，其他位数保留，并且第 9 位数据是否有效要取决于USART 控制寄存器 1(USART_CR1)的 M 位设置，当 M 位为 0 时表示 8 位数据字长，当 M位为 1 表示 9 位数据字长，我们一般使用 8 位数据字长。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd34b3ad9f7d64f415f5fea6dda2b0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c26de1a38814609d2a6aa292425bb2/" rel="bookmark">
			EMNLP’19-Mask-Predict: Parallel Decoding of Conditional Masked Language Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mask-Predict: Parallel Decoding ofConditional Masked Language Models IntorductionConditional Masked Language ModelsArchitectureTraining ObjectivePredicting Target Sequence Length Decoding with Mask-PredictFormal Description Intorduction 大多数机器翻译系统使用顺序译玛的策略，其中单词是一个一个预测的。本文展示了一个并行译码的模型，该模型在恒定译码迭代次数下得到翻译结果。本文提出的条件掩码语言模型（CMLMS）
解码器的输入是一个完全被masked的句子，并行的预测所有的单词，并在恒定数量的屏蔽-预测循环之后结束。这种整体策略使模型可以在丰富的双向上下文中反复重新考虑单词的选择，并且正如我们将要展示的那样，它仅在几个周期内就可以产生高质量的翻译。 M a s k − p r e d i c t Mask-predict Mask−predict反复掩盖并重新预测模型对当前转换最不满意的单词子集。
Conditional Masked Language Models Y Y Y：目标语句 X X X：源语句 Y o b s ， Y m a s k Y_{obs}，Y_{mask} Yobs​，Ymask​：将目标语句划分为两类。 C M L M CMLM CMLM根据 X 与 Y o b s X与Y_{obs} X与Yobs​预测 Y m a s k Y_{mask} Ymask​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c26de1a38814609d2a6aa292425bb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679632cc60223ef509a216dc036e8d85/" rel="bookmark">
			VS无法进行调试问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （遇到神坑，记录一下担心忘记） 如果你的VS配置没有乱动过，突然发现无法打中断点。 1.首先 确保你的模式的DEBUG 2.确保你编译过你的项目 3.在项目属性里，配置属性-〉生成-〉输出-〉生成调试信息 ，把它改为true。 以上都解决不了的话，这边建议您重启电脑或者VS关闭一些杀毒软件，解决，祝好运。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d13e52ce6344eddabe3b745b7e8d05/" rel="bookmark">
			什么是Microsoft编辑器，以及如何使用它？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Editor is an AI-powered intelligent writing assistant available for Word, Outlook, and as a browser extension. Microsoft Editor, available in over 20 languages, aims to make you a better writer. Here’s a brief look at how to use it.
Microsoft编辑器是一款基于AI的智能写作助手，可用于Word，Outlook和浏览器扩展。 Microsoft编辑器提供20多种语言，旨在使您成为更好的作家。 这里是如何使用它的简要介绍。
Microsoft provides a basic version of Editor for free—so long as you have a Microsoft account. This version includes the essentials that you’d expect in a writing assistant, such as a grammar and spell checker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d13e52ce6344eddabe3b745b7e8d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26965edc40a3f9b8c5886632e25d8f4/" rel="bookmark">
			Halcon阈值算子 -- 局部阈值之dyn_threshold
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Halcon阈值算子 – 局部阈值之dyn_threshold 相对于全局阈值，还有一类局部阈值算子。包含dyn_threshold，local_threshold，和var_threshold。本文先介绍dyn_threshold。
理论介绍 dyn_threshold算子的函数签名如下：
dyn_threshold(OrigImage, ThresholdImage : RegionDynThresh : Offset, LightDark : )
输入参数有：
OrigImage：待处理图像ThresholdImage：用作阈值的图像Offset：施加在阈值处理上的固定offsetLightDark ：枚举值 ‘dark’, ‘equal’, ‘light’, ‘not_equal’ 输出参数有：
RegionDynThresh ：阈值处理后的区域 如果令g_{o} = g_{OrigImage}, 和g_{t} = g_{ThresholdImage}.分别代表 OrigImage 和 ThresholdImage 在图像某点的灰度值。则根据如下关系生成 RegionDynThresh
LightDark = ‘light’
g_{o} &gt;= g_{t} + OffsetLightDark = ‘dark’
g_{o} &lt;= g_{t} - OffsetLightDark = ‘equal’
g_{t} - Offset &lt;= g_{o} &lt;= g_{t} + OffsetLightDark = ‘not_equal’
与‘equal’正好相反 dyn_threshold可以用来提取物体轮廓。ThresholdImage 通常是通过OrigImage平滑而来，平滑程度会影响能提取多大的物体轮廓。
offset实际上定义了在阈值操作时，OrigImage与ThresholdImage灰度值偏差的可接受范围。通常取值5~40
dyn_threshold 是一种动态局部阈值算子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f26965edc40a3f9b8c5886632e25d8f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91272b3a5b291a5823c9a680bed2639/" rel="bookmark">
			小论文正文内容双栏，将脚注只分布在左侧栏设置方法：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小论文正文内容双栏，将脚注只分布在左侧栏设置方法：
1、将文件另存为word97-2003.
2、设置兼容性，选择按Word6.x/95/97的方式安排脚注(选项-高级-兼容性-...)
3、引入-脚注（右下角那个-设置自定义标记为空格）
这样就好啦，脚注只停留在左侧栏啦。
注意：必须更改word的版本。
不改版本，插入脚注设置“文字下方”或“1栏”等都无法达到想要的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf79fd12a205a7cdf1a11214595eb83/" rel="bookmark">
			Policy gradient(策略梯度详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 策略梯度基本知识什么是策略梯度？强化学习案例 策略梯度公式详解如何使你的损失函数更好增加一个基准为每一个action分配不同的权重 策略梯度基本知识 什么是策略梯度？ 直接根据状态输出动作或者动作的概率。那么怎么输出呢，最简单的就是使用神经网络啦！我们使用神经网络输入当前的状态，网络就可以输出我们在这个状态下采取每个动作的概率，那么网络应该如何训练来实现最终的收敛呢？我们之前在训练神经网络时，使用最多的方法就是反向传播算法，我们需要一个误差函数，通过梯度下降来使我们的损失最小。但对于强化学习来说，我们不知道动作的正确与否，只能通过奖励值来判断这个动作的相对好坏。基于上面的想法，我们有个非常简单的想法：如果一个动作得到的reward多，那么我们就使其出现的概率增加，如果一个动作得到的reward少，我们就使其出现的概率减小。
强化学习案例 在强化学习中，环境与rewardnfunction你是不能控制的，玩video game时，环境就是你的游戏机，然后reword function就是得分规则，你所能改的只有actor。下围棋也类似。
神经网络的输入是机器观察到的场景转化的向量或者矩阵，输出是每一个行为的概率。像这种彩图我们一般用CNN，然后取代了最早的查表方式，以前的actor是table，然后遇到某张图片就去table里找对应的行为，用在下棋里还可能穷举，如果在自动驾驶领域，这图片是无法用表存完的。可能你之前没有给神经网络看过某张图，但是它还是能得出比较靠谱的结果，所以他具有generalization的特性。
机器先观察画面，然后做出了一个action，向右移动，这个action的奖励是0，然后机器又观察画面，做出了开火的action，然后观察画面，发现有外星人被击落，然后获得reward。
从游戏开始到游戏结束被称为一个episode，那么机器就是要找到每一个episode中，谁的reward总和最大，然后总和最大的reward的episode所包含的各个action是比较好的！
策略梯度公式详解 那么这个Actor的损失函数该怎么定义呢？给定一个actor，记为Π，然后下表θ代表该神经网络的参数，然后input的s就是机器所看到的场景，然后让机器实际去玩一下这个游戏，然后我们要求总的Total reward最大，我们就要将所有的r加起来。但由于即使是使用相同的actor，每一次的总的奖励也可能不同，于是我们就求总的奖励的期望即可。
┏是场景，行动，奖励所组成的向量，如下图所示，比如说玩游戏，一个┏就代表了机器看到了第一个画面，做了某个行为，然后得到什么奖励，然后看到第二个画面，做了某个行为，然后得到什么奖励，以此类推，循环往复，直到游戏结束。然后每一个┏都有可能被经历。当你选择了某一个actor,也就是选择了某一个神经网络，那么会使某一些┏容易出现，某一些不容易出现。那么Rθ的期望就等于每一次游戏过程┏的奖励R与该过程┏出现的几率的乘积之和。那么穷举所有的┏显然不可能，那么我们就玩N场游戏，相当于N个训练数据。
下面的这图看起来不就是一个巨大的network吗？然后环境和reward是无法改变的，就相当于下棋的时候机器无法控制对手的操作，机器也无法改变奖励制度，唯一能改变的就是自己的参数，去适应环境，来使奖励最大化。
下面我们来看看P(┏|θ)打开是什么，画黄线的部分与你的actor无关，取决于外部环境，也就是游戏，然后红线部分与你的actor有关。
求最大你会想到梯度上升的求法，这里的梯度上升是策略梯度的一部分。
那么对Rθ期望求微分具体应该怎么做呢？如下图，R(┏)肯定不可微，但是没关系，它的表达式里没有θ，所以我只需对P(┏|θ)求导数，然后我们要对其做一下变换，巧用log！！然后画红框的两部分之前推导过可以化为1/N，然后整个表达式就可以化为一个近似的表达式。使用Πθ这个神经网络去玩N次游戏，可以得到N个┏
利用上述打开的结论，然后我们利用对数的性质化简，如下图所示：然后我们对θ求导！忽视与θ无关的项。然后得出来一个等式。
然后我们将Rθ得期望求导之后得算式写出来，如下图：其中，log里面的那个p所代表的意思就是当前第n回玩游戏时，t时刻机器所看到的画面的情况下做出a行为的概率，R(┏n)是指第n回完游戏时的总的奖励，然后利用上述得到的结果进行梯度上升。注意：如果我将R(┏n)换成rtn，也就是将第n回玩游戏的总的奖励换成第n回玩游戏时t时刻的奖励，那么会发生什么后果？？如果在刚刚那个射击游戏里，只有开火能得到奖励，那么就会导致机器只会开火。
如果在某一次玩游戏时，机器在看到某个场景时，采取了一个行动，然后总的奖励是正的，那么机器就会自己去增加看到这个场景下做出该行动的概率。
下面我们来看看更新model的过程，先是给了一个actor，然后给actor一个┏，然后算出奖励总和，然后用梯度上升，更新θ，然后再将另一个┏传给actor，循环往复执行。
如何使你的损失函数更好 增加一个基准 那么这里有一个问题，我们看下图，ideal case的第一张图，a和c的会使总的奖励变多，那么机器会倾向于执行a和c的操作，所以a和c的执行几率就变大了，相对的b的几率就减少了。然后我们再看看sampling那一行，b和c可能使我的总的奖励一直是正的，那么机器根本就不知道a的情况，万一a的操作更好呢？？机器只会去学更positive的，b和c的几率也会越来越大，a只会越来越小。这时，我们需要引入一个baseline，如下图的b，我们将总的奖励减去一个b值，也就是某一步的奖励一定要达到某一个标准我才能说它好，否则就是不好。通常我们可以将这个b设为与R(┏)的期望接近的值。
为每一个action分配不同的权重 比如下面是一个简单的游戏，就三步，第一组(s,a)得到的奖励是+5，第二组是0，第三组是-2，然后最后的奖励是+3,如果我们用之前的那个损失函数，那么就默认了每一个(s,a)的组合的权重都是+3,这显然是不靠谱的，虽然总的奖励是正的，但是明显里面有些组合不靠谱，我们就可以给那些不靠谱的组合负的权重。于是我们将R(┏n)换成下图的样子。这样就可以对每一个组合的权重加以区分。
同时，我们再增加一个衰减因子γ，意味着随着时间推移，组合越来越多，那么前面的组合对很后面的组合的影响就越来越小。然后我们将红框框住的那部分重新命名一个函数，叫Advantage function
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab5e363f84f3584ee8790ffcf7a4673/" rel="bookmark">
			ADC、DMA、EXTI、定时器、NVIC等片上外设篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知是否是干货，有什么问题，欢迎留言，看见都会答复的
目录
1. 首先呢，放一个STM32芯片框图，这样心里有底 2
2. 第一呢，我们闲聊聊中断 2
2.1什么叫做中断 2
2.2为什么我们要引入NVIC外设 3
2.3 NVIC主要做了那些工作呢 3
2.3.1 NVIC管理时用到的寄存器 3
2.4 NVIC编程 4
3. 说完NVIC，我们就来聊聊外部中断EXTI(IO上的中断) 4
3.1EXTI 功能框图 4
3.2中断/事件线 5
3.3 编程 5
3.3.1EXTI结构体（库函数） 5
3.3.2 编程要点 5
4 .TIM定时器 6
4.1基本定时器的原理 6
4.2基本定时器的基本初始化结构体 7
4.3 编程要点 7
5. 聊聊ADC 8
5.1 ADC原理详解 8
5.1.1①电压输入范围 8
5.1.2 ②输入通道 9
5.1.3 ③转换顺序 9
5.1.4 ④触发源 10
5.1.5 ⑤转换时间 10
5.1.6 ⑥数据寄存器 11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab5e363f84f3584ee8790ffcf7a4673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fced79b45f544def740cb625fe8f97ae/" rel="bookmark">
			如何在Microsoft白板上进行协作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A whiteboard is a great tool for collaborating with others. If you’re working remotely and can’t physically gather around one, though, you’ll need a virtual solution—like Microsoft Whiteboard.
白板是与他人合作的绝佳工具。 但是，如果您在远程工作并且不能在一个物理上聚集，那么您将需要一个虚拟解决方案，例如Microsoft Whiteboard。
Although Whiteboard is available for anyone with a free Microsoft account or any paid Microsoft 365/Office 365 (M365/O365) subscription, the collaboration features currently only work with members of the same organization.
尽管拥有免费Microsoft帐户或任何付费Microsoft 365 / Office 365(M365 / O365)订阅的任何人都可以使用Whiteboard，但协作功能当前仅适用于同一组织的成员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fced79b45f544def740cb625fe8f97ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3dbd2bb1fd7e384525419c7307faf3/" rel="bookmark">
			sublime一键代码格式化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sublime一键代码格式化 sublime是一款非常好用的编辑器，支持的语言也有很多，我一般会用它来看一些代码文件，只有前端的一些代码才会用它来写
作为程序员，大家都知道，网上前辈们很多优秀的代码我们要down下来学习学习，但每次打开的时候都多少会出现错行等现象，但好在sublime 支持一键代码格式化
1.安装办法 首先，sublime有很多的插件，那使用一键格式化之前就要先下载一个插件SublimeAstyleFormatter
1.打开sublime，在页面中 按ctrl + shift + p，然后在搜索框里面输入 install package，回车后等一会就会出现搜索框/输入框
2.在输入框里面输入SublimeAstyleFormatter，回车后即可下载
如果你没有安装过这个插件，在你输入的时候应该是会有提示的，这里我已经安装过了
2.怎么使用呢？ 很简单，格式化整个文件的按键是： ctrl + alt + f， 格式化选中区域的按键是： ctrl + k + f
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e6ca2b8aca341b6de08dbd3f27c91e/" rel="bookmark">
			零拷贝技术详细解读（Zero Copy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么要有DMA技术？了解一下传统的文件传输如何实现零拷贝PageCache有什么用？ 为什么要有DMA技术？ 在没有 DMA 技术前，I/O 的过程是这样的：
CPU 发出对应的指令给磁盘控制器，然后返回；磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断；CPU
收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间CPU 是无法执行其他任务的。
可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。 简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。
计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是直接内存访问（Direct Memory Access） 技术。
**什么是 DMA 技术？**简单理解就是，在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。
具体过程：
用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；DMA 进一步将 I/O 请求发送给磁盘；磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA发起中断信号，告知自己缓冲区已满；DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； 可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e6ca2b8aca341b6de08dbd3f27c91e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25ae85560df4675db5a3e998746540a3/" rel="bookmark">
			sql练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql语句练习50题(Mysql版)
Mysql数据库使用:学生选课系统，其中设计到三张表，分别为学生表，课程表，学生和课程对应的关联表。
笔试常用：
1、查A课程比B课程成绩高的所有学生学号
SELECT a.s_id FROM score a,score b WHERE a.s_id=b.s_id AND a.c_id='01' AND b.c_id='02' AND a.s_score&gt;b.s_score 2、查名字含“王”的老师的个数
SELECT COUNT(t_id) FROM teacher WHERE t_name LIKE '%王%'; 3、查平均成绩大于90的学生sid和平均成绩
SELECT s_id,ROUND(AVG(s_score),2) AS avg_score FROM score GROUP BY s_id HAVING avg_score&gt;=80; 4、查各科最高分最低分，，以如下形式显示：课程ID，最高分，最低分
SELECT a.c_id,MAX(s_score),MIN(s_score) FROM score a GROUP BY a.c_id 补充（可查看——sql语句练习50题(Mysql版)）：
– 1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数 – 6、查询"李"姓老师的数量
– 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩
– 18、查询各科最高最低分，以如下形式显示：课程ID，课程name，最高分，最低分
SELECT a.c_id,b.c_name,MAX(s_score),MIN(s_score) FROM score a LEFT JOIN course b ON a.c_id = b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25ae85560df4675db5a3e998746540a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c26bf848622c55c9a8f67361c28f8c/" rel="bookmark">
			HALCON中的各种Domain算子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HALCON中的各种Domain算子
每张图像都有其定义域（domain）。定义域包含的范围很广，例如从一个简单的矩形到任意的形状。Domain可以简单理解为ROI。
**Domain算子描述**get_domain返回图像的定义域full_domain（根据图像的尺寸）返回图像的最大定义域rectangle1_domain用平行于坐标轴的矩形去裁剪图像的定义域。注意：图像自身大小不变reduce_domain用任意形状的区域去裁剪图像的定义域。注意：图像自身大小不变crop_domain根据图像定义域去裁剪图像尺寸。注意：图像自身大小会改变 代码示例
read_image (Image, 'printer_chip/printer_chip_01') *获得图像的定义域 get_domain (Image, Domain) *用矩形去裁剪图像的定义域。（定义域变小，图像尺寸未变） rectangle1_domain (Image, ImageReduced, 100, 100, 200, 200) *获取图像的最大定义域。（定义域变为最大，图像尺寸未变） full_domain (ImageReduced, ImageFull) *获得图像的定义域 get_domain (ImageReduced, Domain1) *用任意形状的区域去裁剪图像的定义域，（定义域变小，图像尺寸未变） reduce_domain (Image, Domain1, ImageReduced1) *根据图像定义域去裁剪图像尺寸，（定义域未变，图像尺寸变小） crop_domain (ImageReduced1, ImagePart) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e11d9bba0eaf1cda48c2af4884311b23/" rel="bookmark">
			快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01-快速入门-框架的介绍 框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！ 02-快速入门-ORM介绍 ORM(Object Relational Mapping)： 对象关系映射
指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。
03-快速入门-mybatis的介绍 为什么使用MyBatis?先看一下JDBC JDBC新增 原始JDBC的操作问题分析 1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。
3.查询操作时，需要手动将结果集中的数据封装到实体对象中。
2.sql语句在代码中硬编码，如果要修改sql语句，就需要修改java代码，造成代码不易维护。
4.增删改查操作需要参数时，需要手动将实体对象的数据设置到sql语句的占位符。
原始JDBC的操作问题解决方案 1.使用数据库连接池初始化连接资源。
2.将sql语句抽取到配置文件中。
3.使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射。
这些问题和解决措施，导致MyBatis的出现
什么是MyBatis mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。mybatis通过xml或注解的方式将要执行的各种
statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc
进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 MyBatis官网地址：http://www.mybatis.org/mybatis-3/
04-快速入门-mybatis入门程序 SQL数据准备 CREATE DATABASE db1; USE db1; CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT ); INSERT INTO student VALUES (NULL,'张三',23); INSERT INTO student VALUES (NULL,'李四',24); INSERT INTO student VALUES (NULL,'王五',25); SELECT * FROM student; MyBatis开发步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e11d9bba0eaf1cda48c2af4884311b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77435967f28453e0285c4f011c389af4/" rel="bookmark">
			深度学习之Pytorch（一）神经网络基础及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 Tensor (张量) Tensor 可以和 numpy 的 ndarray相互转换Tensor有不同数据类型，有32位浮点型torch.FloatTensor、64位浮点型 torch.DoubleTensor等 1.2 Variable (变量) Variable 和 Tensor 本质上没有区别，不过 Variable 会被放入一个计算图中，然后进行前向传播，反向传播，自动求导。Variable 有三个比较重要的组成属性: data, grad 和 grad_fn通过 data可以取出 Variable 里面的 tensor 数值， grad_fn 表示的是得到这个Variable 的操作，比如通过加减还是乘除来得到的，最后 grad 是这个Variabel 的反向传播梯度.构建Variable. 要注意参数 requires_grad=True/ False，这个参数表示是否对这个变量求梯度，默认的是 False ，也就是不对这个变量求梯度XXX.backward() 是对于标量求导，里面的参数可以不写；对于矢量求导，要传入参数声明，比如：y.backward(torch.FloatTensor( [1， 0.1 ， 0. 01] ))，这样得到的梯度就是它们原本的梯度分别乘上1，0.1和0.01 例子见P37
1.3 Dataset (数据集) torch.utils.data.Dataset是代表这一数据的抽象类，可以自定义数据类 继承和重写这个抽象类，可以通过迭代的方式来取得每一个数据。通过torch.utils.data.DataLoader定义一个新的迭代器，实现取batch， shuffle或者是多线程去读取数据。 例：
torch.utils.data.DataLoader(dataset,batch_size=1,shuffle=False,sampler=None, batch_sampler
=None,num_workers=0,collate_fn=&lt;function default_collate&gt;, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None): 自定义数据加载器。组合了一个数据集和采样器，并提供关于数据的迭代器。
dataset (Dataset)：需要加载的数据集（可以是自定义或者自带的数据集）。
batch_size：batch的大小（可选项，默认值为1）。
shuffle：是否在每个epoch中shuffle整个数据集， 默认值为False。
sampler：定义从数据中抽取样本的策略. 如果指定了, shuffle参数必须为False。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77435967f28453e0285c4f011c389af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d390fcbb8799351cd9306c0db8a83932/" rel="bookmark">
			原生js实现分页功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原生js分页
实现效果 一、函数封装分页 传入两个参数。第一个为要显示第几页，第二个是页面显示多少数据，
Js动态操作dom插入 分页按钮
条件结构判断 是否为按钮绑定点击事件
二、使用步骤 1.html+css 代码如下（示例）： &lt;style&gt; #idData {color: red;border: solid;text-align: center;} a{text-decoration: none;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table id="idData" width="70%"&gt; &lt;tr&gt;&lt;td&gt;行1&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行2&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行3&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行4&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行5&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行6&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行7&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行8&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行9&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行10&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行11&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行12&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行13&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行14&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行15&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行16&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行17&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行18&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行19&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行20&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行21&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行22&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行23&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行24&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行25&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行26&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行27&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行28&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行29&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行30&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行31&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行32&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行33&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行34&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行35&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行36&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行37&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行38&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行39&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;行40&lt;/td&gt;&lt;td&gt;美女&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;外伶仃岛&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;table width="60%" align="right"&gt; &lt;tr&gt;&lt;td&gt;&lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d390fcbb8799351cd9306c0db8a83932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a505f67853e8f9e75997af9f171555/" rel="bookmark">
			Java异常整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java异常整理 1.Mybatis使用遇到异常 1).初始化异常（sqlSessionFactory） 原因：mybatis实现接口的时候不支持方法重载解决办法：注意实现接口的时候id不要重复即可报错日志如下 org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSessionFactory' defined in class path resource [spring-dao.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis-config.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. The XML location is 'com/michael/dao/AdminUserDao.xml'. Cause: java.lang.IllegalArgumentException: Mapped Statements collection already contains value for com.michael.dao.AdminUserDao.getAdmins. please check com/michael/dao/AdminUserDao.xml and com/michael/dao/AdminUserDao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99a505f67853e8f9e75997af9f171555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac76d509db269ff4db0e9980540e0204/" rel="bookmark">
			Echarts：10-7-5:雷达图&#43;多雷达图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-基础雷达图
option = { title: { text: '雷达图' }, tooltip: {}, legend: { data: ['预算分配（Allocated Budget）', '实际开销（Actual Spending）'] }, radar: { // shape: 'circle', name: { textStyle: { color: '#fff', borderRadius: 3, padding: [3, 9] } }, indicator: [ { name: '销售（sales）', max: 6500}, { name: '管理（Administration）', max: 16000}, { name: '信息技术（Information Techology）', max: 30000}, { name: '客服（Customer Support）', max: 38000}, { name: '研发（Development）', max: 52000}, { name: '市场（Marketing）', max: 25000} ] }, series: [{ type: 'radar', data: [ { value: [4300, 10000, 28000, 35000, 50000, 19000], name: '预算分配（Allocated Budget）' }, { value: [5000, 14000, 28000, 31000, 42000, 21000], name: '实际开销（Actual Spending）' } ] }] }; 2-多雷达图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac76d509db269ff4db0e9980540e0204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7ec061e2446db1df02951bf89fa8d8/" rel="bookmark">
			阅读笔记--MolGAN: An implicit generative model for small molecular graphs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读笔记-MolGAN: An implicit generative model for small molecular graphs 概要背景介绍分子图隐式生成模型与似然生成模型GAN 与 Improved WGANDeterministic policy gradients 模型模型架构生成器判别器与反馈网络 实验分子生成药物发现 总结 概要 寻找具有理想性质的新化合物是一项具有挑战性的任务，具有重要的应用，如新药设计。可合成分子的空间是巨大的，在这个空间中寻找是非常困难的，这主要是由于它的离散性质。最近在开发深层生成模型方面取得的进展催生了一系列解决这一问题的有希望的提议。SMILES是一种从分子图派生的基于字符串的表示法。例如苯可以表示为： c 1 c c c c c 1 c1ccccc1 c1ccccc1。所以可以把它看作一个像语句那样的序列，然后利用基于RNN的生成方法来生成。但它的缺点为RNN必须花费能力来学习语法规则和表示的顺序歧义。 此外，这是不适用于一般（非分子）图的方法。SMILES字符串是从基于图的分子表示中生成的，因此在原始图空间中工作可以减少额外的开销。基于似然性的分子图生成方法需要提供固定（或随机选择）的图表示或昂贵的图匹配程序来评估生成的分子的可能性，因为对所有可能的节点排序的评估对于小尺寸的图的计算成本已经是非常高的了。
在这篇文章中作者利用生成对抗网络来生成分子图。并利用强化学习辅助生成具有具体属性的分子。
背景介绍 分子图 G \mathcal G G将一个分子表示为一个无向图。对于一个具有N个节点一个分子图可以由如下两个矩阵表示:
A ∈ R N × N × Y A\in\mathbb R^{N\times N\times Y} A∈RN×N×Y：邻接矩阵。 Y Y Y代表着分子图中具有Y种共价键（如单键、双键以及三键）。 A i j ∈ R Y A_{ij}\in\mathbb R^{Y} Aij​∈RY代表着原子 i , j i,j i,j之间的共价键类型（用 o n e − h o t one-hot one−hot向量来表示）。 X = [ x 1 , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7ec061e2446db1df02951bf89fa8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8312854ce105011f6abf7b3315067b9/" rel="bookmark">
			在 IDEA 中，通过 module（模块） 依赖来解决一个模块中使用另一个模块中的类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题操作步骤（图示 + 文字说明） 问题 有两个模块，其中一个模块中的类文件里，想使用另外一个模块中存在的类。
虽然同在一个 Project 下，却是不能够直接使用的。
而通过 import 关键字也是无法解决问题的。
我们知道，在 Maven 项目中，通过在 pom.xml 文件中添加依赖配置，就可以解决问题。
但是非 Maven 项目呢？IDEA 很好地提供了一个解决方案：模块依赖
操作步骤（图示 + 文字说明） 说明：此解决方案，仅适用于非 Maven 项目
进入报错模块（即需要引用其他模块中的类的模块）的设置面板，添加依赖关系
需要引用哪个模块中的类，就依赖谁
点击“应用”后，依赖成功，报错解决。
此时再看，鼠标放到函数上面，可以看到函数的详细信息（所在类，所在模块，函数定义信息）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfab8f7ac0de2e980afe667981f49e77/" rel="bookmark">
			深度学习笔记_卷积神经网络参数计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卷积后卷积层大小 W2= (W1-F+2P)/S +1即 (原始图像的宽度-卷积核的宽度+2倍的填充宽度)/步长 + 1采用K个大小为FxF的卷积核，进行步长为S, 填充为P的卷积运算后，得到的层的宽为W2,高为H2, 深度为D2,计算如下所示。 参数量大小 (FxFxD1)xK + K即（卷积核宽x卷积核高）x卷积核的个数 + 偏差个数（即卷积核的个数，每一层有一个bias） Padding的大小 P = (F-S)/2 即（卷积核的宽度-步长）的一半 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66530663538f71a7c9dbccb5cbb2556/" rel="bookmark">
			Windows环境下anaconda环境的迁移以及pyqt5迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：本人在电脑上A上配置好了anaconda的环境，用于pyqt5的GUI开发，之后想要迁移到电脑B上工作
踩坑：
Q1：anaconda环境的迁移
step1：使用了yaml的方法，结果提示conda只能安装在root环境中，此方法放弃
(E:\Anaconda3) E:\&gt;conda env create -f out.yaml Using Anaconda API: https://api.anaconda.org Fetching package metadata .........Could not connect to https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/win-64/ Could not connect to https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/ Could not connect to https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/noarch/ Could not connect to https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/noarch/ .......... InstallError: Install error: Error: 'conda' can only be installed into the root environment step2：使用图形界面的clone迁移，点击clone导出到一个文件夹，然后压缩，在新电脑的的anaconda文件夹envs里解压（我的是E:\Anaconda3\envs\MyEnv），就能在环境里看到。此方法成功，需要使用的包基本都被迁移过来。
Q2：在pycharm中迁移工程的问题
step1：我将pycharm工程直接迁移到新电脑中运行，不成功，显示什么conde=-2，猜想是由于pycharm的配置文件与python路径相关，于是将下图中文件删除，重新创建工程，问题得到解决
Q3：pyqt5中显示“this application failed to start because it could not find or load ...windows in”，参考了https://blog.csdn.net/weixin_42359147/article/details/81140640这篇文章，找到我clone的环境下的qt.conf文件，该文件与python.exe同级，我的是（E:\Anaconda3\envs\MyEnv），使用记事本打开，将路径修改，问题得到解决
注意：需要正确配置Configure a Python Interpreter，请自行百度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a66530663538f71a7c9dbccb5cbb2556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a8534a3fde0fc57e424c96ce2652b1/" rel="bookmark">
			使用 opencv-python 提取视频每一帧的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉是指用摄影机和计算机代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图像处理，用计算机处理成为更适合人眼观察或传送给仪器检测的图像，其任务有图像形成、图像处理、图像提取和图像的三维推理，而目标识别和面部识别也是很重要的研究领域。
OpenCV 的全称是 Open Source Computer Vision Library，是一个跨平台的计算机视觉库，其基于C/C++，支持 Linux/Windows/MacOS/Android/iOS，并提供了 Python，Matlab 和 Java 等语言的接口。
如何使用 opencv-python 提取视频每一帧的图片？ 编程语言：Python
所需库：cv2
获取视频（创建 VideoCapture 对象） 使用 cv2.VideoCapture 类
Args：
filename – 文件路径；
device – 视频设备id ，若只有一个摄像头可以填 0，表示打开默认摄像头；
vc = cv2.VideoCapture(filename) 检验 VideoCapture 对象是否创境成功 使用 VideoCapture 对象的 isOpened 方法
# determine whether to open normally if vc.isOpened(): ret, frame = vc.read() else: ret = False 若成功，返回 True。
按帧读取视频 使用 VideoCapture 对象的 read 方法
使用 VideoCapture 对象的 read 方法按帧读取视频，ret, frame 是 read 方法的两个返回值 ，其中 ret 是布尔值，如果能正确读取帧，则返回 True；如果文件读取到结尾，它的返回值就为 False。frame 就是每一帧的图像，是一个三维矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3a8534a3fde0fc57e424c96ce2652b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce14cab04ff327afd84037c2d3055439/" rel="bookmark">
			JAVA面试题之七—线程池的工作原理和7个参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池的工作原理和7个参数（京东物流、美团充电宝一面、中信银行一面、美团外卖一面、58用户平台一面、轻松集团）
7个参数 corePoolSize：线程池核心线程数量maximumPoolSize:线程池最大线程数量keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间unit：存活时间的单位workQueue：存放任务的队列threadFactory：创建线程的工厂handler：超出线程范围和队列容量的任务的处理程序
每个值为什么这么设置？ 工作原理 例子：
核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。
刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列；
任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个；
后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。
当当前任务小于最大线程数的时候，线程资源会保持核心线程池个数的线程，其他超过的线程资源在存活时间时间之后会被回收。
拒绝策略 1、AbortPolicy：直接抛出异常
2、CallerRunsPolicy：只用调用所在的线程运行任务
3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
4、DiscardPolicy：不处理，丢弃掉。
代码 import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.RejectedExecutionHandler; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * 线程池测试 * 使用丢弃策略处理多余线程，不管多余线程 */ public class ThreadPoolTest2 { public static void main(String[] args) { LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(5); // 丢弃策略，多余的线程直接不处理，丢弃 RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy(); // 创建线程池 5 10 60s ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 60, TimeUnit.SECONDS, queue, handler); for (int i = 1; i &lt;= 16; i++) { threadPool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce14cab04ff327afd84037c2d3055439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851c5801233fa4319a90893df37e5101/" rel="bookmark">
			Caffeine使用篇 - Eviction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、基于大小二、基于时间三、基于引用 前言 Caffeine提供了三种驱逐策略 - 基于大小、基于时间、基于引用。
一、基于大小 使用固定大小的容量maximumSize或者maximumWeight，一旦超出将基于recently or very often（最近最少）策略，驱逐元素。
1. maximumSize
要求maximumSize与maximumWeight只能设置一个。此外，maximumSize必须大于0。 e.g.
Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder() .maximumSize(10) .build(); List&lt;Object&gt; list = new ArrayList&lt;&gt;(100); for (int i = 0; i &lt; 100; i++) { cache.put(i, i); list.add(i); } Map&lt;Object, Object&gt; map = cache.getAllPresent(list); map.forEach((k, v) -&gt; { System.out.println(k + ":" + v); }) System.out.println(cache.estimatedSize()); 2. maximumWeight
要求maximumSize与maximumWeight只能设置一个。此外，maximumWeight必须大于0。 要求一个Caffeine实例只设置一个weigher(…)方法，maximumWeight必须设置。
e.g.
Cache&lt;Object, Object&gt; cache = Caffeine.newBuilder() .maximumWeight(10) .weigher(new Weigher&lt;Object, Object&gt;() { @Override public @NonNegative int weigh(@NonNull Object key, @NonNull Object value) { if (value instanceof Integer) { Integer v = (Integer) value; return v; } return 0; } }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/851c5801233fa4319a90893df37e5101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66579a9552b74fdccc86c3e2f8f328e1/" rel="bookmark">
			阅读笔记-KDD2020-MoFlow: An Invertible Flow Model for Generating Molecular Graphs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读笔记-MoFlow: An Invertible Flow Model for Generating Molecular Graphs 一、 Introduction二、Inference（encoding）2.1 Model Preliminary.2.1.1 The flow framework.2.1.2 Invertible affine coupling layers.2.1.3 Splitting Dimensions.2.1.4 Numerical stability by actnorm 2.2 Proposed Moflow Model2.2.1 Problem Definition: Learning a ProbabilityModel of Molecular Graphs2.2.2 Glow for Bonds2.2.3 Graph Conditional Flow for Atoms2.2.4 Validity Correction 三、Experiments3.1 生成与重建3.2潜在空间的可视化3.3 性能优化3.4 约束属性优化 相关资料： SlidesVideoPaperCode 一、 Introduction 这篇文章是 f l o w − b a s e d flow-based flow−based，大致就是有两个概率分布，如果他们之间的变换是可逆的，那么就可以根据一个较为简单地分布通过逆变换获得另外一个较复杂的概率分布。这篇文章采用的就是将邻接矩阵和原子矩阵这两个概率分布与另外两个较为简单的潜在变量的分布（文中将这两个潜在变量的分布采样为高斯分布）利用flow联系了起来。通过设计一个可逆的分布，以及从高斯分布中采样，将采样的潜在变量通过这个可逆的变换就可以得到分子图结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66579a9552b74fdccc86c3e2f8f328e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57dac1af83aaa5f97da43f741b037300/" rel="bookmark">
			Vue 中数组对象排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型
var arr = [{data:5,date:2017-12-26},{data:80,date:2017-12-27},{data:4,date:2017-12-10}] 根据数字排序 data
// 排序方法 compare(property){ return function(a,b){ var value1 = a[property]; var value2 = b[property]; return value1 - value2; } }, // 使用方法 data 就是数组中你要排序的名称，使用时替换 arr.sort(this.compare('data')); 根据日期排序 date
//升序排序 里面的 date 就是数组中的 date，使用时替换 arr.sort(function(a, b) { if (a.date &lt; b.date ) { return -1; } else if (a.date &gt; b.date ) { return 1; } else { if (a.date &lt; b.date ) { return 1; } else if (a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57dac1af83aaa5f97da43f741b037300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64156c8dcf03eb20b341b4ed7bd1be4c/" rel="bookmark">
			再见了SpringCloud！这个架构挺猛，居然干掉了Dubbo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5年前面试最常问的并且可以顺利拿到高薪的技能是dubbo，2年前面试,只要你简历上有Spring Cloud项目的相关经验,肯定会打动面试官，现在呢?恐怕简历上有dubbo和简单的Spring Cloud技术和经验是无法让面试官高看你的。
SpringCloud Alibaba 近几年在受到国内不少开发者的广泛关注,也成为面试比较吃香的一个技能点了,如果你连SpringCloud Alibaba 微服务生态都没用过,那么你可能就要被时代淘汰了。
最近去大厂面试的兄弟就体验了一把，问及面试考题，这位兄弟言辞中有些许惭愧：面试官已经给了一些提示，但无奈自己准备得不充分，回答很不理想。他没想到，像Seata、Nacos，Sentinel，Eureka等这些在工作中都有涉及过的技术，面试官会问的这么深入！
看完你能回答上几道？据我所知，如果能回答的出其中的一半，就算是勉强及格了。如果十二条你都能全部回答出来，那你应该是妥妥的技术大牛了！可以放心去投大厂简历了！
当然为了帮助那些还在学习Sprng Cloud Alibaba及Spring Cloud微服务的朋友，在这也特地整理了这2份微服务进阶学习手册及大纲脑图分享给大家！由于篇幅原因，本文只展示了目录和内容截图，有需要学习的小伙伴只需转发后私信回复【999】即可来免费获取了！
Sprng Cloud Alibaba进阶学习手册目录 第一章：微服务介绍
第二章 微服务环境搭建
第三章 Nacos Discovery--服务治理
第四章 Sentinel--服务容错
第五章 Gateway--服务网关
第六章 Sleuth--链路追踪
第七章 Rocketmq--消息驱动
第八章 SMS--短信服务
第九章 Nacos Config--服务配置
第十章 Seata--分布式事务
内容展示
6月阿里遭拒，90天深造357页微服务手册，获京东offer 总结 截止到今天，Spring Cloud Alibaba 获得了数超过 1.5w 的 star 数。同时在 Github 上的项目依赖，就是对 Spring Cloud Alibaba 产生依赖关系的产品，也超过了 6000。最重要的，使用 Spring Cloud Alibaba 的公司超过 1000 家。当然不只是外部的公司在使用，我们自己其实也在使用。那经过了双十一的洗礼，其实整个这套框架它的这个稳定性可靠性都得到了印证。
如果你还在学习Spring Cloud Alibaba 而没有方法，这份进阶学习手册和学习路线导图能够帮助到您！有需要的小伙伴只需要你：
——转发和评论我的文章，关注后私信100%免费领取口令「999」即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c09757da7b115a7833693106175d8c3/" rel="bookmark">
			什么是EasyAntiCheat.exe，为什么在我的计算机上？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fortnite and some other online games require EasyAntiCheat. This tool monitors your PC while you’re playing, attempting to stop cheats from working in the first place. If it detects a problem, you can be banned from playing the game online.
Fortnite和其他一些在线游戏需要EasyAntiCheat。 该工具在您玩游戏时会监控您的PC，首先尝试阻止作弊行为。 如果检测到问题，可能会禁止您在线玩游戏。
什么是EasyAntiCheat？ (What is EasyAntiCheat?) Easy Anti-Cheat, developed by Kamu, is an anti-cheating tool designed to stop (and catch) cheaters in online multiplayer games. Think of it like a more modern replacement for PunkBuster, the anti-cheating application that debuted in 2001.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c09757da7b115a7833693106175d8c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330fc84828c3116d62e7c16bc557e806/" rel="bookmark">
			阿里（钉钉部门）远程面，三面坐上“直通车”，拿下offer没问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开篇 由于疫情的缘故，钉钉算是脱颖而出，下载量而话题度直线攀升，巧的是，我也在这个特殊时间里接到了阿里钉钉的邀请。
本人毕业于华南地区某不知名211院校，Java方向，目前钉钉三面已经结束，基本可以说是坐上了“直通车”，收到的反馈都是比较好的，跟HR沟通感觉希望很大，按道理来说拿下offer是没有太大问题的，以下内容就是我这次的钉钉远程面试经历的一个分享和一些心得，希望对大家能够有所帮助。
以下主要分享面经和个人学习方法，会包括很多PDF文档，如面试题库（含答案+解析）、学习笔记、实战文档和脑图等等，均可以免费分享，私信我【666】即可领取~
阿里巴巴钉钉部门远程面试（技术面部分） 钉钉一面：
先自我介绍一下自己讲一下currenthashmap的实现原理，插入时怎么保证的线程安全？更新时怎么保证的线程安全？什么时候加锁？谈谈对代理的理解动态代理是什么？静态代理是什么？说一下两者的区别动态代理的实现方式，他们有什么区别吗？JVM常用命令行调优工具Redis缓存击穿和缓存雪崩HashMap容量大了再扩容，比较耗时怎么办？知道哪些排序？快速排序的原理？你觉得你在开发的项目过程中，哪个项目是有亮点的？说一下亮点在哪？有没有遇到什么困难？怎么解决的？谈谈你对阿里巴巴的认识？你对钉钉了解多少？为什么选择钉钉？ 钉钉二面：
聊了一会项目，很浅讲一下currenthashmap和hashtable的区别讲JVM回收算法，优缺点数据库事务隔离级别以及会产生的问题？数据库b+树索引建立过程redis介绍redis路由选择了解过吗？Spring的了解，IOC，AOP原理。AOP的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理？Java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁，用过reentrantlock吗？reentrantlock与synmchronized的区别Mysql是如何实现事务的？读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式？ 钉钉三面：
介绍你做的项目和其中的难点？反射的作用是什么？数据仓库，多线程和并发工具等？私有云，docker和k8s等？了解哪些中间件，Dubbo，RocketMQ，Mycat等？Dubbo中的 rpc如何实现？自己实现 rpc应该怎么做？Dubbo的服务注册与发现？排序算法 阿里巴巴钉钉部门面试题（完整版+答案解析）：
远程面，该如何操作才能稳坐“直通车”？ （1）准备外在：设备、环境
关于远程面试，第一点我们需要做好的就是准备外在，所谓的外在，包括了设备、视频环境、角度等各个方面，提前调试好设备很有必要，以防在面试过程中发生故障受到影响，另外视频面试的手机距离要适中，不要太近也不要太远，最后面试环境要安静，背景要干净。
（2）准备内在：心理素质
关于准备内在，无非是调整自己的心理素质，面试切记不要紧张，表情也不要太过于夸张，遇到不会的问题也不要慌，试着让面试官提醒一下，另外建议采用“微笑面试法”，让面试官感受到自己的情绪，态度是热情的，这样容易让面试官对你产生好的印象，从而给你的面试增分添彩。
（3）准备自己：知识和技能
最后且最为重要的一点就是准备自己，关于准备自己，无非就是需要提升自己的知识储备与技能水平，关于这一点，没有捷径可言，最好的方法就是“不断学习”，关于学习，我也有自己的一套学习方法，特整理了一些学习资料，可以友情分享给大家。
①Java核心知识整理 Java部分：Java基础，集合，并发，多线程，JVM，设计模式数据结构算法：Java算法，数据结构开源框架部分：Spring，MyBatis，MVC，netty，tomcat分布式部分：架构设计，Redis缓存，Zookeeper，kafka，RabbitMQ，负载均衡等微服务部分：SpringBoot，SpringCloud，Dubbo，Docker
②Spring全家桶（实战系列） 关于Spring，是面试中必问的一个知识面，包括实战、源码等等，以下整理出了一些Spring家族的脑图、笔记、源码等。
③刷题刷题刷题 面试刷题，必不可少，我个人有一套私藏的面试题库，包括JAVA筑基部分、MySQL性能优化、分布式、开源框架、微服务架构等。
结束语 无论现场面还是远程面，都要调整好自己的心态，不要畏惧，往往害怕是源于准备不充分。只要我们提前做充足的准备，视频面试只是浮云。祝大家能在视频面试中超常发挥，向面试官证明：你的优秀不仅仅只是写在简历上。
以上内容中所有的学习资料、面试资料，均可以免费提供，希望大家金三银四面试顺利，拿下自己心仪的offer！
资料获取方式：转发+评论我的文章，关注我，然后私信【666】即可免费领取~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38439bf5e227c6bcd95c39c974a22b41/" rel="bookmark">
			resnet_v2_101训练自己的数据,完成分类任务之数据制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做了一个简单的分类任务，作一下记录，适合小白。从数据处理到推理代码都有，没错，我就是这么暖心！本次代码的框架使用了tf1.14版本，喜欢追逐梦想的童鞋可以尝试使用2.0的。主要差别是很多函数的API入口变了，一些旧的模块在2.0里不支持。关于resnet，这里主要使用slim包来实现，虽然我很喜欢造轮子，但是排期不允许。考虑到不是核心模块，直接拿来主义。到这里，可能有人会迷惑，slim包里有v1和v2版本，到底用哪个呢？我印象中，v1是原著的模型,v2在shortcut-connections上进行了改动，V2的残差单元的激活函数变了。从大牛们的测试结果上看，V2比V1准确度更高些。
入手步骤：当然是先准备数据啦，我这里转成了tfrecord格式。图片准备不用我说了吧~直接上数据处理代码。
import tensorflow as tf
import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
import random
from PIL import Image
def _int64_feature(value):
return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))
def _bytes_feature(value):
return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))
def float_list_feature(value):
return tf.train.Feature(float_list=tf.train.FloatList(value=value))
def get_example_nums(tf_records_filenames):
nums= 0
for record in tf.python_io.tf_record_iterator(tf_records_filenames):
nums += 1
return nums
def show_image(title,image):
plt.imshow(image)
plt.axis('on') # 关掉坐标轴为 off
plt.title(title) # 图像题目
plt.show()
def load_labels_file(filename,labels_num=1,shuffle=False):
images=[]
labels=[]
with open(filename) as f:
lines_list=f.readlines()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38439bf5e227c6bcd95c39c974a22b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b0b5f1f3392056af58dc81073ddc58/" rel="bookmark">
			Python中给List添加元素的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List 是 Python 中常用的数据类型，它一个有序集合，即其中的元素始终保持着初始时的定义的顺序（除非你对它们进行排序或其他修改操作）。
在Python中，向List添加元素，方法有如下4种方法（append(),extend(),insert(), +加号）
1. append() 追加单个元素到List的尾部，只接受一个参数，参数可以是任何数据类型，被追加的元素在List中保持着原结构类型。
此元素如果是一个list，那么这个list将作为一个整体进行追加，注意append()和extend()的区别。
&gt;&gt;&gt; list1=['a','b'] &gt;&gt;&gt; list1.append('c') &gt;&gt;&gt; list1 ['a', 'b', 'c'] 2. extend() 将一个列表中每个元素分别添加到另一个列表中，只接受一个参数；extend()相当于是将list B 连接到list A上。
&gt;&gt;&gt; list1 ['a', 'b', 'c'] &gt;&gt;&gt; list1.extend('d') &gt;&gt;&gt; list1 ['a', 'b', 'c', 'd'] 3. insert() 将一个元素插入到列表中，但其参数有两个（如insert(1,”g”)），第一个参数是索引点，即插入的位置，第二个参数是插入的元素。
&gt;&gt;&gt; list1 ['a', 'b', 'c', 'd'] &gt;&gt;&gt; list1.insert(1,'x') &gt;&gt;&gt; list1 ['a', 'x', 'b', 'c', 'd'] 4. + 加号，将两个list相加，会返回到一个新的list对象，注意与前三种的区别。前面三种方法（append, extend, insert）可对列表增加元素的操作，他们没有返回值，是直接修改了原数据对象。 注意：将两个list相加，需要创建新的list对象，从而需要消耗额外的内存，特别是当list较大时，尽量不要使用“+”来添加list，而应该尽可能使用List的append()方法。
&gt;&gt;&gt; list1 ['a', 'x', 'b', 'c', 'd'] &gt;&gt;&gt; list2=['y','z'] &gt;&gt;&gt; list3=list1+list2 &gt;&gt;&gt; list3 ['a', 'x', 'b', 'c', 'd', 'y', 'z'] 参考网址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b0b5f1f3392056af58dc81073ddc58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7299aef43ed436cd406cd3af2fc8dd3e/" rel="bookmark">
			asp版最新的阿里云短信SDK asp版阿里云短信SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云提供了java,php,asp.net,python等版本，由于没有asp版本的下载。本人决定写一个这样的asp版本。不是阿里云大与短信。就是最新的阿里云短信。
主要在于签名的生成，以及相关的http请求的地址生成。
1。由于asp本身没有签名加密的函数，所以需要自写一个加密函数。
2。需要对要加密的字符串进行构建，这里需要把一些符号进行特殊处理，甚至是经过了二次特殊处理，绝对是个坑啊。
3。对加密的密阴也不是直接拿来就用，需要在未尾添加一个符号。这也是个小坑，不注意就会签名不正确。
最后还是完成了这个asp版本的源码。有利用阿里云短信功能的asp同行可以加我VX:1572939714来获取源码。支付100劳务费。
亲测100%管用。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b66bbd95cbe8084afe240f33910978/" rel="bookmark">
			FFmpeg工具（一） --- ffmpeg视频处理命令行大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFmpeg是视频处理最常用的开源软件。FFmpeg中常用的工具主要是ffmpeg，ffprobe，ffplay，它们分别用作多媒体的编解码工具，内容分析工具和播放器。
FFmpeg工具（一） — ffmpeg视频处理命令行大全
FFmpeg工具（二） — ffprobe常用命令
FFmpeg工具（三） — ffplay常用命令
本篇主要介绍ffmpeg视频处理命令。它功能强大，用途广泛，大量用于视频网站，也是许多音视频格式的标准编解码实现。
ffmpeg的使用格式 ffmpeg的命令行参数非常多，可以分成五个部分。
$ ffmpeg {1} {2} -i {3} {4} {5} $ ffmpeg [全局参数] [输入文件参数] -i [输入文件] [输出文件参数] [输出文件] 上面命令中，参数依次为1.全局参数，2.输入文件参数，3.输入文件，4.输出文件参数，5.输出文件。
比如：
$ ffmpeg \ -y \ # 全局参数 -c:a libfdk_aac -c:v libx264 \ # 输入文件参数 -i input.mp4 \ # 输入文件 -c:v libvpx-vp9 -c:a libvorbis \ # 输出文件参数 output.webm # 输出文件 上面的命令将 mp4 文件转成 webm 文件，这两个都是容器格式。输入的 mp4 文件的音频编码格式是 aac，视频编码格式是 H.264；输出的 webm 文件的视频编码格式是 VP9，音频格式是 Vorbis。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21b66bbd95cbe8084afe240f33910978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3d7b7593756941fc6212013e9e5f31/" rel="bookmark">
			sql查询某个字段内容长度/获取指定字段内容长度的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 获取指定字段内容长度的数据
select * from 表名 where dr = 0 and LENGTH(字段名)&gt;长度 ;
-- 查询某个字段内容长度
select LENGTH(字段) from 表名 where 条件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704b34c96466620bdeebe8fbe9cb59ef/" rel="bookmark">
			Java实现RSA分段加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文完成的是公钥加密，私钥解密（私钥加密公钥解密是一样的）。
注意点：
秘钥生成的格式不同，使用算法也不同，公钥是X509EncodedKeySpec，私钥是PKCS8EncodedKeySpec。报错java.security.spec.InvalidKeySpecException就是因为密钥格式问题。报错Data must not be longer than *** bytes是因为没有分段解密，密文太长。分段加密解密时钥注意偏移量，256位或者128位钥看自己密钥的生成。本文把公私密钥做了编码获取处理是为了方便传输，如果不需要传输，可以不做，代码稍改即可。 代码如下
package RSA; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.*; import java.security.spec.InvalidKeySpecException; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.Base64; /** * @version v1.0 * @ProjectName: Cryptography * @ClassName: RSA * @Description: TODO(RSA加密解密算法类) * @Author: 你还年轻 * @Date: 2020/9/27 21:04 */ public class RSA { /** * @Description: TODO(获取密钥对) * @param * @return {@link KeyPair} * @author 你还年轻 * @throws * @date 2020/9/27 21:48 */ public static KeyPair generateKeyPairs() throws NoSuchAlgorithmException, UnsupportedEncodingException { //标明算法类型 String algorithm = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704b34c96466620bdeebe8fbe9cb59ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abbdd13feda3efa3f854f7be5e60c51c/" rel="bookmark">
			linux权限数字‘755’，‘700’等代表的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		444 r–r--r–
600 rw-------
644 rw-r–r--
666 rw-rw-rw-
700 rwx------
744 rwxr–r--
755 rwxr-xr-x
777 rwxrwxrwx
从左至右，
1-3位数字代表文件所有者的权限，
4-6位数字代表同组用户的权限，
7-9数字代表其他用户的权限。
读取权限：等于4 用 r 表示
写入权限：等于2 用 w 表示
执行权限：等于1 用 x 表示
例如：
755
7： 4+2+1 rwx 所有者具有读取、写入、执行权限；
5: 4+0+1 r-x 同组用户具有读取、执行权限但没有写入权限；
5: 4+0+1 r-x 其他用户具有读取、执行权限但没有写入权限；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e34efb1df98079186aaaa17b2e393a8/" rel="bookmark">
			【mySQL】MySQL JOIN原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL JOIN原理 先看一下实验的两张表：
表comments，总行数28856
表comments_for，总行数57，comments_id是有索引的，ID列为主键。
以上两张表是我们测试的基础，然后看一下索引，comments_for这个表comments_id是有索引的，ID为主键。
最近被公司某一开发问道JOIN了MySQL JOIN的问题，细数之下发下我对MySQL JOIN的理解并不是很深刻，所以也查看了很多文档，最后在InsideMySQL公众号看到了两篇关于JOIN的分析，感觉写的太好了，拿出来分享一下我对于JOIN的实际测试吧。下面先介绍一下MySQL关于JOIN的算法，总共分为三种（来源为InsideMySQL）：
MySQL是只支持一种JOIN算法Nested-Loop Join（嵌套循环链接），不像其他商业数据库可以支持哈希链接和合并连接，不过MySQL的Nested-Loop Join（嵌套循环链接）也是有很多变种，能够帮助MySQL更高效的执行JOIN操作：
（1）Simple Nested-Loop Join（图片为InsideMySQL取来）
这个算法相对来说就是很简单了，从驱动表中取出R1匹配S表所有列，然后R2，R3,直到将R表中的所有数据匹配完，然后合并数据，可以看到这种算法要对S表进行RN次访问，虽然简单，但是相对来说开销还是太大了
（2）Index Nested-Loop Join，实现方式如下图：
索引嵌套联系由于非驱动表上有索引，所以比较的时候不再需要一条条记录进行比较，而可以通过索引来减少比较，从而加速查询。这也就是平时我们在做关联查询的时候必须要求关联字段有索引的一个主要原因。
这种算法在链接查询的时候，驱动表会根据关联字段的索引进行查找，当在索引上找到了符合的值，再回表进行查询，也就是只有当匹配到索引以后才会进行回表。至于驱动表的选择，MySQL优化器一般情况下是会选择记录数少的作为驱动表，但是当SQL特别复杂的时候不排除会出现错误选择。
在索引嵌套链接的方式下，如果非驱动表的关联键是主键的话，这样来说性能就会非常的高，如果不是主键的话，关联起来如果返回的行数很多的话，效率就会特别的低，因为要多次的回表操作。先关联索引，然后根据二级索引的主键ID进行回表的操作。这样来说的话性能相对就会很差。
（3）Block Nested-Loop Join，实现如下：
在有索引的情况下，MySQL会尝试去使用Index Nested-Loop Join算法，在有些情况下，可能Join的列就是没有索引，那么这时MySQL的选择绝对不会是最先介绍的Simple Nested-Loop Join算法，而是会优先使用Block Nested-Loop Join的算法。
Block Nested-Loop Join对比Simple Nested-Loop Join多了一个中间处理的过程，也就是join buffer，使用join buffer将驱动表的查询JOIN相关列都给缓冲到了JOIN BUFFER当中，然后批量与非驱动表进行比较，这也来实现的话，可以将多次比较合并到一次，降低了非驱动表的访问频率。也就是只需要访问一次S表。这样来说的话，就不会出现多次访问非驱动表的情况了，也只有这种情况下才会访问join buffer。
在MySQL当中，我们可以通过参数join_buffer_size来设置join buffer的值，然后再进行操作。默认情况下join_buffer_size=256K，在查找的时候MySQL会将所有的需要的列缓存到join buffer当中，包括select的列，而不是仅仅只缓存关联列。在一个有N个JOIN关联的SQL当中会在执行时候分配N-1个join buffer。
上面介绍完了，下面看一下具体的列子
（1）全表JOIN
EXPLAIN SELECT * FROM comments gc JOIN comments_for gcf ON gc.comments_id=gcf.comments_id; 看一下输出信息：
可以看到在全表扫描的时候comments_for 作为了驱动表，此事因为关联字段是有索引的，所以对索引idx_commentsid进行了一个全索引扫描去匹配非驱动表comments ，每次能够匹配到一行。此时使用的就是Index Nested-Loop Join，通过索引进行了全表的匹配，我们可以看到因为comments_for 表的量级远小于comments ，所以说MySQL优先选择了小表comments_for 作为了驱动表。
（2）全表JOIN+筛选条件
SELECT * FROM comments gc JOIN comments_for gcf ON gc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e34efb1df98079186aaaa17b2e393a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3697aa211a44563b7321ebbea39324dc/" rel="bookmark">
			阅读笔记-GRAPHAF:A FLOW-BASED AUTOREGRESSIVE MODEL FOR MOLECULAR GRAPH GENERATION
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GRAPHAF:A FLOW-BASED AUTOREGRESSIVE MODEL FOR MOLECULAR GRAPH GENERATION 一、概要二、预备知识2.1 Autoregressive flow2.2 Graph Representation Learning 三、方法介绍3.1 GraphAF架构3.2 Efficient Parallel Training3.3 Validity Constrained Sampling3.4 Goal-Directed Molecule Generation with Reinforcement Learning 四、实验4.1 实验设置4.2 Numerical Results 文章链接
一、概要 设计具有所需特性的新型分子结构是诸如药物发现和材料科学等各种应用中的基本问题。.由于化学空间本质上是离散的，整个搜索空间是巨大的，大概有 1 0 33 10^{33} 1033这么大，所以这个问题是非常具有挑战性的。由于这些领域中的大量数据，机器学习技术在分子设计中看到了巨大的机遇。近年来，人们越来越致力于开发能够自动生成化学有效分子结构并优化其性质的机器学习算法。
对于自回归模型作者也有论述：自回归模型的迭代性质允许在生成过程中有效利用化学规则进行化合价检查，因此这些模型生成的有效分子的比例非常高。 但是，由于顺序生成的性质，训练过程通常很慢。 GraphAF方法具有像自动回归模型（从潜在空间到观察空间的映射）这样的迭代生成过程的优势，同时可以计算与前馈神经网络（从观察空间到潜在空间的映射）相对应的精确似然性。 通过并行计算有效地进行。
二、预备知识 2.1 Autoregressive flow \;\;\;\;\;\; N o r m a l i z i n g f l o w \mathbf{Normalizing \;\;flow} Normalizingflow为从基本分布 E \mathcal E E（可以是高斯分布）映射到真实世界可以观测到的空间 Z \mathcal Z Z（比如图片或者语音）的一个参数化的可逆的确定性变换。即： ϵ ∼ p E ( ϵ ) \epsilon\sim p_{\mathcal E}(\epsilon) ϵ∼pE​(ϵ)是基础分布，而 f : E → Z f:\mathcal E\to\mathcal Z f:E→Z是一个可逆变换。则真实世界中的分布 p Z ( z ) p_{\mathbf Z}(z) pZ​(z)可由如下公式计算：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3697aa211a44563b7321ebbea39324dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b37e25318ba2bc3562d512d161c1265/" rel="bookmark">
			遥感影像的纹理特征计算（基于ENVI和Python实践）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 纹理特征计算的一些方法 1、主要有四大类：统计方法、信号处理方法、模型方法和结构方法 2、灰度共生矩阵的概念 在水平方向也就是0方向，0-0有共计4个；0-1共计2个
3、灰度共生矩阵计算的结果 4、灰度共生矩阵的影响因素 5、ENVI的实践 滑动窗口大小为3*3，窗口移动距离为1，量化的灰度级是64。计算的结果有均值、方差、同质性、对比度、差异、熵、二阶矩和相关性。
![
基于python代码的实现过程 1、将遥感影像做灰度化出处理 2、遥感影像的灰度级降级 3、滑动窗口进行滑动 4、计算统计量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752905eff0f8d13b45384d8a418996ab/" rel="bookmark">
			Android Framework 常见解决方案（04）禁止锁屏 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 原理
在SettingsProvider中进行 默认选项的配置
2 解决方案（Android O P Q）
在文件 frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中做如下修改：
&lt;string name="def_trusted_sound" translatable="false"&gt;/system/media/audio/ui/Trusted.ogg&lt;/string&gt; &lt;string name="def_wireless_charging_started_sound" translatable="false"&gt;/system/media/audio/ui/WirelessChargingStarted.ogg&lt;/string&gt; - &lt;bool name="def_lockscreen_disabled"&gt;false&lt;/bool&gt; + &lt;bool name="def_lockscreen_disabled"&gt;true&lt;/bool&gt; &lt;bool name="def_device_provisioned"&gt;false&lt;/bool&gt; &lt;integer name="def_dock_audio_media_enabled"&gt;1&lt;/integer&gt; 在文件 frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java 中做如下修改：
@@ -2419,7 +2419,7 @@ class DatabaseHelper extends SQLiteOpenHelper { loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD, R.bool.def_accessibility_speak_password); - if (SystemProperties.getBoolean("ro.lockscreen.disable.default", false) == true) { + if (SystemProperties.getBoolean("ro.lockscreen.disable.default", true) == true) { loadSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, "1"); } else { loadBooleanSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd388eda209d33e1075058de6580eb7d/" rel="bookmark">
			PUT和POST方法的区别-比较POST和PUT方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PUT vs POST - Comparing HTTP MethodsPUT vs POST2. PUT方法做了什么？3. POST方法做了什么？4. 何时使用？ PUT vs POST - Comparing HTTP Methods PUT vs POST 存在各种各样的HTTP方法，每个方法用于不同的目的。最常用的HTTP方法是GET方法，用于从web服务器检索数据。例如，如果要从特定网站加载图像，浏览器将使用以下命令向web服务器发出请求：
GET https://website.com/path/to/image.jpg 然而，除了GET请求以外，还有其它类型的 http 方法，如下：
HEADPOSTPUTDELETECONNECTOPTIONSTRACE 其中有两种方法在使用时我们经常会感到困惑，何时该用哪一个。这两个方法就是PUT和POST。在这篇文章中，我们将具体地讨论PUT和POST的区别以及我们应该如何正确地使用每个方法。
2. PUT方法做了什么？ PUT方法将会完全地替代目标URL下的资源，不论目标URL下是否存在资源。使用这个方法，你可以创建一个全新的资源或覆盖有一个已经存在的资源，前提是您知道确切的请求URI。使用PUT方法创建新资源的示例如下：
PUT /forums/&lt;new_thread&gt; HTTP/2.0 Host: yourwebsite.com 其中&lt;new_thread&gt;是线程的实际名称或ID号。或者，用于覆盖现有资源的PUT方法可以如下所示：
PUT /forums/&lt;existing_thread&gt; HTTP/2.0 Host: yourwebsite.com 简而言之，PUT方法用于创建或覆盖浏览器认识的指定URL下的资源。
3. POST方法做了什么？ POST方法用于发送用户生成的数据发送到web服务器。比如说，当一个用户对论坛进行了评论或者上传了头像，这时候就应该使用POST方法。如果您不知道新创建的资源应该驻留在哪里，没有确定的URL，那么也应该使用POST方法。换言之，如果创建了一个新的论坛线程，并且没有指定线程路径，那么您可以使用如下所示：
POST /forums HTTP/2.0 Host: yourwebsite.com 使用此方法，源服务器将会返回URL path，您将收到类似以下内容的响应：
HTTP/2.0 201 Created Location: /forums/&lt;new_thread&gt; 总之，POST方法应该用于创建一个下级（或者说孩子）资源的标识，通过请求URI。在上面的例子中，根据源定义，请求URI 是/forums以及下级或孩子应该是 &lt;new_thread&gt;
4. 何时使用？ 当您知道要创建或覆盖的内容的URL时，应该使用PUT方法。当您只知道要创建内容的对象的类别或子部分的URL，请使用POST方法。 文章来自一篇国外的博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4cf21e1f4cbf9b29c6beb0e28f6ed2c/" rel="bookmark">
			逻辑同或，逻辑异或，逻辑与，逻辑或
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、逻辑异或 真⊕假=真
假⊕真=真
假⊕假=假
真⊕真=假
或者为：
True ⊕ False = True
False ⊕ True = True
False ⊕ False = False
True ⊕ True = False
二、逻辑同或 相同为一，不同为零。
三、逻辑与 1.逻辑与&amp;&amp;
表示逻辑与的意思，即为and。当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
2.按位与&amp;
按位运算指的是把字符变成二进制然后按位运算。
例：
15&amp;127为什么等于15？
15二进制： （0000 1111）
127二进制： （1111 1111）
按位与自然就是（0000 1111）=15
四、逻辑或 0 || 0 = 0;
1 || 0 = 1;
0 || 1 = 1;
1 || 1 = 1;
真值表：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7525bf4453c5ceb893794eefbd11a62/" rel="bookmark">
			实现Easy IoT配置以及实现Easy IoT上mqtt消息的通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的及要求 【实验一】实现Easy IoT配置。
【实验二】实现Easy IoT上mqtt消息的通讯。
二、实验原理与内容 实现mind+下Easy IoT上mqtt消息的通讯。
三、实验软硬件环境 硬件：掌控板
软件：Mind+
四、实验过程（实验步骤、记录、数据、分析） 1.在http://iot.dfrobot.com.cn上注册账户，注册成功后点击工作间，并点击添加新设备
2.在Mind+中先连接WIFI，再连接MQTT（MQTT是基于客户端-服务器的消息发布/订阅传输协议）
（1）设置按“A”时连接WIFI，若连接成功便在显示器第一行显示“WiFi连接成功”；
（2）设置按“B”时连接MQTT，连接MQTT的过程：
①初始化MQTT，填写账户所给的lot_id及lot_pwd，以及添加的两个设备的topic；
②MQTT发起连接；
③若MQTT连接成功，则“1”灯亮起且屏幕第二行显示“MQTT连接成功”，与此同时，如果接受到Topic_0发来的消息，显示在屏幕的第三行，并且回复消息至Topic_1中，并将回复的内容显示在第四行。
3.在Mind+中的运行：
// 主程序开始 void setup() { mPython.begin(); myIot.setMqttCallback(msgHandles); } void loop() { while (!(buttonA.isPressed())) {yield();} myIot.wifiConnect("dyj", "12345678"); while (!myIot.wifiStatus()) {yield();} display.setCursorLine(1); display.printLine("Wifi连接成功"); if ((buttonB.isPressed())) { myIot.init("iot.dfrobot.com.cn","KL7o5mFMR","","FL7TcmKGgz",topics,1883); myIot.connect(); while (!myIot.connected()) {yield();} rgb.write(1, 0xFF0000); display.setCursorLine(2); display.printLine("MQTT连接成功"); } } 并发线程：
// 事件回调函数 void obloqMqttEventT0(String&amp; message) { display.setCursorLine(3); display.printLine(message); myIot.publish(topic_1, "I'm fine"); rgb.write(2, 0x33CC00); } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7525bf4453c5ceb893794eefbd11a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eaced630b83e660c9fd91d222ecf148/" rel="bookmark">
			react中如何修改state值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据State类型 更新
当状态发生变化时，如何创建新的状态？根据状态的类型，可以分成三种情况：
1、 状态的类型是不可变类型（数字，字符串，布尔值，null， undefined）
这种情况最简单，直接给要修改的状态赋一个新值即可
//原state this.state = { count: 0, title : 'React', success:false } //改变state this.setState({ count: 1, title: 'bty', success: true }) 2、 状态的类型是数组
数组是一个引用，React 执行 diff 算法时比较的是两个引用，而不是引用的对象。所以直接修改原对象，引用值不发生改变的话，React 不会重新渲染。因此，修改状态的数组或对象时，要返回一个新的数组或对象。
（1）增加
如有一个数组类型的状态books，当向books中增加一本书(chinese)时，使用数组的concat方法或ES6的数组扩展语法
// 方法一：将state先赋值给另外的变量，然后使用concat创建新数组 let books = this.state.books; this.setState({ books: books.concat(['chinese']) }) // 方法二：使用preState、concat创建新数组 this.setState(preState =&gt; ({ books: preState.books.concat(['chinese']) })) // 方法三：ES6 spread syntax this.setState(preState =&gt; ({ books: [...preState.books, 'chinese'] })) （2）截取
当从books中截取部分元素作为新状态时，使用数组的slice方法：
// 方法一：将state先赋值给另外的变量，然后使用slice创建新数组 let books = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eaced630b83e660c9fd91d222ecf148/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72adc2a3d3a00deb965edea917d02eb/" rel="bookmark">
			u-boot配置与编译、kernel的裁剪添加移植、busybox根文件系统的制作等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.裸机... 3
1.1裸机烧写系统... 3
1.2裸机启动流程分析... 3
1.2.1 BL0：... 3
1.2.2 BL1：... 4
1.2.3 BL2：... 4
1.3那么裸机怎么启动呢：编写裸机代码，比如说让灯亮... 4
2.uboot基本使用... 5
2.1uboot文件目录介绍... 5
2.2uboot的启动方式... 6
2.3uboot编译烧写... 6
2.4uboot的基本命令... 7
2.5Bootloader 启动的两个阶段... 8
3. linux内核... 8
3.1内核功能：... 8
3.2linux目录介绍... 8
3.3内核编译/烧写过程... 9
4.文件系统... 10
4.1介绍：... 10
4.2 搭建一个文件系统：... 11
5.NFS文件系统服务的搭建... 14
5.1 NFS概念：... 14
5.2工作原理：... 14
5.3 NFS服务的搭建... 14
5.4 NFS服务的测试... 16
6.内核模块化编程... 16
6.1 模块化介绍... 16
6.2 静态编译到内核步骤：比如说写个led的驱动... 16
6.3 动态编译到内核的步骤：.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72adc2a3d3a00deb965edea917d02eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177fa85907831f00d03f117b2a8fd75e/" rel="bookmark">
			数据结构(python) —— 【15: NB三人组小结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快速、堆、归并排序小结 之前讲了Low B三人组，然后最近又讲了NB三人组的快速排序、堆排序和归并排序。
数据结构(python) —— 【08排序: 快速排序】
数据结构(python) —— 【11: 堆排序】
数据结构(python) —— 【14: 归并排序】
其中堆排序可能比较难理解，需要花费更多时间去结合图文进行理解。今天来把这三个排序进行小结一下。
三种排序算法的时间复杂度都是O(nlog(n))
一般情况下，就运行时间而言:
快速排序 &lt; 归并排序 &lt; 堆排序
三种排序算法的缺点:
快速排序: 极端情况下，排序效率低
归并排序: 需要额外的内存开销
堆排序: 在快的排序算法中较慢
排序方法时间复杂度空间复杂度稳定性代码复杂度最坏情况 平均情况 最好情况 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 简单 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 简单 插入排序 O(n^2) O(n^2) O(n^2) O(1) 稳定 简单 快速排序 O(n^2) O(nlogn) O(nlogn) 平均情况O(logn);最坏情况O(n) 不稳定 较复杂 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 复杂 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 较复杂 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ee4d63ff50a247d32924199afa4be7/" rel="bookmark">
			HBase快速入门系列 （九）| HBase 的实战案例（微博）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HBase实战之谷粒微博需求分析表的分类1.微博内容表2.用户关系表3.微博收件箱表 代码实现1.代码设计总览：2. 环境搭建3.创建命名空间以及表名的定义4.设置一个工具类，在工具类里面将命名空间和表的参数设置好方便后续调用5.写好相应的业务需求方便测试调用6.最后进入测试方法，展示需求 HBase实战之谷粒微博 需求分析 微博内容的浏览，数据库表设计
用户社交体现：关注用户，取关用户
拉取关注的人的微博内容
表的分类 1.微博内容表 表结构：
方法名creatTableeContentTable Nameweibo:contentRowKey用户 ID_时间戳ColumnFamilyinfoColumnLabel标题,内容,图片Version1 个版本 2.用户关系表 表结构：
方法名createTableRelationsTable Nameweibo:relationRowKey用户 IDColumnFamilyattends、fansColumnLabel关注用户 ID，粉丝用户 IDColumnValue用户 IDVersion1 个版本 3.微博收件箱表 表结构：
方法名createTableReceiveContentEmailsTable Nameweibo:inboxRowKey用户 IDColumnFamilyinfoColumnLabel用户 IDColumnValue取微博内容的 RowKeyVersion2 代码实现 1.代码设计总览： 创建命名空间以及表名的定义
创建微博内容表
创建用户关系表
创建用户微博内容接收邮件表
发布微博内容
添加关注用户
移除（取关）用户
获取关注的人的微博内容
测试
2. 环境搭建 1.pom文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;Hadoop&lt;/artifactId&gt; &lt;groupId&gt;com.huan&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;guli-weibo&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-server&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ee4d63ff50a247d32924199afa4be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97961e343d1a4205d684e61797d2e46/" rel="bookmark">
			wm_paint重绘图像_如何在Windows 10上使用Paint 3D调整图像大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wm_paint重绘图像
If you need to perform a simple task like resizing an image on your Windows 10 PC, you don’t need to use software with a steep learning curve like Photoshop. You can do it using Microsoft Paint 3D. Here’s how it’s done.
如果您需要执行简单的任务(例如在Windows 10 PC上调整图像大小)，则无需使用学习曲线陡峭的软件，例如Photoshop。 您可以使用Microsoft Paint 3D来完成 。 这是完成的过程。 Open Paint 3D on your computer by typing “Paint 3D” in the Windows Search bar and selecting “Paint 3D” from the search results.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a97961e343d1a4205d684e61797d2e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b84a27b8bc9ff9f861b0c4e6809f598/" rel="bookmark">
			这就是你日日夜夜想要的docker！！！---------Harbor私有仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Harbor私有仓库介绍1、什么是Harbor？有什么作用？2、harbor的特性3、harbor配置文件参数 二、部署Harbor私有仓库1、harbor服务器安装harbor2、查看已经生成的镜像和容器3、测试4、harbor服务器字符界面镜像仓库测试5、client客户端harbor仓库测试 三、harbor仓库的维护管理1、Harbor.cfg配置文件2、在客户端对镜像进行管理3、迁移harbor数据 一、Harbor私有仓库介绍 1、什么是Harbor？有什么作用？ 是多个容器同时跑起来的服务 所以必须要装docker compose
Harbor是VMware公司的开源级的企业级DockerRegistry(仓库)项目，项目地址为 https://github.com/vmware/harbor.
Harbor的目标是帮助用户迅速搭建一个企业级的DockerRegistry服务。
Harbor以docker公司开源的registry为基础，提供了管理UI，基于角色的访问控制（Role Based Access Control），AD/LDAP集成，以及审计日志（Auditlogging）等企业用户需求的功能，同时还原生支持中文。
Harbor的每个组件都是以Docker容器的形式构建的，使用docker-compose来对它进行部署。用于部署Harbor的docker-compose模板位于/usr/local/bin/harbor/docker-compose.yml(自定义)
2、harbor的特性 1、基于角色控制：用户与Docker镜像仓库通过"项目"进行组织管理,一个用户可以对多个镜像仓库在统一命名空间(projec)里有不同的权限
2、图形化用户界面：用户可以通过浏览器来浏览,检索当前Docker镜像仓库,管理项目和命名空间
3、审计管理：所有这怒地镜像仓库的错都可以被记录追溯，用于审计管理
4、基于镜像的复制策略：镜像可以在多个Harbor实例之间进行复制。
5、支持LDAP认证：Harbor的用户授权可以使用已经存在的用户。
6、镜像删除和垃圾回收：image可以被删除并且回收image占用的空间。
7、简单的部署功能：harbor提供了online、offline安装，此外还提供了virtualappliance安装
8、harbor和docker registry的关系：harbor实质上是对docker registry做了封装，扩展了自己的业务模板。
3、harbor配置文件参数 vim /usr/local/harbor/harbor.cfg，关于 Harbor.cfg 配置文件中有两类参数：所需参数和可选参数
1、所需参数：这些参数需要在配置文件 Harbor.cfg 中设置。如果用户更新它们并运行 install.sh脚本重新安装 Harbour，参数将生效。具体参数如下：
hostname：用于访问用户界面和 register 服务。它应该是目标机器的 IP 地址或完全限 定的域名（FQDN），例如 192.168.195.128 或 hub.kgc.cn。不要使用 localhost 或 127.0.0.1 为主机名。 ui_url_protocol：（http 或 https，默认为 http）用于访问 UI 和令牌/通知服务的协议。如果公证处于启用状态，则此参数必须为 https。 max_job_workers：镜像复制作业线程。 db_password：用于db_auth 的MySQL数据库root 用户的密码。 customize_crt：该属性可设置为打开或关闭，默认打开。打开此属性时，准备脚本创建私钥和根证书，用于生成/验证注册表令牌。 当由外部来源提供密钥和根证书时，将此属性设置为 off。 ssl_cert：SSL 证书的路径，仅当协议设置为 https 时才应用。 secretkey_path：用于在复制策略中加密或解密远程 register 密码的密钥路径。 2、可选参数：这些参数对于更新是可选的，即用户可以将其保留为默认值，并在启动 Harbor 后在 Web UI 上进行更新。如果进入 Harbor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b84a27b8bc9ff9f861b0c4e6809f598/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/205/">«</a>
	<span class="pagination__item pagination__item--current">206/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/207/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>