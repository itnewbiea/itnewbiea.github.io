<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8adca207086288e4f16938d7edf51ef/" rel="bookmark">
			用Python实现开心消消乐小游戏，简直太好玩啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提到开心消消乐这款小游戏，相信大家都不陌生，其曾在 2015 年获得过玩家最喜爱的移动单机游戏奖，受欢迎程度可见一斑，本文我们使用 Python 来做个简单的消消乐小游戏。
实现 消消乐的构成主要包括三部分：游戏主体、计分器、计时器，下面来看一下具体实现。
定义一些常量，比如：窗口宽高、网格行列数等，代码如下：
接着创建一个主窗口，代码如下：
看一下效果：
再接着在窗口中画一个 8 x 8 的网格，代码如下：
看一下效果：
再接着在网格中随机放入各种拼图块，代码如下：
看一下效果：
再接着加入计分器和计时器，代码如下：
看一下效果：
当设置的游戏时间用尽时，我们可以生成一些提示信息，代码如下：
看一下效果：
说完了游戏图形化界面相关的部分，我们再看一下游戏的主要处理逻辑。
我们通过鼠标来操纵拼图块，因此程序需要检查有无拼图块被选中，代码实现如下：
我们需要将鼠标连续选择的拼图块进行位置交换，代码实现如下：
每一次交换拼图块时，我们需要判断是否有连续一样的三个及以上拼图块，代码实现如下：
当出现三个及以上拼图块时，需要将这些拼图块消除，代码实现如下：
将匹配的拼图块消除之后，我们还需要随机生成新的拼图块，代码实现如下：
之后反复执行这个过程，直至耗尽游戏时间，游戏结束。
最后，我们动态看一下游戏效果。
总结
本文我们使用 Python 实现了一个简单的消消乐游戏，有兴趣的可以对游戏做进一步扩展，比如增加关卡等。
感兴趣的小伙伴，完整Python小游戏开心消消乐 Python代码免费分享，具体看下方。
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
工具都帮大家整理好了，安装就可直接上手！
三、最新Python学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、面试宝典
简历模板
若有侵权，请联系删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f50d818ff5752569996e6e65e0c8a0/" rel="bookmark">
			HTML中的自适应布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、两列布局
二、三列布局
三、自适应布局
前言 自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。
一、两列布局 左侧定宽右侧自适应
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .left{ background-color: red; width: 300px; float: left; } .right{ background-color: blue; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="left"&gt;左侧定宽&lt;/div&gt; &lt;div class="right"&gt; 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 浏览器运行结果如下：
二、三列布局 左右定宽 中间自适应
利用浮动将左右浮动起来中间定高，宽度自适应实现三列布局
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f50d818ff5752569996e6e65e0c8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/641a9f5e92762e91b58ed4cc470434d1/" rel="bookmark">
			室内定位-uwb数据集分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集包括：
数据集包含4个不同室内环境的测量数据,每个环境有8个固定的锚点设备和1个移动的定位设备。
在每个环境中,预先定义了一个人行走路径,并在路径上均匀取样获得定位设备的位置。在每个位置上,收集了定位设备与每个锚点之间的多次测距和信道冲激响应(CIR)数据。
一共收集了4个环境约120万组测量数据。数据经过预处理去除异常值后以Json格式提供。
技术验证部分分析了CIR、测距误差分布等,说明数据集质量良好,可用于研发基于测距的室内定位和跟踪算法。
提供了代码库,可以重现技术验证部分的结果,也可以基于该数据集开发定位算法。
总体来说,本数据集提供了高质量的UWB室内定位実测数据,对开发和评估UWB定位算法具有重要的参考价值。
原文
Indoor UWB Positioning and Position Tracking Data Set
下载地址
https://github.com/KlemenBr/uwb_positioning
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6a8deb17740112fbeee5413b1369f2/" rel="bookmark">
			android studio安卓模拟器启动了但是看不到画面解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你使用android studio开发软件的时候，可能会遇到这个问题，就是当你点击下拉框中的启动模拟器的时候，看着程序是启动了，并且运行了，但是看不到模拟器界面，如下图：
这个时候，就要停止项目和模拟器，然后单独点击模拟器的启动按钮来启动，然后再启动程序：
点完之后，就会立马弹出一个模拟器的窗口：
然后再选中这个模拟器，点击运行项目：就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8738166dbb758452e3cc022eb0a95ca5/" rel="bookmark">
			Spring-声明式事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目录
文章目录
前言
一 . 声明式事务概念
1.1 编程式事务
1.2 声明式事务
1.3 spring事务管理器
二 . 基于注解的声明式事务
事务属性: 只读
事务属性: 超时时间
事务属性: 事务异常
事务属性: 事务隔离级别
事务属性: 事务的传播行为
前言 大家好,今天给大家介绍一下spring-tx的相关内容
一 . 声明式事务概念 1.1 编程式事务 编程式事务指手动编写代码来管理事务,即通过编码的方式来控制事务的提交和回滚。
编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。
Connection conn = ...;
try {
// 开启事务：关闭事务的自动提交
conn.setAutoCommit(false);
// 核心操作
// 业务代码
// 提交事务
conn.commit();
}catch(Exception e){
// 回滚事务
conn.rollBack();
}finally{
// 释放数据库连接
conn.close();
}
1.2 声明式事务 声明式事务是通过使用注解或配置文件的方式来实现事务管理的方式。在声明式事务中，开发人员只需要在需要进行事务管理的方法或类上添加相应的注解或配置，由事务管理框架来自动处理事务的开始、提交或回滚。这种方式使得代码更加简洁和易于维护，开发人员无需关注事务管理的细节，只需专注于业务逻辑的编写。
总的来说，编程式事务需要开发人员手动管理事务的细节，适用于对事务管理有较深了解且需要更细粒度控制的场景；而声明式事务通过注解或配置的方式来实现事务管理，减少了开发人员的工作量，适用于简单的事务管理场景。
1.3 spring事务管理器 spring声明式事务管理器对应接口
DataSourceTransactionManager类中的主要方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8738166dbb758452e3cc022eb0a95ca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c699449e07b95c4afaf8fbcc1c0f70f/" rel="bookmark">
			启用NTP服务解决Linux系统时间与北京时间不同步问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
1、服务器的Linux版本为Linux version 4.18.0-348.7.1.el8_5.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)) #1 SMP Wed Dec 22 13:25:12 UTC 2021
2、NTP即Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟。timedatectl实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器。
二、问题
服务器的系统时间与北京时间不一致，略快两分钟
三、解决方法
1、使用timedatectl命令发现NTP服务未激活，系统无法进行时间同步
2、启用NTP服务：timedatectl set-ntp yes
可以看到NTP服务已激活，系统时间也与当前北京时间一致了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4a3dd2b0f236bcaaa41074aa5d0243/" rel="bookmark">
			苹果IOS系统webglcontextlost问题-解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
在IOS手机 解码视频流的时候，第一次可以正常播放，但只要IOS手机熄屏，再重新唤醒，就会一直播放失败，无论换哪个浏览器都不行。安卓手机则一切正常。
经过排查，发现 IOS手机 的浏览器会无故 webGL 的上下文对象，然后引发一些奇怪的问题。
webglcontextlost 可能会导致 以下几个现象，可以参考一下。
解决方案 在文章最后贴出来。
导致的现象1 TypeError: Argument 1 ('shader') to WebGLRenderingContext.shader Source must be an instance of WebGLShader....（如下图）
导致的现象2 导致 gl.createShader(x) 返回结果变为 null
导致的现象3 RuntimeError: Out of bounds memory access (evaluating 'ee. Decode(n,o)')....
排查
以上几种现象，都可能是 webglcontextlost 引起的（我是说可能），如何判断呢？其实只要监听一下这个事件即可，代码如下：
const canvas = document.getElementById('canvas'); canvas.addEventListener("webglcontextlost", () =&gt; { console.log("webglcontextlost") }, false); 如果控制台输出字符串 webglcontextlost，那么恭喜中招，建议先解决这个问题。
可以看到，在苹果官网，很多人提到了同样的问题，看来是官方的锅（咱们不背）。
解决方案
既然是官方的锅，解决方案 自然是升级 IOS 系统版本（升级到17.1），搞定。
升级完测了一下，果然可以正常播放了。再次 熄屏 -&gt; 唤醒 也可以正常播放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b4a3dd2b0f236bcaaa41074aa5d0243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f3f62c081259def1a10030f445d340/" rel="bookmark">
			python计算地址相似度以及抽取省市区信息的库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 平时工作上会经常处理地理数据上关于地址地名的相似度计算，或者从地址中抽取省市区信息的内容，所以记录一下一些好用的python库。
[MGeo应用]使用AI模型比较地址相似度 # pip install cryptography # pip install "modelscope[nlp]" -f https://modelscope.oss-cn-beijing.aliyuncs.com/releases/repo.html from modelscope.pipelines import pipeline from modelscope.utils.constant import Tasks /opt/conda/envs/torch_nlp/lib/python3.8/site-packages/tqdm/auto.py:22: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html from .autonotebook import tqdm as notebook_tqdm 2023-11-03 11:06:46,720 - modelscope - INFO - PyTorch version 1.12.0 Found. 2023-11-03 11:06:46,722 - modelscope - INFO - TensorFlow version 2.13.1 Found. 2023-11-03 11:06:46,723 - modelscope - INFO - Loading ast index from /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6f3f62c081259def1a10030f445d340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0de1699a518b4e1d918288747ced47f/" rel="bookmark">
			源码分析 Flutter 的 setState 过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇我们对比了 setState 和 ModelBinding这两种状态管理的区别，从结果来看，setState 的方式的性能明显低于 ModelBinding 这种使用 InheritedWidget 的方式。这是因为 setState的时候，不管子组件有没有依赖状态数据，都会蒋全部子组件移除后重建。那么 setState 这个过程做了什么事情，会导致这样的结果呢？本篇我们通过 Flutter 的源码来分析一下 setState 的过程。
setState 的定义 我们先来看 setState 的定义，setState 定义在State&lt;T extends StatefulWidget&gt; with Diagnosticable这个类中，也就是 StatefulWidget或其子类的状态类。方法体代码不多，在执行业务代码做了一些异常处理，具体的代码我们不贴了，主要是做了如下处理：
传给setState 的回调方法不能为空。生命周期校验：组件已经从组件树移除的时候会被 dispose 掉，因此不能在 dispose 后调用 setState。通常这会发生在定时器、动画或异步回调的过程中。这样的调用可能会导致内存泄露。在 created 阶段和没有装载阶段（mounted）不可以调用 setState，也就是不能在构造函数里调用 setState。通常应该在 initState 之后调用 setState。setState 的回调方法不能返回 Future 对象，也就是不能在 setState中执行异步操作，只能是同步操作。如果要执行异步操作应该咋 setState 之外进行调用。 @protected void setState(VoidCallback fn) { // 省略异常处理代码 _element!.markNeedsBuild(); } 最为关键的就一行代码：_element!.markNeedsBuild()，从函数名称来看就是标记元素需要构建。那么这个_element 又是从哪来的？继续挖！
Element 是什么？ 我们来看_element 的定义，_element 是一个 StatefulElement 对象，实际上，我们还发现，在获取BuildContext的时候，返回的也是_element。在获取 BuildContext 的时候注释是这么说的：
The location in the tree where this widget builds ——widget构建的渲染树的具体位置。 BuildContext 是一个抽象类，因此可以推断出 StatefulElement 实际上是其接口实现类或子类。往上溯源，发现整个的类层级是下面这样的，其中 Element、ComponentElement 都是抽象类，而 markNeedsBuild 方法是在 Element 抽象类定义的。而对于 Element，官方的定义为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0de1699a518b4e1d918288747ced47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd6e9f9c5d6f932a944f5fa34f91cbb/" rel="bookmark">
			cdn方式引入element-plus icon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、cdn方式使用element-plus的icon 1、首先引入 vue3 element-plus 还有 element-plus icon js包 &lt;script src="{$Think.HTML_STATIC}/xxx/vue/dist/vue.global.js"&gt;&lt;/script&gt; &lt;link href="{$Think.HTML_STATIC}/xxx/element-plus/dist/index.css" rel="stylesheet"&gt; &lt;script src="{$Think.HTML_STATIC}/xxx/element-plus/dist/index.full.js"&gt;&lt;/script&gt; &lt;script src="{$Think.HTML_STATIC}/xxx/element-plus/dist/index.iife.min.js"&gt;&lt;/script&gt; &lt;script src="{$Think.HTML_STATIC}/xxxx/element-plus/es/locale/lang/zh-cn.js"&gt;&lt;/script&gt; 2、声明vue3的一些公共方法 // 此页面为Vue3 不熟悉Vue3禁止复制粘贴使用 // ref 函数可以接收一个简单类型的值，返回一个可改变的 ref 响应式对象，从而弥补reactive函数不支持简单类型的问题 // reactive和ref函数都可以提供响应式数据的转换，具体什么时候需要使用哪个API社区还没有最佳实践，大家暂时可以使用自己熟练的API进行转换 // 推荐一种写法：只有我们明确知道要转换的对象内部的字段名称我们才使用reactive，否则就一律使用ref，从而降低在语法选择上的心智负担 // 公共写法 start const ref = Vue.ref; const reactive = Vue.reactive; const toRefs = Vue.toRefs; const ElMessage = ElementPlus.ElMessage const baseUrl = "/admin.php/xxxx"; // const ArrowRight = ElementPlusIconsVue.ArrowRight; // 公共写法end 3.在set up里面return出 //下面是setup const App = { setup() { // 传说中的setup Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd6e9f9c5d6f932a944f5fa34f91cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f87235f1510367f9c966140264783f/" rel="bookmark">
			【scss】样式用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var.scss 公共scss
@use "sass:math"; $base_vm: 1920; @function vm($px) { @return $px * 1px; } @mixin flex { display: flex; justify-content: center; align-items: center; } @mixin flex-start { display: flex; justify-content: flex-start; align-items: center; } @mixin flex-start-wrap { display: flex; justify-content: flex-start; align-items: center; flex-wrap: wrap; } @mixin flex-end { display: flex; justify-content: flex-end; align-items: center; } @mixin flex-between { display: flex; justify-content: space-between; align-items: center; } @mixin flex-stretch { display: flex; justify-content: stretch; align-items: center; } @mixin flex-col { display: flex; justify-content: center; align-items: center; flex-direction: column; } @mixin flex-col-start { display: flex; justify-content: flex-start; align-items: center; flex-direction: column; } @mixin flex-col-between { display: flex; justify-content: space-between; align-items: center; flex-direction: column; } @mixin hover-highlight { transition: filter 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f87235f1510367f9c966140264783f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6877811104ddc76c95772e0dabe279db/" rel="bookmark">
			STM32中微秒延时的实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32中微秒延时的实现方式 0.前言一、裸机实现方式二、FreeRTOS实现方式三、定时器实现（通用）4、总结 0.前言 最近在STM32驱动移植过程中需要用到微秒延时来实现一些外设的时序，由于网上找到的驱动方法良莠不齐，笔者在实现时序过程中也浪费了不少时间。这里就将笔者觉得比较好的几种方式记录一下，方便后续使用，也可以作为参考。
一、裸机实现方式 在STM32的裸机程序中，实现微秒延时比较简单，通过SysTick计时即可。关于SysTick的相关知识可以站内搜索，这里就不再过多赘述了，相关的delay_us函数参考了正点原子例程中的实现方式：
// 注意:nus的值,不要大于798915us(最大值即2^24/fac_us {fac_us=21}) void delay_us(uint32_t nus) { uint32_t temp; SysTick-&gt;LOAD = nus * fac_us; // 时间加载，fac_us与时钟频率有关，例如：168Mhz时 // fac_us=168，168/168M=1us SysTick-&gt;VAL = 0x00; // 清空计数器 SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk; // 开始倒数 do { temp = SysTick-&gt;CTRL; // 读取控制及状态寄存器的值 } while ((temp &amp; 0x01) &amp;&amp; !(temp &amp; (1 &lt;&lt; 16))); // 等待时间到达，使能且位16为0（未计到0） SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk; // 关闭计数器 SysTick-&gt;VAL = 0X00; // 清空计数器 } 步骤：
1、根据延时时间和定时器所选时钟频率，计算出定时器要计数的时间数值；
2、将该数值加载到重装载寄存器中；
3、将当前值寄存器清零，打开定时器开始计数；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6877811104ddc76c95772e0dabe279db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f488981326f841cfb53fd926bbf10ed/" rel="bookmark">
			elementui el-upload 上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Html2.上传 总结 前言 在使用element中的el-upload上传文件或者图片时，需要先把el-upload的自动上传改为手动上传:auto-upload=“false”然后el-upload内部会调用this.$refs.upload.submit();方法，从而实现多个文件上传。
提示：以下是本篇文章正文内容，下面案例可供参考
一、Html &lt;el-upload class="upload-demo" ref="uploadKpem" :http-request="onUploadKpem" action="" :on-preview="handlePreviewKpem" :on-remove="handleRemoveKpem" :file-list="fileListKpem" :auto-upload="false" accept=".pem" :limit="1"&gt; &lt;el-button slot="trigger" type="primary"&gt;文件选择&lt;/el-button&gt; &lt;el-button style="margin-left: 10px" type="primary" plain @click="submitUploadKpem()"&gt;确认上传&lt;/el-button&gt; &lt;/el-upload&gt; data(){ return { fileListKpem: [], } } 2.上传 代码如下（示例）：
//选择文件 async onUploadKpem(file) { let formData = new FormData(); formData.append("file", file.file); //文件上传需要的参数 file 和 token formData.append("token", this.token); let upKpem = await UploadFileKpem(formData); //UploadFileKpem 自己封装的接口 // console.log(upKpem,"上传") if(upKpem.code == 200){ .... }else{ .... } }, //点击上传 submitUploadKpem() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f488981326f841cfb53fd926bbf10ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4728f444b24839e3f80adf3829bcba9/" rel="bookmark">
			postgresql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pg中提取字符串中字段 SELECT (regexp_matches('{"newValue":"字数为15个字的用例自定义状态","oldKey":"0","fieldName":"statusName","newKey":"118","oldValue":"新建"}', '"oldKey":"([^"]*)"'))[1] AS old_key, (regexp_matches('{"newValue":"字数为15个字的用例自定义状态","oldKey":"0","fieldName":"statusName","newKey":"118","oldValue":"新建"}', '"fieldName":"([^"]*)"'))[1] AS field_name, (regexp_matches('{"newValue":"字数为15个字的用例自定义状态","oldKey":"0","fieldName":"statusName","newKey":"118","oldValue":"新建"}', '"oldValue":"([^"]*)"'))[1] AS old_value, (regexp_matches('{"newValue":"字数为15个字的用例自定义状态","oldKey":"0","fieldName":"statusName","newKey":"118","oldValue":"新建"}', '"newKey":"([^"]*)"'))[1] AS newKey, (regexp_matches('{"newValue":"字数为15个字的用例自定义状态","oldKey":"0","fieldName":"statusName","newKey":"118","oldValue":"新建"}', '"newValue":"([^"]*)"'))[1] AS newValue 查看进程 SELECT * FROM pg_stat_activity WHERE state = 'active' ; 一行转一列，类似侧视图功能 select regexp_split_to_table( '6992560,6992506,6992505,6992504,6992503,6992502,6992469,6992501,6992468,6992500,6992467,6992466,6992465,6992464,6992463,6992462,6992461,6992509,6992508,6992507,6992517,6992516,6992515,6992119,6992514,6992118,6992513,6992117,6992512,6992116,6992479,6992511,6992115,6992478,6992510,6992114,6992477,6992113,6992476,6992112,6992475,6992111,6992474,6992473,6992472,6992471,6992470,6992519,6992518,6992528,6992527,6992526,6992525,6992129,6992524,6992128,6992523,6992127,6992489,6992522,6992126,6992488,6992521,6992125,6992487,6992520,6992124,6992486,6992123,6992122,6992485,6992121,6992484,6992120,6992483,6992482,6992481,6992480,6992490,6992529,6992539,6992538,6992537,6992536,6992535,6992534,6992533,6992499,6992532,6992498,6992531,6992135,6992497,6992530,6992134,6992496,6992133,6992495,6992132,6992494,6992131,6992493,6992130,6992492,6992491,6992549,6992548,6992547,6992546,6992545,6992544,6992543,6992542,6992541,6992540,6992559,6992558,6992557,6992556,6992555,6992554,6992553,6992552,6992551,6992550' , ',') 一列转一行,需要分组(组内 一列转一行),不分组就是整列数据 类似hive中 select id,concat_ws(',',collect_list(name)) names from ts group by id; pg
WITH temp_table(id, num, name) AS ( VALUES (1, 'zs', '合肥'), (1, 'ls', '南京'), (1, 'ww', '杭州'), (1, 'zl', '重庆'), (1, 'sq', '郑州'), (2, 'wb', '六安'), (2, 'lq', '青岛'), (3, 'dd', '三亚'), (3, 'si', '常州'), (3, 'sh', '武汉') ) SELECT id,string_agg(name,',') FROM temp_table group by id; filter函数 select count(*) filter ( where date &gt;= to_date('2019-01-01','yyyy-MM-dd') and date &lt; to_date('2020-01-01','yyyy-MM-dd') ) ,count(*) filter (where date &gt;= to_date('2020-01-01','yyyy-MM-dd') and date &lt; to_date('2021-01-01','yyyy-MM-dd') ) ,count(*) filter (where date &gt;= to_date('2021-01-01','yyyy-MM-dd') ) from modeltest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4728f444b24839e3f80adf3829bcba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294d3f822f40289ae427250d52a05763/" rel="bookmark">
			Rocky9 上安装 redis-dump 和redis-load 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装依赖环境 1、依赖包 dnf -y install perl gcc gcc-c++ zlib-devel 2、编译openssl 1.X ### 下载编译 wget https://www.openssl.org/source/openssl-1.1.1t.tar.gz tar xf openssl-1.1.1t.tar.gz cd openssl-1.1.1t ./config --prefix=/usr/local/openssl make make install ### 配置库文件 echo "/usr/lib64" &gt;&gt; /etc/ld.so.conf &amp;&amp; ldconfig echo "/usr/local/openssl/lib" &gt;&gt; /etc/ld.so.conf &amp;&amp; ldconfig ### 添加至系统环境变量 echo "export PATH=/usr/local/openssl/bin:\$PATH" &gt;&gt; ~/.bashrc source ~/.bashrc 二、安装ruby ### 下载编译(https://www.ruby-lang.org/en/downloads/) wget https://cache.ruby-lang.org/pub/ruby/3.0/ruby-3.0.5.tar.gz #国外网站下载比较慢，可能连接不上 tar -zxvf ruby-3.0.5.tar.gz cd ruby-3.0.5 ./configure --prefix=/usr/local/ruby make make install ### 添加系统环境变量 echo "export PATH=/usr/local/openssl/bin:/usr/local/ruby/bin:\$PATH" &gt;&gt; ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/294d3f822f40289ae427250d52a05763/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27099bd691ee843bd2048cb8984d0242/" rel="bookmark">
			VirtualBox 中 Ubuntu 无法打开terminal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VirtualBox 中 Ubuntu 无法打开terminal 情况描述：解决方案 情况描述： 新安装的虚拟机无法打开TerminalUbuntu 环境中时间乱码 解决方案 CTRL + ALT + F3 # 进入命令行模式（需要返回桌面时CTRL + ALT + F1） cd /etc/default sudo nano locale # 把文件中的 “en_US” 改成 “en_US.UTF-8” # 保存退出 sudo locale-gen --purge reboot # 重启虚拟机 # 虚拟机- Vboxuser is not in the sudoers su root gedit /etc/sudoers 找到 “root ALL=(ALL) ALL”，在下面插入“vboxuser ALL=(ALL) ALL” exit 再次执行 sudo 命令，即可成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63adafd0047212eae74dc9207da80fc4/" rel="bookmark">
			Centos7 上安装 redis-dump 和redis-load 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、导入证书并安装依赖 1、安装GPG keys gpg2 --keyserver keyserver.ubuntu.com --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB curl -sSL http://rvm.io/mpapis.asc | gpg2 --import - curl -sSL http://rvm.io/pkuczynski.asc | gpg2 --import - 2、安装依赖包 [root@localhost ~]# yum install centos-release-scl-rh -y 二、安装ruby 说明： 需要安装的ruby版本必须在 2.7.5 以上，否则后面不能成功安装redis-dump和redis-load命令
#搜索要安装的 ruby 版本 [root@localhost ~]# yum search rh-ruby30 #安装ruby [root@localhost ~]# yum -y install rh-ruby30* #设置默认版本 [root@localhost ~]#scl enable rh-ruby30 bash #查看ruby版本 [root@localhost ~]# ruby -v ruby 3.0.2p107 (2021-07-07 revision 0db68f0233) [x86_64-linux] 三、替换gem源 #替换gem源，不建议用https [root@localhost ~]# gem sources --add http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63adafd0047212eae74dc9207da80fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2577eba99f14593549310d262e7c9e/" rel="bookmark">
			第3章 循环结构 《信息学奥赛一本通 编程启蒙》第30 -- 34课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 30课明确次数控制 [例 30.1] 平方根 信息学奥赛一本通-编程启蒙（C++版）在线评测系统
30.1_哔哩哔哩_bilibili
[例 30.2] 回家作业 信息学奥赛一本通-编程启蒙（C++版）在线评测系统
30.2_哔哩哔哩_bilibili
[例 30.3] 按要求计算输出 信息学奥赛一本通-编程启蒙（C++版）在线评测系统
30.3_哔哩哔哩_bilibili
练 30.1 鸡尾酒疗法 1072：鸡尾酒疗法 信息学奥赛一本通（C++版）在线评测系统
练 30.2 错误减法 信息学奥赛一本通-编程启蒙（C++版）在线评测系统
信奥刷题-错误的减法 信奥刷题-错误的减法_哔哩哔哩_bilibili
练30.3 奇偶分家 信息学奥赛一本通-编程启蒙（C++版）在线评测系统
PTA天梯赛 第26题 奇偶分家问题 PTA天梯赛 第26题 奇偶分家问题_哔哩哔哩_bilibili
奇偶分家 奇偶分家_哔哩哔哩_bilibili
奇偶分家_哔哩哔哩_bilibili
用C语言实现奇偶分家【一题一策】第四十期 用C语言实现奇偶分家【一题一策】第四十期_哔哩哔哩_bilibili
第 31课 统计 [例 31.1] 石头剪子布 1132：石头剪子布 信息学奥赛一本通（C++版）在线评测系统
31.1_哔哩哔哩_bilibili
[例 31.2] 证书等级 信息学奥赛一本通-编程启蒙（C++版）在线评测系统
31.2_哔哩哔哩_bilibili
[例 31.3] 正常血压 1076：正常血压 信息学奥赛一本通（C++版）在线评测系统
31.3_哔哩哔哩_bilibili
练 31.1 年龄与疾病 1106：年龄与疾病 信息学奥赛一本通（C++版）在线评测系统
教四年级小朋友学编程-【一维数组17】年龄与疾病 教四年级小朋友学编程-【一维数组17】年龄与疾病_哔哩哔哩_bilibili
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b2577eba99f14593549310d262e7c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1992b967e86ac2dce597e96f7703f897/" rel="bookmark">
			如何查询linux服务器网卡所接交换机端口的LLDP信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询是否有按照lldpad的软件包，如果没有需要yum install lldpad
[root@backupsvr ~]# rpm -qi lldpad
Name : lldpad
Version : 1.0.1
Release : 5.git036e314.el7
Architecture: x86_64
Install Date: Thu 13 Jul 2023 04:53:04 PM CST
Group : System Environment/Daemons
Size : 714887
License : GPLv2
Signature : RSA/SHA256, Fri 24 May 2019 10:07:40 PM CST, Key ID 199e2f91fd431d51
Source RPM : lldpad-1.0.1-5.git036e314.el7.src.rpm
Build Date : Wed 27 Feb 2019 05:43:04 AM CST
Build Host : x86-040.build.eng.bos.redhat.com
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1992b967e86ac2dce597e96f7703f897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1c45574a7d404cd81da71361d518ad/" rel="bookmark">
			优优嗨聚集团：医保新政来袭，乙类OTC、保健品或将退出医保舞台，影响几何？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，国家医保局发布征求意见稿，拟将乙类OTC（非处方药）和保健品从医保目录中移除。这一政策一旦实施，无疑将对广大参保人员和相关企业产生深远影响。本文将为您详细解析这一政策可能带来的影响，以及如何应对这一变革。
一、政策背景
近年来，国家医保局不断加大对医保目录的调整力度，以更好地适应广大参保人员的医疗需求。此次拟将乙类OTC和保健品移出医保目录，并非偶然之举，而是经过充分调研和论证后的决策。据悉，这类药品和保健品在医保基金中的支出占比相对较低，同时也不具备较为明显的医疗价值。因此，将其移出医保目录，有助于优化医保基金的使用结构，更好地保障广大参保人员的医疗权益。
二、对参保人员的影响
对于广大参保人员来说，这一政策可能带来两方面的影响。首先，一些常备的乙类OTC和保健品将不能再使用医保基金购买，这无疑会降低这些药品和保健品的可及性。对于这部分人群来说，需要做好自费购买的准备，或者寻找其他替代药品。其次，政策的实施将促使相关企业加强自主创新和转型升级，提高产品竞争力。长远来看，这有利于推动我国医药产业的健康发展，为消费者提供更多质优价廉的药品和保健品。
三、对相关企业的影响
对于相关企业来说，这一政策无疑将带来较大的冲击。一方面，由于医保目录的调整将使得相关产品的销售量出现大幅下滑；另一方面，这也将使得企业在研发、生产、销售等环节上面临更大的压力和挑战。为了应对这一变革，企业需要加强技术创新和产品研发，提高产品的质量和竞争力；同时还需要积极拓展市场渠道，调整销售策略以适应新的市场环境；此外还需要加强与政府部门的沟通和协调，争取更多的政策支持和保障。
四、对医保基金的影响
对于医保基金来说，这一政策的实施将有助于优化基金的使用结构和管理效率。由于乙类OTC和保健品在医保基金中的支出占比相对较低，移出医保目录不会对基金的整体使用产生较大影响。同时这也将使得医保基金能够更好地发挥其医疗保障作用，为参保人员提供更加优质、高效的医疗服务。
五、应对策略
面对即将到来的医保新政，无论是参保人员还是相关企业都需要做好应对策略。对于参保人员来说需要加强自我保健意识提高自我保健能力在日常生活中注意预防疾病的发生保持良好的生活习惯和健康的生活方式同时也要做好自费购买的准备寻找其他替代药品或者选择参加商业保险等方式来保障自己的医疗需求；对于相关企业来说需要积极应对挑战加强技术创新和产品研发提高产品的质量和竞争力同时也要调整销售策略拓展市场渠道加强与政府部门的沟通和协调争取更多的政策支持和保障以应对新的市场环境；此外对于医疗机构来说也需要加强医疗服务的质量和管理提高医疗技术水平为参保人员提供更加优质高效的医疗服务以满足人民群众日益增长的医疗需求。
六、结论
总的来说此次医保新政的实施将有助于优化医保基金的使用结构和管理效率更好地保障广大参保人员的医疗权益同时也有助于推动我国医药产业的健康发展然而对于参保人员和相关企业来说还需要做好应对策略以应对即将到来的变革相信在各方的共同努力下一定能够实现我国医药产业的持续健康发展让人民群众享受到更加优质高效的医疗服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5e7de92f320ae0dc2c2e92ae2d0609/" rel="bookmark">
			图像二值化阈值调整——OTSU算法（大津法/最大类间方差法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大津算法（OTSU算法）是一种常用的图像二值化方法，用于将灰度图像转化为二值图像。该算法由日本学者大津展之于1979年提出，因此得名。
大津算法的核心思想是通过寻找一个阈值，将图像的像素分为两个类别：前景和背景。具体步骤如下：
统计图像的灰度直方图，得到每个灰度级的像素数目。遍历所有可能的阈值（0到255），计算根据该阈值将图像分为前景和背景的类内方差。根据类内方差的最小值确定最佳阈值。 在大津算法中，类内方差是衡量前景和背景之间差异的度量。通过选择使类内方差最小的阈值，可以实现最佳的图像分割效果。
大津算法的优点是简单易懂，计算效率高。它适用于灰度图像的二值化处理，特别是对于具有双峰直方图的图像效果更好。然而，该算法对于具有非双峰直方图的图像可能产生较差的分割结果。因此，在应用大津算法之前，需要对图像的直方图进行分析，确保适用性。
大津算法在图像处理中被广泛应用，例如在文档图像处理、目标检测、图像分割等领域。
下面推导类间方差函数：
设阈值为灰度k（）。这个阈值把图像像素分割成两类，C1类像素小于等于k，C2类像素大于k。设这两类像素各自的均值为，图像全局均值为。同时像素被分为C1和C2类的概率分别为。则有：
根据方差的概念，类间方差表达式为：
展开：
合并2，5及3，6项可得：
我们再把代回得到：
再注意到，所以，，从而得到：
对于给定的阈值k，我们可以统计出灰度级的分布列：
灰度值01...255... 显然根据分布列性质有（请注意这里的是分布列中的，不是上面的定义）
那么有：
将k从遍历，找出使得最大的k值，这个k值就是阈值。
对于分割，这个分割就是二值化，OpenCV给了以下几种方式（同threshold）：
cv2帮助文档：
Miscellaneous Image Transformations — OpenCV 3.0.0-dev documentationhttps://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#threshold代码实现：
首先是原理部分的实现，这部分我们使用numpy：
import cv2 import numpy as np def OTSU(img_gray, GrayScale): assert img_gray.ndim == 2, "must input a gary_img" # shape有几个数字, ndim就是多少 img_gray = np.array(img_gray).ravel().astype(np.uint8) u1 = 0.0 # 背景像素的平均灰度值 u2 = 0.0 # 前景像素的平均灰度值 th = 0.0 # 总的像素数目 PixSum = img_gray.size # 各个灰度值的像素数目 PixCount = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5e7de92f320ae0dc2c2e92ae2d0609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4074f5c43c4eebd5e8c532edb32eb51/" rel="bookmark">
			ICLR 2022）ODConv：即插即用的动态卷积 （附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：Omni-Dimensional Dynamic Convolution | OpenReview
代码地址：https://github.com/OSVAI/ODConv/blob/main/modules/odconv.py
1.是什么？ ODConv是一种动态卷积算法，它的原理是在卷积过程中，根据输入数据的特征动态地调整卷积核的形状和大小，以适应不同的输入数据。具体来说，ODConv通过引入一个可学习的形变模块，根据输入数据的特征动态地调整卷积核的形状和大小，从而提高了卷积神经网络的性能。与CondConv和DyConv不同，ODConv不仅考虑了空间维度、输入通道维度和输出通道维度，还考虑了卷积核的形状和大小，因此可以更好地适应不同的输入数据。
2.为什么？ 常规卷积只有一个静态卷积核且与输入样本无关。对于动态卷积来说，它对多个卷积核进行线性加权，而加权值则与输入有关，这就使得动态卷积具有输入依赖性。它可以描述如下：
尽管动态卷积的定义很简单，但CondConv与DyConv的实现是不相同的，主要体现在计算的结构训练策略以及实施动态卷积的层，这些实现上的差异导致了不同的模型精度、模型大小以及推理效率。
两者均为采用了类SE架构，但CondConv采用的是Sigmoid，而DyConv采用的是Softmax；DyConv采用的退化策略进行训练以抑制Softmax的one-hot输出；对于他们嵌入的CNN架构，CondConv替换了最后几个模块的卷积与全连接层，而DyConv则对除第一个卷积外的其他卷积均进行了替换。 根据动态卷积的公式来看，动态卷积有两个基本元素：
卷积核；用于计算注意力{}的注意力函数 给定n个卷积核，其对应的核空间有以下四个维度：
空间核尺寸k×k；输入通道数输出通道数卷积核数量n 然而，对于CondConv与DyConv来说，均采用单个注意力标量，这就意味着它的的输出滤波器∈对于输入具有相同的注意力值。换句话说，卷积核 的空间维度、输入通道维度以及输出通道维度均被CondConv与DyConv所忽视了。这就导致了关于核空间的粗糙探索。这可能就是为什么CondConv与DyConv对于大网络的性能增益较低的原因。
此外，相比常规卷积，动态卷积的卷积核参数往往是其n倍。比如CondConv中的n=8，DyConv中的n=4。当动态卷积使用过多时无疑会极大程度提升模型大小。我们发现：当 移除掉CondConv/DyConv中的注意力机制(即=1)后，其性能提升接近于零。比如，对于ResNet18，其性能增益从1.78%/2.51%下降到了0.08%/0.14。
上述发现意味着：动态卷积中的注意力机制起关键性作用，更有效的设计也许可以在模型精度与大小之间得到更好的平衡。
一定程度上讲，ODConv可以视作CondConv的延续，将CondConv中一个维度上的动态特性进行了扩展，同时了考虑了空域、输入通道、输出通道等维度上的动态性，故称之为全维度动态卷积。ODConv通过并行策略采用多维注意力机制沿核空间的四个维度学习互补性注意力。作为一种“即插即用”的操作，它可以轻易的嵌入到现有CNN网络中。ImageNet分类与COCO检测任务上的实验验证了所提ODConv的优异性：即可提升大模型的性能，又可提升轻量型模型的性能，实乃万金油是也！值得一提的是，受益于其改进的特征提取能力，ODConv搭配一个卷积核时仍可取得与现有多核动态卷积相当甚至更优的性能。
3 怎么样？ 3.1 网络结构 基于前述讨论，ODConv通过并行策略引入一种多维注意力机制以对卷积核空间的四个维度学习更灵活的注意力。上图给出CondConv、DyConv以及ODConv的差异图。
延续动态卷积的定义，ODConv可以描述成如下形式：
其中，表示卷积核的注意力标量，,,表示新引入的三个注意力，分别沿空域维度、输入通道维度以及输出通道维度。这四个注意力采用多头注意力模块计算得到。
在ODConv中，对于卷积核，对k*k空域位置上的卷积参数赋予不用的注意力值，见上图a；对不同输入通道的卷积滤波器赋予不同的注意力值，见上图b；对不同输出通道的卷积滤波器赋予不同的注意力值，见上图c；而则对n个整体卷积核赋予不同的值，见上图d。
原则上来讲，这四种类型的注意力是互补的，通过渐进式对卷积沿位置、通道、滤波器以及核等维度乘以不同的注意力将使得卷积操作对于输入存在各个维度的差异性，提供更好的性能以捕获丰富上下文信息。因此，ODCOnv可以大幅提升卷积的特征提取能力；更重要的是，采用更少卷积核的ODConv可以取得与CondConv、DyConv相当甚至更优的性能。
对比前面两种动态卷积的公式可以发现：ODConv是一种更广义的动态卷积。此外，当设置n=1,===1时，ODConv则退化为仅具有滤波器层面的注意力，基于输入对卷积滤波器进行调制后再进行卷积，类似于SE。故SE是ODConv的一个特例。
那么如何实现ODConv的四种类型的注意力值呢？延续CondConv与DyConv，我们同样采用SE风格的注意力模块，但使其具有多个头以计算多种类型注意力，整体结构见上图。具体来说，对于输入先通过GAP收缩为长度为的特征向量，然后采用FC与四个头生成不同类型的注意力值。对于四个头，其维度分别为k*k,×1,×1,n×1。
在训练方面，我们采用了DyConv中的退化策略以加速训练。在具体架构嵌入方面，我们参考DyConv对除第一个卷积外的其他所有卷积进行替换。
3.2 代码实现 import torch import torch.nn as nn import torch.nn.functional as F import torch.autograd class Attention(nn.Module): def __init__(self, in_planes, out_planes, kernel_size, groups=1, reduction=0.0625, kernel_num=4, min_channel=16): super(Attention, self).__init__() attention_channel = max(int(in_planes * reduction), min_channel) self.kernel_size = kernel_size self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4074f5c43c4eebd5e8c532edb32eb51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513f72e1f44f0ada541ce39742e3244c/" rel="bookmark">
			mAP@.5和mAP@.5:0.95的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来讲解一下mAP@0.5
mAP:Mean Average Precision，即每个类别分别计算AP，然后Mean平均。
那么何为AP，AP即Precsion-Recall Curve图中PR曲线所围成的面积（在yolov5算法中训练结束后的文件中会生成PR-Curve图）
那么PR-Curve图怎么才算效果好？要看曲线是否平滑，多个类别的时候，哪个类别的曲线在上方证明哪个曲线的效果更好。
讲完mAP，再来讲解这个@.5什么意思，mAP@.5其实就是将IOU设置为0.5时，计算每个类别的AP的平均值。
IOU即置信度，目标检测评价函数，如下图所示，当真实框与我们的预测框完全没有相交的时候，IOU=0；当IOU=0.25时证明真实框与我们的预测框有相交部分，当IOU=1时则证明我们的预测框和真实框完全重合。
提到IOU，我们就不得不提到NMS（non maximum suppression 非极大值抑制），在实际检测的过程中，会框出很多不同的检测框都指向同一个目标，那么我们就要想办法从这些框中选择最优的框。NMS正是解决了从多个预测框中选择最优框的问题。
当你给iou一个阈值，比如iou=0.5，那么当两个预测框的相交部分大于50%的时候，就会从这两个预测框中选择一个适合的留下。当两个预测框的相交部分不足50%的适合，两个预测框都会被留下。如上图左边的目标，很明显三个框中两两之间的相交部分都大于50%，所以会在这三个框中选择一个合适的留下。
假如我们设置iou=1，那就相当说对在检测过程中对同一个目标检测出来不同的框时，只有当预测框和真实框完全重合时候，才会从完全相同的框中选择一个合适的框留下，这样的情况很难满足，所以当iou=1时，检测结果图中就会乱七八糟的出现很多的框。
未完待续.......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7020ef9fea0a1819ff1a69cdc4c79c1d/" rel="bookmark">
			echarts的图表立体感——实现立体柱状图和立体饼图的详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😂博主：小猫娃来啦
😂文章核心：使用echarts实现立体柱状图和立体饼图的详细教程
文章目录 简单介绍立体柱状图和立体饼图环境配置实现立体柱状图实现立体饼图总结 简单介绍立体柱状图和立体饼图 立体柱状图和立体饼图是数据可视化中常用的图表类型，它们可以帮助我们更直观地理解和展示数据。立体柱状图通过在二维平面上表示数据的高度，给人一种立体感，使得数据的比较更加清晰明了。立体饼图则将饼图的扇区进行立体化呈现，使得整个图形更具立体感和层次感。
使用Echarts库可以方便地实现立体柱状图和立体饼图，该库是一个基于JavaScript的开源数据可视化库，提供了丰富的图表类型和交互功能。通过使用Echarts，我们可以轻松地创建、定制和呈现各种数据图表，包括立体柱状图和立体饼图。
在实际需求中，我们可能需要使用立体柱状图和立体饼图来展示具有立体感的数据图形。例如，可以用立体柱状图来展示不同城市的销售额，通过柱状图的高度以及立体效果来比较各个城市的销售情况。而立体饼图则可以用来展示不同产品类别的销售占比，通过立体效果使得饼图更加生动有趣。
很炫酷，对吧，配就完事了。
环境配置 下载Echarts库：可以从Echarts官网下载最新版本的库文件，解压后将echarts.js文件引入到HTML文件中。如果用框架，就npm安装就完事了。创建HTML和JavaScript文件：创建一个HTML文件，例如index.html，并在其中引入Echarts库。同时，创建一个JavaScript文件，例如main.js，用于编写图表的代码。 实现立体柱状图 &lt;!-- index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;立体柱状图示例&lt;/title&gt; &lt;script src="echarts.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="barChart" style="width: 600px; height: 400px;"&gt;&lt;/div&gt; &lt;script src="main.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; // main.js // 初始化Echarts实例 var barChart = echarts.init(document.getElementById('barChart')); // 配置立体柱状图的数据 var data = [120, 200, 150, 80, 70]; // 配置立体柱状图的选项 var options = { title: { text: '立体柱状图示例' }, xAxis: { data: ['A', 'B', 'C', 'D', 'E'] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: data, barWidth: 30, // 设置柱体宽度 itemStyle: { emphasis: { barBorderRadius: 7 // 设置柱体边角的圆角 } } }] }; // 渲染图表并呈现在页面中 barChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7020ef9fea0a1819ff1a69cdc4c79c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ba847a1f4b248dd093ce2385252fbe/" rel="bookmark">
			大麦协议开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 用户抢购请求处理：
- 后端实现：在后端，您可以创建一个用于处理用户抢购请求的接口。当用户发起抢购请求时，后端会根据一定的算法和逻辑来处理请求。例如，可以使用分布式锁来保证只有一个用户能够成功抢购。示例后端代码如下（使用Python和Flask框架）：
```python
from flask import Flask, request
app = Flask(__name__)
@app.route('/purchase', methods=['POST'])
def handle_purchase_request():
user_id = request.form.get('user_id')
product_id = request.form.get('product_id')
# 进行抢购逻辑处理
return '抢购成功'
if __name__ == '__main__':
app.run()
```
- 前端实现：在前端，您可以为用户提供一个抢购按钮。当用户点击抢购按钮时，触发前端代码向后端发送抢购请求。示例前端代码如下（使用JavaScript和jQuery）：
```javascript
$('.purchase-button').click(function() {
var userId = $(this).data('user-id');
var productId = $(this).data('product-id');
$.post('/purchase', { user_id: userId, product_id: productId }, function(response) {
// 处理抢购成功后的操作
});
});
```
2. 库存管理：
- 后端实现：在后端，您可以维护一个库存管理系统来跟踪产品的库存情况。当用户成功抢购时，后端需要相应地更新库存数量。可以使用数据库或缓存来存储和管理库存信息。
3. 并发控制：
- 抢购活动可能会引起大量用户同时发起请求，从而产生并发访问问题。为了保证系统的稳定性和公平性，您可以采取一些并发控制措施，如分布式锁、请求限流、队列等，以限制并发访问量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e90a45c6a94d4509567665d029ef805/" rel="bookmark">
			AIGC系列文章目录 第一章 AIGC 与AI对话，如何写好prompt？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC系列文章目录 第一章 AIGC 与AI对话，如何写好prompt？ 文章目录 AIGC系列文章目录第一章 AIGC 与AI对话，如何写好prompt？一、AIGC是什么？二、Prompt是什么？三、Prompt基本原则四、Prompt常用任务五、总结 一、AIGC是什么？ 生成式人工智能AIGC（Artificial Intelligence Generated Content）是人工智能1.0时代进入2.0时代的重要标志。
AIGC对于人类社会、人工智能的意义是里程碑式的。短期来看AIGC改变了基础的生产力工具，中期来看会改变社会的生产关系，长期来看促使整个社会生产力发生质的突破，在一定程度上加快了整个社会的数字化转型进程。
对于个人来说，及时学会利用AIGC可以极大释放工作潜力，并享受到时代红利。玩转AIGC，优质的Prompt提示词是用户最主要和AI进行对话交流的方式。
二、Prompt是什么？ Prompt 中文翻译是“提示”的意思。即用户给AI的指令。它能够生成类似于人类写作的文本。您只需要给出提示或提出问题，它就可以生成你想要的东西。
最近出现的PE（Prompt Engineering，AI提示工程师）可以使AI更加灵活和精确地理解任务，并且能够减少因为语言表达不清晰而导致的误解和错误，使其能够准确、可靠地执行特定任务。
三、Prompt基本原则 在提交Prompt时，应该尽可能提供上下文语境使用常用词汇清晰明确地描述任务的具体信息，包括任务目标、所需操作、相关条件、确定回答形式等。
详细用户需求、任务描述、输出格式要求（示例）：
我要你充当一个高级营养师。 你的任务是指导我每天早餐、中餐和晚餐的食谱，我饮食偏好不吃辛辣刺激食物，保证我营养均衡。目前食材有土豆、鸡蛋、番茄、牛肉、生菜、牛奶土司面包、意大利面。最近在减肥，尽可能包含详细操作步骤。 输出格式可以是markdown格式的表格。早餐、中餐和晚餐用标题二显示。 OpenAI 3.5模型输出（示例）：
四、Prompt常用任务 Prompt常用的任务：
提示词生成器内容创作儿童读物教育培训学术论文编写小说多语言翻译旅游文案角色扮演：产品经理、医疗顾问、营养师、导游等面试求职代码解析技术文档图片生成数据分析数据展示 五、总结 本文仅仅简单介绍了AIGC 与AI对话，如何写好prompt的使用，而AI本身提供了更多的功能等待着我们去探索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e7d0765bc01ed3adb1d37645612aa4/" rel="bookmark">
			android 13 write javaBean error at *** 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错代码：红框处。
注意：android10 不会报错，运行正常。android13就报错
错误原因：对象中VerifyDownloadEntity，有个Bitmap成员变量
public class VerifyDownloadEntity { private Bitmap bitmap; private String cookie; private String err; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302354e5f52311d8cb73283e28cd8b6b/" rel="bookmark">
			pod进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源限制
当定义 Pod 时可以选择性地为每个容器设定所需要的资源数量。 最常见的可设定资源是 CPU 和内存大小，以及其他类型的资源。
当为 Pod 中的容器指定了 request 资源时，调度器就使用该信息来决定将 Pod 调度到哪个节点上。当还为容器指定了 limit 资源时，kubelet 就会确保运行的容器不会使用超出所设的 limit 资源量。kubelet 还会为容器预留所设的 request 资源量， 供该容器使用。
如果 Pod 运行所在的节点具有足够的可用资源，容器可以使用超出所设置的 request 资源量。不过，容器不可以使用超出所设置的 limit 资源量。
如果给容器设置了内存的 limit 值，但未设置内存的 request 值，Kubernetes 会自动为其设置与内存 limit 相匹配的 request 值。 类似的，如果给容器设置了 CPU 的 limit 值但未设置 CPU 的 request 值，则 Kubernetes 自动为其设置 CPU 的 request 值 并使之与 CPU 的 limit 值匹配。
Pod有以下几种可能的状态：
Pending（等待中）：Pod已被创建，但尚未被调度到任何节点上运行。Running（运行中）：Pod已经调度到节点并正在运行中。Succeeded（成功）：Pod中的所有容器已经成功地完成任务并且已经终止。Failed（失败）：Pod中的至少一个容器已经以非正常方式退出。Unknown（未知）：无法获取Pod的状态信息。 这些状态可以通过Kubernetes命令行工具（如kubectl）或Kubernetes API来查询和监控。请注意，具体的状态可能会因不同的环境和配置而有所差异。
生命周期的表示
容器的生命周期通常包含以下几个关键阶段的表示：
创建（Created）：在此阶段，容器对象已被创建，但尚未分配给任何节点运行。等待（Pending）：容器已被调度到节点上，并等待资源分配和启动。运行中（Running）：容器正在运行中，且正常执行其指定的任务。终止（Terminated）：容器任务已完成或非正常退出，进入终止状态。 成功终止（Succeeded）：容器内的应用程序成功完成任务并正常退出。 失败终止（Failed）：容器内的应用程序以非正常方式退出，可能是发生了错误或异常。删除（Deleted）：容器对象已从集群中移除。 这些生命周期的表示可以通过监控和查询相关容器对象的状态来获取。具体的表示方式可能会根据使用的容器编排工具和配置而有所不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302354e5f52311d8cb73283e28cd8b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab33159b5b2e0149154e3d73018db612/" rel="bookmark">
			cloc工具统计代码量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cloc工具统计代码量 cloc工具下载工具使用常用参数 cloc工具下载 sudo apt-get install cloc 工具使用 cloc . 通过上面命令可以统计当前目录下的所有代码信息如下
Language列：文件类型
files列：文件个数
blank列：空行数量
comment列：注释行数
code列：代码总行数
常用参数 命令描述cloc --fullpath --not-match-d=‘(dir/src|dir/source)’ dir统计dir目录下除了dir/src和dir/source目录（不统计dir/src和dir/source目录下）的代码量 更多详细参数可以通过cloc --help查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c38161f196c19b6a295436772bc5eef/" rel="bookmark">
			亿咖通·天穹Pro行泊一体智能驾驶计算平台正式量产
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球出行科技公司亿咖通科技宣布，旗下首款智能驾驶计算平台——亿咖通•天穹Pro行泊一体智能驾驶计算平台（以下简称“该平台”）已向车企正式量产交付。作为亿咖通科技在智能驾驶领域的全新突破，亿咖通•天穹Pro智能驾驶计算平台以其高性能、高安全、高性价比的特性，成为具备普惠价值的智能驾驶计算平台解决方案。
亿咖通•天穹Pro智能驾驶计算平台
为了满足车企及市场主流车型对智能驾驶功能的多样化需求，亿咖通科技基于国芯方案，研发并推出具备行泊一体功能的智能驾驶解决方案系列——亿咖通•天穹智能驾驶计算平台及亿咖通•天穹Pro智能驾驶计算平台，该系列两款平台可支持NOA领航驾驶辅助功能开发，并且可实现从行车到泊车主要场景的全覆盖。
亿咖通·天穹智能驾驶计算平台是面向L2+等级智能驾驶场景打造的“行泊一体”式智能驾驶计算平台，它集成单颗国产自研的强大车规级智能驾驶SoC——华山二号A1000，其峰值算力可达58 TOPS（INT8），可支持5R6V传感器配置，可为车辆提供包括高速NOA领航驾驶辅助、APA、RPA在内的20多项ADAS功能开发。
APA自动泊车功能演示（测试环境）
亿咖通·天穹Pro行泊一体智能驾驶计算平台集成两颗华山二号A1000，综合算力高达116 TOPS（INT8），是面向主流车型L2+高阶行泊一体的高算力强视觉方案。同时，该平台可支持业内领先的BEV感知算法以及5R10V（1L）的传感器配置方案，随着产品功能的不断升级，未来将实现更高维度的感知融合，可支持城市NOA领航驾驶辅助、HPA记忆泊车等高阶ADAS功能开发。
人机共驾HMI示意图
亿咖通•天穹Pro行泊一体智能驾驶计算平台除了支持智能驾驶的丰富功能，更在安全性上处于行业领先地位，是首款搭载华山二号A1000与QNX方案的智驾计算平台解决方案。在硬件方面，其核心智能驾驶SoC黑芝麻智能华山二号A1000同时符合ISO26262 ASIL-B汽车功能安全以及AEC-Q100 G2车规级芯片认证。
在软件方面，该平台搭载了QNX、AUTOSAR AP&amp;CP车规级操作系统，其安全性可满足各地政策法规，助力车企拓展体量大、成熟度高的海外市场。与此同时，该平台的AEB、LKA、LDW、BSD、SAS等ADAS功能已通过C-NCAP ADAS主动安全性摸底测试，并取得了优于业内主流车型的高分成绩，保障行车安全。
在智能驾驶解决方案的开发过程中，系统功能的测试与验证无疑是整个项目的一大重点与难点。为了解决这一关键问题，亿咖通科技提供了一套端到端的测试验证方法与工具链，不仅可以帮助合作伙伴大幅缩短研发周期，还可有效降低开发风险，确保智能驾驶解决方案的可靠性和稳定性。
目前，亿咖通•天穹Pro智能驾驶计算平台与亿咖通·安托拉1000 Pro智能座舱计算平台，均已开启量产。随着整车智驾功能的不断OTA升级，亿咖通•天穹Pro智能驾驶计算平台将会逐步释放更多场景功能，并不断挑战智能驾驶高阶功能，实现技术普惠的价值目标。亿咖通科技将以天穹系列计算平台为起点，围绕整车智能化不断创新升级，为全球用户带来更加智能、便捷和安全的驾乘体验。
亿咖通科技致力于实现汽车智能化全布局，将优异的性能与高安全的方案结合起来，帮助车企能够基于天穹系列计算平台，轻松打造具备智能驾驶功能的车型，让更多用户能够享受到安全高效的出行体验。亿咖通科技将持续以深度创新、联合共创，携手更多整车品牌，实现技术普惠的多方共赢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f8179ffc2b89c4d03262326817dbd3/" rel="bookmark">
			django-apschedule定时任务异常停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在django项目中使用django-apschedule来实现定时任务，使用的是BackgroundScheduler调度类，该调度的实现是通过后台线程的方式执行定时任务。其中任务都是持久化到数据库中的。
在项目的运行过程中，因为数据库的异常，导致定时任务线程异常终止，即使数据库后续恢复正常，但也不再继续执行。我多次尝试复现未果，在开启定时任务期间，手动将数据库连接断开，定时任务执行失败，然后再将数据库建立连接，定时任务竟然重新恢复了，这让我一时摸不着头脑。
具体的错误日志如下，通过分析，是update_job连接数据库异常，没有任何捕获机制，然后层层网上抛，最终导致线程停止，可以很肯定的是，绝对是因为数据库连接失败导致的定时任务失败，那为什么无法复现呢？
Traceback (most recent call last): File "/usr/local/python3/lib/python3.7/threading.py", line 926, in _bootstrap_inner self.run() File "/usr/local/python3/lib/python3.7/threading.py", line 870, in run self._target(*self._args, **self._kwargs) File "/usr/local/python3/lib/python3.7/site-packages/apscheduler/schedulers/blocking.py", line 32, in _main_loop wait_seconds = self._process_jobs() File "/usr/local/python3/lib/python3.7/site-packages/apscheduler/schedulers/base.py", line 1009, in _process_jobs jobstore.update_job(job) File "/usr/local/python3/lib/python3.7/site-packages/django_apscheduler/util.py", line 105, in func_wrapper result = func(*args, **kwargs) File "/usr/local/python3/lib/python3.7/site-packages/django_apscheduler/jobstores.py", line 249, in update_job with transaction.atomic(): File "/usr/local/python3/lib/python3.7/site-packages/django/db/transaction.py", line 189, in __enter__ if not connection.get_autocommit(): File "/usr/local/python3/lib/python3.7/site-packages/django/db/backends/base/base.py", line 389, in get_autocommit self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93f8179ffc2b89c4d03262326817dbd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c1a4028eb1f72bc4d9f639cf4c0745/" rel="bookmark">
			List 移除指定元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求描述 我想在 list 中删除指定的元素，我该如何进行操作呢？
二、代码展示 我们使用 for 循环的形式来解决下上面提出的需求，代码如下：
public class App2 { public static void main( String[] args ){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("aa"); list.add("bb"); list.add("bb"); list.add("cc"); list.add("dd"); list.add("bb"); for(int i=0;i&lt;list.size();i++) { if("bb".equals(list.get(i))) { list.remove(i); } } for(String s:list) { System.out.println(s); } } } 运行结果如下所示，貌似出了个小问题，因为有个 bb 并没有去除掉。
三、原因分析 为什么会出现这种问题呢？当删除第一个 bb 元素后，下一个元素就会向前移一位 , 而 for 循环的索引是继续往后加 1 的，即没删除之前 list.get(2)='bb'，当删除第一个 bb 后，下一个元素前移，导致此时 list.get(1)='bb'，list.get(2)='cc'，而 for 循环里面的 i 并没有发生变化，还是继续执行 +1 向后遍历的操作，导致 bb 元素逃脱了并没有删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c1a4028eb1f72bc4d9f639cf4c0745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a97d7e13499d6b45ac4a509ca0a60c/" rel="bookmark">
			vue-baidu-api地图标记点（自定义标记图标），设置标记点的优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：地图标记坐标点：使用自带的图标
&lt;bm-marker v-for="(item, index) in pathArr" :key="index + '_'" :position="item.value" &gt; &lt;/bm-marker&gt; &lt;script&gt; export default { data(){ return{ zoom:14, center:{}, pathArr:[ {value:{lng:30.122314,lat:121.0013123113}}, {value:{lng:30.23132113,lat:121.12414131}}, ] } } methods:{ //初始化地图 handler: function ({ BMap, map }) { // 赋值，方便调用，本节被用到 this.BMap = BMap this.map = map var view = this.map.getViewport(eval(this.pathArr)) // this.pathArr 是我们知道的经纬度。可以有多个。全部以数组形式放在里面。 //进入显示的百分比 this.zoom = view.zoom; //打开地图时的位置 this.center = view.center; }, } } &lt;/script&gt; 2：地图自定义图标标记点：
使用z-index设计标记点的优先级，可以使优先级高的标记点不被覆盖，显示在最上面
&lt;bm-marker v-for="(item, index) in pathArr" :key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3a97d7e13499d6b45ac4a509ca0a60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030b34615e069adcaa361d002173900f/" rel="bookmark">
			vue全屏展示功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：全屏展示页面所有内容
&lt;span style="color:#918F8F" @click="clickFun"&gt; &lt;img :src="isFullFlag?closeFullImg:openFullImg" style="width:12px;vertical-align:middle"/&gt; {{isFullFlag?'退出全屏':'全屏'}} &lt;/span&gt; &lt;script&gt; export default { data(){ return{ isFullFlag:false } } mounted() { // 监听页面全屏 window.addEventListener("fullscreenchange", (e)=&gt; { if(screenfull.isFullscreen){ this.isFullFlag = true }else{ this.isFullFlag = false } }) }, methods:{ clickFun(){ this.isFullFlag =!this.isFullFlag if (!screenfull.enabled) { this.$message({ message: 'Your browser does not work', type: 'warning' }) return false } screenfull.toggle() } } } &lt;/script&gt; 2：全屏页面的部分内容
&lt;template&gt; &lt;span style="color:#918F8F" @click="clickFun"&gt; &lt;img :src="isFullFlag?closeFullImg:openFullImg" style="width:12px;vertical-align:middle"/&gt; {{isFullFlag?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030b34615e069adcaa361d002173900f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17d62a4f6fe9bbffd4ea68f2b4240d6/" rel="bookmark">
			NOA赛道研究：预计2024年渗透率10%！中算力平台迎窗口期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从基础L2到L3的产业演进中，NOA是至关重要的一步，值得被密切关注。
对于产业链不同位置的玩家，其关注的点有所不同：①对于整车厂来说，根据高工智能汽车监测的数据，基础L2的一体机产品已经趋向于成熟，处于快速渗透期，智驾竞争已经过渡到NOA阶段；②对于Tier1、Tier2来说，在基础L2阶段，智驾产品（一体机）的单车价值量为1000元左右，NOA（域控+传感器）的单车价值量提到3000-30000元左右，市场空间真正出现数量级提升；③占整车成本的真正提升，有望在整车供应链获得一定博弈权，实现从传统制造业到科技产业的演进，供应商们也在寻找自身的分工和角色。
此次文章内容主要集中于中、高算力平台，拥有极致性价的低算力平台后续单独探讨，本次探讨问题包括：
★其一，NOA究竟正如何发展？
★其二，通勤NOA会给产业带来什么样的影响？
★其三，典型的中、高算力芯片是怎么样的？
图片来源：「微报告」为何2024年NOA渗透率可以达到10%？
从产品结构上看，NOA解决方案主要为：传感器（摄像头+毫米波雷达+超声波雷达+高精定位+高精地图/adas地图，地图可理解为先验传感器）+域控制器+软件（底层OS+中间件+感规控算法）。
从整体数据端来看，标配维度，2023年1-5月NOA交付14.94万辆，同比增长92.77%，继续保持高增长势头，市场渗透率为2.03%，处于小规模导入期到大规模放量（以10%渗透率为界）之间。
但较为特殊的一点是，NOA搭载量的头部特斯拉、蔚来、极氪等仍在探索的收费策略为“硬件标配+软件选装”，囊括该部分，以标配+选装的维度，2023年1-5月渗透率已达到6.07%，如果在新能源车市场，标配+选装的渗透率则已经达到19.33%，这是一个必须引起关注的数据。且还有一个需要关注的变量因素，即特斯拉FSD的入华节奏，以其在NOA市场的占比，一旦释放将给市场带来冲击。
根据高工智能汽车此前预计，2024年NOA前装标配渗透率将达到10%。
那么，其一，NOA究竟正如何发展？
以算力平台来划分，NOA有中、高算力平台两种典型的解决方案（极致性价比的低算力平台另行探讨），具体来看：
●增强版高速NOA（+通勤NOA）方案，算力平台20-200TOPS。进入2023年，这一细分市场格外火热。主机厂/Tier1方面，除特斯拉外，典型如理想L7、L8的Air版本和Pro版本，比亚迪腾势N7的Orin-N版本，大疆在成行平台，毫末的HP370、HP570方案；
算力平台方面，地平线的J5（128TOPS），英伟达的Orin-N版本（84TOPS）、TI的TDA4-VH版本（32TOPS）正在2023年密集进入市场，黑芝麻智能在2020-2021年推出的A1000（58TOPS）、A1000PRO（106TOPS）亦在该区间；
●城市NOA方案，算力平台采用200+TOPS。在2023年，可以看到的明显趋势是：在功能端，城市NOA开始规模化落地，小鹏、华为等头部厂商开始开城大战；在搭载车型价格趋势上，200+算力平台搭载车型开始从35万以上下探到20-25万区间，典型代表便是智己LS6、小鹏G6，这无疑给降本提出极大要求，这或给国内芯片玩家带来机会。
算力平台方面，英伟达的Orin-X，华为MDC平台分布于该区间，此外，黑芝麻智能的A2000（250TOPS）、后摩智能的鸿途™H30（256TOPS）亦在该区间。
图片来源：「微报告」为何2024年NOA渗透率可以达到10%？
其二，通勤NOA（或称记忆行车/AI代驾）会给产业带来什么样的影响？
从产业内主机厂/Tier1的跟进来看：
●2023年3月，小鹏汽车首个提出“通勤模式”概念，后续将其命名为Ai代驾，根据2023年10月披露的信息，小鹏汽车的城市NOA开城和AI代驾两条线并行，后者在2023年10月开启小规模测试，在年内向部分用户开放。
其中，AI代驾功能不受城市限制，开启AI代驾功能后，用户可在全国范围内设置起点和终点，手动驾驶一次后即可形成记忆地图，在之后选择该出行路线时就可以使用“AI代驾”功能，实现单独路线/特定场景的城市导航辅助驾驶。
●2023年4月，大疆亮相成行平台，以32TOPS算力平台实现记忆行车，2023年9月，成行平台上车宝骏云朵灵犀版；
●2023年6月，理想汽车在北京望京地区通勤NOA功能测试，2023年8月，宣布将通勤NOA在年内落地100城市；
●2023年10月，毫末智行发布HP370智驾方案，实现通勤NOA；
●2023年10月，百度推出Apollo City Driving，实现通勤模式；
高工智能汽车注意到，通勤NOA在现阶段，或为解决智驾系统价值与价格问题提供一个过渡点。具体来看，高速NOA场景占市民出行时长的约10%，高速NOA+通勤NOA可覆盖85%左右，在稍稍增加传感器硬件和算力成本的同时，便可大幅提升用户可感知价值。
这也或给NOA低、中、高算力平台分层发展的态势，带来一些变量：高算力平台在30万元以上车型继续分层发展；加速中算力平台在中高端乃至平价车型的渗透速度。
其三，典型的中、高算力芯片是怎么样的？
●2022年9月，地平线第三代车规级芯片征程5首发上车理想L8 Pro版，拉开征程5上车的帷幕，根据对外释放的信息，截至目前征程5已累计获得9家车企多达近20款车型的量产定点。
产品层面，征程5单颗芯片算力128TOPS，至多支持16路摄像头感知计算，同时开放支持包括毫米波雷达、激光雷达等多传感器感知、融合、预测与规划控制需求，产品搭载先进的BPU贝叶斯智能加速引擎，具备领先于同级竞品的真实计算性能。
地平线基于征程5打造了国内领跑于行业的完整、成熟的智能计算开发环境，包含芯片开发套件、量产级硬件参考设计、软件开发工具和丰富的参考算法等，通过开放易用的开发工具与基础设施，生态伙伴能够在地平线的芯片上快速部署智能驾驶算法应用，开发差异化产品方案，抢占市场先机。
●2022年5月，后摩智能发布首款存算一体智驾芯片后摩鸿途™H30, 作为全球存算一体智驾芯片的先行者，其基于存算一体创新架构，为智能驾驶提供强大的计算核心，产品核心优势包括：
①强大的AI计算能力：芯片物理算力达256TOPS，大幅提升数据和计算单元的交互效率，计算利用率极高；
②高能效比：核心AI处理器能效比高达20TOPS/Watt, 远远领先于传统架构；
③低延时：AI计算数据处理时延相较传统芯片减少2倍以上，适用各类时延敏感型场景
④用户敏捷开发：提供强大且开放易用的工具链，支持TensorFlow，PyTorch，ONNX和第三方自定义的框架，极大提高开发效率。
根据对外释放的信息，后摩鸿途™H30 已于今年下半年陆续给 Alpha 客户送测。同时，后摩智能的第二代产品后摩鸿途™H50 已经在全力研发中，预计于2024年推出，支持客户2025年的量产车型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b3d8f39e1541cfbfa79c34dc0d7360/" rel="bookmark">
			降本/升级成主旋律，智能座舱迈入发展“新纪元”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能座舱的“进阶战”正在激烈的上演着。
近日，吉利全新汽车机器人品牌极越旗下首款车型极越01正式上市并同步开启交付。新车搭载了高通5nm工艺制程的8295座舱芯片，并首次完全启用双NPU。在强大的算力支持下，极越01配备了35.6英寸6k超清一体屏，并率先实现业内首家AI算法全量本地化，能给用户提供毫秒级全域全离线语音、顶级画质全屏竞速游戏以及全沉浸休闲舱的交互体验，同时还做到了语音、手势、视觉识别等多模态交互。
与此同时，同样搭载了高通8295芯片的极氪001高性能版001 FR也于近日限量发售。新车最大的卖点就是使用了卫星通信技术，可以实现双向卫星消息、卫星语音通话等功能。
可以看到，智能座舱已经成为了智能汽车行业最激烈的 “角斗场”。同时，智能座舱也在加速从高端车型向中低端车型下探。
根据《高工智能汽车研究院》数据显示，2023年上半年，中控大屏、语音交互、车联网等的渗透率均已经超过70%。其中，中控娱乐系统的前装标配渗透率已经达到了92.13%。
与此同时，域控制器、W/AR HUD、DMS等的前装搭载量也呈现了快速增长的态势。比如座舱域控制器，今年上半年前装标配交付117.67万辆，同比增长了67.98%，搭载率达到了12.66%。
接下来，伴随着汽车电子电气架构的进一步升级，智能座舱赛道将进入新一轮的变革周期。
从“堆硬件”到“重体验”转变 从今年全新上市的一些新车以及主机厂的布局动作来看，智能座舱市场正在从单一功能的“堆砌”上车，进入了围绕用户体验进行差异化运营的新周期，由此也衍生出了副驾娱乐屏、多屏交互融合等一系列的新需求：
一是，传统的仪表盘正在被HUD替代，中控大屏化、多屏化成为了主流趋势。比如极越01、理想L9、深蓝S7等纷纷采用W/AR HUD取代传统仪表盘，而腾势N7在车内配备的屏幕数量多达6个，包含17.3英寸中控屏+10.25英寸副驾屏+ 50英寸AR-HUD+10.25英寸仪表屏+双侧智能风口显示屏，同时全系标配UWB数字钥匙。
智云谷CEO侍强表示，AR HUD是智能座舱极其重要的组成部分，未来的市场前景广阔，预计到2025年将成为HUD市场的主流。
智云谷是国内率先实现量产AR HUD的供应商之一，目前，智云谷的AR HUD已经在岚图追光车型（全系标配）上面成功量产，并且即将在某高端新能源品牌SUV车型（全系标配）上面实现量产上车。
二是，智能语音持续升级，并且深度融合手势、视觉识别等多模态交互，打造极致的座舱体验。根据高工智能汽车研究院监测数据显示，2022年中国市场（不含进出口）乘用车同时标配信息娱乐中控、语音、Face ID（含DMS、OMS）交付183.90万辆，前装搭载率为9.23%；今年1-4月，交付79.37万辆，前装搭载率升至14.03%。
在这样的背景之下，一线车企纷纷加强从智能语音到多模态交互的技术储备，手势识别、视觉识别等赛道相关企业迎来发展的最佳窗口期。
其中，赛轮思作为全球车载语音交互系统领军企业，运用先进的AI技术、大语言模型（LLMs）和深度学习，使语音助理获取数字世界不断增长的知识，为驾驶者创造更智能和自然的互动。
比如，赛轮思推出的Cerence Co-Pilot通过人工智能和持续学习，可以准确感知驾驶者的需求，赋能车载助理采取主动，突破了传统基于唤醒词的被动式交互，开创了主动式、多模态车载交互体验。
此外，Cerence Co-Pilot可以分析融合语音、视线、手势和触摸及来自其他汽车传感器的信息，同时灵活而安全地结合边缘技术与云服务。
三是，AR/VR眼镜、游戏等丰富娱乐交互应用上车，沉浸式视听体验渐成竞争焦点。比如，小鹏G9的“全场景5D座舱”打造了360°环绕声场，智能氛围灯结合音乐节拍、音量等因素改变，营造更加沉浸式的视听氛围；而蔚来的“全景数字座舱PanoCinema”则采用AR眼镜+3D空间显示系统、7.1.4沉浸声音响系统等，打造沉浸式观影体验。
四是实现手机与车机的深度融合。近几年，吉利、蔚来等车企纷纷跨界造手机，从而实现车辆与手机的深度互联互通。“未来，智能汽车和智能手机是共同面向用户的多终端、多场景、沉浸式体验的一体融合关系。”吉利掌门人李书福曾表示。
除此之外，众多的主机厂、零部件厂商正在进一步探索智能座舱与大模型的结合。比如理想、智己等主机厂均已经自研GPT大模型，并且在量产车型当中应用。
“随着软件定义汽车的趋势越来越明朗，‘硬件预埋+软件OTA持续升级’已经逐渐成为当下车企的主流策略。”在艾拉比创始人孙荣卫看来，汽车行业的商业模式正在从“卖新车”转为“持续性的服务升级”模式，逐步打开汽车的“黄金通道”。
艾拉比推出的新一代整车软件管理VSP平台，能够统一软件管理源头、软件解算中枢、汽车软件生命周期管理档案，全方位打通生产、售后以及日常用车等多个环节。
与此同时，艾拉比构建的车辆端X-OTA能力，完美支撑汽车固件升级、软件升级、远程诊断和产线更新等功能实现，为整车软件生命周期管理和软件可售提供解决方案。目前，艾拉比已经为40多家主机厂、100多个车型提供OTA集相关软件产品和服务。
全新的竞争时代来临 在《高工智能汽车研究院》看来，智能座舱已经进入了规模化普及的新周期，从芯片到显示，从硬件到软件，从感知到交互，智能座舱新一轮的角逐已经开启。
一方面，智能座舱正在逐步由高端车型向中低价格区间车型渗透，降本增效成为了主机厂首选的考虑因素。这就意味着，谁能够帮助整车厂以最优的成本、最快的速度实现智能座舱产品的量产落地，谁就有机会领跑智能座舱市场。
哈曼Ready Upgrade解决方案是一套可全面升级的智能座舱硬件和软件产品，包含三个系列的量产级座舱域控制器、先进的软件方案、一系列预集成的功能和一整套面向客户的轻量级编码软件开发工具，其创新的产品化开发理念，能够帮助汽车厂商实现车辆全生命周期的座舱全系统升级，并缩短汽车的上市时间和减少汽车厂商的开发成本。
另一方面，智能座舱赛道正在迎来新一轮的芯片替代潮。去年开始，各大主机厂开始陆续进入新车型研发及老车型改款周期，切换供应商的窗口期已经开启。
众所周知，伴随着OTA的迭代升级、更多车载娱乐功能等的上车，智能座舱对于核心SoC的算力需求大幅提升。在这样的背景之下，包括吉利、极氪、理想、零跑、蔚来、小米、小鹏等中国车企计划或即将量产搭载8295平台。
但同时，智能座舱芯片的使用已经呈现了多元化态势。车企针对不同品牌、不同定位的车型在选用计算平台的时候，不仅会考量开发成本、功能定位、产品迭代周期等因素，还会考量芯片是否满足多系统、高性能、功能安全和数据安全等要求，进而选择不同的芯片方案。
中国本土座舱芯片不仅成本更低、商业模式更灵活，还可以提供更加开放的生态及快速响应的本土化服务。因此，包括芯驰科技、华为等等中国本土化座舱SoC的搭载量也在迅速提升。
其中，芯驰X9系列是一款专为新一代汽车电子座舱设计的车规级汽车芯片，不仅集成了高性能CPU、GPU、AI加速器及视频处理器，还配备独立多种智能引擎，可实现感知、语音识别和深度学习等功能，能够高效提升智能座舱的感知和交互能力。
除此之外，X9系列处理器还可以支持多个操作系统，同时驱动仪表、中控、后视镜、后排娱乐等多达10个屏幕和4K屏幕的输出，并且支持多屏共享和互动，以及360环视、泊车、DMS、语音识别等丰富的应用场景。
现阶段，芯驰科技的X9系列处理器已经在上汽、奇瑞、长安、广汽、北汽、东风日产等车企的车型实现规模化量产，同时还成功拿下了几十个重磅定点车型，包含本土汽车品牌、合资品牌、造车新势力及国际大厂。
而针对未来的舱泊一体市场，芯驰科技还推出了基于高性能车规处理器X9U的舱泊一体方案，在单个芯片上可以实现智能座舱、360环视和泊车功能的融合，能够在保障安全性的前提下，通过更优化的系统BOM成本。
在未来，随着人工智能技术的不断发展，智能座舱与智能驾驶一体化将成为主要趋势。业内人士表示，从中控娱乐、座舱域控到中央控制，从舱泊一体再到舱驾一体，全新的智能汽车市场格局正在形成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e14ba06f4322790fa246de32f024c45/" rel="bookmark">
			PC端上拉加载 scroll 监听还是IntersectionObserve API?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今阶段，相对于 uniApp、小程序，PC端如要实现上拉等类似功能并不是很灵活，最常见监听window scroll吗？此方法可以实现，但相对也有一定性能弊端、容错率、兼容等问题。
两者利弊 addEventListener scroll 优点：实时性 、特定阶段实现特定效果
缺点：性能问题、滚动灵敏度容错率、滚动处理复杂、触发次数过多
描述：首先监听 scroll 很灵活，可以随时随地在某个节段去做一些相应操作列如：dom切入，切出、过度等效果。但是 scroll 会一直存在，鼠标滚轮只要滑动，这个事件会一直触发，导致性能问题，浏览器之间也会存在灵敏度差异，其次计算到达底部会有容错率。
InterSectionObServe API 优点：性能优化、减少事件触发减少负担、交叉懒加载、简单易用
缺点：较低浏览器兼容问题、多目标复杂性、异步执行导致其余逻辑变故、代码量过多
描述：IntersectionObserver是JavaScript API，内部计算目标元素与视窗或祖先元素的交叉区域，提供高性能、简单接口，触发事件通知状态变化，依赖浏览器底层机制，内部优化减少不必要的计算及事件触发。
实现案列 addEventListener scroll 监听出现滚动条元素来实现。
需注意：确保监听的元素已出现滚动条，如果是浏览器出现并不是元素配合 overflow:auto 内部出现，被监听者也要相应变化，以免错误监听导致无任何效果。
// Vue3.0 + ts // 挂载后执行 onMounted(() =&gt; { // 被监听者 let view = document.querySelector(".home") as HTMLDivElement; view.addEventListener('scroll', () =&gt; { // 限制滚动到底部时触发事件 // 此处到达底部计算会出现容错率,自行限制下执行次数,并在相应请求中恢复。 if( (view.scrollHeight - view.scrollTop) &lt;= view.offsetHeight ){ // 业务逻辑 //request axios ... } }) }) IntersectionObServe API new API 传入目标元素实现到底部，目标元素可以是一个或数组多个元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e14ba06f4322790fa246de32f024c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a50d40af20bbbe4d1614776136e863/" rel="bookmark">
			突破界限！揭秘超强搜索技巧，助你成为顶尖搜寻高手！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习差距 = 信息差 x 时间投入
搜索效率：谷歌&gt;公众号&gt;短视频&gt;百度（谷歌搜索的结果最强）
限定关键词：“” （"国际移民按性别统计"）
限定标题： intitle （intitle:iphone15摄像头进灰），组合使用（intitle:"iphone15摄像头进灰"）,必须包含关键词并且是完整出现的
限定标题多个关键词： allintitle （allintitle: 张三 李四）
限定内容关键词：intext (intext:"池晨晨" "浙江大学")
限定网址关键词：inurl (李子柒 inurl:cctv intext:youtube)
限定搜索结果的网站来源：site (site:zhihu.com) 必须是完整的域名
限定图片的尺寸大小：imagesize (imagesize:2560*1440)，还可以限定搜索的图片格式 eg：arrow filetype:png
限定搜索结果的文件格式： filetype （研究报告 filetype:ppt）以后想了解某个行业或了解最新的趋势，就先去搜某行业的研究报告 eg：母婴行业2023 filetype:pdf
网页搜索推荐使用：谷歌
公众号类推荐使用：搜狗 或者微信app搜索
垂类网站：eg：设计师必逛的网站 去谷歌搜索结果
判断信息准确度，要看信息源，越是一手源头的信息越准确可信
文章内容提炼来源：超级搜索技术，普通人变强的唯一外挂 | 全套宝藏实操秘技_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de171a9e89bdcd61e5b31f95b90e3d1/" rel="bookmark">
			WPS文件恢复怎么做？记得掌握这5个方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我保存在WPS里的部分文件丢失了，大家快帮我想想办法吧，有什么方法可以恢复这些WPS里的文件吗？真的很重要！” WPS Office是一款流行的办公套件，给用户在办公和学习方面提供了很多的便利。但在整理文件时，我们可能会遇到误删WPS文件的情况，这有时候会让我们手足无措。
今天小编就给大家总结了几个WPS文件恢复的简单操作方法，帮助大家找回误删的WPS文件。详情可继续往下看哦！
方法一：在回收站中恢复WPS文件 WPS文件误删怎么找回？首先我们可以尝试在回收站中对WPS文件进行查找，这是最简单且有效的文件恢复方式。
1.双击进入【回收站】中，查找被删除的WPS文件；
2.选定误删的WPS文件后，可以直接拖出回收站，也可以点击【还原选定的项目】。
方法二：借助撤销功能恢复WPS文件 刚刚删除的WPS文件如何恢复？如果我们的WPS文件是刚刚删除的，可以尝试使用快捷键撤销的功能看看能否恢复WPS文件。
1.确保文件误删后未进行任何其他操作；
2.按下【Ctrl】＋【z】键，看看能否恢复WPS文件。
提示：该方法使用较局限，仅在小部分情况下有效。 方法三：备份与恢复功能恢复WPS文件 WPS文件丢失可以找回吗？其实WPS中有一个自带的备份与恢复功能，通过该功能，我们也是有机会快速恢复WPS文件的。
1.在WPS中，点击【文件】；
2.点击【备份与恢复】，然后进入【备份中心】；
3.找到误删的文件后，双击打开它。即可正常使用。
方法四：在最近中恢复WPS文件 WPS怎么还原上次文档？经常使用WPS办公的朋友可能都注意到了，WPS中有个【最近】功能，这里会保存我们最近编辑过的文章，如果想找回误删的文件，可以看看是否在此处。
1.进入WPS的首页；
2.单击【最近】，找到需要恢复的文件后可以直接进入文件中。
方法五：专业软件恢复WPS文件 WPS没有备份文档怎么恢复？对于没有备份且在电脑上无法找到的文件，小编建议大家借助专业的数据恢复软件来进行恢复。这样或许可以达到事半功倍的效果。比较推荐的是数 据 蛙 恢 复 专 家。
作为一款专业的数据恢复软件，它有适合大众的操作界面，用户有机会通过简单的操作完成复杂的文件恢复。如果需要进行WPS文件恢复，建议在文件误删后及时操作，以下是文件的简要操作步骤。
操作环境： 演示机型：神舟战神G9-CU7PK 系统版本：Windows 10 软件版本：数 据 蛙 恢 复 专 家3.1.6 1.下载好软件后即可运行它，首次使用软件可以先不注册，点击【免费试用】进入选择界面；
2.恢复WPS文件可以只勾选【文档】，如果还需要恢复其他类似文件吗，也可以全选，并对需要扫描的磁盘进行选择，单击【扫描】；
3.扫描完成后，可以对扫描到的部分文件进行查看，右侧可切换查看视角，如果没有找到需要恢复的文件，点击【深度扫描】；
4.深度扫描完成后，可以对需要恢复的WPS文件进行全面的选择，选择完毕后，可以点击【恢复】，并选择新的文件保存位置。
提示：筛选器可以帮你快速定位文件，在扫描结果过多的情况下借助筛选器选择文件有利于提高选择速度。 我们平常工作可能经常会用到WPS文件，一旦文件被误删了，WPS文件恢复应该怎么操作呢？上文已经告诉你答案啦。如果需要恢复WPS文件，可以按照小编分享的方法进行操作哦！
往期推荐：
Win10文件删除了怎么恢复？文件恢复，记好这3个方法！https://blog.csdn.net/datarecover/article/details/134133193?spm=1001.2014.3001.5501
删除的PPT怎么找回来？4个必备恢复方法！https://blog.csdn.net/datarecover/article/details/134134487?spm=1001.2014.3001.5501
电脑不显示桌面？盘点4个正确操作！https://blog.csdn.net/datarecover/article/details/134133802?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fdff43f066cf29563ae5ac27cf5a382/" rel="bookmark">
			Word插入图片显示不全？学会这4个方法，轻松解决！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“为了让我的文档看起来更专业，我在Word里插入了一些图片，但是这些图片有些只显示了部分，有些都无法正常显示。有什么方法可以让图片显示齐全吗？” 在使用Word时，添加一些图片不仅会让我们的文档看起来更美观，也可以更好的帮助我们完成工作。在Word中插入图片是一个比较常见的操作，但有时候我们可能会遇到Word插入图片显示不全的情况。
这是为什么呢？怎么解决这个问题呢？下文小编已经为大家总结了实用的方法，快来试试吧！
Word插入图片显示不全的原因 如果我们将图片插入Word中却发现文档里图片显示不全是为什么呢？比较常见的原因有以下几个。
1.图片尺寸过大：如果你插入的图片尺寸超出了页面边缘，Word会自动调整图片大小以适应页面，导致显示不全；
2.文本框约束：图片可能被放置在文本框内，而文本框的大小不足以容纳整个图片；
3.图层叠加：多个对象（文本框、图片等）叠加在一起时，可能会导致图片部分被遮挡；
4.图片格式问题：某些图片格式可能在Word中显示不全或产生显示问题；
5.缩放设置：Word的缩放设置可能不正确，导致图片显示异常。
Word插入图片显示不全怎么办 Word文档里照片显示不全怎么办呢？了解了以上一些常见的原因后，小编还给大家总结了正确的操作方法，请继续往下看吧！
方法一：调整图片尺寸 Word文档插图片不完全显示可能是由于图片的尺寸设置不正确，我们可以通过调整图片尺寸来解决这个问题。
步骤1：选中图片，点击【设置图片格式】；
步骤2：在【大小】组中，手动设置图片的宽度和高度，确保其适应页面。
提示：也可右键点击图片，选择 【大小和位置】，然后设置合适的尺寸。 方法二：调整文本框 Word里插图片只显示一半，有可能是因为文本框的大小与图片不匹配。如果图片被放置在文本框内，调整文本框的大小以容纳整个图片。
步骤：右键点击文本框，选择【格式形状】，然后调整尺寸。
方法三：图层管理 如果插入图片后文本框位于图片前面可能对图片造成部分遮挡。此时可以通过图层管理来解决Word插入图片显示不全的问题。通常是将图片放在文本框前，操作如下。
步骤：右键点击图片或文本框，选择【置于顶层】或【置于底层】，以管理对象的叠加次序。
方法四：使用布局选项 Word文档里照片显示不全可以尝试使用布局选项来进行更改。改变了文章布局后图片或许就可以正常显示。
步骤：在【布局】选项卡中，尝试选择不同的布局选项，如【四周型】或【紧密型环绕】，以更好地控制图片位置。
使用Word时，我们可能经常需要插入图片，帮助我们提高文章的可读性。Word插入图片显示不全怎么办呢？快来试试这些方法吧！小编都已经给大家总结好啦，需要的朋友可以进行尝试了。
往期推荐：
磁盘空间不足怎么清理？记好这3招！https://blog.csdn.net/datarecover/article/details/134112245?spm=1001.2014.3001.5501
PDF文件恢复？记住这3个就够了！https://blog.csdn.net/datarecover/article/details/134113608?spm=1001.2014.3001.5501
Win10文件删除了怎么恢复？文件恢复，记好这3个方法！https://blog.csdn.net/datarecover/article/details/134133193?spm=1001.2014.3001.5501
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d56d818a7e8e21a6e738671370dc23/" rel="bookmark">
			Android系列面试解析，深夜思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近在网上看到很多关于面试的文章，其中有些面经的文章只提供了面试题目，而没有给出面试过程中的细节和面试心得。
这导致一些面试者在面试前只是盲目地刷题，而没有将题目与自己过去的项目经验结合起来，因此在面试中被问到一些技术问题时无法回答，最终导致面试失败或者薪资不高。
这篇文章主要特点是将繁琐的知识点以系列专题的形式呈现给读者。通过跟随博主构建的体系化学习知识点，读者可以更好地掌握Android开发的相关知识。当读者能够掌握这些知识点时，就可以超越80%以上的Android开发人员。这种无所不知的感觉会让读者感到自己已经成为别人眼中的大神。
在面试前，了解一些常见的面试题目和面试过程中的细节是非常重要的。除了题目之外，还需要注意一些常见的面试礼仪和技巧，例如穿着得体、保持良好的态度、积极思考问题等等。这些细节可以帮助面试者给面试官留下一个良好的印象，增加面试成功的机会。
除了面试前的准备，还需要在平时的学习和工作中积累经验。通过阅读优秀的代码、参与开源项目、与同行交流等方式，可以不断提高自己的技术水平和解决问题的能力。在面试中，这些问题可能会被问到，因此需要做好充分的准备。
面试题笔记分享 为了助力朋友们跳槽面试、升职加薪、职业困境，提高自己的技术，本文给大家整了一套涵盖Android所有技术栈的快速学习方法和笔记。目前已经收到了七八个网友的反馈，说是面试问到了很多这里面的知识点。
每一章节都是站在企业考察思维出发，作为招聘者角度回答。从考察问题延展到考察知识点，再到如何优雅回答一面俱全，可以说是求职面试的必备宝典，每一部分都有上百页内容，接下来具体展示，完整版可直接下方扫码领取。
第一章 算法和数据结构面试题汇总 第二章 Java核心基础面试题汇总 第三章 Java深入泛型与注解面试题汇总 第四章 Java并发编程面试题汇总 第五章 Java虚拟机原理面试题汇总 第六章 Java反射类加载与动态代理面试题汇总 第七章 网络编程面试题汇总 第九章 高级UI面试题汇总 第十章 Framework内核解析面试题汇总 第十一章 Android组件内核面试题汇总 第十二章 程序性能优化与数据持久化面试题汇总 第十三章 开源框架面试题汇总 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ada834fc13b5f74fafeed6f46dbaa1b/" rel="bookmark">
			‘error:03000086:digital envelope routines::initialization“处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 现象： opensslErrorStack: [ 'error:03000086:digital envelope routines::initialization error' ], library: 'digital envelope routines', reason: 'unsupported', code: 'ERR_OSSL_EVP_UNSUPPORTED' 2.解决方法 2.1 在packet.json中添加 set NODE_OPTIONS=--openssl-legacy-provider #比如 "dev": "set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve", 方法2：
参考：输入npm run dev报错“ensslErrorStack: [ ‘error:03000086:digital envelope routines::initialization“解决方法之一-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550e3ad5eede7c75ebf4ca55bb1975d5/" rel="bookmark">
			GNSS卫星姿态解算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GNSS卫星姿态影响太阳光压辐射力的建模与卫星天线改正，正确解算卫星姿态是GNSS数据解算中的关键步骤。
卫星的姿态指卫星的星体坐标轴XYZ在惯性系下的指向，其中Z轴始终指向地球地心，Y轴为卫星太阳能帆板的旋转轴，它始终与太阳-卫星方向垂直（为了最大程度地利用太阳辐射能量）。当然，Y轴同时也垂直于Z轴，最后的X轴与Y轴和Z轴组成右手坐标系。卫星、地球和太阳三者间的几何关系可见下图：
在非地影期的数据解算过程中，我们已知惯性系下的太阳位置向量xsun，卫星位置向量xsat，卫星速度向量vsat。那么便可以直接求得卫星的Z轴，
卫星指向太阳的向量为Sc2sun，
根据Sc2sun与xsat，可以叉乘求得卫星的Y轴，
最后由XZ轴可以算得卫星的X轴，
以上是卫星在非地影期间的姿态解算，然而在卫星地影期间则需考虑更多因素，首先需要求解太阳高度角β与卫星轨道角μ，其中β可以由轨道面法向向量W与xsun求得，
求解卫星轨道角μ则略微复杂些，首先需要求得地球指向午夜点的向量midnight,
之后便可根据midnight与xsat算得轨道角μ了，
其中，
由于向量的模等于向量点乘自身的单位向量tmpunit，因此
同时容易得到
因此，最后得到轨道角μ，其取值范围为-pai到pai
由β与μ即可判断卫星是否处于地影期，最后根据不同卫星系统的地影期姿态控制模式解算得到具体姿态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6108f3063dd2a5beac8977a59be62ad/" rel="bookmark">
			Python的闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闭包——函数嵌套
闭包是指在一个函数内部定义的函数，并且内部函数可以访问外部函数的变量，即使外部函数已经执行完毕，该内部函数仍然可以引用外部函数的变量。闭包使得函数可以保存状态信息，并且具有较长的生命周期。
在Python中，闭包通常是通过在一个函数内部定义另一个函数，并返回内部函数的方式实现的。内部函数可以访问外部函数的变量，并保持对这些变量的引用。下面是一个简单的闭包示例：
def outer_function(x): def inner_function(y): return x + y return inner_function closure = outer_function(10) result = closure(5) print(result) # 输出: 15 在上面的例子中，outer_function是外部函数，接受一个参数x。内部函数inner_function定义在外部函数内部，它访问了外部函数的变量x，并返回x + y的结果。通过调用outer_function并将返回的内部函数赋值给变量closure，我们创建了一个闭包。最后，通过调用closure并传入参数5，我们可以得到闭包的结果15。
闭包具有以下特点：
内部函数可以访问外部函数的变量，即使外部函数已经执行完毕。闭包函数可以持有外部函数的状态，因为它保留了对外部函数变量的引用。外部函数可以返回内部函数，使得内部函数可以在外部函数之外被调用和使用。 闭包在实际开发中有许多应用场景，例如在函数式编程、装饰器、回调函数等方面都可以使用闭包来实现灵活性和代码重用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e988a44832808a0baa7017cb4dda386/" rel="bookmark">
			Python中turtle的基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、turtle的简单介绍 turtle(海龟),是python自带的的一个基于thinker的一个绘图标准库，无需下载即可使用，能够通过坐标控制，抬笔落笔等操作绘制自己需要的图形。
二、turtle基础 1、在使用turtle时，首先要做的是导入turtle库 第一种导入方式：from turtle import * 从turtle库中导出所有的方法和属
注意：在使用该方法时无需添加任何的对象，就可以直接使用turtle库中的方法
第二种导入方式：import turtle as t (as t 是turtle太长了，使用不太方便，取个别名 t 使用 更加方便，你可以将t理解为一个自定义的对象，之后可以通过它调用turtle的方法)
下面我们分别使用两种导入方式来实现同一功能：
第一种：
from turtle import * forward(200) # 沿着当前方向前进200像素 circle(80) # 绘制一个半径为80像素的圆 goto(0,0) # 并且回到原点 done() # 维持界面 第二种：
import turtle as t t.forward(200) # 沿着当前方向前进200像素 t.circle(80) # 画一个半径为80像素的圆 t.goto(0,0) # 并且回到原点 t.done() # 维持界面 2、turtle的常用方法
# pensize()用于设置画笔的宽度，里面直接放整数即可。 """ setup() 用于新建画布 setup(width,height,startx,starty) width: 代表画布宽度，若是整数则代表有多少像素，若是小数则代表占屏幕的比率 height: 代表画布的高度，若是整数则代表有多少像素，若是小数则代表占屏幕的比率 startx: 正值则代表距离屏幕左边界多少像素，负值则代表距离屏幕右边界有多少像素 starty: 正值则代表距离屏幕上边界多少像素，负值则代表距离屏幕下边界有多少像素 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e988a44832808a0baa7017cb4dda386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d56bde2ee64af8b93d316d822f64ef/" rel="bookmark">
			【Linux】磁盘分区与永久挂载，实操模拟损坏文件系统，只要一个命令即可修复！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、磁盘基础内容
1、了解扇区的大小，以及与块的关系
2、磁盘的第一个扇区的内容
二、在Linux中使用硬盘的三大步骤
1、分区
----分区的作用：提高硬盘的性能
----分区的命令
----分区的分类：
----实操分区实验
2、创建文件系统
----文件系统类型：
----创建文件系统的命令
----查看是否文件系统是否创建成功
3、挂载（临时挂载及永久挂载）
----挂载的目的：
挂载点的条件：
----挂载的分类：
①临时挂载：mount
②永久挂载
三、模拟永久挂载配置文件错误重启系统失败，该如何解决
四、模拟损坏磁盘以及修复使用
五、总结
一、磁盘基础内容 1、了解扇区的大小，以及与块的关系 扇区的最小单位是512字节，一般块block的大小是8个扇区即4k（这个是可以改的，但是一般不改）
2、磁盘的第一个扇区的内容 所有磁盘的第一个扇区都存放了三个信息：MBR主引导记录、分区表、结束位
①MBR主引导记录：引导硬件去寻找操作系统，占位446字节
②分区表：记录分区表的信息，MBR分区最多为4个主分区，占位64字节，每个分区占16字节
③结束位：55 aa 占2字节
总结，总共加起来446+64+2=512字节
二、在Linux中使用硬盘的三大步骤 1、分区 ----分区的作用：提高硬盘的性能 ----分区的命令 fdisk -l 设备名：查看该设备的分区信息
fdisk 设备名：交互分区
fdisk交互添加分区的选项n添加新分区p打印分区表t修改分区id类型w保存m寻求帮助 ----分区的分类： 分区分类分区描述MBR分区
（fdisk针对2T以内）主分区可以直接使用，可以装操作系统，编号1-4扩展分区不能直接使用，大小1k存放逻辑分区表，需要逻辑分区，是特殊的主分区，编号1-4，但是最多1个扩展分区逻辑分区可以直接使用，大小不能超过扩展分区的大小，编号从5开始gdisk针对2T以上可以有128个分区不限制 ----实操分区实验 创建主分区
创建扩展分区
创建逻辑分区
创建交换分区
2、创建文件系统 ----文件系统类型： 操作系统文件系统Linux系统centos 6ext4centos7xfs（可以存放文件和目录数据，高性能的日志文件系统，擅长处理大文件）Windows系统64位操作系统ntfs（可以存64G以内的文件）32位操作系统fta32（最大存放4G的文件） ----创建文件系统的命令 查看相关命令，后面跟着的就是文件系统的类型
语法：mkfs.文件系统类型 设备名称
注意！！！！扩展分区不能创建文件系统！！！！只有1K，用来放逻辑分区表
swap分区也是需要创建文件系统的！！
语法：mkswap 设备名称
----查看是否文件系统是否创建成功 lsblk -f ：没有挂载情况下查看文件系统是否创建成功
df -hT：挂载的情况下查看文件系统是什么
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64d56bde2ee64af8b93d316d822f64ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a590b7e5c4b1c9326eed484304c1aa/" rel="bookmark">
			C#在Winform中使用Spire.OCR进行图片文字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，导入Spire.OCR包 使用Nuget安装Spire.OCR的包
将包中dll复制到项目文件夹&gt;bin&gt;Debug目录下
需要复制到的位置
将目标平台设置为X64
第二步，为说明Spire.OCR的识别效果添加几个常用的控件 添加了两个按钮控件，一个pictureBox控件和一个richTextBox控件
第三步，开始使用Spire.OCR进行图片文字识别 //选取图片按钮的代码 private void button1_Click(object sender, EventArgs e) { OpenFileDialog openFileDialog = new OpenFileDialog(); openFileDialog.Filter = "JPEG Files (*.jpg)|*.jpg"; openFileDialog.FilterIndex = 1; openFileDialog.Multiselect = false;​ if (openFileDialog.ShowDialog() == DialogResult.OK) { selectedPicture = openFileDialog.FileName; MessageBox.Show($"您选中的图片路径为：{selectedPicture}"); // 使用Image类加载图片 Image image = Image.FromFile(selectedPicture); // 将图片显示在PictureBox中 pictureBox1.Image = image;​ } else { MessageBox.Show("您本次没有选择任何图片！！！"); } } //开始识别按钮的代码 private void button2_Click(object sender, EventArgs e) { //创建扫描器 OcrScanner scanner = new OcrScanner(); //开始扫描 scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a590b7e5c4b1c9326eed484304c1aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e2ce4a206d6b51f9de7131202fea30/" rel="bookmark">
			C#使用dev的ChartControl控件绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备数据 画图首先需要有数据，本教程使用Bogus生成测试数据
这个教程建了一个demo类，结构如下所示: public class Demo { public int? Id { get; set; } public string? City { get; set; } } 只有两个属性，一个Id，一个City
使用Bogus生成测试数据的代码如下：
Randomizer.Seed = new Random(8675309); var Cities = new[] { "武汉", "长沙", "福州", "南昌", "厦门", "泉州" }; var orderIds = 0; var demoGenerator = new Faker&lt;Demo&gt;("zh_CN") .RuleFor(x =&gt; x.Id, f =&gt; orderIds++) .RuleFor(x =&gt; x.City, f =&gt; f.PickRandom(Cities)); var demos = demoGenerator.Generate(1000); 指定Randomizer.Seed可以使生成的测试数据不变，具体怎么使用bogus不是本文讨论的内容，暂且不表。
查看生成的内容
本教程假定需求是要统计每个City出现的次数，并绘制图表
对列表中City字段进行去重，可以使用linq中的distinct方法，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e2ce4a206d6b51f9de7131202fea30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c27f56ac08932168ccecd649277f2f/" rel="bookmark">
			C#HttpClient返回的结果为乱码的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C#的HttpClient返回的结果是乱码，如下图所示：
在实例化HttpClient时添加new HttpClientHandler() { AutomaticDecompression = DecompressionMethods.GZip }。
代码如下所示：
var httpClient = new HttpClient(new HttpClientHandler() { AutomaticDecompression = DecompressionMethods.GZip }); 现在返回结果正常，如下图所示：
new HttpClientHandler() { AutomaticDecompression = DecompressionMethods.GZip } 这段代码的作用是配置 HttpClient 使用 GZip 压缩方法来处理响应数据，通过这样配置可以确保 HttpClient 在与支持 GZip 压缩的服务器通信时自动处理压缩和解压缩，以便能够以更高效的方式处理数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5abbe439198f8756ea705a29c2c8010/" rel="bookmark">
			C# DataTable类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义 DataTable是C#中的一个类，表示内存中数据的一个表，命名空间为：System.Data
public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializabl 创建DataTable DataTable dt = new DataTable(); 添加DataColumn //第一种方式 dt.Columns.Add("姓名", typeof(string)); dt.Columns.Add("年龄", typeof(int)); //第二种方式 DataColumn dataColumn = new DataColumn(); dataColumn.ColumnName = "籍贯"; dataColumn.DataType = typeof(string); dt.Columns.Add(dataColumn); 添加DataRow //添加DataRow //第一种方式 DataRow dr1 = dt.NewRow(); dr1[0] = "小王"; dr1[1] = 23; dr1[2] = "湖北武汉"; dt.Rows.Add(dr1); //第二种方式 DataRow dr2 = dt.NewRow(); dr2["姓名"] = "小李"; dr2["年龄"] = 21; dr2["籍贯"] = "福建福州"; dt.Rows.Add(dr2); //选定一种方式之后，可以使用循环添加行 for(int i =0; i&lt;100;i++) { DataRow dr = dt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5abbe439198f8756ea705a29c2c8010/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/44/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>