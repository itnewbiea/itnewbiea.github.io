<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699f3877aa3e3a88aa03b7435d8cc9f4/" rel="bookmark">
			vue3&#43;electron开发桌面软件0基础入门，搭建全网最简单的项目！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用vite创建vue项目 npm init vite 1.1 创建完成后，安装依赖包并运行项目
npm install npm run dev 2.vue项目中安装Electron 2.1 electron包可能会安装失败，建议使用cnpm
npm i electron -D 3.定义入口文件 3.1 在跟目录下创建 electron文件夹，electron文件夹下创建主进程文件 main.js
3.2 然后在package.json配置入口，并删掉 "type": "module"
"main": "electron/main.js", 4.electron/main.js中增加窗口 4.1 electron代码不过多介绍，前往官网自行查看 《官方指南 | Electron》
const { app, BrowserWindow } = require('electron') const createWindow= () =&gt; { const mainWin = new BrowserWindow({ width: 800, //窗口宽度 height: 600, //窗口高度 }) mainWin.loadURL('http://127.0.0.1:5173/') } app.whenReady().then(() =&gt; { createWindow() app.on('activate', () =&gt; { if (BrowserWindow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699f3877aa3e3a88aa03b7435d8cc9f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0591ee2ad060757262eff54e0b3bc61b/" rel="bookmark">
			traffic control 之 egress 队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		egress队列主要作用于报文出方向，分为两类：无类队列和分类队列。下面分析下源码。
无类别队列 添加下面这条qdisc时，kernel端代码流程
tc qdisc add dev eth0 root tbf rate 1024kbit limit 1024kbit burst 1024
//linux/net/sched/sck_api.c static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n) struct net_device *dev; struct Qdisc *q; struct tcmsg *tcm; struct nlattr *tca[TCA_MAX + 1]; //解析出配置的参数，保存到tca中 nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL); tcm = nlmsg_data(n); clid = tcm-&gt;tcm_parent; dev = __dev_get_by_index(net, tcm-&gt;tcm_ifindex); q = dev-&gt;qdisc; /* It may be default qdisc, ignore it */ //默认的qdisc，handle为0 if (q &amp;&amp; q-&gt;handle == 0) q = NULL; struct netdev_queue *dev_queue; //a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0591ee2ad060757262eff54e0b3bc61b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b12ec9edee9f08a899080bca710aaf/" rel="bookmark">
			Kepware 读取16位或32位数据时，结果不是真实数据的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kepware采集PLC的数据“IW260”
IW260的值为61696，与PLC中显示的数值不一致。
61696二进制表示“11110001 00000000”,低8位“00000000”变为十进制为0；高8位“11110001”变为十进制为241，而241是IW260在PLC中显示的数值。由此可看出，当kepware读取PLC中的16位数据时，我们需要将高8位与低8位进行一个调换（同理读取32位数据），那么如何在kepware中实现呢？
我们需要修改我们创建“设备”时的默认参数设置。选择创建的设备名称，单击右键，选择【属性】，在弹出的属性编辑器中选择【寻址选项】，我们可以看到此处字节顺序默认为“大端字节序”，我们需要将其改成“小端字节序”.
字节顺序改完之后，我们再次监控数据，如下所示，值变为241
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49720238a4e4cc548b5dcf7c2e8a5af/" rel="bookmark">
			【无标题】页面切换继续保留状态请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 在 store.js 文件中
import Vue from ‘vue’;
import Vuex from ‘vuex’;
import axios from ‘axios’;
Vue.use(Vuex);
const store = new Vuex.Store({
state: {
taskId: null,
executionStatus: ‘执行中’,
intervalId: null,
},
mutations: {
setTaskId(state, taskId) {
state.taskId = taskId;
},
updateExecutionStatus(state, status) {
state.executionStatus = status;
},
setIntervalId(state, intervalId) {
state.intervalId = intervalId;
},
clearIntervalId(state) {
clearInterval(state.intervalId);
state.intervalId = null;
},
},
actions: {
fetchInitialData({ commit }) {
axios.get(‘第一个接口A的URL’)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49720238a4e4cc548b5dcf7c2e8a5af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51bc316023ac0a182fa4695924c81c9/" rel="bookmark">
			从Notepad&#43;&#43;运行python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NotePad++作为一个轻量级编辑器，平常跑一些简单的python代码就可以直接运行这个了，简单方便，就是要配置一下运行路径
从Notepad++可以直接配置快捷键运行当前python程序
点击 运行( R ) --&gt; 运行( R )
在弹出的输入框内输入以下命令，点击 保存… 分配一个名称与快捷键，即可以按快捷键运行当前程序。
#安装python的时候没有改动默认路径，直接安装 cmd /k cd /d "$(CURRENT_DIRECTORY)" &amp; python "$(FULL_CURRENT_PATH)" &amp; pause &amp; exit #安装python的时候安装到自己的安装目录了，将$(CURRENT_DIRECTORY)换成自己的python路径 cmd /k cd /d "E:\app\python" &amp; python "$(FULL_CURRENT_PATH)" &amp; pause &amp; exit 解释：
cmd /k : 告诉Notepad++接下来运行的是Windows命令行程序cd /d “$(CURRENT_DIRECTORY)” : 切换程序运行目录为当前目录，否则程序运行目录为Notepad++安装目录&amp; ：运行多条命令连接符python “$(FULL_CURRENT_PATH)” ： 运行当前程序，前提是python要设置在系统PATH，否则python换成安装目录全路径pause : 运行完程序后暂停exit： 弹出提示"请按任意键继续…" 运行完程序后不想退出，想在命令行继续奋斗。去除最后两个命令：
cmd /k cd /d "$(CURRENT_DIRECTORY)"&amp; python "$(FULL_CURRENT_PATH)" 运行完程序后不想退出python环境，想在python里继续测试变量：
cmd /k cd /d "$(CURRENT_DIRECTORY)"&amp; python -i "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51bc316023ac0a182fa4695924c81c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d4b724ff54c258db891bd45c88ce77/" rel="bookmark">
			如何在HTML中使用React
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		突发奇想
查了查真的可以,官方文档: 在网站中添加 React – React
开始 引入js &lt;!-- 开发环境使用 --&gt; &lt;script src="https://unpkg.com/react@18/umd/react.development.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"&gt;&lt;/script&gt; &lt;!-- Don't use this in production: --&gt; &lt;script src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;&lt;/script&gt; 这个js分开发板和生产版
开发环境为了能正常 debug调试, 源映射，具有热重载功能, (提高编译和重新编译速度,不会配置代码压缩，CSS 拆分, 代码压缩是很耗时的)Babel 是一个 JavaScript 编译器, 负责把 JavaScript 高级语法、转换为低规范以保障能够在低版本的环境下正常执行 生产版本如下
&lt;!-- 生产环境使用 --&gt; &lt;script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin&gt;&lt;/script&gt; Hello, world! &lt;div id="root"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; function MyApp() { return &lt;h1&gt;Hello, world!&lt;/h1&gt;; } const container = document.getElementById('root'); const root = ReactDOM.createRoot(container); root.render(&lt;MyApp /&gt;); &lt;/script&gt; 点击html运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d4b724ff54c258db891bd45c88ce77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d31d21ba3e1ba46cafec98bced7b1f/" rel="bookmark">
			carla中lka实现(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 首先计算之前检测出来的车道线的中线与输入图像的中线进行计算距离，，并设置不同的阈值对于不同的方向进行相关的调整。
一、车辆中心线 一般而言将摄像头架设在车辆的正中心轴上，所获得的图像的中间线极为车辆的中心。
def CalculateCurvature(binary_image, left_fit, right_fit, l_lane_inds, r_lane_inds): img_size = (binary_image.shape[1], binary_image.shape[0]) ploty = np.linspace(0, img_size[1]-1, img_size[1]) y_eval = np.max(ploty) # 找到图像中不为零的所有像素点的像素坐标 nonzero = binary_image.nonzero() nonzeroy = np.array(nonzero[0]) nonzerox = np.array(nonzero[1]) # 将这些不为零的像素点坐标分成x，y车道线中 leftx = nonzerox[l_lane_inds] lefty = nonzeroy[l_lane_inds] rightx = nonzerox[r_lane_inds] righty = nonzeroy[r_lane_inds] # 将这些像素点对应到世界坐标系中，然后拟合成二次曲线 left_fit_cr = np.polyfit(lefty, leftx*xm_per_pix, 2) right_fit_cr = np.polyfit(righty, rightx*xm_per_pix, 2) ## 以下计算本车在车道线中心的位置 dist_from_center = 0.0 if right_fit is not None: if left_fit is not None: # 摄像头位于图像中间，也是本车的中心 camera_pos = img_size[0] / 2 # 左右车道线最底端x坐标 left_lane_pix = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d31d21ba3e1ba46cafec98bced7b1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce6a9eecc2066b14c6d67d5715186dc/" rel="bookmark">
			【C语言】每日一题（找到所有数组中消失的数字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到所有数组中消失的数字，链接奉上。
这里简单说一下，因为还没有接触到动态内存，数据结构，所以知识有限，也是尽力而为，结合题库的评论区找到了适合我的解法，以后有机会，会补上各种解法
方法 暴力循环排序+分情况讨论 暴力循环 暴力循环依旧是最容易想到的，但是越容易想到的往往更耗费时间，也就意味着更容易超出时间界限。
思路：
双重for循环，外部控制1~n个数，内部遍历nums数组，两两比较，记录没有出现的数字，即为消失的数字
代码实现：
static int arr[99999];//创建数组 int* finddisappearednumbers(int* nums, int numssize, int* returnsize) { int count = 0;//计数器 int n = 0; for (int j = 1; j &lt;= numssize; j++) { count = 0;//每次进入要重置 for (int i = 0; i &lt; numssize; i++) { if (j == nums[i]) { count++; break; } } if (count == 0)//为0说明未出现 arr[n++] = j; } *returnsize = n; return arr; } 排序+分情况讨论 思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce6a9eecc2066b14c6d67d5715186dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652264d9d0f34c12daf7ffa1e7531711/" rel="bookmark">
			2027.win10配置组播ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景解决步骤 背景 win10 下QT App 无法接收arm开发板发送的组播消息，wireshark可以正常抓取组播信息。 解决步骤 1 安装组播协议
win10 更改适配器选项，找到对应网卡，右键属性，Microsoft 网络适配器多路传送器协议 ，点击安装可靠多播协议
2 将组播IP加入路由表,管理员权限打开cmd
route add 239.168.20.1 mask 255.255.255.255 0.0.0.0 IF 6 ， 其中6 为接口索引,具体参考route print 查看.
3 查看当前网卡的接口索引
route print
C:\WINDOWS\system32&gt;route print =========================================================================== 接口列表 8...10 7b 44 7d f1 df ......Intel(R) Ethernet Connection (2) I219-V 6...00 0e c6 79 a3 a2 ......ASIX AX88179 USB 3.0 to Gigabit Ethernet Adapter 9...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/652264d9d0f34c12daf7ffa1e7531711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68af13404be1245287967d5a12a7097/" rel="bookmark">
			虚拟环境open3d卸载重新安装，AttributeError: module ‘open3d‘ has no attribute ‘data‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：报错AttributeError: module 'open3d' has no attribute 'data'，open3d突然用不了
解决：卸载虚拟环境的open3d，重新安装。
步骤：
1.卸载
pip uninstall open3d 2.下载对应的whl包
open3d · PyPI
3.安装。将whl包复制到虚拟环境的/Lib路径下
打开conda命令行
激活环境
conda activate 环境名 cd 到以上路径
pip install open3d-0.17.0-cp310-cp310-win_amd64.whl 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8713733f5760a71fc82dbcf48c3e2f6b/" rel="bookmark">
			【JS】for 与 forEach 分别如何跳出循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for 循环 在 for 循环中，退出循环的两种方式：
break; 退出整个循环continue; 退出当次循环 let array = [1, 2, 3, 4, 5, 6, 7, 8, 9]; for (let i = 0; i &lt; array.length; i++) { if (array[i] === 6) { // break; // 退出整改循环， continue; // 退出当次循环 } // 其他操作... console.log('Loop:', array[i]); } // 某种情况下，也可以使用 return 完成终止循环 break 退出整个循环
continue 退出当次循环
forEach 在JavaScript中，forEach方法是用于遍历数组的方法，它会对数组中的每个元素执行指定的操作。
forEach方法本身并不提供直接的方式来跳出循环，但你可以使用一些技巧来跳出循环或模拟跳出循环的效果。
方法一：try{}catch(){} 结合 throw 抛错的方式退出循环
let array = [1, 2, 3, 4, 5, 6, 7, 8, 9]; try { array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8713733f5760a71fc82dbcf48c3e2f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f946d995ae8aeaf809e70372dada6909/" rel="bookmark">
			table表头颜色 element plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原图
预期
css :deep(.el-table__header) {background-color: #F5F7FA;}
:deep(.el-table tr) {background-color: rgba(0,0,0,0);}
:deep(.el-table th.el-table__cell) {background-color: rgba(0,0,0,0);}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43bfd3f8cf92e5f92f481f61b6f076ab/" rel="bookmark">
			新手入门Pinia状态管理库，看完这篇文章你就懂了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Pinia？ Pinia本质上依然是一个状态管理的库，它允许你跨组件/页面进行状态共享。 Pinia和Vuex的区别？ 与Vuex相比，Pinia提供了一个更简单的API，具有更少的规范，提供了Composition-API风格的API。最重要的是，在与TypeScript一起使用时具有可靠的类型推断支持。 和Vuex相比，Pinia有什么优势？ mutations不再存在，只有state，gettes，actions。更友好的TypeScript支持。不再有modules的嵌套结构，每个store都是独立的，互不影响。没有命名空间模块。无需动态添加 Store，默认情况下它们都是动态的。不再需要注入、导入函数、调用函数。支持插件来扩展自身功能。支持服务端渲染（SSR）。 上面列出的只是Pinia的一些主要的优点，还有其它的优点，需要大家在使用的时候慢慢去体会，下面一起来看看Pinia是如何使用的。
如何使用Pinia？ 安装Pinia yarn add pinia 或者 npm install pinia 创建Pinia // src/stores/index.js import { createPinia } from "pinia" const pinia = createPinia () export default pinia 挂载Pinia // src/main.js import { createApp } from 'vue' import App from './App.vue' import pinia from './stores' const app = createApp(App) app.use(pinia) app.mount('#app') 定义一个Store 我们需要知道 Store 是使用 defineStore() 定义的。并且它需要一个唯一名称，作为第一个参数传递。这个name，也称为id，是必需的，Pinia使用它来将store连接到devtools。返回的函数统一使用useXXX作为命名方案，这是约定的一种规范。 // src/stores/counter.js import { defineStore } from 'pinia' const useCounter = defineStore("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43bfd3f8cf92e5f92f481f61b6f076ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca5f6cd56fe00873cbc6fd872d0494c/" rel="bookmark">
			特训营第二天项目实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙理论知识（一定要记得） 防火墙的分类 包过滤防火墙 就是在路由器上写ACL
代理防火墙 相当于租房中介
缺点：速度慢
状态检测防火墙 一个数据包到达防火墙以后，如果策略允许通过，则放行。并建立状态化表项。
优点：处理后续的包速度快、安全性高
防火墙的模式 路由模式透明模式混合模式 区域划分 防火墙区域类型
优先级
所连区域
UNTRUST
5
外网接口
TRUST
85
内网接口
DMZ
50
服务器
LOCAL
100
访问我防火墙本身的流量
Inbound 由低到高
Outbound 由高到低
注意：优先级范围为1-100
实验拓扑 实验需求 实验配置 定义防火墙的区域类型 &lt;SRG&gt;system-view //进入到系统视图
[SRG]undo info-center enable //关闭中心输出命令
[SRG]sysname FW //名字叫FW
[FW]firewall zone trust // 定义信任区域
[FW-zone-trust]add interface g0/0/1 //把接口g0/0/1加入进去
[FW-zone-trust]quit
[FW]firewall zone dmz //定义DMZ区域
[FW-zone-dmz]add interface g0/0/3 //把接口g0/0/3加入进去
[FW-zone-dmz]quit
[FW]firewall zone untrust //定义非信任区域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca5f6cd56fe00873cbc6fd872d0494c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0770049ca4c482ff69f6cebe656662/" rel="bookmark">
			对接聚水潭-胜算接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取胜算账单数据【奇门接口】 官方API ：获取胜算账单数据【奇门接口】-聚水潭ERP开放平台
对接胜算接口的时候， 需要注意无法直接使用奇门的JKD ， 需要重写奇门的请求方法 ，
因为有部分参数，奇门JDK中不存在 ，需要手动填写。
比如：target_app_key 等。
测试DEMO:
import com.ruoyi.common.utils.StringUtils; import java.io.IOException; import java.util.*; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.Reader; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; import java.security.GeneralSecurityException; import java.security.MessageDigest; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.HashMap; import java.util.Map.Entry; import java.util.zip.GZIPInputStream; import javax.crypto.Mac; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; /* * * 对接聚水潭-胜算接口测试DEMO * */ public class jushuitanTest { // 验签参数 private static final String SIGN_METHOD_MD5 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0770049ca4c482ff69f6cebe656662/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3036117d3559f92998d709e7697d102/" rel="bookmark">
			Java程序，插入new Date（）时间，入mysql库后，时间比当前系统时间少了14个小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上图，第一个，是程序日志打印时间，第二个是插入到数据库中的时间，数据库为mysql，时区设置为北京
问题背景：直接在数据库中写sql插入，没有出现时间不同的问题，但是程序一运行就出问题。日志打印时间都是正常的，但是入库出问题。所以问题锁定在数据库上。
技术指导：解决方案出处
总结：执行指令：show variables like '%time_zone%';得到结果：
CST时区是一个非常混乱的时区，出现原因是美国曾多次修改时区。
直接导致的就是，Java默认会使用CST -0600作为默认设置，而北京作为标准的东八区时区，就会与CST的产生14个小时的时差
在服务器上执行“date”，看到时间，看到有CST字样 [root@dabiaoge ~]# date Wed Jan 9 21:54:23 CST 2019 继续知识点扫盲： CST时区 名为CST的时区是一个很混乱的时区，有四种含义： 美国中部时区Central Standard Time（USA）UTC-06：00 澳大利亚中部时区中央标准时间（澳大利亚）UTC + 09:30 中国标准时中国标准时区UTC + 08:00 古巴标准时古巴标准时区UTC-04：00 原因：CST的时区是一个很混乱的时区，在与MySQL协商会话时区时，Java会误以为是CST -0500或者CST -0600，而非CST +0800 解释原因是什么意思：
先来了解下美国的时区变化历史，美国规定每年从“3月11日”至“11月7日”实行夏令时，美国中部时区改为UTC-05：00；而“11月7日”至“3月11日”实行冬令时，美国中部时区改为UTC-06：00，博主的线上问题发现的时间是2019年1月9日，而此时美国中部的时区是UTC0600，而我们的时区是UTC0800，所以6+8=14个小时，因此线上的错误时间相隔14个小时。
解决方案：
1:数据库修改：
set global time_zone = '+08:00' set time_zone = '+08:00' 2：程序修改
数据库链接后加入指定的时区：?serverTimezone=Asia/Shanghai
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bebdbcc51b926743fb70486d6a329f5/" rel="bookmark">
			数据库多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SM数据库中进行以下操作：
1.查询选修了数据库的学生的学号；
select sno from sc,course where course.cname='数据库' and course.cno=sc.cno 2.查询数据库成绩不及格的学生名单（输出学号、姓名、成绩）；
select student.sno,sname,score from sc,course,student where course.cname='数据库' and course.cno=sc.cno and sc.score&lt;60 and sc.sno=student.sno 这里我漏了course.cno=sc.cno导致了错误，课程号没有连接导致输出全部不及格的信息
3.使用内连接查询每个学生及其选修课程情况；
select * from sc inner join student on student.sno=sc.sno 可以看到sc与student内连接，student每一行都与sc连接，他们的共有属性是sno，所以根据sno来匹配
4.使用左连接查询查询每个学生及其选修课程情况；
select * from sc left join student on student.sno=sc.sno 5.使用右连接查询查询每个学生及其选修课程情况；
select * from student right outer join sc on student.sno=sc.sno 不可以向上面一样直接改right，sc right join student
这样sc做主表
6.在表Teacher中，查询职工张三的上级领导信息；
select * from teacher t1 where t1.tno =( select t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bebdbcc51b926743fb70486d6a329f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c61094c33091c01f84f96b8a684047/" rel="bookmark">
			【Python】notepad&#43;&#43;实现python代码运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 搭建python环境 如果已经搭建好python环境，请忽略此步骤，直接填过即可。
1.1 下载python 下载地址：https://www.python.org/downloads/windows/
下载好版本后按照正常提示安装即可，安装过程记住安装位置，或者自定义安装位置。
1.2 设置环境变量 python安装好后，需要把安装路径添加到环境变量的PATH路径中，步骤如下：
a. 在系统设置中直接搜索 “环境变量” ，然后点击 “编辑系统环境变量”
b. 在弹出窗口中，选择 “高级” ==&gt; “环境变量”
c. 在弹出新界面中，双击 “Path” ，然后在弹窗口“新建” ⇒ “填入你的python安装路径” ==&gt; “确定”
d. 后面就是一路点击 “确定”， 这样就添加完环境变量了，最后在cmd命令窗口中输入“python”回车，如果显示如下图，看到python的版本信息，就说明环境变量已设置好。
2 用Notepad++ 编写代码 打开Notepad++软件后，新建一个demo01.py的文件，然后在菜单栏中选择 “语言” ==&gt; “P” ==&gt; “Python”
然后随意编写一段简单代码，如下：
编写完成后，记得 Ctrl + S 保存一下。
3 设置运行环境 a. 在菜单栏中选择 “运行” ==&gt; “运行” （或者直接按快捷键F5，效果一样）
b. 在弹出的运行窗口中的输入框内输入以下内容：
cmd /k D:\"Program Files (x86)"\python\python.exe "$(FULL_CURRENT_PATH)" &amp; ECHO. &amp; PAUSE &amp; EXIT D:\Program Files (x86)\python\python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95c61094c33091c01f84f96b8a684047/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e329481106a76c144820adc26ae61d/" rel="bookmark">
			【从零开始学习Linux】常用命令及操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽，哈喽，大家好~ 我是你们的老朋友：保护小周ღ 本期给大家带来的是 Linux 常用命令及操作，主要有三个分类：文件操作，目录操作，网络操作，创建文件 touch , 创建目录 mkdir , 删除文件或目录 rm , 文本编辑器 vim , 查看文件内容 cat , 文件覆盖写入 echo , 文件目录复制 cp , 文件目录移动或重命名 mv，以及网络相关命令，ps + grep 命令，查看指定进程，netstat + grep 查看进程的端口号及使用指定端口号的进程，sudo 执行特殊权限的任务，我们可以配合其他的一些指令来释放端口~ 更多指令操作，还请阅读下文呐~
本期收录于博主的专栏：Linux_保护小周ღ的博客-CSDN博客
适用于编程初学者，感兴趣的朋友们可以订阅，查看其它 “JavaEE基础知识”。
更多精彩敬请期待：保护小周ღ *★,°*:.☆(￣▽￣)/$:*.°★*
Linux 操作系统不像 windows 那样是图形化操作界面，而是操作的时候需要靠输入命令或一些快捷键进行的。Linux 也拥有自己的图形化操作界面，但是在实际的工作中，一般不会使用。
图形化操作界面的优势是，更适合大众上手，操作简单。
命令行操作系统的优势在于，执行更为高效，也是各大企业的生产工具。
命令行数据传输带宽占用非常低，图形化界面本质上背后还是对接指令。系统资源占用非常低，不需要支持图形处理。命令行适合通过脚本语言来实现批量重复的操作。 接下来，给大家带来的是 Linux 上常使用的命令。
使用终端软件 Xshell 登录云服务器后：
注意：对于 Linux 操作系统来说有时候输入命令没有提示就意味着操作成功！！！ 一、目录操作 1.1 ls （list 列出当前所有文件） 语法：ls [选项] [目录或文件]
功能：list 列出当前目录/指定目录中有那些文件，在Windows 中相当于双击了某个文件夹。
常用选项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18e329481106a76c144820adc26ae61d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924c3459c969dd2173a641275d5545e9/" rel="bookmark">
			基于C&#43;&#43;的OpenCV4入门基础--图形绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，基本图形绘制API
注意事项：
基本图形绘制API中都有线条的颜色、线宽、线型和 shift ：color: 线段的颜色，通过一个Scalar对象定义；thickness: 线条的宽度，默认是1；lineType: 线段的类型，可以取值8， 4， 和CV_AA， 分别代表8邻接连接线，4邻接连接线和反锯齿连接线。默认值为8邻接，为了获得更好地效果可以选用CV_AA(采用了高斯滤波)；shift: 坐标点小数点位数，默认是0。
2，代码示例：
//创建全黑的画布 Mat canvas = Mat::zeros(Size(512,512), CV_8UC3); namedWindow("canvas", WINDOW_AUTOSIZE); //相关绘制API: line rectangle circle ellipse //ps:如果线宽值小于0就是填充效果 line(canvas, Point(10,10), Point(400,400), Scalar(0,0,255), 1, LINE_8);//线段绘制 Rect rect(100,100,200,200); rectangle(canvas, rect, Scalar(0, 255, 0), 1, LINE_8);//矩形绘制 circle(canvas, Point(256, 256), 100, Scalar(255,0,0), 1, LINE_8);//圆绘制 RotatedRect rrt; rrt.center = Point2f(256, 256); rrt.angle = 45.0; rrt.size = Size(100, 200); ellipse(canvas, rrt, Scalar(0,255,0), 1, LINE_8 );//椭圆绘制 imshow("canvas", canvas); 3，添加文字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924c3459c969dd2173a641275d5545e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9718eba57d9e864fbe49edd7aa65afb6/" rel="bookmark">
			React 之 Router - 路由详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Router的基本使用 1. 安装react-router react-router会包含一些react-native的内容，web开发并不需要
npm install react-router-dom
2. 设置使用模式 BrowserRouter或HashRouter
Router中包含了对路径改变的监听，并且会将相应的路径传递给子组件BrowserRouter =&gt; 使用history模式HashRouter =&gt; 使用hash模式 import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; import { HashRouter } from 'react-router-dom'; const root = ReactDOM.createRoot(document.getElementById('root')); root.render( &lt;React.StrictMode&gt; &lt;HashRouter&gt; &lt;App /&gt; &lt;/HashRouter&gt; &lt;/React.StrictMode&gt; ); 3. 路由映射配置 Routes 包裹所有的Route，在其中匹配一个路由
&lt;Routes&gt; &lt;Route path='/' element={&lt;div&gt;home&lt;/div&gt;} /&gt; &lt;Route path='/about' element={&lt;div&gt;about&lt;/div&gt;} /&gt; &lt;/Routes&gt; Router5.x使用的是Switch组件
&lt;Switch&gt; &lt;Route path='/home' component={Home} /&gt; &lt;Route path='/about' component={About} /&gt; {/* 重定向 */} &lt;Redirect to='/home' /&gt; &lt;/Switch&gt; Route Route用于路径的匹配 path属性：用于设置匹配到的路径；element属性：设置匹配到路径后，渲染的组件 Router5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9718eba57d9e864fbe49edd7aa65afb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b1f3a568c05f9cb8776bf8c1c0ba76/" rel="bookmark">
			基于C&#43;&#43;的OpenCV4入门基础--认识Mat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，什么是Mat
Mat就是一个二维的行列矩阵，是图像文件的内存数据对象。其实就是图像的WxH像素点的内存空间。
2，Mat内存空间
头部Header包括图像的宽度，高度，和通道数等信息。
数据部分包括的就是图像像素点，一块连续的内存空间。
3，图像类型与结构信息
就是数据部分的存储方式，例如：
CV_8UC1：就是在内存的数据是8bit无符号数据，是单通道的灰度图。
CV_8UC3：就是在内存的数据是8bit无符号数据，是3通道的BGR图，内存的排列【B，G，R】连续存储。
4，获取图像基本信息
int width = img.cols;//宽 int height = img.rows;//长 int ch = img.channels();//通道数 int d = img.depth();//深度，8bit等 int t = img.type();//类型，无符号整数或者float 5，Mat对象创建与像素信息访问与遍历
代码示例：
//创建 Mat //创建空白(纯色)对象 创建填充值的 Mat 对象 创建单通道与多通道 Mat 对象 Mat t1 = Mat(256, 256, CV_8UC3);//高度 宽度 通道数 t1 = Scalar(255, 0, 0);//Scalar是标量，赋像素值 imshow("t1", t1); Mat t2 = Mat(Size(512, 512), CV_8UC3); t2 = Scalar(255, 0, 255); imshow("t2", t2); Mat t3 = Mat::zeros(Size(256, 256), CV_8UC3); imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b1f3a568c05f9cb8776bf8c1c0ba76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703e8ded487ceef2a51c858349258b24/" rel="bookmark">
			C# 比较两个数组中的内容是否相同的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里要比较的是两个数组中的内容是否相同，以int数组为例
以下示例返回false 因为是比较相同索引的值
int[] Arraya = new[] { 1, 2, 3, 4, 5 }; int[] Arrayb = new[] { 5, 3, 2, 1, 4 }; 以上两个数组内的值是相同的，都是1，2，3，4，5.具体的算法如下。
第一种就是最原始的方法，使用循环。
public static bool compareArr(int[] Arraya,int[] Arrayb){ bool areEqual = true; if (Arraya.Length != Arrayb.Length) { areEqual = false; } else { for (int i = 0; i &lt; Arraya.Length; i++) { if (Arraya[i] != Arrayb[i]) { areEqual = false; break; } } } if (areEqual) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703e8ded487ceef2a51c858349258b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9994fb2c115fcb02f9b2fe59a1f95283/" rel="bookmark">
			十六进制与ascii码互转 C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十六进制与ascii码互转 C语言实现
1. ascii转16进制
/** * func : char_to_hex() * desc : convert ascii to 16 hex * input : ascii * return: hex */ unsigned char char_to_hex(unsigned char chr) { if((chr&gt;='0')&amp;&amp;(chr&lt;='9')) chr = 0x30+(chr-'0'); else if((chr&gt;='A')&amp;&amp;(chr&lt;='Z'))//capital chr = 0x41+(chr - 'A'); else if((chr&gt;='a')&amp;&amp;(chr&lt;='z'))//little chr = 0x61+(chr-'a'); else chr = 0xff; return chr; } 2. 16进制转ascii
/** * func ：hex_to_char() * desc ：transform hex to ascii * input ：hex * return：ascii */ unsigned char hex_to_char(unsigned char hex) { if((hex&gt;=0x30)&amp;&amp;(hex&lt;=0x39)) hex = '0' + hex-0x30; else if((hex&gt;=0x41)&amp;&amp;(hex&lt;=0x5A)) // capital hex = 'A' + (hex - 0x41); else if((hex&gt;=0x61)&amp;&amp;(hex&lt;=0x7A)) // little case hex = 'a' + (hex - 0x61); else hex = 0xff; return hex; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9994fb2c115fcb02f9b2fe59a1f95283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3369b882a7db8d64142030ba16a8a187/" rel="bookmark">
			Java利用注解和AOP实现动态切换数据源（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
1.什么是主从复制？
2.主从复制的优点？
实现方式：
代码实现：
代码测试：
前言： 我们先介绍一下主从复制的概念以及主从复制的优点，扩展一下知识面。
1.什么是主从复制？ 主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。
当一台从服务器连接到主服务器时，从服务器会通知主服务器获取主服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新。
2.主从复制的优点？ 数据安全性高：做了数据的备份，发送单台服务器宕机也不会丢失数据。性能提升：一主多从的模式，主机负责写数据，从机负责读数据，提高性能。扩展性高：在QPS（Queries Per Second）大的情况下，可以通过简单的增加从服务器，提高系统稳定性。 知识贴纸：
QPS全称为Queries Per Second，即每秒钟处理的请求数量。对于一个高并发应用来说，QPS是非常重要的性能指标，它反映了应用处理请求的能力。在实际应用中，QPS的大小取决于应用的负载和应用本身的性能。
举个例子，假设有一个电商网站，这个网站每天需要处理100万个订单请求，那么每秒钟需要处理的订单数量就是1000000 / 86400 ≈ 11.57。因此，这个网站的QPS应该至少达到11.57。
我们为什么要去实现多数据源配置？
在一个项目中，我们可能访问的数据库资源并不止一个，可能是多个甚至更多，这个时候我们就需要去搭建多个数据源，进行动态的切换数据源进行一系列的增删改查操作。在QPS大的情况下，利用主从复制动态切换数据源，可以提高系统的稳定性和性能。在随着业务增长，数据量变大的情况下，我们可能会去分库分表，需要去查询多个数据库。 实现方式： 我们应该如何优雅的通过Java代码实现动态切换数据呢？
注解AOP（面向切面编程） 没错，我们只需掌握这两项技术就可以实现动态切换数据源，去提高系统的稳定性和性能。
代码实现： 0.准备环节： 配置一下我们的yml文件和pom文件
项目所需的依赖jar包：
&lt;!--引入mysql依赖jar--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入jdbc驱动依赖jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入druid数据连接池依赖jar--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; 多数据源配置的yml文件：
spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: master: url: jdbc:mysql://localhost:3306/test username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver slave: url: jdbc:mysql://localhost:3306/test_slave username: root password: root driver-class-name: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3369b882a7db8d64142030ba16a8a187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ded43fd1349f675a0728b30ca20dbe3/" rel="bookmark">
			uniapp 微信小程序分包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uniapp 微信小程序发布时，压缩完单包还是超过3M 解决方法：
1）uniapp运行微信开发工具时，勾选上“运行时是否压缩代码”
2）在manifest.jsom中设置分包
3）手动分包
具体可查看官方文档
首先新建一个跟pages同级的目录，例如pages_user
在pages.json中配置
//分包结构 pages_user/index/index.vue "subPackages": [{ //分包的路径 "root": "pages_user", // 分包中的页面路径配置 "pages": [{ "path": "index/index", "style": { "navigationBarTitleText": "", "backgroundColor": "#fff", "enablePullDownRefresh": false } }] }] // 分包的加载规则，一个包写一条 "preloadRule": { "pages_user/index/index": { "network": "all", "packages": ["__APP__"] } } 分包的注意事项：
【Tab页不能放在分包中】
【子包中的页面或组件只能被子包自己所调用，主包同理】
【uni_modules中的插件如果只在某一子包中使用，则可以直接放到该子包中，同时引用的方式换成了路径形式】
import uCharts from '../uni_modules/qiun-data-charts/js_sdk/u-charts/u-charts.js'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682287032034c677e11a0a77c8e2105b/" rel="bookmark">
			二十. Kubernetes 存储挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 存储挂载volumes卷的分类1. EmptyDir 示例2. hostPath 示例3. HostDir 示例4. NFS 网络数据卷示例(持久化卷) 二. 持久化存储的 PV&amp;PVC&amp;StorageClassPV 的创建与使用细节StorageClass 动态供应的创建与使用细节1. 存储制备器2. 允许卷扩展3. 挂载选项4. 回收策略5. 卷绑定模式6. 允许的拓扑结构7. 创建StorageClass指定provisioner示例 PVC 创建与使用细节 一. 存储挂载 先提出问题,或者存储挂载出现的原因: 通过k8s部署应用时,可能会生成或者读写一些配置文件,在应用部署完成后运行过程中也可能需要生成或者读写一些文件或数据,进而引出问题 这些文件或数据如何存储的这些文件或数据如何读取的如何做到持久化,即使k8s把当前pod杀掉重新拉起,怎样才能读取上一个版本生成的文件数据 我理解的卷挂载就是将文件或数据保存到容器外部指定的存储资源中例如主机文件系统、网络存储、云存储等,然后容器内部通过指定的方式例如路径,http请求等读取指定位置的文件或数据,将文件或数据挂载到容器内部的指定位置,进而解决了以下问题： 存储：卷挂载允许我们将文件或数据存储在容器之外，可以是主机节点的文件系统、网络存储（如 NFS）、云存储等。确保数据的持久性和可靠性，使得即使 Pod 被重新调度或重启，数据仍然可以被访问。读取：通过将卷挂载到容器内的指定路径，应用程序可以直接读取和写入这些文件或数据。应用程序可以像访问本地文件一样访问挂载的文件。持久化：通过卷挂载，即使 Pod 被杀掉重新拉起，以前生成的文件或数据也可以保留。因为卷通常与持久化存储关联，所以即使 Pod 终止并被替换，新 Pod 仍然可以挂载相同的卷，并继续访问之前生成的文件或数据 使用Docker时就有数据卷的概念,存在容器删除数据也被删除的问题，想要持久化使用数据，需要把主机上的目录挂载到Docker中，在K8S中默认情况下如果Pod删除，数据卷也会一起删除，k8s中提出了卷的概念,是docker数据卷的扩展, 参考博客简述一下怎么使用卷挂载一个挂载ymal示例与解释: 在编写部署应用pod的yaml时,或者通过deployment部署编写pod模板时,有几个属性:首先通过"spec.volumes"属性声明多个卷,指定卷名称,卷类型然后在容器中通过"spec.containers.volumeMounts"下的name指定使用spec.volumes中的哪个卷,通过"spec.containers.volumeMounts"下的mountPath指定将该卷挂载到容器的哪个位置后续容器应用在运行过程中,如果spec.containers.volumeMounts.mountPath位置需要读取数据,就会通过对应卷指定的方式到指定位置读取 apiVersion: v1 kind: Pod #类型是Pod metadata: labels: name: redis role: master #定义为主redis name: redis-master spec: volumes: #先声明需要的卷名称,卷类型 - name: redis-data #卷名称 emptyDir: {} #卷类型宿主机挂载点	- name: volumn-sls-mydemo #卷名称 emptyDir: {} #卷类型 - name: acm secret: secretName: &lt;ENVS&gt;-acm-&lt;APP_NAME&gt;-secret - name: config-volume configMap: name: redis-config containers: - name: master image: redis:latest env: #定义环境变量 - name: MASTER value: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/682287032034c677e11a0a77c8e2105b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f296861d35fb2f9100a3fad5addecce2/" rel="bookmark">
			ovs&#43;dpdk 三级流表(microflow/megaflow/openflow)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍在ovs+dpdk下，三级流表的原理及其源码实现。普通模式ovs的第一和二级流表原理和ovs+dpdk下的大同小异，三级流表完全一样。
基本概念 microflow
最开始openflow流表是在kernel中实现的，但是因为在kernel中开发和更新代码相对困难，并且这种方式不被认可。
所以将openflow流表实现移到userspace中，同时kernel中改成microflow cache，此缓存是一个hash表，需要精确匹配报文的所有字段。
megaflow
microflow的问题是如果报文任何字段发生改变，都会导致查找microflow失败，然后将报文上送userspace查找openflow流表来决定如何处理。
这意味着转发性能依赖于microflow流表建立时间，这段时间包括kernel上送miss事件userspace，以及userspace查找openflow流表并下发microflow流表的时间总和。
如果在短连接很多的场景下，microflow cache就会遇到很严重的性能问题，因为不仅要将miss事件上报userspace，还要在userspace查找openflow的多个table。所以就有了megaflow，用来替换microflow。megaflow cache采用模糊匹配的方法，这样就能大大减少miss事件。megaflow流表和openflow流表很类似，因为megaflow也支持根据报文任意字段匹配。但是megaflow相比openflow流表更简单，更轻量，
有两个原因:
a. megaflow不支持优先级，这样在查到megaflow流表后，就能立即停止查找，而不用担心错过更高优先级的流表而查找所有流表。
b. megaflow只使用一个流分类器，而不像openflow支持最多255个分类器。userspace下发megaflow流表时，需要将查找255个分类器用到的所有字段全部下发到megaflow。
尽管megaflow只有一个分类器，但是它需要为每个mask生成一个subtable，报文查找megaflow流表时，也需要查找多个subtable才能匹配到。如果有n个subtable表，最坏的情况下需要查找n次，这样看来基于分类器的megaflow相比于microflow，需要查找更多hash表。
ovs解决这个问题的方法是使用microflow作为第一级缓存，用来保存到megaflow流表的映射。这样的话，第一个报文查找microflow和megaflow失败后，上送miss事件到userspace查找openflow流表，然后下发megaflow流表，并在microflow建立映射，后续的报文就能在microflow命中，根据映射关系直接找到megaflow进行处理。
openflow
第三级流表，由最多255个table组成，每个table包含一个分类器，所有流表都插入到分类器中，具体实现可参考这里
三级流表的查找顺序
microflow在ovs+dpdk代码中，又被称为EMC(exact match cache)。
megaflow在ovs+dpdk代码中，又被称为dpcls(datapath classifer)。
从网卡接收到报文后，首先查找EMC表项，如果命中则直接执行action，如果miss则查找dpcls。
如果查找dpcls命中，则将规则插入EMC，并且执行action。还是miss的话，就查找openflow流表。
如果查找openflow命中，则将规则插入dpcls和EMC，并且执行action。还是miss的话，就丢包或者发给controller。
image.png
数据结构 主要看一下第一级和第二级流表的数据结构。
image.png
struct dp_netdev
代表一个datapath。在ovs+dpdk下，datapath也位于用户空间，所有netdev类型的网桥共享同一个datapath。
ports: 用于保存datapath下的所有端口，包括网桥的所有物理端口(不包含patch口)。
poll_threads: 用于保存datapath下的所有pmd线程相关信息。pmd线程的个数由如下逻辑决定:
//如果没有 pmd 类型的port，则pmd_cores为空 if (!has_pmd_port(dp)) { pmd_cores = ovs_numa_dump_n_cores_per_numa(0); //如果有pmd类型的port，并且指定了 pmd-cpu-mask，则按照指定的maks启动pmd线程 } else if (dp-&gt;pmd_cmask &amp;&amp; dp-&gt;pmd_cmask[0]) { pmd_cores = ovs_numa_dump_cores_with_cmask(dp-&gt;pmd_cmask); //如果没指定 pmd-cpu-mask，则默认每个numa节点上启动一个pmd线程 } else { pmd_cores = ovs_numa_dump_n_cores_per_numa(NR_PMD_THREADS); } struct dp_netdev_pmd_thread
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f296861d35fb2f9100a3fad5addecce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38eb0d60e2ef84821ccf8b28f61ad4f9/" rel="bookmark">
			debian,kali,ubuntu限制cpu最大使用率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kali修改cpu最大使用率 1.下载工具 apt install cpufreqd -y 2.修改/etc/cpufreqd.conf 文件内容如下没有文件就新建文件
# this is a comment # see CPUFREQD.CONF(5) manpage for a complete reference # # Note: ondemand/conservative Profiles are disabled because # they are not available on many platforms. ​ [General] pidfile=/var/run/cpufreqd.pid poll_interval=2 verbosity=4 #enable_remote=1 #remote_group=root [/General] ​ [Profile] name=Powersave Low minfreq=35% maxfreq=80% policy=powersave [/Profile] ​ [Rule] name=AC Rule ac=on # (on/off) profile=Powersave Low [/Rule] # stay in performance mode for the first minutes [Rule] name=AC Off - High Power ac=off # (on/off) battery_interval=70-100 #exec_post=echo 5 &gt; /proc/acpi/sony/brightness profile=Powersave Low [/Rule] ​ # conservative mode when not AC [Rule] name=AC Off - Medium Battery ac=off # (on/off) battery_interval=30-70 #exec_post=echo 3 &gt; /proc/acpi/sony/brightness profile=Powersave Low [/Rule] ​ # conservative mode when not AC [Rule] name=AC Off - Low Battery ac=off # (on/off) battery_interval=0-30 #exec_post=echo 3 &gt; /proc/acpi/sony/brightness profile=Powersave Low [/Rule] ​ ## # Special Rules ## # CPU Too hot!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38eb0d60e2ef84821ccf8b28f61ad4f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6929c429e592db55411d60aee198f5cb/" rel="bookmark">
			可以发AI&#43;无人机方向的论文居然有这么多专业！火焰识别、烟雾识别，人工智能毕业论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球无人机行业发展迅猛，无论是消费级、商业级的无人机，还是在军用、民用级别的领域，在人工智能的全面赋能，通过搭载各类设备的前提下，无人机可以在各种场景中执行复杂的观测任务，以计算机视觉为代表的AI智能检测与识别技术，开始逐步应用到行业的各个场景中。
因此，越来越多的专业论文方向，开始往AI无人机的方向靠拢，特别是交通物流专业、农林业、土木、建筑业、地质勘探、电力工程、环境环艺等专业，不深入了解AI无人机方向，都不知道，它竟然跟你的专业方向如此契合。
如果通过AI+无人机，森林火灾 可以及时遏制，洪涝灾害时可以在不影响救援力量的情况下，抢先发现等待救援的人，在2022年的重庆森林大火，今年的洪灾中，无人机也发挥了巨大的救援作用！
我们先来了解为什么无人机可以与人工智能AI识别技术融合？通过装载的摄像头，可对无人机拍摄的画面进行实时检测、可实现目标检测、目标识别、目标定位、目标追踪等功能。目前，一般是将前端智能（AI智能检测与识别功能）与后端智能（智能大平台进行统一分析）互相结合起来应用也是一种较为常见的方式。
基于火焰识别、烟雾识别等AI算法模型，可通过无人机监测森林、山林、自然生态保护区、景区、公园、农田等区域内是否存在消防火灾、秸秆焚烧等火患危险等。 一旦发现异常情况，可通过系统发出告警提醒。
无人机作为道路巡检的“好帮手”，相对传统人工路面巡查模式，具有操作性强、巡查视野广等特点；如果道路巡查线路长，车辆多、人员杂，难以有效全局管控；在出现恶劣天气、复杂地形、交通事故等情况下，人员安全难保障。但如果使用无人机，将大大降低巡检难度。
包括绿化带识别、烟雾识别、渣土车抛洒、河道垃圾识别等，对城市、森林、水域等特定区域环境进行监测，「无人机+AI」巡检可提供丰富信息，不断强化市容巡查力度，落实精细化管理措施，全面提升城市环境。 电力设备缺陷通常依靠人工巡检在视距内或借助望远镜等设备被发现，目前也使用无人机、巡检机器人、摄像头等智能方式。对于输电线路此类分布广、规模大的电力设备，人工巡检不仅工作量和难度极大，还面临着复杂、多变的户外环境，工作具有较高的危险性；图像采集设备采集到大量的电力设备图像后，再由工程师根据经验判断是否存在缺陷。这种方法的识别效果受限于工程师的技术水平和工作经验，且识别效率与工程师数量和工作时长相关；但通过AI智能巡查与智能运营，通过缺陷检测，可以快速判断问题所在。 当然，特别是对于工科类的小伙伴们来说，AI无人机+专业学科，已经成为了毕业论文方向的重要选择之一，AI无人机，也是论文发表的热门选题，特别电子信息、计算机科学与技术、核电技术与控制工程、电子信息、流体力学、电气工程、船舶电子电器工程、材料、交通信息工程与控制、航空航天等专业的小伙伴来说，论文发表方向，几乎与AI“强绑定”。
简单介绍一些关于的“AI无人机+各类学科”相关的基本应用后，我们还是把话题放到论文本身！
那么，咕泡人工智能，如何来帮助你解决的论文痛点呢？
无论你是什么专业，在咕泡AI，都能找到能满足你方向的AI技术大咖！
更好的AI入门首选课，更专业的满足你定制化AI需求。
点击*查看更多的AI行业专家https://ai.gupaoedu.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e61734c21759c3e6fe829f9dab3c6d/" rel="bookmark">
			基于FPGA的DHT11数字温湿度传感器测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DHT11数字温湿度传感器 本文将使用三段式状态机（Moore型）来对DHT11进行读取温湿度的操作，以便了解DHT11和熟悉三段式状态机的写法。
1.1、概述 DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度 复合传感器。它应用专用的数字模块采集技术和温湿度传感技术，确保 、产品具有极高的可靠性与卓越的长期稳定性。传感器包括一个电容式感湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接。
1.2、DHT11 外形及参数 DHT11 外形如下：
引脚说明 ：
VDD 供电3.3～5.5V DCDATA 串行数据，单总线NC 空脚GND 接地，电源负极 1.3、通讯方式 从上面的引脚说明可以看出来，DHT11是采用单总线（DATA脚）的方式来与上位机通讯，一次通讯时间4ms左右。单总线即只有一根数据线，系统中的数据交换、 控制均由单总线完成。设备（主机或从机）通过一个漏极开路或三态端口连至该数据线， 以允许设备在不发送数据时能够释放总线。单总线通常要求外接一个约 4.7kΩ 的上拉电阻，这样，当总线闲置时，其状态为高电平。由于它们是主从结构，只有主机呼叫从机 时，从机才能应答，因此主机访问器件都必须严格遵循单总线序列，如果出现序列混乱， 器件将不响应主机。
1.3.1、数据组成 数据分为整数部分和小数部分，数据格式如下：
一次完整的数据传输为40bit，高位在前。
数据格式：8bit湿度整数数据+8bit湿度小数数据 +8bit温度整数数据+8bit温度小数数据 +8bit校验和数据
数据传送正确时：校验和数据等于“8bit湿度整数数据 + 8bit湿度小数数据 + 8bit温度 整数数据 + 8bit温度小数数据”所得结果的末8位
示例一：
接收到的40位数据为： 00110101 00000000 00011000 00000100 0101 0001
湿度高8位 湿度低8位 温度高8位 温度低8位 校验位
计算：00110101+00000000+00011000+00000100=01010001
接收数据正确：
湿度：00110101(整数)=35H=53%RH00000000(小数)=00H=0.0%RH=&gt;53%RH+0.0%RH=53.0%RH
温度：00011000(整数)=18H=24℃00000100(小数)=04H=0.4℃=&gt;24℃+0.4℃=24.4℃
1.3.2、通信时序 主机发送一次开始信号后，DHT11 从低功耗模式转换到高速模式，待主机发送的开始信号结束后，DHT11 发送响应信号，送出 40bit 的数据，并触发一次信息采集。信号发送如下图：
主机和从机之间的通信可以通过以下几个步骤完成（主机读取 DHT11 温湿度数据的步 骤）：
步骤一： DHT11 上电后（DHT11 上电后要等待 1S 以越过不稳定状态在此期间不能发送任何指令），测试环境温湿度数据，并记录数据，同时 DHT11 的 DATA 数据线由上拉电阻拉高 一直保持高电平；此时 DHT11 的单总线引脚处于输入状态，时刻检测外部信号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e61734c21759c3e6fe829f9dab3c6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ecc8574f8310c926ce74cf9b7eaeb44/" rel="bookmark">
			CentOS自己搭建时钟同步服务实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、产生背景
2、操作过程
3、客户端操作
4、ntpd和ntpdate的区别
5、参考文章
1、产生背景 因为公司业务，需要使用一些网关设备上报监测实时数据，为了保障数据时钟一致性，所以需要提供一天时钟校验服务器。因为原来这个厂家的网关设备以前使用过其他时钟同步服务。但是最近发现设备掉线率很高，于是经过研究需要我们这边提供时钟同步服务器。
2、操作过程 2.1、准备一台授时服务器
检查是否安装ntp [root@lh-mqtt ~]# rpm -q ntp ntp-4.2.6p5-28.el7.centos.x86_64 如果没有则执行安装操作如下命令
安装ntp服务 yum -y install ntp 修改配置文件
vi /etc/ntp.conf 修改如下：
driftfile /var/lib/ntp/drift restrict default nomodify restrict 127.0.0.1 restrict ::1 # 配置允许连接服务端的网段 restrict 10.10.20.* mask 255.255.255.0 nomodify notrap # 配置时间服务器 server ntp.neu.edu.cn iburst server ntp.aliyun.com iburst server ntp.ntsc.ac.cn iburst # 配置在无法连接到时间服务器时将本地时间同步到客户端 server 127.127.1.0 fudge 127.127.1.0 stratum 10 includefile /etc/ntp/crypto/pw keys /etc/ntp/keys disable monitor 启动ntp服务并配置开机自启
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ecc8574f8310c926ce74cf9b7eaeb44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e258ecbe994309d48b2079120e325ee/" rel="bookmark">
			如何用思维导图&#43;Markdown提升工作效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常的工作中，我们常常需要记录一些信息、重要的事情或者一些重要的想法，Markdown就是一种非常好用的记录工具。搭配思维导图可以提高我们的记录效率，让我们的记录更加结构化。
为什么使用思维导图？ 思维导图可以帮助我们整理思路和信息，可以清晰地列出一个事物的各种属性和关系；便于我们记忆，更容易回忆某个问题的细节；便于交流，不同人之间可以通过同一份思维导图轻松地沟通交流。
为什么使用Markdown? Markdown 作为一种轻量级的标记语言，能让你专注内容创作，无需关心排版，可完全通过鼠标来完成文字输入，做到了真正的沉浸式写作体验，极大提高了效率。
Markdown因为 是一种纯文本，所以可以兼容所有的文本编辑器，即使是在不同的系统、网站上都可以显示同样的效果，你无需担心系统不兼容造成的格式混乱问题。
最后，Markdown学习成本非常低，你只需记住几个简单的语法，就可以很快上手。可以快速用来记录文字、图片、表格等等。
Markdown如何使用？ 简单记住几个语法即可熟练使用Markdown
标题：
用 # 的个数表示1-6级标题
文字
斜体：文字前后各加一个*
粗体：文字前后各加两个**
删除线：在文字前后各加两个~~
段落
文本前面加&gt;，表示引用一段文字
文本前面加***，表示分割线
列表
有序列表：文字前面加数字
无序列表：文字前面加-
插入
链接：[链接名称](链接地址）
图片：！[图片名称](图片地址）
GitMind+Markdown高效工作 1、用GitMind一键整理思路框架 当你准备写一篇文章时，事先理清出内容大纲，可以让你在行文时更加流畅，产出更加高效，而思维导图因为天然的结构化排版，可以很好的用来整理思路。
在GitMind中，你可以从头开始搭建一篇文章的框架，如果是写文章的大纲，你可以使用GitMind 提供的大纲模式，大纲模式下高效又快捷，而且GitMind支持大纲模式和思维导图模式快速切换，用大纲模式写的大纲，可一键转换成思维导图。
GitMind官网：
https://gitmind.cn/
如果你对于思维框架搭建也没有头绪，可以确定主题后，使用GitMind AI一键生成思维导图功能，快速帮你搭建一个完整的思路框架
2、用Markdown专注内容输出 用GitMind思维导图搭建好完整的文章框架后，即可在Markdown中专注内容输出啦，熟练使用常用的Markdown语法，让你的创作效率大大提升
3、常用Markdown工具 Typora https://www.typora.io/
一款简洁、美观的 Markdown 编辑器，支持实时预览、分屏编辑、多种主题等特性。
Visual Studio Code https://code.visualstudio.com/
微软推出的轻量级文本编辑工具，支持高亮 Markdown 的语法，并且可以实时预览。
Cmd Markdown Cmd Markdown 编辑阅读器 - 作业部落出品
作业部落出品，同时支持 Linux、Mac 和 Windows 操作系统，可以Web 在线创作。
总结 综上所述，将GitMind和Markdown结合使用可以进一步提高工作效率和信息管理能力。通过组织思维、多层次结构展示、快速编辑和更新、跨平台兼容以及可视化和文本结合等优势，可以更好地管理和呈现工作流程，提高工作效率和团队协作能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1a70bbbe763bdc4347839f3d4e96047/" rel="bookmark">
			【node.js】commonjs和es6 module的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonJS（简称CJS）和ES6模块（也称为ESM）都是用于在JavaScript中管理模块化的标准，但它们在语法和使用方面存在一些重要区别。以下是它们之间的主要区别：
语法差异：
CommonJS：使用require关键字来导入模块，使用module.exports来导出模块。ES6模块：使用import关键字来导入模块，使用export关键字来导出模块。 静态 vs 动态：
CommonJS：模块的加载是动态的，只有在运行时才能确定模块的依赖关系。ES6模块：模块的加载是静态的，编译阶段就能确定模块的依赖关系，这使得一些优化变得可能。 导入导出方式：
CommonJS：导入的模块是整个模块对象，可以在导入后对其进行修改，但这可能会导致一些意想不到的行为。ES6模块：导入的模块是只读的，不允许直接修改导入的内容。 异步 vs 同步：
CommonJS：模块的加载是同步的，可能会阻塞其他操作。ES6模块：模块的加载是异步的，可以更好地支持异步操作。 浏览器兼容性：
CommonJS：主要用于服务器端，浏览器环境需要使用工具（例如Browserify）来支持。ES6模块：由于浏览器对ES6模块的支持在不断改进，所以在现代浏览器中可以直接使用。 默认导出：
CommonJS：支持通过module.exports设置默认导出。ES6模块：支持通过export default设置默认导出。 总之，CommonJS主要用于服务器端，模块加载是同步的，适用于需要在运行时动态加载模块的情况。ES6模块在现代浏览器和Node.js中都得到广泛支持，支持静态加载和异步操作，更适合于现代Web开发。选择哪种模块系统取决于你的项目需求和目标环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1feb0c83361f7f74bcb1bedfa08022/" rel="bookmark">
			windows上点云库PCL-1.13.0&#43;VS2019的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件运行环境：
windows系统上，VS2019+PCL-1.13.0
PCL的安装包下载：Releases · PointCloudLibrary/pcl · GitHub
安装PCL-1.13.0-AllInOne-msvc2022-win64.exe
安装完后，环境变量会自动生成以下的变量
安装OpenNI2
在PCL 1.13.0的安装路径中，找到OpenNI2的安装包，并开始安装
解压pcl-1.13.0-pdb-msvc2022-win64.zip的文件
将其中的pdb文件复制到PCL安装目录的bin目录下
配置系统环境变量
在环境变量的Path中，添加以上8个路径
配置VS2019
附加包含目录：
C:\Program Files\OpenNI2\Include D:\software2\PCL 1.13.0\include\pcl-1.13 D:\software2\PCL 1.13.0\3rdParty\Eigen\eigen3 D:\software2\PCL 1.13.0\3rdParty\Boost\include\boost-1_80 D:\software2\PCL 1.13.0\3rdParty\FLANN\include D:\software2\PCL 1.13.0\3rdParty\Qhull\include D:\software2\PCL 1.13.0\3rdParty\VTK\include\vtk-9.2 附加库目录：
C:\Program Files\OpenNI2\Lib D:\software2\PCL 1.13.0\3rdParty\Qhull\lib D:\software2\PCL 1.13.0\3rdParty\FLANN\lib D:\software2\PCL 1.13.0\3rdParty\Boost\lib D:\software2\PCL 1.13.0\lib D:\software2\PCL 1.13.0\3rdParty\VTK\lib 附加依赖项_debug:
OpenNI2.lib pcl_commond.lib pcl_featuresd.lib pcl_filtersd.lib pcl_iod.lib pcl_io_plyd.lib pcl_kdtreed.lib pcl_keypointsd.lib pcl_mld.lib pcl_octreed.lib pcl_outofcored.lib pcl_peopled.lib pcl_recognitiond.lib pcl_registrationd.lib pcl_sample_consensusd.lib pcl_searchd.lib pcl_segmentationd.lib pcl_stereod.lib pcl_surfaced.lib pcl_trackingd.lib pcl_visualizationd.lib vtkcgns-9.2-gd.lib vtkChartsCore-9.2-gd.lib vtkCommonColor-9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa1feb0c83361f7f74bcb1bedfa08022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4204981925c0b9672df2ab52f04bfa/" rel="bookmark">
			MongoDB:简单的增删改查操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概述 本篇文章介绍在Navicat中对MongoDB数据库进行增删改查操作,在后面会介绍在Spring Boot中使用MongoTemplate对MongoDB数据库进行相关操作.如有必要可以先看看前面几篇文章.
MongoDB:MySQL,Redis,ES,MongoDB的应用场景
MongoDB:数据库初步应用
二.在Navicat进行增删改查操作 2.1 新增数据 MongoDB有以下几种方法对数据进行新增.
1) insert() 插入单个或者多个数据(文档);
2) save() 如果新新增数据主键存在那么就修改,如果不存在就新增.
3) insertOne()新增一条数据
4) insertMany()新增多条数据.
其中insertOne,insertMany与insert()的功能重复,所以这里就不多做介绍了.
2.1.1 insert()新增数据 示例代码如下:
db.user_search_record.insert({ uuid:"c5e41a77a87c776c7cdbe521294ddcf6" ,keyword:"剪纸用品" ,time:ISODate() ,userId:"0f6bea039ca64c9e81c7bdb43f1587ca"} ) 对照语法格式如下:
db.集合名称.insert( JSON格式的键值对 ) 这里需要主要的是db不能省略,不然会提示集合(表)名称未定义.
在上面案例中ISODate()获得的是格林威治时间,需要在上面+8才能获得北京时间,时间格式时候yyyy-MM-dd HH:mm:ss 下面代码添加多条记录,多条记录需要用 [ ] 符号,表示是一个数组.
db.user_search_record.insert([ { uuid:"c5e41a77a87c776c7cdbe521294ddcf6" ,keyword:"日用商品" ,time:ISODate() ,userId:"0f6bea039ca64c9e81c7bdb43f1587ca"}, { uuid:"c5e41a77a87c776c7cdbe521294ddcf6" ,keyword:"食品" ,time:ISODate() ,userId:"0f6bea039ca64c9e81c7bdb43f1587ca"}, ]) 在MongoDB的集合中存在_id字段,作为文档的主键,如果没有指定,会自动生成. 2.1.2 使用save()保存文档 save()的语法格式与insert()格式类似,示例代码如下:
db.user_search_record.save({ uuid:"c5e41a77a87c776c7cdbe521294ddcf6" ,keyword:"现切水果" ,time:ISODate() ,userId:"0f6bea039ca64c9e81c7bdb43f1587ca"} ) 上面代码没有指定_id所以等同于insert(),将新增一条代码.如果我们指定_id,将判断_id是否存在,如果存在那么就修改原数据,如果不存在,那么新增,示例代码如下:
db.user_search_record.save({ _id:ObjectId("64dc2cc9045b0000260056f5"), uuid:"c5e41a77a87c776c7cdbe521294ddcf6" ,keyword:"绿叶水果" ,time:ISODate() ,userId:"0f6bea039ca64c9e81c7bdb43f1587ca"} ) 在上面代码中需要注意_id是MongoDB特有的数据类型:ObjectId,所以需要用到ObjectId()这个方法对字符串进行转换,并且不能省略.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e4204981925c0b9672df2ab52f04bfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84310e6a52a4e8db3a280ae143d4dd87/" rel="bookmark">
			华为认证含金量如何
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为认证是指通过华为技术有限公司官方认证考试所获得的认证资格。华为认证主要分为三个级别：华为认证工程师（HCIE）、华为认证专家（HCNP）和华为认证技术专家（HCNA），每个级别都有不同的要求和考试内容。
华为IA/IP/IE认证--提取码:1234https://pan.baidu.com/s/1YJhD8QbocHhZ30MvrKm8hg 华为认证的含金量主要体现在以下几个方面：
行业认可度高：华为是全球领先的信息与通信技术解决方案供应商，其在全球范围内的市场份额和影响力较大。因此，获得华为认证将得到行业内的广泛认可和尊重。
就业竞争力强：华为认证是企业招聘中的重要参考，拥有华为认证资格的人员在就业市场上具有较强的竞争力。许多企业在招聘时会优先考虑具备华为认证的候选人。
技术实力证明：华为认证考试内容涵盖了网络、安全、云计算、存储等多个领域，通过考试能够证明个人在相关技术领域的实力和能力。拥有华为认证的人员通常在相关技术岗位上具备更高的技术水平和实战能力。
职业发展机会：华为认证不仅可以证明个人的专业技能，还可以为个人提供更多的职业发展机会。华为在全球范围内拥有广泛的业务和项目，拥有华为认证的人员有更多机会参与到华为的项目中，获得更多的成长和晋升机会。
总之，华为认证具有较高的含金量，能够为个人的职业发展和就业竞争力提供有力支持。然而，获得华为认证并不代表一定能够获得工作机会，个人的实际能力和经验同样重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df2d3d7440caaa0fd5775f3e2b30dc40/" rel="bookmark">
			python怎么保留两位小数?几种方法总结！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多小伙伴在学习python的时候可能会遇到对数据进行格式化输出的需求，其中最常见的需求为:保留几位小数。今天小编就以python怎么保留两位小数为例，来介绍一下python数据格式化的方法。
使用字符串格式化 大部分语言都可以使用字符串格式化的方法来实现保留两位小数的效果，python也不例外：
a = 12.345 print("%.2f" % a) # %代表格式化输出，.2代表小数点后保留两位，f代表数据类型是浮点型 使用round内置函数 python内置了一个名为round的函数，这个函数可以用来对数据进行格式化。代码如下：
a = 12.345 a1 = round(a, 2) #将a通过round函数处理后赋值给a1，传入的2代表保留两位小数 print(a1) 使用decimal模块 类似于java，python也专门提供了一个decimal模块用于精确运算，它也可以进行数据的格式化输出。代码如下：
from decimal import Decimal a = 12.345 Decimal(a).quantize(Decimal("0.00")) # 使用默认的进位方式（同round）“0.00”表示保留小数点后两位 注：python的round采用的进位方式比较特殊，有点类似于四舍五入，但准确的来说应该叫四舍六入五成双。有兴趣的小伙伴可以了解一下数值修约和基进偶舍。
以上就是常规的保留两位小数的方法，接下来介绍两种非常规的方法（使用字符串处理的方法，这种方法仅保留两位小数，不做四舍五入）
使用序列切片 原理很简单，只要找到小数点，然后进行切片即可。代码如下：
a = 12.345 str(a).split('.')[0] + '.' + str(a).split('.')[1][:2] #使用序列切片的方式，切出小数点前的数据，还有小数点后两位的数据，然后进行拼装 使用re模块 类似于切片，不过这次使用正则匹配来定位小数点位置。
import re a = 12.345 re.findall(r"\d{1,}?\.\d{2}", str(a)) #使用正则匹配，将符合规则（一个小数点前有很多位数字，小数点后面只有两位数字的片段）字符串片段取出来 小结 以上就是python怎么保留两位小数的五种方法。这五种方法各有自己的优缺点，读者可以自行选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca63d01f52e77507360799a2b533e27/" rel="bookmark">
			VS Code安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、VS Code下载与安装
1. 概述
2. 下载
3. 安装
二、编译器的下载、安装与配置
1. 概述
2. 下载
3. 安装
4. 配置环境变量
5. 测试
三、VS Code配置
1. 概述
2. 安装C/C++扩展
3. .vscode配置文件
3.1 c_cpp_properties.json
3.2 tasks.json 3.3 launch.json
4. 收纳生成的.exe可执行文件
四、常见问题
1. 中文乱码
2. 程序目录结构
参考文献
前言 本篇文章记录了本人安装并配置VS Code的全过程，包括VS Code下载与安装、Windows环境下GCC编译器的安装与配置、VS Code中C/C++语言的配置以及一些常见问题。本文适用于初次使用VS Code并在配置C/C++时存在困难的读者阅读，涉及一些概念可参考文章：
区分编辑器、IDE和编译器以及Shell、命令行和终端等概念_rangoo1989的博客-CSDN博客
一、VS Code下载与安装 1. 概述 Visual Studio Code简称VS Code，是一款功能强大的代码编辑器，与IDE（集成开发环境）不同，VS Code需要安装对应平台的编译器和语言的扩展。
2. 下载 官网 https://code.visualstudio.com/
3. 安装 选择安装路径。
勾选后点击下一步。（此处可以勾选上“通过Code打开”，即右击文件可以通过VS Code打开）
“添加到PATH”选项会自动将VS Code安装目录下的bin目录添加到用户环境变量中。（后文会提到用户变量与系统变量的区别）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca63d01f52e77507360799a2b533e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f513db2affa11285f0f203471ae48c/" rel="bookmark">
			JS中数组和对象有几种遍历方式？优缺点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数组：
1.for循环遍历 2.while遍历 3.for...in 4.for...of 5.forEach 6.map 对象：
1.for...in 2.for...of(少用,尽量不用,直接用会出错) 3.Object.keys() 4.Object.getOwnPropertyNames() 5.Object.getOwnPropertySymbol() 6.Reflect.ownKeys() for…in和for…of的区别：
1.推荐循环对象属性时使用for...in,遍历数组时使用for...of; 2.for...in循环出的是key，for...of循环出的是value； 3.for...of是es6新引入的特性，修复了es5引入的for...in的不足； 4.for...of不能循环普通的对象，需要通过Object.keys()搭配使用； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea51a38f78eafd5cbd0cfce95816f18/" rel="bookmark">
			tp6 微信分享码 存储到服务器（或者存储到oss）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档 不会
微信文档地址
请求的参数
这个非常重要我就传一个id 不需要这个就能获取到 传递多个参数的话就需要encodeURIComponent
开始调用接口—
public function getPromotionCode($uid) { $data = [ "page"=&gt;"pages/index/index", "scene"=&gt; $uid, 'env_version' =&gt; 'develop', //正式版为 "release"，体验版为 "trial"，开发版为 "develop"。默认是正式版。 'width'=&gt; 600, ]; $datass = json_encode($data); $url = "https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=".$this-&gt;getAccessToken();	//这里获取的token Log::info("URL ". $url); $res = curl_post($url , $datass); if (isset(json_decode($res , true)['errcode'])) { Log::info("code res " . $res); abortExecute("token获取失败"); } # 存储再服务器上的路径 getcwd 获取到public下的绝对路径 $path = getcwd().'/Qrcode'; if(!file_exists($path)){ //判断目录是否存在 mkdir($path); } $filename = md5(time()); $path = $path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ea51a38f78eafd5cbd0cfce95816f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2ae2fe720ea300528555b62fb572ac/" rel="bookmark">
			深度学习论文分享（七）Denoising Diffusion Probabilistic Models for Robust Image Super-Resolution in the Wild
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习论文分享（七）Denoising Diffusion Probabilistic Models for Robust Image Super-Resolution in the Wild 前言Abstract1. Introduction2. Background on Diffusion Models3. Related Work4. Methodology4.1. Architecture4.2. Higher-order degradations4.3. Noise Conditioning Augmentation 5. Experiments5.1. Comparison with Real-ESRGAN and SR35.2. Ablation studies5.3. Noise conditioning augmentation at test time 6. Conclusion 前言 论文原文：https://arxiv.org/abs/2302.07864
论文代码：
Title：Denoising Diffusion Probabilistic Models for Robust Image Super-Resolution in the Wild
Authors：Hshmat Sahak, Daniel Watson, Chitwan Saharia, David Fleet
在此仅做翻译
Abstract 扩散模型在单幅图像的超分辨率和其他图像到图像的转换任务中显示出很好的结果。尽管取得了成功，但它们在更具挑战性的盲超分辨率任务上的表现并没有超过最先进的GAN模型，在盲超分辨率任务中，输入图像没有分布，并且存在未知的退化。
本文介绍了一种基于扩散的盲超分辨模型SR3+，建立了一种新的技术。为此，我们提倡将自监督训练的复合、参数化退化和训练和测试过程中的噪声调节增强相结合进行自监督训练。通过这些创新，大规模卷积架构和大规模数据集，SR3+大大优于SR3。在相同的数据上训练时，它优于RealESRGAN, DRealSR的FID得分为36.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2ae2fe720ea300528555b62fb572ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d167e440f020f76e865caa7f1c502f14/" rel="bookmark">
			爆肝整理，pytest自动化测试框架-常用插件整理（必知必会）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 Pytest拥有丰富的插件架构。超过800个以上的外部插件和活跃的社区，在PyPI项目中以“ pytest- *”为标识。
1、pytest-html：用于生成HTML报告
一次完整的测试，测试报告是必不可少的，但是pytest自身的测试结果过于简单，而pytest-html正好可以给你提供一份清晰报告。
安装：
pip install -U pytest-html 用例：
import pytest # import time # 被测功能 def add(x, y): # time.sleep(1) return x + y # 测试类 class TestLearning: data = [ [3, 4, 7], [-3, 4, 1], [3, -4, -1], [-3, -4, 7], ] @pytest.mark.parametrize("data", data) def test_add(self, data): assert add(data[0], data[1]) == data[2] 运行完，会生产一个html文件 和 css样式文件夹assets，用浏览器打开html即可查看清晰的测试结果。
更加清晰美观的测试报告插件： allure-python（常用）
2、pytest-cov：用于生成覆盖率报告
在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况。
安装：
pip install -U pytest-cov 运行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d167e440f020f76e865caa7f1c502f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1cece7311faf9f90284f9d0cd5a7e42/" rel="bookmark">
			ViewPager清空fragment的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起初我是想通过viewPager获取Adapter 然后调用下面的方法 结果各种报错
image.png 描述： Fragment+ViewPager+Fragment 也就是 fragment中有一个viewPager组件 它包裹着n个fragment 我如何在再次进入 宿主fragment的时候 清空ViewPager中的fragment呢
首先看ViewPager的两种适配器的区别？
FragmentPagerAdapter 和 FragmentStatePagerAdapter 都是用于在 ViewPager 中管理 Fragment 的适配器，但它们在处理 Fragment 的生命周期和内存管理方面有一些区别。以下是它们的主要区别： FragmentPagerAdapter: FragmentPagerAdapter 适用于相对较少且固定数量的 Fragment。它在内存中保留了每个 Fragment 的实例，并通过 FragmentTransaction.attach() 和 FragmentTransaction.detach() 方法来管理 Fragment 的显示和隐藏。这种适配器适合用于不会频繁创建和销毁 Fragment 的情况，例如底部导航栏或选项卡视图。 主要特点： 会在内存中保留所有 Fragment 的实例，不会销毁它们。 适用于 Fragment 数量较少、不会频繁变化的情况。 FragmentStatePagerAdapter: FragmentStatePagerAdapter 适用于大量的 Fragment 或者 Fragment 的数据会经常变化的情况。它在 Fragment 不可见时会销毁其实例，只保留 Fragment 的状态。这种适配器通过 FragmentTransaction.add() 和 FragmentTransaction.remove() 来管理 Fragment 的添加和删除。 主要特点： 会销毁不可见的 Fragment 实例，以释放内存。 适用于 Fragment 数量较多、数据可能经常变化的情况。 总结： 使用 FragmentPagerAdapter 适合页面数量较少且固定，因为它在内存中保留了所有 Fragment 的实例。 使用 FragmentStatePagerAdapter 适合页面数量较多或者数据可能频繁变化的情况，因为它在 Fragment 不可见时会销毁实例，以释放内存。 您可以根据您的应用场景选择适合的适配器类型。如果您的页面数量有限且固定，您可以选择 FragmentPagerAdapter。如果您需要处理大量的 Fragment 或者 Fragment 数据可能经常变化，您可以选择 FragmentStatePagerAdapter。 我这里使用的是 FragmentStatePagerAdapter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1cece7311faf9f90284f9d0cd5a7e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f573d690307d9f7996b8614026d1be6/" rel="bookmark">
			mysql root密码忘记重置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ERROR 1045 (28000): Access denied for user ‘root’@‘localhost’ (using password: YES)
经过多次尝试，终于解决这个问题。以下是操作过程记录。关键为第二步。
1、确保 mysql server 已经停止运行查询mysql server 是否处于运行状态 sudo /usr/local/mysql/support-files/mysql.server status 如果正在运行，则将其停止
sudo /usr/local/mysql/support-files/mysql.server stop 以 skip-grant-tables 模式启动mysql
sudo /usr/local/mysql/support-files/mysql.server start --skip-grant-tables 2、修改密 码登录 mysql
mysql -u root 设置密码为空
mysql&gt; UPDATE mysql.user SET authentication_string=null WHERE User='root'; mysql&gt; flush privileges; mysql&gt; exit; 再次登录 mysql
mysql -u root 更改密码
mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'yourpasswd'; mysql&gt; flush privileges; mysql&gt; exit; 3、以正常模式启动 mysql sudo /usr/local/mysql/support-files/mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f573d690307d9f7996b8614026d1be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c12c44a776087fcdadc9cf7970e843/" rel="bookmark">
			合并所有文件夹中的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设我们有文件夹“测试一”和“测试二”（当然这里可以有很多个文件夹），并且每个文件夹下面还有多个文件夹，里面有大量文件，现在我们要将所有文件都放在一个文件夹中，方便我们后续整理。 1.“测试一”下的文件夹路径：F:\代码测试\测试一 “测试二”下的文件夹路径：F:\代码测试\测试二 目标文件夹路径：F:\代码测试\合并数据 、 2.代码实现 import os import shutil def merge_folders(source_folders, target_folder): if not os.path.exists(target_folder): os.makedirs(target_folder) #os.makedirs() 方法用于递归创建目录 for source_folder in source_folders: # roots代表序言遍历的根文件夹,root正在遍历的文件夹名字,dirs记录正在遍历的文件夹下的子文件夹集合,files正在遍历的文件夹中的文件集合 for root, dirs, files in os.walk(source_folder): #os.walk函数：遍历文件夹下文件并获得路径 for file in files: source_path = os.path.join(root, file) #用于路径拼接文件路径 target_path = os.path.join(target_folder, file) ''' 移动具体文件source_path只能是文本, target_path课题是文件也可以是目录（必须是存在的，所以需要判断代码12，13） ''' shutil.copy(source_path, target_path) print(f'Copied: {source_path} -&gt; {target_path}') print("所有文件夹合并完成") # 设置源文件夹列表和目标文件夹路径 #source_folders = ['F:\胃癌\非早癌','F:\胃癌\早癌','F:\胃癌\数据库里没有的病例'] # 替换为您的源文件夹路径列表 source_folders = ['F:\代码测试\测试一','F:\代码测试\测试二'] # 替换为您的源文件夹路径列表 target_folder = 'F:\代码测试\合并数据' # 替换为您的目标文件夹路径 # 调用合并函数 merge_folders(source_folders, target_folder) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c12c44a776087fcdadc9cf7970e843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4dc8615a9eca1bfd18f515898932091/" rel="bookmark">
			爆肝完成对比！cfa一级2024年考纲分析（附最新教材和课后题下载链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直在期待IFT的考纲对比表，但是可能是今年一级的变化太大了，所有，机构一直没有做，我不能再等了，自己花了一下午，对比了教材（下载见评论区），爆肝完成了这个对比表，基本上是ok的。我的结论是，2024年的cfa虽然变化大，但是却没有那么的难！
从变化来看，与往年相比，确实比较大，各种新增章节有6个，但是好消息是删除的章节有10个，另外虽然章节发生了大规模的扩张，多了20多个，但是整体来看，主要是把原有的一些内容拆成了很多章节，然后内容微调，关键是删除了几个比较难的问题，比如Financial Reporting Standards、Measures of Leverage、Technical Analysis等
所以各位就放心的去报考和复习吧！！！评论里我会逐步放最新的材料，目前已有的包括教材和课后题！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73063970a2b5b128745779eba956063c/" rel="bookmark">
			Python pygame(GUI编程)模块最完整教程（8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章：
Python pygame(GUI编程)模块最完整教程（7）_Python-ZZY的博客-CSDN博客
总目录：
README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com
23 进阶声音操作 参考资料：
https://pyga.me/docs/ref/sndarray.html
https://pyga.me/docs/ref/midi.html
MIDI格式 - 简书
23.1 通过MIDI输出声音 pygame.midi模块操作MIDI（乐器数字接口）。各种电子乐器与计算机通过MIDI进行交互。管理MIDI输入，可以从一些MIDI输入设备获取信息；将MIDI输出，则可以模拟某种乐器播放音符。
和pg.camera一样，midi不会自动导入到pygame中，所以需要额外的导入和初始化。
import pygame as pg from pygame import midi pg.init() midi.init() 下面的程序演示了如何通过midi播放从低到高的音阶（相邻音符之间相差一个半音）。
import pygame as pg from pygame import midi pg.init() midi.init() port = midi.get_default_output_id() # 获取默认的MIDI输出 midi_out = midi.Output(port) # 速度范围0 - 127，速度127时音符持续时间最长 velocity = 100 # 声调最高音符名为127 max_note = 127 try: for note in range(0, max_note + 1): print(note) midi_out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73063970a2b5b128745779eba956063c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ee653ab62c148bf54797de595e3da2/" rel="bookmark">
			BootStrap V5：现代化前端开发的必备工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在现代化的前端开发中，使用适当的工具和技术是非常重要的。BootStrap V5作为一款流行的前端框架，提供了丰富的组件和样式，帮助开发者快速构建现代化的网页界面。本文将详细介绍BootStrap V5的特性和使用方法，并通过代码示例演示其强大的功能。
什么是BootStrap V5 BootStrap V5是一款开源的前端框架，由Twitter开发并维护。它基于HTML、CSS和JavaScript，提供了丰富的组件和样式，使开发者能够快速构建响应式的网页界面。BootStrap V5具有易用性、灵活性和可定制性的特点，被广泛应用于各种Web开发项目中。
特性介绍 响应式设计 BootStrap V5支持响应式设计，可以根据不同设备的屏幕尺寸自动调整网页布局和样式，从而提供更好的用户体验。开发者只需使用BootStrap提供的CSS类，即可轻松实现响应式布局。
&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-6"&gt; &lt;!-- 左侧内容 --&gt; &lt;/div&gt; &lt;div class="col-sm-6"&gt; &lt;!-- 右侧内容 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 强大的组件库 BootStrap V5提供了丰富的组件库，包括导航栏、按钮、表格、表单等常用组件。这些组件具有统一的样式和交互效果，使网页界面看起来更加美观和专业。
&lt;nav class="navbar navbar-expand-lg navbar-light bg-light"&gt; &lt;a class="navbar-brand" href="#"&gt;Logo&lt;/a&gt; &lt;button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"&gt; &lt;span class="navbar-toggler-icon"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class="collapse navbar-collapse" id="navbarNav"&gt; &lt;ul class="navbar-nav"&gt; &lt;li class="nav-item active"&gt; &lt;a class="nav-link" href="#"&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74ee653ab62c148bf54797de595e3da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2475834ae6caa94602106deaf607e67/" rel="bookmark">
			无法打开源文件 “stdio.h“ /“stdlib.h“/“string.h等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有的标准库文件都是缺失的：
需要手动下载：Windows SDK 和模拟器存档 | Microsoft Developer
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/60/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>