<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfdac31ff942037d5eff82851eef8f6b/" rel="bookmark">
			MATLAB 给函数加上随机噪声/扰动的一种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行数值计算时，为了检验一个数值算法是否稳定，通常要给输入数据加上随机噪声。下面介绍一下向函数中添加两种随机噪声的方法，假设需要添加噪声的函数是 f ( x ) f(x) f(x)。
一、添加均匀分布噪声 添加[-1,1]上均匀分布噪声的公式为:
f δ ( x i ) = f ( x i ) + δ ( 2 R i − 1 ) f ( x i ) . f^\delta(x_i)=f(x_i)+\delta (2R_i-1)f(x_i). fδ(xi​)=f(xi​)+δ(2Ri​−1)f(xi​).其中， f δ ( x i ) f^\delta(x_i) fδ(xi​) 是添加了噪声的数据， δ \delta δ是相对误差水平， R i R_{i} Ri​是在区间 [ 0 , 1 ] [0,1] [0,1]上均匀分布随机数。
二、添加正态分布噪声 添加正态分布噪声的公式为:
f δ ( x i ) = f ( x i ) + δ R i n f ( x i ) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfdac31ff942037d5eff82851eef8f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30beeaa3c92d0dbfd148970dd1fd040/" rel="bookmark">
			专精特新申报材料有哪些及有什么好处，补贴20-100万
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专精特新申报材料，根据《中小企业划型标准》（工信部联企业〔2011〕300号）文件，与报统计局的法人单位基本情况表保持一致；符合《工业“四基”发展目录》所列重点领域，主导产品名称，填写最多3个细分领域主导产品名称；从事该产品领域的时间；主导产品类别及代码。申报成功，每户给予一次性20-100万奖补（以各地方具体奖补金额为准）。以下是华夏泰科（专业政策咨询、政策补贴申报）小编带来的专精特新申报材料有哪些及有什么好处，希望有所帮助。
一、专精特新有什么好处
1.资金扶持：每户给予一次性20-100万奖补（以各地方具体奖补金额为准）。
2.荣誉资质：颁发专精特新、“小巨人”企业证书。
3.政策帮助：重点对企业发展中遇到的困难，是“一企一策”给予帮助，如财政专项资金、税收优惠、企业知识产权保护、技术创新支持、市场开拓扶持、融资增信等。
4.政策扶持：在融资服务、技术服务、创新驱动、转型升级、专题培训等方面重点扶持。
5.企业人才：有专门的校园、社会招聘渠道，及人才培训优惠。
6.企业推广：提高企业资质荣誉、提高企业品牌和产品推广等。
7.企业发展：后期对企业在企业金融服务上有倾斜，提升本企业在金融市场融资吸引力，获得此荣誉（能获得此荣誉的企业代表企业的成长性好专精特新中小企业申报范围）后期在企业技改项目，培育项目资助申请上有政策倾斜。
8.北交所上市，企业融资。
9.南方专精特新混合基金支持：主要投资于专精特新企业的基金，股票（含存托凭证）投资占基金资产的比例范围为60%-95%，其中投资于该基金定义的“专精特新”主题证券的比例不低于非现金基金资产的80%。
二、专精特新申报材料有哪些
（一）基本信息
1. 企业划型
要求：根据《中小企业划型标准》（工信部联企业〔2011〕300号）文件，与报统计局的法人单位基本情况表保持一致。
佐证：报统计局的法人单位基本情况表
2. 所属行业
要求：按照《国民经济行业分类（GB/T 4754-2017)》的大类行业填写所属行业代码，与上报统计局的法人单位基本情况表一致。
佐证：报统计局的法人单位基本情况表
3. 上市情况
解析：企业有无上市计划，如有进行到哪一阶段，如股改前筹备阶段，股改、尽调阶段，辅导期或得到中国证监会正式受理。
佐证：与中介机构签订的服务协议、上市申报书、证券经营机构出具的企业处于辅导期的证明等。
（二）经济效益
1. 融资估值、新增股权融资情况
要求：近2年内是否获得新增股权融资，如有则提供证明材料。
佐证：包括但不限于验资报告，增资协议、投资协议及相应的股东支付凭证等。关于企业估值情况的证明文件，除估值报告外，可提供最新一期股权投资协议，需体现企业估值；上市企业估值可采用股价*股本计算，相应的证明材料可采用各股权交易系统网站上（如全国中小企业股份转让系统网站）上提供的行情信息页面截图。
2. 审计报告
要求：提供近两年年审报告，报告中需列明该年度研发费用支出金额。
佐证：近两年度审计报告、研发费专审报告等。
（三）专业化程度
1. 主导产品名称
要求：填写最多3个细分领域主导产品名称；从事该产品领域的时间；主导产品类别及代码。
解析：主导产品类别依据《统计用产品分类目录》填写。无法按该目录分类的，可按行业惯例分类。
2. 所属《工业强基工程实施指南（2016-2020 年）》领域
要求：符合《工业“四基”发展目录》所列重点领域
解析：工业强基即强化工业基础能力。主要包括核心基础零部件（元器件）、关键基础材料、先进基础工艺和产业技术基础（简称“四基”）。
3. “补短板”“填空白”“卡脖子”“替代进口”情况
解析：属于产业链供应链关键环节及关键领域，且能够“补短板”“锻长板”“填空白”的产品。
佐证：如是，10字以内描述具体领域与环节。
4. 主导产品市场占有率
要求：企业近两年主导产品市场占有率、所属省市排名及主导产品销售收入比重、出口额情况。
佐证：权威第三方机构出具的企业主导产品市场占有率证明文件（包括但不限于省级以上政府机构、行业协会或权威咨询机构作出的行业综合排名、单一产品排名等）；或者是企业自己测算，并注明数据出处，具有客观性、准确性的说明。
（四）创新能力
1. 研发机构
要求：包括企业自建或与高校、科研机构联合建立的研发机构，涵盖国家级、省级及企业自建，包括但不限于技术研究院、企业技术中心、企业工程中心、博士后工作站、院士工作站等。
佐证：研发机构证书、研究实验室图片等。
2. 产学研合作
要求：是否与高等院校、科研机构开展产学研合作，最好有实质性课题研究。
材料：产学研合作协议。
3. 知识产权情况
要求：拥有有效的知识产权，包括发明专利，实用新型专利，外观设计专利，软件著作权，首台套产品认定，新技术、新产品，II类、III类医疗器械临床批件等。
佐证：提供证书等佐证材料。
4. 核心业务采用信息系统支撑
要求：企业至少拥有1项核心业务采用信息系统包括但不限于研发设计CAX、生产制造CAM、经营管理ERP/OA、运维服务CRM、供应链管理SRM等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30beeaa3c92d0dbfd148970dd1fd040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca9909d6d10e9b2a3afd05054ab2ccb/" rel="bookmark">
			时钟源系统（时统系统）GPTP对自动驾驶的重要性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时钟源系统（时统系统）GPTP对自动驾驶的重要性
时钟源系统（时统系统）GPTP对自动驾驶的重要性
gPTP简介
一、时间同步要解决的问题
不知道大家还记得军训练习齐步走的场景吗？
齐步走的动作要领你还记得吗？
• 教官首先发出“齐步—–走”的命令，大家听到“齐步”二字后，开始调整动作，最终所有人实现动作同步。
• 听到“走”字后，所有人开始以同样的步伐（频率、步长）行走。
• 如果这种状态得以保持，后续任何时刻，大家的动作都是同步的。然而，由于各种原因，随着时间的推移，部分同学的动作会和其他人失调，为了解决这个问题，行进过程中，教官还会喊“幺二幺、幺二幺”的口号，这是为了让动作失调的人在行进过程中动态调整。
时钟同步的原理是类似的：
• 教官类似于网络中的主时钟，教官发出的的“齐步走”命令就是校时信号。
• 各个学员类似于网络中的从时钟，收到校时指令后，调整自己的时钟。
• 由于时钟晶振频率受环境因素（比如温度等）影响会发生变化，随着时间的流逝，各个时钟会慢慢变得不同步。为了解决这个问题，主时钟必须周期性的发出校时信号（类似于教官的“幺二幺、幺二幺”口号），供失调的节点动态调整时钟。
由此可见，如果要整个网络中的节点保持时钟同步，该网络必须解决以下问题：
选取一个主时钟主时钟动态的发出同步信号其他时钟根据同步信号同步自己的本地时钟。本地时钟的同步包含下面两个方面（通俗点讲就是，找到同步点，然后以同样的频率运行）：
o 绝对时间同步：如下图所示，它要求在同一时刻，A和B的显示时间一致，又称为相位同步。 相对时间同步：如下图所示，虽然在同一时刻A和B的绝对时间不同，但是相邻采样点之间的差值是相同的。也就是说，A和B对时间的度量是一致的（比如两个采样点之间的间隔A时钟测量出来是1ms，B时钟测量出来也是1ms）。它要求A和B的频率保持一致，又称为频率同步。
gPTP就是为了解决以上问题而诞生的。和其他校时协议不同的是，通过约束网络内的节点，它可以达到ns级的精度（6跳以内任意节点间最大时钟误差不超过1us），因此在车载、工业控制等对实时性要求较高的领域得到了应用。
二、gPTP的主要思想
体系结构
AVB域内的每一个节点都是一个时钟，由以下两个角色组成：
• 一个主时钟（Grandmaster Clock），它是标准时间的来源；
• 其他的都是从时钟（Slave Clock），它们必须把自己的时间和主时钟调整一致。
下图是一个简单的gPTP网络拓扑图： 它包含两种类型的节点：
• Time-aware end station：这类设备可以是系统内的主时钟（时间源，Grandmaster），也可以是从时钟（被校时的设备）。图中标注了802.1AS endpoint的就是这种设备。
• Time-aware Bridge：它可以是主时钟，也可以仅仅是个中转设备（类似传统的交换机），连接网络内的其他设备。作为中转设备，它需要接收主时钟的时间信息并将该信息转发出去（在转发的时候，需要矫正链路传输时延和驻留时间）。图中标注了802.1AS bridge的就是这种设备。
从上图还可以看到，时间信息是从主时钟出发，经由各个Bridge分发到所有的从节点。
2. 主时钟选取
gPTP中的主时钟，既可以默认指定，也可以通过BMCA(Best Master Clock Algorithm) 动态选取。 不过在车载或其他一些网络拓扑固定的应用场景中，一般不允许使用BMCA动态选取主时钟，而是默认指定。 这部分内容本文不做相关介绍，有需要可以查阅规范文档。
3. 绝对时间同步
下图包含一个主时钟（Master time）和一个从时钟(Slave time)，二者时间不同步。现在要把从时钟的时间校准到主时钟的时间，其中t1、t4为主时钟对应的时间，t2、t3为从时钟对应的时间。
主要流程如下：
主时钟在t1时刻发送Sync命令，从时钟在t2时刻收到同步指令。这时候从时钟并不知道主时钟是在什么时候发出这个Sync命令的，但是知道自己是在t2时刻收到该命令的。主时钟发送一个Follow_Up命令，该命令中携带t1的值。从时钟收到后，知道上面的Sync指令是在t1时刻发出的。此时从时钟拥有t1、t2两个值。从时钟在t3时刻发送一个Delay_Req命令，主时钟在t4时刻收到该命令。此时从时钟知道t1、t2、t3三个值。主时钟接着发送一个Delay_Resp响应从时钟的Delay_Req，该命令中携带t4的值。从时钟收到后，知道主时钟是在t4时刻收到的Delay_Req命令的。此时从时钟知道t1、t2、t3、t4四个值。我们假设路径传输延时是对称的，即去程的传输延时和回程的传输延时相等。从时钟可以根据下面的公式计算路径传输延时(path_delay)，以及自己与主时钟的偏差(clock_offset)： t2 – t1 = path_delay + clock_offset t4 – t3 = path_delay - clock_offset 由此可以算出： path_delay = (t4 – t3 + t2 – t1) / 2 clock_offset = (t3 – t4 + t2 – t1) / 2现在从时钟知道了自己与主时钟的时差clock_offset，就可以调整自己的时间了。另外，从时钟还知道自己与主时钟的路径传输延时path_delay，该值对于switch意义重大，因为在gPTP的P2P校时方式中，switch需要转发主时钟的校时信号，在转发的时候，需要将该值放在补偿信息中（后面章节会详细介绍）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca9909d6d10e9b2a3afd05054ab2ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6d3603367683972a0c39a644e426ac/" rel="bookmark">
			C语言用什么 IDE 好 - 除了 Visual Studio、VSCode、CLion 还有什么其他选择？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言新手用什么 IDE 好 - 除了 Visual Studio、VSCode、CLion 还有什么其他选择？
回答这样的问题之前，我们需要先了解一下，究竟什么是 IDE？
IDE 即Integrated Development Environment，是集成开发环境的英文缩写。顾名思义，IDE 就是一个集代码编写、分析、编译、调试等功能为一体的应用程序。
第一个真正意义上的 IDE 是 1964 年发布的 Dartmouth BASIC IDE（即 Basic 的前身）。当时的 IDE 采用命令列的方式来操作，而且仅具有一些简单的功能。
今天距离第一个 IDE 诞生已将近 60 年，市面上早已出现层出不穷的各种 IDE。在编译器琳琅满目的今天，开发人员可以根据自己的喜好和 IDE 的特点来选择不同的IDE作为开发工具。根据 PYPL 网站（https://pypl.github.io/IDE.html）的调查，谷歌下载搜索率排行前三的 IDE 分别是：Visual Studio、Eclipse、Visual Studio Code。
这些榜前的 IDE 都各有其优缺点，大家大可对比一下，选择适合自己的 IDE 来进行开发：
Visual Studio
Visual Studio 是微软开发的一款 IDE，广泛用于 Windows 平台。Visual Studio 可以根据用户需要，选择和安装多个语言的编译环境，比如C++、C#、VB。正因为如此，其安装包一般都比较大，安装时间也会比较长。Visual Studio 很多操作都是图形化页面，易于理解。安装完毕后即可开始新建项目并进行编码。
划重点：
开发功能十分齐全可安装多种编程语言，例如 C++、C#、VB 等操作页面图形化，易于理解安装包较大，下载和安装时间长社区版免费 VSCode
VSCode 严格来说并不完全是 IDE，它是微软推出的一款可扩展的轻量级编辑器。也就是说，使用 VSCode 开发 C 语言时，用户还得额外下载和安装本地编译器（GC/VC++/Clang）并配置环境变量后，才能编译运行代码。有兴趣动手的下伙伴可以查看官网进行操作（https://code.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6d3603367683972a0c39a644e426ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fd9e3cacb608c56af065fa7ddf1912/" rel="bookmark">
			Java Optional使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Optional一、Optional 简介二、创建 Optional 实例2.1 empty()方法2.2 of() 方法2.3 ofNullable() 方法 三、Optional的使用3.1 访问 Optional 对象的值3.1.1 get() 方法3.1.2 isPresent()方法3.1.3 ifPresent()方法 3.2 返回默认值3.2.1 orElse()方法3.2.2 orElseGet()方法3.2.3 orElse() 和 orElseGet() 的不同之处 3.3 返回异常3.3.1 orElseThrow()方法 3.4 转换值3.4.1 map()方法3.4.2 flatMap()方法3.4.3 map()和flatMap()的区别 3.5 过滤值3.5.1 filter()方法 3.6 Optional 类的链式方法 四、Java 9 增强4.1 or()方法4.2 ifPresentOrElse()方法4.3 stream()方法 五、总结 Optional 一、Optional 简介 Opitonal是java8引入的一个新类，目的是为了解决空指针异常问题。本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。
Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 Optional 的意义显然不止于此。
二、创建 Optional 实例 2.1 empty()方法 Optional&lt;User&gt; emptyOpt = Optional.empty(); emptyOpt.get(); 尝试访问 emptyOpt 变量的值会导致 NoSuchElementException。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68fd9e3cacb608c56af065fa7ddf1912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4aab7d12b0e3acec27e33508ca42e01/" rel="bookmark">
			Docker容器没有vi/vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 apt-get update apt-get install vim 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ee272fe37f71dae7e740a76ebb883d/" rel="bookmark">
			U3D-Building-UnityEditor不能打包进去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RT
今天测试unity building，发现只要building进来的scene中挂有相关UnityEditor.dll的脚本都不能build成功。
记录一下
如果我上面总结有误，或是有相关的官方说明地址，麻烦大家说一下。
感激不尽
解决方法：只要将 UnityEditor 命名空间下的脚本不要放到 GamePlay 逻辑中即可，这样就可以避免导致打包的问题。
或是在 脚本中使用宏定义：#if UNITY_EDITOR …(你的编辑器时的脚本逻辑) #endif 来避免使用了 UnityEditor 下的代码被编译到发布程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7412bc1675c16ad1f892b7f852906335/" rel="bookmark">
			nn.AdaptiveAvgPool2d() 与 nn.AvgPool2d() 模块的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nn.AdaptiveAvgPool2d() 与 nn.AvgPool2d() 模块的区别_jinfeng2411的博客-CSDN博客_nn.adaptiveavgpool
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7cb2884848006976d034a82006581c/" rel="bookmark">
			《五种时间：重建人生秩序》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 1 章 神灯和她的主人 【一句金句】
如果说时间可以解决一切问题，那么当下问题的答案会写在未来。让遥远未来的自己审视今天的决定，才能分辨出重要性和急迫感，那些纵然时光倒流还是会做的事情，就是今天需要的答案。
【一些收获】
1、重大事项优先级错乱：
是因为人生的道路分岔
各色的脸上各色的妆
主动和被动的看到别人的工作和生活 比较使人不再平静
2、人生起落图
3、追悼会策划表 我应该怎么活 “借假修真” 之旅
4、五种时间：生存时间、赚钱时间、好看时间、好玩时间、心流时间。
【一点思考】
有多久没有好好抬头看看星空了？有多久没有好好认真思考脚下的路该走向何方了？
平静麻木的过一天是一天。理想是什么？
第 2 章 生存时间 运动员密码 【一句金句】
所有的失败都因为曾经不够强大，来自缺乏和不满足。
【一些收获】
一、生存时间：因自身能力不足和外部条件限制而被动处于的时间分布。
二、书中也给了应对被动时间的建议：识别逆境，稳定情绪，缩短被动生存时间，开启主动生存时间。
三、可以残酷地说，你把你的时间、智识、精力和机会成本，都出卖给了合同地甲方。这句话很扎心，但又很现实。
四：“问题不可能由导致这种问题的思维模式来解决。” 补充：所有困难的问题，答案都在另一个层次出自爱因斯坦。同一层次的问题，很难靠同一层次的思考来解决。只有当你自己的认知层次提高之后，才能顺利解决低层次的问题，就好像大学生做小学生的数学题。也就是说，我们通常是无法在产生问题的层面上解决问题的。
五、破解生存时间难题：向运动员学习
1、了解自己
2、好的教练
3、刻意练习
4、拥抱竞争
5、赢得赛点
【一点思考】
读完这一章，发现自己确实处于生存时间，倒不是选择受限，而是畏首畏尾，不敢迈出舒适圈，当下充满挣扎和煎熬，但还是会苟且着，更害怕面对未知的不确定性。
说到底，还是想的太多，做的太少。实践出真知，解决问题最好的办法，还是去直面问题，去实践，去试错，去尝试。如果因为怕失败而不去尝试，只会画地为牢，自我束缚的。
第 3 章 赚钱时间 终极等式 【一句金句】
恐惧从来不是凭空被克服的，我们是通过训练获得实力而让恐惧逐渐缩小的。
所有的一切（体力、技能、知识），都可以通过训练变强，或者因沉沦变废。
【一些收获】
一、做成一件事情的力量往往不是来自事情本身。？ 那么力量可能来自：兴趣爱好、态度、情绪状态、坚持程度、认识自己、时间积累
二、赚钱时间的两个基本观点：1、正反馈 - 增强循环；2、长期坚持。
三、赚钱的定义：赚钱 = 创造价值的过程，赚钱时间就是：安排特定的时间用于提升自己的核心竞争力。
四、一个人很强的两个方面：1、核心竞争力强，在自己的专业领域稀缺；2、结构强，人很坚实，稳健。
五、赚钱时间的方法论：微小积累，持续改变，一万小时。
六、找到了书中自有黄金屋的答案：每当你停滞的时候，你在书中遇到的前辈就会出现引导你。像一个 NPC。
七、写作的核心竞争力不是写作本身，是思考和表达的综合结果。
八、判断社会需求：你所选定的领域是否为推动社会的整体发展和公共利益提供了社会价值。
【一点思考】
最开始没搞懂生存时间和赚钱时间，又把这章读了一遍，感觉作者想说的是从生存时间到赚钱时间，相当于是个进阶，通俗来讲就是先吃饱，再吃好。生存时间是受限的，被动的；赚钱时间则是自由的，主动的，包括建立目标或梦想，一步一步去提高核心竞争力。境界和能力都上了一个层次，赚钱就是顺带的。
附：所长林超在函数模型里的一张图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7cb2884848006976d034a82006581c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34622ce8ceceba00bc295a0b64c7ad70/" rel="bookmark">
			1.小程序开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目录结构
├── app.js ├── app.json ├── app.wxss ├── pages │ │── index │ │ ├── index.wxml │ │ ├── index.js │ │ ├── index.json │ │ └── index.wxss │ └── logs │ ├── logs.wxml │ └── logs.js └── utils 2.1 app.js
App({ /** * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */ onLaunch: function () { }, /** * 当小程序启动，或从后台进入前台显示，会触发 onShow */ onShow: function (options) { }, /** * 当小程序从前台进入后台，会触发 onHide */ onHide: function () { }, /** * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 */ onError: function (msg) { }, globalData: 'I am global data' }) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34622ce8ceceba00bc295a0b64c7ad70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2184e5d40759420a9a2cef47ca4e511f/" rel="bookmark">
			Required request parameter ‘userId‘ for method parameter type String is not present
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman：发送Http请求
springboot控制台打印Exception：Required request parameter ‘userId’ for method parameter type String is not present
解决问题方法之一：
127.0.0.1:8080/user/info?userId = 899-4d2841-89c18cd
看一下参数之间是不是写了空格， userId（空格）=（空格）xxxxxx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2454c8ccc9a25f39b86563a492225467/" rel="bookmark">
			css解决图片失真问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.背景图片失真
.con{ height:100vh; width:100vm; background: url(../../assets/login/background.png) 100% 100%; background-color: #2d3a4b; background-size: 100vm 100vh; image-rendering: -webkit-optimize-contrast; } 2.图片失真
img { image-rendering: -moz-crisp-edges; /* Firefox */ image-rendering: -o-crisp-edges; /* Opera */ image-rendering: -webkit-optimize-contrast; /*Webkit (non-standard naming) */ image-rendering: crisp-edges; \ -ms-interpolation-mode: nearest-neighbor; /* IE (non-standard property) */ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619fbaeef7d11b4e21bf070d4b519c8e/" rel="bookmark">
			Vue3警告：[Vue warn] Extraneous non-emits event listeners (changeParentProps) were passed to component
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue3中组件通信中（子传父）报出如下警告：
[Vue warn]: Extraneous non-emits event listeners (changeParentProps) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the “emits” option.
解决方法：声明下自定义事件名称即可
emits: [‘changeParentProps’]
&lt;template&gt; &lt;div&gt; 子组件 &lt;/div&gt; &lt;button @click="changeParentProps"&gt;更改父组件传过来的props&lt;/button&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import { defineComponent } from '@vue/composition-api' export default defineComponent({ emits: ['changeParentProps'], props: { data: { type: String, default: '' } }, setup (props, { emit }) { // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619fbaeef7d11b4e21bf070d4b519c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317dc68641fcf410189f6066457c2fae/" rel="bookmark">
			sql中的主键和外键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主键
主键的定义
主键：表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。当创建或更改表时可通过定义 PRIMARY KEY 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受空值。由于 PRIMARY KEY 约束确保唯一数据，所以经常用来定义标识列。
作用:
1）保证实体的完整性;
2）加快数据库的操作速度
3）在表中添加新记录时，DBMS会自动检查新记录的主键值，不允许该值与其他记录的主键值重复。
4）DBMS自动按主键值的顺序显示表中的记录。如果没有定义主键，则按输入记录的顺序显示表中的记录。
联合主键
关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。
对于联合主键，允许一列有重复，只要不是所有主键列都重复即可。
主键的特性
主键的必要性
在有些数据库中，虽然主键不是必需的，但最好为每个表都设置一个主键，不管是单主键还是复合主键。它存在代表着表结构的完整性，表的记录必须得有唯一区分的字段，主键主要是用于其他表的外键关联，以及本记录的修改与删除。
主键的无意义性
由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。
选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。
因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。
主键的选择
自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。
对于大部分应用来说，通常自增类型的主键就能满足需求
定义的自增性整数类型的主键一般使用是BIGINT NOT NULL AUTO_INCREMENT类型。
如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。
外键
外键的定义
如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。外键又称作外关键字。
由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个class的记录可以对应多个student表的记录。
为了表达这种一对多的关系，我们需要在student表中加入一列class_id，让它的值与class表的某条记录相对应。
这样，我们就可以根据class_id这个列直接定位出一个student表的记录应该对应到class的哪条记录。
在student表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。
外键并不是通过列名实现的，而是通过定义外键约束实现的：
//定义外键约束
ALTER TABLE student
ADD CONSTRAINT fk_class_id //外键约束的名称fk_class_id可以任意
FOREIGN KEY (class_id) //指定了class_id作为外键
REFERENCES class (id); //指定了这个外键将关联到class表的id列（即class表的主键）
1
2
3
4
5
class_id为学生表的外键。（此时student表中的class_id与class表中的id表示的含义相同）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/317dc68641fcf410189f6066457c2fae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f47ddfae5d0680a99436e9643743bed/" rel="bookmark">
			Mybatis整合在SSM时log4j出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错描述：
Failed to parse config resource: class path resource [mybatis/SqlMapConfig.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.logging.LogException: Error setting Log implementation. Cause: java.lang.NoClassDefFoundError: org/apache/log4j/Priority
借鉴这个文章中的两种方法
(10条消息) Spring + Mybatis整合log4j日志打印sql语句_傲娇的猫的博客-CSDN博客_mybatis 整合日志
经尝试第一种方法可以成功，第二种还是报之前的错误。
1.引入依赖
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
&lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
&lt;version&gt;2.6.1&lt;/version&gt;
&lt;/dependency&gt;
2.在Mybatis的config文件中配置 value="STDOUT_LOGGING"
&lt;settings&gt;
&lt;setting name="logImpl" value="STDOUT_LOGGING"&gt;&lt;/setting&gt;
&lt;/settings&gt;
可以成功运行项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb973aabb45e21028bb792bfe3d3ae9/" rel="bookmark">
			Mysql中Join查询使用与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Mysql中我们最终的一个操作就是查询，查询中又要当属join的应用，这里我们在SQL的层面介绍join的7中产寻区别于数据的覆盖范围，但是不同的DB他的join使用可能略有不同。eg：Mysql中是无法使用外连接查询。这个文章中的内容都来自与B站周阳老师，记录这个笔记主要也是为了加深一下自己的认识。
一、概述与建表语句 1、概述 在Mysql中如果对join的类型不说明则默认采用的内连接——inner join。关于join这几种情况的使用通过下面的这张图以及后边的示例语句就没有什么问题了，但是他在底层的机制会是怎么样呢？
join的连接查询语义是将两张表关联起来，综合两张表中的数据得到我们想要的数据。正常情况下我们知道每张表中都会对应多条数据，那么这两张表中的数据如何匹配起来让他们作为一组数据供我们使用呢？一种的最暴力的的就是让两张表做笛卡尔积，如果两表的数据分别为M、N那么最后产寻出来的数据就会使M*N。这通常不是我们想要的结果，如果我们给定条件那么Mysql就会按照指定的规则匹配数据，在匹配数据的过程中会有一张主表一张从表。为什么这样说呢？关联数据我们一定是按照一定的规则进行的，但是表中的数据都是在磁盘中的，我们就需要先把一张表中的数据读取出来，利用已经读取出来的数据作为条件再去匹配另一张表。
那么既然是按照条件匹配的那么就有能匹配上与不能匹配上两种情况，能够匹配上的自然需要正常显示，只显示匹配上的数据这就是inner join的情况。那么就还有一种情况就是我们把主表中的数据全部都显示出来，而有关从表中的数据匹配上的话就显示出来没有匹配上的话就不显示出来。单纯的left join、right join不再在where中添加任何条件的时候我们可以称之为只显示主表。这样的情况也是下图中最上面的两个展示的，他们的区别也是我们使用的left还是right，这两个关键字是可以相互替换的，他们可以告诉Mysql确定主表的规则：left join以left join左边的表为主表，right的反之。这里需要意识到的一点是这里确定左右并不是以on两边的区分，而是以表中的先后顺序。
没有匹配上的数据，他的所有列一定是空的，通过这个特性我们就可以在where中添加相应的条件实现对个别表独有数据的过滤。
个人理解的是就算我们使用了多个join实际上也是只确定了一个主表，其他的都是围绕这个主表展开，但是没有进一步验证。
下面是一种混合的情况，关于主表的确定是关键，我们可以通过explain来帮我们确定，只要是进行了全表扫描的那就是主表。
2、建表语句 CREATE TABLE `t_dept` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE TABLE `t_emp` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL, `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_dept_id` (`deptId`) #CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`) ) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; INSERT INTO t_dept(deptName,address) VALUES('华山','华山'); INSERT INTO t_dept(deptName,address) VALUES('丐帮','洛阳'); INSERT INTO t_dept(deptName,address) VALUES('峨眉','峨眉山'); INSERT INTO t_dept(deptName,address) VALUES('武当','武当山'); INSERT INTO t_dept(deptName,address) VALUES('明教','光明顶'); INSERT INTO t_dept(deptName,address) VALUES('少林','少林寺'); INSERT INTO t_emp(NAME,age,deptId) VALUES('风清扬',90,1); INSERT INTO t_emp(NAME,age,deptId) VALUES('岳不群',50,1); INSERT INTO t_emp(NAME,age,deptId) VALUES('令狐冲',24,1); INSERT INTO t_emp(NAME,age,deptId) VALUES('洪七公',70,2); INSERT INTO t_emp(NAME,age,deptId) VALUES('乔峰',35,2); INSERT INTO t_emp(NAME,age,deptId) VALUES('灭绝师太',70,3); INSERT INTO t_emp(NAME,age,deptId) VALUES('周芷若',20,3); INSERT INTO t_emp(NAME,age,deptId) VALUES('张三丰',100,4); INSERT INTO t_emp(NAME,age,deptId) VALUES('张无忌',25,5); INSERT INTO t_emp(NAME,age,deptId) VALUES('韦小宝',18,null); 二、SQL实例 1、内连接查询 -- 关联产寻中所说的独有应该以关联键对依据 -- 内连接，查询出来的是，关联键既在A又在B的 explain select d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bb973aabb45e21028bb792bfe3d3ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd612d6e86024da4f3b495db468efe0/" rel="bookmark">
			win10&#43;VS2017专业版，搭建pcl1.8.1开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载PCL_1.8.1 下载链接PCL，其中可以下载各个版本的pcl发布版，如果想要自己编译pcl，还可以下载对应的源码。本文所用测试数据的下载链接，提取码：qjeb。注意要下载与电脑系统对应的pcl，本人选择如下：
2.安装pcl 双击exe文件开始安装pcl库，出现下框时，选择“Add PCL to the system PATH for all user ”，如下图：
选择安装位置，
在安装过程中，会弹出安装OpenNI2的会话框，为了便于管理，本人将这个安装在了pcl文件夹下的OpenNI2文件夹中。
3.配置pdb文件 安装完pcl库之后，将下载的pdb压缩包解压，将解压得到的文件复制到pcl安装路径下的bin目录下 D:\Program Files\PCL 1.8.1\bin
4.配置环境变量 右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，在系统变量的Path变量中添加如下8个路径：
配置完成后重启电脑。
5.配置开发环境 （1）打开vs2017新建一个空项目“Project1”，右键选择项目名称，选择“属性”，“平台”选择“x64”，“配置”选择“Debug”或“Release”均可，只要“链接器”中的lib版本对应即可，下文会给出对应版本的lib文件名。
（2）在常规-&gt;VC++目录-&gt;包含目录中添加如下路径：
$(PCL_ROOT)\3rdParty\Boost\include\boost-1_64
$(PCL_ROOT)\3rdParty\Eigen\eigen3
$(PCL_ROOT)\3rdParty\FLANN\include
$(PCL_ROOT)\3rdParty\Qhull\include
$(PCL_ROOT)\3rdParty\VTK\include\vtk-8.0
$(PCL_ROOT)\include\pcl-1.8
$(PCL_ROOT)\3rdParty\OpenNI2\Include
（3）在常规-&gt;VC++目录-&gt;库目录中添加如下路径：
$(PCL_ROOT)\lib
$(PCL_ROOT)\3rdParty\Boost\lib
$(PCL_ROOT)\3rdParty\FLANN\lib
$(PCL_ROOT)\3rdParty\Qhull\lib
$(PCL_ROOT)\3rdParty\VTK\lib
$(PCL_ROOT)\3rdParty\OpenNI2\Lib
（4）在链接器-&gt;输入-&gt;附加依赖项中添加 D:\Program Files\PCL 1.8.1\lib和 D:\Program Files\PCL 1.8.1\3rdParty\VTK\lib中的所有.lib文件（已附于文末）。
6.测试 在Project1项目中，新建一个cpp文件进行测试。
#include&lt;iostream&gt; //PCL的PLY格式文件的输入输出头文件 #include&lt;pcl/io/ply_io.h&gt; //PCL对各种格式的点的支持头文件 #include &lt;pcl/point_types.h&gt; //点云可视化窗口头文件 #include &lt;pcl/visualization/cloud_viewer.h&gt; int main(int argc, char** argv) { // 创建点云（指针） pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); // 读入PLY格式的文件，如果文件不存在，返回-1 if(pcl::io::loadPLYFile&lt;pcl::PointXYZ&gt;("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd612d6e86024da4f3b495db468efe0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11329119d489ad7289b448be2e66c39a/" rel="bookmark">
			ubuntu18.04 安装Qt交叉编译环境目标机为rk3288
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文在虚拟机条件下安装成功，采用Ubuntu18.04 64位镜像作为编译环境。
需要准备材料 交叉编译器：目标机器为64位的使用 gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu（64位交叉编译器）.tar.xz
目标机为32位的使用：
gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xz
② qt5源码和qtcreator运行包（本例基于64位机器）
qt-everywhere-src-5.12.11（QT源码）.tar.xz
qt-opensource-linux-x64-5.12.11（QT开发工具）.run
安装环境（Ubuntu中安装） 第一步首先要换源：（不然慢到你怀疑人生）
sudo vi /etc/apt/sources.list
或
sudo gedit /etc/apt/sources.list
将下面的源复制进去（实测中科大的源是最快的，更多人推荐阿里源）：
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11329119d489ad7289b448be2e66c39a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ad3100bfe81c986ce4f7b0232fbd4de/" rel="bookmark">
			[hive]去掉字段中的空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive本身没有replace函数,可以用translate和regexp_replace函数代替
方法一
translate(列或符串,要转换的,转换成的)
方法二
regexp_replace(NVL(列名,""),"[\\s]+|[\u3000]+","")
该函数将匹配到的字符替换成""
说明:
[1]regexp_replace(要处理的列或字符串,"正则","将正则匹配到的字符串替换成该字符串")
[2]\\s+ 可以匹配任意的空白字符
\u3000 属于CJK字符的CJK标点符号区块内，是空白字符之一
+匹配前面的子表达式一次或多次
[3]regexp:正则
三扩展
1.去掉字段中的空格和逗号
regexp_replace(NVL(列名,""),"[\\s]+|[\u3000]+|[,]+","")
2.正则抽取:
regexp_extract 注:trim只能去掉首尾的空格或tab
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4ce96be7798634265ab0dc7297780c/" rel="bookmark">
			React生命周期方法和错误处理方法（挂载、更新、卸载、函数组件中生命周期替代方法useEffect、纯函数、副作用等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
React生命周期方法
挂载
contructor()
static getDerivedStateFromProps(props,state)
render()
componentDidMount()
更新
static getDerivedStateFromProps(props,state)
shouldComponentUpdate(nextProps,nextState)
render()
getSnapshotBeforeUpdate(prevProps,prevState)
componentDidUpdate(prevProps, prevState, snapshot)
卸载
componentWillUnmount()
函数组建中生命周期替代方法 useEffect
代替componentDidMount
代替componentDidUpdate
代替 componentWillUnmount
生命周期错误处理方法
相关概念
纯函数
副作用
static getDerivedStateFromError(error)
componentDidCatch(error,info)
React生命周期方法 以下生命周期方法按写的先后顺序被调用。
挂载 当组件实例被创建并插入 DOM 中时调用。
contructor() 如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。
一般只用于以下两种情况
通过给 this.state 赋值对象来初始化内部state。为事件处理函数绑定实例。 constructor(props) { super(props); // 不要在这里调用 this.setState() this.state = { counter: 0 }; this.handleClick = this.handleClick.bind(this); } 注意
调用了super(props) 后才能在构造函数里使用props变量。将props属性赋值给state后，props改变不会引起state的改变，应该在render函数中直接使用this.props.属性名。 static getDerivedStateFromProps(props,state) 在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。参数props,state都为更新后的内容，最后的返回的对象用于更新state。如果返回 null 则不更新任何内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d4ce96be7798634265ab0dc7297780c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb41ac541db45c97c0ec56ffcb1bae70/" rel="bookmark">
			对接抖店API-03 获取订单列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档 ： 抖店开放平台
DOUDIAN_URL ：https://openapi-fxg.jinritemai.com
如果前面获取accessToken 和签名都完成了， 那获取订单会简单很多，毕竟已经熟悉了需要的数据结构。
订单列表中只需要注意一下参数排序问题，分页过程就行， 因为接口返回的数据只有100条 ，所以需要多次请求， 跟分页查询类似，只到你查到想要的所有数据 ，然后在存在本地。
/*************************************** 订单详情查询 **********************************/ public void searchList(Integer day, PlatformManagementStore store) { String method = "order.searchList"; String methodStrUrl = "/order/searchList"; String shopId = store.getShopId(); //之前获取到的token //从redis获取 if (redisUtils.hasKey("tikTokAccessToken" + shopId)) { accessToken = redisUtils.get("tikTokAccessToken" + shopId).toString(); } else { JSONObject data = tokenCreate(shopId); if (null == data || "".equals(data)) { System.out.println("accessToken为空，请检查请求API是否正常获取到"); return; } accessToken = data.getString("access_token"); String expires_in = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb41ac541db45c97c0ec56ffcb1bae70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cbba85b7a39c94f11f19e4e7c25d71/" rel="bookmark">
			CH579 中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CH579中断 文章目录
前言一、pandas是什么？二、使用步骤 1.引入库2.读入数据总结 定时器中断 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
一、定时器中断 关键代码
#include "CH57x_common.h" /* 主函数 */ int main() { /* 配置定时器中断 */ GPIOB_ModeCfg(GPIO_Pin_11, GPIO_ModeIN_PD); /* 开启计数溢出中断，计慢1000个周期进入中断 */ TMR0_TimerInit(FREQ_SYS * 67); // 设置定时时间 FREQ_SYS * 67大约3秒 TMR0_ITCfg(ENABLE, TMR0_3_IT_CYC_END); // 开启中断 NVIC_EnableIRQ(TMR0_IRQn); // 开启引脚使能 while(1); } void TMR0_IRQHandler(void) // TMR0 定时中断处理函数 { if (TMR0_GetITFlag(TMR0_3_IT_CYC_END)) { // 中断处理函数 TMR0_ClearITFlag(TMR0_3_IT_CYC_END); // 清除中断标志 } } 二、GPIO中断 关键代码
#include "CH57x_common.h" /* 主函数 */ int main() { GPIOA_ModeCfg(GPIO_Pin_14, GPIO_ModeIN_PU); //中断引脚1，上拉输入 GPIOA_ITModeCfg(GPIO_Pin_14, GPIO_ITMode_LowLevel); //配置低电平触发中断 GPIOB_ModeCfg(GPIO_Pin_4, GPIO_ModeIN_PU); //中断引脚2，上拉输入 GPIOB_ITModeCfg(GPIO_Pin_4, GPIO_ITMode_LowLevel); //配置低电平触发中断 NVIC_EnableIRQ(GPIO_IRQn); while (1); } /* 串口中断函数 */ void GPIO_IRQHandler(void) { if (GPIOA_ReadITFlagBit(GPIO_Pin_14)) { // 中断处理程序 GPIOA_ClearITFlagBit(GPIO_Pin_14); //清除中断标志 } if (GPIOB_ReadITFlagBit(GPIO_Pin_4)) { // 中断处理程序 GPIOB_ClearITFlagBit(GPIO_Pin_4); //清除中断标志 } } 总结 提示：这里对文章进行总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04cbba85b7a39c94f11f19e4e7c25d71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c774531127b1e56f93f2b906d76658cb/" rel="bookmark">
			C&#43;&#43;指针详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、指针的概念 指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。
先声明几个指针放着做例子：
int*ptr; char*ptr; int**ptr; int(*ptr)[3]; int*(*ptr)[4]; 二、指针的类型 由于指针是一种独立的类型，这种类型的变量存储的值是内存地址 ，所以指针也是有类型的，指针的类型是指指针本身的类型，从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：
int *ptr; //指针的类型是int * char *ptr; //指针的类型是char * int **ptr; //指针的类型是 int ** int (*ptr)[3]; //指针的类型是 int(*)[3] int *(*ptr)[4]; //指针的类型是 int *(*)[4] 三、指针所指向的类型 当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
从语法上看，你只需把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：
int *ptr; //指针所指向的类型是int char *ptr; //指针所指向的的类型是char int **ptr; //指针所指向的的类型是 int * int (*ptr)[3]; //指针所指向的的类型是 int()[3] int *(*ptr)[4]; //指针所指向的的类型是 int *()[4] 在指针的算术运算中，指针所指向的类型有很大的作用。
对于指针所指向的类型，我的理解是指针所指向的内存区，这片内存区所代表的类型，所以指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。
四、指针的值 指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。
指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。
在这里要记住，指针的值就是指针的所指向的内存地址的首地址，而指针的指向则是以XX为首地址的一片内存区域。
五、指针本身所占据的内存区 指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。
指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。
六、指针的算术运算 指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：
char a[20]; int *ptr=a; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c774531127b1e56f93f2b906d76658cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c938386ab165497b744ecfa152c1cb5c/" rel="bookmark">
			Sring-IOC控制反转（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sring IOC 介绍 控制反转（inverse of control） 这个不是什么技术，而是指的一种思想。它的目的是直到我们设计出更加松耦合的程序。
控制：在java中指的是对象的控制权限（创建、销毁）
反转：指的是对象控制权由原来 由开发者在类中手动控制 反转到由Spring容器控制
一句大白话:bean的创建和销毁交给spring容器管理
IOC大概的原理 pom.xml：
&lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; myBean.xml：
&lt;beans&gt; &lt;bean id="orderDao" class="com.llz.dao.impl.OrderDaoImpl"/&gt; &lt;bean id="orderService" class="com.llz.service.impl.OrderServiceImpl"/&gt; &lt;/beans&gt; 工厂类：
public class MyBeanFactory { private static Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); static{ try { //加载myBean.xml,解析xml,将所有的配置的内容放入到map中 //使用dom4j和xpath技术,导入这两个jar包 InputStream is = MyBeanFactory.class.getClassLoader().getResourceAsStream("myBean.xml"); Document doc = new SAXReader().read(is); List&lt;Element&gt; list = doc.selectNodes("//bean"); for (Element element : list) { //获取id和class属性 String id = element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c938386ab165497b744ecfa152c1cb5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c632b506405a6e12fa53ab0703543891/" rel="bookmark">
			acwing蓝桥杯c&#43;&#43;A/B组辅导课--第三讲 数学与简单dp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.买不到的数目 小明开了一家糖果店。
他别出心裁：把水果糖包成4颗一包和7颗一包的两种。
糖果不能拆包卖。
小朋友来买糖的时候，他就用这两种包装来组合。
当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。
你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。
大于17的任何数字都可以用4和7组合出来。
本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。
输入格式
两个正整数 n,m，表示每种包装中糖的颗数。
输出格式
一个正整数，表示最大不能买到的糖数。
数据范围
2≤n,m≤1000
保证数据一定有解。
输入样例：
4 7 输出样例：
17 本题考查性质：两个数p，q，最大不能凑出的数是(p-1)*(q-1)-1
可以用打表的方式找规律
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; int main() { int p,q; cin&gt;&gt;p&gt;&gt;q; cout&lt;&lt;(p-1)*(q-1)-1; return 0; } 2.蚂蚁感冒 长 100 厘米的细长直杆子上有 n 只蚂蚁。
它们的头有的朝左，有的朝右。
每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。
当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。
这些蚂蚁中，有 1 只蚂蚁感冒了。
并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。
请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。
输入格式
第一行输入一个整数 n, 表示蚂蚁的总数。
接着的一行是 n 个用空格分开的整数 Xi, Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c632b506405a6e12fa53ab0703543891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675124934b2cc4a6d85f5845b8c1f821/" rel="bookmark">
			低功耗蓝牙芯片CH579系列开发记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低功耗蓝牙芯片CH579系列开发记录 文章目录 低功耗蓝牙芯片CH579系列开发记录前言一、CH579系列芯片1.1 引脚排列1.2 引脚描述1.3 系统结构1.4 最小系统 二、资料下载2.1 关键资料2.2 视频资料 三、评估开发板3.1 开发板概览3.2 开发板购买 四、开发初体验4.1 环境搭建4.2 跑通例程4.3 下载编译后的HEX文件 小结 前言 本系列文章主要关于CH579系列芯片开发记录，CH579是基于ARM架构Cortex-M0内核的32位低功耗蓝牙MCU ，由南京沁恒微电子股份有限公司开发。其片上集成低功耗蓝牙BLE通讯模块、以太网控制器及收发器、全速USB主机和设备控制器及收发器、段式LCD驱动模块、ADC、触摸按键检测模块、RTC等丰富的外设资源。
一、CH579系列芯片 1.1 引脚排列 CH579系列有两款芯片，分别是CH579M和CH579F，引脚分布如下。
1.2 引脚描述 CH579M资源会多一些，比CH579F多了几路AD通道，串口以及PWM驱动引脚。
详细引脚定义如下：
QFN48为CH579M，QFN28为CH579F。
1.3 系统结构 CH579芯片结构框图
1.4 最小系统 CH579M
CH579F
二、资料下载 2.1 关键资料 官方网站有提供详细的资料下载，包括原理图、例程、下载器驱动等资料，链接如下。
CH579系列官方资料
2.2 视频资料 官方视频资料没有CH579的，但是有其他CH系列的，官方例程都有良好封装，直接调用封装库就可以，小伙伴们可以类比着看。
官方CH系列开发B站视频
三、评估开发板 3.1 开发板概览 CH579系列有一款评估开发板，可以方便调试，入门十分推荐，还有就是买的时候不要忘记同时买配套专用的WCH烧写器，与板子配合十分方便，尤其在打印输出和调试方面。
3.2 开发板购买 开发板购买
官方WCH烧写器
四、开发初体验 4.1 环境搭建 开发环境选择keil5，没装的伙伴下面连接传送。
keil5官方下载
下载安装好keil后需要安装CH系列芯片包才能编译CH579系列例程，下载连接如下。
开发工具包
下载好后解压，打开文件夹选择CH579EVT/PUB目录下的.pack文件双击安装。
安装连接开发板的驱动
CH340驱动下载
安装烧录程序的软件
WCH烧写软件
安装之后打开，如果是英文界面可以通过view/UI language/simplified Chinese。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/675124934b2cc4a6d85f5845b8c1f821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5249ee60fb169e1d7c5ccaac1cc0413/" rel="bookmark">
			Java实现自己想要的代码生成器！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频教程 大家好，我录制的视频《Java 之优雅编程之道》已经在 CSDN 学院发布了，有兴趣的同学可以购买观看，相信大家一定会收获到很多知识的。谢谢大家的支持……
视频地址：http://edu.csdn.net/lecturer/994
提出问题 “ 如何利用 Java + Freemarker 实现代码生成器?
” 解决问题 * 前言 * 做业务开发的时候，经常要根据建立好的数据库表，生成相关的 Model , DTO , Service, Controller , DAO 等等。包括基本的增删改查。而这些细活往往比较简单且没有挑战性，纯粹苦力活。因此，根据公司的框架，开发一个代码生成器是很有必要的。
这里：假如你有一定的 java 基础；假如你熟悉 freemarker 模板引擎；假如你熟悉 MVC 框架；假如你熟悉 Spring Data 框架
* 技术选型 * 由于代码生成器是要生成很多文件的，包 Test.java , TestDTO.java ,TestController.java , TestServiceImpl.java , ITestService.java , TestDAO.java 等等这些文件。所有考虑用 freemarker 强大的模板引擎，制作相关的模板。
* 实现思路 * 首先，假如在数据库中有一张表 ay_test. CREATE TABLE "public"."ay_test" ( "id" varchar(32) COLLATE "default" NOT NULL, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5249ee60fb169e1d7c5ccaac1cc0413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c4bfc13cfd037cd0c3aea1d80fec73/" rel="bookmark">
			java项目文件预览的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、转换pdf方式（推荐）二、pageoffice三、openofffice方式 一、转换pdf方式（推荐） 说明：该方式采用插件（Aspose.Words）将文件转化为pdf文件（需要转化到web服务器的下面），然后再使用浏览器自带的pdf查看器进行文件预览（缺点：只可用于word及pdf文件）。
前端调用代码 AttachMent.previewFile=function(obj,fileId){ var callback = function(data){ var dataObj = new com.ibms.form.ResultMessage(data); var filePath = dataObj.data.filePath; var fileType = dataObj.data.fileType; if(filePath == 'none'){ _layer.msg("文件不存在！", { time: $lang.tip.time, shade: $lang.tip.shade }); }else{ var title = '在线预览'; var width = $(window.top).width()*.9; var height = $(window.top).height()*.9; var url = __ctx + "/oa/system/sysFile/preview.do?fileId="+fileId; if('doc,docx,pdf'.indexOf(fileType) != '-1'){//文件转为pdf url += "&amp;url=oa/system/sysFilePDFPreview.jsp"; var width = $(window.top).width()*1; var height = $(window.top).height()*1; var title="在线预览"; DialogUtil.open({ height:height, width: width, url: url, isResize: true, showMax: false, //是否显示最大化按钮 showToggle: false, //窗口收缩折叠 title: title, showMin: false, sucCall:function(rtn){ //rtn作为回调对象，可进行定制和扩展 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c4bfc13cfd037cd0c3aea1d80fec73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995c81327f44ff4675c931ef6ebec43d/" rel="bookmark">
			Vue脚手架报错--Component name “School“ should always be multi-word解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
所遇问题
解决方法
因为自己在给组件命名时没有使用大驼峰和横线拼接单词，编译的时候一直报错，实际上是语法检测的问题，不同人或公司的语法标准不同，所以会常报错，一般情况下，关闭语法检测。
所遇问题： 通过上图报错信息可知：组件名有一些问题，（信息翻译来就是组件名“School”和“Student”应该总使用用横线拼接的多个单词组成的）。
解决方法： 在项目目录里找到vue.config.js，如果没有就自己创建；
然后再该文件里添加下面代码；
const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ lintOnSave:false //关闭语法检查 }) 保存再次编译即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c4db049d350e7c938d378a4c42c9c4/" rel="bookmark">
			Pycharm中解决Pandas包读取.csv文件时因编码格式出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们用pandas读取.csv文件出现“UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc3 in position 0: invalid continuation byte”等原因是，是因为文件编码格式的问题导致pandas读写错误，例如：
import numpy as np import matplotlib.pyplot as plt import sklearn from sklearn.linear_model import LinearRegression import pandas as pd data = pd.read_csv('./text.csv') data.head() print(data.head) 现在我们直接在pd.read_csv的括号中进行更改，添加如下代码：
data = pd.read_csv('./text.csv', encoding="gbk", header=0, index_col=0) 看看结果：
问题就得到解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f010168f378689d2270ee27b7569d3e2/" rel="bookmark">
			mapper.xml文件映射mapper接口的四种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mapper.xml文件映射mapper接口的四种方式
&lt;mappers&gt; //1、resource,文件的位置 &lt;mapper resource = "mapper/UserMapper.xml"/&gt; &lt;/mapper&gt; //2、绝对路径，一般不用，太长 &lt;mapper url = "File:///..."&gt;&lt;/mapper&gt; /*3、class，接口的全路径 mapper映射文件的全路径 = 位置+映射文件名 2种规范： 1、映射文件的位置必须放在接口的同包目录下，在resources下建包，不能用点分隔，需用斜杠/分隔 2、映射文件名必须与接口同名 */ &lt;mapper class = "com.itheima.mapper.UserMapper"/&gt;&lt;/mapper&gt; //4.包扫描 &lt;package name ="com.itheima.mapper"&gt;&lt;/package&gt; &lt;/mappers&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91568da673aa0115eb987362ad62248e/" rel="bookmark">
			俞军产品方法论|第一章 什么是产品经理 |摘要笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一章 什么是产品经理 一、发展历程：
互联网时代的产品经理：和其他岗位有交叉、重叠或被强化软件时代的产品经理：偏重于项目管理和推进，大多数软件tob消费品时代的产品经理：产品经理最早起源于宝洁,麦克·艾尔洛埃在销售卡玫尔香皂的过程中，提出了“一个人负责一个品牌”的理念，宝洁接受了这个建议，麦克·艾尔洛埃也成为历史上第一个有“产品经理”头衔的人。因为需求相对明确，生产也标准化，有工业时代成熟的方法论支撑，是产品本身容易同质化，所以产品侧重于靠市场驱动，但更主要的是做定位、做营销、做渠道 二、互联网时代的特性： 信息复制分发的边际成本低和用户量巨大：意味着传播快，用户量大就会使得产品或多或少有平台属性，就要考虑产品生态了快速迭代、数据和AB测试：快速迭代意味着降低试错成本，也就降低产品经理的入行门槛。迭代又可获取大量反馈数据和信息，帮助产品经理进行正确的决策 AB测试：用来测试某个变量的两个不同版本的效果差异千人千面：根据不同用户的需求和喜好，展示可能符合用户偏好的信息快速迭代，AB测试减少了产品经理在深度思考方面的锻炼和成长，但只是降低了互联网产品经理的门槛，上限没有降体验设计价值增大：好的体验带来好的口碑 三、产品经理做什么 四大工作职能 需求：定义产品。只有面向用户需求的产品，才有市场结果生产：进行合理的产品设计，并有效率地把产品生产出来销售:需要考虑如何把产品卖给用户，达成市场结果协调：通过协调不同职能的人员产品经理需要搞清楚，当前阶段侧重哪一个部分更能够创造价值，并在对应部分进行重点投入，以创造最大的价值。对“需求”理解的好坏，往往能够决定一个产品的生死产品工作属于强实践性社会科学 产品的研究标的物不可能重复，结论的规律性和复用性受情景约束，需要总是结合具体案例分析相关的关键变量和约束条件人有异质性，社会又情境性，这些与产品相关的经验和规律只是具有统计意义上的显著性，只可归纳，不可演绎，即不能保证能准确预测具体的个人行为和新情景下的市场变化用户模型（合格线） 用户模型是指产品用户和潜在用户的偏好和行为反应模型。掌握的标志是：预判产品迭代后的用户行为变化，准确率较高。要以异质性、情境性、可塑性、自利性、有限理性的用户行为作为基本单位来研究产品的用户模型，并通过大量真实个体行为样本进行分析和洞察包括现实世界（意识）、宏观背景、微观场景交易模型（进阶） 以交易作为基本单位来研究产品，目的是建立可持续交易的互惠模型什么是产品？企业以产品为媒介跟用户进行价值交换为什么企业总是说创造用户价值，而不是创造产品？ 企业和用户交换的从来不是产品，而是价值用户关心的是得到什么和付出什么，包括产品给他什么效用组合需要他付出多少金钱或时间等。一个好产品有三个属性：（对用户）有效用，（企业）有收益，可持续 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6d6c65bc87998f4f39677040e5aa89/" rel="bookmark">
			俞军产品方法论|第三章 交易|摘要笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、交易与交易模型 什么是交易 产品即交易。在灭有强迫或欺诈的前提下，拥有自由选择权的理性人，只有在预期收益大于直接代价，且预期收益大于机会成本的情况下，才会做出交易行为世界上没有等价交换，只要不存在强迫和欺诈，一定是双方都主观判断自己会受益，才会完成交易交易模型 交易模型在某种意义上也是商业模式，是多边关系平衡的利益创造和利益分配模式产品经理用产品促成企业和用户间的价值交换，每一次交换都会创造价值。产品经理最终要做的，是持续不断地发现市场上高于用户支付代价地用户价值，并设计合适地交易模型把它固化为产品让更多交换行为发生的具体做法 持续发现和追加可交换的、有利可图的用户价值 对外的表现是用户体验好，背后的关键点其实是重视长期收益的价值观创造和更高效率地创造这些用户价值持续降低生产成本和所有交易成本企业行为的权重，按影响用户交换行为的ROI排序维护企业生存能力和可持续发展能力 二、效用 欲望的满足 程度边际效用递减原理 一个人对于财富的占有多多益善，即效用函数一阶导数大于零；随着财富的增加，满足程度的增加速度不断下降，效用函数二阶导数小于零最大效用原理 在风险和不确定条件下，个人的决策行为准则是为了获得最大期望效用值而非最大期望金额值以效用角度去分析什么是用户，更容易得到企业发展有利的判断。因为产品对不同用户的效用是有差异的，因此我们在决定做什么产品或更新什么功能之前，先要讨论：我们要满足的是哪些用户？该产品代表什么情景下的什么效用组合？这个产品迭代能否结合我自身的各种优势，实现较高的投入产出比？产品效用与用户欲望的不对等性 底线需求（不能低于）、够用就好（不用高于）、越多越好（愿意多支付）、惊喜（超出预期）一般来说，我们需要满足用户的"底线需求"，把“够用就好”的需求打磨到边际回报率最划算的那个点就停下，然后把“越多越好”的价值创造做到具有极高的投入产出比。适量提供“惊喜” 三、边际 边际效用 指消费者对某种物品的消费量每增加一单位所增加的额外满足程度边际成本边际利润 在一个给定约束条件下，再多做一笔交易，增加的额外利润 四、成本 机会成本：企业为从事某项经营活动而放弃另一项经营活动的机会，或利用一定资源获得某种收入所放弃的另一种收入。另一项经营活动应取得的收益或另一种收入，即为正在从事的经营活动的机会成本。交易成本：完成一笔交易时，交易双方在买卖前后所产生的各种于此交易相关的成本降低交易成本的例子： 标准化：把供给品尽量变成标准品，降低了度量成本，降低了不确定性带来的决策成本和保障成本智能手机的普及坚守了排队带来的交易成本链家真房源线上化抽成？工资？还是买断制 五、供需定律 在条件不变的情况，当需求大于供给时，价格上升，当需求小于攻击时，价格下降 六、相对价格 其他条件不变时，相对价格降低，需求量上升人间第一定律：相对价格 = （直接成本+交易成本）/效用组合智能手机出现之后，我们暂时还看不到下一个巨大新要素，未来一段时间内蓝海比较少，主要就是红海时代，比较适合用这个人间第一定律去分析产品。可以通过追加效用组合、改变效用组合或降低各类交易成本来降低产品的相对价格，实现用户增长 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d9c93e2a28cb916538425c59ee13297/" rel="bookmark">
			俞军产品方法论|第二章 企业、用户、产品|摘要笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、三者的关系 企业以产品作为媒介，与用户进行价值交换，达成了创造商业价值的目的企业能做的，是在给定条件下，选择满足哪些用户需求，创造哪些用户价值，以更多地促进交换，让企业有更高的边际收益和ROI（投资回报率） 二、如何理解用户 用户的定义：用户不是自然人而是需求的集合用户的五个属性：异质性、情境性、可塑性、自利性、有限理性如何理解用户的行为： 首先，在行为发生前，用户通常会接收一个情景的刺激，这个情景的刺激会调用偏好和认知函数，产生一个主观期望效用，促使用户产生相应的行为，即追逐这个预期的效用。而行为会产生某个结果，这个结果又会成为经验，影响偏好和认知函数，从而可能对用户的下一次行为产生影响如何理解用户价值（即主观效用）： 对用户来说价值由主观效用决定。效用是欲望的满足程度。萨缪尔森幸福公式：幸福=效用/欲望欲望具有无限性和约束性，效用的最大特点是主观性用户价值具备认知依存、情景依存、经验反馈演化三特征用一个公式衡量用户价值：用户价值 = 新体验 -旧体验-替换成本 三、如何理解产品 产品是一种价值交换的媒介，企业用产品和用户交换价值卖产品是卖一种在约束条件下的效用组合。分析产品的重点是弄明白这个产品利从何来、利往何去、它创造了什么价值，价值是怎么分配以创造用户价值为目的，打破一个旧的利益平衡，建立一个对己方有利的新产业链，这样的产品才容易成功。 四、如何理解企业 企业的本质只在于两点：1.发现市场获利机会；2.生产效率高于市场发现市场获利机会的途径：洞察（利用信息不对称性），试错（信息不完备性），偶然性（信息不确定性） 边界时需要靠对和错双向界定的，如果每个扩大边界的行为都成功，那你还是不知道产品的边界在哪里，所以试错和失败必然是产品开发过程的一部分一般来说，大型的市场获利机会，一是源于市场环境和制度变化，二是源于关键新技术，三是长期关键因素-组织建设能力企业持续：生产效率高于市场 企业积累的共同知识越多，企业内组织效率就越高。因为虽然企业通过权威决策能比市场节约交易费用，但是，企业内部的科层制也会带来层级之间、人与人之间的信息损耗，可以理解为这是企业内的组织成本。 詹森生产函数：Q=Fr（L,K,M,C:T） 首先，企业的产量Q是变量r(外部规则)的函数，给定一组外部规则时，存在一个被外部规则约束的产出边界。而当外部规则变化时，会出现新的外部规则产出边界，这就是企业冒险的最佳时机。其次，在外部规则r给定的前提下，企业的产量Q主要是变量T的函数，给定一种生产技术，存在一个生产技术约束的产出边界。所以当新技术进入应用阶段时，会出现新的技术性产生边界，这也是企业冒险的最佳时机最后L，K，M分别指传统的劳动力、资本、原材料三个生产要素的投入水平创造价值 最核心的价值概念有两个：使用价值，交换价值。没有使用价值的东西是不能成为产品，但产品有使用价值，不一定有交换价值。用户购买或者使用产品是为了获取使用价值，但企业做产品是 为了获取交换价值创造价值的五大途径：劳动、分工、交易、新技术、制度如何更好地与用户进行“价值交换 从用户角度，愿意选择产品的前提是“效用-成本”&gt;0从企业角度，愿意生产产品的前提是“收益-成本&gt;0”企业愿意进行交易（卖出产品）也是因为这么做最有利可图，并且企业要主义持续维护和创造用户价值，才能保证交易的“可持续性"，而企业的一切行为，也应该围绕"让交换行为更多地发生"（有效用、有收益、可持续） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c05929307959afbcdc3daf6ed78008/" rel="bookmark">
			elasticsearch单台/多台部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单机部署 单机部署步骤 elasticsearch 是不允许root用户直接运行的，需要创建新的用户，并且把elasticsearch 下所有的文件更改所属用户 1.从官网下载压缩包 https://www.elastic.co/cn/downloads/past-releases#elasticsearch
可根据需要的版本进行下载：
2.压缩包解压缩 解压软件包 tar zxvf elasticsearch-7.17.0-linux-x86_64.tar.gz 3.创建用户，并授权： elasticsearch 是不允许root用户直接运行的，需要创建新的用户 useradd es passwd es chown -R es:es /opt/elasticsearch-7.17.0 递归创建日志路径： mkdir -p /data/apps/elasticsearch-7.17.0/logs mkdir -p /data/apps/elasticsearch-7.17.0/data 给es用户授权: chown -R es:es /data/apps/elasticsearch-7.17.0/ 4.修改elasticsearch配置文件 vim /opt/elasticsearch-7.17.0/config/elasticsearch.yml http.cors.enabled: true 开启跨域 http.cors.allow-origin: "*" 开启所有 node.master: false node.data: true node.ingest: false http.cors.enabled: true http.cors.allow-origin: "*" bootstrap.memory_lock: false bootstrap.system_call_filter: false #xpack.security.enabled: true #xpack.security.transport.ssl.enabled: true #xpack.security.transport.ssl.verification_mode: certificate #xpack.security.transport.ssl.keystore.path: elastic-certificates.p12 #xpack.security.transport.ssl.truststore.path: elastic-certificates.p12 cluster.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c05929307959afbcdc3daf6ed78008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1752904d1e277003e9b2d7300746b046/" rel="bookmark">
			让debian支持ll命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 并不是说原生debian是不支持ll命令，而是因为ll本身就是别名命令。
$ ll
-bash: ll: command not found
没有ll这个命令。
之前一直用centos的，还是觉得别名命令好写，省去ls -l的麻烦
别名可以在bashrc上追加再应用即可，一行搞定：
echo "alias ll='ls -l'" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 个人觉得 tailf 也好用，附上添加tailf的命令，其他的可依次类推。
echo "alias tailf='tail -f'" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f4e08d0cb9614c89e1a78111367b6cf/" rel="bookmark">
			opencv4.5.5的下载与环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，在浏览器搜索里输入opencv4.5.5或者用下面这条网址进入官网
https://opencv.org/opencv-4-5-5/
进入后，我们看到的大概是下面的这个页面
然后往下滑，看到下面这里
点击sources，它就会开始下载压缩包了，压缩包下载好后大概长这样
然后，将它解压缩，我在这里自己新建了一个文件夹来放解压后的文件，当然，你们也可以不建，这个不是重点。解压后大概长这样
注意：图片里那个myself_build文件夹你们是没有的，那个文件夹也是我自己建的，但除了那个以外图片里显示的应该和你们解压后得到的一致。
解压得到文件后，我们开始下一步——环境配置
首先点击电脑左下角开始
点开后是这样
点击设置
打开后输入环境
点击编辑系统环境变量
在高级那一栏点击环境变量
选中Path那一行，点击编辑，打开后点击新建，将你解压的opencv文件夹里x64中bin的路径添加进去，然后点击确定。
注意：v14是vs2015用的，v15是vs2017用的，别搞错了哈，我也不知道随便用会不会出问题。
用户变量弄好后，我们就接着弄系统变量
和上面一样的操作，把路径添加进去
然后点击确定，一路确定了再出来，免得等下漏点确定可能会出现改完后退出就回到改之前，属于是改了个寂寞。
那到这里我们大 的环境就弄好了，接下来是进入vs中进行配置
首先，打开vs，点击新建项目
然后，点击确定
点击下一步
勾选空项目，点击完成
首先，
进来后记得把这个x86改成x64，因为我用的是x64文件里bin,lib的去配置 。
如果你跟我用的一样，那记得这里要改成x64，
如果你用的是x86文件下的bin,lib去配置的话，这里就不用改。
注意：我在下面放上的所有的图片里显示的选择都是debug和x86，但这其实是错误的（我已经懒得再去截一遍图了），请在看到那一栏时自动脑补成debug和x64，还有每一次更改你的这两个选择（debug还是release，x86还是x64），你就要重新将下面的步骤再走一遍，不然会全部报错。
然后，点击上面一栏里的项目——属性
打开后
点击VC++目录，在可执行文件目录那里，加入opencv的x64文件中v14的bin文件的路径
点击确定
在包含目录那一栏，编辑加入build文件中include的路径以及include下的opencv2的路径，点击确定
在库目录那一行编辑加入build文件下v14里lib文件的路径，点击确定
点击链接器里的附加依赖项，把lib文件里的dll的名称添加进去，然后点击确定。如果你准备用debug，那就用后面带d的，例如opencv_world455d.lib
如果你准备用release，那就用后面不带d的，例如opencv_world455.lib
我用的是debug，所以在附加依赖项时用的是带d的，
如果你用之前已经将debug改成release了，那在附加依赖项时就用不是带d的。
到了这里基本就弄好了，可以开始你们的骚操作了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd5879349a769f598cc9638223eeec9/" rel="bookmark">
			[MIT]微积分重点 第五课 积分总览 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.先上本节课目录： 1.函数二是函数一的导数 函数一： H e i g h t y ( x ) Height y(x) Heighty(x)
函数二： S l o p e s ( x ) Slope s(x) Slopes(x)
函数一 -&gt; 函数二：
S l o p e s ( x ) = d ⁡ y d ⁡ x = l i m i t o f Δ y Δ x Slope s(x)=\frac{\operatorname dy}{\operatorname dx}=limit\ of\ \frac{\Delta y}{\Delta x} Slopes(x)=dxdy​=limit of ΔxΔy​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bd5879349a769f598cc9638223eeec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17247d15df36a9557286d98609786fc/" rel="bookmark">
			Unity：PlayMode进入死循环导致无响应，找到问题代码|Mac版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在play Mode下，如果出现死循环的话Unity会无响应，参考了一些方法发现可以很容易找到问题代码，也不需要强制退出Unity导致工程进度丢失。自己记录下：
出现死循环后，重新打开Unity。
1.先不要play，首先在VS中开启“调试”面板：
2.在VS里面点击这个按钮，连接Unity：
3.现在，Unity可以开始Play Mode了： 4.重点来了
死循环出现，unity无响应后，点击VS里面这个暂停执行按钮：
5.这时，调试面板的「线程」窗口出现的这一行，就是死循环代码！
双击它，会自动定位到出现问题的代码：
6.现在就可以自行想办法解决死循环了！
在这里我的方法是，令do..while..结构的while判断语句的结果变成false，使它不会继续下一次循环。直接修改变量好了！
修改变量的方法：在「监视」窗口输入变量名称，重新输入想要的值。
或从「局部变量」窗口找到想修改的变量，修改值。
修改之后，再点击VS的「▶️」按钮继续执行代码，离开死循环。这时回到Unity，也从未响应的状态脱离了！可以安全地退出play mode继续工作了。
感谢下面的博客，谢谢各位老师
参考：
快速查找Unity死循环_随风吹笛-CSDN博客_unity 死循环
快速查找Unity中的死循环_Patrick-CSDN博客_unity 死循环
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbc0a488f8d0ca2e7f544036defcedf/" rel="bookmark">
			Postman-03-请求/响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、请求
1.发送Get请求
2.发送Post请求
3.配置请求头
二、响应
1.保存响应
2.查看响应
3.查看网络信息
一、请求 1.发送Get请求 输入https://postman-echo.com/get选择请求方法：Get点击Send 2.发送Post请求 2.1Form data：表单数据
2.2URL-encoded：URL编码
2.3Raw data(Text，JavaScript，JSON，HTML或XML) ：原始类型
3.配置请求头 3.1内容类型：Content-Type
3.2设备类型：User-Agent
二、响应 1.保存响应 2.查看响应 Pretty：适合查看json格式的响应
Raw：原始的方式
Preview：适合查看HTML格式的响应
3.查看网络信息 本地IP、远程地址、状态码、响应时间、响应内容大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570fe1acefe5fe55f934d5e168ece5c6/" rel="bookmark">
			HttpServletRequest 解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		protected void doPost(HttpServletRequest request, HttpServletResponse response) 若param是json字符串 用request.getParameterMap()获取到的Map key是json串，value值为空；若用request.getInputStream()来获取参数则是直接获取到json字符串
若param是key=value&amp;key=value…类型的字符串（此时传的就不是json串了） 用request.getParameterMap()正常获取，若用request.getInputStream()获取到的是key=value&amp;key=value.....字符串
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d858dc7194bc5f0231427f56ce3281a/" rel="bookmark">
			[安洵杯 2019]easy_serialize_php 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：反序列化字符串逃逸（2种情形），extract变量覆盖漏洞 目录 反序列化字符串逃逸反序列化的规则00x1:过滤后字符变多00x1:过滤后字符变少(本题就是此类型)值替换键替换 反序列化字符串逃逸 一般这类漏洞，都是在序列化之后，过滤，然后反序列化引起的。
反序列化的规则 了解反序列化字符串逃逸之前，先了解反序列化的规则
例如：
a:2:{s:4:"user";s:5:"guest";s:8:"function";s:3:"aaa";} //第一个a代表这是一个数组序列化 php反序列化会以 ; 来分隔字符段，以 } 为结尾，并且每个字段的内容是根据长度判断的，比如s:4:“user”;里面的4表示内容长度为4，若为s:4:“user1”;就会报错，也可以自己添加字段。
比如：
a:3:{s:4:"user";s:5:"guest";s:8:"function";s:3:"aaa";s:4:"pass";s:3:"123";} 00x1:过滤后字符变多 #参考字节脉搏实验室 &lt;?php function lemon($string){ $lemon = '/p/i'; return preg_replace($lemon,'ww',$string);//若匹配到p则换为ww } echo "原序列：&lt;br&gt;"; $username = $_POST['a']; $age = '20'; $user = array($username,$age); var_dump(serialize($user)); echo "&lt;br&gt;&lt;br&gt;"; echo "过滤后：&lt;br&gt;"; $r = lemon(serialize($user));//对序列化后的user数组过滤 var_dump($r); echo "&lt;br&gt;&lt;br&gt;过滤后反序列化："; var_dump(unserialize($r)); ?&gt; 当我们输入pppp时被替换为wwwwwwww，反序列化没有成功，以为长度匹配不上。
我们可以通过这个过滤来改age的值，序列化后也就是";i:1;s:2:“50”;}，长度为16，且一个p会被替换为两个ww，所以可以构造16个p，过滤后变为32个w，刚好修改前后的长度相等
pppppppppppppppp";i:1;s:2:"50";} 过滤后 wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww a:2:{i:0;s:32:"【pppppppppppppppp";i:1;s:2:"50";}】";i:1;s:2:"20";} //【】内为我们构造的值 过滤后： a:2:{i:0;s:32:"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww"【;i:1;s:2:"50";}】";i:1;s:2:"20";} //【】内为我们想要的值，age=50 //刚好32个w，不仅包含了16个p所在的位置，也包含了";i:1;s:2:"50";}所在的位置。 经过修改发现可以反序列化成功。
00x1:过滤后字符变少(本题就是此类型) 值替换 &lt;1&gt;对SESSION初始化，以及判断
extract函数：将变量从数组中导入当前的符号表，这里是把post里的值取出来变为PHP变量，比如name=user,则为$name=user，最重要的是它会再变量冲突时覆盖前面的变量。
&lt;2&gt;先对SESSION序列化然后再调用filter过滤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d858dc7194bc5f0231427f56ce3281a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd97fcb2154c24ea7f24315f219a23b/" rel="bookmark">
			Matlab实现SIFT&#43;RANSAC特征检测与图像融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SIFT特征检测 尺度不变特征转换(Scale-invariant Feature Transform or SIFT)是一种计算机视觉的算法，用来侦测与描述影像中的局部性特征。该算法在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，此算法由David Lowe在1999年所发表，2004年完善总结。SIFT算法具有较好的稳定性和不变性，能够适应旋转、尺度缩放、亮度的变化，能在一定程度上不受视角变化、仿射变换、噪声的干扰。
SIFT算法的大致步骤如下：
建立尺度空间，即建立高斯差分(DoG)金字塔在尺度空间中检测极值点，并进行精确定位关键点主方向赋值计算关键点描述子 1.利用SIFT算法对两幅原始图像进行检测，得到的结果如下（原始图像1有736个特征点，原始图像2有607个特征点）
2.得到两幅图像的特征点后，需要对两幅图像进行初步的特征点匹配。
本次实验采用的初步匹配方法为“1NN/2NN&lt;0.8”，即对于图像img1中的每个特征点描述子（设当前特征点描述子为des1_i），在img2图像中搜索与该128维向量之间的角度最小及次小的特征点描述子（分别记为des2_1，des2_2），记最小角度为deg1，次小角度为deg2，若deg1&lt;0.8*deg2，则我们将(des1_i,des2_1)视为符合条件的匹配点对，否则将其视为错配点对并剔除。这种寻找匹配的方法，Lowe在“Distinctive Image Features from Scale-Invariant Keypoints”中有详细说明。
特征点初步匹配结果如下（共66对粗匹配点）：
观察图2可以发现，两幅图像的两侧均存在一些误匹配的特征点，而我们真正需要的特征匹配点对大概应该集中于图像中央附近。因此，下面需要利用RANSAC算法剔除一些误匹配的特征点对，以实现特征点之间的精细匹配。
二、RANSAC特征点精匹配 随机抽样一致算法（Random Sample Consensus or RANSAC）可以从一组包含“局外点（Outliers）”的观测数据集中，通过迭代方式估计数学模型的参数。它是一种不确定的算法——它有一定的概率得出一个合理的结果，因此为了提高得到正确模型的概率，有时候必须增加迭代次数。
滤除误匹配对采用的RANSAC算法从匹配数据集中随机抽出4对样本（不共线）并计算出单应矩阵，然后利用这个模型测试所有数据，计算满足这个模型数据点的个数与投影误差(即代价函数)，若此模型为最优模型，则对应的代价函数最小。
RANSAC算法的具体步骤如下：
随机从数据集中随机抽出4个样本数据 (不能共线)，计算出单应矩阵H，记为模型M；计算数据集中所有数据与模型M的投影误差，若误差小于阈值，则加入内点集I；如果当前内点集I元素个数大于最优内点集I_best , 则更新I_best = I，同时更新迭代次数k；如果迭代次数大于k则退出，否则迭代次数加1，重复上述步骤。 使用RANSAC得到的特征点精匹配结果如下（共34对精匹配点）：
Matlab运行结果的部分截图（单应矩阵和精匹配点对的下标）：
观察图3我们可以发现，两幅图像两侧的一些杂乱无章的错误匹配点对均已被消除，在匹配结果中只保留了两幅图中央的一些精匹配点对，从而实现了特征点的精匹配。下面将进行最后的两幅图的拼接与融合。
三、图像的拼接与融合 在进行最终的拼接与融合之前，我们首先需要使用单应矩阵H对img2进行一个H变换，使得img2的视角大致与img1一致（让img1与img2位于同一坐标系下），以便于后续进行几何变换实现图像拼接。
在调整完毕img2的视角后，我们可以利用几何变换实现最终的两幅图像的拼接。在拼接完毕后，对两幅图像的重叠区域进行了优化处理，主要是调整了交界处img2的长度，使得img2能和img1在竖直方向对齐。
四、Matlab部分源码示例 main主程序：
clear; clc; close all; img1 = imread('test1.png'); img2 = imread('test2.png'); % 调用函数进行SIFT特征检测、RANSAC精细匹配和图像融合、拼接 % 利用SIFT算法找到匹配的特征点对并可视化 [des1, loc1, des2, loc2] = drawKeypoints(img1, img2); % 计算符合粗筛选条件的特征匹配点对并可视化 [matchLoc1, matchLoc2] = siftMatch(des1, loc1, des2, loc2); % 输出所有的特征点对 disp([matchLoc1, matchLoc2]); % 绘制由SIFT初步得到的粗特征匹配点连线 drawLine1(img1, img2, matchLoc1, matchLoc2); % 利用RANSAC算法计算出单应矩阵H以及最终的特征点下标corrPtIdx [H, corrPtIdx] = CalcH(matchLoc2' ,matchLoc1'); % 显示单应矩阵 fprintf('单应矩阵H如下：\n'); disp(H); % 显示由RANSAC找到的特征匹配点对在matchLoc矩阵的下标 fprintf('由RANSAC找到的特征匹配点对在matchLoc矩阵的下标如下：\n'); disp(corrPtIdx); % 绘制由RANSAC最终得到的精特征匹配点连线 drawLine2(img1, img2, matchLoc1, matchLoc2, corrPtIdx) % 利用单应矩阵将img2投影，使img2和img1在同一坐标系下，方便后续的拼接 tform = projective2d(H'); img2_adjusted = imwarp(img2, tform); % 显示一下两幅原始图像 figure; imshow(img1); figure; imshow(img2_adjusted); % 进行图像的最终拼接与融合 final_img = mosaicFusion(img1, img2, img2_adjusted, H); % 显示最终得到的图像 figure; imshow(final_img); 全部源码及原始图像见资源：Matlab实现SIFT+RANSAC特征检测与图像融合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac68e0b626f43229e5df183f0d9e28c/" rel="bookmark">
			VUE 报错大全（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. Duplicate keys detected: '10'. This may cause an update error
2. Unknown custom element: - did you register the component correctly? For recursive components, make sure to provide the "name" option.
1. Duplicate keys detected: '10'. This may cause an update error vue.runtime.esm.js:619 [Vue warn]: Duplicate keys detected: '10'. This may cause an update error.
found in
---&gt; &lt;Toritugiten&gt;
&lt;AppMain&gt; at src/layout/components/AppMain.vue
&lt;Layout&gt; at src/layout/index.vue
&lt;App&gt; at src/App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac68e0b626f43229e5df183f0d9e28c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721a38a6ff80cf7688cf44daca161310/" rel="bookmark">
			vscode mac版本同时显示多个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
vscode mac版本，默认是没办法在上面同时显示多个文件的，上面每次只能显示当前打开的文件，如果想看第二个文件，每次都需要在找到那个文件，然后再点击打开才能查看，很不方便。不知道windows版本的是这样的么。
使用如下方法，可以达到在上面同时显示多个文件，这样查看文件也比较方便。
首先：按command+shift+P，在搜索框中输入：setting.json，打开文件，输入如下内容：
{
"workbench.editor.showTabs": true,
"workbench.editor.enablePreview": false,
}
然后就可以在上面就可以同时显示多个文件了。亲测有效！！！
方法二：或者直接在视图框中点击。
解决办法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5930b559e680ec18fe2264203546ef5/" rel="bookmark">
			Python——import turtle 和 from turtle import * 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import turtle 和 from turtle import * 的区别为：导包不同、声明不同、路径不同。
一、导包不同 1、import turtle：import turtle导入了turtle包以及所有的内部成员。
2、from turtle import * ：from turtle import * 未导入turtle包，只是从这个命名空间导入了所有的成员。
二、声明不同 1、import turtle：import turtle不能使用未声明的变量。因此，要对每项加上包的前缀。
2、from turtle import * ：from turtle import * 可以直接使用命名空间内已经定义好的项目名称。
三、路径不同 1、import turtle：import turtle的所有函数是相对路径，每次使用模块中的函数都要确定引用。
2、from turtle import * ：from turtle import * 的所有函数都是绝对路径，直接使用函数就可以了。
参考文章 import turtle 和 from turtle import * 有什么区别？——百度网友6d6ef13的回答 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffddad3e4b2277f52ab57fc6db76c7a/" rel="bookmark">
			使用泰勒展开解释梯度下降方法参数更新过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提升树Boosting Tree算法实例详解_程大海的博客-CSDN博客
从提升树Boosting Tree过度到梯度提升Gradient Boosting_程大海的博客-CSDN博客
GBDT梯度提升之回归算法个人理解_程大海的博客-CSDN博客_梯度回归算法
GBDT梯度提升之二分类算法个人理解_程大海的博客-CSDN博客_gbdt二分类
GBDT梯度提升之多分类算法个人理解_程大海的博客-CSDN博客_gbdt可以多分类吗
XGBoost算法个人理解_程大海的博客-CSDN博客_xgboost 叶子节点权重
交叉熵损失与极大似然估计_程大海的博客-CSDN博客_极大似然估计和交叉熵
使用泰勒展开解释梯度下降方法参数更新过程_程大海的博客-CSDN博客
AdaBoost算法实例详解_程大海的博客-CSDN博客_adaboost算法实例 泰勒公式：
一阶泰勒展开：
梯度下降是逐步迭代，损失函数逐步降低的过程：
为了满足上述不等式条件，取 ，则上式变为：
因为是步长，，所以上述不等式成立。 从而得出梯度下降的参数更新公式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93ec7cc4a531ae27632de59a5f63d39/" rel="bookmark">
			PointRCNN: 3D Object Proposal Generation and Detection from Point Cloud【翻译】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract 本文提出 PointRCNN 用于从原始点云进行 3D 对象检测。
两个阶段
stage-1 用于自下而上的 3D proposal生成
我们的 stage-1 子网络不是像以前的方法那样从 RGB 图像生成proposal或将点云投影到鸟瞰图或体素，而是通过分割以自下而上的方式直接从点云生成少量高质量的 3D proposal将整个场景的点云分为前景点和背景。
stage-2 用于在规范坐标中细化proposal以获得最终检测结果
stage-2 子网络将每个proposal 的池化点转换为规范坐标，以学习更好的局部空间特征，并结合stage-1 中学习的每个点的全局语义特征进行准确的框细化和置信度预测。
数据集：KITTI 数据集
仅使用点云作为输入，以显着的优势优于最先进的方法（现在不是了）。
1. Introduction 虽然最近开发的 2D 检测算法能够处理图像中大量的视点变化和背景杂乱，但由于三维目标的不规则数据格式和6自由度大的搜索空间，对具有点云特征的三维目标的检测仍然面临着巨大的挑战。
在自动驾驶中，最常用的 3D 传感器是 LiDAR 传感器，它可以生成 3D 点云来捕捉场景的 3D 结构。 基于点云的3D目标检测的难点主要在于点云的不规则性。 最先进的 3D 检测方法要么利用成熟的 2D 检测框架，将点云投影到鸟瞰图 [14、42、17]（参见图 1（a））到正面图 [4 , 38] 或常规 3D 体素 [34, 43]，它们不是最优的，并且在量化过程中会遭受信息丢失。
图 1. 与最先进方法的比较。 我们的方法不是从鸟瞰图和前视图的融合特征图 [14] 或 RGB 图像 [25] 生成提案，而是直接从原始点云以自下而上的方式生成 3D 提案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93ec7cc4a531ae27632de59a5f63d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c53e0cbe958e8c9a93d668ace65a3a2/" rel="bookmark">
			没有webpack.config.js如何配置less吗 安装配置less必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先我们最新创建的项目；无论是vue或者react项目，你都找不到webpack.config.js，甚至没有原来的build文件夹，那我们如何配置less或者jq这种插件呢？接下来进入正题
配置less 1.安装less less-loader
打开我们的项目目录，打开CMD终端，安装命令如下
yarn add less less-loader 或者 npm install less less-loader 2.git commit一下
git add .
git commit -m 'xx'
3. yarn eject生成config目录及你想要的webpack.config.js
在CMD终端 命令行输入：
yarn eject 或者 npm run eject 成功的话会出现config文件夹 4.打开config/webpack.config.js 修改三处
第一处：
const lessRegex = /\.less$/; const lessModuleRegex = /\.module\.less$/; 添加位置如下图 ---------------------------------------------------------------------
第二处：
{ loader: require.resolve('less-loader'), options: lessOptions, }, 添加位置如下图
----------------------------------------------------------------------- 第三处：
{ test: lessRegex, exclude: cssModuleRegex, use: getStyleLoaders({ importLoaders: 1, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, }), sideEffects: true, }, { test: lessModuleRegex, use: getStyleLoaders({ importLoaders: 1, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, modules: true, getLocalIdent: getCSSModuleLocalIdent, }), }, 添加位置如下图 接下来重启项目 成功！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a1c6089b447a46ba4be18fb3deacde/" rel="bookmark">
			[Golang]力扣Leetcode—中级算法—其他—两整数之和（位运算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Golang]力扣Leetcode—中级算法—其他—两整数之和（位运算） 题目：给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。
链接： 力扣Leetcode—中级算法—其他—两整数之和.
示例 1：
输入：a = 1, b = 2
输出：3
示例 2：
输入：a = 2, b = 3
输出：5
标签：位运算、数学
思路：题目要求了不能使用运算符 + 和 - ，于是，我们使用位运算来处理这个问题。
位运算中的两数加法，也就下面这四种：
0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 0 (进位) 我们来看一个例子：
a = 5 = 0101 b = 4 = 0100 a ^ b 如下：（异或：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a1c6089b447a46ba4be18fb3deacde/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/153/">«</a>
	<span class="pagination__item pagination__item--current">154/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/155/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>