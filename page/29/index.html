<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc6437f68dfc4cd07043c4deafb1f4b/" rel="bookmark">
			vditor无法渲染出现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置cdn属性为"vditor"
vditor = new Vditor("vditor", { cdn: "vditor", width: '100%', height: 'calc(100% - 30px)', after: () =&gt; { console.log('Vditor after') vditor.setValue("`Vditor` 最小代码示例"); setVd(vditor); } }); 同时将node_module中的包复制到public下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00b93085d86fd96ed53e8f1f6e205ea/" rel="bookmark">
			Exynos4412 移植Linux-6.1（八）LCD驱动，解决error: implicit declaration of function ‘dma_free_writecombine’的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Exynos4412 移植Linux-6.1（一）下载、配置、编译Linux-6.1
Exynos4412 移植Linux-6.1（二）SD卡驱动——解决无法挂载SD卡的根文件系统
Exynos4412 移植Linux-6.1（三）SD卡驱动——解决mmc0: Timeout waiting for hardware interrupt.
Exynos4412 移植Linux-6.1（四）NandFlash卡驱动
Exynos4412 移植Linux-6.1（五）DM9000网卡驱动
Exynos4412 移植Linux-6.1（六）【已解决】SROMC寄存器的数值不正确的问题
Exynos4412 移植Linux-6.1 (七)挂载Ramdisk文件系统，【已解决】Couldn’t find valid RAM disk image starting at 0
Exynos4412 移植Linux-6.1 (八)LCD驱动，解决error: implicit declaration of function ‘dma_free_writecombine’的问题
Exynos4412 移植Linux-6.1（八）LCD驱动，解决error: implicit declaration of function ‘dma_alloc_writecombine’的问题 系列文章目录0、问题描述1、问题解决的经过（1）修改函数名（2）修改形参 2、编译结果 0、问题描述 有些博主分享了友善之臂tiny4412（Exynos4412）LCD的驱动，如下2位博主：
设备树学习之（十二）LCD驱动
Exynos4412——LCD驱动_lcd_probe
但是，移植的内核版本是Linux-4.x。我要移植的内核版本是Linux-6.1，交叉编译的时候会报错：lcd_drv.c:325:5: error: implicit declaration of function ‘dma_alloc_writecombine’; 出错的原因是内核中没有dma_alloc_writecombine()函数。
1、问题解决的经过 在Linux6.1的内核文件中确实是找不到dma_free_writecombine()函数。但是在Linux4.4的内核文件中可以找到。这个函数是在/include/linux/dma-mapping.h中声明的。
在Linux6.1的内核文件中打开/include/linux/dma-mapping.h，通过搜索关键字alloc，可以找到dma_alloc_wc()函数的声明。当发现这个的时候，我太高兴了！
（1）修改函数名 只需要把dma_alloc_writecombine()替换成dma_alloc_wc()。
（2）修改形参 dma_alloc_writecombine()与dma_alloc_wc()的第一个参数不一样。dma_alloc_wc()的第一个参数是struct device *dev，所以还需要做一些修改。定义结构体变量dev，然后修改dma_alloc_wc()的第一个参数为dev。如下：
struct device *dev = &amp;pdev-&gt;dev; …… tiny4412_lcd-&gt;screen_base = dma_alloc_wc(dev, tiny4412_lcd-&gt;fix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00b93085d86fd96ed53e8f1f6e205ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a9a77d6b4bbeaef11b8352319dbf9f/" rel="bookmark">
			FPGA——XILINX原语（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 FPGA——XILINX原语（1） 1.时钟组件（1）BUFG（2）BUFH（3）BUFR（4）BUFIO（5）使用场景 2.IO端口组件（1）IDDR（2）ODDR（3）IDELAY 1.时钟组件 时钟结构
（1）BUFG 输入输出
（2）BUFH 输入输出
（3）BUFR 可以进行分频，就不用进入PLL了
输入输出
（4）BUFIO 输入输出
（5）使用场景 2.IO端口组件 HR是3 HP是2
（1）IDDR 其中 ILOGICE3的结构
其中
IDDR：输入数据的双沿采样，是ILOGIC块中专用的寄存器，用于实现输入数据双沿采样。
IDDR工作模式： OPPOSITE_EDGE mode ；
SAME_EDGE mode ；
SAME_EDGE_PIPELINED mode；
常用的模式为 SAME_EDGE_PIPELINED mode
原语
（2）ODDR ODDR ：输出数据的双沿采样，是OLOGIC块中专用的寄存器，用于实现输出数据双沿采样
ODDR工作模式：
OPPOSITE_EDGE mode ；
SAME_EDGE mode ；
常用 SAME_EDGE mode ；
原语
（3）IDELAY 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8f39d37c6cc83b42abc140dd1e8041/" rel="bookmark">
			案例101:基于微信小程序的停车共享小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户功能模块的实现
用户注册登录界面
首页界面
停车场界面
车辆信息界面
车位预约界面
管理员功能模块的实现
管理员登录界面
用户管理界面
停车场管理界面
停车预约管理界面
停车缴费管理界面
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着科技的进步，微信小程序慢慢进入了生活当中，由于轻便快捷，方便使用，基于微信这个大平台，使得小程序飞速发展，趋于成熟，因此，针对用户停车预约的需求，特开发了本基于语音识别的停车共享小程序。
本文主要介绍了基于语音识别的停车共享小程序的开发过程，对开发环境、系统设计、系统实现、系统测试等方面进行分析。在设计时对微信客户端、微信开发者工具进行了充分的了解，掌握微信平台通过的接口。系统应用官方提供的API文档，主要实现了用户管理个人车辆、停车场查询预约、停车缴费的功能。
本基于语音识别的停车共享小程序采用Java技术、MYSQL数据库，基于微信平台开发，系统运行效果稳定，操作方便、快捷，界面友好，是一个功能全面、实用性好、安全性高，并具有良好的可扩展性、可维护性的停车共享小程序。
系统展示 用户功能模块的实现 用户注册登录界面 没有账号的用户可进行注册操作，注册后可进入登录界面进行登录系统
首页界面 用户通过微信平台进入本系统后可查看所有停车场信息 停车场界面 用户在停车场界面可查看所有停车场信息，并可选择查看详情 车辆信息界面 用户登录后可管理个人车辆信息，对已有车辆可进行修改和删除，也可添加车辆信息 车位预约界面 用户可查看个人已有车位预约信息，并可进行缴费和删除操作 管理员功能模块的实现 管理员登录界面 管理员可以通过正确的登录账号和密码进行登录系统后台 用户管理界面 管理员在用户管理界面可查看所有用户信息，并可对其进行修改和删除操作，同时也可添加用户信息
停车场管理界面 管理员可增删改查停车场信息
停车预约管理界面 管理员可查看用户停车预约信息，并可对其进行删除操作 停车缴费管理界面 管理员可查看所有停车缴费信息，并可对其进行删除操作
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd8f39d37c6cc83b42abc140dd1e8041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c3989b2204fc68bf7c2f66e6be61dc5/" rel="bookmark">
			案例096:基于微信小程序的社区团购系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：Spring Boot
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
管理员服务端功能模块
商家服务端功能模块
会员客户端功能模块
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 社会的发展和科学技术的进步，互联网技术越来越受欢迎。手机也逐渐受到广大人民群众的喜爱，也逐渐进入了每个会员的使用。手机具有便利性，速度快，效率高，成本低等优点。 因此，构建符合自己要求的操作系统是非常有意义的。
本文从管理员、商家、会员的功能要求出发，社区团购系统中的功能模块主要是实现管理员服务端；首页、个人中心、会员管理、商家管理、商品信息管理、商品分类管理、购买订单管理、退货退款管理、商品评价管理、系统管理，商家服务端：首页、个人中心、商品信息管理、购买订单管理、退货退款管理、商品评价管理；会员客户端：首页、商品信息、我的（会员信息、商品信息、购买订单、退货退款、商品评价、用户充值、购物车、我的订单）。
本人经过认真细致的研究，精心准备和规划，最后测试成功，系统可以正常使用。分析功能调整与社区团购系统实现的实际需求相结合，讨论了微信开发者技术与后台结合java语言和mysql数据库开发社区团购系统的使用。
系统展示 管理员服务端功能模块 管理员通过点击后台管理，进入页面可以输入用户名、密码、角色进行登录相对应操作
管理员通过点击后台管理，进入页面可以查看首页、个人中心、会员管理、商家管理、商品信息管理、商品分类管理、购买订单管理、退货退款管理、商品评价管理、系统管理等功能模块，进行相对应操作
会员管理：管理员通过会员管理可以查看会员账号、会员姓名、手机、邮箱、身份证、头像、积分等并进行详情、删除、修改操作 商家管理：管理员通过列表可以查看商家账号、密码、姓名、手机、邮箱、身份证、商铺名称、商铺图片、商铺地址、经营范围、积分等信息，管理员审核商家后才能登陆，并进行详情、删除、修改操作
商品信息管理：管理员通过商品信息管理可以查看商家账号、商铺名称、商商品原价、商品现价、团购最低人数、商品折扣、团购开始时间、团购结束时间、可提货点、积分、价格、积分等信息并进行详情、删除、修改操作
退货退款管理：管理员通过退货退款管理列表可以并进行审核、回复查看详情、删除操作
系统管理；该页面为轮播图管理界面。管理员可以在此页面进行首页轮播图的管理，通过新建操作可在轮播图中加入新的图片，还可以对以上传的图片进行修改操作，以及图片的删除操作
商家服务端功能模块 商家注册、登录，商家在注册页面填写商家姓名、密码、姓名、手机、邮箱、身份证、商铺名称、商铺图片、商铺地址、经营范围进行注册，登陆填写商家账号、密码，商家需要登陆必须经过管理员审核
首页，商家登录到首页可以查看首页、个人中心、商品信息管理、购买订单管理、退货退款管理、商品评价管理等内容 商品信息，商家在商品信息页面可以查看商家账号、商铺名称、商商品原价、商品现价、团购最低人数、商品折扣、团购开始时间、团购结束时间、可提货点、积分、价格等信息，可进行添加、修改、删除操作
购买订单管理，商家在购买订单管理页面可以查看订单编号、商品名称、商品图片、商品现价、购买时间、团购人数、会员账号、会员姓名、手机、地址，可进行查看会员支付状况，进行详情查看操作
商品评价管理，商家在商品评价可以进行信息回复操作
会员客户端功能模块 会员注册、登录，用户在注册页面填写会员账号、密码、会员姓名、手机、邮箱、身份证、、进行注册，信息无误进行登陆
首页，会员登录到首页可以查看首页、商品信息、我的等内容 商品信息，会员在商品信息页面可以查看、加入购物车、立即订购、积分兑换等操作 我的，会员在我的页面可以查看会员信息、商品信息、购买订单、退货退款、商品评价、用户充值、购物车、我的订单等信息 会员信息，会员在个人信息可以查看会员账号、会员姓名、手机、邮箱、身份证、头像、积分等信息，可进行添加、修改、删除操作 代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c3989b2204fc68bf7c2f66e6be61dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae13c2d41f31f06060c06c565effe7be/" rel="bookmark">
			C&#43;&#43;20形式的utf-8字符串转宽字符串，不依赖编译器编码形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认的char[]编码都是要看编译器编译选项的，你选了ANSI那它就是ANSI，你选了UTF8那它就是UTF8.
【注意：经典DevC++只支持ANSI编码（痛苦）；上图是小熊猫DevC++，则有这个选项】
这一点对我的代码造成了麻烦。我就是要用utf8字符串，无视编译器编码选项，并输出，怎么搞？
先看什么是麻烦的代码：
#include &lt;windows.h&gt; #include &lt;stdio.h&gt; // 将UTF-8字符串转换为宽字符串（不一定是UTF-16） wchar_t* utf8_to_wstr(const char* utf8_string) { // 获取UTF-8字符串的长度 int len = strlen(utf8_string); // 计算所需缓冲区大小 int w_size = MultiByteToWideChar(CP_UTF8, 0, utf8_string, len, NULL, 0); // 分配宽字符串缓冲区 wchar_t* w_string = (wchar_t*)malloc((w_size + 1) * sizeof(wchar_t)); // 将UTF-8多字节转换为宽字符串 MultiByteToWideChar(CP_UTF8, 0, utf8_string, len, w_string, w_size); w_string[w_size] = L'\0'; // 添加NULL终止字符 return w_string; } int main() { const char* utf8_string = "Wormwaker创作"; // 转换为wchar_t* wchar_t* w_string = utf8_to_wstr(utf8_string); // 使用MessageBoxW显示UTF-16字符串 MessageBoxW(NULL, w_string, L"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae13c2d41f31f06060c06c565effe7be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0dfcefcf3081bad1cf367e8f70495b/" rel="bookmark">
			【python】作用域与闭包 || global与nonlocal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python作用域 其他语言的作用域：块级、函数、类、模块、包等由小到大的级别但是python没有块级（if语句块、for语句块），所以if中定义的变量，相当于普通语句 &gt;&gt;&gt; if True: # if语句块没有作用域 x = 1 &gt;&gt;&gt; x 1 &gt;&gt;&gt; def func(): # 函数有作用域 a = 8 &gt;&gt;&gt; a Traceback (most recent call last): File "&lt;pyshell#3&gt;", line 1, in &lt;module&gt; a NameError: name 'a' is not defined 变量的作用域 查找循序： Python以L –&gt; E –&gt; G –&gt;B的规则查找变量，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，最后去内建中找。如果这样还找不到，那就提示变量不存在的错误。
a = 1 def func(): print(a) #输出1，局部变量找不到，去全局变量找 global和nonlocal total = 0 # total是一个全局变量 def plus( arg1, arg2 ): total = arg1 + arg2 # total在这里是局部变量.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0dfcefcf3081bad1cf367e8f70495b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43cb5a0b9571733828d54b91fce386cd/" rel="bookmark">
			若依前端引入外部icon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若依前端引入外部icon 场景：使用若依管理平台时，element-ui自带icon不满足需求，需要自己引入 具体实现：
下载自己需要的svg文件，推荐下载地址: https:www.iconfont.cn，下载时选择SVG下载将下载的svg文件引入项目中（src/assets/icons/svg文件夹下）在需要使用的vue文件中使用： &lt;svg-icon icon-class="bookmark" class-name='custom-class'/&gt; .custom-class{ color: #C03639; font-size: 40px; } 说明：bookmark为svg文件名，custom-class为自定义样式，若样式不生效，将svg文件中的fill参数删除或者改为fill="currentColor"即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee78d6e95fa44e8c65b20fc9693854db/" rel="bookmark">
			Vite与Webpack对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发领域，构建工具的选择对于开发效率和项目性能具有重要影响。Vite和Webpack是两个广泛使用的构建工具，它们都有各自的优点和适用场景。本文将从前端开发的视角对Vite和Webpack进行对比。
一、性能
Vite Vite，原名Vue 3 SSR，是由Vue.js的创始人尤雨溪开发的构建工具。它在开发模式下使用了浏览器原生的ES模块导入（ESM）进行模块加载，因此在开发模式下可以省略打包过程，直接运行源代码。这使得Vite在开发阶段提供了非常快的速度，尤其是在大型项目中。
Webpack Webpack是一个高度可配置的模块打包工具，广泛用于前端项目。它可以将多个模块打包成一个或多个bundle，并通过加载器和插件进行优化和压缩。然而，在开发模式下，Webpack需要先对源代码进行解析和转换，然后才能运行应用。这可能导致开发效率相对较低，尤其是在大型项目中。
二、配置复杂性
Vite Vite的配置相对简单。在vite.config.js文件中，你可以通过导入相应的插件和使用插件的实例来添加新的插件或加载器。例如：
import vue from '@vitejs/plugin-vue' export default { plugins: [vue()] } 这使得Vite的配置过程相对直观和易于理解。
Webpack 对于Webpack，添加一个新的插件或加载器可能需要配置多个文件，并可能需要深入了解Webpack的内部工作原理。这可能导致配置过程相对复杂和繁琐。例如：
module.exports = { module: { rules: [ { test: /\.vue$/, loader: 'vue-loader' } ] }, plugins: [ // ... ] } 三、插件生态系统
Vite 尽管Vite的插件生态系统还在发展阶段，但已经有一些常用的插件可供选择，如vite-plugin-vue、vite-plugin-style-import等。同时，由于Vite基于Rollup，因此可以使用Rollup的插件。这意味着虽然Vite的插件生态系统相对较小，但仍然能够满足一些常见的需求。 Webpack Webpack拥有庞大的插件生态系统，包括加载器、插件和其他扩展。这使得Webpack可以满足各种复杂的前端项目需求。例如，我们可以使用Webpack的插件来压缩代码、优化图片、处理CSS等。丰富的插件生态系统是Webpack的一大优势。 四、跨平台支持
Vite：主要针对现代浏览器进行优化，因此在跨平台支持方面表现良好。然而，对于一些特定的环境或浏览器，可能需要使用额外的配置或polyfills。这意味着虽然Vite的跨平台支持相对较好，但仍然需要一些额外的努力来确保兼容性。Webpack：具有更广泛的跨平台支持，可以处理各种不同的模块系统和环境。例如，我们可以使用Webpack的加载器来处理CommonJS、AMD等不同的模块系统。这意味着虽然Webpack需要更多的配置和插件支持来适应不同的环境，但它能够更好地支持各种不同的前端项目需求。 五、总结
总的来说，Vite和Webpack都是优秀的前端构建工具，各自具有独特的优点和适用场景。如果你需要一个快速的开发环境并且对打包结果有较高的要求，那么Vite可能是一个更好的选择。而如果你需要更广泛的跨平台支持和更丰富的插件生态系统来满足复杂的前端项目需求，那么Webpack可能更适合你。无论你选择哪个工具，都应该根据你的项目需求和个人偏好来进行决策。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdad6553d157931cfbc10c189c9f6fd/" rel="bookmark">
			# 前端常用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端常用代码 文章目录 前端常用代码计算 Span 中字体的长度下载文件Base64数据转换并下载浏览器iframe打开pdf浏览器iframe打开pdf 计算 Span 中字体的长度 getOperationColumnWidth (showToolBars) { let str = '测试' let dom = document.createElement('span') dom.style.display = 'inline-block' dom.style.fontSize = '14px' dom.textContent = str document.body.appendChild(dom) const width = dom.clientWidth document.body.removeChild(dom) return width } 下载文件 在Vue组件中，创建一个方法来处理文件下载操作。 methods: { downloadFile() { // 获取文件的URL或路径 const fileUrl = '/path/to/file'; // 创建一个临时的&lt;a&gt;元素 const link = document.createElement('a'); link.href = fileUrl; // 指定下载的文件名 link.download = 'file.pdf'; // 触发下载 link.click(); } } 在Vue模板中添加一个按钮或触发元素来调用下载方法。 html &lt;template&gt; &lt;div&gt; &lt;button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffdad6553d157931cfbc10c189c9f6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aec912585dc3c242149c292aeb2afb54/" rel="bookmark">
			【案例】pdf预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 window.open("文件路径") // 默认会打开一个新的窗口显示文件 &lt;a href="文件路径" target="_blank"&gt;&lt;/a&gt; // target 来控制是否需要打开新的窗口来显示，默认否 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc41a2fa9c2d56f1456ca232f7e0020/" rel="bookmark">
			【案例】图片预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 如何让图片放大，大多数的UI组件都带有这种功能，今天给大家介绍的这个插件除了放大之外，还可以旋转、移动、翻转、旋转、二次放大（全屏）
实现 npm i v-viewer -S main.js 中引入
import 'viewerjs/dist/viewer.css' import Viewer from 'v-viewer' Vue.use(Viewer) //配置项 Viewer.setDefaults({ zIndexInline:9999 }) &lt;div&gt; &lt;div&gt; 图片展示 &lt;/div&gt; &lt;img class="img" v-for="(src,index) in srclist" :src=" src.src" :title="src.name" :key="index"&gt; &lt;/div&gt; /// 预览学法有两种 图片预览1 &lt;div v-viewer&gt; &lt;img class="img" v-for="(src,index) in srclist" :src=" src.src" alt="src.name" :title="src.name" :key="index"/&gt; &lt;/div&gt; 图片预览2 &lt;viewer :images="srclist"&gt; &lt;img class="img" v-for="(src,index) in srclist" :src="index &gt; 1 ? src.src: ''" :key="index"/&gt; &lt;/viewer&gt; 配置参数 完整代码 &lt;template&gt; &lt;div&gt; &lt;el-button size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc41a2fa9c2d56f1456ca232f7e0020/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac3899c8b2e7c133358aceb6eed74f9/" rel="bookmark">
			模型训练出现 loss = nan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：模型不管怎么调参数，损失均为 nan 换了模型层，换了损失函数，还检查了 loss 的计算方式。还在其他地方验证了 loss 计算正确。
问题定位： 我是在对数据集做了新的不同预处理才出现问题的，训练以前的预处理数据集不会出现此情况。
1.排除预处理 -------将保留两位小数注释掉，仍然出现 loss = nan，说明小数点不是引起的问题的关键原因
2.排除预处理 -------滤波函数注释掉，不会出现 loss = nan，说明问题出现在滤波函数。
3.排除特别信号--------引入单个信号不会出现 loss 问题，引入整个数据集出现 loss = nan，说明可能是某段信号出现问题或者模型拟合不了整个数据集。
重新预处理数据集进行滤波，发现数据集中某个信号会出现代码警告，当时以为问题不大现在看就是这里的问题：
04015采集完成 44001 44001 C:\Users\xxx\.conda\envs\py110_py38\lib\site-packages\pywt\_thresholding.py:23: RuntimeWarning: invalid value encountered in true_divide thresholded = (1 - value/magnitude) 04043采集完成 105912 105912 现在将出现问题的信号04043 隔离训练。
发现只要将 04043号信号送入模型就会出现 loss = nan，其他信号均不会出现 loss = nan
解决问题 进入报错位置，思考是 小波变换库 pywt 阈值函数出现了问题，下面第三行代码处，出现了 除 0错误。
# 进入文件 .conda\envs\py110_py38\lib\site-packages\pywt\_thresholding.py:23 # 查看代码 with np.errstate(divide='ignore'): # divide by zero okay as np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac3899c8b2e7c133358aceb6eed74f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786303a7abd75a151cc7adf1980175eb/" rel="bookmark">
			vue2 之 实现pdf电子签章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前情提要 1. 需求 仿照e签宝，实现pdf电子签章 =&gt; 拿到pdf链接，移动章的位置，获取章的坐标
技术 : 使用fabric + pdfjs-dist + vuedraggable
2. 借鉴 一位大佬的代码仓亏 : 地址
一位大佬写的文章 ：地址
3. 优化 在大佬的代码基础上，进行了些许优化，变的更像e签宝
二、下载 ps : 怕版本不同，导致无法运行，请下载指定版本
1. fabric fabric : 是一个功能强大且操作简单的 Javascript HTML5 canvas 工具库
npm install fabric@5.3.0 2. pdfjs-dist npm install pdfjs-dist@2.5.207 问题一 注意 : 最好配置一下babel，因为打包的时候可能会报错
因为babel默认不会转化node_modules中的包，但是pdfjs-dist用了es6的东东
// 安装包 npm install babel-loader @babel/core @babel/preset-env -D 在webpack.config.js中配置
{ test: /\.js$/, loader: 'babel-loader', include: [ resolve('src'), // 转化pdfjs-dist，之所以分开写，是因为pdfjs-dist里面有很多es6的语法，但是我们只需要转化pdfjs-dist里面的web文件夹下的js文件 resolve('node_modules/pdfjs-dist/web/pdf_viewer.js'), resolve('node_modules/pdfjs-dist/build/pdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786303a7abd75a151cc7adf1980175eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e440ab9ec840680a99b9a4a49f2bf3f/" rel="bookmark">
			poi 实现自动列宽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上找了几个，autoSize ，autoWidth方法，测试发现都没有生效，
然后自己写了一个，如下：
public static void autoColumnWidth(XSSFSheet sheet) { XSSFRow head = sheet.getRow(0); if (Objects.isNull(head)) { return; } int[] columnWidths = new int[head.getLastCellNum()]; for (int i = 0; i &lt; columnWidths.length; i++) { System.out.println("columnWidths[" + i + "] = " + columnWidths[i]); } List&lt;String&gt; oneClass = Arrays.asList("PMD Program","Model Number", "RF Test"); List&lt;String&gt; twoClass = Arrays.asList("HW", "SW"); for (int i = 0; i &lt; sheet.getLastRowNum(); i++) { Row row = sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e440ab9ec840680a99b9a4a49f2bf3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c3ed96928c5eb1841142085d4ed01f/" rel="bookmark">
			java基础系列（十）多态理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 概述 多态是面向对象程序设计的三大特征之一，面向对象的三大特征：封装、继承、多态。
封装给对象提供了隐藏内部特性和行为的能力，保护对象内部的状态，提高了代码的可用性和可维护性。
继承关系使一个子类能继承父类的特征，而不需要再次编写相同的代码，并且附加一些新特征。子类是它的父类的特殊化，每个子类的实例都是其父类的实例。
二. 概念 同一个行为具有多个不同表现形式或形态的能力，指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。
三. 实现多态条件 1.继承：必须要有子类继承父类的继承关系。
2.重写：子类需要对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法而不是原本父类的方法。
3.向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 简单一句话概况：父类对象通过子类实例化
四. 理解 4.1 定义格式 //父类类型 变量名 = new 子类类型(); Father father = new Son(); 4.2 成员变量特点 这个对理解多态至关重要
4.2.1 成员变量访问规则 调用成员变量： 编译看左边， 运行也看左边 编译看左边，javac编译的时候，会看左边的父类有没有这个变量： 有编译成功， 无，编译失败 运行看左边 java运行代码的时候，实际获取的就是左边父类中的成员变量（因为它的类型是Father类型） 4.2.2 成员方法访问规则 调用成员方法： 编译看左边， 运行看右边 编译看左边，javac编译的时候，会看左边的父类有没有这个方法 ： 有编译成功， 无，编译失败 运行看右边 java运行代码的时候 实际运行的是子类中的方法 五. 示例 package com.duotai; //多态测试Demo public class Duo { public static void main(String[] args) { //定义格式： Father father = new Son(); //注意这里打印的父亲的年龄： 60岁 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1c3ed96928c5eb1841142085d4ed01f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d71660625537bd7470bede2adbdbcad1/" rel="bookmark">
			2023年度数据分析项目，建议收藏(数据集)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源丨大数据文摘
对于那些对数据，数据分析或数据科学感兴趣的人，提供一份可以利用业余时间完成的数据科学项目清单，一共14个！
项目分为三种类型：
可视化项目
探索性数据分析（EDA）项目
预测建模
可视化项目
最容易上手的就是数据可视化， 以下3个数据集可以用于创建一些有意思的的可视化效果并加到你的简历中。
1. 新冠病毒可视化
学习如何使用Plotly构建动态可视化数据，展示冠状病毒是如何在全球范围内传播的。Plotly很好用，它可以做动态可视化，好看且操作简单。
难易程度：⭐
数据集：
https://www.kaggle.com/sudalairajkumar/novel-corona-virus-2019-dataset
教程：
https://towardsdatascience.com/visualizing-the-coronavirus-pandemic-with-choropleth-maps-7f30fccaecf5
2. 澳洲大火数据可视化
2019-2020年的丛林大火季，也称为黑色夏天，由2019年6月开始的几场极端野火组成的。据维基百科统计，这场大火烧毁了约1,860万公顷的土地和5,900多座建筑物。
这是一个有趣的项目，可以利用Plotly或Matplotlib数据可视化工具来可视化野火的规模和对地理的影响。
难易程度：⭐
数据集：
https://www.kaggle.com/carlosparadis/fires-from-space-australia-and-new-zeland
3. 地表温度可视化
你是否怀疑过全球变暖的观点？创建一些数据可视化效果，显示地球表面温度如何随时间变化，并可以通过创建折线图或其他动画的Choropleth贴图来实现！也可以创建一个预测模型来预测未来五十年内地球的温度。
难易程度：⭐⭐
数据集：
https://www.kaggle.com/berkeleyearth/climate-change-earth-surface-temperature-data/kernels
探索性数据分析项目
探索性数据分析（EDA），也称为数据挖掘，意思是数据分析过程中使用了多种技术来更好理解数据。
1. 纽约Airbnb数据挖掘
自2008年以来，Airbnb使游客和房东出行更方便，提出更多个性化的体验世界的方式。该数据集包含有关2019年纽约出租的信息以及包含其地理信息，价格，评论数量等。
可以分析的一些角度如下：
哪些区域生意最好，为什么？
哪些区域的流量比其他区域大，为什么？
价格，评论数量和预订天数之间是否存在一些关系？
难易程度：⭐⭐⭐
数据集：
https://www.kaggle.com/dgomonov/new-york-city-airbnb-open-data
2. 哪些因素与员工离职和绩效有关
IBM公开了一个综合数据集，可以使用它来了解各种因素如何影响员工的流失率和满意度。一些变量包括教育程度，工作相关性，绩效评估和工作生活平衡程度等。
分析此数据集，找到任何确实影响员工满意度的变量，另外，还可以看看是否可以对变量进行重要程度排名。
难易程度：⭐
数据集：
https://www.kaggle.com/pavansubhasht/ibm-hr-analytics-attrition-dataset
3. 世界大学排名
你认为你的国家拥有世界上最好的大学吗？成为“最好”大学的衡量标准是什么？该数据集包含三个全球大学排名方式。使用此数据，你是否可以回答以下问题：
顶尖的大学都在哪些国家？
决定世界排名的主要因素是什么？
难易程度：⭐
数据集：
https://www.kaggle.com/mylesoneill/world-university-rankings
4. 饮酒与在校表现
喝酒会影响学生的成绩吗？如果不会，那有什么别的影响吗？这个数据是从中学数学和葡萄牙语课程的学生进行的一项调查中获得的。它包含几个变量，例如饮酒量，家庭人数，参与课外活动。
利用这些数据，挖掘学校成绩与各种因素之间的关系。另外，看看是否可以根据其他变量来预测学生的成绩！
难易程度：⭐
数据集：
https://www.kaggle.com/uciml/student-alcohol-consumption
5. 宠物小精灵数据挖掘
对所有游戏玩家来说，这是一个包含来自七代802个 Pokemon的信息数据集。试着回答以下几个问题！
哪一代宠物小精灵最强？哪代最弱？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d71660625537bd7470bede2adbdbcad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2103ed84926095d31e774d465635d2a2/" rel="bookmark">
			Vue&#43;Electron打包桌面应用(从零到一完整教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.使用vite+vue3+js方式一.构建桌面应用1.创建项目2. 安装依赖运行项目3.配置Electron4.修改配置文件1) vite.config.js2）main.js(项目根目录新增)3）preload.js(项目根目录下新增)4）package.json 5.打包vue项目6.运行electron 二.热更新开发环境1. 编辑main.js2. 同时开启vite和electron服务3.运行 三.打包操作实现1. 环境变量 2. 创建electron文件夹3. 编辑electron/main.js4. 编辑package.json5.打包 二.使用vite+vue3+Ts方式(某大佬已经搭建好了,只能Ts)三.使用vue-cli脚手架方式(支持vue2/3)1.Node版本要求2.通过vue-cli创建vue项目(2/3都可以)3.添加vue自带的electron-builder4.打包exe程序 一.使用vite+vue3+js方式 切记,整个项目的json文件不能有注释,及时没报错也不行,否则运行命令时还是有问题
一.构建桌面应用 1.创建项目 npm create vite@latest 或者 npm init vite@latest // 选择vue3+js或者vue3+ts 2. 安装依赖运行项目 // 进入项目安装依赖 npm install // 运行项目 npm run dev 3.配置Electron npm install electron //这里建议用镜像,不然太慢 4.修改配置文件 1) vite.config.js import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // https://vitejs.dev/config/ export default defineConfig({ base: './',	// 新增,打包的dist文件的index.html引入资源css/js的路径,这里使用相对路径,预防找不到的问题 plugins: [vue()] }) 2）main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2103ed84926095d31e774d465635d2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f698a02ad464d364ea438cb6218c3f/" rel="bookmark">
			关于“Python”的核心知识点整理大全33
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
12.8.3 将子弹存储到编组中
alien_invasion.py
注意
12.8.4 开火
game_functions.py
12.8.5 删除已消失的子弹
alien_invasion.py
12.8.6 限制子弹数量
settings.py
game_functions.py
12.8.7 创建函数 update_bullets()
game_functions.py
alien_invasion.py
12.8.8 创建函数 fire_bullet()
game_functions.py
12.9 小结
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
12.8.3 将子弹存储到编组中 定义Bullet类和必要的设置后，就可以编写代码了，在玩家每次按空格键时都射出一发子弹。 首先，我们将在alien_invasion.py中创建一个编组（group），用于存储所有有效的子弹，以便能够 管理发射出去的所有子弹。这个编组将是pygame.sprite.Group类的一个实例；pygame.sprite. Group类类似于列表，但提供了有助于开发游戏的额外功能。在主循环中，我们将使用这个编组 在屏幕上绘制子弹，以及更新每颗子弹的位置：
alien_invasion.py import pygame from pygame.sprite import Group --snip-- def run_game(): --snip-- # 创建一艘飞船 ship = Ship(ai_settings, screen) # 创建一个用于存储子弹的编组 1 bullets = Group() # 开始游戏主循环 while True: gf.check_events(ai_settings, screen, ship, bullets) ship.update() 2 bullets.update() gf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f698a02ad464d364ea438cb6218c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca32edfd1eb1f963edbf335570e5e587/" rel="bookmark">
			[U in keyof T]?: T[U] extends {} ? PowerPartial＜T[U]＞ : T[U]；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析 [U in keyof T]?: T[U] extends {} ? PowerPartial&lt;T[U]&gt; : T[U]; [U in keyof T]?: T[U] extends {} ? PowerPartial&lt;T[U]&gt; : T[U]; 这段代码是 TypeScript 中的索引签名和条件类型的组合使用。它表示一个泛型对象类型 T，其中每个属性 U 可选，并且根据属性值的类型进行递归的部分可选化。
让我们逐步解析这段代码：
1 [U in keyof T]? 这部分表示遍历泛型对象类型 T 的所有属性 U，并将其设为可选。
[U in keyof T]? ​[U in keyof T]? 是 TypeScript 中用于定义索引签名的语法。在这个语法中，U 是一个变量，表示泛型对象类型 T的属性名，keyof T 则表示获取 T 的所有键，即 T 的属性名称。
整体上，[U in keyof T] 表示对 T 的所有属性进行遍历，并将每个属性都赋值给变量 U，形成一个索引签名。而 ? 表示这些属性都是可选的，即可以存在也可以不存在。
2 T[U] extends {} ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca32edfd1eb1f963edbf335570e5e587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c049f2dd28da05df17bfd80ed88909e/" rel="bookmark">
			Unity开发过程中的一些小知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、如何查询挂载了指定脚本的游戏物体
可以直接在Hierarchy面板上，搜索想要找的脚本名
2、如何将Unity生成的多个相同游戏物体获得序号
可以使用Unity的API Transform.GetSiblingIndex() 实现。
Transform.GetSiblingIndex() ================================== gameobject.id=Transform.GetSiblingIndex() 含义：获得同级索引
将生成的游戏物体放在同一的父级对象下，通过该API即可获取这些游戏图在同级层视图上的位置(按Hierarchy窗口中顺序进行排序)。
3、在Unity中如何获得系统时间并输出
这里需要注意YYYYMMDD_HHMMSS的含义
它表示一种日期和时间的格式
YYYY：表示四位数的年份，比如2024年
MM：表示两位数的月份，比如12月
DD：表示两位数的日期，比如23日
HH：表示小时，比如6小时
MM：表示分钟，比如45分钟
SS：表示秒钟，比如12秒
string date = $"{ System.DateTime.Now:yyyy/MM/dd_HH/mm/ss}" ; string date2 = System.DateTime.Now.ToString("yyyy/MM/dd_HH/mm/ss"); 4、如何用C#做出年/月/日这样种有斜杆的日期显示
1、可以使用C#中Substring()方法
Substring(int i ，int j) i表示从第i位的索引号开始截取 j表示截取的数量 注意：字符串的索引值是从0开始的 作用：从字符串中截取指定开始位置和指定长度的字符串
public void GetDateButton2() { string date = $"{ System.DateTime.Now:yyyyMMdd_HHmmss}"; string datetext = date.Substring(0,8);//截取从索引值第0位开始的后八位字符 string timetext = date.Substring(9,6);//截取从索引值第9位开始的后六位字符 SetDate(ref datetext); SetTime(ref timetext); DateText.text = datetext + "_" + timetext; } public void SetDate(ref string date) { date = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c049f2dd28da05df17bfd80ed88909e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9bdbc8fedfe43b5142350945b17796e/" rel="bookmark">
			河道漂浮物监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，河道和湖泊污染日益严重，漂浮物的监测与识别成为一项迫切需要解决的环境问题。针对这一问题，科技人员研发了河道漂浮物监测识别摄像机。 河道漂浮物监测识别摄像机利用先进的图像识别技术，通过智能算法，可以在河道和湖泊表面捕捉到漂浮的垃圾、塑料瓶、树叶等各种漂浮物，进行自动识别和提醒相关管理人员及清理，从而为环保部门提供准确的监测数据。
河道漂浮物监测识别摄像机的应用具有诸多优势。首先，它能够大大减少对人力和物力资源的依赖，实现全天候的河道监测，提高了监测的效率和准确性。其次，通过实时数据传输，可及时发现河道和湖泊中的漂浮物污染，及时采取应对措施，保护水域生态环境。此外，河道漂浮物监测识别摄像机还具有较低的维护成本和易于安装的特点，可以灵活部署在各类河道和湖泊，为环境监测与保护工作提供有力支持。
总的来说，河道漂浮物监测识别摄像机的问世，为解决河道和湖泊漂浮物污染问题提供了重要的技术手段，可广泛应用于河道管理、环保监测、水域保护等领域，为确保水域环境的清洁与健康发挥重要作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b847c61967048a47d1ee0062a82104/" rel="bookmark">
			获取Ip 的地域等信息的API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上查到有以下结果
淘宝的IP接口地址: http://ip.taobao.com/instructions.php 腾讯的IP地址API接口地址：http://fw.qq.com/ipaddress 新浪的IP地址查询接口：http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js 新浪多地域测试方法：http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&amp;ip=218.192.3.42 搜狐IP地址查询接口（默认GBK）：http://pv.sohu.com/cityjson 搜狐IP地址查询接口（可设置编码）：http://pv.sohu.com/cityjson?ie=utf-8 搜狐另外的IP地址查询接口：http://txt.go.sohu.com/ip/soip 目前我用的是：https://pv.sohu.com/cityjson?ie=utf-8
简易demo,新建index.html文件，代码如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="https://pv.sohu.com/cityjson?ie=utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var city=returnCitySN,UserLocation,UserIP; UserLocation=city.cname;//地域名 UserIP=city.cip;//IP document.write(UserLocation); document.write("&lt;/br&gt;"); document.write(UserIP); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JavaScript是一种广泛使用的编程语言，主要用于网页开发。
JavaScript的基本概念：
变量和数据类型：在JavaScript中，你可以使用变量来存储各种数据，如数字、字符串、布尔值、对象、数组等。JavaScript是一种弱类型语言，这意味着变量的类型可以在运行时改变。函数：函数是一段可重复使用的代码块，可以接受参数并返回一个值。在JavaScript中，函数可以作为一等公民，可以作为参数传递给其他函数，也可以作为变量存储。对象：对象是包含属性和方法的集合。属性是变量，方法则是函数。在JavaScript中，对象是使用花括号{}来创建的。事件：事件是用户与网页交互时发生的事情，如点击、鼠标移动、键盘输入等。JavaScript允许你定义事件处理程序，以便在事件发生时执行特定的代码。DOM（文档对象模型）：DOM是HTML和XML文档的编程接口，它提供了一种方式来访问和操作文档的结构。在JavaScript中，你可以使用DOM来动态地修改网页内容、结构和样式。异步编程：JavaScript是单线程的，这意味着它一次只能执行一个任务。为了提高性能并允许用户与网页交互，JavaScript使用异步编程模型，如回调函数、Promises和async/await。模块和模块化：在现代JavaScript开发中，模块是一种组织代码的方式。通过模块化，你可以将代码分解为独立的文件，每个文件都有一个特定的功能或任务。 JavaScript 是脚本语言
JavaScript 是一种轻量级的编程语言。
JavaScript 是可插入 HTML 页面的编程代码。
JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。
JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 控制了网页的行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248749bf477acd57c60791bd176189fd/" rel="bookmark">
			input 回车响应事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#HTML代码：
&lt;input type="text" id="name-value" onkeydown="keyDown(event)"&gt; #JS函数
//enter键-响应 function keyDown(e){ var keycode = 0; //IE浏览器 if(CheckBrowserIsIE()){ keycode = event.keyCode; }else{ //火狐浏览器 keycode = e.which; } if (keycode == 13 ) //回车键是13 { AddCondition(1);//回车后的响应函数 } } //检测浏览器 function CheckBrowserIsIE(evt){ var result = false; var browser = navigator.appName; if(browser == "Microsoft Internet Explorer"){ result = true; } return result; } JavaScript是一种广泛使用的编程语言，主要用于网页开发。
JavaScript的基本概念：
变量和数据类型：在JavaScript中，你可以使用变量来存储各种数据，如数字、字符串、布尔值、对象、数组等。JavaScript是一种弱类型语言，这意味着变量的类型可以在运行时改变。函数：函数是一段可重复使用的代码块，可以接受参数并返回一个值。在JavaScript中，函数可以作为一等公民，可以作为参数传递给其他函数，也可以作为变量存储。对象：对象是包含属性和方法的集合。属性是变量，方法则是函数。在JavaScript中，对象是使用花括号{}来创建的。事件：事件是用户与网页交互时发生的事情，如点击、鼠标移动、键盘输入等。JavaScript允许你定义事件处理程序，以便在事件发生时执行特定的代码。DOM（文档对象模型）：DOM是HTML和XML文档的编程接口，它提供了一种方式来访问和操作文档的结构。在JavaScript中，你可以使用DOM来动态地修改网页内容、结构和样式。异步编程：JavaScript是单线程的，这意味着它一次只能执行一个任务。为了提高性能并允许用户与网页交互，JavaScript使用异步编程模型，如回调函数、Promises和async/await。模块和模块化：在现代JavaScript开发中，模块是一种组织代码的方式。通过模块化，你可以将代码分解为独立的文件，每个文件都有一个特定的功能或任务。 JavaScript 是脚本语言
JavaScript 是一种轻量级的编程语言。
JavaScript 是可插入 HTML 页面的编程代码。
JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/248749bf477acd57c60791bd176189fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79eec6aec54b57c2f37b77b64ad234c0/" rel="bookmark">
			js获取对象长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#方法一:运用for循环计算对象属性个数
var obj = {a:1,b:2,c:3}; //获取对象长度 function objLength(obj){ var count = 0; for(var i in obj){ count ++; } return count; } console.log(objLength(obj));//3 #方法二：运用Object.keys获取到对象属性并生成数组，然后查看数组的长度即可。
var obj = {a:1,b:2,c:3}; var arr = Object.keys(obj); console.log(arr); //["a", "b", "c"] console.log(arr.length); //3 JavaScript是一种广泛使用的编程语言，主要用于网页开发。
JavaScript的基本概念：
变量和数据类型：在JavaScript中，你可以使用变量来存储各种数据，如数字、字符串、布尔值、对象、数组等。JavaScript是一种弱类型语言，这意味着变量的类型可以在运行时改变。函数：函数是一段可重复使用的代码块，可以接受参数并返回一个值。在JavaScript中，函数可以作为一等公民，可以作为参数传递给其他函数，也可以作为变量存储。对象：对象是包含属性和方法的集合。属性是变量，方法则是函数。在JavaScript中，对象是使用花括号{}来创建的。事件：事件是用户与网页交互时发生的事情，如点击、鼠标移动、键盘输入等。JavaScript允许你定义事件处理程序，以便在事件发生时执行特定的代码。DOM（文档对象模型）：DOM是HTML和XML文档的编程接口，它提供了一种方式来访问和操作文档的结构。在JavaScript中，你可以使用DOM来动态地修改网页内容、结构和样式。异步编程：JavaScript是单线程的，这意味着它一次只能执行一个任务。为了提高性能并允许用户与网页交互，JavaScript使用异步编程模型，如回调函数、Promises和async/await。模块和模块化：在现代JavaScript开发中，模块是一种组织代码的方式。通过模块化，你可以将代码分解为独立的文件，每个文件都有一个特定的功能或任务。 JavaScript 是脚本语言
JavaScript 是一种轻量级的编程语言。
JavaScript 是可插入 HTML 页面的编程代码。
JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。
JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 控制了网页的行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f4bb2af5bb1ba38398d8a53a1b3a79/" rel="bookmark">
			JS获取当天23时59分59秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始时间2019-04-25 00:00:00
/** * 获取日期+00时00分00秒 * @param {Date} datetime --日期 */ export const datetimeFullZero = function(datetime){ var dateValue = new Date(new Date(new Date(datetime).toLocaleDateString()).getTime()); var datetime = dateValue.getFullYear() + "-" + ((dateValue.getMonth() + 1) &lt; 10 ? "0" + (dateValue.getMonth() + 1):(dateValue.getMonth() + 1))+ "-" + (dateValue.getDate() &lt; 10 ? "0" + dateValue.getDate():dateValue.getDate()) + " " + (dateValue.getHours()&lt;10?"0"+dateValue.getHours():dateValue.getHours()) + ":" + (dateValue.getMinutes()&lt;10?"0"+dateValue.getMinutes():dateValue.getMinutes()) + ":" + (dateValue.getSeconds()&lt;10?"0"+dateValue.getSeconds():dateValue.getSeconds()); return datetime; } 结束时间2019-04-25 23:59:59
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f4bb2af5bb1ba38398d8a53a1b3a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2f383b704194b826ea5c34781157ee/" rel="bookmark">
			IE兼容问题new Date()的值为Invalid Date、NaN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：
new Date('2018-11-14') //返回Wed Nov 14 2018 08:00:00 GMT+0800 (中国标准时间)，转换成功 第二种：
new Date('2018-11-14 00:00:00') //返回Invalid Date，转换失败（IE不支持这种写法） 第三种：
new Date('2018/11/14 00:00:00') //返回Wed Nov 14 2018 08:00:00 GMT+0800 (中国标准时间)，转换成功 后记：
IE浏览器支持第一、三种写法、不支持第二种写法；
将日期中‘-’转换为‘/’:
var dateValue = '2018-11-14 00:00:00'; dateValue=dateValue.replace(new RegExp(/-/gm) ,"/"); //转换 console.log(dateValue);//输出：2018/11/14 00:00:00 JavaScript是一种广泛使用的编程语言，主要用于网页开发。
JavaScript的基本概念：
变量和数据类型：在JavaScript中，你可以使用变量来存储各种数据，如数字、字符串、布尔值、对象、数组等。JavaScript是一种弱类型语言，这意味着变量的类型可以在运行时改变。函数：函数是一段可重复使用的代码块，可以接受参数并返回一个值。在JavaScript中，函数可以作为一等公民，可以作为参数传递给其他函数，也可以作为变量存储。对象：对象是包含属性和方法的集合。属性是变量，方法则是函数。在JavaScript中，对象是使用花括号{}来创建的。事件：事件是用户与网页交互时发生的事情，如点击、鼠标移动、键盘输入等。JavaScript允许你定义事件处理程序，以便在事件发生时执行特定的代码。DOM（文档对象模型）：DOM是HTML和XML文档的编程接口，它提供了一种方式来访问和操作文档的结构。在JavaScript中，你可以使用DOM来动态地修改网页内容、结构和样式。异步编程：JavaScript是单线程的，这意味着它一次只能执行一个任务。为了提高性能并允许用户与网页交互，JavaScript使用异步编程模型，如回调函数、Promises和async/await。模块和模块化：在现代JavaScript开发中，模块是一种组织代码的方式。通过模块化，你可以将代码分解为独立的文件，每个文件都有一个特定的功能或任务。 JavaScript 是脚本语言
JavaScript 是一种轻量级的编程语言。
JavaScript 是可插入 HTML 页面的编程代码。
JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。
JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 控制了网页的行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88473ec153bbf3336c291c2b21402758/" rel="bookmark">
			Word字号对应数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字号磅毫米数小初3612.70一号269.17小一248.47二号227.76小二186.35三号165.64小三155.29四号144.94小四124.32五号10.53.70小五93.18六号7.52.65 JavaScript是一种广泛使用的编程语言，主要用于网页开发。
JavaScript的基本概念：
变量和数据类型：在JavaScript中，你可以使用变量来存储各种数据，如数字、字符串、布尔值、对象、数组等。JavaScript是一种弱类型语言，这意味着变量的类型可以在运行时改变。函数：函数是一段可重复使用的代码块，可以接受参数并返回一个值。在JavaScript中，函数可以作为一等公民，可以作为参数传递给其他函数，也可以作为变量存储。对象：对象是包含属性和方法的集合。属性是变量，方法则是函数。在JavaScript中，对象是使用花括号{}来创建的。事件：事件是用户与网页交互时发生的事情，如点击、鼠标移动、键盘输入等。JavaScript允许你定义事件处理程序，以便在事件发生时执行特定的代码。DOM（文档对象模型）：DOM是HTML和XML文档的编程接口，它提供了一种方式来访问和操作文档的结构。在JavaScript中，你可以使用DOM来动态地修改网页内容、结构和样式。异步编程：JavaScript是单线程的，这意味着它一次只能执行一个任务。为了提高性能并允许用户与网页交互，JavaScript使用异步编程模型，如回调函数、Promises和async/await。模块和模块化：在现代JavaScript开发中，模块是一种组织代码的方式。通过模块化，你可以将代码分解为独立的文件，每个文件都有一个特定的功能或任务。 JavaScript 是脚本语言
JavaScript 是一种轻量级的编程语言。
JavaScript 是可插入 HTML 页面的编程代码。
JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。
JavaScript 是 web 开发人员必须学习的 3 门语言中的一门：HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 控制了网页的行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a499bd7d6aa1381202e0012bb34e9752/" rel="bookmark">
			帝国cms问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1 登录后台遇到 Cann't connect to DB!
解决方法：有可能是mysql服务意外关闭，去控制面板-管理工具-服务 找mysql服务启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31475a345174c44d390a594cf1e475c3/" rel="bookmark">
			关于“Python”的核心知识点整理大全32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
12.6.4 调整飞船的速度
settings.py
ship.py
alien_invasion.py
12.6.5 限制飞船的活动范围
ship.py
12.6.6 重构 check_events()
game_functions.py
12.7 简单回顾
12.7.1 alien_invasion.py
12.7.2 settings.py
12.7.3 game_functions.py
12.7.4 ship.py
12.8 射击
12.8.1 添加子弹设置
settings.py
12.8.2 创建 Bullet 类
bullet.py
bullet.py
关于“Python”的核心知识点整理大全12-CSDN博客
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
12.6.4 调整飞船的速度 当前，每次执行while循环时，飞船最多移动1像素，但我们可以在Settings类中添加属性 ship_speed_factor，用于控制飞船的速度。我们将根据这个属性决定飞船在每次循环时最多移动 多少距离。下面演示了如何在settings.py中添加这个新属性：
settings.py class Settings(): """一个存储游戏《外星人入侵》的所有设置的类""" def __init__(self): --snip-- # 飞船的设置 self.ship_speed_factor = 1.5 我们将ship_speed_factor的初始值设置成了1.5。需要移动飞船时，我们将移动1.5像素而不 是1像素。 通过将速度设置指定为小数值，可在后面加快游戏的节奏时更细致地控制飞船的速度。然而， rect的centerx等属性只能存储整数值，因此我们需要对Ship类做些修改：
ship.py class Ship(): 1 def __init__(self, ai_settings, screen): """初始化飞船并设置其初始位置""" self.screen = screen 2 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31475a345174c44d390a594cf1e475c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c2bb1232cdecd2faa96fd6780945ad/" rel="bookmark">
			【C&#43;&#43;题目速刷】二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【C++题目速刷】二分查找 一、二分查找1、题目链接2、解题3、代码 二、在排序数组中查找元素的第一个和最后一个位置1、题目链接2、解题3、代码4、算法模板 三、x的平方根1、解题链接2、解题3、代码 四、搜索插入位置1、题目链接2、解题3、代码 五、山脉数组的峰顶索引1、题目链接2、解题3、代码 六、寻找峰值1、题目链接2、解题3、代码 七、寻找旋转排序数组中的最小值1、题目链接2、解题3、代码 八、点名1、题目链接2、解题3、代码 一、二分查找 1、题目链接 leetcode链接
2、解题 3、代码 二、在排序数组中查找元素的第一个和最后一个位置 1、题目链接 leetcode链接
2、解题 3、代码 4、算法模板 底下是+1，上面就不+1，底下是-1，上面就+1
三、x的平方根 1、解题链接 leetcode链接
2、解题 3、代码 四、搜索插入位置 1、题目链接 leetcode链接
2、解题 3、代码 五、山脉数组的峰顶索引 1、题目链接 leetcode链接
2、解题 3、代码 六、寻找峰值 1、题目链接 leetcode链接
2、解题 3、代码 七、寻找旋转排序数组中的最小值 1、题目链接 leetcode链接
2、解题 3、代码 以nums[0]为基准
以nums[nums.size()-1]为基准
八、点名 1、题目链接 leetcode链接
2、解题 可以有五种做题方式，前四种全是算法复杂度为O(n)，最后一种算法复杂度为O(logn)
哈希表，直接遍历查找结果，位运算，高斯求和公式和二分查找
我们只讲解二分查找算法：
3、代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7cf6ddd5be9a9d672a7830668a5c5e/" rel="bookmark">
			Linux下c语言实现动态库的动态调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux操作系统下，有时候需要在不重新编译程序的情况下，运行时动态地加载库，这时可以通过Linux操作系统提供的API可以实现，涉及到的API主要有dlopen、dlsym和dlclose。使用时，需要加上头文件#include &lt;dlfcn.h&gt; 。
dlopen介绍：打开一个动态链接库 ，函数定义如下：
void * dlopen( const char * pathname, int mode ); 函数功能描述：在dlopen的（）函数以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程。
参数说明：
pathname：动态库的名称，需要带上路径。
mode：分为这几种 RTLD_LAZY 暂缓决定，等有需要时再解出符号 RTLD_NOW 立即决定，返回前解除所有未决定的符号。 RTLD_LOCAL RTLD_GLOBAL 允许导出符号 RTLD_GROUP RTLD_WORLD 返回值说明: 打开错误返回空指针NULL ，若成功，返回库引用 dlsym介绍：
该函数根据动态链接库操作句柄与符号，返回符号对应的地址。
函数定义如下：
void*dlsym(void* handle,const char* symbol);
函数说明：
dlsym根据动态链接库操作句柄和符号，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。
参数说明：
handle：打开库文件之后的句柄。
symbol：需要从库文件查找的符号。
dlclose
dlclose用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时,才会真正被系统卸载。
实验一 获取函数地址
在linux下创建一个test的工程目录。
工程目录下创建一个名为lib1.c的文件，写入如下内容： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include &lt;stdarg.h&gt; void LOG(const char *format, ...) { va_list argptr; char buffer[2048]; va_start(argptr,format); vsprintf(buffer,format,argptr); va_end(argptr); printf("%s\n", buffer); } void lib_function_1(void) { LOG("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7cf6ddd5be9a9d672a7830668a5c5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005382efde1431b4a6e69cf40a188624/" rel="bookmark">
			uniapp数据缓存（存储/获取/移除/清空）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uni-app中，可以使用uni.setStorageSync和uni.getStorageSync来进行数据的存储和获取。而移除缓存数据可以使用uni.removeStorageSync，清空缓存数据可以使用uni.clearStorageSync。
以下是使用示例：
存储数据： uni.setStorageSync('key', 'value'); 获取数据： var value = uni.getStorageSync('key'); 移除数据： uni.removeStorageSync('key'); 清空缓存数据： uni.clearStorageSync(); 注意：以上方法都是同步方法，如果需要异步操作，可以使用uni.setStorage和uni.getStorage方法。
存储数据示例：
uni.setStorage({ key: 'key', data: 'value', success: function () { console.log('存储成功'); } }); 获取数据示例：
uni.getStorage({ key: 'key', success: function (res) { var value = res.data; console.log('获取成功：' + value); } }); 移除数据示例：
uni.removeStorage({ key: 'key', success: function () { console.log('移除成功'); } }); 清空缓存数据示例：
uni.clearStorage({ success: function () { console.log('清空成功'); } }); 以上就是在uni-app中进行数据缓存的常用方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c5c8334e1a72d8f7d5e04bcd1e99d6/" rel="bookmark">
			Linux安装VMware17报错Before you can run VMware,several modules must be compiled and……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错提示 出现这种报错一般是vmmon和vmnet这俩模块没有经过签名认证,软件认为不安全,所以无法正常完成安装，那我们完成签名认证就行
二、centos 1.生成密钥和证书文件 openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -nodes -days 36500 -subj "/CN=VMware/" 2.签名内核模块: 先找到模块的位置
sudo find /lib/modules/ -name vmmon.ko sudo find /lib/modules/ -name vmnet.ko 正常会返回两个路径，接下来替换下面代码中后面的路径代码
sudo /usr/src/kernels/$(uname -r)/scripts/sign-file sha256 ./MOK.priv ./MOK.der /lib/modules/3.10.0-957.el7.x86_64/misc/vmmon.ko sudo /usr/src/kernels/$(uname -r)/scripts/sign-file sha256 ./MOK.priv ./MOK.der /lib/modules/3.10.0-957.el7.x86_64/misc/vmnet.ko 3.导入MOK密钥: sudo mokutil --import MOK.der 注意这步要在第一步生成密钥的路径下执行
即 ls 能看到有 MOK.priv 和 MOK.der 文件
4.重启电脑 reboot 重启后有几个选项
选第二个：Enroll MOK 如果不一样反正是选带MOK的
三、ubuntu 1.生成密钥和证书文件 openssl req -new -x509 -newkey rsa:2048 -keyout MOK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36c5c8334e1a72d8f7d5e04bcd1e99d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c6a45fe41305372329b46ef22e6fe9/" rel="bookmark">
			Android RecyclerView 动画处理 流程 原理（源码分析第三篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、本文主题 上篇文章 Android RecyclerView 动画处理 流程 原理（源码分析第二篇）讲了Recyclerview 动画的实现原理与主要流程。
本文接着上篇文章，分析两个具体一点的流程：
1. Recyclerview 动画执行前的view信息是如何进行保存的，保存了哪些信息
2. 怎样计算“动画执行后，View应该要处于的状态”的信息的？
一、动画执行前的view信息是如何进行保存的，保存了哪些信息 入口：RecyclerView.dispatchLayoutStep1()
调用栈如下：
dispatchLayout()
|
dispatchLayoutStep1()
1.1 dispatchLayout() dispatchLayout()主要用处就是 给所有子View做布局，并处理由布局引起的动画改变。
RecyclerView中有 5 种动画：
动画类别布局前后变化1 PERSISTENTvisible -&gt; visible2 REMOVEDvisible -&gt; removed3 ADDEDnot-exist -&gt; added4 DISAPPEARING(data exist before&amp;after) visible-&gt; non-visible5 APPEARING(data exist before&amp;after) non-visible -&gt; visible 整体方法就是：梳理出布局前、布局后哪些items存在，并且推断出每个 item 的动画类别（上面的5种之一）然后设置相应的动画。
RecyclerView设置每个 Item 的动画，具体是通过 ItemAnimator 接口的 animateXXX() 系列方法。
1.2 ItemAnimator.animateXXX() 对应上面的五种动画，ItemAnimator接口中，定义了一组 abstract 方法(4个)：
animateXXX()方法对应的动画类别1. animateDisappearance()2 REMOVED 和 4 DISAPPEARING2. animateAppearance()3 ADDED 和 5 APPEARING3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78c6a45fe41305372329b46ef22e6fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04c175536c1266cadc46842d4d574cb/" rel="bookmark">
			Flink（十）【处理函数】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 冬天学习成本太高了，每天冻得要死，自习室人满为患，确实是辛苦。学校基本的硬件条件差的一批（图书馆贼小贼偏僻、老教室暖气还没有地板热、空教室还得自己一个一个挨着找），个体无法改变环境只能顺应了（艹，受不了了，去校长信箱轰tnd）。
今天学习 Flink 处理函数，学完这一块就剩状态管理、容错机制和 Flink SQL 了，坚持坚持。学完再好好回顾回顾，最后就是把剩余的一些框架（Kafka、Flume等）补齐了。
1、处理函数 之前所介绍的流处理 API，无论是基本的转换、聚合，还是更为复杂的窗口操作，其实都是基于 DataStream 进行转换的；所以可以统称为 DataStream API，这也是 Flink 编程的核心。而我们知道，为了让代码有更强大的表现力和易用性，Flink 本身提供了多层 API，DataStream API 只是其中之一，如图：
在更底层，我们可以不定义任何具体的算子（比如 map，filter，或者 window），而只是提炼出一个统一的“处理”（process）操作——它是所有转换算子的一个概括性的表达，可以自定义处理逻辑（我们之前可以从 process 函数中获得 上下文对象 ctx、实现侧输出流等），所以这一层接口就被叫作“处理函数”（process function）。在处理函数中，我们直面的就是数据流中最基本的元素：数据事件（event）、状态（state）以及时间（time）。这就相当于对流有了完全的控制权。处理函数比较抽象，没有具体的操作，所以对于一些常见的简单应用（比如求和、开窗口）会显得有些麻烦；不过正是因为它不限定具体做什么，所以理论上我们可以做任何事情，实现所有需求。就相当于我们 Spark 中的 RDD 编程，它是最底层的东西，所以一些上层无法实现的，它都可以实现。
所以，总结一句话就是：只要是现有的算子实现不了的，直接上 process 即可。
1.1、基本处理函数 1.1.1、处理函数的功能和基本使用 我们之前学习的转换算子，一般只是针对某种具体操作来定义的，能够拿到的信息比较有限。比如 map 算子，我们实现的 MapFunction 中，只能获取到当前的数据，定义它转换之后的形式；而像窗口聚合这样的复杂操作，AggregateFunction 中除数据外，还可以获取到当前的状态（以累加器 Accumulator 形式）。另外我们还介绍过富函数类，比如 RichMapFunction，它提供了获取运行时上下文的方法 getRuntimeContext()，可以拿到状态，还有并行度、任务名称之类的运行时信息。
但是无论哪种算子，如果我们想要访问事件的时间戳，或者当前的水位线信息，都是完全做不到的。在定义生成规则之后，水位线会源源不断地产生，像数据一样在任务间流动，可我们却不能像数据一样去处理它，因为跟时间相关的操作，目前我们只会用窗口来处理。而在很多应用需求中，要求我们对时间有更精细的控制，需要能够获取水位线，甚至要“把控时间”、定义什么时候做什么事，这就不是基本的时间窗口能够实现的了。
这就需要我们使用——处理函数（ProcessFunction）了。处理函数提供了一个“定时服务”（TimerService），我们可以通过它访问流中的事件（event）、时间戳（timestamp）、水位线（watermark），甚至可以注册“定时事件”。而且处理函数继承了 AbstractRichFunction 抽象类，所以拥有富函数类的所有特性，同样可以访问状态（state）和其他运行时信息。此外，处理函数还可以直接将数据输出到侧输出流（side output）中。所以，处理函数是最为灵活的处理方法，可以实现各种自定义的业务逻辑；同时也是整个 DataStream API 的底层基础。
处理函数的使用与基本的转换操作类似，只需要直接基于 DataStream 调用.process()方法就可以了。方法需要传入一个 ProcessFunction 作为参数，用来定义处理逻辑（我们之前通过给 process 方法传入一个实现了 ProcessFunction 抽象类的匿名内部类来实现侧输出流、通过给 process 方法传入一个实现了 CoProcessFunction 抽象类的匿名内部类来实现合流 ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04c175536c1266cadc46842d4d574cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/466ab3d44cd4f55d95aeba904b4e5497/" rel="bookmark">
			NGINX安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、官网下载 http://nginx.org/en/download.html
2、上传到服务器安装目录 3、解压 tar -zxvf nginx-1.20.1.tar.gz 4、安装依赖 yum -y install gcc yum -y install pcre pcre-devel yum -y install openssl openssl-devel cd nginx-1.20.1 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module make make install 6、配置环境变量 vi /etc/profile 添加内容： export PATH=/usr/local/nginx/sbin:$PATH 刷新配置： source /etc/profile 7、启动服务 nginx 8、访问主页 shell&gt; curl http://127.0.0.1 9、停止服务 shell&gt; nginx -s stop 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977d5d66974ffc3e3c72696de9c0f49f/" rel="bookmark">
			《小聪明》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简言
一、python方面
1.1、字符串前补0
1.2、python安装包镜像网站
1.3、pip无法卸载包时
1.4、dataframe设置全行或全列显示
1.5、dataframe对某一列特征编码
1. 6、dataframe任意位置插入一列值
1.7、sklearn算法，输出特征方程
1.8、解决dataframe写入csv会出现科学技术法的情况
1.9、dataframe行转列（行列互换）
1.10、正则找出两个特定字符中间的所有内容
1.11、正则匹配字符串中的中文内容
1.12、正则匹配括号里的内容
1.13、try捕获具体报错的行数及文件
1.14、升级pip
1.15、ip地址转int类型
1.16、ip校验
1.17、特征归一化
1.18、dataframe自动转变类型
1.19、机器学习分类问题求精度
1.20、忽略警告
1.21、matplotlib图上正常显示中文
1.22、dataframe的merge与concat
1.23、字符串空白检查与替换
1.24、dataframe按某列排序
二、sql方面
2.1、hive时间格式化
2.2、hive后台load data入表
三、linux方面
3.1、linux中python设置后台运行
3.2、linux远程拷贝
3.3、linux查看文件编码
3.4、linux打包与解压
3.5、设置vim打开文件的默认编码格式
一、简言 本文主要记录一些工作中记录的一些需求处理方式方法，后续如再遇到可以直接查看。主要涉及python、linux、sql领域一些内容，后续如有其他内容还会新增。
一、python方面 1.1、字符串前补0 str(1).zfill(4) # 输出：0001 1.2、python安装包镜像网站 https://pypi.tuna.tsinghua.edu.cn/simple 1.3、pip无法卸载包时 pip install --ignore-installed xxx 1.4、dataframe设置全行或全列显示 # 设置全列显示 pd.set_option('display.max_columns',None) # 设置全行显示 pd.set_option('display.max_rows',None) 1.5、dataframe对某一列特征编码 sex_mapping = {label: idx for idx, label in enumerate(set(df['sex']))} df['sex'] = df['sex'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/977d5d66974ffc3e3c72696de9c0f49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050ffcf9cb2e068b257cf1147f711e4c/" rel="bookmark">
			C&#43;&#43;基础系列（二）纯虚函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 概念 纯虚函数（pure virtual function）是指被标明为不具体实现的虚拟成员函数。它用于这样的情况：定义一个基类时，会遇到无法定义基类中虚函数的具体实现，其实现依赖于不同的派生类。
二. 定义 定义纯虚函数的一般格式为：
virtual 返回类型 函数名（参数表）=0；
含有纯虚函数的基类是不能用来定义对象的。纯虚函数没有实现部分，不能产生对象，所以含有纯虚函数的类是抽象类。
定义纯虚函数必须注意：
1 定义纯虚函数时，不能定义虚函数的实现部分。即使是函数体为空也不可以，函数体为空就可以执行，只是什么也不做就返回。而纯虚函数不能调用。
2 “=0”表明程序员将不定义该函数，函数声明是为派生类保留一个位置。“=0”本质上是将指向函数体的指针定为NULL。
3 在派生类中必须有重新定义的纯虚函数的函数体，这样的派生类才能用来定义对象。
三. 理解 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Shape { public: //虚函数 virtual float area() const {return 0.0;} //虚函数 virtual float volume() const {return 0.0;} //纯虚函数 virtual void shapeName() const = 0; //纯虚函数一般形式为： // virtual 函数类型 函数名（参数列表） = 0; // 1. 纯虚函数没有函数实体 // 2. 最后“=0” 并不表示函数返回值为0， 它只起形式上的作用告诉编译系统“这是纯虚函数” // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050ffcf9cb2e068b257cf1147f711e4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62377506ff7ce5bdf39512b556eec506/" rel="bookmark">
			Vue2动态路由&#43;鉴权&#43;异步请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景：Vue2动态路由+鉴权+异步请求 动态路由+鉴权：
项目场景：在用户登录到系统中的时候，去服务器校验获取令牌，同时返回相关的数据，此时请求速度慢于组件的渲染速度，会产生异步，页面404或者空白。
问题描述 异步函数
请求登录接口Api数据没响应回来，系统就读取数据，此时为空。
主要思路是：
①登录鉴权，获取令牌和数据存储到VueX中（Store）
②在首页挂载的时候读取store里面的数据 渲染页面
在②的时候读取不到，而是在②执行完成后，才把值set到store里。
因为系统集成比较多，没有登录界面但是也需要鉴权，就没有把getUserInfo分离
全局前置守卫 中接收数据代码：
store.dispatch('login', userId).then(() =&gt; { console.log("router") loadingInstance.close() next({replace: true}) }) 原因分析： 异步请求函数
组件的渲染速度很快，接口响应速度慢于渲染速度，产生异步导致不能及时第一时间获取数据和令牌
解决方案： 使用关键字async await 告诉js引擎这是一个异步请求，等待api的响应结果
store.dispatch('login', userId).then(async () =&gt; { console.log("router") loadingInstance.close() await next({replace: true}) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2f41f4bfcf8d03527d8674e845e8acb/" rel="bookmark">
			安装docker-compose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在线安装（需要梯子） [root@lgb /]# curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose [root@lgb bin]# chmod +x /usr/local/bin/docker-compose [root@lgb bin]# docker-compose -version docker-compose version 1.29.0, build 07737305 二、离线安装 https://github.com/docker/compose/tags
选择对应版本，amd=x64_86=x86 ，amd并不是指amd的cpu，两者没有半毛钱关系，centos通常选择amd或者x64_86或者x86。
[root@lgb /]# mv docker-compose-linux-x86_64 /usr/local/bin/docker-compose [root@lgb bin]# chmod +x /usr/local/bin/docker-compose [root@lgb bin]# docker-compose -version docker-compose version 1.29.0, build 07737305 如果需要使用docker-compose部署应用，请先安装docker
安装docker教程：docker--安装docker-ce-CSDN博客
docker-compose部署常见中间件：使用docker-compose高效部署常见应用_安装docker-compose-CSDN博客
docker-conpose官方文档： Samples overview | Docker Docs
参考：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b67a4b4db4893ae201a755f5a029f13/" rel="bookmark">
			腾讯云向开放原子开源基金会捐赠OpenTenBase，共建国产数据库新生态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12月16日，在2023开放原子开发者大会上，腾讯云将企业级分布式数据库TDSQL的社区发行版 OpenTenBase 正式捐赠给开放原子基金会，通过开源共创的方式，与上下游产业链以及开发者共同打造繁荣数据库技术生态。
OpenTenBase 目前已在腾讯社交、游戏、广告、金融等内部业务及外部商用场景下打磨10年以上，可完美适用于拥有海量数据、高并发、高HTAP，以及分布式事务能力的应用场景。这是继编译器软件OpenKona JDK，以及全链路自主演进的操作系统OpenCloudOS之后，腾讯捐赠的又一重磅基础软件项目。
开放原子开源基金会秘书长冯冠霖表示：“很高兴看到腾讯能够把多年研发打磨、通过海量业务场景考验的基础软件数据库项目OpenTenBase开源并捐赠到基金会，未来，基金会将秉持中立开放的态度，与业界一起将OpenTenBase打造成为具有全球影响力的优秀开源项目。”
数据库作为计算机三大基础软件之一，向下可充分发挥硬件算力，向上支撑上层的应用需求，是信息系统高效运行的关键基础。腾讯云数据库研发总经理潘安群表示，OpenTenBase数据库在技术上填补了业内基于 PostgreSQL的开源分布式OLTP系统空白，并且集HTAP双引擎、分布式事务一致性、高 SQL 兼容度、复杂查询等技术能力于一身，能够为企业数字化转型提供强有力支撑。
在引擎方面，OpenTenBase同时支持OLTP（在线交易处理）和OLAP（在线分析处理）能力，能够有效降低业务架构复杂度和成本；
在事务一致性方面，引入全局事务管理节点来管理分布式事务，通过分布式事务一致性技术来保证在全分布式环境下的事务一致性；
在兼容性方面，高度兼容PostgreSQL版本和Oracle版本；
在查询方面，全新开发分布式查询优化器，可将复杂查询的性能提升十倍以上。
腾讯云数据库TDSQL近年来在多个领域取得重要突破，在性能上，今年3月刷新TPC-C世界记录，每分钟事务处理数达到8.14亿。在最新的IDC报告中，位居中国分布式关系型数据库“领导者”类别，并在市场份额上取得国内第一的成绩。
腾讯云数据库总经理王义成介绍，TDSQL已涵盖金融级分布式、云原生、分析型等多引擎融合的完整数据库产品体系，提供业界领先的金融级高可用、存算分离、数据仓库、企业级安全等能力。未来会持续投入和突破数据库核心技术，打造更加健康可持续发展的数据库生态和开源社区，为企业数字化转型提供长久动力。
腾讯是开源技术的坚定推进者和建设者，多年来一直不断推动更底层更重磅的技术对外开放。截至目前，腾讯已经对外开源了170余个项目，在全球企业开源榜位居前十，获得了超过47万的开发者关注和点赞。在本次峰会上，腾讯获颁“开放原子校源行杰出合作伙伴”“白金捐赠人”“三年杰出贡献人”“开源安全委员会年度贡献单位”等多项大奖，并参与开源人才教育、操作系统创新、AI 数据存储、木兰峰会等多个分论坛。
未来，腾讯云将秉持开放、开源战略，持续打磨技术能力，携手开放原子开源基金会、广大开发者和各行业合作伙伴，推动我国关键数字基础设施加速突破。
请给项目 一个 Star !
欢迎提出你的 issue 和 PR！
关注腾讯开源公众号
获取更多最新腾讯官方开源信息！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca83817e0fa768e060890b980e993f7/" rel="bookmark">
			【javascript】npm ERR! cb() never called！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误 环境 windows 10
nvm
node 14.17.0
如何解决 尝试了 5 种方法
1，npm cache clean --force
2, npm cache verify
3, 删掉package-lock.json （然鹅我的这个项目没有这个文件）
4, npm set strict-ssl false
5, 删除node_modules
这五种办法之后，再执行npm install ，老样子，是不是电脑环境问题，用一台干净的windows电脑安装nvm，然后安装node版本，然后再安装，很好，老样子
nvm uninstall所有node版本，然后去官网下载一个node安装包（我是用的zip文件），然后用这个node安装，最后不报错
😄
还有一种办法，直接重装nvm试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af5464041e41f7b134657ac2d0d6a03/" rel="bookmark">
			关于“Python”的核心知识点整理大全31
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
12.4.2 在屏幕上绘制飞船
alien_invasion.py
​编辑12.5 重构：模块 game_functions
12.5.1 函数 check_events()
game_functions.py
alien_invasion.py
12.5.2 函数 update_screen()
game_functions.py
alien_invasion.py
12.6 驾驶飞船
12.6.1 响应按键
game_ functions.py
alien_invasion.py
12.6.2 允许不断移动
ship.py
game_functions.py
alien_invasion.py
12.6.3 左右移动
ship.py
game_functions.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
12.4.2 在屏幕上绘制飞船 下面来更新alien_invasion.py，使其创建一艘飞船，并调用其方法blitme()：
alien_invasion.py --snip-- from settings import Settings from ship import Ship def run_game(): --snip-- pygame.display.set_caption("Alien Invasion") # 创建一艘飞船 1 ship = Ship(screen) # 开始游戏主循环 while True: --snip-- # 每次循环时都重绘屏幕 screen.fill(ai_settings.bg_color) 2 ship.blitme() # 让最近绘制的屏幕可见 pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af5464041e41f7b134657ac2d0d6a03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0bfa97162ed568beaed2dad0377f0d/" rel="bookmark">
			ERROR: Could not build wheels for Pillow, which is required to install pyproject.toml-based projects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错的场景：windows10 安装 python Pillow
2.使用的命令：pip install wheel Pillow
Collecting wheel
Using cached wheel-0.42.0-py3-none-any.whl.metadata (2.2 kB)
Collecting Pillow
Downloading Pillow-10.1.0.tar.gz (50.8 MB)
---------------------------------------- 50.8/50.8 MB 173.3 kB/s eta 0:00:00
Installing build dependencies ... done
Getting requirements to build wheel ... done
Installing backend dependencies ... done
Preparing metadata (pyproject.toml) ... done
Using cached wheel-0.42.0-py3-none-any.whl (65 kB)
Building wheels for collected packages: Pillow
Building wheel for Pillow (pyproject.toml) ... error
error: subprocess-exited-with-error
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0bfa97162ed568beaed2dad0377f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582ddebe58ff0ecf4570d99c9173e7eb/" rel="bookmark">
			CSS实现固定首列和表头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;首行首列固定&lt;/title&gt; &lt;style&gt; /*外层div，设置宽高度*/ div { width: 90vw; height: 90vh; border: 1px solid #dcdee2; overflow: auto; } table { border-collapse: separate; /*设置边框会被分开，而不是合并*/ table-layout: fixed; /*列宽由表格宽度和列宽度设定。*/ width: 100%; word-wrap: break-word; } td, th { border-right: 1px solid #dcdee2; border-bottom: 1px solid #dcdee2; height: 30px; text-align: center; background-color: #fff; } /* 固定表头 */ thead { position: sticky; top: 0; z-index: 1000; } /* th { background-color: #ccc; } */ /* 首列 */ tbody tr td:first-child { position: sticky; left: 0; z-index: 100; } /* 最左上角 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582ddebe58ff0ecf4570d99c9173e7eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46efe21134667470ca838702b0bc30e3/" rel="bookmark">
			【组件本质学习】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import React, {Component, useState, useEffect,} from 'react'; class MyComponent { render() { return { tag: 'div' } } } // 函数式组件： // // 是一个纯函数 // 没有自身状态，只接收外部数据 // 产出 VNode 的方式：单纯的函数调用 // 有状态组件： // // 是一个类，可实例化 // 可以有自身状态 // 产出 VNode 的方式：需要实例化，然后调用其 render 函数 export default () =&gt; { // // init方法用来创建patch函数 // const patch = init([]) // // 我所创建的组件, 组件的作用就是返回一个虚拟dom // /**** // * // * @param props // * @constructor // * Virtual DOM带来了分层设计，它对渲染过程的抽象，使得框架可以渲染到web(浏览器) // * 以外的平台，以及能够实现SSR（Server Side Rendering） // */ // const MyComponent = (props: any) =&gt; { // return h('h1', props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46efe21134667470ca838702b0bc30e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf1926fde4bbd96f4fdc1ed7fca64d1/" rel="bookmark">
			数据分析基础之《numpy（4）—ndarry运算》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、逻辑运算
当我们要操作符合某一条件的数据时，需要用到逻辑运算
1、运算符
满足条件返回true，不满足条件返回false
# 重新生成8只股票10个交易日的涨跌幅数据 stock_change = np.random.normal(loc=0, scale=1, size=(8, 10)) # 获取前5行前5列的数据 stock_change = stock_change[0:5, 0:5] # 逻辑判断，如果涨跌幅大于0.5，就标记为true，否则标记为false stock_change &gt; 0.5 2、布尔索引
想要对布尔数据进行一个统一的操作，相当于是取出数组中为true的所以值，或为false的所有值
# 布尔索引 stock_change[stock_change &gt; 0.5] 二、通用判断函数
1、np.all()
传入一组布尔值，只要有一个false，就返回false，全都是true才返回true
2、np.any()
传入一组布尔值，只要有一个true，就返回true，全都是false才返回false
3、例子
# 判断stock_change是否全是上涨的 np.all(stock_change &gt; 0) stock_change # 判断stock_change是否有上涨的 np.any(stock_change &gt; 0) 三、np.where（三元运算符）
1、通过使用np.where能够进行更加复杂的运算
np.where(布尔值, true的位置要设置的值, false的位置要设置的值)
2、例子
# 判断前四个股票前四天的涨跌幅，大于0的置为1，否则为0 temp = stock_change[:4, :4] temp np.where(temp &gt; 0, 1, 0) 3、np.logical_and 逻辑与
4、np.logical_or 逻辑或
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cf1926fde4bbd96f4fdc1ed7fca64d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e26125f5f7f8693f58b0cc1b2df3412/" rel="bookmark">
			大数据存储技术（4）—— NoSQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、键值数据库Redis
（一）Redis简介
（二）Redis数据类型
（三）Redis持久化
二、列存储数据库HBase
（一）简介
（二）HBase数据表
（三）Hbase物理存储
三、文档数据库MongoDB
（一）MongoDB简介
（二）MongoDB基本概念
四、图数据库Neo4j
（一）Neo4j与知识图谱
（二）Neo4j的核心概念
前言 NoSQL（Not Only SQL），意即“不仅仅是SQL”。NoSQL的拥护者提倡运用非关系型的数据存储作为大数据存储的重要补充。NoSQL数据库适用于数据模型比较简单、IT系统需要更强的灵活性、对数据库性能要求较高且不需要高度的数据一致性等场景。
NoSQL数据库具有如下四大分类：
1、键值（Key-Value）存储数据库：常见的键值存储数据库有Tokyo Cabinet / Tyrant、Berkeley DB、MemcacheDB、Redis等。
2、列存储数据库：如HBase、Cassandra、Riak等。
3、文档型数据库：常见的文档型数据库有MongoDB、CouchDB、SequoiaDB等。
4、图（Graph）数据库：诸如Neo4J、InfoGrid、Infinite Graph等。
一、键值数据库Redis （一）Redis简介 Redis（REmote DIctionary Server）是一个由Salvatore Sanfilippo写的Key-Value内存数据库，能达到每秒十万次的读写，常用作缓存或者消息队列。 Redis是使用ANSI C语言编写的，遵守BSD协议，支持网络并可基于内存和可持久化的日志型Key-Value数据库，提供多种语言的API。 Redis数据库中的值（value）可以是字符串（string）、哈希（map）、列表（list）、集合（sets）和有序集合（sorted sets）等类型。
与其他Key-Value缓存产品相比，Redis主要具有以下三个特点： 首先，Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时可以再次加载使用； 其次，Redis不仅仅支持简单的Key-Value类型的数据，同时还提供list、set、zset、hash等数据结构的存储。 最后，Redis还支持数据的备份，即Master/Slave模式的数据备份，可以将数据从主服务器复制到任意数量的从服务器。 Redis运行在内存中并可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单。
（二）Redis数据类型 Redis支持5种数据类型：string（字符串）、hash（哈希）、list（列表）、set（集合）及zset。
1、string（字符串）
字符串是最常用的一种数据类型，普通的Key/Value存储都可以归为此类。
2、hash（哈希）
哈希是一个string类型的field和value的映射表。hash特别适合存储对象，相当于将对象的每个字段存成单个string类型。Redis的hash实际是将内部存储的value作为一个HashMap，并提供了直接存取这个Map成员的接口，如图所示为Redis中的哈希结构。
3、list（列表）
列表是一个链表结构，可以从头部（左边）或者尾部（右边）添加和删除元素。Redis的list类型其实就是每个子元素都是string类型的双向链表，我们可以通过push或pop操作从链表两端添加删除元素。
4、set（集合）
set是string类型的无序不重复集合。set是通过hash table实现的。可以对集合采取并集、交集、差集操作；还可以使用不同的命令将结果返回给客户端并且存到一个新的集合中。
5、zset
zset在set的基础上增加了一个顺序的属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以将其理解为有列的表，一列存value，一列存顺序，操作中key理解为zset的名字。
（三）Redis持久化 Redis将内存中的数据同步到磁盘来保证持久化。Redis主要支持使用Snapshotting（快照）和Append-only file（aof）两种方式实现数据的持久化。
1、Snapshotting
快照是默认的持久化方式。这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。可以通过配置设置自动做快照，比如可以配置Redis在n秒内如果超过m个key被修改就自动做快照。
2、Append-only file
Append-only file方式比快照方式有更好的持久化性，是由于在使用aof方式进行数据的持久化时，Redis会将每一个收到的写命令都通过write()函数追加到文件中。当redis重启时会通过重新执行文件中保存的写命令，在内存中重建整个数据库的内容。当然由于操作系统会在内核中缓存写操作所做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失部分修改。不过可以通过配置文件告知Redis通过fsync函数强制操作系统写入到磁盘的策略。
二、列存储数据库HBase （一）简介 HBase是一个分布式的、面向列的开源数据库。它主要用来存储非结构化和半结构化的松散数据，是基于列而非行进行数据存储的。HBase建立在HDFS之上，仅能通过主键（row key）和主键的range来检索数据，仅支持单行事务，可以通过Hive支持来实现多表join等复杂操作。它还可以横向扩展，增加廉价的商用服务器来提高HBase的计算和存储能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e26125f5f7f8693f58b0cc1b2df3412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5241aecbf8145f79f6a0bd144a6c3e/" rel="bookmark">
			Jackson与Gson的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 概览
Jackson
Gson
2. 序列化/反序列化
Jackson
Gson
3. 性能
4. 社区支持和可维护性
5. 兼容性和扩展性
结论
1. 概览 Jackson 功能丰富: 提供了广泛的JSON处理能力，包括序列化/反序列化、数据绑定、流式API等。性能: 在许多基准测试中显示出优异的性能，尤其是在大型对象图的序列化和反序列化中。扩展性: 提供了许多模块和注解，支持多种数据格式，如XML、CSV等。社区和支持: 由于其广泛的使用，拥有一个活跃的社区和良好的维护支持。 Gson 易用性: 设计简单直观，易于上手。集成: 与Google的其他项目集成良好，如Google App Engine。轻量级: 相对于Jackson，Gson的库更小，依赖更少。文档和样例: 提供了丰富的文档和示例代码。 2. 序列化/反序列化 Jackson 支持注解和模块化方式来自定义序列化和反序列化的行为。提供了流式API和对象映射API，可以处理复杂的数据结构。允许在序列化过程中包含和排除属性，通过@JsonIgnore等注解实现。 Gson 主要通过简单的toJson()和fromJson()方法进行序列化和反序列化。支持自定义序列化器和反序列化器，但不如Jackson提供的注解那样灵活。简单的API意味着在处理复杂场景时可能需要编写更多的代码。 3. 性能 Jackson: 通常被认为在性能方面略优于Gson，特别是在处理大型对象和复杂的JSON结构时。Gson: 性能表现良好，但在大型数据处理方面可能不及Jackson。 4. 社区支持和可维护性 Jackson: 有着广泛的用户基础和活跃的社区，不断有新功能和性能改进，提供了更好的长期支持。Gson: 也有着稳定的社区支持，但更新和新特性的推出可能不如Jackson频繁。 5. 兼容性和扩展性 Jackson: 支持多种数据格式的扩展，可以与许多Java框架无缝集成，如Spring。Gson: 主要关注JSON，对于其他格式的支持不如Jackson。 结论 选择Jackson还是Gson，取决于具体的项目需求。如果需要高性能和高度的可定制性，Jackson可能是更好的选择。如果项目需要轻量级的库，或者与Google的其他服务有紧密的集成，Gson可能更合适。在实际使用中，两者都是成熟的库，能够为Java应用提供可靠的JSON处理能力。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/30/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>