<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba90fe167620c89d57427fdf3bae80b7/" rel="bookmark">
			如何利用t-SNE可视化自己的数据集分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【转载】利用t-SNE可视化自己的数据集分布_tsne数据集制作-CSDN博客
安装 1、在Linux机器上执行下面操作。
2、使用代码之前需要先安装一个t-SNE的库，地址是GitHub - CannyLab/tsne-cuda: GPU Accelerated t-SNE for CUDA with Python bindings。该库是github上一个高分的开源库，用了cuda加速实现起来比sklearn的t-SNE要快得多，从读取到画图我自己实验确实只需要10秒不到的时间。
3、github上下载TSNE-CUDA项目到本地后，在终端的虚拟环境中输入
pip install -e .
安装好后输入
import tsnecuda
tsnecuda.test()
没有报错说明安装成功
3、在TSNE-CUDA文件夹下创建数据集文件data_set,data_set里放自己的数据集(比如我的数据集叫radar_oldANDyoung,里边包含train和val两个文件夹,每个文件夹下边分别有5个子文件夹，命名为1-5)，其中1-5分别为类名，每个类下边是属于该类的图片
4、在examples文件夹下创建python文件，比如my_tSNE.py,把我下边的代码粘贴进去
5、几个需要修改的地方我的代码里基本都有注释，不懂的可以在本帖下边留言，不定期回复 6、结果图：
代码 import numpy as np from tsnecuda import TSNE import matplotlib.pyplot as plt import numpy as np import cv2 import os size = 224 #resize图片的大小，运行时如果爆显存的话把这里调小即可 # get_data(Input_path,Label) # 作用：读取Input_path里的图片，并给每张图打上自定义标签Label def get_data(Input_path,Label): Image_names=os.listdir(Input_path) #获取目录下所有图片名称列表 data=np.zeros((len(Image_names),size*size*3)) #初始化一个np.array数组用于存数据,自己图片是n维的就把3改成n即可 label=np.zeros((len(Image_names),1)) #初始化一个np.array数组用于存数据 #为当前文件下所有图片分配自定义标签Label for k in range(len(Image_names)): label[k][0]=Label for i in range(len(Image_names)): image_path=os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba90fe167620c89d57427fdf3bae80b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d4719e4cfdbd17b39a7616aa8e46c6b/" rel="bookmark">
			Cython编译文件出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：
(rpc) stu@amax:~/segment/dss_crf$ python setup.py install Compiling pydensecrf/eigen.pyx because it changed. Compiling pydensecrf/densecrf.pyx because it changed. [1/2] Cythonizing pydensecrf/densecrf.pyx /home/stu/anaconda3/envs/rpc/lib/python3.6/site-packages/Cython/Compiler/Main.py:381: FutureWarning: Cython directive 'language_level' not set, using '3str' for now (Py3). This has changed from earlier releases! File: /home/stu03/kdy/rpc/segment/dss_crf/pydensecrf/densecrf.pxd tree = Parsing.p_module(s, pxd, full_module_name) Error compiling Cython file: ------------------------------------------------------------ ... from eigen cimport * ^ ------------------------------------------------------------ pydensecrf/densecrf.pxd:1:0: 'eigen.pxd' not found Error compiling Cython file: ------------------------------------------------------------ ... cdef cppclass PottsCompatibility(LabelCompatibility): PottsCompatibility(float) except + cdef cppclass DiagonalCompatibility(LabelCompatibility): DiagonalCompatibility(const c_VectorXf&amp;) except + ^ ------------------------------------------------------------ pydensecrf/densecrf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d4719e4cfdbd17b39a7616aa8e46c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafcae661f834c30bf50dbddb18efbb1/" rel="bookmark">
			C#结合JavaScript实现多文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求
引入
关键代码
操作界面
​JavaScript包程序
服务端 ashx 程序
服务端上传后处理程序
小结
需求 在许多应用场景里，多文件上传是一项比较实用的功能。实际应用中，多文件上传可以考虑如下需求：
1、对上传文件的类型、大小有一个基本的控制。
2、上传文件时有一个进度显示，包括当前文件和整体进度。
3、上传后，在服务端后续事件进行一些处理。
引入 首先请在WEB应用程序根目录下创建COMMON目录，并引入 JavaScript 程序包，该程序包已经打包，下载地址为：https://download.csdn.net/download/michaelline/88615565。
下载成功后解压到COMMON目录即可，请引入如下图中的 JS 文件：
另外，我们还需要在 app_data目录下创建 ajaxUploadFiles 子目录，以备上传创建文件使用。
关键代码 操作界面 界面上放置标准的 input file 控件，并将其服务器化，即 runat="server"。点击选择文件，选中所有目标文件后，自动实现文件上传功能。
示例界面如下：
​ 示例UI代码如下：
&lt;input class="file" type="file" id="ajaxMfile" runat="server" onbeginupload="ajax_uploadFiles_beginUpload" onprogressupload="ajax_uploadFiles_progressUpload" onendupload="ajax_uploadFiles_endUpload" multiple="multiple" allowtype="pptx|docx|mp3|txt|std" allowsize="500m|100m" fileindex="0" name="fileupload" serverbuttonid="ajaxEndBtn" serverfilelistid="ajaxReturnFileName" progresspanelid="ajaxMfileProgressPanel" onchange="ajax_uploadFiles(this);return false" /&gt; &lt;asp:TextBox runat="server" Width="100%" ID="ajaxReturnFileName" style="display:none" &gt;&lt;/asp:TextBox&gt; &lt;br /&gt; &lt;asp:button ID="ajaxEndBtn" text="后台处理" runat="server" style="display:none" onclick="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fafcae661f834c30bf50dbddb18efbb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a9ea481610a55cddb9b6b77ac63901/" rel="bookmark">
			Pyhon基于YOLOV实现的车辆品牌及型号检测项目源码&#43;模型&#43;项目文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行运行录屏： Pyhon基于YOLOV实现的车辆品牌及型号检测项目运行录屏
完整代码下载地址：Pyhon基于YOLOV实现的车辆品牌及型号检测项目 项目背景： 车辆检测及型号识别广泛应用于物业，交通等的管理场景中。通过在停车场出入口，路口，高速卡口等位置采集的图片数据，对车辆的数量型号等进行识别，可以以较高的效率对车型，数量信息等进行采集。通过采集的数据，在不同的场景中可以辅助不同的业务开展。如商场停车位的规划，路况规划，或者公安系统追踪肇事车辆等等。
项目要求： 使用slim框架来对图片进行分类识别。掌握使用slim物体检测框架来进行物体的检测和识别。传入一张图片实现上述两个功能，显示出最终的结果。 项目方案的分析与方案确定 项目提供的素材： 一个车辆分类的数据集。只是分类数据，内部没有定位信息。共48856张图片其43971张作为训练集，4885张作为验证集。数据已经预先打包成tfrecord格式，数据格式与课程中，分类模型使用的数据格式相同，打包关键代码参考"download_and_convert_flowers.py"。 数据集分类文件labels.txt
达到项目要求所缺少的因素 看不到具体的图片，图片已经打包成tfrecord格式，不知道是什么样的图片。项目提供的素材，不包括检测的标签，也就是给定的素材不能完成检测网络的训练。 各种方案可行性对比和方案的确定 因此，经过讨论，我们的首要任务是将tfrecord数据复原出来，并且找到一种合适的方式能实现检测功能。
可能的方案有：
使用label-image 自己制作检测数据集，在原始图片上进行标注，然后就有了分类标签和检测标签，就可以训练一个端到端的模型。但是缺点是图片太多，而项目周期只有一个月，估计不可能完成。使用一个现有的预训练的检测模型，例如YOLO、faster-rcnn、ssd_mobilenet_v1_coco等，他们已经实现了对一些物体的检测功能，其中还都包含小汽车，因此可以利用这种网络完成检测功能，把读取出来的图片一次输入网络中，生成检测的标定数据，然后重新打包tfrecord文件，最终可以训练出一个端到端的检测加分类模型。这样的可行性也比较高，而且感觉工作量不大，唯一一点是感觉代码难度稍微有点大（相比于下面一种方案），万一要是卡住在中间的环节有可能造成时间紧张。不过总体感觉依旧是个可行的方案。像上一步一样，找一个现成的检测模型，把输入的图片进行检测，再把检测出来的结果输入到自己训练的分类网络中，就可以实现项目需求了，而且相比于其他方案难度最小，最有可能完成这项任务。但是问题是整个过程经过了两步执行操作，感觉没有一步执行完成效率高。 经过对比，我们最终选择了第三个方案。
方案的实施与计划 最终的方案流程如下：
图3-1 方案流程图
项目实施计划如下：
第一周：
数据探索，复原出原始图片内容，进行数据探索、并分析。确定最终使用的检测模型 。 第二周：
测试检测模型的效果，编写调用接口。使用Inception_v4进行分类训练，使之达到85%以上的Top5准确率。 第三周：
完成分类模型项目接口。与检测模型的接口进行整合。将功能整合进一个Web服务功能中。 第四周：
文档撰写与完善代码。 数据探索 复原原始图片 根据项目提示，图片打包过程参考flower的例子，经过研究源代码打包过程和解包过程，我们完成了图片的复原工作。将图片按照分类放进各自的文件夹中。
3-2 获取原始图片数据 如图3-2左侧是复原图片过程的输出，可以看到图片的尺寸都是4xx*320，三通道的jpg图片，图片的高都是一样的，宽度略有不同。这个输入到训练之前，会经过一些图片预处理操作。训练时会将图片统一尺寸，做一些裁剪、随机flip翻转、颜色扭曲等如图3-3。 3-3 图片预处理部分 最后复原出来的图片train集是43972个图片，764个文件夹对应labels.txt中764个分类，训练集的图片数比项目说明中的多了一个，我想可能是因为43971个图片分成4个数据集的取整问题，最后复原的时候可能多了一张重复的，这个没多大关系。 可以发现训练集中每种品类的汽车都有不同的视角、颜色、背景的图片，看来识别车型的影响因素还挺多的。但是数据的主体都拍照的比较清楚，处于画面正中位置，所以应该可以实现不同视角下汽车的分类功能。 发现的问题：训练集里面还是有一些错误的图片的，比如好几次把现代车放进其他车型的标签下的情况，而且是同一张图片放入多次，但是鉴于这样的错误比例不高，所以训练的时候暂时不做处理。先放进网络中训练试试。 选择Yolo作为检测网络 首先，Yolo是回归检测的开山之作，检测效果不错mAP~0.58，而且运行速度非常快能够达到45-150帧每秒。另外一个是因为我们团队的黎同学之前研究过这个模型，所以弄起来比较有把握。
在只有分类的数据集的情况下，我们不能直接使用YOLO模型去进行端到端的训练，因为我们人力有限，为了节约时间成本，我们在网上把开源的YOLO模型拿下来，调用YOLO模型在VOC训练集上训练所得到的预训练参数，写出一个检测程序。 然后我们测试了一下检测的能力：
图3-4 YOLO检测汽车测试
图3-5 YOLO检测更多辆汽车测试
可以看到，YOLO能够出色的完成多辆汽车检测的任务，框选出来的位置很准确。只是会把汽车分成truck、car、bus等分类，这个只需要后期做一下处理都当成汽车就行了。
使用Inception_v4进行分类网络的训练 下一步就是要进行分类网络的训练，项目要求使用Inception_v4模型。于是我们就读了一下Inception_v4的论文，然后研究了一下slim分类训练里面的代码。
Inception_v4论文 论文中介绍了Inception_v4的网络结构还同时介绍了另外一种加了residual的Inception_v4的结构。 同时还把Inception_v3以及带residual的inception_v3做了对比，得出了一些结论：
Inception_v4在Inception_v3的网络结构上进行了一些结构上的微调，最终的实验结果是
图3-6 四种模型的训练结果
Inception_v4系列比Inception_v3系列相比，准确率方面是更优秀的，Top-5 error减少了1.多，另外加了residual的V3或者V4都比不加的模型训练更快的收敛，但是准确率方面倒没有什么更多的贡献。
训练Inception_v4，实现分类功能 训练的思路是，先从slim的github上下载预训练的模型
图3-7 Inception_v4
然后对这个模型进行Finetune。过程是这样的：
图3-8 Inception_v4进行finetune
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3a9ea481610a55cddb9b6b77ac63901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b339ec4d6946b8d42a681aa9baa2d2/" rel="bookmark">
			【算法】怎么用算法给外卖小哥规划路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 假设现在外卖小哥接了10个单，那么要怎么规划路线呢？当然，经验丰富的老哥一看就知道了，但是新人菜鸟小哥就未必能找到节省时间的路线。
那么，如果使用算法来解决这个问题会怎么样？如何在尽量少的总路程和时间内，选择一条优秀路线呢？不妨使用搜索算法来解决这个问题，例如遗传算法就可以解决这类型的问题。
主要包括两步
1.A、B两点之间的代价函数
这里的代价不仅是时间，也要考虑路程，难易程度等。当然，只考虑时间也是可以的，主要看小哥自己认为代价是什么。
2.寻找最优路径
使用优化算法，寻找一条总代价最小的路径就可以了。可以使用遗传算法、模拟退火算法、PSO算法等等。
一、送餐的代价函数 我们需要考虑到多种因素，包括但不限于：
1.交通状况：交通状况是影响外卖小哥送餐速度的重要因素之一。规划路线时需要考虑到交通拥堵、红绿灯等因素，选择最佳的路线。
2.餐厅出餐速度：外卖小哥需要考虑到餐厅出餐速度，避免等待时间过长，影响送餐速度。
3.客户要求：有些客户可能有特殊要求，比如需要外卖小哥爬楼梯等，规划路线时需要考虑到这些因素
对上述每个因素，都分别进度量，最后综合，从而得到两点之间的代价函数C(A,B).
二、送餐的最优路径 接下来，就是一个TSP的问题了，也就是求解如何走完所有取餐、送餐点，并使得总代价时间最小。在这里，我们不妨使用遗传算法，
2.1 遗传算法简介 遗传算法（Genetic Algorithm，GA）是由美国的John Holland教授于20世纪70年代首次提出的，它是一种自适应随机搜索启发式算法。遗传算法以自然选择规律与遗传理论为依托，模拟生物进化过程中的遗传、交叉、变异等过程，通过数学的方式利用计算机仿真运算，将问题的求解过程转换成类似生物进化中的染色体基因的交叉、变异等过程。
遗传算法在求解较为复杂的组合优化问题时，相对一些常规的优化算法，通常能够较快地获得较好的优化结果。它被广泛应用于复杂函数系统优化、机器学习、系统识别、故障诊断、分类系统、控制器设计、神经网络设计、自适应滤波器设计等领域。
详细可参考《老饼讲解|【原理】遗传算法-入门讲解》
2.2 遗传算法的算法流程 遗传算法的算法流程如下
2.3 遗传算法应用于路径规划 用遗传算法，需要设计好该问题的以下三点：
👉1. 染色体交换方式：解与解之间如何进行部分交换
👉2. 基因变异的方式：单个解如何作出随机改变 👉3. 适应度的定义 ：用于评估解的优秀程度 对本问题我们可以设计如下： (1)遗传算法染色体交换方式
将解群两两随机配对，每一对之间(设为a,b)以如下方式交换：
设a=[0,1,5,3,2,4]，b=[1,2,5,0,3,4],先随机抽出a的一个片段a_piece，
假设a_piece= [5,3,2],再在b中找出 a_piece 的排序 b_piece=[2,5,3],
将b_piece替换到a,将a_piece替换到b,得到：a=[0,1,2,5,3,4],b=[1,5,3,0,2,4]
(2)遗传算法基因变异方式
设a=[0,1,5,3,2,4], 先随机抽出a的一个片段a_piece，假设a_piece= [5,3,2],
将a_piece翻转( [2,3,5])后再回代a，得到a=[0，1，2，3，5，4]
(3)遗传算法适应度设计:
本问题的目标函数一定是大于0的，我们简单的设为 ﻿ 即可（F是目标函数的值），就可以达到函数值越小，适应度越大的效果。
设计完以上三点后，只需按遗传算法的算法流程，实现代码即可
三、送餐的最优路径-代码实现 3.1代码说明 下面，我们使用代码实现上述算法。但为了便于实现，作出如下两点假设与简化：
1.由于我们还没有得到任意两点A、B之间的代价函数C(A,B)的具体表达式，而为了能够实现代码，我们不妨先用距离函数D(A,B)替代代价函数C(A,B)，
2.对于地点之间的路线和交通是复杂的，需要依赖了第三方服务的支持，这里我们简单为两点的直线距离就好，
3.2 遗传算法规划路径-代码实现 代码实现如下：
%------代码说明：展示遗传算法求解TSP问题 ----------------- % 来自《老饼讲解神经网络》www.bbbdata.com ,matlab版本：2018a function gaforTSP() clc;clear all;close all ; rng(999) global distMat; cityLoc = [3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b339ec4d6946b8d42a681aa9baa2d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0583ebb160cfde23998db8b3ba2350f3/" rel="bookmark">
			挖漏洞之文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）漏洞原理 文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。
“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。
（二）基础测试方法 一般来讲，开发者一般都会对文件上传部分，进行检测和过滤，用于检测文件类型的方法有很多种，按照下面方法，一步一步测试
1、总的测试思路 第一步查看前端js，如果是在前端js实现文件上传，可以删掉绑定方法，直接上传文件第二步查看是否是黑白名单检测：黑名单是禁止上传文件，白名单是只允许上传文件 如果是白名单：寻找可控参数
如果是黑名单，可以尝试找非黑名单以外的有害文件，可以是大小写不同的可执行文件，比如PhP，也可以是系统配置文件，比如.htaccess文件
2、基于白名单的测试 1、针对后缀名测试，可能在逻辑上发生错误，从而引发文件上传漏洞，比如
加双后缀：变成file.php.jpg 或 file.jpg.php，绕过检测
后缀名加空格：变成file.php ,系统无法正确识别实际扩展名“.php”，从而绕过白名单检测
后缀名加点：变成file.php. 这个方法真针对window系统，win系统中对文件名后缀有点的，会省略掉，.php.就变成.php
后缀名加入%00，进行截断比如file.php,变成file.php%00,（这个方法跟版本有关，老版本可能有）
2、上传图片码，比如只允许图片上传的，把图片和木马集合在一起
3、修改检测值
文件头，比如JPEG (jpg)的文件头： FFD8FF，在图片制作的时候，修改文件
contnet-type值，修改MIME类型为符合上传格式类型，比如png是image/png
4、数组新式上传，如果系统采用数组方式上传，就自己加上一个值，进行上传
3、基于黑名单的测试 如果是黑名单检测文件上传，可以采用以下测试方法：
1、也是对文件后缀名进行测试，在逻辑上文件上传漏洞：
更改后缀大小写：比如php变成Php，有可能没有禁止Php
修改后缀名：比如php，换成php3，这是有可能php3没有被禁止
后缀名后加入::$DATA，比如file.php变成file.php::$DATA,这是NTFS交换数据流绕过，# 其中一个冒号表示创建文件，两个冒号表示写入文件内容
双写文件后缀名，比如.php 变成.pphphp,如果存在检测php文件后替换成空，可以采用这个方法
2、 修改contnet-type值，修改MIME类型为符合上传格式类型，比如png是image/png
3，上传系统文件，有时候开发者忽略网站配置文件，
php网站.htaccess，让其上传图片也可以当作文件执行
..user.ini文件,让包含一个文件
（三）进阶测试方法 有写开发者只关注禁止上传脚本文件这一点，只运行上传符合业务需求的文件，从而针对性的开发，这虽然提升了黑客上传脚本文件，直接getshell，但是忽略其他漏洞，其实由于文件上传这一个功能点，可以导致其他漏洞，如下
1）webshell，上传脚本文件可以webshell
2）xss：
文件名插入payload造成xss、
上传html文件造成xss文件（html文件里注入payload）
上传svg文件（一种图像类型），在属性中插入payload造成xss漏洞
上传gif文件（一种图片），在图片头注入payload造成xss漏洞
上传pdf文件，在文件中属性-添加编辑动作内容插入payload，造成xss
上传word文档，在xml文件部分中，选择任意文件的文件名中插入大量A，在 hexeditor中找到大量存在41（A的十六进制），把payload转为十六进制插入，上传word文档造成xss
3）xxe（docx、xlsx、svg等本质是xml文件）
上传直接上传xml文件，造成xxe
上传xlsx文件，在xlsx中找到下xml文件处插入payload，造成xxe
上传docx文件，在xml文件处插入paylaod，造成xxe
上传svg文件，造成xxe
4）命令注入
上传csv文件，在csv插入payload，在导出csv文件中，打开执行命令导致命令执行
上传图片，对图片进行二次渲染，插入命令，导致rce
5）目录遍历
上传压缩包，服务器对其加压，可能存在Zip Slip目录走访漏洞
6）ssrf
上传 .URL 文件，打开可能会Windows 上的 SSRF SMB连接，导致ssrf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0583ebb160cfde23998db8b3ba2350f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceefeac8ffea7ef0bf26031bb8bb488c/" rel="bookmark">
			阿里云服务器跨域问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一下原始代码：
@Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("http://47.99.63.22/vue"); corsConfiguration.addAllowedOrigin("http://47.99.63.22/lab"); corsConfiguration.addAllowedOrigin("http://47.99.63.22:8096/schedule/all"); corsConfiguration.addAllowedOrigin("http://47.99.63.22:8096/*"); corsConfiguration.addAllowedOrigin("http://localhost:5173"); corsConfiguration.addAllowedOrigin("http://localhost:5174"); corsConfiguration.setAllowCredentials(true); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); corsConfiguration.setMaxAge(MAX_AGE); source.registerCorsConfiguration("/**", corsConfiguration); UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource(); corsConfigurationSource.registerCorsConfiguration("/**",corsConfiguration); return new CorsFilter(source); } 可能存在以下问题：
1、不正确的allowedOrigins配置
addAllowedOrigin方法应该只包含协议、域名和端口。您不能在这里指定路径（如`/lab`或`/schedule/all`）。正确的做法是只指定到端口号，例如 `http://47.99.63.22:8096`。如果您的前端服务器运行在不同的端口上，则只需指定协议和域名（没有路径或通配符）：
2、精确的源而不是通配符
在配置CORS时，如果`setAllowCredentials`被设置为`true`（意味着你希望支持凭证），则不能使用通配符`*`来设置`allowedOrigins`。凭证包括cookies以及HTTP认证的相关信息。通配符与允许凭证的请求不兼容。 3、注册的顺序和实例化
您似乎创建了两个UrlBasedCorsConfigurationSource实例，但只有`source`被用于创建`CorsFilter`。请确保您使用了正确的实例化对象。在这段代码中，`corsConfigurationSource` 实例是没必要的。 修正上述问题后的示例代码可能如下所示：
@Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("http://47.99.63.22"); // 注意这里去掉了路径和通配符 corsConfiguration.addAllowedOrigin("http://localhost:5173"); corsConfiguration.addAllowedOrigin("http://localhost:5174"); corsConfiguration.setAllowCredentials(true); corsConfiguration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceefeac8ffea7ef0bf26031bb8bb488c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d2d686972777f66e48ce5fb6551d2d5/" rel="bookmark">
			软件的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先码后看
nightly : 每日构建版本（同daily build），大型软件构建时间长，白天没时间，就晚上构建啦
devel：供开发用的版本。不带devel后缀的package，通常只包含能让程序运行的动态库和配置文件。而带devel后缀的package，则包含使用这个package开发程序的所有的必需文件。比如头文件，等等。有时devel package还包含静态库。
"devel"包是什么？ | 我的站点
软件版本 —— Alpha、Beta、RC版本的区别_beta版本是什么意思-CSDN博客
nightly、aurora、beta、stable、RC-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c29892d25c70ed76b54a703dafab16/" rel="bookmark">
			“机器视觉探索之旅“——Halcon与VisionMaster对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个经验丰富的机器视觉算法工程师，我对于机器视觉软件的评价会基于多年的实践经验和对不同软件功能的深入了解。在评价VisionMaster和Halcon软件时，我会从使用场景、工作效率、使用便捷性等方面进行全面分析，并结合软件的优缺点进行讨论。
首先，让我们从使用场景方面来看。Halcon是由德国MVTec公司开发的一款领先的机器视觉软件，它广泛应用于工业检测、表面缺陷分析、物体识别、3D视觉和复杂视觉任务处理等领域。Halcon拥有强大的图像处理和分析功能，支持多种相机和图像采集设备，适用于高端的机器视觉系统开发。而VisionMaster则是一款相对较新的机器视觉软件，它的使用场景通常集中在简单或中等复杂度的视觉任务，如简单的尺寸测量、缺陷检测、条码和2D码识别等。VisionMaster通常被认为更适合中小型企业或者那些对算法复杂度要求不高的应用。
接下来，从工作效率的角度来看。Halcon以其高效的算法库而闻名，这些算法库经过多年优化，能够提供高速的图像处理能力。Halcon的算法性能在行业内被公认为是非常高效的，这使得它在处理复杂视觉任务时具有明显的优势。此外，Halcon支持多核处理和GPU加速，进一步提升了处理速度。相比之下，VisionMaster可能在算法优化和处理速度方面略逊一筹，尽管它也提供了基本的多线程处理能力，但在高负载或大规模数据处理方面可能不如Halcon强大。
在使用便捷性方面，VisionMaster通常被认为更加用户友好。它提供了直观的图形用户界面（GUI），使得用户可以通过拖放等简单操作来设计视觉流程，这对于不具备深厚编程背景的用户来说非常方便。而Halcon虽然提供了HDevelop这样的开发环境，但它更偏向于代码编写，需要用户具备一定的编程能力和算法知识。对于初学者来说，Halcon的学习曲线可能会更陡峭。
现在，我们来讨论两者的优缺点。 Halcon Halcon的优点：
1. 强大的算法库：拥有广泛的图像处理和分析算法，能够处理复杂的视觉任务。
2. 高效的性能：支持多核处理和GPU加速，能够快速处理大量图像数据。
3. 广泛的兼容性：支持多种相机和图像采集设备，适用于多种工业应用场景。
4. 灵活性：提供丰富的API，可以轻松集成到其他软件或系统中。
Halcon的缺点：
1. 学习曲线陡峭：需要用户具备编程能力和算法知识。
2. 成本较高：作为高端的机器视觉软件，Halcon的授权费用相对较高。
VisionMaster VisionMaster的优点：
1. 用户友好：直观的GUI设计，适合初学者和非编程专业人士。
2. 成本效益：对于中小企业来说，VisionMaster可能是一个更经济的选择。
3. 快速部署：简单的视觉任务可以通过快速配置实现，缩短开发周期。
VisionMaster的缺点：
1. 算法性能有限：可能不适合处理非常复杂的视觉任务。
2. 扩展性受限：在集成和自定义方面可能不如Halcon灵活。
总结来说，Halcon和VisionMaster各有千秋。Halcon以其强大的算法性能和灵活性，适合需要处理复杂视觉任务的高端应用。而VisionMaster则以其用户友好和成本效益，更适合初学者和中小企业的基本视觉需求。在选择适合的机器视觉软件时，需要根据具体的应用需求、预算限制以及用户的技术背景来进行权衡选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d5949b13361982a58af5a78703f236/" rel="bookmark">
			STM32CubeMX PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PWM简介
脉宽调制 (PWM) 是一种从数字输出输出模拟值的技术。普通的 GPIO 输出只能输出高电平或低电平。因此，只能通过使用时间来生成模拟值。使用 PWM，引脚交替打开和关闭，以便平均输出电压介于高电压和低电压之间。
占空比和 PWM 频率对我们来说是最重要的参数。接通时间占该周期时间的比例称为占空比。例如，20% 的占空比意味着信号在 20% 的时间内开启，在 80% 的时间内关闭。 PWM 频率指定信号的时间周期。
频率 =定时器时钟 / (psc+1) / (arr+1) (单位：Hz)
arr 是计数器值
psc 是预分频值
占空比：
duty circle = TIM3-&gt;CCR1 / arr(单位：%)
TIM3-&gt;CCR1 用户设定值
TIM3-&gt;CCR1 = dutyCycle
和__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, dutyCycle);作用相同
HAL_TIM_PWM_Start//PWM启动函数 HAL_TIM_PWM_Stop//PWM停止函数 _HAL_TIM_SET_COMPARE//占空比 _HAL_TIM_SET_AUTORELOAD//周期 二、CubeMX配置
打开仿真调试
时钟源 选择频率
使能板载LED PC13引脚
定时器配置
生成工程
在代码中只需要在main函数调用
main.c
/* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_2); /* USER CODE END 2 */ 添加小灯观察板子是否工作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d5949b13361982a58af5a78703f236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89be022d9123321ad5cf3351bb2841fd/" rel="bookmark">
			vscode调试pytorch分布式训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		launch.json文件如下"cwd"= "${fileDirname}"表示代码调试的根目录是当前你调试的文件，也就是pretrain.py所在的目录。其他路径参数都是相对这个目录的
如果改成"cwd"= "${workspaceFolder}" 表示代码调试的根目录是打开的工作目录，也就是你vscode打开的工程文件夹的目录
"program"参数是是我们要运行的文件，默认是"program": "${file}",也就是你要调试的文件本身，
比如不调试分布式的话，就是pretrain.py，分布式的话要改成"program": "/root/miniconda3/lib/python3.10/site-packages/torch/distributed/run.py"表示我们其实是要运行这个文件，然后加入args参数，把pretrain.py作为一个参数
注意：pytorch1.9之后torch.distributed.launch 即将被废弃，取而代之的是torch.distributed.run
https://www.cnblogs.com/tencent-cloud-native/p/15186403.html
而torchrun脚本就是torch.distributed.run的内容,所以在终端运行的话
python -m torch.distributed.run --nproc_per_node=8 pretrain.py --config ./configs/Pretrain.yaml --output_dir output/Pretrain 和
torchrun --nproc_per_node=8 pretrain.py --config ./configs/Pretrain.yaml --output_dir output/Pretrain 二者是等价的，终端直接输入torchrun
root@autodl-container-115911b7ae-3dcde09d:~# torchrun usage: torchrun [-h] [--nnodes NNODES] [--nproc_per_node NPROC_PER_NODE] [--rdzv_backend RDZV_BACKEND] [--rdzv_endpoint RDZV_ENDPOINT] [--rdzv_id RDZV_ID] [--rdzv_conf RDZV_CONF] [--standalone] [--max_restarts MAX_RESTARTS] [--monitor_interval MONITOR_INTERVAL] [--start_method {spawn,fork,forkserver}] [--role ROLE] [-m] [--no_python] [--run_path] [--log_dir LOG_DIR] [-r REDIRECTS] [-t TEE] [--node_rank NODE_RANK] [--master_addr MASTER_ADDR] [--master_port MASTER_PORT] training_script .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89be022d9123321ad5cf3351bb2841fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fbe7d36ea6e4f6e28ba165f024ccad/" rel="bookmark">
			短视频ai剪辑分发矩阵系统源码3年技术团队开发搭建打磨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您需要搭建这样的系统，建议您寻求专业的技术支持，以确保系统的稳定性和安全性。
在搭建短视频AI剪辑分发矩阵系统时，您需要考虑以下几个方面：
1. 技术实现：您需要选择适合您的需求和预算的技术栈，例如使用人工智能和机器学习算法来处理视频剪辑，以及选择合适的数据库和服务器来存储和分发视频。
2. 安全性：您需要考虑系统的安全性和隐私保护，以确保用户数据的安全和隐私。
3. 用户体验：您需要考虑系统的易用性和用户体验，以确保用户能够轻松地使用您的系统并获得良好的体验。
4. 运营管理：您需要考虑如何管理和运营您的系统，以确保系统的稳定性和可靠性。
在寻找技术团队时，您需要考虑以下几个因素：
1. 技术实力：技术团队需要有丰富的相关经验和技术实力，能够根据您的需求开发出高质量的系统。
2. 稳定性：技术团队需要能够提供稳定可靠的系统，以确保您的业务不受影响。
3. 售后服务：技术团队需要能够提供优质的售后服务，以确保您在使用过程中遇到问题时能够得到及时解决。
总之，搭建一个短视频AI剪辑分发矩阵系统需要综合考虑技术、安全、用户体验和运营管理等多个方面，建议您寻求专业的技术支持和帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8198ce02e4b2f7610a790f6cec022d7/" rel="bookmark">
			C语言代码：用 C 语言实现一个循环队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
本文将介绍如何使用C语言实现一个循环队列，包括队列的定义、入队、出队、判空和判满等操作。代码实现将遵循专业编程规范，并使用注释进行详细解释。
一、引言
队列是一种常见的数据结构，它遵循先进先出（FIFO）的原则。在实际应用中，队列经常被用于实现各种功能，如缓冲、任务调度等。而循环队列则是一种特殊的队列，它可以通过循环使用数组空间来避免队列中元素的浪费。在本文中，我们将使用C语言来实现一个循环队列，并通过代码和注释进行详细讲解。
二、循环队列的定义
循环队列通常使用一个固定大小的数组和两个指针来实现。其中一个指针指向队头元素，另一个指针指向队尾元素的下一个位置。当队列为空时，两个指针指向同一个位置；当队列为满时，队尾指针指向队头指针的前一个位置。为了实现循环效果，我们需要对数组下标进行取模运算。
在C语言中，我们可以定义一个结构体来表示循环队列，如下所示：
#define MAXSIZE 10 // 定义队列的最大容量 typedef struct { int data[MAXSIZE]; // 存储数据的数组 int front; // 队头指针 int rear; // 队尾指针 } CircularQueue; 三、循环队列的操作
初始化队列
在使用循环队列之前，我们需要对其进行初始化。初始化的过程就是将队头和队尾指针设置为同一个位置。代码如下：
void InitQueue(CircularQueue *Q) { Q-&gt;front = Q-&gt;rear = 0; // 初始化队头和队尾指针 } 判断队列是否为空
判断队列是否为空的方法很简单，只需要检查队头和队尾指针是否相等即可。代码如下：
int IsEmpty(CircularQueue *Q) { return Q-&gt;front == Q-&gt;rear; // 如果队头和队尾指针相等，则队列为空 ｝ 判断队列是否已满
判断队列是否已满的方法也很简单，只需要检查队尾指针是否指向队头指针的前一个位置即可。代码如下：
int IsFull(CircularQueue *Q) { return (Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front; // 如果队尾指针的下一个位置是队头指针，则队列已满 } 入队操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8198ce02e4b2f7610a790f6cec022d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8134727908c646212818d7954550268f/" rel="bookmark">
			GitExtension下载、安装和git分支拉取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能够帮助你们解决问题是博主的荣幸，你们的支持是我创作的最大动力！:)欢迎关注点赞
文章目录 一、GitExtension下载二、GitExtension安装三、GitExtension配置四、GitExtension使用总结 一、GitExtension下载 提示：安装之前需要先确认好自己需要哪个版本的GitExtension，避免浪费时间。
官网下载：
http://gitextensions.github.io/
百度云盘下载：
链接：https://pan.baidu.com/s/1iUVIJw32oxCZ0vQygwekiQ
提取码：hgex
GitExtension官网下载教程
1.选择Download。
2.选择.msi文件下载。
百度云下载
官网下载时间长，建议直接百度云，下载能用就行。
二、GitExtension安装 1.老规矩，还是放好下载的文件，然后双击打开安装包。
2.点击Next
3.点击Next。
4.建议安装到同一目录，然后点击Next。
5.点击Next。
6.点击Next。
7.点击Install，等待安装，直到完成点击Finish。
三、GitExtension配置 1.安装好之后，双击桌面图标，选择使用语言，这里选中文。
2.选好语言后，进来就是这个界面，解决下面报红就能正常使用。
第1项 ：报红表示电脑中必须安装好git，因为git extensions只是一个扩展工具，主要操作还是借助git来完成的，具体可看博主另一篇博客安装Git教程。https://blog.csdn.net/King_Treasure/article/details/134887098
第2项：配置用户名和邮箱，填写好用户名和邮箱后，点击应用和确认就可以了。
第3，4项：配置比较工具，博主用Beyond Compare工具的，后续出教程可关注。Mergetool和Difftool中选bc或者bc3，然后Browse选择本地安装的比较工具路径，最后应用和确认就可以了。
第9项：语言设置，没啥问题直接点Repair后选中文就可以了。
3.解决报红后全绿，选择应用和确定，后续会弹出界面，接着就是简单的使用教程。
四、GitExtension使用 1.在码云或者github随便找项目克隆，HTTPS-&gt;复制链接。
2.建立一个项目工作空间，点击克隆版本库。
3.GitExtension中粘贴项目链接，然后选择好工作目录后点击克隆，等待拉取项目。
3.选择是。
4.出现这个界面，git拉取代码就完成，后续在此工具中操作git分支。
如果想要学习Idea或者Eclipse开发工具的项目导入和开发，可关注博主后续出文章。
总结 以上就是今天要分享的内容，如果有什么不懂的地方或者有什么出错的地方，欢迎前来探讨，谢谢大家~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bcfe06bbaa760c698aeb12ae3745b07/" rel="bookmark">
			Git下载、安装和验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		能够帮助你们解决问题是博主的荣幸，你们的支持是我创作的最大动力！:)欢迎关注点赞
文章目录 一、Git下载二、Gir安装三、Git安装完成验证总结 一、Git下载 官网下载：
https://git-scm.com/download
百度云盘下载：
链接：https://pan.baidu.com/s/1SLm7qFMSQUNfq0ailcVjSw
提取码：eshv
传送门获取：
https://registry.npmmirror.com/binary.html?path=git-for-windows/
官网下载教程
1.打开官网，选择对应系统点进去。
2.选择普通安装或者命令安装。
百度云下载
如果官网下载麻烦，建议可以直接用云盘下载。
二、Gir安装 接下来是Git安装
1.建议将Git放好，然后双击打开安装。
2.点击Next。
3.选择安装目录，然后点击Next。
4.勾上NEW!那个，点击Next。
5.默认选项，点击Next。
6.默认选项，选择Next。
7.默认选项，选择Next。
8.默认选项，选择Next。
9.默认选项，选择Next。
10.默认选项，选择Next。
11.默认选项，选择Next。
12.默认选项，选择Next。
13.默认选项，选择Next。
14.默认选项，选择Next。
15.默认选项，选择Next。
16.不需要勾选，选择Install安装，等待安装，直到安装完成选择Finish。
三、Git安装完成验证 1.Ctrl+R打开，输入cmd，点击确定。
2.输入git --version，回车，出现版本就是安装成功。
总结 以上就是今天要分享的内容，如果有什么不懂的地方或者有什么出错的地方，欢迎前来探讨，谢谢大家~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9325c59510f58e1a83c7696f999197d9/" rel="bookmark">
			部分地区信息学中小学组试卷目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分地区信息学中小学组试卷目录
2023年合肥市青少年信息学科普日活动（小学组）
T1. 存钱（saving）
T2. 逆波兰式计算（rpn）
T3. 自动驾驶（autopilot）
T4. K阶恒星系（kgalaxy）
2023年合肥瑶海区信息学竞赛（小学组）
T1. 排座位（seat）
T2. 计算小擂台（arena）
T3. 成绩排名（rank）
T4. 长跑训练（train）
T5. 积木问题（blocks）
2023年合肥瑶海区信息学竞赛（初中组）
T1. 幸运数字
T2. 活动积分（points）
T3. 乘积（product）
T4. 象棋比赛（chess）
2023年合肥蜀山区信息学竞赛（小学组）
T1. 连续字符
T2. 寻找座位
T3. 限速路段
T4. 观展排队
2023年合肥市瑶海区某校校赛真题（小学组）
T1. 加法运算（add）
T2. 冰糖葫芦（sugar）
T3. 最大奇数和（sum）
T4. 最长连续重复字符（longest）
T5. 寻找宝石（gemstone）
2022年合肥市庐阳区信息学区赛（初中组）
T1. 信封
T2. 三角瓷砖
T3. 特别的电梯
T4. 忐忑楼梯
T5. 集散系统
2022年合肥市蜀山区信息学区赛（小学组）
T1. 互补消除
T2. 图像处理
T3. 通讯协议
T4. 换位整除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9325c59510f58e1a83c7696f999197d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3aca49ee513866cee1aa5fbbb20ac3e/" rel="bookmark">
			Chrome、Firefox、Edge浏览器最新稳定版离线安装包下载指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 toB用户内网设备浏览器版本太低想要升级内网设备浏览器版本，尤其是chrome只能下载浏览器快捷安装程序，还是需要联网安装。其实不管是谷歌、火狐还是微软都有官方的离线安装包的下载渠道，只是谷歌浏览器离线安装包的下载页面并没有面向用户开放出来，火狐还有微软做的不错倒是把浏览器的离线安装包的下载的页面开放出来了。
提效策略 如何快速将最新版浏览器下载下来，避免浏览过多的页面和执行繁琐的操作步骤？为了快速下载Chrome、Firefox、Edge浏览器最新版离线安装包，我将下载链接汇总了一下，官方下载链接无须翻墙，可以放心安装使用！
Chrome（谷歌浏览器） 复制下载链接到浏览器可直接下载对应最新版浏览器。
win10/11 64位
https://dl.google.com/tag/s/installdataindex/update2/installers/ChromeStandaloneSetup64.exe win10 32位
win11 系统没有32位。
https://dl.google.com/tag/s/installdataindex/update2/installers/ChromeStandaloneSetup.exe Firefix（火狐浏览器） 复制下载链接到浏览器可直接下载对应最新版浏览器。
win10/11 64位
https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN win10 32位
https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win&amp;lang=zh-CN macos
https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=osx&amp;lang=zh-CN Edge（微软浏览器） 复制下载链接到浏览器可直接下载对应最新版浏览器。
win10/11 64位
https://go.microsoft.com/fwlink/?LinkID=2093437 win10 32位
https://go.microsoft.com/fwlink/?LinkID=2093505 总结 截止至 2023-12-03 以上所有链接都是可用的，如果有哪个链接不可用了，或者有其他更好的浏览器离线安装包下载方式了，欢迎各位网友在评论区中发言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79612545a599d3aa4da1b62bba8c471/" rel="bookmark">
			C&#43;&#43; ：输出 Hello, World
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出：Hello, World! 是C++ 和很多编程语言的最简单、基本的程序。
现在，我们来写一下这个程序。
此程序需要用到输入输出的头文件：
#include &lt;iostream&gt; 还有下面语句：
using namespace std; 最重要的是下面的输出语句：
cout 此语句是 C++ 中最基本的输出语句，此语句后面要加上 &lt;&lt; 输出流语句就可以输出，下面展示了 cout 的使用样例：
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt;1; // cout 语句可以直接输出数字 return 0; } 此代码可以输出一个数字 1 ，可是我们要输出的东西不是数字，怎么办？
很简单，用双引号将我们要输出的东西引起来就行了，使用样例：
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt;"!@#%&amp;@#@^%sadfD3w@#%D3DFDsgtyUJbF54$%"; return 0; } 此代码可以输出一段乱七八糟的东西。
目前为止，cout 的用法已经讲完了（其实还有很多，只是这里用不到了）
于是，初级代码如下：
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt;"Hello,World!"; return 0; } 好了初级代码讲完了，接下来是高级代码（其实也不怎么高级），要想了解高级代码的语句的意思，请务必懂得自定义函数、递归、队列、结构体、字符串、ASCLL码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79612545a599d3aa4da1b62bba8c471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076cf22ec46559b934a52d65ec44734a/" rel="bookmark">
			【Windows通过VCPKG配置Ceres环境】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Ceres是Google推出一款非线性最小二乘优化库。在Windows下配置Ceres环境主要有两种方法：一种是自行下载代码编译，由于Ceres依赖库较多，配置起来较为麻烦；另一种是通过微软的包管理软件VCPKG配置Ceres环境，比较简单，适合新手小白。本文分享Windows系统下通过VCPKG配置Ceres环境的步骤，内容主要参考了以下三篇博客。
vcpkg 安装ceres库总崩溃的解决办法
在windows系统中使用Ceres非线性优化库：（一）安装Ceres库
win11+vs2022配置ceres库
VCPKG下载生成Ceres库 首先，下载安装vcpkg，可以参考官网的教程Get started with vcpkg。这里把vcpkg放置在了D:\Program Files\vcpkg路径下。安装vcpkg后，在vcpkg路径下运行命令行.\vcpkg search ceres，如下图所示，会找到ceres及开启一些优化选项所依赖的库。使用.\vcpkg install ceres[cuda,cxsparse,eigensparse,lapack,suitesparse,tools]:x64-windows --recurse命令安装Ceres（方括号中的库名根据需要填写），会自动下载Ceres依赖库。生成完成后，在D:\Program Files\vcpkg\installed\x64-windows路径可以看到bin、include、lib、share文件。 VS项目中配置Ceres环境 本节介绍两种在VS项目中配置Ceres环境的方法。一种是使用vcpkg，另一种是使用cmake。使用vcpkg会出现报错，需要手动更改VS项目配置解决，会写cmakelists的话使用cmake更加方便。
使用VCPKG 运行.\vcpkg integrate install命令可以自动在VS中所有项目集成Ceres环境，无需再进行项目配置。若要删除集成，可以使用 .\vcpkg integrate remove。在VS中新建空项目，下载Ceres源码，在example中拷贝一个例程，比如helloworld.cc，添加到项目中，点击运行。过程可能出现报错，我运行中出现三种错误，按照第三个博客中的方法解决了。注意在Debug和Release模式下都要进行配置。
a. 首先是GLOG_NO_ABBREVIATED_SEVERITIES报错。解决方法是在项目-&gt;属性-&gt;C/C+±&gt;预处理器中的预处理器定义增GLOG_NO_ABBREVIATED_SEVERITIES 。
b. 其次是jet.h和local_parameterization.h报错，解决方法是将项目-&gt;属性-&gt;C/C+±&gt;常规中的SDL检查改为否。 c. 最后是std::max报错，解决方法是将项目-&gt;属性-&gt;C/C+±&gt;预处理器中的预处理器定义增加NOMINMAX。最后运行程序，成功输出。
使用CMAKE 下载Ceres源码，在example中拷贝一个例程，比如helloworld.cc，放入某一新建文件夹如cereshelloworld。在cereshelloworld文件夹新建cmakelists.txt文件，按照cmake基本写法配置ceres环境。唯一不同的是，需要在cmake工具链中中添加vcpkg.cmake路径，增加如下语句：set(CMAKE_TOOLCHAIN_FILE "D:/Program Files/vcpkg/scripts/buildsystems/vcpkg.cmake") cmake_minimum_required(VERSION 3.2) # 使用VCPKG生成的库(修改成自己电脑中的vcpkg路径) set(CMAKE_TOOLCHAIN_FILE "D:/Program Files/vcpkg/scripts/buildsystems/vcpkg.cmake") # 项目名 project(ceres_helloworld) # 添加可执行文件 add_executable(${PROJECT_NAME} helloworld.cc) # 查找并包含、链接Ceres find_package(Ceres CONFIG REQUIRED) include_directories(${CERES_INCLUDE_DIRS}) link_directories(${CERES_LIBRARY_DIRS}) target_link_libraries(${PROJECT_NAME} PRIVATE ${CERES_LIBRARIES}) 打开cmake-gui，设置代码路径为cereshelloworld，设置build路径为cereshelloworld\build，依次点击配置、生成、打开工程。
在打开的VS工程中右键点击ceres_helloworld工程，设置为启动项目，点击开始执行，可成功运行程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448a91290a21d182f76d33b569898fcd/" rel="bookmark">
			Linux基础——进程初识（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 硬件 ①冯诺依曼体系 我们常见的计算机，如笔记本。我们不常见的计算机，如服务器，大部分都遵守冯诺依曼体系。其详细结构如下图所示
在这里有几点要说明
1. 这里的储存器实际上指的是内存
2. 输入设备与输出设备都属于外设
常见的输入设备如：鼠标，键盘，摄像头，话筒，磁盘，网卡等
常见的输出设备如：显示器，播放器硬件，磁盘，网卡
3. 运算器与控制器都属于中央控制器（即CPU）
运算器的功能是对我们的数据进行计算任务(算数运算，逻辑运算)
控制器的功能是对我们的计算硬件流程进行一定的控制
值得注意的是
1. 在不考虑缓存情况时，这里的CPU能且只能对内存进行读写，不能访问外设(输入或输出设备)
2. 在冯诺依曼体系中每一个部件都是一个独立个体
3. 外设(输入或输出设备)要输入或者输出数据，也只能写入内存或者从内存中读取
根据上面的情况，我们可以总结出一个结论：所有设备都只能直接和内存打交道 在了解了冯诺依曼体系后，我们也可以解释一些之前无法解释的问题，如：
为什么一个程序要运行，必须要先加载到内存中？
答：因为冯诺依曼体系结构规定了必须这样做。
在实现进度条小程序时，我们知道默认缓存的数据被储存了起来，那么这些数据存储在哪？
答：储存器中。
②实际举例 在这里我们举一个实际例子
我们在使用QQ向朋友发送消息时，数据是如何流动的？
如果发送的是文件时，那么自己的输入设备和朋友的输出设备都应该是磁盘，朋友在收到文件后，采取的措施是将文件保存到本地磁盘中。 2. 软件 ①什么是操作系统 任何计算机系统都包含一个基本的程序集合，称为操作系统(OS）(operating system)
内核（进程管理，内存管理，文件管理，驱动管理）
其他程序（例如函数库，shell程序等等）
简单来说，操作系统是一个对软硬件资源进行管理的软件。
计算机中有如上图所示的层状结构，在其中我们可以看到操作系统通过直接管理驱动程序来实现间接管理底层的硬件，在管理好软硬件资源之后，操作系统为了保证自己数据安全，也为了保证给用户能够提供服务，操作系统以接口的方式给用户提供调用的入口来获取操作系统内部的数据，这就是系统调用，它是操作系统提供的用C语言实现的，自己内部的函数调用。所有访问操作系统的行为，都只能通过系统调用来完成。那么操作系统存在的意义是什么呢？为什么我们需要操作系统呢？根据上面对层状结构的解释，我们可以有以下理解
1．操作系统帮助用户，管理好下面的软硬件资源
2．为了给用户提供一个良好(稳定，高效，安全)的运行环境
即：操作系统通过管理好底层的软硬件资源(手段),为用户提供一个良好的执行环境（目的) 在C语言中我们经常会调用系统库，那么这个系统库与系统调用又有何关系和
②操作系统如何进行管理 那么在知道了操作系统是什么之后，它是如何对软硬件进行管理的呢？
首先我们要知道一般管理资源都分为决策者，执行者与被管理者，举几个例子，在大学中，校长就相当于决策者，辅导员是执行者，各个学生就是被管理者，在公司中，老板就相当于决策者，小组长是执行者，员工就是被管理者。在这些例子中，我们可以发现，管理者和被管理者是不需要见面的，既然如此，那么管理者在不见被管理者的情况下，如何做好的管理呢？——其实，只要能够得到管理信息，就可以进行管理决策，由此我们也可以看到管理的本质——通过对数据的管理，达到对人的管理。既然管理者和被管理者面都不见，那怎么拿到对应的数据呢？——通过执行者。
管理者在决定好要收集到被管理者的什么数据之后，如：校长需要收集到学生的学院、专业、班级、学号、姓名、性别、身高、体重、籍贯、电话等数据，通知辅导员收集数据之后，再将其反馈到校长处，校长为了能够更好的管理数据决定描述每一个学生的具体情况，将每个学生视作一个结构体的具体对象，对学生的描述可以如下图所示
在描述好之后，为了将它们互相联系起来，可以向Student结构体中添加struct Student* next来衔接下一个学生，这之后每有一个学生便实例化一个对象，并使它们链接起来，这样就将对学生数据的管理转换成了对链表的管理，这种方式就是操作系统管理资源的方式，即：在操作系统中，管理任何对象，最终都可以转化成为对某种数据结构的增删查改，这种管理资源的方式我们将其称为“先描述，后组织”，即对于任何一个要管理的资源，都要先对其进行描写（有什么属性），这之后再使用一种数据结构来管理它们
3. 进程 ①什么是进程 对于一个已经加载到内存中的程序，叫做进程，通俗一点来说，正在进行的程序，我们将其称之为进程。
②进程的理解 因为操作系统是需要同时运行多个进程的，那么操作系统要如何管理进程呢？这在之前我们就提到过——先描述，后组织。对于任意一个进程，在磁盘将其加载到内存时，都是加载的代码与数据进去，而操作系统想要管理它，就要先对一个进程作出相应的描述，为了描述这样一个进程，操作系统有自己的描述进程的结构体对象，即——PCB（process control block），它是一个进程属性的集合体，在这个结构体中包含了许多的进程属性，然后操作系统会根据自己的PCB类型，为传输进来的代码和数据创建相应的PCB对象。
操作系统为了管理这些进程，会将它们转换为单链表方便管理。那么，我们就可以认为进程=操作系统对应的PCB+相应的代码与数据。
③Linux中的进程 在了解了PCB后，Linux中的进程又是什么样的呢？在LInux中，操作系统所使用的PCB为task_struct，其包含进程的所有属性，且LInux是使用双链表的形式来管理进程的。下面就让我们来创建一个进程，其代码如下
int main() { while (1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448a91290a21d182f76d33b569898fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42450cd43d17be699f1f224fbd13c1e4/" rel="bookmark">
			react-photo-view 的介绍、安装、使用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本介绍
安装 使用 基本介绍 react-photo-view 是一个基于 React 的图片查看器组件，用于在网页上展示和浏览图片。该组件提供了用户友好的界面和交互，可以轻松地在应用程序中集成并使用。 支持触摸手势，拖动/平移/物理效果滑动，双指指定位置放大/缩小全方面动画衔接，打开/关闭/回弹/触边，顺其自然的交互效果图像自适应，以一个合适的最初呈现大小，并根据调整自适应支持自定义如 &lt;video /&gt; 或任意 HTML 元素的预览键盘导航，完美适配桌面端支持自定义节点扩展，轻松实现全屏预览、旋转控制、图片介绍以及更多功能基于 typescript，7KB Gzipped，支持服务端渲染简单易用的 API，上手零成本 安装 在 React 项目目录运行以下命令：
pnpm:
pnpm i react-photo-view yarn:
yarn add react-photo-view 或者用 npm:
npm install react-photo-view 使用 //引入组件 import { PhotoProvider, PhotoView } from 'react-photo-view'; //引入css import 'react-photo-view/dist/react-photo-view.css'; //使用 &lt;PhotoProvider&gt; &lt;PhotoView src="/img/homepage/sourcecode/source_code_check.png"&gt; &lt;img src="/img/homepage/sourcecode/source_code_check.png" /&gt; &lt;/PhotoView&gt; &lt;/PhotoProvider&gt; 一些常用的PhotoView的相关属性 。
NameDescriptionTypeDefault Valuesrc图片地址stringrender自定义渲染，优先级比 src 低(props: PhotoRenderParams) =&gt; React.ReactNodeoverlay图片覆盖物React.ReactNodewidth自定义渲染节点宽度numberheight自定义渲染节点高度numberchildren子节点，一般为缩略图React.ReactElementtriggers触发打开图片的方式Array&lt;"onClick" | "onDoubleClick"&gt;["onClick"] 其他的例如，添加过渡动画，自定义工具栏，长图模式等更多功能请参阅官方文档。
官方文档：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42450cd43d17be699f1f224fbd13c1e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499c6ed32472f6a553817b0e924b3b03/" rel="bookmark">
			react-lazyload 的介绍、安装、使用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本介绍
安装
使用 基本使用
详细属性
基本介绍 react-lazyload 是一个 React 组件，用于延迟加载（懒加载）页面上的图片或其他资源。懒加载是一种优化手段，它允许页面在初次加载时只加载可视区域内的内容，而在用户滚动页面时再加载其他部分的内容，从而提高页面加载性能。
Github:GitHub - twobin/react-lazyload: Lazy load your component, image or anything matters the performance.Lazy load your component, image or anything matters the performance. - GitHub - twobin/react-lazyload: Lazy load your component, image or anything matters the performance.https://github.com/twobin/react-lazyload
安装 # 使用 npm npm install react-lazyload # 使用 yarn yarn add react-lazyload 博主这里安装的是3.2.0版本。 使用 基本使用 import React from 'react'; import LazyLoad from 'react-lazyload'; const MyComponent = () =&gt; ( &lt;div&gt; &lt;h1&gt;My Component&lt;/h1&gt; {/* 使用 LazyLoad 包装需要懒加载的内容 */} &lt;LazyLoad height={200} offset={100}&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499c6ed32472f6a553817b0e924b3b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4ad42d050dda1662c6e3f029653422/" rel="bookmark">
			Pinyin-pro的介绍、安装、使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
拼音（Pinyin-pro）工具概述
拼音（Pinyin-pro）工具安装
拼音（Pinyin-pro）工具使用
拼音（Pinyin-pro）工具概述 "pinyin-pro" 是一个专业的 JavaScript 中文转拼音的库，具备多音字识别准确、体积轻量、性能优异、功能丰富等特点。其功能具体如下：
支持拼音/声母/韵母/首字母/音调/全部信息支持人名姓氏模式支持文本和拼音匹配支持自定义拼音支持获取带拼音汉字的 HTML 字符串支持获取汉字的所有拼音支持拼音输入转换极致的性能和极高的拼音识别准确率 拼音（Pinyin-pro）工具安装 //npm nmp install pinyin-pro //yarn yarn add pinyin-pro 但是博主在安装途中发现最新版本的Pinyin-pro 与公司的老项目不兼容，运行总是报错，猜测可能是Pinyin-pro中的某些语法或者工具包版本较高与公司的老项目不兼容。于是我在NPM官网找到了几个月以前的一个稳定版本（3.15.1）。这样运行起来就不报错了。
//npm nmp install pinyin-pro@3.15.1 //yarn yarn add pinyin-pro@3.15.1 拼音（Pinyin-pro）工具使用 获取拼音 import { pinyin } from 'pinyin-pro'; // 获取字符串格式拼音 pinyin('汉语拼音'); // 'hàn yǔ pīn yīn' // 获取数组格式拼音 pinyin('汉语拼音', { type: 'array' }); // ["hàn", "yǔ", "pīn", "yīn"] // 获取不带音调数组格式拼音 pinyin('汉语拼音', { toneType: 'none' }); // "han yu pin yin"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4ad42d050dda1662c6e3f029653422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5977c3ed49dde5308e373bdfdd1455cd/" rel="bookmark">
			【DL-遇错】NVIDIA安装CUDA在安装阶段提示NVIDIA安装程序失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
NVIDIA安装CUDA在安装阶段提示NVIDIA安装程序失败（如下图所示）
问题解决：
在自定义安装选项这一步只选择CUDA这一项，其他选项全部不勾选，然后继续后面步骤即可安装成功
解决参考：
参考一 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c740859d59197dd25ecb027a77ad2e/" rel="bookmark">
			ArrayList 多线程操作的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 并发修改异常（ConcurrentModificationException）
2. 数据不一致性
3. 索引错位
4. 内存可见性问题
原因
解决方案
在多线程环境下操作 ArrayList 可能会遇到以下几个问题：
1. 并发修改异常（ConcurrentModificationException） 当多个线程尝试同时对 ArrayList 进行结构性修改（如添加、删除元素）时，可能会抛出 ConcurrentModificationException。这种异常通常在一个线程遍历集合的过程中，另一个线程修改了集合的结构，导致预期的集合状态和实际状态不一致。
2. 数据不一致性 如果多个线程并发访问 ArrayList，可能会出现数据不一致的情况。例如，一个线程正在写入数据，而另一个线程正在读取数据，读取线程可能会读到一个不完整或者不正确的状态。
3. 索引错位 在多线程对 ArrayList 进行添加或删除操作时，可能会导致元素索引发生错位或产生空位。这是因为一个线程可能在向列表中添加元素的同时，另一个线程正在删除或添加某个元素，从而导致索引计算出现错误。因为添加或删除并非原子操作（size++ 和赋值并非原子）。
public boolean add(E e) { ensureCapacityInternal(size + 1); elementData[size++] = e; return true; } 4. 内存可见性问题 由于 ArrayList 没有处理内存可见性，所以当一个线程修改了列表内容，其他线程可能看不到这些改动，除非使用同步机制来确保可见性。
原因 这些问题的根本原因在于 ArrayList 不是线程安全的。在 Java 集合框架中，ArrayList 的设计没有考虑同步机制，这意味着当多个线程对其进行操作时，并没有内置的方法来防止竞争条件或保证线程安全。
解决方案 为了避免这些问题，可以采取以下措施：
使用线程安全的集合：如 Vector 或 CopyOnWriteArrayList，或者使用 Collections.synchronizedList 方法将 ArrayList 包装成一个线程安全的列表。
使用并发集合：Java 的 java.util.concurrent 包提供了一些线程安全的集合类，如 ConcurrentHashMap。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c740859d59197dd25ecb027a77ad2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336c38e9d08c52b576e007afcb875a0c/" rel="bookmark">
			Pandas教程：教你DataFrame数据的条件筛选——精选篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1DataFrame数据的筛选与分布统计的示例用法
import pandas as pd data = {'诗人': ['李白', '苏轼', '李清照', '杜甫', '岳飞'], '性别': ['男', '男', '女', '男', '男'], '芳龄': [18, 26, 13, 15, 28], '朝代': ['唐', '北宋', '宋', '唐', '南宋'], '薪资': [9000, 7000, 8000, 5000, 7000]} df = pd.DataFrame(data, index=['一', '二', '三', '四', '五']) print('0.原始DataFrame数据'.center(40, '-')) print(df) print('1.计数器：统计性别字段里面，男女的分别个数'.center(40, '-')) print(df['性别'].value_counts()) print('显示占比，在数量统计的基础上加一个参数 normalize=True'.center(40, '-')) print(df['性别'].value_counts(normalize=True)) print('2.筛选出性别为男的数据'.center(40, '-')) print(df[df['性别'] == '男']) print('3.筛选出朝代是唐，宋的数据'.center(40, '-')) print(df[df['朝代'].isin(['唐', '宋'])]) print('4.筛选出薪资大于等于8000的数据'.center(40, '-')) print(df[df['薪资'] &gt;= 8000]) 输出内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/336c38e9d08c52b576e007afcb875a0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4241dbaca8ea06ba513e6240f02d3c/" rel="bookmark">
			edge浏览器ie兼容模式怎么打开控制台？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win + R，输入神秘代码：
%systemroot%/System32/f12/IEChooser.exe
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448f9ae38193d8454f51e95c0de4157d/" rel="bookmark">
			vue3 setup 中国省市区三级联动options最简洁写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 前端Q，关注公众号
回复加群，加入前端Q技术交流群
前言 本前端仔在写页面的时候，发现表单里面有一个省市区的 options 组件要写，因为表单很多地方都会用到这个地址选择，我便以为很简单嘛。
虽然很简单的一个功能，但是网络上能搜索到的教程大多都是需要配合 elementUI 等各种 UI 库的，但是我的项目并没有使用这些 UI 库，何况我只是想要拿到 一个地址字符串 而已，何必绑定 UI 库呢？
1、地址三级联动制作思路 思路其实很简单：
1、一个地图 json 数据
2、能够拿到 省份、市、区 的 options 数组来绑定就可以了
3、选择一个省份市，对应的市要变化；选择市时，对应的区要变化
这样的话，我们完全可以依赖 vue 强大的数据处理机制来解决
2、地图json 地图json数据我随便搜了一个： 中国省市区数据[1]
3、vue setup 语法糖写法 我们点击上面的链接，下载了地图json数据，这里选择一个普通的就可以了，如图：
image.png 将文件命名为 area.json ，然后在项目中引入：
// 详细地址(省市区 详细地址) import areaObj from '../../public/area.json'; 第一步：首先是处理省份options数组（这里json地图是键名为省份）：
// 省 const provinceArr = Object.keys(areaObj) const province = ref(provinceArr[0]) 这样就拿到了一个省份数组，这里随机默认选中第一个，北京市，这里 province 变量用来绑定输入框的值
第二步：处理市的数据，关键就是使用计算属性来监听 省份的变化，省份一改变，市的数据也会跟着改变：
// 市 const cityArr = computed(() =&gt; { return Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448f9ae38193d8454f51e95c0de4157d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a30e790bc26817e24b719ff4d0a75d/" rel="bookmark">
			《二十九》自动化构建工具 Gulp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Gulp4。
Gulp：是一个工具包，可以帮助自动化和增强工作流。
Gulp 和 Webpack 的区别： Gulp 的核心理念是 task runner。可以定义一系列任务，等到任务被执行；是基于文件Stream 的构建流；可以使用 Gulp 的插件体系来完成任务。Webpack 的核心理念是 module bundler。是一个模块化的打包工具；可以使用各种各样的 Lodaer 来加载不同的模块；可以使用各种各样的插件在打包的生命周期中完成其他的任务。 Gulp 相对于 Webpack 来说更加地简单易用，适合编写一些自动化的任务，让它们挨个自动去执行，但是对于目前大型的项目（React、Vue、Angular 等）并不会使用 Gulp 来构建。
Gulp 默认不支持模块化。
Gulp 的基本使用： 每个 Gulp 任务都是一个异步的 JavaScript 函数；接收一个回调函数作为参数；必须明确地表示被执行完成，可以通过两种方式：执行作为参数的回调函数，或者返回一个 stream、promise、event emitter、child process 或者 observable 类型的函数。
Gulp 中任务可以分为公开任务和私有任务。
公开任务：在 gulpfile.js 文件中导出的任务被称为公开任务，这些任务可以通过 gulp 命令直接调用。私有任务：被设计为在内部使用，通常作为 series() 或者 parallel() 任务组合的组成部分。 Gulp 单个任务： 新建 gulp-demo 文件夹，并 npm init -y 初始化该项目。
在该文件夹下本地安装 Gulp：npm install gulp。
在项目根目录下新建 gulpfile.js 文件，并定义任务。
// gulpfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a30e790bc26817e24b719ff4d0a75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8928a1c483fd1370551563954cfdc22/" rel="bookmark">
			Dart设计模式之建造者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dart设计模式之建造者模式 建造者模式 模式分析 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
模式难点 如何抽象出不同特性需要很强的抽象思维
模式解决问题 主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
优点 建造者独立，易扩展。便于控制细节风险。 缺点 产品必须有共同点，范围有限制。如内部变化复杂，会有很多的建造类。 模式应用场景 需要生成的对象具有复杂的内部结构。需要生成的对象内部属性本身相互依赖。 模式代码 //建造者模式 import 'run.dart'; //建造者模式的精髓在于抽象，要把内容都抽象成一个一个的类来实现 //标识食物的接口 abstract class Item { String name; Packing packing(); double price; } //包装接口 abstract class Packing { String pack(); } //实现包装接口的实体类 class Wrapper implements Packing { @override pack() { return "Wrapper"; } } class Bottle implements Packing { @override String pack() { return "Bottle"; } } ///创建实现Item接口的抽象类 //使用包装纸包装的食物 abstract class Burger implements Item { @override Packing packing() { return new Wrapper(); } } //使用瓶子包装的食物 abstract class ColdDrink implements Item { @override Packing packing() { return new Bottle(); } } //创建扩展了Burger和ColdDrink的实体类 //蔬菜 class VegBurger extends Burger { @override String name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8928a1c483fd1370551563954cfdc22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd430b64586a58d32fb87493d084e34/" rel="bookmark">
			【计算机视觉 | 目标检测】arxiv 计算机视觉关于目标检测的学术速递（12 月 6 日论文合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、检测相关(10篇)1.1 Diffusion-SS3D: Diffusion Model for Semi-supervised 3D Object Detection1.2 Towards More Practical Group Activity Detection: A New Benchmark and Model1.3 Are Synthetic Data Useful for Egocentric Hand-Object Interaction Detection? An Investigation and the HOI-Synth Domain Adaptation Benchmark1.4 Diffusion Noise Feature: Accurate and Fast Generated Image Detection1.5 Projection Regret: Reducing Background Bias for Novelty Detection via Diffusion Models1.6 Towards Automatic Power Battery Detection: New Challenge, Benchmark Dataset and Baseline1.7 Lenna: Language Enhanced Reasoning Detection Assistant1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd430b64586a58d32fb87493d084e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eaa67dad184de25203917d974e11813/" rel="bookmark">
			如何在Spring Boot中集成RabbitMQ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在Spring Boot中集成RabbitMQ 在现代微服务架构中，消息队列（如RabbitMQ）扮演了关键的角色，它不仅能够提供高效的消息传递机制，还能解耦服务间的通信。本文将介绍如何在Spring Boot项目中集成RabbitMQ，实现生产者和消费者的基本配置。
步骤1：添加Maven依赖 首先，在你的Spring Boot项目的pom.xml中添加spring-boot-starter-amqp依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 这个starter包含了与RabbitMQ集成所需的所有基本依赖。
步骤2：配置RabbitMQ 在application.yml或application.properties中配置RabbitMQ的连接信息：
spring: rabbitmq: host: 10.5.2.27 port: 30700 username: user password: Sungrow@2023 步骤3：实现生产者 在Spring Boot中，发送消息到RabbitMQ的生产者可以很简单地通过RabbitTemplate实现：
import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.web.bind.annotation.*; import com.alibaba.fastjson.JSONObject; @RestController @RequestMapping("/menu") public class MenuController { @Resource private RabbitTemplate rabbitTemplate; @PostMapping("/add") public Result&lt;SysPermission&gt; add(@RequestBody SysPermission permission) { // ... 添加菜单的业务逻辑 rabbitTemplate.convertAndSend(RabbitConstant.GOODS_EXCHANGE, RabbitConstant.MENU_MESSAGE, JSONObject.toJSONString(permission)); return new Result&lt;SysPermission&gt;().success("添加成功！"); } } 这里，convertAndSend方法用于发送消息到指定的交换机和路由键。
步骤4：配置RabbitMQ交换机、队列和绑定 在Spring Boot中，可以通过配置类来定义交换机、队列和它们之间的绑定关系：
import org.springframework.amqp.core.*; import org.springframework.context.annotation.Bean; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eaa67dad184de25203917d974e11813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7bae55154b729300d9eef41d1052831/" rel="bookmark">
			【教程】逻辑回归怎么做多分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、逻辑回归模型介绍
1.1 逻辑回归模型简介
1.2 逻辑回归二分类模型
1.3 逻辑回归多分类模型
二、如何实现逻辑回归二分类
2.1 逻辑回归二分类例子
2.2 逻辑回归二分类实现代码
三、如何实现一个逻辑回归多分类
3.1 逻辑回归多分类问题
3.1 逻辑回归多分类的代码实现
本文部分图文借鉴自《老饼讲解-机器学习》
一、逻辑回归模型介绍 1.1 逻辑回归模型简介 逻辑回归模型是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。它与多重线性回归有很多相同之处，模型形式基本相同，都具有w'x+b，其中w和b是待求参数。重线性回归直接将w'x+b作为因变量即y =w'x+b，而逻辑回归则通过sigmiod函数将w'x+b对应一个概率P，
也就是说，线性回归用于数值预测问题，而逻辑回归则用于分类问题，逻辑回归输出的是属于类别的概率。逻辑回归的意义如下图所示，用直线/超平面将不同类别的数据样本进行划分：
逻辑回归可以用于做二分类(即只有两个类别)，也可以做多分类(2个以上的类别)。二分类是逻辑回归的基本模型，而多分类则是二分类模型的拓展。
1.2 逻辑回归二分类模型 逻辑回归的二分类模型如下：
它的损失函数为最大似然损失函数：
模型中的参数W就是通过求解损失函数，令损失函数取最小值，从而求得W的最优解。模型的求解一般使用梯度下降法。
1.3 逻辑回归多分类模型 逻辑回归多分类模型是二分类模型的拓展。主要有softmax回归和OVR两种拓展方法,其中，OVR是基于二分类模型的一种通用拓展方法。两种方法的原理如下：
softmax回归：softmax回归是逻辑回归在多分类问题上的推广，通过修改逻辑回归的损失函数，将逻辑回归变为softmax回归。softmax回归会有相同于类别数的输出，输出的值为对于样本属于各个类别的概率，最后对于样本进行预测的类型为概率值最高的那个类别。
OVR(基于二分类的逻辑回归)：根据每个类别都建立一个二分类器，本类别的样本标签定义为0，其它分类样本标签定义为1，则有多少个类别就构造多少个逻辑回归分类器。这种方法实际上是将多分类问题划分为多个二分类问题来解决。
上述两种方法都是常用的逻辑回归多分类方法，无论采用哪种方法，逻辑回归多分类模型都需要根据具体问题和数据集进行调整和优化，以获得更好的分类性能。
当为Softmax回归时，逻辑回归多分类的模型表达式如下：
当为OVR模型时，逻辑回归多分类的模型表达式如下
其中，代表属于k类的概率
二、如何实现逻辑回归二分类 2.1 逻辑回归二分类例子 在python中，可以使用sklearn的LogisticRegression实现一个逻辑回归的，例子如下
具体数据如下：
特征：平均平滑度、平均紧凑度、平均凹面、平均凹点，类别：0-恶性、1-良性
即以sk-learn中的breast_cancer的数据，breast_cancer原数据中有30个特征，为方便讲解，我们这里只选4个。下面展示调用sklearn训练一个逻辑回归的DEMO代码
2.2 逻辑回归二分类实现代码 代码简介 ：
1. 数据归一化（用sklearn的逻辑回归一般要作数据归一化）
2. 用归一化数据训练逻辑回归模型 3. 用训练好的逻辑回归模型预测 from sklearn.datasets import load_breast_cancer from sklearn.linear_model import LogisticRegression import numpy as np #----数据加载------ data = load_breast_cancer() X = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7bae55154b729300d9eef41d1052831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d24b9f34d8160b971ecc48065c4d913/" rel="bookmark">
			工作中Hutool包的常用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常工作经常用到hutool工具包，久而久之我就把这些常用的方法慢慢记录下来了，大家可以简单看一下
异常信息String化打印 单独的工具方法 public class ExceptionUtil { // 以上代码通过将异常信息打印到 StringWriter 对象中，然后获取 StringWriter 的字符串表示，从而获取到异常信息的字符串。 public static String toString(Exception e) { StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); e.printStackTrace(pw); return sw.toString(); } } Exception具体报错内容转string public static void main(String[] args) { try { int i = 1/0; } catch (Exception e) { System.out.println(ExceptionUtil.stacktraceToString(e)); } } 打印出来的内容：
java.lang.ArithmeticException: / by zero at com.bofei.activity.task.LoanActiveTask.main(LoanActiveTask.java:147) 元素操作 对象List切割 按照批次分割数组，如1000个元素分四批
List&lt;List&lt;LoanInfoBulkChargeVO&gt;&gt; batchTotalList = ListUtil.splitAvg(collect, bulkDeductionBatchTotal); 按照数量分割数组，如2000个元素按200为一个组进行划分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d24b9f34d8160b971ecc48065c4d913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d082115837c65323f0fdd98d4e9e1cbc/" rel="bookmark">
			flex布局的flex为1到底是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客：flex:1什么意思_公孙元二的博客-CSDN博客
flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。
今天写样式的时候，碰到这样一个问题：子盒子①和②的父盒子设置了display。子盒子①设置了固定宽度，如果子盒子②不想设置calc计算的话，可以设置子盒子②样式display为1
设置②display：1后 ，②则沾满剩下所有空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d97e6cd8d87bdb01b80f9dcaefc2b35/" rel="bookmark">
			JavaWeb知识点小结:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Maven坐标： Maven坐标是Maven中的一个重要概念，用于唯一标识一个Maven项目的依赖关系。
什么是坐标： Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置使用坐标来定义当前项目或引入项目中需要的依赖 它由以下几部分组成： groupId标识项目所属的组织或者公司，一般是倒序的域名，例如org.apache.maven；artifactId标识项目的唯一标识符，例如maven-core；version表示项目的版本号 Maven生命周期： Maven生命周期，也叫lifecycle，是Maven对构建过程的抽象。它通过定义一系列阶段来组织和管理构建任务，这些阶段依次执行，以完成从清理、初始化、编译、测试、打包、集成测试、验证、部署到生成站点等几乎所有构建步骤。
具体来说，Maven的生命周期可以划分为以下三个主要阶段：
Clean生命周期：这一阶段的目标是清理项目，移除所有上一次构建生成的文件。它进一步分为pre-clean（执行一些需要在clean之前完成的工作）、clean（执行清理操作）和post-clean（执行一些需要在clean之后立刻完成的工作）三个子阶段。
Default生命周期（也称为Build生命周期）：这是Maven的主要生命周期，被用于构建应用。这个阶段包括了诸如验证项目的正确性（validate），编译项目的源代码（compile），运行项目的单元测试（test），将编译后的代码打包成可分发的格式（package），对项目进行额外的检查以确保质量（verify），以及将项目的构建结果安装到本地Maven仓库中，以供其他项目使用（install）等一系列步骤。
Site生命周期：这个阶段的目标是生成项目站点，包含了如报告生成，文档生成等步骤。
值得注意的是，Maven的生命周期是抽象的，因此它不做任何的实际工作，所有的任务都由插件（plugin）完成。
HTTP-请求数据格式： 请求方式-GET： 请求参数在请求行中，没有请求体，如: /brand/findAll?name=OPPO&amp;staus=1。GET请求大小是有限制的。
请求方式-POST： 请求参数在请求体中，POST请求大小是没有限制的。
两种请求方式的异同： 在HTTP请求中，GET和POST是两种最常被使用的请求方式。GET是从指定的资源请求数据，而POST则是向指定的资源提交要被处理的数据。
原理上，GET和HEAD方法被称为安全方法，因为它们不会修改服务器上的信息。这意味着使用GET和HEAD的HTTP请求不会在服务器上产生任何实质性的结果。然而，这并不意味着这些安全方法不会执行任何操作，只是它们不会修改信息。相较之下，根据HTTP规范，POST可能会修改服务器上的资源。
此外，GET和POST方法在使用上有一些明显的区别。例如，GET提交参数一般会显示在URL上，而POST通过表单提交，其内容则不会显示在URL上，因此POST更具隐蔽性。同时，GET请求可被缓存、保留在浏览器历史记录中、收藏为书签，但不应该在处理敏感数据时使用。相对地，POST方法不能被缓存、收藏为书签或保留在浏览器历史记录中。
从实际应用的角度来看，由于GET请求把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，因此在URL中可以看到。与此相反，POST方法是通过HTTP post机制，将表单内各个字段与其内容一起传送到ACTION属性所指的URL地址，对于用户来说这个过程是看不到的。
最后，需要注意的是，虽然理论上GET和POST方法都没有数据量限制，但实际上受浏览器、操作系统以及服务器的限制，GET传送的数据量较小，一般不能大于2KB；而POST传送的数据量较大，通常被默认为不受限制。
请求相应介绍-HTTP响应格式： HTTP 状态码分类 HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：
1XX响应中-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它2XX 成功-表示请求已经被成功接受，处理已完成
3XX重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理4XX客户端错误--处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等5XX服务器端错误--处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 HTTP状态码列表: 着重记住：
200：客户端请求成功
404：请求资源不存在，一般是URL输入有误，或者网站资源被删除了
500：服务端发生不可预期的错误
为什么使用list请求参数t时一定要加上@RequestParm？ 在Spring MVC中，@RequestParam注解用于将请求参数绑定到方法参数上。当你使用List&lt;String&gt; hobby作为方法参数时，Spring会自动将请求中的多个相同名称的参数值收集到一个列表中，并将这个列表作为hobby参数的值。
如果不使用@RequestParam注解，Spring无法正确地将请求参数绑定到方法参数上。例如，如果你的请求URL是/listParam?hobby=reading&amp;hobby=swimming，如果没有使用@RequestParam注解，那么hobby参数的值将会是一个包含两个字符串"reading"和"swimming"的列表，而不是一个只包含一个字符串"reading,swimming"的列表。
因此，为了确保请求参数能够正确地绑定到方法参数上，你需要在方法参数前加上@RequestParam注解。
Spring框架中IOC中常用注解： bean是什么？ Bean 是一个由 Spring IoC（控制反转）容器管理的对象。Spring Boot 使用注解来定义和配置 Bean，这些注解包括 @Component、@Service、@Repository、@Controller 等。
当 Spring Boot 启动时，它会扫描项目中的类，查找带有特定注解的类，并将这些类实例化为 Bean。然后，Spring IoC 容器会管理这些 Bean，负责它们的生命周期和依赖注入。
依赖注入的注解：
@Autowired：默认按照类型自动装配
如果同类型的bean存在多个： @Primary 在同类型的类名之前，添加该注解，会提高该类的优先级@Avutowired + @Qualifer("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d97e6cd8d87bdb01b80f9dcaefc2b35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e33f23ca06a5f9d5dedae7536460b70/" rel="bookmark">
			【STM32单片机】简易电子琴设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、功能简介二、软件设计三、实验现象联系作者 一、功能简介 本项目使用STM32F103C8T6单片机控制器，使用数码管模块、矩阵按键、无源蜂鸣器等。
主要功能：
系统运行后，蜂鸣器播放一首音乐，进入电子琴模式，
数码管默认显示0，可通过矩阵按键S1-S16控制1-7低中高音调，同时数码管显示对应音符。按键按下一直发音，松开停止。
二、软件设计 /* 作者：嗨小易（QQ：3443792007） */ //播放起风了 u16 wind_rise[]= {	//前奏 L7,25,M1,25,M2,25,M3,25,L3,50,M5,25,M3,25,M3,50,Z0,150, L7,25,M1,25,M2,25,M3,25,L2,50,M5,25,M3,25,M2,25,M3,25,M1,25,M2,25,L7,25,M1,25,L5,25,Z0,25, L7,25,M1,25,M2,25,M3,25,L3,50,M5,25,M3,75,Z0,150,L7,25,M1,25,M2,25,M3,25,L2,50,M5,25,M3,25,M2,25,M3,25,M1,25,M2,25,Z0,20, //这一路上走走停停 顺着少年漂流的痕迹 M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,50,M3,50,M5,50,M3,50, M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,25,M3,25,M2,25,M1,25,L6,100,Z0,10, //迈出车站的前一刻 竟有些犹豫 M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,50,M3,50,M5,50,M3,50, M2,50,M2,50,M3,25,M2,50,M1,50,M2,100,Z0,50, //不仅笑着这近乡情怯 仍无法避免 M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,50,M3,50,M5,50,M3,50, M2,50,M2,50,M3,25,M2,50,M1,50,L6,100,Z0,10, //而长野的天 依旧那么暖 风吹起了从前 M3,25,M2,25,M1,25,M2,25,M1,100, M3,25,M2,25,M1,25,M2,25,M1,50,M1,50, M5,25,M3,25,M2,25,M1,25,M2,25,M1,100,M1,150,Z0,30, //从前初识这世间 万般留恋 看着天边似在眼前 也甘愿赴汤蹈火去走它一遍 M1,50,M2,50,M3,50,M1,50,M6,50,M5,25,M6,25,M6,50,M6,50, M1,25,M7,50,M6,25,M7,25,M7,100,Z0,5, M7,50,M6,25,M7,25,M7,50,M3,50,H1,25,H2,25,H1,25,M7,25,M6,50,M5,50, M6,50,M5,25,M6,25,M6,25,M5,25,M6,25,M5,25,M6,50,M5,25,M2,25,M2,25,M5,50,M5,50,M3,100,M3,100,Z0,25, //如今走过这世间 万般留恋 翻过岁月不同侧脸 措不及防闯入你的笑颜 M1,50,M2,50,M3,50,M1,50,M6,50,M5,25,M6,25,M6,50,M6,50, M1,25,M7,50,M6,25,M7,25,M7,100,Z0,5, M7,50,M6,25,M7,25,M7,50,M3,50,H1,25,H2,25,H1,25,M7,25,M6,50,M5,50, M6,50,H3,25,H3,25,H3,50,M5,50,M6,50,H3,25,H3,25,H3,25,M5,50,M6,25,M6,100,M6,100,M6,100,Z0,25, //我曾难自拔于世界之大 也沉溺于其中梦话 H1,50,H2,50,H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H2,25,H3,25,H3,50, H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,25,H3,50,H3,50, //不得真假 不做挣扎 不惧笑话 H2,50,H1,25,M6,25,M6,25,H1,50, M6,25,H2,25,H1,25,M6,50,M6,25,H1,50,H1,50, H3,100,H3,25,H4,25,H3,50,H3,25,H2,50,H2,50,Z0,25, //我曾将青春翻涌成她 也曾指尖弹出盛夏 心之所动且就随缘去吧 H1,50,H2,50,H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H2,50, H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H3,50,H3,50, H2,50,H1,25,M6,25,M6,25,H3,50,H3,50, H2,50,H1,25,M6,25,M6,25,H1,50,H1,50,H1,100,H1,100,Z0,10, //短短的路走走停停 也有了几分的距离 M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,50,M3,50,M5,50,M3,50, M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,25,M3,25,M2,25,M1,25,L6,100,Z0,10, //不知抚摸的是故事还是段心情 M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,50,M3,50,M5,50,M3,50, M2,50,M2,50,M3,25,M2,50,M1,50,M2,100,Z0,50, //也许期待的不过是与时间为敌 M2,50,M2,50,M1,25,M2,50,M2,50,M1,25,M2,50,M3,50,M5,50,M3,50, M2,50,M2,50,M3,25,M2,50,M1,50,L6,100,Z0,10, //再次见到你 微凉晨光里 笑的很甜蜜 M3,25,M2,25,M1,25,M2,25,M1,100, M3,25,M2,25,M1,25,M2,25,M1,50,M1,50, M5,25,M3,25,M2,25,M1,25,M2,25,M1,100,M1,150,Z0,30, //从前初识这世间 万般留恋 看着天边似在眼前 也甘愿赴汤蹈火去走它一遍 M1,50,M2,50,M3,50,M1,50,M6,50,M5,25,M6,25,M6,50,M6,50, M1,25,M7,50,M6,25,M7,25,M7,100,Z0,5, M7,50,M6,25,M7,25,M7,50,M3,50,H1,25,H2,25,H1,25,M7,25,M6,50,M5,50, M6,50,M5,25,M6,25,M6,25,M5,25,M6,25,M5,25,M6,50,M5,25,M2,25,M2,25,M5,50,M5,50,M3,100,M3,100,Z0,25, //如今走过这世间 万般留恋 翻过岁月不同侧脸 措不及防闯入你的笑颜 M1,50,M2,50,M3,50,M1,50,M6,50,M5,25,M6,25,M6,50,M6,50, M1,25,M7,50,M6,25,M7,25,M7,100,Z0,5, M7,50,M6,25,M7,25,M7,50,M3,50,H1,25,H2,25,H1,25,M7,25,M6,50,M5,50, M6,50,H3,25,H3,25,H3,50,M5,50,M6,50,H3,25,H3,25,H3,25,M5,50,M6,25,M6,100,M6,100,M6,100,Z0,25, //我曾难自拔于世界之大 也沉溺于其中梦话 H1,50,H2,50,H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H2,25,H3,25,H3,50, H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,25,H3,50,H3,50, //不得真假 不做挣扎 不惧笑话 H2,50,H1,25,M6,25,M6,25,H1,50, M6,25,H2,25,H1,25,M6,50,M6,25,H1,50,H1,50, H3,100,H3,25,H4,25,H3,50,H3,25,H2,50,H2,50,Z0,25, //我曾将青春翻涌成她 也曾指尖弹出盛夏 心之所动且就随缘去吧 H1,50,H2,50,H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H2,50, H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H3,50,H3,50, H2,50,H1,25,M6,25,M6,25,H3,50,H3,50, H2,50,H1,25,M6,25,M6,25,H1,50,H1,50,H1,100,H1,100,Z0,10, //逆着光行走任风吹雨打吧 M6,25,H3,50,H3,50,H2,50,H1,25,M6,25,M6,25,H3,50,H2,50,H1,25,M6,25,M6,25,H1,50,H1,50,H1,50,H1,100,Z0,25, //晚风吹起你鬓间的白发 抚平回忆留下的疤 H1,50,H2,50,H2,25,H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H2,25, H3,25,H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,25,H3,50,H3,50,Z0,5, //你的眼中明暗交杂 一笑生花 暮色遮住你蹒跚的步伐 H2,50,H1,25,M6,25,M6,25,H1,50,M6,25,H2,25,H1,25,M6,50,M6,50, H1,50,H1,50,H3,100,H3,25,H4,25,H3,50,H3,25,H2,50,H2,50,H1,100,H2,100,H3,100,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H2,50, //走进床头藏起的画 画中的你(低着头说话) H3,50,H6,25,H5,25,H5,50,H6,25,H5,25,H5,50,H6,25,H5,25,H3,100,H3,50,H2,50,H1,25,M6,25,M6,25,H3,50,H3,50,H2,50,H1,25,M6,25,M6,25,H1,100,H1,50,Z0,5, //我仍 了 以爱之名你还愿意吗（衔接头有问题） H1,50,H2,50,H1,50,H1,100,M6,25,H3,50,H3,50,H2,50,H1,25,H6,25,H6,25,H3,50,H3,50,H2,50,H1,25,H6,25,H6,25,H1,50,H1,50,H1,100,Z0,5 }; void music_play2(void) { u16 i=0; u16 length=0; length = sizeof(wind_rise)/sizeof(wind_rise[0]); for(i=0;i&lt;(length/2);i++) { beep_on(wind_rise[i*2],260); delay_ms(wind_rise[i*2+1]*5); } } //系统数据设置 void sys_data_set(void) { u8 key=0; u16 note[16]={L6,L7,M1,M2,M3,M4,M5,M6,M7,H1,H2,H3,H4,H5,H6,H7}; key=KEY_Matrix_Scan(); //有键按下 if(key!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e33f23ca06a5f9d5dedae7536460b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607923c6a8f8ff4fa546509ce5e91729/" rel="bookmark">
			C#WinForm连接查询数据库sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、建立WinForm文件
二、开始设计窗体的板面
1.添加控件
2.修改控件属性
三、连接数据库sql
1.先点击工具栏，然后选择连接到数据库
2.选择sql server
3.开始选择想要的数据库
4.双击Button控件，进出button的C#编辑的地方
四、用C#查询数据库数据
1.加一个命名空间
2.在button控件代码里写查询数据库语句
五、总结
一、建立WinForm文件 建立一个你想要的项目，选择Windows桌面的Windows窗体应用（.NET Framework）框架可以选择.NET Framework 4.7.2，版本较低可以选择.NET Framework 4.7.1
二、开始设计窗体的板面 1.添加控件 添加两个控件button和DataGridView
2.修改控件属性 Button属性：name:btnInquiry(驼峰命名法，前面是控件名的缩写，后面是控件要执行的内容),BackColor：可以选择一个你自己想要的控件颜色,text:查询，Anchor属性为Top, Left, Right
DataGridView属性：更改Anchor属性为Top, Left, Right让它跟随主窗体大小变大变小
三、连接数据库sql 1.先点击工具栏，然后选择连接到数据库 2.选择sql server 3.开始选择想要的数据库 4.双击Button控件，进出button的点击事件中编写C# 四、用C#查询数据库数据 1.加一个命名空间 要在命名空间上加入下面一串代码，免得不支持sql
using System.Data.SqlClient; 2.在button控件代码里写查询数据库语句 查询：
private void btnInquiry_Click(object sender, EventArgs e) { //连接数据库 //server：自己电脑服务器名 //user id:SQL server 验证后的用户名 //password:SQL server 验证后的密码 //database:所要用的数据库 string conStr = "server=不想写作业;user id=sa;password=1256;database=student"; SqlConnection con = new SqlConnection(conStr); //打开数据库 con.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607923c6a8f8ff4fa546509ce5e91729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805080eb6387f5c093344171aa605a3c/" rel="bookmark">
			React Native 环境搭建----Andriod端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细！！！React Native 环境搭建----Andriod端（window11系统） 1：node 版本2：JDK的卸载3：卸载完jdk8之后，安装jdk114：前置工作已经完成，开始下载Android Studio来配置React Native 的环境5：react native项目在真机设备上运行 react native官网Android端环境搭建流程:https://www.reactnative.cn/docs/environment-setup
我的步骤（亲试可用）
1：node 版本 （官网的说法是14版本以上）
node下载链接：https://nodejs.org/zh-cn/
2：JDK的卸载 （我原来使用的JDK8，卸载后安装为JDK11）
jdk下载链接：https://www.oracle.com/java/technologies/downloads/#java11
1:直接在开始菜单搜索控制面板
2:选择程序-卸载程序
3:将程序里与jdk相关的内容卸载（我这里已经卸载完成，不附带图了）
4:直接在开始菜单搜索环境变量
5:点击编辑系统环境变量，进入如下界面
6:点击环境变量，将之前配置的和jdk相关的环境变量删除，有可能是在上方的用户环境变量，也可能是在下方的系统环境变量，一般来说是有JAVA_HOME,CLASSPATH,和path里面的一些相关内容
7: CTRL + R 打开cmd窗口，输入javac -version 若是显示javac非内部或者外部命令，表示卸载成功
3：卸载完jdk8之后，安装jdk11 1: 从oracle官网注册账号下载jdk11(我下载的以下版本）
2:安装过程十分简单，这里不赘述了
3:安装完成之后需要配置环境变量
新增系统环境变量JAVA_HOME和CLASSPATH
JAVA_HOME C:\Program Files\java\jdk1.8（这里填jdk的地址）
CLASSPATH .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar （这里复制就可以）
在原来的path变量双击进去，然后分别新建两次，填入以下内容
Path %JAVA_HOME%\bin;
%JAVA_HOME%\jre\bin;
4:确定后关闭窗口，重新打开cmd
(输入javac -verison)成功显示版本信息
4：前置工作已经完成，开始下载Android Studio来配置React Native 的环境 Android Studio的下载链接： https://developer.android.google.cn/studio/
1:点击下载
2:勾选同意协议，即可进行下载
3:安装Android Studio
安装过程比较简单，我是没有改任何配置，直接下一步安装的
安装完成进入如下界面，点击sdk Manaage
4:参照官网安装一下组件
5:下载中…
6:下载完成后，点击finish即可
7:随后按照官网的步骤配置环境变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/805080eb6387f5c093344171aa605a3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e81ba8875effaf41aa5ef47558b24a/" rel="bookmark">
			开源公告 ： TDesignFlutter-百搭易用的跨平台UI组件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介 TDesign是一款诞生于腾讯内部、经过超500项内部业务检验的企业级设计体系，汇集了腾讯众多优秀组件库能力和设计研发经验。之前，TDesign已经支持 Vue2、Vue Next、React 等业界主流技术栈，方便使用者快速开发桌面端、移动端以及小程序等多个版本的应用程序。
作为TDesign设计体系的Flutter实现，TDesignFlutter不但拥有Flutter流畅的跨平台开发体验，而且拥有TDesign美观一致的设计资源。二者结合，开发者可以直接使用TDesign的组件构建Flutter应用，加快开发速度的同时，也确保了应用程序的一致性。
TDesignFlutter已上线Text、Button、Input等29个基础组件，支持4个基础主题属性。在腾讯内部，TDesignFlutter已支持多个产品线上稳定运行。
TDesignFlutter在组件的实现过程中，尽量保留系统组件的能力，并进行功能扩展，使其更强大更易用的同时，尽量降低项目迁移成本。因此，TDesignFlutter可以适用下列场景：
● 如果你是一个全新的业务，想要快速构建美观一致的FlutterAPP。 √
● 如果你使用Flutter系统组件构建了APP，想要一款简单易用、可快速迁移的组件库提升开发效率。 √
● 如果你想客户端和Web端使用风格统一的组件，或者后续需要支持PC桌面端应用。 √
此外，Collapse(折叠面板)、Upload(上传工具)等组件已在开发测试中，相信很快可以和大家见面。
诞生背景 随着互联网的快速发展，产品规模和功能日益增加，开发场景变得更加复杂，传统的设计研发模式已经不足以支撑业务的高速扩张。
腾讯推出的 TDesign 针对这一痛点研发，内含丰富可复用的设计组件资源，如色彩体系、文字系统、动效设计等，覆盖支持 Axure、Sketch、Figma、Adobe XD 等各大产品设计软件。用户可以按照需求查看对应组件的使用教程和代码演示，只需简单的引入操作，即可搭建属于自己的产品界面。而且TDesign支持 Vue2、Vue Next、React 等业界主流技术栈，让用户无需担心技术栈的问题，可以开箱即用。自2021年TDesign开源后，收获了不错的口碑与反响。
Flutter作为Google开源的跨平台框架，以其高效的开发流程、卓越的性能和跨平台能力，成为目前跨平台应用开发的首选框架。而它的跨平台特性，与TDesign多端可复用的理念极为调性相合。许多用户反馈，希望TDesign能够支持Flutter，以便在移动应用开发中使用TDesign的设计原则和规范。
因此，我们决定开源TDesignFlutter，为开发者提供一套一致、美观且易于使用的UI组件库。通过将TDesign的设计原则与Flutter的跨平台能力相结合，开发者可以更高效地构建出精美的移动应用程序。
特性优势 TDesignFlutter结合了TDesign和Flutter二者的优势，具体如下：
一致的多端体验：
Flutter可以通过一套代码库，构建精美的、原生平台编译的多平台应用，高效整合开发资源。而且结合TDesign前端技术栈，可以所有产品保持统一的设计风格，加深用户印象，提高用户粘度。
良好的工具兼容：
TDesignFlutter与Flutter生态系统中的其他插件和工具兼容性良好，可以轻松地集成第三方插件，扩展应用程序的功能。TDesign覆盖支持Axure、Sketch、Figma、Adobe XD 等各大产品设计软件，可以帮助开发者和设计师拥有更好的开发设计体验。
详尽的文档示例：
Flutter和TDesign都在官网提供了详尽的介绍文档和示例代码，可以轻松上手，快速开发。而且Flutter和TDesign都拥有活跃的社区环境，开发者可以在其中交流、提问和分享经验，获得支持和帮助。
百搭的设计风格：
TDesign拥有轻量简洁的 UI风格，百搭适配各种产品项目。而且TDesignFlutter提供了自定义主题的能力，可以支持用户替换自己喜欢的颜色、字体等，更适配自身的业务场景。
丰富的组件资源：
TDesignFlutter已上线Text、Button、Input等29个基础组件，内置244个ttf类型的常用Icon,拥有丰富的主题样式，统一的交互体验。Text组件支持系统Text所有属性，可无缝切换，增加中文居中处理，并将常用属性扁平化，使用更加方便。
开源规划 ● 提供更多可靠实用的组件
● 适配Flutter Web和PC桌面端,支持更多应用场景
● 提供更完善的单元测试模块和性能检测能力，确保组件更可靠和流畅
项目地址 官网地址：
https://tdesign.tencent.com/flutter
Github 地址：
https://github.com/Tencent/tdesign-flutter
欢迎广大设计师和开发者参与，共建通用企业级设计体系。
请给项目 一个 Star !
欢迎提出你的 issue 和 PR！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e81ba8875effaf41aa5ef47558b24a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65966d2fd36a00c4d4c216b829d616c/" rel="bookmark">
			网络基础试题——附答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络基础考题考点 考题；
1. 基础网络概念： IP地址和子网掩码的作用。网络协议的定义和作用，如TCP/IP协议族。OSI模型的七层结构及每一层的功能。 2. 网络设备： 路由器和交换机的区别与作用。集线器（Hub）与交换机（Switch）的对比。网关的作用和在网络中的位置。 3. 网络连接和拓扑： 星型、总线型、环形和网状拓扑结构的特点和优缺点。无线局域网络（WLAN）的基本原理。客户端-服务器模型与对等模型的区别。 4. 网络地址与路由： IPv4和IPv6的区别。子网划分和CIDR表示法。静态路由和动态路由的区别。 5. 网络安全基础： 防火墙的作用和不同类型。公钥基础设施（PKI）的基本原理。常见的网络攻击类型，如DDoS、恶意软件等。 6. 网络协议和服务： HTTP和HTTPS的区别。DNS的作用和工作原理。DHCP协议的作用和流程。 7. 网络性能和优化： 带宽、延迟和吞吐量的定义。通过子网划分和VLAN提高网络性能的方法。负载均衡的作用和实现方式。 8. 网络管理和监控： SNMP协议的作用。网络监控工具的使用，如Wireshark、Nagios等。日志记录的重要性和用途。 答案：
1. 基础网络概念 IP地址和子网掩码的作用：IP地址用于标识网络中的设备，子网掩码用于划分网络。网络协议的定义和作用：网络协议是规定数据通信规则的约定。OSI模型的七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 2. 网络设备 路由器和交换机的区别：路由器在不同网络之间传递数据，交换机在同一网络内传递数据。集线器（Hub）与交换机（Switch）的对比：Hub将数据广播到所有端口，而Switch根据MAC地址转发数据。网关的作用：在不同网络之间转发数据的设备。 3. 网络连接和拓扑 无线局域网络（WLAN）：使用无线信号进行设备之间的通信。客户端-服务器模型与对等模型：客户端向服务器请求服务，对等模型中设备互为对等。 4. 网络地址与路由 IPv4和IPv6的区别：IPv4使用32位地址，IPv6使用128位地址。子网划分和CIDR表示法：将大网络划分为更小的子网，CIDR用于表示IP地址和子网掩码。静态路由和动态路由：手动配置的路由称为静态路由，动态路由通过路由协议自动学习。 5. 网络安全基础 防火墙：阻止不安全的网络流量。公钥基础设施（PKI）：用于管理加密密钥和数字证书。常见的网络攻击类型：DDoS是通过向目标发送大量流量使其服务不可用，恶意软件包括病毒、蠕虫、木马等。 6. 网络协议和服务 HTTP和HTTPS：HTTP是不安全的，HTTPS通过SSL/TLS加密传输。DNS：将域名解析为IP地址的服务。DHCP协议：自动分配IP地址和其他网络配置。 7. 网络性能和优化 带宽、延迟和吞吐量：带宽是传输速率，延迟是数据传输的时间，吞吐量是单位时间内传输的数据量。子网划分和VLAN：通过合理划分子网和使用虚拟局域网提高网络性能。负载均衡：均匀分配流量以提高性能和可用性。 8. 网络管理和监控 SNMP协议：用于网络设备之间的管理和监控。网络监控工具：Wireshark用于网络分析，Nagios用于监控网络设备。日志记录：记录网络事件和问题，有助于故障排除。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efeeb62cdf5b746f94812f842b72b9d3/" rel="bookmark">
			Android 开发常用命令笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析项目包的依赖关系，并保存到name.txt文件中
gradlew :app:dependencies &gt;name.txt
列出所有的依赖：
gradlew :app:androidDependencies &gt;name.txt
获取手机上当前正在显示的应用的包名及Activity
//正在前台交互的activity-windows
adb shell dumpsys window | findstr “mFocused”
//输出activity栈-MAC
adb shell dumpsys activity top | grep ACTIVITY
// 正在前台交互的activity-MAC
adb shell dumpsys window | grep mCurrentFocus
获取手机分辨率
adb shell wm size
卸载应用
adb uninstall [包名]
获取 cpu 架构，如 arm64-v8a
adb shell getprop ro.product.cpu.abi
查看端口是否被占用
netstat -ano | findstr “8080”
谷歌浏览器截屏方法
F12 -&gt; Ctrl + Shift + P -&gt; 搜 “Capture”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efeeb62cdf5b746f94812f842b72b9d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2bb43ab7d6527a23bfde5681accb0f7/" rel="bookmark">
			git命令及快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git命令 代码仓库类型 Git是一个分布式代码管理工具，与之共存的就是中央式代码管理仓库
中央式：所有的代码保存在中央服务器，所以提交必须依赖网络，并且每次提交都会带入到中央仓库，如果是协同开发可能频繁触发代码合并，进而增加提交的成本和代价。最典型的就是svn
分布式：可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库clone一份到本地，并会把提交历史一并拿过来。代表就是Git
git的优势在于本地回退成本更低，更加优雅，用户可能感知不到,
代码文件状态 修改：Git可以感知到工作目录中哪些文件被修改了，然后把修改的文件加入到modified区域
暂存：通过add命令将工作目录中修改的文件提交到暂存区，等候被commit
提交：将暂存区文件commit至Git目录中永久保存
commit节点 Git中每次提交都会生成一个节点,而每个节点都会有一个哈希值作为唯一标示，多次提交会形成一个线性节点链
C2节点包含C1提交内容,同样C3节点包含C1、C2提交内容
head节点 HEAD是Git中非常重要的一个概念，你可以称它为指针或者引用，它可以指向任意一个节点，并且指向的节点始终为当前工作目录，当前工作目录(也就是你所看到的代码)就是HEAD指向的节点。
HEAD是可以移动的，通过移动HEAD来获取前几次的提交，同时也指向一个分支，间接指向分支所指向的节点。
分支 分支也是Git中相当重要的一个概念，当一个分支指向一个节点时，当前节点的内容即是该分支的内容，不同的是分支可以存在多个，而HEAD只有一个。通常会根据功能或版本建立不同的分支
节点分支都只是指向的概念，轻量级，可以基于某分支拉取新分支，本质上不是拷贝代码，而是新分支指向该节点。同样的变动可以合入多个分支。
命令相关 结合3个区域，git命令大致示意如下：
撤销工作区变动：git checkout – 文件名
清空暂存区: git reset HEAD 文件名
创建分支 git branch
切分支 git checkout 分支名, HEAD间接指向当前分支指向的节点
删除分支 git branch -d 分支名
git merge 分支名/节点哈希值，将某个分支或者某个节点的代码合并至当前分支，同一个类的代码修改后会冲突，merge本质将历史分支悬挂在最新分支里
git rebase 分支名/节点哈希值 合并分支代码
本地推到远程并对应的是同一条分支可以优先考虑rebase
git cherry-pick 节点哈希值 选择某几个节点合并
git checkout 分支名/HEAD^ 分支前一次提交~N前N次
git reset HEAD~N //回退N个提交 ^1是前一个
git pull本质是fetch+merge，首先更新远程仓库所有状态到本地，随后再进行合并。合并完成后本地分支会指向最新节点，也可以通过rebase进行合并git pull --rebase
git revert 恢复文件到上次提交
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2bb43ab7d6527a23bfde5681accb0f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e37991e0b8a19001b89a029f5f4f97/" rel="bookmark">
			postgreSql存储jsonb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postgreSQL 支持 json类型存储
使用异同如下：
1. 字段修改 1.1 修改前 字符串类型
private String files; -- 数据库 files varchar(511), 1.2 修改后 jsonArray 类型
@TableField(typeHandler = JsonArrayTypeHandler.class) private JSONArray files; -- 数据库 files jsonb, 2. 查询修改 2.1 修改前 使用mybatisPlus 默认查询
Map map = new HashMap(CommonConstant.TWO); map.put(CommonConstant.FBR_INFO_ID, fbrInfoId); List&lt;FBRHWInfoEntity&gt; hwList = fbrhwInfoMapper.selectByMap(map); 2.2 修改后 需要自己写查询的mapper方法
List&lt;FBRHWInfoEntity&gt; hwList = fbrhwInfoMapper.getByFbrInfoId(fbrInfoId); mapper中 resultMap 的其余字段不用写
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.xxx.npi.module.fbr.mapper.FBRHWInfoMapper"&gt; &lt;resultMap id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8e37991e0b8a19001b89a029f5f4f97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1768e33600b31b16f23af6b81692b1d/" rel="bookmark">
			windows环境运行datax缺少本地hadoop环境报错：Could not locate executable null\bin\winutils.exe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、完整报错
二、解决
三、临时解决方案
四、其他
一、完整报错 十二月 07, 2023 10:01:05 上午 org.apache.hadoop.util.Shell getWinUtilsPath 严重: Failed to locate the winutils binary in the hadoop binary path java.io.IOException: Could not locate executable null\bin\winutils.exe in the Hadoop binaries. at org.apache.hadoop.util.Shell.getQualifiedBinPath(Shell.java:356) at org.apache.hadoop.util.Shell.getWinUtilsPath(Shell.java:371) at org.apache.hadoop.util.Shell.&lt;clinit&gt;(Shell.java:364) at org.apache.hadoop.util.StringUtils.&lt;clinit&gt;(StringUtils.java:80) at org.apache.hadoop.fs.FileSystem$Cache$Key.&lt;init&gt;(FileSystem.java:2807) at org.apache.hadoop.fs.FileSystem$Cache$Key.&lt;init&gt;(FileSystem.java:2802) at org.apache.hadoop.fs.FileSystem$Cache.get(FileSystem.java:2668) at org.apache.hadoop.fs.FileSystem.get(FileSystem.java:371) at org.apache.hadoop.fs.FileSystem.get(FileSystem.java:170) at com.alibaba.datax.plugin.writer.hdfswriter.HdfsHelper.getFileSystem(HdfsHelper.java:74) at com.alibaba.datax.plugin.writer.hdfswriter.HdfsWriter$Job.init(HdfsWriter.java:49) at com.alibaba.datax.core.job.JobContainer.initJobWriter(JobContainer.java:704) at com.alibaba.datax.core.job.JobContainer.init(JobContainer.java:304) at com.alibaba.datax.core.job.JobContainer.start(JobContainer.java:113) at com.alibaba.datax.core.Engine.start(Engine.java:94) at com.alibaba.datax.core.Engine.entry(Engine.java:176) at com.alibaba.datax.core.Engine.main(Engine.java:246) 十二月 07, 2023 10:01:05 上午 org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1768e33600b31b16f23af6b81692b1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edf905de948264145deec55eff7599d/" rel="bookmark">
			个人总结最详细清晰集合Stream流，Lambda表达式的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Stream&amp;Lambda表达式 为什么使用函数式编程：
因为在大数量下的处理集合效率高，直接使用并行流可以不用自己去创建多线程处理，减少了复杂度
代码的可读性高
减少了代码嵌套
函数式编程思想主要是关注对数据进行了什么操作
1 .Lambda表达式 1.1 概述 是jdk8中的一个语法糖，可以对某些匿名内部类写法进行简化，是函数式编程的重要体现。
1.2核心原则 可推导可省略
1.3基本格式 （参数）-&gt; {代码} 不关注方法名，只关注参数和方法体，所以可以直接将方法体那部分给拷贝过来
只能对函数式接口这么使用，如果接口Interface中需要实现的抽象方法只有一个,这样的接口就是函数式接口.
例子1：
new Thread(new Runnable() { @Override public void run() { System.out.println("方法体"); } }).start(); lambda简化：
new Thread(()-&gt; { System.out.println("方法体");} ).start(); //只关注方法体，所以直接将方法体的参数拿过来就可以使用 例子2：未使用lambda:
public interface TestLambda { &lt;T, V&gt; T method(T a, V b); } int method1(TestLambda&lt;String, Integer&gt; lambda) { System.out.println(lambda.method("2", 3)); return 1; } @Test public void testLambda() { int i = method1( new TestLambda&lt;String, Integer&gt;() { @Override public Integer method(String a, Integer b) { return Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8edf905de948264145deec55eff7599d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa25f38b0b76403057e353278e130aa5/" rel="bookmark">
			C语言判断一个字符串是不是回文字符串案例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先看什么是回文字符串：
思路分析
因为回文字符串正读和反读都是相同的，所以可以推出一个结论：
字符串的的第1个字符和最后一个字符相同，第二个字符和倒数第二个字符相同，依次类推。
我们可以通过判断对应位置上的字符是否全部相同来判断这个字符串是不是回文字符串。
只要有一个对应位置上的字符不相同那么就判断这个字符串不是回文字符串。
以字符串"abvdg"和"level"为例进行代码编写。
案例全部代码如下
#include &lt;stdio.h&gt; #include &lt;string.h&gt; void main(){ char arr[10]; int i,a=0; gets(arr);//从键盘输入字符，给字符数组赋值 a=strlen(arr);//计算字符串长度 for(i=0;i&lt;a;i++){ if(arr[i]==arr[a-1-i]){ a=1;//对应位置上的字符相等就给a赋值为1 } else{ a=0;//对应位置上的字符不相等就给a赋值为0并结束循环 break; } } if(a==1){//对应位置上的字符都相等，a一直都是赋值为1 printf("这个字符串是回文字符串"); } else{ printf("这个字符串不是回文字符串"); } } 上面的代码其实是错误的，在文章发布半年后有小伙伴指出这个错误。千万不要学习上面的代码了，我保留下了纯粹是纪念这个事。
下面是错误原因分析：
我一边把a当计数器用一边接收字符串的长度导致逻辑错误。
char arr[10]; int i,a=0; gets(arr);//从键盘输入字符，给字符数组赋值 a=strlen(arr);//计算字符串长度 把计数器定为int count ＝0就可以修改错误。
以下是修改后的全部代码
#include &lt;stdio.h&gt; #include &lt;string.h&gt; void main(){ char arr[10]; int i,a=0; int count=0; gets(arr);//从键盘输入字符，给字符数组赋值 a=strlen(arr);//计算字符串长度 for(i=0;i&lt;a;i++){ if(arr[i]==arr[a-1-i]){ count=1; //对应位置上的字符相等就给a赋值为1 } else{ count=0;//对应位置上的字符不相等就给a赋值为0并结束循环 break; } } if(count==1){//对应位置上的字符都相等，a一直都是赋值为1 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa25f38b0b76403057e353278e130aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ab078f1ba96a738617f30481663a0f/" rel="bookmark">
			毕业设计-基于深度学习的行人车辆闯红灯实时检测算法系统 YOLO python 卷积神经网络 人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计思路
一、课题背景与意义
二、算法理论原理
2.1 YOLOv5算法
2.2 DeepSort算法
三、闯红灯检测的实现
3.1 数据集
3.2 实验环境搭建
3.2 实验及结果分析
实现效果图样例
最后
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导:
最新最全计算机专业毕设选题精选推荐汇总
设计思路 一、课题背景与意义 以图像或视频为研究对象，通过图像处理技术识别出道路情况，不仅要检测出汽车、行人等目标，还要判断出交通信号。而根据这项技术，通过提醒行人和车辆不要违反交通规则可以解决交通安全全世界死亡率排名前列的问题。
二、算法理论原理 2.1 YOLOv5算法 YOLO算法用回归方法对目标进行检测，有着快速检测的能力。YOLOv5分为四个部分，分别为input端，backbone端，neck端，prediction端四个部分。
YOLOv5在目标检测方面有着优秀的性能，其主要原因如下：
(1) Input端包括Mosaic数据增强，新增了图片尺寸处理、自适应锚框计算三部分，增强小目标检测性能，加快图片处理速率。
(2) Backbone新增了Focus结构并且改进了CSP结构，Focus结构减少了冗余信。CSP1用于特征提取部分，CSP2用于特征融合部分。
(3) Neck包括FPN+PAN的结构，加强网络特征融合的能力。
(4) Output端包括GIOU_Loss作为损失函数，新增了GIOU_NMS非极大值抑制。最小化预测框和目标框之间的归一化距离，增强了遮挡重叠的目标的识别率。
2.2 DeepSort算法 DeepSort是由sort升级而来。当物体发生遮挡的时候，使用sort算法容易丢失自己的ID，而新增的Deep Association Metric把轨迹分为确认态和不确认态，新产生的轨迹是不确认态的，不确认态的轨迹必须要和目标连续匹配多次（默认3次）才可以转化成确认态。确认态的轨迹必须和目标连续不匹配多次（默认30次），才可剔除ID。
相关代码示例：
import torch import torch.nn as nn class YOLO(nn.Module): def __init__(self, num_classes, num_anchors): super(YOLO, self).__init__() self.num_classes = num_classes self.num_anchors = num_anchors # Define your network architecture here self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ab078f1ba96a738617f30481663a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2956eff3f8209e82d0de7c589da1ac6/" rel="bookmark">
			TikTok API接口，博主视频列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
声明
目标
1、博主视频列表
2、参数解析：
3、返回结果
声明 本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关！
本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，若有侵权，请联系作者立即删除！
目标 目标：博主视频列表
网址：aHR0cHM6Ly93d3cudGlrdG9rLmNvbS9AZ3JlZW5tYXNrX3NlY3JldA==
1、博主视频列表 最近TT的风控好严重，比较难搞
import requests from loguru import logger url = 'http://地址/tt/earch_data_videos' data = { "token": "h", "keyword": "Pet Cat", "cursor":0, "count":20, "region": "US", "language":"en", } r = requests.get(url, params=data).json() 2、参数解析： 参数名必选类型说明tokenYString接口码keywordYString 搜索关键词
cursorYint翻页游标，根据结果返回的cursor传入做为翻页参数，默认为0count Yint 返回总数，默认为20
regionYString默认USlanguageYString默认en 3、返回结果 总结 1、出于安全考虑,本章未提供完整流程,调试环节省略较多,只提供大致思路,具体细节要你自己还原,相信你也能调试出来.
2、本人写作水平有限,如有讲解不到位或者讲解错误的地方,还请各位大佬在评论区多多指教,共同进步
3、如果这篇文章对你有帮助，就点赞、关注、收藏、三连击一下
4、本篇分享到这里就结束了，欢迎大家关注下期，我们不见不散☀️☀️😊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b5d2573e12310f2c771df0a4345a1f/" rel="bookmark">
			STM32CubeMX 按键控制LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、STM32知识要点
二、STM32CubeMX配置
1.引脚配置，将PB6设置为GPIO_Input ,PC13配置为GPIO_Output​编辑
2.然后点project manager进行下面两项配置
3.成功生成代码后直接打开工程文件 三、keil代码配置
1.GPIO电平输出函数
2.GPIO电平翻转函数
3.GPIO输入判定函数
4.将新生成的工程先编译,可以看到没有错误
5.通过按键，电平翻转方式实现led开关
6.点击LOAD下载，下载成功后可以看到单片机按键按下 LED开，再次按下关
一、STM32知识要点 GPIO：General Purpose Input &amp; Output
STM32的I/O端口可以由软件配置成8种模式：
1、推挽输出 5、模拟输入
2、开漏输出 6、浮空输入
3、推挽式复用功能 7、下拉输入
4、开漏式复用功能 8、上拉输入
二、STM32CubeMX配置 1.引脚配置，将PB6设置为GPIO_Input ,PC13配置为GPIO_Output
将PB6配置上拉
pc13输出高电平
2.然后点project manager进行下面两项配置 3.成功生成代码后直接打开工程文件 三、keil代码配置 1.GPIO电平输出函数 PC13引脚输出低电平点亮LED
HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_RESET); PC13引脚输出高电平
HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_SET); 2.GPIO电平翻转函数
HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13); 3.GPIO输入判定函数 if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_6)==GPIO_PIN_RESET) { HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13); } 4.将新生成的工程先编译,可以看到没有错误 5.通过按键，电平翻转方式实现led开关 6.点击LOAD下载，下载成功后可以看到单片机按键按下 LED开，再次按下关 链接:https://pan.baidu.com/s/1iZf8z1HFVra4sMWwhcMxMQ 密码:v3io
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/34/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>