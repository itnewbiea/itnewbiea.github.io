<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151326958174ba26f363e362741d6f9a/" rel="bookmark">
			ctfshow web入门174
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目给出了查询语句和返回逻辑
先看查询语句
$sql = "select username,password from ctfshow_user4 where username !='flag' and id = '".$_GET['id']."' limit 1;"; 这里能直接看出来是使用单引号进行绕过
是一个字符型注入
继续，查看返回逻辑
if(!preg_match('/flag|[0-9]/i', json_encode($ret))){ $ret['msg']='查询成功'; } 这里如果返回数据中包含 `flag` 字样，或者包含数字0-9，则不会输出
这里的话有两种方法，第一种方法是盲注
这里不作介绍
这里介绍第二种更为取巧的方式
做字符替换
我们已知 flag 中只包含16进制数
也就是0-9 a-f
那么我们可以将 0替换为g
0-&gt;g
1-&gt;h
...
以此类推
好的，那么按照这个思路，要么写个脚本生成payload
要么自己一点一点手写
这里给出脚本
i = 0 s = f"replace(password,{i},'{chr(ord(str(i)) + 55)}')" for i in range(1,10): s = f"replace({s},{i},'{chr(ord(str(i)) + 55)}')" print(s) 如果需要脚本思路的话可以留言
我就再写一篇分享思路的
上面的代码需要python版本3.6以上
这种格式写起来代码运行效率高且看起来容易
这里再给一段低版本的代码
s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151326958174ba26f363e362741d6f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fe1de0cd0dda84b13bb69b61563b24/" rel="bookmark">
			初学者编写python用什么软件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者编写python用什么软件
以下是常用的几款Python代码编辑器和Python集成开发工具。
一、Python代码编辑器
1. Sublime Text
Sublime Text是一款非常流行的代码编辑器，支持Python代码编辑，同时兼容所有平台，并且丰富的插件扩展了语法和编辑功能，迅捷小巧，具有良好的兼容性，很受编程人士的喜爱！
2. Vim
Vim和Vi是一种模型编辑器，它将文本查看从文本编辑中分离，VIM在原始VI之上做了诸多改进，包括可扩展模型和就地代码构建，VIMScripts可用于各种Python开发任务！
3. Visual Studio Code
Visual Studio Code是一款兼容Linux、Mac OS X和Windows 平台的全功能代码编辑器，可扩展并且可以对几乎所有任务进行配置，对于Python的支持可以在Visual Studio Code中安装插件，只需快速点击按钮即可成功安装，且可自动识别Python安装和库。
二、Python集成开发环境
1. PyCharm
PyCharm是唯一一款专门面向Python的全功能集成开发环境，同样拥有付费版和免费开源版，PyCharm不论是在Windows、 Mac OS X系统中，还是在Linux系统中都支持快速安装和使用。
PyCharm直接支持Python开发环境，打开一个新的文件然后就可以开始编写代码，也可以在PyCharm中直接运行和调试Python程序，它还支持源码管理和项目，并且其拥有众多便利和支持社区，能够快速掌握学习使用！
2. Spyder
Spyder是一款为了数据科学工作流做了优化的开源Python集成开发环境，它是附在Anaconda软件包管理器发行版中的，Spyder拥有大部分集成开发环境该具备的功能，如强大语法高亮功能的代码编辑器、Python代码补全以及集成文件浏览器，其还具有其他Python编辑环境中所不具备的变量浏览器功能，十分适合使用Python的数据科学家们。
3. Thonny
Thonny是针对新手的一款集成开发环境，适用于全部主流平台，默认情况下，Thonny会和自带捆绑的Python版本一起安装，十分方便新手使用！
如果需要PyCharm安装包+激活码+python全套学习资料，可以微信扫码下方二维码免费领取
零基础Python学习资源介绍 一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python学习软件 工欲善其事，必先利其器。学习Python常用的开发软件都在这里了！
三、Python入门学习视频 还有很多适合0基础入门的学习视频，有了这些视频，轻轻松松上手Python~
四、Python练习题 每节视频课后，都有对应的练习题哦，可以检验学习成果哈哈！
五、Python实战案例 光学理论是没用的，要学会跟着一起敲代码，动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。这份资料也包含在内的哈~
六、Python面试资料 我们学会了Python之后，有了技能就可以出去找工作啦！下面这些面试题是都来自阿里、腾讯、字节等一线互联网大厂，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
七、资料领取 上述完整版Python全套学习资料已经上传CSDN官方，需要的小伙伴可自行微信扫描下方CSDN官方认证二维码输入“领取资料”免费领取！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e012e68e3381c53f08abb6f66107c1/" rel="bookmark">
			基于python的图形化抓包工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 导入相关模块 import tkinter as tk from tkinter import scrolledtext import threading # 导入多线程模块 from scapy.all import * # 导入scapy模块 # 创建一个图形化界面，用于显示抓包结果 root = tk.Tk() #实例化对象，建立窗口 root.title('Python抓包系统') root.geometry('800x600') # 创建一个标签，用于显示过滤条件 filter_label = tk.Label(root, text='过滤条件：') filter_label.grid(row=0, column=0, sticky='w') # 创建一个输入框，用于输入过滤条件 filter_entry = tk.Entry(root) filter_entry.grid(row=0, column=1, sticky='ew') # 创建一个按钮，用于开始抓包 start_button = tk.Button(root, text='开始') start_button.grid(row=0, column=2, sticky='e') # 创建一个按钮，用于停止抓包 stop_button = tk.Button(root, text='停止') stop_button.grid(row=0, column=3, sticky='e') # 创建一个滚动文本框，用于显示抓包结果 result_text = scrolledtext.ScrolledText(root) result_text.grid(row=1, column=0, columnspan=4, sticky='nsew') # 定义一个变量，用于控制抓包状态 running = False # 定义一个函数，用于分析和显示数据包 def parse_packet(packet): # 显示数据包的摘要信息 result_text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e012e68e3381c53f08abb6f66107c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64cfb4dabe428499b88899e83d7e9f1e/" rel="bookmark">
			【PHP&#43;微信开发】启用服务器配置提交token验证失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		URL写到验证函数为止(www.abc.com/index/index/checkToken)，token随便写，EncodingAESKey自动生成，加密方式明文模式。
把下面的php代码放到配置的域名服务器上，提交即可。
php验证代码
public function checkToken() { header("Content-type: text/html; charset=utf-8"); //1.将timestamp,nonce,toke按字典顺序排序 $timestamp = $_GET['timestamp']; $nonce = $_GET['nonce']; $token = '******'; $signature = $_GET['signature']; $array = array($timestamp,$nonce,$token); //2.将排序后的三个参数拼接之后用sha1加密 $tmpstr = implode('',$array); $tmpstr = sha1($tmpstr); //3.将加密后的字符串与signature进行对比，判断该请求是否来自微信 if($tmpstr == $signature){ echo $_GET['echostr']; exit; } } 注意：如果配置都是正确的，但是一直就是token验证失败，可能是因为编码问题，加上“header("Content-type: text/html; charset=utf-8");”即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803d8b910c61d6578fefa253ea0adeb6/" rel="bookmark">
			在linux里面把一个在前台运行的命令转为后台运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux操作系统 可以通过使用 Ctrl + Z 快捷键将一个正在前台运行的命令暂停，并使其转为后台运行。然后，可以使用 bg 命令将它转移到后台。
以下是在 Linux 中将正在前台运行的命令转移到后台的步骤：
1.使用 Ctrl + Z 快捷键暂停当前正在前台运行的命令。
2.使用 jobs 命令查看当前正在执行的作业列表。
3.使用 bg 命令将前台作业转移到后台。
例如，假设您正在前台运行一个名为 sleep 的命令。执行以下步骤将其转移到后台：
1.按下 Ctrl + Z 暂停当前运行的 sleep 命令。
2.执行 jobs 命令，查看处于后台状态的作业。
$ jobs [1]+ Stopped sleep 60 3.使用 bg 命令将 sleep 命令转移到后台运行。
$ bg %1 [1]+ sleep 60 &amp; 现在，sleep 命令将在后台继续运行。您可以执行其他命令，而无需等待该命令完成。您可以随时使用 fg 命令将作业切换回前台运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daefaafd414b45b6402892fb4da892cb/" rel="bookmark">
			Docker中仓库、镜像和容器用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、仓库、镜像和容器之间的关系 2、Docker镜像 当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载，如果不指定版本，默认下载最新的版本。也可以通过配置，使用自定义的镜像仓库。
2.1 查看镜像信息 2.1.1　使用images命令列出镜像 使用 docker images 或者 docker image ls来列出本地主机上的镜像：
docker images docker image ls 选项说明：
REPOSITORY：表示镜像的仓库源TAG：镜像的标签, 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本IMAGE ID：镜像ID，它唯一的标识了镜像。在使用id时，可以使用该id的前若干个字符组成的可区分串来代替完整的ID。CREATED：镜像创建时间，说明镜像的最后更新时间。SIZE：镜像大小 2.1.2 使用tag命令添加镜像标签 使用docker tag命令为本地镜像任意添加新的标签。当TAG为&lt;none&gt;时，直接为该镜像打上标签，若TAG不为&lt;none&gt;时，此时操作相当于复制链接一份。
如：添加一个新的myubuntu:latest镜像：
docker tag ubuntu:18.04 myubuntu:latest 注意：可以注意到ID的相同的，docker tag命令添加的标签实际上起到了类似链接的作用。
如TAG为&lt;none&gt;时：
docker tag d1165f221234 hello-world:old_image 注意：此时直接为该镜像打上了标签。
2.1.3 使用inspect命令查看详细信息 docker inspect ubuntu:18.04 执行结果：
[root@dgw-machine ~]# docker inspect ubuntu:18.04 [ { "Id": "sha256:3941d3b032a8168d53508410a67baad120a563df67a7959565a30a1cb2114731", "RepoTags": [ "myubuntu:latest", "ubuntu:18.04" ], "RepoDigests": [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daefaafd414b45b6402892fb4da892cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b351a4585810d6d2e897a4cef24b25/" rel="bookmark">
			IGMP协议基础，组播配置和过程解析（华为）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IGMP协议基础，组播配置和过程解析（华为） 预备知识：知道什么是组播。会配OSPF，会看Wireshark工具
新概念： IGMP简介： 网路群组管理协议（Internet Group Management Protocol或简写IGMP)是用于管理网路协议多播组成员的一种通信协议
D类地址：（224.0.0.1~239.255.255.254）
224.0.0.0～224.0.0.255 永久组地址（保留组地址）
224.0.0.1：发给网段内所有主机，（可以说是组播里的广播）224.0.1.0～231.255.255.255233.0.0.0～238.255.255.255 ASM组播地址，全网范围内有效。232.0.0.0～232.255.255.255 缺省情况下的SSM组播地址，全网范围内有效。239.0.0.0～239.255.255.255 本地管理组地址，仅在本地管理域内有效。在不同的管理域内重复使用相同的本地管理组地址不会导致冲突。（类似C类地址的192.168.1.0，不上公网） 查询器： 负责发送查询报文，并接收主机反馈的加入报文和离开报文，通常是某个接口
IGMP报文格式: 普遍组查询报文（General Query）:组播查询网络上所有主机，路由器，用于了解哪些组播组存在成员。成员报告报文（Report）：主机向查询器发送报告，申请加组或应答成员离开报文（Leave）：成员离开组播组时主动向查询器发送的报文，宣告自己离开了某个组播组。 IGMPv1:
IGMPv2:
从报文看到v2版本去掉的版本号。添加了一个最大响应时间，即可以自定义最大响应时间，默认10秒，单位改为0.1秒。添加了一条指定组查询，在查询时不用发给所有组。添加一条离开组消息，成员离开组时主动发送。v2增加了查询器选举（v1最大响应时间10秒，单位1秒，查询器选举用的pim协议） IGMPv3：
该版本添加了指定组播源和组播组的功能，由于v3版本出现不产品会出现不兼容问题。所以并并不广泛应用。主流还是v2版本
以v2版本介绍运行过程 加入组： 在该局域网中，路由器每60秒发送一次查询报文，其他PC收到查询报文后会触发抑制响应机制，然后发送报告到该组，路由器收到后就知道组里有成员，从组播源接收组播消息，下发。（PC可以主动申请加组）
抑制响应机制: 路由器（查询器）并不关心组内成员的数量，只要有成员就行。所以并不需要所有PC都发送报告。在每一个PC收到查询报文后会进行计时（时间是查询报文中的最大响应时间里取随机数），计时结束后发送报告到该组，其他PC收到报告后就不发送报告了查询器也就收了一份报告，省带宽
PC离组： PC主动发送离组报告，路由器（查询器）接收后会连续发送两个查询报文，确认是否还有PC在组内，这两个报文最大响应时间都是1秒，若没收到报告就关闭该组的组播发送（在思科的设备中是只发一个查询，时间2秒）
实验环节： 实验环境： windows10, eNSP 4.0.1 + VLC 3.0.18
命令： multicast routing-enable	//开启组播功能(全局模式) pim dm	//开启pim协议的dm模式（接口模式） igmp enable	//开启igmp协议功能在这里插入代码片（接口模式） igmp version 2	//选择版本（接口模式） 拓扑结构以下，PC，路由器，组播源均配置完ip，路由，全网可通（使用OSPF）
1. 组播源配置
打开设置把vlc.exe路径给上去，(没装VLC的话去官网下载安装https://www.videolan.org/vlc/)
配置组播源： 给个组播组地址，再给要播放的视频，运行后能弹出播放窗口并且播放就🆗啦
2. 路由器端配置：（注意当前接口位置）
[R3]multicast routing-enable	//开启组播功能 [R3-GigabitEthernet0/0/3]pim dm	//开启pim协议的dm模式 [R3-GigabitEthernet0/0/3]igmp enable	//开启igmp协议功能 [R3-GigabitEthernet0/0/3]igmp version 2	//选择版本 [R3-GigabitEthernet0/0/3]int gi0/0/2 [R3-GigabitEthernet0/0/2]pim dm [R2]multicast routing-enable [R2-GigabitEthernet0/0/2]pim dm [R2-GigabitEthernet0/0/1]pim dm [R1]multicast routing-enable [R1-GigabitEthernet0/0/1]pim dm [R1-GigabitEthernet0/0/1]igmp enable [R1-GigabitEthernet0/0/1]igmp version 2 [R1-GigabitEthernet0/0/2]pim dm [R1-GigabitEthernet0/0/2]igmp enable [R1-GigabitEthernet0/0/2]igmp version 2 [R1-GigabitEthernet0/0/3]pim dm [R1-GigabitEthernet0/0/3]igmp enable [R1-GigabitEthernet0/0/3]igmp version 2 [R1]interface Ethernet0/0/1 [R1-Ethernet0/0/1]pim dm 总的来说就是路由器开启组播功能，接口开启pim协议，又接到成员的接口还要开启IGMP并选择版本 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b351a4585810d6d2e897a4cef24b25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64bcc2086b4ff69bd947b3451d09cd88/" rel="bookmark">
			log4cpp的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		log4cpp的使用逻辑构造基本模板布局的格式化目的地对象操作文件回卷文件 log4cpp的使用 逻辑构造 目的地Appender：用于表示日志系统最后输出到哪
布局Layout：表示你输出的格式，类似与printf
优先级Priority：常见的优先级有emerg，alert，crit，error，warn，notice，info，debug，优先级从高到低排列，优先级主要针对不同用户设定，如果一个用户设定的优先级是warn，那么notice，info，debug的信息就会忽略掉不输出
日志Category：是整个日志系统的主干，目的地的设定添加和模板设置，日志记录都由Category完成
一个目的地只能有一个布局，一个布局对应一个目的地
基本模板 #include &lt;iostream&gt; #include &lt;log4cpp/OstreamAppender.hh&gt; #include &lt;log4cpp/Appender.hh&gt; #include &lt;log4cpp/BasicLayout.hh&gt; #include &lt;log4cpp/Category.hh&gt; #include &lt;log4cpp/Priority.hh&gt; using std::cout; using namespace log4cpp; void test0() { //设置目的地对象 //参数1 目的地的名字 console代表控制台， //参数2 流对象 OstreamAppender* posAp = new OstreamAppender("console", &amp;cout); //设置目的地布局 BasicLayout函数是创建布局对象 posAp-&gt;setLayout(new BasicLayout()); //创建日志对象，getRoot函数返回的是创建的日志对象，用引用符号接取 Category&amp; root = Category::getRoot(); //设置日志的目的地 root.setAppender(posAp); //设置日志的优先级 root.setPriority(Priority::DEBUG); //设置模板 Category&amp; model1 = root.getInstance("register"); //打印日志记录 root.emerg("this is an emrge"); root.alert("this is an alert"); root.crit("this is a critical"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64bcc2086b4ff69bd947b3451d09cd88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7966ecafd8785c591fa79419fe372c6e/" rel="bookmark">
			java 微信公众号服务器配置token验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq_27185879/article/details/125673815
公众号配置
URL：填写外网可以访问的域名
Token：填写的值要与代码中的一致
依赖：sha1 加密 &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;/dependency&gt; 验证接口（get请求） import static cn.hutool.crypto.SecureUtil.sha1; @RequestMapping("/checkSign") public void wechatCheckSign(HttpServletRequest request, HttpServletResponse response) throws IOException { String token = "slj_weixin_token"; //填写自己在微信公众平台中设置的token // 微信加密签名 String signature = request.getParameter("signature"); // 随机字符串 String echostr = request.getParameter("echostr"); // 时间戳 String timestamp = request.getParameter("timestamp"); // 随机数 String nonce = request.getParameter("nonce"); String[] str = { token, timestamp, nonce }; // 字典排序 Arrays.sort(str); String bigStr = str[0] + str[1] + str[2]; // SHA1加密 String digest = sha1(bigStr); // 确认请求来至微信 if (digest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7966ecafd8785c591fa79419fe372c6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afca91e6f34e9d9feb734e2ed3bb7d3/" rel="bookmark">
			＜ 开源项目框架：推荐几个开箱即用的开源管理系统 - 让开发不再复杂 ＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 👉 SCUI Admin 中后台前端解决方案👉 Vue + .NetCore 前后端分离的快速发开框架👉 next-admin 适配移动端、pc的后台模板👉 django-vue-admin-pro 快速开发平台👉 Admin.NET 通用管理平台👉 RuoYi 若依权限管理系统👉 Geeker Admin - Vue3.2 + Element-Plus 后台管理框架👉 Pig RABC权限管理系统👉 zheng 分布式敏捷开发系统架构👉 Guns 快速开发平台👉 D2Admin 企业中后台产品前端集成方案👉 eladmin 后台管理系统👉 Vben-Admin 中大型项目后台解决方案往期内容 💨 👉 SCUI Admin 中后台前端解决方案 SCUI 是一个中后台前端解决方案，基于 Vue3 和 elementPlus 实现。使用最新的前端技术栈，提供各类实用的组件方便在业务开发时的调用，并且持续性的提供丰富的业务模板帮助你快速搭建企业级中后台前端任务。
项目地址：https://gitee.com/lolicode/scui
👉 Vue + .NetCore 前后端分离的快速发开框架 框架内置了大量的通用组件可直接使用,并内置了基于本框架定制开发的代码生成器，尽量避免重复性代码编写。支持前端、后台自定义业务代码扩展,后台提供了大量常用扩展与通用类；前端、后台提供了近300个扩展方法与属性,开发人员可在此功能上编写扩展自定义业务代码。
项目地址：https://gitee.com/x_discoverer/Vue.NetCore
👉 next-admin 适配移动端、pc的后台模板 基于 Vue3.x + CompositionAPI + typescript + vite + element plus + vue-router-next + next.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0afca91e6f34e9d9feb734e2ed3bb7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fce3f4b8e6ed5f30e33b710980cd07/" rel="bookmark">
			将本地jar包上传到私服
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ### 本地jar上传本地maven mvn install:install-file -Dfile=E:/IdeaProjects/kingbase8-8.6.0.jar -DgroupId=com.kingbase8 -DartifactId=kingbase8 -Dversion=8.6.0 -Dpackaging=jar ### 本地jar上传私服 mvn deploy:deploy-file -Dmaven.test.skip=true -DgroupId=com.kingbase8 -DartifactId=kingbase8 -Dversion=8.6.0 -Dpackaging=jar -Dfile=E:/IdeaProjects/kingbase8-8.6.0.jar -Durl=http://192.168.1.70:8081/repository/maven-releases/ -DrepositoryId=nexus-releases 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ab12aac6680ee3b26f37a2529d5077/" rel="bookmark">
			【WEB逆向】关于tiktok参数msToken，X-Bogus，_signature生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
tiktok逆向
算法介绍
算法生成研究
代码跟踪
代码编写
开发者测试
tiktok的基本接口​编辑
评论截图
tiktok逆向 本文只是技术探讨，如果对tiktok造成影响请告知，本人及时删除。在线联系VV:HH19991111LV
从视频主页开始查找标题，如图下:
会发现加密参数的msToken，X-Bogus，_signature这个三个
以下开始算法研究
算法介绍 根据js代码抽取和去除花指令需要大量时间，以及绕过检测，
本编文件根本写不完。所以这里简单讲解一下算法生成过程，
tiktok的此次算法生成是使用JSVMP虚拟机模式，
膨胀了大量代码，校验是否为浏览器环境，其中检测了document,window,location,navigator.cavas,symbol,tostring.html，body,script,prototype等等，
算法生成研究 msToken，X-Bogus，_signature是jsVmp生成。
参数必选备注msTokentrue非对称算法生成，和_signature参数相辅相成X-Bogusfalse发现了cookie参与了运算，但是发空值，服务器并未进行检验，后期算法更新估计就会更新这一块，_signaturetrue检验是否浏览器环境，如果非浏览器生成的算法则发包报错，其中关键点，_signature生成的时候，浏览器环境user-agent参与运算。 代码跟踪 代码太多贴入js文件。
window.byted_acrawler.init({ aid: 1988, dfp: !1, boe: !1, intercept: !0, enablePathList: ["/*"], region: "va-tiktok", mode: 513, isSDK: false }); //加上下面js //https://sf16-secsdk.ttwstatic.com/obj/rc-web-sdk-gcs/webmssdk/1.0.0.195/webmssdk.js 代码编写 var p = new XMLHttpRequest; p.open("GET", 'https://www.tiktok.com/api/comment/publish/?aid=1988&amp;app_language=zh-Hant-TW&amp;app_name=tiktok_web&amp;aweme_id=7034791620910451970&amp;battery_info=0.97&amp;browser_language=zh-CN&amp;browser_name=Mozilla&amp;browser_online=true&amp;browser_platform=Win32&amp;browser_version=5.0%20%28Windows%20NT%2010.0%3B%20Win64%3B%20x64%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F94.0.4606.81%20Safari%2F537.36&amp;channel=tiktok_web&amp;cookie_enabled=true&amp;device_id=7062797146567869953&amp;device_platform=web_pc&amp;focus_state=true&amp;from_page=video&amp;history_len=6&amp;is_fullscreen=false&amp;is_page_visible=true&amp;os=windows&amp;priority_region=US&amp;referer=https%3A%2F%2Fwww.tiktok.com%2F&amp;region=JP&amp;root_referer=https%3A%2F%2Fwww.tiktok.com%2F&amp;screen_height=823&amp;screen_width=1463&amp;text=123&amp;text_extra=%5B%5D&amp;tz_name=Asia%2FShanghai&amp;verifyFp=verify_kzfyihmc_9MFy9BZO_vzrg_4eUB_BTQG_EeTWUe5uPwoi&amp;webcast_language=zh-Hant-TW', !0); p.timeout = 60000; p.setRequestHeader("Accept", "application/json, text/plain, */*"); p.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"); p.setRequestHeader("x-tt-passport-csrf-token", "89fedbd4e9c37c1d3d7af4c84664cb7f"); var result = p.send(); 开发者测试 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ab12aac6680ee3b26f37a2529d5077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77fc3364d0b12158444c1671368ee1f8/" rel="bookmark">
			SpringBoot开发实用篇2---与数据层技术有关的替换和整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四、数据层解决方案 1.SQL 现有数据层解决方案技术选型：Druid+MyBatis-plus+MySQL
数据源：DruidDataSource
持久化技术：MyBatis-plus/MyBatis
数据库：MySql
内置数据源：
SpringBoot提供了3种内嵌的数据源对象供开发者选择：
HikariCP：默认内置数据源对象；
Tomcat提供DataSource：HikariCP不可用的情况下，且在web环境中，将使用tomcat服务器配置的数据源对象；
Commons DBCP：Hikari不可用，tomcat数据源也不可用，将使用dbcp数据源。
使用方式：先使用默认配置，再使用个性化配置。
通用配置无法设置具体的数据源配置信息，仅提供基本的连接相关配置，如需配置，在下一级配置中设置具体设定。
JdbcTemplate：Spring提供的默认的持久化技术（几乎没人用）
操作数据库的模板技术。
pom.xml：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; @Autowired private JdbcTemplate jdbcTemplate; @Test void testJdbcTemplate(){ String sql="select * from tbl_book"; RowMapper&lt;Book&gt; rm=new RowMapper&lt;Book&gt;() { @Override public Book mapRow(ResultSet rs, int rowNum) throws SQLException { Book temp=new Book(); //查出来的放到结果集中，从结果集中得到，在set到对象中 temp.setId(rs.getInt("id")); temp.setName(rs.getString("name")); temp.setType(rs.getString("type")); temp.setDescription(rs.getString("description")); return temp; } }; List&lt;Book&gt; list = jdbcTemplate.query(sql, rm); System.out.println(list); } @Test void testJdbcTemplateSave(){ String sql="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77fc3364d0b12158444c1671368ee1f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887851c4f7799ff0cb4c13dff8485c1d/" rel="bookmark">
			kkfileview在线预览文件实现 Windows Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 kkfileview介绍 网页端不想下载文件，而是想在线打开文件预览，比如：txt、doc、docx、pdf、xml、xls、xlsx、ppt、pptx、zip、png、jpg等等。这个时候 kkFileView 的出现就解决了我们的问题。
kkFileView 为文件文档在线预览解决方案，该项目使用流行的spring boot搭建，易上手和部署，基本支持主流办公文档的在线预览，如doc,docx,xls,xlsx,ppt,pptx,pdf,txt,zip,rar,图片,视频,音频等等。
kkfileview 官网
kkfileview 码云地址
kkfileview gitHub地址
2 kkfileview安装 首先，下载代码到本地
idea开发工具打开，clean，install
2.1 Windows环境 2.1.1 启动 install执行成功后，找到target文件夹下的kkFileView-x.x.x.zip压缩包，进行解压缩。进入 bin 目录，双击 startup.bat 启动 kkFileView。
2.1.2 访问检查 进入 log 目录查看 kkFileView.log 日志，打印【kkFileView 服务启动完成，耗时:26.8350973s，演示页请访问: http://127.0.0.1:8012 】则说明启动成功。
这时可以访问http://localhost:8012/index，看到以下页面说明部署成功。
2.1.3 Windows另一种部署方式 截止2.1.2步骤Windows环境已经部署完成。如果是部署本地测试环境的话，还可以直接如下图运行服务，效果和上一种方法是相同的。
2.2 Linux环境 如果搭建测试环境，可以用VMware创建一个虚拟机
2.2.1 上传压缩包 root用户下将 kkFileView-4.2.1.tar.gz 上传到服务器 ，使用命令 tar -zxvf kkFileView-4.2.1.tar.gz 解压。
2.2.2 开放 8012 端口 1.查看防火墙状态：systemctl status firewalld 或 firewall-cmd --state
2.若防火墙未开启，则需要开启防火墙：systemctl start firewalld.service
3.查看开放端口列表firewall-cmd --list-ports
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887851c4f7799ff0cb4c13dff8485c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9246f3f44809f8502859c9f4b6120d7/" rel="bookmark">
			docker 配置本地仓库才能拉取仓库镜像&amp;目录挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、编辑daemon vim /etc/docker/daemon.json
{ "insecure-registries": ["192.168.160.70:5000"] } 重启docker服务 systemctl restart docker.service
docker目录挂载 -v=源文件地址：目的地址
-v/–volume 含义一致
rw 读写权限 ro 只读 默认读写权限
demo:
docker run --name=myName --volume="源文件:镜像中文件地址:ro" hostname="myHostName" 镜像名称 通过 dokcer inspect CONTAINER ID 命令进行查看挂载情况 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e40ba266cd90cdf5c916388a5115843/" rel="bookmark">
			【arxiv】论文找 idea ： 关于 OVD 的论文扫读（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、DetCLIPv2: Scalable Open-Vocabulary Object Detection Pre-training via Word-Region Alignment二、Prompt-Guided Transformers for End-to-End Open-Vocabulary Object Detection三、Bridging the Gap between Object and Image-level Representations for Open-Vocabulary Detection四、P3OVD: Fine-grained Visual-Text Prompt-Driven Self-Training for Open-Vocabulary Object Detectio五、Open Vocabulary Object Detection with Proposal Mining and Prediction Equalization六、Open Vocabulary Object Detection with Pseudo Bounding-Box Labels 一、DetCLIPv2: Scalable Open-Vocabulary Object Detection Pre-training via Word-Region Alignment 论文地址：
https://arxiv.org/pdf/2304.04514.pdf 本文介绍了DetCLIPv2，这是一个高效且可扩展的训练框架，结合大规模的图像-文本对来实现开放词汇的目标检测（OVD）。
与先前通常依赖于预训练的视觉-语言模型（例如CLIP）或通过伪标签过程利用图像-文本对的OVD框架不同，DetCLIPv2以端到端的方式直接学习来自大规模图像-文本对的细粒度词-区域对齐。
为了实现这一目标，我们采用区域建议和文本词之间的最大词-区域相似度来引导对比目标。为了在学习广泛概念的同时使模型具备定位能力，DetCLIPv2使用检测、定位和图像-文本对数据的混合监督，在统一的数据形式下进行训练。通过联合训练和采用低分辨率输入的图像-文本对，DetCLIPv2能够高效有效地利用图像-文本对数据：与DetCLIP相比，DetCLIPv2利用了13倍的图像-文本对，但训练时间相似，并且改善了性能。在预训练过程中使用了1300万个图像-文本对，DetCLIPv2展示了卓越的开放词汇检测性能，例如，DetCLIPv2在LVIS基准测试中使用Swin-T骨干网络实现了40.4%的零样本平均精度（AP），超过了之前的工作GLIP/GLIPv2/DetCLIP分别达到的14.4/11.4/4.5% AP，甚至大幅度超过了其全监督对应物。
我们在训练中使用了来自不同来源的多个数据集（表1）。具体而言，对于检测数据，我们使用了来自Objects365v2 数据集的一个采样子集（表示为O365），其中包含了66万张图像；对于grounding数据，我们使用了GoldG 数据集，其中移除了COCO 图像，这样可以在LVIS 上进行更公平的零样本评估。对于图像-文本配对数据，我们使用了两个版本的Conceptual Captions (CC)数据集，即CC3M 和CC12M（合称为CC15M）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e40ba266cd90cdf5c916388a5115843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc9c1a233bb61d173d3e383f1a44397/" rel="bookmark">
			Prometheus安装、配置、维护及日常使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Prometheus快速部署 1、服务器信息
Linux操作系统版本：CentOS Linux release 7.5.1804（Core）x86_64。
主机IP地址：172.16.60.63。
Prometheus选择下载版本：prometheus-2.44.0.linux-amd64.tar.gz。
2、软件下载
在官方网站下载页面地址https://prometheus.io/download/中找到Prometheus下载列表。在这里可以下载适用于各平台的二进制文件最新版本。
3、 使用二进制文件快速部署
1）官网下载Prometheus完成后，获取软件包的哈希值：
# sha256sum prometheus-2.44.0.linux-amd64.tar.gz
与官网提供的软件包类表中“SHA256 Checksum”列里的哈希值进行核对，保证下载的Prometheus软件包的完整性。
2）解压缩二进制软件包到指定的安装目录，运行Prometheus，操作如下：
# tar -zxvf prometheus-2.4.0.linux-amd64.tar.gz -C /data
# 这里安装在/data目录下
# cd /data # 注意核对个人安装目录
# chown -R root:root prometheus-2.4.0.linux-amd64
# ln -sv prometheus-2.4.0.linux-amd64 prometheus
3）启动Prometheus。
# cd /data/prometheus # 进入安装目录下找到prometheus服务程序
# ./prometheus # 先在终端界面直接启动prometheus服务
可以看到以下输出信息，由于篇幅缘故，这里只截取了Prometheus启动时输出日志的部分内容，
ts=2023-05-22T06:16:59.289Z caller=main.go:531 level=info msg="No time or size retention was set so using the default time retention" duration=15d
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc9c1a233bb61d173d3e383f1a44397/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61851d6a3873b106e0d7dc3b40890704/" rel="bookmark">
			详细讲解u-boot之网络移植与调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前章回顾
二、硬件原理图检查
1.确认硬件原理图的fec对应的phy地址
2.修改网卡fec1的phy地址
3.网络初始化检查
4.fec部分管脚确认
5.检查是否存在多设备管脚复用
6.使用默认ENET2
三、编译烧写，下载验证
1.设置网络环境变量
2.使用软件配置，默认生成
3.验证网络是否连通
四、FEC1网卡1调试
1.屏蔽或删除掉 fec2 节点内容
2.在fec1 节点下添加 mdio 子节点
3.添加MDIO和MDC引脚配置
4.修改ENET设备为enet0
一、前章回顾 上一章，已经讲过如何讲uboot.2022.10版本移植到我们自己的imx6ull开发板上，但是最后编译下载后网络部分为能正确识别，今天我们就来讲一讲网络部分的调试。
上一篇uboot编译后，上电启动，串口打印如下：
U-Boot 2022.10-gaef9f25a-dirty (Apr 05 2023 - 17:49:18 +0800) CPU: Freescale i.MX6ULL rev1.1 792 MHz (running at 396 MHz) CPU: Industrial temperature grade (-40C to 105C) at 26C Reset cause: POR Model: Freescale i.MX6 UltraLiteLite 14x14 EVK Board Board: MX6ULL TOTO DRAM: 512 MiB Core: 65 devices, 17 uclasses, devicetree: separate MMC: FSL_SDHC: 0, FSL_SDHC: 1 Loading Environment from MMC.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61851d6a3873b106e0d7dc3b40890704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e58446a3d3296eb870e0f1a9076309/" rel="bookmark">
			【设备默认口令&#43;弱口令】大道至简
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提醒： 这样的物联网设备都会有一个WEB管理系统（方便使用、管理），而往往这个管理系统通常存在弱口令漏洞----&gt;控制权直接沦陷
当个笑话： 总有一些人一开口就喷这种算什么技术文章？
账号密码没有、弱口令没有、默认密码没有。你还能继续玩下去的还有什么？搞笑？
弱口令： https://github.com/TheKingOfDuck/fuzzDicts
设备默认密码 产品一：深信服
设备名称
默认账号
默认密码
深信服通用
sangfor
Sangfor
sangfor@2018
sangfor@2019
深信服 EDR
root
edr@sangfor
深信服 EDR
admin
admin
深信服产品 AD
sangfor
dlanrecover
深信服负载均衡 AD3.6
admin
admin
深信服 AD3.9
admin
admin
深信服WAC (WNS V2.6 )
admin
admin
深信服VPN
Admin
Admin
深信服VPN
admin
admin
深信服IPSEC VPN SSL (5.5)
Admin
Admin
深信服AC 6.0
admin
admin
SANGFOR防火墙
admin
sangfor
深信服AF(NGAF V2.2)
admin
sangfor
深信服NGAF下一代应用防火墙(NGAF V4.3)
admin
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e58446a3d3296eb870e0f1a9076309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b69652c037ea06385e5532d348827bd/" rel="bookmark">
			【js】超链接取消默认跳转行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近在学习js的一些基础知识，遇到的一些小问题，都会记录下来
超链接取消默认跳转行为 问题描述：在点击超链接之后，不想让它跳转页面。
第一种方法：
链接填写javascript:;,表示不跳转而是执行js代码。
&lt;a href ="javascript:;"&gt;&lt;/a&gt; 第二种方法：
在事件的响应函数中加上return false，会取消事件的默认行为。
注意！但是只生效于xxx.xxx = function(){}形式绑定的事件中！
const links = document.links//获取所有超链接的节点 for(let i = 0;i&lt;links.length;i++){ links[i].onclick = function(){ return false } } 第三种方法：
在事件的响应函数中加上e.preventDefault()，这个函数可以阻止默认事件的发生（有默认事件的才有效，比如a，input type=submit）。
const a = document.querySelector("a") a.addEventlistener('click',e=&gt;{ e.preventDefault(); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bb784dc16a9c6e184b1ccd72f6a44f/" rel="bookmark">
			十六. Kubernetes 工作负载 之 StatefulSet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. StatefulSet 基础解释二. StatefulSet 配合 Service 负载均衡网络(无头服务)的使用podManagementPolicy: pod的管理策略updateStrategy: pod更新策略 一. StatefulSet 基础解释 Deployment部署的应用一般称为无状态应用,StatefulSet部署的应用一般称为有状态应用 无状态应用：可以简单理解为无状态应用不会记录当前状态,例如网络,存储等信息,如果应用宕机重启,重启后网络,存储,顺序可能等可能会变,例如Deployment部署的业务代码有状态应用：可以记录当前状态,即使重启,重启后根据状态记录信息可以做到网络,存储,顺序等不变,例如中间件MySQL、Redis、MQ等等,以mysql为例,部署为有状态的服务,即使宕机重启访问地址不会变,其它服务还是可以正常访问的 并且使用StatefulSet部署的服务是有顺序的,创建pod时,会给创建的多个pod添加索引,部署,启动等都是按照这个索引顺序进行,停止或删除是按照索引逆序执行StatefulSet 使用场景总结: 稳定、唯一的网络标识(dnsname)必须配合Service使用,StatefulSet通过与其相关的无头服务Service为每个pod提供DNS解析条目,通过解析DNS解析条目访问pod稳定的、持久的存储, 每个Pod始终对应各自的存储路径(PersistantVolumeClaimTemplate)有序的、优雅的部署和缩放。按顺序地增加副本、减少副本，并在减少副本时执行清理有序的、自动的滚动更新。按顺序自动地执行滚动更新 StatefulSet注意点 给定 Pod 的存储必须由 PersistentVolume 驱动 基于所请求的 storage class 来提供，或者由管理员预先提供。删除或者收缩 StatefulSet 并不会 删除它关联的存储卷。 这样做是为了保证数据安全，它通常比自动清除 StatefulSet 所有相关的资源更有价值。StatefulSet 当前需要无头服务 来负责 Pod 的网络标识。你需要负责创建此服务。当删除 StatefulSets 时，StatefulSet 不提供任何终止 Pod 的保证。 为了实现 StatefulSet 中的Pod 可以有序地且体面地终止，可以在删除之前将 StatefulSet 缩放为 0。在默认 Pod 管理策略( OrderedReady ) 时使用 滚动更新，可能进入需要人工干预 才能修复的损坏状态 二. StatefulSet 配合 Service 负载均衡网络(无头服务)的使用 StatefulSe与Service负载均衡网络的配合,使用StatefulSet 部署的有状态应用网络,存储等信息不变,以访问地址不变为例,封装Service负载均衡网络时设置" clusterIP: None" 不要分配ClusterIP,headless service等,访问地址由Service内部代理的通过StatefulSe部署pod自己控制 该方式下k8s内部通过"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54bb784dc16a9c6e184b1ccd72f6a44f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbbfdadde8de709222b3370653c2a80b/" rel="bookmark">
			什么是tensorflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是tensorflow tenroflow是Google开源软件库，为机器学习工程中的问题提供了一整套解决方案。类比于Spark/Flink是大数据工程问题的解决方案。
该软件库把机器学习中的通用功能封装成了库，并提供了简易的API，使得在构建机器学习系统时不再需要做那些纷繁复杂的数学、工程工作，能把主要精力放在模型和业务上。这就像现在使用编程语言进行编程时，不再需要知道计算机硬件的细节，不用知道CPU的指令集。从这个意义上说，tensorflow让机器学习工程从汇编语言时代，上升到了高级语言时代。使得机器学习这种曾经只存在于实验室由高级专业人才能把玩的高端技术变成了幼儿园小朋友手里的玩具。
什么是机器学习？ 机器学习工程中又遇到了哪些问题？机器学习是实现人工智能的一种方式。什么是人工智能？什么是智能？
什么是智能？ 目前还没有统一的定义。但是可以肯定的是人具有最高的智能。其他生命也有不同程度的智能。一只猫，一只蚂蚁，一只蚊子我们都认为它们有不同程度的智能。人工智能是人能制造出一种机器，这个机器能像生命智能一样工作。如可以听说读写，可以走路开车，可以辨认图片。就拿辨认图片来说，如辨认图片中的动物是不是一只猫。这个过程可以简化为三步, 看图片，大脑进行思考判断，回答是或者否。这个过程被抽象为一个数据的函数$y=f_w(x)$。x是输入的图片，y是判断的结果(是、否), f是大脑思考，w是大脑中的一些状态。所以智能就是这里的f和w。如何得到f和w就是人工智能中最重要的问题。计算机的发展给人工智能带来希望。f可以是运行在计算机上的程序，w是这个程序的参数。x,y是程序的输入和输出，由于需要计算机处理，所以x,y必须数字化。
传统人工智能：人为编写规则构成f 最明显的就是游戏中AI的实现。由人工编写了复杂的规则，如当敌人距离自己w1米时该干什么，当自己的血量&lt;w2时该干什么，这里的w1,w2还要人为尝试出比较合适的值。而f一般使用状态机或者行为树来实现。我们希望为任意的x都有不错的输出y. 可是，x的取值过于复杂，无论怎么分门别类，都没法穷尽。现比如天气预报，f可能是一 堆微分方程。所以得一堆懂物理，数据的博士去研究。所谓的数模竞赛就是发动一堆人去构造f。
现代人工智能：机器学习出f，w 通用的 f 被发现在：记得傅里叶变换吗？记得小波分析吗？从最简单函数无限叠加来近似一个函数。神经网络就是这样一个通用的 f (实际上需要人为构建层数，每层神经元数，各种卷积，循环神经网络就是这么构造出来的)
如果我们有大量的x,y,还有自己构建的 f 能否由机器自己学习出w？
机器学习就是建立在这种指导思想之上。首先我们构建一个函数f, 他的参数是w. y_pred=f_w(x) y_real是真实值。 loss=(y_pred-y_real)^2。loss, f_w都是人为构建的。比如loss,我们想用它表示真实值和预测值之间的差距，刚好方差能满足我们的需求，当然也有其他函数能满足,人为挑选即可。 同样，f_w也是我们人为挑选的函数，参数w初始值可以是随机值。 只要loss可导，那么我们就可以用梯度下降法来调整参数w去逼近loss的最小值。至于为什么要用梯度下降法也是人为选择的。在这里数学是我们的工具箱。我们要找到一个函数能与现实相符合。
如果我们有两条数据(x1,y1),(x2,y2), loss = (y_pred1-y_real1)^2 + (y_pred2-y_real2)^2。 如果有n条数据，n特别大，如有几个亿，那么loss函数将十分巨大，计算还是求导都十分困难。因此，把n条数据分为大小为m的batch, 每个batch有m条数据，共batch_num = n/m个batch。 每次求导，更新参数，只用一个batch,这样计算量会小很多。 同时把所有batch过一遍称为一个epoch, 经过几个epoch,loss可能不再减小，稳定到一个固定值附近，这种情况就叫模型已经收敛。训练结束。 训练结束后，需要对模型进行评估，这就需要在训练前，把一部分数据拿出来，不参与训练，此时就可以在这部分拿出来的数据上用模型进行预测，并计算loss, 或者预测准确率，就能知道模型的效果。当然，这只是简单的模型离线评估，离线评估有很多其他方法。除此之外，模型上线后还可以进行如A/B测试这样的线上评估。 后边就是如此往复，改进模型，训练，评估。
如今不需要你懂高深的物理数学知识，只要能构建神经网络，有数据，就能训练出模型。这让懂程序懂神经网络的人能对其他行业进行降维打击。因为不需要人去学习那些专业性很强的知识，让机器去学习，学出来还比专业人员还厉害。甚至能训练出通用人工智能，可能在各个方面超过人，特殊专业又比人强。
机器学习中的工程问题 在一个基于机器学习的系统中有很多工程工作需要做。主要是为了服务于y=f_w(x), loss=(y_pred-y_real)^2这两个函数。首先得有大量的(x,y),其次要构建一个合适的f和loss。
最后还要用计算机程序实现f,loss,梯度的计算和参数w的更新。 那么剩下的离线评估，上线，在线评估就水到渠成了。
数据收集(x,y) 收集用户的数据，如用户点击，评论，浏览的内容，用户的性别年龄等等。又如图像识别中要收集大量的图片。
特征工程(x,y) 数据收集部分收集的数据可能不能直接输入模型，需要一定的处理，对于类别特征，如性别，爱好等等，需要以数字编码，对于数值特征 ，如年龄，收入，可以直接用，但是
一般会做归一化处理，以免数值差距较大的特征影响模型效果。经过这一步，x,y将被处理成两个向量如x=[0.1, 0, 0.234, ...] y = 0. 这样的n个(x,y)叫做训练样本，可以直接给y=f_w(x)作为输入了。
模型构建(f_w) 这是一个寻找一个适合的函数的过程，简单如y=wx+b, 复杂如深度神经网络。深度神经网络有个特点，能表示任意函数，它也能表示y=kx+b.所以自从深度神经网络出现后人们就不用再费尽心机构造合适的数学模型了。想想曾经的天气预报模型，人为构建无数个偏微分方程，还得懂各种大气，流体等物理学知识。而现在，一个万金油深度神经网络加大数据加持就能搞。成为大数据，败也大数据。没有大数据，显然没法用神经网络了。
模型训练(train) 既然f_w已经确定，剩下的就是要编程实现整个训练过程了，无非是一些数学计算，涉及矩阵运算，微分计算，损失函数计算，梯度计算，参数更新。只要我们一一实现即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbbfdadde8de709222b3370653c2a80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd9a322f66557f51d263f08d78bce7c/" rel="bookmark">
			el-table表格最后一列合计总分（可自定义某列的合计）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要：主要用到以下截图内容
1.效果
2.最后两列的计算比较特殊，上代码
&lt;el-table v-loading="tableLoading" :summary-method="getSummaries" // 必须项1 show-summary // 必须项2，目的是在尾部展示合计列 :data="tableList"&gt; &lt;/el-table&gt; methods：{ getSummaries (param) { console.log(param, '参数') const { columns, data } = param; const sums = []; columns.forEach((column, index) =&gt; { console.log(column, index) if (index === 0) { // 其他列 sums[index] = '合计/总分'; return; } const values = data.map(item =&gt; Number(item[column.property])); if (!values.every(value =&gt; isNaN(value))) { sums[index] = values.reduce((prev, curr) =&gt; { const value = Number(curr); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd9a322f66557f51d263f08d78bce7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da91f0bab522267704c9a3ed1283434/" rel="bookmark">
			https和http
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d42e57a1947b9e4a428fa0aa991c44/" rel="bookmark">
			【JS】js运算过程中失去精度问题，解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：项目过程中，前端或多或少都会遇到一些运算问题。运算过程中失去精度，是很常见的bug。示例如下
一、常规解决方案 toFixed 通过toFixed保留小数的方式，可以解决一般运算的精度问题。需保证操作的数据为Number，需注意toFixed操作后的数据为String。
console.log((9.7*100)) //969.9999999999999 console.log((9.7*100).toFixed(2)) //970.00 二、引入插件 （1）number-precision //安装 npm install number-precision --save //引入 import NP from 'number-precision' 用法 //加法 n1+n2+n3 NP.plus(n1, n2, n3, ...) //减法 n1-n2-n3 NP.minus(n1, n2, n3, ...) //乘法 n1*n2*n3 NP.times(n1, n2, n3, ...) //除法 n1/n2/m3 NP.divide(n1, n2, n3, ...) //保留小数 n保留两位小数 NP.round(n,2) console.log(NP.round(0.38847, 2)) //0.39 //转为最接近的正确的数字 NP.strip(n) console.log(NP.strip(0.1 + 0.2)) //0.3 提示：NP.round(0.3, 2) 结果是 0.3，但是想要 0.30 怎么办？
NP.round(0.3, 2).toFixed(2) (2)big.js (3)bignumber.js (4)decimal.js 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5794da12c7b1b0be42e9a2636c896e8/" rel="bookmark">
			四个基本子空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四个基本子空间 向量空间子空间四个基本子空间 设有矩阵 A = [ 1 1 2 2 1 3 3 1 4 4 1 5 ] A=\begin{bmatrix*}[r] 1 &amp; 1&amp;2 \\ 2 &amp; 1&amp;3\\ 3&amp;1&amp;4\\ 4&amp;1&amp;5 \end{bmatrix*} A= ​1234​1111​2345​ ​ 向量空间 对加法和数乘封闭的空间。
子空间 任意穿过原点的空间构成子空间，对加法和数乘运算封闭。
四个基本子空间 列空间C(A）
所有A的列向量的线性组合构成矩阵A的列空间。A的列空间是 R 4 R^4 R4的子空间。
A x = b Ax=b Ax=b有解的条件是向量b是各列的线性组合。
零空间N(A)
线性方程组 A x = 0 Ax=0 Ax=0的所有解向量构成的空间，
行空间C( A T A^T AT).
行向量组成的所有线性组合构成行空间
左零空间N( A T A^T AT).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5794da12c7b1b0be42e9a2636c896e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c96916debc9dd2692ef76536ca878b/" rel="bookmark">
			Unity URP延迟渲染流程简单分析（Deferred Rendering）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大概两个月前的某个Unity项目里选择使用了URP延迟渲染管线（其实没必要，主要是因为自己想用一用、学一学，因为后续自己的项目中需要使用延迟渲染），但在写Shader实现物体表面着色时却一直有个疑惑：
延迟渲染应该是先一个Pass将信息存储在GBuffer中，然后再一个Pass进行实际的着色，而且通常来说使用的都是同一套着色模型，而自己在前向渲染中编写使用的自定义着色的Shader挪到延迟渲染中却看起来没有什么问题。这让我不禁怀疑起自己，又或者Unity有着强大的延迟渲染管线中的Shader扩展支持。但因为延迟渲染是准备之后仔细研究的，所以疑惑一直留到了前几天。
就在前两天因为五一假期所以在做自己的项目，于是决定研究一下上边的问题。这时突然想起来之前有看到过Unity的延迟渲染其实是混合了前向渲染的，主要是为了支持透明物体的渲染。拿多个光源照一下物体发现有光源数量限制，又翻了一下Frame Debug，果然自己写的Shader其实走的是延迟渲染后的前向渲染（Render GBuffer里当然也没有对应的信息），问题还没开始就结束了：
然后大概看了看，发现如果想自己自定义着色效果而且走延迟渲染，可能还得改一改URP的代码（不过写个Shader在GBuffer Pass里动动手脚大概也能不改管线实现点效果，但感觉限制比较大），而在改之前就先要了解一下URP中的延迟渲染到底是个什么流程。
这篇文章原本是打算学习使用一段时间后再整理一下，但最近可能要去忙其他事情，这里先写一部分，后续再补充。对Unity渲染管线了解不多，以下内容是对假期时学习的总结，仅整理大致流程方便翻找代码，可能有误，仅供参考。
GBuffer 首先来看一下GBuffer的准备部分。
从Universal Render Pipeline/Lit（也就是默认使用的Lit.shader）入手，在项目Project窗口Packages/Universal RP/Shaders下可以找到(右键-&gt;Show in Explorer可以看到文件的实际位置)，而在这个Shader中我们能看到这么一个Pass：
Name "GBuffer" Tags{"LightMode" = "UniversalGBuffer"} 也就是在这里，ps将所需的数据写入了GBuffer，但这个Shader里并没有具体的vs或ps的实现，而是被包装在了LitGBufferPass.hlsl中：
#pragma vertex LitGBufferPassVertex #pragma fragment LitGBufferPassFragment #include "Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl" #include "Packages/com.unity.render-pipelines.universal/Shaders/LitGBufferPass.hlsl" 在Shaders/LitGBufferPass.hlsl中，我们主要关注ps阶段，其中主要的部分就是通过InitializeStandardLitSurfaceData()获取了物体表面的材质信息，中间InitializeBRDFData()将其转为了BRDF参数（感觉起来这两者主要是对输入的参数进行打包、整理等），然后获取了全局光照，最后BRDFDataToGbuffer()即输出的Gbuffer数据（数据类型为FragmentOutput）。
SurfaceData surfaceData; InitializeStandardLitSurfaceData(input.uv, surfaceData); InputData inputData; InitializeInputData(input, surfaceData.normalTS, inputData); SETUP_DEBUG_TEXTURE_DATA(inputData, input.uv, _BaseMap); #ifdef _DBUFFER ApplyDecalToSurfaceData(input.positionCS, surfaceData, inputData); #endif // Stripped down version of UniversalFragmentPBR(). // in LitForwardPass GlobalIllumination (and temporarily LightingPhysicallyBased) are called inside UniversalFragmentPBR // in Deferred rendering we store the sum of these values (and of emission as well) in the GBuffer BRDFData brdfData; InitializeBRDFData(surfaceData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99c96916debc9dd2692ef76536ca878b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00b54c71cf75961f28f33dc81763cfd/" rel="bookmark">
			win11环境下，vm虚拟机打开系统后，蓝屏重启解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.将vm 升级到16以上版本解决。我是这个原因解决的。
2.cpu是否开启虚拟化
3.win11设备安全性里的内核隔离关了。
4.补充哈哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3857d0168804a96626b8310c387571/" rel="bookmark">
			错误信息：检索 COM 类工厂中 CLSID 为{00024500-0000-0000-C000-000000000046} 的组件失败，原因是出现以下错误:80070005 拒绝访问。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方式：
1.输入命令 mmc comexp.msc /32
2.依次双击【组件服务】--&gt;【计算机】--&gt;【我的电脑】-&gt;【DCOM配置】
3.在【DCOM配置】中找到“Microsoft Excel 应用程序”或“Microsoft Excel Application/ Microsoft Word Application”,选中单击鼠标右键,然后点击“属性”,弹出“Microsoft Excel/ Microsoft Word Application 应用程序属性”（或“Microsoft Excel Application / Microsoft Word Application 属性”）对话框，把“身份验证级别”-&gt; 选择为“无”。
4.点击【标识】标签,选择【交互式用户】
5.点击【安全】标签,在【启动和激活权限】下点击【自定义】然后点击对应的【编辑】按钮,在弹出的【安全性】对话框中填加两个用户：
“NETWORKSERVICE”用户和“IIS_IUSRS”用户(注意要选择本计算机名)
,并给它赋予“本地启动”和“本地激活”权限，并确定
6.仍然是【安全】标签下，在【访问权限】下点击【自定义】然后点击对应的【编辑】按钮，添加“NETWORKSERVICE”用户和“IIS_IUSRS”用户，并赋予“本地访问”权限
7.至此，问题应该已经解决，若没有解决
Word.DocumentClass 相关命令 需要以下路径的文件夹 64位服务器布置跟32位的区别是：
C:\Windows\SysWOW64\config\systemprofile\Deskto C:\Windows\System32\config\systemprofile\Desktop
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ca89e75fdc7d2e655950940284f38e/" rel="bookmark">
			ubuntu中pycharm里python导入cv2包没有代码提示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先确定cv2的下载路径
如果没在conda环境下，在终端直接pip下载的opencv,路径是在
/usr/local/lib/python3.8/dist-packages/cv2 2. 在pycharm中加入此路径
实际操作方法可参考这篇，性质是一样的
https://mp.csdn.net/mp_blog/creation/editor/127600634
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b44957db982cb91d5dbc19604a044e/" rel="bookmark">
			【vue-element-admin gitee】安装依赖报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitee地址
安装依赖时报错 Error while executing: npm ERR! D:\gongju\Git\cmd\git.EXE ls-remote -h -t git://github.com/adobe-web npm ERR! Error while executing: npm ERR! D:\git\Git\cmd\git.EXE ls-remote -h -t https://github.com/nhn/raphael.git npm ERR! npm ERR! fatal: unable to access ‘https://github.com/nhn/raphael.git/’: Failed to connect to github.com port 443: Timed out npm ERR! npm ERR! exited with error code: 128 npm ERR! A complete log of this run can be found in: npm ERR! C:\Users\new\AppData\Roaming\npm-cache_logs\2021-09-08T01_23_18_405Z-debug.log 解决这个问题，可以直接在终端执行：
git config --global url.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8b44957db982cb91d5dbc19604a044e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f34ad1384637a6e4f84465f799350b6/" rel="bookmark">
			5G信道建模研究进展与展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5G信道建模研究进展与展望 一、信道建模定义二、5G信道建模研究进展1. 5G信道建模的理论框架1.1 大尺度衰落特性1.2 小尺度衰落特性1.3 信道新特性 2. 5G信道测量平台和应用场景2.1 5G信道测量平台2.2 5G信道的应用场景 3. 5G信道特性提取与建模 三、未来6G信道建模的研究方向1.发展趋势2.研究方向 一、信道建模定义 信道建模就是通过数学的方式来刻画信道特性，揭示多径的传播机理，探索和掌握信道变化的规律、精确模型和容量机理，为移动通信系统设计与技术优化提供基础。
二、5G信道建模研究进展 5G信道建模的研究主要有三个方面：理论框架；测量平台与场景；信道特性分析与建模
1. 5G信道建模的理论框架 信道在传播过程中会经历直射、反射、散射和衍射，并最终以近似于叠加的方式被接收端接收，使得信道具有大尺度衰落特性和小尺度衰落特性（传统无线通信信道）。在相对较大距离上（十到几百米的距离）的衰落被称作大尺度衰落，而在相对较小距离上（通常是十几个波长距离内）的衰落被称作小尺度衰落。此外，5G信道模型还具有一些新特性，比如空间一致性、气体吸收和阻塞等。
1.1 大尺度衰落特性 大尺度衰落特性主要包括路径损耗和阴影衰落。路径损耗是由于多径在自由空间中传播造成的损耗，取决于发射信号的频率和收发两端的空间距离。阴影衰落是由于收发两端中间存在遮挡物，多径在传播过程中被遮挡而造成接收信号强度的变化。下面介绍5G信道建模中对路径损耗和阴影衰落的建模。
5G标准中有三种常见的路径损耗模型：自由空间邻近（CI）路径损耗模型，浮动截距（FI）路径损耗模型和ABG（Alpha-beta-gamma）路径损耗模型
CI模型 FI模型 ABG模型 常用的阴影衰落建模方法为在路径损耗模型中添加一个阴影衰落因子，在公式 (2-１)、(２-２)和 (２-３)中可以看到，通常将阴影衰落建模为均值为０的高斯随机变量。
1.2 小尺度衰落特性 小尺度衰落是指信道在短距离短期内的快速变化，其主要是由多径效应引起的。小尺度衰落与终端移动速度、周围物体移动速度以及信号的传输带宽有关。对小尺度衰落特性的研究是研究信道的重要一环，其对于后续的通信系统设计与技术优化起着重要的指导作用。针对4G系统，主流的信道模型是基于水平簇的GBSM信道模型，该模型也是ITU以及3GPP标准化组织采纳的建模方法。然而4G模型无法支持3D MIMO技术的研发和评估，张建华教授课题组提出了扩展三维簇，并在发送端和接收端引入垂直角的垂直-水平-时-频四维的GBSM模型，收发机均采用三维天线阵列，从而高精度、低复杂度地支持3D MIMO和大规模MIMO技术研究。
1.3 信道新特性 （1）空间一致性
信道的空间一致性是指当发射端（TX）和/或接收端（RX）移动或转弯时，信道平滑地变化而没有间断；另一方面，在位置接近的链路中，信道特性高度相关。在5G信道模型标准ITU M.2412中，空间一致性具有两种建模方案，本小节只介绍其中最常用的方案，具体细节如下：
（2）气体吸收
由于原子和分子的相互作用，电磁波可能会被介质部分或全部吸收。这种气体吸收导致无线电波传播的额外损失，气体吸收的影响在高频段中不能被忽略，氧气吸收模型被应用在簇响应的基础上。
（3）阻塞
当信号被阻塞时，发射机和接收机之间的静止或移动物体会极大地改变信道特性。尤其是在毫米波频段，毫米波无法有效穿透或绕过人和其他物体，阻塞现象更为常见。阻塞引起的阴影效应对链路预算有重要影响，而动态阻塞会影响对波束查找和波束跟踪等技术的评估。对阻塞的建模不仅要考虑接收信号总功率的变化，还应考虑由于阻塞物的大小、位置和方向不同而导致的多径角度或功率的变化。
2. 5G信道测量平台和应用场景 无线电波在信道中传播时，环境的复杂性和无线电波传播机制的多样性使得接收信号具有随机性，导致确定性信道建模方法复杂度较高。基于信道测量的随机性信道建模方法利用信道测量平台在实际通信场景中采集信道原始数据，并通过高精度信道参数估计算法提取信道参数，最后基于信道参数的统计结果重构信道。这种方法复杂度较低，而且由于是基于实际通信场景下信道数据建立的模型，能更好地反应真实信道的特性和内在的传播机理。
2.1 5G信道测量平台 为了研究5G信道模型，5G信道测量平台需要具有大带宽、高频率、高时延和角度分辨率等能力。
目前，主要有两种 5G 信道测量平台：
（1）一体式测量平台
它是以基于矢量网络分析仪（VNA）为核心设备。通过对S12（或S21）参数的幅度、相位进行测量，得到信道频率响应以及相位信息。然后，利用逆傅里叶变换（IFFT）得到信道冲激响应（CIR）。由于在测量过程中，收、发端都要同时连接到 VNA上，因此其测量距离受到线缆长度的限制。该测量平台的优点是能采集超大带宽的信道信息。
（2）基于分立器件测量平台
基于分立器件搭建的平台则是收、发端使用分离仪表，主要分为三类：（1）基于矢量信号源和频谱仪；（2）基于信号发生器、变频器和数字接收机；（3）基于独立模块和板卡。这三种测量平台多用于时域测量，其收发端在使用之前利用同步时钟进行同步，不受线缆长度的限制。但是，这类平台受限于器件的工作频率范围。基于分立器件搭建的平台带宽往往不超过2GHz，时延分辨率低于VNA平台。其中基于矢量信号源+频谱仪测量平台如下图所示。其中收发机均为独立仪表。基于任意信号发生器+变频器+数字接收机的测量平台的工作原理与信号源+频谱仪模式的测量平台类似，任意信号发生器产生基带IQ数据，送入变频器进行数字上变频；接收端则是通过数字下变频器，将信号搬移至基带，由于其将变频器独立出来，因此可以灵活制定覆盖频率，不必受信号源的限制。
2.2 5G信道的应用场景 为了统一技术研究和公平性比对的场景，5G 信道国际标准 3GPPTR 38.901 中定义了 5 个子场景，分别是UMa、UMi、RMa、室内办公室以及室内工厂。这几个场景具体的定义和典型配置介绍如下。
（1）UMa 场景是指有密集建筑群的城区，基站天线通常位于或高于屋顶线，周围无遮挡，蜂窝小区覆盖面积较大。UMa场景参数如下表 所示，基站高度为25 m，站间距为 500 m。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f34ad1384637a6e4f84465f799350b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0fcf0cf8f670e8e13e741dc4b62acd/" rel="bookmark">
			直接灰度变换和直方图均衡化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		姓名： 李旭 学号：51220710116评定成绩： 实验名称：实验1图像增强
基本原理与方法 直接灰度变换 灰度图像是由灰度阴影组成的数字图像，通常由8位灰度图像中从0（黑色）到255（白色）的像素大小表示。图像中的每个像素表示图像中特定点的亮度。灰度变换（Gray Level Transformation）是一种将图像的灰度级（亮度）值进行变换的操作，用于调整图像的对比度、亮度或者进行灰度级的映射。它的一般表示形式为：
g(x, y) = T(f(x, y))
（1）
灰度变换的目的可以是增强图像的对比度、调整图像的亮度、拉伸灰度级范围、均衡化灰度分布等。
线性变换：线性变换是最简单的灰度变换方式，可以通过改变变换函数的斜率和偏移来调整图像的对比度和亮度。线性变换可以表示为：
gx,y=a*fx,y+b
（2）
其中，a和 b是常数，控制变换的斜率和偏移。通过适当选择a和b的值，可以调整图像的亮度和对比度。
对数变换：对数变换可以扩展图像中的低灰度级细节，并减少高灰度级之间的差异。对数变换可以表示为：
g(x, y) = c * log(1+ f(x, y))
（3）
其中，c是常数，用于调整对数变换的增益。对数变换对于低灰度级的像素进行放大，使得细节更加明显。
幂次变换（伽马校正）：幂次变换可以用于调整图像的对比度和亮度，并改变图像的灰度级分布。幂次变换可以表示为：
g(x, y)=c*f(x, y)γ
（4）
其中，c是常数，γ是幂次指数。通过调整γ的值，可以改变图像的对比度和亮度。当γ大于1时，图像的低灰度级会被压缩，高灰度级会被扩展，从而增强对比度。
直方图均衡化：直方图均衡化是一种常用的灰度变换方法，旨在使图像的灰度级分布更均匀，增强图像的对比度。直方图均衡化的原理是通过对图像的累积分布函数进行变换，将原始图像中的灰度级映射到新的灰度级上。
直方图显示及均衡化 直方图均衡化是一种常用的图像增强技术，旨在调整图像的灰度级分布，增强图像的对比度。它的原理基于直方图和累积分布函数的概念。
直方图均衡化的过程如下：
计算直方图：首先，对输入图像进行灰度化处理，然后计算图像的直方图。直方图是一个表示图像中每个灰度级出现次数的统计图。计算累积分布函数（CDF）：基于直方图，计算图像的累积分布函数。累积分布函数描述了图像中所有灰度级的像素累积概率。映射到新的灰度级：根据累积分布函数，将原始图像中的每个像素的灰度级映射到新的灰度级上。这个映射过程可以通过将累积分布函数值乘以最大灰度级数（如255）并进行四舍五入来实现。生成均衡化后的图像：根据映射后的灰度级，重新分配原始图像中的每个像素的灰度值，生成均衡化后的图像。 直方图均衡化的原理是通过调整图像中像素的灰度级分布，使得图像的灰度级更加均匀，从而增强图像的对比度。它的目标是将输入图像的累积分布函数变为线性的，即每个灰度级出现的概率均匀分布。通过直方图均衡化，原始图像中的较暗的区域将会被拉伸，从而增强细节；而较亮的区域将会被压缩，减少过曝。这样可以使整个图像的灰度范围更好地利用，从而提高图像的视觉效果和信息表达能力。
程序主要源代码 直接灰度变换 function transformedPel = transformedPel(pel)
if pel&lt;=80
transformedPel = 45*1.0/80*pel;
end
if pel&gt;170
transformedPel = 0.353 * (pel - 170) + 225;
end
if pel&lt;=170 &amp;&amp; 80&lt;pel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db0fcf0cf8f670e8e13e741dc4b62acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1d86e7db34c63cbb0cd4f5d4e06466/" rel="bookmark">
			u-boot移植：详细讲解移植u-boot.2022.10版本到imx6ull开发板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、u-boot编译环境准备
1.安装交叉编译工具链
2.u-boot源码包下载
3.编译
4.安装依赖库
二、U-Boot中添加自己的开发板
1、添加开发板默认配置文件
2、添加开发板对应的头文件
3、添加开发板对应的板级文件夹
4、修改 arch/arm/mach-imx/mx6/Kconfig
5、其他需要修改的地方
6、添加编译脚本build.sh
三、编译、下载、验证
1、编译
2、编译成功
3、下载验证
环境
选项内容编译主机UbuntuLTS 18.04目标板ATK I.MX6ULL（512MB DDR3 + 8GB EMMC）u-boot版本2022.10交叉编译工具链gcc-linaro-7.5.0-2019.12-i686_arm-linux-gnueabihf 一、u-boot编译环境准备 1.安装交叉编译工具链 交叉编译工具链详细安装步骤见之前写的文章
文章链接：ubuntu交叉编译工具链安装
2.u-boot源码包下载 1.1、本次使用的uboot版本为2022.10版本u-boot-2022.10.tar.bz2
1.2、下载链接：https://ftp.denx.de/pub/u-boot/
3.编译 2.1、通过共享文件夹或FTP服务将u-boot-2022.10.tar.bz2拷贝到ubuntu中
2.2、源码压缩包解压
tar -jxvf u-boot-2022.10.tar.bz2 4.安装依赖库 4.1、使用默认配置进行编译u-boot时报下面错误
toto@toto:~/workspace/uboot/u-boot-2022.10$ make mx6ull_14x14_evk_defconfig YACC scripts/kconfig/zconf.tab.c /bin/sh: 1: bison: not found scripts/Makefile.lib:222: recipe for target 'scripts/kconfig/zconf.tab.c' failed make[1]: *** [scripts/kconfig/zconf.tab.c] Error 127 Makefile:578: recipe for target 'mx6ull_14x14_evk_defconfig' failed make: *** [mx6ull_14x14_evk_defconfig] Error 2 解决办法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c1d86e7db34c63cbb0cd4f5d4e06466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125c5dad8420b4bf1c963436d8fb7ab4/" rel="bookmark">
			Faster-RCNN网络详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、Faster-RCNN算法原理2.1.RPN结构2.1.1感受野的计算与候选框的生成2.1.2正负样本 2.2.RPN的损失计算2.2.1对于分类损失2.2.2.边界回归参数 2.3.Fast-RCNN损失2.4.整体训练 三、总结四、参考博客、视频、论文地址4.1.B站优质UP视频4.2.系类论文地址4.3.个人相应笔记4.3.1数据集4.3.2目标检测系列 一、前言 前面铺垫都是为了学习最终的Faster-RCNN网络，为此学习了PASCAL VOC数据集、COCO数据集、评价指标、SS算法、R-CNN网络、Fast-RCNN网络，这些可以到本文参考博客查看。
本文有两个目的，其一是作为本人自己的笔记，方便自己巩固复习；其二，希望拙劣的见解能够帮助到正在自学的朋友。
Faster R-CNN提出了一个FPN的结构使得检测速度进度加快，推测速度达到5fps，也即每1秒可以检测5张图片。
二、Faster-RCNN算法原理 我们可以认为Faste-RCNN是在Fast-RCNN的基础上进行修改的，主要改的部分就是候选框的生成，改为了RPN结构，也就是说Faster-RCNN = Fast-RCNN + RPN，接下来我们先介绍什么是RPN?
2.1.RPN结构 上图右边是原论文给的关于RPN的结构，在输入整张图片得到feature map后，我们在feature map上滑动找到滑动窗口中心点在原始图上的中心点（可以根据映射比例关系得到），然后在原图上以该点为中心计算出k个anchor boxes,这里的anchor boxes即为初步生成的候选框，k为指定的一个大小，因为每个目标的大小和比例不一样，所以需要多个候选框来尽可能的找到目标。在原论文中k=9(主要选取了3个比例，分为1：1，1：2，2：1，大小也有三个，分别为：128✖128， 256✖256， 512✖512。也即k = 3✖3 = 9 )
256-d表示的是一个256维的一维向量，256是因为feature map的channels为256，如果backbone是VGG16则会生成512维的一维向量。
2kscores指的是，长度为2k的全连接层，每两个数来表示对k个候选框背景与目标的概率预测，总共k个候选框，所以2k个scores。
4k是指对k个候选框的边界框回归参数的预测，每个框需要4个参数。
2.1.1感受野的计算与候选框的生成 1）感受野的计算
论文中也提到了对于feature map上面每一个pixel的感受野，当网络backbone为ZF时感受为171，VGG16时为228，下图为ZF时的感受野计算过程：
PS:得到每一个anchor的背景前景预测以及边界框回归参数后，我们通过RPN生成的边界框回归参数与前景背景预测分数调整这个初步生成的候选框来生成Fast-RCNN的输入候选框。
2）候选框的生成
对于一张1000✖600✖3的图片在经过backbone输出大小为60*40的feature map,对于上面的每一个pixel,有九个初步候选框，大约为60乘以40✖9 大约20k个初步候选框，排除掉超出图片范围的大约剩下6k个，再经过RPN得到的cls得分，采取极大值抑制的方法筛选出大概2k个候选框，IOU设置为0.7，最终得到的候选框数量与SS算法生成的基本相同，大约2k个。
2.1.2正负样本 训练数据的采样，也即正样本与负样本。
对于每张图片大概采集256个样本，128个正样本，若正样本不够128，则负样本补上数量就行，例如正样本只有100，则负样本采取156个。正样本有两种方式来确定：1）是取与真实框IOU大于0.7的记为正样本；2）将与真实样本IOU最大的作为正样本；第二种方式主要作为第一种方式的补充，防止没有预测的框与真实框IOU大于0.7的极端情况。
负样本由IOU小于0.3的来确定。
2.2.RPN的损失计算 RPN的损失与前面的Fast-RCNN的损失类似，也有两个损失，一个是分类损失，一个边界框回归参数的损失。
2.2.1对于分类损失 刚看最不理解的就是为什么Ncls不等于Nreg,理论上不应该对于每一个候选框我们需要由它对于前景与背景的预测分数，有边界框的回归回归参数，这样不是256个框就都除以256吗?
后面我的个人理解是：对于分类损失确实只预测了256个框，所以每张图像的256个预测框的前后背景得分交叉熵需要除以256
而对于边界框的回归主要由位置来决定，虽然只使用了256个框但是由2400个位置，每个位置k个框，最后采样提取出来的256个框包含了这2400个位置的信息，所以除以2400。
况且还有一个平衡参数λ=10，这样得到的每个损失的权重为1/256，1/240，基本一样，更能说明其实刚开始想的除以256应该才是正确想法。
事实上对于λ，作者做了一些实验，有结果如下：
可以看到实际上各个部分的损失权重对于结果的准确性影响很小。而λ=10是作者实验得到的最佳参数。
2.2.2.边界回归参数 RPN的边界框回归损失与Fast-RCNN的边界框回归损失基本一样，不明白的可以去看我的关于fast-RCNN的详解。值得注意的是这里的X,Xa,X*分别指预测的框，anchor box（也即还没有经过RPN调整的框）、真实框的中心x坐标，y,w,h类似分别指框中心y坐标，框宽和高。这里的边界框回归参数都是相对anchor box计算的。
2.3.Fast-RCNN损失 这部分损失请看上一篇博客。本质上计算一模一样。3.目标检测(三)——Fast-RCNN详解
2.4.整体训练 关于Faster-RCNN的训练，作者有提出几种方法。
1.交替迭代训练，也就是本论文最终采取的方式
2.直接将Fast-RCNN与RPN的损失加在一起训练（Pytorch官方采取的这种方式，相比第一种时间更少，结果也基本一样）
3.作者提到直接加在一起可能会有一点问题，解决方法超出本篇论文的讨论范围。
三、总结 写到这里，R-CNN的系列基本学完，后续还有继续写Mask-RCNN的笔记。特别感谢有B站Up主霹雳吧啦Wz的视频讲解，没有博主的无私分享，我感觉自己理解会达不到这样的层次。本系列的博客都是基于他的视频讲解与原论文还有其他优秀博客写的，确实花了不少时间，希望自己能够帮助到正在学习相关知识的朋友。接下来就可以开始阅读Faster-RCNN的源码了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125c5dad8420b4bf1c963436d8fb7ab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2984d3b74a6fec949d3ef04a5a5da2b1/" rel="bookmark">
			mobx数据更新，组件未刷新问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因 “90%的问题能在官网找到答案，剩下的9%在github仓库 ‘issue’ ，还有1%是未知的”
所以原因在官网：局限性
解决方法 这句话的意思是，在使用makeObservable或makeAutoObservable之前，如果你的类中的属性已经被声明但没有被赋初始值，那么这些属性将无法被正确地观察和侦测到其值的变化。
🌰如何将对象的属性转换为可观察状态：
import { makeObservable, observable } from 'mobx'; class MyObject { x = { // 对象属性 y: 'Initial value', }; constructor() { makeAutoObservable(this); } } 这样当 x 对象内部的属性发生变化时，它们将能够被正确地观察和侦测到。从而更新页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e5c484711fba7a716a2fb4b6b7bb04/" rel="bookmark">
			机器视觉实验二：道路车流量计数实验（OpenCV-python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 用OpenCV编写一个车辆计数程序，强化对课堂讲授内容如图像腐蚀、轮廓提取、边缘检测、视频读写等知识的深入理解和灵活应用。
二、实验要求 1、用OpenCV编写一个车辆计数程序，对一段视频里道路上的来往车辆进行计数统计，要求避免同一车辆重复统计，并尽量避免漏检、错检；
2、认真撰写实验报告，要求说明实验原理，对实验过程叙述清楚，关键代码给出注释，对实验结果给出合理解释，实验分析部分则需要指出实验结果优劣的原因以及如何进一步提高实验性能的方法或手段。
3、利用python版的OpenCV编写代码。
三、实验过程 import cv2 import numpy as np min_w = 90 min_h = 90 #检测线的高度 line_high = 550 #线的偏移 offset = 7 #统计车的数量 carno =0 #存放有效车辆的数组 cars = [] def center(x, y, w, h): #计算矩阵中心点 x1 = int(w/2) y1 = int(h/2) cx = x + x1 cy = y + y1 return cx, cy cap = cv2.VideoCapture('video.mp4') bgsubmog =cv2.createBackgroundSubtractorMOG2() #去背景 #形态学kernel kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5)) while True: ret, frame = cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63e5c484711fba7a716a2fb4b6b7bb04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac8eed44234ca101047d84471f35aaf/" rel="bookmark">
			如何在Ubuntu上编辑和运行C程序(新手入门)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言搭建环境Ubuntu环境搭建 实践操作安装gcc 编辑一个C程序并运行结语 前言 兜兜转转还是想再深入的学习C语言，因此打算制定一个学习C语言的计划来不断推荐学习C语言。欢迎各位志同道合的同志加入和交流 。
qq群·：829876251
搭建环境 目前而言C语言主要运用在底层模块(驱动、解码器、算法实现)，服务器(后端服务器)、嵌入式设备(手机等电子产品上的软件)的开发领域。主要原因还是在于其开发基于Linux系统，而Linux系统是开源免费的，因此后面的C语言学习和实验都是基于Linux系统完成。对于我们大部分电脑使用者来说，使用的都是Windows系统，因此我们需要搭建一个Linux的系统环境来解决系统差异的问题。
Ubuntu环境搭建 这里不单独介绍Ubuntu虚拟环境如何搭建，因为网上的教程已经足够多了。所以直接参考下面的教程即可：
参考博客
实践操作 安装gcc 建议在安装gcc前，更换一下软件源以提升下载速度。
选择最佳后退出即可。
打开终端，输入命令：
sudo apt-get install gcc
最后执行gcc -v如下表示成功
编辑一个C程序并运行 创建一个用于存放C程序的目录，然后创建一个test.c文件，并编辑测试程序如下：
在终端下执行命令gcc -o build test.c并运行程序./build
注意如果不想每次都输入前缀，可将当前工作目录导入环境变量中。
export PATH:=$PATH:/xxx/xxx/xxx
结语 本篇博客可能写的相对比较简易，后面收集了大家集中的问题后会再更改。也欢迎大家入群交流学习。
qq群·：829876251
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57af4aa92891349be47e4511bdce33ab/" rel="bookmark">
			vim教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vim教程（转自vimtutor官方教程，用来入门） 第一讲小结第二讲第三讲小结第四讲小结第五讲小结第六讲小结第七讲小结 第一讲小结 第一节
光标移动 h j k l（左上下右）箭头和鼠标也可以移动第二节 VIM的进入和退出
确保处在正常模式
：q! &lt;回车&gt; （不保存修改退出）
vimtutor &lt;回车&gt; （进入vim教程）第三节 文本编辑之删除
在正常(Normal)模式下，可以按下 -x- 键删除光标所在位置的字符第四节 文本编辑之插入
在正常模式下，按下 -i- 键来插入文本，结束后 -Esc- 键返回正常模式第五节 文本编辑之添加
按 -A- 键以添加文本，结束后按 -Esc- 键结束第六节 编辑文件
vim 文件名 &lt;回车&gt; （编辑文件） ：wq &lt;回车&gt; （保存改动过的文件并退出） 第二讲 欲从当前光标删除至下一个单词，请输入：dw
欲从当前光标删除至当前行末尾，请输入：d$
欲删除整行，请输入：dd
欲重复一个动作，请在它前面加上一个数字：2w
在正常模式下修改命令的格式是：
operator [number] motion
其中：
operator - 操作符，代表要做的事情，比如 d 代表删除
[number] - 可以附加的数字，代表动作重复的次数
motion - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，
$ 代表行末等等。
欲移动光标到行首，请按数字0键：0
欲撤消以前的操作，请输入：u (小写的u)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57af4aa92891349be47e4511bdce33ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf767799e911280b18f4e24edcf77bac/" rel="bookmark">
			MySQL---单列索引（包括普通索引、唯一索引、主键索引）、组合索引、全文索引。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 索引 索引是通过某种算法，构建出一个数据模型，用于快速找出在某个列中有一特定值的行，不使用索
引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的
时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而
不必查看所有数据，那么将会节省很大一部分时间。
按照实现的方式类分，主要有Hash索引和B+Tree索引
Hash索引：
B+Tree索引：
按照功能划分，索引分为单列索引（包括普通索引、唯一索引、主键索引）、组合索引、全文索
引、空间索引。
2.1 创建单列索引-普通索引 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引;
普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，
纯粹为了查询数据更快一点。
创建语法：
create database mydb5; use mydb5; -- 方式1-创建表的时候直接指定 create table student( sid int primary key, card_id varchar(20), name varchar(20), gender varchar(20), age int, birth date, phone_num varchar(20), score double, index index_name(name) -- 给name列创建索引 ); -- 方式2-直接创建 -- create index indexname on tablename(columnname); create index index_gender on student(gender); -- 方式3-修改表结构(添加索引) -- alter table tablename add index indexname(columnname) alter table student add index index_age(age); 查看数据库中所有的索引：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf767799e911280b18f4e24edcf77bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43fd601c5929d380c2209b8e05c0c5d1/" rel="bookmark">
			第一课 C#的基元类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 是一种通用的、类型安全的面向对象编程语言。
进制转换
0x前缀代表十六进制的意思。
0b前缀代表二进制表示法，可以用_分割，可以用在各种类型上面。
B(Binary)二进制 比如101B 就代表2进制
O(Octal)八进制 比如123O 就代表8进制
H(Hex)十六进制 比如CBH就代表16进制
本文链接：C#代码中用UL 0B 0X等前后缀表示数字_ul后缀表示什么_长空X的博客-CSDN博客
MySQL中常见的数据类型十六进制如下： 1. TINYINT：一个字节，范围-128~127，十六进制表示为0x80~0x7F； 2. SMALLINT：两个字节，范围-32768~32767，十六进制表示为0x8000~0x7FFF； 3. MEDIUMINT：三个字节，范围-8388608~8388607，十六进制表示为0x800000~0x7FFFFF； 4. INT：四个字节，范围-2147483648~2147483647，十六进制表示为0x80000000~0x7FFFFFFF； 5. BIGINT：八个字节，范围-9223372036854775808~9223372036854775807，十六进制表示为0x8000000000000000~0x7FFFFFFFFFFFFFFF； 6. FLOAT：四个字节，十六进制表示为0x0~0x7F800000； 7. DOUBLE：八个字节，十六进制表示为0x0~0x7FF0000000000000。 128bits 精度最高
我们可以使用 unchecked 关键字表示对该关键字的作用域内的代码强制不执行算术溢出检查；
我们可以使用 checked 关键字表示对该关键字的作用域内的代码强制执行算术溢出检查。
object
支持.NET类层次结构中的所有类，并为派生类提供低级别服务。这是所有 .NET类的最终基类；它是类型层次结构的根。
//任务：将下面的字符串转换为不同的字节数组 using System.Text; var currentLocation = "Rudong"; //1.转换为 UTF-16 字节数组 byte[] utf16Bytes = Encoding.Unicode.GetBytes(currentLocation); string utf16string = BitConverter.ToString(utf16Bytes); Console.WriteLine(utf16string); //52-00-75-00-64-00-6F-00-6E-00-67-00 //2.转换为 UTF-8 字节数组 byte[] utf8Bytes = Encoding.UTF8.GetBytes(currentLocation); string utf8string = BitConverter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43fd601c5929d380c2209b8e05c0c5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d748081a8a6c057ee6633ac22d3caaab/" rel="bookmark">
			今日热榜前 5 的 GitHub 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日开源热榜 Top5 项目目录：
1. 纪念左耳朵耗子
2. 你的第二大脑
3. 大模型开发人员需要记住的数
4. 短链接管理工具
5. StableStudio
01 纪念左耳朵耗子
MegaEase 创始人兼 CEO 陈皓（网名：左耳朵耗子），于上周因突发心梗去世，享年 47 岁，令人感到十分突然 RIP.
三天前一个叫做 Remembering-Haoel 的开源项目创建了，这个项目用来收集国内开发者和左耳朵耗子的故事，目前已经有 40 名开发者将和左耳朵耗子相处的点滴上传到了这个项目。
项目创建者欢迎开发者通过 PR 来写出和陈皓的故事，这样你们和他的故事就能一直保存在这个世界上最大的技术社区 GitHub。
也许，这就是开发者对技术大佬表达缅怀的方式吧。
开源地址：https://github.com/megaease/Remembering-Haoel
02 你的第二大脑
Quivr 是你的“第二个大脑”，基于人工智能技术，帮助你轻松存储和检索非结构化信息。
Quivr 几乎可以处理任何你扔给它的东西，比如文档、图片、代码、视频等等，你把文档扔给 了 Quivr，就可以通过对话的方式去询问 Quivr 文档中的相关信息，让他帮你总结、分析。
开源地址：https://github.com/StanGirard/quivr
03 大模型开发人员需要记住的数
这个开源项目梳理了大模型开发人员都应该知道的数字，比如训练 GPT 大模型价格、寻来你成本、需要的显存参数等等。
当你想关注某个数时，不需要再去各个网站自己找，先来看看这里有没有你想要的数据。
开源地址：https://github.com/ray-project/llm-numbers
04 短链接管理工具
Dub 是为营销、运营同学使用的短链接共享、跟踪工具，该项目提供了一个强大的仪表盘，可以实时的查看访问的地理、设备、浏览器等信息。
开源地址：https://github.com/steven-tey/dub
05 StableStudio
StableStudio 是 DreamStudio 开源变体， 使用 AI 生成能力的用户界面。和 DreamStudio 相比，StableStudio 所有 API 调用都已被插件系统取代，该插件系统使您可以轻松更换后端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d748081a8a6c057ee6633ac22d3caaab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b3d08307e1213d12e1bce15f64080d/" rel="bookmark">
			VUE3 使用百度地图 【点击获取对应坐标】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文档
编码
第一步 申请api秘钥
第二步 引入
第三步 创建组件
第四步 使用组件
效果图：
文档 百度地图官方文档
https://lbsyun.baidu.com/index.php?title=jspopularGL/guide/geoloaction
百度地图官方示例
https://lbsyun.baidu.com/jsdemo.htm#aCreateMap
编码 第一步 申请api秘钥 https://lbsyun.baidu.com/index.php?title=jspopular/guide/getkey
第二步 引入 在vue项目的index.html文件中引入
第三步 创建组件 &lt;script lang="ts"&gt; export default { name: `baidu-map` }; &lt;/script&gt; &lt;script setup lang="ts"&gt; import { getCurrentInstance, nextTick, onMounted } from "vue"; const { proxy } = getCurrentInstance(); const props = defineProps({ x: { type: Number, default: 113.31071 }, y: { type: Number, default: 23.14828 } }); onMounted(() =&gt; { nextTick(() =&gt; { init(); }); }); const init = async () =&gt; { const BMap = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9b3d08307e1213d12e1bce15f64080d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3301724d182d413a203e9d2fd02e139b/" rel="bookmark">
			将JSON写入文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要引入fastjson的依赖文件，以下是maven的依赖：
&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;/groupId&gt;&lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt; 然后是将json字符串写到文件中去：
import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.serializer.SerializerFeature; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStreamWriter; import java.io.Writer; import java.nio.charset.StandardCharsets; public class JsonUtils { private static final String DEFAULT_SAVE_DIRECTORY = "upload/file/"; private static String SEPARATOR = File.separator; private static SimpleDateFormat DateSdf = new SimpleDateFormat("yyyyMMdd"); public static void saveJson(JSONObject data,Long taskId,Long cmdId) { //写入操作 String content = JSON.toJSONString(data, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat); String filePath =DEFAULT_SAVE_DIRECTORY+ getStrDate() +"/"+ "taskId-"+taskId+"cmdId-"+cmdId+".txt"; try { File file = new File(filePath); // 创建上级目录 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3301724d182d413a203e9d2fd02e139b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bf2343ad47c58e801805ee4fde2483/" rel="bookmark">
			SpringBoot开发实用篇1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、热部署 1.手工启动热部署 经过测试当前是没有启动热部署的：
再将sout的信息多复制几份，刷新功能，发现控制台还是只打印一行信息。说明当前热部署是没有生效的。
手动开启热部署：
在pom.xml文件中加入开发者工具配置热部署：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 运行程序后，修改代码发现热部署没有生效。
需要配合项目构建工具共同使用：
修改代码后，点击Build Project，热部署就成功了（激活热部署）。
关于热部署：
重启（Restart）：自定义开发代码，包含类、页面、配置文件等，加载位置restart类加载器；
重载（ReLoad）：jar包，加载位置base类加载器。
热部署是不需要将jar包再加载一遍的，热部署仅仅是restart过程，而不包括relload过程。（热部署仅仅加载当前开发者自定义开发的资源，不加载jar资源）
程序第一次启动的时候既有restart，也有reload过程。
2.自动启动热部署 设置自动构建项目：
IDEA失去焦点5秒后，自动热部署。
3.热部署配置范围 页面不参与热部署，页面更改后，一刷新，就显示出来了。
配置文件参与热部署。
自定义重启排除项：下面设置的文件不参与热部署
spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC&amp;useSSL=false username: root password: "****" devtools: restart: #设置不参与热部署的文件或文件夹 exclude: static/**,public/**,config/application.yml 4.关闭热部署 设置高优先级属性（Java系统属性）禁用热部署：为了覆盖所有配置文件。
在这个配置文件中设置是不行的，可能有更高优先级的配置文件开启了热部署。
设置在引导类中：
二、配置高级（围绕配置中数据的读取） 1.@ConfigurationProperties可以为第三方的bean绑定属性 @ConfigurationProperties属性可以将配置文件的内容加载到bean容器中。
加载自定义的属性到bean中 配置文件中：
这个类加载配置文件中的内容，并将这个类交给bean来管理
测试一下，bean中有配置文件的内容：
加载第三方依赖的属性到bean中 使用Durid数据源连接池进行测试：
使用@ConfigurationProperties属性为第三方bean绑定属性：
把datasource改成驼峰命名法，就会报错，为什么？（宽松绑定/松散绑定）
@ConfigurationProperties不仅可以为自己开发的组件做bean的属性绑定，还可以为第三方的bean绑定属性，格式相同。
@EnableConfigurationProperties和@ConfigurationProperties的区别：
Enable可以看作是一个开关，开启配置属性的功能，向对应的类里做属性注入，要设定目标是谁，@EnableConfigurationProperties注解可以将使用@ConfigurationProperties注解对应的类加入Spring容器，使用所以不用写@Component
2.宽松绑定/松散绑定 @ConfigurationProperties绑定属性支持属性名宽容绑定
在配置文件中任意写，注解都能认出来
ipAddress: 192.168.1.1 ip_address: 192.168.1.1 ip-address: 192.168.1.1 IP_ADDRESS: 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bf2343ad47c58e801805ee4fde2483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afdb0da47bb3c89dba5ce3818e2a95a/" rel="bookmark">
			《SQL经典实例》第六章 处理字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大多数情况下，你希望以每次穿过一个字符的方式来遍历字符串，可惜在 SQL 中，这种任务完成起来并不容易。由于 SQL 的循环功能有限，你需要通过模拟循环来遍历字符串。我们将这种操作称为“走查字符串”，本章的第一个实例对此做了介绍。使用 SQL 来分析字符串时，这种操作非常重要，本章的大部分实例参照并使用了它。强烈建议你弄清楚这种方法的工作原理。
--6.1 走查字符串 select substring(e.ename,iter.pos,1) as C from (select ename from emp where ename = 'KING') e, (select id as pos from t10) iter where iter.pos &lt;= datalength(e.ename) 内嵌视图 E 的基数为 1，而内嵌视图 ITER 的基数为 10，因此笛卡儿积为 10 行。要在 SQL 中模拟循环，首先需要生成这样的积。 --6.2 在字符串字面量中嵌入引号 select 'g''day mate' qmarks from t1 输出：g'day mate SQL中的单引号即：'' （两个单引号） 单引号总是成对出现 --6.3 计算字符串中特定字符的出现次数 删除字符串中的逗号，再将原来的字符串长度与删除逗号后的字符串长度相减，就可以确定字符串中包含多少个逗号 select (datalength('10,CLARK,MAN,AGER')- datalength(replace('10,CLARK,MANAGER',',','')))/datalength(',') as cnt from t1 第二行的除法，仅当要查找的字符串的长度大于 1 时，这个除法运算才是必不可少 --6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5afdb0da47bb3c89dba5ce3818e2a95a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bb34bc8abb62e07b46dc1156a498e8/" rel="bookmark">
			【vue3常见报错5】Uncaught (in promise) TypeError: xxx is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Uncaught (in promise) TypeError: xxx is not a function 这种报错通常表示调用了一个未定义或不是函数类型的变量。 解决方法包括： 检查是否正确导入函数或模块。确认传递参数的类型和数量与函数定义相匹配。确认参数值不为null或undefined。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3be07158481839ca8d29fc03edb1d9/" rel="bookmark">
			sortable.js 实现拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sortable.js 是一个 JavaScript 库，用于在现代浏览器和触摸设备上重新排序拖放列表。
安装： // 通过 npm安装 npm install sortablejs --save // 在组件中导入 import Sortable from 'sortablejs' 使用： 在 Vue2 中使用Element-UI 的 el-table 表格结合 sortable.js 实现表格拖拽。
点击编辑展示顺序，展示右侧的取消和保存按钮，此时表格可拖拽；点击取消按钮，隐藏右侧的取消和保存按钮，恢复之前表格的状态，此时表格不可拖拽；点击保存按钮，隐藏右侧的取消和保存按钮，将拖拽后的数据传给后端，此时表格不可拖拽。
&lt;template&gt; &lt;div&gt; &lt;div style="display: flex;justify-content: space-between;"&gt; &lt;el-button @click="handleIsEditOrder"&gt;编辑展示顺序&lt;/el-button&gt; &lt;div v-if="isEditOrder"&gt; &lt;el-button @click="handleCancelSort"&gt;取消&lt;/el-button&gt; &lt;el-button type="primary" @click="handleSaveSort"&gt;保存&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;el-table v-if="isShowTable" :data="tableData"&gt; &lt;el-table-column prop="showOrder" label="序号"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="src" label="图片"&gt; &lt;template slot-scope="scope"&gt; &lt;img style="width: 50px; height: 50px" :src="scope.row.image"/&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Sortable from 'sortablejs' export default { name: 'banner', data () { return { tableData: [], isShowTable: true, isEditOrder: false, sortable: null, // 拖拽对象 sortData: [] // 拖拽数据 } }, mounted () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3be07158481839ca8d29fc03edb1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/532112efb3e3f5aeefd320d2a0f7ad70/" rel="bookmark">
			纯html和js穿梭框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、效果： 2、代码（复制可直接使用，对你有帮助的话就点个赞叭，嘿嘿）： &lt;template&gt; &lt;div&gt; &lt;div class="container"&gt; &lt;div class="left_box"&gt; &lt;div @click="inviteAllPerson" style="color:red;cursor: pointer"&gt;{{inviteAll==true?'取消全选':'全选'}}&lt;/div&gt; &lt;div class="left_box_list" v-for="(item,index) in invitePersonList" :key="index"&gt; &lt;div&gt;{{item.name}}&lt;/div&gt; &lt;div&gt;{{item.tel}}&lt;/div&gt; &lt;div @click="changeInviteStatus(item,index)" style="color:blue;cursor: pointer"&gt;点我选择&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt;&gt;&gt;&gt;&lt;/div&gt; &lt;div class="right_box"&gt; &lt;div @click="deleteAllSelectedPerson" v-if="selectedInvitedPerson.length&gt;0" style="color:red;cursor: pointer"&gt;全部清除&lt;/div&gt; &lt;div class="left_box_list" v-for="(item,index) in selectedInvitedPerson" :key="index"&gt; &lt;div&gt;{{item.name}}&lt;/div&gt; &lt;div&gt;{{item.tel}}&lt;/div&gt; &lt;div @click="deleteSelectedPerson(item,index)" style="color:blue;cursor: pointer"&gt;点我删除&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { inviteAll: false, // 是否全选 invitePersonList: [ // 左边数据 { name: '王泽', tel: '1529585496', isChecked: false, id: 1 }, { name: '张花花', tel: '1529585496', isChecked: false, id: 2 }, { name: '王泽强', tel: '1529585496', isChecked: false, id: 3 }, { name: '李狗子', tel: '1529585496', isChecked: false, id: 4 } ], // 邀请人员列表 selectedInvitedPerson: [],//右边数据 } }, created () { }, methods: { //左边-全选 inviteAllPerson () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/532112efb3e3f5aeefd320d2a0f7ad70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9dc53c10d4a7182ddfaaf57a3a3847b/" rel="bookmark">
			右边的数据根据左边选中数据数量的改变而改变，左边数据仍在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、效果：
2、代码（复制可直接
&lt;template&gt; &lt;div&gt; &lt;div class="container"&gt; &lt;div class="left_box"&gt; &lt;div @click="inviteAllPerson" style="color:red;cursor: pointer"&gt;{{inviteAll==true?'取消全选':'全选'}}&lt;/div&gt; &lt;div class="left_box_list" v-for="(item,index) in invitePersonList" :key="index"&gt; &lt;div&gt;{{item.name}}&lt;/div&gt; &lt;div&gt;{{item.tel}}&lt;/div&gt; &lt;div @click="changeInviteStatus(item,index)" style="color:blue;cursor: pointer"&gt;{{item.isChecked==true?'取消选择':'点击选择'}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt;&gt;&gt;&gt;&lt;/div&gt; &lt;div class="right_box"&gt; &lt;div @click="deleteAllSelectedPerson" v-if="selectedInvitedPerson.length&gt;0" style="color:red;cursor: pointer"&gt;全部清除&lt;/div&gt; &lt;div class="left_box_list" v-for="(item,index) in selectedInvitedPerson" :key="index"&gt; &lt;div&gt;{{item.name}}&lt;/div&gt; &lt;div&gt;{{item.tel}}&lt;/div&gt; &lt;div @click="deleteSelectedPerson(item,index)" style="color:blue;cursor: pointer"&gt;点我删除&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { inviteAll: false, // 是否全选 invitePersonList: [ // 左边数据 { name: '王泽', tel: '1529585496', isChecked: false, id: 1 }, { name: '张花花', tel: '1529585496', isChecked: false, id: 2 }, { name: '王泽强', tel: '1529585496', isChecked: false, id: 3 }, { name: '李狗子', tel: '1529585496', isChecked: false, id: 4 } ], // 邀请人员列表 selectedInvitedPerson: [],//右边数据 } }, created () { }, methods: { //左边-全选 inviteAllPerson () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9dc53c10d4a7182ddfaaf57a3a3847b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/79/">«</a>
	<span class="pagination__item pagination__item--current">80/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/81/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>