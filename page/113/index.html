<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a573cef007c17686817c9cf75666067f/" rel="bookmark">
			网站实现变灰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当大家看到全站的内容都变成了灰色，包括按钮、图片等等。这时候我们可能会好奇这是怎么做到的呢？
解决方案很简单，只需要几行代码就能搞定了。通过参考资料，我总结出以下几个方法可以帮助我们达到目的：
使这个网页的颜色变成灰色的最简单的方法，就是在当前页面的css里面。添加下面的代码，并且让他在任意的浏览器里面正确的执行：
方法一
&lt;style type="text/css"&gt; html { filter:grayscale(100%); -webkit-filter:grayscale(100%); -moz-filter:grayscale(100%); -ms-filter:grayscale(100%); -o-filter:grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter:grayscale(1) } &lt;/style&gt; filter是滤镜的意思，filter:gray的意思就是说给页面加上一个灰度的滤镜，所以html里面的所有内容都会变成黑白的了。不过这个滤镜对于chrome和safari浏览器是无效的，所以下面会有一行-webkit-filter: grayscale(100%);这个样式是专属于使用webkit内核的浏览器的，意思和FILTER: gray;差不多，只是写法不同罢了。
方法二
下面这段代码可以把网页变为黑白，将代码加到 CSS 最顶端就可以实现素装，如果网站没有使用 CSS，可以在网页/模板的 HTML 代码和 之间插入：
&lt;style&gt; html { filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(100%);} &lt;/style&gt; 有一些网站可能使用这个 css 不能生效，是因为网站没有使用最新的网页标准协议，请将网页最头部的替换为以下代码：
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; 还有一些网站 FLASH 动画的颜色不能被 CSS 滤镜控制，可以在 FLASH 代码的和之间插入：
&lt;param value="false" name="menu"/&gt; &lt;param value="opaque" name="wmode"/&gt; 最后
给出一段规范的代码，把这段代码加入到网站页面的css里面即可实现页面变成灰色的效果：
html{ -webkit-filter:grayscale(100%); -moz-filter:grayscale(100%); -ms-filter:grayscale(100%); -o-filter:grayscale(100%); filter:grayscale(100%); filter:url("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a573cef007c17686817c9cf75666067f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325d246a1547cacc1f6d2c34d143d48e/" rel="bookmark">
			VSCode 返回上一个光标 (上一个浏览位置) 前进/返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多 常用快捷键 动画演示 Ctrl + 鼠标左击跳到定义.
返回：
Windows: Alt + ← ;或者 鼠标侧键 Linux: Ctrl + Alt + - ;貌似数字键盘的减号没效果 Mac: Ctrl + - 前进：
Windows: Alt + → ;或者 鼠标侧键 查看快捷键、快捷键自定义设置：
VSCode左下角 “管理 / Manage” -&gt; “键盘快捷方式 / Keyboard Shortcuts” -&gt; 搜索 “前进 / Go Forward 或 返回 / Go Back”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f17d3e0fc72edae8e37ff2a89ce7ac0/" rel="bookmark">
			UE5 中 LiveLink 的开发全流程教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意，需要有源代码版本的 Unreal Engine，而不是从游戏 Launcher 中下载的 Unreal 版本。
本文使用是 Unreal Engine 5.1 版本。关于一些基础 API 介绍，可以参考之前的一篇。
起点 可以将 Engine\Source\Programs\BlankProgram 作为模板拷贝一份，然后重新命名（可以使用文本编辑器进行全局替换之类的），这里命名成 CircleLiveLinkProvider，作为 Program 的起点。
使用 GenerateProjectFiles 刷新项目，这样新的 Program 就会出现在 UE 的工程中。
// CircleLiveLinkProvider.cpp #include "CircleLiveLinkProvider.h" #include "RequiredProgramMainCPPInclude.h" DEFINE_LOG_CATEGORY_STATIC(LogCircleLiveLinkProvider, Log, All); IMPLEMENT_APPLICATION(CircleLiveLinkProvider, "CircleLiveLinkProvider"); INT32_MAIN_INT32_ARGC_TCHAR_ARGV() { GEngineLoop.PreInit(ArgC, ArgV); UE_LOG(LogCircleLiveLinkProvider, Display, TEXT("Hello World")); FEngineLoop::AppExit(); return 0; } 编译一下，在 Engine\Binaries\Win64（应该是对应平台下，我用的是 Windows，所以是在 Win64）文件夹下，会有对应编译好的可执行文件。
脱离引擎 如果想让程序独立引擎进行运行，需要使用和 Unreal 源码组织结构相同的目录层次结构。如果这时候你把生成的 .exe 拷贝出来运行，是会出现警告的，会提示没有游戏配置和引擎配置。
LogPaths: Warning: No paths for game localization data were specifed in the game configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f17d3e0fc72edae8e37ff2a89ce7ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/012a3d7cd37bb2aa856d3f9dcffed665/" rel="bookmark">
			C语言学习之关键字解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以下关键字在之前的学习记录中出现过，可以查看学习。
关键字含义auto声明自动变量，缺省时编译器一般默认为autoint声明整型变量double声明双精度变量long声明长整型变量char声明字符型变量float声明浮点型变量short声明短整型变量signed声明有符号类型变量unsigned声明无符号类型变量struct声明结构体变量union声明联合数据类型enum声明枚举类型static声明静态类型switch分支语句，用于开关语句case与switch搭配使用，开关语句分支default开关语句中的其他分支break跳出当前循环register声明寄存器变量const声明只读变量volatile说明变量在程序执行中可被隐含地改变typedef用以给数据类型取别名extern声明变量是在其他文件中声明，在本文件中使用return子程序的返回语句（可以带参数，也可以不带参数）void声明函数无返回值或无参数，声明空类型指针continue结束当前循环，开始下一轮循环dodo…while循环语句的循环体whiledo…while循环语句的循环条件if条件语句else条件语句否定分支（与if连用）forfor循环语句goto无条件跳转语句（不建议使用）sizeof计算对象所占内存空间的大小 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5971eded7b12197286ce4a1f9f1276b7/" rel="bookmark">
			解决拯救者r9000p-rtl8852ae无线网卡ubuntu18.04没有网络适配器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为之前给ubuntu分配的系统空间太小了，为加了块固态硬盘，然后就把ubuntu重新安装了一次。在这里记录 一下遇到的bug，方便未来重装的时候遇到同样的问题，减少解决问题的时间。
没有网络适配器
第一步要可以连接无限网络 1.有线网线连接。
2.没有网线可以使用手机连接电脑然后通过手机上网。小米手机有这个功能，其它品牌应该也有类似的。
3.外置免驱的无线网卡
反正得先上网！！！
第二步下载rtl的驱动包 直接去github上面下载安装包。地址是Iwfinger/rtw89去把包下载下来。
其实这里的readme里面就写的很清楚了。
第三步激活命令 cd rtw89-main make sudo make install sudo modprobe rtw89pci 出现：modprobe :could not insert rtw89.... make clean sudo make install sudo modprobe rtw89pic 基本上重启就成功了。
然后亮度不能调节就切换成510驱动就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b17f4b88ec7b238beb9fa5c4394b36/" rel="bookmark">
			查看Tomcat目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹：
lib目录：Tomcat服务端运行的一些依赖，不用关心。
logs目录：所有的日志信息都在这里。
temp目录：存放运行时产生的一些临时文件，不用关心。
work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及）
webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92420bf246a0d66e3f708efbaf2e760b/" rel="bookmark">
			Swin-Transformer详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在传统的CNN网络中，存在一些缺陷，当堆叠的卷积核太少时候，网络的感受野会比较小，不能表达全局信息，Attebtion能够让我们去关注前景忽略背景，Swin-Transformer的提出最早是为了减小运算量，适应图像分割等问题，在论文中，有patch和token两个概念，我认为当特征存在H和W维度的时候，他就是patch，当H和W相乘时候就是token，当然，他们都是指的的同一组特征，所以很多地方把他们通用。以上为Swin-Transformer的总体流程，下面本文将对网络中每一个结构做详尽介绍：
1.Patch Partition（图像块分割）+Linear Embeding（线性嵌入） 两个过程的实现为使用一个二维卷积（Conv2d），输入通道数：3，输出通道数：C=96（在这里不是48=3*4*4，因为在代码中Patch Partition和Linear Embeding通过一个二维卷积实现，在这里是使用了96个卷积核，根据网络大小不同还可以128、192），卷积核大小和步长都为4。然后进行了归一化（Layer Norm）
2.Patch Merging（图像块合并） 图来源
上图为Patch Merging的一个样例，取一个通道的特征进行讲解，用一个2×2的窗口在特征图上步长为2滑动，每个窗口会被分成四个区域，根据区域不同把一张特征图分为四份，然后在通道深度方向进行拼接，拼接后在通道方向进行归一化（LayerNorm），然后使用全连接使深度变为2。与原图相比高和宽变为原来一半，深度变为原来的二倍。全连接如下：
nn.Linear(4 * dim, 2 * dim, bias=False) 为了提高模型的表征能力，随着网络的加深，通过Patch Merging来减少token（Patch）的数量
3.W-MSA &amp; SW-MSA 上图中，左面是一个MSA模块，其中有多个patch，每一个patch都会与其他的patch进行沟通（q,k)计算，在右面，是swin-Transformer中的W-SMA他会把特征图分割为多个window（窗口），窗口中的每个patch只会和窗口内的patch进行self-attention计算。 目的：减少计算量
缺点：窗口之间无法进行信息交流
为了解决上面窗口之间无法进行信息交流的缺点，通过cyclic shift 把窗口进行移动，这样就可以聚合不同窗口之间的信息。
Shift Window的使用可以实现不同Window之间的信息交互。
Shift Window的过程指的是将window窗口向右和向下移动一定的距离，一般是两个patch的距离，移动之后，特征图的边缘会存在一些多余的突出特征和一些空白的部分，我们把突出特征补充到空白处，可以生成可被窗口分割的特征图，但是补充而来的特征图会与其周围特征形成一个新的窗口，窗口之间的patch会进行self-attention计算，这是我们不想看到的，所有我们使用一个masked MSA（蒙版），防止拼接window不同区域之间的计算。
如图，区域5和区域3两个区域拼接到了一个window里，我们在进行QK相乘，然后除每个Head的维度(dim)开方，再加上mask蒙版(nw, Mn*Mw, Mn*Mw)中的值，给我们不想看到的数据加上一个-100，这样就会在让这个值在进行softmax之后的值为0，进而和V的乘积也会是零
4. Window Attention 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b724a9830c8597942b35802a9b315fbb/" rel="bookmark">
			weixin小程序和公众号抓包方法分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、工具准备及相关设置二、burp抓包演示三、扩展操作四、小结 前言 由于在工作中涉及了微信小程序的渗透测试，参考了一些文章，感觉代理的设置大都太麻烦，甚至还有人用模拟器或者手机登陆微信再抓内网IP的数据包，按照app渗透测试的思路来抓取本在电脑上就能直接运行的应用程序的数据包，实在是没必要。因此自己鼓捣了一种简单的抓包方法，直接用proxifier工具来抓指定进程的数据包，转发给burp就可以了。
一、工具准备及相关设置 我本人用的是proxifier汉化版，可以直接从百度去找，也可以点击下方链接下载：
https://pan.baidu.com/s/1Kf5IVDAgVmCgsXU9rRlJXw?pwd=fsuj
提取码：fsuj 工具下载好以后直接傻瓜式安装即可，然后双击运行，顺利的话会见到如下界面：
依次点击菜单栏中的配置文件-&gt;代理服务器-&gt;添加
填写内容如下，其中端口应与burp的监听端口一致：
这里协议注意选https，我们只要抓https协议相关的数据包（包含了http），而socks5包含了其他协议的内容，burp不能处理，因此这里不能选socks5。
接着在主界面点击配置文件-&gt;代理规则-&gt;添加，然后设置内容如下：
注：WeChatAppEx.exe和WechatBrowser.exe分别是微信小程序和公众号通用的进程。
之后将小程序前面的复选框打钩：
二、burp抓包演示 现在我分别找个公众号和小程序演示。例如最近比较火的羊了个羊小程序：
江南雨上公众号：
三、扩展操作 大型企业经常会规定禁止内外网互联，因此如果连了公司网线，再连自己的热点就属于典型的内外网互联，而如果连公司的wifi，则因为连接人数太多往往很卡。幸好我所在的公司提供了内网代理服务器，连接上以后就可以上网了。下面分享通过proxifier工具开启全局代理的方法：
按照如下图所示进行设置：
这里的IP应为内网中代理服务器的地址和端口，这里我们公司提供的是192.168.25.25:6666，你们可根据自己实际情况修改。注意添加用户名和密码，因为内网代理服务器一般需要验证用户身份。当然不添加的话，也可以，只是后面肯会有弹窗要求填写账户密码进行身份验证。
然后在代理规则中设置如下：
这样就可以把全局所有未额外设置代理的进程流量全部导入代理服务器了。可能有人会问，这个时候假设打开了谷歌浏览器，访问了一个站点，想要用burp抓它的数据包，该怎么办呢？这个时候要注意，不要在浏览器里设置代理，直接在proxifier工具的代理规则添加一条规则如下：
检查该规则是否已启用：
这样的话，小程序、公众号和谷歌浏览器的流量就会被导入到本地的127.0.0.1的8080端口，就可以使用burp去拦截数据包，而burp的出口走的是代理服务器的ip和端口，因此并不影响它们访问外网，这样就实现了在内网环境下设置全局代理和burp拦截数据包两不误了。
同样的方法可以拦截到各种指定进程的数据包，比如拦截御剑工具的数据包，看看它在爆破的时候都发了些什么请求：
四、小结 本文主要分享了使用proxifier工具进行代理设置拦截微信小程序和公众号数据包的方法，同时扩展了其他进程数据包的拦截方法，若是本文对读者学习相关的技术起到了一定的参考意义，望能给本文点个赞，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c860faa3076bd929ff3363931ce01c/" rel="bookmark">
			小鼠与人类ID转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 发现一个好用的R包，homologene
之前用的包是biomart，不好用，老是连不上网
install.packages('homologene') library(homologene) mouse_ID&lt;-read.table("/Users/y/Desktop/小鼠ID.txt",header=T,sep="\t") genelist&lt;-mouse_ID$id a&lt;-mouse2human(genelist) write.table(a,"/Users/y/Desktop/小鼠ID转换.txt",sep="\t",quote=F,row.names=T) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e86df1d5ec3860949c774637a4927e/" rel="bookmark">
			BombLab 解题思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BombLab 解题思路 预备资料预备工作1. 解压2. 反编译3. 常用指令 phase_11. 进入调试模式2. 执行命令到main3. 显示源码和汇编4. 将程序运行到第一关5. 让程序继续运行6. 单步进入调试7. 找bomb前面的比较 phase_2phase_3 预备资料 bomb原文件
bomb汇编文件
预备工作 1. 解压 在tar所在目录下打开终端
tar -xvf ./bomb.tar 得到bomb
2. 反编译 反编译 bomb 文件后输出到 bomb.txt
objdump -D bomb &gt; bomb.txt 3. 常用指令 指令功能效果gdb进入gdb调试器start运行程序到 main 停止next执行下一步 （不进入函数内部 ）si执行下一步layout split显示源码和汇编layout regs显示汇编和寄存器fin跳出当前函数回车键重复上一条指令q退出 y确认退出 n取消退出 phase_1 1. 进入调试模式 使用 gdb bomb 进入调试模式
2. 执行命令到main 使用 start 命令使代码执行到 main 函数停止
3. 显示源码和汇编 使用 layout split 命令 显示源码和汇编代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e86df1d5ec3860949c774637a4927e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efabb7abc0eb207fbd60d43e4a699f5/" rel="bookmark">
			JS基础知识汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 -《发展史》 浏览器发展史
1995 年，网景公司研发的导航者浏览器。
1995 年 8 月，微软推出 IE1.0 版本。
1995 年 11 月，微软推出 IE2.0 版本。
从 IE3 开始，IE 浏览器作为了 windows 内置浏览器。
1998 年，网景公司被“美国在线”收购。
2008 年，谷歌推出了第一款浏览器 Chrome。
JavaScript 发展史
1995 年，网景公司花了 10 天的时间，研发出了 JavaScript 语言。
2004 年，谷歌推出了 AJAX 技术，JS 逐渐开始受到程序员的重视。
2009 年，谷歌研发出了 Nodejs，JS 就可以在服务端进行开发。
JavaScript 版本
1997 年 6 月，JS 的第一版，取名叫做 ECMAScript 1.0， 简称 ES1.0。
2009 年 12 月， ECMAScript 5.0（简称 ES5）正式发布。
2015 年 6 月，ECMAScript 2015（简称 ES6）正式发布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efabb7abc0eb207fbd60d43e4a699f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59bd1447b9c0e601857a59c6912fd802/" rel="bookmark">
			carla学习笔记(十)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验室同学需要做仿真数据的采集实验，为记录以下整个采集过程。方便未来进行类似数据采集时减少写代码的时间。
采集数据要求：
控制一辆车，从a点到b点。然后在路侧架设一个lidar，采集车辆通过激光lidar区域时的数据。
一、首先确定a点和b点。 地图选取的是carla的town03。
具体区域是这里：
首先确定选择的a点：start_point；b点：end_point。
这里使用draw_string函数，将确定的点在地图中显示出来，方便之后的路径确定：
源码如下：
import carla def show_point(world, point_location): world.debug.draw_string(point_location, 'X', draw_shadow=False, color=carla.Color(r=0, g=255, b=0), life_time=50, persistent_lines=True) def main(): client = carla.Client('localhost', 2000) client.set_timeout(2.0) world = client.get_world() start_point = carla.Location(229, 116, 2) end_point = carla.Location(20,194,2) show_point(world, start_point) show_point(world, end_point) main() 地图显示：
图中两个绿色的x就是分别确定的start_point和end_point。
这里有几个点需要注意：
1.注意区分carla.Location和carla.Transform之间的关系。
2.注意在使用系统提供的函数的时候，它的参数的格式要求，尤其是spawn_vehicle函数。
怎么才好知道点的坐标呢？
可以使用这个函数测试。首先确定原点，然后确定x轴正向，再确定y轴正向。就可以将地图的坐标系确定出来。好久没有使用carla了，当时在这一步卡了好久，主要原因就是对于相关的函数的数据格式不熟悉了，解决报错问题花了快一个小时。。。
下面是源码：
import carla def show_point(world, point_location): world.debug.draw_string(point_location, 'P', draw_shadow=False, color=carla.Color(r=0, g=255, b=0), life_time=50, persistent_lines=True) def show_x_point(world, point_location): world.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59bd1447b9c0e601857a59c6912fd802/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494ab6f2bd856044c55518ac19d1d7c8/" rel="bookmark">
			redis批量导入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、采用redis 管道 --pipe
1、先生成文本数据 redis.txt 的 文件格式
有两种文件格式 都是可以的（以下采用的是redis 的hash村粗怒）
*6 $5 hmset $24 user_profile:user_info:0 $4 name $3 317 $3 age $3 187 解释：
*6 表示有三个字符 $5 表示 hmset字符长度为5 也就是我们的命令
$24表示 user_profile:user_info:0的长度为24 也就是我们的key
以此类推
格式二：
hmset user_profile:user_info:0 name 张三 age 12 hmset user_profile:user_info:0 name 李四 age 13 2、文件格式
[atguigu@hadoop105 ~] unix2dos redis.txt 上面的命令会去掉行尾的^M符号
3、执行命令
[atguigu@hadoop105 ~] cat redis.txt | ./redis-cli -h 127.0.0.1 -a password - p 6379 --pipe 遇到的坑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494ab6f2bd856044c55518ac19d1d7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb3dfcecbb9da5668f0d49a59a982bc/" rel="bookmark">
			zookeeper学习笔记(最全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper 文章目录 Zookeeper1 Zookeeper概述1.1 Zookeeper简介1.2 Zookeeper工作原理1.3 Zookeeper特点1.4 Zookeeper数据结构1.5 Zookeeper应用场景 2 Zookeeper本地模式安装2.1 Zookeeper下载2.2 虚拟机的克隆2.3 Zookeeper安装2.4 Zookeeper配置2.5 Zookeeper基本操作2.6 Zookeeper配置参数解析 3 Zookeeper内部原理3.1选举策略3.2 节点类型3.3 监听器原理3.4 写数据流程解析 4 Zookeeper集群搭建4.1 分布式环境安装部署4.2 Zookeeper集群搭建4.1.1 配置服务的id(编号)4.1.2 配置集群IP4.1.3 配置其他两台服务4.1.4 集群操作4.2.5 集群启动的问题 4.3 Zookeeper客户端命令4.3.1 客户端命令4.3.2 节点操作 5 Zookeeper实战5.1 Zookeeper的API应用5.1.1 项目环境搭建5.1.2 创建Zookeeper客户端5.1.3 创建节点5.1.4 查询节点的值5.1.5 修改节点的值5.1.6 删除节点5.1.7 判断节点是否存在5.1.8 获取子节点5.1.9 监听节点的变化 5.2 案例-模拟美团商家上下线5.2.1 分析需求5.2.2 项目环境搭建5.2.3 商家服务类5.2.4 客户端5.2.5 运行测试 5.3 案例-分布式锁商品秒杀5.3.1 分布式锁5.3.2 数据准备5.3.3 搭建工程5.3.4 搭建SSM环境5.3.5 功能的开发5.3.6 Zookeeper解决并发问题 6 Zookeeper总结重点问题： 学习内容： Zookeeper技术（概念、使用场景、特点…）Zookeeper本地安装（在本地搭建Zookeper环境、集群的方式进行搭建）Zookeeper内部原理（掌握Zookeeper工作机制）Zookeeper实战开发（Zookeeper的API使用、美团服务监控系统、分布式秒下系统场景的搭建） 1 Zookeeper概述 1.1 Zookeeper简介 Zookeeper是一个分布式的（多台机器同时干一件事情）、开源框架，分布式应用程序的协调服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb3dfcecbb9da5668f0d49a59a982bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30bbdcd244abe7ea8e7d3c7645e895c0/" rel="bookmark">
			解决PolyBase下dump文件夹不断增长占用大量C盘空间的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总目录 文章目录 总目录前言一、问题发现二、解决问题1.问题原因2.解决步骤3.注意 总结 前言 该问题出现，使用的数据库版本是SQL Server 2019 Developer
一、问题发现 C盘咋又占满了呢？哎，刚装系统没几天，突然发现C盘不明原因的红了！ 于是呢，我就是用WizTree找了一下是什么个文件竟然短短半个月就把我C盘给占满了，后来发现就是SQLServer2019安装目录下的一个日志文件夹，竟然占了我C盘50G左右的空间，而且就是个日志文件，可怕的是每天还在这个日志文件还在增长，再慢几天C盘就给撑爆了。
日志文件目录：C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\Log\Polybase\dump
二、解决问题 原文出处：修复 SQL Server 2019 开发人员版中的 PolyBase
1.问题原因 问题的原因：因为默认情况下SQL Server 2019 Developer 版安装后不启用TCP的网络协议，因此TCP处理禁用状态，但是PolyBase一直尝试通过TCP链接到SQL Server，因此一直报错，并将错误信息存储在了\Log\Polybase\dump 目录。就造成了日志文件不断的增长。
2.解决步骤 首先删除dump文件夹下已有的类似这类SQLDmpr.0000000123C4E5121.GMT-2022-12-01-14-00-00.dmp 尾缀为dmp的文件 按Win+X 调出 系统菜单，选择【计算机管理】，然后选择 修改完毕，会提示会需要重启MSSQLSERVER 才可以生效
WIN+X 选择任务管理，进入任务管理器的【服务】，找到【MSSQLSERVER】，记住PID 使用管理员身份运行cmd，然后输入KILLTASK /PID 5024 /F，强制结束进程 按Win+R，输入services.msc 进入服务，找到下图中的三个服务 选中服务，右键菜单依次启动SQLServer 和PolyBase 服务即可。 3.注意 之所以按照上面的步骤，是因为如果直接在【服务】中去重启SQLServer 和PolyBase 服务可能会因为系统用户权限的问题，提示错误。而按照上面的步骤就会避免这个问题。
总结 以上就是今天要介绍的内容，希望以上内容可以帮助到大家，如文中有不对之处，还请批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a68ca4461447c807ceecc94ee75eb8/" rel="bookmark">
			C语言——循环语句（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.循环语句是什么？
2.while循环语句：
2.1.while循环的语法以及使用
2.2.while循环中的break语句
2.3.while循环中的continue语句
3.for循环
3.1.for循环的语法以及使用
3.2.对比while循环以及for循环
3.3.for循环中的break语句和continue语句
3.4.for循环的一些变种
4.do while 循环
4.1.do while循环语法以及使用
4.2.do while循环中的break语句和continue语句
总结
前言： c语言中有三种循环语句：while循环、do while循环、for循环，下面我会一一介绍它们的用法和它们各自的特点。
1.循环语句是什么？ 学会循环语句我们首先搞明白什么是循环语句。循环语句是用于重复执行某条语句（循环体）的语句，它包含三个部分，分别是初始化部分、判断部分和调整循环部分。C语言提供了3中循环语句，分别为while语句，do while语句和for语句。
举个例子：
只要坚持买彩票和学习我们终会走上人生巅峰，当然这也是我举得不是那么不恰当的例子，图片中的黑线就是我们一直循环的部分，红线蓝线就是终止循环的条件。一个完整的循环语句不仅要有循环判断条件表达式，还要有循环语句。
2.while循环语句： 2.1.while循环的语法以及使用 while循环的语法结构类似选择语句中的if语句。
if（表达式） {语句;} //while循环的语法 while（表达式） { 循环语句； } 注意：当while循环的表达式为真时，程序进入循环体内执行循环体内的语句。
了解了语法结构，下面我来书写一个简单的小程序，通过while循环来打印1-10数字。运行代码如下：
#include&lt;stdio.h&gt; int main() { int n = 1; //创建一个临时变量来存放打印的值 //当表达式为真时才进入循环 while (n &lt;= 10) { printf("%d ", n); n++;//调整循环的部分 } return 0; } 倘若没有调整循环的语句（n++），每次都是n=1进入while循环，程序会变成死循环，如下图所示：
while循环中一定要注意在循环体内调整循环的次数。
2.2.while循环中的break语句 在之前的switch语句学习中，我们知道break语句在选择语句是有打破该次语句的意思。在while循环内也是一样，当程序运行到break语句后会结束该次循环。下面我还是以上面代码为例加入break语句。
#include&lt;stdio.h&gt; int main() { int n = 1; //创建一个临时变量来存放打印的值 //当表达式为真时才进入循环 while (n &lt;= 10) { if (n == 4) break; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a68ca4461447c807ceecc94ee75eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de23694ec13eda15329dd2951371138/" rel="bookmark">
			ueditor 中聚焦问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点了图片，再点文字，文本无法聚焦，这个我是看到有博主在hide方法里加了3句，
me.editor.selection._bakRange.collapsed = true;
me.editor.selection._bakRange.endOffset = 0;
me.editor.selection._bakRange.startOffset = 0;
但是我加上之后，时好时坏，然后发现点击文本时，它认为点击是img,应该是选中事件没有完全清除，后来我又在上面代码基础上加上了一句代码
就好了，
me.editor.selection.getRange().collapse().select(false);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332526885536dd1e21f78abbbe1721de/" rel="bookmark">
			JavaScript：for循环之1~100的加法运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：求 1~100 之间的整数累加和
首先我们先分析一下这个问题的运算思路。
思路分析：
1~100需要循环100次
需要一个计数器 i
需要一个存储结果的变量sum，初始值是 0
算法：1 + 2 + 3 + 4 + 5+......+ 100 , sum = sum + i
算法分析：
代码：
var sum = 0; // 求和，变量 for (var i = 1; i &lt;=100; i++) { sum = sum +i; // 另一种写法：sum += i; } console.log(sum); 运行结果：
搞定！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3fc41b67fb90fe8994782f77fffc62/" rel="bookmark">
			【第6章】1、pandas读取文件（sep分隔符，header列名，skiprows跳行、na_values缺失值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pandas的解析函数 函数描述read_csv从文件、URL或文件对象读取分隔好的数据，，是默认的分隔符read_table从文件、URL或文件型对象读取分隔好的数据，制表符 (\t)是默认的分隔符read_fwf从特定宽度格式的文件中读取数据 (无分隔符)read_clipboardread_table的剪贴板版本，在将表格从Web 页面上转换成数据时有用read_excel从Excel的XLS或XLSX文件中读取表格数据read_hdf读取用pandas存储的HDF5文件read_html从HTML文件中读取所有表格数据read_json从JSON(JavaScript Object Notation) 字符串中读取数据read_msgpack读取MessagePack 二进制格式的pandas数据read_pickle读取以Pythonpickle格式存储的任意对象read_sas读取存储在SAS系统中定制存储格式的SAS数据集read_sql将SOL查询的结果(使用SOLAlchemy)读取为pandas的DataFrameread_stata读取Stata格式的数据集read feather读取Feather二进制格式 2、read_csv、read_table函数参数 参数描述path表明文件系统位置的字符串、URL 或文件型对象sep用于分隔每行字段的字符序列或正则表达式header用作列名的行号，默认是0(第一行)，如果没有列名的话，应该为Noneindex_col用作结果中行索引的列号或列名，可以是一个单一的名称/数字也可以是一个分层索引names结果的列名列表，和 header=None 一起用skiprows从文件开头处起，需要跳过的行数或行号列表na_values需要用NA替换的值序列comment在行结尾处分隔注释的字符parse_dates尝试将数据解析为 datetime，默认是 False。如果为 True，将尝试解析所有的列。也可以指定列号或列名列表来进行解析。如果列表的元素是元组或列表，将会把多个列组合在一起进行解析(例如日期/时间将拆分为两列)keep date col如果连接列到解析日期上，保留被连接的列，默认是 Falseconverters包含列名称映射到函数的字典 (例如[foo’:f会把函数f应用到’foo’列)dayfirst解析非明确日期时，按照国际格式处理(例如7/6/2012-&gt; June7,2012)，默认为 False 3、分隔符（sep） # 1、读取ex1文件（read_csv） pd.read_csv(Path('../源代码/examples/ex1.csv')) """ a	b	c	d	message 0	1	2	3	4	hello 1	5	6	7	8	world 2	9	10	11	12	foo """ ------------------------------------------------------------- # 1-1、读取文件（read_table） pd.read_table(Path('../源代码/examples/ex1.csv')) """ a,b,c,d,message 0	1,2,3,4,hello 1	5,6,7,8,world 2	9,10,11,12,foo """ ------------------------------------------------------------- # 1-2、读取文件，分隔符（sep） pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e3fc41b67fb90fe8994782f77fffc62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f45c7369cc55ed6f06d6304714548ad5/" rel="bookmark">
			C&#43;&#43;Primer第五版 习题答案 第十四章 操作重载与类型转换（Overloaded Operations and Conversions）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		练习14.1 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符又与内置运算符一样？
有所区别：
当一个重载运算符是成员函数时，this绑定到左侧的运算对象；
逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来；
&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。
一样：
对于一个重载的运算符来说，其优先级和结合律与对应的内置运算保持一致。
练习14.2 为 Sales_data 编写重载的输入、输出、加法和复合赋值运算符。
Sales_data_ex02.h
#ifndef SALES_DATA_H_ #define SALES_DATA_H_ #include &lt;string&gt; struct Sales_data; std::istream &amp;operator&gt;&gt;(std::istream &amp;is, Sales_data &amp;item); std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Sales_data &amp;item); Sales_data operator+(const Sales_data &amp;lhs, const Sales_data &amp;rhs); struct Sales_data { friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_data&amp;); friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_data&amp;); friend Sales_data operator+(const Sales_data&amp;, const Sales_data&amp;); public: Sales_data(const std::string &amp;s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p*n){std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f45c7369cc55ed6f06d6304714548ad5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/509f2c1d7a7330294b74b1b97a9721f7/" rel="bookmark">
			css---百叶窗效果实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果图： 二、实现功能： 鼠标悬浮在某个图片上后，会缓慢展开该图片，其他收缩起来。当失去鼠标悬浮后，将所有图片闭合起来。
三、代码实现： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;百叶窗效果&lt;/title&gt; &lt;/head&gt; &lt;style&gt; *{ margin: 0; padding: 0; } .container{ width: 875px; height: 360px; margin: 200px auto; border: 3px solid #194b8d; overflow: hidden; } .container ul{ display: flex; } ul li{ width: 80px; height: 360px; border-left: 3px solid #194b8d; box-shadow: 0 0 25px #000000; list-style: none; /*缓慢收缩/展开效果*/ transition: all 2s; } ul li img{ display: block; width: 540px; height: 360px; } ul:hover li{ width: 80px; } ul li:hover{ width: 540px; } &lt;/style&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/509f2c1d7a7330294b74b1b97a9721f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e650396b5013678ecfc6463ae343d8d6/" rel="bookmark">
			【Ceres学习】1. 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅用于记录自己在学习Ceres时遇到的困难。
0. 参考 Ceres官网：http://ceres-solver.org/installation.html
github: https://github.com/ceres-solver/ceres-solver
1. 下载 从github下载最新的ceres
git clone https://ceres-solver.googlesource.com/ceres-solver 2. 安装依赖 # CMake sudo apt-get install cmake # google-glog + gflags sudo apt-get install libgoogle-glog-dev # BLAS &amp; LAPACK sudo apt-get install libatlas-base-dev # Eigen3 sudo apt-get install libeigen3-dev # SuiteSparse and CXSparse (optional) # - If you want to build Ceres as a *static* library (the default) # you can use the SuiteSparse package in the main Ubuntu package # repository: sudo apt-get install libsuitesparse-dev # - However, if you want to build Ceres as a *shared* library, you must # add the following PPA: sudo add-apt-repository ppa:bzindovic/suitesparse-bugfix-1319687 sudo apt-get update sudo apt-get install libsuitesparse-dev 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e650396b5013678ecfc6463ae343d8d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce2546dde85076f04424bf504f876d0/" rel="bookmark">
			图数据库初探——7. 以红楼梦数据集为例进行Nebula Graph使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 关键命令全流程1. 基本操作1. 图的操作 2. 插入节点和关系数据2.0 scheme概念设计2.1 创建schema2.1.1 控制台创建2.1.2 Schema创建 2.2 上传数据2.3 插入数据2.3.1 插入节点2.3.1 插入关系（边） 2.4 经验 3. Nebula Studio的图探索使用3.1 建立索引3.2 查询3.3 查看图探索 报错排查1. Studio连接数据库504 gateway timeout2. SemanticError: Can't solve the start vids from the sentence: MATCH (v:role) RETURN v3. 返回结果只有三个 有些疑问的地方 0. 关键命令 管理Nebula Service的命令
# 启动所有服务（一般都是启动所有，也可以单独启动某个服务） sudo /usr/local/nebula/scripts/nebula.service start all # 停止所有服务 sudo /usr/local/nebula/scripts/nebula.service stop all # 查看服务状态 sudo /usr/local/nebula/scripts/nebula.service status all 先连接Nebula Graph
cd C:\shaiic_work\nebula_console\ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce2546dde85076f04424bf504f876d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd74ac9d263ff215fb72425e104cd98d/" rel="bookmark">
			关于Math（工具类）的介绍和其常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.Math 是一个工具类，拥有基本的数学操作（如指数、对数、平方根和三角函数等等），使用它可以避免程序员自行研发数学方面的代码。此外，java还有一个java.math包，它提供用于执行任意精度整数(BigInteger)算法和任意精度小数(BigDecimal)算法的类。
Math类是包含用于执行基本数学运算的方法的数学工具类，如初等指数、对数、平方根和三角函数。
类似这样的工具类，其所有方法均为静态方法，并且一般不会创建对象。如System类工具类，代表能够完成一系列功能的类，在使用它们时，不用创建对象，该类中方法为静态方法
常用方法:
1、abs方法，结果都为正数，取绝对值
double d1 = Math.abs(-5);// d1的值为 5 double d2 = Math.abs(5); // d2的值为 5 2、ceil方法，结果为比参数值大的最小整数的double值
double d1 = Math.ceil(3.3); //d1的值为 4.0 double d2 = Math.ceil(-3.3); //d2的值为 -3.0 double d3 = Math.ceil(5.1); //d3的值为 6.0 3、floor方法，结果为比参数值小的最大整数的double值
double d1 = Math.floor(3.3); //d1的值为 3.0 double d2 = Math.floor(-3.3); //d2的值为 -4.0 double d3 = Math.floor(5.1); //d3的值为 5.0 4、max方法，返回两个参数值中较大的值
double d1 = Math.max(3.3, 5.5); //d1的值为 5.5 double d2 = Math.max(-3.3, -5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd74ac9d263ff215fb72425e104cd98d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1907657b5dff258233b1c6cf258c27e/" rel="bookmark">
			npm ERR! cb() never called! 报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm ERR! cb() never called! 报错问题 本人已经被这个问题困扰了好几天总结出以下几条
看网上发帖最多的一种解决方式
1.删除 node_modules 文件夹 2.清除npm缓存 npm cache clean --force 3.npm install 若第一种方法失败 则修改npm版本，我是利用的nvm管理npm版本的，关于nvm的使用可自行百度
1. nvm ls 查看当前管理的 npm 版本 2. nvm use 版本号 使用某一个npm版本 若前两种都不行，则就是 npm 镜像源的问题，要切换为原来的镜像源 不要使用淘宝镜像
npm config set registry https://registry.npmjs.org/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794eef704dcfa1216c75b4734310671c/" rel="bookmark">
			JavaScript：断点调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断点调试可以帮助我们查看代码运行过程。
同时，当你运行代码的时候，可能会出现bug，那么断点调试也可以让我们更好的排错。
所以，断点调试能力非常重要，只有学会了断点调试，才能学会自己修复bug的能力。
我平时用的时微软的Edge浏览器，这里就用Edge（用chrome、火狐方法大同小异）给大家演示一下简单的断点调试的基本操作：
1.打开控制台，按F12或鼠标右键找到检查选项
2.断点文件位置
打开Edge，找到源代码选项（Sources），找到你要调试的文件，打开它：
3.打断点
首先，给源代码里面的文件打断点。点击你要调试的代码的行数，发现行数会被标记为红色（Edge），这说明已经成功打断点了。
4.进入调试状态
刷新页面进入调试状态
5.逐语句执行
按照个人调试需求点击图中红框中的按钮进行调试。
从左到右，各个图标表示的功能分别为：
暂停/恢复脚本执行（快捷键F8 Ctrl+ \ ）。单步跳过下一个函数调用（快捷键F10 Ctrl+ ' ）。单步执行下一个函数调用（快捷键F11 Ctrl+；）。跳出当前执行函数（快捷键Shift+F11 Ctrl+Shift+；）。步骤（快捷键F9）。停用断点（快捷键Ctrl+F8）。出现异常时暂停。 到此，简单的断点调试介绍得差不多了，接下来我们就可以一行一行去看我们的程序代码，查看每一行执行完毕之后，我们各个变量的变化情况了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd402bb2173ded33fe316d27840054d7/" rel="bookmark">
			ROS中生成CameraInfo消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于某个第三方代码需要接受CameraInfo消息，我换了一个相机以后，需要自己发布CameraInfo消息。网上搜了半天，很少有介绍CameraInfo这些数据都是怎么来的的资料，可能大部分都是直接生成的吧，像我这样需要自己计算的可能不多。折腾了半天，也算是找到了方法。特做记录总结。转载请注明出处。
分析 首先看一下现有的CameraInfo有哪些数据：
rostopic echo /camera_info 可以看到，除了header外有 D, K, R, P等参数。这几个都是什么？
这就需要看一下在ros官网的说明：
http://docs.ros.org/en/melodic/api/sensor_msgs/html/msg/CameraInfo.html
一篇关于这个官方说明的资料在这里：https://github.com/dimatura/ros_vimdoc/blob/master/doc/ros-camera-info.txt
可以看出，D是畸变参数，K是相机内参矩阵，R是旋转，P是（校正后的）投影矩阵。
计算 进过相机标定后，一般都能够获得K和D，但R和P怎么设置？
一般我们不需要图像进行旋转，所以R给单位阵就好。P可以看到，P和K并不是完全相同。可以说，如果是没有畸变的图像，那么P左半部分和K是相同的。那么P该如何计算？找到了这个帖子：https://answers.ros.org/question/119506/what-does-projection-matrix-provided-by-the-calibration-represent/（可能访问不了，贴图到这里）
所以可以用OpenCV的函数getOptimalNewCameraMatrix()计算。函数API说明
只需要设置相机内参矩阵、畸变参数、长宽，alpha是自行设定，但根据ROS中cameraInfo，应该设置为0。
代码 测试代码如下：
void ex(void){ cout &lt;&lt; "camera info parameter..." &lt;&lt; endl; Mat dst; Mat cameraMatrix = Mat::zeros(Size(3,3), CV_64FC1); Mat distCoeffs(Size(1,4), CV_64FC1); cameraMatrix.at&lt;double&gt;(0,0) = 199.0923665423; cameraMatrix.at&lt;double&gt;(0,2) = 132.1920713777; cameraMatrix.at&lt;double&gt;(1,1) = 198.8288204701; cameraMatrix.at&lt;double&gt;(1,2) = 110.7126600011; cameraMatrix.at&lt;double&gt;(2,2) = 1; distCoeffs.at&lt;double&gt;(0) = -0.36843631179; distCoeffs.at&lt;double&gt;(1) = 0.150947243556; distCoeffs.at&lt;double&gt;(2) = -0.00029613053; distCoeffs.at&lt;double&gt;(3) = -0.00075943173; // distCoeffs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd402bb2173ded33fe316d27840054d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4319850c543fde98dceb46a1cf6cbc69/" rel="bookmark">
			DMA简单理解和分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DMA基本概念 直接存储器访问（Direct Memory Access），简称DMA。DMA是CPU一个用于数据从一个地址空间到另一地址空间“搬运”（拷贝）的组件，数据拷贝过程不需CPU干预，数据拷贝结束则通知CPU处理。因此，大量数据拷贝时，使用DMA可以释放CPU资源。DMA数据拷贝过程，典型的有：
内存—&gt;内存，内存间拷贝外设—&gt;内存，如uart、spi、i2c等总线接收数据过程内存—&gt;外设，如uart、spi、i2c等总线发送数据过程 二、DMA一些应用场景 1、ADC与DMA （1）AD单次启动+软件启动+查询/中断方式 ------------------------------------------------------------------------- var = Get_Adc_Average(ADC_CHANNEL_0, 10); //放大倍数为0.635 Sys.adc1 = var * 3300 / 4096 * 1.574 + 10; ---------------------------------------------------------------------------- u16 Get_Adc(u32 ch) { ADC_ChannelConfTypeDef ADC1_ChanConf; ADC1_ChanConf.Channel=ch; ADC1_ChanConf.Rank=1; ADC1_ChanConf.SamplingTime=ADC_SAMPLETIME_480CYCLES; ADC1_ChanConf.Offset=0; HAL_ADC_ConfigChannel(&amp;hadc1,&amp;ADC1_ChanConf); HAL_ADC_Start(&amp;hadc1); HAL_ADC_PollForConversion(&amp;hadc1,10); return (u16)HAL_ADC_GetValue(&amp;hadc1); } u16 Get_Adc_Average(u32 ch,u8 times) { u32 temp_val=0; u8 t; for(t=0;t&lt;times;t++) { temp_val+=Get_Adc(ch); osDelay(5); } return temp_val/times; } （2）连续转换+DMA+手动启动/定时器启动 在方法1里面，每次转换完成，需要我们手动去读一下AD值；启动DMA之后，完全省掉了这个过程，只需要等待设定好的值全部转换完成之后触发一个中断，再进行数据处理。
/** * @brief adc01的配置 规则通道并行 扫描和连续转换模式 */ static void bsp_adc01_cfg(void) { /* enable ADC0 and ADC1 clock */ rcu_periph_clock_enable(RCU_ADC0); rcu_periph_clock_enable(RCU_ADC1); /* config ADC clock */ rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV16); /* ADC continous function enable */ adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE); adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE); adc_special_function_config(ADC1, ADC_SCAN_MODE, ENABLE); adc_special_function_config(ADC1, ADC_CONTINUOUS_MODE, ENABLE); /* ADC trigger config */ adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);//ADC0_1_EXTTRIG_REGULAR_NONE adc_external_trigger_source_config(ADC1, ADC_REGULAR_CHANNEL, ADC0_1_EXTTRIG_REGULAR_NONE);//ADC0_1_EXTTRIG_INSERTED_NONE /* ADC data alignment config */ adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT); adc_data_alignment_config(ADC1, ADC_DATAALIGN_RIGHT); /* ADC mode config,使用规则同步模式,ADC0是主,ADC1是从, 同时转换两个通道(同时转换的通道不能相同) */ adc_mode_config(ADC_DAUL_REGULAL_PARALLEL); /* ADC分辨率 12B */ adc_resolution_config(ADC0,ADC_RESOLUTION_12B); adc_resolution_config(ADC1,ADC_RESOLUTION_12B); /* ADC channel length config */ adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, 6); adc_channel_length_config(ADC1, ADC_REGULAR_CHANNEL, 0); /* ADC regular channel config,一个通道转换时长是2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4319850c543fde98dceb46a1cf6cbc69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b092db3a4b5a58b0e4cebb1775f515/" rel="bookmark">
			Android 8.0网络DNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Linux DNS规范
Linux上并没有一个单独的方法可以完成DNS查询工作；没有一个有这样的明确接口的核心系统调用system call。不过，glibc (nss)的getaddrinfo (3), gethostbyname (3)等相关API (RFC3493)提供了DNS查询功能。
1）不支持nscd（name service cache daemon）服务，那么这2个函数接口通过文件/etc/resolv.conf获取DNS服务器的IP地址，然后通过socket通信发送请求到该DNS IP地址去获取待查询域名的IP地址。
2）支持nscd服务（or dnsmasq），这2个函数接口发送请求给nscd，nscd再返回响应给请求者。
3）ping uses glibc gethostbyname()。
2 Android netd DNS
2.1 Android 4.3 DNS
Android 4.3 incorporated a somewhat confusing series of commits under the heading of "dns cache per interface," which effectively causes all Bionic DNS requests to be proxied through netd.
ANDROID_DNS_MODE=local
dumpsys connectivity
dumpsys netd
ndc tether dns set
ndc tether dns list
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40b092db3a4b5a58b0e4cebb1775f515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd691ec47b24ce8ccff4e91ef1552c1/" rel="bookmark">
			C语言学习之原码、反码、补码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、原码二、反码三、补码四、总结 一、原码 原码就是十进制数字的二进制表现形式。例如 int类型的数字，占用4个字节，一个字节又是8位，所以int类型的数字占用32位。
示例：10的原码
00000000 00000000 00000000 00001010 负数原码的最高位表示符号位，1表示为负数
示例：-10的原码
10000000 00000000 00000000 00001010 二、反码 正数的反码与原码一样。
例如上面10反码为：
00000000 00000000 00000000 00001010 负数的反码为最高位符号位保持不变，其余为取反。
例如上面的-10的反码为：
11111111 11111111 11111111 11110101 三、补码 正数的补码同原码、反码相同，保持不变。
例如上面10反码为：
00000000 00000000 00000000 00001010 负数的补码是其反码加1，变成补码。
例如上面的-10的补码为：
11111111 11111111 11111111 11110110 四、总结 对于正数而言，原码、反码、补码三码相同。
对于负数而言，最高位表示符号位，反码为符号位保持不变，其余位取反。补码为反码加上1。
计算机存储时，则是以补码的形式进行存储数字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76910cf4acc1dcd362477b5fa3d97be/" rel="bookmark">
			python每日一练：输入一个字符串，统计其中的小写字母，大写字母，空格键，以及其它字符，并在一行内输出统计的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a = str(input()) smallword = 0 bigword = 0 number = 0 blank = 0 others = 0 longth = len(a) #记录字符串的长度，后面用于遍历次数 #i作为字符串中的具体字符参加遍历 for i in a: #若i在‘abcdefghijklmnopqrstuvwxyz’里面则小写字母加1 if i in 'abcdefghijklmnopqrstuvwxyz' : smallword = smallword + 1 if i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' : bigword = bigword + 1 if i in ' ': blank = blank + 1 others = longth - smallword -bigword - blank print(' 小写字母 :',smallword,' 大写字母 :',bigword,' 空格键 :',blank,' 其它字符: ',others) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0247789258c26564da1394bb0f268430/" rel="bookmark">
			Elasticsearch&#43;Logstash&#43;Java整合实现Word、PDF，TXT等文件的全文内容检索功能-windows版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：概述 Elasticsearch：是一个开源的高扩展的分布式全文搜索引擎，它可以近乎实时的存储，然后检索数据，延迟很小。
Logstash: 实现将mysql或其他数据库的数据定时采集到Elasticsearch里。
ElasticHD：Elasticsearch的可视化工具，可以在界面条件查询查询Elasticsearch里的数据。
二：Elasticsearch安装部署 注意：因为ES是java开发的，所以需要安装jdk，安装完之后要配置环境变量，这个就不再赘述了，不会的可以从网上搜索怎么配置
1. 下载elasticsearch安装包（也可以自己去es官网下载）: elasticsearch-7.16.2-windows-x86-64-Java文档类资源-CSDN下载
2. 解压安装包到指定目录，我的目录是：D:\tool\elasticsearch-7.16.2
3. 进入bin目录，打开命令行（ps：在地址栏直接输入cmd，敲回车，就会在当前目录打开一个命令行窗口）
4. 在命令行输入：elasticsearch-service.bat install 把ES安装为服务
5. 启动 elasticsearch
方法一：进入bin目录，双击 elasticsearch.bat 启动该应用
方法二： 打开任务管理器，在服务栏里查看ES是否启动，没有启动，就启动
6. 直接访问 http://localhost:9200/ ，浏览器出现如下所示，表明成功
补充： 如果启动后报jdk相关的错（原因：es默认先使用本地jdk, 当本地jdk与其需要的版本不匹配则会报错；解决思路就是 让es使用自己自带的jdk,这样就需要修改配置文件，让其指向自己自带的jdk），则按如下方式解决：
步骤一：在系统环境变量里添加：
ES_HOME: D:\tool\elasticsearch-7.16.2\
ES_PATH_CONF: D:\tool\elasticsearch-7.16.2\config JAVA_HOME: D:\tool\elasticsearch-7.16.2\jdk
步骤二：按照如上配置后，bin目录下的elasticsearch-env.bat配置文件就会按照设置的目录去调用自带的jdk, 此时重新启动 elasticsearch即可。
三：Logstash安装部署 1. 下载Logstash安装包（也可以自己去es官网下载）: logstash-7.16.2-windows-x86-64版-Java文档类资源-CSDN下载
2. 将安装包解压到指定目录下，我的在：D:\tool\logstash-7.16.2
3. 进入到bin目录下，将 连接mysql数据库的驱动包（mysql-connector-java-5.1.39.jar） 放到该目录下
下载链接：
https://download.csdn.net/download/m0_37951794/87207721
4. 编写采集数据的sql, 并保存到 test.sql文件里，将test.sql文件放到新建的sqldir里，即 bin/sqldir/ test.sql
我test.sql里的内容是： select * from user
5. 修改bin目录下，logstash.conf 配置文件内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0247789258c26564da1394bb0f268430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7143f9843c7301da02f5efff1541ef95/" rel="bookmark">
			pinia安装使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pinia中文文档
目录
一.pinia简介
二. pinia安装
三.pinia使用
1.main.js中创建pinia实例
2.创建store状态库
定义state
state的读写
state响应式解构
state的修改
Getters的使用
Pinia中Store的互相调用
一.pinia简介 Pinia是vue生态里Vuex的替代者，一个全新的vue状态管理库。
Pinia·是·Vue 的存储库，它允许您跨组件/页面共享状态
(让你可以在页面间实现数据的共享)
二. pinia安装 npm install pinia package.json包中含有pinia
三.pinia使用 1.main.js中创建pinia实例 import { createApp } from 'vue' import App from './App.vue' import {createPinia} from 'pinia' const app = createApp(App) app.use(createPinia()) app.mount('#app') 2.创建store状态库 在src目录下创建一个store包
store下建user.js
定义state state是pinia的核心，是存储数据的地方，例如我们要存储一个user对象
import {defineStore} from 'pinia' import {ref} from "vue"; //第一种写法 export default defineStore('first',()=&gt;{ const name=ref('name') const age=ref(12) return {name,age} }) //第二种写法 export default defineStore('user',{ state:()=&gt;{ return { name:'name', age:12 } } }) state的读写 &lt;template&gt; &lt;a&gt;{{userStore.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7143f9843c7301da02f5efff1541ef95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b0336fd6970a47380b473c6a1f08f9/" rel="bookmark">
			SSM基本框架搭建，SSM的分页功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis分页插件的使用 (SSM) 1. pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis的分页插件依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b0336fd6970a47380b473c6a1f08f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf53c95f48f73612da8bf6535298885/" rel="bookmark">
			常见的统计学方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、大量观察法
这是统计活动过程中搜集数据资料阶段（即统计调查阶段）的基本方法：即要对所研究现象总体中的足够多数的个体进行观察和研究，以期认识具有规律性的总体数量特征。大量观察法的数理依据是大数定律，大数定律是指虽然每个个体受偶然因素的影响作用不同而在数量上几存有差异。
但对总体而言可以相互抵消而呈现出稳定的规律性，因此只有对足够多数的个体进行观察，观察值的综合结果才会趋向稳定，建立在大量观察法基础上的数据资料才会给出一般的结论。统计学的各种调查方法都属于大量观察法。
2、统计分组法
由于所研究现象本身的复杂性、差异性及多层次性，需要我们对所研究现象进行分组或分类研究，以期在同质的基础上探求不同组或类之间的差异性。统计分组在整个统计活动过程中都占有重要地位，在统计调查阶段可通过统计分组法来搜集不同类的资料，并可使抽样调查的样本代表性得以提高（即分层抽样方式）；
在统计整理阶段可以通过统计分组法使各种数据资料得到分门别类的加工处理和储存，并为编制分布数列提供基础；在统计分析阶段则可以通过统计分组法来划分现象类型、研究总体内在结构、比较不同类或组之间的差异（显著性检验）和分析不同变量之间的相关关系。统计学中的统计分组法有传统分组法、判别分析法和聚类分析法等。
3、综合指标法
统计研究现象的数量方面的特征是通过统计综合指标来反映的。所谓综合指标，是指用来从总体上反映所研究现象数量特征和数量关系的范畴及其数值，常见的有总量指标、相对指标，平均指标和标志变异指标等。
综合指标法在统计学、尤其是社会经济统计学中占有十分重要的地位，是描述统计学的核心内容。如何最真实客观地记录、描述和反映所研究现象的数量特征和数量关系，是统计指标理论研究的一大课题。
4、统计模型法
在以统计指标来反映所研究现象的数量特征的同时，我们还经常需要对相关现象之间的数量变动关系进行定量研究，以了解某一(些)现象数量变动与另一(些)现象数量变动之间的关系及变动的影响程度。
5、统计推断法
在统计认识活动中，我们所观察的往往只是所研究现象总体中的一部分单位，掌握的只是具有随机性的样本观察数据，而认识总体数量特征是统计研究的目的，这就需要我们根据概率论和样本分布理论，运用参数估计或假设检验的方法，由样本观测数据来推断总体数量特征。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a8fd251aa205de8f615e76a678ecdfd/" rel="bookmark">
			Apifox：详细使用教程，带你轻松拿捏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Apifox简介
Apifox的安装与使用
Apifox新建项目的流程
编写接口文档
Apifox简介 我们在日常编程开发过程中经常实行的是前后端分离架构的模式，一个项目的落地会通过产品、开发、测试三方会审，对项目需求评审过后，前后端开发会制定一些接口，他们通常会用以下方式：
开发指定接口文档（Reg）。
后端开发依据接口文档开发接口，一边开发一边测试（Postman）。
前端开发需要（Mock）数据供前端调用。
开发完成后，测试通过（Postman，Jmeter）去进行接口测试。
为了能让各个产品项目负责人落地更加便捷，Apifox应运而生实现了API设计开发测试一体化协作。俗称：Apifox=Postman+Swagger+Jmeter+Mock工具集。简而言之：开发人员在Apifox里定接口、前端直接根据Apifox去Mock数据、后端开发直接在Apifox进行调试、测试人员直接在Apifox的接口文档里面写用例、接下来就是前后端进行联调。
Apifox的安装与使用 安装的话就很简单了，百度搜索 Apifox ，或点击右侧的网址 Apifox网址 ，进入网址选择自己电脑适配的系统以及需求进行选择使用。
这边我电脑是 win64 ，所有这边我下载了桌面版64位，下载完成傻瓜式安装即可。安装完成进行注册登录，登录完成你会看到界面有一个个人项目，里面有一个项目案例给你简单介绍一下这个根据的简单使用。
给你一个简单的案例，呈现页面会出现哪些信息，让你初步了解一下。
对于页面的风格自己也可以进行设置， 打开设置对页面的主题颜色和字体大小可以自定义，还有一些其他的网络代理、证书代理调配等。
Apifox新建项目的流程 点击新建团队，创建新项目。
输入自己的团队名称，点击保存。
进入自己保存的团队：可以新建项目、可以定向邀请成员协同操作、可以修改团队名称移交或解散团队。
接下来新建项目，输入名称，项目图标自定，如果第一次使用可以允许包含示例数据，因为我这里没有定向邀请其他成员，项目中就只有我一个人，点击确认即可。
点击确认之后跳转到如下界面，因为上面我同意包含示例数据，所有在项目概览中的项目统计上数字不为0， 当前的项目可进行的操作很多，如下：
编写接口文档 基本信息填写
点击新建接口，进行编写接口文档。
因为本人服务器停运，这里借助黑马程序员某位老师的接口进行展示(doge)，这里填写最基本的信息。
确认信息无误后点击保存即可。
params参数设置
params参数有两种方式，一种是 url后面?之后的参数；另一种是 url中的{参数名}参数。
Body参数
Body参数可以根据自己的需求上传不同格式的文件信息。
这里借用上文提到的接口简单的演示一下，转成json格式的数据是什么样的。这个工具会将我们的数据自动解析并识别成json格式。
我们可以将自己接口上的list添加一下新的东西来验证返回成功的200数据，如下：
将响应成功的案例自动生成在下面：
为了方便区别自己的接口是否成功写入，可以写入一个错误的响应以及案例来进行区别，可以将错误的响应里面的内容删除一点，并根据错误的响应生成一个异常示例：
修改文档完成点击保存并点击运行进入运行页面，点击自动生成的数据，点击发送即可
没有问题点击保存为用例
也可以设置特殊情况，来保存成为错误的用例
也可以给测试的数据添加一些动态值来更好的处理一些情况
后置操作获取token值
我们在进行登录接口的测试时，可以通过后置操作获取其相应的token值，其操作和上文一样，编写相应的接口文档
通过后置操作获取其token值
Apifox的其他功能：
环境变量、全局变量、临时变量、动态变量、随机参数、自动化字段、socket接口、团队管理、导入导出、MOCK、脚本开发、自动化执行、Jenkins持续集成等
总结：
总的来说，Apifox这个工具的功能性还是很强大的，很多企业也开始使用这个工具，对于程序员来说，不善于接触新事物对自身的发展是不利的，这篇文章主要介绍了这个工具的基本使用，还有很多强大的功能没有在此体现出来，还是需要各位在工作中慢慢发掘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1229f2480a8fc97ad657180b02066ab2/" rel="bookmark">
			Word 中Mathtype按钮灰色不可用的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果电脑安装Word和MathType（64位或者32位）后，单独打开mathtype可以使用，但是在word中嵌入 MathType后，MathType在word中功能显示为灰色，无法进行公式编号等操作。解决办法如下：
步骤一：1.选择“工具”—“宏”—“安全性”。2.里把宏安全设置调低一点，如果出现对话框，选择“启用宏”。
步骤二：在Mathtype安装位置C:\Program Files(x86)\MathType\MathPage\64（如果是32位，在最后选择32）中拷贝MathPage.wll文件，然后粘贴到word安装位置中的C:\Program Files(x86)\Microsoft Office 2016\Office16\STARTUP文件夹中。
注：有时也需要将wll文件粘在Microsoft Office 2016\Office16文件夹中。
步骤三：在Mathtype安装位置C:\Program Files(x86)\MathType\Office Support\64（如果是32位，在最后选择32）中拷贝MathType Commands 2016文件，然后粘贴到word安装位置中的C:\Program Files(x86)\Microsoft Office 2016\Office16\STARTUP文件夹中。
步骤四：打开word，点击文件-&gt;选项-&gt;加载项，选择word加载项-&gt;添加，在文件夹C:\Program Files(x86)\Microsoft Office 2016\Office16\STARTUP\ MathType Commands 2016找到MathType Commands 2016，然后将添加后的MathType Commands 2016勾选，确定。
步骤五：重新打开word, Mathtype所有的功能就可用了。
Ps：如果重新打开word后mathtype仍灰色，确定上述操作没问题后。在Word加载项找到Mathtype Commands 2016所在的位置，将步骤二和步骤三中的文件都拷入进去即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde4735a0a9070ee2de28e92950e1c94/" rel="bookmark">
			Flutter桌面开发 - windows插件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过此篇文章，你将了解到：
Flutter插件的基本介绍；windows插件开发的真实踩坑经验。 ⚠️本文为稀土掘金技术社区首发签约文章，14天内禁止转载，14天后未获授权禁止转载，侵权必究！
前言 我们都知道，Flutter的定位更多是作为一个跨平台的UI框架，对于原生平台的功能，开发过程中经常需要插件来提供。不幸的是Windows的生态又极其不完整，插件开发必不可少。但网上windows的文章少之又少，所以本篇文章，我们一起来聊聊插件开发的一些技巧。
插件介绍 Flutter的插件主要分两种：package和plugin。
Package是纯dart代码的库，不涉及原生平台的代码；Plugin是原生插件库，是一种特殊的Package。Plugin需要开发者分别在各原生平台实现对应的能力。 其中Plugin是我们要着重讲的，既然是原生平台实现，那跟dart层就势必需要通讯。Flutter Plugin的通讯主要有：methodChannel、eventChannel、basicMessageChannel。
MethodChannel：同步调用的通道，调用后可以通过result返回结果。可以 Native 端主动调用，也可以Flutter主动调用，属于双向通信。这种通信方式是我们日常开发中为最常用的方式， 关键点是Native 端的调用需要在主线程中执行。EventChannel：异步事件通知的通道，一般是Native端主动发出通知，Flutter接收通信信息。BasicMessageChannel：长链接的通道，双端可以随时发出消息，对方收到消息后可以使用reply进行回复。一般常用于需要双向通信可不知道何时需要发送的场景。 windows插件编写 Flutter Android的生态算是比较完整的，而且网上95%的插件文章，都是以移动端为主，对于不熟悉Windows开发的同学极度不友好。因此本篇文章我们不讲Android端的实现，重点讲Windows端的实践，不过我也不是C++技术栈的，只能浅浅分享我踩过的坑。
如何创建通信通道？ // MethodChannel void XXXPlugin::RegisterWithRegistrar( flutter::PluginRegistrarWindows* registrar) { // 创建一个MethodChannel auto channel = std::make_unique&lt;flutter::MethodChannel&lt;flutter::EncodableValue&gt;&gt;( registrar-&gt;messenger(), "usb_tool", &amp;flutter::StandardMethodCodec::GetInstance()); // 创建插件对象 auto plugin = std::make_unique&lt;XXXPlugin&gt;(); // 把通道设置给插件，同时传入消息的处理入口 channel-&gt;SetMethodCallHandler( [plugin_pointer = plugin.get()](const auto&amp; call, auto result) { plugin_pointer-&gt;HandleMethodCall(call, std::move(result)); }); } // EventChannel // 创建事件流处理对象 auto eventHandler = std::make_unique&lt; StreamHandlerFunctions&lt;EncodableValue&gt;&gt;( [plugin_pointer = plugin.get()]( const EncodableValue* arguments, std::unique_ptr&lt;EventSink&lt;EncodableValue&gt;&gt;&amp;&amp; events) -&gt; std::unique_ptr&lt;StreamHandlerError&lt;EncodableValue&gt;&gt; { return plugin_pointer-&gt;OnListen(arguments, std::move(events)); }, [plugin_pointer = plugin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde4735a0a9070ee2de28e92950e1c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a655916bc2662c045beb81c92b9fa3d/" rel="bookmark">
			基于Android开发的记账软件（附带源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该app实现了用户添加删除、用户切换、收入记录、支出记录、查询等功能，适合新手学习。搭建方法请可查看主页中的android相关视频教程。
记账软件文件：url80.ctfile.com/f/25127180-738830071-d2178c?p=551685 (访问密码: 551685)
开发语言:
java
技术框架:
无
开发工具:
AndroidStudio2.2，新手最好使用此版本搭建，不同版本修改配置比较繁琐
Data Catalog 通过汇总技术和业务元数据，解决大数据生产者组织梳理数据、数据消费者找数和理解数的业务场景。本篇内容源自于火山引擎大数据研发治理套件 DataLeap 中的 Data Catalog 功能模块的实践，主要介绍 Data Catalog 在公有云部署和发布中遇到挑战及解决方案。
背景
Data Catalog 是一种元数据管理的服务，会收集技术元数据，并在其基础上提供更丰富的业务上下文与语义，通常支持元数据编目、查找、详情浏览等功能。目前 Data Catalog 作为火山引擎大数据研发治理套件 DataLeap 产品的核心功能之一，经过多年打磨，服务于字节跳动内部几乎所有核心业务线，解决了数据生产者和消费者对于元数据和资产管理的各项核心需求。
DataLeap 作为一站式数据中台套件，汇集了字节内部多年积累的数据集成、开发、运维、治理、资产、安全等全套数据中台建设的经验，助力 ToB 市场客户提升数据研发治理效率、降低管理成本。
Data Catalog 作为 DataLeap 的核心功能之一，本文汇集了 Data Catalog 团队在最近一年公有云从 0 到 1 实践的整体经验，主要讲解遇到的各项挑战和对应的解决方案。
Data Catalog 公有云发展历程
Data Catalog 已经随着 DataLeap 一起作为公有云产品正式在火山引擎对外发布，下面是 Data Catalog 在功能演进上的一些重要时间节点：
2021 年 9 月，Data Catalog 随着 DataLeap 完成在火山引擎公有云首个版本部署和发布，包含 60%内部核心功能，支持 EMR Hive 数据源元数据管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a655916bc2662c045beb81c92b9fa3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18a84a1af1dba9e367ef3e430a2e99f/" rel="bookmark">
			onnx模型推理及获得各层输出结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如标题所述，我们在代码中做了推量部分，并对于使用gpu还是cpu 做了一个自动处理，修改provider就可以，如果安装的onnxruntime是gpu版那么是调用gpu ,否则使用cpu;对于使用cpu时，开启了多线程，会加快推理速度。
import cv2 import os import glob import subprocess import numpy as np from tqdm import tqdm import onnxruntime as ort import onnx import sys import shutil def normalize(img,scale=None,mean=None,std=None): if isinstance(scale, str): scale = eval(scale) scale = np.float32(scale if scale is not None else 1.0 / 255.0) mean = mean if mean is not None else [0.485, 0.456, 0.406] std = std if std is not None else [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18a84a1af1dba9e367ef3e430a2e99f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e1bc0afcdc3c814a419ed307d7b3cd/" rel="bookmark">
			浅谈Angular中@ViewChild的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前置知识学习 @ViewChild是Angular一共提供的内置的装饰器
Angular提供的内置装饰器分为：类装饰器、属性装饰器、方法装饰器和参数装饰器
@ViewChild属于属性装饰器的一个
ViewChild 用来从模板视图中获取匹配的元素。视图查询在 ngAfterViewInit 钩子函数调用前完成，因此在 ngAfterViewInit 钩子函数中，才能正确获取查询的元素。
@Input() username:string; // @Input()这个装饰器用来对username进行操作，将父组件中传下来的值username赋值给username这个属性 // 当然我们还可以自定义一些属性装饰器。比如在下面实现的@Emoji()，这就是一个属性装饰器。 2 @ViewChild学习梳理 2.1 @ViewChild作用是什么 @ViewChild是Angular提供的用来从模板视图中获取匹配元素的一个属性装饰器。 用于配置一个视图查询。变更检测器会在视图的 DOM 中查找能匹配上该选择器的第一个元素或指令。如果视图的 DOM 发生了变化，出现了匹配该选择器的新的子节点，该属性就会被更新。 2.2 @ViewChild的参数说明 // 将查询到的第一个元素或者指令赋值给selector @ViewChild('searchText', {read: ElementRef, static: false}) selector; 2.2.1 read: 告诉@ViewChild你返回的是什么类型的数据 // 我想通过#myname去查询原始，并将返回ViewContainerRef类型 @ViewChild('myname', {read: ViewContainerRef}) target; read参数是可选的，因为 Angular 会根据 DOM 元素的类型推断出该引用类型。 一般Angular会推断出一些比较简单的类型如： ElementRef 、 TemplateRef一些引用类型如 ViewContainerRef 就不可以被 Angular 推断出来，所以必须在 read 参数中显式声明 一个字符串， 如果没有提供read参数确切的告知返回的元素是什么类型，则其返回实例类型按照以下顺序：
ElementRef实例, : (对于每个元素，都有一个ElementRef和ViewContainerRef)如果没有对应的ElementRef， 则匹配同名的组件 2.2.1 static …（还不确定后续再补）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e1bc0afcdc3c814a419ed307d7b3cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553e63adcd61fa29dad5755ae6e9ce5b/" rel="bookmark">
			js正则表达式密码校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码必须包含数字，特殊字符，小写字母，大写字母其中三项
const regex = /^(?![a-zA-Z]+$)(?![A-Z0-9]+$)(?![A-Z\W_!@#$%^&amp;*`~()-+=]+$)(?![a-z0-9]+$)(?![a-z\W_!@#$%^&amp;*`~()-+=]+$)(?![0-9\W_!@#$%^&amp;*`~()-+=]+$)[a-zA-Z0-9\W_!@#$%^&amp;*`~()-+=]/ regex.test(value) 分享一个vsCode小插件any-rule
包含八十多个正则表达式，前端开发绝大部分需要的正则表达式都包含
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a33f0be72cdb865afbc853d0b3a3b0/" rel="bookmark">
			js运算精度丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题所在：
解决方法1（低精度）：
toFixed介绍：
代码实现：
小结：
解决方法2（高精度）：
代码实现:
小结：
当两个数包含小数进行运算的时候结果并不是正确的结果，而是出现了精度丢失的情况（小数点后面出现很多位）。
问题所在： res.orderColorDeliveryRecords.forEach((item) =&gt; { //计算金额 item.money = (item.price * item.amount); if(!item.cusTypeName){ item.cusTypeName = 'N/A'; } this.record.money += parseFloat(item.money); }); 界面显示：
解决方法1（低精度）： 在运算结果的后面加上toFixed()，精度要求不高的情况下使用;
toFixed介绍： 用法： number.toFixed( value )
参数：此函数参数列表有一个参数，他表示小数点后面精确的位数。
返回值：他以字符串表示形式返回一个数字。
代码实现： res.orderColorDeliveryRecords.forEach((item) =&gt; { item.money = this.actionOperationResult(item.price , item.amount); if(!item.cusTypeName){ item.cusTypeName = 'N/A'; } this.record.money += parseFloat(item.money); }); 界面显示：
小结： 该解决方法只适用于低精度运算。并且有弊端，就如上图界面显示一样，最终运算结果是没有小数位的，还是将小数位给显示出来的。如果不在乎这些还是可以使用的。
解决方法2（高精度）： 先将运算值 x 10^n 转换成整数进行运算，最后将结果还原。精度要求高的推荐使用该解决方法。（代码实现只实现了乘法，需要其他运算的可以自行更改一下）
代码实现: actionOperationResult(val1, val2){ const p = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a33f0be72cdb865afbc853d0b3a3b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d28b0c5bce0fc525a1f3a7e3919b89/" rel="bookmark">
			websocket-前端代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.sinye.xyz/front-end/729.html
我纠结了很长时间要不要写这篇文章。因为，如果自己开发着玩，需要学的东西太多了，如果真正开发项目，肯定不是一个人能完成的，所以我写的这点皮毛根本不够用。
既然是我自己业余时间写这篇文章，那我就按照我开发这个’即时通讯’项目的流程简单描述一下。
1、页面先行 作为前端开发，没有页面怎么行，功能都是在静态页面的基础上添加的。
html: &lt;div class="wrapper"&gt; &lt;div class="container"&gt; &lt;div :class="'mask '+(user_list_bool?'active':'')" @click="user_list_bool=false"&gt;&lt;/div&gt; &lt;div :class="'left '+(user_list_bool?'active':'')"&gt; &lt;div class="top"&gt; &lt;div class=""&gt;在线人数：&lt;span id="numbers"&gt;{{userLength}}&lt;/span&gt; 人 &lt;/div&gt; &lt;/div&gt; &lt;ul class="people"&gt; &lt;li class="person flex_c_b" data-chat="person1" v-for="(item,index) in user_list" :key="index"&gt; &lt;div class="flex_c_s"&gt; &lt;img :src="item.headerimg" alt=""/&gt; &lt;div&gt; &lt;span class="name"&gt;{{item.username}}&lt;/span&gt; &lt;span class="preview"&gt;在线&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;span class="time"&gt;{{item.login_time}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;div class="top flex_c_b"&gt; &lt;span&gt;群名: &lt;span class="name"&gt;又甘又刻&lt;/span&gt;&lt;/span&gt; &lt;div class="chakang" @click="user_list_bool=true"&gt;&lt;div class="numbers"&gt;{{userLength}}&lt;/div&gt;在线&lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;van-pull-refresh v-model="isLoading" @refresh="onRefresh"&gt; --&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d28b0c5bce0fc525a1f3a7e3919b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327499f7d1ea8dc1201dc0df032c6980/" rel="bookmark">
			LSTM对比Bi-LSTM的电力负荷时间序列预测（Matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要：
1.电力负荷预测：
2.滑动窗输入结构的构建
3.LSTM
4.Bi-LSTM
5.程序运行结果：
6.代码展示
摘要： 本文使用LSTM和Bi-LSTM，以电力负荷预测为例对比了两者的预测性能，其中将电力负荷构造为滑动时间窗的形式作为网络输出输入，实现LSTM与Bi-LSTM网络的多输入单输出模型，相比于单输入单输出的模型有更高的准确性。本文的电力负荷滑动窗输入构建方式具有一定的参考价值。
1.电力负荷预测： 电力负荷预测是一种典型的时间序列回归预测任务。电力负荷预测是保证电力供需平衡的基础,并为电网、电源的规划建设以及电网企业、电网使用者的经营决策提供信息和依据。负荷预测分为长期、中期、短期和超短期负荷预测,预测对象包括系统负荷和母线负荷,由电网企业负责组织编制。大用户应根据有关规定,按时报送其主要接装容量和年、月用电量预测及日用电负荷变化过程。
2.滑动窗输入结构的构建 由于电力负荷具有很强的时间相关性，仅通过上一时刻的负荷预测下一时刻的负荷并不能有效的反应复杂的时间关系，同时也没有充分的利用历史负荷数据的全部信息。所以本文通过滑动时间窗技术将多个历史时间内的负荷情况组合起来，预测下一时刻的负荷情况，并不断向前移动，以完成全天内的负荷预测。具体的构造方法如下：
如上图所示，在t时刻时黄色每一个小框都表示一个时间节点的输入数据，蓝色的小框表示输出数据，将3个黄色小框作为输入预测蓝色小框中的数据；而在t+1时刻，整体往前移动一个时间节点，以此不断前进，直到预测完全体的数据。
3.LSTM 传统RNN网络由于结构存在固有缺陷，在参数更新时会存在梯度消失以及梯度爆炸的问题，导致长距离的历史信息丢失，进一步造成网络极难收敛，无法训练出理想的模型。LSTM作为一种改进的循环神经网络，在原有网络结构的基础上加入了细胞状态(cell state)的结构来控制全局信息的传输，并通过遗忘门，输入门，输出门三种门控单元控制细胞状态信息值的更新。LSTM在极大程度上缓解了传统RNN模型存在的长期依赖问题，减少了长距离历史信息的丢失，输出的预测结果更准确 。LSTM的具体模型如下：
LSTM通过以下公式进行更新权值矩阵和偏置参数等网络信息：
4.Bi-LSTM Bi-LSTM 神经⽹络结构模型分2个独⽴LSTM，输⼊序列分别以正序和逆序输⼊⾄2个LSTM神经⽹络进⾏特征提取，将2个输出向量（即提取后的特征向量）进⾏拼接后形成的词向量作为该词的最终特征表达。Bi-LSTM 的模型设计理念是使 t 时刻所获得特征数据同时拥有过去和将来之间的信息，实验证明，这种神经⽹络结构模型对⽂本特征提取效率和性能要优于单个 LSTM 结构模型。
5.程序运行结果： 本文的数据集是一个包含60日的电力时间序列负荷数据，数据的颗粒度为15min，一天中共有96个点，使用前59日的数据进行训练，用最后一日的数据作为测试集进行负荷预测。滑动时间窗口大小设置为8，即过去两个小时内的负荷预测下一时刻的负荷。
6.代码展示 代码中的输入与输出改为自己的数据即可实现不同的功能，其中滑动窗的大小设置也可根据自己的需要修改。
部分代码：
clc; clear; close all; %% 导入数据 load DATA; % 导入60天的负荷数据 figure(1); plot(fuhe); legend('电力负荷'); xlabel('时间(15min)'); ylabel('功率(Kw)'); title('60日总负荷数据'); %% 数据归一化处理 % 归一化到0-1之间 Temp = fuhe; [~,PS] = mapminmax(fuhe,0,1); Temp = mapminmax('apply',Temp,PS); %% 输入输出构建及滑动时间窗输入结构构建 %数据分组 Windows = 8; %时间窗长度 T = 96; %预测未来一天(15min一次) %各个输入集合大小 X_Train = cell(size(Temp,2)-T-Windows,1); % 训练数据 Y_Train = cell(size(Temp,2)-T-Windows,1); % 测试数据 X_Test = cell(T,1); Y_Test = cell(T,1); % 训练数据构建 clc;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327499f7d1ea8dc1201dc0df032c6980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fcd821bcbe5a0c7c4c90e0100b1f0cb/" rel="bookmark">
			Go语言 映射(Map)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		映射是一种数据结构，它是一种元素对的无序集合，每一个索引(key)**对应一个值(value)**，这种数据结构在 Go 语言中被称之为 map。
映射强大的地方是能够基于键快速检索数据。键就像索引一样，指向与该键关联的值。
内部实现 映射是一个集合，可以使用类似处理数组和切片的方式迭代映射中的元素。但映射是无序的，即使使用同样的顺序保存键对，在每次迭代映射的时候顺序也有可能不一样。因为映射实现使用的是哈希表。
哈希表是什么不用过多介绍了，没了解的给一个传送门再自行了解什么是哈希表
哈希表，百度百科介绍
创建和初始化 使用make关键字 // 使用make关键字 // 创建一个映射，键类型是string,值类型是int mobile := make(map[string]int) fmt.Println(mobile) // map[] // 使用映射字面量 // 创建一个映射，键和值类型都是string dict := map[string]string{"apple": "iPhone14 Pro", "huawei": "meta40 Pro"} fmt.Println(dict) // map[apple:iPhone14 Pro huawei:meta40 Pro] fmt.Println(dict["apple"]) // iPhone14 Pro 使用映射字面量 最常用的方法是使用映射字面量。映射的初始长度会根据初始化时指定的键值对的数量来确定。
映射的键不能是切片，函数以及包含切片类型的结构类型，因为这些是具有引用语义，不能作为映射的键。
// 创建一个映射，使用字符串切片作为映射的值 dict2 := map[int][]string{0: {"apple", "huawei"}, 1: {"oppo", "xiaomi"}} fmt.Println(dict2) // map[0:[apple huawei] 1:[oppo xiaomi]] 使用映射（Map） Map中的元素通过key对应的下标语法访问
map[key] 赋值 map[key] = value 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fcd821bcbe5a0c7c4c90e0100b1f0cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee2a816235ab34e0ebf93f9437ccee3/" rel="bookmark">
			CTF解题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一题说：右键用不了，肯定是无法查看页面源代码，直接F12查看flag或者抓包数据得到flag。
第二题：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹
点进去链接，看了看只有报表中心可以打开 进入之后一脸懵，但说是送分题，试了试在上面url处可以修改id的值，于是尝试了爆破，破解出id的不一样的长度id：2333.
将上面id值改为2333，访问得到了flag。
第三题：点击链接后一脸懵，但我看到题目提示肯定用php，于是我加了后缀index.php发现没啥变化，于是就不会了，看了一些大佬的提示，有的是扫目录或者是不断在php后面加后缀，于是得到了index.phps发现出现了一些代码，查看网页源代码进行审计。
毕竟还学过一段时间PHP，还是可以看懂，只是某些函数有点懵，这时百度查看解释即可
urlencode()函数原理就是首先把中文字符转换为十六进制，然后在每个字符前面加一个标识符%。 urldecode()函数与urlencode()函数原理相反，用于解码已编码的 URL 字符串，其原理就是把十六进制字符串转换为中文字符 该代码的意思时不能将id的值通过get传给admin，但必须让admin等于get传值，又由于传得值会经过url解码，（我又得知浏览器会对写入的东西进行一次url解码），因此必须传值的时候进行两次url编码才可以，即对admin进行两次url编码即可。
于是我在网上找到了在线编码工具进行了两次编码。
最终得到如图结果，将该结果输入到网址上：（得到flag）
补充：phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，
所以需要用phps文件代替。其实，只要不用php等已经在服&gt; 务器中注册过的MIME类型为文件即可，但为了国际通用，所以才用了phps文件类型。
它的MIME类型为：text/html, application/x-httpd-php-source, application/x-httpd-php3-source。
第三题（挺开心的，这是自己独立解决的自认为的难题吧...）：点开链接访问后，看到一连串英文，直接有道翻译。
意思为：在这个小小的训练挑战中，您将了解Robots_exclusion_standard。
robots.txt文件被网络爬虫用来检查他们是否被允许抓取和索引你的网站或只允许部分。
有时，这些文件揭示了目录结构，而不是保护内容不被抓取。
看到这里我仍然一脸懵，于是我就复制Robots_exclusion_standard去csdn上了解，初步了解了有关爬虫的知识，知道了robots.txt文件就是对爬虫的行为做出一定的限制，这种限制称为机器人排除标准。
在这个文件中会有一些基本格式：（用于说明哪些是爬虫不能访问的，即让其忽略特定的或者所有的文件目录）
User-agent: * Disallow: / 接下来我了解到在网站的基本地址后面加上robots.txt，就能看到各个网站的robots.txt 文件
即看到会让爬虫忽略的文件目录，于是我尝试输入robots.txt后缀，得到如图
可以看到该文件中，不想让我们访问flog，那我们便可以在网址后面加上flog.php，然后我得到了flag
第五题：（可以说非常简单了）
这提示的很明显，直接在上方按正确格式输入即可
这是页面又让你用post传值方式，直接F12，在hackber中的post数据输入，运行即可。
第六题：（同样简单）
打开后发现如图问题，对于我这菜鸟来说肯定不知道，直接度娘搜索得知要添加bak后缀，于是我在上面网址后面输入改后缀，发现自动下载来个文件，直接以记事本形式打开，得到了flag。
常见备份文件后缀名为：常见的备份文件后缀名有：“.git” 、“.svn”、“ .swp”“.~”、“.bak”、“.bash_history”、“.bkf”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0663bbff736ff4d39e49228a750135/" rel="bookmark">
			centOS环境下MySQL查询、修改初始密码，或解决1820错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们刚在centOS环境下安装好MySQL时，系统提示我们输入密码，这个初始密码那里去找呢？让我们先启动服务：
systemctl start mysqld 这里做一个查询，检查是否启动 命令： systemctl status mysqld 然后我们通过下面的命令去查找初始密码，
cat /var/log/mysqld.log 红框内一串长相很奇怪的字符串就是初始密码：
[root@atdajv ~]# cat /var/log/mysqld.log 2022-11-27T09:36:36.191585Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.25) initializing of server in progress as process 3999 2022-11-27T09:36:36.202246Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started. 2022-11-27T09:36:36.595083Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended. 2022-11-27T09:36:37.703825Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: P!gfqAteJ4w2 然后就可以用这个初始密码，用 mysql -uroot -p 去登录了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b0663bbff736ff4d39e49228a750135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ff772998e4a41f28cd6998ff860bbde/" rel="bookmark">
			YOLO X 改进详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLO X 主要改进：
Anchor-Free: FCOSDecoupled detection headAdvanced label assigning strategy Network structure improvement Decoupled detection head 对比于YOLO V5, YOLO X 在detection head上有了改进。YOLO V5中，检测头是通过卷积同时预测分类以及定位任务，即通过同一个卷积来处理。
YOLO X 则使用了解耦的检测头，即，分类，定位，置信度预测由不同的卷积层来处理。同时，YOLO X 是anchor free的检测器，因此对于定位的输出仅仅只有4个参数，这个区别于YOLO V5 anchor-based 检测，每个cell 是基于3个anchor进行定位预测。YOLO X的三个检测头的权重不共享。文中实验表明，采用解耦的检测头，网络更容易收敛且准确率有了一定的提高。
Anchor-free 对于定位模型预测4个数 ( t x , t y , t w , t h ) (t_x, t_y, t_w, t_h) (tx​,ty​,tw​,th​). 因为是anchor-free，所以对于预测框的高度和宽度区别于YOLO V5基于anchor的缩放，在YOLO X中则是直接输出预测框的高和宽。
Loss Function Loss function 包括三个部分，Class loss function, Region loss function, IoU loss function (置信度).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ff772998e4a41f28cd6998ff860bbde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd465530253a1a2cec9310ab2a4671b2/" rel="bookmark">
			VS2019中配置opencv4.5.4（C&#43;&#43;)环境（一劳永逸的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、默认安装好vs2019和opencv4.5
2、创建项目
3、创建属性表
4、配置属性表
4.1 VC++目录-包含目录、库目录
4.2 输入-附加依赖项
5、环境变量设置
6、重启VS2019测试
7 导入已有属性表（一劳永逸）
1、默认安装好vs2019和opencv4.5 2、创建项目 创建新项目
控制台应用
项目名称和路径
x64
3、创建属性表 视图-其他窗口-属性管理器
添加新项目属性表
重命名和路径
4、配置属性表 双击打开属性页
4.1 VC++目录-包含目录、库目录 包含目录：添加opencv安装目录下，build\include路径。
库目录：添加opencv安装目录下，build\x64\vc15\lib路径。
4.2 输入-附加依赖项 将路径下的文件名复制到附加依赖项中。
5、环境变量设置 高级系统设置-环境变量
6、重启VS2019测试 #include&lt;opencv2/opencv.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; int main() { Mat src = imread("data/1.jpg"); //图片路径 if (src.empty()) { printf("could not find image file"); return -1; } imshow("image", src); waitKey(0); return 0; } 7 导入已有属性表（一劳永逸） 添加之前设置的属性表，一般在前面添加属性表项目的文件下。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/112/">«</a>
	<span class="pagination__item pagination__item--current">113/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/114/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>