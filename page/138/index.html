<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fa889080f9328593fd9e01453e768d/" rel="bookmark">
			单片机控制光耦开关继而控制电机转动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验二 单片机控制光耦开关继而控制电机转动
一、功能实现 通过开关控制单片机输出高低电平，继而控制光耦和继电器开关，从而实现控制电机转动。
二、电路原理 当单片机检测到开关闭合时（P1.2引脚检测到低电平），单片机会输出一个高电平（P2.2引脚置高），故后面连接的三极管导通，光电耦合器导通，从而使后面电路的三极管导通，继电器闭合，所以电机开始转动。同理，当单片机检测到开关断开时（P1.2引脚检测到高电平），单片机会输出一个低电平（P2.2引脚置低），故后面连接的三极管截止，光电耦合器断开，从而使后面电路的三极管截止，继电器断开，所以电机停止转动。使用光电耦合器件实现了隔离作用，避免后面的电路对前面的电路产生影响，使用继电器是因为提高驱动能力，为电机提供足够大的电流。
三、电路原理图 四、物料清单（小器件未计成本） 五、仿真工具选择论述 现有的主流仿真工具有Altium Designer、Multisim、Proteus、Cadence、LTspice、Electronic Workbench、Matlab、TINA-TI、Infineon Designer。此次仿真我使用Proteus，Proteus 软件是英国 Lab Center Electronics 公司出版的 EDA 工具软件，支持电路图设计、PCB 布线和电路仿真。Proteus 支持单片机应用系统的仿真和调试，使软硬件设计在制作 PCB 板前能够得到快速验证，不仅节省成本，还缩短了单片机应用的开发周期。Proteus 是单片机工程师必须掌握的工具。Proteus 软件分为 ARES 和 ISIS 模块，ARES 用来制作 PCB，ISIS 用来绘制电路图和进行电路仿真。
六、仿真结果 1、开关闭合时仿真，电机转动（最终达到500转/s）
2、开关断开时，电机停止转动
程序代码 //单片机:AT89S52
//系统晶振:12MHz
#include &lt;reg52.h&gt;
#define uchar unsigned char
#define uint unsigned int
//引脚定义
sbit switch_1=P1^2;
sbit motor=P2^2;
//功能:延时1毫秒
//入口参数:x
//出口参数:无
void Delay_xms(uint x)
{
uint i,j;
for(i=0;i&lt;x;i++)
for(j=0;j&lt;112;j++);
}
//功能:电机开
void Motor_On(void)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33fa889080f9328593fd9e01453e768d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae70ee3d20f8093ad2cb398dd5481d10/" rel="bookmark">
			不要再重复造轮子了，这16个Java常用工具类，让生产力爆表。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：轮子。
如果在我们的日常工作当中，能够将这些轮子用户，再配合一下 IDEA 的快捷键，可以极大得提升我们的开发效率。
今天我决定把一些压箱底的小工具，分享给大家，希望对你有所帮助。
工具类 1、Collections 首先出场的是 java.util 包下的 Collections 类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。
① 排序 在工作中经常有对集合排序的需求。
看看使用 Collections 工具是如何实现升序和降序的：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); // 升序 Collections.sort(list); System.out.println(list); // 降序 Collections.reverse(list); System.out.println(list); 执行结果：
[1, 2, 3] [3, 2, 1] ② 获取最大或最小值 有时候需要找出集合中的最大值或者最小值，这时可以使用 Collections 的 max 和 min 方法。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Integer max = Collections.max(list);//获取最大值 Integer min = Collections.min(list);//获取最小值 System.out.println(max); System.out.println(min); 执行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae70ee3d20f8093ad2cb398dd5481d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3f81569a50096068f1eb7155aaaa44/" rel="bookmark">
			打印服务IP设置方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.右键网络，打开网络和intenet 设置
2.打开更改适配器选项
3.查看本机IP地址
打开后查看详细信息
4.查看IP地址和DNS地址
5.回退到刚才的页面
6.使用固定IP，将刚才看到的IP地址填进去
上面弄好后，点击高级
再加一个IP地址，要和打印机的前面一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f0e89de800a8854e20679987c1ca88/" rel="bookmark">
			细数软件研发效能的七宗罪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写了两篇文章，分别介绍 “软件研发效能的负面清单”、“软件研发的十大浪费”，今天算是对软件研发效能的负面东西做一个总结，挖掘出背后的原因。从本质上看，都是人性的弱点，这些弱点成为软件研发效能的阻力，甚至把软件研发效能拖下水。
一宗罪：自私
为了自己升职或保自己的位置，希望自己的团队快速扩展，自己管的人越多越好，而不管效能是否低下；具体讨论，可以参考之前写的一篇文章：许多研发管理者并不想提升研发效能，这才是最大的问题！
“各人自扫门前雪，休管他人瓦上霜”，有些管理者，只关注自己一亩三分地，而不管全局利益，局部效能看似不错，但整体效能上不去，甚至会产生严重的冲突，1+1&lt;2, 而不是1+1&gt;2；
资源浪费：自己有好的资源（包括人力资源）、好的学习材料占为己有，而不会主动向大家喊：这里有好的资源、好材料，你们想用吗？
缺少分享精神。做出好的设计、写出好的代码，从中获得的经验和启发不愿分享，甚至都不想让同事知道。
二宗罪：爱面子、虚荣心作祟
形象工程：愿意花巨资建一个大屏幕，呈现一些漂亮的数字，如100%自动化测试率、100%版本构建成功率、每天发布10个版本、一次发布平均高达10个用户故事......但交付的质量如何？是不是用户想要的？用户满意度如何？一些关键的数据倒是没有；例如100%自动化测试率，而实际测试的投入成本居高不下，效能其实不高。
追求好看的指标和有利于自己的解读：即使是相同的数据，看我们怎么解读，如果只是为了好看，就会有好的解读。而且想要什么就度量什么，如果只是想要好看，你就会度量有利于自己的指标，甚至我们都不能低估人们在追求“好看指标”上的“创造性”。但实际上，我们往往希望数据帮我们发现问题，和“爱面子”相反。
喜欢大而全的平台（包括开发平台、效能平台、度量平台、测试平台），而不是专而精的工具，造成平台使用麻烦、流转效率低下；
有些工程实践也是为了充门面，常常沦为一种形式或只是口号，甚至滥竽充数，包括效能度量、单元测试、自动化测试，演示起来很漂亮，但实际项目中则一塌糊涂，而且自己内心还不一定认可其价值。有些文档制作得很漂亮，却是为了应付一些所谓的国际认证、内部审查而事后补做的，所以实质上没有提升效能，反而严重拖效能的后腿。
三宗罪：欲望
欲望永远填不满，为了填充一些人的欲望，软件研发常常付出不少代价。
如占有欲，有些工作（包括工作岗位，如开发经理、测试经理等）不适合他，但因为来得早，占了天时地利，却迟迟不愿让出来，阻碍着研发变革（如开发和测试的融合）。
有些工作完全则是为了满足自己的金钱欲望，例如，重复造轮子是为了自己的业绩，为了自己能涨工资和获得奖金，其实市面上已有现成的且好用的工具（领导可能不知道），自己造出的轮子还没有开源的工具好用（领导可能不知道）；
四宗罪：喜新厌旧
喜欢写新代码，开发新功能，代码不断累积，但从不优化，这样就导致了一个臃肿、脆弱的代码基础，难以进行有效地维持。
追求新的技术、新的编程语言、新的设计模式，不断尝试新的东西，不断在不同的技术、语言和模式之间切换，浪费了多少代码和多少时间，全然不顾；而且新的技术不成熟，让系统的质量不稳定，甚至很糟糕，导致大量的返工。
五宗罪：骄傲、盲目自大
盲目迷恋自己工具，即使很难用，也不舍得抛弃，结果劣币淘汰良币；
总觉得自己做的设计或写的代码就是好，测试人员发现缺陷，不怀疑自己的代码，反而是质问测试人员：你是不是搞错了？从而影响沟通和协作，降低研发效能。
六宗罪：崇洋媚外
拿来主义：不管上下文，只要是欧美大厂（如Google、Apple、Amazon等大厂）的实践就是好实践，拿来就用。一些中小型企业的研发团队不了解自己的团队，不了解自己所处的环境，照搬欧美大厂（甚至国内大厂）的实践，导致水土不服，效能不升反而下降。殊不知，南橘北枳。正如同样的药给大象吃可以治病，而给你吃可能直接丧命。不变革等死，但变革不对，会死得更快。变革是需要，一定要因地制宜。别人的经验可以参考，要弄清楚上下文，然后进行调整。适合自己的路终究要靠自己走出来，拔苗助长只能是昙花一现。
不懂装懂，盲目跟风，不了解某种实践的起源，解决的是什么问题，只要人们说好的，只要大家都在用，就拿来用，也有可能一命呜呼。
七宗罪：懒惰
懒惰是万恶之源，可见懒惰带来的危害之大。
能偷懒就偷懒。写代码时没有验证输入这样的错误常常犯，病从口入，许多普通的安全漏洞（如缓冲区溢出、SQL注入攻击等）、因空指针导致系统崩溃，都是因为“没有验证输入”。代码缺少注释行，代码可读性差，单元测试能不做就不做，代码评审走过场，... 都是由懒惰造成的。
通过这篇文章和下面4篇文章，我们比较彻底地了解软件研发的本质和软件研发效能负面的方方面面，下周我们开始考虑如何克服这些问题、把软件研发拉上正道，如何持续提升效能...
软件研发效能的底层逻辑
直击灵魂：软件研发的第一性原理与10倍效能
软件研发效能的负面清单：哪项是头号敌人？
软件研发的十大浪费：研发效能的另一面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/222c7a2c304ab71f5ebb97ca44e0f026/" rel="bookmark">
			Html .CSS JQUERY （magnifier）实现详情页面特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、jquery使用技巧 1、jquery操作css
2、jquery hover()方法
3、轮播图插件unslider
4、jqeury click()方法（扩展：方法的重载overload）
5、图片放大插件jQueryMagnifier
6、jquery设置内容和属性
7、jquery添加、删除元素
二、任务 1、首页（轮播图、鼠标悬停效果）
（1）读一遍轮播图的demo代码（页面标签元素、标签样式效果、jquery代码）
jquery轮播图插件unslider
（2）准备并配置好插件的相关文件（js文件、图片）
（3）粘贴demo代码
（4）修改属性（高宽、颜色、形状等CSS样式）和参数（id名称、class名称、图片路径）
2、商品详细页面（商品重量样式切换、图片放大镜）
（1）准备并配置好插件相关文件（css、js、图片）
（2）编写html和js代码
注意：修改css里的图片路径和html里的图片路径
（3）图代码，并修改相关属性参数（高宽、颜色、形状等CSS样式）
扩展作业：
（1）重载的定义：
概念： 在同一的类中，允许在一个以上的同名方法，只要他们的参数的个数或者参数类型不同即可 特点：与返回值类型无关，只看参数列表，切参数列表必须不同。（参数个数或参数类型）。调用时，根据方法参数列表的不同来区分；
（2）用重载实现：在js中用方法重载实现，设置边框宽度（1个参数上下左右全一样，2个参数先上下后左右，4个参数上右下左）
三、实现过程代码 .html jquery
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;商品详情(总)&lt;/title&gt; &lt;link rel="stylesheet" href="css/common.css"&gt; &lt;link rel="stylesheet" href="css/detail1.css"&gt; &lt;script src="js/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="css/magnifier.css"&gt; &lt;script src="js/jquery-3.6.0.min.js"&gt;&lt;/script&gt; &lt;script src="js/magnifier.js"&gt;&lt;/script&gt; &lt;style&gt; .cl{ color: #FF5722; background: #FFFFFF; border: 3px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/222c7a2c304ab71f5ebb97ca44e0f026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04b3cf57b5960fd26902a340b27ff85/" rel="bookmark">
			ubuntu20.04 cuda opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个编译目录，并进入。
cuda的安装建议从官网上直接下载run文件，一次性完成cuda nvcc等的安装。
CUDA Toolkit 11.7 Downloads | NVIDIA Developer
wget https://developer.download.nvidia.com/compute/cuda/11.7.0/local_installers/cuda_11.7.0_515.43.04_linux.runsudo sh cuda_11.7.0_515.43.04_linux.run 默认全选安装，建议不要修改。
安装完cuda toolkit之后安装一些必要的软件包，此处如果安装失败，可以多试几次或者换一下源。
# Install prerequisites sudo apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp;\ apt-get install -y \ build-essential \ unzip \ yasm \ pkg-config \ libswscale-dev \ libtbb2 \ libtbb-dev \ libjpeg-dev \ libpng-dev \ libtiff-dev \ libavformat-dev \ libpq-dev \ libxine2-dev \ libglew-dev \ libtiff5-dev \ zlib1g-dev \ libjpeg-dev \ libavcodec-dev \ libavformat-dev \ libavutil-dev \ libpostproc-dev \ libswscale-dev \ libeigen3-dev \ libtbb-dev \ libgtk2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04b3cf57b5960fd26902a340b27ff85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2debb2083f63ba158fd6d203f2f3ed/" rel="bookmark">
			【论文学习】mixup系列（mixup、cutMix、manifold mixup、patchUp、saliencyMix、puzzleMix、co-Mixup、FMix）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mixup是一种简单而又有效的数据增强方法，涨点利器，该方法在图像、文本、语音、推荐、GAN、对抗样本防御等多个领域都能显著提高效果。mixup论文被ICLR2018收录，后续又出现了一系列改进方法。我在本文中详细分析讨论了mixup，并介绍了几种典型的改进方法。
文章目录 一、mixup1, mixup方法2, mixup的讨论2.1 mixup效果如何？2.2 为什么使用Beta分布？2.3 参数 α \alpha α有何影响，如何选择？2.4 是否可以使用多个样本混合？2.5 为什么要使用凸组合？ 二、mixup的后续改进1, 各改进方法简介1.1 cutMix1.2 manifold mixup1.3 patchUp1.4 puzzleMix1.5 saliency Mix1.6 fMix1.7 co-Mix 2, 各改进方法对比 三、读后感 一、mixup 论文(ICLR2018收录，arxiv发表时间：2017-10-25)：https://arxiv.org/abs/1710.09412
源码(698星)：https://github.com/facebookresearch/mixup-cifar10
1, mixup方法 mixup对两个样本-标签数据对按比例相加后生成新的样本-标签数据：
x ~ = λ x i + ( 1 − λ ) x j \tilde{x} = \lambda x_{i} + (1- \lambda) x_{j} x~=λxi​+(1−λ)xj​, 其中 x x x为输入向量
y ~ = λ y i + ( 1 − λ ) y j \tilde{y} = \lambda y_{i} + (1- \lambda) y_{j} y~​=λyi​+(1−λ)yj​, 其中 y y y为标签的one-hot编码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc2debb2083f63ba158fd6d203f2f3ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e8e84bcf2ab3d09963ec44dc450f0f/" rel="bookmark">
			vscode运行卡顿解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡顿原因 主要是rg.exe扩展程序占用CPU过高，那么只需要禁用它即可。
解决方案 打开 vs code ，文件-&gt;首选项-&gt;设置-&gt;搜索“search.followSymlinks”取消勾选即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724b2da4c662a9042e28672cb3e484a9/" rel="bookmark">
			https证书-openssl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页的http-&gt;https 1.生成根证书密钥 # 生成rsa私钥，openssl格式,4096位强度，*.key是密钥文件名 openssl genrsa -out ca.key 4096 2.生成自签名根证书 # 生成的ca.crt文件是用来签署下面的server.csr文件。 openssl req -new -x509 -days 3650 -key ca.key -out ca.crt 3.使用根证书来签名其它证书 # 生成证书密钥 openssl genrsa -out server.key 4096 # 执行这条命令需要依次输入国家、地区、组织、email，common name可以写名字或者域名。如果为了https申请，必须和域名相吻合 新建san.conf，并加入以下内容 [req] default_bits = 4096 distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] countryName = country stateOrProvinceName = province localityName = city organizationName = company name commonName = domain name or ip [v3_req] subjectAltName = @alt_names [alt_names] IP.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/724b2da4c662a9042e28672cb3e484a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85c76e9ae5df6bba3d49dcd8d54a649/" rel="bookmark">
			[Vue warn]: Duplicate keys detected: ‘/‘. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题报错：
每点击一下菜单，包括一级菜单，二级菜单，都会报这个错，但是不影响使用。
问题寻找：在src文件里面的layout里面的components里面的Sidebar里面的SidebarItem.vue文件里面的v-for。
原因：v-fo重复key检测，可能造成更新错误，是因为绑定的key值问题，key值不唯一。
&lt;template&gt; &lt;div v-if="!item.hidden"&gt; &lt;!-- 目录 --&gt; &lt;template v-if="hasOneShowingChild(item.children,item) &amp;&amp; (!onlyOneChild.children||onlyOneChild.noShowingChildren)&amp;&amp;!item.alwaysShow"&gt; &lt;app-link v-if="onlyOneChild.meta" :to="resolvePath(onlyOneChild.path)"&gt; &lt;el-menu-item :index="resolvePath(onlyOneChild.path)" :class="{'submenu-title-noDropdown':!isNest}"&gt; &lt;item :icon="onlyOneChild.meta.icon||(item.meta&amp;&amp;item.meta.icon)" :title="onlyOneChild.meta.title" /&gt; &lt;/el-menu-item&gt; &lt;/app-link&gt; &lt;/template&gt; &lt;!-- 菜单 --&gt; &lt;el-submenu v-else ref="subMenu" :index="resolvePath(item.path)" popper-append-to-body&gt; &lt;template slot="title"&gt; &lt;item v-if="item.meta" :icon="item.meta &amp;&amp; item.meta.icon" :title="item.meta.title" /&gt; &lt;/template&gt; &lt;!-- 原key --&gt; &lt;!-- &lt;sidebar-item v-for="child in item.children" :key="child.path" :is-nest="true" :item="child" :base-path="resolvePath(child.path)" class="nest-menu" /&gt; --&gt; &lt;!-- 修改后的key --&gt; &lt;sidebar-item v-for="child in item.children" :key="child.id" :is-nest="true" :item="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85c76e9ae5df6bba3d49dcd8d54a649/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb75e69ea50d55cd82545c2b5185e49/" rel="bookmark">
			C&#43;&#43; 实现lambda递归调用（C&#43;&#43;11 - C&#43;&#43;23）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言前置知识 C++11，借助std::functionC++14，基于Y不动点组合子（Y Combinator）科里化直接传入打包关于返回值推断 C++23 借助Deducing this实现lambda递归 前言 众所周知，C++11起出现了 lambda表达式 ，或者叫闭包，使得C++函数式编程的实现更为容易。本文不对lambda表达式的历史意义以及工程意义做过多探讨，只是给大家介绍一下如何递归调用lambda表达式。关于lambda表达式的基本用法，敬请移步 cppreference或相关博客，本文默认读者具有最基本的lambda语法认识。
我们知道，倘若直接如同普通函数一般在函数体内尝试递归调用是会语法错误的，无论是采用引用捕获亦或是值捕获都无法完成，此处不做赘述。因此我们需要借助别的东西来实现递归调用。
前置知识 阅读本文，你需要有：
相当基本的C++语法基础十分基本的C++ lambda表达式语法基础非常基本的递归函数认识最为基本的中文基础 C++11，借助std::function 以斐波那契数列为例，我们可以使用lambda表达式来构造一个 std::function 对象，如同这样：
#include &lt;iostream&gt; #include &lt;functional&gt; int main(int argc, char* argv[]) { std::function&lt;int(int)&gt; fib = [&amp;fib](int n) { return n &lt; 2 ? n : fib(n - 1) + fib(n - 2); }; std::cout &lt;&lt; fib(5); return 0; } 不过很显然，这种方法从声明形式上来看并不是那么优雅，从书写形式上来看，右边lambda写了一遍的函数签名左边还要照抄一遍，过于繁琐与丑陋。此外，用闭包去初始化std::function对象，本质上并没有解决lambda递归调用的问题，只是规避了这个问题而已，反而引入了许多新的问题，它并不是零开销抽象的。另外他还有一些功能上的残缺，比如我们尝试实现一个尾递归调用的斐波那契数列：
很显然，对于带有默认参数的lambda表达式，std::function并不能承载其全部功能。
C++14，基于Y不动点组合子（Y Combinator） 如果读者有基本的lambda演算基础，应该对于“Y不动点组合子”有一些概念，它是用来解决匿名函数的递归调用问题的。
科里化 具体理论此处不做讲述，直接看代码，相对纯正的FP写法如下，由于我们要做科里化，传递lambda表达式，此处使用了来自C++14的泛型lambda，即支持在lambda表达式的参数列表中使用auto：
#include &lt;iostream&gt; int main() { auto T = [&amp;](auto x) { return [&amp;](auto y) { return y([&amp;](auto z) {return x(x)(y)(z); }); }; }; auto X = T(T); auto fib = X([](auto f) { return [&amp;](auto n)-&gt;int { return n &lt; 2 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb75e69ea50d55cd82545c2b5185e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098f96a70ccbec3b560e5728fe43b7ab/" rel="bookmark">
			vs2019配置opencv4.6.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击链接 https://opencv.org/releases/ 找到 OpenCV4.6.0 Windows 版
下载完后双击打开安装程序（460是我自己创建的文件夹）
接着配置电脑环境变量，在搜索里面直接搜索path，就可以找到了。
找到系统变量中的path，点击编辑，然后新建。将你说下载的文件里面的bin文件夹路径放上去。
配置完电脑环境后，打开vs2019，创建一个空项目
找到属性管理器。
右键点击DEBUG|x64选择新建属性表，命名自己喜欢，最好可以自己区分出来，因为有很多项目会用到其他的外在库，会添加其他的属性表。然后在VC++目录&gt;&gt;包含目录中添加两行。
E:\opencv\460\opencv\build\include
E:\opencv\460\opencv\build\include\opencv2
再在库目录里添加lib库
因为这个是debug的，所以添加opencv_world460d.lib。（区分release和debug就是看后面有没有d）如果你要在release下运行，则将这个附加依赖项中的最后面的d删除掉即可。
测试代码：
#include &lt;iostream&gt;
#include &lt;opencv2/core.hpp&gt;
#include &lt;opencv2/imgcodecs.hpp&gt;
#include &lt;opencv2/highgui.hpp&gt;
using namespace std;
using namespace cv;
int main(int argc, char** argv)
{
String imageName("5.jpg"); // by default
if (argc &gt; 1)
imageName = argv[1];
Mat image = imread(samples::findFile(imageName), IMREAD_COLOR); // Read the file
if (image.empty()) { // Check for invalid input
cout &lt;&lt; "Could not open or find the image"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098f96a70ccbec3b560e5728fe43b7ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f924e4c0b94b6663a59ccdc71b32234/" rel="bookmark">
			matlab 从txt文本文件中读取指定行数据，并生成新的txt文本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是记录也是互相学习！
fid=fopen('file.txt'); %打开原始文本文件
fidw = fopen('newfile.txt','w'); %打开新建的空文本文件，也是后续写入数据的文本文件
for k= 1:20 %共有1到20行的数据
tline = fgetl(fid);
if k&gt;6 %从第6行开始读取
fprintf(fidw,tline); %将读取到的数据写入新建的空文本文件中，每次写入会覆盖之前的数据
%也可直接用disp(tline); 可直接在命令行窗口显示读取的数据
fprintf(fidw,'\n'); %对写入的数据进行换行处理
end
end
fclose(fid); %关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bf43304e1e3fe7f5d34fddfcb213e4/" rel="bookmark">
			java三个数求最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定三个正整数,求最大公约数和最小公倍数。 Scanner scan = new Scanner(System.in); System.out.println("请依次输入三个数字:"); int a = scan.nextInt(); int b = scan.nextInt(); int c = scan.nextInt(); int z = a &gt; b ? b : a; int d = c &gt; z ? z : c;	for(int i = d ;; i--) { if(a % i == 0 &amp;&amp; b % i == 0 &amp;&amp; c % i ==0) { System.out.println("最大公约数为" + i); break; }	} z = a &lt; b ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98bf43304e1e3fe7f5d34fddfcb213e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de1431b5e2e564ef4451d282d5617eb/" rel="bookmark">
			2022华为机试社招OD高频考试真题【4, 5月份Q1, Q2考试新编程题目】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qq_21712899/article/details/125040945
华为机试真题https://www.online1987.com/
2022华为社招OD高频考试真题【4, 5月份Q1, Q2考试新编程题目】https://www.online1987.com/%E9%A2%98%E7%9B%AE%E5%AF%BC%E8%88%AA/ 华为校招真题https://www.online1987.com/xiaozhao/ 最长广播效应https://www.online1987.com/%E6%9C%80%E9%95%BF%E5%B9%BF%E6%92%AD%E6%95%88%E5%BA%94/
某通信网络中有N个网络结点，用1到N进行标识。网络中的结点互联互通，且结点之间的消息传递有时延，相连结点的时延均为一个时间单位。现给定网络结点的连接关系link[i]={u，v}，其中u和v表示网络结点。当指定一个结点向其他结点进行广播，所有被广播结点收到消息后都会在原路径上回复一条响应消息，请计算发送结点至少需要等待几个时间单位才能收到所有被广播结点的响应消息。 考古问题https://www.online1987.com/%E8%80%83%E5%8F%A4%E9%97%AE%E9%A2%98/
假设以前的石碑被打碎成了很多块，每块上面都有一个或若干个字符，请你写个程序来把之前石碑上文字可能的组合全部写出来，按升序进行排列。
最小传输时延https://www.online1987.com/%E6%9C%80%E5%B0%8F%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6/
某通信网络中有N个网络结点，用1到N进行标识。网络通过一个有向无环图表示，其中图的边的值表示结点之间的消息传递时延。现给定相连节点之间的时延列表times[i]={u，v，w}，其中u表示源结点，v表示目的结点，w表示u和v之间的消息传递时延。请计算给定源结点到目的结点的最小传输时延，如果目的结点不可达，返回-1。 打印任务排序https://www.online1987.com/%E6%89%93%E5%8D%B0%E4%BB%BB%E5%8A%A1%E6%8E%92%E5%BA%8F/
某个打印机根据打印队列执行打印任务。打印任务分为九个优先级，分别用数字1-9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A，然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A优先级高的任务，则将任务A放到队列尾部，否则就执行任务A的打印。请编写一个程序，根据输入的打印队列，输出实际的打印顺序。 报文解压缩https://www.online1987.com/%E6%8A%A5%E6%96%87%E8%A7%A3%E5%8E%8B%E7%BC%A9/
为了提升数据传输的效率，会对传输的报文进行压缩处理。输入一个压缩后的报文，请返回它解压后的原始报文。压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。注意 n 为正整数（0 &lt; n &lt;= 100），str只包含小写英文字母，不考虑异常情况。 污染水域https://www.online1987.com/%E6%B1%A1%E6%9F%93%E6%B0%B4%E5%9F%9F/
输入一行字符串，字符串可转换为N*N的数组，数组可认为是一个水域，判断多少天后，水域被全部污染。
数组中只有0和1，0表示纯净，1表示污染，每天只可污染上下左右的水域，如果开始全部被污染，或永远无法污染，则返回-1。
单词搜索https://www.online1987.com/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/
找到它是一个小游戏，你需要在一个矩阵中找到给定的单词。
假设给定单词 HELLOWORD，在矩阵中只要能找到 H-&gt;E-&gt;L-&gt;L-&gt;O-&gt;W-&gt;O-&gt;R-&gt;L-&gt;D连成的单词，就算通过。
注意区分英文字母大小写，并且您只能上下左右行走，不能走回头路。
发广播https://www.online1987.com/%E5%8F%91%E5%B9%BF%E6%92%AD/
某地有N个广播站，站点之间有些有连接，有些没有。有连接的站点在接受到广播后会互相发送。
给定一个N*N的二维数组matrix,数组的元素都是字符’0’或者’1’。matrix[i][j]=‘1’,则代表i和j站点之间有连接，matrix[i][j] = ‘0’代表没连接，现在要发一条广播，问初始最少给几个广播站发送，才能保证所有的广播站都收到消息。 斗地主https://www.online1987.com/%E6%9C%80%E9%95%BF%E7%9A%84%E9%A1%BA%E5%AD%90/
斗地主起源于湖北十堰房县，据说是一位叫吴修全的年轻人根据当地流行的扑克玩法“跑得快”改编的，如今已风靡整个中国，并流行于互联网上。
牌型：单顺，又称顺子，最少5张牌，最多12张牌(3…A)不能有2，也不能有大小王，不计花色。
例如 3-4-5-6-7-8，7-8-9-10-J-Q，3-4-5-6-7-8-9-10-J-Q-K-A
可用的牌 3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A&lt;2&lt;B(小王)&lt;C(大王)，每种牌除大小王外有四种花色
任务最优调度https://www.online1987.com/%E4%BB%BB%E5%8A%A1%E6%9C%80%E4%BC%98%E8%B0%83%E5%BA%A6/
给定一个正整数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。
请计算执行完所有任务所需的最短时间。
任务执行规则如下:
任务可以按任意顺序执行，且每个任务执行耗时间均为1个时间单位。 数据分类https://www.online1987.com/%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB/
对一个数据a进行分类，分类方法为：
此数据a（四个字节大小）的四个字节相加对一个给定的值b取模，如果得到的结果小于一个给定的值c，则数据a为有效类型，其类型为取模的值；如果得到的结果大于或者等于c，则数据a为无效类型。
比如一个数据a=0x01010101，b=3，按照分类方法计算（0x01+0x01+0x01+0x01）%3=1，
所以如果c=2，则此a为有效类型，其类型为1，如果c=1，则此a为无效类型；
又比如一个数据a=0x01010103，b=3，按照分类方法计算（0x01+0x01+0x01+0x03）%3=0，
比较版本号大小https://www.online1987.com/%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%A4%A7%E5%B0%8F/
输入两个版本号 version1 和 version2，每个版本号由多个子版本号组成。
子版本号之间由 “.” 隔开，由大小写字母、数字组成，并且至少有一个字符。
按从左到右的顺序比较子版本号，比较规则如下：
子版本号前面的0不参与比较，比如 001 和 1 是相等的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de1431b5e2e564ef4451d282d5617eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f23788ac1e0d583942cba26cdf0dbd/" rel="bookmark">
			mybase database从Windows复制到Mac后打开报错err code -1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接复制nyf文件到Mac上
在Mac上安装好mybase后，打开软件，选择打开数据库，选择复制好的nyf文件
打开的时候系统会提示，是否给mybase访问文件夹权限，选择允许，可以在系统偏好设置-安全性与隐私下看到赋权结果：
但还是遇到问题："Failed to open the database. (ErrCode: -1)"
参考官方帮助：
打开mybase日志，提示permission denied，参考以下命令：
sudo chmod -R 777 /Users/xxxx/Downloads/nyfmyself
MAC 出现permission denied解决办法_逍遥的码农的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca115de18728a881aa4b95688e796540/" rel="bookmark">
			解决：jmeter5.5在win11下界面上的字特别小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
界面上，点击操作-&gt;放大
方法二：
用编辑器打开bin文件夹下的jmeter.properties ，把下面红色的地方放开注释，修改大一点，
方法三：
如果方法二不生效，用编辑器打开jmeter.bat，加入以下几行。重启jmeter。
set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.controlFont=Dialog-20
set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.systemFont=Dialog-20
set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.userFont=SansSerif-20
set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.smallFont=SansSerif-20
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8d25cbc18c5d3c0e75762c7f93cd294/" rel="bookmark">
			Navicat Premium使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Navicat premium是一款数据库管理工具,是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle、MariaDB、Mssql、及PostgreSQL 资料库，让管理不同类型的资料库更加的方便。
目录
1 连接到数据库
2 查询
3 新建数据库
4 新建表
5 手动给表添加数据
6 自动生成表数据
7 清空表数据
1 连接到数据库 文件--新建连接--选择数据库--写连接名、对应数据库的用户名、密码,点左下角测试连接,测试成功即可使用--点确定
右键--打开连接
打开连接后,会展示数据库列表
2 查询 3 新建数据库 4 新建表 添加列字段--保存--起表名
5 手动给表添加数据 6 自动生成表数据 数据生成成功
看一下表数据
7 清空表数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438a44cc9bcadc9a0ce24a5fbcbdf1fd/" rel="bookmark">
			mql5中基于任意价格数组通过icustom函数调用内建指标函数创建新指标的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我通过搜索百度、网上各大论坛、贴吧和mql5社区找了很久都没有找到关于如何用任意价格调用内建指标计算均线的方法，在某个mql5编程的培训视频中讲解如何用任意价格创建均线指时，老师也是自己构建的均线指标而非采用调用内建的iMA函数创建。然后我觉得mql5语言这么强大，应该不可能每个指标都需要自己去创建，应该存在直接调用的方法，于是我通过查阅mql5帮助文件，发现了调用所有内建指标的方法，现在将其分享一下。
在mql5编程中，有很多内建指标函数，例如iMA，iATR，iRSI，iCCI函数等，但是他们的计算输入值只能选择ENUM_APPLIED_PRICE枚举变量中的几个价格或者用iCustom和IndicatorCreate创建的指标处理器（指标处理器也称之为指针或者hander）。即当你直接调用此函数时候，只能选择PRICE_CLOSE，PRICE_OPEN，PRICE_HIGH，PRICE_LOW，PRICE_MEDIAN，PRICE_TYPICAL，PRICE_WEIGHTED**这几个价格计算出指标的buffer值，但是我们往往需要创建其他变量的指标，例如以2倍收盘价创建10日均线指标，这个时候就不能直接将2倍收盘价价格数组放到iMA函数中进行计算，而是需要先将2倍收盘价数组变成指针handler，然后才能放入iMA函数中计算出指标值。****
下面以比较常见的创建均线指标iMA函数为例，展示如何用2倍close_price数组(可换成任意价格数组)调用内建指标计算的方法。在mql5帮助文件中，iMA函数说明文档如下：
iMA
函数返回移动平均数指标处理器。只有一个缓冲区。
int iMA(
string symbol, // 交易品种名称
ENUM_TIMEFRAMES period, // 周期
int ma_period, // 平均周期
int ma_shift, // 平移
ENUM_MA_METHOD ma_method, // 平滑类型
ENUM_APPLIED_PRICE applied_price // 价格或者处理程序类型
);
参量
symbol
[in] 证券交易品种名称，数据用来计算指标。 NULL 值代表当前交易品种。
period
[in] 周期值可以是 ENUM_TIMEFRAMES 值中的一个，0代表当前时间表。
ma_period
[in] 计算移动平均数的平均周期。
ma_shift
[in] 与价格图表有关的指标变化。
ma_method
[in] 平滑类型。可以是 ENUM_MA_METHOD 值中的一个。
applied_price
[in] 使用价格。可以是任意 ENUM_APPLIED_PRICE 价格常量或者另外指标处理器。
返回值
返回特殊技术指标处理器，失败返回 INVALID_HANDLE. 计算机内存从不使用的指标中释放，使用指标处理程序传递到的函数 IndicatorRelease() 。
根据以上说明文档中的最后一个参数applied_price可知，需要将2倍close_price价格变成指标处理器才能作为参数传递到函数中，所以最关键的地方就是如何将2倍close_price数组变成handler。解决这个问题只需要用iCustom函数返回指标处理器即可。
iCustom函数官方说明文档如下：
iCustom
函数返回指定自定义指标的处理器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438a44cc9bcadc9a0ce24a5fbcbdf1fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56319b8b1e453a33db1903f4864e921/" rel="bookmark">
			mysql连接 Public Key Retrieval is not allowed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题现象： mysql8+版本JDBC连接，项目启动报错
jdbc:mysql://localhost:3306/mybats_plus_demo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai 问题处理： mysql连接配置添加 allowPublicKeyRetrieval=true
jdbc:mysql://localhost:3306/mybats_plus_demo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec0e4e66092bddf373c9220d3ef3e9fd/" rel="bookmark">
			微信小程序之获取用户信息（流程&#43;2种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取流程图
ui库Vant Weapp：Vant Weapp地址（点击跳转）
第一种方法
适用于直接点击登录获取
在界面添加登录按钮，用户点击按钮调用wx.getUserProfile()函数来提示用户授权登录，授权成功后，把用户头像数据和名称数据保存到缓存区里，并且改变全局变量的值
点击登录后
登录成功后跳转到首页
&lt;van-button size="small" type="primary" block color="rgba(0, 153, 255, 1)" open-type="getUserInfo" bindtap="getUserProfile"&gt;微信一键登录&lt;/van-button&gt; 布局以及路由跳转可以根据需求结合hasUserInfo以及canIUseGetUserProfile状态进行加判断改动
js代码
data: { //是否已经获取用户信息 hasUserInfo: false, //是否可以调用获取信息得函数 canIUseGetUserProfile: false， }, //第一次获取用户信息 getUserProfile: function (e) { wx.getUserProfile({ desc: '获取您的微信个人信息', success: (res) =&gt; { this.setData({ hasUserInfo: true }) var app = getApp() app.globalData.userInfo = res.userInfo; // 将用户信息存到globalData里面 }, fail: function (e) { wx.showToast({ title: '你选择了取消', icon: "none", duration: 1500, mask: true }) } }) }, onLoad: function (n) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec0e4e66092bddf373c9220d3ef3e9fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3be0eaff61e5d538dcdd8b19e3e7ad/" rel="bookmark">
			SpringBoot自定义Environment属性及属性绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们需要在spring bean的生命周期开始前，初始化一些环境变量到Environment中，在bean生命周期的过程中，可以动态的注入这些环境变量。下面就介绍3种方式，配置环境变量。
自定义Environment属性有常用的3种方式，属性绑定有手动绑定和注解自动绑定2种方式。
源码 获取源码
方式一：实现FactoryBean 我们常见的一些框架本身是可以单独运行的，而不是依赖于Spring。同时，有框架为了使用Spring的IOC，通常都提供了一个与Spring整合的jar包，例如：mybatis-spring，我们在xml中会配置一个SqlSessionFactoryBean，它是实现了FactoryBean的，SqlSessionFactoryBean类中完成了一些必要对象的初始化，通过FactoryBean#getObject方法，将SqlSessionFactory交给了Spring管理。通过这个例子，我可以告诉你，FactoryBean是很多框架整合到Spring IOC的桥梁。那我们也可以通过FactoryBean初始化环境变量。
步骤1:实现FactoryBean、EnvironmentAware super.getDefaultProperties()方法是DefaultPropertiesConfig中的，本博客讲述了3种实现方式，就把要配置的环境变量抽出来了。
public class InjectEnvironmentFactoryBean extends DefaultPropertiesConfig implements FactoryBean&lt;Properties&gt;, EnvironmentAware { private Environment environment; @Override public Properties getObject() throws Exception { Properties p = new Properties(); Map&lt;String, Object&gt; defaultProperties = super.getDefaultProperties(); if (defaultProperties != null) { MapPropertySource propertySource = new MapPropertySource(DefaultPropertiesConfig.ASSOCIATED_NAME, defaultProperties); ((ConfigurableEnvironment) environment).getPropertySources().addFirst(propertySource); p.putAll(defaultProperties); } return p; } @Override public Class&lt;?&gt; getObjectType() { return Properties.class; } @Override public void setEnvironment(Environment environment) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af3be0eaff61e5d538dcdd8b19e3e7ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5ce1c0a8a8e5d40c178b55542e0c78/" rel="bookmark">
			单片机基础知识点 04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数码管显示原理 数码管的公共端可以分为“共阴极"和”共阳极“两种情况。当数码管多位一体时，它们内部的公共端是独立的，而负责显示什么数字的段线全部是连接在一起的，独立的公共端可以控制多位一体中的哪一位数码管点亮，而连接在一起的段线可以控制这个能点亮数码管什么数字，通常把公共端叫做“位选线”，连接在一起的段线叫做“段选线”。 2. 数码管静态显示 在用C语言编程时，编码定义方法如下： unsigned char code table[]={ 0x3f,0x06,0x5b,0x4f,0x66 }; 编码定义方法与C语言中的数组定义方法非常相似，不同的地方就是在数组类型后面多了一个code关键字。需要注意的是，单片机C语言中定义数组时是占用内存空间的，而定义编码时是直接分配到程序空间中，编译后编码占用的是程序存储空间，而非内存空间。
举例：
/*实现功能：让实验板上6个数码管同时点亮，依次显示0~F，时间间隔0.5s，循环下去*/ #include &lt;reg52.h&gt; //52系列单片机头文件 #define uchar unsigned char #define uint unsigned int sbit dula =P2^6; //申明U1锁存器的锁存端 sbit wela =P2^7; //申明U2锁存器的锁存端 uchar num; uchar code table[]={ 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71 }; void delayms(uint); void main() { wela=1; //打开U2锁存端 P0=0xc0; //送入位选信号 0x11000000（哪一个数码管） wela=0; //关闭U2锁存端 while(1) { for(num=0;num&lt;16;num++) //16个数字循环显示 { dula=1; //打开U1锁存端 P0=table[num]; //送入段选信号（内容） dula=0; //关闭U1锁存端 delayms(500); } } } void delayms(uint xms) { uint i,j; for(i=xms;i&gt;0;i--) { for(j=110;j&gt;0;j--); //i=xms即延时约xms毫秒 } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c5ce1c0a8a8e5d40c178b55542e0c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715fd00976cc171634ad9e01d7536046/" rel="bookmark">
			matlab优化工具箱OptimizationToolbox使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在matlab 2021打开优化工具箱，提示的是open live editor task：
因为没有在之前的版本中使用过这个工具箱，所以直接按照live editor的方式写个使用记录，主要参考官网的：How to Use the Optimize Live Editor Task
以该优化问题为例：
首先新建一个实时脚本：
对问题中使用到的初值进行指定，另外，和视频里不一样的是，我这个版本里的约束函数没有输入参数R这个设定，所以我是直接在函数里写好常数值的，没有作为输入参数，所以一开始的时候也没有做R的设定：
ctrl+enter后就可以执行到工作区：
然后在脚本中插入工具箱：
效果如下：
然后就可以在这个界面进行目标函数、约束函数、优化方法等等的设置。
指定问题类型：
根据目标函数的类型进行选择，本问题是非线性问题
指定约束类型：
本问题有参数的上下界限制和一个不等式约束，并且是非线性的：
选择优化方法，就用了默认的，点右边的问号可以看到关于求解器的更多信息 4. 编写目标函数
本实例目标函数是从局部函数选择，这种类型需要自己在脚本里编写目标函数，选择新建，下方就会出现一个目标函数模板：
这个模板已经把目标函数怎么写有了个实例，这个示例用的目标函数就是这个，所以不用改了。
5. 选择初始点， 以同样的方法新建约束函数，并设置上下界。 再选择一下需要的结果就可以运行了：
结果图： 结果值：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d964fd31666cbc07fbe747d39ee5de/" rel="bookmark">
			2022年全国职业院校技能大赛（中职组）网络安全竞赛试题解析-A
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年全国职业院校技能大赛（中职组）
网络安全竞赛试题
（1）
（总分100分）
需要环境可以私信博主
赛题说明
一、竞赛项目简介
“网络安全”竞赛共分A.基础设施设置与安全加固；B.网络安全事件响应、数字取证调查和应用安全；C.CTF夺旗-攻击；D.CTF夺旗-防御等四个模块。根据比赛实际情况，竞赛赛场实际使用赛题参数、表述及环境可能有适当修改，具体情况以实际比赛发放赛题为准。竞赛时间安排和分值权重见表1。
表1 竞赛时间安排与分值权重
模块编号
模块名称
竞赛时间（小时）
权值
A
基础设施设置与安全加固
3
20%
B
网络安全事件响应、数字取证调查和应用安全
40%
C
CTF夺旗-攻击
3
20%
D
CTF夺旗-防御
20%
总计
6
100%
二、竞赛注意事项
1.比赛期间禁止携带和使用移动存储设备、计算器、通信工具及参考资料。
2.请根据大赛所提供的比赛环境，检查所列的硬件设备、软件清单、材料清单是否齐全，计算机设备是否能正常使用。
3.在进行任何操作之前，请阅读每个部分的所有任务。各任务之间可能存在一定关联。
4.操作过程中需要及时按照答题要求保存相关结果。比赛结束后，所有设备保持运行状态，评判以最后提交的成果为最终依据。
5.比赛完成后，比赛设备、软件和赛题请保留在座位上，禁止将比赛所用的所有物品（包括试卷等）带离赛场。
6.禁止在提交资料上填写与竞赛无关的标记，如违反规定，可视为0分。
竞赛内容
模块A 基础设施设置与安全加固 （本模块20分）
一、项目和任务描述：
假定你是某企业的网络安全工程师，对于企业的服务器系统，根据任务要求确保各服务正常运行，并通过综合运用登录安全加固、数据库安全策略、流量完整性策略、事件监控策略、防火墙策略、IP协议安全配置等多种安全策略来提升服务器系统的网络安全防御能力。本模块要求根据竞赛现场提供的A模块答题模板对具体任务的操作进行截图并加以相应的文字说明，以word文档的形式书写,以PDF格式保存，以“赛位号+模块A”作为文件名，PDF格式文档为此模块评分唯一依据。
二、服务器环境说明
Windows （2008） 用户名：administrator，密码：123456
Linux （Centos7） 用户名：root，密码：123456
三、具体任务（每个任务得分以电子答题卡为准）
A-1任务一 登录安全加固 1.密码策略（Windows，Linux）
a.设置最短密码长度为15；
众所周知一般win系统只能设置最大限制为14位的密码，其实也是有15，16位的，只不过用在了domain域，安装domain后即可设置
vim /etc/pam.d/login
auth required pam.tally2.so deny=5 unlock_time=60
b.一分钟内仅允许4次登录失败，超过4次，登录帐号锁定1分钟。
这里我们设置为 5 ，由于在一次国赛模拟题答案中，说的超过五次登录失败，其中答案设置为6
2.用户安全管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d964fd31666cbc07fbe747d39ee5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2f52c30bf19764eafb8dbdfa4fff32/" rel="bookmark">
			vue封装弹出框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于： https://blog.csdn.net/qq_37547964/article/details/125068795
vue封装弹出框 一、封装组件二、使用 一、封装组件 &lt;template&gt; &lt;!-- 遮罩层 --&gt; &lt;div v-show="isMask" class="mask" @touchmove.stop @mousewheel.stop&gt; &lt;!-- 内容 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { // 是否显示加载动画 isMask: { type: Boolean, default: true } }, methods: {} } &lt;/script&gt; &lt;style lang="less" scoped&gt; .mask { width: 100vw; height: 100vh; position: fixed; z-index: 1000; top: 0; left: 0; background: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; } &lt;/style&gt; 二、使用 &lt;template&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2f52c30bf19764eafb8dbdfa4fff32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3a7efae82493e900809d9dee740e5b/" rel="bookmark">
			@RequestBody注解转对象大写字母开头参数无法接收到数据问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端传参：
后端接收：
可以看到前端传到后端的时候，GGXH这个参数是有值的，但是后端拿到的时候，就没有值了。
解决办法：
在属性名上面添加 @JsonProperty("")注解，把自己的属性名称填进去，就可以了。
重启项目，看下效果。
可以看到现在这个参数就有值了，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5febba6b13a975e57bf1fd991b9492/" rel="bookmark">
			MegaCli64工具磁盘修复处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#查看机器型号
dmidecode -t 1
##查看磁盘分区情况
lsblk
##查看raid状态，可定位故障的Slot Number
/opt/MegaRAID/MegaCli/MegaCli64 -pdlist -a0|egrep ‘Slot Number|Firmware state’
##查看raid信息，判断是做raid x
##/opt/MegaRAID/MegaCli/MegaCli64 -LDInfo -LALL -aAll
/opt/MegaRAID/MegaCli/MegaCli64 -LDInfo -LALL -aAll | grep RAID
##确认Enclosure Device ID
/opt/MegaRAID/MegaCli/MegaCli64 -PDlist -a0|grep “Enclosure Device”|head -1
##处于JBOD状态的硬盘,变更为unconfigured good状态
/opt/MegaRAID/MegaCli/MegaCli64 -pdmakegood -physdrv [ E n c l o s u r e D e v i c e I D : Enclosure Device ID: EnclosureDeviceID:Slot Number] -force -a0
/opt/MegaRAID/MegaCli/MegaCli64 -pdmakegood -physdrv [32:4] -force -a0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5febba6b13a975e57bf1fd991b9492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61c026313f3f9c9ef8340b1a7c0cc47/" rel="bookmark">
			Python采集招聘数据信息(&#43;详情页)并实现可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录（可点击自己想看的地方💗） 本篇代码提供者: 青灯教育-自游老师 [环境使用]:[模块使用]:如果安装python第三方模块:如何配置pycharm里面的python解释器?pycharm如何安装插件? 基本流程思路: &lt;可以通用&gt;一. 数据来源分析二. 代码实现过程: 代码导入模块1. 发送请求,2. 获取数据3. 解析数据, 提取我们想要数据内容 详情页数据导入模块 可视化代码部分效果展示 尾语 本篇代码提供者: 青灯教育-自游老师 [环境使用]: Python 3.8Pycharm [模块使用]: requests &gt;&gt;&gt; pip install requestsrejsoncsv 如果安装python第三方模块: win + R 输入 cmd 点击确定, 输入安装命令 pip install 模块名 (pip install requests) 回车在pycharm中点击Terminal(终端) 输入安装命令 如何配置pycharm里面的python解释器? 选择file(文件) &gt;&gt;&gt; setting(设置) &gt;&gt;&gt; Project(项目) &gt;&gt;&gt; python interpreter(python解释器)
点击齿轮, 选择add
添加python安装路径
pycharm如何安装插件? 选择file(文件) &gt;&gt;&gt; setting(设置) &gt;&gt;&gt; Plugins(插件)
点击 Marketplace 输入想要安装的插件名字 比如:翻译插件 输入 translation / 汉化插件 输入 Chinese
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61c026313f3f9c9ef8340b1a7c0cc47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd4c853c826c172845d8daafda5c610/" rel="bookmark">
			jmeter函数助手二次开发之加解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先新建一个java工程，然后在scr下新建一个cn.com.functions 包，在eclipse中导入二次开发中需要的jar包
新建一个class ：String1Encrypt.java 继承 AbstractFunction 类
package cn.com.functions;// 这里是包名，是固定的写法 import java.util.Collection; import java.util.LinkedList; import java.util.List; import javax.crypto.Cipher; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec; import org.apache.jmeter.engine.util.CompoundVariable; import org.apache.jmeter.functions.AbstractFunction; import org.apache.jmeter.functions.InvalidVariableException; import org.apache.jmeter.samplers.SampleResult; import org.apache.jmeter.samplers.Sampler; import org.apache.jmeter.threads.JMeterVariables; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; public class String1Encrypt extends AbstractFunction { private static final List&lt;String&gt; desc = new LinkedList(); private static final String KEY1 = "__String1_Encrypt";//这里是函数名，也就是在函数助手列表中显示的名称 private Object[] values; private static final String KEY = "xxxxxxxxx"; //声明密匙，根据需要进行修改，当然也可以讲该参数封封装在下面的static中，作为一个可输入的选项 static { desc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd4c853c826c172845d8daafda5c610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2899d32f97b46c765c4492eb01c463/" rel="bookmark">
			ONNXRUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:‘Where‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到此类错误，如：
onnxruntime.capi.onnxruntime_pybind11_state.InvalidArgument: [ONNXRuntimeError] : 2 : INVALID_ARGUMENT : Non-zero status code returned while running Gather node. Name:'Gather_4445' Status Message: indices element out of data bounds, idx=8 must be within the inclusive range [-3,2]
或：
RUNTIME_EXCEPTION : Non-zero status code returned while running Where node. Name:'Where' Status Message...
可以配合Netron工具（安装方法：pip install netron，使用时终端输入netron）查看导出的onnx模型网络图，可以查找相应的Node（如：Where_XXXX），再去代码中找对应代码，将其改为onnx支持的tensor运算方式即可解决相应问题。
根据在ONNX导出时遇到的问题比较麻烦的是和torch.gather、torch.where、torch.split等Tensor运算方法。
1. torch.where函数
torch.where（condition，x，y）-&gt;tensor
当满足condition，则来自于a，反之来自b
import torch condition=torch.randn(2,2) # tensor([[ 0.2589, -0.5600], # [ 0.9056, -0.3915]]) a=torch.tensor([[0,0],[0,0]]) b=torch.tensor([[1,1],[1,1]]) torch.where(cond&gt;0.5,a,b) 得到结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a2899d32f97b46c765c4492eb01c463/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2357a1ebe61842a473d50bbb768caba2/" rel="bookmark">
			SpringBoot&#43;druid&#43;aop动态数据源切换实现-修改中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、核心类AbstractRoutingDataSource
二、具体代码实现过程
1、自定义数据源类DynamicDataSource 2、切换操作类DynamicDataSourceHolder
3、配置动态数据源DynamicDataSourceConfig
4、定义注解DataSource
5、数据源切换切面DataSourceAspect
6、修改启动类-&gt;排除自动配置
三、附录相关配置文件
一、核心类AbstractRoutingDataSource Spring boot提供了AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。
实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法 determineCurrentLookupKey() 决定使用哪个数据源。 org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource ：
对于该抽象类，关注两组变量和一个方法：
Map&lt;Object, Object&gt; targetDataSources和Object defaultTargetDataSourceMap&lt;Object, DataSource&gt; resolvedDataSources和DataSource resolvedDefaultDataSourceprotected abstract Object determineCurrentLookupKey(); 其中两组变量是相互对应的，在熟悉多实例数据源切换代码时不难发现，当有多个数据源的时候，一定要指定一个作为默认的数据源，在这里也同理，当同时初始化多个数据源的时候，需要显示的调用setDefaultTargetDataSource方法指定一个作为默认数据源； 我们需要关注的是
Map&lt;Object, Object&gt; targetDataSources和Map&lt;Object, DataSource&gt; resolvedDataSources，
targetDataSources是暴露给外部程序用来赋值的，用来添加多个数据源实例（DataSource），而resolvedDataSources是程序内部执行时把targetDataSources赋值到resolvedDataSources，因此会有一个赋值的操作，如下图所示：
根据这段源码可以看出，每次执行时，都会遍历targetDataSources内的所有元素并赋值给resolvedDataSources；这样如果我们在外部程序新增一个新的数据源，都会添加到内部使用，从而实现数据源的动态加载。
继承该抽象类的时候，必须实现一个抽象方法：
protected abstract Object determineCurrentLookupKey()
该方法用于指定到底需要使用哪一个数据源。
到此基本上清楚了该抽象类的使用方法，接下来贴下具体的实现代码
二、具体代码实现过程 1、自定义数据源类DynamicDataSource 自定义数据源DataSource类：
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource; /** * @Description 自定义动态数据源类 */ public class DynamicDataSource extends AbstractRoutingDataSource { @Override protected Object determineCurrentLookupKey() { return DynamicDataSourceHolder.getDataSourceType(); } } 2、切换操作类DynamicDataSourceHolder 通过ThreadLocal维护一个全局唯一的map来实现数据源的动态切换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2357a1ebe61842a473d50bbb768caba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b76636427853ffecf794557a0cc9c97f/" rel="bookmark">
			JS-BOM相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《BOM 内涵 及 区分》
定时器 1.setTimeout 定时器
&amp; 形式：window . setTimeout ( 调用函数 ，延迟时间 ) ;
&amp; 注意：①：window 可省略；
&amp; ②：延迟时间 为 毫秒，不带单位。
&amp; 使用：时间到，调用一次 就结束
2.setInterval 定时器
&amp; 形式：window . setInterval ( 调用函数 ，延迟时间 ) ;
&amp; 注意：①：window 可省略；
&amp; ②：延迟时间 为 毫秒，不带单位。
&amp; 使用：时间到，调用一次再过 同样 时间，再 调用，反复多次
3.清除相关定时器
&amp; 形式：window . clearInterval / clearTimeout ( 计时器名称 )；
&amp; 注意：①：window 可省略；
&amp; ②：取消原先计时。
&amp; 建议：每次开启定时器前要清除定时器，确保页面只有一个！
Location对象 1.该对象属性
① location .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b76636427853ffecf794557a0cc9c97f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ffd67f352b13e2facc16fe9e0a5c83/" rel="bookmark">
			SpringBoot国际化英文中文切换实现与疑难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样实现国际化？
1. 在resources下面新建文件-login.properties文件
2. 再新建一个login_zh_CN.properties文件
3. 4. 新建一个文件 en.US.properties
5. 点击login.properties文件，点击下方的Resource Bundle(没有的话请下载插件Resource Bundle)
6. 点击login_en_US.properties新建一个值
7. 在配置文件中编写
spring.messages.basename=i18N.login
8. 编写要转换的中文英文
9. 编写web组件LocaleResolver(语言环境解析器)
public class MyLocaleResolver implements LocaleResolver {
//解析请求 @Override
public Locale resolveLocale(HttpServletRequest request) {
//获取请求中的语言参数 String language=request.getParameter("l");
Locale locale = Locale.getDefault();//如果没有，就使用默认的 //如果请求的链接携带了国际化的参数 if(!StringUtils.isEmpty(language)){
//zh_CN String[] split= language.split("_");
//国家地区 locale=new Locale(split[0],split[1]);
}
return locale;
}
@Override
public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {
}
}
10. 注册组件，在配置文件--类中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ffd67f352b13e2facc16fe9e0a5c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44047b93bef92f669cd8296f76fe572/" rel="bookmark">
			程序员应该学习掌握哪些知识和技能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在做为一名程序员，压力越来越大，各种开发工具越来越庞大、不断推陈出新，各种开发设计工程理念缤纷精彩、需要融入平常的开发当中，还有很多新的知识点在不断开拓中，相比以前，做为一名程序员尤其是合格程序员的难度的确增加了不少。
那么，做为一名程序员应该学习掌握哪些知识和技能呢？
这里的程序员，不是指专业软件公司的专业开发人员，只是作为一般企事业单位的开发人员，就是我所理解的承担企事业单位开发项目的程序员。
１、掌握网络、服务器和PC机的一般概念和技能。
不至于出了问题一筹莫展，这也是对IT人员的基本要求。
２、数据库知识必不可少。
Oracle、Ms Sql Server、MySql这三个数据库必须要掌握，就是安装、日常维护、备份、存储过程、触发器、函数、SQL语言等，还有分布式、主题数据库的搭建、数据仓储与知识挖掘等。
为了安全和性能，企业一般都有群集。
３、企事业单位做应用开发一般是按项目来的，程序员要懂一些项目管理的知识。
风水轮流转而且快，从事IT的基本上都有项目管理的机会，那就需要掌握一些项目管理的相关知识和技巧。
UML很有用，程序员之间的相互沟通用得多，给用户看那是迷乱他们的眼睛。
基本上，程序员参加了软件开发的全过程，需求分析不能马虎对待，也是一门技术活，规范文档必须写好写得漂亮，测试和总结也不能敷衍，学会沟通的一般技巧，因为有可能与领导交谈，也得学习关于一些企业信息化建设的相关内容，俗称信息化理论，尽量做到深入浅出，做一个好的汇报幻灯片不容易，得花费不少的心思。
４、当前流行的设计与架构、开发模式以及一些新概念如云计算要掌握。
对于做开发的来讲是必须的。
５、掌握具体开发工具，精通一门了解其他。
每个人都有喜好，但是也要熟练掌握，必须要至少熟练掌握一门，精通者很少，没有几年功夫谈精通不现实。
现在的开发都是基于网络的，以B/S居多，那么对于HTML、JavaScript、CSS、JQuery、JSon(P)、XML这几样是基本功。
至少要熟练掌握一门前端框架和后台开发语言并有实际开发经验。
C/S下的开发是做基本功，主要工具看开发项目而定，VC[C++]是通吃的，其次是C#和Java，还有其他的很多，就目前的难度来讲都差不多，不是那么经过简单思考和设计就可以进行的。
企业自己做的网站的维护肯定是自己做，包括性能与安全。
６、现在基于移动智能设备的应用多了，3D。
这是趋势，必须跟上，还有三维上的开发和应用，这个应该是未来的重点。
手机APP的开发和应用能力不能忽视。
７、至于到具体的项目，也会有一些特殊的要求。
比如PhotoShop（图片处理），Premiere（多媒体影象制作）等，这是一般的情况，这不好列举，太多了，比如做地理信息方面的，你得熟悉目前流行的一些处理软件（为了调用），如AutoCad、ArcGis或者GeiMedia（视项目使用情况而定）等等，到三维的又有一些如Skyline系列软件、TerraExplorer【三维浏览器】、3DMAX等。
虽然上面的内容有些杂乱，可认真说起来，掌握好每一项都是有一定的难度的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db86ecce1b61db973e1a3b7c0526c5d/" rel="bookmark">
			PCL点云数据处理-滤波基础（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OK，本篇作为PCL学习笔记，希望同道之人互相交流、讨论！有误之处希望指出，欢迎留言
PCL库中包含几个重要的模块库：FIilter（过滤器）、Features（特征）、Keypoints（关键点）、Registration（配准）、Kd-tree、Octree(八叉树）、Segementation（分割）、Sample consensus（样本一致性）、Surface（表面）、Range image（深度图）、I/O（输入输出）、Visualization（可视化）、Common（公共）、Search（搜索）
Filter模块库：去除点云中不需要的点和点云的投影。
下面用不同方法对点云进行滤波处理：
目录
Passthrough Filter（直通滤波）：VoxelGrid Filter(体素化网格滤波)：StatisticalOutlierRemoval（统计学的（稀疏）离群点去除)：Projecting points using a parameter model（投影滤波）：Extracting indices from a PointCloud（点云索引提取点云子集）：RadiusOutlierRemoval或ConditionalRemoval滤波器： 1.Passthrough Filter（直通滤波）：限定某个字段（理解为点云的变量参数）的范围来达到去除异常点效果关键：
步骤：输入点云-创建滤波器对象-设置字段范围-保存滤波后点云
头文件：#include&lt;pcl/filters/passthrough.h&gt; 代码：pcl::PassThrough&lt;pcl::PointXYZ&gt;pass;//创建滤波器对象 pass.setInputCloud(cloud); //调用成员函数输入点云，cloud为已创建的点云对象 pass.setFilterFieldName("z"); //调用设置字符串函数，z为设定字段对应字符串 pass.setFilterLimits(0,2.0); //调用范围设置函数，z的范围在0-2 pass.filter(*cloud_filtered); //执行直通过滤，并将执行结果被保存在cloud_filtered 完整代码（直通滤波）：
#include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/filters/passthrough.h&gt; int main(int argc, char** argv) { srand(time(0)); //创建点云 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); //填入点云数据 cloud-&gt;width = 5; cloud-&gt;height = 1; cloud-&gt;points.resize(cloud-&gt;width * cloud-&gt;height); for (size_t i = 0; i &lt; cloud-&gt;points.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db86ecce1b61db973e1a3b7c0526c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5495596a6852c2faeb08e28e56bee70/" rel="bookmark">
			自己动手写编译器:while,for,do等循环语句的中间代码生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的简易编译器完成了一大部分，但还有一些关键的语法结构没有处理，那就是for, while, do…while等循环语句对应的中间代码还没有生成，本节我们就针对这些语法结构进行相应的中间代码生成。
首先我们要了解循环语句对应的语法表达式：
stmt -&gt; "while" "( " bool ")" stmts stmt -&gt; "do" stmts "while" "(" bool ")" ";" stmt-&gt; "break" 为了简单起见，我们暂时不处理for循环，有兴趣的同学可以自己添加试试。下面我们先创建while, do…while语法结构对应的语法树节，在inter文件夹中创建while.go，然后添加代码如下：
package inter import ( "errors" "fmt" ) type While struct { stmt *Stmt //继承自Stmt节点 expr ExprInterface //对应while 后面的条件判断表达式 while_stmt StmtInterface //对应while的循环体部分 } func NewWhile(line uint32, expr ExprInterface, while_stmt StmtInterface) *While { if expr.Type().Lexeme != "bool" { //用于while后面的表达式必须为bool类型 err := errors.New("bool type required for while") panic(err) } return &amp;While{ stmt: NewStmt(line), expr: expr, while_stmt: while_stmt, } } //下面仅仅是调用其父类接口 func (w *While) Errors(str string) error { return w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5495596a6852c2faeb08e28e56bee70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873473b862446d3e9a0a4e49d6298e3b/" rel="bookmark">
			大作业——OpenGL-基于物理的渲染挂线项目说明书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：各种渲染效果的切换需要手动在片段着色器中切换FragColor的赋值函数
目录
简介
效果图
一、开发流程
1.环境配置
2.框架搭建
二、基础功能
1.图形绘制
2.着色器
3.纹理材质 4.摄像机 三.核心功能
1.模型加载
2.光照算法
四.高阶功能
1.帧缓存
2.特殊材质效果-环境映射
3.阴影渲染 总结
简介 本OpenGL程序旨在通过OpenGL从底层出发，准许现实世界的真实物理表现，通过OpenGL实现一个基于物理的初级渲染管线。我们可以在OpenGL中自由的创建出我们想要的Model，然后也可以自由的为其添加材质贴图，最后我们通过着色器将我们的模型与材质数据输入按照一定的物理法则进行处理，进而实现在计算机中模拟出各种各样的画面表现。
效果图 玻璃折射 金属反射
标准材质 阴影渲染
一、开发流程 1.环境配置 为了更好的编写OpenGL，我们使用的许多功能完善的OpenGL的库，GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入，对我们来说这就够了。
我们在VS的NuGet包中安装各种我们所需要的库，这样比传统的计算机环境配置更加便捷
配置GLAD，GLAD是一个开源的库，它能解决我们上面提到的那个繁琐的问题。GLAD的配置与大多数的开源库有些许的不同，GLAD使用了一个在线服务。在这里我们能够告诉GLAD需要定义的OpenGL版本，并且根据这个版本加载所有相关的OpenGL函数。
GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的Include文件夹中（或者增加一个额外的项目指向这些目录），并添加glad.c文件到你的工程中。
配置 Stb_image,为了将外部的纹理材质加载到OpenGL中来，我们使用了较为新颖的stb,为了能正常使用stb,我们将其作为头文件导入到项目中来，使用一下的的代码将其导入到cpp中
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
其余的OpenGL库的导入较为简单，我们只需要在NuGet包管理中将其导入即可，不需要额外的单独配置。
2.框架搭建 首先是创建一个可运行的空程序，我们第一步就是创建一个简单的窗口，然后整个程序进行初始化使得这个Opengl可以正常的运行。这里包含了我们项目最终所需要的所有的头文件以及包。 #include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;
#include "Shader.h"
#include "camera.h"
#include "model.h"
#include &lt;iostream&gt;
初始化程序并搭建窗口
int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0; } 首先，我们在main函数中调用glfwInit函数来初始化GLFW，然后我们可以使用glfwWindowHint函数来配置GLFW。glfwWindowHint函数就是表明了我们所使用的的OpenGL的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/873473b862446d3e9a0a4e49d6298e3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159d1b9774d8d6163925f57275497c76/" rel="bookmark">
			安装包失败提示apt --fix-broken install 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Reading package lists... Done Building dependency tree Reading state information... Done You might want to run 'apt --fix-broken install' to correct these. The following packages have unmet dependencies: python3-rosdep-modules : Depends: python3-rospkg-modules (&gt;= 1.3.0) but it is not going to be installed Depends: python3-catkin-pkg-modules (&gt;= 0.4.0) but it is not going to be installed Depends: python3-rosdistro-modules (&gt;= 0.7.5) but it is not going to be installed ros-noetic-rospack : Depends: python3-catkin-pkg-modules but it is not going to be installed ros-noetic-rqt-gui : Depends: python3-rospkg-modules but it is not going to be installed ros-noetic-rqt-robot-monitor : Depends: python3-rospkg-modules but it is not going to be installed E: Unmet dependencies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159d1b9774d8d6163925f57275497c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab19f0b5e9a6546d968b72ad2b938e68/" rel="bookmark">
			d during template parsing (template: “ServletContext resource [/WEB-INF/templates/index.html]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		```go An error happened during template parsing (template: "class path resource [templates/index.html]") org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/index.html]") at org.thym SpringMVC控制层404接口找不到网站 配置文件没错
路径没错
文件都能找到
后面排错发现是我导入了新的源码没有重新打包。
重新打包就能找到网站了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7a2988eeccb63b8c0d8e0f1951a24f/" rel="bookmark">
			vue&#43;element UI upload 上传组件使用经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 vue+element UI 框架开发前端项目时，产品功能要求可以上传图像和文件，这就可以用到 el-upload 上传组件。在用此组件实现功能时，从陌生到熟悉，掌握了一些方法，仅以此文做一个总结梳理。 关于 upload 上传 element 的官网就一句话介绍：通过点击或者拖拽上传文件。它的基础代码如下：
&lt;el-upload class="upload-demo" action="https://jsonplaceholder.typicode.com/posts/" :on-preview="handlePreview" :on-remove="handleRemove" :before-remove="beforeRemove" multiple :limit="3" :on-exceed="handleExceed" :file-list="fileList"&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;div slot="tip" class="el-upload__tip"&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; 我们看 element 官网详细的说明，可以发现 el-upload 的触发事件和属性特别多，action, on-priview, on-remove, before-remove, on-exceed 等大概有二十多个，每个场景都不一样，那我们实际项目中真的会用到这么多的事件吗？我的回答是不用，根据自己的需求来做合适的选择。 本文就结合我自己的实际项目需求来进行说明。代码如下：
&lt;el-upload action list-type="picture-card" :limit="2" :http-request="uploadPicture" :file-list="pictureList" :on-change="handleChangePicture" &gt; &lt;i class="el-icon-plus" /&gt; &lt;div slot="file" slot-scope="{ file }"&gt; &lt;el-image style="width: 147px; height: 147px" :src="file.url" fit="cover" :preview-src-list="[file.url]" /&gt; &lt;/div&gt; &lt;/el-upload&gt; 我这段代码要实现的是上传图片的功能，所以 list-type 设置为 picture-card，这样文件列表的类型就是图片了，如果不设置，默认就是 text 文件。如果我不做 limit （用来限制上传文件/图片的数量）限制，那么效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7a2988eeccb63b8c0d8e0f1951a24f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2af8da3a8d800c31aee9549b57753a1/" rel="bookmark">
			Unity中的框架知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 框架是什么？ 从定义上说
框架是一堆包含了常量，方法，类等代码的集合，他是一个半成品的应用，只包含了一些项目开发的时候所用使用的底层架构，并不包含业务逻辑，框架同时还包含一些优秀的设计模式。
从作用上说
框架是一个支撑整个系统的一个架子
IT中的框架指的是解决一个开放性问题而设计的具有一定约束性的支持结构。在此结构上可以根据具体问题扩张、安插更多的组件，从而更简便和快速解决问题。
从特征上说
框架本身一般不完整到可以解决特定问题，但是可以帮助快速解决问题；没有框架所有的工作都要从无到有，有了框架，为我们提供了一定的功能，我们就可以在框架的基础上开发。不同的框架可以解决不同问题。
框架是为扩展而设计的。
框架里面可以为后续扩展提供各种工具。
软件设计原则 高内聚 内聚：一般指一堆东西形成一个模块，例如变量，对象，或者是功能模块
高内聚：尽可能的让一个模块内部的代码相关程度高，相互联系的紧密。模块内部的代码，相互之间的联系越强，内聚就越高，模块的独立性就越好。一个模块应该尽量去独立的完成一个功能！如果必须写另外的功能，可以分成多个模块，低内聚的代码，不好维护，代码也不就健壮
低耦合 耦合：模块与模块之间相互连接的一种度量，耦合的强弱取决于模块接口的复杂程度，
进入后访问一个模块的点以及通过接口的数据。
低耦合：尽可能的将每一个功能通过模块单独写出去，然后通过指定的接口来相互联系，模块与模块之间的关系越是紧密，独立性就越不好，改变一个模块可能会影响其他的模块
举例：比如中国人和中国文化内聚在中国，而美国人和美国文化都内聚在美国。联合国中各个针对不同国家的部门就是接口。
高内聚：中国内政，中国历史，中国建设等中国元素都是内聚在中国
低耦合：当世界发生大事需要中国出面，那么联合国中对接中国的部门就会与中国发生接触。而需要美国时，对接美国的部门就会与美国产生接触
MVC框架 谈到框架，就离不开MVC框架，MVC是一种经典的三层设计框架，MVC框架将数据与视图分离，通过控制器来接受数据而后反应到视图中。
MVC框架完成了模块的分离，因此在高内聚和低耦合方面有着很强的功能性。
Unity3d中有着很多模块可以是用框架知识来让系统更加稳定。
Unity3D中UI的MVC模式 UI是游戏开发中一个重要模块，也可以使用MVC模式来进行设计与开发
MVC的好处：
1、可以修改UI的外观，而不用修改一行行代码.。(UI由View控制，没有关联数据)
2、在不同的组件里面可以共享同一套逻辑点，用来创建复杂的视图。
MVC的构造
Model：模型(数据)
View：视图(数据的显示)
Controller：控制器(介于模型层与视图层之间，视图层的用户操作发送给控制层，控制层再将其转化为对数据的操作)
MVC框架的图示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec77f64d49e246a22a2b2f02ccc9a3df/" rel="bookmark">
			（C&#43;&#43;）对象指针——小白Doris的课堂笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.对象指针
声明形式：类名 *对象指针名；
例如：Point A(2,3); Point *ptr;ptr=&amp;A;
通过指针访问对象成员：对象指针名--&gt;成员名
ptr--&gt;getX(); or (*ptr).getX();
2.this指针
定义：隐含于每一个类的成员函数中的特殊指针。
功能：明确地指出了成员函数当前所操作的数据所属的对象。
使用：当通过一个对象调用成员函数时，系统先将该对象的地址赋给this指针，然后调用成员函 数，成员函数对对象的数据成员进行操作时，就隐含使用了this指针。
3.指向数据成员的指针
声明：（指向公有数据成员的指针）类型说明符 类名：：*指针名；
（指向公有函数成员的指针）类型说明符 （类名：：*指针名）（参数表）；
（注意：通过指向成员的指针只能访问公有成员。）
分类：
指向数据成员的指针 【赋值：指针名=&amp;类名：：数据成员名；使用：对象名.*类成员指针名or对象指针名--&gt;
类成员指针名】
指向函数成员的指针
【赋值：指针名=类名：：函数成员名； 使用：（对象名.*类成员指针名）（参数表）or（对象指针名--&gt;*类成员指针名）
（注意：成员函数指针的声明、赋值和使用过程中的返回值类型、函数参数表一定要相互匹配。）
】
总结：访问对象的公有成员函数的几种ways：
void main() { Point A(4,5);//声明对象A Point *p1=&amp;A;//声明对象指针并初始化 int (Point::*p_getX)()=Point::getX;//声明成员函数指针并初始化 cout&lt;&lt;(A.*p_getX)()&lt;&lt;endl;//1.使用成员函数指针访问成员函数 cout&lt;&lt;(p1-&gt;getX)()&lt;&lt;endl;//2.使用对象指针访问成员函数 cout&lt;&lt;A.getX()&lt;&lt;endl;//3.使用对象名访问成员函数 } 4.指向类的静态成员的指针（说明：对类的静态成员的访问不依赖于对象，因此可以用普通的指针来指向和访问静态成员。）
下面两个例子分别展示如何通过指针访问类的静态数据成员和静态函数成员嘿嘿嘿
#include&lt;iostream&gt; using namespace std; class Point{ public: Point(int xx=0,int yy=0){X=xx;Y=yy;countP++;}//构造函数 Point(Point &amp;p); int getX(){return X;} int getY(){return Y;} static int countP;//静态数据成员引用性说明 private: int X,Y; }; Point::Point(Point &amp;p) { X=p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec77f64d49e246a22a2b2f02ccc9a3df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4ed22cf88e883dc7f9cbef2a999edb/" rel="bookmark">
			晶振的构造及工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咱搞硬件的，应该都使用过晶振，上次写开关电源环路的零极点的时候，忽然想到晶振是自己起振的，如果从环路的角度看，应该就是利用的环路不稳定的特性，产生自激振荡。
除此之外，我又想到下面这些问题：
那么我们使用晶体的时候，电路的环路的传递函数是怎么样的呢？
为什么只有晶振的固有频率能振荡起来？
为什么改变匹配电容，就能改变频偏？
为什么晶振电路有的要串电阻，有的没有？有的要并联1M电阻，有的没有？
既然有了兴致，那就借这个机会把晶振的内容好好梳理一下，先从基础开始吧。
晶振分类
首先，晶振一般分为两种，一种叫有源晶振，一种叫无源晶振。
有源晶振也叫晶体振荡器，Oscillator；无源晶振有时也叫无源晶体，Crystal，晶体谐振器。至于哪个名字更专业，更准确，我觉得无需争论，名字只是代号而已，大家工作中沟通能知道说的是什么就行。
简单说有源晶振自己供上电就能输出振荡信号，无源晶体必须额外增加电路才能振荡起来。
以上分类是从使用上面来说的。如果我们单看晶振的内部构造，就会发现，有源晶振内部是包含了一个无源晶振，然后再将阻容，放大等电路也包含进去，整体封装好再给我们用。
关于晶体内部结构，我在B站上看到一个非常清晰的拆解视频，有兴趣可以看看，链接是这个：
探索·拆解013 晶振大拆解 60年前晶振什么样 5cm大晶体你见过么_哔哩哔哩_bilibili
有源晶振内部构造包含了无源晶振，所以，一般来说，有源晶振是比无源晶振是要贵的。另外一方面，我们只要了解了无源晶振的特性，有源晶振也就差不多了，毕竟，有源晶振可以看成是无源晶振做成的一个具体电路，供上电，就能输出振荡信号了。
所以，下面我们就只看无源晶振（晶体谐振器）
晶体谐振器构造
首先，晶体谐振器里面的晶体，是指的石英晶体，化学式是二氧化硅SiO2。石英的特点是：热膨胀系数小，Q值高，绝缘。
石英可以做成晶体谐振器，主要是利用了压电效应。压电效应分为正压电效应和逆压电效应，以下是百度百科的定义：
意思对应下图：
晶体的构造示意图：
上图左边是晶体构造的示意图，右边是我们常见的晶振的符号，二者是不是很像？
根据对前面压电效应的理解，晶体可以将电能转化为机械能，然后机械能又能转化为电能。如果给晶体通上交流电，那不就是一会收缩，一会儿膨胀，这不就是机械振动吗？
我们知道，机械振动的物理尺寸和结构固定之后，它本身一般就有一个固有的振动频率。当外加信号的频率与固有振动频率相等时，就会发生共振，产生谐振现象。
显然，晶振的频率，说的就应该是这个固有振荡频率。再从无源晶体也叫“晶体谐振器”，这个“谐振”，应该就是这个意思吧。
除此之外，既然工作原理是机械振动，那么性能自然跟晶体的尺寸和结构非常大的关系。这个我也查了一下，确实如此
晶振频率与切片厚度，切割工艺的关系
切割工艺，就是对晶体坐标轴某种角度去切割。切型有非常多的种类，因为石英是各向异性的，所以不同的切型其物理性质不同，切面的方向与主轴的夹角对其性能有非常重要的影响，比如：频率稳定性，Q值，温度性能等等。
常见的切割类型有两种，AT和BT切。
同种频率的晶振，AT切比BT切的温度系数要小，切片厚度要薄，但是Q值比BT切要低。下面是晶体频率同切片厚度，切割类型的关系：
晶振手册中，也会给出切割类型，不知道兄弟们有没有关注这个参数呢？
特殊的晶振---32.768Khz
从上面看出，AT切的20Mhz晶振的切片很薄，只有0.083mm，但是频率降低到32.768Khz，如果还是AT切的话，厚度就是0.083mm*20Mhz/32.768Khz=50.66mm。显然，这个尺寸太大了。
我们现实中看到的32.768khz的晶振显然是没有这么大的，所以可以肯定的是，32.768Khz的晶振肯定不是AT或是BT切，应该是别的方式。
32.768Khz一般是音叉的结构，就是下面这种：
我想，可能就是因为常规的AT，BT切片方式做不了低频的晶振（尺寸太大），所以这种32.768Khz这样的采用这种音叉结构。
这让我想起当年一开始使用32.768Khz晶振的时候，被迫选了个MC-146封装的，当时还觉得奇怪：别的晶振都能做成3225这种封装的，就你搞特殊，封装长这么奇怪。
小结
本节内容先写这么多吧，主要是查阅资料，总结了下晶振构造相关的，对于硬件设计来说，用处不是特别大，不过了解下也没坏处。
至于开篇提的几个问题，本节是一个问题也没回答，也不着急，后面总会说清楚的，我希望是慢慢从0开始，构建属于自己的知识体系，这样无论遇到什么问题，见过的，没见过的，总能有分析问题的思路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25533c96c925de0f91f738b19c1cdf5b/" rel="bookmark">
			北大《推荐系统》课程-混合推荐算法-整体式混合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
3、整体式混合
3.1 特征组合
3.2 特征扩充
3.3基于图模型的混合
3.3.1基于双层图模型的混合推荐
注：北大刘宏志老师的《推荐系统》课程的学习，图片来源于课程PPT和参考书籍
3、整体式混合 基本思想：对算法进行内部调整，将多个知识源或多种方法整合在一起，只包含一个推荐器；常用的方法有特征组合、特征扩充和基于图模型的混合。
3.1 特征组合 基本思想：将不同的知识源进行整合。
图3.1 特征组合
3.2 特征扩充 基本思想：不是简单的对不同知识源进行混合，而是采用更为复杂的转换步骤。
常见做法：基于相关知识，利用一个模型的输出对另一个模型的输入特征进行扩充或增强。
例如：
图3.2 特征扩充实例
3.3基于图模型的混合 基本思想：利用图将多种不同的信息整合在一起进行统一表示；将推荐问题转化为一个图搜索或者边预测的问题。
目标：使推荐具有一个全面、统一的表示，能灵活支持多种推荐方法。
3.3.1基于双层图模型的混合推荐 图3.3双层图
图3.4双层图的混合推荐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3492823570ef66b393bf2127437b607c/" rel="bookmark">
			基于Python的信用评分卡模型建立和分析，万字阐述，收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和所有金融信贷业务一样,信用风险credit risk也是企业贷款面临的最主要风险，特别是中小微企业。随着微小企业信贷业务的迅速发展,客户群体的不断扩大,诸多大型企业（恒大，融创，st上市公司）暴雷，银行在大数据面前对于客户个人信用水平的把握变得越来越困难.如何科学,快速地识别个人客户和企业客户信用风险,成为微小贷款业务持续,健康发展的重要前提。
信用风险计量模型可以包括跟个人信用评级，企业信用评级和国家信用评级。人信用评级有一系列评级模型组成，常见是A卡（申请评分卡）、B卡（行为模型）、C卡（催收模型）和F卡（反欺诈模型）。 今天我们展示的是个人信用评级模型的开发过程，数据采用kaggle上知名的give me some credit数据集。
give me some credit数据集采用的是国外银行真实个人信贷数据，用于评估个人信贷逾期风险。give me some credit数据集变量不多，只有十余个，但每个变量都很精髓，值得我们深入研究。
一、建模流程 典型的信用评分卡模型如图1-1所示。信用风险评级模型的主要开发流程如下：
（1） 获取数据，包括申请贷款客户的数据。数据包括客户各个维度，包括年龄，性别，收入，职业，家人数量，住房情况，消费情况，债务等等。
（2） 数据预处理，主要工作包括数据清洗、缺失值处理、异常值处理、数据类型转换等等。我们需要把原始数据层层转化为可建模数据。
（3） EDA探索性数据分析和描述性统计，包括统计总体数据量大小，好坏客户占比，数据类型有哪些，变量缺失率，变量频率分析直方图可视化，箱形图可视化，变量相关性可视化等。
（4） 变量选择，通过统计学和机器学习的方法，筛选出对违约状态影响最显著的变量。常见变量选择方法很多，包括iv，feature importance，方差等等 。另外缺失率太高的变量也建议删除。无业务解释性变量且没有价值变量也建议删除。少数数据集存在数据泄露变量，这种模型各种性能会接近完美，需要踢除数据泄露变量。
（5） 模型开发，评分卡建模主要难点是woe分箱，分数拉伸，变量系数计算。其中woe分箱是评分卡中难点中难点，需要丰富统计学知识和业务经验。目前分箱算法多达50多种，没有统一金标准，一般是先机器自动分箱，然后再手动调整分箱，最后反复测试模型最后性能，择优选取最优分箱算法。
（6） 模型验证，核实模型的区分能力、预测能力、稳定性、排序能力等等，并形成模型评估报告，得出模型是否可以使用的结论。模型验证不是一次性完成，而是当建模后，模型上线前，模型上线后定期验证。模型开发和维护是一个循环周期，不是一次完成。
（7） 信用评分卡，根据逻辑回归的变量系数和WOE值来生成评分卡。评分卡方便业务解释，已使用几十年，非常稳定，深受金融行业喜爱。其方法就是将Logistic模型概率分转换为300-900分的标准评分的形式。
（8） 建立评分卡模型系统，根据信用评分卡方法，建立计算机自动信用化评分系统。美国传统产品FICO有类似功能，FICO底层语言是Java。目前流行Java，python或R多种语言构建评分卡自动化模型系统。
（9）模型监控，着时间推移，模型区分能力，例如ks,auc会逐步下降，模型稳定性也会发生偏移。我们需要专业模型监控团队，当监控到模型区分能力下降显著或模型稳定性发生较大偏移时，我们需要重新开发模型，迭代模型。模型监控团队应该每日按时邮件发送模型监控报表给相关团队，特别是开发团队和业务团队。
二. 获取数据
建模数据方面包含借款申请人填写的基本资料，通讯录，通话记录和其他运营商数据，以及在其他第三方平台提供的黑名单和其他借贷平台借贷还款数据，和app抓取的手机数据，有些还包含人行征信，社保公积金工资银行流水，个人消费等数据，针对不同额度和客群需要用户填写和授权的资料不一样。收集需要的数据后，通过SQL提取相关变量特征构造建模用的宽表。具体建模信息如下图。
python评分卡建模实战数据集
之前我讲过利用German credit德国信用数据集建立python信用评分卡模型，该数据集优势是数据量小，对计算机硬件要求不高，方便各个阶层学员学习和测试。
信用评分算法对违约概率进行猜测，是银行用来确定是否应授予贷款的方法。数据属于个人消费类贷款，通过预测某人在未来两年内遇到财务困境的可能性，提高信用评分的最新水平。
银行在市场经济中发挥着至关重要的作用。他们决定谁可以获得资金以及以什么条件获得资金，并且可以做出投资决策或终止投资决定。为了让市场和社会发挥作用，个人和公司需要获得信贷。
give me some credit有15万样本数据，该数据量解决中大型金融机构实战数据，更加接近金融企业项目实战。该数据集通过预测某人在未来两年内遇到财务困难的可能性，提高信用评分的水平。
变量中文释义，变量少而精，可作为建模的参考
我们对上述变量归类，主要分为：
– 基本属性：包括了借款人当时的年龄。
– 偿债能力：包括了借款人的可用额度比值、月收入、负债比率。
– 信用历史：两年内35-59天逾期次数、两年内60-89天逾期次数、两年内90
天或高于90天逾期的次数。
– 财产状况：包括了开放式信贷和贷款数量、不动产贷款或额度数量。
– 其它因素：借款人的家属数量（不包括本人在内）
kaggle模型竞赛中，奖金5000美金，模型评估指标为AUC。
互联网上国内外关于give me some credit数据集AUC得分最佳表现为0.85.
但我方《python信用评分卡建模（附代码）》教程中AUC可以达到0.929，调参后AUC可以更高，远高于互联网上give me some credit论文的模型性能AUC=0.85。互联网论文关于建模步骤有很多看似有理，但实际上不正确的理论。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3492823570ef66b393bf2127437b607c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca8c329b96b5c730ab698283a4ed0ae/" rel="bookmark">
			Java项目:考试系统(java&#43;JSP&#43;bootstrap&#43;Servlet&#43;Mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：俺的博客首页 "资源" 里下载！ 项目介绍 本系统分为两个角色，一个是考生，一个是管理员，
考生功能如下：
登录、选择考试科目、选择考卷、在线考试、提交试卷、并且查询自己的考试成绩
管理员功能如下：
登录、添加试卷、并且添加试卷里的题目、编辑科目、还可以查询所有考生的成绩
环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.数据库：MySql 5.7版本；
6.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
技术栈 1. 后端：servlet
2. 前端：JSP+bootstrap+jQuery
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，Eclipse/MyEclipse导入时，若为maven项目请选择maven;
若为maven项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中db.properties配置文件中的数据库配置改为自己的配置;
4. 运行项目，在浏览器中输入http://localhost:8080/ 登录
学生管理控制层： @Controller @SuppressWarnings("all") public class StudentInfoHandler { @Autowired private StudentInfoService studentInfoService; @Autowired private ClassInfoService classInfoService; @Autowired private ExamSubjectMiddleInfoService examSubjectMiddleInfoService; @Autowired private ExamHistoryPaperService examHistoryPaperService; @Autowired private ExamChooseInfoService examChooseInfoService; @Autowired private ExamSubjectMiddleInfo esm; @Autowired private ClassInfo classInfo; @Autowired private ExamPaperInfo examPaper; @Autowired private GradeInfo grade; @Autowired private StudentInfo student; @Autowired private ExamPaperInfoService examPaperInfoService; private Logger logger = Logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca8c329b96b5c730ab698283a4ed0ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b420285e020a466799e370371d33f8d/" rel="bookmark">
			基于开源WebRTC开发实时音视频靠谱吗？第3方SDK有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 利用Google开源的WebRTC来开发自已的实时音视频系统，靠不靠谱这个问题一直被问到，其实很难一两句话说清楚，因为答案不是一个靠谱或不靠谱可以回答好的，既然被反复问到，今天就系统地整理参考答案。
从大的方向看WebRTC是非常靠谱 原因如下：
使跨平台、跨浏览器通讯成为可能，而且大大加速了这个进程，这就是GoogleWebRTC大受欢迎的主要原因；
大厂商都在跟进，从底层芯片厂商到上层应用厂商，如英特尔、ARM、微软、苹果、宝利通、Vidyo等等；
国内提供音视频PaaS和SaaS服务的厂商都是基于WebRTC开发的，包括QQ、微信，以及从腾讯和YY出来创业的小伙伴；
Google已经基于WebRTC做出了成功应用Hangout和Duo;
WebRTC很适合直播场景：推流采用WebRTC，观看采用现有的CDN方案，结合使用，花椒直播、千帆直播就是最好的案例；
其他的单独抽取部分模块进行使用的例子我就不列举了，太多了。
列举了这么多你是不是觉得WebRTC很靠谱？是的，很靠谱，不然为什么这么多公司，这么多人为什么研究和使用？
但对于个人或创业公司来说，难度却不小 原因包括但不限于下面这些：
WebRTC代码庞大，环境配置复杂，加上对Google的各种封杀，将简单Demo运行起来门槛都很高，当然如果你只是做H5开发，不需要做Native可以跳过这一点；
WebRTC只是一个客户端，更适合1对1，并不适合多对多的视频通话，如视频会议，如果你想支持多方，还得借助其他服务端，但这块是个比较有门槛的技术活（有兴趣的可以了解下Dialogic）；
WebRTC虽然提供了很多信号处理、回声消除、编解码的库，但直接拿过来就想达到QQ和微信的水平，还得下很大功夫去优化，不然也只是微信的6~7分水平；
服务端部署问题，微信效果能这么好，是因为他在很多地方都有部署服务器，可以最大限度降低延迟和保证通话质量，但如果完全采用P2P，是很难达到同等水准的；
所以如果你本身没有音视频开发经验、项目时间又紧、而且后续也不想投入太多资源在这上面，基本上你就不用考虑WebRTC了，采用或暂时先采用其他方案或直接用其他第三方SDK吧！
那么问题来了，市面上主流提供实时音视频服务的SDK有哪些呢？
主流的第3方实时音视频云服务SDK 按照正常逻辑现在这里应该插一个软广告，介绍哪家第三方SDK效果如何如何好、低延迟、高并发、无卡顿、超高清、全球领先，哈哈哈，这里推荐几家比较有实力的厂商供参考（无任何利益关联，排名不分先后）：
1、腾讯SDK；
2、声网，YY团队；
3、即构，QQ团队；
4、叁体，WebEx/Cisco团队；
5、Zoom，思科团队；
6、vidyo，钉钉方案供应商；
7、世纪鼎点，映客方案供应商；
8、一块，尚未提供sdk，但技术确实牛；
9、如有遗漏欢迎底下留言补充。。。
其实对我们用户来说，如何评判一个第三方SDK是否适合，主要从以下几个方面：
1、需求是否能满足？效果怎么样？
2、技术支持是否给力？
3、价格是否合理？
4、是否存在同质业务？
5、更多可留言补充。
上面第4点可能有些人不太明白，特别解释一下，有些提供SDK或PaaS服务的厂商本身也会去做SaaS，比如腾讯既有提供音视频SDK，但也有做在线教育。所以我们在使用类似服务的时候一定要考虑到如果跟他存在同质业务，以后会不会影响到我们，毕竟不是每个PaaS厂商都能像腾讯一样体量那么大，内部团队间又有竞争关系的。
一般既做PaaS又做SaaS产品的公司肯定是没多大前途的，不够专注，也谈不上核心竞争力，当然腾讯除外。
如果想考虑得再长远一点，我们可能还得看PaaS厂商的投资背景，假如某厂商就是360投资的，那你还敢用他们的平台来做美女直播吗？（360已经有了花椒直播）。
以上纯属个人观点，不与任何利益相关联。
【私信扣1免费分享】资料包括《Andoird音视频开发必备手册+音视频学习视频+学习文档资料包+大厂面试真题+2022最新学习路线图》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc89a0ade4b2011a4869dce693a6c2a/" rel="bookmark">
			QML学习十五：ListView的简单使用（内建Model）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处
一、概念 1、MVC 作为一种经典的架构模式，通过把职责、性质相近的成分归结在一起，不相近的进行隔离，MVC将系统分解为模型、视图、控制器三部分，每一部分都相对独立，职责单一。MVC是对系统复杂性的一种合理的梳理与切分，它的思想实质就是“关注点分离”。
QT中的Model-View编程框架，对Controller部分做了改动，引入了Delegate的概念，合起来就是Model-View-Delegate。
在QT C++中，对Model-View-Delegate已经做了基础的实现，不必去设计Model-View框架，只需学习Qt给的框架即可。
2、ListView ListView用来一个条目列表，条目对应的数据来自于Model， 而每个条目的外观则由Delegate决定。
要使用ListView，必须指定一个Model、一个Delegate。
Model可以是QML内建类型，如ListModel、XmlListModel，也可以是在C++实现的QAbstractItemModel或QAbstractListModel的派生类。
二、ListView简单的使用 1、简单的显示例子 修改main.qml内容：
import QtQuick 2.12 import QtQuick.Window 2.12 import QtQuick.Controls 2.12 import QtQuick.Layouts 1.12 import MyObj 1.0 Window { id: window visible: true width: 600 height: 480 title: qsTr("Hello World") Rectangle { width: 360 height: 300 color: "#EEEEEE" Component { id: phoneDelegate Item { id: wrapper width: parent.width height: 30 MouseArea { anchors.fill: parent onClicked: wrapper.ListView.view.currentIndex = index } RowLayout { anchors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc89a0ade4b2011a4869dce693a6c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f368e5498aaf17b524f4e66f1484cac0/" rel="bookmark">
			Java必知习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章：Java简介 —— 自我检测（答案） 1、填空题 1、 Java源程序文件的后缀是 *.java ，Java字节码文件的后缀名称是 *.class 。
2、 Java程序实现可移值性，依靠的是 JVM 。
3、 Java语言的三个分支是： JAVA SE 、 JAVA ME 、 JAVA EE 。
4、 Java程序由 类 组成，如果Java使用 public class 声明类，则文件名称必须与类名称一致。
5、 Java执行是从 main() 方法开始执行的，此方法的完整定义是 public static void main(String args[]) 。
6、 从命名标准上来讲，Java类名的每个单词的首字母通常要求 大写 。
7、 当使用java命令解释一个程序时，一定需要 classpath 环境属性来定位类资源路径；
2、选择题 1、 下面那个是属于解释Java程序所使用到命令？（A）
A、 java.exe B、 javac.exe C、 keytool.exe D、 cmd.exe
2、 下面的那个环境变量java解释时所需要的 B 。
A、 path B、 classpath C、 JAVA_HOME D、TEMP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f368e5498aaf17b524f4e66f1484cac0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/137/">«</a>
	<span class="pagination__item pagination__item--current">138/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/139/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>