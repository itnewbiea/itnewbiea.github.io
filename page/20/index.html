<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/511db0999804ca67193a45d17acb8673/" rel="bookmark">
			GitHub Copilot 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一·简介 GitHub Copilot是一个AI编程助手，它能够为开发者提供代码建议和自动完成功能。Copilot使用自然语言处理技术来理解代码的语义，并根据上下文提供智能化的代码建议。通过使用Copilot，开发者可以提高编码效率，减少错误率，并加速开发过程。
二·内容介绍 GitHub Copilot是一个基于AI的编程助手，它可以帮助开发者提高编码效率和质量。以下是GitHub Copilot中包含的一些主要功能和特点：
代码建议：Copilot可以分析代码的上下文和语义，提供智能化的代码建议。这些建议包括变量名、函数名、类定义、注释等，可以根据不同的编程语言和开发环境进行个性化定制。自动完成：Copilot还提供自动完成功能，可以根据输入的代码自动补全代码片段。这可以大大减少手动编写代码的工作量，提高开发效率。语法检查：Copilot可以分析代码的语法，检查潜在的错误和问题，并提供相应的修复建议。这有助于开发者及时发现和修复代码中的问题，减少运行时错误和调试时间。集成开发环境（IDE）集成：Copilot可以与多种流行的集成开发环境（IDE）集成，如Visual Studio Code、Neovim、JetBrains等。这使得开发者可以在他们习惯的IDE中使用Copilot，方便快捷地进行编程工作。自定义代码片段：开发者可以创建自己的代码片段，并将其保存为模板。在编写代码时，Copilot可以自动提供这些模板，方便快速插入常用的代码块。学习资料：GitHub Copilot官方提供了详细的使用文档和教程，帮助开发者更好地了解和使用Copilot的功能和特点。此外，开发者还可以在GitHub Copilot社区中与其他用户交流使用心得和技巧，获取更多的学习资源。 三·安装与配置 安装条件：首先确保你的机器上已经安装了Python和Visual Studio Code编辑器。Copilot支持Windows、macOS和Linux操作系统。
安装Copilot：打开Visual Studio Code编辑器，在侧边栏中点击Extensions图标，搜索“GitHub Copilot”并安装。
配置API密钥：为了使用Copilot，你需要在GitHub上获取API密钥。访问GitHub官网，在个人账户设置中生成一个新的API密钥，并将其复制到剪贴板中。
配置Copilot：在Visual Studio Code编辑器中，打开“File”菜单，选择“Preferences”-&gt;“Settings”。在弹出的设置窗口中，粘贴以下配置：
"copilot.accessToken": "YOUR_ACCESS_TOKEN" 将"YOUR_ACCESS_TOKEN"替换为之前复制的API密钥。
四·使用Copilot 打开一个编程项目：在Visual Studio Code编辑器中打开你要编程的项目。确保你的代码文件是以编程语言编写的（如Python、JavaScript等）。启动Copilot：按下“Ctrl+Shift+P”组合键（Windows/Linux）或“Cmd+Shift+P”组合键（macOS），打开命令面板。在命令面板中输入“Copilot: Start Session”，并选择该命令。使用代码建议：Copilot会自动分析你的代码，并根据上下文提供代码建议。你可以通过按下“Tab”键来选择一个建议，将其插入到你的代码中。如果你想接受多个建议，可以使用“Ctrl+Shift+Enter”组合键（Windows/Linux）或“Cmd+Shift+Enter”组合键（macOS）来接受所有建议。自动完成：Copilot还提供自动完成功能。当你在编写代码时，它会自动为你完成变量名、函数名等。要触发自动完成，可以使用“Ctrl+Space”（Windows/Linux）或“Cmd+Space”（macOS）。关闭Copilot：当你不再需要Copilot时，可以按下“Ctrl+Shift+P”组合键（Windows/Linux）或“Cmd+Shift+P”组合键（macOS），打开命令面板，输入“Copilot: Stop Session”，并选择该命令来关闭Copilot。 五·高级功能 自定义代码片段：你可以使用Copilot的自定义代码片段功能来创建自己的代码模板。例如，你可以创建一个Python函数模板，并在编写函数时快速插入该模板。要创建自定义代码片段，请在命令面板中输入“Copilot: Create Snippets”，并按照提示操作。集成终端：Copilot还集成了终端功能，方便你在编程时执行命令。要打开终端，请按下“Ctrl+Shift+”（Windows/Linux）或“Cmd+Shift+”（macOS）。在终端中输入命令后，按下回车键即可执行。调试助手：Copilot还提供了调试助手功能，帮助你在编写代码时进行调试。当你在代码中设置断点后，Copilot会自动显示调试信息，包括变量值、调用堆栈等。要使用调试助手，请在命令面板中输入“Copilot: Start Debugging”，并按照提示操作。学习资料：如果你想深入了解Copilot的更多功能和技巧，可以查看GitHub Copilot官方文档和教程。这些资料将为你提供更详细的指导和示例。社区支持：你也可以加入GitHub Copilot社区，与其他开发者交流经验和使用心得。社区中有许多有用的讨论和资源，可以帮助你更好地利用Copilot提高编程效率。 六·总结 GitHub Copilot是一个强大的AI编程助手，能够帮助开发者提高编码效率和质量。通过本文的介绍，你应该已经了解了如何快速安装和配置Copilot，以及如何使用它来提供代码建议和自动完成功能。当然，Copilot还有许多高级功能等待你去探索和利用。希望本文能够帮助你开始使用GitHub Copilot，并享受它带来的便利和高效编程体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fdb10664175b7bb1d5cc3dde61fe52/" rel="bookmark">
			李宏毅机器学习第二十三周周报 Flow-based model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 week 23 Flow-based model摘要Abstract一、李宏毅机器学习1.引言2.数学背景2.1Jacobian2.2Determinant2.3Change of Variable Theorem 3.Flow-based Model4.GLOW 二、文献阅读1. 题目2. abstract3. 网络架构3.1 change of variable formula3.2 Coupling layers3.3Properties3.4Masked convolution3.5Combing coupling layers3.6Multi-scale architecture 4. 文献解读4.1 Introduction4.2 创新点4.3 实验过程4.4 结论 三、实验内容1.任务概述2.数据集介绍3.模型参数4.结果展示5.代码部分小结参考文献 week 23 Flow-based model 摘要 本文主要讨论了基于流的模型的。本文介绍了在之前介绍的几种模型的缺点，并引出了流模型。在此基础上，本文分别阐述了流模型的数学基础及模型的多种实现方式。其次本文展示了题为Density estimation using Real NVP的论文主要内容。这篇论文提出了Coupling layer以及Real NVP模型，该模型使用实值非体积保持变换（real-valued non-volume preserving transformation）。该文在四个数据集上进行实验，从数据角度证明了该网络的优越性。最后，本文基于pytorch实现了Seq2Seq（LSTM2LSTM）模型并用于预测ETTh数据集的后续结果。
Abstract This article focuses on flow-based models. This article describes the shortcomings of several models described earlier and introduces the flow model. On this basis, this article expounds the mathematical basis of the flow model and the various implementation methods of the model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fdb10664175b7bb1d5cc3dde61fe52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb068d6fa4ad59eb75081d1522a6aaf/" rel="bookmark">
			HTML5-新增全局元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML5中升级后的a元素 HTML5为a元素新增了3个属性
属性说明download定义可被下载的目标（如文件，图片等）media定义被链接文档为何媒介/设备优化的type定义被链接文档的MIME类型 语法:
&lt;a href="文件地址" download="新文件名"&gt;&lt;/a&gt; 注意：download属性用于为文件取一个新的文件名。如果download属性值省略，则表示使用旧的文件名
实例:
&lt;a href="../img/OIP-C.jpg" download="a.jpg"&gt;下载图片&lt;/a&gt;&lt;br/&gt; &lt;a href="../img/OIP-C.jpg" download&gt;下载图片&lt;/a&gt; 运行结果
全局元素相关 新增全局元素（任何元素都可以使用） 属性说明contenteditable规定是否可编辑元素的内容hidden规定元素是否被隐藏draggable元素是否可以被拖动spellcheck对用户输入的文本内容进行拼写和语法检查date-*为元素实现自定义属性 contenteditable属性、 概念：contenteditable属性规定是否可编辑元素的内容，前提是该元素必须可以获得光标焦点并且其内容不是只读的。
语法：
&lt;element contenteditable=""&gt;&lt;/element&gt; 属性值：
true：元素内容可以被编辑
false：默认值，元素内不能被编辑
实例：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;contenteditable属性&lt;/title&gt; &lt;style&gt; p{ display:inline-block; padding:10px; border:1px dashed gray; background-color:#f1f1f1; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p contenteditable="true"&gt;这是一段可以被编辑的文字&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 运行结果：
hidden属性 概念：hidden元素规定元素是否被隐藏。
语法：
&lt;element hidden="hidden"&gt;&lt;/element&gt; 属性值
hidden：元素会被隐藏。
默认值：元素会被显示
注意：使用hidden属性仅仅是隐藏了元素的显示，但元素仍然存在于HTML文档中占据空间，可以通过JavaScript等技术访问它们。CSS中的display:none是完全消失不占据空间，属性和样式不存在
实例
&lt;ol&gt; &lt;li&gt;数学&lt;/li&gt; &lt;li hidden&gt;语文&lt;/li&gt; &lt;/ol&gt; 运行结果
draggable属性 概念:draggable属性来定义某一个元素是否可以被拖动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb068d6fa4ad59eb75081d1522a6aaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5052207db4be4bc43d7cb4a387996ee4/" rel="bookmark">
			【12.30】转行小白历险记-刷算法06
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01补充一下：哈希表的基础知识 1. 创建哈希表 在 JavaScript 中，您可以使用对象或 Map 来创建一个哈希表。
使用对象： let hashTable = {}; 使用 Map 对象： let hashMap = new Map(); 2. 插入键值对（Add / Set） 向哈希表中添加键值对。
使用对象： hashTable[key] = value; 使用 Map 对象： hashMap.set(key, value); 3. 搜索键值（Get） 根据键获取哈希表中的值。
使用对象： let value = hashTable[key]; 使用 Map 对象： let value = hashMap.get(key); 4. 检查键是否存在（Check for Key） 检查哈希表中是否存在某个键。
使用对象： let exists = key in hashTable; 使用 Map 对象： let exists = hashMap.has(key); 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5052207db4be4bc43d7cb4a387996ee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0422c6fb178f799961cb4216ce2e3fb1/" rel="bookmark">
			蓝桥杯单片机国一分享——你的蓝桥杯单片机第一课，如何入门与如何备赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 获取信息的途径 其实任何教程或者任何网站都都不可能做得尽善尽美，甚至是官方的也是如此，也不可能适合每个人，所以我首先向你们提供我在备赛时使用到的几个有用的网站，
官网：https://dasai.lanqiao.cn/
官网是获取最权威信息的渠道，我会列举出最常用的几种用法：
（1）官方通知信息：https://dasai.lanqiao.cn/notices/?progid=20
（官方会在这里发布报名时间，省赛时间，决赛地点与时间等官方信息）
（2）部分往届试题：https://www.lanqiao.cn/courses/2786
（3）功能包下载：https://dasai.lanqiao.cn/notices/1096/
（4）比赛大纲：https://dasai.lanqiao.cn/notices/846/单片机教程（基础）：
（1）小蜜蜂老师：
https://www.xmf393.com/2019/06/11/lqbmcu/
https://www.cnblogs.com/ALittleBee/category/1153248.html（一位国一的学长推荐的）
（2）江科大：https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7bbed4bd56787012aaa2a6203c34509e（很多人用）
（3）郭天祥老师：https://www.bilibili.com/video/BV1DW411a7mz/?spm_id_from=333.337.search-card.all.click（我使用的一个教程，有些人觉得很枯燥、太罗嗦，但是我觉得讲的很全面，把原理讲得很清楚，便于我深入理解，可以去学校图书馆借一本对应的书来看）单片机教程（进阶）：
到现在为止我看到的之后基础的视频，并没有真题与进阶的视频，所以我想自己写一个进阶的教程，想知道后续的请关注我的博客 第二章 比赛流程 在实际参加比赛之前，蓝桥杯比赛流程的各种细节我都不太了解，随着我不断对这些细节进行了解，我也被迫不断调整自己的备赛方案，现在我就把这些细节列出来，让大家不用走弯路了
省赛一般是在本校比，国赛以前好像是去北京比，但是2023年之后都是在本省的学校比，具体地点会在临近比赛前两三个星期公布比赛时使用的数据包会在省赛前两三个星期公布，国赛一般都是继续使用这个包比赛时不能带自己的电脑和移动存储设备，也就是不能事先准备好代码 第三章 准备流程 一、编程题学习 1.由于我们学校没有更新keil，是用keil4比赛的，所以要使用的代码可能要下载keil4，要是无法打开下载的keil4，可以在路径下找到C:\Keil_C51_New\UV4，打开UV4.exe
下载地址：https://gitee.com/late-night-study/Tech/blob/master/keil4C51%E4%B8%8B%E8%BD%BD.zip
2.还有教程中用到的文件和代码
https://gitee.com/late-night-study/Tech
简单模块学习：
（1）先大概学习一遍基础视频
（2）看我的进阶教程，然后模仿我的写法（我的代码是经过多次更新的，可能不是最快写出来的，可能不是效果最好的，但是一定是最清晰的，是可以进国赛的）复杂模块
（1）先学习位操作，定时器分配进程，固定的文件格式
（2）根据第一点学的内容，深入学习复杂模块参考流程
（1）先2倍速将江科大1-1到3-4和小蜜蜂老师基础技能2-3的基本概念都看一遍，最好记录一下每章学了什么，之后有哪个小知识点不太懂再回头看多几遍
【51单片机入门教程-2020版 程序全程纯手打 从零开始入门】 https://www.bilibili.com/video/BV1Mb411e7re/?share_source=copy_web&amp;vd_source=c4fc67867c5218768e783d04475bc5a2
【【小蜜蜂笔记】蓝桥杯大赛-单片机设计与开发基础技能与进阶强化教程】 https://www.bilibili.com/video/BV1Bt41187hw/?share_source=copy_web&amp;vd_source=c4fc67867c5218768e783d04475bc5a2
（2）学习基本代码书写格式
http://t.csdnimg.cn/wO5ms
（3）学习基本通讯协议的学习方法
http://t.csdnimg.cn/5CdRg ------------------持续更新---------------------------------------------------
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deeed642c2e639c39a241cac0e7547c9/" rel="bookmark">
			【MATLAB】BiGRU神经网络时序预测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~也可转原文链接获取~
1 基本定义 BiGRU神经网络时序预测算法是一种基于双向门控循环单元（GRU）的多变量时间序列预测方法。该方法结合了双向模型和门控机制，旨在有效地捕捉时间序列数据中的时序关系和多变量之间的相互影响。
具体来说，BiGRU模型由两个方向的GRU网络组成，一个网络从前向后处理时间序列数据，另一个网络从后向前处理时间序列数据。这种双向结构可以同时捕捉到过去和未来的信息，从而更全面地建模时间序列数据中的时序关系。在BiGRU模型中，每个GRU单元都有更新门和重置门来控制信息的流动。更新门决定了当前时刻的输入是否对当前状态进行更新，而重置门决定了如何将过去的状态与当前输入结合起来。通过这些门控机制，BiGRU模型可以自适应地学习时间序列数据中的长期依赖关系和多变量之间的相互影响。
此外，值得注意的是，该模型中的训练过程可以通过适当的损失函数（如均方误差）来衡量预测结果与真实标签之间的差异，并通过反向传播算法来更新网络中的连接权重。通过反复迭代训练，BiGRU模型可以逐渐学习到时间序列数据的特征和模式，从而实现准确的多变量时间序列预测。
BiGRU算法在多变量时间序列预测问题中具有广泛的应用潜力，例如股票价格预测、交通流量预测、气象数据预测等领域。它是一种基于深度学习的方法，通过对大量历史数据的学习来预测未来的发展趋势。在金融领域中，可以使用BiGRU算法来预测股票价格走势、分析市场情绪等。在交通领域中，可以用于交通流量预测、路况分析等。在气象领域中，可以用于气象数据分析、天气预报等。
除了BiGRU模型，还有其他一些常见的时序预测算法，如ARIMA、SARIMA、VAR等。这些方法通常基于统计模型，通过分析时间序列数据的统计特性来进行预测。与BiGRU模型相比，这些方法通常更简单、易于理解和实现，但对于复杂的时间序列数据，其预测性能可能不如基于深度学习的方法。
另外，还有一些混合方法，即将深度学习与统计模型相结合，以充分利用两者的优点。例如，可以使用深度学习模型（如BiGRU）来提取时间序列数据中的特征，然后使用统计模型进行预测。这种方法可以结合深度学习模型的强大特征提取能力和统计模型的预测性能，从而提高预测的准确性和稳定性。
总之，选择合适的时序预测算法需要考虑具体问题、数据特性、计算资源和时间复杂度等方面的因素。在实践中，可以通过实验和交叉验证来评估不同算法的性能，并选择最适合特定问题的预测方法。
此外，为了提高BiGRU模型的预测性能，还可以采用一些技巧和策略。例如，可以采用正则化技术来防止模型过拟合，如L1/L2正则化、dropout等。还可以使用集成学习（ensemble learning）方法，将多个BiGRU模型组合起来，通过集成它们的预测结果来提高预测的准确性和稳定性。
另外，为了更好地训练BiGRU模型，可以采用一些优化算法，如Adam、RMSprop等。这些优化算法可以自动调整学习率，并在训练过程中逐步更新网络权重，以最小化损失函数。此外，还可以采用早停法（early stopping）来避免过度拟合，即在验证损失停止下降时停止训练，以避免过拟合。
此外，为了更好地处理多变量时间序列数据，可以将BiGRU模型扩展为多变量BiGRU模型。该模型将多个BiGRU单元连接起来，每个BiGRU单元负责处理一个变量的时间序列数据。通过将多个BiGRU单元组合在一起，多变量BiGRU模型可以同时捕捉多个变量之间的相互影响和时序关系，从而更准确地预测未来的发展趋势。
总之，BiGRU神经网络时序预测算法是一种强大的时序预测方法，具有广泛的应用前景。通过结合适当的技巧和策略，可以进一步提高其预测性能和稳定性。在未来，随着深度学习技术的不断发展，基于深度学习的时序预测算法有望在更多领域中得到应用和推广。
2 出图效果 附出图效果如下：
附视频教程操作：
【MATLAB】BiGRU神经网络时序预测算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4a0c68e44a0f1cab89636a467446a8/" rel="bookmark">
			【数据库设计和SQL基础语法】--用户权限管理--数据备份和恢复策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 数据备份和恢复是数据库管理中至关重要的任务，对于确保数据安全性和业务连续性具有重大的意义。以下是一些关键的重要性方面：
防止数据丢失： 数据备份是防止因硬件故障、人为错误、恶意攻击或其他意外事件导致数据丢失的主要手段。通过定期备份数据，可以最小化潜在的信息损失。应对灾难： 自然灾害、火灾、洪水、地震等不可预测的灾难可能导致数据中心的完全或部分破坏。备份数据可以用于快速恢复业务，并降低因灾难性事件造成的影响。应对人为错误： 人为错误是数据丢失的常见原因之一。这可能包括误删除、更新错误或不慎执行的SQL语句。备份允许在出现问题时迅速还原到之前的状态。满足合规性要求： 许多行业和法规对于数据的长期存储和备份提出了具体要求。合规性要求可能涉及到备份的频率、数据的保存期限以及数据存储的安全性等方面。保障业务连续性： 数据是现代业务运营的核心。数据库的持续可用性对于业务连续性至关重要。通过备份和恢复策略，可以更快地从故障中恢复，并减少因系统停机而导致的损失。支持测试和开发： 在开发和测试环境中，备份数据可以用于创建与生产环境相似的测试环境。这有助于确保新的应用程序版本、更新或配置更改在生产环境中的运行良好。保护数据完整性： 数据备份不仅仅是为了应对灾难，还有助于保护数据的完整性。在进行数据库维护、升级或迁移时，备份可用于回滚到安全状态。 二、数据库备份策略 2.1 定期完整备份 什么是完整备份
完整备份是一种备份数据库中所有数据的操作。在完整备份过程中，数据库管理系统将数据库的整个内容复制到备份存储位置，包括所有表、索引、存储过程、触发器等数据库对象。完整备份是数据库备份中最基本、最全面的一种备份方式。
完整备份的执行频率
完整备份的执行频率在很大程度上取决于多个因素，其中最关键的因素之一是业务需求。在确定完整备份的执行频率时，数据库管理员需要综合考虑数据的变化率、业务对数据恢复的要求、备份存储的可用性以及备份对系统性能的影响。
首先，对于变化率较低的数据库，执行完整备份的频率可以相对较低。这是因为数据变化较少，相邻两次备份之间的差异有限，因此频繁执行完整备份可能是冗余的。反之，对于变化率高的数据库，更频繁的完整备份可能更为合适，以捕捉到更多的数据变化，减小备份之间的差异。
其次，业务对数据恢复的要求也是决定完整备份频率的关键因素。如果业务对数据的及时性和准确性要求较高，那么可能需要更频繁的完整备份，以确保在发生故障时可以尽快恢复到最新的状态。相反，如果业务能够容忍一定程度的数据丢失，完整备份的频率可以相对较低。
此外，备份存储的可用性也需要考虑。频繁执行完整备份可能导致大量的存储需求，因此需要确保有足够的备份存储空间。这可能涉及到硬件成本、云存储费用等方面的考虑。
最后，数据库管理员还需要评估完整备份对系统性能的影响。备份通常会占用系统资源，可能导致数据库性能下降。因此，在选择完整备份的执行频率时，需要在备份和业务运行之间取得平衡，以最小化备份对正常业务操作的干扰。
2.2 差异备份 差异备份概述
差异备份是一种备份策略，其核心思想是只备份自上次完整备份或差异备份以来发生更改的数据。与完整备份不同，差异备份仅记录数据库中自上次备份以来发生的变化，从而减少备份所需的存储空间和时间。
与完整备份的关系
差异备份和完整备份是数据库备份策略中的两种不同类型，它们之间存在紧密的关系。理解它们之间的关系有助于有效制定备份策略和进行数据恢复。
初始完整备份： 差异备份通常需要依赖于初始的完整备份。在备份周期开始时，首先执行一次完整备份，将整个数据库的内容保存到备份存储介质中。这个完整备份建立了差异备份的基础。差异备份的生成： 一旦完成初始完整备份，接下来的备份可以是差异备份。差异备份捕获了自上次完整备份或差异备份以来发生的所有变化。它记录了数据库中的新增、修改或删除的数据块，而不是整个数据库。这使得差异备份相比完整备份更为高效，减小了备份所需的存储空间和备份过程的时间。恢复过程： 在进行数据恢复时，首先需要还原最近的完整备份。然后，可以应用相应的差异备份，逐步将数据库恢复到最新的状态。由于差异备份只包含了变化的部分，相较于只使用完整备份，数据恢复的时间可以得到显著减少。备份链的管理： 完整备份和差异备份形成了备份链。备份链的长度由完整备份的频率和差异备份的数量共同决定。数据库管理员需要定期执行完整备份，以控制备份链的长度并避免潜在的备份文件过大的问题。 Tip：差异备份是建立在完整备份基础上的，通过记录自上次备份以来的变化，实现了更高效的备份和恢复过程。完整备份提供了备份链的初始点，而差异备份则为备份链的中间和后续部分提供了增量的内容。两者协同工作，形成了综合而强大的数据库备份策略。
2.3 事务日志备份 事务日志的作用
事务日志（Transaction Log）在数据库管理中扮演着关键的角色，其作用涵盖了数据恢复、事务原子性、性能优化和数据库复制等多个方面。以下是事务日志的详细作用：
数据恢复： 事务日志记录了数据库中每个事务的详细操作，包括对数据的修改。在发生数据库故障、硬件故障、意外关机或其他灾难性事件时，事务日志允许数据库管理系统回滚到事务发生之前的状态，从而实现数据的恢复。通过重放日志中的事务记录，数据库可以逐步还原到最后一次完整备份或差异备份的状态。事务原子性的保证： 事务日志对数据库的每个事务进行记录，确保了事务的原子性。在事务提交之前，相关的修改操作会被写入事务日志。如果事务未能成功完成，数据库系统可以通过回滚日志中的信息来撤销已经进行的修改，确保数据库的一致性。性能优化： 事务日志的使用可以提高数据库的性能。通过先将事务的修改操作记录到日志中，而不是直接写入数据库文件，可以减少磁盘I/O的次数，提高事务的执行速度。数据库系统可以异步地将日志中的修改操作应用到实际的数据库文件，从而提升事务的响应时间。数据库复制和高可用性： 事务日志对于数据库复制和高可用性架构非常重要。在数据库复制中，主数据库的事务日志可以被传送到一个或多个备份数据库，确保备份数据库与主数据库保持一致。在高可用性方案中，事务日志的同步传输和应用可以确保在主数据库发生故障时，备份数据库能够快速地接管工作，实现故障切换。回滚和恢复数据库： 事务日志允许数据库管理员执行回滚操作，将数据库恢复到之前的状态。这对于误操作、错误的数据更新或者灾难性事件的恢复非常有用。通过事务日志，可以迅速地回滚到某个时间点，而无需完整地还原整个数据库。 事务日志备份的频率
事务日志备份的频率是一个重要的数据库管理决策，需综合考虑业务需求、数据重要性、恢复时间目标以及备份存储的可用性等多个因素。一般而言，事务日志备份的频率可以根据以下几个方面进行综合考虑。
首先，业务需求对备份频率有直接的影响。如果业务对于数据恢复的要求较高，例如需要尽可能减小数据丢失的时间窗口，那么事务日志备份的频率可能需要相对较高。相反，如果业务能够容忍一定程度的数据丢失，备份频率可以适度减少。
其次，考虑数据的重要性。对于关键业务数据，通常需要更频繁的事务日志备份，以确保对数据的及时保护和恢复。对于较为次要的数据，备份频率可以相对较低。
第三，需要根据恢复时间目标来确定备份频率。如果业务对于数据恢复的时间有较紧迫的要求，可能需要更频繁的事务日志备份，以便在发生故障时可以更迅速地还原到最近的时间点。
此外，备份存储的可用性也是备份频率的考虑因素。较高的备份频率可能导致较大的备份文件数量和更多的存储需求。数据库管理员需要确保备份存储系统能够支持所选备份频率，避免因存储空间不足或性能瓶颈而影响备份的有效性。
最后，备份策略需要综合考虑完整备份、差异备份和事务日志备份的协同作用。不同类型的备份互相补充，共同构成了综合的数据保护方案。备份频率的设计应该考虑到这些备份类型的关系，以确保在发生故障时能够快速、可靠地恢复数据。
三、恢复策略 3.1 完整恢复 完整备份的恢复过程
完整备份的恢复过程是数据库管理中关键的步骤，它涉及将整个数据库从备份中还原到先前的状态。以下是完整备份的恢复过程的一般步骤： 准备备份： 在开始恢复过程之前，需要确保有最新的完整备份可供使用。这通常涉及到备份文件的定期创建和存储。如果数据库采用了定期完整备份的策略，可以选择最近的一次完整备份作为恢复的起点。关闭数据库： 在执行完整备份的恢复之前，通常需要关闭数据库以防止正在进行的事务和操作对恢复过程产生干扰。这可以通过停止数据库管理系统服务或将数据库设置为单用户模式来实现。备份当前数据库状态（可选）： 在关闭数据库之前，可以选择备份当前数据库状态。这可以是一个额外的步骤，用于记录在进行完整备份恢复之前数据库中的任何变化。这样的备份可以在需要时用于比较和审计。将完整备份文件还原到数据库服务器： 使用数据库管理工具或相应的还原命令，将选定的完整备份文件还原到数据库服务器。这个过程将数据库文件和事务日志文件还原到备份时的状态。启动数据库： 完整备份成功还原后，启动数据库服务。这使得数据库处于可用状态，并允许用户和应用程序访问。应用事务日志： 如果存在事务日志备份，通常还需要将最近的事务日志备份应用到数据库中，以捕捉在完整备份和恢复期间发生的任何更改。这确保数据库处于最新的可用状态。开放数据库： 恢复完成后，数据库可以对用户和应用程序进行开放，允许正常的读写操作。 Tip：完整备份的恢复过程涉及选择适当的备份文件、关闭数据库、还原备份文件、启动数据库，并可能包括应用事务日志的步骤。这个过程是关键的，确保数据库在发生故障或数据丢失时能够迅速有效地恢复到可用状态。
3.2 差异恢复 差异备份的恢复流程
差异备份的恢复流程是数据库管理中的关键步骤，涉及将数据库从完整备份或上一个差异备份的状态还原到最新的差异备份所记录的时间点。以下是差异备份的一般恢复流程： 准备备份： 在开始恢复过程之前，确保有最新的完整备份可供使用。此外，需要保证存在差异备份文件，这是上一个完整备份之后经过修改的部分。关闭数据库： 在执行差异备份的恢复之前，通常需要关闭数据库以防止正在进行的事务和操作对恢复过程产生干扰。这可以通过停止数据库管理系统服务或将数据库设置为单用户模式来实现。备份当前数据库状态（可选）： 在关闭数据库之前，可以选择备份当前数据库状态，用于记录在进行恢复之前数据库中的任何变化。这样的备份可以在需要时用于比较和审计。将最近的完整备份还原到数据库服务器： 使用数据库管理工具或相应的还原命令，将最近的完整备份文件还原到数据库服务器。这将把数据库还原到完整备份时的状态。将最新的差异备份还原到数据库服务器： 接下来，使用数据库管理工具或还原命令，将最新的差异备份文件还原到数据库服务器。这将应用在上一个备份（完整备份或上一个差异备份）之后发生的所有更改。启动数据库： 完整备份和最新的差异备份成功还原后，启动数据库服务。这使得数据库处于可用状态，并允许用户和应用程序访问。应用事务日志（可选）： 如果存在事务日志备份，通常还需要将最近的事务日志备份应用到数据库中，以捕捉在最新差异备份和恢复期间发生的任何更改。开放数据库： 恢复完成后，数据库可以对用户和应用程序进行开放，允许正常的读写操作。 Tip：差异备份的恢复流程与完整备份的恢复类似，不同之处在于差异备份需要首先应用最近的完整备份，然后再应用最新的差异备份。这个过程确保数据库在发生故障或数据丢失时能够迅速有效地恢复到最新状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4a0c68e44a0f1cab89636a467446a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6931592e095ef18b116d98932bfbd5b0/" rel="bookmark">
			计算机组成原理-总线概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 总线简图总线的物理实现总览总线定义总线的特性总线的分类按数据格式分类串行总线并行总线 按总线功能分类注意系统总线的进一步分类 总线的结构单总线的机构双总线的结构三总线的结构四总线的结构 小结 总线简图 总线的物理实现 如果该为数据总线，那么当CPU向四根线分别传递高低电平信号时，信号会随着各个线的传输到其他部件中，从而实现数据的传输
但若果同时往总线上各根线都传送数据，可能会冲突，如一个为0一个为1
总览 总线定义 一开始是根据功能，然后使各个部件连接，这样分散连接的方式，如果增减外部设备，那么对电路的连接操作比较麻烦
总线的特性 传送方向即总线上的数字信号往哪个方向走
有效的电平范围是指电平落在某个范围时才是有效，即为1
传输线的功能是指传输地址或数据或控制信号的
时间特性：各类信号发出的试卷安排
总线的分类 按数据格式分类 串行总线 每次只能传一位
抗干扰能力强，估计只有一个电信号，没有其他电信号干扰它吧，感觉可以参考一下物理里面的电生磁，磁生电，电干扰电
拆卸和装配是由于数据大部分不是1bit的，所以导致当需要一比特一比特传输的时候，需要将多bit的数据拆分成一个一个比特的。并且接受时也需要将这一个一个比特装配为原来的多比特数据
并行总线 一次可以传多位置
频率越高，干扰其他线的数字信号能力越强
按总线功能分类 片内总线，系统总线，通信总线层层递增
注意系统总线的进一步分类 数据总线：根数和机器字长一样时，读取的内容长度正好是CPU一次可以处理的最大长度，如果和存储字长一样，那么此时只需要取一次就能取到相应的内容。双向是由于既数据是需要双向传输的
地址总线：同一编址时需要考虑设备数量，如主存是0~n，那么一个设备的地址是n+1，一个设备的地址是n+2。此时就需。要地址总线的位数的最大二进制数就需要满足能够取到n+2。单向是由于传输方向只能是从CPU到主存所。以一定是单向的
控制总线：不同控制总线对应不同控制信号，有些控制线是用来发出到其他部件的，而有些控制线是用来接受其他部件发给CPU的
总线的结构 单总线的机构 因为同一时刻如果不同设备都发送信号到总线上可能会冲突，所以不支持并发传送
带宽低即传输慢，因为不一定能立即传输，要等其他部件对总线不占用了才行，否则冲突
由于只有一个总线，考虑没那么复杂，所以接入比较容易。
另外由于系统总线传输速度快，而IO设备传输的数据在总线速度是慢的，所以可能导致总线浪费部分性能
双总线的结构 突发：就是送出一个需要的数据的地址，但得到的是这个需要的数据和与这个数据地址邻接连续的存储的数据
CPU与通道通过主存总线传输，速度没有浪费，然后各IO设备与通道通过I/O总线传输，速度也没有浪费。
三总线的结构 DMA总线传输快，用于连接高速的外设，I/O总线传输慢，用于连接低速的外设
CPU通过I/O总线访问低速外设通过I/O总线，这样重分利用I/O总线
如果需要访问硬盘，可以通过DMA先将磁盘的内容传到主存，再传到CPU
效率低是因为三个总线只能有一个在工作
四总线的结构 不同总线速度不同，通过桥来转换
数据缓存和转换：即可通过桥将得到的串行数据转换为并行数据再传出
控制：把总线的使用权给哪个设备
小结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3a273611bd5d5318c42f097b3ba204/" rel="bookmark">
			JVM知识总结（简单且高效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. JVM内存与本地内存
JVM内存：受虚拟机内存大小的参数控制，当大小超过参数设置的大小时会报OOM。本地内存：本地内存不受虚拟机内存参数的限制，只受物理内存容量的限制；虽然不受参数的限制，如果所占内存超过物理内存，仍然会报OOM。 2. JVM内存结构
虚拟机栈：服务于Java方法本地方法栈：服务于本地方法程序计数器：保存当前线程执行的字节码位置，当然每个线程工作时都有独立的计数器。堆：用于存放对象方法区：用于存放常量、静态变量、数据类型、类信息等元数据
3. 线程独占与共享区域
独占：虚拟机栈、本地方法栈、程序计数器共享：堆、方法区 4. 栈与堆的区别
栈：是运行时单位，代表逻辑，且区域连续堆：是存储单位，代表数据，区域不连续 5. 方法区、永久代、元空间
方法区：是规范，是概念。永久代：是实现，在JDK7及之前版本，是方法区的一种实现。元空间：是实现，在JDK8及之后版本，是方法区的一种实现。（替代了永久代）
6. 元空间为什么替代了永久代
突破内存限制，减少OOM。 由于元空间使用的是本地内存，而不是 JVM 内存。提高 Full GC 的效率。 因为永久代中存放了很多 JVM 需要的类信息，这些数据大多数是不会被清理的，所以 Full GC 往往无法回收多少空间。但在元空间模型中，由于字符串常量池已移至堆中，因此可以更有效地进行垃圾回收，避免了因频繁的 Full GC 导致的性能影响。满足不同的类加载需求和动态类加载的情况。 元空间可以动态地调整大小，在一些大型的、模块化的应用中，可能需要加载大量的类，这就需要大量的元数据存储空间。避免永久代调优和大小设置的复杂性。 在 Java8 之前的版本中，通常需要手动设置永久代的大小，以避免内存溢出的错误。这增加了应用的配置和管理的复杂性。而元空间使用本地内存，根据实际需求动态调整，大大简化了内存管理的复杂性。 7. JVM内存可见性
线程对于变量的操作只能在自己的工作内存中进行，而不能直接对主存操作。
8. 类的生命周期
加载：通过类的完全限定名，查找此类字节码文件，并创建Class对象。验证：确保Class文件符合当前虚拟机的要求。准备：为static修饰的类变量分配内存，不包含final修饰的变量，因为final已经在编译时分配。解析：将常量池的符号引用替换为直接引用。初始化：静态块执行、静态变量赋值。使用：new出对象程序中使用。卸载：执行垃圾回收。
9. 符号引用和直接引用
符号引用即用**(用字符串符号的形式)**来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。而直接引用则是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中。 10. 类的初始化
只有对类主动使用时才会初始化，触发条件包括
创建类的实例时。访问类的静态方法或静态变量的时候。使用Class.forName反射类的时候。某个子类初始化的时候。 11. 双亲委派加载机制
AppClassLoader从缓存查找类，没有则委托给父加载器ExtClassLoaderExtClassLoader从缓存查找类，没有则委托给父加载器BootStrapClassLoaderBootStrapClassLoader从缓存查找类，没有则sun.mic.boot.class路径查找BootStrapClassLoader从sun.mic.boot.class路径查找，没有则让子类ExtClassLoader加载ExtClassLoader从java.ext.dirs路径查找，没有则让子类AppClassLoader加载AppClassLoader从java.class.path路径查找，如果找到就加载类，否则就抛出异常。
12. 双亲委派机制的优点
避免类的重复加载避免Java的核心API被篡改 13. GC如何判断对象可以被回收
引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象 14. 可达性分析算法
可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会当对象编程（GC Roots）不可达时，GC会判断该对象是否执行过finalize方法，若执行了则直接回收。否则，若对象未执行过finalized方法，将其放入F-Queue队列。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则对象复活。 15. 四种JVM的垃圾回收算法
标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3a273611bd5d5318c42f097b3ba204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa85d38553864d680cd30262bb1eb1a/" rel="bookmark">
			什么是IDE，新手用哪个IDE比较好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDE（Integrated Development Environment，集成开发环境）是一种提供了程序开发所需工具和功能的软件应用。它通常包括代码编辑器、编译器、调试器、构建工具、版本控制工具等功能，以帮助开发者更高效地进行软件开发。
对于新手来说，选择一个适合自己的 IDE 取决于个人的偏好、开发语言和项目需求。以下是一些常见的 IDE，它们在不同方面有各自的优势：
Eclipse:
适用语言： Java、C++、PHP 等。特点： Eclipse 是一个开源的跨平台 IDE，支持众多编程语言和插件，有很强的灵活性。特别适合 Java 开发。 IntelliJ IDEA:
适用语言： Java、Kotlin 等。特点： IntelliJ IDEA 是一个由 JetBrains 公司开发的商业 IDE，在 Java 开发领域非常受欢迎。它有强大的代码智能提示、重构工具和内置的构建工具。 Visual Studio Code:
适用语言： 多语言支持，特别擅长 JavaScript、TypeScript、Python 等。特点： Visual Studio Code 是一个轻量级、免费的开源 IDE，支持多种编程语言。它有强大的扩展系统，可以通过插件满足不同语言和框架的需求。 PyCharm:
适用语言： Python。特点： 由 JetBrains 公司推出的 PyCharm 是专门为 Python 开发设计的 IDE。它提供了强大的代码分析、调试、测试等功能，适合 Python 开发者使用。 NetBeans:
适用语言： Java、HTML5、PHP 等。特点： NetBeans 是一个开源的跨平台 IDE，特别适合 Java 开发。它有强大的集成开发环境，支持多种语言。 Atom:
适用语言： 多语言支持。特点： Atom 是一个免费、开源的文本编辑器，由 GitHub 开发。它有丰富的插件系统，支持多语言，适用于轻量级的开发。 对于新手来说，建议根据自己的需求和喜好尝试不同的 IDE，并选择适合自己的那一个。一些 IDE 提供了免费版本，你可以先尝试它们的基本功能，根据实际使用情况选择是否购买专业版或者使用免费版。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc3e5f55c8fd1a1203ffaff6f8f8538/" rel="bookmark">
			蓝桥杯单片机进阶教程1——代码书写格式，继电器和蜂鸣器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、比赛过程中的参考资料 SCH_硬件原理图V30
二、分析考题 通用的考题是正式程序前加上关闭无关外设
还有就是考继电器的吸合，关键点是不要影响到蜂鸣器 三、实验 关闭无关外设，继电器每隔500ms吸合，断开
参考代码：
https://gitee.com/late-night-study/Tech 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27be1285f9c7fee558d712c4af7b4966/" rel="bookmark">
			centos 7.9 升级系统默认的python2.7到python 2.7.18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos 7.9 升级系统默认的python2.7到python 2.7.18 备份旧版本 mv /usr/bin/python /usr/bin/python_2.7.5
下载新版本 Download Python | Python.org Python Release Python 2.7.18 | Python.org wget https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz
cd /home/soft tar -xzf Python-2.7.18.tgz cd Python-2.7.18 mkdir /usr/local/python2.7.18/ ./configure --prefix=/usr/local/python2.7.18 make &amp;&amp; make install ​ #### ​ ln -s /usr/local/python2.7.18/bin/python2.7 /usr/bin/python ln -s /usr/local/python2.7.18/bin/python /usr/local/bin/python centos的python升级安装完成。
安装 pip
curl "https://bootstrap.pypa.io/pip/2.7/get-pip.py" -o "get-pip.py" ​ python get-pip.py ​ ln -s /usr/local/python2.7.18/bin/pip /usr/bin/pip centos中yum指令报错No module named yum解决 vi /usr/bin/yum #!/usr/bin/python2.7 import sys try: import yum except ImportError: print &gt;&gt; sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27be1285f9c7fee558d712c4af7b4966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7b8167b4765bad57fbe4330ebc99e1/" rel="bookmark">
			Aop&amp;ThreadLocal实现动态数据源切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]AOP（面向切面编程）概述集成到Spring-boot导入依赖：注解及使用 多数据源流程图yml配置多数据源连接信息配置常量类多数据源的注册设置ThreaLocal工具类实现多数据源接口自定义注解AOP切换数据源方法中的使用 AOP（面向切面编程） 概述 面向切面编程（AOP，Aspect-Oriented Programming）是一种编程范式，它允许开发者在不改变业务逻辑的情况下，通过切面（Aspect）来模块化横切关注点。横切关注点是那些存在于应用程序中多个模块中、并且通常分散在各个模块中的功能，例如日志、事务管理、安全性等。
AOP 主要通过以下几个概念来实现：
切面（Aspect）： 切面是一个模块化的单元，它封装了与横切关注点相关的行为。通常，一个切面由一个或多个通知（Advice）和一个切入点（Pointcut）组成。通知（Advice）： 通知定义了在什么时候、在何处以及如何应用切面的行为。常见的通知类型包括前置通知（Before）、后置通知（After）、返回通知（After Returning）、异常通知（After Throwing）和环绕通知（Around）。切入点（Pointcut）： 切入点是一个表达式，它定义了在哪里应用切面的行为。切入点表达式可以匹配一个或多个连接点（Join Point）。连接点（Join Point）： 连接点是应用程序执行过程中的一个特定点，例如方法的调用或异常的抛出。切入点定义了在哪里匹配连接点。目标对象（Target Object）： 目标对象是被一个或多个切面所通知的对象。它是应用程序中的真正业务逻辑。织入（Weaving）： 织入是将切面与目标对象关联起来的过程。织入可以发生在编译时、类加载时、运行时，或者在方法调用时。 AOP 的优势在于它可以将横切关注点从业务逻辑中分离出来，提高了代码的模块化、可维护性和可重用性。典型的应用场景包括日志记录、事务管理、权限控制等。在 Java 中，Spring 框架提供了强大的 AOP 支持，使得开发者能够方便地实现面向切面编程。
集成到Spring-boot 导入依赖： &lt;!--&gt;简单满足基础使用 &lt;/--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--&gt;功能更加强大&lt;/--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;/dependency&gt; spring-boot-starter-aop 是 Spring Boot 提供的一个 Starter（启动器），它简化了在 Spring Boot 项目中使用 AOP 的配置过程。aspectjweaver是AspectJ框架的一部分，它是用于支持 Java 编程语言的 AOP 框架。AspectJ 提供了更丰富的切面表达式语言和更强大的切面功能，包括编译时植入和运行时植入等。 本次的功能使用只需要最简单高效的spring-boot-starter-aop就能实现
注解及使用 **@Aspect：**切面
作用： 用于定义一个切面类，将类标识为切面，可以在类里面定义各种增强操作。
示例：
@Aspect public class MyAspect { // 切面类的定义 } **@Pointcut：**切入点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c7b8167b4765bad57fbe4330ebc99e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da6b8949addde0dbf969aa498a3766c/" rel="bookmark">
			苹果CMS超级播放器专业版无授权全开源，附带安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码介绍 超级播放器专业版v1.0.8，内置六大主流播放器，支持各种格式的视频播放，支持主要功能在每一个播放器内核中都相同效果。
搭建教程 1.不兼容IE浏览器
2.php版本推荐7.4 支持7.1~7.4
3.框架引入不支持同时引入多个播放器
json对接教程：
1.json接口只支持get请求类型，具体配置方法后台有写自行查看
2.json配置默认回源设置了.m3u8,.mp4意味着资源地址中包含这两个字符串就不会进行解析而是直接播放
3.如果说有一些资源地址中携带.m3u8但是也需要解析的话可以直接指定播放组，指定播放组后只要配有json就一定会走解析，指定方法在接口地址中加上from=播放组，例如https://域名.com/player/index.php?code=art&amp;from=qq&amp;url=
4.如果是在接口地址里传参form指定播放组代码匹配解析随便，但如果是根据特征码自动匹配尽量吧特征码填长一点，比如腾讯视频资源，不要直接填qq，你不能保证只有腾讯视频网址里有qq也许其他网址也有被匹配错了导致播放失败，所以应该填v.qq.com
指定默认json教程：
有人可能不喜欢使用播放器的线路切换功能，那么你可以在接口地址中加上from=json编号，json编号就是json接口的序列，从0开始，那么第一条json就0第二条1第三条2...，例如https://域名.com/player/index.php?code=art&amp;key=2&amp;url=
，意思是使用json配置中的第三条json解析资源
选集列表对接教程：
安装方法中有说将选集列表api上传到苹果cms跟目录解压
但还需要设置，就是key，iv要与播放器后台-播放器-高级设置里面的保持一致，否则切换选集后播放失败
第二种方式的传参代码：
&lt;script&gt;
let iframeObj = $('iframe')[2];
iframeObj.addEventListener('load', () =&gt; {
iframeObj.contentWindow.postMessage({
"id":"{$obj.vod_id}",
"name":"{$obj.vod_name}-{$obj['vod_play_list'][$param['sid']]['urls'][$param['nid']]['name']}",
"group":"{$GLOBALS['_COOKIE']['group_name']}",
"next":"{$obj.player_info.url_next}",
"sid":"{$param.sid}",
"nid":"{$param.nid}",
"api":"http://127.0.0.1/index.php",
"dmId":""
}, "*");
})
&lt;/script&gt;
参数说明（url传参方式同样是这些参数）
id：影片id
name：影片名字
group：用户组名称【不需广告功能可填空】
next：下一集地址【不需下一集该功能可填空】
sid：片源【不需选集该功能可填空】
nid：集数【不需选集该功能可填空】
api：选集内容获取api【不需选集该功能可填空】
dmId：自定义弹幕id【可以根据影片id+集数设置id】
2.将选集列表api上传到使用播放器的网站中，直接跟目录解压即可。
3.打开苹果cms后台添加播放器即可
播放器代码：
MacPlayer.Html = '&lt;iframe border="0" src="http://d.com/player/index.php?code=qw&amp;url='+MacPlayer.PlayUrl+'" width="100%" height="100%" marginWidth="0" frameSpacing="0" marginHeight="0" frameBorder="0" scrolling="no" vspale="0" noResize&gt;&lt;/iframe&gt;';
MacPlayer.Show();
播放器接口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4da6b8949addde0dbf969aa498a3766c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d45b9fcf3559b17596b2211a69be62/" rel="bookmark">
			RK3568测试tdd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK3568测试tdd 一、门禁取包二、烧录三、跑tdd用例四、查看结果参考资料 一、门禁取包 右键复制链接，粘贴下载；解压到文件夹；
二、烧录 双击\windows\RKDevTool.exe打开烧写工具，工具界面击烧写步骤如图所示：
推荐LOADER模式烧写；
LOADER模式烧写：板子上电状态，PC usb线连接板子，先按住板子上的Recovery键，然后按一下reset键，待工具界面显示LOADER设备后，松开Recovery键，设备进入loader模式，点击执行开始烧写，如图：
可以替换路径，或者按上述路径新建目录，讲dayu200解压后的镜像烤过来：
三、跑tdd用例 更换tdd包路径；
执行start.bat，输入 run -t UT -tp accessibility
四、查看结果 参考资料 1.OpenHarmony-标准设备系统代码操作梳理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a64596c1fcb87f81ace96aa728a3bc0/" rel="bookmark">
			Oracle OCP怎么样线上考试呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好！今天咱们就来聊聊Oracle OCP这个让人又爱又恨的认证。为啥说又爱又恨呢？因为它既是IT界的“金字招牌”，又是一块硬骨头，不是那么容易啃下来的。好了，废话不多说，我们直奔主题，来看看关于Oracle OCP的那些事儿。
Oracle OCP一定需要培训记录么 首先，我们来谈谈培训记录。很多小伙伴可能都在想：“我得去上个什么Oracle认证培训班，拿个培训记录，这样考试才算数吧？” 告诉你，这事儿可不是绝对的。Oracle官方其实是有一些指定的课程，你参加了，确实会有所帮助，但这并不是强制性的。换句话说，如果你自学能力强，完全可以自己啃书、上网课，然后直接去考试。当然，如果你不介意花点小钱，去培训班听听大佬们怎么讲课，也是不错的选择。
总之，一句话哈，OCP培训记录并不是强制的，不参加OCP的培训班课程，一样可以获取到OCP证书
Oracle OCP可以线上考试么 接下来说说线上考试。现在互联网这么发达，什么都能网上办，Oracle OCP考试当然也不例外。是的，你没听错，Oracle OCP考试完全可以在线上完成，不需要去考场。这对于我们这些懒人来说，简直是太好的消息了。想象一下，在家穿着睡衣，喝着咖啡，就能完成考试，多美妙！下面说下说下怎么约Oracle OCP线上考试
2.1 首先呀，你要先给我Oracle MyLearn（https://mylearn.oracle.com/ou/home）登录用户名，一般是个邮箱号，密码不要，给我也不要
2.2 将考试券绑定到你的账号，就是你给我们的邮箱号
绑定之后，你就可以约考试了，怎么看下面的指导哈，以1z0-083为例
登录https://mylearn.oracle.com/ou/home，显示的是下图的页面
在上面搜索框里，输入你要报考的考试，比如1z0-083，然后会出来1z0-083的考试科目
点1z0-083
根据提示，选择时区，一般选择shanghai +8，选择你要的考试时间，一般早上7点半，和晚上12点，选个你合适的时间，填入你的联系电话，然后一系列确认即可，约好考试后，是这样的界面
那么，线上考试的流程是怎样的呢？ 首先，你的电脑要带有摄像头，这是必备条件哈，不过现在电脑都有摄像头
然后，考试当天，按照指引流程需要在你的电脑上安装指定的安全浏览器，这个安全浏览器就是一个软件，你不能切屏，也能搞死你的远程进程，社交软件进程等。目的是让你一心一意看题，做题
在这里插入图片描述
下载安装好了，点step3，中文意思，就是测试下安全浏览器好不好使
然后勾选step 4，
启动 step 5
考试开始前， 如果你准备好了，请举手，不过界面是英文，就是里面的raise hand
然后监考官要你出示证件，身份证是可以的，你把你的身份证贴近摄像头，给监考考试看清楚你的姓名
有可能监考官会在考试软件里发消息给你，让你输入下你的账号，就是你的邮箱号，确认下
这些过程做了后，老师会给你一个access code
你切换到考试页面，输入你的access code，就可以考试了，
祝你考试顺利，成功中举
考取Oracle OCP对个人职业发展，有什么优势呢 最后，我们来聊聊考取Oracle OCP对个人职业发展的优势。
首先，这个证书在IT行业是非常有分量的。
它不仅证明了你在Oracle数据库领域的专业知识和技能，还能让你在求职时更加出众。
很多公司在招聘数据库管理员或者相关职位时，都会优先考虑有Oracle认证的候选人。
此外，拿到这个证书后，你的薪资水平也很可能会有一个跳跃性的提升。说
白了，这就是一个提升自己技能、开拓职业道路的好机会
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad681be9ec6d11ff7d0bd55a259bc7d7/" rel="bookmark">
			算法基础之最短Hamilton路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最短Hamilton路径 核心思想： 数位dp
用二进制数 存当前所有点 遍历过为1
遍历i图中j点 若j点走过 则求j点路径长度
f[state][j] = f[state_k][k] + w[k][j] state为除去j点的图 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int N = 20, M = 1&lt;&lt; N ; int f[M][N]; int w[N][N]; //权值 int n; int main() { cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;w[i][j]; //输入所有边长度(权值) memset(f , 0x3f, sizeof f); //初始化无穷大 便于取min f[1][0] = 0; //只有起点走过 且当前点为起点 距离为0 for(int i=1;i&lt; 1 &lt;&lt; n;i++) //遍历每一张图 for(int j=0;j&lt;n;j++) //遍历i图中每个点 if(i &gt;&gt; j &amp; 1) // 若j点走过 for(int k= 0;k&lt;n;k++) //遍历j点前一个点k if(i &gt;&gt; k &amp; 1) //k也走过 //更新f[i][j] = f[去掉i][k] +w //特别地 当j == k时 f[state][k] 不合法 因为图中必须包含k点 //所有min只会取f[i][j] f[i][j] = min(f[i][j] , f[i - (1 &lt;&lt; j)][k] + w[k][j]); cout&lt;&lt; f[(1 &lt;&lt; n) - 1][n-1]&lt;&lt;endl; //输出所有点都走过 当前点为n-1的数值 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ede7b8f0b69c20af0b438bbf1d9faf4/" rel="bookmark">
			Go语言中的性能考虑和优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优化您的Go代码以达到最佳性能 性能优化是软件开发的关键方面，无论您使用哪种编程语言。在这篇文章中，我们将探讨Go语言中的性能考虑和优化，Go是一种以其效率而著称的静态类型和编译语言。我们将深入探讨三个关键领域：分析并发代码、识别瓶颈以及实施负载均衡和可扩展性策略。通过本文，您将对如何优化您的Go代码以达到最佳性能有一个坚实的了解。
在Go中对并发代码进行性能分析
对Go代码进行性能分析是了解其性能特性的基本步骤。当处理使用goroutines和channels的并发代码时，性能分析变得尤为关键。在这一部分中，我们将讨论如何有效地对Go并发代码进行性能分析。
1. Go中的性能分析工具
Go提供了用于分析您的代码的内置工具。其中一个工具就是pprof包，它允许您收集CPU和内存分析数据。让我们看一个如何使用它的简单示例：
package main import ( _ "net/http/pprof" "net/http" "time" ) func yourConcurrentFunction() { // Your concurrent code here } func main() { go func() { http.ListenAndServe("localhost:6060", nil) }() go yourConcurrentFunction() // Sleep to allow profiling data to be collected time.Sleep(30 * time.Second) } 在这段代码片段中，我们导入_ "net/http/pprof"包以启用性能分析的端点。然后，我们使用goroutines运行我们的并发函数，并使用HTTP服务器来提供性能分析数据。过一段时间后，您可以在http://localhost:6060/debug/pprof上访问性能分析数据。
2. Goroutine性能分析
Goroutine性能分析帮助您识别与goroutines相关的瓶颈。您可以使用go tool pprof命令行工具收集goroutine分析数据。以下是如何执行的示例：
go tool pprof http://localhost:6060/debug/pprof/goroutine 这个命令连接到正在运行的Go程序，并允许您分析goroutine的性能分析数据。它会显示正在运行的goroutines和被阻塞的goroutines，帮助您识别并发问题。
在Go中识别瓶颈
收集了性能分析数据后，下一步是在您的Go代码中识别瓶颈。瓶颈可能表现为CPU绑定或内存绑定的问题。
1. CPU绑定的瓶颈
当您的代码消耗过多的CPU资源时，就会出现CPU绑定的瓶颈。要解决Go中的这些瓶颈，您需要优化算法并减少不必要的计算。以下是一个简单的示例：
package main import ( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ede7b8f0b69c20af0b438bbf1d9faf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db27e8a85bf37c68ead8e880b758d710/" rel="bookmark">
			69内网安全-域横向CobaltStrike&amp;SPN&amp;RDP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这节课主要讲spn和rdp协议，
案例一域横向移动RDP传递-Mimikatz rdp是什么，rdp是一个远程的链接协议，在linux上面就是ssh协议，
我们在前期信息收集的时候，得到一些hash值和明文密码可以进行一些相关协议的链接的，比如之前讲的ipc，vmi，smb协议，除了这些，rdp协议也是可以进行链接的，
rdp协议对应的开放端口就是3389
明文密码连接时很简单得可以直接xin+r输入mstsc调用出来远程连接窗口，
2.mstsc.exe /console /v:192.168.3.21 /admin
3.linux: rdesktop 192.168.3.21:3389
用hash也可以链接，但是有部分系统有还要执行一下这个命令
windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，
同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持；
REG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f
就比较鸡肋
rdp协议判断；判断对方是否开启了3389端口即可，端口扫描
案例二域横向移动SPN服务-探针,请求,导出,破解,重写 参考链接，https://www.cnblogs.com/backlion/p/8082623.html spn扫描也可以叫扫描Kerberos服务实例名称，
他的攻击流程在思维导图里面写了，探针spn服务，请求服务票据，导出服务票据，破解服务票据，重写服务票据，吃西瓜
设计的服务；mssql，wsman，exchange，iermserv，hyper-v host等等，在参考里面有详细
一般spn攻击可以通过网络端口扫描，通过端口开放可以判断内网主机的一些其他服务，不过进行端口扫描可能会遇到防火墙，比如在用namp扫描的时候遇到防火墙就会扫描不准确；
spn扫描就可以避免这个防火墙，他扫描是走的Kerberos服务，走的地方不一样，SPN查询是普通Kerberos票据的一部分，不会触发防火墙，杀软，
攻击流程，探针spn服务((看一下有那些服务)，请求服务票据（根据不同的服务，选择要操作的服务，然后请求），导出服务票据（请求之后会建立会话连接，在用工具把数据导出来），破解服务票据（导出来之后数据的加密形式是可以破解的，通过破解找到这个链接的东西），重写服务票据，吃西瓜
黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务帐户的NTLM密码哈希用于加密服务票证。黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证。这就是Kerberoasting攻击的关键。
以下操作都在PowerShell进行 探针
setspn -q */*
可以看到域内主机的详细服务目标，
setspn -q */* | findstr "MSSQL"
这个命令就是寻找特定的服务，这个就是寻找的mssqk服务，
然后删除别的票据
请求
Add-Type -AssemblyName System.IdentityModel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db27e8a85bf37c68ead8e880b758d710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811c2c5e25c1c237dfb5e511a0dd92c3/" rel="bookmark">
			鸿蒙HarmonyOS-带笔锋手写板(三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者用ArkTS 写了一个简单的带笔锋的手写板应用，并且可以将手写内容保存为图片。
一、效果图 手写效果如下（在鸿蒙手机模拟器上运行，手写时反应可能会有点慢）
二、实现方法 参考文章：
支持笔锋效果的手写签字控件_android 写字板如何兼容笔峰-CSDN博客
安卓画笔笔锋的实现探索（一） - 简书
主要代码：
核心思想在于通过插值，在两点之间逐渐绘制多个椭圆，从而呈现出笔锋的效果。
drawLine 方法是一段用于在2D渲染画布上绘制线条并赋予其笔锋效果的代码。
在代码中，curDis 用于计算起始点和结束点之间的欧几里德距离。steps 根据距离计算出线条上需要绘制的点的数量。deltaX, deltaY, deltaW 分别表示 x 坐标、y 坐标和宽度每一步的增量。
通过 for 循环，在两点之间进行插值，绘制多个椭圆，以模拟笔锋效果。每一步循环中，创建一个椭圆对象 (oval)，并设置其位置调用 oval 方法绘制椭圆。
最后，更新坐标和宽度的增量，为绘制下一个椭圆做准备。
/** * 绘制线条方法，实现笔锋效果 * @param canvas 2D 渲染上下文对象 * @param x0 起始点 x 坐标 * @param y0 起始点 y 坐标 * @param w0 起始点宽度 * @param x1 结束点 x 坐标 * @param y1 结束点 y 坐标 * @param w1 结束点宽度 */ private drawLine(canvas: CanvasRenderingContext2D, x0: number, y0: number, w0: number, x1: number, y1: number, w1: number): void { // 计算两点之间的欧几里德距离 const curDis: number = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811c2c5e25c1c237dfb5e511a0dd92c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85a570e13839be4237c136d4492aeea/" rel="bookmark">
			大创项目推荐 深度学习二维码识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言2 二维码基础概念2.1 二维码介绍2.2 QRCode2.3 QRCode 特点 3 机器视觉二维码识别技术3.1 二维码的识别流程3.2 二维码定位3.3 常用的扫描方法 4 深度学习二维码识别4.1 部分关键代码 5 测试结果6 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 python+opencv+深度学习实现二维码识别
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：3分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
2 二维码基础概念 2.1 二维码介绍 二维条码/二维码（2-dimensional bar
code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的、黑白相间的、记录数据符号信息的图形；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。
2.2 QRCode 常见的二维码为QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar
Code条形码能存更多的信息，也能表示更多的数据类型。
2.3 QRCode 特点 1、符号规格从版本1（21×21模块）到版本40（177×177 模块），每提高一个版本，每边增加4个模块。
2、数据类型与容量（参照最大规格符号版本40-L级）：
数字数据：7,089个字符字母数据: 4,296个字符8位字节数据: 2,953个字符汉字数据：1,817个字符 3、数据表示方法：
深色模块表示二进制"1"，浅色模块表示二进制"0"。 4、纠错能力：
L级：约可纠错7%的数据码字M级：约可纠错15%的数据码字Q级：约可纠错25%的数据码字H级：约可纠错30%的数据码字 5、结构链接（可选）
可用1-16个QR Code码符号表示一组信息。每一符号表示100个字符的信息。 3 机器视觉二维码识别技术 3.1 二维码的识别流程 首先， 对采集的彩色图像进行灰度化， 以提高后继的运行速度。
其次， 去除噪声。 采用十字形中值滤波去除噪音对二码图像的干扰主要是盐粒噪声。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85a570e13839be4237c136d4492aeea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f84b93d3281024fd150bea9e75f889/" rel="bookmark">
			灸哥问答：作为初学者如何学习设计模式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始把几年前关于设计模式的笔记逐步整理出来，并且分享给大家。讲设计模式的书籍、视频比比皆是。这次我针对每一个设计模式分为五个方面进行介绍：
什么是 X 设计模式？（是什么？）为什么用 X 设计模式？（为什么？优势）如何用 X 设计模式？（怎么用？使用简单的代码示例演示该设计模式的使用方式）是否存在缺陷和不足？（设计模式不是万能的）如何缓解缺陷和不足？（方法永远比问题多） 基于以上五个方面已经介绍了一些设计模式，有一些朋友问：作为初学者应该如何学习设计模式？今天我会从我的学习过程、我对下属的培养过程，给出我对设计模式学习的建议。
在讲之前我有一个前提先同步大家：设计模式不是万能的，用就好好用，如果用不好，不如不用！
一、理论准备 学习并掌握基本的编程知识：如果一个人连最基础的编程知识都没有，那就不要学习设计模式了。学也学不会的。这块主要要对编程语言，比如 Java，以及面向对象编程的知识有一定的了解和掌握，这样才能更好地开始学习设计模式。学习并掌握设计原则：这部分的内容我前面都有详细介绍过，一般书本讲的都是 SOLID 原则，在这个基础上提出了软件设计七原则，包括 SOLID + CARP + LoD，建议使用我的内容好好学习掌握。学习并掌握设计模式：找一本设计模式的书、视频或者我这个系列的也可以，你如果有一个理论指导，然后针对每一个设计模式去理解他的原理和实际应用的场景。先从常用的简单的开始，这样学习才能持续下去。当然你学习过程中有什么问题欢迎和我交流。 二、辅助学习 找寻优秀的设计模式实例进行学习：比如 Spring 中单例模式的使用，很经典，我经常和我的下属们说，这部分的源码好好啃下去，对单例的理解程度会晋级的。这部分代码不难找，网络上介绍的有很多。善于使用工具来深化学习程度：有一些设计工具能帮助你在学习的过程中更好地理解设计模式，比如一些设计模式的可视化工具、UML 制图工具等，可以尝试地用起来，画起来。善于利用博客、社区、公众号资源：这个就不多少了，不仅是通过这些渠道看理论、看代码示例，更多地是看别人是如何学习的，分享学习的经验、交流学习的教训。 三、动手并持续 动手实战：学任何技术不动手是学不会的，关于设计模式的学习也是一样的，你要动手去写才行，这又两种模式，一种是自己写，一种是在实际项目中去写，只有通过多用才能更好地掌握，但是别忘了我开篇的前提，而且在用的过程中，要注重在实际场景中你使用何种设计模式解决问题的思考过程。重复学习和持续实践：关于技术的学习不是用一次就掌握的，理论也不是看一遍就理解的，必须是一个重复学习的过程，也必须是一个持续实践的过程。 要记住，设计模式，它是解决特定问题的通用模板，但并不是所有问题都需要设计模式。
在实践中，根据具体情况灵活运用设计模式，并在不断的实践中逐渐提高你的设计水平。
以上是我的一些建议和看法，希望可以帮到你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d47bc2bf73b3b51f537231f0a0ca3e51/" rel="bookmark">
			代码回滚（git reset）后push失败的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 代码本地回滚之后（即 git reset 到之前的某个历史节点），push上去失败，并报出以下错误信息
! [rejected] master -&gt; master (non-fast-forward) error: failed to push some refs to 'git@github.com:PisecesPeng/usegit.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 大致意思是说，你当前的本地分支节点 比 远端的节点 还旧，默认不允许你push。
其实主要是怕你误操作，因为reset到某个旧节点之后 再push上去，会导致远端的新节点 也同步丢失，如下图所示：
而我们回滚代码 又恰恰是为了丢掉新节点，所以这个时候可以 强制push。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d47bc2bf73b3b51f537231f0a0ca3e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365f470894a22c2246a0962cefaf1ec0/" rel="bookmark">
			Android Studio导入现有项目的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年因为搞了四个电脑放在不同地点，经常遇到在新电脑上装了Android Studio之后需要导入现有项目的情况，有时挺顺利，有时又很麻烦，遇到各种问题导致无法build.
不过也有一些规律，总结一下怎样做才能顺利导入：
错误的做法
从其他电脑上把项目目录拷贝过来，在AS中进行导入。这样特别容易遇到各种问题，什么配置不对，什么依赖无法下载等等。
正确的做法
把代码放在版本管理系统中，比如GitHub, Azure等地方，在安装了Android Studio之后，同时安装GitHub或Azure的插件，直接克隆下来，各种配置和依赖，AS基本都能自己搞定，很快就能build成功把软件跑起来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41ddfd457af2a5e0a868b1543d3f28b/" rel="bookmark">
			基于LangChain&#43;LLM的本地知识库问答：从企业单文档问答到批量文档问答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 过去半年，随着ChatGPT的火爆，直接带火了整个LLM这个方向，然LLM毕竟更多是基于过去的经验数据预训练而来，没法获取最新的知识，以及各企业私有的知识
为了获取最新的知识，ChatGPT plus版集成了bing搜索的功能，有的模型则会调用一个定位于 “链接各种AI模型、工具”的langchain的bing功能为了处理企业私有的知识，要么基于开源模型微调，要么更可以基于langchain里集成的向量数据库和LLM搭建本地知识库问答(此处的向量数据库的独特性在哪呢？举个例子，传统数据库做图片检索可能是通过关键词去搜索，向量数据库是通过语义搜索图片中相同或相近的向量并呈现结果) 所以越来越多的人开始关注langchain并把它与LLM结合起来应用，更直接推动了数据库、知识图谱与LLM的结合应用(详见下一篇文章：知识图谱实战导论：从什么是KG到LLM与KG/DB的结合实战)
本文则侧重讲解
什么是LangChain及langchain的整体组成架构通过langchain-ChatGLM构建本地知识库问答的基本流程，与每个流程背后的逻辑解读langchain-ChatGLM项目的关键源码，不只是把它当做一个工具使用，因为对工具的原理更了解，则对工具的使用更顺畅
一开始解读不易，因为涉及的项目、技术点不少，所以一开始容易绕晕，好在根据该项目的流程一步步抽丝剥茧之后，给大家呈现了清晰的代码架构
过程中，我从接触该langchain-ChatGLM项目到整体源码梳理清晰并写清楚历时了近一周，而大家有了本文之后，可能不到一天便可以理清了(提升近7倍效率) ​​​，这便是本文的价值和意义之一langchain-ChatGLM项目的升级版：langchain-Chatchat我司基于langchain-chatchat二次开发的企业多文档知识库问答系统 阅读过程中若有任何问题，欢迎随时留言，会一一及时回复/解答，共同探讨、共同深挖
第一部分 LangChain的整体组成架构：LLM的外挂/功能库 通俗讲，所谓langchain (官网地址、GitHub地址)，即把AI中常用的很多功能都封装成库，且有调用各种商用模型API、开源模型的接口，支持以下各种组件
​初次接触的朋友一看这么多组件可能直接晕了(封装的东西非常多，感觉它想把LLM所需要用到的功能/工具都封装起来)，为方便理解，我们可以先从大的层面把整个langchain库划分为三个大层：基础层、能力层、应用层
1.1 基础层：models、LLMs、index 1.1.1 Models：模型 各种类型的模型和模型集成，比如OpenAI的各个API/GPT-4等等，为各种不同基础模型提供统一接口
比如通过API完成一次问答
import os os.environ["OPENAI_API_KEY"] = '你的api key' from langchain.llms import OpenAI llm = OpenAI(model_name="text-davinci-003",max_tokens=1024) llm("怎么评价人工智能") 得到的回答如下图所示
1.1.2 LLMS层 这一层主要强调对models层能力的封装以及服务化输出能力，主要有：
各类LLM模型管理平台：强调的模型的种类丰富度以及易用性一体化服务能力产品：强调开箱即用差异化能力：比如聚焦于Prompt管理(包括提示管理、提示优化和提示序列化)、基于共享资源的模型运行模式等等 比如Google's PaLM Text APIs，再比如 llms/openai.py 文件下
model_token_mapping = { "gpt-4": 8192, "gpt-4-0314": 8192, "gpt-4-0613": 8192, "gpt-4-32k": 32768, "gpt-4-32k-0314": 32768, "gpt-4-32k-0613": 32768, "gpt-3.5-turbo": 4096, "gpt-3.5-turbo-0301": 4096, "gpt-3.5-turbo-0613": 4096, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41ddfd457af2a5e0a868b1543d3f28b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0287a1a257d4250bc31ba843ed090571/" rel="bookmark">
			【K8S in Action】第六章 卷：将磁盘挂载到容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍卷 每个新容器都是通过在构建镜像时加入的详细配置文件来启动的。 将此与pod 中容器重新启动的现象结合起来。
存储卷是 pod 的一个组成部分。这意味着在 pod 启动时创建卷， 并在删除 pod时销毁卷。 因此， 在容器重新启动期间， 卷的内容将保持不变， 在重新启动容器之后， 新容器可以识别前一个容器写入卷的所有文件。
另外，如果一个 pod 包含多个容器， 那这个卷可以同时被所有的容器使用。
1.1 卷类型 • emptyDir 用于存储临时数据的简单空目录。
• hostPath 用于将目录从工作节点的文件系统挂载到pod中。
• gitRepo 通过检出Git仓库的内容来初始化的卷。
• nfs 挂载到pod中的NFS共享卷。
2. 通过卷在容器之间共享数据 2.1 使用 emptyDir 关注它是如何用于在 pod 的多个容器之间共享数据的。卷从一个 目录开始，运行在 pod 内的应用程序可以写入它需要 的任何文件。pod 含两个容器和 个挂载在两个容器中的共用的卷，但在不同的路径上。
apiVersion: vl kind: Pod metadata: name : fortune spec: containers: -image: luksa/fortune name: html generator volumeMounts: - name: html mountPath: /var/htdocs 名为html的卷挂载在/var/htdocs - image: nginx:alpine name: web-server volumeMounts : - name: html mountPath: /usr/share/nginx/html readOnly: true ports: - containerPort: 80 protocol: TCP volumes - name: html 叫html的emptyDir卷，挂载在上面的两个容器中 emptyDir: {} 将端口从本地机器转发到 pod 来实现，计算机的 808 端口来访问服务 kubectl port-forward fortune 8080:80 volumes: - name: html emptyDir medium: Memory # 存在内存上 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0287a1a257d4250bc31ba843ed090571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fefe341769ab1139f220f411cde1609/" rel="bookmark">
			信息网络协议基础_IP移动网络管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述移动IPv6待解决的问题关键词基本过程分组拦截技术移动检测和转交地址自动配置到家乡代理绑定注册通信对端不支持IPv6通信对端支持移动IPv6 对IP以上层屏蔽移动性 移动IPv6存在的问题移动IPv6优化代理移动IP概述原理基本过程初始接入切换 概述 移动IPv6 待解决的问题 关键词 基本过程 分组拦截技术 主机A已经跑到别的网络去了, 家乡代理把家乡网络中对A的邻居请求信息截获并把自己的MAC地址作为邻居公告返回.
移动检测和转交地址自动配置 到家乡代理绑定注册 通信对端不支持IPv6 通信对端始终只知道移动节点的家乡地址.
采用双向隧道模式.
通信对端支持移动IPv6 通信对端知道移动节点当前的转交地址.
路由优化模式.
对IP以上层屏蔽移动性 移动地址向目的地址发送信息的过程中, 对于发送端, TCP阶段依然认为自己的源地址是家乡地址, 在移动IPv6阶段对源地址和转交地址进行交换. 同理, 对于接收方, 及时交换源地址和家乡地址.
家乡代理: 对于对端与移动端通信, 对端的目的地址是家乡地址, 然后再由家乡代理封装后给移动端, 反之也一样. 移动端进行解封装, 这使得对上层来说这一系列操作是透明的. 同理, 反操作, 家乡代理解封装.
路由优化: 额外增加头标HAO和T2R, 分别初始化为家乡地址和转交地址, 与原始的源地址进行两次替换, 从而实现透明性.
移动IPv6存在的问题 移动IPv6优化 代理移动IP 概述 可以看到, 随着距离的增加, 路由公告, 绑定等流程占据了主要的时间, 因此, 代理移动IP让和一部分内容在网络层面上完成.
原理 基本过程 初始接入 切换 这个和之前的方法是反着来的.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c4eaaa12b988a1b4dbf95844d1e1de/" rel="bookmark">
			C语言之整型提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 有可能出现的问题2 产生以上问题的原因（整型提升）3 整型提升的过程4 整型提升示例5 总结 1 有可能出现的问题 代码如下
#include &lt;stdio.h&gt; int main () { int a = -1; unsigned int b = 1; if (a &lt; b) { printf("a &lt; b"); } else { printf("a &gt;= b"); } return 0; } 运行结果
2 产生以上问题的原因（整型提升） 在表达式计算时，各种整型首先要提升为int类型，如果int类型不足以表示则要提升为unsigned int类型；然后执行表达式的运算。
**为什么要使用整型提升：**表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。简单来说就是为了在计算中有更快的速度。
3 整型提升的过程 1. 有符号整数的整型提升：高位补充符号位 char var1 = -1； 负数在内存中以补码的形式存储，且char类型占一个字节，即8bit 故变量 var1 的二进制补码为1111 1111 整型提升之后，高位补充符号位1，int为32bit提升后为1111 1111 1111 1111 1111 1111 1111 1111 char var1 = 1； 正数的补码和原码相同，同理可得变量var1的二进制补码为 0000 0001 整型提升之后，高位补充符号位0，提升后为0000 0000 0000 0000 0000 0000 0000 0001 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02c4eaaa12b988a1b4dbf95844d1e1de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35ff29fbc4347d033f9e73482464139/" rel="bookmark">
			tcpdump出现permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用tcpdump -i eth0 src host 192.168.0.184 and ip and port 22 -nn -w ping.pacp命令抓包并把抓到的数据保存到ping.pacp时，出现了权限错误的报错。但实际上我这里用的是root用户执行的命令。 查阅man手册发现:
在tcpdump中，-Z选项用于在启动数据包捕获后降低程序的权限，从而增强系统的安全性。默认开启
如果tcpdump以root用户身份运行，它将在打开用于捕获数据包的设备或输入保存文件后，更改其运行时的用户ID（UID）和组ID（GID）。它会切换到指定的user的UID和该user的主组GID。
这样做的目的是减少tcpdump拥有的权限，因为以root身份运行的进程如果被恶意利用，可能会对系统造成严重的安全风险。
那么如果使用root用户遇到这个问题，可以使用-Z root指定root身份执行tcpdump，从而关掉这个默认选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdc85bf110bc383b8a6b67a24170efb/" rel="bookmark">
			全面指南：掌握GitHub Actions（官网导航链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 github已经是很多程序员寻找开源代码的重要网站，我开始对github做一些使用说明的一些简介，这里我整理了官方文档的说明链接，以及对应哪些功能所需要的参考文档，希望能够帮到大家。
GitHub Actions 这个是Github的 学习路径是一系列指南的集合，旨在帮助用户掌握特定主题。这些学习路径通过提供详细的步骤和示例，引导用户深入了解和有效使用GitHub Actions的各项功能。从入门到高级应用，这些指南涵盖了GitHub Actions的多个方面，使用户能够逐步提高技能并有效地应用于自己的项目中。【GitHub Actions】 提供GitHub Actions的基础概念和功能的概览。 指导用户如何寻找和定制GitHub Actions中的动作 介绍GitHub Actions的核心功能和关键特性 提供关于GitHub Actions中工作流的概览，包括它们的定义和如何使用 指南讲解如何重用工作流，以提高工作效率和一致性。 讨论如何提高GitHub Actions的安全性，包括最佳实践和安全建议 Get started with GitHub Actions 旨在帮助用户通过创建第一个工作流来探索GitHub Actions的可能性。这个入门指南逐步引导用户了解GitHub Actions的基础概念，如何设置一个简单的工作流，以及如何利用GitHub Actions自动化代码构建、测试和部署过程。对于新手来说，这是一个理想的起点，可以通过实践学习并理解GitHub Actions在软件开发工作流中的应用。【Get started with GitHub Actions】
提供自托管运行器的总览，解释它们的用途和如何在GitHub Actions中使用。 教程指导如何添加自托管运行器到GitHub仓库。 介绍如何将自托管运行器应用配置为服务。 说明如何在自托管运行器中使用代理服务器。 介绍如何使用标签来管理和组织自托管运行器。 指导如何在工作流中使用自托管运行器。 解释如何使用组来管理对自托管运行器的访问。 提供自托管运行器的监控和故障排除方法。 Create an action 引导用户如何为GitHub Actions开发和分享自定义动作（actions）的资源。如果你有一个新动作的想法或已为你的项目构建了自定义解决方案，这个指南可以教你如何构建可分享的动作并将它们发布到GitHub Marketplace。这包括创建动作的基本步骤，如编写代码、打包动作、设置元数据和发布。通过这个过程，用户可以将他们的创新和实用工具分享给更广泛的开发者社区。【Create an action】
介绍了自定义动作的基本概念，包括它们的用途和如何在GitHub Actions中使用。 说明如何创建一个Docker容器动作。 指导如何创建一个JavaScript动作。 介绍如何创建组合动作，这种动作可以组合多个步骤。 提供GitHub Actions的元数据语法参考。 介绍GitHub Actions对Dockerfile的支持。 指导如何为动作设置退出代码。 教程介绍如何将动作发布到GitHub Marketplace。 总结 这篇内容旨在提供一个基本概览和实用指南，帮助用户了解GitHub和GitHub Actions的核心功能。从基本的学习路径、入门指南到更复杂的自托管运行器和自定义动作创建，这些信息可以作为一个起点，供初学者和有经验的用户参考，以更好地利用GitHub的这些功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1774ce829f02d4ca94a9d85e395789/" rel="bookmark">
			Java多线程＜二＞多线程经典场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode 多线程刷题 上锁上一次，还是上多次？
同步的顺序。
1. 交替打印字符 使用sychronize同步锁使用lock锁使用concurrent的默认机制使用volitale关键字 + Thread.sleep() / Thread.yield机制使用automic原子类 方式1 ：使用互斥访问state + Number中控制当前state进行
实现1：使用synchornized上锁，wait让出cpu实现2：使用semophore上锁, sleep或者yield让出cpu实现3：使用原子Integer进行访问 + yield或者sleep让出cpu实现4：使用Lock进行访问 + condition让出cpu实现5: 使用blockingQueue放入state,如果不是自己的state,在放进去，然后让出cpu。 方式2：使用互斥访问全局cur进行，cur代表当前数字是多少，如果cur &gt;= n，就直接return让线程终止。
其中cur代表的是当前的数字是多少。互斥的访问方式仍然是上面的那些种。 方式3：使用同步的通知模式
上面的方式，四个线程都是一直处于活跃状态，也就是Runnable的状态。(使用wait的除外)。另外判断是否可以运行都需要while进行判断。
但实际上，四个线程在同一时间，只需要一个线程可以运行。其他线程都必须进行阻塞。所以可以使用同步通知的方式进行，在其他线程运行的时候，阻塞另外的三个线程，并且运行完成一个线程后，可以实现精准通知另一个线程启动。
2. 打印0和奇偶数字 使用锁 sychornized和Lock
使用并发工具
barrier
semopher
使用cas + Thread.sleep/volatile + ThreadSleep
使用blocking que进行实现
经典模型 1. 生产者消费者的几种实现方式 操作系统课本上的经典信号量机制。 锁使用synchornized关键字加上while(true)死循环 package cn.itedus.lottery.test; import lombok.SneakyThrows; import java.util.Stack; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.locks.ReentrantLock; /** * @author: Zekun Fu * @date: 2023/11/13 11:28 * @Description: */ public class test434 { static Stack&lt;String&gt; que = new Stack&lt;&gt;(); static Object full = new ReentrantLock(); static Object empty = new ReentrantLock(); static ReentrantLock lock = new ReentrantLock(); static int n = 0; static final int st = 10; static class Consumer { void consume() { while (true) { lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e1774ce829f02d4ca94a9d85e395789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d422364252559f9b18d3455af9d2499/" rel="bookmark">
			Abstract Factory抽象工厂模式（对象创建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 抽象工厂模式：Abstract Factory 链接：抽象工厂模式实例代码 + 解析
目的 在软件系统中，经常面临着“一系列相互依赖的对象工作”；同时，由于需求的变化，往往存在更多系列对象的创建工作。
如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。
P.s.
抽象工厂本质是对工厂模式的延续，在工厂模式中我们是把同一批基于同一个的基/父类的创建都使用单独的工厂创建，但是又是虽然来自不同基类的类也有相关性，此时我们将其耦合在一起使用一个工厂创建反而会提高效率也没有其它的坏处，比如：对同一个链接的操作的类，虽然不同的行为的父类是不同的，但是他们都是针对同一个链接，此时我们就可以使用一个类将所有行为都放在一起并使用一个工厂创建。
注：由于使用同一个工厂创建，该工厂会将所有的成员都创建包括不用的也会。（也可以使用装饰模式去叠加工厂，做到自定义工厂）
模式定义 提供一个接口，让该接口负责创建一系列”相关或者相互依赖的对象“，无需指定它们具体的类。 ——《设计模式》GoF
要点总结 如果没有应对”多系列对象创建“的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂即可。”系列对象“指的是在某一个特定系列的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。Abstract Factory模式主要在于应用”新系列“的需求变动。其缺点在与难以应对”新对象“的需求变动。 E.g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447aa85ff1c7092822f671113f9b8c4e/" rel="bookmark">
			【Electron】webview 实现网页内嵌
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现效果：
当在输入框内输入某个网址后并点击button按钮 , 该网址内容就展示到下面
踩到的坑：之前通过web技术实现 iframe 标签内嵌会出现 同源策略，同时尝试过 vue.config.ts 内配置跨域项 那样确实 是实现啦 但不知道如何动态切换 tagert 的值 同源策略:
Refused to frame 'https://www.baidu.com/' because an ancestor violates the following Content Security Policy directive: "frame-ancestors 'self' https://chat.baidu.com http://mirror-chat.baidu.com https://fj-chat.baidu.com https://hba-chat.baidu.com https://hbe-chat.baidu.com https://njjs-chat.baidu.com https://nj-chat.baidu.com https://hna-chat.baidu.com https://hnb-chat.baidu.com http://debug.baidu-int.com".
1. npm init -y //先安装package.json
2.npm install electron 3.创建main.js
const { app, BrowserWindow } = require('electron') let mainWindow function createWindow () { mainWindow = new BrowserWindow({ width: 1200, height: 1000, webPreferences: { nodeIntegration: true, webviewTag: true // 启用webview标签 } }) const menu = Menu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447aa85ff1c7092822f671113f9b8c4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acafcce14ce82ae4dda2bdcde6fbc66c/" rel="bookmark">
			已加入git本地版本库的文件如何移除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 针对已经加入本地版本库的文件（文件颜色为绿色），gitignore是无法进线忽略的，需要先清理git缓存，释放已经加入版本控制的文件，方法如下：
进入文件所在目录，选择文件，右键选择open in terminal执行：git rm --cache -rf [文件名/文件夹名]，多个文件使用空格分开 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0437ff70c2cc552f731c8c97fffe5bf3/" rel="bookmark">
			一位安卓开发程序员的2023年终总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个蛮有意思的人工智能学习网站,8个字形容一下"通俗易懂，风趣幽默"，感觉非常有意思,忍不住分享一下给大家。
👉点击跳转到教程
2023年的经历还挺丰富也挺感慨，所以就有了这次年终总结。
年初过完春节后回公司上班后，领导就找我们一个一个谈话，让自己说2022年工作的怎么样，2023年有什么展望，我说的什么大家肯定都懂得，谦卑中夹着技术人对技术的持续追求，之后被告知说公司5月份左右的时候会搬家，说有什么困难吗，意思就是愿不意愿意跟着公司一起，身为来沪打工的人来说，这当然不是什么事情，无非就是从新找房子而已，向公司表明了自己的衷心。时间就这样一天一天过去，每天按时上下班，按时学习技术不断追求技术进步。
时间转眼到了，公司要搬家的时候，在公司完成搬家的第二天后，我也跟随着公司完成了租房，通勤时间40分钟，如果不搬家那么时间将近两个小时，所以我很积极第一时间选择了搬家。
在新环境办公确实挺欣喜，因为毕竟搬到了一个新环境，新鲜感还是有的，工作也很有干劲，因为新办公场地，比以前大了将近四倍，当时觉得公司未来可期，自己估计也能跟着喝个汤，年底涨个薪啥的，就在我还没从梦中醒来的时候，在我正在热火朝天工作的时候，同事跟我说公司开始裁员了，当时我的心想裁就裁呗，我这边活多的很，我还这么年轻，技术也还算OK，跟我有什么关系呢，主打一个事不关己的样子，两个小时候后，我便收到HR的消息，让我去办公室一躺，这个时候我才知道也裁到了我的头上。接下面的事情关注我的人应该都知道，马不停蹄的找工作。
刚开始离职的我说实话一点都不伤心，这个公司加班真的很严重，但是我也非常感谢这家公司，让我的个人能力和编码速度得到了一个质的飞跃，我当时心想我在这家公司都能顶得住，出来找工作，那岂不是轻轻松松，但是结果大家也都知道，投出的简历，根本没人回，这让我一向奉行的技术第一的信仰崩塌了，以前的我想法很简单，只要努力学技术就能有更加美好的钱途，但是结果并不是这样，甚至连展示能力的机会都没有，自此之后，直到现在我的业余时间，都不再把学技术放在了第一，因为很多技术学了就忘了，我想学一些真正能提高自身竞争力的知识，或者考取一些有用的能证明自己的证书，也比自己闷头敲代码强的多。
最后功夫不负有心人，我花费了半个月的时间重新找到了一份安卓开发的工作，试用期半年，工资打八折，现在的我通过努力，已经提前转正，下半年也是兢兢业业的当一个上班族，把工作做完的基础上，想办法做优，让公司产品更好的同时，自己的技术也能得到提升，这岂不是一举两得。
以上是我2023年一年中所发生的一些自身经历，心态固然会变化，但是冷静想想做程序员最重要的还是技术提升，所以希望不会影响大家对技术的一个看法，我只是觉得一定要做对自己有价值的事，并且能证明自己有价值，并且努力的事情，而不是自己闷头学技术，结果根本就用不到的情况，在我看来这还是挺可悲的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deec9b6a22c58028d0fcdc7a3865c13f/" rel="bookmark">
			【MySQL】数据库之存储过程（“SQL语句的脚本“）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是存储过程？
二、存储过程的作用
三、如何创建、调用、查看、删除、修改存储过程
四、存储过程的参数（输入参数，输出参数，输入输出参数）
第一种：输入参数 第二种：输出参数
第三种：输入输出参数
五、存储过程中的条件与循环语句
第一种：if条件的存储过程
第二种：while循环的存储过程 六、如何一次性往数据库中插入上万条数据？
第一种存储过程实现上万数据插入
第二种shell脚本实现上万数据插入
一、什么是存储过程？ 存储过程是一组为了完成特定功能的SQL语句的集合。有点shell脚本的意思
存储过程在使用过程中，是将常用或者复杂的工作预先使用SQL语句写好并用一个指定的名称存储起来，这个过程经编译和优化存储在数据库服务器中，当需要使用该存储过程的时候，只需要调用即可。存储过程在执行上比传统的SQL语句速度更快，执行的效率也更高。
二、存储过程的作用 优点：
1、执行一次后，会将生成的二进制代码驻留缓冲区，提高执行效率；
2、SQL语句加上控制语句的集合，灵活性高；
3、在服务器端存储，客户端调用时，降低网络负载；
4、可以多次重复调用存储过程，也可以随时修改，不影响客户端的调用；
5、可以完成所有数据库的操作，也可以控制数据库的信息访问权限。
三、如何创建、调用、查看、删除、修改存储过程 存储过程也是一种对象，增删改查的命令可以套用DDL的相关语句
存储过程是创建在库中的，需要先用use切换库，否则需要在创建的时候，指定库名 ##创建存储过程了 delimiter 结束符 ##先自定义结束符，因为存储过程中的SQL语句用分号结尾，这时需要修改作为区分 create procedure 存储过程名称() begin SQL语句集合 end结束符号 delimiter ; ##将结束符修改回为分号 ##查看存储过程 show create procedure [库名].存储过程名称; show procedure status like '存储过程名称' \G; ##支持通配符 ##调用存储过程 call 存储过程名称; ##删除存储过程 drop procedure 存储过程名称; drop procedure if exists 存储过程名称; ##如果存在则删除 修改存储过程的方法：
存储过程内容的修改方法是通过删除原有存储过程，之后再以相同的名称创建新的存储过程。如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。 总结就是重新创建储存过程，没有直接删除的方法
四、存储过程的参数（输入参数，输出参数，输入输出参数） 可以在存储过程创建的时候加入参数，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deec9b6a22c58028d0fcdc7a3865c13f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd57f027e7ad38386c80891135d17db7/" rel="bookmark">
			基于ssm的4S店预约保养系统开发&#43;vue论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 目 录 I
摘 要 III
ABSTRACT IV
1 绪论 1
1.1 课题背景 1
1.2 研究现状 1
1.3 研究内容 2
2 系统开发环境 3
2.1 vue技术 3
2.2 JAVA技术 3
2.3 MYSQL数据库 3
2.4 B/S结构 4
2.5 SSM框架技术 4
3 系统分析 5
3.1 可行性分析 5
3.1.1 技术可行性 5
3.1.2 操作可行性 5
3.1.3 经济可行性 5
3.1.4 法律可行性 5
3.2 系统性能分析 5
3.3 系统功能分析 6
3.3.1 角色需求 6
3.3.2 功能需求 6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd57f027e7ad38386c80891135d17db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa04d7240c95d46604bcdd337bc5e052/" rel="bookmark">
			软件集成测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件集成测试是将各个独立的软件模块组合起来，并测试它们之间的接口和交互是否正常工作的过程。下面是软件集成测试的一般步骤：
确定测试策略：确定集成测试的目标、范围和测试策略。确定要测试的软件模块和它们之间的依赖关系。
设计测试用例：根据软件模块的接口规范和功能需求，设计测试用例，包括输入数据、预期输出和测试步骤等。
创建测试环境：设置一个适当的测试环境，包括所需的硬件、软件和网络配置。确保环境与实际生产环境尽可能相似。
执行单元测试：在进行集成测试之前，确保每个单独的软件模块已经通过了单元测试，并且功能正常。
逐步集成测试：从最简单的模块开始，逐步将其他模块集成到测试环境中。每次集成一个或多个模块，并进行相应的测试。
接口测试：针对不同模块之间的接口进行测试。确保数据传递、消息传递和函数调用等接口操作正常。
功能测试：执行功能测试用例，验证整个系统的功能是否按预期工作。
错误处理和异常情况测试：测试系统在错误和异常情况下的响应和恢复能力。例如，测试系统是否能够正确地处理无效输入或系统故障。
性能测试：评估系统的性能指标，如响应时间、吞吐量和资源利用率等。
安全性测试：测试系统的安全性，包括身份验证、数据加密和访问控制等方面。
记录和分析测试结果：记录测试过程中的观察结果、错误和问题。分析测试结果，确定需要修复的问题和改进的地方。
修复和重新测试：根据测试结果修正软件中发现的问题，并进行重新测试，确保问题得到解决并且不会引入新的问题。
完成测试报告：整理测试结果和所获得的数据，撰写集成测试报告，包括测试方法、结果总结、问题和建议等信息。
以上是软件集成测试的一般过程。具体的步骤和方法可能因项目的规模和需求而有所不同。在实际应用中，还可以使用自动化测试工具来辅助执行集成测试，提高效率和准确性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb18b8c6ee5a668db5f461e48bc50df/" rel="bookmark">
			vue-cli搭建项目及一些打包配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vu-cli vue create快速搭建项目 版本信息：Vue CLI v4.5.12
vue create projectName 模式和环境变量 模式 1》开发模式
vue-cli-service serve 2》测试模式
vue-cli-service test:unit 3》生产模式
vue-cli-service build 和 vue-cli-service test:e2e 当我们运行 vue-cli-service 时，环境变量从对应的环境文件中读取；如果文件内部不包含 NODE_ENV 变量，它的值将取决于模式，例如，在 production 模式下被设置为 "production"，在 test 模式下被设置为 "test"，默认则是 "development"
--mode 选项参数为命令行修改默认的模式，可以自己设置模式；比如我下面设置了devtest模式
"devtest" : "vue-cli-service build --mode devtest" 环境变量 然后我在项目的根目录下(新建 .env.devtest 文件)配置devtest环境的环境变量
一个环境文件只包含环境变量的“键=值”对
VUE_APP_MODE="devtest" 设置环境变量的文件
.env # 在所有的环境中被载入 .env.local # 在所有的环境中被载入，但会被 git 忽略 .env.[mode] # 只在指定的模式中被载入 .env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 使用环境变量
process.env.VUE_APP_MODE 注意：不要在你的应用程序中存储任何机密信息（例如私有 API 密钥）；环境变量会随着构建打包嵌入到输出代码，意味着任何人都有机会能够看到它
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb18b8c6ee5a668db5f461e48bc50df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b18743b64b9259dbea65777132b19c/" rel="bookmark">
			STM32 智能家居项目 FreeRTOS 密码锁 指纹锁 GSM远程控制 设计报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料下载: https://download.csdn.net/download/vvoennvv/88503621
一、概述 使用STM32F407芯片，FreeRTOS系统，门禁支持密码输入、指纹输入；人体感应灯可实现家居环境中人体自动识别，并用来控制灯光部分的开、关以及延时功能；GSM远程控制通过手机远程向GSM模块发送短信，并识别短信的内容，根据器内容实现对家庭电器、窗帘、照明的本地或远程控制。
二，整体设计 2.1 密码系统 设计为有两个6位数字密码，并可以进入系统后选择修改密码。首先，系统会不断扫描是否有按键按下。当检测到密码输入时，会将输入的数值保存在一个字符串中，并显示“*”来防止偷窥，可以通过“显示”按键来显示或隐藏密码。密码最多输入6位。输入完成后按确认键，系统就会将字符串的密码一位位地和系统保存的密码进行比较，当存在不同时，系统会显示“密码错误”并清空输入的密码。输入密码正确则跳转进入系统的主界面。在主界面可以选择修改密码进入，然后选择密码修改。
2.2 指纹识别 （1）不断检测指纹；
（2）录入图像。当你的手指放在光学指纹窗口的时候执行这个指令，就可以把指纹的图像拍下来。
（3）生成特征。当你的指纹图像拍下来之后，调用这个指令就可以把图像中的指纹特征记录下来。AS608里面有2个缓存区可以存这个特征。
（4）搜索指纹。调用这个指令就会将已经存在Flash里面的指纹模板和缓存区的指纹特征一一比对，如果有搜索到，则开锁进入系统主界面。
要注意的是，调用的时候需要指明比对的特征是缓存区1还是缓存区2，即你要选择第二步生成的特征所存储的缓存区。
2.3 人体感应 人体红外检测模块HC-SR501只有三个管脚（VCC,GND,DATA），电源VCC和地GND，数据输出管脚DATA。当检测到有人体活动时，DATA输出高电平，平常没有检测到有人体活动时输出为低电平。
2.4 GSM远程控制 系统不断检测是否有短信输入，当接收到信息时，屏幕提示信息输入，并读取判断短信内容，如果短信中有“on”则开灯，有“off”则关灯，如果都没有则不执行退出。该开灯关灯功能都会使人体感应功能关闭，可在设置中恢复。
三，设计报告 在该项目的系统中我主要以stm32F407系列单片机作为主控芯片，正点原子STM32F4开发板的接口丰富，芯片功能强大，资源都可以灵活配置，可以方便的进行各种外设的实验和开发，适合新手的开发学习。
门禁系统方面主要有密码输入部分和指纹识别部分组成。密码输入部分我选择4*4的键盘输入模块，该模块结构简单，易于连接实现密码键盘功能。通过对键盘的按键不断扫描，可以检测被按下的按键，进而确定用户的密码输入。通过编程实现将输入密码一位位与系统保存的密码相比较。正确密码后，主控芯片就会发送指令控制继电器驱动进行开锁，输入密码错误则会提示错误信息。进入系统内部后，能对用户的密码进行修改功能。这里就要用到stm32内部的flash来存储密码。将修改后的密码写入到flash中，防止密码掉电后丢失。
指纹模块部分则使用as608指纹模块，ATK-AS608指纹识别模块是一款比较成熟的指纹模块，官方提供了指纹录入、指纹识别、指纹删除等一系列功能，方便我们进行设计调用。通过给AS608发送特定的指令，就可以调用里面的算法，进行相应的指纹操作。所以我们编程实现，系统开机就会自动读取模块中存储的指纹方便进行比对，然后不断检测指纹模块是否有指纹输入，检测到指纹后调用指纹匹配指令进行指纹对比，匹配成功则开锁进入系统总界面，匹配失败则显示错误信息。开锁后可以选择进行添加指纹、删除指纹的操作。添加指纹时，系统发送添加指纹指令，然后与指纹模块通讯一步步进行指纹录取，最后通过4*4按键模块输入指纹ID存储进指纹模块当中；删除指纹，调用模块的删除指纹指令，然后使用4*4按键模块进行输入指纹ID进行删除，也可以选择一键清空操作。
人体识别控制灯光部分使用HC-SR501人体检测模块来实现，当该模块检测到有人体靠近的时候，模块引脚就会输出高电平到开发板，开发板检测到电平的输入后，控制连接灯光的引脚输出，来达到人体识别控制灯光的目的。当我们进入系统控制界面时，就可以选择灯光设置来对灯光各项参数进行设置。该灯光设置部分需要有总的开关控制和延时设置。总开关设置，该部分通过定义一个全局变量来判断控制实现。当总开关按钮按下，先判断全局变量是0还是1，是0说明灯功能是开着的，就进行关灯并将全局变量置1；反之是1说明灯是关闭的，就开灯并将全局变量置0。延时设置，用户可以直接通过4*4按键模块输入需要的延时数值，确定后该数值会存储到系统内部flash，每一次亮灯前都会先自动读取flash中的数值，确定延时时间再进行亮灯。这样就能方便精确地去控制灯光的延时时间了。
短信远程控制家电部分采用sim800c实现短信的接收、和开发板通讯。开发板系统可以通过调用模块的指令实现与模块的通讯和模块功能的设置。系统开机时，我们首先需要通过串口与sim800c建立通讯，检测sim卡是否正常。通讯成功后，系统需要不断检测串口的输入，检测到有短信传入后有显示提示，然后直接读取短信内容，检测短信内容字符串中是否含有“开灯”、“关灯”等操作内容，有则执行相关操作否则当作其他短信过滤掉。
关于系统的显示，我们采用正点原子的2.8寸电阻触摸屏进行显示，使系统的操作界面简洁明了便于操作，同时显示返回错误信息，提醒用户。最后将这些模块和功能都集合到一起，就能构建成我们的系统作品了。
3.3可能出现的工作难点与拟解决的方法
其中的难点就是实现开发板与各部分模块的正确通讯，还有各部分功能的组合，协调不发生冲突。在此，查阅了有关资料，决定采用freertos操作系统来实现各部分功能任务协调执行。将需要实时检测执行的功能任务设置成高优先级，随时去执行，而缺少实时性的任务设置成低优先级。在执行后或不执行时通过延时挂起函数来暂时挂起高优先级任务，去执行低优先级的任务。这样就能解决各功能任务相互冲突的问题了。
四，总结 一个学习STM32不可多得的项目，通过该项目可以熟悉STM32各种片内资源的使用。
资料下载: https://download.csdn.net/download/vvoennvv/88503621
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/017a8d0f9d415197d7265304dce2b1f6/" rel="bookmark">
			滤波器opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在OpenCV中，滤波器用于对图像进行平滑、锐化、边缘检测等操作。以下是一些常用的滤波器及其在OpenCV中的Python代码示例：
均值滤波器（平滑图像）： import cv2 import numpy as np # 读取图像 image = cv2.imread('path_to_your_image.jpg') # 应用均值滤波器 blurred_image = cv2.blur(image, (5, 5)) # 使用5x5的核进行滤波 # 显示结果 cv2.imshow('Original Image', image) cv2.imshow('Blurred Image', blurred_image) cv2.waitKey(0) cv2.destroyAllWindows() 高斯滤波器（平滑图像，减少噪声）： import cv2 import numpy as np # 读取图像 image = cv2.imread('path_to_your_image.jpg') # 应用高斯滤波器 gaussian_blur = cv2.GaussianBlur(image, (5, 5), 0) # 使用5x5的核，标准差为0 # 显示结果 cv2.imshow('Original Image', image) cv2.imshow('Gaussian Blurred Image', gaussian_blur) cv2.waitKey(0) cv2.destroyAllWindows() 中值滤波器（去除椒盐噪声）： import cv2 import numpy as np # 读取图像 image = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/017a8d0f9d415197d7265304dce2b1f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/218179e07b39d764a7a806f94e458afd/" rel="bookmark">
			Spark Streaming
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、流计算概述
（一）静态数据和流数据
（二）批量计算和实时计算
（三）流计算概念
（四）流计算框架
（五）流计算处理流程
二、Spark Streaming
（一）Spark Streaming设计
（二）Spark Streaming与Storm的对比
（三）从“Hadoop+Storm”架构转向Spark架构
三、DStream操作概述
（一）Spark Streaming工作机制
（二）Spark Streaming程序的基本步骤
（三）创建StreamingContext对象
一、流计算概述 （一）静态数据和流数据 很多企业为了支持决策分析而构建的数据仓库系统，其中存放的大量历史数据就是静态数据。技术人员可以利用数据挖掘和OLAP（On-Line Analytical Processing）分析工具从静态数据中找到对企业有价值的信息。
近年来，在Web应用、网络监控、传感监测等领域，兴起了一种新的数据密集型应用——流数据，即数据以大量、快速、时变的流形式持续到达。实例：PM2.5检测、电子商务网站用户点击流。
流数据具有如下特征：
（1）数据快速持续到达，潜在大小也许是无穷无尽的。
（2）数据来源众多，格式复杂。
（3）数据量大，但是不十分关注存储，一旦经过处理，要么被丢弃，要么被归档存储。
（4）注重数据的整体价值，不过分关注个别数据。
（5）数据顺序颠倒，或者不完整，系统无法控制将要处理的新到达的数据元素的顺序。
（二）批量计算和实时计算 对静态数据和流数据的处理，对应着两种截然不同的计算模式：批量计算和实时计算。
批量计算：充裕时间处理静态数据，如Hadoop。流数据不适合采用批量计算，因为流数据不适合用传统的关系模型建模。
实时计算：流数据必须采用实时计算，响应时间为秒级。数据量少时，不是问题，但是，在大数据时代，数据格式复杂、来源众多、数据量巨大，对实时计算提出了很大的挑战。因此，针对流数据的实时计算——流计算，应运而生。
（三）流计算概念 流计算：实时获取来自不同数据源的海量数据，经过实时分析处理，获得有价值的信息。
流计算秉承一个基本理念，即数据的价值随着时间的流逝而降低，如用户点击流。因此，当事件出现时就应该立即进行处理，而不是缓存起来进行批量处理。为了及时处理流数据，就需要一个低延迟、可扩展、高可靠的处理引擎。
对于一个流计算系统来说，它应达到如下需求：
（1）高性能：处理大数据的基本要求，如每秒处理几十万条数据
（2）海量式：支持TB级甚至是PB级的数据规模
（3）实时性：保证较低的延迟时间，达到秒级别，甚至是毫秒级别
（4）分布式：支持大数据的基本架构，必须能够平滑扩展
（5）易用性：能够快速进行开发和部署
（6）可靠性：能可靠地处理流数据
（四）流计算框架 当前业界诞生了许多专门的流数据实时计算系统来满足各自需求。目前有三类常见的流计算框架和平台：商业级的流计算平台、开源流计算框架、公司为支持自身业务开发的流计算框架。
第一类是商业级的流计算平台：
——IBM InfoSphere Streams
——IBM StreamBase
第二类是开源流计算框架，也是较为常见的，代表如下：
——Twitter Storm：免费、开源的分布式实时计算系统，可简单、高效、可靠地处理大量的流数据。
——Yahoo! S4（Simple Scalable Streaming System）：开源流计算平台，是通用的、分布式的、可扩展的、分区容错的、可插拔的流式系统。
第三类是公司为支持自身业务开发的流计算框架：
——Facebook Puma
——Dstream（百度）
——银河流数据处理平台（淘宝）
（五）流计算处理流程 1、概述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/218179e07b39d764a7a806f94e458afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791347e71f63293fbddb1d367f7cdfc5/" rel="bookmark">
			腾讯欧拉平台产品经理：如何做一款好的数据平台？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 本次分享的主题为如何做一款好的数据平台。来自腾讯的高级产品经理贺智超老师将分享他在数据平台相关工作中的一些思考和实践。
主要内容包括以下五大部分：
1. 技术转产品的思考
2. 深度理解数据工作者的需求
3. 腾讯欧拉资产工场实践
4. 数据平台产品经理方法论
5. 问答环节
分享嘉宾｜贺智超 腾讯 资深产品经理 01
技术转产品的思考
贺老师毕业于计算机软件专业，曾接触过软件开发、图像识别、数学挖掘等专业知识，毕业后成为了一名程序员。后经历了团队从业务的数据研发工作到中台的数据平台研发的转型，积累了丰富的大数据研发经验。由于个人兴趣以及团队角色的需求，在同一个项目内逐步转型为数据平台产品经理。
因此，技术到产品的转型，需要结合内在性格、外部机遇和自我培养等多方因素才能实现。
产品与研发的区别主要体现在职能、思维和研发上，两者需要相互配合共同实现价值。数据平台属于技术型平台，对产品经理的要求更高，既要有产品经理的必备素养，又要有大数据领域的专业技术。
技术转型产品需要做如下一些准备工作：
首先是判断。从专业知识、好奇心、是否对负责任的事情操心、积极的心态、善于挑战目标、沟通能力等角度判断是否适合转型。并判断是否有足够好的机会，比如在同一项目内部进行转型就是一个比较好的机会。
第二尝试。在转型之前，是从产品的视角对需求进行思考，做一些思维上的简单训练和尝试。从简单的需求入手，进行原型图绘制，需求文档撰写等。
第三是学习。培养自身产品经理所需要的一些素养，提升自身产品力，太过于技术的思维方式会阻碍产品力的发展，如果总是考虑实现的难度就可能会丢失一些好的想法。
02
深度理解数据工作者的需求
接下来分享如何由浅入深地理解数据平台的用户需求。
以内容类 APP 为例，它是通过内容连接用户和平台，即作者使用 APP 发布内容，APP 再通过推荐算法将合适的内容推荐给用户。在算法推荐、用户精细化运营、业务决策环节都需要用到数据生产资料，尤其对于算法模型而言，数据决定了一个算法的上界。由此可见，数据非常重要。
在这种背景下，数据层面却仍然面临着很多问题。面向数据开发的工具非常多，但是围绕数据资产本身的工具缺乏，导致数据的管理和使用混乱。数据需要反复验证，查询速度非常慢导致数据分析师效率低。对于策略产品经理而言，只能查到基础的表结构，没有功能去了解表的更多数据信息。公司内的数据工具和平台非常多，但没有协同效应，连集群都是割裂的，这非常不利于数据工程师的工作。表名乱，没有数据规范，数据质量差，出了问题新入职的数据工程师也不知道能找谁。
为了解决这些问题，我们以建设数据资产为目标，来搭建数据平台能力。当一份数据较为规范、易于理解、质量可靠，我们可以称之为数据资产。当数据资产能方便地被下游使用时，才可能发挥出数据中更大的价值。
因此早期欧拉平台着力于打造一个数据资产管理平台，用于沉淀出业务的核心数据资产，面向数据工程师提供数据管理、数据质量监控能力。欧拉先采集表的技术元数据并做一些加工，然后提供一些管理工具给用户登记业务元数据来丰富表的描述，让数据变得更易理解。数据科学家或数据分析师在充分了解数据后，再使用 Presto 这样的高速查询引擎来快速获取分析结果。
平台上线后运行效果并没有完全达到预期，主要有以下问题。首先，问题产生后再解决比较棘手，例如开发一张表，表名已经建好甚至数据已经被下游使用，这时修改会很麻烦，只能做简单的数据管理。其次，数据已经产生甚至已经交付后治理的动力明显不足，导致最终业务的信息登记更少，无法形成一个有效的元数据管理氛围，周期性运动式的治理难以持续。
那么 DE 到底需要什么呢？
通过 Presto 引擎将查询速度提升了，但产品体验也是决定工作效率的核心因素。
技术元数据更丰富，拥有了数据地图的检索能力，但业务元数据很难沉淀，找到表之后缺乏描述表业务信息的内容。
数据质量问题能被有效监控，但很难定位到根因。
数据管理、质量监控等能力在功能矩阵上新增了，但生产流程与管理流程依然割裂。
针对上述问题，有如下解法：
解法1：把一些治理动作提前到生产过程中，不仅规范了表名，也规范了整个开发流程，从而推动整个新表资产化的程度，旧表通过引入的方式进入到治理过程。
解法2：有机整合在整个生产过程中用到的平台工具，来提升数据工程师的效率，元数据信息也因此不会被重复冗余登记。
解法3：构建数据资产化程度的评价指标，从规范、安全、成本、应用等角度设计此评价体系，持续驱动存量和新增数据的治理。
解法4：从上游提前规避数据质量问题。在上游开发阶段充分进行数据测试，核心节点出现问题时能阻断下游传播，防止对下游数据的污染。对于报表延迟风险，在上游出现变慢或失败等突发状况时，评估下游的一些核心保障节点是否有延迟风险。
解法5：将软件工程领域有效的经验进行转换吸收应用到数据工程领域。比如 DataOps 是从敏捷、Devops、精益制造吸收的灵感。通过落地 DataOps 可以提升整体协同效率，保障数据质量，减少开发工作量。
按照“组合创新&amp;错位竞争”的思路，将解决用户需求的方向，从数据资产管理平台，最终转向成了打造一站式数据资产开发平台（资产工场），把管理过程前置到开发，借鉴软件工程思想，目标群体也更专注在数仓工程师、而不是所有的数据研发。
03
腾讯欧拉资产工场实践
接下来介绍腾讯欧拉资产工场的落地实践。
腾讯欧拉资产工场是基于 DataOps 的一站式数据开发平台。通过提前制定流程规范、设定数仓配置，大大增强了整个数据仓库的规范性，并同时兼顾开发效率。
功能矩阵如下图所示：
首先是数据规划。对包括业务域、主题域在内的数仓架构进行设计，对 Hive 以外的数据源进行统一管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791347e71f63293fbddb1d367f7cdfc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf80fa22f19f73c38f5e9859fe97af5/" rel="bookmark">
			装上这 8 个插件，PyCharm才真的是无敌的存在！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给IT入门加星标，提升编程技能 ChinesePlugin 经常听到很多初学者抱怨说，PyCharm 怎么是全英文的？学起来好难啊。
在以前，我会跟他们说，学习编程语言，英文是一项非常重要的能力，千万不能惧怕它，逃避它，而要是去学习它，适应它，如果连个 IDE 都适应不了，那就别学编程了。
而现在，JetBrains 官方自己出了汉化插件，名字就叫：chinese，在插件市场里一搜，排名第一便是它，下载量已经 40 万，对比排名第二的民间汉化插件，简直不是量级的。
点击 INSTALL 安装后，会提示你进行重启，才能生效。
重启完成后，展现在我们面前的是一个既熟悉又陌生的界面，所有的菜单栏全部变成了中文。
点进设置一看，可以说基本实现了汉化，只剩下一小撮的英文（难道是因为这些词保留英文会比翻译后更容易理解吗？就像 socket 和套接字一样。），不过个人感觉完全不影响使用了。
Markdownin PyCharm 富文本排版文档是一件非常痛苦的事情 ，对于程序员写文档，最佳的推荐是使用 Markdown ，我所有的博客日记都是使用 Markdown 写出来的。
从 Github下载的代码一般也都会带有README.md文件，该文件是一个Markdown格式的文件。
PyCharm是默认没有安装Markdown插件的，所以不能按照Markdown格式显示文本，显示的是原始文本。
因此，如果要在 PyCharm 中阅读 Markdown 文档，可以装一下 Markdown support 这个插件。
安装的方法有两种：
1、第一种，最方便的，就是你打开一个 MD 的文档，PyCharm 就会提示你安装它。
2、从插件商店中搜索安装。
效果如下 JupyterNotebook in PyCharm
使用 Jupyter 之前 ，先要安装它
$ pip install jupyter 然后按照下图指示新建一个 Notebook ，就可以开始运作了。
这个界面感觉和Jupyter 的风格不太符
但是使用上是没有什么区别的，记住三个快捷键就好(下面指的是 Mac 上的，Windows 上的有所不同)
Ctrl+Enter：运行该 cell
Option + shift + Enter：调试该 cell
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf80fa22f19f73c38f5e9859fe97af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8aea21126ee4d2a976651fa26024d2/" rel="bookmark">
			python股票分析挖掘预测技术指标知识大全（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包，
我们已经初步的接触与学习其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
也简单介绍一下数据获取的二种方法，通过金融数据接口和爬虫获取。
既然有了数据，python知识也入门了。那么重点要对这些数据分析，来预测股票的未来的大概率走势，让我们这些韭菜们心里有底。
(1)指标有用论 相信技术指标有用论是我们能开发这套股票预测系统的最大的信念和动力。
有一句名言：股市没有新鲜事，不可能有的。投机向群山一样古老，亘古长存，从未改变。股市上今天发生的事，过去曾经发生过，将来还会在此发生。
对过去的数据进行技术分析来预测未来的走势从概率学，统计学，数学的角度是完全科学和可实施的，所以才会有各种的技术指标，算法分析等等。
那么问题来了，股市小散看过各种技术书籍，各种技术指标难记于心的不乏少数，但是市场永远是二八定律，技术指标在手，亏的人远远占大多数。
道理很简单，技术指标不会骗人，程序不会骗人，但是股市是这个世界上最复杂，最具欺骗性的博弈游戏，既然所有技术指标都是根据以往的数据进行计算来预测未来，庄家可以利用大量资金技术和时间来做出虚假技术指标来骗小散入局，简称骗线，还有重要的一点，股市是对人性最大的考验，所有的技术指标不能100%的预测未来，胜算概率超过6成已经很完美了，这也是量化交易大行其道，机器没有感情，按照算法自动交易，挣钱肯定大于亏钱。
(2)编写股票分析挖掘软件核心目的 目前市场上各种交易预测软件汗牛充栋，包括证劵交易软件上kdj,macd,bill,ma等几十种技术指标已经相当完善。 但是用的人多了，盈亏还是二八定律，那就做点交易软件上没有的，增加胜算概率。
代码满足以下条件
(1)多指标共振 比如macd,kdj,boll,ma，lstm算法，线性回归算法同时预测买卖点。因为庄家多个指标同时做到骗线，难度大
(2)量价优先 量是所有指标的前提，股票交易如果每天冷冷清清，那么所有指标是不可靠的，量起来代表股票开始活跃了
(3)背离共振 多个指标有背离，比金叉死叉更加真实
(4)AI算法加持 线性回归算法，贝叶斯算法，lstm长短期记忆神经网络进行数据训练预测
注：只有满足上述大部分条件的股票再纳入自选股票池，当然，这是我个人对技术指标分析的浅薄看法，在测试和使用过程中不断调整算法来最大限度增加预测胜算概率，不足之处欢迎大家交流
(3)常见技术指标 技术指标总几十种，简单的介绍一下几个常见的
(1)指标之王MACD MACD(Moving Average Convergence / Divergence)，平滑异同平均线。是利用收盘价的短期(常用为12日)指数移动平均线与长期(常用为26日)指数移动平均线之间的聚合与分离状况，对买进、卖出时机作出研判的技术指标。
MACD指标是最著名的趋势性指标，其主要特点是稳健性，这种指标不过度灵敏的特性对短线而言固然有过于缓慢的缺点，但正如此也决定其能在周期较长、数据数目较多行情中给出相对稳妥的趋势指向。
当MACD从负数转向正数，是买的信号。当MACD从正数转向负数，是卖的信号。当MACD以大角度变化，表示快的移动平均线和慢的移动平均线的差距非常迅速的拉开，代表了一个市场大趋势的转变。
使用方法 : 随股价上升MACD翻红,即白线上穿黄线(先别买),其后随股价回落,DIF(白线)向MACD(黄线)靠拢,当白线与黄线粘合时(要翻绿未翻绿),此时只需配合日K线即可,当此时K线有止跌信号,如:收阳,十字星等.(注意,在即将白黄粘合时就要开始盯盘囗,观察卖方力量),若此时能止跌称其为”底背驰”.
底背驰是买入的最佳时机!当股价高位回落,MACD翻绿,再度反弹,此时当DIF(白线)与MACD(黄线)粘合时{要变红未变红}若有受阻,如收阴,十字星等,就有可能”顶背驰”是最后的卖出良机!
python代码实现：
import pandas as pd import talib import numpy as np import matplotlib.pyplot as plt import matplotlib.ticker as ticker fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111) df = pd.read_csv("600276.csv") df['date'] = pd.to_datetime(df['date']) df['date'] = df['date'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f8aea21126ee4d2a976651fa26024d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632f4def72d973b6b112a9f51c35a222/" rel="bookmark">
			【MySQL】数据库之高级SQL查询语句补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、补充正则表达式的查询regexp
二、补充case的用法
三、补充空值和null值的区别
一、补充正则表达式的查询regexp 要知道 在MySQL中使用正则表达式，一定要在前面加上regexp
正则表达式
^ 匹配文本的开始字符 ‘^bd’ 匹配以 bd 开头的字符串 $ 匹配文本的结束字符 ‘qn$’ 匹配以 qn 结尾的字符串 . 匹配任何单个字符	‘s.t’ 匹配任何 s 和 t 之间有一个字符的字符串 * 匹配零个或多个在它前面的字符 ‘fo*t’ 匹配 t 前面有任意个 o + 匹配前面的字符 1 次或多次	‘hom+’ 匹配以 ho 开头，后面至少一个m 的字符串 字符串 匹配包含指定的字符串 ‘clo’ 匹配含有 clo 的字符串 p1|p2 匹配 p1 或 p2 ‘bg|fg’ 匹配 bg 或者 fg [...] 匹配字符集合中的任意一个字符 ‘[abc]’ 匹配 a 或者 b 或者 c [^.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/632f4def72d973b6b112a9f51c35a222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27976f64b90e657d4f8b5ee657175713/" rel="bookmark">
			CentOS 8 上安装 Python 3.10.12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是在 CentOS 8 上安装 Python 3.10.12 的全流程，包括下载、编译和安装。请在执行这些步骤之前确保您具有足够的权限。
安装编译依赖项：
sudo dnf install -y gcc openssl-devel bzip2-devel libffi-devel zlib-devel readline-devel sqlite-devel 下载 Python 3.10.12 源代码：
cd /tmp curl -O https://www.python.org/ftp/python/3.10.12/Python-3.10.12.tgz 解压 Python 源代码：
tar -xzvf Python-3.10.12.tgz 进入解压后的目录：
cd Python-3.10.12 配置并编译 Python：
./configure --enable-optimizations make -j$(nproc) 这会根据系统的处理器数量进行并行编译。这个步骤可能需要一些时间。
安装 Python：
sudo make altinstall 使用 altinstall 而不是 install 是为了避免覆盖系统默认的 Python 版本。
验证 Python 安装：
python3.10 --version 这将显示 Python 3.10.12 的版本信息。
升级 pip：
sudo python3.10 -m pip install --upgrade pip 这将确保您使用的是最新版本的 pip。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27976f64b90e657d4f8b5ee657175713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bad304270c0de22f7a08fb3aa735993/" rel="bookmark">
			Can not create registry service-discovery-registry://*.*.*.*:2181/org.apache.dubbo.registry.Registry
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dubbo-admin-0.6.0启动的时候报错：
Can not create registry service-discovery-registry://...:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-admin&amp;dubbo=2.0.2&amp;executor-management-mode=isolation&amp;file-cache=true&amp;interface=org.apache.dubbo.registry.RegistryService&amp;logger=slf4j&amp;pid=16096&amp;qos.port=32222&amp;register=false&amp;registry=zookeeper&amp;release=3.2.5, dubbo version: 3.2.5, current host: 192.168.0.105, error code: 5-14. This may be caused by , go to https://dubbo.apache.org/faq/5/14 to find instructions.
打开apache给提供的网址查看：
5-14 - 模型启动错误 可能的原因 服务在等待发布或订阅时，连接被断开。 网络连接超时。 排查和解决步骤 检查应用服务器与配置中心的连接是否正常。 检查网络连接是否存在超时等。 解决：
在配置文件中添加2个参数
# 新加的参数 dubbo.registry.timeout=50000 # 新加的参数 dubbo.registry.parameters.blockUntilConnectedWait=50 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c60263bed8e892c93494dd202c2ed6/" rel="bookmark">
			Github 2023-12-30 开源项目日报 Top10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据Github Trendings的统计，今日(2023-12-30统计)共有10个项目上榜。根据开发语言中项目的数量，汇总情况如下：
开发语言项目数量TypeScript项目4JavaScript项目2C项目1Python项目1Java项目1HTML项目1Dart项目1非开发语言项目1 令人惊叹的 macOS 软件收集 创建周期：2722 天开发语言：JavaScript协议类型：Creative Commons Zero v1.0 UniversalStar数量：66712 个Fork数量：6068 次关注人数：66712 人贡献人数：453 人Open Issues数量：136 个Github地址：https://github.com/jaywcjlove/awesome-mac.git项目首页: https://git.io/macx 这个项目现在非常庞大，与最初的想法大不相同。在这里，我们收集了许多令人惊叹的 macOS 软件，并将它们分门别类地整理。
Paperless-ngx: 社区支持的文档管理系统 创建周期：686 天开发语言：Python, TypeScript协议类型：GNU General Public License v3.0Star数量：13699 个Fork数量：659 次关注人数：13699 人贡献人数：276 人Open Issues数量：4 个Github地址：https://github.com/paperless-ngx/paperless-ngx.git项目首页: https://docs.paperless-ngx.com Paperless-ngx是一个由社区支持的文件管理系统，可帮助将实体文件转换为可搜索的在线存档。它是原Paperless和Paperless-ng项目的官方继承者，旨在将推进和支持项目的责任分散给一个团队。该系统提供诸如docker compose部署、从Paperless-ng迁移以及广泛文档等功能。
Stirling PDF: 本地托管的强大 PDF 操作工具 创建周期：335 天开发语言：Java, HTML协议类型：GNU General Public License v3.0Star数量：9171 个Fork数量：602 次关注人数：9171 人贡献人数：68 人Open Issues数量：122 个Github地址：https://github.com/Frooodle/Stirling-PDF.git 这是一个强大的基于 Docker 的本地托管的 Web PDF 操作工具，允许您对 PDF 文件执行各种操作，如拆分、合并、转换、重新组织、添加图像、旋转、压缩等。它最初是由 ChatGPT 制作的应用程序，并不断发展，以包含各种功能，以满足您的所有 PDF 需求。Stirling PDF 不会进行任何外发呼叫来进行记录保存或跟踪。所有文件和 PDF 文件要么仅在客户端上处理，要么仅在执行任务期间在服务器内存中，要么仅在执行任务时在临时文件中。已被用户下载的任何文件在那时都已从服务器上删除。请随时在 Github 问题或我们的 Discord 中请求任何功能或错误修复。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c60263bed8e892c93494dd202c2ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e0236f5d3a001f84abd81e59b516296/" rel="bookmark">
			apache httpd多后缀解析漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、漏洞描述 Apache Httpd支持一个文件拥有多个后缀,不同的后缀执行不同的命令,也就是说当我们上传的文件中只要后缀名含有php,该文件就可以被解析成php文件,利用Apache httpd这个特性,就可以绕过上传文件的白名单。
该漏洞和apache版本和php版本无关,属于用户配置不当造成的解析漏洞
二、漏洞原理 由于管理员的错误配置, AddHandler application/x-httpd-php .php,在有多个后缀的情况下,只要一个文件含有.php后缀的文件即将被识别成PHP文件,没必要是最后一个后缀。利用这个特性,将会造成一个可以绕过上传白名单的解析漏洞。
三、漏洞复现
​如上图所示即getshell成功！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/19/">«</a>
	<span class="pagination__item pagination__item--current">20/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/21/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>