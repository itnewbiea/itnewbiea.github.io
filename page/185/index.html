<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e997cf30080c50250dd216b4c2acd27f/" rel="bookmark">
			scss @for 的使用和随机颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @for $i from 1 through 30 { .color#{$i} { color:#fff!important; background: rgba(random(255), random(255), random(255), 0.8) !important; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130c6f54cb4ff9bd1c782236d8da624e/" rel="bookmark">
			rem实现自适应布局小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简要概述关于rem(root em)和ememrem 为什么使用rem来自适应布局实现方案使用媒体查询+rem实现1.首先根据设计稿，不要管适配的问题，以rem为单位进行页面实现；2.使用媒体查询进行适配优缺点 JS+rem来实现方案思想优缺点 简要概述 自适应布局是指页面在不同大小的终端设备呈现时，页面的结构和样式都会根据屏幕的大小去显示适合当前屏幕大小的页面，较好地提升用户体验。
个人理解：像不同身材的人穿同一款式的衣服时有一个适合自己的型号选择，而不是穿同一件衣服，瘦小的身材人扎起来穿，胖大身材的人使劲撑着穿。
关于rem(root em)和em em em在css中是一种相对长度单位，类似于百分数，相对于当前元素的字体尺寸根据比例因子进行放缩。如一般字体大小默认为16px，则2em =16 X 2 =32px。
rem rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其初始字体大小。
为什么使用rem来自适应布局 自适应布局简单来说就是根据显示设备的不同尺寸自动变化‘盒子’的大小，使之更适应当前设备。页面的结构和样式不变，变的是页面中各个‘盒子’的尺寸大小，大小的变化参考基准就是显示屏幕的大小。
而em这种相对长度单位是相对于当前元素的字体尺寸；由于存在继承，如果当前元素没有明确设置字体大小时，每个元素将自动继承其父元素的字体大小。因此以 em 为单位会受到父元素、父元素的父元素等等的大小影响，页面的自适应将会变得繁杂和不可控。
rem与em不同，rem即根 em，只相对于根元素的字体大小，不受元素间继承的影响；使得一个页面中盒子的相对尺寸变化有了统一个基准参考，只要我们根据不同的终端设备尺寸设置了不同的HTML根标签元素字体大小，根标签元素字体大小改变，页面也会随之变化，也就完成了自适应布局。
实现方案 使用媒体查询+rem实现 实现流程大致分为两大部分：
1.首先根据设计稿，不要管适配的问题，以rem为单位进行页面实现； 确定页面html标签的font-size的值，叫rem的基准值；为方便计算，可以把fontsize设定为100px，此时1rem=100px；量设计稿，以rem为单位进行页面实现
举例：
量出一个盒子的width是20px ，换成rem 则是0.2rem；55px，换成rem就是0.55rem（基准值设置为100px时）。
即量出来的Px单位，只需要除以基准值，就换算成为了rem单位 ； 2.使用媒体查询进行适配 当完成设计稿的页面实现后，可以进行下一步的适配问题。以上述设计稿750px，基准值为100px为例：
@media only screen and (width:750px) { html{ font-size: 100px; } } @media only screen and (width:375px) { html{ font-size: 50px; } } @media only screen and (width:320px) { html{ font-size: 42.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130c6f54cb4ff9bd1c782236d8da624e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e894025bdfac80a1373eb228270349c5/" rel="bookmark">
			SpringBoot项目测试类运行错误：java.lang.NoClassDefFoundError: org/springframework/util/Assert
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot项目测试类运行错误
Test ignored. java.lang.NoClassDefFoundError: org/springframework/util/Assert at org.springframework.test.context.junit.jupiter.SpringExtension.getTestContextManager(SpringExtension.java:210) at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:77) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeBeforeAllCallbacks$7(ClassBasedTestDescriptor.java:359) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeBeforeAllCallbacks(ClassBasedTestDescriptor.java:359) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:189) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.before(ClassBasedTestDescriptor.java:78) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:132) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) at java.util.ArrayList.forEach(ArrayList.java:1257) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125) at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122) at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80) at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32) at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57) at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248) at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211) at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226) at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e894025bdfac80a1373eb228270349c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da2bf43cbade3be6585d8b6db17fb3fb/" rel="bookmark">
			Android 10编译报错整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译Android 10遇到以下不同报错，没有给出明显的错误信息，最后验证出是电脑内存不足导致编译被杀掉，增大电脑内存和Swap分区之后解决。
注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。 [ 91% 123644/134926] //vendor/qcom/proprietary/interfaces/voiceprint/1.0:vendor.qti.voiceprint-V1.0-java javac [common] 注: 某些输入文件使用了未经检查或不安全的操作。 注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。 [ 91% 123695/134926] //frameworks/opt/net/voip:voip-common javac [common] 注: frameworks/opt/net/voip/src/java/com/android/server/sip/SipService.java使用或覆盖了已过时的 API。 注: 有关详细信息, 请使用 -Xlint:deprecation 重新编译。 注: frameworks/opt/net/voip/src/java/com/android/server/sip/SipService.java使用了未经检查或不安全的操作。 注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。 Killed 23:17:51 ninja failed with: exit status 1 #### failed to build some targets (04:22:30 (hh:mm:ss)) #### 1 warning generated. [ 77% 4462/5762] //frameworks/base:test-api-stubs-docs Metalava Check API [common] FAILED: out/soong/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da2bf43cbade3be6585d8b6db17fb3fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e73ba94db8023a095afc06ddb4180ff/" rel="bookmark">
			swin transformer论文及代码学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文 源码
Overall Architecture Image 输入image的大小为三维矩阵：H W 3。H为Height，W为Width，3为通道channel，这里指的是RGB。图中只以一个image为例，也就是batch_size = 1。
Patch Partition 一张图片读入后表示为像素矩阵，需要先对图片进行patch partition处理，将图片的最小单位从像素转变为patch。论文中所给的示例为一个patch由4*4个pixel构成，即patch partition模块用包含4*4个像素的patch来对像素矩阵进行分割，并一个patch中的像素值合成一个向量。输入的像素矩阵经过处理后变为的三维矩阵，其中H/4 * W/4表示patch的数量，48为channel，由3*4*4得来。
Linear Embedding A linear embedding layer is applied on this raw-valued feature to project it to an arbitrary dimension(denoted as C).C default 96.
代码中PatchEmbed()类中包含了Patch Partition 和Linear Embedding两个模块。具体代码含义见下面注释。
class PatchEmbed(nn.Module): r""" Image to Patch Embedding Args: img_size (int): Image size. Default: 224. patch_size (int): Patch token size. Default: 4. 4 pixel in_chans (int): Number of input image channels.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e73ba94db8023a095afc06ddb4180ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9064fe4371cd3db1c5b0f4e40dbbdcfc/" rel="bookmark">
			prt文件在线浏览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天很多工程师都使用不同的CAD软件，以至于产生了不同格式的CAD格式文件，因此所有人都难以互换，其中主流的CAD软件有：PTC Creo，Siemens NX，CATIA，SolidWorks，Autodesk Inventor等，如果要向下游进行传递或是需要在线预览下车间等，则需要统一轻量化处理后方可传递或是在线预览，经过近三年的时间探索，目前实现了几种主流CAD文件的轻量化处理，处理后的文件可以在线预览或是传递给下游系统，如有需要可以扫描下方企鹅交流，其中prt文件在线预览如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11acd142631fe6e0e00c5d2a3e7cb0cd/" rel="bookmark">
			React 组件性能优化之 PureComponent 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章出自个人博客：https://knightyun.github.io/2021/05/09/js-react-purecomponent，转载请申明
在 React 类组件中，如果状态（state）发生变化，便会触发组件的重新渲染（执行 render 方法），并且是包括所有子组件在内的全部重渲染，无论某些子组件是否有用到 state 中的值；但有些时候部分子组件计算或渲染工作量较大，并且只做一些情况单一的展示工作，那么在更新状态时对其的渲染，便是额外的性能负担，所以需要寻求一些优化手段；
shouldComponentUpdate shouldComponentUpdate 是 React 的生命周期函数之一，它会在每次渲染（render）之前被调用，并且根据该函数的返回值（true/false）来决定是否调用渲染函数（return true 触发渲染，return false 阻止渲染），但是组件的首次渲染或者调用 forceUpdate() 方法时不会触发调用 shouldComponentUpdate 方法；该生命周期函数的默认行为是在每次 state 发生变化时触发重新渲染，如果自行声明该函数会覆盖这一默认行为，需要自行判断 state 的变化以决定是否重新渲染；
shouldComponentUpdate 方法接收两个传参：(nextProps, nextState)，分别表示变化后的 props（组件的参数） 和 state（组件的状态）；
class MyComponent extends React.Component { state = { count: 0 }; shouldComponentUpdate(nextProps, nextState) { // 无需手动更新 state 值，组件会自动更新 // this.setState({ ...nextState }); if (nextState.count &lt;= 3) { // count 值大于 3 后，组件便不再更新 return true; } else { return false; } } render() { const { count } = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11acd142631fe6e0e00c5d2a3e7cb0cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c178dd38ab6d0995b49daf6128de3e/" rel="bookmark">
			从土木零基础转行数据挖掘和算法的过程与办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		17年1月硕士毕业，后去国企设计院工作，次年4月裸辞后去杭州准备转行，后进入一家互联网金融公司做数据挖掘。大半年后又辞职来到京东做算法，直到现在。
这两年算法岗卷得不是人，以为大家转行的热度会小一些，但发现还是有很多朋友想转互联网，以运营和数据为主。我也是从0开始，探索怎么转行，转去做什么，最后走到了这里。
分享下这段经历，只要对一个人有思考的价值，也是有价值的。
先把排掉坑之后最真诚的推荐总结下，正文有详细的学习过程和坑。
学语法学基础
《笨办法学Python》和《Python基础教程》
学Web开发
《Flask Web开发：基于Python的Web应用开发实践》
学git，学html和css：菜鸟教程
学数据分析
Dataquest：Data Scientist – Python路线
学markdown写作
学sql：SQL zoo、牛客网、力扣
学Python库（NumPy, pandas, matplotlib, sklearn）：《利用Python进行数据分析》《Python数据科学手册》
学算法
西瓜书、统计学习方法、深度学习入门
Coursera 上的deeplearning.ai的专项课程
01
毕业以前
10年上大学时，房地产大周期正盛，各大院校土木招生人数多分数高，大家都在往这个方向转。难以忘记，有个计算机专业的哥们转专业来学土木，问其原因竟是《越狱》男主Michael Scofield是位结构工程师。
土木专业作为一门应用型学科，专业课非常地难学，专业壁垒特别高。真正要命的是，土木学科和其他学科很难交叉，机械可以和自动化、机器人交叉，材料可以通过半导体、高分子、电池等领域进入科技公司，唯独土木，往科技上凑的BIM搞成了什么，广联达跟土木也没有什么关系。即使近年来市场萎靡，产能过剩，土木从业者找工作还是没有问题的，毕竟除了房产还有基建，除了国内还有国外。
总而言之，那个时候土木专业的同学，是没有几个吵着闹着争着抢着转行的。我也不例外，即使有过实习经历，也并没有想着跳出行业看看。本科想着保研，读研想着发论文去设计院，参考着有限几种师兄师姐的发展路径，在局限的认知里也落得快活。
人总是要先进入了一种生活，才知道要跳出这种生活。围城内外。
02
为什么转行
在设计院工作，地位和收入虽不比早年，在一个二线城市，还是很安稳舒服的。朝8晚5，下班可以随时健身、打球、看电影，但产业链夕阳西下，也无法忽视。互联网领域发展很快，但传统领域还是应用相对较老的技术。我很慌。我想学点新东西，也许十年后二十年后还能用上我的专业背景，做点特别的事情。
于是开始写文章，追求工作之外的价值。
想去读博，也许可以当老师，不行也可以想办法去做科研。想换专业读研，国内要考，国外太贵。想转行。
找了一些朋友聊，但做决定的只有自己。
我选择了转行，以“想要去改变世界，而不是给改变世界的人盖房子”为精神动力。
然后就离职了，去到了另一个城市，没有明确的职业规划，只是认准了一个方向：Python。没有其他。
说句后话，不到万不得已尽量别裸辞，一定要把辞职后的路想清楚。像我这样稀里糊涂辞职会遇到很多问题。
03
如何转行
来了杭州之后，租了个自如，买了一堆python相关的书籍和一台新的Mac Pro，也不知道该走向何方。
学语法学基础
买了《笨办法学python》和《python基础教程》，这个其实是离职前后就大略看过了。但是你懂的，python基础语法容易，进阶玩法还是很难的。
怎么学都会觉得浮在表面，不知道在干啥。后来在慕课网找到个高效编程的免费课程，对照着学完了一遍，并notebook挨个实践，后来就放GitHub了。
转行的人都懂，学了再多这种基础也不知道可以用来干嘛，就像我们在学高数、概率论和线性代数一样。后来就频繁逛知乎搜集一切对自己有用的资源。
焦虑开始首现。
一天在小区跑步就想：我要做个博客，文章就记录我学习的东西。
学Web开发
于是，进入了学习的第二阶段，学习怎么做博客。
光看大家的博客文章是很难学到整体认识的，所以要买一本好书。选定了《Flask Web开发：基于Python的Web应用开发实践》。事后觉得这本是真的好，推荐指数五颗星。
然后半个月过了一遍这本狗书。转行的生活就是这样，除了学习就是吃喝拉撒。前半部分特别仔细，去理解思路和代码，后半部分就只顾得上思路了。期间也学习了Git，开始用GitHub。一章一章过这本书，觉得写的真好，再次推荐。虽然基本上照搬书上的代码，但要走通还是有很多坑，频繁参考了GitHub的issues。不过特别坑的是，我买的纸质书是1.0版本的，GitHub上作者已经更新成2.0版本了，直到某一章我死都调不通，提了个issue，还是原作者指出来是版本问题。
在这个过程中，Git主要是从菜鸟教程上学到，实践过程中也反复参考了廖雪峰老师网站的git教程。两者都足够全面，二选一即可。
跑通了狗书之后，发现最终做出来的效果不是我想要的风格，我不需要这么多复杂的功能，也不需要交互。又没能力修改这套框架去定制化实现我想要的博客风格。
然后了解到GitHub Pages写博客，这个就比较容易了，folk了个自己喜欢的模版，同时学习了下Html、CSS，改成了自己喜欢的样子。话不多说
网页开发涉及的Html和CSS主要也是从菜鸟教程上学的，偶尔也去w3schools看看。
以上呢，总结下来，最推荐的就是菜鸟教程了，该有的都有。
博客有了，我要写什么呢？
学数据分析
接着进入到了第三阶段。在离职后去杭州的高铁上，第一次搜到了numpy这个东西，有点数学的意思，看了一篇教程。这个时候我还从未听说过数据分析，更别说算法、数据科学家这些时髦词汇。
要做什么，也是通过不断地浏览知乎确定的。搜python的应用，很难跳过数据分析，看过相关概念后，感觉还不错，用数学办法来解决问题。有点心动了，认为数据分析这个方向其实是把python当工具用，这个比完全依靠python做开发更容易入门。当然，真实原因其实是python研发对我这样0基础的人来说太难了。至少，入门，真的真的太难了。
又开始逛知乎，怎么去学这套东西。看了很多高赞的帖子，挑出来合适自己的办法，最后选了dataquest。它的特点是编程学习而不是跟视频，对我来说通过视频学习总是抓不到重点，还是看材料学好。
然后花了一个月时间学完了整个Data Scientist – Python路线，中间少数跳跃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c178dd38ab6d0995b49daf6128de3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644d6d215a143914044d73148f6c1ea0/" rel="bookmark">
			linux select 进程阻塞,程序中用sleep和select阻塞休眠的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序调用sleep就是放弃cpu执行，进入阻塞状态，但是sleep的秒数过后，有可能有很多进程或线程在竞争cpu，而且优先级都比当前程序高，导致当先进程或线程无法立即执行，这是导致sleep不准确的一个原因。
gnu里介绍sleep:
The function sleep gives a simple way to make the program wait for a short interval. If your program doesn’t use signals (except to terminate), then you can expect sleep to wait reliably throughout the specified interval. Otherwise, sleep can return sooner if a signal arrives; if you want to wait for a given interval regardless of signals, use select (see Waiting for I/O) and don’t specify any descriptors to wait for.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644d6d215a143914044d73148f6c1ea0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bf770c590b392b0914aefc259d8319/" rel="bookmark">
			2021-05-08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初级
1.表达式[1, 2, 3]*3的值为_[1,2,3,1,2,3,1,2,3]_。
2.表达式3 in [1, 2, 3, 4]的值为____True______。
表达式“[3] in [1, 2, 3, 4]”的值为_False__。
3.使用列表与整数的乘法生成包含10个数字5的列表，可以写为__[5]*10____。
4.任意长度的非空列表中最后一个元素的下标为____-1__| l-1____。
5.表达式list(range(1, 10, 3))的值为__[1,4,7]________。
表达式list(range(10, 1, -3))的值为_[10,7,4]__。
表达式list(range(5))的值为__[0,1,2,3,4]__。
6.列表的__remove_方法删除首次出现的指定元素，如果列表中不存在要删除的元素，则抛出异常。
7.假设列表对象a的值为[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]，那么切片：
a[3:7] = _[6, 7, 9, 11]__;
a[:5:2] =_[3,5,7]_；
a[-5:] = __[9, 11, 13, 15, 17]__；
a[-7:-2:2] =__[6,9,13]__
a[:5:-1] = _[17,15,13,11]___
a[8:-9:-1] = _[5, 6, 7, 9, 11, 13, 15]_的逆序___________
sorted([5, 6, 7, 9, 11, 13, 15],reverse=True) ---&gt;排序完成后再逆序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54bf770c590b392b0914aefc259d8319/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7913fd2a38942980111b22742b81f0/" rel="bookmark">
			/opt/MegaRAID/MegaCli/MegaCli64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://cheatography.com/richardjh/cheat-sheets/lsi-logic-megaraid/
要求和一般信息 DELL的PowerEdge RAID控制器（PERC）是一种特殊的LSI Logic SAS / SATA RAID控制器，因此名为MegaCli的LSI管理实用程序也适用于该控制器。对于PERC4和PERC3等较旧的控制器，请参考 http://linux.dell.com/storage.shtml（关键字DellMgr）。 MegaCli可用于Linux，DOS，Windows，Netware和Solaris。 您可以从LSI网站（搜索MegaRAID SAS）获得它，或在以下位置下载它： http : //www.lsi.com/support/downloads/megaraid/miscellaneous/linux/1.01.40_Linux_Cli.zip。 在ZIP文件中，您将找到一个包含MegaCli和MegaCli64二进制文件的RPM存档（将安装到/ opt / MegaRAID / MegaCli）。 MegaCli约定 适配器参数-aN 参数-aN（其中N是从零开始的数字或字符串ALL）指定PERC5 / i适配器ID。如果只有一个控制器，可以安全地使用ALL而不是特定的ID，但是建议您将ID用于所有更改RAID配置的操作。 物理驱动器参数-PhysDrv [E：S] 对于在一个或多个虚拟驱动器上运行的命令，将使用-PhysDrv [E：S]参数，其中E是驱动器所在的机柜设备ID，S是插槽号（从零开始）。您可以使用“ MegaCli -EncInfo -aALL”获取机柜设备ID。E：S语法还用于在创建新的RAID虚拟驱动器时指定物理驱动器（请参阅5）。 虚拟驱动器参数-Lx 参数-Lx用于指定虚拟驱动器（其中x是从零开始的数字或字符串all）。 收集信息 适配器信息 MegaCli -AdpAllInfo -aALL 配置信息 MegaCli -CfgDsply -aALL 活动信息 MegaCli -AdpEventLog -GetEvents -f events.log -aALL &amp;&amp; cat events.log 机箱信息 MegaCli -EncInfo -aALL 虚拟驱动器信息 MegaCli -LDInfo -Lall -aALL 物理驱动器列表 MegaCli -PDList -aALL 物理驱动器列表 MegaCli -PDInfo -PhysDrv [E：S] -aALL 备用电池信息 MegaCli -AdpBbuCmd -aALL 控制器管理 静音警报 MegaCli -AdpSetProp AlarmSilence -aALL 禁用闹钟 MegaCli -AdpSetProp AlarmDsbl -aALL 启用警报 MegaCli -AdpSetProp AlarmEnbl -aALL 虚拟驱动器管理 创建RAID 0、1、5驱动器 MegaCli -CfgLdAdd -r（0 | 1 | 5）[E：S，E：S，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f7913fd2a38942980111b22742b81f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36898c366eacefc84e958be9dbf4eb96/" rel="bookmark">
			实验--异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
在新冠肺炎疫情防控常态化形势下，核酸检测为疫情应对与处置发挥了重要的技术支撑作用，人们外出前经常需要先进行核酸检测。现为检测机构设计一个处理被检人员信息的管理系统，请定义一个类存储被检人员信息，要求：
（1）分别定义身份证号非法异常类、年龄非法异常类和新冠肺炎病毒阳性异常类；
（2）需要保存的隐私信息有身份证号、姓名、年龄、检测结果；
（3）定义构造方法初始化对象属性；
（4）提供属性访问方法；其中身份证号属性值的设置方法定义时，如果身份证号的前17位出现非数字，应抛出身份证号非法异常；其中年龄属性值的设置方法定义时，如果年龄不在1~150范围内，应抛出年龄非法异常；
（5）定义一个诊断方法，用于输出每个人的信息。当某人的检测结果为“阳性”时，应抛出新冠肺炎病毒阳性异常，并输出“隔离治疗”；
（6）分别用下列数据测试被检人员信息类，合理处理可能出现的异常，并输出“新冠肺炎检测管理信息系统V1.0”：
53010219200508011Z 张三 18 阴性
1X0701199310302288 李四 60 阴性
520302198912097945 王五 151 阴性
42092219731015461X 赵六 20 阳性
注：如果认为有必要，可以增加其他的成员方法或构造方法来辅助完成任务。何时触发异常、如何处理异常可自行决定。
下面展示一些 内联代码片。
思路，自定义定义三个异常类 1.ageException extends Exception 2.idException extends Exception 3.resException extends Exception 测试类书写，三个异常类可定义在测试类内部 下面是实验代码 供参考 有误之处，欢迎大佬评论或私信指正 1.ageException extends Exception public class ageException extends Exception{ public ageException(String s) { super(s); } public ageException() { super(); } } 2.idException extends Exception public class idException extends Exception{ public idException(String s) { super(s); } public idException() { super(); } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36898c366eacefc84e958be9dbf4eb96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cbadd8fbf059cf63f96dc5117c86e55/" rel="bookmark">
			iphone怎么连接itunes相关解锁教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用手机时候，连续多遍输入密码错误，就会出现已停用的提示，就比如iphone当你输入密码错误时，就会提示要时隔多久才能在次输入，而如果多遍都错误的话，就会被停用，那这个时候怎么解决呢，有一种方式是连接itunes解锁，小编分享相关教程。
iPhone已停用连接iTunes处理办法
1、首先把iPhone手机先关机。如果按电源键没有效的话，请同时按住Home键和电源键，等待大约10秒后手机会自动关机;
2、首先启动你的电脑端iTunes，将UsB数据线的一头连接上电脑，按住Home键，然后将数据线另一头插入手机，这个过程请不要松开Home键;
3、在手机屏幕看到连接iTunes提示时，松开Home键;
4、电脑端的iTunes将会跳出：“iTunes已检查到一个处于恢复模式的iPhone。您必须恢复此iPhone，然后再配合iTunes使用它”;
5、接下来你就可以使用iTunes恢复你的手机了!恢复成功后，你可以重头同步备份恢复你的通讯录和设置。
以上就是iphone已停用连接itunes怎么解锁的全部内容，希望以上内容能帮助到朋友们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea93684537fca21c4bb76bc846ea4c0b/" rel="bookmark">
			不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接.中断与此服务器或共享资源的所有连接,然后再试一次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在连接共享文件夹时报错 不允许一个用户使用一个以上用户名与服务器或共享资源的多重连接.中断与此服务器或共享资源的所有连接,然后再试一次 断开连接命令 net use * /del /y 再重新连接共享文件夹即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4d1bc063331ade902e739bec79c6993/" rel="bookmark">
			【selenium元素定位】Python使用selenium定位shado-root的元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;article&gt; &lt;h2 class="title"&gt;抓取元素&lt;/h2&gt; &lt;div class="content"&gt; &lt;p class&gt;文章正文&lt;/p&gt; &lt;/div&gt; &lt;/article&gt; &lt;script&gt; var content = document.querySelector('.content'); var root = content.attachShadow({mode: 'open'}); root.innerHTML = '&lt;p class="real_content" style="color: red"&gt; 抓不到的文字！&lt;/p&gt;' &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 问题：想获取文字：抓不到的文字！ # 思路一： # 一般采取selenium的xpath来获取元素 from selenium import webdriver web = webdriver.Chrome('../chromedriver.exe') web.get('http://localhost:63342/test01/h1.html') content = web.find_element_by_xpath('//p[@class="real_content"]') print(content) print(content.text) web.close() web.quit() # 结果没有获取到元素对应的值 控制台打印信息为： &lt;selenium.webdriver.remote.webelement.WebElement (session="510e3aeb9de727a880169c1450f94756", element="700174b1-8ccd-4608-8804-8b67d4af8bb2")&gt; # 思路二：使用lxml from lxml import etree f = open('h1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4d1bc063331ade902e739bec79c6993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6137694453474ab45e8ed90b973585a5/" rel="bookmark">
			AttributeError: module ‘sip’ has no attribute ‘setapi’的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考：https://blog.51cto.com/4292565/2451307 pip install matplotlib后报错：AttributeError: module ‘sip’ has no attribute 'setapi’的解决办法：
将
import matplotlib.pyplot as plt 改为
import matplotlib matplotlib.use('TkAgg') import matplotlib.pyplot as plt 把matplotlib的backend从Agg配置为TkAgg
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a563090eca30451cb03175e7c2a6f419/" rel="bookmark">
			python3爬虫——贴吧实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学者之贴吧爬虫 一、思路二、步骤1.引入库2.载入网页数据3.分析结构提取信息4.将结果写入txt文件中 三、封装四、总结 一、思路 明确目的及需求，以 剑来吧 为例。
本次实例练习准备爬取“剑来吧”每个帖子的标题、帖子链接、发帖作者、发帖时间、回帖数量，那么拿到网页，二话不说先进入开发者模式先观察html文档结构——找规律。
因为直接在网页源码上看很难看出结构特征，可以将源码粘贴到工作区排版后再进一步观察，很容易发现每个帖子都在对应的一个 li标签 内。
&lt;li class=" j_thread_list clearfix thread_item_box" data-field='{&amp;quot;id&amp;quot;:7330657625,&amp;quot;author_name&amp;quot;:&amp;quot;nicloste&amp;quot;,&amp;quot;author_nickname&amp;quot;:null,&amp;quot;author_portrait&amp;quot;:&amp;quot;tb.1.13e78be1.hhmhKGZZ_b3PPalBqMlM-w&amp;quot;,&amp;quot;first_post_id&amp;quot;:139108722117,&amp;quot;reply_num&amp;quot;:3,&amp;quot;is_bakan&amp;quot;:null,&amp;quot;vid&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;is_good&amp;quot;:null,&amp;quot;is_top&amp;quot;:null,&amp;quot;is_protal&amp;quot;:null,&amp;quot;is_membertop&amp;quot;:null,&amp;quot;is_multi_forum&amp;quot;:null,&amp;quot;frs_tpoint&amp;quot;:null}' data-tid='7330657625' data-thread-type="0" data-floor='1''&gt; &lt;div class="t_con cleafix"&gt; &lt;div class="col2_left j_threadlist_li_left"&gt; &lt;span class="threadlist_rep_num center_text" title="回复"&gt;3&lt;/span&gt; &lt;/div&gt; &lt;div class="col2_right j_threadlist_li_right "&gt; &lt;div class="threadlist_lz clearfix"&gt; &lt;div class="threadlist_title pull_left j_th_tit "&gt; &lt;a rel="noreferrer" href="/p/7330657625" title="老是讽刺大骊铁骑的，真的没脑子，他们是低品武夫啊" target="_blank" class="j_th_tit "&gt;老是讽刺大骊铁骑的，真的没脑子，他们是低品武夫啊&lt;/a&gt; &lt;/div&gt; &lt;div class="threadlist_author pull_right"&gt; &lt;span class="tb_icon_author " title="主题作者: nicloste" data-field='{&amp;quot;user_id&amp;quot;:1184496600}' &gt;&lt;i class="icon_author"&gt;&lt;/i&gt;&lt;span class="frs-author-name-wrap"&gt;&lt;a rel="noreferrer" data-field='{&amp;quot;un&amp;quot;:&amp;quot;nicloste&amp;quot;,&amp;quot;id&amp;quot;:&amp;quot;tb.1.13e78be1.hhmhKGZZ_b3PPalBqMlM-w&amp;quot;}' class="frs-author-name j_user_card " href="/home/main/?un=nicloste&amp;ie=utf-8&amp;id=tb.1.13e78be1.hhmhKGZZ_b3PPalBqMlM-w&amp;fr=frs" target="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a563090eca30451cb03175e7c2a6f419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3cdefc51ed972ed2b372b1635b2469/" rel="bookmark">
			linux下web系统性能测试工具,Web Service性能测试工具比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
希望选择一款Web Service性能测试工具，能真实模拟大量用户访问网站时的请求，从而获取服务器当前的请求处理能力(请求数/秒)。 以微信服务器为例，每个用户用独立的登录token，做各种操作，比如刷消息、发消息、看朋友圈等。
希望该性能测试工具符合如下要求：
测试脚本能力，最好是Python/Ruby等最常用的
每个并发实例能使用不同参数
CLI启动测试，这对自动化测试很重要
Session支持，也就是第一个请求的响应，能用于后续请求的参数。
单个结点的并发数量高。
分布式支持，不受限于单个结点的计算能力。
性能测试工具选手：
Gatling
Gatling是一款基于Scala 开发的高性能服务器性能测试工具，它主要用于对服务器进行负载等测试，并分析和测量服务器的各种性能指标。Gatling主要用于测量基于HTTP的服务器，比如Web应用程序，RESTful服务等，除此之外它拥有以下特点：
支持Akka Actors 和 Async IO，从而能达到很高的性能
支持实时生成Html动态轻量报表，从而使报表更易阅读和进行数据分析
支持DSL脚本，从而使测试脚本更易开发与维护
支持录制并生成测试脚本，从而可以方便的生成测试脚本
支持导入HAR(Http Archive)并生成测试脚本
支持Maven，Eclipse，IntelliJ等，以便于开发
支持Jenkins，以便于进行持续集成
支持插件，从而可以扩展其功能，比如可以扩展对其他协议的支持
开源免费
object Search {
val feeder = csv("search.csv").random // 1, 2
val search = exec(http("Home")
.get("/"))
.pause(1)
.feed(feeder) // 3
.exec(http("Search")
.get("/computers?f=${searchCriterion}") // 4
.check(css("a:contains('${searchComputerName}')", "href").saveAs("computerURL"))) // 5
.pause(1)
.exec(http("Select")
.get("${computerURL}")) // 6
.pause(1)
}
统计图：
nGrinder
官网很卡，真的很卡...zzz...
http://naver.github.io/ngrinder/
nGrinder是一个基于 Grinder 开发的一个非常易于管理和使用的性能测试系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c3cdefc51ed972ed2b372b1635b2469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eae684dbd5e15fea01bbe14f97b90a5/" rel="bookmark">
			ajax请求步骤和封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 首先带大家了解一下什么是ajax
ajax(异步javascript xml) 能够刷新局部网页数据而不是重新加载整个网页。
那么如何使用ajax呢？
第一步创XMLHTTPRequest对象 var xhr = new XMLHttpRequest(); 第二步使用open方法设置和服务器的交互信息 //get请求方式
xhr.open('get','getStar.php); //post请求方式
xhr.open('post','getStar.php); 第三步发送请求 xhr.send();
第四步注册事件 xhr.onreadystatechange = function () {
if (xhr.readyState4 &amp;&amp;xhr.status200) {
}
第五步跟新事件 xhr.onreadystatechange = function () {
if (xhr.readyState4 &amp;&amp;xhr.status200) {
//步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
console.log(xhr.responseText);//输入相应的内容
}
完整版的get请求步骤 //步骤一:创建异步对象 varxhr = new XMLHttpRequest(); //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端 xhr.open('get','getStar.php?starName='+name); //步骤三:发送请求 xhr.send(); //步骤四:注册事件 onreadystatechange 状态改变就会调用 xhr.onreadystatechange = function () { if (xhr.readyState==4 &amp;&amp;xhr.status==200) { //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的　console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eae684dbd5e15fea01bbe14f97b90a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adeaa85465e770c81af44ae903035df5/" rel="bookmark">
			symbol类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 symbol是es6新增的第6中原始类型表示一个不可重复的值，不是函数，不能通过new调用
一下 我们用typeof来检测一下看一下他是什么类型
let a = Symbol(); console.log(typeof s) //"symbol" 解析:以上代码中，这个let变量a就是一个毒医无二的值。typeof检测结果，这个变量a是Symbol数据类型，并不是字符串类型或其他的类型
注意点 上面说过sybol函数不能用new来调用，不然会报错啊
下面我们看看看symbol函数是否可以接受字符串微参数，表示symbol实列
let a1 = Symbol（"d1"） let a2 = Symbol("d2") a1 //Symbol(d1) a2 //Symbol(d2) 注意点：以上代码中a1和a2是两个symbol的值。如果不加参数的话，他们会在控制台输出全部是Symbol ,
不好区分啊，有了参数之后就会为他们添加描述一样，输出的时候就可以分辨清楚，到底是哪个是哪个的值
假如symbol的参数是对面 调用toString方法 会怎么样是否能生成一个Symbol的值呢？让我们拭目以待 下面带大家看看和一起分析一下 行吧 那就看看一下代码
const obj ={ toString(){ return "qaqaqa" } } const sl = Symbol(obj); sl// Symbol 解析:Symbol函数的参数只能代表当前Symbol的值进行描述，所有相同常参数Symbol函数的返回的值是不相等的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ded2b378b7247de3461d0ed2e85706/" rel="bookmark">
			错误: 找不到或无法加载主类 com.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：错误: 找不到或无法加载主类 com.
根据个人经验的一种办法，仅供参考：
1、
2、
按步骤勾选上，重新执行即可成功，如果不行的话，原因应该不一样，请另寻他法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502371a913d2b00b065f0378797903cc/" rel="bookmark">
			电脑的Mac地址怎么查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面给大家介绍的是怎么查看电脑的Mac地址的方法与步骤，喜欢的朋友可以一起来学习更多的电脑常识教程。
第一种方法：利用dos命令查看Mac地址：
1、点击“开始”菜单，在“搜索程序和文件”输入框，输入“cmd”(会找到进入dos命令的cmd程序)，然后回车。快捷方式“WIN+R”，在输入cmd。
2、回车后，弹出命令符窗口，输入“ipconfigall”，然后进行回车，就会看到一连串的返回信息。
3、在返回信息中，找到“本地连接”其中的物理地址(Physical Address)，见图片，即为本机的mac地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8785c83c73a4701eef208ae1a4064677/" rel="bookmark">
			【转】log4j 设置将生成的日志进行gz压缩并删除过期日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自https://www.cnblogs.com/haw2106/p/10116164.html
1、准备jar :log4j-1.2.17.jar,commons-logging-1.2.jar，这2个就可以了，其他关于日志的jar包就不要加进来了，在优先级上会有冲突。
2、定义一个类，继承RollingFileAppender类，这个类是按照日志大小滚动生成日志，并把日志编号。我就在这个类基础上重新写了其中的一些方法，加上日期和删除功能，稍加改动就行了。
package com.hm.sage.bigdata.spark.log; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.zip.GZIPOutputStream; import org.apache.log4j.RollingFileAppender; import org.apache.log4j.helpers.CountingQuietWriter; import org.apache.log4j.helpers.LogLog; public class RoolingAndDateFileAppender extends RollingFileAppender { private String datePattern;//日期格式 private String dateStr = "";//文件后面的日期 private String expirDays = "1";//保留最近几天 private String isCleanLog = "true";//是否清日志 private String maxIndex = "100";//一天最多几个文件 private File rootDir;//父目录的抽象路径名 private String gzFormat = "gz";//压缩格式 /** * 设置日期格式 * * @param datePattern */ public void setDatePattern(String datePattern) { if (null !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8785c83c73a4701eef208ae1a4064677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f725d3d36342bf7db0150b357ac174cb/" rel="bookmark">
			js中的展开运算符(扩展运算符)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、...对于数组的用法二、...在函数中的使用三、...对于对象的使用总结 前言 我们现在经常接触到js的一个…运算符，被称为展开运算符由于我对这个不是很熟练所以，打算写下一篇小文章记录一下
提示：以下是本篇文章正文内容，下面案例可供参考
一、…对于数组的用法 let arr=[1,2,3] // 展开一个数组 console.log(...arr) console.log("-----------"); // 复制一个数组，也称为拷贝数组 let arr2=[...arr] arr2.push(4); // 并且不会对arr造成影响 console.log("arr",arr); console.log("arr2",arr2); console.log("-----------"); // 连接数组 let arr3=[...arr,...arr2] console.log(arr3); 二、…在函数中的使用 //对于不确定传多少个值也可以使用扩展运算符 function add(...numbers) { return numbers } // 这样在你传值的时候可以一直增加，从此再也不用关心形参的多少！ console.log(add(1,2,3,4,5)); 如果我们要对这个numbers操作，需要了解一些js对于数组的操作，reduce，filter巴拉巴拉的，有时间也会更新一篇的。
三、…对于对象的使用 首先强调一点，扩展运算符不能直接用于对象，也就是不用去想展开对象
虽然代码上并没有报错，但是控制台并不能输出
所以我们可以构造字面量对象时使用展开语法
var obj1 = { foo: 'yuan', x: 42 }; var obj2 = { foo: 'li', y: 13 }; // 克隆对象一定要加上{} var clonedObj = { ...obj1 }; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f725d3d36342bf7db0150b357ac174cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d656a85d3c58dd21ab35a90af990e3/" rel="bookmark">
			distribute by、group by、sort by、order by的相关释义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、group by
把相同的key发送到同一个reduce分区中，后面必须做聚合操作
2、distribute by
把相同的key发送到下游同一个reduce分区中，只是做数据分散
3、order by
全部排序，把所有数据拉到同一个节点进行排序，数据量大的时候可能会造成内存溢出
4、sort by
区内排序，对每个reduce分区内的数据进行排序，不保证全局有序
5、cluster by
如果distribute by和sort by的字段相同时，只用cluster by就可以完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c567d0cfb8bcc18ba3bcb2a08d2502f/" rel="bookmark">
			leetcode350--- 两个数组的交集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode350— 两个数组的交集 关键字：哈希表，双指针
题目 给定两个数组，编写一个函数来计算它们的交集。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
我们可以不考虑输出结果的顺序。
进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii
方法 1.哈希表 新建一个列表用于储存交集的元素。对数组1遍历建立字典，字典的键为数组的元素值，对应的值为该元素在字典中出现的次数。遍历数组2，查找数组2的值是否在字典的键中出现且对应次数是否大于0，如果出现则加入列表并且将对应次数减1。返回列表 代码如下：
class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: hashmap = {} result = [] for d in nums1: if d in hashmap.keys(): hashmap[d] += 1 else: hashmap[d] = 1 for j in nums2: if j in hashmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c567d0cfb8bcc18ba3bcb2a08d2502f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ebeb217e023c1ca18b81918a55ad73/" rel="bookmark">
			linux将用户加入多个组,Linux 用命令把同一个用户加入多个组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在RHEL7.2系统下用usermod 命令可把某用户添加进多个附加组，默认情况下，一次性添加多个附加组可用以下方式来添加：
usermod -G 附加组1,附加组2，...,附加组N 用户名
【实例】
[[email protected] ~]# useradd mk
[[email protected] ~]# id mk
uid=1159(mk) gid=1159(mk) 组=1159(mk)
[[email protected] ~]# groupadd mk1
[[email protected] ~]# groupadd mk2
[[email protected] ~]# groupadd mk3
[[email protected] ~]# usermod -G mk1,mk2,mk3 mk
[[email protected] ~]# id mk
uid=1159(mk) gid=1159(mk) 组=1159(mk),1161(mk1),1162(mk2),1163(mk3)
但在添加之后若再对该用户添加另外附加组时，使用
usermod -G 附加组名 用户名
会覆盖该用户的之前的附加组。此时，可在usermod 命令中添加一个参数 -a 来实现。
usermod -a -G 附加组名 用户名
【实例】
[[email protected] ~]# id top
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ebeb217e023c1ca18b81918a55ad73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bafa03fd8272f7d362d0ecc19e6eac0/" rel="bookmark">
			linux内核引用FILE指针,探秘linux-文件管理(inode理解)及管道和IO重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件管理
1、Linux系统上各主要目录的简介
/ 根,所有文件的起点
bin 存放操作系统启动时的引导程序,以及操作系统内核文件
boot 存放操作系统启动时的引导程序,以及操作系统内核文件
dev 存放设备文件和特殊文件(如字符设备)
etc 存放配置文件的目录
home 普通用户的家目录默认都在此目录下
lib 存放系统库和内核模块文件 (/lib/modules)
lib64 存放x86_64位系统上共享库文件
media 系统上提供的设备挂载点
misc 系统上提供的设备挂载点
mnt 系统上提供的设备挂载点
opt 第三方应用程序的安装位置
proc 用于输出内核与进程信息相关的虚拟文件系统
root root用户的家目录
sbin 存放管理员用户可执行的相关二进制程序文件目录,不能单独分区,操作系统启动时会用到该目录下的相关程序
selinux selinux相关的安全策略等信息的存储位置
srv 系统上运行的服务用到的数据
sys 用于输出系统上硬件设备相关信息的虚拟文件系统
tmp 临时文件存储位置
usr 第三方软件的安装目录,该目录下有另一套完整的目录文件结构,包括有bin、sbin、local、include、而local又有bin、sbin等
2、inode的认识总结
文件系统inode的一些原理：
文件系统在组织文件存储时，遵循一定的存储规则。在文件系统创建时，会将底层存储设备(硬盘)逻辑划分为一个一个的磁盘(block)，一般一个block大小默认为4096个字节，也就是4K，这个值在ext系列文件系统上支持1024、2048、4096，可以在创建文件系统的时候指定(利用mke2fs -b SIZE来指定block大小，一旦指定后，后期不能更改)，然后将多个磁盘块划分为一个个的块组，一个分区里面有有多个块组，但一个分区里面会有一部分block用来存储整个分区的一些属性状态的超级块，(用tune2fs -l DEVICE可以查看到分区超级块里面存储的信息，如分区卷标、分区的特性、挂载时的默认选项、总共有多少inode、总共多少block、每个块组有多少block、每个块组有多少inode等信息)。
linxu上文件有两部分组成，一个是文件的元数据，一个是文件的数据本身，两部分分开存储，文件系统划分出来的磁盘块有部分用来存储inode table，有部分用来存储数据本身，文件的数据至少占据1个block大小，即使数据只有1byte，如果blick大小为4K，那么该文件数据占用的磁盘空间也是4K。inode table里面存储每每个文件的inode条目，每个条目在在同一个文件系统内部有一个唯一的ID号，一个inode条目记录一个文件的元数据信息，这些信息包括：该文件的权限、属主属组、大小、时间戳(但是inode条目里面是没有存储该文件的文件名的，这点要注意，文件名是存储在目录文件的数据块中)。
inode条目还存储了该文件的数据所在的block的指针信息，也就是该文件数据存在哪个磁盘块上，一般一个inode条目的指针部分，分为直接指针、间接指针、二重指针、三重指针…直接指针在ext系列文件系统上有12个，一个直接指针指向一个磁盘块，故利用直接指针可以存储的数据大小，为4K*12。当数据超过48K时，就需要利用间接指针指向的数据区域来存储了，所谓间接指针就是inode的数据块指针指向了一个block块，但这个block本身存储的不是文件数据本身，而是存储的指针信息(在ext文件系统上，一个指针信息占用4字节的空间，故一个block可以有1024个指针信息)，然后，由这个block块里面的指针指向具体文件数据存储磁盘块，这样，利用间接指针可以存储的文件大小为1024*4K。要存储的文件超过了间接指针能指向的范围，则需要用到二重指针，二重指针是指，inode条目里面的指针指向一个block，该block存储的依然是指针信息，一个指针指向一个block，而被指向的这个block存储的依然是指针信息，具体是这样：inode条目–&gt;block(存的是指针)–&gt;block(存的是指针)–&gt;block(存的是文件数据)，这样二重指针所能存储的文件数据大小就是1024*1024*4K，以此类推。
直接指针：inode条目–&gt;block(存的是文件数据)
间接指针：inode条目–&gt;block(存的是指针)–&gt;block(存的是文件数据)
二重指针：inode条目–&gt;block(存的是指针)–&gt;block(存的是指针)–&gt;block(存的是文件数据)
三重指针：inode条目–&gt;block(存的是指针)–&gt;block(存的是指针)–&gt;block(存的是指针)–&gt;block(存的是文件数据)
利用直接指针能存储的文件大小：12*4K
利用间接指针能存储的文件大小：1*1024*4K (一个inode条目只有1个间接指针)
利用二重指针能存储的文件大小：1*1024*1024*4K
利用三重指针能存储的文件大小：1*1024*1024*1024*4K
而对于文件和目录的存储，在文件系统存储时是不一样的，文件存储中，数据部分存的是文件本身的数据文件，而目录文件，数据部分存储的是目录下面文件名与该文件的inode号的对应关系
故当我们访问某个文件时，文件系统内部寻找的过程大致是这样的：(以寻找/etc/issue为例)
首先找/根，因为根是自启动的，可以知道自己是在哪个inode上，找到/的inode后，inode指向了/下相应的数据存储的block，该block内部存储了/下一级子目录的名称和inode对应关系(当然如果/下有直接的文件，那某些数据块上存储的就是文件的数据)，通过对应关系，就找到了etc所在的inode，然后通过etc的indode，就找到了etc下面的文件和目录的数据存储的block，进而找到了issue文件的数据
3、文件类型和软硬链接的介绍
ls -l 中查看到的权限字段的信息中第一位即表示该文件的类型，常见的文件类型有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bafa03fd8272f7d362d0ecc19e6eac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75ff29f19348a88d1abcc1eb542ee2f/" rel="bookmark">
			JVM的四种内存屏障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、为什么要有内存屏障2、硬件上面的内存屏障3、Java里面的四种内存屏障4、使用内存屏障保存Volatile的有序性4.1 单线程下的指令重排序4.1 多线程下的指令重排序 1、为什么要有内存屏障 为了解决cpu，高速缓存，主内存带来的的指令之间的可见性和重序性问题。
我们都知道计算机运算任务需要CPU和内存相互配合共同完成，其中CPU负责逻辑计算，内存负责数据存储。CPU要与内存进行交互，如读取运算数据、存储运算结果等。由于内存和CPU的计算速度有几个数量级的差距，为了提高CPU的利用率，现代处理器结构都加入了一层读写速度尽可能接近CPU运算速度的高速缓存来作为内存与CPU之间的缓冲：将运算需要使用的数据复制到缓存中，让CPU运算可以快速进行，计算结束后再将计算结果从缓存同步到主内存中，这样处理器就无须等待缓慢的内存读写了。就像下面这样:
每个CPU都会有自己的缓存（有的甚至L1,L2,L3），缓存的目的就是为了提高性能，避免每次都要向内存取，但是这样的弊端也很明显：不能实时的和内存发生信息交换，会使得不同CPU执行的不同线程对同一个变量的缓存值不同。用volatile关键字修饰变量可以解决上述问题，那么volatile是如何做到这一点的呢？那就是内存屏障，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样，java通过屏蔽这些差异，统一由jvm来生成内存屏障的指令
volatile的有序性和可见性
volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；由于内存屏障的作用，避免了volatile变量和其它指令重排序、实现了线程之间通信，使得volatile表现出了锁的特性。
重排序：代码的执行顺序不按照书写的顺序，为了提升运行效率，在不影响结果的前提下，打乱代码运行
int a=1;
int b=2;
int c=a+b;
int c=5;
这里的int c=5这个赋值操作可能发生在int a=1这个操作之前
2、硬件上面的内存屏障 Load屏障，是x86上的”ifence“指令，在其他指令前插入ifence指令，可以让高速缓存中的数据失效，强制当前线程从主内存里面加载数据Store屏障，是x86的”sfence“指令，在其他指令后插入sfence指令，能让当前线程写入高速缓存中的最新数据，写入主内存，让其他线程可见。 3、Java里面的四种内存屏障 LoadLoad屏障：举例语句是Load1; LoadLoad; Load2(这句里面的LoadLoad里面的第一个Load对应Load1加载代码，然后LoadLoad里面的第二个Load对应Load2加载代码)，此时的意思就是，在Load2及后续读取操作从内存读取数据到CPU前，保证Load1从主内存里要读取的数据读取完毕。
StoreStore屏障：举例语句是 Store1; StoreStore; Store2(这句里面的StoreStore里面的第一个Store对应Store1存储代码，然后StoreStore里面的第二个Store对应Store2存储代码)。此时的意思就是在Store2及后续写入操作执行前，保证Store1的写入操作已经把数据写入到主内存里面，确认Store1的写入操作对其它处理器可见。
LoadStore屏障：举例语句是 Load1; LoadStore; Store2(这句里面的LoadStore里面的Load对应Load1加载代码，然后LoadStore里面的Store对应Store2存储代码)，此时的意思就是在Store2及后续代码写入操作执行前，保证Load1从主内存里要读取的数据读取完毕。
StoreLoad屏障：举例语句是Store1; StoreLoad; Load2(这句里面的StoreLoad里面的Store对应Store1存储代码，然后StoreLoad里面的Load对应Load2加载代码)，在Load2及后续读取操作从内存读取数据到CPU前，保证Store1的写入操作已经把数据写入到主内存里，确认Store1的写入操作对其它处理器可见。
4、使用内存屏障保存Volatile的有序性 volatile关键字是通过内存屏障，禁止被它修饰的变量发生指令重排操作
4.1 单线程下的指令重排序 处理器为了提高程序运行效率，可能会对输入代码进行优化，使得程序中各个语句的执行顺序同代码中的顺序不一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。比如：
int i=10;//语句1 int j=10;//语句2 在执行时，有可能对代码进行重排序，比如先执行语句2，再执行语句1。但是如果代码，编程下边这样：
int i=0; int j=0; j++;//语句3 i=j+1;//语句4 这时，语句3和语句4并不会进行重排序。因为语句3和4之间有依赖关系，重排序后会影响结果。
4.1 多线程下的指令重排序 以上说的是单线程的情况，期望结果等于输出结果。下面看多线程的情况，如下代码：
boolean flag=false; private Context context; //线程1 context=loadContext();//语句1 flag=true;//语句2 //线程2 if(flag){ dowork(context); } 如果线程1执行的时候，语句1和语句2进行了重排序，先执行语句2，在还没有执行语句1时，这时线程2 将要执行if，那么就会进入到if语句块中，而context还是null，所以会出错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75ff29f19348a88d1abcc1eb542ee2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafe0fd545f92dc92267e83da71399aa/" rel="bookmark">
			Python打包程序pyinstaller使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用方法 ：pyinstaller 选项 参数 必要参数: scriptname 脚本名称name of scriptfiles to be processed or exactly one .spec-file. If a .spec-file is specified, most options are unnecessary and are ignored.
可靠参数: -h, --help显示帮助信息并退出-v, --version输出版本信息并退出--distpath DIR生成可执行文件存放目录，默认脚本目录下dist文件夹--workpath WORKPATH临时文件存放目录，默认脚本目录下build文件夹--clean清空PyInstaller之前的缓存和临时文件-D, --onedir生成包含可执行文件的文件夹（默认选项）-F, --onefile只生成一个可执行exe文件--specpath DIR生成spec文件的目录（默认当前目录）-n NAME, --name NAME可执行文件exe和spec的名称（默认为第一个脚本的名称） -y, --noconfirm Replace output directory (default:
SPECPATH\dist\SPECNAME) without asking for
confirmation
--upx-dir UPX_DIR Path to UPX utility (default: search the execution
path)
-a, --ascii Do not include unicode encoding support (default:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eafe0fd545f92dc92267e83da71399aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5932efaa0443f1ee8a2b0cc2150223e3/" rel="bookmark">
			[目标检测]CenterNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景性能模型结构与输出解析目标框（后处理）损失函数heatmapregwhloss 模型四元素： 背景模型结构与输出后处理损失函数 背景 目标检测就是识别出图中物体的位置，目前常用物体检测器详尽列出潜在物体的位置并对每个位置进行分类，这比较低效，并且需要额外的后处理。 而centernet，作为一个anchor free模型，将对象bounding box的中心点进行建模,使用关键点估计来找到中心点，并回归到所有其他对象属性，例如大小，3D位置。
与anchor系列模型的区别：
anchor free模型一般通过目标的中心点建模，基于anchor的模型通过预先设置的anchor建模。基于anchor的模型需要设置有关anchor的许多超参数。每个位置的样本数不同： anchor free模型输出特征图上的一个位置只设置一个样本，而基于anchor的检测模型会设置多个样本（同一个位置设置多个不同形状anchor）。正样本的确定方式不同：anchor free模型正样本通过位置确定，基于anchor的检测模型正样本通过IOU来确定 优点：
centernet的输出分辨率大，下采样率只有4（output_stride=4），其他检测模型普遍为8～16。使其对小目标的召回效果比较好。centernet不需要nms，只需要找到heatmap的峰值就好。 缺点：
同一个类别的两个物体的中心点相同，模型只能给出一个物体检测框，原因是因为输出特征图同一个位置只设置一个样本，可以用类似fpn的结构来解决这个问题。 性能 Object Detection on COCO validation
modelbackbonefpsAPCenterNet-DLADLA-342839.2CenterNet-HGHourglass-1047.842.1 模型结构与输出 P代表中心点在原图的位置，R代表输出下采样率，也是输入输出特征图大小的比率。
预处理：将原图通过仿射变换变成512x512，除以255，减均值，除方差。
C: 类别的个数。
keypoint：以热力图的形式出现，预测目标框的中心点，代表该位置是目标中心点的置信度。
解析目标框（后处理） heatmap的峰值的位置就是目标的中心点。将模型heatmap的输出进行通过3x3的卷积核进行最大池化处理，保留局部最大值，然后选择每个类别的topk（100）个像素点，然后通过每个类的topk中（topk x C）选出所有类的topk。通过topk个像素点的位置找到该点对应目标的wh和offset，最后解析出目标框。现在解析出来的目标框的数量是topk个，需要通过阈值（0.3）过滤掉一部分置信度不高的预测结果。 损失函数 当centernet用于普通的目标检测时，其head分为三个部分：heatmap、reg、wh,对应三个损失的计算。
heatmap 目标是输入 I ∈ R W × H × 3 I\in R^{W\times H\times 3} I∈RW×H×3，输出 Y ^ ∈ [ 0 , 1 ] W R × H R × C \hat{Y} \in \left[ 0,1\right]^{\frac{W}{R} \times \frac{H}{R} \times C} Y^∈[0,1]RW​×RH​×C，W和H是输入图片的宽和高，R是输出步长，C是keypoint的类别，比如用COCO做目标检测时,C就等于80。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5932efaa0443f1ee8a2b0cc2150223e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46bd4e3180d05501ecc6e03bc97b7b8/" rel="bookmark">
			EPPlus导出Excel感觉很不错~~~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 导出成为很多系统的必备功能，之前分享过导出PDF的功能，这里来分享一下Excel的导出；
提到Excel导出，NPOI肯定是很多小伙伴的首选，在以往的项目中也用其完成了很多导出需求；对于NPOI，个人感觉使用还是相对比较复杂，填充数据，单元格格式或样式，公式计算等，所以就想着换个库试试；和同事简单的沟通，EPPlus 和 Magicodes.IE 感觉都不错，但从Nuget包的下载量来看，EPPlus明显更胜一筹，而且在当时的业务需求中EPPlus更加合适，所以接下来的分享主要针对EPPlus。
注：EPPlus从版本5开始，如果使用就要求需要商业许可啦，但从业务功能来看，5之前的版本对于绝大多数业务场景够用啦，别排斥，看看之前的版本下载量：
不扯那么多啦，如果小伙伴了解更多关于EPPlus信息，github地址为：https://github.com/JanKallman/EPPlus/wiki。
接下来以平时常用功能为主，和小伙伴分享一下使用。
正文 这里新建一个API项目，针对每个功能单独一个接口进行演示，引入的EPPlus版本为4.5.3.3。
1. 数据填充； EPPlus数据填充很简单，不需要创建行、列，直接定位到单元格赋值即可。两种定位单元格方式，如下：
通过具体行和列的来定位
这种方式定位比较灵活，也是用的比较多的。
代码实现如下：
运行效果：
通过单元格标识来定位
通过单元格标识进行定位，如上图，图中Excel的列标识为字母，行标识为数字，所以第一个单元格的定位可以对应为A1，第二个单元格为B1，以此类推。
代码实现：
运行效果，同样在浏览器中输入对应的接口地址，导出Excel：
2. 公式自动计算； 在以往导出的操作中，关于计算和汇总的数据很多都是在程序中先算好，然后再填充到单元格中，其实使用Excel公式超级方便；
代码实现：
运行效果：
3. 样式设置； 单个单元格指定样式
代码实现：
效果如下：
虽然效果也能实现，但每一个单元格都指定一遍，太麻烦了；下面的范围设置就比较给力；
范围指定样式
代码实现：
运行效果：
设置公共样式，如果所有数据都需要统一的对齐样式，所有单元格都需要边框，可以统一设置；
公共样式直接针对worksheet中的所有单元格设置即可；
代码实现：
运行效果：
4. 合并单元格； 导出数据时，合并单元格是常有的事，我平常用将其分为列合并和行合并两种：
列合并
在我日常开发中，列合并通常在表头用的比较多，所以算是比较固定的格式，直接指定合并的范围即可；
代码实现：
调用：
运行效果：
当然也可以根据需求，动态设置行进行合并；
行合并
行合并主要是针对数据，当连续单元格值相等的情况，通常会要求进行行合并；如上图中前两行的第一个单元格数据都为111，需将其合并。
代码实现：
调用：
运行效果：
5. 自适应列宽和自适应内容 当单元格内容比较多时，通常会用到以下两种方式，如图：
自适应列宽：将字体缩小填充到单元格，单元格列宽不变；
自适应内容：单元格根据内容填充，内容多宽就显示多宽；
代码实现如下：
运行效果如下：
6. 大数据导出 有些导出需求，需要导出大量的数据，如果通过上述内存的方式导出，可能会因为数据量大导致数据处理超时或内存泄露导致导出异常，通常这种需求，会采用异步的方式导出数据；大概步骤如下：
用户点击导出操作，后台生成一条导出记录，即导出任务，包括导出时选择的条件、导出状态等信息；
通过消息队列或者是后台任务的形式，获取到导出任务，得到导出条件，通过后台任务进行导出操作；
保存对应文件，将导出后台任务状态改为已完成；
用户就可以下载生成的文件；
保存文件的代码实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46bd4e3180d05501ecc6e03bc97b7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0adc5f14ded2cfffb72f301d5f189375/" rel="bookmark">
			linux superblock 时间,e2fsck: Bad magic number in super-block_Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ext2/3最重要应该要算超级块了.超级块存储在文件系统的块1(从0开始编号)中,包含了编档系统配置的所有信息,而且用mount命令装载文件系统时,是要检查超级块的,如果不符合要求则会装载失败.
1 获取错误的出错磁盘(或者设备)块的大
tune2fs -l /dev/hda4其实大多数情况下是 1 K.
2介绍怎样读取一个分区的superblock：
(1)首先我们查看一下在磁盘上有哪些分区，通过fdisk -l
这里有三个分区，我们下面查看/dev/sda3(这是一个device file)
(2)从/dev/sda3拷贝1024B-2048B(这就是superblock的位置)到一个叫superblock的文件
这里我们用到了dd这个工具，它在对磁盘进行这样读写操作时非常有用，具体请见man。
bs=1k 每次读写的块大小
skip=1 偏移多少块开始读(这里块为bs=1k,偏移1,表示从1k开始读)
count=1 读的大小(这里表示读1k)
if,of 分别表示从哪里读和写到哪里去。
这里你也许会问为什么要从1k处开始读，并且就读1k的大小呢？下图就是一个分区的物理存储结构：
从图中我们可以看到第一个Block的第一个1k处是存储的Boot Block，而superblock是从1k开始，大小为1k。
(3)查看superblock文件
用vim打开我们刚才从/dev/sda3复制出来的superblock文件，由于是二进制文件，我们在用vim打开之后要用:%!xxd转换成16进制形式。
到这里其实我们已经看到了在磁盘上superblock的形式了。下面我想验证一个这个superblock的正确性。
首先，通过查看/usr/include/linux/ext3_fs.h头文件中的struct ext3_super_block:
(使用sizeof查看int型占用4个字节，vim以16进制打开的文件，每位代表2的4次方，所以表示一个32位需要两位，int型占用4个字节所以需要8位)
我们可以知道在superblock的头上记录着inodes的个数和block的个数，它们分别是32位。
那从superblock中可以看出：
(这里涉及到大数端和小数端的问题，使用vim打开的文本都需要转换，下面是2位2位的转)
inodes_count: 0000 3a04(注意：这里是小数端) –&gt; 043a0000 = 70909952
blocks_count: fdc4 3904 –&gt; 0439c4fd = 70894845
那么该如何验证这个结果呢？linux为我们提供了dumpe2fs这个工具：
dumpe2fs /dev/sda3 |less
我们可以看到如下的输出(一部分)
到这里，有关如果看superblock的方法，这里就全部都讲完了，同样我们可以用dd查看磁盘上任意的部分。
3.mke2fs -n查看superblock
# mke2fs -n /dev/hda5
mke2fs 1.35 (28-Feb-2004)
Filesystem label=
OS type: Linux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0adc5f14ded2cfffb72f301d5f189375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7305578c7e2bd105e265d6a552e57ba/" rel="bookmark">
			WPF属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (一)依赖属性【源码-09DependencyObj】
依赖属性就是一种可以自己没有值，并能通过使用Binding从数据源获得值(依赖在别人身上)的属性。拥有依赖属性的对象被称为“依赖对象”。与传统的CLR属性和面向对象思想相比依赖属性有很多新颖之处。
①：节省实例对内存的开销
②：属性值可以通过Binding依赖在其他对象上。
依赖属性对内存的使用方式
在传统.NET开发中，一个对象所占用的内存空间在调用new操作符进行实例化的时候已经决定了，而WPF允许对象在被创建的时候并不包含用于存储数据的空间(即字段所占用的空间)、只保留在需要用到数据时能够获得默认值、借用其他对象数据或实时分配空间的能力——这种对象就称为依赖对象(DependencyObject)，而这种实时获取数据的能力则依靠依赖属性(DependencyProperty)来实现。在WPF开发中，必须使用依赖对象(DependencyObject)作为依赖属性(DependencyProperty)的宿主，使二者结合起来，才能形成完整的Binding目标被数据所驱动。
public class Student : DependencyObject{ public string Name { get { return (string)GetValue(NameProperty); } set { SetValue(NameProperty, value); } } public static readonly DependencyProperty NameProperty = DependencyProperty.Register("Name",//string类型，用这个参数来指明以哪个CLR属性作为这个依赖属性的包装器 typeof(string), //用来指明此依赖属性用来存储什么类型的值。 typeof(Student));//用来指明此依赖属性的宿主是什么类型，或者说DependencyProperty.Register方法将把这个依赖属性注册关联到那个类型上。} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2555eaa29c114298a49a733bc736599/" rel="bookmark">
			Postgresql、Hologres表结构查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Postgresql、Hologres表结构相关查询语句 1、SQL语句展示2、相关字段说明3、其他结构查询语句展示3.1、3.2、统计每张表的分区数量3.3、 1、SQL语句展示 SELECT DISTINCT a.attnum as num, a.attndims as dimension_array, a.attname as name, t.typname as data_type, concat_ws('',t.typname,SUBSTRING(format_type(a.atttypid,a.atttypmod) from '\(.*\)')) as type_complete, a.attnotnull as notnull,a.attlen AS length, a.atttypmod AS lengthvar,com.description as comment, coalesce(i.indisprimary,false) as primary_key, def.adsrc as default_value FROM pg_attribute a JOIN pg_class pgc ON pgc.oid = a.attrelid LEFT JOIN pg_index i ON (pgc.oid = i.indrelid AND i.indkey[0] = a.attnum) LEFT JOIN pg_description com on (pgc.oid = com.objoid AND a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2555eaa29c114298a49a733bc736599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001ef40fe9cd1e497cfbc5743924607b/" rel="bookmark">
			Kubernetes日常操作命名（非完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Kubernetes日常操作命名 1、Kubernetes 进入容器方法2、获取节点相应服务的信息3、如果需要按selector名来查找相应的pod信息， 可以通过以下命令查看：4、查看K8S集群信息5、查看pods所在的运行节点7、查看pods定义的详细信息8、查看运行的pod的环境变量9、查看指定pod的日志10、查看集群节点信息 1、Kubernetes 进入容器方法 ---- 方法一：
kubectl exec -it asf-admin-688c7745f-4wk7h /bin/sh ---- 方法二：
kubectl exec -it nginx-56b8c64cb4-t97vb /bin/bash 2、获取节点相应服务的信息 kubectl get nodes 3、如果需要按selector名来查找相应的pod信息， 可以通过以下命令查看： kubectl get pod --selector name=tomcat 4、查看K8S集群信息 kubectl cluster-info 5、查看pods所在的运行节点 kubectl get pods -o wide ---- 方法一：
kubectl get pods --all-namespaces ---- 方法二（列出更多的详细信息）：
kubectl get pods -o wide --all-namespaces 7、查看pods定义的详细信息 kubectl get pods -o yaml 8、查看运行的pod的环境变量 kubectl exec &lt;pod名称&gt; env 9、查看指定pod的日志 kubectl logs -f pods/&lt;pod名称&gt; -n kube-system 10、查看集群节点信息 kubectl get nodes 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d021750620fc7750a6687371740ffc/" rel="bookmark">
			git 日常基础使用开发命令（非完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git 命令大全 1、拉取最新的所有分支 git fetch --prune origin
2、下载一个远程分支到本地新建的分支 git checkout -b 本地分支名 origin/远程分支名
3、下载一个远程分支到本地新建的分支（这种写法是上面的简化版，效果完全一样） git checkout --track origin/远程分支名
4、下载一个远程分支到本地新建的分支（这种写法是3的简化版） git checkout -t origin/远程分支名
5、fetch指定的一个分支：git fetch [repo] [remote_branch_name]:[local_branch_name] git checkout [local_branch_name]
（第一行的:[local_branch_name]如果不写，则本地新建的分支名默认与远程分支名相同）
6、获取远程所有分支 git fetch
7、可以看到所有远程分支，假设有一个分支叫origin/mybranch git branch -r
8、即可，会在本地新建一个同名分支，并与该远程分支关联 git checkout mybranch
9、会进入detached head状态，不会在本地新建分支，不要这样写） git checkout origin/mybranch
10、提交分支 git pull
11、提交指定分支 git pull HEAD:origin/mybranch
12、删除远程分支 git push origin --delete [branchname]
13、清理本地无效分支(远程已删除本地没删除的分支) git fetch -p
git branch -d [分支名]
14、指定一个分支拉取最新代码，并合并到当前的分支中 git rebase [branchname]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8d021750620fc7750a6687371740ffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a343bc7c53bfefbea7f6877ed29fe2e/" rel="bookmark">
			linux内核 lvs,Linux中 LVS 的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、LVS简介
LVS(Linux Virtual Server)即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，目前 LVS 是 Linux 内核标准的一部分。
使用 LVS 可以达到的技术目标是：通过 LVS 达到的负载均衡技术和 Linux 操作系统实现一个高性能高可用的 Linux 服务器集群，它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的性能。
LVS 是一个实现负载均衡集群的开源软件项目，LVS架构从逻辑上可分为调度层、Server集群层和共享存储。
二、LVS详细介绍
1、宗旨
使用集群技术和Linux操作系统实现一个高性能、高可用的服务器。
很好的可伸缩性(Scalability)；
很好的可靠性(Reliability)；
很好的可管理性(Manageability)。
2、LVS的组成
LVS 由2部分程序组成，包括 ipvs 和 ipvsadm。
1)ipvs(ip virtual server)：一段代码工作在内核空间，叫ipvs，是真正生效实现调度的代码。
2)ipvsadm：另外一段是工作在用户空间，叫ipvsadm，负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)。
3、LVS相关术语
1)DS：(Director Server)指的是前端负载均衡器节点。
2)RS：(Real Server)后端真实的工作服务器。
3) VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址。
4) DIP：(Director Server IP)主要用于和内部主机通讯的IP地址。
5) RIP：(Real Server IP)后端服务器的IP地址。
6) CIP：(Client IP)访问客户端的IP地址。
4、LVS的优点
LVS主要用于多服务器的负载均衡。它工作在网络层，可以实现高性能，高可用的服务器集群技术。
1)开源，免费，可把许多低性能的服务器组合在一起形成一个超级服务器。
2)在网上能找到一些相关技术资源。
3)易用，配置非常简单，且有多种负载均衡的方法。
4)稳定可靠，即使在集群的服务器中某台服务器无法正常工作，也不影响整体效果。另外可扩展性也非常好。
5、LVS的缺点
1)最核心的就是没有可靠的支持服务，没有人对其结果负责；
2)功能比较简单，支持复杂应用的负载均衡能力较差，如算法较少等；
3)开启隧道方式需重编译内核；
4)配置复杂；
5)主要应用于LINUX，目前没有专门用于WINDOWS的版本，不过可以通过配置，使windows成为LVS集群中的real server。
6、LVS的工作原理
LVS可分为三部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a343bc7c53bfefbea7f6877ed29fe2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d14468089b99f7f966f66926fc7394ea/" rel="bookmark">
			12人局狼人杀攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		民开局 宣称是民：
退水。（优点：若是后置位可以分析一堆，多一轮说话机会，帮助好人分析。缺点：加入狼人确认平民身份，加速狼人抿身份–个人感觉加速狼人身份在大多数局里不重要。）
宣称是预言家：
炸后置位竞选者。（有点：有概率炸出后置位狼人，或者加速好身份的坐实。）然后在合理的实际退水。一般来说炸自己之后第一个的竞选者比较好，减少他准备的时间。
不竞选。不竞选的目的是投票给自己判断出的好人，让其带队；以及把自己身份坐高。
（若有宣称时预言家这查杀警上前置位或者查杀非竞选者，则为真预言家或者狼人。当宣称预言家者查杀警上后置位，默认为想炸狼的民，若其言谈无漏洞且退水，可以暂归好人；若被炸的人言谈紧张或者不敢反咬，判定为狼，顺出。）
当真假预言家不可判断时，理由不充分的强势站边的玩家（若排除平安夜女巫死保银水的可能性外）顺出。
民首轮被其他人发金水，可以直接跳预言家对他查杀–通过他反应判断他究竟是不是预言家。
当有其他玩家在理由不充分的情况下和自己对刚，一定要凶悍反咬，但是不要惜命，要表现出那种我死了无所谓，但是那个人一定是铁狼的心态。对方到底是不是狼人不重要，重要的是让别人确认自己是民的身份。千万千万不要向狼跪下，只有在好人稳赢才能认出，标识自己不死要求出自己怀疑的人。
身为民，顺出顺序：坐实的预言家报的查杀（一般不走查杀的预言家都是假预言家）以及铁狼、死保铁狼的玩家、无理由和自己对刚的玩家、站在狼人视角分析问题的玩家（找链子，找女巫，找长老，找猎人）、理由不充分强势站边者、跟风踩人的玩家、逻辑混乱的玩家。
非预言家神开局 警上：宣称是民，退水。不竞选。宣称是神，要求警徽。宣称预言家炸后置位，然后退选。警上不竞选。
当其他玩家试图穿上自己衣服时，默认其为狼人（个人觉得这个游戏民为神当刀的必要性不大），第二天或第三天仍旧穿衣服则必须顺出。
女巫：
若别人求当轮不死而穿女巫衣服，当夜毒杀（出开局少数情况下，民被急火了，只能找人PK，而穿女巫衣服求生；而其他神身份被急火了，一般来说可以直接自爆神身份）。当自己死亡时，将对跳女巫的玩家带走，若无对跳女巫的则毒走自己判定隐狼，或者毒走铁狼（稳）。白天若没有被投出场外可能性时，保持低调假装闭眼玩家分析。若白天被污，且大概率要被出，曝出女巫身份求自保，并说出当晚毒杀目标。当药用尽或者被狼刀慢的情况下，白天自爆女巫身份，讲述心路历程。
女巫可以首夜救人，警上直接说自己是女巫报银水抢得警长。（尤其是人少的局、有真假预言家对跳的局、以及有守卫可以保护自己的局势）
猎人：
警上：猎人可以开场直接声称自己是猎人，给自己抢得警徽。（当有真假预言家，跳神过多的局势）。（劣势就是猎人身份坐实，女巫身份容易暴露？）
当有人穿猎人衣服时，必须跳猎人将其拍死。如果拍不死，自己时候将其带走。
当自己死亡时的击杀顺序：对跳猎人身份的玩家（同样是狼优先带走穿自己衣服的狼）、确定狼人身份的玩家、中后期怀疑是狼人身份的玩家。当无合理目标时，放空枪或者盖牌。
长老：
（长老局玩的不多，我的理解可能不够，存疑）
第一天白天跳长老，防止衣服被穿。（长老不跳的劣势，衣服被穿很难被拔下来）其实长老牌挺无聊的，必须起跳，往往还要和狼长老对斯。
一般来说，除非有特殊漏洞（料包，或者狼先知迷之悬着双金水或者查杀某个长老），可以留着两个对跳的长老，留到女巫没药、预言家必死了的时候两个都推掉。
守卫：
1、若自己是场上优先首杀的目标，第一回合可以守自己。然后保持低调。
2、若自己不是场上优先击杀的目标，第一晚可以随便守一个人活着空守，第二天可以直接跳守卫或者对跳守卫拍死假守卫，然后在第二晚守自己。
3、铁狼认守卫的时候要淡定，不要被抿出守卫身份。隐狼认守卫可以跳出来和他一换一。
预言家开局 宣称是预言家，报金水。要警徽，今晚验X号，验他的理由是（1、实力强悍，想让他带队）。预言家若验金水是可以假报查杀的，但是一定要说清楚是预言家诈身份，有概率撞到钢板直接血崩的。
预言家可以在警上，宣称预言家，说有查杀，不报，然后交代警徽流。优势就是，在狼队未知谁被查杀的时候可能会出现站队，加速预言家抿身份，劣势就是使得自己的预言家身份不可信。
宣称是预言家，报查杀，全力号召全场将查杀推走。若不强硬，则会留下无说服力的印象。预言家抢警徽时，不必太迫切，可以讲出当拿不到警徽时他将会采取的策略。预言家必须对查杀比枪警徽更加迫切。当预言家是后置位且目前唯一声称预言家的玩家是，可以先报警徽流，然后解释，因为今天有查杀我怕被查杀的会自爆所以我先报警徽流，然后报查杀（时髦值MAX！！！）
第二夜及第三夜，先验警上的玩家，再验宣称是神退水的玩家（一般所谓的警上验一个，警下验一个）。一般来说，有狼对跳预言家时，可以和狼预言家互验（不是指验狼预言家，狼预言家时标狼，不用验，去验狼预言家所谓金水和查杀）。一般说，若预言家为警长，预言家在发言之后不能修改警徽流，说了验谁就要验谁，因为警长倒牌不能发言，有可能会因为改警徽流血崩，就算一定要改要找大概率为金水的人验，保证能给出警徽，不然好人会对警长撕掉警徽有不同的理解。
狼人 夜里可以打手势指挥警上分工，一般推荐，2人起来竞选，1人当深水狼。其他人见机行事。起来竞选也可以选择退水放弃投票，转为隐狼积着。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af4300ceb59a1f7ceee5c2eeeab01c7/" rel="bookmark">
			keil(MDK5)进行编译时常见问题1：undefined symbol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		keil编译出现undefined symbol可能的原因 在利用keil对单片机编程时，有时会出现如下提示：
出现这种现象的原因有如下几条：
（1）未将.c/.h文件添加到代码中。
点击“Add Files”即可添加相应文件到相应文件夹中
（2）未将文件的地址添加进去。
在“include Paths”中添加相应地址。
（3）第三个原因是我找了很多地方都未能得到解决的，然后我发现，当我们把1个变量放在子函数里面，却在其他地方用extern调用时，也会出现这种现象。
在别处调用
所以解决的办法是将这个变量放在函数外面，作为全局变量，即可在别处顺利调用。
如果觉得我的方法有用的话，可以点个赞哦。
如果有什么地方不清楚或者有问题的，欢迎在评论区指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0321cc9219fbe7866982193689bd9fa1/" rel="bookmark">
			网络美女爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要提醒：网络爬取盗亦有道，本教程仅做技术交流，不做任何商业用途，请大家遵守网络商业环境 #编程新人第一次写文章，技术不成熟之处望各位大神轻喷，指出来我也可以更快进步，谢谢大家了!!!提前谢谢大家的一键三连
#这是爬取后的结果，可自定义爬取页数，我这里只爬取了2页（手机热点开着爬取，爬多了流量着不住啊！！！o(╥﹏╥)o）
先看看爬取结果吧~
1、技术路线 requests：网页请求
BeautifulSoup：解析html网页
re：正则表达式，提取html网页信息
os：保存文件
import re import requests import os from bs4 import BeautifulSoup 2、获取网页信息 常规操作，获取网页信息的固定格式，返回的字符串格式的网页内容，其中headers参数可模拟人为的操作，‘欺骗’网站不被发现
def getHtml(url): #固定格式，获取html内容 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36' } #模拟用户操作 try: r = requests.get(url, headers=headers) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: print('网络状态错误') 3、网页爬取分析 右键单击图片区域，选择 ‘审查元素’ ,可以查看当前网页图片详情链接，我就满心欢喜的复制链接打开保存，看看效果，结果一张图片只有60几kb，这就是缩略图啊，不清晰，果断舍弃。。。
没有办法，只有点击找到详情页链接，再进行单独爬取。
空白右键，‘查看页面源代码’，把刚刚复制的缩略图链接复制查找快速定位，分析所有图片详情页链接存在div标签，并且class=‘list’ 唯一，因此可以使用BeautifulSoup提取此标签。并且发现图片详情页链接在herf=后面（同时我们注意到有部分无效链接也在div标签中，观察它们异同，发现无效链接存在’https’字样，因此可在代码中依据此排出无效链接，对应第4条中的函数代码），只需提取出来再在前面加上网页首页链接即可打开，并且右键图片，‘审查元素’，复制链接下载的图片接近1M，表示是高清图片了，到这一步我们只需调用下载保存函数即可保存图片
4、网页详情页链接获取 根据第3条分析的情况，首要目标是将每页的每个图片的详情页链接给爬取下来，为后续的高清图片爬取做准备，这里直接定义函数def getUrlList(url):
def getUrlList(url): # 获取图片链接 url_list = [] #存储每张图片的url，用于后续内容爬取 demo = getHtml(url) soup = BeautifulSoup(demo,'html.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0321cc9219fbe7866982193689bd9fa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba3e2bf40a8d45f051a858b5f6c5114/" rel="bookmark">
			【AcWing】蓝桥杯C&#43;&#43; AB组辅导课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝桥杯 C++ AB 组辅导课 教学计划与递归如何准备蓝桥杯比赛做题的套路第一讲 递归与递推递归实现指数型枚举递归实现排列型枚举递归实现组合型枚举AcWing116.飞行员兄弟 第二讲 二分与前缀和AcWing789.数的范围AcWing790.数的三次方根AcWing795.前缀和AcWing796.子矩阵的和AcWing1221.四平方和AcWing1230.K倍区间 第四讲 枚举、模拟与排序AcWing1210.连号区间数AcWing1236.递增三元组AcWing1245.特别数的和AcWing1204.错误票据AcWing466.回文日期AcWing1219.移动距离AcWing1229.日期问题AcWing1231.航班时间AcWing1241.外卖店优先级 第六讲 双指针、BFS与图论AcWing1238.日志统计AcWing1101.献给阿尔吉侬的花束AcWing1113.红与黑AcWing1224.交换瓶子AcWing1096.地牢大师AcWing1233.全球变暖AcWing1207.大臣的旅费 第十一届蓝桥杯省赛第一场C++A/B组真题AcWing2065.整除序列AcWing2066.解码AcWing2067.走方格AcWing2068.整数拼接 教学计划与递归 如何准备蓝桥杯比赛 要有一定刷题量
若想在省赛中取得较好成绩，建议做200题左右。
若想在国赛中取得较好成绩，建议做300题左右。
本课程约讲解100题左右。
要重视调试
有思路得前提下，若调试不过，不要立马问别人。要自己努力解决问题。
要重视考试。
感受真实氛围，检验学习成果。
比赛时比的并不是去发明或者去创造某一个思路，比赛比的是熟练度。
做题的套路 算法题特点：
1、与数学、物理等学科相比，算法题的模型相对较少。
2、思维量高
3、编写编程能力 。要用理论去指导实践。数学题想出来就能做出来，但是算法题能想出来不一定能实现出来。
做题过程
1、看题目描述
2、分析，抽象出来它考什么模型。分析出题人是想问什么。
3、回忆之前学过的算法或做过的题目能不能解决这个问题。若不能，再去回溯。解决方案是平时多去积累一些题目，多去刷一些题目。只有平时积累的多了，考试的时候才能学以致用。
如何判断一个算法能不能用？
1、首先看正确性
2、再看时间是否超限制。
C++ 评测机一秒约运行一亿次。若算法的的时间复杂度超过108,则可能会超时。
做题时，先看数据范围，排除不能使用的算法。找到题目数据范围区间之内的算法。这样做题思路会更明确。
数据范围可以带给我们非常多的信息。
学算法一定要落实到代码上
若输入输出 范围 小于 105 推荐用 cin / cout 否则用 scanf / printf 输入时间会快一倍左右。
第一讲 递归与递推 递归是什么？递归就是自己调用自己。 递归计算斐波那契数列
#include&lt;iostream&gt; using namespace std; int f(int n ) { if (n == 1) return 1; if (n == 2) return 2; return f(n - 1) + f(n - 2); } int main() { int n ; cin &gt;&gt; n; cout &lt;&lt; f(n); return 0; } 如何分析判断 递归执行顺序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba3e2bf40a8d45f051a858b5f6c5114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e3f7ef353549a6cd5e2a70f2d9f05af/" rel="bookmark">
			【AcWing】寒假每日一题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寒假每日一题 week 1AcWing104.货仓选址 week 2AcWing756.蛇形矩阵AcWing1113.红与黑AcWing1346.回文平方AcWing1227分巧克力AcWing680.剪绳子AcWing429.奖学金 week 3AcWing422.校门外的树AcWing1381.阶乘AcWing1208.翻硬币AcWing1532.找硬币AcWing1341.十三号星期五AcWing754.平方矩阵IIAcWing1432.棋盘挑战AcWing1371.货币系统 week 4AcWing1353.滑雪场设计AcWing1603.整数集合划分AcWing482.合唱队形AcWing420.火星人 week 1 AcWing104.货仓选址 #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n, res; int a[N]; int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf("%d", &amp;a[i]); sort(a, a + n); for (int i = 0; i &lt; n; i ++ ) res += abs(a[i] - a[n / 2]); printf("%d\n", res); return 0; } week 2 AcWing756.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e3f7ef353549a6cd5e2a70f2d9f05af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b563cd68ed33e4d8b6dc0384136fc8c/" rel="bookmark">
			Shell脚本练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编写脚本 systeminfo.sh，显示当前主机系统信息，包括:主机名，IPv4地址，操作系统版本，内核版本，CPU型号，内存大小，硬盘大小 #!/bin/bash # #******************************************************************** #Author:	wangmingwang #QQ: 2380821650 #Date: 2021-04-17 #FileName：	system_info_1.sh #URL: http://www.wangmingwang.com #Description：	The test script #Copyright (C): 2021 All rights reserved #******************************************************************** RED="\E[1;31m" GREEN="echo -e \E[1;32m" END="\E[0m" $GREEN-----------------------Host systeminfo----------------------------------$END echo -e "HOSTNAME: $RED`hostname`$END" echo -e "IPADDR: $RED`ifconfig eth0|grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' |head -n1`$END" echo -e "OSVERSION: $RED`cat /etc/redhat-release`$END" echo -e "KERNEL: $RED`uname -r`$END" echo -e "CPU: $RED`lscpu|grep 'Model name'|tr -s ' '|cut -d : -f2`$END" echo -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b563cd68ed33e4d8b6dc0384136fc8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736e5ab480843db8587539c14f8087f8/" rel="bookmark">
			运维自动化系统部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、CentOS8实现PXE自动化安装1、安装前准备：2、安装相关软件包3、配置dhcp服务4、准备yum源和相关目录5、准备kickstart文件6、准备PXE启动相关文件7、准备启动菜单文件8、测试客户端基于PXE实现自动安装 二、利用cobbler实现自动化安装1、环境准备2、安装相关包并启动服务3、修改cobbler相关的配置4、实现dhcp服务5、下载启动的相关文件6、修改菜单的标题信息7、导入centos系统的安装文件，生成相应的yum源8、准备kickstart文件，并关联至指定的yum源9、支持UEFI安装10、实现cobbler web 管理11、创建cobbler自定义用户 一、CentOS8实现PXE自动化安装 1、安装前准备： 关闭防火墙和selinux 确保dhcp服务器地址是静态IP
2、安装相关软件包 [root@centos8 ~]#dnf -y install dhcp-server tftp-server httpd syslinuxnonlinux(或者syslinux-tftpboot) [root@centos8 ~]#systemctl enable --now httpd tftp dhcpd 3、配置dhcp服务 [root@centos8 ~]#cp /usr/share/doc/dhcp-server/dhcpd.conf.example /etc/dhcp/dhcpd.conf [root@centos8 ~]#vim /etc/dhcp/dhcpd.conf option domain-name "example.com"; option domain-name-servers 180.76.76.76,223.6.6.6; default-lease-time 600; max-lease-time 7200; log-facility local7; subnet 10.0.0.0 netmask 255.255.255.0 { range 10.0.0.1 10.0.0.200; option routers 10.0.0.1; next-server 10.0.0.100; filename "pxelinux.0"; } [root@centos8 ~]#systemctl start dhcpd 4、准备yum源和相关目录 [root@centos8 ~]#mkdir -pv /var/www/html/centos/{6,7,8}/os/x86_64/ [root@centos8 ~]#mount /dev/sr0 /var/www/html/centos/6/os/x86_64/ [root@centos8 ~]#mount /dev/sr1 /var/www/html/centos/7/os/x86_64/ [root@centos8 ~]#mount /dev/sr2 /var/www/html/centos/8/os/x86_64/ 5、准备kickstart文件 [root@centos8 ~]#mkdir /var/www/html/ks/ [root@centos8 ~]#vim /var/www/html/ks/centos6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736e5ab480843db8587539c14f8087f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f158fa323db846e58333c4e45fdc6f59/" rel="bookmark">
			http相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.http头信息 HTTP Request Header 请求头 Header解释示例Accept指定客户端能够接收的内容类型Accept: text/plain, text/htmlAccept-Charset浏览器可以接受的字符编码集。Accept-Charset: iso-8859-5Accept-Encoding指定浏览器可以支持的web服务器返回内容压缩编码类型。Accept-Encoding: compress, gzipAccept-Language浏览器可接受的语言Accept-Language: en,zhAccept-Ranges可以请求网页实体的一个或者多个子范围字段Accept-Ranges: bytesAuthorizationHTTP授权的授权证书Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==Cache-Control指定请求和响应遵循的缓存机制Cache-Control: no-cacheConnection表示是否需要持久连接。（HTTP 1.1默认进行持久连接）Connection: closeCookieHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。Cookie: $Version=1; Skin=new;Content-Length请求的内容长度Content-Length: 348Content-Type请求的与实体对应的MIME信息Content-Type: application/x-www-form-urlencodedDate请求发送的日期和时间Date: Tue, 15 Nov 2010 08:12:31 GMTExpect请求的特定的服务器行为Expect: 100-continueFrom发出请求的用户的EmailFrom: user@email.comHost指定请求的服务器的域名和端口号Host: www.zcmhi.comIf-Match只有请求内容与实体相匹配才有效If-Match: “737060cd8c284d8af7ad3082f209582d”If-Modified-Since如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMTIf-None-Match如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变If-None-Match: “737060cd8c284d8af7ad3082f209582d”If-Range如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为EtagIf-Range: “737060cd8c284d8af7ad3082f209582d”If-Unmodified-Since只在实体在指定时间之后未被修改才请求成功If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMTMax-Forwards限制信息通过代理和网关传送的时间Max-Forwards: 10Pragma用来包含实现特定的指令Pragma: no-cacheProxy-Authorization连接到代理的授权证书Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==Range只请求实体的一部分，指定范围Range: bytes=500-999Referer先前网页的地址，当前请求网页紧随其后,即来路Referer: http://www.zcmhi.com/archives/71.htmlTE客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息TE: trailers,deflate;q=0.5Upgrade向服务器指定某种传输协议以便服务器进行转换（如果支持）Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11User-AgentUser-Agent的内容包含发出请求的用户信息User-Agent: Mozilla/5.0 (Linux; X11)Via通知中间网关或代理服务器地址，通信协议Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)Warning关于消息实体的警告信息Warn: 199 Miscellaneous warning HTTP Responses Header 响应头 Header解释示例Accept-Ranges表明服务器是否支持指定范围请求及哪种类型的分段请求Accept-Ranges: bytesAge从原始服务器到代理缓存形成的估算时间（以秒计，非负）Age: 12Allow对某网络资源的有效的请求行为，不允许则返回405Allow: GET, HEADCache-Control告诉所有的缓存机制是否可以缓存及哪种类型Cache-Control: no-cacheContent-Encodingweb服务器支持的返回内容压缩编码类型。Content-Encoding: gzipContent-Language响应体的语言Content-Language: en,zhContent-Length响应体的长度Content-Length: 348Content-Location请求资源可替代的备用的另一地址Content-Location: /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f158fa323db846e58333c4e45fdc6f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0956d31b0ac30ce2284967109240eced/" rel="bookmark">
			halcon算子学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		get_camera_setup_param( : : CameraSetupModelID, CameraIdx, GenParamName : GenParamValue)
get_camera_setup_param可用于检查相机设置模型CameraSetupModelID的各种通用参数。可以使用此运算符查询两种类型的参数：
General parameters:（CameraIdx）
‘num_cameras’ 模型中描述的摄像机数量。摄像机的数量是随摄像机设置模型的创建而固定的，此后无法更改
’camera_calib_error’:
相机系统优化的反投影的均方根误差（RMSE）。此错误与传回的错误相同
’reference_camera’:
返回已在系统中定义为参考摄像机的摄像机的索引。如果未使用set_camera_setup_param指定参考摄像机，则返回索引0。如果通过在set_camera_setup_param中使用参数’coord_transf_pose’设置姿势来移动坐标系，则坐标系的原点不在任何可用的摄像机中。因此，返回索引-1。
’coord_transf_pose’:
返回已移动设置的坐标系的姿势。请注意，在使用set_camera_setup_param设置参考摄像机之后，将返回此摄像机的姿态。随后使用set_camera_setup_param中的参数’coord_transf_pose’调整此坐标系会产生一个姿态，该姿态对应于所需坐标系相对于当前坐标系的位置和方向。（GenParamName）Camera parameters：（CameraIdx）
’type’: 相机类型 (see set_camera_setup_cam_param).
’params’: 具有内部相机参数的元组。元组的长度取决于相机类型。
’params_deviations’: 一个表示内部摄像机参数的标准偏差的元组。元组的长度取决于相机类型。
’params_covariances’: 如果内部相机参数，则表示协方差矩阵的元组。元组的长度取决于相机类型。
’pose’: 相对于设置的坐标系的相机姿态（有关更多详细信息，请参见create_camera_setup_model）。（GenParamName） tuple_regexp_test( : : Data, Expression : NumMatches)
tuple_regexp_test将Expression中的正则表达式应用于Data中的一个或多个输入字符串，并在NumMatches中返回匹配字符串的数量**。特别是，如果匹配，单个输入字符串的结果将为1，否则为0。请参阅tuple_regexp_match的文档以获取正则表达式的语法和选项。此外，tuple_regexp_test支持选项’invert_match’，这将导致对那些与正则表达式不匹配的输入字符串进行计数。（正则表达式看不懂）
change_radial_distortion_cam_par( : : Mode, CamParamIn, DistortionCoeffs : CamParamOut)
change_radial_distortion_cam_par根据指定的径向失真系数DistortionCoeffs修改内部摄像机参数。该操作员仅可用于面扫描相机（任何类型的镜头）和带远心镜头的线扫描相机。不支持带有透视镜的线扫描相机。
mode的参数：
’fixed’: 仅修改失真系数，其他内部摄像机参数保持不变。通常，这会导致场景可见部分的变化。
’fullsize’ 对于区域扫描相机，将修改比例因子和图像中心点，以保留场景的可见部分。对于带有远心镜头的线扫描相机，请更改比例因子，图像中心点和运动矢量的分量以实现此效果。因此，原始图像中所有可见的点在修改后的图像中也可见。通常，这会导致修改后的图像中出现未定义的像素。
**‘adaptive’**在其他模式之间进行权衡：场景的可见部分会稍有减少，以防止修改后的图像中出现未定义的像素。与“全尺寸”相同的参数被修改。
’preserve_resolution’ 与在“全尺寸”模式下一样，原始图像中所有可见的点在修改后的（校正后的）图像中也可见。对于区域扫描相机，将修改比例因子和图像中心点。对于带有远心镜头的线扫描相机，更改比例因子，图像中心点以及运动矢量的分量可能会达到这种效果。通常，这会导致修改后的图像中出现未定义的像素。与“全屏”模式相反，此外，修改后的图像的大小会增加，以使图像分辨率在图像的任何部分均不会降低。
gen_radial_distortion_map( : Map : CamParamIn, CamParamOut, MapType : )
gen_radial_distortion_map根据内部摄像机参数CamParamIn和CamParamOut计算出与变化的径向失真相对应的图像映射，例如，可以使用操作员calibrate_cameras获得这些参数。 CamParamIn和CamParamOut分别包含旧的和新的相机参数，包括旧的和新的径向变形（另请参阅校准以了解参数序列和基础相机模型）。潜在输出图像的每个像素都使用CamParamOut变换到图像平面，然后使用CamParamIn投影到潜在输入图像的子像素位置。请注意，gen_radial_distortion_map只能与区域扫描相机一起使用。
注：change_radial_distortion_cam_par算子将相机的畸变系数（k1-k3，p1,p2）设置为0，然后利用gen_radial_distortion_map算子将没有畸变的参数和有畸变的参数生成一个映射,就可以利用这个映射进行畸变校正
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0956d31b0ac30ce2284967109240eced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924d32891abd3756a3dfd79765ead970/" rel="bookmark">
			恢复 MyBase 误删除的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 MyBase 是一款很好用的笔记工具, 但是有些时候操作失误, 或者不知什么原因导致两个条目内容相同, 可以使用下面的办法来恢复误被覆盖的条目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4d79b3e466059b84ea23d32f56263b/" rel="bookmark">
			最小linux操作系统,最小的系统：TinyCore，11MB&#43;极致精简，旧电脑也能运行如飞！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：最小的系统：TinyCore，11MB+极致精简，旧电脑也能运行如飞！
电脑端必备的就是操作系统，就像珍珠跟奶茶一样，都是标配好的。说到操作系统，大家第一个想到的就是霸主微软旗下的windows操作系统，其次就是谷歌ChromeOS以及苹果的MacOS，最后才是Deepin等国产系统。
虽说操作系统有很多，但现在无非就是看中系统的易用程度和电脑的运行速度。就这两点可以淘汰很多操作系统，能入选的寥寥无几。
不过近年来基于开源Linux系统二次开发出来的系统由于需要的电脑配置不高，在易用性和运行速度上就占了上风，比如国产Deepin系统。一经发布，喜爱程度不亚于win7。
而且前阵子，韩博士发现了一个宝藏微型Linux发行版TinyCore系统，让你那些徘徊在垃圾桶边缘的旧电脑重新焕发活力，简直就是神仙系统！
世界上最小的发行版操作系统TinyCore
TinyCore是一款体积极小且高度可扩展性的微型Linux发行版，小得让人叹为观止：终端版本只有11MB，而图形界面版本多了5MB。单单一个常见的镜像文件就要在GB上下徘徊，结果它一出手就惊艳四座，被誉为世界上最小的发行版操作系统，连古董机都可以跑得贼顺畅。
不要觉得体积小就觉得看不起，那你就不清楚什么叫麻雀虽小，五脏俱全！
因为它提供了图形化界面，包含BusyBox 和 FLTK 图形界面、JWM 窗口管理器；采用将系统内核完全装载在内存中运行的方式，所以跑起来飞快不是没道理的；
不过水能载舟亦能覆舟，由于精简程度高导致驱动不全，不完整支持所有硬件。只包含Linux内核和X桌面，支持有线网络；
但是用户不要觉得可惜，因为大家有充分的定制自由，可以通过在线软件仓库进行安装额外的应用，丰富扩展整个TinyCore系统功能。发挥自己的想象力，打造一个独有的体积极小且实用性强的Linux。
如何安装TinyCore系统？
下载镜像文件，当然要看好哦，因为它有Core(命令版：11MB)、Tiny Core(图形界面版：16MB)和 Core Plus(功能丰富：106MB)这3款。韩博士直接下载Tiny Core版本镜像。
1. 打开你们的虚拟机，选择下载好的Tiny Core镜像文件。
2. 操作系统要选择“linux”，版本任意发挥哦~
3. 开始设置磁盘的大小，大家给个1GB的空间绝对是够了！
这时候只要默认进行操作即可，随后开始启动虚拟机，这时候你就能畅享只有16MB的操作系统了！
韩博士要提醒大家，先好好在虚拟机上操作一番，觉得好使了再安装到主机上。配置最低也要有RAM: 46 MB(推荐64 MB)和奔腾2的CPU哦~返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ceb73e9f70a5704e93b969d33ab0b6/" rel="bookmark">
			linux文件夹权限777怎么设置,Linux：设置文件夹权限之777的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天面试的时候一不小心就给自己挖坑了，说使用过的Linux命令时，我说了一个 mkdir -m 777 文件夹名称——创建文件夹及授予权限，然后就被问：
为什么mkdir -m 777 文件夹名称授予文件夹权限要用777？
在linux系统中,文件或目录的权限可以分为3种:
R： 4 可读
W：2 可写
X： 1 执行
－：对应数值0
数字 4 、2 和 1表示读、写、执行权限
rwx = 4 + 2 + 1 = 7 (可读写运行)
rw = 4 + 2 = 6 (可读写不可运行)
rx = 4 +1 = 5 (可读可运行不可写)
所以最高权限就是777：(4+2+1) (4+2+1) (4+2+1)；
第一个7:表示当前文件的拥有者的权限,7=4+2+1 可读可写可执行权限；
第二个7:表示当前文件的所属组(同组用户)权限,7=4+2+1 可读可写可执行权限；
第三个7:表示当前文件的组外权限,7=4+2+1 可读可写可执行权限；
所以同理755、655这些都可以表示相应的含义；
文章来源: blog.csdn.net，作者：薄荷2021，版权归原作者所有，如需转载，请联系作者。
原文链接：blog.csdn.net/qq_44390935/article/details/109903504
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/184/">«</a>
	<span class="pagination__item pagination__item--current">185/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/186/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>