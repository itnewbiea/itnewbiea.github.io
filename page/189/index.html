<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fdbac8bb8cc84147ef08780dedb502/" rel="bookmark">
			ping 和 ipconfig 的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping是Windows、Unix和Linux系统下的一个命令。
ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。
ipconfig该命令用于显示所有当前的TCP/IP网络配置值、刷新动态主机配置协议(DHCP)和域名系统(DNS)设置。使用不带参数的IPCONFIG可以显示所有适配器的IP地址、子网掩码、默认网关。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77168990f942156179d4843d54b55557/" rel="bookmark">
			阶跃函数组合响应matlab,matlab在时域分析中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab在时域分析中的应用 UESTC 控制系统计算机仿真 Lirui@时域分析法续 基于Simulink的PID控制器设计 改善系统时域响应性能的措施 二阶系统参数对时域响应性能的影响 时域响应性能指标求取 LTI Viewer 应 用典型环节及其传递函数 一、典型环节及其传递函数 典型环节通常分为以下六种： 1 比例环节 式中 K-增益 特点：输入输出量成比例，无失真和时间延迟。 任何一个复杂系统都是由有限个典型环节组合而成的。 动态方程 传递函数典型环节及其传递函数 2 惯性环节 3 纯微分环节 动态方程 传递函数 动态方程 传递函数典型环节及其传递函数 4 一阶微分环节 5 二阶微分环节 动态方程 传递函数 动态方程 传递函数典型环节及其传递函数 6 积分环节 7 振荡环节 ¡式中 ξ－阻尼比 ¡ -自然振荡角频率(无阻尼振荡角频率) 动态方程 传递函数 动态方程 传递函数典型环节及其传递函数 8 纯时间延时环节 ¡式中 －延迟时间 动态方程 传递函数典型试验信号 二、典型试验信号 Typical test signals (单位)阶跃函数(Step function ) (单位)斜坡函数(Ramp function) (单位)加速度函数(Acceleration fun) (单位)脉冲函数(Impulse function) 正弦函数(Simusoidal function )时域响应性能指标 三、动态性能指标 上升时间 响应曲线从稳态 值的10%上升 到90%，所需 的时间。上升 时间越短，响 应速度越快 峰值时间： 响应曲线达到峰值所需要的时间。 时域响应性能指标 动态性能指标 调节时间 (Settling Time) 响应曲线达到并永远 保持在一个允许误差 范围内，所需的最短 时间。用稳态值的百 分数(通常取5%或2% )表示。超调量 % ：指响应的最大偏离量 h(t p )于终值之差的百分比，即 即： t t r时域响应性能指标求取 四、时域响应性能指标求取 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77168990f942156179d4843d54b55557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcabf5301920046aed928cee266d9b90/" rel="bookmark">
			电力系统分析设计matlab,电力系统分析课程设计-基于Matlab的电力系统潮流计算...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电力系统分析课程设计-基于Matlab的电力系统潮流计算 《电力系统分析》课程设计 基于Matlab的电力系统潮流计算 专 业 电气工程及其自动化 班 级 1402班 姓 名 郭娟 学 号 14039208 同 组 成 员 孙帆 郭娟 陈朝辉 苏新波 吕应发 指 导 教 师 楚冰清 完 成 时 间 2016 .12 .30 目 录 1概述1 1.1设计目的1 1.2设计题目1 1.3设计内容1 2电力系统潮流计算概述2 2.1电力系统简介2 2.2潮流计算简介2 2.3潮流计算意义及其发展2 3 Matlab概述3 3.1 Matlab简介3 3.2 Matlab应用4 4 潮流计算过程4 4.1系统图及参数5 4.1.1 系统图5 4.1.2 各元件参数5 4.2电网潮流计算思路5 4.3潮流计算过程5 4.3.1各元件参数计算5 4.3.2绘制等效电路图7 4.3.3功率分布计算7 5 Matlab程序及运行结果10 5.1Matlab程序10 5.2运行结果20 6设计心得与体会23 参考文献25 1 概述 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcabf5301920046aed928cee266d9b90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2d3513a9dc491bb6c8ba6b489aa239/" rel="bookmark">
			async/await异步和Task多线程您真的明白了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Async异步和Task多线程异步 一、引言二、什么是异步三、什么是Task四、async/await和Task异步详解1、不加await修饰2、加await修饰 一、引言 嗯，由于自己的无知和对知识有点一知半解的陋习下，使自己一直纠结于这样的一个问题：究竟什么是异步，在C#中究竟是async定义了异步，还是使用了Task本身就是异步？很明显，在这样的问题下，觉得自己真的有点犯二。原本这样的问题的解释根本不存在，原因是：自己啊，对知识理解不透彻，又怎么可能想明白。所以，经过一番代码运行作为比较，终于明白了其中的意含义，暫抒己见，还望路过的大神能够指点一二，万分感谢！
二、什么是异步 异步的含义其实很简单，比如我们定义一段代码，不必等前面所有的代码执行完，才开始执行某一段代码，就好像，不必等到饭熟了才开始炒菜，大概的意思就是这么一回事，就比如下面这样一段代码，不必等调用的函数体执行完了，才输出结束，这就是异步！
class Program { static void Main(string[] args) { Console.WriteLine("开始"); WriteAsync(); Console.WriteLine("结束"); Console.ReadKey(); } static void WriteAsync() { Task.Run(() =&gt; { for (int i = 0; i &lt; 10; i++) { Console.WriteLine($"AsyncTestMethod"+" "+i); Thread.Sleep(10); } }); } } 三、什么是Task Task确实是一个很神秘的东西，但从根本上说，其实就是开启线程上的任务，即：允许多个任务可以有多个线程(或在同一线程内)进行，不必等到上一个任务执行完，才开始执行下一个任务，很直观的说，就是我在跑步的同时，不影响我也在听音乐！就好像，我在运行QQ的时候，不影响酷狗也在播放音乐！就比如下面的代码，我在比较值的同时，同时也在对该值得进行输出，二者同时进行！
class Program { static void Main(string[] args) { Task.Run(() =&gt; { for (int i = 0; i &lt; 10; i++) { Console.WriteLine(i + "&lt;3" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f2d3513a9dc491bb6c8ba6b489aa239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9810d6fb8961b0b2ed808874bac22b8/" rel="bookmark">
			linux matlab runtime,linux 环境 MATLAB Runtime 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 MUTsigcv 软件时需要用到MATLAB环境，安装过程如下：
环境下载：https://ww2.mathworks.cn/products/compiler/matlab-runtime.html
安装帮助：https://ww2.mathworks.cn/help/compiler/install-the-matlab-runtime.html
下载安装软件 MATLAB_Runtime_R2019a_Update_4_glnxa64.zip 后，解压
由于我没有管理员权限和x11插件，选择特定目录静默安装：
./install -mode silent -agreeToLicense yes -destinationFolder ./software/MUTsigcv
这一步安装时间较长，大概半个小时
安装完成后 ，会给一个环境变量路径：
/mnt/software/MUTsigcv/v96/runtime/glnxa64:/mnt/software/MUTsigcv/v96/bin/glnxa64:/mnt/software/MUTsigcv/v96/sys/os/glnxa64:/mnt/software/MUTsigcv/v96/extern/bin/glnxa64
这个需要加到自己的环境变量里：
vi ~/.bashrc
export LD_LIBRARY_PATH=/mnt/software/MUTsigcv/v96/runtime/glnxa64:/mnt/software/MUTsigcv/v96/bin/glnxa64:/mnt/software/MUTsigcv/v96/sys/os/glnxa64:/mnt/software/MUTsigcv/v96/extern/bin/glnxa64：$LD_LIBRARY_PATH
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d9171212fba2cb33ed8672fea0a7f2/" rel="bookmark">
			matlab汇流母线,无汇流母线的主接线形式.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无汇流母线的主接线形式
主接线形式接线图优点缺点适用范围单元接线发电机—双绕组变压器单元接线接线简单，开关设备少，操作简便；
故障可能性小，可靠性高；
由于没有发电机电压母线，无多台机并列，发电机出口短主要缺点就是单元中任一元件故障或检修都会影响整个单元的工作。发电机额定电压超过10kV(单机容量在125MW及以上)；
虽然发电机额定电压不超过10kV，但发电厂无地区负荷；
原接于发电机电压母线的发电机已能满足该电压级地区负荷的需要；发电机—三绕组变压器(自耦变)单元接线 (接上表)一、单元接线发电机—变压器扩大单元接线路电流有所减小；
④配电装置结构简单，占地少，投资省。④原接于发电机电压母线的发电机总容量已较大(6kV配电装置不能超过120MW，10kV配电装置不能超过240WM)。发电机—变压器——线路组单元接线 主接线形式主接线图优点缺点适用范围二、桥形接线内桥接线其中一回线路检修或故障时，其余部分不受影响，操作较简单。变压器切除、投入或者故障时，有一回路短时停运，操作较复杂；
线路侧断路器检修时，线路需较长时间停运。内桥接线适用于输电线路较长(则检修和故障几率大)或变压器不需经常投、切及穿越功率不大的小容量配电装置中。外桥接线变压器切除、投运或故障时，不影响其余部分的联系，操作较简单；
穿越功率只经过断路器，所造成的断路器故障、检修及系统开环的几率小。其中一回线路检修或故障时，有一台变压器短时停运，操作较复杂；
变压器侧断路器检修时，变压器需较长时间停运。外桥接线适用于输电线路较短或变压器需经常投、切及穿越功率较大的小容量配电装置中。双桥形接线 主接线形式主接线图优点缺点适用范围三、角形接线
闭环运行时，有较高的可靠性和灵活性；
检修任一台断路器，仅需断开该断路器极其两侧隔离开关，操作简单，无任何回路停电；
断路器使用量较少，与不分段单母线相同，仅次于桥形接线，投资少，占地少。
隔离开关只作为检修断路器时隔离电压用，不作切换操作。角形中任一台断路器检修时，变开环运行，降低接线的可靠性。角数越多，断路器越多，开环几率越大，即进出线回路数要受到限制；
在开环的情况下，当某条回路故障时将影响别的回路工作；
角形接线在开、闭环两种状态的电流差别很大，可能使设备选择发生困难，并使继电保护复杂化；
配电装置的明显性较差，而且不利于扩建。角形接线多用于最终规模较明确，进、出线为3~5回的110kV及以上的配电装置中(例如水电厂及无扩建要求的变电所等)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e322ac69c3dc3d74a46ff1736d85b10b/" rel="bookmark">
			ItemsControl 数据绑定的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习ItemsControl这个控件的时候，查看了MSDN上面的一个例子，并且自己做了一些修改，这里主要使用了两种方式来进行相应的数据绑定，一种是使用DataContext，另外一种是直接将一个类绑定到前台，其实这两种方式原理差不多都是将数据模型的对象添加到一个ObservableCollection集合中，然后再c#教程绑定到前台,下面分别介绍两种绑定方式：
第一种
是将数据存储在一个ObservableCollection集合中，然后作为ItemsControl的DataContext对象，下面分别贴出相关的代码：
&lt;Window x:Class="TestGrid.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:local="clr-namespace:TestGrid" Title="MainWindow" Height="350" Width="525"&gt; &lt;Grid&gt; &lt;ItemsControl Margin="10" x:Name="myItemsControl" ItemsSource="{Binding}"&gt; &lt;ItemsControl.Template&gt; &lt;ControlTemplate TargetType="ItemsControl"&gt; &lt;Border BorderBrush="Aqua" BorderThickness="1" CornerRadius="15"&gt; &lt;ItemsPresenter/&gt; &lt;/Border&gt; &lt;/ControlTemplate&gt; &lt;/ItemsControl.Template&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;WrapPanel/&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate DataType="{ x:Type local:DataSource}"&gt; &lt;DataTemplate.Resources&gt; &lt;Style TargetType="TextBlock"&gt; &lt;Setter Property="FontSize" Value="18"/&gt; &lt;Setter Property="HorizontalAlignment" Value="Center"/&gt; &lt;/Style&gt; &lt;/DataTemplate.Resources&gt; &lt;Grid&gt; &lt;Rectangle Fill="Green"/&gt; &lt;Ellipse Fill="Red"/&gt; &lt;StackPanel&gt; &lt;TextBlock Margin="3,3,3,0" Text="{Binding Path=Priority,Mode=TwoWay}"/&gt; &lt;TextBlock Margin="3,0,3,7" Text="{Binding Path=TaskName,Mode=TwoWay}"/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/DataTemplate&gt; &lt;/ItemsControl.ItemTemplate&gt; &lt;ItemsControl.ItemContainerStyle&gt; &lt;Style&gt; &lt;Setter Property="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e322ac69c3dc3d74a46ff1736d85b10b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73196230670caad4f060d7d74d76c825/" rel="bookmark">
			matlab复化梯形公式误差,数值分析复化梯形公式,复化Simpson公式MATLAB程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分别用复化梯形公式、复化Simpson公式计算定积分分别验证结果(精确值I=4.006994)。
复化梯形公式求定积分:
function I=tquad(x,y)
%复化梯形求积公式，其中，
%x为向量，被积函数自变量的等距结点； %y为向量，被积函数在结点处的函数值； n=length(x);
m=length(y);
%积分自变量的结点数应与它的函数值的个数相同 h=(x(n)-x(1))/(n-1);
a=[1 2*ones(1,n-2) 1];
I=h/2*sum(a.*y);
复化Simpson公式求定积分：
function I=squad(x,y)
%复化Simpson求积公式，其中，
%x为向量，被积函数自变量的等距结点； %y为向量，被积函数在结点处的函数值； n=length(x);
m=length(y);
%积分自变量的结点数应与它的函数值的个数相同 if rem(n-1,2)~=0
I=tquad(x,y);
return;
end
N=(n-1)/2;
h=(x(n)-x(1))/N;
a=zeros(1,n);
for k=1:N
a(2*k-1)=a(2*k-1)+1;
a(2*k)=a(2*k)+4;
a(2*k+1)=a(2*k+1)+1;
end
I=h/6*sum(a.*y);
20 exdx，取n=2,4,8,16
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a674b4470da96c1510f7f93e28e7c2c/" rel="bookmark">
			Git命令笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu下git命令学习笔记 参考视频：视频教程 GIT 结构详解 #git 的三层结构
#working directory 工作区
#staging index 暂存区
#git directory（Repository）版本库
#git中文件四种状态
#1-&gt; untracked 未被追踪 2-&gt;Modified 表示工作区修改了某个文件但还未曾被添加到暂存区
#3-&gt; staged 表示把工作区修改的文件添加到了暂存区但是还没有提交到版本库
#4-&gt; Committed 表示数据被安全的存储在本地库中
GIT 基础操作 git init #创建本地管理
git status #查看状态
git add filename #建立跟踪
git commit -m ‘message’ #提交
git config --list #查看配置信息
git log #查看提交信息
git reflog #查看历史记录
git add . #添加所有本地文件至暂存区
git commit --amend #撤销上次提交，并将暂存区的文件重新提交
git checkout --filename #切换检出,拉取暂存区的文件并替换工作区的文件，注意与git checkout branchname的区别
GIT 删除操作 git reset HEAD – 拉取最近一次提交的版本库中的filename到暂存区，该操作不影响工作区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a674b4470da96c1510f7f93e28e7c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1568970ace7df258d2d981b214222ba/" rel="bookmark">
			java poodle,SSL 3.0 POODLE攻击信息泄露漏洞(CVE-2014-3566)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenSSL 1.0.1i及之前版本中使用的SSL protocol 3.0版本中存在安全漏洞，该漏洞源于程序使用非确定性的CBC填充。攻击者可借助padding-oracle攻击利用该漏洞实施中间人攻击，获取明文数据。
测试代码：(1.0)
import ssl,socket,sys
SSL_VERSION={
'SSLv3':ssl.PROTOCOL_SSLv3,
}
def check_ssl_version(version):
try:
https = ssl.SSLSocket(socket.socket(),ssl_version=SSL_VERSION.get(version))
c = https.connect((ip,port))
print version + ' Supported'
return True
except Exception as e:
return False
USAGE = '==========\nKPoodle - SSL version and poodle attack vulnerability detect tool\n==========\nUsage: python kpoodle.py target port(default:443)\n\nby kingx'
try:
ip = sys.argv[1]
except:
print USAGE
sys.exit()
try:
port = int(sys.argv[2])
except:
port = 443
try:
report_file = sys.argv[3]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1568970ace7df258d2d981b214222ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92e63e6ac17b99079b1508173e3d6dc/" rel="bookmark">
			(原创) 解秘 Node.js 单线程实现高并发请求原理，以及串联同步执行并发请求的方案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个支持多进程请求的 Node 服务，要支持多并发请求，而且请求要按先后顺序串联同步执行返回结果。
对，这需求就是这么奇琶，业务场景也是那么奇琶。
需求是完成了，为了对 Node.js 高并发请求原理有更深一些的理解，特意写一篇文章来巩固一下相关的知识点。
问题 Node.js 由这些关键字组成：事件驱动、非阻塞I/O、高效、轻量。
于是在我们刚接触 Node.js 时，会有所疑问：
为什么在浏览器中运行的 JavaScript 能与操作系统进行如此底层的交互？
Node 真的是单线程吗？
如果是单线程，他是如何处理高并发请求的？
Node 事件驱动是如何实现的？
下来我们一起来解秘这是怎么一回事！
架构一览 上面的问题，都挺底层的，所以我们从 Node.js 本身入手，先来看看 Node.js 的结构。
Node.js 标准库，这部分是由 Javascript编写的，即我们使用过程中直接能调用的 API。在源码中的 lib 目录下可以看到。
Node bindings，这一层是 Javascript 与底层 C/C++ 能够沟通的关键，前者通过 bindings 调用后者，相互交换数据。
第三层是支撑 Node.js 运行的关键，由 C/C++ 实现。
V8：Google 推出的 Javascript VM，也是 Node.js 为什么使用的是 JavaScript 的关键，它为 JavaScript 提供了在非浏览器端运行的环境，它的高效是 Node.js 之所以高效的原因之一。
Libuv：它为 Node.js 提供了跨平台，线程池，事件池，异步 I/O 等能力，是 Node.js 如此强大的关键。
C-ares：提供了异步处理 DNS 相关的能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92e63e6ac17b99079b1508173e3d6dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d41adaec54fea78c071573f5923ebbef/" rel="bookmark">
			php实现唯一登录,利用php怎么实现一个生成唯一id功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用php怎么实现一个生成唯一id功能
发布时间：2020-12-18 15:07:44
来源：亿速云
阅读：70
作者：Leah
这篇文章给大家介绍利用php怎么实现一个生成唯一id功能，内容非常详细，感兴趣的小伙伴们可以参考借鉴，希望对大家能有所帮助。
1、md5(time() . mt_rand(1,1000000));
这种方法有一定的概率会出现重复
2、php内置函数uniqid()
uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID.
w3school参考手册有一句话:"由于基于系统时间，通过该函数生成的 ID 不是最佳的。如需生成绝对唯一的 ID，请使用 md5() 函数"。
下面方法返回结果类似：5DDB650F-4389-F4A9-A100-501EF1348872function uuid() {
if (function_exists ( 'com_create_guid' )) {
return com_create_guid ();
} else {
mt_srand ( ( double ) microtime () * 10000 ); //optional for php 4.2.0 and up.随便数播种，4.2.0以后不需要了。
$charid = strtoupper ( md5 ( uniqid ( rand (), true ) ) ); //根据当前时间(微秒计)生成唯一id.
$hyphen = chr ( 45 ); // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d41adaec54fea78c071573f5923ebbef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5f78c3474e18a6cd4607d9994b76ea/" rel="bookmark">
			JavaScript的期约（Promise）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期约（Promise) 期约的状态代表期约是否完成,有三种状态:
待定（pending）: 表示尚未开始或者正在执行中。
兑现（fulfilled，有时候也称为“解决”，resolved）: 表示已经成功完成。
拒绝（rejected）: 则表示没有成功完成，也就是已经失败。
在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。每个期约只要状态切换为兑现（fulfilled），就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝（rejected），就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为undefined。在期约到达某个落定(settled)状态时执行的异步代码始终会收到这个值（value）或理由（reason）。
Promise.resolve() 通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。
//下面两个期约实例实际上是一样的: let p1 = new Promise((resolve, reject) =&gt; resolve()); let p2 = Promise.resolve(); 这个解决的期约的值（value）对应着传给Promise.reslove()的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约:
setTimeout(console.log, 0, Promise.resolve()); //Promise {&lt;resolved&gt;: undefined} setTimeout(console.log, 0, Promise.resolve(3)); //Promise {&lt;resolved&gt;: 3} //多余的参数会忽略 setTimeout(console.log, 0, Promise.resolve(3, 4, 5)); //Promise {&lt;resolved&gt;: 3} Promise.resolve()可以说是一个幂等方法。所谓的幂等是指多个请求返回相同的结果。用数学表单的话: X^Y = X
let p = Promise.resolve(6); setTimeout( console.log, 0, p === Promise.resolve(p)); // true setTimeout( console.log, 0, p === Promise.resolve(Promise.resolve(p))); // true Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5f78c3474e18a6cd4607d9994b76ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d47aeb0660dbc6b43607a9c9e1a7c70/" rel="bookmark">
			element的el-input-number的默认值的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-input-number默认值为0 的问题
很多时候我们需要用到el-input-number来限制输入框智能输入数字，例如价格之类的，但是用了e l-input-numer的时候把默认值设为空和null都不生效，默认的值仍然显示0
&lt;el-input-number :controls="false" :precision="2" :min="0" :max="100000000" v-model="price" &gt;&lt;/el-input-number&gt;
data(){ return { price:undefined } } precision 代表的是保留小数点几位 min和max代表最大和最小输入值
controls 代表是否显示前后加减箭头
其实只要默认值设置为undefined，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f393ef16edc04a29cda7c1834b25bceb/" rel="bookmark">
			怎么用matlab建立一个魔方,Matlab学习笔记(2)矩阵与魔方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、输入矩阵
开始学习Matlab最好就是先知道如何输入矩阵
你可以依照以下几种方法进行输入矩阵：
1、直接输入矩阵的显式列表
2、从外部数据文件导入矩阵
3、利用方法来生成矩阵
4、利用M文件中自己写的方法来生成矩阵
输入矩阵，你必须遵守以下几条规则：
1、用空格或者逗号把同一行的数据分开
2、用分号把每一行的最后数据标示出来
3、用[ ]把整个数据围起来
比如
A = [16 3 2 13; 5 10 11 8; 9 6 7 12; 4 15 14 1]
Matlab会立即显示你刚输入的矩阵如下：
A =
16 3 2 13
5 10 11 8
9 6 7 12
4 15 14 1
这其实就是一个魔方。
二、求和、转置矩阵、对角矩阵
你可能意识到了这个魔方的特征，那就是假如你对任意一行或一列、或者任意一个对角数据求和，其结果都是一样的。让我们用Matlab来表示这些。你所用到的第一个表达式就是
sum(A)
Matlab回应为：
ans=
34 34 34 34
当我们没有指定输出变量时，Matlab就会使用ans(answer的缩写)变量来表示运算的结果。您计算了每一列向量的和值均为34。
那么行向量的和值呢?
Matlab优先对列向量进行运算。要求得行向量的值最简单的方法就是将原矩阵进行转置运算，计算其行向量的和值，再将结果进行转置。我们一般用省略号或一个引用 ' 来实现转置操作。
所以：
A‘
将会生成：
ans =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f393ef16edc04a29cda7c1834b25bceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6cff677628b6917f3ff0982fea85a43/" rel="bookmark">
			Sqlserver删除表中冗余数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97ec13ca5b6ed5f47860da4285083ef/" rel="bookmark">
			Android Toast介绍及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Toast 一、控件介绍二、具体实例 一、控件介绍 Toast是Android系统提供的轻量级信息提醒机制，用于向用户提示即时消息，它显示在应用程序界面的最上层，显示一段时间后自动消失不会打断当前操作，也不获得焦点。
使用Toast提示信息的实例代码:
Toast.makeText(Context,Text,Time),show(); 这段代码首先调用了Toast的makeText方法用来设置提示信息，Context:表示应用程序环境的信息，就是当前组件的上下文环境，
如果在Activity中使用的话，那么该参数可设置为"Activity.this",
Text:表示你需要提示的信息，
Time:表示提示信息的时长，其属性值有"LENGTH_SHORT 和 LENGTH_LONG"，这两个值分别表示“短时间”，“长时间”，
然后调用了show方法来讲提示信息显示到界面中。
二、具体实例 例如"你要提示用户wifi已断开的信息"
Toast.makeText(MainActivity.this,"WIFI已断开",Toast.LENGTH_SHORT).show(); 上图为运行结果，默认情况下，Tomat消息会显示在屏幕的下方，它多适用于信息提醒，比如网络未连接，用户名密码输入错误或者退出应用程序等场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b930ded0d068c31df0d18190870d41d/" rel="bookmark">
			微信小程序云开发:从0打造云音乐全栈小程序学习计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写自定义目录标题 1. 云开发与Serverless–2021.03.31 2. 播放功能列表实现-2021.04.15 3. 播放器功能实现-2021.4.30 4. 发现功能列表实现-2021.5.15 5. 评论与分享-2021.5.30 6. 我的功能实现-2021.6.15 7. 小程序高级知识-2021.6.30 8. 后台管理系统 -2021.7.15 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4190ccc76751b670708f9e9313418800/" rel="bookmark">
			element的可展开表格点击行数据的时候获取父级数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很多实际业务和需求在用element表格的时候其实是需要用到可展开的表格的，例如我最近遇到的一个需求
章下面会分为很多节，如果我编辑的是节类型的话，那我需要同时传递章ID和节ID，这个时候我就需要拿到这一节的章的ID，代码来说就是我需要拿到点击的当前行的父级数据
rowClick(val){ this.tableData.forEach((item) =&gt; { //判断该行是否有子节点 if ("classList" in item) { //遍历子节点 item.classList.forEach((item2) =&gt; { //判断该节点是否为我点击的节点 if (item2 == val) { // console.log(item2) // 章ID this.chapterId = item.id } }); } }); } // classList 是数据的子节点的集合名称，可以根据实际字段自己修改，item2即点击的这一条数据。item就是我们要拿到的父级的数据了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb448c5d3df3f041cda02b00aaec2de/" rel="bookmark">
			三剑客之grep命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 grep介绍 ps aux --sort=cpu ###查看进程排序cpu的 ps aux --sort=cpu |grep ssh grep命令主要用于过滤文本，grep家族如下
grep： 在文件中全局查找指定的正则表达式，并打印所有包含该表达式的行 egrep：扩展的egrep，支持更多的正则表达式元字符 fgrep：固定grep(fixed grep)，有时也被称作快速(fast grep)，它按字面解释所有的字符 grep命令格式如下
grep [选项] PATTERN 文件1 文件2 ... [root@egon ~]# grep 'root' /etc/passwd [root@egon ~]# fgrep 'bash' /etc/passwd 找到：	grep返回的退出状态为0 没找到：	grep返回的退出状态为1 找不到指定文件：	grep返回的退出状态为2 grep 命令的输入可以来自标准输入或管道，而不仅仅是文件，例如：
ps aux |grep 'nginx' 二 选项 -n, --line-number 在过滤出的每一行前面加上它在文件中的相对行号
-o, --only-matching 只显示匹配的内容
-q, --quiet, --silent 静默模式，没有任何输出，得用$?来判断执行成功没有，即有没有过滤到想要的内容
–color 颜色
-i, --ignore-case 忽略大小写
-A, --after-context=NUM 如果匹配成功，则将匹配行及其后n行一起打印出来
-B, --before-context=NUM 如果匹配成功，则将匹配行及其前n行一起打印出来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb448c5d3df3f041cda02b00aaec2de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7966125e45a17df63bca8272adb436d3/" rel="bookmark">
			mysql 添加rownum,给mysql加下 rownum _转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给mysql加上 rownum _转
转
http://home.21cto.com/forum_topic.php?forum_id=2&amp;topic_id=22
给mysql 表加入rownum!!!
SELECT @rownum := @rownum +1 nowef,p.*
from emp p,
(select @rownum := 0) e
ORDER BY p.empno DESC;
+-------+-------+--------+-----------+------+------------+---------+---------+--------+
| nowef | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | deptno |
+-------+-------+--------+-----------+------+------------+---------+---------+--------+
| 1 | 7369 | SMITH | CLERK | 7902 | 1980-10-10 | 800.00 | NULL | 20 |
| 2 | 7499 | ALLEN | SALESMAN | 7698 | 1981-10-10 | 1600.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7966125e45a17df63bca8272adb436d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbb9d57a2e93c317b2ded8b402dd80f/" rel="bookmark">
			Uniy3D取消导入资源默认压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity导入资源都会默认压缩，这样有一定几率导致导入的资源效果与原始有一些差异，图中取消即可解除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19161a29e0ca03bcaf40f4202a8bdaf/" rel="bookmark">
			安装arcgis10.0出现localhost上运行的许可管理器版本不正确
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天卸了ArcGIS10.1，准备安装ArcGIS10.0时总是出现localhost上运行的许可管理器版本不正确这个问题，在网上找到这个答案，试了下确实可行，在这里记录下，免得下次再走弯路。。。为此我还重装了系统，结果发现依然出现这个问题，血泪史啊。。。。
把ArcGIS的许可指到本机（服务设为@localhost或者机器名），通过修改注册表实现。
64位机器：
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\ESRI\License10.0]
“DESKTOP_CONFIG”=“TRUE”
“TIMEOUTWARNING”=“TRUE”
“SEAT_PREFERENCE”=“Float”
“SingleUse_Installed”=“Professional”
“SOFTWARE_CLASS”=“Professional”
“LICENSE_SERVER”="@localhost"
“FlexNetService”=“True”
&lt;上述内容复制到记事本，然后修改文件名为regArcGIS.reg双击&gt;
32位机器：
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SOFTWARE\ESRI\License10.0]
“DESKTOP_CONFIG”=“TRUE”
“TIMEOUTWARNING”=“TRUE”
“SEAT_PREFERENCE”=“Float”
“SingleUse_Installed”=“Professional”
“SOFTWARE_CLASS”=“Professional”
“LICENSE_SERVER”="@localhost"
“FlexNetService”=“True”
&lt;上述内容复制到记事本，然后修改文件名为regArcGIS.reg双击&gt;
注册表添加后你会发现名字会是localhost
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6af7f29867a110124a44c0bb132ab3/" rel="bookmark">
			如何用matlab进行脑电信号处理,基于matlab的脑电信号处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调用noise_reduce.m文件，可以实现脑电信号的小波变换默认阈值去噪处理，原始数据及去噪处理结果对比如下图7所示。
图7 原始信号与小波默认阈值去噪结果图的对比
从原始脑电信号与去噪处理后的效果来看，经去噪处理后的信号高频信号有所减少。 2.5.2
小波变换强制去噪处理
调用wavelet_rec.m文件，绘制小波变换强制去噪处理之后的信号如下图8所示。
图8原始信号与小波强制去噪结果图的对比
该图表示的是除去了低频干扰和高频噪声之后的结果，从与原始信号的对比中可以看出，高频噪声很明显被消除了。但由于考虑到实际情况，16~32Hz子带内极少有β波，大部分为噪声，所以把这个频带内的信号也全部清除了。
3 讨论
基于FFT变换的功率谱估计适用于平稳时间信号分析,计算结果只能反映信号段总体的平均功率分布情况, 不包含信号的任何时域变化信息, 并且谱估计的频率分辨率与所采用的信号长度成正比，即受数据点数目的影响。
基于小波变换的去噪方法，对非平稳信号去噪，要比传统的滤波去噪声得到的效果好，主要是由于传统的滤波器都具有低通性，对需要分析在每个时刻含有不同频率成分的非平稳信号来说，是很难对它进行匹配分析。而小波变换具有多分辨率，且在时频域都具有局部性，因此很适合用来分析非平稳信号。在用小波分析来进行去噪的关键在于阈值的选取，如果阈值选取的太高，会使信号失去太多细节，使信号失真，如果阈值选得太低，又不能达到去噪的目的。
4 结论
本文利用实测的原始脑电信号, 对脑电信号的处理方法与结果进行了一定的分析和评
价, 以期为脑电信号处理及特征提取提供一定的理论参考和分析依据。目前人们也尝试用非线性处理方法、神经网络的方法、时频结合等等现代的方法来处理脑电信号, 相信这些方法会为脑认知以及医学的发展作出贡献[5]。
脑电信号属于非平稳随机信号，小波分析的方法可以直接对信号的某些频率分量进行观察或者提取出有用的特征信号，为脑电信号的测量与分析提供了非常好的前景。
参考文献:
[1] [2] [3] [4] [5]
余学飞.现代医学电子仪器原理与设计[M].广州:华南理工大学出版社,2007.133~134. 张德峰.MATLAB小波分析[M].北京:机械工业出版,2012. 万永革.数字信号处理的MATLAB实现[M].北京:科学出版社,2012.
于兰兰. 基于小波变换的脑电信号去噪处理[J].南昌大学学报(理科版),2007,31:75~77.
谢松云,张振中,杨金孝,张坤.脑电信号的若干处理方法研究与评价[J].计算机仿真,2007,24(2):326~330.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12b5070d0c6b88b8abd44e8b0228eabc/" rel="bookmark">
			mysql sharding proxy,sharding-proxy之操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单库单表
第一步：修改conf/server.yaml
第二步：修改conf/config-sharding.yaml
解释：：
actualDataNodes: ds_${0}.t_order_${0..1}：会在demo_ds_0这个数据库中创建二张表：t_order_0和t_order_1。
algorithmExpression: t_order_${order_id % 2}：分表，主要是把添加的数据放入到哪张表中。这里采用取模的方式进行分表。在这里要 注意一下 ： order_id必须是整数，不能是字符串，如果是字符串的数字的话，可以通过如下进行转换：Integer.parseInt(order_id)
algorithmExpression: ds_${0} ： 分库，因为这里是单库，所以这里不采用任何的方式进行分库。
第三步：启动sharding-proxy
windows系统下运行：bin/start.bat
linux系统执行：bin/start.sh
默认的端口是：3307
第四步：创建相应的表
sharding-proxy启动成功之后，进行cmd命令行界面,输入如下信息：
然后就是输入你在配置conf/server.yaml文件中的users中的root里的password密码了。
然后使用：show databases; 查看当前有什么逻辑库。
上图的逻辑库是：conf/server.yaml中的authorizedSchemas所对应的test。
然后再执行：use test;
你可以执行：show tables;查看当前库有没有表。
下面创建对应的表：
上面的表结构字段比较少，你可以根据自己的需求来进行添加。
最后一步：测试
往刚刚创建的表添加一些测试数据：
上面的数据会放入到t_order_0表还是t_order_1表呢？
在配置conf/config-sharding.yaml文件时，里面的分表结构是这样的：algorithmExpression: t_order_${order_id % 2}，可以看出是通过添加数据的order_id取模 2 进行划分表的。那这样的话，上面添加的数据可以得出：order_id = 1 取模 2 之后是 1 ，所以上面添加的数据是放入到了t_order_1这张表中。
再来一次试一下：
这条order_id 取模 2 之后是 0，所以该数据放在t_order_0这张表中。
单库单表扩展
上面采用分表是分成两张表，假设我们有100万的数据量，如果你采用的mysql数据库的话，当数据表中数据量越大了，会影响到你查询出来的语句很慢。而我们上述分成了两张表，100万的数据量，每张表分得50万的数据。这样子总比一张表好是吧。
那怎么样分成更多的表呢？
分成十张表
分成十张表的规则就是：
修改conf/config-sharding.yaml:
这里主要是使用order_id的尾数进行划分表。
我目前能想到的就是十张表，你如果能使用单库划分十张以上的表的话，可以跟我说一下，谢谢。
多库单表
第一步：修改conf/server.yaml
第二步：修改conf/config-sharding.yaml
自行在3306端口的mysql中创建好demo_ds_0和demo_ds_1两个数据库。
第三步：启动sharding-proxy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12b5070d0c6b88b8abd44e8b0228eabc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4770b0c266d836c7dcf2cfb138cfdb/" rel="bookmark">
			用matlab解决马尔可夫模型,MatLa工具箱b 马尔可夫模型的MatLab程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		普查工具箱包括5个与隐马尔可夫模型相干的函数：
hmmgenerate从一个马尔可夫模型发生一个事态序列和输出序列；
hmmestimate计算迁移和输出的极大似然估计；
hmmtrain从一个输出序列计算迁移和输出概率的极大似然估计；
hmmviterbi计算一个隐马尔可夫模型最可能的事态改变过程；
hmmdecode计算一个给定输出序列的后验事态概率。
下面局部推荐如何利用这些函数来分析隐马尔可夫模型。
1. 发生一个测验序列
下面代码发生上面简介中模型的迁移和输出矩阵：
TRANS = [.9 .1; .05 .95;];
EMIS = [1/6, 1/6, 1/6, 1/6, 1/6, 1/6;...
7/12, 1/12, 1/12, 1/12, 1/12, 1/12];
要从模型发生一个随机的事态序列和输出序列，利用hmmgenerate：
[seq,states] = hmmgenerate(1000,TRANS,EMIS);
输出中，seq是输出序列，states是事态序列。hmmgenerate在第0步从事态1开始，在第一步迁移到事态i1
，并归来i1作为事态的第一个入口。
2. 估计事态序列
给定了迁移和输出矩阵TRANS和EMIS，函数hmmviterbi利用Viterbi算法计算模型给定输出序列seq最有可能
穿越的事态序列：
likelystates = hmmviterbi(seq, TRANS, EMIS);
likelystates是和seq一样长的序列。计算hmmvertibi的精度如下：
sum(states == likelystates) / length(states)
ans =
0.8680
3. 估计迁移和输出矩阵
函数hmmestimate和hmmtrain用于估计给定输出序列seq的迁移和输出矩阵TRANS和EMIS。
利用hmmestimate
[TRANS_EST, EMIS_EST] = hmmestimate(seq, states)
TRANS_EST =
0.9065 0.0935
0.0406 0.9594
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf4770b0c266d836c7dcf2cfb138cfdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/673a2a649d0908a328d3fb7a5ac61f50/" rel="bookmark">
			解决编译BALM过程中找不到livox_ros_driver文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译github上的代码BALM时出现了找不到"livox_ros_driver"的错误: 在此之前已根据说明编译成功了livox_ros_driver
尝试了(1)在CMakeLists文件中添加"livox_ros_driver"的路径;(2)在~/.bashrc中添加source xxx/devel/setup.bash(xxx是livox_ros_driver根目录所在路径)的方法都没有起到作用.
然后在github的Issue1和Issue2中都找到了类似问题的解决方法,给出的说法是没有source"livox_ros_driver".于是我在livox_ros_driver的根目录下source devel/setup.bash,再去BALM的根目录下catkin_make依旧报错(其实这么做我自己也觉得无用),因为source devel/setup.bash只在当前终端生效
方法一:
把整个BALM文件夹复制到livox_ros_driver的src文件夹下,再在根目录下分别执行source devel/setup.bash和catkin_make便顺利编译通过
方法二:
在BALM项目的根目录打开终端,在此终端下source livox_ros_driver的bash文件,如source ~/xxx/livox_ros_driver/devel/setup.bash,然后再catkin_make即可顺利编译BALM
放一张same_position.bag数据包运行的效果图, 不得不说效果真不错啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e16b54d1a0d40580c53e573b8045f1/" rel="bookmark">
			马尔可夫预测matlab编程,马尔科夫决策过程的matlab编程实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实例简介】
matlab平台下实现的MDP过程，供相关研究者学习
【实例截图】
【核心代码】
e946eb82-9756-4de0-9621-9e6907e4c826
├── Markov Decision Process matlab程序
│ └── Markov Decision Process(MDP)
│ ├── approxeq.m
│ ├── assert.m
│ ├── demo_russell.m
│ ├── demo_sutton.m
│ ├── mk_grid_world.m
│ ├── mk_grid_world_simple.m
│ ├── policy_iteration.m
│ ├── Q_from_V.m
│ ├── README.txt
│ ├── subv2ind.m
│ ├── test1.m
│ ├── value_determination.m
│ └── value_iteration.m
├── Markov Decision Process(MDP)
│ ├── approxeq.m
│ ├── assert.m
│ ├── demo_russell.m
│ ├── demo_sutton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30e16b54d1a0d40580c53e573b8045f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571780144dec88cff97cea05bf8f6927/" rel="bookmark">
			polyval matlab 怎么用,matlab 中polyval的用法 最好能举个例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(3)多项式求值(polyval): 将多项式a中的自变量x 赋予值xv时，
该多项式的值可用
f=polyval (a，xv)
求得，其中xv可以是复数，而且可以是矩阵或 数组，此时polyval对输入变元作元素群运算， 这对于求线性系统的频率特性特别方便。 polyvalm 则对输入的变元阵方阵作矩阵多项式 运算。
【例4-3-2】 设a为系统分母系数向量，b为系统分子系数向量，求此系统的频率响应并画出频率特性。先令频率数组w取线性间隔: w=linspace(0,10);
%在w等于0~10之间按线性间隔取100点(默认值) a=polyval(a，j*w);
%分别求分母分子多项式的值(为复数数组) b=polyval(b，j*w); subplot(2,1,1); plot(w，abs(b./a))
%画两者元素群相除所得的幅频特性 subplot(2,1,2); plot(w，angle(b./a))
%画相频特性
频率特性通常在对数坐标中绘制。
因此输入频率数组取对数等间隔: w1=logspace(-1,1) %在w1从10-1~10之间，按对数分割为 50点(默认值) f=polyval(b,j*w1)./polyval(a，j*w1); %求出这些点上的频率响应(复数) subplot(2,1,1)，loglog(w1，abs(f)) %在双对数坐标中画出幅频特性 subplot(2,1,2); semilogx(w1，angle(f)) %在双对数坐标(x)中画出相频特性  所得曲线如图4-3所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d390b5ddf4486176ef1d0f92c0dfd13/" rel="bookmark">
			GPU 高性能推理加速框架Forward开源啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介
Forward 是一款腾讯平台和内容事业群（PCG）研发的 GPU 高性能推理加速框架。它直接加载主流框架模型（Tensorflow / PyTorch / Keras）转换成 TensorRT 推理加速引擎，帮助用户节省中间繁杂的模型转换或网络构建步骤。相对于直接使用 TensorRT，Forward 更易用以及更容易扩展支持更多模型和算子。目前，Forward 除了覆盖支持主流的 CV，NLP 及推荐领域的深度学习模型外，还支持一些诸如 BERT，FaceSwap，StyleTransfer 这类高级模型。
行业应用 以近期的百万级 BERT 语言模型推理加速项目为例，原本需要成百上千的 CPU 资源来承载的线上推理服务，使用 Forward 推理加速技术后，能够实现原始已训练模型的无缝接入，并保持与之前线上相当的性能的情况下，能节省 40% 以上的成本，实现大幅的成本效能优化。同样地，其他业务团队（例如 QQ，腾讯看点，腾讯新闻，微视）等团队的业务模型也获得了大幅的吞吐量性能的提升。因此，我们有理由相信 Forward 有广大的需求和落地场景，尤其是在日后 GPU 资源日渐丰富的情况下，更是前景可期。
适用人群 深度学习业务模型运营人员：很多业务模型开发维护团队期望提升自己线上业务的性能，但受限于业界目前工具以及人力资源，迟迟无法提升自己的业务性能。本项目则可助力他们直接提升现有业务模型的性能。
深度学习算法开发人员：包括图像，语言，推荐等各 AI 领域的算法开发人员，经常需要开发或改良新的业务模型。受限于业内现有方案，新模型上线往往耗时耗力甚至不受支持，此时本项目的易用性和扩展性将助力提速其新模型的上线。
功能介绍 模型性能优化高：基于 TensorRT API 开发网络层级的支持，保证对于通用网络层级的推理性能优化处于最优级别。
模型支持范围广：除了通用的 CV，NLP，及推荐类模型，还支持一些诸如 BERT，FaceSwap，StyleTransfer 这类高级模型。
接口简单易用：直接导入已训练好的 Tensorflow(.pb) / PyTorch(.pth) / Keras(.h5) 导出的模型文件，隐式转换为高性能的推理 Engine 进行推理加速。
支持自研扩展：可根据业务模型自研定制扩展网络支持层级。
支持 C++ 和 Python 接口调用。
性能介绍 主流模型：由于最终是直接使用 TensorRT 推理引擎，各主流模型的性能可以参考 TensorRT 官方的 Benchmark。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d390b5ddf4486176ef1d0f92c0dfd13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c007114c50f08fc25c559fbcde8f5514/" rel="bookmark">
			解决git上传远端报错error: failed to push some refs to
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现错误的主要原因是github中的README.md文件不在本地代码目录中
解决方法：
可以通过如下命令进行代码合并【注：pull=fetch+merge]
git pull --rebase origin master
终端执行后再上传发现已经正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95198bc38b19ff0c52a49ab71f12d1f/" rel="bookmark">
			matlab 电感电容,Simulink中的电阻电容电感在哪里啊？ , matlab2007simulink中电感电容在什么位置...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单概括：电阻：限流作用，类似于接在两根大直径管子之间的小直径管子限制水流量的作用，也能保护电路。
电容：电容器是一种能够储藏电荷。
电感：主要起到滤波、振荡、延迟、陷波等作用，还有筛选信号、过滤噪声、稳定电流及抑制电磁波干扰等作用。
具体：电阻：是一个限流元件，将电阻接在电路中后，电阻器的阻值是固定的一般是两个引脚，它可限制通过它所连支路的电流大小。
阻值不能改变的称为固定电阻器。
阻值可变的称为电位器或可变电阻器。
理想的电阻器是线性的，即通过电阻器的瞬时电流与外加瞬时电压成正比。
用于分压的可变电阻器。
在裸露的电阻体上，紧压着一至两个可移金属触点。
触点位置确定电阻体任一端与触点间的阻值。
小功率电阻器通常为封装在塑料外壳中的碳膜构成，而大功率的电阻器通常为绕线电阻器，通过将大电阻率的金属丝绕在瓷心上而制成。
如果一个电阻器的电阻值接近零欧姆例如，两个点之间的大截面导线，则该电阻器对电流没有阻碍作用，并联这种电阻器的回路被短路，电流无限大。
如果一个电阻器具有无限大的或很大的电阻，则串接该电阻器的回路可看作开路，电流为零。
工业中常用的电阻器介于两种极端情况之间，它具有一定的电阻，可通过一定的电流，但电流不像短路时那样大。
电阻器的限流作用类似于接在两根大直径管子之间的小直径管子限制水流量的作用。
电阻，英文名resistance，通常缩写为R，它是导体的一种基本性质，与导体的尺寸、材料、温度有关。
欧姆定律说，I=U/R，那么R=U/I，电阻的基本单位是欧姆，用希腊字母“Ω”表示，有这样的定义：导体上加上一伏特电压时，产生一安培电流所对应的阻值。
电阻的主要职能就是阻碍电流流过。
事实上，“电阻”说的是一种性质，而通常在电子产品中所指的电阻，是指电阻器这样一种元件。
欧姆常简称为欧。
表示电阻阻值的常用单位还有千欧kΩ，兆欧MΩ，毫欧m Ω。
电容：电容器，通常简称其容纳电荷的本领为电容，用字母C表示。
定义1：电容器，顾名思义，是‘装电的容器’，是一种容纳电荷的器件。
英文名称：capacitor。
电容器是电子设备中大量使用的电子元件之一，广泛应用于电路中的隔直通交，耦合，旁路，滤波，调谐回路， 能量转换，控制等方面。
定义2：电容器，任何两个彼此绝缘且相隔很近的导体包括导线间都构成一个电容器。
●耦合：用在耦合电路中的电容称为耦合电容，在阻容耦合放大器和其他电容耦合电路中大量使用这种电容电路，起隔直流通交流作用。
●滤波：用在滤波电路中的电容器称为滤波电容，在电源滤波和各种滤波器电路中使用这种电容电路，滤波电容将一定频段内的信号从总信号中去除 。
●退耦：用在退耦电路中的电容器称为退耦电容，在多级放大器的直流电压供给电路中使用这种电容电路，退耦电容消除每级放大器之间的有害低频交连 。
●高频消振：用在高频消振电路中的电容称为高频消振电容，在音频负反馈放大器中，为了消振可能出现的高频自激，采用这种电容电路，以消除放大器可能出现的高频啸叫 。
●谐振：用在LC谐振电路中的电容器称为谐振电容，LC并联和串联谐振电路中都需这种电容电路 。
●旁路：用在旁路电路中的电容器称为旁路电容，电路中如果需要从信号中去掉某一频段的信号，可以使用旁路电容电路，根据所去掉信号频率不同，有全频域所有交流信号旁路电容电路和高频旁路电容电路 。
●中和：用在中和电路中的电容器称为中和电容。
在收音机高频和中频放大器，电视机高频放大器中，采用这种中和电容电路，以消除自激。
●定时：用在定时电路中的电容器称为定时电容。
在需要通过电容充电、放电进行时间控制的电路中使用定时电容电路，电容起控制时间常数大小的作用 。
●积分：用在积分电路中的电容器称为积分电容。
在电势场扫描的同步分离电路中，采用这种积分电容电路，可以从场复合同步信号中取出场同步信号 。
●微分：用在微分电路中的电容器称为微分电容。
在触发器电路中为了得到尖顶触发信号，采用这种微分电容电路，以从各类主要是矩形脉冲信号中得到尖顶脉冲触发信号 。
●补偿：用在补偿电路中的电容器称为补偿电容，在卡座的低音补偿电路中，使用这种低频补偿电容电路，以提升放音信号中的低频信号，此外，还有高频补偿电容电路 。
●自举：用在自举电路中的电容器称为自举电容，常用的OTL功率放大器输出级电路采用这种自举电容电路，以通过正反馈的方式少量提升信号的正半周幅度。
●分频：在分频电路中的电容器称为分频电容，在音箱的扬声器分频电路中，使用分频电容电路，以使高频扬声器工作在高频段，中频扬声器工作在中频段，低频扬声器工作在低频段 。
●负载电容：是指与石英晶体谐振器一起决定负载谐振频率的有效外界电容。
负载电容常用的标准值有16pF、20pF、30pF、50pF和100pF。
负载电容可以根据具体情况作适当的调整，通过调整一般可以将谐振器的工作频率调到标称值。
电感：电感在电路最常见的作用就是与电容一起，组成LC滤波电路。
电容具有“阻直流，通交流”的特性，而电感则有“通直...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5600e212cbe1eb6e0cb2fb0fc687f8/" rel="bookmark">
			MATLAB约当标准型,用MATLAB求其约当标准型状态空间表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统的传递函数为
试用MATLAB求其约当标准型状态空间表达式。
&gt;&gt; num=[2,1];
&gt;&gt; den=[1 7 14 8];
&gt;&gt; [A,B,C,D]=tf2ss(num,den);
&gt;&gt; L=eig(A);
&gt;&gt; K1=L(1)*eye(3)-A;
&gt;&gt; syms p11 p12 p13
&gt;&gt; f=K1*[p11;p12;p13];
&gt;&gt; p11=1;
&gt;&gt; p12=solve(subs(f(2)));
&gt;&gt; p13=solve(subs(f(3)));
&gt;&gt; p1=[p11;p12;p13];
&gt;&gt; K2=L(2)*eye(3)-A;
&gt;&gt; syms p21 p22 p23
&gt;&gt; f=K2*[p21;p22;p23];
&gt;&gt; p21=1;
&gt;&gt; p22=solve(subs(f(2)));
&gt;&gt; p23=solve(subs(f(3)));
&gt;&gt; p2=[p21;p22;p23];
&gt;&gt; K3=L(3)*eye(3)-A;
&gt;&gt; syms p31 p32 p33
&gt;&gt; f=K3*[p31;p32;p33];
&gt;&gt; p31=1;
&gt;&gt; p32=solve(subs(f(2)));
&gt;&gt; p33=solve(subs(f(3)));
&gt;&gt; p3=[p31;p32;p33];
&gt;&gt; T=[p1,p2,p3];
&gt;&gt; A0=inv(T)*A*T
A0 =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5600e212cbe1eb6e0cb2fb0fc687f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79aeb82fbbabf07219c375805cd6313/" rel="bookmark">
			vs 错误 将环境变量 “ TraceDesignTime“ 设置为 true 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vs 错误 将环境变量 " TraceDesignTime" 设置为 true 解决方案
参考文章：
（1）vs 错误 将环境变量 " TraceDesignTime" 设置为 true 解决方案
（2）https://www.cnblogs.com/eat-too-much/p/10847872.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d716183af9529a73fb8709ec8fd5f8/" rel="bookmark">
			关于＜Element * at 0x******＞如何查看标签中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于&lt;Element * at 0x******&gt;如何查看标签中的数据 from lxml import etree import requests url = 'https://www.pearvideo.com/' # 首页地址 data = { } headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " "AppleWebKit/537.36 (KHTML, like Gecko) " "Chrome/89.0.4389.82 Safari/537.36" } session = requests.Session() page_one = session.get(url, headers=headers).text # page_one.encoding = 'utf-8' print('-------首页请求成功--------') tree = etree.HTML(page_one) page_list = tree.xpath('//*[@id="navbar"]/ul/li') for li in page_list: # todo 方法1 page_list_li = li.xpath('./a/@href') # @href采用定位的方式	找到需要的key对应的值 print(li[0].text) # 直接获取li下面的文本 print(li[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d716183af9529a73fb8709ec8fd5f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041a7344c8d861abe87f265def858d16/" rel="bookmark">
			-----已搬运-------【附件】python脚本提交 url编码的%00问题 以及 ascii(0)和 chr(0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是在看sql注入的时候看到的
当所有注释符和单引号都被过滤的时候，我们没有办法进行闭合语句的时候
这时候如果PHP版本较低，那么可能会有%00截断，然后
我们就可以用;%00这样的方式进行上传url的get或者post参数。进而实现mysql语句的闭合，达成了类似于注释的效果。
然后通常要写python脚本，这个用来regexp正则注入，python脚本提交%00的时候，会有些问题，这里是post传入%00的时候，用下面这两个方法都是可以的
parse.unquote('%00')或者chr(0)。是同一个东西。
然后这里%00实质就是那个不可见字符，你直接post传进去，传入个不可见字符得了，你先给他unquote了，先url解码了，就行了，不弄
这个也是 ascii中的0
这个讲unquote和urlencode，讲的可好了
。urlencode可以对字典类型的
unquote是对单个字符的。
unquote 对单个字符应该都是这个东西，弄得，不然就是那个urlencode来的
paramArr = {'type': 0, 'sex': 1} print(parse.urlencode(paramArr)) paramArrSign = 'oznza2zpxwSsJAt++vppkOcm/GEVRQ8/ZrHlNyvuHK8=' quote_text = parse.quote(paramArrSign) print(quote_text) print(parse.unquote(quote_text)) 也是
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f231d65ced93805cfe32fd544037e41/" rel="bookmark">
			String中截取部分内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前开发的项目中，需要实现的一个需求就是根据返回的字符串，截取其中的一部分显示。服务器返回的数据为：上班时间 08:00
但是UI需要显示的是：08:00 所以记录一下方法：
let standTime = item.correct_time.substring(4, (item.correct_time.length)) console.log("------&gt;上班时间为："+standTime) substring(a,b) a代表的是字符串中的起始位置，b代表的是结束位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7db19fc2160a84bd33501ec3922f20/" rel="bookmark">
			VUE3 自定义 网页标题与图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VUE3 自定义 网页标题与图标 1 做一个名为 favicon.ico的logo图 放在 /public/下面，替换原有的 favicon.ico，同时删除 /public/img/所有图片。
2 根目录下新建vue.config.js，
module.exports = { pwa: { iconPaths: { favicon32: 'favicon.ico', favicon16: 'favicon.ico', appleTouchIcon: 'favicon.ico', maskIcon: 'favicon.ico', msTileImage: 'favicon.ico' } } }; 3 重启项目 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19e6700c3fa2224d760cadbaebfecff/" rel="bookmark">
			java做一个登陆界面难点,用Ajax做的一个登陆界面，focus()不起作用解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JScript code
var xmlHttpReq = false;
//创建XMLHttpRequest对象
function createXMLHttpRequest() {
if (window.XMLHttpRequest) {//非IE浏览器
XMLHttpReq = new XMLHttpRequest();
} else if (window.ActiveXobject) {//IE浏览器
try {
XMLHttpReq = new ActiveXobject("Maxml2.XMLHTTP");
} catch (e) {
try {
XMLHttpReq = new ActiveXobject("Microsoft.XMLHTTP");
} catch (e) {
}
}
}
}
function sendRequest(url) {
createXMLHttpRequest();
XMLHttpReq.open("GET", "url", true);
XMLHttpReq.onreadyStatechange = processResponse;//指定响应函数
XMLHttpReq.send(null);
}
function processResponse() {
if (XMLHttpReq.readyState == 4) {
if (XMLHttpReq.status == 200) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19e6700c3fa2224d760cadbaebfecff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8180ab0af84205557df20edd32b2e175/" rel="bookmark">
			KITTI数据集bin转化为bag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 KITTI数据集bin转化为bag
参考链接：
数据集中必须包含times.txt**!!!**
（1）（2）都提到的阿里员工转化工具lidar2rosbag_KITTI
https://github.com/AbnerCSZ/lidar2rosbag_KITTI
（1）关于KITTI数据中点云bin文件转成rosbag包的方法
https://blog.csdn.net/Mr_yangsir/article/details/107354185
（2）KITTI数据集转化为ROS bag包（解决各种类型数据集，实测有效）
https://blog.csdn.net/m0_45388819/article/details/114405418?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242
如果遇到LZ4_stream_t, LZ4_streamDecode_t build error错误可以通过下面链接中的方法解决
https://github.com/ethz-asl/lidar_align/issues/16
下载到工作空间catkin_ws中的功能包名称为lidar2rosbag_KITTI-master
转化时我自己的代码
$roscore $rosrun lidar2rosbag lidar2rosbag data_odometry_velodyne/dataset/sequences/00/ bag00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34da95a2b6cdf027510cdd26930d3d2f/" rel="bookmark">
			java sql解析框架,Spark SQL源码剖析（一）SQL解析框架Catalyst流程概述，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark SQL源码剖析(一)SQL解析框架Catalyst流程概述，
Spark SQL模块，主要就是处理跟SQL解析相关的一些内容，说得更通俗点就是怎么把一个SQL语句解析成Dataframe或者说RDD的任务。以Spark 2.4.3为例，Spark SQL这个大模块分为三个子模块，如下图所示
其中Catalyst可以说是Spark内部专门用来解析SQL的一个框架，在Hive中类似的框架是Calcite(将SQL解析成MapReduce任务)。Catalyst将SQL解析任务分成好几个阶段，这个在对应的论文中讲述得比较清楚，本系列很多内容也会参考论文，有兴趣阅读原论文的可以到这里看：Spark SQL: Relational Data Processing in Spark。
而Core模块其实就是Spark SQL主要解析的流程，当然这个过程中会去调用Catalyst的一些内容。这模块里面比较常用的类包括SparkSession，DataSet等。
至于hive模块，这个不用说，肯定跟hive有关的。这个模块在本系列基本不会涉及到，就不多介绍了。
值得一提的是，论文发表的时候还是在Spark1.x阶段，那个时候SQL解析成词法树用的是scala写的一个解析工具，到2.x阶段改为使用antlr4来做这部分工作(这应该算是最大的改变)。至于为什么要改，我猜是出于可读性和易用性方面的考虑，当然这个仅是个人猜测。
另外，这一系列会简单介绍一条SQL语句的处理流程，基于spark 2.4.3(sql这个模块在spark2.1后变化不大)。这一篇先从整体介绍Spark SQL出现的背景及解决问题，Dataframe API以及Catalyst的流程大概是怎么样，后面分阶段细说Catalyst的流程。
Spark SQL出现的背景及解决的问题
在最早的时候，大规模处理数据的技术是MapReduce，但这种框架执行效率太慢，进行一些关系型处理(如join)需要编写大量代码。后来hive这种框架可以让用户输入sql语句，自动进行优化并执行。
但在大型系统中，任然有两个主要问题，一个是ETL操作需要对接多个数据源。另一个是用户需要执行复杂分析，比如机器学习和图计算等。但传统的关系型处理系统中较难实现。
Spark SQL提供了两个子模块来解决这个问题，DataFrame API和Catalyst。
相比于RDD，Dataframe api提供了更加丰富的关系型api，并且能和RDD相互转换，后面Spark机器学习方面的工作重心，也从以RDD为基础的mllib转移到以Dataframe为基础的Spark ML(虽然Dataframe底层也是RDD)。
另一个就是Catalyst，通过它可以轻松为诸如机器学习之类的域添加数据源(比如json或通过case class自定义的类型)，优化规则和数据类型。
通过这两个模块，Spark SQL主要实现以下目标：
提供方便易用好的API，包括读取外部数据源，以及关系数据处理(用过的都知道)
使用已建立的DBMS技术提供高性能。
轻松支持新数据源，包括半结构化数据和外部数据库(比如MYSQL)。
图计算和机器学习方面的拓展
那下面就介绍Dataframe和Catalyst的流程，当然主要讨论的还是Catalyst。
统一API Dataframe
先来看看论文里面提供的一张图：
这张图可以说明很多，首先Spark的Dataframe API底层也是基于Spark的RDD。但与RDD不同的在于，Dataframe会持有schema(这个实在不好翻译，可以理解为数据的结构吧)，以及可以执行各种各样的关系型操作，比如Select，Filter，Join，Groupby等。从操作上来说，和pandas的Dataframe有点像(连名字都是一样的)。
同时因为是基于RDD的，所以很多RDD的特性Dataframe都能够享受到，比如说分布式计算中一致性，可靠性方面的保证，以及可以通过cache缓存数据，提高计算性能啊等等。
同时图中页展示了Dataframe可以通过JDBC链接外部数据库，通过控制台操作(spark-shell)，或者用户程序。说白了，就是Dataframe可以通过RDD转换而来，也可以通过外部数据表生成。
对了，这里顺便说一句，很多初次接触Spark SQL的童鞋可能会对Dataset和Dataframe这两个东西感到疑惑，在1.x时代它们确实有些差别，不过在spark2.x的时候，这两个API已经统一了。所以基本上Dataset和Dataframe可以看成是等价的东西。
最后还是结合代码做一下实际的展示吧，如下展示生成一个RDD，并且根据这个RDD生成对应的Dataframe，从中可以看出RDD和Dataframe的区别：
//生成RDD
scala&gt; val data = sc.parallelize(Array((1,2),(3,4)))
data: org.apache.spark.rdd.RDD[(Int, Int)] = ParallelCollectionRDD[0] at parallelize at :24
scala&gt; data.foreach(println)
(1,2)
(3,4)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34da95a2b6cdf027510cdd26930d3d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2780f9bf379f4f028526c57484e6243/" rel="bookmark">
			Android 实现搜索历史(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SharedPreferences实现本地搜索历史功能,覆盖搜索重复的文本，可清空 1. 判断搜索内容是否含表情，不需要可以不判断 /** * 校验字符串是否含有表情 * @param content * @return */ public static boolean hasEmoji(String content){ Pattern pattern = Pattern.compile("[\ud83c\udc00-\ud83c\udfff]|[\ud83d\udc00-\ud83d\udfff]|[\u2600-\u27ff]"); Matcher matcher = pattern.matcher(content); if(matcher .find()){ return true; } return false; } 2.软键盘工具类弹出、关闭，不需要可以不判断 public class KeyBoardUtils { /** * 打开软键盘 * * @param editText * @param context */ public static void openKeybord(EditText editText, Context context) { InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(editText, InputMethodManager.RESULT_SHOWN); imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY); } /** * 关闭软键盘 * @param editText * @param context */ public static void closeKeybord(EditText editText, Context context) { InputMethodManager imm = (InputMethodManager) context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2780f9bf379f4f028526c57484e6243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5857c01c76daa5d9fe0e5b2149bc162/" rel="bookmark">
			在线php序列化工具,序列化器 | Elasticsearch-PHP | Elastic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现自定义序列化器edit
如果你想使用自定义序列器，你需要实现 SerializerInterface 接口。请记住，对于所有的 endpoint 和连接来说，客户端只使用一个序列器对象。
class MyCustomSerializer implements SerializerInterface
{
/**
* Serialize request body
*
* @param string|array $data Request body
*
* @return string
*/
public function serialize($data)
{
// code here
}
/**
* Deserialize response body
*
* @param string $data Response body
* @param array $headers Response Headers
*
* @return array|string
*/
public function deserialize($data, $headers)
{
// code here
}
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5857c01c76daa5d9fe0e5b2149bc162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42e7d0286d954143ec70dfd5ab4793b/" rel="bookmark">
			Python3/Python2打印二进制数据到标准输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python2 方法一：print(data)方法二：sys.stdout.write(data) Python3 方法一：sys.stdout.buffer.write(data)
该方法可能在某些http服务中失效，因为没有sys.stdout.buffer方法二：打开标准输出文件 with os.fdopen(sys.stdout.fileno(), 'wb', closefd=False) as stdout: stdout.write(data) stdout.flush() ''' 解析： sys.stdout.fileno()：标准输出文件描述符，通常是1 closefd=False：with代码块结束后不关闭标准输出文件，避免后续无法使用标准输出 stdout.flush()：强制写入数据，避免数据在缓存区中堆积 ''' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f09f9f303b1b883d107008afeaed7c7/" rel="bookmark">
			spark.shuffle.service.enabled使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，这说的是NodeManager中一个长期在运行的辅助服务，用于提升Shuffle计算性能。默认为false，表示不启用该功能，他对计算任务本身不是很友好
之所以一般不开启，是因为它提升的只是executor在GC或者其他原因无法向外提供数据的时候，使用一个辅助服务去从executor拿数据为其他需要的地方，而且不使用它的原因，最主要的还是它的使用需要拥有外部辅助shuffle服务，比如yarn的NodeManager中的External shuffle Service服务
如果你在on yarn模式使用它，你需要在yarn-site.xml中配置如下信息
&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;spark_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.spark_shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.spark.network.yarn.YarnShuffleService&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;spark.shuffle.service.port&lt;/name&gt; &lt;value&gt;7337&lt;/value&gt; &lt;/property&gt; 对于spark来说你需要在spark-defaults.conf中添加如下配置
spark.shuffle.service.enabled true spark.shuffle.service.port 7337 这两个配置是个是开启这个任务，一个是服务的端口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a8e6a1e0343c7d016b3c0af19915b2/" rel="bookmark">
			C#winform控件的各种坐标获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、窗体 绿色边框框住的区域：屏幕橙色边框框住的区域：窗体黄色边框框住的区域：窗体工作区 1.边框 窗体的FormBorderStyle可以设置以下的值，每个值导致窗体的边框的宽度不一样，但是可以发现的是左、右、下边框的宽度是一样的：
// // 摘要: // 指定窗体的边框样式。 [ComVisible(true)] public enum FormBorderStyle { // // 摘要: // 无边框。 None = 0, // // 摘要: // 固定的单线边框。 FixedSingle = 1, // // 摘要: // 固定的三维边框。 Fixed3D = 2, // // 摘要: // 粗、 固定的对话框样式边框。 FixedDialog = 3, // // 摘要: // 可调整大小的边框。 Sizable = 4, // // 摘要: // 不是可调整大小工具窗口边框。 在任务栏中或在用户按 ALT + TAB 时出现的窗口中未显示工具窗口。 虽然窗体，用于指定 System.Windows.Forms.FormBorderStyle.FixedToolWindow // 通常不显示在任务栏中，您必须确保 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a8e6a1e0343c7d016b3c0af19915b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97973861fe4a71cba53f4e81e9def61/" rel="bookmark">
			20210311 plecs 对传递函数进行波特图分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		貌似只有multitone 和AC sweep可以，但impulse 不行~但不知道m 对效果有没有影响
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b2b1b9797abb8537c7dc0b45bf26bf/" rel="bookmark">
			股票量化分析系统浅析之（五）训练集越多越好吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于同一组测试集，使用两个不同的seed进行两次实验，这两次实验的训练集都更大，但是一次实验结果是测试集精度上升，另外一次实验结果是测试集精度下降。两组实验虽然训练集都更大，但是都不是对于小数据集的扩展，而是重新随机采样了更大的数据集。不过这两次实验的训练集是相同的。
这个现象很有意思。更大的训练集使得测试集精度上升比较好理解，但是为什么更大的训练集也会造成测试集精度下降呢？也许是因为更大的训练集包含了更多与测试集不同的分布。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50039735c831e10d25dd62344f3cd671/" rel="bookmark">
			win10修改host文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上找了几个教程发现都是修改权限，自己也试了几个，发现都不行，最后找到一个博主的文章发现很实用，所以在此记录下来。
1、首先找到host文件
2、右击菜单选择管理员
3、输入 notepad
4、在弹出的记事本中找到左上角的文件-&gt;打开，然后找到hosts文件
5、然后就可以修改了，修改完之后Ctrl+s保存就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dadcf470e41a86aa2fb5e6e6c078005a/" rel="bookmark">
			php ajax传递多个参数类型,如何使用ajax传递可变参数名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般当写作你要使用“POST”类型，而不是“GET”类型。 POST用于将数据存入数据存储区，GET用于检索数据。尽管没有更多的代码，但它很难调试，所以我会在黑暗中拍摄几张照片。
首先，清理一下代码并统一你的格式 - 把“字段”放在引号中，像你的其他项目。虽然这可能无法解决您的问题，但JSON standard实际上仅定义为使用双语句。
其次，如果我们可以看到PHP代码，这将有所帮助 - 我的猜测是响应被解释出现问题。我建议，为了进行调试，您可以运行Fiddler并检查实际的请求，以确保您将所有必需的字段发送到服务器。
一旦您更新我们的更多信息，我可以更新我的答案 - 但我会开始切换到POST。
更新 我想我误解了这个问题 - 如果你正在寻找让data.field真正被data.somefield在该属性的名称可以改变为任何你想要的，这是相当简单：
数据[字段] = mapstring
换句话说：
function writeabdata(table, id, field, mapstring) {
//alert ("table = "+table+" id = "+id+" field = \'"+field+"\' value = "+value);
var dataObj = {
'table': table,
'id': id
};
dataObj[field] = mapstring;
$.ajax({
type: 'GET',
url: 'writeabdata.php',
data: dataObj,
success: function (data) {
alert ("data Saved "+ data);
}
});
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dadcf470e41a86aa2fb5e6e6c078005a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/188/">«</a>
	<span class="pagination__item pagination__item--current">189/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/190/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>