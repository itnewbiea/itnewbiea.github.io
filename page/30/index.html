<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1cd917eff513586f528ff17818cfdc/" rel="bookmark">
			Elasticsearch基础篇(六)：es映射和常用的字段类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es创建映射和设置 一、什么是 Elasticsearch 映射？二、映射中的字段类型常见字段类型 （Common data types）对象和关联类型（Objects and relational types）结构化数据类型（Structured data types）聚合数据类型（Aggregate data types）文本搜索类型（Text search types）文档排名类型（Document ranking types）空间数据类型（Spatial data types）其他类型（other types）数组（Arrays）多字段（multi-fields） 三、映射限制 Mapping limit settings四、创建映射使用 REST API 创建映射常用映射示例和说明文本字段映射关键字字段映射日期字段映射数值字段映射地理位置字段映射 特殊映射嵌套字段多字段支持自定义分析器 五、官方文档翻译（可做）显式映射 Explicit mapping聚合度量字段类型 Aggregate metric field type别名字段类型 Alias数组 Arrays布尔字段类型 Boolean field type日期字段类型 Date日期纳秒字段类型 Date nanoseconds field type密集向量字段类型 Dense vector field type展平字段类型 Flattened field type地理点字段类型 Geopoint field type地理形状字段类型 Geo Shape Field Type直方图字段类型 Histogramip字段类型 IP父子关系字段类型 join关键字类型 Keyword type family嵌套字段类型 Nested field type数值字段类型 Numeric对象字段类型 objecdtPercolator字段类型point数据类型范围字段类型 range特征排名字段类型 rank_feature排名特征字段类型 rank_features形状 shape文本 TextToken count字段类型无符号长整数 Unsigned long版本字段类型 Version元数据字段 Metadata fields 元数据字段 Metadata fields映射参数 Mapping parameters映射限制删除映射类型 官方地址：Mapping
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b1cd917eff513586f528ff17818cfdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4633a0fd9a09115ad54f5d56dbfd3af8/" rel="bookmark">
			华为OD机试真题-田忌赛马-2023年OD统一考试（C卷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
给定两个只包含数字的数组a, b, 调整数组a里面数字的顺序，使得尽可能多的a[i] &gt; b[i]。数组a和b中的数字各不相同。
输出所有可以达到最优结果的a数组数量
输入描述：
输入的第一行是数组a中的数字，其中只包含数字，每两个数字之间相隔一个空格，a数组大小不超过10
输入的第一行是数组b中的数字，其中只包含数字，每两个数字之间相隔一个空格，b数组大小不超过10
输出描述：
输出所有可以达到最优结果的a数组数量
补充说明：
示例1
输入：
11 8 20 10 13 7 输出：
1 说明：
最优结果只有一个，a = [11, 20, 8]，故输出1
示例2
输入：
11 12 20 10 13 7 输出：
2 说明：
有两个a数组的排列可以达到最优结果，[12, 20, 11]和[11, 20, 12]，故输出2
示例3
输入：
1 2 3 4 5 6 输出：
6 说明：
a无论如何都会全输，故a任意排列都行，输出所有a数组的排列，6种排法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff2d05076a8c1fc4c1a30d58865b446/" rel="bookmark">
			Vue项目实现添加水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue项目需要实现添加水印的功能，实现如下：
引入watermark-dom依赖包 npm install watermark-dom App.vue引入 import watermark from "watermark-dom"; 初始化水印参数 mounted() { watermark.load({watermark_txt: "测试",watermark_color: '#ED8D29',watermark_width: 240}); }, 附：
watermark_id: 'wm_div_id', //水印总体的id watermark_prefix: 'mask_div_id', //小水印的id前缀 watermark_txt:"测试", //水印的内容 watermark_x:20, //水印起始位置x轴坐标 watermark_y:20, //水印起始位置Y轴坐标 watermark_rows:0, //水印行数 watermark_cols:0, //水印列数 watermark_x_space:100, //水印x轴间隔 watermark_y_space:50, //水印y轴间隔 watermark_font:'微软雅黑', //水印字体 watermark_color:'black', //水印字体颜色 watermark_fontsize:'18px', //水印字体大小 watermark_alpha:0.15, //水印透明度，要求设置在大于等于0.005 watermark_width:100, //水印宽度 watermark_height:100, //水印长度 watermark_angle:15, //水印倾斜度数 watermark_parent_width:0, //水印的总体宽度（默认值：body的scrollWidth和clientWidth的较大值） watermark_parent_height:0, //水印的总体高度（默认值：body的scrollHeight和clientHeight的较大值） watermark_parent_node:null //水印插件挂载的父元素element,不输入则默认挂在body上 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930031005776708a713b7093b2fc2fa7/" rel="bookmark">
			Vue3 &#43; ESLint &#43; Prettier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3 + ESLint + Prettier 配置规则 1 初始化项目 新建 vue-cli 项目。如果已有项目，可直接跳到最后一步。
① 在 cmd 中输入如下代码，开始创建项目。
提示：如果没有安装 vue-cli ，执行npm install -g @vue/cli安装即可。
vue create "项目名称" ② 选择 Manually select features（手动选择功能）。
③ 根据自己需求选择，这里只选择了 Linter / Formatter。
④ 选择版本。
⑤ 选择 ESLint + Prettier。
⑥ 选择 Lint on save。
⑦ 选择 In dedicated config files。
⑧ 是否将此次配置保存为未来项目的预设。
⑨ 如果项目中未安装 ESLint 和 Prettier 则需要安装如下依赖，可对照下图进行配置。
注意：请去掉 package.json 中的 "type": "module" 属性（如果它存在的话）。
npm i @babel/core -D npm i @babel/eslint-parser -D npm i @vue/cli-plugin-eslint -D npm i eslint -D npm i eslint-config-prettier -D npm i eslint-plugin-prettier -D npm i eslint-plugin-vue -D npm i prettier -D // 用到 TS 的需要加入如下依赖 npm i @typescript-eslint/eslint-plugin -D npm i @typescript-eslint/parser -D npm i @vue/cli-plugin-typescript -D npm i @vue/eslint-config-typescript -D npm i typescript -D 至此，初始化项目完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/930031005776708a713b7093b2fc2fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683f66e5639282b26fddc08710d6af38/" rel="bookmark">
			工作服穿戴监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作服穿戴监测识别摄像机是一种通过图像识别技术，实时监测和识别工作场所穿戴的工作服是否符合要求的设备。它可以有效地监测员工是否穿戴了正确的工作服，提高工作场所的安全性和管理效率。 这种摄像机利用先进的计算机视觉技术，能够快速准确地识别出员工穿戴的工作服类型、颜色、标识等信息，实时反馈到监控中心或管理人员的设备上。通过与数据库和规定的标准进行对比，及时发现不符合要求的穿着情况，有助于管理人员及时采取措施进行纠正。
工作服穿戴监测识别摄像机具有多种优点。首先，它可以减轻管理人员的工作负担，消除人为盲点和疏忽，提高了对工作服穿戴情况的监管效率。其次，它可以提升工作场所的安全性，确保员工穿戴符合标准的工作服，降低事故发生的风险。此外，它还可以帮助企业节约人力成本，提高管理效率。
然而，也面临一些挑战。首先是隐私保护问题，员工可能会担心自己的隐私被侵犯；其次是成本问题，部署和维护这种设备需要一定的投入。因此，在实际使用时需要考虑员工的合法权益，并权衡好投入产出比。综上所述，工作服穿戴监测识别摄像机是一种有潜力的管理工具，可以提高工作场所的管理效率和安全性。然而，在应用时需要充分考虑员工的隐私权和合法权益，并进行实施和维护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9440f2ef8460e5e0c277a8dbea8e245/" rel="bookmark">
			华为OD机试真题-堆内存申请-2023年OD统一考试（C卷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
有一个总空间为100字节的堆，现要从中新申请一块内存，内存分配原则为优先紧接着前一块已使用内存分配空间足够且最接近申请大小的空闲内存。
输入描述：
输入：
第1行是1个整数，表示期望申请的内存字节数；
第2到N行是用空格分割的两个整数，表示当前已分配的内存的情况，每一行表示一块已分配的连续内存空间，每行的第1和第2个整数分别表示偏移地址和内存块大小，如：
0 1
3 2
表示0偏移地址开始的1个字节和3偏移地址开始的2个字节已被分配，其余内存空闲。
输出描述：
输出:
若申请成功，输出申请到内存的偏移；若申请失败，输出-1。
补充说明：
1.若输入信息不合法或无效，则申请失败。
2.若没有足够的空间供分配，则申请失败。
3.堆内存信息有区域重叠或有非法值等都是无效输入。
示例1
输入：
1 0 1 3 2 输出：
1 说明：
堆中已使用的两块内存是偏移从0开始1字节和偏移从3开始的2字节，空闲的两块内存是偏移从1开始2个字节和偏移从5开始95字节，根据分配原则，新申请的内存应从1开始分配1个字节，所以输出偏移为1.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab5db405012393a6dbdf7b8636f5060/" rel="bookmark">
			无线通信MIMO的线性等效——NAIC2021无线通信赛道优胜奖方案分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近参加NAIC2021的AI+无线通信比赛，发现无线通信的MIMO过程虽然复杂，但其实是可以进行线性等效的，可以完全等效为一个较大规模矩阵的线性变换，也可以近似等效为一个较小规模对角矩阵的线性变换。这次比赛多数选手是利用了神经网络万能逼近的性质来完成求解的，但我是利用这种等效变换来做的，根本没有使用神经网络，而是使用这种方法可以得到了解析解。这种方法在精度和速度上有很高的性能，也非常方便对MIMO过程进行更多深入的分析。由于我不是学通信专业的，只是做这个比赛的一点总结，是否真的对通信有用我也不知道，只是花了时间去钻研它不想浪费，怕时间长忘了，放到这里存档。
赛题链接：https://naic.pcl.ac.cn/contest/10/34/71
由于决赛现场时间紧张我代码没有完全写完，所以仅得优胜奖，但我觉得这个方法应该是很不错的。文章是赛后不久就写好了，但过了一年后才发布。
1 MIMO过程描述 我们知道MIMO是由多个发射天线和接收天线组成的单个传输过程的组合，对于单个发射天线到单个接收天线的传输过程大概可以用下图描述，主要包括信号调制、反傅里叶变换到时域、加CP（循环前缀）、削峰（防止功率超限）、沿多输入多输出的天线阵组成的信道传输、去CP、傅里叶变换到频域、信号解调。
用python代码写出来MIMO过程的模型如下：
import numpy as np def Modulation(bits): '''调制，先把0,1信号变成-0.7071,0.7071；再分虚实部转为复数''' bits = (2*bits - 1) * 0.7071 bits = bits.reshape(-1, 2) return bits[:,0] + 1j * bits[:,1] def addCP(signal, CP): '''加入循环前缀''' return np.hstack([signal[-CP:], signal]) def removeCP(signal, CP, K): '''去掉循环前缀''' return signal[CP:CP+K] def channel(signal, channelResponse, SNRdb): '''单个信道的传输过程等于对信道响应卷积，再加上高斯噪声''' convolved = np.convolve(signal, channelResponse) sigma2 = 0.0015 * 10 ** (-SNRdb / 10) noise = np.random.randn(*convolved.shape) + 1j * np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab5db405012393a6dbdf7b8636f5060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8597f044e8b8c9fa8c108bdd54f77d6/" rel="bookmark">
			关于“Python”的核心知识点整理大全30
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
12.2.3 在 OS X 系统中安装 Pygame
12.2.4 在 Windows 系统中安装 Pygame
12.3 开始游戏项目
12.3.1 创建 Pygame 窗口以及响应用户输入
首先，我们创建一个空的Pygame窗口。使用Pygame编写的游戏的基本结构如下： alien_invasion.py
12.3.2 设置背景色
alien_invasion.py
12.3.3 创建设置类
settings.py
alien_invasion.py
12.4 添加飞船图像
12.4.1 创建 Ship 类
ship.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
12.2.3 在 OS X 系统中安装 Pygame 要安装Pygame依赖的有些包，需要Homebrew。如果你没有安装Homebrew，请参阅附录A的 说明。
为安装Pygame依赖的库，请执行下面的命令：
$ brew install hg sdl sdl_image sdl_ttf 这将安装运行游戏《外星人入侵》所需的库。每安装一个库后，输出都会向上滚动。 如果你还想启用较高级的功能，如在游戏中包含声音，可安装下面两个额外的库：
$ brew install sdl_mixer portmidi 使用下面的命令来安装Pygame（如果你运行的是Python 2.7，请将pip3替换为pip）：
$ pip3 install --user hg+http://bitbucket.org/pygame/pygame 启动一个Python终端会话，并导入Pygame以检查安装是否成功（如果你运行的是Python 2.7， 请将python3替换为python）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8597f044e8b8c9fa8c108bdd54f77d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f9e56c82a5a11cee887617ef69df6e/" rel="bookmark">
			数字电子技术实验作业(6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.（多选题）在仿真中“新建工程”的方法是什么？
A.①点击Ctrl+N。②在对话框里右下方点击Create。
B.①点击主菜单中File。②在下拉菜单中点击New…。
C. ①点击主菜单中Place。②在下拉菜单中点击Text。
D. ①点击主菜单中File。②在下拉菜单中点击Wire。
您的答案： B A
2.（单选题）仿真和实际操作中验证所用数码管的好坏方法要点是什么？
A. 数码管字符在右边（仿真），数码管接5V电源（实际操作），将5V电源，接数码管右边第3个引脚，点击运行按钮，看是否显示为4。
B. 数码管字符在右边（仿真），数码管接5V电源（实际操作），将5V电源接数码管右边第1个引脚，点击运行按钮，看是否显示为1。
C. 数码管字符在右边（仿真），数码管接5V电源（实际操作），再拿出一个5V电源，点击运行按钮，看数码管是否显示为零。
D. 数码管字符在右边（仿真），数码管接5V电源（实际操作），将5V电源分别接数码管的4个引脚，点击运行按钮，看是否显示为8，4，2，1。
您的答案： D
3.（单选题）本实验视频仿真演示时，查找74LS161的方法是什么？
A. ①点击元件快击中TTL按钮。②在出现对话框里找到74LS_IC单击。③在Component栏下找到74LS74单击。④在点击右上角OK。
B. ①点击元件快击中TTL按钮。②在出现对话框里单击Search…。③在出现的对话框里的Component栏里输入74LS161，再单击右上角Search按钮。④在出现的对话框的Component栏中74LS161D或74LS161N。⑤在点击右上角的OK按钮。⑥在对话框的右上角的再点击OK按钮即可。
C. ①点击主菜单Place。②在出现对话框里单击Component……。③在Group里找到TTL单击。④在出现对话框里找到74LS单击。⑤在Component栏下找到74LS161单击即可。。
D. ①点击元件快击中TTL按钮。②在出现对话框里找到74LS单击。③在Component栏下找到74LS161单击。④在点击右上角OK即可。
您的答案： B
4.（单选题）本实验仿真和实际操作时钟用函数发生器是应该注意的一个重要问题是什么？
A. 调好幅值。
B. 调好幅值，调好频率和直流偏置。
C. 调好频率。
D. 调好幅值，调好频率。
您的答案： B
5.（单选题）本实验基本要求中如何增加“暂停”功能？
A. 在74LS161外围加与非门。
B. 在74LS161外围加触发器。
C. 调整74LS161引脚功能的设计。
D. 在74LS161外围或门。
您的答案： C
6.（单选题）本实验实际操作时，使用数码管时与仿真时使用数码管相比有什么不同？
A. 一定要注意在4个数码管中间加9V电源。
B. 一定要注意在4个数码管中间加5V电源。
C. 一定要注意接地。
D. 一定要注意验证好坏。
您的答案： B
7.（单选题）本实验基本要求需要复习指导书附录四中哪几个型号芯片？
A. 74LS08，74LS86。
B. 74LS00，74LS161。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f9e56c82a5a11cee887617ef69df6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7810fa1d8211b47bea239f2744d0ae11/" rel="bookmark">
			Windows11环境下配置深度学习环境（Pytorch）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 下载安装Miniconda2. 新建Python3.9虚拟环境3. 下载英伟达驱动4. 安装CUDA版Pytorch5. CPU版本pytorch安装6. 下载并配置Pycharm 1. 下载安装Miniconda 下载安装包：镜像文件地址
将Miniconda相关路径添加至系统变量的路径中。
打开Anaconda Powershell Prompt，输入conda --version 2. 新建Python3.9虚拟环境 新建虚拟环境命令： conda create -n conda_name python=x.x(带python版本的)
新建python39环境:conda create -n python39 python=3.9
进入python39环境：conda activate python39
添加清华镜像网站到Anaconda：
conda config --add channels http://mirror.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirror.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 如果需要 jupyter notebook可以使用conda或者pip命令进行安装：
pip install jupyter notebook 在当前目录下输入 jupyter notebook即可打开。
3. 下载英伟达驱动 下载nvidia驱动软件：官网下载，登录，下载驱动。（判断自己的电脑是否有英伟达的显卡，没有显卡不需要安装驱动。）
windows+R，输入cmd，打开命令行，输入nvidia-smi，查看显卡驱动信息。
这里的CUDA version：12.3代表Cuda driver version是12.3，是与显卡的驱动相关的。 4. 安装CUDA版Pytorch 判断自己的电脑是否有英伟达的显卡，没有显卡不需要安装CUDA。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7810fa1d8211b47bea239f2744d0ae11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c3bff68a898611dece36bfa9e3e9eac/" rel="bookmark">
			bootstap table表格, 获取当前点击的table元素在该行是第几个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 有这样一个需求, table表格中是统计数据, 要求点击每个单元格可实现导出统计的底层数据
数据都是可点击导出的, 思路 获取行bootstap 有个index参数, 所哟要获取当前行第几列, 要获取当前点击的table元素在其所在行中的位置（即第几个），你可以使用JavaScript的事件对象和DOM API来实现。以下是一个简单的方法：
// 获取当前点击的table元素 var clickedCell = event.target; // 获取当前行的所有单元格 var cells = clickedCell.parentNode.getElementsByTagName('td'); // 计算当前点击的单元格在其所在行中的位置 var cellIndex = Array.prototype.indexOf.call(cells, clickedCell); // 输出位置信息 console.log('当前点击的单元格在其所在行中的位置是：第' + (cellIndex + 1) + '个'); 在这个方法中，我们首先通过事件对象获取当前点击的table元素。然后，我们使用getElementsByTagName方法获取当前行的所有单元格，并使用Array.prototype.indexOf.call方法计算当前点击的单元格在其所在行中的位置。最后，我们输出位置信息。请注意，这里假设单元格的索引是从0开始的，因此我们需要在结果上加1来得到从1开始的索引。
PS: 该方式用于获取行/列位置都可以的, 并不局限于bootstap表格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58beaf02a3aac999e8e770a236d48faa/" rel="bookmark">
			Mysql总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还不太完整，后续会补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886b061eea0b576e871915b79524f24d/" rel="bookmark">
			JAVA.JUC总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ea40f4e4845aec21c9626056a68c62/" rel="bookmark">
			CTFshow——web174-180（sql注入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web174 这是用正则匹配检查是否有flag
先闭合
order by爆列数
爆数据库名 和 表名
1' union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()--+ 有三个表名 一个一个试一下
虽然过滤了flag 但是没事 把他的password全显示出来就行
web175 正则匹配中\xnn代表的是ascii码为十六进制nn的字符串，本关过滤掉了ascii从0到127的字符
所以就不能用回显来做题
f1
用时间注入脚本
import requests url = "http://c522efea-d585-469c-b1c9-3270d9055620.challenge.ctf.show/api/v5.php?id=1' and " result = '' i = 0 while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f'1=if(ascii(substr(database(),{i},1))&gt;{mid},sleep(2),0)+--+' # payload = f'1=if(ascii(substr((select table_name from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ea40f4e4845aec21c9626056a68c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d9b642dbb1191f895d465635ee1c5b/" rel="bookmark">
			案例073:基于微信小程序的智慧旅游平台开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
后台模块的实现
用户信息管理
旅游景点管理
景区活动管理
小程序会员模块的实现
系统首页
我的菜单
景点购票
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了智慧旅游平台开发微信小程序的开发全过程。通过分析智慧旅游平台开发微信小程序管理的不足，创建了一个计算机管理智慧旅游平台开发微信小程序的方案。文章介绍了智慧旅游平台开发微信小程序的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本智慧旅游平台开发微信小程序功能有管理员和用户。管理员功能有个人中心，用户管理，景点分类管理，旅游景点管理，景点购票管理，景区活动管理，留言板管理，系统管理。用户可以查看景点信息，活动信息，还可以购票，以及留言。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得智慧旅游平台开发微信小程序管理工作系统化、规范化。
系统展示 后台模块的实现 用户信息管理 管理员可以管理用户信息，可以对用户信息添加修改删除。
旅游景点管理 管理员可以对旅游景点信息进行添加修改删除操作。
景区活动管理 管理员可以对景区活动信息进行添加，修改，删除操作。界面如下图所示：
小程序会员模块的实现 系统首页 小程序用户是需要注册才可以进行登录的，登录后在首页可以查看相关信息，并且下面导航可以点击到其他功能模块。界面如下图所示：
我的菜单 在小程序里点击我的，会出现关于我的界面，在这里可以修改个人信息，以及可以点击其他功能模块。界面如下图所示：
景点购票 用户可以对景点进行购票操作。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d9b642dbb1191f895d465635ee1c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4249d7ccff06fe790f928ea7aa3e6f32/" rel="bookmark">
			语言/CPP {系统的东西}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语言/CPP {系统的东西}
系统的宏/常量 __DATE__: "Dec 19 2023"
__TIME__: "17:55:19";
__TIMESTAMP__: "Tue Dec 19 17:55:11 2023";
__cplusplus: 201703: CPP语言的版本;
特殊语法 R"()" string s = "a\nb"; string会进行转义, 即这字符串的长度会是3 而不是4, 也就是 \n是一个字符;
假如你就是想要一个字符串 长度为4 内容为a \ n b, 那么麻烦一点 你可以手动的s[1] = '\\';
有一个系统的工具 R"()" (他很特别, 既不是函数 也不是宏, 反正是个特殊的语法), 你通过string s = R"(xxx)";那么xxx的内容 不会转义, 你写的是R"(a\nb)", 那么 他就是4个字符;
@DELI;
系统的类/结构体 is_literal_type literal字面类型, 即他就是一个值/数据 , 没有函数 不是通常意义上的对象;
字面类型有: bool, char, int, long long, double, T *, T &amp;, T &amp;&amp;;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4249d7ccff06fe790f928ea7aa3e6f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64883c2d8c0436a7a12e9ab34a10558a/" rel="bookmark">
			分享200&#43;个关于AI的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 海拥】【神级代码资源网站】【办公神器】🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流的小伙伴，请点击【全栈技术交流群】 分享200+个关于AI的网站
欢迎大家访问：https://tools.haiyong.site/ai
快速导航 AI 应用AI 写作AI 编程AI 设计AI 作图AI 训练模型AI 影音编辑AI 效率助手 AI 应用 文心一言: https://yiyan.baidu.com/
百度出品的人工智能语言模型
ChatGPT: https://chat.openai.com/
一款功能丰富、智能化、易用性强的人工智能工具，适用于各种内容创作者
TreeMind树图: https://shutu.cn/?from=haiyong
新一代“AI智能”思维导图，在线思维导图制作工具软件，免费思维导图模板。
Notion AI: https://www.notion.so/
这是真人工智能，不是人工智障
Stable Diffusion WebUI: https://github.com/AUTOMATIC1111/stable-diffusion-webui
Github 源码，可以自己搭建一个 Stable Diffusion 算法的 Web 版
头像生成卡通: https://toonme.com/
把头像交给 AI，实现你的卡通梦
DALL·E 2: https://openai.com/dall-e-2/
OpenAI旗下DALL·E 2模型，可以从自然语言的描述中创造出现实的图像和艺术
NUWA: https://nuwa-infinity.microsoft.com/#/
一个多模态生成模型，旨在从给定的文本、图像或视频输入中生成高质量的图像和视频
Stability AI: https://stability.ai/
根据你输入的文字描述，生成相应的图片
Novel AI: https://novelai.net/
用于人工智能辅助写作、讲故事、虚拟陪伴
6pen art: https://6pen.art/
利用文本生成绘画作品的产品
Deep Dream Generator: https://deepdreamgenerator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64883c2d8c0436a7a12e9ab34a10558a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad78988a377cb16af5f6f1757edd0a3/" rel="bookmark">
			【力扣100】146.LRU缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加链接描述
class DLinkedNode: def __init__(self, key=0, value=0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.cache = dict() # 使用伪头部和伪尾部节点 self.head = DLinkedNode() self.tail = DLinkedNode() self.head.next = self.tail self.tail.prev = self.head self.capacity = capacity self.size = 0 def get(self, key: int) -&gt; int: if key not in self.cache: return -1 # 如果 key 存在，先通过哈希表定位，再移到头部 node = self.cache[key] self.moveToHead(node) return node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad78988a377cb16af5f6f1757edd0a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee511f8a9245c0425f11689ab5b4cdba/" rel="bookmark">
			5G工业双卡路由器：引领智能制造新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前快速发展的数字化时代，工业物联网对高效、可靠的通信技术有着迫切需求。为满足工业物联网的需求，5G工业双卡路由器应运而生，为工业用户提供了更可靠、稳定的通信解决方案。
一、5G工业双卡路由器的功能和特点
5G工业双卡路由器集合了多种功能和特点，首先，计讯物联5G工业无线路由器TR323支持单模双卡功能，可以同时使用两个不同的SIM卡，自动切换，确保工业设备的持续、稳定的网络连接。其次，5G工业双卡路由器采用高性能的无线通信模块，可在严峻的环境中正常运行，确保数据传输的稳定性。此外，它还支持高速数据传输，可满足工业应用对大容量数据传输的需求。最重要的是，5G工业双卡路由器具有强大的安全性能，采用了多重协议加密和访问控制技术，保护工业设备和数据的安全。
二、5G工业双卡路由器的应用领域
5G工业双卡路由器具备采集、通信、控制等功能，在工业制造、能源、交通等领域有着广泛的应用。在工业制造领域，它可以连接数控机床、机器人等设备，实现设备之间的远程监控和管理。而在能源领域，工业双卡路由器可以实现电网与能源设备之间的无线连接，提高能源系统的运行效率。此外，在交通领域，工业双卡路由器可用于车载终端设备的通信，实现车辆之间的互联互通，提升交通管理的智能化水平。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e90a4c9f5b6bcca15d66a3935ff0d6e/" rel="bookmark">
			YYYY-MM-dd 与 yyyy-MM-dd 的区别以及跨年问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大写YYYY的用途 大写的YYYY通常用于表示“周年”，在某些编程语言或者数据格式中，比如ISO 8601日期格式中，YYYY可能代表的是所在周属于的年份。这意味着，如果一周跨越了两个不同的年份，该周会被归属到哪一年取决于这周中的大部分日子属于哪一年。
小写yyyy的用途 小写的yyyy则是更常见的表示方法，用于表示“日历年”。无论日期所在的周是否跨年，yyyy总是代表实际的年份。
实际影响 在大多数情况下，人们使用yyyy-MM-dd格式，因为它符合日常生活中对日期的理解和使用。而在一些需要按周计算时间的场合，可能会用到YYYY格式，尤其是在财务报告或者具有特定周计算需求的行业中。
样例 public class DateFormatExample { public static void main(String[] args) { // 使用Calendar获取一个日期实例 Calendar calendar = Calendar.getInstance(); // 假设日期是2023年12月31日 calendar.set(2023, Calendar.DECEMBER, 31); // 使用YYYY格式化日期 SimpleDateFormat formatWithYYYY = new SimpleDateFormat("YYYY-MM-dd"); String dateWithYYYY = formatWithYYYY.format(calendar.getTime()); System.out.println("Date with YYYY: " + dateWithYYYY); // 输出的是2024-12-31，因为12月31日属于第1周，而该周属于下一年 // 使用yyyy格式化日期 SimpleDateFormat formatWithyyyy = new SimpleDateFormat("yyyy-MM-dd"); String dateWithyyyy = formatWithyyyy.format(calendar.getTime()); System.out.println("Date with yyyy: " + dateWithyyyy); // 输出2023-12-31 } } 结论 YYYY-MM-dd可能会导致跨年周的日期被归属到错误的年份。yyyy-MM-dd总是表示实际的日历年份，无论日期所在的周是否跨年。在编写代码或者设置日期格式时，需要根据实际需求选择合适的年份表示方法。 如果使用日期格式不当，可能会在数据处理、日志记录或者时间计算等方面造成混淆和错误。因此，在处理日期和时间时，了解并正确使用这些日期格式是非常重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952966ab58ece9e18aee3d24e125febd/" rel="bookmark">
			Achronix提供由FPGA赋能的智能网卡（SmartNIC）解决方案来打破智能网络性能极限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Achronix
随着人工智能/机器学习（AI/ML）和其他复杂的、以数据为中心的工作负载被广泛部署，市场对高性能计算的需求持续飙升，对高性能网络的需求也呈指数级增长。高性能计算曾经是超级计算机这样一个孤立的领域，而现在从超级计算机到边缘解决方案，在各个层面都可以看到高性能计算，随着我们推动更快的解决方案进入市场，网络安全和高复杂性应用在其中也扮演着更重要的角色。
为了满足对网络加速的需求，并提供灵活的、可重新编程的网络，Achronix为数据中心运营商、云服务提供商和电信公司提供Achronix 的Network Infrastructure Code（简称ANIC）和基于Achronix Speedster7t FPGA芯片构建的SmartNIC。这些可编程的加速器集成了前沿性技术，如400 GbE连接速度、PCIe Gen 5.0功能、片上网络和高速并行处理，以提供无与伦比的性能、可扩展性和灵活性组合。
ANIC是一套由模块化FPGA IP组成的完整设计，提供专为高性能网络流水线进行了优化的SmartNIC解决方案的所有基本功能单元。它有力地支持400 GbE和PCIe Gen 5.0功能，使各类用户能够根据其特定要求快速开发高带宽SmartNIC解决方案，满足其随着条件的变化而变化的要求。
更好的性能，更高的灵活性
为了提高网络性能，越来越多的客户转向SmartNIC，因为它可以通过卸载数据包处理和加密等日常任务来减轻主机服务器CPU的负担。除了节省CPU周期带来的经济效益之外，卸载还可以提高整体系统性能和资源效率。SmartNIC还具有可定制和可编程性，使用户能够灵活地适应不断变化的网络需求。
InfiniBand（简称IB）是用于高性能计算的传统网络技术。尽管IB的性能很好，但对于部署在传统数据中心（用以太网来作为标准网络协议），它却不能提供其中的HPC高性能计算解决方案所需的灵活性或功能密度。Achronix的ANIC解决方案支持400 GbE，可实现快速的数据传输速率，同时还提供了在网卡（NIC）上部署网络应用的能力；这一功能可显著提高应用性能并降低事务延迟。基于FPGA的ANIC方法具有出色的确定性，并始终提供极低的应用延迟，从而使ANIC成为具有严格实时处理需求的应用的首选。
SmartNIC架构的一种实现方法是将计算单元（如Arm内核等）添加到高性能网络数据路径中，以实现灵活的且可编程的网络。虽然添加CPU内核确实可提供网络卸载和应用加速功能，但处理器内核所能提供的网络性能也受限于其自身。功耗和空间限制将单张网络卡上可部署的内核数量限制于10个，从而使指令集受到限制，性能也就受到限制。
ANIC没有使用性能受限的Arm内核，而是运行在高性能的Achronix Speedster7t FPGA器件上，并且ANIC的模块化架构简化了组件选择过程并加快了设计阶段。此外，Speedster7t FPGA器件的部分重新配置功能支持实现动态调整，从而能够满足不断变化的需求。这种部署敏捷性可以节省大量的时间和成本。
“这是性能上的一个数量级飞跃，”Achronix SmartNIC产品规划总监Scott Schweitzer说道。“在ANIC上用一微秒内就可完成的工作在Arm内核上则可能需要几毫秒，而可在几纳秒内完成的工作可能需要几微秒。”
基于ANIC，用户有机会去部署自定义的IP功能。这种自定义的IP功能为定制应用打开了大门，如键值存储、入侵防御、重复数据删除和其他网络功能，所有这些应用都以400 GbE的网络速度运行。
在高性能计算中使用由FPGA加速的智能网卡：游戏规则改变者
高性能计算环境需要卓越的处理能力、高效的数据移动速度和高速的互连能力才能实现最佳性能。各种SmartNIC，尤其是像Achronix提供的基于FPGA的解决方案，可以无缝地满足这些要求。
在高性能计算中采用基于FPGA的SmartNIC带来的主要优势之一是定制化。凭借Speedster7t可重新编程的FPGA具有400 GbE以太网和PCIe Gen5功能，是高性能计算集群的多功能构建模块。
Achronix打造ANIC的目的是使用户能够优化其网络数据路径并加速网络应用。ANIC提供了一个完整的SmartNIC流水线，包括数据包接口、FIFO缓冲区、报头/解析器、流表格、规则引擎和DMA引擎。每种功能单元可以根据客户的需要去选择或取消，从而实现全部或部分数据包加速，并在Speedster7t FPGA器件上为客户自定义的网络加速功能应用预留高达50%的逻辑资源。
Speedster7t FPGA器件还提供二维片上网络（2D NoC），该项设计可在FPGA芯片内提供高达20 Tbps的带宽，并进一步增强模块化应用的部署。每个ANIC模块通过利用80个网络接入点可以实时放置在FPGA上或对其进行升级。
“ANIC的逻辑模块可以像乐高积木一样组合起来，以创建量身定制的SmartNIC解决方案，”Schweitzer说道。“根据想要完成的工作，客户可以选择使用部分或全部ANIC功能单元来组装解决方案。”这种模块化可组合性可确保用户只使用其特定应用所需的模块，从而消除了不必要的开销。
在HPC中，加速的I/O至关重要。SmartNIC允许超快速数据移动，从而有助于大型数据集的快速处理。如在DDoS缓解应用中，要求更深入的数据包检测，ANIC基于FPGA的高度并行设计支持高效的数据包处理，从而确保及时识别和缓解威胁。
在高性能计算和数据驱动应用的时代，Achronix提供的基于FPGA的SmartNIC可提供无与伦比的速度、卸载的处理能力、增强的安全性和卓越的灵活性。无论是寻求高速数据处理，减少延迟还是提高整体效率，SmartNIC都为高性能网络的未来铺平了道路。随着数据的不断激增和应用的要求越来越高，对于任何希望在高性能网络和计算方面突破极限的人来说，SmartNIC代表着一项至关重要的创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04124143c4a2968b132dd86962ba1ea2/" rel="bookmark">
			关于“Python”的核心知识点整理大全29
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
11.2.4 方法 setUp()
注意
11.3 小结
第二部分
项目1 外星人入侵
第１2 章
武装飞船
注意
12.1 规划项目
12.2 安装 Pygame
注意
12.2.1 使用 pip 安装 Python 包
注意
如果你启动终端会话时使用的是命令python3，那么在这里应使用命令sudo python3 get-pip.py。
12.2.2 在 Linux 系统中安装 Pygame
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
11.2.4 方法 setUp() 在前面的test_survey.py中，我们在每个测试方法中都创建了一个AnonymousSurvey实例，并在 每个方法中都创建了答案。unittest.TestCase类包含方法setUp()，让我们只需创建这些对象一 次，并在每个测试方法中使用它们。如果你在TestCase类中包含了方法setUp()，Python将先运行 它，再运行各个以test_打头的方法。这样，在你编写的每个测试方法中都可使用在方法setUp() 中创建的对象了。
下面使用setUp()来创建一个调查对象和一组答案，供方法test_store_single_response()和 test_store_three_responses()使用：
import unittest from survey import AnonymousSurvey class TestAnonymousSurvey(unittest.TestCase): """针对AnonymousSurvey类的测试""" def setUp(self): """ 创建一个调查对象和一组答案，供使用的测试方法使用 """ question = "What language did you first learn to speak?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04124143c4a2968b132dd86962ba1ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bda9287090cd6d35cb1044a63b4d5eb/" rel="bookmark">
			垃圾溢出监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾溢出监测识别摄像机是一种应用于城市环境管理的智能设备，它能够帮助城市管理部门实时监测垃圾桶的填充情况，及时发现溢出情况并作出响应。该设备通常采用计算机视觉技术，结合图像识别算法，能够准确地识别垃圾桶的填充程度和溢出情况。 在实际使用中，垃圾溢出监测识别摄像机首先会被安装在城市的垃圾桶周围，通过摄像头实时拍摄垃圾桶的状况。然后，图像识别算法会对拍摄的图像进行处理和分析，识别出垃圾桶的填充情况和是否溢出。一旦监测到垃圾桶溢出，系统会立即发出警报并通知相关部门进行清理和处理，从而避免垃圾满溢污染环境。
垃圾溢出监测识别摄像机的应用能够极大地提高城市环境管理的效率和卫生水平。通过实时监测垃圾桶的状况，城市管理部门可以合理安排清理资源，及时清除溢出垃圾，有效减少环境污染和恶臭扩散。同时，这种智能设备还可以为城市管理者提供数据支持，帮助他们更好地规划城市环境管理工作，并提高工作效率。
总之，垃圾溢出监测识别摄像机作为一种智能化城市环境管理工具，可以帮助城市管理部门实现精细化管理、高效清洁，提高城市环境的整体卫生水平。它的应用将极大地改善城市居民的生活质量，推动城市环境管理工作向着智能化、信息化和可持续发展的方向迈进。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8ce0c8716638957184c60068252e24/" rel="bookmark">
			Python post请求发送的是Form Data的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常规的Form Data 大部分的Form Data 可以直接都是可以通过正常的post请求进行提交的
import requests headers = { '自己设置的请求头键': '自己设置的请求头键', 'Content-Type': '网页接受的数据类型' } form_data = { '对应的键1'：'对应的值1', '对应的键2'：'对应的值2', } response = requests.post('需要访问的url地址',data=form_data,headers=headers) response.close() 特殊的Form Data 但是有些Form Data 里面的数据是很繁琐的，有一些是以下结构的数据
decode后的数据是看着比较符合json的格式的
但是点击【view source】后就发现其根本不是常规的数据，下图就是source数据的样子
每一个参数，都会已一定固定的格式为开头
例如：
------WebKitFormBoundaryxxxxxxx
Content-Disposition: form-data; name="upload_sign"
如果是这样的参数，那就不能用上面提及的方法去发送post请求
解决的办法 通过【MultipartEncoder】库来创建一个form_data对象
安装第三方库 requests-toolbelt，注意是 - （是减号，不是下划线）才能搜出来
import random import string from requests_toolbelt import MultipartEncoder headers = { '自己设置的请求头键': '自己设置的请求头键', } # 准备需要post的数据 request_data = { 'upload_sign': signature, 'forbid_override': 'false', # 携带文件 # 示例："
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8ce0c8716638957184c60068252e24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a917ad9574f06d0ec7a82c9072d518b2/" rel="bookmark">
			cfa一级考生复习经验分享系列（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先分析一下CFA Level 1内容，考试总体难度并不大，每门课程都比大学本科开设的对应课程简单，但是因为有十门课综合在一起，知识点相对算比较多，内容较多。但对知识点的掌握要求不高，理解即可。比如财报（financial reporting analysis）这门课，很多内容都是理解了原理就行了，给你一个指标变化，会判断相应的财务比率变动情况就行，并不会像会计一样要你做分录等等。考试通过方式具体不说了，大概来说只要做对百分之70的题，基本就能过。
再说我的看法，CFA官网推荐的一级复习时长是300小时（对于英语为母语的国家来说），也就是，如果你英语还可以，提前半年开始复习的话，每天只要学2个小时就够了，可以说是比较轻松的了。如果你不仅英语不错，且十门课都大致接触过，有一定的金融基础，那么考过一级是一点问题都没有。我本科是财会方向的，考研考了金融，然而除了考研之外，整个大学四年基本上没有上过课，可以说没什么基础，唯一对CFA考试有帮助的是英语还不错。所以如果你也没有太多金融基础甚至零基础，不用担忧。
接下来讲一下我的复习情况，从3月复习到6月，没有看教材，notes，跟金城网课，基础班视频，刷课后题，强化班视频，刷百题，mock题，平均每天大概学3-4小时。具体复习如下
前导班网课
粗略浏览讲义后未看，前导课主要是介绍一下课程内容，粗略的讲了下知识点，可以体验一下，找一找看网课的状态。如果有一定基础或者时间紧张可以跳过，内容和基础班一致。基础班网课
可以倍速播放省时间。准备一本笔记本，听课时不用，每门课程每节后跟着老师总结的思路整理归纳内容，可以精简的列提纲的形式，总之要把重要的内容有序的记到本子上，讲义太厚上完课基本上就不会再用了，以后复习或者查知识点就能直接翻笔记。每章结束后，自己脑海中列一下这张的内容框架，想想这章讲了啥。按这个流程，于大概四月下旬看完（前期比较偷懒）。开始刷课后题及网课
把课后题打印出来，一定要认真对待课后题（网课老师说课后题是最好的题，是协会原汁原味出的题。但其实我觉得有的个别题目蛮偏蛮怪的，奇怪的题做错了也不要灰心，考试不考）。平均每门课150题，每天完成一门课的内容，包括做完，对答案，订正，消化理解，错题可以看视频讲解，有新的知识点或者重要的错题可以加到笔记上，做完顺便统计一下正确率。当时做完平均正确率大概85左右，省时间视频讲解可以只看错题，于五月初结束。强化班网课
内容是基础班的精简版，内容不多，把重点再讲了一遍，没有新增内容，有时间的可以再过一遍，很快可以看完，当作巩固知识点，也是对自己的测试，讲到知识点看自己能不能想起相应的内容。也可以在这补充一下笔记。于五月中看完。百题班刷题及讲解网课
开始第二轮刷题，题目数量比课后题多一些，难度也略高一点，但是不会有太偏的题，所以还是要保证正确率，看看自己有没有进步。百题做完平均正确率大概90左右，讲解只看了错题还有一些有困惑的。百题的网课会带你做题同时再过一遍知识点，若课后题做的不好，可以跟着网课来，于五月底结束。押题班
押题班就是几套协会出的mock题，120道题一份，有三份。可以以测试的形式模拟考试的感觉，计时看看自己的速度。Mock题比百题还要难一些，同样要算正确率，算时间。到这个阶段如果还能保持70以上的正确率那就基本可以安心参加考试啦。刷完正确率90左右，于6月初结束
最后两个礼拜花了两天把错题整理了，剩余的时间基本就在等考试了 ps:每门科目我认为的重点
1.Ethics道德，CFA独创的课程，都是重点，把做过的题当小故事背下来，没有太多技巧。
2.quantative method数量，相当于概A，，加一点收益率，假设检验的内容。重点假设检验，数学部分中国考生应该都擅长
3.Economic经济学，宏观，微观，国际经济学，这是我认为最难的一章（本科经济学都60几飘过），三本经济学内容非常多，全是重点。
4.Financial reporting analysis财务报表分析，重点EPS，存货。
5.Corporate finance公司金融，重点WACC，公司治理。
6.portfolio组合，重点三个理论，一定搞懂，还有几根线有效前沿，资本配置线，证券市场线
7.Equity股票，重点定单指令，股票价值计算，有效市场假说，指数加权方法。
8.fixed income固定收益证券，重点住房抵押贷款债券MBS，久期，凸性（理解+计算）。
9.derivatives衍生品，大概清楚每种产品概念即可。
10.alternatives另类投资，重点对冲基金HF，私募股权PE，管理费，激励费的计算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1938f8987e1ea2d9b1b1b59c2c52ac89/" rel="bookmark">
			cfa一级考生复习经验分享系列（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 刚下飞机，拿到10A的成绩单十分激动，基本上每一门都是前10%，即使考得最低的一门也拿到了前15%。作为一个完全零基础备考的外行人，对我来说完全是喜出望外的成绩。下面简单分享一下备考经历：
个人背景：本科+研究生均就读于上海某医学院，没有任何金融相关的基础知识，备考CFA的主要目标就是奠定金融知识的框架；而个人体验而言，CFA的备考确实能构建相当全面的知识体系，作为转行金融的学习工具很合适。英语水平：TOEFL 110，阅读障碍主要在没见过的专业术语。
在2月份报名之后，备考就成为了生活中比重较高的一部分。作为零基础的考生，做好了付出更多努力的觉悟。个人感觉，CFA一级的主要难点不是知识的深度，而在于广度：内容很多，一定要有充足的时间打好基础。由于知识体系的分散庞杂，针对性突击的复习可能反而事倍功半。
2月初到4月初：基础阶段
这段时间为我的第一轮学习，每天大约3小时。由于当时时间较为紧张，想要找出效率最高的学习方法。在对比过后，我发现自己的英文阅读水平较高，可以在较短的时间内直接把NOTES从头啃到尾，因此基本以NOTES为主。每一章节通读NOTES之后，先在笔记上梳理本章节的知识点，最好能根据自己的记忆，整理出一个知识框架。第二天先复习前一天整理的笔记和框架，之后做教材的课后题。大多数的章节这样学习下来效果都不错。但是有些章节，看NOTES感觉效率不高，个人认为是由于某些章节NOTES编的不好、还有一些章节难度太高。这个时候就需要找网课等教学资源，比如Ethics一整章，NOTES基本可以直接扔掉，推荐在喜马拉雅上听何璇老师的免费课程，质量相当高。另外有现金流量表、资产的租赁、固收的久期等较难的章节，直接看NOTES有种啃不动的感觉，需要找些网课先看一到两遍再看NOTES，会节省很多时间。4月中旬：强化阶段
把整个考试内容通读一遍之后，再回过头来，发现前面学的内容基本上都忘得一干二净。考试临近、时间不多，当时陷入了焦虑之中，这个时候就需要之前整理的笔记和框架发挥用处了。直接再啃一次NOTES或者网课都会消耗大量的时间。因此我推荐第二轮复习要以笔记和框架为主。有些章节我之前没有整理自己的框架，因此直接用了品职的框架，每年都有送，感觉编排得很不错，但我更加推荐用自己整理的框架，顺着自己的节奏可以让效率提升很多。大概每天2-3个章节。在复习完每个章节后，第二天一定要再刷一次课后题巩固一下。虽然之前已经做过一次课后题了，但是很多东西都已经忘记，况且课后题是整个CFA一级最重要的题库了，刷多少次都不为过。5月初开始：重点突破
先把学习的重心放在Ethics上。虽然Ethics也强调理解而非死记硬背，但是临近考试再学习Ethics确实有很多好处。建议英语功底较好的一定要通读一下handbook，术语不多、读起来很快，读完会对整个Ethics描述的金融市场有一个很感性的认知，就像是影视作品里的世界观一样。由于Ethics前面的几个准则是重点和难点，所以我把handbook前面四个章节读了两次。考前最后一个月：刷题
基本上就是刷题时间了。建议先把课后题再刷一遍，尤其是较难的重点章节，如果时间不够的话也可以只看以前的错题。在刷完课后题之后，如果有时间，推荐刷一下金程的百题。个人感觉课后题和百题作为题库就足够了。也可以直接开始mock。官方的mock有一定难度，错误率稍高也不要气馁。最后一段时间，各个教育机构也会出自家的押题卷，有甄选地做一下，调整状态，迎接考试即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07105e7e51405094208773a524b41d48/" rel="bookmark">
			cfa一级考生复习经验分享系列（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人背景：本科经济学，有一定基础。现为某国企员工，每天大概率加班到7点多，复习时间有限。
准备材料
买了JC的网课（主要复习依据），然后下载一个potplayer视频播放器（神器，谁用谁知道，主要是用截图功能以及倍速播放功能，能精确到0.1倍），买一个月的百度网盘会员（为了下载视频更快）。准备时间
3月中旬开始准备，由于平时工作，时间有限，主要就是下班后根据这个网课材料来复习。网课看了三遍，第一遍是1.5-2.0倍速听一遍基础班；第二遍是2.2-2.8倍速听一遍强化班；第三遍是针对掌握不扎实的科目用3.0左右倍速再过一遍强化班。做题
理想状态下是去做书后习题，还有notes的练习题，但本人实在是工作占用大量复习时间，没办法，挑精华的做。一是跟着视频里做题，视频里的题目都是精挑细选过的，来自往年的真题，很有意义，一定要会。二是百题班，一定要全部做一遍。第三就是mock，官方出题，参考性还是比较强，每年有三套mock可以做（当然还是工作原因，时间不足，就做了两套）。百题可以在听强化班的时候，每听一门课就做一门百题，巩固知识。
*做笔记
笔记一定是要做的，别人的笔记看着不走心，不入脑，作用不大，笔记这个东西只有最适合自己才是最好的。基础班的时候，我用电脑（主要是有道云笔记）来记录，因为知识点比较杂，电脑里打出来，将来想搜索知识点也比较方便。强化班笔记是我个人觉得最重要的，因为强化班本身就是很浓缩的精华部分，因此你的笔记是精华中的精华。建议大家用小本子记录，最好一个手就能拿住，这样到考前哪怕坐地铁上或者考场候场时也可以拿在手里，迅速的过一遍，临阵磨枪不快也光。考试当天感受
*在国家会议中心考的，今年大家普遍都反映说是侧重概念，容易拿分的计算比往年少了一些。确实如此，所以大家在听课复习的时候一定要注意对概念点的掌握。一定要带好该带的材料，中午有一个小时吃饭时间，一定补充好能量。候场的时候，不要浪费时间，记得拿出针对强化班做的笔记，再过一遍，基本能够做到45分钟过完8科（除经济和数量），脑子里对关键知识点再有些印象。另外，上午考的题有不会的，中午一定再看一下，因为有一定概率下午重复出现考点。复习时间安排：
1.第一阶段：听基础班。JC的基础班视频课，每节课平均大概90分钟左右，一般来说倍速播放加上做笔记整理时间，一节课1小时差不多，当然可以利用工作午休时间多听一听，每天听2-3节课问题不大，大概用一个月时间看完第一遍，做好笔记整理。
2.第二阶段：听强化班一共22节课，大概一周左右可以听完（我正好利用了五一假期），同时做的笔记是非常关键的，之后会经常翻看，一定要结合自身学习感觉到的难点做好有针对性的记录。另外，每一门课程的知识点之间是有逻辑的，运用好思维导图的形式，把这一科课程的整体框架和逻辑搞清楚。
3.第三阶段：边听强化班边做百题，以考促学强化记忆，这一段时间可能会稍微久一些，毕竟做题要花费很多时间，特别是对于上班族来说。百题要自己独立做，不要边做边看答案，最后统一校对，错了的题要根据答案解析搞清楚解题方法，还是搞不清楚的，打开百题班相应章节对照。
4.冲刺阶段：进入六月，开始冲刺，做mock，能做多少就做多少，不过通常一套下来要一整天时间，题量完全和真正的考试一样，所以刷题进度不会太快，要有耐心。宁肯少做一套题也要把已经做过的题搞懂弄通做实，不能稀里糊涂就过去了。
5.最后时刻：也就是考前一天晚上，把自己还是不放心的课程强化班再过一遍，倍速播放，用不了多久，一科1小时足矣。具体到每一科：
数量：基本看了一遍基础班就没再看，因为作为一个念过大学、修过高数的中国人，这一科应该都是有基础的，做题的正确率也够。但是考试时吃了大亏，因为这一科考试和以往考试的题型有了很大变化，非常侧重概念的理解而不是计算，导致真正考试时刚刚过了70%正确率的线。
经济：看了一遍基础班，宏观部分再看了两遍强化班，毕竟本科学这个的，有一定基础。考试依然是侧重概念，与以往的考试题型变化不大。
财会：每年的重头戏，虽然比重有所降低，但是依然是最大比例。财会一科，不能单单看某一节的内容，节与节之间是有联系的，不同的几个专题加在一起就构成了整个财务报表的主体要素，所以弄清楚节与节之间的关系，看懂逻辑思维导图，对财务报表能有一个整体的认识是很重要的。计算内容一定要掌握好，同时侧重掌握IFRS和GAAP之间的几个不同点，每年都有考题。
伦理道德：唯一一门拿了b的科目。说实话，道德这一章有点鸡肋，因为占了第二大的权重所以弃之可惜，但得分率不是很高，大量英文阅读浪费时间又食之无味。做这一门科目重点就是要记好视频课程中讲的典型案例，把七大准则分别都是什么，每一个里面包含哪些点能默写下来，强行记住，这一科起码不会比b更低了。
公司金融：最好拿分的课程，把几个公式被得滚瓜烂熟，主要考点就那么几个，会套公式即可。另外，三大理论的图像怎么画出来，有什么意义，一定要掌握。
固收：这一门课，最重要的一点就是记住几个收益率的公式，复利的、单利的，计息一次计息多次的。然后一定要熟练使用金融计算器，平时多按一按，这一门课熟练使用计算器可以帮助你至少节约5道题的时间。
衍生品：四大类衍生品，对比着记忆，几个衍生品之间有什么联系，有什么不同，每类衍生品在金融市场上起到什么作用，有什么影响，option相对难一些，而且考得比较多，重点看一下。
权益：实际上就是股票，有炒股经验的考友们可能上手更快一些，主要是很多平时不接触的名词，一定要先掌握好概念，否则直接听课不太容易上手入门。这一章建议在做笔记时用中文，毕竟中文翻译过来的词汇更接近我们的生活实际，便于理解。当然，股市老司机们直接拿英文做笔记辅助记忆没有问题。
组合：计算为主。其他：概念性质为主。两者的权重都不大，但掌握起来也还是比较好上手的，争取拿下a。 cfa一级考试，基本上拿到分数在最高1%那部分人得分平均数的70%以上，基本就可以通过考试。翻译成比较好理解的话，就是正确率在70%以上就可以通过了。那是不是意味着我们要完全掌握70%的知识点并且做对才有机会通过呢？显然不是的。因为cfa一级都是选择题，有三分之一的概率可以蒙对，因此如果能确保做对50%，那么整体的正确率的期望大概在67%，很接近70%了对不对？那么努努力争取确保作对的题占55%，那么正确率的期望就达到了70%，我们就可以过关咯！所以遇到难题不要怕，不会做也不要怕，看看够不够55%心情就会好很多！放平心态，结果不会差！
祝愿所有的考友都能够顺利通过！加油哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d965ab45a59a4e86813fa9711b0e5d50/" rel="bookmark">
			关于“Python”的核心知识点整理大全28
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
11.1.5 添加新测试
11.2 测试类
11.2.1 各种断言方法
unittestModule中的断言方法：
​编辑11.2.2 一个要测试的类
survey.py
language_survey.py
11.2.3 测试 AnonymousSurvey 类
test_survey.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
11.1.5 添加新测试 确定get_formatted_name()又能正确地处理简单的姓名后，我们再编写一个测试，用于测试 包含中间名的姓名。为此，我们在NamesTestCase类中再添加一个方法：
import unittest from name_function import get_formatted_name class NamesTestCase(unittest.TestCase): """测试name_function.py """ def test_first_last_name(self): """能够正确地处理像Janis Joplin这样的姓名吗？""" formatted_name = get_formatted_name('janis', 'joplin') self.assertEqual(formatted_name, 'Janis Joplin') def test_first_last_middle_name(self): """能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？""" 1 formatted_name = get_formatted_name( 'wolfgang', 'mozart', 'amadeus') self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart') unittest.main() 我们将这个方法命名为test_first_last_middle_name()。方法名必须以test_打头，这样它才 会在我们运行test_name_function.py时自动运行。这个方法名清楚地指出了它测试的是get_ formatted_name()的哪个行为，这样，如果该测试未通过，我们就会马上知道受影响的是哪种类 型的姓名。在TestCase类中使用很长的方法名是可以的；这些方法的名称必须是描述性的，这才 能让你明白测试未通过时的输出；这些方法由Python自动调用，你根本不用编写调用它们的代码。
为测试函数get_formatted_name()，我们使用名、姓和中间名调用它（见1），再使用 assertEqual()检查返回的姓名是否与预期的姓名（名、中间名和姓）一致。我们再次运行 test_name_function.py时，两个测试都通过了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d965ab45a59a4e86813fa9711b0e5d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a7741587e59d21ea2d58d2cffe5fbd/" rel="bookmark">
			github超时解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错 Failed to connect to github.com port 443: Timed out 解决方法 1、搜索域名对应的ip 网站如下
域名找ip
找到这个ip存下来
2、更改hosts内容 一般hosts的文件路径是C:\Windows\System32\drivers\etc\hosts
但是直接打开没有修改权限，修改方法如下
2.1 管理员模式运行cmd 输入命令
notepad .\drivers\etc\hosts 打开后在最后加上 ip+github.com。如下所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af3d685f1f78d4ee434c39a8475e7c3/" rel="bookmark">
			vue3集成electron
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前文章基于创建一个vue3应用 1、安装electron开发依赖 最新版本：npm install --save-dev electron
指定版本：npm install --save-dev electron@22.2.0
2、添加主进程文件main.js、预加载脚本preload.js __dirname 字符串指向当前正在执行脚本的路径 (在本例中，它指向你的项目的根文件夹)。path.join API 将多个路径联结在一起，创建一个跨平台的路径字符串。 项目根目录新建文件electron/main.js:
const { app, protocol, BrowserWindow, globalShortcut } = require('electron') // 需在当前文件内开头引入 Node.js 的 'path' 模块 const path = require('path') app.commandLine.appendSwitch("--ignore-certificate-errors", "true"); // Scheme must be registered before the app is ready protocol.registerSchemesAsPrivileged([ { scheme: "app", privileges: { secure: true, standard: true } } ]); const createWindow = () =&gt; { const win = new BrowserWindow({ minWidth: 960, minHeight: 540, width: 960, height: 540, //窗口是否在屏幕居中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1af3d685f1f78d4ee434c39a8475e7c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77cb1335a1f7f987ebb539012c69876/" rel="bookmark">
			【嵌入式-51单片机】常见位运算和数据类型以及sbit使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51单片机中
数据类型如下：
位运算符如下：
按位左移&lt;&lt;：低位补零，高位移出
按位右移&gt;&gt;：高位补零，低位移出
按位与&amp;：对应位上的值必须同时为1才为1，可以用来对指定位置的寄存器重置处理。比如P2寄存器为1010 1011（0xAB），此时如果0xAB &amp; 0xFE，此时相当于对第0位作置0处理，结果为0xAA。
按位或|：对应位上的值有一个为1那么值就为1。可以用来对指定位置的寄存器置为高电平处理。比如P2寄存器为1010 1010（0xAA），此时如果0xAA | 0x01，此时相当于对第0位作置1处理，结果为0xAB。
按位异或^：对应位上的值必须相反则为1，否则为0。这个可能具有保持值不变的功能，不太常用把， 比如P2寄存器为1010 1010（0xAA），此时0xAA ^ 0xFF 得到的值为0101 0101，相当于按位取反啦。
按位取反~：对应位上的值按位取反。。。比如1111 1110（0xFE）按位取反就是0000 0001（0x01），在做流水灯测试时发现居然还能这么用。。。。0xFE = ~(0x01 &lt;&lt; 0)，然后可以将这种对流水灯的流转转换为对每一位的左右移。很精彩！这里可以用来对某位进行清零操作。比如IR_Data[0] &amp;= ~(0x01 &lt;&lt; IR_pData);这里可以看到，IR_Data[0]的第IR_pData位进行清零操作。很秀啊~~
在51单片机中，有一个神奇的关键字，叫sbit，这个关键字能直接取到寄存器的某一位。比如寄存器名为P1，8位，如果想直接将其中的第三位当作变量使用，可以直接使用P1_3，这个P1_3就代表了P1寄存器第三位的bit值，正如名字所描述的一样，它应该只能取0和1。比如P1_3=0;将P1第三位置为低电平。如果使用按位与，需要写成P1 = P1 &amp; 0xFB;这样显得有点麻烦。哈哈哈，我算这个1111 1011转为0xFB还要花几秒呢。所以尽量sbit来简化吧~（另外使用PX_X这种寄存器位需要导入#include &lt;REGX52.H&gt;哦~）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8ceeff7e47eaee9dcecbbaa4d03298/" rel="bookmark">
			Python-Selenium-使用 pywinauto 实现 Input 上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前环境：Win10 + Python3.7 + pywinauto==0.6.8，selenium==3.14.1
示例代码
from pywinauto import Desktop import os app = Desktop() dialog = app['打开'] dialog['Edit'].set_edit_text(os.getcwd() + '.\\example-01.jpg') dialog['Button'].click() ''' 其他方法： from pywinauto import application import os app = application.Application() app.connect(title='打开') # app['Dialog']['Edit1'].type_keys(os.getcwd() + '.\\example-01.jpg') # app['Dialog']['Edit1'].SetEditText(os.getcwd() + '.\\example-01.jpg') app['Dialog']['Edit1'].set_edit_text(os.getcwd() + '.\\example-01.jpg') app['Dialog']['Button1'].click() ''' 参考：
https://mp.weixin.qq.com/s?__biz=MzU1NzgyNDI3NQ==&amp;mid=2247484679&amp;idx=1&amp;sn=a340747f16f0c5697764ede7f448a63d&amp;chksm=fc2ea57bcb592c6da51fd3f186a557ac29994bb78b919c618f17ae10fbbdfb16d7c8230e427a&amp;mpshare=1&amp;scene=1&amp;srcid=1216DMzWHdhTgZYFFbVGZHsW&amp;sharer_shareinfo=c65396678acf6d09bcf06fc57ed0addd&amp;sharer_shareinfo_first=c65396678acf6d09bcf06fc57ed0addd&amp;exportkey=n_ChQIAhIQduawNpbBAqP4iyR8%2FYTAShLyAQIE97dBBAEAAAAAAM%2FgFUW0vVIAAAAOpnltbLcz9gKNyK89dVj0DOxgVp8EciivdLsqOeEOeDn%2FVPMouyiXKMKo40Fk76NmX8%2B9UecOMBQOLNgS3oM3USy95IGseYWfWmx08Blkzlyllc0Fobk7aCaaipck4W8pJ%2BLJX6rD5iywpWQwG6vffOs6llL8yGnU6e30ZjFrjPV9IILsurSLzrVbglwwjtgTOb1FpTslaJw4PK6nBzF4Qos2x0Zj9%2FSFKiEKhPosme7v7ePriXmNDr7iQFaEOlp4p5f69wL9O1BWV0CY6ovevQu2D9r1iYKzjsn1&amp;acctmode=0&amp;pass_ticket=gc%2Bk84qheb1bQ6ScSF35lH7APcEXiU415dFWdmHHbPZqiETZGvHPyD4ZC2OJMHN7hRX2TdXRrFc16LrLv0llyg%3D%3D&amp;wx_header=0#rd
https://mp.weixin.qq.com/s?__biz=MjM5NTU0MDg0MA==&amp;mid=2651267611&amp;idx=1&amp;sn=c1ae1a4a17b1c63c18dc223d8ba23af3&amp;chksm=bd05781c8a72f10a81cf6239044a6354d9137f8e322dcea9383852f90c89fb3b554eb766eb94&amp;mpshare=1&amp;scene=1&amp;srcid=12164RziUu8kd3yryjnvtZbU&amp;sharer_shareinfo=8f38390e1fc6e5b07aaa3bd8c3e68f07&amp;sharer_shareinfo_first=8f38390e1fc6e5b07aaa3bd8c3e68f07&amp;exportkey=n_ChQIAhIQrwmNtaFAKwU0xpCrjCRctRLyAQIE97dBBAEAAAAAAHDQCsJVPy0AAAAOpnltbLcz9gKNyK89dVj0MmfYFIQO3IjAltC9jzxNXjdYR%2F31Ok%2BvtyLtDB6OaZNw%2BGBsHYRd%2BsXSUrbrXLC1ONnJ%2FPAiluSRe0iQILwcgzD8LboFF%2F8YfhIBFIAVsAYDAJfNzFpstvgOkiXf0PZsuw1p%2Bg3M7N25llXF7VQ21%2FDqePZcYMEc7JXRtEfo1%2BkWgf1VJU%2Bp9SA8EuCaSu1Tbb3CXWb0Fy%2FwCDld8LB9zJ%2FppHyc9dG6uIdBES8AiHoZDHwHkYHGvhpjrlf8ZOpDjH%2BsVwa%2BIFR0ulX2&amp;acctmode=0&amp;pass_ticket=gc%2Bk84qheb1bQ6ScSF35lH7APcEXiU415dFWdmHHbPZoefKqE%2BuBGd4YY3MF66ov5%2FCbx0d5wkGWluKyPGNFrA%3D%3D&amp;wx_header=0#rd
https://www.qiniu.com/qfans/qnso-60569025
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72f2a5e7c5051fb14847aa99cf1deed/" rel="bookmark">
			【C&#43;&#43;速刷精品】滑动窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++速刷精品】滑动窗口 一、长度最小的子数组1、题目链接2、题目解析3、代码 二、无重复字符的最长字串1、题目链接2、题目解析3、代码 三、最大连续1的个数III1、题目链接2、题目解析3、代码 四、将x减到0的最小操作数1、题目链接2、题目解析3、代码 五、水果成篮1、题目链接2、题目解析3、代码 六、找到字符串中所有字母异位词1、题目链接2、题目解析3、代码 七、串联所有单词的字串1、题目链接2、题目解析3、代码 八、最小覆盖字串1、题目链接2、题目解析3、代码 一、长度最小的子数组 1、题目链接 leetcode链接
2、题目解析 讲解一下什么是滑动窗口？
滑动窗口就是一个同向双指针利用单调性的两个指针区间为窗口，right指针往右移动则是入窗口，left指针往右移动则是出窗口，我们用的步骤如下图：
3、代码 二、无重复字符的最长字串 1、题目链接 leetcode链接
2、题目解析 构造一个hash函数表，将right和left从0开始，不断的将right的值存入到hash表中，如果发现表中存入了两个了，那么就更新left的值，并进行更新ret。
3、代码 三、最大连续1的个数III 1、题目链接 题目链接
2、题目解析 此时定义一个ret用来记录走过的0的个数，right走过一个0就加加，left走过一个0就减减，我们循环的条件在于：当right指针遇见1的时候，一直往右走直到遇见0，每遇见一个0就将ret进行加加，直到ret的个数比k大的时候就需要出窗口了，也就是我们的left指针往右移动，直到找到0，每遇见一个0就将ret减减再left往右走一步，这个判断跳出条件在于ret&lt;k，而在每次进行这个操作的时候，我们都进行算一下下标，也就是中间有多少个元素，最终等right到最后一个位置的下一个位置的时候，我们就结束。
3、代码 四、将x减到0的最小操作数 1、题目链接 leetcode链接
2、题目解析 3、代码 五、水果成篮 1、题目链接 leetcode链接
2、题目解析 3、代码 六、找到字符串中所有字母异位词 1、题目链接 leetcode链接
2、题目解析 3、代码 七、串联所有单词的字串 1、题目链接 leetcode传送门
2、题目解析 3、代码 八、最小覆盖字串 1、题目链接 leetcode链接
2、题目解析 3、代码 NO1.利用unordered_map容器来进行解决，但算法复杂度太高
No2.用hash数组进行解决，算法复杂度低
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2522f1b00fd1cfea62f9ab4b748382e3/" rel="bookmark">
			【C&#43;&#43;】智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么需要智能指针？ 智能指针就是帮我们 C++ 程序员管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而 避免内存泄漏。 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;memory&gt; using namespace std; // 动态分配内存，没有释放就return void memoryLeak1() { string *str = new string("动态分配内存！"); return; } // 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了 int memoryLeak2() { string *str = new string("内存泄露！"); // ... // 发生某些异常，需要结束函数 if (1) { return -1; } // 另外，使用try、catch结束函数，也会造成内存泄漏！ delete str;	// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放 return 1; } int main() { memoryLeak1(); memoryLeak2(); return 0; } 在 memoryLeak1 函数中，new 了一个字符串指针，但是没有 delete 就已经 return 结束函数了，导致内存没有被释放，内存泄露。在 memoryLeak2 函数中，new 了一个字符串指针，虽然在函数末尾有些释放内存的代码 delete str，但是在 delete 之前就已经 return 了，所以内存也没有被释放，内存泄露。 使用指针，我们没有释放，就会造成内存泄露。但是如果使用普通对象就不会。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2522f1b00fd1cfea62f9ab4b748382e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1413f8b2a2330655cb5eb15250471aab/" rel="bookmark">
			《三十一》开发模式构建工具 Vite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Vite4。
在实际开发中，编写的代码往往是不能被浏览器直接识别的，例如 ES6+、React、Vue、TypeScript 等，必须通过构建工具来对代码进行转换、编译，例如 Webpack、Rolluop、Vite 等。
Vite：下一代前端开发与构建工具，能够显著地提升前端开发体验。
Vite 的构成： Vite 主要由两部分构成：
一个开发服务器：基于原生的 ESModule 提供了丰富的內建功能，HMR 的速度非常快。一套构建指令：基于 Rollup 打包代码，可以打包输出优化过的静态资源。 可以对已有项目单独安装并使用 Vite；也可以直接使用 npm init vite 命令来创建一个基于 Vite 的项目。
Vite 启动本地服务为什么快速？ Vite 利用浏览器已经原生支持 ESModule，遇到 import 就发送一个 HTTP 请求去按需加载加载文件，而不需要加载整个项目。
Vite 会启动一个 Connect 服务器拦截这些请求，使用 ESBuild 构建工具动态生成转换后的 ESModule 代码返回给浏览器，而不需要提前解析依赖、打包构建后再启动开发服务器。
Vite2 之前是使用 koa 来搭建服务器；Vite2 及之后是使用 Connect 来搭建服务器。
Webpack 是先解析依赖、打包构建再启动开发服务器，因此启动时间更长。
// src/utils/index.ts export const dateFormat = (date: string) =&gt; { return `日期为：${date}` } 在首次启动 Vite 时，Vite 会预构建项目的第三方依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1413f8b2a2330655cb5eb15250471aab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/475bdd9410094bdfb695608c5e4f7a0e/" rel="bookmark">
			操作无法完成错误0x00000bc4的修复方法，以及出现0x00000bc4的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作无法完成错误0x00000bc4是一个常见的电脑错误，它可能会导致用户无法完成特定的任务或操作。接下来的这篇文章中，我们将探讨这个错误的原因，并提供一些操作无法完成错误0x00000bc4的修复方式来帮助大家解决问题，帮助大家的电脑恢复正常。
一.了解操作无法完成错误0x00000bc4的原因 首先，让我们了解一下操作无法完成错误0x00000bc4的原因。这个错误通常与操作系统或硬件设备驱动程序的问题有关。可能的原因包括：
驱动程序冲突：某些设备驱动程序可能与操作系统不兼容或与其他驱动程序发生冲突，从而导致错误的出现。
损坏的系统文件：操作系统的关键文件被损坏或缺失，导致无法完成所需的操作。
硬件问题：硬件设备故障或连接问题可能导致操作无法完成错误0x00000bc4的发生。
二.操作无法完成错误0x00000bc4的修复方式 当你遇到操作无法完成错误0x00000bc4时，以下是一些解决方法可以帮助你解决问题：
1.更新或重新安装驱动程序 检查并确保你电脑上的所有设备驱动程序都是最新版本。如果存在冲突，尝试禁用或卸载可能引起问题的驱动程序，并重新安装最新版本的驱动程序。
2.使用电脑精灵修复 这是一个专门修复错误代码的问题，先获得这个工具，可以在浏览器顶部输入：电脑修复精灵.site，点击回车键进入将工具进行获得。然后启动工具，点击一键修复即可开始对电脑中的问题进行检测。这个过程也会将操作无法完成错误0x00000bc4的问题也进行修复并解决。
3.修复操作系统 如果以上方法无效，你可以尝试使用操作系统的修复功能，如Windows系统还原或恢复到初始状态。这将帮助你恢复操作系统的稳定性并解决可能存在的问题。
4.硬件故障排除 如果操作无法完成错误0x00000bc4仍然存在，可能需要对硬件设备进行故障排除。检查设备连接是否正确，确保硬件设备正常运行，并可能需要更换故障设备。
三.其他的技巧解决操作无法完成错误0x00000bc4 除了以上提到的解决办法，还有一些其他的技巧可以尝试：
1.更新操作系统：确保你的操作系统是最新版本，以便修复已知的问题和漏洞。
2.清理系统垃圾文件：使用系统优化工具，如磁盘清理和注册表清理工具，来删除不需要的临时文件和无效的注册表项。
3.定期进行系统维护：定期进行系统维护，包括磁盘碎片整理、病毒扫描和更新等，以保持系统的良好状态。
操作无法完成错误0x00000bc4是一个可能会影响电脑正常操作的问题。在遇到这个错误时，你可以尝试通过上面的方法进行解决错误0x00000bc4的问题。此外，定期进行系统维护和保持系统更新也是预防该错误的有效方法。希望小编分享给大家的解决办法能帮助你顺利解决操作无法完成错误0x00000bc4的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f02661f7c961fa6adec0f9037b11fa/" rel="bookmark">
			exception [Request processing failed: org.mybatis.spring.MyBatisSystemException] with root cause
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动Spring框架调用时控制台报出：
2023-12-18T14:48:59.576+08:00 ERROR 28732 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.mybatis.spring.MyBatisSystemException] with root cause
org.apache.ibatis.executor.ExecutorException: No constructor found in void matching [java.lang.Long, java.lang.String, java.time.LocalDateTime, java.time.LocalDateTime]
at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.lambda$createByConstructorSignature$1(DefaultResultSetHandler.java:729) ~[mybatis-3.5.14.jar:3.5.14]
at java.base/java.util.Optional.orElseThrow(Optional.java:403) ~[na:na]
出现MyBatisSystemException，说明mybatis在进行转换的过程中出现了错误，这个时候返回代码中查看自己前端调用的方法是不是查询，如果前端调用的是查询方法，则后端需要有对应的返回值，就需要对应的封装！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f584ce940ac330d05559736750f38592/" rel="bookmark">
			前端检测字符串中是否含有特殊字符，并返回该特殊字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、判断字符串中是否含有特殊字符
const hasSpecicalCharacter = (str) =&gt; { var regex = /[!@#$%^&amp;*(),.?":{}|&lt;&gt;]/ return regex.test(str) } //含有特殊字符返回true, 没有特殊字符返回false 二、判断字符串中是否含有特殊字符，并返回该特殊字符
// 判断姓名格式是否包含特殊字符 const specialCharsRegex = /[^\w\s]/g;----&gt;匹配非字母、数字或空格的字符 //const specialCharsRegex = /[^\u4e00-\u9fa5a-zA-Z0-9\s]/g;----&gt;匹配非汉字、字母、数字或空格的字符 const matchedSpecialChars = exportInputData.value.patientName.match(specialCharsRegex); if(matchedSpecialChars &amp;&amp; matchedSpecialChars.length &gt; 0){ let mactedSpcStr = matchedSpecialChars.join(' ') ElMessage.warning(`姓名中包含特殊字符${mactedSpcStr}，不可下载！`) return } //match匹配到则返回特殊字符数组，未匹配到则返回null 注意：match方法如果匹配的是正则，正则如果加了/g，那么匹配到的结果是所有符合正则的元素组成的数组；
如果不加/g，那么匹配到的结果就是第一个符合正则的元素对象（包含元素值、位置等）
参考：【JS】match() 方法_js match-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdda528c088f11293805ba53c850fe2d/" rel="bookmark">
			关于“Python”的核心知识点整理大全27
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
10.5 小结
第１1 章
测试代码
11.1 测试函数
name_function.py
函数get_formatted_name()将名和姓合并成姓名，在名和姓之间加上一个空格，并将它们的 首字母都大写，再返回结果。为核实get_formatted_name()像期望的那样工作，我们来编写一个 使用这个函数的程序。程序names.py让用户输入名和姓，并显示整洁的全名： names.py
11.1.1 单元测试和测试用例
11.1.2 可通过的测试
test_name_ function.py
11.1.3 不能通过的测试
name_ function.py
11.1.4 测试未通过时怎么办
name_function.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
10.5 小结 在本章中，你学习了：如何使用文件；如何一次性读取整个文件，以及如何以每次一行的方 式读取文件的内容；如何写入文件，以及如何将文本附加到文件末尾；什么是异常以及如何处理 程序可能引发的异常；如何存储Python数据结构，以保存用户提供的信息，避免用户每次运行程 序时都需要重新提供。
在第11章中，你将学习高效的代码测试方式，这可帮助你确定代码正确无误，以及发现扩展 现有程序时可能引入的bug。
第１1 章 测试代码 11.1 测试函数 要学习测试，得有要测试的代码。下面是一个简单的函数，它接受名和姓并返回整洁的姓名：
name_function.py def get_formatted_name(first, last): """Generate a neatly formatted full name.""" full_name = first + ' ' + last return full_name.title() 函数get_formatted_name()将名和姓合并成姓名，在名和姓之间加上一个空格，并将它们的 首字母都大写，再返回结果。为核实get_formatted_name()像期望的那样工作，我们来编写一个 使用这个函数的程序。程序names.py让用户输入名和姓，并显示整洁的全名： names.py from name_function import get_formatted_name print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdda528c088f11293805ba53c850fe2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a9fbe59e8c69656fca4a5f63f94078/" rel="bookmark">
			【玩转Node.JS】=＞ 之 Buffer（缓冲器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js® 是一个开源、跨平台的 JavaScript 运行时环境
文章目录 Buffer 概念Buffer 的特点创建 BufferBuffer 与字符串的转化 Buffer 的读写 Buffer 概念 Buffer 是一个类似于数组的 对象 ，用于表示固定长度的字节序列Buffer 本质是一段内存空间，专门用来处理 二进制数据 Buffer 的特点 Buffer的大小固定且无法调整Buffer 性能较好，可以直接对计算机内存进行操作每个元素的大小为 1 字节（byte） 创建 Buffer 方式一：Buffer.alloc /** @创建了一个长度为 10 字节的 Buffer，相当于申请了 10 字节的内存空间，每个字节的值为 0 **/ let buf_1 = Buffer.alloc(10); // 结果为 &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt; 方式二：Buffer.allocUnsafe //创建了一个长度为 10 字节的 Buffer，buffer 中可能存在旧的数据, 可能会影响执行结果，所以叫 unsafe let buf_2 = Buffer.allocUnsafe(10); 方式三：Buffer.from //通过字符串创建 Buffer let buf_3 = Buffer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a9fbe59e8c69656fca4a5f63f94078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b74f5cb40fd08953f194d6ee5e75aa/" rel="bookmark">
			船只监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		船只识别监测摄像机是一种用于监测和识别船只的设备，它通过视频图像识别技术和智能算法来实现对船只的实时监测和识别。这种摄像机通常安装在海洋监测平台、港口码头、海岸线、湖泊、河道等位置，用于实现对船只航行情况的监测和跟踪。 船只识别监测摄像机的工作原理是通过摄像头捕捉船只的图像信息，然后通过图像识别算法对船只进行识别和分类。这种算法通常会基于目标检测和识别技术，能够识别船只的类型、大小等关键信息，并能够实时跟踪船只的航行轨迹。通过这种方式，船只识别监测摄像机可以帮助监管部门实现对船只的有效监管和管理。
船只识别监测摄像机的应用范围非常广泛，可以应用于港口海域管理、海上交通管制、海洋、湖泊、河道环境监测等多个领域。在港口海域管理方面，船只识别监测摄像机可以帮助港口管理部门对进出港船只进行实时监测和识别，确保港口安全和航行秩序。在海上交通管制方面，船只识别监测摄像机可以帮助海事部门实时掌握海上船只的情况，及时发现和处理违规船只，保障海上交通安全。在海洋、湖泊、河道环境监测方面，船只识别监测摄像机可以帮助监测环境污染和违规捕捞等行为，保护生态环境。
总的来说，船只识别监测摄像机是一种具有重要应用价值的监测设备，它能够通过先进的图像识别技术和智能算法，实现对船只的实时监测和识别，为海上监管和管理提供了重要的技术支持。希望未来能够进一步推动船只识别监测摄像技术的发展和应用，实现更加智能化和高效的海上监管和管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6b3c8bb89dc9742a45ef3e93d007c7/" rel="bookmark">
			2023 年最后一波工具安利「GitHub 热点速览」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：HelloGitHub-小鱼干
2023 年还有两周就要接近尾声了，2023 年的热点速览还有一波工具好安利：比如上周推荐之后上了热榜的远程调试工具 page-spy-web，让调试像呼吸一般自然方便；还有轻量级的搜索引擎 orama，可以让你下载 B 站视频好好过个元旦的下载姬 downkyi，JS 格式化工具 biome，Meta 开源的 JS 库 stylex 也是颇受欢迎。
以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：新发布 | 实用 | 有趣，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 New，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝
1. 本周特推 1.1 远程调试：page-spy-web 主语言：TypeScript
PageSpy 是货拉拉开源的、来调试远程 Web 项目的工具。基于对原生 API 的封装，它将调用原生方法时的参数进行过滤、转化，整理成格式规范的消息供调试端消费；调试端收到消息数据，提供类控制台可交互式的功能界面将数据呈现出来。
GitHub 地址→https://github.com/HuolalaTech/page-spy-web
1.2 搜索引擎：orama 主语言：TypeScript
Orama 是一个快速的、包含所有功能的全文和向量搜索引擎，完全用 TypeScript 编写，且没有任何依赖。Orama 具有快速、存内、容错别字、轻巧（小于 2kb）等特性，它可在浏览器、服务器和边缘计算环境中运行全文、向量和混合搜索查询。
GitHub 地址→https://github.com/oramasearch/orama
2. GitHub Trending 周榜 2.1 语言学习：project-based-learning 本周 star 增长数：1,300+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e6b3c8bb89dc9742a45ef3e93d007c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1b6323074927efeca8de127b0db3d95/" rel="bookmark">
			关于“Python”的核心知识点整理大全26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
10.3.9 决定报告哪些错误
10.4 存储数据
10.4.1 使用 json.dump()和 json.load()
number_writer.py
number_reader.py
10.4.2 保存和读取用户生成的数据
对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程 序停止运行时用户的信息将丢失。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。 我们先来存储用户的名字： remember_me.py
greet_user.py
remember_me.py
10.4.3 重构
remember_me.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
10.3.9 决定报告哪些错误 在什么情况下该向用户报告错误？在什么情况下又应该在失败时一声不吭呢？如果用户知 道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。 如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。 向用户显示他不想看到的信息可能会降低程序的可用性。Python的错误处理结构让你能够细致地 控制与用户分享错误信息的程度，要分享多少信息由你决定。 编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依 赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判 断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。
10.4 存储数据 很多程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管 专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你 几乎总是要保存他们提供的信息；一种简单的方式是使用模块json来存储数据。
模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件 中的数据。你还可以使用json在Python程序之间分享数据。更重要的是，JSON数据格式并非Python 专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。这是一种轻便格 式，很有用，也易于学习。
注意 JSON（JavaScript Object Notation）格式最初是为JavaScript开发的，但随后成了一种常见 格式，被包括Python在内的众多语言采用。
10.4.1 使用 json.dump()和 json.load() 我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第 一个程序将使用json.dump()来存储这组数字，而第二个程序将使用json.load()。 函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。下面演示了如何使用json.dump()来存储数字列表：
number_writer.py import json numbers = [2, 3, 5, 7, 11, 13] 1 filename = 'numbers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1b6323074927efeca8de127b0db3d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa3f106a4310494dd2ac1ddafc3a244/" rel="bookmark">
			Dart设计模式之单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dart设计模式之单例模式 单例模式 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
模式分析 单例类只能有一个实例。单例类必须自己创建自己的唯一实例。单例类必须给所有其他对象提供这一实例。 模式解决问题 控制实例数目，节省系统资源。保证该类只有一个实例，多处共享 优点 内存中只有一个实例，减少了内存开销，尤其是频繁创建和销毁实例避免对资源的多重占用保证全局唯一实例从而保证实例状态一致 缺点 没有接口，不能继承大量使用也会导致内存泄漏 模式应用场景 要求生产唯一序列号。WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 模式代码 class _SingleTon { _SingleTon._(); //第一种方式调用 factory _SingleTon() { return instance; } //第二种方式调用 static _SingleTon instance = _SingleTon._(); int count = 0; } class RunSingleTon implements Run { @override main() { print('单例模式创建'); print(_SingleTon().count++); print(_SingleTon.instance.count++); print(_SingleTon.instance.count++); } } 最后 在这里为了方便大家系统的学习Flutter，这里特意联合了阿里P7架构师和谷歌技术团队共同整理了一份Flutter全家桶学习资料。
内容概要：Flutter技术解析与实战、Flutter进阶学习笔记、Flutter入门与实战和Flutter完整开发实战详解。
内容特点：条理清晰，含图像化表示更加易懂。
由于文章内容比较多，篇幅有限，资料已经被整理成了PDF文档，有需要 Flutter技术解析与实战 完整文档的可扫描下方卡片免费获取！
目录 第一章 为什么 Flutter 是跨平台开发 的终极之选 01 这是为什么？02 跨平台开发03 什么是 Flutter04 Flutter 的特性 第二章 在 Windows 上搭建 Flutter 开发环境 01 使用镜像02 系统要求03 获取 Flutter SDK04 编辑器设置05Android 设置 第三章 编写您的第一个 Flutter App 第四章 Flutter 开发环境搭建和调试 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa3f106a4310494dd2ac1ddafc3a244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91715eefa483c35b72f13eb7fa931a16/" rel="bookmark">
			Dart设计模式之适配器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dart设计模式之适配器模式 适配器模式 模式分析 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。
模式难点 模式解决问题 主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
优点 可以让任何两个没有关联的类一起运行。提高了类的复用。增加了类的透明度。灵活性好。 缺点 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 模式应用场景 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
模式代码 import 'run.dart'; //官方媒体播放接口 abstract class MediaPlayer { void play(String audioType, String fileName); } //自定义媒体播放接口 abstract class AdvancedMediaPlayer { void playVlc(String fileName); void playMp4(String fileName); } //创建实现了 AdvancedMediaPlayer 接口的实体类。 class VlcPlayer implements AdvancedMediaPlayer { @override void playMp4(String fileName) {} @override void playVlc(String fileName) { print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91715eefa483c35b72f13eb7fa931a16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25297ffab9070b79eea22a5cc49f37b8/" rel="bookmark">
			vmware 17 提示 You do not have permission to enter a license key……的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
在安装虚拟机输入许可证时弹出此弹框“You do not have permission to enter a license key. Try again using the system administrator account.”。大概意思是输入许可证密钥时没有足够的权限。为了输入 VMware 许可证密钥，需要使用具有系统管理员权限的帐户。
解决方案1：
使用系统当前管理员账户
解决方案2：
右键桌面的VM图标-&gt;属性-&gt;勾选“以管理员身份运行此程序”-&gt;应用，重新运行VM尝试
解决方案3：
重新安装VM覆盖原安装目录（我是此方法解决的）
解决方案4：
使用正确的密钥
提供几个VM 17能用的密钥
1、MC60H-DWHD5-H80U9-6V85M-8280D
2、NV6RH-2RH50-0JD79-0T9N2-A22M2
文章引用：
解决方案3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48431ff590f0ff69f56ec59ce1403e1c/" rel="bookmark">
			待办事项列表项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pyqt5相关文章:
快速掌握Pyqt5的三种主窗口
快速掌握Pyqt5的2种弹簧
快速掌握Pyqt5的5种布局
快速弄懂Pyqt5的5种项目视图（Item View）
快速弄懂Pyqt5的4种项目部件（Item Widget）
快速掌握Pyqt5的6种按钮
快速掌握Pyqt5的10种容器（Containers）
快速掌握Pyqt5的20种输入控件（Input Widgets）
快速掌握Pyqt5的9种显示控件
详细学习Pyqt5中的5种布局方式
详细学习Pyqt5中的6种按钮
详细学习Pyqt5中的2种弹簧
详细学习Pyqt5的5种项目视图（Item View）
详细学习Pyqt5的4种项目部件（Item Widget）
详细学习Pyqt5的20种输入控件（Input Widgets）
详细学习Pyqt5的9种显示控件
详细学习Pyqt5的10种容器（Containers）
详细学习PyQt5与数据库交互
详细学习PyQt5中的多线程
快速学习PyQt5的动画和图形效果
快速学习PyQt5的高级自定义控件
快速学会绘制Pyqt5中的所有图（上）
快速学会绘制Pyqt5中的所有图（下）
待续。。。
项目软件最终效果图： 第一部分：项目概述 本项目的目标是创建一个简单而直观的待办事项列表应用程序。这个应用程序可以帮助用户有效地管理他们的日常任务，提供以下关键功能：
添加任务：允许用户输入并添加新任务到待办事项列表中。删除任务：提供选项以从列表中删除不再需要的任务。编辑任务：让用户能够修改现有任务的描述。搜索和过滤：使用户能够通过关键词搜索任务，便于快速找到特定任务。进度跟踪：通过进度条展示任务完成的总体进度，帮助用户了解他们完成任务的情况。 应用程序的用户界面（UI）设计注重简洁性和易用性，以确保用户能够轻松地进行日常任务管理。界面包括：
任务输入框：用于输入新任务的文本区域。控制按钮：包括添加、删除和编辑任务的操作按钮。任务显示区：展示任务列表，每个任务项包含一个复选框和任务描述。搜索框：允许用户输入关键词以过滤任务列表。进度指示器：动态显示完成的任务占总任务的百分比。 第二部分：环境搭建 准备PyQt5图形库
打开命令提示符或终端，并运行以下命令：pip install PyQt5 这个命令会从Python包索引(PyPI)下载并安装PyQt5及其依赖项。 第三部分：基础知识讲解 1. QApplication 对象 每个PyQt5应用程序的核心是QApplication对象。这个对象负责管理GUI应用程序的控制流和主要设置。在任何PyQt5程序中，QApplication对象是必须的。
app = QApplication([]) 这段代码创建了一个QApplication实例，它是我们待办事项列表应用程序的起点。
2. QMainWindow 和 QWidget QMainWindow 是主窗口类，为应用程序提供了一个带有菜单栏、工具栏、状态栏和中心部件的框架。在我们的项目中，TodoList类继承自QMainWindow。
class TodoList(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle("待办事项列表") self.setGeometry(300, 300, 600, 500) self.setWindowIcon(QIcon('icon.png')) QWidget 是所有用户界面对象的基类。在这里，我们创建了一个QWidget作为中心部件，并在其上布置其他控件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48431ff590f0ff69f56ec59ce1403e1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ce2b479d052c9bc9418477237b2f62/" rel="bookmark">
			Hive建表语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 单字符分隔符 create table t1 ( a int, b string ) row format delimited fields terminated by ','; -- 单字符分隔符、跳过首行 create table t1 ( a int, b string ) row format delimited fields terminated by ',' SKIP_HEADER=TRUE; -- 单字符分隔符、跳过第1行 create table t1 ( a int, b string ) row format delimited fields terminated by ',' SKIP_HEADER=TRUE tblproperties("skip.header.line.count"="1"); -- 单字符分隔符、双引号括起来 CREATE TABLE t1 ( a int, b string ) ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' ESCAPED BY '"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ce2b479d052c9bc9418477237b2f62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555aebf81f5fba90cd94f30df054d627/" rel="bookmark">
			vite基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite的了解与使用 基本知识 开发时，并不对代码打包，而实直接采用ESM的方式运行项目一
项目部署时，再对项目进行打包
核心原理
其核心原理是利用浏览器现在已经支持ES6的import，碰见import就会发送一个HTTP请求去加载文件
使用vite运行项目时，首先会用esbuild进行预构建，将所有模块转换为 ESM，不需要对我们整个项目进行编译打包，Vite 启动一个服务器,在浏览器需要加载某个模块时，它会拦截这些请求，根据请求进行按需编译，（服务器拦截对 *.vue 文件的请求，即时编译它们，然后将它们作为 JavaScript 发回）然后返回给浏览器。
特点
快速的冷启动：采用No Bundle和esbuild预构建，速度远快于Webpack,Esbuild 使用 Go 语言编写，JS 本质上是单线程语言，GO 语言天生具有多线程的优势
高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载，增加缓存策略：源码模块使用协商缓存，依赖模块使用强缓存
基于 Rollup 打包：生产环境下使用Rollup进行打包（目前rollup比较成熟，esbuild虽然快，但有些功能还在开发中）
简单上手体验 Vite 要求 Node.js 版本 &gt;= 12.0.0
快速构建一个项目
npm init vite@latest # npm 6.x npm init vite@latest my-vue-app --template vue # npm 7+, 需要额外的双横线： npm init vite@latest my-vue-app -- --template vue pnpm来初始化一个项目
pnpm create vite 然后按照提示完成项目的初始化： 输入项目名称 选择框架类型 选择语言类型 下面其实就和上面一样，只是一开始就将项目名称给定好了
pnpm create vite my-vue-app -- --template vue 构建命令 vite：启动开发服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/555aebf81f5fba90cd94f30df054d627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba556b0957599532f7f64ef42c8ea05/" rel="bookmark">
			React和React native
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React 和 React Native 都是由 Facebook 开发的开源 JavaScript 库，用于构建用户界面。虽然它们的名称和开发者相同，但它们的应用场景和功能有所不同。
React
React 是一个用于构建用户界面的 JavaScript 库，尤其是单页面应用。它是由 Facebook 在 2013 年发布的，现在已经成为最流行的前端框架之一。React 的主要特点是：
组件化：React 采用组件化的思想，使得代码可以被封装成独立、可复用的组件。每个组件都有自己的状态和属性，组件的状态或属性的变化会引发组件的重新渲染。
虚拟 DOM：React 引入了虚拟 DOM 的概念，当组件的状态或属性改变时，React 会在内存中创建一个新的虚拟 DOM 树，然后与旧的虚拟 DOM 树进行比较，找出差异，最后将差异应用到真实的 DOM 树上，这个过程被称为 "reconciliation" 或 "diffing"。这种方式可以极大地提高页面的性能。
单向数据流：React 实现了单向数据流，也就是说，数据只能从父组件传递到子组件。这使得数据的流动变得更容易追踪和理解。
React Native
React Native 是一个用于构建原生移动应用的框架。它是在 React 的基础上开发的，允许你使用 JavaScript 和 React 来写 iOS 和 Android 应用。React Native 的主要特点是：
跨平台：React Native 允许你使用同一套代码来开发 iOS 和 Android 应用。虽然某些情况下你可能需要写平台特定的代码，但大部分代码都可以在两个平台上共享。
原生组件：React Native 使用原生组件，而不是 Web 组件。例如，你会使用 React Native 的 &lt;View&gt; 和 &lt;Text&gt; 组件，而不是 HTML 的 &lt;div&gt; 和 &lt;p&gt;。这意味着 React Native 应用的性能和外观与使用 Objective-C、Swift 或 Java/Kotlin 写的原生应用相当。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba556b0957599532f7f64ef42c8ea05/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/29/">«</a>
	<span class="pagination__item pagination__item--current">30/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/31/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>