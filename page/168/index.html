<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6814443dfa48425af445cebbea8b72f/" rel="bookmark">
			【题解】洛谷 P2296 [NOIP2014 提高组] 寻找道路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目传送门
题意：
无向连通图 G G G 有 n n n 个点， n − 1 n-1 n−1 条边。点从 1 1 1 到 n n n 依次编号,编号为 i i i 的点的权值为 W i W_i Wi​，每条边的长度均为 1 1 1。图上两点 ( u , v ) (u,v) (u,v) 的距离定义为 u u u 点到 v v v 点的最短距离。对于图 G G G 上的点对 ( u , v ) (u,v) (u,v)，若它们的距离为 2 2 2，则它们之间会产生 W u × W v W_u\times W_v Wu​×Wv​ 的联合权值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6814443dfa48425af445cebbea8b72f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c773c6c088fe4b03f33c5063804bb8/" rel="bookmark">
			Vueuse包提供的useIntersectionObserver 方法如何使用（参数；返回值）实现无限下拉信息流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 IntersectionObserver 异步监听方法，实现无线信息流下拉加载，
&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 1. 设置容器元素，view-list--&gt; &lt;div class="view-list"&gt; &lt;!-- 2. 循环一个列表,新数据进行追加,下面增加一个loading条--&gt; &lt;div class="item" v-for="(item,index) in itemData" :key="index"&gt;账号ID：{{index}}&lt;/div&gt; &lt;div class="item" id="loading"&gt;加载中&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App', components: { }, data(){ return { itemData:[] } }, methods:{ // 获取随机数 getRange(){ let id = new Date().getTime(); return Math.random()*id; }, // 触发监听回调 loadList(status){ status = status[0]; let isShow = status.isIntersecting; if(isShow){ console.log("加载中 ---- "); for(let i = 4;i&gt;=0;i--){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c773c6c088fe4b03f33c5063804bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923352bbdcda61aa1ddb2b3e0f4bd3d7/" rel="bookmark">
			将多个文件夹下的文件合并到一个文件夹下（指定的文件夹）脚本 删除目录下的空文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 使用bat脚本合并文件夹 1.在D盘新建all文件夹（用于存放合并后的文件） 2.在需要合并的多个文件夹的同级目录新建.bat文件。 @echo on for /f "delims=" %%p in ('dir /b/ad') do move %%p\*.* D:\all\ pause 此处将所有合并后的文件均放在D:\all\下的文件夹内。（若想修改合并后存放文件的位置，替换掉D:\all\ 换成相应修改的路径即可）
3.双击脚本文件运行。 二、清除文件夹下所有的空文件夹 若想清除D:\Test\的空文件夹 1.任意位置新建.bat脚本文件 @echo off for /f "delims=" %%a in ('dir /ad /b /s D:\BlankTest\^|sort /r') do ( rd "%%a"&gt;nul 2&gt;nul &amp;&amp;echo 空目录"%%a"成功删除！ ) pause 双击脚本文件运行即可。（若想修改删除空文件夹的位置，修改D:\BlankTest\ 替换为相应路径即可）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad293938c0739f35fd0f662c4df770dc/" rel="bookmark">
			微积分的本质学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微积分的本质01 1、圆形的面积 为什么圆的面积公式是Area = πr^2
可以将圆分为无数个宽度相同的同心圆环，这保留了圆的对称性。
将其中一个圆环拉直并思考他的面积
拉直后的图形可以近似看做一个长方形，宽为2πr（根据圆的定义周长公式）高为dr（每一个圆环的宽度），当dr趋近于无限小时，这个图形越趋近于长方形。
所以这个圆环的面积可以近似看做2πrdr（dr越小越准确）
以圆环的半径r为横坐标已圆环的周长为纵坐标，将每个圆环从小到大排布在坐标系上
当dr无限小时，所有圆环的面积之和也就是这个圆形的面积可以看做这些圆环所形成的的三角形的面积0.532pi3也就是piR^2
数学中的很多难题都可以分解为许多小数量的和
2抛物线形成的面积如何计算 找到一个函数A（x），当抛物线X^2的x变化时，函数A（X）就是抛物线形成的面积，这个函数A（x）就是这个抛物线的积分。
3导数 导数就是dx越来越小时这个比值所趋向的值，表示函数对取值的微小变化的敏感程度。
4微积分的基本定理 某图像下方面积函数的导数，就是能够还原定义这个图像的函数。
微积分的本质02导数悖论 1学习导数 导数是瞬时变化率，但变化率是在一段时间内的变化率，而瞬时没有变化。
想象一辆车先加速后减速在3秒内移动了10米，一下是关于距离和时间的图像。
在上面画出车速和时间的关系
速度时间函数随着距离时间函数的变化而产生变化。
速度代表什么
计算速度需要两个时间点，但在坐标轴上每个时间点都对应一个速度值。
所以要计算速度可以取很小的时间差dt，计算每个点的速度就可以写作
这样对于每个时间t带入公式都可以得到该时间点的速度。
2导数的含义 导数并不是在dt为某个具体值比如0.01时ds和dt的比值而是当dt无限逼近于0时这个比值的极限。
从图像上看，在t点和t+dt上做一条直线，当dt逼近无限小时这个直线越和曲线在这个点的切线重合。
导数是某个点的变化率的最佳近似。
3导数的推导 假设距离时间的关系是
当t = 2时
即：
简化后得到：
当dt逼近于0时，后面的项目可以简化，并把2换成横轴的变量t
那么函数s(t) = t3的导数就是3(t)2
最佳近似
导数测量的是某个点的变化率的最佳近似值。
微积分的本质03用几何来求导 微小变化量才是导数的本质
1、x2 导数 可以将x2 看做一个正方形的面积。
当x增大dx时，整个正方形的面积增大有三个部分。
1、x3 导数 f(x) = x3 可以看做一个立方体的体积
当x变化dx个单位时f（x）的体积变化可以看成多个小体积的变化
当dx趋近于0时，f（x）的增量可以看做三个大的长方体的体积和
所以df = 3x2* dx
df/dx = 3x2
微积分的本质03直观理解链式法则和成绩法则 1、加法法则 两个函数的和的导数就是他们导数的和
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad293938c0739f35fd0f662c4df770dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf75e005ade614bd1029167e9f649188/" rel="bookmark">
			[前端]Javascript进阶学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Javascript作用Javascript使用声明用法基本操作函数事件属性正则表达式语法方法 异常处理this 关键字let关键字 Javascript异步编程回调函数异步AJAX 前言 基本的变量语法,条件循环语句（与c语言类似）等请看菜鸟教程
Javascript作用 写入html输入流 &lt;script&gt; document.write("&lt;h1&gt;这是一个标题&lt;/h1&gt;"); document.write("&lt;p&gt;这是一个段落。&lt;/p&gt;"); &lt;/script&gt; 响应事件
如在button按钮中声明onclick方法触发相应事件 &lt;button type="button" onclick="alert('欢迎!')"&gt;点我!&lt;/button&gt; 改变html内容，同样包括html图像 &lt;p id="demo"&gt; JavaScript 能改变 HTML 元素的内容。 &lt;/p&gt; &lt;script&gt; function myFunction() { x=document.getElementById("demo"); // 按照id找到demo元素对应的内容 x.innerHTML="Hello JavaScript!"; // 自定义改变内容 } &lt;/script&gt; &lt;button type="button" onclick="myFunction()"&gt;点击这里&lt;/button&gt; 在myFunction方法中自定义改变内容：
改变内容： x.innerHTML=" " 改变样式： x.style.color=" " //color为style包含的属性之一 对内容加以判断，如判断输入的内容(value值）是否为数字： var x=document.getElementById("demo").value; if(x==""||isNaN(x)) { alert("不是数字"); } Javascript使用 声明 必须放在&lt;script&gt;与 &lt;/script&gt;标签之间
变量使用var 声明，声明字符串：
var firstName = "John" var firstName = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf75e005ade614bd1029167e9f649188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bae864d252b94884e72eadf83a2676/" rel="bookmark">
			（Mybatis笔记）mybatis-plus 3.4.3.4 &#43; mybatis-plus-generator 3.5.1 代码生成器使用——超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.特性
3.开始使用
4.演示自动生成过程java+xml
5.改动UserLoginController（测试自带的CRUD）
6.自定义SQL语句
7.Swagger2接口文档配置类
8.完整自动生成类FastAutoGeneratorTest.java
9.总结
前提须知：使用（以下教程仅适用 3.5.1 以上版本，对历史版本的不兼容） Github源码地址：https://github.com/GuiZhouAndroid/mybatisDemo
1.前言 MyBatis-Plus （简称 MP）是Mybatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
本章主要是配置MP及代码自动生成器相关测试，没有介绍MP主要功能使用。
下一章介绍使用MP封装的CRUD接口与MySQL数据交互的教程，传送门链接：
（Mybatis笔记）Mybatis-Plus——封装接口IService使用（一）
CSDN链接：https://blog.csdn.net/qq_39038178/article/details/120612802
（Mybatis笔记）Mybatis-Plus——封装接口IService使用（二）
CSDN连接：https://blog.csdn.net/qq_39038178/article/details/120668991
2.特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5bae864d252b94884e72eadf83a2676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702f6bd8e963cd5526d45d924f1d7729/" rel="bookmark">
			【shadergraph入门】对材质进行UV操作&amp;自发光效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【shadergraph入门】对材质进行UV操作&amp;自发光效果 1、首先在Asset面板中右键新建一个材质球来对其进行UV操作；
2、在Asset中右键创建一个类型的shadergraph，我这里新建的是Unlitshadergraph，HD Render Pipeline 是高清渲染管线，需要选择高清渲染管线下的SG后面才好做透明效果。
3、然后在场景中创建一个球体
4、然后把建好的Shadergraph拖动到Material球上，再将Material球拖动到场景中的球体上；
5、双击点开shadergraph，在shadergraph中点击空格在input中选择texture-&gt;sampletexture2D；
6、导入两张贴图资源到Asset；
7、有alpha通道的让其变透明并应用
7、在shadergraph中，sample 2D节点中中导入贴图；
8、然后将shader的端口暴露到面板上，这样在inspector面板中就可以直接编辑而无需再次打开SG来调整；
9、在SG面板中点击保存后Unity就会编译这个三个，然后再在主面板中把贴图贴到球上面；
10、空格-&gt;UV-&gt;Tiling and offset节点；
11、让UV的两个参数暴露出来：创建一个vector2；
则在主面板可以看到：面板中出现了vector2；
12、用一个四维向量来管理RGBA值；
（vector在base中或者直接在属性面板中添加，split在channel中添加）
修改默认值，让XY控制tiling，让zw控制offset；（Tiling表示平铺的贴图数量，而offset表示贴图的偏移值）
然后要分别合并两个值以链接到tiling&amp;offset上，另外再创建一个combine来链接剩下两个操作；
至于为什么要用四维向量？是四维向量比二维向量的性能更好；
接下来添加球体的自发光效果：
1、在color的mode处选择HDR渲染管线然后Default一栏拾色器出现HDR，然后保存编译；
2、拾色器面板也会发生改变，有了自发光的滑动条：
在这个面板的Intensity选择发光程度；
3、若想要改变发光的颜色，在物体上添加volume组件-新建文件夹-添加post-prossue-bloom-调整threshold大于1；
4、选择tint改变颜色；
5、如图可以得到红色的自发光；
学习链接来自：https://www.bilibili.com/video/BV1HW41127Yk?spm_id_from=333.999.0.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a228529ed903331681676411eddf60b3/" rel="bookmark">
			Android项目迁移到 AndroidX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Android Studio 迁移现有项目 使用 Android Studio 3.2 及更高版本，您只需从菜单栏中依次选择 Refactor &gt; Migrate to AndroidX，即可将现有项目迁移到 AndroidX。
重构命令使用两个标记。默认情况下，这两个标记在 gradle.properties 文件中都设为 true：
//Android 插件会使用对应的 AndroidX 库而非支持库。 android.useAndroidX=true //Android 插件会通过重写现有第三方库的二进制文件，自动将这些库迁移为使用 AndroidX。 android.enableJetifier=true 注释 1、如果要迁移未使用任何第三方库但带有需要转换的依赖项的现有项目，可以将 android.useAndroidX 标记设置为true，并将 android.enableJetifier 标记设置为 false。
2、执行迁移之前，请先将应用更新到最新版本。 我们建议您将项目更新为使用支持库的最终版本：版本 28.0.0。 这是因为，1.0.0 版本的 AndroidX 工件是与支持库 28.0.0 工件等效的二进制文件。
参考 官方文档：迁移到 AndroidX
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962f3cab14417956cacd2f4fb446d744/" rel="bookmark">
			基于STM32的电子琴音乐播放器设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于STM32的电子琴/音乐播放器设计 文章目录 基于STM32的电子琴/音乐播放器设计@[toc]引言第一章 总体设计1.1 系统功能1.2 主要技术性能指标 第二章 系统设计2.1 系统设计2.2 硬件设计2.2.1 整体仿真图2.2.2 按键模块2.2.3 扬声器模块2.2.4 显示模块2.2.5 主控模块 2.3 软件设计2.3.1 主要工作原理2.3.2 PWM发生器2.3.3 music播放器模块2.3.4 exti外部中断2.3.5 按键相关驱动2.3.6 LCD1602驱动2.3.7 主函数相关设计 第三章 系统调试3.1 仿真调试3.2 仿真结果3.3 实际电路调试3.4 功能测试3.5 过程中遇到的问题 第四章 总结3.2 仿真结果3.3 实际电路调试3.4 功能测试3.5 过程中遇到的问题 第四章 总结 引言 ​ 单片微型计算机室大规模集成电路技术发展的产物，属于第四代电子计算机它具有高性能、高速度、体积小、价格低廉、稳定可靠、应用广泛的特点。他的应用必定导致传统的控制技术从根本上发生变革。因此，单片机的开发应用已成为高科技和工程领域的一项重大课题。
​ 电子琴是现代电子科技与音乐结合的产物，是一种新型的键盘乐器。它在现代音乐扮演重要的角色，单片机具有强大的控制功能和灵活的编程实现特性，它已经溶入现代人们的生活中，成为不可替代的一部分。本文的主要内容是用STM32f103rbt6单片机为核心控制元件，设计一个电子琴。
​ 设计核心在于使用STM32单片机内置的
第一章 总体设计 1.1 系统功能 按照设计要求，本系统具有以下功能：
共有三个基本模式：电子琴模式、录音模式、播放器模式电子琴模式下，7个基本按键控制产生7种音调，功能键实现调节音阶和音量录音模式可分为录音和放音两个模块，录音状态下会记录弹奏的音调以及时间；放音模式调用音乐播放器某些模块，实现相同的功能。音乐播放器模块下，可以实现音乐的播放、暂停、切歌、调速、顺序播放、单曲循环、随机播放、以及进度条显示。有两个全局按键中断，可控制模式切换和全局静音/暂停。 1.2 主要技术性能指标 基本按键：7个；功能按键：6个；全局中断按键：2个；扬声器：1个；扬声器功率：1w；LCD1602：1块；主要模式：3个；曲库：8首；音域范围：262Hz~2217Hz；音量阶数：3阶；速度阶数：4阶；循环模式：3种； 第二章 系统设计 2.1 系统设计 ​ 总体系统设计上在硬件上共分为3个区域：基本按键区、功能按键区、LCD显示区。在软件的设计上共分为3个主要模式：电子琴模式、录音模式、播放器模式。主控模块选择使用STM32f103rbt6芯片，进行编程、控制、实现电子琴以及播放器功能。
2.2 硬件设计 2.2.1 整体仿真图 2.2.2 按键模块 ​ 按键模块分为两部分：基本按键和功能按键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/962f3cab14417956cacd2f4fb446d744/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e824839ee0ff58c3990a4d4b8aea40/" rel="bookmark">
			面试官：说说常见的排序算法有哪些？区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是什么 排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列
排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的
对于排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性
时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义
稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变
即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的
二、有哪些 常见的算法排序算法有：
冒泡排序
选择排序
插入排序
归并排序
快速排序
冒泡排序 一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来
思路如下：
比较相邻的元素，如果第一个比第二个大，就交换它们两个
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数
针对所有的元素重复以上的步骤，除了最后一个
重复上述步骤，直到没有任何一堆数字需要比较
选择排序 选择排序是一种简单直观的排序算法，它也是一种交换排序算法
无论什么数据进去都是 O(n²)的时间复杂度。所以用到它的时候，数据规模越小越好
唯一的好处是不占用额外的内存存储空间
思路如下：
在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
重复第二步，直到所有元素均排序完毕
插入排序
插入排序是一种简单直观的排序算法
它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
解决思路如下：
把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的
从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
重复上述过程直到最后一个元素被插入有序子数组中
归并排序 归并排序是建立在归并操作上的一种有效的排序算法
该算法是采用分治法的一个非常典型的应用
将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序
解决思路如下：
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
设定两个指针，最初位置分别为两个已经排序序列的起始位置
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
重复步骤3直到某一指针到达序列尾
将另一序列剩下的所有元素直接复制到合并序列尾
快速排序 快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小
再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列
解决思路如下：
从数列中挑出一个元素，称为"基准"（pivot）
重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序
三、区别 除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等......
区别如下图所示：
参考文献 https://www.runoob.com/w3cnote/bubble-sort.html
http://www.x-lab.info/post/sort-algorithm/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e824839ee0ff58c3990a4d4b8aea40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6d6fd7de77dc7bd6a4f99d5f496c33e/" rel="bookmark">
			nginx_location
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例1.
2.0 root alias
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d63276574b050957abde9fba16e7e72/" rel="bookmark">
			moment 时间类型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 初始化为当前时间：
let now = moment();等价于 moment(new Date()); 使用时间戳初始化：
moment(number); // number为毫秒 moment.unix(number); //number为秒 使用JS Date对象初始化
let date = new Date(); moment(date); moment对象转换成时间戳
let time = moment.valueOf() 把时间戳转换为指定时间样式
new Date(new Date().getTime() - 24 * 60 * 60 * 1000 * (i + 31)).toLocaleDateString().split('/').join('.') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335b5f90aae724df6420a0431b8241ea/" rel="bookmark">
			图像处理​​​​​​​--十大经典算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读：随着现代社会的发展，信息的形式和数量正在迅猛增长。其中很大一部分是图像，图像可以把事物生动地呈现在我们面前，让我们更直观地接受信息。
这是小编的其他文章,希望对大家有所帮助,点击即可阅读
人工智能常用的十大算法 人工智能数学基础（一） 人工智能数学基础(二)
人工智能数学基础（三） 人工智能数学基础（四）
为了方便大家学习交流，我建了一个扣裙：966367816（学习交流、大牛答疑、大厂内推）
另外我还整理了整整200G的人工智能学习笔记、课程视频、面试宝典一并可以无套路免费
分享给大家！
定义 图像处理（image processing）又称为影像处理，是用计算机对图像进行达到所需结果的技术。应用广泛，多用于测绘学、大气科学、天文学、美图、使图像提高辨识等
图像处理是对图像进行分析、加工、和处理，使其满足视觉、心理以及其他要求的技术。图像处理是信号处理在图像域上的一个应用，目前大多数的图像是以数字形式存储，因而图像处理很多情况下指数字图像处理。
下面简单介绍下数字图像处理领域中的经典算法。
深度优先搜索(DFS) DFS（Depth-First-Search）深度优先搜索，是计算机术语，是一种在开发爬虫早期使用较多的方法，是搜索算法的一种。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件) 。
深度优先遍历图的算法是，假定给定图G的初始状态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索递归调用步骤：
1、访问搜索到的未被访问的邻接点；
2、将此顶点标记为已访问节点；
3、搜索该顶点的未被访问的邻接点，若该邻接点存在，则从此邻接点开始进行同样的访问和搜索，反复进行直到所有节点都被访问为止。
算法详解:
首先选定图的类别（有向图、无向图），再选定图的存储结构，根据输入的顶点或者边建立图；并把相应的邻接表或者邻接矩阵输出；
根据已有的邻接矩阵或邻接表用递归方法编写深度优先搜索遍历算法，并输出遍历结果；
图的深度遍历原则：
1 如果有可能，访问一个领接的未访问的节点，标记它，并把它放入栈中。
2 当不能执行规则 1 时，如果栈不为空，则从栈中弹出一个元素。
3 如果不能执行规则 1 和规则 2 时，则完成了遍历。
代码中的图使用的是Graph 图－邻接矩阵法 来表示，其他的表示法请见：Graph 图－邻接表法
代码中的Stack为辅助结构，用来记载访问过的节点。栈的详细描述可以见：ArrayStack 栈 ，LinkedStack 栈 。
Vertex表示图中的节点，其中包含访问，是否访问，清除访问标志的方法。 Graph.main：提供简单测试。代码可以以指定下标的节点开始作深度遍历。 代码比较简单，除了Graph.dsf(int i)深度优先遍历算法外没有过多注释。
广度优先搜索(BFS) 广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。
作法:
BFS是一种盲目搜索法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能地址，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。
从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实现里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。（open-closed表）
A*搜索算法 A*算法是一种静态路网中求解最短路最有效的直接搜索方法。之后涌现了很多预处理算法（ALT，CH，HL等等），在线查询效率是A*算法的数千甚至上万倍。
A*算法操作：首先将起始结点S放入OPEN表，CLOSE表置空，算法描述：
1、如果OPEN表不为空，从表头取一个结点n，如果为空算法失败。
2、n是目标解吗？是，找到一个解（继续寻找，或终止算法）。
3、将n的所有后继结点展开，就是从n可以直接关联的子结点，如果不在CLOSE表中，就将它们放入OPEN表，并把S放入CLOSE表，同时计算每一个后继结点的估价值f(n)，将OPEN表按f(x)排序，最小的放在表头，重复算法，回到1。
Dijkstra算法 戴克斯特拉算法（又译迪杰斯特拉算法） 是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/335b5f90aae724df6420a0431b8241ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e747af7e0aa8e91c14cca64d845dc0/" rel="bookmark">
			电子产品历史价格怎么查？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能是因为有部分人从来没有使用过产品历史价格查询网站或者是软件，所以在第一次接触或者是还没有接触之前，都会担心自己如果自主进行查询的话，是不是不知道如何查询或者是不知道如何进行操作。不过不用担心，因为今天就来为大家分享一下关于电子产品历史价格怎么查的方法，希望能够给大家带来帮助。
知道电子产品历史价格怎么查以后，其他的产品在查询的时候都可以按照相同的方法。
在查询电子产品时，肯定要键入关键词，比如说电子产品的品牌以及产品的型号，或者是店铺的名称，然后点击进行搜索就可以看到页面弹出来关于电子产品的历史成交价格信息了。看到具体的历史成交价格以及具体的走势以后，在进行查询的时候，大家就可以根据自己的预算以及结合目前的报价，然后选择一个在自己预算范围之内的产品进行成交。
前面也说了关于电子产品历史价格怎么查的问题答案可以直接套用在任何产品上面，大家在进行查询的时候可以直接按照套路进行查询，这样的话，任何的产品在购买之前，都可以直接进行查询和使用。不过需要注意的是，产品在进行查询的时候，关键词一定要选择正确。还有就是类似的产品，但是产品的品牌不一样，那么在成交价格上可能会存在差异，这一点大家要在对比的时候仔细观察一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f8fdcfdd300dd84570674258651ad93/" rel="bookmark">
			ubuntu开机跳过输入密码登录和默认桌面显示，直接启动图形应用程序，替换默认图形桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自动登录
Ubuntu开机自动登录，这个应该没什么难点，自行百度。
2.关闭默认的桌面和设置为自己的图形程序
到/usr/share/xsessions目录下
cd /usr/share/xsessions ls 可以看到ubuntu-communitheme-snap.desktop和ubuntu.desktop两个文件，将这个两个文件重命名：
mv ubuntu-communitheme-snap.desktop ubuntu-communitheme-snap.desktop.bak mv ubuntu.desktop ubuntu.desktop.bak 在/usr/share/xsessions目录下创建类似的文件：
vi myapplication.desktop 写入内容
[Desktop Entry] Name=myapplication Comment=auto start myapplication Exec=/home/xx/myapplication.AppImages Icon= Type=Application /home/xx/myapplication.AppImages 为要运行的程序 给权限
chmod -R 777 /usr/share/xsessions/myapplication.desktop 如上就可以做到，你开机Ubuntu后，不显示Ubuntu自己的桌面，然后直接打开你自己的图形程序。是否可以理解为类似于ATM机器一样呢，不显示Windows桌面一样？
3.修改开完机logo
到/usr/share/plymouth/themes/ubuntu-logo/目录下
cd /usr/share/plymouth/themes/ubuntu-logo/
1
你可以看到一个ubuntu-logo.png的图片，这个就是开机和关机显示那个ubuntu的logo；
直接修改它。算了还是备个份吧
mv ubuntu-logo.png ubuntu-logo.png.bak
1
把你的logo传到这个目录下，命名为ubuntu-logo.png
是的，你说的没有错，这个方法 有点生硬 ，但是 方便快捷 呀~
4.reboot
应该是没啥问题了，reboot，看看是不是开机就直接是你的APP了呢？
好呢，不是的话，你再继续google吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679eb031373a3a9d822dd05632913eb7/" rel="bookmark">
			C 语言 —— 多维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多维数组其实就是二维数组的继续延申，而且在正常项目中，常用的多维数组就是二维数组了，因此下面我们重点介绍一下二维数组的定义、初始化以及使用。
1. 什么是二维数组？ 我们之前介绍的数组只有一个下标，称为一维数组，其数组元素也称为单下标变量。
在实际问题中有很多量是二维的或多维的，因此 C 语言允许构造多维数组。多维数组元素有多个下标，以标识它在数组中的位置，所以也称为多下标变量。
二维数组就是有两个下标的数组，是常用的多维数组，更高维的数组其实使用的并不多。
2. 二维数组的定义 二维数组定义的一般形式：
type array_Name[n][m]; PS：type 是数组元素的类型，array_Name 是数组名，n 和 m 为常量表达式。
float rain[5][12]; 应该如何理解这个数组？
事实上，C 语言依旧将二维数组识别为一维数组，只不过数组的元素不再是如 int 类型的变量了，而是一个数组。那么 rain[5][12] 是有 5 个元素的数组，其中每个元素是一个含有 12 个元素的数组，还是有 12 个元素的数组，其中每个元素是一个含有 5 个元素的数组呢？
这个问题在于 [] 这个运算符的结合方向，[] 是自左向右的，因此编译器识别 rain[5][12] 时，会先和 [5] 结合，认为 rain 是一个含有 5 个元素的数组，然后识别 [12] 认为 rain 的每一个元素都是一个含有 12 个元素的数组。
根据以上分析可知，rain 的首元素 rain[0] 是一个内含 12 个 float 类型值的数组。所以，rain[1]、rain[2]等也是如此。如果 rain[0] 是一个数组，那么它的首元素就是 rain[0][0]，第 2 个元素是 rain[0][1]，以此类推。简而言之，数组 rain 有 5 个元素，每个元素都是内含 12 个 float 类型元素的数组，rain[0] 是内含 12 个 float 值的数组，rain[0][0] 是一个 float 类型的值。假设要访问位于 2 行 3 列的值，则使用 rain[2][3]（记住，数组元素的编号从 0 开始，所以 2 行指的是第 3 行）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/679eb031373a3a9d822dd05632913eb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5282ff929fb9528e17b5d8c69677ec1/" rel="bookmark">
			js将数组对象提取出固定id并组成新的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var ids = this.multipleSelection.map(item =&gt; { return item.id }) JavaScript Array map() 方法 map()方法创建一个新数组，其结果是为每个数组元素调用一个函数。map()方法按顺序为数组中的每个元素调用一次提供的函数。
注意： map()不会为没有值的数组元素执行函数。
注意： map()不会更改原始数组。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95cd3341adbb8c2da3cbfb66879896a/" rel="bookmark">
			图神经网络的分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图卷积神经网络 GCN、GraphSage都属于图卷积神经网络，都是利用节点与节点周围的邻居信息不断的聚合，以学习到节点的高层表示。
PATCH-SAN：因为GCN和GraphSage聚合邻居信息时具有排列不变性，而PATCH-SAN是真正利用卷积操作，去完成节点的深层次的学习。
Graph Attention NetWork GAT利用节点之间的attention，求出节点与周围邻居节点的attention系数，然后通过聚合邻居节点得到下一层的特征表示。
Graph Auto-encoder 输入一张图graph，然后通过GCN得到图的隐层节点特征表示z，然后 z ⋅ z T z ·z^T z⋅zT还原出一张图，然后求输入图与输出图的结构性误差，当做损失函数，最小化loss之后，就学到了GCN的参数。与autoencoder思想类似，只不过把encoder转为GCN，decoder转为 z ⋅ z T z·z^T z⋅zT
Graph Spatial-Temporal Networks(图时空网络) 同时考虑图的空间性和时间维度。比如在交通邻域中，速度传感器会随时间变化的时间维度，不同的传感器之间也会形成连接的空间维度的边。当前的许多方法都应用GCN来捕获图的依赖性，使用一些RNN 或CNN 对时间依赖性建模。
Graph Generative NetWork（图生成网络） 通过RNN或者GAN的方式生成网络。图生成网络的一个有前途的应用领域是化合物的生成。在化学图中，原子被视为节点，化学键被视为边，任务是发现具有某些化学和物理性质的新的可合成分子。
Graph Reinforcement Learning（图强化学习） 采用强化学习的方法应用于图网络上
Graph Adversarial Methods GAN思想，生成器生成样本，分类器去判别样本
通用框架 MPNN消息传递网络 统一了各种图神经网络和图卷积网络，分为两个阶段：
消息传递阶段Readout阶段 消息传递阶段
在消息传递阶段分为两个函数：
（1）消息函数Mt ：聚合了自己的节点 h v t h_v^t hvt​、邻居节点 h w t h_w^t hwt​和边的特征 e v w e_{vw} evw​，通过消息聚合函数 M t M_t Mt​，得到聚合邻居的信息 m v t + 1 m_v^{t+1} mvt+1​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95cd3341adbb8c2da3cbfb66879896a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b3d23fedcc8ce256f33dbd1597c47a/" rel="bookmark">
			机器学习_线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XDU机器学习第一次作业
目录
一、线性回归
二、代价函数的表示
三、梯度下降
四、代码实现
运行结果：
进阶
一、线性回归 回归问题是非常常见的一类问题，目的是寻找变量之间的关系。比如要从数据中寻找房屋面积与价格的关系，年龄和身高的关系，气体压力和体积的关系等等。而机器学习要做的正是要让机器自己来学习这些关系，并为对未知的情况做出预测。
对于线性回归，假设变量之间的关系是线性的，即：
其中 θ\pmb{\theta}θθ 就是学习算法需要学习的参数，在线性回归的问题上，就θ1\theta_{1}θ1​和θ0\theta_{0}θ0​，而 xxx 是我们对于问题所选取的特征，也即输入。hhh表示算法得到的映射。
二、代价函数的表示 为了找到这个算法中合适的参数，我们需要制定一个标准。一般而言算法拟合出来的结果与真实的结果误差越小越好，试想一下如果算法拟合出来的结果与真实值的误差为零，那么就是说算法完美地拟合了数据。所以可以根据“真实值与算法拟合值的误差”来表示算法的“合适程度”。在线性回归中，我们经常使用最小二乘的思路构建代价函数：
这里由假设模型得出。对线性回归任务，代价函数可以展开为：
误差函数的值越小，则代表算法拟合结果与真实结果越接近。 三、梯度下降 梯度下降算法沿着误差函数的反向更新θ\thetaθ的值，知道代价函数收敛到最小值。梯度下降算法更新的方法为：
其中 α表示学习率。对于线性回归的的参数，可以根据代价函数求出其参数更新公式：
四、代码实现 现在让我们开始动手实现，首先让我们回顾一下numpy和matplotlib：
import numpy as np import matplotlib.pyplot as plt #% matplotlib inline def warm_up_exercise(): """热身练习""" # ====================== 你的代码 ========================== # 在下面加入你的代码，使程序返回一个 5x5 的单位矩阵 A = np.eye(5, 5) # ========================================================= return A # 当你的实现正确时，下面会输出一个单位矩阵： print(warm_up_exercise()) 运行结果：
你需要实现绘制数据集中图像的函数，当你的实现|正确时，你应该会得到如下的图像：
def plot_data(x, y): """绘制给定数据x与y的图像""" plt.figure() # ====================== 你的代码 ========================== # 绘制x与y的图像 # 使用 matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b3d23fedcc8ce256f33dbd1597c47a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3505d79db21f60b63ece34cde602342f/" rel="bookmark">
			常用电脑快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		▌删除上网痕迹：Ctrl + Shift + Delete▌快速关闭网页：Ctrl + W快速收藏网页：Ctrl + D▌快速定位关键词：Ctrl + F▌快速找到历史记录：Ctrl + H▌快速找到下载内容：Ctrl + J▌剪贴板：Win + V▌调出屏幕草图（Whiteboard）：Win + W
▌快速预览文件内容：Alt + P▌快速创建文件夹：Ctrl + Shift + N▌调出虚拟键盘：Win + R▌保留当前页面：Win + Home方式一：Win + M▌分屏：Win + 方向键▌快速锁屏：Win + L
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a180ac433894e0125f5a5b897bf6fd/" rel="bookmark">
			tensorboard:vcc-PC拒绝了我们的连接请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个问题，可以指定host
tensorboard指令后可以可以指定的参数，如下图
按照图中–host的提示指定参数值为localhost
tensorboard --logdir=events文件存放文件夹 --host localhost 这样就可以成功打开tensorboard了，localhost指的是本地主机。
tips:打开之前最好先定位到当前events文件存放目录的上一级目录，比如
CNNTrain --logs ----events.out.tfevents.1052270081.VCC-PC 打开cmd时可以先定位到CNNTrain，然后通过
tensorboard --logdir=events logs --host localhost 打开tensorboard
这样就可以比较轻松的使用tensorboard了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec1aae9b0ff3a13d9f1e7481cd2db4b/" rel="bookmark">
			怎样用Excel搜索表格内的内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具/材料：excel表格
1.首先在桌面上找到excel表格，并点击打开此表格。
2.进入表格之后，点击表格左上角箭头指向的位置，将整个表格选中。
3.然后ctrl+f快捷键，将查找和替换功能窗口唤出。
4.接着在查找内容的方框里输入需要查找的文字，点击全部查找后就可以看到下面显示此内容在哪个位置了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8318a7b35ad4569aadcda1355fa8d92b/" rel="bookmark">
			OpenStack组件之Nova
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Nova简介 Nova是什么？ OpenStack中提供计算资源服务的项目
Nova负责什么？ 虚拟机生命周期管理
其他计算资源生命周期管理
负责发现各个物理主机上的物理资源数量（物理CPU、内存、本地存储空间、PCI设备等），并根据配置值将其换为逻辑资源数量（如CPU超配）
负责将各个物理节点上的逻辑资源数量上报至数据库，并定期刷新数据库记录，以使记录能够反映当前的实际资源状态。
Nova不负责什么？ 承载虚拟机的物理主机自身的管理
全面的系统状态监控
Nova是OpenStack历史上最核心的项目 历史最长：OpenStack首批两个项目之一
功能最复杂，代码量最大
大部分集成项目和Nova之间都存在配合关系
贡献者在社区中的影响力最大
2.nova架构 模块
功能
一般部署位置
nova-api
接受rest消息
控制节点
nova-scheduler
选择合适的主机
控制节点
nova-conductor
数据库操作和复杂流程控制
控制节点
nova-compute
虚拟机生命周期管理和资源管理
计算节点
nova-novncproxy
novnc访问虚拟机代理
控制节点
nova-consoleauth
novnc访问虚拟机鉴权
控制节点
Nova内部服务使用REST调用，Nova和其他OpenStack服务交互时，使用消息队列。
nova-api：接收和响应客户的API调用。 除了提供 OpenStack 自己的API，nova-api 还支持 Amazon EC2 API。 也就是说，如果客户以前使用 Amazon EC2，并且用 EC2 的 API 开发了些工具来管理虚机，那么如果现在要换成 OpenStack，这些工具可以无缝迁移到 OpenStack，因为 nova-api 兼容 EC2 API，无需做任何修改。负责接收来自客户端的http请求，比如创建一个虚拟机;虚拟机生命周期管理的入口Nova-scheduler:虚拟及调度服务，负责决定在那个计算节点上运行虚拟机。这里的调度策略是先过滤不合适的节点，然后再进行打分操作，选择出来最合适的节点通知该节点上的nova-computer来进行创建虚拟机、迁移等操作。 nova-compute：管理虚拟机的核心服务，通过调用Hypervisor API实现虚拟机生命周期管理。以一个守护进程的方式运行在计算节点上，专门负责创建虚拟机。 虚拟机各生命周期操作的真正执行者(会调用对应的hypervisor的driver）。
底层对接不同虚拟化的平台(KVM/VMware/XEN/Ironic等）
内置周期性任务，完成资源刷新，虚拟机状态同步等功能。
资源管理模块(resource_tracker)配合插件机制，完成资源的统计。
Hypervisor：计算节点上跑的虚拟化管理程序，虚拟机管理最底层的程序。不同虚拟化技术提供自己的 Hypervisor。 常用的 Hypervisor 有 KVM，Xen， VMWare 等nova-conductor：介于nova-database和nova-compute之间，其目的在于消除nova-compute直接访问云数据库。保证了数据库的安全性。数据库操作，解耦其他组件(Nova- Compute)数据库访问；Nova复杂流程控制，如创建，冷迁移，热迁移，虚拟机规格调整，虚拟机重建；其他组件的依赖，如nova- compute需要nova- conductor启动成功后オ能启动；其他组件的心跳定时写入。 引入nova-conductor的好处：之前每个nova-compute都是直接访问数据库的。如果由于某种原因，某个计算节点被攻陷了，那攻击者就可以获取访问数据库的全部权限，肆意操作数据库，更加安全，升级更加方便 nova-console：用户可以通过多种方式访问虚机的控制台： nova-novncproxy，基于 Web 浏览器的 VNC 访问 nova-spice html5 proxy，基于 HTML5 浏览器的 SPICE 访问 nova-xvpnvncproxynova-consoleauth：负责对访问虚拟机控制台请求提供Token认证 nova-cert：提供x509证书支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8318a7b35ad4569aadcda1355fa8d92b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617c52274ccc664260024244cb5908c4/" rel="bookmark">
			c&#43;&#43; auto类型用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、用途 auto是c++程序设计语言的关键字。用于两种情况
（1）声明变量时根据初始化表达式自动推断该变量的类型
（2）声明函数时函数返回值的占位符
二、简要理解 auto可以在声明变量时根据变量初始值的类型自动为此变量选择匹配的类型。
举例：对于值x=1；既可以声明： int x=1 或 long x=1，也可以直接声明 auto x=1
三、用法 根据初始化表达式自动推断被声明的变量的类型，如：
auto f = 3.14; //double auto s("hello"); //const char* auto z = new auto(9); //int * auto x1 = 5, x2 = 5.0, x3 = 'r'; //错误，必须是初始化为同一类型 但是，这么简单的变量声明类型，不建议用auto关键字，而是应更清晰地直接写出其类型。
auto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读。如：
std::vector&lt;int&gt; vect; for(auto it = vect.begin(); it != vect.end(); ++it) { //it的类型是std::vector&lt;int&gt;::iterator std::cin &gt;&gt; *it; } 或者保存lambda表达式类型的变量声明：
auto ptr = [](double x){return x*x;};//类型为std::function&lt;double(double)&gt;函数对象 四、优势 （1）拥有初始化表达式的复杂类型变量声明时简化代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/617c52274ccc664260024244cb5908c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08234a0ecdcaf46b4c8237f8be332ae/" rel="bookmark">
			维护华为服务器的好工具KVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前维护服务器，要么打开远程桌面，要么打开telnet，或者使用其他的远程工具，今天维护一台新购买的华为服务器，使用了华为官网下载的KVM，真好用！
使用网线，找到Mgmt的网口插入，在一台计算机上配置同一网段的IP地址即可登录进行维护了。这时是点对点的连接，也就是只有一台计算机可以访问。
华为服务器的初始网络设置为：
IP地址：192.168.2.100
子网掩码：255.255.255.0
网关地址：192.168.2.100
运行KVM.exe。
在出现的对话框中选择“是”即可
接下来就可以进行服务器的维护了。
真方便！ KVM功能很强大了，可以录屏、制作镜像、强制重启、断电等等，有帮助，使用很简单。
如果远程也可以访问，在CMOS里面设置IP地址为局域网的地址即可。
为了安全，最好在CMOS上修改初始的密码，用户为root，初始密码为Huawei12#$。
另外在该服务器就近的交换机上加上访问ACL，禁止无关IP访问该IP地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612ee2419d5f345728956fab81af4f47/" rel="bookmark">
			vue3写省市镇三级联动组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="xtx-city" ref="target"&gt; &lt;div class="select" @click="toggle" :class="{active:isShow}"&gt; &lt;span v-if='!fullLocation' class="placeholder"&gt;请选择配送地址&lt;/span&gt; &lt;span v-else class="value"&gt;{{fullLocation}}&lt;/span&gt; &lt;i class="iconfont icon-angle-down"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class="option" v-show='isShow'&gt; &lt;div class="loading" v-if="loading"&gt;&lt;/div&gt; &lt;template v-else&gt; &lt;span @click="changeCity(item)" class="ellipsis" v-for="item in cityList" :key="item.code"&gt;{{item.name}}&lt;/span&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref, computed, reactive } from 'vue' import { onClickOutside } from '@vueuse/core' import { getCityList } from '@/api/product.js' export default { name: 'XtxCity', props: { fullLocation: { type: String, default: '' } }, setup(props, { emit }) { const isShow = ref(false) const loading = ref(false) // 控制选择城市弹窗的显示和隐藏 const toggle = () =&gt; { isShow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612ee2419d5f345728956fab81af4f47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b65db0600f253750c01453a8dcb9c4/" rel="bookmark">
			实例化Servlet类异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近初学Servlet，在编写第一个Servlet程序时，遇到了一个令我很苦恼的问题。java代码和XML配置文件中的内容都没有问题，也在Edit Configurations中修改了server的name和Deployment的Application content的内容，都修改成了工程名，但是运行此工程时，却发现一直报错，实例化Servlet类[com.atguigu.test.servlet1]异常。
后来发现，是因为IDEA中配置的Tomcat服务器版本过于高，和Servlet的版本不匹配。于是将Tomcat10换成了Tomcat8，问题得到解决，不再报错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50266ed8a71aa5cbcfadeb78d8e5fcab/" rel="bookmark">
			链表实现输入两个整数数组，A B，将B与A合并，并且排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现两个整数数组进行合并，并且对合并的数组进行排序（通过链表实现）； 代码如下：
/***************************************************************** 实现一个函数，功能为输入两个整数数组，A,B 实现A=A+B,也就是将A与B进行合并 并且对数组A里面的数字大小进行排序。 ******************************************************************/ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //创建结构体 struct ptr { int data; struct ptr* next; }; //创建链表头 struct ptr* creat_headlist() { struct ptr*Head_list=(struct ptr*)malloc(sizeof(struct ptr)); Head_list-&gt;next=NULL; return Head_list; } //创建结点 struct ptr* creat_conection_polt(int data) { struct ptr*c_list=(struct ptr*)malloc(sizeof(struct ptr)); c_list-&gt;data=data; c_list-&gt;next=NULL; return c_list; } //插入结点 void in_set(struct ptr * Head_list,int data) { struct ptr*set_list=creat_conection_polt(data); set_list-&gt;next=Head_list-&gt;next; Head_list-&gt;next=set_list; } //找到此链表的最后一个结点 struct ptr* last_list(struct ptr*Head_list) { struct ptr*next_list_last=(struct ptr*)malloc(sizeof(struct ptr)); while(1) { if(Head_list-&gt;next==NULL) { return Head_list; break; } else { next_list_last=Head_list-&gt;next; Head_list=next_list_last; } } } //对此链表的数据进行从小到大的排序利用冒泡排序法进行操作 void pai_xu(struct ptr* Head_list) { struct ptr*next_ptri=(struct ptr*)malloc(sizeof(struct ptr)); struct ptr*next_ptrj=(struct ptr*)malloc(sizeof(struct ptr)); for(next_ptri=Head_list-&gt;next;next_ptri!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50266ed8a71aa5cbcfadeb78d8e5fcab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74a250e1b3cc6db15767a62724dfc9c/" rel="bookmark">
			关于pycharm中Debugger失败的问题，报错：Connection to Python debugger failed Interrupted function call: accept fa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题的主要解决方法有两种，你如果遇到这个问题，可以依次尝试下面两个步骤。如果问题没有解决，再加油找找，然后分享出来，我来更新一下这篇文章；如果解决了，记得点个赞再走哦~
**步骤一：**这也是网上流传的较多的一种方法，按照下边图片顺序进行操作即可啦。
①
②
步骤二：如果上边的方法不行，你可以翻看一下你的python文件名里边有没有看起来比较敏感的、像关键词的，比如code、thread之类的，如果有，把它改成别的名字或者删掉就可以啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a64f60c0ee9d8e1fae0a8dacb447ad/" rel="bookmark">
			CTFshow刷题日记-WEB-反序列化篇(上，254-263)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非反序列化 web254-简单审计 这个题是搞笑的么🤣
按着源码顺序走一遍
...... $username=$_GET['username']; $password=$_GET['password']; if(isset($username) &amp;&amp; isset($password)){ $user = new ctfShowUser(); if($user-&gt;login($username,$password)){ if($user-&gt;checkVip()){ $user-&gt;vipOneKeyGetFlag(); } }else{ echo "no vip,no flag"; } } 接受两个参数，生成对象，调用 login 函数
# login 函数 class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; ...... public function login($u,$p){ if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){ $this-&gt;isVip=true; } return $this-&gt;isVip; } ...... payload
?username=xxxxxx&amp;password=xxxxxx web259-伪造请求 flag.php
$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); array_pop($xff); $ip = array_pop($xff); if($ip!=='127.0.0.1'){ die('error'); }else{ $token = $_POST['token']; if($token=='ctfshow'){ file_put_contents('flag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a64f60c0ee9d8e1fae0a8dacb447ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb243f18ac425d493da96ccba9bf5e2/" rel="bookmark">
			【优化求解】基于粒子群算法求解多目标优化问题matlab源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【优化求解】基于粒子群算法求解多目标优化问题matlab源码 1 算法介绍 1.1 关于速度和位置 粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。
鸟被抽象为没有质量和体积的微粒(点)，并延伸到N维空间，粒子i在N维空间的位置表示为矢量Xi＝(x1，x2，…，xN)，飞行速度表示为矢量Vi＝(v1，v2，…，vN)。每个粒子都有一个由目标函数决定的适应值(fitness value)，并且知道自己到目前为止发现的最好位置(pbest)和现在的位置Xi。这个可以看作是粒子自己的飞行经验。除此之外，每个粒子还知道到目前为止整个群体中所有粒子发现的最好位置(gbest)(gbest是pbest中的最好值)，这个可以看作是粒子同伴的经验。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。
2.2 速度和位置的更新 PSO初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次的迭代中，粒子通过跟踪两个“极值”(pbest，gbest)来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。
对于公式(1)：
公式(1)的第①部分称为【记忆项】，表示上次速度大小和方向的影响；
公式(1)的第②部分称为【自身认知项】，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；
公式(1)的第③部分称为【群体认知项】，是一个从当前点指向种群最好点的矢量，反映了粒子间的协同合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。
以上面两个公式为基础，再来看一个公式：
公式(2)和 公式(3)被视为标准PSO算法。
1.3 标准PSO算法的流程 1）初始化一群微粒(群体规模为N)，包括随机位置和速度；
2）评价每个微粒的适应度；
3）对每个微粒，将其适应值与其经过的最好位置pbest作比较，如果较好，则将其作为当前的最好位置pbest；
4）对每个微粒，将其适应值与其经过的最好位置gbest作比较，如果较好，则将其作为当前的最好位置gbest；
5）根据公式(2)、(3)调整微粒速度和位置；
6）未达到结束条件则转第2）步。
迭代终止条件根据具体问题一般选为最大迭代次数Gk或(和)微粒群迄今为止搜索到的最优位置满足预定最小适应阈值。
## 4.2 PSO流程图解
2 部分代码 clc; clear; close all; ​ %% 问题定义，这里可以删除 ​ TestProblem=1; % Set to 1, 2, or 3 ​ switch TestProblem case 1 CostFunction=@(x) MyCost1(x); nVar=50; VarMin=0; VarMax=1; case 2 CostFunction=@(x) MyCost2(x); nVar=3; VarMin=-5; VarMax=5; case 3 CostFunction=@(x) MyCost3(x); nVar=2; VarMin=0; VarMax=1; end ​ VarSize=[1 nVar]; ​ VelMax=(VarMax-VarMin)/10; ​ %% MOPSO 设置 nPop=500; % Population Size ​ nRep=100; % Repository Size ​ MaxIt=500; % Maximum Number of Iterations ​ phi1=2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eb243f18ac425d493da96ccba9bf5e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5294df24a6e0f8932237837b74d333b/" rel="bookmark">
			linux图形栈(0)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上图看关系 （这个图一定要熟记于心）
从上图可以看出Linux图形栈主要分为3d和显示
部分名词解释
mesa是一个OpenGL的开源实现，前期是软件实现，后期加入硬件加速
libGL是openGL接口的实现，3D application（如这里的3D-game engine）可以直接调用libGL进行3D渲染。
libDRM和kernel DRM是DRI（Direct Render Infrastructure）的kernel实现，及其library。X-server或者Mesa 3D，可以通过DRI的接口，直接访问底层的图形设备（如GPU等）libdrm是drm下沟通驱动和用户层的库。
kms是一个用于控制显示设备属性的内核driver，如显示分辨率等。直接由X-server控制。
显示主要是就是X11和Wayland，其中，Wayland是近几年才发展起来的，首先介绍X11，它指提供GUI环境的基本框架（定义protocol, 基本的图形·单元（点、线、面等等）、鼠标键盘等输入设备交互等等）直接看图
从图中可以看出，X主要是 X server和X clients组成，通过X protocol通信，x protocol是基于网络的，所以可以跨平台，
X设计之初就规定只提供GUI环境的基本框架，如定义 protocol、设备上绘制基本的图形单元（点 线 面等等）、和鼠标键盘等输入设备交互、等等。它并没有实现UI设计所需的button、menu、window title-bar styles等元素，而是由第三方的应用程序提供。即”提供机制，而非策略“。对用户接口不作要求，比如它提供了生成窗口（window）的方法，却对窗口呈现方式不作任何要求。
拿一个简单的应用场景举例。点击按钮引发按钮更新动作。
内核捕获鼠标点击事件并发送给 X server。X Server 会计算该把这一事件发送给哪个窗口（事实上，窗口位置是由 Compositor (合成器）控制的，X Server 并不能够正确的计算 Compositor 做过特效变化之后的按钮的正确位置）。应用程序对此事件进行处理（将引发按钮更新动作）。但是，在此之前它得向X Server 发送绘制请求。X Server 接收到这条绘制请求，然后把它发给视频驱动来渲染。X 还计算了更新区域，并且这条“垃圾信息”发送给了 Compositor。这时，Compositor 知道它必须要重新合成屏幕上的一块区域。当然，这还是要向X Server发送绘制请求的。开始绘制。但是 X Server 还会去做一些不必要的本职工作（窗口重叠计算、窗口剪裁计算等）。 但是在上述情况下，一个应用不应该直接访问硬件，但对一些游戏等图形应用需要应用直接访问硬件就不行了，这时候就出现了DRI。
首先必须明确DRI是一个软件架构，包含一系列软件模块，诸如DRM(后面会详细提到）和KMS，是用来协调linux kernel，X windows系统，3D图形硬件以及OpenGL渲染引擎之间的工作。其目的是使应用程序和显示硬件之间传输更高效，从而更高效。其参考下图
其显示流程如下：
1）Application（如3D game）根据用户动作，需要重绘界面，此时它会通过OpenGL|ES、EGL等接口，将一系列的绘图请求，提交给GPU。
a）OpenGL|ES、EGL的实现，可以有多种形式，这里以Mesa 3D为例，所有的3D rendering请求，都会经过该软件库，它会根据实际情况，通过硬件或者软件的方式，响应Application的rendering请求。
b）当系统存在基于DRI的硬件rendering机制时，Mesa 3D会通过libGL-meas-DRI，调用DRI提供的rendering功能。
c）libGL-meas-DRI会调用libdrm，libdrm会通过ioctl调用kernel态的DRI驱动，这里称作DRM（Direct Rendering Module）。
d）kernel的DRM模块，最终通过GPU完成rendering动作
2）GPU绘制完成后，将rendering的结果返回给Application。
rendering的结果是以image buffer的形式返回给应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5294df24a6e0f8932237837b74d333b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e7be82182d3c69fa373e327dfca056/" rel="bookmark">
			TensorRT - 使用trtexec工具转换模型、运行模型、测试网络性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 转换模型1.1 Caffe模型转换为TensorRT模型1.2 ONNX模型转换为TensorRT模型1.3 UFF模型转换为TensorRT模型 2 运行ONNX模型3 网络性能测试 1 转换模型 1.1 Caffe模型转换为TensorRT模型 将Caffe模型转换为TensorRT模型，启动所有精度以达到最佳性能 trtexec --deploy=mnist.prototex --model=mnist.caffe --saveEngine=mnist.trt --best 将Caffe模型转换为TensorRT模型，启动所有精度以达到最佳性能，并跳过推理性能测试 trtexec --deploy=mnist.prototex --model=mnist.caffe --saveEngine=mnist.trt --best --buildOnly 1.2 ONNX模型转换为TensorRT模型 将ONNX模型转换为静态batchsize的TensorRT模型，启动所有精度以达到最佳性能，工作区大小设置为1024M trtexec --onnx=mnist.onnx --explicitBatch --saveEngine=mnist.trt --workspace=1024 --best 将ONNX模型转换为动态batchsize的TensorRT模型，启动所有精度以达到最佳性能，工作区大小设置为1024M trtexec --onnx=mnist.onnx --minShapes=input:&lt;shape_of_min_batch&gt; --optShapes=input:&lt;shape_of_opt_batch&gt; --maxShapes=input:&lt;shape_of_max_batch&gt; --saveEngine=mnist.trt --best --workspace=1024 --best –minShapes，–optShapes ，–maxShapes必须全部设置，设置的形式为：batchsize x 通道数 x 输入尺寸x x 输入尺寸y
例如：
--minShapes=input:1x3x416x416 --optShapes=input:8x3x416x416 --maxShapes=input:8x3x416x416 1.3 UFF模型转换为TensorRT模型 待补充
2 运行ONNX模型 在具有静态输入形状的全维模式下运行 ONNX 模型 trtexec --onnx=model.onnx 使用给定的输入形状在全维模式下运行 ONNX 模型 trtexec --onnx=model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e7be82182d3c69fa373e327dfca056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862863b82901a287662460e73846290e/" rel="bookmark">
			u盘格式化后数据能恢复吗，此处有妙招！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时用电脑工作的时候，经常会用到U盘，U盘是很方便的，资料可以随身携带。但是有时候操作失误U盘一不小心给格式化了，那么，U盘格式化后数据能恢复吗？U盘的数据一般是比较重要的，所以就得想方设法来进行恢复，据知网上有不少恢复资料的方法，但多数其实都是误导人的东西。
发现U盘格式化了，数据是可以恢复的，此处的妙招便是下载数据蛙数据恢复专家这款软件来恢复。
第一步：打开下载好的数据蛙数据恢复专家，U盘插入电脑。
第二步：根据自己的需求，在数据蛙数据恢复专家界面选择要恢复的U盘，接着勾选想要的恢复文件类型，确定之后点“扫描”。
备注：软件支持图片、文件、视频等文件的扫描与恢复。
第三步：扫描后，选中需要恢复的所有文件，如果只想恢复个别文件，可以使预览查看的功能，确定想恢复哪份文后接着点击“恢复”即可。
简单的三个步骤，就能把U盘格式化后的数据全部恢复完成，是不是觉得数据蛙数据恢复专家很好用，它是一款全方位数据恢复专家，可以从意外删除、格式化、重装系统、病毒等错误操作中进行快速安全的恢复你所需要的任何数据哦！而且该软件恢复的程序是以只读的方式进行访问您磁盘的数据，所以它不会对数据造成二次破坏。
好了，关于U盘格式化后数据能恢复吗的问题，今天就分享到这里了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e621e81f8c22408e30860d07f35474e3/" rel="bookmark">
			win11开机闪屏解决教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分用户在更新win11系统后，就出现了开机闪屏的问题，使用起来非常地痛苦，不知道怎么解决。其实这是因为最新的win11更新有bug，我们只需要删除这个更新就可以了，下面就一起来操作试试吧。
win11开机闪屏怎么解决：1、首先我们打开任务管理器，点击“文件”，选择“运行新任务”，如图所示。
2、勾选“以系统管理权限创建此任务”，输入“ms-settings:wheel”，回车确定。
3、进入设置之后，选择“Windows更新”进入。
4、接着点击其中的“更新历史记录”，如图所示。
5、进入历史记录之后，再点击“卸载更新”
6、在卸载更新中，找到KB500430更新，右键选中它点击“卸载”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c7089b1bb340d2d1095bdda45d992f/" rel="bookmark">
			总结一下利用pandas进行条件筛选的几个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建一个表：
df = pd.DataFrame({'A':[100, 100, 200, 300, 400], 'B':['a', 'a', 'c', 'd', 'e'], 'C':[3, 2, 1, 5, 4]}) 生成出来的表如下所示：
1）找出df中A列值为100的所有数据
df[df.A==100] 这里也可以是小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=）、不等于（!=）等情况。
2） 找出df中A列值为100、200、300的所有数据
num = [100, 200, 300] df[df.A.isin(num)] 3） 找出df中A列值为100且B列值为‘a’的所有数据
df[(df.A==200)&amp;(df.B=='c')] 4）找出df中A列值为100或B列值为‘b’的所有数据
df[(df.A==100)|(df.B=='b')] 这里需要注意的是，多条件筛选的时候，必须加括号'()'。 5) 需要删除B列的重复行，同时保留重复行中C列最大值所在的行
df.sort_values("C", ascending=False).drop_duplicates("B", keep='first').reset_index(drop=True) 可以看到，B列数据只有一个‘a’数据了，这句代码的意思是先对C列进行降序排序，然后删除B列重复的数据，keep参数是只保留第一个，因为是降序排序，第一个B列的C列数据相对于其他重复的C列数据是最大的（有点绕口） 参考：
利用pandas进行条件筛选和组合筛选 - beyondChan - 博客园
Python Pandas 删除某列重复值，同时根据另一列数值选取保留行_liangbilin的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d6d4498d6085ae85242998e7cf7d68/" rel="bookmark">
			vue3.0安装sass（scss）以及报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要记录了笔者安装sass的过程
1.安装ruby 首先在官网中下载
https://rubyinstaller.org/downloads/
下载之后进行安装
在安装过程中，要记得勾选添加环境变量的选项，其他的就是一直next就可以了
安装完成之后可以在终端输入ruby -v 查看是否安装成功
2.安装sass（scss） 之后cd到项目的目录下
进行sass的安装
npm install sass-loader@7.3.1 --save-dev
npm install node-sass --save-dev
npm install style-loader --save-dev
上面指定版本号的原因是为了防止版本号过高出现报错
3.解决安装完成还是无法使用的问题 安装之后重新运行项目还是报错
解决方法：
在webpack.config.js文件中写入以下代码：
module.export = { module: { rules: [ { test: /\.scss$/, loaders: ['style', 'css', 'sass'] } ] } } 因为是使用vue-cli创建的vue3.0项目，在目录中并没有webpack.config.js文件，因此
在根目录下，创建webpack.config.js
再在其中写入
如图：
之后重新运行项目，问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f81da986bfd8397c936e76186884110/" rel="bookmark">
			Java内置工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java内置工具类及常用类 一、java.util.Objects方法compare(T a, T b, Comparator&lt;? super T&gt; c)equals(Object a, Object b)isNull(Object obj)nonNull(Object obj) 二、java.lang.Math方法abs(double a)floor(double a)ceil(double a)round(double a)max(double a, double b)min(double a, double b)pow(double a, double b)sqrt(double a)cbrt(double a)random() 三、java.util.Arrays方法asList(T... a)binarySearch(int[] a, intkey)copyOf(int[] original, int newLength)copyOfRange(int[] original, int from, int to)equals(int[] a, int[] a2)fill(int[] a, int val)fill(int[] a, int fromIndex, int toIndex, int val)sort(int[] a)toString(int[] a) 四、java.lang.System方法arraycopy(Object src, int srcPos, Object dest, int destPos, int length)currentTimeMillis() 九、java.util.Collections方法addAll(Collection&lt;? super T&gt; c, T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f81da986bfd8397c936e76186884110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77f3ad96a03c338be91e8c0fa2ead859/" rel="bookmark">
			springboot学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot学习笔记 spring基础 Spring概述 Spring的简史
xml配置注解配置java配置 Spring概述
Spring的模块
核心容器CoreContainer
Spring-CoreSpring-BeansSpring-ContextSpring-Context-SupportSpring-Expression AOP
Spring-AOPSpring-Aspects Messaging
Spring-Messaging WEB
Spring-WebSpring-WebmvcSpring-WebSocketSpring-Webmvc-Portlet 数据访问/集成(DataAccess/Intefration)
Spring-JDBCSpring-TXSpring-ORMSpring-OXMSpring-JMS Spring的生态
Spring BootSpring XDSpring CloudSpring DataSpring IntegrationSpring BatchSpring SecuritySpring HATEOASSpring SocialSpring AMQPSpring MobileSpring for AndroidSpring Web FlowSpring Web ServicesSpring LDAPSpring Session Spring项目快速搭建 Maven简介
Maven安装
Maven的pom.xml
dependenciesdependency变量定义编译插件 Spring项目的搭建
Spring Tool Suite
https://spring.io/tools/sts/all IntelliJ IDEA
NetBeans
https://netbeans.org/downloads/ Spring基础配置 1.使用POJO进行轻量级和最小侵入式开发
2.通过依赖注入和基于接口编程实现松耦合
3.通过AOP和默认习惯进行声明式编程
4.使用AOP和模版(template)减少模式化代码
Spring所有功能的设计和实现都是基于此四大原则
依赖注入
声明Bean的注解
@Component组件,没有明确的角色@Service在业务逻辑层(service层)@Repository在数据访问层(dao层)@Controller在展现层(MVC→SpringMVC) 注入Bean的注解
@Autowired:Spring提供的注解@Inject:JSR-330提供的注解@Resource:JSR-250提供的注解 Java配置
@Configuration声明当前类是一个配置类@Bean注解在方法上,声明当前方法的返回值为一个Bean AOP
面向切面编程,相对于OOP面向对象编程
Spring的AOP的存在目的是为了解耦.
AOP可以让一组类共享相同的行为.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77f3ad96a03c338be91e8c0fa2ead859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e562a9f6329a0ae99b20ce238712fdd1/" rel="bookmark">
			基于MongoDb的事件订阅实现hook监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 基于MongoDb的事件订阅实现hook监听(insert,update,remove,find等事件开始，事件成功等)
详情请参考：基于MongoDb的事件订阅实现hook监听http://config.net.cn/datamanage/databaseapply/4bb772c5-99f6-47e8-a356-70851f144e0c-p1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1417b48e48ce1710e0d4208c4f6d1cbc/" rel="bookmark">
			镜头的MTF曲线分析和原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、成像的清晰度、分辨率和锐度 要理解MTF曲线，需要先搞明白这几个词：成像的清晰度，锐度，对比度，和分辨率。摄影里，锐度是指acutance，不是sharpness，尽管两个词翻译成英文都可以叫做锐度。Acute是锋利的意思，比如形容刀口锋利。acutance是acute的一个名词。在摄影上，acutance特指黑白色调的边界的锋利或锐利程度，即黑白边界处的对比度。高acutance照片的黑白边界非常清晰。
因此，锐度（acutance）描述边界处影像信息过渡的快慢；高锐度导致信息的迅速过渡从而使得边界清晰可见。相机和镜头的分辨率（resolution）描述的是对空间细节分辨的能力。如果能把相邻非常近的线条分开，我们就说这个相机或镜头的分辨率高。
对比度（contrast）是和acutance相联系的。显然，高对比度对应高acutance，低对比度对应低acutance。对比度和acutance可以互换，我们这里不区别其含义，尽管对比度有更广泛的含义，比如照片的整体对比度。sharpness是resolution和acutance的结合。如果一幅图像即有高的分辨率（resolution）和高的边缘锐度（acutance），那么我们说这幅图像具有高的sharpness。分辨率和边缘对比度任何一个不够高，这幅图画的sharpness都不够。所以，摄影里的sharpness指照片的整体清晰度。考虑到这些，摄影里的sharpness可能翻译成“清晰度”更合适，而“锐度”的含义留给acutance。下边就这样用：清晰度＝sharpness，锐度＝acutance，分辨率＝resolution，对比度＝contrast。（读国外的镜头测评文章，sharp和sharpness是常见到的词汇，比如说某个镜头very sharp。这个词的含义是确定的，指该镜头的解像力非常高，成像清晰：分辨率高，而且对比度复制准确；这和我们常说的某个镜头成像很锐是不一样的。我们说尼康镜头成像锐度高，是指色调边界的对比度高，清晰；比如树叶的边缘非常清晰。）
记住，清晰度＝对比度+分辨率；或者，清晰度＝锐度+分辨率。高的分辨率只能通过恰当使用好的仪器（相机和镜头）实现，后期无法获得。锐度则可以通过后期来增强。还有，不同的镜头厂家生产镜头的侧重点也不一样，比如蔡司和佳能重视分辨率，莱卡和尼康则重视锐度。
2、镜头的MTF曲线 镜头的MTF曲线（MTF chart）是对镜头的解像力的一个定量描述，确切地说是对镜头成像的清晰程度（包含分辨率和锐度两个因素）的一个定量描述。MTF的数学含义是调制传递函数（Modulation Transfer Function），这是镜头设计工程师必须考虑的一个镜头特性函数。
所谓镜头的解像力，就是镜头如实地再现被摄物体质感（texture）的能力，是镜头成像质量的一个重要指标。用来测试镜头解像能力的被拍对象通常是如图所示的清晰黑白条纹：
这个黑白条纹包含了描述影像清晰度的两个基本要素：锐度，即黑白对比度，这里黑条纹和白条纹有清晰的边界；分辨率，即单位长度包含的黑白条纹数目，用“空间频率”（简称频率）来定量描述。在上边的黑白条纹图案里，空间频率是变化的，从左往右，黑白条纹宽度逐渐变窄，间隔逐渐变小；空间频率逐渐升高。左边是低频，右边是高频。
如果经过镜头成像之后，影像是跟原物一模一样的黑白明晰条纹（包括分辨率和锐度），这个镜头就有完美的解像力。然而，这样完美的镜头是不存在的，一般的镜头成像效果是这样的：
和原物相比，成像有两个损失：（1）锐度降低了，黑白边界变得模糊，这在一定程度上是由光波衍射造成的；（2）太密集的黑白条纹变得不可分辨，这是由于密集条纹锐度降低导致的结果，所以也跟衍射有关。锐度或对比度的丢失最终导致镜头的有限分辨率。
黑白条纹的频率一般用单位长度内的成对的黑白条纹数目（LP，line pairs）来描述，LP/mm。注意，这是把条纹团映射到胶片和数码传感器上的频率，尺寸比原物小很多，所以单位长度是1毫米。因为数码相机的影像传感器大小不一样，同样尺寸的黑白条纹图案映射到不同大小的传感器上获得的频率是不一样的。
完美的镜头，也受光波衍射现象的限制。太阳下的影子的边缘不是完全清晰，总是有一定的模糊。这是因为光是一种电磁波，电磁波有衍射现象，经过物体的边缘会偏离直线传播的方向。镜头的口径有一定大小，光线经过镜头光圈的边缘也会发生衍射，使得黑白的边界变得模糊。黑白条纹的频率越高，衍射的影响越大，最终导致条纹成像的不可分辨。
MTF值代表的是在一定的条纹空间频率下对比度的复制率，这就是MTF的定义。完美镜头（即成像只受光波衍射限制的镜头）的MTF曲线如下图：
在低频端，镜头的MTF值接近于1（保持完美的对比度）。频率越低，解像越容易，边界的模糊带来的影响越小。随着频率增加，MTF值逐渐降低，因为衍射现象的影响开始变得重要。在高频端，衍射的影响强烈到影像无法解析的程度，所以MFT值趋近于0（黑白条纹无法分辨，分辨率变成0）。这是物理上完美的镜头的MTF曲线。
质量非常高的镜头的MTF曲线和理论的完美镜头的曲线非常接近（图中紫线）：
低质量镜头的MTF曲线则和理论的完美MTF曲线相差较远（图中绿线）：
下图给出了MTF＝100%，50%，10%，5%，和2%对应的黑白条纹成像的视觉印象。这里黑白条纹原物的黑白亮度不是上边“阶梯函数”形式的（即黑白边界是突变的），而是频率逐渐变化的“正弦函数”形式，因此黑白边界是逐渐过渡的。
MTF＝50%对应的影像黑白对比度被中等程度地弱化了；MTF＝10%对应的影像对比度则被严重地弱化了。MTF＝2%对应的图案这里还可以略微分辨是因为采用了无噪点的中性灰背景并且电脑屏幕的对比度比较高；
在其它不利的视觉条件下很可能就无法分辨了。
MTF＝5%或2%对应的分辨率是很主观的一个概念，不同的人或同一个人在不同时间看同一个成像会得出不同的结论，所以某个MTF阈值对应的最高分辨率不适合用来描述镜头的解像力。MTF＝50%＝0.5（MTF-50）所对应的空间分辨率和影像的视觉清晰度有很好的关系，因为这个MTF值对应的对比度降低了一半。所以，有时候人们用MTF-50对应的黑白条纹空间频率来表述镜头的解像力。MTF-50对应50LP/mm（每毫米长度包含50对黑白条纹）频率的高端镜头，其成像要比MTF-50对应20LP/mm的低端镜头的成像清晰得多（假设使用同样的相机，同样的光圈，同样的焦距）。
图A样子的MTF曲线（横轴是频率，纵轴是MTF值）并不是我们通常见到的MTF曲线。图B样子的MTF曲线有时会见到。实际上，www.photozone.de网站上的镜头测评中MTF图都是这种图，横轴是镜头光圈，纵轴是MTF-50对应的频率；只不过那里空间频率的单位是lw/ph（line width per picture height）。（因为数码相机影像传感器的尺寸可以和35mm胶片尺寸不同，lw/ph更适合表达数码影像传感器上的频率。lp/mm转换lw/ph的方法是先乘以2，再乘以传感器高度的毫米数。比如对于24×36mm的全画幅传感器，30lp/mm=30×2×24lw/ph=1440lw/ph。换句话说，对于全画幅相机，1lp/mm=48lw/ph。）
然而，更常见到的MTF曲线是这样的：横轴代表距离影像传感器（数码相机）中心的径向距离（沿着传感器的对角线方向），纵轴是MTF值。图中一般给出两组MTF曲线：一组对应低频=10LP/mm，一组对应高一些的频率=30LP/mm。每组曲线又分两条，一条代表镜头对径向线条（线条方向沿着由传感器中心向外的径向）的解像力（实线）；另外一条代表镜头对切向线条（线条方向和传感器中心的同心圆相切）的解像力（虚线）。英文里边径向的用sagittal（sagitta是矢，箭的意思）表示，切向的、圆方向的用meridional（meridian是子午圈）表示。所以，这四条MTF曲线表示为：S10（对径向的、频率为10LP/mm的线条的解析度），M10（对切向的、频率为10LP/mm线条的解析度），S30（对径向的、频率为30LP/mm的线条的解析度），和M30（对切向的、频率为30LP/mm的线条的解析度）。比如下图是尼康厂方公布的Nikkor AF-S 35mm f/1.4G镜头在光圈f/1.4的MTF曲线：
和Nikkor AF-S 200mm f/2G VRII镜头在光圈f/2.0的MTF曲线：
全画幅35mm数码相机的影像传感器的对角线长是43.2mm，一半是21.6mm。所以，MTF曲线的横轴坐标一般从0到21.5mm。21.5mm（MTF曲线最右端）对应传感器的四个角。18mm对应传感器的短边位置，12mm对应长边的位置。1.5X的APS-C传感器则对应0-14.4mm部分。
全画幅（FX）35mm影像传感器尺寸（24×36mm）
FX传感器和径向（S）线条示意图
FX传感器和切向（M）线条示意图
径向线条（S）和横向线条（M）对应的的MTF曲线
3、镜头MTF曲线的解读 根据图A，低频比高频对应的MTF值要高，即对比度损失相较高频要少；理想情况下低频的MTF值趋近于1。所以，10LP/mm曲线对应的MTF值代表了对比度的复制率。这个值越接近于1（100%），镜头的对比度（即锐度，边缘锐度，acutance）复制率越高。较高频率的30LP/mm的曲线对应的MTF值反应了镜头的分辨率（resolution）。这个值越大，说明镜头的分辨率越高。
所以，镜头厂方公布的MTF图一般包含10LP/mm和30LP/mm的两组MTF曲线；一个反映的是锐度，一个反应的是分辨率。
为什么MTF曲线要画出径向和切向两组数据呢？因为镜头在这两个方向的解像力不同。在影像的中心，径向和切向的MTF值是没有分别的。离开中心，它们不再相同，在影像的边角处径向和切向的MTF值会有很大的分别。所以，这两个方向的MTF要分开来表示。在MTF图上，当同一频率的径向和切向MTF曲线开始分开的时候，成像的模糊程度在两个方向不再一样。这种现象叫做“散光”（astigmatism），如下图所示：
S-MTF＞ M-MTF，成像切向模糊严重（左边原像，右边成像）
S-MTF＜ M-MTF，成像径向模糊严重（左边原像，右边成像）
S-MTF＝ M-MTF，径向切向模糊相同（左边原像，右边成像）
从上图可见，如果径向（S）MTF高于切向（M）MTF，成像在垂直于半径方向更模糊。如果径向（S）MTF低于切向（M）MTF，成像在离开相片中心的半径方向更模糊。所以，镜头的MTF曲线实线（S）和虚线（M）越接近越好，因为它代表成像在两个方向模糊程度均衡。这和镜头的焦外成像特性（虚化，bokeh－－这个词来自日语）也有关。径向和切向的MTF曲线越接近，焦外虚化的效果越好－－光斑越接近圆形。
所以，根据镜头的MTF曲线鉴定镜头解像力的基本原则是：（1）MTF曲线越高、越接近于1越好；（2）实线和虚线越接近越好；（3）曲线越平越好。MTF曲线越平，代表镜头的径向解像力越均匀，边角的解像力好。
当然，这些标准也不是绝对的，也要看镜头的用途。比如人像镜头，解像力太高反而不是好事，因为太高的解像力使得人脸上的瑕疵毕现。这也是为什么微距镜头（有极高的解像力）不适合拍摄人像的一个重要原因。人像头，一般也不要边缘解像力太好，因为太好的边缘解像力容易分散人的注意力，也容易给人一种平面缺乏立体感的印象。
对同一个镜头，MTF曲线依赖于光圈值和焦距（如果是变焦）。所以，对比不同的镜头的MTF曲线，要在相同的光圈和焦距下对比。如果焦距确定，在最大和最小光圈的MTF值一般要比中间光圈的MTF值低（图B）。全开光圈，镜头边缘参与成像，色散会比较严重，导致MTF降低。太小的光圈，光线衍射现象严重，也会导致MTF降低。所以，一般镜头的最大光圈和最小光圈都很少用到。在购买大光圈镜头的时候，一定要注意检查最大光圈的MTF曲线，看最大光圈是否可用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e030764bb7ef2b6d9c19c8a8384adea9/" rel="bookmark">
			u盘格式化后数据能恢复吗？看看过来人怎么恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		u盘格式化后数据能恢复吗？u盘是工作中不可或缺的好帮手，首次使用时，一般需要对其格式化，以确保存储空间可以使用，平时使用的过程中，有些朋友也会对u盘格式化处理，但如果因为不恰当操作导致数据丢失，有什么方法可以恢复u盘呢？下面就一起来了解下。
我们都知道，格式化就代表我们可能失去原本存放在u盘里的所有数据，也无法像电脑文件一样从回收站中进行还原，如果在格式化之前通过计算机硬盘或者云存储对u盘数据进行过备份，处理方法也就很简单了，如果没有备份过数据，想要恢复最简单的方法是借助工具。
因为根据数据的删除和恢复原理，被格式化的数据其实并没有真正的消失，只是该位置被系统做了标记，当有新的数据进入时，才会随机覆盖在上面，这时候才会真的彻底删除，但这时候我们也是无法通过肉眼直接查看到数据的，需要借助嗨格式数据恢复大师这类工具进行扫描。
在电脑上打开嗨格式后选择“u盘/内存卡恢复”模式，进入后再点击该u盘盘符进行扫描，完成后就可以查看恢复出来的内容啦，电脑小白也能轻松应对。
以上就是u盘格式化后的相关处理方法，有需要的朋友们抓紧跟着教程试试看吧，希望以上的内容能够对你有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d770629b2710bd8cd92ee6ddb8bbc3ee/" rel="bookmark">
			Systemverilog 中`include 和 filelist区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录今天在搭建验证平台时遇到的一个问题，问题简单描述：搭建的是验证CPU core block的平台，对于core dut来说包括很多小模块，如decode、rename、dispatch、issue和各种FU等模块，针对于每个小模块写了reference_model，需要加到top中，但是由于多个人负责各个子模块的验证工作，所以直接写到top中是不方便的，需要改来改去，所以最终是通过在top中include文件的方式来进行处理。
我负责的include模块如下所示：
因为需要往RM灌入激励，但是对于core 模块的中间小模块来说，激励是中间信号，因此直接采用层次“点”的形式直接抓DUT输入信号。
但是此时编译时报如下错误：上图第90行有语法错误。
检查语法发现没有问题，那就很奇怪了，卡了半天后。在top中去掉该include文件发现神奇的事情，重新编译还报相同的错误。检查了filelist后发现加了这个check文件，那么问题几乎可以定位了，在编译时会首先编译filelist中的文件，但是对于该文件中，使用了层次“点”的形式抓取了信号，但是此时还没建立UVM树结构，因此会报错误，但是吐槽一下VCS工具，报的是语法错误，让我在那里检查半天语法。发现问题后，就解决问题，在filelist中去掉该check文件，通过+incdir+dir的方式，发现编译过了。
总结一下：
1.工具编译时会首先编译filelist里面的东西，说到filelist简单说下-f和-F的区别，-f编译时filelist的路径相对于Makefile在的路径为参考路径，-F编译时是以filelist本级路径为参考路径，所以-F比较方便。
2.include其实就相当于整体文件插入，那么就和include前面代码和后面代码有关系了，提前编译会出错的，编译遇见include文件时会去+incdir库里面寻找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df6c1068ab70bd6c44d6e92410cf711/" rel="bookmark">
			iOS基础之路之addsubview和insertSubView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 子视图是以栈的方式存放的。
每次插入或添加时[self.view.subViews count]都会增加。
addsubview时都是在栈最后面添加，即在视图的最上方。
insertSubView时是插入栈的某一位置，即插入视图层的某一位置。
即[self.view addSubView:xx.view] 等价于 [self.view insertSubView:xx.view atIndex:[self.view.subViews count]];
总之：
addSubview是一层一层往上加，新加的只能放到最上层，
insertSubView可以控制将view添加到指定的层。
————————————————
版权声明：本文为CSDN博主「十万个逗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/q1194259339/article/details/76283741
iOS中调整view层级位置的两个属性 控件的层级关系和你加入到父视图的顺序有关，也就是先addsubview至父视图的，层级越低，会被后加入的遮盖。 可以通过以下函数改变子视图的层级 将一个UIView显示在最前面： - (void)bringSubviewToFront:(UIView *)view; 将视图显示在下面： - (void)sendSubviewToBack... 例如下面的代码示例： UIView *view1 = [[UIView alloc] initWithFrame:CGRectMake(10, 50, 100, 50)]; view1.backgroundColor = [UIColor blueColor]; [self.view addSubview:view1]; UIView *view2 = [[UIView alloc] initWithFrame:CGRectMake(15, 55, 100, 50)]; view2.backgroundColor = [UIColor grayColor]; [self.view addSubview:view2]; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59628854d59cf3a0c761b6f6dfc71d03/" rel="bookmark">
			DMA零拷贝技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据的四次拷贝与四次上下文切换 很多应用程序在面临客户端请求时，可以等价为进行如下的系统调用：
File.read(file, buf, len);
Socket.send(socket, buf, len);
例如消息中间件 Kafka 就是这个应用场景，从磁盘中读取一批消息后原封不动地写入网卡（NIC，Network interface controller）进行发送。
在没有任何优化技术使用的背景下，操作系统为此会进行 4 次数据拷贝，以及 4 次上下文切换，如下图所示：
如果没有优化，读取磁盘数据，再通过网卡传输的场景性能比较差：
4 次 copy：
CPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中；
CPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中；
CPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区；
CPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中；
4 次上下文切换：
read 系统调用时：用户态切换到内核态；
read 系统调用完毕：内核态切换回用户态；
write 系统调用时：用户态切换到内核态；
write 系统调用完毕：内核态切换回用户态；
我们不免发出抱怨：
CPU 全程负责内存内的数据拷贝还可以接受，因为效率还算可以接受，但是如果要全程负责内存与磁盘、网络的数据拷贝，这将难以接受，因为磁盘、网卡的速度远小于内存，内存又远远小于 CPU；
4 次 copy 太多了，4 次上下文切换也太频繁了；
2. DMA 参与下的数据四次拷贝 DMA 技术很容易理解，本质上，DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59628854d59cf3a0c761b6f6dfc71d03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b150621a38d1d8587c8a872c98dc55f/" rel="bookmark">
			【RT-Thread&amp;ART-PI】工业拓展版-以太网(ETH)的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、添加 ETH 配置 1.1.添加 Kconfig 配置 打开 board 目录下的 Kconfig 文件，添加以太网驱动。
1.2.添加以太网驱动程序 1.3.添加 SConscript 链接脚本 打开 rt-thread\bsp\stm32\stm32h750-artpi-h750\board 目录下的 SConscript 添加以太网驱动程序 drv_eth.c。
打开 rt-thread\bsp\stm32\libraries\STM32H7xx_HAL 目录下的 SConscript 添加以太网官方库文件
1.4.在 ENV 中使能以太网 输入 menuconfig 进入菜单配置
​
选择 ETH 的复位引脚，以及以太网驱动芯片型号。
1.5.修改 drv_eth.c 定义 因为为了不影响主分支的 drv_eth.c 通用驱动程序，我们的 drv_eth.c 是单独放在了 port 文件夹下的，所以我们需要稍作修改。
二、编译下载验证 可以看到以太网已经初始化成功。
插入网线，可以已经连接上了并且可以看到网络信息。
输入 ifconfig 命令可以看到以太网网卡以及 wifi 网卡都已经挂载到了设备中，并且默认为以太网网卡。
至此，我们的以太网驱动验证成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1312d95f875545732c3421531275ee3e/" rel="bookmark">
			设置contenteditable属性的div粘贴图片问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现 需求：要一个能粘贴图片的文本框，并且图片要先上传至后端进行安全校验，拿到返回的图片地址进行输入。
思路：普通的input框无法粘贴图片，联想到编辑器原理，可以使用div标签加html5新增的contenteditable属性来实现上述需求。
然后监听粘贴事件，判断是否是图片，如果是，获取数据并上传至后端。
问题 本地测试没问题，但是测试反馈粘贴图片会显示两张照片，确定不是硬件问题后，应该就是浏览器版本问题。我的chrome是80版本的，并不支持在div框插入图片，而测试的chrome是83版本的，支持。、
怎么办呢，用vue的prevent修饰符来重写粘贴方法实现：@input.prevent="changeContent"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f22a1f4a2f3f2fb93edc7d607a6290/" rel="bookmark">
			嵌入式开发入门设计 —— 色盲检测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计目标
搭建环境
1、虚拟机与 windows 挂载共享文件目录
2、搭建虚拟测试环境（屏幕）
3、启动虚拟测试环境（屏幕） Code
1、打开（bmp）图片（open函数）
2、读取（bmp）图片（read函数）
3、显示（bmp）图片（mmap函数）
1）打开 lcd 驱动 2）内存映射mmap【*重点】
3）释放映射内存
4）关闭文件描述符
4、触摸屏
5、主函数
效果演示
结果演示
设计总结
前言 说到色盲，大家肯定会想到各种奇奇怪怪的图片，比如下图：
可能你看来看去，也看不出来图片中有啥；可能你第一眼看过去就知道图片中有个图形，但它是三角形呢？还是圆形呢？还是方形呢？「可先在评论区留下你的答案」，等会在文末附上参考答案。
既然是嵌入式，当然少不了虚拟机了。我用的是VMare Workstation 16，使用的ubuntu 也是16。至于为什么都是16呢，当然与它的各项性能有关。下面正式进入正题。
设计目标 搭建基本的开发环境实现基础的图片显示、切换模拟现实触摸屏效果计算测试结果，得出报告 搭建环境 测试测试，当然需要看到才能测试，所以先把测试环境给搭建起来。本次设计使用的屏幕是虚拟屏幕。至于为什么是虚拟屏幕，原因【￥】你懂我懂大家都懂。
1、虚拟机与 windows 挂载共享文件目录 最后可别忘了在底下点个「确定」。
2、搭建虚拟测试环境（屏幕） 进入共享文件夹：
进入触摸屏模拟器文件夹：
分别对 event_drv 和 mmap_drv 文件中的object文件 进行清除【对上次编译】和编译 ，以及安装驱动：
清楚指令：make clean
编译指令：make
驱动安装指令：sudo insmod xxx.ko
3、启动虚拟测试环境（屏幕） 就会看到如下图的lcd模拟器：
到此环境搭建、启动完成。接下来就交给程序猿了！
Code 有图才有测试，来先上图：
上图也没那么简单，不过也没有那么容易。
1、打开（bmp）图片（open函数） bmp图片是没有经过压缩的图格式bmp格式(24位图):文件信息头+图片信息头+像素点颜色码注意：bmp图片需要严格使用宽度是4的倍数(字节对齐) 如果不是4的倍数,bmp图片储存时宽度会自动补齐为4的倍数如果不处理这个问题,图片会倾斜 &lt;linux 提供了两个open函数，选其一即可&gt;
int open(const char *path, int oflag, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f22a1f4a2f3f2fb93edc7d607a6290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7939ecaee8506a90756b5bb0c91f0d82/" rel="bookmark">
			UE4 RTXGI插件安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、插件安装 1、下载插件 访问DOWNLOAD RTXGI UE4 PLUGIN
点击I Agree To the Terms of the NVIDIA RTX SDKs License Agreement然后点击下载。
2、安装插件 解压后把RTXGI文件夹放到UE_4.27\Engine\Plugins\Runtime\Nvidia文件夹下，打开UE4.27。
在插件管理器中启用NVIDIA RTX Global Illumination插件。
然后在项目设置中确保已经打开光追。
最后重启UE4.27
二、使用教程 1、流程设置 打开控制台输入 r.GlobalIllumination.ExperimentalPlugin 1
r.RTXGI.DDGI 1
最后在场景中放置 DDGIVolume Actor 并包裹住场景。
可以看到场景已经有了GI
2、RTXGI RTXGI使用动态漫反射全局光照（DDGI）算法来计算漫反射全局光照，DDGI使用光线追踪来收集辐射度和距离数据到一个规则的探针网格上。这个你已经熟悉的光照探针解决方案有些相似，但是DDGI收集辐射度和距离数据的过程是实时的，DDGI探针逐渐的收集数据，并使用一种基于静态的方式解决漏光的问题。
控制台指令
命令选项描述r.RTXGI.DDGI0,1开启或关闭RTXGIr.RTXGI.DDGI.LightingPass.Scale0.25-1.0灯光通道分辨率的缩放（取值范围已经被钳制到0.25-1.0之间）r.RTXGI.DDGI.ProbesTextureVis0,1（疑似废弃移动到了DDGIVolume设置上）开启或关闭DDGI的探针显示，在模式2下将未击中表面的光线显示为蓝色，击中表面的光线显示为绿色，光线击中背面显示为红色。r.RTXGI.MemoryUsed0,1在日志中显示RTXGI所使用的的显存状况的细节Vis DDGIProbesTexture0,1显示探针贴图这有助于诊断由于灯光或者网格体没有配置光线追踪中可见所产生的的问题。 3、项目设置 Irradiance Bits（辐射度贴图位深） 默认情况下使用一张10bit每通道的颜色纹理存储探针辐射度，但在extended radiance或者非常亮的光源的情况下10bit可能不足以表现灯光的能量。这时可以将这张贴图增加到32bit每通道，用以支持extended radiance，但同时会增加显存消耗。也可以继续使用10bit贴图，但调整DDGIvolume的Irradiance Scalar 的值，在存储辐射信息之前减少灯光的最大值，然后在读取时再缩放回来，这可以节约显存消耗，但会损失一些精度。
Distance Bits 默认情况下，使用16位浮点数格式来存储探针的距离信息用以计算遮蔽，但当距离非大时，16位可能不足以存储，可以增加到32位来提升精度。
Debug Probe Radius 增加探针可视化时用来显示探针的球的半径。
Probe Update Ray Budget 设置更新探针时可能投射的最大射线数。0指定一个无限的射线数量。一个8x8x8的体积，每个探针使用288条射线，将指定147,456条，以便每帧完全更新所有探针。每一个体积都根据他的优先级进行更新。体积的优先级越高，意味着他的的更新越频繁。这些设置使得有可能对性能成本设置一个上限，同时也控制每一个体积所收到的射线更新的比例
Probes Visualization 默认情况下，可视化的探针将显示它们的辐照度，它可以可视化其他模式，包括命中距离和平方命中距离，或者禁用所有体积的探针的可视化。在可视化距离的情况下，请检查下一个属性’Probes Depth Scale’来控制距离范围。
Probes Depth Scale 当 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7939ecaee8506a90756b5bb0c91f0d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e82fcec479a6aa4624f938aa9eebf238/" rel="bookmark">
			PCL点云库安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，库文件下载 安装PCL首先需要下载对应的安装包，主要有两个，这里推荐在GitHub上下载
PCL安装包下载
2，安装教程 安装步骤：
双击PCL-1.8.1-AllInOne-msvc2015-win64.exe文件按照提示点击下一步勾选 Add PCL to the system Path for all users在弹出安装OpenNI时将安装路径修改为D:\3D\PCL 1.8.1\3rdParty\OpenNI2点击下一步，如果弹出警告说路径太长添加失败，点击确认继续安装。点击下一步，完成配置刚刚路径添加失败的环境变量路径 安装报错问题1： 如果出现OpenNI安装失败或者D:\3D\PCL 1.8.1\3rdParty\OpenNI2文件夹下只有一个文件时
解决方法： 在控制面板中卸载安装的PCL和OpenNI，然后重复上述安装步骤。
配置环境变量的步骤：
在系统变量中添加变量：PCL_ROOT然后在系统变量path中添加安装的PCL库的路径 3，配置工程 配置工程的步骤：
使用Cmake生成工程编译是否报错 4， 测试 测试代码：
#include &lt;iostream&gt; #include &lt;pcl/common/common_headers.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/visualization/pcl_visualizer.h&gt; #include &lt;pcl/visualization/cloud_viewer.h&gt; #include &lt;pcl/console/parse.h&gt; int main(int argc, char **argv) { std::cout &lt;&lt; "Test PCL !!!" &lt;&lt; std::endl; pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr point_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;); uint8_t r(255), g(15), b(15); for (float z(-1.0); z &lt;= 1.0; z += 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e82fcec479a6aa4624f938aa9eebf238/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/167/">«</a>
	<span class="pagination__item pagination__item--current">168/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/169/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>