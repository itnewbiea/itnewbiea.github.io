<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8850ef4e8a9b7ed443f0138c6d8c88/" rel="bookmark">
			Vue Router中两种常见的路由模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希路由（Hash Mode）和历史路由（History Mode）是Vue Router中两种常见的路由模式，它们在URL的格式和对应的实现方式上有所不同。
1、 哈希路由（Hash Mode）
URL格式：在URL中通过使用 # 符号来表示路由路径。例如：https://example.com/#/user/profile.实现方式：在浏览器中，# 符号后面的内容被视为页面内的一个锚点，不会发送到服务器。Vue Router利用这一特性，在URL后面添加一个 hash（#）来管理路由。在这种模式下，路由的变化不会触发页面的刷新，所有的路由改变都在客户端进行。优点：在使用哈希模式时，不需要服务器端配置特殊的路由规则，可以方便地在静态服务器上部署和使用。缺点：URL中的哈希符号可能被视为页面的片段标识，不适合搜索引擎优化（SEO）和某些网站分析工具。 静态服务器：
静态服务器是指专门用来存储和提供静态文件（如 HTML、CSS、JavaScript、图像等）的服务器。与动态服务器相对，静态服务器主要用于向客户端（如浏览器）提供静态资源，不涉及复杂的服务器端运算和动态内容生成。
静态服务器的主要功能是接收客户端的请求，并根据请求的路径返回对应的静态文件。它通常会配置一个基本的文件路径映射关系，将特定的 URL 路径映射到特定的文件或文件夹。
当客户端请求一个静态资源时，静态服务器会根据请求的路径，在指定的文件夹中查找对应的文件或文件夹。如果找到了匹配的静态文件，服务器会将该文件发送给客户端，客户端就可以使用该文件中的内容展示或执行相应的操作。
静态服务器的特点是简单、高效、易于配置和部署。由于静态资源不会经常变化，因此静态服务器不需要针对每个请求进行动态的数据处理，直接返回对应的静态文件就可以了。这使得静态服务器能够提供快速的响应和高并发能力。
静态服务器常用于部署和托管静态网站、单页面应用（如 Vue、React、Angular 等构建的应用）和 CDN（内容分发网络）缓存等场景，为用户提供静态资源的访问。常见的静态服务器有 Nginx、Apache HTTP Server 等。
2、历史路由（History Mode）：
URL格式：URL中不包含 # 符号，采用常规的路径格式。例如：https://example.com/user/profile.实现方式：在服务器端配置，以确保所有的URL请求返回同一个HTML页面（通常是index.html），然后在客户端使用History API管理路由的变化。这意味着在历史模式下，URL的改变会触发向服务器端发送请求，服务器需要配置以正确处理这些URL并返回相应的HTML。优点：历史模式使用常规的URL路径，更符合传统网站的形式，并且对搜索引擎有更好的支持，可以进行更好的SEO优化。缺点：在使用历史模式时，需要服务器端的特殊配置支持，以确保所有路由的URL都返回同一个HTML页面。 问题一： router ===&gt; index.js 中遇到的问题 const createRouter = () =&gt; new Router({ // mode: 'hash', // require service support mode: 'history', // require service support scrollBehavior: () =&gt; ({ y: 0 }), routes: constantRoutes // routes: asyncRoutes }) 这段代码是一个函数表达式，它创建了一个Vue Router实例并返回它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8850ef4e8a9b7ed443f0138c6d8c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c7f3c31e311fd2c6eeeef5caedde005/" rel="bookmark">
			基于C&#43;&#43;的OpenCV4入门基础--图像轮廓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轮廓
图像轮廓就是图像边界，主要针对二值图像，轮廓就是一系列点的集合 轮廓是一系列相连的像素点组成的曲线，代表了物体的基本外形。轮廓常用于形状分析和物体的检测和识别。
边缘检测根据灰度的突变检测边界，但检测到的边缘通常还是零散的片段，并未构成整体。从背景中分离目标，就要将边缘像素连接构成轮廓。也就是说，轮廓是连续的，边缘不一定都连续。边缘主要是作为图像的特征使用，而轮廓主要用来分析物体的形态。
2，C++ API : findContours 和 drawContours
CV_EXPORTS_W void findContours( InputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point()); CV_EXPORTS_W void drawContours( InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness = 1, int lineType = LINE_8, InputArray hierarchy = noArray(), int maxLevel = INT_MAX, Point offset = Point() ); 参数说明：
image：原始图像，8 位单通道二值图像
mode： 轮廓检索模式
cv.RETR_EXTERNAL：只检索最外层轮廓
cv.RETR_LIST：检索所有轮廓，不建立任何层次关系
cv.RETR_CCOMP：检索所有轮廓，并将其组织为两层， 顶层是各部分的外部轮廓，次层是内层轮廓
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c7f3c31e311fd2c6eeeef5caedde005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c99795ceb7acb8ca0c824de03253d0b/" rel="bookmark">
			二、基于PCL的RANSAC拟合点云中所有直线或平面——3D点云处理系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RANSAC原理：略。
其他博客大多都是介绍拟合单条直线或平面的代码案例，本文介绍如何拟合多条直线或平面，其实是在单个拟合的基础上接着拟合，以此类推。
注意：步骤中的直线模型是每次随机在点云中取点计算的。
步骤：
1.根据所设参数（点到直线模型的最大距离）把点云分为了内点和外点，对内点进行直线拟合，得到第一次拟合的直线；
2.提取上一步的外点，按照步骤1再次进行内点和外点的划分，对内点拟合直线，得到第二次拟合的直线，并将直线点云叠加到步骤1得到的直线点云中；
3.设置循环终止的条件，重复步骤1-2，最终拟合出点云中所有直线。
多平面拟合的思想如出一辙，概不赘述。
1.RANSAC拟合点云所有直线 //RANSAC拟合多条直线 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr LineFitting(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud) { //内点点云合并 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_lines(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()); while (cloud-&gt;size() &gt; 20)//循环条件 { pcl::SampleConsensusModelLine&lt;pcl::PointXYZ&gt;::Ptr model_line(new pcl::SampleConsensusModelLine&lt;pcl::PointXYZ&gt;(cloud)); pcl::RandomSampleConsensus&lt;pcl::PointXYZ&gt; ransac(model_line); ransac.setDistanceThreshold(0.05);	//内点到模型的最大距离 ransac.setMaxIterations(100);	//最大迭代次数 ransac.computeModel();	//直线拟合 //根据索引提取内点 std::vector&lt;int&gt; inliers; ransac.getInliers(inliers); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_line(new pcl::PointCloud&lt;pcl::PointXYZ&gt;()); pcl::copyPointCloud&lt;pcl::PointXYZ&gt;(*cloud, inliers, *cloud_line); //若内点尺寸过小，不用继续拟合，跳出循环 if (cloud_line-&gt;width * cloud_line-&gt;height &lt; 20) { break; } *cloud_lines = *cloud_lines + *cloud_line; //pcl::io::savePCDFile(path1+ strcount +"_"+ str + ".pcd", *cloud_line); //提取外点 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr outliers(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointIndices::Ptr inliersPtr(new pcl::PointIndices); inliersPtr-&gt;indices = inliers; pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract; extract.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c99795ceb7acb8ca0c824de03253d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd1b9636eb489397acbcf6f9b474d60/" rel="bookmark">
			CSDN 使用体验：一路向上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用CSDN已经很多年了，这些年我真的在这一平台上收获了很多，而这些年CSDN自身也在不断进步，一步步成长，尤其是在最近的使用过程中，我感受到了CSDN前所未有的包容性、全面性，并且收获成就感。
包容性 随着互联网的不断发展，市面上的社交平台如雨后春笋般不断涌现，我们可以分享日常的平台越来越多，这本来是一件好事，但这却在无形中为我们增添了烦恼，有时候我们有一些想法观点想要表达，却又因不想让某些人看到而不便发表，CSDN就为我们提供了这样一个平台，我们可以通过博客尽情发表自己的心情与想法，如下面一些图所示，这些文字可以很好的表达博主的心情，还可以在评论区继续通过文字或标签传达感受。
可以看到博主在那一个时间段心情一定很丰富且复杂，CSDN平台便很好的承担了这一角色，这正是CSDN的包容性所在。
全面性 现在网络上的信息越来越多，是一个信息爆炸的时代，但是这些信息中存在着大量的重复信息，这为用户带来了很大的不便利，用户要获取一条有用信息，往往要在各个平台之间疲于奔命，严重降低工作效率，因此CSDN上涌现了一批辛苦的博主，将不同平台的内容汇总到CSDN上，使得用户通过一个平台便可以获取到大量有效的信息，下面一些例子展现了来自不同平台的汇总到CSDN上的内容。
公众号
博主自己也表明了自己很勤劳，博主真的是辛苦了！！！
知乎
博主还对图片中的水印贴心的做了遮挡，并且贴心的去掉了原文中一些不必要的图片，再次说一声博主辛苦了！！！
GitHub README文件
这里原文链接已经打不开了，是我用词不当，辜负了作者的努力，好在CSDN平台看到了博主的付出，给了他很多的荣誉，博主创作了这么多原创文章确实辛苦了，真的是实至名归。
知网论文
还有很多这样的资源，作者都贴心的帮我们下载好了，然后汇总到CSDN平台上，供众多用户使用。下面列出我发现的一些上传了众多资源的用户，让我们感谢他们的付出。
weixin_38656463
weixin_38675746
weixin_38593644
成就感 使用CSDN，我最近还获得了成就感，最近在和客服交流的过程中，恰巧我懂得一点Git基础，为其解答了一个问题，这让我收获了成就感，也要夸赞CSDN的客服，遇到不会的地方会虚心请教、乐于好学，这样的精神值得我们每个人学习，我相信这也是由CSDN自身优良的工作文化和氛围决定的。
总结 最近一些CSDN的使用经历真是让我刮目相看，这些年这个平台真的成长了很多，很好的体现了我上述的三个特性，希望CSDN可以越办越好，我也要提升自己，学会去掌握更多的技能，做更好的自己。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17563109ed441497aded82529b5f0e4/" rel="bookmark">
			hive一行多列合并为一行一列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SELECT named_struct('name', 'John', 'age', 30, 'city', 'New York') AS person; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070565b274db3d7cf0e3ba2b556572e9/" rel="bookmark">
			echarts legend不显示问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果legend中的data是动态加入的就会不显示
解决办法：不能单独添加data，要将legend一起整体添加
var options = { } var legend = { data:data数据 } options.legend = legend; myCharts.setOptions(options) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a9e5c5aa12ae7065a5a3d413a36e71/" rel="bookmark">
			怎样理解 Java 注解和运用注解编程？（大佬的文章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在制作上一篇文章之前，完成之后又去找了一下相关的文章，看到其中一个大佬的文章，我收获颇丰，创作就是需要这样的人，故秉承学习知识：海纳百川，厚着脸的将大佬的帖子转过来了
转载自（大家可以多去看看大佬的文章）：怎样理解 Java 注解和运用注解编程？ - bravo1988的回答 - 知乎 https://www.zhihu.com/question/47449512/answer/658228092
注解，和反射一样，是Java中最重要却最容易被人遗忘的知识点。哪怕Spring、SpringMVC、SpringBoot等框架中充满了注解，我们还是选择性地忽视它。很多人不明白它是怎么起作用的，甚至有人把它和注释混淆...工作中也只是机械性地在Controller上加@RequestMapping。是的，我们太习以为常了，以至于觉得它应该就是如此。
内容介绍：
两件小事注解的作用注解的本质反射注解信息元注解属性的数据类型及特别的属性：value和数组 两件小事 去年工作中，我遇到的两件事让注解重新走进我的视野。
第一，18年6月我去了北京，参与开发了某中国五百强企业的一个加密系统，第一次接触到了SpringBoot。当我发现一个demo项目只要简单地写个启动类并加上 @SpringBootApplication就可以直接访问Controller时，感到非常震撼。整个demo没有一个配置文件，连web.xml也没有。
由于开发进度很赶，当时没时间去研究它是如何做到的，但这件事让我意识到自己对注解还是了解得太少。
第二，来到杭州后我又参与开发了一个金融借贷系统，那阵子对接了很多第三方的风控接口：
对签名验签不了解的朋友，可以百度一下。总之，每对接一个接口，都要在开头进行数据校验。一两个接口也就算了，但每次对接风控，基本上都要写10+多个方法。每个方法开头都写一份签名验签的代码，显然太冗余了。我当时的做法是将验签代码抽取成方法，方便复用，自以为算是一种改良了，直到我看到同事用了切面...40米的大刀拦腰砍去，给每个方法都做了签名验签：
注意，实际上切面的作用是在方法前后，而不是方法内部的前后。上面这样画，仅仅为了更形象
这两件事，让我知道，是时候重新学习一下注解了。
注解的作用 格式
public @interface 注解名称{ 属性列表; } 格式有点奇怪，我们稍后再研究。
分类
大致分为三类：自定义注解、JDK内置注解、还有第三方框架提供的注解。
自定义注解就是我们自己写的注解。JDK内置注解，比如@Override检验方法重载，@Deprecated标识方法过期等。第三方框架定义的注解比如SpringMVC的@Controller等。
使用位置
实际开发中，注解常常出现在类、方法、成员变量、形参位置。当然还有其他位置，这里不提及。
作用
如果说注释是写给人看的，那么注解就是写给程序看的。它更像一个标签，贴在一个类、一个方法或者字段上。它的目的是为当前读取该注解的程序提供判断依据。比如程序只要读到加了@Test的方法，就知道该方法是待测试方法，又比如@Before注解，程序看到这个注解，就知道该方法要放在@Test方法之前执行。
级别
注解和类、接口、枚举是同一级别的。
注解的本质 @interface和interface这么相似，我猜注解的本质是一个接口。
为了验证这个猜测，我们做个实验。先按上面的格式写一个注解
属性先不写
编译后得到字节码文件
通过XJad工具反编译MyAnnotation.class
我们发现，@interface变成了interface，而且自动继承了Annotation
既然确实是个接口，那么我们自然可以在里面写方法
得到class文件后反编译
由于接口默认方法的修饰符就是public abstract，所以可以省略，直接写成：
虽说注解的本质是接口，但是仍然有很多怪异的地方，比如使用注解时，我们竟然可以给getValue赋值：
你见过给方法赋值的操作吗？（别闹了，你脑中想到的是给方法传参）。虽然这里的getValue可能不是指getValue()，底层或许是getValue()返回的一个同名变量。但不管怎么说，还是太怪异了。所以在注解里，类似于String getValue()这种，被称为“属性”。给属性赋值显然听起来好接受多了。
另外，我们还可以为属性指定默认值：
当没有赋值时，属性将使用默认值，比如上面的defaultMethod()，它的getValue就是“no description"。
基于以上差异，以后还是把注解单独归为一类，不要当成接口使用。
反射注解信息 上文已经说过，注解就像一个标签，是贴在程序代码上供另一个程序读取的。所以三者关系是：
要牢记，只要用到注解，必然有三角关系：定义注解，使用注解，读取注解。仅仅完成前两步，是没什么卵用的。就好比你写了一本武林秘籍却没人去学，那么这门武功还不如一把菜刀。
所以，接下来我们写一个程序读取注解。读取注解的思路是：
反射获取注解信息：
我们发现，Class、Method、Field对象都有个getAnnotation()，可以获取各自位置的注解信息。
但是控制台提示“空指针异常”，IDEA提示我们：Annotation 'MyAnnotation.class' is not retained for reflective。直译的话就是：注解MyAnnotation并没有为反射保留。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a9e5c5aa12ae7065a5a3d413a36e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b3f256567123ffdfe6d1b2ab01ebd8/" rel="bookmark">
			怎样理解 Java 注解和运用注解编程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java注解是Java编程语言中的一种元数据（metadata）机制，它允许我们在源代码中添加有关程序元素的额外信息，以便在编译、运行时或工具处理中使用。注解为我们提供了一种声明性的方式来描述代码的特性、性质和行为。
它可以用于很多方面，如生成文档、配置应用程序、执行运行时检查等。在本文中，我们将深入探讨Java注解的概念，并提供专业的代码示例，以展示如何运用注解进行编程。
Java注解的基本概念 Java注解是一种注释，它使用@符号作为标识，通常放在Java源代码的类、方法、字段、参数等元素前面。
注解本身是接口，可以在接口内定义注解的成员，这些成员可以包含默认值。
以下是一个简单的Java注解示例：
import java.lang.annotation.*; @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyAnnotation { String value() default "Default Value"; int number(); } 在这个示例中，@MyAnnotation是一个自定义注解，它定义了两个成员：value和number。@Retention和@Target注解用于指定注解的保留策略和目标元素类型。
使用Java注解 要使用自定义注解，只需将它添加到相应的程序元素上。以下是一个示例，演示如何在类、方法和字段上使用自定义注解：
public class MyClass { @MyAnnotation(number = 42) private int myField; @MyAnnotation(number = 7) public void myMethod() { // 方法内容 } } 在这个示例中，我们将@MyAnnotation注解分别添加到了类的字段和方法上，并为注解的number成员提供了不同的值。
自定义注解的处理 为了充分利用Java注解，我们通常需要编写注解处理器（Annotation Processor）来读取和处理注解信息。注解处理器可以在编译时或运行时执行，它可以用于自动生成代码、进行验证、配置加载等任务。
下面是一个简单的注解处理器示例，演示如何读取并处理自定义注解：
import java.lang.reflect.Method; public class MyAnnotationProcessor { public static void processAnnotations(Class&lt;?&gt; clazz) { if (clazz.isAnnotationPresent(MyAnnotation.class)) { MyAnnotation annotation = clazz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b3f256567123ffdfe6d1b2ab01ebd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcf41792fc4e4790daa20b8b39dc973/" rel="bookmark">
			with子句生成临时表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WITH temp_table(id, num, name) AS ( VALUES (1, 'zs', '合肥'), (1, 'ls', '南京'), (1, 'ww', '杭州'), (1, 'zl', '重庆'), (1, 'sq', '郑州'), (2, 'wb', '六安'), (2, 'lq', '青岛'), (3, 'dd', '三亚'), (3, 'si', '常州'), (3, 'sh', '武汉') ) SELECT * FROM temp_table; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7217d0ce1d3660b4fbea7c687ba586e1/" rel="bookmark">
			Java 数据结构与算法-队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列的基础知识 队列是一种常用的数据结构，它最大的特点是 “先入先出”……
在 Java 中，队列是一个定义了插入和删除操作的接口 Queue……
……在某些时候调用函数 add、remove 和 element 时可能会抛出异常，但调用函数 offer、poll 和 peek 不会抛出异常。例如，当调用函数 remove 从一个空的队列中删除最前面的元素时，就会抛出异常。但如果调用函数 poll 从一个空的队列中删除最前面的元素，则会返回 null
在 Java 中实现了接口 Queue 的常用类型有 LinkedList、ArrayDeque 和 PriorityQueue 等。但 PriorityQueue 并不是真正的队列，第 9 章会详细介绍 PriorityQueue
队列的应用 队列是一种经常被使用的数据结构。如果解决某个问题时数据的插入和删除操作满足 “先入先出” 的特点，那么考虑用队列来存储这些数据
面试题 41：滑动窗口的平均值
题目：请实现如下类型 MovingAverage，计算滑动窗口中所有数字的平均值，该类型构造函数的参数确定滑动窗口的大小，每次调用成员函数 next 时都会在滑动窗口中添加一个整数，并返回滑动窗口中所有数字的平均值
class MovingAverage { private Queue&lt;Integer&gt; nums; private int capacity; private int sum; public MovingAverage(int size) { nums = new LinkedList&lt;&gt;(); capacity = size; } public double next(int val) { nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7217d0ce1d3660b4fbea7c687ba586e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e46fcb3cdea72642aba08e5282c28c6/" rel="bookmark">
			Flutter Windows开发环境搭建教程与学习资料推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows应用软件开发有很多框架可以选择，例如比较流行的Electron、Qt、CEF、WPF、WinForm、MFC、DuiLib、SOUI等等。Flutter是近几年流行的全平台应用开发框架，可以进行Android、IOS、Web、MacOS、Windows、Linux等平台的应用软件开发。
一、Flutter介绍 Flutter是谷歌推出的一种移动应用开发框架，使用Dart语言编写。更多Flutter资料大家可参考Flutter官网: https://flutter.cn/。
Flutter 2.10 起，Windows 的支持已进入 stable 渠道！ 本篇介绍Flutter Windows开发环境搭建，以及如何使用Flutter进行Windows应用软件开发。
二、Flutter Windows开发环境搭建 详细参考官网 https://flutter.cn/docs/get-started/install/windows
有以下几点需要注意
1 C++编译支持 Flutter Windows开发，依赖C++编译环境，因此需要先安装Visual Studio，安装时注意勾选C++模块、C++ Windows桌面开发模块。
2 查看电脑中是否有flutter dart环境 where flutter dart 3 必须在 Windows 10/11 上启用开发者模式 4 Flutter安装 Flutter开发语言是Dart，注意，不需要单独安装dart sdk, flutter sdk包含有dart 。
5 环境变量设置 根据官网的提示，进行配置环境变量，加入 flutter\bin 目录的完整路径，检测系统flutter开发环境
flutter doctor 结果如下：
三、Flutter IDE与项目创建 Flutter开发环境推荐使用IDEA或VS Code，下面介绍IDEA Flutter环境配置。
1 IDEA配置 (1) flutter插件安装 下载idea, 安装flutter插件, 安装flutter插件时会提示需要安装dart插件,点击是即可, 安装过程可能比较长, 安装完成后, 需要重启IDEA.
flutter插件安装完后,需要重启idea
(2) 创建flutter windows项目 初次使用idea创建flutter项目，需要指定flutter的路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e46fcb3cdea72642aba08e5282c28c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d04fa1af074d4592816d9e7d0a6015/" rel="bookmark">
			基于局部特征技术的航拍绝缘子图像检测和配准技术的研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输电线路担负着电力传输的重要职责，对输电线路的定期巡检是有效保证输电线路及其设备安全运行的一项基础性工作。传统人工巡检的作业方式，越来越受到自然条件的限制，无法满足实际的需要。采用直升机或无人机输电线路巡检方式具有高效、快捷、可靠、成本低、不受地域影响等优点，已成为我国输电线路巡检的重要方式。本课题利用计算机视觉技术对航拍图像中的绝缘子状态进行检测，利用局部特征进行图像配准技术的研究，进而实现对输电线路的是否安全正常状态进行自动化监测，提升巡检效率和质量，提升巡检工作的自动化和智能化水平。
matlab程序+仿真分析+说明介绍点击如下链接下载：
https://download.csdn.net/download/weixin_45905610/80127926
基于局部特征技术的航拍绝缘子图像检测和配准技术的研究资源-CSDN文库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42e6306465a123c9d056fd96da56098/" rel="bookmark">
			2023人工智能与类脑计算产业发展研究报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类脑计算是指受人脑信息处理方式启发，以更通用的人工智能和高效智能边缘端/云端为目标构建信息系统的技术。其目标是使机器能够以大脑启发的方式实现人类的各种认知能力和协调机制，最终达到或超过人类的智能水平，推动计算机科学的发展，并为下一代通用人工智能的计算提供可能的解决途径。
本报告重点对类脑计算产业、国内外类脑计算市场及其国内外研究现状进行阐述，分析类脑计算对我国数字经济发展的影响，最后阐述我国发展机遇与挑战。
关注公众号：【互联互通社区】，回复【AI170】获取全部报告内容。
人工智能
关注互联互通社区公众号，回复以下编号，可快速下载相关专题报告合辑。
AI001：人工智能核心技术产业白皮书
AI002：2021爱分析人工智能应用趋势报告
AI003：人工智能数据安全风险与治理
AI004：2020年人工智能十大技术进展
AI005：2020中国人工智能厂商全景报告
AI006：2020年中国人工智能商业落地
AI007：新一代人工智能白皮书
AI008：人工智能未来制胜之道
AI009：人工智能新基建发展白皮书
AI010：腾讯人工智能白皮书
AI011：5GAI典型案例
AI012：AI+高等教育发展与应用白皮书
AI013：中国AI+零售行业发展研究报告
AI014：中国AI+零售行业发展研究报告
AI015：AI产业全景图
AI016：2020中国AI中台应用趋势报告
AI017：2021AI智能制造研究报告
AI018：2021中国AI商业落地市场研究报告
AI019：2021认知智能发展研究报告
AI020：上海人工智能创新发展探索与实践案例集
AI021：2021AI中台白皮书
AI022：2021全球人工智能教育落地应用研究报告
AI023：2021可信人工智能白皮书
AI024：中国AI+安防行业发展研究报告
AI025：2021云上智能白皮书
AI026：2021年中国人工智能+医疗与生命科学行业研究报告
AI027：中国云原生AI开发平台白皮书
AI028：2021中国智慧城市AIoT应用研究
AI029：中国AI中台赋能城市空间管理白皮书
AI030：人工智能的认知神经基础白皮书
AI031：企业智能化的路径、方法与领先实践
AI032：AI框架发展白皮书（2022年）
AI033：人工智能白皮书（2022年）
AI034：2022深度合成十大趋势报告 AI035：中国AI数字商业产业展望2021-2025
AI036：可解释AI发展报告2022
AI037：2022百度人工智能专利白皮书
AI038：AI+数字孪生发展现状,应用场景及典型企业
AI039：2022年全球人工智能产业研究报告
AI040：中国神经科学数字化创新（2022）
AI041：全球中小学人工智能教育支撑环境白皮书
AI042：2022年中国知识图谱行业研究报告
AI043：人工智能知识点全景图
AI044：人工智能生成内容（AIGC）白皮书
AI045：2022中国AI商业落地研究报告
AI046：中国AI技术应用场景市场研究及选型评估
AI047：2022金融AI发展研究报告
AI048：可信人工智能产业生态发展报告（2022年）
AI049：2022年中国对话式AI行业发展白皮书
AI050：人工智能技术应用实践白皮书
AI051：人工智能标准化白皮书（2021版）
AI052：商汤人工智能伦理治理年度报告（2022年）
AI053：人工智能深度学习课程高效调研报告
AI054：2022人工智能发展白皮书
AI055：2022医疗AI行业研究白皮书
AI056：人工智能治理与可持续发展实践白皮书
AI057：中国人工智能软件基础设施高质量发展报告
AI058：2022年中国AI+金融行业发展研究报告
AI059：人工智能时代的算法治理报告（2022年）
AI060：2022-2023中国人工智能计算力发展评估报告
AI061：2023年AI创意营销趋势白皮书
AI062：2023AIGC发展趋势报告
AI063：中国人工智能框架市场调研报告
AI064：人工智能产业分析报告（2023）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d42e6306465a123c9d056fd96da56098/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523c2cc7a13e4fe5cdcc0e7af0a8c6e0/" rel="bookmark">
			进阶JAVA篇- Collection 类的常用的API与 Collection 集合的遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.0 Collection 类的说明
1.1 Collection 类中的实例方法
2.0 Collection 集合的遍历方式（重点）
2.1 使用迭代器（ Iterator ）进行遍历
2.2 使用增强型 for 循环进行遍历
2.3 使用 Java 8的 Stream API 进行遍历（使用 Lambda 表达式进行遍历）
1.0 Collection 类的说明 Collection 类是 Java 单列集合框架中的根接口，它是所有单列集合类的父接口。Collection接口有多个实现类，常用有 ArrayList：基于数组实现的动态数组，支持随机访问和快速插入、删除元素。
1.1 Collection 类中的实例方法 代码如下（以举例子的形式来介绍）：
import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; public class CollectionAPI { public static void main(String[] args) { //因为 Collection 是接口，故不能直接创建对象， // 那么需要利用它实现类 ArrayList 类,且支持泛型类 Collection&lt;String&gt; collection = new ArrayList&lt;&gt;(); // 1. Collection 中 add() 的实例方法，添加元素 collection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/523c2cc7a13e4fe5cdcc0e7af0a8c6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0542b115366535fcc6b5fbfd2a2df846/" rel="bookmark">
			经典网络模型系列——Swin-Transformer详细讲解与代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网路模型整体架构二、Patch Partition模块详解三、Patch Merging模块四、W-MSA详解五、SW-MSA详解 masked MSA详解六、 Relative Position Bias详解七、模型详细配置参数八、重要模块代码实现： 1、Patch Partition代码模块：2、Patch Merging代码模块：3、mask掩码生成代码模块：4、stage堆叠部分代码：5、SW-MSA或者W-MSA模块代码：九：模型整体流程代码实现： 论文名称：Swin Transformer: Hierarchical Vision Transformer using Shifted Windows
原论文地址： https://arxiv.org/abs/2103.14030
官方开源代码地址：https://github.com/microsoft/Swin-Transformer
一、网路模型整体架构 二、Patch Partition模块详解 三、Patch Merging模块 四、W-MSA详解 五、SW-MSA详解 masked MSA详解 六、 Relative Position Bias详解 七、模型详细配置参数 八、重要模块代码实现： 1、Patch Partition代码模块： class PatchEmbed(nn.Module):"""2D Image to Patch Embeddingsplit image into non-overlapping patches 即将图片划分成一个个没有重叠的patch"""def __init__(self, patch_size=4, in_c=3, embed_dim=96, norm_layer=None):super().__init__()patch_size = (patch_size, patch_size)self.patch_size = patch_sizeself.in_chans = in_cself.embed_dim = embed_dimself.proj = nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size)self.norm = norm_layer(embed_dim) if norm_layer else nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0542b115366535fcc6b5fbfd2a2df846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb026b3bdb75a602a66bd13fac940369/" rel="bookmark">
			开发过程中的八种确认方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确认是确保做了正确的事情，方向不偏。确认可以在项目前期做，也可以在项目后期做，提倡持续确认、质量左移。在前期主要是检测需求的质量，在后期是检测完成的系统是否真的是客户所需。开发过程中常见的八种确认手段有：
1 原型确认
通过快速构造系统原型，让客户基于原型确认是否满足了其需求。
2 COSMIC度量需求规模
当采用COSMIC方法度量软件需求的规模时，需求应描述到可测试的程度，能够识别出数据对象、数据属性、输入、输出、读与写，否则需求则是模糊的。
3 同行评审
找需求活动的上游、同级、下游的人员参与评审需求文档，从不同的角度识别需求中存在的问题。
4 编写测试用例
通过编写高层次的测试用例用以判断需求是否完备、无二义以及足够详细。
5 增量交付
通过增量交付的方式，尽早获得客户的反馈，尽早确认系统功能，而不是让客户一次性确认系统的所有功能，可以避免最后一刻才报告坏消息。
6 模拟环境测试
通过在模拟环境中运行系统以检测系统可能存在的问题。
7 真实环境试运行
在上线之前可以在客户的真实环境中试运行一段时间，让客户试用一下，检查是否满足了他们的真正需求。
8 系统上线后的反馈
系统上线后客户使用系统反馈意见给开发方，这是进行系统确认的最终手段，使用是检验系统是否满足的需求的终极手段，这种方式反馈的时机比较晚，返工的成本比较高。
需要特别说明的是：代码走查、集成测试、静态扫描、设计评审等是验证的行为，不属于上图所示的确认活动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4059168fefe6ea10650a6f783e08dbc1/" rel="bookmark">
			iOS 用masonry布局Scrollview的问题,添加在scrollview的子控件约束失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// // ViewController.m // Log // // Created by xxzx on 2018/11/23. // Copyright © 2018 xxzx. All rights reserved. // #import "ViewController.h" #import &lt;Masonry.h&gt; @interface ViewController () // scrollView @property (nonatomic, strong) UIScrollView *scrollView; // 约束参照视图,也是容器视图 @property (nonatomic, strong) UIView *contentView; // 第一个测试view @property (nonatomic, strong) UIView *oneView; // 第二个测试view @property (nonatomic, strong) UIView *twoView; // 第三个测试view @property (nonatomic, strong) UIView *threeView; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4059168fefe6ea10650a6f783e08dbc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adba4951520560e887bd0f25f927e160/" rel="bookmark">
			C&#43;&#43;基础系列(一) 对象指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 函数指针和指针函数 1.1 函数指针 这两个是C语言里两个比较绕的概念，我们先说一下函数指针
函数指针本质是一个指针，该指针的地址指向了一个函数。
在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址，而且函数名表示的就是这个地址。
写法如下： 函数返回值类型 (* 指针变量名) (函数参数列表);
int (*fun) (int a ， int b);
1.2 指针函数 指针函数本质是一个函数， 其返回值为指针
指针函数是一个函数。函数都有返回类型（如果不返回值，则为无值型），只不过指针函数返回类型是某一类型的指针。
写法如下：
*类型标识符 函数名(参数表)；
int *fun(int x,int y);
常规函数和指针函数区别: 在函数名前面多了一个 * 号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。
其他理解方式：
指针函数：int* fun(int x,int y);
函数指针：int (*fun)(int x,int y);
可以简单粗暴的理解为，指针函数的*是属于数据类型的，而函数指针的星号是属于函数名的。
一个很简单的判定方法就是观察(*)，记住其中一个即可：
int (*p)(int,int);有括号，*与p结合，*p就是个指针，指向返回值为整型且有两个整型参数的函数的指针，因此称为函数指针。
int*p(int,int); 没有括号，*与int结合，int*为返回类型，p就是一个函数名，这时就是一个指针函数，只不过返回值类型为int*。
二. 对象指针 我们在来看看C++中的对象指针
2.1 指向对象成员函数的指针 需要注意的：定义指向对象成员函数的指针变量的方法和定义指向普通函数的指针变量方法所有不同。
指向普通函数的指针变量就是第一小节中说的函数指针
而定义一个指向对象成员函数的指针变量要复杂一点，直接通过代码来说明
#include &lt;iostream&gt; using namespace std; class Time { public: Time(int, int, int); //声明带参构造函数 int hour; int minute; int sec; void get_time(); // 声明共有成员函数 }; Time :: Time(int h, int m, int s) { hour = h; minute = m; sec = s; } void Time::get_time() { cout&lt;&lt;hour &lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adba4951520560e887bd0f25f927e160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff1abcc12ec708e8072c2bc3207f8a8/" rel="bookmark">
			EasyPlayer播放视频因流媒体协议不一致导致的无法播放问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
页面中采用EasyPlayer插件播放视频，因视频流协议（http）和页面访问协议(https)不一致，导致视频无法播放
解决方案：
pc端chrome浏览器可通过添加信任站点来处理（页面地址和流地址都加入信任站点）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9638e4d5da329210ac977fc00f97cf28/" rel="bookmark">
			java中发生死锁怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Java中，死锁是一种多线程编程中常见的问题，它发生在两个或多个线程相互等待对方释放资源的情况下。
当发生死锁时，线程会永久阻塞，无法继续执行。以下是一些处理Java中死锁的方法：
预防死锁 使用单一锁：尽量减少多个锁的使用，或者使用一个全局锁，以减少死锁的机会。锁的顺序：确保线程在获取多个锁时按相同的顺序获取，以减少死锁的可能性。超时机制：为获取锁设置超时，当等待锁的时间超过一定阈值时，线程可以放弃锁并重试。 检测死锁 使用工具：Java提供了一些工具，如jstack和jconsole，可以帮助你检测死锁问题。编程方法：编写代码来检测死锁。例如，使用线程Dump来分析线程的状态。 解决死锁 中断线程：可以尝试中断一个或多个线程，以打破死锁。重试机制：等待一段时间后，重新尝试获取锁。释放资源：确保每个线程在使用完资源后及时释放，以减少死锁的机会。 使用并发工具类 Java提供了一些并发工具类，如java.util.concurrent包中的ReentrantLock和Semaphore，这些工具类提供更多的控制和灵活性，可以帮助避免死锁问题。 设计良好的并发策略 尽量避免复杂的锁依赖关系。使用线程安全的数据结构。良好的并发设计可以减少死锁的发生。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab13e50b9427f04b1c3764c598e21913/" rel="bookmark">
			C&#43;&#43;——入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
C++入门 前言一、c++关建字二、命名空间1.命名空间定义2.命名空间的使用 三、输入和输出四、缺省参数概念分类 五、函数重载概念 六、引用概念特性常引用使用场景1、做参数2、做返回值 引用和指针的区别指针和引用的不同点 七、内联函数概念 八、auto关键字auto不能推导的场景 九、基于范围的for循环十、指针nullptr总结 前言 C++是在c语言的基础上，容纳进去了面向对像编程思想，并增加许多有用的库，以及编程范式。
补充c语言的一些不足的地方，以及对不合理的地方进行优化。
为后续类和对象学习打基础。
一、c++关建字 C++总计63个关键字，C语言32个关键字。
这里只是简单的展示，后面通过继续学习了解这些关键字的含义。
二、命名空间 1.命名空间定义 在C/C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都有在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。
代码如下（示例）：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //命名空间定义 namespace xdt	//在stdilb.h中包含了rand函数，如果在定义rand的话就会产生冲突， //使用自己的一个独立的命名空间，就可以你避免冲突 { int rand = 1; } //命名空间还可以嵌套使用 namespace xdt_3 { int x = 3; int y = 6; namespace xdt_4 { int x = 10; int y = 100; } } 2.命名空间的使用 命名空间的三种使用方法
1、加域作用限定符
2、使用using将空间中的某个成员引入
3、使用using namespacem命名空间引入
代码如下（示例）：
#include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab13e50b9427f04b1c3764c598e21913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99b91cc286961d4615bd8eb337d7c52/" rel="bookmark">
			一文讲清楚检索增强生成（RAG）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是检索增强生成？逆向工作：为大语言模型提供额外的知识来回答问题通过系统提示给出LLM自定义指令为LLM提供特定的知识来源将所有内容放在一起并提出问题检索步骤：从您的知识库中获取正确的信息什么是嵌入？它们与知识检索有什么关系？使用嵌入找到最好的知识片段为您的知识库建立索引回顾整个过程 推荐阅读 How do domain-specific chatbots work? An Overview of Retrieval Augmented Generation (RAG)，本文是该文章的中译版。
有一个名为LangChain的流行开源库，它可以创建聊天机器人，其中包括用 3 3 3 行代码对任何网站/文档进行问答。这是LangChain文档中的一个示例。
from langchain.document_loaders import WebBaseLoader from langchain.indexes import VectorstoreIndexCreator loader = WebBaseLoader("http://www.paulgraham.com/greatwork.html") index = VectorstoreIndexCreator().from_loaders([loader]) index.query("What should I work on?") 它输出特定于Paul Graham文章的答案：
The work you choose should ideally have three qualities: it should be something you have a natural aptitude for, something you have a deep interest in, and something that offers scope to do great work.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e99b91cc286961d4615bd8eb337d7c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb436176e70334e1007236e78c98cb45/" rel="bookmark">
			开发板配置AP模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AP模式的配置需要三个服务，hostapd服务（提供热点访问和鉴权的服务端进程）、dhcpcd服务（配置静态IP）、dnsmasq服务（提供DNS和DHCP功能）
hostapd服务
开发板在/etc/hostapd.conf本身有这个配置文件，但是内容比较多且杂乱，在/etc/hostapd/hostapd.conf创建新的文件，写入以下内容
interface=wlan0 driver=nl80211 ssid=test-wifi //热点名字，自定义 hw_mode=g channel=6 wmm_enabled=0 macaddr_acl=0 auth_algs=1 ignore_broadcast_ssid=0 wpa=2 wpa_passphrase=test123456 //热点密码 wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP 给hostapd指定配置文件
hostapd -B /etc/hostapd/hostapd.conf dhcpcd服务
配置静态IP，编辑/etc/dhcpcd.conf文件，在文件末尾加入下面内容
interface wlan0 static ip_address=192.168.1.1/24 nohook wpa_supplicant 重新启动dhcpcd服务
dnsmasq服务
编辑/etc/dnsmasq.conf
注释掉其中的内容，加入下面的内容，dhcp分发ip从192.168.1.2~192.168.1.20，支持19个设备
interface=wlan0 dhcp-range=192.168.1.2,192.168.1.20,255.255.255.0,24h 重新启动dnsmasq服务
此时就可以搜索到上面配置的网络了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34f954b88864389e97222d2a1f40267/" rel="bookmark">
			SoC调试gpio不可控问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPIO不可控问题总结
判断是仅此gpio不可控还是一排的gpio不可控
1、仅此GPIO不可控
通过查看原理图，如果仅是这一个io口不可控，首先考虑复用问题，或被其他驱动占用
（1）如果是复用问题，通过下面命令查看io口被具体配置成了什么，或通过TRM文件查看寄存器配置，看被复用为了什么功能，
通过pinctrl修改管脚的配置，改为GPIO
cat /sys/kernel/debug/pinctrl/pinctrl/pin （2）如果是被其他驱动占用，通过sys创建此gpio时，大概率会出现此gpio口繁忙被占用的打印，除非板子上没有实际的模块占用此gpio，这样就可以通过设备树的tmp文件去查看实际的配置，改写设备树使得此gpio可控
2、一排的GPIO不可控
如果是一排的GPIO都不可控，大概率是软件上电源域配置问题，找到这一排gpio的电源，在kernel/Documentation/devicetree/bindings/power/rockchip-io-domain.txt
找到这一路电源的软件定义，在dts中寻找“io_domain”，修改对应的电源为实际电路的电源配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba01cdde4cebdd6f804de7f3939ea24e/" rel="bookmark">
			ubuntu变成只读文件系统怎么办？简单解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的虚拟机装在了移动硬盘里，在拔插usb时，不小心碰到了移动硬盘的接口，造成了断电文件系统变成了只读。
df-h 查看你的文件系统挂载位置，我是 /dev/sda5
1.先在windows系统里给移动硬盘去掉只读权限（实际上这一步骤可能多余，可以直接跳过去第2步）
搜索框输入cmd，以管理员身份运行
依次执行下面的命令
diskpart
list disk (列出磁盘)
select disk x (x为你装载ubuntu的硬盘)
attributes disk clear readonly (去除硬盘的只读属性)
ok轻松解决，下面就是打开虚拟机
2.打开虚拟机，会进入黑屏到initramfs界面
log信息里也可以看到这里的挂载情况，我的log里打印的是/dev/sda5
输入fsck -y /dev/sda5 回车
执行完后输入reboot重启
问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fbb434c56ec36709db0836441ef313/" rel="bookmark">
			2023人工智能全景报告《State of AI Report》出炉！AI未来一年的10大预测：GPT-4仍是全球最强，GenAI 大爆发，...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2023 人工智能全景报告《State of AI Report》出炉！给出AI未来一年的10大预测，GPT-4仍是全球最强，GenAI 大爆发，...1. 研究进展1.1 GPT-4仍是全球最强1.2 闭源模型趋于技术封闭，开源模型紧追不舍1.3 小模型的逆袭1.4 生成式AI推动生命科学的进步 2. 行业趋势2.1 英伟达赢麻了2.2 GenAI大爆发2.3 AI 中坚力量集体出走？ 3. 现有政策4. 安全问题5. 未来预测 2023 人工智能全景报告《State of AI Report》出炉！给出AI未来一年的10大预测，GPT-4仍是全球最强，GenAI 大爆发，… 10月12日，我们迎来了2023年的《人工智能全景报告》（《State of AI Report 2023》），该报告已连续六年发布，成为AI行业流行的风向标。
报告链接：https://www.stateof.ai/
今年的《State of AI Report》由AI投资人 Nathan Benaich 和 Air Street Capital 团队制作，报告超过160页，涵盖了研究进展、行业趋势、现有政策、安全问题、未来预测五个方面，对最新的 AI 发展现状和未来预期进行了深度分析。
传送门：回顾2022年人工智能全景报告
下载完整报告：2023 人工智能全景报告《State of AI Report》
1. 研究进展 报告第一部分总结了 2023 年以来的人工智能技术突破及它们的能力。
GPT-4的发布表明专有技术与次优开源方案之间存在能力差距，同时验证了通过人类反馈强化学习的有效性。
许多人试图用更小的模型、更好的数据集、更长的上下文来克隆或击败专有模型。
不清楚人类生成的数据能维持人工智能扩展趋势多久，也不清楚添加合成数据会产生什么影响。企业中的视频和数据可能是下一个目标。
LLM和扩散模型继续为生命科学界提供助力，多模态成为新的前沿，各种智能体热度增加。
1.1 GPT-4仍是全球最强 2023年是LLM之年，OpenAI的 GPT-4 仍是全球最强大的大型语言模型，成功击败了所有其他LLM———无论是在经典的AI基准测试上，还是在为人类设计的考试上。
1.2 闭源模型趋于技术封闭，开源模型紧追不舍 不过大模型厂商越来越趋于技术封闭，或许是出于安全和竞争方面的考量，闭源模型的开放性有所减弱。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fbb434c56ec36709db0836441ef313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7306f176c6b6960bd7e2c8de199847f1/" rel="bookmark">
			详解Swin Transformer核心实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年，基于自注意力机制的Vision Transformer将用于NLP领域的Transformer模型成功地应用到了CV领域的图像分类上，并在ImageNet数据集上得到88.55%的精度。
然而想要真正地将Transformer模型应用到整个CV领域，有两点问题需要解决。
1、超高分辨率的图像所带来的计算量问题；
2、CV领域任务繁多，如语义分割，目标检测，实力分割等密集预测型任务。而最初的Vision Transformer是不具备多尺度预测的，因此仅在分类一个任务可以很好地工作。
针对第一个问题，通过参考卷积网络的工作方式，以及窗口自注意力模型，Swin Transformer提出了一种带移动窗口的自注意力模型。通过串联窗口自注意力运算(W-MSA)以及滑动窗口自注意力运算(SW-MSA)，使得Swin Transformer在获得近乎全局注意力能力的同时，又将计算量从图像大小的平方关系降为线性关系，大大地减少了运算量，提高了模型推理速度。
针对第二个问题，在每一个模块(Swin Transformer Block)中，Swin Transformer通过特征融合的方式(PatchMerging，可参考卷积网络里的池化操作)每次特征抽取之后都进行一次下采样，增加了下一次窗口注意力运算在原始图像上的感受野，从而对输入图像进行了多尺度的特征提取，使得在CV领域的其他密集预测型任务上的表现也是SOTA。
下图为paperwithcode上的截图，截止2022/1/22号，Swin Transformer在各个CV任务上依然呈现霸榜状态。在CV领域，一般在某个任务上可以提高1%就已经很了不起了，而Swin Transformer则是在各个任务上提高了2%~3%的精度。
将Swin Transformer核心
制成SwinT模块的价值
如下图所示，Swin Transformer的核心模块就是黄色部分，我们需要将这个部分制成一个通用的SwinT接口，使得更多熟悉CNN的开发者将Swin Transformer应用到CV领域的不同任务中。
这么做的价值有两点：
1、Swin Transformer自身的能力强大，这个接口将不会过时。①实现超大尺寸整张图片的全局注意力运算所需要的超级计算单元短时间内不会出现（个人开发者也很难拥有这种算力），也就是说，窗口注意力依然能持续使用一到两年；②现在一般认为，简单有效的才是最好的，而Swin Transformer的实现则非常简单，很容易让人看懂并记住其工作原理；③实践上，Swin Transformer也得到了SOTA，并且成功地获得了马尔奖，简单与强大两者加在一起才是能拿马尔奖的原因。
2、实现方便快捷的编程，例如我们要将Unet变成Swin-Unet，我们将只需要直接将Conv2D模块替换成SwinT模块即可。我们通常需要在同一个网络中，不仅使用Swin Transformer中的块，也会使用到Conv2D模块(例如Swin Transformer用在上层抽取全局特征，Conv2D用在下层抽取局部特征)，因此我们要对原Swin Transformer模型进行架构上的更改。
移动窗口为什么能有全局特征抽取的能力
Swin Transformer中注意力机制是如何运行的，如下图。首先，我们对每个颜色内的窗口进行自注意力运算，如[1,2,3,4]，[5,6,7,8]，[9,10,11,12]，[13,14,15,16]每个列表内的元素做自注意力运算。
然后，滑动窗口，可以看作背景黑框在图像上滑动对图像进行的重新切分。
最后，将图像补回原来的大小，这一步是方便代码的编写，并且对窗口中原本不相邻的区域不做注意力运算。注意，窗口是由黑框决定的。也就是说，由于原图像中[4,7,10,13]相邻，因此左上角[4,7,10,13]一起做注意力运算；而[16,11,6,1]原本不相邻，因此右下角[16],[11],[6],[1]单独做注意力运算，而[16],[11]之间不做注意力运算。左下角[12,15],[2,5]各自相邻，因此[12,15]做注意力运算，[2,5]做注意力运算[12,15]和[2,5]之间不做注意力运算。
通过这两步，美妙的事情发生了，我们首先在第一步建立了[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]各自窗口之间的联系，然后在第二步建立了[4,7,10,13]之间的联系。可以观察到，通过这二步，我们得以建立[1,2,3,4,5,6,7,8,9,10,11,12]之间的联系，滑动窗口+原始窗口就如同一个高速通道在图像的左上角和右下角之间建立起了自注意力的联系，从而获得了全局感受野。
我们可以发现，滑窗和不滑窗两步是缺一不可的。只有两者同时存在，我们才能够建立全局的注意力。因此，W-MSA和SW-MSA必须作为一个整体一起使用。后续在我们的SwinT模块的源代码中，将使用W-MSA、SW-MSA和PatchMerging下采样，并将这三部分整合成一个模块。本文章的后续我们将演示这个接口如何使用，利用这个接口真实地搭建一个SwinResnet网络并对其进行性能测试！
SwinT接口的使用方式
SwinT接口的源代码可以参考：
https://aistudio.baidu.com/aistudio/projectdetail/3288357
#导入包,miziha中含有SwinT模块 import paddle import paddle.nn as nn import miziha #创建测试数据 test_data = paddle.ones([2, 96, 224, 224]) #[N, C, H, W] print(f'输入尺寸:{test_data.shape}') #创建SwinT层 ''' 参数： in_channels: 输入通道数，同卷积 out_channels: 输出通道数，同卷积 以下为SwinT独有的，类似于卷积中的核大小，步幅，填充等 input_resolution: 输入图像的尺寸大小 num_heads: 多头注意力的头数，应该设置为能被输入通道数整除的值 window_size: 做注意力运算的窗口的大小，窗口越大，运算就会越慢 qkv_bias: qkv的偏置，默认None qk_scale: qkv的尺度，注意力大小的一个归一化，默认None #Swin-V1版本 dropout: 默认None attention_dropout: 默认None droppath: 默认None downsample: 下采样，默认False，设置为True时，输出的图片大小会变为输入的一半 ''' swint1 = miziha.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7306f176c6b6960bd7e2c8de199847f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25b3ca736888698142dd042a417e8e2/" rel="bookmark">
			1024是什么节日？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每年的10月24日，对于许多人来说可能只是一个普通的日子，但对于程序员和技术爱好者来说，这一天具有特殊的意义。它被称为"1024节日"，一个专为程序员设立的节日，用来庆祝他们的成就和贡献。
程序员节的由来可以追溯到2004年，当时一些中国程序员在网上讨论，提议将10月24日定为程序员节，以表彰程序员的辛勤工作和贡献。自此以后，程序员节逐渐被越来越多的程序员所认知和庆祝，成为了中国程序员的一个重要节日。
在程序员节这一天，很多公司和组织都会举办一些庆祝活动，比如举行技术分享会、组织编程比赛、发放礼品等等，以表彰程序员的工作和贡献，并鼓励程序员们继续努力学习和创新。
程序员节的庆祝活动不仅仅局限于中国，很多国家和地区的程序员也会庆祝这个节日。在国际上，程序员节通常被称为“程序员之日”，日期是每年的9月13日。这个日期的由来是因为二进制下的9月13日是一个比较特殊的数字，即1001 1011，它表示了程序员们对于计算机的热爱和追求。
作为一个庆祝程序员的节日，程序员节的意义不仅仅在于表彰程序员的工作和贡献，更在于鼓励程序员们继续努力学习和创新。在当今数字化的时代，程序员们的工作和贡献越来越受到社会的重视，他们的技术和创新对于推动数字化进程和促进经济发展都起到了重要的作用。因此，程序员节的庆祝活动不仅仅是一种表彰和庆祝，更是一种鼓励和激励，让程序员们在未来的工作中更加努力和创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656c3eac40840f8018d156c4ba32ec2c/" rel="bookmark">
			错误代码：PR_CONNECT_ABORTED_ERROR，浏览器报错：ERR_PROXY_CONNECTION_FAILED，浏览器无法打开网页的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误代码PR_CONNECT_ABORTED_ERROR通常是由于网络连接中断或被阻止而导致的。这可能是由于网络问题、防火墙设置或其他安全软件引起的。
一般来说，此问题一般都是浏览器访问不了网页，更换浏览器都不行，但是QQ微信登及时通讯工具却可以使用。解决此类问题可以通过进入在IPV4协议中，设置为自动获得ip地址，自动获得DNS服务器地址即可解决。具体步骤如下：
打开控制面板，选择网络和internet，进入网络和共享中心。
右键点击查看WLAN状态，再点击属性
在WLAN属性中找到Internet协议版本4（TCP/IPv4）,点击确定。
将获取dns地址改为自动获取，点击确定。
最后，刷新浏览器，即可访问网页地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea6d879989161719cdf0dff013ba9f9/" rel="bookmark">
			Python学习之Python3.10中match-case的用法和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 3.10 中引入了新的 match-case 语法，它是一种用于模式匹配的结构。它类似于 switch-case 语句，可以根据不同的模式匹配执行不同的代码块。
match-case 语法的基本结构如下： match expression: case pattern1: # 执行代码块1 case pattern2: # 执行代码块2 ... case patternN: # 执行代码块N case _: # 默认代码块 其中 expression 是要匹配的表达式，pattern 是用于匹配的模式，通过 case 关键字连接。下面是几种常见的 match-case 用法及示例：
1. 常量匹配： match x: case 0: print("值为0") case 1: print("值为1") case _: print("其他值") 2. 变量匹配： match x: case 'a': print("变量为'a'") case n: print(f"变量为{n}") case _: print("其他情况") 3. 类型匹配： match value: case str_val as str: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea6d879989161719cdf0dff013ba9f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8f30e578fc661f49195899a7b451b5/" rel="bookmark">
			vmware17 许可证密钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MC60H-DWHD5-H80U9-6V85M-8280D（亲测有效）
JUO9O-6039P-08409-8J0QH-2YR7F
4A4RR-813DK-M81A9-4U35H-06KND
NZ4RR-FTK5H-H81C1-Q30QH-1V2LA
JU090-6039P-08409-8J0QH-2YR7F
4Y09U-AJK97-089Z0-A3054-83KLA
4C21U-2KK9Q-M8130-4V2QH-CF810
MC60H-DWHD5-H80U9-6V85M-8280D
ZA30U-DXF84-4850Q-UMMXZ-W6K8F
AC590-2XW97-48EFZ-TZPQE-MYHEA
YF39K-DLFE5-H856Z-6NWZE-XQ2XD
AC15R-FNZ16-H8DWQ-WFPNV-M28E2
CZ1J8-A0D82-489LZ-ZMZQT-P3KX6
YA11K-6YE8H-H89ZZ-EXM59-Y6AR0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8436bdc0667e110722cd9539f80c1b3c/" rel="bookmark">
			骚戴笔记公告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天软考成绩出来了，我一次拿下，的确是很感谢up主zst_2001！如果不是他的视频我不可能一次过！当然你们能看到我这个笔记也要感谢up主！我本身是不打算分享出来的，完全是被up主的无私伟大感染了才会分享出来哈哈哈~而且这个笔记我后续不会做任何维护和完善！！！
个人建议（主要是针对跟我一样基础不好的人提的建议）
我的基础不好，说白了我大学任何课都没有怎么听过，所以考这个证书我准备了一个月多一点，一开始完全不知道怎么复习？不知道怎么下手？后来发现了这个up主，他的视频很多，我个人觉得讲的很nice！完全够应考！
我这次准备了一个月多一点，可以很负责的告诉跟我一样基础不好的人，想要稳妥一些一次拿下这个证书，那么一个月多的准备太短了！我一开始悠哉悠哉的看，后面发现时间完全不够用，所以我后面一天刷了100集以上的视频，最多一天刷了260多集，简称疯狂！而且我还要做笔记，笔记的作用是为了快速复习，没有笔记你只能再刷一次视频来复习，不但效率低时间也要花很久的时间，所以才有这个笔记，所以我建议你们两个月备考稳妥一些！准备的充分一些一次过的概率就大很多！
总体来说，这个up主的视频都刷完一遍，然后通过我的笔记复习第二遍，最后通过我笔记的钉子户进行第三遍复习！基本上稳妥了！当然我的备考思路是下午的算法题直接放弃！所以没有做算法的任何笔记！还有上午题的英语题基本放弃！
骚戴有话说：这份软件设计师的笔记应该帮助过很多人，但是很少有在评论区感谢我的，可能大家白嫖习惯了，觉得这个是我应该的！我理所当然的！可以通过后台数据发现大家收藏更多，但是很少点赞，我需要更多的点赞和收藏来达到我玩CSDN的小目标，希望大家可以支持一下我！如果大家还是更多的完全白嫖，免费的点赞都十分吝啬，那我分享笔记的意义将荡然无存！毕竟分享欲是需要回应的！点赞就是最好的回应！那么后续这两个专栏会升级为付费专栏，一但成为付费专栏后续就无法再免费了，它将永远是付费专栏！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/040bf8edba0cfac1dead4f8a5098515a/" rel="bookmark">
			多模块打包报错找不到包的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近做微服务项目，服务A，服务B，..，服务A依赖B，在idea里都可以跑起来，但是当打包部署到服务器时，懵逼了，各种clean package 就是不行，总是报找不到类或找不到包，痛定思通，网上各种百度，结果试了下这个可以。
在被依赖的B服务pom里添加：
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 其他模块：
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 然后clean package 就可以了：
注意：如果你的配置文件就是如上配置，那么你需要在maven打包的时候，install一下，就可以依赖了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c8dbe8f5f067d9c35e747b4c75c235/" rel="bookmark">
			2023最新Office2021专业增强版安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Office专业增强版2021是一套办公软件套装，包含了Word、Excel、PowerPoint、Outlook、Access、Publisher、OneNote、Teams等应用程序。这个版本是在Office 365的基础上推出的新版本，与之前的Office版本相比，增强了许多功能。也是目前最新的Office版本。
文章有点长需要耐心看，步骤如下：
Office办公软件mac安装包下载: https://wm.makeding.com/iclk/?zoneid=47172
Office办公软件win安装包下载: https://wm.makeding.com/iclk/?zoneid=47173
首先下载打开登录，如果没有的话先注册一个，注册登录后再打开一下 然后出现下图：
这个时候输入产品的兑钥，如上图，如果没有产钥可以用输入产品密钥后点击下一步，点击后如下图：
这个时候点击确定，点击后部分设备会自动跳转到微软商店的Office安装界面，点击安装即可，如果没有跳转的话，或者跳转后很久没有反应的话，
这时候点击安装，点击后会提示如下图：
如果你不需要更改语言的话，可以直接点击安装就行了。点击安装后会自动下载安装程序。
在浏览器下载目录找到下载的安装程序，如下图：
双击这个安装程序，双击后不要操作设备，等待10秒左右会出现下图：
出现上图只需等待即可，网速快的估计也就两分钟就安装完成了。
安装完成后提示下图：
此时已完成安装，点击这个关闭。（注意：安装完成后是没有桌面快捷方式的）
这个时候点击Win开始图标，如下图：
点击后在出现的搜索框里面输入Word、Excel、PowerPoint 都可以，先固定到任务栏也可以。如下图：
随便打开一个，我这边打开的是Word，打开后点击登录会提示下图：
这时候登录你之前兑换产品的微软账户，登陆后会弹出一个页面，点击页面提示的“入门”然后会提示让你接受许可，点击接受后出现如下图：
这个时候等待就行了，大概10秒左右，就会提示下图：
大功告成，此时完成可以使用了，可以联网放心的使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e78a28ff0104aebb09dea582b4ff8f4/" rel="bookmark">
			从上手到进阶，威联通NAS非官方使用指南【安全设置/AList部署/影视库搭建/虚拟机实操】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从上手到进阶，威联通NAS非官方使用指南【安全设置/AList部署/影视库搭建/虚拟机实操】 哈喽小伙伴们好，我是Stark-C。
上篇我分享的《威联通NAS从入门到上手》的文章收到了很多小伙伴的关注：
出来之后，有几位粉丝朋友又催着继续更，让我说一说更“高级” 一点的玩法。高级谈不上，毕竟我也只是摸索中的“爱好者”，所以本期教程教程就在上篇文章的基础上，来一些上难度的，也就是标题所说“从上手到进阶”的玩法吧！
🔺出场的主角依然是我最喜欢折腾的威联通4盘位旗舰NAS【威联通TS-464C2】，搭载的N5095四核心四线程处理器，并且我已经升级到了24GB（8+16)内存，目前它的性能已经可以媲美一台中等生产力的电脑主机了！
本期教程包含以下内容：
至于我为什么会选择这几个项目作为教程，原因我稍后都会提到。
OK，不废话，开干！
必备安全设置 目的：熟悉威联通QTS系统更多设置功能
通俗来讲我们的NAS其实就是相当于我们日常使用的电脑，有自己的硬件配置，还有自己的系统，所以它也和电脑一样，也有中毒的可能，最典型的就是被不法分子植入勒索病毒要赎金。
一般来说像威联通这种专业性很强的NAS的安全防护还是非常到位的，基本上99%的中勒索病毒的NAS用户主要责任还是在于自己平时在使用NAS的时候没有做好系统的安全防护，才导致不法分子有可乘之机。所以我们在购买NAS之后，还需要有防患于未然的安全意识，对它做进一步的优化与设置，并养成良好的使用习惯，才能达到最大限度的万无一失。
1，保持最新系统
和电脑系统一样，威联通的QTS系统也会不定期的更新，除了带来一些新增功能与必要的系统优化，还会带来最新的安全防护升级，所以如果NAS提示有系统更新提醒，建议第一时间更新系统！
🔺依次打开威联通「控制台—系统—固件更新—检查更新」，如果提示有更新直接升级就可以了。目前威联通最新的固件版本已经来到QTS 5.1.2，除了性能的提升，系统内核Linux Kernel 也跟着升级，安全性更高。
2，停用管理员帐户（admin）
因为绝大多数的NAS产品默认管理员账户一般都是一样的，所以很容易就被攻击者猜到而主动攻击这个账户，并且管理员账户拥有NAS的最高权限，被他人知道后后果不堪设想。
🔺好在威联通在我们创建一个新用户之后默认是禁用管理员账户的。
🔺创建新用户很简单，打开「控制台—权限—用户—创建—创建用户」即可。
🔺我们可以在创建新用户的时候赋予这个用户管理员权限，仅需在右边的「用户组」下面勾选“administrators”即可。
🔺我们以后也可以按照自己的需求手动开机和停用系统管理员账户（admin）。
3，更改默认登录端口号
只要是同一品牌的NAS，它的后台默认WEB端口号都是一样，比如说威联通默认的就是“5000”和“5001”（分别对应HTTP和HTTPS连接端口）。如果你不改，等到某一天你的公网IP暴漏，任何人都能随意访问你的NAS WEB页面了。虽说还有账号和密码一道屏障，但是让人随意访问终归不好。
🔺修改起来很简单：打开「控制台—系统—常规设置—系统管理」，页面中的“系统端口”以及HTTPS下面的“端口号”直接修改成自己能记住的就可以（支持范围1到65535，注意别和本地其它设备端口重复，80和443端口不能用）。
4，停用不必要的连接服务
威联通作为专业的网络存储设备，支持的连接协议非常多，而很多入侵者也正是利用NAS的连接协议来攻击我们的NAS设备的。需要说明的是，普通网络协议（比如SMB,NFS,WebDAV）平时开着不会有什么影响，但是一些底层服务（比如SSH 、SFTP 等）就比较危险了，毕竟它们可以连接系统内部。
🔺这里特别强调的就是SSH连接了，也是很多新手小伙伴容易忽略的地方。因为SSH使用最多的场景就是在搭建Docker容器的时候会用到，很多小伙伴都在在开启之后忘记关闭，所以我们一定要养成用完就关掉的习惯。
5，启用强密码
密码设置就如同我们的WIFI密码设置一样，越复杂破解的难度就越大。只要你能记住，密码尽量设置复杂一些，也就是我们说的“强密码”。
🔺威联通的“强密码”设置在“密码策略”里面，它提供给我们的设置规则还是比较丰富的，包含大小写字母以及数字、特殊符号随意组合。
6，启用两步验证
这个就不用解释了吧？我们日常登录很多应用APP或者一些私密账号（比如Apple ID， Google ID）都会提示两步验证，没想到威联通NAS也是支持的。
🔺威联通的两步验证只需要点击管理员图像，选择「登录和安全性」。
🔺然后就能看到“两步验证”了。
🔺威联通支持两步验证的方案除了有我们常见的手机验证码，还有安全码、二维码、手机端APP。
7，启用IP自动封锁功能
IP自动封锁功能简单来说就和我们使用手机的开屏密码是一样的道理，也就是在密码错误达一定的次数后，就不让你输入了。NAS设置自动封锁功能之后，如果对方输入的错误密码次数达到我们的设定值之后，就直接将对方的IP地址锁定，限制它再次输入，从而避免非法者的试探和攻击。
🔺威联通的IP自动封锁功能在「控制台—系统—安全—IP 访问保护」中。我们可以设置间隔时间，登录次数，阻止时长。一般默认设置的5次就差不多了，如果太少有的时候我们也存在误输的可能，把我们自己的IP也给封锁了就不好了。
8，外网启用 HTTPS 安全加密连接
HTTPS是目前广泛用于互联网的一种安全的通讯协议，因为 HTTPS 需要对网站及与它通讯的相关网页服务器进行身份认证才可以进行连接，从而达到避免其它人攻击的目的。要达到这个目的需要一个非常重要的东西，那就是签署凭证，也就是很多玩家口中的SSL证书。
关于在威联通NAS部署SSL证书实现HTTPS访问我出过详细教程，需要的直接移步该文章：
【保姆教程】一文搞定！教大家在NAS上免费安装SSL证书并实现安全的外网访问_NAS存储_什么值得买
9，安装杀毒软件和安全套件
你没有看错，和我们使用的Windows电脑一样，NAS也有自己专属的杀毒软件来保护自身的安全，并且还有自己的安全套件。
🔺威联通NAS直接给安排了4款安全类的应用套件，直接在「App Center」中，点击「安全」分类就能看到了。
Malware Remover：这是官方默认安全软件，可以检测系统中的恶意病毒程序或者文件，并且可以设置定期扫描；
McFee Antivirus：这个不用说了吧！电脑上就赫赫有名的大厂杀毒软件，没想到NAS上也给安排了；
QuFirewall防火墙：顾名思义，NAS上的专属防火墙了，主要是防止暴力破解，保护数据安全的；
Security Counselor：一个安全评估应用，可以对NAS进行各方面的风险评估，设定出适合自己的安全策略，并且给出相应的处理对策与建议。
10，备份才是王道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e78a28ff0104aebb09dea582b4ff8f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e61f603c5a747e87c1946879345c2c8/" rel="bookmark">
			plink分析100个性状的批量gwas分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是邓飞。
GWAS分析时，3~5个性状是正常操作，要分析100个性状呢，手动修改参数，工作量是够了，但是程序员的修养体现在哪里了？？？
如果还是按照每个性状一个文件夹，每个文件夹中一个脚本，不断地修改脚本，一点也不高端，所以，遇到这种情况，批量处理就派上用场了。
之所以之前一直不用，因为10个性状一下，没有必要，费心思想还不如直接动手操作了，但是100个性状真的吓到我了，不满足才能有进步。就看了一下参数说明，然后五分钟搞定了。虽然五分钟搞定的事情，但是写博客20分钟记录一下还是有必要的，独乐乐不如众乐乐。
开始介绍。
plink中其实没有多性状模型的参数，但是它有一个--mpheno，指定性状所在的列，我们可以借用。
数据来源，GWAS Cookbook的GWAS-dat2，用下面代码生成表型数据：
library(data.table) dd = fread("phe.txt") head(dd) set.seed(123) xx = rnorm(150000) nn = matrix(xx,1500,100) %&gt;% as.data.frame() nn[1:10,1:10] dd1 = cbind(dd,nn) dd1[1:10,1:10] fwrite(dd1,"mphe.txt",col.names = F,quote = F,sep = " ") 1. 表型数据 表型数据：模拟100个性状，整理为txt，第一列FID，第二列ID，第三列以后为性状
2. 基因型数据 3. 单个性状建模 用linear模型（GLM）：
plink --file b --pheno mphe.txt --linear --allow-no-sex --out re1 结果文件：
$ ls re1* re1.assoc.linear re1.log re1.nosex GWAS分析结果：
注意，上面基因型没有质控，所以有P值为NA的情况，正常质控的数据不会存在这种情况。
4. plink批量分析多性状gwas for i in {1..100};do echo "nohup plink --file b --allow-no-sex --pheno mphe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e61f603c5a747e87c1946879345c2c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1eaf3017da5b37ba3b2b04fb0a31c58/" rel="bookmark">
			完美解决 AndroidStudio Gradle 下载jar包慢Android Studio : Read timed out和connect timed out的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目当中找settings.gradle.kts文件将其
找到上图的文件，按照上图进行将下面内容进行替换
新版本
maven { url = uri("https://maven.aliyun.com/repository/public") } maven { url = uri("https://maven.aliyun.com/repository/google") } 老版本
mavenCentral()
maven { url 'https://maven.aliyun.com/repository/public '} maven { url 'https://maven.aliyun.com/repository/google' } 如果不知是什么版本就挨个试一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1279f0d215a961cf3a2f9b7237b4a3e5/" rel="bookmark">
			【linux系统操作】linux中所有基础命令失效，显示找不到该命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
有可能是之前修改了etc/profile.d目录下的环境变量配置文件导致。
解决办法：
方法一：恢复配置文件。
如果记得修改了配置文件那个地方，可以将配置文件修改回去，然后再保存更新。
方法二：直接在linux命令行界面输入如下，然后回车（导入环境变量，以及shell常见的命令的存放地址: export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
方法三：如果系统所有命令都不能使用时，可以使用绝对命令vi打开profile
1./bin/vi /etc/profile.d/环境变量文件名 2.# 在系统的配置文件里添加[环境变量]地址 3.export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271083b1311e93db89462ab6270112ee/" rel="bookmark">
			TS实用技巧：？？ 控制合并运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		??空值合并运算符 判断非空时非常好用
1. 当左侧操作数为null或者undefined时，返回右侧的操作数，否则返回左侧的操作数，与||不同的是，逻辑或会在左侧操作数为falsy时（如：“”，0）返回右侧操作数，此时如果对空字符串或者0有意义时使用空值合并运算符会省去es5中的很多判断
const data1 = 0
// 如果data1是undefined或者null，data2=100
const data2 = data1 ?? 100
// es5实现
const data2 = data1===undefined || data1===null ? 100 : data1
可用于短路，当空值合并运算符的做表达式不是null或者undefined时，不会对右侧表达式进行求职
function A() { console.log('A was called'); return undefined;}
function B() { console.log('B was called'); return false;}
function C() { console.log('C was called'); return "foo";}
console.log(A() ?? C());
console.log(B() ?? C());
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241f58a4f73ac4b8a1b5fbfada6b5651/" rel="bookmark">
			Linux系统安装Python3环境（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于如下Linux系统版本：
1、默认情况下，Linux会自带安装Python，可以运行python --version命令查看，如图： 我们看到Linux中已经自带了Python2.7.5。再次运行python命令后就可以使用python命令窗口了（Ctrl+D退出python命令窗口）。
2、查看Linux默认安装的Python位置 看到/usr/bin/python和/usr/bin/python2都是软链接，/usr/bin/python指向/usr/bin/python2，而/usr/bin/python2最终又指向/usr/bin/python2.7。所以运行python/python2/python2.7是一样的，如图：
3、安装python3 （1）下载 linux下执行
wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz 或者，登录Python Source Releases | Python.org，找到对应版本（我们以Python 3.6.5为例）如图：
下载Python-3.6.5.tgz
（2）文件上传 将文件上传到Linux系统的某个目录下，根据自己情况上传，本例上传到了/root/tools目录下，如图：
（3）解压 执行tar -zxvf Python-3.6.5.tgz命令，将文件解压到当前目录，如图：
（4）准备编译环境 执行如下命令：
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 解释说明一下（标记核心的包务必安装。例如不安装libffi-devel，则会导致pandas导入时报错）：
yum -y install zlib-devel bzip2-devel openssl-devel**(核心)** ncurses-devel sqlite-devel readline-devel tk-devel gcc make gdbm-devel db4-devel libpcap-devel xz-devel**(核心)** libffi-devel**(核心)**
安装python需要的依赖。成功后（Complete!），如图：
如果python是3.7版本，还需要安装libffi-devel。整个编译过程1分钟左右。
如果遇到如下问题：
Loaded plugins: fastestmirror
00:00:00
Could not retrieve mirrorlist http://mirrorlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/241f58a4f73ac4b8a1b5fbfada6b5651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bde8eb36a2cd661b700a78de60d522/" rel="bookmark">
			GSAP动画库的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GSAP是什么？ GSAP 是一个强大的 JavaScript 工具集，可以将开发人员变成动画超级英雄。构建适用于所有主流浏览器的高性能动画。动画化 CSS、SVG、画布、React、Vue、WebGL、颜色、字符串、运动路径、通用对象……任何 JavaScript 可以触及的东西！ GSAP 的 ScrollTrigger 插件可让您使用最少的代码创建令人惊叹的基于滚动的动画。（来自官网）
引入GASP库 1. npm下载
npm install gsap
2. 在文件中引入
import { gsap } from "gsap";
gsap.to() gsap.to()这个api里面有三个参数可以写，gsap.to("你的目标target", { 你所要做出的动作}, "提前时间或滞后时间")。gsap.to()其实就是将你所要操作的元素到你所指定的位置。
封装一个gsap组件 实现：加载组件的时候让数字从0-1以逐步递增的动画展示
&lt;template&gt; &lt;div&gt;{{ tweened.number.toFixed(0) }}&lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import gsap from 'gsap' import { reactive } from 'vue' const props = withDefaults( defineProps&lt;{ from: number to: number duration?: number }&gt;(), { from: 0, to: 0, duration: 1, }, ) const tweened = reactive({ number: props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5bde8eb36a2cd661b700a78de60d522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaeb84c24cad27473f981ad14a8552fe/" rel="bookmark">
			小程序技术在信创操作系统中的应用趋势：适配能力有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序技术在信创操作系统中的应用前景非常广阔，但也面临着一些挑战和问题。开发者需要积极应对这些挑战和问题，为信创操作系统的发展和推广做出贡献。同时，开发者也需要关注小程序技术在信创操作系统中的应用趋势，积极探索新的应用场景和商业模式，为企业和用户带来更多的创新和价值。 随着信息技术的不断发展，信息技术应用创新（简称“信创”）已经成为了当今企业数字化转型的重要趋势之一。信创是指在信息技术领域，以自主可控的国产软硬件产品和服务为核心，构建起一套完整的信息技术生态体系，以替代国外的信息技术产品和服务。在信创的背景下，企业应用需要具备良好的信创适配能力，以满足企业在数字化转型过程中的需求。
从技术角度来看，信创适配能力对于企业应用的开发和部署至关重要。以下是开发者关注的几个方面：
操作系统适配：信创操作系统通常采用不同的内核和技术架构，与传统的 Windows 或 MacOS 操作系统存在差异。因此，企业应用需要进行相应的适配，以确保在信创操作系统上正常运行。
数据库适配：信创生态中的数据库产品与传统的 SQL Server、Oracle 等数据库也存在差异。因此，企业应用需要进行相应的适配，以确保数据存储和访问的可靠性和安全性。
中间件适配：信创生态中的中间件产品与传统的 Tomcat、Weblogic 等中间件也存在差异。因此，企业应用需要进行相应的适配，以确保应用程序的正常运行和扩展性。
硬件适配：信创生态中的硬件产品与传统的 X86 服务器、存储等硬件也存在差异。因此，企业应用需要进行相应的适配，以确保在不同的硬件平台上正常运行。
FinClip 小程序技术发力信创操作系统
小程序技术非常适用于信创操作系统，具体可以体现桌面端使用场景
随着信创操作系统的不断发展和完善，越来越多的企业和用户开始将其作为桌面端操作系统的首选。在桌面端使用场景下，小程序技术具有以下优势：
提高用户体验：小程序技术可以让用户在桌面端轻松地使用各种应用程序，无需下载和安装，也不会占用太多的系统资源，从而提高了用户的使用体验。
降低开发成本：相对于传统的桌面应用程序，小程序的开发成本更低，因为它们可以利用现有的 Web 技术和框架进行开发，无需重新学习新的开发工具和技术。
提高安全性：小程序技术可以通过代码签名和加密等手段来保护应用程序的安全性，防止恶意代码的注入和篡改。
支持离线使用：小程序技术支持离线使用，用户可以在没有网络连接的情况下使用小程序，这对于一些需要在户外或没有网络的环境下使用的应用程序非常有用。
易于推广：小程序技术可以通过微信等社交媒体平台进行推广，这使得应用程序的推广变得更加容易。
凡泰极客旗下FinClip小程序容器技术，为了响应统信生态的推进、实行兼容式创新。。
FinClip是一个支持多终端运行小程序能力的前端容器技术，只需简单集成 「 FinClip SDK」,即可在 手机、Windows、Mac、Linux、统信、麒麟等平台下运行你的小程序，这意味着，移动端、PC 端、IOT等智能终端都能运行小程序了。同时，它还提供一个完善的后台管理系统，统一管理小程序的上架和下架、监测小程序的使用详情。
刚刚有提到，小程序非常适用于在桌面端使用，大家可以假设这么一个场景，过往一些在线文档小程序、预约小程序、打卡小程序、审批小程序只能在手机上进行操作，现在同样的在桌面端也能够实现，而且更好的方便使用者进行编辑，非常友好，如果将多数办公应用都替换成小程序，不仅无需安装，即用即走，还无需手动更新，因为小程序的特性就是支持热更新。
其次，FinClip 在安全逆向技术与安全防护技术方面都非常成熟。包括：非授权外部接入风险防范，FinClip SDK具备相应的保护机制，确保网络通信安全可靠；数据安全风险防范，避免用户敏感信息及业务相关数据泄漏；FinClip采取的加壳保护、代码混淆、反调试等安全加固措施，提高相关文件、业务通讯及加密协议被黑客或第三方平台攻击破解的难度。FinClip也获得多项安全认证，多重保障用户信息安全。
因此，小程序技术在信创操作系统中的应用前景非常广阔，可以为用户带来更加便捷、快速、安全和智能化的应用体验。开发者可以关注小程序技术在信创操作系统中的应用，积极探索新的应用场景和商业模式，为信创操作系统的发展和推广做出贡献。
同时，小程序技术在信创操作系统中的应用也面临着一些挑战和问题。例如，信创操作系统的生态环境相对较新，小程序技术在其中的适配和优化还需要进一步完善；信创操作系统的安全性和稳定性也需要进一步提高，以确保用户数据的安全和隐私。
为了应对这些挑战和问题，开发者可以从以下几个方面入手：
积极参与信创操作系统的生态建设，与其他开发者和厂商合作，共同推动小程序技术在信创操作系统中的适配和优化。
关注信创操作系统的安全性和稳定性，采用更加安全和可靠的开发技术和框架，确保用户数据的安全和隐私。
积极探索新的应用场景和商业模式，为信创操作系统的发展和推广提供更多的创新和价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac1f2f13cfeec4f6f776414f6d12d85/" rel="bookmark">
			FlashAttention计算过程梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FlashAttention 的速度优化原理是怎样的？
从 FlashAttention 到 PagedAttention, 如何进一步优化 Attention 性能
FlashAttention图解（如何加速Attention）
FlashAttention开源代码
Transformer Block运算量解析
在self-attention模块中，主要包含全连接层（通过矩阵乘法实现）、softmax（计算注意力权重），以及根据注意力权重的加权求和（计算注意力的输出结果）。其中，全连接层和根据注意力权重的加权求和其实都是通过矩阵乘法实现的，所以分块计算可以通过矩阵的分块乘法来实现。由于softmax的分母部分需要计算全局元素的求和，分块之后只能计算局部的和，导致softmax的分块计算变得复杂。
标准版softmax
s o f t m a x ( x ) = e x i ∑ e x j softmax(x)=\frac{e^{x_i} }{\sum e^{x_j}} softmax(x)=∑exj​exi​​
稳定版softmax
s o f t m a x ( x ) = e x i − m a x ( x ) ∑ e x j − m a x ( x ) softmax(x)=\frac{e^{x_i - max(x)} }{\sum e^{x_j - max(x)}} softmax(x)=∑exj​−max(x)exi​−max(x)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ac1f2f13cfeec4f6f776414f6d12d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c2d2bd6cb6c31c4ae5ca42d9a6b48b/" rel="bookmark">
			基于 Servlet 的博客系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Servlet 的博客系统 一、准备工作1、创建项目2、创建包3、导入前端静态页面 二、数据库设计1、blog（博客表）2、user（用户表）3、建库建表的 SQL 语句 三、封装数据库操作1、为什么要封装数据库？2、封装数据库的连接/关闭操作3、创建实体类4、封装必要的增删改查操作 四、前后端业务逻辑实现1、登录功能（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 2、检查用户登录（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 3、博客列表（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 4、博客列表页用户信息（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 5、博客详情页（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 6、博客详情页用户信息（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 7、发布博客（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 8、注销功能（1）约定前后端交互接口（2）编写后端代码（3）编写前端代码 五、总结 一、准备工作 1、创建项目 这里需要创建一个Maven项目，在 pom.xml 中引入项目的依赖文件（Servlet、Mysql、Jackson），并创建必要的目录结构：
2、创建包 为了使代码层次更加清晰，这里采用经典的Web项目设计结构——MVC：
M：model，表示和数据相关的部分。
V：view，表示和界面相关的部分。
C：controller，表示数据和界面之间的业务逻辑。
因此在后端业务逻辑方面，在Java目录下创建两个包，分别是 model，存放和数据相关的逻辑代码；controller，存放前后端交互的业务逻辑。对于博客的前端页面部分，可以在导入时，直接放到 webapp 目录下。
3、导入前端静态页面 二、数据库设计 对于当前博客系统的数据库设计相对比较简单，主要涉及到两个实体，分别是 博客 和 用户，它们之间的 ER 关系图如下以及各自的表结构如下所示：
1、blog（博客表） 列名数据类型描述blogIdINT博客ID（主键）titleVARCHAR博客标题contentVARCHAR博客内容userIdINT用户ID（外键）postTimeDATETIME发布时间 2、user（用户表） 列名数据类型描述userIdINT用户ID（主键）usernameVARCHAR用户名passwordVARCHAR密码 3、建库建表的 SQL 语句 create database if not exists blog_system charset utf8;; use blog_system; drop table if exists users; create table users ( userId int primary key auto_increment, username varchar(50) unique, password varchar(50) ); drop table if exists blogs; create table blogs ( blogId int primary key auto_increment, title varchar(32), content varchar(4096), postTime datetime, userId int, foreign key(userId) references users(userId) ); -- 为了方便后续调试，这里插入一些初始内容 insert into users values(null,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c2d2bd6cb6c31c4ae5ca42d9a6b48b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec033641c2268255f5a4ceadbad0a74/" rel="bookmark">
			算法-堆/归并排序-排序链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法-堆/归并排序-排序链表 1 题目概述 1.1 题目出处 https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-interview-150
1.2 题目描述 2 优先级队列构建大顶堆 2.1 思路 优先级队列构建小顶堆链表所有元素放入小顶堆依次取出堆顶元素，链表串起来即可 2.2 代码 class Solution { public ListNode sortList(ListNode head) { if (head == null) { return null; } PriorityQueue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;((n1,n2)-&gt;n1.val-n2.val); ListNode newHead = new ListNode(); while(null != head) { minHeap.add(head); head = head.next; } ListNode tmp = minHeap.poll(); tmp.next = null; newHead.next = tmp; while(minHeap.size()&gt;0) { ListNode cur = minHeap.poll(); tmp.next = cur; tmp = cur; tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec033641c2268255f5a4ceadbad0a74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22982e1a1dfdc1a9a9127470dcbbb5e/" rel="bookmark">
			面向桥隧施工工地的环境参数监测与通风控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘 要...................................................................................... 2
第一章 绪论........................................................................ 5
1.1 研究课题背景....................................................... 5
1.2 国内外发展概况................................................... 8
1.3 课题研究的目的................................................. 10
1.4 课题的研究内容及章节安排............................. 10
第二章 环境监测和通风控制系统的设计方案.................... 11
2.1 设计任务及要求................................................. 11
2.2 环境监测和通风控制系统总体设计方案......... 12
2.3 方案的论证与分析............................................. 13
第三章 系统硬件部分设计.............................................. 15
3.1 总体设计............................................................ 15
3.2 主控制器设计.................................................... 16
3.2.1 芯片介绍.................................................... 16
3.2.2 时钟电路设计............................................ 18
3.2.3 复位电路设计............................................ 19
3.3 显示模块............................................................ 20
3.3.1 LED显示................................................... 20
3.3.2 数码管显示................................................ 20
3.4 显示电路............................................................ 21
3.5 键盘输入电路.................................................... 21
第四章 环境监测和通风控制系统控制系统仿真设计.. 22
4.1 环境监测和通风控制系统控制系统仿真模型 22
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f22982e1a1dfdc1a9a9127470dcbbb5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717a50567c0932f9a085a7db67770a4d/" rel="bookmark">
			图神经网络：图的分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章说明：
1)参考资料：PYG的文档。文档超链。
2)博主水平不高，如有错误，还望批评指正。
3)我在百度网盘上传这篇文章的jupyter notebook以及有关文献。提取码8848。
文章目录 MUTAG数据集说明图分类的常见手段图分类的基本流程改进算法 MUTAG数据集说明 MUTAG数据集是一个分子图形数据集。每个分子包含一个二元标签表示该分子是否为一种类固醇化合物。我们的任务是进行一个二分类的任务，判断某个分子是否类固醇化合物。
导入依赖
from torch_geometric.datasets import TUDataset import torch 导入数据
dataset=TUDataset(root='C:/Users/19216/Desktop/project/Project1/Graph_Classification/TUDataset',name='MUTAG') 打乱顺序，训测拆分
dataset=dataset.shuffle() train_dataset=dataset[:150] test_dataset=dataset[150:] 我们下面观察数据
图分类的常见手段 为充分利用GPU资源，我们使用如上方式。1）创建一个包含多个孤立图的超巨型图，2）特征矩阵简单连接。如上。优点如下：1）不同图间不会进行信息传递，2）稀疏矩阵保存不会占用内存。
导入依赖
from torch_geometric.loader import DataLoader 观察数据
train_loader=DataLoader(train_dataset,batch_size=64,shuffle=True) test_loader=DataLoader(test_dataset,batch_size=64,shuffle=False) for step,data in enumerate(train_loader): print(f'Step {step + 1}:') print('=======') print(f'Number of graphs in the current batch: {data.num_graphs}') print(data) print() #输出如下： #Step 1: #======= #Number of graphs in the current batch: 64 #DataBatch(edge_index=[2, 2626], x=[1187, 7], edge_attr=[2626, 4], y=[64], batch=[1187], ptr=[65]) #Step 2: #======= #Number of graphs in the current batch: 64 #DataBatch(edge_index=[2, 2448], x=[1107, 7], edge_attr=[2448, 4], y=[64], batch=[1107], ptr=[65]) #Step 3: #======= #Number of graphs in the current batch: 22 #DataBatch(edge_index=[2, 978], x=[441, 7], edge_attr=[978, 4], y=[22], batch=[441], ptr=[23]) 图分类的基本流程 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/717a50567c0932f9a085a7db67770a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dffaa871d942c9afc3793e17d364287c/" rel="bookmark">
			图神经网络：(节点分类)Cora数据集实现图神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章说明：
1)参考资料：PYG的文档。文档超链。
2)博主水平不高，如有错误，还望批评指正。
3)我在百度网盘上传这篇文章的jupyter notebook以及有关文献。提取码8488。
文章目录 代码实操1：GCN的复杂实现代码实操2：GCN的简单实现代码实操3：GAT的简单实现 代码实操1：GCN的复杂实现 导入绘图的库，定义绘图函数。
from sklearn.manifold import TSNE import matplotlib.pyplot as plt def visualize(h,color): z=TSNE(n_components=2).fit_transform(h.detach().cpu().numpy()) plt.figure(figsize=(10,10)) plt.xticks([]) plt.yticks([]) plt.scatter(z[:,0],z[:,1],s=70,c=color,cmap="Set2") plt.show() 目前，我并不知道TSNE降维理论。所以，暂时把它当作一种降维技术应该够了。
导入依赖，导入数据，导入依赖。
from torch_geometric.transforms import NormalizeFeatures from torch_geometric.datasets import Planetoid dataset=Planetoid(root='C:/Users/19216/Desktop/project/Project1/Node_Classification2/Planetoid',name='Cora',transform=NormalizeFeatures()) data=dataset[0] #确定具体的图 Cora数据集简单说明：特征矩阵的 s h a p e shape shape为 N × M N \times M N×M， N N N表示为论文数量， M M M表示为特征维度，对于每维，如果单词在论文中，就是1反之就是0。邻接矩阵的 s h a p e shape shape为 N × N N \times N N×N， N N N表示为论文数量，论文之间存在引用，那么就会有一条边。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dffaa871d942c9afc3793e17d364287c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54244f06b25c437a4d671f957a7bca36/" rel="bookmark">
			Bootstrap Collapse的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、效果图：
2、当点击B或C时，A自动收缩：
3、html代码：
&lt;div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true"&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading" role="tab" id="headingOne"&gt; &lt;h4 class="panel-title"&gt; &lt;a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="true" aria-controls="collapseOne"&gt; A &lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div id="collapseOne" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="headingOne"&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item"&gt;1&lt;/li&gt; &lt;li class="list-group-item"&gt;2&lt;/li&gt; &lt;li class="list-group-item"&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading" role="tab" id="headingTwo"&gt; &lt;h4 class="panel-title"&gt; &lt;a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"&gt; B &lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54244f06b25c437a4d671f957a7bca36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8935a3c51ecdccc0c1658332041c48/" rel="bookmark">
			CSS中写三元运算符判断设置样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以用来动态设置style
&lt;el-icon :style="{'cursor' : (scope.row.hik_no &amp;&amp; scope.row.hik_status === 1 ? 'pointer' : 'not-allowed'), 'color': (scope.row.hik_no &amp;&amp; scope.row.hik_status === 1 ? '#409EFC' : '#A8ABB2'), 'border': '1px solid lightgray', 'margin-right': '8px', 'padding': '3px'}"&gt; &lt;HelpFilled /&gt; &lt;/el-icon&gt; 这里用一个el-icon来设置样式
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/48/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>