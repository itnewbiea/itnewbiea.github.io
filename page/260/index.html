<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d3905385a8e1e0a67c74e2cf10230c0/" rel="bookmark">
			签名验签自助排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		签名验签自助排查 支付宝开放平台SDK封装了签名和验签过程，只需配置账号及密钥参数，强烈建议使用。 SDK下载地址 TIPS：文中代码部分以JAVA语言演示，其他语言请参考各自SDK。 使用开放平台SDK接入 如果使用了开放平台SDK，签名验签问题通常是因为密钥配置错误导致。 配置代码示例，问题描述中会以示例中的变量名为例： AlipayClient alipayClient = new DefaultAlipayClient(gateway,app_id,private_key,"json",charset,alipay_public_key,sign_type); 签名问题 Q:SDK抛出异常：“com.alipay.api.AlipayApiException: RSA私钥格式不正确，请检查是否正确配置了PKCS8格式的私钥”。 A:代码中私钥(private_key)格式错误导致。1&gt;.检查格式是否正确。Java需使用PKCS8格式，其他语言使用PKCS1格式。 2&gt;.检查私钥是否一行。 Q:请求时，SDK抛出异常：“java.lang.NullPointerException: privateKey should not be NULL!”。 A:代码中私钥(private_key)参数未赋值导致。请把商户应用私钥赋值给该参数。 Q:请求时，SDK抛出异常：“java.security.NoSuchAlgorithmException: MD5 KeyFactory not available”。 A:代码中签名类型(sign_type)设置错误导致。开放平台接口需设置成RSA。 Q:请求时，支付宝返回报错信息：“{"code":"40003","msg":"Insufficient Conditions","sub_code":"isv.missing-signature-config","sub_msg":"验签出错, 未配置对应签名算法的公钥或者证书"}” A:开放平台未配置商户公钥导致。请登录开放平台，上传公钥。教程 Q:请求时，支付宝返回报错信息：“{"code":"40002","msg":"Invalid Arguments","sub_code":"isv.invalid-signature","sub_msg":"无效签名"}” A:签名校验失败。1&gt;.检查网关地址(gateway)是生产环境还是沙箱环境，必须使用与之匹配的应用id(app_id)与私钥(private_key) 2&gt;.检查编码类型(charset)是否正确。 3&gt;.检查私钥(private_key)与开放平台上传的应用公钥是否匹配。 4&gt;.检查签名类型(sign_type)值是否正确。如果未传入sign_type参数，默认为RSA类型。 验签问题 Q:SDK抛出异常：“java.lang.NullPointerException: alipayPublicKey should not be NULL!”。 A:代码中支付宝公钥(alipay_public_key)参数未赋值导致。请把支付宝公钥赋值给该参数。教程 Q:SDK抛出异常：“java.security.InvalidKeyException” A:代码中支付宝公钥(alipay_public_key)参数内容错误导致。请核对。 Q:SDK抛出异常：“com.alipay.api.AlipayApiException: sign check fail: check Sign and Data Fail!” A:支付宝返回内容验签失败。1&gt;.检查网关地址(gateway)是生产环境还是沙箱环境，必须使用与之匹配的应用id(app_id)与支付宝公钥(alipay_public_key) 2&gt;.检查编码类型(charset)是否正确。 3&gt;.检查代码中支付宝公钥(alipay_public_key)参数与开放平台上获取的支付宝公钥是否一致。 Q:SDK抛出异常：“Caused by: java.security.SignatureException: Signature length not correct: got 256 but was expecting 128” A:支付宝公钥(alipay_public_key)与签名类型(sign_type)不匹配。Sign_type设置为RSA2，alipay_public_key需使用对应的支付宝公钥，不能使用开放平台RSA类型下的支付宝公钥。 Q:SDK抛出异常：“Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d3905385a8e1e0a67c74e2cf10230c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616ec435ee2358af0fd8afb5b6e5f195/" rel="bookmark">
			Apache日志记录组件Log4j出现反序列化漏洞 黑客可以执行任意代码 所有2.x版本均受影响...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源的东西用的人多了，自然漏洞就多。Apache用于日志记录的组件Log4j使用非常灵活，在相当多的开源项目中都有使用，此次漏洞影响所有Apache Log4j 2.*系列版本： Apache Log4j 2.0-alpha1 – Apache Log4j 2.8.1，使用Java 7+的用户应立即升级至2.8.2版本。绿盟科技发布安全威胁通告，通告全文如下：
Apache Log4j是什么 Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。
绿盟科技《 Apache Log4j反序列化漏洞安全威胁通告 》 通告全文如下
北京时间18日清晨，Apache Log4j 被曝出存在一个反序列化漏洞(CVE-2017-5645)。攻击者可以通过发送一个特别制作的2进制payload，在组件将字节反序列化为对象时，触发并执行构造的payload代码。该漏洞主要是由于在处理ObjectInputStream时，接收器对于不可靠来源的input没有过滤。可以通过给TcpSocketServer和UdpSocketServer添加可配置的过滤功能以及一些相关设置，可以有效的解决该漏洞。目前Log4j官方已经发布新版本修复了该漏洞。
相关地址：
http://cve.mitre.org/cgi-bin/cvename.cgi?name=%09CVE-2017-5645
https://issues.apache.org/jira/browse/LOG4J2-1863
http://seclists.org/oss-sec/2017/q2/78
影响范围 受影响的版本
所有Apache Log4j 2.*系列版本： Apache Log4j 2.0-alpha1 – Apache Log4j 2.8.1
不受影响的版本： Apache Log4j 2.8.2
规避方案 使用Java 7+的用户应立即升级至2.8.2版本或者避免使用socket server的相关类。参考链接： https://issues.apache.org/jira/browse/LOG4J2/fixforversion/12339750/?selectedTab=com.atlassian.jira.jira-projects-plugin:version-summary-panel
使用Java 6的用户应该避免使用TCP或者UDP 的socket server相关类，用户也可以手动添加2.8.2版本更新的相关代码来解决该漏洞。 参考链接：
https://git-wip-us.apache.org/repos/asf?p=logging-log4j2.git;h=5dcc192 绿盟科技声明 本安全公告仅用来描述可能存在的安全问题，绿盟科技不为此安全公告提供任何保证或承诺。由于传播、利用此安全公告所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，绿盟科技以及安全公告作者不为此承担任何责任。绿盟科技拥有对此安全公告的修改和解释权。如欲转载或传播此安全公告，必须保证此安全公告的完整性，包括版权声明等全部内容。未经绿盟科技允许，不得任意修改或者增减此安全公告内容，不得以任何方式将其用于商业目的。
原文发布时间：2017年4月18日
本文由：绿盟科技发布，版权归属于原作者
原文链接:http://toutiao.secjia.com/apache-log4j-deserialization-vulnerabilities-cve-2017-5645
本文来自云栖社区合作伙伴安全加，了解相关信息可以关注安全加网站
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e963edb4912425218d04cbfa8423bedc/" rel="bookmark">
			input文本框不可编辑的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		input文本框不可编辑的3种方法 1.disabled disabled属性规定应该禁用 input 元素。
被禁用的 input 元素既不可用，也不可点击。可以设置 disabled 属性，直到满足某些其他的条件为止（比如选择了一个复选框等等）。然后，就需要通过 JavaScript 来删除 disabled 值，将 input 元素的值切换为可用。
注释：disabled 属性无法与 &lt;input type="hidden"&gt; 一起使用
2.readonly readonly 属性规定输入字段为只读。
只读字段是不能修改的。不过，用户仍然可以使用 tab 键切换到该字段，还可以选中或拷贝其文本。
readonly 属性可以防止用户对值进行修改，直到满足某些条件为止（比如选中了一个复选框）。然后，需要使用 JavaScript 消除 readonly 值，将输入字段切换到可编辑状态。
readonly 属性可与 &lt;input type="text"&gt; 或 &lt;input type="password"&gt; 配合使用。
3.unselectable readonly unselectable="on" 该属性跟disable类似，input 元素，不可编辑，不可复制，不可选择，不能接收焦点，设置后文字的颜色也会变成灰色，但是后台可以接收到传值。 示例：&lt;input type="text" readonly unselectable="on" &gt;
注意：
在IE下给DIV设置unselectable与onselectstart属性，可以让div的内容不能选中，但是有bug
&lt;div&gt;普通DIV&lt;div&gt; &lt;div unselectable="on" onselectstart="return false;"&gt;从前面一个DIV开始选，就可以选中本部分内容，只有从该DIV结束部分才能不选中&lt;/div&gt; 要么在body里用onselectstart="return false;"，但是那会导致整个页面都无法选中；或者在所有div或者类似DIV的容器里都要设置onselectstart="return false;"，才能彻底解决。
Firefox下的解决方案： style="-moz-user-select:none;" Chrome下的解决方案：
style="-webkit-user-select:none;"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c0bb90fb559d9d31a2f917a4ce45b4/" rel="bookmark">
			51 Job招聘数据分析与可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 招聘数据分析与可视化 背景 为了分析现有数据行业的招聘情况，抓取2017年3月14日到2017年5月13日发布在51Job上的数据相关招聘职位116273条信息，并从中筛选出职位是数据分析、数据挖掘、文本挖掘、视觉学习、计算广告、数据开发、数据架构师等的数据岗位招聘信息10134条。 从地域分布、企业情况、岗位需求、薪酬等维度去量化分析数据岗位的招聘现状。发现不同薪酬分层下的岗位数量基本与城市发展趋势、行业汇聚、人才聚集呈现正比。 地域分布上，大数据的发展，当前最活跃于发达的一线城市以及沿海地区，但是二线城市中杭州、南京、成都、武汉也是可以选择的。 企业情况上，行业主要集中在电子商务、金融、IT软件等轻资产企业，同时，零售、电信也具有一定需求；企业属性主要是民企、合资企业和上市公司三大类，民营企业占据半边天；企业规模上，数据岗位只有在一定规模的企业，才能凸显重要性，50~500人之间的企业成为主要的岗位提供者。 选择企业行业、企业性质、企业规模、工作地域、学历、技能（r，sas、python、hadoop、spark、excel、java、sql、hive、hbase），其中技能做二值化处理进行模型构建。使用SAS EM进行建模，利用树代替对数值和属性变量进行补缺，最优转换进行变量转换，比较Logistc回归、神经网络、随机森林、梯度Boosting和决策树。
数据抽取 爬虫获取 结构化存储 可视化 可视化地址：https://data2miner.shinyapps.io/data_job_analysis/ 地域分布 技能VS薪酬 文本分析 模型构建 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6452be5bfb88fc34f378e45300f98b04/" rel="bookmark">
			elasticsearch 5.x删除index/type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 elasticsearch 5.x删除index:
在head插件中执行： DELETE ip:port/index 看到 acknowledge{ " true" } 即为成功 elasticsearch 5.x删除type: 在kibana界面,dev tools中： POST ip：potrt/index/type/_delete_by_query?conflicts=proceed { "query": { "match_all": {} } } 个人经验，有其他可行方法可回复讨论 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf0e1f6d5e6baa24cedf2a76503d7c4/" rel="bookmark">
			String截取一段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.若知道要从第几个位置开始截取，可以直接选用substring()方法
2.若不知道要从哪边开始截取，但是知道String中要从哪段开始，只是要中间一段字符串 如：
String str = "age=20&amp;address=sz&amp;name=mason"; int begin = str.indexOf("address="); int end = str.indexOf("&amp;name"); System.out.println(str.substring(begin, end)); result:address=sz
3.若是只要”sz”两个字 如：
String str = "age=20&amp;address=sz&amp;name=mason"; String[] begin = str.split("address="); System.out.println(begin[1].split("&amp;name")[0]); result:sz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60145e6550ab0de08caf8084ec1882b6/" rel="bookmark">
			将博客搬至简书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本人现将所有博客搬至简书平台； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96a93d725d1764e3564c9afd4fef20c/" rel="bookmark">
			安装Oracle时，shmall、shmmax、kernel.sem的设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为拿到一个好配置的生产机器。在装完数据库后，需要对参数进行调优。 首先这个机器内存是128G的 ，而且/dev/shm 设置的是63G （物理内存的一半）。Oracle设置用的是AMM管理，那么就想是否能把这个内存设置大点。
首先这个参数文件在 vi /etc/sysctl.conf 里，重新加载生效是 sysctl -p
# System default settings live in /usr/lib/sysctl.d/00-system.conf. # To override those settings, enter new settings here, or in an /etc/sysctl.d/&lt;name&gt;.conf file # # For more information, see sysctl.conf(5) and sysctl.d(5). #ORACLE SETTING fs.aio-max-nr = 1048576 fs.file-max = 6815744 kernel.shmall = 15728640 kernel.shmmax = 64424509440 kernel.shmmni = 4096 kernel.sem = 5010 641280 5010 128 net.ipv4.ip_local_port_range = 9000 65500 net.core.rmem_default = 262144 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96a93d725d1764e3564c9afd4fef20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c630b7da819ec860cbe80fa5b163f958/" rel="bookmark">
			for(let i = 0; i &lt; 10; i&#43;&#43;)和for(var i = 0; i &lt; 10; i&#43;&#43;)的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let、 var、 setTimeout，一点思考。 for(var i = 0; i &lt; 10; i++){ setTimeout(function(){ console.log(i); },100); } 结果是很显而易见的，10次都是10，在面试前端的闭包知识时候很常见。 用上let之后，
for(let i = 0; i &lt; 10; i++){ setTimeout(function(){ console.log(i); },100); } 结果是： 0、1、2、3、4、5、6、7、8、9
为什么var和let声明的i，得到不同的结果？
var声明的i，作用域不仅仅在for循环内，还在for循环的外部。
当setTimeout执行的时候，for循环已经完成，i此时的值是10，我们稍微调整一下代码：
for(var i = 0; i &lt; 10; i++){ setTimeout(function(){ consoleLog(); },100); } function consoleLog(){ console.log(i); } 结果是10次10。
for(var i = 0; i &lt; 10; i++) 和
var i; for(i = 0; i &lt; 10; i++) 等价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c630b7da819ec860cbe80fa5b163f958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00214e61fd28a7041d6ec55ba3ea911/" rel="bookmark">
			adb 抓取ANR日志和普通日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//确保连接设备
adb devices
//root权限
adb root
//抓日志
adb pull /data/anr D:\anr
其中traces文件就是anr日志文件
但是正常的手机是未root的,那么应该如何获取呢?
第一步:adb bugreport
这时就会在android studio的Device File Explorer的bugreports目录下也可以看到,如下图:
将其保存到电脑桌面,解压如下图:
其中bugrepo....txt文件,如果LogCat中关于anr的信息不见了，不用慌，我们可以在这个txt文件中看到和Logcat中类似的anr信息，因为这个文件比较长，可以搜索anr in关键词
其次是FS-&gt;data-&gt;anr文件,打开对应时间的,搜对应自己的包名,可以查到:
根据图中可以看到SessionFragment调用了Thread.sleep方法
信息解释如下:(注意值不对应)
线程名：main
线程优先级：prio=5
线程ID： tid=1
线程状态：Sleeping
线程组名称：group="main"
线程被挂起的次数：sCount=1
线程被调试器挂起的次数：dsCount=0
线程的java的对象地址：obj= 0x7682ab30
线程本身的Native对象地址：self=0x7bd3815c00
线程调度信息：
Linux系统中内核线程ID: sysTid=6317与主线程的进程号相同
线程调度优先级：nice=-10
线程调度组：cgrp=default
线程调度策略和优先级：sched=0/0
线程处理函数地址：handle= 0x7c59fc8548
线程的上下文信息：
线程调度状态：state=S
线程在CPU中的执行时间、线程等待时间、线程执行的时间片长度：schedstat=(1009468742 32888019 224)
线程在用户态中的调度时间值：utm=91
线程在内核态中的调度时间值：stm=9
最后执行这个线程的CPU核序号：core=4
线程的堆栈信息：
堆栈地址和大小：stack=0x7ff27e1000-0x7ff27e3000 stackSize=8MB
普通日志抓取:
//e表示error的信息
adb logcat *:e &gt;d:/log.txt
回车开始抓取
ctrl+c 结束结束打印
全部龙信息
adb shell logcat &gt; F:\log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00214e61fd28a7041d6ec55ba3ea911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c427adc5474655984e40a986852ca7c9/" rel="bookmark">
			html中设置table的各个td的宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html中设置table的各个td的宽度方法：
&lt;html&gt; &lt;body&gt; &lt;table border="1" width="100%"&gt; &lt;!-- &lt;tr&gt; &lt;td width="70%"&gt;January&lt;/td&gt; &lt;td width="30%"&gt;$100&lt;/td&gt; &lt;/tr&gt; --&gt; &lt;!-- 在 HTML 4.01 中，不赞成使用 td 元素的 width 属性；在 XHTML 1.0 Strict DTD 中，不支持 td 元素的 width 属性。所以用下面的CSS样式代替。 --&gt; &lt;tr&gt; &lt;td style="width:70%"&gt;January&lt;/td&gt; &lt;td style="width:30%"&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2d717452a0202b974dd7a9f0126c74/" rel="bookmark">
			Hive 实现脱敏以及ETL 过程（开启kerberos）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 业务场景及实现原理： 源数据存储在Hbase中，需要将源数据中敏感部分（如身份证、电话号码等）进行脱敏再供用户使用。只需要脱敏少量数据供页面呈现便可（这个呈现主要是给用户看样例数据，便于用户确定是否需要订阅资料）。为了防止请求被非法模仿，因而编写了一个访问Ip 鉴权类，也就是设置了访问ip白名单，只有在白名单上的ip才可以访问接口。具体实现见如下链接：
http://blog.csdn.net/u013850277/article/details/77900765 注：运用该方法脱敏后的数据将存在Hive中而不是Hbase中。 实现原理：
通过 自定义Hive 函数，然后运用自定义函数结合Hive sql 对Hive 数据进行脱敏并入到脱敏库（这里的脱敏库与贴源库保存在同一个集群上）
本人为了方便部署与对外提供接口采用的是Spring boot 方式来部署
二. 执行过程简述 创建Hive 自定义函数
原先脱敏备份的表若存在则将其删除掉
如果存在该脱敏表则重命名备份
执行ETL及脱敏过程
创建表及脱敏成功则将备份表删除掉
测试：一百万条数据完成上述步骤用时1分钟之内；集群机器节点数量为3，内存分别为16G
三. 功能部署成功后的访问接口 请求URL： http://localhost:8003/hive_data_sensitive?tableName=sensitive.t_person_sen&amp;sourceDataTable=admin.t_person1&amp;param=name_0,address_2,sex_1,birthday_3,idcards_4 注：如果源数据表有字段不想出现在脱敏后的表中，则可以不拼接到请求参数中。
请求方式： ​ GET
请求参数：
| 参数名 | 必选 | 说明 |
| --------------- | :–: | :--------------------------------------: |
| tableName | 是 | 脱敏后的表名，eg:sensitive.t_person_sen 其中 sensitive脱敏库，t_person_sen为脱敏后的表名 |
| sourceDataTable | 是 | 源数据，eg: admin.t_person1,admin为脱敏源库，t_person1为源数据 |
| param | 是 | 脱敏参数，字段及其脱敏规则，多个用英文符逗号分割，eg：name_0,address_2,sex_1,birthday_3,idcards_4 | 脱敏规则说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2d717452a0202b974dd7a9f0126c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5913a51a2540b088d03b38ad74713b5/" rel="bookmark">
			c# Win Form程序调用Web API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于在winform中调用webapi 在Win Form中可以使用WebClient、HttpWebRequest、HttpClient中的一个类来调用Web API。由于我自己用的是VS2010，最高只有 .Net FrameWork 4.0，而HttpClient是 .Net FrameWork 4.5里的，所以这里只介绍WebClient和HttpWebRequest的用法。
1、WebClient 初始化一个WebClient类的对象，然后设置client对象的Headers（我这里使用的是json格式的字符串传参，并且编码是utf-8格式的）的Content-Type，最后调用client的UploadString()方法（我这里是要给服务器传入数据并获取返回是否成功，所以调用此方法，各位可根据不同需求调用此类的其他方法），传入url（WebAPI地址）、“Post”（指定改WebAPI是post还是get请求）、sendData（传给WebAPI的数据，此处为json格式的字符串）。以下是使用的代码：
public string RequestWebAPI(string sendData, string url) { try { string backMsg = ""; WebClient client = new WebClient(); client.Headers.Add("Content-Type", "application/json;charset=utf-8"); backMsg = client.UploadString(url, "POST", sendData); return backMsg; } catch (Exception ex) { return ex.Message; } } 2、HttpWebRequest 初始化HttpWebRequest对象，由于HttpWebRequest类无法通过new创建，需要使用WebRequest.Create(url)方法初始化（url为WebAPI地址），而后通过设置属性Method指定请求是Post还是get，属性ContentType设置传入的参数格式（此处为utf-8编码的json格式字符串）。将要传入的数据（即json格式字符串sendData）转换为byte字节数组，而后通过请求流写入存于缓冲区的byte字节数组数据。然后获取响应流对象，此处从响应流读取数据有两种方法，一种是通过将响应流中的数据读取到byte字节数组，而后转换为字符串；另一种是通过初始化StreamReader类对象读取，以下为使用代码：
public string RequestWebAPI(string sendData, string url) { try { string backMsg = ""; HttpWebRequest httpRquest = (HttpWebRequest)WebRequest.Create(url); httpRquest.Method = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5913a51a2540b088d03b38ad74713b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658657e07e634185c416c46b9ca2cb51/" rel="bookmark">
			selenium启动Firefox示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文示例使用selenium启动Firefox，并将浏览器窗口最大化，在百度搜索框内输入“HelloWorld”，最后点击搜索按钮。
源代码如下：
package com.selenium.test; import java.util.concurrent.TimeUnit; import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; public class testGome { public static void main(String[] args) { //如果火狐浏览器没有默认安装在C盘，需要制定其路径 //System.setProperty("webdriver.firefox.bin", "D:/Program Files (x86)/Mozilla Firefox/firefox.exe"); System.setProperty("webdriver.firefox.marionette","C:\\Program Files (x86)\\Mozilla Firefox\\geckodriver.exe"); //WebDriver driver=new FirefoxDriver(); C:\Program Files (x86)\Mozilla Firefox //定义驱动对象为 FirefoxDriver 对象 WebDriver driver = new FirefoxDriver(); //驱动的网址 driver.get("https://www.baidu.com/"); //浏览器窗口变大 driver.manage().window().maximize(); //定位输入框元素 WebElement txtbox = driver.findElement(By.name("wd")); //在输入框输入文本 txtbox.sendKeys("HelloWorld"); //定位按钮元素 WebElement btn = driver.findElement(By.id("su")); //点击按钮 btn.click(); //关闭驱动 driver.close(); } } 注意：可能会遇到一些报错 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658657e07e634185c416c46b9ca2cb51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3806ec459ec8dabb614971d9a3b812/" rel="bookmark">
			Loadrunner 判断事务是否成功的几个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在LR 中往往需要关联response中的值来判断请求是否发送成功，可以使用以下几种方法： 1、判断关联到的字符串是否为空，
if (strlen(lr_eval_string("{param}")) == 0); 2、判断关联的字符串是否跟期望的值相同，
if(strcmp(lr_eval_string("{param}"), "expected") == 0); 3、判断关联的字符数组count是否为0，这种情况适合 ORD=ALL 的关联方式，
if(atoi(lr_eval_string("{param_count}")) == 0); 4、根据返回的响应码是不是200，
int retCode = web_get_int_property(HTTP_INFO_RETURN_CODE); if(intelligentDeposit_retCode == 200) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac7ea01dc49ff32d501d54c5ff2caf4/" rel="bookmark">
			七大查找常见算法（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线性索引查找 1.1 简介 前面讲的几种比较高效的查找方法是基于有序的基础之上的（详见七大查找常见算法（上）），而事实上，数据集可能增长非常快，例如，某些微博网站或大型论坛的帖子和回复总数每天都是成百万上千万条，或者一些服务器的日志信息记录也可能是海量数据，要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据都是按先后顺序存储的。 对于这样的查找表，我们如何能够快速查找到需要的数据呢？常常使用的方法就是—-索引。索引是为了加快查找速度而设计的一种数据结构。它是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。 索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三个线性索引：稠密索引、分块索引、和倒排索引。 1.2 稠密索引 稠密索引如下图所示，它是指在线性索引中，将数据集中的每个记录对应一个索引项。 上图中，左边的图像为索引序列，它是是按照关键码有序排列的。索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高效率。比如查找上表中的18。如果不用索引表，需要6次。而用左侧的索引表，折半两次就可以找到18对应的指针。 这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。 1.3 分块索引 稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 分块有序，是把数据集的记录分成若干块，并且这些块需要满足两个条件： （1）块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间代价，因此通常我们不要求块内有序 （2）块间有序，例如要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字….因为只有块间有序，才有可能在查找时带来效率。 对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。我们定义的分块索引项由三个数据项组成，如下图所示： 这三个数据项分别为最大关键码（它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中最小关键字也能比这一块最大的关键字要大）、存储了块中的记录个数（以便于循环时使用）和指向块首数据元素的指针（便于开始对这一块中的记录进行遍历）。 由上面的分析我们可以大概明白分块索引的步骤： （1）在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。 （2） 根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查获。 1.4 倒排索引 不知道你对搜索引擎好奇过没，无论你查找什么样的信息，它都可以在极短的时间内给你一些结果，是什么算法技术达到这样的高效查找呢？这里介绍一种最基础的搜索技术—-倒排索引。 我们来看一个例子，假设有以下两篇文章： (1) Books and friends should be few but good . (2) A good book is a good friend. 假设我们忽略掉如“books”，“friends”中的复数”s”以及如“A”这样的大小写差异。我们可以整理出这样一张单词表，如下图所示，并将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中，比如“good”它在两篇文章中都有出现，而is只有在文章2中才有。 在这里这张单词表就是索引表，索引项的通用结构是次关键码和记录号表。 其中记录号表存储具有相同次字关键字的所有记录的记录号（可以指向记录的指针或者是该记录的主关键字）。因为这种查找方法是通过属性值来确定记录的位置，而不是通过记录来确定属性值，所以我们称其为倒排索引。
二、树表查找 2.1 二叉树查找算法（最简单的树表查找算法） 如果要查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、斐波那契等查找算法来实现，可惜的是，因为有序，在插入和删除操作上就需要耗费大量的时间。有没有一种既可以使得插入和删除效率不错，又可以比较高效的实现查找的算法？这是有的，二叉树查找算法就可以实现这样的功能。 它的基本思想为：二叉查找树是先对待查找的数据生成其对应的树，其中树的左分支的值小于右分支的值，然后在所查数据和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 它的性质为：（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；（2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；（3）任意节点的左、右子树也分别为二叉查找树。同时，对二叉查找树进行中序遍历，即可得到有序的数列。 不同形态的二叉查找树如下图所示： 对它的时间复杂度进行分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。所以可以发现二叉查找树对于大多数情况下的查找和插入在效率上来说是没有问题的，但是它在最差的情况下效率比较低。而我们追求的是在最坏的情况下仍然有较好的时间复杂度，所以普通的二叉树查找算法还没有达到目的，这也就是为何设计平衡查找树的原因。 2.2 平衡查找树之2-3查找树 和二叉树不一样，2-3树中每个节点保存1个或者两个key值。对于普通的2节点(2-node)，它保存1个key和左右两个孩子（或没有孩子）。对应3节点(3-node)，保存两个Key和三个孩子（或没有孩子），2-3查找树的定义和性质如下： （1）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key有效，有节点也是一个2-3节点，所有的值比key要大。 （2）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。 （3）2-3树中所有的叶子都在同一层次上。 同样，如果中序遍历2-3查找树，就可以得到排好序的序列。2-3查找树可如下图所示： 复杂度分析： 2-3树的查找效率与树的高度是息息相关的。 （1）在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN。 （2）在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN。 2.3 平衡查找树之红黑树 2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。红黑树比一般的二叉查找树具有更好的平衡，所以查找起来更快。 基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。 红黑树的定义：红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：（1）红色节点向左倾斜；（2）一个节点不可能有两个红色链接；（3）整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。 下图可以看到红黑树其实是2-3树的另外一种表现形式，如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。 红黑树的性质：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。 复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。红黑树的平均高度大约为logn。红黑树是2-3查找树的一种实现，它能保证最坏情况下仍然具有对数的时间复杂度。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac7ea01dc49ff32d501d54c5ff2caf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3018664bf396c40ff745b75ba8e5bcd/" rel="bookmark">
			AccessibilityService有哪些缺陷？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 没办法捕捉所有点击事件
通过Onclick实现的点击事件，可以捕捉到通过onTouchEvent实现的的点击事件，捕捉不到 比如【淘宝首页】的搜索框按钮和【微信的添加好友】的搜索框按钮是通过onTouchEvent实现的，所以没办法点击事件 这个问题有办法解决吗？ 欢迎大牛指导下…
2. 获取不到界面数据以外的隐藏数据 比如当前列表的数据是第几条，intent传递的ID值多少 等等
3. 获取不到图片数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89f0017ce2dc6912a38b0a2155b9415/" rel="bookmark">
			android消息处理之messageQueue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.csdn.net/innost/article/details/47317823
在Andrid 2.3以前，只有Java世界的居民有资格向MessageQueue中添加消息以驱动Java世界的正常运转，但从Android 2.3开始，MessageQueue的核心部分下移至Native层，让Native世界的居民也能利用消息循环来处理他们所在世界的事情。因此现在的MessageQueue心系Native和Java两个世界。
2.3.1 MessageQueue的创建 现在来分析MessageQueue是如何跨界工作的，其代码如下：
[MessageQueue.java--&gt;MessageQueue.MessageQueue()]
MessageQueue() {
nativeInit();//构造函数调用nativeInit，该函数由Native层实现
}
nativeInit()方法的真正实现为android_os_MessageQueue_nativeInit()函数，其代码如下：
[android_os_MessageQueue.cpp--&gt;android_os_MessageQueue_nativeInit()]
static voidandroid_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {
// NativeMessageQueue是MessageQueue在Native层的代表
NativeMessageQueue* nativeMessageQueue = newNativeMessageQueue();
......
// 将这个NativeMessageQueue对象设置到Java层保存
android_os_MessageQueue_setNativeMessageQueue(env,obj,
nativeMessageQueue);
}
nativeInit函数在Native层创建了一个与MessageQueue对应的NativeMessageQueue对象，其构造函数如下：
[android_os_MessageQueue.cpp--&gt;NativeMessageQueue::NativeMessageQueue()]
NativeMessageQueue::NativeMessageQueue() {
/* 代表消息循环的Looper也在Native层中呈现身影了。根据消息驱动的知识，一个线程会有一个
Looper来循环处理消息队列中的消息。下面一行的调用就是取得保存在线程本地存储空间
（Thread Local Storage）中的Looper对象 */
mLooper= Looper::getForThread();
if (mLooper == NULL) {
/* 如为第一次进来，则该线程没有设置本地存储，所以须先创建一个Looper，然后再将其保存到
TLS中，这是很常见的一种以线程为单位的单例模式*/
mLooper = new Looper(false);
Looper::setForThread(mLooper);
}
}
Native的Looper是Native世界中参与消息循环的一位重要角色。虽然它的类名和Java层的Looper类一样，但此二者其实并无任何关系。这一点以后还将详细分析。
2.3.2 提取消息 当一切准备就绪后，Java层的消息循环处理，也就是Looper会在一个循环中提取并处理消息。消息的提取就是调用MessageQueue的next()方法。当消息队列为空时，next就会阻塞。MessageQueue同时支持Java层和Native层的事件，那么其next()方法该怎么实现呢？具体代码如下：
[MessagQueue.java--&gt;MessageQueue.next()]
final Message next() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89f0017ce2dc6912a38b0a2155b9415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4784f6a10911bac605049381b3e17534/" rel="bookmark">
			Android加密之文件级加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android加密之文件级加密 前置文章 《Android加密之全盘加密》
《Android系统之System Server大纲》
前言 Android 的安全性问题一直备受关注，Google 在 Android 系统的安全方面也是一直没有停止过更新，努力做到更加安全的手机移动操作系统。
在 Android 的安全性方面，有很多模块：
内核安全性应用安全性应用签名身份验证Trusty TEESELinux加密 等等 其中，加密又分全盘加密（Android 4.4 引入，《Android加密之全盘加密》）和文件级加密（Android 7.0 引入），本文将论述加密中的文件级加密的基本知识。
什么是文件级加密 Android 7.0 及更高版本支持文件级加密 (FBE)。采用文件级加密时，可以使用不同的密钥对不同的文件进行加密，并且可以对这些文件进行单独解密。
全盘加密和文件级加密的区别 借助文件级加密，Android 7.0 中引入了一项称为直接启动的新功能。该功能处于启用状态时，已加密设备在启动后将直接进入锁定屏幕。之前，在使用全盘加密 (FDE) 的已加密设备上，用户在访问任何数据之前都需要先提供凭据，从而导致手机无法执行除最基本操作之外的所有其他操作。例如，闹钟无法运行，无障碍服务不可用，手机无法接电话，而只能进行基本的紧急拨号操作。 文件级加密概述 引入文件级加密 (FBE) 和新 API 后，便可以将应用设为加密感知型应用，这样一来，它们将能够在受限环境中运行。这些应用将可以在用户提供凭据之前运行，同时系统仍能保护私密用户信息。
在启用了 FBE 的设备上，每位用户均有两个可供应用使用的存储位置：
凭据加密 (CE) 存储空间：这是默认存储位置，只有在用户解锁设备后才可用。设备加密 (DE) 存储空间：在直接启动模式期间以及用户解锁设备后均可用。 这种区分能够使工作资料更加安全，因为这样一来，加密不再只基于启动时密码，从而能够同时保护多位用户。
Direct Boot API 允许加密感知型应用访问上述每个区域。应用生命周期会发生一些变化，以便在用户的 CE 存储空间因用户在锁定屏幕上首次输入凭据而解锁时，或者在工作资料提供工作挑战时，通知应用。无论是否实现了 FBE，运行 Android 7.0 的设备都必须要支持这些新的 API 和生命周期。不过，如果没有 FBE，DE 和 CE 存储空间将始终处于解锁状态。 启用文件级加密 通过将不带参数的 fileencryption 标记添加到 userdata 分区最后一列的 fstab 行中，可以启用 FBE。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4784f6a10911bac605049381b3e17534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f037ae73548ce3c75abb3f0ab278a3/" rel="bookmark">
			就 3 点，提升工作效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要想提高工作效率，不论你看什么书，看什么文章，用什么工具，只有下面这三点最重要：
动力剖析自己，找到改善的切入点付诸行动并且坚持 目标驱动 有目标才能高效。
我们爬山，山顶就是目标，心怀山顶，在登顶之前，总是充满希望，纵有沟沟坎坎，也会克服困难，努力前行。
作为一个有追求的程序员，心中应该不只有一座山，更应该有一条绵延不断的山脉，千峰错落，峰峦叠起，终成峻岭。设立目标，付诸行动，不断攀登，是自我成就的不二法门。
放到日常工作中，就这么三点，就能让你与众不同：
每周一问自己：这周干什么，定下这周的目标每天早上问自己一个问题：今天干什么，定下今天的目标每天下班前花十分钟：今天完成了什么、有什么问题，记录下来 其实这是我从敏捷开发每日站会的三个问题延伸出来的。我的观点是，敏捷不只是做某一个项目时的模式和手段，而应当是一个有追求的程序员的贯穿始终的工作习惯。
从现在开始改变 抱歉，没有银弹，只有不起眼的小小经验谈。
作为软件开发工程师，在工作时需要高度集中注意力，动员所有神经来解决问题，最怕受到干扰。我正写代码写得HIGH呢，项目经理蹦过来问我进度怎么样，质管发邮件过来说过程检查不合格，测试MM说某个需求理解不了，有个无聊的网友在QQ发消息撩拨你晚上去幻影凶间，产品经理蹭到身边说不好意思兄弟需求又要改了……要知道保持速度与节奏很重要啊，我正突击呢你来这么一下子，看起来是几秒钟的事儿，可对程序员来讲，也许半天功夫就白费了，要想再找回断掉的思路，花费的时间可是那几秒钟的几十倍几百倍。
看看下面这张图：
“树欲静而风不止”。这是我们在开发过程中必须要面对的现实，各种各样的干扰会让我们的工作效率大打折扣。如果你有同感，往下看吧，包你不失望。
1）邮件的打扰
领导会要求你关注邮件，每隔多少分钟检查一下邮箱，最好安装一个邮箱客户端，设置一个自动检查新邮件。我原来也要求过部门的同事，现在想想这不大靠谱。关键的一点是：真正重要的事儿，真正紧急的事儿，不走邮件！所以，尽管关注邮件是必要的、必须要的，还是要给它设置一个限度。照下面这么做就好了：
每天早上扫一下邮件标题，把重要的、紧急的标记出来每天中午查看邮件，汇总重要的事儿 2）即时通信工具的打扰
这年头，人都忙着在网上社交了，很多精力和时间都贡献给网络上的虚拟圈子和对象了，其实，我要说的是，玩的是热闹也是寂寞，别上瘾为好。
看张图片：
这是我某个时刻的QQ通知截图，同时和十四个人聊天，有的人比我还多，同时聊三五十个，要是笔记本没有静音，“嘀嘀嘀嘀”之声就像农村河畔夜晚的蛙鸣，此起彼伏连绵不绝，真够让人忙活的，你要是每听到一声“嘀嘀”都看一下子，那完了，就算你开着Qt Creator /Eclipse/VS/Android Studio之类的IDE，也没时间切换过去敲代码了。这场景，基本上就变成聊天为主开发为辅，看来淘宝小二的工作更适合你了。
电脑上有QQ，手机上有手Q、微信、陌陌等，也是一会嘀一下、震一下，也许我们每天要看手机100次以上，重度手机依赖者在300次以上，看微信、看微博、各种通知、看短信、接电话、看时间、看天气、看养的宠物、把玩游戏、看小说、看漫画……尼玛，智能手机太富有侵略性了。假如你从口袋里掏出手机的次数远远大于别人给你打电话的次数，那你可能就存在过度关注的倾向，得注意了，阿猿，你又没那么多女盆友，不会错过晚上的约会的，担心个什么劲儿呢。
下面几招就可以让你摆脱或降低即时通信工具和手机对工作的干扰：
QQ，留给中午休息时间吧，或者下班前；关掉QQ，或者关掉消息提醒、设置提醒周期为很长很长；总之你别来烦我，我想你时去看看你。微信，关掉提示音吧，把那些个不咸不淡的群，都设置为消息免打扰。微博，关掉提示吧。手机，调整为震动或者静音。陌陌，办公室都是熟人，干掉它吧。智能手机上各种应用的通知，都使用安全软件禁止掉吧，或者设置通知的提醒模式，不要提醒断网，给手机断网，3G/4G/WIFI统统不要打开，看哪个软件还发通知 一句话：不要让手机和社交软件不停地通知你干扰你，你一个小时去查看一下状态即可。
3）张弛有度
工作一阵子（譬如45分钟、30分钟）就休息一下，有张有弛，活动下筋骨、站起来走走、活动脖子、腰、手，转转眼球看看远方，总之，一个人能集中注意力的时间长度是有限的，你要说你能连续高效工作四个小时，那我表示佩服。
为了能够张弛有度，程序员还需要做一些工作任务上的调整，把编码、设计、杀虫等工作的粒度细分，最好一个小任务能在几十分钟内完成，这样节奏就配合上了。
这方面有个著名的方法：番茄工作法。可以试试。
4） 提升开发效率的小贴士
程序员要写代码，这里有一些小贴士可供参考，也许能提高开发效率：
自测，每完成一个小功能都自测一下，看看这个功能自身是否正常，集成一下，看看有没有影响其他模块。开发人员的自测非常重要，编码期间频繁地测试、集成，会大大节省送测后回归的时间。一个小功能完成后，提交到svn或者github之类的代码托管平台上，免得宕机、停电、误修改造成重复工作，对心情产生恶劣影响，这种影响甚至比外来干扰还要大、持久。多与产品经理、需求人员沟通，完成一个功能就给他们看看，一方面是看是否是他们期待的，以便及时调整，另一方面是让他们对进度有所了解，降低他们因未知产生的焦虑，同时也能降低他们干扰你的频率。多与测试人员沟通，完成一个功能集就可以Build一个版本给他们看看，玩玩儿，让测试人员熟悉产品，建立对产品的直观感受，也给他们时间写用例。多与项目经理沟通，完成一部分功能，就可以给他们看看，让他们知道你在keep moving，也许他们也有一些想法，可以就此交流，免得什么都弄完了有人对结果不满意，要推倒重来，浪费时间。多与团队成员沟通，很多功能都是要相互协作的，让他们知道你前进到哪里了，和与你有工作衔接的同事约定联调时间，相互发布进度。如果不能在预期时间内联调，提前告知。多和UI及美工沟通，做出能看的东西就让他们看，看看是不是他们要的效果，免得到后面了返工浪费工作量。 知易行难 如果你发现自己的工作效率有待提高，并且拟定了一系列的措施，那就执行吧，坚持执行。想再多，落不到行动上，都是白瞎。
执行了，还要想办法度量效果。比如你觉得QQ影响你的开发效率，那就关掉它，坚持一周，看看有什么变化？要想度量效果也很简单，找一个时间跟踪软件，看看你每天花费在QQ聊天上的时间，花在开发工作上的时间，记录下来。然后在关闭QQ的情况下，再记录你花在开发上的时间。对比一下，在时间投入这个维度的结果就出来了。而工作成果这个维度，就看你自己如何度量了，比如通过工作量、完成的任务数等都可以。
总而言之，如果你觉得某个因素使你效率低下，那就制定策略，落实到行动上来，一定有效果。可惜的是有时我们明知那么做会有改善，可就是懒得动弹啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49ab2250ab77b07ac1d9543c68c666a/" rel="bookmark">
			STM32 定时器实现红外遥控数据接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理 1、红外发射协议 红外通信的协议有很多种。这个实验使用的是NEC协议。这个协议采用PWM的方法进行调制，利用脉冲宽度来表示 0 和 1 。
NEC 遥控指令的数据格式为：同步码头、地址码、地址反码、控制码、控制反码。同步码由一个 9ms 的低电平和一个 4.5ms 的高电平组成，地址码、地址反码、控制码、控制反码均是 8 位数据格式。按照低位在前，高位在后的顺序发送。采用反码是为了增加传输的可靠性。因此，每帧的数据为 32 位，包括地址码，地址反码，控制码，控制反码。反码可用于解码时进行校验比对。
NEC码的位定义：一个脉冲对应 560us 的连续载波，一个逻辑 1 传输需要 2.25ms（560us 脉冲+1680us 低电平），一个逻辑 0 的传输需要 1.125ms（560us 脉冲+560us 低电平）。而遥控接收头在收到脉冲的时候为低电平，在没有脉冲的时候为高电平，这样，在接收头端收到的信号为：逻辑 1 应该是 560us 低+1680us 高，逻辑 0 应该是 560us 低+560us 高。
​
红外数据的波形如下图：包括一个同步头和 32 帧数据。 下图可看出，同步头为 9ms 低电平加上 4.5ms 高电平，控制码为 8 个 0，控制反码为 8 个 1。 2、定时器计数 定时器就是按照一个特定的频率对计数值进行加一或减一操作，当数值溢出时则产生一个标志或中断。这里是用定时器计数产生一个周期性的中断。 3、实现方法 利用定时器记录两个下降沿之间的时间，通过该时间判断是否是同步头信息、数据 1 或者数据 0。当检测到同步头，开始记录 32 个数据的时间值。 二、实现 1、配置 GPIO 口下降沿触发中断 示例代码中使用 PA7 管脚，配置为上拉输入模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49ab2250ab77b07ac1d9543c68c666a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286a953de338adfce15176627cce0376/" rel="bookmark">
			我已经搬家啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有人问我为什么不更新了，其实我搬家啦
新家地址： http://kikitamap.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad65e5b31b7f47bfb8c894c77024255/" rel="bookmark">
			Numpy中的pad函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: Numpy中的pad函数
date: 2017-07-30 14:25:06
categories:
Numpy 填补一个数组。
pad（array，pad_width，mode，**kwars）
其中array为要填补的数组（input）
pad_width是在各维度的各个方向上想要填补的长度,如（（2，3），（4，5）），如果直接输入一个整数，则说明各个维度和各个方向所填补的长度都一样。
mode为填补类型，即怎样去填补，有“constant”，“edge”等模式，如果为constant模式，就得指定填补的值。
剩下的都是一些可选参数，先不说了。
返回值为填补好的ndarray。
例子：
&gt;&gt;&gt; a = [1, 2, 3, 4, 5] &gt;&gt;&gt; np.lib.pad(a, (2,3), 'constant', constant_values=(4, 6)) array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6]) &gt;&gt;&gt; a = [[1, 2], [3, 4]] &gt;&gt;&gt; np.lib.pad(a, ((3, 2), (2, 3)), 'minimum') array([[1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1], [3, 3, 3, 4, 3, 3, 3], [1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1]]) &gt;&gt;&gt; a = [[0,1, 2], [3, 4,5]] &gt;&gt;&gt; np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad65e5b31b7f47bfb8c894c77024255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc50614108c00415eac3c1f3616c75ec/" rel="bookmark">
			SAPUI5教程——安装Hybrid Application Tools失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 如果需要使用需要将Fiori打包成Hybrid移动应用，我们需要安装Hybrid Application tools.但是我们安装过程中会遇到这个问题。
对此我们知道是缺少某个包文件，比如fs-write-stream-atomic.
所以我们会执行 sudo npm install -g fs-write-stream-atomic. 进行全局安装，但是安装成功后，再次检查问题依然存在。
方案 检查你当前nodejs环境，是那个版本的，也就是说Hybird Application tools使用的是5.4.1的环境，但是你装全局包是在另一个环境比如6.0.1，这就导致你安装的文件不存在或找不到。 对此我们需要切换node环境，可以使用nvm use 5.4.1 这个命令。 如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998501bd3de05fcd01572a5d99446d0a/" rel="bookmark">
			python  AttributeError: module &#39;string&#39; has no attribute &#39;uppercase&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Traceback (most recent call last): File "Test1.py", line 8, in &lt;module&gt; upperletters = string.uppercase AttributeError: module 'string' has no attribute 'uppercase'
就用这个吧python3.0都能用
&gt;&gt;&gt; string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d89620bbfe616b1b3b7ce1e18f8f0efe/" rel="bookmark">
			三六、vue中使用animate.css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.npm install animate.css –save 2.main.js中引入 import animate from ‘animate.css’ Vue.use(animate) 3.页面中使用 &lt;style type="text/css"&gt; p { width: 300px; height: 300px; background: red; margin: 10px auto; } &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function(){ var app = new Vue({ el:'#box', data:{ show:false } }) } &lt;/script&gt; &lt;!-- 控制数据的值切换显示隐藏 --&gt; &lt;button @click="show=!show"&gt;transition&lt;/button&gt; &lt;!-- 第一种方法 --&gt; &lt;!-- &lt;transition enter-active-class="zoomInLeft" leave-active-class="zoomOutRight"&gt; &lt;p v-show="show" class="animated"&gt;&lt;/p&gt; &lt;/transition&gt; --&gt; &lt;!-- 第二种方法 --&gt; &lt;!-- &lt;transition enter-active-class="animated zoomInLeft" leave-active-class="animated zoomOutRight"&gt; &lt;p v-show="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d89620bbfe616b1b3b7ce1e18f8f0efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d30bfc4ad3898070387a5e79af90c84/" rel="bookmark">
			自组织映射网络SOMnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自组织映射网络ＳＯＭ 自组织特征映射神经网络(self organizing feature map)是一种无监督的学习算法，SOM的主要目的是将任意维度的输入信号通过计算映射转变为一维或者二维的离散映射，并且以自适应的方式实现这个过程． 自组织网络的输出层神经元之 间是互为竞争的关系，竞争成为被激活的神经元．在每一个时刻只有一个输出神经元被激活，被激活的神经元被称为获胜神经元(winning neuron).在输出层神经元中导出获胜神经元的竞争方法是：在输出层的神经元之间采用侧向连接．输出层神经元与输入层的节点之间为全连接． 侧向连接：在自组织映射网络中，输出层的神经元构成的是一个网格状的拓扑结构，网格的每一个交叉为一个神经元，网格通常是一维的或者二维的，也可以是更高维度的． 在竞争学习的过程中，神经元与输入层之间的连接的权值会随着输入模式(刺激)的变化选择性的进行调整，调整后的神经元(获胜神经元)的位置彼此之间变得有序．使得对于不同的输入，在网格上建立有意义的坐标系． 因此，在自组织映射网络的输出层神经元构成的网格中，每个神经元的空间位置(坐标）表示着一个输入模式包含的一个内在的统计特征．
Kononen模型 kohonen模型是一个基于计算映射的SOM网络模型，它抓住了人脑中计算映射的本质特征而且保留了计算的易行性．kohonen模型还可用于数据压缩(即：数据维度的缩减).　下面主要一kohonen模型为主介绍SOMnet.
自组织映射网络实现步骤 １．对网络权值进行初始化，选择较小的初始值． ２．竞争过程; 对每个输入信号，网络中的神经元计算他们各自的判别函数的值．判别值最大的特定神经元成为本次的获胜神经元． ３．合作过程; 获胜的神经元决定兴奋神经元的拓扑邻域(即：获胜神经元周围的空间位置内的神经元),提供相邻神经元的合作基础． ４．权值调节 通过对获胜神经元及其周围的兴奋神经元的权值进行调节，以增加它们对输入信号的判别函数值，随着权值的不断调整，获胜神经元对与相似的输入信号会有更强的响应(即：判别函数值越大).
竞争过程 假设网络中输入信号(数据)空间的维度数为 m ,从中随机选择一个输入信号(向量)记为x, x = [x1,x2,x3,.....xm]T
输出层中的每个神经元与输入层是全连接的结构，所以每个神经元的权值向量和输入空间的维数相同，神经元 j 的权值向量记为：wj
wj=[wj1,wj2,wj3,......wjm]T　j=1,2,3,4.....l 其中 l 是输出层网络中神经元的总数，竞争过程就是找到与向量x最佳匹配的权值向量 wj .最佳匹配的意思是：对于　j=1,2,3,4.....l ,比较每一个神经元对应的权值与输入向量 x 的内积 wTjx ，选择最大者，对应的神经元作为获胜神经元．(假设所有神经元的阈值相同，偏置为负)
对于匹配原则，内积 wTjx 最大化，这数学上可以等价于，向量 x 与 wj 的欧几里的距离最小． 很容易说明这一点：首先对向量 x 和 wj 进行归一化，即： ∥x∥ = ∥wj∥ = 1 向量 x与 wj 的欧几里得距离:
d2(x,wj)=(x−wj)T(x−wj)=2−2wTjx 上面的公式中，表明最小欧几里得距离 d2(x,wj) 就对应这最大化内积 wTjx ,欧几里得距离最小也意味着向量 x 与权值向量 wj 的相似度越高．所以最佳匹配原则也就是找到和输入向量最相似的权值向量． 用索引 i(x) 来标识与输入向量 x 最佳匹配的神经元， i(x) 的定义为:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d30bfc4ad3898070387a5e79af90c84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a5d0afe3d7321d0c34a933fcc5b2709/" rel="bookmark">
			SetThreadAffinityMask中掩码的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们进行多线程开发的过程时，常常需要自己分配线程到不同的处理器上运算，以保证我们程序的运行效率。SetThreadAffinityMask是我们常见的选择。 1.MSDN中函数的定义
DWORD_PTR WINAPI SetThreadAffinityMask( _In_ HANDLE hThread, _In_ DWORD_PTR dwThreadAffinityMask ); 参数hThread就是我们在使用传进去线程的句柄，dwThreadAffinityMask就是我们要传入的处理器掩码 2.掩码常见问题 0x00000001，折就是一个最常见的处理器掩码，这个就是代表使用第一个处理器，如下图所示的i5双核心四线程的处理器CPU0（逻辑上的第一个）。0x00000008就是代表在CPU3（逻辑上的第四个）上运行 对于以前的电脑大多都是这样双核心四线程，我来解释下8核处理器及更多cpu核心的是如何分配到后四个处理器上的 如上图所示，一个32核cpu,当我们想使用 第6个cpu运行线程时，那么掩码就是0x00000020 第7个cpu运行线程时，那么掩码就是0x00000040 第8个cpu运行线程时，那么掩码就是0x00000080 第5个和第7个cpu运行线程时，那么掩码就是0x00000050 第7个和第8个cpu运行线程时，那么掩码就是0x000000C0 第2个和第7个和第8个cpu运行线程时，那么掩码就是0x000000C2 第2个和第4个和第7个和第8个cpu运行线程时，那么掩码就是0x000000CA 以此类推
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d0fc9da16c278b2e0bf9eb98a02691/" rel="bookmark">
			史上最全最丰富的“最长公共子序列”、“最长公共子串”问题的解法与思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		花了一天时间把一直以来的“最大子序列”、“最大递增子序列“、”最大公共子序列“、“最长公共子串”等问题总结了一下。其中参考了若干博文，都备注引用。
首先子序列是指一个一个序列中，由若个数（字母）组成，然后从中任意删掉几个数（字母），保留剩下的数（字母）构成了一个序列，即称子序列。（或者从一个序列中，任意选取若干数或字符，按照这些数或字符原来的排序组成新的序列，即称子序列）
子串是指在一个字符串中任意选取连续的一段字符串，即称子串。
1首先看一下 最大子序列。
最大子序列是要找出由数组成的一维数组中和最大的连续子序列。比如{5,-3,4,2}的最大子序列就是 {5,-3,4,2}，它的和是8,达到最大；而 {5,-6,4,2}的最大子序列是{4,2}，它的和是6。你已经看出来了，找最大子序列的方法很简单，只要前i项的和还没有小于0那么子序列就一直向后扩展，否则丢弃之前的子序列开始新的子序列，同时我们要记下各个子序列的和，最后找到和最大的子序列。
int maxSubSum(const vector&lt;int&gt; &amp; arr,int &amp;begin,int &amp;end){ int maxSum=0; int currSum=0; int newbegin=0; for(int i=0;i&lt;arr.size();++i){ currSum+=arr[i]; if(currSum&gt;maxSum){ maxSum=currSum; begin=newbegin; end=i; } if(currSum&lt;0){ currSum=0; newbegin=i+1; } } return maxSum; }参考博客： 最大子序列、最长递增子序列、最长公共子串、最长公共子序列、字符串编辑距离 上述这篇博客中关于“最长递增子序列”讲解的不太好，我自己重新查看了如下的博客，讲解“最长递增子序列”的内容比较好。
2 最长递增子序列
最长递增子序列问题的描述：设L=&lt;a1,a2,…,an&gt;是n个不同的实数的序列，L的递增子序列是这样一个子序列Lin=&lt;aK1,ak2,…,akm&gt;，其中k1&lt;k2&lt;…&lt;km且aK1&lt;ak2&lt;…&lt;akm。求最大的m值。
设f(i)表示L中以ai为末元素的最长递增子序列的长度。则有如下的递推方程：
这个递推方程的意思是，在求以ai为末元素的最长递增子序列时，找到所有序号在L前面且小于ai的元素aj，即j&lt;i且aj&lt;ai。如果这样的元素存在，那么对所有aj,都有一个以aj为末元素的最长递增子序列的长度f(j)，把其中最大的f(j)选出来，那么f(i)就等于最大的f(j)加上1，即以ai为末元素的最长递增子序列，等于以使f(j)最大的那个aj为末元素的递增子序列最末再加上ai；如果这样的元素不存在，那么ai自身构成一个长度为1的以ai为末元素的递增子序列。
public void lis(float[] L) { int n = L.length; int[] f = new int[n];//用于存放f(i)值； f[0]=1;//以第a1为末元素的最长递增子序列长度为1； for(int i = 1;i&lt;n;i++)//循环n-1次 { f[i]=1;//f[i]的最小值为1； for(int j=0;j&lt;i;j++)//循环i 次 { if(L[j]&lt;L[i]&amp;&amp;f[j]&gt;f[i]-1) f[i]=f[j]+1;//更新f[i]的值。 } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d0fc9da16c278b2e0bf9eb98a02691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29955c2b467c8bc2098cb331cd79cb6a/" rel="bookmark">
			QT实现U盘监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前实现U盘监控，插入U盘，会提示，拔出U盘也会
.h文件 protected: // char FirstDriveFromMask (ULONG unitmask); bool nativeEvent(const QByteArray &amp; eventType, void * message, long*result); .cpp文件 //实现U盘监控 char FirstDriveFromMask( ULONG unitmask) { char i; for (i = 0; i &lt; 26; ++i) { if (unitmask &amp; 0x1) break; unitmask = unitmask &gt;&gt; 1; } //qDebug() &lt;&lt; "sss"; return (i + 'A'); } bool MainWindow::nativeEvent(const QByteArray &amp;eventType, void *message, long *result) { MSG* msg = reinterpret_cast&lt;MSG*&gt;(message); int msgType = msg-&gt;message; if(msgType==WM_DEVICECHANGE) { PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)msg-&gt;lParam; switch (msg-&gt;wParam) { case DBT_DEVICEARRIVAL: if(lpdb-&gt;dbch_devicetype == DBT_DEVTYP_VOLUME) { PDEV_BROADCAST_VOLUME lpdbv = (PDEV_BROADCAST_VOLUME)lpdb; if(lpdbv-&gt;dbcv_flags ==0) { QString USBDisk = QString(FirstDriveFromMask(lpdbv -&gt;dbcv_unitmask)); number=1; // keyHook =SetWindowsHookEx( WH_KEYBOARD_LL,keyProc,Boardhinstance,0); qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29955c2b467c8bc2098cb331cd79cb6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0478efbd9d9e4888b7190eaa7ae0a81b/" rel="bookmark">
			QT实现键盘钩子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前实现点击按钮，键盘不能用
HHOOK keyHook=NULL; //键盘钩子过程 LRESULT CALLBACK keyProc(int nCode,WPARAM wParam,LPARAM lParam ) { //在WH_KEYBOARD_LL模式下lParam 是指向KBDLLHOOKSTRUCT类型地址 KBDLLHOOKSTRUCT *pkbhs = (KBDLLHOOKSTRUCT *) lParam; //如果nCode等于HC_ACTION则处理该消息，如果小于0，则钩子子程就必须将该消息传递给 CallNextHookEx if(nCode == HC_ACTION){ if(pkbhs-&gt;vkCode == VK_ESCAPE &amp;&amp; GetAsyncKeyState(VK_CONTROL)&amp; 0x8000 &amp;&amp; GetAsyncKeyState(VK_SHIFT)&amp;0x8000){ qDebug() &lt;&lt; "Ctrl+Shift+Esc"; }else if(pkbhs-&gt;vkCode == VK_ESCAPE &amp;&amp; GetAsyncKeyState(VK_CONTROL) &amp; 0x8000){ qDebug() &lt;&lt; "Ctrl+Esc"; }else if(pkbhs-&gt;vkCode == VK_TAB &amp;&amp; pkbhs-&gt;flags &amp; LLKHF_ALTDOWN){ qDebug() &lt;&lt; "Alt+Tab"; }else if(pkbhs-&gt;vkCode == VK_ESCAPE &amp;&amp; pkbhs-&gt;flags &amp;LLKHF_ALTDOWN){ qDebug() &lt;&lt; "Alt+Esc"; }else if(pkbhs-&gt;vkCode == VK_LWIN || pkbhs-&gt;vkCode == VK_RWIN){ qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0478efbd9d9e4888b7190eaa7ae0a81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0497be8331a2333227c1fbe34bd864e/" rel="bookmark">
			QT运行cmd指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行cmd指令 QProcess p(0); p.start("route");//写入要运行的指令即可 p.waitForStarted(); p.waitForFinished(); qDebug()&lt;&lt;QString::fromLocal8Bit(p.readAllStandardError()); 另一种写法
QProcess p(0); p.start("cmd", QStringList()&lt;&lt;"/c"&lt;&lt;"dir");//找网络ip的指令（netstat -aon|findstr 218.5.241.13:211） p.waitForStarted(); p.waitForFinished(); qDebug()&lt;&lt;QString::fromLocal8Bit(p.readAllStandardOutput()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e38ebd1fd22342f8d578e825cb8628/" rel="bookmark">
			比较草率的Python基础知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为工作需要，博主最近在学习Python的一些基础知识，不求有多精通，但一些基本的代码还是要看懂才行，在此分享一下这几天整理的学习笔记，望各位能够不吝赐教。
#放在行首用于注释该行
多行注释可以使用三引号"""
eg. """Sipping from your cup 'til it runneth over, Holy Grail. """ print用于输出 raw_input()接收一个字符串并输出，再等待用户赋值 eg. name = raw_input("What's your name?") 格式化输出 string_1 = "Camelot" string_2 = "place" print "Let's not go to %s. 'Tis a silly %s." % (string_1, string_2) Python语句中一般以新行作为为语句的结束符。 但是我们可以使用反斜杠（ \）将一行的语句分为多行显示，如下所示： total = item_one + \ item_two + \ item_three from import 导入包内的一个类或一个函数 import 导入一个包 导入包之后，可以通过dir(包名)来查看包内结构 max(num1,num2,...numn) 返回任意个整数或浮点数中的最大值 min(num1,num2,...numn) 返回任意个整数或浮点数中的最小值 abs(num) 返回某个数的绝对值 type(para) 返回当前参数的数据类型,判断形式如type(para) == int start, end, stride = 1, 6, 2 分别赋值 ----标准数据类型----
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e38ebd1fd22342f8d578e825cb8628/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3f8917d9b293caa0f93643e9be0947/" rel="bookmark">
			JDBC四个核心对象及其常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JDBC中的四个核心对象 DriverManager类 java.sql.DriverManager Connection 接口 java.sql.Connection Statement 接口 java.sql.PreparedStatement ResultSet接口 java.sql.ResultSet DriverManager类 java.sql.DriverManager registerDriver(new com.mysql.jdbc.Driver()); Class.forName(com.mysql.jdbc.Driver()); getConnection(url,user,password); Connection 接口 java.sql.Connection createStatement(); ps=prepareStatement("select * from user where id =?"); ps.setInt(1,3); Statement 接口 java.sql.PreparedStatement ResultSet executeQuery(sql);//执行select语句 int executeUpdate(sql);//执行insert update delete boolean execute();//仅当执行的是select语句，且有结果集是才返回true ResultSet接口 java.sql.ResultSet boolean next()//把游标向下移动一行 getInt(int columnIndex);//根据列的索引查找，索引从1开始 getInt(String columnName);//根据列名查找 getDouble() getString() getDate() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c5031b4bfa30659ecc6eebce537023/" rel="bookmark">
			概率学习（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 甲乙两个人比试射箭，两人射术水平一样。如果甲射了101次，乙射了100次。求甲射中次数比乙射中次数多的概率？
A 1/4 B1/2 C 3/4 D 1/3
分析：这道题出的不严谨，应该再加一句：二人射中的概率均为0.5 然后前一百次可以分为三种情况：甲多、乙多、一样多；因为水平一样，所以甲多、乙多的概率相等； 因为射中概率为0.5，所以前一百次一样多并且最后一次甲射中的概率就是前一百次一样多的概率/2； 最后甲多的概率=前一百次甲多的概率 + 前一百次一样多并且最后一次甲射中的概率 =前一百次（甲多+乙多）的概率/2 + 前一百次一样多的概率/2 =前一百次（甲多+乙多+一样多）的概率/2=1/2
这道题我用的排除法做的：(1)如果甲乙都射100次，因为水平相同，因此两人胜平负的概率相当，均为1/3；(2)甲比乙多射一次，因此甲胜的概率大于1/3；(3)甲第101次一定射中的情况下，前一百次的平局就会转化成胜局，胜局不变，输局无影响，此时甲胜的概率为2/3；(4)甲第101次不一定射中，因此甲胜的概率一定小于2/3；(5)综上可知，甲胜的概率在1/3~2/3之间，选择B。但是我不知道具体的概率怎么算，还是根本就不能算。
关键在最后一箭，若对于每一箭甲的命中概率为P，则答案为P。
2. 关系运算包括选择、投影、连接以及除法。
集合运算是二目运算，包括并、差、交、广义笛卡尔积四种运算。
3.平均要取多少个(0,1)中的随机数才能让和超过1.
A、100 B、10^6 C、10^10 D、e
分析：简单粗暴：数学中公式：n 个随机数之和不超过 1 的概率就是 1/n! ，反过来 n个数之和大于 1 的概率就是 1 - 1/n! ，，因此加到第 n 个数才刚好超过 1 的概率就是累加求和： ∑(n=2..∞) n * (n-1)/n! = ∑(n=1..∞) n/n! = e
任取n个0到1之间的实数，这些数之和小于1的概率： (1) n=1，p1 = 1 = 1/1! (2) n=2，p2 = 1/2 = 1/2! 二维空间中x+y&lt;1的几何分布模型 (3) n=3，p3 = 1/6 = 1/3!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02c5031b4bfa30659ecc6eebce537023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92099ab3a7b69975cc058925760a416/" rel="bookmark">
			java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file &#34;/data/app/com.g
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案：
1.查看第三方的提供的SO包是否存在
2.查看所有 包下是否存在 libHDACEngine.so
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a1fd4205d4f80adba2cbfecdbe3385/" rel="bookmark">
			要让CLR挂掉的话……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://rednaxelafx.iteye.com/blog/460893
（Disclaimer：如果需要转载请先与我联系。 作者：RednaxelaFX -&gt; rednaxelafx.iteye.com） 系列文章： 要让CLR挂掉的话…… 要让CLR挂掉的话（第二弹）……
前几天跟浩飞老兄闲聊的时候，聊到说一个不知道什么地方在面试人的时候，如果面试者说自己精通Java，他们就出题考面试者如何让JVM挂掉。这种面试方式或许是比较激进，不过倒也可以考考别人对特定JVM的实现的认识。
于是在爆栈上有这么一帖：How do you crash a JVM?。跟帖中一些同学的观点一样，我也不认为爆栈或者爆堆能算得上是“crash”，因为JVM还能正确捕捉到错误，并且执行合适的异常处理。真正的“crash”应该是连正常的异常处理都没起作用，直接就出crash log了；要是能连出crash log的步骤都破坏掉那就更彻底了。 爆栈帖里有人建议说： ralfs 写道 1. Use JNI and crash in the native code. 2. If no security manager is installed you can use reflection to crash the VM. This is VM specific, but normally a VM stores a bunch of pointers to native resources in private fields (e.g. a pointer to the native thread object is stored in a long field in java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a1fd4205d4f80adba2cbfecdbe3385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80e940b245c962c885ec3c20bdb6fe3/" rel="bookmark">
			（POJ 1258）Prim算法 最小生成树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prim 只于顶点有关
基本思想
1.清空生成树，任取一个顶点加入生成树
2.在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树
3.重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树
Description
Farmer John has been elected mayor of his town! One of his campaign promises was to bring internet connectivity to all farms in the area. He needs your help, of course.
Farmer John ordered a high speed connection for his farm and is going to share his connectivity with the other farmers. To minimize cost, he wants to lay the minimum amount of optical fiber to connect his farm to all the other farms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80e940b245c962c885ec3c20bdb6fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e13e2cba471b83cb4b3908012bda91/" rel="bookmark">
			网页Css知识之百叶窗相册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先上代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style type="text/css"&gt; *{ /*border: solid 1px black;*/ padding: 0; margin: 0; } .container{ width: 805px; height: 320px; list-style: none; margin: 100px auto; /*margin上下100px,左右自动*/ overflow: hidden; /*当图片溢出时,自动隐藏*/ box-shadow: 1px 1px 6px 1px #444; /*图片下面的阴影,前两个为XY坐标，第三个为虚化值 * 第五个为颜色，相当于一个图形下面的色块*/ /*第四个为向外扩散多少个像素，扩散距离*/ } .container li{ width: 160px; height: 320px; float: left; border-left: solid 1px white; box-shadow: -3px 0px 20px #222; /*只能看到左边的阴影,所以只改左边的参数*/ position: relative; transition: all 1s; /*为了使鼠标本元素（图片）离开时有特效显示*/ } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e13e2cba471b83cb4b3908012bda91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee9f159d2c90b82595fc2260a0fa4fe/" rel="bookmark">
			centos7关闭系统自启动MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 systemctl list-unit-files 执行此命令能查看当前系统的服务启动和服务状态。 pagedown翻页直到找到
结果显示如下：
... microcode.service enabled mysql.service enabled mysqld.service enabled NetworkManager-dispatcher.service enabled ... 取消mysqld的自启动 systemctl disable mysqld 执行该命令后再查看当前系统的服务状态：
... microcode.service enabled mysqld.service disabled NetworkManager-dispatcher.service enabled ... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861ac1b74842da1e18a8df2635fa7948/" rel="bookmark">
			看完《如何掌握所有的程序语言》的一些思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何学习一门编程语言 为什么学习它 要明白这个语言有什么新特性，这个特性能够解决什么问题。如果这个语言不能解决实际的问题，那么它就是没有任何价值的
如何学习 对于新语言的语法学习：运行Demo，调试Demo，学习语法，包括，如何定义变量，如何定义函数，如何调用函数，如何使用if，如何使用while和for，如何使用多线程等。
引用王垠对语言特性的定义 变量定义 算术运算 for 循环语句，while 循环语句 函数定义，函数调用 递归 静态类型系统 类型推导 lambda 函数 面向对象 垃圾回收 指针算术 goto 语句
他的博客和一些观点 博客地址：http://www.yinwang.org
一些观点 《新的联系方式》一文中
有证据显示，Google 在这次美国总统选举中已经做了这样的事，利用数据分析对选民进行“思维控制”，试图影响选举结果。 由于这些原因，我对 Google 的鄙视，已经上升为敌视：Google 是全世界民众的敌人。我鼓励大家都停止使用 Gmail，避免 Google 得到太多的私密数据，利用数据分析来作恶。目前我已经停用 Gmail，使用 DuckDuckGo 代替 Google 搜索引擎，关掉了我的 Google+ 账号，删掉了我存在 Google Drive 的照片和文档，停用了 Chrome 浏览器，还会逐渐停止使用 Google 的其它服务。如果你仔细探索，会发现 Google 对我们的生活其实没有那么重要。
《我为什么不在乎人工智能》一文中
纵观人工智能领域发明过的吓人术语，从 Artificial Intelligence 到 Artificial General Intelligence，从 Machine Learning 到 Deep Learning，…… 我总结出这样一个规律：人工智能的研究者们似乎很喜欢制造吓人的名词，当人们对一个名词失去信心，他们就会提出一个不大一样的，新的名词，免得人们把对这个名词的失望，转移到新的研究上面。然而这些名词之间，终究是换汤不换药。因为没有人真的知道人的智能是什么，所以也就没有办法实现“人工智能”。
我持保守观点吧，我觉得随着技术的进步，是会实现的。只是现在一个语言专家认为，人工智能做不到自动编程。他的观点是，算法可以处理那些判断的事，比如图片识别，自动翻译等；不能处理包含思维的事。
小小的总结下 可能就是知乎那些人对王垠的评价吧，天才，傲慢。 今天看了他的几个观点，的确有种换种思维方式思考的感觉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1189691b95558c1071dc4ca848eeefc7/" rel="bookmark">
			Windows中，为开启了BitLocker的磁盘添加右键锁定菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows中，为开启了BitLocker的磁盘添加右键锁定菜单，方法如下：
1、打开系统注册表，运行&gt;“regedit”，找到以下键键值“HKEY_CLASSES_ROOT\Drive\shell”。
2、在shell下添加项比如“runs”，然后选定“runs”项，在右边的窗格中，双击对应的项，修改默认值为“Lock”，这个“Lock”可以自己设定，就是将要显示在右键菜单里面的名称。
3、在“runs”项下面再添加一项“command”，然后选定“command”项，在右边窗格中，双击对应的项，修改默认值为“c:\windows\System32\manage-bde.exe -lock g: -ForceDismount”，其中，“-lock g:”是需要锁定的盘符，“-ForceDismount”是尝试锁定驱动器，即使它正在使用中。 这样，当应用程序具有非独占访问驱动器时被锁定的驱动器。 您还可以使用-fd为此命令的缩写版本。关闭注册表，右键磁盘，即可看到对应的菜单了。
参考微软BitLocker官方文档：https://technet.microsoft.com/zh-cn/dd875513#BKMK_lock
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3accab6035449f8f2bf35107a2339902/" rel="bookmark">
			Scikit中使用Grid_Search来获取模型的最佳参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. grid search是用来寻找模型的最佳参数 先导入一些依赖包
from sklearn.ensemble import GradientBoostingClassifier from sklearn.grid_search import GridSearchCV from sklearn import metrics import numnpy as np import pandas as pd 2. 设置要查找的参数 params={'learning_rate':np.linspace(0.05,0.25,5), 'max_depth':[x for x in range(1,8,1)], 'min_samples_leaf':[x for x in range(1,5,1)], 'n_estimators':[x for x in range(50,100,10)]} 3. 设置模型和评价指标，开始用不同的参数训练模型 clf = GradientBoostingClassifier() grid = GridSearchCV(clf, params, cv=10, scoring="f1") grid.fit(X, y) scoring所有可能情况如下:
Classification scoringfunctioncommentaccuracymetrics.accuracy_scoreaverage_precisionmetrics.average_precision_scoref1metrics.f1_scorefor binary targetsf1_micrometrics.f1_scoremicro-averagedf1_macrometrics.f1_scoremacro-averagedf1_weightedmetrics.f1_scoreweighted averagef1_samplesmetrics.f1_scoreby multilabel sampleneg_log_lossmetrics.log_lossrequires predict_proba supportprecision etc.metrics.precision_scoresuffixes apply as with “f1”recall etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3accab6035449f8f2bf35107a2339902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9273d309f032568c9b3927d25b8c30f/" rel="bookmark">
			C4.5(weka又称为J48)算法原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 信息增益率 ID3算法有以下几个缺点:
1个属性取值越多,则此属性的信息增益率越大,越有可能被ID3选为当前分类属性。然而取值较多的属性并不一定最优。(例如一个属性的每个子节点都只有1个样本,此时信息增益率达到最大,但是用这样的属性却没有任何意义)
ID3只能处理离散型属性
可以处理缺失数据
可以对树进行剪枝
针对ID3算法的不足,Quinlan又提出了C4.5，C4.5算法采用信息增益率来取代信息增益作为当前最优决策属性的度量标准。
仍然选择weka中天气的数据集为例子:
outlooktemperaturehumiditywindyplaysunnyhothighFALSEnosunnyhothighTRUEnoovercasthothighFALSEyesrainymildhighFALSEyesrainycoolnormalFALSEyesrainycoolnormalTRUEnoovercastcoolnormalTRUEyessunnymildhighFALSEnosunnycoolnormalFALSEyesrainymildnormalFALSEyessunnymildnormalTRUEyesovercastmildhighTRUEyesovercasthotnormalFALSEyesrainymildhighTRUEno 1.1 计算属性outlook的信息增益: IG(outlook)=Entropy(S)−Entropy(S|outlook)=0.24675 1.2 计算分裂信息(SplitInfo)来将信息增益规范化 一个属性取值情况越多， SplitInfo 越大,实际我们需要属性的 SplitInfo 越小越好
SplitInfooutlook(S)=−∑v=v0vn(|Sv|S×log2SvS) 通过Outlook将样本分为以下几个部分: 故 SplitInfooutlook 为: SplitInfooutlook(S)=−514×log2514−414×log2414−514×log2514=1.577 同理计算其他属性的 SplitInfo SplitInfotemperature(S)=1.556 SplitInfohumidity(S)=1.0 SplitInfowindy(S)=0.985 1.3 计算属性的信息增益率 IGR(outlook)=IG(outlook)SplitInfo(outlook)=0.246751.577=0.155 IGR(temperature)=IG(temperature)SplitInfo(temperature)=0.0291.556=0.0186 IGR(humidity)=IG(humidity)SplitInfo(humidity)=0.1511.0=0.151 IGR(windy)=IG(windy)SplitInfo(windy)=0.0480.985=0.048 IGR: Information Gain Ratio,即信息增益率
由此可见,属性 outlook 信息增益率越大，故第一步选择该属性为分类属性。在分裂之后的子节点中，如果该子节点只有一种 label ,则停止继续分类。否则重复上述步骤,继续分裂下去。
1.4 C4.5算法总结 选择 IGR (信息增益率)作为 ID3 算法中 IG (信息增益)的代替来选择更好的分类属性: IGR(attr)=IG(attr)SplitInfo(attr) 然后用此公式遍历每个属性,选择 IGR 最大的属性作为当前的分类属性来产生树。对于分类不纯的节点，继续重复上述方法选择其他属性继续分类。 2. C4.5处理连续型属性 对于连续型属性,C4.5先把它当转换成离散型属性再进行处理。本质上属性取值连续,但对于有限的采样数据它是离散的。例如某连续型属性有N个不同取值,则有N-1种离散化的方法: &lt;= vj 的分到左子树, &gt; vj 的分到右子树,然后计算N-1种情况下最大的信息增益率。
对于离散型属性只需计算1次信息增益率,但连续型属性却需要计算N-1次。为了减少计算量,可对连续属性先进行排序,在只有label发生变化的地方才需要切开。比如: 原本需要计算13种情况,现在仅需计算7种。 + 利用信息增益率来选择连续值属性的分界点存在的问题 由于C4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9273d309f032568c9b3927d25b8c30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b26add4fd324e30a121f327b5f3a5ec/" rel="bookmark">
			IBM Websphere安装配置与项目部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Websphere安装配置 1. 在IBM官网下载安装包
（需注册账户，不要偷懒，账户后边需要用到，而且注册不需要审核很简单，一分钟即可搞定~）
下载地址(下载需要通过审核，可能一天后才可以)：点击打开链接
最下方下载win64位版本即可，将得到EXPRESSTRIAL.agent.installer.win32.win32.x86_64.zip文件
2.安装IBM Installation Manager For Windows
将文件解压后，运行install.exe文件
在安装部分下一步，接受许可，选择版本等常规安装操作之后
直到安装完成，重启IBMInstallation Manager将完成安装。
3. 安装Websphere8.5
运行IBMInstallation Manager选择首选项
找到repository.config并添加存储库、测试存储库连接，操作如下：
在IBMInstallation Manager界面点击【安装】按钮
选择要安装的Websphere8.5安装包
选择共享资源目录
...
一系列常规选项后，
选择要安装的功能部件
确认安装部件信息
安装完成
4. Websphere服务器的配置
首先启动概要管理工具
创建Websphere运行时的概要文件
下面会有安装验证窗口，选择【安装验证】
5. 服务启动
第一步窗口中，选择【启动服务器】
出现【停止服务器】说明服务已启动，否则，点击此处的【启动服务器】即可
若要停止服务，点击【停止服务器】即可，此处不再做演示
6. Websphere的服务验证
进入控制台管理：开始菜单【管理控制台】
忽略以下提示，直接进入即可
输入用户名和密码,如我在创建时设置的用户名/密码是wasadmin/root，输入后登录即可
7. HTTPS 服务器的安装
下载安装 Apache（Windows 64位）
8. 配置Web服务器
was和Http
完成后别忘了保存。
将web应用部署到websphere 1. 将应用打成war包
下一步（NEXT）
选择war包导出的路径，点击finish完成导出操作。
2. 进入websphere的控制台
3. 选择项目war文件，例如这里我的项目是“sushe.war”，完成后点击下一步即可
4. 默认下一步
5. 步骤1/2/3全部默认下一步
6. 这里注意上下文根
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b26add4fd324e30a121f327b5f3a5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d3d4f3fc849cecc5ae2acb0de19b84a/" rel="bookmark">
			《线性代数》学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、消元法 第一步先找到三个主元（povit），主元不能为零。主元在矩阵的对角线上，如果对角线上的值为0的话，就交换行，但如果消元到最后一行时主元为零，则这次消元失败，这个矩阵称为不可逆矩阵。而行列式（determinant）的值就是对角线上主元的乘积。
矩阵乘向量与向量乘矩阵的含义与区别：矩阵乘向量是对矩阵中列的线性组合，而向量乘矩阵是对矩阵中行的线性组合。 由以上两条可得出一个结论：当两个矩阵相乘时，左边矩阵中的每一行都可看作是对右边矩阵行的线性组合，右边矩阵中的每一列都可看作是对左侧矩阵列的线性组合。 那么消元的过程自然也就可以用矩阵的乘积代替。并且交换行与交换列也可以用上面的理论。
逆矩阵E^-1*E=单位矩阵。其中E为转换矩阵。
矩阵乘法具有结合律，E1(E2A)=(E1E2)A ，其中E表示消元矩阵和初等矩阵，听说结合律的证明挺复杂。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a0d2b089b74fc2168be3c09a4c8b5d5/" rel="bookmark">
			MySQL数据库替换为SQLServer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作：mysql数据库，SQLServer数据库，Microsoft SQL Server Migration Assistant 2008 for MySQL 官方转换工具，MySQL ODBC driver
1.下载MySQL驱动以后，解压双击install.bat启动，然后在控制面板里配置。打开控制面板，右侧搜索数据源，在出现的页面中点击设置ODBC数据源，在出现的列表右侧点击添加，选择添加MySQL开头的那个，如果出现ANSI和Unicode两个，建议选择Unicode，编码格式更全；
2.下载安装官方转换工具；
3.双击打开转换工具，新建一个工程，然后点击Connect to MySQL，填写自己的的MySQL数据库信息，其中Server一般就是localhost；
4.创建以后会出现自己的MySQL数据库列表，选择要转换的数据库，右键选择Create report，会生成SQLServer转换列表，关掉即可；
5.点击Connect to SqlServer，填写自己的SQLServer数据库信息，其中Port，如果自己数据库端口是默认端口，那就是1143，如果改了就不是这个了；这一步可能会出现一个警告，说自己的SQLServer Agent 没有运行。那就去开始菜单--&gt;Microsoft SQL Server 2008 R2--&gt;配置工具--&gt;SqlServer配置管理器--&gt;SqlServer服务，把SQL Server代理启动；但是这一步你可能发现SQL Server服务列表显示远程过程调用失败，这时候你 就要去控制面板把所有不是自己所用SQL Server数据库版本的SQL Server工具卸载掉，就可以启动啦；
6.在MySQL数据库右键选择Convert schema，然后在SQL Server数据库右键选择Synchronize with Database，最后在MySQL数据库右键选择 Migrate Data就大功告成了！
参考链接：http://www.2cto.com/database/201506/405433.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd63b1f07eafd66eadcba1327ff0e741/" rel="bookmark">
			Android Toast基础与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Toast的使用方式 Toast.makeText(context,text,duration)public Toast(Context context) 在Android系统中，给我们提供了两种方式来创建一个Toast对象。第一种是通过makeText方法快速构建Toast对象。第二种是通过Toast的构造方法进行创造一个空的（不含View）的Toast对象。注意，通过构造方法创建的Toast对象，在show()前需要我们调用setView（View view）方法来设置显示的View。
这里我们简要查看下makeText方法和构造方法的源码。
构造方法 /** * Construct an empty Toast object. You must call {@link #setView} before you * can call {@link #show}. * * @param context The context to use. Usually your {@link android.app.Application} * or {@link android.app.Activity} object. */ public Toast(Context context) { mContext = context; mTN = new TN(); mTN.mY = context.getResources().getDimensionPixelSize( com.android.internal.R.dimen.toast_y_offset); mTN.mGravity = context.getResources().getInteger( com.android.internal.R.integer.config_toastDefaultGravity); } 在上面的源码中，我们可以看到构造方法中核心操作是创建一个TN对象，并给它设置默认的y轴方向上的偏移和默认的对齐方式Gravity。
makeText方法 /** * Make a standard toast that just contains a text view.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd63b1f07eafd66eadcba1327ff0e741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c6f68fc55d9a948454bfc04e04df86c/" rel="bookmark">
			C&#43;&#43;11新特性——结构体内直接赋初始值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++11添加了很多新特性，使C++看上去更加的灵活和面向对象，其中对struct的修改也值得关注。 我们知道，以前struct（包括类class，两者概念是差不多的）是杜绝在其体内直接给成员变量赋初始值的，但是现在可以给每个成员变量赋予默认的初始值，如下：
struct Student{ char* name = nullptr; unsigned int age = 15; int number = 21509111; }; 如此一来，所有声明的新结构体对象就是默认上面的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aed6778119b1391feb2d9b84a317610/" rel="bookmark">
			Android6.0&#43;解决getColor()方法过时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现看到别人编译代码的时候都是用的6.0往上的版本，我还在用5.0的，瞬间有点伤感啊，伤感自己不能与时俱进，玻璃心啊，不多说了，今天做一下笔记，关于getResources().getColor()方法过时的替代方法，在Android的6.0以上的编译环境中getColor方法过时了，也就是说以后不建议用这种方式，如果一个方法过时了，应该会有另一种方法来顶替的，接下来就来看看代码吧
getColor()过时过时的源码：
/** * Returns a color integer associated with a particular resource ID. If the * resource holds a complex {@link ColorStateList}, then the default color * from the set is returned. * * @param id The desired resource identifier, as generated by the aapt * tool. This integer encodes the package, type, and resource * entry. The value 0 is an invalid identifier. * * @throws NotFoundException Throws NotFoundException if the given ID does * not exist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aed6778119b1391feb2d9b84a317610/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/259/">«</a>
	<span class="pagination__item pagination__item--current">260/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/261/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>