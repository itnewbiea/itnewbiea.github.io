<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a9905e4664f4f3cc093adf75205d13/" rel="bookmark">
			vue vue3中使用高德地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高德地图api官网：https://lbs.amap.com/api/javascript-api-v2/guide/abc/amap-vue
成为开发者并创建 key 为了正常调用 API ，请先注册成为高德开放平台开发者，并申请 web 平台（JS API）的 key 和安全密钥，点击 具体操作。
提示 您在2021年12月02日以后申请的key需要配合您的安全密钥一起使用。
开发一个地图组件
1、NPM 安装 Loader npm i @amap/amap-jsapi-loader --save 2、新建 MapContainer.vue 文件 在项目中新建 MapContainer.vue 文件，用作地图组件。
3、创建地图容器 在 MapContainer.vue 地图组件中创建 标签作为地图容器 ，并设置地图容器的 id 属性为 container。 &lt;template&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/template&gt; 4、设置地图容器样式 &lt;style scoped&gt; #container{ padding:0px; margin: 0px; width: 100%; height: 800px; } &lt;/style&gt; 5、引入JS API Loader 在地图组件 MapContainer.vue 中引入 amap-jsapi-loader
import AMapLoader from '@amap/amap-jsapi-loader'; 6、初始化 Map 注意
初始化 map 对象（注意此处声明 map 对象时 vue2 和 vue3 的用法有区别，切记不能混合使用）强烈建议您在使用时按照本文推荐的的用法进行使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0a9905e4664f4f3cc093adf75205d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735dc1e007f1e509b8c6871de047d1b5/" rel="bookmark">
			C语言趣味小游戏扫雷（数组，函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷 扫雷游戏相关介绍扫雷游戏实现开始菜单布置棋盘打印棋盘布置雷排查雷 三个文件的所有代码test.cgame.hgame.c 扫雷游戏相关介绍 扫雷这种经典益智小游戏，相信不少人都玩过或听说过，若没听过，也没事下面有扫雷玩法的介绍。
扫雷的规则如下：
盘面上有许多方格，方格中随机分布着一些雷。你的目标是避开雷，打开其他所有格子。一个非雷格中的数字表示其相邻8格中的雷数，你可以利用这个信息推导出安全格和雷的位置。
看完上面的规则介绍，相信你已经对扫雷已经有一定的了解了，那么现在就让我们利用C语言，开发出一款属于我们自己的简易扫雷游戏。
注：游戏里面涉及的知识为函数，数组，循环，分支以及C语言头文件的创建，开发环境为 Visual Studio 2022。
扫雷游戏实现 首先我们先考虑完成扫雷游戏需要那写步骤：
第一步：开始菜单
第二步：布置棋盘
第三步：打印棋盘
第四步：布置雷
第五步：排查雷
注：
这个游戏一共分为三个部分来实现
test.c（写游戏的主函数）
game.c（写游戏中函数的实现等）
game.h（写游戏需要的库函数引用和函数声明等）
开始菜单 最开始，我们肯定是先打印出菜单，然后输入内容，来判断是开始游戏还是退出游戏去执行相应的分支。先输出再判断，C语言中的 do{ } while()语句 正好也是先执行再判断正好满足，接着我们打印菜单，写的过程中我们发现，打印菜单的代码写在主函数中，在阅读程序的时候主函数看上去不会很简洁，这个时候我们选择把打印菜单的语句放到menu()这个函数里。然后用switch语句来执行选择的不同分支，此外选择 0 作为退出游戏是因为在C语言中 0为假 非0为真，到while这里进行判断如果是0就直接退出，若为其他则不会退出 do{ } while()语句。game()这个函数放在game.c中。
void menu() { printf("**********************\n"); printf("***** 1:开始游戏 *****\n"); printf("***** 0:退出游戏 *****\n"); printf("**********************\n"); } int input = 0; do { menu(); printf("请选择:&gt; \n"); scanf("%d",&amp;input); switch (input) { case 1: game(); break; case 0: printf("退出游戏\n"); break; default: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735dc1e007f1e509b8c6871de047d1b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5daaee21bd0dccdc034e57ffbfe58af8/" rel="bookmark">
			Linux程序前台后台切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前后台任务切换示例： 1、在Linux终端运行命令的时候，在命令末尾加上 &amp; 符号，就可以让程序在后台运行
$ ./test.sh &amp; 2、如果程序正在前台运行，可以使用 Ctrl+z 选项把程序暂停，然后用 bg %[number] 命令把这个程序放到后台运行，摁Ctrl+z，然后在最后一行加上bg %number 3、对于所有运行的程序，我们可以用jobs –l 指令查看
$ jobs -l 4、也可以用 fg %[number] 指令把一个程序掉到前台
$ fg %1 5、也可以直接终止后台运行的程序，使用 kill 命令
$ kill %1 6、如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到），这时候需要screen或者nohup，该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。
screen教程：
Linux下SSH远程连接断开后让程序继续运行_linux断开ssh连接后继续运行_清晨的光明的博客-CSDN博客
nohup教程：
命令形式：
nohup Command [ Arg … ] [　&amp; ] 示例：
nohup test.sh &amp; 查看nohup.out的日志：
tail -fn 50 nohup.out Shell关闭中断后，在另一个终端jobs无法看到后台跑得程序，如果要停止运行，需要利用ps命令查看进程PID，然后kill：
ps -aux | grep "test.sh" #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分。 kill -9 进程号PID 二、命令解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5daaee21bd0dccdc034e57ffbfe58af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff4eae92fa04c75fee4326b286f5bea/" rel="bookmark">
			【设计模式——学习笔记】23种设计模式——职责链/责任链模式(Chain of Responsibility)（原理讲解&#43;应用场景介绍&#43;案例介绍&#43;Java代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 案例引入传统方式实现分析 介绍基础介绍登场角色应用场景 案例实现案例一类图实现 案例二类图实现 职责链模式在Spring中的应用总结文章说明 案例引入 学校OA系统的采购审批项目: 需求是
采购员采购教学器材如果金额 小于等于5000（0&lt;x&lt;=5000），由教学主任审批如果金额 小于等于10000（5000&lt;x&lt;=10000），由院长审批如果金额 小于等于30000（10000&lt;x&lt;=30000），由副校长审批如果金额 超过30000以上（30000&lt;x），由校长审批 传统方式实现 创建一个不同的审批人对应的类，在客户端中写 if else 判断程序，符合不同的条件，就让不同的审批人去处理
分析 客户端这里会使用到分支判断(比如switch)来对不同的采购请求处理， 这样就存在如下问题
如果各个级别的人员审批金额发生变化，客户端的代码也需要发生变化客户端必须明确知道有多少个审批级别及其访问方式，这样对一个采购请求进行处理的类和Approver (审批人) 就存在强合耦合关系，不利于代码的扩展和维护 【改进】
使用职责链模式
介绍 基础介绍 职责链模式又叫责任链模式，为请求创建了一个接收者对象的链(如下方的简单示意图)。这种模式对请求的发送者和接收者进行解耦。当发送者发送一个请求之后，接收者会按照职责链的顺序一个一个地找出到底应该由谁来负责处理这个请求 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推，如果所有人都不能处理，最后就会提示或者报错说不能处理这种类型的设计模式属于行为型模式 登场角色 Handler(抽象处理者)：定义了一个处理请求的接口，同时设有变量来保存其他的HandlerConcreteHandler(具体处理者)：处理它自己负责的请求，可以访问它的后继者(即下一个处理者)，如果可以处理当前请求则处理，否则就将该请求交给后继者去处理，从而形成一个职责链Request(请求对象)：含有很多属性，表示一个请求Client(请求者)：发送请求 应用场景 有多个对象可以处理同一个请求时，比如: 多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器 案例实现 案例一 类图 实现 【采购请求】
package com.atguigu.responsibilitychain; /** * 请求类 */ public class PurchaseRequest { /** * 请求类型 */ private int type = 0; /** * 请求金额 */ private float price = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ff4eae92fa04c75fee4326b286f5bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bcdefb44f6ca7be83c6f0f6f6d7f268/" rel="bookmark">
			Matlab优化算法-非线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非线性规划(NLP) 有约束条件的非线性规划 例题1 % 非线性规划NLP %如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题。 %{ [x,fval,exitflag,output,lambda,grad,hessian]= fmincon('fun',x0,A,b,Aeq,beq,VLB,VUB,'nonlcon',options） 其中，大部分参数同线性规划； VLB和UVB分别是变量x的下界和上界； "fun'为用M文件定义的目标函数F(x)； “nonlcon'为用M文件定义的非线性向量函数[C(x),Ceq(x)]。 A，b，Aeq，beq定义了线性约束A.x&lt;b，Aeq.x =beq， 如果没有线性约束，则A=[]，b=[]，Aeq =[]，beq =[]； %} function func_1 = fun1(x) func_1 = x(1)^2+x(2)^2+8; end function [C,Ceq] = fun2(x) C = -x(1)^2+x(2); %matlab标准，不等式通通都是小于号 所以取负号 Ceq = x(1)+x(2)^2-2; end x0 = rand(2,1); VLB = zeros(2,1); [x,fval,exitflag,output,lambda,grad,hessian]= fmincon('fun1',x0,[],[],[],[],VLB,[],'fun2') lingo 例题2 % 非线性规划NLP %如果目标函数或约束条件中包含非线性函数，就称这种规划问题为非线性规划问题。 %{ [x,fval,exitflag,output,lambda,grad,hessian]= fmincon('fun',x0,A,b,Aeq,beq,VLB,VUB,'nonlcon',options) 其中，大部分参数同线性规划； VLB和UVB分别是变量x的下界和上界； "fun'为用M文件定义的目标函数F(x)； “nonlcon'为用M文件定义的非线性向量函数[C(x),Ceq(x)]。 A，b，Aeq，beq定义了线性约束A.x&lt;b，Aeq.x =beq， 如果没有线性约束，则A=[]，b=[]，Aeq =[]，beq =[]； %} %目标函数 function fun_c = fun_c1(x) fun_c = x(1)^2+x(2)^2+x(3)^2+8; %f(x)= x1^2+x2^2+x3^2+8 end % 非线性函数 function [fun_c,fun_ceq] = fun_c2(x) fun_c = [-x(1)^2+x(2)-x(3)^2 , x(1)+x(2)^2+x(3)^2-20]; %大于号转换小于号 写成符号 %非线性约束条件 函数表达式 不等式矩阵 fun_ceq = [-x(1)-x(2)^2+2 , x(2)+2*x(3)^2-3]; %非线性约束条件 函数表达式 等式矩阵 end x0_1= rand(3,1); VLB1 = zeros(3,1); [x,fval]= fmincon('fun_c1',x0_1,[],[],[],[],VLB1,[],'fun_c2') 例题3 二次规划 若某非线性规划的目标函数为自变量x的二次函数，约束条件又全是线性的，则称这种规划为二次规划。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bcdefb44f6ca7be83c6f0f6f6d7f268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c54a807ec67059f860edb6ab53900c34/" rel="bookmark">
			python爬虫——爬取天气预报信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，我们将学习如何使用代理IP爬取天气预报信息。我们将使用 Python 编写程序，并使用 requests 和 BeautifulSoup 库来获取和解析 HTML。此外，我们还将使用代理服务器来隐藏我们的 IP 地址，以避免被目标网站封禁。
1. 安装必须的库 首先，我们需要安装必须的库，包括 requests、beautifulsoup4 和lxml。您可以使用以下命令安装这些库：
pip install requests pip install beautifulsoup4 pip install lxml 2. 查找代理服务器 在使用代理服务器之前，我们需要找到可用的代理服务器。我们可以在代理服务器网站上找到这些服务器。在本例中，我们将使用 `https://www.zdaye.com/free/`这个网站来查找代理服务器。该网站提供了免费的代理列表，我们可以根据自己的需要选择适合自己的代理服务器。
3. 获取天气预报信息 在获取天气预报信息之前，我们需要设置代理服务器。代理服务器可以隐藏我们的 IP 地址，并允许我们访问被封禁的网站。我们可以使用以下代码设置代理服务器：
import requests proxy = {'https': 'https://&lt;proxy_ip&gt;:&lt;proxy_port&gt;'} response = requests.get(url, proxies=proxy) 在代码中，我们使用 requests 库设置了代理服务器。代理服务器的 IP 地址和端口号需要替换成您自己的代理服务器的 IP 地址和端口号。
现在，我们可以开始编写代码来获取天气预报信息。以下是完整的代码：
import requests from bs4 import BeautifulSoup # 设置代理服务器 proxy = {'https': 'https://&lt;proxy_ip&gt;:&lt;proxy_port&gt;'} # 请求 URL url = 'https://www.weather.com.cn/weather/101010100.shtml' # 发送请求 response = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c54a807ec67059f860edb6ab53900c34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed36fe8257775887e0b7d9a823211d00/" rel="bookmark">
			php数据接收转文件工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是php中间件工具,作用是接收数据参数形成文件,文件作用给大家任意发挥. 提醒大家,这个文件需要做web工具访问的,配置也给大家弄好了. &lt;?php error_reporting(0); ini_set('magic_quotes_gpc', 0); if(PHP_VERSION &gt; '5.1') @date_default_timezone_set('PRC'); $mtime = explode(' ', microtime()); $starttime = $mtime[1] + $mtime[0]; define('APP_DEBUG', FALSE); define('IN_APP', TRUE); define('APP_ROOT', dirname(__FILE__).'/'); define('APP_DATADIR', dirname(dirname(__FILE__)).'/data/'); define('MAGIC_QUOTES_GPC', ini_get('magic_quotes_gpc')); unset($GLOBALS, $_ENV, $HTTP_GET_VARS, $HTTP_POST_VARS, $HTTP_COOKIE_VARS, $HTTP_SERVER_VARS, $HTTP_ENV_VARS); $_GET = daddslashes($_GET, 1, TRUE); $_POST = daddslashes($_POST, 1, TRUE); $_COOKIE = daddslashes($_COOKIE, 1, TRUE); $_SERVER = daddslashes($_SERVER); $_FILES = daddslashes($_FILES); $_REQUEST = daddslashes($_REQUEST, 1, TRUE); $game_id = getgpc('game_id'); $host_name = getgpc('host_name'); $time = getgpc('time'); $file_core = getgpc('file_core'); //$game_id_int = intval($game_id); $game_id = $game_id == NULL ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed36fe8257775887e0b7d9a823211d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abce72e76c0d35ff3f58d9f8da3aa96a/" rel="bookmark">
			shell端口分配计算代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲的是思想 当前的端口计算是直接获取服务器已经使用得端口和数据库表中已经配置的valid=1端口,还有该机器新分配的当前端口作为排除目标,排除后得到的端口再按顺序使用. 支持任意网段,任意DB,任意端口,任意ID服 &gt;/tmp/ports.txt ports=$(cat /tmp/ports.txt) MYSQL_CMD='mysql -u123 -p123 -h123 -e' serverport=$(ss -tln|awk '{print $4}'|grep -v '[a-Z]'|awk -F: '{print $2}'|grep -v '^$'|sort -nr|uniq) gameport=$($MYSQL_CMD 'select port from port.port where valid=1;'|grep -v port|sort -nr|uniq) range_start=10000 range_end=65432 num_ports=5 i=0 lemon(){ for port in $(seq $range_start $range_end); do if [[ ! "$gameport" =~ $port ]] &amp;&amp; [[ ! "$serverport" =~ $port ]] &amp;&amp; [[ ! "$ports" =~ $port ]]; then var_name="port_$i" eval "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abce72e76c0d35ff3f58d9f8da3aa96a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1412e89c17a32b3e2a9c494d560e9f/" rel="bookmark">
			prt文件怎么打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PRT文件通常是由计算机辅助设计（CAD）软件创建的三维模型文件。要打开PRT文件，您需要使用与创建该文件的CAD软件兼容的程序。以下是一些常见的CAD软件，可以用于打开PRT文件：
Creo Parametric（原名为Pro/ENGINEER）：Creo Parametric是一种由PTC开发的CAD软件，它可以打开和编辑PRT文件。这是最常用的PRT文件格式的软件之一。
SolidWorks：SolidWorks是一种流行的三维CAD软件，它支持打开PRT文件，并且可以进行编辑和修改。
Siemens NX（原名为Unigraphics）：Siemens NX是由西门子开发的CAD/CAM/CAE软件，它可以打开PRT文件并进行设计和分析。
AutoCAD：AutoCAD是一种广泛使用的CAD软件，它通常用于2D设计，但也可以打开一些3D文件格式，包括PRT文件。
请注意，不同的CAD软件版本可能对PRT文件的兼容性有所不同。如果您无法打开PRT文件，请确保您使用的CAD软件支持PRT文件格式，并尝试使用相应的软件版本打开文件。
原文链接：https://www.caiwanghao.com/t/61190.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50b048fc6f18979faa9f10021b829c85/" rel="bookmark">
			1.react useState使用与常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0. 取消批处理合并更新, render 2次1. 合并更新,setCount(异步更新) 3次相当于1次, count值为12. 如何取消批处理合并,让值累加?,改为回调函数写法,内部会依次执行函数, 执行3次 count值为33. 异步更新,获取异步更新的值?useEffect4. 结合useRef处理5.利用扩展运算符的形式来解决对象修改的问题6. 初始值大量计算,优化FAQ小结 用于为函数组件引入状态
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src="../react.development.js"&gt;&lt;/script&gt; &lt;script src="../react-dom.development.js"&gt;&lt;/script&gt; &lt;script src="../babel.min.js"&gt;&lt;/script&gt; &lt;script src="../lodash.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; let app = document.querySelector('#app'); let root = ReactDOM.createRoot(app); let { flushSync } = ReactDOM; let { useState, useEffect } = React; let Welcome = (props)=&gt;{ const initCount = () =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50b048fc6f18979faa9f10021b829c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5209d02bd358c4b099b59250486ca2a0/" rel="bookmark">
			判断点是否在矩形框内（C&#43;&#43; OpenCV）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bool DoesRectangleContainPoint(cv::RotatedRect rectangle, cv::Point2f point) { //转化为轮廓 cv::Point2f corners[4]; rectangle.points(corners); cv::Point2f* lastItemPointer = (corners + sizeof corners / sizeof corners[0]); std::vector&lt;cv::Point2f&gt; contour(corners, lastItemPointer); //判断 double indicator = cv::pointPolygonTest(contour, point, true); if (indicator &gt;= 0) return true; else return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7330e0c64dab40047db659c461536b1/" rel="bookmark">
			python之列表推导式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表推导式是一种简洁的方式来创建列表。它允许您通过在单个表达式中定义循环和条件逻辑，以一种更紧凑的方式生成新的列表。使用列表推导式可以使代码更简洁，易于阅读，并且通常比传统的迭代方法更快。
列表推导式的一般语法形式为：
new_list = [expression for item in iterable if condition] expression：对于每个 item，根据表达式生成新的列表元素。item：从可迭代对象中取出的每个元素。iterable：可迭代对象，例如列表、元组、字符串等。condition（可选）：条件表达式，用于筛选要包含在新列表中的元素。 以下是一些列表推导式的示例：
## 生成平方数列表： squares = [x ** 2 for x in range(10)] print(squares) # 输出: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] ## 过滤奇数的列表： numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] even_numbers = [x for x in numbers if x % 2 == 0] print(even_numbers) # 输出: [2, 4, 6, 8, 10] ## 从字符串列表中获取长度大于等于3的单词列表： words = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7330e0c64dab40047db659c461536b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a719969e74cd40e1aa07332a7a0105c/" rel="bookmark">
			Qt：第三章：常用控件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、窗口控件 1、窗口创建 窗口分为三种：普通窗口、无边框窗口以及顶层窗口(顶层窗口永远在最上面)
//普通窗口 QWidget *widget = new QWidget(nullptr,Qt::Tool|Qt::WindowCloseButtonHint|Qt::WindowMaximizeButtonHint); widget-&gt;setWindowTitle(QStringLiteral("widget窗口")); widget-&gt;show(); //无边框 QWidget *widget1 = new QWidget(nullptr, Qt::FramelessWindowHint); widget1-&gt;show(); //作为顶层窗口出现 QWidget *widget2 = new QWidget(nullptr,Qt::Dialog| Qt::WindowStaysOnTopHint); widget2-&gt;setWindowTitle("top widget"); widget2-&gt;show(); 2、对话框 1、模态对话框和非模态对话框 模态对话框：就是我们没有关闭它之前，不能再与同一个应用程序中的其他窗口进行交互（操作）,例如vs中的新建项目窗口，若不关闭，无法进行编写代码的操作。要想使一个窗口为模态窗口，需要调用它的exec()方法显示窗口。
非模态对话框：关闭该对话框之前，还可以与应用程序中的其他窗口进行交互（操作），例如记事本中的查找窗口要想使一个窗口为非模块窗口的话，需要使用new操作符在堆上创建窗口对象，使用show()方法进行显示
​ //模态对话框 void Dialog04::on_modalButton_clicked() { QDialog dlg(this); dlg.resize(200, 200); dlg.exec(); } //非模态对话框 void Dialog04::on_noModalButton_clicked() { QDialog dlg1(this); dlg1.resize(200, 200); dlg1.show(); } 2、消息对话框 MessageBox：有信息提示框、警告提示框、错误提示框、问题提示框、关于提示框
//信息提示框 QMessageBox::information(nullptr, QStringLiteral("提示信息"), QStringLiteral("这是信息提示窗口"), QMessageBox::Yes | QMessageBox::No); //警告提示框 QMessageBox::warning(nullptr, QStringLiteral("警告信息"), QStringLiteral("程序警告信息")); //错误提示框 QMessageBox::critical(nullptr, QStringLiteral("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a719969e74cd40e1aa07332a7a0105c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152c5aa12bfb357f62ff97edae60cf77/" rel="bookmark">
			Android Studio入门级教程（详细）【小白必看】[通俗易懂]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio如何使用 本文主要讲解一下Android Studio使用方法 步骤： 1.建立项目 首先点击new——new project新建项目 选择想要创建的Android 的模板，建议选择empty activity（空模板），然后next Name：给你的项目起一个名字API level：选择Android 虚拟机的版本，版本越低运行起来越快剩下的就按默认的就行，点击finish（由于版本不一样，步骤2和步骤3的顺序可能交换，大家注意一下就好啦） android项目创建完成了，包含三个主要的文件activity：提供了用户与屏幕之间的互动，以便于用户进行操作，在里面实现主要的Java代码activity_main.xml：布局文件，Android的UI界面显示的视图，所有的控件在这里设计AndroidManifest.xml：Android应用程序的清单文件,是整个Android应用程序的描述文件 2.入门试验 我们双击进入activity_main.xml先将android.support.constraint.ConstraintLayout改为LinerLayout线性的，意思就是水平的的结构并加入android:orientation=”vertical”意思是将所有组件垂直摆放 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;/LinearLayout&gt; 复制
接下来加入一个文本Testview和一个按钮Button &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="学习安卓，你准备好了吗" android:id="@+id/tv_android"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="准备好了" android:id="@+id/bt_android" android:onClick="Welcome"/&gt; &lt;/LinearLayout&gt; 复制
注：小白为了养成良好习惯，每个控件的id一定要起得严谨，一看到就知道是什么意思，最好不要含有数字。
点击右边的preview可以显示视图 双击进入Mainactivity，我们打算点击按钮弹出toast public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152c5aa12bfb357f62ff97edae60cf77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a48b415c2ad7f85752d49bcdca921e8/" rel="bookmark">
			C&#43;&#43;遍历std::tuple（C&#43;&#43;14 ~ C&#43;&#43;20）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文展示了遍历std::tuple的方式：
首先比较容易想到的是利用C++14的std::make_index_sequence与std::get结合取值，然后配合std::initializer_list进行包展开：
// since C++14 class Func0 { template&lt;typename T, typename F, size_t... I&gt; void init(T&amp;&amp; t, F&amp;&amp; f, std::index_sequence&lt;I...&gt;) { std::initializer_list&lt;int&gt;{ (f(std::get&lt;I&gt;(t)), 0)... }; } public: template&lt;typename T, typename F&gt; auto operator()(T&amp;&amp; t, F&amp;&amp; f) { init(t, f, std::make_index_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;{}); } }; 到了C++17，我们有了折叠表达式（Fold expressions），就可以直白一点了：
// since C++17 class Func1 { template&lt;typename T, typename F, size_t... I&gt; void init(T&amp;&amp; t, F&amp;&amp; f, std::index_sequence&lt;I...&gt;) { ((f(std::get&lt;I&gt;(t))), ...); } public: template&lt;typename T, typename F&gt; auto operator()(T&amp;&amp; t, F&amp;&amp; f) { init(t, f, std::make_index_sequence&lt;std::tuple_size_v&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;{}); } }; C++20允许lambda添加模板参数，因此我们可以进一步限制这个遍历器的作用域：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a48b415c2ad7f85752d49bcdca921e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f07fb32b2258d7413c90392a8e81c2a/" rel="bookmark">
			数组中的每个对象中提取xxx_id属性，并返回一个新的数组。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用JavaScript的map方法从数组中的每个对象中提取order_id属性，并返回一个新的数组。
这是一种非常简洁和高效的方法来获取一个对象数组中的所有order_id。代码如下：
let array = [{order_id: 11},{order_id:22}]; let orderIds = array.map(item =&gt; item.order_id); console.log(orderIds); // 输出：[11, 22] 写是为了更好的思考，坚持写作，力争更好的思考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c78bc5d8877d527ea302e3e32eee0473/" rel="bookmark">
			Halcon算子rft_generic()参数解析及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.功能
rft_generic：计算图像的实值快速傅里叶变换。
区别：fft_generic是计算输入图像的快速傅里叶变换。
fft_generic(Image : ImageFFT : Direction, Exponent, Norm, Mode, ResultType : )
Exponent：对应公式中指数符号，前向变换用-1，后向变换用1。
Mode:‘dc_center’频域图中心频率为0，‘dc_edge’频域图边角点频率为0。
2.参数
rft_generic(Image : ImageFFT : Direction, Norm, ResultType, Width : )
Image：输入图像。
ImageFFT：傅里叶转换后的图像。
Direction：计算正向或反向变换。
默认值:'to_freq'(从空间域到频域)，也可设置为'from_freq'(频域到空间域)。
Norm：变换的归一化因子。
默认值:'sqrt'（开根号,c=sqrt(M*N)，变亮）；也可设置为 'n'（图像宽*图像高,c=M*N，变暗），
'none'（不使用,c=1）。
ResultType：输出图像的图像类型。
默认值:'complex'(复数图像)，也可设置为'byte'(灰度图像), 'cyclic', 'direction', 'int1', 'int2', 'int4', 'real'(实值图像), 'uint2'。
Width：运行时应针对其进行优化的图像宽度。
默认值:512，也可设置为128, 160, 192, 256, 320, 384, 640, 768, 1024, 2048。
3.描述
rft_generic计算输入图像的快速傅里叶变换。一般需要使用两次，因为在频域处理完之后，还需要转换成空间域。
与fft_generic, fft_image和fft_image_inv相比，前向变换中的输入图像是实值图像(即，不是复数图像)。在这种情况下，复数输出图像具有冗余。图像右半部分的值是图像左半部分对应值的复共轭。因此，只计算和存储复数图像的左半部分可以节省运行时间和内存。
ResultType参数可用于指定反向变换的结果图像类型(Direction = 'from_freq')。
在正向变换(Direction = 'to_freq')中，即从空间域到频域，生成频域图时，ResultType必须设置为'complex'（输出图像为复数类型）。
参数方向决定了是对频域进行变换还是返回到空间域。
对于Direction = 'to_freq'，输入图像必须具有实值类型，即，复数图像不能用作输入。支持所有可以转换为real类型图像的图像类型。在这种情况下，输出是一个尺寸为(w/2+1)*h的复数图像，其中w和h是输入图像的宽度和高度。在这种模式下，指数-1在转换中使用(参见fft_generic)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c78bc5d8877d527ea302e3e32eee0473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b8190e420698d2cfbe0dda9701afca7/" rel="bookmark">
			BUUCTF_Web题目题解记录1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BUUCTF刷题Web篇 文章目录 BUUCTF刷题Web篇前言一、[GYCTF2020]Blacklist二、[网鼎杯 2020 青龙组]AreUSerialz三、[GXYCTF2019]BabyUpload总结 前言 在无脑刷了若干题目后，回过头来整理，所以顺序和内容比较随缘。
就不写解题过程了，直接说用到的方法和答案。
总是想无脑刷题而不去归纳总结、一味地忍不住去和同事卷解题数量就是自己欺骗自己啊，要真的学到东西才行的。
一、[GYCTF2020]Blacklist 这是一道SQL注入的题，输入1,1’ or 1=1#,1’ order by 2#这些都是有返回内容的，然后尝试联合注入的时候发现select被过滤，没招了，查了别人的wp得知要使用“堆叠注入”。
堆叠注入？应该就是用;来分割可以执行的语句吧
1.查表名：1’;show tables#
得知有一个叫FlagHere的表，想到继续尝试得到这个表中的列名。
2.查列名：1’;show columns from FlagHere#
果然有一个叫flag的列，下面就是要去拿到flag列里的字段了
这里意外发现把from换成in也可以哈哈哈
其实这个网页点了提交之后，输入框就会只剩下个1，然后截图看起来就好怪！所以上一张截图在语句消失后我又手动敲上了，但后面不想敲了emmm
3.获取字段
由于这题过滤了select，所以又做不动了，查看别人的wp得知要用handler。
handler语法是：
handler table_name open … 获取句柄
handler … read first 读取第一行数据
handler … read next 读取下一行数据
这里的三处…是自己可以随意命名的“句柄”，保持一致即可
这里用：1’;handler FlagHere open fh;handler fh read first#
拿到flag！
二、[网鼎杯 2020 青龙组]AreUSerialz 打开靶机之后是PHP代码：
&lt;?php include("flag.php"); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b8190e420698d2cfbe0dda9701afca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0faf969e2e129d30bf1fe1811e1a0596/" rel="bookmark">
			opencv[c&#43;&#43;] findContours()轮廓特征分析大全(求面积、周长、几何矩、质心、凸包、最小外接矩形、最小外接三角形、最小外接椭圆等)---后续完善总结版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，轮廓的发现与绘制
二，轮廓分析（二值图像分析)
🧡计算轮廓面积 : 💛计算轮廓周长：
💚计算几何矩与中心距: moments(）
💙轮廓的外接矩形：
💜最小外接圆/拟合圆：minEnclosingCircle(）
🤎拟合椭圆：fitEllipse(） 🖤拟合直线：fitLine(）
🤍轮廓的凸包：convexHull(）
🧡多边形逼近-逼近真实形状：approxPolyDP(）
💛检测点是否在轮廓内pointPolygonTest(）
一，轮廓的发现与绘制 在OpenCV里面利用findContours()函数和drawContours()函数实现这一功能。
findContours()函数 void findContours( InputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point() ) 参数一： image，输入图像、八位单通道的，背景为黑色的二值图像。（一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像）
参数二：contours，输出轮廓图像。是一个向量，向量的每个元素都是一个轮廓。因此，这个向量的每个元素仍是一个向量。即：
vector&lt;vector&lt;Point&gt; &gt; contours; 参数三：hierarchy，输出各个轮廓的继承关系。hierarchy也是一个向量，长度和contours相等，每个元素和contours的元素对应。hierarchy的每个元素是一个包含四个整型数的向量。即：
vector&lt;Vec4i&gt; hierarchy; 参数四：mode，检测轮廓的方法。有四种方法：
RETR_EXTERNAL：只检测外轮廓。忽略轮廓内部的洞。RETR_LIST：检测所有轮廓，但不建立继承(包含)关系。RETR_TREE：检测所有轮廓，并且建立所有的继承(包含)关系。RETR_CCOMP：检测所有轮廓，但是仅仅建立两层包含关系。 参数五：method，每个轮廓的编码信息。也有四种（常用前两种）
CHAIN_APPROX_NONE：把轮廓上所有的点存储。CHAIN_APPROX_SIMPLE：只存储轮廓上的拐点。CHAIN_APPROX_TC89_L1，CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法 参数六： Point，偏移量。默认为0
注意：该函数将白色区域当作前景物体。所以findContours()函数是黑色背景下找白色轮廓。（重要！！！）
drawContours()函数 drawContours( InputOutputArray binImg, // 输出图像 OutputArrayOfArrays contours,// 全部发现的轮廓对象 Int contourIdx// 轮廓索引号，-1表示绘制所有轮廓 const Scalar &amp; color,// 绘制时候颜色 int thickness,// 绘制线宽，-1表示填充轮廓内部 int lineType,// 线的类型LINE_8 InputArray hierarchy,// 拓扑结构图 int maxlevel,// 最大层数， 0只绘制当前的，1表示绘制绘制当前及其内嵌的轮廓 Point offset = Point()// 轮廓位移，可选 ） 二，轮廓分析（二值图像分析) 在得到图像的轮廓以后，我们就可以进行轮廓分析。经过轮廓分析我们可以得到轮廓各种有用的属性信息、常见的如下：　🧡计算轮廓面积 : contourArea(contour， oriented = False) //计算轮廓的面积 参数说明：contour为输入的单个轮廓值;oriented:轮廓方向，默认值false。 如果为true，该函数返回一个带符号的面积，其正负取决于轮廓的方向(顺时针还是逆时针)。 如果是默认值false，则面积以绝对值的形式返回.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0faf969e2e129d30bf1fe1811e1a0596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2a8a875888f9bab7ef3c6e5afe46c7/" rel="bookmark">
			JSON看这个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JSON转换
1、JSONObject与JSON的区别
JSONObject是JSON的子类。JSON是一个抽象类，JSON中有一个静态方法parseObject（String text），将text解析为一个JSONObject对象并返回；JSONObject是一个继承自JSON的类，当调用JSONObject.parseObject（result）时，会直接调用父类的parseObject（String text）。所以两者没什么区别，一个是用父类去调用父类自己的静态的parseObject（String text），一个是用子类去调用父类的静态parseObject（String text），两者调的是同一个方法。
parseObject()和parse()的区别
类型不同：parse方法返回基本数据类型，如int、double等；而parseObject方法返回包装类类型，如Integer、Double等。
异常处理：当parse方法无法解析输入的字符串时，会抛出NumberFormatException异常；而parseObject方法不会抛出异常，而是返回一个null值。
2、通过HttpservletRequest接收json数据
public String intercept(ActionInvocation invocation) throws Exception { HttpServletRequest request = ServletActionContext.getRequest();	接收json数据 BufferedReader streamReader = new BufferedReader( new InputStreamReader(request.getInputStream(), "UTF-8")); StringBuilder responseStrBuilder = new StringBuilder(); String inputStr; while ((inputStr = streamReader.readLine()) != null) responseStrBuilder.append(inputStr); 转化成json对象 JSONObject jsonObject = JSONObject.fromObject(responseStrBuilder.toString()); 获取其中的对象 JSONObject commonRequest=jsonObject.getJSONObject("commonRequest"); 获取对象中的字段 String accessKey=commonRequest.getString("accessKey"); 获取其中的list数据 List custList=(List) jsonObject.get("custList"); 获取的是字符串 String couponGroupId=jsonObject.getString("couponGroupId"); } 这是传的json数据 { "commonRequest": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb2a8a875888f9bab7ef3c6e5afe46c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a450bd457705f4a98889d6ae209376/" rel="bookmark">
			CentOS7源码安装MySQL详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😊 @ 作者： Eric
💖 @ 主页： https://blog.csdn.net/weixin_47316183?type=blog
🎉 @ 主题：CentOS7源码安装MySQL详细教程
⏱️ @ 创作时间： 2023年08月014日
文章目录 1、安装的四种方式2、源码安装MySQL详细步骤2.1、查看是否安装过MySQL2.2、卸载之前的MySQL（可选）2.3、安装MySQL1）下载安装包2）检查MySQL依赖4）具体安装过程4）服务的初始化5）启动MySQL、查看状态7）MySQL登录8）修改密码 3、配置MySQL3.1、设置MySQL自启动3.2、设置允许远程连接 总结 1、安装的四种方式 安装方式特点rmp安装简单、灵活性差、无法灵活选择版本、升级rpm repository安装包极小，版本安装简单灵活，升级方便，需要联网安装通用二进制包安装比较复杂，灵活性高，平台通用性好源码包安装最复杂，时间长，参数设置灵活，性能好 那么我们这里选择 源码包 方式进行安装，因为性能好同时设置参数灵活
2、源码安装MySQL详细步骤 2.1、查看是否安装过MySQL 1、如果你是用rpm安装, 检查一下RPM PACKAGE：
rpm -qa | grep -i mysql 2、检查mysql service：
systemctl status mysqld.service 3、如果存在mysql-libs的旧版本包，显示如下：
如果不存在mysql-lib的版本，显示如下：
2.2、卸载之前的MySQL（可选） 1、关闭 mysql 服务
systemctl stop mysqld.service 2、查看当前 mysql 安装状况
rpm -qa | grep -i mysql # 或 yum list installed | grep mysql 3、卸载上述命令查询出的已安装程序
yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx 务必卸载干净，反复执行 rpm -qa | grep -i mysql 确认是否有卸载残留
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a450bd457705f4a98889d6ae209376/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d660d6638831fecd34ece1e8a64d47/" rel="bookmark">
			JAVA-IO-字节流-字符流-缓冲流-File，看这个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO，流，File 一、IO流分类二、字节流、文件、缓冲流 的使用2.字符流、文件、缓冲流的使用(同字节流思路一样) 一、IO流分类 1.字节流处理任何数据文件；
2.字符流只能处理纯文本文件；
3.缓冲流基本原理，在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。
字节缓冲流：BufferedInputStream，BufferedOutputStream；
字符缓冲流: BufferedReader，BufferedWriter;
二、字节流、文件、缓冲流 的使用 流程思路 ：file对象 -&gt; file输入流 --&gt; 字节缓冲输入流 --&gt; 字节数组输入流 --&gt; 数组 --&gt; 字节缓冲输出流 --&gt; file输出流 --&gt;文件
代码如下（示例）：
import java.io.*; public class Aopmain { public static void main(String[] args) throws IOException { File file = new File("E:\\PaybillFile\\pdf\\aaa.pdf"); System.out.println(file.getName()); //aaa.pdf System.out.println(file.getPath()); //E:\PaybillFile\pdf\aaa.pdf System.out.println(file.getAbsoluteFile());//E:\PaybillFile\pdf\aaa.pdf System.out.println(file.getAbsolutePath());//E:\PaybillFile\pdf\aaa.pdf /* boolean createNewFile(); //创建文件 boolean mkdir();创建文件夹 boolean mkdirs();创建多级文件夹。*/ //本地已有的要发送的文件 File sendFile = new File("D:\\PaybillFile\\sendpdf\\send01.pdf"); //接收文件夹及文件 File receiveFile = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d660d6638831fecd34ece1e8a64d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1cc7fb0dc363712133f91f93e78e8c/" rel="bookmark">
			Element多选表格设置默认勾选 调用this.$refs.tableRef.toggleRowSelection不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天记录一下多选表格设置默认勾选 调用this.$refs.tableRef.toggleRowSelection不生效的情况...
上次的需求是这样的... 点击筛选按钮，筛选出符合条件的数据，排列到列表页最前面并勾选...
我想这还不简单，直接用下Element的方法就好了,结果就出现了勾选不生效的情况...
// 设置勾选 eligibleData.forEach((row) =&gt; { this.$refs.multipleTable.toggleRowSelection(row);	}); 在这里，点击筛选，不是对进来这个页面时获取的表数据进行直接筛选，而是先调用相关接口后再进行表数据的刷新，所以我们先加一层$nextTick，以便获取更新后的Dom... 其次，通过对比筛选找到源数据来设置选中项... 完美解决该问题
this.$nextTick(() =&gt; { eligibleData.forEach((row) =&gt; { this.tableData.find((item) =&gt; { if (item.id == row.id) { this.$refs.multipleTable.toggleRowSelection(item); } }); }); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc065836f02cc5e43b047a8aa64162b/" rel="bookmark">
			下载程序到西门子PLC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多关于西门子S7-200PLC内容请查看：西门子200系列PLC学习课程大纲
下载西门子200PLC程序分以下两步：
一.编译程序 1. 如下图1-1所示，使用PPI电缆将PLC和电脑连接上，注意笔记本使用USB转PPI电缆，连接保证给PLC单独供电才可以正常通信。
图 1-1 西门子PLC与电脑连接图 2. 如下图1-2所示，打开Micro-win软件，对于3处的简单程序，点击1处所标记的编译按钮，编译完成后显示结果如2处标记所示,
表示程序由主程序OB,子程序SBR_0，以及中断程序INT_0组成，整个大小是22字节，且没有出错，所以该程序可以下载使用。
图 1-2 程序主界面
二.下载程序 1.下载程序需要CPU类型匹配，比如实际PLC硬件的CPU是CPU221，那么程序设置的也应该和实际硬件一样，如图2-1所示，标记1点击后弹出如下对话框，对话框中标记2显示改程序的PLC类型和CPU版本信息，这个一定要与实际硬件匹配，如果闲麻烦，可以通过 点击标记3来读取目前电脑连接的PLC型号和版本信息，当然也可以通过标记4来设置通信参数。
图 2-1 PLC类型信息图
2.上一步完成后就可以点击左边图标按钮或者在命令菜单里选择File-&gt;Download开始下载程序，点击OK即可下载程序到西门子200PLC中，如果S7-200PLC处于运行模式，那么将会有提示将PLC进入停止模式，单击Yes即可置于STOP模式。
3.完成上面一步，即可通过选择菜单里的调试-&gt;开始程序状态监控来监控PLC程序的运行，从而可以直观的查看程序变量的值。
关于PLC程序的下载就这么多，后续课程欢迎继续关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4807ae10899e142779201ed02c118892/" rel="bookmark">
			物流行业数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 物流行业数据分析一、数据预处理1、数据清洗① 重复值、缺失值、格式调整② 异常值处理 2、数据规整 二、 数据分析1、配送服务是否存在问题2、是否存在尚有潜力的销售区域3、商品是否存在质量问题 三、总结参考 物流行业数据分析 Excel适合处理低量级数据，当数据量过高，Excel只能展现部分数据，不利于后续的数据分析，此时使用Python进行数据分析更加方便，有效。
首先，这里仅仅只有一个工作表，数据一共有订单号，订单行，销售时间（下单时间），交货时间（签收时间），货品交货状态（晚交货或按时交货），货品，用户的反馈情况（质量合格，返修或拒货），销售区域（华北，华南，马来西亚），数量以及销售金额等10列数据。粗略的看一下数据，我们就可以发现，在订单号和数量这两列存在部分行为空值，在销售金额这一列数据的单位不统一并且存在逗号，并且订单行这一列数据对我们分析物流行业没有帮助，这些问题都需要在数据预处理阶段进行处理！
认识完数据之后，我们认识一下我们需要解决的问题，具体如下所示：
1.物流配送服务是否存在问题？
2.是否存在尚有潜力的销售区域？
3.商品本身是否存在质量问题？
为了解决这些问题并得出相应的结论，接下来我们就进行数据分析阶段！
一、数据预处理 前面已经提到数据中存在的问题，那么针对问题我们就要进行相应的处理，比如删除数据中存在的重复值，并且处理缺失值（删除或填充），以及格式的调整（销售金额单位不统一），同时我们还需要对异常值进行处理（比如，销售金额存在并且等于0的属于异常值）。首先，我们加载数据并查看数据的基本信息，具体代码如下所示:
1、数据清洗 先使用info()函数查看数据信息
data=pd.read_csv('data_wuliu.csv',encoding='gbk') data.info() 通过info()可以看出，该物流数据共有1161条数据，每条数据有10列，其中：
1、订单号、货品交货状况和数量存在缺失值，但是确实量不大，可以删除
2、订单行对数据分析无关紧要，可以考虑删除
3、销售金额的类型是object类型（万元|元，逗号问题)，数据类型需要转换成int|float类型的
具体操作如下：
① 重复值、缺失值、格式调整 删除重复记录
# 删除重复数据 # 遇到重复数据保留第一行(keep='first')，并且在原数据上修改(inplace=True) data.drop_duplicates(keep='first', inplace=True) data.info() 删除缺失值
# 删除缺失值 # 按行删除(axis=0),只要一条数据中存在NA则删除(how='any') 在原数据上修改 data.dropna(axis=0, how='any', inplace=True) data.info 删除订单列
考虑到订单列对分析数据无关紧要，将订单列删除
# 删除订单行 # 按列删除(axis=1) 并在在原数据上修改(inplace=True) data.drop(columns=['订单行'], axis=1, inplace=True) data.info() 更新索引
# 前面进行了数据删除，需要更新索引 data.reset_index(drop=True,inplace=True) data.info() 清洗数据
从图中可以看出，销售金额中含有 “，”，空格，且单位不一致，对此，编写自定义过滤函数，将逗号和空格删除，并统一单位
# 修改金额格式 # 编写自定义过滤函数,删除逗号，转成float，如果是万元，则乘以10000，否则不处理 def data_deal(number): if (number.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4807ae10899e142779201ed02c118892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef44765e03f44fa0124860976e9b0fb/" rel="bookmark">
			解决WSL2的docker删除镜像后，磁盘空间不释放问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题原因 由于WSL2本质上是虚拟机，所以 Windows 会自动创建 vhdx 后缀的虚拟磁盘文件作为存储。这个 vhdx 后缀的虚拟磁盘文件特点是可以自动扩容，但是一般不会自动缩容。一旦有很多文件把它“撑大”，即使把这些文件删除它也不会自动“缩小”。所以删除文件后还需要我们手动进行压缩才能释放磁盘空间。
2、解决方法 2.1、查看虚拟磁盘文件路径，并关闭Docker Desktop 首先打开Docker Desktop软件，查看Docker虚拟磁盘文件的路径：
然后将WSL2和Docker应用退出，并使用以下命令确认：
wsl --list -v 2.2、压缩虚拟磁盘文件 在PowerShell中，利用diskpart收缩硬盘，首先进入diskpart：
diskpart 然后选择虚拟磁盘文件：
select vdisk file="步骤2.1中虚拟磁盘文件的路径" 接着对虚拟磁盘文件进行压缩：
compact vdisk 最后卸载虚拟磁盘：
detach vdisk 上述操作执行完毕，WSL2 删除文件后空出来的磁盘空间就被释放了，可以去虚拟磁盘文件的路径看到 ext4.vhdx 文件大小已经减小。最后打开 Docker Desktop 可以看到原来镜像还在，成功解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4829a36914c14cb19deaff4afd3698/" rel="bookmark">
			模型导入UE5的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型导入UE5的流程 一、建模部分 1、使用Maya，创建模型
2、将模型所有线都缝合起来。
3、进行清理模型。
4、导出模型为FBX格式。
二、绑定骨骼和蒙皮 1、将制作好的模型以FBX格式导入Blender，使用Auto-Rig Pro插件进行自动生成骨骼。
2、选中对应模型，点击按键"Get Selected Objects"，进行绑定骨骼，然后调整骨骼到对应位置。
3、安放好骨骼之后，记得选择"UE5"匹配对应的骨骼类型。
4、在Auto-Rig Pro中下的"Rig"，点击"GO"来生成控制器。
5、从"姿势模式"切换到"物体模式"，选中模型，然后选中骨骼控制器，在“蒙皮”下点击“Bind”进行绑定。
三、导入UE5 1、导入UE5后，如果出现异常，就进行重定向。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da1b491b019c8a3915b228bb8ae36b3/" rel="bookmark">
			接口自动化测试-Requests模块实战详解，一篇打通...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 什么是requests？
requests是一个很实用的Python HTTP客户端库，编写爬虫和测试服务器响应数据时经常会用到， Requests是Python语言的第三方的库，专门用于发送HTTP请求
下载
pip install requests 请求方式
1、get请求
# GET无参请求 r = requests.get('http://www.baidu.com') # GET有参请求 # 方法一 canshu = {"consName": "水瓶座","key":26183f3f48d787b5541aa3d0e767b359} r = requests.get("http://web.juhe.cn:8080/constellation/getAll", params=canshu) print(r) # 方法二 r = requests.get("http://web.juhe.cn:8080/constellation/getAll?consName=水瓶座&amp;key=26183f3f48d787b5541aa3d0e767b359") print(r.text) 2、post请求
canshu = {"consName": "水瓶座", "key": "26183f3f48d787b5541aa3d0e767b359"} r = requests.post("http://web.juhe.cn:8080/constellation/getAll", data=canshu) print(r.text) 3、响应的内容
r.encoding # 获取当前的编码 r.encoding = 'utf-8' # 设置编码 r.text # 以encoding解析返回内容。字符串方式的响应体，会自动根据响应头部的字符编码进行解码。 r.content # 以字节形式（二进制）返回。字节方式的响应体，会自动为你解码 gzip 和 deflate 压缩。 r.headers # 以字典对象存储服务器响应头，但是这个字典比较特殊，字典键不区分大小写，若键不存在则返回None r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7da1b491b019c8a3915b228bb8ae36b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19dcc8d41a0d59bcf79f162fbba5f164/" rel="bookmark">
			Cobalt Strike使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java环境，cs4.0工具
vps一台（本人使用的是ubantu）
本地电脑windows 10 vps上事先安装好了java并配置了环境变量不会的可以看我的linux配置Java本地环境。 vps可以看我以前的的文章购买，挺便宜。
将jdk-17.0.7上传到vps服务端（方法很多，这里我介绍一种方式）
使用finalshell，Windows版下载地址:http://www.hostbuf.com/downloads/finalshell_install.exehttp://www.hostbuf.com/downloads/finalshell_install.exe
cs4.0链接：https://pan.baidu.com/s/1ZoSnvARG21H2vrRfjLZo1A?pwd=8dtg 提取码：8dtg cs4.0中文版链接：https://pan.baidu.com/s/1aQCcang-sGz1ALreHRfEgQ?pwd=9ve6 提取码：9ve6
cs4.8链接：https://pan.baidu.com/s/1WAutIrlhH7hnAvsRqlKANA?pwd=8mku 提取码：8mku
进入文件
cd /Cs 解压文件 unzip CobaltStrike4.8.zip 给权限
chmod 777 TeamServerImage chmod 777 teamserver 客户端运行cobaltstrike.exe
cs的版本要对应
进入cs了
1.建立Listener 可以通过菜单栏的第一个选项”Cobalt Strike”进人”Listeners” 面板，如下图。
也可以通过快捷功能区进入”Listeners” 面板，如下图。
单击“Add” 按钮，新建一个监听器，输人名称、监听器类型、团队服务器IP地址、监听的端口，然后单击“Save”按钮保存设置，如下图。
2、使用 Web Delivery 执行Payload 单击 “Attacks” 菜单，选择”Web Drive-by”→”Scripted Web Delivery”选项，如下图。
或者通过快捷功能区，打开“Scripted Web Delivery”窗口，如下图。 保持默认配置,选择已经创建的监听器，设置类型为PowerShell,然后单击“Launch”按钮，如下图。
最后，将Cobalt Strike生成的Payload完整地复制下来
成功上线
免责声明
该项目仅供授权下使用，禁止使用该项目进行违法操作，否则自行承担后果，请各位遵守《中华人民共和国网络安全法》！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880721eb3555597790122164497c21c7/" rel="bookmark">
			【Python基础】如何获取昨天的日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 获取昨天的日期 在获取一些证券数据统计网站的数据的时候，最新的数据往往是前一天的，遇到类似的网站的时候，我们常常需要获取昨天的日期。
要使用 Python 获取昨天的日期，可以使用Python内置的 datetime 模块。具体步骤如下：
# 1.导入datetime模块 import datetime # 2.获取当前日期 today = datetime.date.today() # 3.计算昨天的日期 yesterday = today - datetime.timedelta(days=1) # 4.打印昨天的日期 print("Yesterday was:", yesterday) 输出结果如下：
Yesterday was: 2023-08-11 在上面第3步中，我们使用 timedelta 函数计算了当前日期的前一天，并将结果存储在yesterday变量中。
2 获取指定日期的前一天日期 timedelta 方法的另外一个作用是，我们可以指定一个日期，然后计算它的前一天是几月几号。
例如，下面的代码演示了如何计算2023年8月13日的前一天日期：
import datetime # 导包 date = datetime.date(2023, 8, 13) # 创建对象 yesterday = date - datetime.timedelta(days=1) # 计算日期 print("Yesterday was:", yesterday) 输出结果如下：
Yesterday was: 2023-08-12 在这个示例中，我们创建了一个 datetime 对象，它代表了2023年8月13日。然后使用 timedelta 函数计算了前一天的日期，并将结果存储在yesterday变量中。最后打印了昨天的日期。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/880721eb3555597790122164497c21c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba94ef4d5347003b710206e493340d7a/" rel="bookmark">
			JSON序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化：将java对象转换为字节序列反序列化：把字节序 举个例子，假如我们要对Student类对象序列化到一个名为student.txt的文本文件中，然后再通过文本文件反序列化成Student类对象：
其实序列化：将一个对象转化为一种格式，能够更好的传输和电脑理解。
反序列化就是转换过来，便于人们观看的。 JSON的基本格式
对象 {
}
或 数组 [ ]
JOSN的序列化省略了比如需要对对象里的方法一一调用，并且自定义格式输出。
这个是对象的输出格式
//JSON序列化 ObjectMapper mapper=new ObjectMapper(); // try { for (User user : users) { String s = mapper.writeValueAsString(user); System.out.println(s); } } catch (JsonProcessingException e) { e.printStackTrace(); } 数组的输出格式
//JSON序列化 ObjectMapper mapper=new ObjectMapper(); try { String s = mapper.writeValueAsString(users); System.out.println(s); } catch (JsonProcessingException e) { e.printStackTrace(); } JOSN的反序列化
//JOSN反序列化 ObjectMapper mapper=new ObjectMapper(); //JSON实例化对象 File jsonfile =new File("./data/users.json"); //采用apace。common。io 实例化对象 读入文件 try { String content = FileUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba94ef4d5347003b710206e493340d7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870618261973bbade260d8dc9d1968cf/" rel="bookmark">
			Linux查看GPU显卡/CPU内存/硬盘信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显卡信息命令/CPU内存/硬盘 1.显卡2、CPU内存3、硬盘 1.显卡 nvidia-smi
nvidia-smi（显示一次当前GPU占用情况）
nvidia-smi -l（每秒刷新一次并显示）
watch -n 5 nvidia-smi （其中，5表示每隔6秒刷新一次终端的显示结果）
表头释义：
Fan：显示风扇转速，数值在0到100%之间，是计算机的期望转速，如果计算机不是通过风扇冷却或者风扇坏了，显示出来就是N/A；
Temp：显卡内部的温度，单位是摄氏度；
Perf：表征性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能；
Pwr：能耗表示；
Bus-Id：涉及GPU总线的相关信息；
Disp.A：是Display Active的意思，表示GPU的显示是否初始化；
Memory Usage：显存的使用率；
Volatile GPU-Util：浮动的GPU利用率；
Compute M：计算模式；
下边的Processes显示每块GPU上每个进程所使用的显存情况。
GPU：编号
Fan：风扇转速，在0到100%之间变动，这里是42%
Name：显卡名，这里是TITAN X
Temp：显卡温度，这里是69摄氏度
Perf：性能状态，从P0到P12，P0性能最大，P12最小
Persistence-M：持续模式的状态开关，该模式耗能大，但是启动新GPU应用时比较快，这里是off
Pwr：能耗
Bus-Id：涉及GPU总线的东西
Disp.A：表示GPU的显示是否初始化
Memory-Usage：现存使用率，这里已经快满了
GPU-Util：GPU利用率
Compute M.：计算模式
参考查看Linux服务器内存、CPU、显卡、硬盘使用情况，链接：https://www.jianshu.com/p/0aed4feba213
https://www.cnblogs.com/wsnan/p/11769838.html
CUDA版本
1.查看当前安装的版本（nvcc -V）
系统自带：通过nvcc(NVIDIA Cuda compiler driver)命令可查看本机安装的CUDA版本:nvcc -V
nvcc -V查看的是系统自带的cuda的版本。
虚拟环境中：要看虚拟环境中的版本，查看pip包或者要导入pytorch和tensorflow库进行测试 pytorch中：print(torch.__version__)和tensorflow中：conda list | grep cuda直接在终端里，打开相应环境，进行查看
2.查看能支持的最高CUDA版本（nvidia-smi）
通过nvidia-smi 命令可查看本机的Nvidia显卡驱动信息，以及该驱动支持的最高的CUDA版本。nvidia-smi，例如下面的CUDA Version就是我的电脑上面能够安装的最高版本的CUDA，并且该版本号是向下支持的，可以安装低于该版本号的所有CUDA套件 释放显卡内存
在Ubuntu运行代码的时候，有时会出现代码退出了，显存依然在占用的情况。
1、#批量清理显卡中残留进程：(批量包含其他信息时不行，要用/dev/nvidia*设置成指定哪个进行批量kill如：/dev/nvidia0) sudo fuser -v /dev/nvidia* |awk '{for(i=1;i&lt;=NF;i++)print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/870618261973bbade260d8dc9d1968cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83388a58c9c60cc6f29891b7c5dc2c09/" rel="bookmark">
			c&#43;&#43; cpp cmake opencv 深度学习模型 推理 前向部署 代码示例示意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考实现：
https://github.com/spmallick/learnopencv/tree/master/AgeGender
文件结构：
具体实现：
#include &lt;opencv2/imgproc.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/dnn.hpp&gt; #include &lt;tuple&gt; #include &lt;iostream&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;iterator&gt; using namespace cv; using namespace cv::dnn; using namespace std; tuple&lt;Mat, vector&lt;vector&lt;int&gt;&gt;&gt; getFaceBox(Net net, Mat &amp;frame, double conf_threshold) { Mat frameOpenCVDNN = frame.clone(); int frameHeight = frameOpenCVDNN.rows; int frameWidth = frameOpenCVDNN.cols; double inScaleFactor = 1.0; Size size = Size(300, 300); // std::vector&lt;int&gt; meanVal = {104, 117, 123}; Scalar meanVal = Scalar(104, 117, 123); cv::Mat inputBlob; inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, size, meanVal, true, false); net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83388a58c9c60cc6f29891b7c5dc2c09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ddec028333d322d740f6d8d379d7364/" rel="bookmark">
			cilium ebpf helper函数bpf_redirect/peer/neigh
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面分析不同模式下报文路径时，用到了如下几个bpf helper函数，对转发性能提供了很大帮忙，这里分析下他们的
实现原理，先概述下每个函数的作用
bpf_redirect: 将报文重定向到指定接口，通过参数flags表示执行入向还是出向流程 bpf_redirect_peer: 将报文重定向到指定接口的peer，比较典型的是veth的peer，执行的是入向流程 bpf_redirect_neigh: 将报文重定向到指定接口，其中会查找路由表和邻居表后直接将报文从出接口发出 函数源码分析
enum { BPF_F_INGRESS	= (1ULL &lt;&lt; 0), }; /* Internal, non-exposed redirect flags. */ enum { BPF_F_NEIGH	= (1ULL &lt;&lt; 1), BPF_F_PEER	= (1ULL &lt;&lt; 2), BPF_F_NEXTHOP	= (1ULL &lt;&lt; 3), #define BPF_F_REDIRECT_INTERNAL	(BPF_F_NEIGH | BPF_F_PEER | BPF_F_NEXTHOP) }; bpf_redirect
设置接口索引和flags，如果flags为BPF_F_INGRESS，则将skb-&gt;dev设置为ifindex指定的dev，并将报文enqueue_to_backlog到cpu队列，下次软中断再处理报文，就像报文从ifindex指定的接口接收。如果不指定BPF_F_INGRESS，则执行dev_queue_xmit将报文从ifindex指定的接口发送出去
BPF_CALL_2(bpf_redirect, u32, ifindex, u64, flags) { struct bpf_redirect_info *ri = this_cpu_ptr(&amp;bpf_redirect_info); if (unlikely(flags &amp; (~(BPF_F_INGRESS) | BPF_F_REDIRECT_INTERNAL))) return TC_ACT_SHOT; ri-&gt;flags = flags; ri-&gt;tgt_index = ifindex; return TC_ACT_REDIRECT; } bpf_redirect_peer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ddec028333d322d740f6d8d379d7364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0948e4f0b25d809c53a7fd818476a80/" rel="bookmark">
			tp6 v3微信退款
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * @Notes:退款 * @param $out_trade_no 支付时候订单号（order表 original_bn）两个参数选一个这个要选对 * @param $out_refund_no 退款订单号 * @param $total 订单金额 * @param $refund 退款金额 * @Time: 2023-08-10 */ public function refundMoney($out_trade_no , $out_refund_no , $total , $refund) { $config = config('wechat.wechat'); $time=time(); $refundData=[ 'out_refund_no'=&gt;$out_refund_no,	//退款订单号自己生成就好 'reason'=&gt;'商品退款', 'notify_url'=&gt;$config['pay']['refundNotifyUrl'],//退款回调地址 'out_trade_no' =&gt; $out_trade_no, 'amount'=&gt;[ 'refund'=&gt; $refund, //退款标价金额，单位为分，可以做部分退款 'total'=&gt; $total, //订单总金额，单位为分 'currency'=&gt;'CNY' ] ]; $url='https://api.mch.weixin.qq.com/v3/refund/domestic/refunds'; $urlarr = parse_url($url); //拆解为：[scheme=&gt;https,host=&gt;api.mch.weixin.qq.com,path=&gt;/v3/pay/transactions/native] $mchid =$config['pay']['merchantId'];//商户ID $xlid = $config['pay']['serialNumber'];//证书序列号 $refundData=json_encode($refundData); $nonce = $this-&gt;randomString(); $key = $this-&gt;getSign($refundData,$urlarr['path'],$nonce,$time); $token = sprintf('mchid="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0948e4f0b25d809c53a7fd818476a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98cf1466897fb63a42b6e927894562f/" rel="bookmark">
			C&#43;&#43;（.）和（-＞）运算符用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++点运算符（.）和箭头运算符（-&gt;）运算符用法总结 1. 概述2. 点运算符用法3. 箭头运算符用法4. 实例 1. 概述 在C++中，点运算符（.）用于访问类的成员变量和成员函数，而箭头运算符（-&gt;）用于通过指针访问类的成员变量和成员函数。
2. 点运算符用法 访问类的成员变量：对象名.成员变量名
访问类的成员函数：对象名.成员函数名(参数列表)
3. 箭头运算符用法 访问指针指向的对象的成员变量：指针-&gt;成员变量名
访问指针指向的对象的成员函数：指针-&gt;成员函数名(参数列表)
需要注意的是，箭头运算符只能用于指向类对象的指针，而不能用于普通对象。
4. 实例 例如，假设有一个名为“person”的类，其中包含成员变量"name"和成员函数"sayHello"：
class Person { public: string name; void sayHello() { cout &lt;&lt; "Hello, my name is " &lt;&lt; name &lt;&lt; endl; } }; 然后，我们可以使用点运算符和箭头运算符来访问类的成员：
Person p1; // 创建一个Person对象 p1.name = "Alice"; // 使用点运算符访问成员变量 p1.sayHello(); // 使用点运算符调用成员函数 Person* p2 = new Person(); // 创建一个指向Person对象的指针 p2-&gt;name = "Bob"; // 使用箭头运算符访问成员变量 p2-&gt;sayHello(); // 使用箭头运算符调用成员函数 delete p2; // 删除指针对象 总结起来，点运算符和箭头运算符是C++中常用的运算符，用于访问类的成员变量和成员函数，具有一定的区别和使用限制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e63fc88c297cbba45d7ebb2c4086e7/" rel="bookmark">
			简单几步，自动释放Docker占用空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Docker技术的广泛应用，容器化应用越来越普及，但是在使用过程中，可能会遇到磁盘空间不足的问题。本文将介绍几种清理Docker占用的磁盘空间的方法，并给出相应的建议。
本文来自公众号微技术之家。
今天介绍五种清理Docker占用的磁盘空间的方法：清理未使用的容器、清理未使用的镜像、清理临时文件、清理指定容器的临时文件和自动清理。
清理未使用的容器：使用以下命令可以清理所有未运行的容器： docker rm $(docker ps -a -q) 该命令会删除所有未运行的容器。如果你只想删除一个特定的容器，可以使用容器的 ID 或名称作为参数。
清理未使用的镜像：使用以下命令可以清理所有未使用的镜像： docker image prune 该命令会删除所有未使用的镜像。如果你只想删除特定的镜像，可以使用镜像的 ID 或名称作为参数。
清理临时文件：使用以下命令可以清理 Docker 生成的临时文件： docker system prune -a 该命令会删除所有未使用的容器、镜像和临时文件。
清理未使用的容器：如果要清理stop状态的容器，可以使用以下命令： docker container prune 该命令会删除所有未运行的容器，但保留未使用的镜像和临时文件。
自动清理：你可以编写一个脚本，将这些命令组合起来并定期运行。 例如，你可以创建一个 cron 任务来定期清理 Docker 空间。下面给一个简单的 cron 任务示例，每周日的凌晨 1 点清理 Docker 空间：
0 1 * * sun /path/to/cleanup_docker.sh 在终端里输入命令 “crontab -e” 以编辑当前用户的cron任务列表，加入上述命令，然后在 /path/to/cleanup_docker.sh 中，可以将清理命令组合起来，例如：
#!/bin/bash # 清理临时文件 docker system prune -a # 清理未使用的容器 docker container prune 需要将 /path/to/cleanup_docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52e63fc88c297cbba45d7ebb2c4086e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc1ee774907bcbee28dad56a17e2884/" rel="bookmark">
			体渲染原理及WebGL实现【Volume Rendering】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		体渲染（Volume Rendering）是NeRF神经场辐射AI模型的基础，与传统渲染使用三角形来显示 3D 图形不同，体渲染使用其他方法，例如体积光线投射 (Volume Ray Casting)。本文介绍体渲染的原理并提供Three.js实现代码，源代码可以从Github下载。
推荐：用 NSDT编辑器 快速搭建可编程3D场景。
1、体渲染基础 体渲染是基于图像的方法，通过沿 3D 体积投射光线，将 3D 标量场渲染为 2D 图像。 我们在屏幕上看到的每个像素都是光线穿过立方体并按一定间隔从体素获取强度样本的结果。
但是我们如何投射光线呢？
一个简单的选择是使用大小为 (1,1,1) 的 3D 网格立方体，并在两个不同的渲染通道中渲染正面和背面（启用和禁用背面剔除）。
对于屏幕中生成的每个立方体片段，我们可以创建一条从立方体正面开始并在背面结束的射线。 有了光线的起点和终点，我们就可以开始对体素进行采样，以生成最终的片段颜色。
标量场表示为包含每个 (x,y,z) 位置处的强度值的体素
面我们将解释使用 WebGL 和 ThreeJS 实现体渲染的实现步骤。
2、准备原始文件 原始文件是非常简单的文件，仅包含体素强度，它们没有标头或元数据，并且通常每个体素具有按 X、Y 和 Z 顺序排列的 8 位（或 16 位）强度值。
在 OpenGL 或 DirectX 中，我们可以将所有这些数据加载到专门设计的 3D 纹理中，但由于 WebGL 目前不支持存储或采样 3D 纹理，因此我们必须以 2D 纹理可以使用的方式存储它 。 因此，我们可以存储一个 png 图像文件，其中所有 Z 切片一个挨着一个，形成 2D 切片的马赛克。 我开发了一个非常简单的转换器工具，其中包含源代码。 该工具获取原始文件并生成一个 png 图像马赛克，对 alpha 通道中每个体素的强度进行编码（尽管理想的是将 png 存储为 A8 格式只是为了节省一些空间）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dc1ee774907bcbee28dad56a17e2884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482adcbed360e3bcfd6cf97c6d28af27/" rel="bookmark">
			JS字符串截取方法（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天浅浅地总结下常用的字符串截取方法，希望对大家有帮助... 1. substr() function： 截取从指定下标开始指定长度的字符
grammar： str.substr(start, length)
parameter - statr：必传项 起始点下标（正负皆可）为负数时 从尾部开始计算位置
parameter - length：可选项 截取长度 如果不传值 默认截取到末尾 （不能为负数）
note：改方法不会改变原字符串
let str = 'abcdefg' console.log(str.substr(1,2)) // 'bc' console.log(str.substr(1,-2)) // '' console.log(str.substr(1)) // 'bcdefg' console.log(str.substr(-2)) // 'fg' 2. substring() function： 截取两个指定下标之间的字符
grammar：str.substring(from, to)
parameter - from：指定的开始下标 （不可为负数）
parameter - to：指定的结束下标 （不可为负数）
note：
1. from或者to存在负数时 会被替换为0
2. from和to相等时 返回空字符串
3. from的值小于to的值 他们的值会相互替换
4. 返回的字符包括开始下标对应的字符 不包括结束下标对应的字符
let str = 'abcdefg' console.log(str.substring(1,5)) // 'bcde' console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482adcbed360e3bcfd6cf97c6d28af27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6441e4eaf2e1278c2eb99bf751d289f0/" rel="bookmark">
			Java 编程基础：40 道选择题带你掌握核心概念 大学期末考试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然可以！以下是一些关于Java编程的选择题，每道题后面都附有正确答案和简要解释。
Java中基本数据类型不包括：
a) int
b) float
c) boolean
d) string
答案：d) string（Java中的基本数据类型不包括字符串，字符串是引用数据类型。）
在Java中，下列哪个关键字用于定义一个类？
a) class
b) struct
c) type
d) interface
答案：a) class（用class关键字来定义一个类。）
下列哪个选项在Java中用于创建一个对象？
a) new
b) create
c) instantiate
d) object
答案：a) new（使用new关键字来创建一个对象。）
下列哪个关键字用于定义接口？
a) interface
b) class
c) implements
d) extends
答案：a) interface（用interface关键字来定义接口。）
在Java中，以下哪种访问修饰符将成员声明为“包内可见”？
a) public
b) protected
c) private
d) default
答案：d) default（没有使用任何访问修饰符时，默认为包内可见。）
下列哪种循环结构会在循环开始之前先执行一次循环体？
a) for
b) while
c) do-while
d) loop
答案：c) do-while（do-while循环会先执行一次循环体，然后再判断条件。）
在Java中，用于存储不同数据类型的容器是：
a) Array
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6441e4eaf2e1278c2eb99bf751d289f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67624c55e64c45a6c29aa05a3714a2f/" rel="bookmark">
			WPF圆形按钮样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、代码实现 前言 WPF圆形按钮样式设计思路：在button 里重新设计Template，主要包括设计Ellipse边框以及填充颜色。 提示：以下是本篇文章正文内容，下面案例可供参考
一、代码实现 效果图如下所示：
代码如下（示例）：
&lt;ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt; &lt;Style x:Key="roundedButtonStyle" TargetType="Button"&gt; &lt;Setter Property="Width" Value="100"/&gt; &lt;Setter Property="Height" Value="100"/&gt; &lt;Setter Property="Foreground" Value="White"/&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="{x:Type Button}"&gt; &lt;Grid&gt; &lt;Ellipse Name="roundButtonBackground" StrokeThickness="0.5" Fill="red"&gt; &lt;Ellipse.Stroke&gt; &lt;LinearGradientBrush StartPoint="0,0" EndPoint="0,1"&gt; &lt;GradientStop Offset="0" Color="Gray"&gt;&lt;/GradientStop&gt; &lt;GradientStop Offset="1" Color="LightGray"&gt;&lt;/GradientStop&gt; &lt;/LinearGradientBrush&gt; &lt;/Ellipse.Stroke&gt; &lt;/Ellipse&gt; &lt;Ellipse Margin="15,5,15,50"&gt; &lt;Ellipse.Fill&gt; &lt;LinearGradientBrush StartPoint="0,0" EndPoint="0,1"&gt; &lt;GradientStop Offset="0" Color="WhiteSmoke"&gt;&lt;/GradientStop&gt; &lt;GradientStop Offset="1" Color="Transparent"&gt;&lt;/GradientStop&gt; &lt;/LinearGradientBrush&gt; &lt;/Ellipse.Fill&gt; &lt;/Ellipse&gt; &lt;ContentPresenter Name="GelButtonContent" VerticalAlignment="Center" HorizontalAlignment="Center" Content="{TemplateBinding Content}"/&gt; &lt;/Grid&gt; &lt;ControlTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67624c55e64c45a6c29aa05a3714a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6ca1256bd851044efab206fdf2ecef/" rel="bookmark">
			C# 中的反射与示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 中的反射与示例 ​ 在本文中，我将通过示例讨论C# 中的反射。C# 中的反射确定或检查程序集的内容。可以使用反射动态创建类型的实例、将类型绑定到现有对象，或者从现有对象获取类型并调用其方法或访问其字段和属性。在这篇文章中，将讨论什么是 C# 中的反射，如何实现反射，最后，我们将讨论何时在 C# 中使用反射。
一、C# 中的反射是什么？
​ 想要确定或检查程序集的内容时，需要进行反射。在这里，内容是指程序集的元数据，例如该程序集中的方法是什么、该程序集中的属性是什么、它们是公共的还是私有的等等。
​ 反射的最大实现之一是 Visual Studio 本身。假设，在 Visual Studio 中，我们创建了一个 String 类的对象，当我们按 obj. 然后 Visual Studio Intelligence 显示该对象的所有属性、方法、字段等，如下图所示。
二、如何在C#中实现反射？
​ 实现反射是一个三步过程。步骤如下。
导入反射命名空间获取对象的类型浏览对象的元数据 ​ 首先，我们需要导入 Reflection 命名空间，然后我们需要获取对象的类型，一旦我们获取了对象的类型，那么我们就可以去浏览元数据，即浏览方法、属性、变量等等。
​ 例如，使用反射显示 SomeClassLibrary 程序集的属性、方法和变量，如下实例代码所示：
using System; //Step1: 导入 Reflection namespace using System.Reflection; namespace ReflectionDemo { class Program { static void Main(string[] args) { //Step2: 获取类型 //获取程序集信息 var MyAssembly = Assembly.LoadFile(@"D:\Projects\ReflectionDemo\SomeClassLibrary\bin\Debug\SomeClassLibrary.dll"); //获取类信息 var MyType = MyAssembly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6ca1256bd851044efab206fdf2ecef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64b81eb4255b96d5f4c0329a805e6bd/" rel="bookmark">
			VMware安装win11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装环境 虚拟机版本：VMware Workstation17
准备好win11的镜像
安装 1、新建虚拟机 打开vmware Workstation，新建虚拟机
2、选虚拟机配置类型 选择自定义还是典型都可以，自定义里面可以自己设置某些分配，典型也没有任何问题，一般都选择自定义，然后下一步
3、虚拟机兼容性设置 虚拟机向下兼容，高版本兼容低版本，默认就可以，这个功能一般是在导入其他版本的虚拟机出现不兼容的时候才进行配置
4、镜像选择 系统的镜像在电脑上的哪个位置，可以通过浏览直接选择，也可以稍后进行选择，这里选择稍后创建
5、选择系统版本 选择系统版本必须要跟你的镜像相互匹配，不匹配会导致安装失败等各种问题
这里是安装win11，使用的是win11的镜像，所以这里就选择windows 11的版本
6、安装路径以及名字 虚拟机的名称和安装路径，名字可以任意（一般根据虚拟机的用途去命名），这里默认，路径就自己去进行分配，尽量不要在c盘，虚拟机会占用很大的空间，导致c盘爆满，进而导致系统出现问题
7、加密操作 设置虚拟机的加密类型以及密码（密码根据提士要满足8位）
勾选在此计算机上的凭据管理器中的密码，后续打开系统就不需要再输入加密密码，不勾选每次都需要输入
忘记密码结果
8、引导类型 这里无法选择BIOS，因为上面已经了加密
9、处理器分配 不能超过物理主机的最大值，后续可以更改
10、内存分配 不能超过物理主机的最大值，后续可以更改
11、网络类型 这个无所谓，随便选择，后续也能修改
12、I/O控制器 默认就行
13、磁盘类型 默认就行，选择其他的也可以，这个需要根据物理机以及存储虚拟化的实时情况来划分才能体现最佳性能
这里是虚拟机，而且是自己用，就无所谓了，默认就行
有兴趣可以学习下虚拟化或者存储的相关的一些知识
14、虚拟磁盘 选择创建新虚拟磁盘
虚拟磁盘可以迁移到其他虚拟机中使用
15、容量分配 不要选择立即分配，立即分配理论上是直接占用物理机上分配的空间给虚拟机来使用，但是在使用中也会也会随着数据的添加而变大（不知道这是bug还是设计如此，目前up主本人并没有查到相关资料），造成空间的极大浪费，所以这里不勾选立即分配
下面的拆分单个还是多个文件，默认的多个就行，看你是怎么需求的，在使用中没有什么区别
16、硬盘的名字 虚拟硬盘在物理机中的名字，创建之后可以打开物理机的路径进行查看
17、完成创建虚拟机 这里有完成和自定义硬件，如果前面步骤4没有选择镜像，这里可以通过自定义硬件设置镜像
直接选择完成也可以在编辑中找到这个设置，这里选择完成，方便步骤的完整演示
前面如果选择了镜像，这里直接选择完成就可以开机了
18、镜像选择 选择编辑虚拟机设置
在硬件中选择CD/DVD
第一次安装系统是通过镜像来引导，所以在设备状态勾选启动时连接（系统安装成功后这个可以取消勾选，windows系统就不需要了）
19、开启虚拟机 出现这个界面按任意键就能加载镜像
出现这个界面重启虚拟机，出现上面的那个界面按任意键就能加载镜像
20、开始加载镜像 21、语言和首选项设置 之后的设置根据提示各种下一步就可以了
22、现在安装 新创建的，现在安装
23、激活设置 产品密钥可以先不输入，点击我没有产品秘钥
24、系统版本选择 25、声明 是否同意
26、安装 选择自定义安装，不是升级系统，这里是安装系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c64b81eb4255b96d5f4c0329a805e6bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5a802877a13c94ecc1529ea37f632c/" rel="bookmark">
			JAVA学习：将字符串转成数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在面试时，面试官问的第一个问题就是如何将字符串转化成数字
我心想太简单了：用int 的封装类型对象Integer 中有一个parseInt（）方法可将传入参数的字符串转换成数字 如下图
String str= "123456"; int num=Integer.parseInt(str); System.out.println(num); 但是，面试官说不对，说要用String 的valueof（）方法转成数字，回到学校亲自实践后了解 当我们的字符串为纯数字时才可以使用parseInt（）方法解析，否则 当字符串中含有除数字以外的字符时 会报数字格式化异常：
String str= "abc123456"; int num=Integer.parseInt(str); System.out.println(num); 尝试使用integer 的valueof方法将字符串转换成数字 public class FindAllNum { public static void main(String[] args) { String aaa="12141"; int a=Integer.valueOf(aaa); System.out.println(a); } } 尝试当字符串中含有其他类型字符时，再次尝试取出数字，发现依然会爆出异常
public class FindAllNum { public static void main(String[] args) { String str= "a1v2b3s45w6"; // String aaa="12141"; int a=Integer.valueOf(str); System.out.println(a); } } 尝试使用Integer 的valueof ()方法 也可以取出字符中的数值，但是与parseInt 功能类似，当出现字符串时都会报出数字格式化异常，不同的时valueof 返回的时int的封装类型对象， 而parseInt返回的时int 基本数据类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5a802877a13c94ecc1529ea37f632c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b41e97502ae500759b7e58915d5d7ee/" rel="bookmark">
			C# 委托（delegate）和事件（event）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 委托和事件 委托的概念 delegate C/C++中函数指针的 “升级版”
表示函数的变量类型，用来存储、传递函数，是函数的容器，存储的就是一系列具有相同签名和返回回类型的方法的地址
委托的本质是一个类（class）引用数据类型，用来定义函数的类型（返回值和参数的类型）
委托是函数的模板，不同的函数必须对应和各自“格式”一致的委托
委托的使用 namespace Test { // 声明语法： 访问修饰符（delegate的访问修饰符默认为public） delegate关键字 返回值 委托名(参数列表) public delegate int Calculate(int x, int y); // 声明委托类型 public class Test { // 委托作为类的成员，向外提供 += -= 订阅方法 public void Addfunc(Calculate func) { calculate += func; } public void Removefunc(Calculate func) { calculate -= func; } public Calculate? calculate; // 定义委托变量 // 不需要使用 new 关键字来初始化委托对象，因为委托变量本身就是一个对象。在声明委托变量时，变量被赋值为 null，这时候委托变量没有关联任何方法。 ​ public int Add(int x, int y) { int res = x + y; Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b41e97502ae500759b7e58915d5d7ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e63490d46d6ed2b22cf75b36ff418b4/" rel="bookmark">
			Android 12 定制化开发--开启相机或麦克风时,去掉状态栏上的绿色图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android 12 或更高版本的设备上，当应用使用麦克风或相机时，图标会出现在状态栏中。如果应用处于沉浸模式，图标会出现在屏幕的右上角。用户可以打开“快捷设置”，并选择图标以查看哪些应用当前正在使用麦克风或摄像头。图 1 显示了包含图标的示例屏幕截图。
图1 摄像头和麦克风指示标志,显示了最近的数据访问 需求: 去掉状态栏上的 相机 绿色图标.
核心代码路径: frameworks/base/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
@VisibleForTesting internal companion object { val OPS_MIC_CAMERA = intArrayOf(AppOpsManager.OP_CAMERA, AppOpsManager.OP_PHONE_CALL_CAMERA, AppOpsManager.OP_RECORD_AUDIO, AppOpsManager.OP_PHONE_CALL_MICROPHONE) val OPS_LOCATION = intArrayOf( AppOpsManager.OP_COARSE_LOCATION, AppOpsManager.OP_FINE_LOCATION) val OPS = OPS_MIC_CAMERA + OPS_LOCATION val intentFilter = IntentFilter().apply { addAction(Intent.ACTION_USER_SWITCHED) addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE) addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE) } const val TAG = "PrivacyItemController" private const val MIC_CAMERA = SystemUiDeviceConfigFlags.PROPERTY_MIC_CAMERA_ENABLED private const val LOCATION = SystemUiDeviceConfigFlags.PROPERTY_LOCATION_INDICATORS_ENABLED - private const val DEFAULT_MIC_CAMERA = true + private const val DEFAULT_MIC_CAMERA = false private const val DEFAULT_LOCATION = false @VisibleForTesting const val TIME_TO_HOLD_INDICATORS = 5000L } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bd38d52916f837475d4e13fc14159af/" rel="bookmark">
			【动态规划】【前缀和与dp】2811. 判断是否能拆分数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Solution { private: int mx = 0; public: vector&lt;vector&lt;bool&gt;&gt;dp; vector&lt;vector&lt;int&gt;&gt;vis; bool dfs(vector&lt;int&gt;&amp; nums, int i, int j) { if (i == j || (j == i + 1)) { dp[i][j] = true; return true; } // cout &lt;&lt; "i,j " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; "：" &lt;&lt; endl; if (vis[i][j] == 1) { return dp[i][j]; } vis[i][j] = 1; for (int k = j -1; k &gt;= i; k--) { int sumLL = prefix[k + 1] -prefix[i]; int sumRR = prefix[j + 1] - prefix[k + 1]; if ((sumLL &lt; mx &amp;&amp; k !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bd38d52916f837475d4e13fc14159af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/891d60bc9fa17c2697db6c0e7df7dd8f/" rel="bookmark">
			Android Studio Giraffe 正式版下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 是 Android 的官方 IDE。它专为 Android 而打造，可以加快您的开发速度，帮助您为每款 Android 设备构建最高品质的应用。
比以往更快地编码和迭代 Android Studio 基于 IntelliJ IDEA 而构建，可以提供较短的编码和运行工作流周转时间。
Apply Changes
借助 Android Studio 的 Apply Changes 功能，您可以将代码和资源更改推送到正在运行的应用中，而无需重启应用（在某些情况下，甚至无需重启当前 activity）。当您要部署和测试小范围的增量更改，同时保持设备的当前状态时，这种灵活性可帮助您控制应用的重启范围。
智能代码编辑器
代码编辑器提供高级代码补全、重构和代码分析功能，可帮助您编写更好的代码，加快工作速度并提高工作效率。在您输入内容时，Android Studio 会以下拉列表的形式提供建议。只需按 Tab 键即可插入代码。
快速且功能丰富的模拟器
Android 模拟器可比实际设备更快地安装和启动应用，使您能够在各种 Android 设备配置（手机、平板电脑、Android Wear 和 Android TV 设备）上进行应用的原型设计和测试。此外，您还可以模拟各种硬件功能，例如 GPS 定位、网络延迟、移动传感器和多点触控输入。
自信地编程 在每一步，Android Studio 都会尽可能帮助您确保创建的是最佳代码。
代码模板和示例应用
Android Studio 包含项目和代码模板，使您能够轻松添加已有的功能，例如抽屉式导航栏和 ViewPager。您可以从代码模板着手，或在编辑器中右键点击某个 API 并选择“Find Sample Code”来搜索示例。您还可以直接通过“Create Project”屏幕从 GitHub 导入功能全面的应用。
Lintelligence
Android Studio 提供了一个稳健的静态分析框架，包含适用于整个应用的 365 项不同的 lint 检查。此外，它还提供了多种快速修复功能，只需点击一下，即可帮助您解决包括性能、安全性和正确性在内的各类问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/891d60bc9fa17c2697db6c0e7df7dd8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748f63f287f8b600dafa157a7db8997d/" rel="bookmark">
			MySQL插入中文，提示 SQL 错误 [1366] [HY000]: Incorrect string value: ‘\xE5\xBC\xA0\xE4\xB8\x89‘ for column ‘n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改那个字段的编码为uft8
建表语句
CREATE TABLE total_data_waijian(
id int,
name varchar(25) ,
email varchar(25) NOT NULL,
age int
);
修改编码
alter table total_data_waijian change name name varchar(255) character set utf8;
插入数据插入成功
INSERT into total_data_waijian(id,name,email,age)value(1,“黄芪”,“xiao@qq.com”,16);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beaaaf13b3c82e741f189aefea4a9723/" rel="bookmark">
			火爆全网，HttpRunner自动化测试框架-parameters参数化（超细整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 在使用HttpRunner测试过程中，可能会遇到这种场景：
账号登录功能，需要输入用户名和密码，设计测试用例后有 N 种组合情况
如果测试组合比较少，比如只有2个，那我们直接在YAML脚本中写2个 test 就行了，但如果测试组合有10个，或者上百个，我们总不可能写10个，甚至100个 test 吧？
因此，在这里我们就需要用到参数化。在HttpRunner中，通过关键字 parameters 来实现参数化数据驱动机制，不管有多少测试组合，我们只需写1个 test 就行了。
测试场景
如果不使用 parameters 来进行参数化，那么我们的用例可能就是这样的：
- config: name: login test request: base_url: http://api.nnzhp.cn - test: name: login case 1 request: url: /api/user/login method: POST headers: Content-Type: application/x-www-form-urlencoded User-Agent: Fiddler data: username: test1010 passwd: aA123456 validate: - eq: [status_code, 200] - eq: [content.error_code, 0] # 省略很多个 test - test: name: login case N request: url: /api/user/login method: POST headers: Content-Type: application/x-www-form-urlencoded User-Agent: Fiddler data: username: test101012 passwd: aA123456 validate: - eq: [status_code, 200] - eq: [content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beaaaf13b3c82e741f189aefea4a9723/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/61/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>