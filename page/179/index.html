<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a151708a033381bdcbc54c49fe84a5/" rel="bookmark">
			Mybatis：实现多表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例：在Favortie表中关联School表中的SchoolName字段
实现：
1、在Favorite表中添加School字段
目的是为了引用school表中的字段
2、在Mapper.xml文件中
使用&lt;resultMap&gt;标签，
其中id是要封装对象的名称，自命名，与标签中的resultMap对应即可
autoMapping=“true” 开启自动映射，如果列名和属性名
id:主键 result：其他键
collection一对多关联映射，写出关联的外键和需要键即可，
property：对应的属性名
ofType：是对应的完全限定名（表名）
若是三表查询，添加多一个collection标签即可，
!!!注意
&lt;select&gt;标签中原来是resultType，多表查询要使用resultMap
&lt;resultMap id="FavSch" type="Favorite" autoMapping="true"&gt; &lt;id column="favId" property="favId"/&gt; &lt;result property="userId" column="userId"/&gt; &lt;result property="schoolNo" column="schoolNo"/&gt; &lt;result property="majorNo" column="majorNo"/&gt; &lt;collection property="school" ofType="School" &gt; &lt;result column="schoolNo" property="schoolNo"/&gt; &lt;result column="schoolName" property="schoolName"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="listFav" resultMap="FavSch" &gt; select f.*,s.schoolName from tb_favorites f,tb_school s where userId = #{userId} and state=1 and f.schoolNo=s.schoolNo &lt;/select&gt; 3、其他文件照常引用即可，不一一展示
!!!注意的是：在jsp文件中，若是Favorite对象所有的属性，可直接引用，若是关联的属性，需要引用所引用对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f364fd76f2ae2f218b4c4a7d1a95223/" rel="bookmark">
			手写封装图片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编码背景 为了方便
由一张默认图和 上传的图片组成
默认图片不能删除（不需要可以从代码里删除这个版块）
技术 ： vue js
直接上代码吧
&lt;template&gt; &lt;div id="app"&gt; &lt;div class="upload"&gt; &lt;input type="file" id="file" multiple @change="upload" /&gt; &lt;/div&gt; &lt;ul class="view"&gt; &lt;li&gt; &lt;img src="../assets/logo.png" /&gt; // 默认图片换上自己的路径 &lt;div class="delect" title="删不了我" @click="noDelect"&gt;×&lt;/div&gt; &lt;/li&gt; &lt;li v-for="(item, index) in list" :key="index"&gt; &lt;img :src="item" /&gt; &lt;div class="delect" @click="delect(index)"&gt;×&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "UploadImg", data() { return { list: [], }; }, methods: { upload(e) { //e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f364fd76f2ae2f218b4c4a7d1a95223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cba0b820cf5547eafff7db48b51e363/" rel="bookmark">
			px是什么意思计算机二级,px是什么意思？照片中的px是什么的缩写？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		px是什么意思?
px(Pixel，像素)是可以在数字显示设备上显示和表示的数字图像或图形的最小单位。像素是数字图形中的基本逻辑单元。将像素组合在一起以在计算机显示器上形成完整的图像，视频，文本或任何可见的东西。像素也称为图像元素。
若把影像放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，这些小方点就是构成影像的最小单位“像素”。这种最小的图形的单元能在屏幕上显示通常是单个的染色点。像素的大小是会“变”的，也称为“相对长度”。越高位的像素，其拥有的色板也就越丰富，越能表达颜色的真实感。
px是一个相对的参数，是没有绝对的比值的，在不同的分辨率下是不同的，也就是说，像素的大小是会变的，一般情况下，像素比较高的像素，色板也就越丰富，越能表现颜色的真实感。
px不是长度单位，而是一种像素点，例如，50px就是50像素，如果是845px*338px就表示在水平方向上有845个点，在垂直方向上有338个点，像素点越多，图片越清晰。
照片中的px是什么的缩写？
PX是Pixel的缩写，用于表示分辨率的大小，是构成影像的最小单位。它表示一个区域(1英寸的正方体)中像素点的多少，如：如果一个图片的分辨率为100PX，那则表示这个图片1英寸的正方体中，有100*100个像素点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b2540534772b92f9251415d87a79a0/" rel="bookmark">
			LINUX用户管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LINUX用户管理 用户的基本概述:
用户:能够正常登录操作系统
为什么需要用户?
1.系统的每一进程(运行的程序)都需要一个特定的用户运行
2root用户的操作权限过大,容易造成故障这时就需要新建普通用户管理服务器
用户分类:
UID 系统中约定的含义
0 超级管理员
1-200 系统账户,用来运行系统自带的进程默认已经创建
201-999 系统用户,用来运行用户安装的程序,所以此类用户无需登录系统
1000 普通用户,正常可以登录系统的用户权限比较小,能执行的任务有限
查看用户ID信息
使用id命令查询当前前登录用户的信息
用户相关配置文件
当我们创建一个新的用户,系统将用户的信息存放在/etc/passwd中,而密码单独存下
/etc/shadow 中也就是说这两个文件非常重要
passwd文件
cat /etc/passwd | head -1 root:x:0:0:root:/root:/bin/bash
用户名称:root
密码占位符:x
UID:0
GID:0
注释信息:root
家目录:/root
登录的bash:/bin/bash
shadow文件
/etc/shadow 配置文件解释如下图,或者使用命令
添加用户 命令: useradd
必须在root账号下才能添加
-u 指定UID进行创建用户
-g 指定要创建的基本组
-G指定要添加的附加组
-d指定要创建的家目录
-s 指定要创建用户的bash shell
-c指定要创建用户的注释信息
-M不指定家目录
-r创建系统账户,默认无家目录
添加用户的例子:
[root@localhost ~]# useradd -u 5001 -g ops -G dev -c "whoami" -s /bin/bash oldxie ##创建用户 uid 5001 基本组 ops 附加组 dev 注释信息 “whoami” bash shell 为 /bin/bash 名称 oldxie
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b2540534772b92f9251415d87a79a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f065fcead4999e98fabd1a43b809a941/" rel="bookmark">
			安装visio2019Pro提示报错“0xC004F017“具体解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装visio2019Pro教程
安装包VisioPro2019 因为我已经安装了64位的office了，所以visio也只能安装64位的。装32位失败过了，成功不了。
解压安装 以管理员权限安装visio，并启动破解器。但是前几次激活一直显示失败，提示报错“0xC004F017“
解决办法 卸载这个序列号然后重新激活
感谢知乎这位作者提供信息
附上链接：https://zhuanlan.zhihu.com/p/149646890
具体操作 我进行的具体操作，如下图点击office产品密匙中的卸载密匙
会进入这个界面，选择你无法激活的office产品后，点击确定
最后重新点击激活按钮就可以激活成功了，亲测有效，但是不知道是不是很科学，但是对于我来说能用了就好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b108bddbb9a698d16ddc84c024f64f7/" rel="bookmark">
			Ubuntu16.04 升级python到3.6（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu16.04自带的python版本为2.7和3.5.由于3.5官方已经放弃维护，pycharm已经无法使用，所以如果想使用3.0以上版本可以选择升级python。
首先打开终端输入：sudo add-get-repository ppa:deadsnakes/ppa
更新：sudo apt-get update
下载: sudo apt-get install python3.6(期间有需要按yes)
调整python优先级，使得python版本3.6 优先级较高
sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1
sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2
修改默认版本为python3
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150
现在输入python查看就会发现python版本为3.6了
总的来说这种方法虽然可以升级python版本，但是以后想使用其他版本配置不太方便，不同项目之间的python变量也容易搞乱。所以我建议选择下面的方法使用anaconda来管理python环境变量。
anaconda3安装及其配置：https://blog.csdn.net/chen626721/article/details/118655868​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2eba0d4bc315f146c3285941a3921c9/" rel="bookmark">
			img标签alt和title属性的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		alt 主要用于img标签，在图片因为网络不良，路径错误等而无法渲染到页面时候代替其渲染到页面。（也就是说图片没法显示，就用alt的属性值代替），它会被搜索引擎所识别。
alt属性有利于SEO，是搜索引擎搜录时判断图片与文字是否相关的重要依据。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="" alt="我来替代图片" height="200" width="200" title="触碰我显示"&gt; &lt;/body&gt; &lt;/html&gt; title title是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。在IE浏览器中alt起到了title的作用，变成文字提示。
title主要的作用是面向用户体验。
从上面两张图中可以很明显得看到，无论图片是否能显示，title总是能够在页面得以使用，而alt则只能在图片显示不出来的时候才能有用武之地。
总结：alt和title两者都各有作用，alt更多的是有利于SEO，而title则更多的是增强用户的体验，在IE浏览器中alt起到了title的作用，变成文字提示，所以在需要兼容浏览器的情况下，我们最好把两个属性都写上，以保证旧版本的浏览器也能够正常展示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff2b86dfbd222e0a2b7040186ad7fd6/" rel="bookmark">
			缺少计算机所需的介质程序,win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”的图文方案...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”的图文方案?
我们在操作win10系统电脑的时候,常常会遇到win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”的问题。那么出现win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”的问题该怎么解决呢？很多对电脑不太熟悉的小伙伴不知道win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”到底该如何解决？其实只需要1、确认U盘为FAT32格式(这是GpT分区的一个弊病，只支持FAT32格式)；2、重新进入U盘pE，将解压好的镜像文件(必须是Msdn版系统镜像)，将其中Boot、efi、sources文件夹，以及bootmgr和bootmgr.efi文件复制到到C盘根目录就可以了。下面小编就给小伙伴们分享一下win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”具体的解决方法：
提示信息如下：
缺少计算机所需的介质驱动程序。这可能是dVd、U盘或者硬盘驱动程序。如果你有包含该驱动程序的Cd、dVd或U盘，请立即插入。
注意：如果windows安装介质在dVd驱动器或U盘中，你可以在这个步骤中放心地将取出。
在此之前，这位网友已将Bios设置成UEFi启动，并使用diskpart命令，创建了GpT分区，点击下一步，却出现win10.1不能安装，如上图所示的界面。
解决方法：
1、确认U盘为FAT32格式(这是GpT分区的一个弊病，只支持FAT32格式)；
2、重新进入U盘pE，将解压好的镜像文件(必须是Msdn版系统镜像)，将其中Boot、efi、sources文件夹，以及bootmgr和bootmgr.efi文件复制到到C盘根目录；
3、重启电脑，电脑就会自动运行安装程序了。
以上就是该问题的解决方法，当然如果你不想这么麻烦，那么试试在虚拟机中安装win10系统也行。
上述给大家介绍的就是win10系统UEFi安装提示“缺少计算机所需的介质驱动程序”的图文方案了，觉得本文章实用的小伙伴们，可以多多关注笔记本之家的教程哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186acb89986edf3da29aacd2f2f1400b/" rel="bookmark">
			iPhone11也支持门禁功能(iPhone11使用技巧)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理论上讲iPhone 11手机是不支持模拟门禁卡的。但是我们可以使用手机自带的NFC功能实现这一效果。下面就告诉大家具体的操作。赶紧学起来。
首先打开手机中的“钱包”应用。然后点击右上角的“+”按钮。接着我们选择一张交通卡作为自己的门禁卡。当交通卡添加成功以后我们需要找到门禁卡管理员。之后请管理员将手机的NFC信息录入到门禁系统中。这样就可以使用iPhone 11开门禁了。
iPhone 11手机的“钱包”应用不仅可以添加交通卡。还可以添加电影票。添加的方法如下：
首先打开微信App进入首页。然后点击右下角“我”选项。接着点击“支付”选项。进入后点击“电影演出赛事”选项。之后购买一张电影票。付款以后点击“返回商家”按钮。当看到页面中有二维码以后点击右下方的“添加到Wallet”按钮。这样就可以将电影票添加到iPhone 11手机的Wallet应用中。
iPhone手机中的Wallet应用集中保管您的信用卡、借记卡、商店购物卡、登机牌、电影票、优惠券和积分卡等。全都放在您的iPhone或Apple Watch的“钱包”中使用。
通过“钱包”应用。您可以使用iPhone上的凭证办理登机手续、获取和兑换回馈礼品、进入电影院或兑换优惠券。凭证可指明咖啡卡上的余额、优惠券的过期日期、音乐会的座位号等。在美国的一些学校。您或许能够在iPhone和Apple Watch上使用您的学生证。
以上就是iPhone 11手机中“钱包”应用的具体使用方法。可以说它的功能非常强大。可不能小瞧了它。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6730bb3c8e915716a90b2da38e9aaf22/" rel="bookmark">
			IDEA2020版本下载、安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载IDEA 1、IDEA2020.3.3下载地址
链接：https://pan.baidu.com/s/1mPh2Tw8nZAqM5N1A6mH0gg
提取码：dohf
2、插件下载地址
链接：https://pan.baidu.com/s/1ZShuJUxEJSQcWKKXflNc4A
提取码：dohf
二、安装IDEA 1、下载好IDEA安装程序, 双击下载的exe文件，开始安装。如下图，点击Next
2、修改安装路径（默认C盘，建议改到其他盘），如下图，点击Next
3、IDEA安装配置，勾选64位就可以，如下图，点击Next
4、选择开始菜单的快捷键文件夹，默认就好，如下图，直接点Install
5、安装完成后，直接点Finish
6、双击桌面IDEA图标，运行IDEA，然后把确认协议打勾，如下图，点击Continue
7、数据共享，看个人意愿，不愿意就点Don’t Send(不发送)，如下图
8、选择免费评估，然后点击评估，如下图
9、之后进来这个页面，先随便创建一个项目，如下图
10、创建一个springboot项目，项目SDK是本地安装的JDK，如下图，点击下一步
11、把java版本选择8，如下图，然后点击下一步
12、需要什么依赖自己选择，我这里就不弄了，直接下一步
13、改一下项目存在路径，然后点击Finish
14、进来项目后点击File–&gt;settings，如下图
15、选择插件–&gt;点击设置图标–&gt;选择从本地导入。如下图
16、然后选择下载的插件（第一步下载的那个插件），之后就会有这个插件，点应用，再点OK，如下图
17、然后点帮助—&gt;Eval复位，如下图
18、这里可以看免费试用到期时间。把每次重启自动复位打勾，然后点击复位。如下图（免费试用到期时间====复位，大家懂什么意思吧。点复位会重启IDEA）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410f31c5fcf52b400b7d836d17a9212a/" rel="bookmark">
			mysql select tmp_page.*,rownumber() over() as row_id报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pagehelper做分页
&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.6&lt;/version&gt; &lt;/dependency&gt; 出现报错
[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '() as row_id from v_zl_ice as tmp_page' at line 1 是因为pagehelper会封装你的sql，加上rownumber() over() as row_id，但是mysql根本就没有rownumber() over()这个函数，oracle，db2支持rownumber() over()。所以要换成支持mysql的版本，或者指定pagehelper连的数据库是mysql。
如下：
&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 在application.properties文件中增加
pagehelper.helperDialect=mysql pagehelper.reasonable=true pagehelper.support-methods-arguments=true pagehelper.params=count=countSql 问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ba675e1a87d46213944f5b79dbe3d7/" rel="bookmark">
			git的使用一（在日常开发中如何使用git进行代码管理的流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、从远程拉取自己一个分支
git checkout -b 分支名 origin/远程要拉取的分支名 // 创建分支
git push origin 分支名 // 推分支到远程
git branch --set-upstream-to=origin/分支名 // 建立关联
eg.从远程的master分支上拉取一个分支，作为当前版本的开发
git checkout -b feature/V0.0.1 origin/master
git push origin feature/V0.0.1
git branch --set-upstream-to=origin/feature/V0.0.1
2、将本地修改的东西提交到远程
git status // 查看当前本地的文件状态（是否修改或新建）
git add . // 将所有的文件添加到暂存区（一次性添加所有，也可 git add 某个要提交的文件路径 进行单个文件的暂存）
git commit -m '本次修改的备注' // 暂存区内容添加到本地仓库中
git push // 将本地修改的所有推上远程
eg. 当本地修改之后，进行提交
git status
git add . 或 git add src/components/ExamineTemplate/ExamItem.js git commit -m '表格的开发'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ba675e1a87d46213944f5b79dbe3d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7365c48432294a39b4ede198868f325/" rel="bookmark">
			动态合并单元格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//动态合并单元格 function uniteTable(tableId,colLength) {//表格ID，表格列数 var tb=document.getElementById(tableId); tb.style.display=''; var i = 0; var j = 0; var rowCount = tb.rows.length; // 行数 var colCount = tb.rows[0].cells.length; // 列数 var obj1 = null; var obj2 = null; //为每个单元格命名 for (i = 0; i &lt; rowCount; i++) { for (j = 0; j &lt; colCount; j++) { tb.rows[i].cells[j].id = "tb__" + i.toString() + "_" + j.toString(); } } //合并行 for (i = 0; i &lt; colCount; i++) { if (i == colLength) break; obj1 = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7365c48432294a39b4ede198868f325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20aab73548c370f1e34340ef5dbc0882/" rel="bookmark">
			mysql插入中文出错“ERROR 1366 (HY000): Incorrect string value: ‘\xE5\xBC\xA0\xE4\xB8\x89‘ for column ‘name“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux系统在向mysql中插入中文数据的时候会报错误
ERROR 1366 (HY000): Incorrect string value: '\xE5\xBC\xA0\xE4\xB8\x89' for column 'name' at row 1
这主要是因为编码造成的, 我们修改一下编码即可
第一种方法: 只修改这个表的编码格式:
&gt; alter table user convert to charset utf8;
如下图:
第二种方法: 修改mysql默认的编码格式
我们先查看数据库默认的编码格式:
&gt; show variables like '%char%';
可以看到默认是拉丁格式(latin1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b88525984b275d6d357ca0a5bbc8d9e/" rel="bookmark">
			mysql查看表分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT
partition_name part,
partition_expression expr,
partition_description descr,
table_rows
FROM information_schema.partitions WHERE
table_schema = SCHEMA()
AND table_name=‘tb_file_upload_message’;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba298a68a1bd77a70094ddd3ed7f1ec/" rel="bookmark">
			mysql数据库 mybatis查询参数传进来中文结果查不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql数据库 mybatis查询参数传进来中文结果查不到
1、servlet编码指定为UTF-8
2、tomcat编码指定为UTF-8
3、数据库连接URL后面制定为UTF-8
spring.datasource.url=jdbc:mysql://ip地址:端口号/数据库名?allowMultiQueries=true&amp;useUnicode=true&amp;characterEncoding=utf-8 4、还没解决那就是数据库的问题，修改数据库配置，添加UTF-8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d7b3b6b7f4289226d57845477fef58/" rel="bookmark">
			2021-07-08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年最新Web前端面试题精选大全及答案 目录
HTML、CSS相关
Javascript相关
三者的异同
Vue相关
55.Vue路由懒加载（按需加载路由）
React相关
react 生命周期函数
******为什么虚拟 dom 会提高性能?(必考)
(组件的)状态(state)和属性(props)之间有何不同
shouldComponentUpdate 是做什么的
react diff 原理
何为受控组件
调用 super(props) 的目的是什么
React 中构建组件的方式
小程序相关的
其他
企业中的项目流程
奇葩问题
HTML、CSS相关
1.网络中使用最多的图片格式有哪些
JPEG,GIF,PNG,最流行的是jpeg格式，可以把文件压缩到最小 在ps以jpeg格式存储时，提供11级压缩级别
2.请简述css盒子模型
一个css盒子从外到内可以分成四个部分：margin（外边距），border（边框），padding（内边距），content（内容）
默认情况下，盒子的width和height属性只是设置content（内容）的宽和高
盒子真正的宽应该是：内容宽度+左右填充+左右边距+左右边框
盒子真正的高应该是：内容高度+上下填充+上下边距+上下边框
3.视频/音频标签的使用
视频：
视频标签属性：
src 需要播放的视频地址
width/height 设置播放视频的宽高，和img标签的宽高属性一样
autoplay 是否自动播放
controls 是否显示控制条
poster 没有播放之前显示的展位图片
loop 是否循环播放
perload 预加载视频（缓存）与autoplay相冲突，设置了autoplay属性，perload属性会失效。
muted 静音模式
音频: 音频属性和视频属性差不多，不过宽高和poster属性不能用
4.HTML5新增的内容有哪些
新增语义化标签
新增表单类型
表单元素
表单属性
表单事件
多媒体标签
5.Html5 新增的语义化标签有哪些
语义化标签优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d7b3b6b7f4289226d57845477fef58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d4bea49ee2bcb0a7b1d2e0f8ba8df1/" rel="bookmark">
			CRC32查表法的原理及汇编实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRC算法简介 循环冗余校验码（CRC），简称循环码，是一种常用的、具有检错、纠错能力 的校验码，在通信中运用广泛。
CRC 计算可以靠专用的硬件来实现，但是对于低 成本的微控制器系统，在没有硬件支持下实现 CRC 检验，关键的问题就是如何通 过软件来完成 CRC 计算，也就是计算 CRC 校验和的问题。
CRC 校验的基本思想 利用线性编码理论，将发送端要传送的 K 位二进制码序列以一定的规则产生一 个校验用的 R 位监督码（既 CRC 码），并附在信息后边，构成一个新的（K+R）位 二进制码序列，并最后发送出去。在接收端则根据信息码和 CRC 码之间所遵循的 规则进行校验，以确定传送中是否出错。
CRC 码是一种线性、分组的系统码。在 K 位信息码之后再拼接 R 位的校码，
整个编码长度为 N（N=K+R）位，因此，这种编码又叫（N,K）码。CRC 校验采用多项式编码的方法，被处理的 n 比特的数据块可以看作是一个 n-1 阶的二进制多项式
例如，数据 1010111 对应的多项式为 x6+x4+x2+x+1，而多项式 x5+x3+x2+x+1
对应的数据为 101111。
多项式乘除法运算过程与普通代数多项式的乘除法相同。多项式的加减法运
算以 2 为模，加减时不进、借位，和逻辑异或运算一致。
其中模 2 除步骤如下：
（1）用除数对被除数最高几位做模 2 减，没有借位。
（2）除数右移一位，若余数最高位为 1，商为 1，并对余数做模 2 减。若余
数最高位为 0，商为 0，除数继续右移一位。
（3）一直做到余数的位数小于除数时，该余数就是最终余数。
CRC32的计算 要生成 CRC 码首先要将待发送的二进制数据 C(X)左移 R 位，然后除以生成多 项式 G(X)，这样得到的余数就是 CRC 码。CRC 码的具体生成步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8d4bea49ee2bcb0a7b1d2e0f8ba8df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08bf813009ab1b941ee0c5b3ecf1da0b/" rel="bookmark">
			干货篇 | 当CPU使用率达到100%该怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道大家有没有遇到过服务器的CPU使用率达到了100%的情况，在实际生产环境中如果遇到了这种情况我们该怎么办？
接下来我就跟大家探讨一下：当CPU的使用率达到了100%的时候我们该如何排查、定位、找出问题根源。
CPU使用率 Linux作为一个多任务操作系统，将每个CPU的时间划分为很短的时间片，然后在通过调度器轮流分配给各个任务使用，因此造成多任务同时进行的错觉。
CPU使用率：就是CPU处在非空闲状态的时间占总CPU时间的百分比
而CPU使用率中也有很多相关的重要指标，我们可以通过 top 命令简单列举出来
user（缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。nice（缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低system（缩写为 sys），代表内核态 CPU 时间。idle（缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。iowait（缩写为 wa），代表等待 I/O 的 CPU 时间。irq（缩写为 hi），代表处理硬中断的 CPU 时间。softirq（缩写为 si），代表处理软中断的 CPU 时间。steal（缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。 如何查看CPU使用率 在介绍查看CPU使用率的工具之前，我们先来想一个问题：这些性能工具是怎么计算CPU使用率的？
事实上，为了计算CPU使用率，大多数性能工具一般都会取间隔一段时间（比如3秒）的两次值作差后，再计算出这段时间内的平均CPU使用率
这个公式，就是大多数性能工具所看到的CPU使用率的实际计算方法。所以，在使用这些工具的时候我们要注意间隔时间的设置
top 工具和 ps 工具
top 和 ps 是最常用的性能分析工具，其中：
top 显示系统总体的CPU和内存使用情况，以及各个进程的资源使用情况
ps 显示每个进程的资源使用情况
sysstat 工具
除了上面这两个最常用的工具之外，我们还可以使用 sysstat 工具中的 pidstat 命令来查看进程的CPU使用率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08bf813009ab1b941ee0c5b3ecf1da0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058fae41ef1f8347c7361994ec536dfb/" rel="bookmark">
			计算机科学与未解决的难题,NP（未解难题）_百度百科
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NP的英文全称是Non-deterministic Polynomial的问题，即多项式复杂程度的非确定性问题。
中文名
外文名
NP学 科
理论信息学
收 录
P/NP问题是在理论信息学中计算复杂度理论领域里至今没有解决的问题，它被“克雷数学研究所”(Clay Mathematics Institute, 简称CMI)在千禧年大奖难题中收录。P/NP问题中包含了复杂度类P与NP的关系。1971年史提芬·古克(Stephen A. Cook) 和 Leonid Levin 相对独立的提出了下面的问题，即是否两个复杂度类P和NP是恒等的(P=NP?)。
NPP和NP
编辑
语音
复杂度类P包含所有那些可以由一个确定型图灵机在多项式表达的时间内解决的问题；类NP由所有其肯定解可以在给定正确信息的多项式时间内验证的决定问题组成，或者等效的说，那些解可以在非确定图灵机上在多项式时间内找出的问题的集合。很可能，计算理论最大的未解决问题就是关于这两类的关系的。
在2002年对于100研究者的调查，61人相信答案是否定的，9个相信答案是肯定的，22个不确定，而8个相信该问题可能所接受的公理独立，所以不可能证明或证否。对于正确的解答，有一个1,000,000美元的奖励。
NP-完全问题(或者叫NPC)的集合在这个讨论中有重大作用，它们可以大致的被描述为那些在NP中最不像在P中的。(确切定义细节请参看NP-完全)理论计算机科学家相信P、NP和NPC类之间的关系如图中所示，其中P和NPC类不交。
假设P ≠ NP的复杂度类的图解，如P = NP则三个类相同。本质上，P = NP问题问道：如果是/不是问题的正面答案可以很快验证，其答案是否也可以很快计算？这里有一个给你找点这个问题的感觉的例子。给定一个大数Y，我们可以问Y是否是复合数。例如，我们可能问53308290611是否有非平凡的因子。回答是肯定的，虽然手工找出一个因子很麻烦。从另一个方面讲，如果有人声称答案是“对，因为224737可以整除53308290611",则我们可以很快用一个除法来验证。验证一个数是除数比首先找出除数来简单得多。用于验证一个正面答案所需的信息也称为证书。所以我们的结论是，给定 正确的证书，问题的正面答案可以很快的(也就是，在多项式时间内)验证，而这就是这个问题属于NP的原因。虽然这个特定的问题，最近被证明为也在P类中(参看下面的关于"质数在P中"的参考)，这一点也不明显，而且有很多类似的问题相信不属于类P。
限制到是/不是问题并没有改变问题；即使我们允许更复杂的答案，最后的问题(是否FP = FNP)是等价的。
NP形式化定义
编辑
语音
更正式一些，一个决定问题是一个取一些字符串为输入并要求输出为是或否的问题。若有一个算法(譬如图灵机，或一个LISP或Pascal的程序并有无限的内存)能够在最多nk步内对一个串长度为n的输入给出正确答案，其中k是某个不依赖于输入串的常数，则我们称该问题可以在多项式时间内解决，并且将它置入类P。直观的讲，我们将P中的问题视为可以较快解决的问题。
假设有一个算法A(w,C)取两个参数，一个串w，也就是我们的决定问题的输入串，而另一个串C是“建议证明”，并且使得A在最多nk步之内产生“是/否”答案(其中n是w的长度而k不依赖于w)。进一步假设
w是一个答案为“是”的例子，当且仅当，存在C使得A(w,C)返回“是”。
则我们称这个问题可以在非决定性多项式时间内解决，且将它放入NP类。我们把算法A作为一个所建议的证明的检验器，它运行足够快。(注意缩写NP代表“Non-deterministic(非确定性)Polynomial(多项式)”而不是代表“Non-Polynomial(非多项式)。
NPNP完全
编辑
语音
要解决P = NP问题，NP完全的概念非常有用。不严格的讲，NP完全问题是NP类中“最难”的问题，也就是说它们是最可能不属于P类的。这是因为任何NP中的问题可以在多项式时间内变换成为任何特定NP完全问题的一个特例。例如，旅行商问题的判定问题版本是NP完全的。所以NP中的任何问题的任何特例可以在多项式时间内机械地转换成旅行商问题的一个特例。所以若旅行商问题被证明为在P内，则P = NP旅行商问题是很多这样的NP完全的问题之一。若任何一个NP完全的问题在P内，则可以推出P = NP。不幸的是，很多重要的问题被证明为NP完全，但没有一个有已知快速的算法。
NP更难问题
编辑
语音
虽然是否P=NP还是未知的，在P之外的问题是已经知道存在的。寻找国际象棋或围棋最佳走法(在n乘n棋盘上)是在指数时间内完成的。因为可以证明P ≠ EXPTIME(指数时间)，这些问题位于P之外，所以需要比多项式时间更多的时间。判定Presburger算术中的命题是否为真的问题更加困难。Fischer和Rabin于1974年证明每个决定Presburger命题的真伪性的算法有最少2^(2^cn))的运行时间，c为某个常数。这里，n是Presburger命题的长度。因此，该命题已知需要比指数时间更多的运行时间。不可判定问题是更加困难的，例如停机问题。它们无法在任何给定时间内解决。
NPP真的容易处理吗
上面所有的讨论假设了P表示“容易”而“不在P中”表示“困难”。这是一个在复杂度理论中常见而且有一定准确性的假设，它在实践中却不总是真的，原因包括如下几点：
它忽略了常数因子。一个需要101000n时间的问题是属于P的(它是线性时间的)，但是事实上完全无法处理。一个需要10-100002n时间的问题不是在P中的(它是指数时间的)，但是对于n 取值直到几千时还是很容易处理的。
它忽略了指数的大小。一个时间复杂度n1000属于P，但是很难对付。已经证明在P中存在需要任意大的指数的问题(参看时间等级定理)。一个时间复杂度2n/1000的问题不属于P，但对与n直到几千还是容易应对的。
它只考虑了最坏情况的复杂度。可能现实世界中的有些问题在多数时候可以在时间n中解决，但是很偶尔你会看到需要时间2n的特例。这个问题可能有一个多项式的平均时间，但最坏情况是指数式的，所以该问题不属于P。
它只考虑确定性解。可能有一个问题你可以很快解决如果你可以接受出现一点误差的可能，但是确保正确的答案会难得多。这个问题不会属于P，虽然事实上它可以很快求解。这实际上是解决属于NP而还不知道是否属于P的问题的一个办法(参看RP， BPP)。
新的诸如量子电脑这样的计算模型，可能可以快速的解决一些尚未知道是否属于P的问题；但是，没有一个它们已知能够解决的问题是NP完全的。不过，必须注意到P和NP问题的定义是采用象图灵机这样的经典计算模型的属于表述的。所以，即使一个量子计算机算法被发现能够有效的解决一个NP完全问题，我们只是有了一个快速解决困难问题的实际方法，而不是数学类P和NP相等的证明。
NP计算机科学家为什么认为P ≠ NP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058fae41ef1f8347c7361994ec536dfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a572f75f1c3c4384932b8743c23f9243/" rel="bookmark">
			git工具下载项目失败怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你开启vpn时，可能会引起git工具下载项目失败，此时将vpn关掉重新git clone 加上http地址就可以，之后git工具弹出弹窗,输入邮箱和密码就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d345281010fafde8b46d552311775d/" rel="bookmark">
			Oracle分割字段的值并且返回多行数据（使用regexp_substr和regexp_count函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求 需要将数据库的表中某个字段的值，根据逗号来分割后，返回多行数据。
2.实现过程 2.1REGEXP_SUBSTR() function REGEXP_SUBSTR(String, pattern, position, occurrence, modifier)
string:需要进行正则处理的字符串pattern：进行匹配的正则表达式position：起始位置，从字符串的第几个字符开始正则表达式匹配（默认为1） 注意：字符串最初的位置是1而不是0occurrence：获取第几个分割出来的组（分割后最初的字符串会按分割的顺序排列成组）modifier：模式（‘i’不区分大小写进行检索；‘c’区分大小写进行检索。默认为’c’）针对的是正则表达式里字符大小写的匹配 使用REGEXP_SUBSTR()进行逗号的匹配、字符串的分割和获取。
举个例子，这是取字符串中根据逗号分割后的第一组数据
SELECT REGEXP_SUBSTR('5FB146519670485C95E6A5C11E389CD2,8421733E4F7C4DFC8978A3BD54D2D66A', '[^,]+', 1, 1) FROM dual; 结果：
那我们现在将occurrence值动态获取并赋值给REGEXP_SUBSTR函数即可。
可以发现分割后的字符串个数= 分割符号个数 + 1
接下来获取分割符号的个数即可。
有两种方法第一种是把字符串的分割符号替换成’’，然后使用length函数计算原来字符串的长度减去替换后的字符串长度得到分割符号的个数，再加一即可。
select LENGTH('5FB146519670485C95E6A5C11E389CD2,8421733E4F7C4DFC8978A3BD54D2D66A') - LENGTH(REGEXP_REPLACE('5FB146519670485C95E6A5C11E389CD2,8421733E4F7C4DFC8978A3BD54D2D66A', ',', '')) + 1 from dual; 结果：
第二种使用regexp_count函数获取分割符号的个数。
2.2regexp_count() Oracle的11g引入此函数
REGEXP_COUNT ( source_char, pattern [, position [, match_param]])
source_char:需要进行正则处理的字符串pattern ：进行匹配的正则表达式position：起始位置，从字符串的第几个字符开始正则表达式匹配（默认为1） 注意：字符串最初的位置是1而不是0match_param：‘i’ 用于不区分大小写的匹配，‘c’ 用于区分大小写的匹配，‘n’ 允许句点(.)作为通配符去匹配换行符。如果省略该参数，则句点将不匹配换行符，‘m’ 将源串视为多行。即Oracle 将^和$分别看作源串中任意位置任何行的开始和结束，而不是仅仅看作整个源串的开始或结束。如果省略该参数，则Oracle将源串看作一行。‘x’ 忽略空格字符。默认情况下，空格字符与自身相匹配。 REGEXP_COUNT 返回pattern 在source_char 串中出现的次数。如果未找到匹配，则函数返回0。position 变量告诉Oracle 在源串的什么位置开始搜索。在开始位置之后每出现一次模式，都会使计数结果增加1。
举个例子
SELECT regexp_count('5FB146519670485C95E6A5C11E389CD2,8421733E4F7C4DFC8978A3BD54D2D66A', ',')+1 FROM dual; 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d345281010fafde8b46d552311775d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68df956d6e34020aa85702bc740e22dc/" rel="bookmark">
			STM32中HardFault问题的调试解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32中HardFault问题的调试解决 STM32中HardFault问题的调试解决 STM32中HardFault问题的调试解决 一个虽然笨重但实用的方法是将可能出问题的代码注释掉，测。反复测试定位代码出错位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa9a7e9047f4525062000aa943e98a0/" rel="bookmark">
			首篇NLP领域图神经网络综述：127页，从图构建到实际应用面面观
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Lingfei Wu等
编译：机器之心
编辑：Panda
在 Transformer 推动自然语言处理领域迅猛发展的当下，基于图神经网络的 NLP 研究也不容忽视。在近日的一篇综述论文中，来自京东硅谷研发中心、伦斯勒理工学院、浙江大学等机构和高校的研究者首次对用于 NLP 的图神经网络（GNN）进行了全面综述。其中涵盖大量相关和有趣的主题，如用于 NLP 的自动图构建、图表示学习和各种先进的基于 GNN 的编码器 - 解码器模型以及各种 NLP 任务中的 GNN 应用。本文共同一作为吴凌飞（京东硅谷研发中心）与 Yu Chen（伦斯勒理工学院）。
论文地址：https://arxiv.org/pdf/2106.06090.pdf
在解决自然语言处理（NLP）领域的各式问题时，深度学习（DL）已经成为当今的主导方法，尤其是当操作大规模文本语料时。传统的典型方法是将文本序列视为一组 token，比如 BoW（词袋）和 TF-IDF。随着近来词嵌入技术的成功，NLP 任务通常会将句子表示成 token 序列。因此，循环神经网络（RNN）和卷积神经网络（CNN）等常用深度学习技术已经在文本序列建模方面得到了广泛应用。
但是，对于大量各式各样的 NLP 问题，图结构才是最好的表示方式。举个例子，使用文本序列中的句子结构信息（比如依存关系和结构成本解析树），可通过整合特定于当前任务的知识来为原始序列数据提供增补。类似地，序列数据中的语义信息（比如摘要含义表示图和信息抽取图等语义解析图）也可用于增补原始序列数据。因此，这些图结构的数据可以编码实体 token 之间成对的关系，进而可用于学习信息更丰富的表示。
遗憾的是，在欧几里得数据（如图像）或序列数据（如文本）上具有颠覆性能力的深度学习技术却无法直接应用于图结构数据，这是因为图数据比较复杂，涉及到结构不规则和节点近邻数据大小不一致等情况。因此，这激起了图深度学习的研究浪潮，尤其是图神经网络的发展。
这波位于图深度学习和 NLP 交集处的研究浪潮已经影响到了大量 NLP 任务。在开发不同的 GNN 变体以及将它们用于许多 NLP 任务（包括分类任务、关系抽取和生成任务）上，研究社区兴趣浓厚并且已经取得了一些成功。尽管有这些成功的研究案例，但用于 NLP 的图深度学习研究仍旧面临着许多挑战：
如何将原始文本序列数据自动转换成高度结构化的图结构数据？这是 NLP 领域的一个重大问题，因为大多数 NLP 任务使用的初始输入都是文本序列。为了将图神经网络用于 NLP 问题，一大关键步骤是基于文本序列来自动构建图，进而利用其底层的结构信息；
如何确定该使用哪种合适的表示学习技术？图包括无向图、有向图、多关系图和异构图等不同形式，因此为了学习不同图结构数据的特有特征，使用针对具体情况专门设计的 GNN 是至关重要的；
如何有效地建模复杂数据？这是一个重要的挑战，因为许多 NLP 任务都涉及到学习基于图的输入和其它高度结构化输出数据（比如序列、树以及不同类型的图数据）之间的映射关系。
这篇综述首次全面总结了用于自然语言处理的图神经网络。作者表示，这篇综述对机器学习和 NLP 社区而言都是符合时宜的。其中涵盖了广泛的相关主题，包括用于 NLP 的自动图构建、用于 NLP 的图表示学习、用于 NLP 的基于各种高级 GNN 的编码器 - 解码器模型（如 graph2seq、graph2tree 和 graph2graph）以及 GNN 在各种不同 NLP 任务中的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa9a7e9047f4525062000aa943e98a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11df668f32ad7ecf9578e05ad30ce30/" rel="bookmark">
			python深度学习图像处理CSV文件分类标签图片到各个文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python深度学习图像处理CSV文件分类标签图片到各个文件夹 python深度学习图像处理CSV文件分类标签图片到各个文件夹导入库读取csv文件读取并分类图片文件分为测试集、训练集、验证集、和train_valid python深度学习图像处理CSV文件分类标签图片到各个文件夹 最近在学习沐神的深度学习课程，由于一直用的C++，python快忘光了，下面是用python处理CSV数据分类文件夹，主要代码参考李沐的深度学习代码
以一个树叶分类的数据集作例子，数据集在这儿下载简单讲解一下怎样用python将数据分类存入相应文件夹
我们下载的数据集为下图形式。images中为训练集和测试集图片，其他分别有test,train,和一个提交的模板三个csv文件
images长这样处理后会是这种，每一类的图片放在一个文件夹中
导入库 import os import math import shutil import collections import torch import torchvision 读取csv文件 读取train.csv
将文件位置存储在
data_dir = '/home/aries/d2l-zh/pytorch/classify-leaves' fname = os.path.join(data_dir, 'train.csv') 采用with打开文件
with open(fname, 'r') as f: lines = f.readlines()[1:] #从1开始,，去掉跳过文件头行 (列名) line的内容如下
lines中有图片的地址和对应的标签。
我们将lines中每一个数据集去掉空格，并分开每个，列表存入，最后放在一个字典中返回（字典最后可以根据图片地址找到相应的标签）
下面是整个的代码
def read_csv_train(fname): """读取 `fname` 来给标签字典返回一个文件名。""" with open(fname, 'r') as f: # 跳过文件头行 (列名) lines = f.readlines()[1:] tokens = [l.rstrip().split(',') for l in lines] #去掉空格，并分开每个训练图片，列表存入 return dict(((name, label) for name, label in tokens)) #字典返回返回 labels = read_csv_train(os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11df668f32ad7ecf9578e05ad30ce30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50c9d24a6a080d697781ae591fc0b4b/" rel="bookmark">
			rem适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rem: (root em),rem是css中的一种相对长度单位。相对于根元素(即html元素)font-size计算值的倍数,区别于em,em是相对于父标签元素
配置规则：
设计稿是1920px ，约定将屏幕分成若干份数，如80份
1. 计算出的结果最好不要是小数，否则会影响精度
2. 1rem默认的px大小不要太离谱 （1rem = 1920 /80 = 24px,意味着1rem===24px）那么设备宽度与rem基准值比例为 80 。
1. 分为多少份 每一份的宽度就是一个rem的宽度进行单位换算时可将 24px作为基准值( 基准值就是当前html字体大小 )即可
例如：
一个div宽度为240px 那么这个div换成rem就是 240px = 240 / (1/24) == 10rem,那么这个元素在任何设备下的大小都是10rem，只是不同屏幕下代表的px值不一样
当屏幕宽度为320时， 320 / 80 = 4 意味着1rem = 4px (10rem = 40px) 问：当一个html页面中一个 div宽度2rem html字体大小为100px 则div实际高度是多少？
答：html字体大小为100px,则基准值为100，即1rem === 100px 所以div宽为200px
// 实现rem适配 (function () { // rem参照根元素的字体大小 var setFont = function () { var html = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50c9d24a6a080d697781ae591fc0b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94b5d8e3c58405c10e37cc87d895aae/" rel="bookmark">
			NVIDIA-Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装nvidia-docker基础镜像（官网拉取，选定自己版本）
docker run --runtime=nvidia --rm nvidia/cuda:9.0-base nvidia-smi docker run --runtime=nvidia --rm nvidia/cuda:10.0-base nvidia-smi docker run --runtime=nvidia --rm nvidia/cuda:10.1-base nvidia-smi docker run --runtime=nvidia --rm nvidia/cuda:11.2-base nvidia-smi 默认下载基础镜像，并启动容器测试，是否成功（安装了nvida-docker2才行，不然会报错没有运行时）（pull手动拉取）
docker pull-nvidia/cuda:9.0-base 2、查看基础镜像，启动成容器
REPOSITORY TAG IMAGE ID CREATED SIZE nvidia/cuda 10.1-base bfa75f8b799e 3 days ago 105MB 启动容器：sudo docker run -itd --name qinghao nvidia/cuda:10.1-base /bin/bash
进入容器：sudo docker attach qinghao
低版本+需要安装nvidia-docker2才能执行上述命令
docker-19.03及以上版本已经集成了nvidia-docker，但是启动命令变了，需要指定gpu不然不行
docker run -it --gpus all --rm --name test nvida/cuda:10.1-base /bin/bash
3、换源（/etc/apt/sources.list）
deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94b5d8e3c58405c10e37cc87d895aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42569ab243d50e995f88399f6199a62/" rel="bookmark">
			Java 实现 Php 的 hash_hmac 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP 在php中hash_hmac函数就能将HMAC和一部分哈希加密算法相结合起来实现HMAC-SHA1 HMAC-SHA256 HMAC-MD5等等算法。
函数介绍如下：
string hash_hmac(string $algo, string $data, string $key, bool $raw_output = false)
algo：要使用的哈希算法名称，可以是上述提到的md5,sha1等
data：要进行哈希运算的消息，也就是需要加密的明文。
key：使用HMAC生成信息摘要是所使用的密钥。
raw_output：该参数为可选参数，默认为false，如果设为true，则返回原始二进制数据表示的信息摘要，否则返回16进制小写字符串格式表示的信息摘要（注意是16进制数，而非简单的字母加数字）。
另外：如果algo参数指定的不是受支持的算法，将返回false。
&lt;?php $data = "b-b7a3b7cc7a57fb0433fef3252c60a105"; $key = "d25b2cb97c0b5a82d887ebbc0580cce0"; $str = hash_hmac("sha1", $data, $key); echo $str."\n"; ?&gt; 运行结果：
39b46d318c7338b034d1f623a551b8ddcadb7ac0
Java public static void main(String[] args) throws Exception { String key = "d25b2cb97c0b5a82d887ebbc0580cce0"; String data = "b-b7a3b7cc7a57fb0433fef3252c60a105"; String result = getSignature(data, key); System.out.println(result); } /** * 使用 HMAC-SHA1 签名算法对data进行签名 * @param data 被签名的字符串 * @param key 密钥 * @return 加密后的字符串 */ public static String getSignature(String data, String key) throws Exception { //根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称 SecretKeySpec signinKey = new SecretKeySpec(key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42569ab243d50e995f88399f6199a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3452e25872369837843f5ab769578037/" rel="bookmark">
			一文让你轻松理解读懂KNN分类算法~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“码农的后花园”，选择“星标” 公众号
精选文章，第一时间送达
1968年由 Cover和Hart提出最近邻(K-Nearest Neighbors, KNN)算法，KNN是机器学习中有监督学习的一种分类算法，与另外一个机器学习中的无监督学习算法Kmeans类似，但是有本质区别。KNN应用场景有字符识别、 文本分类、 图像识别等领域。
K最近邻分类算法，或者说邻近算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻就是K个最近的邻居的意思，说的是每个样本都可以用它最接近的K个邻近值来代表。近邻算法就是将数据集合中每一个记录进行分类的方法。
KNN算法的思想是：一个样本A与数据集中的k个样本最相似， 如果这k个样本中的大多数样本都属于某一个类别 i， 则该样本 A也属于这个类别 i。(KNN的原理就是当预测一个新的值x的时候，根据它距离最近的K个点中多数点是属于什么类别来判断x属于哪个类别。)
左边的中间绿色的正方形的点是我们添加要预测类别的点，假设选距离该绿色正方形最近的K=3个数据集中已知类别的样本点来预测该绿色正方形点属于什么类别，可以看出距离要预测的绿色点的3个数据集中样本点中属于红色的圆形点多一些，那么该绿色的正方形就归类到蓝三角类别。
但是当K=5时，也就是选取5个距离要预测的绿色的点最近的数据集中的已知类别样本点对其（绿色的点）进行预测类别，如下图，这次距离要预测的绿色点的5个数据集中样本点中属于红色的圆形点多一些，所以将要预测的绿色的正方形点归类为红色圆类别。
这就是KNN算法的实现原理，可以知道要实现KNN算法，需要进行K值（数据集中已知类别的样本点）选取 和 预测点和数据集中所有已知类别的样本点之间的距离计算，以得到K个距离最近样本点，根据这K个已知类别的样本点中绝大多数什么类别来划分要预测点的类别。
KNN算法实现流程
为了判断未知实例的类别，以所有已知类别的实例作为参照。
1.定义选取参数K
2.计算已知类别数据集中的样本点与当前预测点之间的距离，并按距离递增次序排序
3.选取与预测点距离最近的数据集中K个已知类别的样本点
4.统计距离最近的K个样本点的类别出现的频率
5.将预测点归类为距离最近的K个样本点的类别中出现频率最高的类别
如下，距离新添加紫色点距离最近的7个点中，绿色圆点有4个，所以新加入紫色圆点的类别被判别为绿色圆点的类别。
总结：KNN算法主要的点有两个K值的选取和点距离的计算。
K值选取
在应用中，K值一般取一个比较小的数值，通常采用交叉验证法来选取最优的K值,从选取一个较小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K值。
交叉验证法是指将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如6：4拆分出部分训练数据和验证数据。
通过交叉验证计算方差得到的图如上，当增大K时，周围有更多的样本可以借鉴，分类效果会变好，错误率会先降低; 但是当K值增大一定的程度时，错误率会变高，举例来说，当你一共35个样本，K值增大到30，KNN算法就没有意义了。
距离度量计算
距离越近，就越相似，属于这一类的可能性就越大，度量空间中的点距离计算的方式分三种类别：L1范数（曼哈顿距离）、L2范数(欧式距离）、切比雪夫距离，KNN算法中使用的欧式距离。
(1)二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离：
(2)三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离：
(3)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离：
KNN算法最简单粗暴的就是将预测点与数据集中K个已知类别所有样本点距离进行计算，然后保存并排序，选出前面K个值看看哪些类别比较多。
KNN算法代码实例
定义训练数据集样本点和样本点所对应的类别，并使用scatter绘制样本点，类别为0的样本点用绿色圆点绘制，类别为1的样本点用红色圆点绘制。
import numpy as np import matplotlib.pyplot as plt # 定义训练数据集样本矩阵 raw_data_x = [[3.393533211, 2.331273381], [3.110073483, 1.781539638], [1.343808831, 3.368360954], [3.582294042, 4.679179110], [2.280362439, 2.866990263], [7.423436942, 4.696622875], [5.745051997, 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3452e25872369837843f5ab769578037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d17fedb23fa55bc18f6c227cc3be737/" rel="bookmark">
			ubuntu 系统狠慢 或者很卡的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 涉及内存小或者虚拟SWAP分区调整问题
可以通过 系统监视器 进行查看
在UBUNTU系统里面，并不是你的物理内存全部耗尽之后，系统才使用swap分区！系统的swappiness设定值，对如何使用swap分区是有着很大的联系。 swappiness=0 的时候表示最大限度使用物理内存，然后才是 swap空间
swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面
上面2个设置是极端设置，对于UBUNTU系统的默热值来说，这个值=60，如果想最佳化，可以修改为10-20左右！
1、点击 应用程序 - 附件 - 终端
2、输入下面内容查看 swappiness 的当前参数（默认应该看到的是60）
cat /proc/sys/vm/swappiness 3、输入下面内容，修改这个参数为20（执行这一步只是临时修改，如果重启又会恢复60）
sudo sysctl vm.swappiness=20 4、下面的语句可以让你保存你设定的值，首先输入：
sudo gedit /etc/sysctl.conf 然后在底部加入下面内容：
vm.swappiness=20 嘿嘿，现在你的虚拟内存使用方式，就彻底按你设定的值来修改了！ 系统默认的60,其实是60%的意思，就是保护你的内存超过60%来运行更大的程序，而使用SWAP分区作为交换肯定慢，所以通常我们根据自己的需要来作调整！当然不是说10-20就是最好的，因为你自己常用的内存需求，你肯定很清楚，所以你自己决定吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675f632de6a15e82c282854f8beff1ae/" rel="bookmark">
			基于STM32的颜色传感器TCS3472
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、TCS3472是什么？二、RGB 颜色传感器分析三、驱动TCS34723.1读取R,G,B 四、测试TCS34724.1参数测试 总结 前言 最近由于课程设计要求，用到了一款颜色传感器芯片TCS3472，可以读取物体表面三种RGB三种颜色分量。
环境 keil5 uvison
单片机：STM32ZET6，颜色传感器TCS3472
标准库驱动
串口或者WIFI读取
一、TCS3472是什么？ TCS3472 光电转换器包含一个 3×4 光电二极管阵列、四个集成光电二极管电流 的模数转换器(ADC)、数据寄存器、一个状态机和一个 I²C 接口。
3×4 光电二极 管阵列由红光、绿光、蓝光和清晰(未滤光)光电二极管组成。此外，光电二极管 还涂有红外阻挡滤光片。
四个积分 ADC 同时将放大的光电二极管电流转换为 16 位数字值。转换周期完成后，结果被传输到数据寄存器，数据寄存器采用双缓冲 方式，以确保数据的完整性。所有内部时序以及低功率等待状态都由状态机控制。
TCS3472 数据通信通过高达 400 kHz 的双线 I²C 快速串行总线完成。行业标准 I²C 总线方便了与微控制器和嵌入式处理器的轻松直接连接。除 I²C 总线外，TCS3472 还提供单独的中断信号输出。当中断使能且超过用户定义的阈值时，有效-低电 平中断将被置位，并保持置位状态，直到控制器将其清零。此中断功能无需轮询 TCS3472，从而简化并提高了系统软件的效率。用户可以定义中断阈值的上限和 下限，并应用中断持续过滤器。中断持续过滤器允许用户定义在生成中断之前所 需的连续超出阈值事件的数量。中断输出是开漏的，因此可以与其他器件进行布 线。
二、RGB 颜色传感器分析 颜色传感器用白光照射到物体，物体反射回来的光由红光、绿光、蓝光和清 晰(未滤光)光电二极管吸收，产生光电效应，并且产生光电流，四个积分 ADC 同时将放大的光电二极管电流转换为 16 位数字值。转换周期完成后，结果被传 输到数据寄存器，数据寄存器采用双缓冲方式，以确保数据的完整性。
三、驱动TCS3472 TCS3472采用IIC驱动，STM32采用IO口模拟IIc驱动
TCS3472.c
这个是用寄存器来写的，PB口，如果要改端口的话，也要改相应的寄存器。
#include "sys.h" /******************************************************************************/ #define TCS34725_ADDRESS (0x29) #define TCS34725_COMMAND_BIT (0x80) #define TCS34725_ENABLE (0x00) #define TCS34725_ENABLE_AIEN (0x10) /* RGBC Interrupt Enable */ #define TCS34725_ENABLE_WEN (0x08) /* Wait enable - Writing 1 activates the wait timer */ #define TCS34725_ENABLE_AEN (0x02) /* RGBC Enable - Writing 1 actives the ADC, 0 disables it */ #define TCS34725_ENABLE_PON (0x01) /* Power on - Writing 1 activates the internal oscillator, 0 disables it */ #define TCS34725_ATIME (0x01) /* Integration time */ #define TCS34725_WTIME (0x03) /* Wait time (if TCS34725_ENABLE_WEN is asserted) */ #define TCS34725_WTIME_2_4MS (0xFF) /* WLONG0 = 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/675f632de6a15e82c282854f8beff1ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea918ef737b152b7fe25a16834c89a9/" rel="bookmark">
			Java #垃圾回收相关算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
标记阶段：
·引用计数算法
·可达性分析算法（根搜索算法）
清除阶段：
·标记-清除（Mark-Sweep）算法
·复制算法
·标记-压缩/整理 算法
分代回收思想
增量收集算法
标记阶段： ·引用计数算法 原理：对于每一个对象，保存一个整型的引用计数器属性，有任何对象引用了该对象，引用计数器值加1，当引用失效时，引用计数器值减1。当引用计数器值为0时，表示对象不在被使用，可以进行回收。
有致命的缺点：无法解决循环引用的问题。如图1：当外部指针p断开时，发现next对象的引用计数器值永远不会为0，对象无法被回收，造成内存泄漏。导致Java虚拟机中没有使用该算法。
图1 ·可达性分析算法（根搜索算法） 原理：以根对象集合（GC Roots）为起始点，从上至下搜索对象，判断对象是否被根对象直接或间接的引用着，如果对象没有被根对象集合直接或间接的引用着，则是不可达的。
使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的环境中进行。这也是导致垃圾回收时，导致stop the world的原因。
在可达性分析算法中，只有直接或间接被根对象连接着的对象，才是存活对象。如图2：
图2 哪些结构可以作为根对象（GC Roots）：
虚拟机栈中引用的对象。比如：各个线程被调用方法中使用到的参数、局部变量等。本地方法栈内JNI（通常说的本地方法）引用的对象。方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量。方法区中常量引用的对象。比如：字符串常量池（String Table）里的引用。所有被同步锁synchronized持有的对象Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。 清除阶段： ·标记-清除（Mark-Sweep）算法 当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。
标记：Collector从引用根节点开始遍历，标记不被回收的对象，一般是在对象的Header中记录为可达对象。
清除：Collector对堆内存从头到尾进行线性遍历，将对象Header中没有标记为可达的对象，将其回收。
图3 缺点：回收后的内存是分散的，碎片状的，需要维护一个空闲列表（空闲列表：把一个地址告诉给空闲列表，空闲列表来记录这些地址是空闲的，之后数据就直接覆盖在该地址的数据）。
·复制算法 原理：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。
图4 优点：
保证空间连续性。不需要标记过程。适用于可达对象少，垃圾对象多的场景，比如surviver区（from区和to区）。 缺点：
需要两倍的内存。从栈中的引用地址需要改变（因为对象的地址改变了）。当可达的对象很多时，复制算法就不适用了。 ·标记-压缩/整理 算法 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。
图5 与标记-清除算法的区别
二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。
优点：
解决了标记-清除算法的 “碎片” 问题。解决了复制算法两倍内存的问题。 缺点：
效率没有复制算法高。移动了对象，需要改变引用地址。 分代回收思想 新生代垃圾回收频率高，存活对象少，采用复制算法。
老年代垃圾回收频率低，存活对象多，采用标记-清除算法或与标记-整理算法混合使用。
增量收集算法 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。
总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a469f9fac4645a29c76180b272fe7d36/" rel="bookmark">
			Java #对象的finalization机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象的finalization机制 当对象将被垃圾回收器回收时，在回收之前，先执行对象的 finalization()方法。所以一般不主动调用finalization()方法。如果该对象没有机会被回收，finalization()方法一般没有机会执行。
finalization()是Object类的方法，可以被子类重写。
finalization()方法的执行原理：
1、当obj对象到GC Roots没有引用链时，被标记一次。
2、判断是否执行finalization()方法，如果该对象没有重写finalization()方法，或者finalization()方法已经执行过一次后，则不执行finalization()方法。
3、如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
4、finalize()方法是对象逃脱死亡的最后机会，稍后gc会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出队列。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。
下面用代码演示该原理：
public class Main { public static MyClass1 myClass = null; public static void main(String[] args) { MyClass1 myClass1 = new MyClass1(); myClass1.name="name1"; myClass1=null; System.gc(); try { Thread.sleep(2000);//因为Finalizer的优先级很低，所以等待2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(myClass); //第二次断开GC Root引用链 myClass=null; System.gc(); try { Thread.sleep(2000);//因为Finalizer的优先级很低，所以等待2秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(myClass); } } public class MyClass1 { public static String staticStr = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a469f9fac4645a29c76180b272fe7d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813108a5d0b7028ca5a43db22d681a1f/" rel="bookmark">
			JAVA中的printf用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java沿用了C语言中的printf方法，其用法与C中的printf方法一致。下面通过几个例子来说明他的用法：
（1）用于printf的转换符有如下（这里只列出了部分）：
%n　换行　相当于 \n
%c　单个字符
%d　十进制整数
%u　无符号十进制数
%f　十进制浮点数
%o　八进制数
%x　十六进制数
%s　字符串
%%　输出百分号
转换符的类型要与打印的内容数据类型相同，如下例子中我要打印浮点数，就要使用%f
double x = 1000.0 / 3.0;
System.out.printf("%8.2f",x); // 打印结果： 333.33
（2）打印格式，标注在%之后，转换符之前，如（1）中例子中的8.2，其中8表示总共打印8个字符，精度为小数点后2位。同样的，通过修改不同的值可以打印不同的格式，如下
double x = 1000.0 / 3.0;
System.out.printf("%8.2f",x);
System.out.println();
System.out.printf("%10.2f",x);
System.out.println();
System.out.printf("%8.6f",x); （3）当打印的内容有多个参数时，要按照顺序排列在后边参数位，如下例：
double x = 1000.0 / 3.0;
double y = 2000.0 / 3.0;
System.out.printf("第一个数字是%8.6f，第二个数字是%8.6f",x,y); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e599ca5a29a0fd89734a84a27cd407/" rel="bookmark">
			JAVA中的printf方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java沿用了C语言中的printf方法，其用法与C中的printf方法一致。下面通过几个例子来说明他的用法：
（1）用于printf的转换符有如下（这里只列出了部分）：
%n　换行　相当于 \n
%c　单个字符
%d　十进制整数
%u　无符号十进制数
%f　十进制浮点数
%o　八进制数
%x　十六进制数
%s　字符串
%%　输出百分号
转换符的类型要与打印的内容数据类型相同，如下例子中我要打印浮点数，就要使用%f
double x = 1000.0 / 3.0;
System.out.printf("%8.2f",x); // 打印结果： 333.33
（2）打印格式，标注在%之后，转换符之前，如（1）中例子中的8.2，其中8表示总共打印8个字符，精度为小数点后2位。同样的，通过修改不同的值可以打印不同的格式，如下
double x = 1000.0 / 3.0;
System.out.printf("%8.2f",x);
System.out.println();
System.out.printf("%10.2f",x);
System.out.println();
System.out.printf("%8.6f",x); （3）当打印的内容有多个参数时，要按照顺序排列在后边参数位，如下例：
double x = 1000.0 / 3.0;
double y = 2000.0 / 3.0;
System.out.printf(“第一个数字是%8.6f，第二个数字是%8.6f”,x,y); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b55304d92a69a2a8b09bbd20ea68c2/" rel="bookmark">
			net::ERR_ABORTED 404 (Not Found)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用静态资源报错：net::ERR_ABORTED 404 (Not Found) ***
新加入静态资源厚，出现net::ERR_ABORTED 404 (Not Found)，但是路径没有错，在idea上也可以ctrl+鼠标左键访问到
解决方法：如果路径确定没有问题。
1、将文件复制到其它路径下，重新引入，然后保存刷新浏览器，这样新引入的那个会报404，但是之前久的报404的路径可以成功引入，然后删除新引入的路径即可。
现在久的可以正常访问到了，具体原理不知道是啥，搞了半天，恼火。
2、如果试了1还是不能解决，那么对该资源目录ctrl+F5，重启下项目即可。
目前试了两个方法可以解决这个不知道啥原因的404，前提是路径要写对。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7311a3f05d8cabcf5a59e245671a6d0/" rel="bookmark">
			多光谱行人检测（一）Multispectral Pedestrian Detection：Benchmark Dataset and Baseline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章最主要的是制作了KIAST数据集，直到现在仍有许多人使用这个数据集进行多光谱行人检测。虽然提出ACF方法在后续文章作为对比算法，但是因为深度学习的快速发展，后续工作很少基于ACF进行改进。
这篇文章提出了一个多光谱行人数据集，该数据集由基于分束器的特殊硬件捕获，提供良好的颜色-热图像对。颜色热数据集和以前基于颜色的数据集一样大，并提供了密集的注释，包括时间对应。利用该数据集，同时引入了多光谱ACF，它是聚合通道特征(ACF)的扩展，可以同时处理彩色-热图像对。多谱ACF使得ACF的平均漏检率降低了15%，实现了行人检测任务的又一突破。
文章目录 1. 主要贡献2. 数据采集3. 数据集介绍3.1 数据规模3.2 行人遮挡3.3 行人位置3.4 行人外观变化 4. 行人检测基线4.1 标准 ACF4.2 多光谱 ACF 的多光谱行人数据集的例子。它将从白天/晚上的交通场景中捕获的彩色(左列)和热(右列)图像对齐。数据集提供的绿色、黄色和红色框分别表示无遮挡、部分遮挡和重度遮挡。
1. 主要贡献 引入了多光谱行人数据集，提供了对齐的颜色和热图像对。的数据集的图像帧数和广泛使用的行人数据集一样多[10,15]。该数据集还包含以前的数据集中很少提供或讨论的夜间流量序列。分析了颜色通道和热通道的互补关系，提出了如何结合两种通道的优点，而不是单独使用颜色通道或热通道。提出了几种带有热通道的扩展ACF的组合。扩展在提出的多光谱行人数据集上减少了15%的平均漏报率。与以往大多数数据集利用彩色热立体设置相比，使用基于分束器的硬件来物理对齐两个图像域。第一个在白天和晚上提供对齐的彩色和热图像对的数据集。 2. 数据采集 硬件规格如上图所示，开发了由彩色摄像机、热摄像机、分束器和三轴摄像机夹具组成的成像硬件。
彩色相机640×480像素的空间分辨率与103.6◦垂直视野。热相机有320 × 256像素的空间分辨率与39◦垂直视野。请注意，彩色相机的视场比热成像相机大。通过牺牲彩色图像的边缘区域来使用原始热图像在对齐图像域。两个摄像头的帧率等于20fps。
相机标定。硬件的概念是由Bienkowski等人引入的，用于无损评估目的。由于[3]中没有提到对两个图像域的校准方法，所以在这里简要介绍的校准方法。首先，利用立体摄像机标定计算安装在硬件上的两个摄像机之间的平移。在这里，可以认为两个相机的光轴超过分束器是平行的，由于硬连线的安排。因此，两个图像域之间只存在平移，只使用三轴夹具调整摄像机位置，直到平移为零。调整后，两个图像域被矫正为具有相同的虚拟焦距。经过这些步骤，两个图像域具有相同的焦距和相同的主点，并且没有基线。虚拟对齐的图像域有640×512像素的空间分辨率，并有39°垂直视野，这是类似于人类的视觉。由于传统的棋盘图案在热成像相机中是无法观察到的，使用了一个特殊的标定板[16,17]，它有一些孔。当它被加热时，在板和孔之间有一个温度差，因此可以在热成像相机中观察到。图3所示为孔模式图像的示例。
硬件安装在车顶上，用于捕捉以自我为中心的交通场景图像。特别的是，在白天和晚上捕捉了各种场景，以考虑光照条件的变化。在捕获的帧中，95328对彩色热对图像进行手工标注，总共有103128个密集标注和1182个独特的行人。为了标注地面的真实情况，使用了Piotr的计算机视觉工具箱[8]，但它被修改为同时显示彩色和热图像。修改有助于注释，因为在夜间，在颜色通道中很难看到远处的行人。还修改了工具箱，为每个边界框提供遮挡标记，而不是遮挡区域。类似于Dollár等[10]，该对象有四个标签中的一个。很明显，一个行人被标记为“人”。无法区分的个体被贴上了人的标签。骑两轮交通工具的人被称为骑自行车的人。在高度混乱的场景中，即使是人类注释者有时也不能清楚地确定一个人形物体是否是行人。这个物体被标记为人?它在计算中被忽略了。在注释之后，边界框还具有指示帧上的人员索引的时间对应。在的数据集中，一个人平均出现74.80帧(相当于3.74秒)。
3. 数据集介绍 3.1 数据规模 规模。由于行人检测的关键应用是避免事故，根据车辆制动距离对标注的边界盒大小进行分类。在行人经常出现的市区，认为一般车速为30至55公里/小时。在这种驾驶条件下，预期的制动距离为11 ~ 28米(包括驾驶员反应造成的制动延迟)[7]。如果行人的高度约为1.7米，那么在对齐的图像域中，这对应于45 ~ 115像素的高度。将这些大小的注释分类为介质。如图5(a)所示，也确定了远近，即小于或大于中等。图5(b)显示了以像素为单位的行人高度与其对应的距离(以米为单位)的关系。
3.2 行人遮挡 如果一个行人突然被场景中的其他行人或物体遮挡，用三个遮挡标签中的一个来标注。没有被遮挡的行人被标记为没有遮挡;那些在一定程度上闭塞了一半以上的被标记为部分闭塞;轮廓大部分被遮挡的被标记为重遮挡。在所有标注中，75%以上的行人被标注为未遮挡(78.6%)，其余为部分遮挡(12.6%)和重度遮挡(8.8%)。
3.3 行人位置 图6 (a)是用混合高斯模型的分布表示的标注行人的中心。的硬件被设置为覆盖一般驱动程序的视图。这个设置限制了行人在特定区域的外观。因此，行人分布在图像中心的一个窄带内。行人多出现在图像的右侧，因为汽车是在右向交通条件下行驶。还在图6 (b)中以对数标准化的比例显示了每帧的行人数量。
3.4 行人外观变化 图7显示了白天和晚上行人的几个例子。由于强烈的阳光，白天的彩色图像显示出独特的人体形状。另一方面，由于黑暗的环境，夜间彩色图像中的形状无法区分。然而，热图像在夜间显示出明显的形状，因为当空气温度较低时，温差更大，所以可以清楚地捕捉到固定温度的行人在夜间。在白天，强烈的太阳辐射造成背景杂波。基于这些原因，可以期望通过全天使用彩色和热图像的优点来获得更好的性能。
4. 行人检测基线 为了有效地处理颜色和热通道，基线算法建立在聚合通道特征(ACF)行人检测器[9]的基础上。这是一种自然的选择，因为算法可以容纳显示不同模式的多个通道。例如，它使用单色图像的彩色和渐变通道。这样，热通道可以看作是该算法中另一个增强的通道。在这里，受益于的捕获硬件，因为颜色和热通道之间的对齐问题被删除。此外，ACF行人检测器被广泛用作并行最先进的行人检测器的基算法。有了这个想法，首先回顾了为彩色图像设计的标准ACF，并介绍了的扩展来额外处理热通道。
4.1 标准 ACF 对于彩色图像输入，标准ACF[9]有10个增强通道(LUV+M+O): LUV表示颜色空间的3个通道，M表示1个梯度幅值通道，O表示6个梯度直方图通道，是定向梯度直方图(HOG)[4]的简化版本。在ACF[9]中，他们利用了引导过程，从大量的底片中挖掘硬底片，并多次重新训练AdaBoost分类器[1]。最后，他们应用了一种称为软级联的有效抑制方法来提高检测时间。通过这种方法，构建了一个功能强大的行人检测框架。
4.2 多光谱 ACF 利用ACF行人检测器作为的基线，并将其扩展为热强度通道编码。对于扩展，建议三个基线:(1)ACF+T (2) ACF+T+TM+TO (3) ACF+T+THOG。ACF是前面提到的为颜色通道定义的特性。T、T+TM+TO和T+THOG表示热通道增加的额外通道特性。
T 该通道特性直接利用热强度。为了提高检测性能，使用直方图均衡化增强了图像的对比度。T + TM +TO。这个扩展包括三个渠道:T, TM和TO。T为上述热通道，TM为热图像的归一化梯度幅值，TO为热图像的定向梯度直方图。TM和TO采用与标准ACF相同的方法获得。T + THOG。该扩展使用热图像的T和HOG特征(表示为THOG)。与计算6个直方图方向相比，THOG计算更多的梯度方向，并且在局部直方图上有额外的归一化步骤。 这三个扩展利用了热通道的强度和梯度信息。利用热图像的梯度作为一个重要的线索。在不同的条件下对这些扩展进行了自我评估:不同的尺度、遮挡标记和捕获时间(白天或夜晚)。图10的结果表明，三种扩展的性能都优于ACF，其中ACF+T+THOG的性能最好。这是因为ACF+T+THOG有最详尽的人形表示。基于这一观察结果，选择了ACF+T+THOG作为理想的信道特性组合，并对其进行了分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc8e7877d092a5ba4e1180dd3560ab2/" rel="bookmark">
			CSS flex 盒子在 Chrome 和 Safari 中的行为差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章出自个人博客 https://knightyun.github.io/2021/07/05/css-flex-chrome-safari-bug，转载请申明。
问题 最近的开发中有遇到一个页面样式的兼容性问题，大致是使用 flex 布局的两个嵌套弹性盒子，在 Chrome 和 Safari 中对一些特殊情况的处理行为不一致，从而产生了测试 bug；
复现 下面将问题简化为了一个 demo 模型，一个定高 300px 的 flex 盒子 A（红色边框），嵌套了另一个高度被子元素（绿色块）撑开的 flex 盒子 B（蓝色边框），其中盒子 B 为垂直伸缩 flex-direction: column;，Footer 元素（绿色边框）高度固定 100px，背景半透明；代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;style&gt; .flex-box-a { display: flex; width: 300px; height: 300px; flex-direction: column; border: 2px solid red; } .flex-box-b { display: flex; width: 200px; height: auto; border: 2px solid blue; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc8e7877d092a5ba4e1180dd3560ab2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019745e8494077d2101cb7122c9c139e/" rel="bookmark">
			【转载】office2021
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		office2021版本来了，先上车体验一把，官方安装教程在这里给大家详细的安装了一遍做了笔记给大家分享一下。
目录
一、下载Office Tool
二、启动Office Tool
三、卸载清理旧版Office
四、部署下载安装Office2021
五、认证Office2021
1、工具及JHM认证
2、推荐kms认证
六、安装成功 一、下载Office Tool 官方网站：https://otp.landian.vip/
推荐下载：Office-Tool-with-runtime-v8.1
支持 Windows 10 和 Windows 7，需要安装 .NET 5.0 Desktop Runtime x86 框架。
二、启动Office Tool 解压Office-Tool-with-runtime-v8.1
点击setup.bat会自动静默安装x86的windowsdesktop-runtime，并启动Office Tool Plus
如果直接启动Office Tool 会提示安装.NET的错误。
直接点击否后，手动安装x86的windowsdesktop-runtime即可（只需安装x86）。
三、卸载清理旧版Office 安装office2021前，需先卸载电脑上已经安装了的其他office如ffice2016或Office2019等，因为新旧office版本不兼容（如果电脑上没有安装过office忽略这一步）
1. 点击工具箱——使用Office Tool Plus移除office——开始
等待移除完成即可。移除期间界面可能会有一两次短暂的黑屏，这都是正常情况。
2. 如下图说是点击——许可证管理——安装许可证——清除状态，等待清除完成即可。
‘
四、部署下载安装Office2021
点击部署
选择产品——添加产品——Office 专业增强版2021-批量版
体系结构，根据需要，选32位或64位
通道，选当前通道或测试通道或其它需要的通道
部署模式：建议选下载后安装，或根据需要，选下载时安装或使用现有安装源
安装模块将默认的office部署工具改成office tool plus，否则“开始部署”为灰色，不能点击。
应用程序根据需要选择，如：Excel、word、PowerPoint。
点击“开始部署”下载安装Office2021，等待office自动下载安装，这期间必须保持网络畅通。
此时就让他们去下载吧，你可以去愉快的玩耍一会了，当然你的网速快的话可能一转眼就下好了。
好了下载完成之后会收到一个提醒。
此时哦，我们的office2021就安装完成了。 五、认证Office2021 认证这一步就比较简单了，现在有很多的方法可以使用这在里
1、工具及JHM认证 https://www.jb51.net/office/753627.html
2、推荐kms认证 kms.luochenzhimu.com
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019745e8494077d2101cb7122c9c139e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850c47046c21bb2c5fd125c7821c73cc/" rel="bookmark">
			clean code之优雅校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clean code之优雅校验 参数的非空判断，长度判断，集合的非空等等，
接口层校验:demo public interface TaskService { /** * insert tb_task_record * * @param taskRecordVo * @return */ Integer insertTbTaskRecord(@Valid TaskRecordVo taskRecordVo); } @Data public class TaskRecordVo implements Serializable { private static final long serialVersionUID = 9110133117222913758L; /** * 主键id */ @NotNull(message = "id不能为空") private BigInteger id; } @Service @Validated public class TaskServiceImpl implements TaskService { @Override public Integer insertTbTaskRecord(TaskRecordVo taskRecordVo) { return 1; } @Test public void testQueryTaskRecordByTaskId() { try { taskService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850c47046c21bb2c5fd125c7821c73cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5fb4aef7820fb1f158968e710eb999/" rel="bookmark">
			windows 11系统字如何更改文本字体大小？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 11系统字如何更改文本字体大小-win11设置字体文本大小的技巧
打开设置。
转到辅助功能。
在左侧窗格中，选择Display。
查看右侧，调整拖动滑块下的滑块，直到示例文本易于阅读。
单击“应用”。
转载于https://www.172210.com/40524.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289260f55722f5e86ca1cd0e4cffe412/" rel="bookmark">
			计算机硬盘无法启动怎么办,电脑开机找不到硬盘怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑开机黑屏，屏幕上显示“Reboot and Select Proper Boot device or Insert Boot Media in Seleccted Boot device and press a key”，无法启动电脑。这是怎么回事，该如何解决？
电脑开机显示这句话的意思是：重新启动并选择适当的启动设备或在所选的启动设备中插入启动媒介并且按任意键。即电脑没有找到启动硬盘。造成这样的问题有几种可能，相应的解决方法如下：
1.硬盘数据线和电源线松动、氧化或断针
解决方法：尝试重新插拔硬盘数据线和电源线，或更换电源接头、数据线接口。
2.主板关闭了sata接口，而电脑使用的是sata硬盘，这样就导致电脑找不到硬盘。
解决方法：开机按DEL键进入BIOS，在BIOS中把sata接口打开。
3.BIOS中的“standard cmos feaures”页面中把硬盘设为无了。
解决方法：进入BIOS，将该选项设置为auto即可。
4.硬盘和其他IDE设备共用数据线，并都将跳线设成了“master”或“slave”
解决方法：更改其中的一个ide跳线即可，或者都设置成cs。
5.硬盘没有设置活动分区
解决方法：手动或者借助软件，将硬盘的某个分区设置为活动分区。
6.长时间在潮湿环境下不使用电脑，导致硬盘上的元件受潮
解决方法：断开电源，用吹风机均匀的给硬盘加热去湿。
7.电脑上的ide设备过多导致其初始化时间增加，但相应的自检时间没有增加，造成系统无法检测到硬盘或检测超。
解决方法：在bios中找到“boot delay time”选项或“ide delay time”，将时间延长即可。如果BIOS中没有此选项，也可以将内存自检次数设为3次，延长自检时间。
8.硬盘长期使用后，背面电路板的金手指上的氧化导致接触不良
解决方法：拆下电路板，清楚金手指上的氧化物，建议找专门的维修人员清理。
9.硬盘物理坏道
解决方法：如果上述方法都不能解决问题，那硬盘本身可能真的是坏了，好送厂维修了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90469684f16b587190ae06f780bd065f/" rel="bookmark">
			ENSP安装问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、正常安装
1、前期准备，电脑命名为英文格式，并且在BIOS中打开VT功能
2、建议电脑没有安装360等安全软件
2、先安装virtual box，安装到C盘
3、接着安装ENSP，可以为其他盘
4、在接下来的安装过程中，需要安装wireshark，winpcap等软件，正常操作即可
5、安装完成之后不要直接运行，将ENSP和virtual box兼容性改成win7且以管理员运行
6、打开ENSP，有时候会提示系统自带防火墙阻拦，一定允许（可以提前关闭，参考后续笔记）
7、选中AR2220路由，进行测试
二、安装失败
1、打开AR2220出现启动失败40错误，解决办法
①删除ENSP界面所有设备，点击右上角菜单——工具——注册设备，选中所有（其实只需要选中AR即可），点击注册
2、关闭ENSP，重新打开，尝试能否打开AR2220，如果成功打开，恭喜可以开始网络之旅，如果没有打开，分为两种情况，第一种为注册失败，第二种为一直#号
3、先保证兼容性和管理员身份运行是选择的，并且防火墙是允许的或者是关闭的，
打开控制面板\系统和安全\Windows Defender 防火墙，如果想关闭，点击启用或关闭Windows defender防火墙，关闭关闭即可
4、如果不想关闭，那就点击允许应用或功能通过Windows defender防火墙，找到ensp开头的所有选项，打上对勾
5、如果这些都没问题，出现注册失败，两种办法：
①打开virtual box软件，将所有东西删除，接着重新注册即可
②点击上述AR_Base，右键设置，查看网络，判断使用哪个网卡
如果有以上界面，打开自己电脑适配器，看是否存在上述网卡
证明不是virtual box和ensp自身问题，而是ensp调用virtual box出现问题，进入安装ensp的目录，D:\eNSP\vboxserver\AR_Base(我是装在D盘)，若装在C盘C:\Program\Files\Huawei\eNSP\vboxserver\ARBaseBackup\AR_Base
选择蓝色的AR_Base,使用记事本打开，点击编辑中查看HostOnly，出现如图所示
发现与适配器里的描述一致，那就代表没问题
6、如果还是打不开设备，而且没有出现40错误，注册也成功，那就卸载重装，得卸载干净
控制面板中，程序，卸载程序，这样并不能完全卸载，得将安装目录的文件夹手工删除，并且将User-&gt;用户名-&gt;AppData(隐藏文件夹)-&gt;Local-&gt;eNSP 文件夹完全删除
安装目录：D:\eNSP
隐藏目录：C:\Users\cisco\AppData\Local\eNSP
7、优化（用了很长时间觉得很卡，可以尝试这样操作）
管理员身份打开cmd，敲lodctr /R
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cabf3a49f59b5b4f36250cf55d3968/" rel="bookmark">
			虚拟机扩容（/dev/mapper/centos-root下的空间不足）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学着搭建k8s，但是发现我的vmware上的一台虚拟机的磁盘就设置了30g，用一半多了，所以为了方便，决定对虚拟机扩容30g。
首先将磁盘大小增加30g（30g改成60g），点击扩展
打开虚拟机，查看最大分区：fdisk -l，所以下一次分区会为/dev/sda3
开始分区：fdisk /dev/sda --&gt;m --&gt;n–&gt;p–&gt;点击enter默认–&gt;enter键默认–&gt;enter键默认–&gt;w
重启：reboot
查看分区，发现/dev/sda3已创建
创建物理卷前先filter磁盘：dd if=/dev/urandom of=/dev/sdb bs=512 count=64
初始化物理卷：pvcreate /dev/sda3
注：pvcreate指令用于将物理硬盘分区初始化为物理卷，以便被LVM使用。要创建物理卷必须首先对硬盘进行分区，并且将硬盘分区的类型设置为“8e”后，才能使用pvcreate指令将分区初始化为物理卷
把pv加入vg中，相当于扩充vg的大小：vgextend centos /dev/sda3
注：（把pv加入vg中，相当于扩充vg的大小，其中是当前需要扩充的lvm组名，通过vgs命令查看） vgextend指令用于动态的扩展卷组，它通过向卷组中添加物理卷来增加卷组的容量。
扩展lv，使用lvextend命令：lvextend -L +30G /dev/mapper/centos-root
系统重新读取大小：xfs_growfs /dev/mapper/centos-root
查看磁盘使用情况：df -h
说明扩容成功！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8434c4cf0b3e718ba560998bed104f59/" rel="bookmark">
			Hinton，Lecun和Bengio三巨头联手再发万字长文：深度学习的昨天、今天和明天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：ACM
编辑：Priscilla Emil
2018年，ACM（国际计算机学会）决定将计算机领域的最高奖项图灵奖颁给Yoshua Bengio、Yann LeCun 和 Geoffrey Hinton，以表彰他们在计算机深度学习领域的贡献。
这也是图灵奖第三次同时颁给三位获奖者。
用于计算机深度学习的人工神经网络在上世纪80年代就已经被提出，但是在当时科研界由于其缺乏理论支撑，且计算力算力有限，导致其一直没有得到相应的重视。
是这三巨头一直在坚持使用深度学习的方法，并在相关领域进行了深入研究。通过实验发现了许多惊人的成果，并为证明深度神经网络的实际优势做出了贡献。
所以说他们是深度学习之父毫不夸张。
在AI界，当Yoshua Bengio、Yann LeCun 和 Geoffrey Hinton 这三位大神同时出场的时候，一定会有什么大事发生。
最近，深度学习三巨头受ACM通讯杂志之邀，共同针对深度学习的话题进行了一次深度专访，提纲挈领地回顾了深度学习的基本概念、最新的进展，以及未来的挑战。
广大的AI开发者们，看了高人指点之后是不是对于未来之路更加明晰了？下面我们来看看他们都聊了些什么。
深度学习的兴起
在2000年代早期，深度学习引入的一些元素，让更深层的网络的训练变得更加容易，也因此重新激发了神经网络的研究。
GPU和大型数据集的可用性是深度学习的关键因素，也得到了具有自动区分功能、开源、灵活的软件平台（如Theano、Torch、Caffe、TensorFlow等）的增强作用。训练复杂的深度网络、重新使用最新模型及其构建块也变得更加容易。而更多层网络的组合允许更复杂的非线性，在感知任务中取得了意料之外的结果。
深度学习深在哪里？有人认为，更深层次的神经网络可能更加强大，而这种想法在现代深度学习技术出现之前就有了。但是，这样的想法其实是由架构和训练程序的不断进步而得来的，并带来了与深度学习兴起相关的显著进步。
更深层的网络能够更好地概括「输入-输出关系类型」，而这不仅只是因为参数变多了。深度网络通常比具有相同参数数量的浅层网络具有更好的泛化能力。例如，时下流行的计算机视觉卷积网络架构类别是ResNet系列，其中最常见的是ResNet-50，有50层。
图源：知乎@臭咸鱼
深度网络之所以能够脱颖而出，是因为它利用了一种特定形式的组合性，其中一层的特征以多种不同的方式组合，这样在下一层就能够创建更多的抽象特征。
无监督的预训练。当标记训练示例的数量较小，执行任务所需的神经网络的复杂性也较小时，能够使用一些其他信息源来创建特征检测器层，再对这些具有有限标签的特征检测器进行微调。在迁移学习中，信息源是另一种监督学习任务，具有大量标签。但是也可以通过堆叠自动编码器来创建多层特征检测器，无需使用任何标签。
线性整流单元的成功之谜。早期，深度网络的成功，是因为使用了逻辑sigmoid非线性函数或与之密切相关的双曲正切函数，对隐藏层进行无监督的预训练。
长期以来，神经科学一直假设线性整流单元，并且已经在 RBM 和卷积神经网络的某些变体中使用。让人意想不到的是，人们惊喜地发现，非线性整流通过反向传播和随机梯度下降，让训练深度网络变得更加便捷，无需进行逐层预训练。这是深度学习优于以往对象识别方法的技术进步之一。
语音和物体识别方面的突破。声学模型将声波转换为音素片段的概率分布。Robinson、Morgan 等人分别使用了晶片机和DSP芯片，他们的尝试均表明，如果有足够的处理能力，神经网络可以与最先进的声学建模技术相媲美。
2009年，两位研究生使用 NVIDIA GPU ，证明了预训练的深度神经网络在 TIMIT 数据集上的表现略优于 SOTA。这一结果重新激起了神经网络中几个主要语音识别小组的兴趣。2010 年，在不需要依赖说话者训练的情况下，基本一致的深度网络能在大量词汇语音识别方面击败了 SOTA 。2012 年，谷歌显着改善了 Android 上的语音搜索。这是深度学习颠覆性力量的早期证明。
大约在同一时间，深度学习在 2012 年 ImageNet 竞赛中取得了戏剧性的胜利，在识别自然图像中的一千种不同类别的物体时，其错误率几乎减半。这场胜利的关键在于，李飞飞及其合作者为训练集收集了超过一百万张带标签的图像，以及Alex Krizhevsky 对多个 GPU 的高效使用。
深度卷积神经网络具有新颖性，例如，ReLU能加快学习，dropout能防止过度拟合，但它基本上只是一种前馈卷积神经网络，Yann LeCun 和合作者多年来一直都在研究。
计算机视觉社区对这一突破的反应令人钦佩。证明卷积神经网络优越性的证据无可争议，社区很快就放弃了以前的手工设计方法，转而使用深度学习。
深度学习近期的主要成就
三位大神选择性地讨论了深度学习的一些最新进展，如软注意力（soft attention）和Transformer 架构。
深度学习的一个重大发展，尤其是在顺序处理方面，是乘法交互的使用，尤其是软注意力的形式。这是对神经网络工具箱的变革性补充，因为它将神经网络从纯粹的矢量转换机器，转变为能够动态选择对哪些输入进行操作的架构，并且将信息存储在关联存储器中。这种架构的关键特性是，它们能有效地对不同类型的数据结构进行操作。
软注意力可用于某一层的模块，可以动态选择它们来自前一层的哪些向量，从而组合，计算输出。这可以使输出独立于输入的呈现顺序（将它们视为一组），或者利用不同输入之间的关系（将它们视为图形）。
Transformer 架构已经成为许多应用中的主导架构，它堆叠了许多层“self-attention”模块。同一层中对每个模块使用标量积来计算其查询向量与该层中其他模块的关键向量之间的匹配。匹配被归一化为总和1，然后使用产生的标量系数来形成前一层中其他模块产生的值向量的凸组合。结果向量形成下一计算阶段的模块的输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8434c4cf0b3e718ba560998bed104f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947433f1e14556cd93b751accf1304b9/" rel="bookmark">
			【鸿蒙】HarMonyOS的UI组件学习九之计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算器是电脑和手机都必不可少的一款软件，今天分享在鸿蒙系统上开发计算器软件。
先看功能效果:
这里演示了一下加法，该计算器中实现了加减乘除求余，开根号，倒数等所有功能。其他功能的演示这里就不浪费篇幅了。
接下来看界面的设计，这里设计了两种边框主题，一个是显示计算过程和结果的两个Text组件的边框，在graphic文件夹下新建xml文件:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:shape="rectangle"&gt; &lt;corners ohos:radius="20" /&gt; &lt;solid ohos:color="#FFffff"/&gt; &lt;stroke ohos:color="#0066FF" ohos:width="10"/&gt; &lt;/shape&gt; 再新建一个xml文件，设计按钮的背景样式。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;shape xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:shape="rectangle"&gt; &lt;corners ohos:radius="20" /&gt; &lt;solid ohos:color="#FF5151EC"/&gt; &lt;/shape&gt; 接下来就是计算器的界面搭建的xml代码:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;DirectionalLayout xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:height="match_parent" ohos:width="match_parent" ohos:orientation="vertical"&gt; &lt;Text ohos:height="60fp" ohos:width="match_parent" ohos:background_element="#00f" ohos:padding="10fp" ohos:text="计算器" ohos:text_alignment="center" ohos:text_color="#fff" ohos:text_size="30fp"/&gt; &lt;TableLayout ohos:height="match_parent" ohos:width="match_parent" ohos:column_count="1" ohos:orientation="vertical" ohos:padding="10fp" ohos:row_count="8"&gt; &lt;DirectionalLayout ohos:height="match_content" ohos:width="match_parent" ohos:background_element="$graphic:background_textfield" ohos:orientation="vertical"&gt; &lt;Text ohos:id="$+id:tv_jsq1" ohos:height="40fp" ohos:width="match_parent" ohos:text_color="#000" ohos:hint="请在按键上输入计算的数字" ohos:hint_color="#aaa" ohos:padding="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947433f1e14556cd93b751accf1304b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f79e967ede1ae848dc31971239eb9fa/" rel="bookmark">
			vue报错：[Vue warn]: Duplicate keys detected: ‘[object Object]‘. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [Vue warn]: Avoid using non-primitive value as key, use string/number value instead. 原因：检测到重复的键：“[object]”。
&lt;div v-for='item in items' :key='item'&gt; 解决：修改key值
&lt;div v-for='item in items' :key='item.index'&gt; 或： &lt;div v-for='(item,index)in items' :key='index'&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2007c84895ed89fe2402408980327b46/" rel="bookmark">
			立体视觉匹配为什么是不适定问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题思考 在看深度估计的无监督学习方法时，看到有作者提出立体视觉匹配本身是个不适定问题，所以基于立体视觉匹配的无监督学习方法和有监督比性能上还是有差距。
为什么是不适定问题（ill-posed problem） 论文《Stereo Matching Using Belief Propagation》中提到了stereo vision matching中存在的相关问题。
Noise（噪声）：在形成一张图像时，光线的变化是不可避免的，同时还有图像的模糊，传感器的噪声等。Textureless region（低纹理区域）：低纹理区域无法运用强度一致性约束，因此高纹理处的信息需要转化成用于立体匹配的低纹理区域（这一块儿没大懂）Depth discontinuties（深度的不连续）：空间顺滑约束在物体的边界处就会失效，简而言之，信息的迭代将会止步于深度不连续处。Occlusion （遮挡区域）:一张图片的部分区域被遮挡，而另外一张未遮挡，无法通过单张图片得到这块区域的深度信息。
综上所述，立体视觉匹配是一个不适定的问题
[参考文献]
(http://www.jiansun.org/papers/Stereo_PAMI.pdf) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2be93c1828d6132a7f662dc18b75af9/" rel="bookmark">
			HTML5植物大战僵尸网页版游戏源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍： HTML5植物大战僵尸网页版游戏源码，直接把源码上传到服务器就能使用了！
网盘下载地址： http://kekewangLuo.net/Z91ZVfWXaYu0
图片： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18b11290fe5c17efff727aee220138e/" rel="bookmark">
			用array的sort方法把已知的元素排列在数组的首位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sort排序会改变原数组的顺序，所以下面会用map进行数组浅拷贝
const arr = ['a', 'f', '数字', 'd', 'man']; // 把数字排在第一位 const arr_1 = arr.map(item =&gt; item).sort((a,b)=&gt; a === '数字' ? -1 : 1); // 把数字排第一位，man排第二位 const arr_2 = arr.map(item =&gt; item).sort((a,b)=&gt; a==='数字' || a === 'man' &amp;&amp; b !== '数字' ? -1 : 1); console.log('arr_1', arr_1); // ["数字", "a", "f", "d", "man"] console.log('arr_2', arr_2); // ["数字", "man", "a", "f", "d"] 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/178/">«</a>
	<span class="pagination__item pagination__item--current">179/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/180/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>