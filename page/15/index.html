<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bdc3a35c564086afe57e8f05447dd5/" rel="bookmark">
			CSS3设置圆角化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用border-radius属性来设置圆角化 有四个值 分别是：左上 右上 左下 右下
三个值 分别是：左上 右上左下 右下
两个值 分别是：左上右下 右上左下
给单独一角设置圆角化可以使用：border-xxx-xxx-radius
例：左上角 圆角化： border-top-left-radius
div{ width: 100px; height: 100px; background-color: red; margin: 50px 0; /* 设置左上角圆角 */ border-top-left-radius: 10px; } 例：设置一个半圆
div{ width: 200px; height: 100px; background-color: red; margin: 50px 0; /* 设置一个半圆 */ border-radius: 100px 100px 0 0 ; } 例：设置四分之一圆
div{ width: 100px; height: 100px; background-color: red; margin: 50px 0; /* 设置一个四分之一圆 */ border-radius: 100px 0 0 0; } 原创作者：吴小糖
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75bdc3a35c564086afe57e8f05447dd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4060c04a52aaba1cf1298a2f6e69c4d0/" rel="bookmark">
			dyld: Library not loaded: /usr/lib/swift/libswiftCoreGraphics.dylib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新Xcode14后低版本iPhone调试报错 dyld: Library not loaded: /usr/lib/swift/libswiftCoreGraphics.dylib
Referenced from: /var/containers/Bundle/Application/…/….app/…
Reason: image not found
这是缺少libswiftCoreGraphics库
直接导入libswiftCoreGraphics库即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d50f4c9eb328e098d87d18e601bd331/" rel="bookmark">
			JS禁止用户缩放浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div { width: 200px; height: 200px; background-color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; window.addEventListener('mousewheel', function (event) { if (event.ctrlKey === true || event.metaKey) { event.preventDefault() } }, { passive: false }) //firefox window.addEventListener('DOMMouseScroll', function (event) { if (event.ctrlKey === true || event.metaKey) { event.preventDefault() } }, { passive: false }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c00c445a650ec828959866fae8fb4fc/" rel="bookmark">
			《工具录》nslookup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具录 1：nslookup2：选项介绍3：示例 - 命令行模式3.1：查询类型设置3.2：指定 DNS 服务器 4：示例 - 交互模式5：其他 本文以 kali-linux-2023.3-vmware-amd64 为例。
1：nslookup nslookup（name server lookup）常用于域名解析和网络故障排除。
nslookup 有两种操作模式，两种模式功能一致：
交互式模式
适用于在一个会话中执行多个查询或操作。
命令行模式（非交互模式）
适用于执行一次性的简单查询或将其嵌入到脚本中。
2：选项介绍 选项总览：man nslookup 命令中的解释。
NSLOOKUP(1) BIND 9 NSLOOKUP(1) NAME nslookup - query Internet name servers interactively SYNOPSIS nslookup [-option] [name | -] [server] DESCRIPTION nslookup is a program to query Internet domain name servers. nslookup has two modes: interactive and non-interactive. Interactive mode al‐ lows the user to query name servers for information about various hosts and domains or to print a list of hosts in a domain.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c00c445a650ec828959866fae8fb4fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ffe4ca12b416704f030fe615433244/" rel="bookmark">
			【二段式状态机】 fsm 输出打一拍写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/ONEFPGA/article/details/125297745
fsm 2 process module auto_sell( input clk, input rst_n, input coin_one, input coin_half, output reg water, output reg coin_back ); parameter ZERO = 3'b000; parameter HALF = 3'b001; parameter ONE = 3'b010; parameter ONE_HALF = 3'b011; parameter TWO = 3'b100; //--------------------二段式 1 ok-------------------------- //二段式状态机 reg [2:0] c_status; reg [2:0] n_status; reg water_reg; //new 新加的部分； reg coin_back_reg; //new //状态转移 always@(posedge clk,negedge rst_n)begin water_reg &lt;= water; //new coin_back_reg &lt;= coin_back; //new if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ffe4ca12b416704f030fe615433244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3da74f048de8d8e542f62d8a70078ad/" rel="bookmark">
			阿里云域名外部入库流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注册商是阿里云，且在阿里云管理的，请使用此教程外部入库。
如您的域名注册商是阿里云但在聚名管理，请参考教程：https://www.west.cn/faq/list.asp?unid=2539 在外部入库操作之前，请先登录阿里云获取账号ID。详细的账户ID信息获取位置如下图：
一、在我司提交入库
1、登录西部数码官方网站，在【域名交易】-【注册商账号管理】-【添加账号】中，注册商选择“阿里云”，填写上图中查到的账号ID，填写密保答案，然后点【确定提交】，如下图：
2、在【业务管理】-【域名管理】-【外部入库】，输入要入库的域名（填写顶级域名即可），注册商选择“阿里云”，选择添加的阿里云账号ID，选择模版（如入库后不涉及过户，没有模版可以选临时模版），点击【确定提交】。如下图：
选择模版时，可以直接选择临时模版。如下图：
3、提交完成后在【入库记录】中会显示“转移方式”和“我司账号”，阿里云外部入库需要使用“转至其他账号”方式转至我司在阿里云的账号：20403868。
二、登录阿里云网站，完成域名转移账号操作
1、在阿里云网站登录管理平台，在域名资源点击【控制台】，如下图：
2、在【域名控制台】-【域名列表】，勾选要转移的域名，点击【转至其他账号】，如下图：
3、点击【获取验证码】，输入手机收到的短信验证码，对方登录账号输入（20403868），点击【提交】。如下图：
特别说明：如果您是阿里云代理商，使用此功能操作，默认会等待我司邮件确认，如迟迟没成功请联系我司核实。也可以使用0元PUSH功能转到我司账号。
三、在我司确认转移，完成外部入库
1、在【业务管理】-【域名管理】-【外部入库】-【入库记录】，点击【确认转移】，完成外部入库。（域名未在阿里云转移到我司账号之前，请勿点击【确认转移】）
如外部入库迟迟没成功，显示已处理或待转移，请点击【详情】查看具体原因。
2、外部入库成功后，可以在【业务管理】-【域名管理】-【域名列表】中，查看到外部入库的域名。
原文链接：https://www.west.cn/faq/list.asp?unid=2540 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9539850ca7d88ebd30ade1ebe003b5/" rel="bookmark">
			【CNN-BiLSTM-SAM-attention分类】基于空间注意力机制的卷积神经网络结合双向长短记忆神经网络实现数据分类附matlab仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：热爱科研的Matlab仿真开发者，修心和技术同步精进，
代码获取、论文复现及科研仿真合作可私信。 🍎个人主页：Matlab科研工作室
🍊个人信条：格物致知。
更多Matlab完整代码及仿真定制内容点击👇
智能优化算法 神经网络预测 雷达通信 无线传感器 电力系统
信号处理 图像处理 路径规划 元胞自动机 无人机
🔥 内容介绍 摘要 本文提出了一种基于空间注意力机制的卷积神经网络结合双向长短记忆神经网络（CNN-BiLSTM-SAM-attention）的数据分类模型。该模型利用卷积神经网络提取图像的局部特征，并使用双向长短记忆神经网络对图像的全局特征进行建模。此外，该模型还利用空间注意力机制对图像的局部特征进行加权，以突出图像中重要的区域。实验结果表明，该模型在多个数据集上取得了良好的分类性能。
1. 介绍 卷积神经网络（CNN）是一种强大的图像分类模型，它能够自动学习图像的局部特征。然而，CNN在处理图像的全局特征时存在一定的局限性。双向长短记忆神经网络（BiLSTM）是一种循环神经网络，它能够对序列数据进行建模。BiLSTM在处理图像的全局特征时具有较好的性能。
空间注意力机制是一种能够突出图像中重要区域的机制。空间注意力机制可以与CNN和BiLSTM结合起来，以提高图像分类的性能。
2. 模型结构 该模型的结构如图1所示。该模型由以下几个部分组成：
卷积神经网络（CNN）：CNN用于提取图像的局部特征。CNN由多个卷积层和池化层组成。
双向长短记忆神经网络（BiLSTM）：BiLSTM用于对图像的全局特征进行建模。BiLSTM由多个BiLSTM层组成。
空间注意力机制（SAM）：SAM用于对图像的局部特征进行加权，以突出图像中重要的区域。SAM由一个卷积层和一个池化层组成。
3. 训练过程 该模型的训练过程如下：
将图像输入到CNN中，并提取图像的局部特征。
将CNN提取的局部特征输入到BiLSTM中，并对图像的全局特征进行建模。
将BiLSTM提取的全局特征输入到SAM中，并对图像的局部特征进行加权。
将加权后的局部特征输入到分类层，并输出图像的分类结果。
计算模型的损失函数，并使用反向传播算法更新模型的参数。
重复步骤1-5，直到模型收敛。
📣 部分代码 %% 清空环境变量warning off % 关闭报警信息close all % 关闭开启的图窗clear % 清空变量clc % 清空命令行​%% 导入数据res = xlsread('数据集.xlsx');​%% 划分训练集和测试集temp = randperm(357);​P_train = res(temp(1: 240), 1: 12)';T_train = res(temp(1: 240), 13)';M = size(P_train, 2);​P_test = res(temp(241: end), 1: 12)';T_test = res(temp(241: end), 13)';N = size(P_test, 2);​%% 数据归一化[p_train, ps_input] = mapminmax(P_train, 0, 1);p_test = mapminmax('apply', P_test, ps_input);t_train = ind2vec(T_train);t_test = ind2vec(T_test ); ⛳️ 运行结果 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9539850ca7d88ebd30ade1ebe003b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b37654ca5615f44c825b00eb83b177/" rel="bookmark">
			Python实现简单的JS逆向解密, 实现翻译软件&#43;语音播报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨喽~大家好呀，这里是魔王呐 ❤ ~! python更多源码/资料/解答/教程等 点击此处跳转文末名片免费获取
环境使用: python 3.8
pycharm
第三方模块使用: requests --&gt; pip install requests
execjs --&gt; pip install PyExecJS
ttkbootstrap --&gt; pip install ttkbootstrap
pyttsx3 --&gt; pip install pyttsx3
模块安装：
win + R 输入cmd 输入安装命令 pip install 模块名 (如果你觉得安装速度比较慢, 你可以切换国内镜像源)
案例分为两个部分: 一. 实现翻译功能 &lt;爬虫技术&gt;
如果有翻译接口 --&gt; 抓包分析
抓包分析 通过开发者工具 &lt;浏览器自带&gt;
- 翻译接口: https://fanyi.baidu.com/v2transapi?from=zh&amp;to=en
通过对比:
sign --&gt; 参数是改变的
&lt; js代码生成 &gt;
通过开发者工具 分析 --&gt; JS代码那块生成出来 &lt;扣代码&gt;
运行扣下来的js代码
通过python代码执行js代码, 获取sign值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b37654ca5615f44c825b00eb83b177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ee0276bd271768a7e45abe29a02386/" rel="bookmark">
			2024最新SLAM实习、秋招面经（百度、华为、小米、蔚来、理想、美团、阿里菜鸟……）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		秋招已经结束，大大小小面了50场左右，就此开始慢慢整理一下，希望可以给看到的同学一点帮助~
整理期间免费开放，整理完毕后打算设置成VIP可见，赚点小外快
个人BG：双非本，985硕。主要研究方向包括激光SLAM、视觉SLAM、VIO
（ps. 整个面经大致按时间线记录，前期遇到过的问题后续不再记录）
（pps. 目前还在思考是光写面试问题，在问题之后还是附上我的一个不一定对的参考答案…才疏学浅，怕误导到大家。暂定先只写问题吧，一些没有标准答案的问题我也写一写我的理解，如有出错请帮忙在评论区留言哈！）
一、 实习面经 我开始找实习的时间大致是12月中旬，计划3-6月实习。一开始选了一些初创公司练手，前期的面经没有留存记录，暂且不表
1、毫末智行 一面 项目-优化雅可比项目-点云线特征获取ORB特征点及描述子怎么提取单应性矩阵怎么求解描述一下对极几何ICP配准的解析解法手写高斯牛顿曲线拟合八股-多态、虚函数、纯虚函数、内存泄漏coding-爬楼梯 二面 怎么使用Eigen对位姿进行插值，主要考察slerp()函数使用SVD对平面拟合，简述思路VINS-mono的marg策略，主要考察VINS针对是否是关键帧时不同的策略 2、蔚来 一面 项目-轮速计使用的是原始数据还是直接的poseFast-Lio2的ikdtree边缘化以及FEJ的原理八股-shared_ptr、weak_ptr、多线程coding-翻转链表SLAM Coding-imu和lidar时间戳对齐 二面 项目-语义SLAM有没有什么办法可以使得语义信息获取不太耗SLAM时间项目-标定中有没有做在线标定定位指标有没有2sigma、3sigma误差等指标，仅使用均值是不是不太合理位姿插值-slerp函数SLAM Coding-给定位姿轨迹和各帧的点云，拼接成一个大的点云地图。 三面 聊天 3、经纬恒润 BA使用的假设，或者说使用BA要满足的前提条件(至今不知道他想问什么，有懂的大佬可以评论区留言) 4、美团日常实习 一面 聊项目聊一聊 VINS-Mono和ORB3的区别：初始化、优化方式、特征点提取及管理…VINS-Mono初始化的过程八股-模板类多态和虚函数多态分别在什么阶段形成(预编译和运行阶段)coding-二叉树的右视图coding-计算两个矩形的IOU，需要考虑矩形倾斜的情况 二面 SLAM Coding-手写体素滤波 二、 秋招面经 等待更新…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6878d2152ef3f5235c5f082d71087e94/" rel="bookmark">
			三种方式在ASP.NET Core中实现代理功能请求获取数据的接口(以请求百度统计数据接口为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义请求数据属性 TargetUrl参数是目标接口的URL，RequestDataArray参数是要发送的请求数据列表 //定义属性:TargetUrl参数是目标接口的URL，RequestDataArray参数是要发送的请求数据列表 public class ToResponseBody { [JsonPropertyName("TargetUrl")] public string TargetUrl { get; set; } = ""; [JsonPropertyName("RequestDataArray")] public string[] RequestDataArray { get; set; } = null; } 二、定义api返回数据内容形式 public class ApiReturnData { public int code { get; set; } = 0; public string msg { get; set; } = ""; public dynamic data { get; set; } = new ExpandoObject(); } 三、百度统计api简介： （1）大家首先进入以下网址：这个网址介绍了 用户如果要调用百度账号的 API 接口，需要通过百度开发者中心的身份验证，具体步骤进入网址中查看（里面介绍得非常详细）：
地址：https://tongji.baidu.com/api/manual/Chapter2/openapi.html （2）接着再进入接口网址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6878d2152ef3f5235c5f082d71087e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7be3fb7520fafc16560fec5afdb2a96c/" rel="bookmark">
			jenkins &#43;jmeter 报告乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：生产报告会乱码的问题，一般是有编码格式引起的。我遇到的问题是，jmeter需要读取csv的数据作为参数。但是我们并不知道csv保存是什么编码格式，有可能不是utf-8的编码格式，所以会导致中文乱码的问题
解决方案：
1.选择csv，打开方式为txt文档
2.另存为
3.选择编码格式，保存
4.设置CSV Data Set Config的编码格式（UTF-8）
5.在Windows的环境变量中添加：JAVA_TOOL_OPTIONS = -Dfile.encoding=UTF8，配置好后，重启Jenkins即可（重启服务）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c315728ea252a23138d53ebc34bcbad/" rel="bookmark">
			通过CANopen转Modbus TCP网关的伺服系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过开疆CANopen转Modbus TCP网关的伺服系统，我们能够实现CANopen协议与Modbus TCP协议之间的无缝转换，从而为伺服电机的通讯和控制带来更大的便利和灵活性。
首先我们可以通过CANopen协议与伺服电机进行通讯。CANopen协议是一种先进的、高效的通讯协议，它基于CAN总线技术，能够实现设备之间的快速、稳定通讯。在CANopen协议中，从站设备需要配置控制字、速度、模式等参数，主站设备可以通过发送控制指令来精确控制从站设备的运转。
然后，我们可以通过Modbus TCP协议与网关进行通讯。Modbus TCP协议是一种广泛应用的工业自动化通讯协议，它基于TCPIP网络协议，可以实现设备之间的远程通讯和控制。在Modbus TCP协议中，从站设备需要配置IP地址、端口号等参数，主站设备可以通过发送Modbus指令来读写从站设备的寄存器，从而实现对从站设备的精确控制。
通过CANopen转Modbus TCP网关，我们能够实现CANopen协议与Modbus TCP协议之间的转换。网关可以配置为CANopen从站和Modbus主站，从而与伺服电机进行通讯和控制。在网关的配置软件中，我们可以设置CANopen从站的参数和Modbus主站的参数，包括波特率、奇偶校验、数据位、停止位、站地址等。同时，我们还可以手动修改寄存器起始地址，实现不同伺服电机的控制。
使用Modbus主站软件可以读写从站设备的参数。在Modbus主站软件中，我们可以发送Modbus指令来读写从站设备的寄存器，从而实现对伺服电机的精确控制。例如，图1是用modbuspoll通过对伺服读取电机的状态字；图2给伺服下入，功能码为16（写入多寄存器）第一个寄存器是控制字依次写入写入7-6-F，第二、三寄存器是速度值，第四寄存器是模式选择写入0300。这样，当伺服电机在使能后即可按照输入速度运转。总的来说，通过CANopen转Modbus TCP网关的伺服系统，我们能够实现伺服电机的高效通讯和控制。这种系统具有很高的实用性和灵活性，能够满足各种工业自动化应用的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7875ced65c0efd936c4d27bb8a5fd7e/" rel="bookmark">
			【springboot&#43;vue项目（零）】开发项目经验积累（处理问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、VUE+Element UI （一）elementui下拉框默认值不是对应中文问题 v-model绑定的值必须是字符串，才会显示默认选中对应中文，如果是数字，则显示数字，修改为：
handleOpenAddDialog() { this.dialogTitle = "添加信息"; this.dialogAction = "添加"; this.addOrEditForm = { uploadtime: this.getCurrentDateTime(), status: "0" }; this.dialogVisible = true; }, 如果 status: 0 ,则显示为 0 , 如果 status: "0", 则显示为 "正常"。
相对于的修改弹出框也要修改为:
/**** 【6.1】修改弹出框 ****/ openEditDialog(row) { this.dialogTitle = "修改信息"; this.dialogAction = "保存"; this.addOrEditForm = Object.assign({}, row); this.addOrEditForm.status = row.status === 0 ? "正常" : "异常"; // 根据 row.status 的值设置 addOrEditForm.status 的初始值 this.dialogVisible = true; }, （二）无法连续上传导入文件的问题 无法连续上传导入的问题，可能是由于文件选择对话框在每次上传后没有重置所导致的。可以尝试在文件上传成功后重置文件选择框，以便用户能够继续选择和上传文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7875ced65c0efd936c4d27bb8a5fd7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98dad337663c113fbf7097ccb1c686c/" rel="bookmark">
			PaddleOCR数字仪表识别——3.(New)PaddleOCR迁移学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 数据准备1.1 数据集1.2 字典 2. 启动训练2.1 确定模型和对应的配置文件2.1.1 选择的模型2.1.2 选择的配置文件 2.2 训练及评估2.2.1 训练2.2.2 运行过程2.2.3 问题 2.3 预测部署2.3.1 基于Python脚本预测引擎推理 3. 我又来撞南墙了3.1 心理建设3.2 挖掘Github信息感触 安装 参考百度PaddleOCR的 快速安装，记得提前安装gcc就行。（参考 PaddleOCR数字仪表识别——3.paddleocr迁移学习3.1部分） 1. 数据准备 1.1 数据集 参考PaddleOCR数字仪表识别——2(New). textrenderer使用及修改使之符合PaddleOCR数据标准
1.2 字典 PaddleOCR提供了一些默认的字典，位置（PaddleOCR/ppocr/utils/dict/）比如
ppocr/utils/ppocr_keys_v1.txt 是一个包含6623个字符的中文字典， ppocr/utils/ic15_dict.txt 是一个包含36个字符的英文字典， ppocr/utils/dict/french_dict.txt 是一个包含118个字符的法文字典 ppocr/utils/dict/japan_dict.txt 是一个包含4399个字符的日文字典 字典的格式也很简单，就是一个txt文件，每行一个字符（会自动 id-char映射）
我的项目只需要进行数字识别，所以字典就是0-9这10个数字。然后把自己的文件放到上面同样的目录里去，这里存在一个坑
根据PaddleOCR Q&amp;A部分
所以修改字典后，其实就不是迁移学习了，而是重新训练
2. 启动训练 2.1 确定模型和对应的配置文件 之前训练使用的预训练模型是：
模型骨干网络Avg Accuracy模型存储命名CRNNMobileNetV379.37%rec_mv3_none_bilstm_ctc配置文件用的是：配置文件算法名称backbonetrans————rec_icdar15_train.ymlCRNNMobilenet_v3 large 0.5None 之前是2400张图，训练了1000次，在测试集上准确率都是1了。
2.1.1 选择的模型 根据 PaddleOCR-算法介绍部分的文档
推荐使用CRNN（考虑到稳定性），还是使用CRNN，CRNN支持的配置文件也最多，这次用下面的这个试试看（骨干网络变了，准确率高了3%左右）：
模型骨干网络Avg Accuracy模型存储命名CRNNResnet34_vd82.20%rec_r34_vd_none_bilstm_ctc 下载并解压该模型
cd PaddleOCR/ # 下载MobileNetV3的预训练模型 wget -P .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b98dad337663c113fbf7097ccb1c686c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328c1044cc04dd6500ba15938a44312d/" rel="bookmark">
			性能测试之（八）：JMeter断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断言:让程序判断预期结果和实际结果是否一致 学习目标：
掌握响应断言的使用；
掌握json断言的使用；
了解 持续时间断言；
一、响应断言 1、案例 场景：http://baidu.com
需求：让程序检查响应数据中是否包含“百度一下，你就知道”
操作步骤：添加线程组—&gt;添加http请求—&gt;添加响应断言—&gt;添加断言结果—&gt;添加察看结果数
添加响应断言如下：
当响应断言错误时，在察看结果树中查看断言结果：
响应断言的参数：
二、JSON断言（使用JSON断言需要确保响应数据是JSON格式） 该组件用来对JSON文档进行验证，验证步骤如下：
1、首先解析JSON数据，如果数据不是JSON，则验证失败 2、使用Jayway JsonPath1.2.0中的语法搜索指定路径。如果找不到路径，就会失败。 3、如果在文档中找到JSON路径，并且要求对期望值进行验证，那么它将执行验证操作 操作步骤：添加线程组—&gt;添加http请求—&gt;添加JSON断言—&gt;添加断言结果—&gt;添加察看结果数
添加的JSON断言：
断言结果：json的message值不是“成功！”
三、断言持续时间 客户的发送请求到收到服务端响应的时间，要求不超过指定时间。
设置访问https://www.jd.com 不超过 10毫秒
结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df184690d1d1e17136139a630d2ffbba/" rel="bookmark">
			网页和小程序实现放大预览富文本中的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：网页和小程序实现放大预览富文本中的图片
环境：使用微信小程序环境或者uniapp环境开发
实现方式：
通过 rich-text 组件的 itemclick 事件实现
实现代码和效果展示：
代码：
&lt;rich-text :nodes="details.contentHtml" preview @itemclick ="itemclick"&gt;&lt;/rich-text&gt; js代码：
itemclick(e){ console.log('eeeeeeeee',e); if(e.detail.node.name=='img'){ let img =e.detail.node.attrs.src this.SeeDatu(img) } }, SeeDatu(imgUrl) { uni.previewImage({ urls: [imgUrl], current: '', // 当前显示图片的http链接，默认是第一个 success: function(res) {}, fail: function(res) {}, complete: function(res) {}, }) }， 效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a3b635e64dd0c6fe2ebdaee462fe59/" rel="bookmark">
			FastGPT的安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装docker和docker-compose
下载更改配置文件 mkdir fastgpt cd fastgpt curl -O https://raw.githubusercontent.com/labring/FastGPT/main/files/deploy/fastgpt/docker-compose.yml curl -O https://raw.githubusercontent.com/labring/FastGPT/main/projects/app/data/config.json 主要就是OpenAI接口地址和key要修改，因为我们要使用第三方代理的
修改docker-compose.yml中的OPENAI_BASE_URL和CHAT_API_KEY即可，对应为 API 的地址(别忘记加/v1)和 key。
如果速度太慢，把镜像地址那里，阿里云的镜像注释打开
拉取镜像启动容器
# 在 docker-compose.yml 同级目录下执行 docker-compose pull docker-compose up -d 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a35e7cbd6700cc0d1cd96c79bca1659/" rel="bookmark">
			HarmonyOS-ArkTS基本语法及声明式UI描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初识ArkTS语言 ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。
当前，ArkTS在TS的基础上主要扩展了如下能力：
基本语法：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。状态管理：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活的利用这些能力来实现数据和UI的联动。渲染控制：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。 未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。
基本语法概述 在初步了解了ArkTS语言之后，我们以一个具体的示例来说明ArkTS的基本组成。如下图所示，当开发者点击按钮时，文本内容从“Hello World”变为“Hello ArkUI”。
图1 示例效果图
本示例中，ArkTS的基本组成如下所示。
图2 ArkTS的基本组成
装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。 除此之外，ArkTS扩展了多种语法范式来使开发更加便捷：
@Builder/@BuilderParam：特殊的封装UI描述的方法，细粒度的封装和复用UI描述。@Extend/@Style：扩展内置组件和封装属性样式，更灵活地组合内置组件。stateStyles：多态样式，可以依据组件的内部状态的不同，设置不同样式。 声明式UI描述 ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。
创建组件 根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。
说明
创建组件时不需要new运算符。
无参数 如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数：
Column() { Text('item 1') Divider() Text('item 2') } 有参数 如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。
Image组件的必选参数src。
Image('https://xyz/test.jpg') Text组件的非必选参数content。
// string类型的参数 Text('test') // $r形式引入应用资源，可应用于多语言场景 Text($r('app.string.title_value')) // 无参数形式 Text() 变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。
例如，设置变量或表达式来构造Image和Text组件的参数。
Image(this.imagePath) Image('https://' + this.imageUrl) Text(`count: ${this.count}`) 配置属性 属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。
配置Text组件的字体大小。
Text('test') .fontSize(12) 配置组件的多个属性。
Image('test.jpg') .alt('error.jpg') .width(100) .height(100) 除了直接传递常量参数外，还可以传递变量或表达式。
Text('hello') .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a35e7cbd6700cc0d1cd96c79bca1659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8be266e18d59b0390fd0c8d6ed1a1aa2/" rel="bookmark">
			选择排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
选择排序的基本思想是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
选择排序的时间复杂度为O(n^2)，其中n为待排序元素的个数。虽然时间复杂度较高，但选择排序是稳定的排序算法，且具有较好的性能表现。
实现思想：
首先，定义一个最小值min，将min赋值循环后的第一个未排序的值，将该值与后续的值进行比较，如果发现有比min还有小的值，将两个元素进行交换。如果没有发现比该元素还要小的值，说明该值不需要改动，当前位置就是其排序后的位置。依次循环，比较 (元素-1) 次即可完成排序。
推敲代码中： public class Sortselect { public static void main(String[] args) { int[] arrays = {12, 5, 8, 9, 4, 2}; System.out.println("排序前：" + Arrays.toString(arrays)); int min = arrays[0]; for (int j = 0; j &lt; arrays.length; j++) { if (min &gt; arrays[j]) { //交换元素，将最小值移到相应的位置 min = arrays[j]; arrays[j] = arrays[0]; arrays[0] = min; } } System.out.println("第一轮：" + Arrays.toString(arrays)); min = arrays[1]; for (int j = 1; j &lt; arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8be266e18d59b0390fd0c8d6ed1a1aa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c994d18d6de147f123204cfdc94c2601/" rel="bookmark">
			Linux(ubuntu)下git / github/gitee使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先附上git命令
linux@chenxiao:~$ cd Templates/ 先进入一个目录，也可mkdir新建一个目录：用于接下来初始化为git可以管理的仓库
这个目录就是所说的工作目录，指当前正在进行开发的项目的本地目录。
linux@chenxiao:~/Templates$ git init 已初始化空的 Git 仓库于 /home/linux/Templates/.git/ 1. 在终端输入 git init 初始化git仓库 linux@chenxiao:~/Templates$ ll -a 总用量 16 drwxr-xr-x 3 linux linux 4096 12月 29 10:13 ./ drwxr-xr-x 38 linux linux 4096 12月 29 10:12 ../ drwxrwxr-x 7 linux linux 4096 12月 29 10:13 .git/ 终端输入 ll- a查看一下隐藏文件，发现新产生一个 .git/文件。.git就是我们所说的本地仓库(版本库)
本地仓库是 Git 用来存储项目历史记录和版本信息的地方。它是存储在工作目录下的一个隐藏目录（.git文件夹）。仓库包含了项目的历史提交记录、分支、标签等重要信息。
远程仓库：远程仓库是位于远程服务器上的存储库，用于备份、协作和共享代码。常见的远程仓库托管服务包括 GitHub、GitLab 和 Bitbucket。你可以使用 git remote add 命令将本地仓库与远程仓库关联，并使用 git push 命令将本地仓库的代码推送到远程仓库中（文章末尾会有介绍）
linux@chenxiao:~/Templates$ vim test12-29.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c994d18d6de147f123204cfdc94c2601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481cbb14e0a8fe198e4e9d38dbdc5718/" rel="bookmark">
			web前端——伸缩盒模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		15.伸缩盒模型
1.伸缩盒模型简介
2009 年，W3C 提出了一种新的盒子模型 -- Flexible box (伸缩盒模型，又称: 弹性盒子)。
。它可以轻松的控制:元素分布方式、元素对齐方式、元素视觉顺序 ......
。截止目前，除了在部分IE 浏览器不支持，其他浏览器均已全部支持。
。伸缩盒模型的出现，逐渐演变出了一套新的布局方案-- flex 布局
小贴士:
传统布局是指: 基于传统盒状模型，主要靠: display 属性+ position 属性+ float 属性。
flex 布局目前在移动端应用比较广泛，因为传统布局不能很好的呈现在移动设备上。
伸缩盒模型容器与项目
伸缩项目:伸缩客器所有子元素自动成为了:伸缩项日。
1仅伸缩容器的子元素成为了伸缩项日，孙子元案、重孙子元案等后代，不是伸缩项目。
2.无论原来是哪种元案（块、行内块、行内) ，一旦成为了体缩项目，全都会”块状化”.
在开发者工具中computed中可以看到每个元素的属性
伸缩盒里的伸缩项目是按主轴的方向排列的。
/*伸缩盒模型相关属性-start */
/*将该元素变为了伸缩容器 (开启了flex布局) */
display: flex;
/*调整主轴方向，水平从左到右，默认 */
/* flex-direction: row; */
/*调整主轴方向，水平从右到左 */
/* flex-direction: row-reverse; */
/* 调整主轴方向，垂直从上到下 */
/* flex-direction: column; */
/* 调整主轴方向，垂直从下到上 */
flex-direction: column-reverse;
主轴与侧轴
主轴: 伸缩项目沿着主轴排列，主轴默认是水平的，默认方向是:从左到右(左边是起点，右边是终点)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481cbb14e0a8fe198e4e9d38dbdc5718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a20702e07b92085a14814a364e78a67/" rel="bookmark">
			深度解刨性能测试工具Locust
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		An open source load testing tool.
一个开源性能测试工具。
define user behaviour with python code, and swarm your system with millions of simultaneous users.
使用Python代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。
如果你常关注我的博客，大概会注意到我有三、四年没有写过关于性能测试的文章了，其实，今年也没更新几篇像样的博客，反而是我最忙的一年，原因是在写一本关于接口自动化的书。
回到主题，为何突然关注性能测试工具？其实，我只是单纯对Locust工具本身感兴趣而已。1、它与目前主流的LoadRunner和Jmeter玩法都不一样。2、它完全基于Python开发，用Python来编写用户行为。
嗯，如果想用好它的话，你必须对Web开发有一定的认识。而且还要熟悉Python开发。
官方网站：Locust - A modern load testing framework
Locust安装 1、安装Python：
官方：Welcome to Python.org
安装Python2 或Python3
2、安装Locuse
2.1， 通过pip命令安装 /&gt; pip install locustio
2.2， 通过GitHub上克隆项目安装（Python3推荐）：https://github.com/locustio/locust
3、安装 pyzmq
If you intend to run Locust distributed across multiple processes/machines, we recommend you to also install pyzmq.
如果你打算运行Locust 分布在多个进程/机器，我们建议你也安装pyzmq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a20702e07b92085a14814a364e78a67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7e514e70e70062bf31b9f629dccaae9/" rel="bookmark">
			神经网络——torch.optim优化器的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		optimizer.step()是大多数优化器支持的简化版本。 一旦使用例如计算梯度，就可以调用该函数。 backward()反向传播。
文章目录
一、 官方文档
1. 什么是torch.optim？
2. How to use an optimizer（如何使用优化器）
2.1 Constructing it（构建它）
2.2 Per-parameter options（每个参数选项） 2.3 Taking an optimization step（采取优化步骤）
二、torch.optim的算法
2.1 torch.optim.Optimizer(params, defaults)
2.2 Adadelta
2.3 使用torch.optim.SGD进行学习
一、 官方文档
1. 什么是torch.optim？
torch.optim 是一个实现各种优化算法的包。 最常用的方法都已经支持了，接口也足够通用，以后也可以轻松集成更复杂的方法。
2. How to use an optimizer（如何使用优化器）
要使用 torch.optim，必须构造一个优化器对象，该对象将保持当前状态并根据计算的梯度更新参数。
2.1 Constructing it（构建它）
要构造一个优化器，你必须给它一个包含要优化的参数（都应该是变量）的迭代。 然后，您可以指定优化器特定的选项，例如学习率、权重衰减等。
Note:
如果您需要通过 .cuda() 将模型移动到 GPU，请在为其构建优化器之前执行此操作。 .cuda() 之后的模型参数将与调用之前的对象不同。
通常，在构建和使用优化器时，应该确保优化的参数位于一致的位置。
2.2 Per-parameter options（每个参数选项） 不会，后面补充。
2.3 Taking an optimization step（采取优化步骤）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7e514e70e70062bf31b9f629dccaae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27deb3d5309166e8dd8c420f61bcf7a5/" rel="bookmark">
			Axure软件大全：原型设计下载与学习指南！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axure可以有效地创建原型，包括绘制APP和网页的原型图、框架图、结构图等。Axure内置的小部件可以用来构建动态交互。即使新手设计师不懂程序代码，也可以在Axure中创建复杂、动态、功能丰富的原型。对于想要深入研究和花时间学习程序的设计师来说，Axure也可以用Axure构建复杂的交互和现实的网站和应用程序。本文将分享更简单的Axure下载教程。让我们看看。
更简单的Axure下载教程 Axure下载需要打开Axure官方网站，点击下载安装可以尝试30天，从官方网站到下载安装都是英语，英语不好的朋友可能需要比较翻译软件慢慢咨询。除了语言障碍外，Axure下载还有一些局限性，如Axure下载的原型设计，不能在中国在线发布，不能标记切割图，轻量级项目不能直接交付开发。Axure线框图不能与视觉设计图相关，也不能同时查看所有页面的全貌。
国内本土团队打造的一站式原型设计工具即时设计，原生中文语言更符合中国人的使用习惯和需求。即时设计开创了一种新的在线原型设计合作模式，无需在工具之间切换，一个工具就可以完成需求梳理、UI设计、原型设计、收集反馈、原型交付！更方便的是，Axure下载汉化替代版的即时设计支持Axure下载文件的一键/批量导入。导入Axure下载文件后，可以自由进行二次布局、评审、演示和分享。
如果要下载Axure汉化版即时设计，也很简单，可以轻松完成4步：
第一步：浏览器打开即时设计官网，点击下载Axure汉化版即时设计。
第二步：Axure下载汉化版即时设计支持下载Windows、Mac和Android版本，选择您需要的版本下载即可
第三步：打开Axure下载汉化版即时设计下载路径，双击exe程序文件，点击操作并选择软件安装路径。
第四步：选择安装路径后，点击【安装】按钮，等待几秒钟，Axure下载汉化版即时设计下载即可完成。
点击Axure下载汉化版即时设计图标，或在安装完成后检查操作即时设计，通过短信或微信扫码即可使用！
在线打开Axure教程 Axure需要下载计算机软件使用，并且有一个更复杂的操作界面。即时设计基于网络，无需下载和安装，即时设计网站可以在线使用。Axure下载中文版即时设计功能相同，具有一站式原型、设计、交付能力、视觉效果、交互效果、体验效果一站式成型，为用户创造流畅的体验。您只需要免费注册即时设计帐户，即时浏览器使用Axure在线下载中文版即时设计。
在原型功能方面，即时设计与Axure下载几乎相同。在体验和资源供给方面，更多地考虑了当地设计师的工作环境和应用需求。全中文环境和简单易懂的操作界面，即使是初学者也能轻松上手。这款专业的在线原型设计工具可以为您的团队提供很多效率。
高效率。即时设计社区拥有大量的线框、原型模板等设计资源，使高保真原型设计从头到尾交付体验，节省大量其他重复无聊的工作时间，开始敏捷高效的工作。
即时设计 - 可实时协作的专业 UI 设计工具即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://ad.js.design/special/prototype/?source=csdn&amp;plan=bttcsdn1023
方便。即时设计支持交互事件演示，丰富的过渡动画，即时、溶解、智能动画、推广、滑动、滑动等逐渐出现效果，轻松构建优秀的用户体验交互，体验最终的产品形式。
可测试、反馈和迭代。即时设计支持低代码交付，所有图形信息都可以转换为代码，开发人员可以直接在代码面板中查看和复制代码。
原型设计开启了一种新的合作模式。即时设计支持建立一个流畅的原型框架过程，并对产品的整体方案进行具体的演示，以便产品经理、设计师和开发人员共同探索和分析用户的核心需求。
即时设计 - 可实时协作的专业 UI 设计工具即时设计是一款支持在线协作的专业级 UI 设计工具，支持 Sketch、Figma、XD 格式导入，海量优质设计资源即拿即用。支持创建交互原型、获取设计标注，为产设研团队提供一站式协同办公体验。https://ad.js.design/special/prototype/?source=csdn&amp;plan=bttcsdn1023
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68300b9b4079cd60eb94fdbabbe75421/" rel="bookmark">
			k8s---声明式资源管理（yml文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在k8s当中支持两种声明资源的方式： 1、 yaml格式：主要用于和管理资源对象
2、 json格式：主要用于在API接口之间进行消息传递
声明式管理方法(yaml)文件 1、 适合对资源的修改操作
2、 声明式管理依赖于yaml文件，所有的内容都在yaml文件当中。
3、 编辑好的yaml文件还是要靠陈述式命令发布到k8s集群当中。
有三种方式： create -f：只能创建，不能更新。从指定yml文件读取配置，创建服务，不能更新。 apply -f：即可以创建资源对象也可以更新资源对象。如果yml文件更改了，apply可以直接更新资源对象。 delete -f：删除yml文件中声明的资源对象 yml文件如何生成： 1.手动书写
2.可以根据已有的资源，成功生成。
kubectl get deplotment deployment.apps nginx -o yaml &gt; /opt/test.yaml kubectl apply -f test.yaml --force #强制执行yaml文件 #如果不想使用最新的deployment再创建yaml文件可以使用--force强制执行 kubectl get svc nginx-service -o yaml &gt; /opt/service.yaml 常见的yaml类型 1、 deployment的yaml文件格式用于部署还有daemonset和statefulser
2、 service的yaml文件用于暴露服务端口
3、 不基于控制器的pod的yaml文件
k8s当中支持两种声明式的资源管理方式： 1.yml格式，用于配置和管理资源对象
2.json格式：主要用于在api接口之间消息的传递
如何查看deployment的格式模板 kubectl explain deployment 如何用yaml文件编写 cd /opt vim nginx1.yml apiVersion: apps/v1 #声明api版本标签 kind: Deployment #定义资源的类型：service/pod/deployment/job/ingress/daemonset/statfluset metadata: name: nginx1 namespace: zzr labels: zhaozirui: nginx1 #定义资源的元数据信息 ，比如资源的名称，资源对象部署的命名看空间也可以在这里声明，标签等等信息 spec: #定义deployment的资源需要的参数属性。 replicas: 3 #定义副本数 selector: #定义标签选择器 matchLabels: zhaozirui: nginx1 #选择匹配的标签 template: #定义业务模板：如果定义了多个副本，所有的副本属性都会按照模板的配置进行匹配。 metadata: labels: zhaozirui: nginx1 #定义了pod的副本都是用来元数据的标签和属性来进行匹配 spec: containers: - name: nginx image: nginx:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68300b9b4079cd60eb94fdbabbe75421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1116d861d9672644a6e682293829d675/" rel="bookmark">
			红警源代码居然开源了....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：小詹学Python
红警，准确的说应该叫“红色警戒”，是大部分 80 后记忆里跟游戏二字关系最深的情节。
相信每一名 80 后，都有一段难忘的红警岁月，甚至可以说很多人的青春，就叫红警!
说到红色警戒游戏，估计应该是很多同学的童年回忆了吧。
图片 或者
图片 大概在 2000 年之后，星际和红警都在网吧必装游戏之列。
这款游戏也是当年西木头(WestWood)打造的爆款即时战略游戏之一，以至于一提到即时战略游戏，我脑海中第一个浮现的就是红警了。
一九九八年八月十七日，EA收购了Westwood。一般来只要是游戏工作室被EA收购后，就等于是走向了坟墓。
被收购之后，由于EA的管理不善，西木头最终走向了衰落，后面再也没有开发出红警2这样的爆款游戏了。
图片 不过就在最近，有网友在 Github 上发现，EA 悄悄地搞了个大事件，把《命令与征服》系列中的 2 个游戏的部分源码开源了！
PS：《命令与征服》系列是西木工作室(Westwood Studios)的招牌作品。1998 年，EA 收购了西木。
这两个游戏分别是：Tiberian Dawn（泰伯利亚的黎明） 和 Red Alert（红色警戒）。
图片 开源地址：
https://github.com/electronicarts/CnC_Remastered_Collection
这次开源的代码，其实是1996年发布的第一代红警，国内也称之为红警95。
此次开源，并不涉及游戏素材和游戏引擎，只包括 TiberianDawn.DLL 和 RedAlert.dll 的源码，允许 Mod 社区更好的改变游戏行为。
6 月 5 日，这两款游戏发布重制版。
命令与征服系列游戏是 C++ 实现，打开代码之后可以看到十分规范的代码，不由得令人叹服。
图片 下面是飞行器找新降落点的函数，函数功能、输入、输出、代码修改历史都写的非常清楚。
图片 至于为什么没有开源红警2呢？
一个很不幸的消息是红警2的源代码很可能已经丢失了。
最后在放两张图：
图片 &lt; END &gt;
AI变现训练营第五期，下周开营，错过这次就到明年了！
已经帮很多学员拿到了结果，如果你不想错过AI的风口，想寻找一份稳定的副业兼职，推荐你来了解一下。
如果你对这个项目的训练营感兴趣？或是正在思考如何利用业余时间做点什么？欢迎联系我们的助理甜甜咨询。
（对项目感兴趣，长按二维码加微信咨询）
另外还有大礼包福利相送，对于我公众号粉丝，加甜甜备注“微笑”，会额外送你一份价值199元的《AI代写实战操作手册》。
也许拿了这份手册，你也可以慢慢摸索出来，手册给大家讲明白了整个项目的逻辑和操作。
注意！添加务必备注：【微笑】，否则你拿不到实战操作手册。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff3afa41ccdccb68db428c47f2b6350/" rel="bookmark">
			LeetCode 155. 最小栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		155. Min Stack
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
Implement the MinStack class:
MinStack() initializes the stack object.void push(int val) pushes the element val onto the stack.void pop() removes the element on the top of the stack.int top() gets the top element of the stack.int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff3afa41ccdccb68db428c47f2b6350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4cdb035b7d766c33f786b18e9ffa2c/" rel="bookmark">
			【Java 基础】-- 实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义 创建对象的过程就叫实例化。这个过程中会在堆中开辟内存，将一些非静态的方法，变量存放在里面。在程序执行的过程中，可以创建多个对象，既多次实例化。每次实例化都会开辟一块新的内存。
2、实例化的几种方法 new 关键字创建 通过 new 关键字调用类构造器创建对象；调用对象的 getXXXInstance 方法（单例模式/建造者模式）；XXXBuilder/ XXXFactory。反射：Class的 newInstance 方法或者 Constructor 的 newInstance 方法使用类的 clone 方法使用反序列化（deserialization）第三方库 Objenesis 3、Java 类的生命周期 Java 类的生命周期是指一个 class 文件从加载到卸载的全过程，类的完整生命周期包括七个部分：加载——验证——准备——解析——初始化——使用——卸载。
PS：对象的生命周期请参考：Java对象的生命周期 - 简书
4、Java 类加载过程 加载：加载过程就是把class字节码文件载入到虚拟机中，至于从哪儿加载，虚拟机设计者并没有限定，你可以从文件、压缩包、网络、数据库等等地方加载class字节码。 通过类的全限定名来获取定义此类的二进制字节流将此二进制字节流所代表的静态存储结构转化成方法区的运行时数据结构在内存中生成代表此类的java.lang.Class对象,作为该类访问入口.验证：验证的目的是确保class文件的字节流中信息符合虚拟机的要求，不会危害虚拟机安全，使得虚拟机免受恶意代码的攻击，这一步至关重要。 文件格式验证源数据验证字节码验证符号引用验证准备：准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。(仅包含类变量,不包含实例变量).　解析：虚拟机将常量池中的符号引用替换为直接引用，解析动作主要针对类或接口，字段，类方法，方法类型等等。初始化：在该阶段，才真正意义上的开始执行类中定义的java程序代码，该阶段会执行类构造器，并且在Java虚拟机规范中有明确的规定，在下面5种情况下必须对类进行初始化： 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。使用java.long.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。当初始化一个类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类的初始化。当虚拟机启动时，需要制定一个执行的主类（即main方法的类），虚拟机必须先初始化这个类。使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。使用：使用该类所提供的功能，其中包括主动引用和被动引用。 主动引用： 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。通过反射方式执行以上三种行为。初始化子类的时候，会触发父类的初始化。作为程序入口直接运行时（也就是直接调用main方法）。被动引用： 引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。定义类数组，不会引起类的初始化。引用类的常量，不会引起类的初始化。卸载：从内存中释放，在我之前写的垃圾回收机制（GC）总结一文中有介绍到方法区内存回收中对类的回收条件，这里再贴出来一下： 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 5、小结 Java 的对象基本上都是在 jvm 的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。
PS：对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象），而类的整个生命周期则要比对象的生命周期长的多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39caad5e12227efdfdee4c076ec54052/" rel="bookmark">
			海信旗下“隐形冠军”信芯微，授权世强硬创代理32位MCU等产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，世强先进（深圳）科技股份有限公司（下称“世强先进”）与海信集团旗下子公司——青岛信芯微电子科技股份有限公司（下称“信芯微”，英文名：Hi-image）签订授权代理合作协议。
资料显示，信芯微（Hi-image）成立于2019年，该公司专注于芯片产品与技术研发，面向AIoT市场推出中高端芯片产品及解决方案，助力智能产品发展。
本次合作，信芯微（Hi-image）授权世强先进依托产品创新研发和供应平台世强硬创，上线32位MCU芯片以及低功耗蓝牙芯片产品。
据了解，信芯微（Hi-image）32位MCU主要包括大家电MCU以及工业控制类MCU。
其中，大家电MCU芯片——HS1028，内嵌32位RISC CPU内核，最高主频为120MHz，最大可支持32KB RAM&amp;256KB FLASH，支持LQFP100、LQFP64和LQFP48三种封装形式，工作电压介于2.7~5.5V，工作温度范围在-40~105℃，主要应用场景为电机控制、仪器仪表、家电主控等。
工业控制类MCU芯片——HS1031是一款32位芯片，内嵌高性能RISC CPU内核，最高主频120MHz，最大可支持16KB RAM&amp;512KB FLASH，支持QFN32和QFN24两种封装形式，工作电压介于2.2~3.6V，工作温度范围在-40~105℃，主要应用场景为工业控制、精密仪表、智能传感器等。
除了32位MCU产品外，信芯微（Hi-image）的蓝牙芯片——HT2058，内嵌高性能RISC CPU内核，内置32.768kHz RC振荡器，最高时钟频率为48MHz，支持外部32M和32.768k晶振，支持BLE5.0，支持多种外设接口，例如PGA功能的AMIC和DMIC声音采集接口；支持模拟与数字MIC，所有GPIO可任意配置为任意数字接口。
凭借出色的全流程设计开发能力，信芯微（Hi-image）产品工艺涵盖从55nm到12nm，出货量已累计超一亿颗，目前广泛应用于智能家电、工业控制、消费电子等领域，客户可以在世强硬创平台搜索“信芯微”，即可获取相关产品最新信息、样品申请、查看商品库存、选型帮助等服务。
在客户方面，信芯微（Hi-image）已与京东方、华星光电、惠科股份等主流面板厂商，以及海信、东芝、康冠等知名终端品牌形成了长期稳定的合作关系。
信芯微（Hi-image）表示：“世强硬创平台30年来积累了各行业丰富的客户资源，其O2O技术分销模式在业内也是独树一帜。未来，除深耕AIoT市场外，公司还将开拓汽车电子市场，携手世强为硬科技企业带来更高质量的MCU产品及服务。”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5700bdcbb6c4d1ba78388e764ee0756/" rel="bookmark">
			日常问题小计之无法保存JMeter测试计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无法保存JMeter性能测试计划 在今天进行JMeter执行性能测试的时候，浅浅发现，每次发起请求都会提示：
Warning!
You should save your test plan before running it.lf you are using supporting data files (ie, for CSV Data Set or StringFromFile)then it is particularly important to first save your test script.Do you want to save your test plan first?
即：在运行测试计划之前是否要保存测试计划
该问题可能是因为电脑中安装的JDK版本过高，即卸载安装的高版本JDK，重新配置新的JDK环境变量，重启JMeter即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e669e8a627fe875973657d2282e1f18/" rel="bookmark">
			浏览器使用隧道代理HTTP：洞悉无界信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信息爆炸的时代，互联网已经成为获取信息的首选渠道。然而，在某些地区或情况下，访问某些网站可能会受到限制。这时，隧道代理HTTP便成为了一个重要的工具，帮助用户突破限制，洞悉无界信息。
一、隧道代理HTTP的原理与优势
隧道代理HTTP是一种网络通信方式，通过建立一条虚拟的通信隧道，用户可以绕过本地的网络限制，直接连接到外部的服务器，再由外部服务器连接到目标网站。这种方式不仅可以提高网络访问的速度，还可以保护用户的隐私。
二、如何在浏览器中使用隧道代理HTTP
打开浏览器，进入设置页面。不同浏览器的设置页面位置可能有所不同，但通常可以在菜单栏或选项中找到。在设置页面中，找到网络设置或代理设置选项。这一步可能因浏览器的不同而有所差异。在代理设置中，选择使用代理服务器。输入代理服务器的地址和端口号，并选择代理服务器类型。保存设置后，浏览器将通过代理服务器进行网络通信。 三、注意事项
选择可靠的代理服务器：使用隧道代理HTTP时，应选择可靠的代理服务器，以确保网络通信的安全性和稳定性。注意隐私保护：在使用隧道代理HTTP时，用户的网络活动将被代理服务器记录。因此，用户应注意隐私保护，避免在代理服务器上存储敏感信息或进行敏感操作。遵守法律法规：在使用隧道代理HTTP时，应遵守当地的法律法规和网络规定。不得利用隧道代理HTTP进行违法活动或侵犯他人权益。注意网络安全：在使用隧道代理HTTP时，应注意网络安全问题。避免使用存在安全漏洞的代理服务器，以免遭受网络攻击或数据泄露的风险。 总之，隧道代理HTTP是一种实用的工具，获取更多的信息。但在使用过程中，用户应注重安全和隐私保护，遵守法律法规和网络规定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be9f1f7cc5747f19c32fe7bf22dd275/" rel="bookmark">
			git更改.ignore文件之后如何生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git更改.ignore文件之后如何生效
1、首先按照语法更改.ignore文件。
2、git rm -r --cached . #清除缓存
3、git add . # 重新trace file
4、git commit -m “update .gitignore” #提交变更并注释
5、git push origin master #如果需要同步到remote的主分支的话
6、之前在git commit 时看到了delete mode …
如果那些正是我想要忽略的东西，说明新的忽略成功生效了
如果忽略的东西不太相符，，是写的语法语句有问题，需要重新更改.gitignore文件使之重新生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3097cf2bf7ce04534eded9c0dae26de8/" rel="bookmark">
			冒泡排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡排序，也称为Bubble Sort，是一种简单的计算机科学排序算法。该算法重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。这个过程会不断重复，直到没有再需要交换的相邻元素为止，也就是说该数列已经排序完成。
冒泡排序的名字来源于越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
冒泡排序的基本思想是通过对待排序序列从前向后（从下标较小的元素开始），依次对相邻两个元素的值进行两两比较，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒出。例如，对于一个待排序数组：3，9，-1，10，20，第一轮排序后，将最大的元素20固定到了最后的位置；然后在第二轮排序时，因为20的位置已经固定，所以只对前4个进行排序即可。
优化：
因为排序的过程中，个元素不断接近自己的位置，如果一次比较下来没有进行交换过，说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行交换过。从而减少不必要的比较。
推敲冒泡排序中： public class Sort { public static void main(String[] args) { //原始的冒泡排序 int arr[] = {3, 9, -1, 10, -2}; System.out.println("====排序前===="); System.out.println("第0轮：" + Arrays.toString(arr)); System.out.println("===开始排序==="); int temp; for (int j = 0; j &lt; arr.length - 1; j++) { if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } System.out.println("第1轮：" + Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3097cf2bf7ce04534eded9c0dae26de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced38d8dde83a9f87d5fb0fa7cf3d06f/" rel="bookmark">
			解决linux系统时间与网络时间不一致，linux同步网络时间，未找到匹配的参数: ntpdate，错误：没有任何匹配: ntpdate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
CentOS8系统中，原有的时间同步服务 ntp/ntpdate服务已经无法使用，使用yum安装，提示已不存在
[root@localhost ~]# yum install ntp 上次元数据过期检查：-1 day, 16:29:03 前，执行于 2023年10月03日 星期一 19时00分30秒。 未找到匹配的参数： ntp 错误：没有任何匹配: ntp 1、在CentOS8中，已使用chrony替代ntp，首先安装chrony
#使用dnf安装 dnf install -y chrony # 也可以用yum安装 yum install -y chrony 2、永久设置同步时间服务器（修改配置文件）
vim /etc/chrony.conf 3、注释掉第三行原有的时间服务器地址，设置为阿里云的时间服务地址
如果已经是阿里云的请忽略这一步
server 0.centos.pool.ntp.org iburst
server 1.centos.pool.ntp.org iburst
server 2.centos.pool.ntp.org iburst
server 3.centos.pool.ntp.org iburst
阿里云提供了7个NTP时间服务器也就是Internet时间同步服务器地址 ntp1.aliyun.com ntp2.aliyun.com ntp3.aliyun.com ntp4.aliyun.com ntp5.aliyun.com ntp6.aliyun.com ntp7.aliyun.com 4、重启网络时间服务chrony，并设置服务后台运行
#重启时间服务 systemctl restart chronyd.service #设置时间同步服务开机启动 systemctl enable chronyd.service 5、使用date查看当前时间
date 方法二：
1、安装CentOS系统NTP校时包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced38d8dde83a9f87d5fb0fa7cf3d06f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/630b262032ab21700a7529d6f71eb4f2/" rel="bookmark">
			Navicat 连接 Oracle 报错：ORA-28547：connection to server failed，probable Oracle Net admin error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1 报错截图2 原因分析3 解决办法3.1 查询数据库版本3.2 下载对应的 oci.dll 文件3.3 放置 oci.dll 文件3.4 测试连接 1 报错截图 2 原因分析 Navicat 自带的 oci.dll 不支持 Oracle 11g 3 解决办法 在 navicat 中导入对应数据库的 oci.dll 文件步骤参考如下： 3.1 查询数据库版本 -- 如：11.2.0.4.0 select * from v$version; 3.2 下载对应的 oci.dll 文件 官方网站：https://www.oracle.com/database/technologies/instant-client/downloads.html 3.3 放置 oci.dll 文件 3.4 测试连接 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4c1e7babea3be7faa048d017a322fb/" rel="bookmark">
			Address Already In Use: JVM_Bind 端口被占用的几个解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Address Already In Use: JVM_Bind 端口被占用的几个解决办法
运行Tomcat时若出现Address already in use: JVM_Bind 端口被占用，一般使用下面几个办法可以解决：
假设端口为8080
1.启动cmd, 执行命令netstat -ano|findstr 8080 ，会查询出占用端口号的进程号，这时候执行命令
taskkill -f -pid 进程号 杀死进程，然后重启Tomcat即可解决
2.若方法一查询不到进程，（假设使用IDEA）则在Run- Edit Configurations中删掉添加的Tomcat，之后再重新配置Tomcat及其artifacts等，可解决
3.若还是不行，Ctrl Shift Delete 打开资源管理器，关掉Idea和Java jvm的进程，重新打开idea 尝试运行
4.关机重启@TOC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb30e77fffa1b7441620ed77844cb13a/" rel="bookmark">
			Linux DataEase数据可视化分析工具结合内网穿透实现远程访问管理界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 安装DataEase2. 本地访问测试3. 安装 cpolar内网穿透软件4. 配置DataEase公网访问地址5. 公网远程访问Data Ease6. 固定Data Ease公网地址 前言 DataEase 是开源的数据可视化分析工具，帮助用户快速分析数据并洞察业务趋势，从而实现业务的改进与优化。是开源的数据可视化分析工具，帮助用户快速分析数据并洞察业务趋势，从而实现业务的改进与优化。
在本地搭建后,借助cpolar 内网穿透实现远程公网地址即可访问DataEase 的web ui 界面, 这样方便我们在任何设备上都可以随时打开DataEase 进行查看数据分析!
1. 安装DataEase Linux 搭建安装 DataEase 也是比较方便,按照Github 方式 ,采用官方方法,一键安装命令,一键安装:
curl -sSL https://dataease.oss-cn-hangzhou.aliyuncs.com/quick_start.sh | bash 安装完成后,可以看到提示的方式访问,服务端口默认在80,并且提供了默认的用户名和初始密码
2. 本地访问测试 上面我们成功搭建了DataEase 服务,现在本地测试访问,在外部浏览器输入Linux局域网ip地址+80端口,或者Linux 内部图形化界面浏览器输入本机ip+80端口进行访问,这边使用第二种方式,在Linux 图形化界面访问,输入:http://localhost:80 ,即可看到DataEase 登录界面,本地访问测试OK,下面我们安装cpolar 内网穿透工具,实现远程访问
3. 安装 cpolar内网穿透软件 上面我们在本地Linux中安装和启动了DataEase服务,并且本地访问ok,下面我们在Linux安装cpolar内网穿透工具,通过cpolar的http公网地址,我们可以很容易实现远程访问jump server,而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar cpolar安装成功后，在外部浏览器上访问Linux 的9200端口即:【http://局域网ip:9200】，使用cpolar账号登录,登录后即可看到cpolar web 配置界面,结下来在web 界面配置即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb30e77fffa1b7441620ed77844cb13a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8381ab4ed42afcc0e5fd4f002c53149/" rel="bookmark">
			Tomcat 安装和运行教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Tomcat 安装1.1 选择合适的 Tomcat 版本1.2 下载 Tomcat1.3 配置环境变量 二、 运行 Tomcat2.1 启动 Tomcat2.2 关闭 Tomcat 参考资料 一、Tomcat 安装 1.1 选择合适的 Tomcat 版本 Apache Tomcat 是 Jakarta EE（正式JavaEE）技术子集的开源软件实现。不同版本的 Apache Tomcat 可用于不同版本的规范。在 Tomcat官网，规范和相应 Apache Tomcat 版本之间的映射是：
Servlet SpecJSP SpecEL SpecWebSocket SpecAuthentication (JASPIC) SpecApache Tomcat VersionLatest Released VersionSupported Java Versions6.14.06.0TBDTBD11.0.x11.0.0-M15 (alpha)21 and later6.03.15.02.13.010.1.x10.1.1711 and later5.03.04.02.02.010.0.x (superseded)10.0.27 (superseded)8 and later4.02.33.01.11.19.0.x9.0.848 and later3.12.33.01.11.18.5.x8.5.977 and later3.12.33.01.1N/A8.0.x (superseded)8.0.53 (superseded)7 and later3.02.22.21.1N/A7.0.x (archived)7.0.109 (archived)6 and later (7 and later for WebSocket)2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8381ab4ed42afcc0e5fd4f002c53149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1727945f36fb5db43bd17e5d77c0765d/" rel="bookmark">
			Microsoft Visual Studio 2022 install Project 下载慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 关闭Internet 协议版本6
2. 如果没有效果，打开Internet 协议版本4，更改DNS
3. 在浏览器中下载后安装，下载地址如下：
Microsoft Visual Studio Installer Projects 2022 - Visual Studio Marketplace
4. 安装时注意关闭vs，否则无法继续。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b31d1776c7c87c5b6ccdf15cfbd70a2/" rel="bookmark">
			航芯ACM32G103开发板评测 03 RT-Thread Nano移植 线程管理测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		航芯ACM32G103开发板评测 07 RT-Thread Nano移植 线程管理测试 1. 软硬件平台 ACM32G103 Board开发板MDK-ARM KeilRT-Thread Nano 源码
2. 物联网RTOS—RT-Thread ​ RT-Thread诞生于2006年，是一款以开源、中立、社区化发展起来的物联网操作系统。 RT-Thread主要采用 C 语言编写，浅显易懂，且具有方便移植的特性（可快速移植到多种主流 MCU 及模组芯片上）。RT-Thread把面向对象的设计方法应用到实时系统设计中，使得代码风格优雅、架构清晰、系统模块化并且可裁剪性非常好。RT-Thread完整版，通过在线的软件包管理工具，配合系统配置工具实现直观快速的模块化裁剪，并且可以无缝地导入丰富的软件功能包，从而实现复杂功能。
RT-Thread Nano 是一个极简版的硬实时内核，它是由 C 语言开发，采用面向对象的编程思维，具有良好的代码风格，是一款可裁剪的、抢占式实时多任务的 RTOS。其内存资源占用极小，功能包括任务处理、软件定时器、信号量、邮箱和实时调度等相对完整的实时操作系统特性。适用于大量使用的 32 位 ARM 入门级 MCU 的场合。下图是 RT-Thread Nano 的软件框图，包含支持的 CPU 架构与内核源码，还有可拆卸的 FinSH 组件：
支持架构：ARM：Cortex M0/ M3/ M4/ M7 等、RISC-V 及其他。
功能：线程管理、线程间同步与通信、时钟管理、中断管理、内存管理。
RT-Thread Nano的特点 下载简单
RT-Thread Nano 以软件包的方式集成在 Keil MDK 与 CubeMX 中，可以直接在软件中下载 Nano 软件包获取源码，获取方式详见 基于 Keil MDK 移植 RT-Thread Nano 与 基于 CubeMX 移植 RT-Thread Nano 。同时也提供 下载 Nano 源码压缩包 的途径，方便在其他开发环境移植 RT-Thread Nano，如 基于 IAR 移植 RT-Thread Nano。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b31d1776c7c87c5b6ccdf15cfbd70a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d93e9dd743ce5caec05ca58cfd319175/" rel="bookmark">
			航芯ACM32G103开发板评测 02-GPIO输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		航芯ACM32G103开发板评测 02-GPIO输入输出 航芯ACM32G103开发板评测 GPIO输入输出应用
软硬件平台
ACM32G103 Board开发板
MDK-ARM Keil
GPIO输出典型应用——点灯
GPIO输入典型应用——按键
GPIO 功能概述 GPIO 是通用输入/输出（General Purpose I/O）的简称，主要用于工业现场需要用到数字量输入/输出的场合，例如：
输出功能：继电器、 LED、蜂鸣器等的控制输入功能：传感器状态、高低电平等信息的读取复用功能：片内外设的对外接口时序模拟：模拟 SPI、I2C 和 UART 等常用接口的时序 GPIO 功能特性 多种工作模式：每个 GPIO 引脚可以独立配置为输出（推挽或开漏）、输入、外设复用功能或模拟模式。每个 GPIO 引脚可以独立配置为上拉、下拉或浮空。灵活的复用模式：复用功能（AF）的备用引脚，极大提高了端口利用的灵活性。GPIO引脚通过配置相关的寄存器可以用作复用功能输入/输出引脚。
GPIO具体细节见航芯ACM32G103_用户手册V1.3 P393 查看acm32官方库函数文件，查看api函数
/* Exported functions --------------------------------------------------------*/ void GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init); void GPIO_DeInit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin); void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct); GPIO_PinState GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin); uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx); GPIO_PinState GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx); void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); void GPIO_WriteBit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin, GPIO_PinState PinState); void GPIO_Write(GPIO_TypeDef *GPIOx, uint16_t PortVal); void GPIO_ToggleBits(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin); void GPIO_PinLockConfig(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin); GPIO输出 LED点灯 在航芯ACM32G103开发板中，一共有3个led，但是只有一个user_led可以去控制，其中，pow_led com_led作为提示作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d93e9dd743ce5caec05ca58cfd319175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7844fc180f8e1f2e12cf4e75379b6222/" rel="bookmark">
			航芯ACM32G103开发板评测 01-开箱及环境搭建流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01-航芯ACM32G103开发板开箱及环境搭建流程 ACM32G103开发板资源简介 ACM32G103系列是航芯推出的一款有着丰富模拟外设及安全存储扩展能力的高性价比通用MCU。
**高性能：**采用STAR-MC1内核（兼容M33和M4指令集），工作主频120MHz，支持浮点运算和DSP，自带CORDIC三角函数硬件加速器，兼具优异的运算处理能力与超低功耗特性（STOP2模式下&lt;15uA）。
**大容量存储空间：**采用320KB 片上eFlash，64KB SRAM大容量存储空间，并自带Flash加速器实现零等待访问。
**集成丰富模拟外设：**内置2个高级定时器，2路19通道4Msps ADC，1路2通道DAC，4路比较器，3路运算放大器，满足双电机FOC控制要求。
**更强的保护功能，提升数据安全性：**内置AES密码算法硬件加速引擎，内置高质量随机数发生器，有效保护用户代码不被窃取和篡改。
上海航芯ACM32G103开发板评测计划 仓库https://gitee.com/End-ING/embedded-acm32-board
doc 开发过程中使用的手册（很重要）
sdk 包括标准库和HAL相关参考例程 （很重要）
note 测评学习笔记记录
环境搭建流程参考 航芯ACM32G103开发环境搭建 http://bbs.eeworld.com.cn/thread-1265880-1-1.html
基本上大多数的工程模板都是采用MDK-KEIL开发的，一般开发人员都安装好了，基本上没有啥子好说的。基本上只要安装这个pack包就可以了。Aisinochip.ACM32G1.1.0.2.pack。
我们以ACM32G103_SPL_SDK里面的工程作为基础，搭建自己的工程模板。以GPIO的工程为基础模板，当然其他的Example同样可以，这里面的基本案例都是值得学习的。
打开工程，编译0错误0警告。
接下来，我们将建立自己的工程模板
文件参考架构如下：
Application 主函数，应用层代码BspDrivers 板级驱模块动文件Drivers 底层驱动库文件 CMSIS Device SPL_DriverProject mdk工程文件 每个人都有自己的工程习惯，我的如下。打开工程，编译0错误0警告。下载代码即可。
需要注意使用的AC6，不是AC5.
板子板载了DAP,不需要其他的工具，很方便的就下载程序了
下载代码，查看串口终端打印结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8eaa3398c9c4c6c864ad7de1cdd5108/" rel="bookmark">
			K8S陈述式资源管理（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令行: kubectl命令行工具
优点: 90%以上的场景都可以满足对资源的增，删，查比较方便，对改不是很友好
缺点:命令比较冗长，复杂，难记声明式
声明式：K8S当中的yaml文件来实现资源管理
GUI：图形化工具的管理
kubectl命令的详解
查看 部署 查看pod的情况（详细信息和日志，发布和回滚）
Kubernetes kubectl 命令表 _ Kubernetes(K8S)中文文档_Kubernetes中文社区
查看k8s版本信息
kubectl version
查看K8S资源当中，所有资源对象的名称以及简写
kubectl api-resources
查看K8S集群信息
kubectl cluster-info
source &lt;(kubectl completion bash)
查看MASTER节点的状态（基本信息查看）
kubectl get cs
查看默认命名空间default内的pod的信息
kubectl get pod
查看当前集群所有的命名空间
kubectl get ns
查看指定命名空间内的pod，需要加 -n+命名空间的名称
kubectl get pod -n kube-system
查看默认命名空间内pod的详细信息
kubectl get pod -o wide
查询节点信息和状态
kubectl get node
查看node节点的详细信息
kubectl get node -o wide
查看已经部署好的pod的详细信息
kubectl get pod
kubectl describe pod nginx-6799fc88d8-f9c8g
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8eaa3398c9c4c6c864ad7de1cdd5108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38eb3cc584a2e401734eb75e220ea3d9/" rel="bookmark">
			全新SharePoint Premium介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2023年微软 Ignite 会议中，微软推出了 SharePoint Premium，这是一个人工智能平台，旨在改变你在云中的内容体验。SharePoint Premium 是微软 Syntex 的进化。
什么是SharePoint SharePoint 是微软开发的协作和内容管理平台。自2001年以来可用，主要用于企业。它提供了一套服务，使组织能够在组织内部高效地共享和管理文档、信息和想法。
SharePoint 允许创建内部网站以促进团队内的协作、文档存储和管理以及版本跟踪。该平台还提供高级特性，如论坛、表单、工作流和商业分析。
有两种类型的产品：
SharePoint Online 部署在微软数据中心托管并由微软维护的 SaaS 版本。SharePoint Server 部署在服务场的经典服务器版本。 SharePoint 赋予你通过动态站点、个性化新闻和安全文件共享来协作、通知和分发的能力。
协作：通过 Microsoft Teams 中的动态站点赋能团队。同步并安全地共享文件、数据和资源。通知：在内部网上发布信息和资源。用吸引人的定制站点和有针对性的个性化新闻讲述你的故事。分发：在与 Microsoft 365 集成的灵活、大规模云平台上访问、管理和存储协作和交易内容。 SharePoint Premium SharePoint Premium 引入了与你的高价值内容互动的创新方法，在其生命周期中管理和保护它。它还通过确保内容的安全性并为其提供适当的结构，为其准备 Copilot for Microsoft 365，这是重新定义生产力的革命性 AI 助手，来优化内容价值。
内容体验和解决方案： 通过保持内容更新、鼓励发现和在各种文件类型上协作来提高员工生产力，改善业务流程。通过 AI、安全性和工作流优化关键业务文档流程，如合同和发票。
内容处理： 使用 AI 引导的自动化进行文档创建、分类和标记，以最大化内容价值，从而为 Copilot 准备内容。
内容治理： 通过管理内容生命周期和使用简单而强大的工具控制访问，主动解决过度共享和内容扩散的问题。
内容体验 内容管理系统必须超越仅仅存储文件。它们应该提供全面的解决方案，可以在你的高价值文档的整个生命周期中利用任何文件。
微软将 Office 协作的力量扩展到了集成的文件查看器。支持超过400种文件类型，你很快将能够在任何支持的文件类型上添加注释、评论、提及、任务等等，就像你今天对 Office 文档所做的那样。
在新的 Teams Business Documents application中，你可以协作处理合同、工作声明、订单、发票等等。你还可以查看重要文档的完整列表。你将收到可操作的洞察，例如对于即将到期或需要特别关注的合同的timely alerts。
你可以在 Word 中使用standard templates创建新合同，利用内容汇编填写新合同的关键细节。你还可以利用新的 AI 驱动规则偏差引擎比较合同与相关合同，突出可能需要特别关注或存在风险的变化。一旦批准，合同可以使用 SharePoint eSignature 发送。信息保持安全（在 Microsoft 365 内）：它不会离开你的租户，你可以让外部方签署和批准文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38eb3cc584a2e401734eb75e220ea3d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec7b2daaa650dfd8616db636f133f1a/" rel="bookmark">
			前端实现页面内容的截图与下载（html2canvas）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端实现页面内容的截图与下载（html2canvas）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ce46d22cc1d61a8cd78f05faa298a8/" rel="bookmark">
			71内网安全-域横向网络&amp;传输&amp;应用层隧道技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必备知识点； 代理和隧道技术的区别？
代理主要解决的是网络访问问题，隧道是对过滤的绕过，
隧道技术是为了解决什么
解决被防火墙一些设备，ids（入侵检测系统）进行拦截的东西进行突破，举个栗子；在实战情况可能会cs和msf没有办法上线或者得到回显，出口数据被监控，在拖数据的时候会被拦截，网络通信存在问题等 ；
隧道技术前期必备的条件？
应用场景四已经获得了一些控制权，但是不能对肉鸡进行信息收集等一些执行功能；比如利用shior反序列化得到了一些权限，但是漏洞上有ids，把后门放到了对方服务器但是cs上不了线，
这个时候就是隧道技术的应用场景，
在数据通信被拦截的情况下利用隧道技术封装改变通信协议进行绕过拦截，比如你之前是用tcp协议，通过隧道技术可以把tcp协议转换成其他的协议封装出去；防火墙会对一些协议进行流量监控，有一些协议放行，我们就伪装成他放行的协议进行绕过；
在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统（ids）来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，防火墙会有拦截什么协议和端口的设置，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。
常用的隧道技术有以下三种：
网络层：IPv6隧道、ICMP隧道
传输层：TCP隧道、UDP隧道、常规端口转发
应用层：SSH隧道、HTTP/S隧道、DNS隧道 案例一网络传输应用层检测连通性-检测 探针他的协议是否支持，测试这个协议可不可以用。
在肉鸡没办法上线，通信有异常的时候，就要去绕过他，要绕过他肯定要选择一个隧道，隧道的协议有很多，我们确定对方支持什么样的隧道，比如我们想做icmp隧道，我们就要去检测，他支不支持icmp隧道的开启，
1.TCP协议
用“瑞士军刀”netcat，执行nc命令：
nc &lt;IP&gt; &lt;端口&gt;
2.HTTP协议
用curl工具，执行：
curl &lt;IP地址:端口&gt;
如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息
3.ICMP协议
用ping命令，执行：
ping &lt;IP地址/域名&gt;
4.DNS协议
检测DNS连通性常用的命令是nslookup和dig
nslookup是windows自带的DNS探测命令
dig是linux系统自带的DNS探测命令 再用隧道之前，要先探针一下，对应的隧道协议，对方是否是支持的，
案例二网络层ICMP隧道ptunnel使用-检测，利用 拓扑图
目的；通过web服务器，实现对dc端的控制，但是dc上面有防火墙和ids防护
现在已经得到了dc上面的账号密码，但是现在我不可能用本机连接到dc端的，
利用工具；
老版本介绍：https://github.com/f1vefour/ptunnel(需自行编译)，不推荐已经不更新了
新版本介绍：https://github.com/esrrhs/pingtunnel(二次开发版) pingtunnel是把tcp/udp/sock5流量伪装成icmp流量进行转发的感觉，
-p 表示连接icmp隧道另一端的机器IP（即目标服务器）
-lp 表示需要监听的本地tcp端口
-da 指定需要转发的机器的IP（即目标内网某一机器的内网IP）
-dp 指定需要转发的机器的端口（即目标内网某一机器的内网端口）
-x 设置连接的密码
利用之前先判断一些icmp协议可不可以用，判断一下隧道可不可行，通过ping命令判断完可写，
首先现在web肉鸡上执行一条命令
./ptunnel -x xiaodi xiaodi就是设置的密码 在web肉鸡上把工具启动
在kali上运行
./ptunnel -p 192.168.76.150（web肉鸡的ip） -lp 1080（kali1 080端口） -da 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ce46d22cc1d61a8cd78f05faa298a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef5ab9dc00476cbc15555046d807a52/" rel="bookmark">
			解决报错：RuntimeError: Found more than one stateful callback of type `ModelCheckpoint`.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Why 报错？报错原因及解决方法 当我使用 pytorch-lightning 的时候，突发地报了如下错误：
RuntimeError: Found more than one stateful callback of type `ModelCheckpoint`. In the current configuration, this callback does not support being saved alongside other instances of the same type. Please consult the documentation of `ModelCheckpoint` regarding valid settings for the callback state to be checkpointable. HINT: The `callback.state_key` must be unique among all callbacks in the Trainer. Why 报错？ 配置文件中的 modelcheckpoint 和 metrics_over_trainsteps_checkpoint 都有在 every_n_train_steps 属性，如果他们的数值相同就会报此error。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef5ab9dc00476cbc15555046d807a52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c1bfab941a9f39517739fe32b4ece6/" rel="bookmark">
			以太坊交易手续费计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gas 中译是：瓦斯、汽油，代表一种可燃气体。 这形象地比喻以太坊的交易手续费计算模式，不同于比特币中直接支付比特币作为转账手续费， 以太坊视为一个去中心化的计算网络，当你发送Token、执行合约、转移以太币或者在此区块上干其他的时候，计算机在处理这笔交易时需要进行计算消耗网络资源，这样你必须支付燃油费购买燃料才能让计算机为你工作。最终燃料费作为手续费支付给矿工，无论交易成功与否。
参考文章 What is gas? Why do transactions take so long?
以太坊技术与实现 Gas
经典例子 以太坊白皮书给出的转账时计算Gas的例子如下，假设合约存储开始时为空，发送一笔带有10 ETH、2000 Gas、0.001以太币Gas价格的交易，并且有两个数据字段：[2, ‘CHARLIE’]：
验证交易的有效性和格式：检查交易是否有效，格式是否正确。这包括验证交易的结构、签名以及发送者是否有足够的资金来支付最大可能的Gas费用。检查发送者的资金：确保交易发送者账户中至少有2000 * 0.001 = 2 ETH。如果有，那么从发送者的账户中扣除2以太币作为可能的最大Gas费用。注意：这是从交易发送者的钱包里扣除的，不是从10 ETH的交易金额中扣除的初始化Gas和扣除字节费：初始化Gas为2000。假设交易长度为170字节，每字节费用为5，因此扣除850（170*5），剩下1150Gas。处理交易金额：从发送者账户中再扣除10以太币，并将其加到合约账户中。这是交易中指定的转账金额。执行代码：运行合约代码。在这个例子中，操作相对简单：检查合约存储的索引2是否已被使用，发现未被使用，于是将索引2的存储值设置为’CHARLIE’。假设这个过程消耗了187Gas，剩余Gas为1150 - 187 = 963。退还剩余Gas：将未使用的Gas转换回以太币并退还给发送者。在这个例子中，退还的是963 * 0.001 = 0.963 ETH。最后返回交易执行后的状态。计算扣除的总金额：发送的ETH（10 ETH）+ 实际消耗的Gas费用（1.037 ETH）= 用户账户最终减少的总金额（11.037 ETH）。 实际例子 以下是我用老ThinkPad电脑在测试网络里辛辛苦苦挖的一点币，大家也可以去挖挖试试
GoerliETH Faucet地址
现在我们从Account1转账0.001ETH给Account2，预估的Gas费用为0.0000315ETH，直接给你计算好了
也就是说我们这笔交易预估花费的总金额 = 0.001 ETH + 0.0000315 ETH = 0.0010315 ETH
稍作等待后，等到转账confirmed后，我们点击View on block explorer前往网页
也可以在 Goerli Testnet Explorer网站 搜寻transaction ID就行
可以从以下界面看到整个交易的过程
Transaction Fee = Gas Used * Gas Price = 21,000 Gas * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90c1bfab941a9f39517739fe32b4ece6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/590bfc3d6116f2edc48143a184878602/" rel="bookmark">
			matplotlib绘制折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码 import matplotlib.pyplot as plt import numpy as np def get_data(txt_path: str = '', epoch: int = 100, target: str = '', target_data_len: int = 5): # 函数介绍 # https://blog.csdn.net/LQ_001/article/details/130127681?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22130127681%22%2C%22source%22%3A%22LQ_001%22%7D num_list = [] # 将提取出来的数据保存到列表,并在最后返回 data = open(txt_path, encoding="utf-8") # 打开文件 str1 = data.read() # 将文件中读取到的内容转化为字符串 data.close() # 关闭文件 for i in range(0, epoch): index = str1.find(target) # 查找字符串str1中str2字符串的位置 num_list.append(float(str1[index+len(target):index+len(target)+target_data_len])) # 将需要的数据提取到列表中 str1 = str1.replace(target, 'xxxx', 1) # 替换掉已经查阅过的地方,' xxxx '表示替换后的内容，1表示在字符串中的替换次数为1 return num_list # 设置全局字体大小 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/590bfc3d6116f2edc48143a184878602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cad5036c91c3e2f4f6165da9638955/" rel="bookmark">
			mysql模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，可以使用LIKE关键字进行模糊查询。LIKE关键字用于匹配包含指定模式的字符串。
下面是使用LIKE进行模糊查询的示例：
匹配以指定字符串开头的值： SELECT * FROM table_name WHERE column_name LIKE 'value%'; 这将返回表中列column_name以"value"开头的所有行。
匹配以指定字符串结尾的值： SELECT * FROM table_name WHERE column_name LIKE '%value'; 这将返回表中列column_name以"value"结尾的所有行。
匹配包含指定字符串的值： SELECT * FROM table_name WHERE column_name LIKE '%value%'; 这将返回表中列column_name包含"value"的所有行。
匹配包含指定字符串的值，并且区分大小写： SELECT * FROM table_name WHERE column_name LIKE BINARY '%value%'; 这将返回表中列column_name包含"value"的所有行，且区分大小写。
匹配特定模式的值： SELECT * FROM table_name WHERE column_name LIKE 'v_lu_'; 这将返回表中列column_name符合模式"v_lu_"的所有行。其中，'_'代表任意单个字符，可以根据需求自行设置。
需要注意的是，LIKE语句是基于模式匹配的，使用通配符进行匹配，因此在进行模糊查询时，可以使用以下通配符：
%：匹配任意字符（包括0个字符）。_：匹配单个字符。[charlist]：匹配字符列表中的任意单个字符。[^charlist]：匹配不在字符列表中的任意单个字符。 另外，如果要实现对大小写不敏感的模糊查询，可以使用LOWER()或UPPER()函数来将列值转换为小写或大写，并将匹配模式转换为小写或大写进行比较。例如：
SELECT * FROM table_name WHERE LOWER(column_name) LIKE '%value%'; 这将返回表中列column_name包含"value"的所有行，且不区分大小写。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/16/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>