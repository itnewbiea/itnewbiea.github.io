<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf50ec3056ba4f06c9862e65d629483e/" rel="bookmark">
			CUDA安装详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CUDA安装详细教程 一、CUDA下载
CUDA官网
二、CUDA具体安装步骤
1、检查电脑的NVIDIA版本，在cmd中输入nvidia-smi(注意nvidia-smi中的是驱动对应的cuda最高版本，只要此版本大于等于你安装的cuda即可)
若命令nvidia-smi输入无效，可以查看该文的解决方案：
Windows10下cmd中nvidia-smi命令输入无效的解决办法
2、此次笔者选择10.1的CUDA版本，然后根据自己电脑情况选择配置，一般都是Windows10 +x86_64+CUDA版本号+exe[local]，最后点击下载即可
3、下载完成后，以管理员身份运行即可，选择安装地址，等待安装
4、检查系统兼容性，然后点击“同意并继续”
5、选择“自定义”，点击“下一步”
6、全选所有框，但注意不要选择“CUDA”中的“Visual Studio Intergration”，否则后面会报错
7、提前建立好文件夹，为设置安装路径作准备，注意前两个选择CUDA1，最后一个选择CUDA2，然后选择下一步，继续等待安装
8、检查系统变量中是否添加刚才我们的安装路径，若没有则需要自己添加
9、测试CUDA是否安装成功，在cmd输入以下命令：
nvcc --version # 检查CUDA的版本号 set cuda # 查看CUDA设置的环境变量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9056d3bbc2ab577114b83cfd03e2c2d/" rel="bookmark">
			在VMware Workstation的Centos上实现KVM虚拟机的安装部署：详细安装部署过程（保姆级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KVM概述 • 以色列qumranet公司研发，后被RedHad公司收购
（1）kvm只支持x86平台
（2）依赖于 HVM,inter VT AMD-v
• KVM是（Kernel-based Virtual Machine）的简称，是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于Xen，其核心源码很少。
• KVM的虚拟化需要硬件支持（如Intel VT技术或者AMD V技术)。是基于硬件的完全虚拟化。而Xen早期则是基于软件模拟的Para-Virtualization，新版本则是基于硬件支持的完全虚拟化。但Xen本身有自己的进程调度器，存储管理模块等，所以代码较为庞大。广为流传的商业系统虚拟化软件VMware ESX系列是基于软件模拟的Full-Virtualization。
工作原理 KVM 是基于虚拟化扩展（Intel VT 或者 AMD-V）的 X86 硬件的开源的 Linux 原生的全虚拟化解决方案。KVM 中，虚拟机被实现为常规的 Linux 进程，由标准 Linux 调度程序进行调度；虚机的每个虚拟 CPU 被实现为一个常规的 Linux 进程。这使得 KMV 能够使用 Linux 内核的已有功能。
但是，KVM 本身不执行任何硬件模拟，需要客户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的 I/O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序是 QEMU。
KVM的整体结构： 从GUI到Linux内核，包括以下五个组件：
1、virt-manager： 一个用来管理VM的GUI/CUI用户接口，它使用libvirt api 调用VM的各种功能。
2、libvirt：API库，作为较通用的服务器虚拟化软件，它支持Xen，VMware ESXi/GSX，当然，还有QEMU/KVM。
3、QEMU：一个和KVM内核模块交互的模拟器，处理多种客户机系统请求如I/O，一个QEMU进程对应一个客户机系统。
4、KVM内核模块： 从狭义上来说，KVM是一个Linux内核模块，主要负责vCPU的创建，虚拟内存的分配，vCPU寄存器的读写以及vCPU的运行。
5、Bridge-utils - Bridge-utils是一个Linux桥接工具集合，用于创建和配置网络桥接设备。在KVM中使用网络桥接可以实现更高效的网络通信。
KVM的安装与部署 镜像下载地址： http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/
如果是物理服务器，需要在BIOS中打开虚拟化功能（Virtualization Technology），一般的服务器默认是打开这个功能的。
如果是用VMware Workstation做实验，建立的虚拟机的CPU要勾选虚拟化功能，这样虚拟机才会支持KVM虚拟化
首先准备一台新的虚拟机，处理器也不要只给一个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9056d3bbc2ab577114b83cfd03e2c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28a7f54fa80845b4d2d22acfa135060/" rel="bookmark">
			设计模式-装饰器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础概念介绍 代码实现 基础模式 基础模式实现一 如果不使用装饰器模式，而是采用最普遍的类继承和组合的方式，我们需要直接在每个具体类中添加新的功能。这可能导致类的层次结构变得复杂，难以维护，因为每个具体类都需要预先知道所有可能的组合方式。
下面是一个简化的示例，演示了使用类继承和组合的方式来实现相同的功能：
coffee_simple.hpp (头文件)
#ifndef COFFEE_SIMPLE_HPP #define COFFEE_SIMPLE_HPP #include &lt;iostream&gt; #include &lt;string&gt; // 基础咖啡类 class SimpleCoffeeSimple { public: std::string getDescription() const { return "Simple Coffee"; } double cost() const { return 1.0; } }; // 咖啡加牛奶类 class CoffeeWithMilkSimple { SimpleCoffeeSimple baseCoffee; public: std::string getDescription() const { return baseCoffee.getDescription() + ", Milk"; } double cost() const { return baseCoffee.cost() + 0.5; } }; // 咖啡加牛奶和糖类 class CoffeeWithMilkAndSugarSimple { CoffeeWithMilkSimple baseCoffee; public: std::string getDescription() const { return baseCoffee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c28a7f54fa80845b4d2d22acfa135060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c6cf52c926a442013f71bd48054976d/" rel="bookmark">
			python单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式是一种创建型设计模式，它保证一个类仅有一个实例，并提供一个全局访问点。
在 Python 中，可以使用以下几种方式来创建单例模式：
使用 __new__ 方法 在 Python 中， __new__ 方法是一个类方法，它在一个对象实例化之前被调用创建了该对象实例。我们可以通过重载这个方法来实现单例模式。
例如：
class Singleton(object): _instance = None # 保存实例的私有类变量 def __new__(cls, *args, **kwargs): if not cls._instance: cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs) return cls._instance s1 = Singleton() s2 = Singleton() print(s1 == s2) # 输出 True 在上面的示例中，__new__ 方法会检查实例是否存在。如果存在，它会返回保存的实例，否则创建一个新的实例并保存它。
使用装饰器 装饰器是 Python 中一种强大的语法，它可以用来修改一个函数或类的行为。我们可以使用装饰器来实现单例模式。
例如：
def singleton(cls): instances = {} def getinstance(): if cls not in instances: instances[cls] = cls() return instances[cls] return getinstance @singleton class MyClass(object): pass a = MyClass() b = MyClass() print(a == b) # 输出 True 在上面的示例中，我们定义了一个singleton装饰器，该装饰器接受一个类作为参数并返回一个包装它的函数。这个函数将创建一个类的唯一实例并返回它。MyClass 类被修饰，因此仅有一个实例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c6cf52c926a442013f71bd48054976d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264dac0bb6c9ab267b944834b69e5131/" rel="bookmark">
			python系统编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 系统编程系统工具概述sys模块os模块 脚本运行上下文当前工作路径命令行参数shell环境变量标准流 文件和目录工具文件工具目录工具 并行系统工具进程分支线程 系统编程 系统工具 概述 python系统模块:
模块名作用*sys负责导出与怕以后呢解释器本身相关的组件*os包含与python所在底层操作系统相应的变量和函数*os.path为文件和目录处理工具提供了可移植的接口glob用于文件名扩展socket用于网络连接和进程间通信threading,_thread,queue用于运行和同步化并发线程subprocess,multiprocessing用于启动和控制并行进程signal,select,shutil,tempfile用于多种系统相关任务第三方扩展以下pySerial串行端口接口Pexpect用于控制程序间对话Twisted网络框架 获取模块文档:
获取属性:dir()
获取用法:__doc__或help()
sys模块 工具作用*sys.platform底层操作系统名称sys.maxsize当前计算机可容纳的最大整型sys.versionpython解释器版本号*sys.path正在运行的python解释器真正的模块搜索路径包含代表脚本主目录的指示器(首项),交互模式下是空字符串可以更改,并不是永久性的*sys.modules字典,python进程所导入的每一个模块sys.getrefcount查看对象的引用次数sys.builtin_module_namespython可执行程序的内置模块名称sys.exc_info()元祖,最近异常的类型,值,追踪对象追踪对象可用模块traceback处理将追踪对象传入traceback.print_tb()sys.argv命令行参数stdin,stdout,stdrrr标准流sys.exit强制退出 os模块 提供了POSIX(可移植操作系统接口)工具,不依赖平台的目录处理,os.path
常用的os工具:
任务工具shell变量os.environ:设置和获取shell环境变量运行程序os.execvos.execlp:启动新程序os.spawnv:启动带有底层控制的新程序os.system():在pythin脚本中运行shell命令,会暂停它的调用者,可在命令后加&amp;os.popen():运行shell命令并与其输入流(传入’w’参数,write()方法)或输出流(默认,read()方法)相连接.os.startfile():用相应的软件打开文件,无论文件是什么派生程序os.waitpid,os.killos.fork:在类Unix系统下派生新的子进程os.pipe:负责进程间通信文件描述符,文件锁os.resd,os.writeos.open:打开基于底层描述符的文件os.stat:获取文件底层信息文件处理os.rename,os.rmdiros.walk:将函数和循环运用与整个目录树的各部分os.remove:根据路径名删除文件os.mkdir:创建新目录os.mkfifo:创建新的命名管道管理工具:提供信息,帮助管理os.chmod,os.listdir,os.accessos.getpid():给出掉用函数的进程的idos.getcwd():返回当前目录os.chdir():改变目录移植工具os.path.split(‘path’):将路径分割为目录和文件os.path.splitext(‘path’):分割了文件的扩展名os.path.normpath(‘path’:将路径分隔符统一为平台的目录分隔符)os.path.abspath(‘path’):返回文件的完整目录路径名.如添加前缀和处理…语法os.path.join:将目录和文件合成路径os.path.dirname(‘path’)/basename(‘path’):返回目录/文件os.sep:目录分割符号os.pathsep:目录列表中分隔目录的符号os.pardir:父目录os.curdir:当前目录os.linesep:换行符路径名工具os.path.getsize(‘path’):通过文件名获取文件大小os.path.isdir(‘path’)/isfile(‘path’):检测文件类型,是目录/文件os.path.exists(‘path’):测试文件是否存在 脚本运行上下文 当前工作路径 当前工作路径(CWD)与脚本所在路径区别:
当前工作路径(CWD): 当前工作路径是启动脚本的路径,即输入命令行的地方.脚本中没有路径的文件名将会映射到此.通过os.getcwd()获得,os.chdir()改变.当通过图标执行一个脚本时,cwd会被设置为脚本所在路径. 脚本所在路径: 脚本所在路径是脚本文件物理存储位置.import导入时,最先搜索的目录.可以通过sys.path列表中的首项看到. 命令行参数 sys.argv:得到命令行参数列表.sys.argv[0]为执行脚本的名称,在命令行出现的顺序决定列表中的索引
python中的命令行处理工具解析更复杂的命令行:
getopt模块optparse模块,功能更强大 note:
unix上的可执行脚本:
脚本第一行#!/usr/bin/env指定解释器
chmod u+x scripname:增加可执行权限
shell环境变量 python通过一个类似python字典的对象os.environ访问环境变量
获取环境变量:
os.environ[‘环境变量名’],例如获取PYTHONPATH:os.environ[‘PYTHONPATH’] 修改环境变量:
通过对os.environ[‘环境变量名’]赋值,在内部调用os.putenv改变环境变量(修改是临时的,只对程序本身和子程序有效)
子程序:由Unix下的os.spawnv,os.fork/exec,以及所有平台的os.popen,os.system,subprocess启动的程序
修改是临时的原因:一个子程序始终从父程序继承环境变量,而子程序的环境变量不会传递给父进程.
标准流 标准流是预先打开的文件对象,python启动时被绑定到控制台窗口,sys模块提供了标准输入(sys.stdin),标准输出(sys.stdout)和错误流(sys.stderr)
重定向流到文件或程序(依赖shell命令行):
标准输入流重定向到文件输入:&lt; fielname
标准输出流重定向到文件:&gt;filename
结合使用:&lt; inputfile &gt; outputfile
管道,一个程序的标准输出发送到另一个程序的标准输入,python脚本可以在任意一端:|
重定向流与用户交互:
当输入流被重定向后,linux中可以通过/dev/tty文件(当前虚拟终端)读取键盘输入
文件的isatty()方法探测文件是否连接到控制台
重定向流到python对象:
任何提供了类似文件read方法的对象可以指定给sys.stdin,以从该对象的read方法读取输入
任何定义了类似文件write方法的对象可以指定给sys.stdout,所有标准输出将发送到该对象方法上
需要保存和重置原来的流
io标准库:
```python from io import StringIO, BytesIO # StringIO提供对象,将文件对象接口和内存字符串相映射(文本) buff = StringIO() # 在字符串中保存写入的文本 buff.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/264dac0bb6c9ab267b944834b69e5131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313b91a421f4c1092610cd208432e9a2/" rel="bookmark">
			C#winform中使用SQLite数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号「DotNet学习交流」，分享学习DotNet的点滴。
SQLite简介 SQLite是一种轻量级的关系型数据库管理系统（RDBMS），它以一个C库的形式提供。以下是SQLite数据库的一些关键特点：
1、无服务器： SQLite是一种无服务器的数据库管理系统，这意味着它不需要单独的服务器进程来运行。应用程序直接与SQLite库交互，而不是通过一个独立的数据库服务器。
2、自包含： 整个数据库被存储在一个单独的磁盘文件中。这使得SQLite数据库非常易于传输、备份和共享。
3、零配置： SQLite不需要繁琐的配置。你可以通过简单地打开一个文件来创建数据库，而不需要进行额外的设置或管理。
4、事务支持： SQLite支持事务，这是数据库管理系统中的重要概念。事务确保数据库操作的原子性，要么全部完成，要么全部取消。
5、跨平台： SQLite是跨平台的，可以在多种操作系统上运行，包括Windows、macOS和Linux。
6、嵌入式数据库： 由于其轻量级特性，SQLite经常被嵌入到应用程序中，作为应用程序的一部分运行。这种方式不需要单独的数据库服务器进程，适用于嵌入式系统和资源有限的环境。
7、多语言支持： SQLite有许多编程语言的绑定，包括C、C++、Java、Python、Ruby等，使其易于与各种编程语言集成。
8、高性能： 尽管它是一个轻量级的数据库引擎，但SQLite提供了良好的性能，尤其适用于小型项目和嵌入式系统。
SQLite下载安装 打开SQLite官网，点击下载按钮，如下所示：
根据电脑的系统选择合适的版本下载，如下所示：
解压之后，如下所示：
在电脑的环境变量中添加包含SQLite的路径，如下所示：
在命令行窗口中，输入sqlite3，出现如下所示内容，则安装成功。
使用SQLite 首先使用Navicat新建一个SQLite连接
连接名随便写，选择新建sqlite3数据库，再选择一个放数据库的地方，一般可以选择放在项目文件中，如下所示：
在我们选定的路径下，就有了一个数据库，如下所示：
使用SQLSugar操作SQLite数据库 安装SQLSugar，如下所示：
注意根据版本选择合适的nuget包，我这样是用的.NET 8所以选择安装SqlSugarCore。
与连接MySQL数据不同的就是连接字符串的写法
//public static string SQLitePath = Path.Combine(Environment.CurrentDirectory, "demo.db"); public static string SQLitePath = Application.StartupPath + "demo.db"; public static string ConnectionString = "DataSource=" + SQLitePath; SqlSugarClient db = new SqlSugarClient(new ConnectionConfig() { DbType = SqlSugar.DbType.Sqlite, ConnectionString = ConnectionString, IsAutoCloseConnection = true }); 可以使用绝对路径也可以使用相对路径，但是为了便于移植，推荐使用相对路径，下面两种写法都可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/313b91a421f4c1092610cd208432e9a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467b94ed02d9bf8182e2da02cbf7d75f/" rel="bookmark">
			消息中间件——RabbitMQ（六）理解Exchange交换机核心概念！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 来了解RabbitMQ一个重要的概念：Exchange交换机
1. Exchange概念 Exchange：接收消息，并根据路由键转发消息所绑定的队列。 蓝色框：客户端发送消息至交换机，通过路由键路由至指定的队列。
黄色框：交换机和队列通过路由键有一个绑定的关系。
绿色框：消费端通过监听队列来接收消息。
2. 交换机属性 Name:交换机名称
Type:交换机类型——direct、topic、fanout、headers、sharding(此篇不讲)
Durability：是否需要持久化，true为持久化
Auto Delete:当最后一个绑定到Exchange上的队列删除后，自动删除该Exchange
Internal：当前Exchange是否用于RabbitMQ内部使用，默认为false
Arguments：扩展参数，用于扩展AMQP协议自定制化使用
3. Direct Exchange(直连) 所有发送到Direct Exchange的消息被转发到RouteKey中指定的Queue 注意：Direct模式可以使用RabbitMQ自带的Exchange：default Exchange,所以不需要将Exchange进行任何绑定(binding)操作，消息传递时，RouteKey必须完全匹配才会被队列接收，否则该消息会被抛弃。
重点：routing key与队列queues 的key保持一致，即可以路由到对应的queue中。
3.1 代码演示 生产端：
public class Producer4DirectExchange { public static void main(String[] args) throws Exception { //1创建ConnectionFactory Connection connection = ConnectionUtils.getConnection(); //2创建Channel Channel channel = connection.createChannel(); //3 声明 String exchangeName = "test_direct_exchange"; String routingKey = "test.direct"; //4 发送 String msg = "Coder编程 Hello World RabbitMQ 4 Direct Exchange Message .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467b94ed02d9bf8182e2da02cbf7d75f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/977aadef5d3cd0ec82fea80bb1827837/" rel="bookmark">
			消息中间件——RabbitMQ（五）快速入门生产者与消费者，SpringBoot整合RabbitMQ！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本章我们来一次快速入门RabbitMQ——生产者与消费者。需要构建一个生产端与消费端的模型。什么意思呢？我们的生产者发送一条消息，投递到RabbitMQ集群也就是Broker。
我们的消费端进行监听RabbitMQ，当发现队列中有消息后，就进行消费。
1. 环境准备 本次整合主要采用SpringBoot框架，需要对SpringBoot的使用有一定了解。
2.大概步骤 我们来看下大概步骤：
ConnectionFacorty：获取连接工厂Connection：一个连接Channel：数据通信信道，可发送和接收消息Queue：具体的消息存储队列Producer &amp; Consumer 生产者和消费者 这个连接工厂需要配置一些相应的信息，例如: RabbitMQ节点的地址，端口号，VirtualHost等等。
Channel是我们RabbitMQ所有消息进行交互的关键。
3. 项目实战 3.1 连接工厂 public class ConnectionUtils { public static Connection getConnection() throws IOException, TimeoutException { //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("127.0.0.1"); //端口 factory.setPort(5672);//amqp协议 端口 类似与mysql的3306 //设置账号信息，用户名、密码、vhost factory.setVirtualHost("/vhost_cp"); factory.setUsername("user_cp"); factory.setPassword("123456"); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; } } 3.2 生产端 public class Producer { public static void main(String[] args) throws Exception { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/977aadef5d3cd0ec82fea80bb1827837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb6e973c602a6e43c58eefa060e0c3c/" rel="bookmark">
			【C/C&#43;&#43;】简单模拟题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有52张朴克牌，使它们全部正面朝上。从第2张牌开始，把凡是2的倍数位置上的牌翻成正面朝下；接着从第3张牌开始，把凡是3的倍数位置上的牌正面朝上的翻成正面朝下，正面朝下的翻成正面朝上；接着从第4张牌开始，把凡是4的倍数位置上的牌按次此规律翻转；依此类推，直到第1张要翻的牌是第52张为止。统计最后有几张牌正面朝上，并打印出它们的位置。
#include&lt;stdio.h&gt; int main(){ int a[53],k=0; for(int m=1;m&lt;=52;m++){ a[m]=1; } for(int i=2;i&lt;=52;i++){ for(int j=i;j&lt;=52;j++){ if(j%i==0){ a[j]=a[j]*(-1); } } } for(int n=1;n&lt;=52;n++){ if(a[n]==1){ k++; printf("%d ",n); } } printf("\n总共有%d张牌正面朝上\n",k); return 0; } 逆序
将数组中的数据按逆序存放
#include&lt;stdio.h&gt; int main(){ const int N = 10; int a[N]; int i,j,tmp; for(int i=0;i&lt;N;i++){ scanf("%d",&amp;a[i]); } i=0,j=N; while(i&lt;j){ tmp=a[i]; a[i]=a[j-1]; a[j-1]=tmp; i++; j--; } for(int i=0;i&lt;N;i++){ printf("%d ",a[i]); } return 0; } 示例：
3 5 1 2 8 7 9 4 10 6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb6e973c602a6e43c58eefa060e0c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ceba0798a6e65ba7e91caefd25ae26/" rel="bookmark">
			labview 安捷伦 34970A 采集温度等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细描述了怎么用安捷伦34970A采集温度，并列出了labview的下载链接，具有一定的参考价值。
1.必要条件：
RS-232电缆一根
IO Libraries Suite 软件
BenchLink Data Logger 软件
软件可以在http://www.keysight.com.cn下载
检查RS-232 电缆线的完整性(Keysight 货号：34398A，34970A随机附送一根)
2. 34970A的通讯设置
3．在电脑上确定要连接的串口（如果有多个的要把号码对应），打开是德IO Libraries Suite 软件,见如下图刷新
4.打开Data Logger pro软件，新建配置，自动找硬件，选择34970A,然后设置通道的采集类型。
5.按如下图点击start/stop采集开始，采集结束后再点start/stop
6.labview 软件
（1）前面板，（注意将初始化按钮点亮才初始化完才能采集成功，以选择串口号、测量类型，通道列表、波特率、流控制）
（2）框图
7.程序下载链接
https://download.csdn.net/download/weixin_39926429/88563203
注意：需要在NI官网下载34970A的驱动程序，放到安装路径合适的位置，要不然还是运行不了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69bd912797e81503c3623ee5a52cd9ca/" rel="bookmark">
			Python命令行红色提醒: sys.stderr.write
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，sys.stderr.write()函数用于将文本写入标准错误输出流（stderr）。它与print()函数不同，因为它不提供换行符，并且不会自动将文本写入标准输出流（stdout）。
使用sys.stderr.write()函数可以将文本写入标准错误输出流，这对于在程序中输出错误消息或诊断信息非常有用。例如：
import sys try: # 执行某些操作 sys.stderr.write("发生错误：无效的输入值\n") pass except ValueError: # sys.stderr.write("发生错误：无效的输入值\n") 为了直接显示该函数的效果，直接放到try中，正常还是要出现异常捕获后输出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3afc4f96b08d5186318c3ced4746e67c/" rel="bookmark">
			关于Docker容器删除镜像和容器后，C盘内存并未释放问题的解决办法（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里先给出一个命令可以删除全部的容器和镜像：
docker system prune -a 注：慎用！！！可以先试试该命令，单独删除指定的容器和镜像命令如下
一、删除镜像： 删除镜像的命令：
docker rmi 镜像ID或镜像名称 使用如下命令查看镜像信息
docker images 出现如下界面，并获取id，并获取全部docker镜像
尝试删除即可，如果不能删除，可能会让你停止容器运行可使用
docker pause 容器ID或容器名称 容器ID获取使用
docker ps -a 出现如下页面;
docker ps -a ：会列出当前服务器中所有的容器，无论是否在运行。
得到ID后停止运行容器尝试删除
二、删除容器： docker rm 容器ID或容器名称 使用上述代码，id获取仍然是使用 docker ps -a
三、磁盘内存的释放： 如果使用上述方法仍然不行！！！！
最后可以win+R打开
如下
使用上述命令，打开你的temp文件夹，这里面都是最近生成的垃圾文件，
Ctrl+A全选，之后避免去回收站删除可以长按shift可以全部永久删除，如果出现如下类似文件，可以取消删除
其余文件全部删除即可，前提是与docker和Ubuntu全部停止关闭才能释放内存
也可以使用docker stop container_name_or_ID停止
最后附上完成上述操作后： C盘的磁盘变化如图： 未释放前:（注一笔，dockerfile文件如果编写出问题） 构建工具服务器镜像命令：docker-compose up --build 构建成功后，即使使用docker删除的报错的项目，去查看镜像（Image），处于status in use 也会持续产生内存垃圾，需要把镜像状态退出使用，删除后，再尝试上述的释放过程
释放后： 当然也可试试Dism++尝试释放，链接我就放在下面了（永久有效）
链接：https://pan.baidu.com/s/1Dz1onademC77xG7gP7igcw?pwd=sszs 提取码：sszs
释放完仿佛身体被掏空~
写在最后
如有帮助，欢迎收藏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1536aa8f05361e484338ef28343bc1/" rel="bookmark">
			GitHub上8个强烈推荐的 Python 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. Manim2. DeepFaceLab3. Airflow4. GPT-25. XSStrike6. 谷歌图片下载7. Gensim8. SocialMapper总结关于Python技术储备一、Python所有方向的学习路线二、Python基础学习视频三、精品Python学习书籍四、Python工具包+项目源码合集①Python工具包②Python实战案例③Python小游戏源码五、面试资料六、Python兼职渠道 前言 GitHub 无疑是代码托管领域的先行者，Python 作为一种通用编程语言，已经被千千万万的开发人员用来构建各种有意思或有用的项目。以下我们会介绍一些使用 Python 构建的GitHub上优秀的项目。
1. Manim GitHub链接： https://github.com/3b1b/manim
B站链接：https://space.bilibili.com/88461692
Manim 是一个说明性数学动画引擎，使用 manim你可以创建动画视频，还可以控制用于插图和图表的动画。
这个项目将有趣直观的动画与数学教材中的图形图表相结合，是为了让人们更容易了解，从而打破学习数学肯定枯燥无味的刻板印象。简单来说就是一个高逼格的解释性的数学动画。
2. DeepFaceLab GitHub 链接：https://github.com/iperov/DeepFaceLab
DeepFaceLab 是本文中最有趣的 Python 项目之一。DeepFaceLab 是一种可以创建深层假图像和视频的工具，它能让你做很多有意思的事情，比如改变年龄和换脸。为了让事情更令人信服，甚至可以改变语言，前提是你精通视频编辑软件。开发者说互联网上超95%的深度假视频都是使用这个工具制作的。你可以在该项目的网页上找到面孔数据集和设置指南，冲呀伙伴们赶紧动起来!
3. Airflow GitHub链接：https://github.com/apache/flow
Airflow 是一个由Python提供支持，Apache 软件基金会开发的开源工作流管理工具，是一款开源的，分布式任务调度框架，它将一个具有上下级依赖关系的工作流，组装成一个有向无环图。简单来说，其实就是一个安排和监控工作流程的平台，例如编写、计划和监视等活动。如果把工作流定义为代码时，管理、测试和协作都会变得更加容易。
它提供了可伸缩性、动态管道生成和可扩展性。简单的用户界面让 Airflow 的使用过程非常流畅，它强劲的集成能力与其他服务功效有助于最大程度地节省时间。Airflow 正被业内一些大牌公司使用，如Adobe、Lyft、Slack、Expedia等。
4. GPT-2 GitHub 链接： https://github.com/openai/gpt-2
GPT-2 是一个浩大的基于转换器的语言模型，它根据同样巨大的数据集进行训练。目的就是当从上下文中给一组或之前的单词时，预测下一个单词，也就是一种文本生成方式。
简单地说，你只需要给 GPT-2 一些简短的词语或语言模型就能预测并生成品质优良的长文。
5. XSStrike GitHub 链接：https://github.com/s0md3v/XSStrike
跨站点脚本是一个漏洞，对网站来说是令人烦恼并且有害的问题。通过从客户端注入恶意代码，攻击者就能对数据和网站造成不可控的损害。
开发人员说他的工具不只是简简单单地检验随机有效负载，而是可以剖析网站并生成带有工作性能的专门工程有效负载。
6. 谷歌图片下载 GitHub 链接：https://github.com/hardikvasa/google-images-download
本工具的工作方法就是安装库，然后使用命令将所需的关键字、关键词作为参数，然后就到本工具发挥其神奇的作用的时间了。它允许我们一次性从谷歌上下载上百张图片到你的计算机。实际上就是在google images 搜索带有指定关键字的图片，找到你所需要的即可开始下载。有了它，分分钟拥有免费分享海量资源的技能啦。
7. Gensim Gensim是一个Python库，它的作用有文档索引、主题建模以及使用大规模语料数据进行类似检索。Gensim是“生成相似”的缩写。它是清晰、高质高效和可扩展的。这完成了对纯文本的无监督语义建模的无麻烦的目标。它被作者称为“根据纯文本进行监督性建模最健壮、最有效的、最让人放心的软件”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1536aa8f05361e484338ef28343bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f60cfad54bd3b2835793820d8d630a1/" rel="bookmark">
			php实现百万级数据导出至excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置服务器内存
设置程序运行的最大时间
如果导出数量过大，推荐使用循环导出，每次循环这里以导出一万条为例，循环100次即可全部导出
// 设置运行时间 set_time_limit(0); // 设置内存 ini_set('memory_limit', '1024M'); $outformat = urlencode("测试数据"); header("Cache-control: private"); header("Pragma: public"); header('Content-type: application/x-csv'); if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE 5')) { header("Content-Disposition: inline; filename={$outformat}.csv"); } else { header("Content-Disposition: attachment; filename={$outformat}.csv"); // 苹果电脑safari访问，解决文件名乱码 header("Content-Disposition: attachment; filename*=utf-8''{$outformat}.csv"); } $title = ['用户名', '年龄', '城市']; $limit = 10000; $page = 1; $fp = fopen('php://output', 'a'); fputcsv($fp, $title); while (true) { $start = ($page - 1) * $limit; $sql = "SELECT uname,age,city FROM `hd_test` ORDER BY `id` LIMIT {$start},{$limit}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f60cfad54bd3b2835793820d8d630a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a6abf1d3cc10094e14a56da9af3a51/" rel="bookmark">
			IT 论坛测试报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 1、项目简介 本项目是一个B/S架构的论坛系统，依托线上平台为用户提供一个便于交流、讨论的场所。该系统使用前后端的设计模式，围绕用户和和帖子两个核心对象进行业务处理，实现了用户注册登录、帖子管理，用户个人中心，以及评论私信等功能。
下面这张图囊括了本项目的核心功能点：
2、测试目的 本次测试结合软件规格说明书和产品说明文档，针对项目的主流程中的核心功能进行测试，旨在验证上述论坛系统的核心功能模块是否符合需求。
二、测试计划 1、测试范围 本次测试主要集中在论坛系统的核心功能模块上，包括用户管理、帖子管理、站内信管理等，是因为这些核心功能模块是论坛系统的基础功能，对于用户的日常使用至关重要。
2、测试方法 本次测试将采用黑盒测试方法，重点验证用户界面操作与预期结果是否一致：
黑盒测试方法就像是模拟真实用户行为的一种方式，它关注系统是否符合用户的期望和需求。测试人员作为外部用户，不需要了解系统内部的细节，这使得测试结果更加客观可靠。通过测试输入和输出的正确性、界面友好性、系统响应速度等方面来评估系统的质量，特别适用于论坛系统的核心功能。同时，黑盒测试方法还能高效地设计多个测试用例来覆盖不同的功能和使用场景，以检验系统在各种情况下的稳定性和正确性。这样，我们可以在相对较短的时间内发现系统中的潜在问题和缺陷。 3、测试环境 浏览器：Chrome
操作系统：Windows
设备：PC
三、测试执行 1、测试用例设计 本次功能测试是根据核心功能点进行测试用例的设计，以下是分模块归纳出的测试功能点，在进行具体的测试时，可以根据这些测试功能点编写具体的测试用例：
2、自动化测试 本次测试使用到自动化测试，使用的自动化测试工具 Selenium3 和 Junit5 共同完成测试用例的管理和执行。下面是自动化测试的实施详细步骤：
（1）导入自动化测试相关依赖
Selenium3+Junit5配置文件：Gitte 地址
（2）编写公共模块
编写创建驱动方法编写保存现场截图方法 注：创建启动以及现场截图功能会频繁进行复用，所以单独创建一个类进行存储。
（3）注册模块
创建驱动，并打开页面测试页面是否正常打开测试正常注册：多参数测试（根据给出的注册白名单，即不需要校验验证码）测试异常注册：表单为空/无效用户名/密码错误/验证码错误的情况。注意测试的顺序，使用Order注解指定，否则可能会因为执行顺序不对导致测试失败。 （4）登录模块
创建驱动，并打开页面测试页面是否正常打开测试正常登录：多参数测试（根据给出的登录白名单，不需要校验验证码）测试异常登录：表单为空/用户名/密码/验证码错误的情况注意测试的顺序，使用Order注解指定，否则可能会因为执行顺序不对导致测试失败。 （5）业务功能模块
创建驱动，并打开页面测试导航页面是否正常打开由于帖子管理模块、个人中心模块、站内信模块等业务模块都需要登录后在导航页面进行跳转测试，因此将业务功能模块统一进行测试。对各个具体的业务功能点进行有效测试：可以采用多参数进行测试。对各个具体的业务功能点进行无效测试：根据上面的测试用例图进行具体设计。测试时要注意各个功能点之间的执行顺序，使用Order注解指定，否则可能会因为执行顺序不对导致测试失败。注意添加等待，防止出现元素找不到（页面跳转后元素位渲染完毕）、元素状态未就绪（按钮不可点击）等问题。注意根据实际页面调整滚动条，避免因为元素在视窗外导致操作失败。 3、代码编写 针对以上模块进行自动化代码的编写，编写自动化代码时，注意结合实际页面元素，和具体功能点具体分析，这里给出完整代码：点击访问 Gitee
4、测试结果 执行用例个数：50；通过测试用例个数：50。测试用例全部通过，暂未发现 bug：
自动化测试视频：
forum-success-test
四、测试总结 在本次测试中，我们针对IT论坛项目进行了50个全面的测试用例。通过对各个基本功能模块和关键业务逻辑的测试，我们对系统的稳定性和正确性进行了验证。经过测试，我们得出以下总结：
测试覆盖率全面： 通过设计并执行50个测试用例，我们尽可能地覆盖了项目的各个功能和业务场景，包括用户注册、登录、帖子发布、评论回复等关键功能。
无执行错误： 在所有测试用例中，没有发现任何执行错误或系统崩溃的情况。这表明系统在处理各种输入和操作时表现稳定，并且能够准确地处理用户请求和数据交互。
功能符合预期： 在测试过程中，我们验证了各项功能是否符合预期的行为和规范。例如，用户能够成功注册、登录，发布帖子和评论等。系统在各个环节都表现出正确的行为和响应。
五、测试复盘 1、测试小结 本次测试根据项目的核心业务功能来设计的测试用例，然后根据测试用例使用selenium4自动化测试工具和junit5单元测试框架结合来实现web自动化测试的。
在进行自动化代码编写时，采用分模块编写测试用例，同时将测试中常用的方法如截图、创建驱动抽象出一个公共的类实现复用，最后使用测试套件执行所有测试类。
2、本次测试难点 自动化写出来不难，但是自动化执行速度快、更好地发现问题并避免误报才是难题。在本次自动化测试中，主要遇到以下几个问题：
时刻注意测试用例执行的顺序。比如在上面的测试中，一定是先登录才能访问导航页面进行具体的业务操作，否则会因为无权限导致测试用例执行失败。
注意添加等待，防止在操作元素时出现元素找不到（页面跳转后元素未渲染完毕）、元素状态未就绪（按钮不可点击）等问题。这个问题也是在测试中遇到最多的问题，当我们跳转到一个页面后，由于页面元素可能还未加载，直接获取或操作，可能出现找不到元素，或元素功能未就绪的问题，此时我们可以在测试中合理的添加等待，如添加智能等待、强制等待等。
注意根据实际页面调整滚动条，避免因为元素在视窗外导致获取不到，从而操作失败。在上面的测试中，有些页面比如文章编辑页，再进行提交的时候，由于提交按钮在浏览器视窗外（即当前显示的页面中看不到提交按钮），直接获取并点击提交按钮就会报错，此时就需要将滚动条调整到下面，找到提交按钮元素再进行点击操作。
3、本次测试亮点 使用了JUnit5中提供的注解：避免生成过多的对象，造成资源和时间的浪费，提高了自动化的执行效率。
项目中使用单例模式，只创建一次驱动对象，避免每个用例重复创建驱动对象造成时间和资源的浪费。
合理运用Junit5中的参数化：保持用例的简洁，提高代码的可读性。
使用测试套件：通过套件一次执行所有要运行的测试用例。
在合适的位置使用了等待：提高了自动化的运行效率，提高了自动化的稳定性，减小误报的可能性。
使用了屏幕截图：方便问题的追溯以及问题的解决。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a6abf1d3cc10094e14a56da9af3a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/394730ee7e20c4f74172f03f4de59440/" rel="bookmark">
			Android7.1 高通平台 状态栏和导航栏的隐藏与显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户需求：在客户apk的一个或几个页面隐藏状态栏和导航栏，滑动时不显示出来。
源码位置：/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
MyBroadReceiver receiver = null; @Override public void createAndAddWindows() { Log.e("hdz","___________createAndAddWindows()"); receiver = new MyBroadReceiver(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("StatusAndNavigationBar****"); intentFilter.addAction("StatusAndNavigationBar****"); mContext.registerReceiver(receiver,intentFilter); addStatusBarWindow(); } private class MyBroadReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { Log.e("hdz","___________action : " + intent.getAction()); if(intent.getAction().equals("StatusAndNavigationBar****")){//显示状态栏 addStatusBarWindow(true); }else{//隐藏状态栏 addStatusBarWindow(false); } } }; private void addStatusBarWindow() { makeStatusBarView(); mStatusBarWindowManager = new StatusBarWindowManager(mContext); mRemoteInputController = new RemoteInputController(mStatusBarWindowManager, mHeadsUpManager); mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight()); } private void addStatusBarWindow(boolean flag) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/394730ee7e20c4f74172f03f4de59440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cfc44786af624f0c95d05608cb401e/" rel="bookmark">
			Android7.1 高通平台 修改系统默认语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户需求：修改系统默认语言为英文（美国）
源码位置：/build/tools/buildinfo.sh
只需修改 ro.product.locale的值即可，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7208d43b19a11ec63d96b4bbfb96d018/" rel="bookmark">
			scrapy自定义日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义日志系统 首先，在Scrapy的settings.py文件中添加以下代码：
LOG_LEVEL = 'DEBUG' # 日志级别 LOG_FILE = '/path/to/logfile.log' # 日志文件路径 LOG_ENABLED = True # 是否启用日志 LOG_STDOUT = False # 是否输出到标准输出 这些设置将指定Scrapy日志的级别，文件路径和是否启用日志。您还可以将日志输出到标准输出或在默认情况下禁用此功能。
接下来，您可以使用Python的built-in logging模块自定义Scrapy日志记录器。以下是一个例子：
import logging class CustomLogger(object): def __init__(self): self.logger = logging.getLogger('scrapy') self.logger.setLevel(logging.DEBUG) # 创建一个文件处理程序，将日志记录到文件中 fh = logging.FileHandler('/path/to/logfile.log') fh.setLevel(logging.DEBUG) # 创建一个控制台处理程序，将日志记录到控制台上 ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # 创建一个日志格式器，用于将记录格式化为字符串 formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s') # 将日志格式器添加到文件和控制台处理程序 fh.setFormatter(formatter) ch.setFormatter(formatter) # 将文件和控制台处理程序添加到日志记录器 self.logger.addHandler(fh) self.logger.addHandler(ch) def info(self, msg): self.logger.info(msg) def debug(self, msg): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7208d43b19a11ec63d96b4bbfb96d018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e50947bb30a37935a3b3b526f3433e/" rel="bookmark">
			软件设计开发技术的演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、演进历史 1950+ 面向机器编程：基于图灵机模型的计算机，机器语言与汇编语言
1960+ 函数式编程：Lisp语言，以lamda演算为理论基础的编程语言
1966 过程化编程：取消goto，结构化编程，流程图建模，软件 = 算法 + 数据结构
1970+ 模块化架构： PASCAL,C,UNIx的封装，依赖大规模开发
1974 MVC架构： UI与逻辑解耦，分层架构
1978 数据建模：关系数据库，实体关系，ER建模
1980+ 面向对象编程： C++，逻辑复用，抽象接口
1986 并发与容错 ：并发，高容错架构
1991 Linux系统：自由，开放，可裁剪
1993+ 组件化架构：COM
1994 设计模式：面向对象应对的软件设计问题的解决方案
1995 4+1视图：场景视图，逻辑视图，开发视图，运行视图，物理视图
1997 UML:用例图，静态图，行为图，交互图，实现图
1998 服务化架构
1999 四色建模
2001 MDA :模型驱动架构
2001 敏捷开发：TDD,重构，持续继承，代码表达力，演进式设计
2003 领域驱动设计：领域建模。通用语言，战略战术设计，代码模型一直性
2007 MBSE SysML:建模语言，建模工具，建模方法，形式验证
2009 DCI架构：MVC的补充
2010+ 编程语言的演进： C++11,java8,Go，异步与并发，安全性
2012 微服务架构
2013 docker:轻量级虚拟化
2013 事件架构与建模
2015 云原生架构
二、演进目标 让软件更容易验证其正确性
让软件更容易变化
让软件更容易复用
让软件更容易被理解
参考：
一文读懂软件开发流程的演变过程（软件开发经历的三个演变过程） | 项目管理软件—集团管控系统—宇凡软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a565251ab1e22d1df1c77db5207f2a/" rel="bookmark">
			【Mysql】[Err] 1293 - Incorrect table definition；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本情况 SQL文件描述 /* Navicat MySQL Data Transfer Source Server : cm4生产-200 Source Server Version : 50725 Source Host : 192.168.1.200:3306 Source Database : db_wms Target Server Type : MYSQL Target Server Version : 50725 File Encoding : 65001 Date: 2023-03-14 16:59:12 */ 导入的数据库版本 SELECT VERSION() 5.5.50 导入参数 [Err] 1293 - Incorrect table definition; there can be only one TIMESTAMP column with CURRENT_TIMESTAMP in DEFAULT or ON UPDATE clause sql文件异常语句位置 -- ---------------------------- -- Table structure for `tb_groups_message` -- ---------------------------- DROP TABLE IF EXISTS `tb_groups_message`; CREATE TABLE `tb_groups_message` ( `ID` bigint(20) NOT NULL AUTO_INCREMENT, `GROUP_ID` int(255) DEFAULT NULL, `TAG_MAC` int(11) DEFAULT NULL, `BIN_ID` int(11) DEFAULT NULL, `WIP_NO` varchar(255) DEFAULT NULL, `PART_NO` varchar(255) DEFAULT NULL, `ITEM_COUNT` int(11) DEFAULT NULL, `LED_STATE` int(11) DEFAULT NULL, `LED_COLOR` varchar(11) DEFAULT NULL, `UPDATE_TIME` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`ID`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8; -- ---------------------------- -- Table structure for `tb_orders` -- ---------------------------- DROP TABLE IF EXISTS `tb_orders`; CREATE TABLE `tb_orders` ( `id` bigint(11) NOT NULL AUTO_INCREMENT, `orderNumber` varchar(25) COLLATE utf8mb4_bin NOT NULL COMMENT '订单编号', `status` tinyint(1) NOT NULL COMMENT '状态', `establish` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', `finish` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '完成时间', `shopNumber` varchar(8) COLLATE utf8mb4_bin NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; 问题分析 MySql 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a565251ab1e22d1df1c77db5207f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d76129a527a00d6d83b04a5cea55961/" rel="bookmark">
			LangChain库简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ❤️觉得内容不错的话，欢迎点赞收藏加关注😊😊😊，后续会继续输入更多优质内容❤️ 👉有问题欢迎大家加关注私戳或者评论（包括但不限于NLP算法相关，linux学习相关，读研读博相关......）👈 博主原文链接：https://www.yourmetaverse.cn/nlp/507/
（封面图由文心一格生成） LangChain库简介 LangChain是一个强大的框架，专为基于语言模型的应用程序开发而设计。它特别强调上下文感知和推理能力，通过不同的组件、链和集成，为开发者提供极大的灵活性和扩展性。此外，LangChain具备丰富的文档和开发者指南，确保开发者可以高效利用该框架。
LangChain是一个以语言模型为基础的应用程序开发框架。这个框架使得应用程序能够：
上下文感知：将语言模型连接到上下文源（如提示指令、少量示例、用于支撑其回应的内容等）。推理：依靠语言模型进行推理（如基于提供的上下文如何回答、采取什么行动等）。 LangChain框架由几部分组成：
LangChain Libraries：包括Python和JavaScript库。它们包含用于各种组件的接口和集成，一个用于将这些组件组合成链和代理的基本运行时，以及现成的链和代理实现。LangChain Templates：一系列易于部署的参考架构，适用于各种任务。LangServe：一个库，用于将LangChain链部署为REST API。LangSmith：一个开发者平台，允许您在任何LLM框架上调试、测试、评估和监控构建的链，并与LangChain无缝集成。
LangChain的主要价值主张是：
组件：用于处理语言模型的组合工具和集成。这些组件是模块化的，易于使用，无论您是否使用LangChain框架的其他部分。现成的链：为完成更高级任务而构建的组件组合。 现成的链使开始使用变得简单，组件使定制现有链和构建新链变得简单。
LangChain还提供了：
LCEL：一种声明式组合链的方式，旨在支持将原型投入生产，无需代码更改，从最简单的“提示 + LLM”链到最复杂的链。模块：为以下模块提供标准、可扩展的接口和集成：模型I/O（与语言模型的接口）、检索（与特定于应用程序的数据的接口）、代理（让模型根据高级指令选择使用哪些工具）。用例：包括文档问答、聊天机器人、分析结构化数据等多种常见的端到端用例。集成：LangChain是一个丰富的工具生态系统的一部分，这些工具集成了我们的框架并在其基础上构建。 此外，LangChain网站提供全面的API参考文档，以及开发人员指南，包括如何贡献和设置开发环境的指南。
总的来说，LangChain是一个强大的框架，旨在简化与语言模型相关的应用程序的开发和部署过程。
安装LangChain LangChain的安装过程简便，支持多种安装方式：
官方发布版本安装：
使用Pip：pip install langchain使用Conda：conda install langchain -c conda-forge 这将安装LangChain的基本要求。请注意，为了与各种模型提供商、数据存储等集成，需要单独安装特定集成的依赖项。
从源代码安装：
克隆仓库，确保目录为PATH/TO/REPO/langchain/libs/langchain，然后运行：pip install -e .。 LangChain实验包：
对于研究和实验用途，可以安装langchain-experimental包：pip install langchain-experimental。 LangServe：
用于将LangChain可运行文件和链部署为REST API。如果没有使用LangChain CLI，可以单独安装：pip install "langserve[all]"（客户端和服务器依赖），或分别安装客户端和服务器代码。 LangChain CLI：
对于使用LangChain模板和其他LangServe项目非常有用：pip install langchain-cli。 LangSmith SDK：
自动由LangChain安装。如果没有使用LangChain，可以单独安装：pip install langsmith。 ❤️觉得内容不错的话，欢迎点赞收藏加关注😊😊😊，后续会继续输入更多优质内容❤️ 👉有问题欢迎大家加关注私戳或者评论（包括但不限于NLP算法相关，linux学习相关，读研读博相关......）👈 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c6289636e69d30f13378ed7c0f500a/" rel="bookmark">
			Android进阶知识：ANR的定位与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 ANR对于Android开发者来说一定不会陌生，从刚开始学习Android时的一不注意就ANR，到后来知道主线程不能进行耗时操作注意到这点后，程序出现ANR的情况就大大减少了，甚至于消失了。那么真的是只要在主线程做耗时操作就会产生ANR吗？为什么在有时候明明觉得自己没在主线程做耗时操作也出现了ANR呢？一旦出现莫名其妙的ANR，怎么定位导致ANR的产生的位置和解决问题呢？那么接下来就来一个个的解决这些问题。
2、ANR是什么？ ANR全称Application Not Responding即应用程序无响应。在Android中如果应用程序有一段时间无法响应用户操作，系统会弹出弹窗，让用户选择是继续等待还是强制关闭程序。一款良好应用APP是不应该出现这个弹窗的。
3、ANR的产生原因 ANR产生原因和类型有以下几种：
1、Activity在5秒钟之内无法响应屏幕触摸事件挥着键盘输入事件就会产生ANR。 KeyDispatchTimeout
Reason：Input event dispatching timed out
2、BroadcastReceiver在10秒钟之内还未执行完成就会产生ANR。 BroadcastTimeout
Reason：Timeout of broadcast BroadcastRecord
3、Service各个生命周期在20秒钟之内没有执行完成就会产生ANR。 ServiceTimeout
Reason：Timeout executing service
4、ContentProvider在10秒钟之内没有执行完成就会产生ANR。 ContentProviderTimeout
Reason：timeout publishing content providers
在以上这几种原因中出现最多的一般是第一种，而且往往都是因为在写代码时不注意，在主线程做了耗时的操作。
4、ANR的定位与解决 关于ANR的定位这里举一个例子来看。这是我之前遇到的一次出现ANR的时候所解决问题的情况和解决步骤。
首先当然是复现ANR现象，找准ANR出现的地方，查看对应代码，如果能直接看出来问题所在，找到代码中做的错误操作那么直接修改相应代码就解决问题了。但是如果没法轻易看出问题原因，接下来就只好去Logcat中查看对应的错误日志。
07-22 21:39:17.019 819-851/? E/ActivityManager: ANR in com.xxxx.performance (com.xxxx.performance/.view.home.activity.MainActivity) PID: 7398 Reason: Input dispatching timed out (com.xxxx.performance/com.xxxx.performance.view.home.activity.MainActivity, Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c6289636e69d30f13378ed7c0f500a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa4ebbd78ae09e05e7847d6fc600b13/" rel="bookmark">
			C&#43;&#43; OpenCV学习：三、创建画布，绘制线条、矩形、圆、椭圆，添加文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建画布 创建纯黑画布可以使用Mat::zeros函数，信息如下：
参数1：rows，行数
参数2：cols，列数
参数3：type，创建的矩阵类型
代码如下：
Mat img = Mat::zeros(512, 512, CV_8UC3); 创建的画布效果图片如下：
绘制线条 绘制线条使用line函数，信息如下：
参数1：img，要绘制的图像
参数2：pt1，线条的第一个点，即起点
参数3：pt2，线条的第二个点，即终点
参数4：color，线条的颜色
参数5：thickness，线条的粗细，即线宽
参数6：lineType，线条的类型，不常使用
参数7：shift，点坐标的小数位数 ，不常使用
代码示例：
line(img, Point(150, 0), Point(150, 512), Scalar(255, 255, 255), 4); 绘制的线条效果如下：
绘制矩形 绘制矩形使用rectangle函数，信息如下：
参数1：img，要绘制的图像
参数2：pt1，矩形的顶点
参数3：pt2，与pt1对角的矩形顶点
参数4：color，矩形颜色
参数5：thickness，矩形线宽，负值会绘制实心矩形
参数6：lineType，线条 类型 ，不常使用
参数7：shift，顶点坐标的小数位数 ，不常使用
rectangle函数的重载函数信息如下：
参数1：img，要绘制的图像
参数2：rec，绘制的矩形
参数3：color，矩形颜色
参数4：thickness，矩形线宽
参数5：lineType，线条 类型 ，不常使用
参数6：shift，顶点坐标的小数位数 ，不常使用
Rect函数有多个重载，此处只介绍其中一种：Rect(x,y,width,height)
参数1：左上角顶点的x坐标
参数2：左上角顶点的y坐标
参数3：矩形的宽度
参数4：矩形的高度
代码如下：
// 方法1 rectangle(img, Point(100, 100), Point(400, 200), Scalar(0, 255, 255), 2); // 方法2 rectangle(img, Rect(100, 300, 200, 100), Scalar(0, 255, 0), -1); 绘制的矩形效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aa4ebbd78ae09e05e7847d6fc600b13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659541f9ae0ade3ae06bc3d8621fd412/" rel="bookmark">
			【NLP】GPT 模型如何工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 2021 年，我使用 GPT 模型编写了最初的几行代码，那时我意识到文本生成已经达到了拐点。我要求 GPT-3 总结一份很长的文档，并尝试了几次提示。我可以看到结果比以前的模型先进得多，这让我对这项技术感到兴奋，并渴望了解它是如何实现的。现在，后续的 GPT-3.5、ChatGPT 和 GPT-4 模型正在迅速获得广泛采用，该领域的更多人也对它们的工作原理感到好奇。虽然其内部工作细节是专有且复杂的，但所有 GPT 模型都共享一些不难理解的基本思想。
生成语言模型如何工作 让我们首先探讨生成语言模型的工作原理。最基本的想法如下：它们将n 个标记作为输入，并产生一个标记作为输出。
这看起来是一个相当简单的概念，但为了真正理解它，我们需要知道令牌是什么。
令牌是一段文本。在 OpenAI GPT 模型的上下文中，常见单词和短单词通常对应于单个标记，例如下图中的单词“We”。长且不常用的单词通常被分成几个标记。例如，下图中的“拟人化”一词被分解为三个标记。像“ChatGPT”这样的缩写可以用单个标记表示，也可以分为多个标记，具体取决于字母一起出现的常见程度。您可以转到 OpenAI 的Tokenizer 页面，输入文本，然后查看它如何拆分为标记。您可以选择用于文本的“GPT-3”标记化和用于代码的“Codex”标记化。我们将保留默认的“GPT-3”设置。
您还可以使用 OpenAI 的开源tiktoken库使用 Python 代码进行代币化。OpenAI 提供了几种不同的标记器，每个标记器的行为都略有不同。在下面的代码中，我们使用“davinci”（GPT-3 模型）的分词器来匹配您使用 UI 看到的行为。
import tiktoken # Get the encoding for the davinci GPT3 model, which is the "r50k_base" encoding. encoding = tiktoken.encoding_for_model("davinci") text = "We need to stop anthropomorphizing ChatGPT." print(f"text: {text}") token_integers = encoding.encode(text) print(f"total number of tokens: {encoding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/659541f9ae0ade3ae06bc3d8621fd412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceab4b87c83bb8bfab1b31ff8d765fbe/" rel="bookmark">
			C#调用C&#43;&#43;Dll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提前声明：
1，本教程以 x86 的C#程序（控制台，类库或其它）调用 win32 的C++Dll为案例，x64 的C#程序与x64 的C++Dll也可以，AnyCPU是不行的，会提示下图错误：
2，本教程使用的软件为VS2022，环境为NET8，时间为2023-11-22，后期可能有其它变化。
C++项目准备：
1，创建 win32 C++ 空项目
2，项目配置
a，win32，输出为dll；
b，无论你是.net程序，.net core程序，还是net framework程序，这个公共语言运行时支持只能选.NET Framework 运行时(/clr)，选.NET运行时不行，不知原因；
c，符合模式，否；
d，编译为C++TP
e，代码 MyMath
.h文件
#pragma once extern "C" __declspec(dllexport) int Add(int x, int y); .cpp文件
#include "MyMath.h" int Add(int x, int y) { return x + y; } c#项目调用：
任意 x86 的C#程序，引用C++项目生成的dll
[DllImport("LcCpp.dll", EntryPoint = "Add", CallingConvention = CallingConvention.Cdecl)] public static extern int Add(int a, int b); LcCpp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceab4b87c83bb8bfab1b31ff8d765fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d517bc777d916f119b903a69b4226280/" rel="bookmark">
			【Python】自定义pip安装路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为某些原因卸载了电脑上的python，重新安装之后发现，pip安装的目录是之前老版本的目录，有些库和电脑的内核不兼容，所以之前安装的库需要清理重新安装，固定一个目录安装，这样不会在重新安装python之后，再重新配置。
自定义pip安装路径 我们直接上手实操。
1.查看目前pip使用的路径 使用命令
python -m site sys.path = [ '/Users/mac/Library/Python', '/Library/Frameworks/Python.framework/Versions/3.10/lib/python310.zip', '/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10', '/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload', '/Users/mac/Library/Python/3.10/lib/python/site-packages', '/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages', ] USER_BASE: '/Users/mac/Library/Python/3.10' (exists) USER_SITE: '/Users/mac/Library/Python/3.10/lib/python/site-packages' (exists) ENABLE_USER_SITE: True 返回的信息可以看出，我python新安装的目录是/Library/Frameworks/Python.framework/Versions/3.10，但是pip安装的目录是/Users/mac/Library/Python/3.10/lib/python/site-packages。
我们需要做一下目录改变。
2.改变pip的安装路径 2.1 找到 site.py 文件 使用 python -m site -help 命令，我们可以看到目前我们的site.py文件是在哪个位置：
python -m site -help 最上面就是我们site.py文件的地址
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site.py [--user-base] [--user-site] Without arguments print some useful information With arguments print the value of USER_BASE and/or USER_SITE separated by ':'. Exit codes with --user-base or --user-site: 0 - user site directory is enabled 1 - user site directory is disabled by user 2 - user site directory is disabled by super user or for security reasons &gt;2 - unknown error 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d517bc777d916f119b903a69b4226280/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a871139c66e1e253a035d6885c183947/" rel="bookmark">
			c语言打印金字塔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入行数n,打印n行的金字塔。如图：
先分析其规律。
打印n行，即外层循环n次。再分析每一层的规律，先具体化举例，举一个行数为5的金字塔。可以发现每一行前面的空格呈递减趋势，且与行数有关系：空格数=行数-层数。输出字符随行数呈递增趋势，这就更明显了：字符数=行数。
以下是代码实现：
#include &lt;stdio.h&gt; int main(){ int n; scanf("%d",&amp;n);//输入行数 for(int i=1;i&lt;=n;++i){ for(int j=n-i;j&gt;0;--j){//输出空格，等于总行数-层数 printf(" "); } for(int k=1;k&lt;=i;++k){//输出字符，等于行数。 printf("* "); } printf("\n");//每一层完，需要换行 } return 0; } 如果for循环看起来有点迷糊，可以改成while循环方便理解，以下是另一个版本：
#include &lt;stdio.h&gt; int main(){ int n; scanf("%d",&amp;n);//输入行数 for(int i=1;i&lt;=n;++i){ int kongge=n-i; //空格数=总行数-层数 while(kongge--){ printf(" "); } int zifu=i;//字符=行数 while(zifu--){ printf("* "); } printf("\n");//每一层完，需要换行 } return 0; } 知道了这个规律。那Python一个循环就能搞定，根据Python语言的特点，可以直接输出字符串✖数量。 以下是Python语言实现：
n=int(input()) #输入行数 for i in range(1,n+1): print(" "*(n-i),end=' ')#输出（n-1）空格数 print("* "*i)#输出i个字符 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54129c425fb8a9f52181194f4e60307f/" rel="bookmark">
			微信公众号上怎么做微信助力活动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号微信助力活动：一起分享，一起成长
在当今社交媒体时代，人们之间的互动和分享变得越来越重要。微信公众号作为一个广受欢迎的社交平台，为人们提供了一个便捷的分享和交流渠道。而微信助力活动则是通过分享和互动，让用户在参与中获得更多的乐趣和收益。下面就让我们一起来探讨如何在微信公众号上策划一场微信助力活动。
一、微信助力活动的优势
增加用户参与度 微信助力活动通过让用户分享和互动，增加了用户的参与度，提高了活动的曝光度和传播效果。同时，用户在参与过程中也能感受到更多的乐趣和满足感。
扩大品牌影响力 通过微信助力活动，微信公众号可以扩大自己的品牌影响力，吸引更多的用户关注和参与。同时，活动也能增加用户对公众号的信任度和好感度，提高用户粘性。
促进用户增长 微信助力活动通常会设置一些奖励机制，如红包、礼品等，吸引更多的用户参与。这些奖励机制可以刺激用户拉新，促进用户增长，增加公众号粉丝数量。
二、如何策划一场微信助力活动
确定活动主题和目标 在策划微信助力活动时，首先要确定活动的主题和目标。例如，活动的主题可以是节日庆祝、产品推广等，目标可以是增加粉丝数量、提高用户活跃度等。
设计活动规则和流程 在设计活动规则和流程时，需要考虑如何让用户参与并分享活动。通常，微信助力活动会设置一些任务或挑战，让用户完成并分享到朋友圈等地。同时，活动也需要设定明确的奖励机制和截止时间等。
制作活动页面和素材 为了更好地展示微信助力活动的内容和规则，需要制作活动页面和相关素材。这些素材可以包括海报、文案、视频等，以吸引更多用户参与。
推广活动并监测效果 在活动推出后，需要积极推广并监测活动效果。可以通过微信公众号推送消息、社交媒体宣传等方式来推广活动。同时，也需要对活动数据进行监测和分析，以便及时调整策略并优化效果。
三、微信助力活动的未来发展
随着社交媒体的不断发展和用户行为的改变，微信助力活动也将不断创新和发展。未来，我们可以预见以下几种发展趋势：
多元化奖励机制 为了满足不同用户的需求和增加活动的吸引力，微信助力活动将采用更多元化的奖励机制。这些奖励机制可以包括红包、礼品、优惠券等多种形式，以吸引更多用户参与。
个性化推荐机制 通过分析用户的兴趣爱好和行为习惯，微信助力活动将采用更加个性化的推荐机制。这些推荐机制可以根据用户的喜好和需求来推荐相应的活动内容、任务或挑战等，以提高用户的参与度和满意度。
3. 跨界合作与整合营销
未来,微信助力活动将更加注重跨界合作与整合营销通过与其他品牌或机构合作,共同推出具有吸引力和影响力的活动内容可以增加活动的曝光度和传播效果同时也能为参与者带来更多的收益和乐趣。
总的来说微信公众号微信助力活动是一种非常有吸引力的营销方式它通过让用户分享和互动来增加参与度和扩大品牌影响力从而促进用户增长和提高用户粘性。在未来随着社交媒体的发展和用户行为的改变微信助力活动也将不断创新和发展为微信公众号带来更多的机遇与挑战.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc799489bd4406eb41c0dd63b83113e/" rel="bookmark">
			mybatis数据加密脱敏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在研发过程中某些业务场景是不允许存储明文的，例银行卡 身份证类。怎么实现自动加密解密呢？可以利用mybatis Interceptor 做处理，输入明文参数通过拦截器自动加密。查询出结果集自动解密。在web层展示可以对敏感字段加*处理。
支持mybatis-generator 生成的代码，考虑到可能重新生成会覆盖。支持配置指定字段加密解密，就不用担心代码丢失。自定义对象建议使用注解方式
直接上代码
/** * * @author one.xu */ @Target({ElementType.TYPE,ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface EnableEncrypt { } @Target({ElementType.FIELD, ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited public @interface EncryptField { String value() default ""; /** * 参数为map逗号连接需要加密的key * @return */ String keys() default ""; } /** * @author one.xu */ @Slf4j @Intercepts({ @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}), @Signature(type = Executor.class, method = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddc799489bd4406eb41c0dd63b83113e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48f80fae0f59adbbed3d2298ec6e505/" rel="bookmark">
			【解决ubuntu外接显示器不显示的问题】(遇到的问题及解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.首先确认电脑上安装了 NVIDIA 显卡2.检查nvidia显卡驱动是否正常3.重启系统后发现wifi模块不见，同时输入nvidia-smi 输出“No devices were found”3.1 ubuntu 更新显卡驱动导致无法联网3.2 nvidia-smi 输出“No devices were found 4. 检查显示器是否能检测到 参考文章 1.首先确认电脑上安装了 NVIDIA 显卡 lspci | grep -i nvidia 2.检查nvidia显卡驱动是否正常 nvidia-smi 如果返回类似于下面的界面，则表示显卡驱动还没有安装。
输入下面命令，以查看显卡型号以及推荐的驱动版本。
ubuntu-drivers devices 如下图，这里推荐我们安装的是 nvidia-driver-535 - sever-open。
如果我们愿意安装这个版本的驱动，则输入即可安装该驱动：（有坑，看下一步）
sudo ubuntu-drivers autoinstall 安装过程中按照提示操作，安装完成后重启系统，NVIDIA 显卡就可以正常工作了。（出现问题，见下）
3.重启系统后发现wifi模块不见，同时输入nvidia-smi 输出“No devices were found” 3.1 ubuntu 更新显卡驱动导致无法联网 可能原因：升级显卡时导致内核被升级，而缺少与内核相关的包。
先在连不上网的系统里，打开命令行，查看内核版本：
uname -a 可以看到当前连不上网的这个内核版本是 5.15.0-89
重启进入引导菜单，选择 ubuntu 高级选项，发现 5.15.0-89紧邻着的下面的 5.15.0-76 的版本，这应该是上一个版本。
进入此版本后发现确实可以联网了，于是在命令行里输入
dpkg --get-selections | grep linux 可以看到以下的包是5.15.0-76有，但5.15.0-89没有的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48f80fae0f59adbbed3d2298ec6e505/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b47399aa046a0d84022802389dfed59/" rel="bookmark">
			[Python] Python编程无限进步...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 实现PTA平台认可的不定行输入2. 辨别输入的字符串是否全为数字（int，float，complex）3. Python中查找某一个键是否在字典中。4. Python中map函数的用法:5. Python中的sample函数的用法：6. Python中的字典的键值是可以用一个表达式来表示的。7. Python中对列表元素实现格式控制输出。7.1. 使用循环和字符串拼接：7.2. 使用str.join()方法：7.3. 使用str.format()方法： 8. Python中str.join()的用法8.1 使用逗号将字符串列表连接起来：8.2 用空格将元组中的单词连接起来：8.3 使用空字符串将字符列表连接为一个单词： 9. Python中swap()的写法10. Python中赋值语句更加强大的一些原因！10.1 多重赋值：10.2 解构赋值：10.3 增强赋值：10.4 链式赋值：10.5 序列解包： 11. Python中动态初始化一个二维数组12. Eval函数的强大功能之一——直接将符合格式的字面量的字符串转化为值 以下是笔者总结的一些在使用Python进行编程的过程中所思考和总结的一些有趣的玩意儿。
1. 实现PTA平台认可的不定行输入 line = [] while True: try: line.append(input()) except: break 2. 辨别输入的字符串是否全为数字（int，float，complex） eval()函数强大的处理函数。 try: data = eval(input()) if type(data) in (int,float,complex): print("yes") else: print("no") except: print("no") eval()返回字符串表达式中的值或者表达式的计算结果，只要是数就会有值！eval()还可以根据格式将字符串合理得转化为列表、元组、集合、字典。 例题: 7-51 jmu-python-简单计算器 (20 分)
3. Python中查找某一个键是否在字典中。 使用的是in方法。比如当前有一个字典ditc要看键 key是否在dict中我们可以用：if key in dict:来测试。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b47399aa046a0d84022802389dfed59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe09b7c82b5d35a063cda96489026f99/" rel="bookmark">
			【代码】使用python的cpbd库计算图像清晰模糊度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ```python import cpbd, cv2 # import imageio # # # 注意！！这里灰度化后直接就是归一化的值，，不是原rgb值！！ # input_image = imageio.imread('E:\work\intelligence\product_detect\service\clarity\\ng.jpg',as_gray=True) # print(input_image.shape) # print(cpbd.compute(input_image)) # 单张图 image = cv2.imread('E:\work\intelligence\product_detect\service\clarity\\ng.jpg', cv2.IMREAD_GRAYSCALE) # print(image.shape) print(cpbd.compute(image)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/628a8ae5107233612a2d4fea65b0ade6/" rel="bookmark">
			NSAttributedString设置折行方式NSLineBreakByTruncatingTail，计算高度出错，高度返回异常。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS13上，NSAttributedString设置折行方式NSLineBreakByTruncatingTail，计算高度出错，只返回一行的高度。
NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc]init];
style.hyphenationFactor = 1; // 设置每行的最后单词是否截断，在0.0-1.0之间，默认为0.0，越接近1.0单词被截断的可能性越大， 设置hyphenationFactor=1,在计算就返回正常高度了。
如果设置不起效。换下面的方法
找到了解决方案。只需将 NSMutableParagraphStyle 上的 setAllowsDefaultTighteningForTruncation 设置为 YES。
参考 cocoa - Making NSTextField not shrink when NSLineBreakByTruncatingTail is set - Stack Overflow
NSString *highlightTitle = title; //转换参数 NSDictionary *options = @{ NSDocumentTypeDocumentAttribute : NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute :@(NSUTF8StringEncoding) }; //将html文本转换为正常格式的文本 NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithData:[highlightTitle dataUsingEncoding:NSUnicodeStringEncoding] options:options documentAttributes:nil error:nil]; [attributedString removeAttribute:NSParagraphStyleAttributeName range: NSMakeRange(0, attributedString.length)]; [attributedString addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, attributedString.length)]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; // paragraphStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/628a8ae5107233612a2d4fea65b0ade6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff968cbcecf85ad92887d60545fcb5a/" rel="bookmark">
			HCIA-Datacom V1.0模拟考试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9173a29e3946c9085857ec59f28aedab/" rel="bookmark">
			链路聚合-静态和动态区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链路聚合之动静态聚合方式
链路聚合组是由一组相同速率、以全双工方式工作的网口组成。
1、动态聚合：
动态聚合对接的双方通过交互LACP(链路聚合控制协议)协议报文，来协商聚合对接。
优点：对接双方相互交互端口状态信息，使端口状态能保持一致；
缺点：不同厂家对接可能因为协议报文的处理机制等不同，产生对接异常。
一般来说：动态聚合要同端口匹配方式为强制相配套使用，因为：如果端口匹配方式为自适应，那么当物理链路质量不好时，可能端口状态频繁出现变化，相应的聚合组状态也会频繁出现up、down故障。
2、静态聚合：
对接双方不交互LACP报文，仅看物理端口状态是否UP。
优点：不同厂家之间无需担心协议报文协商问题。
缺点：单根纤芯发生故障时，可能出现收端正常的一方端口处于UP，而出现单通，所以这种情况一般要求端口匹配状态为自适应状态。
一般静态聚合组要和端口匹配方式为自适应相配套，因为：如果端口匹配方式为强制模式，那么当单纤芯发生故障时，接收正常的端口是处于UP状态的，设备会继续往该端口发出数据流，但实际上对端接收不到，导致单通情况出现。
建议：一般不同厂家对接，建议设置聚合组为静态、端口设置为自适应方式。
总结：
静态聚合手工绑定，无需担心不同厂商之间的协议报文问题，但是如果是一收一发的那种光纤，单根故障，静态聚合无法检测到，会造成单通故障；
动态聚合使用LACPDU报文来保障两边端口状态一致，不用担心单通故障，但是如果是不同厂商，可能会出现对接问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551349a2ce05909018b048bd38c89b18/" rel="bookmark">
			linux之chmod命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在linux系统中经常遇到需要对文件修改读写执行的权限，下面对chomod命令进行梳理总结。
1、文件权限 在linux系统中，每个文件都有归属的所有者和所有组，并且规定了文件的所有者、以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。
对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。
对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。
文件的普通权限
通过 ll 命令查看文件的详细信息
第一个字符信息就是文件的类型，这个文件类型有（d）目录文件、（-）普通文件、（p）管道文件、（c）字符设备文件、（b）块设备文件、（l）链接文件等等。
文件的普通权限有r（read 读 ）、w（write 写）、x（execute 执行）权限。
除了第一个文件类型，一共有9个空位是用来显示文件的权限，分成三个，文件所有者（user）、所有组（group）、其他人（other）、还有一个是所有人（all），包括前面三个的意思。
在linux中，系统只认识二进制（0/1）的内容，那么读写执行是怎么转化成我们认识的权限，实际上，我们能看到的读写执行是八进制（0-7）显示的。
2、chmod命令 chmod命令来自于英文词组“change mode”的缩写，其功能适用于改变文件或者目录权限的命令。默认只有文件的所有者和管理员可以设置文件权限，普通用户只能管理自己的文件的权限属性。
设置权限时可以使用数字法，亦可使用字母表达式，对于目录文件建议加入-R参数进行递归操作，意味着不仅对于目录本身，也对目录内的子文件/目录进行新权限的设定。
chmod命令的常用参数如下：
-c 若该文件权限确实已经更改，才显示其更改动作-f 若该文件权限无法被更改也不显示错误讯息-v 显示权限变更的详细资料-R 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) 3、修改权限实例 1）文件所有者拥有读写执行权限，所有者、其他用户无权限
chmod 700 test.txt
2）目录拥有满权限
chmod -R 777 test/
3）给一个文件添加可执行权限
chmod +x test.txt
4、注意事项 添加可执行权限是一项有风险的操作，因为可执行文件可能包含恶意代码。确保只将可执行权限添加到受信任的文件上。要执行chmod命令，您通常需要具有文件的所有者或超级用户权限。使用chmod命令时要小心，以免不小心修改了文件的权限。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb30109fbb43d9557ffee6607a75dad9/" rel="bookmark">
			【2023最新超详细】全国建筑市场监管公共服务平台（四库一平台）js逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 js逆向思路第一步抓包第一种破解方法，堆栈法python还原js扣代码还原 第二种破解方法，搜索法完整代码效果展示关于5588返回值和95780返回值 js逆向思路 第一步看请求网址的发起程序都有哪些
接在js文件搜索AES,MD5,等高频加密方式的字段
1 parse 2 decrypt 3 .toString() 4 Base64 5 表单字段 6 url关键字 最后可疑的地方都打上断点，调试，跟踪堆栈
第一步抓包 首先右键打开开发者工具，打开网络界面
接着点击翻页，抓到第二页的包
这里可以看到点击第二页后只有一个包，那肯定是他了，接着我们看他返回的数据
可以很明显的看到被加密了
破解的发法我这里有两种
第一种破解方法，堆栈法 首先打开发起程序
找到app的js文件
一般的返回值都是这个文件
打开之后黄色的这行就是调用的语句
我们这行代码上下部分的return和函数的地方打上断点
这个是2934，最好把这行代码的整个函数代码的return都打上
我在这行代码（e(t)）的最开始的地方打断点的就发现 函数b 有问题，因为他的关键字，这个在第二种方法会讲。
现在打好断点后再次抓包
这里也是断上了，先看看这个t是啥，params一看就是表单吧，很可疑
我们继续走
点击抓包工具里的三角形图案往下运行
在运行了几次之后
就到了我说的很可疑的那段代码，函数b(t):
t 一看不就是 加密后返回值吗
r 是解密后的返回值
我们细看这段代码
很明显，这是AES加密，CBC模式
先把t，就是加密后的返回值解密赋值给e,
n 是 Base64后的e值
最后在使用密匙和偏移量解密，f和m需要先编码
我们可以扣js代码，也可以使用python还原
python还原 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad import binascii # python AES解密 def decrypt(data): KEY = 'jo8j9wGw%6HbxfFn'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb30109fbb43d9557ffee6607a75dad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec8882ed0df8870308a7843c00a77ab5/" rel="bookmark">
			Python&#43;Selenium定位不到元素常见原因及解决办法(报：NoSuchElementException)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Python+Selenium定位不到元素常见原因及解决办法(报：NoSuchElementException),文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧
在做web应用的自动化测试时，定位元素是必不可少的，这个过程经常会碰到定位不到元素的情况（报selenium.common.exceptions.NoSuchElementException），一般可以从以下几个方面着手解决：
1.Frame/Iframe原因定位不到元素： 这个是最常见的原因，首先要理解下frame的实质，frame中实际上是嵌入了另一个页面，而webdriver每次只能在一个页面识别，因此需要先定位到相应的frame，对那个页面里的元素进行定位。
解决方案：
如果iframe有name或id的话，直接使用switch_to_frame(“name值”)或switch_to_frame(“id值”)。如下：
driver=webdriver.Firefox() driver.get(r'http://www.126.com/') driver.switch_to_frame('x-URS-iframe') #需先跳转到iframe框架 username=driver.find_element_by_name('email') username.clear() 如果iframe没有name或id的话，则可以通过下面的方式定位：
#先定位到iframe elementi= driver.find_element_by_class_name('APP-editor-iframe') #再将定位对象传给switch_to_frame()方法 driver.switch_to_frame(elementi) 如果完成操作后，可以通过switch_to.parent_content()方法跳出当前iframe，或者还可以通过switch_to.default_content()方法跳回最外层的页面。
2.Xpath描述错误原因： 由于Xpath层级太复杂，容易犯错。但是该定位方式能够有效定位绝大部分的元素，建议掌握。
解决方案：
2.1可以使用Firefox的firePath，复制xpath路径。该方式容易因为层级改变而需要重新编写过xpath路径，不建议使用，初学者可以先复制路径，然后尝试去修改它。
2.2提高下写xpath的水平。
可以详看笔者另外一篇博文总结：Selenuim+Python之元素定位总结及实例说明
该博文详细总结了Xpath的使用，多组合定位一般都能实现定位问题。
如何检验编写的Xpath是否正确？编写好Xpath路径，可以直接复制到搜狐浏览器的firebug查看html源码，通过Xpath搜索：如下红色框，若无报错，则说明编写的Xpath路径没错。
find_element_by_xpath("//input[@id='kw']") 3.页面还没有加载出来，就对页面上的元素进行的操作： 这种情况一般说来，可以设置等待，等待页面显示之后再操作，这与人手工操作的原理一样：
3.1设置等待时间；缺点是需要设置较长的等待时间，案例多了测试就很慢；
3.2设置等待页面的某个元素出现，比如一个文本、一个输入框都可以，一旦指定的元素出现，就可以做操作。
3.3在调试的过程中可以把页面的html代码打印出来，以便分析。
解决方案：
导入时间模块。
import time time.sleep(3) 4.动态id定位不到元素： 解决方案：
如果发现是动态id，直接用xpath定位或其他方式定位。
5.二次定位，如弹出框登录 如百度登录弹出框登录百度账号，需先定位到百度弹出框，然后再定位到用户名密码登录。
# coding=utf-8 ''' Created on 2016-7-20 @author: Jennifer Project:登录百度账号 ''' from selenium import webdriver import time driver = webdriver.Firefox() driver.get("http://www.baidu.com/") time.sleep(3) #点击登录：有些name为tj_login的元素为不可见的，点击可见的那个登录按钮即可。 #否则会报：ElementNotVisibleException element0=driver.find_elements_by_name("tj_login") for ele0 in element0: if ele0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec8882ed0df8870308a7843c00a77ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d9d23a4e566ba3fa34e19284298d08/" rel="bookmark">
			基于ubuntu20.04安装ros系统搭配使用工业相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于ubuntu20.04安装ros系统搭配使用工业相机 1. ROS系统安装部署1.1更新镜像源1.1.1 备份源文件1.1.2 更新阿里源1.1.3 更新软件源 1.2 ros系统安装1.2.1 添加ros软件源1.2.2 添加秘钥1.2.3 更新软件源1.2.4 配置及更换最佳软件源1.2.5 ROS安装1.2.6 初始化rosdep1.2.7 设置环境变量1.2.8 安装rosinstall1.2.8 验证ROS是否安装成功 2. 海康工业相机SDK安装2.1 SDK下载2.2 MVS&amp;SDK安装 3. ROS Package使用3.1 ros工作空间部署3.2 查看和发布 ROS 话题（Topic）的信息3.3 rviz 可视化工具 1. ROS系统安装部署 参考链接：详细介绍如何在ubuntu20.04中安装ROS系统
本文重点讲工业相机使用部分，ros系统安装，大家可以自行看参考链接，作者写的很详细，每一个报错都考虑到了
1.1更新镜像源 ros系统安装过程中，需要下载大量的依赖环境，更换一个下载速度快的软件源，提升安装速度，本文使用阿里镜像源
deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src https://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb https://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d9d23a4e566ba3fa34e19284298d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02b957bfc5f30c4fb9b5d5036d611a14/" rel="bookmark">
			【Ubuntu】Ubuntu arm64 部署 Blazor Server 应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署步骤 发布安装运行环境：dotnet-sdk（必装）、aspnetcore-runtime、dotnet-runtime安装证书设置环境变量：临时变量、当前用户永久变量、所有用户的永久变量运行：终端运行、后台运行
基本情况 开发系统环境 系统：Windows 10 专业版 22H2 19045.3693 开发软件IDE：Microsoft Visual Studio Community 2022 (64 位) - Current 版本 17.6.5 项目框架：Blazor Server 应用 目标框架：.NET 6.0 系统架构：x64
发布系统环境 系统：Ubuntu 20.04.6 LTS focal 架构：arm64 系统信息 lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.6 LTS Release: 20.04 Codename: focal 查看架构 sudo dpkg --print-architecture arm64 二、部署 2.1 准备部署文件 2.1.1 发布 配置: Release 目标框架(F): net6.0 部署模式(M): 框架依赖 目标运行时(U): 可移植
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02b957bfc5f30c4fb9b5d5036d611a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25cec622e09d84af5e29444846646435/" rel="bookmark">
			利用ShadowRoot 实现样式隔离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ShadowRoot Shadow DOM API 的 ShadowRoot 接口是一个 DOM 子树的根节点，它与文档的主 DOM 树分开渲染。
ShadowRoot 的模式——可以是 open 或者 closed。这定义了 shadow root 的内部实现是否可被 JavaScript 访问及修改 — 也就是说
ShadowRoot的特性 图片来源：掘金（https://juejin.cn/post/6979489951108825095）
自定义的样式和布局：Shadow DOM可以创建一个私有的样式和布局环境，使得组件可以在自己的环境中独立地定义样式和布局，而不会影响到其他组件或页面的样式和布局。
隔离的DOM结构：Shadow DOM可以创建一个私有的DOM结构，使得组件可以在自己的环境中独立地定义DOM结构，而不会影响到其他组件或页面的DOM结构。
嵌套使用：Shadow DOM可以嵌套使用，一个Shadow DOM可以包含另一个Shadow DOM，从而实现更复杂的组件结构。
ShadoRoot 样式/组件隔离 由于Shadow Dom 是一个独立的节点，所以我们可以利用 Shadow Dom 实现样式隔和组件隔离。
ShadowRoot 内事件机制和正常的dom结构一致。但是不管是冒泡还是捕获事件，一旦达到边界ShadowHost的时候event.target就Shadow Host
利用ShadowRoot的特性对插件开发进行优化 (shadowroot使用场景) 在chrome插件开发过程之中，如果你使用了像tailwindcss之类的样式库，不难避免遇到样式冲突的问题。
在开发过程中，我们可以利用ShadowRoot的特性，将样式隔离到ShadowRoot中，从而避免样式冲突。
引入样式文件 import style from '@/styles/main.css' import popupStyle from '@/styles/popup.scss' 这里首先导入了组件依赖的样式文件： main.css和popup.scss。main.css为tailwindcss的样式，popup.scss为自定义的组件样式。
在Popup.vue中不必引入样式文件（因为打包之后样式文件是作用于全局的，无法在shadow root中使用）。
注入样式文件 mountEl 为创建的挂载节点
mountEl.attachShadow({ mode: 'open' }): 给mountEl下面挂载了一个新创建的shadowRoot节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25cec622e09d84af5e29444846646435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a21a25d7434ff085da94281e63c836/" rel="bookmark">
			PyTorch多GPU训练时同步梯度是mean还是sum?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyTorch 通过两种方式可以进行多GPU训练: DataParallel, DistributedDataParallel. 当使用DataParallel的时候, 梯度的计算结果和在单卡上跑是一样的, 对每个数据计算出来的梯度进行累加. 当使用DistributedDataParallel的时候, 每个卡单独计算梯度, 然后多卡的梯度再进行平均.
下面是实验验证:
DataParallel import torch import os import torch.nn as nn def main(): model = nn.Linear(2, 3).cuda() model = torch.nn.DataParallel(model, device_ids=[0, 1]) input = torch.rand(2, 2) labels = torch.tensor([[1, 0, 0], [0, 1, 0]]).cuda() (model(input) * labels).sum().backward() print('input', input) print([p.grad for p in model.parameters()]) if __name__=="__main__": main() 执行CUDA_VISIBLE_DEVICES=0,1 python t.py可以看到输出, 代码中对两个样本分别求梯度, 梯度等于样本的值, DataParallel把两个样本的梯度累加起来在不同GPU中同步.
input tensor([[0.4362, 0.4574], [0.2052, 0.2362]]) [tensor([[0.4363, 0.4573], [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a21a25d7434ff085da94281e63c836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f804cab2ba5eeb66e1b50525b5d1b5ae/" rel="bookmark">
			python连接hive报错：TypeError: can‘t concat str to bytes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、完整报错
二、解决
三、 其他报错
四、impala方式连接hive
或者直接使用 pip install pyhive[hive] 安装。需要先 pip uninstall pyhive。
一、完整报错 Traceback (most recent call last):
File "D:/Gitlab/my_world/hive2csv.py", line 18, in &lt;module&gt;
conn = hive.Connection(host=host, port=port, username=username, password=password, database=database, auth=auth)
File "D:\Anaconda3\lib\site-packages\pyhive\hive.py", line 269, in __init__
self._transport.open()
File "D:\Anaconda3\lib\site-packages\thrift_sasl\__init__.py", line 82, in open
self._send_message(self.START, chosen_mech)
File "D:\Anaconda3\lib\site-packages\thrift_sasl\__init__.py", line 103, in _send_message
self._trans.write(header + body)
TypeError: can't concat str to bytes
二、解决 2.1、进入D:\Anaconda3\lib\site-packages\thrift_sasl\__init__.py文件
2.2、添加如下代码到第101行之前
if (type(body) is str): body = body.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f804cab2ba5eeb66e1b50525b5d1b5ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d4f391c3685fe2d03124e3d6d4534b/" rel="bookmark">
			bitmap基础介绍&#43;holo实现离线UV计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bitmap 基础介绍bitmaping 数据结构bitmap计算算子集成二阶段分布式计算：RoaringBitmap构造方案分桶方案建序方案 holo官网 离线UV计算创建用户映射表创建聚合结果表更新用户映射表和聚合结果表更新聚合结果表UV、PV查询 基础介绍 RoaringBitmap主要为了解决UV指标计算的问题。旨在建立一种可以多维分析的精准UV数据模型，并且可以低成本地实现交并差等集合运算UV指标。 PV和UV指标一直是各类业务中广泛存在并且重点关注的实时指标。其中对于PV指标而言，由于其具备可加性，因此当对维度组合或者时间维度进行上卷时，可以直接求和得出我们所要的累计结果。但是去重指标UV则具备不可加性，他是一种对UID去重计数的指标，如果在维度上卷时直接求和会导致结果偏大。即UV指标一旦定制化生成，就很难具备再计算的能力，需要用户事先计算好。例如。
模型包含每天的UV，但是要算多天的去重UV，则需要从特定时间点重新开始算。模型包含每个城市的UV，但是要算全国的去重UV，则需要去掉城市维度再次聚合计算。 根据历史经验，去重指标有许多解决方案可供设计。主要分为两类，一类是前置计算方案，通过Count Distinct将UV预聚合后存储起来，查询时直接路由到对应UV指标。一类是后置计算方案，将user_id转变成可去重的结构，在查询时通过集合运算，算出UV指标。
前置计算方案，即最常用的Count Distinct算子，统计时根据uid是否存在来决定计次，通常基于DWD模型或者UID粒度的DWS模型，生成UV指标存储在ADM模型中。后置计算方案，通常将user_id存储在可去重结构，可去重结构包括非精准去重的HyperLogLog与ThetaSketch，以及精准去重的RoaringBitmap。 bitmaping 数据结构 RoaringBitmap是效压缩位图，采取的是2^ 32位(4294967296)的Bitmap，可以存储[0,2^32 -1]区间范围的用户编号。但是RoaringBitmap会对这个2^32bit的Bitmap做很多压缩操作，将Bitmap尽可能地压缩在很小的存储量级。其核心思想是：
对于每个用户编号k，会被划分成二进制的高16位(k / 2^16)和低16位(k mod 2^16)。其中高16位称为共享有效位，又可称为分桶号。属于roaring bitmap的一级索引，总计最多可包含2^16=65536个桶。共享有效位只存储一份，可以由多个编号共用，因此很大程度上减少了空间消耗。每一个桶由一个Container 来存放一个数值的低16位。其中container是RBM新创造的概念，其核心目标是为了更高效地压缩和存储数据。Container 总共包括三种数据结构： Array Container ，Bitmap Container和RunContainer。Array Container 存放稀疏的数据，Bitmap Container 存放稠密的数据。此外，如果Array Container和Bitmap Container可以用行程编码压缩，就会替换成RunContainer存储。
Array Container：使用short数组存储低16位，元素排序后放入short数组中。没有数据压缩机制，在数据稀疏场景存储效率高。Bitmap Container：long数组存储低16位，数据内容对应long类型的bit位，数据稠密存储效率很高。如：1，5，6表达成一个long值为00110001.Run Container：低16位使用short数组存储，将连续数据值存储为[起始点，连续个数的格式]。在数据连续性好的场景存储效率高。例如数据[11,12,13,14,15]将存储为两个short数值[11,4]。 在存储效率方面，数据量离散且小于4096时使用array最优，在数据量大且无规律时bitmap最优，在数据连续性比较好的情况下，RunContainer的存储效率最优。
时间复杂度方面Bitmap时间复杂度为O(1)高于Array和Run存储的nlog(n)。
bitmap计算算子集成 hologres本身是兼容postgres开源生态，pg版本的roaringbitmap插件通过简单适配，很容易集成在hologres中。roaringbitmap插件：https://github.com/zeromax007/gpdb-roaringbitmap。
holo中roaringbitmap函数使用文档 ：https://help.aliyun.com/zh/hologres/user-guide/roaring-bitmap-functions?spm=a2c4g.11186623.0.0.df1b5791jxHiiU
典型计算算子：
二阶段分布式计算： 数据的分布键按桶号和bitmap高16位打散到hologres各个计算节点。在进行交并差集计算过程中，由于各个节点之间数据完全独立，每个节点可以单独进行计算，并将计算结果直接汇总到master节点计算进行聚合。整个计算过程是一个二阶段计算过程，完全没有数据shuffle, 整体计算非常高效。
RoaringBitmap构造方案 RoaringBitmap使用过程中，主要遇到的问题，就是如何将user_id存入到RoaringBitmap数据结构中。因为RoaringBitmap不能像HyperLogLog那样，可以直接将user_id存入Bitmap数据结构中。为了能将亿级的编号存入Bitmap中，探索过如下两种方案。
分桶方案 主要解决：数据量过多
分桶方案采取分治的思想，即将一个大用户集切成多个桶，每个桶的量级足以存到42亿的Bitmap中，并且桶中的UID互斥，没有重合的UID。
而分桶的方案包括很多，例如可以采取前几位分桶，或者后几位分桶，只要能够保证剩下的几位都可以存在Bitmap里面。在实时场景中，由于要考虑Explorer的机器数，因此既需要保障每个桶内的UV量级均匀的同时，也需要保障每台机器在存储桶的个数也是均匀的。如下图所示，但是由于ODPS没有存储机器数的概念，因此其分桶的个数可以更加灵活，只需要保障每个分桶下的UID数是相同的即可。
此外，为了防止数据条数膨胀太多，我们默认会采取分10个桶。如果UID量级比较大，用户也可以选择性地增加分桶个数。为了将UID均匀地划分到10个桶上面，我们采取取轮询分桶的方式，即对于第1个编号放在第1个桶里，第2个编号放在第2个桶里，不断轮询分配，直到第11个编号，又重新从第1个桶开始划分。因此最终的分桶方法为。
例如将2088022931508105按10个桶划分，则其分桶号和用户编号为 分桶号 = 93150810 % 10 = 0 用户编号 = concat(reverse(022)，93150810 / 10 ) = 2209315081 分10个桶，等同于将UID的倒数第二位作为分桶号，剩下的有效位重排后作为编号。 分桶方案的优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d4f391c3685fe2d03124e3d6d4534b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2983f1b9ba9916bc491398f7b91582/" rel="bookmark">
			Stable Diffusion XL网络结构-超详细原创
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 强烈推荐先看本人的这篇 Stable Diffusion1.5网络结构-超详细原创-CSDN博客
1 Unet 1.1 详细整体结构 1.2 缩小版整体结构 以生成图像1024x1024为例，与SD1.5的3个CrossAttnDownBlock2D和CrossAttnUpBlock2D相比，SDXL只有2个，但SDXL的CrossAttnDownBlock2D模块有了更多的Transformer模块，且只进行了两次下采样，具体的往下看
1.2.1 DownBlock2D 1.2.1.1 ResBolck2D 和SD1.5不一样的是，多了time_id这个输入，表示origin_size, target_size,以及裁剪坐标，比如图中的time_id＝[[1024, 1024, 0, 0, 1024, 1024],[1024, 1024, 0, 0, 1024, 1024]]
有一半是负向提示词，以[1024, 1024, 0, 0, 1024, 1024],为例，两个[1024, 1024]表示origin_size, target_size，[0, 0]是裁剪坐标，这是SDXL在训练的时候用了一些trick,把原始输入图像和目标图像的大小，以及裁剪坐标也作为条件参与训练
Downsample2D通过步长为2的卷积进行下采样
1.2.2 CrossAttnDownBlock2D CrossAttnDownBlock2D_1 CrossAttnDownBlock2D_1表示第一个CrossAttnDownBlock2D，它的Transformer2DModel有两个BasicTransformerBlock，而SD1.5的Transformer2DModel只有一个BasicTransformerBlock
CrossAttnDownBlock2D_2 CrossAttnDownBlock2D_2表示第2个CrossAttnDownBlock2D，它的Transformer2DModel有10个BasicTransformerBlock
1.2.3 UnetMidBlock2DCrossAttn 其中的Transformer2DModel有10个BasicTransformerBlock
1.2.4 CrossAttnUpBlock2D CrossAttnUpBlock2D_2 CrossAttnUpBlock2D_2表示第2个CrossAttnUpBlock2D，它的Transformer2DModel有10个BasicTransformerBlock，UpSample2D和SD1.5结构一致
CrossAttnUpBlock2D_1 CrossAttnUpBlock2D_1表示第21个CrossAttnUpBlock2D，它的Transformer2DModel有2个BasicTransformerBlock
未完待续
2 CLIP 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57d23736bb301cc1d2bfc3d3b30ed50/" rel="bookmark">
			Edge浏览器提示“你的连接不是专用连接“ 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总目录 文章目录 总目录前言1 问题描述2 解决办法结语 前言 亲测有用予以记录。
1 问题描述 当我们使用Edge进入某个网址的时候提示“你的连接不是专用连接”，如下图所示
2 解决办法 方法1、点击如图所示的“高级”然后有一个“继续访问 .com (不安全)”，点击继续访问即可；
方法2、点击高级，调整键盘为英文输入状态，鼠标点击当前页面上的任意位置，然后输入：thisisunsafe ，然后回车即可。
结语 以上就是本文的内容，希望以上内容可以帮助到您，如文中有不对之处，还请批评指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164d3f465f7fb7e3896a70540b6715f6/" rel="bookmark">
			借助 DevChat AI 之力，成就我之全栈梦想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何为 DevChat ？ DevChat 是集好多种 AI 大模型的智能编程工具,可以大大增加我们上班摸鱼的时间。
整合了如 ChatGPT、Codex等热门 AI 模型支持自然语言编程、代码生成与编写、代码补全等功能因其集成热门 AI 智能，相当于站在了巨人的肩膀上，直接给自己增加十年功力
无需过多配置就可以快速上手，从而大大提升了，我这种代码笨笨的开发效率。
DevChat AI 编程助手有哪些优势？ 1）兼容热门 AI 大模型 上述的大模型可以任我们选择
2）遇到问题直接问，堪比旁边坐了个大牛 例如一时间想不起，如何获取当前时间，然后对当前时间进行格式化，或者获取 10 位或者 13 位时间戳的代码，直接提问。
即问即答。
“一万工资里，DevChat AI 替我出五千的力”
3) 代码讲解大师 例如下面两行前端的 css 代码。我一个后端并不理解，那我需要进行某度搜索，耗费之精力及大（耽误我摸鱼）。
直接选中这两行代码，添加到 DevChat AI 中
4）关于代码及隐私安全 对接的是微软 Azure 服务，可信赖，企业级数据安全
专属福利 独家专属红包码：kykPz5Ey54uWPxNpXuJ6Yi
在这里使用
下载链接 官网地址 使用某 WX,即可扫码登录
插件下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b8cceb95a4e292e072fd66dc9449d7/" rel="bookmark">
			超全 Vue3新特性总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3 应用-技术分享与交流 新特性篇 Vue3 组合式 API VS Vue2 选项式 API 选项式 API 面临的问题: 我们在处理业务逻辑时，需要在 data computed method watch 中分别进行代码编写，碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。我们必须不断地“跳转”相关代码的选项块，让维护变得困难，也不利于代码的可读性。
组合式 API 优势 1.更好的逻辑复用 组合式 API 最基本的优势是它使我们能够通过组合函数来实现更加简洁高效的逻辑复用。在选项式 API 中我们主要的逻辑复用机制是 mixins，而组合式 API 解决了 mixins 的所有缺陷。
2.更灵活的代码组织 大部分代码都自然地被放进了对应的选项里
3.更好的类型推导 近几年来，越来越多的开发者开始使用 TypeScript 书写更健壮可靠的代码，TypeScript 还提供了非常好的 IDE 开发支持。大多数时候，用 TypeScript 书写的组合式 API 代码和用 JavaScript 写都差不太多！这也让许多纯 JavaScript 用户也能从 IDE 中享受到部分类型推导功能。
4.更小的生产包体积 搭配 &lt;script setup&gt; 使用组合式 API 比等价情况下的选项式 API 更高效，对代码压缩也更友好
数据响应式原理 Proxy 相对于 Object.defineProperty proxy 的性能本来比 defineProperty 好，proxy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b8cceb95a4e292e072fd66dc9449d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bbaf0732287621003f52ddcc0b5f9c/" rel="bookmark">
			vue js 禁用控件一分钟，并显示倒计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 isCounting标记计时是否开始，remainTimeTip为显示文本，比如初始值设置为“获取验证码”，clock设置为每1秒自动调用一次，clearInterval(clock)会停止下一次的调用。
data(){ return { remainTime:60,//禁用60秒 isCounting:false,//是否在计时 remainTimeTip:"获取验证码" }; }, .... startCountDown(){	if(this.isCounting) return; //计时开始 this.isCounting=true; this.remainTimeTip="已发送("+this.remainTime+")"; var clock = setInterval(()=&gt;{ if(this.remainTime&gt;0){ this.remainTime--; this.remainTimeTip="已发送("+this.remainTime+")"; }else{ clearInterval(clock); this.isCounting=false; this.remainTime=60; this.remainTimeTip="重新发送"; } },1000); } &lt;span @click="startCountDown" &gt;{{remainTimeTip}}&lt;/span&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade4651c9477eeb65002bd9252f6d08b/" rel="bookmark">
			Mysql查看Binlog文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备 检查是否开启binlog mysql&gt; SHOW VARIABLES LIKE 'log_bin'; // 或者 mysql&gt; SHOW VARIABLES LIKE 'log%'; ON代表开启，OFF代表关闭。如为OFF需 开启 后才能查看，但只能查看开启之后时间点的。
查看binlog文件有哪些 一般yum安装的mysql，binlog没指定的话，一般存在/var/lib/mysql/目录
mysql&gt; SHOW MASTER STATUS; binlog.000029即为最新的binlog文件，但需要主要binlog文件一般会有多个比如27、28
查看binlog文件 使用mysqlbinlog工具查看 以下命令不需要在mysql中执行，在linux-sell中执行即可
查看所有日志内容 mysqlbinlog [binlog文件名] 查看指定时间范围内的日志内容 mysqlbinlog --start-datetime="YYYY-MM-DD HH:MM:SS" --stop-datetime="YYYY-MM-DD HH:MM:SS" [binlog文件名] 将日志内容输出到文件 mysqlbinlog [binlog文件名] &gt; output.sql 以文本格式查看日志内容 mysqlbinlog --verbose [binlog文件名] 以可执行的 SQL 格式查看日志内容 mysqlbinlog --result-file=output.sql [binlog文件名] 例子 查询binlog.000028文件中，从2023-11-13 20:45:55到57秒，有’user‘关键词的语句
mysqlbinlog --start-datetime="2023-11-13 20:45:55" --stop-datetime="2023-11-13 20:45:57" --verbose /var/lib/mysql/binlog.000028 &gt; test.sql | grep -i 'user' grep后面也可以是正则表达式，例如grep -i 'UPDATE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade4651c9477eeb65002bd9252f6d08b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/39/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>