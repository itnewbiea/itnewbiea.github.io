<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fc3b7f11d2fe39e60ddf1e217fb999/" rel="bookmark">
			Visual Studio Code常用快捷键使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode常用的快捷键使用 Shift+1(英文状态下） +Tab 能快速生成网页的基本结构Ctrl+? 快速添加注释（取消注释） Ctrl+c复制 ctrl+V粘贴 ctrl+a 全选
Alt+Shift+↑/↓ （向上/向下复制本行）
Alt+↑/↓（本行向上/向上移动）
Ctrl+Enter（向下换行）
Ctrl+Shift+Enter（向上换行）
Ctrl+z 返回上一步
Ctrl+y 恢复上一步
Ctrl+F 查找
Ctrl+H 替换
Ctrl+Shift+K 删除一行
Home 转到行首
End 转到行尾
alt+鼠标左键 选中多行同时编辑
ctrl+shift+L 选中编辑代码中相同的内容
按住Ctrl + Alt，再按键盘上的上或下键，可以使一列上出现多个光标
选中多行,按tab键可统一向右移动
选中文本后,Ctrl + [ 和 Ctrl + ] 可实现文本的向左移动 和 向右移动
按shift+alt，再使用鼠标拖动，也可以出现竖直的列光标，同时可以选中多列
通过快捷键 Ctrl + i 唤起代码提示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679b644385275bf63e889f6ca7ef441a/" rel="bookmark">
			【随笔】论多线程CPU离线渲染器的实现：A CPU BASED OFFLINE RENDERING ENGINE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 小熊挺喜欢玩游戏的，对于游戏画面有所追求，记得高中第一次玩战地的时候，惊叹于画面细腻的表现，并且还能开坦克车，这样的事情深深吸引了我。我是一个画面党，为了追求更好的画质表现我开始研究设置面板里各个选项的含义，但是并不是特别深入，上了大学幸运地拥有了时间（主要指可以逃课）让我可以重新更加深入的了解图形背后的技术原理，以及那些让人痴迷的图形算法，真是行云流水让人拍案叫绝。
所以做了这样的项目，让我对背后技术有了更深理解，和更好使用Unity或OpenGL了（
开源组件使用和版权声明 得益于前人的工作和巧妙的思想，我在阅读了这些文献后，融合了自己的想法和小思路，做出了这样的作品。虽然现在渲染器已经有很多并且五花八门，但是拥有一个属于自己思路和想法的渲染器还是挺让人有成就感的。
开源组件使用情况说明 Windows Presentation Foundation（WPF）：Licensed Under MIT；.NET Runtime：Licensed Under MIT；OpenCV4：Licensed Under BSD；Asp.Net Core：Licensed Under MIT； 本软件渲染部分实现只使用了C#和C++自带的一些STL库。并没有使用OpenGL或者Direct库。
版权声明 接下来的文章将会尽可能的表明外部引用资源的出处，有些是互联网的资源所以并没有找到源头，但是我会将其标注出来。如果有什么地方没有标准或者错误标注，欢迎在评论区为我指出。
在本文最后，将会给出更详细的资源使用列表。
本文不允许转载发表，一方面这是小熊的日记，写在自己的博客以此做一个纪念，另一方面本文还有很多部分尚未改善完成，待来日方长，再让我慢慢对你诉说。
接下来的文章介绍的部分，除了特别标注以外，是由我所完成和实现的。
项目简介 一个高性能，低占用，便于用户使用的CPU离线渲染器。
本项目不使用现有的相关图形库（如：OpenGL、DirectX）而是从头自己写一遍（根据现有的论文），重新设计相关算法与技术。它具有高性能，低占用的特点，它便于用户使用，采用离线算法进行渲染计算。
在这个渲染器项目中，实现了众多算法包括不限于NPR基于物理的真实渲染，PBR非真实渲染等；可以配合现有的Blender、C4D、3DMAX等DCC软件，进行协同使用；它操作简单，支持简单化云计算等创新功能；完全使用CPU进行渲染，对GPU做到了0占用。
实现了能够渲染一些画面和导出一些动画等功能。
项目特点 我自己写的（使用简单，可以在UI界面切换渲染管线拥有一个物品管理器，可以导入模型调整模型旋转位置，还能修改物体名称一个简单的云计算功能，两台电脑分别渲染一点画面PBR基于物理的渲染，NPR卡通化渲染实现占用资源很小，对比现在的套壳浏览器APP，它只占用57mb左右（打开状态下，未进行渲染计算） 项目截图 软件UI界面： （图中像素女生来自游戏《杜若花开》，一款大二写的Unity像素风手游，设计参考于美术@鱼鱼@小勤@小满@盖子同学）
多材质插槽模型表面实现： （上图人物是一个虚拟主播形象，见本文末的附录的资源声明）
天空HDR采样实现： （天空HDRI文件来自互联网资源）
多线程渲染： 人机交互设计： 软件结构（架构）设计 纹理和材质 （Texture和Material类设计图（部分））
如上图所示，小熊设计了一些类如Texture来表示基础的纹理材质的模样，然后这个类派生了其他的可能纹理，用来表示材质贴图。其中设计了uv这样的变量来采样图片中的颜色信息。
而Material类则用来描述物体的表面属性，大体可以分为光滑或不光滑，粗糙的，金属类或非金属。目前研究到了这里。
渲染和管线设计 （图：自己的管线流程设计稿，上图部分摘抄自{参考文献-1}）
设计了一个比较简单的渲染管线，主要就是用来模拟一些顶点和片元上的操作，最上面的图是常见的渲染流程图。
上图就是一个简单的示意图了，小熊的项目就是这样子进行运算的，而描边等算法我使用了OpenCV等功能库进行制作，主要是比较简单。
同时设计了这些小熊还设计了一个可以解耦合的渲染接口，用户只需要实现接口就能放入到渲染器之中进行使用了。
软件语言和代码实现 采用C#和C++混合编写策略，C#部分手动控制GC回收，提高软件部分的性能，C++负责编写一些需要结合OpenCV或者高性能计算的代码部分，并把C++部分编译为DLL，供前端C#调用。为了提高性能，完全发挥出CPU的实力，采用多线程的软件实现思路，设计一套无锁的内存区域。
C#部分同时负责编写ASP.NET服务器，用于做分布式云计算的基础。
C++部分 dllmain.cpp（DLL的主要入口，用于做出一些动作在ATTACH或者DETACH上，我在这里用于关闭OpenCV的一些功能）imageFunc.cpp（算法的实现，在这里实现了一些函数，用于双边滤波，描边算法，图像二值化均值化等，是【NPR渲染】和【图像自动降噪】功能的实现） C#部分 DAO命名空间（CppFunction类，用于调用C++代码；NetWorkJsonData，用于ASPNET交互；PbIO类，自己封装的二进制读写类，用于BRGA数组写入图片和图片文件读取，模型文件二进制读取；ToRenderDispter类，用于去多线程的参数传递；）CameraObj命名空间：用于实现一些摄像机类，描述摄像机的行为和空间。And So On… 还有一些其他的如：纹理，材质，光线追踪，GobalManager全局管理类等。 在这个部分，同时也实现了一些数学算法，PbMath，用于做数学的线性变换和矩阵运算等操作。支持矩阵于向量的乘法，支持常见的点积与叉积。
public static Vector3d operator *(Matrix3x3d matx, Vector3d vector) { return new Vector3d((matx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/679b644385275bf63e889f6ca7ef441a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae797045c9ae075c8838ced3681eee0/" rel="bookmark">
			list.set交换数据需要（or不需要）添加其他中间变量，两个例子告诉你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：set()方法是来修改指定位置的元素。 两个参数，第一个参数是要修改的元素的索引，第二个参数是要设置的新值。
案例一：当链表中传入的是字符串时：
public static void main(String[] args) { List list = new LinkedList(); list.add("鱼香肉丝"); list.add("粉蒸肉"); list.add("梅干菜扣肉"); System.out.println("=======迭代器遍历======"); Iterator ito = list.iterator(); while (ito.hasNext()) { Object o = ito.next(); System.out.println(o); } //交换前两个元素，正确做法： String str1 = (String)list.get(0); String str2 = (String)list.get(1); list.set(0,str2); list.set(1,str1); //交换前两个元素，错误示例 //list.set(0,list.get(1)); //list.set(1,list.get(0)); System.out.println("=======增强for遍历======"); for (Object ob : list) { System.out.println(ob); } } 错误示例：当调用list.get(1)时，便将list.get(0)覆盖了，此时的 list.get(0)="粉蒸肉"。
当然，面对元素较少的List ，你也可以选择重新赋初值，示例如下： list.set(0,"粉蒸肉"); list.set(1,"鱼香肉丝"); 打印结果：
案例二：当list传入的不是字符串，而是一个对象时：
public static void main(String[] args) { List list = new LinkedList(); // List list = new Vector(); // List list = new ArrayList(); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae797045c9ae075c8838ced3681eee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91535eb764e43f9f6bb696d09e9e6e5e/" rel="bookmark">
			【npm 命令】一次性更新所有包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一次性升级更新项目所依赖的资源，
但是如果升级大版本的话，可能会有兼容性问题；
npm outdated 检查 npm 包的版本状态
// 更新所有包 || -- save 主动更新 paceage.json 文件
npm update || npm update --save
// 更新单个包 ；带上 @ersion - 更新到特定版本
npm update package@version
问题：update 不会去更新 paceage.json 文件；
这个问题 npm v8 开始,将 --save 添加到命令就可以主动更新了；
如果不使用该方法的话，可以使用 npm-check-updates
npm install -g npm-check-updates
之后使用命令去更新 json 文件
ncu 检查 json 文件中的更新
ncu -u 更新 文件
问题2：可能会报依赖项的错
可以使用命令清除 node 缓存
npm cache clean --force 删除 node_modules ，重新install；
问题3：包的报错；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91535eb764e43f9f6bb696d09e9e6e5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11dd6dbd29da7bd414c022b10858fc2/" rel="bookmark">
			centos7 安装 mysql 8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境介绍一、安装前准备 1.卸载MariaDB 1.1 查看是否安装mariadb1.2 卸载1.3 检查是否卸载干净 2.检查依赖 2.1 查看是否安装libaio2.2 查看是否安装numactl 二、安装MySQL 1.下载资源包 1.1 官网下载1.2 wget下载 2.解压3.重命名4.创建存储数据文件5.设置用户组并赋权6.初始化MySQL7.配置参数文件8.启动MySQL9.设置软连接，并重启MySQL10.登录并更改密码11.开放远程连接12.连接工具测试连接MySQL13.MySQL启动和停止 三、设置开机自启动（可选） 环境介绍 操作系统：Centos7.6
MySQL版本： 8.0.30
本文使用的是当前最新8.0.30版本，如果需要安装的版本比8.0.30高或者低，只要是8.0.*版本，那就可以按照本文说明安装，基本不会有任何问题。
一、安装前准备 1.卸载MariaDB 安装MySQL的话会和MariaDB的文件冲突，所以需要先卸载掉MariaDB。
1.1 查看是否安装mariadb rpm -qa|grep mariadb 1.2 卸载 rpm -e --nodeps 文件名 1.3 检查是否卸载干净 rpm -qa|grep mariadb 2.检查依赖 2.1 查看是否安装libaio rpm -qa|grep libaio 如果没有安装则执行
yum -y install libaio //安装libaio 2.2 查看是否安装numactl rpm -qa|grep numactl 如果没有安装则执行
yum -y install numactl //安装numactl 二、安装MySQL 1.下载资源包 可以在官网下载安装包或者在服务器直接使用wget下载。
1.1 官网下载 MySQL官网下载地址:https://dev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c11dd6dbd29da7bd414c022b10858fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d865ae46919d6c5cca26ca01c1f57e/" rel="bookmark">
			VisualStudio(VS)设置程序的版本信息(C-C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在软件开发过程中，通常需要为生成的程序添加一些重要的元数据，如版本号、公司名称和版权信息。这些信息不仅可以提供对程序的更详细描述，还可以帮助用户了解程序的来源和使用限制。在 Visual Studio (以2017为例)中，可以轻松地设置这些信息，使应用程序具有更专业、规范的要求。
本文将介绍如何在 Visual Studio 2017 中设置生成程序的版本信息、公司信息和版权信息逐步指导大家完成这个过程，无论是开发新项目，还是为现有项目添加这些重要的元数据，都能从本文中获得帮助。下面将详细说明每个步骤，并提供示例和提。
二、添加版本信息 【1】选择左边项目选项卡，鼠标点击右键，点击添加，选择新建项。
【2】选项资源—&gt;资源文件(.rc)—&gt;最后点击添加。
【3】添加之后在解决方案选项卡里就可以看到添加的资源文件，双击资源文件就可以打开编辑资源。
【4】在资源编辑页面，右键，点击添加资源。
【5】选择版本，点击新建。
【6】填写版本信息，公司信息等数据。
下面是填写好的： 我只是填写了文件版本和公司名称。
【7】回到解决方案页面，重新编译生成程序。
【8】在应用程序目录下，查看版本信息。
把鼠标光标放在文件上就会弹出提示状态窗，看到文件信息。
在文件属性里可以看到信息。
三、编辑版本信息 版本文件创建之后，在代码目录下可以看到刚才创建的版本资源文件。
用记事本打开之后就能看到刚才填写信息，在这里更改重新编译代码也可以的(要注意格式)。
// Microsoft Visual C++ generated resource script. // #include "resource.h" #define APSTUDIO_READONLY_SYMBOLS / // // Generated from the TEXTINCLUDE 2 resource. // #include "winres.h" / #undef APSTUDIO_READONLY_SYMBOLS / // 中文(简体，中国) resources #if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS) LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED #ifdef APSTUDIO_INVOKED / // // TEXTINCLUDE // 1 TEXTINCLUDE BEGIN "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d865ae46919d6c5cca26ca01c1f57e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fc00983cbb356fc530102e7fdae777/" rel="bookmark">
			HTTPS单向认证与双向认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS单向认证与双向认证 HTTPSCA证书单向认证双向认证 HTTPS Https就是HTTP+SSL/TSL的简称。
SSL(Secure Socket Layer 安全套接层)是TCP/IP协议中基于HTTP之下TCP之上的一个可选协议层。
起初HTTP在传输数据时使用的是明文，传输过程中并不安全。网景（Netscap）公司推出了SSL解决了这一安全隐患，因此越来越多的人也开始使用HTTPS。在SSL更新到3.0时， 互联网工程任务组（IETF）对SSL3.0进行了标准化，并添加了少数机制，并将其更名为TLS1.0(Transport Layer Security 安全传输层协议)，可以说TLS就是SSL的新版本3.1。TLS与SSL两者所使用的算法是不同的TLS增加了许多新的报警代码，比如解密失败(decryption_failed)、记录溢出(record_overflow)、未知CA(unknown_ca)、拒绝访问(access_denied)等，但同时也支持SSL协议上所有的报警代码。由于这些区别的存在，我们可认为TLS是SSL的不兼容增强版。即TLS和SSL不能共用，在认证证书时TLS指定必须与TLS之间交换证书， SSL必须与SSL之间交换证书。
CA证书 CA是Certificate Authority（证书授权）的简称,是由认证机构服务者签发，是数字签名的技术基础保障，也是网上实体身份的证明，能够证明某一实体的身份及其公钥的合法性，证明该实体与公钥二者之间的匹配关系。
CA证书一般由证书认证机构（CA）签发，过程：
1、申请者自己通过非对称加密算法（RSA） 生成对应的公钥和私钥，然后把需要的申请信息（国家，域名等）连同公钥（就是RSA生成的公钥）发送给 证书认证机构（CA）
2、证书认证机构（CA）确认无误后通过消息摘要算法（MD5，SHA) 加密申请的CA证书中的信息，加密完的就叫信息摘要，然后把信息摘要用CA的私钥（申请的RSA私钥） 进行加密，加密完的数据就是签名。
单向认证 1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书（包含了公钥和数字签名）。
3、客户端使用服务端返回的信息验证服务器的合法性，包括：
证书是否过期（这个可能就是平常访问浏览器有红色的提示的原因）发行服务器证书的CA是否可靠（这个可能就是平常访问浏览器有红色的提示的原因）返回的公钥是否能正确解开返回证书中的数字签名服务器证书上的域名是否和服务器的实际域名相匹配验证通过后，将继续进行通信，否则，终止通信 4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。
5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。
6、服务器将选择好的加密方案通过明文方式返回给客户端。
7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，这个随机码则用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务端。
8、服务器收到客户端返回的加密信息后，使用CA的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该对称加密密钥进行对称加密，保证通信过程中信息的安全。
个人理解：单向认证在认证方面，只有客户端对服务端的证书进行了验证，验证了这个SSL证书是否是可信的，而服务端并没有对客户端的相关信息进行验证，这就导致了下面抓包工具在https中进行抓包！
双向认证 1、客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
2、服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书（包含了公钥和数字签名）
3、客户端使用服务端返回的信息验证服务器的合法性，验证通过后，将继续进行通信，否则，终止通信，其中包括：
证书是否过期发行服务器证书的CA是否可靠返回的公钥是否能正确解开返回证书中的数字签名服务器证书上的域名是否和服务器的实际域名相匹配 4、服务端要求客户端发送客户端的证书（这个证书指的就是内置存储在当前APP中通信需要用的证书），客户端会将自己内置的证书发送至服务端（在APP中一般都是类似client.p12的文件等等的）
5、服务端验证客户端的证书，通过验证后，会获得客户端的公钥
6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式
8、服务端将加密方案通过使用之前客户端提供给服务端的公钥进行加密，返回给客户端
9、客户端收到服务端返回的加密方案密文后，使用自己内置证书的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端
10、服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。
ps：双向认证的客户端证书一般都可以是如openssl生成的自签名证书，包括 client.crt 和 client.key，这两部分内容可以集成在 p12 证书中, p12 证书可以设置打开密码。
个人理解证书验证的过程：
先理解下信任传递比如A信任C，B也信任C，那么AB就可以通过C也建立信任关系，CA是值得信任的因此CA颁发的证书值得信任，这个是证书验证的前提。
服务器会去CA申请一个数字证书，提交一些信息（RSA公钥，证书拥有者身份信息，数字证书认证机构（发行者）信息，发行者对这份文件的数字签名及使用的算法，证书的有效期），CA需要去核实这些信息，CA核实后会签发一个用CA私钥加密的数字证书给服务器，同时提供一个CA的公钥用于解密。
客户端收到服务端发送来的CA私钥加密的证书这个过程是如何保持不被第三方破解转发的呢？
证书是CA的私钥进行加密的，CA的私钥我们认为是安全可信的，因此就算第三方截取到消息可以进行解密（使用CA的公钥），但是无法串改信息后加密（因为第三方没有CA的私钥），这就保证了客户端收到的信息一定是服务端发来的，然后对服务的发来的证书进行验证
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8437cf5a048c1664ae7820f64f8b6f10/" rel="bookmark">
			Unity AI Muse 基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity AI Muse 基础教程 Unity AI 内测资格申请Unity 项目Package ManagerMuse Sprite 安装Muse Texture 安装 Muse Sprite 基础教程什么是 Muse Sprite打开 Muse Sprite 窗口Muse Sprite 窗口 参数Muse Sprite Generations 窗口 参数Muse Sprite Generations 窗口 画笔Muse Sprite Generations 二次修改 窗口 Muse Texture 基础教程什么是 Muse Texture打开 Muse Texture 窗口Muse Texture 基础参数Muse Texture 图像生成Muse Texture 材质预览Muse Texture Generations 参数Muse Texture 材质球 参数Muse Texture 材质 保存Muse Texture 材质 应用 Muse Sprite &amp; Muse Texture 演示视频 Unity AI 内测资格申请 Unity AI 内测资格申请链接: Unity AI Unity 项目 项目创建 Package Manager 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8437cf5a048c1664ae7820f64f8b6f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24cccd7cafb1c83fc80aa949ec36b257/" rel="bookmark">
			16-k8s-configMap配置管理中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、相关概念二、基于目录创建configMap三、基于文件创建configMap四、基于自定义参数创建configMap五、configMap使用六、configMap热更新 一、相关概念 简介
为了解决传统容器中配置的挂载、变更、管理等问题，在k8s中引入了一个叫做configmap的资源对象，在configmap中，各个配置项都是以key-value的方式存在的，value的数据可以是一个配置文件的内容，这些配置项被保存在k8s使用的持久化存储etcd中。这样就形成了一个k8s中的配置中心，可以独立的对configmap中的数据进行修改，然后将configmap挂载到pod中进行使用，可以以env的方式，也可以以配置文件的方式在pod中进行引用。这样配置和pod就实现了解耦，都是k8s中独立的资源对象。
使用场景
• 填充环境变量的值
• 设置容器内的命令行参数
• 填充卷的配置文件
常用创建方式
• 基于目录创建
• 基于文件创建
• 基于自定义参数创建
configMap指令查看：kubectl create configMap -h
二、基于目录创建configMap 创建文件夹：mkdir /opt/config
创建文件：vi /opt/config/t1.properties
configmap1: name: myConfigmap1 创建文件：vi /opt/config/t2.properties
configmap2: name: myConfigmap2 创建configMap：kubectl create configmap my-config --from-file=/opt/config/
查看：kubectl get cm
查看详情：kubectl describe cm my-config
三、基于文件创建configMap 创建configMap：kubectl create configmap t1-config --from-file=/opt/config/t1.properties
查看：kubectl get cm
查看详情kubectl describe cm t1-config
基于文件创建configMap并且修改文件名：kubectl create cm t2-config --from-file=new-t2.yml=/opt/config/t2.properties
查看：kubectl describe cm t2-config
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24cccd7cafb1c83fc80aa949ec36b257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8ad305465673a03fca05e99a6ecb1e/" rel="bookmark">
			blob和ArrayBuffer格式图片如何显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先blob格式图片
&lt;template&gt; &lt;div&gt; &lt;img :src="imageURL" alt="Image" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { imageBlob: null, // Blob格式的图片 imageURL: null // 图片的URL }; }, async mounted() { // 获取Blob格式的图片 // ... // 将Blob格式的图片转换为可访问的URL const objectURL = URL.createObjectURL(this.imageBlob); this.imageURL = objectURL; } }; &lt;/script&gt; ArrayBuffer
let blob = new Blob( [res.data], {type:'application/vnd.ms-excel;charset=utf-8'} ); let imgUrl = URL.createObjectURL(res.data) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f2792c14e5366cb15f243c66bde1d5/" rel="bookmark">
			软考高项第四版教材整合管理（第8章）重点内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序：距离2023下半年软考还有18天，来不及看书的小伙伴看过来啦，一起过一下重点，开始之前，建议大家将下面的过程组矩阵图熟记！！！
第8章 项目整合管理 项目整合管理包括识别、定义、组合、统一和协调项目管理过程组的各个过程和项目管理活动。在项目管理中，整合管理兼具统一、合并、沟通和建立联系的性质，项目整合管理贯穿项目始终。
文章目录 第8章 项目整合管理1. 管理基础1.1 执行整合1.2 整合的复杂性1.4 项目管理计划和项目文件 2. 项目整合管理过程2.1 过程概述2.3 敏捷与适应方法 3. 制定项目章程3.1 输入3.2 工具与技术3.3 输出 4. 制定项目管理计划4.1 输入4.2 工具与技术4.3 输出 5. 指导与管理项目工作5.1 输入5.2 工具与技术5.3 输出 6. 管理项目知识6.1 输入6.2 工具与技术6.3 输出 7. 监控项目工作7.1 输入7.2 工具与技术7.3 输出 8. 实施整体变更控制8.1 输入8.2 工具与技术8.3 输出 9. 结束项目或阶段9.1 输入9.2 工具与技术9.3 输出 总结 tips：文章只记录重点内容，时间充裕还是需要结合教材😊
1. 管理基础 1.1 执行整合 项目整合管理由👉项目经理负责，项目经理负责整合所有其他知识领域的成果，并掌握项目总体情况。项目整合管理的责任不能被授权或转移，项目经理必须对整个项目承担最终责任。整合是项目经理的一项关键技能。执行项目整合时项目经理承担双重角色：
组织层面上，项目经理扮演重要角色，与项目发起人携手合作，了解战略目标并确保项目目标和成果与项目组合、项目集以及业务领域保持一致。项目经理以这种方式有助于项目的整合与执行。项目层面上，项目经理负责指导团队关注真正重要的事务并协同工作。为此，项目经理需要整合过程、知识和人员。 1.2 整合的复杂性 项目的复杂性来源于组织的系统行为、人类行为以及组织或环境中的不确定性。
在项目整合之前，项目经理需要考虑项目面临的内外部环境因素，检查项目的特征或属性。作为项目的一种特性或属性，复杂性的含义：①包含多个部分；②不同部分之间存在一系列关联；③不同部分之间的动态交互作用；④这些交互作用所产生的行为远远大于各部分简单的相加（例如突发性行为）。
1.4 项目管理计划和项目文件 项目管理过程中，会使用并产生两大类文件：一是项目管理计划；二是项目文件。二者一般包含的内容如下图示： 2. 项目整合管理过程 2.1 过程概述 项目整合管理过程包括：①制定项目章程：编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件。②制定项目管理计划：定义、准备和协调项目计划的所有组成部分，并把它们整合为一份综合项目项目管理计划。③指导与管理项目工作：为实现项目目标而领导和执行项目管理计划中所确定的工作，并实施已批准变更。④管理项目知识：使用现有知识并生成新知识，以实现项目目标，帮助组织学习。⑤监控项目工作：跟踪、审查和报告整体项目进展，以实现项目管理计划中确定的绩效目标。⑥实施整体变更控制：审查所有变更请求，批准变更，管理可交付成果、组织过程资产、项目文件和项目管理计划的变更，并对变更处理结果进行沟通⑦结束项目或阶段：结束项目、阶段或合同的所有活动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f2792c14e5366cb15f243c66bde1d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97128ca81a2e0ce27dd26690079da9f/" rel="bookmark">
			Apche Kudu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 在Kudu之前,大数据主要以两种方式存储;
(1) 静态数据:
以 HDFS 引擎作为存储引擎,适用于高吞吐量的离线大数据分析场景。这类存储的局限性是无法进行随机的读写。
（2）动态数据：
以HBase、Cassandra 作为存储引擎，适用于大数据随机读写场景。局限性是批量读取吞吐量远不如HDFS，不适用于批量数据分析的场景。
Kudu的定位是一个既支持随机读写、又支持 OLAP 分析的大数据存储引擎。
2.kudu是什么 Apache Kudu 是由 Cloudera 开源的存储引擎，可以同时提供低延迟的随机读写和高效的数据分析能力。它是一个融合HDFS和HBase的功能的新组件，具备介于两者之间的新存储组件。
Kudu支持水平扩展，并且与Cloudera Impala 和 Apache Spark 等当前流行的大数据查询和分析工具结合紧密。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac377ba79818b50e97d2068fd0d41f2/" rel="bookmark">
			Typora:markdown语法的使用说明!必会速成版!!!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介(在Typora中对下面的简介按下ctrl+鼠标单击快速跳转) 标题部分
段落部分
文字显示
列表
区块显示
代码显示
链接
脚注
插入图片
插入表格
一.标题 语法: # 代表(一级标题) ## 代表(二级标题) ### (三级标题)....
其中需要在每个#后面添加空格这样,标题功能才能生效
快捷键:
Ctrl+数字1-6可以快速将选中的文本调成对应级别的标题
Ctrl+0可以快速将选中的文本调节成普通的文本
Ctrl+加号/减号对标题级别进行加减
二.段落 1. 换行 按下键盘的回车键可以完成换行
按下shift+enter键可以完成没有行间隔的换行 就是这种效果
2. 分隔线 语法:三个减号+enter回车或者三个*号+enter键回车
三.文字显示 语法:
粗体:用一对双星号包裹** 粗体 **,或者是使用一对双下划线包裹111 删除线:用一对双飘号包裹~ 下划线:用一对u标签包裹&lt;u&gt;下划线&lt;u&gt; 斜体:用一对单星号包裹 * 斜体 * 高亮:用一对双等号包裹==
演示:
粗体 这里是删除线 这是下划线 这是斜体 高亮显示
快捷键: 加粗:ctrl+B 删除线:shift+alt+5 下划线:ctrl+U 斜体:ctrl+i
如何解决不显示乘号的问题*需要使用转义字符 123*4
1*2*3...*n
如何显示上下标 如果想要输入x2 上标 需要将x和2之间输入一个^符号,在上标的最后也要输入一个 ^
如果想要输入下标 H2O 需要将下标的左右两侧加入波浪线~
四.列表 如果是无序列表可以使用键盘上*/-/+ +空格 效果:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac377ba79818b50e97d2068fd0d41f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319f5e470399528c97532a372e66d226/" rel="bookmark">
			未解决quired request parameter ‘User‘ for method parameter type User is not present\r\n\tat org.springf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot中请求
@RequestMapping(value = "/postTest3",method = RequestMethod.POST) //传入user对象 public String postTest3( @RequestParam User user){ /* ！注意：前端传入的名称必须与User类中的属性名一致 */ System.out.println(user); return "POST请求"; } User类部分
public class User { private String username; private String password; public User(){} } 错误：
Required request parameter 'User' for method parameter type User is not present\r\n\tat org.springframework.web.method.annotation.RequestParamMethodArgumentResolver.
翻译过来就是： 方法参数类型所需的请求参数“用户”不存在\r\n\tat org.springframework.web.method.annotation.RequestParamMethodArgumentResolver.
解决：暂未解决，请帮忙看看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87356e512928a34cedec9e94afc085f7/" rel="bookmark">
			Spark面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Spark Core &amp; SQL 1.1Spark 有几种部署方式？ （1）Local：运行在一台机器上，通常是练练手或者测试环境。
（2）Standalone：构建基于Master+Slaves 的资源调度集群，spark 任务提交给 Master运行，是 Spark 自身的一个调度系统。
（3）Yarn: Spark 客户端直接链接 Yarn，不需要额外构建 Spark 集群。有yarn-client 和 yarn-cluster 两种模式， 主要区别在于 Driver 程序的运行节点。
（4）Mesos：国内大环境比较少用。
1.2 如何理解Spark 中的血统概念（ RDD ） RDD 在 LIneage 依赖方面分为两种 Narrow Dependenciss 与 Wide Dependenciss 用来解决数据容错的高小性以及划分任务时候起到重要作用。
1.3 简述 Spark 的宽窄依赖，以及 Spark 如何划分 stage 又根据什么决定 task 个数？
Stage：根据 RDD 之间的依赖关系的不同将 Job 划分成不同的 Stage ，遇到一个依赖则划分一个 Stsge。
Task：Stage 是一个 TaskSet，将 Stage 根据分区划分成一个个的 Stage。
1.3 如何使用Spark实现TopN的获取 方法1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87356e512928a34cedec9e94afc085f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6e300fd872ced648a368885624f542/" rel="bookmark">
			Word标题编号转换为纯文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建宏
这个要用到宏命令
打开Word文档，按下快捷键Alt+F8，在“宏名”栏中输入“编号转换为文本”，这是给它起的名字，然后点击“创建”在新打开的窗口上，你会看到光标在闪烁，把下面函数中的4行内容复制粘贴到此处。 Sub 编号转纯文本()
Dim kgslist As List
For Each kgslist In ActiveDocument.Lists
kgslist.ConvertNumbersToText
Next
End Sub
如图所示。
二、运行宏
然后按下快捷键Alt+Q(或者，点击左上角“文件”——“关闭并返回到Microsoft Word”)，回到Word界面。
光标定位在除了自动编号以外的任意位置，然后按下Alt+F8，选中“编号转纯文本”(选中后底色为蓝色)，再点击“运行”。
这就完成了，自动编号就成了可以编辑的文本(真实的文字)了。
之后再遇到类似情况，就可以直接运行“编号转换为文本”的宏。
内容参考自：https://blog.csdn.net/wangzhi291/article/details/129876429
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb1a7a7f1f8dba95802d039a70131f4/" rel="bookmark">
			什么情况下需要用到JSON.parse?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编程中，我们通常需要在JavaScript中处理JSON数据。JSON.parse()是JavaScript中的一个内置函数，用于将JSON字符串转换为JavaScript对象。下面是一些常见情况下使用JSON.parse()的示例：
1）从服务器获取数据：当通过网络请求从服务器获取数据时，服务器通常会将相应以JSON字符串的形式发送回来。在JavaScript中，我们需要使用JSON.parse()将这个JSON字符串解析为对象或数组，以便在代码中进一步处理。
例如：
var jsonString = '{"name":"John", "age":30, "city":"New York"}'; var obj = JSON.parse(jsonString); console.log(obj.name); // 输出：John console.log(obj.age); // 输出：30 console.log(obj.city); // 输出：New York 2）处理用户输入的JSON数据：当用户通过表单或其他方式输入JSON数据时，通常以字符串的形式传递给JavaScript代码。在这种情况下，我们可以使用JSON.parse()将输入的JSON字符串解析为对象，并在代码中进行验证或处理。
例如：
var userInput = '{"name":"John", "age":30, "city":"New York"}'; var obj = JSON.parse(userInput); if (obj.name &amp;&amp; obj.age &amp;&amp; obj.city) { // 执行相应操作 } else { // 处理无效输入 } 3）存储和读取本地数据：当我们需要将JavaScript对象或数组保存在本地存储（如localStorage或IndexedDB）中时，由于本地存储只能存储字符串，我们需要使用JSON.stringify()将对象转换为JSON字符串进行存储，然后再使用JSON.parse()将存储的JSON字符串解析回JavaScript对象或数组进行读取。
例如：
// 存储数据 var data = {name: "John", age: 30}; var jsonString = JSON.stringify(data); localStorage.setItem("userData", jsonString); // 读取数据 var savedData = localStorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb1a7a7f1f8dba95802d039a70131f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f13566b519ccbb3048e1c9c338b825a/" rel="bookmark">
			JS获取任意一天的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取前一天的当前时刻和当前时刻
mounted() { this.searchForm.endTime = this.getNow() this.searchForm.startTime = new Date(new Date().setDate(new Date().getDate() - 1)) // 获取当前日期前一天的Date对象 this.searchForm.startTime = this.dataFormat(this.searchForm.startTime) }, methods: { // 格式化时间 dataFormat(date) { // date是传入的时间 let d = new Date(date) let month = d.getMonth() + 1 &lt; 10 ? '0' + (d.getMonth() + 1) : d.getMonth() + 1 let day = d.getDate() &lt; 10 ? '0' + d.getDate() : d.getDate() let hours = d.getHours() &lt; 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f13566b519ccbb3048e1c9c338b825a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37e6f0780c5157abe71a608dbd632c59/" rel="bookmark">
			vue中使用element-ui如何使用分页？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // Template &lt;el-pagination v-if="titleData.length&gt;0" :current-page="pageNo" :page-size="pageSize" layout="total, prev, pager, next, jumper" :total="total" @size-change="handleSizeChange" @current-change="handleCurrentChange" /&gt; // JS data() { return { total: 0, // 总数 pageNo: 1, // 第一页 pageSize: 50, // 每页条数 } }, methods: { /** * 分页处理 */ handleSizeChange(val) { this.pageSize = val this.pageNo = 1 this.getRealTimeAlarmList() }, handleCurrentChange(val) { this.pageNo = val this.getRealTimeAlarmList() } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d041ac8da2ec9549e73f35a6eb6d1c/" rel="bookmark">
			Vue中，如何让echarts放大缩小自适应？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8155058b69b28806ddbf8beb788364/" rel="bookmark">
			提升微服务稳定性与性能：深入剖析Netflix Hystrix框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到 Netflix Hystrix 框架，一定离不开 com.netflix.hystrix.HystrixCommand，这个类是 Netflix 开源的 Hystrix 框架中的一个关键类，用于实现服务的容错和熔断功能。它主要用于将远程服务调用封装成一个独立的命令对象，以便于进行容错处理和监控。
一、核心源码 源码中有几个关键方法，具体方法以及注释看下面的代码：
public abstract class HystrixCommand &lt; R &gt; extends AbstractCommand &lt; R &gt; implements HystrixExecutable&lt; R &gt;, HystrixInvokableInfo&lt; R &gt;, HystrixObservable&lt; R &gt; { /** * 用于【同步】执行命令 */ public R execute() { try { return queue().get(); } catch(Exception e) { throw Exceptions.sneakyThrow(decomposeException(e)); } } /** * 用于【异步】执行命令。 */ public Future&lt; R &gt; queue() { return f; } /** * execute() 或 queue()失败的时候，返回兜底数据 */ protected R getFallback() { throw new UnsupportedOperationException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb8155058b69b28806ddbf8beb788364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85e2a86aa533dd6ab8d3c5b63ac8a62b/" rel="bookmark">
			GET https://unpkg.com/element-ui/lib/theme-chalk/index.css net::ERR_CONNECTION_REFUSED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个解决办法
1.修改unpkg.com为unpkg.zhimg.com
2.下载文件，根据路径引入即可（但这样可能会出现呢一些问题，可以试试）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a16a6726c03782602b9898d4cc02bb/" rel="bookmark">
			ngc项目需要注意的点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、else做好处理， this.$message.error((res.extras === null ? '' : res.extras) + (res.errors === null ? '' : res.errors))不适用于每一个函数中的else做处理
2、列表无数据必须做暂无数据处理
3、动态获取列表表头和信息在一个接口里面写
1）在el-table-clumn中做v-for循环数组，数组和tableData的数组在一个接口里面获取
4、做列表查询的时候，有select框的时候，例如：
注意！！！searchForm.deviceName是赋为获取列值表的第一个数据
//=============templete &lt;el-select v-model="searchForm.deviceName" placeholder="选择设备名称" clearable &gt; &lt;el-option v-for="item in deviceNameList" :key="item.deviceName" :label="item.deviceName" :value="item.deviceName" /&gt; &lt;/el-select&gt; //==============js searchForm: { deviceName: '' }, deviceNameList: [], getSelectData() { this.$api.ngcConfiguration.queryDeviceList() .then(res =&gt; { if (res.statusCode === 200) { if (res.data &amp;&amp; res.data.length &gt; 0) { this.deviceNameList = res.data this.searchForm.deviceName = res.data[0].deviceName // 返回的第一个值附上给deviceName this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10a16a6726c03782602b9898d4cc02bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd13443026fc7ad8838267c19b3a2e49/" rel="bookmark">
			Android学习笔记（三）：添加新activity、Button
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前提到过，活动就类似于界面，如我们可以从一个微信主界面跳转到聊天界面，实现方法就是从一个活动跳转到另一个活动。现在我们就来增加一个新活动，并通过一个按钮实现跳转。
一、自动创建activity Android studio 可以自动创建一个activity，在app/src/main/java/com.example.myapplication/ 目录下右键-&gt;New-&gt;Activity-&gt;Empty Views Activity 新建一个empty activity，如下图所示
从上图可以看到，其中需要设置activity name（活动名）、Layout name（布局名）、 package name（包名），以及编译语言java。默认设置，finish
可以看到，自动生成了两个文件，java文件和xml布局文件，你可以点开文件看看内容，并按照之前学的知识，尝试修改内容试试，比如在布局中增添一个TextView。
此外，打开AndroidManifest.xml文件，你会发现这个文件内容也被修改了，新增了如下代码
&lt;activity android:name=".MainActivity2" android:exported="false" /&gt; 我之前提到过，AndroidManifest.xml文件类似于一个注册表，所有的活动都需要在这个文件中注册才可以使用。其中，name 指指activity类，exported先不管，可以删除。因此，我们知道，新建一个activity，我们需要新建一个activity类，新增一个xml布局文件，并修改ActivityManifest.xml文件。你不妨手动创建一个empty activity ，进一步加深理解。
既然增添了一个新活动，那我们怎么使用它呢。我们可以通过一个按钮，从一个活动跳转到另一个活动。
二、添加一个Button按钮 我们从activity_main界面（MainActivity）利用按钮跳转到activity_main2界面（MainActivity2），那就需要在activity_main.xml文件中增添一个按钮布局，代码如下所示
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center"&gt; &lt;TextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/hello"/&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/Button"/&gt; &lt;/LinearLayout&gt; &lt;Button ... /&gt; 语法就是添加一个按钮布局，其中的语法，通过前面的学习我想你们应该都能够轻松理解了吧。在strings.xml文件中，我设置 Button = go to activity2 。你可以通过在右上角点击Split中看到布局，如下图所示
三、实现按钮逻辑，跳转界面 打开MainActivity.java文件，修改代码如下
public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd13443026fc7ad8838267c19b3a2e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3816acee04b8be87cdf418e30d2f44c4/" rel="bookmark">
			Android学习笔记（二）：TextView显示Hello World
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可能很好其，界面显示的Hello World到底在哪写的呢！
一、 XML布局文件 Android将代码逻辑实现与界面布局分开，这样当你只想使用代码逻辑又不想使用它对应的布局时，就可以很方便的调用。XML文件就是用于布局界面的，如按钮、文本显示等等布局。
二、activity_main.xml布局文件 打开文件 项目/app/src/main/res/layout/activity.xml ，你就可以看到“Hello World”（在这里简单说明以下，res/layout/ 目录下主要存放各种xml布局文件）。如果你点开不是显示的代码，就点击如图所示右上角的 Code 按钮，其中Design中，可以直接拖动或者选择各种选项设计，达到我们想要的界面，但是这样不方便我们了解原理和逻辑，也不便于app适配各种设备，因为当你将这个应用安装到其他尺寸手机时，布局就会变得不一样了。Split中可以很方便我们看到当前代码设计的布局到底是什么样式的。
以上这些内容、语法，你都很陌生，我们先改为以下的内容
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!"/&gt; &lt;/LinearLayout&gt; 这些语法就相对比较简单了，我们简单分析一下，如果不够清楚，也不要急，后面学习过程中会逐渐明白。
&lt;?xml version="1.0" encoding="utf-8"?&gt; 很明显是对xml文件格式和版本的说明。
1、LinearLayout 线性布局 &lt;LinearLayout ... &gt; ... &lt;/LinearLayout&gt; 表明这是一种线性布局（linear layout），注意尖括号要互相对应。第一对尖括号中主要是对该线性布局整体的布局设计，而第二对尖括号表示这个线性布局的结束。
xmlns:android="http://schemas.android.com/apk/res/android" xmlns表示xml命名空间（name space），因此，你可以看到后面的语句 中都包含了 android: 字样。
android:layout_width和height 从名字上看就能明白其表示布局的宽高，而其值match_parent则表示匹配整个界面。
android:orientation="vertical" 该句语法用于设计布局整体排布，vertical表示垂直排布，当你有多个要显示的文本内容或者按钮等，都会垂直依次从上往下排。
android:gravity="center" 该句语法表示对齐模式，center则表示中心对齐，因此你看到hello world在界面中心。
2、TextView 文本内容显示器 &lt;TextView ... /&gt; 表明这是一个用于显示文本内容的布局工具。通过LinearLayout 和 TextView 你可以发现尖括号的作用以及使用，&lt;.../&gt; 或者 &lt;N ... &gt;&lt;/N&gt;。你不妨尝试着修改一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3816acee04b8be87cdf418e30d2f44c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e7c560af7b179963472348269a7024/" rel="bookmark">
			基于Java学生在线考试系统设计实现(源码&#43;lw&#43;部署文档&#43;讲解等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
​ 系统介绍： 如今社会上各行各业，都喜欢用自己行业的专属软件工作，互联网发展到这个时候，人们已经发现离不开了互联网。新技术的产生，往往能解决一些老技术的弊端问题。因为传统考试信息管理难度大，容错率低，管理人员处理数据费工费时，所以专门为解决这个难题开发了一个学生在线考试系统，可以解决许多问题。
学生在线考试系统实现的功能包括老师管理，试卷管理，错题本管理，试题管理，考试记录管理，论坛管理，公告管理等功能。该系统采用了Mysql数据库，Java语言，SSM框架等技术进行编程实现。
学生在线考试系统可以提高考试信息管理问题的解决效率，优化考试信息处理流程，保证考试信息数据的安全，它是一个非常可靠，非常安全的应用程序。
图4.1即为设计的管理员功能结构，管理员权限操作的功能包括对老师，论坛帖子，用户，试卷信息以及考试信息等信息进行管理。
图4.1 管理员功能结构
图4.2即为设计的老师功能结构，老师权限操作的功能包括对试卷进行管理，对试卷的试题进行管理，管理用户考试记录和错题信息，管理论坛帖子等。
图4.2 老师功能结构
图4.3即为设计的用户功能结构，用户权限操作的功能包括选择试卷进行考试，对考试记录以及考试得分信息进行查看，通过论坛功能进行考试方面的信息讨论等。
图4.3 用户功能结构
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
功能截图： 编程人员在搭建的开发环境中，会让各种编程技术一起呈现出最终效果。本节就展示关键部分的页面效果。
5.1 管理员功能实现 5.1.1 老师管理 图5.1 即为编码实现的老师管理界面，管理员对老师的基础信息包括邮箱，老师手机号等进行更改，查询，删除需要删除的老师信息，同时可以为老师的账号进行密码重置。
图5.1 老师管理界面
5.1.2 用户管理 图5.2 即为编码实现的用户管理界面，管理员增删改查用户资料。为用户的账号重置密码。
图5.2 用户管理界面
5.1.3 论坛管理 图5.3 即为编码实现的论坛管理界面，管理员具备查看论坛帖子回复信息，更改论坛帖子内容，帖子类型，帖子标题等信息，删除需要删除的论坛帖子信息等权限。
图5.3 论坛管理界面
5.2 老师功能实现 5.2.1 试卷管理 图5.4 即为编码实现的试卷管理界面，老师具备更改试卷总分信息，试卷状态，考试时长等信息，以及删除需要删除的考试试卷，同时可以使用试卷查询功能完成对试卷管理界面显示的试卷信息的查询操作等权限。
图5.4 试卷管理界面
5.2.2 试题管理 图5.5 即为编码实现的试题管理界面，考试试卷里面包括了试题信息，试题信息需要老师在试题管理界面新增，更改，查询以及删除等，其中试题信息包括分值，正确答案，试题类型，答案解析等信息。
图5.5 试题管理界面
5.2.3 考试记录 图5.6 即为编码实现的考试记录界面，考试记录界面展示了用户考试所选试卷以及对试卷答题所得总分信息，老师通过考试详情可以了解更多用户考试情况信息。
图5.6 考试记录界面
5.3 用户功能实现 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e7c560af7b179963472348269a7024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686bd6ea7bd9f99891ea3a605007a0a6/" rel="bookmark">
			【MySQL进阶之路丨第九篇】一文带你精通MySQL子句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇中我们介绍了数据的插入与查询；在开发中，掌握数据的增删改查等操作和语句是十分重要的。
这一篇我们使用命令行方式来帮助读者掌握MySQL子句。
上一篇链接：MySQL | 数据的插入与查询
【MySQL进阶之路丨第九篇】一文带你精通MySQL子句 1️⃣MySQL WHERE 子句2️⃣MySQL UPDATE 更新3️MySQL DELETE 语句4️⃣ MySQL LIKE 运算子句5️⃣ MySQL UNION 子句6️⃣总结 1️⃣MySQL WHERE 子句 MySQL 中的 WHERE 子句是用于在查询中筛选数据的部分。它允许您指定条件，以便仅返回满足条件的行。
简单来说， WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。
以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：
SELECT field1, field2,...fieldN FROM table_name1, table_name2... [WHERE condition1 [AND [OR]] condition2..... 下面是一个使用 WHERE 子句的示例：
SELECT * FROM students WHERE age &gt; 10; 上述语句将从名为 students 的表中选择所有年龄大于 10 岁的学生。在这个例子中，age &gt; 10 是 WHERE 子句的条件。只有满足此条件的行才会被返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686bd6ea7bd9f99891ea3a605007a0a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30ad360a056be9bd6d82d4ab6460198/" rel="bookmark">
			【MySQL进阶之路丨第六篇】数据库的创建、选择和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇中我们介绍了 MySQL Workbench 的安装与配置；
基于命令行及可视化工具的使用，能够更好地理解MySQL数据库；这一篇我们使用上面两种方式来帮助读者掌握数据库的创建、删除和选择。
上一篇链接： 【MySQL进阶之路丨第五篇】MySQL Workbench 的安装与配置
【MySQL进阶之路丨第六篇】数据库的创建、选择和删除 1️⃣数据库2️⃣创建数据库命令行创建数据库MySQL Workbench 创建数据库 3️⃣选择数据库命令行选择数据库MySQL Workbench 选择数据库 4️⃣删除数据库命令行删除数据库MySQL Workbench 删除数据库 5️⃣总结 1️⃣数据库 数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。
数据库通常包括多张表，表中包含多个列，每列中又含有很多字段。
假设学校想要维护一份学生信息数据库，以下是一些数据库中可能包含的表格以及它们的字段：
1.学生表（Students）：
学生ID姓名年级性别 2.成绩表（Grades）：
学生ID课程ID成绩 通过将这些信息存储在数据库中，学校可以轻松地进行各种操作，例如：查询某个学生的个人信息；根据课程ID获取课程的详细信息和授课教师；计算每个学生的平均成绩。
例图如下：
学生表（Students）： | 学生ID | 姓名 | 年级 | 性别 | -------------------------------- | 10001 | 张三 | 大一 | 男 | | 10002 | 李四 | 大二 | 女 | | 10003 | 王五 | 大三 | 男 | | 10004 | 赵六 | 大一 | 女 | 成绩表（Grades）： | 学生ID | 课程ID | 成绩 | ---------------------- | 10001 | 001 | 85 | | 10001 | 002 | 92 | | 10002 | 001 | 76 | | 10002 | 003 | 88 | | 10003 | 002 | 90 | | 10003 | 003 | 95 | | 10004 | 001 | 79 | 2️⃣创建数据库 命令行创建数据库 打开命令行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30ad360a056be9bd6d82d4ab6460198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6632567cfd670d564f998bed91d87a16/" rel="bookmark">
			BurpSuite黑客工具手把手教你如何获取免费的X度网盘会员体验?存储不求人!!!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用网盘频繁,但是空间不够怎么办???想起来以前的一个测试,下面为大家大概梳理思路
首先打开神器burpsuite
在三种方式中任意选择一个,第一种方式即可,默认你已经会抓包(已经安装过证书),点击next
随后进入我们的主界面
4.算了,讲一下如何安装证书,使用证书后可以抓取https协议的数据包,和一般的抓包应用相同都需要使用提前安装证书
点击Proxy settings后默认弹出一个窗口,如下所示
并且默认情况下访问浏览器地址栏输入:127.0.0.1:8000能够出现如下页面
点击右上角能够下载CA证书
补充:如何导出电脑中安装的CA证书
在浏览器中点击三个点,选择设置,点击设置
搜索证书并点击管理证书
弹出如下窗口
可以将证书导出,用在手机和电脑日后的联动抓包上
回归正题 假设你的burpsuite已经设置好
敲黑板,重点!!!: 打开一个曾经的可用的X度网盘领取会员体验链接,网上搜索一搜一把(aHR0cHM6Ly9wYW4uYmFpZHUuY29tL2NvbXBvbmVudC92aWV3LzIwMDI=),开启抓包,获取到数据,点击Intruder开始XX,设置4位长数字即可,点击上方Status code将其改为200优先,找到一个正常能打开的,之后可以使用正则等方式进行筛选,剩下的各位师傅们自行研究,感谢浏览
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02789ad077b66f1d34accb09c122d543/" rel="bookmark">
			【Go入门】编程语言比较：Golang VS Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Golang：最佳人工智能语言，性能优于 Python 本节是学习go的引入，为了了解Python与go编程语言间比较。后续会完成相关课程，并分享笔记。 如今，世界各地有数百万用户使用 Golang 作为机器学习和人工智能的编程语言。
最好的人工智能编程语言是 Go，而不是 Python！是的，让我们详细了解这两种语言。
Go 很快就要庆祝它的 11 岁生日了，它于十多年前的 2009 年 11 月推出。借助 Google 的语言，开发人员现在的工作效率更高。这种语言的设计者还致力于轻松学习和易用性，并消除 C++ 等语言的“无关垃圾”。
此外，它还具有编译机器代码的能力，以及垃圾收集的便利性。Go 的未来非常光明。
AI 领域有望取得进展 尽管人工智能在 2020 年加速了发展，但事实证明，它对全球公民、企业和政府来说是一个巨大的挑战。通过抗击新冠肺炎 (Covid-19) 斗争取得的重大进展，我们的经济和社会发生了转变。以下是一些特定行业的进步。
卫生保健 人工智能在医疗保健应用中的应用改变了多个组织。人工智能取得了许多新发现，例如分析患者数据、准确诊断、发现药物、管理药物，甚至安装机器人手术机器。
零售和电子商务 人工智能使零售商能够利用智能算法帮助他们识别与他们的兴趣相关且有帮助的产品，从建立独特的营销模式到吸引大量零售客户，从而为他们的购物者提供更加个性化的体验。
制造业 通过使人类能够向机器人发出指令和方向，工业机器人正在带来一场重大革命。借助人工智能，可以更有效地维护生产机械，及早发现故障，并提高产品质量。
银行和金融 使用人工智能辅助，可以减少计算时间并提供现实世界的建议。除了检测和预防欺诈之外，人工智能的数字智能还通过审查关键数据特征来改善客户体验。
为什么 Golang 机器学习是构建人工智能应用程序的主流 利用人工智能，公司可以根据自己的需求构建各种创新应用程序。然而，网络框架必须补充人工智能。然而，Go 有什么特别之处呢？由于 Go 的快速和可扩展性，基于它构建的应用程序非常受欢迎。这种语言在人工智能开发人员中的流行可以通过以下原因来解释。
由于 Golang 是静态类型和静态编译的，因此很容易识别 Golang 中的问题。此外，由于Go实时编译机器代码，因此编辑和刷新周期相对较快，同时仍然产生高效的机器代码。因此，Golang 机器学习语言被用于许多应用程序。 这使得 Go 成为开发人员的绝佳选择，因为它允许您编写高度并发的网络程序。Go to Learn 的功能并不多。Go 社区日益壮大。底层基础设施包括许多测试功能，可以通过轻松识别和测试模块来实现更好的工程纪律。
Golang 最适合机器学习的原因 Go 最值得注意的好处是它能够在多个平台上运行，这使其成为软件迁移的绝佳语言。此外，Go 编译器强制执行 Go 未使用的变量，并内置了固定格式。
Go 的另一个独特之处是它的原生并发和并行能力。因此，Golang 是编写并发密集型应用程序、网络、大数据等的理想平台。尤其是，Golang 在云兼容性方面非常完美。此外，Golang生态系统随着机器学习的不断发展，使其成为开发者的绝佳选择。此外，Golang 浏览器自动化使其成为开发人员的首选。 您可以从通过多种方式学习如何使用 Go 编程语言开始。它能够构建云原生应用程序并开发快速而优雅的 CLI（命令行界面），以支持 DevOps 和 SRE（站点可靠性工程）、实施数据库和构建网站，非常适合此类项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02789ad077b66f1d34accb09c122d543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0557bba1ad97524abfc7bbb4465abc21/" rel="bookmark">
			Android之 Zxing二维码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 简介
1.1 ZXing
目前Android扫描二维码，条形码主要用google官方的工具Zxing，支持扫码，相册解码，生成带logo的二维码等功能 Zxing github 示例地址：https://github.com/zxing/zxing
1.2 ZBar
由于zxing是基于java编写的，扫码速度和解析上可能没那么快，但大部分场合足够用。也有基于c/c++的库zbar，需要编译通过才能用，下面是官网，有兴趣的可以编译试试：
ZBar官网：http://zbar.sourceforge.net/
ZBar GitHub地址：https://github.com/ZBar/ZBar
1.3 华为ScanKit
目前体验最好的华为统一扫码SDK，基本可以做到秒扫和快速识别，支持多码识别和二维码生成。但该服务必须在华为开发者联盟平台注册应用，配置包名和服务json
https://gitee.com/hms-core/hms-scan-demo华为官方demo示例 gitee地址：https://gitee.com/hms-core/hms-scan-demo
二 Zxing使用
2.1 依赖远程zxing库
dependencies { //zxing的core库 implementation "com.google.zxing:core:3.5.1" //zxing implementation "com.google.zxing:zxing-parent:3.5.1" //zxing implementation 'com.journeyapps:zxing-android-embedded:4.1.0' } 或直接使用下面库，目前识别比较快的Zxing库
implementation 'com.journeyapps:zxing-android-embedded:4.3.0' 2.2 添加权限
&lt;uses-permission android:name="android.permission.CAMERA" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;uses-permission android:name="android.permission.FLASHLIGHT" /&gt; 2.3 调用SDK的扫码页面并返回结果
/** * 跳转到扫码界面扫码 */ private void goScan(){ Intent intent = new Intent(MainActivity.this, CaptureActivity.class); startActivityForResult(intent, REQUEST_CODE_SCAN); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0557bba1ad97524abfc7bbb4465abc21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6d1dd4db725b2c06d54d064f137bf7/" rel="bookmark">
			【用python将文件夹下面的文件夹里面的文件全部提取出来，并且放到一个新的文件夹】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件里面有多个文件，每个文件下面有很多jpg格式的照片，把所有照片提取出来并且放在一个新的文件夹下面。 可以使用Python的os和shutil库来完成这个任务。
比如说：我的faces95文件夹下面有95个文件，每个文件下面有十七到十八个照片不等。
把所有照片提取出来可以用以下python代码：
import os import shutil # 设置原始文件夹和目标文件夹 data_folder = 'C:\\Users\\ljx\\Desktop\\Images' photo_folder = 'C:\\Users\\ljx\\Desktop\\new_images' # 创建目标文件夹 if not os.path.exists(photo_folder): os.makedirs(photo_folder) # 遍历所有文件夹 for root, dirs, files in os.walk(data_folder): for file in files: # 如果文件是jpg文件 if file.endswith('.jpg'): # 构造原始文件路径和目标文件路径 src_path = os.path.join(root, file) dst_path = os.path.join(photo_folder, file) # 复制文件到目标文件夹 shutil.copyfile(src_path, dst_path) 需要修改的地方：
data_folder = ''中的改为自己的需要提取的文件路径
photo_folder = ''中的改为自己的需要放置的文件路径，默认是新建文件，自己新建也可以
# 设置原始文件夹和目标文件夹 data_folder = 'C:\\Users\\ljx\\Desktop\\faces95' photo_folder = 'C:\\Users\\ljx\\Desktop\\new_images' 跑出来的结果在指定的文件路径中查看，比如我的在桌面上，就是
如果文件较大，需要的python运行时间会更长一点，需要耐心等待。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d6d1dd4db725b2c06d54d064f137bf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788dd8f9ee6f8814bf325aab2dcf0284/" rel="bookmark">
			Python subprocess模块执行CMD命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做windows开发时经常会使用到该模块，用于执行控制台命令，获取命令返回值等，一般使用Popen和run即可，其他较为少用，run函数会等命令执行完毕再继续执行下一步，而Popen不会。
官方文档介绍：subprocess --- 子进程管理 — Python 3.12.0 文档
封装如下：
def exec_cmd(cmd: str, shell: bool = False): """执行CMD命令 :param cmd: 命令内容 :param shell: 是否需要启用shell :return: """ try: print(f"[INPUT]: {cmd}") if shell: proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE) out, err = proc.communicate() else: proc = subprocess.run(cmd.split(), capture_output=True, check=True, shell=False) out = proc.stdout # 获取输出时注意编码错误 try: result = out.decode('utf8').strip() except UnicodeError: try: result = out.decode('gbk').strip() except UnicodeError: result = out.decode('ansi').strip() result and print(f"[OUTPUT]: {result}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/788dd8f9ee6f8814bf325aab2dcf0284/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5a1e703835e80681061259ef02e1c2/" rel="bookmark">
			Python自定义装饰器以及while 循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		装饰器可以简化代码，使用起来也很方便，下面给出一个示例：
一、while循环一般写法 一个while循环，通常情况下的写法是while True，但是容易引发无法跳出循环的bug，因此必须设置一个超时时间，更好的写法如下：
def func(): print(f"执行func函数") time.sleep(1) return True import time tout = time.time() + 60 # 设置超时时间60s while time.time() &lt; tout: if func(): break else: time.sleep(1) else: raise TimeoutError print(f"跳出循环") 上述例子中，如果func一直返回False，那么60s以后就会引发Timeout超时错误；直到返回了True，输出：“跳出循环”
二、装饰器实现 利用装饰器简化上述代码，实现在一段时间内循环执行代码，超时引发timeout。关于装饰器的定义以及如何定义简单的装饰器，自行在百度搜索教程。
（1）定义装饰器 这里给出的示例允许传入参数，以及读取被装饰函数的某些参数(result = kwargs.get(end_condition)-读取kwargs里的名为end_condition的参数)
def my_timer(total_time: float, interval: float, end_condition, customize: bool = True): """设计一个计时器装饰器,用于在一定时间内循环执行某个函数 :param total_time: 超时时间 :param interval: 等待间隔 :param end_condition: 结束循环的条件, customize = True :param customize: result是否自定义，False-则获取func的某个参数的值，end_condition需要等于参数的名称 :return: """ def decorator(func): @wraps(func) # 维持原函数的属性与函数名 def wrapper(*args, **kwargs): # args位置参数, kwargs关键字参数 if customize: result = end_condition else: # **获取func的关键字参数(end_condition为参数名称),不允许使用位置参数进行传参** result = kwargs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a5a1e703835e80681061259ef02e1c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f044a839acac0577566b40e98af7a121/" rel="bookmark">
			网工配置命令基础总结（2）----VRRP配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.配置VRRP主备备份
2.配置VRRP负载分担
3.配置VRRP域BFD联动实现快速切换
VRRP
虚拟路由冗余协议 VRRP（Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，将虚拟网关设备的 IP 地址作为用户的默认网关实现与外部网络通信。当网关 设备发生故障时，VRRP 机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。
常用配置命令
1.执行命令 vrrp vrid virtual-router-id virtual-ip virtual-address，接口视图创建 VRRP 备份组并给备份组配置虚拟 IP 地址。
2.执行命令 vrrp vrid virtual-router-id priority priority-value，配置交换机在备
份组中的优先级。 缺省情况下，优先级的取值是100。数值越大，优先级越高，优先级越高，越可能成为master 设备。
3.执行命令 vrrp vrid virtual-router-id preempt-mode timer delay delay-value，
配置备份组中交换机的抢占延迟时间。
4.执行命令 vrrp vrid virtual-router-id track bfd-session { bfd-session-id | session-name bfd-configure-name } [ increased value-increased | reduced value-reduced ]，备设备 Backup 接口视图下，配置 VRRP 与 BFD 联动。
5. 执 行 命 令 vrrp vrid virtual-router-id track interface interface-type interface-number [ increased value-increased | reduced value-reduced ]，配置 VRRP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f044a839acac0577566b40e98af7a121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257a9d721912def1b957b61939d987e6/" rel="bookmark">
			【数据结构】顺序表(SeqList)（增、删、查、改）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、顺序表的概念和结构 1、顺序表的概念： 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。
2、顺序表的结构： （1）静态顺序表：使用定长数组存储元素 缺点：只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致 N 定大了，空间开多了浪费，开少了不够用。
// 顺序表的静态存储 #define N 10 typedef int SLDataType; typedef struct SeqList { SLDataType array[N];// 定长数组 size_t size;// 有效数据个数 }SeqList; （2）动态顺序表：使用动态开辟的数组存储元素 优点：动态顺序表可以根据需要动态的分配空间大小。
// 顺序表的动态存储 typedef int SLDataType; //类型重命名，后续要存储其它类型时方便更改 typedef struct SeqList { SLDataType* a;// 指向动态开辟的数组 size_t size;// 有效数据个数（当前顺序表中已存放的数据个数） size_t capacity;// 容量大小（顺序表总共能够存放的数据个数） }SeqList; 注：size_t 数据类型表示 C 中任何对象所能达到的最大长度，它是无符号整数。 二、动态顺序表的接口实现 1、创建文件 test.c（主函数、测试顺序表各个接口功能）SeqList.c（动态顺序表接口函数的实现）SeqList.h（动态顺序表的类型定义、接口函数声明、引用的头文件） 2、SeqList.h 头文件代码 // SeqList.h #pragma once // 防止头文件被二次引用 #include&lt;stdio.h&gt; #include&lt;assert.h&gt; // assert #include&lt;stdlib.h&gt; // realloc typedef int SLDataType; // 后续要存储其它类型时方便直接更改 // 顺序表的动态存储 typedef struct SeqList { SLDataType* a; // 指向动态开辟的数组 size_t size ; // 有效数据个数 size_t capicity ; // 容量空间的大小 }SeqList; // 基本增删查改接口 // 顺序表初始化 void SeqListInit(SeqList* psl); // 顺序表销毁 void SeqListDestory(SeqList* psl); // 检查空间，如果满了，进行增容 void CheckCapacity(SeqList* psl); // 顺序表尾插 void SeqListPushBack(SeqList* psl, SLDataType x); // 顺序表尾删 void SeqListPopBack(SeqList* psl); // 顺序表头插 void SeqListPushFront(SeqList* psl, SLDataType x); // 顺序表头删 void SeqListPopFront(SeqList* psl); // 顺序表打印 void SeqListPrint(SeqList* psl); // 顺序表查找 int SeqListFind(SeqList* psl, SLDataType x); // 顺序表在pos位置插入x void SeqListInsert(SeqList* psl, size_t pos, SLDataType x); // 顺序表删除pos位置的值 void SeqListErase(SeqList* psl, size_t pos); // 查看顺序表中的有效数据个数 size_t SeqListSize(const SeqList* psl); // 修改指定下标位置的数据 void SeqListAt(SeqList* psl, size_t pos, SLDataType x); 三、在 SeqList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257a9d721912def1b957b61939d987e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd111c912b74bcff76d0ff113c2ea17c/" rel="bookmark">
			pytorch中的归一化函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 PyTorch 的 nn 模块中，有一些常见的归一化函数，用于在深度学习模型中进行数据的标准化和归一化。以下是一些常见的归一化函数：
nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d：
这些函数用于批量归一化 (Batch Normalization) 操作。它们可以应用于一维、二维和三维数据，通常用于卷积神经网络中。批量归一化有助于加速训练过程，提高模型的稳定性。
nn.LayerNorm：
Layer Normalization 是一种归一化方法，通常用于自然语言处理任务中。它对每个样本的每个特征进行归一化，而不是对整个批次进行归一化。nn.LayerNorm可用于一维数据。
nn.InstanceNorm1d, nn.InstanceNorm2d, nn.InstanceNorm3d：
Instance Normalization 也是一种归一化方法，通常用于图像处理任务中。它对每个样本的每个通道进行归一化，而不是对整个批次进行归一化。这些函数分别适用于一维、二维和三维数据。
nn.GroupNorm：
Group Normalization 是一种介于批量归一化和 Instance Normalization 之间的方法。它将通道分成多个组，然后对每个组进行归一化。这个函数可以用于一维、二维和三维数据。
nn.SyncBatchNorm：
SyncBatchNorm 是一种用于分布式训练的归一化方法，它扩展了 Batch Normalization 并支持多 GPU 训练。
这些归一化函数可以根据具体的任务和模型选择使用，以帮助模型更快地收敛，提高训练稳定性，并改善模型的泛化性能。选择哪种归一化方法通常取决于数据的特点和任务的需求。在使用时，可以在 PyTorch 的模型定义中包含这些归一化层，以将它们集成到模型中。
本文主要包括以下内容： 1.归一化函数的函数构成（1）nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d（2）nn.LayerNorm（3）nn.InstanceNorm1d, nn.InstanceNorm2d, nn.InstanceNorm3d（4） nn.GroupNorm（5）nn.SyncBatchNorm 2.归一化函数的用法（1）nn.BatchNorm1d`, `nn.BatchNorm2d`, `nn.BatchNorm3d（2）nn.LayerNorm（3）nn.InstanceNorm1d, nn.InstanceNorm2d, nn.InstanceNorm3d（4）nn.GroupNorm（5）nn.SyncBatchNorm 3.归一化函数在神经网络中的应用示例（1）Batch Normalization (nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d)（2） Layer Normalization (nn.LayerNorm)（3）Instance Normalization (nn.InstanceNorm1d, nn.InstanceNorm2d, nn.InstanceNorm3d) 1.归一化函数的函数构成 PyTorch中的归一化函数都是通过nn模块中的不同类来实现的。这些类都是继承自PyTorch的nn.Module类，它们具有共同的构造函数和一些通用的方法，同时也包括了归一化特定的计算。以下是这些归一化函数的一般函数构成：
（1）nn.BatchNorm1d, nn.BatchNorm2d, nn.BatchNorm3d 构造函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd111c912b74bcff76d0ff113c2ea17c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5770dea4a6545f8745e7a9f463d60933/" rel="bookmark">
			安装docker以及nvidia-container-toolkit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 旧版本的docker不支持GPU, 需要安装nvidia-docker才能运行支持GPU的docker image. 新的docker支持GPU后, nvidia-docker等工具移至nvidia-container-toolkit下面, 只要安装nvidia-container-toolkit和docker就可以使用支持GPU的docker image.
安装docker 参考docker官网安装教程: https://docs.docker.com/engine/install/ubuntu/
具体步骤为:
# Add Docker's official GPG key: sudo apt-get update sudo apt-get install ca-certificates curl gnupg sudo install -m 0755 -d /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg sudo chmod a+r /etc/apt/keyrings/docker.gpg # Add the repository to Apt sources: echo \ "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \ "$(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME")" stable" | \ sudo tee /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5770dea4a6545f8745e7a9f463d60933/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b709535e9cf6820431727639ec57fe/" rel="bookmark">
			Docker Compose Yaml（Yml）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Hub 镜像 一、docker-compose.yaml(yml)模板 Docker Hub mysql 镜像 version: "3.9" # compose版本号 services: db: # 单个服务标识(名字) container_name: mysql # 启动后的容器名称 相当于 --name 指定的名称 image: mysql:8 # 镜像 ports: # 端口映射,前者是宿主机端口，后者是容器端口 - 10000:3306 environment: # 指定启动的环境 MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: realworld #自动创建名为realworld的数据库 # env_file:	# 使用文件进行代替 # - ./mysql.env	# mysql.env文件内容就是MYSQL_ROOT_PASSWORD=root volumes: # 表示目录映射关系（前者是宿主机目录，后者是dockker的db容器内的目录) - ./data:/var/lib/mysql # 容器内的数据持久化到主机当前目录(当前yaml文件所在目录)的data目录下 depends_on: - redis restart: - on-failure # no：是默认的重启策略，在任何情况下都不会重启容器。 # always：容器总是重新启动。 # on-failure：在容器非正常退出时（退出状态非0），才会重启容器。 # unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 command: [ '--character-set-server=utf8', '--collation-server=utf8_unicode_ci' ] healthcheck: # 健康检查 test: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b709535e9cf6820431727639ec57fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29456e41d520436cff8ff2ad6b4841dc/" rel="bookmark">
			进阶JAVA篇- BigDecimal 类的常用API（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
API 1.0 BigDecimal 类说明
1.1 为什么浮点数会计算不精确呢？
1.2 如何创建 BigDecimal 类型的对象
1.2.1具体来介绍三种方式来创建：
1.2.2 结合三种创建方法，一起来分析一下。 1.3 BigDecimal 类中的 valueOf(String str) 方法
1.4 BigDecimal 类中的 add() 方法（加减乘除的操作都是一样的，就不多赘述了）
1.5 BigDecimal 类中的 doubleValue() 方法
API 1.0 BigDecimal 类说明 BigDecimal 类是Java中用于精确表示大数的类，可以进行精确的数值运算。在需要精确计算的场景中，可以使用 BigDecimal 类来避免由于浮点数计算误差导致的计算结果不准确的问题。
1.1 为什么浮点数会计算不精确呢？ 代码如下：
public class Text { public static void main(String[] args) { double data1 = 0.1; double data2 = 0.2; System.out.println(data1+data2); } } 运行代码如下：
结果不是0.3，显然结果跟我们预想的不一样。当然不是所以的浮点数运行出来的结果都是错误的，只是有这一部分是运行出来的结果是错误的，但是这一部分我们作为合格的程序员来说是不能接收的。
浮点数在计算机中的表示方式是通过将数值分为两部分：尾数和指数。尾数用来表示数值的有效位数，而指数用来表示数值的大小范围。然而，由于计算机内存的限制，尾数和指数都只能用有限的位数来表示，这就导致了浮点数的精度有限。
二进制表示：计算机使用二进制来表示浮点数，而大部分十进制数无法精确转换为二进制表示。例如，0.1（十进制）在二进制表示中是一个无限循环的小数0.00011001100110011...，因此在计算机中只能近似表示。
有限的位数：浮点数的尾数和指数都只能用有限的位数来表示，这就导致了浮点数的精度有限。例如，Java中的double类型只能精确表示15位有效数字，超过这个范围的数字会被截断或四舍五入。
浮点数运算误差：在进行浮点数运算时，由于尾数和指数的有限位数表示，计算机无法精确表示所有的运算结果。这就导致了浮点数运算的结果可能存在一定的误差。
舍入误差：在将一个浮点数转换为二进制表示时，可能会存在舍入误差。例如，一个无限循环的小数在转换为二进制表示时会被截断或四舍五入，从而导致精度损失。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29456e41d520436cff8ff2ad6b4841dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e821db1ce9839351ef8868c5cdf0ca8/" rel="bookmark">
			华为交换机(S5735S-L24P4S-A1)交换机开启web管理模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.开启web配置模式
华为交换机(S5735S-L24P4S-A1)该型号交换机默认不开启web管理模式。需要通过Console口配置模式开启web管理模式，方便使用图形化界面升级操作系统
1.进入配置命令模式
Please Press ENTER.
An initial password is required for the first login via the console.
Set a password and keep it safe. Otherwise you will not be able to login via the console.
Please configure the login password (8-16)
Enter Password:admin@huawei.com(交换机默认密码)
Confirm Password:admin@huawei.com(交换机默认密码)
2.开启HTTPS服务
&lt;HUAWEI&gt;sys
Enter system view, return user view with Ctrl+Z.(交换机回显信息)
[HUAWEI]http secure-server enable Info: The HTTP secure server has been already started.(交换机回显信息)
Warning: After configuring the source interface or source address, the listening socket will be created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e821db1ce9839351ef8868c5cdf0ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d102b77af45e2ae9ad276b5b453a7ef1/" rel="bookmark">
			去哪里找JAVA项目练手？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 找Java项目可以去github上找，下面总结了一些github上的Java项目，可以看看~
1、 JavaGuide
Star：135k
JavaGuide指的是一份完整的Java学习指南或学习资料，它提供了Java 编程语言的各个方面的详细介绍和技术指导。JavaGuide通常包含了Java语法、面向对象编程、Java类库、 多线程编程、 网络编程、 数据库连接等方面的内容 github地址：https://github.com/Snailclimb/JavaGuide
在线网址：https://javaguide.cn/
2、react-native
Star：110k
React Native 是 Facebook 开源的一个用于构建跨平台移动应用的框架。它基于 React.js，使用 JavaScript 和 JSX 语法进行开发，可以快速构建高性能、原生用户界面的移动应用 github地址：https://github.com/facebook/react-native
在线网址：https://reactnative.dev
3、java-design-patterns
Star：82.7k
Java 设计模式是使用Java编程语言实现的一套可重复使用的解决方案，用于解决 软件设计中常见的问题和模式。设计模式是一种在特定情景下重复出现的优秀解决方案的描述，其目的是提供一种通用的语言来沟通和理解软件设计，它提供了一种结构和组织代码的方法，使得代码更加灵活、可维护、可重用和可扩展 github地址：https://github.com/iluwatar/java-design-patterns
在线网址：https://java-design-patterns.com
4、LeetCodeAnimation
Star：73.3k
LeetCodeAnimation指的是一种通过动画的形式来演示和解释LeetCode题目的技术或工具。LeetCode作为面向程序员的 在线编程平台，提供了大量的算法题目，帮助程序员提升编程能力和解决问题的能力。而LeetCodeAnimation则是通过动画的方式来展示解题思路，让用户更直观地理解算法和 数据结构的运行过程 github地址：https://github.com/MisterBooo/LeetCodeAnimation
5、advanced-java
Star：70.7k
Advanced Java通常指的是在Java编程语言中使用更高级和更复杂特性的编程技术。它构建在Java的基本语法和特性之上，并引入了更多的概念和工具，使开发人员能够处理更复杂的问题和任务。齐包括许多不同的主题和技术，如多线程编程、网络编程、 数据库编程、GUI编程、分布式计算、反射等。这些特性可以帮助开发人员构建更灵活、高效且功能强大的应用程 github地址：https://github.com/doocs/advanced-java
在线网址：https://doocs.github.io/advanced-java/#/
6、sprint-boot
Star：68.1k
Spring Boot是一个 开源框架，用于简化Spring应用程序的构建和部署。它提供了一种快速开发的方式，让开发者能够更轻松地创建独立、基于Spring的 应用程序 github地址：https://github.com/spring-projects/spring-boot
在线网址：https://spring.io/projects/spring-boot
7、mall
Star：67.3k
mall项目是一套电商系统，包括前台 商城系统及后台管理系统，基于SpringBoot+MyBatis实现，采用Docker容器化部署。 前台商城系统包含首页门户、商品推荐、 商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、 订单管理、 会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、 权限管理、设置等模块 github地址：https://github.com/macrozheng/mall
后台管理系统演示地址：https://www.macrozheng.com/admin/
前台商城系统演示地址：https://www.macrozheng.com/app/#/
8、elasticsearch
Star：64.3k
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d102b77af45e2ae9ad276b5b453a7ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5bfaa1824063b11cc66d0a72a67ad9/" rel="bookmark">
			gradle版本是7.1.3加载arr包踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次尝试： 将arr包放入到libs中， 在build.gradle中添加 implementation(name:'**', ext:'aar')
Make project报错：
Could not find :jdsmart-common-b3593f1-1.2.04:. Required by: project :launcherserver Search in build.gradle files 根据错误提示添加了：
allprojects { repositories { flatDir { dirs 'libs' } } } 继续Make project报错：
完整错误日志：
Build file 'D:\android_project\SKControlSystem\SKControlSystem\launcherserver\build.gradle' line: 46 A problem occurred evaluating project ':launcherserver'. &gt; Build was configured to prefer settings repositories over project repositories but repository 'flatDir' was added by build file 'launcherserver\build.gradle' * Try: Run with --info or --debug option to get more log output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5bfaa1824063b11cc66d0a72a67ad9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1135ce653d7e2a39e3447e2fc95c1259/" rel="bookmark">
			Linux 系统中提供CPU性能分析工具整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 系统中提供CPU性能分析工具整理 汇总 查看CPU信息 在linux操作系统中，CPU的信息在启动的过程中被装载到虚拟目录/proc下的cpuinfo文件中，我们可以通过 cat /proc/cpuinfo 查看一下：
cat /proc/cpuinfo 显示如下：
root@thead-910:~# cat /proc/cpuinfo processor : 0 hart : 0 isa : rv64imafdcsu mmu : sv39 model name : T-HEAD C910 freq : 1.2GHz icache : 64kB dcache : 64kB l2cache : 2MB tlb : 1024 4-ways cache line : 64Bytes address sizes : 40 bits physical, 39 bits virtual vector version : 0.7.1 processor : 1 hart : 1 isa : rv64imafdcsu mmu : sv39 model name : T-HEAD C910 freq : 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1135ce653d7e2a39e3447e2fc95c1259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04aed0baadcb1248d6d1bab5fad8826/" rel="bookmark">
			Python中collections.namedtuple用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		namedtuple可用于创建一个命名元组类
官方文档:collections --- 容器数据类型 — Python 3.12.0 文档
简单示例：
from collections import namedtuple # 创建一个命名元组类 Person = namedtuple('Person', 'name age gender') # 使用 _make() 方法将序列转换为命名元组 person_data = ['John', '25', 'Male'] person = Person._make(person_data) # 输出命名元组的属性值 print(person.name) # John print(person.age) # 25 print(person.gender) # Male 上面提示到_make()方法，该方法用于将一个可迭代对象转换为命名元组，常用于将csv sqlite3模块返回的数据转化为命名元组：
# 创建一个命名元组类 EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, paygrade') import csv # 将获取到的csv数据，转化为命名元组(n个 EmployeeRecord 对象组成) for emp in map(EmployeeRecord._make, csv.reader(open("employees.csv", "rb"))): print(emp.name, emp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04aed0baadcb1248d6d1bab5fad8826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2765f9204246597d31b2eb6e33e633/" rel="bookmark">
			js金额转换单位万元，亿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 export function million(value) { if (!value) return 0; if (typeof value == 'string') { value = Number(value); } let unit = ''; const k = 10000; const sizes = ['', '万元', '亿']; let i; if (value &lt; k) { return value + '元'; } else { i = Math.floor(Math.log(value) / Math.log(k)); // 单位下标 value = value / Math.pow(k, i); value = (parseInt(value * 100) / 100).toFixed(2); unit = sizes[i]; } return value + unit || 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50333916fe505e0174526ca41336c7d/" rel="bookmark">
			Java -多线程深入理解与实现、多线程参数传递、多线程下注入Bean无效，如@Resource和@Autowired和@Value 注入为null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Java 多线程深入理解与创建、多线程参数传递的教程链接：二、问题：Spring项目bean 无法注入问题--Thread中注入Bean无效-多线程下@Resource和@Autowired和@Value 注入为null1、解决方法12、解决方法2 参考链接 一、Java 多线程深入理解与创建、多线程参数传递的教程链接： 1. Java 17 多线程之 Runnable 知识点
2. 【Java】线程基本使用——实现 Runnable接口
3. java多线程（二）实现Runnable接口
4. java让Runnable(传参)接受参数以及自定义方法
5. java中如何给Runnable线程传递参数？
二、问题：Spring项目bean 无法注入问题–Thread中注入Bean无效-多线程下@Resource和@Autowired和@Value 注入为null 1、解决方法1 线程内无法被注入注解方法，除非是传参给多线程，即在线程启动前，在主线程代码下，以参数的形式获取注解值（例如@Resource和@Autowired和@Value等注解方法），然后作为参数传递给子线程们。
// 子线程方法 public class TestThread implements Runnable{ private String data; public TestThread(String data){ this.data = data; } @Override public void run() { System.err.println("传递给子线程的数据：" + data) } } // 父线程 public class Test { @Value("${test.data}") private String data; public String testFunction(){ List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(3); for(int i=0;i&lt;3;i++){ String newData = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50333916fe505e0174526ca41336c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2d62525cc9aa6e27bc073beb2577cd/" rel="bookmark">
			删除表中重复的记录，相同数据只保留其中一条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删除developer_report_detail 表中customer_id、cloud_service_type_code、month重复的记录，只保留其中一条。
DELETE FROM developer_report_detail d WHERE EXISTS ( SELECT 1 FROM ( SELECT customer_id, cloud_service_type_code, `month`, max( id ) AS maxId, COUNT( 1 ) c FROM developer_report_detail GROUP BY customer_id, cloud_service_type_code, `month` HAVING c &gt; 1 ) tmp WHERE d.customer_id = tmp.customer_id AND d.cloud_service_type_code = tmp.cloud_service_type_code AND d.MONTH = tmp.`month` AND d.id != tmp.maxid ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0680c777585bcf4bd7a9cc3aa473257a/" rel="bookmark">
			Java -读写文件（ json） - 无键值，转换JSONArray数组 | 有键值 转换为JSONObject | JSONArray 转换为 List＜JSONObject＞ 集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 注意一、读取文件内容1、无键值JSONArray，转换 json 数组、JSONArray 转换为 List&lt;JSONObject&gt; 集合2、有键值 转换为 JSONObject、JSONArray 转换为 List&lt;JSONObject&gt; 集合 二、写入文件参考链接 注意 当我们在Java中使用FileInputStream来读取文件时，需要注意关闭InputStream的问题。FileInputStream是一种资源，它需要占用系统资源来进行读文件操作。如果在使用完FileInputStream后不进行关闭操作，就会导致系统资源被占用且无法释放，最终影响程序的性能与稳定性。
因此，在使用完FileInputStream后，我们应该调用其close()方法来释放已占用的系统资源，以防止因此导致的各种问题，例如内存泄漏、程序异常终止等。
读取完数据后，就必须关闭，不然不仅浪费资源，也容易导致新建文件后，该文件内容会重复之前的数据（笔者遇到过的奇怪问题，类似缓存问题）。
一、读取文件内容 1、无键值JSONArray，转换 json 数组、JSONArray 转换为 List 集合 测试数据格式：
[ { "owner_ip": 0, "id": 0, "text": "test", "timestamp": "" }, { "owner_ip": 0, "id": 1, "text": "test", "timestamp": "" }, { "owner_ip": 0, "id": 2, "text": "test", "timestamp": "" }, { "owner_ip": 0, "id": 3, "text": "test", "timestamp": "" }, { "owner_ip": 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0680c777585bcf4bd7a9cc3aa473257a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb131205976fe2ca7471171ab25ff6e3/" rel="bookmark">
			2023最流行的 Node.js 框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023最流行的 Node.js 框架 Node.js 是一个开源的服务器端软件框架，可用于创建能够快速响应用户请求的应用程序。因此，它作为加快网站和其他在线服务性能的一种方式在不同行业中变得越来越流行。Node.js 的核心主要用于开发网络应用程序，例如 API、网站爬虫和聊天应用程序。然而，标准包没有预装框架——这对于刚刚开始使用 Node.js 的开发人员来说可能有点棘手。值得庆幸的是，如果我们需要比标准框架更高级的东西，有很多第三方 Node.js 框架可供选择。在这篇博文中，我们将带了解一些当前最流行、可用的Node.js 框架，我们可以根据需求做出明智的决定。
什么是 Node.js 框架？ Node.js框架是可用于构建应用程序和管理代码架构的软件。它就像一组指令，告诉我们的计算机在投入生产时要做什么。虽然有许多不同类型的 Node.js 框架可用，但它们都有一个共同点——它们扩展了 Node.js 的标准功能。它们还可以用于创建高度可扩展和安全的应用程序，其中许多最好的框架都提供缓存、路由和用户身份验证等内置功能。Node.js 用途广泛，可以应用于广泛的用例和行业，包括电子商务、房地产和社交媒体。
为什么使用 Node.js 框架？ 正如我们已经提到的，Node.js 没有预装框架，乍一看，对于初学者来说可能有点难以掌握。幸运的是，有很多第三方框架可以用来让我们自由选择，快速开发，并帮助我们比使用提供的标准工具更有效地构建应用程序。Node.js 框架旨在解决常见的编程问题，并且可以帮助我们避免从头开始构建应用程序时可能会陷入的一些陷阱。它们还可以帮助我们创建更安全的应用程序，其中许多最好的框架提供内置的身份验证、数据验证和缓存功能。
框架： Express.JS Express.JS 是最流行的 Node.js 框架之一。它允许我们创建路由和处理请求，并具有错误处理、请求路由和 URL 结构等内置功能。它是一个非常轻量级的框架，很容易上手——特别是如果我们是初学者。有大量在线教程和指南可以帮助我们完成该过程的各个步骤。完成应用程序后，部署应用程序也非常容易，这意味着它非常适合寻求快速且易于上手的开发人员。还有大量可用的附加模块可用于扩展 Express.JS 的功能。 Meteor.JS Meteor.JS 是一个可扩展的开源框架，旨在构建现代 Web 和移动应用程序。它是可用的较新框架之一，由 Meteor Development Group 于 2011 年开发。Meteor.JS 构建在JavaScript之上，允许我们通过组合代码和数据以及使用发布-订阅模型来构建应用程序。如果我们想要构建跨平台应用程序或者想要创建实时应用程序，Meteor.JS 是一个不错的选择。如果我们是开发新手，并且想要尝试一些比市场上其他框架更具挑战性的东西，那么这也是一个不错的选择。 Koa.js Koa.js 是另一个轻量级框架，通常与 Express 结合使用。它由 Express 背后的团队开发，在设计时就考虑到了性能。Koa.js 使用 ES6 构建并遵循断路器模式的原则。这意味着它既可扩展又可靠。Koa.js 非常适合想要构建能够处理大量流量的高性能应用程序的开发人员。它还带有自己的插件，允许我们推送重要事件，例如登录和用户身份验证。 Adonis.js Adonis.js 是一个非常强大的开源框架，专为 Node.js 开发。它旨在让经验丰富和缺乏经验的开发人员更轻松地开始构建应用程序。Adonis.JS 使用 ES6 (ECMAScript 6) 构建，使其具有高度可扩展性。Adonis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb131205976fe2ca7471171ab25ff6e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/49/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>