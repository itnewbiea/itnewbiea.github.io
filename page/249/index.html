<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83c05b96ed277984c74f498f2ec9c0e/" rel="bookmark">
			poi 读取公式的值出现的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用poi读取excel表里，常常遇到类型是CELL_TYPE_FORMULA的单元格时，通常使用evaluator
Workbook wb = cell.getSheet().getWorkbook(); CreationHelper crateHelper = wb.getCreationHelper(); FormulaEvaluator evaluator = crateHelper.createFormulaEvaluator(); ret = getCellValue(evaluator.evaluateInCell(cell)); 但是，在旧的版本poi中，如果对同一个cell多次使用evaluate方法，会导致cache数组越界，报错如下：
java.lang.ArrayIndexOutOfBoundsException: -2 at org.apache.poi.ss.formula.FormulaCellCacheEntrySet.addInternal(FormulaCellCacheEntrySet.java:83) at org.apache.poi.ss.formula.FormulaCellCacheEntrySet.add(FormulaCellCacheEntrySet.java:72) at org.apache.poi.ss.formula.CellCacheEntry.addConsumingCell(CellCacheEntry.java:85) at org.apache.poi.ss.formula.FormulaCellCacheEntry.changeConsumingCells(FormulaCellCacheEntry.java:80) at org.apache.poi.ss.formula.FormulaCellCacheEntry.setSensitiveInputCells(FormulaCellCacheEntry.java:60) at org.apache.poi.ss.formula.FormulaCellCacheEntry.updateFormulaResult(FormulaCellCacheEntry.java:109) at org.apache.poi.ss.formula.CellEvaluationFrame.updateFormulaResult(CellEvaluationFrame.java:75) at org.apache.poi.ss.formula.EvaluationTracker.updateCacheResult(EvaluationTracker.java:94) at org.apache.poi.ss.formula.WorkbookEvaluator.evaluateAny(WorkbookEvaluator.java:286) at org.apache.poi.ss.formula.WorkbookEvaluator.evaluate(WorkbookEvaluator.java:221) at org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator.evaluateFormulaCellValue(HSSFFormulaEvaluator.java:320) at org.apache.poi.hssf.usermodel.HSSFFormulaEvaluator.evaluate(HSSFFormulaEvaluator.java:182) 源代码中FormulaCellCacheEntrySet.java:83: int startIx = cce.hashCode() % arr.length; for(int i=startIx; i&lt;arr.length; i++) { startIx could be negative hence the ArrayIndexOutOfBoundsException 解决方法是使用evaluate之前调用
HSSFFormulaEvaluator.clearAllCachedResultValues() FormulaEvaluator evaluator = wb.getCreationHelper().createFormulaEvaluator(); XSSFCell formulaCell = row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b83c05b96ed277984c74f498f2ec9c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc543e0374c5f9c81d0a3d66dce4a02c/" rel="bookmark">
			编译安装PHP7及扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编译安装PHP 1. 下载源码包并解压 源码包地址：http://php.net/downloads.php 下载源码包 当前PHP最新本门是7.2.9，下载 php-7.2.9 源码包
wget http://be2.php.net/get/php-7.2.9.tar.gz/from/this/mirror -O php-7.2.9.tar.gz 解压源码包 解压缩
tar zxf php-7.2.9.tar.gz 进入解压缩后的目录，查看解压的文件
[root/usr/local/src/php-7.2.9]# ll 总用量 4.1M -rw-rw-r-- 1 root root 84K 8月 14 14:26 acinclude.m4 -rw-r--r-- 1 root root 309K 8月 14 14:26 aclocal.m4 drwxrwxr-x 2 root root 78 8月 14 14:26 appveyor/ -rw-rw-r-- 1 root root 1.4K 8月 14 14:26 .appveyor.yml drwxrwxr-x 2 root root 4.0K 8月 14 14:26 build/ -rwxrwxr-x 1 root root 772 8月 14 14:26 buildconf* -rw-rw-r-- 1 root root 334 8月 14 14:26 buildconf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc543e0374c5f9c81d0a3d66dce4a02c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9206e982d74362e647e969ff29355a9/" rel="bookmark">
			找到Qt程序长时间运行崩溃原因的方法--Dump（DMP）文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个问题，使用vs+Qt开发应用程序，在本地测试正常，但在别人的机器上（windows平台）运行了一段时间（大概五天）崩溃了。所以这个时候我们应该怎样调试并找到程序崩溃的原因呢？发布的应用程序使用的是release版本。release版本是比较难调试的，因为缺少很多调试信息，在VC/VS中我们可以通过生成DMP + PDB进行源码级定位，使用这种方法，当程序在别人电脑上出现异常或者崩溃的时候，会生成DMP文件，然后把该文件拷贝到自己的开发机器上，配合pdb文件调试就可以找到错误的位置，直接把问题定位到源代码中的位置。
本文参考了其它博主的博客，比如：
《vs2010 利用DMP文件、pdb文件查找release下的异常行号的方法》https://blog.csdn.net/itworld123/article/details/79041500
《让程序在崩溃时体面的退出之Dump文件》https://blog.csdn.net/starlee/article/details/6630816
感谢这两位博主的博客，本文在这两篇博客的基础上将代码作了一点改动，使得vs+Qt开发windows应用程序一样可以使用这种方法进行定位调试。下面以开发环境为win7+vs2015+Qt5.9.0为例，介绍这个方法：
一、代码 使用vs（演示用的是vs2015）创建一个Qt工程，往工程里添加main.cpp、dmp3b.cpp、dmp3b.h三个文件。三个文件的代码分别如下图所示：
main.cpp
#include "dmp3b.h" #include &lt;QtWidgets/QApplication&gt; #include &lt;windows.h&gt; #include &lt;DbgHelp.h&gt; #pragma comment(lib,"Dbghelp.lib") long __stdcall CrashInfocallback(_EXCEPTION_POINTERS *pexcp) { //创建 Dump 文件 HANDLE hDumpFile = ::CreateFile( L"MEMORY.DMP", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ); if (hDumpFile != INVALID_HANDLE_VALUE) { //Dump信息 MINIDUMP_EXCEPTION_INFORMATION dumpInfo; dumpInfo.ExceptionPointers = pexcp; dumpInfo.ThreadId = GetCurrentThreadId(); dumpInfo.ClientPointers = TRUE; //写入Dump文件内容 ::MiniDumpWriteDump( GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpNormal, &amp;dumpInfo, NULL, NULL ); } return 0; } int main(int argc, char *argv[]) { ::SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)CrashInfocallback); QApplication a(argc, argv); DMP3B w; //w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9206e982d74362e647e969ff29355a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc67d0204c935acf567dc4ea482c82d3/" rel="bookmark">
			通道突破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通道突破策略利用价格对通道的突破产生交易信号，以布林带突破策略为例 布林带突破 - 无止盈止损 利用前收盘价格precloseprice对于布林带上边带 upperband 和下边带lowerband突破生成开平仓信号：
precloseprice 上穿 upperband，形成做多信号，买入开仓； precloseprice 下穿 lowerband，形成做空信号，卖出开仓。
************************************ 布林带突破 - 无止盈止损 价格上穿布林上边带，形成做多信号，买入开仓； 价格下穿布林下边带，形成做空信号，卖出开仓； ************************************ import talib import pandas as pd import numpy as np import quartz_futures as qf from quartz_futures.api import *
参数初始化 universe = [‘RB1610’] # 策略证券池 start = pd.datetime(2016, 6, 1) # 回测开始时间 end = pd.datetime(2016, 9, 1) # 回测结束时间 capital_base = 1e4 # 初试可用资金 refresh_rate = 1 # 调仓周期 freq = ‘d’ # 调仓频率：s -&gt; 秒；m-&gt; 分钟；d-&gt; 日；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc67d0204c935acf567dc4ea482c82d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3cc7b375a710dc7fbc123a7c4176cd/" rel="bookmark">
			【SlickGrid】------- SlickGrid改变高度的示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 我遇到过这个问题 ，也是很苦恼 对这个插件不熟悉 ，当在div 设置 固定高度的时候 并不管用 ，就是查不到是哪里的问题 很是茫然。在我查找别的问题时候 突然找到了 解决问题的办法了 很是开森 在这里给大家分享一下（js 代码有执行先后的顺序 可能位置的先后 影响代码 不能够实现你想要的 位置要放对呀）
&lt;div id="grid_1" class="detail-table" style="width:100%;height:300px; "&gt;&lt;/div&gt; &lt;script&gt; var mc_grid_dic = new Array(); var grid_1 = new Slick.Grid("#grid_1", dataview_1, columns_1, options1); mc_grid_dic["grid_1"]=grid_1; &lt;/script&gt; /// html 里面的代码 只是重要的一部分 $("#grid_1").css("height", "472px"); var grid_1 = mc_grid_dic["grid_1"]; grid_1.resizeCanvas(); // 这是 js 文件里面的代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec85ce2f9cc569bb9320ba091a29b14/" rel="bookmark">
			跨期套利
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨期套利组合构建 与跨品种套利不同，跨期套利是对同一市场，同一品种，不同到期月份的合约之间进行套利，这其中涉及到非主力合约的问题。非主力合约成交量比较小，有的甚至低到几十数百手，很容易被几手交易量将价格拉至异常。这种异常实际较难捕捉，只会放大回测结果。我们以沪镍为例，其主力合约主要在1，5，9月交割，其余月份成交量很低。而1月交割合约活跃期为7月至12月，5月交割合约活跃期11月到来年4月，所以在构建1月交割合约和5月交割合约的套利组合时，我们选择11、12月作为套利策略实施的时间进行测试，12月底若有持仓强行平仓。这个时间内，1月交割合约为主力合约，5月交割合约为次主力合约。
镍跨期套利 在套利时，我们需要计算均衡价差，一般来说有两种算法：
模拟交割法：通过模拟交割过程各项费用，来计算套利过程中的各项成本，从而得出均衡价差。优点：容易计算，价差变化下；缺点：实际中价差很少恢复到这一水平 历史滞后均值法：通过历史的价差，选择时间窗口长度，得到均衡价差。优点：容易计算，价差动态；缺点：不能保证样本外价差恢复到这一水平 我们以选定套利组合的开盘价差为对象，使用历史滞后均值法，取N日价差均值为中线，中线加上N日价差M倍均值为上轨，中线减去N日价差M倍均值为下轨来构造布林带通道，当价差突破上轨，做空价差。我们选择1，5，9这三个月份交割合约，滚动的进行测试，其中1-5合约测试的时间为11月和12月，5-9合约测试的时间为3月和4月，9-1合约测试的时间为7月和8月，所以全年有半年时间不进行操作。
相关参数及设定 成交价设置为当日开盘价。这里，考虑到次主力合约成交量可能较少，我们设置为3个滑点。 开仓信号为价差超过上轨或者突破下轨，信号触发当天即按所设定的成交价进行成交。平仓信号达到中线附近或者，所设定的套利期现结束强行平仓。 手续费设为6元一手 回测时间为2015年5月至2017年4月 暂不考虑止损。 universe = ‘NIM0’ # 策略期货合约 start = ‘2015-05-18’ # 回测开始时间 end = ‘2017-04-31’ # 回测结束时间 capital_base = 1000000 # 初试可用资金 refresh_rate = 1 # 调仓周期 freq = ‘d’ # 调仓频率：m-&gt; 分钟；d-&gt; 日 margin_rate = 0.09 commission = {‘NI’: (6, ‘perShare’)} slippage = Slippage(3, ‘perShare’) months = [‘07’, ‘08’, ‘11’, ‘12’, ‘03’, ‘04’]
mid, up, low = [], [], [] def initialize(futures_account): # 初始化虚拟期货账户，一般用于设置计数器，回测辅助变量等。 futures_account.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec85ce2f9cc569bb9320ba091a29b14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1070478e19bbb4c049755a8b557708f/" rel="bookmark">
			上下行波动率因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因子的定义 上下行波动率是历史收益率低于平均收益率的下行波动率比上历史收益率高平均收益率的上行波动率的比率: DUVOLi=log((nu?1)∑d(rit?rl?)2(nd?1)∑u(rit?rl?)2) 其中，nu为大于平均复合收益率的天数，nd为小于平均复合收益率的天数, rit为股票的日收益率，rl?为股票的60日平均收益率。这是一个衡量股价暴跌可能性的指标，学界通常认为DUVOL较高的股票有着更高的暴跌可能，因此也就有着期望更高的风险溢价。
from quartz_extensions import * import numpy as np import pandas as pd
start = ‘2016-01-01’ # 回测起始时间 end = ‘2016-12-01’ # 回测结束时间 benchmark = ‘HS300’ # 策略参考标准 universe = set_universe(‘A’) # 证券池，支持股票和基金 refresh_rate = ‘fri’ # 调仓频率，表示每周五结束之后生成调仓 delay_number = 5 # 信号最大衰减周期 quantile_number = 5 # 分位分组的组数 function_list = [“winsorize”, “neutralize”, “standardize”] # 信号处理函数列表，从前到后进行处理 industry_type = ‘SW1’ # 行业分类类型
自定义因子函数 def foo(data, dependencies=[‘closePrice’], max_window=121): daily_return = data[‘closePrice’]/data[‘closePrice’].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1070478e19bbb4c049755a8b557708f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269accfca2d647277f1a20acdb3b30e0/" rel="bookmark">
			量价因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因子的定义
股票交易中，最显然的指标无非价格和成交量，大多经典的技术指标其实都是围绕着价格和成交量来构建，本文中尝试将这两者结合起来构建量价因子。中短周期上，量价走势分类为量价背离与量价同向，并通过量价相关性来衡量量价走势的背离与同向的程度。因此，量价相关性，也就是本文中的量价因子，可以简单定义为：
一段时间窗口内，股票收盘价与股票日换手率之间的秩相关系数 本文中的量价相关系数计算，采取的时间窗口为15个交易日
from quartz_extensions import * import numpy as np import pandas as pd import scipy.stats as st start = ‘2016-01-01’ # 回测起始时间 end = ‘2016-12-01’ # 回测结束时间 benchmark = ‘HS300’ # 策略参考标准 universe = set_universe(‘A’) # 证券池，支持股票和基金 refresh_rate = ‘fri’ # 调仓频率，表示每周五结束之后生成调仓 delay_number = 5 # 信号最大衰减周期 quantile_number = 5 # 分位分组的组数 function_list = [“winsorize”, “neutralize”, “standardize”] # 信号处理函数列表，从前到后进行处理 industry_type = ‘SW1’ # 行业分类类型 ## 自定义因子函数 def foo(data, dependencies=[‘turnoverVol’, ‘closePrice’], max_window=16): closePrice = data[‘closePrice’][1:] pre_closePrice = data[‘closePrice’][:-1] turnoverVol = data[‘turnoverVol’][1:] univ = closePrice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269accfca2d647277f1a20acdb3b30e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15934da11e7318275dc94829e0719797/" rel="bookmark">
			深度学习与TensorFlow实战（八）卷积神经网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CNN简介：卷积神经网络最初是为了解决图像识别等问题设计的，现在已经不仅仅是图像和视频，也可以用于时间序列信号，比如音频信号、文本数据等。在早期的图像研究中，最大的挑战如何组织特征，因为图像数据不像其他类型的数据那样可以通过人工理解来提取特征。在深度学习出现之前，我们必须借助SIFT，HOG等算法提取具有良好区分性的特征（SIFT等可以参考我的博文OpenCV图像处理），再集合SVM等机器学习算法进行图像识别。SIFT对一定程度的缩放、平移、旋转、视角改变、亮度调整等畸变，都具有不变性，是当时最重要的图像特征提取方法之一。可以说，在之前只能依靠SIFT等特征提取算法才能勉强进行可靠的图像识别。 然而，SIFT这类算法体征提取还是有局限性的，一般错误率在26%以上。CNN提取的特征可以达到更好的效果，同时它不需要将特征提取和分类训练两个过程分开，它在训练时就自动提取了最有效的特征。CNN可以直接使用图像的原始像素作为输入，而不必使用SIFT等算法提取特征，减轻了使用传统算法如SVM时必须要做的大量重复工作。和SIFT的等算法相似，CNN训练的模型同样对缩放、平移、旋转等畸变具有不变性，有很强的泛化性。CNN的最大特点在于卷积的权值共享结构，可以大幅度减少神经网络的参数量，防止过拟合的同时又降低了神经网络的复杂度。
一般的卷积神经网络有多个卷积层构成，每个卷积层中通常会进行如下几个操作。 （1）图像通过多个不同的卷积核的滤波，并加偏置，提取局部特征特征，每一个卷积核会映射出一个新的2D图像。 （2）将前面卷积的滤波器输出结果，进行非线性的激活函数处理，目前最常用的是使用relu函数，而以前sigmoid函数用的比较多。 （3）对激活函数的结果再进行池化操作（即降采样，比如2x2的图片降为1X1的图片），目前一般是使用最大池化，保留最显著特征，提升模型的畸变容忍能力。
全连接NN：每个神经元与前后相邻层的每一个神经元都有连接关系，输入是特征，输出为预测结果。 参数个数：（前层X后层+后层） 一张分辨率仅仅是28X28的黑白图像，就有近40万个待优化参数。现实中高分辨率的色彩图像，像素点更多，且为RGB三通道。 待优化参数过多，容易导致模型过拟合。为避免这种现象，实际应用中不会直接将原始图片输入到全连接网络。 在实际中，会先对原始图像进行特征提取，把提取到的特征喂给全连接网络，再让全连接网络计算该分类结果。 卷积： 卷积是一种有效提取图片特征的方法。一般用一个正方形卷积核，遍历图片上的每一个像素点。图片与卷积核重合区域相对应的每一个像素值乘以卷积核内相对应点的权重，然后求和，再加上偏置后，最后得到输出图片中的每一个像素值。 例如：上面是5x5x1的灰度图片，1表示单通道，5x5表示分辨率，共有5行5列个灰度值。若用一个 3x3x1 的卷积核对此 5x5x1 的灰度图片进行卷积，偏置项 b=1，则求卷积的计算是：
(-1)x1+0x0+1x2+(-1)x5+0x4+1x2+(-1)x3+0x4+1x5+1=1（注意不要忘记加偏置 1）
输出图片边长=（输入图片边长-卷积核长+1）/步长，此图片为：（5-3+1）/1=3，输出图片是3x3的分辨率，用了一个卷积核，输出深度是1，最后输出的是3x3x1的图片。
全0填充Padding 有时会在输入图片周围进行全0填充，这样可以保证输出图片的尺寸和输入图片一致。 例：在前面5x5x1 的图片周围进行全零填充，可使输出图片仍保持 5x5x1 的维度。这个全零填充的过程叫做 padding。
输出数据体的尺寸=（W-F+2P）/S+1 W：输入数据体尺寸， F：卷积层神经元感知域， S：步长， P：0填充的数量
例：输入是 7×7，滤波器是 3×3，步长为 1，填充为 0，那么就能得到一个5 × 5 的输出。如果步长为 2，输出就是 3×3。如果输入量是32x32x3，核是 5x5x3，不用全零填充，输出是（32-5+1）/1=28，如果要让输出量保持在 32x32x3，可以对该层加一个大小为 2 的零填充。可以根据需求计算出需要填充几层零。32=（32-5+2P）/1 +1，计算出 P=2，即需填充 2 层零。 使用padding和不使用padding的输出维度 上一行公式是使用padding的输出图片边长，下一行公式是不使用padding的输出图片边长。公式如果不能整除，需要向上取整。如果用全0填充，也是padding=SAME。如果不用全0填充，也是就padding=VALID。 TensorFlow给出的卷积的函数 1）对输入图片的描述：用 batch 给出一次喂入多少张图片，每张图片的分辨率大小，比如 5 行 5 列，以及这些图片包含几个通道的信息，如果是灰度图则为单通道，参数写 1，如果是彩色图则为红绿蓝三通道，参数写 3。 2）对卷积核的描述：要给出卷积核行列分辨率列分辨率、通道数以及用了几个卷积核。比如上图描述，表示卷积核行列分辨率分别为3 行和 3 列，且是 1 通道的，一共有 16 个这样的卷积核，卷积核的通道数是由输入图片的通道数决定的，卷积核的通道数等于输入图片的通道数，所以卷积核的通道数也是1。一共有 16 个这样的卷积核，说明卷积操作后输出图片的深度是 16，也就是输出为 16 通道。 3）对卷积核滑动步长的描述：上图第二个参数表示横向滑动步长，第三个参数表示纵向滑动步长。第一个1和最后一个1这里是固定的。表示纵向和横向都以1为步长。 4）是否使用padding：用的是VALID。注意这里是以字符串的形式给出VALID。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15934da11e7318275dc94829e0719797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/694869323d8c1865ac541fa59b2e797c/" rel="bookmark">
			iOS三种页面跳转方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 第一种通过给页面设置tag值 // 把tag值为3000的view带到最前面 也就是显示在屏幕上; [self.window bringSubviewToFront:[self.window viewWithTag:3000]]; // 把tag值为2000的view送到最后, 让他下面的view显示 [self.window sendSubviewToBack:[self.window viewWithTag:2000]]; /**************************************华丽分割线********************************************/ // 第二种 模态跳转 - (void)isClick:(UIButton *)button { // 模态跳转 // 1. 创建目标页面的对象 SecondViewController *secVC = [[SecondViewController alloc]init]; // 2. 设置跳转的动画样式 secVC.modalTransitionStyle = 0; // 3. 向目标页面进行跳转 [self presentViewController:secVC animated:YES completion:^{ }]; // 4. 内存管理 [secVC release]; } - (void)isCilck:(UIButton *)button { // 返回前一页面 [self dismissViewControllerAnimated:YES completion:^{ }]; } /**************************************华丽分割线********************************************/ // 第三种 导航控制器跳转 - (void)buttonAction:(UIButton *)button { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/694869323d8c1865ac541fa59b2e797c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1330448c6df8cd583aa7c41b8c2d00ac/" rel="bookmark">
			matlab修改证件照背景颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要用到背景为白色的证件照，可是手头上只有红底的，故用matlab弄了一个改背景颜色的程序，大体上效果还行。注意：matrix为背景区域，不同照片可能要修改一下rgb的范围。
img = imread('a.jpg'); [height,width,a] = size(img); %% 选择相应的颜色背景区域 % matrix = (img(:,:,1)&gt;250) | (img(:,:,2)&gt;=250) | (img(:,:,2)&gt;=190); %选择白色的像素点 % matrix = (img(:,:,1)&lt;=150) &amp; (img(:,:,2)&lt;=200) &amp; (img(:,:,3)&gt;120); %选择蓝色的像素点 matrix = (img(:, :, 1)&gt;=90) &amp; (img(:, :, 2)&lt;=50) &amp; (img(:, :, 3)&lt;=50); % 选择红色像素点 matrix(0.2*height:0.5*height,0.23*width:0.72*width) = 0; %中间人像区域保持不变 se = strel('disk',3); matrix = imclose(matrix,se); %关操作平滑边缘 %% 选择要改变背景的颜色 [a,b] = find(matrix ==1); blue = [67,142,219]; %改成蓝色 red = [255, 0, 0]; %改成红色 white = [255,255,255]; %改成白色 color = white; for i = 1:size(a) img(a(i),b(i),1) = color(1); img(a(i),b(i),2) = color(2); img(a(i),b(i),3) = color(3); end %% 平滑处理 g1=medfilt2(img(:,:,1));%红 g2=medfilt2(img(:,:,2));%绿 g3=medfilt2(img(:,:,3));%蓝 img1(:,:,1) = g1; img1(:,:,2) = g2; img1(:,:,3) = g3; imshow(img1); imwrite(img1,'b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1330448c6df8cd583aa7c41b8c2d00ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b165bd3a48953e825d5f0b0e0cc5b9/" rel="bookmark">
			vue采坑记之echarts动态数据刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求是数据发生变化echarts会立即刷新，我将data设置未动态的
请求数据成功之后，将数据插入到investmentnum里面，但是后来发现数据虽然插入成功，但是echarts图却没有变化，所以我猜想是echarts没有刷新
接下来进行填坑
用watch 监听data的变化，数据发生变化时重新初始化echarts图
watch: { //观察data的变化 investmentnum: { handler (newVal, oldVal) { if (this.chart) { for (let i = 0; i &lt; this.investmentnum.length; i++) { if (oldVal[i] != newVal[i]) { this.option = { //echarts tooltip: { trigger: 'item', formatter: '{a} &lt;br/&gt;{b} : {c}' }, legend: { right: 'right', // data: ['金额'], data: [{name:'金额',textStyle:{color:'#4a78e8'}} ] }, xAxis: { type: 'category', name: 'x', splitLine: {show: false}, data : this.weektime, //设置坐标轴字体颜色 axisLine: { lineStyle: { color: '#4a78e8', width: 1,//这里是为了突出显示加上的 }} }, grid: { left: '1%', right: '1%', bottom: '3%', containLabel: true }, yAxis: { type: 'value', name: ' 金额 (万元)', splitLine: { lineStyle: { // 使用深浅的间隔色 color: ['#60bee9'] } }, nameTextStyle: { color: ['#4a78e8'] }, axisLine: { lineStyle: { color: '#4a78e8', width: 1,//这里是为了突出显示加上的 } }, axisLabel: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2b165bd3a48953e825d5f0b0e0cc5b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c991ced8c6084a6fc76ca6a77fe41817/" rel="bookmark">
			理解vue之element-ui中的 &lt;template slot-scope=&#34;scope&#34;&gt;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果有用过element-ui中的table组件，可能会发现有这么一个写法：
&lt;template slot-scope="scope"&gt;
在实际的使用过程中，这种用法当然不仅仅局限于此，其他的地方也会用到。到底这里有什么特别之处呢？
我们看看普通的table用法：
我们先说一说这个基础的用法里面，在el-table中，:data="tableData"是数据集，结构如下：
那么对于每一个el-table-column，我们只需要使用prop="date"，就可以将该列的数据绑定为该数组所有的对象中的“date”属性，我们可以理解为对于tableData，这里始终取的是tableData[$index].date。
table按照tableData这个数组的长度来生成多少行，按照有多少个el-table-column来生成多少列。
现在我们可以看更高级的用法，也就是我们标题提到的&lt;template slot-scope="scope"&gt;
&lt;el-table-column label="日期" width="180"&gt; &lt;template slot-scope="scope"&gt; &lt;i class="el-icon-time"&gt;&lt;/i&gt; &lt;span style="margin-left: 10px"&gt;{{ scope.row.date }}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; 按照我们前面的理解，按照有多少个el-table-column来生成列，因此这里没有使用prop="date"，生成的单元格也就是空白的一个单元格。
template（模版） 在这里属于一个固定用法： &lt;template slot-scope="scope"&gt;
我们主要说一下这个scope是个什么东西，按照element上的提示：
通过 Scoped slot 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据
我们可以理解为：tableData是给到table的记录集，scope是table内部基于tableData生成出来的，我们可以用Excel描绘一下
我们传进去的tableData，在table内部生成了类似于Excel的scope，因此，通过scope.row.date，我们就可以读取到每一行中的date。
还有重要的一点，scope又并非是整个table，我们只是能通过scope.row获得当前的行数据，至于具体为什么，目前我还没有理解得很透彻。只是希望按照这个理解，能记住多点关于scope的使用。
本文纯属个人的理解，如有不当的地方敬请指点！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93ad94beddbfd8017caf9167bb29896/" rel="bookmark">
			如何成功import cv2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用如下命令安装：
#pip3 install opencv-python --proxy 192.168.10.xxx:xxxx
注意：
1、记住是opencv-python
2、python3版本以上需要使用pip3
3、这里因为我所在局域网的DNS设置问题，必须要加代理服务器"--proxy"才能使用pip联网下载
若遇到以下问题，说明缺少相关依赖
然后使用如下命令安装依赖包：
# apt-get install libglib2.0-0
# apt update &amp;&amp; apt install -y libsm6 libxext6
# apt-get install libxrender1
我基本就是遇到这些问题，装完依赖之后就可以使用import cv2了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6f2ba7bb4c3eb7488f68a9f832e0e4/" rel="bookmark">
			乔尔·格林布拉特的神奇公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2005年，格林布拉特将自己长达20年的投资经验浓缩成一本仅有150页的小书——《股市稳赚》（The Little Book That Beats The Market），他创造的这一投资方法因此广为流传，并被称为“神奇公式”。 格林布拉特的投资理念来源于价值投资，他要做的就是找到物美价廉的公司，尤其是在市场出现特殊情况的背景下低价买入拥有好业务的公司。价廉物美简单说就是一方面寻找好的业务，另一方，面寻找便宜的股票。在《股市稳赚》中，格林布拉特指出：好的业务是指有形资本回报率高的公司，而便宜的股票则是指净收益率高的股票。乔尔·格林布拉特认为，好企业就是资本回报率高(ROIC)的企业，便宜也就是低估值，可以用PE、PB、EBIT/EV等来衡量。 神奇公式筛选股票函数实现
排除不适合ROIC衡量的企业，例如银行等。 将股票以ROIC与EP排序，再将ROIC和EP的序数相加。 最后得到序数之和选取最大的30只股票。 import numpy as np import pandas as pd import datetime def MagicFormulaSelect(universe,date):
""" 给定股票列表和日期，返回神奇公式评分最高的股票的30只股票 Args: universe (list of str): 股票列表（有后缀） date (str or datetime): 常见日期格式支持 Returns: list: 神奇公式评分最高的股票的30只股票 Examples: &gt;&gt; universe = set_universe('HS300') &gt;&gt; buy_list = MagicFormulaSelect(universe,'20160909') """ trade_date = date if isinstance(date,datetime.datetime) else parse(date) trade_date = trade_date.strftime('%Y%m%d') df_roic = DataAPI.MktStockFactorsOneDayProGet(tradeDate=trade_date,secID=universe, ticker=u"",field=u"secID,tradeDate,ROIC",pandas="1") df_roic = df_roic.dropna() df_roic = df_roic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b6f2ba7bb4c3eb7488f68a9f832e0e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35c452c144f126d9aca4cb2254b1a86/" rel="bookmark">
			LeetCode: 26. 删除排序数组中的重复项（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为： 你不需要考虑数组中超出新长度后面的元素。 示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2，3，4。 你不需要考虑数组中超出新长度后面的元素。 解答：
要求O(1)空间，hash表是不要指望了；由于数组是排好序的，如果出现重复元素的话，不需要把这个元素删了，只需要用后面的元素把它覆盖就好了。
可以用两个指针front和back来实现：
如果back与front正好重复了，拉动front，直到back和front不重复为止；
反之，进行覆盖操作（back + 1就正好是要覆盖的位置）
class Solution { public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int back = 0; for (int front = 1; front &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f35c452c144f126d9aca4cb2254b1a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00883391aede09e83c09f346e387e335/" rel="bookmark">
			配置pod与容器--将内存资源分配给容器和Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文介绍如何为容器分配内存请求和内存限制。保证容器具有其请求的内存量，但不允许使用比其限制更多的内存。
第一步：创建命名空间
在本例中创建命名空间，与集群中其余的资源部分隔离
kubectl create namespace mem-example 第二步：指定内存请求和内存限制
要为容器指定内存请求，在容器的资源清单中包含字段：resources:requests;
指定容器的内存限制，为：resources：limits
下列代码：创建一个内存请求为100MB，内存限制为200MB的memory-request.yaml 的pod文件：
apiVersion: v1 kind: Pod metadata: name: memory-demo namespace: mem-example spec: containers: - name: memory-demo-ctr image: bxhdocker/nginx:v1.0 resources: limits: memory: "200Mi" requests: memory: "100Mi" 创建pod：
kubectl create -f memory-request.yaml --namespace=mem-example 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5025f1902b6c1dad66c931b4d9ad8105/" rel="bookmark">
			vue 中 canvas 和svg合用制作地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="contents"&gt; &lt;div class="lefttop1-title"&gt;区域&lt;/div&gt; &lt;img id="police" src="../assets/police.svg" style="display:none;" width="395px" height="343px"&gt; &lt;div id="contentMap" style="width: 100%;height: 95%;"&gt; &lt;canvas id="areaCanvas" width="395px" height="343px" style="width:90%;height:90%;margin-left:20px;"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //vue中点在不规则图形中的判断 var inside = require( 'point-in-polygon' ); import {generatePolygon} from '../api/index.js' export default { data () { return { collectionArr: [], } }, mounted () { // 地图坐标 generatePolygon().then(response =&gt; { this.collectionArr = response.data; this.drawPolygons(); }); }, methods: { //	地图 drawPolygons: function () { var canvas = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5025f1902b6c1dad66c931b4d9ad8105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932503fd56392b5367316be8c0ed40a9/" rel="bookmark">
			mysql查询某一个或几个字段重复值是哪个，重复几条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select 列名1，count（1） as count from 表名
group by 列名1
having count&gt;1 and 其他条件
select 列名1，列名2，count（1） as count from 表名
group by 列名1，列名2 having count&gt;1 and 其他条件
原理：先按照要查询出现重复数据的列，进行分组查询。count&gt;1代表出现2次或2次以上。
示例：
/*查询重复数据*/ select serialnum,cdate,count(*) as count from m_8_customer_temp_20180820bak group by serialnum,cdate having count&gt;1 and cdate&gt;='2018-08-20 00:00:00'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b44a63a8494fe7a1db60fe0b3fdbd307/" rel="bookmark">
			turtle库的使用(笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、turtle的绘图窗体
turtle.setup（width，height，startx，starty）
-setup()设置窗体大小和位置
-4个参数中后两个可选
一二两个参数是指窗口的长度与宽度
startx指窗体的左上角的位置的坐标。
turtle.setup(800, 800, 0, 0)
如果没有后面两个参数，系统会默认在程序的正中心。
2、turtle的空间坐标体系
-绝对坐标
窗口的正中心（0，0）
turtle.goto(x, y)
让在任何位置的海龟，无论它在哪里，去到达某一个坐标位置。
turtle.fk(d)
往海龟的正前方向运行。
turtle.bk(d)
往海龟的反方向运行。
turtle.circle(r, angle)
以海龟当前位置左侧的某一个点为圆心进行曲线运行。
3.turtle角度坐标体系
- seth()改变海龟行进方向
- seth()只改变方向但不行进 - angle为绝对度数
left（）和right（）是让海龟向左或向右改变运行方向
实例（一）
import turtle turtle.left(45) turtle.fd(150) turtle.right(135) turtle.fd(300) turtle.left(135) turtle.fd(150) 4、RGB色彩体系
- RGB指红蓝绿三个通道的颜色组合
- 覆盖视力所能感知的所有颜色
- RGB每色取值范围0-255整数或0-1小数
turtle.colormode(mode)
- 1.0: RGB小数值模式
- 255：RGB整数值模式
使用import保留字对turtle库的引用有如下三种方式
from&lt;库名&gt;import&lt;函数名&gt;
from&lt;库名&gt;import *
调用函数不需要&lt;库名&gt;，直接使用&lt;函数名&gt;
import turtle as t,则对turtle库中函数调用采用更简洁的t.&lt;函数名&gt;()形式，保留字as的作用是将turtle库给予别名t。
5、画笔状态函数 函数
描述
pendown()
放下画笔
penup()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b44a63a8494fe7a1db60fe0b3fdbd307/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eaf0484440083481ef6c1d06df12747/" rel="bookmark">
			操作系统：进程地址空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统在管理内存时，每个进程都有一个独立的进程地址空间，进程地址空间的地址为虚拟地址，对于32位操作系统，该虚拟地址空间为2^32=4GB。其中0-3G是用户空间，3G-4G是内核空间。但4G的地址空间是不存在的，也就是我们所说的虚拟内存空间。进程在执行的时候，看到和使用的内存地址都是虚拟地址。
操作系统通过MMU部件将进程使用的虚拟地址转换为物理地址。进程使用虚拟内存中的地址，由操作系统协助相关硬件，把它“转换”成真正的物理地址。虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。 地址空间是一个非负整数地址的有序集合。｛0， 1， 2，……｝ 如果地址空间中的整数是连续的，那么我们说他是一个线性地址空间。在一个带虚拟内存的系统中，CPU从一个有N = 2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间。 一个系统还有一个物理地址空间，对应于系统中物理内存的M个字节。 地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。
虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。 VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为P=2^pz字节。类似的，物理内存被分割为物理页，大小也为P字节（物理页也被称为页帧）。 关于堆和栈
1） 数据结构的栈和堆
首先在数据结构上要知道堆栈，虽然我们这么称呼它，但实际上堆栈是两种数据结构：堆和栈。
堆和栈都是一种数据项按序排列的数据结构。
栈就像装数据的桶或箱子，堆像一棵倒过来的树 从栈说起，它是一种具有后进先出性质的数据结构，也就是说后存放的先取。先存放的后取。 而堆就不同了。堆是一种经过排序的树形数据结构。每一个结点都有一个值。
通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大）。且根结点的两个子树也是一个堆。因为堆的这个特性，经常使用来实现优先队列，堆的存取是随意。
2） 内存分配中的栈和堆 内存中的栈区处于相对较高的地址以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间。堆区是向上增长的用于分配程序猿申请的内存空间。另外还有静态 区是分配静态变量，全局变量空间的；仅仅读区是分配常量和程序代码空间的；以及其它一些分区。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3b9c9fdd8e88eff41f4a5d0df5ed80/" rel="bookmark">
			Selenium启动Firefox示例(python版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前做selenium自动化使用的主流语言分为java和python，前一篇为java版，本篇介绍python实现selenium启动Firefox。
1 #-*- coding:utf-8 -*- 2 3 from selenium import webdriver 4 from selenium.common.exceptions import NoSuchElementException, TimeoutException 5 from selenium.webdriver.remote.webelement import WebElement 6 from selenium.webdriver.support.ui import WebDriverWait # available since 7 from selenium.webdriver.common.keys import Keys 8 9 from time import sleep 10 import os, time 11 12 # driver = webdriver.Chrome("D:\Downloads\chromedriver.exe") 13 driver = webdriver.Firefox() 14 print u"加载驱动完成.." 15 driver.get("https://ww.baidu.com") # 加载页面 16 print u"加载页面完成.." 17 18 sleep(1) 19 20 try: 21 assert u"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed3b9c9fdd8e88eff41f4a5d0df5ed80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0811a65ad7b23487c0acb00dae5cbd5/" rel="bookmark">
			String index out of range: 100 报错详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个很奇葩的报错，出错情况：
在这里进行debug之后可以看到，异常在substring中：
也就是判断字符串的时候报错：具体原因就是string字符串indexof的值本身只有5，然后在这里去取其第100 个字符作为截止，因此就会报这个错；
知识点：主要是堆String概念不清。下面针对字符串相关概念（String、char、char[]）做一个简介。
针对上述问题解决办法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70058b0ba3e64813da6ba85f1afd50bc/" rel="bookmark">
			使用OpenCV通过摄像头捕获实时视频并探测人脸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Opencv初接触，图片的基本操作这篇手记中，我介绍了一些图片的基本操作，视频可以看作是一帧一帧的图片，因此图片操作其实是视频操作的基础，这篇手记就来讲讲OpenCV中的视频操作，并实现一个用笔记本自带的摄像头探测人脸的小功能，最后会把人脸提取出来并保存，作为后续用卷积神经网络进行人脸识别的训练数据。
本地视频读取
OpenCV中是通过创建一个VideoCapture对象来捕获视频，这里先以读取和播放本地视频为例：
import cv2 cap = cv2.VideoCapture('clementi sonatina in f major, op. 36 no. 4.mp4') # 注意这里视频放在当前工作目录下，VideoCapture的参数就是视频文件名 while(cap.isOpened()): # isOpened方法判断视频是否成功打开 ret, frame = cap.read() # read方法返回一个表示视频是否正确读取的布尔值和一帧图像 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 这里用cvtColor（cvt就是convert的缩写）方法进行色彩空间的转换，这里是从BGR空间转换到灰度空间 cv2.imshow('frame', gray) # 通过imshow显示一帧图像 if cv2.waitKey(1) &amp; 0xFF == ord('q'): # 一帧显示一毫秒，通过上面的while循环不断地显示下一帧，从而形成动态的视频；按q键退出循环，关闭视频。 break cap.release() cv2.destroyAllWindows() 通过笔记本摄像头捕获实时视频流
通过上面读取本地视频的代码，可以理解OpenCV中显示视频的原理就是通过循环不断显示下一帧图像从而得到动态的视频，下面，只需改变VideoCapture的参数就可以捕获笔记本电脑摄像头的实时视频流：
import cv2 #引入cv2，也就是引入opencv的一些包和处理类，不然下面的一些操作都无法完成 #打开摄像头的方法，window_name为显示窗口名，video_id为你设备摄像头的id，默认为0或-1，如果引用usb可能会改变为1，等 def openvideo(window_name ,video_id): cv2.namedWindow(window_name) # 创建一个窗口 cap=cv2.VideoCapture(video_id) # 获取摄像头 while cap.isOpened(): ok,frame=cap.read() # ok表示摄像头读取状态，frame表示摄像头读取的图像 if not ok : break cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70058b0ba3e64813da6ba85f1afd50bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0478f16cea93bfa94e364e2cffaaa4ff/" rel="bookmark">
			The slave I/O thread stops because master and slave have equal MySQL server UUIDs;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在部署MySQL主从复制架构的时候，碰到了"Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work." 这个错误提示。即主从架构中使用了相同的UUID。检查server_id系统变量，已经是不同的设置，那原因是？接下来为具体描述。
1、错误消息
mysql&gt; show slave staus;
Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.
2、查看主从的server_id变量
master_mysql&gt; show variables like 'server_id';
+---------------+-------+
| Variable_name | Value |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0478f16cea93bfa94e364e2cffaaa4ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48182768a136b568becb26ee9ac4234/" rel="bookmark">
			element-ui 动态表头渲染表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ElementUI官方文档中，描述的动态渲染只是单纯的将已知字段名称的JSON数据通过prop属性填充到页面中，下为官方文档内容
&lt;template&gt; &lt;el-table :data="tableData" style="width: 100%"&gt; &lt;el-table-column prop="date" label="日期" width="180"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }] } } } &lt;/script&gt; 其中，表格的key值都是固定的。但是针对key值不固定的json数据的渲染，官方文档并未给出明确信息。最近在写项目的时候涉及到的一项需求就是把后台请求到的json数据渲染到页面，但key值并不固定，导致不能按照官方文档提出的方式进行直接渲染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48182768a136b568becb26ee9ac4234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff36b6e2d2df7b1451ab75e725c630c0/" rel="bookmark">
			Tensorflow拟合函数：y=2x&#43;3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文代码在jupyter上实现 拟合一个一元一次函数：y=2x+3，具体要求如下： 1、使用Tensorflow框架 2、利用迭代方法，优化器不限 3、给出拟合的参数值 4、把拟合过程可视化
1.导入模块 import tensorflow as tf import numpy as np import matplotlib.pyplot as plt %matplotlib inline #实现在线画图 2.可视化构造数据 #构造训练数据 x_data=np.random.rand(1000).astype(np.float) #随机生成100个类型为float32的值 y_data=x_data*2+np.random.randn(*x_data.shape)*0.5+3 #定义方程式y=x_data*W+b #可视化 plt.figure() plt.scatter(x_data,y_data) plt.plot(x_data,3+2*x_data,'r') 3.构造损失函数 # 定义权重和偏置项 w = tf.Variable(1.0,name="w") b = tf.Variable(0.2,name="b") y = w*x_data+b # 计算损失函数定义（均方差） loss = tf.reduce_mean(tf.square(y-y_data)) 4.开始训练 # 设定学习速率为0.01，目的是减少loss到最小 train_step = tf.train.GradientDescentOptimizer(0.01).minimize(loss) sess=tf.Session() sess.run(tf.global_variables_initializer()) #迭代1000次 for i in range(10000): sess.run(train_step) if i % 500 == 0 or i+1==10000: plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff36b6e2d2df7b1451ab75e725c630c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220cdececcb7f1435ccf94b999e9f504/" rel="bookmark">
			WPF-3D动效-文字球形环绕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		费劲写了一个动效，却要被砍掉，心碎....
private List&lt;Point3D&gt; GetBuckyBallPoints() { List&lt;Point3D&gt; ltPoints = new List&lt;Point3D&gt;(); ltPoints.Add(new Point3D(.850651, 0, 2.327438)); ltPoints.Add(new Point3D(.262866, .809017, 2.327438)); ltPoints.Add(new Point3D(-.688191, .5, 2.327438)); ltPoints.Add(new Point3D(-.688191, -.5, 2.327438)); ltPoints.Add(new Point3D(.262866, -.809017, 2.327438)); ltPoints.Add(new Point3D(1.701301, 0, 1.801708)); ltPoints.Add(new Point3D(.52573, 1.618035, 1.801708)); ltPoints.Add(new Point3D(.52573, -1.618035, 1.801708)); ltPoints.Add(new Point3D(-1.376383, -.999999, 1.801708)); ltPoints.Add(new Point3D(-1.376383, .999999, 1.801708)); ltPoints.Add(new Point3D(1.964166, .809017, 1.275977)); ltPoints.Add(new Point3D(1.376381, 1.618035, 1.275977)); ltPoints.Add(new Point3D(-.162461, 2.118035, 1.275977)); ltPoints.Add(new Point3D(-1.113517, 1.809017, 1.275977)); ltPoints.Add(new Point3D(-2.064574, .5, 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/220cdececcb7f1435ccf94b999e9f504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdbb3aa1eff42e509f0aeeedfaeea1fe/" rel="bookmark">
			用xcode管理git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用码云平台托管
1.新建工程-不要勾选git
2.将代码上传到码云远程仓库按https://blog.csdn.net/denggun12345/article/details/81630547操作。
3.打开工程，左边第二栏，可以看到git管理情况。
4.修改文件，添加内容：@"master第一次修改";修改后未提交的文件后边都会有M提示
5.修改后未提交的文件后边都会有M，即使是该文件所在的文件夹合上，M也会在其所在上层文件夹上显示（每天下班，哪些文件没有提交，一目了然）
6.下边来创建分支，选中master所在行，右键，从master分支创建分支
7.命名为one
8.刚创建的分支默认为当前的分支，相当于 git checkout -b one命令
9.将修改提交到远程仓库：
source control -&gt;commit
10.写注释，如果选上push对勾，则commit到本地仓库的同时，提交到远程仓库，因为current是one分支，故默认提交到one分支
11.当然也可以切换到其他分支，选中某分支所在行-选checkout
12.按上述步骤在one分支上再拉出一只分支，名曰one-one，修改代码，并提交到one-one分支
13.
14.选中左边的Branches或Remotes文件夹我们可以看到每个分支的提交记录，也可以根据每个分支的提交记录，了解各个分支之间的关系
15.双击每一条提交记录（下图蓝色区域），可以对比两次提交的代码的差异
16.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e9ab9f5c0fb05fefeb8793bec8c169/" rel="bookmark">
			FluentFTP对FtpHelper操作类封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github：https://github.com/robinrodricks/FluentFTP
using FluentFTP; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.IO; namespace imgmig { public class FtpFileMetadata { public long FileLength { get; set; } public string MD5Hash { get; set; } public DateTime LastModifyTime { get; set; } } public class FtpHelper { private FtpClient _client = null; private string _host = "127.0.0.1"; private int _port = 21; private string _username = "Anonymous"; private string _password = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e9ab9f5c0fb05fefeb8793bec8c169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a105e445a6060ef2209487ac003ae44d/" rel="bookmark">
			模型优化策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型优化策略 参考：http://nsaphra.github.io/post/model-scheduling
模型可以通过在训练过程中修改它们的超参数来逐步迭代。这在迁移学习设置中是最常见的，其中，我们为一个新的领域或任务寻求适应现有模型中的知识。持续学习的更普遍的问题也是一个明显的应用。然而，即使使用预定义的数据集，迭代地约束网络的拓扑结构也可以提供像正则化那样的好处。
动态超参数 ## 最容易增量训练的模型可能是在每个迭代周期中更新超参数的模型。在这里，我们并不是指的是那些与网络拓扑相关的超参数，例如层的数量或尺寸。在训练过程中有许多机会来调整拓扑结构，但是模型通常需要重度的重新训练，以便再次实施构建合理的结构，就如我们在内存网络这个案例中清楚阐述的那样。如果我们专注于与正则化和阈值相关的权重，我们可以逐渐地学习结构，而不需要频繁的重新训练来适应根本改变的拓扑结构。 中途Dropout Hinton等人描述了通过特征检测器防止完全过拟合数据的的互适应来完美的拟合数据。在这种解释中，互适应的神经元簇同时激活。随机地抑制这些神经元迫使它们发展各自的独立性。 在标准dropout机制中，这些互适应神经元在所有的训练阶段被视为具有同样有问题。然而，莫雷里奥等人认为，在训练早期，互适应可以代表网络的最佳自组织的开始。在这种观点下，这些结构主要是在训练后期造成过度拟合的威胁。因此，作者为dropout rate引入了一个超参数计划表，随着持续的训练，增加dropout rate。据我所知，这是唯一公布的自适应正则化的建议。 缓和网络（Mollifying network） ### 据我所知，缓和网络，是唯一的尝试是将专注于增量操作数据分布的技术与专注于增量操纵模型的表示性能力的技术相结合的方法。Mollifying网络通过模拟退火逐步降低数据的维度，同时修改各种超参数以允许更长的距离依赖性。在LSTM的情况下，它们将输出门设置为1，输入门为 1/t，遗忘门为1-1/t，其中t是退火时间步长。使用该系统，LSTM最初表现为一个字袋模型，逐渐增加了在每个时间步长上处理更多上下文的能力。 缓和网络对每个层使用不同的数据维度，在较低层中可以比在更高层中更快地消除噪音，因为假设低层表示学习更快。 自适应体系结构 在训练过程中最难修改的超参数可能是那些命令模型体系本身拓扑结构的参数。然而，深度学习文献包含了在训练过程中适应模型架构的技术的悠久历史，通常响应于所学的参数。像这样的方法可以通过在训练开始时通过平滑函数来优化搜索，通过简单的模型加速学习，或者压缩模型以方便地安装在电话或嵌入式设备上。这些方法中的大多数可以被分类为增长模型和缩减模型，分别通过在中间训练时增加参数或通过修剪边或节点来达到。 架构增长 ### 一些最近的迁移学习策略依赖于不断增长的架构，整个新模块上集中在通过创建与现有网络连接的新任务。如果目标是通过增加少量的参数来增加现有的网络，则问题与传统的非参数学习相似，因为我们不需要首先明确地限制模型空间。 神经网络中的经典技术，如级联相关网络和动态节点创建新节点，逐个随机地进行训练。在现代大型架构和问题上，这是棘手的。此外，这些方法的主要优点是，他们接近最小模型，这是一个目标，现代深度学习从业者不再认为这是有价值的，因为几十年来计算能力的飞跃。成长网络的现代技术必须做出2个决定：1）何时（以及在何处）添加新参数？2）如何训练新的参数？ Wald-Falle 等人在训练整个网络之后在批量中添加参数。增强采用并行添加到现有网络的专用辅助层的形式。这些层被训练在原始通用模型所挣扎的类边界上。需要特别注意的类边界通过在保留数据集的混淆矩阵上执行谱聚类来选择，将类划分成具有挑战性的子问题。 辅助层随机地与原始通用系统并行初始化，然后每个训练层只从它们分配的类划分的例子中进行训练。原来的通用网络是固定的，而不是微调最终分类层。所得到的网络是专家的混合，是用来表明改进图像分类问题的结果。 神经深度学习（NDL），同时，使自动编码器能够长生命周期学习。该策略在模型遇到异常情况时，通过添加神经元来更新自动编码器的拓扑结构。这些新的参数只训练在那些离群值上，允许现有的解码器参数以更小的步长更新。现有的编码器参数只有当它们直接连接到新神经元时才更新。 在引入和训练这些新神经元之后，NDL使用作者称之为“内在重放”的方法稳定网络的现有结构。他们重建先前看到的样本的近似值，并对这些重建样本进行训练。 另一个允许长生命周期学习的系统是无限的限制Boltzmann Machine（RBM）。经典RBM的这种扩展通过独特的索引来参数化隐藏单元，表示排序。这些索引被用来通过对旧节点进行偏好来增强网络的增长顺序，直到它们收敛，允许系统任意的增长。一个有趣的方法，但不清楚如何应用类似的修改的网络而不是特质生成架构的RBM。 这些增强技术都不支持递归架构。在现代自然语言处理设置中，这是一个致命的限制。然而，这些技术中的一些可能适用于RNNs，特别是因为在这些环境中最近已经解决了训练专用子系统。 架构裁剪 最近的研究集中于从训练网络中剪除边或整个神经元的可能性。这种方法不仅有利于压缩的目的，而且潜在地作为增加网络的可泛化性的一种方式。 裁剪边 修剪边而不是整个神经元的过程可能不会减少网络的维数类型。然而，它们会使网络变得稀疏，导致可能的内存节省。稀疏网络还占用较小的参数空间，因此可能更泛化。 HAN 等人采取的基本方法是：如果权重低于某一阈值，就将权重设置为0。这种方法对于压缩非常有效，因为可以通过阈值容易地修改要修剪的权重的数量。 LeCun 和Hassibi等人都选择基于修剪的误差变化的泰勒级数逼近的修剪权值。虽然这些方法对于旧的浅层网络是成功的，但是在整个网络上执行这些操作需要在所有参数上计算Hessian矩阵，这对于深度现代体系结构通常是棘手的。Dong等人通过在单个层上进行优化的脑外科手术调查，提出了一种更有效的替代方案。 修剪节点 ### 修剪整个节点具有减少整个网络维度的优点。它也可能比选择单个边更快地修剪，因为节点比边的数量更多，减少了修剪所考虑的候选者的数目。 He等人通过计算每个节点的权重，选择l层宽度为 d l d l 的神经元的 w l i w i l 去裁剪, 他们测试几个重要的度量指标，通过使用‘onorm’，或者平均的 l 1 l 1 正则化时节点的激活模式找到结果中的最高性能指标。
onorm(w l i )=1d l+1 ∑ j=1 d l+1 |w l+1 ij | o n o r m ( w i l ) = 1 d l + 1 ∑ j = 1 d l + 1 | w i j l + 1 | Net-trim 依赖于 l 1 l 1 正则来增加稀疏性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a105e445a6060ef2209487ac003ae44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/554d77c140a0614adebe697f9ba3a4bb/" rel="bookmark">
			【SlickGrid】------- slickgrid删除所有数据和选中的行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.slickgrid 删除所有数据;把主要代码放在里面 会不会只能靠自己了
//清空子表数据 var grid = new Slick.Grid("#grid_2", dataview_2, columns_2, options2); //var grid = mc_grid_dic["grid_2"]; var dataview = grid.getData();//得到数据 var datadelete = grid.getData().getItems();//获取表格的数据 var itemId = new Array(); for (var i = 0; i &lt; datadelete.length; i++) { itemId.push(datadelete[i].id);//组合数据ID } for (var j = 0; j &lt; itemId.length; j++) { dataview.deleteItem(itemId[j]); //删除数据 grid.invalidate(); grid.render();//重新渲染 } 2.slickgrid 删除选中的数据; //子表-delete行 var grid = new Slick.Grid("#grid_2", dataview_2, columns_2, options2); $(".btndetail-delete").off("click").on("click", function () { // var gridid = $(this).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/554d77c140a0614adebe697f9ba3a4bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc949f16b919c4ddee6bc3915330df8/" rel="bookmark">
			android studio,Gradle配置: RxJava失败  Failed to resolve: io.reactivex:rxjava:1.1.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rxjava version2.X之后：
To allow having RxJava 1.x and RxJava 2.x side-by-side, RxJava 2.x is under the maven coordinates io.reactivex.rxjava2:rxjava:2.x.y and classes are accessible below io.reactivex.
版本1.X：io.reactivex
版本2.X：io.reactivex.rxjava2:rxjava:2.x.y
详情见;https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7caca63f31ae0842c009ecdbf0cd2940/" rel="bookmark">
			使用Python处理json字符串中的非法双引号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中数据清洗时遇到以下情况：
a = '{"地区": "湖南", "描述": "精通软件开发、"数据挖掘"和分布式"}' 由于读取出的json字符串中包含有非法双引号，在使用json.loads()处理的时候报错 json.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 29 (char 28) 写了大半个小时的正则都无法解决 后来使用如下方法解决了，一并把json字符串中的换行符、分隔符和双引号都转义了
def deal_json_invaild(data): data = data.replace("\n", "\\n").replace("\r", "\\r").replace("\n\r", "\\n\\r") \ .replace("\r\n", "\\r\\n") \ .replace("\t", "\\t") data = data.replace('": "', '&amp;&amp;testPassword&amp;&amp;')\ .replace('", "', "$$testPassword$$")\ .replace('{"', "@@testPassword@@")\ .replace('"}', "**testPassword**") print(data) data = data.replace('"', r'\"')\ .replace('&amp;&amp;testPassword&amp;&amp;', '": "').replace('$$testPassword$$', '", "').replace('@@testPassword@@', '{"').replace('**testPassword**', '"}') print(data) return data 测试如下：
a = deal_json_invaild(a) json_data = json.loads(a) &gt; {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7caca63f31ae0842c009ecdbf0cd2940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837f8af79ec62d3759fd8e8524020971/" rel="bookmark">
			关于Ubuntu16.04连接Windows10共享失败的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近电脑升级了Ubuntu16.04，用下来还算可以吧，但是在samba共享的时候发生了一些问题。Ubuntu在文件管理器中的网络中连接其他Linux电脑的共享没有问题，但是连接Windows的系统共享就会显示连接超时。
一开始以为是Windows防火墙的问题，但是关闭后故障依旧，把samba等一系列服务全部重装，问题依旧，尝试使用smbclient命令行工具连接共享，
smbclient -L 192.168.1.198 -U username%password
WARNING: The "syslog" option is deprecated
protocol negotiation failed: NT_STATUS_CONNECTION_RESET
得到如下错误信息，后来在samba的一个国外wiki上找到了解决办法：
Protocol negotiation failed: NT_STATUS_CONNECTION_RESET Probably the server is configured not to accept protocol SMB1. Add option client max protocol = SMB2 in /etc/samba/smb.conf. Or just pass argument -m SMB2 to smbclient.
意思是我们目前的samba客户端使用的协议是SMB1，但是Windows10已经使用SMB2这个协议了，所以我们可以使用-m SMB2这个命令行参数来强制sambaclient使用SMB2协议，但是每次都使用命令行显然不方便，那么我们可以修改配置文件，在/etc/samba/smb.conf文件中添加client max protocol = SMB2 ，重启samba服务，正常访问Windows。
注：在Windows10中最好在网络和共享中心——&gt;高级共享设置中关闭密码保护共享，这样可以无密码的访问Windows共享，缺点是安全性下降。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855da03b977eb2d14a4061e27e1f8be9/" rel="bookmark">
			打开浏览器，显示网页可能暂时无法连接,或者它已永久性的移动到了新地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、win+r，进入命令行
重置Winsock目录：以管理员身份在命令行中运行命令：netsh winsock reset catalog
2、输入：NETSH WINSOCK RESET CATALOG
3、重启
如果一台计算机上的Winsock协议配置有问题的话将会导致网络连接等问题，就需要使用netsh winsock reset命令来重置Winsock目录借以恢复网络。这个命令可以重新初始化网络环境，用以解决由于软件冲突，病毒原因造成的参数错误等问题。
网上说不正常的意外关机会导致这种问题的出现，但我回想并没有非正常关机啊，倒是他们的主机经常通过断电闸的方式关机.......
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42936d52a843164c1546cff41aeffbc2/" rel="bookmark">
			【缓存】-缓存中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：主要介绍缓存中间件MemCached和Redis
MemCached 1、MemCached介绍 MemCached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。它便于快速开发，减轻开发难度，解决了大数据量缓存的很多问题，本质上，它是一个简洁的key-value存储系统
2、MemCached工作原理 主要通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度。见下图： Redis 1、Redis简介 Redis 是完全开源免费的，是一个高性能的key-value数据库。
Redis 与其他 key - value 缓存产品有以下三个特点： （1）Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 （2）Redis支持String、list、set、zset、hash等数据结构的存储。 （3）Redis支持数据的备份，即master-slave模式的数据备份。
2、Linux下安装Redis 下载地址：http://redis.io/download （1）下载并安装：
$ wget http://download.redis.io/releases/redis-4.0.10.tar.gz $ tar xzf redis-4.0.10.tar.gz $ cd redis-4.0.10 $ make （2）启动redis服务
$ cd src $ ./redis-server （3）使用redis客户端
$ cd src $ ./redis-cli redis&gt; set companyName G7 OK redis&gt; get companyName "G7" 3、Java使用Redis import redis.clients.jedis.Jedis; import java.util.*; /** * Created by pc on 2018/7/23. * Redis数据类型 */ public class RedisDemo { //String public static void redisString(){ //连接 Redis 服务 Jedis jedis = new Jedis("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42936d52a843164c1546cff41aeffbc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356dd70ed3aa773ab13be4a8ff7465c2/" rel="bookmark">
			程序员到底学什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直在思考程序员到底学什么？难道我们就一直陷在无穷无尽的业务里做增删改查？还是跟别人比多掌握了些开源框架或中间件的使用？还是比别人会更多新的技术或者开发工具？
在别人追求学习更多新的技术，牛逼的中间件，我却更愿意花时间扎实自己基础，了解技术的本质，因为我个人认为新出的技术本质没有多大变化，只会封装的越来越深。
分享一下我个人认为应该学的：
1.算法，数据结构
计算机离不开数学，只有数学的支持才是可靠的
2.抽象能力
怎么从0和1发展到现在的互联网，关键就是的抽象
3.优美的编码
傻瓜都能学出计算机能运行的代码，只能聪明的人会写让人能理解和阅读的代码
5.计算机的思维方式
运用计算机的思维方式描述现实中的问题
6.扎实的基础，融会贯通
操作系统，网络，虚拟机，数据库，中间件。。。
7.透彻的了解技术的本质
不要停留在怎么运用技术，要掌握里面的算法和抽象
8.系统分解，架构的能力
对系统需求把控，分解，构架的能力
9.学会高效沟通，团队协作
学会高效的沟通，注重团队协作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48babd445d484bb30f510e170ae00ac0/" rel="bookmark">
			使用递归求平均值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果数组长度为1，则可以直接返回平均值结果；否则将数组A视为两部分，即A[n-1]和A[0,…,n-2]，递归地处理A[0,…,n-2]中n-1个数的平均值avg，通过(avg*(n-1)+A[n-1])/n即可求得数组A中所有数的平均值。
float arrayavg(float A[],int n){ if(n==0) return A[n]; else return (A[n]+n*arrayavg(A,n-1))/(n+1); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6b98db95f548be6671a2d775aefec4f/" rel="bookmark">
			执行jar包出错：Exception in thread &#34;main&#34; java.lang.NoClassDefFoundError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 错误
Exception in thread main java.lang.NoClassDefFoundError：org/apache/axis2/client/Stub
Exception in thread main java.lang.NoClassDefFoundError：javax/mail/internet/ParseException
......
由于项目需求，我要在Linux中调用执行jar包，jar包是一个Web Service客户端程序，在Windows环境Java IDE工具Eclipse中编写，程序在Eclipse中执行正常，然而，在打包为jar文件之后执行，却出现了以上错误。
这主要是因为jar包在执行时需要用到以上类文件，但是却没有找到这些文件。
之所以在Eclipse中执行正确，是因为我们配置了工程的环境，通过build path已经将所需的类文件以jar包的形式添加到工程中。而打包为jar包之后，由于没有配置环境变量，程序不知道去哪里寻找这些类文件，所以出错。
2. 解决
解决方法有二：
a) 将以上这些类文件所在的jar包路径加入环境变量classpath中，这样在执行jar包时系统会根据classpath的值找到jar包；
b) 在打包时，将这些jar包写入MANIFEST.MF中，例如：
Manifest-Version: 1.0
Created-By: 1.6.0_45 (Sun Microsystems Inc.)
Class-Path: lib/axiom-api-1.2.13.jar lib/axiom-impl-1.2.13.jar lib/axis2-adb-1.6.2.jar lib/axis2-kernel-1.6.2.jar lib/axis2-transport-http-1.6.2.jar lib/axis2-transport-local-1.6.2.jar lib/commons-codec-1.3.jar lib/commons-httpclient-3.1.jar lib/commons-logging-1.1.1.jar lib/gson-2.1.jar lib/httpcore-4.0.jar lib/mail-1.4.jar lib/neethi-3.0.2.jar lib/wsdl4j-1.6.2.jar lib/XmlSchema-1.4.7.jar
Main-Class: iUserMgr.UserMgrMain
【注】：
Class-Path后面的冒号之后有一个空格，并且两个jar文件之间有一个空格。因为我的程序中用到的jar包太多，所以我把它们存放在文件夹lib下面。 将用到的这些jar文件放入lib文件夹，并且将lib文件夹和打包后的jar文件放在同一个目录下，然后执行jar包就不会出现这些问题了。
此处我用的方法二，因为要在Linux中执行jar包，第二种方法会比较方便一些。但是这种方法需要保证lib文件夹始终跟你的jar包在同一个目录下。
3. 附
Exception in thread main java.lang.NoClassDefFoundError：org/apache/axis2/client/Stub
这个类文件在axis2-kernel-1.6.2.jar中
Exception in thread main java.lang.NoClassDefFoundError：javax/mail/internet/ParseException
这个类文件在mail-1.4.jar中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6b98db95f548be6671a2d775aefec4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7be4a0f1cc6c088b383f196515ff9fe/" rel="bookmark">
			cv::Mat与std::string互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、cv::Mat转std::string
没找到更好的办法，只能通过vector进行中转。但memcpy效率还是挺高的
cv::Mat mat = cv::imread("d:\\1.jpg"); std::string str; std::vector&lt;unsigned char&gt; buff; cv::imencode(".jpg", mat, buff); str.resize(buff.size()); memcpy(&amp;str[0], buff.data(), buff.size()); 二、std::string转cv::Mat
把std::string当做1行N列的数据，通过引用数据指针的方式来得到mat2。此时没有发生内存拷贝，效率较高。
cv::Mat mat2(1, str.size(), CV_8U, (char*)str.data()); cv::Mat dst = cv::imdecode(mat2, CV_LOAD_IMAGE_COLOR); 三、场景 thrift里binary类型用的std::string，项目里把cv::Mat定义为binary，就用到了这种办法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02cdcdadd585774b4cf8a067a54efc6/" rel="bookmark">
			Linux上ARP表，路由表的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为厘清数据在网络中的传输流向和具体的实现过程，现对ARP表，路由表进行学习如下。
ARP（Address Resolution Protocol）地址解析协议。IP数据包经常通过以太网进行发送，以32位的IP地址作为源/目的地址。但是以太网设备不能识别IP地址，他们是以48位的以太网地址传输以太网数据包的。ARP就是用来实现这种地址转换的协议。
linux中使用 arp -a命令可查看ARP缓存表：
ARP工作时，先发送一个含有目的IP地址的以太网广播数据包，被应答以一个含有IP和以太网对的数据包。其中第一行表示目的IP，第二行表示存储的MAC地址，最后表示网卡接口。
路由表(routing table)，使用route命令可查看linux内核中的路由表。在这个路由表中，第一个表示目的网段，第二个表示网关，第三个表示子网掩码。
当有两个不同的网络A、B时，由于TCP/IP协议会根据子网掩码来判断两个网络是否相同，所以即使A和B连接在同一个交换机上，他们之间也不能通过TCP/IP进行通信。此时需要借助路由来进行转发，即路由表上标明了下一个应该走的路线，但是这个路线不能说是路由器a，路由器b这样来标识，他是通过路由器某个端口的IP来进行标识的。
具有路由功能的设备的某个IP地址，就是网关。即，网关是路由器上的一个IP地址，路由器是一个进行转发的实体。
当A网络中的主机1,想要与B网络中的主机2进行通信时候，在IP层封装源IP、目的IP，通过子网掩码IP比对，发现两个不在一个子网，则查看路由表将数据发送给路由表上对应的网关。最后在mac层封装时，会通过ARP请求，请求得到网关的mac地址，将报文发送给网关。（此时变得只有目的MAC，源IP、目的IP是没有变的）
总之，在数据进行传送的过程，是由上到下的一个过程，先检查IP（查看是否在一个子网，查看路由表），再进行mac封装（查看ARP表）。
总而言之，这两个表是不同层次的两个表，结合进行使用，保证数据正常传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894c7691cfe8f75fe136069d6f778bb5/" rel="bookmark">
			AppleScript 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AppleScript 快速入门 AppleScript 快速入门 一、让其他程序执行任务二、数据类型三、条件语句四、循环五、函数六、用户交互对话框七、使用词典八、操作其他程序的界面九、运行参数 AppleScript 顾名思义是苹果开发的一套脚本语言，利用 AppleScript 在 macOS 系统上可以对其他程序进行操作，点击按钮、发送消息、模拟自动化执行功能，比如可以打开浏览器，清空回收站等等一些操作，是一个非常有意思的脚本。说好了要快速入门，下面我们开始快速学习了解它吧。
一、让其他程序执行任务 在 macOS 上有一个应用叫脚本编辑器，通过 Launchpad 可以搜索到，打开脚本编辑器之后，可以看到支持编写和解析 AppleScript 和 JavaScript 两种脚本，如下图所示：
AppleScript 的语法和平时的英语语法很类似，你想让哪个程序执行操作，就 tell 它，比如你想让 Finder 清空回收站那就这样写：
tell application "Finder" empty the trash end tell 在脚本编辑器上点击运行按钮就可以看到回收站的内容被清空了，或者按快捷键 Command + R 也能运行，运行之前记得回收站得有东西，不然可能会执行失败。
如果你想让系统说话，可以这样写：
tell application "Finder" say "My name is exchen" end tell 哈哈，记得把电脑的声音打开，是不是听到说话了？不仅支持英文和中文，其他国家语言，像德语、荷兰语笔者试过，同样也可以。
如果你想让浏览器打开 URL，可以这样写：
set myBlog to "http://www.exchen.net" # 告诉 Chrmoe 浏览器打开 URL tell application "Google Chrome" # 新建一个 chrome 窗口 set window1 to make new window tell window1 set currTab to active tab of window1 set URL of currTab to myBlog end tell end tell 看看 Chrmoe 浏览器是不是打开了你指定的 URL 了？有意思吧？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/894c7691cfe8f75fe136069d6f778bb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7e7783feb8d86420f4d96f5c08f539/" rel="bookmark">
			react&#43;webpack 打包，开发环境和生产环境集成一体拿来就能用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：
webpack.config.js
import webpack from "webpack";
import path from "path";
var path = path.resolve(__dirname,"/main.j")
var ExtractTextPlugin = require("extract-text-webpack-plugin");//css,js分离插件,
//使用该插件需要独立下载'npm install extract-text-webpack-plugin --save-dev', 同时下面的rules也必须更改
var CleanWebpackPlugin = require("clean-webpack-plugin");//要清除重复打包的文件重复问题
// 需要先进行安装 npm install --save-dev html-webpack-plugin inline-menifest-webpack-plugin
var HtmlWebpackPlugin = require("html-webpack-plugin");//动态将打包好的js css文件注入到index.html
var InlineMenifestWebpackPlugin = require("inline-menifest-webpack-plugin");//动态将打包好的js css文件注入到index.html
var isProduction = process.env.NODE_ENV === 'production';
var filename = isProduction ? '[name].[chunkhash].js':'[name].js';
module.exports={
entry: {
main: ".src/main.j",
// ventor: ['jquery']
},
output:{
path: path.resolve(__dirname, './build'),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce7e7783feb8d86420f4d96f5c08f539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7f83acbb5d5be69b6e35f504c72088/" rel="bookmark">
			商品历史价格查询网站分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享个人小站，查询电商历史价格，京东、天猫、淘宝等
网址：asd-price.com （里面有说明用法）
大概意思就是在电商的域名（ jd.com\tmall.com ）的一级域名后面添加字母“ asd ”后直接访问就能看到历史价格了。
比如：
https://item.jd.com/5089275.html 这是商品页面
https://item.jdasd.com/5089275.html 这就是历史价格页面（ jd 后面加了“ asd ”）
其他网站都一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca02311952322ad7a4833e15f17b683/" rel="bookmark">
			Android使用Itext生成pdf文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于生成pdf文件，上一篇文章介绍了使用android原生的方式生成pdf，使用android原生的方式对于将view上的内容生成pdf非常的简单，但有缺憾，就是生成的pdf文佳很多，对于在项目中需要将生成的pdf文件发送出去，这时就会发现发送的时间有点长了，这对于用户来说肯定是不可以接受的了，所以就有了这里接受的Itext了。
对于Itext，主要有两个版本，一个是5.x，另一个是7.x，这两个版本是完全是不兼容的，其区别可以参考官网：https://itextpdf.com/blog/itext-7-and-itext-5-roadmaps-differences-updates，
5.x的文档：https://itextsupport.com/apidocs/itext5/latest/
7.x的文档：https://itextsupport.com/apidocs/itext7/latest/
在项目中使用的是5.x，对于7.x没怎么去研究，下面主要是对5.x版本的使用介绍：
首先是下载一个5.x版本的jar包，链接：https://pan.baidu.com/s/1Gno-jNI7L15KSKZZGFai-g，下载完后，至于怎么导包就不用多说了吧，接下来就是看看怎么使用了，先看看文字怎么生存pdf：
public void textTransformPdf(String content,String pdf_save_address){ Document doc = new Document();// 创建一个document对象 FileOutputStream fos; try { fos = new FileOutputStream(pdf_save_address); // pdf_address为Pdf文件保存到sd卡的路径 PdfWriter.getInstance(doc, fos); doc.open(); doc.setPageCount(1); doc.add(new Paragraph(content, setChineseFont())); // result为保存的字符串 // ,setChineseFont()为pdf字体 // 一定要记得关闭document对象 doc.close(); } catch (FileNotFoundException e1) { e1.printStackTrace(); } catch (DocumentException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } public Font setChineseFont() { BaseFont bf = null; Font fontChinese = null; try { // STSong-Light : Adobe的字体 // UniGB-UCS2-H : pdf 字体 bf = BaseFont.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fca02311952322ad7a4833e15f17b683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ef9147fcfdf1abe0d8609fd4ce2b43/" rel="bookmark">
			今天在做微信分享功能的时候，遇到项目部署后出现 config:invalid url domain 弹窗提示的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产生此错误的原因是微信公众号后台配置的微信安全网址跟当前页面的域名不一致导致的，要解决这种情况就需要在公众号的后台设置js接口安全域名，打开微信公众平台
把MP_verify_sfpa0ES1106ZRXnp.txt 这个文件放到你的服务器后，填写好域名，点击“保存”按钮，微信平台会自动检查该文件能不能访问，如果可以的话就会保存成功，之后你的页面就不会出现 config:invalid url domain 这个提示了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e99ed3a3ec18d95bf4dc853b320ff68a/" rel="bookmark">
			原生php导出csv格式的Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图 源码分析 index.php
&lt;?php require_once "./Export.php"; //测试数据 $headerList= ['列名1','列名2','列名3']; $data = [ ['值1','值2','值3'], ['值11','值22','值33'], ['值111','值222','值333'] ]; $fileName = "测试导出文件名"; $tmp = ['备份字段1','备份值1','','备份字段2','备份值2']; $export = new Export(); $result = $export-&gt;exportToCsv($headerList,$data,$fileName,$tmp); Export.php
&lt;?php class export{ /** * params $headerList 头部列表信息(一维数组) 必传 * params $data 导出的数据(二维数组) 必传 * params $filename 文件名称转码 必传 * params $tmp 备用信息(二维数组) 选传 * PS:出现数字格式化情况，可添加看不见的符号，使其正常，如:"\t" **/ public function exportToCsv($headerList = [] , $data = [] , $fileName = '' , $tmp = []){ //文件名称转码 $fileName = iconv('UTF-8', 'GBK', $fileName); //设置header头 header('Content-Type: application/vnd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e99ed3a3ec18d95bf4dc853b320ff68a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c834f08d83445a59316a0c04a2b5bb0/" rel="bookmark">
			MySQL之将查询结果生成新表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL语句示例：
CREATE TABLE school SELECT * FROM class CREARE负责创建表，表的内容是SELECT语句的查询结果
如果我们想结合两个表的相同字段并生成新表，SQL语句如下：
CREATE TABLE school SELECT * FROME CLASS1,CLASS2 WHERE CLASS1.NAME=CLASS2.NAME 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b092a7efde5cb5d5d3361b895fd634d0/" rel="bookmark">
			在编写jsp的时候Myeclipse中 报错 Syntax error on token &#34;Invalid Regular Expression Options&#34;, no accurate corre
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在编写jsp的时候Myeclipse中 报错 Syntax error on token "Invalid Regular Expression Options", no accurate correc解决办法 选中报错的jquery文件“jquery-1.2.6.min.js”。右键选择 MyEclipse--&gt;Exclude From Validation 。再右键选择 MyEclipse--&gt;Run Validation 即可。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/248/">«</a>
	<span class="pagination__item pagination__item--current">249/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/250/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>