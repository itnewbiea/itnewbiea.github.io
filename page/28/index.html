<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b1de2dca7ad8042f9476e9a44f6a657/" rel="bookmark">
			毕业设计-基于深度学习的交通路面障碍物目标检测系统 YOLO python 卷积神经网络 人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
设计思路
一、课题背景与意义
二、算法理论原理
三、检测的实现
3.1 数据集
3.2 实验及结果分析
实现效果图样例
最后
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是海浪学长毕设专题,本次分享的课题是
🎯基于深度学习的交通路面障碍物目标检测系统
设计思路 一、课题背景与意义 随着社会经济的快速发展，越来越多的家庭拥有私家车，如何减少交通意外的发生和实现无人驾驶成为新问题。辅助系统的出现成为解决问题的关键技术，是高精度识别交通路面障碍物的一个重要组成部分。能否及时提醒驾驶员注意交通路面障碍物成为一项安全技术。
二、算法理论原理 YOLOV5模型包括Input、Neck、Backbone和Prediction四个部分。Yolov5网络模型在基础的锚框上进行模拟得到预测框，如果所得预测框计算与实际相差过大，可以改变代码将自动锚功能关闭。Backbone在新增操作的Foucs操作中，切片操作非常重要，其过程是逐步变化的。Neck的结构是FPN（自上而下）+PAN（自底向上结构的特征金字塔）结构，FPN结构采用上采样方法进传递信息和融合信息，获取预测的结果图。Prediction由非极大值抑制（NMS）和Bounding box损失函数两大部分组成。在Bounding box中，GIOU_Loss函数作为损失函数，通过NMS函数可以在预测结果处理阶段解决重合目标边框或进行筛选。
​
相关代码：
import torch import torch.nn as nn class FPN(nn.Module): def __init__(self, in_channels_list, out_channels): super(FPN, self).__init__() self.in_channels_list = in_channels_list self.num_layers = len(in_channels_list) self.out_channels = out_channels # Lateral convolutions self.lateral_convs = nn.ModuleList() for i in range(self.num_layers): conv = nn.Conv2d(in_channels_list[i], out_channels, kernel_size=1) self.lateral_convs.append(conv) # Top-down pathway convolutions self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b1de2dca7ad8042f9476e9a44f6a657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b41313412fa1497405a3228a4f45041a/" rel="bookmark">
			AI项目十九：YOLOV8实现目标追踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处。
主要是学习一下实现目标追踪的原理，并测试一下效果。
目的是通过YOLOV8实现人员检测，并实现人员追踪，没个人员给分配一个ID，实现追踪的效果。
也可以统计人数。在小区办公楼的出入场所，这类很常见。
一、简介 追踪任务是指识别和跟踪特定目标在视频序列中的运动和位置，一般用唯一ID或固定颜色检测框表示），如下图：
目标检测和目标跟踪的区别：
目标检测:目标检测任务要求同时完成对象的定位（即确定对象的边界框位置）和分类（即确定对象的类别）。这意味着目标检测算法必须不仅能够确定对象是否存在，还要知道它是什么。
目标检测通常用于识别和定位图像或视频帧中的对象，通常需要明确的目标类别信息。
目标跟踪:目标跟踪任务更关注对象在帧与帧之间的连续性，通常更注重对象的运动特征，而不要求进行目标的分类。
目标跟踪可以不涉及目标的类别，它的主要目标是维护对象的位置和轨迹，以实现在视频序列中的跟踪。
这里就有个问题，视频中不同时刻的同一个人，位置发生了变化，那么是如何关联上的呢？答案就是匈牙利算法和卡尔曼滤波。
匈牙利算法可以告诉我们当前帧的某个目标，是否与前一帧的某个目标相同。卡尔曼滤波可以基于目标前一时刻的位置，来预测当前时刻的位置，并且可以比传感器（在目标跟踪中即目标检测器，比如Yolo等）更准确的估计目标的位置。 最经典的是DeepSORT，本篇记录的是如何使用IOU，所以了解下DeepSORT。
DeepSORT对每一帧的处理流程如下：
检测器得到bbox → 生成detections → 卡尔曼滤波预测→ 使用匈牙利算法将预测后的tracks和当前帧中的detecions进行匹配（级联匹配和IOU匹配） → 卡尔曼滤波更新
Frame 0：检测器检测到了3个detections，当前没有任何tracks，将这3个detections初始化为tracks Frame 1：检测器又检测到了3个detections，对于Frame 0中的tracks，先进行预测得到新的tracks，然后使用匈牙利算法将新的tracks与detections进行匹配，得到(track, detection)匹配对，最后用每对中的detection更新对应的track 二、方法介绍 目前主流的目标跟踪算法都是基于Tracking-by-Detecton策略，即基于目标检测的结果来进行目标跟踪。
实现目标跟踪的方法：
1、IOU 比较前后两帧检测框IOU是否大于指定阈值，是则是同一个物体，不是则分配新ID，此方法对于运动慢的可以，效果差。
2、卡尔曼滤波 卡尔曼滤波是一种用于估计系统状态的优秀算法。它结合了传感器测量和系统模型，通过递归地计算加权平均值，实时更新状态估计。卡尔曼滤波在众多领域，如导航、机器人技术和信号处理中广泛应用，以提高系统的准确性和鲁棒性。
可以用的库：GitHub - adipandas/multi-object-tracker: Multi-object trackers in Python
3、botsort&amp;bytetrack BoT-SORT是今年非常游戏的跟踪器模型。就所有主要 MOT 指标MOTA、IDF1 和 HOTA而言，BoT-SORT 和 BoT-SORT-ReID 在 MOT17 和 MOT20 测试集的 MOTChallenge数据集中排名第一。对于 MOT17：实现了 80.5 MOTA、80.2 IDF1 和 65.0 HOTA，在跟踪器的排行榜上暂居第一。
论文翻译：https://blog.csdn.net/hhhhhhhhhhwwwwwwwwww/article/details/126890651
论文链接：https://arxiv.org/pdf/2206.14651.pdf
代码：https://github.com/NirAharon/BOT-SORT
ByteTrack是基于tracking-by-detection范式的跟踪方法。大多数多目标跟踪方法通过关联分数高于阈值的检测框来获取目标ID。对于检测分数较低的目标，例如遮挡目标，会被简单的丢弃，这带来了不可忽略的问题，包括大量的漏检和碎片化轨迹。为了解决该问题，作者提出了一种简单、高效且通用的数据关联方法BYTE，通过关联每个检测框而不仅仅是高分检测框来进行跟踪。对于低分检测框，利用它们与轨迹的相似性来恢复真实目标并过滤掉背景检测。
BoT-SORT：https://github.com/NirAharon/BoT-SORT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b41313412fa1497405a3228a4f45041a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bc3e72708638338ff148a77af956587/" rel="bookmark">
			记录一次ocr识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// log(clickCharEx_paddle("图片", true, 0, true)); function requestScreenshot() { let result = false; //等待截屏权限申请并同意 let thread = threads.start(function () { if (device.brand == 'vivo') { text('取消').id('com.android.systemui:id/vbutton_title').waitFor(); sleep(1000) let s = text('取消').findOnce() console.log(s.bounds().centerX(), s.bounds().centerY() - 180); click(s.bounds().centerX(), s.bounds().centerY() - 180) } else { packageName('com.android.systemui').text('立即开始').waitFor(); text('立即开始').click(); } }); //申请截屏权限 if (!requestScreenCapture()) { toast("请求截图失败"); } else { result = true; thread.interrupt(); } return result; }; /** OCR识图并点击（paddle） */ function clickCharEx_paddle(content, isDimFind, index, isClick, offsetX, offsetY, milliSecond) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bc3e72708638338ff148a77af956587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d8ad2ff13f3180be75b72afe2177f5/" rel="bookmark">
			Spark编程实验三：Spark SQL编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、目的与要求
二、实验内容
三、实验步骤
1、Spark SQL基本操作
2、编程实现将RDD转换为DataFrame
3、编程实现利用DataFrame读写MySQL的数据
四、结果分析与实验体会
一、目的与要求 1、通过实验掌握Spark SQL的基本编程方法；
2、熟悉RDD到DataFrame的转化方法；
3、熟悉利用Spark SQL管理来自不同数据源的数据。
二、实验内容 1、Spark SQL基本操作
将下列JSON格式数据复制到Linux系统中，并保存命名为employee.json。
{ "id":1 , "name":"Ella" , "age":36 }
{ "id":2, "name":"Bob","age":29 }
{ "id":3 , "name":"Jack","age":29 }
{ "id":4 , "name":"Jim","age":28 }
{ "id":5 , "name":"Damon" }
{ "id":5 , "name":"Damon" }
为employee.json创建DataFrame，并写出Python语句完成下列操作：
（1）查询所有数据；
（2）查询所有数据，并去除重复的数据；
（3）查询所有数据，打印时去除id字段；
（4）筛选出age&gt;30的记录；
（5）将数据按age分组；
（6）将数据按name升序排列；
（7）取出前3行数据；
（8）查询所有记录的name列，并为其取别名为username；
（9）查询年龄age的平均值；
（10）查询年龄age的最小值。
2、编程实现将RDD转换为DataFrame
源文件内容如下（包含id,name,age）：
1,Ella,36
2,Bob,29
3,Jack,29
请将数据复制保存到Linux系统中，命名为employee.txt，实现从RDD转换得到DataFrame，并按“id:1,name:Ella,age:36”的格式打印出DataFrame的所有数据。请写出程序代码。
3、编程实现利用DataFrame读写MySQL的数据
（1）在MySQL数据库中新建数据库sparktest，再创建表employee，包含如表所示的两行数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d8ad2ff13f3180be75b72afe2177f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8919f36a363dee5ff03571e7f3dc6f9/" rel="bookmark">
			gradle--groovy-dsl和kotlin-dsl对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 gradle--groovy-dsl和kotlin-dsl对比常用对比插件引用对比gradle脚本引用对比任务task对比配置任务创建任务 仓库对比依赖对比groovy的ext和kotlin的extra独立gradle文件对比示例groovykotlin 参考 gradle–groovy-dsl和kotlin-dsl对比 官方文档：Migrating build logic from Groovy to Kotlin官方demo:kotlin-dsl-samples/samples at master · gradle/kotlin-dsl-samples · GitHubandroid相关的迁移可以查阅：将构建配置从 Groovy 迁移到 KTS | Android 开发者 | Android Developers对于想使用kotlin的小伙伴来说，经常会遇到groovy的这个东西kotlin该怎么写的烦恼，为此本文总结一些常用的对比 常用对比 groovy可以使用单引号和双引号，而kotlin只能使用双引号groovy在函数调用时可以省略括号，而kotlin必须加上括号groovy在赋值时可以省略等于号，而kotlin必须加上等号为了减少迁移成本，在groovy时就应该约定使用双引号，调用加上括号，使用等号赋值 插件引用对比 Groovy DSL有两种方式去引用插件： 1 plugins{} //强烈推荐2 apply plugin 注意，核心插件可以用短名称，非核心插件必须声明id和version(非核心插件地址：Gradle - Plugins) //groovy dsl plugins { id 'java' //核心插件，可以省略version id 'jacoco' id 'maven-publish' id 'org.springframework.boot' version '2.4.1' } //kotlin dsl plugins { java //核心插件，可以直接用短名称 jacoco `maven-publish` id("org.springframework.boot") version "2.4.1" } //groovy dsl apply plugin: 'java' apply plugin: 'jacoco' apply plugin: 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8919f36a363dee5ff03571e7f3dc6f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d09b6325a0446833400d440a938490/" rel="bookmark">
			【深入剖析K8s】第五章 1 为什么我们需要Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker容器存在的问题 Docker容器的本质: ’‘‘Namespace做隔离，Cgroups做限制，rootfS做文件系统”。 我们为啥需要Pod?
# 展示当前系统中正在运行的进程的树状结构 pstree -g 在一个真正的操作系统里，是以进程组的方式‘有原则”地组织在—起。
容器的单进程模型,并不是指容器里只能运行‘‘一个”进程，而是指容器无法管理多个进程。这是因为容器里PID＝1的进程就是应用本身，其他进程都是这个PlD＝1进程的子进程。
容器的资源调度上，对于超亲密关系的容器的调度存在难度。Pod在Kubemetes项目里还有更重要的意义’那就是容器设计模式。 多容器的Pod 所有“超亲密关系”的容器都属于同一个Pod。可以把容器间的这种紧密协作称为超亲密关系。这些具有‘超亲密关系”的容器的典型特征包括但不限于:
互相之间会发生直接的文件交换、使用localhost或者Sockct文件进行本地通信发生非常频繁的远程调用需要共享某些LinuxNamespace（比如—个容器要加人另—
个容器的NetworkNamespace） Pod 如何被创建 Pod其实是—组共享了某些资源的容器。Pod里的所有容器都共享—个Network Namespace，并且可以声明共享同一个Volume。
如此看来—个有A、B两个容器的Pod不就等同于一个容器（容器A）共享另外—个容器（容器B）的网络和Volume的做法吗？
docker run --net=B --volumes-from=B --name=A image-A 如果真这样做的话，容器B就必须比容器A先启动’这样一个Pod里的多个容器就不是对等关系。
在Kubemetes项目里’Pod的实现需要使用—个中间容器’这个容器叫作Infra容器。在这个Pod中Infra容器永远是第—个被创建的容器，用户定义的其他容器则通过Jojn Network Namespace的方式与Infra容器关联在—起。
Infra容器—定要占用极少的资源，所以它使用的是—个非常特殊的镜像’
叫作k8s.gcr.io／pause。这个镜像是—个用汇编语言编写的，永远处于“暂停’,状态的容器
网络、Volume 都是真的Pod 来定义的。Kubemetes项目只要把所有Volume的定义都设计在Pod层级即可。
Pod这种‘超亲密关系”容器的设计思想’实际上就是希望，当用户想在一个容器里运行多个功能无关的应用时，应该优先考虑它们是否更应该被描述成—个Pod里的多个容器。
举例说明Pod 1 是wAR包与web服务器 现在有—个JavaWeb应用的WAR包’它需要放在TOmcat的webapps目录下运，那该如何处理这个组合关系呢。
两个容器都挂载了shared-data 的Volume。
这就是nginx-container 可以从它的/usr/share/ngjnx/html目录中读取到debian-container 生成的 indexhtml文件的原因。
2 在Pod中所有Init Container定义的容器’都会比speccontainers定义的用户容器先启动。并且Init Container容器会按顺序逐一启动,而直至它们都启动并且退出了,用户容器才会启动。
我执行了—句cp /sample.war /app,把应用的WAR包复制到／app目录下’然后退出
而后这个/app目录就挂载了一个名叫app-volume的Volume。
等Tomcat容器启动时,它的webapps目录下就—定会存在sample.war文件:这个文件正是WAR包容器启动时复制到这个Volume里面的，而这个Volume是被这两个容器共享的。
总结： Kubemetes项目中Pod的实现原理： In仕a容器永远是第—个被创建的容器’用户定义的其他容器则通过JojnNetworkNamespace的方式与InfTa容器关联在—起。Pod 的本质： Pod实际上是在扮演传统基础设拖里‘‘虚拟机’’的角色’容器则是这个虚拟机里运行的用户程序。容器与虚拟机几乎没有任何相似之处。虚拟机里运行的应用，是在systemd或者supervisord管理之下的一组进程。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb08808a58898e6d9e7917bba4f72f9/" rel="bookmark">
			【K8S in Action】服务：让客户端发现pod 并与之通信（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 通过Ingress暴露服务 Ingress (名词） 一一进入或进入的行为；进入的权利；进入的手段或地点；入口。一个重要的原因是每个 LoadBalancer 服务都需要自己的负载均衡器， 以及
独有的公有 IP 地址， 而 Ingress 只需要一个公网 IP 就能为许多服务提供访问。
Ingress 在网络栈 (HTTP) 的应用层操作。
1.1 Ingress 控制器是必不可少的 只有Ingress控制器在集群中运行，Ingress 资源才能正常工作。在 minikube 上启动 Ingress 的扩展功能。
# 确保已启用 Ingress 附加组件 $ minikube addons list - default-storageclass: enabled - kube-dns: enabled - heapster: disabled - ingress: disabled # 没有启动 - registry-creds: disabled - addon-manager: enabled - dashboard: enabled # 启用 Ingress 附加组件 $ minikube addons enable ingress ingress was successfully enabled # 查看控制Pod $ kubectl get po --all-namespaces 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb08808a58898e6d9e7917bba4f72f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca5b1b6b2f2760df4079c2b018ed5c6/" rel="bookmark">
			C/C&#43;&#43; 连接访问 MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们已经讲述了MySQL的基础使用，现在我们来看一下如何使用语言来操作数据库。在实际开发中，语言连接MySQL是为了能够在编程语言中与MySQL数据库进行交互和操作。大部分情况我们都是通过语言连接MySQL，建立与MySQL数据库的连接，可以向MySQL数据库发送更新请求，如插入、更新或删除数据。本篇文章主要讲解使用C语言连接MySQL数据库，当然在C++中也能够使用，因为C++兼容C语言的。
文章目录
一、连接MySQL
1、1 MySQL官网下载库
1、2 安装对应开发库
二、MySQL接口介绍
2、1 创建和释放 MYSQL 对象
2、2 连接mysql
2、3 发送sql语句
🙋‍♂️ 作者：@Ggggggtm 🙋‍♂️
👀 专栏：MySQL 👀
💥 标题：C/C++ 连接访问 MySQL💥
❣️ 寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景 ❣️ 一、连接MySQL 1、1 MySQL官网下载库 要使用C语言连接mysql，需要使用mysql官网提供的库。MySQL官网：MySQL。如下图：
然后点击DOWNLOADS，如下图：
往下寻找MySQL Community Downloads，如下图：
因为我们使用C语言连接MySQL，所以查找C API，如下图：
然后点击如下图：
我个人所用的是Linux，所以选择Linux的安装包。可根据自己的环境进行选择，如下图：
再次选择OS合适的版本，如下图：
当我们下载后，采用rz -E的方法可将压缩包传输到我们的Linux上。然后再使用 tar -xzf进行解压即可。解压后我们再看其中的文件，如下图：
其中对我们有用的就是头文件和库函数了。具体怎么进行使用该头文件和库函数，可以参照文章：动静态库的原理与制作详解。这里就不再过多解释。
但是我们也不建议使用以上方法，因为其中可能会产生兼容性等问题。我们接着往下看。
1、2 安装对应开发库 当我们再Linux安装了mysql的开发环境时，就会自动给我们安装对应的语言连接mysql 的头文件与库函数。我们可以进行查看。具体查看方法如下：
查看头文件：查看对应的库： 如果上述都能够查看到，证明就已经安装了对应的开发库。一般情况下都是有的，如果没有的话，可以进行自己安装，如下图：
我这里已经安装过了，所以最后显示的是Nothing to do。下面我们来验证一下看是否安装成功。代码如下：
#include &lt;iostream&gt; #include &lt;mysql/mysql.h&gt; int main() { printf("mysql client Version: %s\n", mysql_get_client_info()); return 0; } 运行结果如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca5b1b6b2f2760df4079c2b018ed5c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a636c249c72fc064761f1de231733cd6/" rel="bookmark">
			中汽研实习面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.个人介绍
2.本科有过实习吗？这是第一次实习？
3.希望有什么收获
4.个人建议：拍一张正式的照片
5.有没有考虑交通方式？（稍微有点远，没有住宿）
6.有没有什么问题要问他们
其它：电脑摆个好角度亮一些
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd06e2d9979d78b10a8ca4e1d15c53c6/" rel="bookmark">
			李宏毅机器学习第二十二周周报GAN理论2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 week22 Theory behind GAN 2摘要Abstract一、李宏毅机器学习0.上周内容概述1.GAN的训练过程2.生成器与分辨器的算法细节3.整体算法描述4.原文中生成器目标函数的实现方式 二、文献阅读1. 题目2. abstract3. 网络架构3.1无数据生成方法3.2 Data-Enriching GAN(DeGAN) 4. 文献解读4.1 Introduction4.2 创新点4.3 实验过程4.3.1 知识蒸馏实验4.3.2 类别增量学习 4.4 结论 三、实验内容1.数据展示2.使用差分法预测3.ARIMA模型建立过程4.模型预测小结参考文献 week22 Theory behind GAN 2 摘要 本文主要讨论了GAN的理论知识。本文介绍了在GAN模型的训练过程。本文分别阐述了生成器与分辨器的训练细节，并详细描述了整体算法进行。其次本文展示了题为DeGAN : Data-Enriching GAN for Retrieving Representative Samples from a Trained Classifier的论文主要内容。这篇论文提出了DeGAN，该模型可以使用相关领域的数据或者相关性不高的数据生成数据并能利用数据进行较为准确的预测。该文使用CIFAR和MNIST验证了其优越性。最后，本文基于python实现了ARIMA并用于预测时序数据。
Abstract This article mainly discusses the theoretical knowledge of GAN. This article describes the training process of GAN. This article describes the training details of the generator and the discriminator, and the overall algorithm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd06e2d9979d78b10a8ca4e1d15c53c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d36337d448c90e9b2666dc067e0be4ff/" rel="bookmark">
			ubuntu 安装使用annconda，yolact_ros示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装annconda 1、官网下载anaconda下载链接 根据需要下载自己想要的版本，本文下载的是Anaconda3-5.3.0-Linux-x86_64
2、cd 下载目录 bash Anaconda3-5.3.0-Linux-x86_64.sh 提示信息“Do you wish to proceed with the installation of Microsoft VSCode? [yes|no]”，输入no，其余一路回车enter或者yes
3、环境配置 在~/.bashrc中添加
alias start_anaconda='source ~/anaconda3/bin/activate' 之后需要激活anaconda 环境，在终端输入 start_anaconda进入anaconda的base环境。
二、yolact_ros的使用 1、创建yolact环境,python=3.6 conda create -n yolact python=3.6 conda activate yolact 2、安装环境依赖 conda install --channel https://conda.anaconda.org/conda-forge rospkg conda install --channel https://conda.anaconda.org/conda-forge empy pip install pillow pycocotools matplotlib pip install -i https://pypi.douban.com/simple/ pip install opencv-python==4.3.0.38 conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=10.2 -c pytorch 以下是正常运行的Yolact环境配置 文件(yolact.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d36337d448c90e9b2666dc067e0be4ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc926fd30ec82f64e0af09506d1becf4/" rel="bookmark">
			一文通透想颠覆Transformer的Mamba：从SSM、S4到mamba、线性transformer(含RWKV解析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不知读者发现没有，本文标题的信息含量很大，比如
出来了一个新的序列模型：Mamba，其基于SSM或S4(Structured State Space for Sequence Modeling，连起来4个S，故简称S4)发展为S6(S4 models with a selection mechanism and computed with a scan)，其对应的论文为《Mamba: Linear-Time Sequence Modeling with Selective State Spaces》该Mamba模型的提出者为Albert Gu、Tri Dao，前者现在是CMU助理教授，多年来一直推动SSM架构发展，曾在DeepMind 工作，后者为FlashAttention的一作
换言之，除了论文中展示的效果确实不错之外，由于提出者的背景不一般，所以关注的人比较多Transformer统治各大领域近7年了，7年来，挑战Transformer的模型其实不少 (比如linear attention, gated convolution and recurrent models, and SSMs)，该模型能否真正颠覆Transformer的霸权呢？对此，我们可以细究其原理细节，看看其创新到底是否靠谱、力度是否大 加之有一大模型项目开发营的朋友问道，可否在论文100课上解读下Mamba这篇论文，于此，便有了此文，且具备4个特点
清晰易懂：也为「不需要天天看paper的朋友」而写
在ChatGPT诞生后的一年来，以大模型为代表的技术发展特别快，经常一个月会出来很多新的技术、模型
而不一定非得是每天在实验室扎根于科研的人 才有资格去追踪前沿技术发展，还有一大帮可能是出于对前沿技术的了解、兴趣、热爱、应用而想追踪，可这帮朋友平时或因工作或事太多而不一定对每个新技术、新模型都去看一遍论文，即不可能天天看paper
那咋办呢？他们可能通过一些比如公众号之类的文章去了解，但有的公号文章写的不错，有的则写的不够清晰易懂甚至漏洞百出，会因此让读到这种文章的朋友对新技术、新模型产生畏难心理甚至被误导
故，我和我司来了，为帮助更多朋友更好、更快、更细致的了解大模型相关技术及其实践，我个人算是笔耕不辍(我自今年年初以来也史无前例的写了近30篇，详见：大模型/AIGC/ChatGPT系列：原理、论文、代码、实战)、团队和我算讲课不停中英对比：部分关键的阐述中英文对照学习
考虑到这些新技术、新模型刚推出的时候，论文还是相对最严谨的参考，所以本文会延续前几篇文章的风格：对于一些关键的阐述会把原英文的表述用斜体且淡色的黑体表示，毕竟有的描述对其翻译相比，用原英文阐述更精准足够细致：从HiPPO、SSM、S4起步，逐步推导到Mamba
目前介绍mamba模型的文章，少部分写得很不错，大部分不是这个细节没深入，便是那个细节没深入，考虑到如果很多关键细节没有介绍的话，那没法彻底理解mamba模型
因此，本文会尽可能兼顾所有必须写清楚的细节(比如如果不理解SSM和S4则无法理解mamba模型，故本文会从HiPPO、SSM、S4起步，逐步推导到mamba)，尽可能一文通透mamba模型足够全面：Mamba之外，更精讲「线性Transformer」相关
友人钟博士曾评论，不带点积注意力机制的开源模型中，有希望超越带注意力机制的Llama架构的，一个是mamba，一个便是TransnormerLLM
mamba之外，为帮助大家更深入、更全面的理解不带点积注意力机制的线性transformer，本文第三部分将精讲国内的两个相关工作：TransnormerLLM和RWKV 第一部分 背景知识：Transformer时间复杂度、HiPPO、SSM、S4 1.1 Transformer的二次复杂度 通过之前本博客内的另一篇文章《通透理解FlashAttention与FlashAttention2：让大模型上下文长度突破32K的技术之一》，可知
简单理解的话，计算复杂度和序列长度的平方成正比，可以看一个小例子，比如两个相乘的矩阵大小分别为() 和()，矩阵乘法的一种计算方式是使用第一个矩阵的每一行与第二个矩阵的每一列做​点乘​
因为我们需要拿第一个矩阵的每一行去与第二个矩阵的每一列做点乘，所以总共就需要 次点乘。而每次点乘又需要 次乘法，所以总复杂度就为 精确理解的话，当输入批次大小为 ​ ，序列长度为 ​ 时，
​ 层transformer模型的计算量为 ​，​则代表词向量的维度或者隐藏层的维度(隐藏层维度通常等于词向量维度)
但这个结果是怎么一步一步计算得到的呢？请看原文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc926fd30ec82f64e0af09506d1becf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1f6e64a14cc798a7a47ed22524524d/" rel="bookmark">
			中心性算法归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 中心性算法不仅是在我所学习的计算机网络当中起很重要的作用，在交通网络、社交网络、信息网络、神经网络当中也有很多的应用例子。今天我在这里总结一下场景的几种中心性算法。
参考文献 Python NetworkX库
偏心中心性（Eccentricity Centrality） 偏心中心性是一种用于衡量网络中节点重要性的图论指标。这种中心性度量基于每个节点到网络中所有其他节点的最短路径的最大值。具体而言，一个节点的偏心中心性是由其到达网络中所有其他节点的最短路径中最长的那一个决定的。
下图中计算节点s的偏心中心性时，最远节点为t且距离为3，那么s的偏心中心性就是1/3
接近中心性（Closeness Centrality） 这是一个节点到网络中所有其他节点的平均最短路径长度的倒数。直观地说，接近中心性高的节点可以快速到达网络中的其他节点。这个指标在需要快速传播信息的网络中非常有用。
上图中计算节点s的中心性时，就计算它到所有节点的距离之和，再取倒数就行，标准化的话还需要再乘以节点数N-1
以上两种中心性算法的缺陷 如果在有向图中，两个节点的最短距离为无限大，也就是没有路径到达，那么中心性为0，就无法比较，所以以上两种中心性算法只能应用在强连通有向图当中。无向图当中，如果存在孤立点，也就是没有任何连接的节点，也无法应用以上两种中心性算法。
度中心性（Degree Centrality） 这是最直观的中心性定义，即一个节点的度（与其相连的边的数量）。在有向图中，我们可以进一步区分入度中心性（指向节点的边的数量）和出度中心性（从节点出发的边的数量）。度中心性是网络分析中最常用的中心性指标之一。
比如下面有向图当中，S的出度中心性为2，入度中心性为0
特征向量中心性（Eigenvector Centrality） 这是一个节点的重要性不仅取决于它有多少邻居，而且还取决于它的邻居是多么的重要。换句话说，如果一个节点与多个重要的节点相连，那么这个节点也被认为是重要的。这个指标在识别影响力大的节点方面非常有用，例如在社交网络分析中。
特征向量中心性需要计算邻接矩阵的特征值和对应的特征向量等，计算较为复杂，参照NetworkX库。
注意：在应用到有向图时，最大连通子图以外的节点中心性为0，而且最大特征值和特征向量可能不唯一，所以推荐将特征向量中心性应用到强连通无向图。
介数中心性（Betweenness Centrality） 这是一个节点在网络中所有节点对之间的所有最短路径中出现的次数。直观地说，介数中心性高的节点在网络中的信息流动中起着重要的作用。
介数中心性基于这样的假设：网络中的某些节点对于不同节点间的信息流动或互动起到关键的桥梁作用。它不仅仅考虑了一个节点的直接连接数量（如度中心性所做的那样），而是考虑了节点在连接网络中不同部分的能力。因此，即使一个节点的直接连接数不多，但如果它位于网络的关键位置（如连接两个大社交群体的桥梁），那么它的介数中心性也可能很高。
介数中心性在多种场景下非常有用，特别是在理解网络中信息流动、资源分配以及社交影响力方面。它帮助识别那些可能不是最明显的重要节点，但对于网络的整体结构和功能却至关重要的节点。
我们也可以通过下面的公式来理解，我们假设c(v) 代表节点 v 的介数中心性，σ(i, j)表示节点 i 和 j （i，j∈所有节点V）之间所有最短路径的集合，σ(i, j|v) 表示所有通过节点 v 的最短路径的总和。这样我们就能知道节点v的重要性。
以下是两种由介数中心性衍生出来的中心性算法 最短路径中心性（Shortest Path Centrality） 这是一个节点在网络中所有节点对之间的所有最短路径中出现的次数。这与介数中心性非常相似，但通常用于加权网络，其中边的权重表示节点之间的距离或成本。
在NetworkX库当中，我们可以用betweenness_centrality算法当中的weight参数去定义每条边的权重，不然的话所有路径都是相同的权重。
组介数中心性（Group Betweenness Centrality） 这是一组节点在网络中所有节点对之间的所有最短路径中出现的次数。这个指标用于识别一组节点在网络中的整体重要性。
假设计算一组节点C的组介数中心性 c（C）组介数中心性，其中 σ(i, j) 代表节点 i 和 j（i，j∈所有节点V） 之间所有最短路径对的集合。σ(i, j|C) 代表的是所有通过群组 C 中任何节点的最短路径对的分数之和。计算之前，我们先要定义这组节点C的数目。
网页排名算法（PageRank） PageRank是一种用于网页排名的算法，可以看作是特征向量中心性的一种变体，适用于有向图，特别是网页链接网络。PageRank 的核心思想基于这样一个假设：重要的网页很可能被其他重要网页所链接。
这个算法基于两个关键原则：
链接数量：如果一个网页被许多其他网页链接（引用），那么这个网页被认为是重要的，因此应该有一个较高的PageRank值。链接质量：如果一个网页被已经被认为重要（即具有高PageRank值）的网页所链接，那么这个链接对该网页的PageRank值的贡献会更大。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560f17cd3354dc5a604fea96dba0f305/" rel="bookmark">
			3步实现用Python防止微信消息撤回功能！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用微信时，如果发错消息，可以撤回，但你有没有想过在某些特殊情况下，防止对方撤回消息呢？
今天我们就使用Python实现一下查看好友撤回的微信消息的功能。运行程序，手机端微信扫描弹出的二维码即可登录网页版微信，程序会将网页版微信收到的所有消息都缓存下来，当检测到有消息（语音、文字、图片等）撤回时，将撤回消息的缓存版本通过文件传输助手发送到自己的手机上，如下图所示。
实现微信消息防撤回功能主要通过Python内置的os模块、re模块、time模块、platform模块，以及第三方模块itchat实现。具体步骤如下：
（1）由于使用了第三方模块itchat，所以需要先安装该模块。使用pip命令安装模块的命令如下：
pip install itchat （2）导入程序中需要使用的模块，具体代码如下：
import re import os import time import itchat import platform from itchat.content import * （3）实现逻辑。首先使用platform模块获取操作系统底层的数据，根据不同的操作系统传入不同的登录参数，登陆成功后，缓存接收到的所有信息并监听是否有消息撤回。代码如下：
import re import os import time import itchat import platform from itchat.content import * msg_info = {} face_package = None # 处理接收到的信息 @itchat.msg_register([TEXT, PICTURE, FRIENDS, CARD, MAP, SHARING, RECORDING, ATTACHMENT, VIDEO], isFriendChat=True, isMpChat=True) def handle_rsg(msg): global face_package # 接收消息的时间 msg_time_receive = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) # 发信人 try: msg_from = itchat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/560f17cd3354dc5a604fea96dba0f305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e14b338d14383feb7780c450fd6e4c/" rel="bookmark">
			[215]BloomFilter布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Bloom Filter概念和原理HashMap 的问题布隆过滤器数据结构集合表示和元素查询错误率估计最优的哈希函数个数位数组的大小小结 BloomFilter实例对比、参数选择、代码实现实例对比Bloom Filter的算法Bloom Filter参数选择Bloom Filter实现代码 实际应用场景公式推导 Bloom Filter概念和原理 Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。
HashMap 的问题 讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。
还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。
布隆过滤器数据结构 布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：
如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成**多个哈希值，**并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：
Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：
值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e14b338d14383feb7780c450fd6e4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec0c3c29e30973ecd3046b27e7d32cc/" rel="bookmark">
			关于“Python”的核心知识点整理大全37
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
13.6.2 响应外星人和飞船碰撞
game_stats.py
settings.py
alien_invasion.py
game_functions.py
ship.py
注意
13.6.3 有外星人到达屏幕底端
game_functions.py
13.6.4 游戏结束
game_stats.py
game_functions.py
13.7 确定应运行游戏的哪些部分
alien_invasion.py
13.8 小结
第１4 章
记 分
14.1 添加 Play 按钮
game_stats.py
往期快速传送门👆（在文章最后）：
感谢大家的支持！欢迎订阅收藏！专栏将持续更新！
13.6.2 响应外星人和飞船碰撞 现在需要确定外星人与飞船发生碰撞时，该做些什么。我们不销毁ship实例并创建一个新的 ship实例，而是通过跟踪游戏的统计信息来记录飞船被撞了多少次（跟踪统计信息还有助于记 分）。 下面来编写一个用于跟踪游戏统计信息的新类——GameStats，并将其保存为文件 game_stats.py：
game_stats.py class GameStats(): """跟踪游戏的统计信息""" def __init__(self, ai_settings): """初始化统计信息""" self.ai_settings = ai_settings 1 self.reset_stats() def reset_stats(self): """初始化在游戏运行期间可能变化的统计信息""" self.ships_left = self.ai_settings.ship_limit 在这个游戏运行期间，我们只创建一个GameStats实例，但每当玩家开始新游戏时，需要重 置一些统计信息。为此，我们在方法reset_stats()中初始化大部分统计信息，而不是在__init__() 中直接初始化它们。我们在__init__()中调用这个方法，这样创建GameStats实例时将妥善地设置 这些统计信息（见Ø），同时在玩家开始新游戏时也能调用reset_stats()。 当前只有一项统计信息——ships_left，其值在游戏运行期间将不断变化。一开始玩家拥有 的飞船数存储在settings.py的ship_limit中：
settings.py # 飞船设置 self.ship_speed_factor = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ec0c3c29e30973ecd3046b27e7d32cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bfe6356664b5de8b56ca98f54c92b6/" rel="bookmark">
			【Git报错】Couldn‘t connect to server/Connection was reset最全总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道Hexo小白最常用到的两条操作为:
hexo g #生成页面 hexo d #部署发布 但在笔者熟悉和摸索这个博客框架时，因为频繁使用这两条操作而遇到了各种报错，但大体上为以下几类情况：
Connection was reset 报错信息大致如下👇
fatal: unable to access ‘https://github.com/xxxx.github.io.git/’: Recv failure: Connection was reset
解决办法 依次将如下两条语句复制到git中后，点击回车。
git config --global --unset http.proxy git config --global --unset https.proxy 然后在电脑上同时按下win+R,在运行窗口中输入cmd打开命令提示符，输入以下指令清理DNS缓存：
ipconfig/flushdns 如此，就可以正常地将更改上传到博客了。别的地方使用Git也是同样道理。
Connection timed out/ Couldn’t connect to server 报错信息大致如下👇
fatal: unable to access ‘https://github.com/Alpaca10086zyys/Alpaca10086zyys.github.io.git/’: Failed to connect to github.com port 443 after 21106 ms: Couldn’t connect to server
解决办法 在git bash的命令行里输入：
git config --global --unset http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54bfe6356664b5de8b56ca98f54c92b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ad460cfa87195504f7cfb840edbe49/" rel="bookmark">
			javascript的Map和Set概念以及区别和使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map和Set JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。
Map Map是一组键值对的结构，具有极快的查找速度。
举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：
var names = ['Michael', 'Bob', 'Tracy']; var scores = [95, 75, 85]; 当然可以用一个object的对象来完成这件事，之后在讨论这个问题。
给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。
果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95 首先由此可见Map是一个集合：而且是键值对的集合。但是此集合的元素项是键值对，通过[]语法规范来保证结构的正确性 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：
var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value m.set('Bob', 59); m.has('Adam'); // 是否存在key 'Adam': true m.get('Adam'); // 67 m.delete('Adam'); // 删除key 'Adam' m.get('Adam'); // undefined key值的多样性体现 var m = new Map([['Michael', 95], [true, 75], ['Tracy', 85]]); m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ad460cfa87195504f7cfb840edbe49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54c86dbd9d0b00286279d84ba1c4a4f/" rel="bookmark">
			Conda命令、Miniconda3基础安装使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Conda命令、Miniconda3基础安装使用教程 Minicodna3下载地址：https://docs.conda.io/projects/miniconda/en/latest/index.html
正常安装完毕后，出现conda的控制台：
默认的源下载太慢，换清华源，依次执行以下命令：
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 查看conda配置信息
conda info 清理conda（全部）
conda clean --all 创建虚拟环境’django’，指定python版本为3.9：
conda create -n django python=3.9 激活环境：
conda activate django 退出环境：
conda deactivate 删除环境
conda remove -n django --all 查看所有环境：
conda env list 创建的虚拟环境默认在C盘，如果要修改执行以下命令：
conda config --add envs_dirs G:\install\miniconda3\envs 或直接修改配置文件（C:\Users\用户名\.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54c86dbd9d0b00286279d84ba1c4a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5401e860df4dd15a191923f74b153d/" rel="bookmark">
			log4j rename方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		log4j日志切割 os.rename
[root@zz test]# cat a2.py import os
os.rename('a.txt','b.txt');
[root@zz test]# cat a.txt 111111111111111111111
222222222222222222222
[root@zz test]# ls
a1.py a2.py a.txt tst.log.1 tst.log.2
[root@zz test]# python ^C
[root@zz test]# stat a.txt
File: `a.txt'
Size: 44 Blocks: 8 IO Block: 4096 regular file
Device: 803h/2051d Inode: 948701 Links: 1
Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)
Access: 2023-12-23 00:52:55.466002465 +0800
Modify: 2023-12-23 00:52:50.717999741 +0800
Change: 2023-12-23 00:52:50.717999741 +0800
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5401e860df4dd15a191923f74b153d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c94bc0622e426d8db5f9eaf5c76a2e/" rel="bookmark">
			最全Hadoop实际生产集群高可用搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境准备 1.1 集群规划 序号bigdata-001bigdata-002bigdata-003bigdata-004bigdata-005IPx x xx x xxxxxxxxxx组件hadoop1hadoop2hadoop3hadoop4hadoop5内存64G64G128G128G128GCPU核1616323232Hadoop-3.3.4NameNodeNameNodeDataNodeDataNodeDataNodeResourceManagerResourceManagerNodeManagerNodeManagerNodeManagerDFSZKFailoverControllerDFSZKFailoverControllerJournalNodeJournalNodeJournalNodeHistoryServerZookeeper-3.5.7zkzkzk 1.1 添加新用户并修改权限 useradd hadoop passwd hadoop visudo # 在root ALL=(ALL) ALL一行下面添加 hadoop ALL=(ALL) NOPASSWD: ALL 1.2 配置hosts sudo vim /etc/hosts xxxx hadoop1 xxxx hadoop2 1.3 SSH免密登录 mkdir ~/.ssh cd ~/.ssh ssh-keygen -t rsa -m PEM touch authorized_keys #将authorized_keys配置好后，在编其他机器增加ssh的authorized_keys内入复制过去（必须有该机器的id_rsa.pub） 2.JDK安装 tar -zxvf jdk-8u212-linux-x64.tar.gz -C /data/module/ mv jdk1.8.0_212/ jdk1.8.0_212 #设置环境变量配置JDK sudo vim /etc/profile.d/my_env.sh #添加JAVA_HOME export JAVA_HOME=/data/module/jdk1.8.0_212 export PATH=$PATH:$JAVA_HOME/bin # 让环境变量生效 source /etc/profile.d/my_env.sh # 测试JDK是否安装成功 java -version #每一台机器都需要配置 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c94bc0622e426d8db5f9eaf5c76a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9d1832ef716afd80d7d041139afb1d/" rel="bookmark">
			Hadoop集成对象存储和HDFS磁盘文件存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境配置 1.1 版本说明 组件版本是否必须其他事项Hadoop3.3.0+是hadoop3.3.0之后原生支持国内主要对象存储Hive3.1.3否实测没有Hive也可以使用sparksql，使用hive更好的管理HDFS数据spark3.3.1是hive和spark整合后，语法为HSQL，自定义函数按照hive使用即可cos未知是 说明：由于部分生产日志过大，且需要对近期数据进行分析，HDFS文件存储成本较高，因此定于将近期热数据存储与hdfs，冷数据存储在更便宜的对象存储之上。
1.2 相关组件官网 Hadoop官网：https://hadoop.apache.org/docs/r3.3.4/hadoop-cos/cloud-storage/index.html
腾讯对象存储cos使用官网：https://cloud.tencent.com/document/product/436/6884
spark官网：https://spark.apache.org/docs/3.3.1/
1.3 cos与hadoop集成特征 支持 Hadoop MapReduce 和 Spark 将数据写入 COS 并直接从 COS 中读取。
实现了Hadoop文件系统的接口，提供了与HDFS相同的伪层次目录结构。
支持大文件分段上传。单个文件最大支持19TB
高性能和高可用性。Hadoop-COS 与 HDFS 的性能差异不超过 30%。
1.4 使用限制 对象存储不是文件系统，它有一些限制：
对象存储是一种键值存储，它天然不支持分层目录。通常，使用对象键中的目录分隔符来模拟分层目录，例如“/hadoop/data/words.dat”。
COS 对象存储目前不支持对象的追加操作。这意味着您不能将内容附加到现有对象（文件）的末尾。
删除和重命名操作都是非原子的，这意味着操作会被中断，操作结果可能会处于不一致的状态。
对象存储有不同的授权模型：
目录权限报告为 777。
文件权限报告为 666。
文件所有者被报告为本地当前用户。
文件组也被报告为本地当前用户。
支持大文件（最大40TB）分段上传，但分段数量限制为10000。
每次列出的文件数量限制为 1000 个。
2.Hadoop与HDFS集成 详见本博客《最全Hadoop实际生产集群高可用搭建》
3.Hadoop与yarn集成 3.1 概念 Bucket：COS 中存储数据的容器，名称由用户自定义的 BucketName 和用户 AppID 组成。
Appid：用户维度的唯一资源标识符。
SecretId：用于验证用户身份的 ID
SecretKey：用于验证用户身份的密钥
Region：桶所在的区域。
CosN：Hadoop-COS 使用cosn作为其 URI 方案，因此 CosN 通常用来指代 Hadoop-COS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9d1832ef716afd80d7d041139afb1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7397806aa8d00934f06c1c5ece383267/" rel="bookmark">
			最全HSQL命令大全(Hive命令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章 算数运算 1.1 加法： + 语法：A + B
操作类型：所有数值类型
说明： 返回A与B相加的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。比如，int + int 一般结果为int类型，而 int + double 一般结果为double类型
hive&gt; select 1 + 9 from iteblog; 10 hive&gt; create table iteblog as select 1 + 1.2 from iteblog; hive&gt; describe iteblog; double 1.2 减法： - 语法：A - B
操作类型：所有数值类型
说明： 返回A与B相减的结果。结果的数值类型等于A的类型和B的类型的最小父类型（详见数据类型的继承关系）。比如，int – int 一般结果为int类型，而 int – double 一般结果为double类型
hive&gt; select 10 – 5 from iteblog; 5 hive&gt; create table iteblog as select 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7397806aa8d00934f06c1c5ece383267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7c806a64f903a96f52369157c70cca/" rel="bookmark">
			Ubuntu18.04安装多个pcl、opencv3.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unbuntu 18.0.43 SLAM配置环境 一、多个pcl安装 Ubuntu18.04自带pcl版本为1.8，安装位置在/usr/include/pcl-1.8。最近项目要求pcl1.9，考虑安装多个pcl库，根据安装目录设置选用哪个pcl。
1、下载pcl 手动pcl压缩包下载链接
终端下载如下：
-b是分支的意思，这里对应的PCL版本为1.9.1，可以根据需求在链接中寻找pcl的版本，根据实际情况更改 -b后面的 pcl-1.9.1为想要的版本。
git clone -b pcl-1.9.1 git@github.com:PointCloudLibrary/pcl.git cd pcl-pcl-1.9.1 mkdir build cd build #将pcl1.9安装在 /usr/local/include/pcl19目录下 cmake -DCMAKE_INSTALL_PREFIX=/usr/local/include/pcl19 \ -DBUILD_GPU=ON -DBUILD_apps=ON -DBUILD_examples=ON .. #编译 make -j4 #安装 sudo make install 2、多版本使用 根据pcl安装目录选用pcl版本，在项目CMakeList.txt文件中设置如下：
set(PCL_DIR "/usr/local/include/pcl19") 或者 set(PCL_DIR "/usr/local/pcl19/share/pcl-1.9") find_package(PCL 1.9 REQUIRED) 二、安装Eigen3.1 Eigen库下载链接
1、下载解压、编译、安装eigen 如需多个版本安装使用可以参考pcl编译方式
cd eigen3.1.3 mkdir build cd build cmake .. make sudo make install sudo cp -r /usr/local/include/eigen3 /usr/include 2、查看eigen版本 pkg-config --modversion eigen3 三、安装OpenCV3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7c806a64f903a96f52369157c70cca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c40b243222e04e648b2d78ae4e01abe/" rel="bookmark">
			Apollo定位之NDT定位实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验云平台：Apollo定位之NDT定位实践_Apollo课程 实验流程 1、制作NDT地图 首先解压录制好的record包，得到激光雷达点云和姿态信息，然后再校正激光点云姿态，最后调用NDT制图工具生成NDT地图。
1.1 解压数据包 解压数据包，得到原始的激光雷达点云信息和车辆姿态信息，需要注意点云的cloud_topic要与数据包中的点云topic一 致，如果不清楚，可以通过 cyber_recorder info 命令查看数据包中的cloud_topic信息。
cyber_record_parser --bag_file=sensor_rgb.record --out_folder=/apollo/data --cloud_topic=/apollo/sensor/velodyne64/compensator/PointCloud2 1.2 校正pose信息 解压之后，再通过imu的信息对车辆的姿态进行插值，得到校正之后的车辆pose。
poses_interpolator --input_poses_path=/apollo/data/pcd/odometry_loc.txt --ref_timestamps_path=/apollo/data/pcd/pcd_timestamp.txt --extrinsic_path=modules/localization/msf/params/velodyne_params/velodyne64_novatel_extrinsics_example.yaml --output_poses_path=/apollo/data/pcd/poses.txt 注意：这里面临先有鸡、还是先有蛋的问题，上述方法通过IMU插值进行校正pose，实际上最好通过ndt进行校正，得到更准确的pose。
为了加快速度，这里我们只取前20张点云制作地图（正常制作的时候可以跳过！）
mv /apollo/data/pcd/poses.txt /apollo/data/pcd/poses_bak.txt head -20 /apollo/data/pcd/poses_bak.txt &gt; /apollo/data/pcd/poses.txt 完成上述步骤之后，确认 poses.txt 中是否有数据。
cat /apollo/data/pcd/poses.txt 1.3 生成NDT地图 有了激光雷达点云信息和准确的pose之后，根据这些信息就可以生成NDT地图了。注意这里采用的是NDT的强度信息，因此如果点云中缺少强度信息，则实现不了定位。
ndt_map_creator --pcd_folders=/apollo/data/pcd --pose_files=/apollo/data/pcd/poses.txt --resolution_type=single --resolution=1 --zone_id=10 --map_folder=/apollo/modules/localization/map/ndt_map/local_map 生成好的地图保存在 /apollo/modules/localization/map/ndt_map/local_map 路径下，通过 ls 命令查看该路径下是否有以下文件，如果存在，那么恭喜你！NDT地图就制作成功了！
ls /apollo/modules/localization/map/ndt_map/local_map 2、运行NDT模块 制作好NDT地图之后，接下来，我们就可以运行NDT模块进行融合定位了，以下是运行NDT定位的步骤
2.1 修改配置 首先我们需要根据车辆的情况修改以下配置修改 /apollo/modules/common/data/global_flagfile.txt 中的地图路径 --map_dir 为我们保存地图的路径
--map_dir=/apollo/modules/localization/map 设置地图的UTM zone id，修改激光雷达的外参文件和topic，要与数据包中实际发布的一致。打开 /apollo/modules/localization/conf/loc alization.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c40b243222e04e648b2d78ae4e01abe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb15558309f617355fc251052eaacbe/" rel="bookmark">
			STM32的以太网外设&#43;PHY（LAN8720）使用详解（6）：以太网数据接收及发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 工具准备 1.野火 stm32f407霸天虎开发板 2.LAN8720数据手册 3.STM32F4xx中文参考手册 1 以太网数据接收及发送 1.1 以太网数据接收（轮询） 1.1.1 检查是否接收到一帧完整报文 使用轮询的方式接收以太网数据是一种简单但是效率低下的方法，为了保证及时处理以太网数据我们需要在主循环内高频轮询是否接收到了以太网数据。轮询的函数为ETH_CheckFrameReceived，内容如下：
uint32_t ETH_CheckFrameReceived(void) { /* check if last segment */ if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) != (uint32_t)RESET)) { DMA_RX_FRAME_infos-&gt;Seg_Count++; if (DMA_RX_FRAME_infos-&gt;Seg_Count == 1) { DMA_RX_FRAME_infos-&gt;FS_Rx_Desc = DMARxDescToGet; } DMA_RX_FRAME_infos-&gt;LS_Rx_Desc = DMARxDescToGet; return 1; } /* check if first segment */ else if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) != (uint32_t)RESET)&amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) == (uint32_t)RESET)) { DMA_RX_FRAME_infos-&gt;FS_Rx_Desc = DMARxDescToGet; DMA_RX_FRAME_infos-&gt;LS_Rx_Desc = NULL; DMA_RX_FRAME_infos-&gt;Seg_Count = 1; DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } /* check if intermediate segment */ else if(((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_OWN) == (uint32_t)RESET) &amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_FS) == (uint32_t)RESET)&amp;&amp; ((DMARxDescToGet-&gt;Status &amp; ETH_DMARxDesc_LS) == (uint32_t)RESET)) { (DMA_RX_FRAME_infos-&gt;Seg_Count) ++; DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet-&gt;Buffer2NextDescAddr); } return 0; } 当以太网帧大于我们设置的DMA描述符buffer大小时，以太网帧将会被分成若干段被存储在不同的DMA描述符中，DMA描述符使用接收描述符字0来表示当前DMA描述符是第一个描述符或最后一个描述符或中间描述符：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb15558309f617355fc251052eaacbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b1b352a8e23055b3cea79315072d17/" rel="bookmark">
			STM32的以太网外设&#43;PHY（LAN8720）使用详解（5）：MAC及DMA配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 工具准备 1.野火 stm32f407霸天虎开发板 2.LAN8720数据手册 3.STM32F4xx中文参考手册 1 MAC及DMA配置 1.1 使能ETH时钟 stm32的ETH外设挂载在AHB1总线上，位于RCC_AHB1ENR的bit25-bit27：
相关语句如下：
RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx | RCC_AHB1Periph_ETH_MAC_Rx, ENABLE); 1.2 复位MAC寄存器 直接调用ETH_DeInit函数来复位ETH外设
void ETH_DeInit(void) { RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE); RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE); } 上述语句操作的寄存器如下：
首先设置位25为1复位以太网MAC（复位MAC寄存器到默认值），然后设置为0取消复位。
1.3 复位MAC DMA控制器 首先调用ETH_SoftwareReset函数复位MAC的DMA
void ETH_SoftwareReset(void) { /* Set the SWR bit: resets all MAC subsystem internal registers and logic */ /* After reset all the registers holds their respective reset values */ ETH-&gt;DMABMR |= ETH_DMABMR_SR; } 上述语句操作的寄存器如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b1b352a8e23055b3cea79315072d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666e91de1bf4fb61d8e3d0caba300288/" rel="bookmark">
			STM32的以太网外设&#43;PHY（LAN8720）使用详解（2）：硬件设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 工具准备 1.野火 stm32f407霸天虎开发板 2.LAN8720数据手册 3.STM32F4xx中文参考手册 1 PHY（LAN8720）硬件配置 1.1 硬件配置引脚说明 在LAN8720上电或复位时会读取一些特定引脚的电平，根据电平来进行硬件配置。LAN8720的引脚分布如下：
注意，LAN8720有些引脚内部自带上/下拉，定义如下：
1.1.1 PHY地址配置 LAN8720的PHYAD[0]用来配置PHY地址的bit0，当接入了多个PHY时可以用来区分不同的PHY。该引脚自带内部下拉，同时我们也只用到了一片LAN8720，因此悬空即可。
1.1.2 模式配置 这里的模式指的是传输速度（10Mbps/100Mbps）以及全/半双工，通常我们将MODE引脚都设置为1，MODE引脚内部自带上拉，因此MODE[2:0]引脚无需外加上拉电阻。也就是让LAN8720启用自动协商，它会自动寻找最优的工作方式。关于模式配置引脚说明如下：
MODE[2:0]是复用引脚，复用功能如下:
1.1.3 1.2V内部电压源配置 REGOFF引脚决定LAN8720选择外部还是内部1.2V电源，内部自带下拉电阻。当输入电平为低时选择内部1.2V电源，当输入电平为高时选择外部1.2V电源。这里我们选择内部1.2V电源，无需外加下拉电阻。
1.1.4 nINT/REFCLKO配置 当nINTSEL引脚电平为低时nINT/REFCLKO被设置为50MHz时钟输出，当nINTSEL引脚电平为高时nINT/REFCLKO被设置为中断信号输出（低电平有效）。该引脚内部自带上拉，我们通常使用LAN8720提供50MHz时钟，因此该引脚需要外部下拉。
2 PHY（LAN8720）和MCU连接 由于LAN8720仅支持RMII和SMI接口，因此PHY和MCU的连接就通过RMII和SMI接口实现。原理图设计如下：
这里将REGOFF和nINTSEL引脚下拉，也就是使用内部1.2V电源、REF_CLK输出50MHz时钟。RMII和SMI接口连线按照标准进行连接即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12bf81b8ec4503504823fac58adb36db/" rel="bookmark">
			java中io流(文件流)的使用、资源加载笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 脉络 FileInputStream读取Reader按行读取文件和输出文件读取目录下的所有文件(不递归所有目录)bufferWriter 为什么最后要flush一下bufferWriter设置大小无效写文件无效字节流读取并写入到一个文件restTempalte访问rest服务(小文件一次性)restTemplate访问rest服务(大文件以流的方式)原始的response返回文件流spring返回文件流原始的response返回文件流的方式文件名fileName设置文件名如何从文件流中获取文件名MultipartFile获取文件名很方便 其他Content-Disposition 中的小细节httpclient获取文件流图片在浏览器展示和下载的区别 资源加载 io流是很基础，很常用的工具。掌握好会很有用。 另，nio比io功能强大了不少，建议了解下。 为了方便演示，try catch，finally代码在这里不写了，实际中一定要加上。
相关的文件要先准备好。
inputstream是一个接口提供读的方法。
实际中要和FileInputStream配合
脉络 - InputStream - InputStreamReader # 可以读char - FileInputStream # 可以传入文件名 - Reader - InputStreamReader - FileReader - BufferedReader FileInputStream读取 例子代码：
public static void main(String[] args) throws Exception { String userHome = System.getProperties().getProperty("user.home"); // 用户目录，如：C:\Users\chushiyun String fileName = userHome+"/01.png"; // 文件路径 InputStream in = new FileInputStream(fileName); byte[] bytes = new byte[100]; // 一次读取多少 int temp = 0; // 记录读取的byte数 // read() 读取一个字节 // read(bytes) 读满bytes字节 // read(bytes,5,20) 从5开始 读取20个字节 while ((temp = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12bf81b8ec4503504823fac58adb36db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea2cb818a0767f1f476cab98d313eb0/" rel="bookmark">
			a标签锚链接到顶部加过度效果css
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建锚链接 &lt;!-- 锚链接返回顶部 --&gt; &lt;div class="totop"&gt; &lt;img src="/static/images/header/totop.png" alt="图标" width="20px"&gt; &lt;a href="#app"&gt; 返回顶部 &lt;/a&gt; &lt;/div&gt; 2.样式 .totop { display: none; } .totopshow { cursor: pointer; padding: 10px; display: block; width: 48px; height: 81px; z-index: 100; position: fixed; bottom: 50px; right: 12px; color: #fff; text-align: center; font-size: 14px; background-color: #4e6ef2; border-radius: 3px; } .totop a { display: block; color: #fff; padding-top: 5px; } /* 滚动过度 */ html { scroll-behavior: smooth; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea2cb818a0767f1f476cab98d313eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089a9184950b239c9de7e61e7605f74b/" rel="bookmark">
			大创项目推荐 深度学习&#43;opencv&#43;python实现车道线检测 - 自动驾驶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 实现效果3 卷积神经网络3.1卷积层3.2 池化层3.3 激活函数：3.4 全连接层3.5 使用tensorflow中keras模块实现卷积神经网络 4 YOLOV56 数据集处理7 模型训练8 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **基于深度学习的自动驾驶车道线检测算法研究与实现 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 从汽车的诞生到现在为止已经有一百多年的历史了，随着车辆的增多，交通事故频繁发生，成为社会发展的隐患，人们的生命安全受到了严重威胁。多起事故发生原因中，都有一个共同点，那就是因为视觉问题使驾驶员在行车时获取不准确的信息导致交通事故的发生。为了解决这个问题，高级驾驶辅助系统（ADAS）应运而生，其中车道线检测就是ADAS中相当重要的一个环节。利用机器视觉来检测车道线相当于给汽车安装上了一双“眼睛”，从而代替人眼来获取车道线信息，在一定程度上可以减少发生交通事故的概率。
本项目基于yolov5实现图像车道线检测。
2 实现效果 3 卷积神经网络 受到人类大脑神经突触结构相互连接的模式启发，神经网络作为人工智能领域的重要组成部分，通过分布式的方法处理信息，可以解决复杂的非线性问题，从构造方面来看，主要包括输入层、隐藏层、输出层三大组成结构。每一个节点被称为一个神经元，存在着对应的权重参数，部分神经元存在偏置，当输入数据ｘ进入后，对于经过的神经元都会进行类似于：y＝w*x＋b的线性函数的计算，其中ｗ为该位置神经元的权值，b则为偏置函数。通过每一层神经元的逻辑运算，将结果输入至最后一层的激活函数，最后得到输出output。
3.1卷积层 卷积核相当于一个滑动窗口，示意图中３x３大小的卷积核依次划过６x６大小的输入数据中的对应区域，并与卷积核滑过区域做矩阵点乘，将所得结果依次填入对应位置即可得到右侧４x４尺寸的卷积特征图，例如划到右上角３x３所圈区域时，将进行０x０＋１x１＋２x１＋１x１＋０x０＋１x１＋１x０＋２x０x１x１＝６的计算操作，并将得到的数值填充到卷积特征的右上角。
3.2 池化层 池化操作又称为降采样，提取网络主要特征可以在达到空间不变性的效果同时，有效地减少网络参数，因而简化网络计算复杂度，防止过拟合现象的出现。在实际操作中经常使用最大池化或平均池化两种方式，如下图所示。虽然池化操作可以有效的降低参数数量，但过度池化也会导致一些图片细节的丢失，因此在搭建网络时要根据实际情况来调整池化操作。
3.3 激活函数： 激活函数大致分为两种，在卷积神经网络的发展前期，使用较为传统的饱和激活函数，主要包括sigmoid函数、tanh函数等；随着神经网络的发展，研宄者们发现了饱和激活函数的弱点，并针对其存在的潜在问题，研宄了非饱和激活函数，其主要含有ReLU函数及其函数变体
3.4 全连接层 在整个网络结构中起到“分类器”的作用，经过前面卷积层、池化层、激活函数层之后，网络己经对输入图片的原始数据进行特征提取，并将其映射到隐藏特征空间，全连接层将负责将学习到的特征从隐藏特征空间映射到样本标记空间，一般包括提取到的特征在图片上的位置信息以及特征所属类别概率等。将隐藏特征空间的信息具象化，也是图像处理当中的重要一环。
3.5 使用tensorflow中keras模块实现卷积神经网络 ​
class CNN(tf.keras.Model): def __init__(self): super().__init__() self.conv1 = tf.keras.layers.Conv2D( filters=32, # 卷积层神经元（卷积核）数目 kernel_size=[5, 5], # 感受野大小 padding='same', # padding策略（vaild 或 same） activation=tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089a9184950b239c9de7e61e7605f74b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7346bcd1d36b271da3564fb388edc4/" rel="bookmark">
			[ToolsChain] 关于cmake 编译时候编译器寻找路径问题，两种解决即使findpackage也提示找不到头文件或库的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 自动安装了anaconda 之后 （以及使用源码编译安装，apt安装等不同方式）安装库，我编写cmakelist的时候会经常找不到一些已经确认安装好的库，如有此篇记录，防止corona后遗症。
outline 继续修改cmakelist添加cmake编译路径 我的报错示例 我使用apt get方式安装的glog，
find了package 和add了头文件和库
依旧报相关错误，根本原因就是找不到对应的库导致的为定义符号问题。
修改cmakelist 既然我是aptget方式安装的，那么可以使用
dpkg-query -L libgoogle-glog-dev | grep libglog 找到头文件 和要使用的库（比如我这里用来动态库so）
Set(GLOG_INCLUDE_DIRS "/usr/include/glog/") Set(GLOG_LIBRARIES "/usr/lib/x86_64-linux-gnu/libglog.so") 重新编译问题解决
ps: 这里也看得出我问题之一就是有一个非常见的系统默认路径？？所以自己设定了
修改cmake查找路径 这个我理解和visual studio； matlab的设置大同小异
比如方法find package没有找的原因就是搜索路径下没有，如此加上去就好了。
cmake -LAH 可以看一下当前已经有的路径
两种方式，一种是只针对本项目，一种是全局的设置。见下：（注意是修改和expand两种）
cmake -DCMAKE_PREFIX_PATH="/usr/include/glog/:/usr/lib/x86_64-linux-gnu/" 运行cmake命令时临时生效，不会影响到其他CMake配置
export CMAKE_PREFIX_PATH="/usr/include/glog/:/usr/lib/x86_64-linux-gnu/" shell中执行这个export命令后，所有后续的cmake命令都会考虑到这个环境变量的值（我理解是本shell 懒得实验了）
export CMAKE_PREFIX_PATH="/usr/include/glog/:/usr/lib/x86_64-linux-gnu/:$CMAKE_PREFIX_PATH" 这个是全局修改的expand模式（不删除）
网上还看到一种方式，可以针对一个cmakelist单独设置一个路径,也就是写在cmakelist里
set(CMAKE_PREFIX_PATH "/path/to/package-config-file-directory" ${CMAKE_PREFIX_PATH}) 感觉人类发明的东西还挺灵活的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a53e89187df992104f7ed262ca5d8f22/" rel="bookmark">
			帆软报表 - 数据显示为列表，但是数据仍全部显示在同一行上？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1 问题截图2 解决办法3 原因分析3.1 数据设置：全是列表 1 问题截图 想要的效果：每行显示一组数据得到的效果：数据全部显示在一行，以逗号隔开 2 解决办法 修改扩展方向。将 “不扩展” 修改为 “纵向” 3 原因分析 3.1 数据设置：全是列表 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051951c03c646741fb4fb5a0bc125e71/" rel="bookmark">
			filebeat 处理日志切割问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		filebeat 4664 root 7rW REG 8,3 0 1338277 /root/filebeat-7/data/filebeat.lock
filebeat 4664 root 8u REG 8,3 5235166 1455582 /root/filebeat-7/data/registry/filebeat/log.json
filebeat 4664 root 9r REG 8,3 20971507 948698 /root/test/tst.log.2
filebeat 4664 root 10r REG 8,3 20971516 948699 /root/test/tst.log.1
filebeat 4664 root 11r REG 8,3 20779494 948700 /root/test/tst.log
[root@zz ~]# filebeat 当从tst.log 切换到tst.log.1的时候,还会继续采集tst.log.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47289a80460ddc6a943547bd0191017/" rel="bookmark">
			python核心阶段（七）—— 包＆模块以及虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.包&amp;模块 概念解释 模块：为了使代码容易维护，可以将一组功能相关的代码写入一个单独的.py文件中，这
个.py文件就被称作一个模块
包： 包是指一个有层次的文件目录结构，它包含多个相关模块或子包；
它和目录的区别是会自动包含一个__init__.py的文件
库： 完成一定功能代码的集合，具体表现可以是一个模块，也可以是一个包 框架： 它是一个架构层面的概念，在实际中，通过一个框架，我们可以实现解决问题的
基本骨架，然后再对细节进行修改填充即可
作用：1）作为工具代码，供其他模块使用 2）对代码进行分解、封装，便于维护
3）防止同一模块内重复命名问题
2.分类 类别使用作用标准包/模块 自动安装，手动import导入
特例：内建包/模块（直接使用）
满足基本功能需求三方包/模块手动下载安装满足比较复杂的功能自定义包/模块自己定义 3.一般操作 3.1 包/模块的创建及基本信息 创建查看基本信息模块 直接创建.py文件
模块名称：去除.py后缀后的文件名
包名称：文件夹名
存放位置：import os print（os.__file__)
查看具体内容：dir（包/模块名称）
包 创建一个文件夹
在文件夹中创建一个__init__.py文件
作用：创建时自动执行文件中的代码
3.2 包/模块的导入 3.2.1 常规导入（import）
语法： import 模块名 或 import 包名.模块名 （可同时导入多个模块，用逗号隔开即可）
我们也可以通过as语句（import 模块名 as 别名）给模块起一个别名，可以简化名称
补充：1）调用时，需要指明包/模块的名称 模块名.xxx
2） 如果我们用import导入一个包，默认不会导入任何模块，我们可以通过设置__init__
让文件自动导入需要的模块
3.2.2 from语句导入 语法：from A import B [as C]
适用：只希望导入一个模块或者包的某一部分；或者从某个位置导入某些资源到当前位置
补充：1）A的范围必须大于B（B必须包含在A中） 包 &gt; 模块 &gt; 模块中的资源
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f47289a80460ddc6a943547bd0191017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f46cf5d7cecfc2114781d34a5129a9f/" rel="bookmark">
			开源公告｜tRPC-Java开发框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、项目简介
tRPC-Java是tRPC开发框架Java语言的实现，符合tRPC设计规范和特点。 同时针对Java开发者生态做了更友好的设计与扩展。
2、架构设计
考虑业内Java开发者现状，框架最低要求JDK8及以上，框架底层默认采用业内最广泛的netty4.1网络模块。框架设计了20多处扩展点，对插件化做了细粒度的设计，同时可以根据业务情况进行自由拆分和组合。除了如图所示的插件能力外，框架额外还设计了：服务事件监听、字节码插件、SPI插件工厂、配置注入等能力。
3、主要特点
tRPC-Java除了tRPC通用特点外，还具有以下特点：
● 要求JDK8及以上版本，框架内部采用更优雅的全链路异步化设计，同时业务线程与框架线程完全隔离，让开发者更容易写出更稳定、高性能的代码。
● 支持最新的JDK21协程能力，开发者非常方便的实现“同步编程，异步执行”的代码，不仅让服务性能更高，同时极大解决代码逻辑维护困难的问题。
● 和Spring、云原生等生态融合，可以复用Java现有流行的生态微服务治理能力。
● 在腾讯内部应用于海内外财富与支付模块、企业管理、云服务、互联网微服务、大数据等场景。
4、项目规划
● 丰富生态，开源更多微服务治理相关的插件和组件。
● 丰富脚手架能力。
● 更多对Mesh能力的支持。
5、项目地址
● 项目官方网站：
https://trpc.group/
● Github主仓库：
https://github.com/trpc-group/trpc-java
请给项目 一个 Star !
欢迎提出你的 issue 和 PR！
关注腾讯开源公众号
获取更多最新腾讯官方开源信息！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c038fdc1bb67ab0e70f967fb9feade44/" rel="bookmark">
			python核心阶段（二）—— 面向对象在python中的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言（类） 类是将同类对象的共同属性和行为抽象出来形成的一个相对复杂的数据类型
对象的抽象是类，类的具体化就是对象 1. 类的定义及简单应用 语法： class 类名（首字母大写）:
xxxx（类的描述）
根据类，创建一个对象，这个过程被称为实例化，所以有时对象也被称为实例 语法： xxx = 类名（）
对象通过class属性可以找到对应的类 语法：对象.__class__
class Money: # 注1.首字母大写 2.Money后面不加括号 pass #占位符 one = Money() #根据类创建一个对象 print(one.__class__) #对象通过class属性可以找到类 创建对象时的底层运作 2.属性相关 2.1 属性与变量的区别 1）概念 ：变量是“可以改变的量值” ； 属性是“属于某个对象的特性”
2）访问权限：对于变量，根据不同的位置，存在不同的访问权限（例如局部变量和全局变量）
对于属性，只能通过对象来进行访问，所以必须先找到对象，而对象又通过变量
名来引用，所以它也有对应的访问权限
3）判定依据：是否存在宿主（属性的宿主是对象）
2.2 对象属性 在对象中操作的属性 语法操作备注对象.属性 = 属性的值增加/修改对象属性对于可变类型的数据，例如列表，若直接修改，需要开辟一个新的内存空间；利用l.append函数，则不需要对象.__dict__查询对象的所有属性本质：__dict__ 也是一个属性，专门用于 存储所有属性对象.属性访问对象如果访问不到，会报错del 对象.属性删除对象属性 class Person: #创建类 pass p = Person() #创建对象 p.age = ["a","b"] #新增属性 p.age.append("c") #在原内存修改 p.age = ["a","b","c"] #开辟新内存 print(p.age) #访问属性 print(p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c038fdc1bb67ab0e70f967fb9feade44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0b17c493360014f33af2c3ba090d7d/" rel="bookmark">
			python基础阶段（五）—— 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念（作用）：写了一段代码实现了某个小功能; 然后把这些代码集中到一块, 起一个名字; 下一次就可以根据这个名字再次使用这个代码块, 这就是函数，它可以使代码模块化，更加方便
1. 定义函数 1.1 简单定义 def 函数名称（参数1，参数2，... ）： 函数体 在我们调用函数时，直接用 函数名称（参数）即可，多参时，形参和实参需要一一对应
注意：python中的函数是引用传递（即：是指传递过来的, 是一个变量的地址，通过地址, 可以操作同一份原件），不是值传递（即：是指传递过来的, 是一个数据的副本，修改副本, 对原件没有任何影响）
1.2 函数参数 形参和实参 在函数的定义中，所用的参数是形参——它是函数完成工作所需的一项信息，而在我们调用函数过程中，输入的参数是实参——它是调用时传递给函数的信息
def greet(name): print("Hello," + name.title() + "!") greet("russell") #在该例中，name是形参，“russell”是实参 不定长参数： 有些时候，在函数体中我们需要处理的数据不确定长度，因此我们无法确定参数具体的个数，此时可以：
（1）在形参前面加一个星号（*），使函数接收一个元组（元组比列表的好处：不可变）
（2）在形参前面加两个星号（*），使函数接收一个字典（调用：函数名(参数1 = x ，...） )
参数的装包和拆包（针对于上述两种函数） 装包：把传递的参数, 包装成一个集合（元组 列表） 其实上面两种函数就是进行了装包操作
拆包：把集合参数, 再次分解成单独的个体 （只需要在参数使用时前面再加上*或**）
def test(*aaa): #装包操作 print(aaa) #未拆包 print(*aaa) #拆包 test(1,"a",3) #结果为：(1, 'a', 3) # 1 a 3 缺省参数（默认值） 有时使用函数时，某个参数一般为一个固定值，这种参数可输入也可不输入，如果不输入，则可以使用默认值，这种参数就是缺省参数
定义方式：def 函数名（变量名 = 默认值）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0b17c493360014f33af2c3ba090d7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db0e6f03f77b7c50c6344e6e860f684/" rel="bookmark">
			Java中的Stream流收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、归约和汇总
2、分组
3、分区
4、理解收集器接口
Java 中 Stream 流用来帮助处理集合，类似于数据库中的操作。
在 Stream 接口中，有一个抽象方法 collect，你会发现 collect 是一个归约操作（高级规约），就像 reduce 一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。具体的做法可以通过Collector 接口来定义。// collect和reduce都是Stream接口中的汇总方法，collect方法接收一个Collector(收集器)作为参数
收集器(Collector)非常有用，Collector 接口中方法的实现决定了如何对流执行归约操作。//收集器用来定义收集器如何收集数据
一般来说，Collector 会对元素应用一个转换函数，并将结果累积在一个数据结构中，从而产生这一过程的最终输出。
Collectors 实用类提供了很多静态工厂方法，可以方便地创建常见收集器的实例，所以只要拿来用就可以了。最直接和最常用的收集器比如 toList、toSet、toMap 等静态方法。
1、归约和汇总 使用 Collectors 进行规约和汇总，比如统计汇总，查找最大值和最小值，拼接字符串等。
本节示例会使用到如下代码：
public class Dish { private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) { this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1db0e6f03f77b7c50c6344e6e860f684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ebfdf02314bacc37195a366a4d2594/" rel="bookmark">
			SpringMVC之注解的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
SpringMVC之注解的使用
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、注解的使用@Controller@Controller@RequestParam@RequestHeader@CookieValue@SessionAttributes@ModelAttribute@PathVariable@PostMapping、@GetMapping、@PutMapping、@DeleteMapping@ResponseBody@RestController@RequestBody 总结 前言 提示：这里可以添加本文要记录的大概内容：
通过注解，我们可以在代码中轻松地标识和配置 SpringMVC 的组件，如控制器、视图、请求映射等。这种方式大大减少了冗余的配置文件，提高了开发效率。
在本博客中，我们将深入探讨 SpringMVC 中注解的使用。我们将了解注解的基本概念和工作原理，学习如何使用注解来创建控制器、处理请求和渲染视图。此外，我们还将探讨一些常见的注解，以及如何通过注解进行参数传递和验证。
无论是 SpringMVC 的新手还是有经验的开发者，本博客都将提供有价值的信息和实际示例，帮助你更好地理解和应用注解来简化你的 Web 开发工作。
提示：以下是本篇文章正文内容，下面案例可供参考
一、注解的使用 @Controller 作用：标记控制器，将控制器交给Spring容器管理。
位置：类上方
import org.springframework.stereotype.Controller; @Controller public class MyController { // 处理请求的方法 public void handleRequest(HttpServletRequest request, HttpServletResponse response) { // 在此编写请求处理逻辑 } } 在上述示例中，我们创建了一个名为MyController的类，并在其上添加了@Controller注解。这样，该类就被标记为一个 SpringMVC 控制器。
@Controller注解通常与@RequestMapping注解一起使用，来指定控制器处理的请求路径。
@Controller 作用：给控制器方法设置请求路径
位置：方法或类上方。用于类上，表示类中的所有控制器方法都是以该地址作为父路径。
属性：
value/path:请求路径method:指定请求方式params:规定必须发送的请求参数headers:规定请求必须包含的请求头 @Controller @RequestMapping("/c3") public class MyController3 { /* 访问路径为 /c3/annotation1 支持post和get请求 请求时必须带有age参数 请求时必须带有User-agent请求头 */ @RequestMapping(path = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ebfdf02314bacc37195a366a4d2594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a98582e50791902667991ba5f34626c/" rel="bookmark">
			yolov8添加ca注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建文件 coordAtt.py 位置：ultralytics/nn/modules/coordAtt.py
###################### CoordAtt #### start by AI&amp;CV ############################### # https://zhuanlan.zhihu.com/p/655475515 import torch import torch.nn as nn import torch.nn.functional as F class h_sigmoid(nn.Module): def __init__(self, inplace=True): super(h_sigmoid, self).__init__() self.relu = nn.ReLU6(inplace=inplace) def forward(self, x): return self.relu(x + 3) / 6 class h_swish(nn.Module): def __init__(self, inplace=True): super(h_swish, self).__init__() self.sigmoid = h_sigmoid(inplace=inplace) def forward(self, x): return x * self.sigmoid(x) class CoordAtt(nn.Module): def __init__(self, inp, reduction=32): super(CoordAtt, self).__init__() self.pool_h = nn.AdaptiveAvgPool2d((None, 1)) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a98582e50791902667991ba5f34626c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6b8cc717eaedcd67988fcce54dcdbd/" rel="bookmark">
			css 超过一行/多行显示省略号... - 附示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果 1、超过一行 2、超过多行 - 以两行为例 二、示例代码 1、超过一行 margin: 20px; width: 50px; border: 1px solid red; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 2、超过多行 - 以两行为例 margin: 20px; width: 50px; border: 1px solid red; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; // 如果是3行改为3，以此类推 overflow: hidden; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d899a0f0f2533028d5578a5596e8586/" rel="bookmark">
			高级算法设计与分析（四） -- 贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 高级算法设计与分析（一） -- 算法引论
高级算法设计与分析（二） -- 递归与分治策略
高级算法设计与分析（三） -- 动态规划
高级算法设计与分析（四） -- 贪心算法
高级算法设计与分析（五） -- 回溯法
高级算法设计与分析（六） -- 分支限界法
高级算法设计与分析（七） -- 概率算法和NP完全性理论
高级算法设计与分析（八） -- 总结
目录
系列文章目录
前言
一、贪心算法的基本思想
二、活动安排问题
三、贪心算法的基本要素
四、哈夫曼编码
五、单源最短路径-Dijkstra算法
六、最小生成树
1、基础概念与问题
2、prim算法（普里姆算法）
3、kruskai算法（克鲁斯卡尔算法）
习题
前言 tips：这里只是总结，不是教程哈。鉴于本人写字如画符，就不出视频教程了，如实在有需要，请在文章下方留言。当然，文章有任何问题，也请留言，谢谢！
这个系列用另一种形式，把习题放在最下面，看看好用不。
本系列文章最后一文会进行简要全部总结，以及思维导图放在最后一篇文章最下面，请自行获取。
一、贪心算法的基本思想 50，20，0.2，0.1
3*5
二、活动安排问题 1、问题描述 给定一组活动，每个活动都有一个开始时间和结束时间，目标是安排出一个最大数量的相互兼容的活动集合，即这些活动之间不会相互冲突。
2、例子 3、步骤： 因为是按照结束时间的非减排序的，选择第一个后（红1），把开始时间在这个活动结束时间之前的都排除（红叉），然后继续选择未排除的结束时间最早的一个（绿2），把开始时间在这个活动结束时间之前的都排除（绿叉），以此类推……
4、算法正确性证明： 另一种表述，看你们能接收那种
三、贪心算法的基本要素 1、贪心选择性质、最优子结构 ***自顶向下和自底向上 2、证明方法 4、贪心算法的适用范围 5、背包问题和0-1背包问题 四、哈夫曼编码 复杂度
五、单源最短路径-Dijkstra算法 1、问题描述 有向图
2、算法的基本思想 3、将算法用程序描述 复杂度分析：时间复杂度：o(|V|^2)
4、算法正确性证明 六、最小生成树 1、基础概念与问题 2、prim算法（普里姆算法） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d899a0f0f2533028d5578a5596e8586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8a6604ded51f6d7a384f832af3a5ce/" rel="bookmark">
			【嵌入式-LinuxC】一文带你搞清楚sizeof和strlen怎么计算字符串长度的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上代码~
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(int argc, char *argv[]) { // 这里分配给数组的长度为3，实际给到了7个字符数组，因此sizeof为3。当计算机分配了3个长度后，将不再把随后的值继续填充了，因此strlen实际上长度是随机的，遇到下一个\0就可以得到实际strlen长度。在我计算机上，始终看到的strlen是6，并且输出字符都是一摸一样的。 char s0[3] = {'a', 'p', '0', 'p', '\0', 'l', 'e'}; // 这里算的sizeof为初始化的空间大小，为10，strlen为遇到\0的长度-1，是5-1=4 char s1[10] = {'a', 'p', '0', 'p', '\0', 'l', 'e'}; // 这里转义字符\不要当作一个字符，而要跟后面的符号一起算。因此sizeof总共空间是12, 但strlen遇到\0则结束，因此strlen算的是3 char s2[] = "\t\\\%\0\\0mike\n"; // 这里ASCII 8进制最大值是177，\180超过8进制数，此时按照\1和80算，因此此时有6个字符.sizeof算出6，strlen则是5 char s3[] = "\180\x99\n"; // 这里\150没有超过ASCII码8进制最大值，因此算1个字符。sizeof算出4个字符。strlen则是3个字符 char s4[] = "\150\x99\n"; printf("sizeof(s0)=%ld, strlen(s0)=%ld\n", sizeof(s0), strlen(s0)); printf("sizeof(s1)=%ld, strlen(s1)=%ld\n", sizeof(s1), strlen(s1)); printf("sizeof(s2)=%ld, strlen(s2)=%ld\n", sizeof(s2), strlen(s2)); printf("sizeof(s3)=%ld, strlen(s3)=%ld\n", sizeof(s3), strlen(s3)); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8a6604ded51f6d7a384f832af3a5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a2d44a65ac852f303adedda12e2190/" rel="bookmark">
			高山不语，静水流深：源启基础运行支撑平台在支撑着什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语
2022年，金融级数字底座“源启”应运而生，历经一年疾速演进，已在金融、能源、制造等行业和多家央企集团的百余项重大工程中得以应用。
随着中国电子计算体系重构工作的开展，源启作为对下调用管理泛在软硬件设施和资源，对上支撑各类行业数字化应用、数据产品和人工智能模型的数字基础设施平台，其结构、内涵和实现方法也在快速地研发、实践和迭代：对上，源启数字构建平台、源启数据资产平台、源启行业AI平台日行千里、疾如旋踵；对下，源启基础运行支撑平台也在逐电追风、大步流星；向着贯通上下、经济持续稳步迈进。
近期，在源启基础运行支撑平台层，负责基础设施管理的云原生基础设施管理平台、一体化监控平台和负责平台服务管理的分布式PaaS平台​先后完成升级更新，发布上线，协同实现更卓越的底层算力汇聚和对上层应用的支撑。
根深才能叶茂，本固才能枝荣。我们将分成四期内容向您介绍源启基础运行支撑平台并发布源启云原生基础设施管理平台、源启一体化监控平台、源启分布式PaaS平台等三个产品，与您一起探寻澎湃算力之源。
本篇内容与您探讨：源启基础运行支撑平台在支撑着什么？
“技术架构迁移升级的最大障碍，在于架构的稳定性和技术路线的不确定性，也来源于巨大的重复适配和研发成本。帮助行业机构更好地推进新算力、新架构体系的平稳落地，降低运行风险、技术选择风险、供应链风险、工程实施风险和投资风险，是源启基础运行支撑平台的核心价值。”
​
架构升级 迎难而上
为了应对不断增长的数字化需求、提高效率，降低能源消耗以及提升可扩展性和灵活性，大型数据中心正在向着新型数据中心演进。趋势上，云原生架构、微服务技术广泛被应用，以实现更高的灵活性和可伸缩性。随着技术和业务的发展，底层技术架构进入新老交替的阶段：
●　随着新算力体系的崛起，尤其是高端通用芯片、基础软硬件和云计算架构的快速发展，越来越多的金融机构开始引入和使用分布式计算技术和云原生微服务架构，以此为基础构建上层技术平台和应用系统，正式进入双态IT并存阶段；
●　技术栈涉及到应用、分布式组件、微服务组件、中间件、数据库、虚拟机、容器、物理机、裸金属等方方面面。
以金融行业为例，作为信息化、数字化建设最早的践行者，在探索符合行业发展的建设过程中，金融行业逐渐形成了以传统商业计算技术栈为基础的混合技术架构体系，其中既有大中小型机专用机型的一体化环境，也有Wintel​、Linux+x86/ARM等混搭物理环境，集中式架构和分布式架构并存，物理机和虚拟化环境、私有云和容器云并存，并且使用了支持不同数据格式的数据库产品。在数字化转型中，面临多重问题和挑战：
■　可信、可靠地替代昂贵的传统商业计算底座是否真的可行？
■　面对众多发展机遇，如何应对未来对算力和容量的更高要求？
■　底层基础计算设施如何能够更好、更经济地满足金融行业不同场景的特殊需求？
■　在云计算时代，如何在持续可用性上满足更为严苛的用户体验和监管要求？
■　如何保护已经在基础计算方面花费的巨额投资？
■　各个基础设施厂商之间的软硬件能否实现接口互通、良好适配？
■　技术组件能否简单适配和组合，组合后是否稳定流畅，可正面提升上层系统性能和可用性？
■　如何实现基础计算能力各种异构资源的统一调度和管理？
■　在多层技术栈环境中，如何做到弹性伸缩、快速调用链跟踪和故障恢复？
■　新架构复杂的技术栈和元件，是否有一套统一、可视、简便的方法来管理？
■　如何在基础计算元件方面保留独立、灵活的选择能力？
■　如何在尚未成熟稳定的技术供应环境中升级技术架构并持续发展？
技术架构迁移升级的最大障碍，在于架构的稳定性和技术路线的不确定性，也来源于巨大的重复适配和研发成本。迎难而上，帮助行业机构更好地推进新算力、新架构体系的平稳落地，降低运行风险、技术选择风险、供应链风险、工程实施风险和投资风险，就是源启基础运行支撑平台的核心价值所在。
贯通上下 合纵连横
“源启” 于2022年正式发布，2023年完成2.0版本迭代，是由多年实践经验凝聚而成的金融级数字底座。源启由基础运行支撑平台、数字构建平台、数据资产平台和行业AI平台四大平台构成，是替代传统架构的技术底座，是助力企业转型的数字化基础设施。
源启把底层的基础计算能力、云、容器、安全、数据库等通过一个提供基础设施运行与支撑功能的平台集聚起来，为上层各种的数字化应用提供统一、简洁的支撑，这就是源启基础运行支撑平台。
作为构成源启的四大平台之一，源启基础运行支撑平台是极为关键的沃土和根基，在体系中起着贯通上下、合纵连横的重要作用。
源启基础运行支撑平台，运用系统工程方法，通过一系列技术中台和组件，垂直适配并优化芯片、存储、网络、整机、操作系统、数据库、云和中间件等至最优性能，构建面向下一代的云原生数据中心解决方案；通过实现具备云原生特点的全栈代码定义、全栈开放解耦、全栈状态一致、全栈数据驱动的整体架构，提升数据中心的运维管理效率，奠定数据中心数字化转型的基础；满足金融等重点行业大容量、高并发、高可用和高安全等关键特性，为上层应用提供完整、可信、可配置能力，构建开放解耦、敏捷高效、自主可控、持续改进的商业计算基础平台。
何谓贯通上下、合纵连横？
首先，源启基础运行支撑平台向下封装多样化、差异化的基础设施，打造金融级稳定性和其他关键性能，为行业用户从高成本传统商业计算体系升级到高性能高效能新算力体系提供了架构级的可行性、经设计验证的路线明确性、经实践打磨的可靠性和整体封装后的便利性。
源启提供应用运行支撑的稳定标准，运用容器等混合技术作为资源调度和编排的标准，结合多层次的中间访问层，屏蔽基础设施的差异性，兼容ARM、x86、RISC等多种路线的计算芯片、硬件加速器、存储、通讯以及多种技术路线的数据库及技术中间件，将应用与底层运行环境解耦，让不同类型的业务系统架构在源启数字底座上平滑运行，实现从传统架构或离散的分布式计算架构到新架构的逐步迁移切换。
其次，在稳定可靠的前提下，源启基础运行支撑平台向上支撑多样化的应用类型和工作负载，涵盖多种主流技术框架，建立微服务、数据访问和管理、前端交互、大数据、AI、区块链等应用底层支撑能力。
从访问浏览类的无状态应用、长短流程的管理类应用，到关键交易应用和复杂事务应用，再到数据加工分析类的数据智能应用以及交互智能应用，都可以基于源启基础运行支撑平台顺利地自动部署、组装、扩展和管理，帮助金融等关键行业能快速、精准地从海量业务数据和现有系统能力中发掘组合出新的金融科技能力、业务模式和商业发现，以更从容地应对频繁、多变的业务挑战，满足深度数字化转型中最核心的需求。
在源启基础运行支撑平台中，有几个方面非常关键：
■　在底层，通过云原生基础设施管理平台来进行基础计算资源的跨云调度和管理，以及数据中心的统一管理，在底层可以整合行业当前传统IaaS、虚拟化、容器以及物理机环境，整合各种计算存储能力形成统一的、标准的基础计算能力；
■　与此同时，基础计算能力承载了基础的、内生的数字安全能力，此安全能力基于内置于芯片、内存、操作系统、容器、数据库和源启自身的技术元件中；
■　在基础计算能力之上，进行对不同类型的交易数据库、数据仓库平台以及其他各类数据存储资源的数据资源管理；
■　再向上，则是集群计算框架或分布式框架——将数千台服务器、数万虚拟节点和数十万容器聚合在一起，通过两地三中心或者多地多中心的运行方式，为各种应用提供巨大的综合算力；
■　之后，通过面向行业的公共组件，将大量应用所需的公共能力抽取出来，更加快速地以平台工程的方法来支撑上层应用的建设。
简而言之，源启基础运行支撑平台采用云计算技术​，以分布式资源管理技术、虚拟化技术、云原生技术等多种技术为依托，将服务器等硬件资源池化形成共享池，按需提供计算、网络、存储等产品服务的综合性资源的基础设施服务，实现容器化部署和基础设施自动化目标。
开放解耦 托底铸基
源启基础运行支撑平台适用于多种场景，特别是需要灵活性、可伸缩性、自动化和快速交付的应用程序和工作负载的应用场合。
源启基础运行支撑平台可以用于快速创建、部署和测试应用程序，可以通过对Web应用程序的便捷托管实现快速部署和扩展，天然支持容器化应用程序的部署和管理、广泛支持容器编排工具，拥有自动扩缩容能力以应对具有周期性或不稳定负载的应用程序，泛在适用于大型企业应用以及金融、制造、能源等行业应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a2d44a65ac852f303adedda12e2190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83639df2df3a114aead854f226297bc/" rel="bookmark">
			shell bash 参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #!/bin/bash while getopts as: opt; do case $opt in a) printf '%s\n' 'You have chosen: a';; s) n=$OPTARG; printf '%s: %d\n' 'You have chosen s with an argument of' "$n";; esac done 使用
./script.sh -s 4 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4267dc494b70b48721b7fc3ece68ec/" rel="bookmark">
			RISC-V搭建嵌入式QT开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装环境：
Ubuntu18.04
GCC：gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)
CROOSS-tools：gcc version 8.3.0 (crosstool-NG 1.24.0)
下载5.12安装包，解压后修改qmake.conf配置参数，将编译工具修改为交叉编译器
/qt-everywhere-src-5.12.12$ vi qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf # # qmake configuration for building with arm-linux-gnueabi-g++ # MAKEFILE_GENERATOR = UNIX CONFIG += incremental QMAKE_INCREMENTAL_STYLE = sublib QT_QPA_DEFAULT_PLATFORM = linuxfb #eglfs QMAKE_CFLAGS_RELEASE += -O2 -march=armv7-a QMAKE_CXXFLAGS_RELEASE += -O2 -march=armv7-a include(../common/linux.conf) include(../common/gcc-base-unix.conf) include(../common/g++-unix.conf) # modifications to g++.conf QMAKE_CC = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-gcc QMAKE_CXX = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-g++ QMAKE_LINK = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-g++ QMAKE_LINK_SHLIB = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-g++ # modifications to linux.conf QMAKE_AR = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-ar cqs QMAKE_OBJCOPY = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-objcopy QMAKE_NM = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-nm -P QMAKE_STRIP = /home/luckfox/workspace/luckfox-pico/tools/linux/toolchain/arm-rockchip830-linux-uclibcgnueabihf/bin/arm-rockchip830-linux-uclibcgnueabihf-strip load(qt_config) 添加编译配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4267dc494b70b48721b7fc3ece68ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e175c4317f37a5e490804fc085385480/" rel="bookmark">
			滚动抽奖点名JS实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚动抽奖纯JS实现 最近老师让我用html+css+js实现一个课堂抽奖点名问答问题的一个功能，
因为之前用过轮播图的代码，所以就想到用类似轮播的方式来实现。
通过设置容器left定位负数容器会向左移动
效果如下： 代码： &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .lucky-draw { padding-top: 20px; overflow: hidden; position: relative; height: 320px; left: 50%; transform: translateX(-50%); top: 120px; } .lucky-draw-item { float: left; width: 200px; height: 200px; position: relative; /*background: red;*/ text-align: center; line-height: 120px; } .lucky-draw-item img { width: 200px; height: 200px; } .lucky-element-wrap { position: absolute; } #btn { position: absolute; width: 100px; height: 25px; background: beige; bottom: 10px; left: calc(50% - 50px); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e175c4317f37a5e490804fc085385480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ae492f1b5f0224c5b745734267d405/" rel="bookmark">
			人流量监测识别摄像机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人流量监测识别摄像机是一种基于人工智能技术的智能监控设备，其主要功能是通过摄像头捕捉实时画面，利用深度学习算法对画面中的人数进行实时识别和统计。这种摄像机可以广泛应用于各种场合，如商场、车站、学校、医院等公共场所，以及工厂、仓库等生产环境中，帮助管理者更好地了解实时人流状况，从而进行合理的资源调配和安全管理。
人流量监测识别摄像机的工作原理是通过摄像头采集画面，然后通过深度学习算法对画面中的人物进行分析和统计，最终得出实时的人数数据。在算法方面，通常采用的是基于视觉神经网络的目标检测和跟踪技术，能够准确地识别画面中不同位置、不同数量的人物，并实现目标的持续跟踪，从而实现对人数的准确统计。摄像机的应用场景多种多样。在商场和超市中，可以利用人数识别摄像机实时监测客流量，从而合理安排人员工作和商品陈列，提高服务效率和顾客体验。在公共交通站点，可以实时监控站台和候车区的人数，及时疏导乘客，有效缓解交通拥堵和排队排难。在工厂和仓库中，可以利用摄像机监测生产线上的工人数量，确保工作安全和生产效率。总之，人流量监测识别摄像机可以帮助管理者及时了解人流状况，做出科学决策，提高管理效率。
人流量监测识别摄像机作为一种智能监控设备，能够帮助管理者实时了解人流状况，提高管理效率和安全性，具有广阔的应用前景。随着人工智能技术的不断发展和深入应用，将在各个领域发挥更加重要的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a787e4ef34c318969d2ef09b4341c7c6/" rel="bookmark">
			若依 $tab的所有用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2023.12.22今天我学习了如何使用$tab来进行路由的跳转。
一、打开页签：
this.$tab.openPage("导航名称","/xxx/xxxx")//对应路由 二、修改页签：
const obj = Object.assign({},this.$route,{title:'xxxx标题'}) this.$tab.updatePage(obj); 三、关闭页签：
const obj = {path:"/xxx/xxx"}//关闭当前tab页签，打开新页面 this.$tab.closeOpenPage(obj); this.$tab.closePage();//关闭当前页签，回到首页 四：刷新页签：
this.$tab.refreshPage();//刷新当前页签 const obj = {path:"/xxx/xxxx",name:"xxx"}//刷新指定页签 this.$tab.refreshPage(obj); 五：关闭所有页签：
this.$tab.closeAllPage() 六、关闭左侧页签：
this.$tab.closeLeftPage()//关闭左侧页签 const obj = {path:"/xxx/xxxx",name:'xxx'}//关闭左侧指定页签 this.$tab.closeLeftPage(obj) 七、关闭右侧页签：
this.$tab.closeRightPage()//关闭右侧页签 const obj = {path:"/xxx/xxxx",name:"xxxx"} this.$tab.closeRightPage(obj);//关闭右侧指定页签 八、关闭其他tab页签：
this.$tab.closeOtherPage();//关闭其他tab页签 const obj = {path:"/xxx/xxxx",name:"xxxx"} this.$tab.closeOtherPage(obj)//关闭其他指定页签 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/27/">«</a>
	<span class="pagination__item pagination__item--current">28/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/29/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>