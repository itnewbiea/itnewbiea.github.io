<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02f14360934b4569147d6894e287190/" rel="bookmark">
			Charles抓包显示＜unknown＞解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇 ：Charles抓包微信小程序数据
charles抓包会出现，请求前都加了锁，具体地址为&lt;unknown&gt;的情况。
解决&lt;unknown&gt;问题
首先电脑上需要安装charles，然后需要设置手机上的WiFi设置，修改配置中的代理设置，把服务器的主机名设置成你电脑当前的ip地址（需要注意的是，你的代理服务器主机名的ip地址要和你当前连的ip地址的网段需要一致）。
抓取iPhone设备上的HTTPS请求，需要在iPhone上也安装一个证书，在手机浏览器输入这个网址：http://charlesproxy.com/getssl ，点击安装即可。
1、手机或者其他设备要确认是否安装好了ssl证书（如果没有安装证书，打开浏览器登录网址：chls.pro/ssl 安装证书），安装好之后要设置信任该证书（通用-&gt;关于本机-&gt;设置信任该证书），不然抓包仍会显示unknown类型。
2、在Charles中，设置Proxy-&gt;SSL Proxying Settings中的SSL Proxying的代理网址。
直接点击Add-&gt;OK即可，不用输入host和port。
3、再次抓包，已经没有锁了，可以正常展示抓包内容。
🎙️我是一个热衷分享测试干货的小测试
🎆欢迎点赞 👍 收藏、留言 📝 如有错误敬请指正！
⛽️获取更多干货，可以关注公众号：软件测试开发区
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcaada6551850192ebde9793e4c3000e/" rel="bookmark">
			【Opencv450】HOG&#43;SVM 与Hog&#43;cascade进行行人检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为从opencv3.0开始不再支持hog+cascade级联分类器。github上有人从opencv2.x导出了个hogcascade类，引入opencv4.x可以使用。
行人检测
带孔木块级联分类器识别效果 主程序源码：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/objdetect/objdetect.hpp&gt; #include &lt;opencv2/ml/ml.hpp&gt; #include&lt;ctime&gt; #include "hogcascade.hpp" using namespace std; using namespace cv; int main() { cout &lt;&lt; "Red:Hog+svm------Green:Hog+cascade" &lt;&lt; endl; Mat src = imread("1.jpg", 1); vector&lt;Rect&gt; found1, found_filtered1, found2, found_filtered2;//矩形框数组 clock_t start1, end1, start2, end2; //方法1，Hog+svm start1 = clock(); HOGDescriptor hog;//HOG特征检测器 hog.setSVMDetector(HOGDescriptor::getDefaultPeopleDetector());//设置SVM分类器为默认参数	hog.detectMultiScale(src, found1, 0, Size(2, 2), Size(0, 0), 1.05, 2);//对图像进行多尺度检测，检测窗口移动步长为(8,8) end1 = (double)(1000 * (clock() - start1) / CLOCKS_PER_SEC); //方法2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcaada6551850192ebde9793e4c3000e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3731ce44f3162125b1c845b76794dece/" rel="bookmark">
			MySQL的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽啊铁子们今天分享的是 MySQL 的基本用法
目录
一、安装MySQL
二、命令行登陆及权限修改
三、MySQL默认四张表
四.mysql之账号管理、建库以及四大引擎
五、面试题
一、安装MySQL 我在前面的博客前面写了安装MySQL8.0版本教程链接如下不会的可以看看
http://t.csdn.cn/S4s3U
安装MySQL（8.0的版本）
1.解压MySQL
2.修改my.ini文件
3.mysqld install
4.mysqld --initialize --console
5.net start mysql
6.mysql -P 3306 -u root -p
7.ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';
8.Navicat链接测试
如果MySQL已经安装过，那么执行mysqld remove
安装MySQL（5.7的版本）
1.解压MySQL
2.修改my.ini文件
3.mysqld install
4.mysqld --initialize --console
5.net start mysql
6.mysql -P 3306 -u root -p
7.SET PASSWORD = PASSWORD("123456"); 8.Navicat链接测试
如果MySQL已经安装过，那么执行mysqld remove
删除MySQL（这是5.5版本的卸载方式）
停止MySQL
1添加删除程序中卸载MySQL
2到安装目录删除MySQL
3删除：C:\Documents and Settings\All Users\Application Data\MySQL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3731ce44f3162125b1c845b76794dece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d357615b92e8fdef36d7117f8bfe0a7/" rel="bookmark">
			会话推荐中的价格偏好和兴趣偏好共同建模-论文泛读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛读 一、背景二、方法概要①：②：三、会话的由来四、 现有会话的挑战及解决方法1、如何处理此类异构信息方法： 2、如何建模价格和利息偏好之间的复杂关系方法： 五、贡献六、相关说明工作重点1、问题定义2、价格离散化3、 构造异构超图4、 双通道聚合机制(*)类型内聚合类型间聚合 5、偏好提取提取价格偏好提取兴趣偏好 6、协同引导学习模式 七、预测和训练 一、背景 基于会话的推荐：旨在根据匿名用户的简短行为序列预测其想要购买的物品
然而，在基于会话的推荐中加入价格偏好是非常重要的。
①：很难处理商品各种特征的异构信息来捕捉用户的价格偏好。
②：在确定用户选择时，很难对价格和兴趣偏好之间的复杂关系建模
二、方法概要 我们提出了一种新的基于会话的推荐方法——Coguided异构超图网络（CoHHN）。
①： 针对第一个挑战，设计了一个异构超图来表示异构信息和它们之间丰富的关系。然后设计了一种双通道聚合机制来聚合异构超图中的各种信息。
②： 设计了一个共同引导学习方案来模拟价格和兴趣偏好之间的关系，并增强彼此的学习
在三个真实数据集上进行的大量实验证明了该方法的有效性。进一步的分析揭示了价格对于基于会话的推荐的重要性。
三、会话的由来 传统的RS通常使用用户的长期行为来相应地预测其未来的行为。然而，在许多情况下，由于隐私政策或非登录性质，用户的肖像和她丰富的历史行为数据不可用。
为了解决这个问题，提出了基于会话的建议（SBR），以预测匿名用户在当前会话中基于有限交互（例如，单击的项目及其相关特征）的行为
四、 现有会话的挑战及解决方法 现有的SBR方法侧重于建模用户的兴趣偏好，即用户对某个项目的喜欢程度
但这些方法都忽略了一个非常重要的因素，即用户的价格偏好，其目的是描述用户愿意为一个项目支付多少钱
因此，在预测用户行为时，应考虑用户的价格偏好。然而，在模拟用户对SBR的价格偏好时，我们面临两个主要挑战。
1、如何处理此类异构信息 场景： 例如用户可能会为了提高计算机性能购买昂贵的计算机，但是会买一件价格合理的睡衣在家里穿
在考虑用户的价格偏好时，我们需要考虑相应的项目类别。这样，将涉及多种类型的信息来描述用户的历史行为，包括一系列项目、项目价格和项目类别
方法： 一种直观的方法是直接应用最先进的基于异构图的方法来建模异构信息
但是，例如&lt;项目、价格、类别&gt;之间的关系。这种复杂的高阶依赖可能会导致基于图的通用异构方法失败。
①：受异类图和超图的启发，本文提出了一种异类超图网络，它结合了异类图在建模异类信息方面的优势和超图在捕获复杂的高阶依赖关系方面的优势，来处理SBR中的异类信息
②：我们定义了三种类型的超边，即特征超边、价格超边和会话超边，用于表示不同节点之间的多类型关系。然后设计了一种双通道聚合机制，通过特征超边传播节点嵌入。基于学习到的节点嵌入，我们分别通过价格和会话超边缘应用注意层来提取原始价格和兴趣偏好。
2、如何建模价格和利息偏好之间的复杂关系 场景：用户可能出于强烈的兴趣购买昂贵的物品，即使物品的价格超出了她的预期。在这种情况下，用户由于兴趣浓厚而调整其价格偏好。同样，用户也会购买一些因价格低廉而不喜欢的商品
方法： 我们在从异构超图网络中学习到的原始价格和兴趣偏好的基础上，进一步使这两个偏好相互引导，以丰富它们的语义。最后，Cohn根据商品特征和用户的价格和兴趣偏好进行推荐。
五、贡献 1、我们强调价格因素在决定用户行为中的重要性，并考虑价格和兴趣偏好来预测SBR中的用户行为
2、我们提出了一种新的方法，称为共引导异构超图网络（CoHHN），用于建模价格偏好、兴趣偏好以及它们之间的关系，以进一步提高SBR的性能
3、在三个公共基准上的大量实验表明，与最先进的方法相比，我们提出的COHN方法具有优越性。进一步的分析也证明了价格因素在SBR中的重要性
六、相关说明 工作重点 1、异构图和超图
异构图已被证明在处理异构信息方面是有效的。例如，Fan等人提出了一种异构图中的元路径引导方法，用于意图推荐。
超图是一个超边可以连接两个以上节点的图。这一独特功能使其能够捕获节点之间的复杂高阶依赖关系，尤其是在推荐任务中。HyperRec[35]利用超图的这种能力为下一个项目推荐建立短期用户偏好模型
1、问题定义 2、价格离散化 物品的绝对价格不足以确定物品是否昂贵
场景：例如，200美元可能是一部手机的便宜货，但同样的价格对于一盏台灯来说是非常高的
我们必须根据项目类别将项目价格离散为不同的价格水平，以便在不同类别之间进行比较
对于一个项目 x i x_{i} xi​,他的价格范围是 [ m i n , m a x ] [min,max] [min,max],我们确定他的价格水平如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d357615b92e8fdef36d7117f8bfe0a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0e2e0639488efe22c12e0eb28380b3/" rel="bookmark">
			Python实用脚本/算法集合, 附源代码下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习编程、学习Python最好的方式就是练习，哪怕是新手，只要不断地敲代码输出，肯定会有神效。
Python的练手项目很多，特别是Github上，建议不管新手、老司机都去看看。
这里推荐给大家两个Github上练习的项目，算法仓库-algorithms和脚本仓库-Python master。
后文会有相应源代码集打包下载，给需要的小伙伴。
algorithms算法仓库 首先来看看算法仓库-algorithms。
这里面集合众多核心算法的Python实现，比如排序、图计算、回溯、队列、流计算、堆、搜索、压缩等等。
该仓库支持第三方库安装，在python中进行调用，非常方便。
首先使用pip进行安装：
pip3 install algorithms 然后导入相关模块进行调用，比如sort模块里的merge_sort归并排序算法。
from algorithms.sort import merge_sort if __name__ == "__main__": my_list = [1, 8, 3, 5, 6] my_list = merge_sort(my_list) print(my_list) 个人感觉这个仓库里的算法很齐全，适合做练习，小伙伴们可以试试。
所有算法脚本已经打包好，获取步骤如下：
1，点击下方公众号 数据STUDIO 名片
2，关注 数据STUDIO后，在消息后台回复 b
▲点击关注「数据STUDIO」回复b
另外，@公众号：数据STUDIO 还为大家整理和筛选了大量火爆全网的Python数据科学学习资料，全部资料按需自助免费获取！直接点击👇链接： 火爆全网的Python数据科学手册，太有用了
复旦学子《可解释机器学习》中文版完整PDF下载！
700页的机器学习笔记火了！完整版开放下载
Python脚本仓库 另外还有一个很好的练手项目，脚本仓库-Python master。
这个项目收集了作者平时工作用到的几千个实用小脚本，作者虽然不是程序员，但他这种用代码解决问题的习惯会极大的提升效率，也会迸发出更多的创新思维。
我觉得这样的代码每个人都可以写出来，只要慢慢积累多练习就可以。
举一个简单的例子，作者写了一个创建二维码的脚本，可以自动将url转化为二维码。
import pyqrcode import png from pyqrcode import QRCode # Text which is to be converted to QR code print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a0e2e0639488efe22c12e0eb28380b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0c5f9a63469459ae6b65fc116ccbc5/" rel="bookmark">
			flink批量 async io 写入hbase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 flink 采用批量 async io 方式写入hbase遇到的问题： java.util.concurrent.TimeoutException: Async function call has timed out. flink 采用批量 async io 方式写入hbase 一条一条数据写入hbase太慢了，故采用批量的方式，每2000条数据一个批量写入hbase，提高写入性能
设置一个三秒的翻滚窗口， 将数据聚合在一起， 然后批量的方式， Async IO 异步写入hbase
经在压测环境验证，当长期大数据量消费， 设置checkpoint， async I/O 批量写入hbase 会出现checkpoint超时，写入hbase不及时，flink反压机制不生效。。 这种方式在生产环境慎用！！！！！！
这是坑。。。。。。。
val RunDataDS: DataStream[FdcData[RunData]] = getDatas() // 设置翻滚窗口，聚合数据 val alarmRuleResultStream: DataStream[List[RunData]] = RunDataDS .map(_.datas) .keyBy(_.toolName) .window(TumblingEventTimeWindows.of(Time.seconds(3))) .process(new RunDataProcessWindowFunction()) // 异步IO 写入hbase AsyncDataStream.orderedWait( alarmRuleResultStream, new TestDataHbaseSink(ProjectConfig.HBASE_RUNDATA_TABLE), 6000, TimeUnit.MILLISECONDS, 100) .name("Hbase Sink") /** * 聚合在一起，批量写入 */ class RunDataProcessWindowFunction extends ProcessWindowFunction[RunData, List[RunData], String, TimeWindow] { def process(key: String, context: Context, input: Iterable[RunData], out: Collector[List[RunData]]): Unit = { out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0c5f9a63469459ae6b65fc116ccbc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6520147dd078c4dcd13b44c31c460780/" rel="bookmark">
			2021-Swin Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swin Transformer 论文地址:https://arxiv.org/abs/2103.14030
代码地址:https://github.com/microsoft/Swin-Transformer
https://www.bilibili.com/video/BV13L4y1475U 感谢沐神,朱毅，感谢霹雳大佬！！！！
1. 简介 1.1 简介 Swin Transformer是2021年微软研究院发表在ICCV上的一篇文章，并且已经获得ICCV 2021 best paper的荣誉称号。Swin Transformer网络是Transformer模型在视觉领域的又一次碰撞。该论文一经发表就已在多项视觉任务中霸榜。该论文是在2021年3月发表的，现在是2021年11月了，根据官方提供的信息可以看到，现在还在COCO数据集的目标检测以及实例分割任务中是第一名。
1.2 存在的问题 个人理解
VIT使用Transformer做了图像分类。同时也留下了悬念，怎么样才能使得Transformer应用到 视觉领域的下游任务(分割，检测)中。Swin Transformer就来了
Swin Transformer 希望VIT也能像卷积神经网络一样，也能分成几个block,也能做这种层级式的特征提取。使得提取出来的特征呢，有多尺度的概念
Transformer所使用的自注意力的操作非常的耗时。
前人的工作呢，使用后续的特征图作为Transformer的输入把图片打成patch,减少图片的resolution把图片画成一个一个的小窗口，在窗口里面去做自注意力 2. 网络结构(创新点) Swin Transformer使用了类似卷积神经网络中的层次化构建方法（Hierarchical feature maps），比如特征图尺寸中有对图像下采样4倍的，8倍的以及16倍的，这样的backbone有助于在此基础上构建目标检测，实例分割等任务。而在之前的Vision Transformer中是一开始就直接下采样16倍，后面的特征图也是维持这个下采样率不变。在Swin Transformer中使用了Windows Multi-Head Self-Attention(W-MSA)的概念，比如在下图的4倍下采样和8倍下采样中，将特征图划分成了多个不相交的区域（Window），并且Multi-Head Self-Attention只在每个窗口（Window）内进行。相对于Vision Transformer中直接对整个（Global）特征图进行Multi-Head Self-Attention，这样做的目的是能够减少计算量的，尤其是在浅层特征图很大的时候。这样做虽然减少了计算量但也会隔绝不同窗口之间的信息传递，所以在论文中作者又提出了 Shifted Windows Multi-Head Self-Attention(SW-MSA)的概念，通过此方法能够让信息在相邻的窗口中进行传递，后面会细讲。 下图是Swin Transformer文章中给出的图1，左边是本文要讲的Swin Transformer，右边边是之前讲的Vision Transformer。
接下来，简单看下原论文中给出的关于Swin Transformer（Swin-T）网络的架构图。通过图(a)可以看出整个框架的基本流程如下：
首先将图片输入到Patch Partition模块中进行分块，即每4x4相邻的像素为一个Patch，然后在channel方向展平（flatten）。假设输入的是RGB三通道图片，那么每个patch就有4x4=16个像素，然后每个像素有R、G、B三个值所以展平后是16x3=48，所以通过Patch Partition后图像shape由 [H, W, 3]变成了 [H/4, W/4, 48]。然后在通过Linear Embeding层对每个像素的channel数据做线性变换，由48变成C，即图像shape再由 [H/4, W/4, 48]变成了 [H/4, W/4, C]。其实在源码中Patch Partition和Linear Embeding就是直接通过一个卷积层实现的，和之前Vision Transformer中讲的 Embedding层结构一模一样。然后就是通过四个Stage构建不同大小的特征图，除了Stage1中先通过一个Linear Embeding层外，剩下三个stage都是先通过一个Patch Merging层进行下采样（后面会细讲）。然后都是重复堆叠Swin Transformer Block注意这里的Block其实有两种结构，如图(b)中所示，这两种结构的不同之处仅在于一个使用了W-MSA结构，一个使用了SW-MSA结构。而且这两个结构是成对使用的，先使用一个W-MSA结构再使用一个SW-MSA结构。所以你会发现堆叠Swin Transformer Block的次数都是偶数（因为成对使用）。最后对于分类网络，后面还会接上一个Layer Norm层、全局池化层以及全连接层得到最终输出。图中没有画，但源码中是这样做的。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6520147dd078c4dcd13b44c31c460780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f038fc1e945e3081e2abb64666f884/" rel="bookmark">
			Idea Maven项目打包工其他项目进行外部引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、说明 我们在日常项目开发中经常会有许多公共的模块，如统一的父工程、工具类模块、中间实体类(DTO, VO)，如果我们针对每个子项目都单独的创建一套工具类，多个子项目会存在很多重复的工具类、中间实体类代码。因此，我们可以将这些公共模块统一打成jar包，在各子项目中引入depency依赖即可。
2、将父工程打包成jar包 创建一个maven工程，统一管理各种外部jar 包依赖版本，如Spring Boot，maven plugins，mybatis，lombok等。
2.1、pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;cloud-common&lt;/module&gt; &lt;/modules&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.latiny&lt;/groupId&gt; &lt;artifactId&gt;cloud-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF‐8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF‐8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mybatis.version&gt;1.3.5&lt;/mybatis.version&gt; &lt;lombok.version&gt;1.18.12&lt;/lombok.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt; &lt;spring.cloud.version&gt;Hoxton.SR6&lt;/spring.cloud.version&gt; &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt; &lt;fastjson.version&gt;1.2.47&lt;/fastjson.version&gt; &lt;jwt.version&gt;1.0.10.RELEASE&lt;/jwt.version&gt; &lt;servlet.version&gt;3.1.0&lt;/servlet.version&gt; &lt;mybatis.version&gt;1.3.5&lt;/mybatis.version&gt; &lt;oauth2.version&gt;2.2.5.RELEASE&lt;/oauth2.version&gt; &lt;/properties&gt; &lt;!--全局依赖版本，不会引入具体的包，后期只需引入坐标，不用再指定版本了--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring.cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; PS：一定要指定Java编译插件版本与encoding（UTF-8），否则打包时会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f038fc1e945e3081e2abb64666f884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41afdd8f01f87c2e23f59e566a1e7481/" rel="bookmark">
			Activity的生命周期和启动模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Activity生命周期 1.正常情况： (1) onCreate:
表示 Activty 正在被创建，这是 Activity 生命周期的第一个方法，可以做一些初始化的工作，比如：加载布局，绑定控件，初始化数据等等。
(2) onRestart:
表示 Activity 正在重新启动，通常由 Activty 由不可见变为可见时被调用。
触发场景：按 Home 键进入桌面，或者启动一个新的 Activity，这时当前 Activity 被暂停，然后又回到了该 Activity ，此时会触发 onRestart。
(3) onStart:
表示当前 Activity 正在被启动，此时 Activity 已经可见了，但是还未出现在前台，无法与用户交互，用户是看不到的。
(4) onResume:
当前 Activity 已经可见，出现在前台并且开始活动，onStart 和 onResume 都表示 Activity 可见，onStart 时候 Activity 还在后台，onResume 的时候 Activity 才显示到前台。
(5) onPause:
表示当前 Activity 正在停止，此时还是可见，正常情况下，接着就会调用 onStop 方法。
可以做一些数据存储，动画停止等轻量级回收工作，不能太耗时。因为这会影响到新 Activity 的显示，只有 onPause 执行完，新 Activity 的 onResume 方法才会执行。
注意例如弹出一个非全屏 Dialog 或者启动一个透明的 Activty，那么当前 onStop 方法不会调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41afdd8f01f87c2e23f59e566a1e7481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2324161433f3271b6e47870c7ab018/" rel="bookmark">
			【C#】二值化处理以及高斯模糊减轻毛刺效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要方法
public Bitmap binaryzation(Bitmap bitmap) { //得到图形的宽度和长度 int width = bitmap.Width; int height = bitmap.Height; //创建二值化图像 Bitmap binarymap = new Bitmap(bitmap); int avg = 0; int r = 0; int g = 0; int b= 0; for (int i = 0; i &lt; width; i++) { for (int y = 0; y &lt; height; y++) { int col = binarymap.GetPixel(i, y).ToArgb(); r += (col &amp; 0x00FF0000) &gt;&gt; 16; g += (col &amp; 0x0000FF00) &gt;&gt; 8; b += (col &amp; 0x000000FF); } } int total = width * height; r = r / total; g = g / total; b = b / total; int avggray = (int)((float)r * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d2324161433f3271b6e47870c7ab018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f30db7b715eefa9c11dfc4b73f04bd/" rel="bookmark">
			过滤器和拦截器实现Http请求日志记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过滤器和拦截器实现请求出入参日志记录 前言 项目中记录请求日志是重要的非业务功能，记录请求出入参是常见的方式。一方面，项目本身提供的Http接口需要记录外部的访问记录。另一方面，项目调用第三方服务的Http接口也需要记录请求日志。
请求日志实现方案 方案一：请求日志可以使用AOP实现，给Controller层定义一个切面，统一记录出入参即可。这种方式在我的上一篇博文已经介绍。
方案二：Http请求在项目中本身可以通过过滤器或拦截器处理，而AOP切面自定义成本较高。一个针对Controller层方法的切面并不能保障请求日志的完整性，还要有针对ControllerAdvice层方法的切面。如果项目中调用了多方服务的Http接口，那么需要定义更多的AOP切面。所以利用Tomcat官方或Spring官方提供的过滤器和拦截器处理请求日志也是不错的方案。
过滤器实现记录项目本身Http接口的请求日志 问题：过滤器中记录请求出入参日志，绕不开获取请求流和响应流。众所周知，请求流和响应流只能获取一次。请求处理前，在过滤器中获取请求流，则Spring MVC无法获取RequestBody。请求处理后，在过滤器中获取响应流，则前端无法再次获取ResponseBody。
解决方案：利用Spring提供的ContentCachingRequestWrapper（请求内容缓存类）、ContentCachingResponseWrapper（响应内容缓存类）解决请求流和响应流只能获取一次的问题。这两个类分别是HttpServletRequestWrapper、HttpServletResponseWrapper的子类，他们分别实现了HttpServletRequest、HttpServletResponse接口。
使用：ContentCachingRequestWrapper和ContentCachingResponseWrapper提供了getContentAsByteArray()方法，这个方法可以获取请求流或响应流。但需要注意的是，这个方法也只能调用一次，相当于只缓存了一份，用了就没了。
原理：
流对象去向原请求流Spring MVC获取缓存请求流过滤器获取原响应流前端获取缓存响应流过滤器获取 过滤器定义 import cn.hutool.core.date.StopWatch; import lombok.extern.slf4j.Slf4j; import org.springframework.web.util.ContentCachingRequestWrapper; import org.springframework.web.util.ContentCachingResponseWrapper; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.http.HttpFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.nio.charset.Charset; @Slf4j public class LogRequestFilter extends HttpFilter { @Override protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException { // 转换为请求缓存对象和响应缓存对象 ContentCachingRequestWrapper requestWrapper = new ContentCachingRequestWrapper(request); ContentCachingResponseWrapper responseWrapper = new ContentCachingResponseWrapper(response); // 过滤器放行并计时 StopWatch stopWatch = new StopWatch(); stopWatch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f30db7b715eefa9c11dfc4b73f04bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91ab643665b34c27d2cb016de728401/" rel="bookmark">
			video 标签 autoplay 实现自动播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		属性中加入 autoplay="autoplay" loop="loop" muted ： &lt;video autoplay="autoplay" loop="loop" muted&gt; &lt;source src="./xxx.mp4" type="video/mp4"&gt; &lt;/video&gt; 属性说明： autoplay：视频就绪后马上播放
loop：当媒介文件完成播放后再次开始播放
muted：视频的音频输出为静音
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5c8607c8d03f1a562cc47136808069f/" rel="bookmark">
			YOLOV5超参数设置与数据增强解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、YOLOV5的超参数配置文件介绍 YOLOv5有大约30个超参数用于各种训练设置。它们在*xml中定义。/data目录下的Yaml文件。更好的初始猜测将产生更好的最终结果，因此在进化之前正确地初始化这些值是很重要的。如果有疑问，只需使用缺省值，这些缺省值是为YOLOv5 COCO训练从头优化的。
YOLOv5的超参文件见data/hyp.finetune.yaml（适用VOC数据集）或者hyo.scrach.yaml（适用COCO数据集）文件
1、yolov5/data/hyps/hyp.scratch-low.yaml(YOLOv5 COCO训练从头优化，数据增强低) # Hyperparameters for low-augmentation COCO training from scratch # python train.py --batch 64 --cfg yolov5n6.yaml --weights '' --data coco.yaml --img 640 --epochs 300 --linear # See tutorials for hyperparameter evolution https://github.com/ultralytics/yolov5#tutorials lr0: 0.01 # initial learning rate (SGD=1E-2, Adam=1E-3) 初始学习速率 lrf: 0.01 # final OneCycleLR learning rate (lr0 * lrf) ，最终OneCycleLR学习率 momentum: 0.937 # SGD momentum/Adam beta1 weight_decay: 0.0005 # optimizer weight decay 5e-4 ,权重衰变 warmup_epochs: 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5c8607c8d03f1a562cc47136808069f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908992362ff0a11683123a860579aec6/" rel="bookmark">
			ArcGIS api for JavaScript - 发布一个GIS线上图层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS api for JavaScript如何发布一个线上的图层，下面来进行详解一下。 1. 创建一个数据库
2. 打开ArcCatalog ,双击Add Database Connerction，与所创建的数据库建立连接
3. 为所创建的ArcCatalog（这里是改为测试） 授权许可证
点击Enable Geodatabase…进入授权界面
4. 添加需要发布的图层要素
选择Import/Feature Class(multiple)导入要素类：
添加完成之后，选中所添加的要素类，鼠标右击选择Manage/Register As Versioned，勾选Register the selected…,点击Ok。
5. 发布
打开ArcMAP ,选择Catalog中所添加的要素类拖至左侧，放入地图展示
File =》共享为（share as） =》Service =》下一步 =》Service name 修改名称 =》完成。
自定义参数
分析（Analyze），
报错，双击错误，输入信息 =》 确定。重新分析（Analyze)，错误消失，发布（publishi)。
6. 查看已发布完成的图层：
浏览器 =》登陆ArcGis Service Manage（ArcGIS Server管理器）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4877e202796711ecff175e6cc3b1b2f/" rel="bookmark">
			线性表——链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表 顺序表和链表都是线性表的一种。但链表与顺序表不同的是，他的物理上与逻辑上的机构并不一致。
顺序表的话，逻辑相邻，物理上也是相邻的。所以对于一整块连续的物理地址，当我们进行插入和删除操作的时候就会需要大量的移动元素。
而链表不需要使用地址连续的存储单元，即不需要满足物理与逻辑一致，通过"链"建立数据之间的逻辑关系，当进行插入或删除操作的时候，只需要修改指针即可。
单链表 线性表的链式存储为单链表，通过任意一组存储单元来存储数据。链表通过许多节点构成，节点除了放自身的数据还有存放下一个节点的地址来保证链表的逻辑关系。而链表一般只记录头节点。结构如下：
typedef struct node{ int data; node *next; }node; typedef struct chainlist{ node *head; int size; }clist; 可以看到虽然链表解决了顺序表需要大量连续空间的问题，使其更灵活，但是也可以清楚的看到，每一个节点除了放置数据，还要多存放一个地址，那么这样的话一个数据元素所占据的空间就更大。
因为单链表的数据存放不再是连续的存储单元，所以其存储结构是非随机存取，不可以直接找到表中的某个特定节点，只能在每次寻找时从头遍历。
虚拟头节点 通常用头指针来标识一个单链表，当头指针为NULL时，则为空表。另外，为了简化操作，通常也会在链表第一个节点前加一个虚拟头节点。虚拟头不存放数据，或其存放数据是无意义的，但是他只想链表的第一个节点。
引入头节点的好处：
因为头指针指向第一个节点，而其余节点由上一个节点指向，所以在操作上有了虚拟头节点使得整个链表变得一致无论链表是否为空，其头指针都指向虚拟头而非空指针，因此也空表和非空表的处理上也得到了统一 单链表实现 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct node{ int data; node *next; }node; typedef struct clist{ node *head; int size; }clist; 这是刚刚写好的代码先定义好链表和节点。以及头文件引用。
node *newNode(int val){ node *n = (node *)malloc(sizeof(node)); n-&gt;data = val; n-&gt;next = NULL; return n; } 写一个创建节点的方法，因为在我们插入数据的时候，根据数据要求申请地址，所以需要更方便的存储。
clist *initChainList(){ clist *l = (clist *)malloc(sizeof(clist)); l-&gt;head = newNode(-1); l-&gt;size = 0; return l;	} void deleteChainList(clist *l){ node *temp; temp = l-&gt;head; while(temp){ node *t2 = temp-&gt;next; free(temp); temp = t2; } free(l); } 然后就是创建初始化链表的方法以及删除链表的方法，同样为了避免内存泄漏在删除链表的同时要先释放每个节点的空间，因为在链表中只记录头指针，所以我们需要先进行遍历释放节点。最后再释放链表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4877e202796711ecff175e6cc3b1b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e5083ff638de6993771833663b697cc/" rel="bookmark">
			Java异常的处理(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java异常 文章目录 java异常前言:异常基本介绍基本概念常见的运行异常编程异常 异常处理异常是如何抛出的?那么何选择try-catch和throws 前言: 在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的。
本章将会学习到
编译异常
运行异常
异常的处理try-catch
异常基本介绍 基本概念 java语言中,将程序执行中发生的不正常情况称为"异常".(开发过程中的语法错误或者逻辑错误不算异常)
执行过程中所发生的的异常可以分为两大类
1.Error(错误):java虚拟机无法解决的严重问题.如:jvm系统错误,资源耗尽等严重问题,比如栈的溢出属于严重错误,程序会崩溃
2.Exception:其他因编程错误或偶然的外在因素导致的一般性问题,可以使用指定的代码去快速定位
常见的运行异常 1.NullPointerException空指针异常
2.ArithmeticException数学运算异常
3.ArrayIndexOutOfBoundsException数组下标越界异常
4.ClassCastException类型转换异常
5.NumberFormatException数字格式不正确
编程异常 编程异常是在编译期间,就必须处理的异常,否则代码不能通过编译
常见的编译异常
SQLException 操作数据库时,查询表可能发生异常
IOExcepiton 操作文件时,发生的异常
FileNotFoundException当操作一个不存在的文件时,发生异常
ClassNotFoundException 加载类,而该类不存在时,异常
EOFException 操作文件,到文件末尾,发生异常
IIIegalArguementException 参数异常
异常处理 异常处理就是对异常处理的方式.
异常处理的方式
1.try-catch-finally
2.throws + 异常类型
Java提供的是异常处理的抓抛模型。
过程一：Java程序的执行过程中如出现异常， 会生成一个异常类对象，该异常对象将被提交给Java运行时系统， 这个过程称为抛出(throw)异常。
过程二：抓，可以理解为异常的护理方式。
异常对象的生成
由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出
由开发人员手动创建： Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样。
异常是如何抛出的? main-&gt;function01-&gt;function02(异常函数位置)
遇到异常后 function02-&gt;function01-&gt;main
为了保持整个程序的正常处理,所以必须对代码进行异常处理
try catch 语法
try{ 可能会异常的代码 } cath(ExceptionNum1 e){ 当产生ExceptionNum1异常会在这里进行处理 比如打印异常/比如输出对应的信息,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e5083ff638de6993771833663b697cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/427e98edb3b43e722d1946432669bf06/" rel="bookmark">
			面试-Java【之】HashMap原理，源码逐行分析，理论总结（变量、常量、数据结构、Node、TreeNode、初始化、添加、查询、更新、删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试-Java【之】HashMap原理，源码逐行分析，理论总结（变量、常量、数据结构、Node、TreeNode、初始化、添加、查询、更新、删除） 1.源码分析1.HashMap属性与变量（扩容因子、扩容阈值、结构转换阈值...）2.Node（链表节点）3.TreeNode（红黑树节点）4.初始化（new）5.插入、更新（put、putVal）6.删除（remove、removeNode）7.读取（get、getNode） 2.理论总结1.核心：数组+ 链表或者红黑树2.put 操作：首次插入：无冲突情况3.put 操作：继续操作：出现突情况时4.删除：remove5.获取：get6.补充 《目录：Java-JDBC学习》《幕》 1.源码分析 1.HashMap属性与变量（扩容因子、扩容阈值、结构转换阈值…） public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, Serializable { //默认扩容的临界值（table大于此值时，进行扩容） static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //扩容临界值的最大值 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //链表转红黑树的大小阈值（当链表长度大于8时，并且数组长度大于64时， 链表数据结构，转为红黑树） static final int TREEIFY_THRESHOLD = 8; //链表转红黑树的大小阈值（当链表长度大于8时，并且数组长度大于64时， 链表数据结构，转为红黑树） static final int MIN_TREEIFY_CAPACITY = 64; //红黑树转链表的阈值（当链表长度小于6，并且数组长度小于64时， 红黑树数据结构，转为链表） static final int UNTREEIFY_THRESHOLD = 6; //当前扩容因子（扩容时的倍数），默认0.75f static final float DEFAULT_LOAD_FACTOR = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/427e98edb3b43e722d1946432669bf06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1952a2c8e5c60c71785db2a854808101/" rel="bookmark">
			上传npm包到私有nexus仓库中《解决服务端安装npm依赖失败的问题》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上传npm包到私有nexus仓库中《解决服务端安装npm依赖失败的问题》 1. 问题背景： 最近在做后台管理系统时候，做富文本编辑器，使用到了最新版本的 "tinymce": "^6.1.0" 包。在本地安装使用没有任何问题。最近要弄自动化部署，结果提交gitlab后。自动化部署脚本运行时，执行到npm install时 tinymce这个包就会安装失败。提示“找不到该包” 2. 解决方法： 将"tinymce": "^6.1.0"下载到本地，使用 “node-tgz-downloader” 按照package-lock.json的依赖打包成tgz的包。然后上传到nexus私有仓库。然后再跑自动化脚本时，就会从私有仓库中找到这个包。 3. 具体步骤： 第一步
npm init 创建packagenpm install tinymce@6.1.0 --save 第二步
sudo npm install node-tgz-downloader -g (macOs)npm install node-tgz-downloader -g (windows) 第三步
sudo download-tgz package-lock package-lock.json (macOs)download-tgz package-lock package-lock.json (windows) 第四步
登陆私有npm仓库nexus，点击upload--&gt;再点击npm-hosted
点击上传按钮，从本地选取tgz的包，上传到本地仓库
点击上传按钮，等待上传成功
进入search页面搜索tinymce
第五步
执行自动化部署，在看结果，成功了 以上就是我对本次学习的总结，如果能帮到大家，将特别开心。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9d1c4d69d8295046a3869a2248c747/" rel="bookmark">
			Dockercompose创建redis主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis主从复制 概念 主从复制,是指将一台redis服务器的数据,复制到其他的redis服务器.前者称为主节点,后者称为从节点.
数据的复制是单向的,只能由主节点复制到从节点.Master以写为主,Slave以读为主.
主从复制,读写分离
Dockercompose 创建redis主从复制 先创建网段,便于给实例分配静态ip
docker network create --driver bridge --subnet 172.22.1.0/24 --gateway 172.22.1.1 redis-net version: "3.7" services: # 主 redis1: image: redis:latest container_name: redis1 # 根据配置文件启动 command: /bin/bash -c "redis-server /usr/local/etc/redis/redis.conf" environment: REDIS_PASSWORD: tomato ports: - 6376:6379 volumes: - /home/docker/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf - /home/docker/redis/data:/data networks: redis-net: # 指定ip ipv4_address: 172.22.1.2 # 从1 redis2: image: redis:latest container_name: redis2 # replicaof ip port 认谁为主 command: /bin/bash -c "redis-server /usr/local/etc/redis/redis.conf --replicaof 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9d1c4d69d8295046a3869a2248c747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38dc191c97e0aaf120215fc3e7f467c0/" rel="bookmark">
			Set集合详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Set集合
二.HashSet集合
foreach循环遍历
迭代器遍历数组 三.TreeSet集合
一.Set集合 Set集合其实就是一个接口，HashSet和TreeSet实现了Set接口，所有Set所具备的方法HashSet和TreeSet也是具备的。
特点：
set集合是无序的，不重复的（无序的意思是不会按照我们增加进集合的顺序）遍历通过foreach，迭代器，无法通过下标，因为set集合没有下标初始容量为16，负载因子0.75倍，扩容量增加1倍 二.HashSet集合 HashSet是实现Set集合接口的，所以Set集合所具备的，它也具备。它只储存唯一元素并且允许为空值。储存唯一元素的意思是，如果你增加两个1，那么有一个1会被干掉，只有1一个1存在。由HashMap支持。不保持插入顺序线程不安全 foreach循环遍历 如果里面有的元素增加进去会被覆盖，大家可以按住Ctrl点击add进去看源码。源码里有一个boolean的方法，该方法是判断新增加的元素在该集合是否已经存在了，如果为false那么里面已经存在和该元素一样的元素，如果为true那么里面没有该元素，增加进该集合。
注:如果已经有元素存在
package com.yjx.test; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import org.junit.Before; import org.junit.Test; public class Test01 { private Set&lt;Integer&gt; set=new HashSet&lt;Integer&gt;(); @Before public void list() { set.add(1); set.add(1); set.add(2); set.add(3); set.add(3); set.add(4); set.add(5); set.add(6); } @Test public void test01() { for(Integer e:set) { System.out.println(e); } } } set集合增加的源码里的判断元素是否在集合中存在的方法
boolean add(E e); 得到结果：
迭代器遍历数组 hasNext:判断集合中是否还有元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38dc191c97e0aaf120215fc3e7f467c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63e5e2b048da1536c5f8c48683017208/" rel="bookmark">
			JSON在线序列化网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、菜鸟JSON 2、JSON在线视图查看 3、JSON在线编辑 4、JSON在线编辑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea6903348ced32ddc4ecae2dcd6fac0/" rel="bookmark">
			Navicat Premium操作Mongodb(基本的增删改查)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 启动服务端
二 客户端操作
2.1 创建数据库
2.2 创建集合
2.3 数据的增删改查
1 添加数据(文档)
2 查询数据
3 修改数据
4 删除数据
一 启动服务端 启动服务端详细在这里
为了启动方便,可以创建一个启动cmd命令文件:
创建一个记事本:写mongod --dbpath=..\data\db
修改文件名为mongodb_startup.cmd,发送到桌面快捷方式,鼠标双击启动
二 客户端操作 客户端使用的工具为Navicat Premium
链接：https://pan.baidu.com/s/1RKsEQTB8YTwGmLQ9YSEQCg 提取码：0628 2.1 创建数据库 文件--新建连接--Mongodb--起名字--测试连接--确定
连接名字上--右键--打开连接
连接名字上--右键--新建数据库--起名字
数据库名字上--右键--打开数据库
2.2 创建集合 集合--新建集合
点保存
给集合起名字
2.3 数据的增删改查 1 添加数据(文档) //1 新增数据2种方式 db.book.save({"name":"springboot"}); db.book.insert({"name":"mango good"}); db.book.save({"name":"springboot",type:"工具书"}); 2 查询数据 //2 查询所有数据2种写法 db.book.find() db.getCollection("book").find() //2 条件查询 db.book.find({type:"工具书"}) 3 修改数据 update
修改之前
//3 修改"name":"springboot"的数据为"name","springboot2" //update:遇到满足条件的第一条数据修改 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dea6903348ced32ddc4ecae2dcd6fac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3df89c06c8dd39749e4ad84eb3c314/" rel="bookmark">
			leetCode 46. 全排列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：
输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：
输入：nums = [1]
输出：[[1]]
思路 解决一个回溯问题，实际上就是一个决策树遍历的过程
路径：也就是已经做出的选择。
选择列表：也就是你当前可以做的选择。
结束条件：也就是到达决策树底层，无法再做选择的条件。
/** * @param {number[]} nums * @return {number[][]} */ var permute = function(nums) { let res = [] // 存放结果的数组 const fn = (path)=&gt;{ if(path.length === nums.length){ // 循环结束条件 res.push([...path]) return } for(let a = 0; a &lt; nums.length; a++) { if( path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a3df89c06c8dd39749e4ad84eb3c314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1dfd3356a1446711b446930096ca60/" rel="bookmark">
			computeIfAbsent()和computeIfPresent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程中经常遇到这种数据结构，判断一个map中是否存在这个key，如果存在则处理value的数据，如果不存在，则创建一个满足value要求的数据结构放到value中。
简单解释一下：
map.computeIfAbsent（x,y） map中不存在key为x的值时，将y作为value，x作为key放入map中。
computeIfPresent（x,y）–&gt; 1.返回与指定键关联的新值 2.如果没有与键关联的值，则返回null
代码示例：
public class J1 { static Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;() { { put("age", 12); put("name", 10); } }; static Map&lt;String, Map&lt;String, Integer&gt;&gt; mapHashMap = Maps.newHashMap(); public static void main(String[] args) { // map.computeIfAbsent("sex", key -&gt; {return 5;}); mapHashMap.computeIfAbsent("sex", key -&gt; Maps.newHashMap()); mapHashMap.computeIfPresent("sex", (key, value) -&gt; { value=map; return value; }); System.out.println(mapHashMap); } } 运行截图如下：
附源码：
default V computeIfPresent(K key, BiFunction&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba1dfd3356a1446711b446930096ca60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22108c4cb02d5a72e3c7618d0a2590d6/" rel="bookmark">
			Java常用17个工具类方法，提升开发效率的“轮子”，避免重复造轮子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Collections 首先出场的是java.util包下的Collections类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。
1.1 排序 在工作中经常有对集合排序的需求。
看看使用Collections工具是如何实现升序和降序的：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Collections.sort(list);//升序 System.out.println(list); Collections.reverse(list);//降序 System.out.println(list); 执行结果：
[1, 2, 3] [3, 2, 1] 1.2 获取最大或最小值 有时候需要找出集合中的最大值或者最小值，这时可以使用Collections的max和min方法。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Integer max = Collections.max(list);//获取最大值 Integer min = Collections.min(list);//获取最小值 System.out.println(max); System.out.println(min); 执行结果：
3 1 1.3 转换线程安全集合 我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。
换句话说，这些集合在多线程的环境中，添加数据会出现异常。
这时，可以用Collections的synchronizedxxx方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); List&lt;Integer&gt; integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合 System.out.println(integers); 它的底层会创建SynchronizedRandomAccessList或者SynchronizedList类，这两个类的很多方法都会用synchronized加锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22108c4cb02d5a72e3c7618d0a2590d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a708cf2b249f4bdf24a1344be37c4c45/" rel="bookmark">
			泛微移动端数据库 ：H2数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、H2数据库介绍 常用的开源数据库有：H2，Derby，HSQLDB，MySQL，PostgreSQL。其中H2和HSQLDB类似，十分适合作为嵌入式数据库使用，而其它的数据库大部分都需要安装独立的客户端和服务器端。
H2的优势：
1、h2采用纯Java编写，因此不受平台的限制。
2、h2只有一个jar文件，十分适合作为嵌入式数据库试用。
3、h2提供了一个十分方便的web控制台用于操作和管理数据库内容。
二、H2数据库下载和安装 2.1、H2数据库下载 H2数据库下载地址：http://www.h2database.com/html/download.html
下载完成之后，得到如下图所示的压缩包：
2.2、H2数据库安装 H2数据库的安装非常简单，直接将下载下来的压缩包解压缩即可，如下图所示：
这样，H2数据库就算是安装完成了
2.3、测试H2数据库 首先介绍一下H2数据库的目录结构
h2
|---bin
| |---h2-1.1.116.jar //H2数据库的jar包（驱动也在里面）
| |---h2.bat //Windows控制台启动脚本
| |---h2.sh //Linux控制台启动脚本
| |---h2w.bat //Windows控制台启动脚本（不带黑屏窗口）
|---docs //H2数据库的帮助文档（内有H2数据库的使用手册）
|---service //通过wrapper包装成服务。
|---src //H2数据库的源代码
|---build.bat //windows构建脚本
|---build.sh //linux构建脚本
运行h2.bat批处理程序启动H2数据库，如下图所示：
打开浏览器，输入地址：http://localhost:8082访问H2数据库的Web Console，如下图所示：
能够看到这个界面，就说明了H2数据库可以正常使用了。
三、简单使用H2数据库 3.1、登录H2数据库的WebConsole控制台 连接测试通过之后，点击【连接】按钮，登录到test数据库的webConsole，如下图所示：
3.2、创建表 复制H2数据库提供的样例SQL脚本，如下图所示：
执行SQL脚本，如下图所示：
SQL脚本执行结果：
全部正常执行成功，此时就可以看到创建好的TEST表，如下图所示：
3.3、test数据库文件存放位置说明 在上面的操作中，我们使用jdbc:h2:~/test这个URL通过JDBC的方式连接上了test数据库，如下图所示：
然后在test数据库中创建了一张TEST表，并对TEST表执行了CRUD操作，那么这个test数据库的文件存放在哪个目录下呢，这里就需要说明一下"~"这个符号在window操作系统下代表什么意思了，在Window操作系统下，"~"这个符号代表的就是当前登录到操作系统的用户对应的用户目录，所以test数据库对应的文件存放在登录到操作系统的用户对应的用户目录当中，比如我当前是使用Administrator用户登录操作系统的，所以在"C:\Documents and Settings\Administrator\.h2"目录中就可以找到test数据库对应的数据库文件了，如下图所示：
3.4、创建新的数据库 点击【连接】按钮，就可以进入gacl数据库的控制台了，如下图所示：
此时就可以看到H2自动创建好的gacl数据库和gacl用户，然后在E:\H2目录下也可以找到gacl数据库对应的数据库文件，如下图所示：
同样的，我们也可以在新创建的gacl数据库中创建表，并对表进行CRUD操作，如下图所示：
以上就是H2数据库的简单入门，下一篇博文将讲解如何在java程序中操作H2数据库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6b78b15e3c1731b97b0cbd656a23d7/" rel="bookmark">
			docker swarm 布署minio集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：毕业季·进击的技术er
docker swarm 布署minio集群 环境：ubuntu18.04服务器 4台，docker(docker-compose，docker swarm)
分为主节点（1个）和从节点(3个)：
192.168.44.134 root1
192.168.44.135 root2
192.168.44.136 root3
192.168.44.137 root4
一、初始化主节点 1.主节点下执行以下命令 docker swarm init --advertise-addr 192.168.44.134 如果出现：Error response from daemon: --live-restore daemon configuration is incompatible with swarm mode
可尝试此解决方法：
vim /etc/docker/daemon.json --- "live-restore": true 修改true为false "live-restore": f --- # 重启Docker systemctl restart docker.service 后面若出现这个错也是一样
2.查看节点信息 docker node ls 二、将子节点添加到主节点swarm 1.在子节点运行docker swarm join ... 在docker swarm init中得到的输出docker swarm join --token SWMTKN-1-25i33klsk74p0oarwrbsyge4ggmrvto33o42iinm8oho1geksu-6vqqb5s56mdjrlpausbt2hhah 10.0.0.151:2377在各个子节点运行
若没有则在主节点执行docker swarm join-token worker,也可获得
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6b78b15e3c1731b97b0cbd656a23d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea17f607748d983639f8e04a66f293e/" rel="bookmark">
			强转对象方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java强转对象的时候我们一般会写成如下
Object target =map.get(key); TargetBeanClass bean = null; if(target !=null){ bean= (TargetBeanClass )target ; } 强转对象可以写如下方法，target是null就返回null，不需要再判断强转的对象是否是null在转换会对应的对象来了
public &lt;T&gt; T zhuanhuanduixiang(Object target) { return (T) target; } 那么只需要在调用的地方直接使用该方法包装就可以了，保证代码的简介性可读性 ``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bceb471d094749606dfa2b19ec4f1e4/" rel="bookmark">
			企企通登顶《2022国产SRM供应商管理系统合集》榜首
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软服之家是专注于企业级软件行业的智能平台，平台的数据研究中心根据平台数据整理了2022最新SRM供应商管理系统合集。企企通拥有成熟完善的数字化供应链解决方案和专业到位的服务能力，登顶榜首。
2022国产SRM供应商管理系统合集
01 企企通SRM系统 企企通SRM系统是一个基于互联网服务/技术架构的新一代集成协同平台，致力于帮助改进企业采购管理，缩短业务管理周期时间，减低企业采购成本，提升采购质量和现金管理水平，助力企业打造绿色智能供应链。主要功能包括供应商生命周期管理、寻源、招投标、采购、合同、收发货、财务对账等，核心是实现供应商管理和采购业务管理的闭环，实现在业务、系统、人到物等多个维度的集成和协同。
推荐理由：
以实现供应商全生命周期管理及采购闭环管理为核心，实现多品类采购策略管理。
供应商门户：为内外部用户提供统一的登录界面，方便用户注册、登录，及发布信息和收集反馈意见。
供应商全生命周期管理：从供应商注册、准入、验厂到考评、整改及淘汰的全过程管理，平台支持按照供应商类别设置准入及考评标准、实现全程的采供互动协同、建立多个供应商资源池。
采购需求管理：管理生产性和非生产性的采供需求，实现从需求提报、审批、预算控制到需求池汇总的全过程透明管理，支持需求与供应商的互动协同。
采购寻源：支持多种采购寻源策略，实现采购寻源过程的标准化、规范化，帮助企业实现高效、合规、阳光采购，提升工作效率，有效降低企业采购成本。
合同管理：实现采购合同的生命周期管理，从合同条款、模版、电子合同到合同的履行监控及归档。帮助企业建立结构化电子合同库，形成企业规范的合同条款库，实现合同标准化，提升审核效率，降低企业风险。
订单管理：实现企业和供应商之间的订单信息协同，减少了沟通成本和，实现订单和需求的一站式管理。
交货管理：收发货环节往往关系着材料供应和库存，送发货频繁的确认和变更，货物的清点记录花费较多的时间和精力，交货管理模块能够帮助企业合理的管理交货流程和有效管控库存，提升工作效率和准确性，降低企业成本。
对账结算管理：财务对账结算工作量大，极易出错，企业与供应商之间需要核对对账周期的库存账和财务帐。企企通SRM财务对账结算功能能够与ERP和OA深度集成，帮助企业快速高效准确的完成对账、开票验真、审核等过程的管理。
供应商协同：支持与采购相关的协同事项，事项采供双方的高效工作，主要包括质量协同、研发协同及产能协同等。
报表分析：SRM系统可根据供应链各级别人员不同的需求生成多种形式及需求的报表。支持定制数据报表、图形化报表，极大降低人工统计报表的工作量，确保数据的及时性与准确性。
02 SRM系统赋予企业更多价值效能 首先，数字化采购提升效率。采购业务线上化，企业内部系统打通，外部连接供应商群，采购双方在同一个平台进行信息共享，及时沟通，在线高效完成业务协同。
第二，降低采购与管理成本。多种寻源方式，扩大寻源范围，拓展供应商资源，降低寻源成本。业务信息数据集成，数据面板可视化，科学决策，降低库存、提高计划可执行性，降低采购成本、减少管理支出。采购全流程优化，双方为彼此提供更优质的采购服务。
第三，合规与风控两手抓。采购业务经由平台上进行，合规业务流程，规范采购过程，全线上操作，数据信息化留存，实时追溯，在透明化、阳光化的环境下完成采购。采购过程无法人工干预，避免不合规环节的出现。同时，大数据和算法驱动，辅助企业管理层智慧决策、优化决策。
第四，创新和服务提升。SRM系统，赋能采购方与供应商建立良好的供应链生态。企企通打造的PaaS平台，底层技术支撑企业应用，提升企业管理系统更新的成本与效率。在服务上，产品咨询运维全方位护航，并提高多种服务标准的交付方案，保障企业成功实施上线。
企企通专注SRM领域，已服务1000+家企业升级采购数字化，包含众多500强企业，覆盖高新科技、汽车、新能源、材料化工、机械设备、食品餐饮、消费品、家居、电商贸易、电子通讯、工程、地产、商超酒旅、医药零售、公共服务、办公用品、物业等30+行业，赢得广大客户的信赖与赞誉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98934084ac433599f8f5193f0e051e9/" rel="bookmark">
			PO BO VO DTO POJO DAO DO这些Java中的概念分别指一些什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到一篇文章，通俗易懂的解释了pojo相关概念，原文链接，StevenZhang：
https://www.zhihu.com/question/39651928/answer/2490565983
上班，无聊来写写，打发一下，看官老爷们觉得有问题请评论区指出，但请不要抬杠，答主也会认真看评论。
就比如说我用一个实际场景举例子吧，你更好懂，假如有一张user表，里面有几个字段：
user_iduser_namepass_wordcreate_timedept_id 假设就这么多吧，一张很基础的表，那么对应Java的写法就是一个类： class User{
private Long userId;
private String userName;
private String passWord;
private LocalDateTime createTime；
private Long deptId;
//getter setter constrcutor …【可以用lombok，随意，我这里就省略了】
}
那么我现在需要对于User这张表进行增删改查，那么如果我假设你学过Mybatis?还是JPA这种持久层框架的话，或者你只要学过JDBC的话，你就应该知道，Java中肯定需要一个对象来映射数据库的这张表。User类的每个属性就是数据库表的每一个字段，该类的每一个对象就代表数据库中的每一行，List&lt;User&gt;就代表该表的所有记录。
这个User类就被称为PO，一般也不会加PO的说法，这个类一般就是User。
下面来说说DTO和VO。Data Transfer Object和View Object（不知道拼错没有？大概就这个意思）下面用一个实际场景解释一下：
比如，User这张表，一般在前端我们会进行分页+条件查询，然后在前端用一个列表组件，对于后端请求过来的数据做渲染。对于CRUD来说，这也是一个基本的需求。
那么假设现在有这样一个情况：假设我们再简化一下情况，我们只做条件查询，我需要按照用户名userName模糊匹配，用户创建时间createTime区间匹配的时候，我后端应该如何写？
或者换言之，我后端应该用一个什么对象来接收前端传过来的请求参数？
这时候我们来想想，User类对象，他还能胜任吗？userName还好说，那create Time的区间怎么表示呢？
显然这时候我们就不能在后端这样写了：
public XXX【返回值】 selectUserByCondidition(@RequestBody @Validated User user); 光靠一个User对象我们是不足以接收前端传过来的请求参数的，那你说我可以这样啊：
public XXX【返回值】 selectUserByCondidition(String userName,
LocalDateTime startTime,
LocalDateTime endTime) 。。。。。
这还只是两个字段的条件，如果字段一但多起来了，你确定这样写？你确定老板看了以后不会让你当场毕业？
。。。。。
所以这时候我们就要用到DTO了，数据传输对象，用于在网络中涉及到数据传输的封装对象。那么此时我们就可以在后端定义这样一个DTO：UserQueryConditionDTO【用户条件查询DTO】
public class UserQueryConditionDTO{
private String userName;
private LocalDateTime startTime;
private LocalDateTime endTime;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98934084ac433599f8f5193f0e051e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c95d722c5678351ed4f6de72ac6cde0/" rel="bookmark">
			小白买电脑看哪些配置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能： 电压 intel型号中有Y的是超低电压，U为低电压，H为标准电压。
CPU在同等的电压等级下M3，i3，i5，i7可以看做性能从低到高，如果电压不同的话就很难进行比较了。电压越高，性能越强，电脑的续航能力也越弱。
传统上，轻薄本大多使用Y级别超低电压处理器或者U级别低电压处理器，而游戏本往往使用HQ级别标准电压处理器。
对于日常的office系列软件，看电视剧等，Y级别超低电压处理器就可以满足需求。如果想要学习使用PS，轻度的视频剪辑，偶尔玩玩小型网游，那么建议U级别低电压处理器。如果是经常玩大型游戏，或是频繁使用PS，想学习复杂的视频剪辑特效，三维建模，那么建议使用标准电压处理器。
i3 -i5 -i7 相同电压等级下，新一代CPU往往比前一代性能更好，续航更佳。
核心数 是不是核心数越多，CPU的性能就越强？只有同一制程，同一架构，同一代，同一电压等级的处理器才能相互比较。比如AMD的笔记本处理器总是被奸商称为真四核，双卡交火等等，但是实际上，大概是一核有难三核围观吧。
续航： 电压越高，性能越强，电脑的续航能力也越弱。
工艺越精细，电脑续航能力越强。
相同电压等级下，新一代CPU往往比前一代性能更好，续航更佳。
参考：
https://www.sohu.com/a/194322031_343935
内存（RAM） 内存越大，可以同时运行的程序越多，越复杂。对于我们大多数人的需求，内存只需要关注容量就可以了。
对于多数人来说，8G的内存是最适合的，不管是轻薄本，还是在游戏本上运行大型单机游戏都是可以的。不过这样的电脑价格一般在4500以上，对于预算不足的萌新来说可能有些拙计。那么4G内存可以支持多少程序运行呢？其实还是和前面的Y系列处理器差不多，一般的office系列和看电视剧没有问题。如果是专业一些的需求，4G内存可以支持编辑一个复杂的PPT同时运行一个效果简单的photoshop。在合理的管理程序的情况下，4G内存还是可以胜任很多任务的。
显卡 显卡分为核心显卡和独立显卡。
核心显卡： 笔记本平台的intel处理器都带有核心显卡。带有独立显卡的电脑，在轻度负载的情况下使用核心显卡来节约能源，当遇到游戏，需要硬件加速的场景会自动切换到独立显卡来获得更高性能。
如果你没有任何游戏或是PS等后期软件的需求，那用核心显卡就足够了，便宜又省电。如果你想用PS等后期软件，或者小玩一把LOL等小型网游，那么MX150也可以满足你的需求。以上两个显卡多用于轻薄本中。
独显： 独显如果不是打游戏，平时办公用不上，还拉低续航。
硬盘（固态硬盘SSD和机械硬盘HDD） 机械硬盘： 在实际使用程序的时候，系统运行时间长了，文件没有办法连续保存在磁盘的某一位置，被分散开存储，磁头就会来来回回移动，还要等待磁盘旋转到相应的位置，才会开始读取相应的文件，这就是以前电脑用久了会慢慢变卡的原因之一。
固态硬盘：在读取文件，尤其是小文件的时候，固态硬盘就能做到比机械硬盘快数十倍的速度，这就直接反映在电脑能快速开机，程序能快速响应上。而且没有活动部件的特性也使得存储在固态硬盘上的数据更加可靠，不会因为运行时的震动而损坏。
屏幕（IPS or TN） 屏幕的材质可以分为两类，一类是较新的IPS屏，一类是较旧的TN屏。屏幕的主要参数还有分辨率（像素点的数量，比如19201080,1366768甚至2560*1440），色彩范围（能把多少印刷色彩显示出来），可视角度（从侧面看显示器）和刷新率（每秒刷新多少帧）。
TN屏： 色彩发白，侧面完全不能看的屏幕。
为什么玩FPS游戏需要优先选择TN屏？
由于IPS屏幕的特性，屏幕刷新率不能做的特别高，一般是60Hz，玩射击类游戏的话就会遇到画面撕裂，反应相对迟缓的问题。而TN屏的刷新率普遍可以做的很高（比如120Hz）。当然TN屏并不是总是坑货。高端的TN屏可视角和色域未必比低端的IPS差。只是在我们最容易接触到的价位，TN屏的表现都是远弱于IPS屏的。
PS屏： 一定要买分辨率在1920*1080或更高的IPS屏。现在的主流轻薄本（不包括thinkpad 8000元以下的电脑）和大多数游戏本（除了华硕的飞行堡垒）大多都是配备这个等级的屏幕的。
NTSC是一种色彩空间的定义，一般认为72%NTSC色域近似于100%sRGB色域，这是比较好的屏幕了。而我们最常接触到的是45%NTSC或是60%NTSC色域的屏幕。绘画和影视后期要求颜色在屏幕上是真实的，打印下来或者放在其他设备上显示不会出现偏差。所以绘画和影视后期最好使用72%NTSC色域甚至更高色彩空间的显示器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8821fce0a3f1991fc5b6d91a3f9d3982/" rel="bookmark">
			Set集合（超详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回顾问题: 上一期我们讲了list集合，它的一个显著特点就是读取速度快，元素可重复，可以自动扩容！！！有一个问题，在上一期中，我们使用foreach去删除元素是会发现在两个相邻的同一样的元素中会发生执行错误，如果我们没有重复相邻的两个元素，再去删除，还是会有问题，但我们如果刚好删除的是倒数第二个元素，就可以正常删除，这是为什么呢，我们一起来看看。
下面的图都为源码：
大家首先看到这里的这个方法，在使用list进行foreach进行删除的时候我们就会进入到这里来，然后进行删除，那具体是怎么样的呢，其实在使用foreach进行删除的时候是调用的一个iterator来进行的，这个迭代器就是我们的array list的内部类中的iterator，它进入到这里之后会调用hasnext方法进行cursor进行一个和集合元素的长度进行比较，如果不相等就还有元素，然后接着往下走，调用next方法先去进行一个检查维护，那这个modCount是什么呢，它其实是我们的集合的大小，当我们集合元素大小发生变化是就会更着改变，例如，如果集合原本大小为5，此时插入一个元素，就变成了6.modCount也变成了6，减少一个变成4，modCount也变成了4。所以我们就会发现，在我们用foreach进行list的删除时这个检查约束过不不了就直接抛出异常了，而为什么倒数第二可以呢，以为删除它就变成倒数第一了，来不及检查约束就已经删除了，其实这也时一个特性，但它本质是一个bug。
检查方法
Set集合 特点： 1. 特点：无序，不重复
2. 遍历：foreach，迭代器
3. 扩容： 初始容量16，负载因子0.75，扩容增量1倍
实现类 HashSet 特点： 1.它存储唯一元素并允许空值，依据对象的hashcode来确定该元素是否存在
2. 由HashMap支持
3. 不保持插入顺序
4. 非线程安全
5. 性能参数：初始容量，负载因子，默认值： 初始容量16，负载因子0.75，示例：new HashSet&lt;&gt;(20, 0.5f);
实例 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); private Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); @Before public void setup() { list.add(1); list.add(4); list.add(4); list.add(8); list.add(8); list.add(12); list.add(16); set.add(1); set.add(2); set.add(3); set.add(3); set.add(4); set.add(4); set.add(5); } @Test public void setdome01() { List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(new HashSet&lt;Integer&gt;(list)); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8821fce0a3f1991fc5b6d91a3f9d3982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50516124140226c90d3f4dd931fbc1d9/" rel="bookmark">
			沁恒CH341是一个USB总线的转接芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
CH341是一个USB总线的转接芯片，通过USB总线提供异步串口、打印口、并口以及常用的2线和4线等同步串行接口。 在异步串口方式下，CH341提供串口发送使能、串口接收就绪等交互式的速率控制信号以及常用的MODEM联络信号，用于为计算机扩展异步串口，或者将普通的串口设备直接升级到USB总线。 在打印口方式下，CH341提供了兼容USB相关规范和Windows操作系统的标准USB打印口，用于将普通的并口打印机直接升级到USB总线。 在并口方式下，CH341提供了EPP方式或MEM方式的8位并行接口，用于在不需要单片机/DSP/MCU的环境下，直接输入输出数据。 除此之外，CH341B/F/A芯片还支持一些常用的同步串行接口，例如2线接口（SCL线、SDA线）和4线接口（CS线、SCK/CLK线、MISO/SDI/DIN线、MOSI/SDO/DOUT线）等。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
特点
概述
全速USB设备接口，兼容USB V2.0，外围元器件只需要电容。
可选：通过外部的低成本串行EEPROM定义厂商ID、产品ID、序列号等。
支持5V电源电压和3.3V电源电压。
低成本，直接转换原串口外围设备、原并口打印机、原并口外围设备。
提供SOP-28、SSOP-20、QFN28三种无铅封装，兼容RoHS。
由于是通过USB转换的接口，所以只能做到应用层兼容，而无法绝对相同。
异步串口
仿真标准串口，用于升级原串口外围设备，或者通过USB增加额外串口。
计算机端Windows操作系统下的串口应用程序完全兼容，无需修改。
硬件全双工串口，内置收发缓冲区，支持通讯波特率50bps～2Mbps。
支持5、6、7或者8个数据位，支持奇校验、偶校验、空白、标志以及无校验。
支持串口发送使能、串口接收就绪等传输速率控制信号和MODEM联络信号。
通过外加电平转换器件，提供RS232、RS485、RS422等接口。
支持以标准的串口通讯方式间接地访问CH341外挂的串行EEPROM存储器。
打印口
标准USB打印口，用于升级原并口打印机，兼容相关的USB规范。
兼容Windows操作系统，在Windows 2000和XP下无需驱动程序，应用程序完全兼容。
支持各种标准的并口打印机，可选低速打印方式和高速打印方式。
支持IEEE-1284规范的双向通讯，支持单向和双向传输打印机。
并口
提供两种接口方式：EPP方式和MEM方式。
EPP方式提供AS#、DS#、WR#等信号，类似于EPP V1.7 或 EPP V1.9。
MEM方式提供A0、RD#、WR#等信号，类似于存储器读写方式。
同步串口
采用FlexWireTM技术，通过软件能够实现灵活多样的2线到5线的同步串口。
作为Host/Master主机端，支持2线和4线等常用的同步串行接口。
2线接口提供SCL和SDA两个信号线，支持4种传输速度。
封装
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
注：CH341C/T仅用于USB转串口或者USB转2线接口。 CH341H仅用于USB转4线接口等（例如SPI），新设计不推荐使用，建议用CH341B或CH341F。 CH341A、CH341T和CH341H必须外接晶体及振荡电容。 CH341B、CH341F和CH341C既可以选择外接晶体及电容，也可以选择不外接而直接使用内置时钟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aff29d7770234d3ce47552bad812066/" rel="bookmark">
			沁恒CH9102是一个USB总线的转接芯片，实现USB转高速异步串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
沁恒CH9102是一个USB总线的转接芯片，实现USB转高速异步串口。提供了常用的MODEM联络信号，用于为计算机扩展异步串口，或者将普通的串口设备或者MCU直接升级到USB总线。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
特点
全速USB设备接口，兼容USB V2.0。
内置固件，仿真标准串口，用于升级原串口外围设备，或者通过USB增加额外串口。
计算机端Windows操作系统下的串口应用程序完全兼容，无需修改。
支持免安装的操作系统内置CDC类驱动程序或者多功能高速率的VCP厂商驱动程序。
硬件全双工串口，内置独立的收发缓冲区，支持通讯波特率50bps～4Mbps。
串口支持5、6、7或者8个数据位，支持奇校验、偶校验、空白、标志以及无校验。
支持常用的MODEM联络信号RTS、DTR、DCD、RI、DSR、CTS。
支持CTS和RTS硬件自动流控。
支持半双工，提供正在发送状态TNOW支持RS485切换。
通过外加电平转换器件，支持RS232接口。
USB端支持5V电源电压和3.3V电源电压。
CH9102F串口I/O独立供电，支持5V、3.3V和2.5V甚至1.8V电源电压。
CH9102X串口I/O支持3.3V信号。
内置上电复位，内置时钟，无需外部晶振。
CH9102F内置EEPROM，可配置芯片VID、PID、最大电流值、厂商和产品信息字符串等参数。
芯片内置Unique ID(USB Serial Number)。
提供QFN24和QFN28无铅封装，兼容RoHS。
封装
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
注：CH9102F和CH9102X的底板是0#引脚GND，是可选但建议的连接；其它GND是必要连接。 CH9102X的VIO引脚与V3引脚已在内部短接。 CH9102的USB收发器按USB2.0全内置设计，UD+和UD-引脚不能串接电阻，否则影响信号质量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051d93f849b7397555ccad07f0e58ff4/" rel="bookmark">
			syntax error near unexpected token in 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言：
二、问题解决：
三、总结：
一、引言： 近来在使用 shell 脚本时，从服务器上把脚本文件拿下来，本地修改完之后上传至服务器，运行时出现了如下的错误信息：
最终排查之后，发现是系统兼容性问题，现就解决方案做出说明：
二、问题解决： 首先查看文件格式，使用 notepad++ 打开文件，依次选择视图 -&gt; 显示符号 -&gt; 显示行尾符，然后就看到了预料到的，所有的回车换行都是 Windows 下的 CR LF：
得知是 Linux 和 Windows 下的回车换行符不兼容的问题。所以，剩下的就是将 Windows 下面的 CR LF，转换为 Linux 下面的 LF 即可，如下：
依次选择编辑 -&gt; 文档格式转换 -&gt; 转换为 UNIX 格式：
即可将所有的 CR LF，转换为 LF：
保存之后再运行此 shell 脚本，即可正常运行了。
三、总结： linux/cygwin 下面的 shell 脚本出现错误：syntax error near unexpected token `$’do\r”，是由于该脚本文件是在 Windows 环境下创建编辑的，其默认是将所有的回车变成：CR 加上 LF，而Linux/Unix 中的回车只是 LF，所以导致解释器不认，出现此错误。
所以解决办法就是，将所有的 CRLF 转换为 LF 即可，转换的方法有多种，比如用 dos2unix，或者直接使用 notepad++ 帮我们转换，都是可以的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051d93f849b7397555ccad07f0e58ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af2e1318a4b549b65fd8b318a871405/" rel="bookmark">
			经典模型——Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 AbstractIntroductionBackgroundModel ArchitectureEncoder and Decoder StacksBatchNorm与LayerNorm AttentionScaled Dot-Product AttentionMuti-Head AttentionApplications of Attention in our Model Position-wise Feed-Fordward NetworksEmbedding and SoftmaxPositional Encoding Why Self-AttentionConclusion MLP、CNN、RNN后的第四大模型。
Abstract 序列转录模型主要是采用RNN或者CNN。里面常常包含一种编码器和解码器的结构。
仅仅依赖于注意力机制。
该篇文章主要是针对机器翻译做的。后来应用在了不同的领域。
Introduction 问题：
RNN是一个一步步计算的过程，无法并行，计算性能很差；时序信息会随着序列的移动而丢失。 注意力机制很早就和RNN有所结合，更好地实现了编解码器之间的数据交互。
但是本文舍弃了RNN的结构，完全采用注意力机制来完成。
Background 用卷积神经网络对比较长的序列难以建模，需要用很多层卷积扩大感受野。卷积的优势在于有多个输出通道，每个通道可以学一个模式。
因此，本文提出了多头的注意力模型。
Model Architecture 对于序列模型来说，编码器-解码器结构在序列任务中有不错的表现。
对于解码器而言，在循环神经网络中，词是一个个输出的，过去时刻的输出会作为当前时刻的输入，这称为自回归。
对于解码器而言，是可以看到全部的句子的。编码器得到的序列整个交付给解码器。
Encoder and Decoder Stacks Encoder：包含了六个堆积的模块，每个模块有两个子层。每一个模块中，两个子层都有相应的残差连接，随后经过标准化（LayerNorm）。
为了避免残差连接时，通道大小的不一致（需要做投影），本文将其的维度统一设置为512。
BatchNorm与LayerNorm Internal Covariate Shift：训练的过程中，数据的分布在不断地变化，为下一层网络的学习带来了困难。
在训练的时候，对于一个二维矩阵，行代表样本，列代表特征，BatchNorm是将每列做一个标准化（算均值、标准差，Z-score）。在测试的时候，
通常而言，最后会用可学习的参数 γ , β \gamma,\beta γ,β，对得到的标准化的结果做一个线性变换，相当于是改变了这个分布的均值和方差。
这是因为，如果全都统一成标准正态分布，那模型学习到的特征分布就完全被消除了。因此有必要给他微调的机会。
我认为BN层起到的作用应该是一方面限制其分布不要太离谱，有一个基本的雏形，另一方面又不希望都是一个模子里刻出来的。
在测试时，用到的均值和方差的参数是在训练的时候算出来的。
公式为 μ = m μ + ( 1 − m ) μ b a t c h , σ 同 理 \mu = m\mu+(1-m)\mu_{batch},\sigma同理 μ=mμ+(1−m)μbatch​,σ同理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1af2e1318a4b549b65fd8b318a871405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133644c9c3e3b9b2486587c586b96722/" rel="bookmark">
			[Vue warn]: Error in render: “RangeError: Maximum call stack size exceeded“ found in ---＞ ＜App＞ at
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在使用vuex遇到这个报错
这个报错一般是变量名重复了，仔细检查下代码改过来就能运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f6fd9b685b6cb231d9254fd872b484/" rel="bookmark">
			代理服务器出问题或挂完代理后网络连接且无网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要注意在使用完代理后需要手动关闭，否则会出现代理为关闭的状况，导致网络连接成功，但却无法正常上网。
出现以上情况需要关闭代理，在设置里搜索“代理服务器设置”
打开如上界面，关闭代理服务器即可。
当然，也可以重新打开代理，也是能正常连接网络。以上就是最近遇到的问题，如有小伙伴有其他好的办法或注意事项可留言，共同进步，谢谢。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9082a5418b42ce3daa9ec34cd4057472/" rel="bookmark">
			matlab使用记录--读取当前文件夹所有文件、找到最新创建的文件、app designer打开文件选择窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 读取当前文件夹所有某类型文件 %获取.mat类型的文件 file_search = [pwd '/*.mat']; dirData = dir(file_search); 得到的结果如下：
是以结构体的形式存储了文件的信息，可以打开看一下，包括这些：
每个结构体包括6个字段，有名字、所在文件夹、创建时间、大小、是否为文件夹、最后一个应该也是和时间有关的，我不太了解。
这样的话实际上就可以直接比较文件的date来找到最新、最老的文件：
for i = 2 : length(dirData)% 遍历 if datetime(dirData(i).date) &gt; datetime(dirData(i-1).date)%可以直接用比较运算符比较时间 %这里可以填入一些操作 end end 这样就可以用matlab找到最新创建的文件
2. 打开文件选择窗口 点击某个button，弹出当前文件夹，并可以进行选择，可以参考：matlab app使用对话框读取和保存文件
主要是uigetfile函数
存储文件 使用uiputfile函数
参考：Matlab保存axes上的图（包括坐标轴）
其中关于print函数，参考：
用print函数批量保存图片到文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0545f0e5bdb6a7bb96a1ed7a678d47c7/" rel="bookmark">
			海康工业相机参数设置（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看相机SDK，查看通用配置接口MV_CC_Set/Get(数据类型)Value,每一个参数设置对应一个数据类型，可以在XML节点参数类型列表查看。
1、曝光时间设置
可以看到曝光时间是一个Float数据类型 ，GetNode:key参数是ExposureTime，查看海康相机的官方软件MVS已获得当前相机曝光时间范围。连接上相机后，点击常用属性，在曝光时间设置停留鼠标，就可以显示出范围。
因此，曝光时间a的范围是27-25000000us，代码为：
ret = cam.MV_CC_SetFloatValue("ExposureTime", a) if ret != 0: print("Set ExposureTime fail! ret[0x%x]" % ret) sys.exit() 2、白平衡设置
1是开启自动白平衡设置，0为关闭
ret = cam.MV_CC_SetEnumValue("BalanceWhiteAuto",1) if ret != 0: print("Set BalanceRatio fail! ret[0x%x]" % ret) sys.exit() 3、软触发和硬触发
TriggerMode设置为OFF，是内触发模式，设置为ON时，是外触发模式。外触发模式可以选择为硬触发或软触发，通常TriggerSource为0时，是硬触发，为7时是软触发。具体硬触发设置为几要看接线方式。软触发就是通过软件控制进行采图，硬触发就是外部给的信号进行采图，例如流水线上返回的光电信号就可以是一个硬触发信号。
# ch: 设置触发模式为on ret = cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_ON) if ret != 0: print("set trigger mode fail! ret[0x%x]" % ret) sys.exit() # 设置触发源为软触发 ret = cam.MV_CC_SetEnumValue("TriggerSource", MV_TRIGGER_SOURCE_SOFTWARE) if ret != 0: print("Set Trigger Source fail!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0545f0e5bdb6a7bb96a1ed7a678d47c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3b369f0d051324b5a95367e9e935060/" rel="bookmark">
			css改变水平线的颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、虚线、实现、双线、多色线
&lt;hr style="background-color:#ccc;height: 1px;width:90%;border: none;"/&gt; .hr0{ height:1px;border:none;border-top:1px dashed #0066CC;} .hr1{ height:1px;border:none;border-top:1px solid #555555;} .hr2{ height:3px;border:none;border-top:3px double red;} .hr3{ height:5px;border:none;border-top:5px ridge green;} .hr4{ height:10px;border:none;border-top:10px groove skyblue;} 2、渐变水平线
hr{ width: 100%; border: 0; height: 1px; background-image: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, #09edfd 3%, rgba(0, 0, 0, 0) 80%); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c4fea31a9fea13e073bfb036220105/" rel="bookmark">
			【图片二值化处理，以及byte[] 与bitmap互相转化问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.byte与bitmap相互转换
//将byte流转换为bitmap byte[] signature = item.ToArray(); MemoryStream ms1 = new MemoryStream(signature); Bitmap bm = (Bitmap)Image.FromStream(ms1); ms1.Close(); //图片二值化处理方法 var nbm = binaryzation(bm); MemoryStream ms = new MemoryStream(); nbm.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp); var nSignature = ms.ToArray(); ms.Close(); 2.图片二值化处理
public static Bitmap binaryzation(Bitmap bitmap) { //得到图形的宽度和长度 int width = bitmap.Width; int height = bitmap.Height; //创建二值化图像 Bitmap binarymap = new Bitmap(bitmap); //依次循环，对图像的像素进行处理 for (int i = 0; i &lt; width; i++) { for (int j = 0; j &lt; height; j++) { //得到当前像素 int col = binarymap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6c4fea31a9fea13e073bfb036220105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb7540098c17cee059b4f0b5a3073d3/" rel="bookmark">
			图像识别问题 — cv2.error: OpenCV(4.5.4) D:\a\opencv-python\opencv-python\opencv\modules\highgui\src\window
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、错误原因
1.1、报错背景
1.2、报错信息：
二、解决方法
2.1、卸载：
2.2、安装：
一、错误原因 1.1、报错背景 这个报错来的一脸懵逼，因为这是在cv2.imshow()函数引发的错误。十分钟之前还能正常跑，一会的功夫就不能跑了。中间的功夫安装了一个叫 easyocr 的一个包，然后再次运行就发现cv2.imshow()报如下错误，真实莫名其妙。看网上的解决方法基本就是把包重新安装一遍，暂时没有找到其他好的办法。
1.2、报错信息： 全部的报错信息如下：
cv2.error: OpenCV(4.5.4) D:\a\opencv-python\opencv-python\opencv\modules\highgui\src\window.cpp:1274: error: (-2:Unspecified error) The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Cocoa support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script in function 'cvShowImage' 二、解决方法 2.1、卸载： win+R打开cmd，输入pip list。找到opencv的安装包并卸载（有其他依赖也最好卸载下）。如：opencv-contrib-python等等。
2.2、安装： 看到卸载完成的标志后，再安装。大概率可以解决如上报错。安装命令：pip install opencv-python
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff114d298c182ac4428bb545767625db/" rel="bookmark">
			TypeScript基础之typeof 类型操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文中内容都是参考https://www.typescriptlang.org/docs/handbook/2/typeof-types.html , 以及参考
TypeScript 之 Typeof Type Operator — mqyqingfeng 内容。
typeof 类型操作符 先来看看JavaScript中typeof的用法：
具体可参考 MDN typeof
typeof 操作符返回一个字符串，表示未经计算的操作数的类型。
类型结果Undefined“undefined”Null“object”Boolean“boolean”Number“number”BigInt(ECMAScript 2020 新增)“bigint”String“string”Symbol (ECMAScript 2015 新增)“symbol”宿主对象（由 JS 环境提供）取决于具体实现Function 对象“function”其他任何对象“object” // Undefined typeof undefined === 'undefined'; // true typeof declaredButUndefinedVariable === 'undefined'; // true typeof null === 'object'; // true TypeScript中的typeof常见用途是在类型上下文中获取变量或者属性的类型， 此外还可以配合ReturnType获取函数的返回值类型， 以及配合 keyof 使用。
如：
1. 获取变量类型 function fn (x: string | number) { if (typeof x === 'string') { x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff114d298c182ac4428bb545767625db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae0149135daf47f7f389feacc81050e/" rel="bookmark">
			SpringBoot临时属性properties、args
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置临时属性目的：应用于小范围测试环境(不是配置文件中的属性)
方式1 通过properties
@SpringBootTest(properties = {"test.prop=test111"})
方式2 通过args
@SpringBootTest(args = "--test.prop=test222")
备注:临时属性的优先级 高于 配置文件里的属性
总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e254b5fdb3ff6871c90a6be7da9646/" rel="bookmark">
			java使用jol打印对象信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些时候我们需要查看一个对象的构成，java提供了一个工具包可以实现此功能。
文章目录 1、引入jol-core2、测试3、对象结构说明3.1、对象头3.1.1、Mark Word3.1.2、KClass Word(类指针)3.1.3、数组长度 3.2、对象体3.3、对齐字节 1、引入jol-core maven:
&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt; &lt;artifactId&gt;jol-core&lt;/artifactId&gt; &lt;version&gt;0.16&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; gradle:
implementation group: 'org.openjdk.jol', name: 'jol-core', version: '0.16' 2、测试 public class JolTest { public static void main(String[] args) { User user = new User(); System.out.println(ClassLayout.parseInstance(user).toPrintable()); System.out.println("--------------------------------------------------"); User[] users = new User[10]; System.out.println(ClassLayout.parseInstance(users).toPrintable()); } } 运行结果：
com.iscas.biz.domain.common.User object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000000000000d (biasable; age: 1) 8 4 (object header: class) 0x00067248 12 4 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1e254b5fdb3ff6871c90a6be7da9646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616b824da433749e6dbfe5ece5cdaf3b/" rel="bookmark">
			Flutter Windows应用开发环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要入Flutter开发的坑？ 首先在当今Windows开发已经逐渐成为一个偏小众的领域，不仅要涉及的知识面广，还对开发人员的要求不低，界面的精美也成为一个重要因素。目前已知的Windows 客户端主要分成以下几种
开发语言Qt &amp; C++C# &amp; WPF(MAUI、WinUI3.0、UWP)JS &amp; ElectronDart &amp; Flutter开发速度较慢较快快快上手难度超级高高低适中跨平台是linux 不支持是是长期支持是不确定是Google的亲儿子个人评价QML是未来
大型应用较少 国内好像就一个剪映是这个搞的
想做出精美的复杂界面真的耗时微软小朋友说变就变
除了自家应用国内发展一言难尽
未来国内日子靠边站
一门好语言毁了·····全靠社区，前端人员利器
但内存占用性能问题真的日了狗
设备没淘汰已经无法满足性能要求是Windows客户端的未来值得探索的方向
目前看钉钉已经开始有Flutter的模块
不支持64位个人认为还好 上述对比仅是个人在有限的知识范围内的认知，如有想法欢迎分享
Flutter 2.10中的 Windows 平台支持， Flutter目前已经进入到了3.0的时代，支持了linux和macos，这个很重要，这是能在国内有发展的一个重要因素。当然目前了解到在Windows端音视频的处理上Flutter还有待进一步更新（后续自己实操确认）
个人的想法 Flutter配置入门，dart的熟悉C++ &amp; Flutter的交互Qt &amp; Flutter的混合开发Flutter PC音视频领域的探索 Flutter Windows开发环境配置 前置环境 Visual Studio 2019 C++ 完成开发环境，官方推荐Visual Studio 2022，本人2019没有任何问题
下载Fultter Flutter官方下载地址,下载完成后解压某个目录通过GitHub &gt; git clone https://github.com/flutter/flutter.git -b stable 设置环境变量 设置完成之后，点击确定，关闭所有对话框，然后关闭所有powershell和cmd窗口，再重新打开一个终端窗口
&gt; where.exe flutter dart 如果和以上一致则表示环境变量配置成功。
开发环境检查 &gt; flutter doctor 这里有个红色的x,重要吗？不重要，毕竟我们是要搞Windows 程序开发，直接忽略即可
这里直接输入
&gt; flutter devices 可以查看当前已经配置好的环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/616b824da433749e6dbfe5ece5cdaf3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eae023ec34235f3da3e27730be895e85/" rel="bookmark">
			K8s 中 ConfigMap 使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8s 中 ConfigMap 使用介绍 一、基本介绍二、ConfigMap 使用介绍1.ConfigMap 的创建2.Pod 中使用 ConfigMap 一、基本介绍 ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时，Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。ConfigMap 的主要作用就是为了让镜像和配置文件解耦，以便实现镜像的可移植性和可复用性。 官方介绍
使用 ConfigMap 的限制条件：
ConfigMap 需要在 Pod 启动前创建出来；并且只有当 ConfigMap 和 Pod 处于同一命名空间时，才可以被 Pod 引用；当 Pod 挂载 ConfigMap 绑定的目录时，目录下的目录并不会挂载到 Pod 内，只有目录下的文件会被挂载。 二、ConfigMap 使用介绍 1.ConfigMap 的创建 1）使用目录创建
kubectl create configmap nginx-html --from-file=/etc/nginx/html --from-file：指定在目录下的所有文件都会被用在 ConfigMap 里边创建一个键值对，键的名字就是文件名，值就是文件里内容。 2）使用文件创建
[root@localhost ~]# kubectl create configmap index-html --from-file=/etc/nginx/html/index.html 指定多个文件：kubctl create configmap index-html --from-file=1.txt --from-file=2.txt 3）使用字面值创建
kubectl create configmap dashboard --from-literal=dashboard.username=root --from-literal=dashboard.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eae023ec34235f3da3e27730be895e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/614618c260abbbb1fd319298a5577b87/" rel="bookmark">
			Android中Parcelable的原理和使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parcelable的简单介绍 介绍Parcelable不得不先提一下Serializable接口，Serializable是Java为我们提供的一个标准化的序列化接口,那什么是序列化呢?
进行Android开发的时候，无法将对象的引用传给Activities或者Fragments，我们需要将这些对象放到一个Intent或者Bundle里面，然后再传递。简单来说就是将对象转换为可以传输的二进制流(二进制序列)的过程,这样我们就可以通过序列化,转化为可以在网络传输或者保存到本地的流(序列),从而进行传输数据 ,那反序列化就是从二进制流(序列)转化为对象的过程.
Parcelable是Android为我们提供的序列化的接口，Parcelable相对于Serializable的使用相对复杂一些,但Parcelable的效率相对Serializable也高很多,这一直是Google工程师引以为傲的,有时间的可以看一下Parcelable和Serializable的效率对比 Parcelable vs Serializable 号称快10倍的效率
Android源码中的Parcelable
/** * Interface for classes whose instances can be written to * and restored from a {@link Parcel}. Classes implementing the Parcelable * interface must also have a non-null static field called &lt;code&gt;CREATOR&lt;/code&gt; * of a type that implements the {@link Parcelable.Creator} interface. * * &lt;p&gt;A typical implementation of Parcelable is:&lt;/p&gt; * * &lt;pre&gt; * public class MyParcelable implements Parcelable { * private int mData; * * public int describeContents() { * return 0; * } * * public void writeToParcel(Parcel out, int flags) { * out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/614618c260abbbb1fd319298a5577b87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38fd4664fd140ca83a85e532596b86a/" rel="bookmark">
			stm32蜂鸣器实现电子琴（原理&#43;代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许久没有摸32了，今天是培训的第一天，做个电子琴练练手。
编程难度很小，无非就是gpio控制引脚高低电平转换，比较值得注意的主要是一些乐理上的知识。
我们能听到的1 2 3 4 5 6 7的音符，实际上是一个个固定的频率，这个具体算我也不懂，问巴赫去吧
总而言之，通过百度，我找到了对照图
那怎么转换这个频率捏，首先来看一下频率单位——赫兹（hz）的定义：
赫兹是国际单位制中频率的单位，它是每秒钟的周期性变动重复次数的计量。
赫兹简称赫。每秒钟振动（或振荡、波动）一次为1赫兹，或可写成次/秒，周/秒。
（摘自百度百科）
这么理解，1赫兹就是一秒震动一次，而图中的高音1就是一秒震动880次。
在单片机里，想让蜂鸣器发出高音1就是一秒高低电平转换880次。
每次震动可以这么写：
GPIO_SetBits(GPIOF,GPIO_Pin_8); delay_us(5); GPIO_ResetBits(GPIOF,GPIO_Pin_8); delay_us(5); 这里就是一个50%的pwm波，记住这是一次频率转换，（博主一开始就把pwm波和频率的概念搞混了）而占空比的变化，反应的是声音的强度，占空比越大，蜂鸣器发出的声音越响。
那880hz举例子，如果我们要让蜂鸣器响高音1一秒钟，那就意味着要转换电平880次，而且，每次转换要均匀分布在1秒内，所以我们要在一秒内分割出880个时间周期，即1s/880=1136us（取整）
而这包含前面的10us，所以一次时间周期应该是这样的：
GPIO_SetBits(GPIOF,GPIO_Pin_8); delay_us(5); GPIO_ResetBits(GPIOF,GPIO_Pin_8); delay_us(5); delay_us(1136); 事实上，无论是多少秒，只要在这个时间周期内执行这段指令，蜂鸣器都会发出高音1的音调。
以下是函数代码
double connect[3][7]={{880,987.76,1108.73,1174.66,1318.52,1479.98,1661.22},{440,493.88,554.37,587.33,659.33,739.99,830.61},{220,246.94,277.19,293.67,329.63,370,415.31}}; //创建二位数组存放频率数据 void yinjie(int mst, int f,int h)//第一个参数为响的时间（ms），第二个参数确定音阶 { int t=(int)1000000.0/connect[h-1][f-1]-10;//计算时间间隔 int n=mst*1000;//转微秒 while(n&gt;0)//响的时间每次循环减去时间间隔，小于0时跳出 { GPIO_SetBits(GPIOF,GPIO_Pin_8); delay_us(5); GPIO_ResetBits(GPIOF,GPIO_Pin_8); delay_us(5); delay_us(t); n-=t+10; } GPIO_ResetBits(GPIOF,GPIO_Pin_8); delay_ms(100); } gpio初始化
void Init(){ //gpio初始化 GPIO_InitTypeDef GPIO_InitStructure; RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);//使能GPIOF时钟 //初始化蜂鸣器对应引脚GPIOF8 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;//BEEP对应引脚 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38fd4664fd140ca83a85e532596b86a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/136/">«</a>
	<span class="pagination__item pagination__item--current">137/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/138/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>