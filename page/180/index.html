<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ba121e90dc66752b72206217750557/" rel="bookmark">
			超难的智力题：12小球问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设有12个外表一模一样的小球，其中11个重量完全相同，被称为好球，1个重量比好球重一点或者轻一点，被称为坏球。现在给你一架天平，请用天平称3次，把这个坏球找出来，还要知道它到底是轻的还是重的。
注意，坏球只有一个，另外它到底是重是轻的事先不知道。
12小球问题的描述不复杂，看起来似乎也不难解。但是这个问题却相当难。大家可以试着解这个问题。下面我将给出这个问题的人工解，并在下一篇文章中给出这个问题的计算机解。
首先我们把小球分成A、B、C三组。其中每组各有4个小球。 第一次使用天平时我们把A组和B组分别放在天平的左右两边。我们用 AAAA | BBBB 来表示。这时，我们会有三种可能的结果：
AAAA = BBBB，两端平衡。这意味着坏球是一个C球。 此时，我们可以这样称：AAA | CCC。即用3个好球和3个可能的坏球进行比较。有三种可能的结果： AAA = CCC，则意味着坏球在剩下的那个C球中。我们只要把它与任意一个好球放到天平两边称就可以知道这个C球是重球还是坏球；AAA &lt; CCC，即左轻右重，这意味着坏球一定在右边这3个C球中并且一定是重球。我们只要拿出其中任意两个C球放到天平两边，那边低哪个C球就是坏球；如果两边平衡则剩下的那个C球就是坏球，且一定是重球；AAA &gt; CCC，即左重右轻，这意味着坏球一定在右边这3个C球中并且一定是轻球。我们用类似的方法只用一次天平同样可以找出这个轻球。这里我们有定理：如果有3个球，且知道坏球是重的还是轻的，则用天平称一次就能找出坏球。AAAA &lt; BBBB，左轻右重。这意味着坏球如果是轻球，那它一定是个A球；如果它是个重球，则它一定是个B球。C球当然都是好球啦。我们把天平右边3个B球拿到一边去，只留下1个B球。然后从天平左边拿3个A球放倒右边。再拿3个C球（C球都是好球）放在天平左边，即：ACCC | AAAB 。这样我们会得到3个可能的结果。 ACCC = AAAB，则意味着拿下来的3个B球中有一个是坏球且一定是重球。根据上面定理，我们再用一次天平就能从这个3个B球中找到这个重球！ACCC &lt; AAAB，这意味着坏球要么是左边的那个唯一的A球，要么是右边的那个唯一B球，其他的A球和B球统统都是好球。我们用天平再称一次A与一个好球就能判断A和B中哪个是坏球且能知道它是重的还是轻的；ACCC &gt; AAAB，这意味着天平右边的3个A球中一定有一个坏球，且一定是轻球。根据上面定理，我们再称一次天平就能从这3个A球中找到这个轻球！AAAA &gt; BBBB，这种情况是AAAA &lt; BBBB的对称情形，只需把上面讨论中的A换成B，B换成A就能解决。 我们在解决复杂或者困难的问题时，要学会把问题分解，学会归纳和总结。下面我们思考一下：你能否编个计算机程序解决这个问题呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e195371b75a683e050fcd618cfb2b36/" rel="bookmark">
			GitHub clone超时问题，最简单的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将gihub.com改成github.com.cnpmjs.org（镜像网站） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810fc7acc0cb1c964fc3e641f5c8203c/" rel="bookmark">
			能用计算机解决的问题十个,计算机常见问题及解决方法,计算机十项常见故障...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		??如今，无论在学习工作，还是生活娱乐方面，计算机已经成为我们日常生活中不可缺少的一部分。
然而，在我们使用电脑的过程当中，或许由于操作不当或者质量等问题，总会出现这样或那样的故障。
一般来说，计算机的常见故障大体分为两大类，一类是计算机的硬件问题，另一类就是软件问题。
其中，有的故障完全可以自行解决。
下面，小编将为大家介绍计算机的常见故障及其解决方法。
??
1.死机　死机是计算机的常见故障之一，基本上每个人都会遇到电脑死机的情况。
最大的可能性就是由于电脑的硬件系统比如CPU散热器出现问题，或者显卡、电源散热器损坏。
当CPU风扇出现故障时，即使并没有完全停止转动，只是转数太小，也起不到散热作用。
解决方法：　如果是CPU散热器有问题，便更换CPU散热器;显卡问题也是直接更换显卡风扇;电源散热器损坏的情况下，便需要使用螺丝刀拆开计算机内部进行更换。
2.自动关机　当电脑在正常的运行状态中，突然进行自动关机，这种计算机故障也是比较常见的。
这有可能是由于CPU的温度过高，超过了主板所设定的温度，这时就会自动切断电源。
也有可能是系统中的电源管理或者安装了某些病毒软件，这也有可能导致电脑自动关机。
解决方法：　首先要检查下CPU的散热功能是否正常，再打开主板的选项查看风扇的转速和CPU的工作温度，如果是CPU的散热器问题，可以将风扇拆下来清洗掉灰尘，或者更换质量更好的散热器。
如果是安装了带有病毒的软件，就将软件卸载并彻底查杀病毒。
如果电脑仍然自动关机，那么就可能是电源老化了或者被损坏了，这时便直接换个新的电源。
3.系统运行速度减慢　由于操作系统使用的时间过长，运行过程中产生的垃圾文件越来越多，这就会导致系统运行变慢。
解决方法：　下载一个系统优化工具，比如优化大师、超级兔仔、加速人生等，进行系统清理和垃圾删除。
4.无法播放声音　在音量有打开的前提下，音频播放却没有声音，有可能是声卡设置错了了，也有可能是驱动问题。
解决方法：　左键点击桌面右下角的扬声器，会出现声音音量调节开关控制窗口，查看是不是将音量调节到最低，或者是否勾选了静音。
或者是音箱出现问题，便更换新的音箱。
以上就是小编为大家整理的计算机常见故障和排除方法了。
使电脑产生故障的原因有很多，有的涉及专业领域，当然就需要专业的计算机修理人员进行解决。
但是，在某些紧急情况下，一些小问题也是可以自己处理的。
因此，掌握一些最为常见、典型的电脑故障的解决方法十分重要，它不仅简单、便捷，而且能有效地节约时间，提高你的工作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1cdf0d80311596d53868a01a43020f6/" rel="bookmark">
			vue 全屏 screenfull —— 整页全屏，指定元素全屏，退出全屏，全屏切换等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 npm install screenfull --save 使用方法 import screenfull from "screenfull"; 属性 screenfull.isFullscreen; // 布尔值——当前页面是否全屏 screenfull.isEnabled; // 布尔值——当前浏览器是否支持全屏 方法 默认作用于全屏，若想作用于指定元素，则将指定元素作为参数传入。
screenfull.request(); // 全屏 screenfull.exit(); // 退出全屏 screenfull.toggle(); // 全屏切换 使用范例 整页全屏 &lt;i class="el-icon-full-screen" @click="fullScreen"&gt;&lt;/i&gt; fullScreen() { if (screenfull.isEnabled &amp;&amp; !screenfull.isFullscreen) { screenfull.request(); } }, 整页退出全屏 &lt;i class="icon-exit-screen" @click="exitFullScreen"&gt;&lt;/i&gt; exitFullScreen() { if (screenfull.isEnabled &amp;&amp; screenfull.isFullscreen) { screenfull.exit(); } }, 全屏切换 &lt;i class="el-icon-data-line" @click="toggleFullScreen"&gt;&lt;/i&gt; toggleFullScreen() { if (screenfull.isEnabled) { screenfull.toggle(); } }, 指定元素全屏 &lt;img ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1cdf0d80311596d53868a01a43020f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d34682d6ee2d74fa544a839d4c05b2/" rel="bookmark">
			mjpeg视频传输和人脸识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习树莓派，想做一个人脸识别，并且把视频传输上去，想来想去想到一个方案，用mjpeg视频传输，传输上去在PC端用opencv进行人脸识别。
mjpeg：
mjpeg是由一系列连续的JPEG图片组成的视频流，因此是非帧间编码器，同时，由于是非帧间编码，需要算力比较小，所以比较适合嵌入式平台，缺点需要的网络带宽比较大，仅支持视频流。
安装mjpeg
pi@raspberrypi:~ $ sudo apt-get install cmake libjpeg8-dev pi@raspberrypi:~ $ git clone https://e.coding.net/fivecc/mjpg-streamer/mjpg-streamer.git pi@raspberrypi:~ $ cd mjpg-* pi@raspberrypi:~/mjpg-streamer-master $ cd mjpg-* pi@raspberrypi:~/mjpg-streamer-master/mjpg-streamer-experimental $ make pi@raspberrypi:~/mjpg-streamer-master/mjpg-streamer-experimental $ sudo make install pi@raspberrypi:~/mjpg-streamer-master/mjpg-streamer-experimental $ cd pi@raspberrypi:~ $ 一步一步执行即可。
2.启动mjpeg
命令框直接输入
pi@raspberrypi: ~ $ /usr/local/bin/mjpg_streamer -i "/usr/local/lib/mjpg-streamer/input_uvc.so -n -f 30 -r 1280x720" -o "/usr/local/lib/mjpg-streamer/output_http.so -p 8080 -w /usr/local/share/mjpg-streamer/www" 4.服务端搭建
如果只接收视频可以直接浏览器打开
http://&lt;树莓派ip&gt;:/javascript.html 本次人脸视频采用的是opencv-python,安装过程不在叙述，可以百度一下python和opencv-python版安装，
首先解析视频流，使用如下代码
url = "http://192.168.43.98:8080/?action=stream" rtmp_url= "rtmp://58.200.131.2:1935/livetv/hunantv" 上面的URL是使用mjpeg的网络视频流地址，使用时，把IP地址改成自己的地址，下面的RTMP地址本次亲测可以这样用，后面可以改成RTMP推流，
使用RTMP应该延时会更小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d34682d6ee2d74fa544a839d4c05b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97fa2e2944d0cb100b609e2f39fca497/" rel="bookmark">
			＜img＞ 的 title 和 alt 有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title 通常当鼠标滑动到元素上的时候显示alt 是 &lt;img&gt; 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d038953f25d39c6d952f5ff5252352e0/" rel="bookmark">
			谈谈中兴捧月大赛决赛以及总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 四月份，在师兄的推荐下，报名参加了中兴捧月大赛。一开始只是为了混一个面笔试的资格（因为提交有效成绩即可免笔试），然后为了找一个简单的赛道，注册了几个号看了两三个赛道的题目。发现自己每个都不熟悉，然后就选了一个看起来比较小众的赛道（图灵派，音视频编解码），可能竞争压力会小一点（报一点侥幸）。
初赛 初赛因为就是为了混免笔试，因此就调库（不调库也没办法，我也不会，也没时间天天搞这个，毕竟还有科研任务）。
具体的初赛内容可以看前几篇文章。
https://blog.csdn.net/qq_37207042/article/details/116209375
复赛 这个赛道的复赛好像特别简单（其他赛道好像还有题），复赛就是面试，郭老师远程面试我们，然后基本没有问技术层面的，就问了一下思路。然后做了一些自我介绍，其实我就是念了一下简历，另外问了一些项目经验之类的以及就业意向。因为毕竟不是本专业学这个的，技术深度还是不够，只能问一些浅层的思路。本以为复赛混个奖品就可以了，意外的是，公布决赛名单时候竟然找到了我的牛客ID。
决赛 听说决赛还有参与奖品，而且还包差旅食宿（还有这种好事，当然要去）。然后领我意外的是，中兴对待比赛还挺认真的，赛务组安排的都很好，吃住等生活事务都安排的明明白白。
第一天去先是入住，然后等晚上发布赛题，发布完赛题会住处就开始开发了。
第二天，第三天都是开发，第三天下午5点提交，提交完开始做PPT，第四天答辩，第四天下午终极答辩（前六名），晚上颁奖典礼。
开发开始比较累的，我每天差不多都搞到晚上1点，搞了两天。吃住都在中兴自己的酒店，酒店还行吧，吃饭就酒店自助。
赛题 扯了那么多，毕竟这是个技术博客，还是谈一谈技术。
决赛（图灵派）赛题 图灵派主要涉及的就是音视频编解码，涉及一些深度学习方法。
决赛题目是VR视频编码算法的问题
背景 在VR领域中，对于传输带宽要求极高，需要对于视频进行进一步的压缩，
以降低传输带宽的需求，给用户更好的使用体验，业内常用 tile 编码方案进行传输。
问题1：tile权重预测 根据相关研究表明，对于 360°视频，大约有超过 30%的内容未被参与测试的人观看。因此，通过 tile 编码，可以对于不重要内容进行低权重编码，对于观看频率较高的采用高权重编码。
上图展示了一个全景图像中，用户关注的重点位置和图像。
在 tile 编码时，根据 saliency 的预测权重结果进行西能优化，有线高质量编码更容易被观看的 tile，对不容易被观看的区域视权重情况进行低质量快速编码。 从而完成对编码服务器的性能优化，降低服务成本。 根据附件中所提供的 40 个参与用户对于 40 个视频的头动数据集，对于 tile 编码算法进行设计和训练。
评分标准 在测试的 8 个视频中（赛程过程不提供），对于视频数据进行 tile 编码，对于所预测的权重结果和实际的头动数据集进行相关性计算。最后输出一个 txt 文 本文件，输出分为两列，分别为各个 tile 的观看命中次数和该 tile 对应的权重， 示例如所给压缩包中的 txt 文件。运行压缩包中 pcc.py 计算相关性，获取最终的 相关性评分。同时，对于本问题的解题思路，输出相关文档进行阐述。
问题2：tile编码方案优化 对于单个 tile 的编码方案进行优化。 在第一题全景 tile 编码的基础上，相同的视频内容，不同的编码方案（q、s、t）对主观感知质量的影响较大。不同的视频内容呈现出的规律有一定的差异。 可参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d038953f25d39c6d952f5ff5252352e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03dada37899aad4b46d27a5d904cf6fa/" rel="bookmark">
			P问题、NP问题、NPC问题、NPH问题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P： Polynomial，是指能在多项式时间内解决的问题；（如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。）NP：Non-deterministic Polynomial，是指非确定性多项式问题。不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间复杂度内被验证的问题；NP-Complete（NPC）：NP完全问题。所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。NP-Hard（NPH）：NP难问题。所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)，可以理解为，NP-Hard是比所有NP问题都难的问题。 ==划重点==： P 问题， 可理解为：常数增长或线性增长问题，即随着数据规模的增大，算法消耗的时间会以常数或线性关系增长，但不会巨量增长。 NP问题， 可理解为：指数增长问题，即随着数据规模的增大，算法消耗的时间会增长得恐怖，也称“指数爆炸”。 时间复杂度：指当问题规模扩大后，对应程序运行时间的增长程度（而不是表示一个程序运行所花费的时间）。
多项式级时间复杂度：如 O ( 1 ) , O ( n ) , O ( l o g ( n ) ) , O ( n a ) O(1), O(n), O(log(n)), O(n^a) O(1),O(n),O(log(n)),O(na)等，因为规模 n n n出现在底数的位置。
要理解P问题、NP问题、NPC问题、NP-hard问题，需要先弄懂几个概念：
什么是多项式时间？什么是确定性算法？什么是非确定性算法？什么是规约/约化？ 文章目录 多项式时间（Polynomial time）确定性算法与非确定性算法确定性算法：非确定性算法：规约/约化 P类问题、NP类问题、NPC问题、NPH问题概念四者联系的图形化表示 一个经典的栗子P = NP?Reference 多项式时间（Polynomial time） 什么是时间复杂度？
时间复杂度并不是表示一个程序解决问题需要花费多少时间，而是指当程序所处理的问题规模扩大后，程序运行时间相应的增长幅度。 也就是说，对于某一个程序，其处理某一个特定数据的效率不能衡量该程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者是变慢了数万倍？
不管数据有多大，程序处理所花的时间不变，我们就说这个程序很好，具有 O ( 1 ) O(1) O(1)的时间复杂度，也称常数级复杂度； 若数据规模变得有多大，程序运行花费的时间也跟着变得有多长，比如找 n n n个数中的最大值，这个程序的时间复杂度就是 O ( n ) O(n) O(n)，为线性级复杂度； 而像冒泡排序、插入排序等，数据扩大2倍，而程序运行时间变慢4倍的，时间复杂度就是 O ( n 2 ) O(n^2) O(n2)，即平方级复杂度； 还有一些穷举类的算法，所需时间长度成几何阶数增长（即指数爆炸），这就是 O ( a n ) O(a^n) O(an)的指数级复杂度； 有的甚至是 O ( n !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03dada37899aad4b46d27a5d904cf6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965776237068a214d457ca112eb56343/" rel="bookmark">
			实用干货！正交试验设计及极差分析步骤总结！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、研究背景 当前有一项研究，研究大豆出油率分别与3个因素的关系情况，分别是萃取液，温度和处理时间。需要设计一个三因素三水平的正交试验表，并收集试验数据后进行分析，希望找出3个因素时各水平的最佳大豆出油率组合。
二、正交实验设计 进入SPSSAU系统，选择[实验/医学研究]--[正交实验]。
确定因子个数及水平数，点击[开始分析]。
得到正交表L9.3.4，总共进行9次试验。
三、数据收集 确定选用的正交表后，把表中各列因子下的数字“1”、“2”、“3”，分别换成各因子在试验中的水平值，并根据此表格安排试验方案。
下一步按照试验方案进行试验，将对应数据收集填入表中。
本案例数据如下表：表格中水平数量使用数字表示，比如因子2（温度）里面的数字1表示20度，数字2表示35度。
四、 数据分析 上传数据，对试验数据进行分析。
选择[实验/医学研究]--[极差分析]。
放置分析项操作如下：
SPSSAU输出结果如下：
极差分析可用于研究正交试验数据，包括因素间的优势或因素间具体水平的优劣。表格中各指标含义说明如下：
极差分析表格中可知：从3个因素来看，结合R值（因素极差值）的大小对比可知，因子2温度是最优因素，其次是因子1萃取液量，最后是因子3处理时间。因而3个因素的优劣排序为：因子2（温度）&gt;因子1（萃取液量）&gt;因子3（处理时间）。
具体结合各因子的最佳水平可知，因子1萃取液量时第2个水平即50时最优，因子2温度以第3个水平即50度最优，因子3处理时间以第3个水平即3.5小时最优。
综合上述分析可知：最优因子为温度。最优组合为“温度50度，萃取液量50，处理时间3.5小时”。
通过图形也可直观查看：
「更多内容登录SPSSAU官网了解」
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d1cae7afcc425fe3e61963ca2a2634/" rel="bookmark">
			删除list列表中的某一个元素的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载： https://www.cnblogs.com/blogsofmy/p/10955171.html
当我们在处理业务的时候，很多情况下数据都要进行一层层的过滤，最近需要给一个列表中去除不符合条件的元素，
于是参考着网上的方法自己写了几个方法
1 .Iterator 去除
Iterator&lt;AdmVipConfigs&gt; iterator = admVipConfigs.iterator(); while (iterator.hasNext()){ AdmVipConfigs next = iterator.next(); String vipName1 = next.getVipName(); if (vipName1.equals("铂金会员")){ iterator.remove(); } } 虽然也能去除 但是列表改造成 Iterator 类型的了 （还要转换 不喜欢 ）
这不太符合我的代码风格 先pass
又换了几种比较旧的转换方式 发现缺陷都不小（麻烦）
这时候不能再跟着旧思路走了 必须自己想个好方法了
这时候突然就想起了流 虽然用的不多 但是很喜欢这种风格
用流怎么处理这个问题呢
不用说肯定先Google
然后发现流确实能处理 而且更强大（好看）
2 stream 去除
admVipConfigs.stream().findFirst().map(vo -&gt; { if (vo.getVipName().equals("注册会员")){ admVipConfigs.remove(vo); } return vo; }); 没有改变我的list格式并且更简洁，看着还是比较满意的 但是流处理的时候remove的时候会再次遍历整个list来找出 这个元素，性能会有一定的损耗，这怎么能行，我肉眼能看到的 损耗都是垃圾代码（除非没时间改） 既然这样 我们只能给它加个索引了 3 stream + 索引 去除 IntStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d1cae7afcc425fe3e61963ca2a2634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ec1f7dffa3a64dfe919fcc401cd49a/" rel="bookmark">
			LNA（Low Noise Amplifier, 低噪声功率放大器）简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着无线通信事业的发展，行业对于射频前端方案的性能关注越来越多，LNA（Low Noise Amplifier, 低噪声功率放大器）作为Receiver的第一级有源模块，其对接收机系统的性能有着非常重要的影响。
Figure 1 LNA在射频系统中的位置
噪声的基本理论 LNA的性能和噪声的机理密切相关，其实主要是LNA内部的器件容易受到噪声影响。通信射频电路中通常的噪声来源主要分为以下几种：
1.1 热噪声
热噪声的引入通常是导体电荷布朗运动的结果，并且这种运动会随着温度的上升而加剧，电荷的随机运动引发了随机的电压。这种噪声过程是随机的，所以物理上通常用统计方法来描述热噪声，热噪声的均方噪声电压可以用下式来描述：
可以用等效戴维宁定理来对热噪声进行等效建模如下图所示，就是一个无噪声电阻上串联一个均方值为 [公式] 的噪声电压源：
由于导体中的电子数目巨大，其随机运动又是相互统计独立的，因此根据中心极限定理可知，热噪声是零均值的高斯分布。
1.2 散弹噪声（Shot Noise）
散弹噪声产生的根本原因是电子电荷具有粒子性。产生散弹噪声需要满足以下两个条件：
必须要有直流电流通过；
必须存在电荷载体跃过的电位壁垒，所以通常使用的线性电阻并不产生散弹噪声。
电荷呈离散束导致了每当电子跃过一个能量势垒时就会产生不连续的电流脉冲，正是由于电子到达时间的随机性所以造成了散弹噪声的全频带特性（白噪声特性）。散弹噪声的电流均方根可以表示为：
对存在电位壁垒的要求意味着散弹噪声只与非线性器件有关，但并不是所有非线性器件都会出现散弹噪声。在BJT中由于出现了两个PN结，所以基极电流和集电极电流都可能成为噪声来源，但是在FET中只有栅漏电流才会引起散弹噪声，但是这个电流非常小，所以它并不是一个显著的噪声源。
1.3 闪烁噪声
闪烁噪声又被称为1/f噪声，它虽然非常普遍，却没有一个普遍适用的机理，这种噪声的特点是噪声功率密度谱随频率的增加而减小，它的经验数学表达式为：
LNA相关参数 低噪声放大器（LNA）位于射频接收机的前端，是接收机的第一级有源电路。由级联系统的噪声可以知道，第一级电路的噪声系数会直接加到系统的总噪声系数上，所以LNA的噪声系数需要设计得尽可能低；同时为了提高接收机的接收灵敏度，LNA需要提高足够大的增益；另外，为了减少信号放大过程中的失真，LNA需要有良好的线性度；而且通常LNA和天线之间会有一个视频无源滤波器（通常为SAW或者BAW）进行滤波，该滤波器的性能对于它的负载阻抗非常敏感，所以为了得到良好的滤波特性，LNA的输入阻抗应该匹配到前级滤波器的输出阻抗，通常为50欧姆，如下图史密斯圆图Z0位置：
Figure 2 Smith Chart
2.1 噪声系数
噪声系数通常用于衡量一个电路和或者系统内部噪声大小，它通常用于比较不同电路或者系统噪声性能的好坏。噪声系数的定义如下：
由于放大器本身有噪声，输出端的信噪比和输入端信噪比是不一样的，为此，使用噪声系数来衡量放大器本身的噪声水平。该系数表征放大器的噪声性能恶化程度的一个参量，并不是越大越好，它的值越大，说明在传输过程中掺入的噪声也就越大，反映了器件或者信道特性的不理想。通常噪声系数和温度有关，温度越高，噪声系数越大。
2.2 增益
增益是低噪声放大器的一个重要指标，低噪声放大器若有较大的增益值不仅可以放大信号还能很好地抑制后级电路模块噪声，但是如果增益值过大，那么后级电路模块的线性度就要求很高，否则可能会出现信号饱和现象从而导致信号失真。单级的LNA典型增益通常在10~20dB之间。
2.3 输入输出匹配
在实际的射频系统中，低噪声放大器的前级一般是一个高性能的片外预选射频滤波器，它的输出端口与LNA是输入端口连接，为了实现最大功率传输，LNA的输入阻抗需要匹配到50Ω。如果LNA的输入阻抗偏离50Ω，阻抗不匹配，将会产生两个后果：
产生功率反射，这会影响到LNA接收到的信号的功率大小；
可能会恶化前级射频滤波器的性能，从而使得系统性能恶化；
2.4 线性度
学习过模电的小伙伴应该对晶体管的特性比较熟悉，放大电路的输出特性曲线会随着晶体管的静态设置点的变化而变化，这就是来源于晶体管这种器件的非线性性。我们都期待放大电路是理想线性的，即无论输入功率多大，输出功率都是线性增加的（增益是恒定不变的）。但是事实上，并没有理想线性的放大器，也就是随着输入功率的增大，输入功率可能不会随着线性增大。
如下图，当输入功率较低时，此时的增益接近于线性增益。随着输入功率的不断增大，输出功率近似线性增加，增大到一定程度，非线性越来越明显，导致增益压缩，输出功率增长速度放缓，最后逐步趋于饱和稳定，输入、输出功率之间的关系如下图所示：
Figure 3 放大器的输入输出功率特性曲线
首先需要明确的是，这是输入、输出功率的对数表示，因此理想线性放大器的曲线斜率为1，如图中虚线所示。实线表征的是放大器实际输入、输出功率之间的关系，随着输入功率的增大，输出功率增大得速度变慢，越来越偏离理想的曲线，增益逐步变低，这就是增益压缩效应。
放大器等有源器件通常关注实际增益比线性增益跌落1dB的位置，称之为1dB增益压缩点，该点对应的输入、输出功率一般分别标记为P1dB,in 和P1dB,out 。
1dB增益压缩点越高越好，两个放大器相比较，谁的压缩点越高，意味着谁的线性度越好。无线通信系统中，信号通常都具有一定的带宽，如果总功率接近于1dB压缩点，则放大器非线性越趋于明显，就会产生比较强的谐波、交调产物，从而对邻带或带内造成干扰。因此，非线性失真是放大器设计中一个非常重要的考量因素。所以Pi（1dB）点是衡量线性度很重要的一个参数。
除此之外，TOI（Third-order Intercept）/IP3点也是衡量线性度的一个重要参数。它主要表征的是器件谐波和互调信号对于线性度的影响。
2.5 反向隔离度
反向隔离度表征LNA输入端口和输出端口之间的反向隔离性能，在数值上定义为信号从输出端口到达输入端口的衰减值，一般用S参数中的S12来表示。信号从输出端口到输入端口的衰减值越大，表明它的单向性能越好，反向隔离度越好。良好的隔离度可以有效地抑制从混频器通过低噪声放大器泄露到天线的本振信号，防止较大的本振信号从天线辐射到空间，形成其他通信系统的干扰信号。另外，良好的隔离度还可以降低电路设计难度，使LNA的设计近似为单向化设计，设计输入匹配电路时不用考虑输出匹配电路对它的影响，设计输出匹配电路时亦然。LNA的反向隔离度受密勒效应和寄生电容的影响较大，一般采用cascode结构来提高它的反向隔离性能。
LNA实例 下面以NXP公司的BGS8H2（2300MHz~2690MHz）这款LNA为例讲解一下LNA的规格。这是一款适用于LTE高频频段的LNA，通常为了防止信号过大导致信号后级电路饱和失真，LNA会有两种模式：增益模式（Gain Mode）/旁路模式（Bypass Mode）。下图是它的模块框图：
可以看出LNA有一个CTRL_Pin，该Pin可以通过SOC或者RFIC控制LNA的模式。以下是该LNA的基本技术指标，这个就像是一个产品的包装，一开始给选型厂家一个基本印象：
LNA的规格书中还会给出该器件在不同的情况下的参数：
以及推荐的匹配和推荐的工作条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ec1f7dffa3a64dfe919fcc401cd49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad181219f4a7dca1c05f163ad8973f99/" rel="bookmark">
			【问题解决】AMD驱动安装出现182错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 AMD驱动安装时出现提示：错误182 - Radeon Software 安装在系统配置中检测到不受此软件安装支持的AMD图形硬件
问题解决 卸载当前驱动（控制面板 -&gt; 卸载程序 -&gt; 选择AMD Software右键卸载）重启电脑根据显卡型号下载并安装最新推荐驱动（官网驱动网址） 备注 如果仍无法安装，可以按照以下步骤操作
查看AMD历史驱动
搜索驱动（可以直接搜你想要的驱动版本安装）
进入具体驱动版本介绍页，点击Official Website查看官网介绍
若驱动包含你的显卡型号即可安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d8cd5834c21f610aa1120e49f06edf/" rel="bookmark">
			Java课程设计——家庭理财管理系统(SpringMVC&#43;Mybatis&#43;LayUI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java课程设计——家庭理财管理系统SpringMVC+Mybatis+LayUI 1 前言2 需求与功能分析3 概要设计4 数据库设计4.1 E-R图4.2 数据库的模型图4.3 各表的SQL脚本 5 系统各模块实现5.1 登录模块5.2 数据展示模块5.3 后台信息管理模块5.4 关键技术的实现 6 不足 1 前言 为了更方便地记录家庭成员之间的消费支出和收入，做一个家庭财务管理系统，对各家庭成员每天的消费做一个记录和统计，做成一个数据面板，以便更好的了解和展示家庭消费情况。
环境：Tmocat9.0+SpringMVC+Mabitas+Java
编程思路：Java+WebServlet的一个简单思路（相当于用SpringMVC来写Servlet）
2 需求与功能分析 1.实现家庭成员信息的实时更新和管理
2.实现家庭成员和消费记录的增删查改
3.实现家庭总的收入和支出状况的展示
3 概要设计 ​
图1 系统功能图
4 数据库设计 4.1 E-R图 图2 E-R图
4.2 数据库的模型图 图3 表模型图
4.3 各表的SQL脚本 图4 Record表
图5 User表
图6 Admin表
5 系统各模块实现 5.1 登录模块 （未完善实现，仅在前段做出简单处理）
图7 登录界面
模块关键代码：
// 进行登录操作 form.on('submit(login)', function (data) { ​ data = data.field; ​ if (data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d8cd5834c21f610aa1120e49f06edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7650a5f423f23e4bf8b6c1341908c1/" rel="bookmark">
			图像处理计算两个文件夹中对应图片的PSNR/SSIM，计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用matlbe实现
**
计算多张图片，两个文件夹中对应图片的PSNR/SSIM **
计算两个文件夹中对应图片的PSNR/SSIM import os
import numpy as np
import math
from PIL import Image
import time
当中是你的程序 def psnr(img1, img2):
mse = np.mean((img1 / 1. - img2 / 1.) ** 2)
if mse &lt; 1.0e-10:
return 100 * 1.0
return 10 * math.log10(255.0 * 255.0 / mse)
def mse(img1, img2):
mse = np.mean((img1 / 1. - img2 / 1.) ** 2)
return mse
def ssim(y_true, y_pred):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae7650a5f423f23e4bf8b6c1341908c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a786d14e3b5908a5eeef6d6896b09bd9/" rel="bookmark">
			【鸿蒙】HarMonyOS的UI组件学习七之图片轮播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片轮播功能也是我们在很多应用中常见的一种效果，今天分享鸿蒙系统中展示图片轮播功能。
在鸿蒙系统中，实现轮播效果，主要使用PageSlider组件
接下来创建主布局，代码如下:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;DirectionalLayout xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:height="match_parent" ohos:width="match_parent" ohos:orientation="vertical"&gt; &lt;PageSlider ohos:id="$+id:ps" ohos:height="200fp" ohos:orientation="horizontal" ohos:width="match_parent"/&gt; &lt;/DirectionalLayout&gt; ohos:orientation="horizontal"设置轮播滑动方向为横向
private int[] images = { ResourceTable.Media_jinriteyue, ResourceTable.Media_ydqbannerbeihai, ResourceTable.Media_ydqbannershouti, ResourceTable.Media_i_back, ResourceTable.Media_spic}; private String[] names={ "第一张图", "第二张图", "第三张图", "第四张图", "第五张图" }; 添加五张图片，定义其图片的引用id数组和每张图片对应的文字信息数组
定义实体类，将图片和文字封装成实体类
package com.example.hm_phone_java.entity; public class Page { private int image; private String name; public int getImage() { return image; } public void setImage(int image) { this.image = image; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a786d14e3b5908a5eeef6d6896b09bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208093acbf4869e2c81ea25c093bcc9c/" rel="bookmark">
			vue 字符串换行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //style必须有 &lt;el-form-item :label="br2" prop="brhqbz" style="white-space: pre-wrap;"&gt; &lt;/el-form-item&gt; export default { name: "DynamicForm", data() { return { br2:"123\n456" // 换行符\n也必须有 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3d3cf7e0ae4f6ae7930fbf7b092dac/" rel="bookmark">
			在华为云上部署WordPress I
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在华为云上部署WordPress I 修改时间：2021.03.17 13:28
使用环境：华为云ECS 1vCPUs|1GB|40G|1Mbps|CentOS 8.0 64bit with ARM
设置安全组规则 设置入方向，协议HTTP(80)，80端口，源地址0.0.0.0/0
部署LNMP 使用一键安装包，执行wget http://soft.vpser.net/lnmp/lnmp1.7.tar.gz -cO lnmp1.7.tar.gz &amp;&amp; tar zxf lnmp1.7.tar.gz &amp;&amp; cd lnmp1.7 &amp;&amp; ./install.sh lnmp开始自动安装，大约需要15分钟
安装过程中选择MySQL5.5，开启MySQL InnoDB，选择PHP7.3，不安装内存优化
配置MySQL 执行sudo mysql -u root -p，直接回车进入，第一次无需输入密码
执行如下命令，注意每条命令后的分号
输入CREATE DATABASE wordpress;创建名为wordpress的数据库
输入GRANT ALL ON wordpress.* TO wordpressuser@localhost IDENTIFIED BY 'BLOck@123';为数据库创建用户并为用户分配数据库的完全访问权限，其中wordpressuser为用户名，BLOck@123为密码
输入exit;退出MySQL
配置PHP 执行如下命令启动PHP服务并设置开机自启动
systemctl start php-fpm systemctl enable php-fpm 配置Nginx 执行vim /usr/local/nginx/conf/nginx.conf编辑Nginx配置文件，按i进入编辑模式
在server下添加下列代码
location / { root /usr/local/nginx/html; index index.php index.html index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef3d3cf7e0ae4f6ae7930fbf7b092dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f96f3feb713e8a4a7d5de0bd539554f/" rel="bookmark">
			如何启用计算机端口,Win7系统下开启计算机端口的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机端口是计算机与外界通讯交流的出口，有时候由于操作的失误会把计算机的端口关闭，这时候就需要用户手动去开启。在Win7系统下，用户该如何开启端口呢？下面小编为大家介绍两种比较实用的方法。
Win7系统下开启计算机端口的方法
方法一：服务开启计算机端口
1.点击“开始”，在开始搜索框中输入“服务”，按下键盘上的回车键。
2.在服务窗口中找到对应要开启的端口对应的服务，双击打开。
3.在“启动类型”选择“自动”，在“服务状态”中单击“启动”按钮即可启用该端口，最后，单击“确定”按钮即可。
方法二：TCP/IP协议属性开启计算机端口
点击“开始”→“控制面板”→“网络和Internet”→“查看网络状态和任务”→“本地连接”→点击“属性”→选择“TCP/IPv4协议”→点击“属性”→点击“高级”，在选项的那个页面打开TCP/IP筛选，在出现的设置窗口中也可以根据实现情况设置端口的打开和关闭，默认是未启用TCP/IP筛选。
通过以上方法，用户就可以在Win7系统开启计算机端口了，如果不确定到底开启了哪些端口，可以通过批处理文件查看端口的开启情况，确保安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a447132275110c437aafd8bcd9715f7/" rel="bookmark">
			element使用table样式混乱问题解决方案(doLayout)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用element-ui的table表格时，有时候数据请求回来渲染完会出现以下情况。
理论上在数据请求回来重新渲染一下表格就可以了，正好element文档也提供了这个方法。
实际操作如下，在请求数据接口调用成功后,在$nextTick里执行一下该方法就可以了。
&lt;el-table ref='table'&gt; &lt;/el-table&gt; axios.post('...') .then(function (response) { this.$nextTick(() =&gt; { this.$refs.table.doLayout() }) }) 屡试不爽~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca39c970797d8e0c0896b37e969c9b2/" rel="bookmark">
			服务器数据json传多了，如何截取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 服务器数据传多了，以，为标志进行截取
public PictureCourseWare(String picture, String tag, int nowPage, int allPage) { int index = picture.indexOf(","); if (index &lt; 0) index = 0; Log.e("wy","jpg (,) index =: "+ index); Picture = picture.substring(index); Tag = tag; this.nowPage = nowPage; this.allPage = allPage; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b13531a2c6ccc590e6c40a8f387685d/" rel="bookmark">
			Ubuntu 18.04环境下使用Eclipse和ST-Link搭建STM32开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期：2021年6月28日
建议：如果此文章超过半年，尽量选择我列出的官方网站查看教程。
备注：本电脑换了软件源，使用中科大的软件源
参考站点 1.ST-Link的github地址：https://github.com/stlink-org/stlink
2.ST-Link的安装教程(英文)：https://github.com/stlink-org/stlink/blob/develop/doc/compiling.md
3.Eclipse下载地址(c/c++)：https://www.eclipse.org/downloads/packages/release/helios/sr2/eclipse-ide-cc-developers
4.Eclipse官方安装教程（英文）：https://eclipse-embed-cdt.github.io/plugins/install/
5.gcc-arm-none-eabi交叉编译工具链：https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads
6.gcc-arm-none-eabi官方安装教程(英文)：https://xpack.github.io/arm-none-eabi-gcc/install/#:~:text=The%20easiest%20way%20to%20install%20GNU%20Arm%20Embedded,xPack%2C%20available%20as%20%40xpack-dev-tools%2Farm-none-eabi-gcc%20from%20the%20npmjs.com%20registry.
1.安装Eclipse --1-- 安装java运行环境
$:sudo apt-get install openjdk-6-jre-headless 或者 $:sudo apt-get install default-jdk 备注：这里安装的是开源版本，6是版本号，因为eclipse是基于java环境的，所以需要装它
--2--使用安装包安装eclipse：
----下载：去上面的地址下载：https://www.eclipse.org/downloads/packages/release/helios/sr2/eclipse-ide-cc-developers
备注：请留意版本信息，ubuntu上人软件更新并没有那么方便
----或者使用百度网盘
链接: https://pan.baidu.com/s/119Pya-dR7dRDo0O3K14VDA 提取码: wfj9
文件名：eclipse-cpp.tar.xz
----转到刚才下载的目录，包名为eclipse-cpp.tar.xz
高级的技巧就不用了，没有必要，鼠标右键解压到此处，解压后得到得到eclipse-cpp文件夹，里面的eclipse文件夹下的eclipse就是启动文件
--4--在当前目录下右键在终端打开，命令行输入：
$: sudo ./eclipse 不出意外应该可以看到eclipse的IDE启动，先不管他，关掉，记住刚才启动文件的位置
添加路径，以实现在终端直接打开eclipse
1.编辑.bashrc文件 $:gedit ~/.bashrc 2.在打开的文件中添加一行，路径这里填写刚才解压缩文件中可执行文件的路径 export PATH=/usr/.../eclipse-cpp/eclipse 3.更新 $:source ~/.bashrc 备注：使用sudo启动可以避免后面路径问题，可以理解为windows下的绿色版本
2.安装交叉编译工具链 --1--使用apt命令安装
$:sudo apt-get install gcc-arm-none-eabi 3.安装St-Link --1--安装相关依赖包
$:sudo apt-get install libusb-1.0 $:sudo apt-get install pkg-config $:sudo apt-get install git $:sudo apt-get install cmake $:sudo apt-get install libgtk-3-dev --2--下载源代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b13531a2c6ccc590e6c40a8f387685d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e759c8ac74409b49b14b58456d967c/" rel="bookmark">
			npm ERR! missing script:build报错说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack-bundle-analyzer webpack可视化插件，用来查看一共打了多少个包，每个包的体积和包里面的情况。
/**启动查看/ npm run build --report 结果报错npm ERR! missing script: build，后来发现package.json中scripts参数为
正确：
npm run build:test --report /*npm 允许在package.json文件里面，使用scripts字段定义脚本命令。*/ 访问地址：http://localhost:8888/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8cff2209d57136071982a5de58d74a/" rel="bookmark">
			ffmpeg使用教程（二）常用ffmpeg命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg常用命令：
文档地址：http://www.ffmpeg.org/ffmpeg.html#Options
查看视频信息： ffmpeg -i 2.mp4 2. 转换视频格式：
ffmpeg -i 2.mp4 2_1.avi 3. 提取视频里的音频：
fmpeg -i 2.mp4 -acodec copy -vn 2_2.mp3 4. 提取纯视频文件：
ffmpeg -i 2.mp4 -vcodec copy -an 2_3.mp4 5. 视频剪切：
// 如果我们想从视频里剪切某一片段，例：从时间为00:00:02开始，截取1分钟的视频。 /** -ss设置从视频的哪个时间点开始截取 -t表示截取多长的时间 -vcodec copy表示使用跟原视频一样的视频编解码器。 -acodec copy表示使用跟原视频一样的音频编解码器。 -i 表示源视频文件 -to 截到视频的哪个时间点结束 -y 表示如果输出文件已存在则覆盖。 **/ ffmpeg -i 2.mp4 -vcodec copy -acodec copy -ss 00:00:02 -t 00:01:00 2_4.mp4 -y 6. 压缩视频：
/** -s 360x640表示修改分辨率为360x640(ffmpeg -i 2.mp4 -s 360x640 2_5_1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8cff2209d57136071982a5de58d74a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f7d3fa5bc5f2af6c8628c6e14b13dc/" rel="bookmark">
			ffmpeg使用教程（一）Windows安装配置ffmpeg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、官网下载ffmpeg：http://ffmpeg.org/download.html
https://github.com/BtbN/FFmpeg-Builds/releases
2、解压文件，将bin目录配置到环境变量中
D:\phpstudy_pro\WWW\ffmpeg-N-102790-g947122f111-win64-gpl\bin
3、查看配置是否成功
调用命令行（windows+R输入cmd）输入“ffmpeg –version”，如果出现如下说明配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c93e1b2f5973b62b7735f79b2904293/" rel="bookmark">
			苹果手机咋用计算机,苹果手机怎么通过usb连接电脑上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们会遇到电脑没有网络的情况，但是又要使用电脑上网，那么应该怎么办呢?不用担心有手机就可以了，可以手机通过usb连接电脑上网，那么苹果手机通过usb连接电脑上网呢?有的朋友想知道操作方法，所以下面我们将介绍苹果手机通过usb连接电脑上网方法。
苹果手机怎么通过usb连接电脑上网?具体的方法如下：
1、点击设置——蜂窝移动网络——打开蜂窝移动网络。
2、进入设置——个人热点——打开“个人热点”弹出对话框，选择“仅USB”。
3、选择"打开网络和共享中心"。
4、选择“更改适配器设置”。
5、点击进入更改适配器设置后，显示“本地连接 2”，iphone成功连接电脑。
6、右键点击“宽带连接”——选择“属性”。
7、选择“共享”，勾选“允许其他……连接”，选择“本地连接 2”。
8、选择“设置”。
9、勾选如图，点击确定。
10、设备上显示“个人热点： 1个连接”，即可上网。
以上就是小编带来的苹果手机怎么通过usb连接电脑上网的全部内容，希望可以提供帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4351764557954460518a22c027586d4/" rel="bookmark">
			计算机桌面显示左右有黑边,电脑两边黑边怎么还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Q7：电脑屏幕两边出黑边怎么把它调成全屏
步骤如下：
1、在桌面右击选择“屏幕分辨率”，可通过设置屏幕分辨率解决，14”“最佳分辨率一般为1366*768,19“最佳分辨率一般为1400*900,20”最佳分辨率1600*900........若果不知道屏幕的最佳分辨率可采用推荐分辨率，如下图。
2、如果不变更屏幕分辨率，想以常用的1024*768分辨率铺满屏幕，需要通过设置显卡属性来解决问题。点击“高级设置”，进入显示器设置。
3、在弹出的窗口选择“因特尔图形和媒体控制器”栏目，定位到“缩放”栏目。
4、在“缩放”栏目一般默认选择为“保持纵横比”，下拉缩放栏目，选择为“缩放全屏”即可铺满整个屏幕。
扩展资料：
使用电脑时对电脑的保护方法：
1、自动链接到一些陌生的网站。上网时要注意，不懂的东西不要乱点，尤其是一些色情类的图片，广告漂浮在浏览器页面当中的，不要点击它；如果它影响你浏览网页，就上下拖动滑动条，直到最佳视角为止。
另外，一些上网插件尽量不要装。还有不要安装上网助手及其工具栏，这类软件有时会影响浏览器的正常使用。
2、不要随便下载和安装互联网上的一些小的软件或者程序。
3、陌生人发来的电子函件。收到陌生人发来的电子函件，尤其是那些标题很具诱惑力，比如一则笑话，或者一封情书等，又带有附件的电子函件。
4、使用U盘前先进行查杀病毒操作，定期用防病毒软件检测系统有没有病毒。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f28cb6ffd694a8b9f8affafbf49216/" rel="bookmark">
			图神经网络学习4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点的预测任务 首先定义图神经网络的网络结构，这里使用了torch_geometric.nn.Sequential容器，详细内容可见于官方文档。我们通过hidden_channels_list参数来设置每一层GATConv的outchannel，通过修改hidden_channels_list，我们就可构造出不同的图神经网络。这里通过了三种方式改变网络结构
1、使用不同的卷积层2、使用不同的层数3、每层的不同的神经元个数 1、通过不同的卷积层
这里使用了GCNConv、GATConv、SAGEConv、GraphConv和TransformerConv五种卷积核，运行效果如下：
# 先定义数据 from torch_geometric.datasets import Planetoid from torch_geometric.transforms import NormalizeFeatures dataset = Planetoid(root='dataset', name='Cora', transform=NormalizeFeatures()) print() print(f'Dataset: {dataset}:') print('======================') print(f'Number of graphs: {len(dataset)}') print(f'Number of features: {dataset.num_features}') print(f'Number of classes: {dataset.num_classes}') data = dataset[0] # Get the first graph object. print() print(data) print('======================') # Gather some statistics about the graph. print(f'Number of nodes: {data.num_nodes}') print(f'Number of edges: {data.num_edges}') print(f'Average node degree: {data.num_edges / data.num_nodes:.2f}') print(f'Number of training nodes: {data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14f28cb6ffd694a8b9f8affafbf49216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b465b93103c0862fb15304adf5a645/" rel="bookmark">
			Linux 下解压.tgz文件报错gzip: stdin: invalid compressed data--format violated的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 执行 tar -zxvf xxxx.tgz 命令时，
提示以下信息：
gzip: stdin: invalid compressed data–format violated
tar： Child returned status 1
tar： Error is not recoverable： exiting now
方法一
原因：该压缩包没有用gzip格式压缩，所以不用加z指令解决方法：使用 tar -xvf xxxx.tgz 命令（即去掉z参数） 方法二
把下载下来的文件重命名为tar后缀，mv xx.tgz xx.tar再执行解压命令：tar -zxvf xx.tar 方法三
在wget后加上
--no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" 例如：
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" "http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz" 或
wget --no-check-certificate --no-cookies --header "Cookie: oraclelicense=accept-securebackup-cookie" -c -O 数据集名字 "对应的网页下载链接" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494e29e548a5ea6d73ca0e563a1f9f64/" rel="bookmark">
			鸿蒙开发（14）---ListContainer列表组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ListContainer列表组件基本用法创建ListContainer组件创建数据实体类定义适配器将数据添加到ListContainer组件 横向ListContainer ListContainer列表组件 在实际的App开发中，我们最最最常用的其实就是列表组件。在Android中，它是ListView与recyclerview。在鸿蒙中，它是ListContainer。
下面，我们将详细介绍ListContainer组件的使用方式。
基本用法 在我们创建使用ListContainer组件时，我们一般通过4个步骤进行创建。
创建ListContainer组件 首先，我们需要在XML布局文件定义一个ListContainer组件。示例如下：
&lt;ListContainer ohos:id="$+id:test_listcontainer" ohos:height="match_content" ohos:width="match_parent" ohos:layout_alignment="center"/&gt; 创建数据实体类 第2步，我们需要创建一个实体类模型，用于定义需要使用的列表数据。比如我们资讯类App的实体类有标题，简介，图片等。都可以通过实体类进行定义。
示例如下：
public class MyNews { private String title; private String desc; public MyNews(String title,String desc) { this.title = title; this.desc=desc; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } 这里图片就先省略，只使用标题与描述两个变量。至于图片的获取，我们将在鸿蒙的网络编程章节详细讲解，这里展示跳过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/494e29e548a5ea6d73ca0e563a1f9f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc25705a2089d093818d8f4d84bc909f/" rel="bookmark">
			ArcGIS|核密度分析详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开工具箱–空间分析工具–核密度分析（中英文自行对照）
输入要分析的要素，cell size越小，得到的图越丝滑~
如果此时选择ok结束的话，会得到一个矩形（默认为能包含所分析要素的最小矩形）。
为避免这种情况，点击【环境设置】，点击processing extent，选择你想要设置成的边界；然后点击raster analysis，将mask设置成你想要的边界，点击ok。
成图展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/820b72bc7d408f689d82905efca1f086/" rel="bookmark">
			您没有足够的权限为该计算机所有用户,您有一台运行Windows7的计算机。该计算机是域的一个成员。您将D:\data共享为“数据”。您将Everyone“完全控制”共享权限分配给该文件夹。没有将其他共...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YouneedtodesignamigrationstrategytomigratetheExchangeServer5.5mailboxes.Whatshouldyoudo?()
A.Createandconfigureaone-wayrecipientconnectionagreementfromActiveDirectorytoExchangeServer5.5
B.CreateandconfigureaconfigurationconnectionagreementbetweenExchangeServer5.5andActiveDirectory
C.Createandconfigureaninter-organizationalrecipientconnectionagreementfromExchangeServer5.5toActiveDirectory
D.Createandconfigureatwo-wayrecipientconnectionagreementbetweenExchangeServer5.5toActiveDirectory
E.UseMicrosoftIdentityIntegrationServer(MIIS)tosynchronizeobjectsbetweenExchangeServer5.5andActiveDirectory
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cad76b048763326b34bbd118359965/" rel="bookmark">
			您没有足够的权限为该计算机所有用户,没有足够的权限卸载请与系统管理员联系怎么解决...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用控制面板卸载软件时，提示没有足够的权限卸载请与系统管理员联系的问题，相信很用户也遇到过这种情况，那么没有足够的权限卸载，请与系统管理员联系要怎么解决呢，下面小编给大家分享没有足够的权限卸载请与系统管理员联系的解决方法。
解决方法：
1、首先在计算机桌面上找到软件的快捷方式，然后右击该快捷方式，弹出右击下拉子菜单，在菜单中找到“属性”。
2、点击“属性”，弹出软件快捷方式的属性窗口页面，在页面上可以看到“打开文件位置”。
3、点击“打卡文件位置”，弹出软件的安装目录，在目录中可以找到“Uninst.exe或者Uninstall.exe”。
4、右击“Uninst.exe”,弹出右击的下拉子菜单，在子菜单中可以找到“以管理员身份运行”。
5、点击“以管理员身份运行”，即可弹出卸载向导页面，只需根据向导，一步步的卸载即可。
6、如果桌面上没有软件的快捷方式，可以通过点击计算机左下角的开始，弹出开始的下拉子菜单，在子菜单中可以看到“所有程序”。
7、然后点击“所有程序”，弹出计算机中所用程序的页面，在页面上可以找到要卸载的软件，然后同样进入到软件的安装位置，以管理员身份运行卸载程序，即可解决没有足够的权限卸载软件请与系统管理员联系。
以上就是没有足够的权限卸载请与系统管理员联系的解决方法，要是跟小编遇到的情况一样的话，可以按上面的方法来进行解决。
我要分享到：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e1d99cf3954ca0e75120eea719eb5b/" rel="bookmark">
			【鸿蒙】HarMonyOS的UI组件学习六之订单列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在所有移动互联端的应用软件中，都少不了列表的展示，例如手机通讯录，QQ好友列表，微信好友列表，朋友圈列表，微博列表，邮箱里的邮件列表，王者荣耀的游戏好友列表等等，那在鸿蒙系统中使用什么组件可以展示列表信息，就是它了ListContainer，想要展示出各种不同样子的列表信息页面，那么需要我们自己搭建子布局框架。
今天就分享一下鸿蒙开发中使用列表组件，先看效果图吧!
滑动屏幕可以进行上下滚动列表
并设置回弹效果，类似于微信朋友圈的向下拖动进行回弹
松手后会自动回弹。
那么接下来上代码，先看主布局代码:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;DirectionalLayout xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:height="match_parent" ohos:width="match_parent" ohos:orientation="vertical"&gt; &lt;Text ohos:height="match_content" ohos:width="match_parent" ohos:text="预定记录" ohos:text_size="25vp" ohos:text_alignment="center" ohos:background_element="#FF4141F3" ohos:text_color="#fff" ohos:padding="5vp" /&gt; &lt;ListContainer ohos:background_element="#FFEEECEC" ohos:id="$+id:lc_order" ohos:height="match_parent" ohos:width="match_parent" ohos:rebound_effect="true"/&gt; &lt;/DirectionalLayout&gt; 主布局中整个屏幕其实就分为两部分，一个是标题栏，剩下的都是列表的部分，通过ohos:rebound_effect="true"这个属性设置列表回弹功能
接下来创建子布局文件，其实整个列表的展示我们可以理解为是由多个子布局拼在一起形成列表，我们再来仔细研究一下列表中每一项的框架结构
很明显，每一行都是这种结构，左边一张图片，中间显示文字信息，右边一个箭头，所以我们只要把子布局的框架结构设计出来再通过java代码循环创建就可以了，思路上可以这样理解，那么接下来上子布局的代码
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;DirectionalLayout xmlns:ohos="http://schemas.huawei.com/res/ohos" ohos:height="match_content" ohos:width="match_parent" ohos:alignment="center" ohos:top_margin="1fp" ohos:bottom_margin="1fp" ohos:padding="5fp" ohos:background_element="#fff" ohos:orientation="horizontal"&gt; &lt;Image ohos:id="$+id:image_order" ohos:height="70fp" ohos:width="70fp" ohos:right_margin="10vp" ohos:image_src="$media:lanqiu_small" ohos:scale_mode="stretch"/&gt; &lt;DirectionalLayout ohos:height="match_content" ohos:width="match_parent" ohos:weight="1" ohos:orientation="vertical"&gt; &lt;DirectionalLayout ohos:height="match_content" ohos:width="match_parent" ohos:orientation="horizontal"&gt; &lt;Text ohos:id="$+id:tv_name" ohos:height="match_content" ohos:width="match_content" ohos:weight="1" ohos:text_alignment="left" ohos:text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11e1d99cf3954ca0e75120eea719eb5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9185f9ccc134e09fb9f9158c2e7c93/" rel="bookmark">
			面试官：说说对 State 和 Props的理解，有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、state 一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是state，一般在 constructor 中初始化
当需要修改里面的值的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用，并且重新调用组件render方法，如下面的例子：
class Button extends React.Component { constructor() { super(); this.state = { count: 0, }; } updateCount() { this.setState((prevState, props) =&gt; { return { count: prevState.count + 1 } }); } render() { return (&lt;button onClick={() =&gt; this.updateCount()} &gt; Clicked {this.state.count} times &lt;/button&gt;); } } setState还可以接受第二个参数，它是一个函数，会在setState调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成
this.setState({ name:'JS每日一题' },()=&gt;console.log('setState finished')) 二、props React的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件
组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是props，所以可以把props理解为从外部传入组件内部的数据
react具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据
props除了可以传字符串，数字，还可以传递对象，数组甚至是回调函数，如下：
class Welcome extends React.Component { render() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; } } const element = &lt;Welcome name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9185f9ccc134e09fb9f9158c2e7c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dc84ccda8bcf1ae35d2be241ff12ca/" rel="bookmark">
			配置高档游戏型计算机,2021年游戏台式电脑配置推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组装电脑就是diy电脑，可以满足我们的个性化需求。不过组装过程中往往需要了解各配置搭配是否合理。有小伙伴就想了解2021年游戏台式电脑配置哪些比较好。那小编就给大家推荐几款2021年游戏台式电脑配置。
1、入门游戏主机配置：
这两款价格估值都是3K左右。配置定位于入门游戏玩家，可以保证绝大多数游戏在高特效下流畅运行，主要针对腾讯类游戏，比如LOL,CF,DNF，以及魔兽世界之类不是很吃硬件的网游，绝地求生这样的大型游戏也能在中特效下流畅运行。 这两款cpu都是四核心，虽然R5-1500X的单线程性能稍弱，不过却有超线程技术的加持，在面对一些轻度的生产力需求时表现会更好一些。如果是纯粹游戏党的话，建议用i3-9100f的那款配置。
2、主流游戏主机配置
这两款估值4K左右，配置主要是在前边配置的基础上提升了cpu和显卡。虽然现在很多游戏用4核心的cpu就可以，不过面对一些大型3A游戏还是会有点力不从心，随着游戏不断更新迭代，以后对于cpu的要求也会越来越高，如果你想一台电脑能多玩上几年的话，那么就很有必要考虑6核心的处理器了。 这两款配置的cpu都是6核6线程，搭配GTX1660 SUPER显卡，在1080p分辨率下可以满足绝大多数游戏的需求。
3、中高端游戏主机配置
这两款估值10K左右，配置的cpu核心都上升到了8核，显卡也提升到了中高端型号，一方面可以轻松面对大型3A游戏，另外更多的核心数量在游戏直播以及生产力需求等方面也有更佳的表现。 这两款配置只要你不是追求极致4K分辨率的话，几乎是什么游戏都来者不拒。
以上便是小编给大家推荐的2021年游戏台式电脑配置，大家有需要的话可以参考下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d2b38305b837ce01ca96e657b09b814/" rel="bookmark">
			Access to XMLHttpRequest at ‘http://localhost:8080/VXApplets/UserInfoService/login‘ from origin ‘htt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 Access to XMLHttpRequest at 'http://localhost:8080/VXApplets/UserInfoService/login' from origin 'http://localhost:8082' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. 报错原因 在使用vue-axios进行跨域访问时,访问的相应结果被浏览器拦截,认为这是一个不安全的访问
解决方法 可以从两方面来解决这个问题
前端使用代理进行处理
在vue.config.js中加入如下内容
module.exports = { outputDir: 'dist', //build输出目录 assetsDir: 'assets', //静态资源目录（js, css, img） lintOnSave: false, //是否开启eslint devServer: { open: false, //是否自动弹出浏览器页面 host: "localhost", port: '8082', // https: false, //是否使用https协议 // hotOnly: true, //是否开启热更新 proxy: { '/api': { target: 'http://localhost:8080/VXApplets/', //API服务器的地址 // target: 'https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d2b38305b837ce01ca96e657b09b814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/050456c35fe4d60fcd33256961dc78d5/" rel="bookmark">
			cgo的几种使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的CGO程序 //cgo.go package main import "C" func main(){ println("hello cgo") } 上述代码是一个完整的CGO程序，通过import "C"语句启动了CGO特性，go build命令会在编译和链接阶段启动gcc编译器
源码方式调用C函数 cgoTest.h
void SayHello(const char* s); cgoTest.c
#include &lt;stdio.h&gt; #include "cgoTest.h" void SayHello(const char* s) { puts(s); } main.go
package main /* #include &lt;cgoTest.h&gt; */ import "C" func main(){ C.SayHello(C.CString("Hello world\n")) } 上述.c文件也可以是.cpp文件，前提是编译时需要g++
cgoTest.cpp
#include &lt;iostream&gt; extern "C" { #include "cgo01.h" } void SayHello(const char* s) { std::cout &lt;&lt; s; } 上述.c和.cpp的不同实现都实现了SayHello函数，说明解放了函数的实现者，那如果是这种情况，可不可以使用go实现SayHello函数呢？
答案是可以的，这种技术也称为面向C语言接口(.h中的接口声明)的编程技术，该技术不仅仅可以解放函数的实现者，同时也可以简化函数的使用者。
cgoTest.go
package main import "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/050456c35fe4d60fcd33256961dc78d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5147d9b0e4cd7e93f6e1f9c464b139a9/" rel="bookmark">
			U-Net 3&#43;: 全尺度的跳跃连接的 UNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
前言：U-Net由Olaf Ronneberger等人在在2015年MICCAI上提出。U-Net在神经元结构分割方面取得了巨大的成功，由于功能在层之间传播，因此其框架是突破性的。后续在U-Net的基础上涌现了许多优秀的架构如：U-Net++，Attention U-Net，U2-Net等，今天我们将介绍新的U-Net结构：U-Net+++。
通过增强U-Net架构，在多个数据集上U-NET 3+性能优于Attention UNET，PSPNet，DeepLabV2，DeepLabV3和DeepLabv3 +。这是发表2020 ICASSP的一篇论文，UNet++使用嵌套和密集跳过连接，但它没有从全尺度探索足够的信息。在 UNet 3+ 中，使用了全面的跳过连接和深度监督：
全尺度跳跃连接：将来自不同尺度特征图的低级细节与高级语义结合起来。
全尺度的深度监督：从全尺度聚合特征图中学习分层表示。
进一步提出了混合损失函数和分类引导模块（CGM）
UNet 3+提供更少的参数，但可以产生更准确的位置感知和边界增强的分割图。
论文：UNet 3+: A Full-Scale Connected UNet for Medical Image Segmentation
论文链接：https://arxiv.org/abs/2004.08790
代码链接：https://github.com/ZJUGiveLab/UNet-Version
01
全尺度跳跃连接
U-Net，U-Net++， U-Net3+ 结构图：
左：UNet，中UNet++，右：UNet 3+
无论是普通的连接U-Net还是密集连接的U-Net ++都缺乏从全尺度探索足够信息的能力，因此不能明确地得知器官的位置和边界。
U-Net 3+ 中的每个解码器层都融合了来自编码器的较小和相同尺度的特征图以及来自解码器的较大尺度的特征图，它们捕获了全尺度下的细粒度语义和粗粒度语义。
全尺度跳跃连接示例
为了构建 特征图，类似于U-NET，直接接收来自相同尺度编码器层的特征图 。
与U-Net 相比，一组编码器-解码间跳跃连接通过非重叠最大池化操作将来自较小尺度编码器层 和 进行池化下采样，以便传递底层的低级语义信息。
通过一系列内部解码器跳跃连接利用双线性插值传输来自大尺度解码器层 和 的高级语义信息。
UNet 3+ 中的参数少于UNet和UNet++ 中的参数。（这里有数学证明，有兴趣的可以阅读论文。）
02
全尺度的深度监督
2.1 深度监督
UNet 3+ 从每个解码器阶段（Sup1 到 Sup5）产生一个切分侧边输出，由真实的分类结果监督。
为了实现深度监督，每个解码器阶段的最后一层被送入一个普通的 3 × 3 卷积层，然后是一个双线性上采样和一个 sigmoid 函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5147d9b0e4cd7e93f6e1f9c464b139a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/637d19c5a33e4176d3fca12ff862de5f/" rel="bookmark">
			2021-06-23
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中基类的析构函数为什么要用virtual虚析构函数 知识背景 要弄明白这个问题，首先要了解下C++中的动态绑定。 关于动态绑定的讲解，请参阅： C++中的动态类型与动态绑定、虚函数、多态实现
正题 直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
示例代码讲解
现有Base基类，其析构函数为非虚析构函数。Derived1和Derived2为Base的派生类，这两个派生类中均有以string* 指向存储其name的地址空间，name对象是通过new创建在堆上的对象，因此在析构时，需要显式调用delete删除指针归还内存，否则就会造成内存泄漏。
示例代码讲解 现有Base基类，其析构函数为非虚析构函数。Derived1和Derived2为Base的派生类，这两个派生类中均有以string* 指向存储其name的地址空间，name对象是通过new创建在堆上的对象，因此在析构时，需要显式调用delete删除指针归还内存，否则就会造成内存泄漏。
class Base {
public:
~Base() {
cout &lt;&lt; "~Base()" &lt;&lt; endl;
}
};
class Derived1 : public Base {
public:
Derived1():name_(new string("NULL")) {}
Derived1(const string&amp; n):name_(new string(n)) {}
~Derived1() {
delete name_;
cout &lt;&lt; "~Derived1(): name_ has been deleted." &lt;&lt; endl;
}
private:
string* name_;
};
class Derived2 : public Base {
public:
Derived2():name_(new string("NULL")) {}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/637d19c5a33e4176d3fca12ff862de5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce478d3ee198e4963aa24a76b1b576b9/" rel="bookmark">
			nvidia-smi no devices were found的“奇技淫巧”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在跑深度学习的代码的时候突然出现这样的情况：昨天还能跑的代码，今天就突然崩了。然后发现nvidia-smi no devices were found。？？？这就一脸懵！！！网上查资料说是驱动问题，需要重装显卡驱动。由于我的设备是远程连接的别人的设备，只能放弃。突发奇想，让他一直nvidia-smi，查了一下ubuntu下命令是这样子：watch -n 0.1 -d nvidia-smi就是每0.1s查看一次显卡。奇迹诞生！！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa60a5cb512c6e04ac2ce097b71c1ab0/" rel="bookmark">
			win10窗口移动快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win + ←：最大化窗口到左侧的屏幕上（与开始屏幕应用无关）
Win + →：最大化窗口到右侧的屏幕上（与开始屏幕应用无关）
Win+ ↑：最大化窗口（与开始屏幕应用无关）
Win+ ↓：最小化窗口（与开始屏幕应用无关）
Win+ SHIFT +↑：垂直拉伸窗口，宽度不变（与开始屏幕应用无关）
Win+ SHIFT +↓：垂直缩小窗口，宽度不变（与开始屏幕应用无关）
Win+SHIFT+←：将活动窗口移至左侧显示器 （与开始屏幕应用无关）
Win+SHIFT+→：将活动窗口移至右侧显示器（与开始屏幕应用无关）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1adc9adf528cb1a7e2acabf353c21b/" rel="bookmark">
			没有足够的权限为该计算机所有用户,win 10安装程序显示没有足够的权限为该计算机所有用户完成此安装...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2. 第二步，在电脑中新建一个文本文档，在新建的文档中输入一下代码：
@echo off
pushd "%~dp0"
dir /b %systemroot%\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;gp.txt
dir /b %systemroot%\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;gp.txt
for /f %%i in ('findstr /i . gp.txt 2^&gt;nul') do dism /online /norestart /add-package:"%systemroot%\servicing\Packages\%%i"
pause
输入以上代码后，将文件另存为后缀为.cmd的文件，然后右击以管理员的身份打开，再重启电脑即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27943c12e6c2b75e1e22f4d29fc312f/" rel="bookmark">
			动态规划——矩阵连乘问题算法及实现详解（附完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题分析 矩阵连乘问题是经典的动态规划问题，其主要是n个矩阵进行矩阵乘法运算时，通过括号改变运算的先后顺序，减少运算次数，找到最佳划分方法，求解最少运算次数。
算法分析 矩阵连乘问题中动态规划可以帮助我们找到从每个矩阵到另一个矩阵的最小运算次数以及对应的划分,我们用dp[i][j]存储从矩阵A[i]到矩阵A[j]的运算次数。每当对从矩阵A[i]连乘到矩阵A[j]求解最小连乘括号划分时，我们引入A[i]到A[j]连乘序列中的一个矩阵A[k]。我们从第i+1个矩阵开始尝试，直到矩阵A[j],如果有更优解——得到更小的dp[i][j]，那么就更新，并且将第k个矩阵视为一个分割界限进行记录,直到完成对dp[1][n]的更新。
①初始化
因为每个矩阵对自身不用进行运算，所以我们将dp[i][j]的对角线元素初始化为0
for(int i=1;i&lt;matrixNum;i++){//初始化对角线元素为零 dp[i][i]=0; } ②核心算法
1）引入变量length用来记录当前矩阵连乘的数目，我们从两个矩阵连乘开始寻找最优解，直到求出n个矩阵连乘的最优解。
2）引入变量j记录连乘矩阵的最后一个矩阵的下标。
3）引入二维数组decison[i][j]记录每轮矩阵A[i]连乘到矩阵A[j]的分割界限,每一轮都会不断更新，直到找到本轮最好的分割界限。
4）核心算法共三轮循环：
第一轮用来控制由小问题不断向大问题扩展——先求解两两矩阵相乘最优解，再进行连续三个矩阵相乘求最优解，最终求出n个矩阵连乘的最优解。
第二轮连乘起点矩阵遍历的控制。每轮循环需要先把分割界限设定在起点矩阵，对dp[i][j]进行初始化。
第三轮连乘矩阵A[i]到矩阵A[j]之间，中间矩阵A[k]的遍历控制。
注意 ：个人认为最难理解的地方在于，每次对dp[i][j]的更新都要将分割界限k两侧并且运算后的整体矩阵单独拿出来进行相乘运算并且加和—— matrixIndex[i-1]*matrixIndex[i]*matrixIndex[j];。
int j=0; for(int length=2;length&lt;=matrixNum;++length){//length表示矩阵连乘的矩阵数目 for (int i=1;i&lt;=matrixNum-length+1;++i){ j=i+length-1;//length-1表示本次矩阵连乘的结果加和次数，j记录连乘矩阵的最后一个矩阵的下标 dp[i][j] = dp[i+1][j]+matrixIndex[i-1]*matrixIndex[i]*matrixIndex[j];//先将分割界限定在i，即最后计算第一个矩阵与后面整体相乘 decision[i][j] = i;//记录分割界限 for (int k = i + 1; k &lt; j; ++k){ int tmp = dp[i][k]+dp[k+1][j]+matrixIndex[i-1]*matrixIndex[k]*matrixIndex[j];//k作为分割界限，不断寻找更优的划分界限，使得该规模矩阵相乘计算次数尽可能小 if(dp[i][j]&gt;tmp){//如果有更优解就更新 dp[i][j] = tmp; decision[i][j] = k;//更新分割界限 } } } } ③结果展示
完整代码 package com.algorithm.review; import java.util.Scanner; public class Matrix { public int [] matrixIndex=new int[100]; public int [][] decision = new int[100][100];//分割界限记录 public int [][]dp = new int[100][100]; int matrixNum = 0; public static void main(String[] args) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a27943c12e6c2b75e1e22f4d29fc312f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f911a12cedf76ed5ac205e0e38d57b8/" rel="bookmark">
			用计算机怎么录音,电脑怎么录音？你知道电脑上的录音机在哪吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：电脑怎么录音？你知道电脑上的录音机在哪吗？
我们都知道手机上有录音设备，但其实电脑上也是有录音机的哦！只不过平常它藏得比较深，我们想要发现它也不是一件容易的事情，下面我们就一起来看看如何找到电脑上的录音设备吧。
1、程序打开
打开电脑程序窗口，在搜索框中直接输入“录音机”，按回车键，就可以快速调用电脑上的录音机机了。
2、附件打开
在程序窗口中，我们也可以通过选择“所有程序—附件”，找到其中的“录音机”设备，从而打开电脑上的录音机。
3、快捷键打开
直接通过快捷键“Win+R”打开“运行”窗口，在输入框中，输入“soundrecorder”。按enter键后，就可以快速打开录音机设备。
4、控制面板打开
除了上面三种常规的打开方式外，我们还可以通过控制面板来打开电脑的录音机。
操作如下：
①打开电脑上的控制面板，点击“Realtek高清晰音频管理器”。
接着，在电脑屏幕下方的任务栏中找到一个橘色的扬声器图标。
右键选择该图标，选择其中的“录音机”，打开录音机。
不过电脑上的录音机音质较差，如果是想要录制一些音质比较好的音频，还是要通过更加专业的录音设备。小编在电脑上使用的是迅捷录音软件。操作也非常简单，打开软件后，设置“音频选项”以及“声音来源”后，点击“开始录制”按钮，就可以进行音频录制了。
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22f409547f9b1efb8a4d2662afb2114/" rel="bookmark">
			图形学基础|各项异性与头发渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形学基础|各项异性与头发渲染 文章目录 图形学基础|各项异性与头发渲染一、前言二、各向异性光照2.1 各向异性光照现象2.2 ShadingModel扩展 三、头发光照模型3.1 Kajiya-Kay Model3.1.1 Strand based Anisotropy3.1.2 Kajiya-Kay经验模型3.1.3 基于Kajiya-Kay的卡通头发 3.2 Marschner Model3.2.1 着色模型公式3.2.2 UE头发材质和着色器代码 四、头发建模和制作技巧4.1 头发模型建模4.2 头发贴图4.3 毛发渲染的排序问题 参考博文 一、前言 在 虚幻引擎之自定义着色模型（ShadingModel） 中，笔者简要地提到了Hair（毛发）光照模型，但是并没有做深入一点的介绍和源码的阅读。
同时与头发材质渲染经常一起提到的就是各向异性（Anisotropy），这又是什么样的概念呢？
在本篇博客中，将对各向异性和头发渲染进行介绍。
二、各向异性光照 2.1 各向异性光照现象 在渲染头发、丝绸等材质时，常要用到各向异性高光（Anisotropic highlighting）。
那么，什么是各向异性高光呢？先来看个直观的对比。
下图左：各向同性金属球；右：各向异性金属球。 可以看到：
左侧各向同性（isotropic）金属球的高光，呈现为一个圆形亮光斑，比较集中；右侧各向异性（Anisotropic）金属球的高光，呈环形，在头发渲染中又称为”天使环“； 各向异性（Anisotropic）指的是在不同方向上表现出的光照效果会产生差异。
右侧的金属表面反射的高光效果和使用 BlinnPhong （或者类似算法）得到的高光效果有着明显的差异。
这可能是由于加工工艺导致的，表面并不是抛光的（一个完全被抛光的物体表面是光学平面），因此形成了大量细小沟槽。
这样类型的凹槽造成了各向异性的光照效果。由于凹槽没有小到可以被光线忽略，所以当光线到达物体表面的时候没有办法直接反射出去，而是射入了凹槽中，在凹槽内部经过多次反射，最终才反射出来。
现实生活中还有很多物体表面会产生各向异性的光照效果，比如丝绸织物， 头发，CD表面等。
在渲染中来实现各向异性光照时，我们需要在像素着色器中，根据法线扰动规则重新计算法线，这样虽然是一个平面，但它上面的像素却会因为法线扰动而形成一些纹理、凹槽的效果，从而展示出更多的细节表现，而且法线的扰动通常是有规律的，所以在不同的方向上表现出的效果可能会不一样，从而表现出所谓的光学各向异性。
2.2 ShadingModel扩展 将各向同性的shading model拓展到各向异性，需要解决两个问题：
需要引入哪些新的参数来描述各向异性？需要在原有BRDF模型的基础上修改公式的哪些部分来描述各向异性？ 对于问题1：
既然是各向异性，必须要分别定义各个方向上的差异属性，这里的属性一般是粗糙度（Roughness）。
方向一般在切平面上选取两个轴，即tangent方向和bitangent方向，他们与normal共同构成了一组正交基底（TBN坐标系）。
对于需要精细控制切平面方向的模型，比如头发，会单独提供切向贴图，指明切向方向，类似于法向贴图。其他情况一般由系统（shader）确定切向方向。
通过增加额外的一个参数，将原有的粗糙度替换成为tangent和bitangent方向的粗糙度，记作 α t , α b \alpha_{t},\alpha_{b} αt​,αb​或 α x , α y \alpha_{x},\alpha_{y} αx​,αy​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22f409547f9b1efb8a4d2662afb2114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4e3fa74088acb6b132ab8ac632addd/" rel="bookmark">
			kotlin之我又迷惑了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题格外短，也格外简单。
fun hello() = { println("Hello World") } fun main() { hello() } 打印结果是：
无法编译打印"Hello World"什么也不发生其他情况 暂且不纠结答案，先来回顾一下 Kotlin 中是如何声明函数的。
Kotlin 使用 fun 关键字来声明函数，如下所示： fun hello() = "Hello World" Kotlin 会自动推导函数返回值，上面的代码定义了一个返回值是 String 的函数。
那么… 下面的代码正确吗？
fun hello3() { return "Hello Wrold" } hello2() 是不能正常编译的。因为如果显式使用了 return，也必须显式指定返回值类型。
到这，注意两个点：
1、Kotlin 会自动推导函数返回值类型，但显式 return 也必须显式声明返回值类型。
2、使用 = 定义函数可以省略函数返回值类型。 回到原题：
fun hello() = { println("Hello World") } 这就很明了了，声明了一个返回值类型可自动推导的函数 hello() ，其返回值类型就是 = 后面的 {…} 。
这对大括号是什么类型呢？熟悉kotlin语法应该知道 {} 是Lambda表达式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc4e3fa74088acb6b132ab8ac632addd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7fac5fb03af6d13970b7e866750166/" rel="bookmark">
			华为数通ENSP修改中文方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在〈〉用户视角这里修改命令:
language-mode-china
他只能用于display查看信息才显示中文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda4efd74d9b2bc4600514305cc97951/" rel="bookmark">
			＜a＞标签的click和href的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		onclick的事件被先执行，其次是href中定义的（页面跳转或者javascript）
两个定义同时存在的时候（onclick与href），如果想阻止href的动作，在onclick必须加上return false; 一般是这样写οnclick=“xxx();return false;”.
在href中定义的函数如果有返回值的话，当前页面的内容将被返回值代替如果页面过长有滚动条，且希望通过链接的 onclick 事件执行操作。应将它的 href 属性设为 javascript:void(0);，而不要是 #，这可以防止不必要的页面跳动；
所以，比较推荐的写法是
&lt;a href="javascript:void(0)" onclick="fn(this)"&gt; &lt;a href="javascript:void(0);" onclick="javascript:goUrl('http://www.sina.com');return false;"&gt;跳转3&lt;/a&gt; &lt;a href="#" onclick="subgo()"&gt;点我&lt;/a&gt;与&lt;a href="javascript:void(0)" onclick="subgo()"&gt;点我&lt;/a&gt;区别。 实际上 #包含了一个位置信息默认的锚是#top 也就是网页的上端 ，而javascript:void(0) 仅仅表示一个死链接，没有任何信息。所以调用脚本的时候最好用void(0)
href一般是指向一个URL地址，也可以调用javascript ,如href=“javascript:xxx();”,
文档中推荐这样写：&lt;a href=" javascript:void(0)" onclick="xxx();"&gt;xx&lt;/a&gt;,
此方法在复杂环境有时会产生奇怪的问题，尽量不要用javascript:协议做为a标签的href属性，这样不仅会导致不必要的触发window.onbeforeunload事件，在IE里面更会使gif动画图片停止播放。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3844e3d6e5fc9db7b5596bb251aba28/" rel="bookmark">
			讲一讲冯诺依曼计算机模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要分为输入设备，输出设备，存储器，运算器，控制器
根据这个模型就具体实现了一个计算机的基本硬件
输入设备，就有鼠标，键盘等
输出设备，就有显示屏，打印机等
存储器，就有内存条，寄存器，cpu缓存等
控制器，就有cpu的控制单元
运算器，就有cpu的运算单元
cpu有控制单元，运算单元，存储单元
存储单元里又有寄存器，多级缓存，分别为一级缓存，二级缓存，三级缓存
一个cpu中有多个物理核，每个物理核又能有多个逻辑核
每个逻辑核独占一个一级缓存 每个物理核独占一个二级缓存
每个cpu又独占一个三级缓存
每次cpu运行程序的时候，控制器会从存储单元中取出一条指令，根据指令，读取寄存器中的数据，如果没有，从一级中读，读过没有再从二级缓存中毒，如果再没有，从三级缓存中读，最后没有再从主存中读， 读取又是一道复制的过程，将数据从主存复制到三级缓存，三级缓存再复制到二级缓存，二级缓存再复制到一级缓存，最后再将一级缓存复制到寄存器,在从寄存器中取数据，根据指令，控制运算器操作数据执行运算操作.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5df5ec8415e2b440ea56a1f2b67a6c9/" rel="bookmark">
			数据库系列之MySQL分布式事务原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 5.0版本后开始支持XA分布式事务，本文简要介绍XA事务原理及MySQL和MyCAT中XA事务的实现，并使用Python程序案例进行测试验证。
1、XA事务原理 分布式事务处理是指一个程序或程序段，在一个资源或多个资源上为完成某些功能的执行过程的集合。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的动作，提交或回滚事务的决定必须产生统一结果。X/Open定义了分布式事务处理模型，包括应用程序AP、事务管理器TM、资源管理器RM、通信资源管理器CRM。
1）在XA规范中分布式事务有AP、RM、TM组成：
应用程序（Application Program）：定义事务边界（定义事务开始和结束）并访问事务边界内的资源资源管理器（Resource Manager）：RM管理计算机共享的资源，资源包含比如数据库、文件系统等事务管理器(Transaction Manager ，简称TM)：负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。 2）分布式事务的流程如下：
配置TM，将RM注册到TM，即给TM注册RM为数据源AP从TM获取资源管理器的代理，获取TM所管理的RM的JDBC连接AP向TM发起全局事务TM将XID通知到各RMAP通过链接直接对RM进行操作AP结束全局事务TM会通知RM全局事务结束开始二阶段提交 3）Xa主要规定了RM与TM之间的交互，在XA规范中定义的RM 和 TM交互的接口：
xa_start：负责开启或者恢复一个事务分支，并且管理XID到调用线程xa_end：负责取消当前线程与事务分支的关联xa_prepare：负责询问RM 是否准备好了提交事务分支xa_commit：通知RM提交事务分支xa_rollback：通知RM回滚事务分支xa_close：结束使用RMxa_open：AP初始化RM 4）XA协议是使用了二阶段协议
应用程序调用了事务管理器的提交方法，此后第一阶段分为两个步骤： 事务管理器通知参与该事务的各个资源管理器，通知他们开启事务、执行SQL（暂不提交），并进入prepare状态（该状态下可执行commit / rollback）。资源管理器接收到消息后开始准备阶段，写好事务日志并执行事务，但不提交，然后将是否就绪的消息返回给事务管理器RM根据自己的情况，如果判断自己进行的工作可以被提交，那就就对工作内容进行持久化，并给TM回执OK；否者给TM的回执NORM在发送了否定答复并回滚了已经的工作后，就可以丢弃这个事务分支信息了 第二阶段也分为两个步骤： 事务管理器在接受各个消息后，开始分析，如果有任意其一失败，则发送回滚命令，否则发送提交命令。各个资源管理器接收到命令后，执行（耗时很少），并将提交消息返回给事务管理器。 两阶段提交的好处是有了事务管理器进行统一管理，让事务在提交前尽可能的完成所有能完成的工作。同时两阶段提交可以保证事务的一致性，不管是事务管理器还是各个资源管理器，每执行一步操作都会被日志记录，为出现故障后的恢复提供依据。
5）XA事务的问题和MySQL的局限性
XA事务明显的问题是timeout问题，因为事务管理器要收集各个资源管理器的响应消息，如果其中一个或多个一直不返回消息，则事务管理器一直等待，应用程序也被阻塞。
MySQL中的XA事务，长期起来存在一个缺陷：MySQL中数据库的主从复制是通过binlog复制完成的，而binlog是MySQL数据库内部XA事务的协调者，并且MySQL数据库为binlog做了优化，binlog不写prepare日志只写commit日志。如果所有的节点prepare完成，但是在commit前crash，如果crash恢复的时候选择commit，由于binlog在prepare阶段未写，在主库看来此分布式事务最终提交了，但是此事务的操作并未写到binlog中，因此也就未能成功复制到备库，从而导致主备库数据不一致的情况出现。
2、MySQL中XA实现 2.1 MySQL中的XA事务 MYSQL的数据库存储引擎InnoDB的事务特性能够保证在存储引擎级别实现ACID，而分布式事务让存储引擎级别的事务扩展到数据库层面，甚至扩展到多个数据库之间，这是通过两阶段提交协议来实现的，MySQL 5.0或者更新版本开始支持XA事务，从下图可知MySQL中只有InnoDB引擎支持XA协议：
MySQL中的XA事务分为外部XA事务和内部XA事务：
外部XA用于跨多MySQL实例的分布式事务，需要应用层作为协调者，应用层负责决定提交还是回滚崩溃时的悬挂事务。MySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持内部XA事务用于同一实例下跨多引擎事务，由Binlog作为协调者，比如在一个存储引擎提交时，需要将提交信息写入二进制日志，这就是一个分布式内部XA事务，只不过二进制日志的参与者是MySQL本身。Binlog作为内部XA的协调者，在binlog中出现的内部xid，在crash recover时，由binlog负责提交。(这是因为，binlog不进行prepare，只进行commit，因此在binlog中出现的内部xid，一定能够保证其在底层各存储引擎中已经完成prepare)。 2.2 MySQL XA事务的语法 1）首先确保MySQL开启XA事务支持
mysql&gt; SHOW VARIABLES LIKE '%xa%'; +------------------------+-------+ | Variable_name | Value | +------------------------+-------+ | innodb_support_xa | ON | +------------------------+-------+ innodb_support_xa的值是ON就说明mysql已经开启对XA事务的支持了，如果不是可以使用命令“SET innodb_support_xa=ON”开启
2）XA事务的语法有以下
XA START 'xid'; // 'xid' 是用户给的，全局唯一在一台mysql中开启一个XA事务 XA END 'xid '; //标识XA事务的操作结束 XA PREPARE 'xid'; //告知mysql 准备提交这个xa事务 XA COMMIT 'xid'; //告知mysql提交这个xa事务 XA ROLLBACK 'xid'; //告知mysql回滚这个xa事务 XA RECOVER;//查看本机mysql目前有哪些xa事务处于prepare状态 其中xid是一个全局唯一的id标示一个分支事务，每个分支事务有自己的全局唯一的一个id,是一个字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5df5ec8415e2b440ea56a1f2b67a6c9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/179/">«</a>
	<span class="pagination__item pagination__item--current">180/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/181/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>