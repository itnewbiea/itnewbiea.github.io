<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4c4725e9e06f6c957969ac9a48a40a/" rel="bookmark">
			设置el-table表头全选框隐藏或禁用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：设置el-table表头的多选框隐藏或禁用，网上找的均造成即时生效，但刷新页面时页面会卡顿。
方法1：
直接使用css（scoped中）设置：
::v-deep .el-table__header-wrapper .el-checkbox { // display: none;//设置不成功，页面卡顿 visibility: hidden; } 方法2：
给el-table设置表头属性header-cell-class-name
leftheaderStyle({ row, column, rowIndex, columnIndex }) { if (columnIndex === 0) { return "seltAllbtnDis"; } }, css部分(scoped)：
::v-deep .seltAllbtnDis .cell { visibility: hidden; } 以上2种方法可隐藏全选框，效果如下：
方法3：
使用el-table的select-all方法，此方法为设置全选框禁用，非隐藏
//禁用全选框 selectAll() { this.$refs.MainTable.clearSelection(); }, 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b854ff19fff648eec04afdd9707897e/" rel="bookmark">
			python学习之字符串去重的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的工作经常会碰到对字符串进行去重的操作，这篇文章主要介绍python去掉字符串中重复字符的几种方法，需要的小伙伴可以参考哦。
1、直接遍历字符串的方式 # *_* coding : UTF-8 *_* name='王李张李陈王杨张吴周王刘赵黄吴杨' newname='' for char in name: if char not in newname: newname+=char print (newname) 王李张陈杨吴周刘赵黄 2、遍历去重的另一种方式 # *_* coding : UTF-8 *_* name='王李张李陈王杨张吴周王刘赵黄吴杨' newname='' i = len(name)-1 while True: if i &gt;=0: if name[i] not in newname: newname+=(name[i]) i-=1 else: break print (newname) 杨吴黄赵刘王周张陈李 3、将字符串转换成列表的方式（list sort） # *_* coding : UTF-8 *_* name = '王李张李陈王杨张吴周王刘赵黄吴杨' myname = set(name) print(myname) newname = list(set(name)) print(''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b854ff19fff648eec04afdd9707897e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797f4b12d2adf59c12f797459575417d/" rel="bookmark">
			spark outline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 SparkCoreRDD 概述 特性RDD的创建和分区规则Transformation转换算子1. Value类型2. 双Value类型3. Key-Value类型 Action 行动算子RDD序列化 闭包检查 序列化方法和属性 Kryo序列化框架RDD依赖关系RDD持久化spark 分区器Spark Core IO 读写累加器广播变量SparkCore项目实战 Spark SQLSpark SQL DataFrame DataSet概述Spark SQL APISpark SQL IO 读写SparkSQL项目实战：TopN Spark StreamingSpark Streaming概述 特点 架构DStream创建 通过监听端口 自定义数据源 Kafka数据源DStream无状态化转换原语&amp;有状态转化原语DStream输出原语-foreachRDD&amp;使用SparkSQL处理采集周期中的数据Spark Streaming项目实战 Spark 内核spark 面试 SparkCore RDD 概述 特性 Spark RDD 概述 特性 RDD的创建和分区规则 Spark RDD 创建和分区规则
Transformation转换算子 1. Value类型 Spark map和mapPartitions
Spark mapPartitionsWithIndex
Spark flatMap
Spark glom
Spark groupBy
Spark filter
Spark sample
Spark distinct
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/797f4b12d2adf59c12f797459575417d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ad8d012fc0b1cd7a05ddcda5b5df3c/" rel="bookmark">
			spawn cmd ENOENT错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景：spawn cmd ENOENT错误 问题描述 例如：使用Vue设置启动服务器时自动打开浏览器报错如下
Error: spawn cmd ENOENT at Process.ChildProcess._handle.onexit (internal/child_process.js:240:19) at onErrorNT (internal/child_process.js:415:16) at process._tickCallback (internal/process/next_tick.js:63:19) Emitted 'error' event at: at Process.ChildProcess._handle.onexit (internal/child_process.js:246:12) at onErrorNT (internal/child_process.js:415:16) at process._tickCallback (internal/process/next_tick.js:63:19) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! jian@0.1.0 start: `react-scripts start` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the jian@0.1.0 start script. npm ERR! This is probably not a problem with npm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03ad8d012fc0b1cd7a05ddcda5b5df3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd7326909f9176da48c92e7519fd88fd/" rel="bookmark">
			Node.js 入门：events 模块和发布订阅模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文会介绍 events 模块的主要作用和使用方式，以及自己实现一个简单的发布订阅模式，帮助加深理解。
events 模块 文档地址，点击访问。
Node.js 是基于事件驱动实现的异步操作。 事件驱动依赖就是的 events 模块。
events 模块导出一个 EventEmitter 类，它是发布订阅模式的一种实现。
无论你是了解发布订阅模式，只要你有过前端开发的经验，那么对于 DOM事件监听，事件解绑等操作一定不陌生。其实这就是一种发布订阅。
平时开发中我们很少会直接使用这个模块。这是因为 Node.js 的很多内置模块，比如 fs ， http 等模块，都是继承自 EventEmitter 类而实现的。
也就是说，我们平时经常用到的模块，就已经具备了发布订阅（事件监听、事件触发）的能力。后面会介绍到 Stream 和 http 模块的使用，到时候就会发现，到处都有发布订阅的影子。
EventEmitter 类 events 模块对外暴露 EventEmitter 类。
打印一下它的原型对象：
const EventEmitter = require('events') console.log(EventEmitter.prototype) 有很多方法，光看名字我们就能知道每个方法的作用是什么：
on：订阅事件emit：发布事件once：只订阅一次，也就是只能触发一次removeListener：移除订阅者removerAllListeners：移除所有的订阅者off：removeLister 方法的别名 使用 EventEmitter 类的使用方式有两种。
首先它是一个构造函数（源码中以构造函数实现），所以可以通过实例化的方法来使用。
其次，node 的很多模块都是继承自它，所以子类除了自身的能力之外，也具备了发布订阅的能力。
这里演示下第二种。
const EventEmitter = require('events') class Reader extends EventEmitter { // ... } const reader = new Reader() const buy = bookName =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd7326909f9176da48c92e7519fd88fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ea201566d4ac4f9cd1d1e28254b081/" rel="bookmark">
			word文档图标变成白色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word文档图标变成白色，有可能是电脑上既有microsoft office，又安装又WPS（WPS比较流氓，会篡改注册表中图标的路径，下图打个比方）
图标路径被修改后，容易与office发生冲突，就会出现两种图标都不显示的情况，此时就需要自己手动修改注册表ICON部分的路径了。亲测有效，图标已还原。
直接搜其他人的修改注册表的方法吧，我就先不写了，以后再补。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/789de822da80d97d13bb8f18713bf530/" rel="bookmark">
			Linux中的休眠函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
Linux中应用层和驱动层编写代码时都会用到延时，本文主要介绍两种情况下延时功能的实现。
1.应用层：sleep、usleep；
2.驱动层：udelay、mdelay、ssleep、通过jiffies 、定时器、中断底半部；
二、应用层延时
1.sleep 头文件：#include &lt;unistd.h&gt;
原 型：unsigned int sleep(unsigned int seconds);
参 数：seconds：延时时长，单位s；
返回值：0 - 表示成功休眠seconds时长；
other - 表示在延时过程中因信号导致缺少的时长；
注 意：1.sleep的底层逻辑使用nanosleep实现，并且在一些系统中，sleep可以通过alarm和SIGALRM信号实现，但是不要混合调用alarm和sleep；
2.当进程运行到sleep时，进程将进入到可中断休眠态，唤醒休眠的方式：到达延时时间 和 信号中断休眠；
3.在运行sleep的时候，将会释放CPU的占有率，占用的资源较少；
4.在sleep的时候，如果使用信号中断，将会运行sleep下一指令；
关于注意中第三点相关的测试代码及效果：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt;
int main(int argc,const char argv[])
{
printf("strat\n");
sleep(10);
printf("stop\n");
return 0;
}
2.usleep
头文件：#include &lt;unistd.h&gt;
原 型：int usleep(useconds_t usec);
参 数：usec：延时时长，单位us；
返回值：0 - 表示成功休眠usec时长；
-1 - 表示失败，重置errno；
errno为EINTR 由于信号中断导致；
errno为EINVAL设置的休眠时间超出范围；
注 意：1.运行usleep将使线程暂停(至少)usec微秒，睡眠时间可能会因任何系统活动或处理调用所花费的时间或系统计时器的粒度而略微延长；
2.休眠时长范围为0 ~ 1000000，超过范围将报错；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/789de822da80d97d13bb8f18713bf530/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a13972014d86bb018314a8b16e4c1180/" rel="bookmark">
			android tombstone log分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家一起聊聊android 中出现的 Tombstone问题，近期在定制pad 上分析设备概率性重启，导出bugreport日志后，除了看到anr log外，同级目录下还看到了tombstones
并且对比以往日志，发现都生产了大量tombstone...,于是决定一探究竟，或许问题和它有关呢 tombstone概念
tombstone一般是由Dalvik错误、状态监视调试器、C层代码以及libc的一些问题导致的。
当系统发生tombstone的时候，kernel首先会上报一个严重的警告信号(signal),上层接收到之后，进程的调试工具会把进程中当时的调用栈现场保存起来，并在系统创建了data/tombstones目录后把异常时的进程信息写在此目录里面，开发者需要通过调用栈来分析整个调用流程来找出出问题的点。
分析tombstone原因
下面是我遇到的tombstone情况
pid与tid 相同，问题出在主线程
pid与tid 不同，问题出在子线程
signal 信号量分析
信号机制是进程之间相互传递消息的一种方法，常见的型号种类如下：
问题总结
以上两种情况是我遇到的，pid 和tid相同的情况，根据日志分析和对比前后复现问题的tombstone，发现均为三方应用或内部应用在某种场景下诱发Native Crash 可以根据进程号跟踪到相应位置，（真正找到问题根源可能麻烦些，大体是这个路子）；
pid 和tid不同的情况，分析起来有点无从下手，但是前前后后对比日志，发现这种情况进程均为系统服务进程pid: 467, tid: 806, name: HwBinder:467_3 &gt;&gt;&gt;/vendor/bin/hw/android.hardware.audio.service.mediatek &lt;&lt;&lt;
只能根据signal 来找到比较完整的调用栈以及调用底层编码逻辑...
就简单写到这里了，欢迎大家交流补充，如有不对，敬请纠正!
参考链接
Android Tombstone crash定位分析
https://cloud.tencent.com/developer/article/1969660
Android开发太难了，Native Crash的一切！
android跨进程通信——signal https://www.jianshu.com/p/73c33648ffc8
signal 6 (SIGABRT) log分析
https://blog.csdn.net/weixin_29172201/article/details/117613032
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d421cb496a944504fe3fcb65fa2f8550/" rel="bookmark">
			python学习之去除字符串中的空格（6种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了Python 字符串去除空格的6种方法，文中通过示例代码介绍的非常详细，对大家的学习或者工作具有一定的参考学习价值，来一起学习吧。
在处理Python代码字符串的时候，我们常会遇到要去除空格的情况，所以就总结了多种方法供大家参考。
方法1：字符串strip()、lstrip()和rstrip()方法 # *_* coding : UTF-8 *_* username = ' 乐不思蜀 快乐学习 ' print(username.strip()) word='赵 钱 孙 李 周 吴 郑 王' word=''.join([i.strip(' ') for i in word]) print(word) 输出结果：
乐不思蜀 快乐学习
赵钱孙李周吴郑王
方法2：使用split()方法 # *_* coding : UTF-8 *_* word='编号 姓名 性别 年级 学校 奖项' list=word.split(' ') listnew=[i for i in list if i!='' ] new=' '.join(listnew) print(new) 输出结果：
编号 姓名 性别 年级 学校 奖项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d421cb496a944504fe3fcb65fa2f8550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd94267e1f951c6fcb4a020760fbe05/" rel="bookmark">
			2023年 HCIA-Datacom-H12-811 V1.0（最新考试题库200题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		150.链路聚合的LACP模式采用LACPDU选举主动端，LACPDU中的哪些信息是选举LACP主动端的依据？
A.接口编号
B.MAC地址
C.设备优先级
D.接口优先级
答案：BC
151.如下选项中的配置，哪些属于二层ACL？
A.rule20 permit source-mac 0203-0405-0607
B.rule10 permit 12-protocol arp
C.rule 25 permit source 192.168.1.1 0.0.0.0
D.rule 15 permit vlan-id 100
答案：ABD
152.为检测CAPWAP隧道的连通状态，在CAPWAP隧道建立之后AC使用以下哪些CAPWAP报文进行深测？
A. DPD
B. Hello
C. Echo
D.Keep alive
答案：CD
153.控制器是SDN的核心组件。控制器通过南向接口连接设备。以下属于控制器南向协议的的是？
A.PCEP
B. SNMP
C. OpenFlow
D.NETCONF
答案：ABCD
154.关于访问控制列表编号与类型的对应关系，下面描述正确的是？
A.高级的访问控制列表编号范围是3000—3999
B.二层的访问控制列表编号范围是4000—4999
C.基于接口的访问控制列表编号范围是1000—2000
D.基本的访问控制列表编号范围是1000—2999
答案：AB
155.VRP系统中，Ctrl＋Z组合键具备什么功能
A.从任何视图退出用户视图
B.退出接口视图
C.退出当前视图
D.退出Console接口视图
E.从系统视图退回到用户视图
答案：AE
156.下列关于OSPF区域描述正确的是？
A.在配置OSPF区域之前必须给路由器的loopback接口配置IP地址
B.所有的网络都应在区域0中宣告
C.骨干区域的编号不能为2
D.区域的编号范围是从0.0.0.0到255.255.255.255
答案：CD
157.关于冲突域和广播域，描述正确的是？
A.一台采用默认配置的二层交换机所有端口上连接的设备属于一个冲突域
B.一台HUB所有端口上连接的设备属于一个广播域
C.一台HUB上所有端口上连接的设备属于一个冲突域
D.一台路由器所连接的设备属于一个广播域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd94267e1f951c6fcb4a020760fbe05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f30a7c4cc15b65c68c845cf0b345b5/" rel="bookmark">
			python学习之把列表元素拼接成字符串的4种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、使用join()方法连接列列表二、利用for循环连接列表三、对列表进行切片然后连接四、使用zip压缩多个列表为一个列表 前言 我们在分析列表数据时，常常需要对列表数据进行输出或多列表关联拼接。直接使用列表，列表中的各元素以逗号分隔，每个元素包含引号。如何连接列表中的元素为一个字符串呢？
文章主要介绍python 连接列表元素的4种方法，帮助大家更好的理解和学习使用python，感兴趣的朋友可以了解下。
一、使用join()方法连接列列表 使用join()方法可将列表中的元素以指定的间隔符进行连接，如果不使用间隔符，可以使用’ ‘空字符作为间隔符。下面介绍使用符号’ ’ 和"_"连接每个城市：
# *_* coding : UTF-8 *_* city=['上海', '广州', '成都', '北京', '武汉', '长沙', '杭州', '厦门'] print(''.join(city)) print(' '.join(city)) print('-'.join(city)) 输出结果：
上海广州成都北京武汉长沙杭州厦门
上海 广州 成都 北京 武汉 长沙 杭州 厦门
上海-广州-成都-北京-武汉-长沙-杭州-厦门
二、利用for循环连接列表 使用for循环读取列表中的每一个元素，然后拼接为一个字符串。可以按需要设置间隔字符。如使用符号’‘、’+‘和’&lt;'连接列表中的元素。在输出时，若使用print()函数进行直接输出，也可以直接设置print()函数的end参数来设置分隔符，如下：
# *_* coding : UTF-8 *_* data = [10, 20, 30, 40, 50, 60, 70, 80] strnull = '' stradd = '' strlin = '' for item in data: strnull = strnull + str(item) # 连接列表中的元素，间隔符为空 stradd = stradd + '+' + str(item) # 连接列表中的元素，间隔符为‘+’ strlin = strlin + '&lt;' + str(item) # 连接列表中的元素，间隔符为‘&lt;’ if item ==80: print(item) else: print(item, end='*') # 在输出设置间隔符为‘*’，连接各个元素 print(strnull) print(stradd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f30a7c4cc15b65c68c845cf0b345b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671cae2668042d8f9b2bf9eadf6e2d5a/" rel="bookmark">
			用python识别文字中的城市
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候我们希望可以直接在文字中识别城市名，但是这类的库可遇不可求，小编有幸遇到这样一个库，所以分享出来给大家用。
库名：cpca
安装命令：
pip install cpca 使用代码：
import cpca location_str = '济南在哪' df = cpca.transform_text_with_addrs(location_str, pos_sensitive=True) print(df) 这样就可以将文字中所有的地区名都显示出来，各位可以根据自己文字的特点进行摘取。
比如摘取第一个的省、市、区/县
shengfen = df.loc[0, '省'] shi = df.loc[0, '市'] qu = df.loc[0, '区'] 如果有多个地区名可以自己根据需要调整摘取第几个的名字。
比如第三个就是
shengfen = df.loc[2, '省'] shi = df.loc[2, '市'] qu = df.loc[2, '区'] 也可以去判断然后再处理。
例如：https://www.lcyinsu.com/
这个站就是判断标题中包含的地区，然后将地区转成拼音，最后拼接成二级域名地址。比如北京市的就会吧内容发到https://beijingshi.lcyinsu.com中去
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0eaf1713553a041766857f45be53f8b/" rel="bookmark">
			el-table实现两个表格的关联连接（类似数据库的左连接关系）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023.2.7今天我学习了如何使用el-table实现两个表格之间的关联连接。
首先什么是关联关系： left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行
效果： 表一：
表二：
连接的新表一：
我们可以看到相同的键名是【ccc】，对应的相同的值是【33】和【66】。然后相关的数据就会被关联起来，没有相关的数据就会Push到新的一行。
为了防止其他键名出现重复，需要把通用的键名删除，如(id,time等)，只留下字段名就好，如(col_a,col_b,col_c)。
js删除不需要的键名代码如下：
// 去掉原表格数据不需要的字段 const data_List = this.dataList.map((item, index, arr) =&gt; { delete item.id delete item.created_at delete item.updated_at delete item.version }) // 去掉添加数据不需要的字段 const add_data_List = remarkName.map((item, index, arr) =&gt; { delete item.id delete item.created_at delete item.updated_at delete item.version }) js代码如下：
const demo = (arr1, arr2) =&gt; { const res = [] // 扩展数组 const arr = [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0eaf1713553a041766857f45be53f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e420976f6504a210fb8e18dae2b8e1/" rel="bookmark">
			java中的if介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 if 定义形式
if(布尔运算值){源程序;}
else if(布尔运算值){源程序;}
else if(布尔运算值){源程序;}
else{程序}
package com.scanner.demo; import java.util.Scanner; public class IfDemo01 { public static void main(String[] args) { Scanner sc = new Scanner(System.in);//定义扫描仪 System.out.println("请输入成绩:"); int score = sc.nextInt();//接受成绩 if (score&gt;=90&amp;&amp;score&lt;=100){ System.out.println("A级"); }else if (score&gt;=80&amp;&amp;score&lt;90){ System.out.println("B级"); }else if (score&gt;=70&amp;&amp;score&lt;80){ System.out.println("C级"); }else if (score&gt;=60&amp;&amp;score&lt;70){ System.out.println("D级"); }else if (score&gt;=0&amp;&amp;score&lt;60){ System.out.println("不及格"); }else { System.out.println("成绩不合法"); } sc.close();//关闭资源,防止程序占用资源 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555c2b0b5f4652fa7827aaf06fe20347/" rel="bookmark">
			线性规划中的人工变量与松弛变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 人工变量
人工变量是为了凑成单纯形表中的基变量而人工加入的单位向量，在目标函数中系数为-M，最后化简结果中基变量要为0，否则无可行解。化简单纯形表就可以解决，若用对偶单纯形表的话就直接能解单纯形表，不用添加人工变量。
2. 松弛变量
松弛变量（或者剩余变量）目的是将线性规划的不等式约束转化为等式约束，松弛变量或者剩余变量分别表示在实际问题中未被充分利用的资源和超出的资源数，均未被转化为价值和利润，因此引进模型后他们在目标函数中的系数均为零。
若所研究的线性规划模型的约束条件全是小于类型，那么可以通过标准化过程引入M个非负的松弛变量。 松弛变量的引入常常是为了便于在更大的可行域内求解。若为0，则收敛到原有状态，若大于零，则约束松弛。
具体而言，对线性规划问题的研究是基于标准型进行的。因此对于给定的非标准型线性规划问题的数学模型，则需要将其化为标准型。这也算是运筹学以及优化问题中的典型做法，即将很多问题简化和标准化为统一的形式，因此实现求解。
一般地，对于不同形式的线性规划模型，可以采用一些方法将其化为标准型。其中 当约束条件为“≤”（“≥”）类型的线性规划问题，可在不等式左边加上（或者减去）一个非负的新变量，即可化为等式。这个新增的非负变量称为松弛变量（或剩余变量），也可统称为松弛变量。在目标函数中一般认为新增的松弛变量的系数为零。
因此，可以看到松弛变量是非负数，如果松弛变量为0时，表示这是稀缺资源，若大于0则表示，资源未充分利用。
3. 两者异同点
相同点：
①都添加到约束条件上;
②取值均非负;
不同点：
①目的不同:添加松弛变量是为了将不等式约束化为等式约束，而添加人工变量是为了给单纯形算法提供初始可行基变量;
②含义不同:松弛变量有具体含义而人工变量没有具体含义;
③在解中不同:当原问题有最优解时，松弛变量取值可以非0，而人工变量取值必定为0；
④在求解过程中，松弛变量在目标函数中的系数都为零，但是人工变量在求解过中的目标函数中的系数不为零，当取得最优解时，人工变量取值必定为0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31060b517ec2f63c9ea2797698ecd8bc/" rel="bookmark">
			java中Switch介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义形式
int i=2; switch (i){ case 1: System.out.println("1号"); break; case 2: System.out.println("2号"); break; case 3: System.out.println("3号"); break; default: System.out.println("未知"); } 对应的i是什么 程序会自动去寻找对应的结果，如果找不到就会执行最后的默认结果default。
全部程序（自己定义）
package com.scanner.demo; import java.util.Scanner; public class SwitchDemo01 { public static void main(String[] args) { int i=2; switch (i){ case 1: System.out.println("1号"); break; case 2: System.out.println("2号"); break; case 3: System.out.println("3号"); break; default: System.out.println("未知"); } } } 升级版
package com.scanner.demo; import java.util.Scanner; public class SwitchDemo01 { public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31060b517ec2f63c9ea2797698ecd8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c36619518057be78423458b3d590c8d/" rel="bookmark">
			js实现判断密码设置是否正确
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件为表单失去焦点，符合密码设置规定，提示语句及图标变为绿色，不符合变为红色。 html代码
&lt;div class="register"&gt; &lt;input type="password" class="ipt"&gt; &lt;i class="fa fa-circle-o" aria-hidden="true"&gt;&lt;/i&gt; &lt;p class="message"&gt;请输入6-16位密码&lt;/p&gt; &lt;/div&gt; css代码
div { width: 600px; margin: 100px auto; } .message { display: inline-block; font-size: 12px; color: #999; padding-left: 2px; } .fa-circle-o { color: #999; padding-left: 8px; } .worng { color: coral; } .fa-dot-circle-o { color: coral; padding-left: 8px; } .right { color: green; } .fa-check-square-o { color: green; padding-left: 8px; } js代码
&lt;script&gt; //获取元素 var ipt = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c36619518057be78423458b3d590c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1886139e31b7be0680f469543608704/" rel="bookmark">
			django项目开发部署完整案例【最终效果展示】【源码】【simpleui】【增删改查】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Background 最近有个项目需要一个简单的页面，为了实现对项目基础信息增删改查的功能，于是就用django+simpleui写了一个，开发工具是pycharm。历经大坑小坑，最终成功上线，这里记录下整个过程，并分享出源码，放在文章最后。如果你想自己测试下，拿到源码，首先你得有python3环境吧，然后你可以按照README.md文件中的【快速开始】准备下你自己的本地环境，按照步骤应该就能起来，如果遇到问题可以评论问我（不要私信我），我天天都刷博客，有消息就能看到，看到就会及时回复。 1、先上最终效果 2、定制化 定制主题 先安装再配置 pip3 install django-simpleui
定制网站logo 定制网站favicon.ico 需要自己制作，这是在线制作网站 在线制作ico图标
定制网站菜单 图标可以在这个网站上找【Font Awesome】， 使用就很简单了。
3、部署到服务器上 这里采用Nginx配合uWSGI的方式。
部署前需要修改下配置 settings.py
1.DEBUG = False
2.ALLOWED_HOSTS = [‘*’]
3.STATIC_ROOT = os.path.join(BASE_DIR, “static”)
首先在服务器上建目录并修改权限 mkdir /pyweb useradd nginx chown -R nginx.nginx /pyweb/ 然后把项目拷贝到这个目录下
安装依赖(我这里没用虚拟环境)
pip3 install -r requirements.txt 配置nginx并启动 怎么安装这里就不赘述了，安装好把nginx.conf的内容换成下面的（若nginx无他用），需要修改的地方已经注释很清楚了。
events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; server { listen 80; server_name yours.com; #改为自己的域名，没域名修改为127.0.0.1:80 charset utf-8; location / { include uwsgi_params; uwsgi_pass yours:8000; #这个和uwsgi里的socket配置要一样 uwsgi_param UWSGI_SCRIPT yunlu_pms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1886139e31b7be0680f469543608704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd502e4af7434dc535c155b488e913c0/" rel="bookmark">
			从零开始教你如何完成一个基于Vite&#43;Vue3&#43;TS的后台管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目大致效果 心动了吗？ 没错，没错，你没看错，在学习了前端也有一年多的时间了，先后学习了：html、css、html5、css3、js、微信小程序、nodejs、vue、react、ts等
现在也是时候来对之前学的知识进行一个综合的练习了，同时也是对除开工作之余时间的一种自我提升和完善把
项目说明 本项目是参考 coderwhy 老师的项目在进行开发学习的，因此这里采用的接口是 coderwhy 老师的接口
可能就有人好奇了，谁是 coderwhy？
在这个互联网如此发达的时代下，只要我们动一动手指头问一下度娘就可以知道了
这里之所以要推荐 coderwhy 老师，是因为他讲的项目里的组件初级封装以及高级封装的思想是使我很受用
工欲善其事必先利其器 对本项目，主要用到到编辑器是 VsCode
另外要开发本项目还需要安装 nodejs
有了以上两个利器之后其实就可以进行开发了
除此之外你还可以安装 postman 进行接口的管理和测试
会在这里一步一步写代码吗？ 答案当然是否定的，关于项目的开发以及保姆式的开发流程本人都统统上传到了我的 码云 上了，感兴趣的小伙伴或者是近期没有找到合适项目做的小伙伴可以参考哦！
进入到我的码云后：
请认准：vue3-ts-admin 哦！！！
点击进去就可以和我一起学习啦！
希望可以多多交流哦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1eedb9ce6c62c5bf4ce60cdd74ee5c/" rel="bookmark">
			Ubuntu 更换清华大学镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 更换镜像源 通常我们使用ubunntu的时候总是出现网络过慢导致的更新下载失败等问题。
Ubuntu默认的服务器是在国外，自然连接就很慢。
这里我们更换成国内的镜像源，这里使用清华镜像源。
操作步骤如下：https://blog.csdn.net/qq_57171795/article/details/123109463
下面介绍更换清华镜像源的方法
1.打开Ubuntu的控制台（快捷键ctrl+Alt T）
2.进入 /etc/apt/路径
cd /etc/apt/ 3.将sources.list备份保存为sources.backup.list,以防止有需要的时候更换回来
cp -a sources.list sources.backup.list 4.打开清华镜像官方,在搜索框输入ubuntu ,点击ubuntu旁边的小问号
https://mirrors.tuna.tsinghua.edu.cn/
https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/
5.根据相应的版本复制镜像源码，查看ubuntu版本。
查看ubuntu对应的版本方法：
cat /etc/issue 这里我的版本号是：21.10，需要在清华网站上选择相应的版本后再复制镜像源码
6.打开sources.list
sudo gedit sources.list 7.将sources.list内的内容清空，粘贴刚刚复制的镜像源，并保存（save）
下面的是ubuntu20.04
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1eedb9ce6c62c5bf4ce60cdd74ee5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133e890c1cb959d62948c38288e651dc/" rel="bookmark">
			No module named  pymssql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller打包后运行报错-No module named 'pymssql._mssql'
方法解决：
import pymssql后，添加这几行即可
from pymssql import _mssql
from pymssql import _pymssql
import uuid
import decimal
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aba75d44f1840ccd44ffe8497b0432b/" rel="bookmark">
			java中的while循环和do while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		while循环
定义形式：while(i&lt;100){};
while(布尔表达式)符合while里面布尔表达式这个while循环才能被运行。
package com.scanner.demo; public class WhileDemo { public static void main(String[] args) { int i=0; int sum=0; while (i&lt;=100){//100内的和为5050 sum=sum+i; i++; } System.out.println(sum);*/ int i=0; int sum=0; while(i&lt;100){ i++; if (i%2==0){//100内偶数和2550 sum=sum+i; }if (i&gt;100){break;} } System.out.println(sum); int i=0; int sum=0; while(i&lt;100){ i++; if (i%2==1){//100内奇数和2500 sum=sum+i; }if (i&gt;100){break;} } System.out.println(sum); } } do while循环（do while无论成不成功都会执行一次）
package com.scanner.demo; public class DoWhile { public static void main(String[] args) { int i=0; int sum=0; do { sum=sum+i; i++; }while (i&lt;=100);//do while无论成不成功都会执行一次 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aba75d44f1840ccd44ffe8497b0432b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933d3c839334969311d67132777852ff/" rel="bookmark">
			微信小程序--》从零实现小程序项目案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏍️作者简介：大家好，我是亦世凡华、渴望知识储备自己的一名在校大学生
🛵个人主页：亦世凡华、
🛺系列专栏：微信小程序
🚲座右铭：人生亦可燃烧，亦可腐败，我愿燃烧，耗尽所有光芒。
👀引言
⚓经过web前端开发的学习，相信大家对于前端开发有了一定深入的了解，今天我开设了微信小程序专栏，主要想从移动端开发方向进一步发展，而对于我来说写移动端博文的第一站就是小程序开发，希望看到我文章的朋友能对你有所帮助。
目录
配置导航栏
配置tabBar
实现页面轮播图
实现页面九宫格
实现底部图片
实现九宫格的导航跳转
实现导航跳转时设置标题内容
实现商品列表数据的渲染
实现上拉加载以及loading效果
实现数据是否加载完毕的判断
实现下拉刷新功能
实现wxs处理手机号
最终的实现效果
今天借助黑马的本地生活案例，加强一下自己对小程序的学习，并将学习过程分享出来，希望能和以前学习的知识相互印证。现在开始：
配置导航栏 导航栏是小程序的门户，用户进来第一眼看到的便是导航栏，其起着对当前小程序主题的概括。而我们 新建的小程序 时，第一步变开始配置导航栏。如下：
配置tabBar 因为配置tabBar需要借助字体图标，我这里平常喜欢使用阿里云字体图标库，所以需要先去阿里云库中找到相关图标：其官方网站：网站链接 。
随便找两个，一个作为未点击(未激活)状态，另一个作为已点击(已激活)状态：
因为我是属于类似做一个小demo ，图标就随便选了，在正式项目必须严谨了，选好图标命名如下
准备好图片资源之后就要在 app.json 文件中配置tabBar了，配置代码如下：
{ "pages":[ "pages/home/home", "pages/message/message", "pages/contact/contact" ], "window":{ "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#008c8c", "navigationBarTitleText": "本地生活", "navigationBarTextStyle":"white" }, "tabBar": { "list": [{ "pagePath": "pages/home/home", "text": "首页", "iconPath": "/images/home.png", "selectedIconPath": "/images/home-active.png" },{ "pagePath": "pages/message/message", "text": "消息", "iconPath": "/images/message.png", "selectedIconPath": "/images/message-active.png" },{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933d3c839334969311d67132777852ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807db5137cedb7ee2ea5060866d9007c/" rel="bookmark">
			Servlet项目创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet 1.Servlet是什么？ Servlet 是一种实现动态页面的技术，是一组 Tomcat 提供给程序猿的 API, 帮助程序猿简单高效的开发一个 web app，它是基于HTTP协议交换并且运行在Tomcat里的框架技术。
2.Servlet的主要工作？ 1）用户的URL到程序的映射
允许程序猿注册一个类, 在 Tomcat 收到某个特定的 HTTP 请求的时候, 执行这个类中的一些代码。
2）得到Request请求中的所有数据
帮助程序猿解析 HTTP 请求, 把 HTTP 请求从一个字符串解析成一个 HttpRequest 对象。
3）将服务器端处理的结果返回给用户
帮助程序猿构造 HTTP 响应。 程序猿只要给指定的 HttpResponse 对象填写一些属性字段, Servlet 就会自动的安装 HTTP 协议的方式构造出一个 HTTP 响应字符串, 并通过 Socket 写回给客户端。
3.第一个Servlet项目 1.创建项目
首先需要创建一个Maven项目，因为Servlet是基于Maven的。
File-&gt;New-&gt;Project-&gt;Maven-&gt;maven-archetype-webapp
贴心的idea会给我们再次显示maven的配置信息，确保国内源已经配置完成，否则项目会创建失败。之后点击Finish即可完成创建。
创建好servlet项目后，进入页面可以看到项目的目录，其中pom.xml中包含maven的配置文件。
其中最重要的还是dependencies标签内的所有依赖，里面有多个dependency，一个dependency就表示一个引用的jar包。
2.引入依赖
添加servlet框架，到中央仓库（[https://mvnrepository.com/]）下载依赖信息，搜索servlet。
其中，servlet的版本号取决于Tomact的版本号，在Tomcat的官网可以查询到官方建议的版本号。我使用的Tomcat版本是8.5的，所以应该使用3.1的servlet。
选择3.1版本servlet，复制依赖信息加入到pom.xml的dependencies中。
复制到pom.xml后，记得点击加载按钮，检查libraries中是否有servlet，存在说明加载成功。
3.创建目录
需要创建两个目录，一个是源代码目录，另一个是单元测试目录。
源代码目录：main-&gt;New -&gt;Directory-&gt;java
单元测试目录：main-&gt;New -&gt;Directory-&gt;test,再将灰色的普通文件夹test转换为单元测试文件夹，是绿色的。
4.编写代码
a)在java目录中创建一个类HelloServlet，继承HTTPServlet。
b)设置URL映射，能够将URL地址定位到当前类上。
c)重写doGet或doPost方法。
5.打包程序
点击maven生命周期中的package进行打包
打包后的项目路径位于右下角显示框中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807db5137cedb7ee2ea5060866d9007c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96bead716128d30fab2dd9dc2780625e/" rel="bookmark">
			argparse--- 命令行选项、参数和子命令解析器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习文档：argparse --- 命令行选项、参数和子命令解析器 — Python 3.11.1 文档 1、介绍 argparse模块可以让我们很方便的编写命令行语句，它可以帮助我们从命令行中解析出程序所需要的参数，argparse模块还自动生成帮助和用法消息。当用户给程序输入无效参数时，模块也会发出错误。
2、使用方法 创建一个解析器，使用 argparse.ArgumentParser() 构建实例 parse = argparse.ArgumentParser( prog = 'ProgramName', description = 'What the program dose', epilog = 'Text at thr bottom of help' ) 添加参数： 使用 ArgumentParser.add_argument() 将参数规范附加到解析器
"--dataset": 表示所添加的参数的名称
type=str: 表示数据类型
default="cora": 表示默认值
hlep: 可以写入一些参数说明，比如该参数有哪几种取值等
parser.add_argument( "--dataset", type=str, default="cora", help="Dataset name ('cora', 'citeseer', 'pubmed').", ) 解析参数： 使用 ArgumentParser.parse_args() 方法运行解析器从命令行中提取数据，并将数据放入变量args中 args = parser.parse_args() ps: 有一次用这种方式发生了报错，改用
args = parser.parse_know_args()[0] 就好了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96bead716128d30fab2dd9dc2780625e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01dcde4a4c8bdd05e45f64c4414cbe1d/" rel="bookmark">
			Python 集合（列表 ，元组，集合， 字典）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一Python 集合 Python 编程语言中有四种集合数据类型：
列表（List）是一种有序和可更改的集合。允许重复的成员。
元组（Tuple）是一种有序且不可更改的集合。允许重复的成员。
集合（Set）是一个无序和无索引的集合。没有重复的成员。
字典（Dictionary）是一个无序，可变和有索引的集合。没有重复的成员。
二.列表（List） 列表是一个有序且可更改的集合。在 Python 中，列表用方括号编写。
实例
1.创建列表：
thislist = ["apple", "banana", "cherry"] print(thislist) 2.访问项目
您可以通过引用索引号来访问列表项：
实例
打印列表的第二项：
thislist = ["apple", "banana", "cherry"] print(thislist[1]) 3.负的索引
负索引表示从末尾开始，-1 表示最后一个项目，-2 表示倒数第二个项目，依此类推。
实例
打印列表的最后一项：
thislist = ["apple", "banana", "cherry"] print(thislist[-1]) 索引范围
您可以通过指定范围的起点和终点来指定索引范围。
指定范围后，返回值将是包含指定项目的新列表。
实例
返回第三、第四、第五项：
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"] print(thislist[2:5]) 注释：搜索将从索引 2（包括）开始，到索引 5（不包括）结束。
请记住，第一项的索引为 0。
负索引的范围
如果要从列表末尾开始搜索，请指定负索引：
实例
此例将返回从索引 -4（包括）到索引 -1（排除）的项目：
thislist = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01dcde4a4c8bdd05e45f64c4414cbe1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7aebd87b315101995af13ba550ad4a4/" rel="bookmark">
			js去掉html中所有的标签、空格和回车换行符只保留文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在做项目的时候需要在HTML代码中提取文本内容，并去掉空格和回车等字符
setText(val) { if (val != null &amp;&amp; val != "") { var re1 = new RegExp("&lt;.+?&gt;|&amp;.+?;","g"); //匹配html标签的正则表达式，"g"是搜索匹配多个符合的内容 var msg = val.replace(re1,""); //执行替换成空字符 msg = msg.replace(/\s/g,""); //去掉所有的空格（中文空格、英文空格都会被替换） msg = msg.replace(/[\r\n]/g,""); //去掉所有的换行符 return msg.substr(0, 100); //获文本文字内容的前100个字符 } else return '' } // 调用示例 var html = "&lt;p&gt;这是一段HTML代码&lt;/p&gt;" setText(html) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c48190b1eadab517976382fefcc9c5/" rel="bookmark">
			lio-sam学习笔记(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 对于lio-sam框架的安装配置。
每一回不同框架的配置真是要了老命了。。。
一、安装依赖 官方github：
GitHub - TixiaoShan/LIO-SAM: LIO-SAM: Tightly-coupled Lidar Inertial Odometry via Smoothing and Mapping
lio-sam主要有两个依赖：ROS和gtsam，两个都踩了大坑。。。
首先我安装成功catkin_make了，但不能roslaunch lio-sam run.launch，运行就报错。
1.ros 因为系统是18.04，安装的melodic，而且之前跑lego-loam的时候，ros没有出现问题。所以我当时直接忽视了readme上面对于ros部分的配置。
然后安装到后面运行时就出现了这个错误：
第一次翻看log的时候没有看全，没有看到前面的ROS pathxxx的内容，然后就一直解决下面的两个process die。结果这个错误一直都不能解决，然后才发现是官方ros中还有三个配置没有安装。
ROS (tested with Kinetic and Melodic. Refer to #206 for Noetic)
sudo apt-get install -y ros-melodic-navigation sudo apt-get install -y ros-melodic-robot-localization sudo apt-get install -y ros-melodic-robot-state-publisher 安装完成后关于ROS部分的报错就没有了，下面开始真正的折磨。
2.gtsam 这个的配置真的是要了命了。。。
我之前安装的是lego-loam的时候的适配版本，是gtsam-4.0.0-alpha2吧。然后运行时报错：
然后在网上找解决方式，当时是说有如下几个解决方式：
第一个，在编译安装gtsam的时候，将SSE关闭：
mkdir build &amp;&amp; cd build
cmake -DGTSAM_BUILD_WITH_MARCH_NATIVE=OFF ..
sudo make install -j8
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c48190b1eadab517976382fefcc9c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ee4fa7ec45b57a1d6301bad1364e17/" rel="bookmark">
			自定义maven依赖，封装常用工具类，供其他项目引入使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景构思1、通用性高2、耦合度低 开始创建项目常用类提取、修改打包、推送到本地maven仓库其他项目引用 背景 有一些在各个项目经常会用到的工具类，每次做项目时都要把这些工具类复制过去，感觉有点麻烦了，就想能不能把这些工具类提取出来封装，打包成jar，要用的时候就不用每次都复制那么多工具类了，只需要拿这一个jar就行。后面发现可以把它们制作成maven依赖，这样也不用拿jar了，直接在pom.xml中引入就行。
构思 接下来我们就需要先想好哪些工具类是适合封装的？
我目前考虑到适合封装的有两点要求：通用性高；耦合度低。
1、通用性高 就是这个类在不同项目中用到，代码都差不多甚至一样，这种通用性就很高，可以考虑提取出来。
2、耦合度低 就是这个类在不同项目中用到，它的依赖性低，独立性高；如果这个类它 import 了很多不同的jar包，并且这些jar包都是需要引入maven依赖的，这种我就觉得不适合提取。就是在这个（自定义maven依赖）项目中，我们要尽可能少的引入第三方依赖。
（以上两点仅我个人看法，考虑不周或有其他补充可以在评论区评论😘）
开始 既然已经确定好哪些类适合封装了，那就开始动手吧！
创建项目 首先我们创建一个maven项目
点击finish后，我们看pom.xml
常用类提取、修改 接下来我们把常用的一些类复制到这个项目，做对应的修改。
比如我自定义的一个异常类：ExceptionVo：它一开始是这样的，用了lombok依赖。
但是我们需要尽可能减少依赖，就不引入lombok了，而是用传统的get、set方法。
或者是每个项目必用的 RedisUtil 工具类，这个类就需要引入 spring-data-redis 依赖，如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;fuhua&lt;/groupId&gt; &lt;artifactId&gt;fuhua-util&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 这个它一开始是用 @Component 注解的组件，拿过来后不用这个注解，而是在使用的时候，在 @Configuration 注解的类中，手动配置 RedisUtil bean。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73ee4fa7ec45b57a1d6301bad1364e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bba98a50732102badf841f5437e094f/" rel="bookmark">
			java：获取excel文件表头数据和列表数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：导入的文件存放到单独的一张文件表种，其他表存文件表id
//一、根据fileid查询文件获取文件流
InputStream inputStream = null;
try {
inputStream = sysFileCoreFeignClient.download(fileId).body().asInputStream();
} catch (IOException e) {
e.printStackTrace();
throw new BusinessException(“获取文件流失败!”);
}
//二、读取excel文件内容
//1.获取工作薄
Workbook workbook = null;
try {
workbook = WorkbookFactory.create(inputStream);
} catch (IOException | InvalidFormatException e) {
e.printStackTrace();
throw new BusinessException(“读取excel文件内容失败!”);
}
// 2.获取sheet页
Sheet sheet = workbook.getSheetAt(0);
//2.1.从0开始；获取sheet页第一行（即表头行）
Row Row = sheet.getRow(0);
//从0开始；getCell(0)表示第一列
String head1 = Row.getCell(0).getStringCellValue()
//2.2.循环文件行，从1开始（即表格数据）
for (int rowNum = 1; rowNum &lt;= sheet.getLastRowNum(); rowNum++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bba98a50732102badf841f5437e094f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91960be8d22c6356619b2c0db5b6039/" rel="bookmark">
			python数据分析-微积分基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，在这个信息化时代，数据分析在各领域中发挥着越来越重要的作用。大家使用大数据技术从海量数据中挖掘信息，发现规律，探索潜在价值。在大数据的研究和应用中，数学是坚实的理论基础。在数据预处理、分析与建模、模型评价与优化等过程中，数学方法扮演着至关重要的角色。
所以接下来，我们用python语言去实现微积分的一些基础计算等。常用第三方SymPy库来实现微积分计算。
SymPy的全称为Symbolic Python，是由纯Python语言编写的一个用于符号运算的库，能够与其他科学计算库相结合。符号化的计算采用的是数学对象符号化的计算方式，使用数学对象的精确标识，而不是近似的，计算结果可以为一个数学表达式。它的目标在于成为一个富有特色的计算机代数系统，同时保证自身的代码尽可能简单，且易于理解，容易扩展。
目录
一、求一元二次方程
二、集合的运算
三、 数列的极限
四、 求导数
五、 复合函数求导法则
六、 微分的近似运算
七、 微分中值
八、不定积分
九、定积分
一、求一元二次方程 使用solve(f, *symbols, **flags)
from sympy import *#导入SymPy库 x = symbols('x')#将x定义为符号变量 #通过SymPy库的solve()命令求得一元二次方程的两个根 x = solve(x**2-5*x+6,x) print('一元二次方程的两个根：',x) 输出结果：
一元二次方程的两个根：[2, 3] 二、集合的运算 A = set('12345')#定义集合A B = set('234')#定义集合B print('集合A和集合B的并：',A|B) print('集合A和集合B的交：',A&amp;B) print('集合A和集合B的差：',A-B) 输出结果：
集合A和集合B的并：{'3', '4', '5', '2', '1'} 集合A和集合B的交： {'2', '3', '4'} 集合A和集合B的差：{'1', '5'} 三、 数列的极限 计算数列的极限，可以使用SymPy库的limit函数实现。语法格式如下：
sympy.limit(e,z,z0,dir='+') #e：接受SymPy表达式，表示需要进行求极限的数列的一般项或函数。无默认值 #z:接受SymPy表达式，表示需要进行极限的数列的项或函数的目标值。无默认值 #z0:接受any expression,包含所有类型的数值、∞和-∞等，表示自变量趋于有限值或趋于无穷大，其中∞表示无穷大。无默认值 #dir:接受+或-。取值+时，表示趋于有限值的右极限（z→z0+）；取值-时，表示趋于有限值的左极限（z→z0-）。对于无穷大的z0(∞或-∞)，dir参数无效。默认为+ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91960be8d22c6356619b2c0db5b6039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef715054060b32497b1102a33ca2e45/" rel="bookmark">
			ubuntu 16.04 谷歌浏览器google-chrome-stable : Depends: libu2f-udev but it is not installable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$ sudo apt-get install google-chrome-stable Reading package lists... Done
Building dependency tree Reading state information... Done
Some packages could not be installed. This may mean that you have
requested an impossible situation or if you are using the unstable
distribution that some required packages have not yet been created
or been moved out of Incoming.
The following information may help to resolve the situation:
The following packages have unmet dependencies:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef715054060b32497b1102a33ca2e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024fe070eb27c07ec45a04e02c62a263/" rel="bookmark">
			C&#43;&#43; 命令模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是命令模式？ 将请求转换为一个包含与请求相关的所有信息的独立对象。从而使你可以用不同的请求方法进行参数化，并且能够对请求进行排队、记录请求日志以及撤销请求操作。命令模式属于行为设计模式 如何理解命令模式 命令模式很像我们订外卖（淘宝），用户下单，订单中包裹了商户的信息及订餐数量，外卖平台作为接收者将订单再通知到商户，商户执行操作。
命令模式的步骤 源自ChatGpt的总结 定义一个 Command 抽象类，它声明了一个抽象的 execute() 方法，该方法用于执行命令。创建一个实现了 Command 抽象类的实体类，该类实现了 execute() 方法，用于执行具体的命令。创建一个 Invoker 类，该类持有 Command 类的一个实例，并调用实例的 execute() 方法来实现命令的调用。创建客户端，在客户端中创建一个具体的 Command 对象，并设置它的接收者。创建 Invoker 对象，并将创建的 Command 对象设置到 Invoker 对象中。调用 Invoker 对象的 execute() 方法来执行命令。 代码描述 我们这里用户头像为例子
首先需要接口类 /*通用命令*/ class Command { public: virtual ~Command() {} virtual void Execute() const = 0; }; /*通用处理人*/ class Receiver { public: virtual void DoFuncA(const int a) = 0; virtual void DoFuncB(const int b) = 0; }; 创建具体命令 /*实例化一个厨师类的处理人*/ class CookReceiver : public Receiver { public: explicit CookReceiver(const std::string&amp; cook_name) : cook_name_(cook_name) {} void DoFuncA(const int a) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024fe070eb27c07ec45a04e02c62a263/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ab5af9c442c2dd6f797f1f123716fe/" rel="bookmark">
			纯JS前端分页组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个自己写的前端分页组件
使用方法 ① 引入css `你的目录/my-page-v1.0/MyPage.css`
② 引入js `你的目录/my-page-v1.0/MyPage.js`
引入后如图
如何使用
1 页面定义一个div,并加上id属性
2 在script中这样调用
&lt;script&gt; window.onload = function (){ new MyPage({ id: 'page', //ID page: { index: 18, //当前页 total: 88754, //总数据条数 limit: 10 // 每页显示条数 }, view:{ // 视图按钮文本(可选), 支持html元素 可以不配置 prev: '上一页', next: '下一页', first: '首页', last: '尾页' }, callback:{ toPage(index, limit) { //跳转的当前页,每页显示条数 //核心方法, 需要重写, 每次点跳页都会调用该方法, 该方法会返回新的总数据条数,然后重新渲染 // 例: // 请求服务器 // 得到请求结果 // 返回请求结果总条数即可 return 261; } } }) } &lt;/script&gt; 预览
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ab5af9c442c2dd6f797f1f123716fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bfa6b6faab66fd2d6584c7099a18f6/" rel="bookmark">
			再次输入密码校验函数，判断两次密码输入是否一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 校验函数如下：
var validatePass = (rule，value，callback) =&gt; { if (value ){ callback(new Error('请输入密码')); }else { if (this.ruleForm.checkPass !== ){ this.$refs.ruleForm.validateField('checkPass'); } callback(); } }; var validatePass2 = (rule，value， callback) =&gt; if (value === '){ callback(new Error( 请再次输入密码')); else if (value !== this.ruleForm.pass) { callback(new Error('两次输入密码不一致!)); }else{ callback(); } }; rules:{ pass:[ { validator: validatePass,trigger:'blur'} ] checkPass:[ { validator: validatePass2，trigger:'blur'} ] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a7890a29a6d01a0b50d31c8d65fbf1/" rel="bookmark">
			vue中两个或多个input输入框必填一个原来可以这样实现！（输入框二选一必填校验函数&#43;英文数字/中文数字正则）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：1.两个输入框至少填一个；2.一个只能输入英文和数字，另一个只能输入中文和数字。 接下来我们分三步来实现：
第一步：定义校验函数（因为有两个输入框，所以这里两个输入框的校验函数） var validateNameZh = (rule, value, callback) =&gt; { if (this.makeBrandFrom.nameEn == '' &amp;&amp; value == '') { callback(new Error('中文名英文名必填一个')) } else { callback() } }; var validateNameEn = (rule, value, callback) =&gt; { if (this.makeBrandFrom.nameZh == '' &amp;&amp; value == '') { callback(new Error('中文名英文名必填一个')) } else { callback() } }; 这里我们需要注意一下书写位置（放在data里面）
第二步：把我们的校验函数添加到校验规则里面and把输入时的正则也写好 rules: { nameZh: [{ pattern: /[\u4e00-\u9fa50-9]/, message: '只能输入中文或数字', trigger: 'blur' }, { validator: validateNameZh, trigger: 'blur' }, ], nameEn: [{ pattern: /[a-zA-Z0-9]/, message: '请输入英文或数字', trigger: 'blur' }, { validator: validateNameEn, trigger: 'blur' }, ], } 注意：路由规则也是写在data里面，并且需要与你的表单进行绑定哦！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a7890a29a6d01a0b50d31c8d65fbf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ae9558ba2a1381b03a788b10f73b8c3/" rel="bookmark">
			C语言打印输出字符串的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路分析
知识点补充
1，在C语言中，一维数组的数组名实际上就是指向数组首项元素的指针。
2，如果指针p已经指向一个字符串，判断字符串是否结束，一般采用while(*p!='\0')的办法。
以打印输出arr[30]="hello world";为例进行讲解。
我们用3种方法打印输出字符串
第1种：直接按整体打印输出整个字符串。
第2种：使用指针按整体打印输出整个字符串。
第3种：使用指针按单个字符打印输出整个字符串。
第4种：使用string.h头文件的知识点整体打印输出整个字符串。
第1种方法代码如下:
#include &lt;stdio.h&gt; void main(){ char arr[30]="hello world"; printf("%s",arr); } 第1种方法代码运行结果如下:
第2种方法代码如下:
#include &lt;stdio.h&gt; void main(){ char arr[30]="hello world";//初始化字符串 char *p;//定义一个指针p p=arr;//字符串的地址赋给p printf("%s",p); } 第2种方法代码运行结果如下：
第3种方法代码如下：
#include &lt;stdio.h&gt; void main(){ char arr[30]="hello world";//初始化字符串 char *p;//定义一个指针p p=arr;//字符串的地址赋给p while(*p!='\0'){ printf("%c",*p++);//按单个字符打印输出整个字符串。 } } 第3种方法代码运行结果如下:
第4种方法代码如下：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; void main( ){ char arr[30];//定义一个字符串数组 printf("请输入一个字符串\n"); gets(arr);//从键盘中输入字符串，给字符串数组赋值 printf("打印输出字符串\n"); puts(arr);//整体打印输出字符串数组 } 第4种方法代码运行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a4c73e9db4058e50d4310898fc0a5a/" rel="bookmark">
			C#与SQl数据的对应关系（tinyint、smallint、int、bigint）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中对应的说明
SQL C#
bigint（sql大小:8byte) long(64位)
int, integer（sql大小:4byte) int(32位)
smallint（sql大小:2byte） short(16位)
tinyint（sql大小:1byte) byte(8位)
注意：
使用整数数据的精确数字数据类型。
bigint
从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。
int
从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。
smallint
从 -2^15 (-32,768) 到 2^15 - 1 (32,767) 的整型数据。存储大小为 2 个字节。
tinyint
从 0 到 255 的整型数据。存储大小为 1 字节。
注释
在支持整数值的地方支持 bigint 数据类型。但是，bigint 用于某些特殊的情况，当整数值超过 int 数据类型支持的范围时，就可以采用 bigint。在 SQL Server 中，int 数据类型是主要的整数数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a4c73e9db4058e50d4310898fc0a5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717aafa3de137dbb880377d936833989/" rel="bookmark">
			Vue 父组件传值子组件无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 背景：
在父组件mounted钩子中，获取接口数据。然后，通过props 传递给子组件。
问题描述 遇到的问题：
子组件mounted接收数据无效。
原因分析： 分析：
在父组件获取api数据以后，传递给子组件，由于发起的请求是个异步函数，不能保证子组件挂载时数据获取完成。
解决方案： 方案：使用v-if保证在子组件挂载完成后，数据可以获取到。v-if=“传递的数据是否存在”
&lt;pagination v-if="alllist.length!==0" @GetList="GetList" :list='alllist' /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334fbdb9a354bbd7694b6df70f0c0c91/" rel="bookmark">
			jinjia2模板，循环中的全局变量使用，避坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，项目中用python实现一个自动化生成API文档的功能，再自动生成请求示例的时候卡主了，主要原因还是因为jinjia2框架使用不熟悉，折腾了半天，最后stackflow上面找到了答案
问题： jinjia2循环中需要设置全局变量，用传统的编程语法去实现，如下：
&lt;% set temp1 = 0 %&gt; {% for item in api.reqs %} ... {% set tmp1 = temp1 + 1%} # 这个时候始终为1 {% endfor %} {{temp1}} # 这个时候始值为1 循环外定义一个全局变量，循环内修改后无效，猜想：可能是每一次循环后，内存清空了，temp1始终=0
解决： 采用jinjia2里面的“空间”对象来赋值以及修改值
&lt;% set temp1 = namespace(t1=0,t2=1) %&gt; {% for item in api.reqs %} ... {% set temp1.t1 = temp1.t1 + 1%} {% set temp1.t2 = temp1.t2 + 1%} {% endfor %} {{temp1.t1}} # 这个时候会累加值 {{temp1.t1}} # 这个时候会累加值 主要还是不熟悉，并且这个语法有点坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0539c384e2911a7db426ae0f6361f191/" rel="bookmark">
			Pycharm中安装ros2中的包rclpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu系统中的pycharm中目前集成的ros2相关第三方库不多，需要进行配置，以下为配置方法：
1. 首先确保ubuntu系统中已经安装ROS2
2. Pycahrm中配置rclpy包
2.1 进入pycahrm中的设置settings
2.2 进入项目解释器-&gt;下拉选择python解释器-&gt;选择show All，点击进入
2.3 点击1指向的图标，跳转小界面，点击其中的+号 ，添加/opt/ros/foxy/lib/python3.8/site-packages,这个路径包含rclpy的安装路径，点击site-packages可以找到rclpy包，至此可以添加成功路径
如果安装在其他路径，也是相同的方法找到对应的包安装路径进行添加，其他的包类似操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc184b15b169c57572d45d7595288b9/" rel="bookmark">
			物流行业有什么重要的指标，如何进行数据分析？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据是信息时代的典型特征，即通过收集、输入、储存、管理、分析对传统数据进行整合，在互联网的发展中其重要作用。目前大数据已经应用在很多领域中，并影响着各行各业，也有越来越多的行业开始关注大数据，例如“菜鸟网络”的建设就是阿里巴巴公司旗下物流行业应用大数据的典型案例，通过在电商平台和消费者共同进行商品时间的预算和运输，这就需要大数据的计算和支持。
那么物流行业究竟如何如大数据联系起来？有哪些重要的数据指标？如何利用数据分析提升效能呢？小亿今天想和大家聊聊这些问题。
一、物流行业与数据指标
数据也称观测值，是实验、测量、观察、调查等的结果，常以数量的形式给出。现代物流系统是一个庞大复杂的系统，包括运输、仓储、 配送、搬运、包装和再加工等诸多环节，每个环节信息流量十分巨大，产生了巨大的数据流。对物流数据加以分析能够帮助物流企业及时、准确地收集和分析客户、市场、销售及整个企业内部的各种信息，对客户的行为及市场趋势进行有效的分析，了解客户各自的偏好，了解企业内部物流问题的关键所在，从而在提高服务质量和物流效率的同时，降低企业物流成本，这就是物流行业的数据指标的意义所在。
物流行业的常见数据指标，大致有收货数据，储存数据，挑选数据，发货数据，退货数据这5类。
1、收货指标数据
收货数据，包括到货量，订单数，车辆的装载量，收货区域大小，收货作业时间，每天收货SKU数等。
车辆的装载量和卸载时间主要对于站台设计有影响，包括车辆大小、载重量等。一般情况下，还要分析卸货的方式、速度，以便详细规划站台的数量。
收货一般是比较简单的，但也有比较复杂的情形，比如新华书店图书的收货即是如此。因为每天到货的品种很多，还有大量混包的情形，因此收货要进行专门的处理。有些电商的收货也比较复杂，包括要进行QC等动作，对收货区的要求就不一样。
2、储存指标数据
货物储存是一个十分重要的运输过程，库存能力对系统的设计非常重要，但如何确定库存是非常有讲究的。除了库存总量W以外，还要考虑SKU数，以及各种存储方式下的库存要求等。
很多情况下，仓库的设计并非是单一的。所以，设计的时候就要清楚库存的方式是什么，有什么要求。
一般的储存形式分为2种主要方式：以托盘为单位储存（分为立体库和平面库两种最基本形式）和以箱为单位储存。
当然还有其它形式，如包裹、麻袋、散料等，也有条状物（如钢材），异形物品（如服装的挂装等）等。在设计中，这两种方式都要考虑，有时以托盘为主，有时以箱储存为主，有时两者比较均衡。
3、挑选指标数据
挑选分拣数据，包括挑选的订单数，订单行数，发货量，整盘出库量，整件出库量，拆零出库量是比较重要的。
在挑选管理货物的时候，物流行业有一个非常重要的ABC分类法，根据货品的重要程度把货品归为A、B、C三类，进行分别管理：
A类货品：品种比例在10%左右，占比很小；但年消耗的金额比例约为70%，比重较大，是关键的少数，需要重点管理。
B类货品：品种比例在20%左右；年消耗的金额比例约为20%，品种比例与金额比例基本持平，常规管理即可。
C类货品：品种比例在70%左右，占比很大；但年消耗的金额比例在10%上下，此类物品数量多，占用了大量管理成本，但年消耗的金额很小，只需一般管理即可。
在管理仓库的时候，拿出主要精力处理主要事情，不是说不去管理B类、C类的货品。
在B类、C类货品中也有相对重要和次要的货品，可以循环使用ABC分类法进行分类管理，有利于减少库存，节约管理费用，从而降低管理成本。
拣选环节设计关注的主要是拣选、包装和输送问题，因此，有关拣选的细节问题就非常重要。如整盘出库量、整件出库量和拆零出库量，这三个参数对于设计也是非常重要的。
4、发货指标数据
在发货阶段，发货路向、数量、车辆形式、作业时间、暂存时间等数据是发货设计阶段的基础。分拣机的格口不可能无限增加。
因此，设计中应考虑波次问题，以便控制格口数量。
有些物流中心的发货区设计很小，站台停车位很少，给发货造成很大困难。集货区的大小与发货波次有关。很多小的物流中心，每天只安排一次发货，其发货区就要大一些。
对一个大型的物流中心来说，一般要按照多个大波次组织发货，每个大波次还有若干小波次，由此可以大幅度降低对集货区的需求。这在设计中是要注意的，随着大家对物流认识越来越深刻，发货装车环节越来越受到重视。因此，设计中也要与时俱进，考虑自动化系统对发货区的影响。
5、退货指标数据
退货数据不是均衡的，有很大的波动性，相关的数据有订单数，SKU。
在数据分析中（实际作业也是如此），要将退货收货与退货处理分开来。其作业时间和作业量都会不一样，对退货来说，其作业流程对于设计会产生影响。一般数据分析仅仅提供退货量即可，包括订单数、订单行、SKU、数量等。
二、数据分析与物流行业
数据分析是指用适当的统计方法对收集来的大量第一手资料和第二手资料进行分析，以求最大化地开发数据资料的功能，发挥数据的作用。是为了提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。而具体到物流行业则是因为物流的覆盖范围很大，从物料计划、采购、仓库、生产计划、配送中心和进出口，都是数据密集的部门，都需要对数据进行汇总分析并对运作进行安排的关键部门。总的来说，物流行业的数据分析有以下4个环节：
1、采购环节
采购是物流中不可忽视的重要环节之一，原材料的获取是企业生产的基础，一个好的全面的采购分析对于领导制定下一步采购策略是至关重要的。而在这里遇到的问题是，如何在如此庞大的供应商中选择适合企业自己的，如何把握好供应商的产品质量，以及业务员绩效如何评价等等问题。对采购环节的数据分析可实现供应商信用评价、业务员绩效考核等决策分析, 帮助企业为后续生产、销售等环节的顺 利进行打下坚实的基础, 为最终产品在质量和成本上的定位提供科学的依据。
基于以上的问题，在采购环节的数据分析具体步骤如下：
首先是在采购价格上进行数据分析，分析价格波动规律，以及寻找出可能的商机。对采购商进行供应信用等级分析,从交付 日期、质量、数据和价格等方面评估供应商的表现。这些数据可以从企业的财务，库存等部门获得。对物品延迟交货情况进行分析，对可能影响整个供应链的因素进行抑制，防止造成更大的损失。对采购项目中某种物料下一时期的需求进 行分析，依据物料长期以来的采购情况，找出规律，进行预测，从而帮助相关决策者作出正确的决策。采购成本差异分析，找出其中采购成本波动的原因，是因为质量问题，还是因为交通运输等问题造成的成本差异，从而从根本上解决采购成本波动的问题。
2、销售环节
数据分析在销售环节应用的非常多，在现代企业的战略宝典中，提高销售利润总是重中之中。现代物流中，已由传统中推式生产转为拉式生产，如何把握客户不断变化的需求，更好的满足顾客需求已经成为每个企业必要思考的问题。销售处于供应链的最下游，也就是最能得到顾客需求信息的环节，决策者如何准确、及时捕捉到销售信息，分析销售情况,随时根据历史的销售情况,对下一步的生产经营科学地进行决策，成为企业是否能领先于竞争对手，保持企业生命活力的重要环节。
销售分析需要的基础数据主要来源于销售、库存、财务和人事等。对于零售物流等，大部分来源于POS终端系统所反映出来的信息情况。但实际中，由于销售数据分析也是最烦琐的一块，利用率也常常不及 20%，如何能更好的利用这些有用的数据，成为我们研究的对象。专职销售的企业数据分析：如超市，连锁店等。在销售商品数据中，哪些商品具有相关性，比如某些客户 在买了牙膏之后都会买牙刷。这是比较显性的相关，也有些是不明显的相关，比如某些客户购买了卫生纸产品后也会购买啤酒，这个就需要分析人员对其调查分析，这样就可以更好的帮助企业提供更好的服务，也可以更好的进行促销等活动。
在大量的销售数据中，找到那些贡献值最大的数据，也就是常说的“二八”原则，20%的产品，销售额却占到总销售的 80%以上，对这一类产品需要重点关注。对某类商品的特殊销售情况进行分析，在销售数据中，可能发现某类商品销售走向发生重大变化，对该类商品给予关注，找出原因，更好的进行采购。对滞销商品进行统计分析，找出哪些商品滞销，为什么滞销，有什么好的方法处理这些滞销商品等等。这些销售数据都可以进行分析，以便更好的实行CRM（客户关系管理）。多角度分析销售成绩，根据销售数量，销售金额，或者是为某新产品打开市场等等角度来对销售员进行销售数据分析，并据此展开绩效管理工作。
3、运输环节
运输起着消除物流生产地与消费地之间空间错位的作用，运输在物流中通常占有大量成本，并且难以控制，给企业带来了不小的风险，如何更好的改善运输状况，是物流企业中考虑最多的问题。建立智能交通系统，通过 GPS与 GIS等先进的物流信息技术，对整个运输情况进行跟踪处理，防止运输过程中可能遇到的各种问题。同时通过GPS通信导航，可以为车辆提供及时的路面信息与道路状况，为其选择最佳路线与实时导航，也可以对公司内部所有车辆的运营数据，如GPS定位跟踪数据、车辆的行驶时间、行驶距离、完成的吨公里数进行分析，以其发现内在的规律，从而更有效地进行企业的物流运输规划。
4、财务环节
对物流企业财务环节进行数据分析，可以满足企业领导对各业务部门费用支出情况查询的要求, 并实现了对应收款、应付款的决策分析，综合改善企业的财务运行状况。对物流企业财务环节进行数据分析，还包括分析各种材料成本在产品总成本中所占的比重，分析其与实际生产情况是否相符，存在什么样的差距以及产生这种差距的原因，从而发现采购活动中可能存在的漏洞。对物流企业各部门的财务数据进行分析，发现其可能存在的坏账，以及不正常金额出入情况，发现企业的不正常运作，为管理者更好的管理下面分属企业提供决策支持。
物流企业财务环节数据分析，不应仅局限于本公司内部，还应该扩展到客户与供应商甚至整条供应链上的各节点的财务数据。如对客户财务交易情况进行数据分析，比如客户的 欠款时间，欠款次数，金额等等，以此为依据建立客户信用等级，为客户管理提供参考数据。 对供应商的财务交易数据进行分析，甚至对其采购情况、收支情况以及财务健康情况进行数据分析，从而更好的选择财务稳健、信誉良好的供应商，从而提高企业自身的竞争力。
三、物流行业常用数据分析工具
1、EXCEL
EXCEL电子表格软件是一个看起来比较直观的工具，物流也是一个以直观的实物流动为基础的部门，但它们的结合并不是直观，因为EXCEL电子表格软件是物流引起的信息流的表现载体，必须以一定的逻辑顺序来进行组织安排，才能正确又高效进行物流供应链数据处理工作。
在日常的数据处理中，常用的 EXCEL电子表格软件函数有 VLOOKUP、RIGHT、LEFT、MID、SUMIF、INDEX、 MATCH 等。另外，通过对EXCEL电子表格软件功能的深度挖掘，如 VBA(Visual Basic For Applications)发挥EXCEL电子表格软件的更深的应用，解决数据统计分析中的各种难题，能大大提高办公效率。 总的来说，EXCEL 电子表格软件是一个集数据表、工作函数、VBA 应用程序和强大的报表处理于一身的强大工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc184b15b169c57572d45d7595288b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9510c27ca451750a4959e483879ecb3/" rel="bookmark">
			Vue3自定义指令实现拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3使用自定义指令实现拖拽记录
贴代码记录一下
// 拖拽的指令 const drag = { beforeMount(el, binding) { // 自定义属性，判断是否可拖拽 if (!binding.value) return const dialogHeaderEl = el.querySelector('.dialog_header') const dragDom = el.querySelector('.dialog_content') dialogHeaderEl.style.cssText += ';cursor:move;' const sty = (function () { return (dom, attr) =&gt; getComputedStyle(dom, null)[attr] })() dialogHeaderEl.onmousedown = (e) =&gt; { // 鼠标按下，计算当前元素距离可视区的距离 const disX = e.clientX - dialogHeaderEl.offsetLeft const disY = e.clientY - dialogHeaderEl.offsetTop const screenWidth = document.body.clientWidth // body当前宽度 const screenHeight = document.documentElement.clientHeight // 可见区域高度(应为body高度，可某些环境下无法获取) const dragDomWidth = dragDom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9510c27ca451750a4959e483879ecb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2977d019b05699f48c735ec65ccf81b7/" rel="bookmark">
			[MGeo应用]使用Python&#43;AI模型准确拆分Excel中地址的省市区街道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Geo地址匠（转载请注明出处）
在处理人员登记信息或者收货地址管理时，常常需要把地址里的省市区镇拆分出来方便后续分类管理。
例如对于地址“上海市静安区乌鲁木齐中路12号”，单独拆分出“上海市/静安区”。
目前一些基于规则的方法无法覆盖到所有情况，比如：
通过“xx省”“xx市”后缀来找省市区的，当缺少该后缀便无法工作。例如：上海静安华山医院，按照后缀是找不到上海和静安的。通过字符长度来切割的，例如设置省的长度为3，当遇到长度不同的省市区名称变会出错。例如：内蒙古自治区，按照长度切割，内蒙古会被识别为省，自治区会被识别为市。 我们开源了一个地址AI预训练底座以及一系列下游应用模型MGeo（ModelScope 魔搭社区），可以用来识别地址里面的省市区。
首先需要安装python3.7的环境，没有anaconda的可以直接下载安装python3.7：
conda create -n py37testmaas python=3.7 conda activate py37testmaas 安装相关依赖：
cpu机器：pip install cryptography==3.4.8 tensorflow==1.15.5 torch==1.11.0 torchvision==0.12.0 torchaudio==0.11.0 openpyxl gpu机器：pip install cryptography==3.4.8 tensorflow-gpu==1.15.5 torch==1.11.0 torchvision==0.12.0 torchaudio==0.11.0 openpyxl 安装modelscope：
pip install "modelscope[nlp]" -f https://modelscope.oss-cn-beijing.aliyuncs.com/releases/repo.html 确认下modelscope版本大于等于1.2.0：
pip freeze | grep modelscope 测试下模型是否可用：
from modelscope.pipelines import pipeline from modelscope.utils.constant import Tasks task = Tasks.token_classification model = 'damo/mgeo_geographic_elements_tagging_chinese_base' inputs = '浙江省杭州市余杭区阿里巴巴西溪园区' pipeline_ins = pipeline(task=task, model=model) print(pipeline_ins(input=inputs)) #输出 {'output': [{'type': 'prov', 'start': 0, 'end': 3, 'span': '浙江省'}, {'type': 'city', 'start': 3, 'end': 6, 'span': '杭州市'},{'type': 'district', 'start': 6, 'end': 9, 'span': '余杭区'}, {'type': 'poi', 'start': 9, 'end': 17, 'span': '阿里巴巴西溪园区'}]} 可以看到这个模型能将地址里面的省市区街道都拆分出来。剩下的工作便是读取excel内容、识别省市区街道、保存识别结果了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2977d019b05699f48c735ec65ccf81b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180aa888046478b92b7d6584ff719b89/" rel="bookmark">
			audio或video标签 autoplay无效 或 .play()报错问题 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 video标签
video标签设置 autoplay 无效，一般的解决办法是 在video标签上设置 muted 属性 即可。
muted 属性的作用：是否静音
也就是说，想让video标签自动播放视频，必须先设置为静音。原因下面一起说。
audio标签
audio标签设置 autoplay 无效，或者在 js 中用 audio.play() 报以下错误：
而且audio标签 即使设置了 muted 属性也不能自动播放（解决方法最后说）。
原因分析
其实从报错信息也可以了解到，DOMException: play() failed because the user didn't interact with the document first 意思就是说：调用audio.play()方法之前，用户必须先和页面有交互，否则调用失败。
这也是video标签自动播放视频，为何必须先设置静音的原因。
用户和页面之间有交互：其实就是指 用户与页面要发生了事件，才算有交互。比如 鼠标事件（单击 onclick，双击 ondblclick，按下 onmousedown，松开 onmouseup，右击 oncontextmenu 等），键盘事件（按下 onkeydown，松开 onkeyup 等）等。
注意：onmouseenter，onmouseleave，onmouseover，onmouseout 等某些事件，并不算用户与页面发生了交互。比如说，你想在onmouseenter事件发生的回调函数中，执行 audio.play() 也是会报错的，因为谷歌浏览器认为这不算有交互。
解决方法
明白了原因，其实解决方法就很多了。
打个比方：进入某个页面之后，想在3秒后能 成功调用 audio.play() 播放音频，你可以在3秒内随便单击一下页面的某个地方，这样谷歌浏览器就认为 用户与页面已经有交互了，那么3秒一到，play()方法调用成功，音频就正常播放了。 既然是这样，那么在用户进入页面的时候，只要引导用户先去触发这些事件，问题就解决了。
方法1：进入页面时，可以做个欢迎弹窗之类的，引导用户点击关闭（这样就有交互了），然后就可以 自动播放 音频，或者 自动播放 有声视频。方法2：直接做个播放按钮之类的，引导用户点击之后才调用 音频播放 或 有声视频播放。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cf0586ad40236333a65a4e4ae966a5/" rel="bookmark">
			npm ERR! C:\Program Files\Git\cmd\git.EXE ls-remote -h -t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装依赖时遇到以下问题，有可能是node或者npm版本高了，记录一下：
先是出现
npm ERR! code 128 npm ERR! git dep preparation failed npm ERR! command C:\Program Files\nodejs\node.exe C:\Program Files\nodejs\node_modules\npm\bin\npm-cli.js install --force --cache=D:\npm-cache --prefer-offline=false --prefer-online=false --offline=false --no-progress --no-save --no-audit --include=dev --include=peer --include=optional --no-package-lock-only --no-dry-run 然后降低了node和npm版本
node版本：
v14.0.0 npm版本
6.14.10 然后到此报文
npm ERR! Error while executing: npm ERR! C:\Program Files\Git\cmd\git.EXE ls-remote -h -t git://github.com/adobe-webplatform/eve.git npm ERR! npm ERR! fatal: unable to access 'https://github.com/adobe-webplatform/eve.git/': OpenSSL SSL_read: Connection was reset, errno 10054 npm ERR!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60cf0586ad40236333a65a4e4ae966a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b49e81ceddb9ead5573c26349f495a9/" rel="bookmark">
			点击input时，去除边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法 代码展示：
input { border: none; -webkit-box-shadow: none; box-shadow: none; outline: none; } input:focus { border: none; box-shadow: none; } outline样式属性：outline属性表示轮廓具体位置如下图所示（位于经典盒子模型的border和margin之间）： 在默认状态下，对处于focus状态的元素浏览器会通过虚框或者外发光的形式进行区分和提示，这个虚框或者外发光就是浏览默认的outline。这个outline是很有用的，它可以提示用户自己当前聚焦在哪个元素上面，而且在此时按下回车键就相当于点击了这个元素。 2.:focus 伪类选择器：用于选取获得焦点的表单元素，焦点也即是光标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8917d21466273bdd81132d3dd9d5fdc1/" rel="bookmark">
			android aosp源码下载及编译实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载源码各种坑，特此记录一下：
root@lxb-virtual-machine:~/bin# cd ~/bin/aosp
root@lxb-virtual-machine:~/bin/aosp# repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-10.0.0_r17
报错日志1:
repo: reusing existing repo client checkout in /root/bin/aosp
Traceback (most recent call last):
File "/root/bin/aosp/.repo/repo/main.py", line 705, in &lt;module&gt;
_Main(sys.argv[1:])
File "/root/bin/aosp/.repo/repo/main.py", line 681, in _Main
result = repo._Run(name, gopts, argv) or 0
File "/root/bin/aosp/.repo/repo/main.py", line 228, in _Run
result = run()
File "/root/bin/aosp/.repo/repo/main.py", line 219, in &lt;lambda&gt;
run = lambda: self._RunLong(name, gopts, argv) or 0
File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8917d21466273bdd81132d3dd9d5fdc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfcab18d57cd377330279b3eaa4fd92/" rel="bookmark">
			【微积分易错点总结】函数、极限和连续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀write in front🚀
📜所属专栏：
🛰️博客主页：睿睿的博客主页
🛰️代码仓库：🎉VS2022_C语言仓库
🎡您的点赞、关注、收藏、评论，是对我最大的激励和支持！！！
关注我，关注我，关注我，你们将会看到更多的优质内容！！
前言： 今天开始总结微积分易错知识！
一、函数： 1.1反函数： 反函数存在的充要条件是函数f(x)在值域上一一对应，所以如果一个函数f(x)单调且连续，它一定有反函数
1.2初等函数： 基本初等函数有限次+ -* / 和有限次函数的复合运算所得到的函数
二、极限： 2.1极限存在的条件： f(x)在x趋于x0时的极值存在的充要条件是 左右极限存在且相等。所以要求某点极限一定要先看是否存在！
2.2极限的运算法则： 只能运算有限项limf(x)和limg(x)都存在极值时才能通过极值的+ - * / 乘与常数和常数方来简化运算。比如算limx*1/x在x趋于0时的极限。1/x无极限，所以不能这样运算。 2.3.等价无穷小代换的条件： 只适用于分式分子或分母是因子的乘积才能替换0/0型 经典错误： 我们在x趋于0的分式函数中，看到分母或分子出现cosx都会直接当作1，原因是等价替换，cosx~1，而不是分次求极限！不要在其他题目里面弄错！
三、连续： 3.1连续的条件： 在该点有极限(左极限=有极限)在该点有定义极限与函数值相等 闭区间内的连续： 如果函数在(a,b)内连续，并且在左端点右连续(函数在a有定义，且a点的右极限存在并且等于该点的函数值)，在右端点左连续，则称f(x)在闭区间[a,b]上是连续的
3.2连续的运算法则： 重点1： 初等函数在其定义区间都是连续的！
所以只要满足：
趋于的值在函数中有定义函数是初等函数 我们就可以直接将趋于的值代入函数计算！
重点2： 内函数存在极限，外函数在该极限连续，则极限号可以和函数符号换位置！
即：
limf[g(x)]=f[limg(x)]
本章重点证明公式： 1.和差化积： sinx1-sinx2=2*cos[(x1+x2)/2]*sin[(x1-x2)/2] 2.重要不等式： [x]&lt;=x&lt;[x]+1 更新不易，辛苦各位小伙伴们动动小手，👍三连走一走💕💕 ~ ~ ~ 你们真的对我很重要！最后，本文仍有许多不足之处，欢迎各位认真读完文章的小伙伴们随时私信交流、批评指正！
专栏订阅：
每日一题
c语言学习
算法
智力题
更新不易，辛苦各位小伙伴们动动小手，👍三连走一走💕💕 ~ ~ ~ 你们真的对我很重要！最后，本文仍有许多不足之处，欢迎各位认真读完文章的小伙伴们随时私信交流、批评指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86aaf2586d97685074de711984db54d/" rel="bookmark">
			移动机器人多模态自主导航详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
作者丨ROSrookie
来源丨古月居
点击进入—&gt;3D视觉工坊学习交流群
想象我们要去某个地方游玩，你是不是会先在脑海中勾勒出一条路线，然后出发前往这个地方？
人类的导航如此，那对于机器人来讲，该如何实现导航功能呢？
1.机器人自主导航
我们先来理清自主导航的框架，其关键是自主定位和路径规划。针对这两个核心功能，ROS提供了一套完整的框架支持，收到导航目标位置后，机器人只需要发布必要的传感器信息，框架中的功能包即可帮助机器人完成导航。
其中，move_base功能包实现机器人导航中的最优路径规划，amcl实现二维地图中的机器人定位。
为了实现机器人全局最优路径规划与实时避障路径规划，move_base需要订阅机器人发布的深度传感器信息（sensor_msgs/LaserScan或 sensor_msgs/PointCloud）和里程计信息（nav_msgs/Odometry），同时完整的TF坐标变换也是实现路径规划的重要基础。
导航框架最终的输出是控制机器人的速度指令（geometry_msgs/Twist），这就要求机器人控制节点具备解析控制指令中线速度、角速度的能力，并且控制机器人完成相应的运动。
注：
导航框架所包含的功能包很多，可以直接使用如下命令安装：
$ sudo apt-get install ros-melodic-navigation
2.机器人定位
导航功能的顺利进行，离不开机器人的精准定位。自主定位即机器人在任意状态下都可以推算出自己在地图中所处的位置。ROS为开发者提供了一种自适蒙特卡罗定位方法（Adaptive Monte Carlo Localization，amcl），这是一种概率统计方法，针对已有地图使用粒子滤波器跟踪一个机器人的姿态。
给定初始位姿后，AMCL会在机器人周围随机撒一些粒子，随着机器人的运动，每个粒子也会实时跟随机器人的速度更新位姿，当粒子周边的环境状态与机器人差距较大时，就会被逐渐淘汰，反之，则会在机器人周边产生更多粒子。以此类推，粒子都集中在机器人所在位置可能性高的地方，也就是定位的结果。
为了调教以上粒子滤波算法，AMCL功能包中可配置的参数很多，一般初次上手不建议，只需要注意订阅和发布的话题名匹配即可，感兴趣的小伙伴可以在官网（http://wiki.ros.org/amcl）查看各个参数的详细介绍，相关的理论算法请参考《概率机器人》一书。
3.机器人路径规划
机器人知道自己的位置后，如何像人一样根据自己的经验规划出一条路径来呢？move_base功能包就是负责这样的功能，主要由全局路径规划器和本地实时规划器（局部路径规划器）组成。
全局规划就好比我们依靠经验（或地图数据）规划点到点最优路径的过程；局部规划可以理解为去往目的地途中，不断调整机器人姿态、躲避障碍物，以贴合最优路径的过程。
全局路径规划常用Dijkstra算法和A*算法。Dijkstra算法深度优先，往往可以找到全局最优路径，不过搜索时间长、消耗资源多，而A*算法加入了启发函数，虽然不一定可以找到全局最优路径，但搜索时间更快，适合大空间范围的规划。移动机器人大部分是在室内有限范围内使用，两者搜索时间和消耗资源的差距并不明显，一般使用Dijkstra算法即可。
本地实时规划常用Dynamic Window Approaches（DWA）和Time Elastic Band（TEB）算法，两种算法的核心思想如下，具体算法实现大家可以在网上搜索相关的论文。
为了完成以上这些规划器算法的配置，move_base功能包的启动也需要配置不少参数，比如下图所示的这些参数文件：
包含通用配置文件（costmap_common）、全局规划配置文件（global_costmap）、本地规划配置文件（local_costmap）、本地规划器（planer）、路径规划算法（全局base_global_planner和局部base_local_planner）和控制频率（controller_frequency）、规划频率（planner_frequency）等一些参数。这些参数的详细介绍可以去官网（http://wiki.ros.org/move_base）查看。
4.代价地图的配置
人在导航去某个地方的时候可以通过眼睛和经验判断哪里有墙、哪里有水坑、哪里能走和哪里不能走。机器人如何判断呢？
move_base导航使用两种代价地图存储周围环境中的障碍信息：一种用于全局路径规划（global_costmap），一种用于本地实时路径规划（local_costmap）。两种代价地图需要使用一些共用的或独立的配置文件：通用配置文件（costmap_common_params）、全局规划配置文件（global_costmap_params）和本地规划配置文件（local_costmap_params）。
通用配置文件costmap_common_params.yaml的代码和关键参数的含义如下：
注意话题名不要设置错了，footprint也需要根据实际机器人的大小进行设置。
全局规划配置文件global_costmap_params.yaml的代码和关键参数的含义如下：
由于我们这里是已经有地图了，所以将static_map设置true。若我们想使用机器人探索未知的地方并且进行建图的话，则将static_map设置为false。
本地规划配置文件local_costmap_params.yaml的代码和关键参数的含义如下：
其中width、height、resolution参数用于设置代价地图的长（米）、高（米）和分辨率（米/格）。rolling_window参数用来设置在机器人移动过程中是否需要滚动窗口，以保持机器人处于中心位置。
既然导航的各个问题都已经梳理清楚，那么是否真的可以实现导航呢？以及在不同运动模态下，机器人的导航效果又会怎样？接下来我们就用LIMO机器人试一试。
注：关于该机器人运动模态的配置与SLAM，请参考以下内容：
《 细数移动机器人那些常用的运动模态 》
《 如何在移动机器人中部署Gmapping SLAM算法 》
5. 差速移动机器人自主导航
打开机器人的启动文件limo_start.launch，将use_mcnamu设置为false，如下图所示。
局部规划器选用的算法为TEB，由于相关参数比较多，这里就不一一展示和说明，若想了解每个参数，可以前往官网查看相关说明：http://wiki.ros.org/teb_local_planner
下面是一些参数的配置与介绍：
注意，当运动模式为差速运动时，y方向的速度必须设置为0。为了导航效果更好，这里将最小转弯半径（min_turning_radius）设置为0。
注意min_obstacle_dist不要设置的比costmap_common_params.yaml中的膨胀半径小，不然会报错。
然后运行下面的命令，开启导航功能。
$ roslaunch limo_bringup limo_start.launch $ roslaunch limo_bringup limo_navigation_diff.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e86aaf2586d97685074de711984db54d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/103/">«</a>
	<span class="pagination__item pagination__item--current">104/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/105/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>