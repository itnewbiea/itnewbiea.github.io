<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd9e9c8ceab4691226705d7d164c26c/" rel="bookmark">
			Qt调试详细日志文件输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qInstallMessageHandle安装消息，注册回调函数，对qDebug()、qWarning()、qCritial()、qInfo()、qFatal() 等函数输出信息重定向处理。
注明：以下方法仅适用于 Qt5 及以上版本。
目的：生成log.txt日志文件，记录详细日志信息（包括等级、所在文件、所在行号、描述信息、产生时间等）,以便于快速跟踪、定位。那么在qt createor的应用程序输出窗口就不会有调试信息显示。
QtMessageHandler qInstallMessageHandler(QtMessageHandler handler)
qInstallMessageHandler安装写在main()方法中，这样全局所有类的qDebug都可以将信息直接打印到日志文件中（即安装了消息处理）。如果想恢复消息处理程序,调用qInstallMessageHandler(0)。
QtMessageHandler 回调函数处理日志信息，包括等级、所在文件、所在行号、描述信息、产生时间。并保存到本地文件。
其中等级：
qDebug： 调试信息
qWarning：警告信息
qCritical： 严重错误
qFatal： 致命错误
#ifndef LOGGINGOUTPUT_H #define LOGGINGOUTPUT_H #include &lt;QObject&gt; #include &lt;QApplication&gt; #include &lt;QDir&gt; #include &lt;QMutex&gt; #include &lt;QDateTime&gt; #include &lt;QTextStream&gt; #include &lt;QFile&gt; const int LOG_OPERATE_OK = 100; //操作成功 const int LOG_OPENFILE_FAILED = 101; //打开文件失败 class QLogOutput : public QObject { Q_OBJECT public: explicit QLogOutput(QObject *parent = nullptr); //安装信息处理函数 static void install(QString strLogFile); //卸载信息处理函数 static void uninstall(); private: //日志信息处理函数 static void outPutMsg(QtMsgType msgType, const QMessageLogContext &amp;context, const QString &amp;strText); //保存日志 static int SaveLog(const QString &amp;strMsg); //保存日志路径 static QString m_strLogFile; }; #endif // LOGGINGOUTPUT_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cd9e9c8ceab4691226705d7d164c26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12866757cf71d98bf5dfc8848dca5e3d/" rel="bookmark">
			servlet的创建方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.servlet简介 servlet是一个专门用来接收客户端发送过来的请求的小的web程序，servlet的本质是一个类。
这个接口是JAVA官方写的，实现类是我们自己来实现，当然实现servlet的实现类需要一些参数，这些参数是tomcat接收了前端的信息，发送到了servlet（实现流程，前端可以识别xml，所以前端发送给xml，xml发送给tomcat，tomcat解析了xml然后发给了servlet）。
所以可以总结一下xml的功能
1.接收浏览器发送过来的消息
2.给浏览器返回消息，浏览器可以识别html，可以动态去输出html
2.创建servlet 1.实现servlet接口 首先我们得确定一点，所有的编码必须是UTF-8，否则会出现乱码问题。
当然实现一个接口，我们需要重写接口里的方法。我们可以发现接口里面有五个方法
我们先一步一步的来，先只看Service方法
package testWeb; import java.io.IOException; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class FirstServlet implements Servlet{ @Override public void init(ServletConfig config) throws ServletException { // TODO Auto-generated method stub } @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { System.out.println("这是我的第一个servlet"); } @Override public ServletConfig getServletConfig() { // TODO Auto-generated method stub return null; } @Override public String getServletInfo() { // TODO Auto-generated method stub return null; } @Override public void destroy() { // TODO Auto-generated method stub } } 当我们写完service之后，由于我们现在还在学习阶段，所以xml需要我们自己配置，所以我们找到web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12866757cf71d98bf5dfc8848dca5e3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ccdc4dccfd653d938c33f946b6acf4e/" rel="bookmark">
			五、elasticsearch查询操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据准备
1、查询指定字段包含指定内容的文档
2、指定输出的文档字段查询（“_source”）
3、排序查询（默认根据指定字段升序asc排序）（“sort”）
4、分页查询
5、布尔查询（多条件查询）
6、数据过滤(“filter”)
7、精确查询（term）
8、两个类型text和keyword
9、高亮查询（“highlight”）
10、自定义高亮标签
elasticsearch查询操作大致可分为以下几种（这些操作MySQL也可以做，但是在大数据量的情况下有可能会出现效率较慢的情况）而elasticsearch可以说是解决这种问题的灵丹妙药，为查询而生，特别是大数据量的模糊查询
匹配查询 match
按照条件查询 (must、must_not、should)
精确查询 (term)
区间范围查询（filer -&gt;range）
匹配字段查询
多条件查询（布尔查询）
高亮查询 (highlight)
数据准备 使用kibana执行操作，将数据保存在elasticsearch中
PUT /book/_doc/1 { "name":"数据结构", "desc":"基础学习数据结构与算法", "price":15 } PUT /book/_doc/2 { "name":"Java", "desc":"这是一本java基础学习", "price":40 } PUT /book/_doc/3 { "name":"Linux", "desc":"服务器命令操作", "price":35 } PUT /book/_doc/4 { "name":"c语言", "desc":"入门教程", "price":20 } 查看索引详细信息，es帮着我们自动推断并设置了字段类型
在使用kabina时，输入关键字kibina会有提示，点击enter即可帮助我们自动补全API命令，但是注意如果输入了”_doc”则没有了提示
1、查询指定字段包含指定内容的文档 查询文档中name包含数据的文档记录
第一种方式GET book/_doc/_search?q=name：数据 第二种方式 GET book/_doc/_search { "query": { "match":{ "name": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ccdc4dccfd653d938c33f946b6acf4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef121c69ff8de9634f0a93d4c2d42483/" rel="bookmark">
			四、使用Kibana执行elasticsearch的CRUD操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
使用kibana测试
1、创建一个索引
2、创建索引并添加数据
3、获取索引的具体信息
4、通过GET请求_cat查看所有的_cat命令
5、修改数据
5.1、使用PUT修改
5.2、使用POST最后加上_update修改
6、删除文档
7、删除索引
8、查询操作
Rest风格说明
Rest是一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件，它主要用于客户端和服务端交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。
基于Rest命令说明
Method
Url地址
描述
PUT
localhost:9200/索引名称/类型名称/文档id
创建文档（指定文档id）
POST
localhost:9200/索引名称/类型名称
创建文档（随机文档id）
POST
localhost:9200/索引名称/类型名称/文档id/_update
修改文档
DELETE
localhost:9200/索引名称/类型名称/文档id
删除文档
GET
localhost:9200/索引名称/类型名称/文档id
通过文档id查询文档
POST
localhost:9200/索引名称/类型名称/_search
查询所有数据
使用kibana测试 启动elasticsearch服务
启动kibana服务（crud操作elasticsearch）
启动elasticsearch-head插件（查看elasticsearch中的数据）
1、创建一个索引 PUT /索引名
{
请求体
}
示例：
PUT /test { "mappings": { "properties": { "name": { "type": "text" }, "age": { "type": "long" }, "birth": { "type": "date" } } } } 执行完操作后查看elasticsearch可视化界面(elasticsearch-head插件)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef121c69ff8de9634f0a93d4c2d42483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e39d1c872c4c6a9108cf9206616a173/" rel="bookmark">
			一、elasticsearch的简介与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Elasticsearch下载
二、安装
三、启动
四、安装可视化插件（elasticsearch-head）
1、下载地址
2、解压缩下载好的压缩文件
3、进入解压缩目录
五、解决跨域问题
Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用Elasticsearch的水平伸缩性，能使数据在生产环境变得更有价值。
Elasticsearch 的实现原理主要分为以下几个步骤
首先用户将数据提交到Elasticsearch 数据库中再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据当用户搜索数据时候，再根据权重将结果排名，打分再将返回结果呈现给用户。 Elastic Stack（ELK stack）
E---Elasticsearch 数据存储、查询
L---Logstash 数据收集和日志解析引擎
K---Kibana 分析和可视化平台
Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。
Elasticsearch的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elasticsearch是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。
总结起来就是，在大数据量时使用Elasticsearch可以提高搜索效率。
最常见的使用场景就是电商网站搜索商品，或者在日志系统中搜索日志时，或者百度等搜索引擎等等。如果使用传统的关系型数据库进行模糊查询，那么就有可能会出现索引失效的情况，导致执行效率非常的低（数据量大的情况下）
如：select age from user where name like “%航%” Elasticsearch概念（以下简称Elastic ）
关系型数据库
Elasticsearch
数据库（database）
索引index
表（tables）
类型Types（8.x后会弃用）
行（rows）
文档documents
字段（columns）
字段fields
Elastic （集群）中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下可以包含多个文档（行），每个文档中可以包含多个字段（列）文档可以嵌套
1、 Node 与 Cluster
Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。
单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。
2、 Index（相当于MySQL中的Database）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e39d1c872c4c6a9108cf9206616a173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c6284b4122bc53277f20187ec87314/" rel="bookmark">
			今日头条新闻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在entry-&gt;src-&gt;main-&gt;module.json5 文件中添加网络请求权限代码如下
"requestPermissions": [ {"name": "ohos.permission.INTERNET"} ],
Index.ets
import { HomePage } from "../pages/HomePage" import { bottomNavigation, NewsType } from "../data/DataHelper" import { BottomNavigation } from "../model/SystemModel" import { BottomTabs, BottomTabsTwo, TopTabs } from "../component/TabsNavigation" @Entry @Component struct Index { @State message: string = 'Hello World' private controller: TabsController = new TabsController() build() { Flex({ direction: FlexDirection.Column, justifyContent: FlexAlign.Center }) { Row() { Image($r("app.media.qqNews")) .aspectRatio(1) .height(40) Row() { Image($r("app.media.sousuo")) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c6284b4122bc53277f20187ec87314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2556900d58c285a1c24645e591f5de/" rel="bookmark">
			TabContent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Entry @Component struct Index { @State message: string = 'Hello World' @State fontColor: string = '#182431' @State selectedFontColor: string = '#007DFF' @State currentIndex: number = 0 private controller: TabsController = new TabsController() build() { Tabs({ barPosition: BarPosition.Start, controller:this.controller }) { TabContent() { Column().width('100%').height('100%').backgroundColor('#00CB87') }.tabBar(this.TabBuilder(0, 'green')) TabContent() { Column().width('100%').height('100%').backgroundColor('#007DFF') }.tabBar(this.TabBuilder(1, 'blue')) TabContent() { Column().width('100%').height('100%').backgroundColor('#FFBF00') }.tabBar(this.TabBuilder(2, 'yellow')) TabContent() { Column().width('100%').height('100%').backgroundColor('#E67C92') }.tabBar(this.TabBuilder(3, 'pink')) } .vertical(false) //Tabs 方向 false:横向 true:纵向 .barMode(BarMode.Fixed) //布局模式 Fixed:平均分配页签栏宽度或长度 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2556900d58c285a1c24645e591f5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dfdabb63151efe5e837d42a21d6554/" rel="bookmark">
			列表entry-＞src-＞main-＞module.json5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 entry-&gt;src-&gt;main-&gt;module.json5
"requestPermissions": [ {"name": "ohos.permission.INTERNET"} ],
Index.ets
arrayList=[ {"name":"苹果","price":3.5,"imageUrl":"https://img1.baidu.com/it/u=1513650579,1757297287&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1681059600&amp;t=2bdf979a877dd8723c72d7285b140734"}, {"name":"香蕉","price":5.5,"imageUrl":"https://img0.baidu.com/it/u=387808086,3839707072&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1681059600&amp;t=eb4513cd82a1e087c2e5fbb6a887b376"}, ] build() { Column(){ List(){ ForEach(this.arrayList,(item,index)=&gt;{ ListItem(){ Row(){ Image(item.imageUrl) .layoutWeight(1) .height(200) Text(item.name) .fontSize(20) .fontColor(Color.Red) .margin({left:20}) Text(item.price+"/kg") .fontSize(20) .margin({left:20,right:20}) } } }) } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a0080621ddccb1854619b78bb9d2a6/" rel="bookmark">
			关于guacamole项目中的一点感悟与理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于guacamole项目中的一点想法 前言一、guacd模块启动相关二、一些感悟与理解参考 前言 Guacamole 是基于 Web 的 VNC 客户端，使用它可以通过web浏览器访问远程服务器终端并进行操作。它的基本架构如下图所示。
巧合之下，前段时间了解了项目中guacd模块有关的一些内容，重点关注的是这个模块启动过程中涉及网络IO、线程、进程的建立（网络并发模型）等，学习记录在此，希望可以便人便己。
一、guacd模块启动相关 整个guacd模块的启动比较复杂，下面画了一个简要的代码流程图（流程图中主要关注的是网络IO、进程、线程的建立），如下所示。
流程比较复杂，下面根据上图简要介绍下：
guacd所在的main（假设所在进程为P0,线程也是T0）运行之后，会在打开一个监听端口，等待accep（）连接到来；
当有连接到来之时，新建一个线程T1(对应的进程是P1)处理请求；然后T0接着accept；
T1执行guacd_connection_thread（），在这个函数中判断连接请求是不是想加入原有的连接，还是建立新的连接。
//蓝色右边部分：作为第一个进程，加载插件，然后建立工作进程
如果是新建连接，则会新建一个子进程P2；在P2中先通过动态链接的方式加载协议，之后阻塞在guacd_recv_fd（）上，等待父进程P1（建立子进程后父进程P1返回继续执行原来的任务，执行guac_add_user()）发送父子间通信的套接字端口proc_fd （这个proc_fd是用于IO线程和工作线程之间沟通用的）;
若P2接收到了发送的P1proc_fd，会新建一个线程T3；在T3中执行guacd_user_thread. 在guacd_user_thread中是主要建立连接关系的一些操作，然后执行 guac_user_handle_connection（）
在guac_user_handle_connection（）中又新建了一个子线程T4（这算是工作线程）；在T4中正式通过proc_fd和IO线程联系，循环处理客户端的请求。
//红色左边部分：用于为每个请求建立IO线程（一个读线程、一个写线程）
在上述步骤3中，若请求是想加入一个已有的连接，则会跳过建立新进程的步骤；直接执行guacd_add_user（）；
在guacd_add_user（）中会建立一个unix套接字用于父子进程通信，通过guacd_send_fd（）发送给子进程（步骤3中的）
之后会新建io子线程T5，在io子线程中执行guacd_connection_io_thread（）；在guacd_connection_io_thread（）中又会新建一个写线程T6， 用来从网络中读，然后写到客户端（即工作线程）；T5线程当做读线程，从客户端（即工作线程）读数据，写入到网络中。
其基本的逻辑有两点需要说明：
1、一个连接可以被多个用户共享（类似于分享屏幕），第一个建立这个连接的用户叫做这个连接的owner，逻辑会走一遍右边建立新进程的过程（需要加载动态库插件）。 后续想加入同一个连接的用户则不需要建立新的进程，只需要由owner所对应的进程建立工作线程即可。
2、每个用户都会为其建立一组IO线程（读线程和写线程）和工作线程。其中前者主要是当做工作线程和网络之间的通信中介，其目的大概是提高整体的IO效率；后者的工作则主要是进行实际的业务处理。其基本关系如下图所示。
二、一些感悟与理解 关于IO线程和工作线程
在guacamole中会为每个用户建立一组IO线程和工作线程。按照我目前所了解的，很多项目，尤其是涉及到网络IO的项目，其IO并发模型中大都会把用户的整个逻辑拆分为IO和实际的业务处理，对应由不同的线程进行处理。有必要吗？
大部分情况下还是有必要的，尤其是对于并发量较大的web业务来说。按照我的理解分离IO线程和业务处理线程好处以下几点：
（1）、一是可以在某种程度情况下，IO线程和业务线程并发处理（甚至可以利用多核的优点达到并行），使得业务线程在处理业务之时不影响IO（客户端的请求和回复），当然这也只是在一定程度上的，如果业务线程一直跟不上，IO线程再快，整体的服务质量也会下降。
（2）、可以使用IO复用的机制，让IO线程同时处理多个连接的IO，或者使用以IO复用为基础的Reactor模式，大大提高系统的并发量。
（3）、IO线程和业务线程解耦，在某些情况下可以方便的进行勘误或者性能调优，这一点我目前还没遇到过。
当然把IO线程和业务线程分离也有一点不好的地方，由于把整个的业务逻辑（IO+具体对数据的处理）进行了拆分，因此在数据传递时会出现线程切换，造成一些性能损耗；在guacd中IO线程和工作线程分属于两个进程，切换的损耗还要更大些。
关于IO复用
在很多现在的项目中都使用了IO复用的机制（epoll、select等），由多个连接共享一个IO线程。但是guacd这里用的就不是IO复用；它是给每个用户建立连接对应的一个IO读写线程和一个工作线程（应该是一个？），这种方式的话并发量可能不是很高，guacd为什么要这么设计呢？
我想了想，大概是由于guacamole面向的大都是视频传输，传输的数据量都比较大，如果使用同一个线程来进行IO，会造成IO线程忙不过来的状况，倒不如使用每个连接一组IO线程的情形。这样说的话，选择什么样的IO并发模型也不是定数，还要根据具体的业务要求来进行判断。
关于建立线程还是建立进程
线程和进程最主要的区别在我来看有两点，这两点分别是二者的优缺点：进程独立而切换慢，线程共享而切换快。在guacd中大部分逻辑都是建立的线程，但是在第一个owner建立连接的时候创建的是进程。
按照我的理解是因为每个owner主管的连接所对应协议不尽相同，所需要加载的插件也不同，如果都是用线程的话，那么只能把所有用到的插件都加载到同一份进程空间中，大家一起共享了。虽然这么说理论说好像也可以，但这样的话占用的进程空间可能也比较了。 同时，所有的线程都放在一个进程中，逻辑上也有点混乱。
关于同步
我们以前学操作系统的时候知道线程、进程同步的一些机制，比如说条件变量、信号量等等。其实从某种程度上来说，使用IO的阻塞操作也可以达到同样的效果，如上图中的owner所在进程在等着父进程发送fd，也算是一种同步操作；再比如说，pthread_join，wait_pid这些等待子线程、子进程退出的操作，也能算作是一种同步手段。
我的理解是，从本质上来说，这些手段底层都需要有共享的一个“东西”（ 可以是阻塞中的fd，可以是信号量中的信号，也可以是条件变量中的变量等等），用来起到一个通知的作用。
关于进程和线程
什么是进程，什么是线程？在linux上线程也是一种进程。那么它们的本质是什么？
是一种执行流。 新建了一个进程或者线程，就相当于开辟了一个新的执行流，让其他的执行流因为暂时阻塞的缘故，cpu可以选择另一个执行流，以此来增加cpu的利用率和系统整体的吞吐量。
一点的不理解
最后，在来谈点不理解的内容吧。
一般来说，根据运行时间长短，线程或者进程可分为两种，一种是长期任务，一种是短期任务；长期任务的生命周期一般由用户的进入与退出（连接的建立与断开、或者整个程序的开始与结束）来决定，一般主逻辑里都会有一个while{} 循环（如上图中的IO线程和工作线程）；而短期的任务一般是临时的任务，执行完就结束了，一般不会有一直运行的循环操作（如上述guacd中的accpet之后建立的T1）；
我不懂的是，为什么在上述流程图中的owner所在进程主管的部分（右半黄色部分），在有用户想要加入已有的连接之后，需要创建两个线程T3、T4；代码中T3新建了T4之后，就一直在那join了（阻塞住了），反正也没用，为什么不直接用T3来当做工作线程处理整个逻辑呢？目前还不是很懂，有了解的小伙伴，可以教教我。
参考 【1】guacamole项目地址
【2】《真象还原》
【3】为什么建议 Netty 的 I/O 线程与业务线程分离
【4】框架篇：见识一下linux高性能网络IO+Reactor模型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e6874da6d027a55525ed235a5c9927/" rel="bookmark">
			Unity学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本操作：（了解概念和何时使用，步骤在需要的时候再去查找） 1.定点吸附：选择物体后按住V键，定位定点，再拖拽到目标物体某个定点上。
2.Clipping Planes：如果项目远处地形资源等无法看见需要调节相机裁剪平面的距离。
3.culling mask：图层可以通过控制剔除遮罩来改变能不能看见该图层。
4.persp：透视观察模式、ISO（正交观察模式）
5.场景：一组相关联的游戏对象的集合，通常游戏中每个关卡就是一个场景，用于展现当前关卡中的所有物体。
6.游戏对象：运行时场景中的游戏物体。一个游戏对象就是一个容器，可以挂载组件。
7.组件：是游戏对象的功能模块，每个组件都是一个类的实例。
8.camera：可以制作小地图和后视镜等功能。
9.材质：物体的质地，指色彩、纹理、光滑度、透明度、反射率、折射率、发光度等，实际是shader的实例。
10.Texture：附加到物体表面的贴图。
11.shader着色器：专门用来渲染图形的技术，可以使纹理以某种方式展现。是一段代码、程序。
12.物理着色器PBS：遵从物理学的能量守恒定律，可以创建不同光照下接近真实的效果。
13.InstantOC：
①Occlusion culling：遮挡剔除，物体被送进渲染流水线之前，将摄像机视角内看不到的物体进行剔除，从而减少每帧渲染数据量，提高渲染性能。 因此在物体被别的物体遮挡的时候，需要用到遮挡剔除。
②LOD（Levels of Detail）：多细节层次，根据物体模型的节点在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的
面熟和细节度。因此在精细模型离相机较远时使用糙模，在近距离时使用细模。近清远模。
14.
15.profiler（Ctrl+F7）：电脑使用性能情况等信息。
16.光照系统：
①Global illumination（全局光照）：能够计算直接光（光源直接发出）、间接光（物体表面发射出的光）、环境光以及反射光的光照系统。
②设置阴影，阴影的渲染消耗性能。包括是否投射阴影及阴影剔除。
③烘焙（Baked）：将光线效果预渲染成贴图再作用到模拟物体，从而提高性能。
17.命名空间（namespace）：命名空间就是类的集合；引用集合中的类时需要在类名中使用所选的前缀。
18.InputMange :定义用户输入（Edit-Project-Settings-Input） bool result = Input.GetButton("虚拟轴名") float value = Input.GetAxisRaw("虚拟轴名") ….. P153
19.关节组件五大类：
①链条关节：将两个物体以链条的形式绑在一起，当力量过大超过链条的固定力矩时，两个物体就会产生相互的拉力。
②固定关节：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也不会发生改变。
③弹簧关节：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的推力，拉伸它们会得到两边对中间的拉力。
④角色关节：可以模拟角色的骨骼关节，可以绕骨骼节点任意角度旋转。
⑤可配置关节：可以模拟任意关节的效果，包括上面的四种效果，最强大也是最复杂的。
20.力场组件：力场是一种为刚体快速添加恒定作用力的方法。
①Force：用于设定在世界坐标系中使用的力，向量表示。
②Relative Force：用于设定在物体局部坐标系中使用的力。
③Torque：设定在世界坐标系中使用的扭矩力，向量表示，对象将依据该向量进行转动，向量越长转动越快。
④Relative Torque：设定在局部坐标系中使用的扭矩力，向量表示，对象将依据该向量进行转动，向量越长，转动越快。
3D数学（向量、欧拉角、四元数、坐标系统） 向量:世界坐标指向物体的射线，用以判断方向 API：向量的模float dis = vector.magnitude、vector.distance(vector3.zeor,dis)；
获取向量方向也称“标准化”“归一化”；
向量的方向Vector3 vector2 = vector1.normalized，verctor2为vector1的单位向量，vector1.normalize()；将vector1自身设置为单位向量；
三角函数：已知一边一角，求其他边与角。 API：Mathf.Sin(float radian)、Mathf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e6874da6d027a55525ed235a5c9927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fad0d4554d75339c78e957c5899f529/" rel="bookmark">
			虚拟机 VMware-Workstation-pro 17 下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机安装 下载安装 VMware-Workstation-pro 17 下载地址：VMware Workstation 17
vmware 文档：VMware Workstation 17 Pro 发行说明
点击安装
点击下一步，勾选后下一步
修改安装目录（根据自己需求修改），点击下一步
取消提升计划，点击下一步
下一步，安装
升级
安装完成后，点击许可证
输入许可证，完成
打开虚拟机
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6477785d5d92c24f87c03f28c62d8e4/" rel="bookmark">
			微服务系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微服务系列 1初步整合ABP模块化 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3967e8f5663f9e8db6dea95d1711421e/" rel="bookmark">
			1初步整合ABP模块化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先创建一个WebApi项目 2 初步整合ABP模块化 Abp官网，这里我们先初步整合WebApi模块化，待程序运行起来，后续文章我们再对Abp进行深入。
2.1 NuGet：包Volo.Abp Volo,Abp：模块化必备
2.2 NuGet：Volo.Abp.AspNetCore Volo.Abp.AspNetCore：装配Web项目DI容器注入必备
2.3 NuGet：Volo.Autofac Volo.Autofac：Abp的DI容器
2.4.创建一个模块化Module类 [DependsOn(typeof(AbpAspNetCoreModule))] public class AdminGatewayModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { // Add services to the container. context.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle context.Services.AddEndpointsApiExplorer(); context.Services.AddSwaggerGen(); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var env = context.GetEnvironment(); var app = context.GetApplicationBuilder(); if (env.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseRouting(); app.UseEndpoints(endpoint =&gt; { endpoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3967e8f5663f9e8db6dea95d1711421e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b49490337031004b8d46c788302bea/" rel="bookmark">
			16行代码采集原神官网角色全图&#43;全语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭！我是小熊猫~ 本来是不玩原神的，
但是实在是经不住诱惑鸭~
毕竟谁能拒绝可以爬树、炸鱼、壶里造房子、抓小动物、躲猫猫的对战游戏捏~
准备工具 准备模块 import requests import re import execjs 请求链接 本次目标 所有角色的：
基础介绍中日语音图片 分析数据来源 1. 右键点击检查（开发者工具）
2.刷新网页，找准对应数据
源码资料电子书:点击此处跳转文末名片获取 开始代码 url = 'https:///main/character/liyue?char=1' html_data = requests.get(url).text print(html_data) 筛选数据
随便搜索网站内包含内容：“南十字”
使用正则表达式匹配数据内容
js_text = re.findall('window.__NUXT__=(.*);', html_data)[0] 执行结果 html_data = requests.get(url).text js_text = re.findall('window.__NUXT__=(.*);', html_data)[0] result = execjs.eval(js_text) 此时会出现编码问题
加指定编码
import subprocess from functools import partial subprocess.Popen = partial(subprocess.Popen, encoding="utf-8") 再次运行，无报错
使用pprint查看数据结构
pprint.pprint(result) 返回网页查看我们需要的内容
打印所需数据
charList = result['data'][0]['charList'] for char in charList: cover1 = char['cover1'] title = char['title'] intro = char['intro'] audio_list = char['cv'][0]['audio'] print(title, intro, cover1, audio_list) 部分效果展示 全部代码 import requests import re import execjs url = 'https://*****/main/character/liyue?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b49490337031004b8d46c788302bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc2e8a863d7304d0b0a5920dbf66552/" rel="bookmark">
			摸鱼也有效率——8个python自动化脚本提高打工人幸福感~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨害大家好鸭！我是小熊猫❤ 最近有许多打工人都找我说打工好难
每天都是执行许多重复的任务，
例如阅读新闻、发邮件、查看天气、打开书签、清理文件夹等等，
使用自动化脚本，就无需手动一次又一次地完成这些任务，
非常方便啊有木有？！
而在某种程度上，Python 就是自动化的代名词。
今天就来和大家一起学习一下，
用8个python自动化脚本提高工作效率~ 快乐摸鱼~
1、自动化阅读网页新闻 这个脚本能够实现从网页中抓取文本，然后自动化语音朗读，当你想听新闻的时候，这是个不错的选择。
代码分为两大部分，第一通过爬虫抓取网页文本呢，第二通过阅读工具来朗读文本。
需要的第三方库：
Beautiful Soup - 经典的HTML/XML文本解析器，用来提取爬下来的网页信息
requests - 好用到逆天的HTTP工具，用来向网页发送请求获取数据
Pyttsx3 - 将文本转换为语音，并控制速率、频率和语音
import pyttsx3 import requests from bs4 import BeautifulSoup voices = engine.getProperty('voices') newVoiceRate = 130 ## Reduce The Speech Rate engine.setProperty('rate',newVoiceRate) engine.setProperty('voice', voices[1].id) def speak(audio): engine.say(audio) engine.runAndWait() text = str(input("Paste article\n")) res = requests.get(text) # python学习裙：660193417# articles = [] for i in range(len(soup.select('.p'))): article = soup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dc2e8a863d7304d0b0a5920dbf66552/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ed0d8af00d1564e22a23b55b729bcd/" rel="bookmark">
			Python 100道基础入门练习题（附答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例001：数字组合 题目
有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？
程序分析 遍历全部可能，把有重复的剃掉。
1 num=0 2 for a in range(1,5): 3 for b in range(1,5): 4 for c in range(1,5): 5 if((a!=b)and(a!=c)and(b!=c)): 6 print(a,b,c) 7 num+=1 8 print (num) 实例002：“个税计算” 题目 企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？
程序分析 分区间计算即可。
1 profit=int(input('Show me the money: ')) 2 bonus=0 3 thresholds=[100000,100000,200000,200000,400000] 4 rates=[0.1,0.075,0.05,0.03,0.015,0.01] 5 for i in range(len(thresholds)): 6 if profit&lt;=thresholds[i]: 7 bonus+=profit*rates[i] 8 profit=0 9 break 10 else: 11 bonus+=thresholds[i]*rates[i] 12 profit-=thresholds[i] 13 bonus+=profit*rates[-1] 14 print(bonus 实例003：完全平方数 题目 一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ed0d8af00d1564e22a23b55b729bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb1e4fdbaa124bac6553f2ccf63ca6a/" rel="bookmark">
			opencv缺陷检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用传统算法，根据实际工程项目，手把手教你做一个最典型的产品缺陷检测项目案例，虽然这个案例与实际生产还存在一定的差距，但是这个检测流程已经很接近实际生产了。
我们先看一下测试结果：
这个检测的主要需求就是，根据视频流中流水线上的产品，通过每一帧图像，检测出每个产品的缺陷属性，并把有缺陷的产品给标注出来，并注明缺陷类型。
在项目开始之前，我们先思考一下整个检测流程的框架：
1，首先我们要抓取视频流中的每一帧图像
2，在抓取得每一张图像中，首先要定位出这张图片中的每一个产品，找出这件产品的边缘
3，分析所抓取每个产品的属性，分析其缺陷类型的特征，通过算法形式来对缺陷进行归类。
上面就是整个检测的基本流程，其实，在利用传统算法进行检测的时候，基本流程不会差别太大，所用算子也基本大致相同。在讲解这个检测方法之前，我先来讲解几个我们经常用到的算子：
findContours()：
这个函数是查找整张图片中所有轮廓的函数，这个函数很重要，在处理图像分割尤其是查找整个图像中边缘分割时候少不了它，所以我重点说明一下，首先它的函数原型是这样的：
// 查找整张图片的所有轮廓findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset=Point()); 我先来讲解一下这个函数的主要参数：
1），image代表输入的图像矩阵；
2），第二个参数contours代表输出的整张图片的所有轮廓，由于轮廓坐标是一组二维坐标构成的一组数据集，因此，它的声明是一个嵌套了一层坐标数据集向量的向量：
//参数contours的声明vector&lt;vector&lt;Point&gt;&gt; contours; 3），第三个参数hierarchy顾名思义，字面的意思是层级关系，它代表各个轮廓的继承关系，也是一个向量，长度和contours相同，每个元素和contours的元素相对应，hierarchy的每一个元素是一个包含四个整形数的向量，也即：​​​​​​​
//参数hierarchy的声明//Vec4i 代表包含四个元素的整形向量vector&lt;Vec4i&gt; hierarchy; 那么这里的hierarchy究竟代表什么意思呢，其实对于一张图片，findContours()查找出所有的 个轮廓后，每个轮廓都会有自己的索引， ，而hierarchy[i]里面的四个元素 分别代表第 个轮廓：后一个轮廓的序号、前一个轮廓的序号、子轮廓的序号、父轮廓的序号，有严格的顺序。
为了更加直观说明，请看下面一张图片：
上面图片中，是一张图片中的所有轮廓，分别用序号0、1、2、3来表示，其中0有两个子轮廓，分别是1和3，而1则有一个父轮廓也有一个子轮廓，分别是0与2，它们的继承关系基本上就是这样，我们再做进一步的分析：
4），第四个参数mode，代表定义轮廓的检索方式：
取值一：CV_RETR_EXTERNAL，只检测最外围轮廓，包含在外围轮廓内的内围轮廓被忽略。
取值二：CV_RETR_LIST，检测所有的轮廓，包括内围、外围轮廓，但是检测到的轮廓不建立等级关系，彼此之间独立，没有等级关系，这就意味着这个检索模式下不存在父轮廓或内嵌轮廓，所以hierarchy向量内所有元素的第3、第4个分量都会被置为-1.
取值三：CV_RETR_CCOMP，检测所有的轮廓，但所有轮廓只建立两个等级关系，外围为顶层，若外围内的内围轮廓还包含了其他的轮廓信息，则内围内的所有轮廓均归属于顶层。
取值四：CV_RETR_TREE，检测所有轮廓，所有轮廓建立一个等级树结构。外层轮廓包含内层轮廓，内层轮廓还可以继续包含内嵌轮廓。
5），第五个参数method，用来定义轮廓的近似方法：
取值一：CV_CHAIN_APPROX_NONE，保存物体边界上所有连续的轮廓点到contours向量内。
取值二：CV_CHAIN_APPROX_SIMPLE，仅保存轮廓的拐点信息，把所有轮廓拐点处的点保存入contours向量内，拐点与拐点之间直线段上的信息点不予保留。
取值三：CV_CHAIN_APPROX_TC89_L1;
取值四：CV_CHAIN_APPROX_TC89_KCOS，取值三与四两者使用teh-Chinl chain 近似算法。
6），第六个参数，Point类型的offset参数，这个参数相当于在每一个检测出的轮廓点上加上该偏移量，而且Point还可以是负数。
在实际使用中，我们需要根据实际情况来选定合适的参数，比如第五个参数，如果你使用CV_CHAIN_APPROX_SIMPLE这个参数，那么返回的坐标向量集是仅包含拐点信息的，为了得到轮廓的完整坐标数据，我必须使用CV_CHAIN_APPROX_NONE参数。请大家在实际使用过程中根据自己的实际情况来选择合适的参数
再来说下moments这个函数，其实moment在物理学中表示“力矩”的感念，“矩”在物理学中是表示距离和物理量乘积的物理量，表示物体的空间分布（至于汉语为什么把它翻译成矩这个字，我也不太明白，不知道是不是李善兰翻译的）。而在数学中，“矩”是概率论中的一个名词，它的本质是数学期望，我们从它的定义中就可以看出：
在opencv中，我们看下这个函数的原型：​​​​​​​
Moments moments( InputArray array, bool binaryImage = false ); 第一个参数是输入一个数组，也就是我们上面计算出来的contours向量，第二个参数默认为false.
我们再来看整个程序的编写方法：
首先我们使用opencv中的VideoCapture类来进行读取视频流，并抓取视频中的每一帧图像：​​​​​​​
Mat img; //定义图像矩阵VideoCapture cap("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb1e4fdbaa124bac6553f2ccf63ca6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8cec06b57d4d61d162ce528bb9b5266/" rel="bookmark">
			MongoDB生产部署方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分片集群三种角色 路由节点——Router Service 提供集群单一入口，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用，router不存储数据。
搭建：可以有多个，理论上只需要使用一个，建议至少2个达到高可用。
功能：转发应用端请求，选择合适数据节点进行读写，合并多个数据节点的返回。
配置节点——Config Server 提供集群元数据存储目录，分片数据分布的映射（哪些数据放在哪个分片集群）
搭建：就是普通的复制集架构，一般1主2从提供高可用。
配置节点中比较重要的就是Shared这张表，里面存储分片中数据的范围。
（路由节点在启动的时候会把配置节点的数据加载到自己的内存当中，方便快的进行数据的比对，完成数据的分发处理）
数据节点（mongod） 以复制集为单位（避免单点故障）
分片之间数据不重复
横向扩展
最大1024分片
所有分片在一起才可完整工作
二、部署步骤 在生产集群中使用6台物理机，确保数据冗余并且您的系统具有高可用性。对于生产分片集群部署：
将配置服务器部署为 3 成员副本集将每个分片部署为 2 个成员的副本集部署3台mongos台路由器 机器
端口
服务
备注
0.0.0.1
7017
router service
路由节点
7019
shard service
主（rs01）
0.0.0.2
7017
router service
路由节点
7019
shard service
主（rs02）
0.0.0.3
7017
router service
路由节点
7019
shard service
主（rs03）
0.0.0.4
7018
config service
配置服务
7019
shard service
从（rs01）
0.0.0.5
7018
config service
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8cec06b57d4d61d162ce528bb9b5266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1df4083941d798da03ed1e64f83062/" rel="bookmark">
			计算机网络5：传输媒体和信道复用(物理层)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、物理层下边的传输媒体 传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类，即导向型传输媒体和非导向型传输媒体。
在导向型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。 （1）导向传输媒体 1）双绞线
双绞线也称为双扭线，是最古老但又是最常用的传输媒体。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。通常将一定数量的这种双绞线捆成电缆，在其外面包上护套。现在的以太网(主流的计算机局域网)基本上也是使用各种类型的双绞线电缆进行连接的。
下图为无屏蔽双绞线实物图：
下图为屏蔽双绞线实物图：
屏蔽双绞线可以减少外部电磁干扰。无屏蔽双绞线和屏蔽双绞线的结构图示：
2）同轴电缆
同轴电缆由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层以及绝缘保护套层所组成。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。
下图为同轴电缆实物图：
同轴电缆的结构图示：
3）光纤
光纤通信就是利用光导纤维(光纤)传递光脉冲来进行通信的。有光脉冲相当于1，而没有光脉冲相当于0。由于可见光的频率非常高，约为 10MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。
光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。
下图为光纤实物图：
光纤通常由非常透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体。 纤芯很细，其直径只有 8~100 µm 。光波正是通过纤芯进行传导的。包层较纤芯有较低的折射率。当光线从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包层时就会折射回纤芯。这个过程不断重复，光也就沿石光纤传输下去。
光波在光纤中折射：
光波在纤芯中传输：
（2）非导向传输媒体 当通信距离很远时，敷设电缆既昂贵又费时。利用无线电波在自由空间的传播就可较快地实现多种通信。
由于这种通信方式不使用上一节所介绍的各种导引型传输媒体，因此就将自由空间称为“非导引型传输媒体”
非导向传输媒体就是指自由空间，其中电磁波传输被称为无线传输。
无线传输所使用的频段很广
短波通信主要是靠电离层的反射，但短波通信的通信质量较差。
微波通信主要是直线传播，如：地面微波接力通信、卫星通信等。
3、物理层设备-集线器 工作特点：他在网络中只起到信号放大和重发的作用、其目的是扩大网络的传输范围，而不具备信号的定向传送能力。目前被交换机取代。
最大传输距离：100m
集线器是一个重大的冲突域。如下图，计算机A和计算机B通过集线器进行通信
（1）A发出的消息，B、C、D都能收到，只是计算机C、和D通过MAC地址判断消息不是自己的，便不进行接收，网络通信不安全
（2）当计算机A和B通信时，其他计算机便不能再通信，只能进行等待，因此会形成通信冲突
（3）集线器在此只是充当一个网线的角色，对数据只作传输不做识别处理
二、信道复用技术 复用是通信技术中的基本概念，复用可以节约传播介质
1、频分复用 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。
频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的带宽是频带带宽而不是数据的发送速率）
一个传播介质中信号可以分成多个频率传输，不同用户的通讯使用不同的频率，接收端也通过不同的频率来区分不同的用户通讯信息。
频分复用FDM示意图
如下图，传输信号经过调制解调器使用不同频率解调，形成不同频率的声波，然后把不同频率的声波叠加成一个声波进行传输。
在接收端收到信号以后，使用过滤器针对不同频率进行过滤，然后使用相同的频率进行解调，从而还原发送端传播的声波想信息。
电话机使用频分复用的例子图示 多个信道（图示12个信道）通过频分复用形成一个信道，然后一层一层叠加，最后汇总成一个最大的信道进行传输。
2、时分复用技术 时分复用则是将时间划分为一段段等长的时分复用帧（TMD帧）。每一个时分复用的用户在每一个TMD帧中占用固定序号的时隙。每一个用户占用的时间空隙是周期性地出现（其周期就是TMD帧的长度对应的时间）。
TMD信号也成为等时信号。时分复用的所有用户是在不同的时间占用同样的频带宽度。
发送端不同用户的信息存放位置是有规律的，接收端根据规律来取对应用户的数据。如图：
不同用户的数据存放的位置始终是不变的
数据的排列图示
（1）时分复用的实现机制 存取双方都遵从一定的时钟速率进行存取值
（2）时分复用的问题 时分复用可能会造成线路资源的浪费。使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的，如下图：
（2）改进：统计时分复用 统计时分复用，在不同信号前多加了一个信号标识，通过标识来区分不同用户的数据，不同数据不再占用一个固定的位置，数据存放是没有规律的，从而达到高效利用信道的目的。
3、波分复用——光的频分复用 波分复用WDM，实际上就是光的频分复用
波分复用的简略示意图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb10332d6e91a6cc3a40952b0509d6d/" rel="bookmark">
			震惊！！！乐得瑞推出LDR6328 PD诱骗芯片/PD取电芯片电路概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概述
LDR6328 是乐得瑞科技有限公司针对 USB PD 协议和 Qualcomm Quick Charge(简称 QC)协议开
发的一款兼容 USB PD 和 QC 的通信芯片。输入端主要接 PD 和 QC 的适配器，输出端配置输出固定
的电压。LDR6328 从支持 USB PD 和 QC 协议的适配器取电，然后供电给设备。比如可以配置适配器
输出需要的功率，给无线充电器设备供电。
2、特点
◇ 采用 SOP-8 封装
◇ 兼容 USB PD 3.0 规范，支持 USB PD 2.0
◇ 兼容 QC 3.0 规范，支持 QC 2.0
◇ 可自动诱骗 PD 输出 5V、9V、12V 电压，QC 输出 9V、12V 电压
3、应用
◇ 所有需要适配器（支持 USB PD 和 QC 协议）供电的设备
如无线充，无人机，筋膜枪，大功率蓝牙音箱取电等等！！！
优先检测PD＞QC协议 默认输入12V电压，如适配器无12V则选择9V，以此类推，如需其它电压档位可联系我司业务定制电压！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb10332d6e91a6cc3a40952b0509d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f54160de3ea04c4333b84edec74f79/" rel="bookmark">
			若依微服务(springcloud)之新增业务模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若依微服务(springcloud)之新增业务模块_会敲代码的小白鼠的博客-CSDN博客_若依cloud新建模块若依微服务版怎样新增业务子模块并使用代码生成实现对表的增删改查_霸道流氓气质的博客-CSDN博客
上篇我们已经搭建好了若依微服务框架，本次我们为实现自己的业务，将实现新增业务模块
1，
下面是官网下载的若依微服务代码导入idea后的架构
我们的业务是在module版块里面，所以我们需要在该目录下新建我们自己的业务模块ruoyi-tsmk,
如图：
我们在module右键选择新建一个module选择maven，注意这个地方parent需要选择在module下面， 下一步:
我们打开ruoyi-modules-system的系统模块的pom.xml,将其dependencies下和build下的代码复制到上面新建业务模块的pom.xml文件中，
如图
然后在新建模块下新建包com.ruoyi.tsmk,将前面system模块的启动类复制到新建业务的包下并更改名字
然后将system的yml配置文件复制到新建模块一份，并修改该模块的端口号，这里是9209,以及应用名称,应用名称记得更改，若是还是stystem，到时候启动项目，在服务中就会在sysytem下面 下一步：
我们启动nacos，把我们新建的tsmk模块配置好
找到配置列表，选择ruoyi-system-dev.yml，点击克隆，并更改Data Id 为ruoyi-system-dev.yml点击开始克隆
选中新克隆的配置文件，点击编辑，将搜索的指定包名的路径改为com.ruoyi.tsmk，这里的包名要与后面生成代码时相对应
再找到ruoyi-gateway-dev.yml网管的配置文件，把sysytem复制一份，点击编辑成我们tsmk就行
然后打开idea依次找到ruoyi-gateway、ruoyi-auth、ruoyi-system、ruoyi-gen下的启动类去启动，注意启动顺序。
网关模块和认证模块要在系统模块和代码生成模块之前。
然后再启动刚才新建的业务模块，此时一个启动五个模块。
打开nacos，可以看到服务管理里面已经有了我们刚才启动的新建业务模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de4c72dfa82b7654b024b07601272d3/" rel="bookmark">
			【io_uring】使用 io_uring 的高效 IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻译自 https://kernel.dk/io_uring.pdf
This article is intended to serve as an introduction to the newest Linux IO interface, io_uring, and compare it to the existing offerings. We'll go over the reasons for its existence, inner workings of it, and the user visible interface. The article will not go into details about specific commands and the likes, as that would just be duplicating the information available in the associated man pages. Rather, it will attempt to provide an introduction to io_uring and how it works, with the goal hopefully being that the reader will have gained a deeper understanding of how it all ties together.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de4c72dfa82b7654b024b07601272d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d0bef3dc6559b7bf95ff2ab365e3636/" rel="bookmark">
			浏览器被2345劫持了怎么搞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因我下载了某些修改东西，然后就被2345篡改了浏览器的数据。 我是在虚拟机里下载的，但是虚拟机其实也是物理机的一部分，实际上下载的还是到了物理机里面，于是浏览器打开就变成了2345的导航页面
1 解决方案：
浏览器主页被2345导航篡改,怎么办?
2 然后Google浏览器不知道怎么的，就变成了 新建标签页是无标题，怎么都打不开，解决这个问题的方案
谷歌浏览器打不开网页，也打不开设置，一直显示“无标题”的解决办法（完美）
3 如果不想这么麻烦的话，说一个简单的方法
将1 重命名为2 那样的然后新建2的快捷方式就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6dd7f02b8ee3c4d654e4c4eb522207/" rel="bookmark">
			sql server 查询表的字段名 数据类型 和字段长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习记录，以备忘： SELECT syscolumns.name AS 字段名,systypes.name AS 数据类型,syscolumns.length AS 长度 FROM syscolumns INNER JOIN systypes ON systypes.xtype=syscolumns.xtype
WHERE id=(SELECT id FROM sysobjects WHERE name='表名')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ec1a10365ff1e1c6ddb35ababd29c5/" rel="bookmark">
			chatgpt赋能python：Python装汉化包详解：完美解决你的语言难题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python装汉化包详解：完美解决你的语言难题 前言 作为一种高效、易读易写、功能强大的编程语言，Python已经逐渐成为了开发者们的不二选择。不过，对于初学者而言，英文文档的学习难度可能会稍微大一点。于是，本文将详细介绍如何在Python中安装中文汉化包，解决语言难题。
什么是Python汉化包 Python汉化包，正如其名，即将Python源代码中的英文语言转换为中文语言，让代码更加易于理解与使用。同时，Python汉化包还会对Python的库函数进行翻译，帮助开发者更好地使用Python。
需要注意的是，Python官方并没有提供完整的Python汉化包，因此我们需要借助第三方汉化包来实现。
Python汉化包的种类 Python汉化包的种类非常多，但是大致上可以分为以下几种：
Python汉化补丁包：这种汉化包是对Python源代码进行修改，需要重新编译Python才能生效。这种汉化包的弊端就是修改了Python的源码，一旦升级Python版本就会失效。程序汉化包：这种汉化包通过修改Python的默认编码方式，直接替换特定字符串的方法来实现。由于是直接替换字符串，所以只需安装一个汉化包，就可以对所有PYTHON程序进行修改，不受Python版本的限制。编辑器汉化包：这种汉化包是对Python编辑器进行汉化，通常是修改编辑器界面，美化字体等方式实现。因此这种汉化包只能汉化编辑器界面，对代码本身没有影响。 安装Python汉化包 在本篇文章中，我们主要介绍第2种Python汉化包——程序汉化包的安装方法。
下载汉化包： 我们可以在github上下载汉化包，最典型的汉化包是汉化贴 (https://blog.csdn.net/bohequn/article/details/93755594)。
安装汉化包： 将汉化包文件解压缩至Python的安装目录下即可。首先，我们需要找到Python的安装目录，打开Python的命令行提示符，输入以下代码定位Python安装路径：
import sys print(sys.executable) 这段代码运行后，会返回当前系统上Python的可执行路径。接着，我们将汉化包中的文件解压至Python的安装目录下，并且将GNU_gettext.py中的：
gettext.bindtextdomain(“python”, “c:/Python27/Lib/locale”)
符号"/"前后的路径规范化即可。
测试Python汉化包 安装完汉化包后，我们需要测试是否安装成功。以命令行为例，打开Python的命令行提示符，输入以下代码：
import os print(os.getcwd()) print("Hello, World!") 我们可以看到，输出结果中的"Hello, World!“变成了"你好，世界！”，这证明汉化包安装成功。
结论 Python汉化包能够帮助开发者更好地学习和使用Python，减少语言难题带来的学习障碍。本文介绍了Python汉化包的种类和程序汉化包的安装方法。只要按照本文所述方法进行操作，就能成功安装使用Python汉化包，让学习Python的过程更加轻松愉快。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a2c5d470b091265177dab95befb32e/" rel="bookmark">
			Java 流程控制 Switch 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Switch语句？
Switch语句是Java中的一种流程控制语句，用于根据表达式的值选择不同的执行路径。Switch语句通常用于多个条件的判断，比如根据用户输入的不同选项执行不同的操作。
二、语法说明
Switch语句的基本语法如下：
switch (expression) { case value1: // statement(s) to be executed if expression == value1 break; case value2: // statement(s) to be executed if expression == value2 break; case value3: // statement(s) to be executed if expression == value3 break; ... default: // statement(s) to be executed if none of the above cases are true break; } Switch语句包含一个表达式和多个case语句块。表达式的值将与每个case语句块中的值进行比较，如果表达式的值等于某个case语句块中的值，则执行该语句块中的语句。如果表达式的值与所有case语句块中的值都不匹配，则执行default语句块中的语句。
Switch语句中的break语句用于终止当前的语句块，并跳过后面的所有语句块。如果省略break语句，则程序将继续执行后面的语句块，直到遇到break语句或Switch语句结束。
三、使用示例
下面是一些使用Java Switch语句的示例：
根据用户输入的选项执行不同的操作： int option = 2; switch (option) { case 1: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a2c5d470b091265177dab95befb32e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715f387f3150e4c32a79ba1bbdb4dd82/" rel="bookmark">
			Windows上pip缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows上pip缓存 pip缓存我的pip缓存位置更改缓存位置（推荐）删除 pip 缓存效果验证 C盘空间又又又不够了，分析发现C盘下AppData下pip缓存占用较多。
pip缓存 在使用pip安装Python库时，如果之前已经下载过该库，pip会默认使用缓存来安装库，而不是重新从网络上下载。缓存文件通常存储在用户目录下的缓存文件夹中，具体位置因操作系统和Python版本而异。以下是一些常见的Python版本和操作系统下缓存文件的默认位置：
我的pip缓存位置 cmd命令行中查看
C:\Users\lenovo-T15&gt;pip cache dir c:\users\lenovo-t15\appdata\local\pip\cache 果然是C盘下占用空间比较大的位置。
更改缓存位置（推荐） 首先先建立一个文件夹来充当缓存目录
推荐在D盘，如果python也是安装在D盘的话，最好在安装目录下建立就好，如我的就是这样建立了pipcache文件夹来缓存pip的缓存数据
打开命令行窗口输入：
pip config set global.cache-dir "D:\Software\python3.6\pipcache" Writing to C:\Users\lenovo-T15\AppData\Roaming\pip\pip.ini 注：文件夹路径地址要如我这样的绝对地址。如果出现第二行的语句，说明更改成功。
再次验证一下，成功：
C:\Users\lenovo-T15&gt;pip cache dir d:\software\python3.6\pipcache 然后就可以删除之前的pip缓存了，也可以把其复制来这个新地址。
删除 pip 缓存 1、找到对应文件夹，进行删除
2、命令删除
pip cache purge 这个命令会清除所有缓存，包括已下载但未安装的软件包和已安装但未被使用的缓存。
只想清除特定软件包的缓存，可以使用以下命令：
pip cache remove package-name 其中，package-name 是你要清除缓存的软件包的名称。
无论是在 PyCharm 的终端中执行命令还是在命令行中执行命令，使用 pip 安装包时产生的缓存都应该存储在相同的位置。pip 使用的缓存目录通常是当前用户目录下的 ~/.cache/pip，它是基于用户的，而不是基于特定环境的，因此在同一个用户下，不同的 Python 环境都会共享相同的缓存目录。
效果验证 又可以缓一缓了，暂时逃避红色的压抑！！！
参考
[1]: https://blog.csdn.net/qq_38463737/article/details/107220446
[2]: https://blog.csdn.net/qq_44921056/article/details/129857659
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e75c74dcb87f2e37c5aaff728eb2dcd/" rel="bookmark">
			Android11 DNS解析流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android11 DNS解析 1. DNS解析概念 ​ DNS的全称是domain name system，即域名系统。主要目的是将域名解析为IP地址，域名是方便用户记忆，但网络传输中源目地址使用IP地址来进行标识的，所以Android中的网络应用程序在发起http请求之前必然要经历DNS解析过程。
2. Android11的DNS解析过程 2.1 Inet6AddressImpl.lookupHostByName Android app不管用什么网络框架，dns解析都会走到Inet6AddressImpl.lookupHostByName方法，我们就以这个方法为入口开始看代码：
/** * Resolves a hostname to its IP addresses using a cache. * * @param host the hostname to resolve. * @param netId the network to perform resolution upon. * @return the IP addresses of the host. */ private static InetAddress[] lookupHostByName(String host, int netId) throws UnknownHostException { //参数host代表dns解析的域名，netId代表使用的网络，如wifi，数据网络等等都是可以自己选择的 BlockGuard.getThreadPolicy().onNetwork(); // 缓存中是否已经有了，这里的缓存只是应用进程的缓存（TTL为2s），并不是DNS的TTL缓存 ... try { StructAddrinfo hints = new StructAddrinfo(); //不指定协议族，返回包括 IPv4 和 IPv6 的所有地址 hints.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e75c74dcb87f2e37c5aaff728eb2dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8808d950099da13cad03ac466852642a/" rel="bookmark">
			深度学习Q&amp;A之卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习Q&amp;A之卷积神经网络 前言1 卷积基础知识问题1 简述卷积的基本操作，并分析其与全连接层的区别 （难度： ★ \bigstar ★）分析与解答： ♣ \clubsuit ♣ 局部连接: ♣ \clubsuit ♣ 权值共享: ♣ \clubsuit ♣ 输入/输出数据的结构化: 问题2 在卷积神经网络中，如何计算各层的感受野大小 （难度： ★ ★ \bigstar \bigstar ★★）分析与解答： 问题3 卷积层的输出尺寸、参数量和计算量 （难度： ★ ★ \bigstar \bigstar ★★）分析与解答： ⧫ \blacklozenge ⧫ 输出尺寸 ⧫ \blacklozenge ⧫ 参数量 ⧫ \blacklozenge ⧫ 计算量 2 卷积的变种问题1 简述转置卷积的主要思想以及应用场景（难度： ★ ★ ★ \bigstar \bigstar \bigstar ★★★）分析与解答： 问题2 简述空洞卷积的设计思路（难度： ★ ★ \bigstar \bigstar ★★）分析与解答： 3 卷积神经网络的基础模块问题1 批归一化是为了解决什么问题？它的参数有何意义？它在网络中一般放在什么位置？（难度： ★ ★ ★ \bigstar \bigstar \bigstar ★★★）分析与解答： 问题2 卷积神经网络中的瓶颈结果和沙漏结构提出的初衷是什么？可以应用于哪些问题？（难度： ★ ★ ★ ★ \bigstar \bigstar \bigstar \bigstar ★★★★） ♠ \spadesuit ♠ 瓶颈结构 ♠ \spadesuit ♠ 沙漏结构 前言 本文是基于《百面深度学习 算法工程师带你去面试》一书，内容也都来自书中，而我会对其中的内容进行些许过滤，将我认为比较重要实用的内容放到博客里，文本虽然来自书中，不过相关的示例图、图片均为本人原创手绘（均带有本人水印）。 如果有人对博客中的图片和动图感兴趣的可以私聊我要无水印的原件。 本系列面向刚入门深度学习的读者，和有一定基础但没有体系了解过深度学习细节的Deep learner。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8808d950099da13cad03ac466852642a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa939bb448aaa1ff9f1ec3596f5a90c3/" rel="bookmark">
			【Spring Boot学习】Spring Boot的创建和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
💞💞今天我们开始学习Spring Boot，这里我们会学习到怎么去创建和使用Spring Boot，在这里我们会了解到什么是最为核心的框架之一。
💞💞前路漫漫，希望大家坚持下去，不忘初心，成为一名优秀的程序员。
个人主页⭐： 书生♡
gitee主页🙋‍♂：奋斗的小白
专栏主页💞：JavaEE进阶专栏
博客领域💥：java编程前端，算法，强训题目
写作风格💞：超前知识点，干货，思路讲解，通俗易懂
支持博主💖：关注⭐，点赞、收藏⭐、留言💬
目录 1.Spring Boot1.1什么是SpringBoot1.2 Spring Boot的优点 2.Spring Boot的创建2.1Spring Boot的创建的准备2.2 Spring Boot 的创建 3.Spring Boot目录介绍4.Spring Boot运行4.1 直接运行4.2 输出 Hello world 5.包路径问题 1.Spring Boot 1.1什么是SpringBoot Spring 是为了简化 Java 程序的，⽽ Spring Boot 是为了简化 Spring 程序开发的。
1.2 Spring Boot的优点 Spring Boot 的优点有以下几点：
1.快速生成我们所需要的依赖和框架
2.内置运行容器，不需要配置Tomcat了，现在直接运行就可以了
3.可以抛弃XML，使用注解和配置（后面会讲）就可以了
4.快速部署项目，可以直接运行并启动容器
5.支持更多的监控指标，可以更好地了解项目的运行
这些是SpringBoot最基础的优点，SpringBoot还有三个最核心的优点。
SpringBoot最核心的优点
1.快速添加依赖
2.内置Web容器
3.自动装配（这个是上面没有体现出来的，也是最重要的）
2.Spring Boot的创建 2.1Spring Boot的创建的准备 对于Spring Boot的创建，如果你是专业版/破解版，那么idea直接就可以生成SpringBoot项目了，但是如果你是社区版，那么你就要先去idea下载一个插件。
点击左上角的File–&gt;点击settings–&gt;点击Plugins–&gt;搜索Spring Boot Helper，下载好以后这个会变为Spring Initializr and Assistant，让你就可以创建SpringBoot项目了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa939bb448aaa1ff9f1ec3596f5a90c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747c4d26f4e468e43ac73df17549bb74/" rel="bookmark">
			mysql分组排序增加序号值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下代码是一个MySQL查询语句，用于对字段field1和field2进行分组，并在field1值相同时对field2进行排序并增加序号。
select field1,field2,count(*) as count ,( @i := if( @pre_field1 = field1 , @i + 1,1)) rownum ,(@pre_field1 := field1) from table_name,(SELECT @i := 0,@pre_field1 := '') AS a GROUP BY field1,field2, ORDER BY field1,field2 以下是每个部分的解释：
select: 指定要查询的字段或表达式。field1,field2: 需要进行分组和排序的两个字段。count(*) as count: 计算每个分组中的记录数，并将其命名为count。@i := if( @pre_field1 = field1 , @i + 1,1) rownum: 使用MySQL的用户变量@i来增加序号。如果前一个分组的field1值与当前分组的field1值相同，则序号递增1；否则，序号重置为1。@pre_field1 := field1: 将当前分组的field1值赋给用户变量@pre_field1，以便在下一行计算中使用。from table_name: 指定要查询的表名。(SELECT @i := 0,@pre_field1 := '') AS a: 定义并初始化用户变量@i和@pre_field1的子查询别名a。GROUP BY field1,field2: 根据field1和field2字段进行分组。ORDER BY field1,field2: 对分组后的结果按照field1和field2进行升序排序。 请注意，该查询语句中的用户变量的使用是特定于MySQL的，不同的数据库管理系统可能有不同的语法和机制来实现相同的功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93994362dafd9b10c492ac7d64ccf830/" rel="bookmark">
			Gungnir系列-Zabbix05-自定义脚本监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 zabbix监控搭建完毕之后我们可以发现zabbix自己带了很多定义好的监控项，但是这可能无法满足我们很多需求。这时我们就很需要自定义监控项，利用自己写好的针对不同功能的脚本，对需要的指标进行监控。我们也可以写脚本查询一些数据，通过告警的方式收到这些数据。
这里我的需求就是想监控主机间的ping是否可达，如不可达进行告警。
二、agent端操作 把脚本放在指定目录下
mkdir -pv /root/zzx chmod 777 /root/zzx 编写脚本
vi /root/zzx/pingzzx.sh #!/bin/bash hostip=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v 201|grep -v inet6|awk '{print $2}'|tr -d "addr:"` HLIST=$(cat /root/zzx/ipadds.txt) for IP in $HLIST do ping -c 3 -i 0.2 -W 3 $IP &amp;&gt; /dev/null if [ $? -ne 0 ] ; then echo "$hostip to $IP is Off-line." fi done 这里我的脚本名为pingzzx.sh，将本机需要ping的ip放入ipadds.txt中。
别忘了修改权限，防止zabbix没有权限
chmod 777 /root/zzx/* 修改zabbix_agentd.conf
egrep -v "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93994362dafd9b10c492ac7d64ccf830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8863b4ace4929723ff5312411044d93c/" rel="bookmark">
			Qt可执行程序写入版本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ Qt是一个基于C++语言的跨平台应用程序开发框架，具有丰富的UI组件和API库。Qt包括了许多模块，如Qt Core、Qt GUI、Qt Network等，每个模块都提供了一系列的类和函数。Qt还提供了集成开发环境（IDE）Qt Creator，使得开发人员可以通过它来创建、编译、调试和部署Qt应用程序。 学习Qt开发不知道做什么？我为大家整理的这些领域都涉及到Qt开发：嵌入式领域、桌面端开发、移动端、微控制器MCU、客户端(游戏、直播等等)、汽车领域行业、 消费类电子设备、医疗领域行业、工业自动化领域等等
Qt框架,GUI应用程序,跨平台开发,信号与槽机制,QML语言,模型视图编程,多线程编程,数据库编程,网络编程,XML解析,JSON解析,图形图像处理,用户界面设计,动画效果,OpenGL,WebKit,嵌入式开发,客户端/服务器应用程序.自定义控件QT6，C++语言基础，qt基础编程，qt软件开发，Qt架构设计，qt布局管理器，qt嵌入式开发，qt编程入门，qt数据库编程，qt跨平台框架，QT项目实战，Quick模块，OpenCV，Qt实战，OpenCV教程，QT界面开发，Qt框架，C++数据结构，Qt线程，桌面应用开发，qt桌面应用开发，Socket网络编程，qt开发工程师，qt开发，应用程序开发框架，图形视图框架，数据库编程，Qt开发编程，Qt开发控件，Qt开发工程师，QT开发必备技能栈，qt编码，qt网络编程，qt网络通信，Qt信号，Qt槽机制，qt字符串,qt数据类型,qt容器，qt客户端开发，qt软件工程师，qt页面绘制 本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（C++语言基础，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QT嵌入式开发，Quick模块等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓ 方法很简单：新建一个txt文件。当然，名称按具体项目自拟，再把后缀直接改为rc类型即可。
文件中的内容呢？请看下文（注意：文件内的换行等等符号不可以错乱）：
IDI_ICON1 ICON "version.ico" #if defined(UNDER_CE) #include &lt;winbase.h&gt; #else #include &lt;winver.h&gt; #endif VS_VERSION_INFO VERSIONINFO FILEVERSION 1,0,0,10 PRODUCTVERSION 1,0,0,10 FILEFLAGSMASK 0x3fL #ifdef _DEBUG FILEFLAGS VS_FF_DEBUG #else FILEFLAGS 0x0L #endif FILEOS VOS__WINDOWS32 FILETYPE VFT_DLL FILESUBTYPE 0x0L BEGIN BLOCK "StringFileInfo" BEGIN BLOCK "080404b0" BEGIN VALUE "CompanyName", "开源软件\0" VALUE "FileDescription", "唤醒狩猎者\0" VALUE "FileVersion", "1.0.0.0\0" VALUE "ProductVersion", "1.0.0.0\0" VALUE "LegalCopyright", "开发者 CSDN IT1995\0" VALUE "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8863b4ace4929723ff5312411044d93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98631842e7a94e6827fdb3ff33132e27/" rel="bookmark">
			HTML爱心表白代码，亲测有效，独一无二！福利来啦！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发福利啦~小编最近搜集了好几个表白代码，感兴趣可以点进主页看看哟~
如果觉得文章不错，还请一键三联，不定时发布各种全免费的独一无二的代码！
这次我们来分享跳动的爱心的代码，网上有很多，但是个人觉得我这个比较温馨一点，背景也好看
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;跳动爱心&lt;/title&gt; &lt;style&gt; *{ padding: 0; margin: 0; } body{ background-color: pink; } #frame{ position: relative; width: 400px; height: 300px; margin: 250px auto; } .left,.right{ top: 0; width: 200px; height: 200px; border-radius: 50%; } .left{ left: 35px; } .right{ right: 35px; z-index: -1; } .bottom{ bottom: 36px; left: 100px; width: 200px; height: 200px; transform: rotate(45deg); z-index: -1; } .heart{ position: absolute; box-shadow:0 0 40px #d5093c; animation: beat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98631842e7a94e6827fdb3ff33132e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3b166201b8cc35f6ad7c89e88c6162/" rel="bookmark">
			linux复习资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux复习资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb87dffeb1e36c82bcee6cf21d93a3bc/" rel="bookmark">
			CMake的基础知识，看这篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是杂烩君。
上一篇文章中我们分享了关于make与Makefile的知识：Makefile常用基础知识梳理！。make工具有很多种：gnu make、QT的qmake、微软的MS nmake等。不同的make工具遵循不同的规范，如果我们的程序想要运行在不同的平台上，就需要根据不同地平台的make工具规范编写对应的Makefile文件。显然，这很不方便。
CMake就是一个可以解决上面这个问题的工具。
什么是cmake？ CMake 是一个跨平台的安装(编译)工具。CMakeList.txt是一个与平台无关的、用于定制编译流程的文件。CMake 靠的是 CMakeLists.txt 文件来生成Makefile文件。
CMakeLists.txt文件的编写也需要遵循一些语法规则，CMakeLists.txt文件的语法与shell脚本的语法很相似，shell编程知识可见往期文章：Hello系列 | Shell编程必备简明基础知识。
下面简单了解CMakeLists.txt简单的规则及一些示例。
cmake语法知识 1、直译模式 直译模式简单解释就是不生成Makefile的模式。这很方便我们验证一些CMakeLists.txt的语法及验证一些数学运算等。
下面通过简单实例区分直译模式与非直译模式的区别。
直译模式：
输入 -P参数 指定CMakeLists.txt脚本以直译模式解析。其中，message是CMakeLists.txt中用于输出信息的命令。以直译模式解析就不会生成Makefile文件，并且终端输出的信息就是我们CMakeLists.txt指定输出的内容。
非直译模式：
可见，以非直译模式解析则会生成Makefile文件，并且终端多输出了一些核查编译器相关的信息。
2、定义变量 CMakeLists.txt中只有字串和字串数组两种变量。定义变量通过 set命令 来定义，使用变量时在外面加上 ${} 符号即可。如：
# 定义变量 set(name "LinuxZn") # 使用变量 message("My name is ${name}!") ① 注释使用符号 #。
② 命令不区分大小写，即set也可以替换为SET。
3、数学运算 # EXPR 是一款表达式计算工具 # math 是用于数学运算的命令 # 设置变量a、b的值 set(a "1") set(b "2") # 加 math(EXPR res "${a} + ${b}") message("a + b : ${res}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb87dffeb1e36c82bcee6cf21d93a3bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f43541c60b37a3d87e1e90b2176125/" rel="bookmark">
			Java -jar参数详解：掌握Java可执行JAR文件的运行技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一种常用的开发语言，Java经常使用可执行的JAR（Java Archive）文件来打包和分发应用程序。使用java -jar命令运行JAR文件是一种方便快捷的方式。本文将详细介绍java -jar命令的各种参数，帮助您充分利用这个功能。
一、简介 java -jar命令用于运行可执行的JAR文件。它会自动查找JAR文件中的清单文件（MANIFEST.MF），并根据清单文件中的Main-Class属性指定的主类来启动应用程序。
二、常用参数详解 以下是一些常用的java -jar命令的参数，让我们逐一了解它们的功能和用法。
-Xmx：指定Java堆的最大内存大小。例如，-Xmx512m表示将最大堆内存设置为512MB。通过调整堆内存大小，可以优化应用程序的性能和内存使用情况。
-Xms：指定Java堆的初始内存大小。例如，-Xms256m表示将初始堆内存设置为256MB。这个参数可以帮助您在启动应用程序时控制初始内存分配的大小。
-Xss：指定线程栈的大小。例如，-Xss1m表示将线程栈大小设置为1MB。线程栈用于存储线程的局部变量和方法调用信息。通过调整线程栈的大小，可以控制应用程序的并发性能和内存使用情况。
-XX:MetaspaceSize=256m参数，您可以指定元空间的初始大小为256MB。这意味着在应用程序启动时，虚拟机会预分配256MB的内存用于存储类的元数据。
-XX:MaxMetaspaceSize=：指定元空间的最大大小。元空间用于存储类的元数据信息。例如，-XX:MaxMetaspaceSize=256m表示将元空间的最大大小设置为256MB。适当设置元空间的大小可以避免类加载和元数据溢出的问题。
-D=：设置系统属性。例如，-Djava.library.path=/path/to/libs设置java.library.path系统属性为/path/to/libs。您可以使用这个参数来配置应用程序的一些属性，例如文件路径、日志级别等。
-verbose:class：打印类加载信息。使用这个参数可以了解应用程序在运行过程中加载的类的详细信息，包括类的名称、来源等。
-verbose:gc：打印垃圾回收信息。通过使用这个参数，您可以了解应用程序的垃圾回收情况，包括垃圾回收器的使用情况、回收的对象数量等。
-Dfile.encoding=：设置默认的文件编码。例如，-Dfile.encoding=UTF-8表示使用UTF-8编码来读取和写入文件。正确设置文件编码可以确保应用程序能够正确处理不同字符集的文本数据。
以上是一些常用的java -jar命令的参数，通过灵活运用这些参数，您可以对应用程序的性能、内存使用和系统属性进行优化和配置。
三、示例使用 示例1： 前台启动
java -jar -Xms4096m -Xmx4096m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m /opt/myapp/myapp.jar
在上述示例中，我们同时使用了多个参数。-Xms4096m设置最大堆内存为4096MB，-Xmx4096m设置初始堆内存为4096MB，-XX:MetaspaceSize=256m 将元空间的初始大小设置为256MB，-XX:MaxMetaspaceSize=256m 将元空间的最大大小设置为256MB,最后，通过-jar选项指定要运行的JAR文件为myapp.jar。
示例2： 后台启动，并输出日志到nohub.out
nohup /usr/local/java/jdk1.8.0_333/bin/java -jar -Xms8192m -Xmx8192m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m -XX:+UseConcMarkSweepGC /home/myapp/myapp.jar &gt; nohup.out 2&gt;&amp;1 &amp;
四、启动脚本 一般情况了，我们会在jar包的同级目录下创建一个start.sh的启动脚本来启动我们的服务
**示例1：**启动脚本
#!/bin/sh nohup /usr/local/java/jdk1.8.0_102/bin/java -jar -Xms4096m -Xmx4096m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m /home/myapp/myapp.jar &gt; nohup.out 2&gt;&amp;1 &amp; **示例2：**通用脚本
#!/bin/bash # ################################################################## # ### Service start script # ################################################################## # 方便查看日志，参数为 -f PRG="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67f43541c60b37a3d87e1e90b2176125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a25c580214efc68527a25efe18866b4b/" rel="bookmark">
			使用conda更新python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、更新原因
二、步骤
2.1、添加conda下载镜像
2.2、conda更新python
2.3、更新conda版本
三、验证
四、离线安装
一、更新原因 原因是本来使用的是具有python3.6.3版本的conda环境，但是因为python内存堆栈溢出的bug问题。现在需要将Python的版本更新到3.8.8或3.9.2及以上。在更新的过程还是有几个细节需要注意下，这边做个记录。
方法有两种，一种是conda install命令更新，另一种是直接下载sh更新。前者比较繁琐且容易出错。第二种相对简单很多。
第二种方式 第二种方式简单，这边简单讲一下。下载sh后直接拷贝到对应linux目录后安装，具体可参考这篇文章：linux安装anaconda3环境-CSDN博客 。sh下载地址是：Index of / ，其中部分的anaconda对应的python列表如下（都是一个一个安装后 python -V 试出来的）：
Anaconda3-2020.07-Linux-x86_64.shpython3.8.3Anaconda3-2020.11-Linux-x86_64.shpython3.8.5Anaconda3-2021.04-Linux-x86_64.shpython3.8.8Anaconda3-2021.11-Linux-x86_64.shpython3.9.7 二、步骤（第一种方式） 2.1、添加conda下载镜像 这个是为了让你在下载的时候使用国内镜像源地址下载，有效提高下载速度。
# 将下面内容添加到 ~/.condarc channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - defaults show_channel_urls: true default_channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r custom_channels: conda-forge: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud ssl_verify: false 2.3、更新conda版本 如果conda的版本跟python的版本不兼容了。具体体现于下面的报错：
[root@finance205 home]# conda -V Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a25c580214efc68527a25efe18866b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c903e24b527b229f1e72e5717c6daa/" rel="bookmark">
			Spring Boot使用Redisson分布式锁解决缓存击穿问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 什么是缓存击穿2 为什么要使用分布式锁3 什么是Redisson4 Spring Boot集成Redisson4.1 添加maven依赖4.2 配置yml4.3 配置RedissonConfig 5 使用Redisson的分布式锁解决缓存击穿 1 什么是缓存击穿 一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
2 为什么要使用分布式锁 在项目中，当共享资源出现竞争情况的时候，为了防止出现并发问题，我们一般会采用锁机制来控制。在单机环境下，可以使用synchronized或Lock来实现；但是在分布式系统中，因为竞争的线程可能不在同一个节点上（同一个jvm中），所以需要一个让所有进程都能访问到的锁来实现，比如mysql、redis、zookeeper。
3 什么是Redisson Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。
4 Spring Boot集成Redisson 4.1 添加maven依赖 不再需要spring-boot-starter-data-redis依赖，但是都添加也不会报错
&lt;!--redisson--&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.17.0&lt;/version&gt; &lt;/dependency&gt; 4.2 配置yml spring: datasource: username: xx password: xxxxxx driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=CTT cache: type: redis redis: database: 0 port: 6379 # Redis服务器连接端口 host: localhost # Redis服务器地址 password: xxxxxx # Redis服务器连接密码（默认为空） timeout: 5000 # 超时时间 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c903e24b527b229f1e72e5717c6daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ca483e46a0dda7e1f23df6feb4f997/" rel="bookmark">
			vue-汉字转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
插件文档
下载插件
参数
optiions使用
使用
插件文档 GitHub - waterchestnut/pinyin: 把汉字转化为拼音字母，由chinalu/JSPinyin改写，使用新语法并去掉mootools的依赖
下载插件 npm install js-pinyin
参数 optiions使用 pinyin.setOptions({charCase:1});
setOptions 中传入对象，对象可传两个参数
charCase参数：输出脾阴的大小写模式：0-首字母大写，1-全小写，2-全大写
checkPolyphone:是否检查多音字 ------------------------------------------------------------------------------------------------------------------
使用 // 根据自己路径，引入即可
import pinyin from '../../../../node_modules/js-pinyin/index';
// 根据名称获取标识
getIdentifying(event){
// 拼音小写
pinyin.setOptions({charCase:1});
console.log(pinyin.getFullChars('管理员')) //GuanLiYuan; console.log(pinyin.getCamelChars('管理员')) //GLY; console.log(pinyin.getCamelChars('1234')) //1234; console.log(pinyin.getCamelChars('杨')) //Y; // 赋值
// pyName[0].toUpperCase() 首字母大写
// pyName.slice(1) 接触字符串其余部分
// 赋值
this.form.identifying=pyName[0].toUpperCase()+pyName.slice(1);
// 赋值
this.$set(this.form,'identifying',pyName);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449ea7a8ef240fa7e84aefa216d9b008/" rel="bookmark">
			【面试】java后端面试问题收集1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式id唯一性如何保证 分布式系统中生成唯一ID（如订单号、用户ID等）是一项常见的需求。在保证唯一性的基础上，分布式ID生成应能够满足高并发、可扩展和性能要求。下面介绍几种常用的分布式ID生成方案，它们都以不同的方式保证了唯一性：
UUID（Universally Unique Identifier）：UUID是一种128位的全局唯一标识符，采用随机算法生成。UUID的唯一性非常高，几乎可以忽略重复的概率。UUID在生成时不依赖于任何中央注册机构，因此可以在分布式系统中生成唯一ID。然而，由于其较长的长度对于存储和索引来说可能不够高效，同时也不具备可排序性。
数据库自增ID：使用数据库自增ID的方式是常见且简单的方案。数据库通过设置自增主键，每次插入新记录时会自动递增生成唯一ID。优点是数据库提供了高并发和事务的支持，不需要考虑冲突问题。但是，数据库的性能可能成为瓶颈，并且在分库分表的情况下，需要额外的管理和访问多个数据库。
Snowflake算法：Snowflake是Twitter开源的一种分布式ID生成算法。Snowflake算法将64位的ID划分成多个部分，包括时间戳、工作节点ID和序列号。通过对时间戳、节点ID和序列号的组合，可以生成一个全局唯一的ID。Snowflake算法在分布式环境下具备高性能和可扩展性，同时也保留了可排序性的特点。
全局唯一ID生成器（如Redis、ZooKeeper）：使用全局唯一ID生成器可以避免单点故障。例如，借助于Redis或ZooKeeper这样的分布式数据存储服务，可以实现一个全局唯一ID的生成器。每次需要生成ID时，客户端向全局唯一ID生成器请求一个唯一ID，通过原子操作保证了ID的唯一性和可靠性。
在实际应用中，根据系统的需求和规模选择合适的分布式ID生成方案。而且需要注意的是，保证ID的唯一性只是第一步，如何高效地生成和使用ID、如何处理ID的有序性以及如何在分布式系统中保障ID的一致性等问题也是需要考虑的。
了解GC吗，java的GC怎么做？ 深入了解JVM垃圾回收的8种算法
GC（垃圾收集）是一种自动管理内存的机制，它通过自动扫描和回收程序中不再使用的内存，以减少内存泄漏和提高应用程序的性能。
Java的GC机制是指Java虚拟机（JVM）中负责自动回收垃圾对象的一套算法。Java程序在运行时会动态地分配和释放内存，但由于Java语言本身并没有提供手动管理内存的机制，所以需要依靠GC进行自动管理。
Java的GC机制主要基于以下几个原则：
引用计数法（Reference Counting）：在每个对象中维护一个计数器，记录有多少个引用指向该对象。每当有一个引用指向该对象时，计数器加一；当引用指向该对象失效时，计数器减一。当计数器为零时，表示该对象不再被使用，可以释放内存。但这种方法无法解决循环引用的情况，因此Java不采用引用计数法。
可达性分析（Reachability Analysis）：Java的GC机制基于可达性分析，即判断某个对象是否可达，若不可达则表明该对象不再被使用。从GC Roots（包括栈中的局部变量、静态变量、常量等）开始，通过对象引用链追踪，标记所有可达的对象，并将剩余的对象（即不可达对象）判定为垃圾，待回收。
标记-清除算法（Mark and Sweep）：当Java的GC判定某个对象为垃圾时，它并不直接释放该对象所占的内存空间，而是将其标记为可回收状态。在Java虚拟机判断需要进行垃圾回收时，会先暂停应用程序运行，通过标记所有可达对象，然后清除所有不可达对象所占的内存空间，最后压缩内存，使其连续起来，以便后续分配。
分代回收（Generational Collection）：为了提高回收效率，JVM将内存分为不同的代（Generation），一般分为年轻代（Young Generation）和老年代（Old Generation）。年轻代中的对象生命周期较短，回收频率高，采用复制算法（Copying）回收；老年代中的对象生命周期较长，采用标记-清除算法回收。
总的来说，Java的GC机制通过判断对象的可达性和分代回收的方式对内存进行自动管理和回收，减少了开发者手动释放内存的工作，并提高了应用程序的性能和稳定性。不同的GC算法和配置可根据实际需求进行选择和调整。、
访问一个网站后发生了什么：
用户在浏览器中输入网址，请求访问网站。浏览器首先进行DNS查询，将域名转换为对应的IP地址。 如果DNS缓存中有对应的IP地址，直接使用缓存。如果没有，则进行DNS解析，向DNS服务器发送查询请求获取对应的IP地址。 用户计算机与目标服务器之间建立网络连接。 如果目标服务器在同一局域网内，使用ARP协议查询目标设备的MAC地址，直接建立连接。否则，通过默认网关路由器建立连接。 在传输层使用TCP协议进行连接的建立和数据传输。 进行TCP三次握手来建立连接。 客户端发送一个带有SYN标志的数据包给服务器。服务器接收到请求后，回复一个带有SYN/ACK标志的数据包。客户端再回复一个带有ACK标志的数据包，确认连接建立成功。 客户端向服务器发送HTTP请求。 服务器接收到请求后，进行处理和响应。 根据请求的方法和路径，进行相应的处理操作。生成HTTP响应，包括状态码、响应头和响应内容。 服务器将HTTP响应发送回客户端。 HTTP响应经过网络传输到达客户端。 客户端接收到HTTP响应。 数据经过TCP传输层进行处理和接收。 浏览器解析HTTP响应并渲染页面。 解析HTML、CSS、JavaScript等内容。根据解析结果渲染页面显示给用户。 数据传输完毕后，关闭TCP连接。 客户端和服务器进行TCP四次挥手来关闭连接。 客户端发送一个带有FIN标志的数据包给服务器。服务器接收到请求后，回复一个带有ACK标志的数据包。服务器发送一个带有FIN标志的数据包给客户端。客户端接收到请求后，回复一个带有ACK标志的数据包，最终连接关闭。 mq 消息不丢失详细再讲讲
本服务依赖哪些外部服务，外部服务异常了怎么办
数据在线迁移方案，什么时候可以把源库下掉，数据丢失怎么办，怎么保证一致性
Linux更改文件权限命令，为什么是三个数字
谈谈对动态规划的理解，01背包问题怎么解决
进程间 ipc 机制
tcp 如何保证可靠
四层负载均衡和七层负载均衡，四层了解吗？（答不太了解，于是扯了一下七层，提到了反向代理）
ngnix分发请求后，响应是响应给client还是给ngnix （回答不知道，猜的是ngnix，根本没用过啊哈哈哈）
操作系统最多可以建立多少长链接
http3了解吗？（不太了解，只知道底层是quic）
mysql索引原理，b+树为什么要在最底层把叶子结点串成双向链表？
事务隔离级别，每个级别分别会发生什么问题
java11和8区别？（不太了解，谈了一些可有可无的特性，面试官提醒垃圾收集器，回答更换了默认的垃圾收集器为g1，面试官这时候问了解zgc吗，回答不了解）
深度拷贝怎么做
synchronized 可重入吗？公平吗？怎么实现一个公平锁？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/449ea7a8ef240fa7e84aefa216d9b008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97543161a5a282ad2e8209b66210f60c/" rel="bookmark">
			python中pandas如何过滤输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中使用 Pandas 库进行数据分析时，你可以使用条件过滤来筛选和过滤输出。Pandas 提供了多种方法来实现数据的过滤和筛选操作，(ChatGPT编写)以下是一些常用的方式：
1. 使用布尔索引：
```python
import pandas as pd
# 创建一个示例DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
'Age': [25, 30, 35, 40]}
df = pd.DataFrame(data)
# 使用布尔索引过滤输出
filtered_df = df[df['Age'] &gt; 30]
print(filtered_df)
```
import pandas as pd # 创建一个示例DataFrame data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'], 'Age': [25, 30, 35, 40]} df = pd.DataFrame(data) # 使用布尔索引过滤输出 filtered_df = df[df['Age'] &gt; 30] print(filtered_df) 2. 使用条件表达式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97543161a5a282ad2e8209b66210f60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81f7160f5ee9915a01cf6770c961693/" rel="bookmark">
			Github下载安装ROS软件包的步骤和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载 1.创建工作空间 用于存放GitHub下载的包，并提供编译空间。
工作空间的目录结构：
2.添加一个工具 3.在GitHub上获取包的网址连接 https://github.com 4.复制GitHub包到本地 注意在catkin_ws/src下复制
二、编译 1.安装依赖 在catkin_ws/src/包/scripts下，根据你的Ubuntu型号来选择相应的依赖。
2.编译 在~/catkin_ws的目录下进行catkin_make编译，而不是在src的目录下。
三、运行 1.加载环境参数到终端环境里，否则找不到软件包 使用source指令载入工作空间的环境设置。
可以设置source指令到bashrc文件中，以免每次忘记设置。
（1）打开.bashrc文件
(2)文章末尾添加指令source ~/catkin_ws/devel/setup.bash
2.运行ros程序 使用launch运行编译好的ros程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b98b4c90a727cce6f094c0fa051cdd/" rel="bookmark">
			Java实现简单五子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.设计思路
2.代码实现
1.初始化需要的变量
2.初始化棋盘和打印棋盘的方法
3.判断胜利的方法
4.开始下棋
5.总体代码
6运行结果 1.设计思路 1.启动五子棋游戏 调用一个方法
初始化棋盘(开始之初初始化一次,对二维数组进行赋值) -- 初始化方法
打印出五子棋棋盘(重复使用多次) -- 打印棋盘方法
2.下棋 黑白双方交替下棋
输入坐标(黑棋,白棋哪个先下棋)
判断坐标是否合法,判断是否重复
判断输赢
2.代码实现 1.初始化需要的变量 static String white = "☆"; static String black = "★"; static String[][] qp = new String[15][15]; static String[] num = {"⒈", "⒉", "⒊", "⒋", "⒌", "⒍", "⒎", "⒏", "⒐", "⒑", "⒒", "⒓", "⒔", "⒕", "⒖"}; static String line = "十"; 2.初始化棋盘和打印棋盘的方法 /** * 初始化棋盘 */ public static void qipan(){ qp[14]=num;//棋盘最后一行为数字 int t=0; for (int i = 0; i &lt; qp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b98b4c90a727cce6f094c0fa051cdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e5167c1f229ffbae7b4c877566e483/" rel="bookmark">
			【STM32训练—WiFi模块】第二篇、STM32驱动ESP8266WiFi模块获取天气
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一部分、前言
1、获取心知天气API接口
2、硬件准备
第二部分、电脑串口助手调试WIFI模块获取天气
1、ESP8266获取天气的流程
2、具体步骤
第三部分、STM32驱动ESP8266模块获取天气数据
1、天气数据的解析
1.1、什么函数来解析天气数据？
2.1、解析后的数据如何使用？
2、相关代码
2.1、main.c文件
2.2、esp8266.c文件
第四部分、总结
1、效果展示
2、完整的工程
3、补充
第一部分、前言 这篇博客拖了很久很久，本来是打算和前面一篇一起发出来的，但是那段时间因为一些事情耽搁了，这篇博客写了一半，剩下的一直都没有写，其次就是人也有点懒，也不太想动🤪🤪。
这几天考试周来了，复习又不想复习，不如把这篇内容更新完整，这篇更新完之后，STM32专栏应该不会再更新了。
然后，后面我打算出一期C语言的学习笔记专栏，再后面就是FPGA的学习笔记专栏。想是这么想的，不知道能不能做好，哈哈🤭。
1、获取心知天气API接口 这里还是希望大家先去看我的第一篇博客：【STM32训练—WiFi模块】第一篇、STM32驱动ESP8266WiFi模块获取网络时间通过这篇博客你会明白WIFI模块获取网络流程是什么样子的，搞懂了这个，你会发现获取天气和获取时间的步骤完全一样，代码也没有什么大的变化。
接着再来说一下心知天气，上一篇文章提到时间的接口是由苏宁后台提供的“quan.suning.com/getSysTime.do”，那么这里想获取天气，那么也需要一个API的接口，这里的API接口由心知天气给我们提供。
因此需要注册一个心知天气，获取自己的密钥。关于注册的过程可以参考心知天气提供的文档：注册与登陆 | 心知天气文档 (seniverse.com)
注册完成后，如何获取属于自己的API接口呢，参考文档如下：查看/修改你的API密钥 (yuque.com)
这是我的API接口，点进去之后就会看到目前杭州的天气数据：https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=zh-Hans&amp;unit=c
点击上面的链接，就会获取到天气数据，接下来的步骤就和前面获取时间一样，主要区别就是将时间的API接口换成刚刚注册得到的心知天气的API接口即可，是不是发现原来也就这么回事。
2、硬件准备 STM32选用核心板F103C8T6，然后再加一个ESP8266 WiFi模块（任何型号应该都可以，我这次用的ESP-01s），最后需要一个USB-TTL模块用来打印串口数据。
需要注意的是：我的这个ESP-01S，有一个EN使能端，必须要给高电平才能用，上一篇博客用的那个WIFI模块没有EN使能端。所以希望大家注意自己的模块。
第二部分、电脑串口助手调试WIFI模块获取天气 1、ESP8266获取天气的流程 流程和获取时间的流程大致一样，只不过这里获取的为天气数据。
2、具体步骤 第一步、AT指令集
0：AT 1：AT+RST 2：AT+CWMODE=1 3：AT+CIPMUX=0 4：AT+CWJAP="你的WiFi名称","你的WiFi密码" 5：AT+CIPMODE=1 6：AT+CIPSTART="TCP","api.seniverse.com",80 7：AT+CIPSEND 8：GET https://api.seniverse.com/v3/weather/now.json?key=SwLQ3i0Q5TNa6NSKT&amp;location=hangzhou&amp;language=en&amp;unit=c 9：+++ 注意：所有串口步骤同前一篇文章，这里直接有区别的步骤为第八步，因此这里直接跳转到第八步
第八步、连接目标的服务器，TCP是传输协议,api.seniverse.com是心知天气服务器的IP地址，80是服务器端口。
第十步、第九步和前文一样，接着再发送获取数据的请求，得到天气数据
第十一步、关于退出透传的方式也和前面博客完全一样，这里就不再展示，所以一定要看第一篇文章，那个文章介绍的太详细了。
第三部分、STM32驱动ESP8266模块获取天气数据 1、天气数据的解析 这里天气的解析我调用了cJSON的库，你不用管这个库怎么写的，原理是啥，知道它是怎么用的就可以了，例如调用什么函数来解析天气数据？解析后的数据如何使用？弄明白这两个问题，就够了。
1.1、什么函数来解析天气数据？ 时间太久了，我都不知道我哪里弄来的这个函数，反正挺好用的，侵权联系我删除!
这个函数我放在我工程的"cJSON.c"文件最下面。
/********************************************************************************* * Function Name ： cJSON_WeatherParse,解析天气数据 * Parameter	： JSON：天气数据包 results：保存解析后得到的有用的数据 * Return Value ： 0：成功 其他:错误 * Function Explain ： * Create Date ： 2017.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e5167c1f229ffbae7b4c877566e483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b091c94d19d308d3aa0e521eca4ab17/" rel="bookmark">
			Sublime text 4 使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Sublime text 4 使用技巧 1. 快速编辑多行的方法。2. 待续 1. 快速编辑多行的方法。 使用下面的功能要安装一个叫emmet的插件。
下面就来看下具体的五种方式吧：
1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行；
2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑；
3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑；
4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；
5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。
备注：转载地址点击这里
2. 待续 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e724bd38df80bf384b72ced8747b1a42/" rel="bookmark">
			线性回归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归算法概述 线性回归是利用数理统计中的回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。线性回归模型是相对简单的回归模型，对一个或多个自变量之间的线性关系进行建模，可用最小二乘法求模型函数。
回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。
线性回归算法计算过程 线性回归算法的目的是来找到一条函数表达式，从而能够最好的拟合给定的数据集。
当得到这条函数表达式的时候，讲所有已知的点代入到这个函数表达式之间，就会得到一个函数值，而这个函数值减去真实值之后就会得到一个误差，将所有的误差平方后求和就是这个函数表达式整体的一个误差，这种将所有误差平方求和的方法叫做残差平方和。得到的结果越大，就说明预测值和实际值差距越大，得到的结果越小，就说明预测值和实际值差距越小，当结果为0时，证明所有的点都在这个函数表达式上。
表达式为
其中为误差。
举个例子，在二维平面上一些点随机的分布在一条线的两侧，那么线性回归的目的就是找到这条线的函数表达式，得到这条线的函数表达式就能处理未知的点，就能够求出他的结果值。
线性回归算法的使用条件 1.自变量与因变量应该大致呈线性 。
2.残差即真实值与预测值的差的分布为正态分布。
3.残差应该满足方差齐性。
4.自变量之间应是相互独立的，不存在共线性。
正规地来说，应用线性回归分析之前，需要对这四个条件进行检验。如果条件不符合仍然使用线性回归，即使得出结果，精度也会很差。
最小二乘法 最小二乘法公式是一个数学的公式，在数学上称为曲线拟合。
公式为
其中为最小二乘估计的截距，为最小二乘估计的斜率，和为样本x和y的均值。线性回归算法的函数表达式就是通过最小二乘法所得到的。
线性回归算法的优缺点 优点：
1.运算速度快，由于算法简单，符合非常简洁的数学原理，所以线性回归算法不管时建模速度还是预测速度都是非常快的。
2.可解释性很强，由于最终可以得到一个数学函数表达式，根据计算出的系数就可以明确的知道每个变量的影响大小。
3.善于获取数据集中的线性关系。
缺点：
1.预测的精确度较低，由于获得的模型只是要求最小的损失，而不是数据良好的拟合，所以精确度比较低。
2.不相关的特征会影响结果，对噪声数据处理比较难。
3.不适用于非线性数据。
4.容易出现过拟合，尤其是数据量不大的情况。
线性回归算法代码 from sklearn.linear_model import LinearRegression # 导入线性回归模型 clf = LinearRegression() # 建立线性回归模型对象 clf.fit(x_train, y_train) res = clf.predict(x_test) 代码函数及参数说明见
https://scikit-learn.org.cn/view/394.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25052e1d069c98245935c9303d757220/" rel="bookmark">
			【mybatis】【mybatisPlus】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 下 mybatis、mybatisPlus Mybatis的作用配置数据源和mybatis的配置 Mybatis的作用 Mybatis就是帮助程序员将数据存取到数据库里面。
MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) --&gt;对象关系映射
所有的事情，不用Mybatis依旧可以做到，只是用了它，会更加方便更加简单，开发更快速。
配置数据源和mybatis的配置 在application.properties\application.yaml属性配置文件中配置数据源和mybatis相关配置
# 端口号 server.port=8080 # mapper xml 文件地址 mybatis.mapper-locations=classpath*:mapper/*Mapper.xml # 数据库url spring.datasource.url=jdbc:mysql://localhost:3306/kgc?springboot_db?serverTimezone=UTC # 数据库用户名 spring.datasource.username=root # 数据库密码 spring.datasource.password=root # 数据库驱动 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 或者
# 配置数据信息 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC username: root password: root @EqualsAndHashCode
@Accessors
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4cbc8e9e05f10d6417bb4b85e4bb636/" rel="bookmark">
			旋转框目标检测mmrotate v1.0.0rc1 之RTMDet训练DOTA的官方问题解析整理（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Batchsize和学习率问题 1、关于rotated_rtmdet_l-coco_pretrain-3x-dota_ms.py配置文件的batchsize和学习率设置 问题： 回答： 2、不同batchsize下s2anet的mAP #59 问题： 回答： 3、关于lr和batchsize的问题 #645 2、如何进行多尺度测试？ #201 3、为什么相同的物体分类分数相差很大？ #455 问题： 回答： _base_ = ['./roi_trans_r50_fpn_1x_dota_le90.py'] data_root = 'datasets/split_ms_dotav1/' angle_version = 'le90' img_norm_cfg = dict( mean=[123.675, 116.28, 103.53], std=[58.395, 57.12, 57.375], to_rgb=True) train_pipeline = [ dict(type='LoadImageFromFile'), dict(type='LoadAnnotations', with_bbox=True), dict(type='RResize', img_scale=(1024, 1024)), dict( type='RRandomFlip', flip_ratio=[0.25, 0.25, 0.25], direction=['horizontal', 'vertical', 'diagonal'], version=angle_version), dict( type='PolyRandomRotate', rotate_ratio=0.5, angles_range=180, auto_bound=False, rect_classes=[9, 11], version=angle_version), dict(type='Normalize', **img_norm_cfg), dict(type='Pad', size_divisor=32), dict(type='DefaultFormatBundle'), dict(type='Collect', keys=['img', 'gt_bboxes', 'gt_labels']) ] data = dict( train=dict( pipeline=train_pipeline, ann_file=data_root + 'trainval/annfiles/', img_prefix=data_root + 'trainval/images/'), val=dict( ann_file=data_root + 'trainval/annfiles/', img_prefix=data_root + 'trainval/images/'), test=dict( ann_file=data_root + 'test/images/', img_prefix=data_root + 'test/images/')) model = dict(train_cfg=dict(rpn=dict(assigner=dict(gpu_assign_thr=200)))) 4、检测细长物体的困难 #384 问题： 回答： def gen_single_level_base_anchors(self, base_size, scales, ratios, center=None): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4cbc8e9e05f10d6417bb4b85e4bb636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2bbec0622e297031ddd419831fbf18/" rel="bookmark">
			基础快速排序（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路解释：
如果起始位置l小于结束位置r，执行以下操作：定义变量i、j和x，分别表示子序列的起始位置、结束位置和基准元素。通过一次扫描，将比基准元素小的元素放在基准元素的左边，将比基准元素大的元素放在基准元素的右边。这一步骤使用两个指针i和j，分别从序列的两端开始向中间移动，找到需要交换的元素，并进行交换，直到i和j相遇。将基准元素放到最终的位置，即a[i]的位置。递归调用Quick_Sort函数，对基准元素左边的子序列进行排序，起始位置为l，结束位置为i-1。递归调用Quick_Sort函数，对基准元素右边的子序列进行排序，起始位置为i+1，结束位置为r。 #include &lt;stdio.h&gt; void Quick_Sort(int a[], int l, int r) { if (l &lt; r) { int i, j, x; i = l; j = r; x = a[i]; while(i&lt;j) { while (i&lt;j &amp;&amp; a[j]&gt;x) { j = j-1; // 从右向左找第一个小于x的数 } if (i &lt; j) { a[i] = a[j]; // 将小于x的值放在左边 i=i+1; } while (i &lt; j &amp;&amp; a[i] &lt; x) { i = i + 1; // 从左向右找第一个大于x的数 } if (i &lt; j) { a[j] = a[i]; // 将大于x的值放在右边 j = j - 1; } } a[i] = x; Quick_Sort(a, l, i - 1); Quick_Sort(a, i+1, r); } } int main() { int arr[] = { 30,40,60,10,20,50,2,3,4,5,1,2,4,6,7 }; Quick_Sort(arr, 0, 14); for (int i = 0; i &lt; 14; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f2bbec0622e297031ddd419831fbf18/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/74/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>