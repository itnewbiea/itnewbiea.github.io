<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d145d2cdaac6df7b189647946d1195/" rel="bookmark">
			【读博感悟】关于读博期间科研训练的想法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近看到一个问题：“国内追求发文章的博士教育是舍本逐末吗”，分享一些关于读博的看法。
博士生涯对思维的训练远远胜过选择了一个什么样的课题。博士论文对人类的知识贡献虽小但却意义重大。获得博士学位就如同学会如何射击，一旦你知道如何射击，你就可以一直射击，直到你击中它为止。因此在获得博士学位时不一定要产生巨大的影响力，那就如同第一次开枪就能击中靶心一样困难，学术影响力应该是毕生研究的奋斗目标。
每种培养模式的形成都有其历史和环境因素，是不是舍本逐末不好评价，但我想从自身角度谈一下关于读博的看法。
博士生涯的训练 在决定读博之前，我一直很想了解读博到底要干什么。通过阅读他人的经验分享，包括导师角度和学生角度，我逐渐了解到读博是怎样一个过程。正如犹他大学的Matt Might教授在其总结的《读博失败的10大常见原因》中所提到的：“你的博士学位是什么并不重要，重要的是你能拿到一个，因为博士生涯对思维的训练远远胜过选择了一个什么样的课题。博士论文对人类的知识贡献虽小但却意义重大。获得博士学位时就能产生巨大影响力，就如同第一次开枪就能击中靶心，影响力应该是学生毕生研究的奋斗目标。一旦你知道如何射击，你就可以一直射击，直到你击中它为止。”
读博对一个人最大的训练是思维上的训练，遇到一个问题后，可以通过查阅文献资料，找到问题本质所在，然后据此设计实验、完成实验，进而分析数据和现象，以验证自己的思路，最终提升对该问题的认识。
一旦掌握这样的能力，将不会局限于某一个具体领域的问题，因为这是认识世界的通用方法论。所以我意识到，具体的方向似乎并没有那么关键，最重要的是能拿到一个博士学位，当然研究方向需要在合理的范围内，要保证在有限的时间内能够毕业。
除了思辨能力，管理能力保证自己能够在规定时间内完成足够的项目和工作量，表达能力让自己能够将所做的工作清晰地展示给他人，心理调节能力保证自己能够更加从容地发挥出个人的潜力，这些都将是获得博士学位时受益终生的财富。
学术期刊给出的建议 前段时间写期刊文章时，从期刊给的模板里学到的一句话，在这里给大家分享一下：
Your paper should describe very clearly your accomplishments so other people can understand what your original contribution is and use it. Notice that usually your technical accomplishments will be evaluated based on the number of citations but not based on the number of papers published.
您的论文应非常清楚地描述您的成就，以便其他人了解您的原创性贡献并加以利用。请注意，您的技术成就通常会根据引用次数进行评估，而不是根据发表论文的数量。
我觉得这句话非常清楚地描述了发文章的出发点：那就是为了“便于他人了解您的原创性贡献，并加以利用”。在这个过程中，他人会引用你的文章，所以技术成就是根据引用次数来评估的。但是现实的情况大家应该有所体会，这里借鉴《三体》中的一句话：“现实的引力太沉重了。”只能说，希望各位看到这个问题的博士生能够不忘读博的初心、不留遗憾。
推荐一些关于读博的优质文章 如果你正在犹豫要不要读博，或即将开始读博，亦或正处于刚开始读博的迷茫期，我这里有一些之前收藏的文章，希望能对你有所帮助。如果对读博的话题感兴趣，也欢迎私信一起交流。
《一个人读博失败的10大常见原因》——犹他大学计算机科学教授Matt Might施一公院士：《如何做一名优秀的博士生》读博很孤独？过来人告诉你怎么办Nature:《读博之前应该知道的二十件事情》一位博士生接受怎样的训练才是完整, 全面的科研训练？硕博研究生期间应该明确的50件事科研笔记：学习和科研——科学网"彭思龙"的博文“更新”自己，我硕博生涯的一些经验对工科类博士研究生开展科学研究的几条建议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b7b0b2f579667faa42832846d1f2fc/" rel="bookmark">
			C语言文件fopen函数 fclose函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件目录 文件的打开和关闭操作流的函数三种不同的格式化输入输出函数解释标准流所有流字符 文件的打开和关闭 文件打开函数 fopen
FILE * fopen ( const char * filename, const char * mode ); 返回值：打开成功返回一个指向要打开文件的文件信息区的文件指针,打开失败返回NULL
传入参数：
1：要打开的文件名
引用文件名这里，可以使用相对路径和绝对路径
相对路径：
**.**表示当前文件所在路径
** . . **表示当前文件的上层路径
//当前路径的上层路径的hehe文件夹的test.txt文件 FILE* pf = fopen("./../hehe/test.txt","w"); 绝对路径：
//test.txt所存在的绝对位置 FILE* pf = fopen("C:\\Users\\hui\\Desktop\\test.txt", "w"); 如果不加路径直接使用文件名打开，它的默认打开路径是当前源文件所在的位置
FILE* pf = fopen("test.txt", "w"); 2：打开的方式
文件关闭函数 fclose
这个函数是配合文件打开函数一起使用的，每当打开一个文件不再使用后就必须进行关闭操作
int fclose ( FILE * stream ); 返回值：
关闭成功返回0.失败返回EOF
传入参数：
关闭的文件指针
操作流的函数 从指定的流中读取一个字符，后标记指针自动向后移动一位，并返回对应的ASCii值，读取失败会返回EOF
字符输⼊函数 fgetc
int fgetc ( FILE * stream ); 字符输出函数 fputc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b7b0b2f579667faa42832846d1f2fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8092eb4a9c7580e7872a019bd06571/" rel="bookmark">
			python pygbag教程 —— 在网页上运行pygame程序（全网中文教程首发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pygame是一款流行的游戏制作模块，经过特殊的方式编译后，可以在浏览器web网页上运行。web上的打包主要使用第三方模块pygbag。
pygame教程：Python pygame(GUI编程)模块最完整教程（1）_pygame模块详解_Python-ZZY的博客-CSDN博客
1 pygbag简介 pygbag是经过官方认可的一个第三方模块，专用于编译pygame使其在网页上运行。该网址演示了一个经过pygbag打包的pygame程序：Minesweeper by Python ZZY -China。
注意：在国内访问itch和github速度可能较慢，通常要加载很久。（建议开VPN） pygbag打包后文件经过压缩，占用较少的空间。pygbag应用首次加载速度较慢，后面的速度会变快。
需要注意的是：pygbag依赖于Chrome内核的浏览器（如google, firefox），否则无法正常运行
pygbag源码：GitHub - pygame-web/pygbag: python and pygame wasm for everyone ( packager + test server + simulator )
2 安装 通过pip即可安装：
pip install pygbag 需要注意的是，pygbag依赖于一大堆的第三方库，所以强烈建议安装和使用都在虚拟环境中进行。
3 规范 进行打包的python-pygame程序文件夹中必须包含一个main.py文件（或者不使用文件夹而是一个单独的程序文件），作为应用运行的进入点。并且程序中的主循环必须以异步的形式进行，在进行异步的循环之前，最好提前定义常量、导入素材，以避免出现网络错误。
注意事项如下：
pygbag依赖于Chrome内核的浏览器（如google, firefox），否则无法正常运行需要包含一个main函数，并且是异步的形式可以在main函数的外面导入模块或导入一些必要的素材文件，这样能避免一些网络错误。素材中需要在pygame中播放的声音文件必须为*.ogg格式调用pygame.display.flip或pygame.display.update刷新pygame屏幕时，必须加上await asyncio.sleep(0)这一句。如果使用了3D/WebGL，打包时需要添加选项：--template noctx.tmpl在代码中使用time.sleep, pygame.time.wait是无效的，必须使用await asyncio.sleep(...)来替代 下面的例子叙述了代码的规范，读者可查看其中的注释：
import asyncio import pygame as pg # 在此处一次性定义所有常量，以便于编译 WIDTH = 700 HEIGHT = 300 # 如果有附带文件（图片、声音等素材文件），则在此处载入（可通过缓存lru_cache），以避免网络错误 # 在pygame播放的声音文件必须为*.ogg ... async def main(): pg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8092eb4a9c7580e7872a019bd06571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57efc3d723542c138f617760f8c492c/" rel="bookmark">
			Linux用户与权限（认知root用户、修改权限控制 - chmod、修改权限控制 - chown）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 认知root用户
1.1 什么是root用户（超级管理员）
1.2 用户切换命令
1.3 sudo命令
1.3.1 为普通用户配置sudo认证
2. 用户、用户组管理
2.1 理解用户、用户组的概念
2.2 掌握用户、用户组管理的相关命令
2.2.1 用户组管理
2.2.2 用户管理
3. 查看控制权限
3.1 查看Linux文件的权限管控信息
3.2 读、写、执行三种权限的含义
4. 修改权限控制 - chmod
4.1 chmod命令
4.2 权限的数字序号
5. 修改权限控制 - chown
1. 认知root用户 1.1 什么是root用户（超级管理员） 无论是Windows、MacOS、Linux均采用多用户的管理模式进行权限管理。
在Linux系统中，拥有最大权限的账户名为：root（超级管理员）
而在前期，我们一直使用的账户是普通的用户：itheima
root用户拥有最大的系统操作权限，而普通用户在许多地方的权限是受限的。
例如当我们使用普通用户在根目录下创建文件夹，会出现如下情况：
而若是切换到root用户后，继续尝试，如下：
注意：
普通用户的权限，一般在其HOME目录内是不受限的
一旦出了HOME目录，大多数地方，普通用户仅有只读和执行权限，无修改权限
1.2 用户切换命令 su和exit命令
su命令就是用于账户切换的系统命令，其来源英文单词：Switch User
语法：su [-] [用户名]
- 符号是可选的，表示是否在切换用户后加载环境变量（后续讲解），建议带上
参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root
切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl + d
注意：
使用普通用户，切换到其它用户需要输入密码，如切换到root用户
使用root用户切换到其它用户，无需密码，可以直接切换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57efc3d723542c138f617760f8c492c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0da51fb35ce6d4ab4a720a793a2c387/" rel="bookmark">
			python 文件查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取文件信息 代码如下（示例）：
import os path = r'C:\Windows\System32\calc.exe' print(os.path.dirname(path)) #获取目录名称 print(os.path.basename(path)) #获取基本名称 二、查找文件 代码如下（示例）：
##### 查找文件 import os import argparse def search_file(dir_path, filters) : print("search begin！！！！") # print("search files begin in dir {}".format(dir_path)) for cur_dir, sub_dir, files in os.walk(dir_path) : for file in files : if os.path.splitext(file)[1] in filters : file_abs_path = os.path.join( cur_dir, file ) print( file_abs_path[len(dir_path):] ) print("search end！！！！") def search_namefile( a , b ): for root,dirs,files in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0da51fb35ce6d4ab4a720a793a2c387/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28417176b60a352448c48eae5b635b20/" rel="bookmark">
			python 常见文件的加密与解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、代码1 代码如下（示例）：
import win32com.client, os, time from PyPDF2 import PdfFileWriter, PdfFileReader ###################### 对word加密 def word_encryption(path, password): # 若加密保存.docx时，覆盖原文件，则无法成功添加密码。但是保存为另一个文件名，则可以添加密码。 # 因此将A存为B，删A，再将B改为A。 dirname, tempname = os.path.split(path) path_temp = os.path.join(dirname, tempname) while os.path.exists(path_temp): tempname = f'{len(tempname)}' + tempname path_temp = os.path.join(dirname, tempname) def w_encryption(fp, pt, pw): word_app = win32com.client.Dispatch('Word.Application') word_app.Visible = 0 word_app.DisplayAlerts = 0 doc = word_app.Documents.Open(fp, False, False, False, '') doc.SaveAs2(pt, None, False, pw) doc.Close() word_app.Quit() w_encryption(path, path_temp, password) os.remove(path) # 删除原文件 os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28417176b60a352448c48eae5b635b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e53eac479accd1ec1614b6382153c5a/" rel="bookmark">
			python 指定word生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.代码 代码如下（示例）：
from docx import * import pandas as pd import re def datetime(): b = [] a = list(pd.date_range(start='2022-12-23', end='2023-01-31').strftime("%Y-%m-%d")) for i in range(len(a)): b.append( re.sub("-", ".", str(a[i])) ) print(b) # print(a) # a=list(map(str,a)) # print(len(a)) return b def dealrows(date): document = Document() table = document.add_table(40, 7, style="Table Grid") for i in range(40): if i == 0 : heading_cells = table.rows[i].cells heading_cells[0].text = '消毒时间' heading_cells[1].text = '楼层' heading_cells[2].text = '消毒剂' heading_cells[3].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e53eac479accd1ec1614b6382153c5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f951a56c5abf6d42e9dd59740b5b9032/" rel="bookmark">
			解决安装torchvision时import报错ImportError: cannot import name ‘PILLOW_VERSION‘ from ‘PIL‘ 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在anaconda环境下安装pytorch1.2.0版本和torchvision0.4.0。安装成功之后尝试import包：
我的配置版本：
win10
python 3.7
cuda 10.0
pytorch 1.2.0
torchvision 0.4.0
pillow 9.5.0
查阅资料看是由于pillow版本太高，将pillow版本降低后解决问题：
pip uninstall pillow
pip install pillow==6.2.2
重新安装低版本的pillow后成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d531171c4864ee19fed59bd111a4ed2/" rel="bookmark">
			win11用vmware 15.5pro虚拟机一开机直接蓝屏，以及 VMware Authorization Service服务重启的完美解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列出可能的原因一一排除：
1.电脑没有打开CPU虚拟化
查看电脑是否开启CPU虚拟化
在任务管理器（CTRL+SHIFT+ESC）中
可以看到已启用，因此排除这个问题。
2.VMware 版本过低
由于15.5pro无法直接免费升级17，所以需要先卸载干净15.5。
前两步参考这一篇：VMware彻底卸载_vmware卸载-CSDN博客
第三步遇到问题，无法在控制面版删除软件。
直接进入第四步看：删除包含VMware产品的文件夹，参考这一篇（注意任务管理器里VM相关进程必须全部关闭才能把文件清理干净！）如何将VMware Workstation卸载干净(详解)_vmware workstation怎么卸载-CSDN博客
最后重新安装VM17：VMware Workstation 17 Pro的下载&amp;&amp;安装&amp;&amp;使用-CSDN博客
又出现问题：虚拟机VMware Authorization Service未能启动
VMware Authorization Service 这个服务甚至不在服务列表里，需要以管理员的身份创建一个
这里有个大坑，就是一定到以管理员身份启动CMD，否则无法创建！！！！
sc create VMAuthdService binpath= "C:\Program Files (x86)\VMware\VMware Workstation\vmware-authd.exe" 服务成功创建！
重启虚拟机试试看：成功！
希望对你有帮助~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd8b2aa448f9033a354962c1c8d0981/" rel="bookmark">
			C语言结构体相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文的编译环境为 Visual Studio 2022
结构体 何为结构体？结构体变量声明全局声明局部声明隐式声明结构体重命名 结构体变量的四种初始化方式结构成员访问操作符结构体自引用结构体传参结构体内存对齐对齐规则内存对齐的意义 何为结构体？ 结构体是一种自定义类型，是多种数据类型的集合。它和数组很像，不过数组里面是存储单一类型的成员变量集合，而结构体里面可以放整形，浮点型，字符型，数组，指针等一系列不同数据类型的成员变量。
struct是定义结构体类型的关键字，下面这个就是结构体的基本形式：
struct S//(结构体名字可以自己定义) { //成员列表 int age; char name[20] ; float score; short class; }student;//变量列表 结构体变量声明 全局声明 声明一个全局的结构体变量 student，全局有效。
struct S { int age; char name[20]; float score; short class; }student; int main() { return 0; } 局部声明 声明一个局部的结构体变量 student,只在mian函数里有效。
int main() { struct S { int age; char name[20]; float score; int class; }student; return 0; } 隐式声明 结构体的隐式声明就是把结构体的名字给省略不写，但造成的后果就是结构体只能声明一次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd8b2aa448f9033a354962c1c8d0981/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a716c161948a2a980226e0be65261d7/" rel="bookmark">
			人工智能和图搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是人工智能？ 环顾四周，你会发现人工智能并没有一个明确且单一的定义。有人说，“人工智能被定义为对理性主体的研究”，其中“理性主体可以是任何做出决策的人、公司、机器或软件。它在考虑过去和未来后执行具有最佳结果的行动”。当前感知（代理在给定实例下的感知输入）”。其他则更哲学地试图找到人类自然智能和机器能做的事情之间的界限。
但所有的定义都试图说明，人工智能实际上是一门学科，当你想知道该做什么而你不知道该做什么时。这里出现了一个理性代理，通过一些传感器感知环境并查看它已经执行的旧操作，它尝试选择具有最佳结果的下一个操作。 那么让我们看一个经典的寻路问题。我们有一个包含许多节点的图，您尝试找到两个节点之间成本最小的路径。这是人工智能代理的定义。你并不完全知道路径是什么，而理性主体通过感知环境（在我们的例子中是图表）会找到该路径。
但我们知道有很多算法能够解决图搜索问题。只需查看 DFS、BFS、Dijkstra 或A*即可。我们中的一些人从高中就知道这个算法。那么这里有什么新内容呢？这真的是人工智能代理所做的吗？嗯，是的，但不仅如此。人工智能不仅仅是一种编程范式，就像图搜索算法一样，而且，正如我之前所说，它是对理性主体的研究，这些理性主体研究环境并尝试选择具有最佳结果的行动。
AI 代理是一个广义的术语。它们涉及机器学习、神经网络、深度学习等等，并应用于金融、医疗机构、安全等领域。所以图搜索只是人工智能的一个小子类型。
经典的图搜索算法和能够找到两个节点之间最短路径的人工智能代理之间的区别只是术语的不同。理解这一点很重要，就像你试图创建一个与老式算法实际上没有什么不同的人工智能代理一样。
所有这些算法的要点是，在访问一个节点后，我们必须选择下一个未访问的节点并“访问”它，以查看是否达到目标。
更多关于 BFS 正如我之前所说，广度优先搜索是一种基于树的算法。它的名字来源于图遍历是分层的想法。从源节点开始，我们首先探索邻居，然后进一步向下移动。
我们看下图：
从节点 A 开始，我们看到这个图如何变成一棵树。
A 是位于第 0 层的起始节点，然后 B 和 C 位于第 1 层，然后 D 和 E 位于第 2 层。这就是 BFS 遍历该图的顺序。
如果我们使用 BFS 遍历该图，顺序将是：A -&gt; B -&gt; C -&gt; D -&gt; E。
仔细观察这棵树，我们会发现 B 和 C、E 和 D 之间存在一些联系。发生这种情况是因为我们的图包含循环。但如果我们想最优地遍历它，我们不应该再次访问已经访问过的节点。因此，选择要访问的节点的条件之一就是未被访问。
算法如何工作 考虑到，在访问起始节点之后，我们将继续访问它的所有邻居，然后我们将进入下一个“层”，并且需要一个队列。当我们访问一个节点时，我们检查它的邻居，如果尚未访问邻居，我们将它们添加到队列中。然后，我们实际上只是从队列中选择下一个要访问的节点。我们需要做的另一件事是标记已访问的节点，以便不再访问它们。这样，我们将只访问所有图节点一次。
因此，使用该算法，如果起始节点和目标之间至少存在一条路径，我们就能够找到任何节点。 寻找成本最低的路径 让我们通过在顶点上添加一些成本来更改我们的图。
现在我们想从A到D走成本最低的路径。我们看到从 A 到D有多种方法。我们可以走这条路径，A -&gt; B -&gt; D，成本为 20，或者我们可以选择 A -&gt; C -&gt; B -&gt; D，成本较低，为 16。但是还有另一条成本最低的路径3、A -&gt; C -&gt; E -&gt; D。 那么，我们应该怎么做才能找到这条路径呢？我们需要改变获取下一个节点访问的方式。在经典的BFS算法中，我们采用先进先出的队列顺序（先进先出）来选择下一个要访问的节点。我们最终会找到目标，但不是最便宜的路径。为了以最低的成本到达路径上的目标，我们需要改变从队列中获取下一个要访问的节点的方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a716c161948a2a980226e0be65261d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3243c215a1da7510e8603ff6017777c9/" rel="bookmark">
			Ubuntu20.04 制作系统ISO镜像并物理机还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装软件-Systemback 1.如果已经添加过ppa，可以删除重新添加或者跳过此步 sudo add-apt-repository --remove ppa:nemh/systemback 2.添加ppa 我是ubuntu20，但这个软件最后支持的是 ubuntu16.04版本，所以加一个16版本的ppa
sudo add-apt-repository "deb http://ppa.launchpad.net/nemh/systemback/ubuntu xenial main" 出现下面问题：
W: GPG 错误：http://ppa.launchpad.net/nemh/systemback/ubuntu xenial InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY 14E4942973C62A1B
解决：
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 14E4942973C62A1B 3.更新仓库并进行安装 sudo apt update sudo apt install systemback 下面是安装界面：
第二步：打开软件进行.sblive镜像制作 1. 启动 #启动systemback sudo systemback 2. 创建Live系统 之后进入：
其中工作目录：镜像存放地址；Live模式系统名称：镜像名称；包含用户数据文件：除了那些系统的，其他比如document就是用户数据文件。最后点击“创建新的”。
然后遇到了这种bug：
查看终端：
emm感觉数据文件有问题，我决定不再勾选，包含数据文件
点击创建新的
进度正常：
安装完成：
创建完成！
第三步、 创建iso文件 这里如果是小于4G的xxx.sblive文件可以直接在界面上点击Convert to ISO转成ISO文件，如果是大于等于4G的镜像，需要按以下步骤转换成ISO文件。
步骤1：解压 .sblive 文件 来到home文件下（上图，刚才选择的工作目录）
打开终端：
sudo mkdir sblive sudo tar -xf my_computer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3243c215a1da7510e8603ff6017777c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9584adb357e8b92c6c45653694203438/" rel="bookmark">
			基于51单片机的8路抢答器proteus仿真 汇编语言程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件设计 上一篇讲了基于C语言的抢答器，下边讲一下基于汇编语言的抢答器。
仿真图：
程序设计 OK EQU 20H ;抢答开始标志位 RING EQU 22H ;响铃标志位 DATA0 EQU 36H ;抢答按键口数据存放地址 ORG 0000H AJMP MAIN ORG 0003H AJMP INTT0 ORG 000BH AJMP T0INT ORG 001BH AJMP T1INT ORG 0040H MAIN: MOV R1,#14H ;初设抢答时间为20s MOV R2,#1EH ;初设答题时间为30s MOV 38H,#3CH ;启用锦囊时间从60s倒计时 MOV TMOD,#11H ;设置未定时器/模式1 MOV TH0,#0F0H MOV TL0,#0FFH ;越高发声频率越高,越尖 MOV TH1,#3CH MOV TL1,#0B0H ;50ms为一次溢出中断 SETB EA SETB ET0 SETB ET1 ;允许二个中断,T0/T1 CLR OK CLR RING SETB TR1 SETB TR0 ;一开始就运行定时器,以开始显示FFF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9584adb357e8b92c6c45653694203438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ae71a3604d27e8ec91b96ccf2ad6b0/" rel="bookmark">
			解决“该虚拟机似乎正在使用中”问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 在用VMware虚拟机的时候，有时会发现打开虚拟机时提示“该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按“获取所有权(T)”按钮获取它的所有权。否则，请按“取消©”按钮以防损坏。配置文件: D:\win10\Windows 10 x64.vmx”出现这一情况是由于虚拟机未正常关闭引起的。
当我们点击“获取所有权(T)”按钮，会发现弹出一个窗口提示无法打开虚拟机: D:\win10\Windows 10 x64.vmx获取该虚拟机的所有权失败。主机上的某个应用程序正在使用该虚拟机。配置文件: D:\win10\Windows 10 x64.vmx。”等信息。这说明获取所有权失败了。
当点击“取消©”按钮是直接退出窗口，什么也不弹出。这时候发现不管点哪个按钮都不能解决我们的问题。
二、解决步骤 1、找到配置文件的路径（也就是弹出提示窗口上的路径），在这里是D:\win10这个目录下。
2、找到后缀为.lck文件夹。
3、将后缀为.lck的文件夹删除，或者或避免删错可以移动到备份文件夹中，也可以直接重命名此文件夹，在这里我将文件夹Windows 10 x64.vmx.lck改为Windows 10 x64.vmx.lck.backup。
4、重新打开虚拟机，发现此虚拟机可以正常打开了。
亲测有效，大家如果遇到这类问题不妨按照上面的解决步骤试一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8519d9be01c65842d5cd6c42240843d/" rel="bookmark">
			milkv-duo交叉编译环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 GitHub - milkv-duo/duo-buildroot-sdk: Milk-V Duo Official buildroot SDK
CV180X/CV181X SDK 编译及使用说明 ‒ SDKCompilationandUsageGuide master 文档
过程 创建docker环境 docker run -it \ --privileged=true --cap-add=ALL \ --name milkv_env \ -v /home/luo/locke/milkv_duo:/work \ -v /lib/modules:/lib/modules \ -v /dev:/dev \ ubuntu:20.04 /bin/bash 安装基本环境 apt update apt install git wget sudo vim rsync pkg-config unzip dosfstools mtools e2fsprogs genext2fs sudo apt-get install build-essential ninja-build bc wget curl git gcc slib automake autoconf libtool libssl-dev squashfs-tools android-sdk-libsparse-utils android-sdk-ext4-utils jq cmake python3-distutils tclsh scons parallel tree python3-dev python3-pip device-tree-compiler libssl-dev cpio squashfs-tools fakeroot libncurses5 flex dosfstools bison 拉取源码 git clone https://ghproxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8519d9be01c65842d5cd6c42240843d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/062079d68e77583f42b79719ffdc82c2/" rel="bookmark">
			翻墙工作？承德程序员被罚款 108 万元！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，随着互联网的快速发展，远程办公成为越来越多公司和个人的选择。很多国外的远程办公公司也在中国和其他各个国家招收员工。
然而，最近一则承德程序员因远程办公被罚款100万的新闻引起了广泛关注。这个程序员给一家软件公司打工，工作内容是开发开源软件。
这必不可避免使用 ZOOM 软件进行远程会议，使用 github 提交代码，使用 support 回答用户问题，而使用这其中的一些软件是需要 fan q 的。
但是，承德公安局对他进行了罚款，以“违法所得”为由没收了他 3 年的收入，共 1058000 元。
fan q 本身违法吗？ 很多人以为 fan q 本身不违法，只要不传播 fan q 工具和以此盈利就不违法。
但是在中国，“翻墙”是违法的。
根据《中华人民共和国计算机信息网络国际联网管理暂行规定》第六条：计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。
如违反上述规定，公安机关会责令停止联网，给予警告，可以并处 15000 元以下的罚款；有违法所得的，没收违法所得。
因此，如果你需要进行远程工作，可以向公司申请开通国际互联网专线，合法连接境外网络，三大运营商都有此类服务提供。
什么是违法所得？
然后，对于怎么定义违法所得，引起了很多人的思考？翻墙上班违法吗？翻墙使用 油管账号分享视频获取广告收入违法吗？
很多人就说了，996 的“违法”所得，需要没收吗？更可气的是，很多人 996 都没有收入。
但是，
根据中国的法律法规，违法所得是指行政相对人从事违反国家法律、法规规定的活动，即实施了国家法律、法规禁止的行为，或未履行法定义务的所获得的利益。
对于违法所得的认定，可以依据《工商行政管理机关行政处罚案件违法所得认定办法》进行计算，基本原则是以当事人违法生产、销售商品或者提供服务所获得的全部收入扣除当事人直接用于经营活动的适当的合理支出，为违法所得。本办法有特殊规定的除外。
一句话，没事，别 fan q，如确实有需要，申请专线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086f409111a7116c3e0aee229b1796bf/" rel="bookmark">
			umi4中的配置问题，我想用umirc.ts中alias配置没起作用。是我的用法不对吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在文件中直接配置是不生效的
alias: { '@': '/src', 'components': '/src/components', '@components': '/src/components', }, 解决：
具体查看官方文档：https://umijs.org/docs/api/config#chainwebpack
配置之后，在页面中引用会有ts警告，原因在于tsconfig.ts文件的配置，需要在插件中修改tsconfig的配置。
官方文档查看：https://umijs.org/docs/api/plugin-api#modifytsconfig
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79337947d9fb71f77dc7539cfa3225c/" rel="bookmark">
			深度学习基础学习-深度可分离卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里仅仅介绍自己关于这方面的了解，大佬绕道
1 普通卷积 我们采取不同的卷积核对输入进行卷积，学习到了对于每个通道的输入特征，最后进行整合，得到了多通道的特征信息，也就是说融合了单通道卷积核的特征信息与多通道之间的联系，即空间与通道的融合。
这是一个最基础的卷积，将输入通过四个不同的滤波器，得到对应的输出，接下来我们对其进行扩展
（1）单纯增加输入通道数
单纯增加我们输入特征的通道数（比如隐藏层的输出很高如192层，作为下一层的输入，那么其通道数也会很大），对应滤波器的通道数也会增加
(2)增加滤波器个数
增加滤波器个数则会令输出特征的通道数增大，从而导致参数量的上升。
（3）参数量的计算
如果上述的两个维度分别都做了2倍的变换，那么最后总的参数量则是原来的四倍。
上述所说是最传统的卷积方式，随着深度学习的发展，我们意识到网络的加深有助于性能的提升，但与此同时带来的也是参数量的上涨，于是才有了以下的发展
2 逐深度卷积（depthwise conv） 重点：逐深度卷积是将通道进行分组
2.1 将输入通道分为两组 接着按照上面的例子，如果针对输入通道数过多的情况，我们先将输入通道单独的分为两组
那么这里的滤波器对应的通道数将是原来的一半（滤波器个数不变），输入通道进行分组后，这里的滤波器也分为了两组，第一组滤波器对应第一组的输入，第二组滤波器对应第二组的输入，最后将分组的两个通道整合在一起。
2.2 第一组分组进行卷积 这里可以明显看到，滤波器的深度只和当前组的深度相同，而不是整个输入的深度。滤波器个数仍然是对应最后的输出通道数，唯一不同的即第一个分组只收集了前四个滤波器的特征，而没有后面四个；第二组只收集了后四个滤波器的特征。
2.3 第二组分组进行卷积 这样一来，我们分两组完成了整个卷积过程。
2.4 将所有通道单独分为一组 这就是对应的深度卷积，但是这样的深度卷积存在明显的问题。
2.5 深度卷积存在的问题 2.5.1 每一组分组只对应一个滤波器的特征 这个问题其实在前面两个分组的时候提到过，当我们将通道数分为两组的时候第一个分组只收集了前四个滤波器的特征，而没有后面四个；第二组只收集了后四个滤波器的特征。这个问题在二分组的时候可能不明显，但是对于每个通道都单独分组的情况下，这个缺陷尤为明显，我们的每个分组对应一个通道，一个通道只对应一个滤波器，也就是说，第一个输出特征只依赖于第一个输入特征，我们无法得到像没有分组情况下的能得到全部表达能力的情况。
分组卷积每个通道上可以获取不同的特征信息，但是缺点是只能获取对应单通道的信息。
这种情况下的分组卷积其实是丧失了一部分表达能力的，每一组通道只对应一个滤波器的特征信息，所以接下来引出了深度可分离卷积，其核心思想是加入了逐点卷积，也就是我们常说的1x1卷积，1x1卷积最重要的部分即可以不改变空间上的信息，但是却能获取所有通道上的信息，我们通过这个特殊的特征，可以做到通道上的信息融合，从而弥补分组卷积的缺陷。
3 逐点卷积（点对点卷积，pointwise conv） 重点：逐点卷积是通道上的信息融合，即它不改变空间上的任何信息，而能获取所有通道上的信息
逐点卷积按字面理解即1x1卷积，关于1x1卷积可以参考1x1卷积的作用
如下图所示
一个输入2通道的3x3特征，经过4个1x1卷积后，不改变其空间上的大小，在通道上将其扩展到了4通道。
那么此处逐点卷积做到的就是通道上的信息融合，但是不改变空间上信息。
如上图所示，点对点卷积的方式，不改变空间上的信息，但是却能获取所有通道的信息
4 逐深度可分离卷积 按照字面理解，深度可分离卷积即深度卷积+逐点卷积，同时做到空间与通道上的信息融合，同时大大的降低了参数量。
按前面所说，基于分组卷积的方式，丧失了部分表达能力，我们通过1x1卷积能进行通道融合的方式，将空间与通道结合，弥补了分组卷积信息缺失的特点。
对比上述两个图
第一个是分组卷积，可以获取空间上的信息（输入通过3x3卷积对应中间层的一个像素点，正好可以对应后文的1x1卷积），但是缺无法获取通道融合的信息第二个是深度卷积，对于空间上的信息只能获取一个像素点的信息，但是却能融合所有通道的信息 将上述两个部分进行融合，即可得到我们的深度可分离卷积
5 深度可分离卷积参数量计算 5.1 普通卷积 5.2 深度可分离卷积 其中第一个式子没有了N通道数，而转为了1x1卷积获取通道信息
5.3 参数量比较 假设输出通道数为256，卷积核大小是3x3，那么采用深度可分离卷积的参数量将是原来的0.12
6 深度可分离卷积的实验结果 针对这个结果，表明对应特征通道数越多的情况下，我们的加速速度更加快，也就是参数量减少的更多
参考资料 深度可分离卷积的前世今生
1x1卷积的作用
逐深度可分离卷积
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c79337947d9fb71f77dc7539cfa3225c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe9215039549c084f92713d62342c18/" rel="bookmark">
			Oracle 千万级表的优化思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.表分区：减少查询的数据量，从而减少I/O操作。
2.适当的索引：查询频率、索引数量。
3.视图：用来放经常查询的结果，还可以减少服务器计算的开销。
4.并行处理：加快查询速度，受制于CPU。
5.压缩：压缩表、索引，减少存储空间的使用，也能提高I/O性能。
6.SQL调优：表连接方式、子查询、关键字等，可参考：
快速入门到精通：一篇学会Oracle_一碗折耳根的博客-CSDN博客
7.数据库参数配置：SGA/PGA、日志、缓存都卡大表的脖子
8.升级硬件：增加内存，用更好的磁盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b3cd8141da3ba9b879dece7f2542d0/" rel="bookmark">
			电脑提示错误代码0xc000007b该怎么解决，几种解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0xc000007b是一类较为常见的错误，如果你的电脑提示错误代码0xc000007b，不用惊慌这个问题其实很好解决。今天小编就针对这一问题给大家整理一些解决错误代码0xc000007b的几种方法。希望能够帮助到大家。一起来看看吧。
一.错误代码0xc000007b的常见原因 1.一些电脑病毒会攻击系统文件，就会导致文件被病毒感染。从而提示错误代码0xc000007b窗口。
2.Windows系统无法处理运行应用程序所需的某些设置。
3.文件的位置被更改或文件被删除也可能是因为本身存在文件损坏的问题。
4.用户的电脑是运行32位的操作系统的，但运行的应用程序只适用于在64位操作系统中运行，用户强制运行就会导致自己的电脑无法加载这一应用程序，出现错误代码0xc000007b，毕竟勉强是没有幸福的。
二.解决错误代码0xc000007b的方法 解决办法一：暂时禁用防病毒软件 如果您安装了第三方防病毒软件，建议您卸载它，具体步骤如下：启动Windows 10计算机，右键点击开始，选择应用和功能，之后选择第三方杀毒软件，点击卸载即可。若您没有安装第三方软件，也可以参考此处的方法暂时禁用Windows Defender。禁用之后，请再次执行出现错误提示前的操作，查看问题是否解决。若问题已解决，建议再次开启Windows Defender或者下载其他与当前系统版本更兼容的第三方杀毒软件以保护电脑免受恶意软件的攻击。
解决方法二:更新系统 出现错误代码0xc000007b的原因可能是因为windows过久没有更新，导致电脑版本和文件不兼容。并且长时间没有更新会导致文件出现错误，可以通过更新windows的方式将文件一起修复。在更新的过程中也是在进行补丁。
如果你使用的是Windows 11，你可以通过打开设置(使用Windows+i)，选择左侧的“Windows更新”，然后点击右侧的“检查更新”来检查和安装最新的更新。
在Windows 10上，你会打开设置(通过按Windows+i)，选择“更新与安全”，然后点击“检查更新”。
一旦你安装了可用的更新，重新启动你的电脑，你的问题可能会得到解决。
解决方法三：使用电脑修复精灵 如果上面的几个办法没有解决代码错误的问题可以试着用电脑修复精灵进行文件的修复，这个办法也是非常的简单，简单的几步就可以解决错误代码0xc000007b的问题。
首先可以在浏览器顶部输入：电脑修复精灵.site，然后可以选择按回车键前往，
进入后找到错误代码修复工具，找到后选择这个工具，点击下载按钮将这个工具进行下载安装。
下载安装完后在在将工具打开，打开后选择一键修复，就可以开始对电脑进行检查扫描。
扫描结束后点击一键修复，电脑中的有问题文件都会一键给你进行修复。
以上小编整理的关于错误代码0xc000007b的解决办法，如果你想了解更多，可以持续关注小编。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc906ba9e90cf9e734eff283869e358/" rel="bookmark">
			Oracle自治事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般在创建存储过程的时候都会加上：
PRAGMA AUTONOMOUS_TRANSACTION
使用场景：
1.在存储过程中执行多个操作时，可以使用自治事务来确保每个操作都能正确提交或回滚。
2.当存储过程需要执行长时间的操作时，可以使用自治事务来确保该操作不会被其他操作阻塞。
而不使用也许会导致以下问题：
1.操作失败：假如各个操作有数据依赖关系，不使用自治事务，当某个操作失败回滚，可能会导致其他操作也失败回滚。
2.数据不一致：有多个用户同时读写数据时，造成数据不一致的显示。
举例：
CREATE OR REPLACE PROCEDURE P_TEST(I_DATE VARCHAR2, O_NAME OUT VARCHAR2) IS
PRAGMA AUTONOMOUS_TRANSACTION;
将存储过程执行中所有的操作放在一个独立的事务中进行，如果发生异常或错误，整个事务都将回滚，从而保证数据的一致性和完整性。
关于存储过程更多的使用请见：
快速入门到精通：一篇学会Oracle_一碗折耳根的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5990c9881a39dffefd8123d544d311cc/" rel="bookmark">
			谈谈距离度量方式：欧氏距离与余弦距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前因 在机器学习/深度学习的很多任务中，我们通常会面临着两个样本之间相似度的比较。通常常用的两种度量方式为欧氏距离与余弦距离，那么在什么时候用欧氏距离？什么时候用余弦相似度？他们之间的联系与区别在哪里呢？
探索 在机器学习当中，通常以一组向量来表示样本
如上图所示，欧式距离是通过勾股定理来计算两个向量之间的距离：
余弦相似度是计算两个向量之间夹角的余弦值： 通常用1-D(x,y)来表示余弦距离。
分析：
首先谈谈区别，欧氏距离的范围是不确定的(没有经过归一化)，得到的值可能很大(最小为0)，值越大表示样本之间越不相似，直观上的理解就是度量两个向量点之间的绝对距离（用一根绳子去连接两个点，这根绳子的长度就是欧式距离）。而余弦距离不考虑向量大小，只关注角度关系，取值范围[-1,1]，当两个向量方向完全一致时取1，完全相反时取-1。可以这么说，欧氏距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异。
接下来谈谈两者的缺点与应用场景，欧氏距离尝尝收到维度诅咒，当研究对象的维度很高时(通常深度网络输出一个高维向量)会受到影响，导致范围不固定，含义也比较模糊。余弦距离虽然没有受到维度诅咒，但其并没有考虑到向量的大小，只考虑了方向。
所以，应用何种距离度量函数取决于具体的应用场景：当数据维度较低，或者向量的大小很重要时采用欧氏距离，比如在分析房价时，考虑小区绿化面积与房屋面积为特征，两个样本(1000,100)与(500,50)，若采用余弦距离会认为这两个房子价格较近，这肯定是不合理的。当数据维度较高（很难判断各维度之间的具体含义），或者为稀疏向量，又或者是更关于两者的相对差异时采用余弦距离：比如分析用户行为来构建推荐系统，A用户购买向量为(1,0)，B用户购买向量为(0,1)。
这里的应用限制不一定对，具体情况具体分析。比如，当维度高的时候，欧氏距离也可能效果更好。
最后谈谈它们的联系，如果我们将向量归一化后执行欧氏距离，其与余弦距离等价。公式证明见下：
来自参考链接[1]
这里通过画图可以更简单地理解，当向量执行归一化后变为单位向量，欧式距离就是求单位向量之间的距离，余弦距离求夹角的余弦值：
其中两个向量用红线表示，紫线表示它们之间的欧氏距离，cosΘ为余弦距离，由余弦定理可知，两者存在反比关系。
更多的度量方式见参考链接2
扩展 余弦距离是否是严格意义上的距离？
距离的定义：在一个集合中，如果每一对元素均可唯一确定一个实数，使得三条距离公理（正定性，对称性，三角不等式）成立，则该实数可称为这对元素之间的距离。
这里简单提一下，后续有时间再补充。余弦距离满足正定性和对称性，但是不满足三角不等式，因此它并不是严格 定义的距离。
参考 [1] 数据科学中常见的9种距离度量方法，内含欧氏距离、切比雪夫距离等
https://zhuanlan.zhihu.com/p/350744027
[2] 欧氏距离和余弦相似度的区别是什么？
https://www.zhihu.com/question/19640394/answer/207795500
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c116f89ea9f0c92de935cff7f734897/" rel="bookmark">
			antd vue DatePicker 日期选择框限制仅能选择当月日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：在项目开发时，有A、B两个页面，A页面是列表页，按照年与月进行搜索；B页面是详情页，按照年月日搜索，但是年月是根据每条明细进行变化的。如：该条明细是2022年1月的，详情页仅能选择2022年1月的日期。
DatePicker 代码实例 限制勾选范围为当前月份 // 限制勾选范围为当前月份 &lt;template&gt; &lt;a-range-picker :value="hackValue || value" :disabled-date="disabledDate" // 新增该属性 @change="onChange" @openChange="onOpenChange" @calendarChange="onCalendarChange" /&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { Dayjs } from 'dayjs' const disabledDate = (current: Dayjs) =&gt; { const monthStart = dayjs().startOf('month') // 当前月第一天 const monthEnd = dayjs().endOf('month') // 当前月最后一天 return monthStart &gt; current || current &gt;= monthEnd } &lt;/script&gt; 限制范围为指定日期的当前月份 // 限制范围为指定日期的当前月份 &lt;template&gt; &lt;a-range-picker :value="hackValue || value" :disabled-date="disabledDate" :default-picker-value="defaultPickerValue" // 绑定初始值 /&gt; &lt;/template&gt; &lt;script lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c116f89ea9f0c92de935cff7f734897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295a5db6695ace6479bbd4bf61aa18cd/" rel="bookmark">
			微信公众平台怎么添加秒杀活动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众平台是一个非常有用的工具，它可以帮助企业或个人建立自己的品牌形象，增加用户粘性，提高销售业绩等等。在微信公众平台上添加秒杀活动为主题可以吸引更多的用户关注，促进销售，提高品牌知名度等。下面我们将介绍如何在微信公众平台上添加秒杀活动为主题写一篇1000字的文章。
一、明确活动目的和主题
在添加秒杀活动为主题之前，必须明确活动的目的和主题。例如，为了增加销售额，吸引更多用户关注等。同时还需要确定秒杀活动的具体细节，例如活动的时间、地点、参与方式、奖品设置等。
二、设计活动页面
在设计活动页面时，应该考虑到用户的使用体验。活动页面应该包括活动的详细介绍、参与方式、秒杀规则、奖品展示等内容。同时还需要在页面上添加二维码或链接等方便用户快速参与。
三、发布活动信息
在发布活动信息时，应该尽可能地扩大活动的曝光率。可以通过微信朋友圈、微信群、微信公众号等社交媒体渠道来传播活动信息。同时还可以利用其他媒体渠道来宣传，例如微博、抖音等。
四、制定活动规则
制定秒杀活动的规则是非常重要的，它直接影响到活动的公正性和透明度。规则应该包括活动的时间、地点、参与方式、秒杀方式、奖品设置等详细信息。同时还需要在活动页面上公开规则，方便用户了解和参与。
五、设置奖品和奖项
秒杀活动的奖品和奖项也是吸引用户参与的重要因素之一。可以根据不同的产品或服务设置不同的奖品和奖项，例如折扣券、礼品等。同时还需要在活动页面上展示奖品和奖项，以吸引更多用户的关注和参与。
六、准备客服团队
由于秒杀活动涉及到用户的资金安全等问题，所以需要准备客服团队来解决用户的问题和疑虑。可以在微信公众号上添加客服联系方式，例如客服电话、客服邮箱等，方便用户联系客服团队解决问题。
七、开始秒杀活动
当秒杀活动准备就绪后，就可以开始活动了。在活动期间，需要保持微信公众平台的稳定性和可访问性，以避免因访问人数过多而导致的服务器故障等问题。同时还需要密切关注用户的参与情况和反馈，及时调整活动方案，提高用户满意度。
八、公布结果和兑奖
在秒杀活动结束后，需要公布活动的结果和中奖者名单，并按照承诺兑奖。可以通过微信公众号向用户推送消息或是在微信朋友圈中公布中奖者名单等方式来公布结果。同时还需要按照承诺兑奖，保证活动的公正性和透明度。
九、总结活动效果和经验
在秒杀活动结束后，需要对活动的效果和经验进行总结和分析。可以通过数据统计和分析来评估活动的效果，例如参与人数、销售额、新增用户数量等指标。同时还需要针对活动中出现的问题和不足之处进行总结，以便在未来的活动中更好地发挥。
总之，添加秒杀活动为主题的微信公众平台可以吸引更多的用户关注和参与，提高销售业绩和品牌知名度。在组织秒杀活动时，必须明确活动的目的和主题，制定合理的规则和奖品设置，准备好客服团队并保持微信公众平台的稳定性和可访问性。最后需要对活动的效果和经验进行总结和分析，以便在未来的活动中更好地发挥。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ddeae217dcd303491608e7e43a78e1/" rel="bookmark">
			转载好的文章2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总的Disruptor 的使用场景 disruptor 史上最全之3： 8大使用场景详细图解_disruptor应用场景-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41d63528093605cd06c0954a939df59/" rel="bookmark">
			C# 通过Process.Start(@“C:\Windows\System32\osk.exe“)调用系统软键盘，提示无法找到文件路径解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Window10、Window11中，通过文件资源管理器打开C:\Windows\System32\osk.exe路径可以打开软键盘，但是无法在C#中，通过Process.Start(@"C:\Windows\System32\osk.exe")对软件盘进行调用。
有以上困扰的朋友可以尝试下面的代码，亲测有效！！！
using System.Runtime.InteropServices; public static bool isShowNumBoard = false; [DllImport("kernel32.dll", SetLastError = true)] public static extern bool Wow64DisableWow64FsRedirection(ref IntPtr ptr); [DllImport("kernel32.dll", SetLastError = true)] public static extern bool Wow64RevertWow64FsRedirection(IntPtr ptr); //在需要触发软件盘的函数中，放入try中的内容 private void button_keyborad_Click(object sender, EventArgs e) { try { //判断软键盘是否进程是否已经存在，如果不存在进行调用 Process[] pro = Process.GetProcessesByName("osk"); //说明已经存在，不再进行调用 if (pro != null &amp;&amp; pro.Length &gt; 0) return; IntPtr ptr = new IntPtr(); bool isWow64FsRedirectionDisabled = Wow64DisableWow64FsRedirection(ref ptr); if (isWow64FsRedirectionDisabled) { Process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41d63528093605cd06c0954a939df59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34eb4ca4a57c3b5e323c147463a40f64/" rel="bookmark">
			使用内网穿透实现公网VNC远程桌面Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. ubuntu安装VNC2. 设置vnc开机启动3. windows 安装VNC viewer连接工具4. 内网穿透4.1 安装cpolar【支持使用一键脚本命令安装】4.2 创建隧道映射4.3 测试公网远程访问 5. 配置固定TCP地址5.1 保留一个固定的公网TCP端口地址5.2 配置固定公网TCP端口地址5.3 测试使用固定公网地址远程 总结 前言 实现ubuntu 系统桌面级别的远程连接,需要在ubuntu 系统中安装vnc,既然是桌面,前提是需要ubuntu 带有图形化界面,如果没有,可以执行以下命令安装图形化界面
sudo apt install ubuntu-desktop sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal sudo reboot #重启即可看到图形界面 1. ubuntu安装VNC 在ubuntu中安装vnc
sudo apt-get install x11vnc 安装LightDM【LightDM从设计上就是支持本地图形界面以获得最好的兼容性】
sudo apt-get install lightdm 安装过程中会出现以下选项,选择lightdm然后回车即可
设置密码,设置密码后,会问你是否需要将密码保存在:/home/root1/.vnc/passwd,输入y确认即可
x11vnc -storepasswd 2. 设置vnc开机启动 创建一个x11vnc.service文件
sudo vim /lib/systemd/system/x11vnc.service 按i键进入编辑模式,添加如下信息,!!注意: &lt;USERNAME&gt;替换为您ubuntu用户名,添加完成后按Esc键退出编辑,然后输入冒号:wq保存
[Unit] Description=Start x11vnc at startup. After=multi-user.target [Service] Type=simple ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/&lt;USERNAME&gt;/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34eb4ca4a57c3b5e323c147463a40f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334aef933cf6bc92516d2f562473a056/" rel="bookmark">
			unordered_set&#43;unordered_map&#43;字符输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提高oj运行时间效率： ios::sync_with_stdio(false); 关于字符输入： char arr[100]; gets(arr); //字符串输入 cout&lt;&lt;arr&lt;&lt;endl; cout&lt;&lt;strlen(arr)&lt;&lt;endl;// 字符型 unordered_set: set会自动去除重复元素
unordered_set&lt;int&gt; ms; ms.insert(1); ms.insert(2); ms.insert(3); // find() 函数如果没有找到会返回结束位置的迭代器(地址) unordered_set&lt;int&gt;::iterator pos = us.find(1); //查找值为1的元素 if (pos != us.end()) { us.erase(pos); } //遍历1 for(auto x:ms){ cout&lt;&lt;x&lt;&lt;" "; } //遍历2 for(auto iter=ms.begin();iter!=ms.end();iter++){ cout&lt;&lt;*iter&lt;&lt;" "; } unordered_map: unordered_map&lt;int, string&gt; um; //插入键值对方式一 um.insert(pair&lt;int, string&gt;(1, "one")); um.insert(pair&lt;int, string&gt;(2, "two")); um.insert(pair&lt;int, string&gt;(3, "three")); //插入方式2 {}创建一个 一维向量 um.insert({4,"four"}); // 插入键值对方式3 um.insert(make_pair(6,"b")); //遍历方式一：范围for for (auto e : um) { cout &lt;&lt; e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/334aef933cf6bc92516d2f562473a056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfaa064596b7b96d9031a265e83dd391/" rel="bookmark">
			Linux操作系统作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cat命令加行号显示文件/etc/issue的内容。 [root@localhost example]# cat -n /etc/issue
1 \S
2 Kernel \r on an \m
3 2.使用more命令查看文件/etc/man_db.conf的内容。
[root@localhost example]# more /etc/man_db.conf\
3使用less命令查看文件/etc/man_db.conf的内容。
[root@localhost example]# less /etc/man_db.conf(进入文件查看)
4使用head命令查看文件/etc/man_db.conf前15行的内容。
[root@localhost example]# head -n -15 /etc/man_db.conf
5将/usr/bin/passwd中的内容使用ASCII方式输出。
[root@localhost example]# od -t c /usr/bin/passwd
6将当前目录设为/root.
[root@localhost example]# cd
7执行 echo pwd&gt;&gt;pwd.sh命令，了解命令产生的结果。
将内容（pwd）追加到文件末尾
8查看文件pwd.sh的权限。
[root@localhost ~]# ls -l pwd.sh
-rw-r--r--. 1 root root 4 9月 25 21:06 pwd.sh
9执行./pwd.sh，能否执行，为什么？
[root@localhost ~]# ./pwd.sh
bash: ./pwd.sh: 权限不够
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfaa064596b7b96d9031a265e83dd391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36320707215917ff321b5af7a6a75957/" rel="bookmark">
			电脑出现错误代码0x8004005应该如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当Windows出现错误代码0x80004005时，应该如何解决，今天给大家介绍几种能够解决错误代码0x8004005的方法，来看看有什么好的办法可以帮助你解决吧。
一.解决办法 第一种解决方法：命令提示符修复 1.首先使用快捷键“Win标+R”键，打开运行。在根据以下内容进行输入，
2.然后如果你要修复的文件在E盘，那就输入：chkdsk e： /f，如果修复的文件在C盘，那就输入：chkdsk c： /f，代码格式为：chkdsk 盘符： /f
3.然后按下回车键进入，等待命令运行完成后，问题即可解决。
第二种解决办法：使用电脑修复精灵 这个方法能够快熟有效的解决错误代码的问题，只需要在浏览器顶部输入：电脑修复精灵.site，按下回车键就可以进入。
进入后选择错误代码修复工具，点击黄色按钮，根据提示进行完成。
完成后将工具打开，打开后可以选择一键修复，点击一键修复就可以将错误代码进行修复。
第三种解决方法：使用自动修复 1.双击桌面的此电脑找到文件所在盘，例如：E盘。
2.然后右键“E盘”，选择属性。
3.之后点击上方的“工具”选项栏。
4.然后点击“检查”。
5.在检查中点击“扫描驱动器”。
6.等待扫描完成后即可进行修复。
第四种解决办法：运行Windows更新疑难解答 Windows更新疑难解答是Windows系统内置的一项系统更新排查工具，它能够帮助用户排查到系统更新过程中遇到的多数问题并修复。由于Windows更新出现问题也可能导致0x80004005错误，因此可运行Windows更新疑难解答尝试解决问题。
1.运行计算机，同时按下键盘里的Windows+I键以打开设置界面。之后点击进入到更新和安全选项中。
2.在左侧功能栏里找到疑难解答，之后在右侧选中Windows更新选项，并点击运行疑难解答按钮。等待片刻，待疑难解答完成之后查看问题是否已解决。
若Windows更新疑难解答未能解决问题，请打开此电脑，跳转到C：\Windows\SoftwareDistribution\Download路径，将该文件夹中的文件删除，之后再次尝试Windows更新操作。
二.错误代码原因 电脑没有正确注册某些动态链接库文件，或者电脑和Internet之间存在不允许的HTTPS连解的防火墙。
电脑防火墙问题，在启用共享访问的时候提示错误代码0x80004005，导致无法正常启用共享访问。
电脑打印机设置出错，导致适用于共享打印机时，系统出现的0x80004005错误代码。
以上就是0x80004005错误的修复方法。如果以上方法都未能解决您的问题，请仔细回想一下错误发生之前是否对注册表进行了更改，若有更改，请将其还原。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7837f027a892ba48efa200cbf70ba4/" rel="bookmark">
			计算机图形学——利用MFC库绘制直线（DDA算法和Bresenham算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 利用MFC库实现直线的绘制（分别使用DDA算法和Bresenham算法）
求解思路 创建MFC APP项目，选择Dialog Based模板，如下：
1. 对话框设计 利用TOOL BOX中的工具修改主对话框（如果TOOL BOX没有的话，在view中打开）
添加两个绘图框，分别对应DDA算法和Bresenham算法，ID为IDC_STATIC_DRAW_AREA1和IDC_STATIC_DRAW_AREA2
添加两个按钮，ID为IDC_BUTTON_DDA和IDC_BUTTON_BRESENHAM
添加四个文本编辑框便于输入坐标值，ID为IDC_EDIT_START1, IDC_EDIT_START2, IDC_EDIT_END1, IDC_EDIT_END2
添加静态文本框
注：修改ID需要选中对象，点击属性，然后在属性中修改ID
效果如下图：
2. 算法设计 DDA算法 算法描述略
Bresenham算法 获取起点和终点坐标：首先获取直线的起点坐标 (x0, y0) 和终点坐标 (x1, y1)
计算dx和dy：计算 dx = x1 - x0 和 dy = y1 - y0
计算p0初始值： p_0 = 2*dy - dx，这是初始的决策参数。p_k 用于决定下一个要绘制的像素的位置
Bresenham主循环：在每一步中，根据 p_k 的值来决定下一个要绘制的像素
如果 p_k 小于0，则下一个像素位于 (x_k + 1, y_k)，并且 p_{k+1} = p_k + 2*dy
如果 p_k 大于等于0，则下一个像素位于 (x_k + 1, y_k + 1)，并且 p_{k+1} = p_k + 2*dy - 2*dx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df7837f027a892ba48efa200cbf70ba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24b4412f1eebefd65e5bfa96b83f4316/" rel="bookmark">
			vue input输入框限制输入负号、数字、以及两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只能输入数字
&lt;!-- 只能输入数字，且长度最长为16位（maxlength="16"） --&gt; &lt;el-input v-model.trim="form.testA" maxlength="16" onkeyup="value=value.replace(/\D/g,'')" onafterpaste="value=value.replace(/\D/g,'')" @blur="form.testA=$event.target.value" 只能输入数字，允许输入小数点，且只能输入两位小数（正数、0）
&lt;!-- 只能输入数字，允许输入小数点，且只能输入两位小数（正数） --&gt; &lt;el-input v-model.trim="form.testA" maxlength="16" oninput="value=value.replace(/^\D*([0-9]\d*\.?\d{0,2})?.*$/,'$1')" @blur="form.testA=$event.target.value" /&gt; 只能输入数字，允许输入小数点和负号，且只能输入两位小数（正数、负数、0）
&lt;!-- 只能输入数字，允许输入小数点和负号，且只能输入两位小数（正数、负数、0） --&gt; &lt;el-input v-model.trim="form.testA" maxlength="16" oninput="value=value.replace(/^([0-9-]\d*\.?\d{0,2})?.*$/,'$1')" @blur="form.testA=$event.target.value" /&gt; 若输入中文后，在输入正确的值，值没有变化、显示上一次的值，可在@change中传入$event：
&lt;!-- --&gt; &lt;el-input v-model.trim="form.testA" maxlength="16" oninput="value=value.replace(/^([0-9-]\d*\.?\d{0,2})?.*$/,'$1')" @blur="form.testA=$event.target.value" @change="changeContent(row, $index, $event)" /&gt; changeContent(row,index,event) { this.$set(row, 'testA', event) // 赋值 } 参考地址：https://blog.csdn.net/Sweet_Waf/article/details/129661493
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ee3b52e3b75a6d6389c68899ec4ba9/" rel="bookmark">
			纯前端导出Excel并修改样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇前端导出：Vue实现导出功能（无后端配合） ，但是当时没考虑到样式的问题，后来要求导出的Excel单元格的样式也需要调整，尤其是宽度，第一想到的就是xlsx-style这个包，之前也没用过，这次用一下试着调一下宽度等样式，刚安装上就嘎嘎报错~~~，下面就介绍一下该库是使用，踩坑解决...
首先安装： npm i file-saver -S npm i xlsx -S npm i xlsx-style -S 然后引入 import * as XLSX from 'xlsx' import FileSaver from 'file-saver' import XLSXS from 'xlsx-style' 如果仅仅是为了导出，不修改样式，也就是不引入 xlsx-style 这个库 是没有问题的，但是引入了 xlsx-style之后，直接报错，项目直接跑不起来，首先报错如下： 1. Module not found: Error: Can't resolve './cptable' 解决： 只需在vue.config.js中添加如下 configureWebpack: { // 解决 Module not found: Error: Can't resolve './cptable' externals: { './cptable': 'var cptable' } } 接着还有错，
2. Module not found: Error: Can't resolve 'fs' 解决： 接着在vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ee3b52e3b75a6d6389c68899ec4ba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/240331ef437387210a3c498ec6409a11/" rel="bookmark">
			R语言常用函数整理（包括基本对象处理、字符处理、数学、统计函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Functions in R 处理数据对象的函数 length(object) 显示对象中元素/成分的数量 dim(object) 显示某个对象的维度 str() 显示某个对象的结构 class() 显示某个对象的类或类型 mode() 显示某个对象的模式 names() 显示某对象中各成分的名称 c(object, object, …) 将对象合并入一个向量 cbind(object, object, …) 按列合并对象 rbind(object, object, …) 按行合并对象 head() 列出数据框的前6行 tail() 列出数据框的最后6行 ls() 显示当前的对象列表 rm(object, object, …) 删除一个或多个对象语句rm(list = ls())将删除当前工作环境中的几乎所有对象 newobject &lt;- edit(object)fix(object) 数学函数 abs(x) 绝对值 sqrt(x) 平方根 ceiling(x) 不小于x的最小整数 floor(x) 不大于x的最大整数 trunc(x) 向0的方向截取的x中的整数部分 round(x, digits=n) 将x四舍五入到n位小数 signif(x, digits=n) 将x四舍五入到n位有效数字注意这里的有效数字包括整数位（要和round函数区分开） cos(x)、sin(x)、tan(x) 正弦、余弦、正切 acos(x)、asin(x)、atan(x) 反余弦、反正先、反正切 cosh(x)、sinh(x)、tanh(x) 双曲余弦、双曲正弦、双曲正切 acosh(x)、asinh(x)、atanh(x) 反双曲余弦、反双曲正弦、反双曲正切 log(x, base=n) 对x取以n为底的对数log(10)返回值为2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/240331ef437387210a3c498ec6409a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f95fc02b55387643c7c1cc568bedcfb1/" rel="bookmark">
			linux 救援模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.知识点
1.当我们忘记密码时，就可以用此方法进行暴力修改root密码
2.如果只是单纯的想要修改root密码，可以用 passwd root 命令进行修改
二.步骤详解
1.进入grub引导界面
2.按【e】键进入内核编辑界面--上下键向下走
3.在内核行行末（linux16行行末）追加参数【rd.break】，运用组合快捷键【CTRL+X】进入救援模式
TIP：在initrd16这一行输入[←]键进入linux16行行末
4.在救援模式输入命令如下：
1.switch_root:/# mount -o remount,rw /sysroot #以读写权限重新挂载根目录
2.switch_root:/# chroot /sysroot #改变根目录
3.sh-4.2# passwd #设置root密码，（root）可不写
[输入密码]
P.S.密码不会显示。
[确认密码]
4.sh-4.2# touch /.autorelabel #修改SElinux，否则密码修改不成功 5.sh-4.2# exit #退回上级目录，退出chroot
6.switch_root:/# reboot #重启
补充：
.autorelabel是一个隐藏文件，目的是为了重新标记SElinux文件系统，使你能成功重置root密码。
SElinux是一种内核级加强系统防火墙。
sysroot是一个逻辑根目录、一个临时根目录、不是根目录的根目录
————————————————
版权声明：本文为CSDN博主「「已注销」」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_73760816/article/details/126955091
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dda0256343dab4e0acc5c888b6b3d18/" rel="bookmark">
			知识分享 钡铼网关功能介绍：使用SSLTLS 加密，保证MQTT通信安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
为了使不同的设备或系统能够相互通信，让旧有系统和新的系统可以集成，通信更加灵活和可靠。以及将数据从不同的来源收集并传输到不同的目的地，实现数据的集中管理和分发。
通信网关完美克服了这一难题，485或者网口的设备能通过以太网或者4G无线，上传至智能物联网云平台。与计算平台相比，通信网关性价比也更高。以太网等设备的通信问题得到解决，但另一个问题也随之出现：通信链路易受网络攻击的威胁，使升级保护网络安全成为首要问题。
作为基于现代密码学公钥算法的安全协议，TLS/SSL能在工业通讯网络上保证传输安全，钡铼网关产品内置对TLS/SSL的支持，包括支持单/双向认证、X.509证书、密钥加密等多种安全认证。本文将介绍HTTPS、TLS/SSL相关知识。
1、什么是HTTPS？
超文本传输协议(HTTP)是设计用于在Web上传输内容的协议。HTTP是一种简单协议，它利用可靠的传输控制协议 (TCP) 服务来执行其内容传输功能。由于数据在传输过程中是明文传输，因此无法保证网络通信在传输过程中不被篡改，安全性受到限制。
超文本传输安全协议 (HTTPS)是在HTTP协议基础上实施TLS加密，以提高数据传输的安全性。所有网站以及其他部分web服务都使用该协议。因此，任何使用HTTPS的网站都使用 TLS加密。不同版本的TLS协议内容约定不一样，这也会给 HTTPS建立连接时需要握手协商的信息造成差异。
2、什么是SSL/TLS?
SSL/TLS协议SSL是指安全套接字层，是由网景公司在1990年推出的一种标准安全协议，简而言之，它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据，防止网络犯罪分子读取和修改任何传输信息，包括个人资料，用于在网络通信中建立Web浏览器和Web服务器之间的加密链接。
TLS（传输层安全）是IETF组织（工程任务组）在1999年将SSL3.0协议规范进行了标准化。由于SSL和TLS之间存在加密算法上的差异，因此不能互相操作，所以是两个不同的协议，可以说，是更为安全的升级版 SSL。
两者主要工作在应用层与传输层之间，可以与多种应用层协议配合。
为什么需要 SSL/TLS？
两者创建的目的都是提高网络中数据访问的安全性，因为在 http 携带需要传送的数据，数据没有任何的保护，是容易被黑客拦截下来的；使用了 SSL/TLS 之后，因为数据包经过加密，即使被黑客截获，由于黑客不知道密钥，也无法获取数据包中的信息。
3、SSL/TLS 带来的安全优势
▲机密性：TLS通讯的每次会话都会由会话密钥加密，会话密钥通讯双方协商产生。任何第三方都无法知晓通讯内容。即使一次会话的密钥泄露，并不影响其他会话的安全性。
▲完整性：使用MAC算法来保证消息的完整性，加密通讯中的数据很难被篡改而不被发现。
▲真实性是指通信的对方是可信的，利用了PKI（Public Key Infrastructure即「公钥基础设施」来保证公钥的真实性。
▲不可否认性，用TLS建立连接的时候，通讯双方可以互相检查对方的身份。在实践中，很常见的一种身份检查方式是检查对方持有的X.509数字证书。这样的数字证书通常是由一个授信机构颁发的，不可伪造。
SSL/TLS协议流程
SSL/TLS协议流程用一句话来概括：其用非对称加密的手段来传递密钥，然后用密钥进行对称加密来传递应用数据；可以最大限度保证数据传输的安全性，可以保证数据不被窃听，不会导致数据安全问题。
具体来说，SSL/TLS在工作流程有以下几步：
▲先进行一个握手阶段：
1）客户端发出请求：这一步客户端会生成一个随机数传给服务器。
2）服务器回应：这一步服务器会返回给客户端一个服务器数字证书（证书中包含用于加密的公钥），另外服务器也会生成一个随机数给客户端。
3）客户端回应：这一步客户端首先会校验数字证书的合法性，然后会再生成一个随机数，这个随机数会使用第2步中的公钥采用非对称加密算法（例如RSA算法）进行加密后传给服务器，密文只能通过服务器的私钥来解密。
4）服务器最后回应：握手结束。
▲握手结束后，客户端和服务器都有上面握手阶段的三个随机数。客户端和服务器都通过这三个随机生成一个密钥，接下来所有的通信内容都使用这个密钥通过对称加密算法加密传输，服务器和客户端才开始进行安全的通信。
5、SSL和TLS的关系与区别
TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS在SSL v3.0的基础上，提供了以下增加内容：
（1）更安全的MAC算法
（2）更严密的警报
（3）“灰色区域”规范的更明确的定义
还有人问过小编什么标准X.509证书，这次一同说吧。
X.509是密码学里公钥证书的格式标准。X.509证书已应用在包括TLS/SSL在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。X.509证书里含有公钥、身份信息（比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。我们所说的CA颁发的证书或者SSL/TLS证书指的都是符合X.509格式的证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a54958a4a293f8c442270c8a04fe061/" rel="bookmark">
			Linux创建本地yum仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：先将光盘镜像挂在到/mnt目录中
第二步：切换至/etc/yum.repos.d目录，先将公共的yum源备份至新建目录backup中（此步骤也可以省略）
第三步：在/etc/yum.repos.d目录中自定义创建一个指向本地yum源仓库的文件，并配置相关的信息，如图
第四步：清理之前的公共仓缓存，重新生成新的缓存“yum clean all &amp;&amp; yum makecache”
最后如果想测试是否安装完成，可以采用“ifdown ens33”关闭网卡，然后采用yum命令安装httpd（yum -y install httpd）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe455094cbc5b0235714d18f1b07048e/" rel="bookmark">
			C#之委托
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、简介
（一）概述
（二）类与委托
二、声明委托
三、使用委托
（一）创建委托对象
（二）使用委托
四、简单的委托示例
五、Action[T]和Func[T]委托
六、多播委托
七、匿名方法
委托时寻址方法的.NET版本。在C++中，函数指针只不过是一个指向内存位置的指针，它不是类型安全的。我们无法判断这个指针实际指向什么，像参数和返回类型等项就无从知晓了。
而.NET委托完全不同，委托是类型安全的类，它定义了返回类型和参数的类型。委托类不仅包含对方法的引用，也可以包含对多个方法的引用。
Lambda表达式与委托之间相关。当参数是委托类型时，就可以使用Lambda表达式实现委托引用的方法。
一、简介 （一）概述 C#中的委托是一个类型，它描述了一个方法的签名，即方法的参数类型和返回类型。委托可以看作是一个指向方法的引用，使得我们可以像使用函数指针一样调用这些方法。
将一个或多个方法作为参数传递给另一个方法，从而在需要时调用这些方法。实现事件处理程序。实现回调方法。实现异步编程等功能。 我们习惯于把数据作为参数传递给方法，所以，给方法传递另一个方法听起来有点奇怪。而有时某个方法执行的操作并不是针对数据进行的，而是要对另一个方法进行操作。更麻烦的是，在编译时我们不知道第二个方法是什么，这个信息只能在运行时得到，所以需要把第二个方法作为参数传递给第一个方法。
在C和C++中，只能提取函数的地址，并作为一个参数传递它。C没有类型安全性，可以把任何函数传递给需要函数指针的方法。但是，这种直接方法不仅会导致一些关于类型安全性的问题，而且没有意识到：在进行面向对象编程时，几乎没有方法是孤立存在的，而是在调用方法前通常需要与类实例相关联。所以.NET Framework在语法上不允许使用这种直接方法。如果要传递方法，就必须把方法的细节封装在一种新类型的对象中，即委托。委托只是一种特殊类型的对象，其特殊之处在于，我们以前定义的所有对象都包含数据，而委托包含的只是一个或多个方法的地址。
（二）类与委托 委托和类一样，是一种用户定义类型。但类表示的是数据和方法的集合，而委托则持有一个或多个方法，以及一系列预定义操作。可以通过一下操作步骤来使用委托。
（1）声明一个委托类型。委托声明看上去和方法声明相似，只是没有实现块。
（2）使用该委托类型声明一个委托变量
（3）创建一个委托类型的对象，并把它赋值给委托变量。新的委托对象包含指向某个方法的引用，这个方法的签名和返回类型必须跟第一步中定义的委托类型一致。
（4）你可以选择为委托对象添加其他方法。这些方法的签名和返回类型必须与第一步中定义的委托类型相同
（5）在代码中你可以像调用方法一样调用委托。在调用委托的时候，其包含的每一个方法都会被执行。
类委托声明类型声明类声明委托（类型）声明类型的变量声明类类型的变量声明委托类型的变量填充变量创建类的实例并且把他的引用赋值给变量创建委托的实例并且把它的引用赋值给变量，然后增加第一个方法使用变量使用类对象调用委托对象 二、声明委托 在C#中使用一个类时，分两个阶段：
需要定义这个类，即告诉编译器这个类由什么字段和方法组成。实例化类的一个对象 使用委托时，也需要经过这两个步骤：
定义要使用的委托。对于委托，定义它就是告诉编译器这种类型的委托表示哪种类型的方法。必须创建该委托的一个或多个实例。编译器在后台将创建表示该委托的一个类。 定义委托的语法如下：
delegate void IntMethodInvoker(int x); 关键字：delegate 返回类型：void 委托类型名称：IntMethodInvoker 签名：int x
在这个示例中，定义了一个委托IntMethodInvoker，并指定该委托的每个实例都可以包含一个方法的引用，该方法带有一个int参数，并返回void。理解委托的一个要点是它们的类型安全性非常高。在定义委托时，必须给出它所表示的方法的签名和返回类型等全部细节。
假定要定义一个委托 TwoLongsop,该委托表示的方法有两个 long型参数,返回类型为 double。可以编写如下代码：
delegate double TwoLongsOp(long first, long second); 或者要定义一个委托,它表示的方法不带参数,返回一个string型的值,可以编写如下代码： delegate string GetAString(); 其语法类似于方法的定义，但没有方法体，定义的前面要加上关键字delegate。因为定义委托基本是定义一个新类，所以可以在定义类的任何相同地方定义委托。也就是说，可以在另一个类的内部定义，也可以在任何类的外部定义，还可以在名称空间中把委托定义为顶层对象。更具定义的可见性，和委托的作用域，可以在委托的定义上应用任意常见的访问修饰符：public、private、protected等：
public delegate string GetAstring(); 定义好委托后，就可以创建它的一个实例，从而用它存储特定方法的细节。
三、使用委托 （一）创建委托对象 委托是引用类型，因此有引用和对象。在委托类型声明之后，我们可以声明变量并创建类型的对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe455094cbc5b0235714d18f1b07048e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ba74552e77abd67229f004517a81e1/" rel="bookmark">
			十六进制字符串转ASCII字符串-缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; // 函数将十六进制字符转换为对应的整数值 int hexCharToInt(char c) { if (c &gt;= '0' &amp;&amp; c &lt;= '9') { return c - '0'; } else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') { return c - 'A' + 10; } else if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') { return c - 'a' + 10; } return -1; // 非法字符 } // 函数将十六进制字符串转换为ASCII字符串（在同一个数组中） void hexStringToAsciiInPlace(char* hexString) { int len = 0; for (int i = 0; hexString[i] &amp;&amp; hexString[i + 1]; i += 2) { int highNibble = hexCharToInt(hexString[i]); int lowNibble = hexCharToInt(hexString[i + 1]); if (highNibble == -1 || lowNibble == -1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ba74552e77abd67229f004517a81e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab6cfb56e300769742144e7ba2654af/" rel="bookmark">
			微信小程序自定义按钮触发转发分享功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前置 一般正常做法如下：
&lt;button data-name="shareBtn" open-type="share" className="share"&gt;&lt;/button&gt; 通过设置按钮属性的方式来触发，然而，有时候需要手动触发。
解决方案 在一个父盒子中使用position: relative; 将 悬浮在 自定义的div中即可
代码如下：
//页面结构 &lt;view className="tool"&gt; &lt;text&gt;微信好友&lt;/text&gt; &lt;button data-name="shareBtn" open-type="share" className="share" &gt;&lt;/button&gt; &lt;/view&gt; //样式 .tool { position: relative; .... .share { position: absolute; left: 0; right: 0; bottom: 0; top: 0; opacity: 0; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c976ba968b025f7cf518418dcb9ddd/" rel="bookmark">
			BootstrapTable父子表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、案例图：
2、代码部分
3、对JavaScript部分讲解
1、案例图： 1-1、展开父表的子表图：
1-2、在父表的每一行的最前面显示一个加号，点开就是子表信息
2、代码部分 2-1HTML、
&lt;!-- 模态框 --&gt; &lt;div class="modal fade bs-example-modal-lg" tabindex="-1" role="dialog" aria-labelledby="myLargeModalLabel" id="seatModal"&gt; &lt;div class="modal-dialog seatFrame modal-lg" role="document"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;div style="display: flex;justify-content: space-between;"&gt; &lt;h2 class="modal-title" id="myModalLabel"&gt;考场信息&lt;/h2&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;考试场次&lt;span id="seatInformationNo"&gt;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;table id="trainingInformation" class="table table-striped table-hover" style="margin-top: 0px;"&gt; &lt;tbody id="seatTable"&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c976ba968b025f7cf518418dcb9ddd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f209cf31483773c6d1dd6f3a6f3d66cf/" rel="bookmark">
			电脑提示找不到msvcp71.dll丢失怎样修复，几种修复办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		msvcp71.dll 丢失的问题可能会对 Windows 系统的运行造成很大的影响。因此，一定要采取上述预防措施，今天就和大家科普一些关于msvcp71.dll丢失怎样修复的办法。希望能够帮助大家快速解决文件丢失的问题。
一.先了解msvcp71.dll丢失的原因 导致msvcp71.dll丢失的原因有很多。可能是因为软件或游戏出现了问题，里面的msvcp71.dll文件被破坏，导致的弹窗出现，也可能是因为系统长时间没更新，导致文件与程序不匹配导致文件被破坏。如果电脑被恶意文件入侵也会导致文件被破坏。恶意文件会攻击电脑中的部分文件，这样也就可能将msvcp71.dll文件破坏。等等还有一些别的原因也会导致文件出现错误，以上是最常见的几种导致文件缺失的原因。
二.msvcp71.dll丢失怎样修复 1.重新下载有问题的软件 如果是在使用某个软件时出现的文件错误提示，那可以尝试将这个软件重新下载并安装。
首先，可以再设置中找到程序，点击进入程序与功能，在页面中找到出现问题的程序
双击击该程序的图标，选择卸载，点击确认卸载程序或游戏。
在你的浏览器中搜索并下载最新版本的该程序或游戏的安装文件。需要注意找到一个官方的站点进行下载，或找到一个可靠的软件进行下载。
将软件下载后，双击下载的安装文件，按照安装向导的提示进行重新安装。
安装完成后，重新启动你的电脑并尝试运行该程序或游戏，查看是否仍然出现msvcp71.dll文件丢失的错误提示。
2.使用dll修复工具 大家需要先获得这个工具，那么如何获得呢？可以再浏览器顶部输入：dll修复.site，进入后根据提示步骤进行。DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
获得工具后将工具启动打开，你可以选择两种方式进行修复，一键修复或手动修复。
一键修复会扫描电脑中的所有文件进行扫描，找出电脑中缺失的其他文件。扫描后可以选择一键修复将文件全部进行修复。如果一键修复工没有找到msvcp71.dll文件可以选择手动修复。
手动修复搜索msvcp71.dll，搜索结果出现后点击手动修复即可将msvcp71.dll文件缺失的情况进行修复。
3.更新系统 更新系统可以将电脑中缺失的部分文件进行修复。更新也是将电脑进行补丁，大家可以查看电脑是否有需要的待更新。可以在设置的更新与安全中进行查看。
4.使用sfc 这个是电脑自带的一种系统修复，可以将电脑中出现错误的文件进行修复，大门这个方法时间会比较久，大家可以在电脑中搜索cmd，找到命令提示符。选择“以管理员的身份”打开，打开后在窗口输入：sfc/ /scannow，然后按回车键（Enter），等待检测是否有文件需要修复，如果有，系统会自动修复完成，系统修复完成后将电脑关机重启，在打开软件进行检测。查看问题是否的到解决.
电脑中如果出现msvcp71.dll文件缺失都需要大家及时去将文件进行修复，电脑中的文件需要大家去维护。如果不及时维护可能会导致电脑出现更加严重的问题。最后希望以上几种办法能够帮助到大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bacba15b22aad4bf182b3d3d255a816/" rel="bookmark">
			J-LINK J-FLASH 下载STM32单片机程序使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J-LINK J-FLASH 下载程序使用教程
-V1.0 2023.05.09
Introduction
本教程用于演示如何使用JLINK V9配套J-FLASH软件烧写更新MCU程序的教程
安装提供的 JLINK驱动程序。JLink_Windows_V722a.rar。全程默认安装，只能安装在C盘，不可安装于其它盘。
安装驱动完成后，将JLINK V9仿真器上USB口插上电脑，系统会自动识别仿真器。
JLINK下载口使用专用接口扩展板上1.25间距 4PIN连接线与目标板上J5 连接器 SWD下载口进行连接。然后目标板上电。
JLINK STLINK SWD转接板要使用配套转接板连接。转接板上有XH2.54 PH2.0 MX1.25连接器（各有6P 5P 4P），根据实际项目中使用的SWD口对应接口PIN数类型用连接线进行连接。
JLINK V9 购买厂家
https://item.taobao.com/item.htm?spm=a21dvs.23580594.0.0.4fee645eBhrX7u&amp;ft=t&amp;id=711925143009
JLINK STLINK SWD转接板购买厂家
https://item.taobao.com/item.htm?spm=a1z10.3-c.w4002-17776821439.11.5c6a53f022Mwob&amp;id=711128835630
2. 安装完成在电脑 开始 菜单找到SEGGER-J-LINK V7.22f文件夹，点击打开 J-Flash V7.22
点击 create a new project.（使用后可以在软件菜单File保存这个烧写工程，后续直接打开使用即可）
选择Target interface 为 SWD 。点击Target Device后面按钮，在弹出芯片Device中输入STM32L431.
在弹出菜单列表中选择STM32L431RC 。然后点击OK
点击 file, 点击 File/Open data file, 选择要下载的程序（格式为.hex）
点击软件target -connect 软件连接目标板
如果连接成功，下方信息栏目会显示Connected successfully
如果连接失败, 请确认目标板已上电，或重新插拔连接线与JLINK USB连接线。或关闭J-FALSH软件重新连接。
点击 Target- Manual Programming -Program F5 即可开始下载程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bacba15b22aad4bf182b3d3d255a816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbcf50f12a1e4dbfe946e0d4b19f852/" rel="bookmark">
			基于vue&#43;Element Table Popover 弹出框内置表格的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目场景：实现效果认识组件代码效果分析 封装：代码封装思路页面中使用 项目场景： 在选择数据的时候需要在已选择的数据中对比选择，具体就是点击一个按钮，弹出一个小的弹出框，但不像对话框那样还需要增加一个遮罩层，更加的轻量化，但是需要查看的数据很多需要一个列表来展示，列表的话还需要一个筛选功能。
我的思路是增加复选框列，将选择的内容插入到外部的列表中，我这里主要是分享弹出框内置列表的一个封装思路。
但是在这当中还会设计到列表、分页的方法，所以建议先搞清楚列表以及分页在来看，这些我之前的文章都有涉及。
实现效果 认识组件 老样子先根据Element的官方文档认识一下Popover 弹出框
代码 &lt;el-popover placement="right" width="400" trigger="click"&gt; &lt;el-table :data="gridData"&gt; &lt;el-table-column width="150" property="date" label="日期"&gt;&lt;/el-table-column&gt; &lt;el-table-column width="100" property="name" label="姓名"&gt;&lt;/el-table-column&gt; &lt;el-table-column width="300" property="address" label="地址"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-button slot="reference"&gt;click 激活&lt;/el-button&gt; &lt;/el-popover&gt; &lt;script&gt; export default { data() { return { gridData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }] }; } }; &lt;/script&gt; 效果 分析 这个是一个基础的Popover 弹出框，在这当中我们要用到的方法、函数有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adbcf50f12a1e4dbfe946e0d4b19f852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16f381b3c8567c735b0f79db17f13be/" rel="bookmark">
			【力扣 041. 数据流中的移动平均值 题解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		力扣 041. 数据流中的移动平均值 题解 思路解题方法复杂度Code Problem: 力扣 041. 数据流中的移动平均值
思路 在初始化时创建一个数组缓存值，sum缓存和,size缓存数组大小
解题方法 sum = sum - oldVal + newVal
复杂度 时间复杂度: O ( 1 ) O(1) O(1)
空间复杂度: O ( s i z e ) O(size) O(size)
Code class MovingAverage { int size; int length = 0; int sum; int[] nums ; /** Initialize your data structure here. */ public MovingAverage(int size) { this.size = size; nums = new int[size]; } public double next(int val) { sum = sum - nums[length % size] + val; nums[length % size] = val; length++; return (sum*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16f381b3c8567c735b0f79db17f13be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d825d12cac1c7035ffc009024284a58/" rel="bookmark">
			python判断float是否相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 float类型数据的比较不能用 == ，如果需要判断两个float数据是否相等，尽量使用差值的绝对值是否达到需要的精度。
float_a = 3.1415926... float_b = 3.1415926... if abs(float_b - float_a) &lt; 10**-8: peint(f"达到所需精度") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a291faa5d046710fa1db4723427e8967/" rel="bookmark">
			离线安装cdh6.3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离线安装cdh6.3.1（如需安装包请留言） 安装过程比较繁琐，请耐心阅读。祝您好运！
1.环境准备 三台linux服务器(安装jdk1.8+，python2.7以上)：
192.168.10.53 node-cdh1（主节点，建议cpu32c，内存64G以上）
192.168.10.54 node-cdh2（建议内存32G以上）
192.168.10.55 node-cdh3（建议内存32G以上）
各节点/opt/cloudera/parcels目录建议10G以上
下载
官方下载地址如下：
https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html（jdk已安装可省略）
https://archive.cloudera.com/cdh6/6.3.1/parcels/CDH-6.3.1-1.cdh6.3.1.p0.1470567-el7.parcel
https://archive.cloudera.com/cdh6/6.3.1/parcels/CDH-6.3.1-1.cdh6.3.1.p0.1470567-el7.parcel.sha1
https://archive.cloudera.com/cdh6/6.3.1/parcels/manifest.json
https://archive.cloudera.com/cm6/6.3.1/repo-as-tarball/cm6.3.1-redhat7.tar.gz
https://dev.mysql.com/downloads/mysql/5.7.html#downloads
http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar
1.1.设置linux主机名 各自节点执行修改主机名命令：
hostnamectl set-hostname node-cdh1 hostnamectl set-hostname node-cdh2 hostnamectl set-hostname node-cdh3 修改主机名也可编辑/etc/sysconfig/network
vi /etc/sysconfig/network
输入
NETWORKING=yes HOSTNAME=node-cdh1 每个节点上都添加以下内容至 /etc/hosts
vi /etc/hosts
192.168.10.53 node-cdh1 192.168.10.54 node-cdh2 192.168.10.55 node-cdh3 reboot重启各节点重启完成后用hostname命令查询系统主机名 1.2.关闭集群防火墙 systemctl stop firewalld &amp;&amp; systemctl disable firewalld &amp;&amp; iptables -F 1.3.关闭集群selinux vi /etc/selinux/config
SELINUX=disabled
修改成disabled之后 重启linux系统生效
1.4.设置集群时钟同步 1.4.1.所有节点设置亚洲上海时区 timedatectl set-timezone Asia/Shanghai 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a291faa5d046710fa1db4723427e8967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9243bf0e48eeb1173f511f588bc6a1/" rel="bookmark">
			ChatGLM接入微信公众号（cpolar的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，尝试 继上利用frp加上阿里云服务器，借助公网ip实现内网穿透，再加上申请域名，解析云服务器，再frp上建立http连接，但是由于阿里云免费的服务器，不支持备案，所以域名解析的服务器无法通过域名访问，所以我尝试去购买便宜的香港的服务器免去备案的麻烦，但是连接完之后，token依旧验证失败。
二，方法 2.1 解决验证问题 我的连接问题我认为很大概率是我的域名和服务器的问题，所以得找到一个替代省去麻烦，最好就是找一个内网穿透的工具，可以建立http连接并且能够提供备案域名实现连接。
2.2 cpolar的使用 我看到b站视频cpolar，这个工具可以免费进行内网穿透并提供备案域名，但是备案域名只是24h内随机域名，需要固定域名可以购买基础套餐
进入cpolar的官网
cpolar - secure introspectable tunnels to localhost
登录注册之后
按照图片要求操作，下载对应版本的cpolar，解压缩之后，连接自己的账户
./cpolar http 80
开放端口进入
实际效果应该是这样
只需要将对应的连接80端口的提供好的给你的域名，填入微信公众号验证就行，在加上token的验证代码，上一个文章也有，我粘贴部分
def wechat(): timestamp = request.args.get("timestamp") nonce = request.args.get("nonce") echostr = request.args.get("echostr") signature = request.args.get("signature") if request.method == "GET": if not all([signature, echostr, nonce, timestamp]): abort(404) li = [wechatToken, timestamp, nonce] li.sort() tmp_str = "".join(li) sign = hashlib.sha1(tmp_str.encode("utf-8")).hexdigest() if signature != sign: abort(403) else: return echostr 因为微信在给你发送验证请求的是get请求，所以分开执行后面的post发送也会比较方便
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d9243bf0e48eeb1173f511f588bc6a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ecd980b6d0ef7fe5a4e5f23eff0eb74/" rel="bookmark">
			C#中的委托和事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：什么是委托 ——委托是一种存储函数引用的类型，就像我们定义一个string str一样，这个str变量就是string类型。因为C#中没有函数类型，但是可以定义一个委托类型，把一个函数赋给这个委托，类似于C++中的函数指针
——委托的定义与类的定义类似，先定义，再声明，再创建实例，再使用，定义时需要加上delegate关键字但是不需要函数体
using System; class MainClass { //定义 delegate void Fun1Del(); //声明 Fun1Del del1; static void Main() { del1 = Fun1(); del1(); } static void Fun1() { } } ——当定义一个委托时，CLR会自动生成一个类，继承自System.MulticastDelegate，包含了构造函数、BeginInvoke、EndInvoke、Invoke，所以委托本质是一个Class。事件也类似，但是事件只对外部提供了一个add和一个remove接口，所以不能在外部调用方法
例如上面的委托例子，de1=Fun1()就相当于调用了构造函数，通过构造函数将Fun1方法的内存地址存起来。调用del1()时相当于调用了Invoke方法去调用当前存储的内存地址的方法
二：自定义委托 ​using System; class MainClass { delegate void Fun1Del(); delegate void Fun2Del(int num); delegate int Fun3Del(int num); static void Main() { Fun1Del del1 = Fun1; Fun2Del del2 = Fun2; Fun3Del del3 = Fun3; Fun1(); Fun2(11); int num = Fun3(11); } static void Fun1() { } static void Fun2(int num) { } static int Fun3(int num) { return num; } } 三：Action委托 Action是系统内置的委托类型，这样就不需要通过delegate定义委托类型，可以直接使用Action作为类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ecd980b6d0ef7fe5a4e5f23eff0eb74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdc6b07d8ef9cffd5d28ce0d0db24c5/" rel="bookmark">
			电脑advapi32.dll怎么修复，整理几种修复办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用电脑时突然出现advapi32.dll缺失的错误提示，这时候有什么办法可以解决呢?去网上找也没有找到什么好的办法，于是想起来找我的懂电脑的朋友，他给我出了几招，最后解决了advapi32.dll缺失的问题。整理一下把方法分享给小伙伴们。
一.了解advapi32.dll文件 advapi32.dll是一个高级API应用程序接口服务库的一部分，包含的函数与对象的安全性，注册表的操控以及事件日志有关。advapi32.dll是一种系统文件，在Windows操作系统中扮演着至关重要的角色。它包含了许多关键的应用程序接口，用于管理系统的安全和权限。advapi32.dll还在账户权限管理方面发挥着重要作用。它可以提供一些API来检查和修改不同账户的权限，以确保有权的用户可以执行相应操作。
二.advapi32.dll修复办法 方法一：使用注册表编辑器 1.首先打开电脑左下角搜索栏中搜索运行，然后找到运行选项，点击打开。
2.在弹出的运行对话框里输入 命令： regedit，按下回车键打开注册表编辑器。
3.打开注册表依次，找到编辑标签点击选择“查找”在文本框内输入：advapi32.dll
4.然后在下侧的列表中找到advapi32.dll错误信息，点击删除即可。
5.然后继续查找下一个，直到删除完成即可。
这个办法小编没有使用，因为这个办法容易将有用的文件删除，所以并不推荐给大家，缺失的advapi32.dll文件也有其他的小文件，有些小文件是还需要的文件，所以如果将文件一起删除会导致电脑出现其他问题。
办法二：使用系统还原 1.在电脑的左下角搜索栏中搜索：控制面板，将其打开，打开后找到系统与安全，点击进入，进入后找到系统，
2.在系统页面中的右边的相关设置中找到系统保护。然后找到创建在使用鼠标点击，在弹出的输入一个描述恢复点的名称，然后点击创建。
3.在需要的时候，你可以回到系统保护选项卡，选择系统还原按钮。选择一个你想要回复到的最近的日期，然后点击下一步。
4.在提示中，请再次确认您要还原计算机的日期和时间，并单击完成。
这个办法小编也没能使用，但小伙伴也能试着使用，小编的电脑没有创建还原点，所以大家可以试试你们的电脑有没有创建还原点，但这个办法需要大家在操作前先将重要的文件进行备份，以防重要文件丢失。
办法三：使用dll修复工具 1.可以在浏览器顶部输入：dll修复.site，然后按键盘回车键进入。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
2.进入获取一个dll修复工具，利用这个dll修复工具直接进行一键修复就可以了，
3.打开工具后使用一键修复，它会根据你电脑系统缺失了哪些dll文件，然后进行相关的修复，如你丢失了dll就会帮你修复dll文件，操作比较简单方便。
小编是通过这种办法解决的，使用这个办法小编不到五分钟就把文件解决了，我使用的是手动修复将文件文件问题解决，当然如果小伙伴们的时间充足的话可以使用一键修复，我比较懒，等系统提示在修复吧。（偷笑）
以上就是小编修复advapi32.dll的心路历程，大家也可以试试，朋友说还有其他的解决办法，如果大家先要了解的可以留言在评论区，下次给大家整理。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/52/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>