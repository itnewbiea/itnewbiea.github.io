<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e10fed8a50515161064919a2177fe23/" rel="bookmark">
			Git使用（基础超简单上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些人可能会疑惑，git到底有什么用处，为什么要学这个和技术栈没有相关的突然冒出的东西。这里简要说一下他的用处。
Git技能——一个团队合作可共同完成项目的，可共享的，可帮你自动整合队员们在同一个文件的更改形成新的版本迭代的"工具"。（以前的版本也可以找到在自己需要的时候）
我们先在这个图片的基础上了解一下我们的文件在获取和远程仓库中拉下来时 ，它在计算机内部变化情况。
Git原理分析图 一个是你编辑的地方，一个是add进去的暂存区的地方，继续的一个是commit进去的本地仓库，形式上走了一遭，其实还是在你电脑里头，但是必须这么走一波流程。
再就是push上去我们的远程仓库，也就是上去了一个代码托管中心
局域网下，就是在一些公司他们自己弄一个管理中心：GItLab。而互联网下就是有名的Gitee（国内）、GitHub（国外） Git安装 Git自己学会安装哈，百度有教程，不断下一步就是了。
然后你发现你的右键多了Git Bash / Git GUI。
Git常用命令 这些慢慢来熟悉，先看下面。
刚拿到git bash你在哪里的路径下右键启动的它，它就在哪里进行锁定这个位置上的文件进行提交还是clone下来文件下来。
首先：
初始化一下本地库： git init 这是在你特定下的路径下的文件夹中会有一个隐藏式的.git
查看本地库的状态： git status 第一次的时候工作区没文件
On branch master No commits yet nothing to commit (create/copy files and use "git add" to track) 而如果你创建一个文件在该路径下里头比如：test.txt
你再看git status一下：
On branch master No commits yet Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.txt nothing added to commit but untracked files present (use "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e10fed8a50515161064919a2177fe23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1d390becb5adec1749548dfd5053a9/" rel="bookmark">
			使用 gomonkey 遇到非 debug 模式执行失败的问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述解决方法 问题描述 基于 Golang 语言，写单元测试，使用gomonkey对于某个函数进行 Mock，遇到如下问题：
使用「正常模式」执行单元测试，Patch不生效，Mock 失败；使用「Debug模式」执行单元测试，Patch生效，Mock 成功。 说实话，看到这样的现象感觉很怪异，那么，为什么会出现这个问题呢？
解决方法 在网上搜了搜该问题及现象，发现该问题的原因是，
想要使gomonkey的Patch生效，需要关闭编译器对代码的自动优化 但是在「正常模式」下，是没有关闭编译器对代码的自动优化的；而在「Debug模式」下，dlv默认关闭了编译器对代码的自动优化。
因此，想要保证gomonkey的Patch生效，需要关闭编译器的自动优化功能。有两种方法，
方法1：go test -gcflags "all=-N -l" ，直接在go test命令行后面加上-gcflags "all=-N -l" 参数；方法2：使用 GoLand，在Go Test的配置项Go tool arguments中，配置-gcflags "all=-N -l" 参数。 除此之外，大家也可参考「资料1」和「资料2」，里面也描述了该问题的原因及解决方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65c3d40e6d099b8cf5c3743c21d08a1/" rel="bookmark">
			Python3基础- random随机小数、整数的巧用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、随机小数1.1 大于0且小于1之间的小数1.2 n,m 之间的小数 二、随机整数2.1 大于等于n 且小于等于m2.2 大于等于n 且小于m2.3 大于等于n 且小于m，步长为j2.4 序列中随机选择一个2.5 序列中随机选择j个2.6 打乱列表 总结 前言 平时写代码逻辑过程中，我们会经常用到随机小数、整数等场景。在这里我们借用内置模块random实现常见的随机数。
一、随机小数 1.1 大于0且小于1之间的小数 实现代码：
print(random.random()) 输出如下：
#!/usr/bin/env python # -*- coding: utf-8 -*- import random D:\Anaconda3\envs\py37\python.exe E:/codes/py3/espider/study/random_随机数.py 0.2691439054266863 Process finished with exit code 0 1.2 n,m 之间的小数 实现代码：
#!/usr/bin/env python # -*- coding: utf-8 -*- import random print(random.uniform(5,15)) 输出如下：
D:\Anaconda3\envs\py37\python.exe E:/codes/py3/espider/study/random_随机数.py 13.716436287857 Process finished with exit code 0 二、随机整数 2.1 大于等于n 且小于等于m random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c65c3d40e6d099b8cf5c3743c21d08a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a6a9d541ca6d4148685f333ea41bfd/" rel="bookmark">
			Android fragment介绍及基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 fragment的介绍 一 什么是fragment?
fragment是一个小的activity,点击不同的item,会显示不同的界面,这个界面就是fragment.
可以在多个activity中重复使用一个fragment,所以可以把fragment视为activity中的模块化的组成部分
二 为什么有fragment?
使页面动态灵活设计
为了让activity能更简洁地配置画面
三 fragment的特点?
1 Fragment 有自己的生命周期
2 必须委托在activity中才能运行(所以Fragment的生命周期受activity影响),当activity销毁时,fragment就没了 3 当activity运行时,可以独立操作fragment,动态增加移除一些fragment
4 fragment可以自己接收输入事件
二 fragment的基本使用步骤 此文写的是静态fragment,动态fragment请点这里
step1 new一个 Fragment,写fragment的xml
step2 Fragment.java里
1 解析fragment的xml
root = inflater.inflate(R.layout.fragment_blank1,container,false);
2 随便写点操作
step3 activity_main.xml
1 写&lt;fragment&gt;标签
2 用name属性关联上之前写的fragment.java文件名
3 加id(不然运行时会报错)
step4 多个fragment
1 添加多个Fragment.java的文件
2 activity_main.xml里再添加多个&lt;fragment&gt;标签,设置权重layout_weight
三 代码 step1 new一个 Fragment,写fragment的xml fragment_blank1.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".BlankFragment1"&gt; &lt;TextView android:id="@+id/textView" android:layout_width="match_parent" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a6a9d541ca6d4148685f333ea41bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f437955a7c387f1fa4695a72074e6ec/" rel="bookmark">
			Vue使用MathJax动态识别数学公式渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 最近公司的一个项目需求是在前端显示Latex转化的数学公式，经过不断的百度和测试已基本实现。现在此做一个记录。
2、MathJax介绍 MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。(Wiki)
3、步骤 3.1、引入MathJax 在使用MathJax之前，需要通过CDN引入, 在&lt;body&gt;标签中添加，该语句导入的是国内的CDN。vue项目则放在index.ejs下
&lt;link rel="dns-prefetch" href="//cdn.mathjax.org" /&gt; //引入速度更快 &lt;script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; 结合上面引入，在index.ejs下可以直接初始化
&lt;link rel="dns-prefetch" href="//cdn.mathjax.org" /&gt; &lt;script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; &lt;script type="text/x-mathjax-config"&gt; if(MathJax){ MathJax.Hub.Config({ jax: ["input/TeX","output/HTML-CSS", "output/PreviewHTML"], //输出格式配置：latex 解析为 DOM结构 tex2jax: { inlineMath: [['$','$']], displayMath: [ ['$$','$$'], ["\\[","\\]"] ] }, "HTML-CSS": { showMathMenu: false, // 隐藏右键菜单展示 linebreaks: { automatic: true, //超长公式换行处理（默认是false不换行） width: "80%" //设置换行的点，默认是遇到等号=换行 } }, }); } &lt;/script&gt; 3.2、配置MathJax，封装globalVariable.js文件 let isMathjaxConfig = false;//用于标识是否配置 const initMathjaxConfig = () =&gt; { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f437955a7c387f1fa4695a72074e6ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f935e374a9276a1d188da019134196e/" rel="bookmark">
			Spring创建了配置文件却找不到【IDEA】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：IDEA识别不到你创建的配置文件
解决：需要创建一个资源文件夹并标记为资源文件夹
新建一个文件夹
新建一个spring配置文件
打开顶部栏file-&gt;project Structure-&gt;model
ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8fed2bde16d8e49f51bd0d8bdb0813/" rel="bookmark">
			dayjs获取当月的第一天和最后一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用dayjs获取当月第一天和最后一天
startDate: dayjs(this.chooseMonth).startOf('month').format('YYYY-MM-DD'), endDate: dayjs(this.chooseMonth).endOf('month').format('YYYY-MM-DD'), 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01f49760efac411876f90b0c9b76857/" rel="bookmark">
			深度学习数据集整理百度云，持续更新！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习数据集 脸部数据集 CASIA-WebFace 数据集：链接：https://pan.baidu.com/s/1O5QlCTkvkq3mR0lyfNOHuA 提取码：kko7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f21ce2971cce216e037c1a77e64d6d18/" rel="bookmark">
			实例化Servlet类异常404、500错误-解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： ✖️ 检查所有配置项、程序代码，均没问题。 网页访问不定项出现 404 或者 500 错误。
✖️运行Tomcat 不会生成 target 目录。 out目录下面的 字节码文件 也不会生成。
网页中出现的错误👇👇👇 IDEA中👇👇👇 解决方案： 一、在macos中检查 是否在终端 已经启动了Tomcat 1、打开终端 - 输入"cd"+空格 然后把 Tomcat下的bin目录拖进终端 然后回车。
2、输入指令"./shutdown.sh"
3、再次尝试 启动IADE中的Tomcat
二、在windows中 修改.iml文件 1、选择工程目录下的.iml文件，删除component标签。
2、🙏重启 Tomcat
注： 在Tomcat这块 有的时候，会出现404找不到目标资源。如果，检查代码并未发现任何错误，可以尝试重启IDEA 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948de60bd48499573a00abe4d986cd0d/" rel="bookmark">
			微信小程序开发（后端 Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信使用的开发语言和文件很「特殊」。 小程序所使用的程序文件类型大致分为以下几种： ①WXML (WeiXin Mark Language，微信标记语言) ②WXSS (WeiXin Style Sheet，微信样式表) ③JS (Java，小程序的主体) 小伙伴们有兴趣想了解内容和更多相关学习资料的请点赞收藏+评论转发+关注我，后面会有很多干货。我有一些面试题、架构、设计类资料可以说是程序员面试必备！
所有资料都整理到网盘了，需要的话欢迎下载！私信我回复【111】即可免费获取
在语言方面，小程序看似重新定义了一套标准。但实际上，它们与「前端三件套」——HTML、CSS 和 Java—— 差不太多。
下面，我们就来对比一下小程序开发语言和「前端三件套」有什么异同点：
HTML 与 WXML：两者差异比较大，如果之前没有接触过 Android 开发，可能会觉得有些头疼。事实上，WXML 更像是 Android 开发中的界面 XML 描述文件，适合于程序界面的构建；而 HTML 则倾向于文章的展示 (这与 HTML 的历史有关)，以及互联网页面的构建。
WXSS 与 CSS：两者在语言上几乎没有差别，可以直接通用。
JS 文件：小程序的 JS 文件与前端开发使用的 JS 几乎没有区别，只是小程序的 JS 新增了微信的一些 API 接口，并去除了一些不必要的功能 (如 DOM)。
在语言上，小程序完全向学习成本最低的前端开发看齐，但这不代表所有前端开发者都能无缝迁移。
如果你是从前端开发转向小程序，就需要注意这两个点：
HTML 与 WXML 两种文件的构建思想差异较大，如果之前只接触过前端开发，需要一点时间才能适应 WXML 的编写方法。
虽然小程序使用的是前端语言，但不代表可以继续沿用前端的开发思想进行开发。小程序对前端开发的要求从「构建界面」升级成「开发完整应用」，前端开发需要在意识上进行转变。
1. 主要内容 springboot 后端架构构建
小程序项目构建
小程序 api 调用
后台 resetful 接口编写
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/948de60bd48499573a00abe4d986cd0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab229fa1fc2dce42418c27e946d9c69/" rel="bookmark">
			检索COM 类工厂中 CLSID 为 {000209FF-0000-0000-C000-000000000046} 的组件失败,错误: 80080005
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检索COM 类工厂中 CLSID 为 {000209FF-0000-0000-C000-000000000046} 的组件失败,错误: 80080005(CO_E_SERVER_EXEC_FAILURE) 项目中需要解析2003(.doc)格式Word, 原来使用的NPOI不支持，只能使用com组件进行解析
引用了-Microsoft.Office.Interop.Word 组件， 在本地编译和执行都没有问题，可以正常解析2003 word文档
但是部署到服务器端后，程序无法使用，度娘的各种尝试都做了，包括
DTC修改
修改组件的读取和启动权限
控制面板－》管理工具－》组件服务－》计算机－》我的电脑－》DCom配置－》找到Microsoft Word
之后
单击属性打开此应用程序的属性对话框。
单击标识选项卡，然后选择交互式用户。
单击"安全"选项卡,分别在"启动和激活权限"和"访问权限"组中选中"自定义",然后
自定义-&gt;编辑-&gt;添加NetWork Services账户 以及相应权限； 等等
但依然报上面错误
各种尝试之后解决问题办法：
运行dcomcnfg.exe打开组件服务；
依次展开"组件服务"-&gt;“计算机”-&gt;“我的电脑”-&gt;“DCOM配置”-&gt;“Microsoft Word 文档”
在组件属性的标识签页中将交互式用户选中可以解决这个问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b8e250ccd3bc587b1827f40046d818/" rel="bookmark">
			PTI：通过枢轴完成人脸投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper
PTI: Pivotal Tuning for Latent-based Editing of Real Images
2022 ACM TOGStyleGan 人脸编辑相关人脸投影 paper code
在StyleGAN中，编辑图像前，必须首先将图像投影到latent space，然后事实证明，StyleGAN的latent space在失真和可编辑性之间存在固有平衡，即图像在近似保持原始外观的情况下存在一定令人信服的可编辑性。实际上，生成器域外的图像在保留面部ID信息的情况下完成图像编辑仍然十分困难，在本文中，我们提出了一种弥补这个差距的方法。我们的方法稍微训练了生成器，以便域外图像更真实地投影到latent space。同时，将初始投影latent code充当枢轴，围绕它微调生成器，利用一个正则化项保证其身份。这种训练过程最终会使投影更加真实准确、而不影响可编辑能力。最后我们验证了方法地准确性和先进性，同时针对多种图像完成编辑展现了我们的技术。
Introduction 由于StyleGAN训练成本非常高，而且pretrained model实现了前所未有的视觉质量，所以流行的方法是冻结生成器。相比之下，我们微调生成器使其适应所需的输入图像，方法包括两个主要步骤：
（1）首先利用现有的反演方法将图像投影为可编辑的latent code
（2）利用Priotal Tuning – 微调pretrained stylegan，使用上一步找到的枢轴 (latent code)来生成图像。
关键的想法：即使生成器微调，但latent code仍然可以保持其编辑质量。我们的实验表明，微调后的生成器保留了枢轴代码的编辑能力，同时实现了前所未有的重构质量。
Method 由于StyleGan具有解耦性质，轻微和局部的调整可以使其生成效果完成更改、而不会破坏其强大的编辑能力。因此，针对给定的图像（可能在外观方面的分布是不满足要求的），我们建议在生成器域内找到其最近的可编辑点，然后将这个关键点拉向目标，对其附近影响很小。如此在满足人物的相似度的同时确保了可编辑能力。
1. Inversion 投影（反演）的目的是为Pivotal Tuning寻找到一个起点。由于StyleGan的原生latent space w具有最佳的可编辑性，同时在Pivotal Tuning期间的失真较少，我们选择了将图像inversion到w空间，而不是目前主流使用的w+空间。我们使用了现成的反演方法，本质上，通过LPIPS 感知损失函数，直接优化latent code w 和噪声向量 n来重建输入图像 x，使用噪声优化正则化项显着改善了反演质量【因为噪声正则化避免了噪声向量中包含重要信息】。 这意味着一旦 $ w_{p} $ 已经确定后，n 值在最终的视觉外观中起次要作用。优化定义如下：
w p , n = a r g m i n L L P I P S ( x , G ( w , n ; θ ) ) + λ n L n ( n ) θ : 权 重 L n : 噪 声 正 则 化 项 w_{p},n = arg\ min \mathcal{L}_{LPIPS}(x,G(w,n;\theta))+\lambda_{n}\mathcal{L}_{n}(n) \\ \theta : 权重 \ \ \mathcal{L}_{n}:噪声正则化项 wp​,n=arg minLLPIPS​(x,G(w,n;θ))+λn​Ln​(n)θ:权重 Ln​:噪声正则化项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b8e250ccd3bc587b1827f40046d818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84e8d2975538391ec821d969533f9ef/" rel="bookmark">
			docker 常见命令学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取镜像 docker pull ubuntu启动容器 docker run -it ubuntu /bin/bash [ i 交互式操作 t 终端]后台运行容器 docker run -itd ubuntu /bin/bash进入后台运行的容器 docker attack &lt;容器id&gt; [ 该方法退出会导致容器停止 ]docker exec &lt;容器id&gt; [ 该方法退出不会导致容器停止]启动一个停止的容器 docker start &lt;容器id&gt;查看容器 docker ps导出容器 docker export &lt;容器id&gt; &gt; ubuntu.tar导入容器 cat ubuntu.tar | docker import - test/ubuntu:v1删除容器 docker rm -f &lt;容器id&gt;查看容器端口 docker port &lt;容器id&gt; 查看本地镜像列表 docker images查找镜像 https://hub.docker.com 或 docker search httpd删除镜像 docker rmi &lt;镜像&gt;更新镜像 docker commit -m="update" -a="author" &lt;容器id&gt; &lt;新镜像名称：TAG&gt; [ m 提交的描述信息 a 镜像作者]构建镜像（需要使用Dockerfile） docker build -t dockername .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84e8d2975538391ec821d969533f9ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bb64f6a4cd5b12535f23ad3d3a041c/" rel="bookmark">
			qml扩展插件的创建与使用（仅C&#43;&#43;插件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前的文档，只记录了使用qml源码的Quick模块，有时很多功能无法在qml中满足，或需要对代码进行保密时，需要在C++中实现qml控件，并发布到插件库中，本次记录下qml扩展插件相关，供需要的小伙伴参考
笔者本次使用的是win10系统
一、创建插件工程 笔者使用的是QtCreator7.0.2，可以在向导中，直接创建qml扩展插件工程
工程的名称和存放位置，随便找一个
但要注意，不要出现中文、空格、特殊字符
向导模板中，会直接将一个类注册到qml中，笔者没有修改名称
导入的uri也可以修改成自己的，笔者也没有修改，直接采用默认的
注：uri是qml中，import的模块名，若是存在于多个目录中，需要使用"."分隔
笔者为测试，选择了有代表性的Qt5.15.2和Qt6.3.0
创建工程后，会生成6个文件，可以根据需要修改
二、添加一个qml控件 笔者为省事，直接就在MyItem类上修改了。
MyItem类默认继承自QQuickItem，若需要自定义可见控件，可以从QQuickPaintedItem类派生，并重新实现paint(）函数。笔者为测试，添加两个属性name、color和一个信号chartCleared、一个调用函数clearChart()
笔者的头文件修改如下
//#include &lt;QQuickItem&gt; #include &lt;QtQuick/QQuickPaintedItem&gt; #include &lt;QColor&gt; class MyItem : public QQuickPaintedItem { Q_OBJECT Q_DISABLE_COPY(MyItem) Q_PROPERTY(QString name READ name WRITE setName) Q_PROPERTY(QColor color READ color WRITE setColor) public: explicit MyItem(QQuickItem *parent = nullptr); ~MyItem() override; QString name() const; void setName(const QString &amp;name); QColor color() const; void setColor(const QColor &amp;color); //实现自定义绘制 void paint(QPainter *painter) override; Q_INVOKABLE void clearChart(); signals: void chartCleared(); private: QString m_name; QColor m_color; }; 自定义绘制的paint()函数、clearChart()函数实现如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bb64f6a4cd5b12535f23ad3d3a041c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2d62f236f3d5d5c850370870fbb6f9/" rel="bookmark">
			华为od介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、华为od是什么？二、华为od介绍1.薪资：2.待遇：3.工作内容： 总结 前言 简单地介绍一下华为od
一、华为od是什么？ 华为OD是Outsourcing Dispacth模式，是华为和外企德科联合招聘的简称。
目前华为大多数是OD招聘。OD模式也是华为提出的一种新的用工形式，每年都会从OD项目挑优秀员工转为正编。
二、华为od介绍 1.薪资： 所有OD和正式员工一样对待，没有差别，部门平时开会、评审等活动都是一起参加的，是“同薪同酬”，都是由华为的HR直接定的薪资，看的是我们技术能力。华为是大企业，能到华为上班也是有能力的，每个部门都有好多职位，是金子，在哪都会发光。薪资对华为OD也是有绝对的优势，在互联网一线的大厂中，华为的工作环境和薪资都是很好的。
2.待遇： 待遇没有差别，华为正式员工享有的保障，OD的员工同样享有。我们是为了员工长期发展，是为了更好的服务于华为，服务于华为OD员工，我们是是专门服务于OD员工的团队。
3.工作内容： 华为OD门槛很高，面试流程复杂，筛选严格，也是需要接触研发项目，体现你们的价值，OD的成本也是比较高的，不会招聘员工之后不认真地对待你们的工作内容。所以你们来了跟华为正编的员工一样必然是核心研发项目。
总结 华为OD综合来看说实话不会比华为正编员工要好很多，但是华为OD的薪资待遇也要好于市面上90%以上的互联公司，毕竟华为《财富》杂志正式发布2019年世界500强榜单！中国民营企业排名第一。公司的实力决定员工的成长和发展。而外企德科，也是一家卓越的公司。在现有的情况和经济环境下，华为OD平台很大背景很好，薪资待遇可以得到保障，而且华为又是国内所以企业中最注重技术发展的公司，可以保证在这里面技术得到全面的提供。能成为华为OD候选人的小伙伴肯定资质背景很好，有自己的判断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84aff305401d769fe89841f8a3ba8bc1/" rel="bookmark">
			​CVPR 2022 | 子空间对抗训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©PaperWeekly 原创 · 作者 | 鬼谷子
研究方向 | GAN图像生成、情绪对抗样本生成
引言 该论文是关于一篇对抗训练的文章，论文的代码已经开源。对抗训练是一种可以有效抵御对抗攻击的方法，然而其存在一个严重问题，即在训练过程中，模型会出现过拟合现象，PGD 攻击的鲁棒精度突然会下降到 0%。在该论文中，作者从一种新的优化角度来处理这个问题，作者首先揭示了每个样本的快速增长梯度与过拟合之间的密切联系，这也可以用于理解多步自适应算法中的过拟合现象。
为了控制梯度的增长，作者提出了一种新的对抗训练的方法，即子空间对抗训练，它将对抗训练约束在经过严谨提取的子空间中。实验结果显示，该方法成功地解决了这种模型过拟合问题，并显著提高了模型的鲁棒性，而且时间能耗上也比 PGD-10 小很多。
论文标题：
Subspace Adversarial Training
论文链接：
https://arxiv.org/abs/2111.12229
代码链接：
https://github.com/nblt/Sub-AT
相关介绍
对抗训练是目前抵御对抗攻击提高模型鲁棒性最有效的方法。给定一个带有参数 的神经网络 ，其中对抗训练数学形式如下所示：
其中 是一个以半径为 的范数球， 是一个损失函数。对于单步对抗训练来说，内部生成对抗样本的计算公式如下所示：
但是对抗训练一个重要的问题的在于可能会出现严重的过拟合现象，其主要原因在于参数量过大。针对这个问题，之前大多数工作关注在于神经网络训练在低维流形的本质。在低维子空间对神经网络训练可以能够在大大减小参数量的同时使得神经网络模型能够达到一个好的分类性能。
论文方法
当模型过拟合的现象出现的时候，在测试集中的模型的测试准确率会陡然下降。对抗训练时，神经网络在训练数据中获得了对抗信息，这会使得有害于模型对正常样本的泛化能力，导致正常分类准确率下降，同时也会丢失对于由 PGD 生成的新的对抗样本的泛化能力。由此可知，对抗信息的学习很难学习，它会导致神经网络在学习过程中出现巨大的波动，从而最终过拟合。
由于对抗样本学习的困难性，作者主要关注每个样本梯度的演化并通过平均梯度范数去分析模型的训练状态。作者主要在本文中去记录利用 fast 对抗训练方法去抵御 PGD-20 攻击的平均范数，可以发现当过模型的拟合现象出现时，平均梯度和准确率的会同时突然增大，这个现象也暗示着当模型的过拟合现象出现时，平均梯度范数会突然增大，导致神经网络在学习训练数据的过程中出现巨大的波动，从而导致模型的泛化能力下降。
为了进一步探究梯度增长跟过拟合之间的关系，作者更详细地记录了过拟合现象出现之后的统计数据。由下图可以发现，不管学习的多大，最终模型都会出现过拟合现象，但是一个小的学习率可以使得模型有一个更好的鲁棒性而且也会推迟过拟合现象的出现。所以，对于学习的选取时非常重要的，选取一个合适的学习率它可以通过控制平均提梯度范数的大小从而减缓模型过拟合现象。
3.1 控制梯度大小
由以上的数据分析可知，在模型的训练过程中，如何控制每个样本梯度的大小是非常重要的。论文的核心思想是在一个低维子空间里去限制对抗训练过程中的梯度的大小而不是在整个参数空间中。在该思想下，一个急需要解决的问题就是怎样获得这样一个可以进行有效对抗训练的子空间。最近的研究有研究者提出一个 DLDR 的算法，它可以有效从训练过程中提取用于优化的低维子空间，主要过程可以分为如下两步：
步骤一：在模型训练过程中采样获得模型参数向量 ，其中每个参数向量的维度为 。
步骤二：对参数矩阵 进行奇异值分解并获得有 维子空间的正交基 。
在该论文中，作者主要应用 DLDR 算法去提取可以有效对抗训练的子空间，这里需要注意的是采样模型参数的时候需要在模型过拟合出现之前。然后，在这个提取子空间里对神经网络的参数进行优化，这样可以有效缓解模型过拟合现象，并能够使模型获得更好的鲁棒性。
采样策略：对于 DLDR 算法，作者在每个训练批次中均匀采样两次。在每个采样批次中，模型将获得最好的分类性能。在训练初始阶段，由于子空间没有很好的评估出来，所以采样效果不是很好。
训练性能：如下图所示，子空间对抗训练可以很好将平均梯度范数数值在一个很低的区间里，这不仅可以有效地解决过拟合问题同时耶大大提高了模型的鲁棒性。另外，子空间对抗训练对模型学习率的选取也没有那么严苛，在一个较大学习率区间内模型学习都可以进行很好的收敛。
计算分析：子空间对抗训练的计算开销分为两部分：DLDR 和子空间对抗训练。DLDR 又包含两个步骤采样和分解，其中跟采样相比，分解的计算开销可以忽略不计。子空间对抗训练与标准的对抗训练计算开销相当。虽然子空间对抗训练的时间开销要比正常对抗训练的时间开销要大一点，但是训练效果却是要好很多。
实验结果
下表所示为不同对抗训练方法在 CIFAR-10 和 CIFAR-100 数据集上的结果。作者将子空间对抗训练方法应用于不同的基本对抗训练方法中，并从相应的训练轨迹中提取子空间。可以发现训练在 200 个的 epoch 的学习率下，Fast AT 和梯度截断 FGSM AT 仍然会遇到严重的灾难性过度拟合现象。在没有任何其他正则化技术的情况下，论文中提出的子空间对抗训练的方法可以使得模型获得更好的鲁棒性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84aff305401d769fe89841f8a3ba8bc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262dfe44c9c82d9fd3273501188c0005/" rel="bookmark">
			Qnap NAS &#43; Emby Server &#43; Kodi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目标KODI中重置emby数据库kodi emby 插件本地模式配置a. 威联通NAS开启nfs服务并配置用户映射b. Emby server配置绝对路径c. KODI Emby插件配置本地模式 我的媒体整理 目标 在威联通NAS中配置Emby Server，并在Kodi中安装并配置Emby next gen插件（我用的是kodi v19版本，代号Matrix），使其可访问NAS 中的 Emby Server中的资源。
KODI中重置emby数据库 kodi中插件选中Emby-next-gen，点击遥控器上的菜单键，在弹出的菜单中选择设置并打开，将光标移至同步，右侧子菜单中选中执行本地数据库重置并点击，在弹出的确定要重置本地Kodi数据库吗？提示框中选中是并点击，将弹出删除所有缓存的艺术图？，选中是并点击，将弹出重置所有Emby插件项设置，选中是并点击后，数据库会被重置，重置完成后弹出数据库重置已完成，Kodi现在将重新启动以启动更改，点击确定后Kodi将退出，手动重新启动Kodi。1
重新启动Kodi后，等待弹出Enable userrating sync，选中是并点击，将弹出播放模式对话框，提示信息为注意！如果选择本地模式，某些Emby功能将会丢失，例如：Emby影院模式，直接推流/转码选项和家长模式，访问计划等，选中插件（默认）并点击，将弹出选择主服务器对话框，选中列出的服务器名称（例如NASE）,将弹出请登录对话框，选中列出的用户名头像后，将会提示输入密码，使用ios appkodi remote可从手机上远程便捷的输入密码，然后点击登录，然后弹出选择要添加的媒体库对话框，选中全部后点击确定，将开始添加媒体库，等待添加完成。
kodi emby 插件本地模式配置 a. 威联通NAS开启nfs服务并配置用户映射 进入威联通网页端，控制台&gt;&gt;网路&amp;文件服务&gt;&gt;Win/Mac/NFS/WebDAV，然后点击Linux NFS服务，勾选激活NFS v2/v3 服务、激活NFS v4服务和启动manage-gids，然后点击应用。等待应用生效后，点击点击这里设置网络共享的NFS访问权，进入共享文件夹页面，点击视频文件所在的共享文件夹操作列的第二个按钮即编辑共享文件夹权限按钮，进入编辑共享文件夹权限按钮页面，首先在选择权限类别下拉框中选中NFS主机访问，然后在右下方允许访问的IP地址或域名进行用户映射配置，主机/IP地址/网络可保持默认*，也可填KODI所在设备的IP地址，安全项保持默认，Squash选项设置为读写和Squash所有用户，匿名GID可设为administrators，匿名UID按心情选择用户，然后点击应用，至此完成威联通NAS NFS 服务器设置。
b. Emby server配置绝对路径 登录emby网页端，点击页面右上角的齿轮（设置）按钮，进入设置页面，在左侧导航栏中选中服务器下的媒体库，将展开媒体库页面，依次对列出的各个合集进行如下操作：在合集封面上右击，点击弹出的菜单项编辑，然后在弹出的对话框中找到文件夹栏，依次点击各条路径，将弹出各自的选择路径对话框，在（可选）共享的网络文件夹文本框中输入nfs://192.168.xx.xx/共享文件夹名称/下面的子文件夹，例如，当文件夹为/share/CACHEDEV1_DATA/video/movies_series时，（可选）共享的网络文件夹需填写nfs://192.168.xx.xx/video/movies_series，这里的xx.xx需要更换成NAS对应的ip，然后点击确定。
c. KODI Emby插件配置本地模式 如果之前已经为KODI Emby （next gen）配置了插件模式，需要首先进行 emby数据库重置，然后在弹出播放模式对话框，提示信息为注意！如果选择本地模式，某些Emby功能将会丢失，例如：Emby影院模式，直接推流/转码选项和家长模式，访问计划等，选中本地模式并点击，然后将弹出Emby-next-gen对话框，提示信息为请确保您的Emby服务器媒体库，可以在你访问的Kodi上安装，并且您的服务器上配置了路径替换。有关更多信息，请查看Emby中Kodi的Github维基百科的常见问题解答。，点击确定，将弹出选择主服务器对话框，选中列出的服务器名称（例如NASE）,将弹出请登录对话框，选中列出的用户名头像后，将会提示输入密码，使用ios appkodi remote可从手机上远程便捷的输入密码，然后点击登录，然后弹出选择要添加的媒体库对话框，选中全部后点击确定，将开始添加媒体库，等待添加完成。
注意
经测试，并不需要在Kodi&gt;&gt;视频&gt;&gt;文件夹中添加nfs源。
我的媒体整理 问题描述：插件模式下，完成媒体库的添加后，在主界面的最上面一行我的媒体中会列出很多按标签命名的集合，显得多余，我只想保留所有电影、集合、所有电视节目、插件、Android应用这几个集合。
解决办法：进入Kodi的设置，进入位于第二行的Embuary下的媒体中心，选中左侧的媒体中心，在右侧选中并打开编辑菜单配置，将弹出主菜单对话框，稍等几秒会列出一些些项目，这些项目便对应着我的媒体中的各个集合，从上到下依次将除所有电影、集合、所有电视节目、插件、Android应用这几项之外的所有其他项目的小眼睛点击成关闭（x）状态后再点击最下方的应用设置即可。
手把手教您KODI挂载NAS上的Emby流媒体服务器！同步视频播放记录 流畅播放原盘影片！ ↩︎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b509aed0490b8732875a95c71a2ea5c4/" rel="bookmark">
			MMDetection 系列之（自定义数据管道处理增强管道）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据管道设计 遵循典型约定，我们使用Dataset和DataLoader对多个worker进行数据加载。数据集返回与模型的forward方法的参数相对应的数据项字典。由于目标检测中的数据可能不相同大小(图像大小，gt box大小等)，我们在MMCV中引入了一个新的DataContainer类型，以帮助收集和分发不同大小的数据。查看这里了解更多细节。
对数据准备管道和数据集进行分解。数据集通常定义如何处理注释，数据管道定义准备数据字典的所有步骤。管道由一系列操作组成。每个操作都接受一个字典作为输入，并输出一个字典用于下一个转换。
我们在下图中展示了一个经典的管道。蓝色的块是管道操作。随着管道的运行，每个操作符都可以向结果字典添加新的键(标记为绿色)或更新现有的键(标记为橙色)。
1、pipeline example for Faster R-CNN. img_norm_cfg = dict( mean=[123.675, 116.28, 103.53], std=[58.395, 57.12, 57.375], to_rgb=True) train_pipeline = [ dict(type='LoadImageFromFile'), dict(type='LoadAnnotations', with_bbox=True), dict(type='Resize', img_scale=(1333, 800), keep_ratio=True), dict(type='RandomFlip', flip_ratio=0.5), dict(type='Normalize', **img_norm_cfg), dict(type='Pad', size_divisor=32), dict(type='DefaultFormatBundle'), dict(type='Collect', keys=['img', 'gt_bboxes', 'gt_labels']), ] test_pipeline = [ dict(type='LoadImageFromFile'), dict( type='MultiScaleFlipAug', img_scale=(1333, 800), flip=False, transforms=[ dict(type='Resize', keep_ratio=True), dict(type='RandomFlip'), dict(type='Normalize', **img_norm_cfg), dict(type='Pad', size_divisor=32), dict(type='ImageToTensor', keys=['img']), dict(type='Collect', keys=['img']), ]) ] 对于每个操作，我们列出了添加/更新/删除的相关dict字段。
预处理
Resize
添加：scale，scale_idx，pad_shape，scale_factor，keep_ratio
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b509aed0490b8732875a95c71a2ea5c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61c17f095f11aadc1e7a97cea893540a/" rel="bookmark">
			威联通NAS配置阿里云域名和SSL证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 A. 目标：B. 购买域名C. 为域名配置DDNSa. 实名认证b. 域名解析c. 申请 AccessKeyd. 威联通配置域名 D. 为域名配置SSL证书a. 购买证书b. 证书申请c. 为域名配置证书d. 可选操作 A. 目标： 从阿里云万网购买域名；为威联通NAS配置购买的域名，即设置DDNS；从阿里云购买SSL证书；为通过域名访问威联通配置SSL证书。 B. 购买域名 登录万网，点击域名注册，输入想注册的域名名称后点击立即查询，直到找到尚未注册的域名后加入清单，然后点击域名清单，点击立即购买，跳转支付并完成支付。
C. 为域名配置DDNS a. 实名认证 要使用域名首先需要实名认证，进入阿里云工作台&gt;&gt;域名服务&gt;&gt;信息模板，如果没有显示有模板状态为模板实名成功的模板，则需要创建新信息模板，按要求填写信息后提交审核，等待审核通过（时间不超过1小时，很快）。
b. 域名解析 进入阿里云工作台&gt;&gt;域名服务&gt;&gt;域名列表，在要设置的域名列表行上点击解析按钮，跳转至解析设置，点击添加2条记录，
序号记录类型主机记录解析线路记录值TTL1A默认1.1.1.1 （随便写一个ipv4地址即可）10分钟2AAAA默认ff03:0:0:0:0:0:0:c1（随便写一个ipv6地址即可10分钟 c. 申请 AccessKey 在阿里云工作台几面右上角，将鼠标悬停至头像，将弹出下拉菜单，点击Accesskey管理，点击创建AccessKey，经验证后创建成功，之后会显示查看secret按钮，可查看AccessKey ID和AccessKey Secret
d. 威联通配置域名 进入主菜单&gt;&gt;控制台&gt;&gt;myQnapCloud 云服务&gt;&gt;My DDNS，关闭DDNS；进入主菜单&gt;&gt;Container Station&gt;&gt;创建，搜索aliyun-ddns，安装sanjusss/aliyun-ddns，其中在container设置页面向下滑，点击高级设置，环境选项页中AKID和AKSCT分别填入上一步申请的AccessKey ID和AccessKey Secret，DOMAIN填入购买的域名名称，网络选项页的网络模式选择Host，然后点击创建。1
在Container Station&gt;&gt;总览界面中点击sanjusss/aliyun-ddns，显示有如下样式的日志便表示配置成功。 [05/11/2022 22:08:43]当前公网IPv4为 xxx.xxx.xxx.xx（xxxx接口）。 [05/11/2022 22:08:44]当前公网IPv6为 240e:xxx:xxx:xxxx:xxxx:xxxx:xxxx:xxxx（xxxxxxxx接口）。 [05/11/2022 22:08:44]成功获取xxxxx的所有记录，共2条。 [05/11/2022 22:08:44]A记录xxxxxx。 [05/11/2022 22:08:44]AAAA记录xxxxxx D. 为域名配置SSL证书 a. 购买证书 阿里云&gt;&gt;产品&gt;&gt;安全&gt;&gt;SSL证书 ,点击选购SSL证书，进入云盾证书服务界面，其中，SSL证书服务选择DV单域名证书【免费试用】，数量选择20，然后可0元购买。
b. 证书申请 阿里云控制台&gt;&gt;产品与服务&gt;&gt;SSL证书（应用安全），进入数字证书管理服务界面，SSL证书&gt;&gt;免费证书，点击证书申请，进入申请页面，证书绑定域名填写购买的域名，域名验证方式为手工DNS验证，密钥算法``RSA，CSR生成方式选系统生成，其余按要求填写后点击下一步，由于是阿里云的域名，所以域名会自动增加一条解析记录，然后点击验证，提交审核，等待审核通过。2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61c17f095f11aadc1e7a97cea893540a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68828c584ed3e080a173ade982287332/" rel="bookmark">
			IntelliJ IDEA查看类层次结构图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IntelliJ IDEA查看类层次结构快捷键
Crtl + Alt + U
Crtl + Alt + Shift + U
Crtl + H
查看Diagram图形 的类层次结构图
Crtl + Alt + U或 Crtl + Alt + Shift + U
手动步骤，右键需要查看的类 -&gt; Diagrams -&gt; Show Diagram Popup
然后就可以看到类的具体层次结构了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f2202f0e6ab4a396a944886d8a66cc/" rel="bookmark">
			【UML】UML交互图（顺序图和通信图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UML交互图（顺序图和通信图） 1.交互图简介2.前置——CRC cards（Class-Responsibility-Collaborator）3.对比和优缺点4.交互图详解4.1 顺序图通信图共同点生命线框图消息表达式 4.2 顺序图基本构成创建与销毁对象框图多态同步与异步顺序图代码实例 4.3 通信图链、消息创建实例消息嵌套（编号）有条件消息带有互斥路径的有条件编号三者组合使用迭代和循环多态同步和异步消息 1.交互图简介 UML使用交互图来描述对象间通过消息的交互，交互图可以用于动态对象建模。
当我们要考虑真正的面向对象设计细节时，就必须要“落实”发送哪些消息、发送给谁、以何种顺序发送等具体问题。应该花费时间使用交互图进行动态对象建模，而不仅是使用类图进行静态对象建模。
交互图在精化阶段中使用，用来描述一个用例的行为,显示该用例中所涉及的对象以及这些对象之间的消息传递情况
2.前置——CRC cards（Class-Responsibility-Collaborator） CRC卡用于职责分配，是交互图和类图的极简版，在初始阶段使用
类 类名写在整个CRC卡的最上方。职责 包括这个类对自身信息的了解，以及这些信息将如何运用。这个部分在CRC卡的左边。协作 指代另一个类，这里写的信息是协作的类名。我们通过这个类获取我们想要的信息或者相关操作。这个部分在CRC卡的右边。 3.对比和优缺点 在这两种类型的交互图中，顺序图具有更丰富的符号标记，更容易查阅，但是通信图也有其独特的功能，尤其适用于在墙上画草图。
在表示法选项方面，UML规范更多是以顺序图为核心，对其表示法和语义投入了更多的精力。因此，顺序图对工具的支持更好，并且有更多有效的表示法选项。在阅读顺序方面，采用顺序图可以更方便地表示调用流的顺序，仅需要由上至下阅读即可，而对于通信图，我们则必须查阅顺序编号。因此，顺序图在文档化方面更胜一筹。在空间效用方面，通信图更具有优越性，因为可以在任何位置（水平或垂直）方便地放置或擦除框图。相比之下，在顺序图中添加的新对象时必须总是位于纸（或墙）的右边，因而右边的空间会很快被占用；垂直方向的空余空间不能得到有效利用。因此，用通信图绘制的墙上草图更易于修改，在墙上绘制。 4.交互图详解 4.1 顺序图通信图共同点 生命线框图 UML中定义了参与者框图的以下几种表达：
消息表达式 交互图展示了对象之间的消息，UML对于这些消息表达式具有标准语法：
return = message(parameter : parametreType) : returnType 没有返回值时，返回值可省略，没有参数时，圆括号可省略，类型信息不重要时也可省略，甚至可以只保留方法名
4.2 顺序图 基本构成 虚线为生命线（类的存活时间）箭头实线代表对象间的消息（典型同步消息）执行规格条（Execution specification bar）表示控制期（focus of control）最开始的消息在UML中称为初始消息，没有特定发送者。带返回值的消息既可以使用消息表达式来表示，也可以通过反方向的虚线箭头表示应答线，应答线上应标记返回值。还有发送给自身的消息
创建与销毁对象 在某个对象当中创建新实例，使用create并且新创建的对象，被置于其创建的“高度”上若需要显式地表示对象的销毁，用大X和终止于大X的生命线表示。
框图 有条件框图，里面的方法都遵循该条件执行（if，for等等），more items代表保护消息，或者称作条件子句
下图左侧是以图框操作符opt表示的"“有条件消息”，右侧是以图框操作符alt表示的"互斥的有条件消息"。互斥的有条件消息的图框用虚线分为上下两部分，条件子句为真时，走上方的消息路径，否则走下方的路径。
下图是循环消息的两种表示法。
标记ref的框图，是引用其他顺序图来简化，命名其他顺序图只要打上sd标签
至于常见图框操作符的含义，如下表所示：
多态 多态类，以这种方式对抽象类以及其每个实现画图
同步与异步 异步调用使用的箭头为刺形箭头，因为不用等待响应，因此不会阻塞，而常规同步（阻塞）调用用实心箭头表示
主动对象（active object）在生命线框图两侧加双竖线。
即在其进行的执行线程中运行或控制自己的执行线程的实例
顺序图代码实例 代码与图之间的关系如图所示，被指向的类B拥有箭头所示方法，发出箭头的类A调用方法
消息的传播
1.makePayment消息被发送到Register一个实例
2.Register实例将makePayment消息发送到Sale实例
3.Sale实例创建Payment实例
4.3 通信图 链、消息 链(link)是连接两个对象的路径，它指明了对象间某种可能的导航和可见性，更正式地说，链是关联的实例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97f2202f0e6ab4a396a944886d8a66cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1578a242c9005c76186f1d86d4ad4e/" rel="bookmark">
			Java split根据“.“分割字符串问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java split根据"."分割字符串问题 1. 为啥str.split(".") 分割出来的是空的2. Java中的转义字符 Escape Character3. 正则表达式中的转义符举例 1. 为啥str.split(“.”) 分割出来的是空的 split() 方法根据匹配给定的正则表达式来拆分字符串。
注意： . $ | * 等转义字符，必须得加 \\。
因此，应该用str.split(“\\.”)
2. Java中的转义字符 Escape Character 字母前加上"\"来表示一些不能显示的ASCII字符，如\0,\t,\n等，因为0，t，n等都不是原本ASCII表中的意思了，所以称为转义字符。
格式为：\+要转义的字符
3. 正则表达式中的转义符 正则表达式中的转义符也为"\"。所以在java中书写正则表达式时，要先通过java的转义再通过正则表达式的转义才是真正要的表达式。
举例 想要实现将字符串str = “192.168.0.1” 按照“.”进行分割。
使用split(String regex)方法，regex 为正则表达式分隔符。
由于正则表达式中"." 是一个具有特殊意义的字符，它可用于匹配任何字符。
因此需要转义符“\”，即正则表达式为regex = “\.”
但是转义符"\“在java中也充当着转义符，因此还要对”\“进行转义。
所以正则表达式要写成 “\\.”
String[] strs = str.split(”\\.")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad333c5a09b7f007dd3b84a0dcac6a2/" rel="bookmark">
			babel-plugin-import 的组件按需加载原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对比webpack懒加载 webpack 懒加载是将源码中的 import、require 引入的文件编译之后再根据动态加载语法配置（通常以页面路由为基本单位）将较大的代码拆分并构建出较小的 chunk 包，运行时执行到相应业务逻辑时才去加载执行对应 chunk 代码。
webpack 懒加载主要发生在 JS 拆分出不同的 Chunk 这一过程中。
babel-plugin-import 按需加载是以组件为基本单位产出 js、css、less 文件，借助插件或者部分引入的写法，使得项目代码或 babel 编译后的代码中只包含使用到的组件的 js、css、less 等。
首先是执行时机不同，babel-plugin-import 按需加载是在源码编写阶段或者 babel 编译 js 阶段，而 webpack 懒加载则是在构建生成打包产物阶段。其次是原理不同，babel-plugin-import 按需加载是在源码阶段就去掉了无关代码，而 webpack 懒加载则是将经过 tree-shaking 优化过后的大文件包进行拆分在适当的运行时进行按需加载。两者并不冲突，可以一前一后共同作用。
实现原理 babel-plugin-import 按需加载目的是减少项目构建打包产物的大小，提高项目线上首屏渲染速度，减少白屏时间，减少流量消耗。
若是采用手动引入需要使用到的组件以及其对应的样式文件，那么在 webpack 构件时组件库中其他未被引入的文件不会被打包。
import Button from 'lib/button'; import 'lib/lib/button/style'; 若是自动引入：
npm i babel-plugin-import -D module.exports = { plugins: [ ['import', { libraryName, libraryDirectory: 'es', style: true }, libraryName] ] }; import { Button } from libraryName; 组件其实就是对一堆 js、css 以及 less 等文件的总称，自动引入的本质是将引入组件的写法通过插件来转换成手动引入组件对应的代码以及样式文件的写法。核心原理依然是对源码的 import 导入写法进行转换——词法语法分析，AST转换，代码生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad333c5a09b7f007dd3b84a0dcac6a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36dbbe16ba075161ed80f0cae98fb070/" rel="bookmark">
			k8s——删除namespace一直处于Terminating状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常删除namespace(kubernetes-dashboard)一直删不干净，处于Terminating状态
正常删除 kubectl delete namespace NAMESPACENAME
强制删除 kubectl delete namespace NAMESPACENAME --force --grace-period=0
如果强制删除也没有用的话
修改finalizers，删除下面红色框内容 kubectl edit namespace NAMESPACE_NAME
如果这个方法也不行的话
通过调用接口删除 导出json格式到tmp.json
kubectl get namespace &lt;terminating-namespace&gt; -o json &gt;tmp.json
编辑tmp.josn，删除finalizers 字段的值
{ "apiVersion": "v1", "kind": "Namespace", "metadata": { "annotations": { "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"v1\",\"kind\":\"Namespace\",\"metadata\":{\"annotations\":{},\"name\":\"kubernetes-dashboard\"}}\n" }, "creationTimestamp": "2022-05-29T14:35:19Z", "deletionTimestamp": "2022-05-30T06:51:16Z", "name": "kubernetes-dashboard", "resourceVersion": "1048583", "selfLink": "/api/v1/namespaces/kubernetes-dashboard", "uid": "2320611c-1eec-4903-80e9-e30850b9b5c7" }, "spec": { "finalizers": [] }, "status": { "phase": "Terminating" } } 开启 proxy kubectl proxy 打开新的terminal 窗口，运行以下命令： curl -k -H "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36dbbe16ba075161ed80f0cae98fb070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875a287f12ad801665a027ba07656a73/" rel="bookmark">
			解决Chrome浏览器图片缩放模糊的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起初开发网页时，都把图片尺寸精心设计好，图片多大就做成多大，而且还尽量压缩，这样才利于网页快速载入，增强用户浏览体验。
但现在手机时代了，用手机浏览网页，就会发现PC端正常效果的图片却显得模糊。
于是需要把图片原始尺寸做大一些，再等比例缩小嵌入网页，这样手机端看图片就会很清晰。
比如，420×336（px）的图片等比例缩小，以320×256（px）的规格嵌入网页：
&lt;a href="http://www.furuijinzhao.com/_gb/service_cleaning.html"&gt; &lt;img src="_img/clean.jpg" width="320" height="256" alt="清洁服务" /&gt; &lt;/a&gt; 但发现，在chrom浏览器中，缩小尺寸的图片显示失真、不清晰。
经过搜索、完善，总结出三种CSS解决方法。
方法一：
img { /*......*/ backface-visibility:hidden; -webkit-backface-visibility:hidden;	/* Chrome 和 Safari */ -moz-backface-visibility:hidden; /* Firefox */ -ms-backface-visibility:hidden; /* Internet Explorer */ } 方法二：
img { /*......*/ image-rendering:-moz-crisp-edges; /* Firefox */ image-rendering:-o-crisp-edges; /* Opera */ image-rendering:-webkit-optimize-contrast; /*Webkit (non-standard naming) */ image-rendering:crisp-edges; -ms-interpolation-mode: nearest-neighbor; /* IE (non-standard property) */ } 方法三：
img { /*......*/ filter:blur(0); -webkit-filter:blur(0); -moz-filter:blur(0); -ms-filter:blur(0); transform:translateZ(0); -webkit-transform:translateZ(0); -moz-transform:translateZ(0); -ms-transform:translateZ(0); } 再看图片，正常清晰了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/875a287f12ad801665a027ba07656a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271edfa365f1bff62b0f36c89192e70e/" rel="bookmark">
			线性结构与非线性结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据结构包括:线性结构和非线性结构
线性结构：
线性结构是最常用的数据结构，特点就是元素直接存在1对1的线性关系。具有两种不同的存储结构，顺序存储结构和链式存储结构。顺序存储结构表称为顺序表，顺序表中元素的内存地址是连续的。链式存储的线性表称为链表，链表中的存储数据的内存地址不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。常见的线性结构有：数组、队列、链表、和栈。 非线性结构
非线性结构包括：二维数组、多维数组、广义表、树结构、图结构。其中树结构图结构在算法中用到的更加广泛。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3065e7e795bf21f28e8637adfd4542c/" rel="bookmark">
			原生js使用 nextSibling 实现可输入下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML中的每个标签元素、属性、文本都能看做是一个DOM的节点，这些dom节点构成了一个树形结构，类似于一颗家族树一样，一层接一层，这就是Html的DOM树。而JavaScript为了能够操作Html，定义了一套自己的dom编程接口，通过这些接口可以操作html的每个DOM节点。本教程我们使用nextSibling属性实现可编辑的下拉框。
目录结构
1、nextSibling的用法
2、使用 nextSibling 实现可编辑下拉框
3、JavaScript DOM操作的常用方法和属性
详情请前往以下网址查看：https://www.kongzid.com/archives/js2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aefe2108c7fb8a878c7ff8dfd1daa4a/" rel="bookmark">
			excel表格排序，4种排序教程全都有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel具备直观的界面、出色的计算功能和图表工具，其中excel可以对庞大的数据源利用排序进行快速整理，使数据一目了然并且美观，excel表格排序的具体流程是怎样的呢？小编给大家罗列了4种排序教程！赶紧来围观吧！
第一种：根据数值排序 这种排序方式应该是比较常见而且常用的一种排序方式，打开excel表格，随意选中一个需要排序的数值，点击上方的【开始】，在工具栏的后面找到【排序】，即可根据数值进行升序或降序。
第二种：根据单元格颜色排序 如果您的excel表格中的单元格是填充了颜色的，想要将该内容放在顶端或低端的话，可以在第一种的排序处选择【自定义排序】，随后跳出排序的对话框，根据小编的表格，在【列】出选择【成绩评定】，在【排序依据】处选择【单元格颜色】，在【次序】处选择有颜色的单元格或无单元格颜色都可以，最后一个是选择顶端或低端，都选择完毕后，点击【确定】。
第三种：根据字体颜色排序 操作步骤跟第二种排序方式差不多，只不过在【排序依据】处选择【字体颜色】罢了。
第四种：根据条件格式图标排序 将【排序依据】选择【条件格式图标】即可，只不过这种排序方式比较少用到。
以上就是小编整理的4种excel表格排序教程啦！是不是觉得非常简单呢？不管是不是常用的还是不常用的排序形式，大家都应该掌握其中的操作步骤，毕竟学无止境对吧！如果对小编写的内容感兴趣或者喜欢的话，那就给小编反手来个赞或者关注吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d95f03f86ac428eb9859ca4e3aeb13/" rel="bookmark">
			Shell进阶脚本70个练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.数组的基本脚本
2.子shell与父shell
3.子shell与父shell进阶
4.基础函数
5.函数进阶之作用域域返回值
6.进程控制与文件描述和管道
7.排序算法
8.花阔号的使用
9.波浪号
10.变量替换
11.高级变量替换
12.命令替换
13.算术替换
14.进程替换
15.单词切割
16.路径替换
17.随机获取密码
18.shell解释器和属性
19.初始化命令shopt终端与tput终端
20.trap信号捕捉
21.shell脚本内容排错与进度条
22.xargs参数传参
23.shift移动参数
24.其他
1.数组的基本脚本 #!/bin/bash name[0]="jacob" # 定义一个数组 name[1]="Rose" # 附加数组 name[2]="Rick" # 附加数组 name[3+3]="TinTin" # 追加数组,相当与在第6位追加 echo ${name[0]} # 打印数组第一个内容 echo ${name[1]} # 打印数组第二个内容 echo ${name[6]} # 打印数组第四个内容或echo ${name[3+3]} name[3+3]="Tin" # 如果有值则是修改 echo ${name[*]} # 打印数组所有值，会把值当成一个整体 echo ${name[-1]} # 打印数组最后一个值 echo ${name[-2]} # 打印数组最后第二个值 echo ${#name[*]} # 打印数组内的值的个数 echo ${name[@]} # 打印数组所有值,分为单个个体 i=1 addr[$i]="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d95f03f86ac428eb9859ca4e3aeb13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f6aec43f8d270308f0a66347a65dc9/" rel="bookmark">
			Android插件化原理及基础实现【hook篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件化的理念 将应用分为多个模块，分出宿主与插件
用户安装宿主，动态加载插件
插件化的优点 按需加载、可插拔、动态更新
减小apk体积，解决方法是超过65535的问题
插件分开开发与编译，提高效率，降低耦合度
插件化的缺点 提升项目复杂度
插件化框架 特性dynamic-load-apkDynamicApkSmallDroidPluginVirtualAPK作者任玉刚携程wequick360滴滴四大组件支持只支持Activity只支持Activity只支持Activity全支持全支持插件无需在清单文件预注册√x√√√插件可以依赖宿主√√√x√支持PendingIntentxxx√√Android特性支持大部分大部分大部分几乎全部几乎全部兼容性适配一般一般中等高高插件构建无部署AAPTGradle插件无Gradle插件 插件的架构思路 Demo地址
如何加载插件？ 通过Android的类加载机制，和几个ClassLoader分别的作用可知，想要加载插件，就需要将插件项目打成dex或apk，然后根据DexClassLoader指定插件路径，即可加载
apk是一个完整的Android包，其中包含了dex代码部分，res资源部分，AndroidManifest清单部分，作为插件时，其资源也可以被用到
dex是一个纯代码的包，有多个class文件组合而成
dex可作为热修复，apk可以作为完整的插件使用，这里讲的是插件的使用，就以apk为例
独立声明一个插件工程，在其中编写代码，然后编译成apk，其过程和正常apk工程一样
将apk放入手机存储，然后通过DexClassLoader加载，此时，可以调用没有使用的资源的类的方法
插件中的类
public class PluginTest { public static void doSomeThing(){ Log.d("hahaha", "PluginTest doSomeThing "); } } 拷贝插件到私有目录，并创建插件的类加载器
private boolean copyPlugin() { String pluginName = "plugin.apk"; // 插件所在目录 mPluginPath = mContext.getExternalFilesDir(null).getAbsolutePath() + File.separator + pluginName; // 最终拷贝到的私有目录 String targetPath = mContext.getDir(PLUGIN_CACHE_DIR_NAME,Context.MODE_PRIVATE).getAbsolutePath(); if(!new File(mPluginPath).exists()){ // 如果插件不存在 Log.e(TAG,"plugin not exists !!!"); return false; } File targetFile = new File(targetPath); if(targetFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f6aec43f8d270308f0a66347a65dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b0bcf449321400eab4123d74390d94/" rel="bookmark">
			实现tab选项卡的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tab栏切换主要分为2大模块：
上面的模块选项卡：当点击某一个时，当前的这个底色会变色，其余不变（排他思想） 修改类名的方式
下面的模块内容：跟随上面的选项卡变化，因此下面模块变化需要写到上面模块选项卡的点击事件里
难点在于如何实现点击上面选项卡模块，下面模块显示其对应的内容，这里可以利用 自定义属性 的方式进行（当然这只是其中一种思路）：给每个选项卡通过自定义属性设置其索引号，可以通过 getAttribute 得到当前点击的这个选项卡的索引号，让相应的内容模块显示出来即可
方式1： &lt;!-- 选项卡部分 --&gt; &lt;div id="tab"&gt; &lt;!-- 头部区域 --&gt; &lt;div class="tab-header" id="tab-header"&gt; &lt;ul&gt; &lt;li class="selected"&gt;公告&lt;/li&gt; &lt;li&gt;规则&lt;/li&gt; &lt;li&gt;论坛&lt;/li&gt; &lt;li&gt;安全&lt;/li&gt; &lt;li&gt;公益&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 身体部分 --&gt; &lt;div id="tab-content"&gt; &lt;!-- 第一部分 --&gt; &lt;div class="dom" style="display: block;"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="#"&gt;数据七夕：金牛爱送玫瑰&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;阿里打造“互联网监管”&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;10万家店60万新品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;全球最大网上时装周&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 第二部分 --&gt; &lt;div class="dom"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b0bcf449321400eab4123d74390d94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd77cee62ea302b3dd510edeec1da5cf/" rel="bookmark">
			关于Maven新建项目本地仓库恢复默认地址的完美解方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人根据教程在idea的setting中修改Maven的本地仓库位置：
可是改为后只对本项目生效，新建项目还是默认C盘，在网上查看了很多方法：
有的说把新生成项目中.mvn中的wapper删除（此方法不可靠）
有的说到打开C盘此位置：
C:\Users\你的用户名.IntelliJIdea2019.3\config\option\project.default.xml
然后修改idea的默认配置：
&lt;component name="MavenImportPreferences"&gt; &lt;option name="generalSettings"&gt; &lt;MavenGeneralSettings&gt; &lt;option name="localRepository" value="这里是你自己的local repository路径，例如（C:\ideaMaven\MavenRepository）" /&gt; &lt;option name="mavenHome" value="这里是你自己的maven Home路径，例如（C:\ideaMaven\apache-maven-3.6.1）" /&gt; &lt;option name="userSettingsFile" value="这里是你自己的user Settings File路径，例如（C:\ideaMaven\apache-maven-3.6.1\conf\settings.xml）" /&gt; &lt;/MavenGeneralSettings&gt; &lt;/option&gt; &lt;/component&gt; 这些都太麻烦了，个人方法：
首先点击file-&gt;close project-&gt;返回到idea的初始欢迎界面:
此时进入setting修改Maven的本地仓库位置就是全局配置，对新建的项目都会生效。
好了，教程结束，完美解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f89ab1b6c58483ed803806a21e1983/" rel="bookmark">
			Redis 缓存中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 缓存中间件 文章目录 Redis 缓存中间件为什么需要缓存中间件？Redis 简介特性单线程 Redis存储机制Snapshot 工作原理AOF 工作原理存储模式性能和安全数据结构及使用场景String 字符串Hash 哈希List 列表Set 集合ZSET 有序集合 技术总结REFERENCES 手机用户请横屏获取最佳阅读体验，REFERENCES中是本文参考的链接，如需要链接和更多资源，可以关注公众号后回复『知识星球』加入并获取长期知识分享服务。
为什么需要缓存中间件？ 一个网站演变的过程中，用户量的增加引起了并发量提高，如果不做处理，则频繁的查询数据库，结果是页面显示的慢，服务器、数据库不堪重负。如果网站页面所展示的数据的更新不是特别频繁，想提高页面显示的速度，减轻服务器的负担，此时应该考虑使用缓存。
所以，缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对物理数据源访问的频次，从而提高了应用的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。
使用缓存有一个原则：越高层次的缓存效果越好。 推荐使用页面缓存。
Redis 简介 redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)、Hash(哈希类型的映射表)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。
在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，Python，Ruby，Perl，PHP客户端，使用很方便。
特性 速度快
数据存在内存中
C语言编写，5W 行代码
单线程数据模型
持久化
多种数据结构
支持多种编辑语言
功能丰富
主从复制（数据一致性）
高可用
哨兵模式 单线程 为什么这么快？
纯内存操作
非阻塞IO
避免线程切换和竞态消耗
如何使用？
拒绝长（慢）命令，如 keys、flushall。
一次只运行一个命令
Redis存储机制 Redis存储机制分成两种 Snapshot和 AOF。无论是哪种机制，Redis都是将数据存储在内存中。
Snapshot 工作原理 是将数据先存储在内存，然后当数据累计达到某些设定的伐值的时候，就会触发一次DUMP操作，将变化的数据一次性写入数据文件（RDB文件）。
AOF 工作原理 是将数据也是先存在内存，但是在存储的时候会使用调用 fsync 来完成对本次写操作的日志记录，这个日志揭露文件其实是一个基于 Redis 网络交互协议的文本文件。AOF 调用 fsync 也不是说全部都是无阻塞的，在某些系统上可能出现 fsync 阻塞进程的情况，对于这种情况可以通过配置修改，但默认情况不要修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f89ab1b6c58483ed803806a21e1983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fc93d541bd47e3cf0ffaf5bb709c10/" rel="bookmark">
			vue-router路由跳转与打开新窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-router打开新窗口的方法及跳转方式对比 打开新窗口 方法1：
const routeUrl = this.$router.resolve({ path: "/targetUrl", query: { id: 96 }, }); window.open(routeUrl.href, "_blank"); }, 方法2：
&lt;router-link target="_blank" :to="{ path: '/catalog', query: { id: '1' } }" &gt;打开新的标签页&lt;/router-link&gt; 如果通过iframe嵌入到其他系统中，这样打开新窗口，会丢掉iframe的壳子，出现有问题
需改为window.parent.open(routeUrl.href, “_blank”);
注意同源问题，需要解决
vue-router的几种跳转方式 this.$router.push()
push向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL
首页 ===》通过直接修改地址来到页面A ===》通过点击按钮，this.$router.push来到页面B
那么这个时候点击浏览器的返回，首先返回到页面A，再次点击返回才返回到首页
this.$router.replace()
replace不会向 history 添加新记录，而是用心的替换掉当前的 history 记录
首页 ===》 通过直接修改地址来到页面A ===》通过点击按钮，this.$router.replace来到页面B
此时点击浏览器的返回，那么会直接回到首页
router.push({ path: '/home', replace: true }) this.$router.replace('/home') 上面这两种方法是等效的
router-link标签
&lt;router-link to="/url"&gt;&lt;/router-link&gt; 等同于调用
router.push(“/url”)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38fc93d541bd47e3cf0ffaf5bb709c10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65afb2024fea399e890f04096bba146/" rel="bookmark">
			Python中Round函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中Round函数 Python中的舍入函数，返回浮点数，该浮点数是指定数字的舍入版本。本文将详细探讨这一概念。本文将介绍以下内容，
Python round()
Practical Application
Rounding NumPy Arrays
Rounding Pandas Series and DataFrame
Data Frame
那么，让我们开始吧，
Python中的舍入函数
round（x，n）方法将返回x的值，该值四舍五入到小数点后的n位数字。
例如：
round（7.6 + 8.7,1） 输出：
16.3 回合赋予此功能以提供最接近的价值
例如：
round（6.543231，2） 输出：
6.54 有时无法提供正确的输出
示例：
round（2.675，2）＃应该返回2.68，但不会返回 输出：
2.67 有时它给出正确的输出
例如：
round（8.875，2） 输出：
8.88 继续本文有关Python中的舍入函数的文章。
Python回合（）
python中的舍入函数将十进制值四舍五入为给定的位数，如果我们不提供n（即十进制后的位数），则会将数字四舍五入为最接近的整数。
如果其后的整数&gt; = 5，则四舍五入为ceil；如果小数为&lt;5，则四舍五入为整数。
没有第二个参数的round（）
#int print(round(12)) #float print(round(66.6)) print(round(45.5)) print(round(92.4)) 输出：
12 67 46 92 现在，如果提供了第二个参数，则如果last_digit + 1&gt; = 5，则最后一个十进制数字将增加1直至舍入后的值，否则它将与提供的相同。
带有第二个参数的round（）
# when last_digit+1 =5 print(round(3.775, 2)) # when last_digit+1 is &gt;=5 print(round(3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65afb2024fea399e890f04096bba146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59cc6be8576e00d080b6d9ae3e02ff5e/" rel="bookmark">
			KVM管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KVM的管理工具，一般都对qemu命令进行了封装和功能增强，提供了比原生的qemu命令行更加友好、高效的用户交互接口。
1. libvirt
libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和应用程序接口，而且一些常用的虚拟机管理工具（如virsh、virt-install、virt-manager等）和云计算框架平台（如OpenStack、ZStack、OpenNebula、Eucalyptus等）都在底层使用libvirt的应用程序接口。其主要作为连接底层Hypervisor和上层应用程序的一个中间适配层。
libvirt支持多种虚拟化方案，既支持包括KVM、QEMU、Xen、VMware、VirtualBox、Hyper-V等在内的平台虚拟化方案，也支持OpenVZ、LXC等Linux容器虚拟化系统，还支持用户态Linux（UML）的虚拟化。
libvirt对多种不同的Hypervisor的支持是通过一种基于驱动程序的架构来实现的。libvirt对不同的Hypervisor提供了不同的驱动。libvirt作为中间适配层，可以让底层Hypervisor对上层用户空间的管理工具是完全透明的，因为libvirt屏蔽了底层各种Hypervisor的细节，为上层管理工具提供了一个统一的、较稳定的接口（API）。通过libvirt，一些用户空间管理工具可以管理各种不同的Hypervisor和上面运行的客户机。
libvirt主要由3个部分组成，分别是：应用程序编程接口库、一个守护进程（libvirtd）和一个默认命令行管理工具（virsh）。应用程序接口是为其他虚拟机管理工具（如virsh、virt-manager等）提供虚拟机管理的程序库支持。libvirtd守护进程负责执行对节点上的域的管理工作，在用各种工具对虚拟机进行管理时，这个守护进程一定要处于运行状态中。
libvirt的核心价值和主要目标就是提供一套管理虚拟机的、稳定的、高效的应用程序接口（API）。libvirt API本身是用C语言实现的，主要包括8个部分：连接Hypervisor相关的API、域管理的API、节点管理的API、网络管理的API、存储卷管理的API、存储池管理的API、事件管理的API、数据流管理的API。
2. virsh
virsh是用于管理虚拟化环境中的客户机和Hypervisor的命令行工具，通过调用libvirt API来实现虚拟化的管理的。virsh是完全在命令行文本模式下运行的用户态工具，它是系统管理员通过脚本程序实现虚拟化自动部署和管理的理想工具之一。
在使用virsh命令行进行虚拟化管理操作时，可以使用两种工作模式：交互模式和非交互模式。交互模式，是连接到相应的Hypervisor上，然后输入一个命令得到一个返回结果，直到用户使用“quit”命令退出连接。非交互模式，是直接在命令行中在一个建立连接的URI之后添加需要执行的一个或多个命令，执行完成后将命令的输出结果返回到当前终端上，然后自动断开连接。
3. virt-manager
virt-manager是用于管理虚拟机的图形化的桌面用户接口，目前仅支持在Linux或其他类UNIX系统中运行。virt-manager项目选择使用Python语言开发其应用程序部分，使用GNU AutoTools（包括autoconf、automake等工具）进行项目的构建。virt-manager是一个完全开源的软件，使用Linux界广泛采用的GNU GPL许可证发布。virt-manager依赖的一些程序库主要包括Python（用于应用程序逻辑部分的实现）、GTK+PyGTK（用于UI界面）和libvirt（用于底层的API）。
virt-manager工具在图形界面中实现了一些易用且丰富的虚拟化管理功能。已经为用户提供的功能如下：
对虚拟机（即客户机）生命周期的管理，如创建、修改、启动、暂停、恢复和停止虚拟机，还包括虚拟快照、动态迁移等功能。
对运行中客户机实时性能、资源利用率等监控，统计结果的图形化展示。
对创建客户机的图形化的引导，对客户机的资源分配和虚拟硬件的配置和调整等功能也提供了图形化的支持。
内置了一个VNC和SPICE客户端，可以用于连接到客户机的图形界面进行交互。
支持本地或远程管理KVM、Xen、QEMU、LXC、ESX等Hypervisor上的客户机。
4. virt-viewer
virt-viewer是“Virtual Machine Viewer”（虚拟机查看器）工具的软件包和命令行工具名称，它是一个显示虚拟化客户机的图形界面的工具。virt-viewer使用GTK-VNC或SPICE-GTK作为它的显示能力，使用libvirt API去查询客户机的VNC或SPICE服务器端的信息。virt-viewer经常用于替换传统的VNC客户端查看器，因为后者通常不支持x509认证授权的SSL/TLS加密，而virt-viewer是支持的。
virt-viewer连接到的客户机可以通过客户机的名称、域ID、UUID等表示来唯一指定。virt-viewer还支持“-c URI”或“–connection URI”参数来指定连接到远程宿主机上的一个客户机，当然远程连接时一些必要的认证还是必需的。关于virt-viewer工具更多详细的参数和解释，可以通过“man virt-viewer”命令查看使用手册。
5. virt-install
virt-install是“Virt Install”工具的命令名称和软件包名称。virt-install命令行工具为虚拟客户机的安装提供了一个便捷易用的方式，它也是用libvirt API来创建KVM、Xen、LXC等各种类型的客户机，同时，它也为virt-manager的图形界面创建客户机提供了安装系统的API。virt-install工具使用文本模式的串口控制台和VNC（或SPICE）图形接口，可以支持基于文本模式和图形界面的客户机安装。virt-install中使用到的安装介质（如光盘、ISO文件）可以存放在本地系统上，也可以存放在远程的NFS、HTTP、FTP服务器上。virt-install支持本地的客户机系统，也可以通过“–connect URI”（或“-c URI”）参数来支持在远程宿主机中安装客户机。
6. virt-top
virt-top是一个用于展示虚拟化客户机运行状态和资源使用率的工具，它与Linux系统上常用的“top”工具类似，而且它的许多快捷键和命令行参数的设置都与“top”工具相同。virt-top也是使用libvirt API来获取客户机的运行状态和资源使用情况的，所以只要是libvirt支持的Hypervisor，就可以用virt-top监控该Hypervisor上的客户机状态。
7. libguestfs
libguestfs是用于访问和修改虚拟机的磁盘镜像的一组工具集合。libguestfs提供了访问和编辑客户机中的文件、脚本化修改客户机中的信息、监控磁盘使用和空闲的统计信息、P2V、V2V、创建客户机、克隆客户机、备份磁盘内容、格式化磁盘、调整磁盘大小等非常丰富的功能。libguestfs支持大部分的主流客户机操作系统，如：CentOS、Fedora、Ubuntu、Windows等操作系统；libguestfs除了支持KVM虚拟机，它甚至支持VMware、Hyper-V等非开源的虚拟机。同时，libguestfs还提供了一套C库以方便被链接到自己用C/C++开发的管理程序之中。它还有对其他很多流程编程语言（如：Python）的绑定，让开发者可以方便地使用libgeustfs提供的功能构建自己的虚拟机磁盘镜像管理程序。
libguestfs-tools提供了很多工具，可以分别对应不同的功能和使用场景，如：virt-ls用于列出虚拟机中的文件，virt-copy-in用于往虚拟机中复制文件或目录，virt-copy-out用于从虚拟机往外复制文件或目录，virt-resize用于调整磁盘大小，virt-cat用于显示虚拟机中的一个文件的内容，virt-edit用于编辑虚拟机中的文件，virt-df用于查看虚拟机中文件系统空间使用情况，等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013704c8c58cfd5daba1a833e60ad2c7/" rel="bookmark">
			c语言中fclose函数的使用你会吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝字关注我，了解更多咨询
1、C语言fclose函数用于关闭使用fopen成功打开的文件。
2、fopen函数和fclose函数总是成对出现。如果文件成功打开fopen函数，请使用fclose函数关闭文件。
实例
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { //如果D:/file.txt存在，则fopen打开成功，否则失败返回NULL FILE * fp = fopen ("d://file.txt", "r"); if(!fp) printf("打开文件失败"); else { printf("打开文件成功")； fclose(fp); //如果文件打开成功记得关闭 } return(0); } END
*声明：本文于网络整理，版权归原作者所有，如来源信息有误或侵犯权益，请联系我们删除或授权事宜。
戳“阅读原文”我们一起进步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b05f800792901a27c43c956cba693e/" rel="bookmark">
			git HEAD detached from origin 问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这个问题是因为分支选错了，所以说后续的提交都提交到了一个匿名分支之上，整个状态是游离了的 下面说一下解决问题的步骤
1.查看在游离状态下提交的最新commit号
git branch -v 2.创建一个临时的分支，创建完成之后切换到该分支上查看一下
git branch temp 最新的commit号 3.切换到要合并的分支智商
git checkout 要合并临时分支的分支名称 4.合并分支
git merge temp 5.删除临时分支
git branch -d temp 6.推送合并后的分支到远程仓库
git push origin 分支名称:远程分支名称 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085153deb0a2b531dc49d3695348e3e5/" rel="bookmark">
			CSS图片裁剪：实现切角效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 img { border: 1px gray solid; width: 400px; height: 200px; clip-path: polygon(0 20px, 100% 0, 100% 100%, 0 100%); } img { border: 1px gray solid; width: 400px; height: 200px; clip-path: polygon(0 0, 100% 0, 100% 180px, 0 100%); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066ed547346d4d8df02f3e5ae89cc6a6/" rel="bookmark">
			kubernetes的service服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、service的概念
​二、kube-proxy支持的三种模式
1、usersapace模式
2、iptables 模式
3、ipvs 模式
三、Service类型
1、ClusterIP类型的Service
service-clusterip.yaml
2、NodePort类型的Service
service-nodeport.yaml
3、LoadBalancer类型的Service
4、ExternalName类型的Service
5、HeadLess类型的Service
一、service的概念 每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：
Pod IP会随着Pod的重建产生变化
Pod IP仅仅是集群内可见的虚拟IP，外部无法访问
这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。
Service可以看作是一组同类Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。
Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后它会将最新的Service信息转换成对应的访问规则。
二、kube-proxy支持的三种模式 1、usersapace模式 userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。 该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。
2、iptables 模式 iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。 该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略(只能进行轮询或者随机)，当后端Pod不可用时也无法进行重试。
3、ipvs 模式 ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。
注：此模式必须安装ipvs内核模块，否则会降级为iptables
三、Service类型 Service的资源清单文件
kind: Service # 资源类型 apiVersion: v1 # 资源版本 metadata: # 元数据 name: service # 资源名称 namespace: dev # 命名空间 spec: # 描述 selector: # 标签选择器，用于确定当前service代理哪些pod app: nginx type: # Service类型，指定service的访问方式 clusterIP: # 虚拟服务的ip地址 sessionAffinity: # session亲和性，支持ClientIP、None两个选项 ports: # 端口信息 - protocol: TCP port: 3017 # service端口 targetPort: 5003 # pod端口 nodePort: 31122 # 主机端口 ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/066ed547346d4d8df02f3e5ae89cc6a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e36daf1e6749ff5d776b4d25fe211b/" rel="bookmark">
			npm run serve 和 npm run dev 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在日常运行vue 项目中 在终端 运行命令有时用到 npm run serve 有时是 npm run dev。
那么，什么时候用到 serve ，什么时候用到 dev 呢？ 他们的区别是什么？
一般在 vue 3.x 的时候用 npm run serve,vue2.x项目运行的时候用到 npm run dev，
dev是vue cli2的默认执行命令，serve是vue cli4的默认执行命令
例如：在vue 项目终端，输入 npm run serve 或者 npm run dev 其中一个的时候 会出现报错，如下：
以上是运行错误提示，然后找到package.json文件，观察标红代码。
我们会发现 npm run serve 代表执行npm run package.json 里面的scripts值，例如 npm run serve实际运行的是vue-cli-service serve，在此vue项目中dev 代表的是vue-cli-service serve，所以我们通过 npm run dev 可以运行此项目，如下：
运行成功（运行成功后一般即可弹出项目运行页面），如果不想重新运行直接看到页面的话，通过 local显示的链接复制，在浏览器打开，就能看到该vue项目 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37b3140d6cb2d5c7164890fd1d2735c/" rel="bookmark">
			源码中新增API后的编译问题（Android 12）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近公司的产品平台升级，芯片厂商换了，Android版本也由原来的Android 9 升级到了Android 12;
Audio模块要求支持支持多通道录音，于是在源码里新增了几个音频通道常量的定义，包括Audio的java层和hal层，主要新增的文件如下：
frameworks/base/media/java/android/media/AudioFormat.java
public static int inChannelMaskFromOutChannelMask(int outMask) throws IllegalArgumentException {
if (outMask == CHANNEL_OUT_DEFAULT) {
throw new IllegalArgumentException(
"Illegal CHANNEL_OUT_DEFAULT channel mask for input.");
}
switch (channelCountFromOutChannelMask(outMask)) {
case 1:
return CHANNEL_IN_MONO;
case 2:
return CHANNEL_IN_STEREO;
/**add by *** mic start**/
case 8:
return CHANNEL_IN_08;
case 12:
return CHANNEL_IN_12;
case 16:
return CHANNEL_IN_16;
/**add by *** mic end**/
default:
throw new IllegalArgumentException("Unsupported channel configuration for input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37b3140d6cb2d5c7164890fd1d2735c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d961186c3e00b516f879b93fd95a310d/" rel="bookmark">
			element-vue admin 右击路由选项 利用fullscreen实现全局页面全屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		凡有所相，皆是虚妄
文章目录 前言效果图 一、fullscreen是什么？二、使用步骤1.安装依赖，引入组件2.添加路由右键菜单选项及全屏实现 前言 项目需求，每个页面都需要有个全屏的功能，而原有的全屏功能是把整个页面放大全屏（包括左侧菜单，路由栏），现在只需要主功能页面放大全屏。
效果图 一、fullscreen是什么？ 简易轻量化类原生的高兼容窗口全屏控件。
二、使用步骤 1.安装依赖，引入组件 终端安装依赖
npm install vue-fullscreen --save 在 main.js文件中引入组件
import fullscreen from 'vue-fullscreen' Vue.use(fullscreen) 2.添加路由右键菜单选项及全屏实现 我的路由文件在这，具体自行寻找projectName/src/layout/components/TagsView/index.vue
Template代码
// 选项为无序列表 &lt;ul&gt; &lt;li @click="clickFullscreen()"&gt;&lt;i class="el-icon-full-screen" /&gt; 全屏显示&lt;/li&gt; &lt;/ul&gt; &lt;fullscreen style="background: #f7f8fa" :fullscreen.sync="fullscreen"&gt; // 这里是全局设置，在路由下的页面就全屏，如果要给其它的数据全屏改成对应的就好	&lt;router-view v-if="showMainFlag" :in-screen="!fullscreen" style="width: 100%; height: 100%;" /&gt; &lt;/fullscreen&gt; script代码
export default { data() { return { fullscreen: false, showMain: false } }, computed: { showMainFlag() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d961186c3e00b516f879b93fd95a310d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02755760b14b5241317724e454fc166/" rel="bookmark">
			css3中伪类选择器:target的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料　CSS3 target伪类简介
今天由于在做任务13，里面有一个子任务是要求用css写出一个简单的图片轮播，刚开始真的是完全没有思路，想着不用js怎么绑定点击事件呢，看了别人的一些实现方法，发现:target是一个神奇的东西。
如果想看用css3实现的图片轮播的源码，狠狠点击这里demo
刚开始接触:target时，真的是一头雾水，觉得这个是个什么东西，怎么能处理点击事件呢。看了差不多五六篇博客还有简介吧，突然醒悟，这不就也是一个选择器嘛，只不过功能高大上了点而已。
具体说明高大上功能之前，先来“接地气”的说一下基本概念：
它用来匹配文档(页面)的URI中某个标志符的目标元素。具体来说，URI中的标志符通常会包含一个”#”字符，然后后面带有一个标志符名称，比如#respond，target就是用来匹配ID为respond的元素的。
那它的功能到底高大上在哪呢，就是它可以根据你当前的点击的元素动态的有选择性的链接到对应的元素上，比如下面的代码块
&lt;div id="img1"&gt; &lt;div id="img2"&gt; &lt;div id="img3"&gt; &lt;ul class="mainImg"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;	&lt;/div&gt;	&lt;ul class="controller"&gt; &lt;li&gt;&lt;a href="#img1"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#img2"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#img3"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 不要被这个嵌套了n多层div的代码吓到了啊，其实这是用css实现图片轮播的无奈之举，因为没有选择父级的选择器。好，现在点击1，那么文档就会自动定位到#img1，也就是id为img1的div元素。同理，点击2，文档就会自动定位到id为img2的div元素。定位到id为img2的div元素，就相当于用ID选择器#img2定位。
这样接下来再想选择什么元素就随心所欲了，比如选择类名为mainImg的div元素，就可以这么写#img1:target .mainImg 表示的是当目标元素为#img1时,它的子元素.mainImg的样式变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b597e1dc5b7b59b43089003de2dfcb/" rel="bookmark">
			【Microsoft Azure 的1024种玩法】五十. 通过Azure文件共享将Azure File 挂载到本地机器实现文件实时共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【简介】 Azure 文件是 Microsoft 推出的易用云文件系统。 Azure 文件共享可以在 Windows 和 Windows Server 中无缝使用。 本文介绍如何通过Azure文件共享将Azure File 挂载到本地实现文件实时共享
【前期文章】 【Microsoft Azure 的1024种玩法】一.一分钟快速上手搭建宝塔管理面板
【Microsoft Azure 的1024种玩法】二.基于Azure云平台的安全攻防靶场系统构建
【Microsoft Azure 的1024种玩法】三.基于Azure云平台构建Discuz论坛
【Microsoft Azure 的1024种玩法】四. 利用Azure Virtual machines 打造个人专属云盘，速度吊打某云盘
【Microsoft Azure 的1024种玩法】五.基于Azure Cloud Shell 一站式创建Linux VM
【Microsoft Azure 的1024种玩法】六.使用Azure Cloud Shell对Linux VirtualMachines 进行生命周期管理
【Microsoft Azure 的1024种玩法】七.Azure云端搭建部署属于自己的维基百科
【Microsoft Azure 的1024种玩法】八. 基于Azure云端轻松打造一款好用的私有云笔记
【Microsoft Azure 的1024种玩法】九. Microsoft Azure云端轻松构建部署PostgreSQL数据库
【Microsoft Azure 的1024种玩法】十. 基于Azure App Service 快速上手部署 ASP.NET Web 应用
【Microsoft Azure 的1024种玩法】十一.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b597e1dc5b7b59b43089003de2dfcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0ae663c0058105b1e81feadace70e3/" rel="bookmark">
			学习react之旅·零基础纯网课学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯粹记录个人react零基础成长历程，若有不足多多指导批评。
20220520创建react项目和运行 node.js / npm 配置安装（找博客按步骤安装一大堆） 在终端建脚手架：
npm install -g create-react-app 建立项目：
create-react-app your-app 进入目录 cd your-app 运行 npm start npm start 将是日后使用最多的启动react项目的方式.
20220526 let / const 的认识 基本的运行hello world！
import React from "react"; import ReactDOM from 'react-dom'; const element = &lt;h1&gt; Hello lemon lack&lt;/h1&gt;; React.createElement; console.log(element); ReactDOM.render(element,document.getElementById("root")); for循环体结构：
function sayHello() { for(let i = 0; i&lt;5; i++) { console.log(i); } console.log(i); } sayHello(); 一个属性两个方法：
const person={ name: 'Mosh', walk(){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f0ae663c0058105b1e81feadace70e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6ecf3e8efe5d36dba22d3e8820c05c/" rel="bookmark">
			【解决】npm ERR A complete log of this run can be found in: npm ERR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一些同学可能想配置react的运行环境，苦于不同的电脑遇到千奇百怪的问题和ERROR。下面是我遇到问题对应的解决方案，希望对你们有帮助。 本来我们的基本步骤是：
下载好nvm文件
在里面下载node.js，就是说安装并且use 14.16.1 -&gt;和16.14.2
其次安装npm即可完成react的环境配置。
就可以开始学习react啦！！！
如果出现nvm安装问题就看下面： 把这两段：
node_mirror: https://npm.taobao.org/mirrors/node/ ​ npm_mirror: https://npm.taobao.org/mirrors/npm/ 放进去settings文件
（你在nvm官网安装下来nvm就可以了，在里面有一个settings.txt 文件）
调用npm出现问题
nnpm ERR! Unexpected token '.' ​ npm ERR! A complete log of this run can be found in: ​ npm ERR! C:\Users\Lenovo\AppData\Local\npm-cache\_logs\2022-04-24T15_07_28_136Z-debug-0.log 从而导致yarn在vscode中调用出问题
解决：
首先必须打开权限！
要以管理员身份运行
通过get-ExecutionPolicy查看注册表权限是Restricted是受限制的；
权限问题！可以设置：set-executionpolicy remotesigned
关键是这样做了还是不行！@#￥￥%为什么呢，我当时也纳闷，后来经过苦苦摸索。。。
发现有另外一种办法。 在cmd下
1.
install npm v8.1.0 2.
nvm use 17.0.0 3.
npm i -g yarn 4.
npm i -g yarn 这个时候的npm -v调用看到的是8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6ecf3e8efe5d36dba22d3e8820c05c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fffadac2263bb8dc3045af84e669789/" rel="bookmark">
			C&#43;&#43; —— 指向对象的指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++程序经常使用指向对象的指针，通常会搭配 new 来使用，例如，Class_Name 是类，value 是 Type_Name 类型：
Class_Name * ptr = new Class_Name(value); 该语句会调用如下的构造函数：
Class_Name(Type_Name &amp;); 而下面的初始化则是会调用默认构造函数：
Class_Name * ptr = new Class_Name; 再谈 new 和 delete 对于类对象我们可以在两个层次上使用 new 和 delete。
首先，可以使用 new 为类的数据成员分配存储空间。例如，String 类的char * str 成员，在构造函数中使用 new 生成足够存储字符串的空间，并将地址赋值给 str。由于这是在构造函数中进行的，因此在析构函数中必须使用 delete 释放空间。因为字符串是字符数组，所以构造函数和析构函数中使用带中括号的 new 和 delete。
其次，可以使用 new 来为整个类对象分配内存。String * pstr = new String("YouKa");这不是为要存储的字符串分配内存，而是为对象分配内存，即为保存字符串地址的 str 指针和 len 成员分配内存。需要注意，程序不会给 strNum 成员分配内存，因为 strNum 是静态成员，是独立于对象的。创建对象将调用构造函数，构造函数分配用于保存字符串的内容，并将字符串的地址赋给 str。当程序不在需要该对象时，可以使用 delete 删除它，delete pstr;，这里的 delete 只释放保存 str 和 len 成员的空间，不释放 str 指向的空间，该任务是由析构函数完成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fffadac2263bb8dc3045af84e669789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e03f1983cbcd1947611f7bf1bc41bb15/" rel="bookmark">
			double类型的两个数可以直接比较吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接： double类型（浮点数）是否相等的判断方法_haikuotiankongdong的博客-CSDN博客_double比较是否相等
·
举个例子： double a1 = 2.11; double a2 = 2.10; double a3 = a1 - a2; double b1 = 7.98; double b2 = 7.97; double b3 = b1 - b2; System.out.println(a3 == b3); 乍一看，觉得肯定是true啊，都是0.01，其实不是，结果是false；
因为无论我们使用哪种编程语言，在哪种编译环境下工作，都要先把源代码翻译成二进制的机器码才能被计算机所识别。
举个简单的例子，在源程序里面2.4，是十进制的，但计算机不能直接识别，要先编译成二进制。
那么问题来了，2.4的二进制并非是精确的2.4，反而是最为接近的二进制表示是2.39999999999999999999。
打印出来a3和b3看看：
可以看到，这两个double类型的变量，即使看起来觉得是相等的，但是其实并不是的，因为double浮点数存在精度问题，它所表示的是一个精度区间。
这两个double类型的变量表示的只是0.01上下的一个精度区间内的一个数字。
要真正理解，在Java中，float和double都是浮点数，是二进制数值表示的，就可能出现精度缺失问题。所以处理float和double类型数值时，必须注意精度问题。
`
结论： double类型的两个数可以使用&lt;、&gt;，但是不能直接用==、&gt;=、&lt;=比较大小，
因为double类型的表示往往是不精确的(近似表示)，double浮点数存在精度问题，它是属于有精度范围的那种，不够精确。
所以，
double类型的两个数可以使用&lt;、&gt;，因为比较大于小于，跟精度范围没有关联；
但是不能直接用==、&gt;=、&lt;=比较大小，因为会涉及到具体的精度。
·
拓展： ①，关于double和float类型的加减乘除必须使用BigDecimal。
②，要多去更加理解计算机中浮点数二进制表示会导致精度问题。详情参见：double类型精度丢失问题，以及解决方法_Morning sunshine的博客-CSDN博客
③，NaN： 比如说，Double里边的NaN是一个double类型的常量，但是NaN和任何数据用==比较，都是false；
详情参见：Double里边的NaN是什么？_Morning sunshine的博客-CSDN博客
·
最后： 所以，对于double类型，&gt;、&lt;可以直接进行比较，
==、&gt;=、&lt;=这种情况，最好是通过Double.doubleToLongBits()方法将其先转为long类型，然后再去进行比较。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728e9366725fe785e8414ea75800b54a/" rel="bookmark">
			kubernetes单节点部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主从服务器 [root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# setenforce 0 [root@localhost ~]# hostnamectl set-hostname master [root@localhost ~]# su #关闭swap [root@master ~]# sed -ri 's/.*swap.*/#&amp;/' /etc/fstab [root@master ~]# swapoff -a #本地映射/etc/hosts [root@master ~]# vim /etc/hosts 192.168.68.200 master 192.168.68.30 node1 192.168.68.105 node2 ##时间同步 [root@master ~]# yum install ntpdate -y [root@master ~]# ntpdate time.windows.com [root@master ~]# cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF [root@master ~]# sysctl --system ##安装docker [root@master ~]# yum-config-manager \ --add-repo \ https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728e9366725fe785e8414ea75800b54a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/140/">«</a>
	<span class="pagination__item pagination__item--current">141/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/142/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>