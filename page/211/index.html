<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6795bb264342d2467089a00da1f94ccb/" rel="bookmark">
			解析Vue2.0和3.0的双向数据绑定原理和异同(带源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析Vue2.0和3.0的双向数据绑定原理和异同(带源码) Vue2.0和Vue3.0实现原理 Vue 2.0 Vue2.0实现MVVM(双向数据绑定)的原理是通过 Object.defineProperty 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
Vue官网也给出了解释:
Vue 3.0 实现响应式基于ES6:Proxy
Vue2.0和Vue3.0的差异如下: Vue2.0 基于Object.defineProperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式。Object.defineProperty 无法检测到对象属性的添加和删除 。由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。深度监听需要一次性递归，对性能影响比较大。 Vue3.0 基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除。不需要一次性遍历data的属性，可以显著提高性能。因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。 Vue2.x实现响应式 下面是基于Object.defineProperty ,一步步实现简单版Vue2.0。
由于Object.defineProperty 无法监听数组，所以数组类型实现响应式，需要处理。 判断如果是数组类型，就重写数组的原型方法(‘push’,‘pop’,‘shift’,unshift) // 重新定义数组原型，Object.defineProperty不具备监听数组的方法 const oldArrayProperty = Array.prototype; const arrProto = Object.create(oldArrayProperty); ["push","pop","shift","unshift","splice"].forEach( methodName =&gt; (arrProto[methodName] = function() { updateView(); oldArrayProperty[methodName].call(this, ...arguments); }) ) 将传入的data属性进行深度监听，判断是对象还是数组。 function observer(target){ if(typeof target !== 'object' || target === null){ return target } // 如果是数组类型,重写数组原型的方法("push","pop","shift","unshift","splice") if(Array.isArray(target)){ target.__proto__ == arrProto; } // 如果是对象，遍历对象所有的属性，并使用Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6795bb264342d2467089a00da1f94ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55850f3216b507994c41726ad44cb09/" rel="bookmark">
			如何使用Python爬虫&#43;数据分析对新冠疫情数据实时监控！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1x00】前言 本来两三个月之前就想搞个疫情数据实时数据展示的，由于各种不可抗拒因素一而再再而三的鸽了，最近终于抽空写了一个，数据是用 Python 爬取的百度疫情实时大数据报告，请求库用的 requests，解析用的 Xpath 语法，词云用的 wordcloud 库，数据可视化用 pyecharts 绘制的地图和折线图，数据储存在 Excel 表格里面，使用 openpyxl 对表格进行处理。
本程序实现了累计确诊地图展示和每日数据变化折线图展示，其他更多数据的获取和展示均可在程序中进行拓展，可以将程序部署在服务器上，设置定时运行，即可实时展示数据，pyecharts 绘图模块也可以整合到 Web 框架（Django、Flask等）中使用。
在获取数据时有全球和境外两个概念，全球包含中国，境外不包含中国，后期绘制的四个图：中国累计确诊地图、全球累计确诊地图（包含中国）、中国每日数据折线图、境外每日数据折线图（不包含中国）。
注意项：直接向该网页发送请求获取的响应中，没有每个国家的每日数据，该数据获取的地址是：https://voice.baidu.com/newpneumonia/get?target=trend&amp;isCaseIn=1&amp;stage=publish
预览地址：http://cov.itrhx.com/数据来源：https://voice.baidu.com/act/newpneumonia/newpneumonia/pyecharts 文档：https://pyecharts.org/openpyxl 文档：https://openpyxl.readthedocs.io/wordcloud 文档：http://amueller.github.io/word_cloud/ 【2x00】思维导图 【3x00】数据结构分析 通过查看百度的疫情数据页面，可以看到很多整齐的数据，猜测就是疫情相关的数据，保存该页面，对其进行格式化，很容易可以分析出所有的数据都在 &lt;script type="application/json" id="captain-config"&gt;&lt;/script&gt; 里面，其中 title 里面是一些 Unicode 编码，将其转为中文后更容易得到不同的分类数据。
由于数据繁多，可以将数据主体部分提取出来，删除一些重复项和其他杂项，留下数据大体位置并分析数据结构，便于后期的数据提取，经过处理后的数据大致结构如下：
&lt;script type="application/json" id="captain-config"&gt; { "component": [ { "mapLastUpdatedTime": "2020.07.05 16:13", // 国内疫情数据最后更新时间 "caseList": [ // caseList 列表，每一个元素是一个字典 { "confirmed": "1", // 每个字典包含中国每个省的每一项疫情数据 "died": "0", "crued": "1", "relativeTime": "1593792000", "confirmedRelative": "0", "diedRelative": "0", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55850f3216b507994c41726ad44cb09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361313b2143f2ec61ea9f3769765916e/" rel="bookmark">
			Spring自带定时任务框架Schedule
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @Component @EnableScheduling public class SchedulerTask{ /* * * DESC : 编写定时任务，每5秒输出一次 * */ @Scheduled(cron = "*/5 * * * * ?") private void scheduleTask(){ System.out.println("Schedule............"); } } 如果想要在项目启动时就执行一次定时任务，可以实现InitializingBean接口
import org.springframework.beans.factory.InitializingBean; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; @Component @EnableScheduling public class SchedulerTask implements InitializingBean{ /* * * DESC : 编写定时任务，每5秒输出一次 * */ @Scheduled(cron = "*/5 * * * * ?") private void scheduleTask(){ System.out.println("Schedule............"); } @Override public void afterPropertiesSet() throws Exception { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361313b2143f2ec61ea9f3769765916e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a712ac977a3666f792f708828764a8bb/" rel="bookmark">
			你的分支在3次提交之前领先于‘origin / master‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文翻译自：Your branch is ahead of 'origin/master' by 3 commits
I am getting the following when running git status 运行git status时我得到以下内容 Your branch is ahead of 'origin/master' by 3 commits. I have read on some other post the way to fix this is run git pull --rebase but what exactly is rebase, will I lose data or is this simple way to sync with master? 我已经阅读了其他一些文章修复此问题的方法是运行git pull --rebase但究竟什么是rebase，我会丢失数据还是这种与master同步的简单方法？ #1楼 参考：https://stackoom.com/question/16liw/你的分支在-次提交之前领先于-origin-master
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a712ac977a3666f792f708828764a8bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210b5b4553cc5358876107ac8adfc981/" rel="bookmark">
			QT：QTextBrowser设置最大行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ui-&gt;textBrowser-&gt;document()-&gt;setMaximumBlockCount(10); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26fed43d94227d42057d39335876744f/" rel="bookmark">
			NatCam 移动端插件 for Unity3d 使用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 插件导入后需要将ios模块库更改为取消安卓平台编译，我是应用在安卓手机上故有此设置一步，发布ios平台的可以无视。
插件样例介绍不是很多，但设置起来很方便，亲测不仅后置摄像头可以调整焦距，就连前置摄像头也可以调整，比系统自带的还厉害，真是 i 服了 u 了。曝光度调节 手电筒开关等等必需的设置都有了相对于手机端摄像头。
具体设置如下：
曝光调节 NatCam.Camera.ExposureBias =value;
焦距调节 NatCam.Camera.ZoomRatio = value ;
手电筒 NatCam.Camera.TorchMode = on / off;
自带的摄像头切换有问题，不能循环切换，所以需要自己手动更改一下下，我根据 facing 的值作了二次判断实现了循环切换。
总结 帧率速度确实挺快，设置起来也很简单，现在此插件已经下架，上架了全新版本，可发布全平台名称NatDevice - Media Device API 有兴趣的同学可以研究研究。
最后本编微信 1780260056 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bfee177d33df5a1fc06557a596efe8/" rel="bookmark">
			redis setIfAbsent的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果为空就set值，并返回1
如果存在(不为空)不进行操作，并返回0
很明显，比get和set要好。因为先判断get，再set的用法，有可能会重复set值。
setIfAbsent 和 setnx setIfAbsent 是java中的方法
setnx 是 redis命令中的方法
setnx 例子 redis&gt; SETNX mykey "Hello" (integer) 1 redis&gt; SETNX mykey "World" (integer) 0 redis&gt; GET mykey "Hello" setIfAbsent 例子 代码：
BoundValueOperations boundValueOperations = this.redisTemplate.boundValueOps(redisKey); flag = boundValueOperations.setIfAbsent(value); // flag 表示的是否set boundValueOperations.expire(seconds, TimeUnit.SECONDS); if(!flag){ // 重复 repeatSerial.add(serialNo); continue; }else{// 没有重复 norepeatSerial.add(serialNo); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea0d545345542344e063a7ab52a98fb3/" rel="bookmark">
			Java文件操作专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我心目中，能在操作系统中存储文件，读取文件一直是一个神秘的领域，能用编程完成文件的增删改查是我之前学编程时的动力之一，之前的C语言最多只会写入txt文档，并且读出来还非常费劲，Python因为各种包的存在，保存文件以及读取文件变得非常轻松，但是操作文件又是另一回事了，对于包不支持的文件类型就毫无办法（只是我不知道而已），现在来到了Java，这次在拉钩大数据课程的辅助下，我准备整理出文件操作的方法，以及配合多线程和网络编程，完成一些之前看来是不可能的任务。
正文 首先所有文件都可以用字节进行传输
但是读取字符的时候需要使用字符流（也可以把字节流转为字符流然后进行读取）
下图是所有的IO流结构
代码实际操作目录 接下来以几个小例子充分理解IO流的内容
1.txt文件输入，控制台字符输出
2.控制台字符输入，txt文件输出
3.任意文件输入，任意文件输出（复制操作）
4.遍历文件夹下所有文件并复制
5.保存类文件并读取
6.在网络程序中实现文件传输
代码实际操作 1.txt文件输入，控制台字符输出
package com.csdn.IO; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class Work2 { public static void main(String[] args) { FileReader fr =null; BufferedReader br = null; try { fr = new FileReader("d:/a.txt"); br=new BufferedReader(fr); String str=null; while ((str=br.readLine())!=null) { System.out.println(str); } } catch (IOException e) { e.printStackTrace(); }finally { try { if(br!=null) { br.close(); } if(null!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea0d545345542344e063a7ab52a98fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e8970e3a73480daec5197daebb8d35/" rel="bookmark">
			社会网络分析中的基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：数据猿Riggle
来源：文科数据员
经过前两篇的学习，我们已经对社会网络分析有一个模糊概念了。
社会网络分析(一) | python的Networkx库基础知识
社会网络分析(二) | Network的论文
今天数据猿就整理了一下社会网络分析的基本概念，阅读时可不求甚解，遇到实际问题再进一步深究。
本文目录如下——
度 每一个节点连接的所有边的数量，包括出度和入度。一般来说，无向图中就是所有边的数量，在有向图中就是出度和入度之和。
出度 从该节点连出的边的数量
入度 从该节点连入的边的数量
平均度 网络中的平均度等于度除以节点数量。
无向图中，平均度=度总数/节点数量
有向图中，出度总数等于入度总数，平均度=出度总数/节点数量
平均加权度 在统计节点度时，也考虑边的权重。边权重非1情况时，就不能套用平均度的公式，需要加权计算。
边 可简单理解为和所有节点连接线
边的权重 每条边与之对应的值。因计算方式和意义而异。如边上是距离，权重就是距离。如果是社区探测，就是社区的联系程度。
中心性 计算出网络直径等网络的边的特性后，就可以计算出中介中心度（Betwenness Centrality）、亲密中心度（Closeness Centrality）、离心度（Eccentricity），还有新增的Harmonic closeness Centrality等。在Gephi中，
度中心性（Degree Centrality） 单纯的数量来衡量。又叫点度中心度，度越多，就越大。
接近中心性（Closeness Centrality） 一个节点能到达节点的数量除以所能到达节点的最短路径之和。
简单理解为与其他中心的中心性。接近中心性的值为路径长度的倒数。接近中心性需要考量每个节点到其它节点的最短路的平均长度。也就是说，对于一个节点而言，它距离其它节点越近，那么它的中心度越高。
中介中心性（Betweenness Centrality） 统计某个节点被其他节点，以最短路径通过的数量与图中最短路径总数之比。
一个结点充当“中介”的次数越高，它的中介中心度就越大。
离心度 从一个节点所有可以到达的节点中，找出最长的最短路径。即一个节点所能达到的最大的最短路径。
特征向量中心性（Eigenvector Centrality） 一个节点的重要性既取决于其邻居节点的数量（即该节点的度），也取决于其邻居节点的重要性。核心思想就是，一个重要的节点不仅与其他许多节点有连接，而且与他相连的节点也是比较重要的节点。
图密度 实际有的边数与最大可能边数之比。比如，3个节点，可只有一条边。那么图密度就是1/6.
连接组件 可以确定一个图中连接组件的数量。
无向图中，如果所有的节点都可以连通，称为为连通图。
有向图中，从任何一个节点沿着边的方向都可以到达任何一个节点，因此被称为强连通图。弱连通图是有部分节点可以沿着边的方向到达任何一个节点。
社会网络分析算法 模块化（社区探测算法） 根据图的连接关系对节点做归类，类型相同的节点会增加一个字段，用相同的数字表示。模块化在社会学中可以用于社区发现。
衡量网络图结构的模块化程度。一般&gt;0.44 就说明该网络图达到了一定的模块化程度 。
Pagerank 是一种根据网页之间的链接关系对网页的重要性进行评分的算法。
平均聚类系数 聚类系数：一个节点一度连接的节点中，实际的边数与最大边数之比。
比如4个节点，从其中一个节点a出发，连接了5条，有1条对角线没有。实际边数就是没有直接相连的两个节点通过a的对点连接的两条边。那么节点a的平均聚类系数就是实际边数2/最大边数3。
路径长度 网络整体会统计图的直径（Diameter）、半径（Radius）、平均路径长度（Aerage Path Length），三个指标都与最短路径数（Number of shortest paths）有关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e8970e3a73480daec5197daebb8d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7362a2e1f7c50c343885d9e85c1daaf9/" rel="bookmark">
			使用Indemind双目模组跑ORB_SLAM3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Indemind双目模组跑通ORB_SLAM31.下载源码编译2.ROS编译错误3.配置文件 Indmeind跑ORB_SLAM3的VIO1.按照ORB_SLAM3正常编译即可2.运行 Indemind双目模组跑ORB_SLAM3实测 Indemind双目模组跑通ORB_SLAM3 首先感谢作者的贡献与开源。ORB_Slam3的介绍不做叙述，这里只对编译过程做出详细介绍。ORB_Slam3的介绍创新有时间在更新。
1.下载源码编译 ORB_SLAM3地址
纯视觉或加IMU跑Euroc数据集效果很好。
纯视觉跑或加IMU跑Indmeind双目模组表现也很好，注意在录制数据集的时候可以参考Euroc数据集初始的摆动，时间大概在20-30秒之间即可完成初始化。(ORB_SLAM3的对初始化的要求比较高)
//按照官方编译即可 //正常ROS编译 catkin_make //编译ORB_SLAM3 cd ORB_SLAM3 chmod +x build.sh ./build.sh 这里对ROS进行编译会有一些错误。
2.ROS编译错误 1.类似与这种的错误
[rosbuild] rospack found package "ORB_SLAM2" at "", but the current directory is "/home/angelo/ORB_SLAM2/Examples/ROS/ORB_SLAM2". You should double-check your ROS_PACKAGE_PATH to ensure that packages are found in the correct precedence order. 将所有代码下的命名空间由ORB_SLAM2改为ORB_SLAM3
这样改完之后你还会遇到错误
2.某个.h文件的GeometricCamera.h、KannalaBrandt8.h、Pinhole.h文件找不到
1.在该.h文件添加正确的路径 2.其实这三个.h文件是在报错的.h文件的下一级目录，可以复制到上一级 别高兴，你应该还会遇到一类错误
3.boost文件找不到Makefile，这个主要是你编译了多个ORB_SLAM
解决办法Examples/ROS/ORB_SLAM3/Cmakelist.txt里面添加
target_link_libraries(Stereo boost_system boost_filesystem) target_link_libraries(RGBD boost_system boost_filesystem) target_link_libraries(Mono boost_system boost_filesystem) 注意一些topic问题，安装sdk，启动sdk看之前博客，这样你就可以顺利的跑起来SDK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7362a2e1f7c50c343885d9e85c1daaf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941aa1b7041ad5b3942ef6614663cb82/" rel="bookmark">
			串口收发乱码解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口收发乱码解决方案 串口收发乱码解决方案总结 串口收发乱码解决方案 在使用基于stm32f103rct6芯片的板子实现485收发时，发现可以发送也可以接收，但是收发的数据都是乱码。
第一步，因为可收可发，引脚肯定没问题；
第二步检查波特率，检查后发现波特率也没问题；
第三步检查时钟配置，仿佛也是没问题。。。
此时已经郁闷了。
二话不说，先上485配置代码：
static void uart1_config(uint32_t baud_rate) { GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); /* * UART1_TX PA9 * UART1_RX PA10 * RS485EN PA11 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = baud_rate; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/941aa1b7041ad5b3942ef6614663cb82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6393767494c4b8c7f3b636c01dc1427/" rel="bookmark">
			qt构建遇到 cannot find -l xxx 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题：qt构建遇到cannot find -lxxx问题 :-1: error: cannot find -lz :-1: error: cannot find -llzma :-1: error: collect2: error: ld returned 1 exit status 2.分析：代码没有问题，库的路径问题 3.解决 cannot find -lz 3.1查找libz locate libz 3.2查找结果 /home/user/share/stone/src/tomato/lib/libzlib.a /home/user/work/Falcon/vigorflow/firmware/T02/controler/stone/src/tomato/lib/libzlib.a /lib/i386-linux-gnu/libz.so.1 /lib/i386-linux-gnu/libz.so.1.2.11 /lib/x86_64-linux-gnu/libz.so.1 /lib/x86_64-linux-gnu/libz.so.1.2.11 /snap/core/9436/lib/x86_64-linux-gnu/libz.so.1 /snap/core/9436/lib/x86_64-linux-gnu/libz.so.1.2.8 /snap/core/9665/lib/x86_64-linux-gnu/libz.so.1 /snap/core/9665/lib/x86_64-linux-gnu/libz.so.1.2.8 /snap/core18/1754/lib/x86_64-linux-gnu/libz.so.1 /snap/core18/1754/lib/x86_64-linux-gnu/libz.so.1.2.11 ....... 3.3建立软链接 sudo ln -s /lib/x86_64-linux-gnu/libz.so.1 /usr/lib/libz.so 3.4重启qt，再次构建问题1解决 4.同样方法，解决 cannot find -llzma 4.1查找liblzma locate liblzma 4.2查找结果 /lib/i386-linux-gnu/liblzma.so.5 /lib/i386-linux-gnu/liblzma.so.5.2.4 /lib/x86_64-linux-gnu/liblzma.so.5 /lib/x86_64-linux-gnu/liblzma.so.5.2.4 /snap/core/9436/lib/x86_64-linux-gnu/liblzma.so.5 /snap/core/9436/lib/x86_64-linux-gnu/liblzma.so.5.0.0 /snap/core/9436/usr/share/doc/liblzma5 /snap/core/9436/usr/share/doc/liblzma5/changelog.Debian.gz /snap/core/9436/usr/share/doc/liblzma5/copyright.gz /snap/core/9665/lib/x86_64-linux-gnu/liblzma.so.5 /snap/core/9665/lib/x86_64-linux-gnu/liblzma.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6393767494c4b8c7f3b636c01dc1427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c833829336518390e2ab7601b22814a/" rel="bookmark">
			yes or no？基于词典的情感分析法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自更博以来第一次断更，现在先把文本分析的坑补上，这篇文章着重介绍情感分析的两种基本方法之一：基于词典的情感分析（下篇讲基于监督的情感分析），建模环境为R。
目录 1 背景与目的1.1 情感分析的应用场景1.2 情感分析的痛点 2 方法与实现2.1 什么是基于词典的情感分析2.2 怎么做词典式情感分析2.2.1 数据介绍2.2.2 训练集分词2.2.3 情感分析（统计两性词汇数量并比较）2.2.4 测试集验证、结果评价与调优 1 背景与目的 1.1 情感分析的应用场景 顾客的评价最能反映其对商品的使用感受，对此类信息进行加工，提炼产品痛点和亮点，实现针对性改进和营销，是一个很有意义的方向。
研究这些文本内容的情感倾向（比如正、负or中），就是咱们情感分析要解决的问题。
1.2 情感分析的痛点 1）研究对象难，情感分析的研究对象是长文本，相比其它传统数据类型，难度更大，加上话语表达博大精深拐弯抹角阴阳怪气，连人都分不清的话中话，就别指望模型了；
2）建模过程难，这也是文本类分析的通病，有大量分词操作和超级稀疏矩阵，吃内存；
3）前期工作要求高，有些数据和模型几乎啥都不要可以直接上手，但情感分析不行，基于词典的情感分析需要精确度较高囊括范围较广的词典，基于监督的情感分析则需要预置情感类型准确性较高的文本进行训练，这些数据都是需要人工标注的。
情感分析前期准备工作量大，中间建模过程难，最后结果也未必如人意，但还是要做，因为大型语料以人力实现难、枯燥且不具有连续型，而一个不断训练提升的模型最后不管是从成本从效率还是准确性来说相比起来并不差。另外，以工具解放工具人，让人去干人该干的事，也是建模的初衷之一。
2 方法与实现 2.1 什么是基于词典的情感分析 简单来说就是以包含的褒义词和贬义词的数量投票。
先分词，然后对比分词结果与已总结好的褒义词和贬义词词典，统计两类词汇的数量，哪边多情感偏向哪边。词典的准确性直接影响该方法的分类效果，常规情感词典参考：
2.2 怎么做词典式情感分析 2.2.1 数据介绍 1）语料
酒店评论文本：训练集23967条，测试集4000条（清华李军标注整理）
2）词典
正向词汇21563个，负向词汇24575个（上面方法介绍中提到的参考词典的分类汇总）
2.2.2 训练集分词 #文本清洗 sentence &lt;- as.vector(test$msg) sentence &lt;- gsub("[[:digit:]]*", "", sentence) #清除数字[a-zA-Z] sentence &lt;- gsub("[a-zA-Z]", "", sentence) sentence &lt;- gsub("\\.", "", sentence) test &lt;- test[!is.na(sentence), ] sentence &lt;- sentence[!is.na(sentence)] test &lt;- test[!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c833829336518390e2ab7601b22814a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5189e5c243bf622ac8894c86bda0f555/" rel="bookmark">
			ubuntu date -R查看时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a222805f40a44b17a1ab797bfed6bbc/" rel="bookmark">
			阅读Decoupled Spatial-Temporal Attention Network for Skeleton-Based Action Recognition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于骨骼动作识别的解耦时空注意网络
paper：https://arxiv.org/abs/2007.03263
文章目录 AbstractIntroductionMethod3.1 Spatial-temporal attention module 3.2 Decoupled Position encoding3.3 Spatial global regularization3.4 Complete attention module3.5 Overall architecture3.6 Data decoupling 后续补充 Abstract 以人体关节二维/三维坐标表示的动态骨骼数据，由于其高层次的语义信息和环境鲁棒性，在人体动作识别中得到了广泛的研究。然而，以往的方法在很大程度上依赖于手工设计遍历规则或图拓扑来绘制关节之间的依赖关系，这在性能和泛化方面都受到了限制。在这项工作中，我们提出了一种新的解耦时空注意网络（DSTA-Net），用于基于骨架的动作识别。它只涉及注意块，允许建模关节之间的时空依赖关系，而不需要知道它们的位置或相互连接。具体来说，针对骨骼数据的具体要求，提出了三种注意块构建技术，即时空注意解耦、解耦位置编码和空间全局正则化。此外，在数据方面，我们引入了骨骼数据解耦技术，以强调空间/时间和不同运动尺度的具体特征，从而对人类行为有更全面的了解。为了验证该方法的有效性，在四个具有挑战性的基于骨架的手势和动作识别数据集SHREC、DHG、NTU-60和NTU-120上进行了大量的实验，其中DSTA网络在所有这些数据集上都取得了SOTA。
Introduction 手工编制的规则是关节全局依赖建模并非最佳选择，作者阐述近年来transformer的自我注意力机制取得了很大的成功。自注意力机制可以降低计算复杂度，并提高全局依赖关系，而且不需要指导元素的内在关系，为发现有用模式提供更大的灵活性。
作者提出了一种新的解耦时空注意网络(DSTA-Net), 模型并没有用与结构相关的RNNs、CNNs或GCNs。但是根据注意力网络自我发现骨骼数据关联的难点如下：
(1) 原始自我注意机制的输入是序列数据，而骨架数据同时存在于空间和时间维度。一种简单的方法是简单地将时空数据展平成一个单一的序列。然而，将时间和空间等同对待是不合理的，因为它们包含完全不同的语义。此外，简单的展平操作增加了序列长度，由于自注意机制的点积运算，大大增加了计算成本。相反，我们建议将自我注意机制依次分解为空间注意和时间注意。为了平衡空间与时间的独立性和互动性，我们专门设计了三种策略。(2) 当将骨骼关节送入注意网络时，没有预定义的顺序或结构。为了给每个关节提供唯一的标记，引入了一种位置编码技术。基于同样的原因，它也被分解成空间编码和时间编码。(3) 结果表明，在先验知识的基础上加入适当的正则化，可以有效地减少过拟合问题，提高模型的泛化能力。例如，由于图像具有平移不变的结构，CNNs利用局部加权机制来迫使模型学习更多针对图像不同区域的通用滤波器。对于骨骼数据，骨骼的每个关节都有特定的物理/语义意义（如头或手），对于所有的帧都是固定的，对于所有的数据样本都是一致的。基于这一先验知识，提出了一种空间全局正则化方法，使模型能够针对不同的样本学习更多的一般注意事项。注意正则化不适用于时间维，因为没有这样的语义对齐特性。 另外，从数据的角度来看，对于不同的行为，不同的模式区别是明显的。我们主张应考虑两种性质。一个特征是动作是与动作相关还是与动作无关,选择特定的时空特征。例如，在对“向上挥手”和“向下挥手”手势进行分类时，手的全局轨迹比手形更重要，但在识别“一指一指”和“两指点”等手势时，空间模式比手势更重要。在此基础上，我们提出将数据分解为空间和时间两个维度，其中空间流只包含与运动无关的特征，而时间流只包含与运动相关的特征。通过分别对这两个流进行建模，该模型可以更好地关注空间/时间特征和特定于身份的模式。最后，通过融合这两条信息流，可以更全面地了解人类的行为。另一个特性是运动尺度的敏感性。对于时间流，一些动作的分类依赖于几个连续帧的运动模式，而另一些则依赖于整体运动趋势。例如，要将“鼓掌”与“双手合十”这两种手势进行分类，短期动作细节至关重要。但对于“向上挥手”与“向下挥手”，长期运动趋势更为重要。因此，我们根据采样率将时间信息分为快流和慢流。低帧速率流可以捕获更多关于全局运动的信息，而高帧速率流可以更关注细节运动。同样，对两个流进行融合，以提高识别性能。
作者在四个数据集上进行了大量的实验，包括两个手势识别数据集SHREC和DHG，以及两个人类动作识别数据集，即NTU-60和NTU-120。在不需要手工编制遍历规则或图拓扑的情况下，作者的方法在所有这些数据集上都达到了SOTA，这证明了该方法的有效性和可推广性。
作者的贡献共四个方面:
据我们所知，作者首次提出了一种用于基于骨架的动作识别的解耦时空注意网络（DSTA-Net），该网络由纯注意模块构成，无需人工设计遍历规则或图拓扑；我们提出了三种有效的建立注意网络的技术，即时空注意解耦、解耦位置编码和空间全局正则化；我们提出将数据分解为四个流，即时空流、空间流、慢时流和快时流，每一个流都集中在骨架序列的一个特定方面。通过融合不同类型的特征，该模型可以对人类行为有更全面的理解。在四个具有挑战性的动作识别数据集上，我们的方法达到了最先进的性能和显著的优势。在SHREC和DHG的14类/28类基准测试中，DSTA Net的表现分别优于SOTA 2.6%/3.2%和1.9%/2.9%。分别达到91.5%/96.4%和86.6%/89.0%分别是NTU-60和NTU-120的CS/CV基准。 Method 3.1 Spatial-temporal attention module 原始transformer由序列数据fed，即矩阵 X ∈ R N × C X \in \mathbb R^{N\times C} X∈RN×C，其中 N N N表示元素个数， C C C表示通道数.对于动态骨骼数据，输入是一个3阶张量 X ∈ R N × T × C X \in \mathbb R^{N\times T \times C} X∈RN×T×C，其中 T T T表示帧数。如何处理时间与空间的关系，是一个值得探讨的问题。Wang等人建议忽略时间和空间的差异，将输入视为一个连续的数据 X ∈ R N ^ × C X \in \mathbb R^{\hat N\times C} X∈RN^×C，，其中 N ^ = N T \hat N=N T N^=NT，但是时间维和空间维是完全不同的, 把它们等同对待是不合理的。此外，该策略计算注意映射的计算复杂度为 O ( T 2 N 2 C ) O(T^2N^2C) O(T2N2C)（采用朴素矩阵乘法算法），计算复杂度过大。相反，我们建议将空间和时间维度解耦，这样可以大大降低计算复杂度并提高性能.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a222805f40a44b17a1ab797bfed6bbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5cf0fc5635badde233844ffe452982/" rel="bookmark">
			数据库字符集问题解决（Incorrect string value: ‘\xE5\xBC\xA0\xE6\x97\xA0...‘ for column ‘name‘ at row 1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Incorrect string value: '\xE5\xBC\xA0\xE6\x97\xA0...' for column 'name' at row 1
这个错误的原因就是数据库的默认编码格式为latin1,而你要将utf8的中文插入到表中。
然后就将表的格式改为utf8。
使用指令为：alter table stu character set utf8;
但修改后发现还是不能将数据添加到表中
想了下是因为表中数据的格式还是latin1,因此还要将表中出错数据的格式换为utf8
使用指令为：alter table stu change name name varchar(50) character set utf8;
然后再重新添加数据就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e3ebdac664a1ea8a2d40f52bfa28e1/" rel="bookmark">
			openstack 使用openstack命令进行操作时报错Missing value auth-url required for auth plugin password
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装openstack中
#输入命令 openstack compute service list --service nova-compute #报错 Missing value auth-url required for auth plugin password 新建admin-openrc.sh（目录位置不重要，记住位置就行），内容如下，记得修改OS_PASSWORD的值，我的是123456
export OS_USERNAME=admin export OS_PASSWORD=123456 export OS_PROJECT_NAME=admin export OS_USER_DOMAIN_NAME=Default export OS_PROJECT_DOMAIN_NAME=Default export OS_AUTH_URL=http://controller:35357/v3 export OS_IDENTITY_API_VERSION=3 执行命令
. admin-openrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0232d4c9cdc4544af982f43dd8f9d813/" rel="bookmark">
			因为不想跑步，所以才去跑步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文本已收录至我的GitHub仓库，欢迎Star：https://github.com/bin392328206/six-finger
种一棵树最好的时间是十年前，其次是现在
我知道很多人不玩qq了,但是怀旧一下,欢迎加入六脉神剑Java菜鸟学习群，群聊号码：549684836 鼓励大家在技术的路上写博客
絮叨 今天是8月的第一天嘛，刚好周末，刚好有时间规划一下学习计划，然后给大家分享一下，和大家一起学习学习，很喜欢的一句话（因为不想跑步，所以才去跑步。）
下文的资料地址 链接：https://pan.baidu.com/s/1cVbPe5nxPB1Bpj3x93QtHw ，提取码：k5ox
Netty 这个是小六六这个月的主要目标了，哈哈。说说我为啥打算学习一下这个呢？是因为前面再学习rocketmq的时候，我看namesrv的源码里面的通信框架就是netty，然后自己平时也很少接触这块，但是为了更好的去理解一下东西我还是觉得有必要好好学习，我一般呢?喜欢一边学习，一边写博客，虽然很多时候都是copy的，但是过一遍总是好的哈哈，既然要给大家推荐，干货肯定是有的
学习视频
我觉得入门一个东西的最好方式视频，看字眼 我说的是入门，就是以最快的速度知道这个东西是什么，怎么样，最简单的用法就好了，
我这边推荐的是 韩顺平老师的netty 从入门到源码 哈哈 非常不错，直接搜索bi站 第一个就是韩老师的视频，然后资料我已经放在了前文的百度网盘中了，大家可以去链接中拿
学习资料
然后呢，如果你入门了一个东西之后，要继续学习的话，那么你就需要找书籍或者是官网的文档去学习了，因为这样是比较全面的，比较完善的了。
然后资料我也放到网盘里面了，这个月的主线就是netty了
一些进阶的书籍 其实小六六发现一个问题，很多时候写业务，其实真的不是难不难的问题，其实是对产品业务的理解了，如果你理解了业务，那么如果仅仅是实现代码的话，那么我觉得1年 经验 和几年经验都差不多，不过呢 肯定还是有点区别的，但是我觉得差距就不那么大了，所以呢，再理解业务之后，我们就要修炼我们的代码，大家去看Spring的源码的时候，就会觉得自己写的代码有多么的low了。所以小六六还会跟大家一起来学习下面的 代码修炼之道的书，并用在平时公司的项目里面，学的再多也是要用上，才能熟能生巧
高效Java
这本书应该不错，很多人推荐，小六六还没看，这个月会完成任务的
程序员进阶 极客时间的一个专栏
结尾 哈哈，其实就是一个月度学习规划的书，哈哈把资料送给大家一起学习哈。。随便水一篇文章
日常求赞 好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是真粉。
创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见
六脉神剑 | 文 【原创】如果本篇博客有任何错误，请批评指教，不胜感激 ！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a66abc3c2f4258d554cf2b40eb3556/" rel="bookmark">
			最新综述：深度学习图像三维重建最新方法及未来趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“3D视觉工坊”，选择“星标”
干货第一时间送达
今天分享的是：深度学习领域基于图像的三维物体重建最新方法及未来趋势综述。原文：Image-based 3D Object Reconstruction: State-of-the-Art and Trends in the Deep Learning Era
论文下载：https://arxiv.org/abs/1906.06543
摘要：三维重建是计算机视觉计算机图形学和机器学习等领域几十年来一个不适定问题。从2015年开始使用CNN解决基于图像的三维重建（image-based 3D reconstruction）有了极大的关注并且展示出强大的性能。在新时代的快速发展下，我们提供了这一领域详细的调研。本文章专注于从RGB图像估计三维物体形状的深度学习方法。除此之外我们还回顾了关于特定物体（如人脸）的近期研究。我们一些重要论文性能的分析和比较，总结这一领域的现有问题并讨论未来研究的方向。
本文是深度学习做三维重建的一篇综述
对自2015年以来本领域的149个方法做详尽的回顾
深入分析深度学习三维重建的各个方面，包括训练集，网络架构选择以及重建结果，训练技巧和应用场景
总结对比了普遍的三维重建算法（88种），本文还包含了三维人脸重建算法（11种），人体形状重建算法（6种方法）
问题陈述和分类 假设 为物体 的一张或多张RGB图片。三维重建可以总结为一个学习预测算子 的过程，输入图像到该算子可得到一个和物体 相似的模型 。因此重建的目标函数为 ,其中 为算子的参数， 为重建结果和目标 的距离函数， 也称作深度学习中的损失函数。
如上表所示，本文依据输入数据（Input），输出的表示（Output），神经网络结构（Network architecture）和训练步骤（Training）对算法进行了分类。输入可以是单张图片，多张图片（已知／未知外参），或是视频流，即具有时间相关性的图像序列；输入也可以是描述一个或多个属于已知／未知类别的物体；还可以包括轮廓，语义标注等先验作为输入数据。输出的表示对网络结构的选择来说很重要，它影响着计算效率和重建质量，主要有三种表示方法。体积表示（Volumetric）：在早期深度学习的三维重建算法中广泛采用，它可采用体素网格来参数化三维物体；这样二维卷积可以很容易扩展到三维，但是会极大消耗内存，也只有极少数方法达到亚像素精度。基于面的表示（Surface）：如网格和点云，它们占用内存小，但不是规则结构，因此很难融入深度学习架构中。中间表示（Intermidiate）：不直接从图像预测得到三维几何结构，而是将问题分解为连续步骤，每个步骤预测一个中间表示。实现预测算子 的网络结构有很多，它的主干架构在训练和测试阶段也可能是不同的，一般由编码器h和解码器g组成，即 。编码器将输入映射到称为特征向量或代码的隐变量x中，使用一系列的卷积和池化操作，然后是全连接层。解码器也称为生成器，通过使用全连接层或反卷积网络（卷积和上采样操作的序列，也称为上卷积）将特征向量解码为所需输出。前者适用于三维点云等非结构化输出，后者则用于重建体积网格或参数化表面。虽然网络的架构和它的组成模块很重要，但是算法性能很大程度上取决于它们的训练方式。本文将从三方面介绍。数据集：目前有多种数据集用于深度学习三维重建，一些是真实数据，一些是计算机图形生成的。损失函数：损失函数很大程度上影响着重建质量，同时反映了监督学习的程度。训练步骤和监督程度：有些方法需要用相应的三维模型标注真实的图像，获得这些图像的成本非常高；有些方法则依赖于真实数据和合成数据的组合；另一些则通过利用容易获得的监督信号的损失函数来避免完全的三维监督。以下为这些方面的详细介绍
编码阶段 基于深度学习的三维重建将输入图像 编码为特征向量 ，其中 为隐空间。一个好的映射方程应该满足一下性质。
表示相似物体的两张图像映射在隐空间应彼此相似
的一个小的扰动应与输入形状小的扰动对应
由h引起的潜在表示应和外界因素无关，如相机位姿
三维模型及其对应的二维图像应映射在隐空间的同一点上，这确保表示的特征不模糊，从而有助于重建
前两个条件可以通过使用编码器解决，编码器将输入映射到离散或者连续的隐空间，它可以是平面的或层次的。第三个条件可以通过分离表示解决，最后一个在训练阶段通过使用TL架构（将在training章节中讲）来解决。
离散隐空间Wu在他们的开创性工作[3]中引入了3D ShapeNet，这是一种编码网络，它将表示大小为 的离散体积网格的三维模型映射到大小4000×1的向量表示中。其核心网络由3个卷积层（每个卷积层使用3D卷积滤波器）和3个全连接层组成。这种标准的普通架构已经被用于三维形状分类和检索，并用于从以体素网格表示的深度图中进行三维重建。将输入图像映射到隐空间的2D编码网络有着与3D ShapeNet相似的网络架构，但使用2D卷积，代表工作有[4],[5],[6],[7],[8],[9],[10]和[11]。早期的工作在使用的网络层的类型和数量上有所不同，包括池化层和激活函数有所不同。
连续隐空间使用前一小节中介绍的编码器，隐空间 可能不是连续的，因此它不允许简单的插值。换句话说，如果 并且 ，则不能保证 可以解码为有效的3D形状。此外， 的小扰动也不会对应于输入的小扰动。变分自编码器（VAE）及其3D扩展（3D-VAE）具有一个让它们适合生成建模的独特的特性：通过设计，它们的隐空间是连续的，允许采样和插值。其关键思想是，它不是将输入映射到特征向量，而是映射到多变量高斯分布的平均向量 和标准差 向量。然后，采样层获取这两个向量，并通过从高斯分布随机采样生成特征向量 ，该特征向量 将用作随后解码阶段的输入。这样的思想用于为体积表示([17],[18])，深度表示([19])，表面表示([20])，以及点云表示([21],[22])的三维重建算法学习连续隐空间。3D-VAE可以对在训练阶段没有见过的图片重建出不错结果。
层次隐空间Liu[18]表明，将输入映射到单个潜在表示（向量表示）的编码器不能提取丰富的结构，因此可能导致模糊的重建。为提高重建质量，Liu引入了更复杂的内部变量结构，其具体目标是鼓励对潜在特征检测器的分层排列进行学习。该方法从一个全局隐变量层开始，该层被硬连接到一组局部隐变量层，每个隐变量层的任务是表示一个级别的特征抽象。跳跃连接以自上而下的定向方式将隐编码（向量）连接在一起：接近输入的局部代码将倾向于表示较低级别的特征，而远离输入的局部代码将倾向于表示较高级别的特征。最后，当输入到特定于任务的模型（如三维重建）中时，将局部隐编码连接到扁平结构。
分离表示一张图像中物体的外观受多个因素的影响，例如对象的形状、相机位姿和照明条件。标准编码器用经过学习的编码 表示所有这些变量。这在诸如识别和分类之类的应用中是不可取的，这些应用应该对诸如位姿和照明之类的外部因素保持不变。三维重建也可以受益于分离式表示，其中形状、位姿和灯光用不同的编码表示。为了达到这一目的，Grant等[5]提出一个编码器，可以将RGB图像映射为一个形状编码和一个位姿变换编码。它们将会分别解码为三维形状与光线条件位姿。此外，Zhu等人[24]使用相似的思想，将6DOF的位姿参数和三维模型解耦。这样减少网络中的参数，提高了效率。
体积解码 体积表示将三维物体离散化成三维体素栅格 。离散化的越精细，模型也表示的更准确。解码的目标就是输入图像，恢复出栅格，使得三维形状近似真实的三维物体。使用体积栅格表示的优点是很多为二维图像分析设计的深度学习框架可以很简单地扩展到三维数据（三维卷积与池化）。下面分别介绍不同体积表示方式，低精度解码器架构以及高精度三维重建。下表为各种体积解码器的分类：
三维形状的体积表示在文献中主要有四种体积表示方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6a66abc3c2f4258d554cf2b40eb3556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7095c56ba9291c380ace01fbc56b8e/" rel="bookmark">
			【NOIP2014】P2296 寻找道路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一道比较基础的图遍历的题。
思路很巧妙，要考虑到反向建图，反向BFS,找出能达到终点的点1，再正向遍历，找到这些点1中出边点均能到终点的所有点2，然后再从起点遍历，只所有2类点中找最短路径
一开始总是TLE，后来发现是初始化建图时候没有考虑到重复操作，同一个点被处理了多次，时间耗时大大降低，见代码中关键优化一段
#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; queue&lt;int&gt; qNode; int n, m,x,y,s ,t; vector&lt;int&gt; fwd[10005],rvs[10005]; int iCanReach[10005]; int iAllCan[10005] = { 0 }; int dis[10005]; inline int read() { int x = 0, y = 1; char c = getchar(); while (c&gt;'9' || c&lt;'0'){ if (c == '0')y = -1; c = getchar(); } while (c &gt;= '0'&amp;&amp;c &lt;= '9'){ x = x * 10 + c - '0'; c = getchar(); } return x*y; } int main() { n = read(); m = read(); for (int i = 0; i &lt; m; ++i) { x = read(); y = read(); if (x == y)continue; fwd[x].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd7095c56ba9291c380ace01fbc56b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6542dd9b95226f405d819e4273b350ec/" rel="bookmark">
			split函数分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 split函数分割 1.使用split函数进行字符串分割操作时，利用 | 符号进行多分隔符操作 String aaa = "hahah,aaaa;xxxxx"; String[] split = aaa.split(",|;"); for (String s : split) { System.out.println(s); } 结果 hahah aaaa xxxxx 2.当分割从外部获取的字符串时，例如从excel或者其他文档中获取的字符串，进行分割时需要利用转义符\\ remark = “备注：xxxxx”；(从外部获取) String[] remark = getMergedRegionValue(sheet, 7, 1).split("\\:|\\："); //写两个冒号是一个英文一个中文，防止漏分 结果 备注 xxxxx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7011683eb335abc6039ca5627acca4/" rel="bookmark">
			python接口自动化-单接口测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口测试之前要先知道一个单元测试模块，那就是unittest，这个模块由5部分组成：
TestCase：写用例的，所有用例都写在这里边
TestSuite：测试套件，收集用例
TestLoader：加载用例
TestRunner：运行用例
TestFixTure：测试准备和善后工作，分为setUp和tearDown
需求：网站的搜索图书功能，用关键字搜索图书，例如想要搜索含有”一带一路“的书。做接口测试，也需要写用例，那么这些用例都跟功能测试用例一样的，如下：
有用例了，但是还需要接口文档
上代码
import requests #这个库是接口测试必不可少的，里边包含各种请求方式和返回值 import unittest #单元测试模块，作用是写用例，运行用例 import sys import io sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='utf8') #避免打印中文乱码的 class Test_api(unittest.TestCase): #继承unittest def setUp(self): pass def test_search(self): #用例名称必须是test开头 '''keyword search''' #这里是用例名称，用途是批量运行用例时，能够知道这条用例是测什么的 self.url = 'http://*****/search/keywords' #接口地址 self.param = { 'keyword' : '一带一路' #请求参数，搜索有关“一带一路”的书 } self.res = requests.get(self.url,params=self.param) #发送请求，这个不需要请求头，所以没有header self.r = self.res.json() #把返回值转成json串 self.assertIn('一带一路',str(self.r)) #断言，判断返回值中是否包含搜索的字符串 print (self.r) def tearDown(self): pass if __name__=='__main__': suite = unittest.TestSuite() #测试套件，用于收集用例 suite.addTest(Test_api('test_search')) #添加需要执行的用例 runner = unittest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb7011683eb335abc6039ca5627acca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73287a4142b5e525d6dff1edd0e06b8/" rel="bookmark">
			java ID最后一位校验位生成规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * @author SevenFin * @date 2017-11-10 上午10:52:08 * @param id ID前17位 * @return ID第18位 校验位 */ public static String verifyId(String id) { int count = 0; char[] charArr = id.toCharArray(); for (int i = 0; i &lt; charArr.length; i++) { int n = Integer.parseInt(charArr[i] + ""); count += n * (Math.pow(2, 17 - i) % 11); } switch (count % 11) { case 0: return "1"; case 1: return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73287a4142b5e525d6dff1edd0e06b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac6e5c6a292e9c3dc6d92a123c25aa6/" rel="bookmark">
			二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思想：根据中间值缩小数组一般长度进行查找数据
public class ErFenChaZhao { public static void main(String[] args) { int[] arr={10,20,30,40}; System.out.println(getIndexByELE(arr,20)+1); } private static int getIndexByELE(int[] arr,int ele){ int minIndex=0; int maxIndex=arr.length-1; int centerIndex=(minIndex+maxIndex)/2; while(minIndex&lt;=maxIndex){ if(ele==arr[centerIndex]){ return centerIndex; } else if(ele&gt;arr[centerIndex]){ minIndex=centerIndex+1; } else if(ele&lt;arr[centerIndex]) { maxIndex=centerIndex-1; } //重新计算 centerIndex=(minIndex+maxIndex)/2; } return 0; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcd6382a31a31b4f31b0ea03eb9f7099/" rel="bookmark">
			python&#43;opencv图像处理之五：图像阈值化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python+opencv图像处理之五：图像阈值化处理 目录 python+opencv图像处理之五：图像阈值化处理 一、阈值化二、各方法选择参数图像对比 一、阈值化 阈值即为界限，或者说是临界值，是指一个效应能够产生的最低值或最高值。旨在提取图像中的目标物体，将背景以及噪声区分开来。
通常会设定一个阈值T，通过T将图像的像素划分为两类：大于T的像素群和小于T的像素群。灰度转换处理后的图像中，每个像素都只有一个灰度值，大小表示明暗程度。利用阈值化，我们就可以从一副图像中分割出我们需要的物体部分。
常见阈值化公式，即二进制阈值化：
Y = { 0 , gray&lt;T 255 , gray&gt;T Y= \begin{cases} 0, &amp; \text {gray&lt;T} \\ 255, &amp; \text{gray&gt;T} \end{cases} Y={0,255,​gray&lt;Tgray&gt;T​
当灰度Gray小于阈值T时，其像素设置为0，图像中显示为黑色；当灰度Gray大于或等于阈值T时，其Y值为255，图像中显示为白色。
opencv中对于图像阈值处理提供了cv2.threshold（）函数
cv2.threshold（）中包含四个参数，分别为：
第一个原图像
第二个进行分类的阈值
第三个是高于（低于）阈值时赋予的新值
第四个是一个方法选择参数，常用的有：
参数参数作用效果cv2.THRESH_BINARY像素点的灰度值大于阈值，设其灰度值为最大值（255）；小于阈值，设其灰度值为最小值（0）cv2.THRESH_BINARY_INV像素点的灰度值大于阈值，设其灰度值为最小值（0）；小于阈值，设其灰度值为最大值（255）cv2.THRESH_TRUNC像素点的灰度值小于阈值，其灰度值不变；大于阈值，设其灰度值为阈值cv2.THRESH_TOZERO像素点的灰度值小于阈值，其灰度值不变；大于阈值，设其灰度值为最小值（0）cv2.THRESH_TOZERO_INV像素点的灰度值大于阈值，其灰度值不变；小于阈值，设其灰度值为最小值（0） 该函数有两个返回值，第一个retVal（得到的阈值数据），第二个就是阈值化后的图像。
二、各方法选择参数图像对比 程序代码如下：
#encoding:utf-8 import cv2 import numpy as np import matplotlib.pyplot as plt #输入图像 image= cv2.imread("line.jpg") #将图片转换为灰度图 gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) #阈值化处理 ret,thresh1=cv2.threshold(gray,127,255,cv2.THRESH_BINARY) ret,thresh2=cv2.threshold(gray,127,255,cv2.THRESH_BINARY_INV) ret,thresh3=cv2.threshold(gray,127,255,cv2.THRESH_TRUNC) ret,thresh4=cv2.threshold(gray,127,255,cv2.THRESH_TOZERO) ret,thresh5=cv2.threshold(gray,127,255,cv2.THRESH_TOZERO_INV) #显示结果 titles = ['Gray Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV'] images = [gray, thresh1, thresh2, thresh3, thresh4, thresh5] for i in range(6): plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcd6382a31a31b4f31b0ea03eb9f7099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6e140bd03a9d589248538d267b2cce/" rel="bookmark">
			位(bit)， 字节(byte)， 字(word)，双字（dword or Qword）释义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位（bit） 位（bit） 来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。
一个二进制位只可以表示0和1两种状态；
两个二进制位可以表示00、01、10、11四种状态；
三位二进制数可表示八种状态。
字节（byte） 字节（byte） 字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。 字节是通过网络传输信息（或在硬盘或内存中存储信息）,在计算机中数据处理的基本单位，是计算机信息技术用于计量存储容量和传输容量的一种计量单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。
八位二进制数最小为00000000，最大为11111111；
通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。
一个ascll码就是一个字节， 因为ascll码的二进制范围是00000000到11111111， 十进制范围是0到255。
节（word） 字((word) 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字（word）。一个字通常由一个或多个（一般是字节的整数位）字节构成。计算机的字长决定了其CPU一次操作处理实际位数的多少，由此可见计算机的字长越大，其性能越强。
双字（Qword） 两个双字称为一个四字（Qword）。
unicode指的是UCS-2的编码方式， 是以两个字节的长度；
utf-8是一种变长的编码方式，它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度；
utf-16是，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16无法兼容于ASCLL编码；
UTF-32(或 UCS-4)是以4个字节的长度固定存储的。
引申阅读 ANSI是什么编码？Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4汉字编码：GB2312, GBK, GB18030, Big5 java 中的位：byte：一个字节（8位）；short：两个字节（16位）；int：四个字节（32位）(一个字长)；long：八个字节（64位）；float：四个字节（32位）；double：八个字节（64位）。
在C++ 6.0中,BYTE与WORD,DWORD本质上都是一种无符号整型，也就是说BYTE是无符号的char型（char型本质上也是一种1个字节的整型），WORD是无符号short型，DWORD是无符号long型。char型长度为1字节，short型长度为2字节，int和long型长度都为4字节，因此可以认为BYTE与WORD,DWORD定义的变量分别获得了1字节，2字节，4字节内存，正与BYTE与WORD,DWORD的字面意义相符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197a45077ef8c6b038d88c6794e3151c/" rel="bookmark">
			wpf绘制圆形图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;Window x:Class="DrawArrow.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="MainWindow" Height="550" Width="625"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="30"/&gt; &lt;RowDefinition Height="282*"/&gt; &lt;/Grid.RowDefinitions&gt; &lt;StackPanel Orientation="Horizontal"&gt; &lt;Button Click="btn_DrawLines_Click" Content="DrawLines" Margin="4"&gt;&lt;/Button&gt; &lt;Button Content="Draw Circle" Click="Button_Click"&gt;&lt;/Button&gt; &lt;Label Content="Start X" Margin="2"&gt;&lt;/Label&gt; &lt;TextBox Name="tb_startX" Text="10" Width="40" Margin="4"&gt;&lt;/TextBox&gt; &lt;Label Content="Start Index" Margin="2"&gt;&lt;/Label&gt; &lt;TextBox Name="tb_startIndex" Text="3" Width="40" Margin="4"&gt;&lt;/TextBox&gt; &lt;Label Content="End Index" Margin="2"&gt;&lt;/Label&gt; &lt;TextBox Name="tb_EndIndex" Text="5" Width="40" Margin="4"&gt;&lt;/TextBox&gt; &lt;CheckBox IsChecked="True" Name="cb_IsPass" Content="Is Pass" Margin="4"&gt;&lt;/CheckBox&gt; &lt;Button Click="btn_Clear_Click" Content="Clear" Margin="4"&gt;&lt;/Button&gt; &lt;/StackPanel&gt; &lt;StackPanel Name="FlowPanel" Grid.Row="1" Orientation="Horizontal"&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Window&gt; /// &lt;summary&gt; /// 作出圆圈 /// &lt;/summary&gt; private void DrawCircle(double x, double y, int r, Brush PenColor) { Path x_Arrow = new Path();//x轴箭头 x_Arrow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/197a45077ef8c6b038d88c6794e3151c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9004c174768b4bae7e2c49b02aa8f28a/" rel="bookmark">
			VS Code失去了智能提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		像特么失了智一样，就是没提示
勾上解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06650202d50d8302d726c189daf63394/" rel="bookmark">
			贼全!一举通关的Spring&#43;SpringBoot&#43;SpringCloud全攻略,是真香啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天，有幸从朋友那里得到了一份Alibaba内部的墙裂推荐的“玩转Spring全家桶的PDF”，我也不是个吝啬的人，好的东西当然要一起分享。那今天我就秀一把，带你一站通关Spring、Spring Boot与Spring Cloud,让你轻松斩获大厂Offer！
这份PDF能得到的收获： 使用 Spring 熟练开发 Web 服务；
搞懂 Spring Boot 核心功能的实现原理；
通过 Spring Cloud 快速构建微服务架构；
掌握 Spring 个性化定制与扩展的进阶方法。
注意：有需要免费领取一线架构师的Spring全家桶笔记的朋友，可以点击这里免费领取不要错过哦
01 Spring 毋庸置疑，Spring 早已成为 Java 后端开发事实上的行业标准，无数的公司选择 Spring 作为基础的开发框架，大部分Java 后端程序员在日常工作中也会接触到 Spring ，因此，如何用好 Spring ，也就成为 Java 程序员的必修课之一。
Spring 面试必备题+解析
不同版本的Spring Framework有哪些主要功能?什么是Spring Framework?列举Spring Framework的优点。Spring Framework有哪些不同的功能?Spring Framework中有多少个模块，它们分别是什么?什么是Spring配置文件?Spring应用程序有哪些不同组件?使用Spring有哪些方式?依赖注入(loc)什么是Spring I0C容器?什么是依赖注入?可以通过多少种方式完成依赖注入?区分构造函数注入和setter注入。spring中有多少种I0C容器?区分BeanFactory 和ApplicationContext.列举loC的一一些好处。Spring loC的实现机制。 Spring思维导图
Spring学习笔记
Spring概述(基本情况)核心思想loC和AOP手写实现loC和AOP (自定义spring框架)Spring loC高级应用（基础知识/高级特性）Spring loC源码深度剖析(设计非常优雅/设计模式) 注意:原则、方法和技巧。Spring AOP高级应用(声明式事务控制/Spring AOP源码深度剖析) 第⼀部分** Spring **概述
第⼆部分 核⼼思想
第三部分 ⼿写实现** IoC 和 AOP**
第四部分** Spring IOC **应⽤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06650202d50d8302d726c189daf63394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b14a7837e89971be1efb5641235d9b/" rel="bookmark">
			如何提高解题速度?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何提高解题速度?
主持人：解题的速度跟不上,刚好有一个网友也问了,数学答题的速度太慢了,如何提高解题的速度?
何秀好：提高解题的速度,基础知识要牢固,基本方法要熟练,思考问题要慎密,运算技能要扎实,书写表达要快捷.有的考生书写速度太慢,追求试卷的完美整洁,导致隐性失分,这是不可取的.应该不求完美,但求完成；不求整洁,但求准确.一份在规定时间内完成的答卷,只要书写的文字、式子、符号能看清楚就行了.
另外,草稿的使用也有讲究,可将草稿纸对折对折再对折,这样就有16个矩形区域,给每个区域编号就可对应16个题,这样做的好处在于检查某些运算有无错误时,不要到处找运算过程,浪费时间和精力.做解答题要先审题,理清思路,加强心算,争取一挥而就,下笔有神,落笔成功,尽量不用草稿纸.
主持人：现在是否可以通过限时的训练,自己给自己限定时间,做相应的题目,例如要找平时做题慢的原因,有可能是做解答题慢,这样是否有帮助?
何秀好：这是非常好的办法,有的考生自己做了一个“错题本”,将历次考试中做错了的题都记录下来,针对这些错误的题进行限时训练,这是非常有效的训练.错题本基本上浓缩了数学以及其他的重点、难点、基点以及自己学习过程中的“盲点”.要安排足够时间整理知识方法,反思考卷,查漏补缺.
主持人：“错题本”记录的是考生个人失分的情况,结合“错题本”进行训练,是很好的办法.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a74a4eeb7e8b4be18295318302db05e/" rel="bookmark">
			STM32F103x学习笔记（1）—— IAP应用编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IAP应用编程 1、IAP简介 IAP是In Application Programming的首字母缩写，IAP是用户自己的程序在运行过程中对User Flash的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口对产品中的固件程序进行更新升级。
2、STM32内置Flash 1、STM32内部FLASH的起始地址为0X08000000,Bootloader程序文件就从此地址开始写入，存放APP程序的首地址设置在紧跟Bootloader之后。当程序开始执行时，首先运行的是Bootloader程序，然后Bootloader收到BIN文件并将其复制到APP区域使固件得以更新,固件更新结束后还需要跳转到APP程序开始执行新的程序,完成这最后这一步要了解Cortex-M3的中断向量表。
2、程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动，当复位中断程序运行完成后才跳转到main函数。由此可见，在最后一步的设计中需要根据存放APP程序的起始地址以及中断向量表来设置栈顶地址，并获取复位中断地址跳转到复位中断程序。
2.1、内置Flash的分配情况大致如下： 2.2、具体内置Flash大小参考选型手册 3、BootLoader程序 1、上电初始程序依然从0x08000004处取出复位中断向量地址，执行复位中断函数后跳转到IAP的main(标号①所示)，
2、在IAP的main函数执行完成后强制跳转到0x08000004+N+M处(标号②所示)，最后跳转到新的main函数中来(标号③所示)，
3、当发生中断请求后，程序跳转到新的中断向量表中取出新的中断函数入口地址，再跳转到新的中断服务函数中执行(标号④⑤所示)，执行完中断函数后再返回到main函数中来(标号⑥所示)。
3.1、标注如下图所示： 4、流程图 4.1、IAP升级过程中，我采用的大致方案是：
1、APP 收到上位机发来的升级指令后，将升级标志写入 Flash ，然后调用软件重启函数，进行重启；
2、重启后，STM32 先进入 Bootloader ，Bootloader 检查升级标志是否置位，如果未置位，则跳转到 APP 中，相反，则停留在 Bootloader 中；
3、Bootloader 初始化后发送准备完毕命令至上位机，上位机受到后将固件数据拆分成数据帧，依次发送给 STM32 ，每发送一帧需要等待 STM32 应答无误后，继续发送下一帧；
4、STM32 收到数据帧时，先保存在缓存数组中，然后发送应答给上位机，待接收的数据长度为一字或多字时，将数据一起写入 Flash ；
5、上位机发送完所有数据后，发送结束命令，STM32 收到后，将所有未写入的数据全部写完，将固件版本号写入 Flash 中，复位升级标志，检查 APP 程序区起始数据无误后，发送升级完毕应答给上位机，接着调用软件重启函数，重进 Bootloader ；
6、重进 Bootloader 后，Bootloader 检查升级标志为复位状态时，跳转到 APP 中执行 APP 程序；
7、至此，所有升级过程全部结束。
5、程序代码解析 5.1、bootloader程序设计 在 /Drivers/src/IAP.c中
Step 1) 确定存放APP程序的首地址
#define FLASH_APP1_ADDR 0x08006000 //应用程序起始地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a74a4eeb7e8b4be18295318302db05e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2f5f8758030324d3aa28dc15f2e84b/" rel="bookmark">
			WEB综合案例  day02 数据库设计 目录模块 题目模块（图片上传 显示） 题目选项模块  操作中遇到的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑马面面day02 web综合案例1. 数据库设计1.1 数据库设计范式1.2 数据库设计工具 2. 学科模块快速开发3. 目录模块4. 题目模块4.1 题目模块快速开发（重点）4.2 文件上传基础演示4.3 添加题目时加入文件上传4.4 文件上传的重名问题4.5 修改题目时加入文件上传4.6 兼容图片上传可选操作与显示问题 5. 题目选项模块5.1 列表页制作5.2 添加功能制作5.3 删除功能制作5.4 修改功能制作5.5 添加修改功能合并5.6 删除功能相关问题及解决方案 操作中碰到的问题！ web综合案例 1. 数据库设计 1.1 数据库设计范式 什么叫数据库设计范式？
范式：规范的形式，应用于各个行业的标准化
数据库设计中有5种范式，但是常用的分别是：第一范式（1NF）,第二范式（2NF），第三范式（3NF）
第一范式（1NF）：针对数据表中的列，列要具备原子性，不可再拆分
如果数据表这样设计，籍贯这一列不具备原子性，因为数据可再次拆分，不拆分的话无法获取用户的州郡信息或县市信息，拆分之后如下：
第二范式（2NF）：数据表要具备唯一主键，不存在多主键，使得每一行数据具有唯一性
在如图所示的表中：没有哪一个字段（列）能唯一确定一条数据，要想唯一确定一条数据，需要两个或更多的字段，这就违反了第二范式，数据表不具备唯一主键而存在多主键。
那如何来解决呢？在表中加一个唯一主键列：id
第三范式（3NF）：不依赖非主键的字段及更深层次的依赖，使得每个字段都独立依赖于主键字段（独立性）
什么叫依赖：依赖，就是在一个表中，其中某个字段的值B可以由另一个字段值A来决定，那我们称字段B依赖字段A或字段A决定字段B
在如图所示的表结构中：合计列=单价 X 数量，当然这中间还需要依赖商品编号来查询商品单价
总而言之，合计这一列，依赖了表中的非主键字段，以及非主键字段的更深层次的依赖，这表明合计这一列的数据是冗余的，因为我们完全可以通过计算的方式得到合计数据，而不需要在表中来存储。
反三范式：允许少量的数据冗余，提高查询的速度
看情况去用，都有适用场景
三范式和反三范式的一个适用场景 在淘宝购物的时候，比如一个手机5000，打折，页面显示的数据用三范式展示， 这样一打折就能更新到页面，展示出来。 用户下单后累计的历史订单用反三范式，当手机出现价格回调的时候，因为不关联，数据不会出来更改的情况。 不然本来打折后买的价格，会显示成原价，这就不合理了。 1.2 数据库设计工具 PowerDesigner：简称PD，是一款功能强大的建模软件，提供强大的元数据管理功能，可以帮助用户构建关键信息的全方位视图，创建多种类型的模型，包括概念数据模型，物理数据模型，面向对象模型等等，同时集成了数据管理，BI，数据集成和数据整合多种功能。
2. 学科模块快速开发 个人理解：学科目录和之前做的差不多，只是在Servlet层的时候需要注意学科创建时间，在course.setCreateTime的地方传入new Date()参数，并且在CourseDao.xml（对应的映射文件）中把设置时间去掉。
（1）创建学科实体：com.itheima.domain.store.Course
public class Course { private String id; private String name; private String remark; private String state; private Date createTime; // getter/setter略 } （2）创建dao接口：com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2f5f8758030324d3aa28dc15f2e84b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586f694ff085cace7b18e86ca057d11f/" rel="bookmark">
			WEB综合案例 day01概述 环境搭建 企业模块 部门模块 用户模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@TOC
WEB综合案例 1. 概述 1.1 案例介绍 黑马面面是一款面向程序员的面试刷题系统，服务于学员培训学习完毕后的复习问题，通过大量刷题，提高企业面试题的熟知度，辅助学员顺利完成求职面试。
注意：我们在本课程中只做黑马面面系统的一部分，对有些功能进行了微缩改造，
黑马面面本原始系统又分为三个子系统：后台系统，前台系统，手机端（在本课程中不涉及），以下是各子系统核心的功能介绍
后台系统：试题的录入
前台系统：会员刷题
手机端：会员刷题（常用/主流）
1.2系统架构 接下来在做之前，我们就要说说这套案例制作的时候应该采用怎样的一种结构进行搭建？同时采用什么样的技术进行实现。那么首先我们先聊一聊整个项目的系统架构。
对于整个系统来说，它分成两块，一个是后台系统，一个是前台系统。那么我们在访问后台系统的时候，是通过浏览器来进行访问，最终把我们的数据存入到我们的数据库端。记得一点，我们从后台系统录入的题目数据，最终会被前台系统使用，所以说前后台系统，他们在数据这一端上来说是进行共享的。也就是前后台系统用的基础数据是同一组。那么前台系统是通过手机端来进行刷这个题，那么我们在这里边呢，不做手机端的，我们也做浏览器的，这就是它的一个整体的结构，你要先了解。
那么对于后台系统来说，开发的时候，我们采用三层架构的形式开发，分为表现、业务、数据。表现层负责数据的收集以及回显，业务层负责业务逻辑处理，数据层负责与数据库打交道。那么对于前台系统来说呢，它仍然是这样的，只不过他们之间用的技术有差别。那么都有哪些差别呢？接下来咱们就要来说一下技术架构！
1.3 技术架构 对于后台系统与前台系统，我们分成五个层面来介绍他们的产品。分别是页面端的技术，也就是我们的前端技术了，以及controller、service、Dao、DB。
详情见下图：
AdminLTE：一个前端框架，提供了很多友好的主题样式，动态功能效果，可直接使用，非常方便
POI：数据报表工具，可用于报表导出
1.4 需求分析 刷题是整个项目的核心功能，那么试题一定是我们的核心。对一道题来说，体型会多种多样，这次我们以最复杂的选择题来演示。选择题一般由题目与选项构成，题目与选项是一对多的关系。在下图中，我们以线和圆点来表述它们之间的关系。没有圆点的是“一”方，有圆点的是“多”方。
继续看，试题一定有归属的学科，比如你Java的同学做python的题，其实意义不大对吧。题目和学科能直产生一对多的关系吗？一个学科下其实分了很多的东西，比如Java下分Java基础、JavaWeb等等，所以在学科和试题建，需要有个目录。
假如你现在想去一个企业，是不想想看看这个企业以前都出些什么面试题呀。那就需要一个企业的模块了。一个企业与试题之间，也是一对多的关系。
试题是谁录入系统呢？需要有用户模块，那肯定是操作系统的人，对于这个用户来说，并不是所有人都能录入，所以需要约定一个部门。然后，那是部门中所有人都需要录入么？这样就涉及到了一个权限的问题了，我们说你这个用户有一种角色，就能拥有录入试题的权限！所以在用户与角色之间形成一个多对多的关系。
这个人分配角色了就能录试题了吗？不，还需要一个叫模块的东西。就是这个系统中一共有多少种操作？在我们系统中有一个模块叫做录入试题的模块，有一个模块叫审核试题的模块，是这个角色能操作这个模块儿，所以这个用户才能执行这项操作。模块与角色之间也是一个多对多的关系。
录入完了就能直接用么？不能，万一你录的题有问题呢？所以一定要有一个审核机制。对于所有的操作，我们都需要有一个日志来记录了，所以还要有一个日志的东西。
接下来要开始答题 ，那谁来答题呢？，会员。所以我们要有一个会员的模块。会员就直接做题吗？，做题应该是以试卷的形式呈现。作为一个会员，登录以后，你要去做一套卷子，而不是做一道题，当然你说能不能做单个题，可以，可以把单个题理解为这个试卷就一道题。会员与试卷是一对多的关系。
那试卷就与我们的试题直接产生关系么，不需要。我们每一个试卷生成以后。都需要把这个题给做出来，你做出来以后，除了有题目以外，试卷中还得有你做题的答案。所以说试卷中会保存一个试卷的答题明细，这个地方试卷对答题明细是一个一对多的关系。其实答题明细中本身就有试题的ID，因此我们这里用试卷与答题明细对试题进行关联。
总结一下，左边这块是属于后台系统，负责保障录入试题的。右边这块属于前台系统，负责学员的刷题功能。
1.5 课程计划安排 2. 环境搭建 2.1 工程结构搭建 创建工程的要求，及注意点：
创建maven工程（web工程）
导入项目依赖的坐标（资源）
补全目录结构
web
​ |-----src
​ |-------main
​ |------------java
​ |------------resources
​ |------------webapp
​ |-------test
​ |-------------java
​ |-------------resources
创建三层架构开发的包层次结构
创建三层架构开发的包层次结构
domain
dao
service
web
​ controller
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586f694ff085cace7b18e86ca057d11f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4930f7626d91151192a87babb12dffbd/" rel="bookmark">
			JSON对象转java对象 JSON数组转LIST数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * json数组转List */ List&lt;Student&gt; stus = (List&lt;Student&gt;)JSONArray.parseArray(array.toJSONString(), Student.class); /** * Json对象转java对象 */ Student stu = JSONObject.parseObject(array.get(0).toString(), Student.class); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdb48e8c7c71d64ec434c3609c39948/" rel="bookmark">
			事务隔离级别图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务隔离是指一个事务所做的修改，对另一个事务的可见性。如果事务与事务之间不进行隔离，那么就会导致数据读取中的一些问题：脏读、不可重复读、幻读。
为了规避这些问题，就需要对事务进行隔离。以下为4种事务隔离级别的图解：
READ UNCOMITTED（未提交读）
事务A对B未提交的数据可见，可能导致“脏读”。
READ COMMITED（提交读）
事务A在事务B开启事务到提交事务过程中，通过“快照读”保证了对事务B对ID为1记录进行的修改“视而不见”，从而避免了“脏读”。但等事务B提交后”再次读取ID为1的记录，发现和第1次读取到的不一样“，此即为“不可重复读”，这种隔离级别未解决“不可重复读”的问题。
REPEATABLE READ（可重复读，mysql默认）
事务A在提交事务前通过锁定读取的记录行防止其它事务对其进行修改，从而避免了“不可重复读”的问题。如下图所示：
但是，事务A只能锁定某条读取的记录，对于涉及多条记录的SQL，如查询表记录数，此过程中事务B在数据库中插入了一条新记录，事务A再次查询数目，发现比第1次多了一条记录，此即为“幻读”。
可重复读能避免“脏读”、“不可重复读”，但不能避免“幻读”。
SERIALIZABLE（可串行化）
最高的隔离级别。它通过强制事务串行执行，避免了前面所说的幻读问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd241bc1bab0e2d42fb67c9aa2a5d44e/" rel="bookmark">
			这么学，好玩，有趣，逗死了！（2017年系统规划与管理师上午综合知识试题试题解析（六））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		● IT服务风险管理中，对风险的识别是很重要的一项工作。识别方法中，通常采用文档审查、信息收集技术、检查表、分析假设和图解技术。下面（ ）选项不属于信息采集技术。
（51）A.德尔菲法
B.访谈法
C.头脑风暴法
D.因果分析图法
● IT服务风险管理中，风险的监控是指跟踪已识别的危险，检测残余风险和识别新的风险，保证风险计划的执行，并评价这些计划对减轻风险的有效性。风险监控是整个生命周期中一个持续进行的过程。下面（ ）不是风险监控的基本方法。
（52）A.风险评估
B.技术指标分析
C.技术的绩效评估
D.差异和趋势分析
● IT服务营销中，供应商关系的管理是一项重要工作，其活动包括了：①供应商间的协调、②支持合同管理、③供应商的选择/推荐、④供应商审核及管理、⑤争议处理。按照活动规律、其正确的顺序是（ ）。
（53）A.①→④→③→⑤→②
B.③→①→④→②→⑤
C.③→④→①→⑤→②
D.①→③→②→④→⑤
● IT服务营销过程共分四个阶段，下面（ ）不属于这四个阶段的内容。
（54）A.服务执行阶段
B.服务达成阶段
C.启动准备阶段
D.能力展示阶段
● 在IT服务营销中，对IT服务项目的预算，让系统规划与管理师能够从财务的角度来衡量IT服务项目工作开展的有效性，达到高效利用项目资金，提高服务投入产出比的目的。项目预算的制定分为三个步骤，下面（ ）不在这三个步骤之列。
（55）A.识别项目预算收入项与开支项
B.划分IT服务项目执行阶段
C.形成预算表
D.寻找控制成本开支方法
● 在IT服务团队的五个特性中，人员的岗位结构特征将岗位分为三类且团队成员相对固定。下面（ ）选项的划分是正确的三类岗位。
（56）A.管理岗、技术岗、培训岗
B.管理岗、安保岗、技术岗
C.管理岗、技术岗、操作岗
D.技术岗、培训岗、操作岗
● ITSS （Information Technology Service Standards）是一套成体系和综合配套的信息技术服务标准库，全面规范了信息技术服务产品及其组成要素，用于指导实施标准化和可信赖的信息技术服务。该体系的组成要素包括（ ）。
（57）A.人员、过程、工具、资源
B.人员、过程、管理、资源
C.人员、过程、技术、资源
D.人员、过程、组织、资源
● IT服务的广泛应用对从业人员的职业素养和法律法规知识提出来更高的要求，在职业素养中，要求从业者具有执业责任，下面“（ ）”不是要求的职业责任。
（58）A.应遵守相关组织如甲方、乙方或业内共识的制度和政策
B.在合理和清楚的事实基础上，可以不管他人在项目管理方面可能违反行为准则的情况
C.有责任向客户、用户、供应商说明可能潜在的利益冲突和明显不恰当的重大情况
D.在职业发展中，应认可和尊重他人开发或拥有的知识产权，以准确、真实和完整的方式在所有与项目有关的各项活动中遵守规则，并推动和支持向其同行宣传职业行为准则
● 任何一个团队从开始组建到最终达到绩效要求，需要一个周期。依据塔克曼群体发展模型，结合IT服务管理工作特性，将团队建设周期分为四个阶段，他们分别是（未按正确次序排列） ①风暴期 ②表现期 ③组建期 ④规范期 团队建设周期的正确排序为（ ）。
（59）A.③→①→④→②
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd241bc1bab0e2d42fb67c9aa2a5d44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9362297c9dba0f83871a5599f3a8957/" rel="bookmark">
			小白建网站，该如何入手？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新手小白打算建个网站，该如何入手？ 作者：北柯
链接：https://www.zhihu.com/question/19774219/answer/1296842611
来源：知乎
非常遗憾的告诉大家，尽管发展了二三十年，建站行业依然没有形成一个统一的服务标准和规范，对于普通人来说，该选择什么样的建站方式，花多少钱，怎么挑选服务商都是一头雾水。网上的各种介绍五花八门，很多内容发布了很久，有些早已不再适用，所以我今天写了一篇最新、全面的内容供大家参考。
搭建网站的费用包括域名购买、网站服务器空间、网站设计及开发费组成，除了设计及开发费是一次性收取之外，域名和空间费是按年支付的，总费用在1000-100万人民币之间，跨度非常大。因为报价不透明，你对建站行业又不了解，很可能会被坑。所以，请仔细看下面的内容。
网站费用最大的一部分是网站设计服务费及网站的系统开发。
主流的方式分为：
全定制开发
半定制开发
程序自助部署
模版自助建站
免费建站工具
1.全定制开发：这种方式做出的网站品质最好，会由专门的项目经理提供网站的方案策划，设计师根据要求进行创意设计，程序员再根据功能及样式要求进行技术开发。整个过程需要消耗大量的人工，因此费用比较高昂。
费用：费用高，通常几万元起，甚至上百万RMB。记得我创业时准备做个网站，于是咨询了北京某知名定制建站公司（中*动*），对方给我的报价是25万！！果断放弃。
市场上很多电商平台的网站都是定制化开发的，比如天猫、京东、唯品会……
2.半定制开发：一些服务商凭借多年的技术和服务积累，将常用的功能模块和样式封装到系统当中，通过灵活配置满足用户的网站功能要求。这种模式下，网站只需要设计师根据客户要求进行样式设计，之后不再需要大量的技术开发，极大地提升了建站效率，也降低了建站成本，这种模式就是由原中国万网（现已被阿里云收购）首创并推广开来的标准建站模式，是现在市场上主流的建站模式。
费用：建一个网站的费用大概是几千元，是建站非常不错的选择。
这个是使用阿里云建站半定制化服务搭建的网站：http://www.kappa.com.cn/
阿里云建站“云企”，设计师为你量身定制网站​aliyun2.wezhan.cn
3.程序自助部署：网上有一些成熟的开源建站系统，在全球范围内拥有广泛的用户，用户可以自行部署到服务器空间，通过简单的配置即可使用，这种方式几乎没有额外费用，单要求有一定的技术能力来完成部署和部分修改，不太适合普通用户。
费用：0成本。比如WordPress。
4.模版自助建站：这种模式也是非常多的建站用户选择的方式，服务商提供了大量的分行业做好的网站模版，用户根据自己的需求选择合适的模版，在线开通，通过网站管理后台进行修改，替换成自己的内容网站即可上线。服务商会直接集成服务器空间，不需要额外购买，比较适合对网站要求不高的用户选择。
费用：每年收取，在几百元到一两千元不等。比如阿里云自助建站模版叫云·速成美站，费用几百元起。半定制服务是云·企业官网，提供设计师一对一服务，价格4980元起，第二年续费只需要980元。
下面这个是用阿里云建站工具搭建出来的网站：http://aliyun1.wezhan.cn
阿里云建站“速美”，高性价比，价格低至500元​aliyun1.wezhan.cn
模板建站做出来的网站
5.免费建站工具：有服务商会推出免费建站，但出于营收的考虑，免费建站会限制很多功能，不支持绑定顶级域名的，只能通过预览地址浏览，并且对访问速度也会有一些限制。会极大地影响网站的正常使用。往往免费的才是最贵的，网站的美观、内容得当、访问快速并且稳定缺一不可，千万不要为了省钱选择免费。我们建议大家在选择网站服务商的时候，一定要选择知名服务商，确保网站的长期稳定。
除了网站设计服务费及网站的系统开发之外，还有一部分费用来自域名购买、网站服务器空间，这部分是按年支付的。
网站域名：也就是一个网站的地址，绝大多数人会选择自行注册一个顶级域名，域名可以和组织或个人的名字、品牌、商标相关联，便于记忆，也是组织形象的一部分。比如苹果公司的官网就是http://www.apple.com。值得注意的是：有一些服务商提供免费域名，免费域名通常都是二级域名，并不一定能提供长期稳定的服务，也不便于记忆，不建议选用。
域名的费用：每年几十块钱并不高。大家可以去阿里云可以直接挑选注册，非常简单（前身是中国万网）或者国外的godaddy购买。
网站服务器空间：网站的内容和程序需要放置到一个服务器空间，可以选择共享虚拟主机，或独立的服务器、云服务器。由于国家有关部门对网站部署的合规性管理，包括服务器提供商的接入备案审批等。现在几乎已经没有正规服务商再提供免费的服务器空间了。因此，在服务器空间选择上，我也建议大家选择正规的服务商。
空间费用：每年几百到几千元不等。国内首推阿里云服务器，是国内市场占有率排名第一的云计算服务商。国外有亚马逊的AWS，但因为政策因素，AWS在中国发展受限。
so，你做一个网站，既可以花几百元DIY开发一个网站，不过这种适合有一定技术基础的同学，你也可以找技术设计团队定制化开发一个网站，成本在十几万甚至几十万。但对于预算不多的新手来说，最合理的一种方式是选择模版自助建站，门槛低、费用在几千块左右、而且可以快速上线。
即便现在有各种APP、微博、微信公众号、小程序，网站依然是互联网内容不可或缺的载体，是建立用户对企业信任度较好的选择，因此我们想要通过互联网宣传和推广的时候，可以尝试搭建属于自己的网站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e4ef9653c9944ee4c0b8de1922a620/" rel="bookmark">
			4G模块未注册到网络原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 4G SIM卡未注册到网络的可能原因
SIM卡与卡插槽接触不良，导致SIM卡电路无法工作，模块与云服务器无法通信，此时可以拆下SIM卡，用清洁棉布擦拭SIM卡芯片后，重新安装；SIM卡偶然原因，网络信号覆盖区域无信号后，未能重接搜索网络并册，此时可以更换所处位置到空旷区域或重启设备电源，然后查看网络是否注册；SIM卡在网络中一直未注册，此时可以将此SIM卡更换至另外一台设备，如果同样显示无服务为SIM卡原因，此时需更换SIM卡；SIM卡卡槽不支持防反插，需按照正确方向插入SIM卡。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e50341e39e2e0f98d5a9b4da018f696/" rel="bookmark">
			shell脚本快速入门之-----shell脚本练习100例！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、循环ping192.168.110网段的所有主机2、for批量创建用户3、创建存放1-100奇数的数组里创建任意数字及长度的数组，根据客户的需求加入元素4、将一个数组中的所有不够60的提到605、判断数组中最大的数6、 猜数字游戏7 检测本机当前用户是否为超级管理员,如果是管理员,则使用 yum 安装 vsftpd,如果不是,则提示您非管理员(使用字串对比版本)8编写脚本,实现人机&lt;石头,剪刀,布&gt;游戏9、99乘法表10、 100以内的数字求合 11、自动调整网络配置12、将脚本设置为开机自启动13、成绩14、输入你想加入的数组元素15、小于60的数组直接unset干掉16、倒直角三角17、 正直角18、平行四边形19、梯形20、等腰三角形21、菱形22、三个人抽奖随机比大小23、 阶乘24、使用函数 判断是否有三个数相乘；如果有，直接乘然后输出，没有的话就退出25、用until 小于50的求合26、冒泡排序法 将数组的序列进行排序27、请输入你的成绩 小于60 不及格 85以上优秀28、为指定用户发送在线消息29、while+sleep用法 1、循环ping192.168.110网段的所有主机 #!/bin/bash i=1 for i in {1..254} do ping -c 2 -w 3 -i 0.3 192.168.110.$i $&gt; /dev/null if [ $? -eq 0 ] ;then echo "192.168.110.$i is yes" else echo "192.168.110.$i is no" fi let i++ done 2、for批量创建用户 user=$`cat /opt/user.txt` for i in $user do useradd $i echo "1234" | passwd --stdin $i done ~ 3、创建存放1-100奇数的数组里 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e50341e39e2e0f98d5a9b4da018f696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368b4cc907571338b5c081187e391d18/" rel="bookmark">
			python sklearn 回归预测房价例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用sklearn 回归模型,预测房价例子
from sklearn import linear_model import pandas as pd import numpy as np def get_data(): # square_feet,price train_data = pd.read_csv("train_data.csv") return np.array(train_data[["square_feet", "comfortable"]]).reshape(-1, 2), np.array(train_data["price"]).reshape( -1, 1) if __name__ == "__main__": # 获取训练数据 x, y = get_data() # 创建回归模型 regr = linear_model.LinearRegression() # 训练模型 regr.fit(x, y) # 获取预测数据 df = pd.read_csv("predict_data.csv") predict_x = np.array(df[["square_feet", "comfortable"]]).reshape(-1, 2) # 获取预测结果 predict_outcome = regr.predict(predict_x) # intercept_和coef_是模型参数 # y = coef_[0]*x1 + coef_[1]*x2 + intercept_ print({'intercept': regr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/368b4cc907571338b5c081187e391d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3501e92404e419b993265ba6713b76b0/" rel="bookmark">
			shell脚本快速入门之-----正则三剑客之一grep用法大全！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 元字符总结一、grep用法大全1、把空行过滤掉然后显示2、[ie]表示匹配任意一个3、查找重复单个字符4、不以w开头的并且后面接oo的过滤出来5、过滤出不以a-z A-Z开头的6、过滤出0-9和a-z的7、过滤出以root开头的 以bash结尾的8、过滤出以.结尾的 这里的.需要转义 查找任意一个字符“.”9、筛选出oo或者oo再多几个o的字段 *代表前一个字符的0个或者多个匹配10、查询以 w 开头 d 结尾，中间包含至少一个 o 的字符串11、查询以 w 开头 d 结尾，中间的字符可有可无的字符串。12、查询任意数字所在行13、 grep -n '*' httpd.conf 匹配*的字符 不需要转义14、查询以 w 开头以 d 结尾，中间包含 2 个或 2 个以上 o 的字符串。15、 [root@promote opt]# grep -n 'o\+' httpd.conf 表示匹配一个o的字符16、-C的用法 二、 egrep1、特点：与grep的区别 使用场景2、 +号的使用方法不同与※号不通之处在于（1）egrep 直接用'wo+'（2）grep想要实现+的功能还要加上转义符\（3）想要达到同样的需求也可以用'？'同样的grep需要加转义符 egrep不需要 在这里跟※一样 3、 '+' '*' '?' {}总结4、 egrep 总结 元字符总结 ^ 匹配输入字符串的开始位置。除非在方括号表达式中使用，表示不包含该字符集合。要匹配“^” 字符本身，请使用“^”
$ 匹配输入字符串的结尾位置。如果设置了RegExp 对象的 Multiline 属性，则“KaTeX parse error: Undefined control sequence: \n at position 6: ”也匹配‘\̲n̲’或‘\r’。要匹配“”字符本身，请使用“$”匹配除“\r\n”之外的任何单个字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3501e92404e419b993265ba6713b76b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a7630b21a180cd7d9f9fa7dbcc807d/" rel="bookmark">
			必备工具推荐：Windows查杀端口小工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预览 解决痛点：
端口被占用，还要打开任务管理器，密密麻麻找不到java.exe优点：
绿色解压版，卸载直接删除文件即可，无残留，开源免费
下载 原作者Github:https://github.com/yfinternet/portSpirit
CSDN免积分下载Github下载 解压启动上面的exe即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746e6d8eb29c7c4124ca78522379fb86/" rel="bookmark">
			用Echarts实现中国地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲来无事看了看echarts，感觉挺有趣的就做了个中国地图玩玩，代码已经加了详细注释。
先附上最后的动态效果图：
ps:数据为本人纯双手乱打
需要用到echarts.js和china.js，echarts.js可以去官网下载，也可以直接引入在线链接：https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js
china.js的话，由于蓝奏还不支持上传.js的文件，所以我压缩了一下，下载到本地解压即可使用。也可以百度自行寻找。点这下载
不想下载的我也给你准备了在线的，早就知道有人不想下，别问我怎么知道的 —&gt;https://gallery.echartsjs.com/dep/echarts/map/js/china.js
两种方法引入都可以
懒人直接复制区：
&lt;script src="https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js"&gt;&lt;/script&gt; &lt;script src="https://gallery.echartsjs.com/dep/echarts/map/js/china.js"&gt;&lt;/script&gt; 引入的时候需要注意，要先引入echarts.min.js,不然会出错
最后附上代码部分：
&lt;body&gt; &lt;div id="box" style="width: 800px; height: 800px;"&gt;&lt;/div&gt; &lt;script&gt; // 初始化echarts实例 var myEcharts = echarts.init(document.getElementById("box")); var option = { title: { //标题样式 text: 'ECharts 中国地图', x: "center", textStyle: { fontSize: 18, color: "red" }, }, tooltip: { //这里设置提示框 trigger: 'item', //数据项图形触发 backgroundColor: "red", //提示框浮层的背景颜色。 //字符串模板(地图): {a}（系列名称），{b}（区域名称），{c}（合并数值）,{d}（无） formatter: '地区：{b}&lt;br/&gt;模拟数据：{c}' }, visualMap: {//视觉映射组件 top: 'center', left: 'left', min: 10, max: 500000, text: ['High', 'Low'], realtime: false, //拖拽时，是否实时更新 calculable: true, //是否显示拖拽用的手柄 inRange: { color: ['lightskyblue', 'yellow', 'orangered'] } }, series: [ { name: '模拟数据', type: 'map', mapType: 'china', roam: false,//是否开启鼠标缩放和平移漫游 itemStyle: {//地图区域的多边形 图形样式 normal: {//是图形在默认状态下的样式 label: { show: true,//是否显示标签 textStyle: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746e6d8eb29c7c4124ca78522379fb86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa8aebc0536c96596800d9c48204e14/" rel="bookmark">
			Java23种设计模式之单例模式的五种实现方式、反射破解单例模式、不能破解枚举单例模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码链接（Gitee码云）：https://gitee.com/oldou/javadesignpatterns
这里有我整理好的Java23种设计模式的源码以及博客教程，博客教程中介绍了Java23种设计的模式的各种实现方式以及应用场景，非常适用于学习以及提高我们的设计思维，如果对大家有所帮助，请记得star一下给予作者一定的精神支持，你的star是我写出更好的博客的动力，谢谢大家。
目录 设计模式简介单例模式的简介单例模式的实现实现方式一：饿汉式（单例对象立即加载）实现方式二：懒汉式（单例对象延迟加载）实现方式三：双重检测锁实现（不建议使用）实现方式四：静态内部类实现方式(懒加载方式)实现方式五：枚举 反射破解单例模式枚举单例模式的解释单例模式总结 设计模式简介 将设计者的思维融入大家的学习和工作中，更高层次的思考！
• 创建型模式：
– 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
• 结构型模式：
– 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
• 行为型模式：
– 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。
本次文章介绍的是单例模式的五种实现方式。
单例模式的简介 • 核心作用：
保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
• 常见应用场景：
– Windows的Task Manager（任务管理器）就是很典型的单例模式
– windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
– 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
– 网站的计数器，一般也是采用单例模式实现，否则难以同步。
– 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
– 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
– 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
– Application 也是单例的典型应用（Servlet编程中会涉及到）
– 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
– 在servlet编程中，每个Servlet也是单例
– 在spring MVC框架/struts1框架中，控制器对象也是单例
• 单例模式的优点：
– 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，
则可 以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
– 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理
• 常见的五种单例模式实现方式：
– 主要：
• 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
• 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa8aebc0536c96596800d9c48204e14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1443ba5da7794ee9c4c47f1265c3c23/" rel="bookmark">
			我就是小马那个穷困潦倒的诗人程序员朋友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又到一年结束，一年伊始的时候！ 小马是谁？ 是谁不重要，和大马云是一家子嘛，分不了那么清楚！ 不小心写在了代码块！！ 那又怎样？ 就要写成代码块的方式，什么时候中文在代码里不再只是出现在注释就好了。 2018 一年的开始前，总要总结一下过去。
啊 我那不堪回首的往事 和无处安放的魅力 工作 1、 这一年，上一家公司倒闭后，来到了一家老气横秋的“互联网”公司，做了一名小小的测试人员。
2、每天在吐槽自己低工资和嫌弃开发写的代码中度过。（因为我是开发出身，至于为什么去了测试？因为我不自信啊）
3、熟悉了公司业务，出差的时候，大家都在羡慕金融公司程序员，老人悠悠说了一句忠告：
程序员后面其实大家代码能力也就都差不多，值钱的是业务能力，业务经验的积累不是一时半会儿能做到的。
4、以前学过java和Android，但是很久没写，早就还给不知道哪个编辑哪个老师了，于是看着这么火热的区块链和python，自学吧！听说可以用来爬任何东西？万物皆可爬！
5、快年底了，没什么事情，自己研究了自动化测试，这一研究可好，领导觉得这个事情终于有人做了，给你吧！
开始还有一个小伙伴，最后只剩我一人在搞。难受，硬着头皮自己设计原型，自己写代码，自己优化。老大说，java拓展性比较好，你还是用java来吧，这，我那无处安放的python语法啊！
我对小马说：我搞这个自动化，也许以后就可以当经理了。 小马笑了笑：恩，可以，给你成立一个自动化测试部门！ 我说:对啊，我马上要发达了，当个领导！ 小马说：然后就有你一个人！ 虽然想反驳，但是这公司好像确实不会花钱请人啊，貌似确实是我一个人的部门，光杆司令一个。
生活 1、恋爱能让人上天堂，也能让你下地狱。一场恋爱还没分手，就已经是大负翁了，努力搬砖，挣钱，每天东墙补西墙，西墙拆东墙。曾经过过多有钱多奢侈的日子，现在就过得多清贫。
2、没钱觉得还有支柱，年底，冷的，精神支柱走了，我变成了一个自由的负翁大龄单身青年。
我：唉，还是分手了 小马：奥，那我以后要多关照你，怕你想不开。 我：先借点钱 (* ^ -^ *) 支付宝到账***元！ 3、荒废的王者拿出来打打，吃鸡已经吃的没了胃口。
4、做了统计，大概看了115部院线影片，大概花了12925分钟在电影，同时听了2082首歌曲，花了我295小时。
小马：你这是寂寞了295小时啊，空虚了12925分钟！ 我：不抽烟不喝酒，就这么点爱好了！ 2019 1、先贴出来公司年终总结报告写的玩意 2、接下来是小马给我的flag 3、我的Flag 我的还重要吗？
没啥flag，都被安排上了！
减肥吧，不再当个死肥宅！
岁月这把猪饲料谁爱吃谁吃，我要绝食！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3d3644d8d1465126e4fb2c3ed5e176/" rel="bookmark">
			SQL SERVER 查询表的各字段长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL SERVER 查询表的各字段长度 SELECT a.name,b.name,c.DATA_TYPE,b.max_length FROM sys.tables a join sys.columns b on b.object_id = a.object_id join INFORMATION_SCHEMA.COLUMNS c on b.name=c.COLUMN_NAME and a.name=c.TABLE_NAME where a.name='shipment_header' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da18177a1e0bd7988f86b2cc27137ba5/" rel="bookmark">
			聚焦爬虫案例3：扇贝单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：
使用xpath将单词以及解释提取出来
import requests from lxml import etree headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36' } response = requests.get(url='https://www.shanbay.com/wordlist/110521/232414/?page=1',headers=headers) # print(response.text) 将字符串转换成html元素对象
html = etree.HTML(response.text) 使用xpath提取数据
先获取tr标签
tr_list = html.xpath('//table[@class="table table-bordered table-striped"]/tbody/tr') print(tr_list) # [&lt;Element tr at 0x24c2c3bd8c8&gt;, &lt;Element tr at 0x24c2c3bd888&gt;, &lt;Element tr at 0x24c2c3bd848&gt;, &lt;Element tr at 0x24c2c3bd808&gt;, &lt;Element tr at 0x24c2c3bd708&gt;, &lt;Element tr at 0x24c2c3e4088&gt;, &lt;Element tr at 0x24c2c3e40c8&gt;, &lt;Element tr at 0x24c2c3e4708&gt;, &lt;Element tr at 0x24c2c3e4688&gt;, &lt;Element tr at 0x24c2c3cc888&gt;, &lt;Element tr at 0x24c2c3e4948&gt;, &lt;Element tr at 0x24c2c3e4988&gt;, &lt;Element tr at 0x24c2c3e4908&gt;, &lt;Element tr at 0x24c2c3e49c8&gt;, &lt;Element tr at 0x24c2c3e4a08&gt;, &lt;Element tr at 0x24c2c3e4a48&gt;, &lt;Element tr at 0x24c2c3e4a88&gt;, &lt;Element tr at 0x24c2c3e4ac8&gt;, &lt;Element tr at 0x24c2c3e4b08&gt;, &lt;Element tr at 0x24c2c3e4b48&gt;] for tr in tr_list: 获取单词
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da18177a1e0bd7988f86b2cc27137ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9e7db54424bd14269adf2d46590244/" rel="bookmark">
			JS 解析 key-value 最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般请求接口返回的数据大部分是 json 格式，JS 解析某个字段数据，相信大家都会遇到取某个字段可能会是 undefined 或者 null 类型，如果代码忘记处理 bad case 就会挂了
下面代码是封装了对字典的解析，感觉挺好用的，基本原理就是循环遍历 keys，找到对应的 key 后，返回对应的 value，也比较简单
mapUtils.dig = (map, keys) =&gt; { if (_.isNull(map)) { return map } let digMap = map keys.forEach(key =&gt; { if (digMap[key] === undefined) { return } if (digMap[key] === null) { return null } digMap = digMap[key] }) return digMap } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b2067de8b60dedb517f9b39258380b/" rel="bookmark">
			微信截屏黑屏（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信是我们经常用的工具，但是最近一段实践发现在使用截屏后出现了黑色的情况。
经过了解是由于我打开了独立显卡优先导致的。
方法一
windows键+P 设置屏幕显示为 复制
方法二
我们只需要卸载独立显卡就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dbb67a1e0c7ecbd30e1f6baa3e874f4/" rel="bookmark">
			SVN文件信息获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 标题svn获取文件信息方式 svn info: 显示本地或远程条目的信息。
用法: info [TARGET[@REV]…]
显示每个 TARGET 的信息 (默认: “.”)。
TARGET 可以是工作副本中的路径或版本库中的 URL。REV 指定从哪个
版本开始查找目标。
有效选项:
-r [–revision] ARG : ARG (一些命令也接受ARG1:ARG2范围)
版本参数可以是如下之一:
NUMBER 版本号
‘{’ DATE ‘}’ 在指定时间以后的版本
‘HEAD’ 版本库中的最新版本
‘BASE’ 工作副本的基线版本
‘COMMITTED’ 最后提交或基线之前
python可通过os调用指令，localFile可以是文件夹也可以是文件的绝对路径，可以不用通过os.chdir改变工作目录。
os.popen('svn info {}'.format(localFile)).read() 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/210/">«</a>
	<span class="pagination__item pagination__item--current">211/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/212/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>