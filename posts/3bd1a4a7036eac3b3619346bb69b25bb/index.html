<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>golang高级进阶（一）：进程、线程、并发、并行、goroutine协程 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="golang高级进阶（一）：进程、线程、并发、并行、goroutine协程" />
<meta property="og:description" content="目录
一、关于进程和线程
1. 进程（Process）
2. 线程
二、关于并发和并行
1. 并发
2. 并行
3. 通俗讲
三、goroutine协程以及主线程
1. 主线程
2. 协程
3. 多协程和多线程
四、go关键词实操
1. 顺序执行
2. 加入go
3. 加入时间
4. 主线程执行快的情况
5. sync.WaitGroup解决不等待
6. 多协程并发并行执行
五、设置golang运行时占用的cpu核数量（不是很重要）
重点：这一篇全是干货，一定要多读多记，哪里不会可以留言咨询我。
一、关于进程和线程 1. 进程（Process） 进程就是程序在操作系统中的一次执行过程，是由系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间。一个进程至少有5种基本状态：初始态、执行态、等待状态、就绪状态、终止状态。
通俗讲：进程就是一个正在执行的程序。
2. 线程 线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。
通俗讲：一个进程可以创建多个线程，同一个进程中的多个线程可以并发执行，一个程序要运行的话至少有一个进程。
二、关于并发和并行 1. 并发 多个线程同时竞争一个位置，竞争到的才可以执行，每一个时间段只有一个线程在执行。
2. 并行 多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。
3. 通俗讲 多线程程序在单核cpu上运行就是并发，在多核cpu上运行就是并行。如果线程数大于cpu核数，则多线程程序在多个cpu上既有并发也有并行。
三、goroutine协程以及主线程 1. 主线程 可以理解为线程或进程，在一个golang程序的主线程上可以启用多个协程。golang中多协程可以实现并发或者并行。
2. 协程 可以理解为用户级别的线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。golang的一大特色就是从语言方面原生支持协程，在函数或方法前面加一个go关键词就可以创建一个协程。可以说golang中的协程就是goroutine。
Golang 中的多协程有点类似其他语言中的多线程。
3. 多协程和多线程 Golang 中每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。 OS 线程（操作系统线程）一般都有固定的栈内存（通常为 2MB 左右）,一个 goroutine (协程) 占用内存非常小，只有 2KB 左右，多协程 goroutine 切换调度开销方面远比线程要少。 这也是为什么越来越多的大公司使用 Golang 的原因之一。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3bd1a4a7036eac3b3619346bb69b25bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-22T11:04:00+08:00" />
<meta property="article:modified_time" content="2022-04-22T11:04:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">golang高级进阶（一）：进程、线程、并发、并行、goroutine协程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B" rel="nofollow">一、关于进程和线程</a></p> 
<p id="1.%20%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.%20%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89" rel="nofollow">1. 进程（Process）</a></p> 
<p id="2.%20%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px;"><a href="#2.%20%E7%BA%BF%E7%A8%8B" rel="nofollow">2. 线程</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C" rel="nofollow">二、关于并发和并行</a></p> 
<p id="1.%20%E5%B9%B6%E5%8F%91-toc" style="margin-left:80px;"><a href="#1.%20%E5%B9%B6%E5%8F%91" rel="nofollow">1. 并发</a></p> 
<p id="2.%20%E5%B9%B6%E8%A1%8C-toc" style="margin-left:80px;"><a href="#2.%20%E5%B9%B6%E8%A1%8C" rel="nofollow">2. 并行</a></p> 
<p id="3.%20%E9%80%9A%E4%BF%97%E8%AE%B2-toc" style="margin-left:80px;"><a href="#3.%20%E9%80%9A%E4%BF%97%E8%AE%B2" rel="nofollow">3. 通俗讲</a></p> 
<p id="%E4%B8%89%E3%80%81goroutine%E5%8D%8F%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%B8%BB%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81goroutine%E5%8D%8F%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%B8%BB%E7%BA%BF%E7%A8%8B" rel="nofollow">三、goroutine协程以及主线程</a></p> 
<p id="1.%20%E4%B8%BB%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px;"><a href="#1.%20%E4%B8%BB%E7%BA%BF%E7%A8%8B" rel="nofollow">1. 主线程</a></p> 
<p id="2.%20%E5%8D%8F%E7%A8%8B-toc" style="margin-left:80px;"><a href="#2.%20%E5%8D%8F%E7%A8%8B" rel="nofollow">2. 协程</a></p> 
<p id="3.%20%E5%A4%9A%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px;"><a href="#3.%20%E5%A4%9A%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B" rel="nofollow">3. 多协程和多线程</a></p> 
<p id="%E5%9B%9B%E3%80%81go%E5%85%B3%E9%94%AE%E8%AF%8D%E5%AE%9E%E6%93%8D-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81go%E5%85%B3%E9%94%AE%E8%AF%8D%E5%AE%9E%E6%93%8D" rel="nofollow">四、go关键词实操</a></p> 
<p id="1.%20%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C-toc" style="margin-left:80px;"><a href="#1.%20%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C" rel="nofollow">1. 顺序执行</a></p> 
<p id="2.%20%E5%8A%A0%E5%85%A5go-toc" style="margin-left:80px;"><a href="#2.%20%E5%8A%A0%E5%85%A5go" rel="nofollow">2. 加入go</a></p> 
<p id="3.%20%E5%8A%A0%E5%85%A5%E6%97%B6%E9%97%B4-toc" style="margin-left:80px;"><a href="#3.%20%E5%8A%A0%E5%85%A5%E6%97%B6%E9%97%B4" rel="nofollow">3. 加入时间</a></p> 
<p id="4.%20%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#4.%20%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">4. 主线程执行快的情况</a></p> 
<p id="5.%20sync.WaitGroup%E8%A7%A3%E5%86%B3%E4%B8%8D%E7%AD%89%E5%BE%85-toc" style="margin-left:80px;"><a href="#5.%20sync.WaitGroup%E8%A7%A3%E5%86%B3%E4%B8%8D%E7%AD%89%E5%BE%85" rel="nofollow">5. sync.WaitGroup解决不等待</a></p> 
<p id="6.%20%E5%A4%9A%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C-toc" style="margin-left:80px;"><a href="#6.%20%E5%A4%9A%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C" rel="nofollow">6. 多协程并发并行执行</a></p> 
<p id="%E4%BA%94%E3%80%81%E8%AE%BE%E7%BD%AEgolang%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8D%A0%E7%94%A8%E7%9A%84cpu%E6%A0%B8%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E8%AE%BE%E7%BD%AEgolang%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8D%A0%E7%94%A8%E7%9A%84cpu%E6%A0%B8%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89" rel="nofollow">五、设置golang运行时占用的cpu核数量（不是很重要）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><span style="color:#fe2c24;">重点：这一篇全是干货，一定要多读多记，哪里不会可以留言咨询我。</span></p> 
<h3 id="%E4%B8%80%E3%80%81%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">一、关于进程和线程</h3> 
<h4 id="1.%20%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89">1. 进程（Process）</h4> 
<p>进程就是程序在操作系统中的一次执行过程，是由系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间。一个进程至少有5种基本状态：初始态、执行态、等待状态、就绪状态、终止状态。</p> 
<p>通俗讲：<span style="color:#fe2c24;">进程就是一个正在执行的程序。</span></p> 
<h4 id="2.%20%E7%BA%BF%E7%A8%8B">2. 线程</h4> 
<p>线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。</p> 
<p><span style="color:#0d0016;">通俗讲：</span><span style="color:#fe2c24;">一个进程可以创建多个线程，同一个进程中的多个线程可以并发执行，一个程序要运行的话至少有一个进程。</span></p> 
<p><img alt="" height="371" src="https://images2.imgbox.com/8c/96/ambfRyMJ_o.png" width="687"></p> 
<p> <img alt="" height="640" src="https://images2.imgbox.com/b7/03/j1FtGmYx_o.png" width="960"></p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C">二、关于并发和并行</h3> 
<h4 id="1.%20%E5%B9%B6%E5%8F%91">1. 并发</h4> 
<p>多个线程同时竞争一个位置，竞争到的才可以执行，每一个时间段只有一个线程在执行。</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/b1/6f/p0O2MpDN_o.png" width="734"></p> 
<h4 id="2.%20%E5%B9%B6%E8%A1%8C">2. 并行</h4> 
<p>多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/7c/64/s7vp424H_o.png" width="639"></p> 
<h4 id="3.%20%E9%80%9A%E4%BF%97%E8%AE%B2">3. 通俗讲</h4> 
<p><span style="color:#fe2c24;">多线程程序在单核cpu上运行就是并发，在多核cpu上运行就是并行。如果线程数大于cpu核数，则多线程程序在多个cpu上既有并发也有并行。</span></p> 
<h3 id="%E4%B8%89%E3%80%81goroutine%E5%8D%8F%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%B8%BB%E7%BA%BF%E7%A8%8B">三、goroutine协程以及主线程</h3> 
<h4 id="1.%20%E4%B8%BB%E7%BA%BF%E7%A8%8B">1. 主线程</h4> 
<p>可以理解为线程或进程，在一个golang程序的主线程上可以启用多个协程。golang中多协程可以实现并发或者并行。</p> 
<h4 id="2.%20%E5%8D%8F%E7%A8%8B">2. 协程</h4> 
<p>可以理解为用户级别的线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。golang的一大特色就是从语言方面原生支持协程，在函数或方法前面加一个go关键词就可以创建一个协程。可以说golang中的协程就是goroutine。</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/0e/5b/Mp7ZMqfx_o.png" width="532"></p> 
<p> Golang 中的多协程有点类似其他语言中的多线程。</p> 
<h4 id="3.%20%E5%A4%9A%E5%8D%8F%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B">3. 多协程和多线程</h4> 
<p>Golang 中每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。 OS 线程（操作系统线程）一般都有固定的栈内存（通常为 2MB 左右）,一个 goroutine (协程) 占用内存非常小，只有 2KB 左右，多协程 goroutine 切换调度开销方面远比线程要少。 这也是为什么越来越多的大公司使用 Golang 的原因之一。</p> 
<h3 id="%E5%9B%9B%E3%80%81go%E5%85%B3%E9%94%AE%E8%AF%8D%E5%AE%9E%E6%93%8D">四、go关键词实操</h3> 
<h4 id="1.%20%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C">1. 顺序执行</h4> 
<pre><code class="language-Go">package main

import "fmt"

func test() {
	for i := 0; i &lt; 5; i++ {
		fmt.Println("test执行", i)
	}
}

func main() {
    // 正常顺序执行
	test()
	for i := 0; i &lt; 5; i++ {
		fmt.Println("main执行", i)
	}
	/*
		test执行 0
		test执行 1
		test执行 2
		test执行 3
		test执行 4
		main执行 0
		main执行 1
		main执行 2
		main执行 3
		main执行 4
	*/
}</code></pre> 
<h4 id="2.%20%E5%8A%A0%E5%85%A5go">2. 加入go</h4> 
<pre><code class="language-Go">package main

import "fmt"

func test() {
	for i := 0; i &lt; 5; i++ {
		fmt.Println("test执行", i)
	}
}

func main() {
    // 加入goroutine后
	go test()
	for i := 0; i &lt; 5; i++ {
		fmt.Println("main执行", i)
	}
	/*
		main执行 0
		main执行 1
		main执行 2
		main执行 3
		main执行 4
		主线程执行完毕后，并没有等待协程的执行
	*/
}</code></pre> 
<h4 id="3.%20%E5%8A%A0%E5%85%A5%E6%97%B6%E9%97%B4">3. 加入时间</h4> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "time"
)

// 加入时间
func test1() {
	for i := 0; i &lt; 5; i++ {
		fmt.Println("test执行", i)
		time.Sleep(time.Millisecond * 100)
	}
}

func main() {
    // 加入sleep之后再执行
	go test1()
	for i := 0; i &lt; 5; i++ {
		fmt.Println("main执行", i)
		time.Sleep(time.Millisecond * 100)
	}
	/*
		main执行 0
		test执行 0
		test执行 1
		main执行 1
		main执行 2
		test执行 2
		main执行 3
		test执行 3
		test执行 4
		main执行 4
		加入相同的睡眠时间后，执行的顺序不一定，但少量数据来看均会执行完毕
	*/
}</code></pre> 
<h4 id="4.%20%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%9A%84%E6%83%85%E5%86%B5">4. 主线程执行快的情况</h4> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "time"
)

func test1() {
	for i := 0; i &lt; 5; i++ {
		fmt.Println("test执行", i)
		time.Sleep(time.Millisecond * 100)
	}
}

func main() {
    // 如果主线程执行的快会出现什么情况？
	go test1()
	for i := 0; i &lt; 5; i++ {
		fmt.Println("main执行", i)
		time.Sleep(time.Millisecond * 20)
	}
	/*
		main执行 0
		test执行 0
		main执行 1
		main执行 2
		main执行 3
		main执行 4
		test执行 1
		那么他将不会等待协程执行，就会退出执行。
	*/
}</code></pre> 
<h4 id="5.%20sync.WaitGroup%E8%A7%A3%E5%86%B3%E4%B8%8D%E7%AD%89%E5%BE%85">5. sync.WaitGroup解决不等待</h4> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "time"
    "sync"
)

var wg sync.WiatGroup

func test2() {
	for i := 0; i &lt; 5; i++ {
		fmt.Println("test执行", i)
		time.Sleep(time.Millisecond * 100)
	}
	wg.Done()
}

func main() {
    // sync.WaitGroup 完美解决，以后在项目中也会经常使用
	wg.Add(1)
	go test2()
	for i := 0; i &lt; 5; i++ {
		fmt.Println("main执行", i)
		time.Sleep(time.Millisecond * 20)
	}
	wg.Wait()
	/*
		main执行 0
		test执行 0
		main执行 1
		main执行 2
		main执行 3
		main执行 4
		test执行 1
		test执行 2
		test执行 3
		test执行 4
		这样就可以解决主线程执行完毕后，不等待等待协程执行完毕就退出的问题。
	*/
}</code></pre> 
<h4 id="6.%20%E5%A4%9A%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C">6. 多协程并发并行执行</h4> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "time"
    "sync"
)

func hello(num int) {
	defer wg.Done()
	for i := 0; i &lt; 5; i++ {
		fmt.Printf("第%v个协程执行--%v\n", num, i)
	}

}

func main() {
    // 多协程并发执行
	for i := 0; i &lt; 3; i++ {
		wg.Add(1)
		go hello(i)
	}
	wg.Wait()
	/*
		第2个协程执行--0
		第2个协程执行--1
		第2个协程执行--2
		第2个协程执行--3
		第2个协程执行--4
		第0个协程执行--0
		第0个协程执行--1
		第0个协程执行--2
		第0个协程执行--3
		第0个协程执行--4
		第1个协程执行--0
		第1个协程执行--1
		第1个协程执行--2
		第1个协程执行--3
		第1个协程执行--4
	*/
}</code></pre> 
<h3 id="%E4%BA%94%E3%80%81%E8%AE%BE%E7%BD%AEgolang%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8D%A0%E7%94%A8%E7%9A%84cpu%E6%A0%B8%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89">五、设置golang运行时占用的cpu核数量（不是很重要）</h3> 
<pre><code class="language-Go">package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 设置程序占用几个cpu进行执行，默认是全部
	// 获取计算机cpu个数
	cpuNum := runtime.NumCPU()
	fmt.Println(cpuNum) // 6 我本机电脑是6核cpu

	// 设置占用cpu个数
	runtime.GOMAXPROCS(2)
	fmt.Println("ok")
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04fa474c999186c0e7b14bd486e67fc5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">显示远程计算机或设备将不接受连接的解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0725bed879521f74d2fbfc5308439cc9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pygame绘制弧线</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>