<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（转）pb&#43;api实际应用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（转）pb&#43;api实际应用" />
<meta property="og:description" content="1、利用Api函数计算Windows从启动后所运行的总时间 Function long GetTickCount() Library &#34;kernel32.dll&#34; //获取windows从启动开始的总微秒数
窗口w_example的open事件：
timer(0.05)//触发timer事件
窗口的timer事件：
long hour , minute ,second hour = GetTickCount() / 1000 / 60 / 60//获取小时数
st_1.text = String(hour) &#43; &#34;小时&#34;
minute = (GetTickCount() - hour * 60 * 60 * 1000) / 1000 / 60//获取分钟数
st_2.text = Str(minute) &#43; &#34;分钟&#34;
second = (GetTickCount() - long(st_1.text) * 60 * 60 * 1000 - long(st_2.text) * 60 * 1000) / 1000//获取总秒数
st_3.text = String(second) &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/695595abf38022314be55ce1b58fec41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-04-18T10:58:00+08:00" />
<meta property="article:modified_time" content="2011-04-18T10:58:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（转）pb&#43;api实际应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、利用Api函数计算Windows从启动后所运行的总时间 </p> 
<p>Function long GetTickCount()  Library  "kernel32.dll"  //获取windows从启动开始的总微秒数</p> 
<p>窗口w_example的open事件：</p> 
<p>timer(0.05)//触发timer事件</p> 
<p>窗口的timer事件：</p> 
<p>long hour , minute ,second </p> 
<p>hour = GetTickCount() / 1000 / 60 / 60//获取小时数</p> 
<p>st_1.text = String(hour) + "小时"</p> 
<p>minute = (GetTickCount() - hour * 60 * 60 * 1000) / 1000 / 60//获取分钟数</p> 
<p>st_2.text = Str(minute) + "分钟"</p> 
<p>second = (GetTickCount() - long(st_1.text) * 60 * 60 * 1000 - long(st_2.text) * 60 * 1000) / 1000//获取总秒数</p> 
<p>st_3.text = String(second) + "秒钟"</p> 
<p> </p> 
<p>  </p> 
<p>2、GetSystemMetrics函数</p> 
<p>Function long GetSystemMetrics (long  nIndex )  Lib “user32.dll”<br>　　其中nIndex的不同取值可以使该函数实现不同的功能。例如返回Win桌面中各种显示单元的宽度和高度、是否安装鼠标、是否调换了鼠标左右键的定义等。<br>　　当nIndex = 67（SM_CLEANBOOT）时，该函数的返回值表示Windows9x的当前运行模式。<br>　　在以下的示例中我们可以看到GetSystemMetrics函数的用法和作用。</p> 
<p>       首先在窗口w_example中定义实例变量：<br>　　Public Constant long SM_CLEANBOOT = 67       定义外部函数引用声明：</p> 
<p>       Function long GetSystemMetrics (long  nIndex )  Lib “user32.dll”<br>　　在窗口w_example中添加static text控件st_1和commandbutton控件 Cb_1，设置如下代码：<br>　　 cb_1.clicked:</p> 
<p>　　 choose case  GetSystemMetrics(SM_CLEANBOOT) <br>　　            Case 0</p> 
<p>                            st_1.text=“系统运行于正常模式”<br>　　             Case 1</p> 
<p>                            st_1.text=“系统运行于安全模式”<br>　　            Case 2</p> 
<p>                             st_1.text=“系统运行于网络环境下的安全模式”<br>　　 end choose<br> </p> 
<p> </p> 
<p>  </p> 
<p>3、获取磁盘分区大小（支持大的分区)</p> 
<p>type large_integer from structure<br>unsignedlong  lowpart<br>unsignedlong  highpart<br>end type//定义能够保存64位整形的结构</p> 
<p>定义外部函数引用声明</p> 
<p>Function long GetDiskFreeSpaceExA(ref string lpRootPathName, ref large_integer lpFreeBytesAvailableToCaller,ref large_integer lpTotalNumberOfBytes, ref large_integer lpTotalNumberOfFreeBytes) Library "kernel32.dll" </p> 
<p>api函数解析：</p> 
<p>lpRootPathName  String　，不包括卷名的磁盘根路径名 <br>lpFreeBytesAvailableToCaller  LARGE_INTEGER，指定一个变量，用于容纳调用者可用的字节数量<br>lpTotalNumberOfBytes  LARGE_INTEGER　，指定一个变量，用于容纳磁盘上的总字节数 <br>lpTotalNumberOfFreeBytes LARGE_INTEGER，指定一个变量，用于容纳磁盘上可用的字节数 </p> 
<p>实现代码解析：</p> 
<p>public function double of_get_drive_totalspace (string as_drive);/*函数作用:获取指定的驱动器的空间大小<br>  参数:as_drive string 驱动器名<br>  返回值:real   */  <br>Double         ld_capacity<br>any ia_pass<br>if right(as_drive,1)&lt;&gt;":" then<br>as_drive=as_drive+":"<br>end if//判断传递的驱动器参数的最后一个字符是否为":"<br>LARGE_INTEGER lngFreeCaller,lngTotal,lngTotalFree//定义结构的三个变量<br>GetDiskFreeSpaceExA(as_drive, lngFreeCaller, lngTotal, lngTotalFree)//调用api函数获取对应的分区信息<br>IF lngTotal.Highpart &gt; 0 THEN<br>   ld_capacity = ( lngTotal.Highpart * 1.0 * 4294967295 ) +lngTotal.LowPart<br>ELSE<br>   ld_capacity = lngTotal.LowPart<br>END IF//进行对应的结构变量转化为double类型并返回<br>return ld_capacity<br> <br>  <br>  </p> 
<p>4、用API函数控制光驱的开关<br>使用API函数CDdoor 来控制光驱门的开和关程序十分简单，由于 CDdoor 函数自身包含了对异常错误的处理机制，因此这个程序的通用性很高，你可以把这段代码移植到你的程序中，实现某些多媒体播放器所常用的开关光驱的功能。 <br>以下是源代码：</p> 
<p>//　　-------------------------------------------<br>//　　 利用API函数控制光驱的开和关<br>//　　-------------------------------------------<br>//　　程序说明：<br>//　　 本例使用API函数 CDdoor 来控制光驱门的开和关<br>//　　程序十分简单，由于 CDdoor 函数自身包含了对异常<br>//　　错误的处理机制，因此这个程序的通用性很高，你可<br>//　　以把这段代码移植到你的程序中，实现某些多媒体播<br>//　　放器所常用的开关光驱的功能。<br>//　　-------------------------------------------</p> 
<p><br>　　说明：CDdoor函数是安装WINDOWS时所自带的winmm.dll文件中包含的函数</p> 
<p>定义外部函数引用声明：</p> 
<p>Declare Function long  CDdoor( string lpstrCommand , string lpstrReturnString, long uReturnLength , long hwndCallback ) Libraray "winmm.dll" Alias for  "mciSendStringA" 　</p> 
<p>定义实例变量：</p> 
<p><br>boolean CDOpen //　CDOpen用来标示光驱开与关的状态</p> 
<p>w_example的cb_1的clicked事件：<br>//如果关闭则打开，并且按钮做相应变化</p> 
<p>If CDOpen = False Then<br>    CDdoor("set CDAudio door open", "0", 0, 0)<br>    CDOpen = True<br>    Cb_1.text = "点击关闭光驱"<br>Else <br>　　//否则关闭<br>     CDdoor("set CDAudio door closed", "0", 0, 0)<br>     CDOpen = False<br>     Cb_1.text = "点击打开光驱"<br>End If<br>w_example的open事件：<br>      CDOpen = False<br>      CDdoor("set CDAudio door closed", "0", 0, 0)</p> 
<p>相关api函数解析：</p> 
<p><br>　　CDdoor函数是安装WINDOWS时所自带的winmm.dll文件中包含的函数，我们只须先加入如下的声明后就能引用这个API函数：</p> 
<p>　　Function long CDdoor( string lpstrCommand , //String，这是控制命令参数<br>　　　string  lpstrReturnString , //　　　String，这是返回值<br>　　　long  uReturnLength, //Long，返回值长度参数<br>　　　long  hwndCallback )  Librara y "winmm.dll" Alias for  "mciSendStringA" </p> 
<p>　　引用的语法是CDdoor("set CDAudio door closed", "0", 0, 0)//用以关闭光驱门 </p> 
<p>　　　　　　　　CDdoor("set CDAudio door open", "0", 0, 0)//用以打开光驱门</p> 
<p>程序解析：</p> 
<p><br>　　程序中使用了一个布尔型变量来标示当前光驱门开与关的状态。</p> 
<p>　　如果配合检测光驱是否存在的函数一起使用，此程序的通用性会更高。而关于检测驱动器信息的函数请参看 GetDriveType，GetLogicalDrives这两个api函数的用法。<br>  <br>  <br> <br>  </p> 
<p>5、使用文件的默认的打开方式 </p> 
<p>    许多应用程序都需要通过默认的打开方式来打开一些文档。在某些情况下，你的应用程序可能需要显示像HTML或者RTF这样的文件。但是我们如何知道哪个应用程序与这些文件建立了关联关系呢？幸好，Windows API提供给我们使文档显示在其默认的程序里的方法。</p> 
<p><br>我们可以通过Windows shell.方法使用ShellExecute API函数来加载文档。这个函数将自动的来判断文件的默认打开方式，并用默认的打开方式来开启文档。</p> 
<p>以下就是ShellExecute函数的声明：</p> 
<p>Function long ShellExecuteA (long  hWnd As Long, string  lpOperation , string lpFile , string lpParameters, string lpDirectory , long nShowCmd ) Library "shell32.dll" </p> 
<p>Constant long SW_SHOWNORMAL = 1<br>Constant long SW_HIDE = 0 </p> 
<p>我们将结合下面的例子来解释该API函数的主要参数的意义。</p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)</p> 
<p>ShellExecute(handle(this), "Open", "c:/mypage.html", ls_temp, ls_temp, SW_SHOWNORMAL) </p> 
<p>“handle(this)”：表示那个你将要作为父窗体的窗体句柄。</p> 
<p>“Operatio”：该参数付值为“Open”，表示使用“打开”方法来操作该文档。</p> 
<p>“File”：该参数表示要操作哪个文件，必须用该文件的完全路径表示。</p> 
<p>“Parameters”：该参数表示打开文件时的命令行参数。</p> 
<p>“Directory”：该参数用于指定该应用程序的默认目录。</p> 
<p>“ShowCmd”：该参数将被设置为“SW_SHOWNORMAL”以打开文档。 <br>  <br>  <br>  </p> 
<p>6、使用SendMessage来实现剪切、复制和粘贴 </p> 
<p>    调用SendMessage API就能够向任何带有handle属性的窗口或者控件发送Windows消息。很多控件内置有对特定消息的响应机制。使用这一机制，你在自己的powerbuilder应用程序里很容易就能够实现剪切、复制和粘贴的功能。  </p> 
<p>要使用这一技巧，你就需要声明用于剪切、复制和粘贴的常数：</p> 
<p>Constant long  WM_COPY = 769</p> 
<p>Constant long  WM_CUT = 768</p> 
<p>Constant long  WM_PASTE =770</p> 
<p>然后，声明对SendMessage API的调用：</p> 
<p>Function long  SendMessage (long hWnd, long wMsg , long wParam , long  lParam ) Library "user32.dll" </p> 
<p>HWnd自变量能够接受消息发送的目的控件的句柄，而wMsg自变量会接受一个表明要被发送的是哪个对象的常数。WParam和lParam自变量被用来把其他信息同消息一起传递，但是不对WM_CUT、WM_COPY或者WM_PASTE使用。</p> 
<p>下面是从菜单点击事件调用SendMessage API的代码：</p> 
<p>m_Copy.Clicked:</p> 
<p>SendMessage(Me.ActiveControl.hwnd, WM_COPY, 0, 0)<br>m_Cut.Clicked</p> 
<p>SendMessage(Me.ActiveControl.hwnd, WM_CUT, 0, 0)</p> 
<p><br>m_Paste.Clicked</p> 
<p>SendMessage(Me.ActiveControl.hwnd, WM_PASTE, 0, 0)</p> 
<p><br>这个技巧能够用于任何实现handle方法，并能够响应WM_CUT、WM_COPY和WM_PASTE消息的控件。还应该实现错误处理，以处理不带handle方法的控件。 </p> 
<p>   <br> <br> </p> 
<p>7、隐藏/显示开始菜单</p> 
<p>Function long FindWindow  (string  lpClassName, string lpWindowName ) Library "user32.dll" Alias for "FindWindowA"</p> 
<p>注释：寻找窗口列表中第一个符合指定条件的顶级窗口<br>注释：lpClassName指向包含了窗口类名的空中止（C语言）字串的指针；或设为零，注释：表示接收任何类<br>注释：lpWindowName指向包含了窗口文本（或标签）的空中止（C语言）字串的指针；注释：或设为零，表示接收任何窗口标题</p> 
<p>Function long  FindWindowEx (long  hWnd1 ,long hWnd2, string lpsz1 , string lpsz2 ) Library "user32.dll" Alias for "FindWindowExA" </p> 
<p>注释：在窗口列表中寻找与指定条件相符的第一个子窗口 <br>注释：hWnd1在其中查找子的父窗口<br>注释：hWnd2从这个窗口后开始查找。这样便可利用对FindWindowEx的多次调用找到符合条件的所有子窗口。如设为零，表示从第一个子窗口开始搜索</p> 
<p>Function long  ShowWindow(long  hwnd , long  nCmdShow )  Library  "user32.dll" </p> 
<p>注释：控制窗口的可见性<br>注释：hwnd窗口句柄，要向这个窗口应用由nCmdShow指定的命令<br>注释：nCmdShow为窗口指定可视性方面的一个命令</p> 
<p>实现代码：cb_1.clicked:</p> 
<p>long  Handle ,FindClass </p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)<br>FindClass = FindWindow("Shell_TrayWnd", "")<br>Handle = FindWindowEx(FindClass, 0, "Button", ls_temp)<br>ShowWindow(Handle, 0)//隐藏开始菜单</p> 
<p>cb_2.clicked:</p> 
<p>long Handle , FindClass </p> 
<p>FindClass = FindWindow("Shell_TrayWnd", "")<br>Handle = FindWindowEx(FindClass, 0, "Button", ls_temp)<br>ShowWindow(Handle, 1)//显示开始菜单<br>  <br>    <br> <br>      </p> 
<p>8、起用和禁止ctrl-alt-del</p> 
<p>Function long SystemParametersInfo (long uAction , long  uParam, Ref any lpvParam, long  fuWinIni )  Library "user32.dll" Alias for "SystemParametersInfoA"</p> 
<p>注释：允许获取和设置数量众多的windows系统参数<br>注释：uAction指定要设置的参数</p> 
<p>Constant long SPI_SCREENSAVERRUNNING = 97</p> 
<p>实现代码：起用ctrl-alt-del:</p> 
<p>integer ret As Integer<br>boolean pOld</p> 
<p>ret = SystemParametersInfo(SPI_SCREENSAVERRUNNING, True, pOld, 0)</p> 
<p>禁止ctrl-alt-del:</p> 
<p>integer ret </p> 
<p>boolean pOld </p> 
<p>ret = SystemParametersInfo(SPI_SCREENSAVERRUNNING, False, pOld, 0)</p> 
<p> </p> 
<p> <br>  </p> 
<p>9、隐藏和显示系统托盘</p> 
<p>//注释：隐藏系统托盘</p> 
<p>long  FindClass, Handle</p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)<br>FindClass = FindWindow("Shell_TrayWnd", "")<br>Handle = FindWindowEx(FindClass, 0, "TrayNotifyWnd", ls_temp)<br>ShowWindow(Handle, 0)<br>//显示系统托盘</p> 
<p>//注释：隐藏系统托盘</p> 
<p>long  FindClass, Handle</p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)<br>FindClass = FindWindow("Shell_TrayWnd", "")<br>Handle = FindWindowEx(FindClass, 0, "TrayNotifyWnd", ls_temp)<br>ShowWindow(Handle, 1)<br>   <br> <br>  </p> 
<p>10、显示/隐藏任务栏<br>long FindClass, FindClass2 , Parent, Handle </p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)</p> 
<p>FindClass = FindWindow("Shell_TrayWnd", "")<br>FindClass2 = FindWindowEx(FindClass, 0, "ReBarWindow32", ls_temp)<br>Parent = FindWindowEx(FindClass2, 0, "MSTaskSwWClass", ls_temp)<br>Handle = FindWindowEx(Parent, 0, "SysTabControl32", vls_temp)<br>ShowWindow(Handle, 0)//显示任务栏</p> 
<p>long FindClass, FindClass2 , Parent, Handle </p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)</p> 
<p>FindClass = FindWindow("Shell_TrayWnd", "")<br>FindClass2 = FindWindowEx(FindClass, 0, "ReBarWindow32", ls_temp)<br>Parent = FindWindowEx(FindClass2, 0, "MSTaskSwWClass", ls_temp)<br>Handle = FindWindowEx(Parent, 0, "SysTabControl32", vls_temp)<br>ShowWindow(Handle, 1)//隐藏任务栏<br>  <br>  </p> 
<p>  </p> 
<p>11、怎样确定系统是否安装了声卡？<br>     <br>     //API函数声明： <br>     Function long  waveOutGetNumDevs () Library  "winmm.dll"</p> 
<p>    代码如下： <br>     integer i </p> 
<p>     i = waveOutGetNumDevs() <br>     If i &gt; 0 Then </p> 
<p>         messagebox("声卡检测","你的系统可以播放声音!")</p> 
<p>     Else </p> 
<p><br>          messagebox("声卡检测","你的系统不能播放声音!")</p> 
<p>     End If <br>  <br>  <br>  </p> 
<p>12、powerbuilder中如何使用未安装的字体？</p> 
<p><br>Function long AddFontResource(string lpFileName)  Library  "gdi32.dll"  Alias for "AddFontResourceA"  </p> 
<p>Function long  RemoveFontResource (string lpFileName ) Library "gdi32.dll" Alias for "RemoveFontResourceA"    </p> 
<p>//增加字体： <br>long lResult </p> 
<p>lResult = AddFontResource("c:myAppmyFont.ttf") </p> 
<p><br>// 删除字体：</p> 
<p>long lResult </p> 
<p>lResult = RemoveFontResource("c:myAppmyFont.ttf") <br>  <br> </p> 
<p>  </p> 
<p>13、半透明窗体(win2000特有API) </p> 
<p>Function long SetLayeredWindowAttributes  (long hwnd , long  crKey , long  bAlpha , long dwFlags ) Library "user32.dll"<br>注释：具体可以使用的常量及其用法</p> 
<p>Constant long  LWA_ALPHA=2 //注释：表示把窗体设置成半透明样式<br>Constant long  LWA_COLORKEY=1 // 注释：表示不显示窗体中的透明色 </p> 
<p>实现代码：</p> 
<p>Function long GetWindowLong (long  hwnd , long nIndex ) Library  "user32.dll" Alias for "GetWindowLongA" </p> 
<p>Function long SetWindowLong (long  hwnd, long  nIndex , long dwNewLong )  Library "user32.dll" Alias for "SetWindowLongA" </p> 
<p>Function long SetLayeredWindowAttributes  (long hwnd , long  crKey , long  bAlpha , long dwFlags ) Library "user32.dll"</p> 
<p>Constant long  WS_EX_LAYERED = 32768</p> 
<p>Constant long  GWL_EXSTYLE =-20<br>Constant long  LWA_ALPHA =2<br>Constant long  LWA_COLORKEY =1</p> 
<p>窗口w_example的open事件：<br>long rtn<br>rtn = GetWindowLong(handle(this), GWL_EXSTYLE)   //注释：取的窗口原先的样式<br>rtn = rtn + WS_EX_LAYERED    //注释：使窗体添加上新的样式WS_EX_LAYERED<br>SetWindowLong(handle(thios), GWL_EXSTYLE, rtn )//  注释：把新的样式赋给窗体</p> 
<p>SetLayeredWindowAttributes(handle(this), 0, 192, LWA_ALPHA)</p> 
<p>//注释：把窗体设置成半透明样式,第二个参数表示透明程度<br>//注释：取值范围0--255,为0时就是一个全透明的窗体了<br>  <br> </p> 
<p> </p> 
<p>  </p> 
<p>14、使窗体右上角的X按钮失效 </p> 
<p>外部函数声明</p> 
<p>Function long GetSystemMenu(long hwnd, long bRevert) Library "user32.dll"<br>//函数功能<br>//取得指定窗口的系统菜单的句柄。在powerbuilder，“系统菜单”的正式名称为“控制菜单”，即单击窗口左上角的控制框时出现的菜单 </p> 
<p>//返回值<br>//Long，如执行成功，返回系统菜单的句柄；零意味着出错。如bRevert设为TRUE，也会返回零（简单的恢复原始的系统菜单） </p> 
<p>//备注<br>//在powerbuilder里使用：系统菜单会向窗口发送一条WM_SYSCOMMAND消息，而不是WM_COMMAND消息 </p> 
<p>//参数表<br>//hwnd ----------- Long，窗口的句柄 </p> 
<p>//bRevert -------- Long，如设为TRUE，表示接收原始的系统菜单 </p> 
<p>Function long RemoveMenu(long hMenu, long nPosition, long wFlags) Library "user32.dll" </p> 
<p>//函数功能<br>//删除指定的菜单条目。如删除的条目属于一个弹出式菜单，那么这个函数不会同时删除弹出式菜单。首先应该用GetSubMenu函数取得弹出式菜单的句柄，再在以后将其删除 </p> 
<p>//返回值<br>//Long，非零表示成功，零表示失败。会设置GetLastError </p> 
<p>//备注<br>//强烈建议大家使用powerbuilder菜单的visible属性从菜单中删除条目，而不要用这个函数，否则会造成指定菜单中其他菜单条目的visible属性对错误的菜单条目产生影响 </p> 
<p>//参数表<br>//hMenu ---------- Long，菜单的句柄 </p> 
<p>//nPosition ------ Long，欲改变的菜单条目的标识符。如在wFlags参数中指定了MF_BYCOMMAND，这个参数就代表欲改变的菜单条目的命令ID。如设置的是MF_BYPOSITION，这个参数就代表菜单条目在菜单中的位置（第一个条目的位置为零） </p> 
<p>//wFlags --------- Long，常数MF_BYCOMMAND或MF_BYPOSITION，取决于nPosition参数</p> 
<p>实现代码：<br>w_example窗口的open事件：<br>long R,mymenu<br>MyMenu = GetSystemMenu(handle(this), 0)<br>RemoveMenu(MyMenu, 96, R) <br>//程序中用到了两个API函数GetSystemMenu、RemoveMenu，其中GetSystemMenu函数用来得到系统菜单的句柄，RemoveMenu用来删除指定的菜单条目，我们先来看看这个函数的声明和参数：<br>Function long GetSystemMenu(long hwnd, long bRevert) Library "user32.dll"<br>Function long RemoveMenu(long hMenu, long nPosition, long wFlags) Library "user32.dll" <br>其中各GetSystemMenu参数的意义如下表: <br>参数 意义 <br>hwnd Long 系统菜单所在窗口的句柄 <br>bRevert Long 如设为TRUE，表示恢复原始的系统菜单 <br>返回值 Long 如执行成功，返回系统菜单的句柄；零意味着出错。如bRevert设为TRUE，也会返回零（简单的恢复原始的系统菜单） <br>而RemoveMenu参数的意义如下表: <br>参数 意义 <br>hMenu Long 菜单的句柄 <br>nPosition Long 欲改变的菜单条目的标识符。如在wFlags参数中指定了MF_BYCOMMAND，这个参数就代表欲改变的菜单条目的命令ID。如设置的是MF_BYPOSITION，这个参数就代表菜单条目在菜单中的位置（第一个条目的位置为零） <br>wFlags Long 常数MF_BYCOMMAND＝0或MF_BYPOSITION＝1024，取决于nPosition参数 <br>返回值 Long，非零表示成功，零表示失败 <br>然后就可以在程序中使用这两个函数了，我们在窗体的Form_Load()过程中加入如下代码： <br>MyMenu = GetSystemMenu(handle(this),0)//得到系统菜单的句柄，handle(this)表示当前窗体的句柄 <br>RemoveMenu(MyMenu, 96, MF_BYCOMMAND)//移去“关闭”菜单项，96“关闭”菜单项的命令ID <br>  <br>  </p> 
<p> <br> <br>15、如何获得屏幕保护程序的密码<br>//如果屏幕保护程序设置了密码，密码将被加密，然后写到注册表的“HKEY_CURRENT_USER/Control Panel/Desktop/ScreenSave_Data”位置。屏保密码的最大长度为128位。加密方式是将密码与一特定字符串异或后得到密文，经过参考有关资料，笔者利用VB成功地破解了屏保的密码。 <br>外部函数声明：<br>Function long RegOpenKeyEx(long hKey, string lpSubKey, long ulOptions, long samDesired, long phkResult) Library "advapi32.dll" Alias for "RegOpenKeyExA"  <br>Function long RegCloseKey(long hKey) Library "advapi32.dll" <br>Function long RegQueryValueEx(long hKey,string lpValueName, long lpReserved,long lpType,any lpData,long lpcbData) Library "advapi32.dll" Alias for "RegQueryValueExA" <br>Function long RegSetValueEx(long hKey, string lpValueNames, long Reserved,long dwType, any lpData, long cbData)  Library "advapi32.dll" Aliasfor  "RegSetValueExA" //以上api可以使用powerbuilder提供的注册表函数替代<br>实例变量声明：<br>//注释：加密和解密所用的字符串 <br>Constant string Key = "48EE761D6769A11B7A8C47F85495975F78D9DA6C59D76B35C57785182A0E52FF00<br>E31B718D3463EB91C3240FB7C2F8E3B6544C3554E7C94928A385110B2C68FBEE7DF66CE39C2DE47<br>2C3BB851A123C32E36B4F4DF4A924C8FA78AD23A1E46D9A04CE2BC5B6C5EF935CA8852B413772FA<br>574541A1204F80B3D52302643F6CF10F" <br>Constant long HKEY_CURRENT_USER = 2147483649<br>Constant long REG_SZ = 1 <br>Constant long KEY_READ = &amp;H20019 <br>窗口自定义函数：<br>//注释：自定义函数，找到屏保密码 <br>Function string GetScreenSaverPwd() <br>string EncryptedPassword ,DecryptedPassword,strRetVal,strreturn<br>long lngResult,lngHandle,lngcbData<br>//注释：从注册表中读取已经加密的屏保密码 <br>RegOpenKeyEx(HKEY_CURRENT_USER, "Control Panel/desktop", 0, KEY_READ, lngHandle) <br>RegQueryValueEx(lngHandle, "ScreenSave_Data", 0, lngType, ByVal strRetVal, lngcbData )<br>strRetVal = Space(lngcbData) <br>lngResult = RegQueryValueEx(lngHandle, "ScreenSave_Data", 0, lngType, ByVal strRetVal, lngcbData) <br>RegCloseKey (lngHandle) <br>EncryptedPassword = strRetVal <br>//注释：解密,得到密码 <br>If Len(EncryptedPassword) &lt;&gt; 1 Then <br>EncryptedPassword = Left(EncryptedPassword, Len(EncryptedPassword) - 1) <br>//注释：每2位与Key进行异或运算，得到密码 <br>For i = 1 To Len(EncryptedPassword) Step 2 <br>   DecryptedPassword = wf_or(DecryptedPassword,wf_Xor(Mid(EncryptedPassword, i, 2),Mid(Key, i, 2)))//这个是随便写的，可能有问题的：）<br>Next <br>str_return = DecryptedPassword <br>Else <br>str_return = "" <br>End If <br>If str_return = "" Then str_return = "未设置屏保密码。" <br>return str_return <br> <br> <br> <br>  </p> 
<p>16、设置本地机器的时间</p> 
<p>外部函数引用声明：</p> 
<p>Function long SetSystemTime(stc_systemtime lpSystemTime) Library "kernel32.dll" </p> 
<p>结构声明：</p> 
<p>type stc_systemtime from structure<br>integer  wyear<br>integer  wmonth<br>integer  wdayofweek<br>integer  wday<br>integer  whour<br>integer  wminute<br>integer  wsecond<br>integer  wmilliseconds<br>end type</p> 
<p>实现代码：</p> 
<p>public function boolean of_setsystemtime (datetime adt_datetime);</p> 
<p>stc_systemtime lstc_systemtime<br>date ld_date<br>time lt_time<br>ld_date=date(adt_datetime)<br>lt_time=time(adt_datetime)<br>lstc_systemtime.wyear=year(ld_date)//设置结构变量的年<br>lstc_systemtime.wmonth=month(ld_date)//设置结构变量的月</p> 
<p>lstc_systemtime.wday=day(ld_date)//)//设置结构变量的天lstc_systemtime.wdayofweek=daynumber(ld_date)//设置结构变量的星期数lstc_systemtime.whour=hour(lt_time)//设置结构变量的小时</p> 
<p>lstc_systemtime.wminute=minute(lt_time)//设置结构的秒数<br>lstc_systemtime.wsecond=minute(lt_time)//设置结构的分钟数<br>lstc_systemtime.wmilliseconds=0//设置结构的微秒数<br>return setsystemtime(lstc_systemtime)&lt;&gt;0//返回是否设置成功</p> 
<p>end function<br>  <br> </p> 
<p>  <br>  </p> 
<p>17、调用API函数设计ABOUT窗口 </p> 
<p>　　Windows操作系统的许多软件中都包含一个windows 风格的about 窗口，它向用户反映了当前系统的一些基本信息，其中显示有关windows 及其应用软件的版本、版权和系统的工作状态等信息。以下通过调用API 函数设计应用系统的ABOUT 窗口。</p> 
<p>外部函数引用声明：</p> 
<p>Function long GetWindowWord  (long hwnd, long nIndex ) Library "user32.dll"</p> 
<p>Function long ShellAbout (long hwnd, string  szApp , string szOtherStuff, long hIcon) Library "shell32.dll" Alias for "ShellAboutA" </p> 
<p>Function long ExtractIcon (long hinst, string lpszExeFileName, long nIconIndex )  Library "shell32.dll" Alias for "ExtractIconA"</p> 
<p>Function long GetDiskFreeSpace (string lpRootPathName, long lpSectorsPerCluster, long lpBytesPerSector , long lpNumberOfFreeClusters , long lpTotalNumberOfClusters) Library "kernel32.dll" Alias for "GetDiskFreeSpaceA"</p> 
<p>function long GetDriveType(string nDrive) Library "kernel32.dll" Alias for "GetDriveTypeA"</p> 
<p>Subroutine GetSystemInfo ( SYSTEM_INFO lpSystemInfo)  Libaray "kernel32.dll"</p> 
<p>Function long GetSystemMetrics(long nIndex ) Library "user32.dll" </p> 
<p>定义实例变量：</p> 
<p>Constant long GWL_EXSTYLE = -20<br>Constant long  GWL_STYLE = -16<br>Constant long GWL_WNDPROC = -4<br>Constant long GWL_HINSTANCE = -6</p> 
<p>Constant long SM_CXSCREEN = 0<br>Constant long SM_CYSCREEN = 1</p> 
<p>定义结构system_info<br>Type SYSTEM_INFO from structure<br>long dwOemID <br>long dwPageSize </p> 
<p>long lpMinimumApplicationAddress </p> 
<p>long lpMaximumApplicationAddress </p> 
<p>long dwActiveProcessorMask </p> 
<p>long dwNumberOrfProcessors</p> 
<p>long dwProcessorType </p> 
<p>long dwAllocationGranularity </p> 
<p>long dwReserved</p> 
<p>End Type</p> 
<p>实现代码：<br>w_example.cb_1.clicked:</p> 
<p>long  hinst ,icons,abouts,cls1, cls2,secs ,bytes,x</p> 
<p>string dispx,dispy ,cps ,space1 ,space2,buffs </p> 
<p>system_info sysinfo  hinst = GetWindowWord(handle(parent), GWL_HINSTANCE)//获得指定窗口结构的信息<br>icons = ExtractIcon(hinst, "d:/fpw26/foxprow.exe", 0)//获取指定的可执行程序的图标<br>buff = "C:/"<br>GetDriveType(buffs)//获取盘的类型<br>GetDiskFreeSpace(buffs, secs, bytes, cls1, cls2)//获取指定分区的容量，注：这个api函数不能获取大硬盘分区的信息<br>cls1 = cls1 * secs * bytes<br>cls2 = cls2 * secs * bytes </p> 
<p>space1 = "C驱动器总共容量：" +string(cls2/1024, "#, #") + "千字节"<br>space2 = "C驱动器可用容量：" + string(cls1/1024, "#, #") + "千字节"<br>x=GetSystemMetrics(SM_CXSCREEN)//获取显示器的水平方向分辨率<br>dispx = "显示器分辨率：" + String(x)<br>x = GetSystemMetrics(SM_CYSCREEN)//获取显示器的垂直方向分辨率<br>dispy = String(x)<br>GetSystemInfo(sysinfo)//获取系统信息（如cpu，电源）<br>choose Case sysinfo.dwProcessorType<br>        Case 386 </p> 
<p>      　　cpus = "处理器类型:386"<br>　　Case 486<br>　　      cpus = "处理器类型:486"<br>　　Case 586<br>　       　cpus = "处理器类型:586"<br>　　end choose</p> 
<p>abouts = ShellAbout(handle(parent), "演示程序","销售管理系统V2.0版权所有[C]2004-2005天天软件" +&amp;</p> 
<p>Char(13) + Char(10) + space1 + Char(13) + Char(10)+&amp;<br>space2+ char(13) + Char(10) + cpus + " " + dispx +&amp;<br>"*" + dispy , icons)//显示标准的about对话框<br>  <br> </p> 
<p>  </p> 
<p>18、获得IE的版本号 <br>定义结构：</p> 
<p>Type DllVersionInfo from structure</p> 
<p><br>long cbSize</p> 
<p>long dwMajorVersion </p> 
<p>long dwMinorVersion </p> 
<p>long dwBuildNumber</p> 
<p>long dwPlatformID</p> 
<p>End Type </p> 
<p>外部函数引用声明：</p> 
<p>Funcation long DllGetVersion Lib( DllVersioninfo dwVersion) library "Shlwapi.dll" </p> 
<p>窗口w_example的窗口级函数:</p> 
<p>string Wf_VersionString() </p> 
<p>string ls_return</p> 
<p>DllVersionInfo DVI</p> 
<p>DVI.cbSize = 160//对DllVersioninfo的相关成员进行初始化</p> 
<p>DllGetVersion(DVI) //调用api函数有关IE的信息</p> 
<p>ls_return = "Internet Explorer " +DVI.dwMajorVersion + "." +DVI.dwMinorVersion+ "." +DVI.dwBuildNumber </p> 
<p><br>return ls_return<br>   <br> <br> <br>  </p> 
<p>19.指定ip能否ping通</p> 
<p><br>定义两个结构：<br>str_ip_option:<br>ttl char<br>tos char<br>flags char<br>size char<br>data long</p> 
<p>str_icmp_ech<br>address       ulong<br>status        ulong<br>roundtriphome ulong<br>datasize      uint<br>reserved      uint<br>datapointer   ulong<br>options       str_ip_option<br>data[250]     char</p> 
<p>声明外部函数:<br>function long inet_addr(ref string addr) library "wsock32.dll"<br>function long IcmpCloseHandle(long IcmpHandle) library "icmp.dll"<br>function long IcmpSendEcho (long IcmpHandle,long DestinationAddress,string requestData,integer requestSize,long requestOption,ref str_icmp_echo replyBuffer,long replySize,long timeout ) library "icmp.dll"<br>function long IcmpCreateFile() library "icmp.dll"</p> 
<p>函数,返回true表示能ping通:<br>boolean f_ping(string ps_ipaddr):<br>ulong  lul_NetAddress<br>long   ll_hFile,ll_ret<br>string ls_Message=Space(20)<br>str_icmp_echo preturn</p> 
<p>lul_NetAddress=inet_addr(as_IPAddr)<br>IF lul_NetAddress=-1 THEN RETURN FALSE</p> 
<p>ll_hFile=IcmpCreateFile()<br>IF ll_hFile = 0 THEN  RETURN FALSE<br>ll_ret=IcmpSendEcho(ll_hFile,lul_NetAddress,ls_Message,Len(ls_Message),0,preturn,282,500)<br>IcmpCloseHandle(ll_hfile)</p> 
<p>RETURN ll_ret &gt; 0<br>  </p> 
<p> <br>  </p> 
<p>20.使程序不出现在Windows任务列表中( Win98 )</p> 
<p>定义常量：<br>constant long RSP_SIMPLE_SERVICE = 1<br>constant long RSP_UNREGISTER_SERVICE = 0</p> 
<p>声明外部函数：<br>//获取当前进程id<br>function long GetCurrentProcessId() library 'kernel32'<br>//注册服务进程<br>function long RegisterServiceProcess(long processid, long type) library 'kernel32'</p> 
<p>application的open事件:<br>long ll_procid<br>ll_procid = GetCurrentProcessId()<br>RegisterServiceProcess(ll_procid, RSP_SIMPLE_SERVICE)</p> 
<p>application的close事件:<br>long ll_procid<br>ll_procid = GetCurrentProcessId()<br>RegisterServiceProcess(ll_procid, RSP_UNREGISTER_SERVICE)<br>  <br>   <br>  <br>  </p> 
<p>21、获取光驱的盘符</p> 
<p>外部函数声明：</p> 
<p>Function uint GetDriveTypeA(string lpRootPathName) LIBRARY "kernel32.dll"</p> 
<p>自定义用户函数</p> 
<p>public function string of_get_drive_type (string as_rootpathname);/*函数作用:获取指定的驱动器的类型<br>  参数:as_drive string 驱动器名<br>  返回值:string   */  <br>string ls_DriveType<br>as_RootPathName=Left(as_RootPathName,1)+":"<br>CHOOSE CASE GetDriveTypeA(as_RootPathName)<br>CASE 2<br>  ls_DriveType="REMOVABLE"//可移动磁盘<br>CASE 3<br>  ls_DriveType="FIXED"//软驱<br>CASE 4<br>  ls_DriveType="REMOTE"//网络驱动盘符<br>CASE 5<br>  ls_DriveType="CDROM"//光驱<br>CASE 6<br>  ls_DriveType="RAMDISK"//随机存储设备<br>CASE ELSE<br>  SetNull(ls_DriveType)<br>END CHOOSE<br>RETURN ls_DriveType<br>end function</p> 
<p>public function string of_get_drive_cdrom ();/*函数作用:获取光驱的驱动器名<br>   返回值:string    */   <br>integer li_i,li_start,li_end<br>string ls_CDRoms=""<br>li_start=Asc("A")<br>li_end=Asc("Z")<br>FOR li_i=li_start TO li_end<br>IF of_get_drive_Type(Char(li_i))="CDROM" THEN ls_CDRoms=ls_CDRoms+Char(li_i)</p> 
<p>//调用自定义函数of_get_drive_type()并判断函数返回值，如是CDROM则退出循环<br>NEXT<br>RETURN ls_CDRoms<br>end function<br>  <br> <br> <br>  </p> 
<p>22、实现系统托盘 <br>　WINDOWS状态栏也称系统托盘，在WINDOWS9X中已有系统时钟、音量控制、输入法等程序在WINDOWS的状态栏中设有图标，一些应用程序在安装完后也将它们本身的图标放入了状态栏中，如超级解霸、WINAMP等。通过在应用程序中有效地控制状态栏中的图标，不仅可以使应用程序具有专业水准，也方便了用户的操作。VB做为一种使用很广的高级语言，实现将图标放入状态栏的功能并不困难，只要有效地利用一个API函数 Shell_NotifyIcon和NOTIFYICONDATA数据结构就能达到这一目的，有关这两者的定义和使用在程序中有详细的注释，在此就不再详述了。</p> 
<p>　　下面的这个程序运行后，将窗口图标加入到了WINDOWS状态栏中，用鼠标右击该图标会弹出一个菜单，可实现修改该图标、窗口复位、最小化、最大化及关闭程序等功能。</p> 
<p>实现步骤：</p> 
<p>结构定义</p> 
<p>Type NOTIFYICONDATA from structure<br>　long cbSize //注释：该数据结构的大小<br>　long hwnd //注释：处理任务栏中图标的窗口句柄<br>　long uID//注释：定义的任务栏中图标的标识<br>　long uFlags //注释：任务栏图标功能控制，可以是以下值的组合（一般全包括）<br>　//注释：NIF_MESSAGE 表示发送控制消息；<br>　//注释：NIF_ICON表示显示控制栏中的图标；<br>　//注释：NIF_TIP表示任务栏中的图标有动态提示。<br>　long uCallbackMessage//注释：任务栏图标通过它与用户程序交换消息，处理该消息的窗口由hWnd决定<br>　long hIcon //注释：任务栏中的图标的控制句柄<br>　string szTip//注释：图标的提示信息<br>End Type</p> 
<p>外部函数引用声明：</p> 
<p>Function long Shell_NotifyIcon (long dwMessage,NOTIFYICONDATA lpData  ) Library "shell32.dll" Alias for "Shell_NotifyIconA" </p> 
<p>实例变量定义：</p> 
<p>Constant long  WM_SYSCOMMAND = 274</p> 
<p>Constant long  SC_RESTORE = 61728</p> 
<p>integer LastState //注释：保留原窗口状态</p> 
<p>//注释：---------- dwMessage可以是以下NIM_ADD、NIM_DELETE、NIM_MODIFY 标识符之一</p> 
<p>Constant long  NIM_ADD =0 //注释：在任务栏中增加一个图标<br>Constant long  NIM_DELETE =2 //注释：删除任务栏中的一个图标<br>Constant long  NIM_MODIFY = 1//注释：修改任务栏中个图标信息</p> 
<p>Constant long NIF_MESSAGE = 1// 注释：NOTIFYICONDATA结构中uFlags的控制信息<br>Constant long  NIF_ICON = 2<br>Constant long NIF_TIP =4</p> 
<p>Constant long  WM_MOUSEMOVE = 512//注释：当鼠标指针移至图标上</p> 
<p>Constant long  WM_LBUTTONUP = 514</p> 
<p>Constant long WM_RBUTTONUP =517</p> 
<p>NOTIFYICONDATA myData</p> 
<p>w_example窗口的open事件：</p> 
<p>If this. WindowState = Minimized! Then<br>　　LastState = Normal!<br>　Else<br>　　LastState = this.WindowState<br>　End If</p> 
<p>myData.cbSize = 256</p> 
<p>mydata.hwnd =handle(this)</p> 
<p>mydata.uID = 0<br>mydata.uFlags = NIF_ICON + NIF_MESSAGE + NIF_TIP<br>mydata.uCallbackMessage = WM_MOUSEMOVE<br>mydata.hIcon = this.Icon//注释：默认为窗口图标<br>mydate.szTip = "提示" <br>Shell_NotifyIcon(NIM_ADD, myData)</p> 
<p>窗口w_example的mousemove事件：</p> 
<p>choose case long (X)<br>　　Case WM_RBUTTONUP //注释：鼠标在图标上右击时弹出菜单<br>　　　　m_popup im_pop</p> 
<p>             im_pop=create m_popup</p> 
<p>             im_pop.popmemu(x,y)</p> 
<p>            destroy im_pop</p> 
<p>　　Case WM_LBUTTONUP //注释：鼠标在图标上左击时窗口若最小化则恢复窗口位置<br>　　　　If this.WindowState = Minimized Then<br>　　　　　this.WindowState = LastState<br>　　　　　this.SetFocus<br>　　　　End If<br>end choose</p> 
<p>窗口w_example的close事件：</p> 
<p>Shell_NotifyIcon（NIM_DELETE, myData）// 注释：窗口卸载时，将状态栏中的图标一同卸载<br>  </p> 
<p><br>  </p> 
<p>23、获取文件的相关时间信息</p> 
<p>实现步骤</p> 
<p>定义结构</p> 
<p>type stc_find_data from structure<br>unsignedlong  att<br>stc_filetime  c_time<br>stc_filetime  a_time<br>stc_filetime  w_time<br>unsignedlong  h_size<br>unsignedlong  l_size<br>unsignedlong  dwreserved0<br>unsignedlong  dwreserved1<br>character  cfilename[260]<br>character  calternatefilename[16]<br>end type</p> 
<p>type stc_filetime from structure<br>  long htime<br>  long ltime<br>end type</p> 
<p>定义外部函数声明</p> 
<p>Function ulong GetFileAttributesA(string lpFileName) LIBRARY "kernel32.dll"<br>FUNCTION ulong FindClose(ulong hFindFile) LIBRARY "kernel32.dll"<br>FUNCTION ulong FindFirstFile(ref string lpFileName,ref stc_find_data lpFindFileData) LIBRARY "kernel32.dll" ALIAS FOR "FindFirstFileA"<br>FUNCTION ulong FindNextFile(ulong hFindFile,ref stc_find_data lpFindFileData) LIBRARY "kernel32.dll" ALIAS FOR "FindNextFileA"<br>FUNCTION ulong FileTimeToDosDateTime(ref stc_filetime lpFileTime,ref long lpFatDate,ref long lpFatTime) LIBRARY "kernel32.dll"<br>FUNCTION ulong DosDateTimeToFileTime(ulong wFatDate,ulong wFatTime,ref stc_filetime lpFileTime) LIBRARY "kernel32.dll"</p> 
<p>public function datetime of_get_file_writetime (string as_filename);/*函数作用:获取文件的最后写操作时间<br>  参数: as_filename string 文件名，需绝对文件路径<br>  返回值:datetime                 */<br>long ll_code<br>datetime ldt_filedatetime<br>long lul_date,lul_time<br>int lui_year,lui_month,lui_day,lui_hour,lui_minute,lui_second<br>stc_find_data ls_file<br>ll_code=findfirstfile(as_filename,ls_file)//查找文件<br>findclose(ll_code)<br>ldt_filedatetime=datetime(ls_file.w_time)//文件的最后写入时间<br>if ll_code=-1 then<br>setnull(ldt_filedatetime)<br>else<br>filetimetodosdatetime (ls_file.w_time,lul_date,lul_time)//转换dos时间为powerbuilder的日期、时间<br>lui_day=mod(lul_date,32)<br>lui_month=mod(lul_date,512)/32 <br>if lui_month=0 then<br>  lui_month=1<br>end if<br>lui_year=lul_date/512+1980<br>lui_second=mod(lul_time,32)*2<br>lui_minute=mod(lul_time,2048)/32<br>lui_hour=(lul_time)/2048 + 8<br>if lui_hour&gt;=24  then<br>  lui_hour=lui_hour - 24<br>  ldt_filedatetime=datetime(relativedate(date(lui_year,lui_month,lui_day),1),time(lui_hour,lui_minute,lui_second))<br>else<br>  ldt_filedatetime=datetime(date(lui_year,lui_month,lui_day),time(lui_hour,lui_minute,lui_second))  <br>end if<br>end if<br>return ldt_filedatetime<br>end function</p> 
<p>public function datetime of_get_file_createtime (string as_filename);/*函数作用:获取文件的创建时间<br>  参数: as_filename string 文件名，需绝对文件路径<br>  返回值:datetime                 */<br>long ll_code<br>datetime ldt_filedatetime<br>long lul_date,lul_time<br>int lui_year,lui_month,lui_day,lui_hour,lui_minute,lui_second<br>stc_find_data ls_file<br>ll_code=findfirstfile(as_filename,ls_file)<br>findclose(ll_code)<br>ldt_filedatetime=datetime(ls_file.c_time)<br>if ll_code=-1 then<br>setnull(ldt_filedatetime)<br>else<br>filetimetodosdatetime (ls_file.c_time,lul_date,lul_time)<br>lui_day=mod(lul_date,32)<br>lui_month=mod(lul_date,512)/32 <br>if lui_month=0 then<br>  lui_month=1<br>end if<br>lui_year=lul_date/512+1980<br>lui_second=mod(lul_time,32)*2<br>lui_minute=mod(lul_time,2048)/32<br>lui_hour=(lul_time)/2048 + 8<br>if lui_hour&gt;=24  then<br>  lui_hour=lui_hour - 24<br>  ldt_filedatetime=datetime(relativedate(date(lui_year,lui_month,lui_day),1),time(lui_hour,lui_minute,lui_second))<br>else<br>  ldt_filedatetime=datetime(date(lui_year,lui_month,lui_day),time(lui_hour,lui_minute,lui_second))  <br>end if<br>end if<br>return ldt_filedatetime<br>end function</p> 
<p>public function datetime of_get_file_accesstime (string as_filename);/*函数作用:获取文件的最后访问时间<br>  参数: as_filename string 文件名，需绝对文件路径<br>  返回值:datetime                 */<br>long ll_code<br>datetime ldt_filedatetime<br>long lul_date,lul_time<br>int lui_year,lui_month,lui_day,lui_hour,lui_minute,lui_second<br>stc_find_data ls_file<br>ll_code=findfirstfile(as_filename,ls_file)<br>findclose(ll_code)<br>ldt_filedatetime=datetime(ls_file.a_time)<br>if ll_code=-1 then<br>setnull(ldt_filedatetime)<br>else<br>filetimetodosdatetime (ls_file.a_time,lul_date,lul_time)<br>lui_day=mod(lul_date,32)<br>lui_month=mod(lul_date,512)/32 <br>if lui_month=0 then<br>  lui_month=1<br>end if<br>lui_year=lul_date/512+1980<br>lui_second=mod(lul_time,32)*2<br>lui_minute=mod(lul_time,2048)/32<br>lui_hour=(lul_time)/2048 + 8<br>if lui_hour&gt;=24  then<br>  lui_hour=lui_hour - 24<br>  ldt_filedatetime=datetime(relativedate(date(lui_year,lui_month,lui_day),1),time(lui_hour,lui_minute,lui_second))<br>else<br>  ldt_filedatetime=datetime(date(lui_year,lui_month,lui_day),time(lui_hour,lui_minute,lui_second))  <br>end if<br>end if<br>return ldt_filedatetime<br>end function<br>  <br> </p> 
<p>  </p> 
<p>24、清除开始菜单中“我的文档”的列表文件 </p> 
<p>清除开始菜单中“我的文档”的列表文件 </p> 
<p>在“任务栏 属性”的“开始菜单程序”中有一个“清除”按钮，用于清除“我的文档”所列出的最近打开的文件列表。</p> 
<p>在Powerbuilder应用程序中如何实现这一功能呢？</p> 
<p>首先我们来理解Windows是通过什么方式在文档中添加列表文件的。</p> 
<p>在Windows中，当我们打开某些类型的文件时，均在开始菜单的“我的文档”中添加以该文件名命名的快捷方式。其实这</p> 
<p>调用了shell32.dll文件所提供的函数SHAddToRecentDocs。此函数顾名思义是专门用来往开始菜单中“我的文档”添加列</p> 
<p>表文件的。Powerbuilder调用它的相应格式为：</p> 
<p>string  NewFile</p> 
<p>NewFile = "C:/TEST.TXT"</p> 
<p>SHAddToRecentDocs(2,NewFile) //注释：添加项目</p> 
<p>如果我们反其道而行之，能不能让它清除列表文件而不是添加新项目呢。请看如下代码：</p> 
<p>//注释：外部函数引用声明</p> 
<p>Subroutine  SHAddToRecentDocs(long uFlags,string pv ) Library "shell32.dll"</p> 
<p>//注释：给工程添加一个按钮，其单击事件的代码为：</p> 
<p>w_example.cb_1.clicked:</p> 
<p>string ls_temp</p> 
<p>setnull(ls_temp)</p> 
<p>SHAddToRecentDocs(2,ls_temp)// 注释：清除<br>   <br> <br>  </p> 
<p>25、用Semaphore检测运行实例的个数 </p> 
<p>使用到的api函数解释：</p> 
<p>CreateSemaphore(SECURITY_ATTRIBUTES lpSemaphoreAttributes  , long lInitialCount, long lMaximumCount, string lpName ) </p> 
<p>该函数是Windows提供用来创建一个Semaphore信号的函数,其参数含义如下： </p> 
<p>lpSemaphoreAttributes：安全属性参数，是为Windows NT设置的，在Windows 95下可以忽略。但是在PowerBuilder中若如上述声明，则不能忽略，忽略后该函数有时不能正确执行，并返回0。此时，可以设置其为默认值，或者改为long lpSemaphoreAttributes，然后再传入0。 </p> 
<p>lInitialCount：Semaphore的初始值，一般设为0或lMaxmumCount。 </p> 
<p>lMaximunCount：Semaphore信号的最大值。 </p> 
<p>lpName：该信号名，以便其他进程对其进行调用，若是相同进程可以设为Null。 </p> 
<p>函数成功时返回创建的Semaphore信号的句柄。该函数有一个特点，就是在要创建的信号已经创建了的情况下，它等同于函数OpenSemaphore()，仅仅是打开该Semaphore信号，并返回信号句柄。 </p> 
<p>ReleaseSemaphore(long  hSemaphore, long lReleaseCount，long lpPreviousCount)</p> 
<p>hSemaphore：函数CreateSemaphore()返回的Semaphore信号句柄； </p> 
<p>lReleaseCount： 当前信号值的改变量； </p> 
<p>lpPreviousCount：返回的Semaphore信号被加之前的值，可用于跟踪测试。 </p> 
<p>如果Semaphore信号当前值加上lReleaseCount后不超过CreateSemaphore()中设定的最大值lMaximunCount，函数返回1(True),否则返回0(False),可用GetLastError()得到其失败的详细原因。 </p> 
<p>WaitForSingleObject(long hHandle , long dwMilliseconds)</p> 
<p>hHandle：等待对象的句柄； </p> 
<p>dwMilliseconds：等待时间。 </p> 
<p>　该函数可以实现对一个可等待对象的等待操作,获取操作执行权。当等待的对象被释放时函数成功返回，同时使等待对象变为有信号状态，或者超时返回。该函数用于等待Semaphore信号时，若Semaphore信号不为0，则函数成功返回，同时使Semaphore信号记数减1。 </p> 
<p>实现步骤：</p> 
<p>定义结构：</p> 
<p>Type SECURITY_ATTRIBUTES  from structure</p> 
<p>long nLength</p> 
<p>long lpSecurityDescriptor </p> 
<p>long bInheritHandle </p> 
<p>End Type </p> 
<p>定义外部函数引用声明：</p> 
<p>Function long ReleaseSemaphore (long  hSemaphore, long lReleaseCount ,long lpPreviousCount) Library "kernel32.dll"</p> 
<p>Function long CreateSemaphore(SECURITY_ATTRIBUTES lpSemaphoreAttributes, long lInitialCount, long lMaximumCount , string lpName ) Library "kernel32.dll" Alias for "CreateSemaphoreA"  </p> 
<p>Function long WaitForSingleObject (long hHandle, long  dwMilliseconds)  Library "kernel32.ll"</p> 
<p>定义实例变量：</p> 
<p>string Semaphore, </p> 
<p>long Sema ,PrevSemaphore , Turn </p> 
<p>SECURITY_ATTRIBUTES  Security  </p> 
<p>窗口w_example的open事件：</p> 
<p>Security.bInheritHandle = True //注释：默认的安全值 </p> 
<p>Security.lpSecurityDescriptor = 0 </p> 
<p>Security.nLength = 96</p> 
<p>Semaphore = "Instance"</p> 
<p>//创建或打开一个Semaphore记数信号，设资源空闲使用量为4 </p> 
<p>Sema = CreateSemaphore(Security, 4, 4, Semaphore) </p> 
<p>//注释：申请一个权限，并立即返回 </p> 
<p>//Turn = WaitForSingleObject (Sema, 0) </p> 
<p>//注释：如果不是正常返回，则表示没有申请到资源的使用权限 </p> 
<p>If Turn &lt;&gt; 0 Then </p> 
<p>messagebox("", "Full!") </p> 
<p>End If </p> 
<p><br>窗口w_example的closequery事件：</p> 
<p>//在当前值上加1，表示有一个程序退出，释放了一个权限，PrevSemaphore参数接收释放前的计数器的值 </p> 
<p>ReleaseSemaphore （Sema, 1, PrevSemaphore）<br>  <br>  <br>  </p> 
<p>26、判断一个32位程序是否结束 </p> 
<p>实现步骤：</p> 
<p>外部函数引用声明：</p> 
<p>Function long OpenProcess(ref long  dwDesiredaccess,ref long  bInherithandle, ref long dwProcessid)  Library "kernel32.dll" </p> 
<p>Function long  GetExitCodeProcess(long  hProcess, long lpexitcode)  Library "kernel32.dll" </p> 
<p>定义实例变量：</p> 
<p>Constant long  STILL_ACTIVE = 259</p> 
<p>Constant long PROCESS_QUERY_INFORMATION = 1024 </p> 
<p>定义窗口级函数</p> 
<p>wf_ShellWait(string cCommandLine) </p> 
<p>long hShell ,hProc, lExit </p> 
<p>hShell = run(cCommandLine) </p> 
<p>hProc = OpenProcess(PROCESS_QUERY_INFORMATION, False, hShell) </p> 
<p>Do </p> 
<p>GetExitCodeProcess(hProc, lExit )</p> 
<p>Yield ()</p> 
<p>Loop  until  lExit = STILL_ACTIVE </p> 
<p>//调用 ShellWait，控制权将不会交给一个过程，直到调用该过程的程序结束 <br>   <br> <br>  </p> 
<p>27、如何为你的应用程序设置热键？ </p> 
<p>实现步骤：</p> 
<p>外部函数引用声明：</p> 
<p>Function long SendMessage (long hwnd , long wMsg , long  wParam, long lParam)  Library "user32.dll" alias for "SendMessageA"</p> 
<p>Function long DefWindowProc (long  hwnd,long wMsg, long wParam, long  lParam) Library "user32.dll" Alias for "DefWindowProcA" </p> 
<p>定义实例变量：</p> 
<p>Constant long  WM_SETHOTKEY = 50</p> 
<p>Constant long  WM_SHOWWINDOW = 24</p> 
<p>Constant long  HK_SHIFTA = 321//注释：Shift + A</p> 
<p>Constant long  HK_SHIFTB = 322//注释：Shift * B </p> 
<p>Constant long HK_CONTROLA = 577//注释：Control + A </p> 
<p>Constant long  HK_ALTZ = 1114</p> 
<p>//请注意组合键的值必须以低／高位字节的格式进行声明。也就是说是一个十六进制的数字。后两位是低端字节，如</p> 
<p>41=a；前两位是高端字节，如01=1=shift。 </p> 
<p>窗口w_example的open事件： </p> 
<p>long erg</p> 
<p>this.WindowState = Minimized!//注释：让windows知道你想要的热键。</p> 
<p>erg = SendMessage(handle(this), WM_SETHOTKEY,HK_ALTZ, 0) //注释：检查函数是否执行成功 </p> 
<p>If erg &lt;&gt; 1 Then </p> 
<p>messagebox("提示" "你需要重新注册另一个热键"）</p> 
<p>End If </p> 
<p>//注释：告诉windows热键按下后做什么－－显示窗口 </p> 
<p>erg = DefWindowProc(handle(this), WM_SHOWWINDOW,0, 0) <br>  <br> </p> 
<p><br> 28、如何设定屏幕颜色数　</p> 
<p>//原则上，只改这一次，下一次开机会还原，但如果需重开机，才会Update </p> 
<p>Registry中的设定，并重开机。</p> 
<p>如果要永久设定其设定值，请将</p> 
<p>b = ChangeDisplaySettings(DevM, 0) 改成</p> 
<p>b = ChangeDisplaySettings(DevM, CDS_UPDATEREGISTRY)</p> 
<p>//注：DevM.dmBitsPerPel 便是设定颜色数，其实应说每个Pixel要多少Bits来显示</p> 
<p>//4   --&gt; 16色</p> 
<p>//8   --&gt; 256色</p> 
<p>//16   --&gt; 65536色   以此类推</p> 
<p>实现步骤：</p> 
<p>定义结构：</p> 
<p>type devmode from structure<br>string  dmdevicename<br>integer  dmspecversion<br>integer  dmdriverversion<br>integer  dmsize<br>integer  dmdriverextra<br>long  dmfields<br>integer  dmorientation<br>integer  dmpapersize<br>integer  dmpaperlength<br>integer  dmpaperwidth<br>integer  dmscale<br>integer  dmcopies<br>integer  dmdefaultsource<br>integer  dmprintquantity<br>integer  dmcolor<br>integer  dmduplex<br>integer  dmyresolution<br>integer  dmttoption<br>integer  dmcollate<br>string  dmformname<br>integer  dmunusedpadding<br>long  dmbitsperpel<br>long  dmpelswidth<br>long  dmpelsheight<br>long  dmdisplayflags<br>long  dmdisplayfrequency<br>end type</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long EnumDisplaySettings (long lpszDeviceName, long iModeNum , lpDevMode As DevMode) Library "user32.dll" Alias for "EnumDisplaySettingsA" </p> 
<p>Function long  ChangeDisplaySettings (DevMode lpDevMode , long  dwflags) Library "user32" Alias for "ChangeDisplaySettingsA" </p> 
<p>Function long  ExitWindowsEx (long uFlags , long dwReserved ) Library "user32.dll" </p> 
<p>定义实例变量：</p> 
<p>Constant long  EWX_REBOOT = 2//  注释： 重开机</p> 
<p>Constant long  CCDEVICENAME = 32</p> 
<p>Constant long  CCFORMNAME = 32</p> 
<p>Constant long  DM_BITSPERPEL = 262144</p> 
<p>Constant long  DISP_CHANGE_SUCCESSFUL = 0</p> 
<p>Constant long DISP_CHANGE_RESTART = 1</p> 
<p>Constant long  CDS_UPDATEREGISTRY = 1</p> 
<p><br>DevMode DevM</p> 
<p>实现代码：</p> 
<p>w_example窗口的命令按钮cb_1.clicked:</p> 
<p>boolean a</p> 
<p>long i </p> 
<p>long b </p> 
<p>long ans </p> 
<p>a = EnumDisplaySettings(0, 0, DevM) //注释：Initial Setting</p> 
<p>DevM.dmBitsPerPel = 8 //注释：设定成256色</p> 
<p>DevM.dmFields = DM_BITSPERPEL</p> 
<p>b = ChangeDisplaySettings(DevM, 0)</p> 
<p>If b = DISP_CHANGE_RESTART Then</p> 
<p>       ans = messagebox("提示","要重开机设定才能完成，重开？", question!,yesno!)</p> 
<p>       If ans = 1 Then</p> 
<p>           b = ChangeDisplaySettings(DevM, CDS_UPDATEREGISTRY)</p> 
<p>           ExitWindowsEx(EWX_REBOOT, 0)//这个api函数只能在win98上使用，win nt以上须采用别的方法</p> 
<p>        End If</p> 
<p>Else<br>        If b &lt;&gt; DISP_CHANGE_SUCCESSFUL Then</p> 
<p>          Messagebox("提示","设定有误")</p> 
<p>        End If</p> 
<p>End If<br>  <br>  <br>  </p> 
<p>29、彩色BMP档转成灰度</p> 
<p>将RGB想成3D之X,Y,Z轴,则BMP的RGB为(r,g,b)与座标(Y,Y,Y)距离最小时的Y即为灰度值<br>Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B<br>    整数化<br>Y = ( 9798*R + 19235*G +  3735*B) / 32768<br>RGB(Y, Y, Y)就可以了</p> 
<p>实现步骤：</p> 
<p>外部函数引用声明：</p> 
<p>Funcation long GetPixel (long hdc , long  x , long Y) Library "gdi32.dll" </p> 
<p>Funcation long SetPixelV (long hdc , long x , long Y , long crColor )  Library "gdi32.dll"</p> 
<p>Funcation long GetDC(long handle) library "gdi32.dll"</p> 
<p>定义实例变量：</p> 
<p>picture tmpPic</p> 
<p>窗口w_example的open事件：</p> 
<p>P_1.setredraw(false)// 注释：设定所有Pixel的改变不立即在pictureBox上显示</p> 
<p>tmpPic = Picture1.Picture</p> 
<p>窗口w_example的cb_1.clicked:</p> 
<p>long width5, heigh5, rgb5 </p> 
<p>long hdc5, i , j</p> 
<p>long bBlue, bRed, bGreen</p> 
<p>long y</p> 
<p>width5 = unitstopixels(P_1.Width,xunitstopixels!)</p> 
<p>heigh5 =unitstopixels(P_1.height,yunitstopixels!)</p> 
<p>hdc5 = getdc(handle(this)</p> 
<p>For i = 1 To width5</p> 
<p>   For j = 1 To heigh5</p> 
<p>       rgb5 = GetPixel(hdc5, i, j)</p> 
<p>       bBlue = Blue(rgb5)</p> 
<p>       bRed = Red(rgb5)</p> 
<p>       bGreen = Green(rgb5)</p> 
<p>       Y = (9798 * bRed + 19235 * bGreen + 3735 * bBlue) / 32768</p> 
<p>       rgb5 = RGB(Y, Y, Y)</p> 
<p>       SetPixelV (hdc5, i, j, rgb5)<br>   Next <br>Next <br>P_1.setredraw(true)// 注释：此时才真正显示Picture<br>End Sub</p> 
<p>w_example窗口级函数：</p> 
<p>Function long Red(long  mlColor ) </p> 
<p>return wf_and(mlColor,255)//对mlcolor进行位与计算</p> 
<p>Function long  Green(long mlColor )</p> 
<p>return wf_and((mlColor/256) ,255)</p> 
<p>Function long Blue(long mlColor) </p> 
<p>return wf_and ((mlColor /65536) ,255)<br>  <br> <br>  </p> 
<p>30、如何将的游标显示成动画游标 </p> 
<p>动画在 Windows 底下是 .ani 格式的档案， 要显示此类游标，首先要利用LoadCursorFromFile API 载入.ani 档案，</p> 
<p>然或利用 SetSystemCursor API 加以显示。</p> 
<p>实现步骤：</p> 
<p>定义实例变量</p> 
<p>Constant long OCR_NORMAL = 32512</p> 
<p>Constant long  IDC_ARROW = 32512</p> 
<p>外部函数引用声明</p> 
<p>Function long LoadCursorFromFile (string lpFileName ) Library "user32.dll" Alias for  "LoadCursorFromFileA"</p> 
<p>Function long LoadCursor (ref long  hInstance , long lpCursorName) Library  "user32.dll" Alias for  " LoadCursorA" </p> 
<p>//注释： modified</p> 
<p>Function long SetSystemCursor (long  hcur , long  id )  Library "user32.dll"</p> 
<p>实现代码：</p> 
<p>long  hCursor</p> 
<p>hCursor = LoadCursorFromFile(" 欲显示的 .ani 或 .cur 档案名称")</p> 
<p>SetSystemCursor(hCursor, OCR_NORMAL)</p> 
<p>//若要将鼠标游标还原原状， 则是执行以下叙述：</p> 
<p>long ll_temp</p> 
<p>ll_temp=0</p> 
<p>hCursor = LoadCursor(0, IDC_ARROW)</p> 
<p>SetSystemCursor(hCursor, OCR_NORMAL)</p> 
<p> </p> 
<p>31、如何设定屏幕分辨率　</p> 
<p>　　原则上，只改这一次，下一次开机会还原，但如果需重开机，才会Update<br>Registry中的设定，并重开机。<br>如果要永久设定其设定值，请将<br>b = ChangeDisplaySettings(DevM, 0) 改成<br>b = ChangeDisplaySettings(DevM, CDS_UPDATEREGISTRY)</p> 
<p> </p> 
<p>实现步骤：</p> 
<p>定义结构：</p> 
<p>type devmode from structure<br>string  dmdevicename<br>integer  dmspecversion<br>integer  dmdriverversion<br>integer  dmsize<br>integer  dmdriverextra<br>long  dmfields<br>integer  dmorientation<br>integer  dmpapersize<br>integer  dmpaperlength<br>integer  dmpaperwidth<br>integer  dmscale<br>integer  dmcopies<br>integer  dmdefaultsource<br>integer  dmprintquantity<br>integer  dmcolor<br>integer  dmduplex<br>integer  dmyresolution<br>integer  dmttoption<br>integer  dmcollate<br>string  dmformname<br>integer  dmunusedpadding<br>long  dmbitsperpel<br>long  dmpelswidth<br>long  dmpelsheight<br>long  dmdisplayflags<br>long  dmdisplayfrequency<br>end type</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long EnumDisplaySettings (long lpszDeviceName, long iModeNum , lpDevMode As DevMode) Library "user32.dll" Alias for "EnumDisplaySettingsA" </p> 
<p>Function long  ChangeDisplaySettings (DevMode lpDevMode , long  dwflags) Library "user32" Alias for "ChangeDisplaySettingsA" </p> 
<p>Function long  ExitWindowsEx (long uFlags , long dwReserved ) Library "user32.dll" </p> 
<p>定义实例变量：</p> 
<p>Constant long  EWX_REBOOT = 2//  注释： 重开机</p> 
<p>Constant long  CCDEVICENAME = 32</p> 
<p>Constant long  CCFORMNAME = 32</p> 
<p>Constant long  DM_BITSPERPEL = 262144</p> 
<p>Constant long  DISP_CHANGE_SUCCESSFUL = 0</p> 
<p>Constant long DISP_CHANGE_RESTART = 1</p> 
<p>Constant long  CDS_UPDATEREGISTRY = 1</p> 
<p><br>DevMode DevM</p> 
<p>w_example窗口的命令按钮cb_1.clicked:</p> 
<p>long i,b,ans,a </p> 
<p>a = EnumDisplaySettings(0, 0, DevM) //注释：Initial Setting</p> 
<p>DevM.dmFields = DM_PELSWIDTH + DM_PELSHEIGHT</p> 
<p>DevM.dmPelsWidth = 800 //  注释：设定成想要的分辨率</p> 
<p>DevM.dmPelsHeight = 600</p> 
<p>b = ChangeDisplaySettings(DevM, 0) //注释：Changed Only this time</p> 
<p>If b = DISP_CHANGE_RESTART Then</p> 
<p>   ans = MsgBox("提示","要重开机设定才能完成，重开？", question!,yesno!)</p> 
<p>   If ans = 1 Then</p> 
<p>      b = ChangeDisplaySettings(DevM, CDS_UPDATEREGISTRY)</p> 
<p>       // 注释：after this , Will Update in Registry</p> 
<p>        ExitWindowsEx(EWX_REBOOT, 0)</p> 
<p>       //  只能在win98下这样使用，在win nt以上须采用别的方法实现系统的重新启动</p> 
<p>        End If</p> 
<p>    Else<br>       If b &lt;&gt; DISP_CHANGE_SUCCESSFUL Then</p> 
<p>          MessageBox("提示","设定有误")</p> 
<p>       End If</p> 
<p>    End If<br>  <br>  </p> 
<p>32、取得Window, System, Temp所在目录 </p> 
<p>外部函数引用声明：</p> 
<p>Function uint GetWindowsDirectoryA(ref string lpBuffer,uint uSize) Library "kernel32.dll"//windows目录</p> 
<p>Function uint GetSystemDirectoryA(ref string lpBuffer,uint uSize) Library "kernel32.dll"//system目录</p> 
<p>Function ulong GetTempPathA(ulong nBufferLength,ref string lpBuffer) Library "kernel32.dll"//temp目录</p> 
<p>public function string of_get_windows ();</p> 
<p>/*函数作用:获取windows文件夹名 返回值:string    */    </p> 
<p>string ls_Buffer</p> 
<p>ulong ll_RequiredBufferSize</p> 
<p>ls_Buffer=Space(255)</p> 
<p>ll_RequiredBufferSize=GetWindowsDirectoryA(ls_Buffer,255)</p> 
<p>IF ll_RequiredBufferSize=0 or ll_RequiredBufferSize&gt;255 THEN SetNull(ls_Buffer)</p> 
<p>RETURN ls_Buffer</p> 
<p>end function</p> 
<p>public function string of_get_system ();</p> 
<p>/*函数作用:获取系统文件夹名 返回值:string    */  </p> 
<p>string ls_Buffer</p> 
<p>ulong ll_RequiredBufferSize</p> 
<p>ls_Buffer=Space(255)</p> 
<p>ll_RequiredBufferSize=GetSystemDirectoryA(ls_Buffer,255)</p> 
<p>IF ll_RequiredBufferSize=0 or ll_RequiredBufferSize&gt;255 THEN SetNull(ls_Buffer)</p> 
<p>RETURN ls_Buffer</p> 
<p>end function</p> 
<p>public function string of_get_temp ();</p> 
<p>/*函数作用:获取系统临时文件夹名 返回值:string    */ </p> 
<p>ulong nBufferLength=255</p> 
<p>string lpBuffer</p> 
<p>lpbuffer=fill(' ',255)</p> 
<p>GetTempPath(nBufferLength,lpBuffer)</p> 
<p>return lpbuffer</p> 
<p>end function<br>  <br>  </p> 
<p>33、创建不规则窗体</p> 
<p>实现步骤：</p> 
<p>定义结构</p> 
<p>Type POINTAPI from structure</p> 
<p>long x</p> 
<p>long y</p> 
<p>End Type</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long CreatePolygonRgn (Pointapi lpPoint , long nCount , long nPolyFillMode) Library "gdi32.dll"</p> 
<p>Function long SetWindowRgn (long hWnd , long hRgn, boolean bRedraw )  Lib "user32.dll"</p> 
<p>定义实例变量：</p> 
<p>Pointapi XYPOINT[]   </p> 
<p>窗口w_example的命令按钮cb_1.clicked:</p> 
<p>//定义区域句柄</p> 
<p>long  hRgn,lRes</p> 
<p>//确定T型顶点坐标的值</p> 
<p>XYPOINT[1].X = 0</p> 
<p>XYPOINT[1]Y = 0</p> 
<p>XYPOINT[2].X =unitstopixels(parant.width,xunitstopixels!)</p> 
<p>XYPOINT[2].Y = 0</p> 
<p>XYPOINT[3].X = unitstopixels(parant.width,xunitstopixels!)</p> 
<p>XYPOINT[3].Y =unitstopixels(parant.height/2,yunitstopixels!)</p> 
<p>XYPOINT[4].X = unitstopixels(parant.width,xunitstopixels!) - unitstopixels(parant.width,xunitstopixels!)/3</p> 
<p>XYPOINT[4].Y = unitstopixels(parant.height/2,yunitstopixels!)</p> 
<p>XYPOINT[5].X =  unitstopixels(parant.width,xunitstopixels!) - unitstopixels(parant.width,xunitstopixels!)/3</p> 
<p>XYPOINT[5].Y =  unitstopixels(parant.height,yunitstopixels!) </p> 
<p>XYPOINT[6].X = unitstopixels(parant.width,xunitstopixels!) /3</p> 
<p>XYPOINT[6].Y = unitstopixels(parant.height,yunitstopixels!)</p> 
<p>XYPOINT[7].X = unitstopixels(parant.width,xunitstopixels!) /3</p> 
<p>XYPOINT[7].Y =  unitstopixels(parant.width,yunitstopixels!) /2</p> 
<p>XYPOINT[8].X = 0</p> 
<p>XYPOINT[8].Y =  unitstopixels(parant.height,yunitstopixels!) /2</p> 
<p>hRgn = CreatePolygonRgn(XYPOINT[1], 8, 1)</p> 
<p>lRes = SetWindowRgn(handle(this), hRgn, True)<br>  <br> </p> 
<p>34、获取指定的驱动器的卷标名称</p> 
<p>外部函数引用声明：<br>Function boolean GetVolumeInformationA(string lpRootPathName,ref string lpVolumeNameBuffer,ulong nVolumeNameSize,ref ulong lpVolumeSerialNumber,ref ulong lpMaximumComponentLength,ref ulong lpFileSystemFlags,ref string lpFileSystemNameBuffer,ulong nFileSystemNameSize) LIBRARY "kernel32.dll"</p> 
<p>public function string of_get_drive_volumename (string as_drive);/*函数作用:获取指定的驱动器的卷标名称<br>  参数:as_drive string 驱动器名<br>  返回值:string   */  <br>string ls_VolumeNameBuffer<br>ulong ll_VolumeSerialNumber<br>ulong ll_MaximumComponentLength<br>ulong ll_FileSystemFlags<br>string ls_FileSystemNameBuffer<br>as_drive=Left(as_drive,1)+":"<br>ls_VolumeNameBuffer=Space(20)<br>ls_FileSystemNameBuffer=Space(20)<br>IF not GetVolumeInformationA(as_drive,ls_VolumeNameBuffer,20,ll_VolumeSerialNumber,ll_MaximumComponentLength,ll_FileSystemFlags,ls_FileSystemNameBuffer,20) THEN<br>SetNull(ls_VolumeNameBuffer)<br>END IF<br>RETURN ls_VolumeNameBuffer<br>end function<br>  </p> 
<p>  </p> 
<p>35、检测声卡和音量设置</p> 
<p>实现步骤： </p> 
<p>定义实例变量：</p> 
<p>Constant long  HIGHEST_VOLUME_SETTING = 100 </p> 
<p>Constant long  AUX_MAPPER = -1</p> 
<p>Constant long  MAXPNAMELEN = 32</p> 
<p>Constant long AUXCAPS_CDAUDIO = 1 </p> 
<p>Constant long AUXCAPS_AUXIN = 2</p> 
<p>Constant long  AUXCAPS_VOLUME = 1</p> 
<p>constant long  AUXCAPS_LRVOLUME =2</p> 
<p>Constant long  MMSYSERR_NOERROR = 0</p> 
<p>Constant long MMSYSERR_BASE = 0</p> 
<p>Constant long  MMSYSERR_BADDEVICEID = 2</p> 
<p>定义结构</p> 
<p>Type AUXCAPS from structure</p> 
<p>       integer wMid</p> 
<p>       integer wPid </p> 
<p>       long vDriverVersion </p> 
<p>       string szPname </p> 
<p>       integer wTechnology</p> 
<p>       long  dwSupport </p> 
<p>End Type</p> 
<p>Type VolumeSetting from structure</p> 
<p>     integer LeftVol</p> 
<p>     integer RightVol</p> 
<p>End Type</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long auxGetNumDevs() Library "winmm.dll" </p> 
<p>Function long auxGetDevCaps (long uDeviceID, AUXCAPS lpCaps, long uSize)  Library "winmm.dll" Alias for "auxGetDevCapsA"</p> 
<p>Function long auxSetVolume(long uDeviceID , long dwVolume)  Library "winmm.dll" </p> 
<p>Function long auxGetVolume (long uDeviceID, ref VolumeSetting lpdwVolume) Library "winmm.dll" </p> 
<p>Subroutine CopyMemory  (VolumeSetting hpvDest ,VolumeSetting  hpvSource, long cbCopy)Library "kernel32.dll" Alias for "RtlMoveMemory"</p> 
<p>定义窗口级函数:</p> 
<p>Function integer wf_nSigned(long lUnsignedInt ) </p> 
<p>    integer nReturnVal </p> 
<p>    If lUnsignedInt &gt; 65535 Or lUnsignedInt &lt; 0 Then</p> 
<p>        Messagebox("error", "Error in conversion from Unsigned to nSigned Integer")</p> 
<p>         return 0</p> 
<p>    End If</p> 
<p>    If lUnsignedInt &gt; 32767 Then</p> 
<p>        nReturnVal = lUnsignedInt - 65536</p> 
<p>    Else</p> 
<p>        nReturnVal = lUnsignedInt</p> 
<p>    End If</p> 
<p>    return nRetrunVal</p> 
<p><br>Function long wf_lUnsigned(integer nSignedInt ) </p> 
<p>   long  lReturnVal</p> 
<p>    If nSignedInt &lt; 0 Then</p> 
<p>        lReturnVal = nSignedInt + 65536</p> 
<p>    Else</p> 
<p>        lReturnVal = nSignedInt</p> 
<p>    End If<br>    If lReturnVal &gt; 65535 Or lReturnVal &lt; 0 Then</p> 
<p>       messagebox("error","Error in conversion from nSigned to Unsigned Integer")</p> 
<p>       lReturnVal = 0</p> 
<p>    End If</p> 
<p>    return lReturnVal</p> 
<p><br>Function long  lSetVolume(ref long lLeftVol , Ref long lRightVol, long lDeviceID) </p> 
<p>  long lReturnVal</p> 
<p>   VolumeSetting Volume </p> 
<p>   long lBothVolumes </p> 
<p>    Volume.LeftVol = wf_nSigned(lLeftVol * 65535 / HIGHEST_VOLUME_SETTING)</p> 
<p>    Volume.RightVol = wf_nSigned(lRightVol * 65535 / HIGHEST_VOLUME_SETTING)</p> 
<p>    //copy our Volume-variable to a long</p> 
<p>    CopyMemory (lBothVolumes, Volume.LeftVol,64)</p> 
<p>    //call the SetVolume-function</p> 
<p>    lReturnVal = auxSetVolume(lDeviceID, lBothVolumes)</p> 
<p>   return lReturnVal</p> 
<p>窗口w_example的open事件：</p> 
<p>    VolumeSetting Volume, </p> 
<p>    long Cnt </p> 
<p>    AUXCAPS AC   //set the output to a persistent graphic</p> 
<p>    this.setredraw(false)</p> 
<p>    //loop through all the devices</p> 
<p>    For Cnt = 0 To auxGetNumDevs - 1 //auxGetNumDevs is zero-based</p> 
<p>        //get the volume</p> 
<p>        auxGetVolume(Cnt, Volume)</p> 
<p>        //get the device capabilities</p> 
<p>        auxGetDevCaps(Cnt, AC, 1024)</p> 
<p>        //print the name on the form</p> 
<p>        st_1.text=st_1.text+"Device #" + String(Cnt + 1) + ":  " + AC.szPname</p> 
<p>        //print the left- and right volume on the form</p> 
<p>        st_1.text=st_1.text+ "Left volume:" + String(HIGHEST_VOLUME_SETTING * lUnsigned(Volume.LeftVol) / 65535)</p> 
<p>        st_1.text=st_1.text+ "Right volume:" + String(HIGHEST_VOLUME_SETTING * lUnsigned(Volume.RightVol) / 65535)</p> 
<p>        //set the left- and right-volume to 50%</p> 
<p>        lSetVolume(50, 50, Cnt)</p> 
<p>        messagebox("clue","Both volumes now set to 50%")</p> 
<p>   Next<br>  <br> </p> 
<p>36、获取网卡的MAC地址</p> 
<p>实现步骤：</p> 
<p>定义结构：</p> 
<p>type str_ipaddrrow from structure<br>long  addr<br>long  interface<br>long  m<br>long  b<br>long  as<br>integer  u1<br>integer  u2<br>end type</p> 
<p>type str_ipaddrtable from structure<br>long  numentries<br>str_ipaddrrow  table[6]<br>end type</p> 
<p>type str_ipnetrow from structure<br>long  index<br>long  physaddrlen<br>character  bphysaddr[8]<br>long  addr<br>long  iptype<br>end type</p> 
<p>type str_ipnettable from structure<br>long  numentries<br>str_ipnetrow  table[255]<br>end type</p> 
<p>type str_ipnettable1 from structure<br>long  numentries<br>long  asd<br>end type</p> 
<p>type str_mac from structure<br>character  mac[8]<br>end type</p> 
<p>定义外部函数引用声明：</p> 
<p>FUNCTION long gethostbyaddr(ref long addr, long addr_len,long addr_type) LIBRARY "ws2_32.dll"<br>SUBROUTINE RtlMoveMemoryString(ref string hpvDest,long hpvSource,long cbCopy) LIBRARY "kernel32.dll" ALIAS FOR "RtlMoveMemory"</p> 
<p>FUNCTION long GetIpAddrTable(ref str_ipaddrtable llll, ref long addr_len,boolean ip_sort) LIBRARY "iphlpapi.dll"<br>FUNCTION LONG inet_addr( ref string cp ) LIBRARY "ws2_32.dll"<br>FUNCTION LONG GetIpNetTable(ref str_ipnettable llll, ref long addr_len,boolean ip_sort) LIBRARY "iphlpapi.dll"<br>FUNCTION LONG DeleteIpNetEntry(ref str_ipnetrow ip) LIBRARY "iphlpapi.dll"<br>FUNCTION LONG FlushIpNetTable(long ip) LIBRARY "iphlpapi.dll"<br>FUNCTION LONG SendARP(long ip, long ipsur ,ref str_mac str, ref long len) LIBRARY "iphlpapi.dll"</p> 
<p>实现函数：</p> 
<p>public function string uf_getmac (string as_ip);str_ipnettable lstr_table //ARP表<br>long ll_buffer     //缓冲区大小<br>boolean lb_type     // 排序<br>str_mac lstr_mac<br>long ll_len<br>long ll_type, ll_inetaddr, ll_row<br>string ls_ip, ls_mac</p> 
<p>ls_ip = TRIM(as_ip)<br>ll_inetaddr = inet_addr(ls_ip)<br>lb_type = false<br>ll_type = GetIpNetTable(lstr_table, ll_buffer, lb_type) //第一次得到缓冲区大小<br>ll_type = GetIpNetTable(lstr_table, ll_buffer, lb_type)</p> 
<p>if ll_type=0 then //ARP表中有ip地址<br>  for ll_row=1 to lstr_table.numentries<br>  if lstr_table.table[ll_row].addr = ll_inetaddr then <br>   //找到所指定的ip删除<br>   ll_type = DeleteIpNetEntry(lstr_table.table[ll_row])<br>  end if<br>next<br>end if</p> 
<p>ll_len = 8<br>ll_type = SendARP(ll_inetaddr, 0, lstr_mac, ll_len)</p> 
<p>if ll_type &lt;&gt;0 then return '12345' //没有找到</p> 
<p>for ll_row =1 to 6<br>ls_mac += string(asc(lstr_mac.mac[ll_row]))<br>next </p> 
<p>Return left(ls_mac,len(ls_mac)-1)<br>  <br> <br>  </p> 
<p>37、调用系统的“运行程序“对话框、”查找文件“对话框、更改与文件相关联的图标对话框</p> 
<p>实现步骤：</p> 
<p>定义结构：</p> 
<p>Type BrowseInfo from structure</p> 
<p>    long  hwndOwner</p> 
<p>    long Root </p> 
<p>    long splayName</p> 
<p>    long itle</p> 
<p>    long  ulFlags </p> 
<p>    long  lpfnCallback </p> 
<p>    long lParam </p> 
<p>    long iImage </p> 
<p>End Type</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long SHObjectProperties (long hwndOwner ,long uFlags , string lpstrName, string lpstrPar)Library "Shell32.dll" <br>Subroutine CoTaskMemFree (long hMem ) Library "ole32.dll"</p> 
<p>Function long SHBrowseForFolder  (Browseinfo lpbi) Library "Shell32.dll"</p> 
<p>Function long SHFindFiles (long pIDLRoot ,long pidlSavedSearch) Library "Shell32.dll"</p> 
<p>Function long GetFileNameFromBrowse  ( long hwndOwner,string lpstrFile, long nMaxFile , string lpstrInitDir, string lpstrDefExt , string lpstrFilter, string lpstrTitle ) Library "Shell32.dll" </p> 
<p>Subroutine  PickIconDlg (long hwndOwner , string  lpstrFile, long nMaxFile, long lpdwIconIndex )Library "Shell32.dll" </p> 
<p>Function long SHRunFileDlg (long hOwner , long hIcon ,string lpstrDirectory ,string szTitle , string szPrompt, long uFlags)  Library "Shell32.dll" </p> 
<p>定义实例变量：</p> 
<p>Constant long  BIF_RETURNONLYFSDIRS = 1</p> 
<p>Constant long MAX_PATH = 260</p> 
<p>实现代码：</p> 
<p>w_example.cb_1.clicked://运行程序示例</p> 
<p>SHRunFileDlg (handle(parent), handle(parent.Icon), "c:/windows", "运行程序演示",  "在文本框中输入程序名或按浏览键查找程序", 0)//handle(parent.icon)这个须是一个icon图标的句柄</p> 
<p>w_example.cb_2.clicked://更改图标示例</p> 
<p>    long a</p> 
<p>    string astr <br>    <br>    astr = "c:/windows/notepad.exe"</p> 
<p>    PickIconDlg (handle(parent), astr, 1, a)</p> 
<p>w_example.cb_3.clicked://打开文件示例</p> 
<p>    string astr ,bstr     bstr = "c:/windows"</p> 
<p>     GetFileNameFromBrowse(handle(parent), astr, 256, bstr, "*.txt",  "文本文件 *.txt", "Open Sample")</p> 
<p>     messagebox("提示",astr)</p> 
<p>w_example.cb_4.clicked://查找文件示例</p> 
<p>    long lpIDList  </p> 
<p>   Browseinfo udtBI</p> 
<p>   // 注释：初试化udtBI结构<br>     udtBI.hwndOwner = handle(parent)</p> 
<p>     udtbl.ulFlags = BIF_RETURNONLYFSDIRS<br>    <br>    //注释：弹出文件夹查看窗口</p> 
<p>    lpIDList = SHBrowseForFolder(udtBI)<br>     <br>    If lpIDList Then</p> 
<p>     //   注释：查找文件</p> 
<p>        SHFindFiles( lpIDList, 0)</p> 
<p>       CoTaskMemFree(lpIDList)</p> 
<p>    End If</p> 
<p>w_example.cb_5.clicked://显示文件属性示例</p> 
<p>    SHObjectProperties(handle(parent), 2, "c:/windows/notepad.exe", "Samples")<br>  <br> <br>  </p> 
<p>38、判断一个文件是否在IE的缓存中 </p> 
<p>当你建立一个联到网上文件的快捷方式时，你可能需要知道它是否已经被访问过，于是你就可以适当地改变链接的颜色等</p> 
<p>。这则小技巧就是告诉你如何判断一个文件是否在Internet Explorer的缓存中，以满足你的须要。</p> 
<p>实现步骤：</p> 
<p>定义实例变量：</p> 
<p>Constant long ERROR_INSUFFICIENT_BUFFER = 122</p> 
<p>Constant long  eeErrorBase = 26720</p> 
<p>Constant long FORMAT_MESSAGE_ALLOCATE_BUFFER = 256</p> 
<p>Constant long FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192</p> 
<p>Constant long FORMAT_MESSAGE_FROM_HMODULE = 2048</p> 
<p>Constant long  FORMAT_MESSAGE_FROM_STRING = 1024</p> 
<p>Constant long FORMAT_MESSAGE_FROM_SYSTEM = 4096</p> 
<p>Constant long FORMAT_MESSAGE_IGNORE_INSERTS =512</p> 
<p>Constant FORMAT_MESSAGE_MAX_WIDTH_MASK = 255</p> 
<p>定义结构：</p> 
<p>Type FILETIME from structure</p> 
<p>　 long dwLowDateTime </p> 
<p>　 long dwHighDateTime </p> 
<p>End Type</p> 
<p>Type INTERNET_CACHE_ENTRY_INFO from structure</p> 
<p>　 long dwStructSize</p> 
<p>　 string lpszSourceUrlName</p> 
<p>　 strng lpszLocalFileName </p> 
<p>　 string CacheEntryType </p> 
<p>　 long dwUseCount </p> 
<p>　 long dwHitRate </p> 
<p>　 long dwSizeLow </p> 
<p>　 long dwSizeHigh</p> 
<p>　 filetime LastModifiedTime </p> 
<p>　 filetime ExpireTIme </p> 
<p>　 filetime LastAccessTime </p> 
<p>　 filetime LastSyncTime</p> 
<p>　 long lpHeaderInfo</p> 
<p>　 long dwHeaderInfoSize</p> 
<p>　 string lpszFileExtension </p> 
<p>　 long dwReserved </p> 
<p>End Type</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long GetUrlCacheEntryInfo (string sUrlName , INTERNET_CACHE_ENTRY_INFO  lpCacheEntryInfo, long lpdwCacheEntryInfoBufferSize) Library  "wininet.dll" Alias for "GetUrlCacheEntryInfoA"</p> 
<p>Function long FormatMessage  (long dwFlags,long  lpSource, long MessageId , long dwLanguageId , string lpBuffer, long nSize ,long Arguments ) Library  "kernel32.dll" Alias for "FormatMessageA"</p> 
<p>定义窗口级函数:</p> 
<p>Function string  wf_WinAPIError(long lLastDLLError) </p> 
<p>string sBuff ,s_return</p> 
<p>long lCount</p> 
<p>// 注释：返回与LastDLLError相关的出错信息：</p> 
<p>sBuff =space(256)</p> 
<p>lCount = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM + FORMAT_MESSAGE_IGNORE_INSERTS, 　　　0, lLastDLLError, 0, sBuff, 256, 0)</p> 
<p>If lCount&gt;0 Then</p> 
<p>　　　s_return = Left(sBuff, lCount)</p> 
<p>End If</p> 
<p>return s_return</p> 
<p>Function boolean GetCacheEntryInfo(long hWnd, string lpszUrl ) </p> 
<p>long dwEntrySize=1024</p> 
<p>INTERNET_CACHE_ENTRY_INFO lpCacheEntry </p> 
<p>return GetUrlCacheEntryInfo(lpszUrl, lpCacheEntry ,dwEntrySize)) &lt;&gt; 0 </p> 
<p>窗口的w_example.cb_1.clicked：</p> 
<p>If (GetCacheEntryInfo(handle(this), sle_1.Text))=true Then</p> 
<p>　　　Messagebox("提示", "URL In Cache.")</p> 
<p>Else</p> 
<p>　　  Messagebox("提示", "URL Not In Cache.")</p> 
<p>End If<br>  <br>  </p> 
<p>39、格式化磁盘 </p> 
<p>//在Drive的参数中 "A:" = 0，类推。</p> 
<p>Constant long SHFMT_ID_DEFAULT =65535//Currently the only fmtID supported.</p> 
<p>Function long  SHFormatDrive(long hWnd , long Drive, long fmtID , long Options)  Library  "shell32.dll"</p> 
<p>w_example.cb_1.clicked:</p> 
<p>long  lret </p> 
<p>lret = SHFormatDrive(handle(parent), 0, SHFMT_ID_DEFAULT, 0)</p> 
<p>choose Case lret</p> 
<p>Case -2</p> 
<p>messagebox("提示", "磁盘格式化成功!")</p> 
<p>Case -3</p> 
<p>messagebox("提示","不能格式化只读的磁盘！")</p> 
<p>End choose <br>  <br> </p> 
<p><br>40、获取操作系统使用的语言集：</p> 
<p>Function long  GetSystemDefaultLCID () Library "kernel32.dll" </p> 
<p>例子：</p> 
<p>long LocaleID </p> 
<p>LocalID = GetSystemDefaultLCID()</p> 
<p>choose case LocalelID</p> 
<p>case 1028</p> 
<p>       messagebox("提示","中文繁体（台湾）")</p> 
<p>case 2051</p> 
<p>       messagebox("提示","中文简体（大陆）")</p> 
<p>case 1033</p> 
<p>      messagebox("提示","英文 ... ")</p> 
<p>end choose<br>  <br> <br>  </p> 
<p>41、判断是否连接internet</p> 
<p>定义外部函数引用声明：</p> 
<p>Function long InternetSetDialState(string lpszConnectoid , long dwState , long  dwReserved )  Library "wininet.dll" </p> 
<p>     <br>Function long  InternetOpen (string sAgent , long  lAccessType, string sProxyName, string sProxyBypass , long lFlags ) Library "wininet.dll" Alias for "InternetOpenA"</p> 
<p>Function long  InternetGetConnectedStateEx (ref long lpdwFlags ,string lpszConnectionName, long dwNameLen ,  long dwReserved) Library "wininet.dll" Alias for "InternetGetConnectedStateExA"</p> 
<p>定义实例变量：</p> 
<p>constant long INTERNET_CONNECTION_MODEM = 1</p> 
<p>constant long INTERNET_CONNECTION_LAN = 2</p> 
<p>constant long INTERNET_CONNECTION_PROXY = 4</p> 
<p>constant long INTERNET_RAS_INSTALLED = 16</p> 
<p>constant long INTERNET_CONNECTION_OFFLINE = 32</p> 
<p>constant long INTERNET_CONNECTION_CONFIGURED = 64</p> 
<p>long eR </p> 
<p>string sMsg</p> 
<p>string sName</p> 
<p>boolean bConnected </p> 
<p>实现代码：</p> 
<p>//InternetConnected 函数判断是否连接到Internet的函数,获得是否以及通过何中方式连接到Internet上 </p> 
<p>Function boolean  wf_InternetConnected(ref long eConnectionInfo , ref string  sConnectionName ) </p> 
<p>long dwFlags </p> 
<p>string sNameBuf </p> 
<p>long lR </p> 
<p>long iPos</p> 
<p>sNameBuf = space(513)</p> 
<p>lR = InternetGetConnectedStateEx(dwFlags, sNameBuf, 512, 0) </p> 
<p>eConnectionInfo = dwFlags </p> 
<p>iPos =pos(sNameBuf, " ") </p> 
<p>If iPos &gt; 0 Then </p> 
<p>     sConnectionName = Left(sNameBuf, iPos - 1) </p> 
<p>ElseIf Not sNameBuf =space(513) Then </p> 
<p>      sConnectionName = sNameBuf </p> 
<p>End If </p> 
<p>return lr=1<br>  <br>  <br>  <br>  <br>42、控制由Run运行的程序（简称Run程序） <br>在PB程序设计中，可以用Run()来运行一些程序。但Run程序无法与PB主程序协调 <br>工作，若用户多次调用，就会启动Run程序的多个实例，主程序退出时，Run程序 <br>依然运行。可以用如下函数使它们协调工作： <br>function Ulong FindWindowA(Ulong classname, String windowname) <br>Library "user32.dll” <br>function Long SetParent(Long childwin, Long parentwin) Library "user32.dll” <br>（1） 使Run程序只运行一个实例 <br>handle = FindWindowsA(nul,wtitle) <br>//查找Run程序是否已经运行，wtitle为Run程序的窗口标题 <br>If handle &gt; 0 Then Return <br>//若已经在运行就返回 <br>Run(“c:/luhan.chm”) <br>//否则运行Run程序 <br>（2） PB主程序退出时，Run程序也关闭 <br>Handle = FindWindowA(nul,wtitle) <br>SetParent(handle,Handle(w_main)) <br>//使Run程序窗口成为PB主程序的子窗口 <br>  <br> <br>  </p> 
<p>43、和取消映像网络驱动器 </p> 
<p>若要在程序中把远程主机的资源映像到本地驱动器，可以用如下函数： </p> 
<p>function Long WNetAddConnectionA(String path, String pwd, String drv) <br>Library “mpr.dll” </p> 
<p>如下代码可以把远程主机Alexander上的共享文件夹My Documents映像到本地的J <br>盘： </p> 
<p>WnetAddConnectionA(“// Alexander/ My Documents”,””,”J:”) //参数2 <br>为访问口令 </p> 
<p>它的作用相当于在DOS提示符下执行：Net Use J: // Alexander/ My Documents </p> 
<p>取消网络映像盘：</p> 
<p>Function long WNetCancelConnectionA(string  lpszName,long bForce) Library "mpr.dll"  </p> 
<p>String lpszName ﹐已连接資源的远端盘符或本地盘符</p> 
<p>long bForce, 如为TRUE﹐表示切断连接(即使连接的资源上正有打开的文件或作业)<br>  <br> <br>  </p> 
<p>44、如何在PB中播放音乐 </p> 
<p>PB没有提供任何多媒体函数，要播放音乐只能通过Win32 API的PlaySound来实现：</p> 
<p>function Long PlaySound(String Filename, Int Mod, Int Flags) Library "winmm.dll"</p> 
<p>参数1为wav文件名，参数2必须取0，参数3取1表示后台播放，取8表示循环播放，</p> 
<p>因此取9（=1+8）表示在后台循环播放。 </p> 
<p> </p> 
<p><br>45、如何将长文件名转换为短文件名 <br>通过GetShortPathName函数可以把上文件名转换为8.3格式，其声明为： </p> 
<p>Function Long GetShortPathNameA(String lf, ref String sf, Long buflen) Library “kernel32.dll” </p> 
<p>参数1为长文件名，参数2为保存短文件名的缓冲区，参数3为缓冲区长度。例如： </p> 
<p>GetShortPathNameA(“C:/My Document/Powerbuilder编程实践.Doc”,sf,256) / <br>//sf = Spcace(256)<br> </p> 
<p> </p> 
<p>46、如何使PB窗口总在最上层</p> 
<p>通过SetWindowPos函数吧窗口的显示层次修改为HWND_TOPMOST，就可以使指定窗口永远不会被其他窗口覆盖，该函数声明为：  </p> 
<p>Function Long SetWindowPos( long hwnd, Long ord, Long x, Long y, Long dx, Long dy, Long uflag) </p> 
<p>Library "user32.dll"</p> 
<p>参数1为要顶层显示的窗口句柄，参数2指定显示的层次，参数7为附加选项，其余参数指定窗口位置和大小，均可忽略。</p> 
<p>在窗口的Open或Activate事件中加入如下函数调用：</p> 
<p>SetWindowPos(Handle(This),-1,0,0,0,0,3) </p> 
<p>参数2取-1表示在最顶层显示窗口，取1表示在最底层显示；最后一个参数若取1，表示窗口大小保持不变，取2表示保持位置不变，因此，取3（=1+2）表示大小和位置均保持不变，取0表示将窗口的大小和位置改变为指定值。</p> 
<p>亦可调用api函数：</p> 
<p>Function long SetForegroundWindow (long  hWnd ) Lib "user32.dll" </p> 
<p>实现窗口的永远置于最顶层<br>  <br> <br>  </p> 
<p>47、复制文件</p> 
<p>PowerBuilder 提供了过时的FileCopy语句.问题是使用该函数时并不显示文件复制对话框,也就是说,当拷贝一个大文件时,用</p> 
<p>户看不到Windows的标准文件复制对话框,无法从进度条上判断当前复制的进度.那么,如何做到这一点呢?</p> 
<p>可以通过调用api函数实现这样的功能，具体步骤如下：</p> 
<p>定义结构：</p> 
<p>Type SHFILEOPSTRUCT  from structure</p> 
<p>long hWnd</p> 
<p>long wFunc </p> 
<p>string pFrom </p> 
<p>string pTo</p> 
<p>integer fFlags</p> 
<p>boolean fAnyOperationsAborted </p> 
<p>long hNameMappings </p> 
<p>string lpszProgressTitle</p> 
<p>End Type </p> 
<p>外部函数引用声明：</p> 
<p>Function long SHFileOperation ( SHFILEOPSTRUCT lpFileOp) Library "shell32.dll" Alias for "SHFileOperationA"</p> 
<p>定义实例变量：</p> 
<p>Constant long  FO_COPY = 2</p> 
<p>Constant long FOF_ALLOWUNDO =64</p> 
<p>实现函数为：<br>boolean wf_ShellCopyFile(string Source , string Dest)</p> 
<p>//函数返回值为:boolean,成功执行，返回true,未成功返回false</p> 
<p>//参数：string source为源文件</p> 
<p>//            string dest为目标文件</p> 
<p><br>boolean ib_return</p> 
<p>long  result</p> 
<p>SHFILEOPSTRUCT fileop</p> 
<p>初始化结构体</p> 
<p>fileop.hwnd = 0 </p> 
<p>fileop.wFunc = FO_COPY </p> 
<p><br>fileop.pFrom = Source </p> 
<p>fileop.pTo = Dest </p> 
<p>fileop.fFlags = FOF_ALLOWUNDO </p> 
<p>result = SHFileOperation(fileop) </p> 
<p><br>If result ＜＞ 0 Then </p> 
<p>     return false</p> 
<p>ElseIf fileop.fAnyOperationsAborted ＜＞ 0 Then </p> 
<p>     return false</p> 
<p>End If </p> 
<p>return true<br>  <br>  </p> 
<p>48、如何列出系统正在进行的程序及强行关闭该程序</p> 
<p>1、Declare四个Win32Api函数。 <br>    Function Long GetCurrentProcessId() Library "kernel32.dll" <br>    Function Long CreateToolhelp32Snapshot(Long Flags,Long ProcessId) Library "kernel32.dll" <br>    Function Integer Process32First(uLong Snapshot,ref s_Process Process) Library "kernel32.dll" <br>    Function Integer Process32Next(uLong Snapshot,ref s_Process Process) Library "kernel32.dll" <br>2、定义s_Process结构 <br>     unsignedlong structsize <br>     unsignedlong usage <br>     unsignedlong processid <br>     unsignedlong defaultheapid <br>     unsignedlong moduleid <br>     unsignedlong threads <br>     unsignedlong parentprocessid <br>     unsignedlong classbase <br>     unsignedlong flags <br>     character filename[260] <br>3、调用示例(此函数查找在系统中是否已有当前程序的复本在运行) <br>     s_Process lst_Process //进程结构 <br>     String ls_FileName[100],ls_CurExeName //最多100个进程，可改进 <br>     ulong ln_ProcessID,ln_SameCount,ln_Snapshot,ln_Circle,ln_Count <br>     ln_ProcessID = GetCurrentProcessId() //取当前进程的ID <br>     if IsNull(ln_ProcessID) or ln_ProcessID&lt;1 then return -1 //出错则返回 <br>     ln_Snapshot = CreateToolhelp32Snapshot(2,0) //在堆上创建进程快照 <br>     if (ln_Snapshot&lt;1) then return -1 //出错则返回 <br>     lst_Process.StructSize = 296 //Win32api的Process结构大小 <br>     ln_SameCount = 0 //复本数为0 <br>     if Process32First(ln_Snapshot,lst_Process)=0 then return -1 //取第一个进程失败则返回 <br>     ln_Count = 1 <br>     ls_FileName[ln_Count] = lst_Process.FileName //列举的进程名称放入数组 <br>     //如列举到的进程ID等于当前进程ID,则知道了当前进程的名称,保存 <br>     if lst_Process.ProcessID=ln_ProcessID then ls_CurExeName=lst_Process.FileName <br>     do while true //循环取列举的进程名称，放入数组 <br>     if Process32Next(ln_Snapshot,lst_Process)=0 then exit //列举完毕 <br>     ln_Count = ln_Count + 1 <br>     ls_FileName[ln_Count] = lst_Process.FileName <br>     if lst_Process.ProcessID=ln_ProcessID then ls_CurExeName=lst_Process.FileName <br>     loop <br>     for ln_Circle=1 to ln_Count //计算系统中有几个同名进程 <br>     if ls_CurExeName=ls_FileName[ln_Circle] then ln_SameCount=ln_SameCount+1 <br>     next <br>     return ln_SameCount //如当前进程无复本在运行，返回1;否则有几个在运行则返回几<br>  <br> <br> </p> 
<p>49、如何判断显示模式是大字体还是小字体</p> 
<p>一个近似的方法是使用GetDeviceCaps()获得LOGPIXELSY和LOGPIXELSX的设置，一般的每英寸96个点为小字体，而</p> 
<p>120个点为大字体。不过修改字体设置必须要重新启动计算机。</p> 
<p>微软推荐的检测大/小字体的方法（Windows 95, Windows 98, Windows Me, or Windows NT 3.51）是调用API函数</p> 
<p>GetTextMetrics()。Windows显示驱动在小字体模式下使用VGASYS.FON，而在大字体模式下使用8514SYS.FON 。</p> 
<p>下面是一个例子：</p> 
<p>定义结构：</p> 
<p>Type TEXTMETRIC  from structure</p> 
<p>      integer   tmHeight</p> 
<p>      integer  tmAscent</p> 
<p>      integer  tmDescent </p> 
<p>      integer  tmInternalLeading</p> 
<p>      integer  tmExternalLeading</p> 
<p>      integer  tmAveCharWidth </p> 
<p>      integer   tmMaxCharWidth</p> 
<p>      integer   tmWeight</p> 
<p>      string    tmItalic</p> 
<p>      string   tmUnderlined </p> 
<p>      string tmStruckOut </p> 
<p>      string  tmFirstChar </p> 
<p>      string   tmLastChar</p> 
<p>      string   tmDefaultChar</p> 
<p>      string   tmBreakChar</p> 
<p>      string tmPitchAndFamily </p> 
<p>      string  tmCharSet</p> 
<p>      integer  tmOverhang </p> 
<p>      integer  tmDigitizedAspectX</p> 
<p>      integer   tmDigitizedAspectY </p> 
<p>  End Type </p> 
<p>定义外部函数引用声明：</p> 
<p>Function long GetTextMetrics(long hdc , TEXTMETRIC lpMetrics)  Libraray "gdi32.dll" Alias for "GetTextMetricsA"  </p> 
<p>Function long GetDesktopWindow() Library "user32.dll"   </p> 
<p>Function long GetWindowDC(long hwnd)  Library "user32.dll" </p> 
<p>Function long ReleaseDC (long hwnd, long hdc)Library "user32.dll"   </p> 
<p>Function long SetMapMode (long hdc, long  nMapMode )  Library "gdi32.dll"     </p> 
<p>定义窗口级实例变量：</p> 
<p>Constant long  MM_TEXT = 1 </p> 
<p>实现函数：</p> 
<p>Function string  wf_GetFontRes() </p> 
<p>long  hdc, hwnd, PrevMapMode </p> 
<p>TEXTMETRIC tm</p> 
<p>string ls_return<br>     <br>//默认返回小字体 </p> 
<p>ls_return= "VGA" <br>     <br>//获得桌面窗口的句柄</p> 
<p>hwnd = GetDesktopWindow() </p> 
<p>//获得桌面的上下文句柄 </p> 
<p>hdc = GetWindowDC(hwnd) </p> 
<p>If hdc&lt;&gt;0 Then </p> 
<p>//设置映射方式为点阵 </p> 
<p>//PrevMapMode = SetMapMode(hdc, MM_TEXT) </p> 
<p>//获得系统字体的大小 </p> 
<p>GetTextMetrics(hdc, tm )<br>     <br>//设置映射方式回原来的值 </p> 
<p>// PrevMapMode = SetMapMode(hdc, PrevMapMode) <br>     <br>// 释放设备上下文句柄 </p> 
<p>ReleaseDC( hwnd, hdc )<br>     <br>//如果系统字体大于16个像素，则使用大字体 </p> 
<p>If tm.tmHeight &gt; 16 Then ls_return= "8514" </p> 
<p>End If </p> 
<p>return ls_return<br>  <br>  </p> 
<p>50、获取系统进程列表</p> 
<p>实现步骤：</p> 
<p>定义结构：</p> 
<p>type processentry32 from structure<br>unsignedlong  dwsize<br>unsignedlong  cntusage<br>unsignedlong  th32processid<br>unsignedlong  th32defaultheapid<br>unsignedlong  th32moduleid<br>unsignedlong  cntthreads<br>unsignedlong  th32parentprocessid<br>long  pcpriclassbase<br>unsignedlong  dwflags<br>character  szexefile[260]<br>end type</p> 
<p>type moduleentry32 from structure<br>unsignedlong  dwsize<br>unsignedlong  th32moduleid<br>unsignedlong  th32processid<br>unsignedlong  glblcntusage<br>unsignedlong  proccntusage<br>unsignedlong  modbaseaddr<br>unsignedlong  modbasesize<br>unsignedlong  hmodule<br>character  szmodule[256]<br>character  szexepath[260]<br>end type</p> 
<p>type THREADENTRY32 from structure<br>ulong  dwSize<br>ulong  cntUsage<br>ulong  th32ThreadID<br>ulong  th32OwnerProcessID<br>long  tpBasePri<br>long  tpDeltaPri<br>ulong  dwFlags<br>end type</p> 
<p>定义外部函数引用：</p> 
<p>function long CreateToolhelp32Snapshot(ulong dwFlags, ulong th32ProcessID) library "kernel32"</p> 
<p>function boolean Process32First(long hSnapshot, ref PROCESSENTRY32 lppe) library "kernel32"</p> 
<p>function boolean Process32Next(long hSnapshot, ref PROCESSENTRY32 lppe) library "kernel32"</p> 
<p>function boolean Module32First(long hSnapshot, ref MODULEENTRY32 lpme) library "kernel32"</p> 
<p>function boolean Module32Next(long hSnapshot, ref MODULEENTRY32 lpme) library "kernel32"</p> 
<p>function boolean Thread32First(ulong hSnapshot, ref THREADENTRY32 lpte) library "kernel32"</p> 
<p>function boolean Thread32Next(ulong hSnapshot, ref THREADENTRY32 lpte) library "kernel32"</p> 
<p>function boolean CloseHandle(long hObject) library "kernel32"</p> 
<p>定义窗口实例变量：</p> 
<p>constant long TH32CS_SNAPHEAPLIST = 1</p> 
<p>constant long TH32CS_SNAPPROCESS  = 2</p> 
<p>constant long TH32CS_SNAPTHREAD   = 4</p> 
<p>constant long TH32CS_SNAPMODULE   = 8</p> 
<p>实现函数：</p> 
<p>public subroutine of_getprocesslist ();long hSnapshot</p> 
<p>string ls_caption</p> 
<p>listviewitem l_tvi</p> 
<p>hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)</p> 
<p>if hSnapshot &lt;= 0 then return</p> 
<p>PROCESSENTRY32 pe</p> 
<p>pe.dwSize = 296   //sizeof(pe)</p> 
<p>Process32First(hSnapshot, pe)</p> 
<p>do while true</p> 
<p>ls_caption = string(pe.szExeFile) + "~t" + string(pe.th32ProcessID) +"~t" + string(pe.cntThreads)</p> 
<p>l_tvi.label = ls_caption</p> 
<p>l_tvi.data = long(pe.th32ProcessID )</p> 
<p>l_tvi.pictureindex = 1</p> 
<p>lv_list.AddItem(l_tvi)</p> 
<p>if not Process32Next(hSnapshot, pe) then exit</p> 
<p>loop </p> 
<p>CloseHandle(hSnapShot)</p> 
<p>end subroutine</p> 
<p> </p> 
<p>51、获取定义进程所调用的模块</p> 
<p>public subroutine of_getmodulelist (long processid);lv_module.DeleteItems()</p> 
<p>long hModuleShot</p> 
<p>listviewitem l_tvi</p> 
<p>MODULEENTRY32 me</p> 
<p>me.dwSize = 548</p> 
<p>hModuleShot = CreateToolhelp32Snapshot (TH32CS_SNAPMODULE, processid)</p> 
<p>if hModuleShot &lt;= 0 then return</p> 
<p>Module32First(hModuleShot, me)</p> 
<p>do while true</p> 
<p>l_tvi.label = me.szModule + "~t" + me.szExePath<br>     <br>l_tvi.pictureindex = 1</p> 
<p>l_tvi.data = me.hModule</p> 
<p>lv_module.AddItem(l_tvi)</p> 
<p>if not Module32Next(hModuleShot, me) then exit</p> 
<p>loop</p> 
<p>CloseHandle(hModuleShot)</p> 
<p>end subroutine<br>  <br> <br> </p> 
<p><br>52、 枚举所有窗口的入口函数</p> 
<p>实现步骤：</p> 
<p>定义窗口实例变量：</p> 
<p>Constant long GW_CHILD  = 5</p> 
<p>Constant long GW_HWNDNEXT = 2</p> 
<p>定义外部函数引用声明：</p> 
<p>function ulong GetDesktopWindow() library "user32"</p> 
<p>Function int GetClassName(ulong hWnd, ref string lpClassName, int nMaxCount) library "user32" alias for "GetClassNameA"</p> 
<p>function long GetWindowText(long hwnd, ref string lpString, long nMaxCount) library "user32" alias for "GetWindowTextA"</p> 
<p>function long IsWindowVisible(ulong hwnd) library "user32"</p> 
<p>实现代码：</p> 
<p>ulong hWnd, hTreeItem</p> 
<p>string ls_classname, ls_caption, ls_handle</p> 
<p>TreeViewItem l_tvi</p> 
<p>hWnd = GetDesktopWindow()//获取桌面窗口的句柄</p> 
<p>ls_classname = space(255)</p> 
<p>GetClassName(hWnd, ls_classname, 255)//获取桌面窗口的窗口类型</p> 
<p>//显示桌面窗口的相关信息</p> 
<p>l_tvi.label =wf_Dec2Hex(hWnd, 8) + "(Dec:" + string(hWnd) + ")" + " " + ls_classname + ' -- "桌面"'</p> 
<p>l_tvi.data = hWnd</p> 
<p>l_tvi.PictureIndex = 1</p> 
<p>l_tvi.SelectedPictureIndex = 1</p> 
<p>hTreeItem = tv_win.InsertItemLast(0, l_tvi)</p> 
<p>//调用函数wf_enumwin()显示桌面窗口所有的子窗口</p> 
<p>wf_EnumWin(hWnd, hTreeItem)</p> 
<p>tv_win.ExpandItem(hTreeItem)</p> 
<p>private subroutine wf_enumwin (unsignedlong hparentwnd, unsignedlong hparenttreeitem)</p> 
<p>function ulong GetWindow(ulong hWnd, int uCmd) library "user32"</p> 
<p>function long GetWindowText(long hwnd, ref string lpString, long nMaxCount) library "user32" alias for "GetWindowTextA"</p> 
<p>ulong hWnd, hTreeItem</p> 
<p>string ls_classname, ls_handle, ls_caption</p> 
<p>long ll_pictureindex</p> 
<p>TreeViewItem l_tvi</p> 
<p>ls_classname = space(255)</p> 
<p>ls_caption = space(255)</p> 
<p>hWnd = GetWindow(hParentWnd, GW_CHILD)//获取指定窗口的子窗口的句柄</p> 
<p>do while hWnd &gt; 0</p> 
<p>GetClassName(hWnd, ls_classname, 255)//获取窗口的类型</p> 
<p>GetWindowText(hWnd, ls_caption, 255)//获取窗口的标题栏中的文字</p> 
<p>SendMessage(hWnd, 13, 255, ls_caption)//向窗口发送消息</p> 
<p>ls_handle = wf_Dec2Hex(hWnd, 8)//转化10进制为16进制</p> 
<p>if IsWindowVisible(hWnd) &gt; 0 then//判断窗口是否为可见</p> 
<p>  ll_pictureindex = 1</p> 
<p>else</p> 
<p>  ll_pictureindex = 2</p> 
<p>end if</p> 
<p>l_tvi.label = ls_handle + "(Dec:" + string(hWnd) + ")" + " " + ls_classname + ' -- "' + ls_caption + '"'</p> 
<p>l_tvi.data = hWnd</p> 
<p>l_tvi.PictureIndex = ll_pictureindex</p> 
<p>l_tvi.SelectedPictureIndex = ll_pictureindex</p> 
<p>hTreeItem = tv_win.InsertItemLast(hParentTreeItem, l_tvi)</p> 
<p>wf_EnumWin(hWnd, hTreeItem)//递归调用函数wf_enumwin()获取该窗口的所有子窗口</p> 
<p>hWnd =GetWindow(hWnd,GW_HWNDNEXT)//获取下一个子窗口</p> 
<p>loop</p> 
<p>end subroutine</p> 
<p> </p> 
<p><br>53、使菜单项左对齐</p> 
<p>定义结构：</p> 
<p>type menuiteminfo from structure<br>long  cbsize<br>long  fmask<br>long  ftype<br>long  fstate<br>long  wid<br>long  hsubmenu<br>long  hbmpchecked<br>long  hbmpunchecked<br>long  dwitemdata<br>string  dwtypedata<br>long  cch<br>end type</p> 
<p>定义外部函数引用：</p> 
<p>FUNCTION ulong SetMenuItemInfo(ulong hMenu,ulong un,boolean bool,ref MENUITEMINFO lpcMenuItemInfo) LIBRARY "user32.dll" ALIAS FOR "SetMenuItemInfoA"</p> 
<p>FUNCTION ulong GetMenuItemInfo(ulong hMenu,ulong un,boolean b,ref MENUITEMINFO lpMenuItemInfo) LIBRARY "user32.dll" ALIAS FOR "GetMenuItemInfoA"</p> 
<p>FUNCTION ulong DrawMenuBar(ulong hwnd) LIBRARY "user32.dll"</p> 
<p>FUNCTION ulong GetMenu(ulong hwnd) LIBRARY "user32.dll"</p> 
<p>实现函数：</p> 
<p>long wf_setmenu_position(long handle,long position)</p> 
<p>/*参数long handle 窗口的的句柄</p> 
<p>long position 是菜单的左对齐的菜单项*/</p> 
<p>menuiteminfo my_menuiteminfo</p> 
<p>long return_value</p> 
<p>/*初始化结构体*/</p> 
<p>my_menuiteminfo.cbsize=44</p> 
<p>my_menuiteminfo.fmask=16</p> 
<p>my_menuiteminfo.cch=128</p> 
<p>my_menuiteminfo.dwtypedata=Space(128)</p> 
<p>/*获取菜单信息*/</p> 
<p>return_value=getmenuiteminfo(handle,position,true,my_menuiteminfo)</p> 
<p>my_menuiteminfo.ftype=16384</p> 
<p>/*设置菜单信息*/</p> 
<p>return_value=setmenuiteminfo(handle,position,true,my_menuiteminfo)</p> 
<p>/*画菜单栏*/</p> 
<p>return_value=drawmenubar(getmenu(handle))</p> 
<p>return return_value</p> 
<p> <br> <br>  </p> 
<p>54、修改窗口的样式</p> 
<p>funcation long SetWindowLongA(Uint hWindow,integer unindex,long lnewvalue) library "user32.dll"</p> 
<p>funcation long GetWindowLongA(uInt hWindow,integer unindex) library "user32.dll"</p> 
<p>以下代码为添加最小化按钮并删除（禁止）最大化按钮来修改已有窗口</p> 
<p>uInt hWindow</p> 
<p>integer GWL_STYLE=-16</p> 
<p>long WS_MAXIMIZEBOX=65536,WS_MINIMIZEDBOX=131072,LoldStyle</p> 
<p>hWindow=handle(this)</p> 
<p>LoldStyle=getwindowlonga(hwindow,GWL_STYLE)</p> 
<p>setwindowlonga(hwindow,GWL_STYLE,loldstyle+ WS_MINIMIZEDBOX- WS_MAXIMIZEBOX)</p> 
<p><br> <br>  </p> 
<p>55、捕获datawindow内的单个按键</p> 
<p>定义结构：</p> 
<p>s_win_message</p> 
<p>uint hwnd</p> 
<p>uint unmessage</p> 
<p>uint unwparam</p> 
<p>long llParm </p> 
<p>long ltime</p> 
<p>int npt</p> 
<p>定义外部函数引用声明：</p> 
<p>funcation boolean PeekMessage(ref s_win_message smsg,uint hwnd,uint unfilterfirst,uint unfilterlast,uint unremove)library "user32.dll"</p> 
<p>funcation uint GetWindow(uint hwnd,int nrelationship)library "user32.dll"</p> 
<p>实现过程：</p> 
<p>datawindow控件的自定义事件ue_dwnkey(pbm_dwnkey)</p> 
<p>uint hdatawindowcontrol,heditcontrol</p> 
<p>integer GW_CHILD=5</p> 
<p>boolean breturn</p> 
<p>s_win_message smsg</p> 
<p>hdatawindowcontrol=handle(this)</p> 
<p>heditcontrol=getwindow(hdatawindowcontrol,gw_child)</p> 
<p>breturn=peekmessage(smsg,heditcontrol,0,0,0)<br> <br> <br>  </p> 
<p>56、获取系统用户名</p> 
<p>申明API函数<br>FUNCTION ulong WNetGetUser(ref string lpName,ref string lpUserName,ref ulong lpnLength) LIBRARY "mpr.dll" ALIAS FOR "WNetGetUserA" </p> 
<p>PB脚本语言<br>string ls_name, ls_username<br>ulong ll_len<br>ll_len = 256<br>ls_username = space(ll_len)<br>setnull(ls_name)<br>WNetGetUser(ls_Name,ls_UserName,ll_Len) <br>messagebox("系统登录用户名",ls_username)<br>  <br> <br>  </p> 
<p>57、通过调用APi函数WNetGetUserName，你可以获取大数网络客户端的网络用户标识，该函数适用于Netware, Windows for Workgroups, Windows NT, Windows 95与LanManager. 对于32 位应用程序，需要使用另一个API函数:GetUserNameA(). <br>16-bit程序<br>//外部函数说明:<br>function int WNetGetUser( ref string userid, ref uint len ) library "user.exe"</p> 
<p>PowerScript脚本<br>string login_name<br>uint   lui_len<br>int    li_rc<br>string ls_temp</p> 
<p>lui_len = 255<br>ls_temp = space( 255 )<br>li_rc = WNetGetUser( ls_temp, lui_len )<br>login_name = Trim( ls_temp )</p> 
<p>32-bit程序<br>//外部函数说明<br>Function boolean GetUserNameA( ref string userID, ref ulong len ) library "ADVAPI32.DLL"</p> 
<p>Powerscript脚本<br>string  login_name<br>string  ls_temp <br>ulong   lul_value<br>boolean lb_rc</p> 
<p>lul_value = 255<br>ls_temp = Space( 255 )<br>lb_rc = GetUserNameA( ls_temp, lul_value )<br>login_name = Trim( ls_temp )<br>  </p> 
<p>  </p> 
<p>58、下面的例子给出了通过调用Novell API来获取用户名的方法： <br>1.说明下面的外部函数:</p> 
<p>function ulong NWInitialize() library "NWInfo"<br>function ulong NWGetInfo( Long Drv, Long info, ref string buffer ) Library "NWInfo"<br>2.然后定义一个函数并加入下面的程序</p> 
<p>// i_sys=1 - novell<br>string login_name<br>string ls_temp<br>integer drv,info<br>long l_ret</p> 
<p>login_name = "user_name_error"</p> 
<p>if i_sys = 1 then   // novell login name.<br>l_ret = NWInitialize()    // init the dll, check for client 32 ...<br>if l_ret  = 0  then<br>  drv = 7 // network drive g:<br>  info = 35 // typeless user name <br>  ls_temp = Space( 129 )<br>  //  get the login name for specific drive<br>  l_ret = NWGetInfo( drv, info, ls_temp )<br>  if l_ret = 0 then<br>   login_name = Trim( ls_temp )<br>  end if<br>end if   <br>end if</p> 
<p>return login_name<br>  <br> <br>  </p> 
<p>59、在应用程序中启动控制面板 </p> 
<p>在应用程序中启动控制面板，只需用ShellExecute函数打开对应的CPL文件即可，例如要在应用程序中修改Windows密码，只需打开Password.cpl文件，启动ODBC管理器只要打开ODBCCP32.CPL。</p> 
<p>函数声明：<br>Function Long ShellExecute(Long hwindow, String lpOperation, String lpFile, String lpParameters, String lpDirectory, Long nShowCmd) Library 'shell32.dll' Alias for ShellExecuteA <br>Function Long GetDesktopWindow() Library 'user32.dll' </p> 
<p>脚本如下：<br>String ls_cpl_name <br>String ls_null </p> 
<p>SetNull(ls_null) <br>ls_cpl_name = "Password.cpl" </p> 
<p>ShellExecute(GetDesktopWindow(), ls_null, 'rundll32.exe', "shell32.dll,Control_RunDLL " + ls_cpl_name + ",", ls_null, 0) <br>  <br> <br> </p> 
<p>60、因为要用连续纸打印发票和报表，在PWIN95中打印机设置处，用自定义纸张设好特定大小发票，用于打印发票。但是当打印完一张发票以后，打印机自动切纸以后，再打第二张发票时，继续重新打在第一张发票的位置上，不知如何是好？是否要在PB中用调用外部函数设置自定义纸张大小，才起作用？</p> 
<p><br>A1: I had a solution, like follows, <br>void WINAPI PrintSet(LPCTSTR PrinterName, DWORD PaperSize, DWORD Height, DWORD Width, LPDWORD ret_code, LPTSTR errortext)<br>{ <br>    DEVMODE* lv_devmode;<br>    DEVMODE* lv_devmode_2;<br>    PRINTER_INFO_2* lv_printer_info;<br>    LPTSTR lv_str, pDeviceName;<br>    HANDLE phPrinter;<br>    DWORD pcbNeeded, lv_dword;<br>    lv_printer_info = malloc( 500 );<br>    if (!OpenPrinter(PrinterName, &amp;phPrinter, NULL))<br>    {<!-- --><br>        free(lv_printer_info);<br>            *ret_code = GetLastError();<br>        lv_str = "打开打印机失败 !";<br>        strcpy(errortext, lv_str);<br>        return;<br>    }<br>    if (!GetPrinter(phPrinter, 2, lv_printer_info, 500, &amp;pcbNeeded ))<br>    {<!-- --><br>        free(lv_printer_info);<br>        *ret_code = GetLastError();<br>        ClosePrinter(phPrinter);<br>        lv_str = "无法得到打印机参数 !";<br>        strcpy(errortext, lv_str);<br>        return;<br>    }<br>    lv_devmode = lv_printer_info-&gt;pDevMode;<br>    pDeviceName = lv_devmode-&gt;dmDeviceName;<br>    lv_dword = DocumentProperties(0, phPrinter, pDeviceName, lv_devmode, 0, DM_OUT_BUFFER);<br>    if (lv_dword&lt;0)<br>    {<!-- --><br>        free(lv_printer_info);<br>        *ret_code = GetLastError();<br>        ClosePrinter(phPrinter);<br>        lv_str = "无法取得打印机参数 !";<br>        strcpy(errortext, lv_str);<br>        return;<br>    }<br>    // 修改DEVMODE结构， 设置纸张大小及其高度和宽度<br>    lv_devmode-&gt;dmFields = lv_devmode-&gt;dmFields|DM_ORIENTATION|DM_PAPERLENGTH|DM_PAPERWIDTH|DM_PAPERSIZE;<br>    lv_devmode-&gt;dmOrientation = DMORIENT_PORTRAIT ;<br>    lv_devmode-&gt;dmPaperSize = PaperSize ;<br>    lv_devmode-&gt;dmPaperLength = Height;<br>    lv_devmode-&gt;dmPaperWidth = Width;<br>    // 通过调用DOCUMENTPROPERTIES函数传会修改的DEVMODE结构，<br>    // 在调用时指定DM_IN_BUFFER|DM_OUT_BUFFER<br>    lv_devmode_2 = malloc(500);<br>    lv_dword = DocumentProperties(0, phPrinter, pDeviceName, lv_devmode_2, lv_devmode, DM_IN_BUFFER|DM_OUT_BUFFER);<br>    if (lv_dword&lt;0)<br>    {<!-- --><br>        free(lv_devmode_2);<br>        free(lv_printer_info);<br>        *ret_code = GetLastError();<br>        ClosePrinter(phPrinter);<br>        lv_str = "无法设置打印机参数 !";<br>        strcpy(errortext, lv_str);<br>        return;<br>    }<br>    if (!SetPrinter(phPrinter, 2, lv_printer_info, NULL))<br>    {<!-- --><br>        free(lv_printer_info);<br>        *ret_code = GetLastError();<br>        ClosePrinter(phPrinter);<br>        lv_str = "无法设置打印机参数 !";<br>        strcpy(errortext, lv_str);<br>        return;<br>    } <br>    free(lv_devmode_2);<br>    free(lv_printer_info);<br>    ClosePrinter(phPrinter);<br>    lv_str = "设置打印机参数成功 !";<br>    strcpy(errortext, lv_str);<br>    *ret_code = 1;<br>    return ;<br>} <br>  <br> <br>  <br>  </p> 
<p>61、禁用网络 恢复网络 程序</p> 
<p>来源：<a href="http://www.pdriver.com" rel="nofollow">www.pdriver.com</a> 作者：wzlzn</p> 
<p>private function boolean of_statechange (boolean benable, unsignedlong selecteditem, unsignedlong hdevinfo);SP_PROPCHANGE_PARAMS PropChangeParams </p> 
<p>PropChangeParams.classinstallheader.cbsize = 8</p> 
<p>SP_DEVINFO_DATA DeviceInfoData <br>DeviceInfoData.cbsize = 28 //12 + 16<br>if (SetupDiEnumDeviceInfo(hDevInfo,SelectedItem,ref DeviceInfoData) = 0) then   return FALSE</p> 
<p>    //<br>    // Set the PropChangeParams structure.<br>    //<br>  constant ULONG DIF_PROPERTYCHANGE = 18 //0x00000012<br>  constant ULONG DICS_FLAG_GLOBAL = 1 //0x00000001 <br>  constant ULONG DICS_ENABLE      = 1 //0x00000001<br>  constant ULONG DICS_DISABLE     = 2 //0x00000002</p> 
<p>    PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;<br>    PropChangeParams.Scope = DICS_FLAG_GLOBAL;<br>  if (bEnable) then<br>     PropChangeParams.StateChange = DICS_ENABLE <br>else<br>  PropChangeParams.StateChange = DICS_DISABLE <br>end if</p> 
<p>    if (SetupDiSetClassInstallParams(hDevInfo,ref DeviceInfoData,ref PropChangeParams,20/*sizeof(PropChangeParams)*/) = 0) then<br>        return FALSE<br>end if</p> 
<p>    //<br>    // Call the ClassInstaller and perform the change.<br>    //<br>    if (SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,ref DeviceInfoData) = 0) then   return TRUE</p> 
<p>    return TRUE<br>end function</p> 
<p>private function boolean of_isclassnet (guid oclassguid);//    #define MAX_NUM  50</p> 
<p>constant ULONG  REG_SZ    = 1<br>constant ULONG  STANDARD_RIGHTS_READ  = 131072 //(0x00020000L)<br>constant ULONG  KEY_QUERY_value = 1<br>constant ULONG  KEY_ENUMERATE_SUB_KEYS  =0008<br>constant ULONG  KEY_NOTIFY              = 16 //(0x0010)<br>constant ULONG  SYNCHRONIZE             = 1048576 //         (0x00100000L)<br>constant ULONG  KEY_READ                = (STANDARD_RIGHTS_READ + KEY_QUERY_value + KEY_ENUMERATE_SUB_KEYS + KEY_NOTIFY)<br>constant ULONG ERROR_SUCCESS = 0</p> 
<p>ULONG hKeyClass<br>LONG lRet<br>char ClassType[50]<br>char NetClass[50] <br>ulong dwLength ,dwType<br>dwLength = 50<br>dwType = REG_SZ<br>NetClass[1] = "N"<br>NetClass[2] = "e"<br>NetClass[3] = "t"<br>NetClass[4] = char(0) //= "Net"<br>hKeyClass = SetupDiOpenClassRegKey(oClassGuid,KEY_READ)<br>if (hKeyClass &gt; 0) then<br>lRet = RegQueryvalueEx(hKeyClass,"Class", 0, ref dwType, ref ClassType, ref dwLength)<br>   RegCloseKey(hKeyClass)</p> 
<p>   if (lRet &lt;&gt; ERROR_SUCCESS) then return FALSE</p> 
<p>   if (ClassType[1] = "N" and ClassType[2] = "e" and ClassType[3] = "t" and ClassType[4] = char(0) ) then <br>  return TRUE<br>end if<br>    return FALSE;<br>end if</p> 
<p>return false<br>end function</p> 
<p><br>public function boolean of_enablenetwork (boolean benable);LONG hDevInfo<br>SP_DEVINFO_DATA DeviceInfoData<br>ULONG  i, Status, Problem    <br>ULONG hKeyClass<br>char DeviceName[200] </p> 
<p>hDevInfo = SetupDiGetClassDevs(0,0,0, DIGCF_PRESENT + DIGCF_ALLCLASSES)<br>if (INVALID_HANDLE_value = hDevInfo) then return FALSE</p> 
<p>DeviceInfoData.cbsize = 28 //3 * 4 + 16<br>i = 0<br>DO WHILE (SetupDiEnumDeviceInfo(hDevInfo,i,REF DeviceInfoData) &lt;&gt; 0) // for (i=0;SetupDiEnumDeviceInfo(hDevInfo,i,&amp;DeviceInfoData);i++)<br>   if (of_IsClassNet(DeviceInfoData.ClassGuid)) then<br>    if ( of_statechange(bEnable,i,hDevInfo)) then<br>    end if<br>end if</p> 
<p>i++<br>LOOP<br>return FALSE</p> 
<p>end function</p> 
<p>type sp_devinfo_data from structure<br>unsignedlong  cbsize<br>guid  classguid<br>unsignedlong  devinst<br>unsignedlong  reserved<br>end type </p> 
<p>type SP_CLASSINSTALL_HEADER from structure<br>    ULONG       cbSize;<br>    ULONG InstallFunction;<br>end type</p> 
<p>type SP_PROPCHANGE_PARAMS from structure<br>    SP_CLASSINSTALL_HEADER ClassInstallHeader<br>    ulong                  StateChange;<br>    ulong                  Scope;<br>    ulong                  HwProfile;<br>end type</p> 
<p>type guid from structure<br>unsignedlong  data1<br>character  data2[2]<br>character  data3[2]<br>character  data4[8]<br>end type<br>//<br>FUNCTION LONG SetupDiGetClassDevs(ULONG ClassGuid,ULONG Enumerator,ULONG hwndParent,ULONG Flags)LIBRARY "Setupapi.DLL" ALIAS FOR SetupDiGetClassDevsA<br>//FUNCTION ULONG SetupDiEnumDeviceInfo(ULONG DeviceInfoSet,ULONG MemberIndex, ref SP_DEVINFO_DATA DeviceInfoData)LIBRARY "Setupapi.DLL"<br>/*FUNCTION ULONG SetupDiOpenClassRegKeyEx(<br>  const GUID* ClassGuid,<br>  REGSAM samDesired,<br>  DWORD Flags,<br>  PCTSTR MachineName,<br>  PVOID Reserved<br>);*/</p> 
<p>FUNCTION ULONG SetupDiOpenClassRegKey(ref GUID ClassGuid,ULONG samDesired)LIBRARY "Setupapi.DLL"<br>FUNCTION ULONG SetupDiEnumDeviceInfo(ULONG DeviceInfoSet,ULONG MemberIndex,REF SP_DEVINFO_DATA DeviceInfoData)LIBRARY "Setupapi.DLL"<br>FUNCTION ULONG SetupDiSetClassInstallParams(ULONG  DeviceInfoSet,SP_DEVINFO_DATA DeviceInfoData,ref SP_PROPCHANGE_PARAMS ClassInstallParams,ULONG ClassInstallParamsSize)LIBRARY "Setupapi.dll"  ALIAS FOR "SetupDiSetClassInstallParamsA"<br>FUNCTION ULONG SetupDiCallClassInstaller(ULONG  InstallFunction,ULONG DeviceInfoSet, SP_DEVINFO_DATA DeviceInfoData)LIBRARY "Setupapi.dll"  ALIAS FOR "SetupDiCallClassInstaller"</p> 
<p>FUNCTION LONG RegQueryvalueEx(ULONG hKey,STRING lpvalueName, ULONG lpReserved,REF ULONG lpType,REF CHAR lpData[50],REF ULONG lpcbData) LIBRARY "Advapi32.DLL"  ALIAS FOR  RegQueryvalueExA<br>FUNCTION LONG RegCloseKey(ULONG hKey)LIBRARY "Advapi32.DLL"  ALIAS FOR  RegCloseKey</p> 
<p>constant LONG  INVALID_HANDLE_value = -1 </p> 
<p>constant ULONG  DIGCF_PRESENT = 00000002<br>constant ULONG  DIGCF_ALLCLASSES = 00000004</p> 
<p> <br> <br> <br>  <br>62、修改进度条颜色源码<br>1，声明常量<br>Constant Long    WM_USER = 1024 </p> 
<p>Constant Long    PBM_SETBARCOLOR = WM_USER + 9</p> 
<p>Constant Long    CCM_FIRST = 8192</p> 
<p>Constant Long    CCM_SETBKCOLOR = CCM_FIRST + 1</p> 
<p>2，进度条CONSTRUCTOR事件：</p> 
<p>Send( Handle(This), PBM_SETBARCOLOR, 0, Rgb( 251, 230, 148 ) )<br>Send( Handle(This), CCM_SETBKCOLOR, 0, Rgb( 232, 127, 8 ) )</p> 
<p> </p> 
<p>Showing flat scrollbars in a ListView</p> 
<p>Long             ll_ExStyle<br>Constant Integer LVM_SETEXTENDEDLISTVIEWSTYLE = 4150<br>Constant Integer LVM_GETEXTENDEDLISTVIEWSTYLE = 4151<br>Constant Integer LVS_EX_FLATSB = 256</p> 
<p>ll_ExStyle = Send( Handle( this ), LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0 )</p> 
<p><br>ll_Exstyle += LVS_EX_FLATSB<br>ll_ExStyle = Send( Handle( this ), LVM_SETEXTENDEDLISTVIEWSTYLE, 0, ll_ExStyle ) <br> </p> 
<p>Autosizing columns to match widest text within a column</p> 
<p>uLong    lul_Header, lul_LvHandle<br>Integer  li_ItemCount, li_Loop<br>Constant Integer LVM_GETHEADER = 4127<br>Constant Integer LVSCW_AUTOSIZE = -1<br>Constant Integer LVSCW_AUTOSIZE_USEHEADER = -2<br>Constant Integer HDM_GETITEMCOUNT = 4608 </p> 
<p>// First get a handle to the header of the listview. You can use this</p> 
<p>// to get the number of columns within your ListView.</p> 
<p>// A ListView actually exists of two controls, a ListView and a</p> 
<p>// header control (when the ListView is in ListViewReport! mode).</p> 
<p>// Columnheaders exists within the header control.</p> 
<p>lul_LvHandle = Handle( yourListView )<br>lul_Header = Send( lul_LvHandle, LVM_GETHEADER, 0, 0 )</p> 
<p>If lul_Header &lt;= 0 Then Return</p> 
<p>// Second, get the number of columns within the listview</p> 
<p>li_ItemCount = Send( lul_Header, HDM_GETITEMCOUNT, 0, 0 )</p> 
<p>/* Third, set the columnwidth of the columns.</p> 
<p>   Indexes within ListView messages are zero-based so I start with column 0.</p> 
<p>   Using the LVM_SETCOLUMNWIDTH message with the LVSCW_AUTOSIZE_USEHEADER</p> 
<p>   value normally sizes your column to match the header width. For the</p> 
<p>   last column however, it fills the REMAINING part of your ListView */</p> 
<p>For li_Loop = 0 To li_ItemCount - 1<br>   Send( iul_lvHandle, LVM_SETCOLUMNWIDTH, li_Loop, LVSCW_AUTOSIZE_USEHEADER )<br>Next<br>  <br> <br> <br>  </p> 
<p>3、Putting a ListBox in the Toolbar</p> 
<p>Function uLong FindWindowExA( long hParent, long hChildAfter, String lpszClass, String lpszWindow ) Library "user32.dll"<br>Function uLong SetParent( uLong hChild, uLong hWnd ) Library "user32.dll"</p> 
<p>In your MDI-frame Open-script: </p> 
<p>String        ls_ClassName, ls_Null</p> 
<p>uLong        lul_Toolbar, lul_Null, lul_ListBox</p> 
<p>ListBox      llb_1 </p> 
<p>SetNull( ls_Null )</p> 
<p>SetNull( lul_Null )</p> 
<p>ls_ClassName = 'FNFIXEDBAR60'</p> 
<p>// Find handle of toolbar (for PB 7 use FNFIXEDBAR70)</p> 
<p>lul_Toolbar = FindWindowExA( Handle( this ), lul_Null, ls_Classname, ls_Null )</p> 
<p>// Create a listbox.</p> 
<p>OpenUserObject( llb_1, 'Listbox', 0, 0 )</p> 
<p>// Get handle of the listbox</p> 
<p>lul_ListBox = Handle( llb_1 )</p> 
<p>// Set toolbar to be the parent</p> 
<p>SetParent( lul_ListBox, lul_Toolbar )</p> 
<p>// Change some properties of listbox</p> 
<p>llb_1.Y = 12</p> 
<p>llb_1.X = 1000</p> 
<p>llb_1.Width = 200</p> 
<p>llb_1.Height = 61 <br>  </p> 
<p> </p> 
<p>63、枚举网络资源：</p> 
<p>type str_netresource from structure<br>ulong  dwscope<br>ulong  dwtype<br>ulong  dwdisplaytype<br>ulong  dwusage<br>ulong  lplocalname<br>ulong  lpremotename<br>ulong  lpcomment<br>ulong  lpprovider<br>end type</p> 
<p>Function ULONG WNetOpenEnum  ( ULONG dwScope ,ULONG dwType , ULONG dwUsage , str_NetResource str_NET,REF uLONG lphEnum ) LibRARY "mpr.dll"  alias for "WNetOpenEnumA"<br>  Function ULONG WNetEnumResource(uLONG  hEnum ,ref uLONG lpcCount, uLONG  lpBuffer , ref uLONG lpBufferSize ) LibRARY "mpr.dll" alias for "WNetEnumResourceA" <br>  Function ULONG WNetCloseEnum  ( LONG hEnum ) LibRARY "mpr.dll" <br>  Function ULONG GlobalAlloc  ( LONG wFlags , LONG dwBytes ) LibRARY "KERNEL32"<br>  Function ULONG GlobalFree  ( LONG hMem ) LibRARY "KERNEL32"<br>  Function ulong CopyMem (ref str_netresource hpvDest ,  ulong hpvSource , ulong cbCopy ) Library "KERNEL32" Alias  for  "RtlMoveMemory"<br>  Function ulong CopyPointer2String ( ref string NewString , ulong OldString ) Library "KERNEL32" Alias for "lstrcpyA" </p> 
<p>public subroutine wf_getnetresource (treeview tv_pass, str_netresource str_net, long ll_hand);Ulong ll_enum,ll_rc,ll_BUFF,ll_count,ll_buffsize,ll_source,ll_time<br>LONG ll_row,ll_thand<br>integer ll_level<br>WNetOpenEnum(2, 0, 0, str_net,  ll_Enum)<br>do while true <br>str_netresource str_dest <br>ll_buffsize=1000<br>ll_count=-1<br>ll_Buff = GlobalAlloc(64, ll_buffsize)<br>ll_rc = WNetEnumResource(LL_Enum,ll_count, LL_BUFF, ll_buffsize)<br>if ll_rc&lt;&gt;0 then   <br>  GlobalFree(ll_buff)   <br>  exit<br>end if<br>ll_source=ll_buff<br>for ll_time=1 to ll_count <br>  CopyMem(str_net,ll_source,32)<br>  if str_net.dwdisplaytype=6 then<br>   ll_level=0<br>  else<br>   ll_level=str_net.dwdisplaytype<br>  end if  <br>  if ll_level&lt;&gt;3 then   <br>   li_hand=tv_pass.InsertItemlast(wf_iif(ll_level&gt;0,ll_hand,0),wf_p2s(str_net.lpremotename),str_net.dwdisplaytype+str_net.dwtype - 3)  <br>   wf_getnetresource(tv_pass,str_net,li_hand) <br>  end if<br>  ll_source=ll_source+32<br>next<br>GlobalFree  ( ll_buff)  <br>loop<br>WNetCloseEnum(LL_ENUM)<br>end subroutine<br>public function any wf_iif (boolean lb_cond, any la_a, any la_b);if lb_cond then <br>return la_a<br>else<br>return la_b<br>end if<br>end function</p> 
<p>public function string wf_p2s (unsignedlong ll_p);string ls_s<br>ls_s = space(255)<br>CopyPointer2String( ls_s, ll_p)<br>return ls_s</p> 
<p>end function<br>  <br> </p> 
<p><br>64、用api 调用摄像头源码</p> 
<p>//定义变量<br>uint lhand </p> 
<p>//定义常数<br>long WM_USER=1024<br>long WM_CAP_START = WM_USER <br>long WM_CAP_STOP = WM_CAP_START + 68 <br>long WM_CAP_DRIVER_CONNECT = WM_CAP_START + 10 <br>long WM_CAP_DRIVER_DISCONNECT = WM_CAP_START + 11 <br>long WM_CAP_SAVEDIB = WM_CAP_START + 25 <br>long WM_CAP_GRAB_FRAME = WM_CAP_START + 60 <br>long WM_CAP_SEQUENCE = WM_CAP_START + 62 <br>long WM_CAP_FILE_SET_CAPTURE_FILEA = WM_CAP_START + 20 <br>long WM_CAP_SEQUENCE_NOFILE =WM_CAP_START+  63 <br>long WM_CAP_SET_OVERLAY =WM_CAP_START+  51 <br>long WM_CAP_SET_PREVIEW =WM_CAP_START+  50 <br>long WM_CAP_SET_CALLBACK_VIDEOSTREAM = WM_CAP_START +6 <br>long WM_CAP_SET_CALLBACK_ERROR=WM_CAP_START +2 <br>long WM_CAP_SET_CALLBACK_STATUSA= WM_CAP_START +3 <br>long WM_CAP_SET_CALLBACK_FRAME= WM_CAP_START +5 <br>long WM_CAP_SET_SCALE=WM_CAP_START+  53 <br>long WM_CAP_SET_PREVIEWRATE=WM_CAP_START+  52 </p> 
<p>//定义api<br>function ulong capCreateCaptureWindowA(string lpszWindowName,ulong dwStyle,long x ,long y ,long nWidth ,long nHeight ,ulong ParentWin ,long  nId ) LIBRARY 'AVICAP32.DLL' </p> 
<p>//代码<br>string lpszName<br>ulong l1<br>l1=handle(w_main)</p> 
<p>lpszName='摄像头界面...'<br>lhand=capCreateCaptureWindowA(lpszName,262144+12582912+1073741824 + 268435456 ,0,0,200,200,l1,0)<br>if lhand &lt;&gt; 0 then   <br>  send(lhand, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0, 0) <br>  send(lhand, WM_CAP_SET_CALLBACK_ERROR, 0, 0) <br>  send(lhand, WM_CAP_SET_CALLBACK_STATUSA, 0, 0) <br>  send(lhand, WM_CAP_DRIVER_CONNECT, 0, 0) <br>  send(lhand, WM_CAP_SET_SCALE, 1, 0) <br>  send(lhand, WM_CAP_SET_PREVIEWRATE, 66, 0) <br>  send(lhand, WM_CAP_SET_OVERLAY, 1, 0)<br>  send(lhand, WM_CAP_SET_PREVIEW, 1, 0) <br>end if</p> 
<p> <br> </p> 
<p>65、如何隐藏窗口的TITLE标题？</p> 
<p>1、把下列声明加到GLOBAL EXTERNAL FUNCTIONS： </p> 
<p>Function ulong SetWindowPos(ulong hwnd,ulong hWndInsertAfter,ulong x,ulong y,ulong cx,ulong cy,ulong wFlags) LIBRARY "user32.dll" </p> 
<p>Function ULong SetWindowLongA(Long hwnd, Long nIndex, Long dwNewLong) Library 'user32.dll' </p> 
<p>Function ULong GetWindowLongA(Long hwnd, Long nIndex) Library 'user32.dll' </p> 
<p>2、把下列代码加到W_FRAME窗口（即MDI窗口）的OPEN事件： </p> 
<p>long dwStyle </p> 
<p>dwStyle = GetWindowLongA(handle(this), -16) </p> 
<p>dwStyle = dwStyle - 12582912 </p> 
<p>   </p> 
<p>dwStyle = SetWindowLongA(handle(this), -16, dwStyle) </p> 
<p>SetWindowPos(handle(this), -2, 0, 0, 0, 0, 39)<br> <br> <br>  </p> 
<p>66、如何在PB中编写PING代码？ </p> 
<p>解决方案： </p> 
<p>声明外部函数： </p> 
<p>Function ulong IcmpCreateFile () Library "icmp.dll" </p> 
<p>Function long IcmpSendEcho (ulong IcmpHandle, ulong DestinationAddress, string RequestData,long RequestSize, long RequestOptions, Ref icmp_echo_reply ReplyBuffer, long ReplySize, long Timeout ) Library "icmp.dll" Alias for "IcmpSendEcho" </p> 
<p>Function long IcmpCloseHandle (ulong IcmpHandle) Library "icmp.dll" </p> 
<p>Function ulong inet_addr (string cp) Library "ws2_32.dll" Alias for "inet_addr" </p> 
<p>代码： </p> 
<p>ULong lul_address, lul_handle </p> 
<p>Long ll_rc, ll_size </p> 
<p>String ls_reply </p> 
<p>icmp_echo_reply lstr_reply </p> 
<p>lul_address = inet_addr(as_ipaddress) </p> 
<p>If lul_address &gt; 0 Then </p> 
<p>lul_handle = IcmpCreateFile() </p> 
<p>ll_size = Len(as_echomsg) </p> 
<p>ll_rc = IcmpSendEcho(lul_handle, lul_address, &amp; </p> 
<p>as_echomsg, ll_size, 0, &amp; </p> 
<p>lstr_reply, 278, 200) </p> 
<p>IcmpCloseHandle(lul_handle) </p> 
<p>If ll_rc &lt;&gt; 0 Then </p> 
<p>If lstr_reply.Status = 0 Then </p> 
<p>ls_reply = String(lstr_reply.Data) </p> 
<p>If ls_reply = as_echomsg Then </p> 
<p>Return True </p> 
<p>End If </p> 
<p>End If </p> 
<p>End If </p> 
<p>End If </p> 
<p>Return False </p> 
<p>//True 表示PING成功，反之失败<br> <br> </p> 
<p><br>67、如何调用NetMessageBufferSend发送消息？ </p> 
<p>问题描述： </p> 
<p>如何调用WINNT/2K/XP下的API函数NetMessageBufferSend模拟net send命令来发送消息？ </p> 
<p>解决方案： </p> 
<p>下面代码已测试成功，直接导入PBL即可 </p> 
<p>$PBExportHeader$w_main.srw </p> 
<p>forward </p> 
<p>global type w_main from Window </p> 
<p>end type </p> 
<p>type mle_1 from multilineedit within w_main </p> 
<p>end type </p> 
<p>type cb_1 from commandbutton within w_main </p> 
<p>end type </p> 
<p>type sle_1 from singlelineedit within w_main </p> 
<p>end type </p> 
<p>type st_2 from statictext within w_main </p> 
<p>end type </p> 
<p>type st_1 from statictext within w_main </p> 
<p>end type </p> 
<p>end forward </p> 
<p>type icmp_echo_reply from structure </p> 
<p>    unsignedlong        address </p> 
<p>    unsignedlong        status </p> 
<p>    unsignedlong        roundtriptime </p> 
<p>    unsignedlong        datasize </p> 
<p>    unsignedlong        reserved[3] </p> 
<p>    character       data[250] </p> 
<p>end type </p> 
<p>global type w_main from Window </p> 
<p>int X=1056 </p> 
<p>int Y=484 </p> 
<p>int Width=1531 </p> 
<p>int Height=1152 </p> 
<p>boolean TitleBar=true </p> 
<p>string Title="NETMESSAGESEND" </p> 
<p>long BackColor=80269524 </p> 
<p>boolean ControlMenu=true </p> 
<p>boolean MinBox=true </p> 
<p>boolean Resizable=true </p> 
<p>mle_1 mle_1 </p> 
<p>cb_1 cb_1 </p> 
<p>sle_1 sle_1 </p> 
<p>st_2 st_2 </p> 
<p>st_1 st_1 </p> 
<p>end type </p> 
<p>global w_main w_main </p> 
<p>type prototypes </p> 
<p>Function ulong NetMessageBufferSend(ulong servername, ref char msgname[],ulong fromname, ref char buf[], ulong buflen) Library "netapi32.dll" Alias for "NetMessageBufferSend" </p> 
<p>Function ulong IcmpCreateFile () Library "icmp.dll" </p> 
<p>Function long IcmpSendEcho (ulong IcmpHandle, ulong DestinationAddress, string RequestData,long RequestSize, long RequestOptions, Ref icmp_echo_reply ReplyBuffer, long ReplySize, long Timeout ) Library "icmp.dll" Alias for "IcmpSendEcho" </p> 
<p>Function long IcmpCloseHandle (ulong IcmpHandle) Library "icmp.dll" </p> 
<p>Function ulong inet_addr (string cp) Library "ws2_32.dll" Alias for "inet_addr" </p> 
<p>end prototypes </p> 
<p>type variables </p> 
<p>CONSTANT ulong NERR_Success = 0 </p> 
<p>end variables </p> 
<p>forward prototypes </p> 
<p>public subroutine wf_string_to_unicode (string as_string, ref character ac_unicode[]) </p> 
<p>public subroutine wf_string_to_unicode (string as_string, ref character ac_unicode[]) </p> 
<p>public function boolean wf_netmessagebuffersend (string as_sendto, string as_msgtext) </p> 
<p>public function boolean wf_ping (string as_ipaddress, string as_echomsg) </p> 
<p>end prototypes </p> 
<p>public subroutine wf_string_to_unicode (string as_string, ref character ac_unicode[]);Integer li_loop, li_len, li_uni </p> 
<p>li_len = Len(as_string) </p> 
<p>FOR li_loop = 1 TO li_len </p> 
<p>    li_uni = li_uni + 1 </p> 
<p>    ac_unicode[li_uni] = Mid(as_string, li_loop, 1) </p> 
<p>    li_uni = li_uni + 1 </p> 
<p>    ac_unicode[li_uni] = Char(0) </p> 
<p>NEXT </p> 
<p>li_uni = li_uni + 1 </p> 
<p>ac_unicode[li_uni] = Char(0) </p> 
<p>li_uni = li_uni + 1 </p> 
<p>ac_unicode[li_uni] = Char(0) </p> 
<p>end subroutine </p> 
<p>public function boolean wf_netmessagebuffersend (string as_sendto, string as_msgtext);Ulong lul_result, lul_buflen </p> 
<p>Char lc_msgname[],lc_msgtext[] </p> 
<p>wf_string_to_unicode(as_sendto, lc_msgname) </p> 
<p>wf_string_to_unicode(as_msgtext, lc_msgtext) </p> 
<p>lul_buflen = UpperBound(lc_msgtext) </p> 
<p>lul_result = NetMessageBufferSend(0, lc_msgname,0, lc_msgtext, lul_buflen) </p> 
<p>If lul_result = NERR_Success Then </p> 
<p>    Return True </p> 
<p>Else </p> 
<p>    Return False </p> 
<p>End If </p> 
<p>end function </p> 
<p>public function boolean wf_ping (string as_ipaddress, string as_echomsg);ULong lul_address, lul_handle </p> 
<p>Long ll_rc, ll_size </p> 
<p>String ls_reply </p> 
<p>icmp_echo_reply lstr_reply </p> 
<p>lul_address = inet_addr(as_ipaddress) </p> 
<p>If lul_address &gt; 0 Then </p> 
<p>    lul_handle = IcmpCreateFile() </p> 
<p>    ll_size = Len(as_echomsg) </p> 
<p>    ll_rc = IcmpSendEcho(lul_handle, lul_address, &amp; </p> 
<p>                        as_echomsg, ll_size, 0, &amp; </p> 
<p>                        lstr_reply, 278, 200) </p> 
<p>    IcmpCloseHandle(lul_handle) </p> 
<p>    If ll_rc &lt;&gt; 0 Then </p> 
<p>        If lstr_reply.Status = 0 Then </p> 
<p>            ls_reply = String(lstr_reply.Data) </p> 
<p>            If ls_reply = as_echomsg Then </p> 
<p>                Return True </p> 
<p>            End If </p> 
<p>        End If </p> 
<p>    End If </p> 
<p>End If </p> 
<p>Return False </p> 
<p>end function </p> 
<p>on w_main.create </p> 
<p>this.mle_1=create mle_1 </p> 
<p>this.cb_1=create cb_1 </p> 
<p>this.sle_1=create sle_1 </p> 
<p>this.st_2=create st_2 </p> 
<p>this.st_1=create st_1 </p> 
<p>this.Control[]={this.mle_1,&amp; </p> 
<p>this.cb_1,&amp; </p> 
<p>this.sle_1,&amp; </p> 
<p>this.st_2,&amp; </p> 
<p>this.st_1} </p> 
<p>end on </p> 
<p>on w_main.destroy </p> 
<p>destroy(this.mle_1) </p> 
<p>destroy(this.cb_1) </p> 
<p>destroy(this.sle_1) </p> 
<p>destroy(this.st_2) </p> 
<p>destroy(this.st_1) </p> 
<p>end on </p> 
<p>type mle_1 from multilineedit within w_main </p> 
<p>int X=27 </p> 
<p>int Y=264 </p> 
<p>int Width=1399 </p> 
<p>int Height=604 </p> 
<p>int TabOrder=20 </p> 
<p>BorderStyle BorderStyle=StyleLowered! </p> 
<p>long TextColor=33554432 </p> 
<p>int TextSize=-10 </p> 
<p>int Weight=400 </p> 
<p>string FaceName="方正姚体" </p> 
<p>FontCharSet FontCharSet=GB2312CharSet! </p> 
<p>FontPitch FontPitch=Variable! </p> 
<p>end type </p> 
<p>type cb_1 from commandbutton within w_main </p> 
<p>int X=1070 </p> 
<p>int Y=904 </p> 
<p>int Width=357 </p> 
<p>int Height=108 </p> 
<p>int TabOrder=30 </p> 
<p>string Text=" 发送(&amp;S)" </p> 
<p>int TextSize=-10 </p> 
<p>int Weight=400 </p> 
<p>string FaceName="方正姚体" </p> 
<p>FontCharSet FontCharSet=GB2312CharSet! </p> 
<p>FontPitch FontPitch=Variable! </p> 
<p>end type </p> 
<p>event clicked;if not wf_ping(trim(sle_1.text),"") then </p> 
<p>    messagebox("提示","指定目标地址不存在或不通!") </p> 
<p>    return </p> 
<p>end if </p> 
<p>if wf_NetMessageBufferSend(trim(sle_1.text),trim(mle_1.text)) then </p> 
<p>   messagebox("提示","发送成功!") </p> 
<p>else </p> 
<p>   messagebox("提示","发送失败!")   </p> 
<p>end if </p> 
<p>end event </p> 
<p>type sle_1 from singlelineedit within w_main </p> 
<p>int X=430 </p> 
<p>int Y=48 </p> 
<p>int Width=997 </p> 
<p>int Height=92 </p> 
<p>int TabOrder=10 </p> 
<p>BorderStyle BorderStyle=StyleLowered! </p> 
<p>boolean AutoHScroll=false </p> 
<p>long TextColor=33554432 </p> 
<p>int TextSize=-10 </p> 
<p>int Weight=400 </p> 
<p>string FaceName="方正姚体" </p> 
<p>FontCharSet FontCharSet=GB2312CharSet! </p> 
<p>FontPitch FontPitch=Variable! </p> 
<p>end type </p> 
<p>type st_2 from statictext within w_main </p> 
<p>int X=14 </p> 
<p>int Y=172 </p> 
<p>int Width=379 </p> 
<p>int Height=76 </p> 
<p>boolean Enabled=false </p> 
<p>string Text="发送内容：" </p> 
<p>boolean FocusRectangle=false </p> 
<p>long TextColor=33554432 </p> 
<p>long BackColor=67108864 </p> 
<p>int TextSize=-10 </p> 
<p>int Weight=400 </p> 
<p>string FaceName="方正姚体" </p> 
<p>FontCharSet FontCharSet=GB2312CharSet! </p> 
<p>FontPitch FontPitch=Variable! </p> 
<p>end type </p> 
<p>type st_1 from statictext within w_main </p> 
<p>int X=14 </p> 
<p>int Y=52 </p> 
<p>int Width=379 </p> 
<p>int Height=76 </p> 
<p>boolean Enabled=false </p> 
<p>string Text="目标地址：" </p> 
<p>boolean FocusRectangle=false </p> 
<p>long TextColor=33554432 </p> 
<p>long BackColor=67108864 </p> 
<p>int TextSize=-10 </p> 
<p>int Weight=400 </p> 
<p>string FaceName="方正姚体" </p> 
<p>FontCharSet FontCharSet=GB2312CharSet! </p> 
<p>FontPitch FontPitch=Variable! </p> 
<p>end type </p> 
<p> <br>  </p> 
<p>68、PB程序间传递字符串变量<br>我们知道可以用Send ( handle, message#, lowword, long )函数完成不同程序窗口间的消息传递，其中最后两个参数为long型，因此可以利用这两个参数来传递数字型的变量。如果想传递的是字符串呢？由于每个进程都有自己独立的内存地址和内存空间，因此不可能直接通过访问变量地址的方法得到变量。</p> 
<p>下面给出pb的方法：</p> 
<p>source程序：</p> 
<p>外部函数：</p> 
<p>Function ulong GetCurrentProcessId() LIBRARY "kernel32.dll"</p> 
<p>Function integer SndMsg(long hWnd, long uMsg, long url, &amp;<br>     ref blob info) library "user32.dll" Alias For "SendMessageA</p> 
<p>constant long PBM_CUSTOM01 = 1024</p> 
<p>程序：</p> 
<p>IF il_hTarget &lt;= 0 THEN findTarget() //找接受变量的窗口，主要用findwindow实现<br>IF il_hTarget &gt; 0 THEN<br>String ls_len<br>//组成一个要发送的字符串<br>url+= " "+info+" "+String(srctype)+" "+String(offlinetype)<br>//计算整个要发送字符的长度，并转化为长度为10的字符串<br>ls_len = String(Len(url))<br>IF Len(ls_len) &lt; 10 THEN<br>  ls_len = Space(10 - Len(ls_len))+ls_len<br>END IF<br>//转化为blob并发送<br>Blob lb_snd<br>lb_snd = Blob(ls_len+url)<br>SndMsg(il_hTarget, PBM_CUSTOM01 +9,getcurrentprocessID(),lb_snd)<br>END IF</p> 
<p>target程序：</p> 
<p>外部函数：</p> 
<p>Function ulong OpenProcess(ulong dwDesiredAccess,ulong bInheritHandle,ulong dwProcessId) LIBRARY "kernel32.dll"<br>Function ulong ReadProcessMemoryStr(ulong hProcess,long lpBaseAddress,ref string lpBuffer,ulong nSize,ref long lpNumberOfBytesWritten) LIBRARY "kernel32.dll" Alias for "ReadProcessMemory" <br>Function ulong ReadProcessMemoryBlob(ulong hProcess,long lpBaseAddress,ref blob lpBuffer,ulong nSize,ref long lpNumberOfBytesWritten) LIBRARY "kernel32.dll" Alias for "ReadProcessMemory" </p> 
<p>事件pbm_custom10:</p> 
<p>If (wparam = 0) Or (lparam = 0) THEN RETURN</p> 
<p>Long ll_null<br>SetNull(ll_null)</p> 
<p>Long processhnd<br>CONSTANT Long  PROCESS_VM_READ = 16</p> 
<p>processhnd = openprocess(PROCESS_VM_READ,0,wparam);<br>//读取发送进程的内存数据<br>String ls_size<br>Long ll_size<br>ls_size = Space(10) //数据的大小<br>ReadProcessMemoryStr(processhnd,lparam,ls_size,10,ll_null)<br>ll_size = Long(Trim(ls_size))</p> 
<p>Blob lb_data<br>lb_data = Blob(String(Space(ll_size)))</p> 
<p>ReadProcessMemoryBlob(processhnd,lparam+10,lb_data,ll_size,ll_null)</p> 
<p>string ls_data</p> 
<p>ls_data = String(lb_data) //好啦，收到礼物了</p> 
<p> <br> </p> 
<p>69、谈谈如何在图片框上输出透明文字</p> 
<p>1、声明API函数： <br>FUNCTION ulong GetDC(ulong hwnd) LIBRARY "user32.dll" <br>FUNCTION ulong SetBkMode(ulong hdc,ulong nBkMode) LIBRARY "gdi32.dll" <br>FUNCTION ulong TextOut(ulong hdc,ulong x,ulong y,ref string lpString,ulong nCount) LIBRARY "gdi32.dll" ALIAS FOR "TextOutA" <br>2、声明一窗口级实例变量： <br>//获取图片框的句柄 <br>ulong i_ulng_handle <br>3、在窗口中放入一图片框控件，名为：p_1，在constructor事件中加入以下代码： <br>i_ulng_handle=getdc(handle(this)) <br>//设置此控件的背景为透明模式 <br>setbkmode(i_ulng_handle,1) <br>4、加一按纽，text为：写字，单击事件中加入以下代码： <br>long lng_len,lng_x,lng_y <br>string str_text <br>str_text="这只是测试" <br>lng_len=len(str_text)  </p> 
<p>//使文字在图片中居中 <br>lng_x=unitstopixels((p_1.width - lng_len*40),xunitstopixels!) /2 <br>lng_y=unitstopixels(p_1.height - 40,yunitstopixels!) /2 <br>//这是必需的，不知为啥？ <br>p_1.enabled=false <br>//输出文字 <br>textout(i_ulng_handle,lng_x,lng_y,str_text,lng_len) <br>5、加一按纽，text为：抹掉，单击事件中加入以下代码： <br>p_1.enabled=true </p> 
<p> <br> </p> 
<p>70、取局域网计算机名、IP、MAC、工作组等信息 </p> 
<p>使用的API：</p> 
<p>Function boolean IsWindow (Long hwnd ) Library "user32.dll"</p> 
<p>FUNCTION ulong WinExec(ref string lpCmdLine,ulong nCmdShow) LIBRARY "kernel32.dll"</p> 
<p>       使用到的《PB扩充函数1.5》中的函数</p> 
<p>       uf_Network_Ping、uf_file_isavailable。虽然使用《PB扩充函数1.5》时需要一个mhand.dll，但是我们用到的2个函数并没有使用到mhand.dll，所以也算是没有借助第三方DLL。</p> 
<p>       检索IP等信息使用2个自建的函数：</p> 
<p>f_searchip(): </p> 
<p>string ls_ip,ls_temp</p> 
<p>//ls_temp为需要检索的ip段，格式为xxx.xxx.xxx. 如：192。168。0。</p> 
<p>ls_temp=192.168.0.</p> 
<p>for i=1 to 255</p> 
<p>       ls_ip=ls_temp + string(i)</p> 
<p>       f_searchip1(ls_ip)</p> 
<p>next</p> 
<p>f_searchip1(string ls_ip): </p> 
<p>//得到一个一个ip地址计算机信息并且插入数据窗口</p> 
<p>u_kchs        lu_kchs</p> 
<p>string        ls_temp</p> 
<p>long              ll_row,p</p> 
<p>integer        li_filenum</p> 
<p>ulong        ll_handle</p> 
<p>string        ls_pcname,ls_mac,ls_group</p> 
<p>sle_ts.text='正在检索'+as_ip</p> 
<p>//如果能ping通为有效ip</p> 
<p>if not(lu_kchs.uf_Network_Ping(as_ip)) then return</p> 
<p>//使用NBTSTAT命令取得相关信息</p> 
<p>ls_temp="nbtstat -a "+as_ip+"&gt;temp/"+as_ip</p> 
<p>li_FileNum = FileOpen("run.bat",StreamMode!, Write!, LockWrite!, Replace!)</p> 
<p>FileWrite(li_FileNum,ls_temp)</p> 
<p>FileClose(li_filenum)</p> 
<p>ls_temp='run.bat'</p> 
<p>ll_handle=WinExec(ls_temp,0)</p> 
<p>//等待DOS窗口关闭</p> 
<p>Do While isWindow(ll_handle)</p> 
<p>       Yield()</p> 
<p>Loop</p> 
<p>//等待临时文件创建成功</p> 
<p>do while not(lu_kchs.uf_file_isavailable("temp/"+as_ip))</p> 
<p>       Yield()</p> 
<p>Loop</p> 
<p>//取计算机mac,工作组等信息</p> 
<p>li_FileNum=FileOpen("temp/"+as_ip,StreamMode!,Read! )</p> 
<p>if li_FileNum&gt;0 then </p> 
<p>       FileRead(li_FileNum,ls_temp)</p> 
<p>       FileClose(li_filenum)</p> 
<p>       FileDelete("temp/"+as_ip)</p> 
<p>              </p> 
<p>       p=pos(ls_temp,'MAC Address = ')</p> 
<p>       ls_mac=mid(ls_temp,p + 14,17)</p> 
<p>              </p> 
<p>       p=pos(ls_temp,'UNIQUE      Registered')</p> 
<p>       ls_pcname=trim(mid(ls_temp,p - 21,14))</p> 
<p>              </p> 
<p>       p=pos(ls_temp,'GROUP       Registered')</p> 
<p>       ls_group=trim(mid(ls_temp,p - 21,14))</p> 
<p>       </p> 
<p>       if ls_mac='/NetBT_Tcpip_{942' then ls_mac='其他设备'</p> 
<p>       if ls_mac&lt;&gt;'其他设备' and trim(ls_mac) &lt;&gt; '' then</p> 
<p>              //因为使用DHCP动态分配IP,所以根据MAC地址来标识唯一的计算机</p> 
<p>              ll_row=dw_cx.find("mac='"+ls_mac+"'",1,dw_cx.rowcount())</p> 
<p>              if ll_row&gt;0 then </p> 
<p>                     //如果原来有数据则修改</p> 
<p>                     dw_cx.o b j e c t.mac[ll_row]=ls_mac</p> 
<p>                     dw_cx.o b j e c t.pcname[ll_row]=ls_pcname</p> 
<p>                     dw_cx.o b j e c t.workgroup[ll_row]=ls_group</p> 
<p>                     dw_cx.o b j e c t.ip[ll_row]=as_ip</p> 
<p>                     dw_cx.o b j e c t.online[ll_row]=1</p> 
<p>              else</p> 
<p>                     ll_row=dw_cx.insertrow(0)</p> 
<p>                     dw_cx.o b j e c t.rowid[ll_row]=0</p> 
<p>                     dw_cx.o b j e c t.mac[ll_row]=ls_mac</p> 
<p>                     dw_cx.o b j e c t.pcname[ll_row]=ls_pcname</p> 
<p>                     dw_cx.o b j e c t.workgroup[ll_row]=ls_group</p> 
<p>                     dw_cx.o b j e c t.ip[ll_row]=as_ip</p> 
<p>                     dw_cx.o b j e c t.online[ll_row]=1</p> 
<p>              end if</p> 
<p>       end if</p> 
<p>end if       <br>  </p> 
<p> </p> 
<p>71、如何在PB中实现串口编程</p> 
<p>可以使用mscomm32.ocx控件 </p> 
<p>脚本如下：</p> 
<p>String ls_data </p> 
<p>//使用COM1端口。 <br>ole_1.object.CommPort = 1 <br>//设置速率为9600,无奇偶校验，8 位数据，一个停止位。 <br>ole_1.object.Settings = "9600,N,8,1" <br>//读入整个缓冲区的数据。 <br>ole_1.object.InputLen = 0 <br>打开端口 <br>ole_1.object.PortOpen = True </p> 
<p>//发送attention命令 <br>ole_1.object.Output = "ATV1Q0" + char(13) </p> 
<p>//等待数据。 <br>Do <br>Yield() <br>//从Com端口取数据 <br>ls_data += ole_1.object.Input <br>LOOP Until(Pos(ls_data, "OK" + char(13) + char (10)) &gt; 0) </p> 
<p>//向Com端口发送数据使用Output方法 <br>ole_1.Object.Output = ls_data </p> 
<p>//关闭端口。 <br>ole_1.object.PortOpen = FALSE </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3a0ddc32841fe86e93b36e6b497130b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">twaver-flex 右键菜单和右键选中网元</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d31107b09d3b27b8a07dbead0da24a2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jstl之foreach用法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>