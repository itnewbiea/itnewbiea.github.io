<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>重做日志恢复 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="重做日志恢复" />
<meta property="og:description" content="联机重做日志大致分为两种状态：当前正在写的和当前没有写的，丢失不同状态的联机重做日志文件，其处理方式也是不一样的，下面分别介绍。
联机重做日志文件须知
查看当前数据库中联机重做日志文件的状态
SQL&gt; select group#,thread#,sequence#,members,archived,status from v$log;
GROUP# THREAD# SEQUENCE# MEMBERS ARC STATUS
---------- ---------- ---------- ---------- --- ----------------
1 1 1 1 NO CURRENT
2 1 0 1 YES UNUSED
3 1 0 1 YES UNUSED
注意视图中的status列，该列标示着联机重做日志的状态，共有6中可选值
UNUSED ---标示从未用过。一般刚刚创建或open resetlogs打开后，联机重做日志组为这一状态。
CURRENT ---表示当前的。
ACTIVE ---表示活动的。虽然不是当前状态，但也有可能正被使用或要被使用，比如crash recovery时可能存在这中联机重做日志组
CLEARING ---日志正在清空，当执行 alter database clear logfile语句时，该日志组状态为这种状态，语句执行完毕后，操作的日志组状态变为UNUSED.
INACTIVE ---不活动状态。表示改组日志中的内容已经被归档或顺利写入数据文件，该组日志可被继续重用。
CLEARING_CURRENT ---日志正在清空，但是由于清空出错，如I/O设备无法访问，导致清空工作不能顺利完成。
由上述视图可见，group 1 的联机重做日志组位当前状态，然后在查询v$logfile视图，即可看到联机重做日志组对应的文件
SQL&gt; select group#,member from v$logfile;
GROUP#
----------
MEMBER
--------------------------------------------------------------------------------" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/304862aa9198c7980624ad5aeac11785/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-24T03:01:46+08:00" />
<meta property="article:modified_time" content="2021-05-24T03:01:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">重做日志恢复</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>联机重做日志大致分为两种状态：当前正在写的和当前没有写的，丢失不同状态的联机重做日志文件，其处理方式也是不一样的，下面分别介绍。</p> 
<p> </p> 
<p> </p> 
<p>联机重做日志文件须知</p> 
<p> </p> 
<p>查看当前数据库中联机重做日志文件的状态</p> 
<p> </p> 
<p>SQL&gt; select group#,thread#,sequence#,members,archived,status from v$log;<br><br>     GROUP#    THREAD#  SEQUENCE#    MEMBERS ARC STATUS<br> ---------- ---------- ---------- ---------- --- ----------------<br>      1         1            1       1 NO     CURRENT<br>      2         1            0       1 YES UNUSED<br>      3         1            0       1 YES UNUSED</p> 
<p> </p> 
<p> </p> 
<p>注意视图中的status列，该列标示着联机重做日志的状态，共有6中可选值</p> 
<p> </p> 
<p>UNUSED  ---标示从未用过。一般刚刚创建或open resetlogs打开后，联机重做日志组为这一状态。</p> 
<p> </p> 
<p>CURRENT  ---表示当前的。</p> 
<p> </p> 
<p>ACTIVE     ---表示活动的。虽然不是当前状态，但也有可能正被使用或要被使用，比如crash recovery时可能存在这中联机重做日志组</p> 
<p> </p> 
<p>CLEARING  ---日志正在清空，当执行 alter database clear logfile语句时，该日志组状态为这种状态，语句执行完毕后，操作的日志组状态变为UNUSED.</p> 
<p> </p> 
<p>INACTIVE  ---不活动状态。表示改组日志中的内容已经被归档或顺利写入数据文件，该组日志可被继续重用。</p> 
<p> </p> 
<p>CLEARING_CURRENT ---日志正在清空，但是由于清空出错，如I/O设备无法访问，导致清空工作不能顺利完成。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>由上述视图可见，group 1 的联机重做日志组位当前状态，然后在查询v$logfile视图，即可看到联机重做日志组对应的文件</p> 
<p> </p> 
<p> </p> 
<p>SQL&gt; select group#,member from v$logfile;<br><br>     GROUP#<br> ----------<br> MEMBER<br> --------------------------------------------------------------------------------<br>      1<br> /u01/app/oracle/oradata/orcl/redo01.log<br><br>      2<br> /u01/app/oracle/oradata/orcl/redo02.log<br><br>      3<br> /u01/app/oracle/oradata/orcl/redo03.log<br><br><br> SQL&gt; </p> 
<p> </p> 
<p> </p> 
<p>group 1 对应的是/u01/app/oracle/oradata/orcl/redo01.log，就是当前的联机重做日志文件。</p> 
<p> </p> 
<p> </p> 
<p><strong>丢失非当前的联机重做日志文件</strong></p> 
<p> </p> 
<p> </p> 
<p>1：模拟文件丢失</p> 
<p> </p> 
<p>步骤：先shutdown ，在delete日志文件，在startup</p> 
<p> </p> 
<p>SQL&gt; shutdown immediate;<br> Database closed.<br> Database dismounted.<br> ORACLE instance shut down.</p> 
<p> </p> 
<p> </p> 
<p>[oracle@oracle ~]$ cd /u01/app/oracle/oradata/orcl/<br> [oracle@oracle orcl]$ ll<br> total 2008060<br> -rw-r----- 1 oracle oinstall   9748480 Dec 24 22:34 control01.ctl<br> -rw-r----- 1 oracle oinstall  52436992 Dec 24 22:34 orcl_data.dbf<br> -rw-r----- 1 oracle oinstall  52429312 Dec 24 22:34 redo01.log<br> -rw-r----- 1 oracle oinstall  52429312 Dec 24 22:07 redo02.log<br> -rw-r----- 1 oracle oinstall  52429312 Dec 24 22:07 redo03.log<br> -rw-r----- 1 oracle oinstall 629153792 Dec 24 22:34 sysaux01.dbf<br> -rw-r----- 1 oracle oinstall 734011392 Dec 24 22:34 system01.dbf<br> -rw-r----- 1 oracle oinstall  72359936 Dec 24 22:09 temp01.dbf<br> -rw-r----- 1 oracle oinstall  52436992 Dec 24 22:34 test_data.dbf<br> -rw-r----- 1 oracle oinstall 387981312 Dec 24 22:34 undotbs01.dbf<br> -rw-r----- 1 oracle oinstall   5251072 Dec 24 22:34 users01.dbf</p> 
<p><br> [oracle@oracle orcl]$ rm redo02.log</p> 
<p> </p> 
<p> </p> 
<p> SQL&gt; startup</p> 
<p>ORACLE instance started.<br><br> Total System Global Area  835104768 bytes<br> Fixed Size              2217952 bytes<br> Variable Size            528484384 bytes<br> Database Buffers       301989888 bytes<br> Redo Buffers              2412544 bytes<br> Database mounted.<br> ORA-03113: 通信通道的文件结尾<br> 进程 ID: 6762<br> 会话 ID: 1 序列号: 5<br>  </p> 
<p>2：恢复丢失的联机重做日志文件</p> 
<p> </p> 
<p>这里group 2 对应的联机重做日志文件丢失，可以通过 alter database clear logfile 命令重建日志即可，如下</p> 
<p> </p> 
<p>SQL&gt; startup<br> ORACLE instance started.<br><br> Total System Global Area  835104768 bytes<br> Fixed Size              2217952 bytes<br> Variable Size            528484384 bytes<br> Database Buffers       301989888 bytes<br> Redo Buffers              2412544 bytes<br> Database mounted.<br> ORA-03113: 通信通道的文件结尾<br> 进程 ID: 6762<br> 会话 ID: 1 序列号: 5<br><br><br> SQL&gt; conn /as sysdba</p> 
<p><br> Connected to an idle instance.<br><br> SQL&gt; startup mount;</p> 
<p><br> ORACLE instance started.<br><br> Total System Global Area  835104768 bytes<br> Fixed Size              2217952 bytes<br> Variable Size            528484384 bytes<br> Database Buffers       301989888 bytes<br> Redo Buffers              2412544 bytes<br> Database mounted.</p> 
<p><br> SQL&gt; alter database clear logfile group 2;<br><br> Database altered.<br><br> SQL&gt; alter database open;<br><br> Database altered.</p> 
<p> </p> 
<p>数据库就可以正常打开了。</p> 
<p> </p> 
<p>由上所述，对于非当前的联机重做日志文件损坏，其修复过程非常简单，并且操作安全，不会造成数据丢失。</p> 
<p> </p> 
<p> </p> 
<p><strong>丢失当前的联机重做日志文件</strong></p> 
<p> </p> 
<p>1：模拟文件丢失</p> 
<p> </p> 
<p>手动删除联机重做日志文件，如果确认是否为当前重做日志文件可以根据上面操作。</p> 
<p> </p> 
<p>注意：数据库打开状态时，丢失当前的联机重做日志文件会造成数据库崩溃，也就是数据库处于不一致的状态，为了尽可能的贴近实际，这才在关闭数据库时，采用了shutdown abort 方式关闭。</p> 
<p> </p> 
<p> </p> 
<p>操作：先shutdown abort，在delete文件，在startup</p> 
<p> </p> 
<p>SQL&gt; shutdown abort;<br> ORACLE instance shut down.</p> 
<p> </p> 
<p>SQL&gt; startup mount;<br> ORACLE instance started.<br><br> Total System Global Area  835104768 bytes<br> Fixed Size              2217952 bytes<br> Variable Size            528484384 bytes<br> Database Buffers       301989888 bytes<br> Redo Buffers              2412544 bytes<br> Database mounted.</p> 
<p> </p> 
<p>oracle@oracle orcl]$ rm redo01.log<br> [oracle@oracle orcl]$ ll<br> total 1956856<br> -rw-r----- 1 oracle oinstall   9748480 Dec 24 23:49 control01.ctl<br> -rw-r----- 1 oracle oinstall  52436992 Dec 24 23:39 orcl_data.dbf<br> -rw-r----- 1 oracle oinstall  52429312 Dec 24 23:39 redo02.log<br> -rw-r----- 1 oracle oinstall  52429312 Dec 24 23:39 redo03.log<br> -rw-r----- 1 oracle oinstall 629153792 Dec 24 23:45 sysaux01.dbf<br> -rw-r----- 1 oracle oinstall 734011392 Dec 24 23:44 system01.dbf<br> -rw-r----- 1 oracle oinstall  72359936 Dec 24 23:28 temp01.dbf<br> -rw-r----- 1 oracle oinstall  52436992 Dec 24 23:39 test_data.dbf<br> -rw-r----- 1 oracle oinstall 387981312 Dec 24 23:44 undotbs01.dbf<br> -rw-r----- 1 oracle oinstall   5251072 Dec 24 23:39 users01.dbf</p> 
<p> </p> 
<p>启动数据库</p> 
<p> </p> 
<p>SQL&gt; alter database open;</p> 
<p><br> alter database open<br> *<br> ERROR at line 1:<br> ORA-00313: 无法打开日志组 1 (用于线程 1) 的成员<br> ORA-00312: 联机日志 1 线程 1: '/u01/app/oracle/oradata/orcl/redo01.log'<br> ORA-27037: 无法获得文件状态<br> Linux-x86_64 Error: 2: No such file or directory<br> Additional information: 3</p> 
<p> </p> 
<p> </p> 
<p>修复联机重做日志文件</p> 
<p> </p> 
<p>1：尝试通过 alter database clear logfile 命令修复丢失的重做日志文件</p> 
<p> </p> 
<p>SQL&gt; alter database clear logfile group 1;              <br> alter database clear logfile group 1<br> *<br> ERROR at line 1:<br> ORA-01624: 日志 1 是紧急恢复实例 orcl (线程 1) 所必需的<br> ORA-00312: 联机日志 1 线程 1: '/u01/app/oracle/oradata/orcl/redo01.log'</p> 
<p> </p> 
<p>根据错误信息可知，丢失的重做日志文件中包含必备的重做信息，无法被clear。</p> 
<p> </p> 
<p>2：执行不完全恢复</p> 
<p> </p> 
<p>如果是归档模式下，并且有备份，建议通过备份进行不完全恢复，正常情况下只丢失当前的重做日志文件中的数据。</p> 
<p> </p> 
<p>recover database until cancel；</p> 
<p> </p> 
<p><strong>如果没有备份，就只能强制恢复了</strong>。这里我们需要修改一个隐藏的初始化参数：</p> 
<p> </p> 
<p>SQL&gt; alter system set "_allow_resetlogs_corruption"=true scope=spfile;</p> 
<p> </p> 
<p> </p> 
<p>SQL&gt; shutdown immediate;<br> ORA-01109: 数据库未打开<br><br><br> Database dismounted.<br> ORACLE instance shut down.</p> 
<p><br> SQL&gt; startup mount;<br> ORACLE instance started.<br><br> Total System Global Area  835104768 bytes<br> Fixed Size              2217952 bytes<br> Variable Size            528484384 bytes<br> Database Buffers       301989888 bytes<br> Redo Buffers              2412544 bytes<br> Database mounted.<br> SQL&gt; recover database until cancel;<br> ORA-00279: 更改 840952 (在 12/25/2013 00:20:34 生成) 对于线程 1 是必需的<br> ORA-00289: 建议:<br> /u01/app/oracle/flash_recovery_area/ORCL/archivelog/2013_12_25/o1_mf_1_1_%u_.arc<br> ORA-00280: 更改 840952 (用于线程 1) 在序列 #1 中<br><br><br> Specify log: {=suggested | filename | AUTO | CANCEL}</p> 
<p><br> cancel</p> 
<p> </p> 
<p>ORA-01547: 警告: RECOVER 成功但 OPEN RESETLOGS 将出现如下错误<br> ORA-01194: 文件 1 需要更多的恢复来保持一致性<br> ORA-01110: 数据文件 1: '/u01/app/oracle/oradata/orcl/system01.dbf'<br><br><br> ORA-01112: 未启动介质恢复<br><br><br> SQL&gt; alter database open;<br> alter database open<br> *<br> ERROR at line 1:<br> ORA-01589: 要打开数据库则必须使用 RESETLOGS 或 NORESETLOGS 选项<br><br><br> SQL&gt; alter database open resetlogs;<br><br> Database altered.<br><br> SQL&gt; conn test/test<br> Connected.<br><br> SQL&gt; select * from t1;<br><br>      ID NAME<br> ---------- --------------------<br>      1 sun<br>      1 sun<br>      1 sun<br>      1 sun<br><br> SQL&gt; </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>那么我之前添加的数据（没有切换归档），不管是提交的还是未提交的数据，都会丢失。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>注意：强烈建议，当数据库恢复成功以后，应该马上进行备份（expdp或exp）等备份方式，备份数据库，然后新建数据库，再通过imp或ipmdp方式将之前导出的二进制备份文件导入到新库。</p> 
<p> </p> 
<p> </p> 
<p>强制恢复完成以后，测试下数据库，</p> 
<p> </p> 
<p>SQL&gt; shutdown immediate;<br> Database closed.<br> Database dismounted.<br> ORACLE instance shut down.<br> SQL&gt; startup<br> ORACLE instance started.<br><br> Total System Global Area  835104768 bytes<br> Fixed Size              2217952 bytes<br> Variable Size            528484384 bytes<br> Database Buffers       301989888 bytes<br> Redo Buffers              2412544 bytes<br> Database mounted.<br> Database opened.<br> SQL&gt; </p> 
<p> </p> 
<p>如果没有问题，那么说明ok了。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/30166976/viewspace-1564826/，如需转载，请注明出处，否则将追究法律责任。</p> 
<p>转载于:http://blog.itpub.net/30166976/viewspace-1564826/</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73aaae4a67979be911363bb53e1affe3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于深拷贝的详细理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c16ee0778679eb2f41f4279a03223f13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp-省市区三级联动的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>