<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Clang 中 AST 相关类简介（不定时更新） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Clang 中 AST 相关类简介（不定时更新）" />
<meta property="og:description" content="Clang 中 AST 相关类简介（不定时更新） 1. Decl(declaration)1.1 FunctionDecl 2. Stmt(statement)3. Expr(expression)3.1 FullExpr3.2 ExprWithCleanups3.3 CallExpr 1. Decl(declaration) 它表示程序中的一个声明。
1.1 FunctionDecl 表示一个函数声明(declaration)或定义(definition)。
因为一个给定的函数可以在程序中声明多次，所以可能有几个 FunctionDecls 对应于该函数。当遍历此 FunctionDecl 上下文中的声明列表时(例如，翻译单元)，只会找到其中的一个 FunctionDecl；这个 FunctionDecl 包含关于函数的所有已知信息。另外，此函数的前置声明可以通过 getPreviousDecl() 链获得。
一个函数声明可能是：
一个非定义声明，一个定义。一个函数可能被如下定义： 它有一个 body，或者在稍后解析中将会有一个 body。它有一个未实例化(uninstantiated)的 body。此 body 不存在，因为尚未使用该函数，但是此声明被视为一个定义，并且不允许对该函数进行其他定义。它没有一个用户指定的 body，但它不允许重新定义(redefinition)，因为它是 deleted/defaulted 或通过其他机制(alias、ifunc)定义的。
它的 public 成员函数： DeclarationNameInfo getNameInfo() const
使用它来获取函数名：FunctionDecl *f; std::string funcName = f-&gt;getNameInfo().getName().getAsString(); QualType getReturnType() const
获取函数的返回类型SourceRange getSourceRange() constbool hasBody() const
如果此 Decl 表示代码体(如函数或方法定义)的声明，则返回 true。
注意，如果这个 Decl 的任何 redeclaration 表示代码体的声明，那么 hasBody 也可以返回 true。bool isDefined() const" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f04ba1fe4ecc8587f4e338dbb6c9f7fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-04T11:53:16+08:00" />
<meta property="article:modified_time" content="2019-07-04T11:53:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Clang 中 AST 相关类简介（不定时更新）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Clang 中 AST 相关类简介（不定时更新）</h4> 
 <ul><li><ul><li><ul><li><a href="#1_Decldeclaration_2" rel="nofollow">1. Decl(declaration)</a></li><li><ul><li><a href="#11_FunctionDecl_5" rel="nofollow">1.1 FunctionDecl</a></li></ul> 
    </li><li><a href="#2_Stmtstatement_40" rel="nofollow">2. Stmt(statement)</a></li><li><a href="#3_Exprexpression_59" rel="nofollow">3. Expr(expression)</a></li><li><ul><li><a href="#31_FullExpr_62" rel="nofollow">3.1 FullExpr</a></li><li><a href="#32_ExprWithCleanups_65" rel="nofollow">3.2 ExprWithCleanups</a></li><li><a href="#33_CallExpr_75" rel="nofollow">3.3 CallExpr</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1_Decldeclaration_2"></a>1. Decl(declaration)</h4> 
<p>它表示程序中的一个声明。<br> <img src="https://images2.imgbox.com/f0/2d/mCnUaylx_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="11_FunctionDecl_5"></a>1.1 FunctionDecl</h5> 
<p>表示一个函数声明(declaration)或定义(definition)。<br> 因为一个给定的函数可以在程序中声明多次，所以可能有几个 <code>FunctionDecls</code> 对应于该函数。当遍历此 <code>FunctionDecl</code> 上下文中的声明列表时(例如，翻译单元)，只会找到其中的一个 <code>FunctionDecl</code>；这个 <code>FunctionDecl</code> 包含关于函数的所有已知信息。另外，此函数的前置声明可以通过 <code>getPreviousDecl()</code> 链获得。</p> 
<p>一个函数声明可能是：</p> 
<ul><li>一个非定义声明，</li><li>一个定义。一个函数可能被如下定义： 
  <ul><li>它有一个 body，或者在稍后解析中将会有一个 body。</li><li>它有一个未实例化(uninstantiated)的 body。此 body 不存在，因为尚未使用该函数，但是此声明被视为一个定义，并且不允许对该函数进行其他定义。</li><li>它没有一个用户指定的 body，但它不允许重新定义(redefinition)，因为它是 deleted/defaulted 或通过其他机制(alias、ifunc)定义的。<br> <img src="https://images2.imgbox.com/6f/3c/GvKlrzv2_o.png" alt="在这里插入图片描述"><br> 它的 public 成员函数：</li></ul> </li><li><strong>DeclarationNameInfo getNameInfo() const</strong><br> 使用它来获取函数名：<pre><code class="prism language-cpp">FunctionDecl <span class="token operator">*</span>f<span class="token punctuation">;</span>
std<span class="token operator">::</span>string funcName <span class="token operator">=</span> f<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">getNameInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li><strong>QualType getReturnType() const</strong><br> 获取函数的返回类型</li><li><strong>SourceRange getSourceRange() const</strong></li><li><strong>bool hasBody() const</strong><br> 如果此 Decl 表示代码体(如函数或方法定义)的声明，则返回 true。<br> 注意，如果这个 Decl 的任何 redeclaration 表示代码体的声明，那么 hasBody 也可以返回 true。</li><li><strong>bool isDefined() const</strong><br> 如果函数的有一个不需要被实例化(instantiate)的定义，则返回true。</li><li><strong>函数的参数遍历</strong><pre><code class="prism language-cpp">FunctionDecl <span class="token operator">*</span>f<span class="token punctuation">;</span>
Rewriter rw<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>FunctionDecl<span class="token operator">::</span>param_iterator start <span class="token operator">=</span> f<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">param_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> f<span class="token operator">-</span><span class="token operator">&gt;</span><span class="token function">param_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> start<span class="token operator">!=</span>end<span class="token punctuation">;</span> start<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token comment">// 输出代码中的形式参数</span>
  llvm<span class="token operator">::</span><span class="token function">errs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> rw<span class="token punctuation">.</span><span class="token function">getRewrittenText</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>start<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSourceRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h4><a id="2_Stmtstatement_40"></a>2. Stmt(statement)</h4> 
<p>这个类表示程序中的一个语句。语句是程序的基本构建块，一个语句相当于一条完整的计算机指令，大部分语句都以 <code>;</code> 结尾。包括：</p> 
<ul><li>表达式语句<br> 主要是函数调用语句（<code>printf()</code>）和赋值语句（<code>value = expression;</code>）</li><li>语句块<br> <code>{}</code> 括起来的语句</li><li>空语句<br> 即 <code>;</code></li><li>控制语句<br> 分为循环语句（<code>for</code>、<code>while</code>）、选择/条件语句（<code>if</code>、<code>switch</code>）、特殊语句（<code>return</code>、<code>continue</code>、<code>break</code>）</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token comment">// 这是一个声明</span>
i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment">// 这是一个语句；`i = 5`是一个表达式</span>
<span class="token punctuation">{<!-- --></span>		<span class="token comment">// 这是一个复合语句</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>
  j <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e2/83/eietDsRZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_Exprexpression_59"></a>3. Expr(expression)</h4> 
<p>它表示程序中的一个表达式。表达式是由运算符和运算对象组成，运算对象可以是常量、变量或二者的结合。一些表达式由子表达式（非 <code>full-expression</code>）组成。<strong>表达式最重要的特性之一就是每个表达式都有一个值</strong>。变量、常量、函数调用本身也是一个表达式。<br> <img src="https://images2.imgbox.com/ed/2a/LiO8B5Rj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="31_FullExpr_62"></a>3.1 FullExpr</h5> 
<p>代表一个<code>“full-expression”</code>节点，完全表达式即它不是另一个表达式的子表达式。<br> <img src="https://images2.imgbox.com/92/10/8I8AvsSF_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="32_ExprWithCleanups_65"></a>3.2 ExprWithCleanups</h5> 
<p>它表示一个表达式(通常是 <code>full-expression</code>)，该表达式引入要在子表达式求值结束时运行的清理(<code>cleanup</code>)。</p> 
<p>表达式引入的清理最常见的来源是 C++ 中的临时对象(temporary objects)，但是其他几种表达式也会创建清理，包括 ARC 中返回一个 Objective-C 指针的每个调用。</p> 
<p>该表达式还跟踪子表达式是否包含一个潜在求值的 <code>block literal</code>。 一个 <code>block literal</code> 的生命周期是 <code>enclosing scope</code> 的长度(extent)。<br> <img src="https://images2.imgbox.com/06/68/9ACSVkXG_o.png" alt="在这里插入图片描述"><br> 该类的 public 成员：</p> 
<ul><li><code>using CleanupObject = BlockDecl *;</code><br> 清理中保存的对象的类型。记住一组 <code>blocks</code> 很有用；我们也可以记住一组 <code>temporaries</code>，但目前没有必要。</li></ul> 
<h5><a id="33_CallExpr_75"></a>3.3 CallExpr</h5> 
<p>它表示一个函数调用(C99 6.5.2.2, C++ [expr.call])。<code>CallExpr</code>本身表示一个普通的函数调用，例如，<code>f(x, 2)</code>。<br> 它的子类可以表示导致一个函数调用的替代语法(语义上)。例如，<code>CXXOperatorCallExpr</code>是它的一个子类，用于重载操作符调用，该子类使用操作符语法，例如 <code>str1 + str2</code> 解析为一个函数调用。<br> <img src="https://images2.imgbox.com/9b/9f/65jgr9jz_o.png" alt="在这里插入图片描述"><br> 它的 public 成员函数：</p> 
<ul><li><code>FunctionDecl *getDirectCallee();</code><br> 如果被调用方是一个 <code>FunctionDecl</code> ，则返回它。否则返回null。</li><li><code>unsigned getBuiltinCallee() const;</code><br> 如果这是对builtin的调用，返回被调用者的builtin ID。如果不是，返回0。（对于C程序可以使用它来判断调用的是否是自己编写的函数，C++中不行）</li><li><code>QualType getCallReturnType(const ASTContext &amp;Ctx) const;</code><br> 获取它的返回类型。</li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d59f530854b63dd346d0fb916cb5721/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《Programming in Lua 3》读书笔记(十七)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/de5f1a8bb2ad763c3a053c9d86f4b2a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MVC client validation step</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>