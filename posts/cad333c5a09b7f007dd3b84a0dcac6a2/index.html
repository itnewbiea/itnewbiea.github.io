<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>babel-plugin-import 的组件按需加载原理 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="babel-plugin-import 的组件按需加载原理" />
<meta property="og:description" content="对比webpack懒加载 webpack 懒加载是将源码中的 import、require 引入的文件编译之后再根据动态加载语法配置（通常以页面路由为基本单位）将较大的代码拆分并构建出较小的 chunk 包，运行时执行到相应业务逻辑时才去加载执行对应 chunk 代码。
webpack 懒加载主要发生在 JS 拆分出不同的 Chunk 这一过程中。
babel-plugin-import 按需加载是以组件为基本单位产出 js、css、less 文件，借助插件或者部分引入的写法，使得项目代码或 babel 编译后的代码中只包含使用到的组件的 js、css、less 等。
首先是执行时机不同，babel-plugin-import 按需加载是在源码编写阶段或者 babel 编译 js 阶段，而 webpack 懒加载则是在构建生成打包产物阶段。其次是原理不同，babel-plugin-import 按需加载是在源码阶段就去掉了无关代码，而 webpack 懒加载则是将经过 tree-shaking 优化过后的大文件包进行拆分在适当的运行时进行按需加载。两者并不冲突，可以一前一后共同作用。
实现原理 babel-plugin-import 按需加载目的是减少项目构建打包产物的大小，提高项目线上首屏渲染速度，减少白屏时间，减少流量消耗。
若是采用手动引入需要使用到的组件以及其对应的样式文件，那么在 webpack 构件时组件库中其他未被引入的文件不会被打包。
import Button from &#39;lib/button&#39;; import &#39;lib/lib/button/style&#39;; 若是自动引入：
npm i babel-plugin-import -D module.exports = { plugins: [ [&#39;import&#39;, { libraryName, libraryDirectory: &#39;es&#39;, style: true }, libraryName] ] }; import { Button } from libraryName; 组件其实就是对一堆 js、css 以及 less 等文件的总称，自动引入的本质是将引入组件的写法通过插件来转换成手动引入组件对应的代码以及样式文件的写法。核心原理依然是对源码的 import 导入写法进行转换——词法语法分析，AST转换，代码生成。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cad333c5a09b7f007dd3b84a0dcac6a2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T15:59:25+08:00" />
<meta property="article:modified_time" content="2022-05-30T15:59:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">babel-plugin-import 的组件按需加载原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>对比webpack懒加载</h2> 
<p><strong>webpack 懒加载</strong>是将源码中的 import、require 引入的文件编译之后再根据动态加载语法配置（通常以页面路由为基本单位）<strong>将较大的代码拆分并构建出较小的 chunk 包</strong>，运行时执行到相应业务逻辑时才去加载执行对应 chunk 代码。</p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/51/f4/e5tS8EcO_o.png" width="1200"></p> 
<p></p> 
<p>webpack 懒加载主要发生在 JS 拆分出不同的 Chunk 这一过程中。</p> 
<p><strong>babel-plugin-import 按需加载</strong>是以组件为基本单位产出 js、css、less 文件，借助插件或者部分引入的写法，使得项目代码或 babel 编译后的代码中只包含使用到的组件的 js、css、less 等。</p> 
<p>首先是执行时机不同，<strong>babel-plugin-import 按需加载</strong>是在源码编写阶段或者 babel 编译 js 阶段，而 webpack 懒加载则是在构建生成打包产物阶段。其次是原理不同，<strong>babel-plugin-import 按需加载</strong>是在源码阶段就去掉了无关代码，而 webpack 懒加载则是将经过 tree-shaking 优化过后的大文件包进行拆分在适当的运行时进行按需加载。两者并不冲突，可以一前一后共同作用。</p> 
<h2>实现原理</h2> 
<p><strong>babel-plugin-import 按需加载</strong>目的是<strong>减少项目构建打包产物的大小，提高项目线上首屏渲染速度，减少白屏时间，减少流量消耗</strong>。</p> 
<p>若是采用手动引入需要使用到的组件以及其对应的样式文件，那么在 webpack 构件时组件库中其他未被引入的文件不会被打包。</p> 
<pre><code class="language-javascript">import Button from 'lib/button';
import 'lib/lib/button/style';</code></pre> 
<p>若是自动引入：</p> 
<pre><code class="language-javascript">npm i babel-plugin-import -D

module.exports = {
  plugins: [
    ['import', {
      libraryName,
      libraryDirectory: 'es',
      style: true
    }, libraryName]
  ]
};


import { Button } from libraryName;</code></pre> 
<p>组件其实就是对一堆 js、css 以及 less 等文件的总称，自动引入的本质是将引入组件的写法通过插件来转换成手动引入组件对应的代码以及样式文件的写法。核心原理依然是对源码的 import 导入写法进行转换——词法语法分析，AST转换，代码生成。</p> 
<p>该插件主要参数：</p> 
<pre><code class="language-javascript"> "libraryName": "", // 组件库名称，对应 import 语法中的包名
  "libraryDirectory": "lib", // 编译之后各个组件单元所在文件夹名称
  "style": true, // 是否引入组件对应样式文件，也可以传入 less 来引入 less 文件
  "styleLibraryDirectory": "", // 编译之后引入的组件样式文件所在文件夹名称
  "camel2DashComponentName": false, // 是否将驼峰命名的导入变量转换为对应的横线连接命名的文件名
  "customName": (name, file) =&gt; { return `/lib/${name}` }, // 自定义编译之后引入的组件名
  "customStyleName": (name, file) =&gt; { return `/lib/css/${name}` }, // 自定义编译之后引入样式文件的名称</code></pre> 
<p>插件中使用到的钩子函数有：</p> 
<pre><code class="language-javascript">const methods = [
  'ImportDeclaration', 				// import 导入声明
  'CallExpression',				    // 函数调用
  'MemberExpression',
  'Property',
  'VariableDeclarator',
  'ArrayExpression',
  'LogicalExpression',
  'ConditionalExpression',
  'IfStatement',
  'ExpressionStatement',
  'ReturnStatement',
  'ExportDefaultDeclaration',
  'BinaryExpression',
  'NewExpression',
  'ClassDeclaration',
  'SwitchStatement',
  'SwitchCase',
];
</code></pre> 
<p> Visitor 对象上还配置了 Program 钩子，该钩子是在 babel 处理一个独立文件（或者叫做模块更合适，node 规范定义一个文件就是一个模块）时执行，其中若不按此方式具体指定则默认为 enter 钩子。</p> 
<pre><code class="language-javascript">const Program = {
  // 进入钩子
  enter(path, options) {
  	// 1. 根据插件接受到的配置参数初始化插件 Plugin 数组
    // 2. 遍历插件 Plugin 数组，依次执行各个插件的初始化方法 ProgramEnter
  },
  // 退出钩子
  exit() {
  	// ...
  }
}</code></pre> 
<p>转换 import 语法需要识别 ES6 模块规范的默认导入、部分导入以及整体导入等语法，主要逻辑包括鉴别是否是部分导入，只有部分导入才表示导入具体组件，转换导入变量名等。</p> 
<pre><code class="language-javascript">// 1. 部分导入
import { Button } from '';
console.log(Button);

// 2. 默认导入
import default from '';
console.log(default.Button);

// 3. 全部导入
import * as D from '';
console.log(D.Button);</code></pre> 
<p>整体处理逻辑如下：</p> 
<ul><li><code>ImportDeclaration</code> 钩子中将部分导入、默认导入和整体导入的语句记录到插件全局状态对象上，同时将节点的 path 对象记录至插件全局状态对象上；</li><li>插件全局状态对象上存储的 path 对象会在 <code>Program</code> 退出时遍历执行 <code>remove</code> 方法，从而移除了所有原始的导入语句；</li><li>在 <code>MemberExpression</code>、<code>CallExpression</code>、<code>buildExpressionHandler</code>、<code>buildDeclaratorHandler</code>等钩子函数中执行 <code>importMethod</code> 函数；</li><li><code>importMethod</code> 函数会根据插件的配置参数计算出真实文件导入路径、是否导入样式文件、样式文件名、是否转换默认导入等配置，从而使用 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmain%2Fpackages%2Fbabel-helper-module-imports" rel="nofollow" title="@babel/helper-module-imports">@babel/helper-module-imports</a> 提供的 <code>addSideEffect</code> 方法添加对应的部分导入语句。</li><li>重命名导入模块的变量描述符 <code>Identifier。</code> 
  <ul><li>以钩子函数为入口，根据不同的节点类型取找到不同节点与变量相关的属性；</li><li>校验变量的 <code>name</code> 是否存在于插件全局状态的 <code>specfied</code> 中，即变量是否是导入组件指向的变量；</li><li>通过 <code>path.scope.hasBinding</code>、<code>path.scope.getBinding</code> 排除掉其他作用域的变量；</li><li>借助 <code>importMethod</code> 方法计算转换后模块对应的变量名然后修改节点对应的变量名。</li><li>变量描述符 <code>Identifier</code>可能指向的钩子有：</li></ul></li></ul> 
<pre><code class="language-javascript">Property
VariableDeclarator
ArrayExpression
LogicalExpression
ConditionalExpression
IfStatement
ExpressionStatement
ReturnStatement
ExportDefaultDeclaration
BinaryExpression
NewExpression
SwitchStatement
SwitchCase
ClassDeclaration</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36dbbe16ba075161ed80f0cae98fb070/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">k8s——删除namespace一直处于Terminating状态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f1578a242c9005c76186f1d86d4ad4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java split根据“.“分割字符串问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>