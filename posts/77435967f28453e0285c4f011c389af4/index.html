<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习之Pytorch（一）神经网络基础及代码实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度学习之Pytorch（一）神经网络基础及代码实现" />
<meta property="og:description" content="1.1 Tensor (张量) Tensor 可以和 numpy 的 ndarray相互转换Tensor有不同数据类型，有32位浮点型torch.FloatTensor、64位浮点型 torch.DoubleTensor等 1.2 Variable (变量) Variable 和 Tensor 本质上没有区别，不过 Variable 会被放入一个计算图中，然后进行前向传播，反向传播，自动求导。Variable 有三个比较重要的组成属性: data, grad 和 grad_fn通过 data可以取出 Variable 里面的 tensor 数值， grad_fn 表示的是得到这个Variable 的操作，比如通过加减还是乘除来得到的，最后 grad 是这个Variabel 的反向传播梯度.构建Variable. 要注意参数 requires_grad=True/ False，这个参数表示是否对这个变量求梯度，默认的是 False ，也就是不对这个变量求梯度XXX.backward() 是对于标量求导，里面的参数可以不写；对于矢量求导，要传入参数声明，比如：y.backward(torch.FloatTensor( [1， 0.1 ， 0. 01] ))，这样得到的梯度就是它们原本的梯度分别乘上1，0.1和0.01 例子见P37
1.3 Dataset (数据集) torch.utils.data.Dataset是代表这一数据的抽象类，可以自定义数据类 继承和重写这个抽象类，可以通过迭代的方式来取得每一个数据。通过torch.utils.data.DataLoader定义一个新的迭代器，实现取batch， shuffle或者是多线程去读取数据。 例：
torch.utils.data.DataLoader(dataset,batch_size=1,shuffle=False,sampler=None, batch_sampler
=None,num_workers=0,collate_fn=&lt;function default_collate&gt;, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None): 自定义数据加载器。组合了一个数据集和采样器，并提供关于数据的迭代器。
dataset (Dataset)：需要加载的数据集（可以是自定义或者自带的数据集）。
batch_size：batch的大小（可选项，默认值为1）。
shuffle：是否在每个epoch中shuffle整个数据集， 默认值为False。
sampler：定义从数据中抽取样本的策略. 如果指定了, shuffle参数必须为False。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/77435967f28453e0285c4f011c389af4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-08T21:57:51+08:00" />
<meta property="article:modified_time" content="2020-10-08T21:57:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习之Pytorch（一）神经网络基础及代码实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div id="content_views" class="htmledit_views"> 
  <h4>1.1 Tensor (张量)</h4> 
  <ul><li>Tensor 可以和 numpy 的 ndarray相互转换</li><li>Tensor有不同数据类型，有32位浮点型torch.FloatTensor、64位浮点型 torch.DoubleTensor等</li></ul> 
  <h4>1.2 Variable (变量)</h4> 
  <ul><li>Variable 和 Tensor 本质上没有区别，不过 Variable 会被放入一个计算图中，然后进行前向传播，反向传播，自动求导。</li><li>Variable 有三个比较重要的组成属性: data, grad 和 grad_fn通过 data可以取出 Variable 里面的 tensor 数值， grad_fn 表示的是得到这个Variable 的操作，比如通过加减还是乘除来得到的，最后 grad 是这个Variabel 的反向传播梯度.</li><li>构建Variable. 要注意参数 requires_grad=True/ False，这个参数表示是否对这个变量求梯度，默认的是 False ，也就是不对这个变量求梯度</li><li>XXX.backward() 是对于标量求导，里面的参数可以不写；对于矢量求导，要传入参数声明，比如：y.backward(torch.FloatTensor( [1， 0.1 ， 0. 01] ))，这样得到的梯度就是它们原本的梯度分别乘上1，0.1和0.01</li></ul> 
  <p><em>例子</em><em>见</em><em>P37</em></p> 
  <h4>1.3 Dataset (数据集)</h4> 
  <ul><li>torch.utils.data.Dataset是代表这一数据的抽象类，可以自定义数据类 继承和重写这个抽象类，可以通过迭代的方式来取得每一个数据。</li><li>通过torch.utils.data.DataLoader定义一个新的迭代器，实现取batch， shuffle或者是多线程去读取数据。</li></ul> 
  <p><em>例：</em></p> 
  <p><em>torch.utils.data.DataLoader(dataset,batch_size=1,shuffle=False,sampler=None, batch_sampler</em></p> 
  <p><em>=None,num_workers=0,collate_fn=&lt;function default_collate&gt;, pin_memory=False, drop_last=False, timeout=0, worker_init_fn=None): </em><em>自定义数据加载器。组合了一个数据集和采样器，并提供关于数据的迭代器。</em></p> 
  <p><em>dataset (Dataset)</em><em>：需要加载的数据集（可以是自定义或者自带的数据集）。</em></p> 
  <p><em>batch_size</em><em>：</em><em>batch</em><em>的大小（可选项，默认值为1</em><em>）。</em></p> 
  <p><em>shuffle</em><em>：是否在每个epoch</em><em>中shuffle</em><em>整个数据集， </em><em>默认值为False</em><em>。</em></p> 
  <p><em>sampler</em><em>：定义从数据中抽取样本的策略. </em><em>如果指定了, shuffle</em><em>参数必须为False</em><em>。</em></p> 
  <p><em>num_workers</em><em>：表示读取样本的线程数，0</em><em>表示只有主线程。</em></p> 
  <p><em>collate_fn</em><em>：合并一个样本列表称为一个batch</em><em>。</em></p> 
  <p><em>pin_memory</em><em>：是否在返回数据之前将张量拷贝到CUDA</em><em>。</em></p> 
  <p><em>drop_last (bool, optional) </em><em>：设置是否丢弃最后一个不完整的batch</em><em>，默认为False</em><em>。</em></p> 
  <ul><li>在torchvision这个包中还有更高级的有关于计算机视觉的数据读取类: ImageFolder</li></ul> 
  <p><em>要求图片是下面这种存放形式:</em></p> 
  <p><em>root/dog/xxx.png </em></p> 
  <p><em>root/dog/xxy.png</em></p> 
  <p><em>root/cat/ 123.png </em></p> 
  <p><em>root/cat/ 456.png</em></p> 
  <p>dset = lmageFolder(root='root_path'，transform=None，loader=default_loader)</p> 
  <blockquote> 
   <p>root是根目录，该目录下有几个文件夹，每个文件夹表示一个类别: transform和 target_transform 是图片增强，之后我们会详细讲;</p> 
  </blockquote> 
  <p>loader是图片读取的办法，然后通过 loader将图片转换成我们需要的图片类型进入神经网络</p> 
  <p> </p> 
  <h4>1.4 nn.Module (模组)</h4> 
  <ul><li>所有的层结构和损失函数都来自于torch.nn，所有的模型构建都是从这个基类nn.Module 继承的，所有的网络层都是由 nn 这个包得到的，比如线性层 nn.Linear。</li><li>定义完模型之后，我们需要通过 nn 这个包来定义损失函数。</li></ul> 
  <h4>1.5 torch.optim (优化)</h4> 
  <p>优化算法是一种调整模型参数更新的策略，通过修改参数使得损失函数最小化(或最大化)</p> 
  <p>1. 一阶优化算法</p> 
  <p>使用各个参数的梯度值来更新参数，最常用的一阶优化算法是梯度下降。梯度下降的功能是通过寻找最小值，控制方差，更新模型参数，最终使模型收敛</p> 
  <div> 
   <figure class="image"> 
    <img alt="" height="118" src="https://images2.imgbox.com/d9/b5/GjUcCMku_o.png" width="460"> 
    <figcaption>
      网络的参数更新公式 
    </figcaption> 
   </figure> 
  </div> 
  <p> </p> 
  <p>2. 二阶优化算法</p> 
  <p>使用了二阶导数(也叫做 Hessian 方法)来最小化或最大化损失函 数，主要基于牛顿法，但是由于二阶导数的计算成本很高，所以这种方法并没有广泛使用。</p> 
  <p> torch.optim 是一个实现各种优化算法的包，大多数常见的算法都能够直接通过这个包来调用，比如随机梯度下降，<a href="https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch-optim/" rel="nofollow">具体官方实例</a>（在优化之前需要先将梯度归零，即 optimizer.zeros() , 然后通过 loss.backward（）反向传播，自动求导得到每个参数的梯度，最后只需要 optimizer. step ()就可以通过梯度做一步参数更新）</p> 
  <p> </p> 
  <h4>1.6 模型的保存与加载</h4> 
  <p>使用 torch.save，有两种保存方式：<br> (1) 保存整个模型的结构和参数，保存的对象是模型 model<br> (2) 保存模型的参数，保存的对象是模型的状态 model.state dict()</p> 
  <p>对应于保存模型，加载模型的方式：<br> (1) 加载完整的模型和参数，使用 load model = torch.load('XXX' )<br> (2) 加载模型参数，需要先导入模型的结构，然后model.load state dic (torch.load('XXX')) 来导入</p> 
  <p> </p> 
  <h4>2.1 分类问题</h4> 
  <p>二分类算法一一Logistic 回归</p> 
  <ul><li>非线性变换 Sigmoid 函数是 Logistic 分布函数中 γ=1 ，μ=0 的特殊形式。</li></ul> 
  <p><img alt="" class="has" src="https://images2.imgbox.com/ed/41/yPbvmzFj_o.jpg"></p> 
  <ul><li> Logistic 回归要更进一步，通过找到分类概率 P(Y =1) 与输入变量x的直接关系，然后通过比较概率值来判断类别.</li><li> Logistic 回归的思路是先拟合决策边界(这里的决策边界不局限于线性，还可以是多项式)，再建立这个边界和分类概率的关系，从而得到二分类情况下的概率。</li><li>模型的参数估计 <em>具体见P44</em></li></ul> 
  <p> </p> 
  <h4>2.2 代码实现</h4> 
  <ul><li>定义模型并训练</li></ul> 
  <p><strong>定义</strong> Logistic 回归的模型</p> 
  <p>class  LogisticRegression(nn.Module) :</p> 
  <p>    self.lr=nn.Linear()  </p> 
  <p>    self.sm=nn.Sigmoid ()</p> 
  <p>criterion = nn.BCELoss ()</p> 
  <p>optimizer = torch . optim.SGD( logistic_model.parameters () , lr=le-3 ,momentum=0.9 )</p> 
  <p><strong>训练</strong>模型</p> 
  <p>for epoch in range(50000):</p> 
  <p>    变量转成Variable形式</p> 
  <p>    前向传播：out = model (x)    #self.lr=nn.Linear()  self.sm=nn.Sigmoid ()</p> 
  <p>              loss = criterion(out , y)</p> 
  <p>    反向传播：optimizer. zero_grad ()</p> 
  <p>              loss.backward ()</p> 
  <p>              optimizer. step () </p> 
  <p> </p> 
  <h4>3.1 <strong>激活函数</strong></h4> 
  <p>简单的一层神经网络的数学形式简单，可以看成一个线性运算再加上一个激活函数（可激活变大/变小），Logistic 回归是使用了 Sigmoid 作为激活函数的一层神经网络</p> 
  <p><img alt="" class="has" src="https://images2.imgbox.com/56/af/rnIXVSqm_o.jpg"></p> 
  <p> </p> 
  <p>适合用于前向传播（实际基本不用）</p> 
  <p>Sigmoid 函数有以下两大缺点</p> 
  <p>( 1 )  Sigmoid 函数靠近1和0的两端会造成梯度消失，梯度下降法通过梯度乘上学习率来更新参数，因此如果梯度接近 0，那么没有任何信息来更新参数，造成模型不收敛</p> 
  <p>( 2 )  经过 Sigmoid 激活函数的输出，作为后一层网络的输入是非 0 均值的，若输入进入下一层神经元的时候全是正的，则导致梯度全是正的，在更新参数时永远都是正梯度。</p> 
  <p><img alt="" class="has" src="https://images2.imgbox.com/06/fa/QMQVRMYc_o.jpg"></p> 
  <p><img alt="" class="has" src="https://images2.imgbox.com/38/e9/drrCbmyz_o.jpg"></p> 
  <p>ReLU 的优点：适合用于后向传播</p> 
  <p>(1)相比于 Sigmoid 和 Tanh 激活函数， ReLU 激活函数可极大地加速随机梯度下降法的收敛速度，这因为它是线性的，且不存在梯度消失的问题</p> 
  <p>( 2 )相比于 Sigmoid 和 Tanh 激活函数， ReLU 的计算方法更加简单.只需要一个阈值运算就可以得到结果，不需要进行一大堆复杂的运算。</p> 
  <p>ReLU 的缺点:</p> 
  <p>训练的时候很脆弱.举个例子：由于ReLU在x&lt;0时梯度为0，这样就导致负的梯度在这个ReLU被置零，那么这个神经元之后的梯度就永远是0了，不再对任何数据有所响应。在实际操作中可以通过设置比较小的学习率来避免这个小问题</p> 
  <p> </p> 
  <p><strong>4.Leaky ReLU   </strong><strong>略</strong></p> 
  <p><strong>5.Maxout   </strong><strong>略</strong></p> 
  <p> </p> 
  <h4><strong>3.2 神经网络的结构、模型的表示能力与容量</strong></h4> 
  <ul><li>N 层神经网络并不会把输入层算进去，因此一个一层的神经网络是指没有隐藏层，只有输入层和输出层的神经网络。Logistic 回归就是一个一层的神经网络</li><li>但是更深的全连接神经网络结构效果提升就不大了，而与此对比的是卷积神经网络的深层结构则会有更好的效果。</li><li>对于容量更大（更深）的神经网络，它的局部极小点的方差特别小，也就是说训练多次虽然可能陷入不同的局部极小点，但是它们之间的差异是很小的，这样训练就不会完全依靠随机初始化。</li><li>控制网络过拟合<em>见后面</em></li></ul> 
  <p> </p> 
  <h4>4.1 梯度下降法</h4> 
  <ul><li>损失函数f ， 我们用反向传播算法算出 f 的梯度 f(x)，更新参数</li><li>反向传播就是链式求导：如果需要对其中的元素求导，那么可以一层一层求导，然后将结果乘起来。求解每层网络的参数都是通过链式法则将前面的结果求出不断迭代到这一层的</li><li>参数更新：<img alt="" class="has" height="20" src="https://images2.imgbox.com/d7/e4/QomatPi9_o.png" width="111"></li></ul> 
  <p>第一个参数代表下一步的位置</p> 
  <p>第二个参数代表当前位置</p> 
  <p>α代表学习率，每迈出一步的距离，不能太大也不能太小</p> 
  <p><img alt="" class="has" height="43" src="https://images2.imgbox.com/ed/06/JpQ5z0N6_o.png" width="74">代表梯度，损失函数</p> 
  <p> </p> 
  <h4>4.2 梯度下降法的变式</h4> 
  <p><strong>人工设置学习率</strong></p> 
  <p>1.SGD 随机梯度下降</p> 
  <p>每次使用一批 (batch) 数掘进行梯度的计算，而不是计算全部数据的梯度</p> 
  <p>2.Momentum</p> 
  <p>相比于标准梯度下降算法，Momentum项能够在相关方向加速SGD，使得参数更新方向更多地沿着横轴进行，抑制振荡，从而加快收敛</p> 
  <p>3.Nesterov</p> 
  <p>Momentum加上nesterov项后，梯度在大的跳跃后，进行计算对当前梯度进行校正</p> 
  <p> </p> 
  <p><strong>自适应学习率</strong></p> 
  <p>1.Adagrad</p> 
  <ul><li>适合处理稀疏梯度</li><li>中后期，分母上梯度平方的累加将会越来越大，使<em>gradient</em>→0，使得训练提前结束</li></ul> 
  <p>2.Adadelta</p> 
  <ul><li>训练初中期，加速效果不错，很快</li><li>训练后期，反复在局部最小值附近抖动</li></ul> 
  <p>3.RMSprop</p> 
  <ul><li>RMSprop算是Adagrad的一种发展，和Adadelta的变体，效果趋于二者之间</li><li>适合处理非平稳目标</li><li>对于RNN效果很好</li></ul> 
  <p>4.Adam</p> 
  <p>这是一种综合型的学习方法，可以看成是RMSprop 加上动量 (Momentum) 的学习方法，达到比 RMSProp 更好的效果。</p> 
  <h4>经验之谈</h4> 
  <ul><li>对于<strong>稀疏数据</strong>，尽量使用学习率可<strong>自适应</strong>的优化方法，不用手动调节，而且最好采用<strong>默认值</strong></li><li><strong>SGD</strong>通常训练时间更长，容易陷入鞍点，但是在好的初始化和学习率调度方案的情况下，结果更可靠</li><li>如果在意<strong>更快的收敛</strong>，并且需要训练<strong>较深较复杂</strong>的网络时，推荐使用学习率<strong>自适应</strong>的优化方法。</li><li>Adadelta，RMSprop，Adam是比较相近的算法，在相似的情况下表现<strong>差不多</strong>。</li><li>在想使用带动量的RMSprop，或者Adam的地方，大多可以使用<strong>Nadam</strong>取得<strong>更好</strong>的效果</li></ul> 
  <p><em>补充 <a href="https://blog.csdn.net/u012759136/article/details/52302426">深度学习最全优化方法总结比较</a></em></p> 
  <p> </p> 
  <h4>5.1 数据预处理</h4> 
  <p>1.中心化</p> 
  <p>每个特征维度都减去相应的均值实现中心化，这样可以使得数据变成 0 均值，特别对于一些图像数据.</p> 
  <p>2.标准化/归一化</p> 
  <ul><li>有两种常用的方法：</li></ul> 
  <p><strong>StandardScaler：减去均值然后除以方差（或标准差）</strong>，这种数据标准化方法经过处理后数据符合标准正态分布，即均值为0，标准差为1</p> 
  <p><strong>MinMaxScaler：</strong>将特征缩放到给定的最小值和最大值之间，或者也可以将每个特征的最大绝对值转换至单位大小。</p> 
  <ul><li>标准化（归一化）两个优点：</li></ul> 
  <p>  1）归一化后加快了梯度下降求最优解的速度；</p> 
  <p>  2）归一化有可能提高精度。</p> 
  <ul><li>经验之谈</li></ul> 
  <p>1）在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，<strong>StandardScaler</strong>表现更好。</p> 
  <p>2）在不涉及协方差计算、数据不符合正态分布的时候，可以使用<strong>MinMaxScaler</strong>。比如图像处理中，将RGB图像转换为灰度图像后将其值限定在[0，255]的范围。</p> 
  <p>3）使用<strong>MinMaxScaler</strong>，其协方差产生了倍数值的缩放，因此无法消除量纲对方差、协方差的影响，对PCA分析影响巨大；同时，由于量纲的存在，距离的计算结果会不同。</p> 
  <p>在<strong>StandardScaler</strong>中，每个维度都是去量纲化的，避免了不同量纲的选取对距离计算产生的巨大影响。</p> 
  <p>4）若数据包含许多异常值<strong>，</strong><strong>RobustScaler</strong> 对数据的中心和范围使用更有鲁棒性的估计。</p> 
  <p>      针对稀疏矩阵，用<strong>MaxAbs</strong></p> 
  <p>3.PCA（去噪）</p> 
  <p>数据中心化，用协方差矩阵对数据进行去相关性，投影到一个特征空间，取主要特征向量。</p> 
  <p>4.白噪声（加噪）</p> 
  <p>将数据投影到一个特征空间， 然后每个维度除以特征值来标准化这些数据，直观上就是一个多元高斯分布转化到了 一个 0 均值，协方差矩阵为 1 的多元高斯分布 。</p> 
  <p><em>3. 4.在CNN中基本不用</em></p> 
  <p> </p> 
  <h4>5.2 权重初始化</h4> 
  <p>1.全 0 初始化</p> 
  <p>不可取，否则权重相同</p> 
  <p>2. 随机初始化</p> 
  <p>经常用，在训练深度神经网络时可能会造成两个问题，<strong>梯度消失和梯度爆炸</strong>。</p> 
  <p><em>梯度消失和梯度爆炸 补充：<a href="https://blog.csdn.net/qq_25737169/article/details/78847691">详解机器学习中的梯度消失、爆炸原因及其解决方法</a></em></p> 
  <p>3. 稀疏初始化</p> 
  <p>实际较少用到</p> 
  <p>4. 初始化偏置( bias )</p> 
  <p>偏置 (bias)通常是初始化为 0</p> 
  <p>5. 批标准化( Batch Normalization )</p> 
  <p><strong>效果好，</strong>它位于X=WU+B激活值获得之后，非线性函数变换之前</p> 
  <p>对于每个隐层神经元，把逐渐往非线性函数的取值区间的上下限两端靠近的激活输入分布 强制拉回到 均值为0方差为1的比较标准的正态分布，使得输入值落入非线性函数比较敏感的区域，以此避免梯度消失问题。</p> 
  <p><em>具体见 <a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" rel="nofollow">深入理解Batch Normalization批标准化</a></em></p> 
  <p> </p> 
  <h4>5.3 防止过拟合</h4> 
  <p>1.正则化（目的是限制参数过多或者过大，避免模型更加复杂）</p> 
  <p>L2正则化是正则化(regularization)中比较常用的形式：对于权重过大的部分进行惩罚，让参数更新之后更加靠近0 </p> 
  <p>L1正则化是另一种正则化方法：在损失函数中增加权重的 1 范数</p> 
  <p> </p> 
  <ul><li>在实际中通常使用 L2 正则化，我们也可以把L1正则化和 L2 正则化结合起来，如<img alt="" class="has" height="22" src="https://images2.imgbox.com/fb/7f/XOs7b8We_o.png" width="93"> 。</li><li><strong>L1</strong>相对于 L2 ，在优化的过程中可以让权重变得更加稀疏，在优化结束的时候，权重只会取一些与最重要的输入有关的权重，这就使得与噪声相关的权重被尽可能降为 0</li><li><strong>L2</strong> 会比L1更加发散，权重也会被限制得更小</li></ul> 
  <p><em>补充：<a href="https://blog.csdn.net/red_stone1/article/details/80755144">机器学习中 L1 和 L2 正则化的直观解释</a></em></p> 
  <p>还有一种正则化方法叫做最大范数限制，其迫使权重在更新的过程中范数有一个上界，可以使得当学习率设置太高的时候网络不会"爆炸"</p> 
  <p> </p> 
  <p>2.Dropout</p> 
  <ul><li>在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作， 也就是说每次训练忽略一部分的特征检测器（让一部分的隐层节点值为0）</li><li>在预测的时候，如果保留所有的权重（预测没办法随机丢弃，若丢弃一些神经元，会带来结果不稳定的问题），每一个神经单元的权重参数要乘以概率p。</li><li>每一次训练batch，Dropout之后就可以看作是一个新的模型，然后训练了很多次之后就可以看成是这些模型的集成，整个dropout过程就相当于对很多个不同的神经网络取平均</li></ul> 
  <p> </p> 
  <h4>5.4 神经网络实现</h4> 
  <p><strong>快速回忆版</strong></p> 
  <p>1、构建好一个神经网络</p> 
  <p>2、训练网络必须经过4步：</p> 
  <p>第一步：将输入input向前传播，进行运算后得到输出output</p> 
  <p>第二步：将output再输入loss函数，计算loss值（是个标量）</p> 
  <p>第三步：将梯度反向传播到每个参数</p> 
  <p>第四步：利用公式进行权重更新</p> 
  <p> </p> 
  <p><strong>细抠代码版</strong></p> 
  <p><strong>1、搭建网络：</strong></p> 
  <div> 
   <figure class="image"> 
    <img alt="" src="https://images2.imgbox.com/36/f9/fMny6kTn_o.jpg"> 
    <figcaption>
      黄字重点 
    </figcaption> 
   </figure> 
  </div> 
  <p><strong>2、导入包、定义超参数（</strong>如 batch size 、 learning rate 还有 num_epoches）</p> 
  <p>3、用torchvision.transforms进行<strong>数据预处理</strong></p> 
  <p><strong>4、读取数据集（见1.3</strong><strong>）</strong></p> 
  <p>torchvision.datasets</p> 
  <p>torch.utils.data.DataLoader。建立数据迭代器</p> 
  <p><strong>5、导入网络，定义损害函数和优化方法 </strong></p> 
  <p>model =  net.Batch_Net(输入图片维度, 隐藏层1 , 隐藏层2, 分类数)</p> 
  <p>criterion  =  nn.CrossEntropyLoss()</p> 
  <p>optimizer =  optim.SGD(model.parameters() ,  lr=learning_rate)</p> 
  <p><strong>6、训练网络</strong></p> 
  <p><em>例：for epoch in range(50000):</em></p> 
  <p><em>    </em><em>变量转成Variable形式</em></p> 
  <p><em>    </em><em>前向传播：out = model (x)    #self.lr=nn.Linear()  self.sm=nn.Sigmoid ()</em></p> 
  <p><em>              loss = criterion(out , y)</em></p> 
  <p><em>    </em><em>反向传播：optimizer. zero_grad ()</em></p> 
  <p><em>              loss.backward ()</em></p> 
  <p><em>              optimizer. step () </em></p> 
  <p><strong>7、测试网络</strong></p> 
  <p><img alt="" class="has" src="https://images2.imgbox.com/ff/b3/iSb7Wdrv_o.jpg"></p> 
  <p> </p> 
  <p> </p> 
  <p> </p> 
  <p> </p> 
  <p> </p> 
  <hr> 
  <p></p> 
 </div> 
 <div> 
  <div></div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d390fcbb8799351cd9306c0db8a83932/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">原生js实现分页功能</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e11d9bba0eaf1cda48c2af4884311b23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快速入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>