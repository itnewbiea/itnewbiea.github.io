<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>主机怎么加入组播组 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="主机怎么加入组播组" />
<meta property="og:description" content="原文链接：https://www.zhihu.com/question/27233903 知乎用户：车小胖
组播也是一种IP包，也有源IP地址，目的IP地址，源IP地址为组播源的服务器IP地址，目的地址为一个特殊的IP地址，它位于 224.0.0.0 - 239.255.255.255 中，由于 224.0.0.0/8用于本地链路，即一跳的组播，239.0.0.0/8 为私有组播地址，所以实际的可用于在互联网上组播地址是225.0.0.0/8 - 238.0.0.0/8，这个组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员（组播源）往微信群（组播IP）发送消息（组播数据），这个群里的成员（组播接收者）都会接收到此消息。
IPTV就是组播的应用：
IPTV里的一个电视频道对应一个组播IP， 假设CCTV1 对应的组播IP =238.1.1.1 ，IPTV节目源IP=1.1.1.1，就以238.1.1.1 为目的地址封装发送，这里有两个问题需要解决：
IPTV组播源不知道收看此节目的用户在哪里？
收看此节目的用户不知道IPTV组播源在哪里？
用户IPTV机顶盒只知道节目组播地址为238.1.1.1 ，至于谁是这个节目源（IP=1.1.1.1）并不清楚。
于是就引入了一个中介机构（RP），Rendezvous Point，RP点，组播的汇聚点，RP IP = 2.2.2.2 ，组播源通过单播隧道的方式把组播238.1.1.1 发给 RP，简称组播源的注册。
机顶盒静态配置了RP IP = 2.2.2.2，知道RP会有组播数据，于是就向RP（ 2.2.2.2）申请加入这个238.1.1.1 的组，于是RP就把自己收到的注册组播源数据发送给机顶盒，这个就是基于RP的 树，RPT。
机顶盒收到第一个组播包，定睛一看，原来组播源是1.1.1.1，于是发一个申请给1.1.1.1 ，申请加入238.1.1.1，这就是基于源的 树，SPT。即然已加入了SPT ，就不需要RPT 了，向RP申请退出就可以了。
着重强调一点：一旦组播用户（接收者）知道了组播源，那RP的任务就算完成了，RP的存在就是为了组播接收者发现组播源，组播用户会加入路径更优的SPT树，会申请退出路径不是最优的RPT树，避免收到两份组播的复制。
以上就是组播工作的大概过程，IPTV是IGMPv2 以及 PIM SM mode 的一个应用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f2e1b6ff6947e0b04d619bae81cffbd2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-30T21:12:00+08:00" />
<meta property="article:modified_time" content="2018-04-30T21:12:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">主机怎么加入组播组</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原文链接：<a href="https://www.zhihu.com/question/27233903" rel="nofollow">https://www.zhihu.com/question/27233903</a> 知乎用户：车小胖</p> 
<p>组播也是一种IP包，也有源IP地址，目的IP地址，源IP地址为组播源的服务器IP地址，目的地址为一个特殊的IP地址，它位于 224.0.0.0 - 239.255.255.255 中，由于 224.0.0.0/8用于本地链路，即一跳的组播，239.0.0.0/8 为私有组播地址，所以实际的可用于在互联网上组播地址是225.0.0.0/8 - 238.0.0.0/8，这个组播地址不属于任何服务器或个人，它有点类似一个微信群号，任何成员（组播源）往微信群（组播IP）发送消息（组播数据），这个群里的成员（组播接收者）都会接收到此消息。</p> 
<p>IPTV就是组播的应用：</p> 
<p>IPTV里的一个电视频道对应一个组播IP， 假设CCTV1 对应的组播IP =238.1.1.1 ，IPTV节目源IP=1.1.1.1，就以238.1.1.1 为目的地址封装发送，这里有两个问题需要解决：</p> 
<p>IPTV组播源不知道收看此节目的用户在哪里？</p> 
<p>收看此节目的用户不知道IPTV组播源在哪里？</p> 
<p>用户IPTV机顶盒只知道节目组播地址为238.1.1.1 ，至于谁是这个节目源（IP=1.1.1.1）并不清楚。</p> 
<p>于是就引入了一个中介机构（RP），Rendezvous Point，RP点，组播的汇聚点，RP IP = 2.2.2.2 ，组播源通过单播隧道的方式把组播238.1.1.1 发给 RP，简称组播源的注册。</p> 
<p>机顶盒静态配置了RP IP = 2.2.2.2，知道RP会有组播数据，于是就向RP（ 2.2.2.2）申请加入这个238.1.1.1 的组，于是RP就把自己收到的注册组播源数据发送给机顶盒，这个就是基于RP的 树，RPT。</p> 
<p>机顶盒收到第一个组播包，定睛一看，原来组播源是1.1.1.1，于是发一个申请给1.1.1.1 ，申请加入238.1.1.1，这就是基于源的 树，SPT。即然已加入了SPT ，就不需要RPT 了，向RP申请退出就可以了。</p> 
<p>着重强调一点：一旦组播用户（接收者）知道了组播源，那RP的任务就算完成了，RP的存在就是为了组播接收者发现组播源，组播用户会加入路径更优的SPT树，会申请退出路径不是最优的RPT树，避免收到两份组播的复制。</p> 
<p>以上就是组播工作的大概过程，IPTV是IGMPv2 以及 PIM SM mode 的一个应用。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e0dc2f2e8d12ed904ffa19bde553c43/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Integer类源码解析之toString方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e2eceec9a6194469b5a22a2fe8718801/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">httprunner的用例模板</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>