<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【mysql】—— 深度理解“索引” - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【mysql】—— 深度理解“索引”" />
<meta property="og:description" content="本期，我将要给大家介绍的是关于 mysql 中的“索引”，这部分内容在mysql知识体系中可谓是相当重要的，接下来，让我带领大家进入本期的知识学习！！！
目录
（一）前言
（二）索引的理解
1、硬件角度理解索引
1.1、MySQL 与磁盘交互基本单位
1.2、简单小结
2、软件角度理解索引
2.1、案例演示
2.2、为何IO交互要是 Page？
2.3、单个page和多个page （三）聚簇索引 VS 非聚簇索引
（四）索引操作
1、主键索引
2、唯一索引
3、普通索引
4、全文索引
（五）总结与归纳
（一）前言 首先，我先给大家直观的展示一下在查询的时候，看看没有索引时有什么问题？
开始时 构建了一个8000000条记录的数据 海量表 。接下来，我将通过这张表给大家直观的演示： 💨 需求：查询员工编号为998877的员工 1️⃣ 首先，我先用传统的方式进行查询操作： select * from EMP where empno=998877; 输出展示： 解释说明： 可以看到耗时 4.93 秒，这还是在本机一个人来操作，在实际项目中，如果放在公网中，假如同时有 1000 个人并发查询，那很可能就死机。 2️⃣ 接下来我通过创建索引可以很好的解决这一问题： alter table EMP add index(empno); 输出展示： 为了防止事件的偶然性，接下来我换一个员工编号，在测试看看查询时间： 【小结】
通过以上直观的演示，我们可以发现有无索引在实际应用中的效率截然不同。因此，掌握好“索引”这个知识对我们学习mysql还是很重要的！！ （二）索引的理解 接下来，我分别从硬件和OS两个角度带大家认识索引的底层细节。
1、硬件角度理解索引 💨 首先带研究一下磁盘： 在看看磁盘中一个盘片：
扇区：
数据库文件，本质其实就是保存在磁盘的盘片当中。也就是上面的一个个小格子中，就是我们经常所说的扇区。当然，数据库文件很大，也很多，一定需要占据多个扇区。 我们在使用 Linux ，所看到的大部分目录或者文件，其实就是保存在硬盘当中的。 ( 当然，有一些内存文件系统，如： proc ， sys 之类，我们不考虑 ) 数据库文件，本质其实就是保存在磁盘的盘片当中，就是一个一个的文件 所以，最基本的，找到一个文件的全部，本质，就是在磁盘找到所有保存文件的扇区。 而我们能够定位任何一个扇区，那么便能找到所有扇区，因为查找方式是一样的。 定位扇区： 解释说明：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0b258d0c8e7d8ed7d817544b53d898e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T11:33:41+08:00" />
<meta property="article:modified_time" content="2024-01-02T11:33:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【mysql】—— 深度理解“索引”</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>本期，我将要给大家介绍的是关于 <strong>mysql 中的“索引”</strong>，这部分内容在mysql知识体系中可谓是相当重要的，接下来，让我带领大家进入本期的知识学习！！！</p> 
</blockquote> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80" rel="nofollow">（一）前言</a></p> 
<p id="%C2%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B4%A2%E5%BC%95%E7%9A%84%E7%90%86%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%C2%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B4%A2%E5%BC%95%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow"> （二）索引的理解</a></p> 
<p id="1%E3%80%81%E7%A1%AC%E4%BB%B6%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%A1%AC%E4%BB%B6%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95" rel="nofollow">1、硬件角度理解索引</a></p> 
<p id="1.1%E3%80%81MySQL%20%E4%B8%8E%E7%A3%81%E7%9B%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D-toc" style="margin-left:80px;"><a href="#1.1%E3%80%81MySQL%20%E4%B8%8E%E7%A3%81%E7%9B%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D" rel="nofollow">1.1、MySQL 与磁盘交互基本单位</a></p> 
<p id="1.2%E3%80%81%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93" rel="nofollow">1.2、简单小结</a></p> 
<p id="2%E3%80%81%E8%BD%AF%E4%BB%B6%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%BD%AF%E4%BB%B6%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95" rel="nofollow">2、软件角度理解索引</a></p> 
<p id="2.1%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA" rel="nofollow">2.1、案例演示</a></p> 
<p id="2.2%E3%80%81%E4%B8%BA%E4%BD%95IO%E4%BA%A4%E4%BA%92%E8%A6%81%E6%98%AF%20Page%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81%E4%B8%BA%E4%BD%95IO%E4%BA%A4%E4%BA%92%E8%A6%81%E6%98%AF%20Page%EF%BC%9F" rel="nofollow">2.2、为何IO交互要是 Page？</a></p> 
<p id="2.3%E3%80%81%E5%8D%95%E4%B8%AApage%E5%92%8C%E5%A4%9A%E4%B8%AApage%C2%A0-toc" style="margin-left:80px;"><a href="#2.3%E3%80%81%E5%8D%95%E4%B8%AApage%E5%92%8C%E5%A4%9A%E4%B8%AApage%C2%A0" rel="nofollow">2.3、单个page和多个page </a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20VS%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20VS%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95" rel="nofollow">（三）聚簇索引 VS 非聚簇索引</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C" rel="nofollow">（四）索引操作</a></p> 
<p id="1%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95" rel="nofollow">1、主键索引</a></p> 
<p id="2%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95" rel="nofollow">2、唯一索引</a></p> 
<p id="3%E3%80%81%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95" rel="nofollow">3、普通索引</a></p> 
<p id="4%E3%80%81%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95" rel="nofollow">4、全文索引</a></p> 
<p id="%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BD%92%E7%BA%B3-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BD%92%E7%BA%B3" rel="nofollow">（五）总结与归纳</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E8%A8%80">（一）前言</h2> 
<blockquote> 
 <p><strong>首先，我先给大家直观的展示一下<span style="color:#333333;">在查询的时候，看看没有索引时有什么问题？</span></strong></p> 
</blockquote> 
<ul><li><span style="color:#0d0016;">开始时</span><span style="color:#aa5500;"> 构建了一个</span><span style="color:#aa5500;">8000000</span><span style="color:#aa5500;">条记录的数据 </span><span style="color:#333333;">海量表</span> 。接下来，我将通过这张表给大家直观的演示：</li></ul> 
<p class="img-center"><img alt="" height="759" src="https://images2.imgbox.com/3d/2c/1oxWqb2k_o.png" width="820"></p> 
<p></p> 
<blockquote> 
 <p><strong>💨 <span style="color:#fe2c24;">需求</span>：<span style="color:#333333;">查询员工编号为</span><span style="color:#333333;">998877</span><span style="color:#333333;">的员工 </span></strong></p> 
</blockquote> 
<ul><li> 1️⃣ 首先，我先用传统的方式进行查询操作：</li></ul> 
<pre><code class="language-bash">select * from EMP where empno=998877;</code></pre> 
<ul><li>输出展示：</li></ul> 
<p class="img-center"><img alt="" height="794" src="https://images2.imgbox.com/3e/97/fVtJwij0_o.png" width="829"></p> 
<ul><li>解释说明：</li></ul> 
<div> 
 <span style="color:#333333;">可以看到耗时</span> 
 <span style="color:#333333;">4.93</span> 
 <span style="color:#333333;">秒，这还是在本机一个人来操作，在实际项目中，如果放在公网中，假如同时有 </span> 
</div> 
<div> 
 <span style="color:#333333;">1000</span> 
 <span style="color:#333333;">个人并发查询，那很可能就死机。</span> 
</div> 
<p></p> 
<hr> 
<ul><li>2️⃣ 接下来我通过<span style="color:#333333;">创建索引可以很好的解决这一问题：</span></li></ul> 
<pre><code class="language-bash">alter table EMP add index(empno);</code></pre> 
<ul><li>输出展示：</li></ul> 
<p class="img-center"><img alt="" height="795" src="https://images2.imgbox.com/7a/e2/0qNcqPtw_o.png" width="823"></p> 
<p></p> 
<ul><li><span style="color:#333333;">为了防止事件的偶然性，接下来我换一个员工编号，在测试看看查询时间：</span></li></ul> 
<p class="img-center"><img alt="" height="784" src="https://images2.imgbox.com/aa/4a/pnj9uxq9_o.png" width="834"></p> 
<p></p> 
<p><strong><span style="background-color:#ffd900;">【小结】</span></strong></p> 
<ul><li>通过以上直观的演示，我们可以发现有无索引在实际应用中的效率截然不同。因此，掌握好“索引”这个知识对我们学习mysql还是很重要的！！</li></ul> 
<hr> 
<h2 id="%C2%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B4%A2%E5%BC%95%E7%9A%84%E7%90%86%E8%A7%A3"> （二）索引的理解</h2> 
<p><strong>接下来，我分别从硬件和OS两个角度带大家认识索引的底层细节。</strong></p> 
<h3 id="1%E3%80%81%E7%A1%AC%E4%BB%B6%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95">1、硬件角度理解索引</h3> 
<blockquote> 
 <div>
   💨  
  <span style="color:#333333;"><strong>首先带研究一下磁盘： </strong></span> 
 </div> 
</blockquote> 
<div> 
 <p class="img-center"><img alt="" height="585" src="https://images2.imgbox.com/21/80/CkjemHh5_o.png" width="836"></p> 
</div> 
<p><span style="color:#333333;"><strong>在看看磁盘中一个盘片：</strong></span></p> 
<div></div> 
<div> 
 <p class="img-center"><img alt="" height="706" src="https://images2.imgbox.com/6c/93/gbecQArz_o.png" width="1188"></p> 
 <p><span style="color:#333333;"><strong>扇区：</strong></span></p> 
</div> 
<ul><li><span style="color:#333333;">数据库文件，本质其实就是保存在磁盘的盘片当中。也就是上面的一个个小格子中，就是我们经常所说的扇区。当然，数据库文件很大，也很多，一定需要占据多个扇区。 </span></li></ul> 
<div> 
 <div></div> 
 <div></div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#333333;">我们在使用</span> 
   <span style="color:#333333;">Linux</span> 
   <span style="color:#333333;">，所看到的大部分目录或者文件，其实就是保存在硬盘当中的。</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#333333;">当然，有一些内存文件系统，如： proc </span> 
   <span style="color:#333333;">， </span> 
   <span style="color:#333333;">sys </span> 
   <span style="color:#333333;">之类，我们不考虑</span> 
   <span style="color:#333333;">) </span> 
  </div> 
  <div></div> 
  <ul><li><strong><span style="color:#aa5500;">数据库文件，本质其实就是保存在磁盘的盘片当中，就是一个一个的文件</span></strong></li></ul> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="517" src="https://images2.imgbox.com/78/37/uTHiXbKf_o.png" width="815"></p> 
  <ol><li><span style="color:#333333;">所以，最基本的，找到一个文件的全部，本质，就是在磁盘找到所有保存文件的扇区。 </span></li><li><span style="color:#333333;">而我们能够定位任何一个扇区，那么便能找到所有扇区，因为查找方式是一样的。 </span></li></ol> 
  <p></p> 
  <div> 
   <span style="color:#333333;"><strong>定位扇区：</strong></span> 
  </div> 
  <div> 
   <p class="img-center"><img alt="" height="531" src="https://images2.imgbox.com/2b/8f/cZ4IrHZo_o.png" width="944"></p> 
   <p><strong><span style="background-color:#ffd900;">解释说明：</span></strong></p> 
   <ul><li><span style="color:#333333;">柱面</span><span style="color:#333333;">(</span><span style="color:#333333;">磁道</span><span style="color:#333333;">): </span><span style="color:#333333;">多盘磁盘，每盘都是双面，大小完全相等。那么同半径的磁道，整体上便构成了一个柱面；</span></li></ul> 
   <div> 
    <ul><li><span style="color:#333333;">每个盘面都有一个磁头，那么磁头和盘面的对应关系便是</span><span style="color:#333333;">1</span><span style="color:#333333;">对</span><span style="color:#333333;">1</span><span style="color:#333333;">的；</span></li><li><span style="color:#333333;">所以，我们只需要知道，磁头（Heads</span><span style="color:#333333;">）、柱面</span><span style="color:#333333;">(Cylinder)(</span><span style="color:#333333;">等价于磁道</span><span style="color:#333333;">)</span><span style="color:#333333;">、扇区</span><span style="color:#333333;">(Sector)</span><span style="color:#333333;">对应的编号。即可在磁盘上定位所要访问的扇区。这种磁盘数据定位方式叫做 CHS </span><span style="color:#333333;">。不过实际系统软件使用的并不是 CHS </span><span style="color:#333333;">（但是硬件是），而是 </span><span style="color:#333333;">LBA </span><span style="color:#333333;">，一种线性地址，可以想象成虚拟地址与物理地址。系统将 LBA </span><span style="color:#333333;">地址最后会转化成为 </span><span style="color:#333333;">CHS </span><span style="color:#333333;">，交给磁盘去进行数据读取。不过，我们现在不关心转化细节，知道这个东西，让我们逻辑自洽起来即可。 </span></li></ul> 
   </div> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="background-color:#ffd900;">【小结】</span></strong> 
  </div> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#333333;">我们现在已经能够在硬件层面定位，任何一个基本数据块了</span> 
    <span style="color:#333333;">(</span> 
    <span style="color:#333333;">扇区</span> 
    <span style="color:#333333;">)</span> 
    <span style="color:#333333;">。那么在系统软件上，就直接按照扇区(512字节，部分</span> 
    <span style="color:#333333;">4096</span> 
    <span style="color:#333333;">字节</span> 
    <span style="color:#333333;">),</span> 
    <span style="color:#333333;">进行</span> 
    <span style="color:#333333;">IO</span> 
    <span style="color:#333333;">交互吗？<strong>不是 </strong></span> 
   </div> 
   <ul><li><span style="color:#333333;">如果操作系统直接使用硬件提供的数据大小进行交互，那么系统的</span><span style="color:#333333;">IO</span><span style="color:#333333;">代码，就和硬件强相关，换言</span><span style="color:#333333;">之，如果硬件发生变化，系统必须跟着变化 </span></li><li><span style="color:#333333;">从目前来看，单次</span><span style="color:#333333;">IO 512</span><span style="color:#333333;">字节，还是太小了。</span><span style="color:#333333;">IO</span><span style="color:#333333;">单位小，意味着读取同样的数据内容，需要进行多</span><span style="color:#333333;">次磁盘访问，会带来效率的降低。 </span></li><li><span style="color:#333333;">之前学习文件系统，就是在磁盘的基本结构下建立的，文件系统读取基本单位，就不是扇区，而是</span><span style="color:#333333;">数据块。</span></li></ul> 
  </div> 
  <div> 
   <blockquote> 
    <div> 
     <strong>💨 <span style="color:#333333;">故，系统读取磁盘，是以</span><span style="color:#fe2c24;">块</span><span style="color:#333333;">为单位的，基本单位是 4KB </span></strong> 
    </div> 
   </blockquote> 
  </div> 
  <div> 
   <hr> 
   <h4 id="1.1%E3%80%81MySQL%20%E4%B8%8E%E7%A3%81%E7%9B%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D">1.1、<span style="color:#333333;">MySQL </span><span style="color:#333333;"><strong>与磁盘交互基本单位</strong></span></h4> 
   <div> 
    <span style="color:#333333;">MySQL </span> 
    <span style="color:#333333;">作为一款应用软件，可以想象成一种特殊的文件系统。它有着更高的</span> 
    <span style="color:#333333;">IO</span> 
    <span style="color:#333333;">场景，所以，为了提高基本的IO</span> 
    <span style="color:#333333;">效率， </span> 
    <span style="color:#333333;">MySQL </span> 
    <span style="color:#333333;">进行</span> 
    <span style="color:#333333;">IO</span> 
    <span style="color:#333333;">的基本单位是 </span> 
    <strong><span style="color:#333333;">16KB </span></strong> 
    <span style="color:#333333;">(</span> 
    <span style="color:#333333;">后面统一使用 </span> 
    <span style="color:#333333;">InnoDB </span> 
    <span style="color:#333333;">存储引擎讲解</span> 
    <span style="color:#333333;">)</span> 
   </div> 
   <pre><code class="language-bash">SHOW GLOBAL STATUS LIKE 'innodb_page_size';</code></pre> 
   <p class="img-center"><img alt="" height="238" src="https://images2.imgbox.com/de/70/2s9g1Q6P_o.png" width="694"></p> 
   <p><strong><span style="background-color:#ffd900;">解释说明：</span></strong></p> 
   <ul><li><span style="color:#333333;">也就是说，磁盘这个硬件设备的基本单位是 </span><span style="color:#333333;">512 </span><span style="color:#333333;">字节，而 </span><span style="color:#333333;">MySQL InnoDB</span><span style="color:#333333;">引擎</span><span style="color:#333333;">使用 </span><span style="color:#333333;">16KB </span><span style="color:#333333;">进行</span><span style="color:#333333;">IO</span><span style="color:#333333;">交互；</span></li><li><span style="color:#333333;">即， MySQL </span><span style="color:#333333;">和磁盘进行数据交互的基本单位是 </span><span style="color:#fe2c24;"><strong>16KB</strong></span><span style="color:#333333;"> ；</span></li><li><span style="color:#333333;">这个基本数据单元，在 </span><span style="color:#333333;">MySQL </span><span style="color:#333333;">这里叫做</span><strong><span style="color:#333333;">page</span></strong><span style="color:#333333;">（注意和系统的page</span><span style="color:#333333;">区分）</span></li></ul> 
  </div> 
  <div></div> 
  <h4 id="1.2%E3%80%81%E7%AE%80%E5%8D%95%E5%B0%8F%E7%BB%93">1.2、简单小结</h4> 
  <div> 
   <ol><li><span style="color:#333333;">MySQL </span><span style="color:#333333;">中的数据文件，是以</span><strong><span style="color:#333333;">page</span></strong><span style="color:#333333;">为单位保存在磁盘当中的。 </span></li><li><span style="color:#333333;">MySQL </span><span style="color:#333333;">的 </span><span style="color:#333333;">CURD </span><span style="color:#333333;">操作，都需要通过</span><span style="color:#333333;"><strong>计算</strong></span><span style="color:#333333;">，找到对应的插入位置，或者找到对应要修改或者查询的数</span><span style="color:#333333;">据。 </span></li><li><span style="color:#333333;">而只要涉及计算，就需要</span><span style="color:#333333;">CPU</span><span style="color:#333333;">参与，而为了便于</span><span style="color:#333333;">CPU</span><span style="color:#333333;">参与，一定要能够先将数据移动到内存当中。 </span></li><li><span style="color:#333333;">所以在特定时间内，数据一定是磁盘中有，内存中也有。后续操作完内存数据之后，以特定的刷新</span><span style="color:#333333;">策略，刷新到磁盘。而这时，就涉及到磁盘和内存的数据交互，也就是</span><span style="color:#333333;">IO</span><span style="color:#333333;">了。而此时</span><span style="color:#333333;">IO</span><span style="color:#333333;">的基本单位</span><span style="color:#333333;">就是</span><strong><span style="color:#333333;">Page</span></strong><span style="color:#333333;">。 </span></li><li><span style="color:#333333;">为了更好的进行上面的操作， </span><span style="color:#333333;">MySQL </span><span style="color:#333333;">服务器在内存中运行的时候，在服务器内部，就申请了被称</span><span style="color:#333333;">为 </span><span style="color:#fe2c24;"><strong>Buffer Pool </strong></span><span style="color:#333333;">的的大内存空间，来进行各种缓存。其实就是很大的内存空间，来和磁盘数据进</span><span style="color:#333333;">行</span><span style="color:#333333;">IO</span><span style="color:#333333;">交互。 </span></li><li><span style="color:#333333;">为何更高的效率，一定要尽可能的减少系统和磁盘</span><span style="color:#333333;">IO</span><span style="color:#333333;">的次数 </span></li></ol> 
   <div> 
    <hr> 
    <h3 id="2%E3%80%81%E8%BD%AF%E4%BB%B6%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95">2、软件角度理解索引</h3> 
    <h4 id="2.1%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA">2.1、案例演示</h4> 
    <blockquote> 
     <p>首先<span style="color:#333333;"><strong>建立一张测试表，一</strong></span><strong><span style="color:#0d0016;">定要添加主键，只有这样才会默认生成主键索引</span></strong></p> 
    </blockquote> 
    <p class="img-center"><img alt="" height="462" src="https://images2.imgbox.com/a3/a6/wnEhjNaS_o.png" width="834"></p> 
    <ul><li>接下来，创建好表之后，我们往表中插入几条数据便于测试（<span style="color:#aa5500;">注意，我并没有按照主<strong>键的大小顺序</strong>插入</span>）：</li></ul> 
    <p class="img-center"><img alt="" height="569" src="https://images2.imgbox.com/30/f1/8gf4XrrR_o.png" width="788"></p> 
    <div> 
     <span style="color:#333333;"><strong>查看插入结果</strong></span> 
    </div> 
    <div></div> 
    <div> 
     <p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/23/07/VbnBhppU_o.png" width="650"></p> 
    </div> 
    <div></div> 
   </div> 
  </div> 
 </div> 
</div> 
<h4 id="2.2%E3%80%81%E4%B8%BA%E4%BD%95IO%E4%BA%A4%E4%BA%92%E8%A6%81%E6%98%AF%20Page%EF%BC%9F">2.2、<span style="color:#333333;"><strong>为何</strong></span><span style="color:#333333;"><strong>IO</strong></span><span style="color:#333333;"><strong>交互要是 </strong></span><span style="color:#333333;">Page？</span></h4> 
<p><strong><span style="color:#333333;">现在有一个问题：</span><span style="color:#fe2c24;">为何MySQL和磁盘进行IO交互的时候，要采用Page的方案进行交互呢?用多少，加载多少?</span></strong></p> 
<ol><li><span style="color:#333333;">如上面的</span><span style="color:#333333;">5</span><span style="color:#333333;">条记录，如果</span><span style="color:#333333;">MySQL</span><span style="color:#333333;">要查找</span><span style="color:#333333;">id=2</span><span style="color:#333333;">的记录，第一次加载</span><span style="color:#333333;">id=1</span><span style="color:#333333;">，第二次加载</span><span style="color:#333333;">id=2</span><span style="color:#333333;">，一次一条记录，那么就需要2</span><span style="color:#333333;">次</span><span style="color:#333333;">IO</span><span style="color:#333333;">。如果要找</span><span style="color:#333333;">id=5</span><span style="color:#333333;">，那么就需要</span><span style="color:#333333;">5</span><span style="color:#333333;">次</span><span style="color:#333333;">IO</span><span style="color:#333333;">。 </span></li><li><span style="color:#333333;">但，如果这</span><span style="color:#333333;">5</span><span style="color:#333333;">条</span><span style="color:#333333;">(</span><span style="color:#333333;">或者更多</span><span style="color:#333333;">)</span><span style="color:#333333;">都被保存在一个</span><span style="color:#333333;">Page</span><span style="color:#333333;">中</span><span style="color:#333333;">(16KB</span><span style="color:#333333;">，能保存很多记录</span><span style="color:#333333;">),</span><span style="color:#333333;">那么第一次</span><span style="color:#333333;">IO</span><span style="color:#333333;">查找</span><span style="color:#333333;">id=2</span><span style="color:#333333;">的时候，整个Page</span><span style="color:#333333;">会被加载到</span><span style="color:#333333;">MySQL</span><span style="color:#333333;">的 </span><span style="color:#333333;">Buffer Pool </span><span style="color:#333333;">中，这里完成了一次</span><span style="color:#333333;">IO</span><span style="color:#333333;">。但是往后如果在查找</span><span style="color:#333333;">id=1,3,4,5等，完全不需要进行IO</span><span style="color:#333333;">了，而是直接在内存中进行了。所以，就在单</span><span style="color:#333333;">Page</span><span style="color:#333333;">里面，大大减少了</span><span style="color:#333333;">IO</span><span style="color:#333333;">的次数。 </span></li><li><span style="color:#333333;">无法保证用户一定下次找的数据就在这个</span><span style="color:#333333;">Page</span><span style="color:#333333;">里面，我们不能严格保证，但是有很大概率，因为有<strong>局部性原理</strong>。 </span></li><li><span style="color:#333333;">往往</span><span style="color:#333333;">IO</span><span style="color:#333333;">效率低下的最主要矛盾<strong>不是</strong></span><strong><span style="color:#333333;">IO</span><span style="color:#333333;">单次数据量的大小，而是</span><span style="color:#333333;">IO</span></strong><span style="color:#333333;"><strong>的次数</strong>。</span></li></ol> 
<hr> 
<p></p> 
<h4 id="2.3%E3%80%81%E5%8D%95%E4%B8%AApage%E5%92%8C%E5%A4%9A%E4%B8%AApage%C2%A0">2.3、单个page和多个page </h4> 
<p></p> 
<div>
  💨  
 <span style="color:#333333;"><strong>理解单个Page：</strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">MySQL </span> 
 <span style="color:#333333;">中要管理很多数据表文件，而要管理好这些文件，就需要 </span> 
 <strong><span style="color:#fe2c24;">先描述，在组织</span></strong> 
 <span style="color:#333333;"> </span> 
 <span style="color:#333333;">,</span> 
 <span style="color:#333333;">我们目前可以简单理解成一个个独立文件是有一个或者多个Page</span> 
 <span style="color:#333333;">构成的。</span> 
</div> 
<p class="img-center"><img alt="" height="624" src="https://images2.imgbox.com/17/6c/cS56hvHv_o.png" width="949"></p> 
<div> 
 <span style="color:#333333;">不同的 </span> 
 <span style="color:#333333;">Page </span> 
 <span style="color:#333333;">，在 </span> 
 <span style="color:#333333;">MySQL </span> 
 <span style="color:#333333;">中，都是 </span> 
 <span style="color:#333333;">16KB </span> 
 <span style="color:#333333;">，使用 </span> 
 <span style="color:#333333;">prev </span> 
 <span style="color:#333333;">和 </span> 
 <span style="color:#333333;">next </span> 
 <span style="color:#333333;">构成双向链表 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">因为有主键的问题， </span> 
 <span style="color:#333333;">MySQL </span> 
 <span style="color:#333333;">会默认按照主键给我们的数据进行排序，从上面的</span> 
 <span style="color:#333333;">Page</span> 
 <span style="color:#333333;">内数据记录可以看出，数据是有序且彼此关联的。 </span> 
</div> 
<p></p> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">为什么数据库在插入数据时要对其进行排序呢？我们按正常顺序插入数据不是也挺好的吗？ </span></strong> 
 </div> 
 <ol><li><span style="color:#000000;">插入数据时排序的目的，就是优化查询的效率。 </span></li><li><span style="color:#000000;">页内部存放数据的模块，实质上也是一个链表的结构，链表的特点也就是增删快，查询修改慢，所以优化查询的效率是必须的。 </span></li><li><span style="color:#000000;">正式因为有序，在查找的时候，从头到后都是有效查找，没有任何一个查找是浪费的，而且，如果运气好，是可以提前结束查找过程的</span></li></ol> 
</blockquote> 
<p></p> 
<p>💨<span style="color:#333333;"><strong>理解多个</strong></span><span style="color:#333333;"><strong>Page </strong></span>：</p> 
<ul><li><span style="color:#333333;">通过上面的分析，我们知道，上面页模式中，只有一个功能，就是</span><span style="color:#333333;"><strong>在查询某条数据的时候直接将一</strong></span><span style="color:#333333;"><strong>整页的数据加载到内存中，以减少硬盘</strong></span><span style="color:#333333;"><strong>IO</strong></span><span style="color:#333333;"><strong>次数，从而提高性能。</strong></span><span style="color:#333333;">但是，我们也可以看到，现在的页</span><span style="color:#333333;">模式内部，实际上是采用了链表的结构，前一条数据指向后一条数据，本质上还是通过数据的逐条</span><span style="color:#333333;">比较来取出特定的数据。 </span></li><li><span style="color:#333333;">如果有</span><span style="color:#333333;">1</span><span style="color:#333333;">千万条数据，一定需要多个</span><span style="color:#333333;">Page</span><span style="color:#333333;">来保存</span><span style="color:#333333;">1</span><span style="color:#333333;">千万条数据，多个</span><span style="color:#333333;">Page</span><span style="color:#333333;">彼此使用双链表链接起</span><span style="color:#333333;">来，而且每个</span><span style="color:#333333;">Page</span><span style="color:#333333;">内部的数据也是基于链表的。那么，查找特定一条记录，也一定是线性查找。这效率也太低了。</span></li></ul> 
<div> 
 <p class="img-center"><img alt="" height="389" src="https://images2.imgbox.com/5f/45/6yejz3W3_o.png" width="1200"></p> 
 <div>
   💨  
  <span style="color:#333333;"><strong>页目录：</strong></span> 
 </div> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">我们在看《谭浩强</span> 
  <span style="color:#333333;">C</span> 
  <span style="color:#333333;">程序设计》这本书的时候，如果我们要看</span> 
  <span style="color:#333333;">&lt;</span> 
  <span style="color:#333333;">指针章节</span> 
  <span style="color:#333333;">&gt;</span> 
  <span style="color:#333333;">，找到该章节有两种做法 </span> 
 </div> 
 <ul><li><span style="color:#333333;">从头逐页的向后翻，直到找到目标内容 </span></li><li><span style="color:#333333;">通过书提供的目录，发现指针章节在</span><span style="color:#333333;">234</span><span style="color:#333333;">页</span><span style="color:#333333;">(</span><span style="color:#333333;">假设</span><span style="color:#333333;">)</span><span style="color:#333333;">，那么我们便直接翻到</span><span style="color:#333333;">234</span><span style="color:#333333;">页。同时，查找目录的</span><span style="color:#333333;">方案，可以顺序找，不过因为目录肯定少，所以可以快速提高定位 </span></li><li><span style="color:#333333;">本质上，书中的目录，是多花了纸张的，但是却提高了效率 </span></li><li><span style="color:#333333;">所以，目录，是一种</span><span style="color:#333333;">“</span><span style="color:#333333;">空间换时间的做法</span><span style="color:#333333;">”</span></li></ul> 
</div> 
<div></div> 
<div>
  💨  
 <span style="color:#333333;"><strong>单页情况：</strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">针对上面的单页</span> 
 <span style="color:#333333;">Page</span> 
 <span style="color:#333333;">，我们能否也引入目录呢？当然可以</span> 
</div> 
<div></div> 
<div> 
 <p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/43/69/7EpooxxO_o.png" width="573"></p> 
 <div> 
  <span style="color:#333333;">那么当前，在一个</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">内部，我们引入了目录。比如，我们要查找</span> 
  <span style="color:#333333;">id=4</span> 
  <span style="color:#333333;">记录，之前必须线性遍历</span> 
  <span style="color:#333333;">4</span> 
  <span style="color:#333333;">次，才能拿到结果。现在直接通过目录2[3]</span> 
  <span style="color:#333333;">，直接进行定位新的起始位置，提高了效率。现在我们可以再次正式回答上面的问题了，为何通过键值 MySQL </span> 
  <span style="color:#333333;">会自动排序？</span> 
 </div> 
</div> 
<div></div> 
<ul><li><span style="color:#fe2c24;"><strong>答案很简单，可以很方便引入目录</strong></span></li></ul> 
<div></div> 
<div>
  💨  
 <span style="color:#333333;"><strong>多页情况 </strong></span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">MySQL </span> 
  <span style="color:#333333;">中每一页的大小只有 </span> 
  <span style="color:#333333;">16KB </span> 
  <span style="color:#333333;">，单个</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">大小固定，所以随着数据量不断增大， </span> 
  <span style="color:#333333;">16KB </span> 
  <span style="color:#333333;">不可能存下所有的数据，那么必定会有多个页来存储数据。 </span> 
 </div> 
 <div></div> 
 <div> 
  <p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/9d/09/SuZgawji_o.png" width="1200"></p> 
  <div> 
   <span style="color:#333333;">在单表数据不断被插入的情况下， </span> 
   <span style="color:#333333;">MySQL </span> 
   <span style="color:#333333;">会在容量不足的时候，自动开辟新的</span> 
   <span style="color:#333333;">Page</span> 
   <span style="color:#333333;">来保存新的数据，然后通过指针的方式，将所有的Page</span> 
   <span style="color:#333333;">组织起来。 </span> 
  </div> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#333333;">需要注意，上面的图，是理想结构，大家也知道，目前要保证整体有序，那么新插入的数据，不一定会在新Page</span> 
  <span style="color:#333333;">上面，这里仅仅做演示。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">这样，我们就可以通过多个</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">遍历，</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">内部通过目录来快速定位数据。可是，貌似这样也有效率问题，在Page</span> 
  <span style="color:#333333;">之间，也是需要 </span> 
  <span style="color:#333333;">MySQL </span> 
  <span style="color:#333333;">遍历的，遍历意味着依旧需要进行大量的</span> 
  <span style="color:#333333;">IO</span> 
  <span style="color:#333333;">，将下一个</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">加载到内存，进行线性检测。这样就显得我们之前的Page</span> 
  <span style="color:#333333;">内部的目录，有点杯水车薪了。 </span> 
 </div> 
 <div></div> 
 <blockquote> 
  <div> 
   <span style="color:#333333;">那么如何解决呢？解决方案，<strong>其实就是我们之前的思路，给</strong></span> 
   <strong><span style="color:#333333;">Page</span></strong> 
   <span style="color:#333333;"><strong>也带上目录</strong>：</span> 
  </div> 
 </blockquote> 
 <ul><li><span style="color:#333333;">使用一个目录项来指向某一页，而这个目录项存放的就是将要指向的页中存放的最小数据的键值。 </span></li><li><span style="color:#333333;">和页内目录不同的地方在于，这种目录管理的级别是页，而页内目录管理的级别是行。 </span></li><li><span style="color:#333333;">其中，每个目录项的构成是：键值</span><span style="color:#333333;">+</span><span style="color:#333333;">指针。图中没有画全。 </span></li></ul> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="637" src="https://images2.imgbox.com/6c/ba/0SIVVHDy_o.png" width="1200"></p> 
 <div> 
  <span style="color:#333333;">存在一个目录页来管理页目录，目录页中的数据存放的就是指向的那一页中最小的数据。有数据，就可通过比较，找到该访问那个Page</span> 
  <span style="color:#333333;">，进而通过指针，找到下一个</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">其实</span> 
  <span style="color:#333333;"><strong>目录页的本质也是页，普通页中存的数据是用户数据，而目录页中存的数据是普通页的地址。 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">可是，我们每次检索数据的时候，该从哪里开始呢？虽然顶层的目录页少了，但是还要遍历啊？不用担心，可以在加目录页</span> 
 </div> 
</div> 
<div></div> 
<div> 
 <p class="img-center"><img alt="" height="485" src="https://images2.imgbox.com/76/3e/WRMcaNOt_o.png" width="736"></p> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">这货就是传说中的</span> 
  <span style="color:#333333;">B+</span> 
  <span style="color:#333333;">树啊！没错，至此，我们已经给我们的表</span> 
  <span style="color:#333333;">user</span> 
  <span style="color:#333333;">构建完了主键索引。 </span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;">随便找一个</span> 
  <span style="color:#333333;">id=</span> 
  <span style="color:#333333;">？我们发现，现在查找的</span> 
  <span style="color:#333333;">Page</span> 
  <span style="color:#333333;">数一定减少了，也就意味着</span> 
  <span style="color:#333333;">IO</span> 
  <span style="color:#333333;">次数减少了，那么效率也就提高了。</span> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div> 
 <hr> 
 <h2 id="%EF%BC%88%E4%B8%89%EF%BC%89%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%20VS%20%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">（三）<span style="color:#333333;"><strong>聚簇索引</strong></span><span style="color:#333333;"><strong> VS </strong></span><span style="color:#333333;"><strong>非聚簇索引</strong></span></h2> 
</div> 
<blockquote> 
 <div> 
  <strong><span style="color:#333333;">MyISAM </span><span style="color:#333333;">存储引擎</span><span style="color:#333333;">-</span><span style="color:#333333;">主键索引 </span></strong> 
 </div> 
</blockquote> 
<div></div> 
<div> 
 <span style="color:#333333;">MyISAM </span> 
 <span style="color:#333333;">引擎同样使用</span> 
 <span style="color:#333333;">B+</span> 
 <span style="color:#333333;">树作为索引结果，叶节点的</span> 
 <span style="color:#333333;">data</span> 
 <span style="color:#333333;">域存放的是数据记录的地址。下图为 </span> 
 <span style="color:#333333;">MyISAM表的主索引， Col1 </span> 
 <span style="color:#333333;">为主键。</span> 
</div> 
<p class="img-center"><img alt="" height="752" src="https://images2.imgbox.com/e3/b4/Lj4K5Db3_o.png" width="1058"></p> 
<p></p> 
<div> 
 <span style="color:#333333;">其中， </span> 
 <span style="color:#333333;">MyISAM </span> 
 <span style="color:#333333;">最大的特点是，将索引</span> 
 <span style="color:#333333;">Page</span> 
 <span style="color:#333333;">和数据</span> 
 <span style="color:#333333;">Page</span> 
 <span style="color:#333333;">分离，也就是叶子节点没有数据，只有对应数据的地址。 </span> 
</div> 
<p></p> 
<div> 
 <span style="color:#333333;">相较于 </span> 
 <span style="color:#333333;">InnoDB </span> 
 <span style="color:#333333;">索引， </span> 
 <span style="color:#333333;">InnoDB </span> 
 <span style="color:#333333;">是将索引和数据放在一起的。 </span> 
</div> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/5b/7f/CKfhdJCO_o.png" width="1200"></p> 
<ul><li><span style="color:#333333;">其中， </span><span style="color:#333333;">MyISAM </span><span style="color:#333333;">这种用户数据与索引数据分离的索引方案，叫做<strong>非聚簇索引 </strong></span></li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="632" src="https://images2.imgbox.com/ba/e9/sx22Fhxh_o.png" width="1200"></p> 
<ul><li><span style="color:#333333;">其中， </span><span style="color:#333333;">InnoDB </span><span style="color:#333333;">这种用户数据与索引数据在一起索引方案，叫做<strong>聚簇索引 </strong></span></li></ul> 
<div> 
 <span style="color:#333333;">当然， </span> 
 <span style="color:#333333;">MySQL </span> 
 <span style="color:#333333;">除了默认会建立主键索引外，我们用户也有可能建立按照其他列信息建立的索引，一般这种索引可以叫做辅助（普通）索引。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">对于 </span> 
 <span style="color:#333333;">MyISAM </span> 
 <span style="color:#333333;">,</span> 
 <span style="color:#333333;">建立辅助（普通）索引和主键索引没有差别，无非就是主键不能重复，而非主键可重复。 </span> 
</div> 
<p></p> 
<blockquote> 
 <p> <span style="color:#333333;">下图就是基于 </span><span style="color:#333333;">MyISAM </span><span style="color:#333333;">的 </span><span style="color:#333333;">Col2 </span><span style="color:#333333;">建立的索引，和主键索引没有差别 ：</span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="764" src="https://images2.imgbox.com/4e/f0/8U9QEJhx_o.png" width="1068"></p> 
<div> 
 <span style="color:#333333;">同样， </span> 
 <span style="color:#333333;">InnoDB </span> 
 <span style="color:#333333;">除了主键索引，用户也会建立辅助（普通）索引，我们以上表中的 </span> 
 <span style="color:#333333;">Col3 </span> 
 <span style="color:#333333;">建立对应的辅助索引如下图： </span> 
</div> 
<div></div> 
<div> 
 <p class="img-center"><img alt="" height="366" src="https://images2.imgbox.com/fa/b1/YGvSXuTw_o.png" width="879"></p> 
 <ul><li><span style="color:#333333;">可以看到， </span><span style="color:#333333;">InnoDB </span><span style="color:#333333;">的非主键索引中叶子节点并没有数据，而只有对应记录的</span><span style="color:#333333;">key</span><span style="color:#333333;">值。 </span></li><li><li><span style="color:#333333;">所以通过辅助（普通）索引，找到目标记录，需要两遍索引：<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。这种过程，就叫做</span><span style="color:#fe2c24;"><strong>回表查询 </strong></span></li><li><li><span style="color:#333333;">为何 </span><span style="color:#333333;">InnoDB </span><span style="color:#333333;">针对这种辅助（普通）索引的场景，不给叶子节点也附上数据呢？<strong>原因就是太浪费空间了。</strong></span></li></ul> 
</div> 
<hr> 
<h2 id="%EF%BC%88%E5%9B%9B%EF%BC%89%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C">（四）<span style="color:#333333;"><strong>索引操作</strong></span></h2> 
<h3 id="1%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95">1、<span style="color:#333333;"><strong>主键索引 </strong></span></h3> 
<p>1.1<span style="color:#333333;"><strong>创建主键索引</strong></span></p> 
<ul><li><span style="color:#fe2c24;"><strong>💨第一种方式：</strong></span></li></ul> 
<div> 
 <pre><code class="language-bash">-- 在创建表的时候，直接在字段名后指定 primary key
create table test1(
    id int primary key,
    name varchar(30)
);</code></pre> 
 <p></p> 
</div> 
<ul><li><span style="color:#fe2c24;"><strong>💨第二种方式：</strong></span></li></ul> 
<div></div> 
<div> 
 <pre><code class="language-bash">-- 在创建表的最后，指定某列或某几列为主键索引
create table test2(
    id int, 
    name varchar(30), 
    primary key(id)
);</code></pre> 
</div> 
<div></div> 
<ul><li><span style="color:#fe2c24;"><strong>💨第三种方式：</strong></span></li></ul> 
<div></div> 
<div> 
 <pre><code class="language-bash">create table test3(
    id int, 
    name varchar(30)
);

-- 创建表以后再添加主键
alter table test3 add primary key(id);</code></pre> 
 <p></p> 
</div> 
<div></div> 
<p><span style="color:#333333;"><strong>1.2查询索引 </strong></span></p> 
<ul><li><span style="color:#333333;">第一种方法： </span><strong><span style="color:#333333;">show keys from </span><span style="color:#333333;">表名 </span>；</strong></li><li><span style="color:#333333;">第二种方法: </span><strong><span style="color:#333333;">show index from </span><span style="color:#333333;">表名</span><span style="color:#333333;">; </span></strong></li><li><span style="color:#333333;">第三种方法（信息比较简略）： </span><strong><span style="color:#333333;">desc </span><span style="color:#333333;">表名；</span></strong></li></ul> 
<div></div> 
<p class="img-center"><img alt="" height="765" src="https://images2.imgbox.com/66/59/KQiTLzhP_o.png" width="1200"></p> 
<p><span style="color:#333333;"><strong>1.3删除索引 </strong></span></p> 
<ul><li><span style="color:#333333;">方法</span><span style="color:#333333;">-</span><span style="color:#333333;">删除主键索引： </span><strong><span style="color:#333333;">alter table </span><span style="color:#333333;">表名 </span><span style="color:#333333;">drop primary key</span></strong><span style="color:#333333;"><strong>;</strong> </span></li></ul> 
<p class="img-center"><img alt="" height="381" src="https://images2.imgbox.com/21/9b/5Q1umEa4_o.png" width="789"></p> 
<p></p> 
<div> 
 <strong><span style="color:#333333;"><span style="background-color:#ffd900;">主键索引的特点： </span></span></strong> 
</div> 
<ul><li><span style="color:#333333;">一个表中，最多有一个主键索引，当然可以使符合主键 </span></li></ul> 
<p><img alt="" height="539" src="https://images2.imgbox.com/d9/a4/5GjH703V_o.png" width="832"></p> 
<ul><li><span style="color:#333333;">主键索引的效率高（主键不可重复） </span></li></ul> 
<p><img alt="" height="141" src="https://images2.imgbox.com/e3/fc/gITcEZ4T_o.png" width="730"></p> 
<ul><li><span style="color:#333333;">创建主键索引的列，它的值不能为</span><span style="color:#333333;">null</span><span style="color:#333333;">，且不能重复 </span></li><li><span style="color:#333333;">主键索引的列基本上是</span><span style="color:#333333;">int</span></li></ul> 
<hr> 
<h3 id="2%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">2、<span style="color:#333333;"><strong>唯一索引</strong></span></h3> 
<p></p> 
<p>1.1<span style="color:#333333;"><strong>创建主键索引</strong></span></p> 
<ul><li><span style="color:#fe2c24;"><strong>💨第一种方式：</strong></span></li></ul> 
<pre><code class="language-bash">-- 在表定义时，在某列后直接指定unique唯一属性。
create table test3(
    id int primary key, 
    name varchar(30) unique
);</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>💨第二种方式：</strong></span></li></ul> 
<pre><code class="language-bash">-- 创建表时，在表的后面指定某列或某几列为unique
create table test3(
    id int primary key, 
    name varchar(30), 
    unique(name)
);</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>💨第三种方式：</strong></span></li></ul> 
<pre><code class="language-bash">create table test3(
    id int primary key, 
    name varchar(30)
）；

alter table test3 add unique(name);</code></pre> 
<p><strong>1.2查询索引（方法同上）</strong></p> 
<p class="img-center"><img alt="" height="765" src="https://images2.imgbox.com/db/f0/71XhlDa3_o.png" width="983"></p> 
<p><span style="color:#333333;"><strong>1.3删除索引</strong></span></p> 
<ul><li><span style="color:#333333;">第二种方法</span><span style="color:#333333;">-</span><span style="color:#333333;">其他索引的删除：<strong> </strong></span><strong><span style="color:#333333;">alter table </span><span style="color:#333333;">表名 </span><span style="color:#333333;">drop index </span><span style="color:#333333;">索引名（索引名就是show keys from 表名中的 Key_name 字段</span></strong><strong><span style="color:#333333;">）；</span></strong></li></ul> 
<p class="img-center"><img alt="" height="709" src="https://images2.imgbox.com/43/48/VAFsLEAc_o.png" width="1200"></p> 
<p></p> 
<div> 
 <strong><span style="color:#333333;"><span style="background-color:#ffd900;">唯一索引的特点： </span></span></strong> 
</div> 
<ul><li><span style="color:#333333;">一个表中，可以有多个唯一索引 </span></li><li><span style="color:#333333;">查询效率高 </span></li><li><span style="color:#333333;">如果在某一列建立唯一索引，必须保证这列不能有重复数据 </span></li><li><span style="color:#333333;">如果一个唯一索引上指定</span><span style="color:#333333;">not null</span><span style="color:#333333;">，等价于主键索引</span></li></ul> 
<hr> 
<p></p> 
<h3 id="3%E3%80%81%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95">3、<span style="color:#333333;"><strong>普通索引</strong></span></h3> 
<p></p> 
<p>1.1<span style="color:#333333;"><strong>创建主键索引</strong></span></p> 
<ul><li><span style="color:#fe2c24;"><strong>💨第一种方式：</strong></span></li></ul> 
<pre><code class="language-bash">create table test4(
    id int primary key,
    name varchar(20),
    email varchar(30),
    index(name)  --在表的定义最后，指定某列为索引
);

</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>💨第一种方式：</strong></span></li></ul> 
<pre><code class="language-bash">create table test4(
    id int primary key, 
    name varchar(20), 
    email varchar(30)
);

alter table test4 add index(name); --创建完表以后指定某列为普通索引</code></pre> 
<ul><li><span style="color:#fe2c24;"><strong>💨第一种方式：</strong></span></li></ul> 
<pre><code class="language-bash">create table test4(
    id int primary key, 
    name varchar(20), 
    email varchar(30)
);

-- 创建一个索引名为 idx_name 的索引
create index idx_name on test4(name);</code></pre> 
<p><strong>1.2查询索引（方法同上）</strong> </p> 
<p class="img-center"><img alt="" height="777" src="https://images2.imgbox.com/76/cd/VrMbxTRn_o.png" width="827"></p> 
<p><span style="color:#333333;"><strong>1.3删除索引</strong></span></p> 
<ul><li><span style="color:#333333;">第三种方法方法：</span><strong><span style="color:#333333;"> drop index </span><span style="color:#333333;">索引名</span><span style="color:#333333;"> on </span><span style="color:#333333;">表名</span></strong></li></ul> 
<pre><code class="language-bash">drop index name on test4;</code></pre> 
<p class="img-center"><img alt="" height="690" src="https://images2.imgbox.com/e2/a0/MIszU8zB_o.png" width="1025"></p> 
<ul><li> 除了可以对一列进行索引之外，还可以对多列进行索引操作：</li></ul> 
<p class="img-center"><img alt="" height="1008" src="https://images2.imgbox.com/35/d3/vlaSv297_o.png" width="578"></p> 
<p></p> 
<div> 
 <strong><span style="color:#333333;"><span style="background-color:#ffd900;">普通索引的特点： </span></span></strong> 
</div> 
<ul><li><span style="color:#333333;">一个表中可以有多个普通索引，普通索引在实际开发中用的比较多 </span></li><li><span style="color:#333333;">如果某列需要创建索引，但是该列有重复的值，那么我们就应该使用普通索引</span></li></ul> 
<hr> 
<h3 id="4%E3%80%81%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95" style="background-color:transparent;"><span style="color:#333333;"><strong>4、全文索引</strong></span></h3> 
<div> 
 <span style="color:#333333;">当对文章字段或有大量文字的字段进行检索时，会使用到<strong>全文索引</strong>。</span> 
 <span style="color:#333333;">MySQL</span> 
 <span style="color:#333333;">提供全文索引机制，但是有要求，要求表的存储引擎必须是</span> 
 <span style="color:#fe2c24;"><strong>MyISAM</strong></span> 
 <span style="color:#333333;">，而且默认的全文索引支持英文，不支持中文。如果对中文进行全文检索，可以使用<strong>sphinx</strong></span> 
 <span style="color:#333333;">的中文版</span> 
 <span style="color:#333333;">(<strong>coreseek</strong>)</span> 
 <span style="color:#333333;">。 </span> 
</div> 
<p></p> 
<ul><li>接下来，我先创建一个表并向其中插入一些数据，具体如下：</li></ul> 
<p class="img-center"><img alt="" height="574" src="https://images2.imgbox.com/74/39/COCsLNM0_o.png" width="869"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>需求</strong></span>：<strong><span style="color:#333333;">查询有没有</span><span style="color:#333333;">database</span><span style="color:#333333;">数据</span></strong></p> 
</blockquote> 
<ul><li><span style="color:#333333;">如果使用如下查询方式，虽然查询出数据，但是没有使用到全文索引 </span></li></ul> 
<div> 
 <pre><code class="language-bash">select * from articles where body like '%database%';</code></pre> 
 <p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/b4/dc/2NcCbXwd_o.png" width="729"></p> 
</div> 
<div> 
 <ul><li><span style="color:#333333;">可以用</span><strong><span style="color:#333333;">explain</span></strong><span style="color:#333333;">工具看一下，是否使用到索引 </span></li></ul> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="335" src="https://images2.imgbox.com/c4/57/1YYjO307_o.png" width="839"></p> 
</div> 
<div> 
 <ul><li><span style="color:#333333;">那如何使用全文索引呢?接下来，我简单的展示一下：</span></li></ul> 
 <pre><code class="language-bash">SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('database');</code></pre> 
 <ul><li>紧接着再去查询一次，<span style="color:#333333;">通过</span><span style="color:#333333;">explain</span><span style="color:#333333;">来分析这个</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句</span>：</li></ul> 
 <p class="img-center"><img alt="" height="323" src="https://images2.imgbox.com/da/f6/ekSR8bWJ_o.png" width="853"></p> 
</div> 
<div> 
 <hr> 
 <p></p> 
</div> 
<div></div> 
<h2 id="%EF%BC%88%E4%BA%94%EF%BC%89%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BD%92%E7%BA%B3">（五）总结与归纳</h2> 
<blockquote> 
 <p><strong>接下来，我们简单的回顾下本文学到的知识内容！！！</strong></p> 
</blockquote> 
<ul><li><strong>索引</strong>是一种数据结构，它能够快速定位到数据表中的特定行，类似于书籍的目录，使得数据库系统不必扫描整个表，而是能够更快地找到所需数据；</li><li>在MySQL中，常见的索引类型包括<span style="color:#333333;">B+</span><span style="color:#333333;">树</span>索引、哈希索引、全文索引等，其中<span style="color:#fe2c24;"><strong>B+树索引</strong></span>是最常用和最常见的索引类型；</li><li>通过使用索引，数据库可以快速定位到需要查询的数据，加速查询速度，特别是在大型数据集的情况下效果显著；不仅能加速查询操作，还能加速排序和数据检索操作，提高数据库的整体性能。</li></ul> 
<blockquote> 
 <p><strong>以上便是本文的全部内容了，感谢大家的观看和支持！！！</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fc/55/r6Yv2ilX_o.gif"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e7582cbfbd07de3210b076421596781/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【LeetCode:69. x 的平方根 | 二分】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83454c4167a97b1882c2343be5a25acb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一文了解 CORS 跨域</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>