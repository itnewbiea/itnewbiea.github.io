<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Merge Sort及应用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Merge Sort及应用" />
<meta property="og:description" content="算法原理 定义merge_sort函数，将数组分为两部分A[left..mid]和A[mid&#43;1..right]，分别对这两部分排序（递归调用merge_sort函数），然后调用merge函数合并这两部分
void merge_sort( vector&lt;int&gt;&amp; A, int left, int right ) { // 如果left == right，说明数组只包含1个元素，不必排序，直接返回 if( left &gt;= right ) // 似乎left == right也没问题 return; int mid = left &#43; ( right - left ) / 2; merge_sort( A, left, mid ); // 递归调用 merge_sort( A, mid &#43; 1, right ); // 递归调用 merge( A, left, mid, right ); } 定义merge函数，将排好序的两部分A[left..mid]和A[mid&#43;1..right]合并起来
void merge( vector&lt;int&gt;&amp; A, int left, int mid, int right ) { // 复制A[left." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d554bc03221d0cdf03355fa13fb7c089/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-27T14:53:40+08:00" />
<meta property="article:modified_time" content="2018-07-27T14:53:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Merge Sort及应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="算法原理">算法原理</h3> 
<p>定义<code>merge_sort</code>函数，将数组分为两部分<code>A[left..mid]</code>和<code>A[mid+1..right]</code>，分别对这两部分排序（递归调用<code>merge_sort</code>函数），然后调用<code>merge</code>函数合并这两部分</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> merge_sort( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; A, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right )
{
    <span class="hljs-comment">// 如果left == right，说明数组只包含1个元素，不必排序，直接返回</span>
    <span class="hljs-keyword">if</span>( left &gt;= right ) <span class="hljs-comment">// 似乎left == right也没问题</span>
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> mid = left + ( right - left ) / <span class="hljs-number">2</span>;

    merge_sort( A, left, mid );         <span class="hljs-comment">// 递归调用</span>
    merge_sort( A, mid + <span class="hljs-number">1</span>, right );    <span class="hljs-comment">// 递归调用</span>
    merge( A, left, mid, right );
}</code></pre> 
<p>定义<code>merge</code>函数，将排好序的两部分<code>A[left..mid]</code>和<code>A[mid+1..right]</code>合并起来</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> merge( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; A, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right )
{
    <span class="hljs-comment">// 复制A[left..mid]和A[mid+1..right]，暂存</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> arr1( A.begin() + left, A.begin() + mid + <span class="hljs-number">1</span> );
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> arr2( A.begin() + mid + <span class="hljs-number">1</span>, A.begin() + right + <span class="hljs-number">1</span> );

    arr1.push_back( INT_MAX );  <span class="hljs-comment">// 末尾加上INT_MAX，作为哨兵</span>
    arr2.push_back( INT_MAX );

    <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 遍历A[left..right]的每个位置，依次填写arr1[p1]或arr2[p2]</span>
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = left; i &lt;= right; i++ )
        <span class="hljs-keyword">if</span>( arr1[p1] &lt;= arr2[p2] )
        {
            A[i] = arr1[p1];
            p1++;
        }
        <span class="hljs-keyword">else</span>
        {
            A[i] = arr2[p2];
            p2++;
        }
}</code></pre> 
<p>完整代码如下</p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;stdio.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;time.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#define MAXN 50</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;



<span class="hljs-keyword">void</span> display( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; s )
{
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++ )
        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"%d "</span>, s[i] );
    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );
}

<span class="hljs-keyword">bool</span> check( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; s1, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; s2 )
{
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.size(); i++ )
        <span class="hljs-keyword">if</span>( s1[i] != s2[i] )
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}



<span class="hljs-keyword">void</span> merge( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; A, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right )
{
    <span class="hljs-comment">// 复制A[left..mid]和A[mid+1..right]，暂存</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> arr1( A.begin() + left, A.begin() + mid + <span class="hljs-number">1</span> );
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> arr2( A.begin() + mid + <span class="hljs-number">1</span>, A.begin() + right + <span class="hljs-number">1</span> );

    arr1.push_back( INT_MAX );  <span class="hljs-comment">// 末尾加上INT_MAX，作为哨兵</span>
    arr2.push_back( INT_MAX );

    <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 遍历A[left..right]的每个位置，依次填写arr1[p1]或arr2[p2]</span>
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = left; i &lt;= right; i++ )
        <span class="hljs-keyword">if</span>( arr1[p1] &lt;= arr2[p2] )
        {
            A[i] = arr1[p1];
            p1++;
        }
        <span class="hljs-keyword">else</span>
        {
            A[i] = arr2[p2];
            p2++;
        }
}

<span class="hljs-keyword">void</span> merge_sort( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; A, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right )
{
    <span class="hljs-comment">// 如果left == right，说明数组只包含1个元素，不必排序，直接返回</span>
    <span class="hljs-keyword">if</span>( left &gt;= right ) <span class="hljs-comment">// 似乎left == right也没问题</span>
        <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">int</span> mid = left + ( right - left ) / <span class="hljs-number">2</span>;

    merge_sort( A, left, mid );         <span class="hljs-comment">// 递归调用</span>
    merge_sort( A, mid + <span class="hljs-number">1</span>, right );    <span class="hljs-comment">// 递归调用</span>
    merge( A, left, mid, right );
}



<span class="hljs-keyword">int</span> main()
{
    srand( (<span class="hljs-keyword">unsigned</span>)time(NULL) );

    <span class="hljs-keyword">int</span> nums[MAXN];

    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++ )
        nums[i] = rand() % <span class="hljs-number">100</span>;

    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> s1( nums, nums + MAXN );
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> s2( nums, nums + MAXN );

    merge_sort( s1, <span class="hljs-number">0</span>, s1.size() - <span class="hljs-number">1</span> );
    sort( s2.begin(), s2.end() );

    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"s1: "</span> );
    display(s1);

    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"s2: "</span> );
    display(s2);

    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"Result: %s\n"</span>, check( s1, s2 ) ? <span class="hljs-string">"Accepted"</span> : <span class="hljs-string">"Wrong Answer"</span> );

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h3 id="算法分析">算法分析</h3> 
<p>时间复杂度：merge_sort函数O(logn)，merge函数O(n)，故时间复杂度为O(nlogn) <br> 空间复杂度：merge_sort函数O(logn)，merge函数O(n)，故O(logn) + O(n) = O(n)</p> 
<h3 id="扩展对链表使用merge-sort-1">扩展：对链表使用Merge Sort</h3> 
<p><a href="https://leetcode.com/problems/sort-list/description/" rel="nofollow">LeetCode 148. Sort List</a></p> 
<pre class="prettyprint"><code class=" hljs lasso">class Solution {
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/*
    链表高级排序，采用归并排序，借用了21. Merge Two Sorted Lists的代码
    */</span>
    ListNode<span class="hljs-subst">*</span> sortList(ListNode<span class="hljs-subst">*</span> head) {
        <span class="hljs-keyword">if</span>( <span class="hljs-subst">!</span>head <span class="hljs-subst">||</span> <span class="hljs-subst">!</span>head<span class="hljs-subst">-&gt;</span>next )
            <span class="hljs-keyword">return</span> head;

        <span class="hljs-comment">// 利用快慢指针，找到中间节点</span>
        ListNode<span class="hljs-subst">*</span> prev <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>, <span class="hljs-subst">*</span>p <span class="hljs-subst">=</span> head, <span class="hljs-subst">*</span>q <span class="hljs-subst">=</span> head;

        <span class="hljs-keyword">while</span>(q)
        {
            prev <span class="hljs-subst">=</span> p;
            p <span class="hljs-subst">=</span> p<span class="hljs-subst">-&gt;</span>next;

            for( int i <span class="hljs-subst">=</span> <span class="hljs-number">0</span>; i <span class="hljs-subst">&lt;</span> <span class="hljs-number">2</span>; i<span class="hljs-subst">++</span> )
            {
                q <span class="hljs-subst">=</span> q<span class="hljs-subst">-&gt;</span>next;

                <span class="hljs-keyword">if</span>( <span class="hljs-subst">!</span>q )
                    break;
            }            
        }

        prev<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> <span class="hljs-built_in">NULL</span>;  <span class="hljs-comment">// 切成两段</span>

        ListNode<span class="hljs-subst">*</span> l1 <span class="hljs-subst">=</span> sortList( head );
        ListNode<span class="hljs-subst">*</span> l2 <span class="hljs-subst">=</span> sortList( p );

        <span class="hljs-keyword">return</span> mergeTwoLists( l1, l2 );
    }

    ListNode<span class="hljs-subst">*</span> mergeTwoLists( ListNode<span class="hljs-subst">*</span> l1, ListNode<span class="hljs-subst">*</span> l2 )
    {
        ListNode<span class="hljs-subst">*</span> head <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> ListNode(<span class="hljs-subst">-</span><span class="hljs-number">1</span>);
        ListNode<span class="hljs-subst">*</span> p <span class="hljs-subst">=</span> l1, <span class="hljs-subst">*</span>q <span class="hljs-subst">=</span> l2, <span class="hljs-subst">*</span>cur <span class="hljs-subst">=</span> head;

        <span class="hljs-keyword">while</span>( p <span class="hljs-subst">&amp;&amp;</span> q )
        {
            <span class="hljs-keyword">if</span>( p<span class="hljs-subst">-&gt;</span>val <span class="hljs-subst">&lt;=</span> q<span class="hljs-subst">-&gt;</span>val )
            {
                cur<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> p;
                p <span class="hljs-subst">=</span> p<span class="hljs-subst">-&gt;</span>next;
            }
            <span class="hljs-keyword">else</span>
            {
                cur<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> q;
                q <span class="hljs-subst">=</span> q<span class="hljs-subst">-&gt;</span>next;
            }

            cur <span class="hljs-subst">=</span> cur<span class="hljs-subst">-&gt;</span>next;
        }

        <span class="hljs-keyword">if</span>( p )
            cur<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> p;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( q )
            cur<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">=</span> q;

        <span class="hljs-keyword">return</span> head<span class="hljs-subst">-&gt;</span>next;
    }
};</code></pre> 
<h3 id="应用求数组中的逆序对">应用：求数组中的逆序对</h3> 
<p>简单版本：<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?qru=/ta/coding-interviews/question-ranking&amp;rp=1&amp;ru=/ta/coding-interviews&amp;tPage=1&amp;tpId=13&amp;tqId=11188" rel="nofollow">nowcoder 数组中的逆序对</a> <br> 在Merge Sort中（具体是在<code>merge</code>函数中）完成逆序对的统计，Merge Sort仍然对整个数组进行递增排序，因此破坏了原数组 <br> <img src="https://images2.imgbox.com/13/65/Qd4unlUP_o.png" alt="这里写图片描述" title=""></p> 
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> Solution {
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> merge( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>&amp; result )
    {
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> arr1( s.begin() + left, s.begin() + mid + <span class="hljs-number">1</span> );
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> arr2( s.begin() + mid + <span class="hljs-number">1</span>, s.begin() + right + <span class="hljs-number">1</span> );

        <span class="hljs-comment">// 因为merge操作是从右向左进行的，因此在最左边插入INT_MIN作为哨兵</span>
        arr1.insert( arr1.begin(), INT_MIN );
        arr2.insert( arr2.begin(), INT_MIN );

        <span class="hljs-keyword">int</span> p1 = arr1.size() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> p2 = arr2.size() - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = right; i &gt;= left; i-- )
            <span class="hljs-keyword">if</span>( arr1[p1] &gt; arr2[p2] )
            {
                result = ( result + p2 ) % <span class="hljs-number">1000000007</span>;  <span class="hljs-comment">// 产生p2对逆序对</span>
                s[i] = arr1[p1];
                p1--;
            }
            <span class="hljs-keyword">else</span>
            {
                s[i] = arr2[p2];
                p2--;
            }
    }

    <span class="hljs-keyword">void</span> merge_sort( <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>&amp; s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>&amp; result )
    {
        <span class="hljs-keyword">if</span>( left &gt;= right )
            <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">int</span> mid = left + ( right - left ) / <span class="hljs-number">2</span>;

        merge_sort( s, left, mid, result );
        merge_sort( s, mid + <span class="hljs-number">1</span>, right, result );
        merge( s, left, mid, right, result );
    }

    <span class="hljs-keyword">int</span> InversePairs(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> data) {
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
        merge_sort( data, <span class="hljs-number">0</span>, data.size() - <span class="hljs-number">1</span>, result );
        <span class="hljs-keyword">return</span> result;
    }
};</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/281e13d341c0151519b944bfc8690d39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">知识是系统的</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1985bdd51c4c19ced18a34bb81e6b414/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">打包Maven项目时出现Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>