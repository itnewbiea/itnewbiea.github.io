<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础篇 第七天 异常、智能指针、nullptr，auto - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础篇 第七天 异常、智能指针、nullptr，auto" />
<meta property="og:description" content="目录
异常
异常概念：
C和C&#43;&#43;中异常的区别
异常处理
1. throw抛出异常
2. try...catch 进行异常处理
3.try...catch抛出自建类的异常
4.自建类的异常延伸
捕获的扩展
提高异常捕获的概率
智能指针
auto_ptr（已废弃，只做了解）
auto_ptr智能指针的方法
弃用原因（了解）：
unique_ptr
shared_ptr
weak_ptr
nullptr
auto 自动推导(基础)
异常 异常概念： C&#43;&#43;的异常是指程序在运行期间出现的问题，编译可以通过，说明代码出现了逻辑问题，而不是语法问题。当程序运行的过程中出现了C&#43;&#43;标准库中预定义的异常现象时，程序会抛出一个异常对象，此对象需要正确地处理，否则会导致运行终止。
C和C&#43;&#43;中异常的区别 1. 异常的语法：C&#43;&#43;中具有原生的异常处理机制，使用`try-catch`块来捕获和处理异常。而C语言并没有内置的异常处理机制，需要使用其他方式来处理错误，如返回错误码、使用全局变量等。
2. 异常类型：C&#43;&#43;中的异常可以是任何类型的对象，包括内置类型、自定义类型、标准库类型等。而C语言中没有内置的异常类型概念，错误通常以错误码或特定的返回值表示。
3. 异常的传播：在C&#43;&#43;中，异常可以在调用栈上进行传播，即从抛出异常的地方一直传播到能够处理异常的地方。而在C语言中，错误处理通常是通过返回错误码或特定值来传递的。
4. 异常处理的开销：由于C&#43;&#43;中的异常处理机制涉及到对象的构造和析构、栈的展开等操作，因此异常处理可能会带来一定的性能开销。而C语言中的错误处理通常更加轻量级，不会引入额外的开销。
#include &lt;iostream&gt; using namespace std; int main() { string s=&#34;hello&#34;; cout&lt;&lt;s.at(0)&lt;&lt;endl; cout&lt;&lt;s.at(10)&lt;&lt;endl; cout&lt;&lt;&#34;程序继续运行。。&#34;&lt;&lt;endl; } 正确的捕获方式
#include &lt;iostream&gt; #include &lt;stdexcept&gt; using namespace std; int main() { string s=&#34;hello&#34;; cout&lt;&lt;s.at(0)&lt;&lt;endl; try{ cout&lt;&lt;s.at(10)&lt;&lt;endl; }catch(out_of_range a){ cout&lt;&lt;a.what()&lt;&lt;endl; } cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5834b56220b6098d44bc1764c479054b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-02T15:31:03+08:00" />
<meta property="article:modified_time" content="2023-08-02T15:31:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础篇 第七天 异常、智能指针、nullptr，auto</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="uECdu-toc" style="margin-left:40px;"><a href="#uECdu" rel="nofollow">异常</a></p> 
<p id="D1exB-toc" style="margin-left:80px;"><a href="#D1exB" rel="nofollow">异常概念：</a></p> 
<p id="QYGIq-toc" style="margin-left:80px;"><a href="#QYGIq" rel="nofollow">C和C++中异常的区别</a></p> 
<p id="ex8QE-toc" style="margin-left:80px;"><a href="#ex8QE" rel="nofollow">异常处理</a></p> 
<p id="um8gW-toc" style="margin-left:120px;"><a href="#um8gW" rel="nofollow">1. throw抛出异常</a></p> 
<p id="W8FN0-toc" style="margin-left:120px;"><a href="#W8FN0" rel="nofollow">2. try...catch 进行异常处理</a></p> 
<p id="faT6N-toc" style="margin-left:120px;"><a href="#faT6N" rel="nofollow">3.try...catch抛出自建类的异常</a></p> 
<p id="iIc2W-toc" style="margin-left:120px;"><a href="#iIc2W" rel="nofollow">4.自建类的异常延伸</a></p> 
<p id="NMWKY-toc" style="margin-left:80px;"><a href="#NMWKY" rel="nofollow">捕获的扩展</a></p> 
<p id="XzLTh-toc" style="margin-left:80px;"><a href="#XzLTh" rel="nofollow">提高异常捕获的概率</a></p> 
<p id="F5rUo-toc" style="margin-left:40px;"><a href="#F5rUo" rel="nofollow">智能指针</a></p> 
<p id="iJdY0-toc" style="margin-left:80px;"><a href="#iJdY0" rel="nofollow">auto_ptr（已废弃，只做了解）</a></p> 
<p id="q0Gd2-toc" style="margin-left:120px;"><a href="#q0Gd2" rel="nofollow">auto_ptr智能指针的方法</a></p> 
<p id="rEoL3-toc" style="margin-left:120px;"><a href="#rEoL3" rel="nofollow">弃用原因（了解）：</a></p> 
<p id="i6lSv-toc" style="margin-left:80px;"><a href="#i6lSv" rel="nofollow">unique_ptr</a></p> 
<p id="puQ5U-toc" style="margin-left:80px;"><a href="#puQ5U" rel="nofollow">shared_ptr</a></p> 
<p id="ZFM4X-toc" style="margin-left:80px;"><a href="#ZFM4X" rel="nofollow">weak_ptr</a></p> 
<p id="CRki4-toc" style="margin-left:40px;"><a href="#CRki4" rel="nofollow">nullptr</a></p> 
<p id="urnBz-toc" style="margin-left:40px;"><a href="#urnBz" rel="nofollow">auto 自动推导(基础)</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3><br><strong>异常</strong></h3> 
<h4 id="D1exB"><strong>异常概念：</strong></h4> 
<p id="ud9c09fb5">C++的异常是指程序在运行期间出现的问题，编译可以通过，说明<strong>代码出现了逻辑问题</strong>，而<strong>不是语法问题</strong>。当程序运行的过程中出现了C++标准库中预定义的异常现象时，程序会抛出一个异常对象，此对象需要正确地处理，否则会导致运行终止。</p> 
<h4 id="QYGIq">C和C++中异常的区别</h4> 
<p id="ucc2d8e2a">1. 异常的语法：C++中具有原生的异常处理机制，使用`<code>try-catch</code>`块来捕获和处理异常。而C语言并没有内置的异常处理机制，需要使用其他方式来处理错误，如返回错误码、使用全局变量等。</p> 
<p id="u84c3f707">2. 异常类型：C++中的异常可以是任何类型的对象，包括<strong>内置类型、自定义类型、标准库类型</strong>等。而C语言中没有内置的异常类型概念，错误通常以错误码或特定的返回值表示。</p> 
<p id="u7caf52c7">3. 异常的传播：在C++中，异常可以在调用栈上进行传播，即从抛出异常的地方一直传播到能够处理异常的地方。而在C语言中，错误处理通常是通过返回错误码或特定值来传递的。</p> 
<p id="ubac3e2ae">4. 异常处理的开销：由于<strong>C++中的异常处理机制涉及到对象的构造和析构</strong>、栈的展开等操作，因此异常处理可能会带来一定的性能开销。而C语言中的错误处理通常更加轻量级，不会引入额外的开销。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main()
{
    string s="hello";
    cout&lt;&lt;s.at(0)&lt;&lt;endl;
    cout&lt;&lt;s.at(10)&lt;&lt;endl; 
    cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl;
}</code></pre> 
<p id="u60c20207"></p> 
<p class="img-center"><img alt="" height="120" id="ud97d3e9a" src="https://images2.imgbox.com/af/97/xbmHtbrj_o.png" width="630"></p> 
<p id="ucfcfcca6">正确的捕获方式</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

int main()
{
    string s="hello";
    cout&lt;&lt;s.at(0)&lt;&lt;endl;
    try{
        cout&lt;&lt;s.at(10)&lt;&lt;endl;
    }catch(out_of_range a){
        cout&lt;&lt;a.what()&lt;&lt;endl;
    }
    cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl;
}</code></pre> 
<p id="ucd41df68"></p> 
<p class="img-center"><img alt="" height="116" id="u73cf3f1a" src="https://images2.imgbox.com/f5/8b/AeUvk0Eq_o.png" width="590"></p> 
<h4 id="ex8QE"><strong>异常处理</strong></h4> 
<h5 id="um8gW">1. throw抛出异常</h5> 
<p id="u890c6c4f">可以抛出任意类型的异常，抛给程序调用者，如果出现异常，调用者需要处理，否则程序就会终止。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void division(double a,double b)
{
    if(b==0){
        throw 'e'; 
    }
    cout&lt;&lt;a/b&lt;&lt;endl;
}
int main()
{
    double a=3;
    double b=2;
    division(a,b);
    b=0;
    division(a,b);
    cout&lt;&lt;"程序继续运行"&lt;&lt;endl;
}</code></pre> 
<p class="img-center"><img alt="" height="91" id="u201f94b0" src="https://images2.imgbox.com/08/f9/X35k00TQ_o.png" width="458"></p> 
<h5 id="W8FN0"><br> 2. try...catch 进行异常处理</h5> 
<p id="u92ed9a45">使用try-catch代码块进行异常的捕获，try代码块表示尝试执行可能出现异常的代码，catch块表示如果try块中出现了异常，则与catch块捕获的异常类型进行匹配，如果匹配成功，则进入catch块，如果匹配失败，程序仍然终止。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
void division(double a,double b){
    if(b==0){
        throw 'e'; 
    }
    cout&lt;&lt;a/b&lt;&lt;endl;
}
int main()
{
    double a=3;
    double b=2;
    division(a,b);
    b=0;
    try{
        division(a,b);
    }catch(char e){
        cout&lt;&lt;"异常已经处理，可以继续运行"&lt;&lt;endl;
    }
    cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl;
}</code></pre> 
<p id="ufc1421f9"></p> 
<p class="img-center"><img alt="" height="120" id="u1c4bd257" src="https://images2.imgbox.com/fa/d0/AP41dbvW_o.png" width="328"></p> 
<h5 id="faT6N">3.<strong>try</strong>...<strong>catch</strong>抛出自建类的异常</h5> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class DivisionByZero{
private:
    string message;
public:
    DivisionByZero(string message){
        this-&gt;message=message;
    }
    void getMsg(){
        cout&lt;&lt;message&lt;&lt;endl;
    }
};
void division(double a,double b){
    if(b==0){
        throw DivisionByZero("你除0出现了错误！");
    }
    cout&lt;&lt;a/b&lt;&lt;endl;
}
int main()
{
    double a=3;
    double b=2;
    division(a,b);
    b=0;
    division(a,b);
    cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl;
}</code></pre> 
<p id="u1e9295db"></p> 
<p class="img-center"><img alt="" height="94" id="u7e2e8ec3" src="https://images2.imgbox.com/b0/af/iIOB06Ta_o.png" width="588"></p> 
<h5 id="iIc2W">4.自建类的异常延伸</h5> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class DivisionByZero{
private:
    string message;
public:
    DivisionByZero(string message){
        this-&gt;message=message;
    }
    void getMsg(){
        cout&lt;&lt;message&lt;&lt;endl;
    }
};
void division(double a,double b){
    if(b==0){
        //throw 'a';
        throw DivisionByZero("你除0出现了错误！");
    }
    cout&lt;&lt;a/b&lt;&lt;endl;
}
int main()
{
    double a=3;
    double b=2;
    division(a,b);
    b=0;
    try{
        division(a,b);
    }catch(DivisionByZero e){
        e.getMsg();
        cout&lt;&lt;"这里是处理的方式。。。"&lt;&lt;endl;
    }
    cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl;
}</code></pre> 
<p id="u212781f1"></p> 
<p class="img-center"><img alt="" height="128" id="uf9853b9e" src="https://images2.imgbox.com/cb/9c/doceWBqM_o.png" width="339"></p> 
<h4 id="NMWKY">捕获的扩展</h4> 
<p id="u7762d467"></p> 
<p class="img-center"><img alt="" height="629" id="ud0d2f18d" src="https://images2.imgbox.com/12/5c/azJT8hYl_o.png" width="559"></p> 
<h4 id="XzLTh"></h4> 
<p class="img-center"><img alt="" height="695" id="u15185eca" src="https://images2.imgbox.com/85/94/Jn4pQQe7_o.png" width="793"></p> 
<h4><br> 提高异常捕获的概率</h4> 
<p id="u238397af">1. 准确标识可能引发异常的代码块：<br> 在编写代码时，要<strong>仔细考虑可能引发异常</strong>的地方，并将其放置在适当的`<code><strong>try</strong></code>`块中。这样可以确保异常被正确捕获，并且避免在不应该捕获异常的地方捕获它们。</p> 
<p id="u5556ff5a">2. 使用更具体的异常类型：<br> 在抛出异常时，尽量使用更具体的异常类型，而不是通用的`<code><strong>std::exception</strong></code>`。这样可以使异常处理更加精确和灵活，以便针对不同类型的异常采取不同的处理方式。</p> 
<p id="u241193df">3. 捕获异常的顺序：</p> 
<p id="uba1769b7">在使用多个`<code><strong>catch</strong></code>`块捕获异常时，应该将最具体的异常类型的`<code>catch</code>`块放在前面，而将更通用的异常类型的`catch`块放在后面。这样可以确保异常被正确地捕获，并避免被更通用的异常类型所捕获。</p> 
<p id="ud8ee6b44">4. 使用<strong>异常基类捕获多个异常</strong>：</p> 
<p id="ude9e66f4">如果有多个异常类型具有相似的处理方式，可以使用异常基类来捕获它们。这样可以减少重复的代码，并提高异常捕获的概率。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;
class DivisionByZero{
private:
    string message;
public:
    DivisionByZero(string message){
        this-&gt;message=message;
    }
    void getMsg(){
        cout&lt;&lt;message&lt;&lt;endl;
    }
};
void division(double a,double b){
    if(b==0){
        throw DivisionByZero("你除0出现了错误！");
    }
    cout&lt;&lt;a/b&lt;&lt;endl;
}
int main()
{
    double a=3;
    double b=2;
    division(a,b);
    b=0;
    try{
        division(a,b);
    }catch(const length_error e ){
        cout&lt;&lt;1&lt;&lt;endl;
    }catch(const logic_error e){
        cout&lt;&lt;2&lt;&lt;endl;
    }catch(const exception e){
        cout&lt;&lt;3&lt;&lt;endl;
    }catch(...){
        cout&lt;&lt;4&lt;&lt;endl;
    }
    cout&lt;&lt;"程序继续运行。。"&lt;&lt;endl;
}</code></pre> 
<p id="uf8a27118"></p> 
<p class="img-center"><img alt="" height="129" id="ud91e9482" src="https://images2.imgbox.com/49/8e/ix82jidF_o.png" width="341"></p> 
<h3 id="F5rUo"><strong>智能指针</strong></h3> 
<p id="u5ad42c48">C++智能指针的存在可以提供自动化的内存管理、异常安全性、简化代码、防止悬空指针以及共享所有权等好处，使得C++编程更加方便、安全和高效。</p> 
<p id="ud7ba26c3">智能指针主要用于<strong>管理堆内存对象</strong>的生命周期，本身<strong>指针对象是位于栈内存</strong>的对象。</p> 
<p id="ub05380e7">智能指针需要引入头文件<code><strong>#include &lt;memory&gt;</strong></code> ，智能指针管理的new关键字创建的堆内存对象</p> 
<h4 id="iJdY0"><strong>auto_ptr（已废弃，只做了解）</strong></h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class Test{
private:
    string str;
public:
    Test(string s):str(s){}
    ~Test(){
        cout&lt;&lt;str&lt;&lt;"销毁了"&lt;&lt;endl;
    }
};
int main()
{
    {
       Test t("A");
       Test * t2=new Test("B");
//       传统手动销毁对象内存
//       delete t2;
//       t2=NULL;
       auto_ptr &lt;Test&gt; ap1(t2); //智能指针自动管理
    }
}</code></pre> 
<h5 id="q0Gd2">auto_ptr智能指针的方法</h5> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class Test{
private:
    string str;
public:
    Test(string s):str(s){}
    ~Test(){
        cout&lt;&lt;str&lt;&lt;"销毁了"&lt;&lt;endl;
    }
    void show(){
        cout&lt;&lt;"str的值是："&lt;&lt;str&lt;&lt;endl;
    }
};
int main()
{
    {
        //第一种构造方式
       Test * t1=new Test("B");
       auto_ptr &lt;Test&gt; ap1(t1); //智能指针自动管理
       //第二种构造方式
       auto_ptr &lt;Test&gt; ap2(new Test("C"));
       //get()方法可以得到管理的堆内存对象的地址
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;t1&lt;&lt;endl;  //0xee17c0 0xee17c0
       ap2.get()-&gt;show(); //str的值是：C
       //reset()方法  放弃之间对象的管理权，会把之前对象的内存释放
       ap2.reset(new Test("D"));
       cout&lt;&lt;"------------"&lt;&lt;endl;
       //release()方式 释放的管理权.但是管理对象内存不会释放
       ap1.release();
       delete t1;
       t1=NULL;
    }
}</code></pre> 
<p id="uc82f8685"></p> 
<p class="img-center"><img alt="" height="422" id="ua7921040" src="https://images2.imgbox.com/39/dd/SDKZMveZ_o.png" width="1200"></p> 
<p id="u1fd63b2b">这个<strong>警告</strong>说明auto_ptr已经被废弃了</p> 
<h5 id="rEoL3">弃用原因（了解）：</h5> 
<p id="u90feee41">1. 潜在的资源所有权转移问题：`std::auto_ptr` 允许资源的所有权在拷贝或赋值时进行转移。这意味着当您将一个 `std::auto_ptr` 赋值给另一个 `std::auto_ptr` 或者将其作为函数参数传递时，原始指针的所有权会被转移给新的 `std::auto_ptr`。这可能导致潜在的所有权混乱和资源释放问题。</p> 
<p id="ud9c6726c">2. 缺乏拷贝语义：`std::auto_ptr` 不支持拷贝构造函数和拷贝赋值运算符。这意味着无法直接通过拷贝 `std::auto_ptr` 对象来创建新的对象，限制了它的使用场景。</p> 
<p id="u4b90c18e">3. 不适用于标准容器：由于 `std::auto_ptr` 的所有权转移特性，它不能与标准容器（如 `std::vector` 或 `std::map`）一起使用。将 `std::auto_ptr` 存储在容器中会导致资源的所有权混乱和未定义行为。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class Test{
private:
    string str;
public:
    Test(string s):str(s){}
    ~Test(){
        cout&lt;&lt;str&lt;&lt;"销毁了"&lt;&lt;endl;
    }
    void show(){
        cout&lt;&lt;"str的值是："&lt;&lt;str&lt;&lt;endl;
    }
};
int main()
{
    {
        //第一种构造方式
       Test * t1=new Test("B");
       auto_ptr &lt;Test&gt; ap1(t1); //智能指针自动管理
       cout&lt;&lt;t1&lt;&lt;endl;
       cout&lt;&lt;ap1.get()&lt;&lt;endl;    //0x6e17c0

       auto_ptr &lt;Test&gt; ap2(ap1); //拷贝构造
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;ap2.get()&lt;&lt;endl; //0 0x6e17c0

       auto_ptr&lt;Test&gt; ap3=ap2;  //隐式的拷贝构造
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;ap2.get()&lt;&lt;" "&lt;&lt;ap3.get()&lt;&lt;endl;

       auto_ptr&lt;Test&gt; ap4;
       ap4=ap3;  //等号赋值
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;ap2.get()&lt;&lt;" "&lt;&lt;ap3.get()&lt;&lt;" "&lt;&lt;ap4.get()&lt;&lt;endl;

    }
}</code></pre> 
<p id="u831e5d49"></p> 
<p class="img-center"><img alt="" height="152" id="ub2a0c85e" src="https://images2.imgbox.com/d4/47/2eSW2dFL_o.png" width="465"></p> 
<h4 id="i6lSv">unique_ptr</h4> 
<p id="ua70c35d7">解决了auto_ptr复制语义发生控制权转移的问题，如需转移可以使用move的方式</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class Test{
private:
    string str;
public:
    Test(string s):str(s){}
    ~Test(){
        cout&lt;&lt;str&lt;&lt;"销毁了"&lt;&lt;endl;
    }
    void show(){
        cout&lt;&lt;"str的值是："&lt;&lt;str&lt;&lt;endl;
    }
};
int main()
{
    {
        //第一种构造方式
       Test * t1=new Test("B");
       unique_ptr &lt;Test&gt; ap1(t1); //智能指针自动管理
       cout&lt;&lt;t1&lt;&lt;endl;
       cout&lt;&lt;ap1.get()&lt;&lt;endl;

       //unique_ptr &lt;Test&gt; ap2(ap1); //拷贝构造
       unique_ptr &lt;Test&gt; ap2(move(ap1));
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;ap2.get()&lt;&lt;endl;

       //unique_ptr&lt;Test&gt; ap3=ap2;  //隐式的拷贝构造
       unique_ptr&lt;Test&gt; ap3=move(ap2);
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;ap2.get()&lt;&lt;" "&lt;&lt;ap3.get()&lt;&lt;endl;

       unique_ptr&lt;Test&gt; ap4;
       //ap4=ap3;  //等号赋值
       ap4=move(ap3);
       cout&lt;&lt;ap1.get()&lt;&lt;" "&lt;&lt;ap2.get()&lt;&lt;" "&lt;&lt;ap3.get()&lt;&lt;" "&lt;&lt;ap4.get()&lt;&lt;endl;

    }
}</code></pre> 
<p id="uba98a7ce"></p> 
<p class="img-center"><img alt="" height="135" id="u2c79162e" src="https://images2.imgbox.com/71/32/Q4KlObPV_o.png" width="315"></p> 
<h4 id="puQ5U">shared_ptr</h4> 
<p id="ucea58a1a">一个资源在多个指针之间共享。</p> 
<p id="ue1e0e0cb">每当有一个智能指针管理资源的时候 ,使用计数加1，当一个智能智能释放管理权的时候，使用计数就减1</p> 
<p id="ue75f10d5">当使用计数的为0的时候，此时资源没有被使用，这时才会销毁</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class Test{
private:
    string str;
public:
    Test(string s):str(s){}
    ~Test(){
        cout&lt;&lt;str&lt;&lt;"销毁了"&lt;&lt;endl;
    }
    void show(){
        cout&lt;&lt;"str的值是："&lt;&lt;str&lt;&lt;endl;
    }
};
int main()
{
    {
        //第一种构造方式
       Test * t1=new Test("B");
       shared_ptr &lt;Test&gt; sp1(t1);
       cout&lt;&lt;sp1.get()&lt;&lt;endl; //0x10217c0
       cout&lt;&lt;sp1.use_count()&lt;&lt;endl; //1
       shared_ptr &lt;Test&gt; sp2(sp1);
       cout&lt;&lt;sp1.use_count()&lt;&lt;" "&lt;&lt;sp2.use_count()&lt;&lt;endl;//2 2

       shared_ptr &lt;Test&gt; sp3=sp2;
       cout&lt;&lt;sp1.use_count()&lt;&lt;" "&lt;&lt;sp2.use_count()&lt;&lt;" "&lt;&lt;sp3.use_count()&lt;&lt;endl; //3 3 3

       shared_ptr &lt;Test&gt; sp4=sp3;
       cout&lt;&lt;sp1.use_count()&lt;&lt;" "&lt;&lt;sp2.use_count()
          &lt;&lt;" "&lt;&lt;sp3.use_count()&lt;&lt;" "&lt;&lt;sp4.use_count()&lt;&lt;endl; //4 4 4 4

       sp4.reset(); //sp4释放管理权 使用计数减1
       cout&lt;&lt;sp1.use_count()&lt;&lt;" "&lt;&lt;sp2.use_count()
          &lt;&lt;" "&lt;&lt;sp3.use_count()&lt;&lt;" "&lt;&lt;sp4.use_count()&lt;&lt;endl;//3 3 3 0
    }
}</code></pre> 
<p id="uec36da49"></p> 
<p class="img-center"><img alt="" height="173" id="uc77d7210" src="https://images2.imgbox.com/22/95/c9EOSVa1_o.png" width="387"></p> 
<h4 id="ZFM4X">weak_ptr</h4> 
<p id="u79f095b7">用于解决 `<code>shared_ptr</code>` 的循环引用问题，并提供了对被 `<code>shared_ptr</code>` 管理的对象的弱引用</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class Test {
private:
    string str;
public:
    Test(string s) : str(s) {}
    ~Test() {
        cout &lt;&lt; str &lt;&lt; "销毁了" &lt;&lt; endl;
    }
    void show() {
        cout &lt;&lt; "str的值是：" &lt;&lt; str &lt;&lt; endl;
    }
};

int main() {
    {
        shared_ptr&lt;Test&gt; sp1 = make_shared&lt;Test&gt;("B");
        cout &lt;&lt; sp1.get() &lt;&lt; endl; // 输出：0x10217c0
        cout &lt;&lt; sp1.use_count() &lt;&lt; endl; // 输出：1
        shared_ptr&lt;Test&gt; sp2 = sp1;
        cout &lt;&lt; sp1.use_count() &lt;&lt; " " &lt;&lt; sp2.use_count() &lt;&lt; endl; // 输出：2 2
        shared_ptr&lt;Test&gt; sp3 = sp2;
        cout &lt;&lt; sp1.use_count() &lt;&lt; " " &lt;&lt; sp2.use_count() &lt;&lt; " " &lt;&lt; sp3.use_count() &lt;&lt; endl; // 输出：3 3 3
        weak_ptr&lt;Test&gt; wp1 = sp3;
        cout &lt;&lt; sp1.use_count() &lt;&lt; " " &lt;&lt; sp2.use_count() &lt;&lt; " " &lt;&lt; sp3.use_count() &lt;&lt; " " &lt;&lt; wp1.use_count() &lt;&lt; endl; // 输出：3 3 3 3
        shared_ptr&lt;Test&gt; sp4 = wp1.lock();
        cout &lt;&lt; sp1.use_count() &lt;&lt; " " &lt;&lt; sp2.use_count() &lt;&lt; " " &lt;&lt; sp3.use_count() &lt;&lt; " " &lt;&lt; wp1.use_count() &lt;&lt; endl; // 输出：4 4 4 4
        sp4.reset(); // 释放 sp4 的管理权，使用计数减 1
        cout &lt;&lt; sp1.use_count() &lt;&lt; " " &lt;&lt; sp2.use_count() &lt;&lt; " " &lt;&lt; sp3.use_count() &lt;&lt; " " &lt;&lt; wp1.use_count() &lt;&lt; endl; // 输出：3 3 3 3
    }
}</code></pre> 
<p id="u22363f4d"></p> 
<p class="img-center"><img alt="" height="197" id="u88d8b3bb" src="https://images2.imgbox.com/5c/4d/k4SkgsMo_o.png" width="425"></p> 
<h3 id="CRki4">nullptr</h3> 
<p id="ua4474f88">` <code><strong>nullptr</strong></code>` 是 C++11 引入的空指针常量。它是一个特殊的关键字，用于表示一个空指针。</p> 
<p id="u1abd0b02">为什么引入<code><strong>nullptr</strong></code>？</p> 
<p id="ubfd939dd">在早期的 C++ 版本中，通常使用宏 `<code>NULL</code>` 或整数常量 0 来表示空指针。然而，这种表示方式容易引起一些问题，因为整数类型可以隐式转换为指针类型，可能会导致错误的解释。</p> 
<p id="uf4d6d063">为了解决这个问题，并提供更明确和类型安全的空指针表示，C++11 引入了 `<code>nullptr</code>`。它是一个特殊的关键字，表示一个空指针常量，具有明确的空指针类型。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
void test(char * ch){
    cout&lt;&lt;"1"&lt;&lt;endl;
}
void test(int n){
    cout&lt;&lt;"2"&lt;&lt;endl;
}
int main()
{
    char * a=NULL;
    test(a);   			//1
    test(NULL); 		//2

    char * b=nullptr; 	//1
    test(b);
    test(nullptr); 		//1
}</code></pre> 
<h3 id="urnBz">auto 自动推导(基础)</h3> 
<p id="uae5d75f2">auto不能做参数类型的推导，也不能推断表达式的类型和数组</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;map&gt;
using namespace std;

int main()
{
    int a=10;
    auto b=10;
    cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;

    map&lt;string,int&gt; mp;
    mp.insert(pair&lt;string,int&gt;("age",20));
    mp.insert(pair&lt;string,int&gt;("height",170));
    mp.insert(pair&lt;string,int&gt;("weight",60));
    //map&lt;string,int&gt;::iterator ite=mp.begin();
    auto ite=mp.begin();
    for(;ite!=mp.end();ite++){
        cout&lt;&lt;ite-&gt;first&lt;&lt;" "&lt;&lt;ite-&gt;second&lt;&lt;endl;
    }
}</code></pre> 
<p id="u99c44a90"></p> 
<p class="img-center"><img alt="" height="117" id="u5d005eff" src="https://images2.imgbox.com/71/21/Dl4RmXaP_o.png" width="301"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/611e599805ebd4df1fc2274790400575/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">List集合删除指定元素-四种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f10baadef6924f3c7b2f8660c9dae88/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">了解什么是PR</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>