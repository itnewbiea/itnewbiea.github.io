<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构OJ实验4-队列 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构OJ实验4-队列" />
<meta property="og:description" content="A. DS队列之银行排队 题目描述 在银行营业大厅共服务3种客户，类型为A\B\C，大厅分别设置了3个窗口分别服务三种客户，即每个窗口只服务一种客户。现有一批客户来银行办理业务，每个客户都有类型和办理业务时间。每个窗口按照客户到来的顺序进行服务。
编程实现它们的办理流程，请使用C&#43;&#43;自带的queue必须使用队列实现，其他方法0分！
队列queue的用法如下：
1.包含头文件：#include &lt;queue&gt;
2.定义一个整数队列对象：queue&lt;int&gt; myQe;
3.定义一个整数队列对象数组：queue&lt;int&gt; myQA[10];
4.入队操作：myQe.push(itemp); //把整数itemp进入队列
5.出队操作：myQe.pop(); //把队头元素弹出队列，注意本操作不获取队头元素
6.获取队头元素： itemp = myQe.front(); // 把队头元素放入itemp中，注意本操作不弹出元素
7.判断队列是否为空：myQe.empty();//队列空则返回true，不空则返回false
输入 第一行输入先输入n表示客户数量
第二行输入每个客户的类型，数据之间用用空格隔开
第三行输入每个客户的办理时间，数据之间用用空格隔开
输出 第一行输出A类客户的平均办理时间
第二行输出B类客户的平均办理时间
第三行输出C类客户的平均办理时间
样例查看模式 正常显示查看格式
输入样例1 8
A B C B C A A A
10 20 30 40 50 60 70 80
输出样例1 55
30
40
AC代码 #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;map&gt; using namespace std; int main() { int n; cin &gt;&gt; n; queue&lt;char&gt;q; map&lt;int, int&gt;mp; for (int i = 0; i &lt; n; i&#43;&#43;) { char x; cin &gt;&gt; x; q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c666ea3485c3f1df73b560b082e78004/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T10:34:29+08:00" />
<meta property="article:modified_time" content="2024-01-01T10:34:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构OJ实验4-队列</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>A. DS队列之银行排队</h3> 
<h4>题目描述</h4> 
<p>在银行营业大厅共服务3种客户，类型为A\B\C，大厅分别设置了3个窗口分别服务三种客户，即每个窗口只服务一种客户。现有一批客户来银行办理业务，每个客户都有类型和办理业务时间。每个窗口按照客户到来的顺序进行服务。</p> 
<p>编程实现它们的办理流程，请使用C++自带的queue<strong>必须使用队列实现，其他方法0分！</strong></p> 
<p>队列queue的用法如下：</p> 
<p>1.包含头文件：#include &lt;queue&gt;</p> 
<p>2.定义一个整数队列对象：queue&lt;int&gt;  myQe;</p> 
<p>3.定义一个整数队列对象数组：queue&lt;int&gt;  myQA[10];</p> 
<p>4.入队操作：myQe.push(itemp); //把整数itemp进入队列</p> 
<p>5.出队操作：myQe.pop();  //把队头元素弹出队列，注意本操作不获取队头元素</p> 
<p>6.获取队头元素： itemp = myQe.front(); // 把队头元素放入itemp中，注意本操作不弹出元素</p> 
<p>7.判断队列是否为空：myQe.empty();//队列空则返回true，不空则返回false</p> 
<h4>输入</h4> 
<p>第一行输入先输入n表示客户数量</p> 
<p>第二行输入每个客户的类型，数据之间用用空格隔开</p> 
<p>第三行输入每个客户的办理时间，数据之间用用空格隔开</p> 
<h4>输出</h4> 
<p>第一行输出A类客户的平均办理时间</p> 
<p>第二行输出B类客户的平均办理时间</p> 
<p>第三行输出C类客户的平均办理时间</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>8<br> A B C B C A A A<br> 10 20 30 40 50 60 70 80</p> 
<h4>输出样例1</h4> 
<p>55<br> 30<br> 40</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
using namespace std;
int main()
{
	int n;
	cin &gt;&gt; n;
	queue&lt;char&gt;q;
	map&lt;int, int&gt;mp;
	for (int i = 0; i &lt; n; i++)
	{
		char x;
		cin &gt;&gt; x;
		q.push(x);
	}
	for (int i = 0; i &lt; n; i++)
	{
		int x;
		cin &gt;&gt; x;
		mp[i] = x;
	}
	int sumA = 0,cntA=0;
	int sumB = 0,cntB=0;
	int sumC = 0,cntC=0;
	int idx = 0;
	while (!q.empty())
	{
		auto t = q.front();
		q.pop();
		if (t == 'A')
		{
			sumA += mp[idx];
			cntA++;
		}
		else if (t == 'B')
		{
			sumB += mp[idx];
			cntB++;
		}
		else
		{
			sumC += mp[idx];
			cntC++;
		}
		idx++;
	}
	cout &lt;&lt; sumA / cntA &lt;&lt; endl;
	cout &lt;&lt; sumB / cntB &lt;&lt; endl;
	cout &lt;&lt; sumC / cntC &lt;&lt; endl;
	return 0;
}
</code></pre> 
<h3>B. DS队列+堆栈--数制转换</h3> 
<h4>题目描述</h4> 
<p>对于任意十进制数转换为k进制，包括整数部分和小数部分转换。整数部分采用除k求余法，小数部分采用乘k取整法例如x=19.125，求2进制转换</p> 
<pre><code>整数部分19，					小数部分0.125
19 / 2 = 9 … 1					0.125 * 2 = 0.25 … 0
9 / 2 = 4 … 1					0.25 * 2 = 0.5   … 0
4 / 2 = 2 … 0 					0.5 * 2 = 1     … 1
2 / 2 = 1 … 0
1 / 2 = 0 … 1
</code></pre> 
<p>所以整数部分转为 10011，小数部分转为0.001，合起来为10011.001</p> 
<p>提示整数部分可用堆栈，小数部分可用队列实现</p> 
<p><strong>注意：必须按照上述方法来实现数制转换，其他方法0分</strong></p> 
<h4>输入</h4> 
<p>第一行输入一个t，表示下面将有t组测试数据。</p> 
<p>接下来每行包含两个参数n和k，n表示要转换的数值，可能是非整数；k表示要转换的数制，1&lt;k&lt;=16</p> 
<h4>输出</h4> 
<p>对于每一组测试数据，每行输出转换后的结果，结果精度到小数点后3位</p> 
<p>输出小数点后几位的代码如下：</p> 
<p>#include &lt;iostream&gt;<br> #include &lt;iomanip&gt;<br> using namespace std;</p> 
<p>int main()<br> {<!-- --><br> double r = 123.56789;<br> cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;r&lt;&lt;endl;   //输出小数点后4</p> 
<p>return 0;<br> }</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>2<br> 19.125 2<br> 15.125 16</p> 
<h4>输出样例1</h4> 
<p>10011.001<br> F.200</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;iomanip&gt;
using namespace std;
char num[18] = {
'0','1','2','3','4','5','6','7','8','9',
'A','B','C','D','E','F' };//最多16进制
void transform(double n, int k)
{
	//整数-&gt;先除的为个位（最后输出）-&gt;栈
	//小数-&gt;先乘的为首位（首先输出）-&gt;队列
	stack&lt;char&gt;z;
	queue&lt;char&gt;x;
	int zhen = (int)n;
	double fen = n - zhen;
	while (zhen != 0)
	{
		z.push(num[zhen % k]);
		zhen /= k;
	}
	int check = 5;//可能取不到0
	while (fen != 0)
	{
		check--;
		if (check == 1)break;
		fen *= k;
		x.push(num[(int)fen]);
		fen = fen - (int)fen;
	}
    if (z.empty())
    {
        cout &lt;&lt; "0.";
    }
    else
    {
        while (!z.empty())
        {
            cout &lt;&lt; z.top();//最后即首个
            z.pop();
        }
        cout &lt;&lt; ".";
    }
    if (x.empty())
    {
        cout &lt;&lt; "000";
    }
    else
    {
        for (int i = 1; i &lt;= 3; i++)
        {
            if (x.empty())
            {
                cout &lt;&lt; "0";
            }
            else
            {
                cout &lt;&lt; x.front();
                x.pop();
            }
        }
    }
    cout &lt;&lt; endl;
}
int main()
{
	int t;
	cin &gt;&gt; t;
	while (t--)
	{
		double n;
		int k;
		cin &gt;&gt; n &gt;&gt; k;
        transform(n, k);
	}
	return 0;
}
</code></pre> 
<h3>C. 银行业务队列简单模拟</h3> 
<h4>题目描述</h4> 
<p>设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。</p> 
<h4>输入</h4> 
<p>输入为一行正整数，其中第1个数字N(≤1000)为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。</p> 
<h4>输出</h4> 
<p>按业务处理完成的顺序输出顾客的编号。数字间以空格分隔，但最后一个编号后不能有多余的空格。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>8 2 1 3 9 4 11 13 15</p> 
<h4>输出样例1</h4> 
<p>1 3 2 9 11 4 13 15</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;iomanip&gt;
using namespace std;
int main()
{
	int n;
	cin &gt;&gt; n;
	queue&lt;int&gt;a;
	queue&lt;int&gt;b;
	vector&lt;int&gt;ans;
	for (int i = 0; i &lt; n; i++)
	{
		int x;
		cin &gt;&gt; x;
		if (x % 2)a.push(x);
		else b.push(x);
	}
	int cnt = 0;
	while (!a.empty())
	{
		ans.push_back(a.front());
		a.pop();
		cnt++;
		if (cnt == 2)
		{
			if (!b.empty())
			{
				ans.push_back(b.front());
				b.pop();
			}
			cnt = 0;
		}
	}
	while (!b.empty())
	{
		ans.push_back(b.front());
		b.pop();
	}
	for (int i = 0; i &lt; n; i++)
	{
		cout &lt;&lt; ans[i];
		if (i != n - 1)cout &lt;&lt; " ";
		else cout &lt;&lt; endl;
	}
	return 0;
}
</code></pre> 
<h3>D. 银行排队问题之单队列多窗口加VIP服务</h3> 
<h4>题目描述</h4> 
<p>假设银行有K个窗口提供服务，窗口前设一条黄线，所有顾客按到达时间在黄线后排成一条长龙。当有窗口空闲时，下一位顾客即去该窗口处理事务。当有多个窗口可选择时，假设顾客总是选择编号最小的窗口。</p> 
<p>有些银行会给VIP客户以各种优惠服务，例如专门开辟VIP窗口。为了最大限度地利用资源，VIP窗口的服务机制定义为：当队列中没有VIP客户时，该窗口为普通顾客服务；当该窗口空闲并且队列中有VIP客户在等待时，排在最前面的VIP客户享受该窗口的服务。同时，当轮到某VIP客户出列时，若VIP窗口非空，该客户可以选择空闲的普通窗口；否则一定选择VIP窗口。</p> 
<p>本题要求输出前来等待服务的N位顾客的平均等待时间、最长等待时间、最后完成时间，并且统计每个窗口服务了多少名顾客。</p> 
<h4>输入</h4> 
<p>输入第1行给出正整数N（≤1000），为顾客总人数；随后N行，每行给出一位顾客的到达时间<code>T</code>、事务处理时间<code>P</code>和是否VIP的标志（1是VIP，0则不是），并且假设输入数据已经按到达时间先后排好了顺序；最后一行给出正整数K（≤10）—— 为开设的营业窗口数，以及VIP窗口的编号（从0到K−1）。这里假设每位顾客事务被处理的最长时间为60分钟。</p> 
<h4>输出</h4> 
<p>在第一行中输出平均等待时间（输出到小数点后1位）、最长等待时间、最后完成时间，之间用1个空格分隔，行末不能有多余空格。</p> 
<p>在第二行中按编号递增顺序输出每个窗口服务了多少名顾客，数字之间用1个空格分隔，行末不能有多余空格。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>10<br> 0 20 0<br> 0 20 0<br> 1 68 1<br> 1 12 1<br> 2 15 0<br> 2 10 0<br> 3 15 1<br> 10 12 1<br> 30 15 0<br> 62 5 1<br> 3 1</p> 
<h4>输出样例1</h4> 
<p>15.1 35 67<br> 4 5 1</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct people
{
    int arrive;
    int manage;
    int VIP;
};
int main()
{
    int n;
    cin&gt;&gt;n;
    vector&lt;people&gt;v;
    for(int i=0;i&lt;n;i++)
    {
        int a,b,c;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        b=min(60,b);
        v.push_back({a,b,c});
    }
    int k,vk;
    cin&gt;&gt;k&gt;&gt;vk;
    vector&lt;int&gt;server(k,0);
    vector&lt;int&gt;deal(k,0);
    int max_wait=0;
    int finish=0;
    double avg_wait=0;
    int cur=0;
    while(1)
    {
        //先处理vip
        if(deal[vk]==0)
        {
            for(vector&lt;people&gt;::iterator it=v.begin();it!=v.end();it++)
            {
                auto p=(*it);
                if(p.VIP&amp;&amp;p.arrive&lt;=cur)
                {
                    server[vk]++;
                    deal[vk]=p.manage;
                    int need=cur-p.arrive;
                    finish+=need;
                    if(need&gt;max_wait)
                    {
                        max_wait=need;
                    }
                    v.erase(it);
                    break;
                }
            }
        }
        //后处理其它人
        while(!v.empty()&amp;&amp;v.front().arrive&lt;=cur)
        {
            auto tt=v.front();
            bool flag=0;
            for(int i=0;i&lt;k;i++)
            {
                if(deal[i]==0)
                {
                    server[i]++;
                    deal[i]=tt.manage;
                    int need=cur-tt.arrive;
                    finish+=need;
                    if(need&gt;max_wait)
                    {
                        max_wait=need;
                    }
                    v.erase(v.begin());
                    flag=1;
                    break;
                }
            }
            //所有窗口都有人
            if(!flag)
            {
                break;
            }
        }
        bool flag1=0;
        for(int i=0;i&lt;k;i++)
        {
            //在办理中
            if(deal[i])deal[i]--;
            if(deal[i])flag1=1;
        }
        cur++;
        if(!flag1&amp;&amp;v.empty())
        {
            break;
        }
    }
    printf("%.1lf %d %d\n",1.0*finish/n,max_wait,cur);
    for(int i=0;i&lt;k;i++)
    {
        if(i)cout&lt;&lt;" ";
        cout&lt;&lt;server[i];
    }
    cout&lt;&lt;endl;
    return 0;
}</code></pre> 
<h3>E. DS栈+队列—排队游戏</h3> 
<h4>题目描述</h4> 
<p>在幼儿园中，老师安排小朋友做一个排队的游戏。首先老师精心的把数目相同的小男孩和小女孩编排在一个队列中，每个小孩按其在队列中的位置发给一个编号（编号从0开始）。然后老师告诉小朋友们，站在前边的小男孩可以和他后边相邻的小女孩手拉手离开队列，剩余的小朋友重新站拢，再按前后相邻的小男孩小女孩手拉手离开队列游戏，如此往复。由于教师精心的安排，恰好可以保证每两个小朋友都能手拉手离开队列，并且最后离开的两个小朋友是编号最小的和最大的两个小朋友。（注：只有小男孩在前，小女孩在后，且他们两之间没有其他的小朋友，他们才能手拉手离开队列）。请根据老师的排队，按小女孩编号从小到大的顺序，给出所有手拉手离开队列的小男孩和小女孩的编号对。</p> 
<h4>输入</h4> 
<p>用一个字符串代表小朋友队列。字符串中只会出现两个字符，分别代表小男孩和小女孩，首先出现的字符代表小男孩，另一个字符代表小女孩。小孩总数不超过2000。</p> 
<h4>输出</h4> 
<p>按小女孩编号顺序，顺序输出手拉手离开队列的小男孩和小女孩的编号对，每行一对编号，编号之间用一个空格分隔。</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>((()(())())(()))</p> 
<h4>输出样例1</h4> 
<p>2 3<br> 5 6<br> 4 7<br> 8 9<br> 1 10<br> 12 13<br> 11 14<br> 0 15</p> 
<h4><br> AC代码</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;iomanip&gt;
using namespace std;
int main()
{
	string s;
	cin &gt;&gt; s;
	stack&lt;pair&lt;char, int&gt;&gt;q;
	for (int i = 0; i &lt; s.size(); i++)
	{
		if (s[i] == '(')
		{
			q.push({ '(',i });
		}
		else
		{
			auto t = q.top();
			q.pop();
			cout &lt;&lt; t.second &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;
		}
	}
	return 0;
}
</code></pre> 
<h3>F. DS队列--组队列</h3> 
<h4>题目描述</h4> 
<p>组队列是队列结构中一种常见的队列结构，在很多地方有着广泛应用。组队列是是指队列内的元素分组聚集在一起。组队列包含两种命令：</p> 
<p>1、 ENQUEUE，表示当有新的元素进入队列，首先会检索是否有同一组的元素已经存在，如果有，则新元素排在同组的最后，如果没有则插入队列末尾。</p> 
<p>2、 DEQUEUE，表示队列头元素出队</p> 
<p>3、 STOP，停止操作</p> 
<h4>输入</h4> 
<p>第1行输入一个t(t&lt;=10)，表示1个队列中有多少个组</p> 
<p>第2行输入一个第1组的元素个数和数值</p> 
<p>第3行输入一个第2组的元素个数和数值</p> 
<p>以此类推输入完t组以定义同组元素之后，开始输入多个操作命令(&lt;200)，对空的组队列进行操作，例如输入ENQUEUE 100，表示把元素100插入队列</p> 
<h4>输出</h4> 
<p>DEQUEUE出队的元素</p> 
<p>样例查看模式 </p> 
<p>正常显示查看格式</p> 
<h4>输入样例1 </h4> 
<p>2\n<br> 3 101 102 103\n<br> 3 201 202 203\n<br> ENQUEUE 101\n<br> ENQUEUE 201\n<br> ENQUEUE 102\n<br> ENQUEUE 202\n<br> ENQUEUE 103\n<br> ENQUEUE 203\n<br> DEQUEUE\n<br> DEQUEUE\n<br> DEQUEUE\n<br> STOP\n</p> 
<h4>输出样例1</h4> 
<p>101 102 103\n</p> 
<h4>输入样例2 </h4> 
<p>3\n<br> 3 101 102 103\n<br> 3 201 202 203\n<br> 3 301 302 303\n<br> ENQUEUE 201\n<br> ENQUEUE 301\n<br> ENQUEUE 102\n<br> DEQUEUE\n<br> DEQUEUE\n<br> DEQUEUE\n<br> ENQUEUE 101\n<br> ENQUEUE 203\n<br> ENQUEUE 302\n<br> ENQUEUE 301\n<br> DEQUEUE\n<br> DEQUEUE\n<br> DEQUEUE\n<br> STOP\n</p> 
<h4>AC代码</h4> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n;
    cin&gt;&gt;n;
    vector&lt;queue&lt;int&gt;&gt;q(n);
    map&lt;int,int&gt;mp;
    queue&lt;int&gt;num;
    vector&lt;int&gt;res;
    for(int i=0;i&lt;n;i++)
    {
        int nn;
        cin&gt;&gt;nn;
        for(int j=0;j&lt;nn;j++)
        {
            int tt;
            cin&gt;&gt;tt;
            mp[tt]=i;//每个对应的组数
        }
    }
    string ans;
    while(1)
    {
        cin&gt;&gt;ans;
        if(ans=="STOP")break;
        else if(ans=="ENQUEUE")
        {
            int pp;
            cin&gt;&gt;pp;
            if(q[mp[pp]].empty())
            {
                num.push(mp[pp]);
            }
            q[mp[pp]].push(pp);
        }
        else
        {
            int kk=num.front();
            res.push_back(q[kk].front());
            q[kk].pop();
            if(q[kk].empty())
            {
                num.pop();
            }
        }
    }
    for(int i=0;i&lt;res.size();i++)
    {
         if(i)cout&lt;&lt;" ";
        cout&lt;&lt;res[i];
    }
    cout&lt;&lt;endl;
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7444687007d5e1e9a6b5a3ea592cb377/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构和算法笔记3：双指针法（快慢指针）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bce0b5458f5cbbb6506ef5167b93e861/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python使用条件检查来区分不同的运行环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>