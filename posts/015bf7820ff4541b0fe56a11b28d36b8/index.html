<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构二叉树——堆 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构二叉树——堆" />
<meta property="og:description" content="前言：哈喽小伙伴们，紧随上篇文章树的讲解，我们这篇文章开始进行二叉树的讲解。
先来看二叉树的一种特殊形式——堆。
目录
一.什么是堆
二.堆的概念
三.堆的实现
1.堆的创建
2.堆的销毁
3.堆顶数据
4.堆的判空
5.堆的数据个数
6.堆的插入
7.堆的删除
8.测试
四.完整代码展示
1.Heap.h
2.Heap.c
五.总结 一.什么是堆 我们已经了解到，二叉树有顺序存储和链式存储两种方式。其中顺序存储比较特殊，它用数组来作为架构，这就要求树的各个节点之间必须是连续且有序，这样一来只有完全二叉树才符合条件，所以我们将顺序存储的二叉树另起一个新名字——堆。
二.堆的概念 堆既然作为从二叉树独立出来的一个新的数据结构，自然要有它自己的特性：
堆中的某个节点的值总是不大于或不小于其父节点的值。堆总是一棵完全二叉树。堆按照从上到下，从左到右的顺序依次在数组中排列。 如何理解第一个特性呢？？？来看下图：
如果一个父节点的值比它的子节点的值都小，那么我们将这样的堆称为小堆；如果一个父节点的值比它的子节点的值都大，那么我们将这样的堆称为大堆； 三.堆的实现 我现在随便给出一个数组：
arr[] = { 9,4,6,2,7,1,8,4,8,2 };
该数组可以是一棵二叉树，但是不满足堆的条件，下面我们就来创建一个堆，并将该数组的数据按照堆的规则将它们入堆。（以小堆为例）
1.堆的创建 因为是数组型数据结构，所以一开始肯定还是要创建一个堆结构体：
typedef int HPDataType; typedef struct Heap { HPDataType* data; int size; int capacity; }Heap; 紧接着进行初始化：
// 堆的构建 void HeapCreate(Heap* hp) { assert(hp); hp-&gt;capacity = 0; hp-&gt;size = 0; hp-&gt;data = NULL; } 2.堆的销毁 销毁也是同样的操作：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/015bf7820ff4541b0fe56a11b28d36b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T14:47:54+08:00" />
<meta property="article:modified_time" content="2023-11-25T14:47:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构二叉树——堆</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：哈喽小伙伴们，紧随上篇文章树的讲解，我们这篇文章开始进行二叉树的讲解。</p> 
<p>先来看二叉树的一种特殊形式——堆。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86" rel="nofollow">一.什么是堆</a></p> 
<p id="%E4%BA%8C.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">二.堆的概念</a></p> 
<p id="%E4%B8%89.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">三.堆的实现</a></p> 
<p id="1.%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#1.%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">1.堆的创建</a></p> 
<p id="2.%E5%A0%86%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:40px;"><a href="#2.%E5%A0%86%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">2.堆的销毁</a></p> 
<p id="%C2%A03.%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%C2%A03.%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE" rel="nofollow"> 3.堆顶数据</a></p> 
<p id="4.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA-toc" style="margin-left:40px;"><a href="#4.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA" rel="nofollow">4.堆的判空</a></p> 
<p id="5.%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0" rel="nofollow">5.堆的数据个数</a></p> 
<p id="%C2%A06.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#%C2%A06.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow"> 6.堆的插入</a></p> 
<p id="7.%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#7.%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">7.堆的删除</a></p> 
<p id="8.%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#8.%E6%B5%8B%E8%AF%95" rel="nofollow">8.测试</a></p> 
<p id="%E5%9B%9B.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" rel="nofollow">四.完整代码展示</a></p> 
<p id="1.Heap.h-toc" style="margin-left:40px;"><a href="#1.Heap.h" rel="nofollow">1.Heap.h</a></p> 
<p id="2.Heap.c-toc" style="margin-left:40px;"><a href="#2.Heap.c" rel="nofollow">2.Heap.c</a></p> 
<p id="%E4%BA%94.%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%E6%80%BB%E7%BB%93%C2%A0" rel="nofollow">五.总结 </a></p> 
<hr> 
<h2 id="%E4%B8%80.%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86" style="background-color:transparent;">一.什么是堆</h2> 
<p>我们已经了解到，二叉树有<span style="color:#fe2c24;"><strong>顺序存储和链式存储</strong></span>两种方式。其中顺序存储比较特殊，它<span style="color:#fe2c24;"><strong>用数组来作为架构</strong></span>，这就<strong><span style="background-color:#ffd900;">要求树的各个节点之间必须是连续且有序</span></strong>，这样一来<span style="color:#fe2c24;"><strong>只有完全二叉树才符合条件</strong></span>，所以我们将顺序存储的二叉树另起一个新名字——<span style="color:#fe2c24;"><strong>堆</strong></span>。</p> 
<hr> 
<h2 id="%E4%BA%8C.%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5">二.堆的概念</h2> 
<p>堆既然作为从二叉树独立出来的一个新的数据结构，自然要有它自己的特性：</p> 
<ul><li><strong>堆中的某个节点的值总是不大于或不小于其父节点的值。</strong></li><li><strong>堆总是一棵完全二叉树。</strong></li><li><strong>堆按照从上到下，从左到右的顺序依次在数组中排列。</strong></li></ul> 
<p>如何理解第一个特性呢？？？来看下图：</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/56/27/Re8AQsCX_o.png" width="421"></p> 
<ul><li>如果一个父节点的值比它的子节点的值都<span style="color:#fe2c24;"><strong>小</strong></span>，那么我们将这样的堆称为<span style="color:#fe2c24;"><strong>小堆</strong></span>；</li><li>如果一个父节点的值比它的子节点的值都<span style="color:#fe2c24;"><strong>大</strong></span>，那么我们将这样的堆称为<span style="color:#fe2c24;"><strong>大堆</strong></span>；</li></ul> 
<hr> 
<h2 id="%E4%B8%89.%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0">三.堆的实现</h2> 
<p>我现在随便给出一个数组：</p> 
<blockquote> 
 <p>arr[] = { 9,4,6,2,7,1,8,4,8,2 };</p> 
</blockquote> 
<p>该数组可以是一棵二叉树，但是<strong>不满足堆的条件</strong>，下面我们就来创建一个堆，并将该数组的数据按照堆的规则将它们入堆。（以小堆为例）</p> 
<hr> 
<h3 id="1.%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA">1.堆的创建</h3> 
<p>因为是数组型数据结构，所以一开始肯定还是要创建一个堆结构体：</p> 
<pre><code class="language-cpp">typedef int HPDataType;

typedef struct Heap
{
	HPDataType* data;
	int size;
	int capacity;
}Heap;</code></pre> 
<p>紧接着进行初始化：</p> 
<pre><code class="language-cpp">// 堆的构建
void HeapCreate(Heap* hp)
{
	assert(hp);
	hp-&gt;capacity = 0;
	hp-&gt;size = 0;
	hp-&gt;data = NULL;
}</code></pre> 
<hr> 
<h3 id="2.%E5%A0%86%E7%9A%84%E9%94%80%E6%AF%81">2.堆的销毁</h3> 
<p>销毁也是同样的操作：</p> 
<pre><code class="language-cpp">// 堆的销毁
void HeapDestory(Heap* hp)
{
	assert(hp);
	free(hp-&gt;data);
	hp-&gt;capacity = 0;
	hp-&gt;size = 0;
	hp-&gt;data = NULL;
}</code></pre> 
<hr> 
<h3 id="%C2%A03.%E5%A0%86%E9%A1%B6%E6%95%B0%E6%8D%AE"> 3.堆顶数据</h3> 
<pre><code class="language-cpp">// 取堆顶的数据
HPDataType HeapTop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size &gt; 0);
	return hp-&gt;data[0];
}</code></pre> 
<p>取堆顶数据是要断言堆是否为空。 </p> 
<hr> 
<h3 id="4.%E5%A0%86%E7%9A%84%E5%88%A4%E7%A9%BA">4.堆的判空</h3> 
<pre><code class="language-cpp">// 堆的判空
bool HeapEmpty(Heap* hp)
{
	assert(hp);
	return hp-&gt;size == 0;
}</code></pre> 
<p>堆判空比较简单，如果sizeof为0，就说明堆没有数据。 </p> 
<hr> 
<h3 id="5.%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0">5.堆的数据个数</h3> 
<pre><code class="language-cpp">// 堆的数据个数
int HeapSize(Heap* hp)
{
	assert(hp);
	return hp-&gt;size;
}</code></pre> 
<p>数据个数即为size。</p> 
<hr> 
<h3 id="%C2%A06.%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5"> 6.堆的插入</h3> 
<p>整个入堆的操作分为两部分：</p> 
<blockquote> 
 <ol><li><strong>将数据存入堆底；</strong></li><li><strong>按照小堆的规则进行调整。</strong></li></ol> 
</blockquote> 
<p>因为数据入堆的时候不一定就是按照小堆的规则，所以我们必须得有一个调整。</p> 
<p>那么我们又该如何调整呢？？？</p> 
<p>小堆的规则是，<span style="color:#fe2c24;"><strong>父节点的值不大于子节点的值</strong></span>，那<strong><span style="background-color:#ffd900;">如果新入堆的子节点的值要比父节点小，就将它们两个的值进行交换</span></strong>。交换之后，<span style="color:#fe2c24;"><strong>新的父节点还要和它的父节点再进行比较</strong></span>，如果小，那么就还要继续进行交换，就这样一步一步的<span style="color:#fe2c24;"><strong>向上调整</strong></span>。</p> 
<p>首先小伙伴们要知道，<strong><span style="background-color:#ffd900;">堆中的节点的序号和数组一样，根节点为0，依次往下排序</span></strong>。</p> 
<p>然后是一个很重要的小技巧，那就是，假设一个父节点的序号为N，它的其中一个子节点的序号为n，那么<span style="color:#fe2c24;"><strong>N = （n - 1）/ 2</strong></span>。</p> 
<p>通过这一点，我们就可以很容易的实现调整啦。</p> 
<p>先来看数据入堆：</p> 
<pre><code class="language-cpp">//堆的插入
void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;size == hp-&gt;capacity)
	{
		int newcapacity = hp-&gt;capacity == 0 ? 4 : hp-&gt;capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(hp-&gt;data,sizeof(HPDataType)*newcapacity);
		if (tmp == NULL)
		{
			perror("HeapPush-&gt;malloc");
			exit(-1);
		}
		hp-&gt;data = tmp;
		hp-&gt;capacity = newcapacity;
	}
	hp-&gt;data[hp-&gt;size] = x;
	hp-&gt;size++;
	AdjustUp(hp-&gt;data, hp-&gt;size - 1);
}</code></pre> 
<p>入堆之后，开始进行调整，我们另建一个<span style="color:#fe2c24;"><strong>向上调整函数</strong></span>，并<span style="color:#fe2c24;"><strong>传入数组的地址和子节点的序号。</strong></span></p> 
<pre><code class="language-cpp">//交换
void Swap(HPDataType* x, HPDataType* y)
{
	HPDataType tmp = *x;
	*x = *y;
	*y = tmp;
}
//堆向上调整
void AdjustUp(HPDataType* a, int child)
{
	while (child &gt; 0)
	{
		int parent = (child - 1) / 2;
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
		}
		else
		{
			break;
		}
        child = parent;
		parent = (parent - 1) / 2;
	}
}</code></pre> 
<p>因为需要进行交换，所以我们干脆就在写一个<span style="color:#fe2c24;"><strong>交换函数</strong></span>，这样更加方便。</p> 
<p>在该函数中，我们<span style="color:#fe2c24;"><strong>首先要记录父节点的序号</strong></span>，然后通过while循换来实现一步一步的向上调整，值得注意的是<span style="color:#fe2c24;"><strong>while循环的条件：child &gt; 0</strong></span>，<strong><span style="background-color:#ffd900;">因为很有可以一直向上调整，直到该子节点成为最上边的根节点，如此一来，它的序号就是0。所以只要它还大于0 ，那么就反复执行循环</span></strong>。</p> 
<p>随后进行比较判断，<strong>如果子节点要小于父节点，就进行交换，<span style="color:#fe2c24;">然后让两个child和parent分别向上继承序号</span></strong>。</p> 
<p>反之，就不用交换，更不用再执行循环，所以就<span style="color:#fe2c24;"><strong>直接用break打破循环</strong></span>。</p> 
<p>如此一来我们就实现了堆的插入。</p> 
<hr> 
<h3 id="7.%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" style="background-color:transparent;">7.堆的删除</h3> 
<p>有小伙伴会说，堆的删除简单啊，直接<strong>size--</strong>。但是我要告诉你的是，<strong>谁说过堆的删除就是删除最后一个节点了</strong>？？？如果是这样，那岂不是太简单了。</p> 
<p>所以<strong>实际上说堆的删除，都是删除它的<span style="color:#fe2c24;">根节点</span></strong>。</p> 
<p>这就很难办啊，根节点该怎么删除啊？？？</p> 
<p>这时候又有小伙伴说，<strong>直接让数据都向前覆盖呗</strong>，话是这样说，但是假如说，我们一个小堆是<strong>1,3,2,4,5</strong>，把根节点1删除，剩下的序列是<strong>3,2,4,5</strong>，<span style="color:#fe2c24;"><strong>3成为新的根节点，但是它的子节点2比它小</strong></span>，这样就<strong>不满足小堆的规则</strong>了，<span style="color:#fe2c24;"><strong>堆的数据就全乱套了。</strong></span></p> 
<p>那么堆到底该如何进行根节点的删除呢？？？</p> 
<p><span style="color:#fe2c24;"><strong>既要满足把根节点删除，又要满足不破坏堆的结构和规则</strong></span>，为此诞生出了，<strong><span style="background-color:#ffd900;">先将根节点的值和最后一个节点的值交换，再让新根节点进行向下比较调整</span></strong>的方法。</p> 
<pre><code class="language-cpp">//堆的删除
void HeapPop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size &gt; 0);
	Swap(&amp;hp-&gt;data[0], &amp;hp-&gt;data[hp-&gt;size - 1]);
	hp-&gt;size--;
	AdjustDown(hp-&gt;data, hp-&gt;size, 0);
}</code></pre> 
<p>首先，要<strong>断言堆是否为空</strong>。</p> 
<p>接着，我们<strong><span style="background-color:#ffd900;">将根节点与最后一个节点进行值的交换，再让size--，这样便满足的将根节点的值进行了删除</span></strong>。</p> 
<p>但是<span style="color:#fe2c24;"><strong>新的根节点的值不一定满是小堆的规则</strong></span>，<span style="color:#fe2c24;"><strong>它可能比它的子节点的值更大</strong></span>，所以就要开始进行<span style="color:#fe2c24;"><strong>向下调整啦</strong></span>。</p> 
<pre><code class="language-cpp">//堆向下调整
void AdjustDown(HPDataType* a, int size, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; size)
	{
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])
		{
			child++;
		}
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p>向下调整，我们需要<span style="color:#fe2c24;"><strong>传入数组，数组的大小，以及根节点的序号0</strong></span>。</p> 
<p>通过公式<span style="color:#fe2c24;"><strong>N = （n - 1）/ 2</strong></span>的逆向操作，我们可以<span style="color:#fe2c24;"><strong>通过父节点的序号来得到它的左子节点的序号</strong></span>，因为要<strong>满足小堆的规则</strong>，所以向下调整时，我们要<span style="color:#fe2c24;"><strong>找两个子节点中值更小的一个来进行交换</strong></span>。 </p> 
<p>所以我们首先要进行一次比较，<strong><span style="background-color:#ffd900;">如果右节点的值大于左节点，就让child++，这样child就是右节点的序号</span></strong>。</p> 
<p>紧接着就开始比较两个父子节点的值的大小，<strong><span style="background-color:#ffd900;">如果父比子大，就交换，并向下继承序号，反之就打破循环，结束调整</span></strong>。</p> 
<p>最后我们再来分析while循环的判断条件<span style="color:#fe2c24;"><strong>（child &lt; size）</strong></span>，<strong><span style="background-color:#ffd900;">如果一直向下调整，就会出现parent成为了最后一层的节点，那么他就没有子节点可以调整了，也就是它的child的序号已经超出size的范围了，所以循环便不再进行</span></strong>。</p> 
<p>此外，还有一种特殊情况：</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/c3/ff/rBctgZu8_o.png" width="465"></p> 
<p>如果此时的父节点为我们的红箭头指向的节点，那么他就<span style="color:#fe2c24;"><strong>只有左子节点</strong></span>，这样我们就<strong>不用比较左右节点的大小啦，所以判断左右节点的大小时，需要多加一条<span style="color:#fe2c24;">child+1 &lt; size</span></strong>，来排除此特殊情况。</p> 
<hr> 
<h3 id="8.%E6%B5%8B%E8%AF%95">8.测试</h3> 
<pre><code class="language-cpp">#include "Heap.h"

void test(Heap* hp)
{
	HeapCreate(hp);
	HPDataType arr[] = { 9,4,6,2,7,1,8,4,8,2 };
	int size = sizeof(arr) / sizeof(arr[0]);
	for (int i = 0; i &lt; size; i++)
	{
		HeapPush(hp, arr[i]);
	}
	while (!HeapEmpty(hp))
	{
		printf("%d ", HeapTop(hp));
		HeapPop(hp);
	}
}
int main()
{
	Heap hp;
	test(&amp;hp);
	return 0;
}</code></pre> 
<p>因为堆同样不支持直接遍历的操作，所以还是要自己来实现遍历的操作，结果如下：</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/f5/50/cPCYx0HK_o.png" width="312"></p> 
<p>如果想要改为大堆，我们只需要将父子节点的大小比较和兄弟节点的大小比较进行更改即可。</p> 
<p>大堆结果如下：</p> 
<p><img alt="" height="126" src="https://images2.imgbox.com/a5/3a/ZhT7xuVl_o.png" width="340"></p> 
<hr> 
<h2 id="%E5%9B%9B.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA">四.完整代码展示</h2> 
<h3 id="1.Heap.h">1.Heap.h</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

typedef int HPDataType;

typedef struct Heap
{
	HPDataType* data;
	int size;
	int capacity;
}Heap;

// 堆的构建
void HeapCreate(Heap* hp);
// 堆的销毁
void HeapDestory(Heap* hp);
// 堆的插入
void HeapPush(Heap* hp, HPDataType x);
// 堆的删除
void HeapPop(Heap* hp);
// 取堆顶的数据
HPDataType HeapTop(Heap* hp);
// 堆的数据个数
int HeapSize(Heap* hp);
// 堆的判空
bool HeapEmpty(Heap* hp);</code></pre> 
<hr> 
<h3 id="2.Heap.c">2.Heap.c</h3> 
<pre><code class="language-cpp">#include "Heap.h"

// 堆的构建
void HeapCreate(Heap* hp)
{
	assert(hp);
	hp-&gt;capacity = 0;
	hp-&gt;size = 0;
	hp-&gt;data = NULL;
}
// 堆的销毁
void HeapDestory(Heap* hp)
{
	assert(hp);
	free(hp-&gt;data);
	hp-&gt;capacity = 0;
	hp-&gt;size = 0;
	hp-&gt;data = NULL;
}
//交换
void Swap(HPDataType* x, HPDataType* y)
{
	HPDataType tmp = *x;
	*x = *y;
	*y = tmp;
}
//堆向上调整
void AdjustUp(HPDataType* a, int child)
{
	while (child &gt; 0)
	{
		int parent = (child - 1) / 2;
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
		}
		else
		{
			break;
		}
		parent = (parent - 1) / 2;
		child = (child - 1) / 2;
	}
}
//堆向下调整
void AdjustDown(HPDataType* a, int size, int parent)
{
	int child = parent * 2 + 1;
	while (child &lt; size)
	{
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])
		{
			child++;
		}
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
//堆的插入
void HeapPush(Heap* hp, HPDataType x)
{
	assert(hp);
	if (hp-&gt;size == hp-&gt;capacity)
	{
		int newcapacity = hp-&gt;capacity == 0 ? 4 : hp-&gt;capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(hp-&gt;data,sizeof(HPDataType)*newcapacity);
		if (tmp == NULL)
		{
			perror("HeapPush-&gt;malloc");
			exit(-1);
		}
		hp-&gt;data = tmp;
		hp-&gt;capacity = newcapacity;
	}
	hp-&gt;data[hp-&gt;size] = x;
	hp-&gt;size++;
	AdjustUp(hp-&gt;data, hp-&gt;size - 1);
}
//堆的删除
void HeapPop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size &gt; 0);
	Swap(&amp;hp-&gt;data[0], &amp;hp-&gt;data[hp-&gt;size - 1]);
	hp-&gt;size--;
	AdjustDown(hp-&gt;data, hp-&gt;size, 0);
}
// 取堆顶的数据
HPDataType HeapTop(Heap* hp)
{
	assert(hp);
	assert(hp-&gt;size &gt; 0);
	return hp-&gt;data[0];
}
// 堆的数据个数
int HeapSize(Heap* hp)
{
	assert(hp);
	return hp-&gt;size;
}
// 堆的判空
bool HeapEmpty(Heap* hp)
{
	assert(hp);
	return hp-&gt;size == 0;
}</code></pre> 
<hr> 
<h2 id="%E4%BA%94.%E6%80%BB%E7%BB%93%C2%A0">五.总结 </h2> 
<p><strong>堆最难的点就再于插入和删除，需要考虑父子节点之间的大小关系</strong>，但是如果能够理清思绪，问题自然也就迎刃而解啦。</p> 
<p>最后喜欢博主文章的小伙伴记得<span style="color:#956fe7;"><strong>一键三连</strong></span>支持一下哦！！！</p> 
<p>我们下期再见啦！！！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b9c3f53aaddbe7d6dd2816b41f2bd201/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">让vs2022支持wsl（linux）本地调试.net工程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f84c381d4103efa8470bcc49b9779fc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">googleplay应用提审</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>