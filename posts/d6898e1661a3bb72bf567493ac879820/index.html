<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32驱动RGB LED彩灯模块闪烁GPIO_Write（）函数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32驱动RGB LED彩灯模块闪烁GPIO_Write（）函数" />
<meta property="og:description" content="本文基于标准库来实现驱动LED灯闪烁的状态，利用这个实验更加清楚明白的了解GPIO输出引脚的应用，以及对子函数——延时函数的调用
上一篇文章用的是GPIO_Resetbit()已经GPIO_Setbits（）两个函数，文中我们使用多一个GPIO_Write（）函数。
文章目录
一、LED彩灯模块介绍及实验现象
1、模块介绍
2、实验现象
二、程序编写前的准备
1、延时函数的调用
2、GPIO _write()函数
3、硬件电路接线
三、程序编写
1、端口配置
2、主函数的编写
一、LED彩灯模块介绍及实验现象 1、模块介绍 LED彩灯模块，具有三个LED灯，高电平驱动，三个LED灯为红（R）、绿（G）、蓝（B），三个灯单独亮时则对应其颜色，其中两个亮或三个同时亮时，可以组合成多种颜色。
如 当三个灯同时亮时，灯光 分为三块，但整体亮度较强，无明显变色现象。 当蓝灯与红灯同时亮起时，灯光颜色有点像紫色。
2、实验现象 本实验为两个状态，一个是初始化状态，一个是正常工。初始化状态会进行三次红——绿——蓝灯交替切换，然后进入正常工作状态，即彩灯模块三个灯同时闪烁（同时亮同时灭），在彩灯模块灭的时候stm32板上的灯会亮，当彩灯模块亮时stm32板上的灯灭，二者交替闪烁。
STM32驱动RGB LED彩灯模块闪烁
二、程序编写前的准备 1、延时函数的调用 简单的延时函数，可以利用for循环，或者while循环，让程序运行一段时间（定义变量i，赋予一个值，让这个值从某数值减小到0），这样就可以实现粗略的一个延时。下面提供的是一个比较精准的延时函数。即Delay.c文件。
#include &#34;stm32f10x.h&#34; /** * @brief 微秒级延时 * @param xus 延时时长，范围：0~233015 * @retval 无 */ void Delay_us(uint32_t xus) { SysTick-&gt;LOAD = 72 * xus;	//设置定时器重装值 SysTick-&gt;VAL = 0x00;	//清空当前计数值 SysTick-&gt;CTRL = 0x00000005;	//设置时钟源为HCLK，启动定时器 while(!(SysTick-&gt;CTRL &amp; 0x00010000));	//等待计数到0 SysTick-&gt;CTRL = 0x00000004;	//关闭定时器 } /** * @brief 毫秒级延时 * @param xms 延时时长，范围：0~4294967295 * @retval 无 */ void Delay_ms(uint32_t xms) { while(xms--) { Delay_us(1000); } } /** * @brief 秒级延时 * @param xs 延时时长，范围：0~4294967295 * @retval 无 */ void Delay_s(uint32_t xs) { while(xs--) { Delay_ms(1000); } } 主函数调用这个delay函数前需要声明，这里用delay." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d6898e1661a3bb72bf567493ac879820/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-21T22:44:21+08:00" />
<meta property="article:modified_time" content="2023-10-21T22:44:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32驱动RGB LED彩灯模块闪烁GPIO_Write（）函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文基于标准库来实现驱动LED灯闪烁的状态，利用这个实验更加清楚明白的了解GPIO输出引脚的应用，以及对子函数——延时函数的调用</p> 
<p>上一篇文章用的是GPIO_Resetbit()已经GPIO_Setbits（）两个函数，文中我们使用多一个GPIO_Write（）函数。</p> 
<p></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%E4%B8%80%E3%80%81LED%E5%BD%A9%E7%81%AF%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81LED%E5%BD%A9%E7%81%AF%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1" rel="nofollow">一、LED彩灯模块介绍及实验现象</a></p> 
<p id="1%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D" rel="nofollow">1、模块介绍</a></p> 
<p id="2%E3%80%81%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1" rel="nofollow">2、实验现象</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87" rel="nofollow">二、程序编写前的准备</a></p> 
<p id="1%E3%80%81%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8" rel="nofollow">1、延时函数的调用</a></p> 
<p id="2%E3%80%81GPIO%20_write()%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2%E3%80%81GPIO%20_write%28%29%E5%87%BD%E6%95%B0" rel="nofollow">2、GPIO _write()函数</a></p> 
<p id="3%E3%80%81%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E6%8E%A5%E7%BA%BF-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E6%8E%A5%E7%BA%BF" rel="nofollow">3、硬件电路接线</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99" rel="nofollow">三、程序编写</a></p> 
<p id="1%E3%80%81%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE" rel="nofollow">1、端口配置</a></p> 
<p id="2%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99" rel="nofollow">2、主函数的编写</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81LED%E5%BD%A9%E7%81%AF%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1">一、LED彩灯模块介绍及实验现象</h2> 
<h3 id="1%E3%80%81%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D">1、模块介绍</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b9/b2/NEHRLw6n_o.jpg" width="1200"></p> 
<p>LED彩灯模块，具有三个LED灯，高电平驱动，三个LED灯为红（R）、绿（G）、蓝（B），三个灯单独亮时则对应其颜色，其中两个亮或三个同时亮时，可以组合成多种颜色。</p> 
<p>如 当三个灯同时亮时，灯光    分为三块，但整体亮度较强，无明显变色现象。                                                     </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ab/7d/R5kd4nri_o.jpg" width="1200"></p> 
<p>当蓝灯与红灯同时亮起时，灯光颜色有点像紫色。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b7/6c/HVGTaNBX_o.jpg" width="1200"></p> 
<h3 id="2%E3%80%81%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1">2、实验现象</h3> 
<p>本实验为两个状态，一个是初始化状态，一个是正常工。初始化状态会进行三次红——绿——蓝灯交替切换，然后进入正常工作状态，即彩灯模块三个灯同时闪烁（同时亮同时灭），在彩灯模块灭的时候stm32板上的灯会亮，当彩灯模块亮时stm32板上的灯灭，二者交替闪烁。</p> 
<div class="csdn-video-box"> 
 <iframe id="6dCbuJ4Z-1697720081396" frameborder="0" src="https://live.csdn.net/v/embed/336627" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>STM32驱动RGB LED彩灯模块闪烁</p> 
</div> 
<h2 id="%E4%BA%8C%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">二、程序编写前的准备</h2> 
<h3 id="1%E3%80%81%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8">1、延时函数的调用</h3> 
<p>简单的延时函数，可以利用for循环，或者while循环，让程序运行一段时间（定义变量i，赋予一个值，让这个值从某数值减小到0），这样就可以实现粗略的一个延时。下面提供的是一个比较精准的延时函数。即Delay.c文件。</p> 
<pre><code>#include "stm32f10x.h"

/**
  * @brief  微秒级延时
  * @param  xus 延时时长，范围：0~233015
  * @retval 无
  */
void Delay_us(uint32_t xus)
{
	SysTick-&gt;LOAD = 72 * xus;				//设置定时器重装值
	SysTick-&gt;VAL = 0x00;					//清空当前计数值
	SysTick-&gt;CTRL = 0x00000005;				//设置时钟源为HCLK，启动定时器
	while(!(SysTick-&gt;CTRL &amp; 0x00010000));	//等待计数到0
	SysTick-&gt;CTRL = 0x00000004;				//关闭定时器
}

/**
  * @brief  毫秒级延时
  * @param  xms 延时时长，范围：0~4294967295
  * @retval 无
  */
void Delay_ms(uint32_t xms)
{
	while(xms--)
	{
		Delay_us(1000);
	}
}
 
/**
  * @brief  秒级延时
  * @param  xs 延时时长，范围：0~4294967295
  * @retval 无
  */
void Delay_s(uint32_t xs)
{
	while(xs--)
	{
		Delay_ms(1000);
	}
} 
</code></pre> 
<p>主函数调用这个delay函数前需要声明，这里用delay.h文件。</p> 
<pre><code>#ifndef __DELAY_H
#define __DELAY_H

void Delay_us(uint32_t us);
void Delay_ms(uint32_t ms);
void Delay_s(uint32_t s);

#endif
</code></pre> 
<p>使用步骤如下，先将Delay.c跟Delay.h两个文件下载后添加至工程文件夹user中，然后在keil软件中的组user中添加两个文件，然后在main文件中添加头文件声明即可调用。#include "Delay.h"</p> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/8f/b6/W7rIvpHx_o.png" width="1200"></p> 
<p><img alt="" height="659" src="https://images2.imgbox.com/65/3f/eNhAIgKG_o.png" width="907"></p> 
<p><img alt="" height="746" src="https://images2.imgbox.com/23/88/cwGxpi7o_o.png" width="1200"></p> 
<p></p> 
<h3 id="2%E3%80%81GPIO%20_write()%E5%87%BD%E6%95%B0">2、GPIO _write()函数</h3> 
<p>这个函数可以同时对所有的IO口进行操作，跟GPIO_Resetbit()已经GPIO_Setbits（）一样括号内都是2个参数，我们看一下手册上的定义</p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/43/91/UqS5KJYs_o.png" width="901"></p> 
<p>这里两个参数，第一个对应的是输出的GPIO口，第二个参数第一个参数对应输出口16个引脚的值，当全部输出低电平时为 0000  0000  0000  0000，在keil5中没有二进制，因此我们将其转化为16进制，为0x0000；当全部输出为高电平时为 1111 1111 1111 1111，即为0xFFFF。</p> 
<p>这里我们稍微提一下16进制的转换，如下图所示，这里每四个引脚对应为一个十六进制数。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/58/89/O8IPLOx5_o.jpg" width="1200"></p> 
<p></p> 
<p><img alt="" height="470" src="https://images2.imgbox.com/fd/06/ZLH3K6TF_o.png" width="466"></p> 
<p>例如我们要引脚1、3、5、7、9、11、13、15输出高电平，而剩余的脚输出低电平，引脚电平为1010  1010  1010 1010（注意，这里从左到右按照从高位引脚向低位引脚排列），即对应为PA15、PA14……PA2、PA1、PA0，将其转化为十六进制，即为0XAAAA，其中0X表示为十六进制。</p> 
<h3 id="3%E3%80%81%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E6%8E%A5%E7%BA%BF">3、硬件电路接线</h3> 
<p>LED彩灯模块有4个引脚，即R，G，B，GND，接线时RGB三个引脚可以接任意GPIO引脚作为输出口，由高电平驱动，GND接到芯片上的G，即接地。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d4/9f/n1dRxHmC_o.jpg" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99">三、程序编写</h2> 
<h3 id="1%E3%80%81%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE">1、端口配置</h3> 
<p>在keil端口调用时，可使用或将多端口进行配置，比如    GPIO_INT.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3这段函数，我们同时打开了4个引脚，使用（|）表示或，也可以使用十六进制0X000F表示。右键可以查看GPIO_Pin在固件库中的定义，可知道使用GPIO-Pin_All已定义为0XFFFF，即全部引脚调用</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/8a/a1/Lpo9fNue_o.png" width="1080"></p> 
<pre><code>void GPIO_Config(void)
{
	RCC_APB2PeriphClockCmd (RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC ,ENABLE );
	GPIO_InitTypeDef  GPIO_INT;  //自定义一个结构体
	GPIO_INT .GPIO_Mode=GPIO_Mode_Out_PP; //使用推完输出
	GPIO_INT .GPIO_Pin=GPIO_Pin_All;  //使用GPIO_Write()函数时，端口引脚必须全部打开
	GPIO_INT .GPIO_Speed =GPIO_Speed_50MHz; //晶振速度
	GPIO_Init (GPIOB,&amp;GPIO_INT );  //对GPIOB端口进行初始化
	GPIO_INT .GPIO_Mode=GPIO_Mode_Out_PP; //GPIOB使用推完输出
	GPIO_INT .GPIO_Pin=GPIO_Pin_13;  
	GPIO_INT .GPIO_Speed =GPIO_Speed_50MHz; //晶振速度
	GPIO_Init (GPIOC,&amp;GPIO_INT );  //对GPIOC端口进行初始化
	GPIO_SetBits (GPIOC,GPIO_Pin_13 );
}</code></pre> 
<h3 id="2%E3%80%81%E4%B8%BB%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">2、主函数的编写</h3> 
<p>使用for循环对初始化的状态进行三次循环，初始化状态：在红灯亮后延时500ms，然后熄灭红灯的同时点亮绿灯，延时500ms熄灭绿灯点亮蓝灯，再等500熄灭蓝灯点亮红灯，如此往复操作。</p> 
<p> 对于正常工作的步骤也如上 ，在熄灭彩灯模块的同时点亮芯片上的LED灯。</p> 
<pre><code>
#include "stm32f10x.h"
#include "Delay.h"    //调用延时函数

void GPIO_Config(void)
{
	RCC_APB2PeriphClockCmd (RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC ,ENABLE );
	GPIO_InitTypeDef  GPIO_INT;  //自定义一个结构体
	GPIO_INT .GPIO_Mode=GPIO_Mode_Out_PP; //使用推完输出
	GPIO_INT .GPIO_Pin=0xffff;  //使用GPIO_Write()函数时，端口引脚必须全部打开
	GPIO_INT .GPIO_Speed =GPIO_Speed_50MHz; //晶振速度
	GPIO_Init (GPIOB,&amp;GPIO_INT );  //对GPIOB端口进行初始化
	GPIO_INT .GPIO_Mode=GPIO_Mode_Out_PP; //GPIOB使用推完输出
	GPIO_INT .GPIO_Pin=GPIO_Pin_13;  
	GPIO_INT .GPIO_Speed =GPIO_Speed_50MHz; //晶振速度
	GPIO_Init (GPIOC,&amp;GPIO_INT );  //对GPIOC端口进行初始化
	GPIO_SetBits (GPIOC,GPIO_Pin_13 );
}

int main(void)
{	
	int i;                                   
	GPIO_Config ();
	for(i=0;i&lt;3;i++)  //初始化
	{	
		GPIO_SetBits (GPIOB,GPIO_Pin_7);    //让GPIOB的7引脚输出高电平  点亮红灯
		Delay_ms (500);  //调用延时函数，延时200ms
		GPIO_ResetBits (GPIOB,GPIO_Pin_7);  //让GPIOB的7引脚输出低电平  熄灭红灯
		GPIO_SetBits (GPIOB,GPIO_Pin_8);    //让GPIOB的8引脚输出高电平  点亮灯
		Delay_ms (500);  //调用延时函数，延时200ms
		GPIO_ResetBits (GPIOB,GPIO_Pin_8);  //让GPIOB的8引脚输出低电平  熄灭绿色
		GPIO_SetBits  (GPIOB,GPIO_Pin_9);   //让GPIOB的9引脚输出高电平  点亮蓝色
		Delay_ms (500);  //调用延时函数，延时200ms
		GPIO_ResetBits (GPIOB,GPIO_Pin_9);  //让GPIOB的9引脚输出低电平  熄灭蓝色
		Delay_ms (500);
	}
	
	while(1)      //正常工作
	{
		GPIO_SetBits  (GPIOC,GPIO_Pin_13);  //让GPIOC的13引脚输出高电平  熄灭LED
		GPIO_Write (GPIOB ,0X0700);     //0000 0111 0000 0000    0X1C00
		Delay_ms (1000);  //调用延时函数，延时200ms
		GPIO_Write (GPIOB,0X0000);
		GPIO_ResetBits (GPIOC,GPIO_Pin_13);  //让GPIC的13引脚输出低电平  点亮LED
		Delay_ms (1000);
	}

}</code></pre> 
<p></p> 
<p>程序以及延时模块的两个文件在链接中：链接：https://pan.baidu.com/s/1XmiP687Zi9eUhOxcfb2qKA?pwd=dhob <br> 提取码：dhob</p> 
<p></p> 
<p></p> 
<p></p> 
<p>本人也是初学STM32，在学习的同时以初学者的角度来理解说明，如果文章有错误的地方，请大家多多指正，谢谢！！！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c048e0e6579ce6996af1af3ffe065b38/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Opencv&#43;python的车流量检测项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f799740441082a033dc086502ca08889/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JVM第十七讲：调试排错 - Java 问题排查之Linux命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>