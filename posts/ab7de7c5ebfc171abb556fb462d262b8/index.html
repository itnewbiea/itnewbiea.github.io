<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解一元二次方程lisp_只有lisp能做——欧拉计划第66题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="解一元二次方程lisp_只有lisp能做——欧拉计划第66题" />
<meta property="og:description" content="仅以此文膜拜八年前的自己
序言
欧拉计划(Project Euler)就像LeetCode，是一个编程答题的网站。不同于LeetCode的是，欧拉计划只要求用户提交最终答案即可(一般是一个数字)，而不需要完整代码。因此，可以尽情地使用自己喜欢的编程语言——不少题目甚至光靠笔和纸便能解决。
欧拉计划的第66题非常有意思，它的题目很简单，就是要求找出在不大于1000的整数中，以哪一个数字为丢番图方程的系数，可以得到所有最小解中的最大值。
可以很容易地看出方程有一个直观的暴力算法：让y从1开始递增，对于每一个y，计算公式Dy^2&#43;1的值。如果该值为平方数，那么它的平方根就是最小的x解。再依照这个算法求解所有D不大于1000的方程，便可以求出题目的答案。很容易用Python写出这个算法# -*- coding: utf8 -*-
import math
def is_square(num: int) -&gt; bool:
return math.isqrt(num) ** 2 == num
def find_x(D: int) -&gt; int:
&#34;&#34;&#34;
求出给定D时，满足题目所给的丢番图方程的最小的x。
&#34;&#34;&#34;
assert not is_square(D)
y = 1
while True:
candidate = D * y * y &#43; 1
if is_square(candidate):
return math.isqrt(candidate)
y &#43;= 1
def solve_66(limit):
&#34;&#34;&#34;
找出不大于limi的D中，使find_x的返回值最大的那一个数字。
&#34;&#34;&#34;
max_D = None
max_x = None
D = 2" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ab7de7c5ebfc171abb556fb462d262b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-12T12:55:20+08:00" />
<meta property="article:modified_time" content="2021-02-12T12:55:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解一元二次方程lisp_只有lisp能做——欧拉计划第66题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>仅以此文膜拜八年前的自己</p> 
 <p>序言</p> 
 <p>欧拉计划(Project Euler)就像LeetCode，是一个编程答题的网站。不同于LeetCode的是，欧拉计划只要求用户提交最终答案即可(一般是一个数字)，而不需要完整代码。因此，可以尽情地使用自己喜欢的编程语言——不少题目甚至光靠笔和纸便能解决。</p> 
 <p>欧拉计划的第66题非常有意思，它的题目很简单，就是要求找出在不大于1000的整数中，以哪一个数字为丢番图方程的系数，可以得到所有最小解中的最大值。</p> 
 <p align="center"><img src="https://images2.imgbox.com/c2/b4/uk0s0b39_o.png" alt="f5b7d6310d8d67fd79901e35b3cb37ee.png"></p> 
 <p>可以很容易地看出方程有一个直观的暴力算法：让y从1开始递增，对于每一个y，计算公式Dy^2+1的值。如果该值为平方数，那么它的平方根就是最小的x解。再依照这个算法求解所有D不大于1000的方程，便可以求出题目的答案。很容易用Python写出这个算法# -*- coding: utf8 -*-</p> 
 <p>import math</p> 
 <p>def is_square(num: int) -&gt; bool:</p> 
 <p>return math.isqrt(num) ** 2 == num</p> 
 <p>def find_x(D: int) -&gt; int:</p> 
 <p>"""</p> 
 <p>求出给定D时，满足题目所给的丢番图方程的最小的x。</p> 
 <p>"""</p> 
 <p>assert not is_square(D)</p> 
 <p>y = 1</p> 
 <p>while True:</p> 
 <p>candidate = D * y * y + 1</p> 
 <p>if is_square(candidate):</p> 
 <p>return math.isqrt(candidate)</p> 
 <p>y += 1</p> 
 <p>def solve_66(limit):</p> 
 <p>"""</p> 
 <p>找出不大于limi的D中，使find_x的返回值最大的那一个数字。</p> 
 <p>"""</p> 
 <p>max_D = None</p> 
 <p>max_x = None</p> 
 <p>D = 2</p> 
 <p>while D &lt;= limit:</p> 
 <p>if is_square(D):</p> 
 <p>D += 1</p> 
 <p>continue</p> 
 <p>x = find_x(D)</p> 
 <p>if max_x is None or x &gt; max_x:</p> 
 <p>max_D = D</p> 
 <p>max_x = x</p> 
 <p>D += 1</p> 
 <p>return max_D, max_x</p> 
 <p>if __name__ == '__main__':</p> 
 <p>D, x = solve_66(7)</p> 
 <p>print('D is {} and x is {}'.format(D, x))</p> 
 <p>但如果将上限limit提升为1000，这个算法在有生之年是算不出结果的。</p> 
 <p>要想解决这一题，需要借助数学的力量。</p> 
 <p>佩尔方程</p> 
 <p>八年前第一次做这一题的时候，经过一番搜索，我从这篇文章中知道了题目中的方程叫做佩尔方程。它有标准的解法，但需要用到连分数。那么什么是连分数呢？</p> 
 <p>连分数不是一种新的数系，只是小数的另一种写法。例如可以把分数45除以16写成下面的形式</p> 
 <p align="center"><img src="https://images2.imgbox.com/43/f4/yZwZb5cf_o.png" alt="84bb24597c1c68b12ef6ee6f9fd96344.png"></p> 
 <p>就像定义递归的数据结构一样，可以给连分数一个递归的定义。连分数要么是一个整数，要么是一个整数加上另一个连分数的倒数。除了上面的形式，连分数也可以写成更节省篇幅的样子。比如把45除以16写成[2;1,4,3]，即把原本的式子中所有的整数部分按顺序写在一对方括号之间。这种记法，看起来就像是编程语言中的数组一般。</p> 
 <p>如果用数组[2;1,4,3]的不同前缀来构造分式，那么结果依次为2/1、3/1、14/5。它们是这个连分数的渐进连分数，而佩尔方程的一组解，就来自于渐进连分数的分子和分母。</p> 
 <p>以系数为7的佩尔方程为例，先计算出根号7的连分数，然后依次尝试它的渐进连分数。前三个分别为2/1、3/1、5/2，都不是方程的解。第四个渐进连分数8/3才是方程的解。如果继续提高连分数的精度，还会找到第二个解127/48。继续找，还有更多，而8则是其中最小的x。</p> 
 <p>所以，想要快速算出佩尔方程的解，最重要的是找到计算一个数的平方根的连分数的算法。</p> 
 <p>计算平方根的连分数的错误方法</p> 
 <p align="center"><img src="https://images2.imgbox.com/a4/37/jo28uOPW_o.png" alt="24c48792dbd8bfd45d5f71c7a20f9d15.png"></p> 
 <p>要计算一个数字的连分数，最重要的便是要算出所有的整数部分(a0、a2、a2等)。它们都可以依据定义直接计算</p> 
 <p align="center"><img src="https://images2.imgbox.com/35/db/86rXDmt8_o.png" alt="1c27b038991e73fe064ead46b78b59fb.png"></p> 
 <p>推广到一半情况，如果用变量n存储开平方的数字，用numbers存储所有已知的整数，那么用Python可以写出下面的算法来计算出下一个整数# 计算连分数数列的下一个数字</p> 
 <p>import math</p> 
 <p>def compute_next_integer_part(n, numbers):</p> 
 <p>v = math.sqrt(n)</p> 
 <p>for a in numbers:</p> 
 <p>v = 1 / (v - a)</p> 
 <p>return int(v)</p> 
 <p>if __name__ == '__main__':</p> 
 <p>n = 14</p> 
 <p>numbers = [3, 1, 2, 1]</p> 
 <p>v = compute_next_integer_part(n, numbers)</p> 
 <p>print('下一个数字为{}'.format(v))</p> 
 <p>遗憾的是，这个算法算出来的数字会因为计算上的精度误差而导致失之毫厘谬以千里。</p> 
 <p>计算平方根的连分数的正确方法</p> 
 <p>要想计算出正确的结果，就需要尽可能地消除在计算1 / (v - a)的时候引入的误差，因此必须把浮点数从分母中除去。</p> 
 <p>在这个网站中，作者以计算根号14的连分数为例，列出了一个表格</p> 
 <p align="center"><img src="https://images2.imgbox.com/8a/97/4kUYsAUi_o.png" alt="ae5c59d2b6eae847447004e2eae05084.png"></p> 
 <p>可以看到x1、x2，以及x3都是形如(sqrt(n)+a)/b这样的格式，这样的式子更利于控制误差。那么是否每一个待计算的x都符合这种格式呢？答案是肯定的，可以用数学归纳法予以证明(为了方便写公式，用LaTeX写好后截了图)</p> 
 <p align="center"><img src="https://images2.imgbox.com/d5/84/GVRKL0XG_o.png" alt="aacfd5503e94a46867e5c59fc2ad62e5.png"></p> 
 <p>在这个证明过程中，还得到了分子中的a以及分母中的b的递推公式，现在可以写出正确的计算连分数整数部分的代码了。</p> 
 <p>用Common Lisp实现上述算法</p> 
 <p>为了在实现这个算法的同时还要写出优雅的代码，我会用上Common Lisp的面向对象特性。首先是定义一个类来表示一个可以不断提高精度的连分数(defpackage #:com.liutos.cf</p> 
 <p>(:use #:cl))</p> 
 <p>(in-package #:com.liutos.cf)</p> 
 <p>(defclass ()</p> 
 <p>((a</p> 
 <p>:documentation "数学归纳法中、分子中与平方根相加的数"</p> 
 <p>:initform 0)</p> 
 <p>(b</p> 
 <p>:documentation "数学归纳法中的分母"</p> 
 <p>:initform 1)</p> 
 <p>(numbers</p> 
 <p>:documentation "连分数中的整数部分依次组成的数组。"</p> 
 <p>:initform nil)</p> 
 <p>(origin</p> 
 <p>:documentation "被开平方的数字"</p> 
 <p>:initarg :origin))</p> 
 <p>(:documentation "表示整数ORIGIN的平方根的连分数。"))</p> 
 <p>接着再定义这个类需要实现的“接口”(defgeneric advance (cf)</p> 
 <p>(:documentation "让连分数CF提高到下一个精度。"))</p> 
 <p>(defgeneric into-rational (cf)</p> 
 <p>(:documentation "将连分数CF转换为有理数类型的值。"))</p> 
 <p>最后来实现上述两个接口(defmethod advance ((cf ))</p> 
 <p>"根据递推公式计算出下一批a、b，以及连分数的整数部分。"</p> 
 <p>(let* ((a (slot-value cf 'a))</p> 
 <p>(b (slot-value cf 'b))</p> 
 <p>(n (slot-value cf 'origin))</p> 
 <p>(m (truncate (+ (sqrt n) a) b)))</p> 
 <p>(let ((a (- (* b m) a))</p> 
 <p>(b (/ (- n (expt (- a (* b m)) 2)) b)))</p> 
 <p>(setf (slot-value cf 'a) a</p> 
 <p>(slot-value cf 'b) b</p> 
 <p>(slot-value cf 'numbers) (append (slot-value cf 'numbers) (list m))))</p> 
 <p>(values)))</p> 
 <p>(defmethod into-rational ((cf ))</p> 
 <p>(let* ((numbers (reverse (slot-value cf 'numbers)))</p> 
 <p>(v (first numbers)))</p> 
 <p>(dolist (n (rest numbers))</p> 
 <p>(setf v</p> 
 <p>(+ n (/ 1 v))))</p> 
 <p>v))</p> 
 <p>在实现into-rational方法上，Common Lisp的有理数数值类型给我带来了极大的便利，它使我不必担心计算(/ 1 v)的时候会引入误差，代码写起来简单直白。</p> 
 <p>解题</p> 
 <p>乘胜追击，用Common Lisp解答第66题(defun find-min-x (D)</p> 
 <p>(let ((cf (make-instance ' :origin D)))</p> 
 <p>(loop</p> 
 <p>(advance cf)</p> 
 <p>(let* ((ratio (into-rational cf))</p> 
 <p>(x (numerator ratio))</p> 
 <p>(y (denominator ratio)))</p> 
 <p>(when (= (- (* x x) (* D y y)) 1)</p> 
 <p>(return-from find-min-x x))))))</p> 
 <p>(defun square-p (n)</p> 
 <p>(let ((rt (sqrt n)))</p> 
 <p>(= rt (truncate rt))))</p> 
 <p>(defun pro66 (&amp;optional (bnd 1000))</p> 
 <p>(let ((target-d)</p> 
 <p>(max-x 0))</p> 
 <p>(loop :for i :from 2 :to bnd</p> 
 <p>:when (not (square-p i))</p> 
 <p>:do (let ((x (find-min-x i)))</p> 
 <p>(if (&gt; x max-x)</p> 
 <p>(setf target-d i</p> 
 <p>max-x x))))</p> 
 <p>(values target-d max-x)))</p> 
 <p>答案的D是多少就不说了，不过作为答案的x是16421658242965910275055840472270471049。有兴趣的读者可以试一下暴力解法要花多久才能算到这个数字。</p> 
 <p>全文完。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/774e7a932bcf581e01af15101c51cdf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java system in_JAVA中的System.in</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26210fdd7d2e83817a93b2cc01de9bf3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java broken pipe_java Broken pipe 几种原因</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>