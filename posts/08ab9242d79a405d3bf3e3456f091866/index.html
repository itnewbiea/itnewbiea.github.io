<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android数据存储五种方式总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android数据存储五种方式总结" />
<meta property="og:description" content="本文介绍Android平台进行数据存储的五大方式,分别如下: 1 使用SharedPreferences存储数据
2 文件存储数据 3 SQLite数据库存储数据
4 使用ContentProvider存储数据
5 网络存储数据
第一种： 使用SharedPreferences存储数据 SharedPreferencese的使用:https://blog.csdn.net/augfun/article/details/54563808
适用范围：保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口 令密码等。
核心原理：保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data/&lt;package name&gt;/shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。 SharedPreferences本身是一 个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例
class ViewOcl implements View.OnClickListener{ @Override public void onClick(View v) { switch(v.getId()){ case R.id.btnSet: //步骤1：获取输入值 String code = txtCode.getText().toString().trim(); //步骤2-1：创建一个SharedPreferences.Editor接口对象，lock表示要写入的XML文件名，MODE_WORLD_WRITEABLE写操作 SharedPreferences.Editor editor = getSharedPreferences(&#34;lock&#34;, MODE_WORLD_WRITEABLE).edit(); //步骤2-2：将获取过来的值放入文件 editor.putString(&#34;code&#34;, code); //步骤3：提交 editor.commit(); Toast.makeText(getApplicationContext(), &#34;口令设置成功&#34;, Toast.LENGTH_LONG).show(); break; case R.id.btnGet: //步骤1：创建一个SharedPreferences接口对象 SharedPreferences read = getSharedPreferences(&#34;lock&#34;, MODE_WORLD_READABLE); //步骤2：获取文件中的值 String value = read." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/08ab9242d79a405d3bf3e3456f091866/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-24T16:07:48+08:00" />
<meta property="article:modified_time" content="2019-02-24T16:07:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android数据存储五种方式总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文介绍Android平台进行数据存储的五大方式,分别如下:   <br><strong>    1 使用SharedPreferences存储数据<br>     2 文件存储数据      <br>     3 SQLite数据库存储数据<br>     4 使用ContentProvider存储数据<br>     5 网络存储数据</strong></p> 
<h4>第一种： 使用SharedPreferences存储数据</h4> 
<p>SharedPreferencese的使用:<a href="https://blog.csdn.net/augfun/article/details/54563808">https://blog.csdn.net/augfun/article/details/54563808</a></p> 
<p>   <strong> 适用范围：</strong>保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口 令密码等。</p> 
<p><strong>核心原理：</strong>保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data/&lt;package name&gt;/shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。 SharedPreferences本身是一 个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例</p> 
<pre class="has"><code class="language-java">class ViewOcl implements View.OnClickListener{

        @Override
        public void onClick(View v) {

            switch(v.getId()){
            case R.id.btnSet:
                //步骤1：获取输入值
                String code = txtCode.getText().toString().trim();
                //步骤2-1：创建一个SharedPreferences.Editor接口对象，lock表示要写入的XML文件名，MODE_WORLD_WRITEABLE写操作
                SharedPreferences.Editor editor = getSharedPreferences("lock", MODE_WORLD_WRITEABLE).edit();
                //步骤2-2：将获取过来的值放入文件
                editor.putString("code", code);
                //步骤3：提交
                editor.commit();
                Toast.makeText(getApplicationContext(), "口令设置成功", Toast.LENGTH_LONG).show();
                break;
            case R.id.btnGet:
                //步骤1：创建一个SharedPreferences接口对象
                SharedPreferences read = getSharedPreferences("lock", MODE_WORLD_READABLE);
                //步骤2：获取文件中的值
                String value = read.getString("code", "");
                Toast.makeText(getApplicationContext(), "口令为："+value, Toast.LENGTH_LONG).show();
                
                break;
                
            }</code></pre> 
<h4>第二种： 文件存储数据</h4> 
<p><strong>核心原理:</strong> Context提供了两个方法来打开数据文件里的文件IO流 FileInputStream openFileInput(String name); FileOutputStream(String name , int mode),这两个方法第一个参数 用于指定文件名，第二个参数指定打开文件的模式。</p> 
<p><strong>具体有以下值可选</strong>：</p> 
<p><span style="color:#f33b45;">MODE_PRIVATE：</span>为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可   以使用Context.MODE_APPEND<br><span style="color:#f33b45;">MODE_APPEND：</span>模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。<br><span style="color:#f33b45;">MODE_WORLD_READABLE：</span>表示当前文件可以被其他应用读取；<br><span style="color:#f33b45;">MODE_WORLD_WRITEABLE：</span>表示当前文件可以被其他应用写入。<br>  除此之外，Context还提供了如下几个重要的方法：<br><span style="color:#f33b45;">getDir(String name , int mode):</span>在应用程序的数据文件夹下获取或者创建name对应的子目录<br><span style="color:#f33b45;">File getFilesDir():</span>获取该应用程序的数据文件夹得绝对路径<br><span style="color:#f33b45;">String[] fileList():</span>返回该应用数据文件夹的全部文件</p> 
<pre class="has"><code class="language-java">public String read() {
        try {
            FileInputStream inStream = this.openFileInput("message.txt");
            byte[] buffer = new byte[1024];
            int hasRead = 0;
            StringBuilder sb = new StringBuilder();
            while ((hasRead = inStream.read(buffer)) != -1) {
                sb.append(new String(buffer, 0, hasRead));
            }

            inStream.close();
            return sb.toString();
        } catch (Exception e) {
            e.printStackTrace();
        } 
        return null;
    }
    
    public void write(String msg){
        // 步骤1：获取输入值
        if(msg == null) return;
        try {
            // 步骤2:创建一个FileOutputStream对象,MODE_APPEND追加模式
            FileOutputStream fos = openFileOutput("message.txt",
                    MODE_APPEND);
            // 步骤3：将获取过来的值放入文件
            fos.write(msg.getBytes());
            // 步骤4：关闭数据流
            fos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }</code></pre> 
<p>openFileOutput()方法的第一参数用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。创建的文件保存在/data/data/&lt;package name&gt;/files目录，如： /data/data/cn.tony.app/files/message.txt，<br>  下面讲解某些特殊文件读写需要注意的地方:<br> 读写sdcard上的文件<br> 其中读写步骤按如下进行:<br> 1、调用Environment的getExternalStorageState()方法判断手机上是否插了sd卡,且应用程序具有读写SD卡的权限，如下代码将返回true<br> Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)<br> 2、调用Environment.getExternalStorageDirectory()方法来获取外部存储器，也就是SD卡的目录,或者使用"/mnt/sdcard/"目录<br> 3、使用IO流操作SD卡上的文件 <br> 注意点：手机应该已插入SD卡，对于模拟器而言，可通过mksdcard命令来创建虚拟存储卡<br>            必须在AndroidManifest.xml上配置读写SD卡的权限</p> 
<pre class="has"><code class="language-html">&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;</code></pre> 
<p>案例代码：</p> 
<pre class="has"><code class="language-java">// 文件写操作函数
    private void write(String content) {
        if (Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED)) { // 如果sdcard存在
            File file = new File(Environment.getExternalStorageDirectory()
                    .toString()
                    + File.separator
                    + DIR
                    + File.separator
                    + FILENAME); // 定义File类对象
            if (!file.getParentFile().exists()) { // 父文件夹不存在
                file.getParentFile().mkdirs(); // 创建文件夹
            }
            PrintStream out = null; // 打印流对象用于输出
            try {
                out = new PrintStream(new FileOutputStream(file, true)); // 追加文件
                out.println(content);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (out != null) {
                    out.close(); // 关闭打印流
                }
            }
        } else { // SDCard不存在，使用Toast提示用户
            Toast.makeText(this, "保存失败，SD卡不存在！", Toast.LENGTH_LONG).show();
        }
    }

    // 文件读操作函数
    private String read() {

        if (Environment.getExternalStorageState().equals(
                Environment.MEDIA_MOUNTED)) { // 如果sdcard存在
            File file = new File(Environment.getExternalStorageDirectory()
                    .toString()
                    + File.separator
                    + DIR
                    + File.separator
                    + FILENAME); // 定义File类对象
            if (!file.getParentFile().exists()) { // 父文件夹不存在
                file.getParentFile().mkdirs(); // 创建文件夹
            }
            Scanner scan = null; // 扫描输入
            StringBuilder sb = new StringBuilder();
            try {
                scan = new Scanner(new FileInputStream(file)); // 实例化Scanner
                while (scan.hasNext()) { // 循环读取
                    sb.append(scan.next() + "\n"); // 设置文本
                }
                return sb.toString();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (scan != null) {
                    scan.close(); // 关闭打印流
                }
            }
        } else { // SDCard不存在，使用Toast提示用户
            Toast.makeText(this, "读取失败，SD卡不存在！", Toast.LENGTH_LONG).show();
        }
        return null;
    }</code></pre> 
<h4>第三种：SQLite存储数据</h4> 
<p>SQLite是轻量级嵌入式数据库引擎，它支持 SQL 语言，并且只利用很少的内存就有很好的性能。现在的主流移动设备像Android、iPhone等都使用SQLite作为复杂数据的存储引擎，在我们为移动设备开发应用程序时，也许就要使用到SQLite来存储我们大量的数据，所以我们就需要掌握移动设备上的SQLite开发技巧</p> 
<p><a href="https://blog.csdn.net/augfun/article/details/54563972">https://blog.csdn.net/augfun/article/details/54563972</a></p> 
<h4>第四种：ContentProvider</h4> 
<p>ContentProvider是一种内容共享型组件，它通过Binder向其他组件乃至其他应用提供数据。当ContentProvider所在的进程启动时，ContentProvider会同时启动并被发布到AMS中。需要注意的是，这个时候ContentProvider的onCreate要先于Application的onCreate而执行，这在四大组件中是一个少有的现象。系统预置了许多ContentProvider，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法即可。</p> 
<p><a href="https://blog.csdn.net/augfun/article/details/55805594">https://blog.csdn.net/augfun/article/details/55805594</a></p> 
<h4>第五种:网络存储数据</h4> 
<p>android网络编程:<a href="https://blog.csdn.net/augfun/article/details/54590018">https://blog.csdn.net/augfun/article/details/54590018</a></p> 
<p>android端实现断点续传下载:<a href="https://blog.csdn.net/augfun/article/details/54664979">https://blog.csdn.net/augfun/article/details/54664979</a></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72d5a89a93d2a4c33f8a99e73f261f8c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LaTeX中argmin / argmax下标书写方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a386972e71843bc15c21fbcb0c42599c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">语言_JAVA</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>