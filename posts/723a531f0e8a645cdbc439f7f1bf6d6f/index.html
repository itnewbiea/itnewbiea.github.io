<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java操作MyBatis-Plus通过自定义拦截器对mysql字段以注解形式实现自动加解密 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java操作MyBatis-Plus通过自定义拦截器对mysql字段以注解形式实现自动加解密" />
<meta property="og:description" content="一.需求背景 跟大学室友闲谈时，了解到他公司正在做项目内对数据库敏感字段实现自动加解密的需求，使用的技术是Springboot，Mybatis-Plus,MySql等技术栈，加密算法是用的AES，密钥是放在华为云，这里实现一个阉割版的demo，仅供有兴趣的同学进行参考。
二.前置条件 首先我自己在日常搭了一个普通的springboot项目，目前还没有前台，所以就在浏览器请求tomcat模拟接口。
其次，这里的是实现主要是应用了Mybatis的拦截器，AES算法，mysql等技术栈，需要了解一下相关背景。
1.AES算法 AES的全称是Advanced Encryption Standard，意思是高级加密标准。它的出现主要是为了取代DES加密算法的，因为我们都知道DES算法的密钥长度是56Bit，因此算法的理论安全强度是2的56次方。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得计算机的处理能力越来越强，虽然出现了3DES的加密方法，但由于它的加密时间是DES算法的3倍多，64Bit的分组大小相对较小，所以还是不能满足人们对安全性的要求。于是1997年1月2号，美国国家标准技术研究所宣布希望征集高级加密标准，用以取代DES。AES也得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。
在密码标准征集中，所有AES候选提交方案都必须满足以下标准：
分组大小为128位的分组密码。
必须支持三种密码标准：128位、192位和256位。
比提交的其他算法更安全。
在软件和硬件实现上都很高效。
2.Mybatis拦截器 拦截器（Interceptor）在 Mybatis 中被当做插件（plugin）对待，官方文档提供了 Executor（拦截执行器的方法），ParameterHandler（拦截参数的处理），ResultSetHandler（拦截结果集的处理），StatementHandler（拦截Sql语法构建的处理） 共4种，并且提示“这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码”。
拦截器的使用场景主要是更新数据库的通用字段，分库分表，加解密等的处理。
1.1 MyBatis自定义拦截器 实现org.apache.ibatis.plugin.Interceptor接口。添加拦截器注解org.apache.ibatis.plugin.Intercepts配置文件中添加拦截器 1.2 在MyBatis中可被拦截的类型有四种(按照拦截顺序) Executor：拦截执行器的方法。ParameterHandler：拦截参数的处理。ResultHandler：拦截结果集的处理。StatementHandler：拦截Sql语法构建的处理，绝大部分我们是在这里设置我们的拦截器 先执行每个插件的plugin方法，若是@Intercepts注解标明需要拦截该对象，那么生成类型对象的代理对象。（即使该插件需要拦截该类型对象，但是依旧会执行下一个插件的plugin方法）。知道执行完毕所有的plugin方法。在执行每个Intercept方法。
1.3 拦截器注解的作用： 自定义拦截器必须使用MyBatis提供的注解来声明我们要拦截的类型对象。
Mybatis插件都要有Intercepts注解来指定要拦截哪个对象哪个方法。我们知道，Plugin.wrap方法会返回四大接口对象的代理对象，会拦截所有的方法。在代理对象执行对应方法的时候，会调用InvocationHandler处理器的invoke方法。
1.4 拦截器注解的规则： 具体规则如下：
@Intercepts({ @Signature(type = StatementHandler.class, method = &#34;query&#34;, args = {Statement.class, ResultHandler.class}), @Signature(type = StatementHandler.class, method = &#34;update&#34;, args = {Statement.class}), @Signature(type = StatementHandler.class, method = &#34;batch&#34;, args = {Statement.class}) }) 复制代码 @Intercepts：标识该类是一个拦截器@Signature：指明自定义拦截器需要拦截哪一个类型，哪一个方法； type：对应四种类型中的一种；method：对应接口中的哪类方法（因为可能存在重载方法）；args：对应哪一个方法； 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/723a531f0e8a645cdbc439f7f1bf6d6f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-08T10:55:07+08:00" />
<meta property="article:modified_time" content="2023-03-08T10:55:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java操作MyBatis-Plus通过自定义拦截器对mysql字段以注解形式实现自动加解密</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.需求背景</h2> 
<p>跟大学室友闲谈时，了解到他公司正在做项目内对数据库敏感字段实现自动加解密的需求，使用的技术是Springboot，Mybatis-Plus,MySql等技术栈，加密算法是用的AES，密钥是放在华为云，这里实现一个阉割版的demo，仅供有兴趣的同学进行参考。</p> 
<h2>二.前置条件</h2> 
<p>首先我自己在日常搭了一个普通的springboot项目，目前还没有前台，所以就在浏览器请求tomcat模拟接口。</p> 
<p>其次，这里的是实现主要是应用了Mybatis的拦截器，AES算法，mysql等技术栈，需要了解一下相关背景。</p> 
<h3>1.AES算法</h3> 
<p>AES的全称是Advanced Encryption Standard，意思是高级加密标准。它的出现主要是为了取代DES加密算法的，因为我们都知道DES算法的密钥长度是56Bit，因此算法的理论安全强度是2的56次方。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得计算机的处理能力越来越强，虽然出现了3DES的加密方法，但由于它的加密时间是DES算法的3倍多，64Bit的分组大小相对较小，所以还是不能满足人们对安全性的要求。于是1997年1月2号，美国国家标准技术研究所宣布希望征集高级加密标准，用以取代DES。AES也得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。</p> 
<p>在密码标准征集中，所有AES候选提交方案都必须满足以下标准：</p> 
<ul><li> <p>分组大小为128位的分组密码。</p> </li><li> <p>必须支持三种密码标准：128位、192位和256位。</p> </li><li> <p>比提交的其他算法更安全。</p> </li><li> <p>在软件和硬件实现上都很高效。</p> </li></ul> 
<h3>2.Mybatis拦截器</h3> 
<p>拦截器（Interceptor）在 Mybatis 中被当做插件（plugin）对待，官方文档提供了 Executor（拦截执行器的方法），ParameterHandler（拦截参数的处理），ResultSetHandler（拦截结果集的处理），StatementHandler（拦截Sql语法构建的处理） 共4种，并且提示“这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码”。</p> 
<p>拦截器的使用场景主要是更新数据库的通用字段，分库分表，加解密等的处理。</p> 
<h4>1.1 MyBatis自定义拦截器</h4> 
<ul><li>实现<code>org.apache.ibatis.plugin.Interceptor</code>接口。</li><li>添加拦截器注解<code>org.apache.ibatis.plugin.Intercepts</code></li><li>配置文件中添加拦截器</li></ul> 
<h4>1.2 在MyBatis中可被拦截的类型有四种(按照拦截顺序)</h4> 
<ul><li>Executor：拦截执行器的方法。</li><li>ParameterHandler：拦截参数的处理。</li><li>ResultHandler：拦截结果集的处理。</li><li>StatementHandler：拦截Sql语法构建的处理，<em>绝大部分我们是在这里设置我们的拦截器</em></li></ul> 
<p>先执行每个插件的plugin方法，若是<code>@Intercepts</code>注解标明需要拦截该对象，那么生成类型对象的代理对象。（即使该插件需要拦截该类型对象，但是依旧会执行下一个插件的plugin方法）。知道执行完毕所有的plugin方法。在执行每个Intercept方法。</p> 
<h4>1.3 拦截器注解的作用：</h4> 
<p>自定义拦截器必须使用MyBatis提供的注解来声明我们要拦截的类型对象。</p> 
<p>Mybatis插件都要有Intercepts注解来<strong>指定要拦截哪个对象哪个方法</strong>。我们知道，Plugin.wrap方法会返回四大接口对象的代理对象，会拦截所有的方法。在代理对象执行对应方法的时候，会调用InvocationHandler处理器的invoke方法。</p> 
<h4>1.4 拦截器注解的规则：</h4> 
<p>具体规则如下：</p> 
<pre><code>@Intercepts({
    @Signature(type = StatementHandler.class, method = "query", args = {Statement.class, ResultHandler.class}),
    @Signature(type = StatementHandler.class, method = "update", args = {Statement.class}),
    @Signature(type = StatementHandler.class, method = "batch", args = {Statement.class})
})
复制代码</code></pre> 
<ul><li>@Intercepts：标识该类是一个拦截器</li><li>@Signature：指明自定义拦截器需要拦截哪一个类型，哪一个方法； 
  <ul><li>type：对应四种类型中的一种；</li><li>method：对应接口中的哪类方法（因为可能存在重载方法）；</li><li>args：对应哪一个方法；</li></ul></li></ul> 
<h4>1.5. 拦截器可拦截的方法</h4> 
<table><thead><tr><th>拦截的类</th><th>拦截的方法</th></tr></thead><tbody><tr><td>Executor</td><td>update, query, flushStatements, commit, rollback,getTransaction, close, isClosed</td></tr><tr><td>ParameterHandler</td><td>getParameterObject, setParameters</td></tr><tr><td>StatementHandler</td><td>prepare, parameterize, batch, update, query</td></tr><tr><td>ResultSetHandler</td><td>handleResultSets, handleOutputParameters</td></tr></tbody></table> 
<p><code>Executor</code> 提供的方法中，<code>update</code> 包含了 新增，修改和删除类型，无法直接区分，需要借助 <code>MappedStatement</code> 类的属性 <code>SqlCommandType</code> 来进行判断，该类包含了所有的操作类型</p> 
<pre>public enum SqlCommandType {
  UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH;
}</pre> 
<p>毕竟新增和修改的场景，有些参数是有区别的，比如创建时间和更新时间，<code>update</code> 时是无需兼顾创建时间字段的。</p> 
<h3>3.mysql数据库创建表</h3> 
<pre><code class="language-sql">create table user
(
    id          bigint unsigned auto_increment comment '主键'
        primary key,
    name        varchar(20)                                    not null comment '姓名',
    balance     int         default 0                          not null comment '账户余额',
    password    varchar(50) not null comment '密码',
    create_time datetime    default CURRENT_TIMESTAMP          not null comment '创建时间',
    update_time datetime    default CURRENT_TIMESTAMP          null on update CURRENT_TIMESTAMP comment '更新时间'
)
    comment '用户表';</code></pre> 
<p>这里的password就是我们要加解密的字段，存储时要进行加密，获取查询后进行解密。</p> 
<h3>4.Maven依赖</h3> 
<pre><code class="language-sql">        &lt;!--mybatis-plus依赖 --&gt;
        &lt;dependency&gt;
			&lt;groupId&gt;com.baomidou&lt;/groupId&gt;
			&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;3.4.0&lt;/version&gt;
		&lt;/dependency&gt;
        &lt;dependency&gt;
			&lt;groupId&gt;com.baomidou&lt;/groupId&gt;
			&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;3.4.0&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;!--Mysql jdbc驱动--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;mysql&lt;/groupId&gt;
			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
			&lt;version&gt;8.0.17&lt;/version&gt;
		&lt;/dependency&gt;</code></pre> 
<p></p> 
<h2>三.代码实现</h2> 
<p>实现思路就是首先通过注解，能确定需要加解密的表和字段，然后通过自定义注解进行标注，通过自定义拦截器对字段进行加解密操作。</p> 
<h3>1.AES加解密工具类</h3> 
<pre><code class="language-java">import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

/**
 * 加解密工具类
 * @author lima
 * @date 2023/3/3 16:56
 */
public class AESUtils {
    private static final String ALGORITHM = "AES";
    private static final String SECRET_KEY = "aes-key-lima1995"; // 密钥

    /**
     * 加密
     */
    public static String encrypt(String value) throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        byte[] encrypted = cipher.doFinal(value.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }

    /**
     * 解密
     */
    public static String decrypt(String value) throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        byte[] decoded = Base64.getDecoder().decode(value);
        byte[] decrypted = cipher.doFinal(decoded);
        return new String(decrypted);
    }
}
</code></pre> 
<h3>2.自定义注解</h3> 
<pre><code class="language-java">import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 带有敏感字段的类需要加这个注解
 * @author lima
 * @date 2023/3/6 16:18
 */
@Inherited
@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface SensitiveData {
}</code></pre> 
<pre><code class="language-java">import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 需要加解密的字段用这个注解
 * @author lima
 * @date 2023/3/3 17:29
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Encrypted {

}
</code></pre> 
<h3>3.加密拦截器</h3> 
<pre><code class="language-java">

import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.plugin.*;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;
import java.lang.reflect.Field;
import java.sql.PreparedStatement;
import java.util.Objects;

/**
 * @author lima
 * @date 2023/3/6 16:19
 */
@Slf4j
@Component
@Intercepts({
        @Signature(type = ParameterHandler.class, method = "setParameters", args = {PreparedStatement.class}),
})
public class EncryptInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        try {
            ParameterHandler parameterHandler = (ParameterHandler) invocation.getTarget();
            // 获取参数对像，即 mapper 中 paramsType 的实例
            Field parameterField = parameterHandler.getClass().getDeclaredField("parameterObject");
            parameterField.setAccessible(true);
            //取出实例
            Object parameterObject = parameterField.get(parameterHandler);
            if (parameterObject != null) {
                Class&lt;?&gt; parameterObjectClass = parameterObject.getClass();
                //校验该实例的类是否被@SensitiveData所注解
                SensitiveData sensitiveData = AnnotationUtils.findAnnotation(parameterObjectClass, SensitiveData.class);
                if (Objects.nonNull(sensitiveData)) {
                    //取出当前当前类所有字段，传入加密方法
                    Field[] declaredFields = parameterObjectClass.getDeclaredFields();
                    encrypt(declaredFields, parameterObject);
                }
            }
            return invocation.proceed();
        } catch (Exception e) {
            log.error("加密失败", e);
        }
        return invocation.proceed();
    }

    /**
     * 切记配置，否则当前拦截器不会加入拦截器链
     */
    @Override
    public Object plugin(Object o) {
        return Plugin.wrap(o, this);
    }

    public &lt;T&gt; T encrypt(Field[] declaredFields, T paramsObject) throws Exception {
        for (Field field : declaredFields) {
            //取出所有被EncryptDecryptField注解的字段
            Encrypted sensitiveField = field.getAnnotation(Encrypted.class);
            if (!Objects.isNull(sensitiveField)) {
                field.setAccessible(true);
                Object object = field.get(paramsObject);
                //暂时只实现String类型的加密
                if (object instanceof String) {
                    String value = (String) object;
                    //加密  这里我使用自定义的AES加密工具
                    field.set(paramsObject, AESUtils.encrypt(value));
                }
            }
        }
        return paramsObject;
    }
}</code></pre> 
<h3>4.解密拦截器</h3> 
<pre><code class="language-java">import org.apache.ibatis.executor.resultset.ResultSetHandler;
import org.apache.ibatis.plugin.*;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import java.lang.reflect.Field;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Objects;

/**
 * 解密拦截器
 * @author lima
 * @date 2023/3/6 16:22
 */
@Intercepts({
        @Signature(type = ResultSetHandler.class, method = "handleResultSets", args = {Statement.class})
})
@Slf4j
@Component
public class DecryptInterceptor implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Object resultObject = invocation.proceed();
        try {
            if (Objects.isNull(resultObject)) {
                return null;
            }
            //基于selectList
            if (resultObject instanceof ArrayList) {
                ArrayList resultList = (ArrayList) resultObject;
                if (!CollectionUtils.isEmpty(resultList) &amp;&amp; needToDecrypt(resultList.get(0))) {
                    for (Object result : resultList) {
                        //逐一解密
                        decrypt(result);
                    }
                }
                //基于selectOne
            } else {
                if (needToDecrypt(resultObject)) {
                    AESUtils.decrypt((String) resultObject);
                }
            }
            return resultObject;
        } catch (Exception e) {
            log.error("解密失败", e);
        }
        return resultObject;
    }

    private boolean needToDecrypt(Object object) {
        Class&lt;?&gt; objectClass = object.getClass();
        SensitiveData sensitiveData = AnnotationUtils.findAnnotation(objectClass, SensitiveData.class);
        return Objects.nonNull(sensitiveData);
    }

    @Override
    public Object plugin(Object o) {
        return Plugin.wrap(o, this);
    }

    public &lt;T&gt; T decrypt(T result) throws Exception {
        //取出resultType的类
        Class&lt;?&gt; resultClass = result.getClass();
        Field[] declaredFields = resultClass.getDeclaredFields();
        for (Field field : declaredFields) {
            //取出所有被EncryptDecryptField注解的字段
            Encrypted sensitiveField = field.getAnnotation(Encrypted.class);
            if (!Objects.isNull(sensitiveField)) {
                field.setAccessible(true);
                Object object = field.get(result);
                //只支持String的解密
                if (object instanceof String) {
                    String value = (String) object;
                    //对注解的字段进行逐一解密
                    field.set(result, AESUtils.decrypt(value));
                }
            }
        }
        return result;
    }
}</code></pre> 
<p></p> 
<h3>5.自定义controller、service、dao等</h3> 
<pre><code class="language-java">@RestController
public class UserController {
    @Autowired
    UserService userService;

    @RequestMapping("/create")
    public String create(String name,String password) throws Exception {
        Boolean result = userService.create(name,password);
        if(result){
            return "创建成功";
        }
        return "创建失败";
    }

    @RequestMapping("/query")
    public User query(Long id){
        return userService.query(id);
    }
}
</code></pre> 
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService{
    @Autowired
    UserDao userDao;

    @Override
    public Boolean create(String name, String password) throws Exception {
        return userDao.create(name,1000,password);
    }

    @Override
    public User query(Long id) {
        return userDao.query(id);
    }
}
</code></pre> 
<pre><code class="language-java">@Component
public class UserDao {
    @Resource
    UserMapper userMapper;

    public Boolean create(String name, Integer balance, String password) throws Exception {
        User user =new User();
        user.setName(name);
        user.setBalance(balance);
        user.setPassword(password);
        int insert = userMapper.insert(user);
        return insert &gt; 0;
    }

    public User query(Long id) {
        return userMapper.getUserById(id);
    }
}
</code></pre> 
<h2>四.结果演示</h2> 
<h3>1.创建</h3> 
<p><img alt="" height="1154" src="https://images2.imgbox.com/b1/79/WYb0Yy9F_o.png" width="1200"></p> 
<p></p> 
<p>这里使用postman模拟请求本地，查看数据库结果 </p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/22/94/iHWoLlaQ_o.png" width="1200"></p> 
<p></p> 
<h3>2.查询</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/30/62/k74TesZN_o.png" width="1200"></p> 
<p></p> 
<p>业务代码中没有任何关于加解密的代码，但是在插入和查询时，已经自动进行了加解密操作。</p> 
<p></p> 
<p>以上就是全部内容，希望对你有所帮助。</p> 
<p></p> 
<p></p> 
<p>参考资料：</p> 
<p><a class="link-info" href="https://juejin.cn/post/7027633293684113421" rel="nofollow" title="https://juejin.cn/post/7027633293684113421">https://juejin.cn/post/7027633293684113421</a></p> 
<p><a href="https://blog.csdn.net/lsqingfeng/article/details/113173379" title="Mybatis-plus实现在DAO层面对敏感数据的加解密_@sensitivefield_一缕82年的清风的博客-CSDN博客">Mybatis-plus实现在DAO层面对敏感数据的加解密_@sensitivefield_一缕82年的清风的博客-CSDN博客</a></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9eda56bdf1aa8dd2a808dc91c63bd170/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">element-ui 的 el-input-number的默认值设置为空</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/999bb63431e3d62fa376501992c8adf8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023最新Android大厂高频面试题（包含答案解析免费分享）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>