<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JokerのZYNQ7020】AXI4_Lite_GPIO。 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JokerのZYNQ7020】AXI4_Lite_GPIO。" />
<meta property="og:description" content="软件环境：vivado 2017.4 硬件平台：XC7Z020 今天主要是BB一下基于AXI4_Lite总线slave从端，增加自定义GPIO操作的方法。
先新建个基于AXI4_Lite总线的自定义IP部分。Tools------------&gt; Create and Package New IP。
然后选择Create a new AXI4 peripheral。
名字什么的最好起的有标志性一点，主要是存放的地方要设置好，以便后面其他工程调用的时候，也能找到。 接口类型选择Lite，Slave模式。
选Edit Ip，进入编辑模式。
打开以后就是下图这个样子，图里第一个红框可以认为是顶层文件，做外部接口用的，真正的功能和总线时序实现是在下面红框的文件里。因为模版的代码有点多，所以这里只说明该动的地方在哪，没说明的就是没动过的。
具体AXI4_Lite总线时序这次先不谈，先说这次文件怎么改， 开下面那个红框文件，18行用户接口那里，增加一个4位的LED输出，为什么是四位不是八位，因为我只有四个灯啊，当然你想八位也没什么问题，但是有用的还是只有四位啊。
接口OK了以后，在400行，加LED控制部分，写到总线上的数据会写到slv_reg0~slv_reg3，这里我们使用slv_reg0，将写到slv_reg0的数据传给LED，来改变LED的状态。
内层实现部分做好了，别忘了修改外层接口，老样子，18行增加外部接口，72行增加传给下层的接口。
都弄好了以后，两个文件分别按保存，然后在Design Sources里，双击这个文件。
在Ports and interfaces里，看到上面提示，刷新一下模块对外的接口。
噹 噹 噹 噹~新增加的LED接口就刷出来啦。
最后，在Review and Package里，重新封装一下IP，自定义基于AXI4_Lite的GPIO就搞定了。
回到主工程，Create block design后，搜索刚才新建的自定义IP的名字就能找到了。
搭建好的外部框架是下面这个样子。
然后老套路呀，Generate the output products，Create a HDL wrapper。加入管脚约束文件。产生Bitstream，最后导入SDK。
set_property PACKAGE_PIN J16 [get_ports {LED_o_0[0]}] set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[0]}] set_property PACKAGE_PIN K16 [get_ports {LED_o_0[1]}] set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[1]}] set_property PACKAGE_PIN G15 [get_ports {LED_o_0[2]}] set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[2]}] set_property PACKAGE_PIN H15 [get_ports {LED_o_0[3]}] set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[3]}] SDK中new application然后添加如下测试代码，就能看到四个LED轮流闪烁。 #include &lt;stdio." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/933a8cee67b7a921fed9568db81698de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-09T19:49:06+08:00" />
<meta property="article:modified_time" content="2018-12-09T19:49:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JokerのZYNQ7020】AXI4_Lite_GPIO。</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#e579b6;">软件环境：vivado 2017.4        硬件平台：XC7Z020 </span></p> 
<hr> 
<p> 今天主要是BB一下基于AXI4_Lite总线slave从端，增加自定义GPIO操作的方法。</p> 
<p>先新建个基于AXI4_Lite总线的自定义IP部分。Tools------------&gt; Create and Package New IP。</p> 
<p style="text-align:center;"><img alt="" class="has" height="141" src="https://images2.imgbox.com/0a/16/Dl5iW7Sd_o.png" width="379"></p> 
<p> 然后选择Create a new AXI4 peripheral。</p> 
<p style="text-align:center;"><img alt="" class="has" height="578" src="https://images2.imgbox.com/dd/e3/BvnlducY_o.png" width="856"></p> 
<p>名字什么的最好起的有标志性一点，主要是存放的地方要设置好，以便后面其他工程调用的时候，也能找到。 </p> 
<p style="text-align:center;"><img alt="" class="has" height="578" src="https://images2.imgbox.com/6f/4c/PeAgZp58_o.png" width="856"></p> 
<p>接口类型选择Lite，Slave模式。</p> 
<p style="text-align:center;"><img alt="" class="has" height="578" src="https://images2.imgbox.com/29/fe/n5eO3pIi_o.png" width="856"></p> 
<p> 选Edit Ip，进入编辑模式。</p> 
<p style="text-align:center;"><img alt="" class="has" height="578" src="https://images2.imgbox.com/80/88/EnzHQnia_o.png" width="856"></p> 
<p>打开以后就是下图这个样子，图里第一个红框可以认为是顶层文件，做外部接口用的，真正的功能和总线时序实现是在下面红框的文件里。因为模版的代码有点多，所以这里只说明该动的地方在哪，没说明的就是没动过的。</p> 
<p style="text-align:center;"><img alt="" class="has" height="453" src="https://images2.imgbox.com/05/6d/FuYm6hnA_o.png" width="750"></p> 
<p>具体AXI4_Lite总线时序这次先不谈，先说这次文件怎么改， 开下面那个红框文件，18行用户接口那里，增加一个4位的LED输出，为什么是四位不是八位，因为我只有四个灯啊，当然你想八位也没什么问题，但是有用的还是只有四位啊。</p> 
<p style="text-align:center;"><img alt="" class="has" height="65" src="https://images2.imgbox.com/b7/00/R4DhdrH1_o.png" width="312"></p> 
<p> 接口OK了以后，在400行，加LED控制部分，写到总线上的数据会写到slv_reg0~slv_reg3，这里我们使用slv_reg0，将写到slv_reg0的数据传给LED，来改变LED的状态。</p> 
<p style="text-align:center;"><img alt="" class="has" height="64" src="https://images2.imgbox.com/c7/83/sWIorSId_o.png" width="300"></p> 
<p>内层实现部分做好了，别忘了修改外层接口，老样子，18行增加外部接口，72行增加传给下层的接口。</p> 
<p><img alt="" class="has" height="59" src="https://images2.imgbox.com/e0/cc/VVl5ThTi_o.png" width="326"><img alt="" class="has" height="58" src="https://images2.imgbox.com/14/3a/BMrnVPYX_o.png" width="279"></p> 
<p>都弄好了以后，两个文件分别按保存，然后在Design Sources里，双击这个文件。</p> 
<p style="text-align:center;"><img alt="" class="has" height="320" src="https://images2.imgbox.com/91/c5/nKTerY0u_o.png" width="390"></p> 
<p> 在Ports and interfaces里，看到上面提示，刷新一下模块对外的接口。</p> 
<p style="text-align:center;"><img alt="" class="has" height="374" src="https://images2.imgbox.com/c8/a1/89n3OSUf_o.png" width="583"></p> 
<p> 噹 噹 噹 噹~新增加的LED接口就刷出来啦。</p> 
<p style="text-align:center;"><img alt="" class="has" height="378" src="https://images2.imgbox.com/c1/48/dDNNKSsS_o.png" width="568"></p> 
<p>最后，在Review and Package里，重新封装一下IP，自定义基于AXI4_Lite的GPIO就搞定了。</p> 
<p><img alt="" class="has" height="570" src="https://images2.imgbox.com/9f/68/A4JgeADR_o.png" width="850"> </p> 
<p>回到主工程，Create block design后，搜索刚才新建的自定义IP的名字就能找到了。</p> 
<p style="text-align:center;"><img alt="" class="has" height="347" src="https://images2.imgbox.com/63/61/WctKx31f_o.png" width="603"></p> 
<p> 搭建好的外部框架是下面这个样子。</p> 
<p style="text-align:center;"><img alt="" class="has" height="282" src="https://images2.imgbox.com/cc/c1/aJBwgb9F_o.png" width="800"></p> 
<p>然后老套路呀，Generate the output products，Create a HDL wrapper。加入管脚约束文件。产生Bitstream，最后导入SDK。</p> 
<pre class="has"><code class="language-cpp">set_property PACKAGE_PIN J16 [get_ports {LED_o_0[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[0]}]

set_property PACKAGE_PIN K16 [get_ports {LED_o_0[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[1]}]

set_property PACKAGE_PIN G15 [get_ports {LED_o_0[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[2]}]

set_property PACKAGE_PIN H15 [get_ports {LED_o_0[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {LED_o_0[3]}]</code></pre> 
<hr> 
<p>SDK中new application然后添加如下测试代码，就能看到四个LED轮流闪烁。 </p> 
<pre class="has"><code class="language-cpp">#include &lt;stdio.h&gt;
#include "xparameters.h"
#include "xil_io.h"
#include "sleep.h"
#include "xil_types.h"

#define XGpio_axi_WriteReg(BaseAddr, RegOffset, Data)	\
		Xil_Out32((BaseAddr) + (u32)(RegOffset), (u32)(Data))

#define XPAR_AXI4_LITE_GPIO XPAR_AXI4_LITE_GPIO_0_S00_AXI_BASEADDR
#define AXI4_LITE_GPIO_REG0 0

int main()
{
	u8 i=0;
	XGpio_axi_WriteReg(XPAR_AXI4_LITE_GPIO,AXI4_LITE_GPIO_REG0,0X00);
	while(1)
	{
		for(i=0;i&lt;=3;i++)
		{
		XGpio_axi_WriteReg(XPAR_AXI4_LITE_GPIO,AXI4_LITE_GPIO_REG0,1&lt;&lt;i);
		usleep(500000);
		}
		i=0;
	}
}
</code></pre> 
<p>接下来对程序中的一些函数做一些解释说明：</p> 
<p>首先，最最最最最最最最最最最最最最最最最最最最最最最最常用的Xil_Out32((BaseAddr) + (u32)(RegOffset), (u32)(Data))，这个函数名和参数已经把意思表达的很清楚了。往BaseAddr+RegOffset里写入Data。</p> 
<pre class="has"><code class="language-cpp">static INLINE void Xil_Out32(UINTPTR Addr, u32 Value)
{
#ifndef ENABLE_SAFETY
	volatile u32 *LocalAddr = (volatile u32 *)Addr;
	*LocalAddr = Value;
#else
	XStl_RegUpdate(Addr, Value);
#endif
}</code></pre> 
<p>然后，XPAR_AXI4_LITE_GPIO_0_S00_AXI_BASEADDR这个东西是什么，哪来的。看下面。</p> 
<p style="text-align:center;"><img alt="" class="has" height="182" src="https://images2.imgbox.com/25/27/W7mWAXgK_o.png" width="662"></p> 
<p>之前在vivado里的自建IP，被映射到地址线上了，所以对这个地址的一顿操作，可以说就相当于对自建IP的一顿操作了。记住这个地址0x43C0_0000，然后在xparameters.h里找这个地址，可以看到。</p> 
<p style="text-align:center;"><img alt="" class="has" height="120" src="https://images2.imgbox.com/6f/11/krGP4ay2_o.png" width="420"></p> 
<p> 所以主函数里的XGpio_axi_WriteReg(XPAR_AXI4_LITE_GPIO,AXI4_LITE_GPIO_REG0,1&lt;&lt;i);就相当于在不停的给寄存器0赋值，就相当于在给slv_reg0不停的赋值，自然可以看到灯在轮流点亮了。</p> 
<hr> 
<p> <span style="color:#3399ea;">这节没啥好总结的，都是基本操作，修改基于AXI4_Lite线的自定义IP，就不多哔哔了。古德拜~</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5de006dfb22d8018cd93612d887fdc41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JFinal常见的错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/857f970f5fca54c8e502d1b1511cac50/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.lang.NoClassDefFoundError: Failed resolution of: Lcom/android/tools/ir/runtime/IncrementalChang</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>