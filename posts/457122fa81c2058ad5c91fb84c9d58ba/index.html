<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JavaEE】阻塞队列 &#43; 生产者消费者模型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JavaEE】阻塞队列 &#43; 生产者消费者模型" />
<meta property="og:description" content="目录
阻塞队列
阻塞队列的使用
生产者消费者模型
模型的两个好处
1. 降低耦合
2. 削峰填谷
简单实现阻塞队列
阻塞队列 阻塞队列是在一般的队列上升级而来的。
对于队列为空时，如果还想取队列中的元素，此时阻塞队列就会进行阻塞。
对于队列为满时，如果还想往队列中放元素，此时阻塞队列就会进行阻塞。
阻塞队列的使用 阻塞队列的具体使用由这个接口 BlockingQueue&lt;&gt;实现。
可以看到，该接口继承了队列，所以它有队列的所有方法。不过在使用阻塞队列时，我们一般只使用以下两种方法
方法说明void put(value)该方法是往队列里面添加元素，满了就阻塞Object take()该方法是取出队列的元素，空了就阻塞 其他的方法没有阻塞功能。 当我们实例化的时候可以看到，有以下三种实现方式。
简单使用一下阻塞队列。
import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; public class ThreadDemo21 { public static void main(String[] args) throws InterruptedException { // 这个队列的空间大小设置为 3 BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3); blockingQueue.put(1); blockingQueue.put(2); blockingQueue.put(3); // 因为只有一个主线程 // 当往队列里添加第四个元素时, 这是队列就会进行阻塞 blockingQueue.put(4); // 以下代码执行不到了 int ret = blockingQueue.take(); System.out.println(ret); ret = blockingQueue.take(); System.out.println(ret); ret = blockingQueue." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/457122fa81c2058ad5c91fb84c9d58ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-19T21:00:11+08:00" />
<meta property="article:modified_time" content="2023-01-19T21:00:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JavaEE】阻塞队列 &#43; 生产者消费者模型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97" rel="nofollow">阻塞队列</a></p> 
<p id="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">阻塞队列的使用</a></p> 
<p id="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B" rel="nofollow">生产者消费者模型</a></p> 
<p id="%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A5%BD%E5%A4%84-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A5%BD%E5%A4%84" rel="nofollow">模型的两个好处</a></p> 
<p id="1.%20%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88-toc" style="margin-left:80px;"><a href="#1.%20%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88" rel="nofollow">1. 降低耦合</a></p> 
<p id="2.%20%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7-toc" style="margin-left:80px;"><a href="#2.%20%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7" rel="nofollow">2. 削峰填谷</a></p> 
<p id="%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97" rel="nofollow">简单实现阻塞队列</a></p> 
<hr id="hr-toc"> 
<h2>阻塞队列</h2> 
<p>阻塞队列是在一般的队列上升级而来的。</p> 
<blockquote> 
 <p>对于队列为<strong>空</strong>时，如果还想<strong>取</strong>队列中的元素，此时阻塞队列就会进行<strong>阻塞</strong>。</p> 
 <p>对于队列为<strong>满</strong>时，如果还想往队列中<strong>放</strong>元素，此时阻塞队列就会进行<strong>阻塞</strong>。</p> 
</blockquote> 
<h3 id="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8">阻塞队列的使用</h3> 
<p>阻塞队列的具体使用由这个接口 BlockingQueue&lt;&gt;实现。</p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/62/ff/ZwnBTyMk_o.png" width="1003"></p> 
<p>可以看到，该接口继承了队列，所以它有队列的所有方法。不过在使用阻塞队列时，我们一般只使用以下两种方法</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>void put(value)</td><td>该方法是往队列里面添加元素，满了就阻塞</td></tr><tr><td>Object take()</td><td>该方法是取出队列的元素，空了就阻塞</td></tr></tbody></table> 
<p><strong>其他的方法没有阻塞功能</strong>。 </p> 
<p>当我们实例化的时候可以看到，有以下三种实现方式。</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/0e/6c/Df7W6cTa_o.png" width="918"></p> 
<p> 简单使用一下阻塞队列。</p> 
<pre><code class="language-java">import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class ThreadDemo21 {

    public static void main(String[] args) throws InterruptedException {

        // 这个队列的空间大小设置为 3
        BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(3);
        blockingQueue.put(1);
        blockingQueue.put(2);
        blockingQueue.put(3);
        // 因为只有一个主线程
        // 当往队列里添加第四个元素时, 这是队列就会进行阻塞
        blockingQueue.put(4);
        
        // 以下代码执行不到了 
        int ret = blockingQueue.take();
        System.out.println(ret);
        ret = blockingQueue.take();
        System.out.println(ret);
        ret = blockingQueue.take();
        System.out.println(ret);
        ret = blockingQueue.take();
        System.out.println(ret);
    }
}</code></pre> 
<p><img alt="" height="274" src="https://images2.imgbox.com/b2/7b/tFfDTr86_o.png" width="640">  </p> 
<hr> 
<h2 id="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">生产者消费者模型</h2> 
<p><img alt="" height="753" src="https://images2.imgbox.com/86/26/T3lik2RC_o.png" width="1200">对于上图的模型，就是生产者消费者模型。 </p> 
<p><strong>阻塞队列通常被应用到生产者消费者模型当中。阻塞队列充当缓冲区。</strong></p> 
<pre><code class="language-java">// 使用阻塞队列实现生产者消费者模型

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class ThreadDemo22 {

    public static void main(String[] args) {
        // 生产者产生的数字都放到阻塞队列中
        // 消费者从阻塞队列中拿到数字
        BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(1000);

        // t1线程是生产者
        Thread t1 = new Thread(() -&gt; {
            int i = 1;
            while (true) {
                try {
                    blockingQueue.put(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("生产者: " + i);
                i++;

                // 生产者每隔100ms产生一个数字
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // t2线程是消费者
        Thread t2 = new Thread(() -&gt; {
            while (true) {
                try {
                    int ret = blockingQueue.take();
                    System.out.println("消费者: " + ret);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t1.start();
        t2.start();

    }

}</code></pre> 
<p> <img alt="" height="480" src="https://images2.imgbox.com/9a/71/rXJqtZzm_o.png" width="554"></p> 
<hr> 
<p> </p> 
<h3 id="%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A5%BD%E5%A4%84">模型的两个好处</h3> 
<h4 id="1.%20%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88">1. 降低耦合</h4> 
<p>为引入该模型前，耦合度高。</p> 
<p><img alt="" height="766" src="https://images2.imgbox.com/f2/c2/puf2GVPD_o.png" width="1185"></p> 
<p>引入该模型后，耦合性降低。</p> 
<p><img alt="" height="787" src="https://images2.imgbox.com/e2/4d/S3RQT0at_o.png" width="1200"></p> 
<p> </p> 
<h4 id="2.%20%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7">2. 削峰填谷</h4> 
<p>前段时间鹅鸭杀游戏突然爆火，从日均几万人到四五十万人同时在线。此时大量用户数据就会到这个缓冲区当中，不至于一下子全部发送到服务器当中，导致服务器崩溃。这里的缓冲区就起到了削峰的作用；当用户数量下去之后，服务器就从缓冲区中继续读取数据，不至于在这个时间闲着没事干。</p> 
<hr> 
<h2 id="%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">简单实现阻塞队列</h2> 
<p>具体代码的解释都卸载注释中了。</p> 
<pre><code class="language-java">// 实现一个阻塞队列
// 不带泛型, 直接使用Integer类型
// 只实现 带有阻塞功能的 put 和 take 方法

class MyBlockQueue {

    private Integer[] arr = new Integer[100];
    private int head = 0;// 指向对头
    private int tail = 0;// 指向队尾
    private int size = 0;// 计数

    public void put(int value) throws InterruptedException {
        // 加锁只是针对当前的对象
        // 如果实例化了其他对象, 并不会相互影响
        synchronized(this) {
            // 这里while相当于多次if
            // 目的是为了判断唤醒之后是否数组是否还是满的, 满了继续阻塞
            // 因为在多线程下, 有可能顺序会发生变化
            while (size == arr.length) {
                this.wait();
            }
            // 没有满, 在tail指向的位置添加元素, 添加完之后tail后移
            arr[tail] = value;
            tail++;
            // tail如果到了末尾, 它就要从头开始
            if (tail &gt;= arr.length) {
                tail = 0;
            }
            //计数器++
            size++;
            // 此时数组中有元素了, 可以唤醒在take方法中因为数组为空而阻塞的原因了
            this.notify();
        }
    }

    // 由于涉及到多线程, 所以要考虑线程安全问题
    // head tail size都是会改变的变量, 所以考虑synchronized来保持其原子性
    public Integer take() throws InterruptedException {

        synchronized(this) {
            // 如果数组为空, 就要阻塞等待
            // 使用while的理由同上
            while (size == 0) {
                this.wait();
            }
            // 有元素, 开始从head指向的弹出
            Integer ret = arr[head];
            head++;
            if (head &gt;= arr.length) {
                head = 0;
            }
            size--;
            // 此时数组中有空的位置了, 可以唤醒在put方法中因为数组满而阻塞的原因了
            this.notify();
            return ret;
        }
    }
}

public class ThreadDemo24 {

    public static void main(String[] args) {
        // 使用生产者消费者模型测试一下实现的阻塞队列
        // t1 线程为生产者
        // t2 线程为消费者

        MyBlockQueue myBlockQueue = new MyBlockQueue();

        Thread t1 = new Thread(()-&gt; {
            int i = 1;
            while (true) {
                try {
                    myBlockQueue.put(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("生产者" + i);
                i++;
                // 让生产者每隔 100ms 生产出一个数字
                // 如果消费者没有时间限制, 这样就会出现队列为空而阻塞的情况
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        Thread t2 = new Thread(()-&gt; {
            while (true) {
                try {
                    int ret = myBlockQueue.take();
                    System.out.println("消费者" + ret);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        t1.start();
        t2.start();
    }
}
</code></pre> 
<p><img alt="" height="575" src="https://images2.imgbox.com/c1/16/JoqUYOcy_o.png" width="287"></p> 
<hr> 
<p>有什么错误评论区指出。希望可以帮到你。 </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/242e3535f49daa5db5c2c13c6540e467/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[C/C&#43;&#43;]对象指针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1672e2dfbbaede909ede21e9d2da1aa7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单片机开发中常用到的C语言中关于数组和字符串的函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>