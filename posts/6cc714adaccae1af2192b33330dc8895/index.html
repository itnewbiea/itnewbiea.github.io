<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2.MySQL索引创建方法及其优化 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2.MySQL索引创建方法及其优化" />
<meta property="og:description" content="索引优化分析 性能下降，SQL慢、执行时间长、等待时间长 数据过多——分库分表关联太多的表，太多join——SQL优化没有充分利用到索引 ——索引建立服务器调优及各个参数设置——调整my.cnf 其中优化手段“建立索引”最快捷也最常用。
预热—常见通用的join查询
其中：union关键字在使用时，两个结果的字段相等、字段数相等、字段顺序一致。
union all和union的区别在于去重，union会去重。
select a.*，b.* from t_emp a left join t_dept b on a.deptid = b.id where b.id is null union select a.*，b.* from t_dept b left join t_emp a on a.deptid = b.id where a.id is null; -- 查询a表独有和b表独有的数据 mysql 单表瓶颈500w
索引简介 索引(Index)是帮助MySQL高效获取数据的数据结构。
索引的本质：索引是数据结构
可将索引理解为&#34;排好序的快速查找数据结构&#34;。
数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法。这些数据结构就是索引。
索引的存放位置：一般来说，索引本身也很大，不可能全部存储在内存中，因此，索引往往以索引文件的形式存储在磁盘中。
索引的优势： 提高数据检索的效率，降低数据库的IO成本；通过索引对数据进行排序，降低数据排序的成本，减少CPU的消耗。 索引的劣势： 在提高查询速率的同时，降低了表更新的速度。因在更新表时，MySQL不仅保存表数据，还需保存索引文件每次添加的索引列字段实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引也需占用空间。 索引的结构：
B_tree 平衡树 Btree 非叶子节点包含 索引指向的数据向下的指针指向数据的指针 B&#43;tree 非叶子节点不包含索引指向的数据 MySQL选择B&#43;tree作为索引，相对有限的内存中，B&#43;tree的占用空间要比Btree小三分之一，相对发生IO的次数更少，时间更短。
时间复杂度 同一问题可用不同的算法解决，而一个算法的质量优劣将影响到算法及程序的执行效率。算法分析的目的在于选择合适的算法和改进算法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6cc714adaccae1af2192b33330dc8895/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-15T08:32:09+08:00" />
<meta property="article:modified_time" content="2021-07-15T08:32:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2.MySQL索引创建方法及其优化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>索引优化分析</h2> 
<h3><a id="SQL_2"></a>性能下降，SQL慢、执行时间长、等待时间长</h3> 
<ul><li>数据过多——分库分表</li><li>关联太多的表，太多join——SQL优化</li><li>没有充分利用到索引 ——索引建立</li><li>服务器调优及各个参数设置——调整my.cnf</li></ul> 
<p>其中优化手段“建立索引”最快捷也最常用。</p> 
<p>预热—常见通用的join查询</p> 
<p><img src="https://images2.imgbox.com/34/cf/7sDPwoSW_o.png" alt="在这里插入图片描述"></p> 
<p>其中：<code>union</code>关键字在使用时，两个结果的字段相等、字段数相等、字段顺序一致。</p> 
<p><code>union all</code>和<code>union</code>的区别在于<strong>去重</strong>，<code>union</code>会去重。</p> 
<pre><code class="prism language-mysql">select a.*，b.* from t_emp a 
left join t_dept b on a.deptid = b.id
where b.id is null
union
select a.*，b.* from t_dept b 
left join t_emp a on a.deptid = b.id
where a.id is null;
-- 查询a表独有和b表独有的数据

</code></pre> 
<p>mysql 单表瓶颈500w</p> 
<h3><a id="_33"></a>索引简介</h3> 
<p>索引(Index)是帮助MySQL高效获取数据的数据结构。</p> 
<p>索引的本质：索引是数据结构</p> 
<p>可将索引理解为"排好序的快速查找数据结构"。</p> 
<p>数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法。这些数据结构就是索引。</p> 
<p>索引的存放位置：一般来说，索引本身也很大，不可能全部存储在内存中，因此，索引往往以索引文件的形式存储在磁盘中。</p> 
<h4><a id="_45"></a>索引的优势：</h4> 
<ul><li>提高数据检索的效率，降低数据库的IO成本；</li><li>通过索引对数据进行排序，降低数据排序的成本，减少CPU的消耗。</li></ul> 
<h4><a id="_50"></a>索引的劣势：</h4> 
<ul><li>在提高查询速率的同时，降低了表更新的速度。因在更新表时，MySQL不仅保存表数据，还需保存索引文件每次添加的索引列字段</li><li>实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引也需占用空间。</li></ul> 
<p>索引的结构：</p> 
<h4><a id="B_tree__57"></a>B_tree 平衡树</h4> 
<ul><li>Btree 
  <ol><li>非叶子节点包含 
    <ol><li>索引指向的数据</li><li>向下的指针</li><li>指向数据的指针</li></ol> </li></ol> </li><li>B+tree 
  <ul><li>非叶子节点不包含索引指向的数据</li></ul> </li></ul> 
<p><strong>MySQL选择B+tree作为索引，相对有限的内存中，B+tree的占用空间要比Btree小三分之一，相对发生IO的次数更少，时间更短。</strong></p> 
<h4><a id="_69"></a>时间复杂度</h4> 
<p>同一问题可用不同的算法解决，而一个算法的质量优劣将影响到算法及程序的执行效率。算法分析的目的在于选择合适的算法和改进算法。</p> 
<p><code>O(n)</code> 时间复杂度 算法随着数量级n的增加在时间维度上的复杂程度。</p> 
<p><img src="https://images2.imgbox.com/72/15/HSqItrDP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_78"></a>聚簇索引和非聚簇索引</h4> 
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。</p> 
<p>“聚簇”表示数据行和相邻的间值聚簇存储在一起。</p> 
<p>只有主键索引是聚簇索引，即按照顺序排列好的索引。</p> 
<p>除了主键索引，其余建立的索引都是非聚簇索引，特点：非聚簇索引要对所有索引进行查找。</p> 
<p><img src="https://images2.imgbox.com/26/c0/gkPeXaJL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="mysql_92"></a>mysql索引分类</h3> 
<h4><a id="_94"></a>单值索引</h4> 
<p>​ 即一个索引只包含单个列，一个表可以有多个单列索引</p> 
<p>​</p> 
<ul><li>随表一起创建索引</li></ul> 
<pre><code class="prism language-mysql">create table 
customer(
    id int(10) unsigned auto_increment,
    customer_no varchar(200),
    customer_name varchar(200),
    primary key(id),
    key(customer_name) 
    );
-- key(customer_name) 随着表的创建，同时创建索引
</code></pre> 
<ul><li>单独创建单值索引<br> <code>CREATE INDEX idx_customer_name ON customer(customer_name)</code></li><li>删除索引<br> <code>DROP INDEX idx_customer_name ON customer;</code></li></ul> 
<h4><a id="_117"></a>唯一索引</h4> 
<p>​ 索引列的值必须必须唯一，但允许有空值<br> <code>CREATE UNIQUE INDEX [indexName] ON table_name(column)</code></p> 
<h4><a id="_122"></a>主键索引</h4> 
<p>​ 设定为主键后数据库会自动建立索引，Innodb 为聚簇索引</p> 
<h4><a id="_126"></a>复合索引</h4> 
<p>​ 即一个索引包含多个列。针对多个字段创建一个索引</p> 
<p>​ <code>create index idx_age_deptid_name on t_emp(age,deptid,name)</code></p> 
<p>​ 通过符合索引查询的结果为复合索引内的n条数据，即复合索引包含几条字段就返回几条字段的查询结果。</p> 
<h4><a id="_134"></a>基本语法</h4> 
<ul><li> <p>创建 <code>create [unique] index [indexName] on table_name(column)</code></p> 
  <ul><li> <p>创建单值索引</p> <p>给表t_emp表中的name字段创建索引：</p> <p><code>create index idx_name on t_emp(name)</code></p> </li><li> <p>唯一索引的创建</p> <p>在mysql中，随着主键的创立会自动生成索引，所以对于表中其他字段数据集唯一的字段可以设置唯一索引</p> <p>为员工表中员工编号字段创建唯一索引</p> <p><code>create unique index idx_empno in temp(emp_no)</code></p> </li><li> <p>复合索引</p> </li></ul> </li><li> <p>删除 <code>drop index [indexName] on mytable;</code></p> </li><li> <p>查看 <code>show index from table_name\G</code></p> </li><li> <p>使用alter命令（一般情况使用create就足够了）</p> <pre><code class="prism language-mysql">-- 四种方式来添加数据表的索引

alter table tbl_name add primary key(column_list);
-- 该语句添加一个主键，意味着索引值必须唯一且不为空

alter table tbl_name add unique index_name(column_list);
-- 这条语句创建索引的值必须是唯一的（除了Null外，Null可能会出现多次

alter table tbl_name add index index_name(column_list);
-- 添加普通索引，索引值可出现多次

alter table tbl_name add fulltext index_name(column_list);
-- 该语句指定是索引为fulltext，用于全文索引
</code></pre> </li></ul> 
<h4><a id="_178"></a>什么情况下需要创建索引</h4> 
<ul><li>主键自动创建唯一索引；；</li><li>频繁作为查询条件的字段应该创建索引；</li><li>查询中与其它表关联的字段，外键关系建立索引；</li><li>单键/组合索引的选择问题，组合索引的性价比更高；</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提升排序速度；</li><li>查询中统计或分组字段 ， 
  <ul><li><code>group by</code> 相较于<code>order by</code> 更伤性能，因为<code>group by</code>中包含<code>order by</code>先排序后分组。</li></ul> </li></ul> 
<h4><a id="_188"></a>那些情况不许创建索引</h4> 
<ul><li>表记录太少</li><li>经常增删改查的表或字段</li><li>where条件里用不到的字段不需要创建索引</li><li>过滤性不好的不适合创建索引</li></ul> 
<h3><a id="_195"></a>衡量是否因该建索引，怎么建立索引的“尺子”</h3> 
<p><strong>Explain</strong> 就是mysql提供给使用者的“尺子”</p> 
<h4><a id="Explain_199"></a>一、Explain是什么（查看执行计划）</h4> 
<p>执行计划：在MySQL逻辑架构中<code>optimizer(优化器)</code>在不改变查询结果的情况下调整sql执行顺序，生成执行计划。</p> 
<p>使用<code>EXPLAIN</code>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p> 
<h4><a id="Explain_205"></a>二、Explain能干什么？</h4> 
<ul><li> <h3><a id="_207"></a>表的读取顺序</h3> </li><li> <h3><a id="_209"></a>哪些索引可以使用</h3> </li><li> <h3><a id="_211"></a>数据读取操作的操作类型</h3> </li><li> <h3><a id="_213"></a>哪些索引被实际使用</h3> </li><li> <h3><a id="_215"></a>表之间的引用</h3> </li><li> <h3><a id="_217"></a><strong>每张表有多少行被物理查询</strong></h3> </li></ul> 
<h4><a id="Explain_220"></a>三、Explain怎么用</h4> 
<pre><code class="prism language-mysql">EXPLAIN sql查询语句
</code></pre> 
<p><code>Explain sql语句</code> 返回对sql语句的分析情况。</p> 
<p>执行计划包含的信息（关键的）：</p> 
<ol><li> <p>id</p> 
  <ul><li>select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</li><li>三种id情况： 
    <ul><li>id号相同：执行顺序由上到下（所显示分析情况表）</li><li>id不相同：如果是子查询，id的序号会递增，id越大优先级越高，越先被执行；</li><li>id列中id既有相同又有不同时：先按id不同，再按id相同进行优先级划分</li></ul> </li><li>关注点：<strong>id号每个号码，表示一趟独立的查询，一个sql的查询趟数越少越好。（相同号码代表一趟查询）</strong></li></ul> </li><li> <p>type</p> <p>显示查询使用了何种类型。</p> 
  <ul><li> <p>从最好到最差：</p> <p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p> 
    <ul><li>all：全表扫描、效率极低（当type字段中出现此关键词，就可对其进行索引创建）</li><li>index：覆盖索引，出现index 时sql使用了索引但是没有通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组；（需要进行优化）</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询语句，这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一个点，不会涉及到扫描全部索引</li></ul> </li></ul> </li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f82778547768c6935f2d2094ee48d3ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UnixBench性能测试分析：Hygon C86 7280</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c6a80265defd81ad93b35d708f455c0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python写post请求</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>