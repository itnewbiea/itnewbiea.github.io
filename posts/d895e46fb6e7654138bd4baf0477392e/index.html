<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>个推解读Android13新特性，发布《Android13适配指南》 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="个推解读Android13新特性，发布《Android13适配指南》" />
<meta property="og:description" content="8月16日，谷歌宣布Android13新系统的源代码已经上传到Android开源项目（AOSP）中，Android13正式发布。自从2022年2月Android13第一个预览版上线以来，历经7个月的测试和优化，正式版本的Android13终于来了！Android13仍然聚焦个人隐私保护和安全，并提供了万物互联时代下大小屏适配、电池利用率优化等相关的技术开发能力。
感兴趣的开发者可以登录官网下载源码测试学习：https://developer.android.google.cn/about/versions/13
个推服务开发者多年，一直密切关注和跟进行业发展趋势。Android13正式版发布后，我们使用模拟器进行了研究和适配测试。本文将从权限变更、系统优化、功能更新等方面来谈谈Android13新特性，以帮助开发者快速上手完成Android新系统的适配。
权限变更 一、通知权限 通知栏消息一直是App和用户沟通的有效渠道。在Android13之前，App只需要使用NotificationManager即可向终端用户推送通知栏消息。Android13则引入了新的运行时通知权限：POST_NOTIFICATIONS。对此，App开发者需要予以重点关注。
个推对该权限进行了测试，总结如下：
1. 首先看TargetSdk&lt;33的情况。
如下图，当App使用通知栏功能时，系统将自动弹出授权弹窗：
用户点击“允许”，App可正常给用户推送消息：
2. 再看TargetSdk == 33的情况。
开发者需要在AndroidManifest.xml中声明POST_NOTIFICATIONS权限，还需要在使用通知栏推送功能时在代码中申请运行时权限：
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:tools=&#34;http://schemas.android.com/tools&#34; package=&#34;com.gt.demo.mubai.push&#34;&gt; &lt;uses-permission android:name=&#34;android.permission.POST_NOTIFICATIONS&#34;/&gt; &lt;/manifest&gt; requestPermissions(new String[]{“android.permission.POST_NOTIFICATIONS”})复制 以上是用户点击“允许”App推送的情况。当然，用户也有可能点击“不允许”。值得注意的是，一旦被用户拒绝授权，下次系统将不会再出现权限申请的弹窗。
如果App仍然要推送重要消息（比如重大版本更新）给用户，则需要引导用户前往设置界面打开通知权限。代码如下：
private void jumpNotificationSetting() { final ApplicationInfo applicationInfo = getApplicationInfo(); try { Intent intent = new Intent(); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(&#34;android.settings.APP_NOTIFICATION_SETTINGS&#34;); intent.putExtra(&#34;app_package&#34;, applicationInfo.packageName); intent.putExtra(&#34;android.provider.extra.APP_PACKAGE&#34;, applicationInfo.packageName); intent.putExtra(&#34;app_uid&#34;, applicationInfo.uid); startActivity(intent); } catch (Throwable t) { t.printStackTrace(); Intent intent = new Intent(); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setAction(&#34;android.settings.APPLICATION_DETAILS_SETTINGS&#34;); intent.setData(Uri.fromParts(&#34;package&#34;, applicationInfo." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d895e46fb6e7654138bd4baf0477392e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-05T11:08:16+08:00" />
<meta property="article:modified_time" content="2022-09-05T11:08:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">个推解读Android13新特性，发布《Android13适配指南》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>8月16日，谷歌宣布Android13新系统的源代码已经上传到Android开源项目（AOSP）中，Android13正式发布。自从2022年2月Android13第一个预览版上线以来，历经7个月的测试和优化，正式版本的Android13终于来了！Android13仍然聚焦个人隐私保护和安全，并提供了万物互联时代下大小屏适配、电池利用率优化等相关的技术开发能力。</p> 
<p>感兴趣的开发者可以登录官网下载源码测试学习：https://developer.android.google.cn/about/versions/13</p> 
<p>个推服务开发者多年，一直密切关注和跟进行业发展趋势。Android13正式版发布后，我们使用模拟器进行了研究和适配测试。本文将从<strong>权限变更、系统优化、功能更新</strong>等方面来谈谈Android13新特性，以帮助开发者快速上手完成Android新系统的适配。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/c6/yeE1p3Ij_o.png"></p> 
<p> </p> 
<p style="text-align:center;"></p> 
<p> </p> 
<p></p> 
<h2><strong>权限变更</strong></h2> 
<h3><strong>一、通知权限</strong></h3> 
<p>通知栏消息一直是App和用户沟通的有效渠道。在Android13之前，App只需要使用NotificationManager即可向终端用户推送通知栏消息。Android13则引入了新的运行时通知权限：POST_NOTIFICATIONS。对此，App开发者需要予以重点关注。</p> 
<p>个推对该权限进行了测试，总结如下：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/ce/ncaxGQSI_o.png"></p> 
<p><strong>1. 首先看TargetSdk&lt;33的情况。</strong></p> 
<p>如下图，当App使用通知栏功能时，系统将自动弹出授权弹窗：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/73/3a/mkBJRlfm_o.png"></p> 
<p></p> 
<p>用户点击“允许”，App可正常给用户推送消息：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ed/4e/2T2XILQC_o.png"></p> 
<p></p> 
<p><strong>2. 再看TargetSdk == 33的情况。</strong></p> 
<p>开发者需要在AndroidManifest.xml中声明POST_NOTIFICATIONS权限，还需要在使用通知栏推送功能时在代码中申请运行时权限：</p> 
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="com.gt.demo.mubai.push"&gt;
    &lt;uses-permission android:name="android.permission.POST_NOTIFICATIONS"/&gt;
&lt;/manifest&gt;
requestPermissions(new String[]{“android.permission.POST_NOTIFICATIONS”})复制</code></pre> 
<p></p> 
<p></p> 
<p>以上是用户点击“允许”App推送的情况。当然，用户也有可能点击“不允许”。值得注意的是，<strong>一旦被用户拒绝授权，下次系统将不会再出现权限申请的弹窗。</strong></p> 
<p>如果App仍然要推送重要消息（比如重大版本更新）给用户，则需要引导用户前往设置界面打开通知权限。代码如下：</p> 
<pre><code>private void jumpNotificationSetting() {
    final ApplicationInfo applicationInfo = getApplicationInfo();
 
    try {
        Intent intent = new Intent();
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS");
        intent.putExtra("app_package", applicationInfo.packageName);
        intent.putExtra("android.provider.extra.APP_PACKAGE", applicationInfo.packageName);
        intent.putExtra("app_uid", applicationInfo.uid);
        startActivity(intent);
    } catch (Throwable t) {
        t.printStackTrace();
        Intent intent = new Intent();
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS");
        intent.setData(Uri.fromParts("package", applicationInfo.packageName, null));
        startActivity(intent);
    }
}复制</code></pre> 
<p></p> 
<p><strong>★温馨提示：</strong></p> 
<p>如果App要确认用户是否已启用通知，可以调用NotificationManager.areNotificationsEnabled()进行判断。</p> 
<p></p> 
<p>另外，除了“允许”和“不允许”两种选择外，用户还可以<strong>划走权限申请对话框（User swipes away from dialog）</strong>，即用户未选择授权（也未选择不授权）。那么下次App进行通知栏消息推送时，系统将再次弹出用户授权弹窗。</p> 
<p></p> 
<p><strong>★个推说：</strong></p> 
<p>Android13的通知权限变更将使终端用户的体验得到极大改善。用户能够自主选择是否接受App推送的通知栏消息，减少被无效信息频繁打扰的情况。</p> 
<p>个推以消息推送服务起家，也一直倡导绿色推送，强调在合适的时间、合适的地点、合适的场景把合适的内容推送给合适的人群，给终端用户更好的体验。</p> 
<p></p> 
<h3><strong>二、WiFi权限变更</strong></h3> 
<p>Android13对WiFi权限的变更也是一大重点。在万物互联的当下，不同的智能家居/智能穿戴设备多是通过WiFi互通互联，因此这些类型的App开发者更要着重关注该部分内容。</p> 
<p>在以往版本的Android系统下，如果App要使用WiFi相关功能，需要申请 ACCESS_FINE_LOCATION，即位置权限，如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/c4/JJeMrgYM_o.png"></p> 
<p> ▲图片来源于Android13官网</p> 
<p></p> 
<p>为了避免App过度索权，更好地保护终端用户隐私，<strong>Android13将WiFi权限从位置权限中分离了出来</strong>，引入了新的运行时权限：NEARBY_WIFI_DEVICES。</p> 
<p>如果App仅需要使用WiFi相关的API，并不需要使用getScanResults()、startScan()等与位置相关的API，那么建议App开发者切换到新的NEARBY_WIFI_DEVICES权限。</p> 
<p></p> 
<p><strong>新的WiFi权限运行机制：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/80/8a/RAScpAFK_o.png"></p> 
<p> ▲图片来源于Android13官网</p> 
<p></p> 
<p><strong>权限使用和适配：</strong></p> 
<p>开发者需要注意的是，如果你的应用（targetSdk == 33）<strong>已经声明不会根据 WiFi信息推导设备的物理位置信息</strong>，那就不再需要声明 ACCESS_FINE_LOCATION 权限。</p> 
<p>另外，如果应用<strong>在Android13上只使用WiFi API而不使用位置信息</strong>，那开发者可以在AndroidManifest.xml中增加NEARBY_WIFI_DEVICES权限，并将usesPermissionFlags属性设为neverForLocation，给ACCESS_FINE_LOCATION权限增加maxSdkVersion="32"的限制，代码如下：</p> 
<pre><code>&lt;manifest ...&gt;
    &lt;uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES"       
                     android:usesPermissionFlags="neverForLocation"/&gt;
  
    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"
                     android:maxSdkVersion="32" /&gt;
&lt;/manifest&gt;复制</code></pre> 
<p></p> 
<h3> 三、<strong>更细分的媒体权限</strong></h3> 
<p>除了通知权限和WiFi权限的更新外，Android13对本地数据访问权限也做了进一步细化。</p> 
<p>Android13将READ_EXTERNAL_STORAGE和 WRITE_EXTERNAL_STORAGE权限细分为：READ_MEDIA_IMAGES、 READ_MEDIA_VIDEO和 READ_MEDIA_AUDIO，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3c/18/Yux7qIAQ_o.png"></p> 
<p>▲图片来源于Android13官网</p> 
<p></p> 
<p>个推使用android.permission.READ.MEDIA_IMAGES，对新权限进行了测试：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/be/b8/zaB7Fixi_o.png"></p> 
<p></p> 
<p>我们发现，单独请求READ_MEDIA_IMAGES、单独请求 READ_MEDIA_VIDEO和同时请求READ_MEDIA_IMAGES&amp; READ_MEDIA_VIDEO，系统均将<strong>只显示一个授权弹窗</strong>。</p> 
<p>另外，<strong>如果App（targetSdk == 33）已经申请了读的权限，那App同时也就有了写的权限</strong>，无需再额外声明 WRITE_EXTERNAL_STORAGE权限，代码如下：</p> 
<pre><code>&lt;manifest ...&gt;
    &lt;uses-permission android:name="android.permission.READ_MEDIA_IMAGES" /&gt;
    &lt;uses-permission android:name="android.permission.READ_MEDIA_AUDIO" /&gt;
    &lt;uses-permission android:name="android.permission.READ_MEDIA_VIDEO" /&gt;
  
    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
                       android:maxSdkVersion="32" /&gt;
&lt;/manifest&gt;复制</code></pre> 
<p></p> 
<h3>四、<strong>精确的闹钟权限</strong></h3> 
<p>为了节省系统资源，Android12引入了SCHEDULE_EXACT_ALARM权限进行“闹钟和提醒”功能的授权管理。Android13则又引入了新的闹钟权限USE_EXACT_ALARM。</p> 
<p>和Android12的SCHEDULE_EXACT_ALARM权限不同，如果App已经申请使用了USE_EXACT_ALARM新权限，那么用户是不能在设置页面里关闭授权的。</p> 
<p>对于日程管理、时间管理等类型的App来讲，Android13引入的USE_EXACT_ALARM权限能够带来一定便利。相比Android12的SCHEDULE_EXACT_ALARM权限，使用新权限的应用将不再需要频繁打扰用户进行授权，能够更高效地为用户提供闹钟、日程提醒等服务。</p> 
<p></p> 
<p>不过，为了防止新权限被滥用，GooglePlay设置了严格的上架审核机制。开发者要注意，一旦使用了USE_EXACT_ALARM权限，App在上架GooglePlay时将会被平台严格审查。<strong>除非App属于闹钟、计时器、日历等类型的应用或者在已被列入到应用市场的白名单里，否则GooglePlay将不会允许使用该权限的应用上架。</strong></p> 
<p></p> 
<p><strong>★个推说：</strong></p> 
<p>随着我国对App用户个人权益保护力度的不断加大，相信后续国内的手机厂商和应用市场也将跟进建立相应的审查机制，增强对用户权益的保护。建议App开发者持续关注相关动态，及时做好适配工作。</p> 
<p></p> 
<h3>五、<strong>后台的传感器权限</strong></h3> 
<p>如今生物信息安全也是大众关注的焦点。为了更好地保护终端用户的个人生物信息，Android13增加了新的后台传感器权限。</p> 
<p>App在后台运行时，如果需要获取心率、体温、血氧饱和度等传感器信息，将不仅需要向用户申请现有的BODY_SENSORS权限，还必须声明新的BODY_SENSORS_BACKGROUND权限。</p> 
<p>综上可以看到，Android13对个人隐私保护的重视和加强。除了权限变更方面，Android13还进行了系统优化、组件更新，以进一步提升系统的安全性和友好性。</p> 
<p></p> 
<h2><strong>系统优化</strong></h2> 
<h3><strong>一、更安全的系统组件</strong></h3> 
<h4><strong>IntentFilter</strong></h4> 
<p>在之前版本的Android系统中，开发者只需将android:exported设为true就可以跨应用显式启动Activity和Service，即使intent-filter中的action或者type不匹配，也能够启动。</p> 
<p>为避免上述漏洞，Android 13增强了intent-filter的匹配过滤逻辑。<strong>在接收方的targetSdk == 33的情况下，如果intent-filter匹配命中，无论发送方的targetSdk版本如何，intent都将生效。</strong></p> 
<p></p> 
<p><strong>★温馨提示：</strong></p> 
<p>以下几种情况不需要遵循intent-filter的匹配过滤逻辑：</p> 
<ul><li> <p>组件没有声明</p> </li><li> <p>同一个App里的intent</p> </li><li> <p>系统或Root进程发出的intent</p> </li></ul> 
<p></p> 
<h4><strong>BroadcastReceiver</strong></h4> 
<p>以往的Android系统下，应用动态注册的BroadcastReceiver广播接收器会接收到任何应用发送的广播（除非该接收器使用了应用签名权限保护），这会使动态注册的广播接收器存在安全风险。</p> 
<p></p> 
<p>Android13要求，<strong>应用动态注册的广播接收器必须以显著的方式指出是否允许其他应用访问</strong>，即其他应用是否可以向其发送广播。否则，在动态注册时系统将抛出安全异常（SecurityException）。</p> 
<p>目前该增强措施并非默认生效，开发者需启用 DYNAMIC_RECEIVER_EXPLICIT_EXPORT_REQUIRED兼容性框架，并在动态注册广播时指定是否接受其他应用的广播：</p> 
<pre><code>context.registerReceiver(receiver, intentFilter, RECEIVER_EXPORTED)
context.registerReceiver(receiver, intentFilter, RECEIVER_NOT_EXPORTED)复制</code></pre> 
<p></p> 
<p><strong>★温馨提示：</strong></p> 
<p>系统广播不受RECEIVER_NOT_EXPORTED影响。</p> 
<p></p> 
<h3><strong>二、前台服务(FGS)任务管理器</strong></h3> 
<p>Android13还新增了前台服务（FGS）任务管理器功能。</p> 
<p>如下图，用户可以在下拉的通知栏中直接关闭前台服务和应用程序：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/38/62/Vy3DvkJd_o.png"></p> 
<p> </p> 
<p></p> 
<p>此外，如果系统检测到应用长时间运行某项前台服务<strong>（在24小时的时间段内至少运行20小时）</strong>，便会向用户发送提醒通知，通知内容如下：</p> 
<p><em>APP is running in the background for a long time. Tap to review.</em></p> 
<p></p> 
<p>值得注意的是，满足以下任一条件的情况下，系统均将不会显示该通知：</p> 
<ul><li> <p>已经发送过前台服务相关的通知，也就是说，用户未关闭之前的提醒通知</p> </li><li> <p>前台服务的类型为 FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK 或 FOREGROUND_SERVICE_TYPE_LOCATION</p> </li></ul> 
<p></p> 
<p><strong>★温馨提示：</strong></p> 
<p>如果系统针对某应用已经显示过此通知，那至少在30天后系统才会再次显示该通知。另外，系统级应用、安全应用（比如具有android.app.role.EMERGENCY 角色的应用）等运行的前台服务，将不会显示在FGS任务管理器中。</p> 
<p></p> 
<h3>三、<strong>通知权限</strong></h3> 
<p>Android9引入了<strong>应用待机存储分区功能</strong>，根据应用的使用时间和频率，将应用动态分配到五个不同优先级的存储分区，然后对不同存储分区的应用施加不同级别的应用资源限制。</p> 
<p></p> 
<p>如下，<strong>存储分区按照优先级从高到低排序，优先级越低对该分区内的App限制越多</strong>：</p> 
<ul><li> <p>活跃：应用目前正在使用中，或者最近刚刚使用过。</p> </li><li> <p>工作集：应用会定期使用。</p> </li><li> <p>常用：应用会经常使用，但不会每天使用。</p> </li><li> <p>极少使用：应用不经常使用。</p> </li><li> <p>受限：应用会消耗大量的系统资源，或表现出不良行为（Android11引入）。</p> </li></ul> 
<p></p> 
<p>其中“受限”状态的应用，将受到以下限制：</p> 
<ul><li> <p>无法启动前台服务。</p> </li><li> <p>现有的前台服务会从前台移除。</p> </li><li> <p>不会触发闹钟。</p> </li><li> <p>不会执行Jobs。</p> </li></ul> 
<p></p> 
<p>在Android9应用待机存储分区功能的基础上，Android13对电池资源策略进行了优化，以延长设备的电池续航时间，提升终端用户的体验。</p> 
<p></p> 
<p>首先，Android13新增了以下规则，<strong>符合相应规则的应用将进入到“受限”存储分区</strong>（设备处于关闭状态的时间不会计入互动限制）：</p> 
<ul><li> <p>用户已经8天没有与应用互动。</p> </li><li> <p>应用在1天内调用过多的广播或者绑定服务。</p> </li><li> <p>应用在1天内消耗了大量的电池电量，阈值取决于设备。</p> </li></ul> 
<p>其次，Android13还对“受限”存储分区的应用增加了限制措施：</p> 
<ul><li> <p>应用将不收受到BOOT_COMPLETED、LOCKED_BOOT_COMPLETED广播</p> </li></ul> 
<p></p> 
<h3>四、<strong>对non-SDK接口限制的更新</strong></h3> 
<p>Android 13对一些non-SDK接口进行了限制（并针对部分限制提供了替代方案）。开发者需要明确App在升级时是否使用了受限的non-SDK接口。</p> 
<p>Android13中受限的non-SDK接口参考：</p> 
<pre><code>Landroid/app/Activity;-&gt;setDisablePreviewScreenshots(Z)V # Use setRecentsScreenshotEnabled() instead.
Landroid/os/PowerManager;-&gt;isLightDeviceIdleMode()Z # Use isDeviceLightIdleMode() instead.
Landroid/os/Process;-&gt;setArgV0(Ljava/lang/String;)V # In general, do not try to change the process name. If you must change the process name (for instance, for debugging), you can use pthread_setname_np() instead, though be aware that doing this might confuse the system.
Landroid/view/accessibility/AccessibilityInteractionClient;-&gt;clearCache(I)V # Use android.accessibilityservice.AccessibilityService#clearCache() instead.复制</code></pre> 
<p></p> 
<h2><strong>功能更新</strong></h2> 
<p>用户体验的提升也一直是Android系统更新的重点。Android13主要针对剪切板、大小屏适配、UI展示等进行了功能更新。</p> 
<p></p> 
<h3>一、<strong>剪切板</strong></h3> 
<p>首先来看剪贴板。相信大家都使用过剪贴板，它能够快速复制页面上的内容，方便我们进行内容编辑和修改。</p> 
<p></p> 
<p>但是一直以来，剪切板功能存在这样一个隐患，即剪切板复制的内容中可能存在敏感信息。为了更好地保障剪切板中的隐私内容（比如手机号码、邮箱、账号密码等）不被泄露，Android13对剪切板功能进行了更新。</p> 
<p></p> 
<p>如下图，Android13剪切板功能的使用分2步：</p> 
<ul><li> <p>确认内容已成功复制。</p> </li><li> <p><strong>提供所复制内容的预览。</strong></p> </li></ul> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/a4/e8/SLD7sgLY_o.gif"></strong></p> 
<p> </p> 
<p></p> 
<p></p> 
<p>此外，Android13还提供了<strong>脱敏功能</strong><strong>，使用户能够对剪切板中的敏感信息进行隐藏</strong>，实现了便利性和安全性兼得。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/67/98/yEVQz5SD_o.png"></p> 
<p></p> 
<h3><strong>二、</strong><strong>更好地支持平板和大屏幕</strong></h3> 
<p>平板电脑、车载大屏、智能电视屏等的广泛应用，使用户的终端场景越来越多样化。如何给不同终端的用户始终美观和流畅的体验？Android13对此提供了更好的支持，对大屏上的系统UI以及分屏展示等进行了更新。</p> 
<p>如下图，在大屏幕上，<strong>Android13支持不同的功能模块同屏展示</strong>，使得大屏幕的优势能够充分被利用。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2a/11/cVUHGwbJ_o.png"></p> 
<p> </p> 
<p></p> 
<p>▲Android13系统下，用户可以将“快速设置”版块和“通知栏”版块置于同屏当中。</p> 
<p></p> 
<h3><strong>三、Jetpack WindowManager</strong></h3> 
<p></p> 
<p>另外，<strong>Android13还支持用户在大屏幕中一次显示多个Activity</strong>，以充分利用大屏的显示空间。</p> 
<p>开发者可通过创建XML配置文件或进行Jetpack WindowManager API调用来确定App实现多个Activity同屏显示（比如并排或堆叠）的具体方式。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ec/1c/ZgbnoOX4_o.jpg"></p> 
<p></p> 
<p>▲比如，以分割任务窗口（splite task window）的形式实现单个屏幕内展示两个Activity。</p> 
<p></p> 
<h3><strong>四、更好的兼容性支持</strong></h3> 
<p>对于尚未适配大屏幕的App，Android13也提供了更加友好和稳定的兼容支持，让这些App在默认情况下也能有舒适美观的UI展示，不会影响到终端用户的体验，如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/17/cb/fDppAZuM_o.png"></p> 
<p> </p> 
<p></p> 
<p><strong>▲图片来源于Android13官网</strong></p> 
<p></p> 
<p><strong>总结：</strong></p> 
<p>通过近两年的Android系统更新可以看到，Google不再对安卓系统进行大刀阔斧的改动，而是在用户体验、隐私保护、系统安全、组件优化等方面下足了功夫。</p> 
<p>更多Android13的更新要点，开发者可进入Android13官网做进一步了解：https://developer.android.google.cn/about/versions/13</p> 
<p>如果您还想就新系统适配以及安卓开发等内容进行更深入的交流，欢迎添加<strong>@个推技术支持</strong>，和我们联系。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/00/de/teUmeQp0_o.png"></p> 
<p></p> 
<p>后续，个推还将持续关注安卓系统和行业发展动态，和开发者们一起交流移动开发技术，共建移动互联网新生态。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/326005ea23b8dd08c6b42923bcc32ab9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringCloud Feign 远程调用（史上最详细讲解）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/985929ce20c1476517bc2bcb735946d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LaTeX 2022 安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>