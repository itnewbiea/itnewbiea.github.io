<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>安卓开发软件培训！腾讯3轮面试都问了Android事件分发，面试必问 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="安卓开发软件培训！腾讯3轮面试都问了Android事件分发，面试必问" />
<meta property="og:description" content="前言 相信前几天在朋友圈晒无聊的小伙伴们，也陆续结束了假期。很多公司为了员工的健康考虑，启动了远程办公模式。
床在桌边，饭在桌上，家里一切都那么安逸，专心工作真的是一件难事。远程工作最大的敌人就是：你的自制力。战胜自己，以后你一定是做成大事的人。
除了好好工作，远程办公还有一个好处是时间比较自由，抓紧一些自由的时间赶紧充电学习。越是空闲时间，越是你追赶别人的绝佳机会。
企业开始上班，就意味着大批量的招聘需求正在路上。所以利用好这段时间，开工后就是你进入大厂的最佳时机。
拉勾网通过与近百家知名企业的深入沟通，结合拉勾 50w&#43; Java 岗位需求和国内外一线实战讲师，历时 15 个月，对标阿里 P7 技术要求打磨而成**《Java工程师高薪训练营》**是你在这个假期，非常值得学习的内容。
二、显示系统基础知识 在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：
2.1 基础概念 屏幕刷新频率 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。刷新频率取决于硬件的固定参数（不会变的）。
逐行扫描 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 / 60 ≈ 16ms。
帧率 （Frame Rate） 表示 GPU 在一秒内绘制操作的帧数，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。
画面撕裂（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图
2.2 双缓存 2.2.1 画面撕裂 原因 屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU/GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。
简单说就是Display在显示的过程中，buffer内数据被CPU/GPU修改，导致画面撕裂。
2.2.2 双缓存 那咋解决画面撕裂呢？ 答案是使用 双缓存。
由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。
双缓存，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 Back Buffer，而显示器使用 Frame Buffer，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1872d664aafef40fa5d4642cfa8fc0a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-26T16:42:56+08:00" />
<meta property="article:modified_time" content="2021-02-26T16:42:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">安卓开发软件培训！腾讯3轮面试都问了Android事件分发，面试必问</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>前言</h4> 
<p>相信前几天在朋友圈晒无聊的小伙伴们，也陆续结束了假期。很多公司为了员工的健康考虑，启动了远程办公模式。</p> 
<p>床在桌边，饭在桌上，家里一切都那么安逸，专心工作真的是一件难事。远程工作最大的敌人就是：你的自制力。战胜自己，以后你一定是做成大事的人。</p> 
<p>除了好好工作，远程办公还有一个好处是时间比较自由，抓紧一些自由的时间赶紧充电学习。越是空闲时间，越是你追赶别人的绝佳机会。</p> 
<p>企业开始上班，就意味着大批量的招聘需求正在路上。所以利用好这段时间，开工后就是你进入大厂的最佳时机。</p> 
<p>拉勾网通过与近百家知名企业的深入沟通，结合拉勾 50w+ Java 岗位需求和国内外一线实战讲师，历时 15 个月，对标阿里 P7 技术要求打磨而成**《Java工程师高薪训练营》**是你在这个假期，非常值得学习的内容。</p> 
<h2><a id="_14"></a>二、显示系统基础知识</h2> 
<p>在一个典型的显示系统中，一般包括CPU、GPU、Display三个部分， CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把buffer里的数据呈现到屏幕上。如下图：</p> 
<p><img src="https://images2.imgbox.com/9d/db/8oT4jvKh_o.png" alt=""></p> 
<h3><a id="21__21"></a>2.1 基础概念</h3> 
<ul><li> <p><strong>屏幕刷新频率</strong> 一秒内屏幕刷新的次数（一秒内显示了多少帧的图像），单位 Hz（赫兹），如常见的 60 Hz。<strong>刷新频率取决于硬件的固定参数</strong>（不会变的）。</p> </li><li> <p><strong>逐行扫描</strong> 显示器并不是一次性将画面显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点，不过这一过程快到人眼无法察觉到变化。以 60 Hz 刷新率的屏幕为例，这一过程即 1000 / 60 ≈ 16ms。</p> </li><li> <p><strong>帧率</strong> （Frame Rate） 表示 <strong>GPU 在一秒内绘制操作的帧数</strong>，单位 fps。例如在电影界采用 24 帧的速度足够使画面运行的非常流畅。而 Android 系统则采用更加流程的 60 fps，即每秒钟GPU最多绘制 60 帧画面。帧率是动态变化的，例如当画面静止时，GPU 是没有绘制操作的，屏幕刷新的还是buffer中的数据，即GPU最后操作的帧数据。</p> </li><li> <p><strong>画面撕裂</strong>（tearing） 一个屏幕内的数据来自2个不同的帧，画面会出现撕裂感，如下图</p> </li></ul> 
<p><img src="https://images2.imgbox.com/62/a6/LJf8b4BL_o.png" alt="明显看出画面错位的位置，这就是画面撕裂。"></p> 
<h3><a id="22__34"></a>2.2 双缓存</h3> 
<h4><a id="221___36"></a>2.2.1 画面撕裂 原因</h4> 
<p>屏幕刷新频是固定的，比如每16.6ms从buffer取数据显示完一帧，理想情况下帧率和刷新频率保持一致，即每绘制完成一帧，显示器显示一帧。但是CPU/GPU写数据是不可控的，所以会出现buffer里有些数据根本没显示出来就被重写了，即buffer里的数据可能是来自不同的帧的， 当屏幕刷新时，此时它并不知道buffer的状态，因此从buffer抓取的帧并不是完整的一帧画面，即出现画面撕裂。</p> 
<p>简单说就是Display在显示的过程中，buffer内数据被CPU/GPU修改，导致画面撕裂。</p> 
<h4><a id="222__42"></a>2.2.2 双缓存</h4> 
<p>那咋解决画面撕裂呢？ 答案是使用 双缓存。</p> 
<p>由于图像绘制和屏幕读取 使用的是同个buffer，所以屏幕刷新时可能读取到的是不完整的一帧画面。</p> 
<p><strong>双缓存</strong>，让绘制和显示器拥有各自的buffer：GPU 始终将完成的一帧图像数据写入到 <strong>Back Buffer</strong>，而显示器使用 <strong>Frame Buffer</strong>，当屏幕刷新时，Frame Buffer 并不会发生变化，当Back buffer准备就绪后，它们才进行交换。如下图：</p> 
<p><img src="https://images2.imgbox.com/87/7c/Gr9LZM0z_o.png" alt=""></p> 
<h4><a id="223_VSync_53"></a>2.2.3 VSync</h4> 
<p>问题又来了：什么时候进行两个buffer的交换呢？</p> 
<p>假如是 Back buffer准备完成一帧数据以后就进行，那么如果此时屏幕还没有完整显示上一帧内容的话，肯定是会出问题的。看来只能是等到屏幕处理完一帧数据后，才可以执行这一操作了。</p> 
<p>当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时有一段时间空隙，称为VerticalBlanking Interval(VBI)。那，这个时间点就是我们进行缓冲区交换的最佳时间。因为此时屏幕没有在刷新，也就避免了交换过程中出现 screen tearing的状况。</p> 
<p><strong>VSync</strong>(垂直同步)是VerticalSynchronization的简写，它利用VBI时期出现的vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。另外，交换是指各自的内存地址，可以认为该操作是瞬间完成。</p> 
<p>所以说V-sync这个概念并不是Google首创的，它在早年的PC机领域就已经出现了。</p> 
<h2><a id="Android_65"></a>三、Android屏幕刷新机制</h2> 
<h3><a id="31_Android41_67"></a>3.1 Android4.1之前的问题</h3> 
<p>具体到Android中，在Android4.1之前，屏幕刷新也遵循 上面介绍的 双缓存+VSync 机制。如下图：</p> 
<p><img src="https://images2.imgbox.com/d0/0e/fgBVZpVQ_o.png" alt=""></p> 
<p>以时间的顺序来看下将会发生的过程：</p> 
<ol><li>Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，且在Display显示下一帧前完成</li><li>因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，缓存进行交换，然后正常显示第1帧</li><li>接着第2帧开始处理，是直到第2个VSync快来前才开始处理的。</li><li>第2个VSync来时，由于第2帧数据还没有准备就绪，缓存没有交换，显示的还是第1帧。这种情况被Android开发组命名为“Jank”，即发生了<strong>丢帧</strong>。</li><li>当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync 进行缓存交换再显示。</li></ol> 
<p>所以总的来说，就是屏幕平白无故地多显示了一次第1帧。</p> 
<p>原因是 第2帧的CPU/GPU计算 没能在VSync信号到来前完成 。</p> 
<p>我们知道，<strong>双缓存的交换 是在Vsyn到来时进行，交换后屏幕会取Frame buffer内的新数据，而实际 此时的Back buffer 就可以供GPU准备下一帧数据了。 如果 Vsyn到来时 CPU/GPU就开始操作的话，是有完整的16.6ms的，这样应该会基本避免jank的出现了</strong>（除非CPU/GPU计算超过了16.6ms）。 那如何让 CPU/GPU计算在 Vsyn到来时进行呢？</p> 
<h3><a id="32_drawing_with_VSync_89"></a>3.2 drawing with VSync</h3> 
<p>为了优化显示性能，Google在Android 4.1系统中对Android Display系统进行了重构，实现了Project Butter（黄油工程）：系统在收到VSync pulse后，将马上开始下一帧的渲染。即<strong>一旦收到VSync通知（16ms触发一次），CPU和GPU 才立刻开始计算然后把数据写入buffer</strong>。如下图：</p> 
<p><img src="https://images2.imgbox.com/23/d6/3X9qpEDJ_o.png" alt=""></p> 
<p>CPU/GPU根据VSYNC信号同步处理数据，可以让CPU/GPU有完整的16ms时间来处理数据，减少了jank。</p> 
<p>一句话总结，<strong>VSync同步使得CPU/GPU充分利用了16.6ms时间，减少jank。</strong></p> 
<p>问题又来了，如果界面比较复杂，CPU/GPU的处理时间较长 超过了16.6ms呢？如下图：</p> 
<p><img src="https://images2.imgbox.com/a0/85/LqfEQepK_o.png" alt=""></p> 
<ol><li>在第二个时间段内，但却因 GPU 还在处理 B 帧，缓存没能交换，导致 A 帧被重复显示。</li><li>而B完成后，又因为缺乏VSync pulse信号，它只能等待下一个signal的来临。于是在这一过程中，有一大段时间是被浪费的。</li><li>当下一个VSync出现时，CPU/GPU马上执行操作（A帧），且缓存交换，相应的显示屏对应的就是B。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li></ol> 
<p><strong>为什么 CPU 不能在第二个 16ms 处理绘制工作呢？</strong></p> 
<p>原因是只有两个 buffer，Back buffer正在被GPU用来处理B帧的数据， Frame buffer的内容用于Display的显示，这样两个buffer都被占用，CPU 则无法准备下一帧的数据。 那么，如果再提供一个buffer，CPU、GPU 和显示设备都能使用各自的buffer工作，互不影响。</p> 
<h3><a id="33__113"></a>3.3 三缓存</h3> 
<p><strong>三缓存</strong>就是在双缓冲机制基础上增加了一个 Graphic Buffer 缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个 Graphic Buffer 所占用的内存。</p> 
<p><img src="https://images2.imgbox.com/19/25/rBYPLQWX_o.png" alt=""></p> 
<ol><li> <p>第一个Jank，是不可避免的。但是在第二个 16ms 时间段，CPU/GPU 使用 <strong>第三个 Buffer</strong> 完成C帧的计算，虽然还是会多显示一次 A 帧，但后续显示就比较顺畅了，有效避免 Jank 的进一步加剧。</p> </li><li> <p>注意在第3段中，A帧的计算已完成，但是在第4个vsync来的时候才显示，如果是双缓冲，那在第三个vynsc就可以显示了。</p> </li></ol> 
<p><strong>三缓冲有效利用了等待vysnc的时间，减少了jank，但是带来了延迟。</strong> 所以，是不是 Buffer 越多越好呢？这个是否定的，Buffer 正常还是两个，当出现 Jank 后三个足以。</p> 
<p>以上就是Android屏幕刷新的原理了。</p> 
<h4><a id="_130"></a>最后</h4> 
<p>针对Android程序员，我这边给大家整理了一些资料，包括不限于高级UI、性能优化、架构师课程、NDK、混合式开发（ReactNative+Weex）微信小程序、Flutter等全方面的Android进阶实践技术；希望能帮助到大家，也节省大家在网上搜索资料的时间来学习，也可以分享动态给身边好友一起学习！</p> 
<ul><li> <p><strong>Android前沿技术大纲</strong></p> <p><img src="https://images2.imgbox.com/32/1f/Ar0MgNxA_o.png" alt=""></p> </li><li> <p><strong>全套体系化高级架构视频</strong></p> <p><img src="https://images2.imgbox.com/64/e5/McTQ1BRt_o.png" alt=""></p> </li></ul> 
<h6><a id="GitHubhttpsgithubcoma120464AndroidP7blobmasterAndroidE5BC80E58F91E4B88DE4BC9AE8BF99E4BA9BEFBC9FE5A682E4BD95E99DA2E8AF95E68BBFE9AB98E896AAEFBC81md_142"></a>资料领取：<strong>点赞+<a href="https://github.com/a120464/Android-P7/blob/master/Android%E5%BC%80%E5%8F%91%E4%B8%8D%E4%BC%9A%E8%BF%99%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E9%9D%A2%E8%AF%95%E6%8B%BF%E9%AB%98%E8%96%AA%EF%BC%81.md">点击GitHub免费获取</a></strong></h6> 
<blockquote> 
 <p><strong>往期Android高级架构资料、源码、笔记、视频。高级UI、性能优化、架构师课程、混合式开发（ReactNative+Weex）全方面的Android进阶实践技术，群内还有技术大牛一起讨论交流解决问题。</strong></p> 
</blockquote> 
<p>E9%AB%98%E8%96%AA%EF%BC%81.md)**</p> 
<blockquote> 
 <p><strong>往期Android高级架构资料、源码、笔记、视频。高级UI、性能优化、架构师课程、混合式开发（ReactNative+Weex）全方面的Android进阶实践技术，群内还有技术大牛一起讨论交流解决问题。</strong></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f4d14521d5de4a264f3e948ad9f0329f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面试官：说说 typeof 与 instanceof 区别?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72a0d20290e5d2f24dd9c82e5b05c1e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言程序设计  设计用函数实现模块化程序设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>