<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;函数的导出与导入 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;函数的导出与导入" />
<meta property="og:description" content="DLL使用
（1）隐式链接到 DLL 的可执行文件在生成时链接到导入库(.lib文件)。
（2）采用显式连接（LoadLibrary和GetProcAddress）时，不需要.lib文件。
函数导出方式
（1）源代码中的 __declspec(dllexport) 关键字 （2）.def 文件中的 EXPORTS 语句 （3）LINK 命令中的 /EXPORT 规范 所有这三种方法可以用在同一个程序中。LINK 在生成包含导出的程序时还创建导入库，除非生成中使用了 .exp 文件。
导出
CppDynamicLinkLibrary.cpp
#include &#34;CppDynamicLinkLibrary.h&#34; #include &lt;strsafe.h&gt; #pragma region DLLMain BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } #pragma endregion #pragma region Global Data // An exported/imported global data using a DEF file // Initialize it to be 1 int g_nVal1 = 1; // An exported/imported global data using __declspec(dllexport/dllimport) // Initialize it to be 2 SYMBOL_DECLSPEC int g_nVal2 = 2; #pragma endregion #pragma region Ordinary Functions // An exported/imported cdecl(default) function using a DEF file int /*__cdecl*/ GetStringLength1(PCWSTR pszString) { return static_cast&lt;int&gt;(wcslen(pszString)); } // An exported/imported stdcall function using __declspec(dllexport/dllimport) SYMBOL_DECLSPEC int __stdcall GetStringLength2(PCWSTR pszString) { return static_cast&lt;int&gt;(wcslen(pszString)); } #pragma endregion #pragma region Callback Function // An exported/imported stdcall function using a DEF file // It requires a callback function as one of the arguments int __stdcall CompareInts(int a, int b, PFN_COMPARE cmpFunc) { // Make the callback to the comparison function // If a is greater than b, return a; // If b is greater than or equal to a, return b." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/99644817c46dc1daf16e70f192aed4ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-10-23T11:13:20+08:00" />
<meta property="article:modified_time" content="2014-10-23T11:13:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;函数的导出与导入</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>DLL使用</p> 
<p>（1）隐式链接到 DLL 的可执行文件在生成时链接到导入库(.lib文件)。</p> 
<p>（2）采用显式连接（LoadLibrary和GetProcAddress）时，不需要.lib文件。</p> 
<p>函数导出方式</p> 
<p>（1）源代码中的 __declspec(dllexport) 关键字 <br> （2）.def 文件中的 EXPORTS 语句 <br> （3）LINK 命令中的 /EXPORT 规范 <br> 所有这三种方法可以用在同一个程序中。LINK 在生成包含导出的程序时还创建导入库，除非生成中使用了 .exp 文件。<br> </p> 
<p><span style="white-space:pre"></span></p> 
<p><span style="white-space:pre"></span>导出</p> 
<p>CppDynamicLinkLibrary.cpp<br> </p> 
<p></p> 
<pre><code class="language-cpp">#include "CppDynamicLinkLibrary.h"
#include &lt;strsafe.h&gt;

#pragma region DLLMain
BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD  ul_reason_for_call,
                      LPVOID lpReserved
                      )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
#pragma endregion


#pragma region Global Data

// An exported/imported global data using a DEF file
// Initialize it to be 1
int g_nVal1 = 1;


// An exported/imported global data using __declspec(dllexport/dllimport)
// Initialize it to be 2
SYMBOL_DECLSPEC int g_nVal2 = 2;

#pragma endregion


#pragma region Ordinary Functions


// An exported/imported cdecl(default) function using a DEF file
int /*__cdecl*/ GetStringLength1(PCWSTR pszString)
{
    return static_cast&lt;int&gt;(wcslen(pszString));
}


// An exported/imported stdcall function using __declspec(dllexport/dllimport)
SYMBOL_DECLSPEC int __stdcall GetStringLength2(PCWSTR pszString)
{
    return static_cast&lt;int&gt;(wcslen(pszString));
}

#pragma endregion


#pragma region Callback Function

// An exported/imported stdcall function using a DEF file
// It requires a callback function as one of the arguments
int __stdcall CompareInts(int a, int b, PFN_COMPARE cmpFunc)
{
	// Make the callback to the comparison function

	// If a is greater than b, return a; 
    // If b is greater than or equal to a, return b.
    return ((*cmpFunc)(a, b) &gt; 0) ? a : b;
}

#pragma endregion


#pragma region Class

// Constructor of the simple C++ class
CSimpleObject::CSimpleObject(void) : m_fField(0.0f)
{
}


// Destructor of the simple C++ class
CSimpleObject::~CSimpleObject(void)
{
}


float CSimpleObject::get_FloatProperty(void)
{
	return this-&gt;m_fField;
}


void CSimpleObject::set_FloatProperty(float newVal)
{
	this-&gt;m_fField = newVal;
}


HRESULT CSimpleObject::ToString(PWSTR pszBuffer, DWORD dwSize)
{
    return StringCchPrintf(pszBuffer, dwSize, L"%.2f", this-&gt;m_fField);
}


int CSimpleObject::GetStringLength(PCWSTR pszString)
{
    return static_cast&lt;int&gt;(wcslen(pszString));
}

#pragma endregion</code></pre> 
<br> 
<br> 
<p></p> 
<p>CppDynamicLinkLibrary.def<br> </p> 
<p></p> 
<pre><code class="language-cpp">LIBRARY   CppDynamicLinkLibrary
EXPORTS
   GetStringLength1     @1
   CompareInts  	@2
   g_nVal1		DATA</code></pre> 
<br> 
<span style="white-space:pre"></span>导入 
<p></p> 
<p>CppLoadLibrary.cpp<br> </p> 
<p></p> 
<pre><code class="language-cpp">#pragma region Includes
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#pragma endregion


// Function pointer types for functions exported from the DLL module

typedef int     (_cdecl* LPFNGETSTRINGLENGTH1)      (PCWSTR);

// CALLBACK, aka __stdcall, can only be used for stdcall methods. If it is
// used for __cdecl methods, this error will be thrown in runtime: The value 
// of ESP was not properly saved across a function call. This is usually a 
// result of calling a function declared with one calling convention with a
// function pointer declared with a different calling convention.
typedef int     (CALLBACK* LPFNGETSTRINGLENGTH2)    (PCWSTR);

// Type-definition of the 'PFN_COMPARE' callback function, and the CompareInts 
// function that requires the callback as one of the arguments.
typedef int     (CALLBACK* PFN_COMPARE)             (int, int);
typedef int     (CALLBACK* LPFNMAX)                 (int, int, PFN_COMPARE);


//
//   FUNCTION: IsModuleLoaded(PCWSTR)
//
//   PURPOSE: Check whether or not the specified module is loaded in the 
//   current process.
//
//   PARAMETERS:
//   * pszModuleName - the module name
//
//   RETURN VALUE: The function returns TRUE if the specified module is 
//   loaded in the current process. If the module is not loaded, the function 
//   returns FALSE.
//
BOOL IsModuleLoaded(PCWSTR pszModuleName) 
{
	// Get the module in the process according to the module name.
	HMODULE hMod = GetModuleHandle(pszModuleName);
    return (hMod != NULL);
}


//
//   FUNCTION: Max(int, int)
//
//   PURPOSE: This is the callback function for the method Max exported from 
//   CppDynamicLinkLibrary.dll
//
//   PARAMETERS:
//   * a - the first integer
//   * b - the second integer
//
//   RETURN VALUE: The function returns a positive number if a &gt; b, returns 0 
//   if a equals b, and returns a negative number if a &lt; b.
//
int CALLBACK Max(int a, int b)
{
	return (a - b);
}


int wmain(int argc, wchar_t *argv[])
{
    BOOL fLoaded = FALSE;
    HINSTANCE hModule = NULL;

	// The name of the module to be dynamically-loaded.
	PCWSTR pszModuleName = L"CppDynamicLinkLibrary";

	// Check whether or not the module is loaded.
	fLoaded = IsModuleLoaded(pszModuleName);
    wprintf(L"Module \"%s\" is %sloaded\n", pszModuleName, fLoaded ? L"" : L"not ");

	// Dynamically load the library.
    wprintf(L"Load the library\n");
	hModule = LoadLibrary(pszModuleName);
	if (hModule == NULL)
	{
        wprintf(L"LoadLibrary failed w/err 0x%08lx\n", GetLastError());
        goto Cleanup;
    }

    // Check whether or not the module is loaded.
	fLoaded = IsModuleLoaded(pszModuleName);
    wprintf(L"Module \"%s\" is %sloaded\n", pszModuleName, fLoaded ? L"" : L"not ");

    // 
    // Access the global data exported from a module.
    // 

    // Dynamically-loaded DLL does not allow you to access the global data 
    // exported from the DLL.

    // 
    // Call the functions exported from a module.
    // 

    PCWSTR pszString = L"HelloWorld";
    int nLength;

    // Call int /*__cdecl*/ GetStringLength1(PWSTR pszString);
    LPFNGETSTRINGLENGTH1 lpfnGetStringLength1 = (LPFNGETSTRINGLENGTH1)GetProcAddress(hModule, "GetStringLength1");
    if (lpfnGetStringLength1 == NULL)
    {
        wprintf(L"GetStringLength1 cannot be found (Error: 0x%08lx)\n", 
            GetLastError());
        goto Cleanup;
    }
	nLength = lpfnGetStringLength1(pszString);
    wprintf(L"Function: GetStringLength1(\"%s\") =&gt; %d\n", pszString, nLength);

    // Call int __stdcall GetStringLength2(PWSTR pszString);
    LPFNGETSTRINGLENGTH2 lpfnGetStringLength2 = (LPFNGETSTRINGLENGTH2)GetProcAddress(hModule, "_GetStringLength2@4");
    if (lpfnGetStringLength2 == NULL)
    {
        wprintf(L"GetStringLength2 cannot be found (Error: 0x%08lx)\n", 
            GetLastError());
        goto Cleanup;
    }
    nLength = lpfnGetStringLength2(pszString);
    wprintf(L"Function: GetStringLength2(\"%s\") =&gt; %d\n", pszString, nLength);

    //
    // Call the callback functions exported from a module.
    //

    // Call int __stdcall CompareInts(int a, int b, PFN_COMPARE cmpFunc);
    LPFNMAX lpfnMax = (LPFNMAX)GetProcAddress(hModule, "CompareInts");
    if (lpfnMax == NULL)
    {
        wprintf(L"CompareInts cannot be found (Error: 0x%08lx)\n", GetLastError());
        goto Cleanup;
    }
    int max = lpfnMax(2, 3, &amp;Max);
    wprintf(L"Function: CompareInts(2, 3,Max) =&gt; %d\n", max);

    //
    // Use the class exported from a module.
    //

    // Dynamically-loaded DLL does not allow you to use the class exported 
    // from the DLL.

Cleanup:

    if (hModule)
    {
        // Attempt to free and unload the library.
        wprintf(L"Unload the dynamically-loaded DLL\n");
        if (!FreeLibrary(hModule))
        {
            wprintf(L"FreeLibrary failed w/err 0x%08lx\n", GetLastError());
        }
    }
    
    // Check whether or not the module is loaded.
	fLoaded = IsModuleLoaded(pszModuleName);
    wprintf(L"Module \"%s\" is %sloaded\n", pszModuleName, fLoaded ? L"" : L"not ");

	return 0;
}</code></pre> 
<br> 
<br> 
<p></p> 
<p>示例工程地址:http://download.csdn.net/detail/x356982611/8071757</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1132c88174c746ec3b49c42115f22378/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据源BasicDataSource</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8786b9ae2ac053c64d43b86c4289ce6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用for和while循环求e的值[e=1&#43;1/1!&#43;1/2!&#43;1/3!&#43;1/4!&#43;1/5!&#43;...&#43;1/n!]</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>