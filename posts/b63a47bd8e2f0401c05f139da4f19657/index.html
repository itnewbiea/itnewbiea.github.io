<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OPC读写Kepware（C&#43;&#43;） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OPC读写Kepware（C&#43;&#43;）" />
<meta property="og:description" content="OPC读写Kepware（C&#43;&#43;opc同步读写）
”rw“ 是kepserver6.5的OPF文件，需要kepserver6.5及以上版本才能打开OPF文件，打开后如下图。
将各种接口封装成类…
OpcClient.h
#include &#34;opcda.h&#34; #include &#34;OpcError.h&#34; #include &#34;iostream&#34; #include &#34;opccomn.h&#34; #define LOCALE_ID 0x409 using namespace std; class OpcClient { public: OpcClient(); ~OpcClient(); IOPCServer	*m_IOPCServer; IOPCItemMgt	*m_IOPCItemMgt; IOPCSyncIO	*m_IOPCSyncIO; OPCITEMDEF	m_Items[1]; OPCITEMRESULT	*m_ItemResult; OPCHANDLE	m_GrpSrvHandle; HRESULT	*m_pErrors; bool	OpcClientBusy; int connectToServer(LPWSTR ProgID, LPWSTR GrpID); int addItemtoGrp(LPWSTR szItemID, VARTYPE vt_ItemType); int readShort(LPWSTR OPCServerProgID, LPWSTR groupID,LPWSTR szItemID, VARTYPE vt_ItemType); int writeShort(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, int value); float readFloat(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType); int writeFloat(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, float value); bool readBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType); int writeBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, bool value); int setBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType); int resetBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType); int invertBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType); int Stop(); private: }; OpcClient." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b63a47bd8e2f0401c05f139da4f19657/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-10T11:44:40+08:00" />
<meta property="article:modified_time" content="2022-12-10T11:44:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OPC读写Kepware（C&#43;&#43;）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>OPC读写Kepware（C++opc同步读写）</p> 
<p>”rw“ 是kepserver6.5的OPF文件，需要kepserver6.5及以上版本才能打开OPF文件，打开后如下图。<br> <img src="https://images2.imgbox.com/89/43/CZgwhhIo_o.png" alt="在这里插入图片描述"><br> 将各种接口封装成类…<br> OpcClient.h</p> 
<pre><code>#include "opcda.h"               
#include "OpcError.h"
#include "iostream"
#include  "opccomn.h"
#define LOCALE_ID 0x409
using namespace std;

class OpcClient
{
public:
	OpcClient();
	~OpcClient();
	IOPCServer		*m_IOPCServer;
	IOPCItemMgt		*m_IOPCItemMgt;
	IOPCSyncIO		*m_IOPCSyncIO;
	OPCITEMDEF		m_Items[1];
	OPCITEMRESULT	*m_ItemResult;
	OPCHANDLE		m_GrpSrvHandle;
	HRESULT			*m_pErrors;
	bool			OpcClientBusy;

	int connectToServer(LPWSTR ProgID, LPWSTR GrpID);
	int addItemtoGrp(LPWSTR szItemID, VARTYPE vt_ItemType);
	
	int readShort(LPWSTR OPCServerProgID, LPWSTR groupID,LPWSTR szItemID, VARTYPE vt_ItemType);
	int writeShort(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, int value);
	float readFloat(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType);
	int writeFloat(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, float value);
	bool readBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType);
	int writeBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, bool value);
	int setBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType);
	int resetBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType);
	int invertBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType);
	int Stop();

private:

};
</code></pre> 
<p>OpcClient.cpp</p> 
<pre><code>#include "stdafx.h"
#include "OpcClient.h"
int OpcClient::connectToServer(LPWSTR ProgID, LPWSTR GrpID)
{
	OpcClientBusy = true;
	HRESULT			r1;
	CLSID			clsid;
	LONG			TimeBias = 0;
	FLOAT			PercentDeadband = 0.0;
	DWORD			RevisedUpdateRate;
	//初始化COM库
	m_ItemResult = NULL;
	r1 = CoInitialize(NULL);
	//通过ProgID,查找注册表中的机关CLSID
	r1 = CLSIDFromProgID(ProgID, &amp;clsid);
	if (FAILED(r1))
	{
		CoUninitialize();
		return 1;
	}
	//创建 OPC服务对象，并查询对象的IID_IOPCServer接口
	r1 = CoCreateInstance(clsid, NULL,
		CLSCTX_LOCAL_SERVER, IID_IOPCServer,
		(void**)&amp;m_IOPCServer);
	if (r1 != S_OK)
	{
		m_IOPCServer = NULL;
		CoUninitialize();
		return 2;
	}
	//添加一个Group，并查询IOPCItemMgt接口
	r1 = m_IOPCServer-&gt;AddGroup(GrpID,
		TRUE,
		500,
		1,
		&amp;TimeBias,
		&amp;PercentDeadband,
		LOCALE_ID,
		&amp;m_GrpSrvHandle,
		&amp;RevisedUpdateRate,
		IID_IOPCItemMgt,
		(LPUNKNOWN*)&amp;m_IOPCItemMgt);
	if (r1 == OPC_S_UNSUPPORTEDRATE)
	{
		return 3;
	}
	else if (FAILED(r1))
	{
		m_IOPCServer-&gt;Release();
		m_IOPCServer = NULL;
		CoUninitialize();
		return 4;
	}
	return 0;
}
int OpcClient::addItemtoGrp(LPWSTR szItemID, VARTYPE vt_ItemType)
{
	if (OpcClientBusy == false)
	{
		return 1;
	}
	HRESULT r1;
	//为ADDItem定义item表的参数
	m_Items[0].szAccessPath = L"";
	m_Items[0].szItemID = szItemID;
	m_Items[0].bActive = TRUE;
	m_Items[0].hClient = 1;
	m_Items[0].dwBlobSize = 0;
	m_Items[0].pBlob = NULL;
	m_Items[0].vtRequestedDataType = vt_ItemType;
	r1 = m_IOPCItemMgt-&gt;AddItems(1,
		m_Items,
		&amp;m_ItemResult,
		&amp;m_pErrors);

	if (r1 == S_OK)
	{
		//cout &lt;&lt; "ADDItems()成功！" &lt;&lt; endl;
	}
	if ((r1 != S_OK) &amp;&amp; (r1 != S_FALSE))
	{
		//cout &lt;&lt; "ADDItems失败！！" &lt;&lt; endl;
		m_IOPCItemMgt-&gt;Release();
		m_IOPCItemMgt = NULL;
		m_GrpSrvHandle = NULL;
		m_IOPCServer-&gt;Release();
		m_IOPCServer = NULL;
		CoUninitialize();
		return 1;
	}
	//检测Itemr的可读可写性
	if (m_ItemResult[0].dwAccessRights != (OPC_READABLE + OPC_WRITEABLE))
	{
		return 2;
	}
	else
	{
		//
	}

	//查询group对象的同步接口
	r1 = m_IOPCItemMgt-&gt;QueryInterface(IID_IOPCSyncIO, (void**)&amp;m_IOPCSyncIO);
	if (r1&lt;0)
	{
		CoTaskMemFree(m_ItemResult);
		m_IOPCItemMgt-&gt;Release();
		m_IOPCItemMgt = NULL;
		m_GrpSrvHandle = NULL;
		m_IOPCServer-&gt;Release();
		m_IOPCServer = NULL;
		CoUninitialize();
		return 3;
	}
	return 0;
}
int OpcClient::readShort(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType)
{
	OpcClient::connectToServer(OPCServerProgID, groupID);
	OpcClient::addItemtoGrp(szItemID, vt_ItemType);

	OPCHANDLE		*phServer;
	OPCITEMSTATE	*pItemValue;
	HRESULT			*pErrors;
	HRESULT			r1 = E_FAIL;

	if (m_pErrors[0] != S_OK)
	{
		return 32767;
	}
	//内存分配
	phServer = new OPCHANDLE[1];
	phServer[0] = m_ItemResult[0].hServer;
	r1 = m_IOPCSyncIO-&gt;Read(OPC_DS_DEVICE, 1, phServer, &amp;pItemValue, &amp;pErrors);
	//释放内存
	delete[]phServer;

	if (r1 == S_OK)
	{
		//
	}
	else
	{
		Stop();
		return 32767;
	}
	Stop();
	return pItemValue[0].vDataValue.intVal;
}
int OpcClient::writeShort(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, int value)
{
	OpcClient::connectToServer(OPCServerProgID, groupID);
	OpcClient::addItemtoGrp(szItemID, VT_I2);
	OPCHANDLE *phServer;
	HRESULT *pErrors;
	VARIANT	values[1];
	HRESULT r1;
	LPWSTR	ErrorStr;

	if (m_pErrors[0] != S_OK)
	{
		Stop();
		return 1;
	}
	phServer = new OPCHANDLE[1];
	phServer[0] = m_ItemResult[0].hServer;

	values[0].vt = VT_I2;
	values[0].intVal = value;
	r1 = m_IOPCSyncIO-&gt;Write(1, phServer, values, &amp;pErrors);
	delete[]phServer;
	Stop();
	return 0;
}
float OpcClient::readFloat(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType)
{
	OpcClient::connectToServer(OPCServerProgID, groupID);
	OpcClient::addItemtoGrp(szItemID, vt_ItemType);
	OPCHANDLE		*phServer;
	OPCITEMSTATE	*pItemValue;
	HRESULT			*pErrors;
	HRESULT			r1 = E_FAIL;
	if (m_pErrors[0] != S_OK)
	{
		return 32767;
	}
	//内存分配
	phServer = new OPCHANDLE[1];
	phServer[0] = m_ItemResult[0].hServer;
	r1 = m_IOPCSyncIO-&gt;Read(OPC_DS_DEVICE, 1, phServer, &amp;pItemValue, &amp;pErrors);
	//释放内存
	delete[]phServer;

	if (r1 == S_OK)
	{
		//
	}
	Stop();
	return pItemValue[0].vDataValue.fltVal;
}
int OpcClient::writeFloat(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, float value)
{
	OpcClient::connectToServer(OPCServerProgID, groupID);
	OpcClient::addItemtoGrp(szItemID, VT_R4);
	OPCHANDLE *phServer;
	HRESULT *pErrors;
	VARIANT	values[1];
	HRESULT r1;
	LPWSTR	ErrorStr;

	if (m_pErrors[0] != S_OK)
	{
		return;
	}
	phServer = new OPCHANDLE[1];
	phServer[0] = m_ItemResult[0].hServer;

	//UpdateData(TRUE); 
	values[0].vt = VT_R4;
	values[0].fltVal = value;
	r1 = m_IOPCSyncIO-&gt;Write(1, phServer, values, &amp;pErrors);
	delete[]phServer;
	Stop();
	return 0;
}
bool OpcClient::readBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType)
{
	OpcClient::connectToServer(OPCServerProgID, groupID);
	OpcClient::addItemtoGrp(szItemID, vt_ItemType);
	OPCHANDLE		*phServer;
	OPCITEMSTATE	*pItemValue;
	HRESULT			*pErrors;
	HRESULT			r1 = E_FAIL;
	if (m_pErrors[0] != S_OK)
	{
		return 32767;
	}

	phServer = new OPCHANDLE[1];

	phServer[0] = m_ItemResult[0].hServer;
	r1 = m_IOPCSyncIO-&gt;Read(OPC_DS_DEVICE, 1, phServer, &amp;pItemValue, &amp;pErrors);
	//释放内存
	delete[]phServer;
	if (r1 == S_OK)
	{
		//
	}
	Stop();
	if (pItemValue[0].vDataValue.boolVal==-1)
	{
		return true;
	}
	else
	{
		return false;
	}
}
int OpcClient::writeBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, bool value)
{
	OpcClient::connectToServer(OPCServerProgID, groupID);
	OpcClient::addItemtoGrp(szItemID, VT_R4);
	OPCHANDLE *phServer;
	HRESULT *pErrors;
	VARIANT	values[1];
	HRESULT r1;
	LPWSTR	ErrorStr;

	if (m_pErrors[0] != S_OK)
	{
		return;
	}
	phServer = new OPCHANDLE[1];
	phServer[0] = m_ItemResult[0].hServer;

	values[0].vt = VT_R4;
	values[0].boolVal = value;
	r1 = m_IOPCSyncIO-&gt;Write(1, phServer, values, &amp;pErrors);
	delete[]phServer;
	Stop();
	return 0;
}

int OpcClient::setBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType)
{
	writeBool(OPCServerProgID, groupID, szItemID, true);
	if (readBool(OPCServerProgID, groupID, szItemID, VT_BOOL))
	{
		return 0;
	}
	else
	{
		return 1;
	}
}
int OpcClient::resetBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType)
{
	writeBool(OPCServerProgID, groupID, szItemID, false);
	if (readBool(OPCServerProgID, groupID, szItemID, VT_BOOL))
	{
		return 0;
	}
	else
	{
		return 1;
	}
}
int OpcClient::invertBool(LPWSTR OPCServerProgID, LPWSTR groupID, LPWSTR szItemID, VARTYPE vt_ItemType)
{
	if (readBool(OPCServerProgID, groupID, szItemID, VT_BOOL) == false)
	{
		writeBool(OPCServerProgID, groupID, szItemID, true);
		return 0;
	}
	if (readBool(OPCServerProgID, groupID, szItemID, VT_BOOL) == true)
	{
		writeBool(OPCServerProgID, groupID, szItemID, false);
		return 0;
	}
}

int OpcClient::Stop()
{
	if (OpcClientBusy == false)
	{
		return 1;

	}
	HRESULT r1;
	OPCHANDLE *phServer;
	HRESULT *pErrors;
	phServer = new OPCHANDLE[1];
	phServer[0] = m_ItemResult[0].hServer;
	r1 = m_IOPCItemMgt-&gt;RemoveItems(0,
		phServer,
		&amp;pErrors
		);
	delete[]phServer;
	CoTaskMemFree(pErrors);
	CoTaskMemFree(m_ItemResult);
	m_ItemResult = NULL;
	m_IOPCSyncIO-&gt;Release();
	m_IOPCSyncIO = NULL;
	m_IOPCItemMgt-&gt;Release();
	m_IOPCItemMgt = NULL;
	r1 = m_IOPCServer-&gt;RemoveGroup(m_GrpSrvHandle, true);
	m_GrpSrvHandle = NULL;
	m_IOPCServer-&gt;Release();
	m_IOPCServer = NULL;
	CoUninitialize();
	OpcClientBusy = false;
	return 0;
}

OpcClient::OpcClient()
{

	OpcClientBusy = false;//初始化为false
}

OpcClient::~OpcClient()
{
	//
}
</code></pre> 
<p>mian函数</p> 
<pre><code>// OpcClient.cpp : 定义控制台应用程序的入口点。

#include "stdafx.h"
#include "OpcClient.h"
using namespace std;

OpcClient ObjKepOpc;
int _tmain(int argc, _TCHAR *argv[])
{
	const LPWSTR OPCServerProgID = L"Kepware.KEPServerEX.V6";//服务器ProID
	const LPWSTR groupID = L"King.Win7";//GroupID，通道.设备
	const LPWSTR ritem_1 = L"King.Win7.Tag_1";//item格式，通道.设备.item
	const LPWSTR ritem_2 = L"King.Win7.Tag_2";//item格式，通道.设备.item

	const LPWSTR witem_1 = L"King.Win7.Tag_1_write";//item格式，通道.设备.item
	const LPWSTR witem_2 = L"King.Win7.Tag_2_write";//item格式，通道.设备.item
	ObjKepOpc.connectToServer(OPCServerProgID, groupID);
	while(1)
	{
		//读
		float r1 = ObjKepOpc.readFloat(OPCServerProgID, groupID,ritem_1, VT_R4);
		float r2 = ObjKepOpc.readFloat(OPCServerProgID, groupID,ritem_2, VT_R4);
		cout&lt;&lt; r1 &lt;&lt;endl;
		cout&lt;&lt; r2 &lt;&lt;endl;
		//写
		ObjKepOpc.writeFloat(OPCServerProgID, groupID,witem_1,r1);
		ObjKepOpc.writeFloat(OPCServerProgID, groupID,witem_2,r2);
	}
	return 0;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/2e/d1/y7kQpBrq_o.png" alt="在这里插入图片描述"></p> 
<p>完整项目：<br> https://download.csdn.net/download/weixin_37928884/86881385</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e79d457ad3d3bb649d085f88d7758a9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于uniapp小程序压缩视频后上传云点播视频损坏这件事</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f72a6083647f724655083be0e5fa5d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【优化笔记5】证明log-sum-exp函数是凸函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>