<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Libevent的使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Libevent的使用" />
<meta property="og:description" content="Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I/O 多路复用技术， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。
Chromium、Memcached、NTP、HTTPSQS等著名的开源程序都使用libevent库，足见libevent的稳定。更多使用libevent的程序可以到libevent的官网查看。
Libevent主要组成 libevent包括事件管理、缓存管理、DNS、HTTP、缓存事件几大部分。事件管理包括各种IO（socket）、定时器、信号等事件；缓存管理是指evbuffer功能；DNS是libevent提供的一个异步DNS查询功能；HTTP是libevent的一个轻量级http实现，包括服务器和客户端。libevent也支持ssl，这对于有安全需求的网络程序非常的重要，但是其支持不是很完善，比如http server的实现就不支持ssl。
Libevent的核心实现 Reactor（反应堆）模式是libevent的核心框架，libevent以事件驱动，自动触发回调功能。之前介绍的epoll反应堆的源码，就是从libevent中抽取出来的。
安装libevent 官方网站: http://libevent.org
源码下载主要分2个大版本：
1.4.x 系列，较为早期版本，适合源码学习2.x 系列，较新的版本，代码量比1.4版本多很多，功能也更完善。 源码包的安装，以2.0.22版本为例，在官网可以下载到源码包libevent-2.0.22-stable.tar.gz，基本安装步骤与第三方库源码包安装方式基本一致。
1、解压源码包：tar -xzvf libevent-2.0.22-stable.tar.gz 2、进入到源码目录：cd libevent-2.0.22-stable 3、执行配置./configure，生成makefile 4、编译源码 :执行make 5、编译后安装，输入本用户的密码: sudo make install 6、安装后验证，简单的先编译一个文件：demo.c
#include &lt;event.h&gt; #include &lt;stdio.h&gt; int main() { char ** methods = event_get_supported_methods();//获取libevent后端支持的方法 int i =0; for(i = 0;methods[i] != NULL ;i&#43;&#43;) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/ae737647b21f73b8bb161cebd139eb8b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-28T15:51:38+08:00" />
<meta property="article:modified_time" content="2023-12-28T15:51:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Libevent的使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">        Libevent 是一个用C语言</span>编写<span style="color:#333333;">的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I/O 多路复用技术， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">        Chromium、Memcached、NTP、HTTPSQS等著名的开源程序都使用libevent库，足见libevent的稳定。更多使用libevent的程序可以到libevent的官网查看。</span></span></p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><strong><strong>Li</strong></strong><strong><strong>bevent主要组成</strong></strong></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="background-color:#ffffff;"><span style="color:#333333;">        libevent包括事件管理、缓存管理、DNS、HTTP、缓存事件几大部分。事件管理包括各种IO（socket）、定时器、信号等事件；缓存管理是指evbuffer功能；DNS是libevent提供的一个异步DNS查询功能；HTTP是libevent的一个轻量级http实现，包括服务器和客户端。libevent也支持ssl，这对于有安全需求的网络程序非常的重要，但是其支持不是很完善，比如http server的实现就不支持ssl。</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 style="text-align:justify;"><strong><strong><strong>L</strong></strong><strong><strong>ibevent</strong></strong><strong><strong>的核心</strong></strong><strong><strong>实现</strong></strong></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">        Reactor（反应堆）模式是libevent的核心框架，libevent以事件驱动，自动触发回调功能。之前介绍的epoll反应堆的源码，就是从libevent中抽取出来的。</p> 
<h2 style="margin-left:.0001pt;text-align:justify;"><strong><strong><strong>安装libevent</strong></strong></strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">官方网站: <a href="http://libevent.org/" rel="nofollow" title="http://libevent.org">http://libevent.org</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">源码下载主要分2个大版本：</p> 
<ol><li style="text-align:justify;">1.4.x 系列，较为早期版本，适合源码学习</li><li style="text-align:justify;">2.x 系列，较新的版本，代码量比1.4版本多很多，功能也更完善。</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">源码包的安装，以2.0.22版本为例，在官网可以下载到源码包libevent-2.0.22-stable.tar.gz，基本安装步骤与第三方库源码包安装方式基本一致。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        <strong>1、解压源码包：tar -xzvf libevent-2.0.22-stable.tar.gz </strong></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="585" src="https://images2.imgbox.com/c5/bf/PVRihvWo_o.png" width="988"><a name="3268"></a></p> 
<div> 
 <div> 
  <img alt="" height="228" src="https://images2.imgbox.com/a4/9e/avuCAWGG_o.png" width="855"> 
 </div> 
 <div></div> 
 <div></div> 
 <div> 
  <strong>        2、进入到源码目录：cd libevent-2.0.22-stable</strong> 
 </div> 
 <div></div> 
 <div> 
  <img alt="" height="70" src="https://images2.imgbox.com/1d/9f/PEDnRLZU_o.png" width="799"> 
 </div> 
 <div></div> 
 <div>
            
 </div> 
 <div> 
  <strong>        3、执行配置./configure，生成makefile</strong> 
 </div> 
 <div> 
  <img alt="" height="561" src="https://images2.imgbox.com/a3/fd/GP2oxaqS_o.png" width="970"> 
 </div> 
 <div></div> 
 <div> 
  <strong>        4、<span style="color:#4d4d4d;">编译源码 :执行make</span></strong> 
 </div> 
 <div> 
  <img alt="" height="30" src="https://images2.imgbox.com/f5/c4/KdRZarM6_o.png" width="547"> 
 </div> 
 <div></div> 
 <div> 
  <strong>        5、编译后安装，输入本用户的密码: sudo make install</strong> 
 </div> 
 <div> 
  <img alt="" height="99" src="https://images2.imgbox.com/ac/57/MMmqe8E6_o.png" width="831"> 
 </div> 
 <div> 
  <p style="margin-left:.0001pt;text-align:justify;"></p> 
  <p style="margin-left:.0001pt;text-align:justify;"><strong>6、安装后验证，简单的先编译一个文件：demo.c</strong></p> 
  <pre><code class="language-cpp">#include &lt;event.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    char ** methods = event_get_supported_methods();//获取libevent后端支持的方法
    int i =0;
    for(i = 0;methods[i] != NULL ;i++)
    {
        printf("%s\n",methods[i]);
    }

    //获取当前平台支持的方法
	struct event_base * base = event_base_new();
		printf("%s\n",event_base_get_method(base));
    return 0;
}</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;"></p> 
  <p style="margin-left:.0001pt;text-align:justify;"><strong>编译：编译时需要指定库名  -levent    (可以忽略该警告，代表编译完成)</strong></p> 
  <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="286" src="https://images2.imgbox.com/77/4d/gcNyo9q0_o.png" width="978"></p> 
  <p style="margin-left:.0001pt;text-align:justify;"></p> 
  <p style="margin-left:.0001pt;text-align:justify;"><strong>执行：./demo     (同时也能看到libevent在当前主机上后端支持的多路IO方法)</strong></p> 
  <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="204" src="https://images2.imgbox.com/d6/7f/5tKaXQx5_o.png" width="976"></p> 
  <hr> 
  <h2 style="text-align:justify;"><strong><strong><strong>L</strong></strong><strong><strong>ibevent的</strong></strong><strong><strong>入门级使用</strong></strong></strong></h2> 
  <h3 style="text-align:justify;"><strong><strong><strong>L</strong></strong><strong><strong>ibevent</strong></strong><strong><strong>的地基</strong></strong><strong><strong>-</strong></strong><strong><strong>event_base</strong></strong></strong></h3> 
  <p>        在使用libevent的函数之前，需要先申请一个或event_base结构，相当于盖房子时的地基。在event_base基础上会有一个事件集合，可以检测哪个事件是激活的（就绪）。</p> 
  <p>通常情况下可以通过event_base_new函数获得event_base结构。</p> 
  <pre><code class="language-cpp">   struct event_base *event_base_new(void);</code></pre> 
  <p>申请到event_base结构指针可以通过event_base_free进行释放。</p> 
  <pre><code class="language-cpp"> void event_base_free(struct event_base *);</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;">如果fork出子进程，想在子进程继续使用event_base，那么子进程需要对event_base重新初始化，函数如下：</p> 
  <pre><code class="language-cpp"> int event_reinit(struct event_base *base);</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;">        对于不同系统而言，event_base就是调用不同的多路IO接口去判断事件是否已经被激活，对于linux系统而言，核心调用的就是epoll，同时支持poll和select。</p> 
  <h3 style="margin-left:.0001pt;text-align:justify;">等待事件产生-循环等待event_loop</h3> 
  <p style="margin-left:.0001pt;text-align:justify;">        Libevent在地基打好之后，需要等待事件的产生，也就是等待想要等待的事件的激活，那么程序不能退出，对于epoll来说，我们需要自己控制循环，而在libevent中也给我们提供了api接口，类似where(1)的功能.函数如下：<strong><span style="background-color:#ffffff;"><span style="color:#0000ff;">    </span></span></strong></p> 
  <pre><code class="language-cpp">    int event_base_loop(struct event_base *base, int flags);

        flags的取值：

                #define EVLOOP_ONCE 0x01

        只触发一次，如果事件没有被触发，阻塞等待

                #define EVLOOP_NONBLOCK 0x02

        非阻塞方式检测事件是否被触发，不管事件触发与否，都会立即返回

而大多数我们都调用libevent给我们提供的另外一个api：

        int event_base_dispatch(struct event_base *base);
        调用该函数，相当于没有设置标志位的event_base_loop。程序将会一直运行，直到没有需要检测的事件了，或者被结束循环的api终止。

        int event_base_loopexit(struct event_base *base, const struct timeval *tv);

        int event_base_loopbreak(struct event_base *base);

        struct timeval {

                long    tv_sec;                    
                long    tv_usec;            

                };</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;">        两个函数的区别是如果正在执行激活事件的回调函数，那么event_base_loopexit将在事件回调执行结束后终止循环（如果tv时间非NULL，那么将等待tv设置的时间后立即结束循环），而event_base_loopbreak会立即终止循环。</p> 
  <h3 style="text-align:justify;"><strong><strong><strong>事件驱动-</strong></strong><strong><strong>event</strong></strong></strong></h3> 
  <p>        事件驱动实际上是libevent的核心思想，对比epoll服务器流程</p> 
  <p><img alt="" height="744" src="https://images2.imgbox.com/b7/bb/7AeLyyK5_o.png" width="1200"></p> 
  <p style="margin-left:.0001pt;text-align:justify;"><strong>主要几个状态：</strong></p> 
  <p style="margin-left:.0001pt;text-align:justify;">        <strong>无效的指针</strong> 此时仅仅是定义了 struct event *ptr；</p> 
  <p style="margin-left:.0001pt;text-align:justify;">       <strong> 非未决</strong>：相当于创建了事件，但是事件还没有处于被监听状态，类似于我们使用epoll的时候定义了struct epoll_event ev并且对ev的两个字段进行了赋值，但是此时尚未调用epoll_ctl。</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        <strong>未决</strong>：就是对事件开始监听，暂时未有事件产生。相当于调用epoll_ctl。</p> 
  <p style="margin-left:.0001pt;text-align:justify;">        <strong>激活</strong>：代表监听的事件已经产生，这时需要处理，相当于我们epoll所说的事件就绪。</p> 
  <p style="margin-left:.0001pt;text-align:justify;">Libevent的事件驱动对应的结构体为struct event，对应的函数在图上也比较清晰，下面介绍一下主要的函数</p> 
  <p style="margin-left:.0001pt;text-align:justify;">1、event_new负责新创建event结构指针，同时指定对应的地基base，还有对应的文件描述符，事件，以及回调函数和回调函数的参数。</p> 
  <pre><code class="language-cpp">struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);

event_new负责新创建event结构指针，同时指定对应的地基base，还有对应的文件描述符，事件，以及回调函数和回调函数的参数。

参数说明：
    base 对应的根节点
    fd 要监听的文件描述符
    events 要监听的事件
		#define  EV_TIMEOUT         0x01   //超时事件
    #define  EV_READ                  0x02 //读事件
    #define  EV_WRITE                0x04  //写事件
    #define  EV_SIGNAL              0x08     //信号事件
    #define  EV_PERSIST              0x10   //周期性触发
    #define  EV_ET                        0x20 //边缘触发，如果底层模型支持
    cb 回调函数，原型如下：
        typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
            arg 回调函数的参数</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;">2、将非未决态事件转为未决态，相当于调用epoll_ctl函数，开始监听事件是否产生。</p> 
  <pre><code class="language-cpp">int event_add(struct event *ev, const struct timeval *timeout);

//将非未决态事件转为未决态，相当于调用epoll_ctl函数，开始监听事件是否产生。

参数说明：
	Ev 就是前面event_new创建的事件
    Timeout 限时等待事件的产生，也可以设置为NULL，没有限时。</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;">3、将事件从未决态变为非未决态，相当于epoll的下树（epoll_ctl调用EPOLL_CTL_DEL操作）操作。</p> 
  <pre><code class="language-cpp">int event_del(struct event *ev);

//将事件从未决态变为非未决态，相当于epoll的下树（epoll_ctl调用EPOLL_CTL_DEL操作）操作。</code></pre> 
  <p style="margin-left:.0001pt;text-align:justify;">4、释放event_new申请的event节点</p> 
  <pre><code class="language-cpp">void event_free(struct event *ev);

//释放event_new申请的event节点。</code></pre> 
  <h3 style="margin-left:.0001pt;text-align:justify;">用libevent写一下简易的事件驱动的网络服务器端程序：</h3> 
  <pre><code class="language-cpp">//event_server.c
//用libevent写一下简易的服务器

#include &lt;event.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;

struct event *readev = NULL;

void readcb(evutil_socket_t fd, short event, void * arg)
{
	//处理读事件
	char buf[256] = { 0 };
	int ret = read(fd, buf, sizeof(buf));
	if (ret &lt; 0){
		perror("read err");
		close(fd);
		event_del(readev);
	}
	else if (ret == 0){
		printf("client closed\n");
		close(fd);
		event_del(readev);
	}
	else{
		write(fd, buf, ret);//反射
	}
}
void conncb(evutil_socket_t fd, short event, void * arg)
{
	//处理连接
	struct event_base *base = (struct event_base*)arg;
	struct sockaddr_in client;
	socklen_t  len = sizeof(client);
	int cfd = accept(fd, (struct sockaddr*)&amp;client, &amp;len);
	if (cfd &gt; 0){
		//连接成功
		//需要将新的文件描述符上树
		readev = event_new(base, cfd, EV_READ | EV_PERSIST, readcb, base);
		event_add(readev, NULL);
	}
}

int main()
{
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	struct sockaddr_in serv;
	bzero(&amp;serv, sizeof(serv));
	serv.sin_addr.s_addr = htonl(INADDR_ANY);
	serv.sin_port = htons(8888);
	serv.sin_family = AF_INET;

	bind(fd, (struct sockaddr*)&amp;serv, sizeof(serv));

	listen(fd, 120);
	struct event_base *base = event_base_new();//创建根节点

	//struct event *event_new(struct event_base *, evutil_socket_t, short, event_callback_fn, void *);
	struct event *connev = event_new(base, fd, EV_READ | EV_PERSIST, conncb, base);
	event_add(connev, NULL);//开始监听
	//循环
	event_base_dispatch(base);
	event_base_free(base);//释放
	event_free(connev);
	event_free(readev);
	return 0;
}</code></pre> 
  <hr> 
  <h3 style="text-align:justify;"><strong><strong><strong>自带buffer</strong></strong><strong><strong>的事件</strong></strong><strong><strong>-</strong></strong><strong><strong>bufferevent</strong></strong></strong></h3> 
  <p>        Bufferevent实际上也是一个event，只不过比普通的event高级一些，它的内部有两个缓冲区，以及一个文件描述符（网络套接字）。我们都知道一个网络套接字有读和写两个缓冲区，bufferevent同样也带有两个缓冲区，还有就是libevent事件驱动的核心回调函数，那么四个缓冲区以及触发回调的关系如下：</p> 
  <p><img alt="" height="525" src="https://images2.imgbox.com/d1/6b/w5t4O9iI_o.png" width="826"></p> 
  <p></p> 
  <p style="margin-left:.0001pt;text-align:justify;">核心:  一个文件描述符  两个缓冲区  3个回调</p> 
  <p><img alt="" height="687" src="https://images2.imgbox.com/6c/77/79AdHqZ5_o.png" width="1023"></p> 
  <p style="margin-left:.0001pt;text-align:justify;">有三个回调函数：</p> 
  <ol><li style="text-align:justify;">读回调 – 当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调</li><li style="text-align:justify;">写回调 – 当bufferevent将自身写缓冲的数据写到底层写缓冲区的时候出发写事件回调</li><li style="text-align:justify;">事件回调 – 当bufferevent绑定的socket连接，断开或者异常的时候触发事件回调</li></ol> 
  <h4 style="margin-left:.0001pt;text-align:justify;">主要使用的函数如下：</h4> 
  <p style="margin-left:.0001pt;text-align:justify;">        1、bufferevent_socket_new 对已经存在socket创建bufferevent事件，可用于后面讲到的链接监听器的回调函数中</p> 
  <pre><code class="language-cpp">struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);

bufferevent_socket_new 对已经存在socket创建bufferevent事件，可用于后面讲到的链接监听器的回调函数中，

参数说明：
	base – 对应根节点
	fd   -- 文件描述符
	options – bufferevent的选项
		BEV_OPT_CLOSE_ON_FREE   -- 释放bufferevent自动关闭底层接口    
		BEV_OPT_THREADSAFE      -- 使bufferevent能够在多线程下是安全的</code></pre> 
  <p style="margin-left:.0001pt;text-align:left;">        2、bufferevent_socket_connect封装了底层的socket与connect接口，通过调用此函数，可以将bufferevent事件与通信的socket进行绑定</p> 
  <pre><code class="language-cpp">int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen);

bufferevent_socket_connect封装了底层的socket与connect接口，通过调用此函数，可以将bufferevent事件与通信的socket进行绑定，

参数如下：
	bev – 需要提前初始化的bufferevent事件
	serv – 对端的ip地址，端口，协议的结构指针
	socklen – 描述serv的长度</code></pre> 
  <p style="text-align:justify;">3、释放bufferevent</p> 
  <pre><code class="language-cpp">void bufferevent_free(struct bufferevent *bufev);

//释放bufferevent</code></pre> 
  <p style="text-align:justify;">4、bufferevent_setcb用于设置bufferevent的回调函数</p> 
  <pre><code class="language-cpp">void bufferevent_setcb(struct bufferevent *bufev,
    bufferevent_data_cb readcb, bufferevent_data_cb writecb,
bufferevent_event_cb eventcb, void *cbarg);

	bufferevent_setcb用于设置bufferevent的回调函数，readcb，writecb，eventcb分别对应了读回调，写回调，事件回调，cbarg代表回调函数的参数。

	回调函数的原型：
	typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
	typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);

    What 代表对应的事件：
            BEV_EVENT_EOF, BEV_EVENT_ERROR，BEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED</code></pre> 
  <p style="text-align:justify;">5、bufferevent_write是将data的数据写到bufferevent的写缓冲区</p> 
  <pre><code class="language-cpp">int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);
    //bufferevent_write是将data的数据写到bufferevent的写缓冲区	


int bufferevent_write_buffer(struct bufferevent *bufev, struct evbuffer *buf);
    //bufferevent_write_buffer 是将数据写到写缓冲区另外一个写法，实际上bufferevent的内部的两个缓冲区结构就是struct evbuffer。</code></pre> 
  <p style="text-align:justify;">6、bufferevent_read 是将bufferevent的读缓冲区数据读到data中，同时将读到的数据从bufferevent的读缓冲清除。</p> 
  <pre><code class="language-cpp">size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
	//bufferevent_read 是将bufferevent的读缓冲区数据读到data中，同时将读到的数据从bufferevent的读缓冲清除。

int bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf);
	//bufferevent_read_buffer 将bufferevent读缓冲数据读到buf中，接口的另外一种。</code></pre> 
  <p style="text-align:justify;">7、<span style="background-color:#ffffff;"><span style="color:#000000;">bufferevent_enable</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">与</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">bufferevent_disable</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">是</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">设置事件是否</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">生效</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">，如果设置为disable，</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">事件</span></span><span style="background-color:#ffffff;"><span style="color:#000000;">回调将不会被触发。</span></span></p> 
  <pre><code class="language-cpp">int bufferevent_enable(struct bufferevent *bufev, short event);


int bufferevent_disable(struct bufferevent *bufev, short event);</code></pre> 
  <h4 style="margin-left:.0001pt;text-align:left;"><strong><strong><strong>链接监听器-</strong></strong><strong><strong>evconnlistener</strong></strong></strong><span style="color:#000000;"> </span></h4> 
  <p style="margin-left:.0001pt;text-align:left;">        链接监听器封装了底层的socket通信相关函数，比如socket，bind，listen，accept这几个函数。链接监听器创建后实际上相当于调用了socket，bind，listen，此时等待新的客户端连接到来，如果有新的客户端连接，那么内部先进行accept处理，然后调用用户指定的回调函数。</p> 
  <p style="margin-left:.0001pt;text-align:justify;"> 1、evconnlistener_new_bind是在当前没有套接字的情况下对链接监听器进行初始化，看最后2个参数实际上就是bind使用的关键参数，backlog是listen函数的关键参数（略有不同的是，如果backlog是-1，那么监听器会自动选择一个合适的值，如果填0，那么监听器会认为listen函数已经被调用过了），ptr是回调函数的参数，cb是有新连接之后的回调函数，但是注意这个回调函数触发的时候，链接器已经处理好新连接了，并将与新连接通信的描述符交给回调函数。</p> 
  <pre><code class="language-cpp">struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
const struct sockaddr *sa, int socklen);



Flags 需要参考几个值：
	LEV_OPT_LEAVE_SOCKETS_BLOCKING   文件描述符为阻塞的
	LEV_OPT_CLOSE_ON_FREE            关闭时自动释放
	LEV_OPT_REUSEABLE                端口复用
	LEV_OPT_THREADSAFE               分配锁，线程安全</code></pre> 
  <p style="margin-left:.0001pt;text-align:left;">2、evconnlistener_new函数与前一个函数不同的地方在与后2个参数，使用本函数时，认为socket已经初始化好，并且bind完成，甚至也可以做完listen，所以大多数时候，我们都可以使用第一个函数。</p> 
  <pre><code class="language-cpp">struct evconnlistener *evconnlistener_new(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
evutil_socket_t fd);


//两个函数的回调函数
typedef void (*evconnlistener_cb)(struct evconnlistener *evl, evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr);
主要回调函数fd参数会与客户端通信的描述符，并非是等待连接的监听的那个描述符，所以cliaddr对应的也是新连接的对端地址信息，已经是accept处理好的。</code></pre> 
  <p style="margin-left:.0001pt;text-align:left;">3、操作链接监听器</p> 
  <pre><code class="language-cpp">void evconnlistener_free(struct evconnlistener *lev);
//释放链接监听器


int evconnlistener_enable(struct evconnlistener *lev);
//使链接监听器生效


int evconnlistener_disable(struct evconnlistener *lev);
//使链接监听器失效</code></pre> 
  <h4 style="margin-left:.0001pt;text-align:left;"></h4> 
  <h4 style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">bufferveent事件的监听流程</span></h4> 
  <p><img alt="" height="742" src="https://images2.imgbox.com/a5/a6/uxlZyWMz_o.png" width="1200"></p> 
 </div> 
</div> 
<h3>libevent中hello-world.c的代码（在安装包的sample目录下） 阅读：</h3> 
<pre><code class="language-cpp">/*
  This exmple program provides a trivial server program that listens for TCP
  connections on port 9995.  When they arrive, it writes a short message to
  each client connection, and closes each connection once it is flushed.

  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).
*/


#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#ifndef WIN32
#include &lt;netinet/in.h&gt;
# ifdef _XOPEN_SOURCE_EXTENDED
#  include &lt;arpa/inet.h&gt;
# endif
#include &lt;sys/socket.h&gt;
#endif

#include &lt;event2/bufferevent.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/listener.h&gt;
#include &lt;event2/util.h&gt;
#include &lt;event2/event.h&gt;

static const char MESSAGE[] = "Hello, World!\n";

static const int PORT = 9995;

static void conn_readcb(struct bufferevent *bev, void *user_data);
static void listener_cb(struct evconnlistener *, evutil_socket_t,
    struct sockaddr *, int socklen, void *);
static void conn_writecb(struct bufferevent *, void *);
static void conn_eventcb(struct bufferevent *, short, void *);
static void signal_cb(evutil_socket_t, short, void *);

int
main(int argc, char **argv)
{
	struct event_base *base;
	struct evconnlistener *listener;
	struct event *signal_event;

	struct sockaddr_in sin;
#ifdef WIN32
	WSADATA wsa_data;
	WSAStartup(0x0201, &amp;wsa_data);
#endif

	base = event_base_new();//创建event_base根节点
	if (!base) {
		fprintf(stderr, "Could not initialize libevent!\n");
		return 1;
	}

	memset(&amp;sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(PORT);

	//创建链接侦听器
	listener = evconnlistener_new_bind(base, listener_cb, (void *)base,
	    LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,
	    (struct sockaddr*)&amp;sin,
	    sizeof(sin));

	if (!listener) {
		fprintf(stderr, "Could not create a listener!\n");
		return 1;
	}
	//创建信触发的节点
	signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base);
	//将信号节点上树
	if (!signal_event || event_add(signal_event, NULL)&lt;0) {
		fprintf(stderr, "Could not create/add a signal event!\n");
		return 1;
	}

	event_base_dispatch(base);//循环监听

	evconnlistener_free(listener);//释放链接侦听器
	event_free(signal_event);//释放信号节点
	event_base_free(base);//释放event_base根节点

	printf("done\n");
	return 0;
}

static void
listener_cb(struct evconnlistener *listener, evutil_socket_t fd,
    struct sockaddr *sa, int socklen, void *user_data)
{
	struct event_base *base = user_data;
	struct bufferevent *bev;

	//将fd上树
	//新建一个buffervent节点
	bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
	if (!bev) {
		fprintf(stderr, "Error constructing bufferevent!");
		event_base_loopbreak(base);
		return;
	}
	//设置回调
	bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);
	bufferevent_enable(bev, EV_WRITE | EV_READ);//设置写事件使能
	//bufferevent_disable(bev, EV_READ);//设置读事件非使能

	bufferevent_write(bev, MESSAGE, strlen(MESSAGE));//给cfd发送消息 helloworld
}
static void conn_readcb(struct bufferevent *bev, void *user_data)
{
	char buf[1500]="";
	int n = bufferevent_read(bev,buf,sizeof(buf));
	printf("%s\n",buf);
	bufferevent_write(bev, buf,n);//给cfd发送消息 



}

static void
conn_writecb(struct bufferevent *bev, void *user_data)
{
	struct evbuffer *output = bufferevent_get_output(bev);//获取缓冲区类型
	if (evbuffer_get_length(output) == 0) {
		
	//	printf("flushed answer\n");
	//	bufferevent_free(bev);//释放节点 自动关闭
	}
}

static void
conn_eventcb(struct bufferevent *bev, short events, void *user_data)
{
	if (events &amp; BEV_EVENT_EOF) {
		printf("Connection closed.\n");
	} else if (events &amp; BEV_EVENT_ERROR) {
		printf("Got an error on the connection: %s\n",
		    strerror(errno));/*XXX win32*/
	}
	/* None of the other events can happen here, since we haven't enabled
	 * timeouts */
	bufferevent_free(bev);
}

static void
signal_cb(evutil_socket_t sig, short events, void *user_data)
{
	struct event_base *base = user_data;
	struct timeval delay = { 2, 0 };

	printf("Caught an interrupt signal; exiting cleanly in two seconds.\n");

	event_base_loopexit(base, &amp;delay);//退出循环监听
}
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/16d147886c4c095da5c6d6c22e1aaa49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">&amp;nbsp</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1354bebe9dc7438e216602430fe9dfe3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【排序算法】合并两个有序数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>