<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;独有的特点 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;独有的特点" />
<meta property="og:description" content="STL容器
序列容器：vector,string list
vector和list的区别：
vector:和数组类似，有连续的内存空间且起始地址不变，内存空间不够要重新申请内存。
list:双向链表实现，空间不连续，指针访问。
关联容器：set map
map:红黑树，二叉查找树，可自动按键值排序。是标准的一部分。
hashmap:哈希表，各项操作的评价时间复杂度近常数。
适配容器：stack queue dequeue(动态数组，双向队列实现)
STL智能指针：auto_ptr，当出现异常时，分配的对象能被自动销毁，内存自动释放。
多态 封装 继承
继承
私有继承：编译器不会将派生类对象转换成基类对象。从私有基类继承来的成员都成为了派生类的私有对象。
多重继承：优点：可调用多个基类中的接口 缺点：容易出现继承向上的二义性，解决办法，改为虚拟继承，不会出现重复拷贝现象。
多重继承中的构造函数顺序：
1.虚拟基类的构造函数按照它们被继承的顺序构造
2.非虚基类的构造函数按照被构造的顺序
3.成员对象的构造按照声明顺序调用
4.类自身构造函数
多态
1.编译时多态：通过重载实现，对非虚成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现哪种操作
2.运行时多态：虚成员。运行时才根据具体情况决定实现何种操作。
虚函数
1.系统会为类分配一个指针成员指向一个虚函数表，表中每项指向一个虚函数的地址，即函数指针数组。
2.虚函数表一继承性和多态性。
3.构造函数不能调用虚函数
虚函数和纯虚函数的区别：
1.虚函数在类中可以实现，作用是为了让这个函数在子类里可以被覆盖，实现多态。纯虚函数只是一个接口，函数声明，在子类中实现
2.虚函数在子类中可以不重载，纯虚函数必须在子类中实现
3.虚函数的类用于&#39;实作继承&#39;：继承接口的同时也继承了父类的实现。纯虚函数‘介面继承’：关注的是接口的统一性。
4.带纯虚函数的类叫虚基类，不能直接生成对象(实例化)，只有被继承并重写起虚函数后才能使用。
抽象基类/虚基类：含有纯虚函数的基类，
1.方便使用多态性 2.纯虚函数相当于接口，能把派生类的共同特征提取出来。
1.class和struct的区别
class继承是private，可表示模板类型。struct是Public。
2.静态成员对每个类的类型只有一个复制品，有所有对象共享访问，当作该类型的全局变量。非静态成员每个类对象都有自己的复制品。静态成员函数不属于类的对象，没有this指针。
3.静态数据成员与全局变量相比的优势：1.没有进入程序的全局名字空间，不存在命名冲突。2.可设private隐藏信息。3.必须在类外面初始化。
4.空类默认会产生：默认构造函数、复制构造函数、析构函数、赋值函数、取值运算
5.构造函数可以被重载，可以有好几个，可带参。析构函数只有一个不能被重载，且不能带参。
6.只有基类才会把析构函数写成虚函数，避免内存泄漏。
7.复制构造函数被调用的情况：1.对象以值传递的方式传入函数体。2.以值传递的方式从函数返回。3.需要通过另外一个对象进行初始化。
深复制：为新对象制作了外部对象的独立复制 浅复制：新旧对象指向同一个外部内容。
8.函数重载是用来描述同名函数具有相同或相似功能，但数据类型或参数不同的函数。
9.重载和覆写的区别：
重载：子类改写了父类的方法，一种语法规则，在编译阶段完成，不属于面向对象编程 特征：1.方法名必须相同 2.参数列表必须不同 3.返回值可以不同
覆写：派生类重写基类的虚函数，运行阶段决定，是面向对象编程的重要特征
特征：1.只有虚方法和抽象方法才能被覆写 2.相同函数名 参数列表 返回值
1" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0a711f6ee24843c14397aa188822ec15/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-26T17:46:32+08:00" />
<meta property="article:modified_time" content="2021-08-26T17:46:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;独有的特点</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>STL容器<br> 序列容器：vector,string list<br> vector和list的区别：<br> vector:和数组类似，有连续的内存空间且起始地址不变，内存空间不够要重新申请内存。<br> list:双向链表实现，空间不连续，指针访问。</p> 
<p>关联容器：set map<br> map:红黑树，二叉查找树，可自动按键值排序。是标准的一部分。<br> hashmap:哈希表，各项操作的评价时间复杂度近常数。<br> 适配容器：stack queue  dequeue(动态数组，双向队列实现)</p> 
<p>STL智能指针：auto_ptr，当出现异常时，分配的对象能被自动销毁，内存自动释放。</p> 
<p><br> 多态 封装 继承</p> 
<p>继承<br> 私有继承：编译器不会将派生类对象转换成基类对象。从私有基类继承来的成员都成为了派生类的私有对象。<br> 多重继承：优点：可调用多个基类中的接口   缺点：容易出现继承向上的二义性，解决办法，改为虚拟继承，不会出现重复拷贝现象。<br> 多重继承中的构造函数顺序：<br> 1.虚拟基类的构造函数按照它们被继承的顺序构造<br> 2.非虚基类的构造函数按照被构造的顺序<br> 3.成员对象的构造按照声明顺序调用<br> 4.类自身构造函数</p> 
<p>多态<br> 1.编译时多态：通过重载实现，对非虚成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现哪种操作<br> 2.运行时多态：虚成员。运行时才根据具体情况决定实现何种操作。</p> 
<p>虚函数<br> 1.系统会为类分配一个指针成员指向一个虚函数表，表中每项指向一个虚函数的地址，即函数指针数组。<br> 2.虚函数表一继承性和多态性。<br> 3.构造函数不能调用虚函数</p> 
<p>虚函数和纯虚函数的区别：<br> 1.虚函数在类中可以实现，作用是为了让这个函数在子类里可以被覆盖，实现多态。纯虚函数只是一个接口，函数声明，在子类中实现<br> 2.虚函数在子类中可以不重载，纯虚函数必须在子类中实现<br> 3.虚函数的类用于'实作继承'：继承接口的同时也继承了父类的实现。纯虚函数‘介面继承’：关注的是接口的统一性。<br> 4.带纯虚函数的类叫虚基类，不能直接生成对象(实例化)，只有被继承并重写起虚函数后才能使用。</p> 
<p>抽象基类/虚基类：含有纯虚函数的基类，<br> 1.方便使用多态性   2.纯虚函数相当于接口，能把派生类的共同特征提取出来。</p> 
<p>1.class和struct的区别<br> class继承是private，可表示模板类型。struct是Public。</p> 
<p><br> 2.静态成员对每个类的类型只有一个复制品，有所有对象共享访问，当作该类型的全局变量。非静态成员每个类对象都有自己的复制品。静态成员函数不属于类的对象，没有this指针。<br> 3.静态数据成员与全局变量相比的优势：1.没有进入程序的全局名字空间，不存在命名冲突。2.可设private隐藏信息。3.必须在类外面初始化。<br> 4.空类默认会产生：默认构造函数、复制构造函数、析构函数、赋值函数、取值运算<br> 5.构造函数可以被重载，可以有好几个，可带参。析构函数只有一个不能被重载，且不能带参。<br> 6.只有基类才会把析构函数写成虚函数，避免内存泄漏。<br> 7.复制构造函数被调用的情况：1.对象以值传递的方式传入函数体。2.以值传递的方式从函数返回。3.需要通过另外一个对象进行初始化。<br> 深复制：为新对象制作了外部对象的独立复制   浅复制：新旧对象指向同一个外部内容。<br> 8.函数重载是用来描述同名函数具有相同或相似功能，但数据类型或参数不同的函数。<br> 9.重载和覆写的区别：<br> 重载：子类改写了父类的方法，一种语法规则，在编译阶段完成，不属于面向对象编程  <br> 特征：1.方法名必须相同  2.参数列表必须不同  3.返回值可以不同<br> 覆写：派生类重写基类的虚函数，运行阶段决定，是面向对象编程的重要特征<br> 特征：1.只有虚方法和抽象方法才能被覆写  2.相同函数名 参数列表 返回值<br> 1</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4094709a079ac56f21f341acd8407fad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">遇到的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/811d02b22616456174040bb8ceec2e9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常考基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>