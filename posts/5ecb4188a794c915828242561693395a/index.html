<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PHP中被忽略的性能优化利器：生成器 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PHP中被忽略的性能优化利器：生成器" />
<meta property="og:description" content="如果是做Python或者其他语言的小伙伴，对于生成器应该不陌生。但很多PHP开发者或许都不知道生成器这个功能，可能是因为生成器是PHP 5.5.0才引入的功能，也可以是生成器作用不是很明显。但是，生成器功能的确非常有用。
优点 直接讲概念估计你听完还是一头雾水，所以我们先来说说优点，也许能勾起你的兴趣。那么生成器有哪些优点，如下：
生成器会对PHP应用的性能有非常大的影响PHP代码运行时节省大量的内存比较适合计算大量的数据 那么，这些神奇的功能究竟是如何做到的？我们先来举个例子。
概念引入 首先，放下生成器概念的包袱，来看一个简单的PHP函数：
function createRange($number){ $data = []; for($i=0;$i&lt;$number;$i&#43;&#43;){ $data[] = time(); } return $data; } 这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单：
我们创建一个函数。函数内包含一个for循环，我们循环的把当前时间放到$data里面 for循环执行完毕，把$data返回出去。 下面没完，我们继续。我们再写一个函数，把这个函数的返回值循环打印出来：
$result = createRange(10); // 这里调用上面我们创建的函数 foreach($result as $value){ sleep(1);//这里停顿1秒，我们后续有用 echo $value.&#39;&lt;br /&gt;&#39;; } 我们在浏览器里面看一下运行结果：
这里非常完美，没有任何问题。（当然sleep(1)效果你们看不出来）
思考一个问题 我们注意到，在调用函数createRange的时候给$number的传值是10，一个很小的数字。假设，现在传递一个值10000000（1000万）。
那么，在函数createRange里面，for循环就需要执行1000万次。且有1000万个值被放到$data里面，而$data数组在是被放在内存内。所以，在调用函数时候会占用大量内存。
这里，生成器就可以大显身手了。
创建生成器 我们直接修改代码，你们注意观察：
function createRange($number){ for($i=0;$i&lt;$number;$i&#43;&#43;){ yield time(); } } 看下这段和刚刚很像的代码，我们删除了数组$data，而且也没有返回任何内容，而是在time()之前使用了一个关键字yield
使用生成器 我们再运行一下第二段代码：
$result = createRange(10); // 这里调用上面我们创建的函数 foreach($result as $value){ sleep(1); echo $value.&#39;&lt;br /&gt;&#39;; } 我们奇迹般的发现了，输出的值和第一次没有使用生成器的不一样。这里的值（时间戳）中间间隔了1秒。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5ecb4188a794c915828242561693395a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-08T08:53:51+08:00" />
<meta property="article:modified_time" content="2017-12-08T08:53:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PHP中被忽略的性能优化利器：生成器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <p>如果是做Python或者其他语言的小伙伴，对于生成器应该不陌生。但很多PHP开发者或许都不知道生成器这个功能，可能是因为生成器是PHP 5.5.0才引入的功能，也可以是生成器作用不是很明显。但是，生成器功能的确非常有用。</p> 
 <h3>优点</h3> 
 <p>直接讲概念估计你听完还是一头雾水，所以我们先来说说优点，也许能勾起你的兴趣。那么生成器有哪些优点，如下：</p> 
 <ul><li>生成器会对PHP应用的性能有非常大的影响</li><li>PHP代码运行时节省大量的内存</li><li>比较适合计算大量的数据</li></ul> 
 <p>那么，这些神奇的功能究竟是如何做到的？我们先来举个例子。</p> 
 <h3>概念引入</h3> 
 <p>首先，放下生成器概念的包袱，来看一个简单的PHP函数：</p> 
 <pre><code>function createRange($number){
    $data = [];
    for($i=0;$i&lt;$number;$i++){
        $data[] = time();
    }
    return $data;
}</code></pre> 
 <p>这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单：</p> 
 <ol><li>我们创建一个函数。</li><li>函数内包含一个<code>for</code>循环，我们循环的把当前时间放到<code>$data</code>里面</li><li> <code>for</code>循环执行完毕，把<code>$data</code>返回出去。</li></ol> 
 <p>下面没完，我们继续。我们再写一个函数，把这个函数的返回值循环打印出来：</p> 
 <pre><code>$result = createRange(10); // 这里调用上面我们创建的函数
foreach($result as $value){
    sleep(1);//这里停顿1秒，我们后续有用
    echo $value.'&lt;br /&gt;';
}</code></pre> 
 <p>我们在浏览器里面看一下运行结果：</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/12/c9/xow98er1_o.png" alt="图片描述" title="图片描述"></span></p> 
 <p>这里非常完美，没有任何问题。（当然<code>sleep(1)</code>效果你们看不出来）</p> 
 <h3>思考一个问题</h3> 
 <p>我们注意到，在调用函数<code>createRange</code>的时候给<code>$number</code>的传值是10，一个很小的数字。假设，现在传递一个值<code>10000000</code>（1000万）。</p> 
 <p>那么，在函数<code>createRange</code>里面，<code>for</code>循环就需要执行<code>1000</code>万次。且有<code>1000</code>万个值被放到<code>$data</code>里面，而<code>$data</code>数组在是被放在内存内。所以，在调用函数时候会占用大量内存。</p> 
 <p>这里，生成器就可以大显身手了。</p> 
 <h3>创建生成器</h3> 
 <p>我们直接修改代码，你们注意观察：</p> 
 <pre><code>function createRange($number){
    for($i=0;$i&lt;$number;$i++){
        yield time();
    }
}</code></pre> 
 <p>看下这段和刚刚很像的代码，我们删除了数组<code>$data</code>，而且也没有返回任何内容，而是在<code>time()</code>之前使用了一个关键字<code>yield</code></p> 
 <h3>使用生成器</h3> 
 <p>我们再运行一下第二段代码：</p> 
 <pre><code>$result = createRange(10); // 这里调用上面我们创建的函数
foreach($result as $value){
    sleep(1);
    echo $value.'&lt;br /&gt;';
}</code></pre> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/4c/01/1lYtqnVo_o.png" alt="图片描述" title="图片描述"></span></p> 
 <p>我们奇迹般的发现了，输出的值和第一次没有使用生成器的不一样。这里的值（时间戳）中间间隔了1秒。</p> 
 <p>这里的间隔一秒其实就是<code>sleep(1)</code>造成的后果。但是为什么第一次没有间隔？那是因为：</p> 
 <ul><li>未使用生成器时：<code>createRange</code>函数内的<code>for</code>循环结果被很快放到<code>$data</code>中，并且立即返回。所以，<code>foreach</code>循环的是一个固定的数组。</li><li>使用生成器时：<code>createRange</code>的值不是一次性快速生成，而是依赖于<code>foreach</code>循环。<code>foreach</code>循环一次，<code>for</code>执行一次。</li></ul> 
 <p>到这里，你应该对生成器有点儿头绪。</p> 
 <h3>深入理解生成器</h3> 
 <h4>代码剖析</h4> 
 <p>下面我们来对于刚刚的代码进行剖析。</p> 
 <pre><code>function createRange($number){
    for($i=0;$i&lt;$number;$i++){
        yield time();
    }
}

$result = createRange(10); // 这里调用上面我们创建的函数
foreach($result as $value){
    sleep(1);
    echo $value.'&lt;br /&gt;';
}</code></pre> 
 <p>我们来还原一下代码执行过程。</p> 
 <ol><li>首先调用<code>createRange</code>函数，传入参数<code>10</code>，但是<code>for</code>值执行了一次然后停止了，并且告诉<code>foreach</code>第一次循环可以用的值。</li><li> <code>foreach</code>开始对<code>$result</code>循环，进来首先<code>sleep(1)</code>，然后开始使用<code>for</code>给的一个值执行输出。</li><li> <code>foreach</code>准备第二次循环，开始第二次循环之前，它向<code>for</code>循环又请求了一次。</li><li> <code>for</code>循环于是又执行了一次，将生成的时间戳告诉<code>foreach</code>.</li><li> <code>foreach</code>拿到第二个值，并且输出。由于<code>foreach</code>中<code>sleep(1)</code>，所以，<code>for</code>循环延迟了1秒生成当前时间</li></ol> 
 <p>所以，整个代码执行中，始终只有一个记录值参与循环，内存中也只有一条信息。</p> 
 <p>无论开始传入的<code>$number</code>有多大，由于并不会立即生成所有结果集，所以内存始终是一条循环的值。</p> 
 <h4>概念理解</h4> 
 <p>到这里，你应该已经大概理解什么是生成器了。下面我们来说下生成器原理。</p> 
 <p>首先明确一个概念：<strong>生成器yield关键字不是返回值，他的专业术语叫产出值，只是生成一个值</strong></p> 
 <p>那么代码中<code>foreach</code>循环的是什么？其实是PHP在使用生成器的时候，会返回一个<code>Generator</code>类的对象。<code>foreach</code>可以对该对象进行迭代，每一次迭代，PHP会通过<code>Generator</code>实例计算出下一次需要迭代的值。这样<code>foreach</code>就知道下一次需要迭代的值了。</p> 
 <p>而且，在运行中<code>for</code>循环执行后，会立即停止。等待<code>foreach</code>下次循环时候再次和<code>for</code>索要下次的值的时候，<code>for</code>循环才会再执行一次，然后立即再次停止。直到不满足条件不执行结束。</p> 
 <h3>实际开发应用</h3> 
 <p>很多PHP开发者不了解生成器，其实主要是不了解应用领域。那么，生成器在实际开发中有哪些应用？</p> 
 <h4>读取超大文件</h4> 
 <p>PHP开发很多时候都要读取大文件，比如csv文件、text文件，或者一些日志文件。这些文件如果很大，比如5个G。这时，直接一次性把所有的内容读取到内存中计算不太现实。</p> 
 <p>这里生成器就可以派上用场啦。简单看个例子：读取text文件</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/95/3a/l9ZYS6Te_o.png" alt="图片描述" title="图片描述"></span></p> 
 <p>我们创建一个text文本文档，并在其中输入几行文字，示范读取。</p> 
 <pre><code>&lt;?php
header("content-type:text/html;charset=utf-8");
function readTxt()
{
    # code...
    $handle = fopen("./test.txt", 'rb');

    while (feof($handle)===false) {
        # code...
        yield fgets($handle);
    }

    fclose($handle);
}

foreach (readTxt() as $key =&gt; $value) {
    # code...
    echo $value.'&lt;br /&gt;';
}</code></pre> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/e4/00/5uXpqNW9_o.png" alt="图片描述" title="图片描述"></span></p> 
 <p>通过上图的输出结果我们可以看出代码完全正常。</p> 
 <p>但是，背后的代码执行规则却一点儿也不一样。使用生成器读取文件，第一次读取了第一行，第二次读取了第二行，以此类推，<strong>每次被加载到内存中的文字只有一行</strong>，大大的减小了内存的使用。</p> 
 <p>这样，即使读取上G的文本也不用担心，完全可以像读取很小文件一样编写代码。</p> 
 <h3>完</h3> 
 <p>推荐一个我们团队自己开发的针对开发者的网址导航：<a href="https://www.bidianer.com" rel="nofollow">笔点导航 - 用心做最简洁的网址导航</a></p> 
 <ol><li>可以自定义网址</li><li>可以自定义分类</li><li>分类可以标记颜色</li><li>自定义皮肤</li><li>自定义搜索</li><li>网址拖拽排序</li><li>自定义插件小模块</li></ol> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/50/ea/qzClrRcj_o.png" alt="图片描述" title="图片描述"></span></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96af60d7a1a36bb81f8878930232037a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css中按钮的四种状态</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b7aff7ea090e1d163b9d07c4e61301c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Jupyter Notebook（一）安装配置与使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>