<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>杨中科 ASP.NETCore Rest - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="杨中科 ASP.NETCore Rest" />
<meta property="og:description" content="什么是Rest RPC 1、Web API两种风格: 面向过程(RPC) 、面向REST (REST)
2、RPC:“控制器/操作方法“的形式把服务器端的代码当成方法去调用。把HTTP当成传输数据的通道，不关心HTTP谓词。通过QueryString请求报文体给服务器传递数据。状态码。比如/Persons/GetAll、/Persons/GetBvld?id=8./Persons/Update、/Persons/DeleteByld/8
REST REST: 按照HTTP的语义来使用HTTP协议
1、URL用于资源的定位: /user/888、/user/888/orders)
2、HTTP谓词: GET、POST (新增) 、PUT (整体更新)DELETE、PATCH (局部更新) 等
3、什么是“幂等”，举例? DELETE（删除id=1的数据，多次删除都是一样的）、PUT、GET是幂等的POST不幂等（幂等：执行一次和执行多次的结果是一致的）
4、GET的响应可以被缓存
5、服务器端要通过状态码来反映资源获取的结果: 404、403(没有权限) 、201 (新增成功)
RPC:业务驱动，自然
REST: 要求开发人员对REST原则更了解、并且有更多的设计能力。
没有绝对的好与坏，根据业务需求选择适合自己的方式。
REST的优缺点 REST的优点 1、通过URL对资源定位，语义更清晰
2、通过HTTP谓词表示不同的操作，接口自描
3、可以对GET、PUT、DELETE请求进行重试
4、可以用GET请求做缓存
5、通过HTTP状态码反映服务器端的处理结果统一错误处理机制。
6、网关等可以分析请求处理结果
REST的缺点 1、真实系统中的资源非常复杂，很难清晰地进行资源的划分，对技术人员的业务和技术水平要求高。
2、不是所有的操作都能简单地对应到确定的HTTP谓词力
3、系统的进化可能会改变幂等性.
4、通过URL进行资源定位不符合中文用户的习惯
5、HTTP状态码个数有限。
6、有些环节会篡改非200响应码的响应报文
7、有的客户端不支持PUT、DELETE请求。
选择 1、REST是学术化的概念，仅供参考。为什么AWS、ES等比较RESTful。为什么阿里、腾讯等很多系统不RESTful?
2、根据公司情况，进行REST的选择和裁剪
Asp.NET Core Restful中如何传递参数 HTTP传递参数的三种方式 URL: 适合定位;长度限制
QueryString: 灵活，长度限制
请求报文体:灵活，长度不限制；不支持GET、Delete
三种方式的不同语义 URL: 资源定位
Querstring URL之外的额外数据
请求报文体: 供PUT、POST提供数据
实施指南 1、完全按照HTTP语义要求高
2、我的建议" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0bdfed371a3488301760f3adc50275e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T19:15:18+08:00" />
<meta property="article:modified_time" content="2024-01-05T19:15:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">杨中科 ASP.NETCore Rest</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Rest_0"></a>什么是Rest</h3> 
<h4><a id="RPC_1"></a>RPC</h4> 
<p>1、Web API两种风格: 面向过程(RPC) 、面向REST (REST)</p> 
<p>2、RPC:“控制器/操作方法“的形式把服务器端的代码当成方法去调用。把HTTP当成传输数据的通道，不关心HTTP谓词。通过QueryString请求报文体给服务器传递数据。状态码。比如/Persons/GetAll、/Persons/GetBvld?id=8./Persons/Update、/Persons/DeleteByld/8</p> 
<h4><a id="REST_6"></a>REST</h4> 
<p>REST: 按照HTTP的语义来使用HTTP协议<br> 1、URL用于资源的定位: /user/888、/user/888/orders)<br> 2、HTTP谓词: GET、POST (新增) 、PUT (整体更新)DELETE、PATCH (局部更新) 等<br> 3、什么是“幂等”，举例? DELETE（删除id=1的数据，多次删除都是一样的）、PUT、GET是幂等的POST不幂等（幂等：执行一次和执行多次的结果是一致的）<br> 4、GET的响应可以被缓存<br> 5、服务器端要通过状态码来反映资源获取的结果: 404、403(没有权限) 、201 (新增成功)</p> 
<p><img src="https://images2.imgbox.com/b1/09/YZ3XX4Lv_o.png" alt="在这里插入图片描述"><br> RPC:业务驱动，自然<br> REST: 要求开发人员对REST原则更了解、并且有更多的设计能力。</p> 
<p>没有绝对的好与坏，根据业务需求选择适合自己的方式。</p> 
<h3><a id="REST_20"></a>REST的优缺点</h3> 
<h4><a id="REST_22"></a>REST的优点</h4> 
<p>1、通过URL对资源定位，语义更清晰<br> 2、通过HTTP谓词表示不同的操作，接口自描<br> 3、可以对GET、PUT、DELETE请求进行重试<br> 4、可以用GET请求做缓存<br> 5、通过HTTP状态码反映服务器端的处理结果统一错误处理机制。<br> 6、网关等可以分析请求处理结果</p> 
<h4><a id="REST_30"></a>REST的缺点</h4> 
<p>1、真实系统中的资源非常复杂，很难清晰地进行资源的划分，对技术人员的业务和技术水平要求高。<br> 2、不是所有的操作都能简单地对应到确定的HTTP谓词力<br> 3、系统的进化可能会改变幂等性.<br> 4、通过URL进行资源定位不符合中文用户的习惯<br> 5、HTTP状态码个数有限。<br> 6、有些环节会篡改非200响应码的响应报文<br> 7、有的客户端不支持PUT、DELETE请求。</p> 
<h4><a id="_39"></a>选择</h4> 
<p>1、REST是学术化的概念，仅供参考。为什么AWS、ES等比较RESTful。为什么阿里、腾讯等很多系统不RESTful?<br> 2、根据公司情况，进行REST的选择和裁剪</p> 
<h3><a id="AspNET_Core_Restful_43"></a>Asp.NET Core Restful中如何传递参数</h3> 
<h4><a id="HTTP_44"></a>HTTP传递参数的三种方式</h4> 
<p>URL: 适合定位;长度限制<br> QueryString: 灵活，长度限制<br> 请求报文体:灵活，长度不限制；不支持GET、Delete</p> 
<h4><a id="_49"></a>三种方式的不同语义</h4> 
<p>URL: 资源定位<br> Querstring URL之外的额外数据<br> 请求报文体: 供PUT、POST提供数据</p> 
<h4><a id="_54"></a>实施指南</h4> 
<p>1、完全按照HTTP语义要求高<br> 2、我的建议<br> 1)对于保存、更新类的请求POST、PUT请求，把全部参数都放到请求报<br> 文体中;<br> <img src="https://images2.imgbox.com/e5/eb/xTYMLyW2_o.png" alt="在这里插入图片描述"></p> 
<pre><code>2) 对于DELETE请求，要传递的参数就是一个资源的id，因此把参数放到QueryString中即可
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/6f/ouDl2fXG_o.png" alt="在这里插入图片描述"></p> 
<pre><code>3) 对于GET请求，一般参数的内容都不会太长，因此统一通过QueryString传递参数就可以。对于极少数参数内容超过URL限制的请求由于GET、PUT请求都是幂等的，因此我们把请求改成通过PUT请求，然后通过报文体来传递参数。
</code></pre> 
<h3><a id="AspNET_Core_68"></a>Asp.NET Core如何返回错误码</h3> 
<h4><a id="_69"></a>状态码</h4> 
<p>1、REST:通过HTTP状态码返回服务器端的处理结果<br> 2、问题</p> 
<ol><li>HTTP状态码数量有限</li><li>HTTP的状态码并不适合用来表示业务层面的错误码它是一个用来表示技术层面信息的状态码。新增用户的操作中，如果服务器端要求Json格式，客户端提交XML服务器返回400是没问题的。但是如果用户名格式错误或者用户名重复，存在200派和400派</li></ol> 
<h4><a id="400_75"></a>400派观点</h4> 
<p>1、网关等可以监控HTTP状态码，如果接口频繁出现4xx1状态码，那么就说明客户端的代码不完善。<br> 2、很多的系统都是按照HTTP状态码的不同含义进行设计的。如果失败了服务器端返回的状态码还是200的话这会违背软件设计的初衷。</p> 
<h4><a id="200_79"></a>200派观点</h4> 
<p>网络的问题归网络、业务的问题归业务。业务错误不应该和技术错误混在一起。把系统日志和业务日志区分开。</p> 
<p>大企业也不统一<br> 百度: 200派<br> 谷歌: 400派<br> 同一家公司企业微信和微信小程序: 200派<br> 微信支付: 400派</p> 
<p>个人观点:400派<br> 1、对于数据库服务器连接失败、请求报文格式、服务器端异常等非业务错误，服务器端应该返回4xx、5xx等状态招<br> 2、对于业务层面的错误，比如用户不存在，我们要使用4xx等HTTP状态码返回。同样在响应报文体中给出详细的错误信息，比如(“code”:3,message”:”用户不存在”}。<br> 3、不仅要返回4xx的HTTP状态码，而且不要忘了通过响应报文体给出详细的错误信息。对于用户不存在，不仅要404，而且把响应报文体设置为(“code”:3,message”:”用户名已存在”]，这样能区分出来是哪里的问题</p> 
<h3><a id="ASPNET_CoreRest_94"></a>ASP.NET Core中的Rest落地指南</h3> 
<h4><a id="_95"></a>实现建议</h4> 
<p>1、使用RPC风格: Users/AddNew、Users/GetAll、Users/DeleteByld。<br> 2、对于可以缓存的操作，使用GET请求，对于幂等的更新操作，使用PUT请求，对于幂等的删除操作，使用DELETE请求，对于其他操作，统一使用POST请求。<br> 3、参数: 保存、更新类的请求使用POST、PUT请求，把全部参数都放到请求报文体中;对于GET和DELETE请求，把参数放到QueryString中。推荐尽量使用URL做资源定位。<br> 4、对于业务错误，服务器端返回合适的4XX状态码，不知道该选择哪个状态码就用400，同时，在报文体中通过code参数提供业务错误码以及错误消息。<br> 5、如果请求的处理执行成功，服务器端返回值为200的Http状态码，如果有需要返回给客户端的数据，则服务器端把这些数据放到响应报文体</p> 
<h4><a id="_102"></a>实现技术</h4> 
<p>1、控制器上[Route(“[controller]/[action]”)]<br> 2、强制要求控制器中不同的操作用不同的方法名2<br> 3、把[HttpGet]、[HttpPost]、[HttpDelete]、[HttpPut]等添加到对应的操作方法上。<br> 注意: 如果控制器中存在一个没有添加[HttpGet].[HttpPost]等的public方法，Swagger就会报错，可以用ApiExplorerSettings(lgnoreApi = true)]</p> 
<p><img src="https://images2.imgbox.com/aa/71/jksx0dIr_o.png" alt="在这里插入图片描述"><br> 运行结果:<br> <img src="https://images2.imgbox.com/a1/7a/3tOGAikd_o.png" alt="在这里插入图片描述"><br> 但是此时这个接口是可以直接调用的<br> <img src="https://images2.imgbox.com/c1/44/PcIJV0lq_o.png" alt="在这里插入图片描述"></p> 
<p>将方法改为private<br> <img src="https://images2.imgbox.com/18/f0/LJFGz7yz_o.png" alt="在这里插入图片描述"><br> 运行结果：<br> <img src="https://images2.imgbox.com/48/eb/lU7VuIg4_o.png" alt="在这里插入图片描述"><br> 或者加上特性<br> <img src="https://images2.imgbox.com/7d/eb/Hgwk2hPj_o.png" alt="在这里插入图片描述"><br> 运行结果:<br> <img src="https://images2.imgbox.com/3e/0b/M3vhpd4C_o.png" alt="在这里插入图片描述"><br> 测试：<br> <img src="https://images2.imgbox.com/94/2b/RKB3r0a7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/78/29/T7YkGhPu_o.png" alt="在这里插入图片描述"><br> 新建Person类<br> <img src="https://images2.imgbox.com/ed/b7/NhEIhf5s_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/67/55/iKJ1ZDxg_o.png" alt="在这里插入图片描述"><br> 编写控制类<br> <img src="https://images2.imgbox.com/a5/83/UlmPfsqg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d6/73/whaoR8Ti_o.png" alt="在这里插入图片描述"><br> [HttpGet]<br> <img src="https://images2.imgbox.com/18/27/hcfVAHNo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4d/7a/1hzH4yix_o.png" alt="在这里插入图片描述"><br> 运行：<br> <img src="https://images2.imgbox.com/6c/b8/NGKdEV47_o.png" alt="在这里插入图片描述"><br> GetAll<br> <img src="https://images2.imgbox.com/c8/8b/Yk9Ui5Fj_o.png" alt="在这里插入图片描述"><br> getById<br> <img src="https://images2.imgbox.com/2c/2d/3YsFTJ4e_o.png" alt="在这里插入图片描述"></p> 
<p>Post addNew<img src="https://images2.imgbox.com/67/6d/VgewaC2L_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c2b6218802db16dce0810490868c84e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu docker离线安装docker（.deb包方式）（成功）（附卸载方法）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b0e5339150c978f0a774831fc4035e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024打开怎样的AI时空之门？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>