<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;——左值、右值、左值引用、右值引用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;——左值、右值、左值引用、右值引用" />
<meta property="og:description" content="1、左值和右值 左值（left-values），缩写：lvalues
右值（right-values），缩写：rvalues
直接上官网查，我一向倡导自己去懂得原理，而原理都是老外写的，当然我只是针对c&#43;&#43;编程语言这样说。
https://msdn.microsoft.com/en-us/library/f90831hc.aspx
翻译：所有的c&#43;&#43;表达，不是左值就是右值。
lvalues是指存在于单个表达式之外的对象。你可以把左值当成有名字的对象。
所有的变量，包括常变量，都是左值。
rvalues是一个暂时存在的值存在于单个表达式之内的对象。
有点拗口（难理解），通俗来说就是，左值的生存期不只是这句话，后面还能用到它。
而右值呢，出了这句话就挂了，所以也叫（将亡值）。
它举了一个栗子：
#include &lt;iostream&gt; using namespace std; int main() { int x = 3 &#43; 4; cout &lt;&lt; x &lt;&lt; endl; } 在以上实例中，很显然，x是左值，3 &#43; 4是右值。
它又举了一个栗子，来说明错误的使用和正确的使用
// lvalues_and_rvalues2.cpp int main() { int i, j, *p; // 正确的使用: 变量是左值 i = 7; // 错误的使用: 左边的操作 必须是 左值 (C2106) 7 = i; // C2106 j * 4 = 7; // C2106 // 正确的使用: 被间接引用的指针是左值 *p = i; const int ci = 7; // 错误的使用: 左边的操作 是 常量左值 (C3892) ci = 9; // C3892 // 正确的使用: 条件操作 返回了左值 ((i &lt; 3) ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/c4e9f0092d2737214e0518fd88020d3b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-18T18:17:39+08:00" />
<meta property="article:modified_time" content="2018-10-18T18:17:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;——左值、右值、左值引用、右值引用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1、左值和右值</h4> 
<p>左值（left-values），缩写：lvalues</p> 
<p>右值（right-values），缩写：rvalues</p> 
<p>直接上官网查，我一向倡导自己去懂得原理，而原理都是老外写的，当然我只是针对c++编程语言这样说。</p> 
<p><a href="https://msdn.microsoft.com/en-us/library/f90831hc.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/f90831hc.aspx</a></p> 
<p>翻译：所有的c++表达，不是左值就是右值。</p> 
<p><strong>lvalues</strong>是指存在于单个表达式之外的对象。你可以把左值当成有名字的对象。</p> 
<p>所有的变量，包括常变量，都是左值。</p> 
<p><strong>rvalues</strong>是一个暂时存在的值存在于单个表达式之内的对象。</p> 
<p>有点拗口（难理解），通俗来说就是，左值的生存期不只是这句话，后面还能用到它。</p> 
<p>而右值呢，出了这句话就挂了，所以也叫（将亡值）。</p> 
<p>它举了一个栗子：</p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;iostream&gt;  
using namespace std;  
int main()  
{  
   int x = 3 + 4;  
   cout &lt;&lt; x &lt;&lt; endl;  
}  
</code></pre> 
<p>在以上实例中，很显然，x是左值，3 + 4是右值。</p> 
<p>它又举了一个栗子，来说明错误的使用和正确的使用</p> 
<pre class="has"><code class="hljs language-cpp">// lvalues_and_rvalues2.cpp  
int main()  
{  
   int i, j, *p;  
  
   // 正确的使用: 变量是左值 
   i = 7;  
  
   // 错误的使用: 左边的操作 必须是 左值 (C2106)
   7 = i; // C2106  
   j * 4 = 7; // C2106  
  
   // 正确的使用: 被间接引用的指针是左值
   *p = i;   
  
   const int ci = 7;  
   // 错误的使用: 左边的操作 是 常量左值 (C3892)
   ci = 9; // C3892 
  
   // 正确的使用: 条件操作 返回了左值
   ((i &lt; 3) ? i : j) = 7;  
}  
</code></pre> 
<h4>2、左值引用、右值引用</h4> 
<p><strong>左值引用：</strong>参考说明书《Lvalue Reference Declarator: &amp;》，网站如下：</p> 
<p><a href="https://msdn.microsoft.com/en-us/library/w7049scy.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/w7049scy.aspx</a></p> 
<p>使用语法：类型 + &amp;（引用符） + 表达式</p> 
<pre class="has"><code class="hljs language-cpp">type-id &amp; cast-expression </code></pre> 
<p>翻译：</p> 
<p>你可以把左值引用当成对象的另一个名字，lvalue引用声明由一个可选的说明符列表和一个引用声明符组成。</p> 
<p>引用必须初始化，而且不能改变。</p> 
<p>一个对象的地址可以 转化成 一种指定类型的指针 或者 转化成 一个 相似类型的引用。意义是相同的。</p> 
<p>demo:</p> 
<pre class="has"><code class="hljs language-cpp">char c_val = 'c';
char *ptr = &amp;c_val;
char &amp;r_val = c_val;</code></pre> 
<p>不要混淆 取地址 和 引用，当&amp;说明符前面带有类型声明，则是引用，否则就是取地址。</p> 
<p>通俗来说 &amp;在 ”=” 号左边的是引用，右边的是取地址。 </p> 
<p><strong>右值引用：</strong>参考说明书《Rvalue Reference Declarator: &amp;&amp;》，网站如下：</p> 
<p><a href="https://msdn.microsoft.com/en-us/library/dd293668.aspx" rel="nofollow">https://msdn.microsoft.com/en-us/library/dd293668.aspx</a></p> 
<p>使用语法：类型 + &amp;&amp; + 表达式</p> 
<pre class="has"><code class="hljs language-cpp">type-id &amp;&amp; cast-expression  </code></pre> 
<p>翻译：</p> 
<p><strong>Move Semantics：移动语义</strong></p> 
<p>右值引用使您能够区分左值和右值。Lvalue引用和rvalue引用在语法和语义上是相似的。</p> 
<p>右值引用支持移动语义的实现，可以显著提升应用程序的性能。移动语义允许您编写将资源(例如动态分配的内存)从一个对象传输到另一个对象的代码，移动语义行之有效，因为它允许从程序中其他地方无法引用的临时对象转移资源。</p> 
<p>为了实现移动语义，你在类中提供一个动态构造，和可选择的动态赋值运算符(<code>operator=</code>)。拷贝和赋值操作的资源是右值的可以自动调用移动语义。不像缺省的拷贝构造，编译器并不提供缺省的动态构造。</p> 
<p>demo:</p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;iostream&gt;  
#include &lt;string&gt;  
using namespace std;  
  
int main()  
{  
   string s = string("h") + "e" + "ll" + "o";  
   cout &lt;&lt; s &lt;&lt; endl;  
}  </code></pre> 
<p>在Visual C++ 2010之前，每个调用 “+”运算符会分配和返回一个新的临时的string对象，</p> 
<p>“+”运算符不能从一个string扩展到另一个，因为它不知道string是左值还是右值。如果源字符串都是lvalues，那么它们可能在程序的其他地方被引用，因此不能被修改。通过使用右值引用“+”运算符能够修改那些不能在程序中别处引用的右值，所以现在“+”运算符可以有一个string扩展到另一个。这可以显著减少字符串类必须执行的动态内存分配的数量。</p> 
<p>为了更好地理解移动语义，考虑向向量对象插入一个元素的例子。如果超出了vector对象的容量，vector对象必须为其元素重新分配内存，然后将每个元素复制到另一个内存位置，以便为插入的元素腾出空间。当插入操作复制一个元素时，它创建一个新元素，调用copy构造函数将数据从前一个元素复制到新元素，然后销毁前一个元素。移动语义允许您直接移动对象，而不必执行昂贵的内存分配和复制操作。</p> 
<p><strong>Perfect Forwarding：完美转发</strong></p> 
<p>完美的转发减少了重载函数 避免了转发的问题。转发的问题出现在你写通用函数将引用作为参数，将这些参数由函数调用的时候。</p> 
<p>举个例子，如果通用函数将 type const T&amp;作为参数，那么调用函数不能修改参数的值。</p> 
<p>如果通用函数 将 type T&amp;作为参数，那么当参数是右值的时候，函数不能调用。</p> 
<p>通常来说，为了解决上述的问题，你需要提供重载函数，既要有type const T&amp;参数的函数，也要有type T&amp;参数的函数。</p> 
<p>结果呢，重载函数的数量随着参数数量呈指数递增。而右值引用能够使你只用一个函数就能适用于任意数量的参数。</p> 
<p>原先的做法如下：</p> 
<p>先写出所有适用的通用函数</p> 
<pre class="has"><code class="hljs language-cpp">struct W  
{  
   W(int&amp;, int&amp;) {}  
};  
  
struct X  
{  
   X(const int&amp;, int&amp;) {}  
};  
  
struct Y  
{  
   Y(int&amp;, const int&amp;) {}  
};  
  
struct Z  
{  
   Z(const int&amp;, const int&amp;) {}  
};  
</code></pre> 
<p>再将带有不同类型的参数的函数用模板结合起来</p> 
<pre class="has"><code class="hljs language-cpp">template &lt;typename T, typename A1, typename A2&gt;  
T* factory(A1&amp; a1, A2&amp; a2)  
{  
   return new T(a1, a2);  
}  </code></pre> 
<p>调用：需要根据适用的类型用相应的指针对接。</p> 
<p>当调用的是左值时</p> 
<pre class="has"><code class="hljs language-cpp">int a = 4, b = 5;  
W* pw = factory&lt;W&gt;(a, b);  
</code></pre> 
<p>当调用的是右值时。但是，下面的示例中没有包含对工厂函数的有效调用，因为工厂将可修改的lvalue引用作为其参数，但是它是通过使用右值调用的:</p> 
<p>这里要注意的是const int &amp;是lvalue 而不是 rvalue</p> 
<p>而2是rvalue，函数会编译不过。</p> 
<pre class="has"><code class="hljs language-cpp">Z* pz = factory&lt;Z&gt;(2, 2);  </code></pre> 
<p>为了解决这类问题，需要将模板函数修改成如下形式，右值引用可以适用const T&amp; 和 T&amp;形式的参数：</p> 
<pre class="has"><code class="hljs language-cpp">template &lt;typename T, typename A1, typename A2&gt;  
T* factory(A1&amp;&amp; a1, A2&amp;&amp; a2)  
{  
   return new T(std::forward&lt;A1&gt;(a1), std::forward&lt;A2&gt;(a2));  
}  </code></pre> 
<p>经过上述修改，均可以调用，如下图代码所示： </p> 
<pre class="has"><code class="hljs language-cpp">int main()  
{  
   int a = 4, b = 5;  
   W* pw = factory&lt;W&gt;(a, b);  
   X* px = factory&lt;X&gt;(2, b);  
   Y* py = factory&lt;Y&gt;(a, 2);  
   Z* pz = factory&lt;Z&gt;(2, 2);  
  
   delete pw;  
   delete px;  
   delete py;  
   delete pz;  
} </code></pre> 
<p>除了上述所示的右值引用，还有额外的强大功能：</p> 
<p><strong>Additional Properties of Rvalue References</strong></p> 
<p>1、可以通过重载函数，调用左值或右值参数。具体来讲，你可以通过重载区分出无法修改的对象（const T&amp;）：左值和可修改的临时对象（T &amp;）：右值。</p> 
<p>demo：</p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;iostream&gt;  
using namespace std;  
  
// A class that contains a memory resource.  
class MemoryBlock  
{  
   // TODO: Add resources for the class here.  
};  
  
void f(const MemoryBlock&amp;)  
{  
   cout &lt;&lt; "In f(const MemoryBlock&amp;). This version cannot modify the parameter." &lt;&lt; endl;  
}  
  
void f(MemoryBlock&amp;&amp;)  
{  
   cout &lt;&lt; "In f(MemoryBlock&amp;&amp;). This version can modify the parameter." &lt;&lt; endl;  
}  
  
int main()  
{  
   MemoryBlock block;  
   f(block);          //左值引用调用
   f(MemoryBlock());  //右值引用调用
}  
</code></pre> 
<p>调用结果如下： </p> 
<pre class="has"><code class="hljs language-cpp">In f(const MemoryBlock&amp;). This version cannot modify the parameter.  
In f(MemoryBlock&amp;&amp;). This version can modify the parameter. </code></pre> 
<p>2、再看下一个demo：与上述demo不同的是</p> 
<p>f函数中参数命名了block，值得一提的是在右值引用中，若参数带有名字则视为左值，因为该参数可以在别处调用。</p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;iostream&gt;  
using namespace std;  
  
// A class that contains a memory resource.  
class MemoryBlock  
{  
   // TODO: Add resources for the class here.  
};  
  
void g(const MemoryBlock&amp;)   
{  
   cout &lt;&lt; "In g(const MemoryBlock&amp;)." &lt;&lt; endl;  
}  
  
void g(MemoryBlock&amp;&amp;)   
{  
   cout &lt;&lt; "In g(MemoryBlock&amp;&amp;)." &lt;&lt; endl;  
}  
  
MemoryBlock&amp;&amp; f(MemoryBlock&amp;&amp; block)  
{  
   g(block);  
   return block;  
}  
  
int main()  
{  
   g(f(MemoryBlock()));  
}  
</code></pre> 
<p>调用结果如下：在这个例子中main函数传递了右值给了f函数，f函数将参数block视为了左值，调用了左值引用的函数g(const MemoryBlock&amp;)   ，接着返回一个右值对象，然后调用了右值引用函数g(MemoryBlock&amp;&amp;) 。</p> 
<pre class="has"><code class="hljs language-cpp">In g(const MemoryBlock&amp;).  
In g(MemoryBlock&amp;&amp;).  
</code></pre> 
<p>3、右值引用中还可以通过static_cast将左值转成右值，进行右值引用函数调用</p> 
<p>demo：</p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;iostream&gt;  
using namespace std;  
  
// A class that contains a memory resource.  
class MemoryBlock  
{  
   // TODO: Add resources for the class here.  
};  
  
void g(const MemoryBlock&amp;)   
{  
   cout &lt;&lt; "In g(const MemoryBlock&amp;)." &lt;&lt; endl;  
}  
  
void g(MemoryBlock&amp;&amp;)   
{  
   cout &lt;&lt; "In g(MemoryBlock&amp;&amp;)." &lt;&lt; endl;  
}  
  
int main()  
{  
   MemoryBlock block;  
   g(block);  
   g(static_cast&lt;MemoryBlock&amp;&amp;&gt;(block));  
}</code></pre> 
<p>调用结果如下：static_cast&lt;MemoryBlock&amp;&amp;&gt;(block)将block转成了右值。</p> 
<pre class="has"><code class="hljs language-cpp">In g(const MemoryBlock&amp;).  
In g(MemoryBlock&amp;&amp;).  </code></pre> 
<p>4、模板函数可以推断出模板参数类型，进而使用“<strong>引用折叠</strong>”规则</p> 
<pre class="has"><code class="hljs language-cpp">#include &lt;iostream&gt;  
#include &lt;string&gt;  
using namespace std;  

template&lt;typename T&gt; struct S;
template&lt;typename T&gt; struct S&lt;T&amp;&gt;
{
    static void print(T&amp; t)
    {
        cout &lt;&lt; "print&lt;T&amp;&gt;: " &lt;&lt; t &lt;&lt; endl;  
    }
};
template&lt;typename T&gt; struct S&lt;const T&amp;&gt; {  
   static void print(const T&amp; t)  
   {  
      cout &lt;&lt; "print&lt;const T&amp;&gt;: " &lt;&lt; t &lt;&lt; endl;  
   }  
};  
  
template&lt;typename T&gt; struct S&lt;T&amp;&amp;&gt; {  
   static void print(T&amp;&amp; t)  
   {  
      cout &lt;&lt; "print&lt;T&amp;&amp;&gt;: " &lt;&lt; t &lt;&lt; endl;  
   }  
};  
  
template&lt;typename T&gt; struct S&lt;const T&amp;&amp;&gt; {  
   static void print(const T&amp;&amp; t)  
   {  
      cout &lt;&lt; "print&lt;const T&amp;&amp;&gt;: " &lt;&lt; t &lt;&lt; endl;  
   }  
};  

template &lt;typename T&gt; void print_type_and_value(T&amp;&amp; t)   
{  
   S&lt;T&amp;&amp;&gt;::print(std::forward&lt;T&gt;(t));  
} 

const string fourth() { return string("fourth"); } //这个函数为了返回const string类型的 "fourth" 即const + 右值

int main()  
{  
   string s1("first");  //左值调用
   print_type_and_value(s1);   
  
   const string s2("second");  //const 左值
   print_type_and_value(s2);  
  
   print_type_and_value(string("third"));  //右值
  
   print_type_and_value(fourth());  //const 右值
}  
</code></pre> 
<p>调用结果：</p> 
<pre class="has"><code class="hljs language-cpp">print&lt;T&amp;&gt;: first  
print&lt;const T&amp;&gt;: second  
print&lt;T&amp;&amp;&gt;: third  
print&lt;const T&amp;&amp;&gt;: fourth  </code></pre> 
<p>查看一下引用折叠规则：</p> 
<table><thead><tr><th> </th><th> </th></tr></thead><tbody><tr><td>Expanded type</td><td>Collapsed type</td></tr><tr><td><code>T&amp; &amp;</code></td><td><code>T&amp;</code></td></tr><tr><td><code>T&amp; &amp;&amp;</code></td><td><code>T&amp;</code></td></tr><tr><td><code>T&amp;&amp; &amp;</code></td><td><code>T&amp;</code></td></tr><tr><td><code>T&amp;&amp; &amp;&amp;</code></td><td><code>T&amp;&amp;</code></td></tr></tbody></table> 
<p>对照代码：</p> 
<p>调用print_type_and_value(T&amp;&amp; t)</p> 
<p> </p> 
<p> 例如first 是左值引用 则把t 参数看成T&amp; 类型 </p> 
<p>即T变成 T&amp; 这里T 是 string</p> 
<p>则T 变成了 String&amp;</p> 
<p>即如下代码所示：</p> 
<pre class="has"><code class="hljs language-cpp">print_type_and_value&lt;string&amp;&gt;(string&amp; &amp;&amp; t) </code></pre> 
<p>forward的函数实现如下：将上述类型T&amp; 转发成 T&amp; &amp;&amp;</p> 
<pre class="has"><code class="hljs language-cpp">T&amp; &amp;&amp; forward(remove_reference&lt;T&amp;&gt;::type&amp; a) noexcept
{
  return static_cast&lt;T&amp; &amp;&amp;&gt;(a);
} </code></pre> 
<p>进而通过引用折叠规则（表的第二条）对应的Collapsed type变成 了 T&amp;即调用函数struct S&lt;T&amp;&gt;。</p> 
<p> </p> 
<h4><strong>总结：</strong></h4> 
<p>右值引用将左值与右值区分开来。它们可以帮助您通过消除不必要的内存分配和复制操作来提高应用程序的性能。它们还使您能够编写接受任意参数的函数的一个版本，并将其转发给另一个函数，就好像直接调用了另一个函数一样</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ef8c9a30534f97c408d1ad82258550f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">测试Web应用程序中的竞争条件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17a90a291a1444610e444368074d9cf7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">oracle 时间函数 TO_DATE</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>