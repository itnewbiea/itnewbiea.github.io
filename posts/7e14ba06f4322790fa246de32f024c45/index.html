<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PC端上拉加载 scroll 监听还是IntersectionObserve API? - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PC端上拉加载 scroll 监听还是IntersectionObserve API?" />
<meta property="og:description" content="如今阶段，相对于 uniApp、小程序，PC端如要实现上拉等类似功能并不是很灵活，最常见监听window scroll吗？此方法可以实现，但相对也有一定性能弊端、容错率、兼容等问题。
两者利弊 addEventListener scroll 优点：实时性 、特定阶段实现特定效果
缺点：性能问题、滚动灵敏度容错率、滚动处理复杂、触发次数过多
描述：首先监听 scroll 很灵活，可以随时随地在某个节段去做一些相应操作列如：dom切入，切出、过度等效果。但是 scroll 会一直存在，鼠标滚轮只要滑动，这个事件会一直触发，导致性能问题，浏览器之间也会存在灵敏度差异，其次计算到达底部会有容错率。
InterSectionObServe API 优点：性能优化、减少事件触发减少负担、交叉懒加载、简单易用
缺点：较低浏览器兼容问题、多目标复杂性、异步执行导致其余逻辑变故、代码量过多
描述：IntersectionObserver是JavaScript API，内部计算目标元素与视窗或祖先元素的交叉区域，提供高性能、简单接口，触发事件通知状态变化，依赖浏览器底层机制，内部优化减少不必要的计算及事件触发。
实现案列 addEventListener scroll 监听出现滚动条元素来实现。
需注意：确保监听的元素已出现滚动条，如果是浏览器出现并不是元素配合 overflow:auto 内部出现，被监听者也要相应变化，以免错误监听导致无任何效果。
// Vue3.0 &#43; ts // 挂载后执行 onMounted(() =&gt; { // 被监听者 let view = document.querySelector(&#34;.home&#34;) as HTMLDivElement; view.addEventListener(&#39;scroll&#39;, () =&gt; { // 限制滚动到底部时触发事件 // 此处到达底部计算会出现容错率,自行限制下执行次数,并在相应请求中恢复。 if( (view.scrollHeight - view.scrollTop) &lt;= view.offsetHeight ){ // 业务逻辑 //request axios ... } }) }) IntersectionObServe API new API 传入目标元素实现到底部，目标元素可以是一个或数组多个元素" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7e14ba06f4322790fa246de32f024c45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T10:27:18+08:00" />
<meta property="article:modified_time" content="2023-11-01T10:27:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PC端上拉加载 scroll 监听还是IntersectionObserve API?</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>如今阶段，相对于 uniApp、小程序，PC端如要实现上拉等类似功能并不是很灵活，最常见监听window scroll吗？此方法可以实现，但相对也有一定性能弊端、容错率、兼容等问题。</p> 
<p></p> 
<h3>两者利弊</h3> 
<h4><strong>addEventListener scroll</strong></h4> 
<p>优点：实时性 、特定阶段实现特定效果</p> 
<p>缺点：性能问题、滚动灵敏度容错率、滚动处理复杂、触发次数过多</p> 
<p>描述：首先监听 <strong>scroll </strong>很灵活，可以随时随地在某个节段去做一些相应操作列如：dom切入，切出、过度等效果。但是 <strong>scroll</strong> 会一直存在，鼠标滚轮只要滑动，这个事件会一直触发，导致性能问题，浏览器之间也会存在灵敏度差异，其次计算到达底部会有容错率。</p> 
<h4>InterSectionObServe API</h4> 
<p>优点：性能优化、减少事件触发减少负担、交叉懒加载、简单易用</p> 
<p>缺点：较低浏览器兼容问题、多目标复杂性、异步执行导致其余逻辑变故、代码量过多</p> 
<p>描述：IntersectionObserver是JavaScript API，内部计算目标元素与视窗或祖先元素的交叉区域，提供高性能、简单接口，触发事件通知状态变化，依赖浏览器底层机制，内部优化减少不必要的计算及事件触发。</p> 
<p></p> 
<h3>实现案列</h3> 
<h4><strong>addEventListener scroll</strong></h4> 
<p>监听出现滚动条元素来实现。</p> 
<p><span style="color:#fe2c24;">需注意</span><span style="color:#0d0016;">：确保监听的元素已出现滚动条，如果是浏览器出现并不是元素配合 overflow:auto 内部出现，被监听者也要相应变化，以免错误监听导致无任何效果。</span></p> 
<pre><code class="language-javascript">// Vue3.0 + ts 
// 挂载后执行
onMounted(() =&gt; {
    // 被监听者
    let view = document.querySelector(".home") as HTMLDivElement;
    view.addEventListener('scroll', () =&gt; {
        // 限制滚动到底部时触发事件
        // 此处到达底部计算会出现容错率,自行限制下执行次数,并在相应请求中恢复。
        if(
            (view.scrollHeight - view.scrollTop) &lt;= view.offsetHeight
        ){
            // 业务逻辑
            //request axios ...
        }    
    })
})</code></pre> 
<h4>IntersectionObServe API</h4> 
<p>new API 传入目标元素实现到底部，目标元素可以是一个或数组多个元素</p> 
<pre><code class="language-javascript">
// 挂载后执行
onMounted(() =&gt; {
    // 目标元素集
    let view = document.getElementsByclassName('XXX') as HTMLDivElement;
    // 底部元素
    let finalDom = view[view.length - 1];
    // 初始化构造函数
    const server = new IntersectionObserver( callback: (entries) 一 
    // isIntersecting 是否已到达目标元素
    if (entries[0].isIntersecting) {
        // request 
        // 取消追踪再进行追踪 此处逻辑自行编写
        server.unobserve(finalDom);
    }
    // 追踪目标元素
    server.observe(finalDom);
})</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75a50d40af20bbbe4d1614776136e863/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">突破界限！揭秘超强搜索技巧，助你成为顶尖搜寻高手！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24b3d8f39e1541cfbfa79c34dc0d7360/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">降本/升级成主旋律，智能座舱迈入发展“新纪元”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>