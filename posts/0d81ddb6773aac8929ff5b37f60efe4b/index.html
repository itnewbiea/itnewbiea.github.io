<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeRTOS任务通知 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeRTOS任务通知" />
<meta property="og:description" content="FreeRTOS 内核 V8.2.0 版本发布的时候，FreeRTOS 新增了任务通知这个功能，任务通知也
是用于任务间进行同步和通讯的一种机制，但是相对于前面章节介绍的队列、事件标志组和信
号量等而言，任务通知在内存占用和效率方面都有很大的优势。
一、 FreeRTOS 任务通知简介 在 FreeRTOS 中，每一个任务都有两个用于任务通知功能的数组，分别为任务通知数组和
任务通知状态数组。其中任务通知数组中的每一个元素都是一个 32 位无符号类型的通知值；而
任务通知状态数组中的元素则表示与之对应的任务通知的状态。任务通知数组中的 32 位无符号通知值，用于任务到任务或中断到任务发送通知的“媒介”。当通知值为 0 时，表示没有任务通知；当通知值不为 0 时，表示有任务通知，并且通知值就是通知的内容。
任务通知状态数组中的元素，用于标记任务通知数组中通知的状态，任务通知有三种状态，分别为未等待通知状态、等待通知状态和等待接收通知状态。其中未等待通知状态为任务通知
的复位状态；当任务在没有通知的时候接收通知时，在任务阻塞等待任务通知的这段时间内，
任务所等待的任务通知就处于等待通知状态；当有其他任务向任务发送通知，但任务还未接收
这一通知的这段期间内，任务通知就处于等待接收通知状态。任务通知功能所使用到的任务通知数组和任务通知状态数组为任务控制块中的成员变量，因此任务通知的传输是直接传出到任务中的，不同通过任务的通讯对象（队列、事件标志组和信号量就属于通讯对象）这个间接的方式。
二、任务通知的优势 使用任务通知向任务发送事件或数据比使用队列、事件标志组或信号量快得多；并且使用
任务通知代替队列、事件标志组或信号量，可以节省大量的内存，这是因为每个通讯对象在使
用之前都需要被创建，而任务通知功能中的每个通知只需要在每个任务中占用固定的 5 字节内
存。
三、任务通知的缺点 虽然任务通知功能相比通讯对象，有着更快、占用内存少的优点，但是任务通知功能并不
能适用于所有情况，例如以下列出的几种情况：
1. 发送事件或数据到中断
通讯对象可以发送事件或数据从中断到任务，或从任务到中断，但是由于任务通知依赖于
任务控制块中的两个成员变量，并且中断不是任务，因此任务通知功能并不适用于从任务往中
断发送事件或数据的这种情况，但是任务通知功能可以在任务之间或从中断到任务发送事件或
数据。
2. 存在多个接收任务
通讯对象可以被已知通讯对象句柄的任意多个任务或中断访问（发送或接收），但任务通知
是直接发送事件或数据到指定接收任务的，因传输的事件或数据只能由接收任务处理。然而在
实际中很少受到这种情况的限制，因为，虽然多个任务和中断发送事件或数据到一个通讯对象
是很常见的，但很少出现多个任务或中断接收同一个通讯对象的情况。
3. 缓冲多个 数据项
通讯对象中的队列是可以一次性保存多个已经被发送到队列，但还未被接收的事件或数据
的，也就是说，通讯对象有着一定的缓冲多个数据的能力，但是任务通知是通过更新任务通知
值来发送事件或数据的，一个任务通知值只能保存一次。
4. 广播到多个任务
通讯对象中的事件标志组是可以将一个事件同时发送到多个任务中的，但任务通知只能是
被指定的一个接收任务接收并处理。
5. 阻塞等待接收任务
当通讯对象处于暂时无法写入的状态（例如队列已满，此时无法再向队列写入消息）时，
发送任务是可以选择阻塞等待接收任务接收，但是任务因尝试发送任务通知到已有任务通知但
还未处理的任务而进行阻塞等待的。但是任务通知也很少在实际情况中收到这种情况的限制。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0d81ddb6773aac8929ff5b37f60efe4b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T15:12:44+08:00" />
<meta property="article:modified_time" content="2024-01-03T15:12:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeRTOS任务通知</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>FreeRTOS 内核 V8.2.0 版本发布的时候，FreeRTOS 新增了任务通知这个功能，任务通知也<br> 是用于任务间进行同步和通讯的一种机制，但是相对于前面章节介绍的队列、事件标志组和信<br> 号量等而言，任务通知在内存占用和效率方面都有很大的优势。</p> 
<h2>一、 FreeRTOS  任务通知简介</h2> 
<p>        在 FreeRTOS 中，<strong>每一个任务都有两个用于任务通知功能的数组</strong>，分别为<strong>任务通知数组和<br> 任务通知状态数组</strong>。其中任务通知数组中的每一个元素都是一个 32 位无符号类型的通知值；而<br> 任务通知状态数组中的元素则表示与之对应的任务通知的状态。任务通知数组中的 32 位无符号通知值，用于任务到任务或中断到任务发送通知的“媒介”。<strong>当通知值为 0 时，表示没有任务通知；当通知值不为 0 时，表示有任务通知，并且通知值就是通知的内容。</strong></p> 
<p><strong>        </strong>任务通知状态数组中的元素，用于标记任务通知数组中通知的状态，<strong>任务通知有三种状态，分别为未等待通知状态、等待通知状态和等待接收通知状态</strong>。其中未等待通知状态为任务通知<br> 的复位状态；当任务在没有通知的时候接收通知时，在任务阻塞等待任务通知的这段时间内，<br> 任务所等待的任务通知就处于等待通知状态；当有其他任务向任务发送通知，但任务还未接收<br> 这一通知的这段期间内，任务通知就处于等待接收通知状态。任务通知功能所使用到的任务通知数组和任务通知状态数组为任务控制块中的成员变量，因此任务通知的传输是直接传出到任务中的，不同通过任务的通讯对象（队列、事件标志组和信号量就属于通讯对象）这个间接的方式。</p> 
<p></p> 
<h2>二、任务通知的优势</h2> 
<p>使用任务通知向任务发送事件或数据比使用队列、事件标志组或信号量快得多；并且使用<br> 任务通知代替队列、事件标志组或信号量，可以节省大量的内存，这是因为每个通讯对象在使<br> 用之前都需要被创建，而任务通知功能中的每个通知只需要在每个任务中占用固定的 5 字节内<br> 存。</p> 
<p></p> 
<h2>三、任务通知的缺点</h2> 
<p>虽然任务通知功能相比通讯对象，有着更快、占用内存少的优点，但是任务通知功能并不<br> 能适用于所有情况，例如以下列出的几种情况：<br> 1.  发送事件或数据到中断<br> 通讯对象可以发送事件或数据从中断到任务，或从任务到中断，但是由于任务通知依赖于<br> 任务控制块中的两个成员变量，并且中断不是任务，因此任务通知功能并不适用于从任务往中<br> 断发送事件或数据的这种情况，但是任务通知功能可以在任务之间或从中断到任务发送事件或<br> 数据。<br> 2.  存在多个接收任务<br> 通讯对象可以被已知通讯对象句柄的任意多个任务或中断访问（发送或接收），但任务通知<br> 是直接发送事件或数据到指定接收任务的，因传输的事件或数据只能由接收任务处理。然而在<br> 实际中很少受到这种情况的限制，因为，虽然多个任务和中断发送事件或数据到一个通讯对象<br> 是很常见的，但很少出现多个任务或中断接收同一个通讯对象的情况。<br> 3.  缓冲多个 数据项<br> 通讯对象中的队列是可以一次性保存多个已经被发送到队列，但还未被接收的事件或数据<br> 的，也就是说，通讯对象有着一定的缓冲多个数据的能力，但是任务通知是通过更新任务通知<br> 值来发送事件或数据的，一个任务通知值只能保存一次。<br> 4.  广播到多个任务<br> 通讯对象中的事件标志组是可以将一个事件同时发送到多个任务中的，但任务通知只能是<br> 被指定的一个接收任务接收并处理。<br> 5.  阻塞等待接收任务<br> 当通讯对象处于暂时无法写入的状态（例如队列已满，此时无法再向队列写入消息）时，<br> 发送任务是可以选择阻塞等待接收任务接收，但是任务因尝试发送任务通知到已有任务通知但<br> 还未处理的任务而进行阻塞等待的。但是任务通知也很少在实际情况中收到这种情况的限制。</p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dd5c7ecedfba15d12f8379d6586754c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[Java]判断一个矩阵是另一个矩阵的子矩阵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b36e81d5ec105be0722ecd07fe0a0cc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Jvm垃圾收集器系列之Parallel Scavenge收集器（个人见解仅供参考）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>