<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于OpenCV和VTK的冠脉三维重建 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于OpenCV和VTK的冠脉三维重建" />
<meta property="og:description" content="冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。
具体文献可以参考：
1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.
2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.
3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献
这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。
以下为其中的一个实验所给出的数据，两幅不同角度的图片为。
图A 图B
图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。
有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。
匹配的结果如下：
上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。
以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）
/*-----Editored by HuangWang-2017年2月21日-----*/ /*-----功能描述：读取手工匹配的两幅冠脉造影的二维匹配点坐标,*/ /*-----利用冠脉造影算法进行三维点重建，并在VTK中使用大小不一的圆柱管道进行重建-----*/ /*-----程序员专用分割线-----*/ //包含C&#43;&#43;标准输入输出头文件，用到的OpenCV类以及VTK类的头文件 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;math.h&gt; #include &lt;vector&gt; #include &lt;vtkActor.h&gt; #include &lt;vtkCamera.h&gt; #include &lt;vtkCellArray.h&gt; #include &lt;vtkPoints.h&gt; #include &lt;vtkPolyData.h&gt; #include &lt;vtkPolyDataMapper.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkProperty." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/daa2239551d2dda4e08a4e2dda15a87d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-25T09:02:51+08:00" />
<meta property="article:modified_time" content="2017-05-25T09:02:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于OpenCV和VTK的冠脉三维重建</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>    冠脉三维重建就是从两幅不同角度拍摄的冠脉医学图片根据相机参数(角度)重建出原有的三维冠脉形态。</p> 
<p>    具体文献可以参考：</p> 
<p>      1.黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003.</p> 
<p>      2.王国铸. 单臂冠脉造影三维重建与定量分析[D]. 华中科技大学, 2012.</p> 
<p>      3.郝培远. 冠脉造影三维重建定量分析(QCA)及最佳投照角度的研究[D]. 南方医科大学, 2011.等文献</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>这里以黄家祥这篇文章的数据作为例子，具体的冠脉三维重建步骤可见这篇文章黄家祥. 冠状动脉树三维骨架重建方法的研究[D]. 天津大学, 2003。</p> 
<p>以下为其中的一个实验所给出的数据，两幅不同角度的图片为。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/d9/8f/o7FI1Cqz_o.jpg"><img alt="" class="has" src="https://images2.imgbox.com/50/56/I6TMJmHr_o.jpg"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>         图A                               图B</p> 
<p> </p> 
<p> </p> 
<p><span style="color:#555555;">图A和图B的相机参数分别为RAO 0，CAUD35和LAO 80，CRAN15。</span></p> 
<p> </p> 
<p> </p> 
<p><span style="color:#555555;"><img alt="" class="has" src="https://images2.imgbox.com/aa/19/nY3s3Ymh_o.jpg"></span></p> 
<p> </p> 
<p> </p> 
<p><span style="color:#555555;"><span style="color:#555555;">有了这些参数，我们需要提取冠脉骨架线，以及做两幅骨架线上特征点的匹配，骨架段的匹配，一般的特征点的匹配方法都采用外极线匹配，但是之前我写了外极线匹配然后看重建出来的三维点效果并不是很好，所以这里还是使用了原始的手动的进行两幅图片上的特征点匹配。</span></span></p> 
<p> </p> 
<p>    <span style="color:#555555;">匹配的结果如下：</span></p> 
<p><span style="color:#555555;"><img alt="" class="has" src="https://images2.imgbox.com/9d/0a/qSSKMM8c_o.jpg"></span></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p><span style="color:#555555;"><span style="color:#555555;">上图中的ImageA2.txt和ImageB2.txt作为A图和B图上对应的二维点坐标，之后就是根据这些点坐标进行矩阵运算（三维点重建算法）,从而得到在三维空间中这些点的坐标，在得到三维空间中点的坐标之后，就可以将点连接起来进行三维可视化，这里的可视化工具为VTK，点与点之间的连接进行了样条插值函数，并且生成圆柱体管道来模拟冠脉。而OpenCV主要应用于之间复杂的矩阵运算。</span></span></p> 
<p> </p> 
<p> </p> 
<p><span style="color:#555555;"><span style="color:#555555;"><span style="color:#555555;">以下为自己写的程序源码（还有个外极线匹配的版本，因为效果不好，这里就不进行贴出了）</span></span></span></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<pre class="has"><code class="language-cpp">/*-----Editored by HuangWang-2017年2月21日-----*/
/*-----功能描述：读取手工匹配的两幅冠脉造影的二维匹配点坐标,*/
/*-----利用冠脉造影算法进行三维点重建，并在VTK中使用大小不一的圆柱管道进行重建-----*/
/*-----程序员专用分割线-----*/

//包含C++标准输入输出头文件，用到的OpenCV类以及VTK类的头文件
#include &lt;iostream&gt; 
#include &lt;fstream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/core/core.hpp&gt; 
#include&lt;opencv2/highgui/highgui.hpp&gt; 
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
#include &lt;vtkActor.h&gt;
#include &lt;vtkCamera.h&gt;
#include &lt;vtkCellArray.h&gt;
#include &lt;vtkPoints.h&gt;
#include &lt;vtkPolyData.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkRenderWindow.h&gt;
#include &lt;vtkRenderWindowInteractor.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkProperty.h&gt;
#include &lt;vtkTubeFilter.h&gt;
#include &lt;vtkParametricSpline.h&gt;
#include &lt;vtkParametricFunctionSource.h&gt;
#include &lt;vtkSmartPointer.h&gt;

using namespace cv; //使用OpenCV命名空间
using namespace std;//使用C++命名空间

#define  PI 3.14159265358979323846 //宏定义圆周率PI

typedef struct My_Scalefactor//定义缩放因子结构体
{
	double IamgeAXfactor;//ImageA上二维点X坐标除以D1
	double ImageAYfactor;//ImageA上二维点Y坐标除以D1
	double ImageBXfactor;//ImageA上二维点X坐标除以D2
	double ImageBYfactor;//ImageA上二维点X坐标除以D2
};
typedef struct My2dPoint//定义自己的二维坐标点结构体
{
	double x;
	double y;
};
typedef struct My3dPoint//定义自己的三维坐标点结构体
{
	double x;
	double y;
	double z;
};

void InitMat(Mat &amp;m,double *num)//用一维数组初始化OpenCV矩阵Mat对象
{
	for (int i=0;i&lt;m.rows;i++)
	{
		for (int j=0;j&lt;m.cols;j++)
		{
			m.at&lt;double&gt;(i,j)=*(num+i*m.cols+j);
		}
	}
}

Mat GenerateRymat(double jiaodu)//构造Ry矩阵OpenCV矩阵Mat对象,参数角度为角度，直接返回一个Mat对象
{
	double m[]={cos(jiaodu/180*PI),0,-sin(jiaodu/180*PI),	
		0,1,0,
		sin(jiaodu/180*PI),0,cos(jiaodu/180*PI)
	};
	Mat Mtemp(3,3,CV_64F);
	InitMat(Mtemp,m);
	return Mtemp;
}

Mat GenerateRxmat(double jiaodu)//构造Rx矩阵OpenCV矩阵Mat对象,参数角度为角度,直接返回一个Mat对象
{
	double m[]={1,0,0,
		0,cos(jiaodu/180*PI),sin(jiaodu/180*PI),
		0,-sin(jiaodu/180*PI),cos(jiaodu/180*PI)
	};
	Mat Mtemp(3,3,CV_64F);
	InitMat(Mtemp,m);
	return Mtemp;
}

float ExtractMatIJValue(Mat &amp;M,int i,int j)//提取Mat对象第i行第j列的数值,M为Mat对象，ij为行列值
{
	return M.at&lt;double&gt;(i,j);
}



Mat Generate3DAmat(Mat &amp;M,My_Scalefactor &amp; myfactor)//生成最后求三维点的A矩阵，M为Mat类对象,为先求出的R矩阵，My_Scalefactor为struct
{
	Mat Mattemp(4,3,CV_64F);
	Mattemp.at&lt;double&gt;(0,0)=1;
	Mattemp.at&lt;double&gt;(0,1)=0.0;
	Mattemp.at&lt;double&gt;(0,2)=-myfactor.IamgeAXfactor;
	Mattemp.at&lt;double&gt;(1,0)=0;
	Mattemp.at&lt;double&gt;(1,1)=1;
	Mattemp.at&lt;double&gt;(1,2)=-myfactor.ImageAYfactor;
	Mattemp.at&lt;double&gt;(2,0)=ExtractMatIJValue(M,0,0)-(ExtractMatIJValue(M,2,0)

*myfactor.ImageBXfactor);
	Mattemp.at&lt;double&gt;(2,1)=ExtractMatIJValue(M,0,1)-(ExtractMatIJValue(M,2,1)

*myfactor.ImageBXfactor);
	Mattemp.at&lt;double&gt;(2,2)=ExtractMatIJValue(M,0,2)-(ExtractMatIJValue(M,2,2)

*myfactor.ImageBXfactor);
	Mattemp.at&lt;double&gt;(3,0)=ExtractMatIJValue(M,1,0)-(ExtractMatIJValue(M,2,0)

*myfactor.ImageBYfactor);
	Mattemp.at&lt;double&gt;(3,1)=ExtractMatIJValue(M,1,1)-(ExtractMatIJValue(M,2,1)

*myfactor.ImageBYfactor);
	Mattemp.at&lt;double&gt;(3,2)=ExtractMatIJValue(M,1,2)-(ExtractMatIJValue(M,2,2)

*myfactor.ImageBYfactor);
//	InitMat(Mattemp,m);
	return Mattemp;

}

Mat Genreate3Damat(Mat &amp;M,My_Scalefactor &amp; myfactor)//生成求B矩阵的a矩阵
{
	double m[]={ExtractMatIJValue(M,0,0)-ExtractMatIJValue(M,2,0)*myfactor.ImageBXfactor,
		ExtractMatIJValue(M,0,1)-ExtractMatIJValue(M,2,1)*myfactor.ImageBXfactor,
		ExtractMatIJValue(M,0,2)-ExtractMatIJValue(M,2,2)*myfactor.ImageBXfactor
	};
	Mat Mattemp(1,3,CV_64F);
	InitMat(Mattemp,m);
	return Mattemp;
}

Mat Generate3DTmat(double T)//生成求B矩阵的T矩阵
{
	
	Mat Mattemp(3,1,CV_64F);
	Mattemp.at&lt;double&gt;(0,0)=0.0;
	Mattemp.at&lt;double&gt;(1,0)=0.0;
	Mattemp.at&lt;double&gt;(2,0)=T;
	
	return Mattemp;
}

Mat Generate3Dbmat(Mat &amp;M,My_Scalefactor &amp;myfactor)//生成求B矩阵的b矩阵
{
	double m[]={ExtractMatIJValue(M,1,0)-ExtractMatIJValue(M,2,0)*myfactor.ImageBYfactor,
		ExtractMatIJValue(M,1,1)-ExtractMatIJValue(M,2,1)*myfactor.ImageBYfactor,
		ExtractMatIJValue(M,1,2)-ExtractMatIJValue(M,2,2)*myfactor.ImageBYfactor
	};
	Mat Mattemp(1,3,CV_64F);
	InitMat(Mattemp,m);
	return Mattemp;
}

Mat Generate3DBmat(Mat &amp;a,Mat &amp;b,Mat &amp;t)//生成最后求三维点的B矩阵
{	
	Mat at,bt;
	at=a*t;
	bt=b*t;
	Mat Mattemp(4,1,CV_64F);
	Mattemp.at&lt;double&gt;(0,0)=0.0;
	Mattemp.at&lt;double&gt;(1,0)=0.0;
	Mattemp.at&lt;double&gt;(2,0)=at.at&lt;double&gt;(0,0);
	Mattemp.at&lt;double&gt;(3,0)=bt.at&lt;double&gt;(0,0);
	return Mattemp;
}


int main() 
{ 
	Mat R;//定义旋转矩阵对象
	Mat t;//定义平移矩阵对象
	//	Mat Rxp2,Rya2,Rya1,Rxp1;//构建求旋转矩阵R的原始矩阵
	//ImageA角度参数为 RAO 0，CAUD 35 所以a1=0,p1=35
	//ImageB角度参数为 LAO 80，CRAN 15 所以a2=80,p2=15
	//因为a1为RAO角度，所以a1=-a1=0,p1=35，a2为LAO角度，a2=-a2=-80,
	//因为p2为CRAN角度，所以p2=-p2=-15
	double a1,a2,p1,p2;//声明角度
	/*a1=0;
	a2=-80;
	p1=35;
	p2=-15;*/

	//对角度进行赋值
	a1=0;
	a2=80;
	p1=35;
	p2=15;

	R=GenerateRxmat(p2)*GenerateRymat(a2)*GenerateRymat(a1)*GenerateRxmat(-p1);//求旋转矩阵R
		
	double T1=755,T2=865;//定义距离变量，T1表示O点到s1的距离，T2表示O点到s2的距离
	t=Generate3DTmat(T1)-(R.inv()*Generate3DTmat(T2));//求平移矩阵t
	

	vector&lt;My2dPoint&gt;ImageApoint;//声明存储ImageA轮廓线点坐标的容器
	ImageApoint.clear();//刚开始先清除容器中的数据
    vector&lt;My2dPoint&gt;ImageBpoint;//声明存储ImageB轮廓线点坐标的容器
	ImageBpoint.clear();//刚开始先清除容器中的数据


	/*-----从txt中读取两幅图片手工匹配的二维点数据，并将其填充到容器之中去-----*/
	FILE *ImageA=NULL;//定义读取图片A上二维点坐标的文件指针
	FILE *ImageB=NULL;//定义读取图片B上二维点坐标的文件指针

	ImageA=fopen("E:/ImageA2.txt","rb");//打开存储图片A二维点坐标的txt文件
	if (!ImageA)
	{
		cout&lt;&lt;"打开文件失败"&lt;&lt;endl;
	}
	double ImageAx,ImageAy;//定义临时二维点坐标对象
	My2dPoint ImageAtemp;//定义临时的二维点结构体

	while (!feof(ImageA))//逐行读取数据
	{
		fscanf(ImageA,"%lf %lf",&amp;ImageAx,&amp;ImageAy);//按格式读取数据
		//将临时变量的值赋给二维结构体的相应对象
		ImageAtemp.x=ImageAx;
		ImageAtemp.y=ImageAy;
		ImageApoint.push_back(ImageAtemp);//向容器中压入这个结构体
	}

	ImageB=fopen("E:/ImageB2.txt","rb");//打开存储图片B二维点坐标的txt文件
	if (!ImageB)
	{
		cout&lt;&lt;"打开文件失败"&lt;&lt;endl;
	}
	double ImageBx,ImageBy;//定义临时二维点坐标对象
	My2dPoint ImageBtemp;//定义临时的二维点结构体
	while (!feof(ImageB))//逐行读取数据
	{
		fscanf(ImageB,"%lf %lf",&amp;ImageBx,&amp;ImageBy);//按格式读取数据
		//将临时变量的值赋给二维结构体的相应对象
		ImageBtemp.x=ImageBx;
		ImageBtemp.y=ImageBy;
		ImageBpoint.push_back(ImageBtemp);//向容器中压入这个结构体
	}


	//定义X射线源S1和S2到各自投影平面的垂直距离D1，D2
	int D1=987,D2=987;
	
	vector&lt;My3dPoint&gt; Result3Dpoint;//声明存储最后由ImageA和ImageB二维点所求的三维点坐标的容器
	Result3Dpoint.clear();
	for (int i=0;i&lt;ImageApoint.size()-1;i++)
	{
		/*-----求解缩放因子-----*/
		My_Scalefactor temp;
		temp.IamgeAXfactor=ImageApoint[i].x/D1;
		temp.ImageAYfactor=ImageApoint[i].y/D1;
		temp.ImageBXfactor=ImageBpoint[i].x/D2;
		temp.ImageBYfactor=ImageBpoint[i].y/D2;

		/*-----实现从二维点向三维点转换-----*/
		Mat A,a,b,B;//声明进行最后三维点计算的矩阵，以及求解
		A=Generate3DAmat(R,temp);
		a=Genreate3Damat(R,temp);
		b=Generate3Dbmat(R,temp);
		B=Generate3DBmat(a,b,t);
		
		Mat C;//声明三维点坐标的结果矩阵
		C=(A.t()*A).inv()*A.t()*B;
		My3dPoint Result;
		Result.x=C.at&lt;double&gt;(0);
		Result.y=C.at&lt;double&gt;(1);
		Result.z=C.at&lt;double&gt;(2);
		ofstream f;
		f.open("E:/三维坐标2.txt",ios::out|ios::app);
		f&lt;&lt;Result.x&lt;&lt;"	"&lt;&lt;Result.y&lt;&lt;"	"&lt;&lt;Result.z&lt;&lt;endl;
		Result3Dpoint.push_back(Result);
	}

	/*-----很据上述求解出来的冠脉三维点重建的结果，按顺序进行样条插值生成样条曲线-----*/
	/*-----并以插值后生成的样条曲线为中心生成圆柱体管道，通过设置不同的圆柱体半径达到模拟冠脉的目的-----*/
	/*-----定义vtk绘图命令,开始绘制-----*/

	/*-----绘制第一段样条插值曲线以及圆柱体管道，从0点到1点-----*/
	/*-----对一段圆柱体管道的绘制做详细注释，以下几段相似-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point01=vtkSmartPointer&lt;vtkPoints&gt;::New(); //声明第一段样条曲线中所包含的点的VTK智能指针
	//根据上述求得的三维点的结果，向第一段线的点的智能指针中插入三维点
	point01-&gt;InsertPoint(0,Result3Dpoint[0].x,Result3Dpoint[0].y,Result3Dpoint[0].z);
	point01-&gt;InsertPoint(1,Result3Dpoint[1].x,Result3Dpoint[1].y,Result3Dpoint[1].z);
	point01-&gt;InsertPoint(2,Result3Dpoint[2].x,Result3Dpoint[2].y,Result3Dpoint[2].z);
	point01-&gt;InsertPoint(3,Result3Dpoint[3].x,Result3Dpoint[3].y,Result3Dpoint[3].z);
	point01-&gt;InsertPoint(4,Result3Dpoint[4].x,Result3Dpoint[4].y,Result3Dpoint[4].z);

	/*-----根据三维点插值成样条曲线-----*/
	vtkSmartPointer&lt;vtkParametricSpline&gt;spline01=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline01-&gt;SetPoints(point01);
	spline01-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource01=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource01-&gt;SetParametricFunction(spline01);

	/*定义样条曲线的Mapper以及Actor*/
	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper01=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper01-&gt;SetInputConnection(splineSource01-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor01=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor01-&gt;SetMapper(splineMapper01);
	splineActor01-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);//设置样条曲线的颜色

	/*以生成的样条曲线为中心生成圆柱体管道*/
	vtkSmartPointer&lt;vtkTubeFilter&gt;tube01=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube01-&gt;SetInput(splineSource01-&gt;GetOutput());//输入样条曲线
	tube01-&gt;SetNumberOfSides(20);//设置圆柱体管道的侧边的数量，数量越多越圆滑
	tube01-&gt;SetRadius(3.5);//设置圆柱体管道的半径

	/*设置生成的圆柱体管道的Mapper和Actor，以便在VTK中进行绘制*/
	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper01=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper01-&gt;SetInput(tube01-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor01=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor01-&gt;SetMapper(tubeMapper01);
	tubeActor01-&gt;GetProperty()-&gt;SetColor(1,0,0);//设置圆柱体的颜色

	/*-----绘制第二段样条插值曲线以及圆柱体管道，从1点到2点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point12=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point12-&gt;InsertPoint(0,Result3Dpoint[4].x,Result3Dpoint[4].y,Result3Dpoint[4].z);
	point12-&gt;InsertPoint(1,Result3Dpoint[5].x,Result3Dpoint[5].y,Result3Dpoint[5].z);
	point12-&gt;InsertPoint(2,Result3Dpoint[6].x,Result3Dpoint[6].y,Result3Dpoint[6].z);
	point12-&gt;InsertPoint(3,Result3Dpoint[7].x,Result3Dpoint[7].y,Result3Dpoint[7].z);
	point12-&gt;InsertPoint(4,Result3Dpoint[8].x,Result3Dpoint[8].y,Result3Dpoint[8].z);
	point12-&gt;InsertPoint(5,Result3Dpoint[9].x,Result3Dpoint[9].y,Result3Dpoint[9].z);
	point12-&gt;InsertPoint(6,Result3Dpoint[10].x,Result3Dpoint[10].y,Result3Dpoint[10].z);

	vtkSmartPointer&lt;vtkParametricSpline&gt;spline12=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline12-&gt;SetPoints(point12);
	spline12-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource12=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource12-&gt;SetParametricFunction(spline12);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper12=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper12-&gt;SetInputConnection(splineSource12-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor12=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor12-&gt;SetMapper(splineMapper12);
	splineActor12-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube12=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube12-&gt;SetInput(splineSource12-&gt;GetOutput());
	tube12-&gt;SetNumberOfSides(20);
	tube12-&gt;SetRadius(3);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper12=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper12-&gt;SetInput(tube12-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor12=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor12-&gt;SetMapper(tubeMapper12);
	tubeActor12-&gt;GetProperty()-&gt;SetColor(1,0,0);


	/*-----绘制第三段样条插值曲线以及圆柱体管道，从2点到3点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point23=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point23-&gt;InsertPoint(0,Result3Dpoint[10].x,Result3Dpoint[10].y,Result3Dpoint[10].z);
	point23-&gt;InsertPoint(1,Result3Dpoint[11].x,Result3Dpoint[11].y,Result3Dpoint[11].z);
	point23-&gt;InsertPoint(2,Result3Dpoint[12].x,Result3Dpoint[12].y,Result3Dpoint[12].z);
	point23-&gt;InsertPoint(3,Result3Dpoint[13].x,Result3Dpoint[13].y,Result3Dpoint[13].z);
	point23-&gt;InsertPoint(4,Result3Dpoint[14].x,Result3Dpoint[14].y,Result3Dpoint[14].z);
	point23-&gt;InsertPoint(5,Result3Dpoint[15].x,Result3Dpoint[15].y,Result3Dpoint[15].z);
	

	vtkSmartPointer&lt;vtkParametricSpline&gt;spline23=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline23-&gt;SetPoints(point23);
	spline23-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource23=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource23-&gt;SetParametricFunction(spline23);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper23=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper23-&gt;SetInputConnection(splineSource23-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor23=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor23-&gt;SetMapper(splineMapper23);
	splineActor23-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube23=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube23-&gt;SetInput(splineSource23-&gt;GetOutput());
	tube23-&gt;SetNumberOfSides(23);
	tube23-&gt;SetRadius(2.5);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper23=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper23-&gt;SetInput(tube23-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor23=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor23-&gt;SetMapper(tubeMapper23);
	tubeActor23-&gt;GetProperty()-&gt;SetColor(1,0,0);

	/*-----绘制第四段样条插值曲线以及圆柱体管道，从2点到4点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point24=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point24-&gt;InsertPoint(0,Result3Dpoint[10].x,Result3Dpoint[10].y,Result3Dpoint[10].z);
	point24-&gt;InsertPoint(1,Result3Dpoint[16].x,Result3Dpoint[16].y,Result3Dpoint[16].z);
	point24-&gt;InsertPoint(2,Result3Dpoint[17].x,Result3Dpoint[17].y,Result3Dpoint[17].z);
	point24-&gt;InsertPoint(3,Result3Dpoint[18].x,Result3Dpoint[18].y,Result3Dpoint[18].z);
	point24-&gt;InsertPoint(4,Result3Dpoint[19].x,Result3Dpoint[19].y,Result3Dpoint[19].z);
	point24-&gt;InsertPoint(5,Result3Dpoint[20].x,Result3Dpoint[20].y,Result3Dpoint[20].z);


	vtkSmartPointer&lt;vtkParametricSpline&gt;spline24=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline24-&gt;SetPoints(point24);
	spline24-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource24=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource24-&gt;SetParametricFunction(spline24);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper24=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper24-&gt;SetInputConnection(splineSource24-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor24=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor24-&gt;SetMapper(splineMapper24);
	splineActor24-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube24=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube24-&gt;SetInput(splineSource24-&gt;GetOutput());
	tube24-&gt;SetNumberOfSides(24);
	tube24-&gt;SetRadius(2.5);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper24=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper24-&gt;SetInput(tube24-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor24=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor24-&gt;SetMapper(tubeMapper24);
	tubeActor24-&gt;GetProperty()-&gt;SetColor(1,0,0);

	/*-----绘制第五段样条插值曲线以及圆柱体管道，从4点到5点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point45=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point45-&gt;InsertPoint(0,Result3Dpoint[20].x,Result3Dpoint[20].y,Result3Dpoint[20].z);
	point45-&gt;InsertPoint(1,Result3Dpoint[21].x,Result3Dpoint[21].y,Result3Dpoint[21].z);
	point45-&gt;InsertPoint(2,Result3Dpoint[22].x,Result3Dpoint[22].y,Result3Dpoint[22].z);
	point45-&gt;InsertPoint(3,Result3Dpoint[23].x,Result3Dpoint[23].y,Result3Dpoint[23].z);
	point45-&gt;InsertPoint(4,Result3Dpoint[24].x,Result3Dpoint[24].y,Result3Dpoint[24].z);
	point45-&gt;InsertPoint(5,Result3Dpoint[25].x,Result3Dpoint[25].y,Result3Dpoint[25].z);


	vtkSmartPointer&lt;vtkParametricSpline&gt;spline45=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline45-&gt;SetPoints(point45);
	spline45-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource45=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource45-&gt;SetParametricFunction(spline45);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper45=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper45-&gt;SetInputConnection(splineSource45-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor45=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor45-&gt;SetMapper(splineMapper45);
	splineActor45-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube45=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube45-&gt;SetInput(splineSource45-&gt;GetOutput());
	tube45-&gt;SetNumberOfSides(24);
	tube45-&gt;SetRadius(2);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper45=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper45-&gt;SetInput(tube45-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor45=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor45-&gt;SetMapper(tubeMapper45);
	tubeActor45-&gt;GetProperty()-&gt;SetColor(1,0,0);

	/*-----绘制第六段样条插值曲线以及圆柱体管道，从4点到6点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point46=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point46-&gt;InsertPoint(0,Result3Dpoint[20].x,Result3Dpoint[20].y,Result3Dpoint[20].z);
	point46-&gt;InsertPoint(1,Result3Dpoint[26].x,Result3Dpoint[26].y,Result3Dpoint[26].z);
	point46-&gt;InsertPoint(2,Result3Dpoint[27].x,Result3Dpoint[27].y,Result3Dpoint[27].z);
	point46-&gt;InsertPoint(3,Result3Dpoint[28].x,Result3Dpoint[28].y,Result3Dpoint[28].z);
	point46-&gt;InsertPoint(4,Result3Dpoint[29].x,Result3Dpoint[29].y,Result3Dpoint[29].z);


	vtkSmartPointer&lt;vtkParametricSpline&gt;spline46=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline46-&gt;SetPoints(point46);
	spline46-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource46=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource46-&gt;SetParametricFunction(spline46);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper46=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper46-&gt;SetInputConnection(splineSource46-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor46=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor46-&gt;SetMapper(splineMapper46);
	splineActor46-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube46=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube46-&gt;SetInput(splineSource46-&gt;GetOutput());
	tube46-&gt;SetNumberOfSides(24);
	tube46-&gt;SetRadius(1.5);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper46=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper46-&gt;SetInput(tube46-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor46=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor46-&gt;SetMapper(tubeMapper46);
	tubeActor46-&gt;GetProperty()-&gt;SetColor(1,0,0);

	/*-----绘制第七段样条插值曲线以及圆柱体管道，从1点到7点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point17=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point17-&gt;InsertPoint(0,Result3Dpoint[4].x,Result3Dpoint[4].y,Result3Dpoint[4].z);
	point17-&gt;InsertPoint(1,Result3Dpoint[31].x,Result3Dpoint[31].y,Result3Dpoint[31].z);
	point17-&gt;InsertPoint(2,Result3Dpoint[32].x,Result3Dpoint[32].y,Result3Dpoint[32].z);
	point17-&gt;InsertPoint(3,Result3Dpoint[33].x,Result3Dpoint[33].y,Result3Dpoint[33].z);
	point17-&gt;InsertPoint(4,Result3Dpoint[34].x,Result3Dpoint[34].y,Result3Dpoint[34].z);
	point17-&gt;InsertPoint(4,Result3Dpoint[35].x,Result3Dpoint[35].y,Result3Dpoint[35].z);
	point17-&gt;InsertPoint(4,Result3Dpoint[36].x,Result3Dpoint[36].y,Result3Dpoint[36].z);
	point17-&gt;InsertPoint(4,Result3Dpoint[37].x,Result3Dpoint[37].y,Result3Dpoint[37].z);
	point17-&gt;InsertPoint(4,Result3Dpoint[38].x,Result3Dpoint[38].y,Result3Dpoint[38].z);



	vtkSmartPointer&lt;vtkParametricSpline&gt;spline17=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline17-&gt;SetPoints(point17);
	spline17-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource17=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource17-&gt;SetParametricFunction(spline17);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper17=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper17-&gt;SetInputConnection(splineSource17-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor17=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor17-&gt;SetMapper(splineMapper17);
	splineActor17-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube17=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube17-&gt;SetInput(splineSource17-&gt;GetOutput());
	tube17-&gt;SetNumberOfSides(17);
	tube17-&gt;SetRadius(3);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper17=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper17-&gt;SetInput(tube17-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor17=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor17-&gt;SetMapper(tubeMapper17);
	tubeActor17-&gt;GetProperty()-&gt;SetColor(1,0,0);

	/*-----绘制第八段样条插值曲线以及圆柱体管道，从7点到8点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point78=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point78-&gt;InsertPoint(0,Result3Dpoint[38].x,Result3Dpoint[38].y,Result3Dpoint[38].z);
	point78-&gt;InsertPoint(1,Result3Dpoint[39].x,Result3Dpoint[39].y,Result3Dpoint[39].z);
	point78-&gt;InsertPoint(2,Result3Dpoint[40].x,Result3Dpoint[40].y,Result3Dpoint[40].z);
	point78-&gt;InsertPoint(3,Result3Dpoint[41].x,Result3Dpoint[41].y,Result3Dpoint[41].z);
	point78-&gt;InsertPoint(4,Result3Dpoint[42].x,Result3Dpoint[42].y,Result3Dpoint[42].z);
	point78-&gt;InsertPoint(4,Result3Dpoint[43].x,Result3Dpoint[43].y,Result3Dpoint[43].z);


	vtkSmartPointer&lt;vtkParametricSpline&gt;spline78=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline78-&gt;SetPoints(point78);
	spline78-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource78=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource78-&gt;SetParametricFunction(spline78);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper78=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper78-&gt;SetInputConnection(splineSource78-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor78=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor78-&gt;SetMapper(splineMapper78);
	splineActor78-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube78=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube78-&gt;SetInput(splineSource78-&gt;GetOutput());
	tube78-&gt;SetNumberOfSides(24);
	tube78-&gt;SetRadius(2.5);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper78=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper78-&gt;SetInput(tube78-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor78=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor78-&gt;SetMapper(tubeMapper78);
	tubeActor78-&gt;GetProperty()-&gt;SetColor(1,0,0);

	/*-----绘制第九段样条插值曲线以及圆柱体管道，从7点到9点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point79=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point79-&gt;InsertPoint(0,Result3Dpoint[38].x,Result3Dpoint[38].y,Result3Dpoint[38].z);
	point79-&gt;InsertPoint(1,Result3Dpoint[44].x,Result3Dpoint[44].y,Result3Dpoint[44].z);
	point79-&gt;InsertPoint(2,Result3Dpoint[45].x,Result3Dpoint[45].y,Result3Dpoint[45].z);
	point79-&gt;InsertPoint(3,Result3Dpoint[46].x,Result3Dpoint[46].y,Result3Dpoint[46].z);
	point79-&gt;InsertPoint(4,Result3Dpoint[47].x,Result3Dpoint[47].y,Result3Dpoint[47].z);
	point79-&gt;InsertPoint(4,Result3Dpoint[48].x,Result3Dpoint[48].y,Result3Dpoint[48].z);


	vtkSmartPointer&lt;vtkParametricSpline&gt;spline79=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline79-&gt;SetPoints(point79);
	spline79-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource79=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource79-&gt;SetParametricFunction(spline79);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper79=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper79-&gt;SetInputConnection(splineSource79-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor79=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor79-&gt;SetMapper(splineMapper79);
	splineActor79-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube79=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube79-&gt;SetInput(splineSource79-&gt;GetOutput());
	tube79-&gt;SetNumberOfSides(24);
	tube79-&gt;SetRadius(2);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper79=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper79-&gt;SetInput(tube79-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor79=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor79-&gt;SetMapper(tubeMapper79);
	tubeActor79-&gt;GetProperty()-&gt;SetColor(1,0,0);


	/*-----绘制第十段样条插值曲线以及圆柱体管道，从9点到10点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point910=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point910-&gt;InsertPoint(0,Result3Dpoint[48].x,Result3Dpoint[48].y,Result3Dpoint[48].z);
	point910-&gt;InsertPoint(1,Result3Dpoint[49].x,Result3Dpoint[49].y,Result3Dpoint[49].z);
	point910-&gt;InsertPoint(2,Result3Dpoint[50].x,Result3Dpoint[50].y,Result3Dpoint[50].z);
	point910-&gt;InsertPoint(3,Result3Dpoint[51].x,Result3Dpoint[51].y,Result3Dpoint[51].z);


	vtkSmartPointer&lt;vtkParametricSpline&gt;spline910=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline910-&gt;SetPoints(point910);
	spline910-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource910=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource910-&gt;SetParametricFunction(spline910);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper910=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper910-&gt;SetInputConnection(splineSource910-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor910=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor910-&gt;SetMapper(splineMapper910);
	splineActor910-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube910=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube910-&gt;SetInput(splineSource910-&gt;GetOutput());
	tube910-&gt;SetNumberOfSides(24);
	tube910-&gt;SetRadius(1.5);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper910=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper910-&gt;SetInput(tube910-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor910=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor910-&gt;SetMapper(tubeMapper910);
	tubeActor910-&gt;GetProperty()-&gt;SetColor(1,0,0);



	/*-----绘制第十一段样条插值曲线以及圆柱体管道，从10点到11点-----*/
	vtkSmartPointer&lt;vtkPoints&gt;point1011=vtkSmartPointer&lt;vtkPoints&gt;::New();
	point1011-&gt;InsertPoint(0,Result3Dpoint[48].x,Result3Dpoint[48].y,Result3Dpoint[48].z);
	point1011-&gt;InsertPoint(1,Result3Dpoint[52].x,Result3Dpoint[52].y,Result3Dpoint[52].z);
	point1011-&gt;InsertPoint(2,Result3Dpoint[53].x,Result3Dpoint[53].y,Result3Dpoint[53].z);
	point1011-&gt;InsertPoint(3,Result3Dpoint[54].x,Result3Dpoint[54].y,Result3Dpoint[54].z);
	point1011-&gt;InsertPoint(3,Result3Dpoint[55].x,Result3Dpoint[55].y,Result3Dpoint[55].z);

	vtkSmartPointer&lt;vtkParametricSpline&gt;spline1011=vtkSmartPointer&lt;vtkParametricSpline&gt;::New();
	spline1011-&gt;SetPoints(point1011);
	spline1011-&gt;ClosedOff();

	vtkSmartPointer&lt;vtkParametricFunctionSource&gt;splineSource1011=vtkSmartPointer&lt;vtkParametricFunctionSource&gt;::New();
	splineSource1011-&gt;SetParametricFunction(spline1011);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;splineMapper1011=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	splineMapper1011-&gt;SetInputConnection(splineSource1011-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt;splineActor1011=vtkSmartPointer&lt;vtkActor&gt;::New();
	splineActor1011-&gt;SetMapper(splineMapper1011);
	splineActor1011-&gt;GetProperty()-&gt;SetColor(0.38,0.7,0.16);

	vtkSmartPointer&lt;vtkTubeFilter&gt;tube1011=vtkSmartPointer&lt;vtkTubeFilter&gt;::New();
	tube1011-&gt;SetInput(splineSource1011-&gt;GetOutput());
	tube1011-&gt;SetNumberOfSides(24);
	tube1011-&gt;SetRadius(1.5);

	vtkSmartPointer&lt;vtkPolyDataMapper&gt;tubeMapper1011=vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	tubeMapper1011-&gt;SetInput(tube1011-&gt;GetOutput());

	vtkSmartPointer&lt;vtkActor&gt;tubeActor1011=vtkSmartPointer&lt;vtkActor&gt;::New();
	tubeActor1011-&gt;SetMapper(tubeMapper1011);
	tubeActor1011-&gt;GetProperty()-&gt;SetColor(1,0,0);


	/*-----以下为vtk统一的绘制命令，向绘制窗口添加每一段样条曲线以及圆柱体管道的Actor-----*/
	vtkSmartPointer&lt;vtkRenderer&gt;ren1=vtkSmartPointer&lt;vtkRenderer&gt;::New();
	vtkSmartPointer&lt;vtkRenderWindow&gt;renWin=vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
	renWin-&gt;AddRenderer(ren1);
	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;iren=vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
	iren-&gt;SetRenderWindow(renWin);
	ren1-&gt;SetBackground(1,1,1);//设置绘制窗口背景

	//添加第1段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor01);
	ren1-&gt;AddActor(tubeActor01);
	//添加第2段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor12);
	ren1-&gt;AddActor(tubeActor12);
	//添加第3段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor23);
	ren1-&gt;AddActor(tubeActor23);
	//添加第4段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor24);
	ren1-&gt;AddActor(tubeActor24);
	//添加第5段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor45);
	ren1-&gt;AddActor(tubeActor45);
	//添加第6段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor46);
	ren1-&gt;AddActor(tubeActor46);
	//添加第7段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor17);
	ren1-&gt;AddActor(tubeActor17);
	//添加第8段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor78);
	ren1-&gt;AddActor(tubeActor78);
	//添加第9段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor79);
	ren1-&gt;AddActor(tubeActor79);
	//添加第10段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor910);
	ren1-&gt;AddActor(tubeActor910);
	//添加第11段样条曲线以及圆柱体管道的Actor
	ren1-&gt;AddActor(splineActor1011);
	ren1-&gt;AddActor(tubeActor1011);

	renWin-&gt;SetSize(500,500);//设置窗口大小
	
	renWin-&gt;Render();//绘制
	iren-&gt;Start();//启动交互器

	return 0;
}</code></pre> 
<p>外极线版本：</p> 
<pre class="has"><code>#include &lt;iostream&gt; 
#include &lt;fstream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/core/core.hpp&gt; 
#include&lt;opencv2/highgui/highgui.hpp&gt; 
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;math.h&gt;
#include &lt;vector&gt;
using namespace cv; 
using namespace std;

#define  PI 3.14159265358979323846
typedef struct My_Scalefactor
{
	double IamgeAXfactor;//ImageA上二维点X坐标除以D1
	double ImageAYfactor;//ImageA上二维点Y坐标除以D1
	double ImageBXfactor;//ImageA上二维点X坐标除以D2
	double ImageBYfactor;//ImageA上二维点X坐标除以D2
};
typedef struct My2dPoint
{
	double x;
	double y;
};
typedef struct My3dPoint
{
	double x;
	double y;
	double z;
};
typedef struct MyDistance
{
	double distance;
};
//void InitMat(Mat &amp;m,float *num)用一维数组初始化Mat对象
void InitMat(Mat &amp;m,double *num)
{
	for (int i=0;i&lt;m.rows;i++)
	{
		for (int j=0;j&lt;m.cols;j++)
		{
			m.at&lt;double&gt;(i,j)=*(num+i*m.rows+j);
		}
	}
}
//GenerateRymat(float jiaodu,Mat &amp;M)构造Ry矩阵Mat对象,参数角度为角度，直接返回一个Mat对象
Mat GenerateRymat(double jiaodu)
{
	double m[]={cos(jiaodu/180*PI),0,-sin(jiaodu/180*PI),	
		0,1,0,
		sin(jiaodu/180*PI),0,cos(jiaodu/180*PI)
	};
	Mat Mtemp(3,3,CV_64F);
	InitMat(Mtemp,m);
	return Mtemp;
}
//GenerateRxmat(float jiaodu,Mat &amp;M)构造Rx矩阵Mat对象,参数角度为角度,直接返回一个Mat对象
Mat GenerateRxmat(double jiaodu)
{
	double m[]={1,0,0,
		0,cos(jiaodu/180*PI),sin(jiaodu/180*PI),
		0,-sin(jiaodu/180*PI),cos(jiaodu/180*PI)
	};
	Mat Mtemp(3,3,CV_64F);
	InitMat(Mtemp,m);
	return Mtemp;
}
//提取Mat对象第i行第j列的数值,M为Mat对象，ij为行列值
float ExtractMatIJValue(Mat &amp;M,int i,int j)
{
	return M.at&lt;double&gt;(i,j);
}


//生成最后求三维点的A矩阵，M为Mat类对象,为先求出的R矩阵，My_Scalefactor为struct
Mat Generate3DAmat(Mat &amp;M,My_Scalefactor &amp; myfactor)
{
	//这种浮点数组赋值的方法出错,原因未知
	/*float m[]={1,0,(-myfactor.IamgeAXfactor),
			0,1,(-myfactor.ImageAYfactor),
			(ExtractMatIJValue(M,0,0)-(ExtractMatIJValue(M,2,0)

*myfactor.ImageBXfactor)),
			(ExtractMatIJValue(M,0,1)-(ExtractMatIJValue(M,2,1)

*myfactor.ImageBXfactor)),
			(ExtractMatIJValue(M,0,2)-(ExtractMatIJValue(M,2,2)

*myfactor.ImageBXfactor)),
			(ExtractMatIJValue(M,1,0)-(ExtractMatIJValue(M,2,0)

*myfactor.ImageBYfactor)),
			(ExtractMatIJValue(M,1,1)-(ExtractMatIJValue(M,2,1)

*myfactor.ImageBYfactor)),
			(ExtractMatIJValue(M,1,2)-(ExtractMatIJValue(M,2,2)*myfactor.ImageBYfactor))
	};*/
	Mat Mattemp(4,3,CV_64F);
	Mattemp.at&lt;double&gt;(0,0)=1;
	Mattemp.at&lt;double&gt;(0,1)=0.0;
	Mattemp.at&lt;double&gt;(0,2)=-myfactor.IamgeAXfactor;
	Mattemp.at&lt;double&gt;(1,0)=0;
	Mattemp.at&lt;double&gt;(1,1)=1;
	Mattemp.at&lt;double&gt;(1,2)=-myfactor.ImageAYfactor;
	Mattemp.at&lt;double&gt;(2,0)=ExtractMatIJValue(M,0,0)-(ExtractMatIJValue(M,2,0)

*myfactor.ImageBXfactor);
	Mattemp.at&lt;double&gt;(2,1)=ExtractMatIJValue(M,0,1)-(ExtractMatIJValue(M,2,1)

*myfactor.ImageBXfactor);
	Mattemp.at&lt;double&gt;(2,2)=ExtractMatIJValue(M,0,2)-(ExtractMatIJValue(M,2,2)

*myfactor.ImageBXfactor);
	Mattemp.at&lt;double&gt;(3,0)=ExtractMatIJValue(M,1,0)-(ExtractMatIJValue(M,2,0)

*myfactor.ImageBYfactor);
	Mattemp.at&lt;double&gt;(3,1)=ExtractMatIJValue(M,1,1)-(ExtractMatIJValue(M,2,1)

*myfactor.ImageBYfactor);
	Mattemp.at&lt;double&gt;(3,2)=ExtractMatIJValue(M,1,2)-(ExtractMatIJValue(M,2,2)

*myfactor.ImageBYfactor);
//	InitMat(Mattemp,m);
	return Mattemp;

}
//生成最后三维点的a矩阵
Mat Genreate3Damat(Mat &amp;M,My_Scalefactor &amp; myfactor)
{
	double m[]={ExtractMatIJValue(M,0,0)-ExtractMatIJValue(M,2,0)*myfactor.ImageBXfactor,
		ExtractMatIJValue(M,0,1)-ExtractMatIJValue(M,2,1)*myfactor.ImageBXfactor,
		ExtractMatIJValue(M,0,2)-ExtractMatIJValue(M,2,2)*myfactor.ImageBXfactor
	};
	Mat Mattemp(1,3,CV_64F);
	InitMat(Mattemp,m);
	return Mattemp;
}
//生成最后三维点的T举证
Mat Generate3DTmat(double T)
{
	
	Mat Mattemp(3,1,CV_64F);
	Mattemp.at&lt;double&gt;(0,0)=0.0;
	Mattemp.at&lt;double&gt;(1,0)=0.0;
	Mattemp.at&lt;double&gt;(2,0)=T;
	
	return Mattemp;
}
//生成最后三维点的b矩阵
Mat Generate3Dbmat(Mat &amp;M,My_Scalefactor &amp;myfactor)
{
	double m[]={ExtractMatIJValue(M,1,0)-ExtractMatIJValue(M,2,0)*myfactor.ImageBYfactor,
		ExtractMatIJValue(M,1,1)-ExtractMatIJValue(M,2,1)*myfactor.ImageBYfactor,
		ExtractMatIJValue(M,1,2)-ExtractMatIJValue(M,2,2)*myfactor.ImageBYfactor
	};
	Mat Mattemp(1,3,CV_64F);
	InitMat(Mattemp,m);
	return Mattemp;
}
//生成最后三维点的B矩阵
Mat Generate3DBmat(Mat &amp;a,Mat &amp;b,Mat &amp;t)
{	
	Mat at,bt;
	at=a*t;
	bt=b*t;
	Mat Mattemp(4,1,CV_64F);
	Mattemp.at&lt;double&gt;(0,0)=0.0;
	Mattemp.at&lt;double&gt;(1,0)=0.0;
	Mattemp.at&lt;double&gt;(2,0)=at.at&lt;double&gt;(0,0);
	Mattemp.at&lt;double&gt;(3,0)=bt.at&lt;double&gt;(0,0);
	return Mattemp;
}
//在进行外极线匹配的时候求解图像B的对应点（u2,v2）到外极限的距离D
double Distince(double A1,double A2,double A3,double B1,double B2,double B3,My2dPoint &amp; u2v2,double D2)
{
	//求解该点的缩放因子
	double tempImageBxfactor,tempImageByfactor;
	tempImageBxfactor=u2v2.x/D2;
	tempImageByfactor=u2v2.y/D2;

	//定义外极线距离
	double tempDistance;
	//求解外极线距离
	double X=(fabs((A3*B2-A2*B3)*tempImageBxfactor+(A1*B3-A3*B1)*tempImageByfactor+(A2*B1-A1*B2)));
	double Y=(sqrt((A3*B2-A2*B3)*(A3*B2-A2*B3)+(A1*B3-A3*B1)*(A1*B3-A3*B1)));
//	cout&lt;&lt;"X="&lt;&lt;X&lt;&lt;"		"&lt;&lt;"Y="&lt;&lt;Y&lt;&lt;endl;
	tempDistance=X/Y;
//	tempDistance=(fabs((A3*B2-A2*B3)*tempImageBxfactor+(A1*B3-A3*B1)*tempImageByfactor+(A2*B1-A1*B2)))/(sqrt((A3*B2-A2*B3)*(A3*B2-A2*B3)+(A1*B3-A3*B1)*(A1*B3-A3*B1)));
//	cout&lt;&lt;"tempDistance="&lt;&lt;tempDistance&lt;&lt;endl;
	return tempDistance;
}
//找到vector&lt;MyDistance&gt; &amp;m_distance中最小值的下标
//m_distance为存储两点距离值的容器
int FindVectormin(vector&lt;MyDistance&gt; &amp;m_distance)
{	
	int min=0;
	double distanceMin;
	distanceMin=m_distance[0].distance;
	for (int i=1;i&lt;m_distance.size();i++)
	{
		if (m_distance[i].distance&lt;distanceMin)
		{
			distanceMin=m_distance[i].distance;
			min=i;
		}
	}
//	cout&lt;&lt;"distanceMin="&lt;&lt;distanceMin&lt;&lt;endl;
//	cout&lt;&lt;"min="&lt;&lt;min&lt;&lt;endl;
	return min;
}
//将 DEPTH_8U型二值图像进行细化  经典的Zhang并行快速细化算法
//src，原始IPL_DEPTH_8U型二值图像;dst，目标存储空间，必须事先分配好，且和原图像大小类型一致;
//iterations，迭代次数
void thin(const Mat &amp;src, Mat &amp;dst, const int iterations)
{
	const int height =src.rows -1;
	const int width  =src.cols -1;

	//拷贝一个数组给另一个数组
	if(src.data != dst.data)
	{
		src.copyTo(dst);
	}


	int n = 0,i = 0,j = 0;
	Mat tmpImg;
	uchar *pU, *pC, *pD;
	bool isFinished =false;

	for(n=0; n&lt;iterations; n++)
	{
		dst.copyTo(tmpImg); 
		isFinished =false;   //一次 先行后列扫描 开始
		//扫描过程一 开始
		for(i=1; i&lt;height;  i++) 
		{
			pU = tmpImg.ptr&lt;uchar&gt;(i-1);
			pC = tmpImg.ptr&lt;uchar&gt;(i);
			pD = tmpImg.ptr&lt;uchar&gt;(i+1);
			for(int j=1; j&lt;width; j++)
			{
				if(pC[j] &gt; 0)
				{
					int ap=0;
					int p2 = (pU[j] &gt;0);
					int p3 = (pU[j+1] &gt;0);
					if (p2==0 &amp;&amp; p3==1)
					{
						ap++;
					}
					int p4 = (pC[j+1] &gt;0);
					if(p3==0 &amp;&amp; p4==1)
					{
						ap++;
					}
					int p5 = (pD[j+1] &gt;0);
					if(p4==0 &amp;&amp; p5==1)
					{
						ap++;
					}
					int p6 = (pD[j] &gt;0);
					if(p5==0 &amp;&amp; p6==1)
					{
						ap++;
					}
					int p7 = (pD[j-1] &gt;0);
					if(p6==0 &amp;&amp; p7==1)
					{
						ap++;
					}
					int p8 = (pC[j-1] &gt;0);
					if(p7==0 &amp;&amp; p8==1)
					{
						ap++;
					}
					int p9 = (pU[j-1] &gt;0);
					if(p8==0 &amp;&amp; p9==1)
					{
						ap++;
					}
					if(p9==0 &amp;&amp; p2==1)
					{
						ap++;
					}
					if((p2+p3+p4+p5+p6+p7+p8+p9)&gt;1 &amp;&amp; (p2+p3+p4+p5+p6+p7+p8+p9)&lt;7)
					{
						if(ap==1)
						{
							if((p2*p4*p6==0)&amp;&amp;(p4*p6*p8==0))
							{                           
								dst.ptr&lt;uchar&gt;(i)[j]=0;
								isFinished =true;                            
							}

							//   if((p2*p4*p8==0)&amp;&amp;(p2*p6*p8==0))
							//    {                           
							//         dst.ptr&lt;uchar&gt;(i)[j]=0;
							//         isFinished =TRUE;                            
							//    }

						}
					}                    
				}

			} //扫描过程一 结束


			dst.copyTo(tmpImg); 
			//扫描过程二 开始
			for(i=1; i&lt;height;  i++)  //一次 先行后列扫描 开始
			{
				pU = tmpImg.ptr&lt;uchar&gt;(i-1);
				pC = tmpImg.ptr&lt;uchar&gt;(i);
				pD = tmpImg.ptr&lt;uchar&gt;(i+1);
				for(int j=1; j&lt;width; j++)
				{
					if(pC[j] &gt; 0)
					{
						int ap=0;
						int p2 = (pU[j] &gt;0);
						int p3 = (pU[j+1] &gt;0);
						if (p2==0 &amp;&amp; p3==1)
						{
							ap++;
						}
						int p4 = (pC[j+1] &gt;0);
						if(p3==0 &amp;&amp; p4==1)
						{
							ap++;
						}
						int p5 = (pD[j+1] &gt;0);
						if(p4==0 &amp;&amp; p5==1)
						{
							ap++;
						}
						int p6 = (pD[j] &gt;0);
						if(p5==0 &amp;&amp; p6==1)
						{
							ap++;
						}
						int p7 = (pD[j-1] &gt;0);
						if(p6==0 &amp;&amp; p7==1)
						{
							ap++;
						}
						int p8 = (pC[j-1] &gt;0);
						if(p7==0 &amp;&amp; p8==1)
						{
							ap++;
						}
						int p9 = (pU[j-1] &gt;0);
						if(p8==0 &amp;&amp; p9==1)
						{
							ap++;
						}
						if(p9==0 &amp;&amp; p2==1)
						{
							ap++;
						}
						if((p2+p3+p4+p5+p6+p7+p8+p9)&gt;1 &amp;&amp; (p2+p3+p4+p5+p6+p7+p8+p9)&lt;7)
						{
							if(ap==1)
							{
								//   if((p2*p4*p6==0)&amp;&amp;(p4*p6*p8==0))
								//   {                           
								//         dst.ptr&lt;uchar&gt;(i)[j]=0;
								//         isFinished =TRUE;                            
								//    }

								if((p2*p4*p8==0)&amp;&amp;(p2*p6*p8==0))
								{                           
									dst.ptr&lt;uchar&gt;(i)[j]=0;
									isFinished =true;                            
								}

							}
						}                    
					}

				}

			} //一次 先行后列扫描完成          
			//如果在扫描过程中没有删除点，则提前退出
			if(isFinished ==false)
			{
				break; 
			}
		}

	}
}
int main() 
{ 
	Mat R;//旋转矩阵对象
	Mat t;//平移矩阵对象
	//	Mat Rxp2,Rya2,Rya1,Rxp1;//构建求旋转矩阵R的原始矩阵
	//ImageA角度参数为 RAO 0，CAUD 35 所以a1=0,p1=35
	//ImageB角度参数为 LAO 80，CRAN 15 所以a2=80,p2=15
	//因为a1为RAO角度，所以a1=-a1=0,p1=35，a2为LAO角度，a2=-a2=-80,
	//因为p2为CRAN角度，所以p2=-p2=-15
	double a1,a2,p1,p2;//声明角度
	a1=0;
	a2=-80;
	p1=35;
	p2=-15;
	/*a1=0;
	a2=80;
	p1=35;
	p2=15;*/
	R=GenerateRxmat(p2)*GenerateRymat(a2)*GenerateRymat(a1)*GenerateRxmat(-p1);
		
	cout&lt;&lt;"R="&lt;&lt;R&lt;&lt;endl;
	double T1=755,T2=865;//T1表示O点到s1的距离，T2表示O点到s2的距离
	t=Generate3DTmat(T1)-(R.inv()*Generate3DTmat(T2));
	cout&lt;&lt;"Generate3DTmat(T1)="&lt;&lt;Generate3DTmat(T1)&lt;&lt;endl;
	cout&lt;&lt;"t="&lt;&lt;t&lt;&lt;endl;

	//外极线匹配
	vector&lt;My2dPoint&gt;ImageApoint;//存储ImageA轮廓线点坐标
	ImageApoint.clear();
    vector&lt;My2dPoint&gt;ImageBpoint;//存储ImageB轮廓线点坐标
	ImageBpoint.clear();

	Mat ImageA=imread("E:/A.bmp",0);//打开ImageA,并创建相关的Mat对象
	Mat ImageB=imread("E:/B.bmp",0);//打开ImageB,并创建相关的Mat对象
	ImageA=ImageA&lt;200;
	ImageB=ImageB&lt;200;

	//定义ImageA轮廓以及层次结构
	vector&lt;vector&lt;Point&gt;&gt;ImageAcontours;
	vector&lt;vector&lt;Point&gt;&gt;ImageBcontours;
	vector&lt;Vec4i&gt;ImageAhierarchy;
	vector&lt;Vec4i&gt;ImageBhierarchy;
	//查找ImageA和ImageB的轮廓线
	findContours(ImageA,ImageAcontours,ImageAhierarchy,RETR_EXTERNAL,CHAIN_APPROX_NONE);
	findContours(ImageB,ImageBcontours,ImageBhierarchy,RETR_EXTERNAL,CHAIN_APPROX_NONE);

	//将ImageA和ImageB的轮廓线的点进行迭代输出到vector,ImageApoint和ImageBpoint中
	//传递ImageA轮廓线的坐标，压入容器
	My2dPoint ImageAtemp;
	for (int i=0;i&lt;ImageAcontours.size();i++)
	{
		for (int j=0;j&lt;ImageAcontours[i].size();j++)
		{
		//	cout&lt;&lt;ImageAcontours[i][j].x&lt;&lt;"	"&lt;&lt;ImageAcontours[i][j].y&lt;&lt;endl;
			ImageAtemp.x=ImageAcontours[i][j].x;
			ImageAtemp.y=ImageA.rows-ImageAcontours[i][j].y;
			ImageApoint.push_back(ImageAtemp);
		}
	}
	cout&lt;&lt;"ImageApoint.size()="&lt;&lt;ImageApoint.size()&lt;&lt;endl;
	//传递ImageB轮廓线的坐标,压入容器
	My2dPoint ImageBtemp;
	for (int i=0;i&lt;ImageBcontours.size();i++)
	{
		for (int j=0;j&lt;ImageBcontours[i].size();j++)
		{
		//	cout&lt;&lt;ImageBcontours[i][j].x&lt;&lt;"	"&lt;&lt;ImageBcontours[i][j].y&lt;&lt;endl;
			ImageBtemp.x=ImageBcontours[i][j].x;
			ImageBtemp.y=ImageB.rows-ImageBcontours[i][j].y;
			ImageBpoint.push_back(ImageBtemp);
			ofstream f;
			f.open("E:/ImageB轮廓线坐标.txt",ios::out|ios::app);
			f&lt;&lt;ImageBtemp.x&lt;&lt;"    "&lt;&lt;ImageBtemp.y&lt;&lt;endl;
		}
	}
	cout&lt;&lt;"ImageBpoint.size()="&lt;&lt;ImageBpoint.size()&lt;&lt;endl;
	int D1=987,D2=987;
	//根据外极线约束搜索ImageA上的点在ImageB上的匹配点
	vector&lt;MyDistance&gt; ImageBwaijixianDistance;//存储ImageB上轮廓线上的点到外极线的距离，距离最小的为匹配点
	
	vector&lt;My3dPoint&gt; Result3Dpoint;//存储最后由ImageA和ImageB二维点所求的三维点坐标
	Result3Dpoint.clear();

	for (int i=0;i&lt;1;i++)
	{
		
		ImageBwaijixianDistance.clear();

		My_Scalefactor temp;
		ImageApoint[i].x=149;
		ImageApoint[i].x=13;
		temp.IamgeAXfactor=ImageApoint[i].x/D1;
//		cout&lt;&lt;"temp.IamgeAXfactor="&lt;&lt;temp.IamgeAXfactor&lt;&lt;"ImageApoint[i].x="&lt;&lt;ImageApoint[i].y&lt;&lt;endl;
		temp.ImageAYfactor=ImageApoint[i].y/D1;
		//求解构建外极线方程所需参数
		double A1=ExtractMatIJValue(R,0,0)*temp.IamgeAXfactor+ExtractMatIJValue(R,0,1)*temp.ImageAYfactor+ExtractMatIJValue(R,0,2);
		double A2=ExtractMatIJValue(R,1,0)*temp.IamgeAXfactor+ExtractMatIJValue(R,1,1)*temp.ImageAYfactor+ExtractMatIJValue(R,1,2);
		double A3=ExtractMatIJValue(R,2,0)*temp.IamgeAXfactor+ExtractMatIJValue(R,2,1)*temp.ImageAYfactor+ExtractMatIJValue(R,2,2);
		double B1=ExtractMatIJValue(R,0,0)*t.at&lt;double&gt;(0)+ExtractMatIJValue(R,0,1)*t.at&lt;double&gt;(1)+ExtractMatIJValue(R,0,2)*t.at&lt;double&gt;(2);
		double B2=ExtractMatIJValue(R,1,0)*t.at&lt;double&gt;(0)+ExtractMatIJValue(R,1,1)*t.at&lt;double&gt;(1)+ExtractMatIJValue(R,1,2)*t.at&lt;double&gt;(2);
		double B3=ExtractMatIJValue(R,2,0)*t.at&lt;double&gt;(0)+ExtractMatIJValue(R,2,1)*t.at&lt;double&gt;(1)+ExtractMatIJValue(R,2,2)*t.at&lt;double&gt;(2);
		MyDistance tempDistance;
		for (int j=0;j&lt;ImageBpoint.size();j++)
		{
			//计算ImageB轮廓线所有点到外极线的距离，并将其压入距离容器
			tempDistance.distance=Distince(A1,A2,A3,B1,B2,B3,ImageBpoint[j],D2);
			ImageBwaijixianDistance.push_back(tempDistance);	
		}
		
		//找到ImageBwaijixianDistance（)距离最小值所在的下标，根据此下标确定ImageA与ImageB的匹配点
		int DintanceMinXiaBiao=0;
		DintanceMinXiaBiao=FindVectormin(ImageBwaijixianDistance);

		

	//	cout&lt;&lt;"DistanceMin="&lt;&lt;ImageBwaijixianDistance[DintanceMinXiaBiao].distance&lt;&lt;"		"&lt;&lt;DintanceMinXiaBiao&lt;&lt;endl;
		cout&lt;&lt;ImageBpoint[DintanceMinXiaBiao].x&lt;&lt;"    "&lt;&lt;ImageBpoint[DintanceMinXiaBiao].y&lt;&lt;endl;
		//计算ImageB上的缩放因子
		temp.ImageBXfactor=ImageBpoint[DintanceMinXiaBiao].x/D2;
		temp.ImageBYfactor=ImageBpoint[DintanceMinXiaBiao].y/D2;
		/*temp.ImageBXfactor=ImageBpoint[i].x/D2;
		temp.ImageBYfactor=ImageBpoint[i].y/D2;*/

		//实现从二维点向三维点转换
		Mat A,a,b,B;//声明进行最后三维点计算的矩阵，以及求解
		A=Generate3DAmat(R,temp);
//		cout&lt;&lt;A&lt;&lt;endl;
		a=Genreate3Damat(R,temp);
		b=Generate3Dbmat(R,temp);
		B=Generate3DBmat(a,b,t);
		
		Mat C;//声明三维点坐标的结果矩阵
		C=(A.t()*A).inv()*A.t()*B;
		My3dPoint Result;
		Result.x=C.at&lt;double&gt;(0);
		Result.y=C.at&lt;double&gt;(1);
		Result.z=C.at&lt;double&gt;(2);
	//	cout&lt;&lt;Result.x&lt;&lt;"	"&lt;&lt;Result.y&lt;&lt;"	"&lt;&lt;Result.z&lt;&lt;endl;
		ofstream f;
		f.open("E:/三维坐标.txt",ios::out|ios::app);
		f&lt;&lt;Result.x&lt;&lt;"	"&lt;&lt;Result.y&lt;&lt;"	"&lt;&lt;Result.z&lt;&lt;endl;
		Result3Dpoint.push_back(Result);
	}
	return 0;
}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>     下面为论文中给出的三维重建结果：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/f5/49/zPXoIBRs_o.jpg"></p> 
<p> </p> 
<p> </p> 
<p>    本示例程序最后的运行结果：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/04/7f/65y4UPZm_o.jpg"><img alt="" class="has" src="https://images2.imgbox.com/f9/af/2ruKY5HK_o.jpg"><img alt="" class="has" src="https://images2.imgbox.com/e5/64/cOmW4RUr_o.png"><img alt="" class="has" src="https://images2.imgbox.com/9b/d6/SKEyOiZq_o.png"><img alt="" class="has" src="https://images2.imgbox.com/dc/7b/drlwH0e6_o.jpg"></p> 
<p> </p> 
<p> </p> 
<p><span style="color:#555555;">总体上来看，重建效果与论文中最后给出的结果类似，VTK封装了OpenGL底层的绘图命令，所以在光照与材质方面不需要我们去过多的设置就会有逼真的三维显示效果。</span></p> 
<p> </p> 
<p>关于网友一直求得二维点数据，我找了好久终于找到了，大家可以进入我的个站<a href="https://www.stubbornhuang.com/823/" rel="nofollow">https://www.stubbornhuang.com/823/</a>下载！</p> 
<p>如果您觉得这篇博文有用，请访问我的个人站：<a href="http://www.stubbornhuang.com" rel="nofollow">http://www.stubbornhuang.com</a>，更多博文干货等着您。</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/803bb6fd00e11b46988cf1a91cefee68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决“error C2872: “ACCESS_MASK”: 不明确的符号	“报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/905be0278a817df2128a245721613fc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java调用批处理bat文件调用python pdfkit把动态html转pdf</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>