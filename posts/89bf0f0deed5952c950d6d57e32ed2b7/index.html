<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K8Spod组件 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K8Spod组件" />
<meta property="og:description" content="一个pod能包含几个容器
一个pause容器(基础容器/父容器/根容器）
一个或者多个应用容器(业务容器)
通常一个Pod最好只包含一个应用容器，一个应用容器最好也只运行一个业务进程。
同一个Pod里的容器都是运行在同一个node节点上的，并且共享 net、mnt、uts、 pid、 ipc 命名空间。
pod的定义 1 Pod是k8s中最小的资源管理组件
2 Pod也是最小化运行容器化的应用的资源管理对象
3 Pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合
4 最常见的是在一个pod当中运行一个容器，也是最常用的方式
5 在一个pod当中同时运行多个容器，在一个pod当中可以同时封装及格需要耦合的互相协作的容器，这些多个容器共享资源，也可以互相协作组成一个service单位
6 不论运行一个容器还是多个容器，k8s管理的都是pod而不是容器
一个pod内的容器，必须都运行在同一个节点，基于现代容器技术的要求，就是一个pod运行一个容器，一个容器只运行一个进程，横向扩展(核心是方便扩缩容，还有就是解耦，一个pod内运行多个容器，耦合度太高，一旦一个进程失败，整个pod将全部失败)实现解耦，基于pod可以创建多个副本，实现高可用和负载均衡。管理方便，简单直观。
Pod内的容器共享资源，共享机制:pause底层基础容器来提供共享资源的机制。
Pause容器是基础容器，也可以成为父容器，它的作用就是管理pod内容器的共享操作
Pause还可以管理容器的生命周期
k8s提供了pause容器两大核心功能
1 为pod内的所有容器提供一个统一的命名空间
2 启动容器的pid命名空间，每个pod中都作为pid都为1的进程(init进程) ，回收僵尸进程（pod里面是容器，容器运行的进程pid，pause父进程1在pod内部管理容器进程）
3 创建pod时，先创建pause容器，然后拉取镜像，生成容器，形成pod
Pause容器共享两种资源
1 网络：每个pod都会被分配一个集群内部的唯一ip地址，pod内的容器共享网络，pod在集群内部的ip地址和端口，pod内部的容器可以使用localhost互相通信，pod的中容器与外部通信时，从共享的资源当中进行分配，宿主机的端口映射
2 存储pod可以指定多个共享volume，pod内的容器共享这些vloume
Vloume可以是实现数据持久化，可以防止pod重新构建之后数据文件丢失
每个pod都有一个基础容器pause容器
Pause容器对应的惊险属于k8s集群的一部分，创建集群就会有pause这个基础镜像
Pod里面包含了一个或者多个相关的容器（也就是应用）
由kube-controller-manager 提供网络ip
Pod外再设置一个基础镜像
1 pod内部有一组容器，挂了一个，就算整个pod失效了吗？，引入了pause禁止，代表整个容器的组的状态
可以解决对pod内部容器整体状态的判断
2 pod内的容器共享ip，共享volume挂载卷，解决了容器网络通信的问题，解决了容器内部文件共享的问题
pod的分类
1 自主式pod：
这种pod不会自我修复，pod内容器的进程终止或者删除，或者缺少资源被驱逐，这个pod没有办法自愈
由scheduler进行调度，不被控制器管理，没有自愈能力，一旦pod挂掉，不会被重新拉起，没有副本管理，滚动更新功能
2 控制器管理pod：
可以滚动升级，可以自愈(自动重启)，可以提供管理pod的数量，以及扩缩容
由scheduler进行调度，被控制器管理，有自愈能力(一旦pod挂了，会被控制器重新拉起)，由副本管理，滚动更新等功能
3 静态pod
不由schedule调度，是由kubelet自行管理，始终和kubelet运行在同一个node节点上，不能直接删除，静态pod的yaml配置文件目录默认存放于/etc/kubenetes/manifests目录，在这个目录下创建或者删除yaml文件，kubelet会自动的创建或删除静态pod
#创建命令 kubectl create deployment/statefulset/daemonset .... pod的生命周期与常见的状态" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/89bf0f0deed5952c950d6d57e32ed2b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-03T16:14:57+08:00" />
<meta property="article:modified_time" content="2024-01-03T16:14:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K8Spod组件</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>一个pod能包含几个容器</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p>一个pause容器(基础容器/父容器/根容器）</p> <p>一个或者多个应用容器(业务容器)</p> <p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">通常一个Pod<strong>最好</strong>只包含一个应用容器，一个应用容器最好也只运行一个业务进程。</span></span></p> <p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">同一个Pod里的容器都是运行在同一个node节点上的，并且共享 net、mnt、uts、 pid、 ipc 命名空间。</span></span></p> </td></tr></tbody></table> 
<p><strong>pod的定义 </strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:53px;">1</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">Pod是k8s中最小的资源管理组件</p> </td></tr><tr><td style="width:53px;">2</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">Pod也是最小化运行容器化的应用的资源管理对象</p> </td></tr><tr><td style="width:53px;">3</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">Pod是一个抽象的概念，可以理解为一个或者多个容器化应用的集合</p> </td></tr><tr><td style="width:53px;">4</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">最常见的是在一个pod当中运行一个容器，也是最常用的方式</p> </td></tr><tr><td style="width:53px;">5</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">在一个pod当中同时运行多个容器，在一个pod当中可以同时封装及格需要耦合的互相协作的容器，这些多个容器共享资源，也可以互相协作组成一个service单位</p> </td></tr><tr><td style="width:53px;">6</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">不论运行一个容器还是多个容器，k8s管理的都是pod而不是容器</p> </td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p style="margin-left:.0001pt;text-align:justify;">一个pod内的容器，必须都运行在同一个节点，基于现代容器技术的要求，就是一个pod运行一个容器，一个容器只运行一个进程，横向扩展(核心是方便扩缩容，还有就是解耦，一个pod内运行多个容器，耦合度太高，一旦一个进程失败，整个pod将全部失败)实现解耦，基于pod可以创建多个副本，实现高可用和负载均衡。管理方便，简单直观。</p> </td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:43px;"></td><td style="width:455px;"> <p style="margin-left:.0001pt;text-align:justify;">Pod内的容器共享资源，共享机制:pause底层基础容器来提供共享资源的机制。</p> <p style="margin-left:.0001pt;text-align:justify;">Pause容器是基础容器，也可以成为父容器，它的作用就是管理pod内容器的共享操作</p> <p style="margin-left:.0001pt;text-align:justify;">Pause还可以管理容器的生命周期</p> <p style="margin-left:.0001pt;text-align:justify;">k8s提供了pause容器两大核心功能</p> </td></tr><tr><td style="width:43px;">1</td><td style="width:455px;"> <p style="text-align:justify;">为pod内的所有容器提供一个统一的命名空间</p> </td></tr><tr><td style="width:43px;">2</td><td style="width:455px;"> <p style="margin-left:.0001pt;text-align:justify;">启动容器的pid命名空间，每个pod中都作为pid都为1的进程(init进程) ，回收僵尸进程（pod里面是容器，容器运行的进程pid，pause父进程1在pod内部管理容器进程）</p> </td></tr><tr><td style="width:43px;">3</td><td style="width:455px;"> <p style="margin-left:.0001pt;text-align:justify;">创建pod时，先创建pause容器，然后拉取镜像，生成容器，形成pod</p> </td></tr></tbody></table> 
<p><img alt="" height="355" src="https://images2.imgbox.com/a4/56/A3169EG4_o.png" width="829"></p> 
<p><strong> Pause容器共享两种资源</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:59px;">1</td><td style="width:439px;"> <p style="margin-left:.0001pt;text-align:justify;">网络：每个pod都会被分配一个集群内部的唯一ip地址，pod内的容器共享网络，pod在集群内部的ip地址和端口，pod内部的容器可以使用localhost互相通信，pod的中容器与外部通信时，从共享的资源当中进行分配，宿主机的端口映射</p> </td></tr><tr><td style="width:59px;">2</td><td style="width:439px;"> <p style="text-align:justify;">存储pod可以指定多个共享volume，pod内的容器共享这些vloume</p> <p style="margin-left:.0001pt;text-align:justify;">Vloume可以是实现数据持久化，可以防止pod重新构建之后数据文件丢失</p> </td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:47px;"></td><td style="width:451px;"> <p style="margin-left:.0001pt;text-align:justify;">每个pod都有一个基础容器pause容器</p> <p style="margin-left:.0001pt;text-align:justify;">Pause容器对应的惊险属于k8s集群的一部分，创建集群就会有pause这个基础镜像</p> <p style="margin-left:.0001pt;text-align:justify;">Pod里面包含了一个或者多个相关的容器（也就是应用）</p> <p style="margin-left:.0001pt;text-align:justify;">由kube-controller-manager 提供网络ip</p> <p style="margin-left:.0001pt;text-align:justify;">Pod外再设置一个基础镜像</p> </td></tr><tr><td style="width:47px;">1</td><td style="width:451px;"> <p style="text-align:justify;">pod内部有一组容器，挂了一个，就算整个pod失效了吗？，引入了pause禁止，代表整个容器的组的状态</p> <p style="margin-left:.0001pt;text-align:justify;">可以解决对pod内部容器整体状态的判断</p> </td></tr><tr><td style="width:47px;">2</td><td style="width:451px;"> <p style="margin-left:.0001pt;text-align:justify;">pod内的容器共享ip，共享volume挂载卷，解决了容器网络通信的问题，解决了容器内部文件共享的问题</p> </td></tr></tbody></table> 
<p><strong>pod的分类</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:35px;">1</td><td style="width:463px;"> <p style="margin-left:.0001pt;text-align:justify;">自主式pod：</p> <p style="margin-left:.0001pt;text-align:justify;">这种pod不会自我修复，pod内容器的进程终止或者删除，或者缺少资源被驱逐，这个pod没有办法自愈</p> <p style="margin-left:.0001pt;text-align:justify;">由scheduler进行调度，不被控制器管理，没有自愈能力，一旦pod挂掉，不会被重新拉起，没有副本管理，滚动更新功能</p> </td></tr><tr><td style="width:35px;">2</td><td style="width:463px;"> <p style="margin-left:.0001pt;text-align:justify;">控制器管理pod：</p> <p style="margin-left:.0001pt;text-align:justify;">可以滚动升级，可以自愈(自动重启)，可以提供管理pod的数量，以及扩缩容</p> <p style="margin-left:.0001pt;text-align:justify;">由scheduler进行调度，被控制器管理，有自愈能力(一旦pod挂了，会被控制器重新拉起)，由副本管理，滚动更新等功能</p> </td></tr><tr><td style="width:35px;">3</td><td style="width:463px;"> <p>静态pod</p> <p>不由schedule调度，是由kubelet自行管理，始终和kubelet运行在同一个node节点上，不能直接删除，静态pod的yaml配置文件目录默认存放于/etc/kubenetes/manifests目录，在这个目录下创建或者删除yaml文件，kubelet会自动的创建或删除静态pod</p> </td></tr></tbody></table> 
<pre><code class="language-bash">#创建命令
kubectl create deployment/statefulset/daemonset ....</code></pre> 
<p><strong>pod的生命周期与常见的状态</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:48px;">1</td><td style="width:450px;"> <p style="margin-left:.0001pt;text-align:justify;">pending：挂起状态，</p> <p style="margin-left:.0001pt;text-align:justify;">pod已被创建，但是尚未被分配到运行的node节点（一直pending的原因：节点上资源不够，需要等待其他pod的调度）</p> </td></tr><tr><td style="width:48px;">2</td><td style="width:450px;"> <p style="margin-left:.0001pt;text-align:justify;">Running：运行中，</p> <p style="margin-left:.0001pt;text-align:justify;">pod已被分配到了node节点，pod内部的所有容器都已经启动，运行状态正常，且稳定</p> </td></tr><tr><td style="width:48px;">3</td><td style="width:450px;"> <p style="margin-left:.0001pt;text-align:justify;">Complete：也叫successded，</p> <p style="margin-left:.0001pt;text-align:justify;">容器内部的进程运行完毕，正常退出，没有发生错误</p> </td></tr><tr><td style="width:48px;">4</td><td style="width:450px;"> <p style="margin-left:.0001pt;text-align:justify;">Faild：</p> <p style="margin-left:.0001pt;text-align:justify;">pod中的容器非正常状态退出，发生了错误，需要通过查看详情来定位问题</p> </td></tr><tr><td style="width:48px;">5</td><td style="width:450px;"> <p style="text-align:justify;">UNkown：</p> <p style="text-align:justify;">由于某些原因，k8s集群无法获取pod的状态，APIserver出了问题</p> </td></tr><tr><td style="width:48px;">7</td><td style="width:450px;"> <p style="margin-left:.0001pt;text-align:justify;">Terminating：</p> <p style="margin-left:.0001pt;text-align:justify;">终止中，正在被中终止，pod正在被删除，但是里面的容器正在终止，这个过程其中还会有一些其他的操作，如资源回收，垃圾清理，以及终止过程中需要执行的命令</p> </td></tr><tr><td style="width:48px;"></td><td style="width:450px;">pod遵循预定义的生命周期，起始于pending阶段，如果至少其中有一个主容器正常运行，则进入running阶段，之后取决于pod是否有容器以失败状态退出而进入succeeded或者Failed阶段</td></tr></tbody></table> 
<p><img alt="" height="403" src="https://images2.imgbox.com/38/f8/A637USrR_o.png" width="831"></p> 
<p><strong> 创建pod的容器分类</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:46px;">1</td><td style="width:452px;"> <p style="text-align:justify;">基础容器：pause</p> <p style="text-align:justify;">作为linux命名空间共享的基础，给pod里其他的容器提供网络，存储资源的共享</p> <p style="text-align:justify;">作为pid=1的init进程管理整个pod容器组的生命周期</p> </td></tr><tr><td style="width:46px;">2</td><td style="width:452px;"> <p style="text-align:justify;">Init容器：初始化容器，init c   </p> <p style="text-align:justify;">在1和2这个过程中，pod的状态叫init：0/3，每启动一个就改变1/3 , 2/3 , 3/3 ，全部启动之后才会到业务容器</p> <p style="margin-left:.0001pt;text-align:justify;">Init容器的作用：环境变量，可以在创建的过程中为业务容器定制好，相关的代码和<span style="color:#000000;">工具</span></p> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">Init容器独立与业务容器，它是单独构建的一个镜像，对业务容器不产生任何安全影响</span></p> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">Init容器能以不同于pod内应用容器的文件系统视图运行，secrets的权限（保存一些加密的安全机制配置），应用容器无法访问secrets的权限、</span></p> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">Init容器提供了应用容器运行之前的先决条件，提供了一种阻塞机制或者延迟机制来控制应用容器的启动，只有前置条件满足，才会创建pod的应用容器</span></p> </td></tr><tr><td style="width:46px;">3</td><td style="width:452px;"> <p style="margin-left:.0001pt;text-align:justify;">业务容器（应用容器）</p> <p style="margin-left:.0001pt;text-align:justify;">pod由多个应用容器时，是并行启动的，即应用容器要在所有init容器都成功的完成启动，运行，退出后才会启动</p> </td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:53px;">1</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">在pod的启动过程中，容器是按照初始化容器先启动，每个容器必须在下一个容器启动之前，要成功退出</p> </td></tr><tr><td style="width:53px;">2</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">如果运行失败，会按照容器的重启策略进行指定动作，resatrtPolicy   Always  never  onFailure(非正常退出才会重启)</p> </td></tr><tr><td style="width:53px;">3</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">所有的init容器没有成功之前，pod是不会进入ready状态的</p> <p style="margin-left:.0001pt;text-align:justify;">Init容器与service无关，不能对外提供访问</p> </td></tr><tr><td style="width:53px;">4</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">如果重启pod，所有的init容器一定会重新执行</p> </td></tr><tr><td style="width:53px;">5</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">如果修改init容器的spec(参数)，只限制于image，其他的修改字段都不生效（基于deployment）</p> </td></tr><tr><td style="width:53px;">6</td><td style="width:445px;"> <p style="margin-left:.0001pt;text-align:justify;">在pod中每个容器的名称都要唯一，不能重复</p> </td></tr></tbody></table> 
<p><strong> pod中容器的重启策略</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:86px;">Always</td><td style="width:412px;">只要容器退出，总是重启，无论容器的状态码是否正常，默认策略，可以不加</td></tr><tr><td style="width:86px;">Never</td><td style="width:412px;">只要容器退出，不论是否正常，都不重启</td></tr><tr><td style="width:86px;">OnFailure</td><td style="width:412px;">只要容器的转态码非0才会重启（pod容器异常退出时），正常退出不重启（容器退出码为0）</td></tr></tbody></table> 
<p><img alt="" height="107" src="https://images2.imgbox.com/c6/97/WXwNaV7t_o.png" width="830"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>总结</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p style="margin-left:.0001pt;text-align:justify;">Pause容器：底层容器，也可以理解为基础容器</p> <p style="margin-left:.0001pt;text-align:justify;">提供pod内容器的网络和存储共享，以及pod内容器退出之后的资源回收</p> <p style="margin-left:.0001pt;text-align:justify;">Init容器：人为设定的业务容器，启动之前的必要条件</p> </td></tr></tbody></table> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>Pod的生命周期</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:40px;">1</td><td style="width:458px;">pause基础容器</td></tr><tr><td style="width:40px;">2</td><td style="width:458px;">Init初始化容器，全部成功退出，才会到业务容器</td></tr><tr><td style="width:40px;">3</td><td style="width:458px;">Postart prestop 容器的钩子，启动时命令和退出时的命令</td></tr><tr><td style="width:40px;">4</td><td style="width:458px;">探针:探测容器的健康状态，伴随pod的整个生命周期（除了启动探针）</td></tr><tr><td style="width:40px;"></td><td style="width:458px;">总结：pod就是用来封装容器，业务室容器，服务也是容器，包括端口也是容器</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p style="margin-left:.0001pt;text-align:justify;">Pod的重启策略always只要有一个失败整个pod都会重启，</p> <p style="margin-left:.0001pt;text-align:justify;">Never：都不重启</p> <p style="margin-left:.0001pt;text-align:justify;">OnFail：重启整个pod</p> </td></tr></tbody></table>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c2f54962a746b6cfbeb5f9bb137227c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">技术探索的激情与匠心：获取IP信息的神秘世界</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c1cff4d5ca5d80f0e8efb012fef9cb4a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">卡巴斯基曝光苹果处理器“神秘后门”，复杂程度堪称史诗级！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>