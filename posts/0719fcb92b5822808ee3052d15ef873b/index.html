<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FFmpeg在Windows上通过dshow编解码方式设置为mjpeg并实时显示测试代码 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FFmpeg在Windows上通过dshow编解码方式设置为mjpeg并实时显示测试代码" />
<meta property="og:description" content="Windows上默认的内置摄像头一般支持两种编解码格式：rawvideo和mjpeg。在调用FFmpeg接口时默认的采用rawvideo。这里通过DirectShow实现为mjpeg进行编解码。
通过命令行调用FFmpeg可执行文件：
(1). 可获取Windows上连接的视频设备，命令如下：
ffmpeg.exe -list_devices true -f dshow -i dummy (2). 可获取指定视频设备支持的编解码格式和video size，命令如下：
ffmpeg.exe -f dshow -list_options true -i video=&#34;Integrated Webcam&#34; 这里通过C&#43;&#43;实现获取连接的视频设备，代码如下：
AVFormatContext* format_context = avformat_alloc_context(); AVDictionary* dict = nullptr; av_dict_set(&amp;dict, &#34;list_devices&#34;, &#34;true&#34;, 0); AVInputFormat* input_format = av_find_input_format(&#34;dshow&#34;); avformat_open_input(&amp;format_context, &#34;&#34;, input_format, &amp;dict); avformat_close_input(&amp;format_context); av_dict_free(&amp;dict); 这里通过C&#43;&#43;实现支持的编解码格式和video size，代码如下：
AVFormatContext* format_context = avformat_alloc_context(); AVDictionary* dict = nullptr; av_dict_set(&amp;dict, &#34;list_options&#34;, &#34;true&#34;, 0); AVInputFormat* input_format = av_find_input_format(&#34;dshow&#34;); avformat_open_input(&amp;format_context, &#34;video=Integrated Webcam&#34;, input_format, &amp;dict); // video=video device name avformat_close_input(&amp;format_context); av_dict_free(&amp;dict); 设置编解码格式通过av_dict_set好像不能成功，这里是通过AVFormatContext的video_codec_id进行设置，通过av_dict_set设置帧率好像也不能成功。通过调用OpenCV的接口进行实时显示，代码如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0719fcb92b5822808ee3052d15ef873b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-08T14:52:42+08:00" />
<meta property="article:modified_time" content="2019-12-08T14:52:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FFmpeg在Windows上通过dshow编解码方式设置为mjpeg并实时显示测试代码</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-indent:33px;">Windows上默认的内置摄像头一般支持两种编解码格式：rawvideo和mjpeg。在调用FFmpeg接口时默认的采用rawvideo。这里通过DirectShow实现为mjpeg进行编解码。</p> 
<p style="text-indent:33px;">通过命令行调用FFmpeg可执行文件：</p> 
<p style="text-indent:33px;">(1). 可获取Windows上连接的视频设备，命令如下：</p> 
<pre class="has"><code class="language-bash">ffmpeg.exe -list_devices true -f dshow -i dummy</code></pre> 
<p style="text-indent:33px;">(2). 可获取指定视频设备支持的编解码格式和video size，命令如下：</p> 
<pre class="has"><code class="language-bash">ffmpeg.exe -f dshow -list_options true -i video="Integrated Webcam"</code></pre> 
<p style="text-indent:33px;">这里通过C++实现获取连接的视频设备，代码如下：</p> 
<pre class="has"><code class="language-cpp">AVFormatContext* format_context = avformat_alloc_context();
AVDictionary* dict = nullptr;
av_dict_set(&amp;dict, "list_devices", "true", 0);
AVInputFormat* input_format = av_find_input_format("dshow");
avformat_open_input(&amp;format_context, "", input_format, &amp;dict);
avformat_close_input(&amp;format_context);
av_dict_free(&amp;dict);</code></pre> 
<p style="text-indent:33px;">这里通过C++实现支持的编解码格式和video size，代码如下：</p> 
<pre class="has"><code class="language-cpp">AVFormatContext* format_context = avformat_alloc_context();
AVDictionary* dict = nullptr;
av_dict_set(&amp;dict, "list_options", "true", 0);
AVInputFormat* input_format = av_find_input_format("dshow");
avformat_open_input(&amp;format_context, "video=Integrated Webcam", input_format, &amp;dict); // video=video device name
avformat_close_input(&amp;format_context);
av_dict_free(&amp;dict);</code></pre> 
<p style="text-indent:33px;">设置编解码格式通过av_dict_set好像不能成功，这里是通过AVFormatContext的video_codec_id进行设置，通过av_dict_set设置帧率好像也不能成功。通过调用OpenCV的接口进行实时显示，代码如下：</p> 
<pre class="has"><code class="language-cpp">#include "funset.hpp"
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;fstream&gt;
#include &lt;thread&gt;
#include "common.hpp"

#ifdef __cplusplus
extern "C" {
#endif

#include &lt;libavdevice/avdevice.h&gt;
#include &lt;libavformat/avformat.h&gt;
#include &lt;libavcodec/avcodec.h&gt;
#include &lt;libswscale/swscale.h&gt;
#include &lt;libavutil/mem.h&gt;
#include &lt;libavutil/imgutils.h&gt;

#ifdef __cplusplus
}
#endif

#include &lt;opencv2/opencv.hpp&gt;

#ifdef _MSC_VER
int test_ffmpeg_decode_dshow()
{
	avdevice_register_all();

	AVCodecID id = AV_CODEC_ID_MJPEG;
	AVCodec* encoder_id = avcodec_find_encoder(id);
	AVCodec* decoder_id = avcodec_find_decoder(id);
	if (!encoder_id || !decoder_id) {
		fprintf(stderr, "codec not found: %d\n", id);
		return -1;
	}

	AVFormatContext* format_context = avformat_alloc_context();
	format_context-&gt;video_codec_id = id; // 指定编解码格式

	AVInputFormat* input_format = av_find_input_format("dshow");
	AVDictionary* dict = nullptr;
	//if (av_dict_set(&amp;dict, "vcodec"/*"input_format"*/, "mjpeg", 0) &lt; 0) fprintf(stderr, "fail to av_dict_set: line: %d\n", __LINE__); // 通过av_dict_set设置编解码格式好像不起作用
	if (av_dict_set(&amp;dict, "video_size", "320x240", 0) &lt; 0) fprintf(stderr, "fail to av_dict_set: line: %d\n", __LINE__);
	//if (av_dict_set(&amp;dict, "r", "25", 0) &lt; 0) fprintf(stderr, "fail to av_dict_set: line: %d\n", __LINE__); // 通过av_dict_set设置帧率好像不起作用
	int ret = avformat_open_input(&amp;format_context, "video=Integrated Webcam", input_format, &amp;dict);
	if (ret != 0) {
		fprintf(stderr, "fail to avformat_open_input: %d\n", ret);
		return -1;
	}

	ret = avformat_find_stream_info(format_context, nullptr);
	if (ret &lt; 0) {
		fprintf(stderr, "fail to get stream information: %d\n", ret);
		return -1;
	}

	int video_stream_index = -1;
	for (unsigned int i = 0; i &lt; format_context-&gt;nb_streams; ++i) {
		const AVStream* stream = format_context-&gt;streams[i];
		if (stream-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
			video_stream_index = i;
			fprintf(stdout, "type of the encoded data: %d, dimensions of the video frame in pixels: width: %d, height: %d, pixel format: %d\n",
				stream-&gt;codecpar-&gt;codec_id, stream-&gt;codecpar-&gt;width, stream-&gt;codecpar-&gt;height, stream-&gt;codecpar-&gt;format);
		}
	}

	if (video_stream_index == -1) {
		fprintf(stderr, "no video stream\n");
		return -1;
	}

	fprintf(stdout, "frame rate: %f\n", av_q2d(format_context-&gt;streams[video_stream_index]-&gt;r_frame_rate));

	AVCodecParameters* codecpar = format_context-&gt;streams[video_stream_index]-&gt;codecpar;
	const AVCodec* codec = avcodec_find_decoder(codecpar-&gt;codec_id);
	if (!codec) {
		fprintf(stderr, "fail to avcodec_find_decoder\n");
		return -1;
	}

	if (codecpar-&gt;codec_id != id) {
		fprintf(stderr, "this test code only support mjpeg encode: %d\n", codecpar-&gt;codec_id);
		return -1;
	}

	AVCodecContext* codec_context = avcodec_alloc_context3(codec);
	if (!codec_context) {
		fprintf(stderr, "fail to avcodec_alloc_context3\n");
		return -1;
	}

	codec_context-&gt;pix_fmt = AVPixelFormat(codecpar-&gt;format);
	codec_context-&gt;height = codecpar-&gt;height;
	codec_context-&gt;width = codecpar-&gt;width;
	codec_context-&gt;thread_count = 16;
	ret = avcodec_open2(codec_context, codec, nullptr);
	if (ret != 0) {
		fprintf(stderr, "fail to avcodec_open2: %d\n", ret);
		return -1;
	}

	AVPixelFormat dst_pixel_format = AV_PIX_FMT_BGR24;
	AVFrame* frame = av_frame_alloc();
	AVPacket* packet = (AVPacket*)av_malloc(sizeof(AVPacket));
	SwsContext* sws_context = sws_getContext(codec_context-&gt;width, codec_context-&gt;height, codec_context-&gt;pix_fmt, codec_context-&gt;width, codec_context-&gt;height, dst_pixel_format, 0, nullptr, nullptr, nullptr);
	if (!frame || !packet || !sws_context) {
		fprintf(stderr, "fail to alloc\n");
		return -1;
	}

	uint8_t *bgr_data[4];
	int bgr_linesize[4];
	av_image_alloc(bgr_data, bgr_linesize, codec_context-&gt;width, codec_context-&gt;height, dst_pixel_format, 1);
	cv::Mat mat(codec_context-&gt;height, codec_context-&gt;width, CV_8UC3);
	const char* winname = "dshow mjpeg video";
	cv::namedWindow(winname);

	while (1) {
		ret = av_read_frame(format_context, packet);
		if (ret &gt;= 0 &amp;&amp; packet-&gt;stream_index == video_stream_index &amp;&amp; packet-&gt;size &gt; 0) {
			ret = avcodec_send_packet(codec_context, packet);
			if (ret &lt; 0) {
				fprintf(stderr, "##### fail to avcodec_send_packet: %d\n", ret);
				av_packet_unref(packet);
				continue;
			}

			ret = avcodec_receive_frame(codec_context, frame);
			if (ret &lt; 0) {
				fprintf(stderr, "##### fail to avcodec_receive_frame: %d\n", ret);
				av_packet_unref(packet);
				continue;
			}

			sws_scale(sws_context, frame-&gt;data, frame-&gt;linesize, 0, codec_context-&gt;height, bgr_data, bgr_linesize);
			mat.data = bgr_data[0];
			cv::imshow(winname, mat);
		} else if (ret &lt; 0 || packet-&gt;size &lt;= 0) {
			fprintf(stderr, "##### fail to av_read_frame: %d, packet size: %d\n", ret, packet-&gt;size);
			continue;
		}

		av_packet_unref(packet);

		int key = cv::waitKey(30);
		if (key == 27) break;
	}

	cv::destroyWindow(winname);
	sws_freeContext(sws_context);
	av_frame_free(&amp;frame);
	av_freep(packet);
	av_freep(&amp;bgr_data[0]);
	avformat_close_input(&amp;format_context);
	av_dict_free(&amp;dict);
}

	fprintf(stdout, "test finish\n");
	return 0;
}
#else
int test_ffmpeg_decode_dshow()
{
	fprintf(stderr, "Error: this test code only support windows platform\n");
	return -1;
}
#endif</code></pre> 
<p style="text-indent:33px;">执行结果如下：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/ba/77/4oz0li6p_o.png"></p> 
<p style="text-indent:33px;"><strong>GitHub</strong>：<a href="https://github.com/fengbingchun/OpenCV_Test">https://github.com/fengbingchun/OpenCV_Test</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3eb400255269b276919074d1a5b93fa9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">elementui表格插槽用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/48345630391e5d5eac47b5cc275d5946/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小程序微信登录获取unionid</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>