<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动手学ROS2-2节点通信-话题之RCLCPP实现 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="动手学ROS2-2节点通信-话题之RCLCPP实现" />
<meta property="og:description" content="说明：本文基于ubuntu22.04和ros2 humble版本
目录
一、话题入门
1.节点通信
2.话题基础概念
2.1话题通信采取的是订阅发布模型
2.2消息接口，同一个话题，所有的发布者和接收者必须使用相同消息接口。
2.3GUI-RQT工具
2.4CLI工具
二、话题之RCLCPP实现
1. 创建节点
2.编写发布者
2.1导入消息接口
2.2确定话题名称和服务质量Qos
2.3使用定时器定时发布数据
2.4运行测试
3编写订阅者
3.1创建订阅节点
​编辑
3.2查看订阅者API文档
3.3编写修改相关文件
3.4运行测试
4订阅发布测试
一、话题入门 1.节点通信 通信的目的是在计算机系统中实现不同组件、进程或设备之间的信息和数据传递。
通信的原理涉及两个主要方面：通信协议和通信方式。
通信协议定义了数据的格式、传输方式、错误检测和纠正等规则，以确保可靠的数据传输。
通信方式涉及了不同的通信介质和技术，包括网络通信和进程间通信（IPC）。
基于TCP/UDP的网络通信方式：通过计算机网络进行信息交换。
基于共享内存的进程间通信(IPC)方式：通过共享内存区域在同一计算机系统内的不同进程之间进行通信。
ROS 2用于通讯的默认中间件是DDS。在DDS中，不同逻辑网络共享物理网络的主要机制称为域(Domain) ID。同一域上的ROS 2节点可以自由地相互发现并发送消息，而不同域上的ROS 2节点则不能。所有ROS 2节点默认使用域ID为0。为了避免在同一网络上运行ROS 2的不同计算机组之间互相干扰，应为每组设置不同的域ID。
2.话题基础概念 2.1话题通信采取的是订阅发布模型 节点发布数据到某个话题上，节点就可以通过订阅话题拿到数据。
​
2.2消息接口，同一个话题，所有的发布者和接收者必须使用相同消息接口。 为了方便发送者和接收者进行数据的交换，ROS2帮我们在数据传递时做好了消息的序列化和反序列化。
2.3GUI-RQT工具 终端输入命令，可以显示节点间通信模型
rqt_graph
​
2.4CLI工具 ros2 topic -h
ros2 topic list 返回系统中当前活动的所有主题的列表
ros2 topic list -t 返回系统中当前活动的所有主题的列表时，增加消息类型
ros2 topic echo &lt;话题&gt; 打印实时话题内容
ros2 topic info &lt;话题&gt; 查看话题属性信息" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/19f3868d9496c141fbf91720f6277ef9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-13T10:59:13+08:00" />
<meta property="article:modified_time" content="2023-07-13T10:59:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动手学ROS2-2节点通信-话题之RCLCPP实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>说明：本文基于ubuntu22.04和ros2 humble版本</p> 
<p><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%AF%9D%E9%A2%98%E5%85%A5%E9%97%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%AF%9D%E9%A2%98%E5%85%A5%E9%97%A8" rel="nofollow">一、话题入门</a></p> 
<p id="1.%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1-toc" style="margin-left:40px;"><a href="#1.%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1" rel="nofollow">1.节点通信</a></p> 
<p id="2.%E8%AF%9D%E9%A2%98-toc" style="margin-left:40px;"><a href="#2.%E8%AF%9D%E9%A2%98" rel="nofollow">2.话题基础概念</a></p> 
<p id="2.1%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E9%87%87%E5%8F%96%E7%9A%84%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2.1%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E9%87%87%E5%8F%96%E7%9A%84%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9E%8B" rel="nofollow">2.1话题通信采取的是订阅发布模型</a></p> 
<p id="%C2%A02.2%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%90%8C%E4%B8%80%E4%B8%AA%E8%AF%9D%E9%A2%98%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A02.2%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%90%8C%E4%B8%80%E4%B8%AA%E8%AF%9D%E9%A2%98%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%E3%80%82" rel="nofollow"> 2.2消息接口，同一个话题，所有的发布者和接收者必须使用相同消息接口。</a></p> 
<p id="2.3GUI-RQT%E5%B7%A5%E5%85%B7-toc" style="margin-left:80px;"><a href="#2.3GUI-RQT%E5%B7%A5%E5%85%B7" rel="nofollow">2.3GUI-RQT工具</a></p> 
<p id="2.4CLI%E5%B7%A5%E5%85%B7-toc" style="margin-left:80px;"><a href="#2.4CLI%E5%B7%A5%E5%85%B7" rel="nofollow">2.4CLI工具</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%AF%9D%E9%A2%98%E4%B9%8BRCLCPP%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%AF%9D%E9%A2%98%E4%B9%8BRCLCPP%E5%AE%9E%E7%8E%B0" rel="nofollow">二、话题之RCLCPP实现</a></p> 
<p id="1.%20%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#1.%20%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9" rel="nofollow">1. 创建节点</a></p> 
<p id="%C2%A02.%E7%BC%96%E5%86%99%E5%8F%91%E5%B8%83%E8%80%85-toc" style="margin-left:40px;"><a href="#%C2%A02.%E7%BC%96%E5%86%99%E5%8F%91%E5%B8%83%E8%80%85" rel="nofollow"> 2.编写发布者</a></p> 
<p id="2.1%E5%AF%BC%E5%85%A5%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#2.1%E5%AF%BC%E5%85%A5%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3" rel="nofollow">2.1导入消息接口</a></p> 
<p id="2.2%E7%A1%AE%E5%AE%9A%E8%AF%9D%E9%A2%98%E5%90%8D%E7%A7%B0%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8FQos-toc" style="margin-left:80px;"><a href="#2.2%E7%A1%AE%E5%AE%9A%E8%AF%9D%E9%A2%98%E5%90%8D%E7%A7%B0%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8FQos" rel="nofollow">2.2确定话题名称和服务质量Qos</a></p> 
<p id="2.3%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%8F%91%E5%B8%83%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#2.3%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%8F%91%E5%B8%83%E6%95%B0%E6%8D%AE" rel="nofollow">2.3使用定时器定时发布数据</a></p> 
<p id="%C2%A02.4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%C2%A02.4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow"> 2.4运行测试</a></p> 
<p id="3%E7%BC%96%E5%86%99%E8%AE%A2%E9%98%85%E8%80%85-toc" style="margin-left:40px;"><a href="#3%E7%BC%96%E5%86%99%E8%AE%A2%E9%98%85%E8%80%85" rel="nofollow">3编写订阅者</a></p> 
<p id="3.1%E5%88%9B%E5%BB%BA%E8%AE%A2%E9%98%85%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#3.1%E5%88%9B%E5%BB%BA%E8%AE%A2%E9%98%85%E8%8A%82%E7%82%B9" rel="nofollow">3.1创建订阅节点</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="3.2%E6%9F%A5%E7%9C%8B%E8%AE%A2%E9%98%85%E8%80%85API%E6%96%87%E6%A1%A3-toc" style="margin-left:80px;"><a href="#3.2%E6%9F%A5%E7%9C%8B%E8%AE%A2%E9%98%85%E8%80%85API%E6%96%87%E6%A1%A3" rel="nofollow">3.2查看订阅者API文档</a></p> 
<p id="3.3%E7%BC%96%E5%86%99%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#3.3%E7%BC%96%E5%86%99%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6" rel="nofollow">3.3编写修改相关文件</a></p> 
<p id="3.4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#3.4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">3.4运行测试</a></p> 
<p id="%C2%A04%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%C2%A04%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%B5%8B%E8%AF%95" rel="nofollow"> 4订阅发布测试</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E8%AF%9D%E9%A2%98%E5%85%A5%E9%97%A8">一、话题入门</h2> 
<h3 id="1.%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1">1.节点通信</h3> 
<blockquote> 
 <p>通信的目的是在计算机系统中实现不同组件、进程或设备之间的信息和数据传递。</p> 
 <p>通信的原理涉及两个主要方面：通信协议和通信方式。</p> 
 <p>通信协议定义了数据的格式、传输方式、错误检测和纠正等规则，以确保可靠的数据传输。</p> 
 <p>通信方式涉及了不同的通信介质和技术，包括网络通信和进程间通信（IPC）。</p> 
</blockquote> 
<p id="_1-基于tcpudp的网络通信方式"><strong>基于TCP/UDP的网络通信方式：</strong>通过计算机网络进行信息交换。</p> 
<p><strong>基于共享内存的进程间通信(IPC)方式：</strong>通过共享内存区域在同一计算机系统内的不同进程之间进行通信。</p> 
<blockquote> 
 <p>ROS 2用于通讯的默认中间件是DDS。在DDS中，不同逻辑网络共享物理网络的主要机制称为域(Domain) ID。同一域上的ROS 2节点可以自由地相互发现并发送消息，而不同域上的ROS 2节点则不能。所有ROS 2节点默认使用域ID为0。为了避免在同一网络上运行ROS 2的不同计算机组之间互相干扰，应为每组设置不同的域ID。</p> 
</blockquote> 
<h3 id="2.%E8%AF%9D%E9%A2%98">2.话题基础概念</h3> 
<h4 id="2.1%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E9%87%87%E5%8F%96%E7%9A%84%E6%98%AF%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><strong>2.1话题通信采取的是订阅发布模型</strong></h4> 
<p>节点发布数据到某个话题上，节点就可以通过订阅话题拿到数据。</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/3f/fd/at0SvW9t_o.png" width="503">​</p> 
<h4 id="%C2%A02.2%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%90%8C%E4%B8%80%E4%B8%AA%E8%AF%9D%E9%A2%98%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%E3%80%82"> 2.2<strong>消息接口，同一个话题，所有的发布者和接收者必须使用相同消息接口。</strong></h4> 
<p>为了方便发送者和接收者进行数据的交换，ROS2帮我们在数据传递时做好了消息的序列化和反序列化。</p> 
<h4 id="2.3GUI-RQT%E5%B7%A5%E5%85%B7"><strong>2.3GUI-RQT工具</strong></h4> 
<p>终端输入命令，可以显示节点间通信模型</p> 
<p>rqt_graph</p> 
<p><img alt="" height="743" src="https://images2.imgbox.com/a3/ad/BpKt9it7_o.png" width="963">​</p> 
<h4 id="2.4CLI%E5%B7%A5%E5%85%B7">2.4CLI工具</h4> 
<blockquote> 
 <p>ros2 topic -h</p> 
 <p>ros2 topic list      返回系统中当前活动的所有主题的列表</p> 
 <p> ros2 topic list -t  返回系统中当前活动的所有主题的列表时，增加消息类型</p> 
 <p>ros2 topic echo &lt;话题&gt;    打印实时话题内容</p> 
 <p>ros2 topic info &lt;话题&gt;     查看话题属性信息</p> 
 <p>ros2 interface show &lt;话题信息&gt;   查看话题信息的消息类型</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E8%AF%9D%E9%A2%98%E4%B9%8BRCLCPP%E5%AE%9E%E7%8E%B0">二、话题之RCLCPP实现</h2> 
<p>使用ROS2的RCLCPP客户端库来实现话题通信。</p> 
<p>RCLCPP为Node类提供了丰富的API接口，其中就包括创建话题发布者和创建话题订阅者。</p> 
<h3 id="1.%20%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><strong>1. 创建节点</strong></h3> 
<blockquote> 
 <p>创建一个控制节点和一个被控节点。</p> 
 <p><strong>控制节点</strong>创建一个话题发布者，发布控制命令（command）话题，接口类型为字符串（string），控制接点通过发布者发布控制命令（前进、后退、左转、右转、停止）。</p> 
 <p><strong>被控节点</strong>创建一个订阅者，订阅控制命令，收到控制命令后根据命令内容打印对应速度出来。</p> 
</blockquote> 
<p><img alt="" height="71" src="https://images2.imgbox.com/3f/fa/31OdCn96_o.png" width="374">​</p> 
<p>在ros2test文件夹下开启终端，依次输入下面的命令，创建<code>chapt3_ws</code>工作空间、<code>example_topic_rclcpp</code>功能包和<code>topic_publisher_01.cpp</code></p> 
<blockquote> 
 <p>mkdir -p chapt3_ws/src</p> 
 <p>cd chapt3_ws/src</p> 
 <p>ros2 pkg create example_topic_rclcpp --build-type ament_cmake --dependencies rclcpp touch example_topic_rclcpp/src/topic_publisher_01.cpp</p> 
</blockquote> 
<blockquote> 
 <ul><li>pkg create 是创建包的意思</li><li>--build-type 用来指定该包的编译类型，一共有三个可选项<code>ament_python</code>、<code>ament_cmake</code>、<code>cmake</code></li><li>--dependencies 指的是这个功能包的依赖，这里小鱼给了一个ros2的C++客户端接口<code>rclcpp</code></li></ul> 
</blockquote> 
<p>完成后的目录结构</p> 
<p><img alt="" height="330" src="https://images2.imgbox.com/7a/27/IKVbNDCV_o.png" width="385">​</p> 
<p>接着采用面向对象方式写一个最简单的节点 </p> 
<div> 
 <pre><code>#include "rclcpp/rclcpp.hpp"

class TopicPublisher01 : public rclcpp::Node
{
public:
    // 构造函数,有一个参数为节点名称
    TopicPublisher01(std::string name) : Node(name)
    {
        RCLCPP_INFO(this-&gt;get_logger(), "%s节点已经启动.", name.c_str());
    }

private:
    // 声明节点
};

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    /*创建对应节点的共享指针对象*/
    auto node = std::make_shared&lt;TopicPublisher01&gt;("topic_publisher_01");
    /* 运行节点，并检测退出信号*/
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}</code></pre> 
</div> 
<p>在CMakeLists.txt中添加可执行文件，并使用install指令将其安装到install目录</p> 
<div> 
 <pre><code>add_executable(topic_publisher_01 src/topic_publisher_01.cpp)
ament_target_dependencies(topic_publisher_01 rclcpp)

install(TARGETS
  topic_publisher_01
  DESTINATION lib/${PROJECT_NAME}
)</code></pre> 
</div> 
<p>编译在chapt3_wscpp目录下运行colcon测试</p> 
<blockquote> 
 <p>colcon build --packages-select example_topic_rclcpp        #编译节点</p> 
 <p>source install/setup.bash        #source环境</p> 
 <p>ros2 run example_topic_rclcpp topic_publisher_01</p> 
</blockquote> 
<p><img alt="" height="238" src="https://images2.imgbox.com/b6/c2/eOqzDZcb_o.png" width="742">​</p> 
<h3 id="%C2%A02.%E7%BC%96%E5%86%99%E5%8F%91%E5%B8%83%E8%80%85"> 2.编写发布者</h3> 
<p>学习使用API文档，创建发布者，需要调用<code>node</code>的成员函数<code>create_publisher</code>并传入对应的参数。</p> 
<div> 
 <p><img alt="" height="400" src="https://images2.imgbox.com/6d/48/XwCHdetA_o.png" width="1200">​</p> 
</div> 
<p> 根据API文档，创建发布者的函数，需要传入消息类型（msgT）、话题名称（topic_name）和 服务指令（qos）。</p> 
<h4 id="2.1%E5%AF%BC%E5%85%A5%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3"><strong>2.1导入消息接口</strong></h4> 
<p>消息接口是ROS2通信时必须的一部分，通过消息接口ROS2才能完成消息的序列化和反序列化</p> 
<blockquote> 
 <p><strong><code>ament_cmake</code>类型功能包</strong>导入消息接口分为三步：</p> 
 <ol><li>在<code>CMakeLists.txt</code>中导入，具体是先<code>find_packages</code>再<code>ament_target_dependencies</code>。</li><li>在<code>packages.xml</code>中导入，具体是添加<code>depend</code>标签并将消息接口写入。</li><li>在代码中导入，C++中是<code>#include"消息功能包/xxx/xxx.hpp"</code>。</li></ol> 
</blockquote> 
<p>CMakeLists.txt</p> 
<div> 
 <pre><code>find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

add_executable(topic_publisher_01 src/topic_publisher_01.cpp)
ament_target_dependencies(topic_publisher_01 rclcpp std_msgs)</code></pre> 
</div> 
<p>packages.xml</p> 
<div> 
 <pre><code>  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;

  &lt;depend&gt;rclcpp&lt;/depend&gt;
  &lt;depend&gt;std_msgs&lt;/depend&gt;

  &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;
  &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;</code></pre> 
</div> 
<p>代码源文件topic_publisher_01.cpp</p> 
<div> 
 <pre><code>#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class TopicPublisher01 : public rclcpp::Node</code></pre> 
</div> 
<h4 id="2.2%E7%A1%AE%E5%AE%9A%E8%AF%9D%E9%A2%98%E5%90%8D%E7%A7%B0%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8FQos"><strong>2.2确定话题名称和服务质量Qos</strong></h4> 
<ul><li>话题名称（topic_name）就用<code>control_command</code>。</li><li>Qos，Qos支持直接指定一个数字，这个数字对应的是<code>KeepLast</code>队列长度。一般设置成10，即如果一次性有100条消息，默认保留最新的10个，其余的都扔掉。</li></ul> 
<p> 代码源文件 topic_publisher_01.cpp </p> 
<div> 
 <pre><code>#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class TopicPublisher01 : public rclcpp::Node
{
public:
    // 构造函数,有一个参数为节点名称
    TopicPublisher01(std::string name) : Node(name)
    {
        RCLCPP_INFO(this-&gt;get_logger(), "大家好，我是%s.", name.c_str());
        // 创建发布者
        command_publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;("command", 10);
    }

private:
    // 声明话题发布者
    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr command_publisher_;
};</code></pre> 
</div> 
<h4 id="2.3%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E5%8F%91%E5%B8%83%E6%95%B0%E6%8D%AE"><strong>2.3使用定时器定时发布数据</strong></h4> 
<blockquote> 
 <p>定时器是ROS2中的一个常用功能，通过定时器可以实现按照一定周期调用某个函数以实现定时发布等逻辑。</p> 
 <p>定时器对应的类是<code> rclcpp::TimerBase</code>，调用<code>create_wall_timer</code>将返回其共享指针。</p> 
 <p>创建定时器时传入了两个参数，这两个参数都利用了C++11的新特性。</p> 
 <ul><li><code>std::chrono::milliseconds(500)</code>，代表500ms，chrono是c++ 11中的时间库，提供计时，时钟等功能。</li><li><code>std::bind(&amp;TopicPublisher01::timer_callback, this)</code>，bind() 函数的意义就像它的函数名一样，是用来绑定函数调用的某些参数的。</li></ul> 
 <p><strong>创建发布消息</strong></p> 
 <p><code>std_msgs::msg::String</code>是通过ROS2的消息文件自动生成的类，其原始消息文件内容可以通过命令行查询</p> 
 <p><strong>ROS2会将消息文件转换成一个类，并把其中的定义转换成类的成员函数。</strong></p> 
</blockquote> 
<p>编写好发布者后，通过ROS2中的定时器来设置指定的周期调用回调函数，在回调函数里实现发布数据功能。</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/f8/57/VjN3RqKa_o.png" width="1024"></p> 
<p>RCLCPP文档，找到创建定时器函数，观察参数</p> 
<ul><li>period，回调函数调用周期。</li><li>callback，回调函数。</li><li>group，调用回调函数所在的回调组，默认为nullptr。</li></ul> 
<p> 代码源文件 topic_publisher_01.cpp </p> 
<pre><code>class TopicPublisher01 : public rclcpp::Node
{
public:
    // 构造函数,有一个参数为节点名称
    TopicPublisher01(std::string name) : Node(name)
    {
        RCLCPP_INFO(this-&gt;get_logger(), "大家好，我是%s.", name.c_str());
        // 创建发布者
        command_publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;("command", 10);
        // 创建定时器，500ms为周期，定时发布
        timer_ = this-&gt;create_wall_timer(std::chrono::milliseconds(500), std::bind(&amp;TopicPublisher01::timer_callback, this));
    }

private:
    void timer_callback()
    {
        // 创建消息
        std_msgs::msg::String message;
        message.data = "forward";
        // 日志打印
        RCLCPP_INFO(this-&gt;get_logger(), "Publishing: '%s'", message.data.c_str());
        // 发布消息
        command_publisher_-&gt;publish(message);
    }
    // 声名定时器指针
    rclcpp::TimerBase::SharedPtr timer_;
    // 声明话题发布者指针
    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr command_publisher_;
};</code></pre> 
<h4 id="%C2%A02.4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"> 2.4运行测试</h4> 
<p>在chapt3_wscpp工作空间目录下，打开终端运行</p> 
<blockquote> 
 <p>colcon build --packages-select example_topic_rclcpp</p> 
 <p>source install/setup.bash</p> 
 <p>ros2 run example_topic_rclcpp topic_publisher_01</p> 
 <p></p> 
 <p>#查看话题列表</p> 
 <p>ros2 topic list</p> 
 <p>#输出话题内容</p> 
 <p>ros2 topic echo /command</p> 
</blockquote> 
<h3 id="3%E7%BC%96%E5%86%99%E8%AE%A2%E9%98%85%E8%80%85">3编写订阅者</h3> 
<p>手动创建一个节点订阅<code>/command</code>指令，并处理数据。</p> 
<h4 id="3.1%E5%88%9B%E5%BB%BA%E8%AE%A2%E9%98%85%E8%8A%82%E7%82%B9">3.1创建订阅节点</h4> 
<p>在chapt3_ws/src/example_topic_rclcpp目录下开启终端，输入以下命令创建源文件</p> 
<blockquote> 
 <p>touch src/topic_subscribe_01.cpp</p> 
</blockquote> 
<p>编写代码源文件topic_subscribe_01.cpp</p> 
<pre><code>#include "rclcpp/rclcpp.hpp"

class TopicSubscribe01 : public rclcpp::Node
{
public:
    // 构造函数,有一个参数为节点名称
    TopicSubscribe01(std::string name) : Node(name)
    {
        RCLCPP_INFO(this-&gt;get_logger(), "大家好，我是%s.", name.c_str());
    }

private:
    // 声明节点
};

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    /*创建对应节点的共享指针对象*/
    auto node = std::make_shared&lt;TopicSubscribe01&gt;("topic_subscribe_01");
    /* 运行节点，并检测退出信号*/
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}</code></pre> 
<p>CMakeLists.txt中增加编译链接</p> 
<pre><code>add_executable(topic_subscribe_01 src/topic_subscribe_01.cpp)
ament_target_dependencies(topic_subscribe_01 rclcpp)

install(TARGETS
topic_subscribe_01
  DESTINATION lib/${PROJECT_NAME}
)</code></pre> 
<p>在工作空间目录下进行编译测试</p> 
<blockquote> 
 <p>colcon build --packages-select example_topic_rclcpp</p> 
 <p>source install/setup.bash</p> 
 <p>ros2 run example_topic_rclcpp topic_subscribe_01  #首先会自动进入build文件下寻找，需要指出可执行文件所在文件夹</p> 
</blockquote> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="94" src="https://images2.imgbox.com/1f/d2/TX7xqNYd_o.png" width="730"></h4> 
<h4 id="3.2%E6%9F%A5%E7%9C%8B%E8%AE%A2%E9%98%85%E8%80%85API%E6%96%87%E6%A1%A3">3.2查看订阅者API文档</h4> 
<p> <img alt="" height="500" src="https://images2.imgbox.com/8f/73/j92Amoon_o.png" width="1193"></p> 
<p>五个参数，但后面两个都是默认的参数，我们只需要有话题名称、Qos和回调函数即可。</p> 
<h4 id="3.3%E7%BC%96%E5%86%99%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6">3.3编写修改相关文件</h4> 
<p> 编写源文件代码</p> 
<pre><code>#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"

class TopicSubscribe01 : public rclcpp::Node
{
public:
    TopicSubscribe01(std::string name) : Node(name)
    {
        RCLCPP_INFO(this-&gt;get_logger(), "大家好，我是%s.", name.c_str());
          // 创建一个订阅者订阅话题
        command_subscribe_ = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;("command", 10, std::bind(&amp;TopicSubscribe01::command_callback, this, std::placeholders::_1));
    }

private:
     // 声明一个订阅者
    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr command_subscribe_;
     // 收到话题数据的回调函数
    void command_callback(const std_msgs::msg::String::SharedPtr msg)
    {
        double speed = 0.0f;
        if(msg-&gt;data == "forward")
        {
            speed = 0.2f;
        }
        RCLCPP_INFO(this-&gt;get_logger(), "收到[%s]指令，发送速度 %f", msg-&gt;data.c_str(),speed);
    }
};</code></pre> 
<p>CMakeLists.txt中添加std_msgs依赖</p> 
<blockquote> 
 <p>ament_target_dependencies(topic_subscribe_01 rclcpp std_msgs)</p> 
</blockquote> 
<h4 id="3.4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">3.4运行测试</h4> 
<p>在工作空间目录下开启终端，编译运行订阅节点</p> 
<blockquote> 
 <p>colcon build --packages-select example_topic_rclcpp</p> 
 <p>source install/setup.bash</p> 
 <p>ros2 run example_topic_rclcpp topic_subscribe_01</p> 
</blockquote> 
<p><code>手动发布数据测试订阅者</code></p> 
<blockquote> 
 <p>ros2 topic pub /command std_msgs/msg/String "{data: forward}"</p> 
</blockquote> 
<p><img alt="" height="293" src="https://images2.imgbox.com/75/5f/FDlRlIdf_o.png" width="1200"></p> 
<h3 id="%C2%A04%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%B5%8B%E8%AF%95"> 4订阅发布测试</h3> 
<p>开启节点的先后顺序无关，节点间能够相互发现</p> 
<p>运行订阅节点</p> 
<blockquote> 
 <p>source install/setup.bash</p> 
 <p>ros2 run example_topic_rclcpp topic_subscribe_01</p> 
</blockquote> 
<p>运行发布节点</p> 
<blockquote> 
 <p>source install/setup.bash</p> 
 <p>ros2 run example_topic_rclcpp topic_publisher_01</p> 
</blockquote> 
<p>运行结果</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/39/a5/GBhmOpe1_o.png" width="1200"></p> 
<p> 打开RQT查看计算图，终端输入 rqt</p> 
<p>选择Node Graph</p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/ac/e4/LCswMich_o.png" width="778"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bfb28049e7f1794fe03191f8d5697e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python3.9，PyQt5，anaconda虚拟环境，jupyter notebook——的环境配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da372902fbbc191a100ae06a53c85ca2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【HTB系列】Bastard</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>