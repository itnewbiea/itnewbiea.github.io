<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Prometheus抓取Docker Swarm集群副本服务 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Prometheus抓取Docker Swarm集群副本服务" />
<meta property="og:description" content="dns_sd_configs在这篇博文中，我将演示如何通过在 Docker swarm 中引入一个中间 Prometheus 实例并结合几个 Prometheus 功能（主要是跨服务联合）来收集和获取所需的指标数据，从而很容易地做到这一点。
在 Docker swarm 集群中，应用程序作为服务运行。对于外部宿主机中（特指swarm 集群之外的所有东西），该服务看起来就像通过已发布端口访问的实例。但是在 swarm 内部，通常有多个运行该服务的实例（副本）。外部主动请求时，Docker 网络将到已发布服务端口路由到正在运行的副本之一。作为调用者，您无法感知被路由到服务具体实例。
如果你想拥有一个在 Docker swarm 之外运行的 Prometheus 服务器来抓取服务的指标，最简单的方法是让它主动拉取已发布服务的监控，如果服务在具有多个实例的复制模式下运行，将无法准确获得具体的实例。因为对服务的调用实际上最终在 Docker 网络负载均衡器中完成，它将抓取请求转发到一个正在运行的实例。因此，您获得的数据是其中一个服务实例的指标（您不知道是哪一个）。由于 Prometheus 会定期抓取服务指标，并且每个抓取请求都独立于之前的请求进行路由，因此下一个抓取请求可能会被路由到返回该实例指标的不同服务实例并由其响应，等等。因此，最坏的情况是 Prometheus 在每次抓取请求时都会获得一组不同的指标，不会为您提供连贯的数据。
如果 Prometheus 知道多个服务实例并可以单独抓取它们，它将为指标添加一个instance标签，并由此为每个指标和实例存储不同的时间序列。Docker swarm 在向 Prometheus 隐藏这些细节方面做得很好，至少在 swarm 之外是这样。因此，如果您将 Prometheus 本身作为 Docker swarm 中的服务运行，您可以将其dns_sd_configs功能与 Docker swarm DNS 服务发现一起使用，以单独抓取所有实例。结合 Prometheus 的跨服务联合功能，您可以从 swarm 之外的 Prometheus 服务器上抓取这些服务实例指标。
在这篇博文中，我将设置一个运行示例服务的本地 Docker swarm 集群来演示它的外观。
使用示例服务设置 Docker 群 首先，我为本地 Docker 实例初始化 swarm 模式（可以使用 再次停用docker swarm leave --force）
docker swarm init 我正在为 Mac 运行 Docker Desktop，所以这里不需要任何其他选项。有关如何在其他环境中设置本地 swarm 的详细信息，请参阅docker swarm 教程。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1bffccbeacbd6d64c0b80b4988b40f5d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-13T16:43:56+08:00" />
<meta property="article:modified_time" content="2022-04-13T16:43:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Prometheus抓取Docker Swarm集群副本服务</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><code>dns_sd_configs</code>在这篇博文中，我将演示如何通过在 Docker swarm 中引入一个中间 Prometheus 实例并结合几个 Prometheus 功能（主要是跨服务联合）来收集和获取所需的指标数据，从而很容易地做到这一点。</p> 
<blockquote> 
 <p>在 Docker swarm 集群中，应用程序作为服务运行。对于外部宿主机中（特指swarm 集群之外的所有东西），该服务看起来就像通过已发布端口访问的实例。但是在 swarm 内部，通常有多个运行该服务的实例（副本）。外部主动请求时，Docker 网络将到已发布服务端口路由到正在运行的副本之一。作为调用者，您无法感知被路由到服务具体实例。</p> 
</blockquote> 
<p>如果你想拥有一个在 Docker swarm 之外运行的 Prometheus 服务器来抓取服务的指标，最简单的方法是让它主动拉取已发布服务的监控，如果服务在具有多个实例的复制模式下运行，将无法准确获得具体的实例。因为对服务的调用实际上最终在 Docker 网络负载均衡器中完成，它将抓取请求转发到一个正在运行的实例。因此，您获得的数据是其中一个服务实例的指标（您不知道是哪一个）。由于 Prometheus 会定期抓取服务指标，并且每个抓取请求都独立于之前的请求进行路由，因此下一个抓取请求可能会被路由到返回该实例指标的不同服务实例并由其响应，等等。因此，最坏的情况是 Prometheus 在每次抓取请求时都会获得一组不同的指标，不会为您提供连贯的数据。</p> 
<p>如果 Prometheus 知道多个服务实例并可以单独抓取它们，它将为指标添加一个<code>instance</code>标签，并由此为每个指标和实例存储不同的时间序列。Docker swarm 在向 Prometheus 隐藏这些细节方面做得很好，至少在 swarm 之外是这样。因此，如果您将 Prometheus 本身作为 Docker swarm 中的服务运行，您可以将其<code>dns_sd_configs</code>功能与 Docker swarm DNS 服务发现一起使用，以单独抓取所有实例。结合 Prometheus 的<a href="https://prometheus.io/docs/prometheus/latest/federation/#cross-service-federation" rel="nofollow">跨服务联合功能</a>，您可以从 swarm 之外的 Prometheus 服务器上抓取这些服务实例指标。</p> 
<p>在这篇博文中，我将设置一个运行示例服务的本地 Docker swarm 集群来演示它的外观。</p> 
<h4><a id="_Docker_httpswwwinnoqcomenblogscrapingdockerswarmserviceinstanceswithprometheussettingupadockerswarmwithasampleservice_10"></a><a href="https://www.innoq.com/en/blog/scraping-docker-swarm-service-instances-with-prometheus/#settingupadockerswarmwithasampleservice" rel="nofollow">使用示例服务设置 Docker 群</a></h4> 
<p>首先，我为本地 Docker 实例初始化 swarm 模式（可以使用 再次停用<code>docker swarm leave --force</code>）</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> swarm init
</code></pre> 
<p>我正在为 Mac 运行 Docker Desktop，所以这里不需要任何其他选项。有关如何在其他环境中设置本地 swarm 的详细信息，请参阅<a href="https://docs.docker.com/engine/swarm/swarm-tutorial/create-swarm/" rel="nofollow">docker swarm 教程。</a></p> 
<p>一个重要的细节（不幸的是，Docker swarm 文档中似乎没有描述）是，Docker swarm DNS 服务发现不适用于默认的入口覆盖网络（我花了很长时间才弄清楚这一点，直到我发现<a href="https://forums.docker.com/t/docker-ce-swarm-service-discovery-just-does-not-work-whatsoever/47393/2" rel="nofollow">这个在 Docker 论坛中回答</a>）。所以我将首先创建一个自定义覆盖网络。</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> network create <span class="token punctuation">\</span>
    --driver overlay <span class="token punctuation">\</span>
    --attachable <span class="token punctuation">\</span>
    custom-overlay-network
</code></pre> 
<p>作为示例服务，我使用了一个 Docker 映像，其中包含一个非常基本的 Spring Boot 应用程序，并启用了 Actuator 和 Micrometer Prometheus 插件。</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">service</span> create <span class="token punctuation">\</span>
    --name sample-service <span class="token punctuation">\</span>
    --replicas <span class="token number">3</span> <span class="token punctuation">\</span>
    --network custom-overlay-network <span class="token punctuation">\</span>
    -p <span class="token number">8080</span>:8080 <span class="token punctuation">\</span>
    sample-app:latest
</code></pre> 
<p>列出在我的 swarm 中运行的所有 Docker 服务，我可以看到我<code>sample-service</code>正在运行三个实例。</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">service</span> <span class="token function">ls</span>

    ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
    kgjaw3vx1tnh        sample-service      replicated          <span class="token number">3</span>/3                 sample-app:latest   *:8080-<span class="token operator">&gt;</span><span class="token number">8080</span>/tcp
</code></pre> 
<p>我的 Spring Boot 应用程序的 8080 端口已发布，因此我还可以访问执行器指标端点</p> 
<pre><code class="prism language-bash"><span class="token function">curl</span> localhost:8080/actuator/prometheus

    <span class="token comment"># HELP jvm_gc_live_data_size_bytes Size of old generation memory pool after a full GC</span>
    <span class="token comment"># TYPE jvm_gc_live_data_size_bytes gauge</span>
    jvm_gc_live_data_size_bytes <span class="token number">0.0</span>
    <span class="token comment"># HELP jvm_classes_loaded_classes The number of classes that are currently loaded in the Java virtual machine</span>
    <span class="token comment"># TYPE jvm_classes_loaded_classes gauge</span>
    jvm_classes_loaded_classes <span class="token number">7469.0</span>
    <span class="token punctuation">..</span>.
</code></pre> 
<p>由于我的 Docker swarm 只包含一个管理器节点（我的本地机器），我可以看到所有三个副本正在运行的 Docker 容器</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">ps</span>

    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
    bc26b66080f7        sample-app:latest   <span class="token string">"java -Djava.securit…"</span>   <span class="token number">6</span> minutes ago       Up <span class="token number">6</span> minutes                            sample-service.3.hp0xkndw8mx9yoph24rhh60pl
    b4cb0a313b82        sample-app:latest   <span class="token string">"java -Djava.securit…"</span>   <span class="token number">6</span> minutes ago       Up <span class="token number">6</span> minutes                            sample-service.2.iwbagkwjpx4m6exm4w7bsj5pd
    7621dd38374a        sample-app:latest   <span class="token string">"java -Djava.securit…"</span>   <span class="token number">6</span> minutes ago       Up <span class="token number">6</span> minutes                            sample-service.1.1a208aiqnu5lttkg93j4dptbe
</code></pre> 
<p>为了查看运行中的 DNS 服务发现，我连接到在 Docker swarm 中运行的容器之一。我必须安装<code>dnsutils</code>软件包才能使用<code>nslookup</code>.</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -ti bc26b66080f7 /bin/sh

<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> dnsutils -y
</code></pre> 
<p>查找服务名称本身，我得到一个虚拟 IP 地址</p> 
<pre><code class="prism language-bash"><span class="token function">nslookup</span> sample-service

    Server:   <span class="token number">127.0</span>.0.11
    Address:  <span class="token number">127.0</span>.0.11<span class="token comment">#53</span>

    Non-authoritative answer:
    Name:     sample-service
    Address:  <span class="token number">10.0</span>.1.2
</code></pre> 
<p>要解析在我的 Docker 群中运行的所有服务副本的虚拟 IP 地址，我必须查找<code>tasks.&lt;service name&gt;</code>域名（请参阅<a href="https://docs.docker.com/network/overlay/#container-discovery" rel="nofollow">Docker 覆盖网络文档</a>）</p> 
<pre><code class="prism language-bash"><span class="token function">nslookup</span> tasks.sample-service

    Server:   <span class="token number">127.0</span>.0.11
    Address:  <span class="token number">127.0</span>.0.11<span class="token comment">#53</span>

    Non-authoritative answer:
    Name:     tasks.sample-service
    Address:  <span class="token number">10.0</span>.1.4
    Name:     tasks.sample-service
    Address:  <span class="token number">10.0</span>.1.3
    Name:     tasks.sample-service
    Address:  <span class="token number">10.0</span>.1.5
</code></pre> 
<p>这个 DNS 服务发现功能正是运行在 Docker 群中的 Prometheus 实例可以用来抓取所有这些服务实例的功能（我将<code>swarm-prometheus</code>在其余文本中提到这个实例）。</p> 
<h4><a id="_swarm_httpswwwinnoqcomenblogscrapingdockerswarmserviceinstanceswithprometheusscrapingtheserviceinstanceswithintheswarm_114"></a><a href="https://www.innoq.com/en/blog/scraping-docker-swarm-service-instances-with-prometheus/#scrapingtheserviceinstanceswithintheswarm" rel="nofollow">在 swarm 中抓取服务实例</a></h4> 
<p>为了设置<code>swarm-prometheus</code>服务，我基于最新的官方 Prometheus 镜像构建了一个 Docker 镜像，并添加了我自己的配置文件。</p> 
<pre><code class="prism language-bash">FROM prom/prometheus:latest
ADD prometheus.yml /etc/prometheus/
</code></pre> 
<p>配置文件中有趣的部分是<code>swarm-service</code>我添加的抓取作业。我使用 a <code>dns_sd_config</code>（有关详细信息，请参阅<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#dns_sd_config" rel="nofollow">文档</a>）通过执行 DNS 查询来查找抓取目标。我需要执行 A 类 DNS 查询，因为查询只返回服务实例的 IP 地址，所以我必须告诉 Prometheus 实例正在侦听的端口以及指标端点的路径。</p> 
<pre><code class="prism language-bash">scrape_configs:
  <span class="token punctuation">..</span>.
  - job_name: <span class="token string">'swarm-service'</span>
    dns_sd_configs:
      - names:
          - <span class="token string">'tasks.sample-service'</span>
        type: <span class="token string">'A'</span>
        port: <span class="token number">8080</span>
    metrics_path: <span class="token string">'/actuator/prometheus'</span>
</code></pre> 
<p>构建图像后，我创建了<code>swarm-prometheus</code>服务</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> build -t swarm-prometheus <span class="token builtin class-name">.</span>

<span class="token function">docker</span> <span class="token function">service</span> create <span class="token punctuation">\</span>
    --replicas <span class="token number">1</span> <span class="token punctuation">\</span>
    --name swarm-prometheus <span class="token punctuation">\</span>
    --network custom-overlay-network <span class="token punctuation">\</span>
    -p <span class="token number">9090</span>:9090 <span class="token punctuation">\</span>
    swarm-prometheus:latest
</code></pre> 
<p>当我打开 Prometheus Web UI 并导航到“Status -&gt; Targets”时，我可以看到我的配置按预期工作</p> 
<p><img src="https://images2.imgbox.com/e3/c5/SOMho7eT_o.png" alt="图1">图 1 – swarm-prometheus Web UI 中配置的抓取作业的状态</p> 
<p>对示例应用程序编写的指标之一执行基本查询，我得到三个结果时间序列，一个用于我的每个实例。由 prometheus 抓取作业添加的<code>instance</code>标签包含相应服务实例的 IP 和端口。</p> 
<p><img src="https://images2.imgbox.com/50/b7/gNOCPuzU_o.png" alt="图 2">图 2 - 具有三个结果时间序列的基本 Prometheus 查询</p> 
<p>此时，我的所有服务实例的指标都收集在<code>swarm-prometheus</code>. 作为下一步，我想让它们进入在 swarm 之外运行的 Prometheus 服务器（我将<code>host-prometheus</code>在此处引用它）。</p> 
<h4><a id="_federate__Prometheus_httpswwwinnoqcomenblogscrapingdockerswarmserviceinstanceswithprometheususingfederatetoscrapethemetricsfromanotherprometheus_160"></a><a href="https://www.innoq.com/en/blog/scraping-docker-swarm-service-instances-with-prometheus/#usingfederatetoscrapethemetricsfromanotherprometheus" rel="nofollow">使用 federate 从另一个 Prometheus 抓取指标</a></h4> 
<p>Prometheus 提供了一个<code>/federate</code>端点，可用于从另一个 Prometheus 实例中抓取选定的时间序列集（有关详细信息，请参阅<a href="https://prometheus.io/docs/prometheus/latest/federation/#cross-service-federation" rel="nofollow">文档</a>）。端点需要一个或多个即时向量选择器来指定请求的时间序列。</p> 
<p>我想为我的抓取作业收集的所有时间序列调用和查询的<code>/federate</code>端点（我使用with和选项以便能够使用未编码的参数值）<code>swarm-prometheus``swarm-service``curl``-G``--data-urlencode</code></p> 
<pre><code class="prism language-bash"><span class="token function">curl</span> -G <span class="token string">"http://localhost:9090/federate"</span> --data-urlencode <span class="token string">'match[]={job="swarm-service"}'</span>

    <span class="token comment"># TYPE jvm_buffer_count_buffers untyped</span>
    jvm_buffer_count_buffers<span class="token punctuation">{<!-- --></span>id<span class="token operator">=</span><span class="token string">"direct"</span>,instance<span class="token operator">=</span><span class="token string">"10.0.1.3:8080"</span>,job<span class="token operator">=</span><span class="token string">"swarm-service"</span><span class="token punctuation">}</span> <span class="token number">10</span> <span class="token number">1586866971856</span>
    jvm_buffer_count_buffers<span class="token punctuation">{<!-- --></span>id<span class="token operator">=</span><span class="token string">"direct"</span>,instance<span class="token operator">=</span><span class="token string">"10.0.1.4:8080"</span>,job<span class="token operator">=</span><span class="token string">"swarm-service"</span><span class="token punctuation">}</span> <span class="token number">10</span> <span class="token number">1586866975100</span>
    jvm_buffer_count_buffers<span class="token punctuation">{<!-- --></span>id<span class="token operator">=</span><span class="token string">"direct"</span>,instance<span class="token operator">=</span><span class="token string">"10.0.1.5:8080"</span>,job<span class="token operator">=</span><span class="token string">"swarm-service"</span><span class="token punctuation">}</span> <span class="token number">10</span> <span class="token number">1586866976176</span>
    jvm_buffer_count_buffers<span class="token punctuation">{<!-- --></span>id<span class="token operator">=</span><span class="token string">"mapped"</span>,instance<span class="token operator">=</span><span class="token string">"10.0.1.3:8080"</span>,job<span class="token operator">=</span><span class="token string">"swarm-service"</span><span class="token punctuation">}</span> <span class="token number">0</span> <span class="token number">1586866971856</span>
    jvm_buffer_count_buffers<span class="token punctuation">{<!-- --></span>id<span class="token operator">=</span><span class="token string">"mapped"</span>,instance<span class="token operator">=</span><span class="token string">"10.0.1.5:8080"</span>,job<span class="token operator">=</span><span class="token string">"swarm-service"</span><span class="token punctuation">}</span> <span class="token number">0</span> <span class="token number">1586866976176</span>
    jvm_buffer_count_buffers<span class="token punctuation">{<!-- --></span>id<span class="token operator">=</span><span class="token string">"mapped"</span>,instance<span class="token operator">=</span><span class="token string">"10.0.1.4:8080"</span>,job<span class="token operator">=</span><span class="token string">"swarm-service"</span><span class="token punctuation">}</span> <span class="token number">0</span> <span class="token number">1586866975100</span>
    <span class="token punctuation">..</span>.
</code></pre> 
<p>我唯一需要做的<code>host-prometheus</code>就是添加一个适当的抓取作业来请求该<code>/federate</code>端点。</p> 
<pre><code class="prism language-bash">scrape_configs:
  <span class="token punctuation">..</span>.
  - job_name: <span class="token string">'swarm-prometheus'</span>
    honor_labels: <span class="token boolean">true</span>
    metrics_path: <span class="token string">'/federate'</span>
    params:
      <span class="token string">'match[]'</span><span class="token builtin class-name">:</span>
        - <span class="token string">'{job="swarm-service"}'</span>
    static_configs:
      - targets:
        - <span class="token string">'swarm-prometheus:9090'</span>
</code></pre> 
<p>因为我将<code>host-prometheus</code>在 Docker 中运行，连接到与我的 swarm 相同的网络，所以我可以使用<code>swarm-prometheus</code>服务名称作为主机名。在现实世界的环境中，我可能不得不找到另一种访问<code>swarm-prometheus</code>服务的方法，例如使用一个 docker swarm 节点的 IP 地址和发布的端口。</p> 
<p>激活<code>honor_labels</code>标志确保 Prometheus 保留已包含在已抓取指标中的<code>job</code>和<code>instance</code>标签，并且不会用自己的值覆盖它们（有关详细信息，请参阅<a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config" rel="nofollow"><code>scrape_config</code>文档</a>）。</p> 
<p>构建并运行后，<code>host-prometheus</code>我可以再次检查目标状态页面以查看抓取作业是否成功运行</p> 
<pre><code class="prism language-bash"><span class="token function">docker</span> build -t host-prometheus <span class="token builtin class-name">.</span>

<span class="token function">docker</span> run -d <span class="token punctuation">\</span>
    --network custom-overlay-network <span class="token punctuation">\</span>
    -p <span class="token number">9999</span>:9090 <span class="token punctuation">\</span>
    host-prometheus:latest
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/1c/HaLNOi0T_o.png" alt="图 3">图 3 – host-prometheus Web UI 中配置的抓取作业的状态</p> 
<p><code>host-prometheus</code>现在我可以在我的Web UI中执行与以前相同的 Prometheus 查询，并获得三个结果时间序列。</p> 
<p>所以，已经是这样了。只需在 docker swarm 中设置一个中间 Prometheus 实例并结合几个现有功能，就可以很容易地将所有 swarm 服务实例的指标获取到 Prometheus 服务器中，即使它必须在 swarm 之外运行。</p> 
<h4><a id="httpswwwinnoqcomenblogscrapingdockerswarmserviceinstanceswithprometheussomefinetuning_216"></a><a href="https://www.innoq.com/en/blog/scraping-docker-swarm-service-instances-with-prometheus/#somefinetuning" rel="nofollow">优化</a></h4> 
<p>在我当前的项目中实施上述设置后，我提出了一些我认为值得分享的改进。</p> 
<p>如果您在 docker swarm 中运行多个不同的 Spring Boot 服务，所有服务都在默认端口 8080 上进行侦听，那么为每个服务设置一个专用的<code>swarm-prometheus</code>抓取作业是非常多余的。每个服务唯一需要更改的是请求的域名 ( <code>tasks.&lt;service name&gt;</code>)。而且，您可能已经注意到，可以在<code>dns_sd_configs</code>. 所以我们可以配置一个覆盖所有现有服务的抓取作业</p> 
<pre><code class="prism language-yml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'swarm-services'</span>
    <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> <span class="token string">'/actuator/prometheus'</span>
    <span class="token key atrule">dns_sd_configs</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">names</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token string">'tasks.sample-service-1'</span>
          <span class="token punctuation">-</span> <span class="token string">'tasks.sample-service-2'</span>
          <span class="token punctuation">-</span> <span class="token punctuation">...</span>
        <span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">'A'</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
</code></pre> 
<p>但是，这样做我们可能会遇到另一个问题。使用旧配置，每个服务有一个抓取作业，我们能够相应地命名抓取作业并使用<code>job</code>标签来识别/过滤不同服务的指标。现在，有了一个通用的抓取工作，我们必须为此找到另一种解决方案。</p> 
<p>幸运的是，我们在 Spring Boot 应用程序中用于提供 Prometheus 指标端点的库 Micrometer 可以轻松配置为向所有书面指标添加自定义标签。通过将以下行添加到<code>application.properties</code>我们每个 Spring Boot 服务的配置文件（例如）中，一个以<code>service</code>包含服务名称（此处）的静态值命名的标签<code>sample-service-1</code>被添加到我们的服务写入的所有指标中。</p> 
<pre><code class="prism language-bash">management.metrics.tags.service<span class="token operator">=</span>sample-service-1
</code></pre> 
<p>最后，如果您在 Prometheus 之上使用<a href="https://grafana.com/" rel="nofollow">Grafana</a><code>instance</code>，则包含服务实例的 IP 地址和端口（例如<code>10.0.1.3:8080</code>）的标签值将被证明是有问题的。如果您想将它们用作仪表板变量（例如，为所有实例重复面板或为一个具体实例过滤数据）这将不起作用，因为值中的点和冒号（这些值将中断对底层 Prometheus 的数据请求因为它们不是由 Grafana 编码的 URL）。我们必须将它们转换为问题较少的格式才能以这种方式使用它们。我们可以通过在抓取作业配置中添加一个<code>metric_relabel_configs</code>来做到这一点<code>swarm-prometheus</code></p> 
<pre><code class="prism language-yml"><span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'swarm-services'</span>
    <span class="token key atrule">metrics_path</span><span class="token punctuation">:</span> <span class="token string">'/actuator/prometheus'</span>
    <span class="token key atrule">dns_sd_configs</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">names</span><span class="token punctuation">:</span>
          <span class="token punctuation">-</span> <span class="token string">'tasks.sample-service-1'</span>
          <span class="token punctuation">-</span> <span class="token string">'tasks.sample-service-2'</span>
          <span class="token punctuation">-</span> <span class="token punctuation">...</span>
        <span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">'A'</span>
        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>
    <span class="token key atrule">metric_relabel_configs</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">source_labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> instance <span class="token punctuation">]</span>
        <span class="token key atrule">regex</span><span class="token punctuation">:</span> <span class="token string">'^([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)\:([0-9]+)$'</span>
        <span class="token key atrule">replacement</span><span class="token punctuation">:</span> <span class="token string">'${1}_${2}_${3}_${4}'</span>
        <span class="token key atrule">target_label</span><span class="token punctuation">:</span> instance
</code></pre> 
<p>此配置采用<code>source_labels</code>(here <code>instance</code>) 的所有值，将给定值应用于每个<code>regex</code>值，用给定表达式<code>replacement</code>替换值（使用由覆盖原始值）到指标中。因此，旧值将转换为对 Grafana 而言问题较小的值。<code>${1}``${2}``regex``target_label``instance``10.0.1.3:8080``10_0_1_3</code></p> 
<hr> 
<p>更新：从 Prometheus 2.20 开始，还有一个可用的<a href="https://prometheus.io/docs/guides/dockerswarm/" rel="nofollow">Docker Swarm 服务发现</a>可以用来代替本文中描述的 DNS 服务发现。感谢<a href="https://twitter.com/roidelapluie" rel="nofollow">Julien Pivoto</a>向我介绍了新功能。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e84430f5329507a5194c233e3ad2b5f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于CNN训练时loss停留在0.69，acc为0.5左右的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d86aea2660e3c1c77a983a25299532b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nginx 配置 解决iframe 跨域问题 cookie失效问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>