<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS基础之修饰符 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS基础之修饰符" />
<meta property="og:description" content="一、Objective-C @automic：原子的，表示线程安全，目的是确保其他线程不在同一时间内访问相同的资源；
@nonatomic：非原子的，表示线程不安全，可以在不同位置读写属性的值；
@readwrite：编译器会为属性生成get和set方法；
@readonly：编译器只生成get方法；
@protected：缺省，受保护的成员变量；
@public：公开的成员变量；
@private：私有成员变量；
@copy：copy，会重新分配内存；
block分为全局block、堆block和栈block；
方法是在内存的栈区，每个方法都是在被调用的时候从硬盘到内存，然后去执行，执行完就消失；
Objective-C中的类对象（堆区），block（栈区）当使用copy修饰时，系统会把block拷贝到堆区，这样属性就拥有block的所有权保证block不会提前释放；
@weak：不增加引用计数，也不持有对象，ARC中使用，只可修饰对象；RunTime维护了一个weak表，用于存储指向某个对象的所有weak指针，weak表是一个hash table，key为所指对象的地址，value是weak指针的地址数组；
初始化时，RunTime会调用objc_initWeak初始化一个新的weak指针指向对象的地址，添加引用时，objc_initWeak函数会调用objc_storeWeak函数更新指针指向，创建对应的weak table，释放时，调用clearDeallocating根据对象地址获取所有的weak指针地址的数组，遍历数组把数据至空，最后将weak table中这个entry删除并清理对象记录；
在xib/storyboard中的控件使用weak修饰；
@assign：修饰基本数据类型，分配在栈上，由系统分配和释放；
@strong：强引用；
__block：如果可以访问局部变量但是不能修改局部变量可以使用，编译器会将__block变量包装成一个对象，变成对象后就可以根据指针地址在block内部去修改外部的变量；
__strong：对变量强引用；
unsafe_unretained：在所修饰的对象被释放后，该指针就变成了野指针；
@assign：不会使引用计数加1，直接赋值，可修饰对象和基本数据类型；
二、Swift let修饰常量；
var修饰变量；
typealias修饰类型别名；
func修饰函数声明；
inout修饰输入输出参数（copy-in copy-out），函数调用时，参数的值被copy；
函数内部时，copy的值被修改；
函数返回时，copy的值被赋值给原参数；
**_**命名的参数被显式忽略；
**…**参数基本类型名称后紧跟三个点，会被视为可变参数；
mutating自身修改，Enum或extension的方法如果会修改self，需要以mutating标记；
override重写超类中的方法；
static类型方法，如果是class中的方法使用static或class final修饰则不可被重写，class中使用class修饰的方法则可被重写；
throws抛出错误的函数和方法；
rethrows重抛错误的函数和方法；
async异步函数和方法；
Never表示函数或方法不会返回给它的调用者（不归函数）；
Struct结构体声明、Enum枚举声明、Class类声明、Actor声明、Protocol协议声明、extension拓展声明、Associatedtype协议关联类型声明、Subscript下标声明、init构造器声明（init?可失败构造器）、convenience便利构造器；
required子类必须实现；
deinit析构器声明；
operator运算符声明（infix中缀、prefix前缀、postfix后缀），使用于运算符重载；
open所有命名空间可访问、继承和重写；
public所有命名空间内可访问，但其他命名空间不能继承和重写；
internal默认访问级别，可以访问同一命名空间，但其他实体不能访问该实体；
fileprivate文件内私有；
private类私有；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/94acd116201e77ac21bb70f30581bea9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T09:31:47+08:00" />
<meta property="article:modified_time" content="2024-01-06T09:31:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS基础之修饰符</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h6><a id="ObjectiveC_0"></a>一、Objective-C</h6> 
<p><strong>@automic</strong>：原子的，表示线程安全，目的是确保其他线程不在同一时间内访问相同的资源；<br> <strong>@nonatomic</strong>：非原子的，表示线程不安全，可以在不同位置读写属性的值；<br> <strong>@readwrite</strong>：编译器会为属性生成get和set方法；<br> <strong>@readonly</strong>：编译器只生成get方法；<br> <strong>@protected</strong>：缺省，受保护的成员变量；<br> <strong>@public</strong>：公开的成员变量；<br> <strong>@private</strong>：私有成员变量；<br> <strong>@copy</strong>：copy，会重新分配内存；<br> block分为全局block、堆block和栈block；<br> 方法是在内存的栈区，每个方法都是在被调用的时候从硬盘到内存，然后去执行，执行完就消失；<br> Objective-C中的类对象（堆区），block（栈区）当使用copy修饰时，系统会把block拷贝到堆区，这样属性就拥有block的所有权保证block不会提前释放；<br> <strong>@weak</strong>：<a href="https://blog.csdn.net/weixin_42979360/article/details/135302034?spm=1001.2014.3001.5501">不增加引用计数，也不持有对象，ARC中使用，只可修饰对象；RunTime维护了一个weak表，用于存储指向某个对象的所有weak指针，weak表是一个hash table，key为所指对象的地址，value是weak指针的地址数组；<br> 初始化时，RunTime会调用objc_initWeak初始化一个新的weak指针指向对象的地址，添加引用时，objc_initWeak函数会调用objc_storeWeak函数更新指针指向，创建对应的weak table，释放时，调用clearDeallocating根据对象地址获取所有的weak指针地址的数组，遍历数组把数据至空，最后将weak table中这个entry删除并清理对象记录</a>；<br> 在xib/storyboard中的控件使用weak修饰；<br> <strong>@assign</strong>：修饰基本数据类型，分配在栈上，由系统分配和释放；<br> <strong>@strong</strong>：强引用；<br> <strong>__block</strong>：如果可以访问局部变量但是不能修改局部变量可以使用，编译器会将__block变量包装成一个对象，变成对象后就可以根据指针地址在block内部去修改外部的变量；<br> <strong>__strong</strong>：对变量强引用；<br> <strong>unsafe_unretained</strong>：在所修饰的对象被释放后，该指针就变成了野指针；<br> <strong>@assign</strong>：不会使引用计数加1，直接赋值，可修饰对象和基本数据类型；</p> 
<h6><a id="Swift_21"></a>二、Swift</h6> 
<p><strong>let</strong>修饰常量；<br> <strong>var</strong>修饰变量；<br> <strong>typealias</strong>修饰类型别名；<br> <strong>func</strong>修饰函数声明；<br> <strong>inout</strong>修饰输入输出参数（copy-in copy-out），函数调用时，参数的值被copy；<br> 函数内部时，copy的值被修改；<br> 函数返回时，copy的值被赋值给原参数；<br> **_**命名的参数被显式忽略；<br> **…**参数基本类型名称后紧跟三个点，会被视为可变参数；<br> <strong>mutating</strong>自身修改，Enum或extension的方法如果会修改self，需要以mutating标记；<br> <strong>override</strong>重写超类中的方法；<br> <strong>static</strong>类型方法，如果是class中的方法使用static或class final修饰则不可被重写，class中使用class修饰的方法则可被重写；<br> <strong>throws</strong>抛出错误的函数和方法；<br> <strong>rethrows</strong>重抛错误的函数和方法；<br> <strong>async</strong>异步函数和方法；<br> <strong>Never</strong>表示函数或方法不会返回给它的调用者（不归函数）；<br> <strong>Struct</strong>结构体声明、<strong>Enum</strong>枚举声明、<strong>Class</strong>类声明、<strong>Actor</strong>声明、<strong>Protocol</strong>协议声明、<strong>extension</strong>拓展声明、<strong>Associatedtype</strong>协议关联类型声明、<strong>Subscript</strong>下标声明、<strong>init</strong>构造器声明（init?可失败构造器）、<strong>convenience</strong>便利构造器；<br> <strong>required</strong>子类必须实现；<br> <strong>deinit</strong>析构器声明；<br> <strong>operator</strong>运算符声明（<strong>infix</strong>中缀、<strong>prefix</strong>前缀、<strong>postfix</strong>后缀），使用于运算符重载；<br> <strong>open</strong>所有命名空间可访问、继承和重写；<br> <strong>public</strong>所有命名空间内可访问，但其他命名空间不能继承和重写；<br> <strong>internal</strong>默认访问级别，可以访问同一命名空间，但其他实体不能访问该实体；<br> <strong>fileprivate</strong>文件内私有；<br> <strong>private</strong>类私有；</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dbd2c7adecc78274cdf5e8ed2ef79b4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是js，js的特点，js的组成</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd38eab765744ae80df30049b1b8aa1a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">创建VScode的C/C&#43;&#43;编译环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>