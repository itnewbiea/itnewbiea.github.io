<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HDU 4347 The Closest M Points - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HDU 4347 The Closest M Points" />
<meta property="og:description" content="The Closest M Points Time Limit: 8000MS Memory Limit: 98304KB 64bit IO Format: %I64d &amp; %I64u
Submit Status
Description The course of Software Design and Development Practice is objectionable. ZLC is facing a serious problem .There are many points in K-dimensional space .Given a point. ZLC need to find out the closest m points. Euclidean distance is used as the distance metric between two points. The Euclidean distance between points p and q is the length of the line segment connecting them." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/982b878ee2b3bb187ec9e300a706ce20/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-12-21T03:42:04+08:00" />
<meta property="article:modified_time" content="2015-12-21T03:42:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HDU 4347 The Closest M Points</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>The Closest M Points <br> Time Limit: 8000MS Memory Limit: 98304KB 64bit IO Format: %I64d &amp; %I64u</p> 
 <p>Submit Status</p> 
 <p>Description <br> The course of Software Design and Development Practice is objectionable. ZLC is facing a serious problem .There are many points in K-dimensional space .Given a point. ZLC need to find out the closest m points. Euclidean distance is used as the distance metric between two points. The Euclidean distance between points p and q is the length of the line segment connecting them.In Cartesian coordinates, if p = (p 1, p 2,…, p n) and q = (q 1, q 2,…, q n) are two points in Euclidean n-space, then the distance from p to q, or from q to p is given by:</p> 
 <p>Can you help him solve this problem?</p> 
 <p>Input <br> In the first line of the text file .there are two non-negative integers n and K. They denote respectively: the number of points, 1 &lt;= n &lt;= 50000, and the number of Dimensions,1 &lt;= K &lt;= 5. In each of the following n lines there is written k integers, representing the coordinates of a point. This followed by a line with one positive integer t, representing the number of queries,1 &lt;= t &lt;=10000.each query contains two lines. The k integers in the first line represent the given point. In the second line, there is one integer m, the number of closest points you should find,1 &lt;= m &lt;=10. The absolute value of all the coordinates will not be more than 10000. <br> There are multiple test cases. Process to end of file.</p> 
 <p>Output <br> For each query, output m+1 lines: <br> The first line saying :”the closest m points are:” where m is the number of the points. <br> The following m lines representing m points ,in accordance with the order from near to far <br> It is guaranteed that the answer can only be formed in one ways. The distances from the given point to all the nearest m+1 points are different. That means input like this: <br> 2 2 <br> 1 1 <br> 3 3 <br> 1 <br> 2 2 <br> 1 <br> will not exist.</p> 
 <p>Sample Input</p> 
 <p>3 2 <br> 1 1 <br> 1 3 <br> 3 4 <br> 2 <br> 2 3 <br> 2 <br> 2 3 <br> 1 </p> 
 <p>Sample Output</p> 
 <p>the closest 2 points are: <br> 1 3 <br> 3 4 <br> the closest 1 points are: <br> 1 3 </p> 
</blockquote> 
<p>这道题是一道可以用kd-tree来解决的题，关于kd-tree的介绍有很多，我扼要的介绍一下，kd-tree是一种二叉树，用来对很多数据进行划分，而这些数据都具有k种属性。例如：我们要分类一组气象数据，而每个数据都具有多种属性，如：气压，温度，湿度。在kd-tree中我们轮流使用这些属性来分类这些数据。还是用气象数据的例子，我们在kd-tree的第一层用气压分类，第二层用温度分类，第三层用湿度分类。</p> 
<p>假设我们在某个节点使用第k个属性<span class="MathJax_Preview"></span><span style="" id="MathJax-Element-1893-Frame" class="MathJax"> 
   
   <span style="width: 1.083em; display: inline-block;" id="MathJax-Span-16949" class="math"><span style="display: inline-block; position: relative; width: 0.853em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.546em, 1000em, 2.718em, -0.432em); top: -2.4em; left: 0em;"><span id="MathJax-Span-16950" class="mrow"><span id="MathJax-Span-16951" class="msubsup"><span style="display: inline-block; position: relative; width: 0.875em; height: 0px;"><span style="position: absolute; clip: rect(1.813em, 1000em, 2.838em, -0.432em); top: -2.667em; left: 0em;"><span style="font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16952" class="mi">k</span><span style="display: inline-block; width: 0px; height: 2.667em;"></span></span><span style="position: absolute; top: -2.303em; left: 0.533em;"><span id="MathJax-Span-16953" class="texatom"><span id="MathJax-Span-16954" class="mrow"><span style="font-size: 70.7%; font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16955" class="mi">t</span></span></span><span style="display: inline-block; width: 0px; height: 2.453em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.4em;"></span></span></span><span style="border-left: 0em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.198em; vertical-align: -0.264em;"></span></span> 
  </span><script id="MathJax-Element-1893" type="math/tex">k_{t}</script>来进行分类，如果待分类的数据的第k个属性为<span class="MathJax_Preview"></span><span style="" id="MathJax-Element-1894-Frame" class="MathJax"> 
   
   <span style="width: 1.15em; display: inline-block;" id="MathJax-Span-16956" class="math"><span style="display: inline-block; position: relative; width: 0.907em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.546em, 1000em, 2.718em, -0.432em); top: -2.4em; left: 0em;"><span id="MathJax-Span-16957" class="mrow"><span id="MathJax-Span-16958" class="msubsup"><span style="display: inline-block; position: relative; width: 0.928em; height: 0px;"><span style="position: absolute; clip: rect(1.813em, 1000em, 2.838em, -0.432em); top: -2.667em; left: 0em;"><span style="font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16959" class="mi">k</span><span style="display: inline-block; width: 0px; height: 2.667em;"></span></span><span style="position: absolute; top: -2.303em; left: 0.533em;"><span id="MathJax-Span-16960" class="texatom"><span id="MathJax-Span-16961" class="mrow"><span style="font-size: 70.7%; font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16962" class="mi">c</span></span></span><span style="display: inline-block; width: 0px; height: 2.453em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.4em;"></span></span></span><span style="border-left: 0em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.198em; vertical-align: -0.264em;"></span></span> 
  </span><script id="MathJax-Element-1894" type="math/tex">k_{c}</script>，并且<span class="MathJax_Preview"></span><span style="" id="MathJax-Element-1895-Frame" class="MathJax"> 
   
   <span style="width: 3.95em; display: inline-block;" id="MathJax-Span-16963" class="math"><span style="display: inline-block; position: relative; width: 3.147em; height: 0px; font-size: 125%;"><span style="position: absolute; clip: rect(1.973em, 1000em, 3.144em, -0.432em); top: -2.827em; left: 0em;"><span id="MathJax-Span-16964" class="mrow"><span id="MathJax-Span-16965" class="msubsup"><span style="display: inline-block; position: relative; width: 0.928em; height: 0px;"><span style="position: absolute; clip: rect(1.813em, 1000em, 2.838em, -0.432em); top: -2.667em; left: 0em;"><span style="font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16966" class="mi">k</span><span style="display: inline-block; width: 0px; height: 2.667em;"></span></span><span style="position: absolute; top: -2.303em; left: 0.533em;"><span id="MathJax-Span-16967" class="texatom"><span id="MathJax-Span-16968" class="mrow"><span style="font-size: 70.7%; font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16969" class="mi">c</span></span></span><span style="display: inline-block; width: 0px; height: 2.453em;"></span></span></span></span><span style="font-family: MathJax_Main; padding-left: 0.278em;" id="MathJax-Span-16970" class="mo">&lt;</span><span style="padding-left: 0.278em;" id="MathJax-Span-16971" class="msubsup"><span style="display: inline-block; position: relative; width: 0.875em; height: 0px;"><span style="position: absolute; clip: rect(1.813em, 1000em, 2.838em, -0.432em); top: -2.667em; left: 0em;"><span style="font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16972" class="mi">k</span><span style="display: inline-block; width: 0px; height: 2.667em;"></span></span><span style="position: absolute; top: -2.303em; left: 0.533em;"><span id="MathJax-Span-16973" class="texatom"><span id="MathJax-Span-16974" class="mrow"><span style="font-size: 70.7%; font-family: MathJax_Math; font-style: italic;" id="MathJax-Span-16975" class="mi">t</span></span></span><span style="display: inline-block; width: 0px; height: 2.453em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.827em;"></span></span></span><span style="border-left: 0em solid; display: inline-block; overflow: hidden; width: 0px; height: 1.198em; vertical-align: -0.264em;"></span></span> 
  </span><script id="MathJax-Element-1895" type="math/tex">k_{c}<k_{t}</script>那我们进入该节点的左子树继续分类，否则进入右子树。我们举个例子, 这个例子参考了Christopher G. Healey’s Advanced data structure notes：</p> 
<table><thead><tr><th>名字(name)</th><th align="center">身高(ht)</th><th align="center">体重(wt)</th></tr></thead><tbody><tr><td>瞌睡虫(Sleepy)</td><td align="center">36</td><td align="center">48</td></tr><tr><td>开心果(Happy)</td><td align="center">34</td><td align="center">52</td></tr><tr><td>博士(Doc)</td><td align="center">38</td><td align="center">51</td></tr><tr><td>糊涂蛋(Dopey)</td><td align="center">37</td><td align="center">54</td></tr><tr><td>爱生气(Grumpy)</td><td align="center">32</td><td align="center">55</td></tr><tr><td>喷嚏精(Sneezy)</td><td align="center">35</td><td align="center">46</td></tr><tr><td>害羞鬼(Bashful)</td><td align="center">33</td><td align="center">50</td></tr><tr><td>白雪公主(Ms.White)</td><td align="center">65</td><td align="center">98</td></tr></tbody></table> 
<p>我们轮流使用两个属性身高和体重来分类数据，我们首先使用身高属性，通常我们可以使用 身高的中位数对应的值作为划分值，但这里我们为了简便，我们就按顺序选择每条数据去建立kd-tree，例如第一条数据是瞌睡虫，使用的是身高属性，因此kd-tree的根节点就是ht:36, 接着添加第二条数据：开心果。因为开心果的身高为34，所以进入到根节点的左子树，由于是第二层，所以我们应该使用体重属性，所以kd-tree，因此根节点的左子树的根节点为wt:52，同理我们添加第三个数据：博士，博士的身高高于36，因此进入到右子树，然后我们使用体重属性，因此根节点的右子树的根节点为wt:51. 如图所示： <br> <img src="https://images2.imgbox.com/25/42/Nev4eQ6a_o.png" alt="这里写图片描述" title=""> <br> 我们接着添加数据，当所有的数据都添加后，我们就得到一棵完整的kd-tree，然后我们重新将所有数据通过这棵kd-tree，并将所有的的数据存储在kd-tree的叶子节点上，如图所示： <br> <img src="https://images2.imgbox.com/bd/12/PIdGAh8u_o.png" alt="这里写图片描述" title=""> <br> 一般的kd-tree都是将数据存储在叶子节点上，但是对于我们这一题，我按照这种方式实现后，提交结果超时，后来我参考了别人的做法（<a href="http://blog.csdn.net/wxfwxf328/article/details/8158187">http://blog.csdn.net/wxfwxf328/article/details/8158187</a>），在他的实现中，直接将数据存在每个节点上，即做分类的节点（根节点及其他非叶子 节点），也存储了数据。即如图： <br> <img src="https://images2.imgbox.com/86/09/Kk0ViCLo_o.png" alt="这里写图片描述" title="">这种做法在这道题上取得了较好的效果。知道了原理，接下来我们就来看下具体的实现方法。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-preprocessor">#include&lt;queue&gt;   </span>
<span class="hljs-preprocessor">#include&lt;algorithm&gt;  </span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50000</span>;
<span class="hljs-keyword">short</span> currentDim; <span class="hljs-comment">//ys: which dimension we are currently working on</span>
<span class="hljs-preprocessor">#define square(x) (x)*(x)</span>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">short</span> K, t;</code></pre> 
<p>N表示的是可能输入的最多的点数，currentDim表示的是当前我们考虑的是哪一维，n表示具体的测试用例中的点数，K表示具体的测试用例的位数，t表示测试用例数。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">struct</span> point
{
    <span class="hljs-keyword">short</span> pos[<span class="hljs-number">5</span>];
    <span class="hljs-keyword">bool</span> flag; <span class="hljs-comment">//ys: whether this is a valid point</span>
    point()
    {
        flag = <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> point &amp;a) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> pos[currentDim] &lt; a.pos[currentDim]; 
    }
};

point input_v[N];
priority_queue&lt;pair&lt;<span class="hljs-keyword">double</span>, point&gt;&gt; pq;
point kd_tree[<span class="hljs-number">4</span>*N];</code></pre> 
<p>因为题目告知最多为5维数据，所以我们定义pos为5维数组，flag表示当前这个点是不是一个有效点，只有一个点被赋予了具体的值之后，我们才能说它是一个有效点，所以最初都会被初始化为false。接下来是一个结构体内的运算符重载，这点很有用，因为定义了这个运算符重载之后，我们就可以直接比较两个point来了，而这个结果还会一来与当前使用的是哪一维有关，因为当前使用的是哪一维，我们就用哪一维进行比较。有了point结构，我们就可以定义存放输入数据的数组input_v, 我们使用了priority queue来帮我们完成对于pair的排序，而pair包括两部分，第一部分是一个double，第二部分是一个点，而第一部分的double表示的就是第二部分这个点到我们查询的这个点间的距离。然后我们定义了kd-tree, 我们注意到它包含的点数为4N，因为我们使用的是数组来实现kd-tree, 而我们的root的index为1，所以我们可知如果节点的index为x，那么它的左儿子节点的index为2x，它的右儿子节点的index为2x+1，即使当前节点是kd-tree中的最后一个节点，但我们并不知道，所以我们仍要检查它的左儿子和右儿子，直到发现它的两个儿子的flag都为false，我们才停止进一步检查。那么最坏的情况下我们要检测的节点的最大索引值是多少呢？如下图所示： <br> <img src="https://images2.imgbox.com/f5/0a/9zIK7JCB_o.png" alt="这里写图片描述" title=""> <br> 我们假设有四个点，我们每次选择当前维上排在中间的元素作为划分的节点，如果总的点数为偶数，那么就会有两个点排在中间，这是我们选择较小的那个作为划分的节点，因此如图所示，根节点把所有数据分为两类，比它小的有一个，比它大的有两个，图中每个节点中的数字表示该节点在数组中的存储位置，因为根节点的位置为1，那么它的左儿子的位置就应该为2，右儿子的位置就应该为3，由于右边有两个节点，所以我们要继续划分，找出当前维上排在中间的节点，因为只有两个节点，所以两个节点都算是排在中间的节点，因此我们选择较小的那个作为划分节点，存储在位置3上，而另外那个节点比这个划分节点大，所以成为它的右儿子，存储在位置7上，虽然这个节点已经是最后一个节点了，但是我们的程序判断不再进一步构建子树的条件是当前节点为无效节点(即flag=false), 但我们当前的节点是有效节点，所以程序仍会继续检测它的左子树和右子树，因此位置14和15会被检测到（当然这个过程可以优化，从而避免为位置14和15分配空间）。此时，我们发现4个节点，但在最坏的情况下，需要检测到位置15，由于我们的数组是从0开始的（虽然根节点是从1开始），所以我们的数组大小为16，是节点数的4倍，所以这就是为什么kd-tree数组的大小为4N。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> construct_kdTree(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">short</span> K, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">short</span> depth)
{
    <span class="hljs-keyword">if</span>(p &lt;= r)
    {
        currentDim = depth % K;
        <span class="hljs-keyword">int</span> mid = (p + r) / <span class="hljs-number">2</span>;
        nth_element(input_v+p, input_v+mid, input_v+r+<span class="hljs-number">1</span>);
        kd_tree[index] = input_v[mid];
        kd_tree[index].flag = <span class="hljs-keyword">true</span>;
        construct_kdTree(n, K, p, mid-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*index, depth+<span class="hljs-number">1</span>);
        construct_kdTree(n, K, mid+<span class="hljs-number">1</span>, r, <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>, depth+<span class="hljs-number">1</span>);
    }
}</code></pre> 
<p>下面就是创建kd-tree了，因为用递归的方式创建，所以先还是判断一下对应的区间的开始p和结尾r位置，如果开始位置在结尾位置之后，那么这个区间不成立，否则就应该创建对应的节点，首先找出当前使用的是哪一维，因为每一维是轮流使用的，所以我们通过当前节点所处的深度模上总的维数来得到当前使用的维数，不难发现同一深度的节点使用的是同一维。然后我们计算出当前区间的中间位置，如果有两个中间位置，则取较小的一个。接着我们使用stl中的nth_element，它的作用是把第n大的元素摆在第n个位置上，以我们程序中的nth_element ( input_v+p, input_v+mid, input_v+r+1);为例，我们区间input_v+p到input_v+r这段区间中的第mid-p+1大的元素放到input_v+mid这个位置上，同时保证在input_v+mid左侧的元素都小于等于它，input_v+mid右侧的元素都大于等于它，尽管如此，这些元素并不一定排好了，例如可能是2 1 3 5 4， 2，1 都小于3, 而5,4都大于3。把中间这个元素放到input_v+mid这个位置上了之后，我们就取这个中间元素作为分类节点的值，然后把flag设为true，表示这是一个有效的节点。接着我们继续递归地构建左子树和右子树。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> query_kdTree(point p, <span class="hljs-keyword">short</span> closestM, <span class="hljs-keyword">short</span> K, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">short</span> depth)
{
    <span class="hljs-comment">//if(index &gt;= 2*N || !kd_tree[index].flag)</span>
    <span class="hljs-keyword">if</span>(!kd_tree[index].flag)
        <span class="hljs-keyword">return</span>;
    pair&lt;<span class="hljs-keyword">double</span>, point&gt; current_node(<span class="hljs-number">0</span>, kd_tree[index]);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++)
    {
        current_node.first += square(p.pos[i]-current_node.second.pos[i]);
    }

    <span class="hljs-keyword">short</span> idm = depth % K;
    <span class="hljs-keyword">short</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//ys: whether we need to explore other side of the split</span>
    <span class="hljs-keyword">int</span> lchild = <span class="hljs-number">2</span>*index;
    <span class="hljs-keyword">int</span> rchild = <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span>(kd_tree[index].pos[idm] &lt;= p.pos[idm])
    {
        query_kdTree(p, closestM, K, rchild, depth+<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        query_kdTree(p, closestM, K, lchild, depth+<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">if</span>(pq.size() &lt; closestM)
    {
        pq.push(current_node);
        flag = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">if</span>(current_node.first &lt; pq.top().first)
        {
            pq.pop();
            pq.push(current_node);
        }
        <span class="hljs-keyword">if</span>(square(p.pos[idm] - kd_tree[index].pos[idm]) &lt; pq.top().first)
        {
            flag = <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">if</span>(flag)
    {
        <span class="hljs-keyword">if</span>(kd_tree[index].pos[idm] &lt;= p.pos[idm])
            query_kdTree(p, closestM, K, lchild, depth+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">else</span>
            query_kdTree(p, closestM, K, rchild, depth+<span class="hljs-number">1</span>);
    }
}</code></pre> 
<p>这部分就是kd-tree的查询了，首先一开始，我们判断是否当前节点是flag是否是true，如果是false则说明当前节点是无效节点，所以直接返回，否则进一步开始查询，接着使用到了stl中的pair，这里使用pair主要是想将point和该point与查询的point之间的距离绑定在一起。然后我们开始计算当前point与查询point之间的距离，这个地方本应该要开方才是距离，但由于我们用它来比较大小，所以不开方也不会影响大小关系，所以为了节省时间，此处就不进行开方运算。</p> 
<p>接着我们计算当前使用的是哪一维，这个地方我们使用了一个局部变量来存储，而没有使用之前申明的全局变量，是因为这个变量将在递归调用前后多次使用，如果使用全局变量，在递归调用过程中这个值会被改变，因此，当程序从递归调用中返回时就与递归调用前的值不一致了，而这将会导致错误。接着的变量flag表示的是是否我们还需要搜索当前节点的另一分支。具体在什么情况下需要搜索另一分支，我们将在后面介绍。接着我们计算当前节点的左右儿子的位置。然后我们开始比较，如果查询point的值大于等于当前point的值，那么进入当前point的右子树继续搜索，否则进入当前point的左子树继续搜索。当子树搜索完毕后，所有结果都存储在名为pq的priority queue中，如果pq的大小不到closestM，例如我们要找出离查询point最近的5个点，而pq中现在只有3个点，那么我们肯定还要想pq中加点，所以首先我们将当前point加进去，然后将flag置为1，说明我们还需要搜寻当前节点的另一分支。另外方面如果pq的大小已经超过了closestM，那么我们就把当前point与查询point之间的距离和pq中的最大距离做比较，如果比pq中的最大距离小，那么我们就弹出pq中的最大距离点，把当前point加入到pq中（pq是大顶堆）。但是否存在查询point虽然被划分到左子树，而实际上它离右子树上的点更近呢，答案是肯定的，如图所示： <br> <img src="https://images2.imgbox.com/e8/30/EHYE8fMB_o.png" alt="这里写图片描述" title=""> <br> 查询point A虽然和point B，point C分为一类，但实际上离他最近的是分在另外一类的point D。那么如何判断是否可能存在这种情况呢？其实很简单，我们检测查询point与当前point在当前维上的差距，即：我们图中的point A到划分直线的距离，如果这个距离大于pq中的最大距离，那么我们就不用检测划分直线另一侧的点了，因为划分直线另一侧的点到point A的距离必然大于等于划分直线到point A的距离。否则，我们就需要检测划分直线另一侧的点，即：当前point的另一分支。所以接下来的代码中，如果flag为true，那么我们就检测当前point的另一分支。</p> 
<pre class="prettyprint"><code class="language-c hljs "><span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%hd"</span>,&amp;n,&amp;K)!=EOF)  
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> j = <span class="hljs-number">0</span>; j &lt; K; j++)
            {
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;input_v[i].pos[j]);
            }
        }
        <span class="hljs-built_in">memset</span>(kd_tree, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(point)*<span class="hljs-number">4</span>*N);
        construct_kdTree(n, K, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;t);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> c = <span class="hljs-number">0</span>; c &lt; t; c++)
        {
            <span class="hljs-keyword">short</span> closestM;
            point tmpv;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> j = <span class="hljs-number">0</span>; j &lt; K; j++)
            {
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;tmpv.pos[j]);
            }
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;closestM);
            query_kdTree(tmpv, closestM, K, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the closest %hd points are:\n"</span>, closestM);
            point pt[<span class="hljs-number">10</span>];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> i = <span class="hljs-number">0</span>; !pq.empty(); i++)
            {
                pt[i] = pq.top().second;
                pq.pop();
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> i = closestM-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
            {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> j = <span class="hljs-number">0</span>; j &lt; K; j++)
                {
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%hd"</span>, pt[i].pos[j]);
                    <span class="hljs-keyword">if</span>(j == K-<span class="hljs-number">1</span>)
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
                    <span class="hljs-keyword">else</span>
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>主函数就比较简单了，首先读入有多少个点，几维，然后把每个点读入到input_v数组中，因为有多组测试，每一组使用不同的kd-tree，所以现将kd-tree对应内存置0，然后构建kd-tree，然后读入要测试几个点，然后是具体的查询point，然后是要找出距离查询point最近的几个points。然后调用query_kdTree进行查询。得到结果后，把这些点按照距离查询point的距离由小到大打印出来，值得一提的是pq是大顶堆，所以我们从中弹出来的point距离查询point的距离是由大到小，所以我们使用了一个额外的数组pt，用于存放从pq中弹出的point，然后我们在按从后往前的顺序将结果打出。 <br> 下面是完整程序代码：</p> 
<pre class="prettyprint"><code class="language-c++ hljs cpp"><span class="hljs-preprocessor">#include&lt;queue&gt;   </span>
<span class="hljs-preprocessor">#include&lt;algorithm&gt;  </span>
<span class="hljs-preprocessor">#include&lt;string.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">50000</span>;
<span class="hljs-keyword">short</span> currentDim; <span class="hljs-comment">//ys: which dimension we are currently working on</span>
<span class="hljs-preprocessor">#define square(x) (x)*(x)</span>
<span class="hljs-keyword">int</span> n;
<span class="hljs-keyword">short</span> K, t;

<span class="hljs-keyword">struct</span> point
{
    <span class="hljs-keyword">short</span> pos[<span class="hljs-number">5</span>];
    <span class="hljs-keyword">bool</span> flag; <span class="hljs-comment">//ys: whether this is a valid point</span>
    point()
    {
        flag = <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> point &amp;a) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> pos[currentDim] &lt; a.pos[currentDim]; 
    }
};

point input_v[N];
priority_queue&lt;pair&lt;<span class="hljs-keyword">double</span>, point&gt;&gt; pq;
point kd_tree[<span class="hljs-number">4</span>*N];
<span class="hljs-comment">//point kd_tree[2*N];</span>

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> construct_kdTree(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">short</span> K, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">short</span> depth)
{
    <span class="hljs-keyword">if</span>(p &lt;= r)
    {
        currentDim = depth % K;
        <span class="hljs-keyword">int</span> mid = (p + r) / <span class="hljs-number">2</span>;
        nth_element(input_v+p, input_v+mid, input_v+r+<span class="hljs-number">1</span>);
        kd_tree[index] = input_v[mid];
        kd_tree[index].flag = <span class="hljs-keyword">true</span>;
        construct_kdTree(n, K, p, mid-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*index, depth+<span class="hljs-number">1</span>);
        construct_kdTree(n, K, mid+<span class="hljs-number">1</span>, r, <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>, depth+<span class="hljs-number">1</span>);
    }
}

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> query_kdTree(point p, <span class="hljs-keyword">short</span> closestM, <span class="hljs-keyword">short</span> K, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">short</span> depth)
{
    <span class="hljs-comment">//if(index &gt;= 2*N || !kd_tree[index].flag)</span>
    <span class="hljs-keyword">if</span>(!kd_tree[index].flag)
        <span class="hljs-keyword">return</span>;
    pair&lt;<span class="hljs-keyword">double</span>, point&gt; current_node(<span class="hljs-number">0</span>, kd_tree[index]);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; K; i++)
    {
        current_node.first += square(p.pos[i]-current_node.second.pos[i]);
    }

    <span class="hljs-keyword">short</span> idm = depth % K;
    <span class="hljs-keyword">short</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//ys: whether we need to explore other side of the split</span>
    <span class="hljs-keyword">int</span> lchild = <span class="hljs-number">2</span>*index;
    <span class="hljs-keyword">int</span> rchild = <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span>(kd_tree[index].pos[idm] &lt;= p.pos[idm])
    {
        query_kdTree(p, closestM, K, rchild, depth+<span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        query_kdTree(p, closestM, K, lchild, depth+<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">if</span>(pq.size() &lt; closestM)
    {
        pq.push(current_node);
        flag = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">if</span>(current_node.first &lt; pq.top().first)
        {
            pq.pop();
            pq.push(current_node);
        }
        <span class="hljs-keyword">if</span>(square(p.pos[idm] - kd_tree[index].pos[idm]) &lt; pq.top().first)
        {
            flag = <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">if</span>(flag)
    {
        <span class="hljs-keyword">if</span>(kd_tree[index].pos[idm] &lt;= p.pos[idm])
            query_kdTree(p, closestM, K, lchild, depth+<span class="hljs-number">1</span>);
        <span class="hljs-keyword">else</span>
            query_kdTree(p, closestM, K, rchild, depth+<span class="hljs-number">1</span>);
    }
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%hd"</span>,&amp;n,&amp;K)!=EOF)  
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> j = <span class="hljs-number">0</span>; j &lt; K; j++)
            {
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;input_v[i].pos[j]);
            }
        }
        <span class="hljs-comment">//memset(kd_tree, 0, sizeof(point)*2*N);</span>
        <span class="hljs-built_in">memset</span>(kd_tree, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(point)*<span class="hljs-number">4</span>*N);
        construct_kdTree(n, K, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;t);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> c = <span class="hljs-number">0</span>; c &lt; t; c++)
        {
            <span class="hljs-keyword">short</span> closestM;
            point tmpv;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> j = <span class="hljs-number">0</span>; j &lt; K; j++)
            {
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;tmpv.pos[j]);
            }
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%hd"</span>, &amp;closestM);
            query_kdTree(tmpv, closestM, K, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"the closest %hd points are:\n"</span>, closestM);
            point pt[<span class="hljs-number">10</span>];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> i = <span class="hljs-number">0</span>; !pq.empty(); i++)
            {
                pt[i] = pq.top().second;
                pq.pop();
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> i = closestM-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)
            {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">short</span> j = <span class="hljs-number">0</span>; j &lt; K; j++)
                {
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%hd"</span>, pt[i].pos[j]);
                    <span class="hljs-keyword">if</span>(j == K-<span class="hljs-number">1</span>)
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
                    <span class="hljs-keyword">else</span>
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" "</span>);
                }
            }
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eefde60b3929cbc102520f1488cc4663/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最近邻搜索之乘积量化（Product Quantizer）理解（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddf1aceabcce277c0cda4caa367bd3e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">POI：数据批量导出、按模板导出</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>