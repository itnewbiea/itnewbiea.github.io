<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软构复习2测试与测试优先的原则 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软构复习2测试与测试优先的原则" />
<meta property="og:description" content="一、测试
测试无法达到百分百的无错误
1-10个错误每千行代码：标准工业级软件
0.1-1个：高质量的验证（Java库能达到）
0.01-0.1个：极高质量的，严格安全的如NASA，Praxis等公司
再好的测试也不能证明系统无错误，测试时的目标应该是破坏性的，证错的
好的测试的特点：能发现错误，不冗余，最佳特性，既不太复杂也不太简单
测试的等级：
单元测试（功能层面，一个方法，函数），集成测试（类，包等），系统测试（一个体系系统），验收测试
静态测试：用眼睛看，检查代码，浏览代码
动态测试：执行程序来发现错误
测试：发现错误 调试：找到错误根源，消除错误
白盒测试：对程序内部代码结构的测试 黑盒测试：对程序外部表现出来的行为的测试 测试困难的原因：暴力穷举不可能；偶然测试没有意义 ；基于样本的统计数据对软件测试意义不大—软件与产品的巨大差异；软件行为在离散空间中差异巨大：大多数正确，少数错误；无统计规律可循； 测试时转变心态：让代码尽快出错 二、测试用例： test case = {test inputs &#43; execution conditions&#43; expected results} 测试用例：输入&#43;执行条件&#43;期望结果 三、测试优先的编程 先写spec，再写spec的测试用例，再写代码，测试，发现问题，解决问题，重复步骤 写测试用例就是不断理解，修正，完善spec的过程 测试优先会节省大量的调试时间 四、单元测试： 针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试 前面要声明@Test 一般以test&#43;被测试单元名称命名，且用断言式，一般期望值在前 Test目录和src目录一样，且两个文件夹可以放入同一个包中来方便访问被测试的成员 五、黑盒测试： 检查代码功能，不关心内部实现细节 检查程序是否符合规约，用尽可能少的测试用例，尽快运行，发现尽可能大的程序错误 1.通过等价类划分选择测试用例： 针对每个输入数据需要满足的约束条件，划分等价类 基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为 测试用例即可，进而降低测试用例数量 2.在分区中包含边界（BVA）： 边界值分析方法是对等价类划分方法的补充 在等价类划分时，将边界值作为等价类之一加入考虑 例如：小于最小值，最小值，略大于最小值，略小于最大值，最大值，大于最大值 覆盖分区的两种极端： 1.笛卡尔积全覆盖，多个维度的每个情况都要有一种组合，但是实际并非所有组合情况都可能 测试完备，但是用例数量多，代价高 2.最小覆盖：每个维度的每个取值至少被覆盖一次即可 用例少，代价低，但是覆盖度未必高 六、白盒测试： 考虑内部代码实现细节 根据程序内部路径实现测试用例 典型的白盒测试：独立/基本路径测试：对程序所有执行路径进行等价类划 分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试 用例使每一条基本路径被至少覆盖1次。 七、测试覆盖度： 测试效果：路径覆盖&gt;分支覆盖&gt;语句覆盖 测试难度同上，但是路径数目巨大，难以全覆盖 实际当中，根据预先设定的覆盖度标准，逐步增加测试用例的数量， 直到覆盖度达到标准（例如语句覆盖100%、路径覆盖90%） 八、自动测试和回归测试 自动： 自动调用被测函数、自动判定测试结果、自动计算覆盖度 只是测试用例的自动执行，而非自动生成测试用例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a257a1c4739d9b9448992b9c93b09ffe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-04T16:43:24+08:00" />
<meta property="article:modified_time" content="2022-06-04T16:43:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软构复习2测试与测试优先的原则</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、测试</p> 
<p>测试无法达到百分百的无错误</p> 
<p>1-10个错误每千行代码：标准工业级软件</p> 
<p>0.1-1个：高质量的验证（Java库能达到）</p> 
<p>0.01-0.1个：极高质量的，严格安全的如NASA，Praxis等公司</p> 
<p>再好的测试也不能证明系统无错误，测试时的目标应该是破坏性的，证错的</p> 
<p>好的测试的特点：能发现错误，不冗余，最佳特性，既不太复杂也不太简单</p> 
<p>测试的等级：<br> 单元测试（功能层面，一个方法，函数），集成测试（类，包等），系统测试（一个体系系统），验收测试</p> 
<p>静态测试：用眼睛看，检查代码，浏览代码</p> 
<p>动态测试：执行程序来发现错误</p> 
<p>测试：发现错误 调试：找到错误根源，消除错误</p> 
<div> 
 <span style="color:#0d0016;">白盒测试：对程序内部代码结构的测试  </span> 
</div> 
<div> 
 <span style="color:#0d0016;">黑盒测试：对程序外部表现出来的行为的测试</span> 
</div> 
<div>
  测试困难的原因：暴力穷举不可能；偶然测试没有意义 
 <span style="color:#0d0016;">；基于样本的统计数据对软件测试意义不大—软件与产品的巨大差异；软件行为在离散空间中差异巨大：大多数正确，少数错误；无统计规律可循；</span> 
</div> 
<div>
  测试时转变心态：让代码尽快出错 
</div> 
<div></div> 
<div>
  二、测试用例： 
</div> 
<div> 
 <div> 
  <span style="color:#0d0016;">test case = {test inputs + execution conditions+ expected results} 测试用例：输入+执行条件+期望结果</span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#0d0016;">三、测试优先的编程</span> 
 </div> 
 <div>
   先写spec，再写spec的测试用例，再写代码，测试，发现问题，解决问题，重复步骤 
 </div> 
 <div>
   写测试用例就是不断理解，修正，完善spec的过程 
 </div> 
 <div>
   测试优先会节省大量的调试时间 
 </div> 
 <div></div> 
 <div>
   四、单元测试： 
  <div> 
   <span style="color:#0d0016;">针对软件的最小单元模型开展测试，隔离各个模块，容易定位错误和调试</span> 
  </div> 
  <div> 
   <span style="color:#0d0016;">前面要声明@Test</span> 
  </div> 
  <div> 
   <span style="color:#0d0016;">一般以test+被测试单元名称命名，且用断言式，一般期望值在前</span> 
  </div> 
  <div>
    Test目录和src目录一样，且两个文件夹可以放入同一个包中来方便访问被测试的成员 
  </div> 
  <div>
    五、黑盒测试： 
  </div> 
  <div>
    检查代码功能，不关心内部实现细节 
  </div> 
  <div>
    检查程序是否符合规约，用尽可能少的测试用例，尽快运行，发现尽可能大的程序错误 
  </div> 
  <div>
    1.通过等价类划分选择测试用例： 
   <div> 
    <span style="color:#0d0016;">针对每个输入数据需要满足的约束条件，划分等价类</span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#0d0016;">基于的假设：相似的输入，将会展示相似的行为。故可从每个等价类中选一个代表作为 </span> 
    </div> 
    <div> 
     <span style="color:#0d0016;">测试用例即可，进而降低测试用例数量</span> 
     <span style="color:#0000ff;">    </span> 
    </div> 
    <div>
      2.在分区中包含边界（BVA）： 
    </div> 
    <div>
      边界值分析方法是对等价类划分方法的补充 
    </div> 
    <div>
      在等价类划分时，将边界值作为等价类之一加入考虑 
    </div> 
    <div>
      例如：小于最小值，最小值，略大于最小值，略小于最大值，最大值，大于最大值 
    </div> 
    <div></div> 
    <div>
      覆盖分区的两种极端： 
     <br> 1.笛卡尔积全覆盖，多个维度的每个情况都要有一种组合，但是实际并非所有组合情况都可能 
    </div> 
    <div>
      测试完备，但是用例数量多，代价高 
    </div> 
    <div>
      2.最小覆盖：每个维度的每个取值至少被覆盖一次即可 
    </div> 
    <div>
      用例少，代价低，但是覆盖度未必高 
    </div> 
    <div></div> 
    <div>
      六、白盒测试： 
    </div> 
    <div>
      考虑内部代码实现细节 
    </div> 
    <div>
      根据程序内部路径实现测试用例 
    </div> 
    <div> 
     <div> 
      <span style="color:#0d0016;">典型的白盒测试：独立/基本路径测试：对程序所有执行路径进行等价类划 </span> 
     </div> 
     <div> 
      <span style="color:#0d0016;">分，找出有代表性的最简单的路径(例如循环只需执行1次)，设计测试 </span> 
     </div> 
     <div> 
      <span style="color:#0d0016;">用例使每一条基本路径被至少覆盖1次。</span> 
     </div> 
    </div> 
    <div></div> 
    <div>
      七、测试覆盖度： 
     <br> 测试效果：路径覆盖&gt;分支覆盖&gt;语句覆盖 
    </div> 
    <div>
      测试难度同上，但是路径数目巨大，难以全覆盖 
    </div> 
    <div> 
     <div> 
      <span style="color:#0d0016;">实际当中，根据预先设定的覆盖度标准，逐步增加测试用例的数量， </span> 
     </div> 
     <div> 
      <span style="color:#0d0016;">直到覆盖度达到标准（例如语句覆盖100%、路径覆盖90%）</span> 
     </div> 
    </div> 
    <div></div> 
    <div>
      八、自动测试和回归测试 
    </div> 
    <div>
      自动： 
     <div> 
      <span style="color:#0d0016;">自动调用被测函数、自动判定测试结果、自动计算覆盖度</span> 
     </div> 
     <p>只是测试用例的自动执行，而非自动生成测试用例</p> 
     <p>回归：一旦程序被修改，重新执行之前的所有测试</p> 
     <p>无论何时发现并修复了一个bug，将引发该bug的输入作为测试用例添加到自动测试套件中，这种测试用例称为回归测试。这有助于用良好的测试用例填充测试套件。</p> 
     <p>每个回归测试都是在代码的一个版本中完成的</p> 
     <p>实际自动和回归一般是结合的，自动化回归测试是目前最好的测试模式,自动回归测试，以防止bug返回。</p> 
     <p>测试策略（根据什么来选择测试用例）非常重要，需要在程序中显式记录下来</p> 
     <p>目的:在代码评审过程中,其他人可以理解你的测试,并评判你的测试是否足够充分</p> 
    </div> 
    <div></div> 
    <div></div> 
   </div> 
  </div> 
 </div> 
</div> 
<div></div> 
<div></div> 
<div></div> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20a3ce88fd5c1e0e756f22b194ffb834/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">春节期间重装anaconda&#43;opencv血泪史分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fba2beb6650ebb434c5d2174ca098110/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">easy-x常用函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>