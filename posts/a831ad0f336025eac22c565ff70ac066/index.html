<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OD使用初探 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OD使用初探" />
<meta property="og:description" content="1.什么是OD OD全称Ollydbg，是反汇编常用的工具，经常用作动态调试。
2.OD中文版下载 下载地址
3.界面简介 4.默认功能 1）汇编代码对应的地址窗口（虚拟地址，一般情况下，同一程序的同一条指令在不同系统环境下此值相同。）
2） 汇编代码对应的十六进制机器码窗口
3）反汇编窗口
4）反汇编代码对应的注释信息窗口
5）寄存器信息窗口
6）当前执行到的反汇编代码的信息窗口
7~9） 数据所在的内存地址，十六进制，ASCII码
10~12）栈地址，存放的数据，对应说明信息
5.OD快捷键 F2
下断点，也就是指定断点的地址
F3
加载一个可执行程序，进行调试分析
F4
程序执行到光标处
F5
缩小、还原当前窗口
F7
单步步入
F8
单步步过
F9
直接运行程序，遇到断点处，程序暂停
Ctrl&#43;F2
重新运行程序到起始处，一般用于重新调试程序
Ctrl&#43;F9
执行到函数返回处，用于跳出函数实现
Alt&#43;F9
执行到用户代码处，用于快速跳出系统函数
Ctrl&#43;G
输入十六进制地址，快速定位到该地址处
6.寄存器 EAX:扩展累加寄存器
EBX扩展基址寄存器
ECX扩展计数寄存器
EDX扩展数据寄存器
ESI扩展来源寄存器
EDI扩展目标寄存器
以下三个不可随便用，他们的范围是（0--ffffffff）
EBP扩展基址指针寄存器，主要用于栈和栈帧
ESP扩展堆栈指针寄存器，指向当前进程的栈空间地址
EIP:扩展的指令指针寄存器，总是指向下一条被被指向的命令
7.常用方法 1）F2下断点，Alt&#43;b打开断点编辑器，可编辑所有下过的断点，空格键可快速切换断点状态。
2）当位于某个CALL中，这时想返回到调用这个CALL的地方时，可以按“Ctrl&#43;F9”快捷键执行返回功能。
这样OD就会停在遇到的第一个返回命令（如RET、RETF或IRET）。
3）如果跟进系统DLL提供的API函数中，此时想返回到应用程序领空里，可以按快捷键“Alt&#43;F9”执行返回到用户代码命令。
4）所谓领空，实际上就是指在某一时刻，CPU执行的指令所在的某段代码的所有者。
如004013F7这类地址一般是可执行文件领空，7C8114AB这类大地址一般是系统DLL所在的地址空间。
5）程序通常读取文本框内容的字符串用的是以下两个函数： GetDlgItemTextA（GetDlgItemTextW）
GetWindowTextA（GetWindowTextW）
6）按“Ctrl&#43;G”键打开跟随表达式的窗口。（***很重要，可追踪函数）
7）通过“Ctrl&#43;N”键打开应用程序的导入表（输入表），然后查看应用程序总共导入了哪些函数来以此推断需要在哪里挖坑下陷阱！（***很重要，可追踪导入的dll等文件）
8）返回值，汇编代码的返回值约定是存放在eax这个寄存器里边的，如果32位的eax不够存放返回值，系统会将返回值放在内存某个位置并把该位置的地址放在eax返回。
8.操作指南 指南地址
9.寄存器简介 EBP是当前函数的存取指针，即存储或者读取数时的指针基地址；
ESP就是当前函数的栈顶指针。每一次发生函数的调用（主函数调用子函数）时，在被调用函数初始时，都会把当前函数（主函数）的EBP压栈，以便从子函数返回到主函数时可以获取EBP。
通过一段程序理解esp和ebp：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a831ad0f336025eac22c565ff70ac066/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-05T18:19:05+08:00" />
<meta property="article:modified_time" content="2019-03-05T18:19:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OD使用初探</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.什么是OD</h3> 
<p>OD全称<a href="https://www.baidu.com/s?wd=Ollydbg&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" rel="nofollow">Ollydbg</a>，是反汇编常用的工具，经常用作动态调试。</p> 
<h3>2.OD中文版下载</h3> 
<p><a href="https://download.csdn.net/download/linhao90/2934821">下载地址</a></p> 
<h3>3.界面简介</h3> 
<p><img alt="" class="has" src="https://images2.imgbox.com/65/01/4qMf6Kvc_o.gif"></p> 
<h3>4.默认功能</h3> 
<p>1）汇编代码对应的地址窗口（虚拟地址，一般情况下，同一程序的同一条指令在不同系统环境下此值相同。）</p> 
<p>2） 汇编代码对应的十六进制机器码窗口</p> 
<p>3）反汇编窗口</p> 
<p>4）反汇编代码对应的注释信息窗口</p> 
<p>5）寄存器信息窗口</p> 
<p>6）当前执行到的反汇编代码的信息窗口</p> 
<p>7~9） 数据所在的内存地址，十六进制，ASCII码</p> 
<p>10~12）栈地址，存放的数据，对应说明信息<br>  </p> 
<h3>5.OD快捷键</h3> 
<p>F2</p> 
<p>下断点，也就是指定断点的地址</p> 
<p>F3</p> 
<p>加载一个可执行程序，进行调试分析</p> 
<p>F4</p> 
<p>程序执行到光标处</p> 
<p>F5</p> 
<p>缩小、还原当前窗口</p> 
<p>F7</p> 
<p>单步步入</p> 
<p>F8</p> 
<p>单步步过</p> 
<p>F9</p> 
<p>直接运行程序，遇到断点处，程序暂停</p> 
<p>Ctrl+F2</p> 
<p>重新运行程序到起始处，一般用于重新调试程序</p> 
<p>Ctrl+F9</p> 
<p>执行到函数返回处，用于跳出函数实现</p> 
<p>Alt+F9</p> 
<p>执行到用户代码处，用于快速跳出系统函数</p> 
<p>Ctrl+G</p> 
<p>输入十六进制地址，快速定位到该地址处</p> 
<h3><br> 6.寄存器</h3> 
<p>EAX:扩展累加寄存器</p> 
<p>EBX扩展基址寄存器</p> 
<p>ECX扩展计数寄存器</p> 
<p>EDX扩展数据寄存器</p> 
<p>ESI扩展来源寄存器</p> 
<p>EDI扩展目标寄存器</p> 
<p><span style="color:#f33b45;">以下三个不可随便用，他们的范围是（0--ffffffff）</span></p> 
<p>EBP扩展基址指针寄存器，主要用于栈和栈帧</p> 
<p>ESP扩展堆栈指针寄存器，指向当前进程的栈空间地址</p> 
<p>EIP:扩展的指令指针寄存器，总是指向下一条被被指向的命令<br>  </p> 
<h3>7.常用方法</h3> 
<p>1）F2下断点，Alt+b打开断点编辑器，可编辑所有下过的断点，空格键可快速切换断点状态。</p> 
<p>2）当位于某个CALL中，这时想返回到调用这个CALL的地方时，可以按“Ctrl+F9”快捷键执行返回功能。</p> 
<p>这样OD就会停在遇到的第一个返回命令（如RET、RETF或IRET）。</p> 
<p>3）如果跟进系统DLL提供的API函数中，此时想返回到应用程序领空里，可以按快捷键“Alt+F9”执行返回到用户代码命令。</p> 
<p>4）所谓领空，实际上就是指在某一时刻，CPU执行的指令所在的某段代码的所有者。</p> 
<p>    如004013F7这类地址一般是可执行文件领空，7C8114AB这类大地址一般是系统DLL所在的地址空间。</p> 
<p>5）程序通常读取文本框内容的字符串用的是以下两个函数：   </p> 
<p>   GetDlgItemTextA（GetDlgItemTextW）</p> 
<p>   GetWindowTextA（GetWindowTextW）</p> 
<p>6）按“Ctrl+G”键打开跟随表达式的窗口。<span style="color:#f33b45;">（***很重要，可追踪函数）</span></p> 
<p>7）通过“Ctrl+N”键打开应用程序的导入表（输入表），然后查看应用程序总共导入了哪些函数来以此推断需要在哪里挖坑下陷阱！<span style="color:#f33b45;">（***很重要，可追踪导入的dll等文件）</span></p> 
<p>8）返回值，汇编代码的返回值约定是存放在eax这个寄存器里边的，如果32位的eax不够存放返回值，系统会将返回值放在内存某个位置并把该位置的地址放在eax返回。</p> 
<h3>8.操作指南</h3> 
<p><a href="https://blog.csdn.net/zy_strive_2012/article/details/54893020">指南地址</a></p> 
<h3>9.寄存器简介</h3> 
<p>EBP是当前函数的存取指针，即存储或者读取数时的指针基地址；</p> 
<p>ESP就是当前函数的栈顶指针。每一次发生函数的调用（主函数调用子函数）时，在被调用函数初始时，都会把当前函数（主函数）的EBP压栈，以便从子函数返回到主函数时可以获取EBP。</p> 
<p><img alt="" class="has" height="270" src="https://images2.imgbox.com/a2/c8/6zfwtbCV_o.png" width="296"></p> 
<p>通过一段程序理解esp和ebp：</p> 
<pre class="has"><code>main() {

//执行test前

print(int p1,int p2);

//执行test后

}

分析下上面程序的调用原理，假设执行print前esp=Q：

push p2; //函数参数p2入栈，esp=Q-4H

push p1; //函数参数p1入栈，esp=Q-8H

call print; //函数返回地址入栈，esp=Q-0CH

//现在进入print内，做些准备工作：

push ebp; //保护先前ebp指针，ebp入栈，esp=Q-10H

mov esp,ebp; //设置ebp等于当前的esp

// 此时，ebp+0CH=Q-4H，即p2的位置

// 同样，ebp+08H=Q-8H，即p1的位置

// 下面是print内的一些操作：

sub esp,20H; //设置长度为10H大小的局部变量空间，esp=Q-20H

// ... ...

// 一系列操作

// ... ...

add esp,20H; //释放局部变量空间，esp=Q-10H

pop ebp; //出栈，恢复原先的ebp的值，esp=Q-0CH

ret 8; //ret返回，弹出先前入栈的返回地址，esp=Q-08H，后面加操作数8H为平衡堆栈

// 之后，弹出函数参数，esp=Q，恢复执行print函数前的堆栈；
</code></pre> 
<p> </p> 
<p>图示，注意栈在内存中的生长方向是逆向：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/69/d7/7bZUfneY_o.png"></p> 
<p>执行push p2;前，esp=Q；</p> 
<p>执行push p2;过程中，esp-=4H，p2入栈；</p> 
<p>执行push p2;后，esp=Q-4H；</p> 
<h3>10.参考文献</h3> 
<p>1）<a href="https://blog.csdn.net/yeruby/article/details/39780943">https://blog.csdn.net/yeruby/article/details/39780943</a></p> 
<p>2）<a href="https://blog.csdn.net/wangkr111/article/details/41315629">https://blog.csdn.net/wangkr111/article/details/41315629</a></p> 
<p>3）<a href="https://download.csdn.net/download/linhao90/2934821">https://download.csdn.net/download/linhao90/2934821</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bb63297e361e2c603571a5071aaf5a9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">版本控制和构建工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9cc39bd58e38c7f1b39cdacfef2444f1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[填坑]QT5.12 &#43; MYSQL8.0 &#43; VS2017解决各种报错问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>