<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>美团（Leaf）分布式ID生成器，好用的一批！ - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="美团（Leaf）分布式ID生成器，好用的一批！" />
<meta property="og:description" content="不了解分布式ID的同学，先行去看《一口气说出 9种 分布式ID生成方式，面试官有点懵了》温习一下基础知识，这里就不再赘述了
美团（Leaf） Leaf是美团推出的一个分布式ID生成服务，名字取自德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world.”（“世界上没有两片相同的树叶”），取个名字都这么有寓意，美团程序员牛掰啊！
Leaf的优势：高可靠、低延迟、全局唯一等特点。
目前主流的分布式ID生成方式，大致都是基于数据库号段模式和雪花算法（snowflake），而美团（Leaf）刚好同时兼具了这两种方式，可以根据不同业务场景灵活切换。
接下来结合实战，详细的介绍一下Leaf的Leaf-segment号段模式和Leaf-snowflake模式
一、 Leaf-segment号段模式 Leaf-segment号段模式是对直接用数据库自增ID充当分布式ID的一种优化，减少对数据库的频率操作。相当于从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，业务服务将号段在本地生成1~1000的自增ID并加载到内存.。
大致的流程入下图所示：
号段耗尽之后再去数据库获取新的号段，可以大大的减轻数据库的压力。对max_id字段做一次update操作，update max_id= max_id &#43; step，update成功则说明新号段获取成功，新的号段范围是(max_id ,max_id &#43;step]。
由于依赖数据库，我们先设计一下表结构：
CREATE TABLE `leaf_alloc` ( `biz_tag` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;业务key&#39;, `max_id` bigint(20) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;当前已经分配了的最大id&#39;, `step` int(11) NOT NULL COMMENT &#39;初始步长，也是动态调整的最小步长&#39;, `description` varchar(256) DEFAULT NULL COMMENT &#39;业务key的描述&#39;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;数据库维护的更新时间&#39;, PRIMARY KEY (`biz_tag`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 预先插入一条测试的业务数据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8be91741fc6dec2bbd3ceba1375f2641/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-09T11:23:00+08:00" />
<meta property="article:modified_time" content="2020-08-09T11:23:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">美团（Leaf）分布式ID生成器，好用的一批！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>不了解分布式ID的同学，先行去看<a href="http://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw%3D%3D&amp;chksm=fbb29e35ccc51723d20211820715346c70c25e6eaf49d80cde0314aff4ab2d072658038f1a3b&amp;idx=3&amp;mid=2247489483&amp;scene=21&amp;sn=fbf4945e6474d19ab98e99d4088fe441#wechat_redirect" rel="nofollow">《一口气说出 9种 分布式ID生成方式，面试官有点懵了》</a>温习一下基础知识，这里就不再赘述了<br></p> 
 <h3>美团（Leaf）</h3> 
 <p><code>Leaf</code>是美团推出的一个分布式ID生成服务，名字取自德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world.”（“世界上没有两片相同的树叶”），取个名字都这么有寓意，美团程序员牛掰啊！<br></p> 
 <p><code>Leaf</code>的优势：<code>高可靠</code>、<code>低延迟</code>、<code>全局唯一</code>等特点。</p> 
 <p>目前主流的分布式ID生成方式，大致都是基于<code>数据库号段模式</code>和<code>雪花算法（snowflake）</code>，而美团（Leaf）刚好同时兼具了这两种方式，可以根据不同业务场景灵活切换。</p> 
 <p>接下来结合实战，详细的介绍一下<code>Leaf</code>的<code>Leaf-segment号段模式</code>和<code>Leaf-snowflake模式</code></p> 
 <h3>一、 Leaf-segment号段模式</h3> 
 <p><code>Leaf-segment</code>号段模式是对直接用<code>数据库自增ID</code>充当<code>分布式ID</code>的一种优化，减少对数据库的频率操作。相当于从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，业务服务将号段在本地生成1~1000的自增ID并加载到内存.。<br></p> 
 <p>大致的流程入下图所示：</p> 
 <img src="https://images2.imgbox.com/c0/6d/Uo9yEQUC_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p>号段耗尽之后再去数据库获取新的号段，可以大大的减轻数据库的压力。对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是(<code>max_id ,max_id +step</code>]。</p> 
 <p>由于依赖数据库，我们先设计一下表结构：</p> 
 <pre class="has"><code class="language-go">CREATE TABLE `leaf_alloc` (
  `biz_tag` varchar(128) NOT NULL DEFAULT '' COMMENT '业务key',
  `max_id` bigint(20) NOT NULL DEFAULT '1' COMMENT '当前已经分配了的最大id',
  `step` int(11) NOT NULL COMMENT '初始步长，也是动态调整的最小步长',
  `description` varchar(256) DEFAULT NULL COMMENT '业务key的描述',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '数据库维护的更新时间',
  PRIMARY KEY (`biz_tag`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre> 
 <p>预先插入一条测试的业务数据</p> 
 <pre class="has"><code class="language-go">INSERT INTO `leaf_alloc` (`biz_tag`, `max_id`, `step`, `description`, `update_time`) VALUES ('leaf-segment-test', '0', '10', '测试', '2020-02-28 10:41:03');
</code></pre> 
 <ul><li><p><code>biz_tag</code>：针对不同业务需求，用biz_tag字段来隔离，如果以后需要扩容时，只需对biz_tag分库分表即可</p></li><li><p><code>max_id</code>：当前业务号段的最大值，用于计算下一个号段</p></li><li><p><code>step</code>：步长，也就是每次获取ID的数量</p></li><li><p><code>description</code>：对于业务的描述，没啥好说的</p></li></ul> 
 <p>将Leaf项目下载到本地：<code>https://github.com/Meituan-Dianping/Leaf</code></p> 
 <p>修改一下项目中的<code>leaf.properties</code>文件，添加数据库配置</p> 
 <pre class="has"><code class="language-go">leaf.name=com.sankuai.leaf.opensource.test
leaf.segment.enable=true
leaf.jdbc.url=jdbc:mysql://127.0.0.1:3306/xin-master?useUnicode=true&amp;characterEncoding=utf8
leaf.jdbc.username=junkang
leaf.jdbc.password=junkang

leaf.snowflake.enable=false
</code></pre> 
 <p><strong>注意</strong>：<code>leaf.snowflake.enable</code> 与 <code>leaf.segment.enable</code> 是无法同时开启的，否则项目将无法启动。</p> 
 <p>配置相当的简单，直接启动<code>LeafServerApplication</code>后就OK了，接下来测试一下，<code>leaf</code>是基于<code>Http请求</code>的发号服务， <code>LeafController</code> 中只有两个方法，一个号段接口，一个snowflake接口，<code>key</code>就是数据库中预先插入的业务<code>biz_tag</code>。</p> 
 <pre class="has"><code class="language-go">@RestController
public class LeafController {
    private Logger logger = LoggerFactory.getLogger(LeafController.class);

    @Autowired
    private SegmentService segmentService;
    @Autowired
    private SnowflakeService snowflakeService;

    /**
     * 号段模式
     * @param key
     * @return
     */
    @RequestMapping(value = "/api/segment/get/{key}")
    public String getSegmentId(@PathVariable("key") String key) {
        return get(key, segmentService.getId(key));
    }

    /**
     * 雪花算法模式
     * @param key
     * @return
     */
    @RequestMapping(value = "/api/snowflake/get/{key}")
    public String getSnowflakeId(@PathVariable("key") String key) {
        return get(key, snowflakeService.getId(key));
    }

    private String get(@PathVariable("key") String key, Result id) {
        Result result;
        if (key == null || key.isEmpty()) {
            throw new NoKeyException();
        }
        result = id;
        if (result.getStatus().equals(Status.EXCEPTION)) {
            throw new LeafServerException(result.toString());
        }
        return String.valueOf(result.getId());
    }
}
</code></pre> 
 <p>访问：<code>http://127.0.0.1:8080/api/segment/get/leaf-segment-test</code>，结果正常返回，感觉没毛病，但当查了一下数据库表中数据时发现了一个问题。<br></p> 
 <img src="https://images2.imgbox.com/cf/03/Hbutd4kd_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <img src="https://images2.imgbox.com/c5/93/xJbmZX68_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p>通常在用号段模式的时候，取号段的时机是在前一个号段消耗完的时候进行的，可刚刚才取了一个ID，数据库中却已经更新了<code>max_id</code>，也就是说<code>leaf</code>已经多获取了一个号段，这是什么鬼操作？<br></p> 
 <img src="https://images2.imgbox.com/17/86/BXihrLNp_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p><strong><code>Leaf</code>为啥要这么设计呢？</strong></p> 
 <p><code>Leaf</code> 希望能在DB中取号段的过程中做到无阻塞！</p> 
 <p>当号段耗尽时再去DB中取下一个号段，如果此时网络发生抖动，或者DB发生慢查询，业务系统拿不到号段，就会导致整个系统的响应时间变慢，对流量巨大的业务，这是不可容忍的。</p> 
 <p>所以<code>Leaf</code>在当前号段消费到某个点时，就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做很大程度上的降低了系统的风险。</p> 
 <p><strong>那么</strong><strong><code>某个点</code>到底是什么时候呢？</strong></p> 
 <p>这里做了一个实验，号段设置长度为<code>step=10</code>，<code>max_id=1</code><br></p> 
 <img src="https://images2.imgbox.com/5a/d4/721qEnLC_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p>当我拿第一个ID时，看到号段增加了，1/10 <br></p> 
 <img src="https://images2.imgbox.com/8f/11/wjsnttvH_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <img src="https://images2.imgbox.com/72/ba/TdZmCCtL_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p><br>当我拿第三个Id时，看到号段又增加了，3/10<br></p> 
 <img src="https://images2.imgbox.com/f3/5d/scOc1PYn_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <img src="https://images2.imgbox.com/22/6d/WLRdYIQJ_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p><br><code>Leaf</code>采用<code>双buffer</code>的方式，它的服务内部有两个号段缓存区<code>segment</code>。当前号段已消耗10%时，还没能拿到下一个号段，则会另启一个更新线程去更新下一个号段。</p> 
 <p>简而言之就是<code>Leaf</code>保证了总是会多缓存两个号段，即便哪一时刻数据库挂了，也会保证发号服务可以正常工作一段时间。</p> 
 <img src="https://images2.imgbox.com/69/22/HdIeJGeZ_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p>通常推荐号段（<code>segment</code>）长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</p> 
 <p><strong>优点：</strong><strong></strong></p> 
 <ul><li><p>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</p></li><li><p>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</p></li></ul> 
 <p><strong>缺点：</strong><strong></strong></p> 
 <ul><li><p>ID号码不够随机，能够泄露发号数量的信息，不太安全。</p></li><li><p>DB宕机会造成整个系统不可用（用到数据库的都有可能）。</p></li></ul> 
 <h3>二、Leaf-snowflake</h3> 
 <p><code>Leaf-snowflake</code>基本上就是沿用了snowflake的设计，ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>机房ID</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。<br></p> 
 <p><code>Leaf-snowflake</code>不同于原始snowflake算法地方，主要是在workId的生成上，<code>Leaf-snowflake</code>依靠<code>Zookeeper</code>生成<code>workId</code>，也就是上边的<code>机器ID</code>（占5比特）+ <code>机房ID</code>（占5比特）。<code>Leaf</code>中workId是基于ZooKeeper的<code>顺序Id</code>来生成的，每个应用在使用Leaf-snowflake时，启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p> 
 <img src="https://images2.imgbox.com/e0/72/yv7RyV5E_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p><br><code>Leaf-snowflake</code>启动服务的过程大致如下：</p> 
 <ul><li><p>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</p></li><li><p>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</p></li><li><p>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</p></li></ul> 
 <p>但<code>Leaf-snowflake</code>对Zookeeper是一种弱依赖关系，除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个<code>workerID</code>文件。一旦ZooKeeper出现问题，恰好机器出现故障需重启时，依然能够保证服务正常启动。</p> 
 <p>启动<code>Leaf-snowflake</code>模式也比较简单，起动本地ZooKeeper，修改一下项目中的<code>leaf.properties</code>文件，关闭<code>leaf.segment模式</code>，启用<code>leaf.snowflake</code>模式即可。</p> 
 <pre class="has"><code class="language-go">leaf.segment.enable=false
#leaf.jdbc.url=jdbc:mysql://127.0.0.1:3306/xin-master?useUnicode=true&amp;characterEncoding=utf8
#leaf.jdbc.username=junkang
#leaf.jdbc.password=junkang

leaf.snowflake.enable=true
leaf.snowflake.zk.address=127.0.0.1
leaf.snowflake.port=2181
</code></pre> 
 <pre class="has"><code class="language-go">    /**
     * 雪花算法模式
     * @param key
     * @return
     */
    @RequestMapping(value = "/api/snowflake/get/{key}")
    public String getSnowflakeId(@PathVariable("key") String key) {
        return get(key, snowflakeService.getId(key));
    }
</code></pre> 
 <p>测试一下，访问：<code>http://127.0.0.1:8080/api/snowflake/get/leaf-segment-test</code><br></p> 
 <img src="https://images2.imgbox.com/4f/95/WJQHgj5U_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <p><strong>优点：</strong><strong></strong></p> 
 <ul><li><p>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</p></li></ul> 
 <p><strong>缺点：</strong><strong></strong></p> 
 <ul><li><p>依赖ZooKeeper，存在服务不可用风险（实在不知道有啥缺点了）</p></li></ul> 
 <h3>三、Leaf监控</h3> 
 <p>请求地址：<code>http://127.0.0.1:8080/cache</code><br></p> 
 <p>针对服务自身的监控，Leaf提供了Web层的内存数据映射界面，可以实时看到所有号段的下发状态。比如每个号段双buffer的使用情况，当前ID下发到了哪个位置等信息都可以在Web界面上查看。</p> 
 <img src="https://images2.imgbox.com/f9/44/XAjrlLiS_o.png" title="在这里插入图片描述"> 
 <figcaption> 
  <br> 
 </figcaption> 
 <h3>总结</h3> 
 <p>对于Leaf具体使用哪种模式，还是根据具体的业务场景使用，本文并没有对Leaf源码做过多的分析，因为Leaf 代码量简洁很好阅读。后续还会把其他几种分布式ID生成器，依次结合实战介绍给大家，欢迎大家关注。</p> 
 <pre class="has"><code class="language-php">特别推荐一个分享架构+算法的优质内容，还没关注的小伙伴，可以长按关注一下：


</code></pre> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/99/e3/r0FWVbfo_o.png"></p> 
 <pre class="has"><code class="language-php">长按订阅更多精彩▼

如有收获，点个在看，诚挚感谢
</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aede1137cbf8b17150549a253780b871/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MYSQL &#43; JAVA</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42e2319b913f17cbc41aa5cefb13a086/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ILSVRC-ImageNet历年竞赛冠军</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>