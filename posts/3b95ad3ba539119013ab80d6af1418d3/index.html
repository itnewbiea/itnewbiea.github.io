<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker本地私有仓库与harbor私有仓库 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker本地私有仓库与harbor私有仓库" />
<meta property="og:description" content="一、搭建本地私有仓库
1、首先下载registry镜像
1
docker pull registry
2、在daemon.json文件中添加私有镜像仓库地址
1
2
3
4
5
6
7
8
vim /etc/ docker/daemon.json
{
&#34;insecure-registries&#34;: [&#34;192.168.80.11:5000&#34;],
#添加，注意用逗号结尾
&#34;registry-mirrors&#34;: [&#34;https://6ijb8ubo.mirror.aliyuncs.com&#34;]
}
systemctl restart docker.service
3、运行registry容器
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
docker run -itd -v /data/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:latest
===================================================
-itd: 在容器中打开一个伪终端进行交互操作，并在后台运行
-v: 把宿主机的/data/registry目录绑定到容器/var/lib/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的
持久化;
-p:映射端口;访问宿主机的5000端口就访问到registry容器的服务了
--restart=always: 这是重启的策略，在容器退出时总是重启容器
--name registry: 创建容器命名为registry
registry:latest:这个是刚才pull下来的镜像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3b95ad3ba539119013ab80d6af1418d3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-03T20:49:53+08:00" />
<meta property="article:modified_time" content="2023-05-03T20:49:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker本地私有仓库与harbor私有仓库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、搭建本地私有仓库</strong></p> 
<p><strong><a name="b"></a>1、首先下载registry镜像</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>docker pull registry</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/5d/iFFeiBI2_o.png"></p> 
<p></p> 
<p><strong><a name="c"></a>2、在daemon.json文件中添加私有镜像仓库地址</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>vim /etc/ docker/daemon.json</code></p> <p><code>{<!-- --></code></p> <p><code>"insecure-registries"</code><code>: [</code><code>"192.168.80.11:5000"</code><code>],</code></p> <p><code>#添加，注意用逗号结尾</code></p> <p><code>"registry-mirrors"</code><code>: [</code><code>"https://6ijb8ubo.mirror.aliyuncs.com"</code><code>]</code></p> <p><code>}</code></p> <p></p> <p><code>systemctl restart docker.service</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d9/db/DuVvyRA5_o.png"></p> 
<p></p> 
<p><strong><a name="d"></a>3、运行registry容器</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> </td><td> <p><code>docker run -itd -v /data/registry:/</code><code>var</code><code>/lib/registry -p 5000:5000 --restart=always --name registry registry:latest</code></p> <p><code>===================================================</code></p> <p><code>-itd: 在容器中打开一个伪终端进行交互操作，并在后台运行</code></p> <p><code>-v: 把宿主机的/data/registry目录绑定到容器/</code><code>var</code><code>/lib/registry目录(这个目录是registry容器中存放镜像文件的目录)，来实现数据的</code></p> <p><code>持久化;</code></p> <p><code>-p:映射端口;访问宿主机的5000端口就访问到registry容器的服务了</code></p> <p><code>--restart=always: 这是重启的策略，在容器退出时总是重启容器</code></p> <p><code>--name registry: 创建容器命名为registry</code></p> <p><code>registry:latest:这个是刚才pull下来的镜像</code></p> <p><code>====================================================</code></p> <p><code>Docker容器的重启策略如下:</code></p> <p><code>no:默认策略，在容器退出时不重启容器</code></p> <p><code>on</code><code>-failure: 在容器非正常退出时(退出状态非0)，才会重启容器</code></p> <p><code>on</code><code>-failure:3 :在容器非正常退出时重启容器，最多重启3次</code></p> <p><code>always: 在容器退出时总是重启容器</code></p> <p><code>unless-stopped: 在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/10/5d/vNibNYpq_o.png"></p> 
<p><strong><a name="e"></a>4、为镜像打标签</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>docker tag centos:7 192.168.142.3:5000/centos7:jc</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6c/38/pb41GBWZ_o.png"></p> 
<p></p> 
<p><strong><a name="f"></a>5、上传到私有仓库</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>docker push 192.168.142.5:5000/centos7:jc</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c5/3a/5CeBls8I_o.png"></p> 
<p></p> 
<p><strong><a name="g"></a>6、列出私有仓库的所有镜像</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>curl http:</code><code>//192.168.142.3:5000/v2/_catalog</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bd/e9/1UOIBFO3_o.png"></p> 
<p></p> 
<p><strong><a name="h"></a>7、列出私有仓库的centos7镜像有哪些tag</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>curl http:</code><code>//192.168.142.3:5000/v2/centos7/tags/list</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f3/23/DLdf81ys_o.png"></p> 
<p></p> 
<p><strong><a name="i"></a>8、先删除原有的centos的镜像，再测试私有仓库下载</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>docker images</code></p> <p><code>docker rmi -f eeb6ee3f44bd</code></p> <p><code>docker pull 192.168.142.3:5000/centos7:jc</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/92/94/5vF2Zfu6_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/19/d6/ZYxratNq_o.png"></p> 
<p></p> 
<p><strong><a name="j"></a>二、Harbor 简介</strong></p> 
<p><strong><a name="k"></a>1、什么是Harbor</strong>　　</p> 
<p>（1）Harbor 是 VMware 公司开源的企业级 Docker Registry 项目，其目标是帮助用户迅速搭建一个企业级的 Docker Registry 服务。</p> 
<p>（2）Harbor以 Docker 公司开源的 Registry 为基础，提供了图形管理 UI 、基于角色的访问控制(Role Based AccessControl) 、AD/LDAP 集成、以及审计日志(Auditlogging) 等企业用户需求的功能，同时还原生支持中文。</p> 
<p>（3）Harbor 的每个组件都是以 Docker 容器的形式构建的，使用 docker-compose 来对它进行部署。用于部署 Harbor 的 docker-compose 模板位于 harbor/docker-compose.yml。</p> 
<p><strong><a name="l"></a>2、Harbor的特性</strong>　　</p> 
<p>（1）基于角色控制：用户和仓库都是基于项目进行组织的，而用户在项目中可以拥有不同的权限。<br> （2）基于镜像的复制策略：镜像可以在多个Harbor实例之间进行复制（同步）。<br> （3）支持 LDAP/AD：Harbor 可以集成企业内部已有的 AD/LDAP（类似数据库的一张表），用于对已经存在的用户认证和管理。<br> （4）镜像删除和垃圾回收：镜像可以被删除，也可以回收镜像占用的空间。<br> （5）图形化用户界面：用户可以通过浏览器来浏览，搜索镜像仓库以及对项目进行管理。<br> （6）审计管理：所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。<br> （7）支持 RESTful API：RESTful API 提供给管理员对于 Harbor 更多的操控, 使得与其它管理软件集成变得更容易。<br> （8）Harbor和docker registry的关系：Harbor实质上是对docker registry做了封装，扩展了自己的业务模板。</p> 
<p><strong><a name="m"></a>3、Harbor的构成</strong>　　</p> 
<p>Harbor 在架构上主要有 Proxy、Registry、Core services、Database（Harbor-db）、Log collector（Harbor-log）、Job services 六个组件。</p> 
<p>（1）Proxy: Harbor 的 Registry、UI、Token 服务等组件，都处在 nginx 反向代理后边。该代理将来自浏览器、docker clients 的请求转发到后端不同的服务上。</p> 
<p>（2）Registry: 负责储存 Docker 镜像，并处理 Docker push/pull 命令。由于要对用户进行访问控制，即不同用户对 Docker 镜像 有不同的读写权限，Registry 会指向一个 Token 服务，强制用户的每次 Docker pull/push 请求都要携带一个合法的 Token， Registry 会通过公钥对 Token 进行解密验证。</p> 
<p>（3）Core services: Harbor的核心功能，主要提供以下3个服务:<br> 1）UI（harbor-ui）: 提供图形化界面，帮助用户管理 Registry 上的镜像（image）, 并对用户进行授权。<br> 2）WebHook：为了及时获取Registry 上image 状态变化的情况，在Registry 上配置 Webhook，把状态变化传递给 UI 模块。<br> 3）Token 服务：负责根据用户权限给每个 Docker push/pull 命令签发 Token。Docker 客户端向 Registry 服务发起的请求， 如果不包含 Token，会被重定向到 Token 服务，获得 Token 后再重新向 Registry 进行请求。</p> 
<p>（4）Database（harbor-db）：为core services提供数据库服务，负责储存用户权限、审计日志、Docker 镜像分组信息等数据。</p> 
<p>（5）Job services: 主要用于镜像复制，本地镜像可以被同步到远程 Harbor 实例上。</p> 
<p>（6）Log collector（harbor-log）: 负责收集其他组件的日志到一个地方。</p> 
<p><br> 总结：Harbor 的每个组件都是以 Docker 容器的形式构建的，因此，使用 Docker Compose 来对它进行部署。<br> 总共分为7个容器运行，通过在docker-compose.yml所在目录中执行 docker-compose ps 命令来查看， 名称分别为：nginx、harbor-jobservice、harbor-ui、harbor-db、harbor-adminserver、registry、harbor-log。<br> 其中 harbor-adminserver 主要是作为一个后端的配置数据管理，并没有太多的其他功能。harbor-ui 所要操作的所有数据都通过 harbor-adminserver 这样一个数据配置管理中心来完成。</p> 
<p><strong><a name="n"></a>三、Harbor 部署 </strong></p> 
<p><strong><a name="o"></a>1、环境部署</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>Harbor服务器           192.168.142.3       docker-ce、docker-compose、harbor-offline-v1.2.2</code></p> <p><code>client服务器           192.168.142.4       docker-ce</code></p> </td></tr></tbody></table> 
<p><strong><a name="p"></a>2、部署 Docker-Compose 服务　</strong>　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>//下载或者上传 Docker-Compose</code></p> <p><code>curl -L https:</code><code>//github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></p> <p></p> <p><code>chmod +x /usr/local/bin/docker-compose</code></p> <p></p> <p><code>docker-compose -v</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1e/85/tIxf3Wh5_o.png"></p> 
<p><strong><a name="q"></a>3、部署 Harbor 服务</strong>　　</p> 
<p>（1）下载或上传 Harbor 安装程序　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>wget http:</code><code>//harbor.orientsoft.cn/harbor-1.2.2/harbor-offline-installer-v1.2.2.tgz</code></p> <p></p> <p><code>tar zxvf harbor-offline-installer-v1.2.2.tgz -C /usr/local/</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8e/5d/iRvIoaDF_o.png"></p> 
<p></p> 
<p>（2）修改harbor安装的配置文件　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <p><code>vim /usr/local/harbor/harbor.cfg</code></p> <p><code>--5行--修改，设置为Harbor服务器的IP地址或者域名</code></p> <p><code>hostname = 192.168.142.3</code></p> <p><code>--59行--指定管理员的初始密码，默认的用户名/密码是admin/Harbor12345</code></p> <p><code>harbor_admin_password = Harbor12345</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/76/88/PIb2NHUB_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1e/33/LZzX8DSA_o.png"></p> 
<p><strong><a name="r"></a>4、关于 Harbor.cfg 配置文件中有两类参数：所需参数和可选参数　</strong>　</p> 
<p>（1）所需参数：这些参数需要在配置文件 Harbor.cfg 中设置。如果用户更新它们并运行 install.sh 脚本重新安装 Harbour， 参数将生效。具体参数如下：<br> ● hostname：用于访问用户界面和 register 服务。它应该是目标机器的 IP 地址或完全限定的域名（FQDN），例如 192.168.80.10 或 hub.kgc.cn。不要使用 localhost 或 127.0.0.1 为主机名。</p> 
<p>● ui_url_protocol：（http 或 https，默认为 http）用于访问 UI 和令牌/通知服务的协议。如果处于启用状态，则此参数必须为 https。</p> 
<p>● max_job_workers：镜像复制作业线程。</p> 
<p>● db_password：用于db_auth 的MySQL数据库root 用户的密码。</p> 
<p>● customize_crt：该属性可设置为打开或关闭，默认打开。打开此属性时，准备脚本创建私钥和根证书，用于生成/验证注册表令牌。当由外部来源提供密钥和根证书时，将此属性设置为 off。</p> 
<p>● ssl_cert：SSL 证书的路径，仅当协议设置为 https 时才应用。</p> 
<p>● secretkey_path：用于在复制策略中加密或解密远程 register 密码的密钥路径。</p> 
<p>（2）可选参数：这些参数对于更新是可选的，即用户可以将其保留为默认值，并在启动 Harbor 后在 Web UI 上进行更新。如果进入 Harbor.cfg，只会在第一次启动 Harbor 时生效，随后对这些参数的更新，Harbor.cfg 将被忽略。</p> 
<p>注意：如果选择通过 UI 设置这些参数，请确保在启动 Harbor 后立即执行此操作。具体来说，必须在注册或在 Harbor 中创建任何新用户之前设置所需的 auth_mode。当系统中有用户时（除了默认的 admin 用户）， auth_mode 不能被修改。 具体参数如下：<br> ● Email：Harbor 需要该参数才能向用户发送“密码重置”电子邮件，并且只有在需要该功能时才启用。请注意，在默认情况下 SSL 连接时没有启用。如果 SMTP 服务器需要 SSL，但不支持 STARTTLS，那么应该通过设置启用 SSL email_ssl = TRUE。</p> 
<p>● harbour_admin_password：管理员的初始密码，只在 Harbour 第一次启动时生效。之后， 此设置将被忽略，并且应在 UI 中设置管理员的密码。请注意，默认的用户名/密码是admin/Harbor12345。</p> 
<p>● auth_mode：使用的认证类型，默认情况下，它是 db_auth，即凭据存储在数据库中。对于LDAP身份验证，请将其设置为 ldap_auth。</p> 
<p>● self_registration：启用/禁用用户注册功能。禁用时，新用户只能由 Admin 用户创建，只有管理员用户可以在 Harbour 中创建新用户。注意：当 auth_mode 设置为 ldap_auth 时，自注册功能将始终处于禁用状态，并且该标志被忽略。</p> 
<p>● Token_expiration：由令牌服务创建的令牌的到期时间（分钟），默认为 30 分钟。</p> 
<p>● project_creation_restriction：用于控制哪些用户有权创建项目的标志。默认情况下，每个人都可以创建一个项目。如果将其值设置为“adminonly”，那么只有 admin 可以创建项目。</p> 
<p>● verify_remote_cert：打开或关闭，默认打开。此标志决定了当Harbor与远程 register 实例通信时是否验证 SSL/TLS 证书。 将此属性设置为 off 将绕过 SSL/TLS 验证，这在远程实例具有自签名或不可信证书时经常使用。</p> 
<p>另外，默认情况下，Harbour 将镜像存储在本地文件系统上。在生产环境中，可以考虑 使用其他存储后端而不是本地文件系统，如 S3、Openstack Swif、Ceph 等对象存储。但需要更新 common/templates/registry/config.yml 文件。</p> 
<p><strong><a name="s"></a>5、启动 Harbor</strong>　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>cd /usr/local/harbor/</code></p> <p><code>./install.sh</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/42/8PyX3L3W_o.png"></p> 
<p></p> 
<p><strong><a name="t"></a>6、查看 Harbor 启动镜像　</strong>　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>cd /usr/local/harbor/</code></p> <p><code>docker-compose ps</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/24/5gkn9sAA_o.png"></p> 
<p></p> 
<p><strong><a name="u"></a>7、创建一个新项目</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> </td><td> <p><code>（1）浏览器访问：http:</code><code>//192.168.142.3 登录 Harbor WEB UI 界面，默认的管理员用户名和密码是 admin/Harbor12345</code></p> <p></p> <p><code>（2）输入用户名和密码登录界面后可以创建一个新项目。点击“+项目”按钮</code></p> <p></p> <p><code>（3）填写项目名称为“jc”，点击“确定”按钮，创建新项目</code></p> <p></p> <p><code>（4）此时可使用 Docker 命令在本地通过 127.0.0.1 来登录和推送镜像。默认情况下，Registry 服务器在端口 80 上侦听。</code></p> <p><code>//登录 Harbor</code></p> <p><code>docker login [-u admin -p Harbor12345] http:</code><code>//127.0.0.1</code></p> <p></p> <p><code>//下载镜像进行测试</code></p> <p><code>docker pull nginx</code></p> <p></p> <p><code>//将镜像打标签</code></p> <p><code>格式：docker tag 镜像:标签  仓库IP/项目名称/镜像名:标签</code></p> <p><code>docker tag nginx:latest 127.0.0.1/jc/nginx:test</code></p> <p></p> <p><code>//上传镜像到 Harbor</code></p> <p><code>docker push 127.0.0.1/jc/nginx:test</code></p> <p></p> <p><code>（5）在 Harbor 界面 myproject-kgc 目录下可看见此镜像及相关信息</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fa/ef/7DiL0BAP_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dc/db/0EnglvkR_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bf/df/PMMi15Zu_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/a9/8zsAaEm2_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/fe/JSueOKAo_o.png"></p> 
<p></p> 
<p><strong><a name="v"></a>8、在其他客户端上传镜像</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>以上操作都是在 Harbor 服务器本地操作。如果其他客户端登录到 Harbor，就会报如下错误。出现这问题的原因为Docker Registry 交互默认使用的是 HTTPS，但是搭建私有镜像默认使用的是 HTTP 服务，所以与私有镜像交互时出现以下错误。</code></p> </td></tr></tbody></table> 
<p>docker login -u admin -p Harbor12345 http://192.168.142.3</p> 
<p>WARNING! Using --password via the CLI is insecure. Use --password-stdin.<br> Error response from daemon: Get "https://192.168.142.3/v2/": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/77/e4/UutZZ2x3_o.png"></p> 
<p></p> 
<p>（1）在 Docker 客户端配置操作　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> <p>19</p> <p>20</p> <p>21</p> <p>22</p> <p>23</p> <p>24</p> <p>25</p> </td><td> <p><code>//解决办法是：在 Docker server 启动的时候，增加启动参数，默认使用 HTTP 访问。</code></p> <p><code>vim /usr/lib/systemd/system/docker.service</code></p> <p><code>--13行--修改</code></p> <p><code>ExecStart=/usr/bin/dockerd -H fd:</code><code>// --insecure-registry 192.168.142.3 --containerd=/run/containerd/containerd.sock</code></p> <p><code>或</code></p> <p><code>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.142.3</code></p> <p></p> <p><code>//重启 Docker，再次登录</code></p> <p><code>systemctl daemon-reload</code></p> <p><code>systemctl restart docker</code></p> <p></p> <p><code>//再次登录 Harbor</code></p> <p><code>docker login -u admin -p Harbor12345 http:</code><code>//192.168.142.3</code></p> <p><code>WARNING! Using --password via the CLI </code><code>is</code> <code>insecure. Use --password-stdin.</code></p> <p><code>WARNING! Your password will be stored unencrypted </code><code>in</code> <code>/root/.docker/config.json.</code></p> <p><code>Login Succeeded</code></p> <p><code>//将自动保存凭据到/root/.docker/config.json，下次登录时可直接使用凭据登录 Harbor</code></p> <p></p> <p><code>//下载镜像进行测试</code></p> <p><code>docker pull 192.168.142.3/jc/nginx:test</code></p> <p></p> <p><code>//上传镜像进行测试</code></p> <p><code>docker pull cirros</code></p> <p><code>docker tag cirros:latest 192.168.142.3/jc/cirros:test1</code></p> <p><code>docker push 192.168.80.10/jc/cirros:test1</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2d/fa/5KUKLFlz_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/53/uLE4hHd8_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/27/ac/jJftx6Od_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e5/29/Cm8X1WNG_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c6/32/TFyIz8Vh_o.png"></p> 
<p></p> 
<p>（2）刷新 Harbor 的 Web 管理界面进行查看，会发现jc项目里面有两个镜像</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c9/45/nUNERZBR_o.png"></p> 
<p></p> 
<p><strong><a name="w"></a>四、维护管理Harbor</strong></p> 
<p><strong><a name="x"></a>1、通过 Harbor Web 创建项目　</strong>　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>在 Harbor 仓库中，任何镜像在被 push 到 regsitry 之前都必须有一个自己所属的项目。</code></p> <p><code>单击“+项目”，填写项目名称，项目级别若设置为</code><code>"私有"</code><code>，则不勾选。如果设置为公共仓库，则所有人对此项目下的镜像拥有读权限，命令行中不需要执行</code><code>"Docker login"</code><code>即可下载镜像，镜像操作与 Docker Hub 一致。</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e9/ba/OsrSGMbB_o.png"></p> 
<p></p> 
<p><strong><a name="y"></a>2、创建 Harbor 用户　</strong>　</p> 
<p>（1）创建用户并分配权限</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> </td><td> <p><code>在 Web 管理界面中单击系统管理 -&gt; 用户管理 -&gt; +用户，</code></p> <p><code>填写用户名为“jc”，邮箱为“jc13057662308@163.com”，全名为“jiangchao”，密码为“Jc123456”，注释为“管理员”（可省略）。</code></p> <p><code>附：用户创建成功后，单击左侧“...”按钮可将上述创建的用户设置为管理员角色或进行删除操作，本例不作任何设置。</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9f/1b/Kp2Ep2sK_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/74/a5/4DWcwbgO_o.png"></p> 
<p></p> 
<p>（2）添加项目成员　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>单击项目 -&gt; jc-&gt; 成员 -&gt; + 成员，填写上述创建的用户 jc 并分配角色为“开发人员”。</code></p> <p><code>附：此时单击左侧“...”按钮仍然可对成员角色进行变更或者删除操作</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/84/1a/vy4FdCxP_o.png"></p> 
<p></p> 
<p>（3）在客户端上使用普通账户操作镜像　　//删除上述打标签的本地镜像</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> </td><td> <p><code>docker rmi 192.168.142.3/jc/cirros:test1</code></p> <p></p> <p><code>//先退出当前用户，然后使用上述创建的账户 kgc-zhangsan 登录</code></p> <p><code>docker logout 192.168.142.3</code></p> <p></p> <p><code>docker login 192.168.142.3</code></p> <p><code>或</code></p> <p><code>docker login -u jc -p Jc123456 http:</code><code>//192.168.142.3</code></p> <p></p> <p><code>//下载和上传镜像进行测试</code></p> <p><code>docker pull 192.168.142.3/jc/cirros:test1</code></p> <p></p> <p><code>docker tag 192.168.142.3/jc/cirros:test 192.168.142.3/jc/cirros:test2</code></p> <p><code>docker push 192.168.142.3/jc/cirros:test2</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e0/51/0YgGLIH2_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/33/27/mFYBsr6Q_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/61/37/iNPK7xCd_o.png"></p> 
<p></p> 
<p><strong><a name="z"></a>3、查看日志　</strong>　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>Web 界面日志，操作日志按时间顺序记录用户相关操作</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d9/7b/bGlqjZEX_o.png"></p> 
<p></p> 
<p><strong><a name="aa"></a>4、修改 Harbor.cfg 配置文件</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> <p>15</p> <p>16</p> <p>17</p> <p>18</p> </td><td> <p><code>要更改 Harbour的配置文件中的可选参数时，请先停止现有的 Harbour实例并更新 Harbor.cfg；然后运行 prepare 脚本来填充配置； 最后重新创建并启动 Harbour 的实例。</code></p> <p></p> <p><code>使用 docker-compose 管理 Harbor 时，必须在与 docker-compose.yml 相同的目录中运行。</code></p> <p><code>cd /usr/local/harbor</code></p> <p><code>docker-compose down -v</code></p> <p></p> <p><code>vim harbor.cfg          #只能修改可选参数</code></p> <p></p> <p><code>./prepare</code></p> <p></p> <p><code>docker-compose up -d</code></p> <p><code>//如果有以下报错，需要开启防火墙 firewalld 服务解决</code></p> <p><code>Creating network </code><code>"harbor_harbor"</code> <code>with the </code><code>default</code> <code>driver</code></p> <p><code>ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule:  (iptables failed: iptables --wait -t nat -I DOCKER -i br-b53c314f45e8 -j RETURN: iptables: No chain/target/match </code><code>by</code> <code>that name.</code></p> <p><code> </code><code>(exit status 1))</code></p> <p></p> <p><code>systemctl restart firewalld.service</code></p> <p><code>docker-compose up -d</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8c/9a/HrqXsO7l_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/e6/oPQgvmdp_o.png"></p> 
<p></p> 
<p><strong><a name="bb"></a>5、移除 Harbor 服务容器同时保留镜像数据/数据库，并进行迁移</strong>　　</p> 
<p>在Harbor服务器上操作　　</p> 
<p>（1）移除 Harbor 服务容器　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> </td><td> <p><code>cd /usr/local/harbor</code></p> <p><code>docker-compose down -v</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ff/82/6WGVYnwQ_o.png"></p> 
<p>（2）把项目中的镜像数据进行打包　　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>//持久数据，如镜像，数据库等在宿主机的/data/目录下，日志在宿主机的/var/log/Harbor/目录下</code></p> <p><code>ls /data/registry/docker/registry/v2/repositories/jc</code></p> <p><code>cd /data/registry/docker/registry/v2/repositories/jc</code></p> <p><code>tar zcvf jc-registry.tar.gz ./*mv jc-registry.tar.gz /root</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/58/2a/PpE43C9Q_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4b/82/y89oDNmQ_o.png"></p> 
<p><strong><a name="cc"></a>6、如需重新部署，需要移除 Harbor 服务容器全部数据　</strong>　</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> </td><td> <p><code>cd /usr/local/harbor</code></p> <p><code>docker-compose down -v</code></p> <p><code>rm -r /data/database</code></p> <p><code>rm -r /data/registry</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/aa/bc/xpLfQDEx_o.png"></p> 
<p><strong><a name="zz"></a>7、解压缩数据包并重新启动harbor</strong></p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>mkdir -p /data/registry/docker/registry/v2/repositories/jc</code></p> <p><code>tar zxvf /root/jc-registry.tar.gz -C /data/registry/docker/registry/v2/repositories/jc</code></p> <p></p> <p><code>cd /usr/local/harbor</code></p> <p><code>docker-compose up -d   #重启一下</code></p> <p></p> <p><code>docker-compose down -v</code></p> <p><code>docker-compose up -d   #再重启一下</code></p> </td></tr></tbody></table> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/98/82/FLWYOHCQ_o.png"></p> 
<p> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/00/ed/glsBwbdU_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/35/vPyfVdFb_o.png"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70346344b326ead61da57f7e07f4d60b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">抖音和tiktok的逆向开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/213980dd477c4ed5a98ccc57e0771f06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">行人重识别(REID)——原理方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>