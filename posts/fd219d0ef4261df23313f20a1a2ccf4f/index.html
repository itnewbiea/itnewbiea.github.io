<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TRACE32——AMP多核调试 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TRACE32——AMP多核调试" />
<meta property="og:description" content="TRACE32——AMP多核调试 之前有一篇文章介绍过芯片的SMP多核调试，适用于同架构的内核运行同一套操作系统的场景。例如英飞凌的TC275TF芯片的三个TriCore核以SMP的方式运行着AutoSar操作系统。
但随着芯片的使用场景越来越复杂，芯片厂商推出的SoC可能会同时集成不同架构的内核用于不同的功能。
例如TI公司推出的TDA4VM芯片含有Cortex-M3、Cortex-R5、Cortex-A72、C66x DSP、C7x DSP等不同架构的内核。
不同架构的内核有不同的指令集、有不同的代码空间、运行不同的操作系统，所以也需要不同的TRACE32窗口（GUI）来进行调试。但此时TRACE32 GUI之间共享一个劳特巴赫设备以及一个JTAG调试接口：
传统方式调试AMP
如果是在Windows PC机上，我们可以使用TRACE32 Start程序进行配置AMP调试环境。根据需要调试的内核架构，添加相应的配置项即可。
配置好后，只需在Configuration名字处（图中是TDA4的位置）或者1:PodBus Device Chain处右键，点击Start，便会自动打开所有核的调试窗口。
关于TRACE32 Start的使用方法可以参考app_t32start.pdf
由于AMP多核调试时，可能会使用Trace（跟踪）功能，为了便于TRACE32更好地处理多核之间的Trace数据，建议在各个GUI中，执行如下命令
System.config 在每个GUI中修改此处的参数：
对于绝大部分情况，此处参数的配置原则为：
core：任意数字，各个GUI之间不重复即可。
推荐按窗口顺序填写：
即第一个GUI的值写1. 第二个GUI的值写2.以此类推
chip：各个GUI之间保持为相同值
推荐都写1.
有时候，AMP多核调试时，可能会希望主核开始运行时，其他从核也能同步运行起来。此时，可以执行Synch命令进行相应的同步配置：
注意：使用Synch功能的前提是，每个GUI都打开了InterCom Port。具体操作方法可以参考文档：
general_ref_s.pdf的Synch章节ide_ref.pdf的InterCom章节 新方法调试AMP
如果在Linux PC上使用TRACE32，可能没有TRACE32 Start。因此TRACE32推出了更高效更通用的方法（需要2020年以后的TRACE32版本），主要为下面两个命令组
//用于打开新的GUI、查看已经打开的GUI TargetSystem //用于GUI之间的通信、跨GUI之间执行命令 InterCom 以TI芯片TDA4VM为例，AMP相关调试方法如下：
按照正常方式启动第一个TRACE32 GUI用于第一个内核/子系统的调试。
例如，TDA4VM的MCU域的R5 SMP 多核子系统
在调试过程中，如果需要同时调试其他内核/子系统，可以使用这条命令再启一个TRACE32 GUI：
TargetSystem.NewInstance &lt;新窗口名字&gt; /ARCH &lt;新窗口架构&gt; // 其中新窗口名字，可以任意取名 // 架构名可选的有： // - ARM：所有ARM核 // - ARM64：2022年开始的TRACE32版本不区分ARM和ARM64，任选一个即可 // - Tricore: 英飞凌Tricore核 // - C6000 // - C7000 // - 等等，更多的架构可以在TRACE32命令行下方的提示栏中进行选取 例如希望调试TDA4VM MAIN0域的R5 SMP子系统，新打开的GUI调试的架构，和当前GUI调试的架构一样时，/ARCH参数可省略：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/fd219d0ef4261df23313f20a1a2ccf4f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-05T23:16:08+08:00" />
<meta property="article:modified_time" content="2022-08-05T23:16:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TRACE32——AMP多核调试</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="TRACE32AMP_0"></a>TRACE32——AMP多核调试</h2> 
<p>之前有一篇文章介绍过芯片的<a href="https://blog.csdn.net/weixin_48120109/article/details/126167789?spm=1001.2014.3001.5501">SMP多核调试</a>，适用于同架构的内核运行同一套操作系统的场景。<a href="https://blog.csdn.net/weixin_48120109/article/details/126167789?spm=1001.2014.3001.5501">例如英飞凌的TC275TF芯片的三个TriCore核以SMP的方式运行着AutoSar操作系统。</a></p> 
<p>但随着芯片的使用场景越来越复杂，芯片厂商推出的SoC可能会同时集成不同架构的内核用于不同的功能。</p> 
<p>例如TI公司推出的TDA4VM芯片含有Cortex-M3、Cortex-R5、Cortex-A72、C66x DSP、C7x DSP等不同架构的内核。</p> 
<p>不同架构的内核有不同的指令集、有不同的代码空间、运行不同的操作系统，所以也需要<strong>不同的TRACE32窗口（GUI）来进行调试</strong>。但此时TRACE32 GUI之间共享一个劳特巴赫设备以及一个JTAG调试接口：</p> 
<p><img src="https://images2.imgbox.com/cd/8d/6ph55JaM_o.png" alt="图片"></p> 
<blockquote> 
 <p>传统方式调试AMP</p> 
</blockquote> 
<p>如果是在Windows PC机上，我们可以使用<em><strong>TRACE32 Start</strong></em>程序进行配置AMP调试环境。根据需要调试的内核架构，添加相应的配置项即可。</p> 
<p><img src="https://images2.imgbox.com/55/30/JRMHWDQR_o.jpg" alt="图片"></p> 
<p>配置好后，只需在Configuration名字处（图中是TDA4的位置）或者<strong>1:PodBus Device Chain</strong>处右键，点击Start，便会自动打开所有核的调试窗口。</p> 
<p><img src="https://images2.imgbox.com/07/94/QDmdosMk_o.png" alt="图片"></p> 
<p>关于TRACE32 Start的使用方法可以参考<em><strong>app_t32start.pdf</strong></em></p> 
<p>由于AMP多核调试时，可能会使用Trace（跟踪）功能，为了便于TRACE32更好地处理多核之间的Trace数据，建议在各个GUI中，执行如下命令</p> 
<pre><code>System.config
</code></pre> 
<p>在每个GUI中修改此处的参数：</p> 
<p><img src="https://images2.imgbox.com/a0/56/lrP38STG_o.png" alt="图片"></p> 
<p>对于绝大部分情况，此处参数的配置原则为：</p> 
<p><strong>core</strong>：任意数字，各个GUI之间不重复即可。</p> 
<p>推荐按窗口顺序填写：</p> 
<p><strong>即第一个GUI的值写1. 第二个GUI的值写2.以此类推</strong></p> 
<p><strong>chip</strong>：各个GUI之间保持为相同值</p> 
<p><strong>推荐都写1.</strong></p> 
<p>有时候，AMP多核调试时，可能会希望主核开始运行时，其他从核也能同步运行起来。此时，可以执行<em><strong>Synch</strong></em>命令进行相应的同步配置：</p> 
<p><img src="https://images2.imgbox.com/93/68/KIh033aV_o.png" alt="图片"></p> 
<p><em>注意：使用Synch功能的前提是，每个GUI都打开了InterCom Port。具体操作方法可以参考文档：</em></p> 
<ul><li><em><strong>general_ref_s.pdf</strong>的Synch章节</em></li><li><em><strong>ide_ref.pdf</strong>的InterCom章节</em></li></ul> 
<blockquote> 
 <p>新方法调试AMP</p> 
</blockquote> 
<p>如果在Linux PC上使用TRACE32，可能没有TRACE32 Start。因此TRACE32推出了更高效更通用的方法（<em>需要2020年以后的TRACE32版本</em>），主要为下面两个命令组</p> 
<pre><code>//用于打开新的GUI、查看已经打开的GUI
TargetSystem  

//用于GUI之间的通信、跨GUI之间执行命令
InterCom  
</code></pre> 
<p>以TI芯片TDA4VM为例，AMP相关调试方法如下：</p> 
<p><strong>按照正常方式启动第一个TRACE32 GUI用于第一个内核/子系统的调试</strong>。</p> 
<p>例如，TDA4VM的MCU域的R5 SMP 多核子系统</p> 
<p><img src="https://images2.imgbox.com/4d/00/f2g7eQOq_o.png" alt="图片"></p> 
<p><strong>在调试过程中，如果需要同时调试其他内核/子系统，可以使用这条命令再启一个TRACE32 GUI：</strong></p> 
<pre><code>TargetSystem.NewInstance &lt;新窗口名字&gt; /ARCH &lt;新窗口架构&gt;
// 其中新窗口名字，可以任意取名
// 架构名可选的有：
// - ARM：所有ARM核
// - ARM64：2022年开始的TRACE32版本不区分ARM和ARM64，任选一个即可
// - Tricore: 英飞凌Tricore核
// - C6000 
// - C7000
// - 等等，更多的架构可以在TRACE32命令行下方的提示栏中进行选取
</code></pre> 
<p>例如希望调试TDA4VM MAIN0域的R5 SMP子系统，<strong>新打开的GUI调试的架构，和当前GUI调试的架构一样时，/ARCH参数可省略</strong>：</p> 
<pre><code>// 新GUI名字任意选取，例如 main0TargetSystem.NewInstance main0
</code></pre> 
<p>这条命令会:</p> 
<ul><li>打开当前GUI的Intercom Port（如果未打开）</li><li>克隆当前GUI使用的配置文件（config.t32）</li><li>并将配置文件的Intercom Port加1后，供新打开的GUI使用</li></ul> 
<p>当然上面的操作是<strong>TRACE32底层自动做的，一般用户可以不用关心</strong>。只需要记住新打开的GUI的名字。</p> 
<p><img src="https://images2.imgbox.com/39/99/ifDML0u1_o.png" alt="图片"></p> 
<p>如果用户习惯使用用鼠标操作，可仍然按照以前的习惯，在新打开的GUI中：</p> 
<ul><li><strong>选择要调试的内核/芯片/子系统名字</strong></li><li><strong>进行Attach操作，连上内核后开始调试</strong></li></ul> 
<p>也有用户习惯使用CMM脚本操作TRACE32，通过这种方法调试AMP多核的优势是，可以使用一个CMM脚本，控制所有多核窗口。示意图如下：</p> 
<p><img src="https://images2.imgbox.com/03/90/ZBcyCFe1_o.png" alt="图片"></p> 
<p>单个CMM脚本能够控制所有窗口的操作，主要用了如下命令：</p> 
<pre><code>Intercom.execute &lt;窗口名字&gt; &lt;命令&gt;
//命令可简写成如下格式
IC &lt;窗口名字&gt; &lt;命令&gt;
</code></pre> 
<p>本例子中，我们的脚本可以这样写：</p> 
<pre><code>//第一个GUI：MCU-R5
System.cpu TDA4VM-CR5-MCU
core.assign 1,2  //MCU域是一个R5 SMP子系统
System.attach 
Break
List /core 0
List /core 1

//*******打开第二个GUI：MAIN0-R5**********
TargetSystem.NewInstance main0
IC main0 System.cpu TDA4VM-CR5-MAIN0
IC main0 System.CONFIG.CORE 2. 1. 
IC main0 core.assign 1,2  //MAIN0域是一个R5 SMP子系统
IC main0 System.attach 
IC main0 Break
IC main0 List /core 0
IC main0 List /core 1
</code></pre> 
<p>同理，我们也可以用类似的方法，打开其他核的调试窗口，例如TDAVM芯片中的DSP C66x</p> 
<p><img src="https://images2.imgbox.com/27/61/osCYQSfz_o.png" alt="图片"></p> 
<p>当打开的GUI比较多后，除了可以使用*IC &lt;窗口名字&gt; &lt;命令&gt;*的方法来对指定GUI进行操作。还可以使用<strong>ALL</strong>、<strong>OTRHERS</strong>，来进行多个GUI的同时操作：</p> 
<pre><code>//对所有已经打开的GUI，执行命令
IC ALL &lt;命令&gt;

//除了当前GUI，对其他所有窗口执行命令
IC OTHERS &lt;命令&gt;
</code></pre> 
<p>命令示意图如下：</p> 
<p><em><strong>IC ALL Go</strong></em></p> 
<p><img src="https://images2.imgbox.com/fb/9a/N9qe3XDv_o.png" alt="图片"></p> 
<p><em><strong>IC Others Go</strong></em></p> 
<p><img src="https://images2.imgbox.com/a9/8b/E0f8nMS9_o.png" alt="图片"></p> 
<p>综合更多的内核和命令，CMM脚本功能更新如下：</p> 
<pre><code>//script.cmm 在第一个GUI中执行
//第一个GUI：MCU-R5
System.cpu TDA4VM-CR5-MCU
core.assign 1,2  //MCU域是一个R5 SMP子系统
System.attach 
Break
List /core 0
List /core 1

//打开第二个GUI：MAIN0-R5
TargetSystem.NewInstance main0
IC main0 System.cpu TDA4VM-CR5-MAIN0
IC main0 System.CONFIG.CORE 2. 1. 
IC main0 core.assign 1,2  //MAIN0域是一个R5 SMP子系统
IC main0 System.attach 
IC main0 Break
IC main0 List /core 0
IC main0 List /core 1

//打开第三个GUI：C66X
TargetSystem.NewInstance c66x
IC c66x System.cpu TDA4VM-C66X
IC c66x System.CONFIG.CORE 3. 1. 
IC c66x System.attach 
IC c66x Break
IC c66x List

//多个GUI之间的同步控制
Go Os_Init //控制MCU-R5运行到断点处
Wait !RUN()
IC All Go //控制所有GUI一起运行程序
wait 5.s
IC Others Break

ENDDO
</code></pre> 
<p>回顾下整个AMP多核调试环境，其中包含了若干个SMP多核子系统。使用一个CMM脚本进行调试，操作和维护都更方便。</p> 
<p><img src="https://images2.imgbox.com/8f/6a/bMvRhtvV_o.png" alt="图片"></p> 
<p>也可以执行如下命令后查看当前AMP多核调试环境中，各个GUI以及各个Core的状态：</p> 
<pre><code>TargetSystem All
</code></pre> 
<p><img src="https://images2.imgbox.com/e6/ab/xpjFBvZ2_o.png" alt="图片"></p> 
<p>关于TargetSystem命令的更多介绍可以参考：</p> 
<ul><li><em><strong>general_ref_t.pdf</strong>的 TargetSystem章节</em></li></ul> 
<blockquote> 
 <p>多核调试更多参考信息</p> 
</blockquote> 
<ul><li><strong>文档：</strong></li></ul> 
<p><em><strong>debugger_.pdf</strong></em> 中的多核调试章节</p> 
<p>例如 <em>debugger_armv8v9.pdf</em> 的<em>Quick Start for Multicore Debugging</em></p> 
<ul><li><strong>脚本：</strong></li></ul> 
<p><code>demo\&lt;arch&gt;\hardware\</code>文件夹下提供了一些常见的开发板可用的多核调试参考脚本</p> 
<p>例如<code>\demo\arm\hardware\s32g2\s32g-vnp-evb\s32g-vnp-evb-m7-a53-amp\s32g-vnp-evb_amp_sram.cmm</code></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa63f659224539101db3438e1fc03c39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">牛客网——序列中删除指定数字</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36411bdd46c057278edf8f437316ae3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">leetcode-数组系列算法总结-java版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>