<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解析Vue2.0和3.0的双向数据绑定原理和异同(带源码) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="解析Vue2.0和3.0的双向数据绑定原理和异同(带源码)" />
<meta property="og:description" content="解析Vue2.0和3.0的双向数据绑定原理和异同(带源码) Vue2.0和Vue3.0实现原理 Vue 2.0 Vue2.0实现MVVM(双向数据绑定)的原理是通过 Object.defineProperty 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
Vue官网也给出了解释:
Vue 3.0 实现响应式基于ES6:Proxy
Vue2.0和Vue3.0的差异如下: Vue2.0 基于Object.defineProperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式。Object.defineProperty 无法检测到对象属性的添加和删除 。由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。深度监听需要一次性递归，对性能影响比较大。 Vue3.0 基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除。不需要一次性遍历data的属性，可以显著提高性能。因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。 Vue2.x实现响应式 下面是基于Object.defineProperty ,一步步实现简单版Vue2.0。
由于Object.defineProperty 无法监听数组，所以数组类型实现响应式，需要处理。 判断如果是数组类型，就重写数组的原型方法(‘push’,‘pop’,‘shift’,unshift) // 重新定义数组原型，Object.defineProperty不具备监听数组的方法 const oldArrayProperty = Array.prototype; const arrProto = Object.create(oldArrayProperty); [&#34;push&#34;,&#34;pop&#34;,&#34;shift&#34;,&#34;unshift&#34;,&#34;splice&#34;].forEach( methodName =&gt; (arrProto[methodName] = function() { updateView(); oldArrayProperty[methodName].call(this, ...arguments); }) ) 将传入的data属性进行深度监听，判断是对象还是数组。 function observer(target){ if(typeof target !== &#39;object&#39; || target === null){ return target } // 如果是数组类型,重写数组原型的方法(&#34;push&#34;,&#34;pop&#34;,&#34;shift&#34;,&#34;unshift&#34;,&#34;splice&#34;) if(Array.isArray(target)){ target.__proto__ == arrProto; } // 如果是对象，遍历对象所有的属性，并使用Object." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6795bb264342d2467089a00da1f94ccb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-05T17:05:59+08:00" />
<meta property="article:modified_time" content="2020-08-05T17:05:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解析Vue2.0和3.0的双向数据绑定原理和异同(带源码)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Vue2030_0"></a>解析Vue2.0和3.0的双向数据绑定原理和异同(带源码)</h2> 
<h3><a id="Vue20Vue30_1"></a>Vue2.0和Vue3.0实现原理</h3> 
<h4><a id="Vue_20_2"></a>Vue 2.0</h4> 
<p>Vue2.0实现MVVM(双向数据绑定)的原理是通过 Object.defineProperty 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p> 
<p>Vue官网也给出了解释:<br> <img src="https://images2.imgbox.com/f6/24/OgpARNZ2_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="Vue_30_8"></a>Vue 3.0</h4> 
<p>实现响应式基于ES6:<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="nofollow">Proxy</a></p> 
<h3><a id="Vue20Vue30_10"></a>Vue2.0和Vue3.0的差异如下:</h3> 
<h4><a id="Vue20_11"></a>Vue2.0</h4> 
<ul><li>基于Object.defineProperty，不具备监听数组的能力，需要重新定义数组的原型来达到响应式。</li><li>Object.defineProperty 无法检测到对象属性的添加和删除 。</li><li>由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。</li><li>深度监听需要一次性递归，对性能影响比较大。</li></ul> 
<h4><a id="Vue30_17"></a>Vue3.0</h4> 
<ul><li>基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除。</li><li>不需要一次性遍历data的属性，可以显著提高性能。</li><li>因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。</li></ul> 
<h3><a id="Vue2x_21"></a>Vue2.x实现响应式</h3> 
<p>下面是基于Object.defineProperty ,一步步实现简单版Vue2.0。</p> 
<ol><li>由于Object.defineProperty 无法监听数组，所以数组类型实现响应式，需要处理。 判断如果是数组类型，就重写数组的原型方法(‘push’,‘pop’,‘shift’,unshift)</li></ol> 
<pre><code> // 重新定义数组原型，Object.defineProperty不具备监听数组的方法
 const oldArrayProperty = Array.prototype;
     const arrProto = Object.create(oldArrayProperty);
     ["push","pop","shift","unshift","splice"].forEach(
         methodName =&gt; 
         (arrProto[methodName] = function() {
             updateView();
             oldArrayProperty[methodName].call(this, ...arguments);
         })
     )
</code></pre> 
<ol start="2"><li>将传入的data属性进行深度监听，判断是对象还是数组。</li></ol> 
<pre><code> function observer(target){
     if(typeof target !== 'object' || target === null){
         return target
     }
 
     // 如果是数组类型,重写数组原型的方法("push","pop","shift","unshift","splice")
     if(Array.isArray(target)){
         target.__proto__ == arrProto;
     }
 
     // 如果是对象，遍历对象所有的属性，并使用Object.defineProperty把这些属性全部转为getter/setter
     for(let key in target){
         defineReactive(target,key,target[key])
     }
 }
</code></pre> 
<ol start="3"><li>核心API Object.defineProperty，将传入属性转为getter/setter</li></ol> 
<pre><code>function defineReactive(target, key, value){
    // 如果对象有更多的层级，再次调用observer监听方法，实现深层次的监听。
    observer(value);

    Object.defineProperty(target, key, {
        get(){
            return value;
        },
        set(newValue){
            // 设置值的时候也需要深度监听
            observer(value);

            if(newValue !== value){
                value = newValue;

                // 数据驱动视图，如果数据改变，就调用视图更新的方法。对应到Vue中是执行VDOM
                updateView();
            }
        }
    })
}
</code></pre> 
<ol start="4"><li>数据更新会触发视图更新，这是MVVM的绑定原理，这就会涉及到Vue的template编译为render函数，在执行Virtual Dom， Diff算法， Vnode等这些东西了。</li></ol> 
<pre><code> function updateView(){
     console.log('视图更新')
 }
</code></pre> 
<ol start="5"><li>使用</li></ol> 
<pre><code>const data = {
  name: "zhangsan",
  age: 20,
  info: {
    address: "北京" // 需要深度监听
  },
  nums: [10, 20, 30]
};

observer(data);
</code></pre> 
<h3><a id="Vue30_102"></a>Vue3.0实现响应式</h3> 
<p>Vue3.0基于Proxy来做数据大劫持代理，可以原生支持到数组的响应式，不需要重写数组的原型，还可以直接支持新增和删除属性， 比Vue2.x的Object.defineProperty更加的清晰明了。</p> 
<ol><li>核心代码(非常少)</li></ol> 
<pre><code>const proxyData = new Proxy(data, {
   get(target,key,receive){ 
     // 只处理本身(非原型)的属性
     const ownKeys = Reflect.ownKeys(target)
     if(ownKeys.includes(key)){
       console.log('get',key) // 监听
     }
     const result = Reflect.get(target,key,receive)
     return result
   },
   set(target, key, val, reveive){
     // 重复的数据，不处理
     const oldVal = target[key]
     if(val == oldVal){
       return true
     }
     const result = Reflect.set(target, key, val,reveive)
     return result
   },
   // 删除属性
   deleteProperty(target, key){
     const result = Reflect.deleteProperty(target,key)
     return result
   }
 })
</code></pre> 
<ol start="2"><li>使用</li></ol> 
<pre><code> const data = {
   name: "zhangsan",
   age: 20,
   info: {
     address: "北京" // 需要深度监听
   },
   nums: [10, 20, 30]
 };
</code></pre> 
<p>直接这样就可以了，也不需要声明，Proxy直接会代理监听data的内容，非常的简单方便，唯一的不足就是部分浏览器无法兼容Proxy，也不能hack，所以目前只能兼容到IE11。</p> 
<h3><a id="_147"></a>全部源码</h3> 
<p>可直接将代码复制到chrome浏览器的控制台，直接调试打印。</p> 
<h4><a id="Vue20_149"></a>Vue2.0</h4> 
<pre><code> function defineReactive(target, key, value) {
   //深度监听
   observer(value);
 
   Object.defineProperty(target, key, {
     get() {
       return value;
     },
     set(newValue) {
       //深度监听
       observer(value);
       if (newValue !== value) {
         value = newValue;
 
         updateView();
       }
     }
   });
 }
 
 function observer(target) {
   if (typeof target !== "object" || target === null) {
     return target;
   }
 
   if (Array.isArray(target)) {
     target.__proto__ = arrProto;
   }
 
   for (let key in target) {
     defineReactive(target, key, target[key]);
   }
 }
 
 // 重新定义数组原型
 const oldAddrayProperty = Array.prototype;
 const arrProto = Object.create(oldAddrayProperty);
 ["push", "pop", "shift", "unshift", "spluce"].forEach(
   methodName =&gt;
     (arrProto[methodName] = function() {
       updateView();
       oldAddrayProperty[methodName].call(this, ...arguments);
     })
 );
 
 // 视图更新
  function updateView() {
   console.log("视图更新");
 }
 
 // 声明要响应式的对象
 const data = {
   name: "zhangsan",
   age: 20,
   info: {
     address: "北京" // 需要深度监听
   },
   nums: [10, 20, 30]
 };
 
 // 执行响应式
 observer(data);
</code></pre> 
<h4><a id="Vue30_216"></a>Vue3.0</h4> 
<pre><code>const proxyData = new Proxy(data, {
   get(target,key,receive){ 
     // 只处理本身(非原型)的属性
     const ownKeys = Reflect.ownKeys(target)
     if(ownKeys.includes(key)){
       console.log('get',key) // 监听
     }
     const result = Reflect.get(target,key,receive)
     return result
   },
   set(target, key, val, reveive){
     // 重复的数据，不处理
     const oldVal = target[key]
     if(val == oldVal){
       return true
     }
     const result = Reflect.set(target, key, val,reveive)
     console.log('set', key, val)
     return result
   },
   deleteProperty(target, key){
     const result = Reflect.deleteProperty(target,key)
     console.log('delete property', key)
     console.log('result',result)
     return result
   }
 })

  // 声明要响应式的对象,Proxy会自动代理
 const data = {
   name: "zhangsan",
   age: 20,
   info: {
     address: "北京" // 需要深度监听
   },
   nums: [10, 20, 30]
 };
</code></pre> 
<p>转载自：<a href="https://zhuanlan.zhihu.com/p/125715026" rel="nofollow">解析Vue2.0和3.0的响应式原理和异同(带源码)</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e55850f3216b507994c41726ad44cb09/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用Python爬虫&#43;数据分析对新冠疫情数据实时监控！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fdfc4d649319379aa3ad1500d620066f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js截取逗号（符号可变）前/后的字符串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>