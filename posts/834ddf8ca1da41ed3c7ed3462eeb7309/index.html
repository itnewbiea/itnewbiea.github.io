<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>稀疏矩阵的基本操作 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="稀疏矩阵的基本操作" />
<meta property="og:description" content="1）掌握稀疏矩阵基础知识，实现初始化稀疏矩阵、销毁稀疏矩阵、输出稀疏矩阵、复制稀疏矩阵、稀疏矩阵的相加、相减与相乘、将指定值插入到稀疏矩阵的指定位置、返回指定稀疏矩阵的指定行列的值等操作；
2）掌握稀疏矩阵简单转置方法和快速转置方法的实现。
#include &lt;iostream&gt; #define MAXSIZE 12500//假设非零元素的最大值为12500 typedef int ElemType; using namespace std; typedef struct { int i,j;//该元素的行下标和列下标 ElemType e; }Triple,*pTriple; typedef struct{ Triple data[MAXSIZE&#43;1];//非零元三元组表，data[0]未用 int mu,nu,tu;//矩阵的行数 列数 和 非零元素个数 }TSMatrix; bool initMatrix(TSMatrix &amp;M);//初始化稀疏矩阵 bool DestroySMatrix(TSMatrix &amp;M);//销毁稀疏矩阵 bool PrintSMatrix(TSMatrix &amp;M);//输出稀疏矩阵 bool CopySMatrix(TSMatrix &amp;M,TSMatrix &amp;T);//由稀疏矩阵M复制得到T bool AddSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的和Q=M&#43;N bool SubMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的差Q=M-N bool MultSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M的列数与N的行数对应相等时，求稀疏矩阵乘积Q=M X N; bool TransposeSMatrix1(TSMatrix &amp;M,TSMatrix &amp;T);//求稀疏矩阵M的转置矩阵T bool TransposeSMatrix2(TSMatrix &amp;M,TSMatrix &amp;T); //求稀疏矩阵M的快速转置矩阵T bool setItem(TSMatrix &amp;M,int i,int j,ElemType e);//将指定值插入到稀疏矩阵的指定位置 void getItem(TSMatrix &amp;M,int i,int j,int &amp;x);//返回指定稀疏矩阵的指定行列的值 int main(){ TSMatrix A; if (initMatrix(A)){ cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/834ddf8ca1da41ed3c7ed3462eeb7309/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-02T22:10:07+08:00" />
<meta property="article:modified_time" content="2022-10-02T22:10:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">稀疏矩阵的基本操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#393939;"><span style="color:#393939;">1）</span><span style="color:#393939;">掌握稀疏矩阵基础知识，实现初始化稀疏矩阵、销毁稀疏矩阵、输出稀疏矩阵、复制稀疏矩阵、稀疏矩阵的相加、相减与相乘、将指定值插入到稀疏矩阵的指定位置、返回指定稀疏矩阵的指定行列的值等操作；</span></span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#393939;"><span style="color:#393939;">2）掌握</span><span style="color:#393939;">稀疏矩阵简单转置方法和快速转置方法的实现</span><span style="color:#393939;">。</span></span></p> 
<pre><code class="hljs">#include &lt;iostream&gt;

#define MAXSIZE 12500//假设非零元素的最大值为12500

typedef int ElemType;

using namespace std;

typedef struct {

int i,j;//该元素的行下标和列下标

ElemType e;

}Triple,*pTriple;

typedef struct{

Triple data[MAXSIZE+1];//非零元三元组表，data[0]未用

int mu,nu,tu;//矩阵的行数 列数 和 非零元素个数

}TSMatrix;

bool initMatrix(TSMatrix &amp;M);//初始化稀疏矩阵

bool DestroySMatrix(TSMatrix &amp;M);//销毁稀疏矩阵

bool PrintSMatrix(TSMatrix &amp;M);//输出稀疏矩阵

bool CopySMatrix(TSMatrix &amp;M,TSMatrix &amp;T);//由稀疏矩阵M复制得到T

bool AddSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的和Q=M+N

bool SubMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的差Q=M-N

bool MultSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q);//当稀疏矩阵M的列数与N的行数对应相等时，求稀疏矩阵乘积Q=M X N;

bool TransposeSMatrix1(TSMatrix &amp;M,TSMatrix &amp;T);//求稀疏矩阵M的转置矩阵T

bool TransposeSMatrix2(TSMatrix &amp;M,TSMatrix &amp;T); //求稀疏矩阵M的快速转置矩阵T

bool setItem(TSMatrix &amp;M,int i,int j,ElemType e);//将指定值插入到稀疏矩阵的指定位置

void getItem(TSMatrix &amp;M,int i,int j,int &amp;x);//返回指定稀疏矩阵的指定行列的值

int main(){

TSMatrix A;

if (initMatrix(A)){

cout &lt;&lt; "初始化稀疏矩阵A成功" &lt;&lt; endl;

}

PrintSMatrix(A);

TSMatrix B;

cout &lt;&lt; "A矩阵复制得B矩阵" &lt;&lt; endl;

CopySMatrix(A,B);

PrintSMatrix(B);

TSMatrix C;

AddSMatrix(A,B,C);

cout &lt;&lt; "当A矩阵与B矩阵相加时，得到C矩阵" &lt;&lt; endl;

PrintSMatrix(C);

TSMatrix D;

SubMatrix(C,A,D);

cout &lt;&lt; "当C矩阵与A矩阵相减时，得到D矩阵" &lt;&lt; endl;

PrintSMatrix(D);

TSMatrix E;

cout &lt;&lt; "初始化E矩阵,要求行数为3，可实现与A矩阵的相乘" &lt;&lt; endl;

initMatrix(E);

TSMatrix F;

MultSMatrix(A,E,F);

cout &lt;&lt; "当A与E矩阵相乘时,得到F矩阵" &lt;&lt; endl;

PrintSMatrix(F);

TSMatrix G;

cout &lt;&lt; "当A矩阵转置时，得到G矩阵" &lt;&lt; endl;

cout &lt;&lt; "用简单转置方法转置" &lt;&lt; endl;

TransposeSMatrix1(A,G);

PrintSMatrix(G);

TSMatrix H;

cout &lt;&lt; "用快速转置方法转置" &lt;&lt; endl;

TransposeSMatrix2(A,H);

PrintSMatrix(H);

DestroySMatrix(A);

DestroySMatrix(B);

DestroySMatrix(C);

DestroySMatrix(D);

DestroySMatrix(E);

DestroySMatrix(F);

DestroySMatrix(G);

DestroySMatrix(H);

return 0;

}

//初始化稀疏矩阵

bool initMatrix(TSMatrix &amp;M){

int x,y,z;

cout &lt;&lt; "请依次输入稀疏矩阵的行数 列数 非零元素个数" &lt;&lt; endl;

cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;

M.mu = x;

M.nu = y;

M.tu = z;



for(int k=1;k&lt;=M.tu;k++){

cout&lt;&lt;"请输入第"&lt;&lt;k&lt;&lt;"个元素所在行数、列数、值"&lt;&lt;endl;

cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;

M.data[k].i = x;

M.data[k].j = y;

M.data[k].e = z;

}

return true;

}

//销毁稀疏矩阵

bool DestroySMatrix(TSMatrix &amp;M){

for(int k=1;k&lt;=M.tu;k++){

M.data[k].i = 0;

M.data[k].j = 0;

M.data[k].e = 0;

}

M.mu = 0;

M.nu = 0;

M.tu = 0;

return true;

}

//输出稀疏矩阵

bool PrintSMatrix(TSMatrix &amp;M){

cout &lt;&lt; "此时该三元组为" &lt;&lt; endl;

for(int k=1;k&lt;=M.tu;k++){

cout &lt;&lt; M.data[k].i &lt;&lt; "  " &lt;&lt;  M.data[k].j &lt;&lt; "  " &lt;&lt; M.data[k].e;

cout &lt;&lt; endl;

}

return true;

}

//由稀疏矩阵M复制得到T

bool CopySMatrix(TSMatrix &amp;M,TSMatrix &amp;T){

T.mu = M.mu;

T.nu = M.nu;

T.tu = M.tu;



for(int k=1;k&lt;=M.tu;k++){

T.data[k].i = M.data[k].i ;

T.data[k].j = M.data[k].j;

T.data[k].e = M.data[k].e;

}

return true;

}

//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的和Q=M+N

bool AddSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q){

if(M.mu!=N.mu||M.nu!=N.nu){

cout &lt;&lt; "输入错误" &lt;&lt; endl;

return false;

}

    

Q.mu = M.mu;

Q.nu = M.nu;

Q.tu =0;

int item,x,y;

for(int i=1;i&lt;=M.mu;i++){

for(int j=1;j&lt;=M.nu;j++){

            getItem(M,i,j,x);

getItem(N,i,j,y);  

item = x + y;

//如果计算出来的值不为零， 则插入到稀疏矩阵中

if(item != 0){

setItem(Q,i,j,item);

}

}

}

return true;

}

//当稀疏矩阵M与N的行数和列数对应相等时，求稀疏矩阵的差Q=M-N

bool SubMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q){

if(M.mu!=N.mu||M.nu!=N.nu){

cout &lt;&lt; "输入错误" &lt;&lt; endl;

return false;

}

    

Q.mu = M.mu;

Q.nu = M.nu;

Q.tu = 0;

int item,x,y;

for(int i=1;i&lt;=M.mu;i++){

for(int j=1;j&lt;=M.nu;j++){

getItem(M,i,j,x);

getItem(N,i,j,y);

item = x - y;

//如果计算出来的值不为零， 则插入到稀疏矩阵中

if(item != 0){

setItem(Q,i,j,item);

}

}

}

return true;

}

//稀疏矩阵M的列数与N的行数对应相等时，直接用三元组方式求矩阵乘积

bool MultSMatrix(TSMatrix &amp;M,TSMatrix &amp;N,TSMatrix &amp;Q){

if(M.nu != N.mu)

    return false;

Q.mu = M.mu;

Q.nu = N.nu;

Q.tu = 0;//Q初始化

int sum,x,y;

for(int i=1;i&lt;=Q.mu;i++){

for(int j=1;j&lt;=Q.nu;j++){

sum = 0;

for(int k=1;k&lt;=N.mu;k++){

getItem(M,i,k,x);

    getItem(N,k,j,y);

sum += x * y;

}

setItem(Q,i,j,sum);

}

}

return true;

}

//求稀疏矩阵M的简单转置矩阵T

bool TransposeSMatrix1(TSMatrix &amp;M,TSMatrix &amp;T){

T.mu = M.nu;

T.nu = M.mu;

T.tu = M.tu;

int num[MAXSIZE+1];

if(T.tu){

int q = 1;

for(int col=1;col&lt;=M.nu;++col){

for(int p=1;p&lt;=M.tu;++p){

if(M.data[p].j == col){

T.data[q].i = M.data[p].j;

T.data[q].j = M.data[p].i;

T.data[q].e = M.data[p].e;

++q;

}

}

}

}

return true;

}

//求稀疏矩阵M的快速转置矩阵T

bool TransposeSMatrix2(TSMatrix &amp;M,TSMatrix &amp;T){

T.mu = M.nu;

T.nu = M.mu;

T.tu = M.tu;

int num[MAXSIZE+1];

if(T.tu){

        for(int col=1;col&lt;=M.nu;++col){

         num[col] = 0;//num[col]表示矩阵中第col列中非零元的个数

}

for(int t=1;t&lt;=M.tu;++t)

++num[M.data[t].j];//求M中每一列含非零元个数

int cpot[MAXSIZE+1];

cpot[1] = 1;

//求第col列中第一个非零元在b.data中的序号

for(int col=2;col&lt;=M.nu;++col){

cpot[col] = cpot[col-1]+num[col-1];//cpot[col]表示该列第一个非零元素在三元组表中存放的正确位置

}

int col;

int q;

for(int p=1;p&lt;=M.tu;++p){

col = M.data[p].j;

q = cpot[col];

T.data[q].i = M.data[p].j;

T.data[q].j = M.data[p].i;

T.data[q].e = M.data[p].e;

++cpot[col];

}     

}

return true;

}

//将指定值插入到稀疏矩阵的指定位置

bool setItem(TSMatrix &amp;M,int i,int j,ElemType e){

if(M.mu&lt;i||M.nu&lt;j){

cout &lt;&lt; "输出错误";

return false;

}

if(M.tu == MAXSIZE){

cout &lt;&lt; "三元组已满，不能继续存储元素" &lt;&lt; endl;

return false;

}

if(e == 0){//当存入的元素值为0时，则直接返回

return true;

}

int index = 0;

while(index &lt;= M.tu){

if(i &gt; M.data[index].i){

index++;

}

else if((i ==  M.data[index].i) &amp;&amp; (j &gt;  M.data[index].j)){

index++;

}

else{

break;

}

}

if((i ==  M.data[index].i)&amp;&amp;(j ==  M.data[index].j)){//当前行列已经存在时，则直接替换该行列的元素

 M.data[index].e = e;

}else{//当前行列不存在时

    M.tu++;

for(int m = M.tu;m&gt;index;m--){

 M.data[m].i = M.data[m-1].i;

 M.data[m].j = M.data[m-1].j;

 M.data[m].e = M.data[m-1].e;

}

M.data[index].i = i;

M.data[index].j = j;

M.data[index].e = e;

}

}

//返回指定稀疏矩阵的指定行列的值

void getItem(TSMatrix &amp;M,int i,int j,int &amp;m){

int k = 1;

if(i&gt;M.mu||j&gt;M.nu){

cout &lt;&lt; "输入错误";

exit(-1);

}

while((k&lt;M.tu)&amp;&amp;(i&gt;M.data[k].i)){

k++;//查找i行的非零元素

}

while((k&lt;=M.tu)&amp;&amp;(i==M.data[k].i)&amp;&amp;(j&gt;M.data[k].j)){

k++;

}//此时



if((M.data[k].i==i)&amp;&amp;(M.data[k].j==j)){

m =  M.data[k].e;

}

else{

m = 0;

}

}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d1c0dd54166f838f39de64faf4dffaf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于优化ＬＳＴＭ 模型的股票预测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb1c1d0801505a58ff6be6ae75a5e7d2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">串的基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>