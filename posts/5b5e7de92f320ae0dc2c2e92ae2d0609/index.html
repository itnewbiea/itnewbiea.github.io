<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>图像二值化阈值调整——OTSU算法（大津法/最大类间方差法） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="图像二值化阈值调整——OTSU算法（大津法/最大类间方差法）" />
<meta property="og:description" content="大津算法（OTSU算法）是一种常用的图像二值化方法，用于将灰度图像转化为二值图像。该算法由日本学者大津展之于1979年提出，因此得名。
大津算法的核心思想是通过寻找一个阈值，将图像的像素分为两个类别：前景和背景。具体步骤如下：
统计图像的灰度直方图，得到每个灰度级的像素数目。遍历所有可能的阈值（0到255），计算根据该阈值将图像分为前景和背景的类内方差。根据类内方差的最小值确定最佳阈值。 在大津算法中，类内方差是衡量前景和背景之间差异的度量。通过选择使类内方差最小的阈值，可以实现最佳的图像分割效果。
大津算法的优点是简单易懂，计算效率高。它适用于灰度图像的二值化处理，特别是对于具有双峰直方图的图像效果更好。然而，该算法对于具有非双峰直方图的图像可能产生较差的分割结果。因此，在应用大津算法之前，需要对图像的直方图进行分析，确保适用性。
大津算法在图像处理中被广泛应用，例如在文档图像处理、目标检测、图像分割等领域。
下面推导类间方差函数：
设阈值为灰度k（）。这个阈值把图像像素分割成两类，C1类像素小于等于k，C2类像素大于k。设这两类像素各自的均值为，图像全局均值为。同时像素被分为C1和C2类的概率分别为。则有：
根据方差的概念，类间方差表达式为：
展开：
合并2，5及3，6项可得：
我们再把代回得到：
再注意到，所以，，从而得到：
对于给定的阈值k，我们可以统计出灰度级的分布列：
灰度值01...255... 显然根据分布列性质有（请注意这里的是分布列中的，不是上面的定义）
那么有：
将k从遍历，找出使得最大的k值，这个k值就是阈值。
对于分割，这个分割就是二值化，OpenCV给了以下几种方式（同threshold）：
cv2帮助文档：
Miscellaneous Image Transformations — OpenCV 3.0.0-dev documentationhttps://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#threshold代码实现：
首先是原理部分的实现，这部分我们使用numpy：
import cv2 import numpy as np def OTSU(img_gray, GrayScale): assert img_gray.ndim == 2, &#34;must input a gary_img&#34; # shape有几个数字, ndim就是多少 img_gray = np.array(img_gray).ravel().astype(np.uint8) u1 = 0.0 # 背景像素的平均灰度值 u2 = 0.0 # 前景像素的平均灰度值 th = 0.0 # 总的像素数目 PixSum = img_gray.size # 各个灰度值的像素数目 PixCount = np." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5b5e7de92f320ae0dc2c2e92ae2d0609/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T22:37:17+08:00" />
<meta property="article:modified_time" content="2023-11-01T22:37:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">图像二值化阈值调整——OTSU算法（大津法/最大类间方差法）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>大津算法（OTSU算法）是一种常用的图像二值化方法，用于将灰度图像转化为二值图像。该算法由日本学者大津展之于1979年提出，因此得名。</p> 
<p>大津算法的核心思想是通过寻找一个阈值，将图像的像素分为两个类别：前景和背景。具体步骤如下：</p> 
<ol><li>统计图像的灰度直方图，得到每个灰度级的像素数目。</li><li>遍历所有可能的阈值（0到255），计算根据该阈值将图像分为前景和背景的类内方差。</li><li>根据类内方差的最小值确定最佳阈值。</li></ol> 
<p>在大津算法中，类内方差是衡量前景和背景之间差异的度量。通过选择使类内方差最小的阈值，可以实现最佳的图像分割效果。</p> 
<p>大津算法的优点是简单易懂，计算效率高。它适用于灰度图像的二值化处理，特别是对于具有双峰直方图的图像效果更好。然而，该算法对于具有非双峰直方图的图像可能产生较差的分割结果。因此，在应用大津算法之前，需要对图像的直方图进行分析，确保适用性。</p> 
<p>大津算法在图像处理中被广泛应用，例如在文档图像处理、目标检测、图像分割等领域。</p> 
<p>下面推导类间方差函数：</p> 
<p>设阈值为灰度k（<img alt="k\in \left [ 0,L-1 \right ],L=256" class="mathcode" src="https://images2.imgbox.com/87/9e/ob2Q0GRy_o.png">）。这个阈值把图像像素分割成两类，C1类像素小于等于k，C2类像素大于k。设这两类像素各自的均值为<img alt="m_1,m_2" class="mathcode" src="https://images2.imgbox.com/87/2a/6GSdav6V_o.png">，图像全局均值为<img alt="m_G" class="mathcode" src="https://images2.imgbox.com/39/c6/CGyY4gPN_o.png">。同时像素被分为C1和C2类的概率分别为<img alt="p_1,p_2" class="mathcode" src="https://images2.imgbox.com/41/18/Ra6WK4iO_o.png">。则有：</p> 
<p style="text-align:center;"><img alt="p_1m_1+p_2m_2=m_G" class="mathcode" src="https://images2.imgbox.com/7c/dc/VR5YT2vo_o.png"></p> 
<p style="text-align:center;"><img alt="p_1+p_2=1" class="mathcode" src="https://images2.imgbox.com/78/92/ztQt16Od_o.png"></p> 
<p>根据方差的概念，类间方差表达式为：</p> 
<p style="text-align:center;"><img alt="\sigma ^2=p_1\left ( m_1-m_G \right )^2+p_2\left ( m_2-m_G \right )^2" class="mathcode" src="https://images2.imgbox.com/53/6c/EmSBIhct_o.png"></p> 
<p>展开：</p> 
<p style="text-align:center;"><img alt="\sigma ^2=p_1m_1^2+p_1m_G^2-2p_1m_1m_G+p_2m_2^2+p_2m_G^2-2p_2m_2m_G" class="mathcode" src="https://images2.imgbox.com/0e/eb/uCXiioRl_o.png"></p> 
<p>合并2，5及3，6项可得：</p> 
<p style="text-align:center;"><img alt="\sigma ^2=p_1m_1^2+p_2m_2^2+m_G^2-2m_G^2=p_1m_1^2+p_2m_2^2-m_G^2" class="mathcode" src="https://images2.imgbox.com/28/3a/oqDsEwAe_o.png"></p> 
<p>我们再把<img alt="m_G=p_1m_1+p_2m_2" class="mathcode" src="https://images2.imgbox.com/dd/24/iWyw0EFR_o.png">代回得到：</p> 
<p style="text-align:center;"><img alt="\sigma ^2=(p_1-p_1^2)m_1^2+(p_2-p_2^2)m_2^2-2p_1p_2m_1m_2" class="mathcode" src="https://images2.imgbox.com/0e/d8/uIlCu3YZ_o.png"></p> 
<p>再注意到<img alt="p_1+p_2=1" class="mathcode" src="https://images2.imgbox.com/87/2e/vfaBJIx5_o.png">，所以<img alt="p_1-p_1^2=p_1(1-p_1)=p_1p_2" class="mathcode" src="https://images2.imgbox.com/6e/ca/61qN6Nfp_o.png">，<img alt="p_2-p_2^2=p_2(1-p_2)=p_1p_2" class="mathcode" src="https://images2.imgbox.com/a9/71/antMM6cq_o.png">，从而得到：</p> 
<p style="text-align:center;"><img alt="\sigma ^2=p_1p_2(m_1-m_2)^2" class="mathcode" src="https://images2.imgbox.com/0d/3f/OLWd7PMW_o.png"></p> 
<p>对于给定的阈值k，我们可以统计出灰度级的分布列：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>灰度值</td><td>0</td><td>1</td><td>...</td><td>255</td></tr><tr><td><img alt="p_i" class="mathcode" src="https://images2.imgbox.com/01/6c/hCH4P6UX_o.png"></td><td><img alt="p_0" class="mathcode" src="https://images2.imgbox.com/8a/2e/sFcbvQLz_o.png"></td><td><img alt="p_1" class="mathcode" src="https://images2.imgbox.com/df/e8/ViIyoWj1_o.png"></td><td>...</td><td><img alt="p_{255}" class="mathcode" src="https://images2.imgbox.com/29/84/l9B12wiS_o.png"></td></tr></tbody></table> 
<p>显然根据分布列性质有<img alt="\sum_{i=0}^{L-1}p_i=1" class="mathcode" src="https://images2.imgbox.com/6c/b9/YWEntwVa_o.png">（请注意这里的<img alt="p_1,p_2" class="mathcode" src="https://images2.imgbox.com/9d/12/6tH3LFFY_o.png">是分布列中的，不是上面的定义）</p> 
<p>那么有：</p> 
<p style="text-align:center;"><img alt="p_1=\sum_{i=0}^{k-1}p_i,p_2=\sum_{i=k}^{L-1}p_i,m_1=\sum_{i=0}^{k-1}ip_i,m_2=\sum_{i=k}^{L-1}ip_i" class="mathcode" src="https://images2.imgbox.com/5d/66/ksyuWe9n_o.png"></p> 
<p>将k从<img alt="\left [ 0,L-1 \right ]" class="mathcode" src="https://images2.imgbox.com/0b/a9/HcDfoNiE_o.png">遍历，找出使得<img alt="\sigma ^2" class="mathcode" src="https://images2.imgbox.com/3e/71/H8XspDyn_o.png">最大的k值，这个k值就是阈值。</p> 
<p>对于分割，这个分割就是二值化，OpenCV给了以下几种方式（同threshold）：</p> 
<p class="img-center"><img alt="" height="575" src="https://images2.imgbox.com/fd/14/9bqoZsTr_o.png" width="762"></p> 
<p>cv2帮助文档：</p> 
<p><a class="has-card" href="https://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#threshold" rel="nofollow" title="Miscellaneous Image Transformations — OpenCV 3.0.0-dev documentation"><span class="link-card-box"><span class="link-title">Miscellaneous Image Transformations — OpenCV 3.0.0-dev documentation</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/a6/c1/jZWPmaUi_o.png" alt="icon-default.png?t=N7T8">https://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#threshold</span></span></a>代码实现：</p> 
<p>首先是原理部分的实现，这部分我们使用numpy：</p> 
<pre><code class="language-python">import cv2
import numpy as np

def OTSU(img_gray, GrayScale):
    assert img_gray.ndim == 2, "must input a gary_img"  # shape有几个数字, ndim就是多少
    img_gray = np.array(img_gray).ravel().astype(np.uint8)
    u1 = 0.0  # 背景像素的平均灰度值
    u2 = 0.0  # 前景像素的平均灰度值
    th = 0.0

    # 总的像素数目
    PixSum = img_gray.size
    # 各个灰度值的像素数目
    PixCount = np.zeros(GrayScale)
    # 各灰度值所占总像素数的比例
    PixRate = np.zeros(GrayScale)
    # 统计各个灰度值的像素个数
    for i in range(PixSum):
        # 默认灰度图像的像素值范围为GrayScale
        Pixvalue = img_gray[i]
        PixCount[Pixvalue] = PixCount[Pixvalue] + 1

    # 确定各个灰度值对应的像素点的个数在所有的像素点中的比例。
    for j in range(GrayScale):
        PixRate[j] = PixCount[j] * 1.0 / PixSum
    Max_var = 0
    # 确定最大类间方差对应的阈值
    for i in range(1, GrayScale):  # 从1开始是为了避免w1为0.
        u1_tem = 0.0
        u2_tem = 0.0
        # 背景像素的比列
        w1 = np.sum(PixRate[:i])
        # 前景像素的比例
        w2 = 1.0 - w1
        if w1 == 0 or w2 == 0:
            pass
        else:  # 背景像素的平均灰度值
            for m in range(i):
                u1_tem = u1_tem + PixRate[m] * m
            u1 = u1_tem * 1.0 / w1
            # 前景像素的平均灰度值
            for n in range(i, GrayScale):
                u2_tem = u2_tem + PixRate[n] * n
            u2 = u2_tem / w2
            # print(u1)
            # 类间方差公式：G=w1*w2*(u1-u2)**2
            tem_var = w1 * w2 * np.power((u1 - u2), 2)
            # print(tem_var)
            # 判断当前类间方差是否为最大值。
            if Max_var &lt; tem_var:
                Max_var = tem_var  # 深拷贝，Max_var与tem_var占用不同的内存空间。
                th = i
    return th

def main():
    img = cv2.imread('6.jpg', 0)
    # 将图片转为灰度图
    th = OTSU(img, 256)
    print("使用numpy的方法：" + str(th))  # 结果为 136

main()</code></pre> 
<p>然后是基于cv2的OTSU实现，cv2可直接指定使用：</p> 
<pre><code class="language-python">import cv2
import matplotlib.pylab as plt

def main2():
    img = cv2.imread('6.jpg', 0)
    ret, thresh1 = cv2.threshold(img, 0, 255, cv2.THRESH_OTSU)
    print(ret)  # 结果是135.0

    titles = ['Original Image', 'After Binarization']
    images = [img, thresh1]

    for i in range(2):
        plt.subplot(1, 2, i+1)
        plt.imshow(images[i], 'gray')
        plt.title(titles[i])
        plt.xticks([])
        plt.yticks([])

    plt.show()

main2()</code></pre> 
<p class="img-center"><img alt="" height="480" src="https://images2.imgbox.com/78/e2/Q4eAiY4o_o.png" width="640"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e4074f5c43c4eebd5e8c532edb32eb51/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ICLR 2022）ODConv：即插即用的动态卷积 （附代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d1c45574a7d404cd81da71361d518ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">优优嗨聚集团：医保新政来袭，乙类OTC、保健品或将退出医保舞台，影响几何？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>