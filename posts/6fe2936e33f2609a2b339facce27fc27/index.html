<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一次搞懂数据大屏适配方案 (vw vh、rem、scale) - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一次搞懂数据大屏适配方案 (vw vh、rem、scale)" />
<meta property="og:description" content="大厂技术 高级前端 Node进阶
点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群
前言
当接到可视化大屏需求时，你是否会有以下疑问👇如何做一款定制化的数据大屏？ 开发可视化数据大屏如何做自适应？ vm vh、rem、scale 到底哪种比较好？ 时间不够，有没有偷懒的方法？
最近在公司开发了一个可视化大屏，开发定制化大屏，大家可能都一个感受，开发大屏主要是两方面的工作：
大屏之关键-前期的自适应适配
根据 ui 稿绘制图表，调细节
而解决了适配问题后，后面就只是一个慢工出细活，耗时间的事情了。
适配方案分析 看了网上的各种方案，目前大家采用的大概有 3 种👇
方案实现方式优点缺点vm vh1.按照设计稿的尺寸，将px按比例计算转为vw和vh1.可以动态计算图表的宽高，字体等，灵活性较高 2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦scale1.通过 scale 属性，根据屏幕大小，对图表进行整体的等比缩放1.代码量少，适配简单 2.一次处理后不需要在各个图表中再去单独适配1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.当缩放比例过大时候，字体会有一点点模糊，就一点点 3.当缩放比例过大时候，事件热区会偏移。rem &#43; vm vh1.获得 rem 的基准值 2.动态的计算html根元素的font-size 3.图表中通过 vm vh 动态计算字体、间距、位移等1.布局的自适应代码量少，适配简单1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.图表需要单个做字体、间距、位移的适配 以上 3 种方案在实际应用中该怎么选择视具体情况而定，也有看到大家说自适应在地图的适配中会有一些兼容问题，我这边还没有实践过。
如果想简单，客户能同意留白，选用 scale 即可
如果需要兼容不同比例的大屏，并且想在不同比例中都有比较好的效果，图表占满屏幕，类似于移动端的响应式，可以采用 vm vh 的方案
至于 rem，个人觉得就是 scale 和 vm vh 的综合，最终的效果跟 scale 差不多" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6fe2936e33f2609a2b339facce27fc27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-16T11:56:49+08:00" />
<meta property="article:modified_time" content="2022-12-16T11:56:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一次搞懂数据大屏适配方案 (vw vh、rem、scale)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h2>大厂技术  高级前端  Node进阶<br></h2> 
 <p style="text-align:center;">点击上方 程序员成长指北，关注公众号<br></p> 
 <p style="text-align:center;">回复1，加入高级Node交流群</p> 
 <p>前言</p> 
 <p>当接到可视化大屏需求时，你是否会有以下疑问👇<strong>如何做一款定制化的数据大屏？ 开发可视化数据大屏如何做自适应？ vm vh、rem、scale 到底哪种比较好？ 时间不够，有没有偷懒的方法？</strong></p> 
 <p><img src="https://images2.imgbox.com/19/5b/syhyVFB5_o.jpg" alt="456d18e1d8aa6207ccc55adcd2959f2c.jpeg"> 最近在公司开发了一个可视化大屏，开发定制化大屏，大家可能都一个感受，开发大屏主要是两方面的工作：</p> 
 <ul><li><p><code>大屏之关键-前期的自适应适配</code></p></li><li><p><code>根据 ui 稿绘制图表，调细节</code></p></li></ul> 
 <p>而解决了适配问题后，后面就只是一个慢工出细活，耗时间的事情了。</p> 
 <h4>适配方案分析</h4> 
 <p>看了网上的各种方案，目前大家采用的大概有 3 种👇</p> 
 <table><thead><tr><th>方案</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>vm vh</strong></td><td>1.按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code></td><td>1.可以动态计算图表的宽高，字体等，灵活性较高 2.当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况</td><td>1.每个图表都需要单独做字体、间距、位移的适配，比较麻烦</td></tr><tr><td><strong>scale</strong></td><td>1.通过 <code>scale</code> 属性，根据屏幕大小，对图表进行整体的等比缩放</td><td>1.代码量少，适配简单 2.一次处理后不需要在各个图表中再去单独适配</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况  2.当缩放比例过大时候，字体会有一点点模糊，就一点点  3.当缩放比例过大时候，事件热区会偏移。</td></tr><tr><td><strong>rem + vm vh</strong></td><td>1.获得 rem 的基准值 2.动态的计算<code>html根元素的font-size</code> 3.图表中通过 vm vh 动态计算字体、间距、位移等</td><td>1.布局的自适应代码量少，适配简单</td><td>1.因为是根据 ui 稿等比缩放，当大屏跟 ui 稿的比例不一样时，会出现周边留白情况 2.图表需要单个做字体、间距、位移的适配</td></tr></tbody></table> 
 <p>以上 3 种方案在实际应用中该怎么选择视具体情况而定，也有看到大家说自适应在地图的适配中会有一些兼容问题，我这边还没有实践过。</p> 
 <ul><li><p>如果想简单，客户能同意留白，选用 <code>scale</code> 即可</p></li><li><p>如果需要兼容不同比例的大屏，并且想在不同比例中都有比较好的效果，图表占满屏幕，类似于移动端的响应式，可以采用 vm vh 的方案</p></li><li><p>至于 rem，个人觉得就是 scale 和 vm vh 的综合，最终的效果跟 <code>scale</code> 差不多</p></li></ul> 
 <p>接下来介绍下三种方案的具体实现，方案中的代码都以 vue2.0 和 vue-cli3 搭建的 vue 项目为例，因为是 demo，图表的一些细节就没有过多细致的调整了</p> 
 <h4>方案一：vw vh</h4> 
 <h5>上效果</h5> 
 <img src="https://images2.imgbox.com/60/0f/4Z7gr3AI_o.jpg" alt="e122e30a4116a1b02ce8ce489d705268.jpeg"> 
 <figcaption>
   ezgif.com-gif-maker (1).gif 
 </figcaption> 
 <p>当屏幕的尺寸比例刚好是 16:9 时</p> 
 <img src="https://images2.imgbox.com/0c/3b/i1UMdGIl_o.jpg" alt="d011b004ead43186100584d360263d57.jpeg"> 
 <figcaption>
   vwh02.jpg 
 </figcaption> 
 <p>当屏幕的尺寸比例大于 16:9 时</p> 
 <img src="https://images2.imgbox.com/09/ef/Wnl2gV9i_o.jpg" alt="1109d22244c3cee7f443d5172e6d7f1b.jpeg"> 
 <figcaption>
   vwh03.jpg 
 </figcaption> 
 <p>当屏幕的尺寸比例小于 16:9 时</p> 
 <img src="https://images2.imgbox.com/ed/47/3TaO4nEc_o.jpg" alt="f45d2ead30405b86cb8924369cd9fd4c.jpeg"> 
 <figcaption>
   vwh09.jpg 
 </figcaption> 
 <h5>实现思路</h5> 
 <p>按照设计稿的尺寸，将<code>px</code>按比例计算转为<code>vw</code>和<code>vh</code>，转换公式如下</p> 
 <pre class="has"><code class="language-go">假设设计稿尺寸为 1920*1080（做之前一定问清楚 ui 设计稿的尺寸）

即：
网页宽度=1920px
网页高度=1080px

我们都知道
网页宽度=100vw
网页宽度=100vh

所以，在 1920px*1080px 的屏幕分辨率下

1920px = 100vw

1080px = 100vh

这样一来，以一个宽 300px 和 200px 的 div 来说，其所占的宽高，以 vw 和 vh 为单位，计算方式如下:

vwDiv = (300px / 1920px ) * 100vw
vhDiv = (200px / 1080px ) * 100vh

所以，就在 1920*1080 的屏幕分辨率下，计算出了单个 div 的宽高

当屏幕放大或者缩小时，div 还是以 vw 和 vh 作为宽高的，就会自动适应不同分辨率的屏幕
复制代码</code></pre> 
 <h5>话不多说，上代码</h5> 
 <h6>css 方案 - sass</h6> 
 <p>util.scss</p> 
 <pre class="has"><code class="language-go">// 使用 scss 的 math 函数，https://sass-lang.com/documentation/breaking-changes/slash-div
@use "sass:math";

// 默认设计稿的宽度
$designWidth: 1920;
// 默认设计稿的高度
$designHeight: 1080;

// px 转为 vw 的函数
@function vw($px) {
  @return math.div($px, $designWidth) * 100vw;
}

// px 转为 vh 的函数
@function vh($px) {
  @return math.div($px, $designHeight) * 100vh;
}
复制代码</code></pre> 
 <p><strong>路径配置</strong>只需在<code>vue.config.js</code>里配置一下<code>utils.scss</code>的路径，就可以全局使用了</p> 
 <p>vue.config.js</p> 
 <pre class="has"><code class="language-go">const path = require("path");

function resolve(dir) {
  return path.join(__dirname, dir);
}

module.exports = {
  publicPath: "",
  configureWebpack: {
    name: "app name",
    resolve: {
      alias: {
        "@": resolve("src"),
      },
    },
  },
  css: {
    // 全局配置 utils.scs，详细配置参考 vue-cli 官网
    loaderOptions: {
      sass: {
        prependData: `@import "@/styles/utils.scss";`,
      },
    },
  },
};
复制代码</code></pre> 
 <p><strong>在 .vue 中使用</strong></p> 
 <pre class="has"><code class="language-go">&lt;template&gt;
    &lt;div class="box"&gt;   
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
    name: "Box",
}
&lt;/script&gt;

&lt;style lang="scss" scoped="scoped"&gt;
/* 
 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh 单位   
 */
.box{
    width: vw(300);
    height: vh(100);
    font-size: vh(16);
    background-color: black;
    margin-left: vw(10);
    margin-top: vh(10);
    border: vh(2) solid red;
}
&lt;/style&gt;
复制代码</code></pre> 
 <h6>css 方案 - less</h6> 
 <p>utils.less</p> 
 <pre class="has"><code class="language-go">@charset "utf-8";

// 默认设计稿的宽度
@designWidth: 1920;

// 默认设计稿的高度
@designHeight: 1080;

.px2vw(@name, @px) {
  @{name}: (@px / @designWidth) * 100vw;
}

.px2vh(@name, @px) {
  @{name}: (@px / @designHeight) * 100vh;
}

.px2font(@px) {
  font-size: (@px / @designWidth) * 100vw;
}
复制代码</code></pre> 
 <p><strong>路径配置</strong>在<code>vue.config.js</code>里配置一下<code>utils.less</code></p> 
 <pre class="has"><code class="language-go">const path = require("path");

function resolve(dir) {
  return path.join(__dirname, dir);
}

module.exports = {
  publicPath: "",
  configureWebpack: {
    name: "app name",
    resolve: {
      alias: {
        "@": resolve("src"),
      },
    },
  },
  css: {
    // 全局配置utils.scss
    loaderOptions: {
      less: {
        additionalData: `@import "@/styles/utils.less";`,
      },
    },
  },
};
复制代码</code></pre> 
 <p><strong>在 .vue 文件中使用</strong></p> 
 <pre class="has"><code class="language-go">&lt;template&gt;
    &lt;div class="box"&gt;   
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
    name: "Box",
}
&lt;/script&gt;

&lt;style lang="less" scoped="scoped"&gt;
/* 
 直接使用 vw 和 vh 函数，将像素值传进去，得到的就是具体的 vw vh单位   
 */
.box{
    .px2vw(width, 300);
    .px2vh(height, 100);
    .px2font(16);
    .px2vw(margin-left, 300);
    .px2vh(margin-top, 100);
    background-color: black;
}
&lt;/style&gt;
复制代码</code></pre> 
 <h6>定义 js 样式处理函数</h6> 
 <pre class="has"><code class="language-go">// 定义设计稿的宽高
const designWidth = 1920;
const designHeight = 1080;

// px转vw
export const px2vw = (_px) =&gt; {
  return (_px * 100.0) / designWidth + 'vw';
};

export const px2vh = (_px) =&gt; {
  return (_px * 100.0) / designHeight + 'vh';
};

export const px2font = (_px) =&gt; {
  return (_px * 100.0) / designWidth + 'vw';
};
复制代码</code></pre> 
 <h6>屏幕变化后，图表自动调整</h6> 
 <p>这种使用方式有个弊端，就是屏幕尺寸发生变化后，需要手动刷新一下才能完成自适应调整</p> 
 <p>为了解决这个问题，你需要在各个图表中监听页面尺寸变化，重新调整图表，在 vue 项目中，也可以借助<code>element-resize-detector</code>，最好封装个 resize 的指令，在各图表中就只要使用该指令就可以了，毕竟作为程序员，能偷懒就偷懒</p> 
 <ol><li><p>安装 element-resize-detector</p></li></ol> 
 <blockquote> 
  <p>npm install element-resize-detector --save</p> 
 </blockquote> 
 <ol><li><p>引入工具包在组件中使用或者在单独的 js 中使用</p></li></ol> 
 <blockquote> 
  <p>import resizeDetector from 'element-resize-detector'</p> 
 </blockquote> 
 <ol><li><p>封装 directive</p></li></ol> 
 <pre class="has"><code class="language-go">// directive.js
import * as ECharts from "echarts";
import elementResizeDetectorMaker from "element-resize-detector";
import Vue from "vue";
const HANDLER = "_vue_resize_handler";
function bind(el, binding) {
  el[HANDLER] = binding.value
    ? binding.value
    : () =&gt; {
        let chart = ECharts.getInstanceByDom(el);
        if (!chart) {
          return;
        }
        chart.resize();
      };
  // 监听绑定的div大小变化，更新 echarts 大小
  elementResizeDetectorMaker().listenTo(el, el[HANDLER]);
}
function unbind(el) {
  // window.removeEventListener("resize", el[HANDLER]);
  elementResizeDetectorMaker().removeListener(el, el[HANDLER]);
  delete el[HANDLER];
}
// 自定义指令：v-chart-resize 示例：v-chart-resize="fn"
Vue.directive("chart-resize", { bind, unbind });
复制代码</code></pre> 
 <ol><li><p>main.js 中引入</p></li></ol> 
 <pre class="has"><code class="language-go">import '@/directive/directive';
复制代码</code></pre> 
 <ol><li><p>html 代码</p></li></ol> 
 <pre class="has"><code class="language-go">&lt;template&gt;
  &lt;div class="linechart"&gt;
    &lt;div ref="chart" v-chart-resize class="chart"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
复制代码</code></pre> 
 <p>这里要注意的是，图表中如果需要 tab 切换动态更新图表数据，在更新数据时一定不要用 echarts 的 dispose 方法先将图表移除，再重新绘制，因为 resize 指令中挂载到的图表实例还是旧的，就监听不到新的 chart 元素的 resize 了，更新数据只需要用 chart 的 setOption 方法重新设置配置项即可。</p> 
 <h6>图表字体、间距、位移等尺寸自适应</h6> 
 <p>echarts 的字体大小只支持具体数值（像素），不能用百分比或者 vw 等尺寸，一般字体不会去做自适应，当宽高比跟 ui 稿比例出入太大时，会出现文字跟图表重叠的情况</p> 
 <p><img src="https://images2.imgbox.com/f5/ec/12BqJpE6_o.jpg" alt="3bf255b2c40f842c48b0db8491ce77b2.jpeg"> 这里我们就需要封装一个工具函数，来处理图表中文字自适应了👇</p> 
 <ul><li><p>默认情况下，这里以你的设计稿是 1920*1080 为例，即网页宽度是 1920px (做之前一定问清楚 ui 设计稿的尺寸）</p></li><li><p>把这个函数写在一个单独的工具文件<code>dataUtil.js</code>里面，在需要的时候调用</p></li><li><p>其原理是计算出当前屏幕宽度和默认设计宽度的比值，将原始的尺寸乘以该值</p></li><li><p>另外，其它 echarts 的配置项，比如间距、定位、边距也可以用该函数</p></li></ul> 
 <ol><li><p>编写 dataUtil.js 工具函数</p></li></ol> 
 <pre class="has"><code class="language-go">// Echarts图表字体、间距自适应
export const fitChartSize = (size,defalteWidth = 1920) =&gt; {
  let clientWidth = window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth;
  if (!clientWidth) return size;
  let scale = (clientWidth / defalteWidth);
  return Number((size*scale).toFixed(3));
}
复制代码</code></pre> 
 <ol><li><p>将函数挂载到原型上</p></li></ol> 
 <pre class="has"><code class="language-go">import {fitChartSize} from '@src/utils/dataUtil.js'
Vue.prototype.fitChartFont = fitChartSize;
复制代码</code></pre> 
 <ol><li><p>这样你可以在<code>.vue</code>文件中直接使用<code>this.fitChartSize()</code>调用</p></li></ol> 
 <pre class="has"><code class="language-go">&lt;template&gt;
  &lt;div class="chartsdom" ref="chart" v-chart-resize&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "dashboardChart",
  data() {
    return {
      option: null,
    };
  },
  mounted() {
    this.getEchart();
  },
  methods: {
    getEchart() {
      let myChart = this.$echarts.init(this.$refs.chart);
      const option = {
        backgroundColor: "transparent",
        tooltip: {
          trigger: "item",
          formatter: "{a} &lt;br/&gt;{b} : {c}%",
        },
        grid: {
          left: this.fitChartSize(10),
          right: this.fitChartSize(20),
          top: this.fitChartSize(20),
          bottom: this.fitChartSize(10),
          containLabel: true,
        },
        calculable: true,
        series: [
          {
            color: ["#0db1cdcc"],
            name: "计划投入",
            type: "funnel",
            width: "45%",
            height: "70%",
            x: "5%",

            minSize: "10%",
            funnelAlign: "right",

            center: ["50%", "50%"], // for pie

            data: [
              {
                value: 30,
                name: "下单30%",
              },
              {
                value: 55,
                name: "咨询55%",
              },
              {
                value: 65,
                name: "点击65%",
              },
              {
                value: 60,
                name: "访问62%",
              },
              {
                value: 80,
                name: "展现80%",
              },
            ].sort(function (a, b) {
              return a.value - b.value;
            }),
            roseType: true,
            label: {
              normal: {
                formatter: function () {},
                position: "inside",
              },
            },
            itemStyle: {
              normal: {
                borderWidth: 0,
                shadowBlur: this.fitChartSize(20),
                shadowOffsetX: 0,
                shadowOffsetY: this.fitChartSize(5),
                shadowColor: "rgba(0, 0, 0, 0.3)",
              },
            },
          },

          {
            color: ["#0C66FF"],
            name: "实际投入",
            type: "funnel",
            width: "45%",
            height: "70%",
            x: "50%",

            minSize: "10%",
            funnelAlign: "left",

            center: ["50%", "50%"], // for pie

            data: [
              {
                value: 35,
                name: "下单35%",
              },
              {
                value: 40,
                name: "咨询40%",
              },
              {
                value: 70,
                name: "访问70%",
              },
              {
                value: 90,
                name: "点击90%",
              },
              {
                value: 95,
                name: "展现95%",
              },
            ].sort(function (a, b) {
              return a.value - b.value;
            }),
            roseType: true,
            label: {
              normal: {
                position: "inside",
              },
            },
            itemStyle: {
              normal: {
                borderWidth: 0,
                shadowBlur: this.fitChartSize(20),
                shadowOffsetX: 0,
                shadowOffsetY: this.fitChartSize(5),
                shadowColor: "rgba(0, 0, 0, 0.3)",
              },
            },
          },
        ],
      };
      myChart.setOption(option, true);
    },
  },
  beforeDestroy() {},
};
&lt;/script&gt;

&lt;style lang="scss" scoped&gt;
.chartsdom {
  width: 100%;
  height: 100%;
}
&lt;/style&gt;
复制代码</code></pre> 
 <h4>方案二：scale</h4> 
 <p>通过 css 的 scale 属性，根据屏幕大小，对图表进行整体的等比缩放，从而达到自适应效果</p> 
 <h5>上效果</h5> 
 <img src="https://images2.imgbox.com/63/4f/duVM5Z9g_o.jpg" alt="7fe40188bc97a89b1b0359de4e3ac307.jpeg"> 
 <figcaption>
   sceen-scale.gif 
 </figcaption> 
 <p>当屏幕的尺寸比例刚好是 16:9 时，页面能刚好全屏展示，内容占满显示器</p> 
 <img src="https://images2.imgbox.com/a9/b6/QAC28O32_o.jpg" alt="ea0fb7f44ebecc9ff26be9082f720cbb.jpeg"> 
 <figcaption>
   sceen-demo.jpg 
 </figcaption> 
 <p>当屏幕的尺寸比例小于 16:9 时，页面上下留白，左右占满并上下居中，显示比例保持 16:9</p> 
 <img src="https://images2.imgbox.com/cd/e1/eHyX12pM_o.jpg" alt="9d26ec91c246444a3cf406d971ffca37.jpeg"> 
 <figcaption>
   sceen-demo-02.jpg 
 </figcaption> 
 <p>当屏幕尺寸比例大于 16:9 时，页面左右留白，上下占满并居中，显示比例保持 16:9</p> 
 <img src="https://images2.imgbox.com/96/19/ISRxmR4f_o.jpg" alt="8af3a61bd2e78410d59c9c25dcc23ccc.jpeg"> 
 <figcaption>
   sceen-demo-03.jpg 
 </figcaption> 
 <h5>话不多说，上代码</h5> 
 <p><strong>html 部分</strong></p> 
 <pre class="has"><code class="language-go">&lt;div className="screen-wrapper"&gt;
    &lt;div className="screen" id="screen"&gt;

    &lt;/div&gt;
 &lt;/div&gt;
复制代码</code></pre> 
 <p><strong>js 部分</strong></p> 
 <pre class="has"><code class="language-go">&lt;script&gt;
export default {
mounted() {
  // 初始化自适应  ----在刚显示的时候就开始适配一次
  handleScreenAuto();
  // 绑定自适应函数   ---防止浏览器栏变化后不再适配
  window.onresize = () =&gt; handleScreenAuto();
},
deleted() {
  window.onresize = null;
},
methods: {
  // 数据大屏自适应函数
  handleScreenAuto() {
    const designDraftWidth = 1920; //设计稿的宽度
    const designDraftHeight = 960; //设计稿的高度
    // 根据屏幕的变化适配的比例
    const scale =
      document.documentElement.clientWidth /
        document.documentElement.clientHeight &lt;
      designDraftWidth / designDraftHeight
        ? document.documentElement.clientWidth / designDraftWidth
        : document.documentElement.clientHeight / designDraftHeight;
    // 缩放比例
    document.querySelector(
      '#screen',
    ).style.transform = `scale(${scale}) translate(-50%, -50%)`;
  },
},
};
&lt;/script&gt;
复制代码</code></pre> 
 <p><strong>css部分</strong></p> 
 <pre class="has"><code class="language-go">/*
  除了设计稿的宽高是根据您自己的设计稿决定以外，其他复制粘贴就完事
*/  
.screen-root {
    height: 100%;
    width: 100%;
    .screen {
        display: inline-block;
        width: 1920px;  //设计稿的宽度
        height: 960px;  //设计稿的高度
        transform-origin: 0 0;
        position: absolute;
        left: 50%;
        top: -50%;
    }
}
复制代码</code></pre> 
 <h5>实现思路</h5> 
 <p><strong>如何缩放</strong></p> 
 <p>当<code>屏幕宽高比 &lt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕宽度 / 设计稿宽度</code>当<code>屏幕宽高比 &gt; 设计稿宽高比</code>，我们需要缩放的比例是<code>屏幕高度 / 设计稿高度</code></p> 
 <pre class="has"><code class="language-go">const scale = document.documentElement.clientWidth / document.documentElement.clientHeight &lt; designDraftWidth / designDraftHeight ?
            (document.documentElement.clientWidth / designDraftWidth) :
            (document.documentElement.clientHeight / designDraftHeight);
复制代码</code></pre> 
 <p>如果我们拿到的设计稿宽高为: 1920 * 960 px ，而我们的屏幕大小是 1440 * 900 px，那么 1440/900 = 1.6，920/960 = 2</p> 
 <p>因为 1.6 &lt; 2 （当前屏幕宽高比小于设计稿宽高比）</p> 
 <p>所以我们需要缩放的比例是：屏幕宽度除以设计稿宽度 = 1440/1920 = 0.75</p> 
 <p><strong>如何居中</strong>首先我们利用 <code>transform:translate(-50%,-50%)</code> ，将动画的基点设为左上角</p> 
 <blockquote> 
  <p>transform-origin：设置动画的基点(中心点)，默认点是元素的中心点</p> 
 </blockquote> 
 <p>语法</p> 
 <blockquote> 
  <p>transform-origin: x-axis y-axis z-axis;</p> 
 </blockquote> 
 <p>然后利用<code>transform:translate(-50%,-50%)</code>，将图表沿 x，y 轴移动 50%</p> 
 <img src="https://images2.imgbox.com/92/0d/07NVXYfb_o.jpg" alt="17064217275b7c900b9b7109730374a1.jpeg"> 
 <figcaption>
   image.png 
 </figcaption> 
 <p>接下来利用<code>绝对定位</code>将图表定位到中间位置</p> 
 <pre class="has"><code class="language-go">position: absolute;
left: 50%;
top: 50%;
复制代码</code></pre> 
 <h5>偷懒方法-插件</h5> 
 <p><code>v-scale-screen</code>是使用 css 属性 transform 实现缩放效果的一个大屏自适应组件，通过 scale 进行等比例计算，达到等比例缩放的效果，同时也支持铺满全屏，宽度等比，高度等比，等自适应方案,具体可查大屏自适应终极解决方案</p> 
 <h4>方案三：rem + vw wh</h4> 
 <h5>上效果</h5> 
 <img src="https://images2.imgbox.com/87/35/9GnbEHIC_o.jpg" alt="8f817c94b7d2b59d992f227a858dd356.jpeg"> 
 <figcaption>
   rem.gif 
 </figcaption> 
 <p>当屏幕的尺寸比例刚好是 16:9 时，页面能刚好全屏展示，内容占满显示器</p> 
 <img src="https://images2.imgbox.com/b4/10/xwyJlpW5_o.jpg" alt="9f45044327b8c9cf3947b33d90ac7a4b.jpeg"> 
 <figcaption>
   rem01.jpg 
 </figcaption> 
 <p>当屏幕的尺寸比例小于 16:9 时，页面上下留白，左右占满并上下居中，显示比例保持 16:9</p> 
 <img src="https://images2.imgbox.com/0a/ac/cfTYAx0Y_o.jpg" alt="3c8fd52ede6f915d6b7271abf1171262.jpeg"> 
 <figcaption>
   rem02.jpg 
 </figcaption> 
 <p>当屏幕尺寸比例大于 16:9 时，页面左右留白，上下占满并居中，显示比例保持 16:9</p> 
 <img src="https://images2.imgbox.com/05/53/6x3rEbtx_o.jpg" alt="fa199702ba4711a5069f4b2ce14ec666.jpeg"> 
 <figcaption>
   rem03.jpg 
 </figcaption> 
 <h5>实现思路</h5> 
 <p><strong>关于 rem</strong><code>rem(font size of the root element)</code>，是 css3 中新增的一个大小单位，即相对于根元素 font-size 值的大小。<strong>自适应思路</strong>动态的计算出页面的 fontsize 从而改变 rem 的大小。</p> 
 <ol><li><p>拿 1920 * 1080 的标准屏幕大小为例，将屏幕分为<code>10</code>份，先计算<code>rem 的基准值:</code> 1920 / 10 = 192；</p></li><li><p>把所有元素的长、宽、位置、字体大小等原来的 px 单位全部转换成 rem；</p></li><li><p>网页加载后，用 js 去计算当前浏览器的宽度，并设置 html 的 font-size 为 (<code>当前浏览器窗口宽度 / 10</code>) 。 这样的话 10rem 就刚好等于浏览器窗口的宽度，也就可以保证 100% 宽度，等比例缩放设计稿的页面了。 <img src="https://images2.imgbox.com/7d/d7/tmAHfS2b_o.jpg" alt="39b4bac2e2af7d4727388947913436b4.jpeg"></p></li></ol> 
 <p><strong>因此 rem + vm vh 方案要解决三件事</strong></p> 
 <ol><li><p>获得 rem 的基准值；</p></li><li><p>页面内写一段 js 代码，动态的计算<code>html根元素的font-size</code>；</p></li><li><p>屏幕变化后，图表自动调整和图表字体、间距、位移等的自适应。</p></li></ol> 
 <h5>实现方案</h5> 
 <p><strong>第一点：获得 rem 的基准值</strong></p> 
 <ol><li><p>首先安装 <code>@njleonzhang/postcss-px-to-rem</code> 这个包</p></li></ol> 
 <pre class="has"><code class="language-go">npm i @njleonzhang/postcss-px-to-rem -D
复制代码</code></pre> 
 <ol><li><p>在项目根目录新建<code>.postcssrc.js</code>配置文件</p></li></ol> 
 <pre class="has"><code class="language-go">module.exports = {
  plugins: {
    autoprefixer: {},
    "@njleonzhang/postcss-px-to-rem": {
      unitToConvert: 'px', // (String) 要转换的单位，默认是 px。
      widthOfDesignLayout: 1920, // (Number) 设计布局的宽度。对于pc仪表盘，一般是 1920.
      unitPrecision: 3, // (Number) 允许 rem 单位增长到的十进制数字.
      selectorBlackList: ['.ignore', '.hairlines'], // (Array) 要忽略并保留为 px 的选择器.
      minPixelValue: 1, // (Number) 设置要替换的最小像素值.
      mediaQuery: false // (Boolean) 允许在媒体查询中转换 px.
    }
  }
}
复制代码</code></pre> 
 <ol><li><p>配置完成后，页面内的 px 就会被转换成 rem 了</p></li></ol> 
 <p><strong>第二点：动态的计算<code>html根元素的font-size</code></strong></p> 
 <ol><li><p>在工具函数文件中新建一个 rem.js 文件，用于动态计算 font-size</p></li></ol> 
 <pre class="has"><code class="language-go">(function init(screenRatioByDesign = 16 / 9) {
  let docEle = document.documentElement
  function setHtmlFontSize() {
    var screenRatio = docEle.clientWidth / docEle.clientHeight;
    var fontSize = (
      screenRatio &gt; screenRatioByDesign
        ? (screenRatioByDesign / screenRatio)
        : 1
    ) * docEle.clientWidth / 10;
    docEle.style.fontSize = fontSize.toFixed(3) + "px";
    console.log(docEle.style.fontSize);
  }
  setHtmlFontSize()
  window.addEventListener('resize', setHtmlFontSize)
})()
复制代码</code></pre> 
 <ol><li><p>在入口文件 main.js 中引入 rem.js 文件</p></li></ol> 
 <pre class="has"><code class="language-go">import './utils/rem.js';
复制代码</code></pre> 
 <p>至此，页面就已经可以实现 16:9 自适应了。</p> 
 <p><strong>第三点：屏幕变化，图表自适应</strong>屏幕变化后，图表自动调整字体、间距、位移等，此处参考上面 vm vh 的实现方式即可，在此就不重复赘述了</p> 
 <h4>参考资料</h4> 
 <ul><li><p>推荐一个echarts 的案列网站，需要什么直接图表直接在上面去找，可以省去很多查 echarts 配置的时间全网echarts案例资源大总结和echarts的高效使用技巧（细节版）</p></li><li><p>scale 方案参考： 数据大屏最简单自适应方案，无需适配rem单位</p></li><li><p>vm vh 方案参考： Vue+Echarts企业级大屏项目适配方案</p></li><li><p>rem 方案参考：数据大屏rem适配方案</p></li></ul> 
 <blockquote> 
  <p>作者：懒惰的智慧 </p> 
  <p>链接：https://juejin.cn/post/7163932925955112996 </p> 
 </blockquote> 
 <p style="text-align:center;">Node 社群</p> 
 <p style="text-align:left;">我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/13/94/5fKVjrlY_o.png" alt="e5f16f7d76c504d6f6b6afb4ae0614d5.jpeg"></p> 
 <p style="text-align:right;">  <strong> “分享、点赞、在看” 支持一波👍</strong></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dabc052d3cc9ab311580923eae71259d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Erlang - 入门之一日志系统如何打印输出使用lager框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd287a9abdce5280915ea19962d63f01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【大数据技术Hadoop&#43;Spark】Hive数据仓库架构、优缺点、数据模型介绍（图文解释 超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>