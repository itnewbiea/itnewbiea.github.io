<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中关键字const和mutable的用法总结 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中关键字const和mutable的用法总结" />
<meta property="og:description" content="const关键字 1、const修饰普通变量和指针 const修饰变量，一般有两种写法： const TYPE value; TYPE const value; 两种写法在本质上是一样的。含义是：const修饰的类型为TYPE的变量value是不可变的。对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value值不可变。 例如： const int nValue； //nValue是const int const nValue； //nValue是const 但是对于指针类型的TYPE，不同的写法会有不同情况： 指针本身是常量不可变 (char*) const pContent; 指针所指向的内容是常量不可变 const (char) *pContent; (char) const *pContent; 两者都不可变 const char* const pContent; 识别const到底是修饰指针还是指针所指的对象，还有一个较为简便的方法，也就是沿着*号划一条线： 如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 2、const修饰函数参数 const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)： void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用) void function(const char* Var); //参数指针所指内容为常量不可变 void function(char* const Var); //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的) void function(const Class&amp; Var); //引用参数在函数内不可以改变 参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。 3、const修饰类对象/对象指针/对象引用 const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。 const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 例如： class AAA { void func1(); void func2() const; } const AAA aObj; aObj." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/54cbd232fce72873924c3f8bfe00c772/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-28T17:21:03+08:00" />
<meta property="article:modified_time" content="2016-04-28T17:21:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中关键字const和mutable的用法总结</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li>const关键字</li></ul> 
<h6>1、const修饰普通变量和指针</h6> const修饰变量，一般有两种写法： 
<br> 
<pre><code class="language-cpp">const TYPE value;
TYPE const value;</code></pre> 
<br> 
<br> 两种写法在本质上是一样的。含义是：const修饰的类型为TYPE的变量value是不可变的。对于一个非指针的类型TYPE，无论怎么写，都是一个含义，即value值不可变。 例如： 
<br> 
<pre><code class="language-cpp">const int nValue； //nValue是const
int const nValue； //nValue是const</code></pre> 
<br> 
<br> 但是对于指针类型的TYPE，不同的写法会有不同情况： 
<br> 指针本身是常量不可变 
<br> 
<pre><code class="language-cpp">(char*) const pContent;</code></pre> 
<br> 
<br> 指针所指向的内容是常量不可变 
<br> 
<pre><code class="language-cpp">const (char) *pContent;
(char) const *pContent;</code></pre> 
<br> 
<br> 两者都不可变 
<br> 
<pre><code class="language-cpp">const char* const pContent;</code></pre> 
<br> 
<br> 识别const到底是修饰指针还是指针所指的对象，还有一个较为简便的方法，也就是沿着*号划一条线： 
<br> 如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 
<br> 如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 
<br> 2、const修饰函数参数 
<br> const修饰函数参数是它最广泛的一种用途，它表示在函数体中不能修改参数的值(包括参数本身的值或者参数其中包含的值)： 
<br> 
<pre><code class="language-cpp">void function(const int Var); //传递过来的参数在函数内不可以改变(无意义，该函数以传值的方式调用)
void function(const char* Var); //参数指针所指内容为常量不可变
void function(char* const Var); //参数指针本身为常量不可变(也无意义，var本身也是通过传值的形式赋值的)
void function(const Class&amp; Var); //引用参数在函数内不可以改变</code></pre> 
<br> 
<br> 参数const通常用于参数为指针或引用的情况，若输入参数采用“值传递”方式，由于函数将自动产生临时变量用于复制该参数，该参数本就不需要保护，所以不用const修饰。 
<br> 3、const修饰类对象/对象指针/对象引用 
<br> const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。 
<br> const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。 
<br> 例如： 
<br> 
<pre><code class="language-cpp">class AAA
{
void func1();
void func2() const;
}
const AAA aObj;
aObj.func1(); 错误
aObj.func2(); 正确

const AAA* aObj = new AAA();
aObj-&gt;func1(); 错误
aObj-&gt;func2(); 正确</code></pre> 
<br> 
<br> 
<br> 4、const修饰数据成员 
<br> const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么，例如： 
<br> 
<pre><code class="language-cpp">class A
{
const int size = 100; //错误
int array[size]; //错误，未知的size
}</code></pre> 
<br> 
<br> const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，可以用类中的枚举常量来实现，例如： 
<br> 
<pre><code class="language-cpp">class A
{
…
enum {size1=100, size2 = 200 };
int array1[size1];
int array2[size2];
…
}</code></pre> 
<br> 
<br> 枚举常量不会占用对象的存储空间，他们在编译时被全部求值。但是枚举常量的隐含数据类型是整数，其最大值有限，且不能表示浮点数。 
<br> 5、const修饰成员函数 
<br> const修饰类的成员函数，用const修饰的成员函数不能改变对象的成员变量。一般把const写在成员函数的最后： 
<br> 
<pre><code class="language-cpp">class A
{
…
void function()const; //常成员函数, 它不改变对象的成员变量. 也不能调用类中任何非const成员函数。
}</code></pre> 
<br> 
<br> 对于const类对象/指针/引用，只能调用类的const成员函数。 
<br> 
<ul><li>C++关键字mutable</li></ul> （1）mutable的意思是“可变的，易变的”，跟C++中的const是反义词。 
<br> （2）在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中 
<br> 实例说明： 
<br> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class TestMutable
{
public:
TestMutable(){i=0;}
int Output() const
{
return i++; //error C2166: l-value specifies const object
}
private:
int i;
};
int main()
{
TestMutable testMutable;
cout&lt;&lt;testMutable.Output()&lt;&lt;endl;
return 0;
}</code></pre> 
<br> 
<br> 显然i++在const修饰的函数里是编译通不过的。 
<br> 修改代码： 
<br> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
class TestMutable
{
public:
TestMutable(){i=0;}
int Output() const
{
return i++; 
}
private:
mutable int i;
};
int main()
{
TestMutable testMutable;
cout&lt;&lt;testMutable.Output()&lt;&lt;endl;
return 0;
}</code></pre> 
<br> 
<br> 在 int i 前面加上 mutable上面就能编译通过了，马上可以看出关键字mutable的作用了。 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/566d631d4242879137f68d1941f1eea6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">您无权输入许可证密钥,请请使用系统管理员账户重试</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21610f77a2f8c4aa33ec19810981c32f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mongoose（三）：数据类型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>