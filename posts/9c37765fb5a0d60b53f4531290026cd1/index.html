<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用 Transformer 网络建立预测模型 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="利用 Transformer 网络建立预测模型" />
<meta property="og:description" content="引言
我最近读了一篇非常有趣的论文：Deep Transformer Models for Time Series Forecasting: The Influenza Prevalence Case。我认为这可能是一个有趣的项目，从零开始实施类似的东西，以了解更多关于时间序列预测。
预测任务：
在时间序列预测中，目标是根据时间序列的历史价值预测其未来价值。时间序列预测任务的一些例子如下：
预测流感流行个案：Deep Transformer Models for Time Series Forecasting: The Influenza Prevalence Case
能源产量预测：Energy consumption forecasting using a stacked non-parametric Bayesian approach
天气预报：MetNet: A Neural Weather Model for Precipitation Forecasting
例如，我们可以将一个城市的能源消耗量数据存储几个月，然后训练一个模型，该模型将能够预测该城市未来的能源消耗。这可以用来估计能源需求，因此能源公司可以使用这个模型来估计在任何特定时间需要生产的能源的最佳价值。
时间序列预测实例
模型
我们将使用的模型是一个编解码 Transformer，其中编码器部分作为输入的历史时间序列，而解码器部分以自回归的方式预测未来的价值。
解码器使用注意机制与编码器连接。通过这种方式，解码器可以学会在进行预测之前“关注”时间序列中最有用的部分历史值。
解码器使用 masked self-attention，使网络不能在训练运行过程中通过预测未来值来预测过去值来作弊。
编码器子网络：
编码器
解码器子网络：
解码器
完整模型：
自回归编/解码 Transformer
这个体系结构可以使用 PyTorch 构建，方法如下：
encoder_layer = nn.TransformerEncoderLayer( d_model=channels, nhead=8, dropout=self.dropout, dim_feedforward=4 * channels, ) decoder_layer = nn." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/9c37765fb5a0d60b53f4531290026cd1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-18T20:30:00+08:00" />
<meta property="article:modified_time" content="2021-06-18T20:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用 Transformer 网络建立预测模型</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><strong>引言</strong></p> 
 <p>我最近读了一篇非常有趣的论文：<strong>Deep Transformer Models for Time Series Forecasting: The Influenza Prevalence Case</strong>。我认为这可能是一个有趣的项目，从零开始实施类似的东西，以了解更多关于时间序列预测。</p> 
 <p><strong>预测任务：</strong></p> 
 <p>在时间序列预测中，目标是根据时间序列的历史价值预测其未来价值。时间序列预测任务的一些例子如下：</p> 
 <ul><li><p style="text-align: justify">预测流感流行个案：<strong>Deep Transformer Models for Time Series Forecasting: The Influenza Prevalence Cas</strong><strong>e</strong></p></li><li><p style="text-align: justify">能源产量预测：<strong>Energy consumption forecasting using a stacked non-parametric Bayesian approach</strong></p></li><li><p style="text-align: justify">天气预报：<strong>MetNet: A Neural Weather Model for Precipitation Forecasting</strong></p></li></ul> 
 <p>例如，我们可以将一个城市的能源消耗量数据存储几个月，然后训练一个模型，该模型将能够预测该城市未来的能源消耗。这可以用来估计能源需求，因此能源公司可以使用这个模型来估计在任何特定时间需要生产的能源的最佳价值。</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/e6/8f/Lq6bHIVT_o.png"></p> 
 <p style="text-align: center">时间序列预测实例</p> 
 <p><strong>模型</strong></p> 
 <p>我们将使用的模型是一个编解码 Transformer，其中编码器部分作为输入的历史时间序列，而解码器部分以自回归的方式预测未来的价值。</p> 
 <p>解码器使用注意机制与编码器连接。通过这种方式，解码器可以学会在进行预测之前“关注”时间序列中最有用的部分历史值。</p> 
 <p>解码器使用 masked self-attention，使网络不能在训练运行过程中通过预测未来值来预测过去值来作弊。</p> 
 <p><strong>编码器子网络：</strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/ed/44/OxhGq5Jo_o.png"></p> 
 <p style="text-align: center">编码器</p> 
 <p><strong>解码器子网络：</strong></p> 
 <p><img src="https://images2.imgbox.com/78/62/c04fJvi1_o.png"></p> 
 <p style="text-align: center">解码器</p> 
 <p><strong>完整模型：</strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/61/60/9V3BWZqK_o.png"></p> 
 <p style="text-align: center">自回归编/解码 Transformer</p> 
 <p>这个体系结构可以使用 PyTorch 构建，方法如下：</p> 
 <pre class="has"><code class="language-properties">encoder_layer = nn.TransformerEncoderLayer(
    d_model=channels,
    nhead=8,
    dropout=self.dropout,
    dim_feedforward=4 * channels,
)
decoder_layer = nn.TransformerDecoderLayer(
    d_model=channels,
    nhead=8,
    dropout=self.dropout,
    dim_feedforward=4 * channels,
)


self.encoder = torch.nn.TransformerEncoder(encoder_layer, num_layers=8)
self.decoder = torch.nn.TransformerDecoder(decoder_layer, num_layers=8)
</code></pre> 
 <p><strong>数据</strong></p> 
 <p>每次我实现一种新的方法时，我都喜欢首先在合成数据上进行尝试，以便更容易理解和调试。这降低了数据的复杂性，并且更加关注于实现/算法。</p> 
 <p>我编写了一个小脚本，可以生成具有不同周期、偏移量和模式的非平凡时间序列。</p> 
 <pre class="has"><code class="language-python">def generate_time_series(dataframe):


    clip_val = random.uniform(0.3, 1)


    period = random.choice(periods)


    phase = random.randint(-1000, 1000)


    dataframe["views"] = dataframe.apply(
        lambda x: np.clip(
            np.cos(x["index"] * 2 * np.pi / period + phase), -clip_val, clip_val
        )
        * x["amplitude"]
        + x["offset"],
        axis=1,
    ) + np.random.normal(
        0, dataframe["amplitude"].abs().max() / 10, size=(dataframe.shape[0],)
    )


    return dataframe
</code></pre> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/fb/79/8cCWxHQq_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/ae/28/xqC5wWml_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/99/f1/DWYVay3C_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/4b/c5/xgKfrkGM_o.png"></p> 
 <p style="text-align: center">生成的时间序列示例<br></p> 
 <p>然后，该模型同时对所有这些时间序列进行训练：</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/d0/8e/5xnZtUWy_o.png"></p> 
 <p style="text-align: center">训练损失</p> 
 <p><strong>结果</strong></p> 
 <p>我们现在使用这个模型来预测这些时间序列的未来价值，结果有点喜忧参半：</p> 
 <p><strong>错误的</strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/b2/56/xe3pICXb_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/39/56/kWT3bGaQ_o.png"></p> 
 <p style="text-align: center">错误预测的例子</p> 
 <p><strong>正确的</strong></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/b8/18/L2XlKfmL_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/df/03/aJhj8n1N_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/56/57/3psEkJD7_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/d2/59/P1ExavuU_o.png"></p> 
 <p style="text-align: center">正确预测的例子</p> 
 <p>结果并不像我预期的那么好，特别是考虑到通常很容易对合成数据做出好的预测，但是他们仍然是让人有所期待的。</p> 
 <p>该模型的预测有点不同步与轻微的振幅高估了一些不良的例子。在好的例子中，除去噪音，这个预测非常符合实际情况。</p> 
 <p>我可能需要调试我的代码多一点，并在优化超参数之前，我可以期望得到更好的结果。</p> 
 <p><strong>结论</strong></p> 
 <p>Transformers 是目前非常流行的模型，在许多机器学习的应用，所以这是很自然的，他们将用于时间序列预测。</p> 
 <p>Transformers 可能不是你处理时间序列的第一选择，因为它们可能沉重而且需要大量数据，但是它们很适合你的机器学习工具包，因为它们的多功能性和广泛的应用范围，从它们第一次在 NLP 中应用到音频处理，计算机视觉和时间序列。</p> 
 <p><strong>·  END  ·</strong><br></p> 
 <p>HAPPY LIFE</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/91/15/Au3OWUXE_o.png"></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59975d19d57d0eee0137fcd90de862ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微型计算机的总线分为哪些,计算机总线的分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/748c0892035f3bcc7bab11778910fbe9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">欲与天公试比高：决策树算法及实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>