<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简单对接抖音小店的接口 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简单对接抖音小店的接口" />
<meta property="og:description" content="最近公司需要对接抖音小店的接口。然后其实对接起来还是蛮简单的，不过自己阅读文档的能力还有点问题，所以这里记录一下开发遇到的问题。
文档地址：https://op.jinritemai.com/docs/guide-docs/6/14
首先是需要准备的配置。
抖音小店的整个流程分两步，第一步先获取他们的access_token，因为调用接口的时候需要附带这个token作为url的参数去调用的，不然会报错。然后第二步就是上面说的再去正式调参。
所以我的做法是写了一个定时每隔10分钟去调用一次token。官方文档找不到了，所以我就贴下自己的方法，下图。
拿到了token保存到缓存就可以写接下来的代码了。
https://op.jinritemai.com/docs/guide-docs/10/23
官方文档说他们接口get，post都能调用。我也试了确实可以。调用接口的时候主要碰到的问题是拼参数的问题。因为我开始为了偷懒，就直接用字符串拼接了，但是他们的param格式是Map&lt;String, String&gt; 的字符串 {&#34;id&#34;: &#34;0&#34;}，所以在拼的时候就很容易出错。因为你要拼成这种格式需要这样写string param = &#34;{\&#34;id\&#34;: \&#34;0\&#34;}&#34;;。参数一个还行，多了就很容易出错，所以推荐用map然后转jsonObject再转字符串。这样就不会出错了。
然后我也推荐用treeMap去做为容器去装。因为treeMap再插入值的时候会对key进行排序。因为官方文档说明了param需要key从小到大排序，而treeMap也满足了这点要求。
然后抖店接口还有个sign值的参数。他是由很多参数加到一起然后加密的一个字符串，然后这个sign值在调用接口的时候是需要一同带过去的。
然后这个requestStr在拼接的时候也是需要将他的key值从大到小去排序。下面是加密方式，这个官方文档也是有的。
然后得到上述这些就可以去调用抖店的接口了。下面贴个简单的订单列表接口实例（其实确实蛮简单的，但是坑还是有的）
流程就是先拿到token，再拿到当前时间（其实好像不是当前时间也可以），然后根据他的method, param, date去获取sign（/order/list就是这个接口的api，然后order.list就是接口的method，文档都有：https://op.jinritemai.com/docs/api-docs/15/55）
然后我这里json和date做了下转换是因为参数怕会有什么特殊字符，所以要转义一下。
然后就可以拼好url了（url &#43; param）然后用http请求就行。
全部代码：
package com.xxx.mall.core.utils; import com.alibaba.fastjson.JSONObject; import com.xxx.mall.common.DoudianConstant; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import java.io.UnsupportedEncodingException; import java.math.BigInteger; import java.net.URLEncoder; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.TreeMap; public class DouDianUtils { /** * 抖店接口域名 */ private static final String DOUDIAN_URL = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/99b2d48347d56c574210b9adc46a3f92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-18T17:49:55+08:00" />
<meta property="article:modified_time" content="2020-10-18T17:49:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简单对接抖音小店的接口</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近公司需要对接抖音小店的接口。然后其实对接起来还是蛮简单的，不过自己阅读文档的能力还有点问题，所以这里记录一下开发遇到的问题。</p> 
<p>文档地址：<a href="https://op.jinritemai.com/docs/guide-docs/6/14" rel="nofollow">https://op.jinritemai.com/docs/guide-docs/6/14</a></p> 
<p>首先是需要准备的配置。</p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/f3/05/3kh3UqBO_o.png" width="1122"></p> 
<p>抖音小店的整个流程分两步，第一步先获取他们的access_token，因为调用接口的时候需要附带这个token作为url的参数去调用的，不然会报错。然后第二步就是上面说的再去正式调参。</p> 
<p>所以我的做法是写了一个定时每隔10分钟去调用一次token。官方文档找不到了，所以我就贴下自己的方法，下图。</p> 
<p><img alt="" height="903" src="https://images2.imgbox.com/4c/dc/phbQayS2_o.png" width="1129"></p> 
<p> </p> 
<p>拿到了token保存到缓存就可以写接下来的代码了。</p> 
<p><a href="https://op.jinritemai.com/docs/guide-docs/10/23" rel="nofollow">https://op.jinritemai.com/docs/guide-docs/10/23</a></p> 
<p>官方文档说他们接口get，post都能调用。我也试了确实可以。调用接口的时候主要碰到的问题是拼参数的问题。因为我开始为了偷懒，就直接用字符串拼接了，但是他们的param格式是Map&lt;String, String&gt; 的字符串 {"id": "0"}，所以在拼的时候就很容易出错。因为你要拼成这种格式需要这样写string param = "{\"id\": \"0\"}";。参数一个还行，多了就很容易出错，所以推荐用map然后转jsonObject再转字符串。这样就不会出错了。</p> 
<p>然后我也推荐用treeMap去做为容器去装。因为treeMap再插入值的时候会对key进行排序。因为官方文档说明了param需要key从小到大排序，而treeMap也满足了这点要求。</p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/aa/94/cXTpeQQn_o.png" width="751"></p> 
<p>然后抖店接口还有个sign值的参数。他是由很多参数加到一起然后加密的一个字符串，然后这个sign值在调用接口的时候是需要一同带过去的。<img alt="" height="434" src="https://images2.imgbox.com/71/a1/mlvyZflT_o.png" width="1200"></p> 
<p>然后这个requestStr在拼接的时候也是需要将他的key值从大到小去排序。下面是加密方式，这个官方文档也是有的。</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/f8/46/qGJMPGzW_o.png" width="1200"></p> 
<p>然后得到上述这些就可以去调用抖店的接口了。下面贴个简单的订单列表接口实例（其实确实蛮简单的，但是坑还是有的）</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/d7/5d/eOTnfKWo_o.png" width="1200"></p> 
<p><img alt="" height="698" src="https://images2.imgbox.com/b8/8e/mr30rG1A_o.png" width="1200"></p> 
<p>流程就是先拿到token，再拿到当前时间（其实好像不是当前时间也可以），然后根据他的method, param, date去获取sign（/order/list就是这个接口的api，然后order.list就是接口的method，文档都有：<a href="https://op.jinritemai.com/docs/api-docs/15/55" rel="nofollow">https://op.jinritemai.com/docs/api-docs/15/55</a>）</p> 
<p>然后我这里json和date做了下转换是因为参数怕会有什么特殊字符，所以要转义一下。</p> 
<p>然后就可以拼好url了（url + param）然后用http请求就行。</p> 
<p>全部代码：</p> 
<pre><code class="language-java">package com.xxx.mall.core.utils;

import com.alibaba.fastjson.JSONObject;
import com.xxx.mall.common.DoudianConstant;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;


public class DouDianUtils {

    /**
     * 抖店接口域名
     */
    private static final String DOUDIAN_URL = "https://openapi-fxg.jinritemai.com";
    /**
     * app key
     */
    private static final String APP_KEY = "your app key";
    /**
     * app secret
     */
    private static final String APP_SECRET = "your app secret";
    /**
     * 抖店cache的cacheName
     */
    private static final String DOUDIAN_CACHE_NAME = "doudianCache";
    /**
     * 抖店cache的cacheKey
     */
    private static final String DOUDIAN_TOKEN_KEY = "doudian_access_token";

    /**
     * 通过api取accessToken
     */
    public static void fetchAccessToken() {
        String url = DOUDIAN_URL + "/oauth2/access_token" + "?app_id=" + APP_KEY + "&amp;app_secret="
                + APP_SECRET + "&amp;grant_type=authorization_self";
        String response = HttpUtils.httpGet(url, 20000);
        if (StringUtils.isBlank(response)) {
            for (int i = 0; i &lt; 3; i++) {
                response = HttpUtils.httpGet(url, 20000);
                if (StringUtils.isNotBlank(response)) {
                    break;
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        JSONObject jsonObject = JSONObject.parseObject(response);
        if (jsonObject.getIntValue("err_no") == 0) {
            JSONObject data = jsonObject.getJSONObject("data");
            if (null != data) {
                //用于调用API的access_token
                String accessToken = data.getString("access_token");
                if (StringUtils.isNotBlank(accessToken)) {
                    CacheUtil.put(DOUDIAN_CACHE_NAME, DOUDIAN_TOKEN_KEY, accessToken);
                }
            }
        }
    }

    /**
     * 获取 输入参数签名结果 sign
     *
     * @param methodName 方法名
     * @param paramJson 传参
     * @param timeStamp 时间戳
     * @return sign
     */
    public static String fetchSign(String methodName, String paramJson, String timeStamp) {
        String requestStr = APP_SECRET + "app_key" + APP_KEY + "method" + methodName + "param_json" + paramJson + "timestamp"
                + timeStamp + "v2" + APP_SECRET;
        return paramToMD5(requestStr);
    }

    /**
     * 将param参数转成MD5
     *
     * @param requestStr 请求参数
     * @return String
     */
    public static String paramToMD5(String requestStr) {
        byte[] secretBytes;
        try {
            secretBytes = MessageDigest.getInstance("md5").digest(
                    requestStr.getBytes());
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("没有这个md5算法！");
        }
        StringBuilder md5code = new StringBuilder(new BigInteger(1, secretBytes).toString(16));
        while (md5code.length() &lt; 32) {
            md5code.insert(0, "0");
        }
        return md5code.toString();
    }

    /**
     * 获取订单列表 支持按照子订单状态和订单的创建时间、更新时间来检索订单，获取订单列表
     *
     * Tips：
     * 此接口做了限流，每个access_token每分钟1000次上限
     * 此接口，page最多返回100页，一页最多100单，故同样的请求，最多能拉到1万单
     * 通过该接口获取到的父订单，会在order_id后面会加上字母A做标识（这里和从店铺后台导出的订单有区别，从店铺后台导出的订单末尾没有A，
     * 但其实际和通过openapi获取的父订单是同一个，如依据运营导出的订单做核对，则请做订单末尾的A相关处理）
     * 如搜索时指定order_status，则搜索维度为子订单，即按照子订单状态搜索，total也为该状态子订单数量。返回结果的json结构不变，仍为父子订单结构，
     * 因此当有父订单包含多子订单时，返回的结构中父订单可能会有重复!
     * 由于订单同步会有延迟，建议在使用open接口拉取订单时，要做缓冲和兜底处理。比如，在今天的6:00去拉取5:30-5:40的数据后（20分钟后拉），明天的6:00时再拉取一次今天5:30-5:40的数据（兜底补拉）
     *
     * 拉订单最好不要100页的拉，要98-99页的拉，100页有的时候会出问题
     * start_time 开始时间
     * end_time 结束时间
     * order_by 1、默认按订单创建时间搜索 2、值为“create_time”：按订单创建时间；值为“update_time”：按订单更新时间
     * @return JSONArray
     * @throws UnsupportedEncodingException
     */
    public static JSONObject fetchOrderList() throws UnsupportedEncodingException {
        Map&lt;String, String&gt; map = new TreeMap&lt;&gt;();
        map.put("start_time", "2020/08/01 00:00:00");
        map.put("end_time", "2020/10/02 00:00:00");
        map.put("order_by", "create_time");
        String paramJson = JSONObject.toJSONString(map);
        String accessToken = (String) CacheUtil.get(DOUDIAN_CACHE_NAME, DOUDIAN_TOKEN_KEY);
        String url = DOUDIAN_URL + "/order/list";
        Date now = new Date();
        String dateStr = DateUtil.date2Str(now, "yyyy-MM-dd HH:mm:ss");

        String sign = fetchSign("order.list", paramJson, dateStr);
        //转码
        String paramJson2 = URLEncoder.encode(paramJson, "UTF-8");
        String dateStr2 = URLEncoder.encode(dateStr, "UTF-8");
        String param = "?app_key=" + APP_KEY + "&amp;method=" + "order.list" + "&amp;access_token="
                + accessToken + "&amp;param_json=" + paramJson2 + "&amp;timestamp=" + dateStr2 + "&amp;v=2&amp;sign=" + sign;
        String response = HttpUtils.httpGet(url + param, 20000);
        JSONObject jsonObject = JSONObject.parseObject(response);
        if (jsonObject.getIntValue("err_no") == 0) {
            return jsonObject.getJSONObject("data");
        }
        return null;
    }
}
</code></pre> 
<p>这里只是实例代码，可以根据实际要求优化代码，这就是后面的工作了。</p> 
<p> </p> 
<p>=============================================================================================</p> 
<p>更新一下遇到新的问题：</p> 
<p>批量添加sku的时候（/sku/addAll）,规格id取的是规格项的最上级的id。这里如果有三个sku的话就是拼成8|8|8</p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/c3/a6/D3iJTZdr_o.png" width="793"><img alt="" height="589" src="https://images2.imgbox.com/73/a8/wmx2sr2A_o.png" width="756"></p> 
<div id="gtx-trans"> 
 <div class="gtx-trans-icon">
     
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56ccbb86c1791838b1e191bf521bb4b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java计算字符串形式的百分数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47df484be5fc0df2f2d1f90db8e8c8be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">463. 判断回文链表的3种方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>