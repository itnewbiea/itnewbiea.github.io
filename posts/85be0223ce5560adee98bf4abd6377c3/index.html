<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实现二叉树类及若干应用算法（附具体代码） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实现二叉树类及若干应用算法（附具体代码）" />
<meta property="og:description" content="一、二叉树的存储结构 1. 顺序存储结构
由于每个数据元素的存储位置彼此之间有着一定的关系，因此可以根据结点的编号直接计算出他的父结点、左右孩子结点的位置。类似的，其他操作也可以通过计算得出。
但是此存储结构只对于满、完全二叉树来说效率极高，而对于一般的二叉树而言使用顺序存储会造成空间极大的浪费。
2. 链式存储结构
链式存储中，每个结点结构应该包含两个指针域，分别指向左、右孩子结点，以及一个结点数据。
struct BiNode { T data;	//结点数据 BiNode&lt;T&gt;* lchild;	//左孩子 BiNode&lt;T&gt;* rchild;	//右孩子 }; 使用链式存储虽然还是有许多空指针域，但是后面会进一步改进该程序使得空指针域得以利用，所以我们选择链式存储。
二、二叉树的遍历算法 1.先序遍历
先输出本身的值，再依次输出左、右孩子的值。
void BiTree&lt;T&gt;::PreOrder(BiNode&lt;T&gt;* p) { if (p == NULL) return; cout &lt;&lt; p-&gt;data; PreOrder(p-&gt;lchild); PreOrder(p-&gt;rchild); } 2.中序遍历
先输出左孩子的值，再输出本身的值，最后输出右孩子的值。
void BiTree&lt;T&gt;::InOrder(BiNode&lt;T&gt;* p) { if (p == NULL) return; InOrder(p-&gt;lchild); cout &lt;&lt; p-&gt;data; InOrder(p-&gt;rchild); } 3.后序遍历
先输出左、右孩子的值，最后输出本身的值。
void BiTree&lt;T&gt;::PostOrder(BiNode&lt;T&gt;* p) { if (p == NULL) return; PostOrder(p-&gt;lchild); PostOrder(p-&gt;rchild); cout &lt;&lt; p-&gt;data; } 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/85be0223ce5560adee98bf4abd6377c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-06T21:42:05+08:00" />
<meta property="article:modified_time" content="2021-11-06T21:42:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实现二叉树类及若干应用算法（附具体代码）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>一、二叉树的存储结构</h3> 
<p><strong>1. 顺序存储结构</strong><br> 由于每个数据元素的存储位置彼此之间有着一定的关系，因此可以根据结点的编号直接计算出他的父结点、左右孩子结点的位置。类似的，其他操作也可以通过计算得出。<br> 但是此存储结构只对于满、完全二叉树来说效率极高，而对于一般的二叉树而言使用顺序存储会造成空间极大的浪费。</p> 
<p><strong>2. 链式存储结构</strong><br> 链式存储中，每个结点结构应该包含两个指针域，分别指向左、右孩子结点，以及一个结点数据。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> BiNode
<span class="token punctuation">{<!-- --></span>
	T data<span class="token punctuation">;</span>					<span class="token comment">//结点数据</span>
	BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> lchild<span class="token punctuation">;</span>		<span class="token comment">//左孩子</span>
	BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> rchild<span class="token punctuation">;</span>		<span class="token comment">//右孩子</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用链式存储虽然还是有许多空指针域，但是后面会进一步改进该程序使得空指针域得以利用，所以我们选择链式存储。</p> 
<h3><a id="_19"></a>二、二叉树的遍历算法</h3> 
<p><strong>1.先序遍历</strong><br> 先输出本身的值，再依次输出左、右孩子的值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">PreOrder</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">;</span>
	<span class="token function">PreOrder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">PreOrder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2.中序遍历</strong><br> 先输出左孩子的值，再输出本身的值，最后输出右孩子的值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">InOrder</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">InOrder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">;</span>
	<span class="token function">InOrder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>3.后序遍历</strong><br> 先输出左、右孩子的值，最后输出本身的值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">PostOrder</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">PostOrder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">PostOrder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>4.层次遍历</strong><br> 自上而下，从左向右一层层遍历，因为具有先进先出的特点，所以使用队列来实现相关操作。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">LevelOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	queue<span class="token operator">&lt;</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span><span class="token operator">&gt;</span> Q<span class="token punctuation">;</span>
	Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
			Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
			Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>因为前面三种遍历都是递归算法，所以要注意不能直接调用根结点，需要通过对外开放的函数作为媒介调用根结点。</strong></p> 
<p><strong>例如：</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">PreOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>注意：进行递归运算时只需要考虑前几种情况，不要想的太深，会混淆</strong></p> 
<h3><a id="_94"></a>三、二叉树的构造</h3> 
<p><strong>1. 单个遍历序列构造二叉树</strong><br> 通过带空指针标记的先序序列来构造一个确定的二叉树<img src="https://images2.imgbox.com/e2/57/33JxJpH2_o.jpg" alt=""></p> 
<p>通过将空指针标记为*来唯一确定一个二叉树</p> 
<pre><code class="prism language-cpp">BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">CreateByPre</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	T e <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	i<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">&gt;</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild <span class="token operator">=</span> <span class="token function">CreateByPre</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild <span class="token operator">=</span> <span class="token function">CreateByPre</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2.通过两个不同序列来构造一个确定的二叉树</strong><br> 两个不同序列可以是先序序列和中序序列，也可以是后序序列和中序序列，但是不能是先序序列和后序序列。<br> 下面以先序序列和中序序列为例：<br> 已知某二叉树的先序序列为ABHFDECKG，中序序列为HBDFAEKCG，确定二叉树的过程如图所示。<br> <img src="https://images2.imgbox.com/0a/59/Xj6QmzhR_o.jpg" alt="在这里插入图片描述"><br> 后序序列和中序序列确定二叉树的方法与上图类似。</p> 
<pre><code class="prism language-cpp">BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">CreateByPreMid</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> ipre<span class="token punctuation">,</span> <span class="token keyword">int</span> imid<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	BiNode <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">&gt;</span>data <span class="token operator">=</span> pre<span class="token punctuation">[</span>ipre<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pre<span class="token punctuation">[</span>ipre<span class="token punctuation">]</span> <span class="token operator">==</span> mid<span class="token punctuation">[</span>imid <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild <span class="token operator">=</span> <span class="token function">CreateByPreMid</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> ipre <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> imid<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild <span class="token operator">=</span> <span class="token function">CreateByPreMid</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> ipre <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_141"></a>四、二叉树的析构</h3> 
<p>析构要从底层向根结点依次析构，这里要用到递归的算法。</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> BiTree<span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span><span class="token operator">:</span><span class="token operator">:</span><span class="token function">Free</span><span class="token punctuation">(</span>BiNode<span class="token generics function"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> NULL<span class="token punctuation">)</span>		
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">Free</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Free</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	delete p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_153"></a>五、其他应用算法</h3> 
<p><strong>1.计算二叉树的结点数</strong><br> 利用后序遍历程序的框架，将计数目标分解为对左子树和右子树的计数，通过逐层递归调用完成。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Count</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">Count</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> left <span class="token operator">+</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>2.计算二叉树的高度</strong><br> 若二叉树为空则高度为0，否则二叉树的高度为左、右子树高度的最大值加1，同样是利用了递归调用。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Height</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">Height</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">Height</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span>
		<span class="token keyword">return</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token keyword">return</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>3.根据关键值查找结点</strong><br> 查找过程可以分解为3各部分：<br> ①结点比较<br> ②左子树查找<br> ③右子树查找<br> 若查找成功则停止查找并返回该结点的指针，若所有结点都不满足条件返回NULL。</p> 
<pre><code class="prism language-cpp">BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Search</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">,</span> T e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>data <span class="token operator">==</span> e<span class="token punctuation">)</span>
		<span class="token keyword">return</span> p<span class="token punctuation">;</span>
	BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> q <span class="token operator">=</span> <span class="token function">Search</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> q<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">Search</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>4.查找结点的父结点</strong><br> 和上面的算法类似，也是分为三部分：根结点的比较和左、右子树的查找。<br> 若查找成功返回对应的结点，否则返回NULL。</p> 
<pre><code class="prism language-cpp">BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> BiTree<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">SearchParent</span><span class="token punctuation">(</span>BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">,</span> BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> child<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> child <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild <span class="token operator">==</span> child <span class="token operator">||</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild <span class="token operator">==</span> child<span class="token punctuation">)</span>
		<span class="token keyword">return</span> p<span class="token punctuation">;</span>
	BiNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> q <span class="token operator">=</span> <span class="token function">SearchParent</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>lchild<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> q<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">SearchParent</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rchild<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_220"></a>六、总结</h3> 
<p>二叉树类的实现运用了大量的递归运算，在层次遍历中还使用了队列的算法。递归运算时一定要注意将大问题化为小问题，并且不要随着递归而不停的向下去思考，只需要考虑最上面一层的递归，其他的交给计算机来实现即可。同时这里的二叉树存储结构选择的为链式存储，仍然有大量的空间浪费，后面将介绍线索二叉树将这些浪费的空间全部都利用上。</p> 
<p>具体代码：<a href="https://download.csdn.net/download/qq_52207529/38150962">二叉树类及其相关应用</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6e5f3d0a962db75b548c20c61d7e4d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机图形学基础-图形的表示和数据结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d73e2975c157008d05b43d3d998dfcb2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pinia简介和setup语法糖</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>