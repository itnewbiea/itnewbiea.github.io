<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python入门自学进阶-Web框架——38、redis、rabbitmq、git - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python入门自学进阶-Web框架——38、redis、rabbitmq、git" />
<meta property="og:description" content="缓存数据库redis：
NoSQL（Not only SQL）泛指非关系型的数据库。为了解决大规模数据集合多重数据类的挑战。
NoSQL数据库的四大分类：
键值（Key-Value）存储数据库列存储数据库文档型数据库图形（Graph）数据库 redis是业界主流的key-value nosql数据库之一。redis主要用在linux类系统。
要在 Ubuntu 上安装 Redis，打开终端，然后输入以下命令：
$sudo apt-get update $sudo apt-get install redis-server 在windows系统下，下载压缩包，解压缩后，就可以直接运行。
解压缩后的Redis-x64-5.0.14.1：
在此目录下运行cmd，在命令窗口运行命令redis-server redis.windows.conf，启动redis服务器
可以看到，服务的端口是6379。此启动方法表示临时服务安装成功。使用该指令创建的服务，不会再window service列表中出现redis服务名，此窗口关闭，临时服务会自动退出
后台服务安装启动指令：redis-server.exe --service-install redis.windows.conf --loglevel verbose（一定要先卸载已经安装的临时或者固定的服务，否则会出现错误）
卸载服务：redis-server --service-uninstall
启动服务指令：redis-server.exe --service-start
如果需要停止就执行 redis-server --service-stop // 停止服务
再打开一个cmd窗口，运行客户端：redis-cli.exe
redis-py 的API的使用可以分类为：
连接方式连接池操作 String 操作Hash 操作List 操作Set 操作Sort Set 操作管道发布订阅 String操作：
使用：set 、get 、 keys *
在使用set时，显示set语法：
set(name, value, ex=None, px=None, nx=False, xx=False)
1
2
3
4
5
6" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/37e1aadb16b801d13aa09951f6a7867b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-04T17:29:05+08:00" />
<meta property="article:modified_time" content="2023-08-04T17:29:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python入门自学进阶-Web框架——38、redis、rabbitmq、git</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;"><strong>缓存数据库redis</strong></span>：</p> 
<p>NoSQL（Not only SQL）泛指非关系型的数据库。为了解决大规模数据集合多重数据类的挑战。</p> 
<p><strong>NoSQL数据库的四大分类</strong>：</p> 
<ul><li>键值（Key-Value）存储数据库</li><li>列存储数据库</li><li>文档型数据库</li><li>图形（Graph）数据库</li></ul> 
<p>redis是业界主流的key-value nosql数据库之一。redis主要用在linux类系统。</p> 
<p>要在 Ubuntu 上安装 Redis，打开终端，然后输入以下命令：</p> 
<pre>$sudo apt-get update
$sudo apt-get install redis-server</pre> 
<p>在windows系统下，下载压缩包，解压缩后，就可以直接运行。</p> 
<p>解压缩后的Redis-x64-5.0.14.1：</p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/bc/cb/78TyHoEL_o.png" width="623"></p> 
<p> 在此目录下运行cmd，在命令窗口运行命令redis-server redis.windows.conf，启动redis服务器</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/06/40/iXfDyiU4_o.png" width="644"></p> 
<p> 可以看到，服务的端口是6379。此启动方法表示临时服务安装成功。使用该指令创建的服务，不会再window service列表中出现redis服务名，此窗口关闭，临时服务会自动退出</p> 
<p>后台服务安装启动指令：redis-server.exe --service-install redis.windows.conf --loglevel verbose（一定要先卸载已经安装的临时或者固定的服务，否则会出现错误）</p> 
<p>卸载服务：redis-server --service-uninstall</p> 
<p>启动服务指令：redis-server.exe --service-start</p> 
<p>如果需要停止就执行 redis-server --service-stop // 停止服务</p> 
<p>再打开一个cmd窗口，运行客户端：redis-cli.exe</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/8c/ac/0sD3XrPT_o.png" width="571"></p> 
<p>redis-py 的API的使用可以分类为：</p> 
<ul><li>连接方式</li><li>连接池</li><li>操作 
  <ul><li>String 操作</li><li>Hash 操作</li><li>List 操作</li><li>Set 操作</li><li>Sort Set 操作</li></ul></li><li>管道</li><li>发布订阅</li></ul> 
<p><strong> String操作</strong>：</p> 
<p>使用：set 、get 、 keys *</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/70/45/8LtDaInA_o.png" width="314"></p> 
<p> 在使用set时，显示set语法：</p> 
<p><img alt="" height="48" src="https://images2.imgbox.com/ad/e4/XRnaVGzX_o.png" width="640"></p> 
<p> set(name, value, ex=None, px=None, nx=False, xx=False)</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>在Redis中设置值，默认，不存在则创建，存在则修改</code></p> <p><code>参数：</code></p> <p><code>     </code><code>ex，过期时间（秒）</code></p> <p><code>     </code><code>px，过期时间（毫秒）</code></p> <p><code>     </code><code>nx，如果设置为True，则只有name不存在时，当前set操作才执行</code></p> <p><code>     </code><code>xx，如果设置为True，则只有name存在时，当前set操作才执行</code></p> </td></tr></tbody></table> 
<p><img alt="" height="214" src="https://images2.imgbox.com/9b/86/YB4Uf5Ek_o.png" width="306"></p> 
<p> 其他一些命令：setnx(key,value) 、setex(key,value,time) 、psetex(key,time_ms,value) 、mset(*args,**kwargs) 、get(key) 、 mget(keys,*args)、 getset(key,value)、 getrange(key,start,end)、 setrange(key,offset,value)、setbit(key,offset,value) 、getbit(name,offset)、 bitcount(key,start=None,end=None)、 strlen(key)、 incr(self,key,amount=1)、 incrbyfloat(self,key,amount=1.0)、decr(self,key,amount=1) 、 append(key,value)</p> 
<p>setbit/getbit/bitcount这一组命令来记录、统计用户登录信息。</p> 
<p><strong>Hash操作</strong>：</p> 
<p>hset (key field value)、hget(key field)、 hmset(key,mapping)、 hmget(key field)、 hkeys(key)、 hgetall(key)、 hlen(key)、 hvals(key)、 hexists(key field)、 hincrby(key field)、  HSCAN key cursor [MATCH pattern] [COUNT count]、 hdel(key *field)、 </p> 
<p><strong>list操作：</strong></p> 
<p>lpush、 llen、 lrange、 pushx、 lpushx、 linsert、lset、 lrem、 lpop、 lindex、 lrange、 ltrim、 rpoplpush、 blpop、 brpoplpush</p> 
<p><strong>set操作：</strong></p> 
<p>无序集合</p> 
<p>sadd、scard 、 sdiff、 sdiffstore、 sinter、 sinterstore、 sismember、 smove、 spop、 srandmember、 srem、 sunion、 sunionstore、 sscan</p> 
<p>有序集合</p> 
<p>zadd、 zcard、 zrank、 zrem、 zrenrangebyrank、 zcount、 zincrby、 zrange、 zremrangebyscore、 zscore、 zinterstore、 zscan、</p> 
<p><strong>其他操作：</strong></p> 
<p>delete、exists、 keys 、 expire 、rename、 move、 randomkey、 type、 scan</p> 
<p><strong>python连接使用redis：</strong></p> 
<p>安装模块：pip install redis</p> 
<p>使用：</p> 
<pre><code class="language-python">import redis

r = redis.Redis(host='127.0.0.1',port=6379)
r.set('foo','bar')
print(r.get('foo'))</code></pre> 
<p>将host地址改为网卡的地址：</p> 
<pre><code class="language-python">import redis

r = redis.Redis(host='192.168.1.117',port=6379)
r.set('foo','bar')
print(r.get('foo'))</code></pre> 
<p>结果是：ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。</p> 
<p>需要修改redis.windows.conf文件中，将bind 127.0.0.1 改为bind 192.168.1.117</p> 
<p>如果改为bind 0.0.0.0 则使用192.168.1.117或127.0.0.1都能访问到。</p> 
<p>这时，是未经验证就直接访问了，可以使用密码进行验证。修改redis.windows.conf文件中的配置项：# requirepass foobared</p> 
<p>可以看到，需要密码是注释掉的，即不需要密码验证，打开验证：requirepass abc123</p> 
<p>重启后，再次运行上面的程序：提示：redis.exceptions.AuthenticationError: Authentication required.</p> 
<p>现在需要验证了</p> 
<pre><code class="language-python">import redis

r = redis.Redis(host='127.0.0.1',port=6379,password='abc123')
r.set('foo','bar')
print(r.get('foo'))</code></pre> 
<p>此时，连接成功。</p> 
<p>在客户端使用时，也需要密码，还用auth password验证。</p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/34/fd/1GgswZbr_o.png" width="353"></p> 
<p> 使用连接池：</p> 
<pre><code class="language-python">import redis

pool =redis.ConnectionPool(host='192.168.1.117',port=6379,password='abc123')
r = redis.Redis(connection_pool=pool)
r.set('foo2','bar222')
print(r.get('foo2'))
r.set('ccc2',1234)</code></pre> 
<p>管道：redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p> 
<pre><code class="language-python">import redis

pool =redis.ConnectionPool(host='192.168.1.117',port=6379,password='abc123')
r = redis.Redis(connection_pool=pool)

pipe = r.pipeline(transaction=True)
pipe.set('name','aaaaaaaa')
pipe.set('role','bbbbbbbbbbbb')
pipe.execute()</code></pre> 
<p><span style="color:#fe2c24;"><strong>消息队列RabbitMQ</strong></span>：</p> 
<p><strong>消息队列中间件——</strong>是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性。 使用较多的消息队列有 ActiveMQ（安全），RabbitMQ，ZeroMQ，Kafka（大数据），MetaMQ，RocketMQ<br><strong>RabbitMQ</strong> ——一个由 Erlang 语言开发的 AMQP 的开源实现。<br><strong>AMQP</strong> ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。<br> RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：<br> 1.可靠性（Reliability）<br> RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。<br> 2.灵活的路由（Flexible Routing）<br> 在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。<br> 3.消息集群（Clustering）<br> 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker<br> 4.高可用（Highly Available Queues）<br> 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。<br> 5.多种协议（Multi-protocol）<br> RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。<br> 6.多语言客户端（Many Clients）<br> RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。<br> 7.管理界面（Management UI）<br> RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。<br> 8.跟踪机制（Tracing）<br> 如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。<br> 9.插件机制（Plugin System）<br> RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p> 
<p>RabbitMQ的工作原理：</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/57/a3/PngeqPBN_o.png" width="1015"></p> 
<p> </p> 
<p><strong>Broker：</strong>接收和分发消息的应用，RabbitMQ Server就是Message Broker<br><strong>Connection：</strong> publisher / consumer（发布者/消费者）和 broker之间的TCP连接。（个人感觉用producer/consumer——生产者/消费者或publisher/subscriber——发布者/订阅者更合适）        <strong>Channel：</strong>如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id 帮助客户端和message broker识别 channel，所以channel 之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建TCP connection的开销<br><strong>Exchange：</strong>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有: direct (point-to-point), topic(publish-subscribe) and fanout<br> (multicast)<br><strong>Routing Key：</strong>生产者将消息发送到交换机时会携带一个key,来指定路由规则<br><strong>binding Key：</strong>在绑定Exchange和Queue时，会指定一个BindingKey,生产者发送消息携带的RoutingKey会和bindingKey对比，若一致就将消息分发至这个队列<br><strong>vHost 虚拟主机：</strong>每一个RabbitMQ服务器可以开设多个虚拟主机，每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的 "交换机exchange、绑定Binding、队列Queue"，更重要的是每一个vhost拥有独立的权限机制，这样就能安全地使用一个RabbitMQ服务器来服务多个应用程序，其中每个vhost服务一个应用程序。</p> 
<p><strong>RabbitMQ的安装（windows版本）：</strong></p> 
<p>RabbitMQ需要Erlang的支持，先安装这个支持包otp_win64_25.3.2.exe，OTP代表开放电信平台。 它是一个应用程序操作系统和一组用于构建大规模，容错，分布式应用程序的库和过程。核心概念是OTP行为，可以看作一个用回调函数作为参数的应用程序框架。</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/4c/c6/nMpQEmvB_o.png" width="504"></p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/e2/69/HtmwkRQ7_o.png" width="498"> </p> 
<p> <img alt="" height="379" src="https://images2.imgbox.com/fc/70/kApphJah_o.png" width="495"></p> 
<p> <img alt="" height="381" src="https://images2.imgbox.com/9a/bf/7d9P2CT5_o.png" width="498"></p> 
<p> <img alt="" height="292" src="https://images2.imgbox.com/62/fb/hu4FSit9_o.png" width="482"></p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/79/30/gFYNEf0K_o.png" width="484"> </p> 
<p> <img alt="" height="289" src="https://images2.imgbox.com/08/d5/pW9MBA0b_o.png" width="482"></p> 
<p> <img alt="" height="371" src="https://images2.imgbox.com/f6/f4/Rp9o8CJ7_o.png" width="497"></p> 
<p> 安装RabbitMQ：rabbitmq-server-3.12.1.exe</p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/39/b7/YnRz4laO_o.png" width="503"></p> 
<p> <img alt="" height="374" src="https://images2.imgbox.com/6b/7e/t8cusUhk_o.png" width="498"></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/2f/27/7RdNFHfn_o.png" width="500"> </p> 
<p> <img alt="" height="375" src="https://images2.imgbox.com/df/d8/jdKKAkWX_o.png" width="502"></p> 
<p>安装完成后，在服务列表中能可见：</p> 
<p><img alt="" height="74" src="https://images2.imgbox.com/6a/ac/1nbkscN3_o.png" width="541"> </p> 
<p> 安装管理界面（插件）：</p> 
<p>进入rabbitMQ安装目录的sbin目录，点击上方的路径框输入cmd，按下回车键</p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/03/af/2JnnzZ9E_o.png" width="729"></p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/10/42/c5cqmc12_o.png" width="709"> </p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/bd/7b/eRCqZDUB_o.png" width="610"> </p> 
<p>运行命令：  rabbitmq-plugins enable rabbitmq_management </p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/87/c3/j0hI3pZx_o.png" width="667"></p> 
<p>打开浏览器，输入http://127.0.0.1:15672/，登录</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/f6/2d/4qVfiAvT_o.png" width="503"> </p> 
<p>输入用户名和密码，初始都为guest</p> 
<p><img alt="" height="743" src="https://images2.imgbox.com/ea/0a/Ou46v8w7_o.png" width="1200"> </p> 
<p> 至此，安装完毕。</p> 
<p>Python使用RabbitMQ，需要安装pika模块：pip install pika</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/09/27/5UtX7lb3_o.png" width="648"></p> 
<p> RabbitMQ的使用：最简单的发布与接收</p> 
<pre><code class="language-python"># File：sender.py 发送消息，即生产者
import pika  # 链接mq需要pika模块

connection = pika.BlockingConnection(pika.ConnectionParameters(
    'localhost'))
channel = connection.channel()

# 声明queue
channel.queue_declare(queue='hello')

# 在RabbitMQ中一个消息不可能被直接发送到queue，即队列中，它总是需要通过exchange进行转发
channel.basic_publish(exchange='',
                      routing_key='hello',
                      body='消息体：hello world!'.encode('utf-8'),)
print("[x] sent 'hello word!'")
connection.close()</code></pre> 
<p> </p> 
<pre><code class="language-python"># File：recv.py  消费者，即接收者、订阅者
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(
    'localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')

def callback(ch, method, properties, body):
    print("[x] Received %r" % body.decode("utf-8"))

channel.basic_consume(queue='hello',on_message_callback=callback,auto_ack=True)

print('[*] Waiting for message. To exit press CTRL+C')
channel.start_consuming()</code></pre> 
<p>在消费者端，basic_consume方法中设置了auto_ack=True，即自动应答，即消费者接受消息后，自动应答RabbitMQ服务器，即Broker，然后在Broker中的队列中将此消息删除，否则，如果设置为False，则会在队列中一直存在，如下：</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/05/48/ujy0IsZ4_o.png" width="782"></p> 
<p> 显示有2条未应答，消息还有2条。</p> 
<p>可以设置手动应答：</p> 
<pre><code class="language-python"># File：recv.py  消费者，即接收者、订阅者
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters(
    'localhost'))
channel = connection.channel()
channel.queue_declare(queue='hello')

def callback(ch, method, properties, body):
    print("[x] Received %r" % body.decode("utf-8"))
    # 如果basic_consume中auto_ack为False，则这里要手动进行应答
    channel.basic_ack(delivery_tag=method.delivery_tag) # 手动应答
    print('手动应答队列中消息')
channel.basic_consume(queue='hello',on_message_callback=callback,auto_ack=False)

print('[*] Waiting for message. To exit press CTRL+C')
channel.start_consuming()</code></pre> 
<p><img alt="" height="475" src="https://images2.imgbox.com/1a/fc/Ouup8GRI_o.png" width="573"></p> 
<p> 自带的用户、密码为guest的只能本机登录，可以增加用户：</p> 
<p>rabbitmqctl add_user 用户名 密码</p> 
<p>给指定用户添加管理员权限：</p> 
<p>rabbitmqctl  set_user_tags 用户名 administrator</p> 
<p>给用户添加权限</p> 
<p>rabbitmqctl set_permissions -p / 用户名 ".*" ".*" ".*"</p> 
<p>以上是使用命令进行用户的添加，但是在测试时，出现问题：</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/c8/9b/wGFdwYvO_o.png" width="646"></p> 
<p> 查询网上的解决方法，也没成功，然后从web端增加了用户。</p> 
<p>使用增加的用户进行消息操作：</p> 
<p>生产者：</p> 
<pre><code class="language-python"># File：sender.py 发送消息，即生产者
import pika  # 链接mq需要pika模块
import time
user_info = pika.PlainCredentials('tester','test1234')
connection = pika.BlockingConnection(pika.ConnectionParameters(
    '192.168.1.117',5672,'/',user_info))
channel = connection.channel()

# 声明queue
# 如果指定的queue不存在，则会创建一个queue，如果已经存在 则不会做其他动作，官方推荐，每次使用时都可以加上这句
channel.queue_declare(queue='hello')

# 在RabbitMQ中一个消息不可能被直接发送到queue，即队列中，它总是需要通过exchange进行转发
for i in range(0,20):
    channel.basic_publish(exchange='', # 简单模式，这里设置为空字符串就可以
                          routing_key='hello', # 指定消息要发送到哪个queue
                          body='消息体{}：hello world!'.format(i).encode('utf-8'), ) # 指定要发送的消息
    print("[x] sent %s 'hello word!'" % i)
    time.sleep(1)
connection.close()

#RabbitMQ中所有的消息都要先通过交换机，空字符串表示使用默认的交换机</code></pre> 
<p>消费者：</p> 
<pre><code class="language-python"># File：recv.py  消费者，即接收者、订阅者
import pika

user_info = pika.PlainCredentials('tester','test1234')
connection = pika.BlockingConnection(pika.ConnectionParameters(
    '192.168.1.117',5672,'/',user_info))
channel = connection.channel()
channel.queue_declare(queue='hello')

def callback(ch, method, properties, body):
    print("[x] Received %r" % body.decode("utf-8"))
    # 如果basic_consume中auto_ack为False，则这里要手动进行应答
    channel.basic_ack(delivery_tag=method.delivery_tag) # 手动应答
    print('手动应答队列中消息')
    # ch,即channel: 包含channel的一切属性和方法
    # method: 包含 consumer_tag, delivery_tag, exchange, redelivered, routing_key
    # properties: basic_publish 通过 properties 传入的参数
    # body: basic_publish发送的消息


channel.basic_consume(queue='hello', # 接收指定queue的消息
                      on_message_callback=callback, # 设置收到消息的回调函数
                      auto_ack=False) # 指定为True，表示消息接收到后自动给消息发送方回复确认，已收到消息，False表示不自动确认，需要在callback中手工确认

print('[*] Waiting for message. To exit press CTRL+C')

# 一直处于等待接收消息的状态，如果没收到消息就一直处于阻塞状态，收到消息就调用上面的回调函数
channel.start_consuming()</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="790" src="https://images2.imgbox.com/b4/0c/SAGpy0FD_o.png" width="644"></p> 
<p> 以上是RabbitMQ简单模式</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/ef/69/R6MtacyC_o.png" width="793"></p> 
<p>上面的生产者存在一个问题，就是在我们的消费者还没开始消费完队列里的消息，如果这时rabbitmq服务挂了，那么消息队列里的消息将会全部丢失，解决方法是在声明队列时，声明队列为可持久化存储队列，并且在生产者在将消息插入到消息队列时，设置消息持久化存储，具体如下</p> 
<pre><code class="language-python"># File：sender.py 发送消息，即生产者
import pika  # 链接mq需要pika模块
import time
user_info = pika.PlainCredentials('tester','test1234')
connection = pika.BlockingConnection(pika.ConnectionParameters(
    '192.168.1.117',5672,'/',user_info))
channel = connection.channel()

# 声明queue
# 如果指定的queue不存在，则会创建一个queue，如果已经存在 则不会做其他动作，官方推荐，每次使用时都可以加上这句
channel.queue_declare(queue='durable_queue',durable=True)
#PS：这里不同种队列不允许名字相同,这个队列设置了持久化为True，即是一个持久化队列

# 在RabbitMQ中一个消息不可能被直接发送到queue，即队列中，它总是需要通过exchange进行转发
for i in range(0,20):
    channel.basic_publish(exchange='', # 简单模式，这里设置为空字符串就可以
                          routing_key='durable_queue', # 指定消息要发送到哪个queue
                          body='消息体{}：hello world!'.format(i).encode('utf-8'), # 指定要发送的消息
                          properties=pika.BasicProperties(delivery_mode=2))
                         # 设置当前消息持久化存储（properties=pika.BasicProperties(delivery_mode=2)）
    print("[x] sent %s 'hello word!'" % i)
    time.sleep(1)
connection.close()

#RabbitMQ中所有的消息都要先通过交换机，空字符串表示使用默认的交换机

</code></pre> 
<p>消费者，只需修改队列的声明与生产者一致即可，如channel.queue_declare(queue='durable_queue',durable=True)</p> 
<p>同时开启多个消费者，会随机读取队列中的消息。</p> 
<p>默认安装的RabbitMQ中，在运行了上面的程序后，在RabbitMQ中connections、channel、exchange、queues信息：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/87/cf/HF9KH0VF_o.png" width="809"></p> 
<p> </p> 
<p></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c13d7b0663aca8715428819521c2ce9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文阅读：ImageNet</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6dd8832b73c0d98b24f54b0ba87f7060/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; 对象指针</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>