<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库查询优化 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库查询优化" />
<meta property="og:description" content="1 使用SET NOCOUNT ON 选项： 缺省地，每次执行SQL语句时，一个消息会从服务端发给客户端以显示SQL语句影响的行数。这些信息对客户端来说很少有用。通过关闭这个缺省值，你能减少在服务端和客户端的网络流量，帮助全面提升服务器和应用程序的性能。为了关闭存储过程级的这个特点，在每个存储过程的开头包含“SET NOCOUNT ON”语句。
2 正确使用UNION和UNION ALL： 许多人没完全理解UNION和UNION SELECT是怎样工作的，因此，结果浪费了大量不必要的SQLServer资源。当使用UNION时，它相当于在结果集上执行SELECT DISTINCT。换句话说，UNION将联合两个相类似的记录集，然后搜索重复的记录并排除。如果这是你的目的，那么使用UNION是正确的。但如果你使用UNION联合的两个记录集没有重复记录，那么使用UNION会浪费资源，因为它要寻找重复记录，即使你确定它们不存在。
所以如果你知道你要联合的记录集里没有重复，那么你要使用UNION ALL，而不是UNION。UNION ALL联合记录集，但不搜索重复记录，这样减少SQLServer资源的使用，从而提升性能。
3 尽量不用SELECT * ： 绝大多数情况下，不要用 * 来代替查询返回的字段列表，用 * 的好处是代码量少、就算是表结构或视图的列发生变化，编写的查询SQL语句也不用变，都返回所有的字段。但数据库服务器在解析时，如果碰到 *，则会先分析表的结构，然后把表的所有字段名再罗列出来。这就增加了分析的时间。
4 慎用SELECT DISTINCT： DISTINCT子句仅在特定功能的时候使用，即从记录集中排除重复记录的时候。这是因为DISTINCT子句先获取结果集然后去重，这样增加SQLServer有用资源的使用。当然，如果你需要去做，那就只有去做了。
当如果你知道SELECT语句将从不返回重复记录，那么使用DISTINCT语句对SQLServer资源不必要的浪费。
5 少用游标： 任何一种游标都会降低SQLServer性能。有些情况不能避免，大多数情况可以避免。所以如果你的应用程序目前正在使用TSQL游标，看看这些代码是否能够重写以避免它们。如果你需要一行一行的执行操作，考虑下边这些选项中的一个或多个来代替游标的使用：
使用临时表
使用WHILE循环
使用派生表
使用相关子查询
使用CASE语句
使用多个查询
上面每一个都能取代游标并且执行更快。 如果你不能避免使用游标，至少试着提高它们的速度，找出加速游标的方法。
6 选择最有效率的表名顺序： SQLSERVER的解析器按照从右到左的顺序处理FROM子句中的表名，因此FROM子句中写在最后的表（基础表driving table）将被最先处理，在FROM子句中包含多个表的情况下，必须选择记录条数最少的表作为基础表，当SQLSERVER处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表（FROM子句中最后的那个表)并对记录进行排序；然后扫描第二个表（FROM子句中最后第二个表)；最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并。
例如: 表 TAB1有 16384 条记录，表 TAB2 有5条记录，选择TAB2作为基础表 (最好的方法)：
select count(*) from TAB1 a, TAB2 b
选择TAB1作为基础表 (不佳的方法)：
select count(*) from TAB2 a, TAB1 b" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7104c6e4772648896c3cba49433a1883/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-02-09T10:25:45+08:00" />
<meta property="article:modified_time" content="2015-02-09T10:25:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库查询优化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">1<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">使用SET NOCOUNT ON 选项：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:宋体">缺省地，每次执行SQL语句时，一个消息会从服务端发给客户端以显示SQL语句影响的行数。这些信息对客户端来说很少有用。通过关闭这个缺省值，你能减少在服务端和客户端的网络流量，帮助全面提升服务器和应用程序的性能。为了关闭存储过程级的这个特点，在每个存储过程的开头包含“</span><span style="background-color:inherit; font-family:宋体">SET NOCOUNT ON</span><span style="background-color:inherit; font-family:宋体">”语句。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">2<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">正确使用UNION和UNION ALL：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">许多人没完全理解UNION和UNION SELECT是怎样工作的，因此，结果浪费了大量不必要的SQLServer资源。当使用UNION时，它相当于在结果集上执行SELECT DISTINCT。换句话说，UNION将联合两个相类似的记录集，然后搜索重复的记录并排除。如果这是你的目的，那么使用UNION是正确的。但如果你使用UNION联合的两个记录集没有重复记录，那么使用UNION会浪费资源，因为它要寻找重复记录，即使你确定它们不存在。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">所以如果你知道你要联合的记录集里没有重复，那么你要使用UNION ALL，而不是UNION。UNION ALL联合记录集，但不搜索重复记录，这样减少SQLServer资源的使用，从而提升性能。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">3<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">尽量不用SELECT * ：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">绝大多数情况下，不要用 * 来代替查询返回的字段列表，用 * 的好处是代码量少、就算是表结构或视图的列发生变化，编写的查询SQL语句也不用变，都返回所有的字段。但数据库服务器在解析时，如果碰到 *，则会先分析表的结构，然后把表的所有字段名再罗列出来。这就增加了分析的时间。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">4<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">慎用SELECT DISTINCT：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    DISTINCT</span><span style="background-color:inherit; font-family:宋体">子句仅在特定功能的时候使用，即从记录集中排除重复记录的时候。这是因为DISTINCT子句先获取结果集然后去重，这样增加SQLServer有用资源的使用。当然，如果你需要去做，那就只有去做了。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">当如果你知道SELECT语句将从不返回重复记录，那么使用DISTINCT语句对SQLServer资源不必要的浪费。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">5<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">少用游标：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">任何一种游标都会降低SQLServer性能。有些情况不能避免，大多数情况可以避免。所以如果你的应用程序目前正在使用TSQL游标，看看这些代码是否能够重写以避免它们。如果你需要一行一行的执行操作，考虑下边这些选项中的一个或多个来代替游标的使用：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">使用临时表</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">使用WHILE循环</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">使用派生表</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">使用相关子查询</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">使用CASE语句</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">使用多个查询</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">上面每一个都能取代游标并且执行更快。 如果你不能避免使用游标，至少试着提高它们的速度，找出加速游标的方法。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">6<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">选择最有效率的表名顺序：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    SQLSERVER</span><span style="background-color:inherit; font-family:宋体">的解析器按照从右到左的顺序处理FROM子句中的表名，因此FROM子句中写在最后的表（基础表driving table）将被最先处理，在FROM子句中包含多个表的情况下，必须选择记录条数最少的表作为基础表，当SQLSERVER处理多个表时，会运用排序及合并的方式连接它们。首先，扫描第一个表（FROM子句中最后的那个表)并对记录进行排序；然后扫描第二个表（FROM子句中最后第二个表)；最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">例如: 表 TAB1有 16384 条记录，表 TAB2 有5条记录，选择TAB2作为基础表 (最好的方法)：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">select count(*) from TAB1 a, TAB2 b</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">选择TAB1作为基础表 (不佳的方法)：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">select count(*) from TAB2 a, TAB1 b</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">7<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">使用表的别名(Alias)：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上，这样可以减少解析的时间并减少那些由Column歧义引起的语法错误。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">8<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">SARG</span><span style="background-color:inherit; font-family:宋体; font-size:14pt">你的WHERE条件：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    ARGE</span><span style="background-color:inherit; font-family:宋体">来源于"Search Argument"（搜索参数）的首字母拼成的"SARG"，它是指WHERE子句里，列和常量的比较。如果WHERE子句是sargable（可SARG的），这意味着它能利用索引加速查询的完成。如果WHERE子句不是可SARG的，这意味着WHERE子句不能利用索引（或至少部分不能利用），执行的是全表或索引扫描，这会引起查询的性能下降。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">在WHERE子句里不可SARG的搜索条件如"IS NULL", "&lt;&gt;", "!=", "!&gt;", "!&lt;", "NOT", "NOT EXISTS", "NOT IN", "NOT LIKE"和"LIKE '%500'"，通常（但不总是）会阻止查询优化器使用索引执行搜索。另外在列上使用包括函数的表达式、两边都使用相同列的表达式、或和一个列（不是常量）比较的表达式，都是不可SARG的。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">并不是每一个不可SARG的WHERE子句都注定要全表扫描。如果WHERE子句包括两个可SARG和一个不可SARG的子句，那么至少可SARG的子句能使用索引（如果存在的话）帮助快速访问数据。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">大多数情况下，如果表上有包括查询里所有SELECT、JOIN、WHERE子句用到的列的覆盖索引，那么覆盖索引能够代替全表扫描去返回查询的数据，即使它有不可SARG的WHERE子句。但记住覆盖索引尤其自身的缺陷，如此经常产生宽索引会增加读磁盘I/O。某些情况下，可以把不可SARG的WHERE子句重写成可SARG的子句。例如：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">WHERE SUBSTRING(firstname,1,1) = 'm'</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">可以写成：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">WHERE firstname like 'm%'</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">这两个WHERE子句有相同的结果，但第一个是不可SARG的（因为使用了函数）将运行得慢些，而第二个是可SARG的，将运行得快些。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">如果你不知道特定的WHERE子句是不是可SARG的，在查询分析器里检查查询执行计划。这样做，你能很快的知道查询是使用了索引还是全表扫描来返回的数据。仔细分析，许多不可SARG的查询能写成可SARG的查询。下面分几点讲解WHERE条件的SARG。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.1<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">WHERE</span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">子句中的连接顺序</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> SQLSERVER<span style="background-color:inherit; font-family:宋体">采用自下而上的顺序解析</span>WHERE<span style="background-color:inherit; font-family:宋体">子句，根据这个原理，表之间的连接必须写在其他</span>WHERE<span style="background-color:inherit; font-family:宋体">条件之前，那些可以过滤掉最大数量记录的条件必须写在</span>WHERE<span style="background-color:inherit; font-family:宋体">子句的末尾。例如：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> (<span style="background-color:inherit; font-family:宋体">低效</span>)</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> SELECT *  FROM EMP E</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> WHERE SAL &gt; 50000</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> AND JOB = ‘MANAGER’</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> AND 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR=E.EMPNO)</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px">  </p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> (<span style="background-color:inherit; font-family:宋体">高效</span>)</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> SELECT * FROM EMP E</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> WHERE 25 &lt; (SELECT COUNT(*) FROM EMP WHERE MGR=E.EMPNO)</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> AND SAL &gt; 50000</p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> AND JOB = ‘MANAGER’</p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.2<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">避免困难的正规表达式：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">MATCHES</span><span style="background-color:inherit; font-family:宋体">和LIKE关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时间。例如：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT * FROM customer WHERE zipcode LIKE "98_ _ _"</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">即使在zipcode字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如果把语句改为SELECT * FROM customer WHERE zipcode &gt;="98000"，在执行查询时就会利用索引来查询，显然会大大提高速度。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">另外，还要避免非开始的子串。例如语句：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT * FROM customer WHERE zipcode[2</span><span style="background-color:inherit; font-family:宋体">，3] &gt;"80"</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">在where子句中采用了非开始子串，因而这个语句也不会使用索引。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.3<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">避免对大型表行数据的顺序存取：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">在嵌套查询中，对表的顺序存取对查询效率可能产生致命的影响。比如采用顺序存取策略，一个嵌套3层的查询，如果每层都查询1000行，那么这个查询就要查询10亿行数据。避免这种情况的主要方法就是对连接的列进行索引。例如，两个表：学生表（学号、姓名、年龄……）和选课表（学号、课程号、成绩）。如果两个表要做连接，就要在“学号”这个连接字段上建立索引。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">还可以使用并集来避免顺序存取。尽管在所有的检查列上都有索引，但某些形式的where子句强迫优化器使用顺序存取。下面的查询将强迫对orders表执行顺序操作：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT * FROM orders WHERE (customer_num=104 AND order_num&gt;1001) OR order_num=1008</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">虽然在customer_num和order_num上建有索引，但是在上面的语句中优化器还是使用顺序存取路径扫描整个表。因为这个语句要检索的是分离的行的集合，所以应该改为如下语句：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT * FROM orders WHERE customer_num=104 AND order_num&gt;1001</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">UNION ALL</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT * FROM orders WHERE order_num=1008</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">这样就能利用索引路径处理查询。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.4<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">EXISTS</span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">和IN的使用：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">在许多基于基础表的查询中，为了满足一个条件，往往需要对另一个表进行联接。　　 在这种情况下，使用EXISTS(或NOT EXISTS)通常将提高查询的效率。在子查询中，NOT IN子句将执行一个内部的排序和合并。无论在哪种情况下，NOT IN都是最低效的，因为它对子查询中的表执行了一个全表遍历。为了避免使用NOT IN，我们可以把它改写成外连接(Outer Joins)或NOT EXISTS。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.5<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">避免在索引列上使用IS NULL和IS NOT NULL：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">避免在索引中使用任何可以为空的列，SQLSERVER将无法使用该索引。对于单列索引，如果列包含空值，索引中将不存在此记录；对于复合索引，如果每个列都为空，索引中同样不存在此记录。如果至少有一个列不为空，则记录存在于索引中。　　 </span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">　　如果唯一性索引建立在表的A列和B列上，并且表中存在一条记录的A,B值为(123,null)，SQLSERVER将不接受下一条具有相同A,B值（123,null）的记录插入。　　 </span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">　　如果所有的索引列都为空，SQLSERVER将认为整个键值为空，而空不可能等于空，因此你可以插入1000条具有相同键值的记录，当然它们都是空！因为空值不存在于索引列中，所以WHERE子句中对索引列进行空值比较将使SQLSERVER停用该索引。下面的代码将会很低效（索引失效）：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT </span><span style="background-color:inherit; font-family:宋体">… FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.6<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">避免在索引列上使用计算：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    WHERE</span><span style="background-color:inherit; font-family:宋体">子句中，如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描。　　 例如下面的语句低效 ：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT </span><span style="background-color:inherit; font-family:宋体">… FROM DEPT WHERE SAL * 12 &gt; 25000</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">而下面的语句将是高效的：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">SELECT </span><span style="background-color:inherit; font-family:宋体">… FROM DEPT WHERE SAL &gt; 25000/12</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">请务必注意，查询中不要对索引列进行处理，如：TRIM，substring，convert等等操作。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">8.7<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">       </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">用WHERE子句替换HAVING子句：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit"><span style="background-color:inherit; font-family:宋体">    </span></span><span style="background-color:inherit; font-family:宋体">避免使用HAVING子句，HAVING只会在检索出所有记录之后才对结果集进行过滤，这个处理需要排序、统计等操作。如果能通过WHERE子句限制记录的数目，那就能减少这方面的开销。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">9<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">避免或简化排序：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">应当简化或避免对大型表进行重复的排序。当能够利用索引自动以适当的次序产生输出时，优化器就避免了排序的步骤。以下是一些影响因素：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">索引中不包括一个或几个待排序的列；</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">group by</span><span style="background-color:inherit; font-family:宋体">或order by子句中列的次序与索引的次序不一样；</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">排序的列来自不同的表。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">为了避免不必要的排序，就要正确地增建索引，合理地合并数据库表（尽管有时可能影响表的规范化，但相对于效率的提高是值得的）。如果排序不可避免，那么应当试图简化它，如缩小排序的列的范围等。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">10<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">    </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">临时表的使用：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; color:black; font-family:宋体">临时表有很多特殊的用途，象用来替代游标，不过它们仍能引起性能问题，如果这个问题能消除，SQLServer将执行得更快。在永久表和临时表的数据行相同的条件下，使用临时表没有永久表快。但有时还必须得使用临时表，如先从存储大量数据的永久表中提取符全条件的存放到临时表，然后在临时表上执行操作。如果是直接在存储大量数据的永久表上执行操作（如：统计、循环等），其性能将大打折扣。所以，使不使用临时表，何时使用临时表，需要具体情况决定。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">11<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">    </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">是否使用视图：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">视图最大的用途是处理安全相关的问题，而不是一些懒惰的开发人员用来存储经常使用的查询的方法。例如，如果你需要允许用户访问特定SQLServer的数据，那么你也许可以考虑为用户（或组）创建一个视图，然后给用户访问视图而不是基表的权限。另一方面，在应用程序里，从视图选择数据没有好的理由，相反，绕过视图直接从需要的表里获取数据。原因是许多视图（当然不是全部）返回比SELECT语句所需更多的数据，增加不必要的开销。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">例如，假定有一个视图从两个连接表里返回10列。你想要从视图里使用SELECT语句返回其中7列。实际上发生的情况是基于视图的查询先运行，返回数据，然后你的查询针对这些数据运行。既然你仅需要7列，而不是视图返回的10列，更多不必要的数据被返回。浪费SQLServer的资源。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">长久以来，大家在争论是查询视图速度快还是直接查询快，本人也不敢轻易下结论，因此作了多次试验，其结果是：基于视图查询，性能确实不会比直接写查询语句快，对于简单的查询，最多是在同一水平上。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">当然，上面的测试是在没有为视图创建索引的情况下，SQLServer2000以上可以为视图创建索引，视图索引与表的索引在作用方式上非常相似。与表一样，视图可以有一个集簇索引（clustered index）和多个非集簇索引。创建视图索引后能够提高视图的性能。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">如果视图不包含索引，则数据库中不保存视图返回的结果集。有的时候，我们可能要创建涉及大量记录或必须进行复杂计算的视图，比如要进行聚合分组处理或多重连接操作。如果每次引用这些视图的时候让sql server重新生成结果集，数据库开销将非常大。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">12<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">    </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">让事务尽可能的短：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">保持TSQL事务尽可能的短。这会帮助减少锁（所有类型的锁）的数量，有助于全面提升SQLServer的性能。如果有经验，你也许要将长事务分成更小的事务组。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">13<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">    </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">用存储过程代替直接写查询语句：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">存储过程为开发人员提供了很多好处，包括：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">减少网络流量和响应时间，提升应用程序性能。例如，通过网络发送一个存储过程调用，而不是发送500行的TSQL将更快，资源使用更少。当每次执行SQL时，都会执行解析SQL语句、估算索引的利用率、绑定变量、读数据块等等工作。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">存储过程执行计划能够重用，驻留在SQLServer内存的缓存里，减少服务器开销。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">客户端执行请求更有效率。例如，如果应用程序需要插入大量的二进制值到一个image数据列而不使用存储过程，它必须转化二进制为字符串（大小会增加一倍），然后发送给SQLServer。当SQLServer接收到后，它必须把字符串值转回二进制格式。大量的浪费开销。存储过程能消除这个问题通过将应用程序传给SQLServer的二进制格式作为参数，从而减少开销提升性能。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">存储过程帮助提供代码重用。虽然这些不直接提升应用程序的性能，通过减少代码量和减少调试时间来提升开发人员的效率。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">存储过程能封装逻辑。你能够改变存储过程代码而不影响客户端（假定你保持参数相同也不移除任何结果集的列）。这节约开发人员的时间。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">存储过程为你的数据提供更好的安全性。如果你仅使用存储过程，你可以移除直接对表的SELECT、INSERT、UPDATE和DELETE权限从而强迫开发人员使用存储过程访问数据。这会节约DBA的时间。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:Wingdings">n<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">作为首要的常规，所有的TSQL代码都应该通过存储过程调用。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">13.1<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">   </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">存储过程名不要以 sp_ 开头：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">对这一准则，可能很多人会感觉纳闷，是的，我开始也纳闷过。如果创建的存储过程不是运行在Master数据库里，不要使用以sp_为前缀的名称。这个特别的前缀是为系统存储过程保留的。尽管使用这个前缀不会禁止用户定义的存储过程的运行，但会稍微降低一些执行效率。这是因为SQLServer在执行以sp_为前缀的任何一个存储过程时缺省地首先试图在Master数据库里寻找，尽管那儿没有，这就浪费了寻找存储过程的时间。如果SQLServer在Master数据库里不能找到存储过程，那么接下来会将存储过程的拥有者作为DBO去解析。如果存储过程在目前的数据库里，那么它会执行。为了避免不必要的延迟，不要用前缀为sp_命名你的任何一个存储过程。</span></p> 
<h3 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:21px"> <span style="background-color:inherit; font-family:宋体; font-size:10.5pt">13.2<span style="background-color:inherit; font-weight:normal; font-size:7pt; font-family:'Times New Roman'">   </span></span><span style="background-color:inherit; font-family:宋体; font-size:10.5pt">存储过程的拥有者要相同：</span></h3> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">为了最好的性能，同一个存储过程里调用的所有对象的拥有者都应该相同，DBO更适宜。如果不是那样，即对象名相同而拥有者不同，那么SQLServer必须执行名称判断。当发生这样的情形时，SQLServer不能使用存储过程里在内存里的执行计划，相反，它必须重新编译存储过程，从而影响性能。当从应用程序里调用存储过程时，使用分隔符名称来调用也是重要的。如：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">EXEC dbo.myProcedure</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">代替：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">        EXEC myProcedure</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">这样做有两个原因，其中一个和性能有关。首先，使用完全有分隔符的名称有助于消除那些和你要运行的存储过程有潜在的混淆，有助于禁止BUG和潜在的问题。但更重要的是，这样做SQLServer能更直接的访问存储过程执行计划，而不是轮流访问，从而加速了存储过程的性能。当然性能提升很小，但如果你的服务器每小时要运行成千上万或更多的存储过程，这些节约的小段时间加起来就很可观了。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">14<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">    </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">完整性使用下的约束和触发器：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">    </span><span style="background-color:inherit; font-family:宋体">数据库里不要执行多余的完整性特点。例如，如果你正使用主键和外键约束来强迫引用完整性，则不要添加触发器来实现相同的功能而增加不必要的开销。同样既使用约束又使用默认值或既使用约束又使用规则也会执行多余的工作。</span></p> 
<h2 style="color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; line-height:21px; font-size:14px; font-weight:normal"> <span style="background-color:inherit; font-family:宋体; font-size:14pt">15<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">    </span></span><span style="background-color:inherit; font-family:宋体; font-size:14pt">在SQL中捕捉异常：</span></h2> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">这一条准则应该不能算是优化方面的，只是编写要求。现在</span>SQLServer2005<span style="background-color:inherit; font-family:宋体">中，新增了</span>BEGIN TRY…END TRY<span style="background-color:inherit; font-family:宋体">和</span> BEGIN CATCH…END CATCH<span style="background-color:inherit; font-family:宋体">二个成对语句，用于捕捉运行时出现的异常。在</span>Oracle<span style="background-color:inherit; font-family:宋体">中，可用</span> BEGIN…EXCEPTION…END <span style="background-color:inherit; font-family:宋体">语句捕捉异常。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">把</span>SQL<span style="background-color:inherit; font-family:宋体">代码块中加入捕捉异常的语句内，有二个好处：一是可以在</span>SQL<span style="background-color:inherit; font-family:宋体">语句内部得到异常并作错误处理，如在错误代码块内返回自定义错误信息、</span>ROLBACK<span style="background-color:inherit; font-family:宋体">等。这样可减少应用程序捕捉异常带来的资源开销；另外一个好处就是可以防止死锁情况的发生，当出现死锁时，</span>SQLServer2005<span style="background-color:inherit; font-family:宋体">会抛出异常，我们就可捕捉到。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px">  </p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px">  </p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; font-family:宋体">下面列出一些索引的概念，有助于设计表结构和编写</span>SQL<span style="background-color:inherit; font-family:宋体">语句：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:宋体">按照存储规则来分：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; color:black; font-family:宋体">聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。因此一个表只能包含一个聚集索引，但该索引可以包含多个列（组合索引）。检索效率比普通索引高，但对数据新增</span><span style="background-color:inherit; color:black">/</span><span style="background-color:inherit; color:black; font-family:宋体">修改</span><span style="background-color:inherit; color:black">/</span><span style="background-color:inherit; color:black; font-family:宋体">删除的影响比较大。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; color:black; font-family:宋体">非聚集索引：与聚集索引相对，不影响表中的数据存储顺序，检索效率比聚集索引低，对数据新增</span><span style="background-color:inherit; color:black">/</span><span style="background-color:inherit; color:black; font-family:宋体">修改</span><span style="background-color:inherit; color:black">/</span><span style="background-color:inherit; color:black; font-family:宋体">删除的影响很少。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:宋体">按照维护与管理的角度来分：</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; color:black; font-family:宋体">唯一索引：惟一索引可以确保索引列不包含重复的值，可以用多个列，但是索引可以确保索引列中每个值组合都是唯一的。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; font-family:宋体">主键索引：在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; color:black; font-family:宋体">普通索引：由关键字</span><span style="background-color:inherit; color:black">KEY</span><span style="background-color:inherit; color:black; font-family:宋体">或</span><span style="background-color:inherit; color:black">INDEX</span><span style="background-color:inherit; color:black; font-family:宋体">定义的索引，唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件或排序条件中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列</span><span style="background-color:inherit; color:black">(</span><span style="background-color:inherit; color:black; font-family:宋体">如整数类型的数据列</span><span style="background-color:inherit; color:black">)</span><span style="background-color:inherit; color:black; font-family:宋体">来创建索引。允许有重复的列存在。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:Wingdings">l<span style="background-color:inherit; font-size:7pt; font-family:'Times New Roman'">         </span></span><span style="background-color:inherit; color:black; font-family:宋体">复合索引：如果在两上以上的列上创建的索引，则称为复合索引。</span></p> 
<p style="margin-top:5px; margin-bottom:5px; color:rgb(57,57,57); font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:21px"> <span style="background-color:inherit; color:black; font-family:宋体">原文地址:<a target="_blank" href="http://www.cnblogs.com/Joshualang/archive/2009/05/14/1456563.html" rel="nofollow noopener noreferrer" style="background-color:inherit; color:rgb(100,102,179)">http://www.cnblogs.com/Joshualang/archive/2009/05/14/1456563.html</a></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d4b931d7b757fc978e51d7bbd025d0d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">让lager的日志文件按日期滚动起来</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55c2d504ab5242c46f28502b30fa6105/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vs.net打包自动检测环境并安装.net framework</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>