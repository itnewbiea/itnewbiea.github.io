<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Feign，模块之间调用传递参数HttpServletRequest request拿不到值问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Feign，模块之间调用传递参数HttpServletRequest request拿不到值问题" />
<meta property="og:description" content="问题描述：
spring boot 项目，多模块之间使用Feign调用，请求方的request对象在传递的过程中丢失，服务方request对象中没有相应值。
初始状态：
feign接口
@PostMapping(&#34;/xxxx&#34;)
@ApiOperation(value = &#34;xxxx&#34;, notes = xxxx&#34;)
RestResult&lt;JSONObject&gt; testFeign() throws Exception;
实现：
@PostMapping(&#34;/xxxx&#34;)
@ApiOperation(value = &#34;xxxx&#34;, notes = xxxx&#34;)
@Transactional(rollbackFor = Exception.class)
public RestResult&lt;JSONObject&gt; testFeign(@Autowired HttpServletRequest request) throws Exception{
}
调用：
feignClient.testFeign();
结果：
request中没有请求头中没有相应数据。
解决过程：
尝试修改参数注解，在feign接口中增加参数。依然拿不到。
解决方案：
修改feign配置
public class NativeFeignConfig { @Bean public RequestInterceptor getRequestInterceptor() { return new RequestInterceptor() { @Override public void apply(RequestTemplate requestTemplate) { ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes(); HttpServletRequest req = servletRequestAttributes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f2c733d918b4b2455453fc34e07c9b9e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-16T17:41:12+08:00" />
<meta property="article:modified_time" content="2020-12-16T17:41:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Feign，模块之间调用传递参数HttpServletRequest request拿不到值问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>问题描述：</strong></p> 
<p>       spring boot 项目，多模块之间使用Feign调用，请求方的request对象在传递的过程中丢失，服务方request对象中没有相应值。</p> 
<p><strong>初始状态：</strong></p> 
<p style="text-indent:33px;">feign接口</p> 
<p style="text-indent:33px;">@PostMapping("/xxxx")<br>        @ApiOperation(value = "xxxx", notes = xxxx")<br>        RestResult&lt;JSONObject&gt; testFeign() throws Exception;</p> 
<p style="text-indent:33px;">实现：</p> 
<p style="text-indent:33px;">@PostMapping("/xxxx")<br>        @ApiOperation(value = "xxxx", notes = xxxx")<br>        @Transactional(rollbackFor = Exception.class)<br>        public RestResult&lt;JSONObject&gt; testFeign(@Autowired HttpServletRequest request) throws Exception{<!-- --><br>        }</p> 
<p style="text-indent:33px;">调用：</p> 
<p style="text-indent:33px;">feignClient.testFeign();</p> 
<p style="text-indent:33px;">结果：</p> 
<p style="text-indent:33px;">request中没有请求头中没有相应数据。</p> 
<p style="text-indent:0;"><strong>解决过程：</strong></p> 
<p style="text-indent:33px;">尝试修改参数注解，在feign接口中增加参数。依然拿不到。</p> 
<p style="text-indent:0;"><strong>解决方案：</strong></p> 
<p style="text-indent:33px;">修改feign配置</p> 
<pre>public class NativeFeignConfig {
    @Bean
    public RequestInterceptor getRequestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate requestTemplate) {
                ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();
                HttpServletRequest req = servletRequestAttributes.getRequest();
                Map&lt;String, Collection&lt;String&gt;&gt; headerMap = new HashMap();
                //获取你需要传递的头信息
                String userId = req.getHeader(SessionConst.KEY_USER_ID);
                String userName = req.getHeader(SessionConst.KEY_USER_NAME);
                String token = req.getHeader(SessionConst.KEY_TOKEN);
                String systemRole = req.getHeader(SessionConst.KEY_USER_SYSTEMROLE_ID);
                headerMap.put(SessionConst.KEY_USER_ID, Arrays.asList(userId));
                headerMap.put(SessionConst.KEY_USER_NAME, Arrays.asList(userName));
                headerMap.put(SessionConst.KEY_TOKEN, Arrays.asList(token));
                headerMap.put(SessionConst.KEY_USER_SYSTEMROLE_ID, Arrays.asList(systemRole));
                //feign请求时，便可携带上该信息
                requestTemplate.headers(headerMap);
            }
        };
    }
}</pre> 
<pre>注：创建一个自定义的hystrix 线程策略, 将servletRequestAttributes传入新线程中，并赋给RequestContextHolder:

public class MyHystrixConcurrencyStrategy extends HystrixConcurrencyStrategy {
    @Override
    public &lt;T&gt; Callable&lt;T&gt; wrapCallable(Callable&lt;T&gt; callable){
        ServletRequestAttributes servletRequestAttributes=(ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        return new Callable&lt;T&gt;() {
            @Override
            public T call() throws Exception {
                try {
                    if (null != servletRequestAttributes) {
                        RequestContextHolder.setRequestAttributes(servletRequestAttributes);
                    }
                    return callable.call();
                }finally {
                    RequestContextHolder.resetRequestAttributes();
                }
            }
        };
    }
}
</pre> 
<pre>@Configuration
public class HystrixConfig {
    @PostConstruct
    public void init(){
        HystrixPlugins.getInstance().registerConcurrencyStrategy(
                new MyHystrixConcurrencyStrategy()
        );
    }
}</pre> 
<p>在feign接口类中的注解上增加 ：configuration= NativeFeignConfig.class</p> 
<pre>@FeignClient(value = "xxxx",configuration= NativeFeignConfig.class)</pre> 
<p><strong>问题原因：</strong></p> 
<p style="text-indent:33px;">开启hystrix后，feign请求，会运行在hystrix管理的另一线程下。也就是说从请求方模块发送到服务方的请求参数可以正常传递，但是HttpServletRequest request对象并没有正常传递，从一个线程到另一个线程中时，request并没有跟随一起。需要手工组装request请求中的值。</p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;"> </p> 
<p style="text-indent:33px;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e8e185390a14a1c793176b190819932/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【点云PCL入门】点云滤波</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6390b4388530990168ed921538d3801/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">卷积神经网络系列之卷积/池化后特征图大小怎么计算？？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>