<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>信号量（Semaphore）与线程计数器（CountDownLatch） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="信号量（Semaphore）与线程计数器（CountDownLatch）" />
<meta property="og:description" content="目录
🍉信号量（Semaphore）
🥭线程计数器（CountDownLatch）
🍉信号量（Semaphore） Semaphore属于共享锁，即多个线程可以同时获取，用来表示可用资源的个数，本质上是一个计数器
🥩理解信号量：
🍂我们将信号量理解为一个停车场的空车位，例如当前有100个空车位，表示100个可用资源
🍂当有车开进停车场，就相当于申请一个可用资源，空车位就-1（这个称为信号量的P操作）
🍂当有车开出停车场，就相当于释放一个可用资源，空车位就&#43;1（这个称为信号量的V操作）
🍂如果可用资源为0，会尝试申请资源，就会阻塞等待，直到有其他线程释放资源
🥩注意：Semaphore的PV操作的加减计数器操作都是原子性的，可以直接在多线程环境下使用
🍡Semaphore的构造方法：
🍭Semaphore的常用方法：
🍢使用场景：
☘️等待一组线程执行完，再执行某个任务
☘️同一个时间最多执行n个线程（有限资源的使用）
🍴示例：
创建Semaphore实例，初始化为4，表示4个可用资源
acquire方法表示申请资源（P操作），release方法表示释放资源（V操作）
创建20个线程，每个线程都尝试申请资源，sleep等待1秒后，释放资源，观察程序执行结果
👁‍🗨️代码展示：
import java.util.concurrent.Semaphore; public class SemaphoreTest { public static void main(String[] args) { Semaphore sem = new Semaphore(4); Runnable runnable = new Runnable() { @Override public void run() { try { System.out.println(&#34;申请资源&#34;); sem.acquire(); System.out.println(&#34;获取到资源&#34;); Thread.sleep(1000); sem.release(); System.out.println(&#34;释放资源&#34;); } catch (InterruptedException e) { e.printStackTrace(); } } }; for(int i = 0;i &lt; 20;i&#43;&#43;){ Thread t = new Thread(runnable); t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/37390f8cbc6aa3a5af85aafad49ab99f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-09T21:53:20+08:00" />
<meta property="article:modified_time" content="2022-04-09T21:53:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">信号量（Semaphore）与线程计数器（CountDownLatch）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8D%8D%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89-toc" style="margin-left:0px;"><a href="#%F0%9F%8D%8D%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89" rel="nofollow">🍉信号量（Semaphore）</a></p> 
<p id="%F0%9F%A5%AD%E7%BA%BF%E7%A8%8B%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88CountDownLatch%EF%BC%89-toc" style="margin-left:0px;"><a href="#%F0%9F%A5%AD%E7%BA%BF%E7%A8%8B%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88CountDownLatch%EF%BC%89" rel="nofollow">🥭线程计数器（CountDownLatch）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>🍉信号量（Semaphore）</h2> 
<p><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">Semaphore属于共享锁</span></span>，即多个线程可以同时获取，用来<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">表示可用资源的个数</span></span>，本质上是一个<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">计数器</span></span></p> 
<p><strong>🥩理解信号量：</strong></p> 
<blockquote> 
 <p>🍂我们将信号量理解为一个停车场的空车位，例如当前有100个空车位，表示100个可用资源<br> 🍂当有车开进停车场，就相当于<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">申请一个可用资源</span></span>，<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">空车位就-1</span></span>（这个称为信号量的<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">P操作</span></span>）<br> 🍂当有车开出停车场，就相当于<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">释放一个可用资源</span></span>，<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">空车位就+1</span></span>（这个称为信号量的<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">V操作</span></span>）<br> 🍂如果<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">可用资源为0</span></span>，会尝试申请资源，就会<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">阻塞等待</span></span>，直到有其他线程释放资源</p> 
</blockquote> 
<blockquote> 
 <p><strong>🥩注意：</strong>Semaphore的<span style="color:#fe2c24;"><span style="background-color:#d4e9d5;">PV操作</span></span>的加减计数器操作都是<span style="color:#fe2c24;"><span style="background-color:#d4e9d5;">原子性</span></span>的，可以直接在多线程环境下使用</p> 
</blockquote> 
<p><strong>🍡Semaphore的构造方法：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ca/89/OIpwrt1V_o.jpg"></p> 
<p><strong>🍭Semaphore的常用方法：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8b/f5/Lty5o3De_o.jpg"></p> 
<p><strong>🍢使用场景：</strong></p> 
<blockquote> 
 <p>☘️等待一组线程执行完，再执行某个任务<br> ☘️同一个时间最多执行n个线程（<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">有限资源的使用</span></span>）</p> 
</blockquote> 
<p><strong>🍴示例：</strong></p> 
<blockquote> 
 <p>创建Semaphore实例，初始化为4，表示4个可用资源<br> acquire方法表示申请资源（P操作），release方法表示释放资源（V操作）<br> 创建20个线程，每个线程都尝试申请资源，sleep等待1秒后，释放资源，观察程序执行结果</p> 
</blockquote> 
<p><strong>👁‍🗨️代码展示：</strong></p> 
<pre><code class="language-java">import java.util.concurrent.Semaphore;

public class SemaphoreTest {
    public static void main(String[] args) {
        Semaphore sem = new Semaphore(4);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                try {
                    System.out.println("申请资源");
                    sem.acquire();
                    System.out.println("获取到资源");
                    Thread.sleep(1000);
                    sem.release();
                    System.out.println("释放资源");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        for(int i = 0;i &lt; 20;i++){
            Thread t = new Thread(runnable);
            t.start();
        }
    }
}
</code></pre> 
<p><strong>👁‍🗨️打印结果说明：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b5/28/9wObtA26_o.jpg"></p> 
<h2 id="%F0%9F%A5%AD%E7%BA%BF%E7%A8%8B%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88CountDownLatch%EF%BC%89">🥭线程计数器（CountDownLatch）</h2> 
<p><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">CountDownLatch也属于共享锁</span></span>，其内部有一个<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">int类型的属性</span></span>表示可以同时<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">并发并行的线程的数量</span></span> <br><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">同时等待N个任务执行结束</span></span></p> 
<blockquote> 
 <p><strong>举例说明：</strong></p> 
 <p>比如跑步比赛，必须等所有运动员通过终点才能公布成绩</p> 
</blockquote> 
<p><strong>🍭CountDownLatch的构造方法：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dc/8d/ImwXMKQb_o.jpg"></p> 
<p><strong>🍡CountDownLatch的常用方法：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/ca/Q5XXXHxM_o.jpg"></p> 
<blockquote> 
 <p><strong>🥩使用场景：</strong>等待多个线程全部执行完，再执行某个任务</p> 
</blockquote> 
<blockquote> 
 <p><strong>🥩注意：</strong><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">CountDownLatch</span><span style="background-color:#98c091;">只能减</span><span style="background-color:#f9eda6;">不能加 </span></span></p> 
</blockquote> 
<p><strong>🍴示例：</strong></p> 
<blockquote> 
 <p>构造CountDownLatch实例，初始化为10，表示有10个任务需要完成<br> 每个任务执行完成后，调用countDown()，CountDownLatch内部计数器自减<br> 主线程调用await(),等待所有线程执行完毕，也就是计数器值为0，再继续执行主线程后续任务</p> 
</blockquote> 
<p>👁‍🗨️<strong>代码展示：</strong></p> 
<pre><code class="language-java">import java.util.concurrent.CountDownLatch;

public class CountDownLatchTest {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(10);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
                latch.countDown();
            }
        };
        for(int i = 0;i &lt; 10;i++){
            Thread t = new Thread(runnable);
            t.start();
        }
        latch.await();
        System.out.println("10个线程比赛结束");
    }
}
</code></pre> 
<p><strong>👁‍🗨️打印结果说明：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/0d/pzucGUQT_o.jpg"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/536d68075bdbce3e008745acd38c83d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">uniapp小程序父组件与子组件之间调用方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/daffbe7329e3317d859d2ff79c9904d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iframe嵌入页面之Cookies存取</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>