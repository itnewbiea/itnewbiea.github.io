<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端（二十四）——轮询与 WebSocket的battle - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端（二十四）——轮询与 WebSocket的battle" />
<meta property="og:description" content="😃博主：小猫娃来啦
😃文章核心：轮询与 WebSocket的battle
文章目录 前言轮询的原理及实现WebSocket的原理及实现轮询与WebSocket的比较轮询的应用场景WebSocket的应用场景使用场景的对比与选择WebSocket的安全性考虑WebSocket与服务器端推送技术的比较 前言 在现代Web应用中，实时通信已经成为用户体验的重要组成部分。实时通信指的是通过网站或应用程序实时传输数据并保持连接，在无需手动刷新页面的情况下更新内容。轮询和WebSocket都是用于现实时通信的技术。今天我们来对比一下这两种实现方式，看看到底哪个好。
轮询的原理及实现 什么是轮询
轮询是一种客户端不断向服务器发送请求以获取更新的数据的方式。客户端定期（通常使用定时器）向服务器发送请求，不管服务器是否有新数据。如果服务器没有更新，服务器返回空或者相同的响；如果有新数据，服务器会返回最新的数据。
轮询的工作原理
轮询的工作原理很简单。客户端发起请求，服务器检查是否有新数据。如果有，服务器返回数据；如果没有，服务器等待一段时间，然后返回空响应。客户端接收到响应后，再次发起请求，继续这个过程。
轮询的实现方式
轮询有两种常见的实现方式：定时轮询和递归轮询。定时轮询是设置一个固定的时间隔，每隔一段时间就发送一次请求；递归轮询是在每次请求的回调函数中再次发送请求。
以下是一个使用JavaScript的定时轮询示例：
function pollServer() { fetch(&#39;/api/data&#39;) .then(response =&gt; response.json()) .then(data =&gt; { // 处理服务器响应的数据 console.log(&#39;Received data:&#39;, data); // 继续下一次轮询 setTimeout(pollServer, 5000); }); } // 开始轮询 pollServer(); WebSocket的原理及实现 什么是WebSocket
WebSocket是一种全双工、持久化的通信协议，可以在客户端和服务器之间建立实时的双向通信。与传统的HTTP请求-响应模型不同，WebSocket允许服务器主动向客户端推送数据，而不需要客户端不断发送请求。
WebSocket的工作原理
WebSocket的工作原理基于HTTP协议的升级。客户端向服务器发送一个特殊的Upgrade请求头，服务器收到请求后，如果支持WebSocket协议，将响应101 Switching Protocols，并将连接升级为全双工通信的WebSocket连接。之后，服务器和客户端都可以通过这个连接进行实时的双向通信。
WebSocket的实现方式
在前端，你可以使用WebSocket API与服务器建立WebSocket连接，并通过发送和接收消息来实现实时通信。在服务器端，你需要使用相应的后端框架或库来处理WebSocket连接和消息。
以下是一个使用JavaScript的WebSocket示例：
const socket = new WebSocket(&#39;ws://example.com/socket&#39;); socket.onopen = function() { console.log(&#39;WebSocket connection established.&#39;); }; socket.onmessage = function(event) { const data = event." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8d1780ae7d809c095e082e7fe67edfea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-26T06:15:00+08:00" />
<meta property="article:modified_time" content="2023-10-26T06:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端（二十四）——轮询与 WebSocket的battle</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/2c/df/TvJ2ZU4L_o.gif" alt="在这里插入图片描述"><br> 😃博主：小猫娃来啦<br> 😃文章核心：<strong>轮询与 WebSocket的battle</strong></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_5" rel="nofollow">前言</a></li><li><a href="#_9" rel="nofollow">轮询的原理及实现</a></li><li><a href="#WebSocket_39" rel="nofollow">WebSocket的原理及实现</a></li><li><a href="#WebSocket_76" rel="nofollow">轮询与WebSocket的比较</a></li><li><a href="#_93" rel="nofollow">轮询的应用场景</a></li><li><a href="#WebSocket_109" rel="nofollow">WebSocket的应用场景</a></li><li><a href="#_124" rel="nofollow">使用场景的对比与选择</a></li><li><a href="#WebSocket_137" rel="nofollow">WebSocket的安全性考虑</a></li><li><a href="#WebSocket_149" rel="nofollow">WebSocket与服务器端推送技术的比较</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_5"></a>前言</h2> 
<p>在现代Web应用中，实时通信已经成为用户体验的重要组成部分。实时通信指的是通过网站或应用程序实时传输数据并保持连接，在无需手动刷新页面的情况下更新内容。轮询和WebSocket都是用于现实时通信的技术。今天我们来对比一下这两种实现方式，看看到底哪个好。</p> 
<hr> 
<h2><a id="_9"></a>轮询的原理及实现</h2> 
<p><mark>什么是轮询</mark><br> 轮询是一种客户端不断向服务器发送请求以获取更新的数据的方式。客户端定期（通常使用定时器）向服务器发送请求，不管服务器是否有新数据。如果服务器没有更新，服务器返回空或者相同的响；如果有新数据，服务器会返回最新的数据。</p> 
<p><mark>轮询的工作原理</mark><br> 轮询的工作原理很简单。客户端发起请求，服务器检查是否有新数据。如果有，服务器返回数据；如果没有，服务器等待一段时间，然后返回空响应。客户端接收到响应后，再次发起请求，继续这个过程。</p> 
<p><mark>轮询的实现方式</mark><br> 轮询有两种常见的实现方式：定时轮询和递归轮询。定时轮询是设置一个固定的时间隔，每隔一段时间就发送一次请求；递归轮询是在每次请求的回调函数中再次发送请求。</p> 
<p>以下是一个使用JavaScript的定时轮询示例：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">pollServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/api/data'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 处理服务器响应的数据</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received data:'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
      <span class="token comment">// 继续下一次轮询</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>pollServer<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 开始轮询</span>
<span class="token function">pollServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h2><a id="WebSocket_39"></a>WebSocket的原理及实现</h2> 
<p><mark>什么是WebSocket</mark><br> WebSocket是一种全双工、持久化的通信协议，可以在客户端和服务器之间建立实时的双向通信。与传统的HTTP请求-响应模型不同，WebSocket允许服务器主动向客户端推送数据，而不需要客户端不断发送请求。</p> 
<p><mark>WebSocket的工作原理</mark><br> WebSocket的工作原理基于HTTP协议的升级。客户端向服务器发送一个特殊的Upgrade请求头，服务器收到请求后，如果支持WebSocket协议，将响应101 Switching Protocols，并将连接升级为全双工通信的WebSocket连接。之后，服务器和客户端都可以通过这个连接进行实时的双向通信。</p> 
<p><mark>WebSocket的实现方式</mark><br> 在前端，你可以使用WebSocket API与服务器建立WebSocket连接，并通过发送和接收消息来实现实时通信。在服务器端，你需要使用相应的后端框架或库来处理WebSocket连接和消息。</p> 
<p>以下是一个使用JavaScript的WebSocket示例：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://example.com/socket'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

socket<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'WebSocket connection established.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

socket<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token comment">// 处理收到的数据</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received data:'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

socket<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'WebSocket error:'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

socket<span class="token punctuation">.</span><span class="token function-variable function">onclose</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'WebSocket connection closed.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>以上代码示例中，我们创建了一个WebSocket对象，并通过监听事件来处理连接的建立、收到的数据、错误和连接关闭。</p> 
<hr> 
<h2><a id="WebSocket_76"></a>轮询与WebSocket的比较</h2> 
<p><mark>性能比较</mark><br> 性能方面，WebSocket比轮询具有明显的优势。因为WebSocket使用持久化连接，不需要在每个请求中发送额外的头信息，减少了网络传输的开销。相比之下，轮询需要频繁地发送请求和接收响应，增加了不必要的网络流量。</p> 
<p><mark>实时性比较</mark><br> WebSocket是一种实时双向通信协议，可以在服务器端有新数据时立即将其推送给客户端，实现实时更新。轮询依赖于定时发送请求，无法实时地获取到最新的数据，存在一定的延迟。</p> 
<p><mark>扩展性比较</mark><br> 由于WebSocket使用全双工通信，服务器可以主动向客户端推送数据，这使得WebSocket在处理大规模用户和实时数据推送场景中更具扩展性。轮询在大规模用户时会增加服务器的负载。</p> 
<p><mark>兼容性比较</mark><br> WebSocket在现代浏览器中得到了广泛支持，包括最新版本的桌面和移动浏览器。然而，对于一些旧版浏览器，特别是IE系列的浏览器，可能不支持或提供低的兼容性。轮询可以在几乎所有的浏览器中工作，但存在性能和效率的问题。</p> 
<p><mark>开发复杂度比较</mark><br> WebSocket在实现时相对复杂，需要在前端和后端分别实现相应的逻辑和处理器。而轮询的实现相对简单，只需在前端设置定时器和后端处理请求。因，如果项目对开发时间有限制或者开发资源有限，轮询可能是更简单的解决方案。</p> 
<hr> 
<h2><a id="_93"></a>轮询的应用场景</h2> 
<p><mark>实时聊天应用</mark><br> 轮询可以用于实现简单的即时聊天应用。前端定时向服务器发送请求获取最新的消息，实现简单的消息推送功能。</p> 
<p><mark>在线游戏应用</mark><br> 对于一些简单的在线游戏应用，轮询可以用于更新玩家之间的动态，例如玩家位置、分数等信息。</p> 
<p><mark>股票市场行情显示</mark><br> 在股票市场中，轮询可以用于获取最新的股票行情数据，并在页面上实时展示股票价格的变动。</p> 
<p><mark>其他实时数据展示应用</mark><br> 对于需要实时展示数据的应用，例如实时天气预报、实时交通状况，轮询可以用于获取最新的数据并实时更新展示。</p> 
<hr> 
<h2><a id="WebSocket_109"></a>WebSocket的应用场景</h2> 
<p><mark>实时数据推送应用</mark><br> WebSocket最适合于需要实时推送大量数据的应用场景，例如时股票市场行情、实时新闻推送等。通过建立持久的WebSocket连接，服务器可以主动向客户端推送实时数据，而不需要客户端发起请求。</p> 
<p><mark>即时协作应用</mark><br> 对于需要多人实时协作的应用，例如团协作编辑、在线白板等，WebSocket能够实现高效的实时通信，使得个用户之间可以实时共享信息和进行协作操作。</p> 
<p><mark>多人在线游戏应用</mark><br> WebSocket可以用于构建多人在线游戏应用，玩家之间可以实时交互、共享游戏状态和进行实时的游戏操作。</p> 
<p><mark>其他需要实时双向通信的应用</mark><br> WebSocket适用于任何需要实时双向通信的应用场景，例如实时聊天应用、实时客服系统、实时推送通知等。</p> 
<hr> 
<h2><a id="_124"></a>使用场景的对比与选择</h2> 
<p>当选择轮询还是WebSocket时，需要根据具体的需求来决定。以下是一些考虑因素：</p> 
<ul><li>实时性需求：如果应用需要实时更新，能够快速推送数据给客户端，WebSocket是更好的选择。</li><li>性能要求：如果应用需要高性的实时通信，并且可以扩展到大量用户，WebSocket是更合适的方案。</li><li>兼容性要求：如果应用需要支持各种浏览器，尤其是旧版浏览器，轮询可能是更可靠的解决方案。</li><li>开发难度与成本：WebSocket的实现相对复杂，涉及到前端和后端的开发，而轮询的实现相对简单。</li></ul> 
<p>根据对这些因素的权衡，可以选择最适合应用需求的方案。</p> 
<hr> 
<h2><a id="WebSocket_137"></a>WebSocket的安全性考虑</h2> 
<p>在使用WebSocket时，需要考虑一些安全性方面的问题：</p> 
<ul><li> <p>跨站脚本攻击（XSS）：使用WebSocket时，应确保对用户输入进行适当的验证和过滤，以防止跨站脚本攻击。</p> </li><li> <p>跨站请求伪造（CSRF）：WebSocket连接可能受到CSRF攻击的威胁。可以使用CSRF令牌或其他身份验证机制来防止此类攻击。</p> </li><li> <p>安全认证和授权：确保WebSocket连接的安全认证和授权机制。只有经过身份验证且具有适当权限的用户才能建立WebSocket连接。</p> </li><li> <p>数据加密：可以使用SSL/TLS协议对WebSocket连接进行加密，以确保数据在传输过程中的安全性。</p> </li></ul> 
<hr> 
<h2><a id="WebSocket_149"></a>WebSocket与服务器端推送技术的比较</h2> 
<p>WebSocket可以用于服务器端主动推送数据给客户端，与其他服务器端推送技术相比具有如下优势：</p> 
<ul><li> <p>实时性：WebSocket具有实时双向通信的能力，可以实时推送数据给客户端，与服务器端轮询相比，可以更快地将数据发送到客户端。</p> </li><li> <p>性能：WebSocket使用持久连接，减少了网络传输的开销，且能够高效地处理大规模并发连接。</p> </li><li> <p>扩展性：WebSocket具备较高的扩展性，可以处理大量同时连接的用户，且不会造成服务器过载。</p> </li><li> <p>兼容性：WebSocket在现代浏览器中得到广泛支持，可以在各种平台和设备上运行。</p> </li><li> <p>开发复杂度：相较于其他服务器端推送技术，WebSocket的实现可能更复杂一些，需要在前端和后端分别实现相应的逻辑和处理器。</p> </li></ul> 
<p>综上所述，WebSocket与其他服务器端推送技术相比，具有好的实时性、性能、扩展性和兼容性。然而，需要根据具体应用需求和开发资源的限制来选择合适的技方案。</p> 
<p>总之，在实时通信方面，WebSocket是一种非常有用的技术，适用于需要实时双向通信的应用场景。与传统的轮询相比，WebSocket具有更好的性能和实时性，可以实现更好的用户体验和效率。同时，需要注意对WebSocket的安全性进行恰当的考虑和防护，以确保数据传输的安全性。</p> 
<p><img src="https://images2.imgbox.com/94/ed/TzV2XstC_o.gif" alt="在这里插入图片描述"></p> 
<hr>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/87ce28b3db07241d5b7f47f84759877e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows 搭建Flutter开发环境教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/339f2cbba2c2e756a90dbf860d1cd588/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu 更换国内源</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>