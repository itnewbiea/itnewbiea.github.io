<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud Gateway网关的使用与介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud Gateway网关的使用与介绍" />
<meta property="og:description" content="目录
1. gateway简介
1.1 是什么
1.2 作用
1.3 主要特征
1.4 与zuul的主要区别
1.5 主要组件
1.6 架构图
2. 开发示例
2.1 创建一个gateway模块
2.2 与nacos结合使用
2.2.1 默认规则
2.2.2 通过配置文件配置路由
2.2.3 动态路由
1. gateway简介 1.1 是什么 SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。
1.2 作用 Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。
1.3 主要特征 基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0集成 Hystrix 断路器集成 Spring Cloud DiscoveryClientPredicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters具备一些网关的高级功能：动态路由、限流、路径重写 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5b54ea5d9b04a5b95b601b58b4d33013/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-10T20:41:32+08:00" />
<meta property="article:modified_time" content="2022-12-10T20:41:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud Gateway网关的使用与介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20gateway%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#1.%20gateway%E7%AE%80%E4%BB%8B" rel="nofollow">1. gateway简介</a></p> 
<p id="1.1%20%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#1.1%20%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">1.1 是什么</a></p> 
<p id="1.2%20%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.2%20%E4%BD%9C%E7%94%A8" rel="nofollow">1.2 作用</a></p> 
<p id="1.3%20%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81-toc" style="margin-left:40px;"><a href="#1.3%20%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81" rel="nofollow">1.3 主要特征</a></p> 
<p id="1.4%20%E4%B8%8Ezuul%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.4%20%E4%B8%8Ezuul%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB" rel="nofollow">1.4 与zuul的主要区别</a></p> 
<p id="1.5%20%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6-toc" style="margin-left:40px;"><a href="#1.5%20%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6" rel="nofollow">1.5 主要组件</a></p> 
<p id="1.6%20%E6%9E%B6%E6%9E%84%E5%9B%BE-toc" style="margin-left:40px;"><a href="#1.6%20%E6%9E%B6%E6%9E%84%E5%9B%BE" rel="nofollow">1.6 架构图</a></p> 
<p id="2.%20%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B-toc" style="margin-left:0px;"><a href="#2.%20%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B" rel="nofollow">2. 开发示例</a></p> 
<p id="2.1%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgateway%E6%A8%A1%E5%9D%97-toc" style="margin-left:40px;"><a href="#2.1%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgateway%E6%A8%A1%E5%9D%97" rel="nofollow">2.1 创建一个gateway模块</a></p> 
<p id="2.2%20%E4%B8%8Enacos%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2%20%E4%B8%8Enacos%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8" rel="nofollow">2.2 与nacos结合使用</a></p> 
<p id="2.2.1%20%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99-toc" style="margin-left:80px;"><a href="#2.2.1%20%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99" rel="nofollow">2.2.1 默认规则</a></p> 
<p id="2.2.2%20%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1-toc" style="margin-left:80px;"><a href="#2.2.2%20%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1" rel="nofollow">2.2.2 通过配置文件配置路由</a></p> 
<p id="2.2.3%20%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-toc" style="margin-left:80px;"><a href="#2.2.3%20%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1" rel="nofollow">2.2.3 动态路由</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>1. gateway简介</h2> 
<h3 id="1.1%20%E6%98%AF%E4%BB%80%E4%B9%88">1.1 是什么</h3> 
<p>SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p> 
<h3 id="1.2%20%E4%BD%9C%E7%94%A8">1.2 作用</h3> 
<p>Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</p> 
<h3 id="1.3%20%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81">1.3 主要特征</h3> 
<ul><li>基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0</li><li>集成 Hystrix 断路器</li><li>集成 Spring Cloud DiscoveryClient</li><li>Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters</li><li>具备一些网关的高级功能：动态路由、限流、路径重写</li></ul> 
<h3 id="1.4%20%E4%B8%8Ezuul%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB">1.4 与zuul的主要区别</h3> 
<p>Spring Cloud Gateway 底层使用了高性能的通信框架Netty， zuul采用的是传统的servlet IO。</p> 
<h3 id="1.5%20%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6">1.5 主要组件</h3> 
<ul><li>Filter</li></ul> 
<p>过滤器，与zuul中的过滤器作用相同，可以用来拦截和修改请求，也可以对响应做处理。比如用来进行安全校验等。</p> 
<ul><li>Route</li></ul> 
<p>路由组件，将网关接受到的请求发送给指定的上游服务进行处理。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问</p> 
<ul><li>Predicate</li></ul> 
<p>断言， 这是一个 Java 8 的 Predicate。简单的理解是路由转发的条件，满足条件的请求才会被转发。有点像sql中的where子句的作用。</p> 
<h3 id="1.6%20%E6%9E%B6%E6%9E%84%E5%9B%BE">1.6 架构图</h3> 
<p><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/" rel="nofollow" title="官网">官网</a></p> 
<p><img alt="" height="603" src="https://images2.imgbox.com/2f/8f/IE1EOYBU_o.png" width="505"></p> 
<p>对上图的理解：</p> 
<p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑</p> 
<h2 id="2.%20%E5%BC%80%E5%8F%91%E7%A4%BA%E4%BE%8B">2. 开发示例</h2> 
<h3 id="2.1%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAgateway%E6%A8%A1%E5%9D%97">2.1 创建一个gateway模块</h3> 
<p>1）创建一个gateway模块</p> 
<p><img alt="" height="944" src="https://images2.imgbox.com/1e/da/zgtWtEER_o.png" width="1200"></p> 
<p>2）如上图，配置pom文件，引入必要的包</p> 
<pre><code class="hljs">   &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 从注册中心进行服务发现 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 向注册中心进行服务注册 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;
            &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
         &lt;artifactId&gt;lombok&lt;/artifactId&gt;
         &lt;version&gt;1.18.22&lt;/version&gt;
         &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
         &lt;version&gt;1.2.73&lt;/version&gt;
       &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;</code></pre> 
<ol><li>项目配置文件：application.yml</li></ol> 
<p><img alt="" height="361" src="https://images2.imgbox.com/da/1f/VATshyAa_o.png" width="1027"></p> 
<pre><code class="hljs">server:
  port: 8090

spring:
  application:
    name: service-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848</code></pre> 
<p>4）创建启动类，</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/5e/08/Ku8OJMD6_o.png" width="874"></p> 
<pre><code class="hljs">@SpringBootApplication
@EnableDiscoveryClient
public class GatewayApp {

    public static void main(String[] args) {
        SpringApplication.run(GatewayApp.class, args);
    }

}</code></pre> 
<h3 id="2.2%20%E4%B8%8Enacos%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">2.2 与nacos结合使用</h3> 
<h4 id="2.2.1%20%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99">2.2.1 默认规则</h4> 
<p>将gateway注册到nacos注册中心，使用默认规则进行路由，默认规则使用简单，但功能也相当较弱。</p> 
<p>默认规则：</p> 
<p><a href="/" rel="nofollow" title="http://gateway_host:gateway_port/">http://gateway_host:gateway_port/</a>服务名/**</p> 
<p>服务名 默认为nacos注册的服务点的大写，可以修改</p> 
<p>配置文件：</p> 
<p> </p> 
<pre><code class="hljs">server:
  port: 8090

spring:
  application:
    name: service-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848

    gateway:
      discovery:
        locator:
          #开启服务发现功能，从注册中心获取服务列表，（nacos-&gt;服务管理-&gt;服务列表）
          #默认服务名称需要为大写，可以通过配置lower-case-service-id: true 改变这一规则
          enabled: true
          #配置服务名使用小写
          lower-case-service-id: true

#配置配置
logging:
  level:
    #trace，debug，info
    org.pringframework.cloud.gateway: trace #便于跟踪调试，生产环境最好不用
    org.springframework.http.server.reactive: debug
    org.springframework.web.reactive: debug
    reactor.ipc.netty: debug</code></pre> 
<p>测试 比如我有一个模块注册名为service-consumer 那么请求为<a href="http://localhost:8090/service-consumer/echou/133" rel="nofollow" title="http://localhost:8090/service-consumer/***（设置项目的请求路径）">http://localhost:8090/service-consumer/***（设置项目的请求路径）</a></p> 
<h4 id="2.2.2%20%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1">2.2.2 通过配置文件配置路由</h4> 
<p>RouteDefinition中，主要有五个属性：</p> 
<ul><li>id：路由标识（id：标识，具有唯一性，默认为uuid</li><li>predicates：PredicateDefinition 路由断言定义列表</li><li>filters：FilterDefinition 过滤器定义列表，为一个数组</li><li>uri：目标服务地址（uri：地址，请求转发后的地址）</li><li>order：优先级， 越小越优先</li></ul> 
<p>通过配置文件配置路由的缺点是，当增加服务时需要修改配置文件并重启网关。</p> 
<p>配置文件：</p> 
<pre><code class="hljs">server:
  port: 8090

spring:
  application:
    name: service-gateway
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848

    gateway:
      discovery:
        locator:
          #开启服务发现功能，从注册中心获取服务列表，（nacos-&gt;服务管理-&gt;服务列表）
          #默认服务名称需要为大写，可以通过配置lower-case-service-id: true 改变这一规则
          enabled: false
          #配置服务名使用小写
          lower-case-service-id: true

      routes:
        # http://localhost:5000/usr/hello
        #路由标识（id：标识，具有唯一性）
        - id: consumer-service-api
          #目标服务地址（uri：地址，请求转发后的地址），会自动从注册中心获得服务的IP，不需要手动写死
          uri: lb://service-consumer
          #优先级，越小越优先
          #order: 999
          #路由条件（predicates：断言）
          predicates:
          # 路径匹配，
          - Path=/consumer/**
          filters:
          #路径前缀删除示例：请求/name/bar/foo，StripPrefix=2，去除掉前面两个前缀之后，最后转发到目标服务的路径为/foo
          #前缀过滤，请求地址：http://localhost:5000/usr/hello
          #此处配置去掉1个路径前缀，再配置上面的 Path=/usr/**，就将**转发到指定的微服务
          #因为这个api相当于是服务名，只是为了方便以后nginx的代码加上去的，对于服务提供者service-client来说，不需要这段地址，所以需要去掉
          - StripPrefix=1

#配置配置
logging:
  level:
    #trace，debug，info
    org.pringframework.cloud.gateway: trace #便于跟踪调试，生产环境最好不用
    org.springframework.http.server.reactive: debug
    org.springframework.web.reactive: debug
    reactor.ipc.netty: debug</code></pre> 
<p>- Path=/consumer/** 这个参数中间为断言可理解为别名</p> 
<p>- StripPrefix=1 //在真实拼接地址的时候 跳过consumer这一段 如果断言为- Path=/consumer/dd/** 那么下方参数就需要进行更改 要跳过两段- StripPrefix=2 //跳过 的为 consumer/dd</p> 
<h4 id="2.2.3%20%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1">2.2.3 动态路由</h4> 
<p>功能强，在新增服务时不需要重启网关</p> 
<p>1）配置文件</p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/3c/d2/NfB6mDEm_o.png" width="1165"></p> 
<p> </p> 
<pre><code class="hljs"># 自定义配置
# 自定义配置
nacos:
  dataId: gateway-config.json
  group: GWC-GROUP

#配置配置
logging:
  level:
    #trace，debug，info
    #便于跟踪调试，生产环境最好不用
    org.springframework.cloud.gateway: trace
    org.springframework.http.server.reactive: debug
    org.springframework.web.reactive: debug
    reactor.ipc.netty: debug
</code></pre> 
<p>2）读取配置文件的中的配置信息</p> 
<pre><code class="hljs">/**
 * 1. 保存Gateway(网关)中与nacos相关的属性
 * 2. 这些信息是自定义配置属性，它们保存在配置文件application.yml中
 */
@Configuration
@Data
public class GatewayNacosProperties {

    @Value("${spring.cloud.nacos.discovery.server-addr}")
    private String serverAddr;

    @Value("${nacos.dataId}")
    private String dataId;

    @Value("${nacos.group}")
    private String group;

}
</code></pre> 
<p>3）实现实现动态路由 </p> 
<pre><code class="hljs">/**
 * 此类实现了Spring Cloud Gateway + nacos 的动态路由
 * 该类用于监听配置中心中的路由配置的变化，当监听到配置变化，则发布一个事件，
 * 用于更新本地路由信息。
 * 它实现一个Spring提供的事件推送接口ApplicationEventPublisherAware
 */
@Component
public class DynamicRoutingConfig implements ApplicationEventPublisherAware {

    private final Logger logger = LoggerFactory.getLogger(DynamicRoutingConfig.class);

    @Autowired
    private RouteDefinitionWriter routeDefinitionWriter;

    @Autowired
    private GatewayNacosProperties gatewayNacosProperties;

    private ApplicationEventPublisher applicationEventPublisher;


    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }

    /**
     * 这个方法主要负责监听Nacos的配置变化，这里先使用参数构建一个ConfigService，再使用ConfigService开启一个监听，
     * 并且在监听的方法中刷新路由信息。
     *
     * @throws NacosException
     */
    @Bean
    public void refreshRouting() throws NacosException {
        Properties properties = new Properties();
        properties.put(PropertyKeyConst.SERVER_ADDR, gatewayNacosProperties.getServerAddr());
        ConfigService configService = NacosFactory.createConfigService(properties);

        //获得nacos中已有的路由配置
        String json = configService.getConfig(gatewayNacosProperties.getDataId(), gatewayNacosProperties.getGroup(), 8090);
        this.parseJson(json);

        //添加监听器，监听nacos中的数据修改事件
        configService.addListener(gatewayNacosProperties.getDataId(), gatewayNacosProperties.getGroup(), new Listener() {
            @Override
            public Executor getExecutor() {
                return null;
            }

            @Override
            public void receiveConfigInfo(String configInfo) {
                logger.info(configInfo);
                parseJson(configInfo);
            }
        });
    }


    /**
     * 解析从nacos读取的路由配置信息(json格式)
     *
     * @param json
     */
    public void parseJson(String json) {
        logger.info("从Nacos返回的路由配置(JSON格式)：" + json);
        List&lt;RouteDefinition&gt; routeArr = JSON.parseArray(json).toJavaList(RouteDefinition.class);
        for (RouteDefinition route : routeArr) {
            update(route);
        }
    }


    /**
     * 路由更新：
     * 1）先将原来的路由信息删除
     * 2）保存新的路由信息
     * @param routeDefinition
     * @return
     */
    public void update(RouteDefinition routeDefinition) {

        try {
            this.routeDefinitionWriter.delete(Mono.just(routeDefinition.getId()));
            logger.info("删除原来的路由信息");
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }

        try {
            routeDefinitionWriter.save(Mono.just(routeDefinition)).subscribe();
            this.applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this));
            logger.info("路由更新成功");
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
    }

}
</code></pre> 
<p> </p> 
<p>4）在配置中心中配置路由信息</p> 
<p><img alt="" height="470" src="https://images2.imgbox.com/3c/bd/Nnjh6RM0_o.png" width="1200"></p> 
<p><img alt="" height="935" src="https://images2.imgbox.com/f5/24/L3d4B5PT_o.png" width="1200"></p> 
<p>路由配置采用json格式，参考配置如下： service-consumer 服务名称 本地配置中的名称</p> 
<pre><code class="hljs">[
  {
    "id": "service-consumer",
    "predicates": [
      {
        "name": "Path",
        "args": {
        "_genkey_0": "/consumer/**"
        }
      }
    ],
    "filters": [
      {
        "name": "StripPrefix",
        "args": {
          "_genkey_0": "1"
        }
      }
    ],
    "uri": "lb://service-consumer",
    "order": 0
  }
]</code></pre> 
<p>需要根据自己的项目的具体情况配置。</p> 
<p>配置两个模块</p> 
<pre><code class="hljs">[
  {
    "id": "service-consumer",
    "predicates": [
      {
        "name": "Path",
        "args": {
        "_genkey_0": "/consumer/**"
        }
      }
    ],
    "filters": [
      {
        "name": "StripPrefix",
        "args": {
          "_genkey_0": "1"
        }
      }
    ],
    "uri": "lb://service-consumer",
    "order": 0
  },
    {
    "id": "service-proved",
    "predicates": [
      {
        "name": "Path",
        "args": {
        "_genkey_0": "/proved/**"
        }
      }
    ],
    "filters": [
      {
        "name": "StripPrefix",
        "args": {
          "_genkey_0": "1"
        }
      }
    ],
    "uri": "lb://service-proved",
    "order": 0
  }
]
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/19b3de1b1ab056235cfd55013fde0e79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">video标签不能自动播放的原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f3482a64edf21caa33e58e3da0b3da0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows10 java环境变量的配置详细教程（Windows10 和Windows11）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>