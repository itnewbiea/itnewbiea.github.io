<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式3——结构型模式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式3——结构型模式" />
<meta property="og:description" content="结构型模式描述如何将类或对象按某种布局组成更大的结构，它分为类结构型和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。
由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。
结构型模式分为以下7种：
代理模式；适配器模式；装饰者模式；桥接模式；外观模式；组合模式；享元模式。 1、代理模式 1.1、概述 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。
1.2、结构 代理（Proxy）模式分为三种角色：
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 1.3、静态代理 我们通过案例来感受一下静态代理。
【例】火车站卖票
如果要买火车站的票，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车票在多个地方都有代售点，我们就进去代售点卖票就方便多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。
// 抽象主题类：卖火车票的接口 interface SellTickets { void sell(); } // 具体主题类：火车站类 class TrainStation implements SellTickets { @Override public void sell() { System.out.println(&#34;火车站卖票&#34;); } } // 代理类：代售点类 class ProxyPoint implements SellTickets { // 声明火车站类对象 private TrainStation trainStation = new TrainStation(); @Override public void sell() { System.out.println(&#34;代理点收取一些服务费用&#34;); trainStation.sell(); } } public class Client2 { public static void main(String[] args) { // 创建代售点类对象 ProxyPoint proxyPoint = new ProxyPoint(); // 调用方法进行买票 proxyPoint." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8e983337d29149bfcd7630d2f80a31c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-10T10:12:06+08:00" />
<meta property="article:modified_time" content="2023-03-10T10:12:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式3——结构型模式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>结构型模式描述如何将类或对象按某种布局组成更大的结构，它分为类结构型和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。</p> 
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p> 
<p>结构型模式分为以下7种：</p> 
<ul><li>代理模式；</li><li>适配器模式；</li><li>装饰者模式；</li><li>桥接模式；</li><li>外观模式；</li><li>组合模式；</li><li>享元模式。</li></ul> 
<h3>1、代理模式</h3> 
<h3>1.1、概述</h3> 
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p> 
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p> 
<h3>1.2、结构</h3> 
<p>代理（Proxy）模式分为三种角色：</p> 
<ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ul> 
<h3>1.3、静态代理</h3> 
<p>我们通过案例来感受一下静态代理。</p> 
<p>【例】火车站卖票</p> 
<p>如果要买火车站的票，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车票在多个地方都有代售点，我们就进去代售点卖票就方便多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/60/a7/NX0VPx5F_o.png"></p> 
<pre><code class="language-java">// 抽象主题类：卖火车票的接口
interface SellTickets {
    void sell();
}

// 具体主题类：火车站类
class TrainStation implements SellTickets {
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
}

// 代理类：代售点类
class ProxyPoint implements SellTickets {
    // 声明火车站类对象
    private TrainStation trainStation = new TrainStation();

    @Override
    public void sell() {
        System.out.println("代理点收取一些服务费用");
        trainStation.sell();
    }
}

public class Client2 {
    public static void main(String[] args) {
        // 创建代售点类对象
        ProxyPoint proxyPoint = new ProxyPoint();
        // 调用方法进行买票
        proxyPoint.sell();
    }
}

结果：
代理点收取一些服务费用
火车站卖票</code></pre> 
<p>从上面代买中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell()方法进行了增强（代理点收取一些服务费用）。</p> 
<h3>1.4、JDK动态代理</h3> 
<p>接下来我们使用动态代理实现上面的案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p> 
<p>代码如下：</p> 
<pre><code class="language-java">// 抽象主题类：卖火车票的接口
interface SellTickets {
    void sell();
}

// 具体主题类：火车站类
class TrainStation implements SellTickets {
    @Override
    public void sell() {
        System.out.println("火车站卖票");
    }
}

// 获取代理对象的工厂类，代理类也实现了对应的接口
class ProxyFactory {
    // 声明目标对象
    private TrainStation trainStation = new TrainStation();

    // 获取代理对象的方法
    public SellTickets getProxyObject() {
        // 返回代理对象即可
        /*
          ClassLoader loader : 类加载器，用于加载代理类。可以通过目标对象获取类加载器
          Class&lt;?&gt;[] interfaces ： 代理类实现的接口的字节码对象
          InvocationHandler h ： 代理对象的调用处理程序
         */
        SellTickets proxyObject = (SellTickets) Proxy.newProxyInstance(
                trainStation.getClass().getClassLoader(),
                trainStation.getClass().getInterfaces(),
                new InvocationHandler() {
                    /*
                        Object proxy : 代理对象，和proxyObject对象是同一个对象，在invoke方法中基本不用
                        Method method ： 对接口中的方法进行封装的Method对象
                        Object[] args : 调用方法的实际参数

                        返回值 ： 方法的返回值。如果接口方法没有返回值，那么返回null；如果有返回值，则返回具体的值
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("代售点收取一定的服务费用（jdk动态代理）");
                        Object obj = method.invoke(trainStation, args);
                        return obj;
                    }
                }
        );
        return proxyObject;
    }
}

public class Client2 {
    public static void main(String[] args) {
        // 获取代理对象
        // 1、创建代理工厂对象
        ProxyFactory proxyFactory = new ProxyFactory();
        // 2、使用factory对象的方法获取代理对象
        SellTickets proxyObject = proxyFactory.getProxyObject();
        // 3、调用卖电脑的方法
        proxyObject.sell();
    }
}

结果：
代售点收取一定的服务费用（jdk动态代理）
火车站卖票</code></pre> 
<p>使用了动态代理，我们思考下面的问题：</p> 
<p>ProxyFactory是代理类吗？- ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态地在内存中生成的类。通过阿里巴巴开源的Java诊断工具（Arthas【阿尔萨斯】）查看代理类的结构（已简化）：</p> 
<pre><code class="language-java">public final class $Proxy0 extends Proxy implements SellTickets {
    private static Method m3;
    
    public $Proxy0(InvocationHandler invocationHandler) {
        super(invocationHandler);
    }
    
    static {
        m3 = Class.forName("com.design_pattern.proxy.SellTickets").getMethod("sell", new Class[0]);
    }
    
    public final void sell() {
        this.h.invoke(this, m3, null);
    }
}

public class Proxy {
    protected InvocationHandler invocationHandler;
}</code></pre> 
<p>从上面的类中，我们可以看到以下几个信息：</p> 
<ul><li>代理类（$Proxy0）实现了SellTickets，也就印证了我们之前说的真实类和代理类实现同样的接口。</li><li>代理类（$Proxy0）将我们提供的匿名内部类对象传递给了父类。</li></ul> 
<p>动态代理的执行流程是什么样的？</p> 
<ul><li>在测试类中通过代理对象调用sell()方法；</li><li>根据多态的特性，执行的是代理类($Proxy0)中的sell()方法；</li><li>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法；</li><li>invoke方法通过反射执行了真实对象所属类（TrainStation）中的sell()方法。</li></ul> 
<h3>1.5、CGLIB动态代理</h3> 
<p>同样是上面的案例，我们再次使用CGLIB代理实现。</p> 
<p>如果没有定义SellTickets接口，只定义了TrainStation（火车站类），很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p> 
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p> 
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p> 
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>代码如下：</p> 
<pre><code class="language-java">class TrainStation {
    public void sell() {
        System.out.println("火车站卖票");
    }
}

// 代理对象工厂
class ProxyFactory {
    public TrainStation getProxyObject(TrainStation station) {
        // 创建Enhancer对象，类似于JDK代理中的Proxy类
        Enhancer enhancer = new Enhancer();
        // 设置父类的字节码对象，指定代理类的父类
        enhancer.setSuperclass(TrainStation.class);
        // 设置回调函数
        enhancer.setCallback(new MethodInterceptor() {
            /**
             *
             * @param o 代理对象
             * @param method 调用的方法
             * @param objects 方法参数
             * @param methodProxy
             * @return
             * @throws Throwable
             */
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println("代售点收取一定的费用（cglib代理）");
                // 要调用目标对象的方法
                Object obj = method.invoke(station, objects);
                return obj;
            }
        });
        // 创建代理对象
        TrainStation proxyObject = (TrainStation) enhancer.create();
        return proxyObject;
    }
}

public class Client3 {
    public static void main(String[] args) {
        // 创建代理工厂对象
        ProxyFactory proxyFactory = new ProxyFactory();
        // 获取代理对象
        TrainStation proxyObject = proxyFactory.getProxyObject(new TrainStation());
        // 调佣代理对象中的sell()方法
        proxyObject.sell();
    }
}

结果：
代售点收取一定的费用（cglib代理）
火车站卖票</code></pre> 
<h3>1.6、三种代理的对比</h3> 
<h4>1.6.1、jdk代理和cglib代理</h4> 
<p>使用cglib实现动态代理，cglib底层采用ASM字节码生成框架，使用字节码生成框架技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，cglib不能对声明为final的类或者方法进行代理，因为cglib原理是动态生成被代理类的子类。</p> 
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于cglib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比cglib代理效率低一些，但是到JDK1.8的时候，JDK代理效率高于cglib代理，所以如果有接口使用JDK动态代理，如果没有接口使用cglib代理。</p> 
<h4>1.6.2、动态代理和静态代理</h4> 
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke()），这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p> 
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度，而动态代理不会出现该问题。</p> 
<h3>1.7、优缺点</h3> 
<p>优点：</p> 
<ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。</li></ul> 
<p>缺点：</p> 
<ul><li>增加了系统的复杂度。</li></ul> 
<h3>1.8、使用场景</h3> 
<h4>1.8.1、远程（Remote）代理</h4> 
<p>本地服务器通过网络请求远程服务，为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p> 
<h4>1.8.2、防火墙（Firewall）代理</h4> 
<p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p> 
<h4>1.8.3、保护（Protect or Access）代理</h4> 
<p>控制一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p> 
<h2>2、适配器模式</h2> 
<h3>2.1、概述</h3> 
<p>定义：将一个类的接口转换成客户端希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的哪些类能一起工作。</p> 
<p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比较高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p> 
<h3>2.2、结构</h3> 
<p>适配器模式（Adapter）包含以下主要角色：</p> 
<ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件接口。</li><li>适配器类（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul> 
<h3>2.3、类适配器模式</h3> 
<p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p> 
<p>【例】读卡器。</p> 
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。类图如下</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fb/89/iY3SaUUm_o.png"></p> 
<p>代码如下：</p> 
<pre><code class="language-java">// 适配者类的接口
interface TFCard {
    // 从TF卡中读取数据
    String readTF();

    // 往TF卡中写数据
    void writeTF(String msg);
}

// 适配者类实现
class TFCardImpl implements TFCard {
    @Override
    public String readTF() {
        String msg = "TFCard read msg : hello world TFCard";
        return msg;
    }

    @Override
    public void writeTF(String msg) {
        System.out.println("TFCard write msg : " + msg);
    }
}

// 目标接口
interface SDCard {
    // 从SD卡中读取数据
    String readSD();
    // 往SD卡中写数据
    void writeSD(String msg);
}

// 具体SDCard实现
class SDCardImpl implements SDCard {
    @Override
    public String readSD() {
        String msg = "SDCard read msg : hello world SDCard";
        return msg;
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("SDCard write msg : " + msg);
    }
}

// 适配器类
class SDAdapterTF extends TFCardImpl implements SDCard {
    @Override
    public String readSD() {
        System.out.println("adapter read tf card");
        return readTF();
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        writeTF(msg);
    }
}

// 计算机类
class Computer {
    // 从SD卡中读取数据
    public String readSD(SDCard sdCard) {
        if (sdCard == null) throw new NullPointerException("sd card can not be null");
        return sdCard.readSD();
    }
}

public class Test4 {
    public static void main(String[] args) {
        // 创建计算机对象
        Computer computer = new Computer();
        // 读取SD卡中的数据
        String msg1 = computer.readSD(new SDCardImpl());
        System.out.println(msg1);
        System.out.println("-------------------------------------");

        // 使用该电脑读取TF卡中的数据
        String msg2 = computer.readSD(new SDAdapterTF());
        System.out.println(msg2);
    }
}

结果：
SDCard read msg : hello world SDCard
-------------------------------------
adapter read tf card
TFCard read msg : hello world TFCard</code></pre> 
<p>类适配器模式违背了合成复用原则，类适配器是客户端类有一个接口规范的情况下可用，反之不可用。</p> 
<h3>2.4、对象适配器模式</h3> 
<p>实现方式：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p> 
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b9/33/T6cnXugQ_o.png"></p> 
<p>代码如下：</p> 
<pre><code class="language-java">// 适配者类的接口
interface TFCard {
    // 从TF卡中读取数据
    String readTF();

    // 往TF卡中写数据
    void writeTF(String msg);
}

// 适配者类实现
class TFCardImpl implements TFCard {
    @Override
    public String readTF() {
        String msg = "TFCard read msg : hello world TFCard";
        return msg;
    }

    @Override
    public void writeTF(String msg) {
        System.out.println("TFCard write msg : " + msg);
    }
}

// 目标接口
interface SDCard {
    // 从SD卡中读取数据
    String readSD();
    // 往SD卡中写数据
    void writeSD(String msg);
}

// 具体SDCard实现
class SDCardImpl implements SDCard {
    @Override
    public String readSD() {
        String msg = "SDCard read msg : hello world SDCard";
        return msg;
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("SDCard write msg : " + msg);
    }
}

// 适配器类
class SDAdapterTF implements SDCard {
    private TFCard tfCard;

    public SDAdapterTF(TFCard tfCard) {
        this.tfCard = tfCard;
    }

    @Override
    public String readSD() {
        System.out.println("adapter read tf card");
        return tfCard.readTF();
    }

    @Override
    public void writeSD(String msg) {
        System.out.println("adapter write tf card");
        tfCard.writeTF(msg);
    }
}

// 计算机类
class Computer {
    // 从SD卡中读取数据
    public String readSD(SDCard sdCard) {
        if (sdCard == null) throw new NullPointerException("sd card can not be null");
        return sdCard.readSD();
    }
}

public class Test4 {
    public static void main(String[] args) {
        // 创建计算机对象
        Computer computer = new Computer();
        // 读取SD卡中的数据
        String msg1 = computer.readSD(new SDCardImpl());
        System.out.println(msg1);
        System.out.println("-------------------------------------");

        // 使用该电脑读取TF卡中的数据
        String msg2 = computer.readSD(new SDAdapterTF(new TFCardImpl()));
        System.out.println(msg2);
    }
}

结果：
SDCard read msg : hello world SDCard
-------------------------------------
adapter read tf card
TFCard read msg : hello world TFCard</code></pre> 
<p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，实现所有方法，而此时我们只需要继承该抽象类即可。</p> 
<h3>2.5、应用场景</h3> 
<p>以前开发的系统存在满足新功能需求的类，但其接口同新系统的接口不一致。</p> 
<p>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p> 
<h3>2.6、JDK源码解析</h3> 
<p>Reader（字符流）、InputStream（字节流）的适配使用的就是InputStreamReader和OutputStreamWriter。</p> 
<p>InputStreamReader继承自java.io包中的Reader，对Reader中的抽象的未实现的方法给出实现。</p> 
<pre><code class="language-java">    public int read() throws IOException {
        return sd.read();
    }
    
    public int read(char cbuf[], int offset, int length) throws IOException {
        return sd.read(cbuf, offset, length);
    }</code></pre> 
<p>如上代码中的sd(StreamDecoder类对象），在Sun的jdk实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/db/WyNTzB3s_o.png"></p> 
<p>从上图可以看出：</p> 
<ul><li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装；</li><li>StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现，但我们知道它们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li></ul> 
<p>结论：表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p> 
<h2>3、装饰者模式</h2> 
<h3>3.1、概述</h3> 
<p>我们先来看一个快餐店的例子。</p> 
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不大一样，那么计算总价就会显得比较麻烦。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b3/54/bMMUDMRJ_o.png"></p> 
<p></p> 
<p>使用继承的方式存在的问题：</p> 
<ul><li>扩展性不好；</li><li>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类；</li><li>产生更多的子类。</li></ul> 
<p>装饰者模式定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p> 
<h3>3.2、结构</h3> 
<p>装饰（Decorator）模式中的角色：</p> 
<ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接受附加责任的对象；</li><li>具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责；</li><li>抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能；</li><li>具体装饰（Concrete Decorator）角色：实现抽象装置的相关方法，并给具体构件对象添加附加的责任。</li></ul> 
<h3>3.3、案例</h3> 
<p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p> 
<p>类图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2c/8c/ohNY3oci_o.png"></p> 
<p>代码如下：</p> 
<pre><code class="language-java">/**
 * 抽象构件角色：快餐类
 */
abstract class FastFood {
    private float price;
    private String desc;

    public FastFood() {
    }

    public FastFood(float price, String desc) {
        this.price = price;
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public abstract float cost();
}

// 具体构件角色：炒饭快餐类
class FriedRice extends FastFood {
    public FriedRice() {
        super(10, "炒饭");
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

// 具体构件角色：炒面快餐类
class FriedNoodles extends FastFood {
    public FriedNoodles() {
        super(12, "炒面");
    }

    @Override
    public float cost() {
        return getPrice();
    }
}

// 抽象装饰角色：装饰者类
abstract class Garnish extends FastFood {
    // 声明快餐类的变量
    private FastFood fastFood;

    public Garnish(FastFood fastFood) {
        this.fastFood = fastFood;
    }

    public Garnish(FastFood fastFood, float price, String desc) {
        super(price, desc);
        this.fastFood = fastFood;
    }

    public FastFood getFastFood() {
        return fastFood;
    }

    public void setFastFood(FastFood fastFood) {
        this.fastFood = fastFood;
    }
}

// 具体装饰者角色：鸡蛋
class Egg extends Garnish {
    public Egg(FastFood fastFood) {
        super(fastFood, 1, "鸡蛋");
    }

    @Override
    public float cost() {
        // 计算价格
        return getPrice() + getFastFood().cost();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}

// 具体装饰者角色：培根
class Bacon extends Garnish {
    public Bacon(FastFood fastFood) {
        super(fastFood, 2, "培根");
    }

    @Override
    public float cost() {
        // 计算价格
        return getPrice() + getFastFood().cost();
    }

    @Override
    public String getDesc() {
        return super.getDesc() + getFastFood().getDesc();
    }
}

public class Test5 {
    public static void main(String[] args) {
        // 点一份炒饭
        FastFood food = new FriedRice();
        System.out.println(food.getDesc() + " " + food.cost() + " 元");
        System.out.println("-------------------------------------------");


        // 在上面的炒饭中加一个鸡蛋
        food = new Egg(food);
        System.out.println(food.getDesc() + " " + food.cost() + " 元");
        System.out.println("-------------------------------------------");

        // 再加一个鸡蛋
        food = new Egg(food);
        System.out.println(food.getDesc() + " " + food.cost() + " 元");
        System.out.println("-------------------------------------------");

        // 再加一个培根
        food = new Bacon(food);
        System.out.println(food.getDesc() + " " + food.cost() + " 元");
        System.out.println("-------------------------------------------");
    }
}

结果：
炒饭 10.0 元
-------------------------------------------
鸡蛋炒饭 11.0 元
-------------------------------------------
鸡蛋鸡蛋炒饭 12.0 元
-------------------------------------------
培根鸡蛋鸡蛋炒饭 14.0 元
-------------------------------------------</code></pre> 
<p>好处：</p> 
<ul><li>装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美地遵循开闭原则，继承是静态地附加责任，装饰者则是动态地附加责任。</li><li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li></ul> 
<h3>3.4、使用场景</h3> 
<ul><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况有两类：① 系统中存在大量的独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；② 类定义不能继承（如final类）。</li><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；</li><li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li></ul> 
<h3>3.5、JDK源码解析</h3> 
<p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader， BufferedWriter。</p> 
<p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter。</p> 
<pre><code class="language-java">public class Test6 {
    public static void main(String[] args) throws IOException {
        // 创建BufferedWriter对象
        // 创建FileWriter对象
        FileWriter fw = new FileWriter("C:\\Users\\Administrator\\Desktop\\a.txt");
        BufferedWriter bw = new BufferedWriter(fw);

        // 写数据
        bw.write("hello Buffered");

        bw.close();
    }
}

结果（a.txt）：
hello Buffered</code></pre> 
<p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/42/df/qizh2mW3_o.png"></p> 
<p>小结：BufferedWriter使用装饰者模式对Writer子实现进行了增强，添加了缓冲区，提高了写数据的效率。</p> 
<h3>3.6、代理和装饰者的区别</h3> 
<p>静态代理和装饰者模式的区别：</p> 
<p>相同点：</p> 
<ul><li>都要实现与目标类相同的业务接口；</li><li>在两个类中都要声明目标对象；</li><li>都可以在不修改目标类的前提下增强目标方法；</li></ul> 
<p>不同点：</p> 
<ul><li>目的不同：装饰者是为了增强目标对象；静态代理是为了保护和隐藏目标对象。</li><li>获取目标对象构建的地方不同：装饰者是由外界传递进来，可以通过构造方法传递；静态代理是在代理类内部创建，以此来隐藏目标对象。</li></ul> 
<h2>4、桥接模式</h2> 
<h3>4.1、概述</h3> 
<p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色，我们可以利用继承的方式来设计类的关系。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/50/ad5FtvZT_o.png"></p> 
<p>我们可以发现有很多的类，加入我们再增加一个形状或增加一种颜色，就需要创建更多的类。试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的系统设计，我们此时可以考虑使用桥接模式。</p> 
<p>桥接模式定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代理继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p> 
<h3>4.2、结构</h3> 
<p>桥接（Bridge）模式包含以下主要角色：</p> 
<ul><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implement）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implement）角色：给出实现化角色接口的具体实现。</li></ul> 
<h3>4.3、案例</h3> 
<p>【例】视频播放器。</p> 
<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p> 
<p>类图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9e/ea/MgCOcpVx_o.png"></p> 
<p>代码如下：</p> 
<pre><code class="language-java">// 实现化角色：视频文件
interface VideoFile {
    // 解码功能
    void decode(String fileName);
}

// 具体实现化角色：avi视频文件
class AviFile implements VideoFile {

    @Override
    public void decode(String fileName) {
        System.out.println("avi视频文件：" + fileName);
    }
}

// 具体实现化角色：rmvb视频文件
class RmvbFile implements VideoFile {
    @Override
    public void decode(String fileName) {
        System.out.println("rmvb视频文件：" + fileName);
    }
}

// 抽象化角色：抽象的操作系统类
abstract class OperatingSystem {
    // 声明videoFile变量
    protected VideoFile videoFile;

    public OperatingSystem(VideoFile videoFile) {
        this.videoFile = videoFile;
    }

    public abstract void play(String fileName);
}

// 扩展抽象化角色：Windows操作系统
class Windows extends OperatingSystem {
    public Windows(VideoFile videoFile) {
        super(videoFile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}

// 扩展抽象化角色：Mac操作系统
class Mac extends OperatingSystem {
    public Mac(VideoFile videoFile) {
        super(videoFile);
    }

    @Override
    public void play(String fileName) {
        videoFile.decode(fileName);
    }
}

public class Test6 {
    public static void main(String[] args) throws IOException {
        // 创建Mac系统对象
        OperatingSystem system = new Mac(new AviFile());
        // 使用操作系统播放视频文件
        system.play("战狼3");
    }
}

结果：
avi视频文件：战狼3</code></pre> 
<p>好处：</p> 
<ul><li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</li><li>实现细节对客户透明。</li></ul> 
<h3>4.4、使用场景</h3> 
<ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时；</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时；</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li></ul> 
<h2>5、外观模式</h2> 
<h3>5.1、概述</h3> 
<p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定的托管管理费用。</p> 
<p>外观模式定义：又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p> 
<p>外观（Facade）模式是“迪米特法则”的典型应用。</p> 
<h3>5.2、结构</h3> 
<p>外观（Facade）模式包含以下主要角色：</p> 
<ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ul> 
<h3>5.3、案例</h3> 
<p>【例】智能家电控制。</p> 
<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c3/31/Ly5N5GxX_o.png"></p> 
<p>代码如下：</p> 
<pre><code class="language-java">// 灯类
class Light {
    public void on() {
        System.out.println("打开电灯...");
    }

    public void off() {
        System.out.println("关闭电灯...");
    }
}

// TV类
class TV {
    public void on() {
        System.out.println("打开电视机...");
    }

    public void off() {
        System.out.println("关闭电视机...");
    }
}

// 空调类
class AirCondition {
    public void on() {
        System.out.println("打开空调...");
    }

    public void off() {
        System.out.println("关闭空调...");
    }
}

// 外观类，用户主要和该类对象进行交互
class SmartAppliancesFacade {
    // 聚合电灯对象、电视机对象、空调对象
    private Light light;
    private TV tv;
    private AirCondition airCondition;

    public SmartAppliancesFacade() {
        this.light = new Light();
        this.tv = new TV();
        this.airCondition = new AirCondition();
    }

    // 通过语音控制
    public void say(String message) {
        if (message.contains("打开")) {
            on();
        } else if (message.contains("关闭")) {
            off();
        } else {
            System.out.println("我还听不懂你说的！");
        }
    }

    // 一键打开功能
    private void on() {
        light.on();
        tv.on();
        airCondition.on();
    }

    // 一键关闭功能
    private void off() {
        light.off();
        tv.off();
        airCondition.off();
    }
}


public class Test7 {
    public static void main(String[] args) {
        // 创建智能音箱对象
        SmartAppliancesFacade facade = new SmartAppliancesFacade();
        // 控制家电
        facade.say("打开家电");
        System.out.println("-----------------------");
        facade.say("关闭家电");
    }
}

结果：
打开电灯...
打开电视机...
打开空调...
-----------------------
关闭电灯...
关闭电视机...
关闭空调...</code></pre> 
<p>好处：</p> 
<ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类；</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul> 
<p>缺点：</p> 
<ul><li>不符合开闭原则，修改很麻烦。</li></ul> 
<h3>5.4、使用场景</h3> 
<ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系；</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问；</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul> 
<h3>5.5、源码解析</h3> 
<p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象，但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该Request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p> 
<pre><code class="language-java">class ServletDemo extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doGet(req, resp);
    }
}

public class Test8 {
    public static void main(String[] args) {

    }
}</code></pre> 
<p>RequestFacade类就使用了外观模式。先看结构图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9d/57/0RXObopv_o.png"></p> 
<p>为什么在此处使用外观模式呢？</p> 
<p>定义RequestFacade类，分别实现ServletRequest，同时定义私有成员变量Request，并且方法的实现调用Request的实现。然后，将RequestFacade上转为ServletRequest，传给servlet的service方法，这样即使在servlet中被下转为RequestFacade，也不能访问私有成员变量对象中的方法。既用了Request，又能防止其中方法被不合理地访问。</p> 
<h2>6、组合模式</h2> 
<h3>6.1、概述</h3> 
<p>组合模式定义：又名部分整体模式，是用于把一组相似的对象当做一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p> 
<h3>6.2、结构</h3> 
<p>组合模式主要包含三种角色：</p> 
<ul><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝结点和叶子结点形成一个树形结构。</li><li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul> 
<h3>6.3、案例实现</h3> 
<p>【例】软件菜单。</p> 
<p>我们在访问一些别的管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p> 
<p>要实现该案例，我们先画出类图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/44/7e/FCm3YgBa_o.png"></p> 
<p>代码实现：</p> 
<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p> 
<pre><code class="language-java">// 菜单组件，不管是菜单还是菜单项，都应该继承自该类
abstract class MenuComponent {
    // 菜单组件的名称
    protected String name;
    // 菜单组件的层级
    protected int level;

    // 添加子菜单
    public void add(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }

    // 移除子菜单
    public void remove(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }

    // 获取指定的子菜单
    public MenuComponent getChild(int index) {
        throw new UnsupportedOperationException();
    }

    // 获取菜单或菜单项的名称
    public String getName() {
        return name;
    }

    // 打印菜单名称的方法（包含子菜单和子菜单项）
    public abstract void print();
}

// 菜单类（属于树枝节点）
class Menu extends MenuComponent {
    // 菜单可以有多个子菜单或子菜单项
    private List&lt;MenuComponent&gt; menuComponents;

    // 提供构造方法
    public Menu(String name, int level) {
        this.name = name;
        this.level = level;
        this.menuComponents = new ArrayList&lt;&gt;();
    }

    @Override
    public void add(MenuComponent menuComponent) {
        menuComponents.add(menuComponent);
    }

    @Override
    public void remove(MenuComponent menuComponent) {
        menuComponent.remove(menuComponent);
    }

    @Override
    public MenuComponent getChild(int index) {
        return menuComponents.get(index);
    }

    @Override
    public void print() {
        // 打印菜单名称
        for (int i = 0; i &lt; level; i++) {
            System.out.print("--");
        }
        System.out.println(name);
        // 打印子菜单或子菜单项名称
        for (MenuComponent menuComponent : menuComponents) {
            menuComponent.print();
        }
    }
}

// 菜单项类：属于叶子节点
class MenuItem extends MenuComponent {
    public MenuItem(String name, int level) {
        this.name = name;
        this.level = level;
    }

    @Override
    public void print() {
        for (int i = 0; i &lt; level; i++) {
            System.out.print("--");
        }
        // 打印菜单项的名称
        System.out.println(name);
    }
}

public class Test9 {
    public static void main(String[] args) {
        // 创建菜单树
        MenuComponent menu1 = new Menu("菜单管理", 2);
        menu1.add(new MenuItem("页面访问", 3));
        menu1.add(new MenuItem("展开菜单", 3));
        menu1.add(new MenuItem("编辑菜单", 3));
        menu1.add(new MenuItem("删除菜单", 3));
        menu1.add(new MenuItem("新增菜单", 3));

        MenuComponent menu2 = new Menu("权限管理", 2);
        menu2.add(new MenuItem("页面访问", 3));
        menu2.add(new MenuItem("提交保存", 3));

        MenuComponent menu3 = new Menu("角色管理", 2);
        menu3.add(new MenuItem("页面访问", 3));
        menu3.add(new MenuItem("新增角色", 3));
        menu3.add(new MenuItem("修改角色", 3));

        // 创建1级菜单
        MenuComponent component = new Menu("系统管理", 1);
        // 将2级菜单添加到1级菜单中
        component.add(menu1);
        component.add(menu2);
        component.add(menu3);

        // 打印菜单名称（如果有子菜单，一块打印）
        component.print();
    }
}

结果：
--系统管理
----菜单管理
------页面访问
------展开菜单
------编辑菜单
------删除菜单
------新增菜单
----权限管理
------页面访问
------提交保存
----角色管理
------页面访问
------新增角色
------修改角色</code></pre> 
<h3>6.4、组合模式的分类</h3> 
<p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p> 
<ul><li>透明组合模式：透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中MenuComponent声明了add()、remove()、getChild()方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的抽象，即不可能包含成员对象，因此为其提供add()、remove()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。</li><li>安全组合模式：在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点Menu类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</li></ul> 
<h3>6.5、优点</h3> 
<ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制；</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码；</li><li>在组合模式中增加新的树枝节点和叶子结点都很方便，无需对现有类库进行任何修改，符合开闭原则；</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul> 
<h3>6.6、使用场景</h3> 
<p>组合模式正式应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p> 
<h2>7、享元模式</h2> 
<h3>7.1、概述</h3> 
<p>享元模式定义：运行共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量，避免大量相似对象的开销，从而提高系统资源的利用率。</p> 
<h3>7.2、结构</h3> 
<p>享元（Flyweight）模式中存在以下两种状态：</p> 
<ul><li>内部状态，即不会随着环境的改变而改变的可共享部分；</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li></ul> 
<p>享元模式的主要有以下角色：</p> 
<ul><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元（Concrete Flyweight）角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>非享元（Unsharable Flyweight）角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>享元工厂角色（FlyWeight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul> 
<h3>7.3、案例实现</h3> 
<p>【例】俄罗斯方块。</p> 
<p>在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行创建。</p> 
<p>先来看类图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b1/8d/Dx28mkfy_o.png"></p> 
<p>代码如下：</p> 
<p>俄罗斯方块具有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p> 
<pre><code class="language-java">// 抽象享元角色
abstract class AbstractBox {
    // 获取图形的方法
    public abstract String getShape();

    // 显示图形及颜色
    public void display(String color) {
        System.out.println("方块形状：" + getShape() + ", 颜色：" + color);
    }
}

// 具体享元角色：I图形类
class IBox extends AbstractBox {
    @Override
    public String getShape() {
        return "I";
    }
}
// 具体享元角色：L图形类
class LBox extends AbstractBox {
    @Override
    public String getShape() {
        return "L";
    }
}
// 具体享元角色：I图形类
class OBox extends AbstractBox {
    @Override
    public String getShape() {
        return "O";
    }
}

// 工厂类，将该类设计为单例
class BoxFactory {
    private HashMap&lt;String, AbstractBox&gt; map;

    // 在构造方法中进行初始化操作
    private BoxFactory() {
        map = new HashMap&lt;&gt;();
        map.put("I", new IBox());
        map.put("L", new LBox());
        map.put("O", new OBox());
    }

    private static BoxFactory factory = new BoxFactory();
    // 提供一个方法获取该工厂类对象
    public static BoxFactory getInstance() {
        return factory;
    }

    // 根据名称获取图形对象
    public AbstractBox getShape(String name) {
        return map.get(name);
    }
}

public class Test1 {
    public static void main(String[] args) {
        // 获取I图形对象
        AbstractBox box1 = BoxFactory.getInstance().getShape("I");
        box1.display("灰色");
        // 获取L图形对象
        AbstractBox box2 = BoxFactory.getInstance().getShape("L");
        box2.display("灰色");
        // 获取O图形对象
        AbstractBox box3 = BoxFactory.getInstance().getShape("O");
        box3.display("灰色");
        // 获取O图形对象
        AbstractBox box4 = BoxFactory.getInstance().getShape("O");
        box4.display("红色");

        System.out.println("两次获取的的O图形是否是同一个对象：" + (box3 == box4));
    }
}

结果：
方块形状：I, 颜色：灰色
方块形状：L, 颜色：灰色
方块形状：O, 颜色：灰色
方块形状：O, 颜色：红色
两次获取的的O图形是否是同一个对象：true</code></pre> 
<h3>7.4、优缺点和使用场景</h3> 
<p>1、优点</p> 
<ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能；</li><li>享元模式中的外部状态相对独立，且不影响内部状态。</li></ul> 
<p>2、缺点</p> 
<ul><li>为了使对象可以共享，需要将享元对象的部分状态外部化，分类内部状态和外部状态，使程序逻辑复杂。</li></ul> 
<p>3、使用场景</p> 
<ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费；</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul> 
<h3>7.5、JDK源码解析</h3> 
<p>Integer类使用了享元模式。我们先看下面的例子：</p> 
<pre><code class="language-java">public class Test2 {
    public static void main(String[] args) {
        Integer i1 = 127;
        Integer i2 = 127;

        System.out.println("i1和i2对象是否是同一个对象：" + (i1 == i2));

        Integer i3 = 128;
        Integer i4 = 128;

        System.out.println("i3和i4对象是否是同一个对象：" + (i3 == i4));
    }
}

结果：
i1和i2对象是否是同一个对象：true
i3和i4对象是否是同一个对象：false</code></pre> 
<p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？Integer.valueOf()源码如下：</p> 
<pre><code class="language-java">public final class Integer extends Number implements Comparable&lt;Integer&gt; {
        private static class IntegerCache {
            static final int low = -128;
            static final int high;
            static final Integer cache[];

            static {
                // high value may be configured by property
                int h = 127;
                String integerCacheHighPropValue =
                    sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
                if (integerCacheHighPropValue != null) {
                    try {
                        int i = parseInt(integerCacheHighPropValue);
                        i = Math.max(i, 127);
                        // Maximum array size is Integer.MAX_VALUE
                        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                    } catch( NumberFormatException nfe) {
                        // If the property cannot be parsed into an int, ignore it.
                    }
                }
                high = h;

                cache = new Integer[(high - low) + 1];
                int j = low;
                for(int k = 0; k &lt; cache.length; k++)
                    cache[k] = new Integer(j++);

                // range [-128, 127] must be interned (JLS7 5.1.7)
                assert IntegerCache.high &gt;= 127;
            }

            private IntegerCache() {}
        }
    
    public static Integer valueOf(int i) {
        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    
}</code></pre> 
<p>Integer默认先创建并缓存-128到127之间数的Integer对象，当调用valueOf()时如果参数在-128到127之间则计算下标并从缓存中返回，否则会创建一个新的Integer对象。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8040ed611c6361be87d92f078607086c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MQTT基础知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf50ea31f56b6e86306903f9c0cb64e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">liunx下安装node exporter</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>