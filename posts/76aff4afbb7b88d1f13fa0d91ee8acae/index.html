<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32之串口/蓝牙控制led灯 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32之串口/蓝牙控制led灯" />
<meta property="og:description" content="该文章记录学习stm32串口遇到的一些问题，完整代码地址。
一、项目描述 通过串口或蓝牙发送指令来控制led灯。
open ------&gt; led 亮close ------&gt; led 灭其它 -------&gt; 反馈给串口或蓝牙错误指令 二、项目用到的模块 stm32 串口1,PA9(TX), PA10(RX)HC01 蓝牙模块，PA9(TX), PA10(RX)led灯, PB8 三、USART1关键配置说明 四、代码说明 main.c中主要代码如下：
#define UART1_REC_LEN 200 uint16_t UART1_RX_STA=0; uint8_t buf=0; // 接收缓冲, 串口接收到的数据放在这个数组里，最大UART1_REC_LEN个字节 uint8_t UART1_RX_Buffer[UART1_REC_LEN]; void SystemClock_Config(void); // 接收中断 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart-&gt;Instance != USART1) { return; } // 数据接收完成 if((UART1_RX_STA &amp; 0x8000) != 0) { HAL_UART_Receive_IT(&amp;huart1, &amp;buf, 1); return; } // 接收到回车之后判断后续的是不是换行，如果是换行，数据接收完成，但是还要开启一下中断 if(UART1_RX_STA&amp;0x4000) { UART1_RX_STA= (buf == 0x0a) ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/76aff4afbb7b88d1f13fa0d91ee8acae/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-18T09:14:22+08:00" />
<meta property="article:modified_time" content="2023-09-18T09:14:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32之串口/蓝牙控制led灯</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>该文章记录学习stm32串口遇到的一些问题，<a class="link-info" href="https://github.com/barry-source/embedded/tree/main/32/uart_test_intterrupt" title="完整代码地址">完整代码地址</a>。</p> 
<h4>一、项目描述</h4> 
<p>通过串口或蓝牙发送指令来控制led灯。</p> 
<ul><li><strong>open ------&gt; led 亮</strong></li><li><strong>close ------&gt; led 灭</strong></li><li><strong>其它  -------&gt; 反馈给串口或蓝牙错误指令</strong></li></ul> 
<h4>二、项目用到的模块</h4> 
<ol><li>stm32 串口1,PA9(TX), PA10(RX)</li><li><span style="color:#24292e;">HC01 蓝牙模块，</span>PA9(TX), PA10(RX)</li><li>led灯,  PB8</li></ol> 
<h4>三、USART1关键配置说明</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/34/e3/D2WXbbBR_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/9c/c4/jwQ48bff_o.png" width="1200"></p> 
<h4>四、代码说明</h4> 
<p>main.c中主要代码如下：</p> 
<pre><code class="language-cpp">#define UART1_REC_LEN 200

uint16_t UART1_RX_STA=0;
uint8_t buf=0;
// 接收缓冲, 串口接收到的数据放在这个数组里，最大UART1_REC_LEN个字节
uint8_t UART1_RX_Buffer[UART1_REC_LEN];

void SystemClock_Config(void);

// 接收中断
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
	if(huart-&gt;Instance != USART1) {
		return;
	}
	// 数据接收完成
	if((UART1_RX_STA &amp; 0x8000) != 0) {
		HAL_UART_Receive_IT(&amp;huart1, &amp;buf, 1);
		return;
	}
	// 接收到回车之后判断后续的是不是换行，如果是换行，数据接收完成，但是还要开启一下中断
	if(UART1_RX_STA&amp;0x4000) {
		UART1_RX_STA= (buf == 0x0a) ? (UART1_RX_STA| 0x8000) : 0;
	} else {
		// 接收到回车，将高第二位置1，否则继续接收数据
		if(buf == 0x0d) {
			UART1_RX_STA |= 0x4000;
		} else {
			UART1_RX_Buffer[UART1_RX_STA&amp;0x3fff] = buf;
			UART1_RX_STA ++;
			if(UART1_RX_STA &gt; UART1_REC_LEN - 1) {
				UART1_RX_STA = 0;
			}
		}
	}
	HAL_UART_Receive_IT(&amp;huart1, &amp;buf, 1);
}

int fputc(int ch, FILE *file) {
	unsigned char temp[1] = {ch};
	HAL_UART_Transmit(&amp;huart1, temp, 1, 0xfff);
	return ch;
}

int main(void)
{
  HAL_Init();

  SystemClock_Config();

  MX_GPIO_Init();
  MX_USART1_UART_Init();
  HAL_UART_Receive_IT(&amp;huart1, &amp;buf, 1);
  while (1)
  {
		if(UART1_RX_STA &amp; 0x8000)
		{
			printf("收到数据：");
			if(UART1_RX_Buffer[0] == '\0') continue;
			if(!strcmp((const char *)UART1_RX_Buffer, "open")) {
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);
			} else if(!strcmp((const char *)UART1_RX_Buffer, "close")){
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
			} else {
				printf("error code");
			}
			HAL_UART_Transmit(&amp;huart1, UART1_RX_Buffer, UART1_RX_STA &amp; 0x3fff, 0xffff);
			while(huart1.gState != HAL_UART_STATE_READY);
			UART1_RX_STA = 0;
		} else {
			printf("hello heart\r\n");
		}
		HAL_Delay(1000);
  }
}</code></pre> 
<h5>4.1、重定向printf打印功能到串口</h5> 
<p>重写fputc函数就可以重定向printf，里面就是调用了HAL库中串口的发送函数。</p> 
<pre><code class="language-cpp">int fputc(int ch, FILE *file) {
	unsigned char temp[1] = {ch};
	HAL_UART_Transmit(&amp;huart1, temp, 1, 0xfff);
	return ch;
}</code></pre> 
<p><strong>注意</strong>：这里需要在keil 选中Use Micro LIB,否则会不成功。</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/10/d0/aoBecTuf_o.png" width="364"></p> 
<h5>4.2、开启接收中断</h5> 
<p>初始化完成之后和接收中断函数调用完成之后，需要重新调用接收中断函数</p> 
<pre><code class="language-cpp">HAL_UART_Receive_IT(&amp;huart1, &amp;buf, 1);</code></pre> 
<h5>4.3、接收中断函数</h5> 
<p>这里定义一个uint16_t类型的UART1_RX_STA变量，其中</p> 
<ul><li>最高位表示是否数据完成</li><li>次高位表示是否接收了回车</li><li>其它位表示接收的字节数</li></ul> 
<p>注意点:</p> 
<ul><li><strong>中断函数最好不要有延时函数，可能会造成数据接收异常</strong></li><li><strong>中断函数最好不要打印函数，也可能导致时间过长，造成数据异常</strong></li><li><strong>双串口调试（正好板子上引出了两组USART1引脚）</strong></li><li><strong>串口和蓝牙同时连接时，最好只用一个发，要不然可能有影响</strong></li></ul> 
<h5>4.4、串口初始化函数</h5> 
<pre><code class="language-cpp">void MX_USART1_UART_Init(void)
{
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 9600;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&amp;huart1) != HAL_OK)
  {
    Error_Handler();
  }
}
</code></pre> 
<p>Instance类型<strong>USART_TypeDef</strong>，主要是串口包含的寄存器，USART1是一个宏，绑定串口1的物理地址，方式和之前介绍的<a class="link-info" href="https://blog.csdn.net/TSC1235/article/details/132890759" title="GPIO">GPIO</a>类似。</p> 
<p>另外USART1 是挂载到APB2总线上，其它串口挂载到APB1总线上。</p> 
<pre><code class="language-cpp">typedef struct
{
  __IO uint32_t SR;         /*!&lt; USART Status register,                   Address offset: 0x00 */
  __IO uint32_t DR;         /*!&lt; USART Data register,                     Address offset: 0x04 */
  __IO uint32_t BRR;        /*!&lt; USART Baud rate register,                Address offset: 0x08 */
  __IO uint32_t CR1;        /*!&lt; USART Control register 1,                Address offset: 0x0C */
  __IO uint32_t CR2;        /*!&lt; USART Control register 2,                Address offset: 0x10 */
  __IO uint32_t CR3;        /*!&lt; USART Control register 3,                Address offset: 0x14 */
  __IO uint32_t GTPR;       /*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */
} USART_TypeDef;</code></pre> 
<p> huart1 的类型是UART_HandleTypeDef，定义如下</p> 
<pre><code class="language-cpp">typedef struct __UART_HandleTypeDef
{
  USART_TypeDef                 *Instance;        
  UART_InitTypeDef              Init;             
  const uint8_t                 *pTxBuffPtr;      
  uint16_t                      TxXferSize;      
  __IO uint16_t                 TxXferCount;      
  uint8_t                       *pRxBuffPtr;     
  uint16_t                      RxXferSize;       

  __IO uint16_t                 RxXferCount;      

  __IO HAL_UART_RxTypeTypeDef ReceptionType;      
  __IO HAL_UART_RxEventTypeTypeDef RxEventType;   
  DMA_HandleTypeDef             *hdmatx;          

  DMA_HandleTypeDef             *hdmarx;          
  HAL_LockTypeDef               Lock;             

  __IO HAL_UART_StateTypeDef    gState;                                                           
  __IO HAL_UART_StateTypeDef    RxState;          
  __IO uint32_t                 ErrorCode;        

#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    
  void (* TxHalfCpltCallback)(struct __UART_HandleTypeDef *huart);        
          *******省略代码*******
#endif  /* USE_HAL_UART_REGISTER_CALLBACKS */

} UART_HandleTypeDef;</code></pre> 
<p> Init类型如下，主要是设置数据传输的配置。</p> 
<pre><code class="language-cpp">typedef struct
{
  uint32_t BaudRate;                 
  uint32_t WordLength;               
  uint32_t StopBits;                 
  uint32_t Parity;                   
  uint32_t Mode;                      
  uint32_t HwFlowCtl;                 
  uint32_t OverSampling;              
} UART_InitTypeDef;
</code></pre> 
<p>Init 主要配置波特率，字长，停止位等等。</p> 
<p>其实HAL库中的模块配置都很相似，包括GPIO, 定时器等。</p> 
<h6>4.4.1、HAL_UART_Init</h6> 
<p>主要操作如下，代码已经添加了注释</p> 
<pre><code class="language-cpp">HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  //判断 是否地址无效
  if (huart == NULL)
  {
    return HAL_ERROR;
  }
  // 流控制位有效或无效时的操作
  if (huart-&gt;Init.HwFlowCtl != UART_HWCONTROL_NONE)
  {
    // 流控制器只适用于串口1 2 3 
    assert_param(IS_UART_HWFLOW_INSTANCE(huart-&gt;Instance));
    assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart-&gt;Init.HwFlowCtl));
  }
  else
  {
    assert_param(IS_UART_INSTANCE(huart-&gt;Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart-&gt;Init.WordLength));
#if defined(USART_CR1_OVER8)
  assert_param(IS_UART_OVERSAMPLING(huart-&gt;Init.OverSampling));
#endif /* USART_CR1_OVER8 */

  if (huart-&gt;gState == HAL_UART_STATE_RESET)
  {
    // 先解锁再操作
    huart-&gt;Lock = HAL_UNLOCKED;

// 这里没有定义回调，只会走else
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    UART_InitCallbacksToDefault(huart);

    if (huart-&gt;MspInitCallback == NULL)
    {
      huart-&gt;MspInitCallback = HAL_UART_MspInit;
    }

    huart-&gt;MspInitCallback(huart);
#else
    //初始化GPIO，串口优先级等
    HAL_UART_MspInit(huart);
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart-&gt;gState = HAL_UART_STATE_BUSY;

  // 先关闭串口，再操作，最后打开串口
  __HAL_UART_DISABLE(huart);

  
  UART_SetConfig(huart);

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
 //异步模式下，USART_CR2的LINEN（局域网模式）和CLKEN（时钟使能）要清0
 // USART_CR3的SCEN, HDSE， IREN ，STOP（文档里有说明）要清0
  CLEAR_BIT(huart-&gt;Instance-&gt;CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  CLEAR_BIT(huart-&gt;Instance-&gt;CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));

  __HAL_UART_ENABLE(huart);

  // 设置串口的初始化状态
  huart-&gt;ErrorCode = HAL_UART_ERROR_NONE;
  huart-&gt;gState = HAL_UART_STATE_READY;
  huart-&gt;RxState = HAL_UART_STATE_READY;
  huart-&gt;RxEventType = HAL_UART_RXEVENT_TC;

  return HAL_OK;
}</code></pre> 
<p>UART_SetConfig 是串口的主要寄存器配置，核心代码如下</p> 
<pre><code class="language-cpp">static void UART_SetConfig(UART_HandleTypeDef *huart)
{
  uint32_t tmpreg;
  uint32_t pclk;
  // 设置停止位
  MODIFY_REG(huart-&gt;Instance-&gt;CR2, USART_CR2_STOP, huart-&gt;Init.StopBits);


// 根据Init.WordLength 配置USART1_CR1寄存器中各位

#if defined(USART_CR1_OVER8)
  tmpreg = (uint32_t)huart-&gt;Init.WordLength | huart-&gt;Init.Parity | huart-&gt;Init.Mode | huart-&gt;Init.OverSampling;
  MODIFY_REG(huart-&gt;Instance-&gt;CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart-&gt;Init.WordLength | huart-&gt;Init.Parity | huart-&gt;Init.Mode;
  MODIFY_REG(huart-&gt;Instance-&gt;CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
             tmpreg);
#endif /* USART_CR1_OVER8 */

  // 配置USART1_CR3寄存器中的RTSE（RTS使能）,CTSE(CTS使能)
  MODIFY_REG(huart-&gt;Instance-&gt;CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart-&gt;Init.HwFlowCtl);

  // 配置时钟
  if(huart-&gt;Instance == USART1)
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
  }

  // 配置波特率
#if defined(USART_CR1_OVER8)
  if (huart-&gt;Init.OverSampling == UART_OVERSAMPLING_8)
  {
    huart-&gt;Instance-&gt;BRR = UART_BRR_SAMPLING8(pclk, huart-&gt;Init.BaudRate);
  }
  else
  {
    huart-&gt;Instance-&gt;BRR = UART_BRR_SAMPLING16(pclk, huart-&gt;Init.BaudRate);
  }
#else
  huart-&gt;Instance-&gt;BRR = UART_BRR_SAMPLING16(pclk, huart-&gt;Init.BaudRate);
#endif /* USART_CR1_OVER8 */
}</code></pre> 
<p>pclk的获取，这里大致分析下它的实现</p> 
<pre><code class="language-cpp">uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  // HAL_RCC_GetHCLKFreq 最终获取的是系统核心时钟16000000hz
  // CFGR是时钟配置寄存器，这里要配置的是PPRE2,在11-13位，APB预分频（APB2）
  // RCC_CFGR_PPRE2 = 11 1000 0000 0000 正好对应11-13位
  // RCC_CFGR_PPRE2_Pos = 8
  // const uint8_t APBPrescTable[8U] =  {0, 0, 0, 0, 1, 2, 3, 4};
  // APBPrescTable[(RCC-&gt;CFGR &amp; RCC_CFGR_PPRE2) &gt;&gt; RCC_CFGR_PPRE2_Pos] 这个操作是获取分频系数
  // 获取之后将 16000000hz 相除
  return (HAL_RCC_GetHCLKFreq() &gt;&gt; APBPrescTable[(RCC-&gt;CFGR &amp; RCC_CFGR_PPRE2) &gt;&gt; RCC_CFGR_PPRE2_Pos]);
}</code></pre> 
<p>五、效果图</p> 
<p><img alt="" height="415" src="https://images2.imgbox.com/29/aa/ppZvWB8S_o.jpg" width="187"><img alt="" height="416" src="https://images2.imgbox.com/ba/08/6nBPtE73_o.jpg" width="187"><img alt="" height="413" src="https://images2.imgbox.com/49/37/TZwPIt2t_o.jpg" width="186"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67694476d1a43e254a22ad508f78942d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux驱动之INPUT设备驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53c0fbb83030c97ba84426a422d4d63d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">清理buff/cache和swap空间释放</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>