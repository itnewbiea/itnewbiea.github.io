<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【题解】进击的奶牛 洛谷P1824 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【题解】进击的奶牛 洛谷P1824" />
<meta property="og:description" content="题目请戳：洛谷P1824 进击的奶牛
题目描述 Farmer John建造了一个有N(2&lt;=N&lt;=100,000)个隔间的牛棚，这些隔间分布在一条直线上，坐标是x1,…,xN (0&lt;=xi&lt;=1,000,000,000)。
他的C(2&lt;=C&lt;=N)头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？
输入格式 第1行：两个用空格隔开的数字N和C。
第2~N&#43;1行：每行一个整数，表示每个隔间的坐标。
输出格式 输出只有一行，即相邻两头牛最大的最近距离。
输入输出样例 输入 5 3 1 2 8 4 9 输出 3 解题思路 首先牛棚的分布是x1,...,xN (0&lt;=xi&lt;=1,000,000,000)， 1 0 10 10^{10} 1010 &lt; 1 0 8 10^8 108 暴力肯定会TLE
那么我们如何减少时间复杂度呢。枚举每一种可行解是不大可行了。但是如果给出一个猜测解，去验证这个解是否可行就容易得多。也就是我们先在范围x1~xN内随便猜一个可能的间隔mid，然后验证如果每两头牛之间至少相邻mid个牛棚是否可行。
如果这个mid可行，则不用考虑比它小的解了（比mid小的解可能可行，但题目要求的是最大的可行mid）如果我们取的mid位于可行区间中点左右的位置，一下就排除了一半！！（雨巨：“是不是很快乐！！” ๑乛◡乛๑）
而如果当前猜测的mid不可行，则比它大的解也不用考虑了（因为一定不可行）
于是我们的思路从枚举寻找两头最近牛之间的最大距离，变成了给一个距离判断这个距离是否可行。
（好啦二分的思路讲完啦）
简单地说，就是每次取一个临近中点的点，判断这个点的值是否满足条件。是则取这个点的右半边继续上述过程。否则取这个点的左半边继续上述过程。
接下来上代码：
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; int n,a[100005],c; int check(int low, int high){ int dis; while(low &lt;= high){ int cow = c - 1;//第一头牛已放入第一个隔间 dis = low &#43; (high - low) / 2;//二分设定距离 这种写法防爆int if( dis == low ) break; //与low相等，说明该数据已经测试过可行且无法再找到更优解 int i = 0, flag = 1,tar; while(cow){ tar = a[i] &#43; dis; if( a[n-1] &lt; tar){ flag = 0; break; } while(a[i] &lt; tar &amp;&amp; i &lt; n) //找到下一个满足距离的隔间 i&#43;&#43;; cow--; } if(flag) //更新可行解的区间[low,high) low = dis; else high = dis; } return dis; } int main(){ cin&gt;&gt;n&gt;&gt;c; for(int i = 0; i &lt; n; i&#43;&#43;) cin&gt;&gt;a[i]; sort(a, a &#43; n); cout&lt;&lt;check(1, a[n - 1] - a[0]); return 0; } 其实check和二分是可以分开的看起来清楚一些。我直接混在一起写了一个函数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6da0ba0e280dc14b57f56a1e46c3c59d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-22T22:27:09+08:00" />
<meta property="article:modified_time" content="2020-05-22T22:27:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【题解】进击的奶牛 洛谷P1824</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>题目请戳：<a href="https://www.luogu.com.cn/problem/P1824" rel="nofollow">洛谷P1824 进击的奶牛</a></p> 
<h3><a id="_1"></a>题目描述</h3> 
<p>Farmer John建造了一个有N(2&lt;=N&lt;=100,000)个隔间的牛棚，这些隔间分布在一条直线上，坐标是x1,…,xN (0&lt;=xi&lt;=1,000,000,000)。</p> 
<p>他的C(2&lt;=C&lt;=N)头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？</p> 
<h3><a id="_5"></a>输入格式</h3> 
<p>第1行：两个用空格隔开的数字N和C。</p> 
<p>第2~N+1行：每行一个整数，表示每个隔间的坐标。</p> 
<h3><a id="_10"></a>输出格式</h3> 
<p>输出只有一行，即相邻两头牛最大的最近距离。</p> 
<h3><a id="_13"></a>输入输出样例</h3> 
<h5><a id="_14"></a>输入</h5> 
<pre><code>5 3
1 
2 
8 
4 
9 
</code></pre> 
<h5><a id="_22"></a>输出</h5> 
<pre><code>3
</code></pre> 
<h3><a id="_25"></a>解题思路</h3> 
<p>首先牛棚的分布是<code>x1,...,xN (0&lt;=xi&lt;=1,000,000,000)</code>，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
        
        
          0 
         
        
          10 
         
        
       
      
        10^{10} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></span> &lt; <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         1 
        
        
        
          0 
         
        
          8 
         
        
       
      
        10^8 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 暴力肯定会TLE</p> 
<p>那么我们如何减少时间复杂度呢。枚举每一种可行解是不大可行了。但是如果给出一个猜测解，去验证这个解是否可行就容易得多。也就是我们先在范围<code>x1~xN</code>内随便猜一个可能的间隔<code>mid</code>，然后验证如果每两头牛之间至少相邻<code>mid</code>个牛棚是否可行。</p> 
<p>如果这个<code>mid</code>可行，则不用考虑比它小的解了（比<code>mid</code>小的解可能可行，但题目要求的是最大的可行<code>mid</code>）如果我们取的<code>mid</code>位于可行区间中点左右的位置，一下就排除了一半！！（雨巨：“是不是很快乐！！” ๑乛◡乛๑）</p> 
<p>而如果当前猜测的<code>mid</code>不可行，则比它大的解也不用考虑了（因为一定不可行）</p> 
<p>于是我们的思路从枚举寻找两头最近牛之间的最大距离，变成了给一个距离判断这个距离是否可行。</p> 
<p>（好啦二分的思路讲完啦）</p> 
<p>简单地说，就是每次取一个临近中点的点，判断这个点的值是否满足条件。是则取这个点的右半边继续上述过程。否则取这个点的左半边继续上述过程。</p> 
<p>接下来上代码：</p> 
<pre><code class="prism language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;map&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">100005</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> dis<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> cow <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//第一头牛已放入第一个隔间</span>
        dis <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//二分设定距离 这种写法防爆int</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> dis <span class="token operator">==</span> low <span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">//与low相等，说明该数据已经测试过可行且无法再找到更优解</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>tar<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cow<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            tar <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dis<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> a<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> tar<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> tar <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>  <span class="token comment">//找到下一个满足距离的隔间</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            cow<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>    <span class="token comment">//更新可行解的区间[low,high)</span>
            low <span class="token operator">=</span> dis<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            high <span class="token operator">=</span> dis<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dis<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cin<span class="token operator">&gt;&gt;</span>n<span class="token operator">&gt;&gt;</span>c<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        cin<span class="token operator">&gt;&gt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">check</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其实check和二分是可以分开的看起来清楚一些。我直接混在一起写了一个函数。</p> 
<p>顺带一提。判断边界或者返回值最好的办法就是带几组数据进去试一下。还可以用我这组样例试试：</p> 
<h5><a id="_84"></a>输入</h5> 
<pre><code>5 3
1 
2 
6 
4 
5 
</code></pre> 
<h5><a id="_92"></a>输出</h5> 
<pre><code>2
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61ef4b4ea8956f9071d39af2fa664853/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux常用命令之grep命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35977cb5531782577bff647185000787/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【看这个就够了】Python中split()方法深度解析(看完这个你再不会算我输)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>