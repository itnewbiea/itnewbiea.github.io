<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sparkSQL自定义聚合函数（UDAF）实现bitmap函数 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sparkSQL自定义聚合函数（UDAF）实现bitmap函数" />
<meta property="og:description" content="创建测试表
使用phoenix在HBase中创建测试表，字段使用VARBINARY类型
CREATE TABLE IF NOT EXISTS test_binary (
date VARCHAR NOT NULL,
dist_mem VARBINARY
CONSTRAINT test_binary_pk PRIMARY KEY (date)
) SALT_BUCKETS=6;
创建完成后使用RoaringBitmap序列化数据存入数据库：
实现自定义聚合函数bitmap
import org.apache.spark.sql.Row;
import org.apache.spark.sql.expressions.MutableAggregationBuffer;
import org.apache.spark.sql.expressions.UserDefinedAggregateFunction;
import org.apache.spark.sql.types.DataType;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.StructField;
import org.apache.spark.sql.types.StructType;
import org.roaringbitmap.RoaringBitmap;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
/**
* 实现自定义聚合函数Bitmap
*/
public class UdafBitMap extends UserDefinedAggregateFunction {
@Override
public StructType inputSchema() {
List&lt;StructField&gt; structFields = new ArrayList&lt;&gt;();
structFields.add(DataTypes.createStructField(&#34;field&#34;, DataTypes.BinaryType, true));" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8fdc10a034c40ce45936ca3949fd6e29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-07T19:50:14+08:00" />
<meta property="article:modified_time" content="2019-02-07T19:50:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sparkSQL自定义聚合函数（UDAF）实现bitmap函数</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>创建测试表<br> 使用phoenix在HBase中创建测试表，字段使用VARBINARY类型</p> 
<p>CREATE TABLE IF NOT EXISTS test_binary (<br> date VARCHAR NOT NULL,<br> dist_mem VARBINARY<br>  CONSTRAINT test_binary_pk PRIMARY KEY (date)<br>  ) SALT_BUCKETS=6;<br>  创建完成后使用RoaringBitmap序列化数据存入数据库：</p> 
<p>实现自定义聚合函数bitmap<br> import org.apache.spark.sql.Row;<br> import org.apache.spark.sql.expressions.MutableAggregationBuffer;<br> import org.apache.spark.sql.expressions.UserDefinedAggregateFunction;<br> import org.apache.spark.sql.types.DataType;<br> import org.apache.spark.sql.types.DataTypes;<br> import org.apache.spark.sql.types.StructField;<br> import org.apache.spark.sql.types.StructType;<br> import org.roaringbitmap.RoaringBitmap;<br>  <br> import java.io.*;<br> import java.util.ArrayList;<br> import java.util.List;<br>  <br> /**<br>  * 实现自定义聚合函数Bitmap<br>  */<br> public class UdafBitMap extends UserDefinedAggregateFunction {<!-- --><br>     @Override<br>     public StructType inputSchema() {<!-- --><br>         List&lt;StructField&gt; structFields = new ArrayList&lt;&gt;();<br>         structFields.add(DataTypes.createStructField("field", DataTypes.BinaryType, true));<br>         return DataTypes.createStructType(structFields);<br>     }<br>  <br>     @Override<br>     public StructType bufferSchema() {<!-- --><br>         List&lt;StructField&gt; structFields = new ArrayList&lt;&gt;();<br>         structFields.add(DataTypes.createStructField("field", DataTypes.BinaryType, true));<br>         return DataTypes.createStructType(structFields);<br>     }<br>  <br>     @Override<br>     public DataType dataType() {<!-- --><br>         return DataTypes.LongType;<br>     }<br>  <br>     @Override<br>     public boolean deterministic() {<!-- --><br>         //是否强制每次执行的结果相同<br>         return false;<br>     }<br>  <br>     @Override<br>     public void initialize(MutableAggregationBuffer buffer) {<!-- --><br>         //初始化<br>         buffer.update(0, null);<br>     }<br>  <br>     @Override<br>     public void update(MutableAggregationBuffer buffer, Row input) {<!-- --><br>         // 相同的executor间的数据合并<br>         // 1. 输入为空直接返回不更新<br>         Object in = input.get(0);<br>         if(in == null){<!-- --><br>             return ;<br>         }<br>         // 2. 源为空则直接更新值为输入<br>         byte[] inBytes = (byte[]) in;<br>         Object out = buffer.get(0);<br>         if(out == null){<!-- --><br>             buffer.update(0, inBytes);<br>             return ;<br>         }<br>         // 3. 源和输入都不为空使用bitmap去重合并<br>         byte[] outBytes = (byte[]) out;<br>         byte[] result = outBytes;<br>         RoaringBitmap outRR = new RoaringBitmap();<br>         RoaringBitmap inRR = new RoaringBitmap();<br>         try {<!-- --><br>             outRR.deserialize(new DataInputStream(new ByteArrayInputStream(outBytes)));<br>             inRR.deserialize(new DataInputStream(new ByteArrayInputStream(inBytes)));<br>             outRR.or(inRR);<br>             ByteArrayOutputStream bos = new ByteArrayOutputStream();<br>             outRR.serialize(new DataOutputStream(bos));<br>             result = bos.toByteArray();<br>         } catch (IOException e) {<!-- --><br>             e.printStackTrace();<br>         }<br>         buffer.update(0, result);<br>     }<br>  <br>     @Override<br>     public void merge(MutableAggregationBuffer buffer1, Row buffer2) {<!-- --><br>         //不同excutor间的数据合并<br>         update(buffer1, buffer2);<br>     }<br>  <br>     @Override<br>     public Object evaluate(Row buffer) {<!-- --><br>         //根据Buffer计算结果<br>         long r = 0l;<br>         Object val = buffer.get(0);<br>         if (val != null) {<!-- --><br>             RoaringBitmap rr = new RoaringBitmap();<br>             try {<!-- --><br>                 rr.deserialize(new DataInputStream(new ByteArrayInputStream((byte[]) val)));<br>                 r = rr.getLongCardinality();<br>             } catch (IOException e) {<!-- --><br>                 e.printStackTrace();<br>             }<br>         }<br>         return r;<br>     }<br> }<br> 调用示例<br>  /**<br>      * 使用自定义函数解析bitmap<br>      *<br>      * @param sparkSession<br>      * @return<br>      */<br>     private static void udafBitmap(SparkSession sparkSession) {<!-- --><br>         try {<!-- --><br>             Properties prop = PropUtil.loadProp(DB_PHOENIX_CONF_FILE);<br>             // JDBC连接属性<br>             Properties connProp = new Properties();<br>             connProp.put("driver", prop.getProperty(DB_PHOENIX_DRIVER));<br>             connProp.put("user", prop.getProperty(DB_PHOENIX_USER));<br>             connProp.put("password", prop.getProperty(DB_PHOENIX_PASS));<br>             connProp.put("fetchsize", prop.getProperty(DB_PHOENIX_FETCHSIZE));<br>             // 注册自定义聚合函数<br>             sparkSession.udf().register("bitmap",new UdafBitMap());<br>             sparkSession<br>                     .read()<br>                     .jdbc(prop.getProperty(DB_PHOENIX_URL), "test_binary", connProp)<br>                     // sql中必须使用global_temp.表名，否则找不到<br>                     .createOrReplaceGlobalTempView("test_binary");<br>             //sparkSession.sql("select YEAR(TO_DATE(date)) year,bitmap(dist_mem) memNum from global_temp.test_binary group by YEAR(TO_DATE(date))").show();<br>             sparkSession.sql("select date,bitmap(dist_mem) memNum from global_temp.test_binary group by date").show();<br>         } catch (Exception e) {<!-- --><br>             e.printStackTrace();<br>         }<br>     }<br> 结果：</p> 
<p>+----------+------+<br> |      date|memNum|<br> +----------+------+<br> |2017-01-06| 19762|<br> |2017-01-09| 22320|<br> |2017-01-02| 13156|<br> |2017-01-01|  9738|<br> |2017-01-03| 21543|<br> |2017-01-04| 21850|<br> |2017-01-08| 17359|<br> |2017-01-05| 20129|<br> |2017-01-07| 18347|<br> +----------+------+<br>  <br> --------------------- <br><br> ref：https://blog.csdn.net/xiongbingcool/article/details/81282118 <br>  </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/82ae50fa5bdff2091a52d5afec782abd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java趣味编程案例21----最小公倍数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7590adf2ec5913bef8d27271897b3bf5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js中递归调用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>