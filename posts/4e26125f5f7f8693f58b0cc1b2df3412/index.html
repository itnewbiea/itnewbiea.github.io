<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大数据存储技术（4）—— NoSQL数据库 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="大数据存储技术（4）—— NoSQL数据库" />
<meta property="og:description" content="目录
前言
一、键值数据库Redis
（一）Redis简介
（二）Redis数据类型
（三）Redis持久化
二、列存储数据库HBase
（一）简介
（二）HBase数据表
（三）Hbase物理存储
三、文档数据库MongoDB
（一）MongoDB简介
（二）MongoDB基本概念
四、图数据库Neo4j
（一）Neo4j与知识图谱
（二）Neo4j的核心概念
前言 NoSQL（Not Only SQL），意即“不仅仅是SQL”。NoSQL的拥护者提倡运用非关系型的数据存储作为大数据存储的重要补充。NoSQL数据库适用于数据模型比较简单、IT系统需要更强的灵活性、对数据库性能要求较高且不需要高度的数据一致性等场景。
NoSQL数据库具有如下四大分类：
1、键值（Key-Value）存储数据库：常见的键值存储数据库有Tokyo Cabinet / Tyrant、Berkeley DB、MemcacheDB、Redis等。
2、列存储数据库：如HBase、Cassandra、Riak等。
3、文档型数据库：常见的文档型数据库有MongoDB、CouchDB、SequoiaDB等。
4、图（Graph）数据库：诸如Neo4J、InfoGrid、Infinite Graph等。
一、键值数据库Redis （一）Redis简介 Redis（REmote DIctionary Server）是一个由Salvatore Sanfilippo写的Key-Value内存数据库，能达到每秒十万次的读写，常用作缓存或者消息队列。 Redis是使用ANSI C语言编写的，遵守BSD协议，支持网络并可基于内存和可持久化的日志型Key-Value数据库，提供多种语言的API。 Redis数据库中的值（value）可以是字符串（string）、哈希（map）、列表（list）、集合（sets）和有序集合（sorted sets）等类型。
与其他Key-Value缓存产品相比，Redis主要具有以下三个特点： 首先，Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时可以再次加载使用； 其次，Redis不仅仅支持简单的Key-Value类型的数据，同时还提供list、set、zset、hash等数据结构的存储。 最后，Redis还支持数据的备份，即Master/Slave模式的数据备份，可以将数据从主服务器复制到任意数量的从服务器。 Redis运行在内存中并可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单。
（二）Redis数据类型 Redis支持5种数据类型：string（字符串）、hash（哈希）、list（列表）、set（集合）及zset。
1、string（字符串）
字符串是最常用的一种数据类型，普通的Key/Value存储都可以归为此类。
2、hash（哈希）
哈希是一个string类型的field和value的映射表。hash特别适合存储对象，相当于将对象的每个字段存成单个string类型。Redis的hash实际是将内部存储的value作为一个HashMap，并提供了直接存取这个Map成员的接口，如图所示为Redis中的哈希结构。
3、list（列表）
列表是一个链表结构，可以从头部（左边）或者尾部（右边）添加和删除元素。Redis的list类型其实就是每个子元素都是string类型的双向链表，我们可以通过push或pop操作从链表两端添加删除元素。
4、set（集合）
set是string类型的无序不重复集合。set是通过hash table实现的。可以对集合采取并集、交集、差集操作；还可以使用不同的命令将结果返回给客户端并且存到一个新的集合中。
5、zset
zset在set的基础上增加了一个顺序的属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以将其理解为有列的表，一列存value，一列存顺序，操作中key理解为zset的名字。
（三）Redis持久化 Redis将内存中的数据同步到磁盘来保证持久化。Redis主要支持使用Snapshotting（快照）和Append-only file（aof）两种方式实现数据的持久化。
1、Snapshotting
快照是默认的持久化方式。这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。可以通过配置设置自动做快照，比如可以配置Redis在n秒内如果超过m个key被修改就自动做快照。
2、Append-only file
Append-only file方式比快照方式有更好的持久化性，是由于在使用aof方式进行数据的持久化时，Redis会将每一个收到的写命令都通过write()函数追加到文件中。当redis重启时会通过重新执行文件中保存的写命令，在内存中重建整个数据库的内容。当然由于操作系统会在内核中缓存写操作所做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失部分修改。不过可以通过配置文件告知Redis通过fsync函数强制操作系统写入到磁盘的策略。
二、列存储数据库HBase （一）简介 HBase是一个分布式的、面向列的开源数据库。它主要用来存储非结构化和半结构化的松散数据，是基于列而非行进行数据存储的。HBase建立在HDFS之上，仅能通过主键（row key）和主键的range来检索数据，仅支持单行事务，可以通过Hive支持来实现多表join等复杂操作。它还可以横向扩展，增加廉价的商用服务器来提高HBase的计算和存储能力。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4e26125f5f7f8693f58b0cc1b2df3412/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-20T12:49:51+08:00" />
<meta property="article:modified_time" content="2023-12-20T12:49:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大数据存储技术（4）—— NoSQL数据库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93Redis-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93Redis" rel="nofollow">一、键值数据库Redis</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89Redis%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89Redis%E7%AE%80%E4%BB%8B" rel="nofollow">（一）Redis简介</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">（二）Redis数据类型</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89Redis%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89Redis%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">（三）Redis持久化</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%88%97%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93HBase-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%88%97%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93HBase" rel="nofollow">二、列存储数据库HBase</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E4%BB%8B" rel="nofollow">（一）简介</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89HBase%E6%95%B0%E6%8D%AE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89HBase%E6%95%B0%E6%8D%AE%E8%A1%A8" rel="nofollow">（二）HBase数据表</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89Hbase%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89Hbase%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8" rel="nofollow">（三）Hbase物理存储</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB" rel="nofollow">三、文档数据库MongoDB</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89MongoDB%E7%AE%80%E4%BB%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89MongoDB%E7%AE%80%E4%BB%8B" rel="nofollow">（一）MongoDB简介</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89MongoDB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89MongoDB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">（二）MongoDB基本概念</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j" rel="nofollow">四、图数据库Neo4j</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89Neo4j%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89Neo4j%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1" rel="nofollow">（一）Neo4j与知识图谱</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89Neo4j%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89Neo4j%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" rel="nofollow">（二）Neo4j的核心概念</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>前言</h3> 
<p style="text-align:justify;">        NoSQL（Not Only SQL），意即“不仅仅是SQL”。NoSQL的拥护者提倡运用非关系型的数据存储作为大数据存储的重要补充。NoSQL数据库适用于数据模型比较简单、IT系统需要更强的灵活性、对数据库性能要求较高且不需要高度的数据一致性等场景。</p> 
<p style="text-align:justify;">        NoSQL数据库具有如下<strong>四大分类</strong>：<br> 1、键值（Key-Value）存储数据库：常见的键值存储数据库有Tokyo Cabinet / Tyrant、Berkeley DB、MemcacheDB、Redis等。<br> 2、列存储数据库：如HBase、Cassandra、Riak等。<br> 3、文档型数据库：常见的文档型数据库有MongoDB、CouchDB、SequoiaDB等。<br> 4、图（Graph）数据库：诸如Neo4J、InfoGrid、Infinite Graph等。</p> 
<h3 id="%E4%B8%80%E3%80%81%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93Redis" style="text-align:justify;">一、键值数据库Redis</h3> 
<h4 id="%EF%BC%88%E4%B8%80%EF%BC%89Redis%E7%AE%80%E4%BB%8B" style="text-align:justify;">（一）Redis简介</h4> 
<p style="text-align:justify;">        Redis（REmote DIctionary Server）是一个由Salvatore Sanfilippo写的Key-Value内存数据库，能达到每秒十万次的读写，常用作缓存或者消息队列。 Redis是使用ANSI C语言编写的，遵守BSD协议，支持网络并可基于内存和可持久化的日志型Key-Value数据库，提供多种语言的API。 Redis数据库中的值（value）可以是字符串（string）、哈希（map）、列表（list）、集合（sets）和有序集合（sorted sets）等类型。<br>         与其他Key-Value缓存产品相比，Redis主要具有以下三个特点： 首先，Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启时可以再次加载使用； 其次，Redis不仅仅支持简单的Key-Value类型的数据，同时还提供list、set、zset、hash等数据结构的存储。 最后，Redis还支持数据的备份，即Master/Slave模式的数据备份，可以将数据从主服务器复制到任意数量的从服务器。 Redis运行在内存中并可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单。</p> 
<h4 id="%EF%BC%88%E4%BA%8C%EF%BC%89Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">（二）Redis数据类型</h4> 
<p style="text-align:justify;">        Redis支持5种数据类型：string（字符串）、hash（哈希）、list（列表）、set（集合）及zset。</p> 
<p style="text-align:justify;"><strong>1、string（字符串）</strong><br>         字符串是最常用的一种数据类型，普通的Key/Value存储都可以归为此类。</p> 
<p style="text-align:justify;"><strong>2、hash（哈希）</strong><br>         哈希是一个string类型的field和value的映射表。hash特别适合存储对象，相当于将对象的每个字段存成单个string类型。Redis的hash实际是将内部存储的value作为一个HashMap，并提供了直接存取这个Map成员的接口，如图所示为Redis中的哈希结构。</p> 
<p class="img-center"><img alt="" height="252" src="https://images2.imgbox.com/91/24/8FiGabvT_o.png" width="500"></p> 
<p style="text-align:justify;"><strong>3、list（列表）</strong><br>         列表是一个链表结构，可以从头部（左边）或者尾部（右边）添加和删除元素。Redis的list类型其实就是每个子元素都是string类型的双向链表，我们可以通过push或pop操作从链表两端添加删除元素。</p> 
<p style="text-align:justify;"><strong>4、set（集合）</strong><br>         set是string类型的无序不重复集合。set是通过hash table实现的。可以对集合采取并集、交集、差集操作；还可以使用不同的命令将结果返回给客户端并且存到一个新的集合中。</p> 
<p style="text-align:justify;"><strong>5、zset</strong><br>         zset在set的基础上增加了一个顺序的属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以将其理解为有列的表，一列存value，一列存顺序，操作中key理解为zset的名字。</p> 
<h4 id="%EF%BC%88%E4%B8%89%EF%BC%89Redis%E6%8C%81%E4%B9%85%E5%8C%96" style="text-align:justify;">（三）Redis持久化</h4> 
<p style="text-align:justify;">        Redis将内存中的数据同步到磁盘来保证持久化。Redis主要支持使用Snapshotting（快照）和Append-only file（aof）两种方式实现数据的持久化。</p> 
<p style="text-align:justify;"><strong>1、Snapshotting</strong><br>         快照是默认的持久化方式。这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。可以通过配置设置自动做快照，比如可以配置Redis在n秒内如果超过m个key被修改就自动做快照。</p> 
<p style="text-align:justify;"><strong>2、Append-only file</strong><br>         Append-only file方式比快照方式有更好的持久化性，是由于在使用aof方式进行数据的持久化时，Redis会将每一个收到的写命令都通过write()函数追加到文件中。当redis重启时会通过重新执行文件中保存的写命令，在内存中重建整个数据库的内容。当然由于操作系统会在内核中缓存写操作所做的修改，所以可能不是立即写到磁盘上，这样aof方式的持久化也还是有可能会丢失部分修改。不过可以通过配置文件告知Redis通过fsync函数强制操作系统写入到磁盘的策略。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%88%97%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93HBase" style="text-align:justify;">二、列存储数据库HBase</h3> 
<h4 id="%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E4%BB%8B">（一）简介</h4> 
<p style="text-align:justify;">        HBase是一个分布式的、面向列的开源数据库。它主要用来存储非结构化和半结构化的松散数据，是基于列而非行进行数据存储的。HBase建立在HDFS之上，仅能通过主键（row key）和主键的range来检索数据，仅支持单行事务，可以通过Hive支持来实现多表join等复杂操作。它还可以横向扩展，增加廉价的商用服务器来提高HBase的计算和存储能力。</p> 
<p style="text-align:justify;">        在一个HBase集群中一般存在Client、HMaster、HRegionServer、Zookeeper四种角色，如图所示为HBase部署架构。</p> 
<p class="img-center"><img alt="" height="442" src="https://images2.imgbox.com/3e/6e/yneCwOUQ_o.png" width="900"></p> 
<p style="text-align:justify;"><strong>1、Client</strong><br>         客户端包含访问HBase的接口，并维护Cache来加快对HBase的访问，比如Region的位置信息。</p> 
<p style="text-align:justify;"><strong>2、HMaster </strong><br>         HMaster在功能上主要负责Table和Region的管理工作，包括：<br>         （1）管理用户对Table的增、删、改、查操作；<br>         （2）管理HRegionServer的负载均衡，调整Region分布；<br>         （3）在Region Split后，负责新Region的分配；<br>         （4）在HRegionServer停机后，负责失效HRegionServer上的Regions迁移。<br>         Region是HBase数据管理的基本单位。数据的move、balance、split，都是按照Region来进行操作的。<br>         HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行。</p> 
<p style="text-align:justify;"><strong>3、HRegionServer</strong><br>         HRegionServer主要负责响应用户I/O请求，向HDFS文件系统中读写数据，是HBase中最核心的模块。HRegionServer内部管理了一系列HRegion对象，每个HRegion对应了Table中的一个Region，HRegion由多个HStore组成。每个HStore对应了Table中的一个Column Family的存储，每个Column Family就是一个集中的存储单元。因此将具备共同IO特性的Column放在一个Column Family中，会提高存储效率。</p> 
<p style="text-align:justify;"><strong>4、Zookeeper</strong><br>         Zookeeper Quorum中除存储了HBase内置表-ROOT-的地址和HMaster的地址外，HRegionServer也会把自己相关信息注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的健康状态。此外，Zookeeper也避免了HMaster的单点问题。</p> 
<h4 id="%EF%BC%88%E4%BA%8C%EF%BC%89HBase%E6%95%B0%E6%8D%AE%E8%A1%A8" style="text-align:justify;">（二）HBase数据表</h4> 
<p style="text-align:justify;">        相较于传统的数据表，<strong>HBase中的数据表</strong>一般有这样一些<strong>特点</strong>：<br>         （1）大表，一个表可以有上亿行，上百万列；<br>         （2）面向列（族）的存储和权限控制，列（族）独立检索；<br>         （3）稀疏表结构，对于为空（null）的列，并不占用存储空间。<br>         表的逻辑结构如图所示，表由行和列组成。列划分为若干个列族（row family）。</p> 
<p class="img-center"><img alt="" height="192" src="https://images2.imgbox.com/fc/03/NIgSKf4E_o.png" width="900"></p> 
<p style="text-align:justify;"><strong>1、行键</strong><br>         行键Row Key是用来检索记录的主键。访问HBase Table中的行，要么通过单个Row Key访问，要么通过Row Key的Range，要么就是进行全表扫描。行键（Row Key）可以是任意字符串（最大长度是64KB，实际应用中长度一般为10～100 bytes），在HBase内部，Row Key保存为字节数组。</p> 
<p style="text-align:justify;"><strong>2、列族</strong><br>         HBase表中的每个列，都归属于某个列族（Column Family）。列族是表的一部分，而列不是，列簇必须在使用表之前定义，列名都以列族作为前缀。例如courses:history，courses:math都属于courses这个列族。</p> 
<p style="text-align:justify;"><strong>3、时间戳</strong><br>         HBase中通过行键和列确定的一个存储单元称为cell。每个cell都保存着同一份数据的多个版本，版本通过时间戳（Timestamp）来索引。时间戳的类型是64位整型。时间戳可以由HBase在数据写入时自动赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值。</p> 
<h4 id="%EF%BC%88%E4%B8%89%EF%BC%89Hbase%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8" style="text-align:justify;">（三）Hbase物理存储</h4> 
<p style="text-align:justify;">        HBase的数据表中的所有行都按照行键的字典序排列。在存储时，Table在行的方向上分割为多个HRegion。HRegion是按大小分割的，每个表一开始只有一个region，随着数据不断插入表，region不断增大，当增大到一个阀值的时候，Hregion就会等分为两个新的HRegion。 当Table中的行不断增多，就会有越来越多的HRegion。<br>         <strong>HRegion是HBase中分布式存储和负载均衡的最小单元</strong>，不同的HRegion可分布在不同的HRegion server上，但一个HRegion是不会拆分到多个Server上的。一个HRegion由一个或者多个Store组成，每个Store保存一个columns family。每个Strore又由一个MemStore和0～多个StoreFile组成。<strong>StoreFile以HFile格式保存在HDFS上</strong>。<br>         HFile分为如下六个部分：<br> （1）Data Block段：保存表中的数据，这部分可以被压缩。<br> （2）Meta Block段（可选的）：保存用户自定义的键值对，可以被压缩。<br> （3）File Info段：HFile的元信息，不被压缩，用户也可以在这一部分添加自己的元信息。<br> （4）Data Block Index段：Data Block的索引，每条索引的key是被索引的block的第一条记录的key。<br> （5）Meta Block Index段（可选的）：Meta Block的索引。<br> （6）Trailer：这一段是定长的。保存了每一段的偏移量，读取一个HFile时，会首先读取Trailer，Trailer保存了每个段的起始位置，然后，DataBlock Index会被读取到内存中。<br>         为了应对灾难恢复，每个Region Server维护一个HLog，HLog记录数据的所有变更，一旦数据修改，就可以从log中进行恢复。</p> 
<h3 id="%E4%B8%89%E3%80%81%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB" style="text-align:justify;">三、文档数据库MongoDB</h3> 
<h4 id="%EF%BC%88%E4%B8%80%EF%BC%89MongoDB%E7%AE%80%E4%BB%8B">（一）MongoDB简介</h4> 
<p style="text-align:justify;">        MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品。MongoDB查询语言功能非常强大，可以实现类似关系数据库单表查询的绝大部分功能，同时支持数据索引。<br><strong>        对于数据查询：</strong>MongoDB支持动态查询，支持丰富的查询表达式。支持完全索引，可以在任意属性上建立索引，包含内部对象。MongoDB还提供创建基于地理空间索引的能力。MongoDB的查询优化器会分析表达式，并生成一个高效的查询计划，并且包含一个监视工具用于分析数据库操作的性能。<br><strong>        提供强大的聚合工具：</strong>如Count、Group等，支持使用MapReduce完成复杂的聚合任务。同时支持复制和故障恢复，MongoDB支持主从复制机制，可以实现数据备份、故障恢复、读扩展等功能。而基于副本集的复制机制提供了自动故障恢复的功能，确保了集群数据不会丢失。<br><strong>        对于数据存储：</strong>MongoDB采用高效的传统存储方式，文件存储格式为BSON（JSON的一种扩展）。BSON是对二进制格式的JSON的简称，BSON支持文档和数组的嵌套。支持二进制数据及大型对象。 同时，MongoDB采用自动分片功能，自动处理碎片，以支持云计算层次的扩展性，可动态添加额外的机器。MongoDB对数据进行分片可以使集群存储更多的数据，实现更大的负载，也能保证存储的负载均衡。<br>         <strong>提供了多种语言的接口：</strong>支持Python、PHP、Ruby、Java、C、C#、Javascript、Perl及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序。开发人员使用任何一种主流开发语言都可以轻松编程，实现访问MongoDB数据库。</p> 
<p style="text-align:justify;">        针对MongoDB的特点和提供的功能，MongoDB不适合处理传统的商业智能应用和那些要求高度事务性的系统以及复杂的跨文档（表）级联查询。<br>         MongoDB非常适合在以下应用环境中使用：<br><strong>（1）网站数据：</strong>MongoDB非常适合实时的插入、更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。<br><strong>（2）缓存：</strong>由于性能很高，MongoDB也适合作为信息基础设施的缓存层。在系统重启之后，由MongoDB搭建的持久化缓存层可以避免下层的数据源过载。<br><strong>（3）大尺寸，低价值的数据：</strong>使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候往往会选择传统的文件进行存储。<br><strong>（4）高伸缩性的场景：</strong>MongoDB非常适合由数十或数百台服务器组成的数据库。MongoDB的路线图中已经包含对MapReduce引擎的内置支持。<br><strong>（5）用于对象及JSON数据的存储：</strong>MongoDB的BSON数据格式非常适合文档化格式的存储及查询。</p> 
<h4 id="%EF%BC%88%E4%BA%8C%EF%BC%89MongoDB%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" style="text-align:justify;">（二）MongoDB基本概念</h4> 
<p style="text-align:justify;">        MongoDB是NoSQL数据库中最像关系数据库的一种，但其采用基于文档的存储，而是基于数据表的存储。下表给出了MongoDB与关系型数据库在文档、集合等概念的区别，其中MongoDB并不支持表间的连接操作。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:600px;"><caption>
   SQL术语概念与MongoDB术语概念的比较表 
 </caption><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td>——</td><td>表连接，MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键，MongoDB自动将_id字段设置为主键</td></tr></tbody></table> 
<p style="text-align:justify;">        传统关系数据库的数据表与MongoDB中集合相对应，下图给出了一个记录用户信息的关系型数据库表与MongoDB集合的对应关系。用户记录包括id、用户名（user_name）、电子邮箱（email）、年龄（age）、城市（city）信息。</p> 
<p class="img-center"><img alt="" height="292" src="https://images2.imgbox.com/83/89/G7NnhKYP_o.png" width="700"></p> 
<p style="text-align:justify;">        一个MongoDB实例可以包含一组数据库，一个数据库可以包含一组集合，一个集合可以包含一组文档，一个文档包含一组字段，每一个字段都是一个键值对。其中key必须为字符串类型，value可以包含如下类型：<br> ① 基本类型，例如，string、int、float、timestamp、binary等；<br> ② 一个文档；<br> ③ 数组类型。</p> 
<p style="text-align:justify;"><strong>1、文档</strong><br>         文档是MongoDB中数据的基本单位，类似于关系数据库中的行（但是比行复杂）。必须提醒注意的是，MongoDB中“文档”是由多个键及其关联的值有序地放在一起构成的一个文档。不同的编程语言对文档的表示方法不同，在JavaScript中文档表示为：<br> {"name":"Alex"}<br> 这个文档只有一个键“name”，对应的值为“Alex”。多数情况下，文档比这个更复杂，它包含多个键/值对。例如：<br> {"name":"alex", "age": 3}<br> 文档中的键/值对是有序的，下面的文档与上面的文档是完全不同的两个文档。<br> {"age": 3 , "name":"alex"}<br>         文档中的值不仅可以是双引号中的字符串，也可以是其他的数据类型，例如，整型、布尔型等，也可以是另外一个文档，即文档可以嵌套，文档中的键类型只能是字符串。</p> 
<p style="text-align:justify;"><strong>2、集合</strong></p> 
<p style="text-align:justify;">        集合是一组文档，类似于关系数据库中的表。集合是无模式的，集合中的文档可以是各式各样的。例如，{"Alex":"name"}和{"age": 21}，它们的键不同，值的类型也不同，但是它们可以存放在同一个集合中，也就是不同模式的文档都可以放在同一个集合中。</p> 
<p style="text-align:justify;"><strong>3、数据库</strong></p> 
<p style="text-align:justify;">        MongoDB中多个文档组成集合，多个集合组成数据库。一个MongoDB实例可以承载多个数据库，它们之间可以看作是相互独立的，每个数据库都有独立的权限控制。在磁盘上，不同的数据库存放在不同的文件中。MongoDB中存在Admin、Local和Config三个系统数据库。<br> Admin数据库：一个权限数据库，如果创建用户的时候将该用户添加到admin数据库中，那么该用户就自动继承了所有数据库的权限。<br> Local数据库：这个数据库永远不会被复制，可以用来存储本地单台服务器的任意集合。<br> Config数据库：当MongoDB使用分片模式时，Config数据库在内部使用，用于保存分片的信息。</p> 
<h3 id="%E5%9B%9B%E3%80%81%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j" style="text-align:justify;">四、图数据库Neo4j</h3> 
<h4 id="%EF%BC%88%E4%B8%80%EF%BC%89Neo4j%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1">（一）Neo4j与知识图谱</h4> 
<p style="text-align:justify;">        <strong>知识图谱</strong>是结构化的语义知识库，用于以符号形式描述物理世界中的概念及其相互关系，其基本组成单位是“实体-关系-实体”三元组，以及实体及其相关“属性-值”对，实体之间通过关系相互连接，构成网状的知识结构。<br>         在知识图谱的数据层，知识以事实（Fact）为单位存储在图数据库。如果以“实体-关系-实体”或者“实体-属性-值”三元组作为事实的基本表达方式，则存储在图数据库中的所有数据将构成庞大的实体关系网络，形成知识的图谱。</p> 
<p style="text-align:justify;">       <strong> Neo4j</strong>是一个将结构化数据存储在图（网络）而不是表中的NoSQL图数据库，它可以被看作是一个嵌入式的、基于磁盘的、具备完全事务特性的高性能Java持久化图引擎，该引擎具有成熟数据库的所有特性。<br>         Neo4j重点解决了拥有大量连接的传统RDBMS在查询时出现的性能衰退问题。围绕图进行数据建模后，Neo4j会以相同的速度遍历节点与边，其遍历速度与构成图的数据规模没有关系。此外，Neo4j还提供了非常快的图算法、推荐系统和OLAP风格的分析。</p> 
<p style="text-align:justify;">        <strong>遍历</strong>是图数据库数据检索的一个基本操作，也是图模型中所特有的操作。遍历的重要概念是其本身的局域化，遍历查询数据时仅使用必需的数据，而不是像关系数据库中使用join操作那样对所有的数据集实施代价昂贵的分组操作。<br>         Neo4j在开始添加数据之前，不需要定义表和关系，一个节点可以具有任何属性，任何节点都可以与其他任何节点建立关系。Neo4j数据库中的数据模型隐含在它存储的数据中，而不是明确地将数据模型定义为数据库本身的一个部分，它是对存入数据的一个描述，而不是数据库的一系列方法来限制将要存储的内容。<br>         Neo4j本身是用Java语言实现的，它也提供了Java API帮助用户来实现相关的数据库操作。同时Neo4j提供Cypher声明式图谱查询语言，用来可视化查询展示图谱里面的节点和关系。Cypher围绕图谱查询提供了可读性好和容易使用，功能强大的众多优点，并且是跨平台的，包括Java、Shell等其他所有平台。</p> 
<h4 id="%EF%BC%88%E4%BA%8C%EF%BC%89Neo4j%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" style="text-align:justify;">（二）Neo4j的核心概念</h4> 
<p style="text-align:justify;"><strong>1、Nodes（节点）</strong><br>         图谱的基本单位主要是节点和关系，它们都可以包含属性；一个节点就是一行数据，一个关系也是一行数据，里面的属性就是数据库里面的row里面的字段。除了属性之外，关系和节点还可以有零到多个标签，标签也可以认为是一个特殊分组方式。</p> 
<p style="text-align:justify;"><strong>2、Relationships（关系）</strong><br>         关系的功能是组织和连接节点，一个关系连接两个节点，一个开始节点和一个结束节点。当所有的点被连接起来，就形成了一张图谱，通过关系可以组织节点形成任意的结构，比如list、tree、map、tuple，或者更复杂的结构。关系拥有进和出两个方向，代表一种指向。</p> 
<p style="text-align:justify;"><strong>3、Properties（属性）</strong><br>         属性非常类似数据库里面的字段，只有节点和关系可以拥有0到多个属性，属性类型基本和Java的数据类型一致，分为数值、字符串、布尔，以及其他的一些类型，字段名必须是字符串。</p> 
<p style="text-align:justify;"><strong>4、Labels（标签）</strong><br>         可以通过标签给节点加上一种类型，一个节点可以有多个类型。除此之外标签在给属性建立索引或者约束时也会用到。Label名称必须是非空的unicode字符串，其最大标记容量为231。</p> 
<p style="text-align:justify;"><strong>5、Traversal（遍历）</strong><br>         查询时候通常是遍历图谱然后找到路径，在遍历时通常会有一个开始节点，然后根据Cypher提供的查询语句，遍历相关路径上的节点和关系，从而得到最终的结果。</p> 
<p style="text-align:justify;"><strong>6、Paths（路径）</strong><br>         路径是一个或多个节点通过关系连接起来的产物，例如，得到图谱查询或者遍历的结果。</p> 
<p style="text-align:justify;"><strong>7、Indexes（索引）</strong><br>         构建索引是一个异步请求，并不会立刻生效，会在后台创建直至成功后，才能最终生效。</p> 
<p style="text-align:justify;"><strong>8、Constraints（约束）</strong><br>         约束可以定义在某个字段上，限制字段值唯一，创建约束会自动创建索引。</p> 
<p style="text-align:justify;"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd5241aecbf8145f79f6a0bd144a6c3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jackson与Gson的比较</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cf1926fde4bbd96f4fdc1ed7fca64d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据分析基础之《numpy（4）—ndarry运算》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>