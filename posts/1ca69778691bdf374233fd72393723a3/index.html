<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql索引优化，更好的创建和使用索引 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql索引优化，更好的创建和使用索引" />
<meta property="og:description" content="我们如何更好的创建和使用索引呢？ 大家记住以下这个8个方案就OK啦。
1、只为用于搜索、排序或分组的列创建索引 我们只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。仅出现在查询列表中的列就没必要建立索引了。
2、考虑索引列中不重复值的个数 我们知道在通过二级索引&#43;回表的方式执行查询时，某个扫描区间中包含的二级索引记录数量越多，就会导致回表操作的代价越大。==我们在为某个列创建索引时，需要考虑该列中不重复值的个数占全部记录条数的比例。==如果比例太低，则说明该列包含过多重复值，那么在通过二级索引&#43;回表的方式执行查询时，就有可能执行太多的回表，导致性能下降。
对二级索引&#43;回表的这种查询方式还不是太了解的同学请看这篇文章
mysql 回表的代价（InnoDB）
3、索引列的类型尽量小 在定义表结构时，要显示的指定列的类型。以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT这几种，他们占用的存储空间大小依次递增。
如果想对某个整数类型的列建立索引，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，如果能使用INT就不使用BIGINT，因为数据类型越小，索引占用的存储空间就越少，在一个数据页就能存放更多的记录，磁盘IO的性能损耗也就越小，一次页面IO可以将更多的记录加载到内存。
4、为列前缀建立索引 我们知道一个字符串其实是由若干个字符构成的，如果在mysql中使用utf8字符集来存储字符串，则需要1~3个字节来编码一个字符。假如字符串很长，那么存储这个字符串就需要占用很大的存储空间。在需要为这个字符串所在的列建立索引的时候，就意味着在对应的B&#43;树中的记录中，需要把该列的完整的字符串记录下来。字符串越长，在索引中占用的空间也就越大。
其实索引列的字符串前缀也是排好序的，设计索引的人员提出了一个方案，只将字符串的前几个字符存放到索引中，也就是说在二级索引的记录中只保留字符串的前几个字符。创建语句如下：
ALTER TABLE demo_table ADD INDEX idx_key1(key1(10)); //创建的字符串索引只保留前10个字符 5、覆盖索引 为了彻底告别回表操作带来的性能损耗，建议最好在查询的列表中只包含索引列，例如：
SELECT key1,id FROM demo_table WHERE key1 &gt; &#39;a&#39; AND key1 &lt; &#39;c&#39;; 由于我们只查询 key1,id列的值，所以在使用idx_key1索引来扫描(‘a’,‘c’)区间中的二级索引记录时，可以直接从获取到的二级索引记录中读出key1列和id列的值，而不需要执行回表操作，我们把这种索引中已经包含所有需要读取的列的查询方式称为覆盖索引。
排序操作也优先使用覆盖索引进行查询，比如：
SELECT key1 FROM demo_table ORDER BY key1; 如果我们的业务中没有必要使用索引列以外的列，或者没有必要使用全部的列，我们最好比需要的列放到查询中，而不是用 select * 代替。
6、让索引列以列名的形式在搜索条件中单独出现 如下的方式并不会使用到索引，而是全表扫描：
SELECT * FROM demo_table WHERE key2 * 2 &lt; 4; 如下的方式可以使用到索引：
SELECT * FROM demo_table WHERE key2 &lt; 4 * 2; 所以，如果想让某个查询使用索引来执行，请让索引列以列名的形式单独出现在搜索条件中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1ca69778691bdf374233fd72393723a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-13T14:25:48+08:00" />
<meta property="article:modified_time" content="2023-11-13T14:25:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql索引优化，更好的创建和使用索引</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>我们如何更好的创建和使用索引呢？</h3> 
<p>大家记住以下这个8个方案就OK啦。</p> 
<h5><a id="1_3"></a>1、只为用于搜索、排序或分组的列创建索引</h5> 
<p>我们只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。仅出现在查询列表中的列就没必要建立索引了。</p> 
<h5><a id="2_9"></a>2、考虑索引列中不重复值的个数</h5> 
<p>我们知道在通过二级索引+回表的方式执行查询时，某个扫描区间中包含的二级索引记录数量越多，就会导致回表操作的代价越大。==我们在为某个列创建索引时，需要考虑该列中不重复值的个数占全部记录条数的比例。==如果比例太低，则说明该列包含过多重复值，那么在通过二级索引+回表的方式执行查询时，就有可能执行太多的回表，导致性能下降。</p> 
<p><em>对二级索引+回表的这种查询方式还不是太了解的同学请看这篇文章</em><br> <a href="https://blog.csdn.net/qq_38374397/article/details/128559816">mysql 回表的代价（InnoDB）</a></p> 
<h5><a id="3_17"></a>3、索引列的类型尽量小</h5> 
<p>在定义表结构时，要显示的指定列的类型。以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT这几种，他们占用的存储空间大小依次递增。<br> <strong>如果想对某个整数类型的列建立索引，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，如果能使用INT就不使用BIGINT，<mark>因为数据类型越小，索引占用的存储空间就越少，在一个数据页就能存放更多的记录，磁盘IO的性能损耗也就越小</mark>，一次页面IO可以将更多的记录加载到内存。</strong></p> 
<h5><a id="4_22"></a>4、为列前缀建立索引</h5> 
<p>我们知道一个字符串其实是由若干个字符构成的，如果在mysql中使用utf8字符集来存储字符串，则需要1~3个字节来编码一个字符。假如字符串很长，那么存储这个字符串就需要占用很大的存储空间。<mark>在需要为这个字符串所在的列建立索引的时候，就意味着在对应的B+树中的记录中，需要把该列的完整的字符串记录下来。字符串越长，在索引中占用的空间也就越大。</mark><br> 其实索引列的字符串前缀也是排好序的，设计索引的人员提出了一个方案，只将字符串的前几个字符存放到索引中，也就是说在二级索引的记录中只保留字符串的前几个字符。创建语句如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> demo_table <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> idx_key1<span class="token punctuation">(</span>key1<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建的字符串索引只保留前10个字符</span>
</code></pre> 
<h5><a id="5_31"></a>5、覆盖索引</h5> 
<p>为了彻底告别回表操作带来的性能损耗，建议最好在查询的列表中只包含索引列，例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> key1<span class="token punctuation">,</span>id <span class="token keyword">FROM</span> demo_table <span class="token keyword">WHERE</span> key1 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">AND</span> key1 <span class="token operator">&lt;</span> <span class="token string">'c'</span><span class="token punctuation">;</span> 
</code></pre> 
<p>由于我们只查询 key1,id列的值，所以在使用idx_key1索引来扫描(‘a’,‘c’)区间中的二级索引记录时，可以直接从获取到的二级索引记录中读出key1列和id列的值，而不需要执行回表操作，<mark>我们把这种索引中已经包含所有需要读取的列的查询方式称为覆盖索引。</mark></p> 
<p>排序操作也优先使用覆盖索引进行查询，比如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> key1 <span class="token keyword">FROM</span> demo_table <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> key1<span class="token punctuation">;</span>
</code></pre> 
<p><em>如果我们的业务中没有必要使用索引列以外的列，或者没有必要使用全部的列，我们最好比需要的列放到查询中，而不是用 select * 代替。</em></p> 
<h5><a id="6_46"></a>6、让索引列以列名的形式在搜索条件中单独出现</h5> 
<p>如下的方式并不会使用到索引，而是全表扫描：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> demo_table <span class="token keyword">WHERE</span> key2 <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> 
</code></pre> 
<p>如下的方式可以使用到索引：</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> demo_table <span class="token keyword">WHERE</span> key2 <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> 
</code></pre> 
<p><em>所以，如果想让某个查询使用索引来执行，请让索引列以列名的形式单独出现在搜索条件中。</em></p> 
<h5><a id="7_59"></a>7、新插入记录时主键大小对效率的影响</h5> 
<p>我们知道，对应InnoDB存储引擎来说，在没有显示的创建索引时，表中的数据实际上是存储在聚簇索引的叶子节点中，而且<mark>B+树的每一层数据页以及页面中的记录都是按主键值从小到大排序的</mark>。<mark>如果新插入的主键值是依次增大的话，则每插满一个数据页就换到下一个数据页继续插入</mark>，如果新插入的主键值忽大忽小，就很麻烦了。</p> 
<p>假如某个数据页的聚簇索引的记录已经满了，他的存储主键值在1-100之间， 我们再插入一条主键值为9的记录，这个时候新插入的记录会到哪里？存储引擎会把当前页面分裂成两个页面，把本页中的一些记录移动到新页中。页面分裂就意味着性能损耗<br> <em>所以我们一般都把表中的主键设置为自动递增 AUTO_INCREMENT</em></p> 
<h5><a id="8_66"></a>8、冗余和重复索引</h5> 
<p>比如某个列是在某个组合索引中，然后我们又为这个列建立了一个单独的索引，这个是没有必要的，或者我们为主键列单独建立了索引，也是没有必要的，因为主键本来就自带索引。</p> 
<p>创作不易，点个赞或者加个收藏吧~👍</p> 
<p>最后的最后送大家一句话</p> 
<p><em><strong>白驹过隙，沧海桑田</strong></em></p> 
<p>与君共勉</p> 
<blockquote> 
 <p><strong>文章持续更新，可以关注下方公众号或者微信搜一搜「 最后一支迷迭香 」第一时间阅读，获取更完整的链路资料。</strong></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f68f798dd970fc5bd2a52df1d88df1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringCloud Alibaba微服务工程搭建（保姆级）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/efafee9977afe6ca79e5a8ef602fc643/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【mysql】将逗号分割的字段内容转换为多行并group by</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>