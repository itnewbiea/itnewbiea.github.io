<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;学习（23） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;学习（23）" />
<meta property="og:description" content="1.分析下述代码运行：
#include&lt;iostream&gt; using namespacestd; int main() { int a[10]={0,1,2,3,4,5,6,7,8,9}; int *p=a; cout&lt;&lt;p[6]&lt;&lt;&#34;&#34;&lt;&lt;*(a&#43;6)&lt;&lt;&#34; &#34;&lt;&lt;*(p&#43;6)&lt;&lt;&#34;&#34;&lt;&lt;p&#43;6&lt;&lt;endl; return 0; } 2、用关键字virtual修饰的成员函数叫做虚函数，虚函数是为了实现多态而存在的，必须有函数体；
纯虚函数的声明，是在虚函数声明的结尾加=0，没有函数体。在派生类中没有重新定义虚函数之前是不能调用的纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加&#34;=0&#34;
如果一个类中至少含有一个纯虚函数，此时称之为抽象类。所以抽象类一定有纯虚函数
基类类型的指针可以指向任何基类对象或派生类对象
3、下列代码输出结果？
auto fn(unsignedchar a) {
cout&lt;&lt;std::hex&lt;&lt;(int)a&lt;&lt;endl;
}
fn(-1);
分析：32位-1的原码1000 0000 0000 0001 补码1111 1111 1111 1111（求反加一）
则fn()后8位为1111 1111
int 后0000 0000 1111 1111
Hex16进制后ff
int型-1的存储方式为补码（32位，4字节），1111 1111 1111 1111
转换为unsigned char（8位，1字节）发生字节截断，取最后八位为1111 1111 ；
再转换为int后为0000 0000 0000 0000 0000 0000 1111 1111 ，即为ff
4、
#include&lt;iostream&gt; #include&lt;string.h&gt; using namespacestd; struct st_t{ int status; short *pdata; char errstr[32]; }; int main() { st_t st[16]; char *p=(char *)(st[2]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/b1b282c2a05d90605bbd7eb5e092c41b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-26T17:30:13+08:00" />
<meta property="article:modified_time" content="2017-05-26T17:30:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;学习（23）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong><span style="color:#1F497D">1.分析下述代码运行：</span></strong></p> 
<p><strong><span style="color:#1F497D"></span></strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespacestd;
int main()
{
       int a[10]={0,1,2,3,4,5,6,7,8,9};
       int *p=a;
       cout&lt;&lt;p[6]&lt;&lt;""&lt;&lt;*(a+6)&lt;&lt;" "&lt;&lt;*(p+6)&lt;&lt;""&lt;&lt;p+6&lt;&lt;endl;
       return 0;
}</code></pre> 
<br> 
<br> 
<p></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">2</span><span style="color:#1F497D">、用关键字</span><span style="color:#1F497D">virtual</span><span style="color:#1F497D">修饰的成员函数叫做</span><span style="color:red">虚函数</span><span style="color:#1F497D">，虚函数是</span><span style="color:red">为了实现多态而存在的，必须</span><span style="color:red">有函数体</span><span style="color:#1F497D">；</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:red">纯虚函数</span><span style="color:#1F497D">的声明，是在虚函数声明的结尾加</span><span style="color:#1F497D">=0</span><span style="color:#1F497D">，</span><span style="color:red">没有函数体</span><span style="color:#1F497D">。</span><span style="color:red">在派生类中没有重新定义虚函数之前是不能调用的</span><span style="color:#1F497D">纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加</span><span style="color:#1F497D">"=0"</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">如果</span><span style="color:red">一个类中至少含有一个纯虚函数</span><span style="color:#1F497D">，此时称之为</span><span style="color:red">抽象类</span><span style="color:#1F497D">。所以抽象类一定有纯虚函数</span></span></strong></p> 
<p><strong><span style="color:red"><span style="font-size:18px">基类类型的指针可以指向任何基类对象或派生类对象</span></span></strong></p> 
<p><strong><span style="color:red"><span style="font-size:18px"> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">3</span><span style="color:#1F497D">、下列代码输出结果？</span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px">auto fn(unsignedchar a) {<!-- --></span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px">       cout&lt;&lt;std::hex&lt;&lt;(int)a&lt;&lt;endl;</span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px">}</span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px">fn(-1);</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">分析：</span><span style="color:#1F497D">32</span><span style="color:#1F497D">位-1</span>的原码1000 0000 0000 0001 </span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">补码1111 1111 1111 1111</span>（求反加一）</span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">则fn()</span>后8位为1111 1111<br> int 后0000 0000 1111 1111<br> Hex16进制后ff</span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px"> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">int</span><span style="color:#1F497D">型</span><span style="color:#1F497D">-1</span><span style="color:#1F497D">的存储方式为补码（</span><span style="color:#1F497D">32</span><span style="color:#1F497D">位，</span><span style="color:#1F497D">4</span><span style="color:#1F497D">字节），</span><span style="color:#1F497D">1111  1111  1111  1111</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">转换为</span><span style="color:#1F497D">unsigned char</span><span style="color:#1F497D">（</span><span style="color:#1F497D">8</span><span style="color:#1F497D">位，</span><span style="color:#1F497D">1</span><span style="color:#1F497D">字节）发生字节截断，取最后八位为</span><span style="color:#1F497D">1111  1111 </span><span style="color:#1F497D">；</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">再转换为</span><span style="color:#1F497D">int</span><span style="color:#1F497D">后为</span><span style="color:#1F497D">0000 0000 0000 0000 0000 0000 1111 1111 </span><span style="color:#1F497D">，即为</span><span style="color:#1F497D">ff</span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px"> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">4</span><span style="color:#1F497D">、</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D"></span></span></strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespacestd;
struct st_t{
       int status;
       short *pdata;
       char errstr[32];
};
int main()
{
       st_t st[16];
       char *p=(char *)(st[2].errstr + 32);
       cout&lt;&lt;p-(char *)(st);
       return 0;
}</code></pre> 
<p></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">st_t</span><span style="color:#1F497D">大小为</span><span style="color:#1F497D">40</span><span style="color:#1F497D">，设</span><span style="color:#1F497D">st</span><span style="color:#1F497D">起始地址为</span><span style="color:#1F497D">0</span><span style="color:#1F497D">，</span><span style="color:#1F497D">str[2].errstr</span><span style="color:#1F497D">起始地址为</span><span style="color:#1F497D">40*2+8=88</span><span style="color:#1F497D">。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">p</span><span style="color:#1F497D">存储的地址为</span><span style="color:#1F497D">88+32</span><span style="color:#1F497D">，结果显然为</span><span style="color:#1F497D">120</span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px"> </span></span></strong></p> 
<p><span style="font-size:18px"><strong><span style="color:#1F497D">5.</span> <span style="color:#1F497D"> 面向对象的五大基本原则：</span></strong></span></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">单一职责原则（</span><span style="color:#1F497D">SRP</span><span style="color:#1F497D">）</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">开放封闭原则（</span><span style="color:#1F497D">OCP</span><span style="color:#1F497D">）</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">里氏替换原则（</span><span style="color:#1F497D">LSP</span><span style="color:#1F497D">）</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">依赖倒置原则（</span><span style="color:#1F497D">DIP</span><span style="color:#1F497D">）</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">接口隔离原则（</span><span style="color:#1F497D">ISP</span><span style="color:#1F497D">）</span></span></strong></p> 
<p align="left"><span style="font-size:18px"> </span></p> 
<p align="left"><span style="font-size:18px">s(Single-Resposibility Principle):单一职责原则<br> <br> o(Open-Closed principle ):开放封闭原则<br> <br> l(Liskov-Substituion Principle):里氏原则<br> <br> i(Interface-Segregation Principle ):接口隔离原则<br> <br> d(Dependecy-Inversion Principle ):依赖倒置原则<br> <br> 一个单词：立方体(solid),很好记!!! </span></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px"> </span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px">五个基本原则：</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000">单一职责原则（Single-Resposibility Principle）</span><span style="color:#1F497D">：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000"><br> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000">开放封闭原则（Open-Closed principle）</span><span style="color:#1F497D">：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000"><br> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000">Liskov替换原则（Liskov-Substituion Principle</span><span style="color:#1F497D">）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000"><br> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000">依赖倒置原则（Dependecy-Inversion Principle）</span><span style="color:#1F497D">：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000"><br> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#ff0000">接口隔离原则（Interface-Segregation Principle</span><span style="color:#1F497D">）：使用多个小的专门的接口，而不要使用一个大的总接口</span></span></strong></p> 
<p><strong><span style="color:#1F497D"><span style="font-size:18px"> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">6</span><span style="color:#1F497D">．使用</span><span style="color:#1F497D"> char *p = new char[100];</span><span style="color:#1F497D">申请一段内存，然后使用</span><span style="color:#1F497D">delete p</span><span style="color:#1F497D">释放：</span><span style="color:red">不会造成内存泄露，但不建议使用。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D"><br> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">C++</span><span style="color:#1F497D">告诉我们在回收用</span><span style="color:#1F497D"> new </span><span style="color:#1F497D">分配的单个对象的内存空间的时候用</span><span style="color:#1F497D"> delete</span><span style="color:#1F497D">，回收用</span><span style="color:#1F497D"> new[] </span><span style="color:#1F497D">分配的一组对象的内存空间的时候用</span><span style="color:#1F497D"> delete[]</span><span style="color:#1F497D">。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">关于</span><span style="color:#1F497D"> new[] </span><span style="color:#1F497D">和</span><span style="color:#1F497D"> delete[]</span><span style="color:#1F497D">，其中又分为两种情况：</span><span style="color:#1F497D">(1) </span><span style="color:#1F497D">为基本数据类型分配和回收空间；</span><span style="color:#1F497D">(2) </span><span style="color:#1F497D">为自定义类型分配和回收空间。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用</span><span style="color:#1F497D"> delete </span><span style="color:#1F497D">和</span><span style="color:#1F497D"> delete[] </span> <span style="color:#1F497D">都是应该可以的；但是对于类对象数组，只能用</span><span style="color:#1F497D"> delete[]</span><span style="color:#1F497D">。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D">所以一个简单的使用原则就是：</span><span style="color:#1F497D">new </span><span style="color:#1F497D">和</span><span style="color:#1F497D"> delete</span><span style="color:#1F497D">、</span><span style="color:#1F497D">new[] </span><span style="color:#1F497D">和</span><span style="color:#1F497D"> delete[] </span> <span style="color:#1F497D">对应使用。</span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D"><br> </span></span></strong></p> 
<p><strong><span style="font-size:18px"><span style="color:#1F497D"><a target="_blank" href="http://blog.csdn.net/cbnotes/article/details/38900799" rel="noopener noreferrer">点击打开链接</a>（详细学习）<br> </span></span></strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/320bf391cbe06e1d87992d8e56213f6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二分法查找示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a847df1efd782e9526759619f91b9cb0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【电子产品】ThinkPad S5   Intel(R) Dual Band Wireless-AC 3165 网卡驱动莫名其妙挂掉</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>