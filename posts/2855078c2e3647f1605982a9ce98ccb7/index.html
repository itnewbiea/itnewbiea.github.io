<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【墨尘の笔记】数据结构与算法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【墨尘の笔记】数据结构与算法" />
<meta property="og:description" content="前言 仙人指路 [第一章]为入门，讲解数据结构是干什么的
[第二章]到第四章是数据结构基础，主要讲解链表，栈，队列，串等
[第五章]是二叉树
[第六章]是图,此章偏难，非考研或算法从业可粗略看
[第七章]到第八章是查找以及各种排序
[第九章]为补充，教材中没有的部分概念我随机补充上去
墨尘の话 本文内容主要参考王道考研，其中21版本咸鱼学长的课尚可，20版本比较枯燥,可选择性学习
浙大陈越姥姥的课比较精简且侧重于练习，能看懂且时间多的蛋疼可以看这个
因时间关系,后期比较匆促，本人也就是学着玩玩╮(╯▽╰)╭，可多参考链接自主学习
参考视频 2020 王道考研 数据结构 - B站
数据结构-浙江大学 - B站
第一章 1.1.1 数据机构的基本概念 1. 什么是数据结构 数据：信息的载体，是描述客观事务属性的数，字符，以及所有能输入到计算机种并被计算机程序识别和处理的符号集合
数据对象： 具有相通性质的数据元素的集合，是数据的一个子集
数据元素： 数据的基本单位，通常作为一个整体进行考虑和处理
数据项： 构成数据元素的不可分割的最小单位
举例：一群人，就是一个数据对象，每个人就是一个数据元素，他们的手，头等就是数据项
结构：数据中存在某种关联关系，称为结构
举例：小明是八年级一班中的学生，成绩为100
上例中小明和成绩是数据项，一班是数据元素，八年级是数据对象
2. 数据结构三要素 1. 逻辑结构 线性结构
线性结构： 数据元素是一对一的关系，除了第一个元素，所有都有唯一前驱（前面有一个节点）；除了最后一个元素，所有元素都有唯一后继（后面有一个节点）
非线性结构
集合： 一组元素属于同一个集合，除此外别无关系
树形结构： 数据元素之间是一对多的关系
图状结构： 数据元素之间是多对多的关系
2. 存储结构 顺序存储
顺序存储： 把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系靠存储单元的邻接关系体现
非顺序存储
链式存储： 逻辑上相邻的元素在物理位置上可以不相邻，借助元素存储地址的指针来表示元素之间的逻辑关系
索引存储： 在存储元素信息的同时，还建立附加的索引表。索引表中每项称为索引项，索引项一般为（关键字，地址）
散列存储： 根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储
顺序存储便于查找，非顺序查找便于增删
3. 数据的运算 3. 概念 1.2.1 算法的基本概念 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2855078c2e3647f1605982a9ce98ccb7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-20T18:22:13+08:00" />
<meta property="article:modified_time" content="2021-04-20T18:22:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【墨尘の笔记】数据结构与算法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<h5><a id="_2"></a>仙人指路</h5> 
<p>[第一章]为入门，讲解数据结构是干什么的</p> 
<p>[第二章]到第四章是数据结构基础，主要讲解链表，栈，队列，串等</p> 
<p>[第五章]是二叉树</p> 
<p>[第六章]是图,此章偏难，非考研或算法从业可粗略看</p> 
<p>[第七章]到第八章是查找以及各种排序</p> 
<p>[第九章]为补充，教材中没有的部分概念我随机补充上去</p> 
<h5><a id="_16"></a>墨尘の话</h5> 
<p>本文内容<strong>主要参考王道考研</strong>，其中21版本咸鱼学长的课尚可，20版本比较枯燥,可选择性学习</p> 
<p>浙大陈越姥姥的课比较精简且侧重于练习，能看懂且时间多的蛋疼可以看这个</p> 
<p>因时间关系,后期比较匆促，本人也就是学着玩玩╮(╯▽╰)╭，可多参考链接自主学习</p> 
<h5><a id="_24"></a>参考视频</h5> 
<p><a href="https://www.bilibili.com/video/BV1b7411N798" rel="nofollow">2020 王道考研 数据结构 - B站</a></p> 
<p><a href="https://www.bilibili.com/video/BV1JW411i731" rel="nofollow">数据结构-浙江大学 - B站</a></p> 
<h3><a id="_30"></a>第一章</h3> 
<h3><a id="111__32"></a>1.1.1 数据机构的基本概念</h3> 
<h4><a id="1__34"></a>1. 什么是数据结构</h4> 
<p><strong>数据：信息的载体，是描述客观事务属性的数，字符，以及所有能输入到计算机种并被计算机程序识别和处理的符号集合</strong></p> 
<p>数据对象： 具有相通性质的数据元素的集合，是数据的一个子集</p> 
<p>数据元素： 数据的基本单位，通常作为一个整体进行考虑和处理</p> 
<p>数据项： 构成数据元素的不可分割的最小单位</p> 
<p>举例：一群人，就是一个数据对象，每个人就是一个数据元素，他们的手，头等就是数据项</p> 
<p><strong>结构：数据中存在某种关联关系，称为结构</strong></p> 
<p>举例：小明是八年级一班中的学生，成绩为100</p> 
<p>上例中小明和成绩是数据项，一班是数据元素，八年级是数据对象</p> 
<h4><a id="2__52"></a>2. 数据结构三要素</h4> 
<h5><a id="1__54"></a>1. 逻辑结构</h5> 
<p><strong>线性结构</strong></p> 
<p>线性结构： 数据元素是一对一的关系，除了第一个元素，所有都有唯一前驱（前面有一个节点）；除了最后一个元素，所有元素都有唯一后继（后面有一个节点）</p> 
<p><strong>非线性结构</strong></p> 
<p>集合： 一组元素属于同一个集合，除此外别无关系</p> 
<p>树形结构： 数据元素之间是一对多的关系</p> 
<p>图状结构： 数据元素之间是多对多的关系</p> 
<p><img src="https://images2.imgbox.com/4a/41/ImnlOSd4_o.png" alt="image-20210326163346644"></p> 
<h5><a id="2__70"></a>2. 存储结构</h5> 
<p><strong>顺序存储</strong></p> 
<p>顺序存储： 把<strong>逻辑上相邻</strong>的元素存储在<strong>物理位置也相邻</strong>的存储单元中，元素之间的关系靠存储单元的邻接关系体现</p> 
<p><strong>非顺序存储</strong></p> 
<p>链式存储： <strong>逻辑上相邻</strong>的元素在<strong>物理位置上可以不相邻</strong>，借助元素存储地址的指针来表示元素之间的逻辑关系</p> 
<p>索引存储： 在存储元素信息的同时，还建立附加的索引表。索引表中每项称为索引项，索引项一般为（关键字，地址）</p> 
<p>散列存储： 根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p> 
<p>顺序存储便于查找，非顺序查找便于增删</p> 
<p><img src="https://images2.imgbox.com/0b/ae/uCZxxhA0_o.png" alt="image-20210326163403699"></p> 
<h5><a id="3__90"></a>3. 数据的运算</h5> 
<p><img src="https://images2.imgbox.com/70/29/ksDrWIE0_o.png" alt="image-20210326163428469"></p> 
<h4><a id="3__94"></a>3. 概念</h4> 
<p><img src="https://images2.imgbox.com/9b/f4/RJp4cK2U_o.png" alt="image-20210326163444137"></p> 
<h3><a id="121__98"></a>1.2.1 算法的基本概念</h3> 
<h4><a id="1__100"></a>1. 什么是算法</h4> 
<p>程序 = 数据结构 + 算法</p> 
<p>数据结构负责将现实世界的问题转化为信息，然后将信息存入计算机</p> 
<p>算法是处理信息的步骤，负责将信息进行处理得到我们想要的结果</p> 
<h4><a id="2__108"></a>2. 算法的特性</h4> 
<ol><li>有穷性： 有限时间里可以执行完</li><li>可行性： 可以用现有的操作实现算法</li></ol> 
<p><strong>好算法的特性</strong></p> 
<ol><li>正确性：正确解决问题</li><li>可读性：别人也能很清晰的看明白</li><li>健壮性（鲁棒性）： 可以处理异常情况，比如非法数据等</li><li><strong>高效率： 省时间，省内存</strong></li></ol> 
<h4><a id="3__120"></a>3. 概念</h4> 
<p><img src="https://images2.imgbox.com/28/c6/ljs29S3R_o.png" alt="image-20210326164240364"></p> 
<h3><a id="122__124"></a>1.2.2 时间复杂度</h3> 
<h4><a id="1__126"></a>1. 如何评价算法的时间开销</h4> 
<p>1.和机器性能相关，诸如超级计算机 vs 单片机</p> 
<p>2.和编程语言相关，越高级的语言效率越低</p> 
<p>3.和编译程序产生的机器指令相关</p> 
<p>4.有些算法是不能事后统计的</p> 
<p>通常情况机器性能和编程语言无法改变，因此考虑如何优化程序性能即可</p> 
<p><strong>时间开销与问题规模n之间的关系</strong></p> 
<h4><a id="2__142"></a>2. 如何计算</h4> 
<p>一般指代循环/迭代，循环的次数越多时间复杂度越高（参考下图）</p> 
<p><img src="https://images2.imgbox.com/e1/49/8mzk6ElZ_o.png" alt="image-20210326164348922"></p> 
<h4><a id="3__148"></a>3. 三种复杂度</h4> 
<p>1.最坏时间复杂度： 考虑最坏的情况</p> 
<p>2.平均时间复杂度： 考虑所有输入情况都处于同等概率</p> 
<p>3.最好时间复杂度： 考虑最好的情况</p> 
<p><strong>评定一个算法的时间复杂度好坏通常要拿最坏情况去考虑</strong></p> 
<h4><a id="4__158"></a>4. 概念</h4> 
<p><img src="https://images2.imgbox.com/3e/03/lfO5nUfl_o.png" alt="image-20210326164401093"></p> 
<h3><a id="123__162"></a>1.2.3 空间复杂度</h3> 
<p>通俗理解：每个变量都会在内存中开辟一个新的空间，因此基于空间复杂度优化变量越少越好，递归尤甚</p> 
<p><strong>内存开销与问题规模n之间的关系</strong></p> 
<p>基于现在计算机内存来讲，通常我们只需要考虑时间复杂度，空间复杂度无需作为首选考虑</p> 
<h4><a id="1__170"></a>1. 概念</h4> 
<p><img src="https://images2.imgbox.com/4c/51/Y2lFHtZQ_o.png" alt="image-20210326164503662"></p> 
<h3><a id="_176"></a>第二章</h3> 
<h4><a id="21%09_178"></a>2.1 线性表的定义的基本操作</h4> 
<h5><a id="1__180"></a>1. 线性表的定义</h5> 
<p>线性表是具有<strong>相同</strong>数据类型的n（n &gt;= 0）个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时线性表是一个空表</p> 
<p><img src="https://images2.imgbox.com/d6/5f/SGZVvxBo_o.png" alt="image-20210326164516562"></p> 
<h5><a id="2__186"></a>2. 线性表的基本操作</h5> 
<pre><code class="prism language-java"><span class="token comment">// 初始化表。构造一个空的线性表L，分配内存空间</span>
<span class="token function">InitList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span>
<span class="token function">DestroyList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// 插入操作。在表L中第i个位置上插入指定元素e</span>
<span class="token function">ListInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</span>
<span class="token function">ListDelete</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 按值查找操作。在表L中查找具有给定关键字值的元素。</span>
<span class="token function">LocateElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 按位查找操作。获取表L中第i个位置的元素的值。</span>
<span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 其他常用操作</span>

<span class="token comment">// 求表长。返回线性表L的所有元素值。</span>
<span class="token function">Length</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出操作。按前后顺序输出线性表L的所有元素值。</span>
<span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判空操作。若L为空表，则返回true，否则返回false</span>
<span class="token function">Empty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>Tips:</p> 
<p>1.<strong>对数据的操作（分析思路） —— 创销，增删改查（适用于所有数据结构）</strong></p> 
<p>2.java函数的定义 —— &lt;返回值类型&gt; 函数名（&lt;参数1类型&gt; 参数1，&lt;参数2类型&gt; 参数2，…）</p> 
<p>3.实际开发中，可根据实际需求定义其他的基本操作（输出，判空等）</p> 
<p>4.函数名和参数的形式，命名都可改变（Reference: 严蔚敏版《数据结构与算法》）</p> 
<h5><a id="_226"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/7e/53/xzC6D5dy_o.png" alt="image-20210326164531526"></p> 
<h4><a id="221%09_230"></a>2.2.1 顺序表的定义</h4> 
<h5><a id="1__232"></a>1. 顺序表的定义</h5> 
<p>用顺序存储的方式实现线性表</p> 
<p>顺序存储：把<strong>逻辑上相邻</strong>的元素存储在<strong>物理位置上也相邻</strong>的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p> 
<h5><a id="2__238"></a>2. 顺序表的特点</h5> 
<p>​ <strong>优点</strong></p> 
<ol><li> <p>随机访问，既可以在O(1)时间内找到第一个元素</p> </li><li> <p>存储密度高，每个节点只存储数据元素</p> <p><strong>缺点</strong></p> </li><li> <p>拓展容量不方便（采用动态分配时间复杂度较高）</p> </li><li> <p>插入，删除不方便，需要移动大量元素</p> </li></ol> 
<h5><a id="3__252"></a>3. 概念</h5> 
<p>注：图上所示函数均为c语言中动态分配相关函数，可根据自身情况选择性学习</p> 
<p>代码在2.2.2.2 顺序表的查找一节</p> 
<p><img src="https://images2.imgbox.com/54/00/kYSLdwuT_o.png" alt="image-20210326164618599"></p> 
<h4><a id="2221%09_260"></a>2.2.2.1 顺序表的插入删除</h4> 
<h5><a id="_262"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/75/b9/fqt9b1Dl_o.png" alt="image-20210326164640102"></p> 
<h4><a id="2222%09_266"></a>2.2.2.2 顺序表的查找</h4> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 顺序表
 * @author: HouBo
 * @Date: 2020/11/26 17:52
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqList</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXSIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 最大长度</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用静态数组存放数据</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>  <span class="token comment">// 顺序表的当前长度</span>

    <span class="token comment">// 初始化一个顺序表</span>
    <span class="token keyword">void</span> <span class="token function">initList</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        L<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 初始长度为0</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 添加一个数据</span>
    <span class="token keyword">boolean</span> <span class="token function">listInsert</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前i的值是否有效</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前存储空间是否充盈</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 将第i个元素之后的元素后移</span>
            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 在位置i处放入e</span>
        <span class="token punctuation">}</span>
        L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 长度+1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除一个数据</span>
    <span class="token keyword">boolean</span> <span class="token function">listDelete</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前i的值是否有效</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        e <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 将第i个元素之后的元素后移</span>
            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 在位置i处放入e</span>
        <span class="token punctuation">}</span>
        L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 长度-1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 按位查找</span>
    <span class="token keyword">int</span> <span class="token function">getElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按值查找</span>
    <span class="token keyword">int</span> <span class="token function">locateElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此段代码非最优解，仅作练习使用</p> 
<h5><a id="_336"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/1c/6c/nHCK623l_o.png" alt="image-20210326164703240"></p> 
<h4><a id="231%09_340"></a>2.3.1 单链表的定义</h4> 
<h5><a id="1__342"></a>1. 什么是单链表</h5> 
<p>相对于顺序表，单链表除了存储数据元素外，还需要存储指向下一个节点的指针</p> 
<p><img src="https://images2.imgbox.com/b0/73/KEDVSQzq_o.png" alt="image-20210326164749030"></p> 
<h5><a id="2__348"></a>2. 单链表和顺序表的不同</h5> 
<table><thead><tr><th align="center"></th><th align="center">顺序表</th><th align="center">单链表</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">随机存取，存储密度高</td><td align="center">不要求大片连续空间，改变容量方便</td></tr><tr><td align="center">缺点</td><td align="center">要求大片连续空间，改变容量不方便</td><td align="center">不可随机存取，要耗费一定空间存放指针</td></tr></tbody></table> 
<h5><a id="_355"></a>带头结点和不带头结点的区别</h5> 
<p>创立第一个结点，既为带头结点，反之则为不带</p> 
<p>不带头结点，对第一个数据结点和后续数据结点的处理需要用不用的代码逻辑，空表和非空表的处理同理</p> 
<p><strong>带头结点通常情况下优于不带</strong></p> 
<h5><a id="_363"></a>概念</h5> 
<p>代码放在2.3.2.3 单链表的建立一节中</p> 
<p><img src="https://images2.imgbox.com/9f/7c/h3B2tgYA_o.png" alt="image-20210326164901618"></p> 
<h4><a id="2321%09_369"></a>2.3.2.1 单链表的插入删除</h4> 
<p>此章中，p通过代指当前结点，s指新插入的结点, a1指下一个结点, e指新值</p> 
<h5><a id="11__373"></a>1.1 按位序插入(带头结点)</h5> 
<p>思路：插入结点打断链表，上一个结点挂到它身上（指向它），它挂到下一个结点身上。</p> 
<p><strong>链表插入删除操作和顺序表相比相对复杂，需多多思考。</strong></p> 
<p><img src="https://images2.imgbox.com/60/32/E3MVTHP3_o.png" alt="image-20210326165108584"></p> 
<h5><a id="12__381"></a>1.2 按位序插入（不带头结点）</h5> 
<p>不带头结点第一个结点需要做特殊处理，创建一个s，将第a1挂到它身上。</p> 
<h5><a id="2__385"></a>2. 指定结点的后插操作</h5> 
<p>a1挂到s身上，s挂到p身上。</p> 
<h5><a id="3__389"></a>3. 指定结点的前插操作</h5> 
<p>由于无法直接获取p的上一个结点，因此可采用如下方法实现:</p> 
<p>思路：将p变更为s, s变更为p</p> 
<p>实现：p的值赋给s，新值e赋给p</p> 
<h5><a id="4__397"></a>4. 按位序删除</h5> 
<p>思路：找到要删除的结点，断开它并释放空间</p> 
<h5><a id="5__401"></a>5. 指定结点的删除</h5> 
<p>思路：同上</p> 
<p>实现：将p的值和下一个引用都指向下一个，实现删除p的效果</p> 
<p>此处如果p是最后一个结点，将会出现异常</p> 
<p><strong>单链表的局限性：无法逆向检索，不方便</strong></p> 
<h5><a id="6__411"></a>6. 概念</h5> 
<p><img src="https://images2.imgbox.com/b2/12/iY4HiZe2_o.png" alt="image-20210326165124409"></p> 
<h4><a id="2322%09_415"></a>2.3.2.2 单链表的查找</h4> 
<h5><a id="_417"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/9d/45/yCGxkIUQ_o.png" alt="image-20210326165137520"></p> 
<h4><a id="2323%09_421"></a>2.3.2.3 单链表的建立</h4> 
<p>思路：遍历所有结点，通过头插或者尾插的方式实现循环建立一个单链表。</p> 
<p><strong>头插法可以实现反转链表，注意这是个重点</strong></p> 
<h5><a id="_427"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 结点
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HNode</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token function">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">HNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 数据</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token comment">// 下一个结点</span>
    HNode next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 单链表
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HLinkerList</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 链表的头结点</span>
    HNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment">// 初始化一个空链表</span>
    <span class="token keyword">boolean</span> <span class="token function">InitList</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        L<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个头结点,如果不带头结点此处直接赋空</span>
        L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// 头结点之后暂时没有结点</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在第i个位置插入元素e</span>
    <span class="token keyword">boolean</span> <span class="token function">ListInsert</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 以下代码段为不带头结点的操作</span>
<span class="token comment">//        if(i == 1) { // 插入第一个结点的操作与其他结点操作不同</span>
<span class="token comment">//            HNode s = new HNode();</span>
<span class="token comment">//            s.data = e;</span>
<span class="token comment">//            s.next = L.head.next;</span>
<span class="token comment">//            L.head = s; // 头指针指向新结点</span>
<span class="token comment">//        }</span>
<span class="token comment">//        HNode p; // 指针p向前扫描到的结点</span>
<span class="token comment">//        int j = 0; // 当前p指向的是第几个结点，不带的话此处赋1</span>
<span class="token comment">//        p = L.head; // L指向头结点，头结点是第0个结点</span>
<span class="token comment">//        while (p != null &amp;&amp; j &lt; i - 1) { // 循环找到 i - 1 个结点</span>
<span class="token comment">//            p = p.next;</span>
<span class="token comment">//            j++;</span>
<span class="token comment">//        }</span>
        HNode p <span class="token operator">=</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//        if(p == null){ // i值不合法</span>
<span class="token comment">//            return false;</span>
<span class="token comment">//        }</span>
<span class="token comment">//        HNode s = new HNode();</span>
<span class="token comment">//        s.data = e;</span>
<span class="token comment">//        s.next = p.next;</span>
<span class="token comment">//        p.next = s; // 将结点s连到p之后</span>
<span class="token comment">//        return true; // 插入成功</span>

        <span class="token keyword">return</span> <span class="token function">InsertNextNode</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 后插操作：在p结点之后插入元素e</span>
    <span class="token keyword">boolean</span> <span class="token function">InsertNextNode</span><span class="token punctuation">(</span>HNode p<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 新结点s存储数据e</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 新结点s挂到p身上</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 前插操作：在p结点之前插入元素e</span>
    <span class="token keyword">boolean</span> <span class="token function">InsertPriorNode</span><span class="token punctuation">(</span>HNode p<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 新结点s挂到p身上</span>
        s<span class="token punctuation">.</span>data <span class="token operator">=</span> p<span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token comment">// 将p里面的元素复制到s中</span>
        p<span class="token punctuation">.</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// p中的元素覆盖为e</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按位序删除</span>
    <span class="token keyword">boolean</span> <span class="token function">ListDelete</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        HNode p; // 指针p向前扫描到的结点</span>
<span class="token comment">//        int j = 0; // 当前p指向的是第几个结点，不带的话此处赋1</span>
<span class="token comment">//        p = L.head; // L指向头结点，头结点是第0个结点</span>
<span class="token comment">//        while (p != null &amp;&amp; j &lt; i - 1) { // 循环找到 i - 1 个结点</span>
<span class="token comment">//            p = p.next;</span>
<span class="token comment">//            j++;</span>
<span class="token comment">//        }</span>
        HNode p <span class="token operator">=</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// i值不合法</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 第i - 1个结点后面已无其他结点</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        HNode q = p.next; // 令q指向被删除的结点</span>
<span class="token comment">//        e = q.data; // 用e返回元素的值</span>
<span class="token comment">//        p.next = q.next; // 将q结点从链中断开</span>
<span class="token comment">//        return true; // 删除成功</span>

        <span class="token keyword">return</span> <span class="token function">DeleteNode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除指定结点p</span>
    <span class="token keyword">boolean</span> <span class="token function">DeleteNode</span><span class="token punctuation">(</span>HNode p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 令q指向p的后继结点</span>
        p<span class="token punctuation">.</span>data <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token comment">// 和后继结点交换数据域</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 将q结点从链中断开</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按位查找，返回第i个元素</span>
    HNode <span class="token function">GetElem</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode p<span class="token punctuation">;</span> <span class="token comment">// 指针p向前扫描到的结点</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前p指向的是第几个结点，不带的话此处赋1</span>
        p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span> <span class="token comment">// L指向头结点，头结点是第0个结点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 循环找到 i 个结点</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按值查找</span>
    HNode <span class="token function">LocateElem</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        HNode p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">// 从第一个结点开始查找数据域为e的结点</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token comment">// 找到后返回该结点，否则返回null</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 求表的长度</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        HNode p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表第"</span> <span class="token operator">+</span> len <span class="token operator">+</span> <span class="token string">"个数据:"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            len<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>此段代码非最优解，仅作练习使用</p> 
<h4><a id="233%09_608"></a>2.3.3 双链表</h4> 
<p>下文中，s指代新结点，p指代当前结点，q指代下一个结点</p> 
<h5><a id="1__612"></a>1. 双链表和单链表的概念</h5> 
<p>单链表：无法逆向检索，有时候不太方便</p> 
<p>双链表：可进可退，存储密度更低</p> 
<p>双链表整体和单链表差距不大，额外新增了一个指向上一个结点的处理</p> 
<h5><a id="2__620"></a>2. 双链表的插入</h5> 
<p>思路：和单链表同理，额外增加了prior的处理</p> 
<p>① q挂到s身上</p> 
<p>② q的prior指向s</p> 
<p>③ s的prior指向p</p> 
<p>④ s挂到p身上</p> 
<p>如果q不存在，第二步需省略</p> 
<p><img src="https://images2.imgbox.com/96/33/SXjdSvdC_o.png" alt="image-20210326165204033"></p> 
<h5><a id="3__636"></a>3. 双链表的删除</h5> 
<p>① q的下一个结点挂到p身上</p> 
<p>② q的下一个结点的prior指向p</p> 
<p><img src="https://images2.imgbox.com/52/1b/OFSPobwc_o.png" alt="image-20210326165214894"></p> 
<h5><a id="_644"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 结点（双链表）
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HDNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">HDNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">HDNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 数据</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token comment">// 下一个结点</span>
    HDNode next<span class="token punctuation">;</span>
    <span class="token comment">// 上一个结点</span>
    HDNode prior<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 双链表
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HDLinkedList</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 链表的头结点</span>
    HDNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment">// 初始化一个空链表</span>
    <span class="token keyword">boolean</span> <span class="token function">InitList</span><span class="token punctuation">(</span>HDLinkedList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        L<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HDNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个头结点,如果不带头结点此处直接赋空</span>
        L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>prior <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// 头结点的prior永远指向空</span>
        L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// 头结点之后暂时没有结点</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在p结点之后插入s结点</span>
    <span class="token keyword">boolean</span> <span class="token function">InsertNextHDNode</span><span class="token punctuation">(</span>HDNode p<span class="token punctuation">,</span> HDNode s<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> s <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 非法参数</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果p后面有结点</span>
            p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        s<span class="token punctuation">.</span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除p结点的后继结点</span>
    <span class="token keyword">boolean</span> <span class="token function">DeleteNextNode</span><span class="token punctuation">(</span>HDNode p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HDNode q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 找到p的后继结点q</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// p没有后继</span>
        <span class="token punctuation">}</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// q结点不是最后一个结点</span>
            q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 求表的长度</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span>HDLinkedList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        HDNode p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表第"</span> <span class="token operator">+</span> len <span class="token operator">+</span> <span class="token string">"个数据:"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            len<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="_732"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/2a/a7/I2v1aHsc_o.png" alt="image-20210326165233947"></p> 
<h4><a id="234%09_736"></a>2.3.4 循环链表</h4> 
<h5><a id="1__738"></a>1. 循环链表与普通链表的不同</h5> 
<p>循环链表的尾结点的指针指向头结点，而普通链表的尾结点指向空。</p> 
<p>通常我们无法获取之前的结点，除非拿到头结点，循环单链表可以通过遍历结点的方式从而拿到自己想要的结点。</p> 
<p>以前在增加/删除操作时，需要给最后一个结点判空，现在则不需要。</p> 
<h5><a id="2__746"></a>2. 循环双链表</h5> 
<p>表头的prior指向表尾，表尾的next指向表头。</p> 
<h5><a id="_750"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/cf/ac/KHubaLlI_o.png" alt="image-20210326165256412"></p> 
<h4><a id="235%09_754"></a>2.3.5 静态链表</h4> 
<h5><a id="1__756"></a>1. 什么是静态链表</h5> 
<p>单链表：各个结点在内存中随意散落。</p> 
<p>静态链表：分配一整片连续的内存空间，各个结点集中安置。</p> 
<p><img src="https://images2.imgbox.com/fc/dd/I68xKtDG_o.png" alt="image-20210326165336687"></p> 
<h5><a id="2__764"></a>2. 静态链表的概念</h5> 
<p>静态链表就是用数组的方式实现的链表。</p> 
<p><strong>容量固定不可变</strong></p> 
<p>本章内容不是很重要，了解其概念即可。</p> 
<h4><a id="236%09_772"></a>2.3.6 顺序表和链表的比较</h4> 
<h5><a id="1__774"></a>1. 线性结构</h5> 
<p>都属于线性结构</p> 
<h5><a id="2__778"></a>2. 存储结构</h5> 
<table><thead><tr><th align="center"></th><th align="center"><strong>顺序表</strong></th><th align="center"><strong>单链表</strong></th></tr></thead><tbody><tr><td align="center"><strong>优点</strong></td><td align="center">随机存取，存储密度高</td><td align="center">不要求大片连续空间，改变容量方便</td></tr><tr><td align="center"><strong>缺点</strong></td><td align="center">要求大片连续空间，改变容量不方便</td><td align="center">不可随机存取，要耗费一定空间存放指针</td></tr></tbody></table> 
<h5><a id="3__785"></a>3. 基本操作</h5> 
<table><thead><tr><th align="left">操作</th><th align="left">顺序表</th><th align="left">链表</th></tr></thead><tbody><tr><td align="left"><strong>创</strong></td><td align="left">需要分配大片连续空间。若分配空间过小，则之后不方便扩展；若分配空间过大，则浪费内存资源</td><td align="left">只需分配一个头结点（也可不分配），方便扩展</td></tr><tr><td align="left"><strong>销</strong></td><td align="left">长度赋0即可，本笔记采用java实现，因此无需考虑内存问题，如果使用c实现则需要通过free函数释放内存</td><td align="left">依次删除每个结点</td></tr><tr><td align="left"><strong>增，删</strong></td><td align="left">插入/删除元素都要将后续元素全部后移/前移 时间复杂度O(n),时间开销主要来自移动元素</td><td align="left">插入/删除元素只需修改指针即可 时间复杂度O(n),时间开销主要来自查找元素</td></tr><tr><td align="left"><strong>查</strong></td><td align="left">按位查找：O(1)</td><td align="left">按值查找：O(n)</td></tr></tbody></table> 
<h5><a id="4__794"></a>4. 概念</h5> 
<p>表长无法预估，需要经常进行增/删操作，可使用链表</p> 
<p>表长可预估，需要经常进行查询操作，可使用顺序表</p> 
<h3><a id="_800"></a>第三章</h3> 
<h4><a id="311%09_802"></a>3.1.1 栈的基本概念</h4> 
<h5><a id="1_Stack_804"></a>1. 栈（Stack）的概念</h5> 
<p>栈是<strong>只允许在一端进行插入或删除</strong>的线性表</p> 
<p>重要术语：栈顶，栈底，空栈</p> 
<p><img src="https://images2.imgbox.com/cd/b5/y50Z3vMG_o.png" alt="image-20210326205646609"></p> 
<p>特点：后进先出（Last In First Out）LIFO</p> 
<h5><a id="2__814"></a>2. 栈的基本操作</h5> 
<pre><code class="prism language-java"><span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化栈。构造一个空栈，分配内存空间。</span>
<span class="token function">DestroyStack</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 销毁栈。销毁并释放栈s所占用的内存空间。</span>

<span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进栈，若栈S未满，则将x加入使之成为新栈顶。</span>
<span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出栈，若栈S非空，则弹出栈顶元素，并用x返回。</span>

<span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读栈顶元素。若栈S非空，则用x返回栈顶元素。</span>

<span class="token comment">// 其他常用操作</span>
<span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断一个栈是否为空</span>
</code></pre> 
<h5><a id="_829"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/4d/45/YLpNHEm0_o.png" alt="image-20210326205510127"></p> 
<h4><a id="312%09_833"></a>3.1.2 栈的顺序存储实现</h4> 
<h5><a id="_835"></a>思路</h5> 
<p>给定一个静态数组，每次操作头或者尾即可</p> 
<p>指针用于操纵当前数据</p> 
<p><img src="https://images2.imgbox.com/06/6f/gTzSu1Br_o.png" alt="image-20210326210119682"></p> 
<h5><a id="_843"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 顺序存储实现栈
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HSqStack</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">final</span> <span class="token keyword">int</span> MAXSIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 定义栈中元素的最大个数</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 静态数组中放栈中元素</span>

    <span class="token keyword">int</span> top<span class="token punctuation">;</span> <span class="token comment">// 栈顶指针</span>

    <span class="token function">HSqStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 初始化栈</span>
    <span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 此处如果指向0，则预示已经有一个参数了，所以初始化指向-1</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断栈空</span>
    <span class="token keyword">boolean</span> <span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入栈</span>
    <span class="token keyword">boolean</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 栈满</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        top<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 指针上移一位</span>
        data<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 新元素入栈</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出栈</span>
    <span class="token keyword">boolean</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span>  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 空栈</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        x <span class="token operator">=</span> data<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 栈顶元素先出栈</span>
        top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 指针下移</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 读取栈顶元素</span>
    <span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span>  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 空栈</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        x <span class="token operator">=</span> data<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读取栈顶元素</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_903"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/dd/99/RRP4Qlhy_o.png" alt="image-20210326205743322"></p> 
<h4><a id="313%09_907"></a>3.1.3 栈的链式存储实现</h4> 
<p>用链表的方式实现栈几乎等同于单链表，此处直接套用单链表即可</p> 
<h4><a id="321%09_911"></a>3.2.1 队列的基本概念</h4> 
<h5><a id="1__913"></a>1. 什么是队列</h5> 
<p>栈（Stack）是只允许<strong>在一端进行插入或删除</strong>的线性表</p> 
<p>队列（Queue）是只允许<strong>在一端插入,在另一端删除</strong>的线性表</p> 
<p><img src="https://images2.imgbox.com/34/d5/Lme3xJYO_o.png" alt="image-20210326210328613"></p> 
<p>队列的特点：先进先出 First In First Out (FIFO)</p> 
<h5><a id="2__923"></a>2. 队列的基本操作</h5> 
<pre><code class="prism language-java"><span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化队列，构造一个空队列Q</span>
<span class="token function">DestroyQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 销毁队列，销毁并释放队列Q所占用的空间</span>

<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 入队，若队列Q未满，将x加入，使之成为新的队尾</span>
<span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队，若队列Q非空，删除队头元素，并用x返回</span>

<span class="token function">GetHead</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读队头元素，对队列Q非空，则将队头元素赋值给x</span>
<span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断队列是否为空</span>
</code></pre> 
<h5><a id="_936"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/fc/be/mk7m8Ylb_o.png" alt="image-20210326210404480"></p> 
<h4><a id="322%09_940"></a>3.2.2 队列的顺序实现</h4> 
<h5><a id="_942"></a>要点</h5> 
<p>求队列一共有多少个元素的算法如下：</p> 
<pre><code class="prism language-java"><span class="token comment">// 尾指针 + 长度 - 头指针 % 长度</span>
<span class="token punctuation">(</span>rear <span class="token operator">+</span> MAX_SIZE <span class="token operator">-</span> front<span class="token punctuation">)</span> <span class="token operator">%</span> MAX_SIZE
</code></pre> 
<p>头尾指针均为长度以内任意一个数字，因此想要求差必须先加上最大长度</p> 
<p>尾指针和头指针位置可调换</p> 
<p>概念上不会大于长度，保证代码健全性加上模运算</p> 
<h5><a id="_957"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 顺序队列
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HSqQueue</span><span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SqQueue</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 静态数组存放元素</span>
        <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">// 队头指针和队尾指针</span>

        <span class="token keyword">public</span> <span class="token function">SqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> SqQueue Q<span class="token punctuation">;</span>

    <span class="token comment">// 初始化队列</span>
    <span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        Q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始时，队头队尾全部指向空</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">boolean</span> <span class="token function">queueEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">;</span> <span class="token comment">// 当队头队尾指向一样时，则意味队列为空</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入队</span>
    <span class="token keyword">boolean</span> <span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果队头的指针的下一位指向队尾，则表示队满</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE<span class="token punctuation">;</span> <span class="token comment">// 队尾指针+1取模，保证指针不会超过长度</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出队</span>
    <span class="token keyword">boolean</span> <span class="token function">deQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 队列为空</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE<span class="token punctuation">;</span> <span class="token comment">// 队尾指针+1取模，保证指针不会超过长度</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取队头元素</span>
    <span class="token keyword">int</span> <span class="token function">getHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 队列为空</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取队列长度</span>
    <span class="token keyword">int</span> <span class="token function">queueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> Q<span class="token punctuation">.</span>MAX_SIZE <span class="token operator">-</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码不完善，仅作练习使用</p> 
<h5><a id="_1027"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/ed/35/T8yUvEiN_o.png" alt="image-20210326210438044"></p> 
<h4><a id="323%09_1031"></a>3.2.3 队列的链式实现</h4> 
<h5><a id="_1033"></a>概念</h5> 
<p>链式无需考虑内存</p> 
<h5><a id="_1037"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 链式队列
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HLinkQueue</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        LinkNode next<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">LinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">LinkNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">LinkQueue</span><span class="token punctuation">{<!-- --></span>
        LinkNode front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> LinkQueue Q<span class="token punctuation">;</span>

    <span class="token comment">// 初始化队列</span>
    <span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始时，front,rear都指向头结点</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 不带头结点的话front和rear都要指向空</span>
        Q<span class="token punctuation">.</span>front<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入队</span>
    <span class="token keyword">boolean</span> <span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        LinkNode s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment">// 如果不带头结点则front需要进行非空判断，为空则修改表头指针</span>
        Q<span class="token punctuation">.</span>rear<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 新结点挂到rear身上</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 修改表尾指针</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出队</span>
    <span class="token keyword">boolean</span> <span class="token function">deQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 空队列</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        LinkNode p <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 修改头结点的next指针</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果是最后一个结点</span>
            Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_1101"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/84/87/Kdfgv4S3_o.png" alt="image-20210326210514330"></p> 
<h4><a id="324%09_1105"></a>3.2.4 双端队列</h4> 
<h5><a id="_1107"></a>概念</h5> 
<p>栈：单端插入和删除的线性表</p> 
<p>队列：一端插入，另一端删除的线性表</p> 
<p>双端队列：两端插入，两端删除的线性表</p> 
<p>双端队列包含输入受限和输出受限两种情况，不同情况具有不同局限性，需根据情况选择</p> 
<h5><a id="_1117"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/17/49/cAFNwJbQ_o.png" alt="image-20210326212039635"></p> 
<h4><a id="331%09_1121"></a>3.3.1 栈在括号匹配中的应用</h4> 
<p>示例：</p> 
<p>一组括号，求出它们能不能完成匹配</p> 
<p>思路：</p> 
<p>使用栈，将左括号压入，如果遇到右括号就压出，遇到无法匹配的括号或者匹配结束栈里还有值则匹配失败</p> 
<p><img src="https://images2.imgbox.com/46/9d/WX60WnZS_o.png" alt="image-20210326212212977"></p> 
<h5><a id="_1133"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 给定一组括号，判断这组括号能否完成匹配
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Brancket</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> String bracketStr <span class="token operator">=</span> <span class="token string">"({}{})"</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">bracketCheck</span><span class="token punctuation">(</span>bracketStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">bracketCheck</span><span class="token punctuation">(</span>String bracketStr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>bracketStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 栈元素</span>
        <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 栈顶指针</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> bracketStr<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span> <span class="token operator">||</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'{'</span> <span class="token operator">||</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 扫描到左括号，入栈</span>
                data<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 扫描到右括号且当前栈空,匹配失败</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">char</span> topElem <span class="token operator">=</span> data<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 栈顶元素出栈</span>
                <span class="token comment">// 进行匹配，如果匹配失败则返回false</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> topElem <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> topElem <span class="token operator">!=</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'}'</span> <span class="token operator">&amp;&amp;</span> topElem <span class="token operator">!=</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 括号校验完成且栈空则匹配成功</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="332%09_1180"></a>3.3.2 栈在表达式求值中的应用（上）</h4> 
<h5><a id="_1182"></a>三种表达式的不同</h5> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fcNMwH0u-1618913822522)(https://i.loli.net/2021/02/01/2GOCL9hukZWgNse.png)]</p> 
<p>中缀表达式</p> 
<p>运算符在中间，既为我们常用的数学表达式</p> 
<p>后缀表达式</p> 
<p>运算符在后面，又叫逆波兰表达式（Reverse Polish notation）</p> 
<p>前缀表达式</p> 
<p>运算符在前面，因为是波兰人提出，所以又叫波兰表达式（Polish notation）</p> 
<table><thead><tr><th align="center">中缀表达式</th><th align="center">后缀表达式</th><th align="center">前缀表达式</th></tr></thead><tbody><tr><td align="center">a + b</td><td align="center">ab +</td><td align="center">+ ab</td></tr><tr><td align="center">a + b - c</td><td align="center">a b + c -</td><td align="center">- + ab c</td></tr><tr><td align="center">a + b - c * d</td><td align="center">ab + cd * -</td><td align="center">- + ab * cd</td></tr></tbody></table> 
<p>核心思想还是一个计算区间一块区域，诸如(a + b) - (c * d) = （ab+）(cd*) -</p> 
<h5><a id="_1206"></a>中缀转后缀</h5> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UCf07h9Q-1618913822523)(https://i.loli.net/2021/02/01/t2GmHCKyBF59gvq.png)]</p> 
<p>左优先原则：只要左边的运算符能先计算，就先计算左边的</p> 
<h5><a id="_1212"></a>后缀表达式的手算方法</h5> 
<p>从左往右扫描，每遇到一个运算符，就让运算符前面<strong>最近的两个操作数</strong>执行对应操作，合并为一个操作数</p> 
<p><strong>对于计算机而言，后缀表达式的效率往往要更高</strong></p> 
<h5><a id="_1218"></a>中缀表达式转前缀表达式</h5> 
<p>右优先原则：只要右边的操作符能先计算，就优先计算右边的</p> 
<pre><code>中缀
A + B * (C - D) - E / F
常规计算
- + A * B - C D / E F
右优先
+ A - * B - C D / E F
</code></pre> 
<h5><a id="_1231"></a>后缀表达式的机算方法</h5> 
<p>① 从左到右扫描下一个元素，直到处理完所有元素</p> 
<p>② 若扫描到操作数则入栈</p> 
<p>③ 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果入栈</p> 
<h5><a id="_1239"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/21/fa/DspzwBp9_o.png" alt="image-20210326212341082"></p> 
<h4><a id="332%09_1243"></a>3.3.2 栈在表达式求值中的应用（下）</h4> 
<h5><a id="_1245"></a>中缀转后缀</h5> 
<p>① 遇到操作数，直接加入后缀表达式</p> 
<p>② 遇到界限符。遇到 ( 直接入栈，遇到 ) 则依次弹出栈内运算符并加入后缀表达式，直到弹出 ( 为止。注意（ 不加后缀</p> 
<p>③ 遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 ( 或栈空则停止。之后再将当前运算符入栈。</p> 
<h5><a id="_1253"></a>中缀的计算</h5> 
<p>中缀转后缀 + 后缀求值</p> 
<p>① 初始化两个栈，操作数栈和运算符栈</p> 
<p>② 若扫描到操作数，压入操作数栈</p> 
<p>③ 若扫描到运算符或界限符，则按照‘中缀转后缀’相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要在弹出两个操作数栈的栈顶元素并执行相应运算，运算结果在压回操作数栈）</p> 
<h5><a id="_1263"></a>代码</h5> 
<p>因时间原因，此处仅列出中转后和后计算</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Pattern<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 后缀表达式
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PolishNotation</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 中缀表达式</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String notation <span class="token operator">=</span> <span class="token string">"((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1))"</span><span class="token punctuation">;</span>
    <span class="token comment">// 后缀表达式</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String poNotation <span class="token operator">=</span> <span class="token string">"15 7 1 1 + - / 3 * 2 1 1 + + -"</span><span class="token punctuation">;</span>
    <span class="token comment">// 前缀表达式</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String rpoNotation <span class="token operator">=</span> <span class="token string">"- * / 15 - 7 + 1 1 3 + 2 + 1 1"</span><span class="token punctuation">;</span>
    <span class="token comment">// 10的倍数</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exactNums <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中计算："</span> <span class="token operator">+</span> <span class="token function">countNum</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中转后："</span> <span class="token operator">+</span> <span class="token function">commTransRpo</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"后计算："</span> <span class="token operator">+</span> <span class="token function">poCount</span><span class="token punctuation">(</span>poNotation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 中缀转后缀
     */</span>
    <span class="token keyword">static</span> String <span class="token function">commTransRpo</span><span class="token punctuation">(</span>String notation<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Stack<span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> notation<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    j<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                i <span class="token operator">+=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">char</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span><span class="token punctuation">(</span>pop <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pop <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">switch</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>
                        <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>
                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                    <span class="token keyword">char</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token keyword">if</span><span class="token punctuation">(</span>pop <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">!=</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pop <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token punctuation">}</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>
                        <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>
                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'-'</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                    <span class="token keyword">char</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token keyword">if</span><span class="token punctuation">(</span>pop <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">!=</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pop <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token punctuation">}</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 后缀计算
     */</span>
    <span class="token keyword">static</span> Integer <span class="token function">poCount</span><span class="token punctuation">(</span>String notation<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        Stack<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> notation<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> count <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    j<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                i <span class="token operator">+=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">switch</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        res <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 求和（中缀）
     */</span>
    <span class="token keyword">static</span> Integer <span class="token function">countNum</span><span class="token punctuation">(</span>String notation<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">poCount</span><span class="token punctuation">(</span><span class="token function">commTransRpo</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 判断一个字符是否为Integer
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isInteger</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"[0-9]*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="333%09_1417"></a>3.3.3 栈在递归中的应用</h4> 
<h5><a id="_1419"></a>什么问题适合用递归算法解决</h5> 
<p>可以把原始问题转换为<strong>属性相同，但规模较小</strong>的问题</p> 
<p><img src="https://images2.imgbox.com/29/69/b621VcxG_o.png" alt="image-20210326212649394"></p> 
<h5><a id="_1425"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/13/0a/qYMlTOS5_o.png" alt="image-20210326212752974"></p> 
<h4><a id="334%09_1429"></a>3.3.4 队列的应用</h4> 
<h5><a id="_1431"></a>队列在操作系统中的应用</h5> 
<p>多个进程争抢着使用有限的系统资源时，<strong>FCFS</strong>(First Come First Service, <strong>先来先服务</strong>)是一种常用策略</p> 
<h4><a id="34__1435"></a>3.4 特殊矩阵的压缩存储</h4> 
<p><img src="https://images2.imgbox.com/63/19/4GTDvgtI_o.png" alt="image-20210326213308798"></p> 
<h5><a id="_1439"></a>一维数组存储结构</h5> 
<p>各数组元素大小相同，且物理上连续存放</p> 
<pre><code>LOC + i * sizeof(ElemType)
</code></pre> 
<p>除特殊说明，否则数组<strong>下标默认从0开始</strong></p> 
<h5><a id="_1449"></a>二维数组存储结构</h5> 
<pre><code>M行N列的二位数组b[M][N]中，若按行优先存储，则b[i][j]的存储地址
LOC + (i * N + j) * sizeof(elemeType)

M行N列的二位数组b[M][N]中，若按列优先存储，则b[i][j]的存储地址
LOC + (j * M + i) * sizeof(elemeType)
</code></pre> 
<p>思路：无论行列优先，从起始地址遍历到当前元素即可得到存储地址</p> 
<h5><a id="_1461"></a>对称矩阵</h5> 
<p>若n阶<strong>方阵</strong>中任意一个元素a i,j 都有 <strong>a i, j = a j, <strong>,则该矩阵称为</strong>对称矩阵</strong></p> 
<p><img src="https://images2.imgbox.com/2b/60/KFQEjDDd_o.png" alt="image-20210326213545801"></p> 
<p>策略：只存储主对角线+下三角区</p> 
<p>使用一维数组存储，则取值为:<br> 行优先：先根据i值求出上面有几行，在根据j值求出在当前行的位置</p> 
<p>列优先：同上，将位置调换即可</p> 
<h5><a id="_1474"></a>三角矩阵</h5> 
<p>下三角矩阵：除了主对角线和下三角区，其余都相同</p> 
<p>上三角矩阵：除了主对角线和上三角区，其余都相同</p> 
<p><img src="https://images2.imgbox.com/0c/06/Mp7Acmmx_o.png" alt="image-20210326213643463"></p> 
<p>存储策略：将中线和三角区按照<strong>行优先</strong>存入，最后一个位置存放常量c</p> 
<h5><a id="_1484"></a>三对角矩阵</h5> 
<p>又称带状矩阵，既中线周围一圈都有值，其余皆为0</p> 
<p><img src="https://images2.imgbox.com/3a/97/bYhJd0mN_o.png" alt="image-20210326213719998"></p> 
<p>首行和尾行是两个，其余都是三个</p> 
<h5><a id="_1492"></a>稀疏矩阵</h5> 
<p>非零元素远远少于矩阵元素的个数，且<strong>无规则分布</strong></p> 
<p><strong>存储策略一：顺序存储</strong></p> 
<p>三元组 &lt;行，列，值&gt;</p> 
<p><strong>此处行列从1开始</strong></p> 
<p><img src="https://images2.imgbox.com/2d/b2/uznErIf2_o.png" alt="image-20210326213938697"></p> 
<p><strong>存储策略二：十字链表法</strong></p> 
<p><img src="https://images2.imgbox.com/21/da/cqKOMmx9_o.png" alt="image-20210326214019017"></p> 
<p><img src="https://images2.imgbox.com/2f/ba/GDzZDKWy_o.png" alt="image-20210326214037617"></p> 
<h5><a id="_1510"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/b7/fc/Jb7tE4TQ_o.png" alt="image-20210326214104251"></p> 
<h3><a id="_1514"></a>第四章</h3> 
<h4><a id="421%09_1516"></a>4.2.1 串的定义和基本操作</h4> 
<h5><a id="_1518"></a>串的定义</h5> 
<p>串，既字符串(String)是由零个或多个<strong>字符</strong>组成的有限序列。</p> 
<p>举例：</p> 
<p>S = “Hello World!”<br> T = ‘iPhone 1 Pro Max?’</p> 
<p>子串：串中任意个连续的字符组成的子序列 Eg : ‘iPhone’,'Pro M’是串的子串</p> 
<p>主串：包含子串的串。 Eg : T是子串’iPhone’的主串</p> 
<p>字符在主串中的位置:字符在串中的序号。 Eg:'1’在T中的位置是8</p> 
<p>子串在主串中的位置:子串的第一个字符在主串中的位置 Eg:'11 Pro’在T中的位置是8</p> 
<h5><a id="_1535"></a>操作</h5> 
<pre><code>StrAssign(T, chars); // 赋值操作。将chars的值赋给T
StrCopy(T, S); // 赋值操作。将串S复制给串T
StrEmpty(S); // 判空操作。若S为空串，则返回true，否则返回false
StrLength(S); // 求串长。返回串S的元素个数.
ClearString(S); // 清空操作。将S清为空串
DestoryString(S); // 销毁串。将串S销毁
Concat(T, S1, S2); // 串链接。由T返回由S1和S2连接而成的新串
SubString(Sub, S, pos, len); // 求子串。用Sub返回S中从pos开始到len的子串
Index(S, T); // 定位操作。若主串S中存在与T相同的子串，则返回一个字符的位置，否则返回0
StrCompare(S, T); // 比较操作。若S&gt;T，则返回值&gt;0，S&lt;T则返回值&lt;0,S=T则返回0
</code></pre> 
<h5><a id="_1550"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/22/a9/7L8eY7XE_o.png" alt="image-20210326214135281"></p> 
<h4><a id="412%09_1554"></a>4.1.2 串的存储结构</h4> 
<h5><a id="_1556"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/e4/ac/kVMK7Kg1_o.png" alt="image-20210326214215168"></p> 
<h4><a id="421%09_1560"></a>4.2.1 串的朴素模式匹配</h4> 
<h5><a id="_1562"></a>思路</h5> 
<p>在<strong>主串</strong>中找到<strong>模式串</strong>相同的<strong>子串</strong></p> 
<p>因该算法思路简单了然，故叫朴素模式匹配</p> 
<table><thead><tr><th align="center">最好时间复杂度</th><th align="center">O（m）</th></tr></thead><tbody><tr><td align="center">常规时间复杂度</td><td align="center">O（n）</td></tr><tr><td align="center">最坏时间复杂度</td><td align="center">O (nm)</td></tr></tbody></table> 
<h5><a id="_1573"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/bd/f7/vC3H5hna_o.png" alt="image-20210326214337675"></p> 
<h4><a id="422%09KMP_1577"></a>4.2.2 KMP算法（上）</h4> 
<h5><a id="KMP_1579"></a>什么是KMP算法</h5> 
<p>朴素模式匹配的优化</p> 
<p>由三个人提出，各取名字中一个字母，因此叫KMP算法</p> 
<h5><a id="_1585"></a>朴素模式匹配的缺点</h5> 
<p>当某些子串与模式串能部分匹配时，<strong>主串的扫描指针i经常回溯</strong>，导致时间开销增加</p> 
<h4><a id="423%09KMP_1589"></a>4.2.3 KMP算法（下）</h4> 
<p>学不会，等我学会了再来补充</p> 
<h4><a id="424%09KMP_1593"></a>4.2.4 KMP算法的进一步</h4> 
<p>同上</p> 
<h3><a id="_1597"></a>第五章</h3> 
<h4><a id="51%09_1599"></a>5.1 树的基本概念</h4> 
<p><img src="https://images2.imgbox.com/71/19/Zsza3iBf_o.png" alt="image-20210326214542431"></p> 
<h5><a id="_1603"></a>什么是树</h5> 
<p>树是 n (n &gt;= 0) 个结点的有限集合，n = 0 时，称为空树。</p> 
<p>而任意非空树应该满足:</p> 
<p>1.有且仅有一个特定的称为<strong>根</strong>的结点。</p> 
<p>2.当 n &gt; 1时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根节点的<strong>子树</strong>。</p> 
<h5><a id="_1613"></a>基本术语</h5> 
<ol><li>节点的度：一个节点含有的子树的个数称为该节点的<strong>度</strong>；</li><li>树的度：一棵树中，<strong>最大的节点</strong>度称为树的度；</li><li>叶节点或终端节点：度为零的节点；</li><li>非终端节点或分支节点：度不为零的节点；</li><li>父亲节点：若一个节点<strong>含有子节点</strong>，则这个节点称为其子节点的<strong>父节点</strong>；</li><li>孩子节点：一个节点<strong>含有的子树的根节点</strong>称为该节点的<strong>子节点</strong>；</li><li>兄弟节点：具有<strong>相同父节点</strong>的节点互称为<strong>兄弟节点</strong>；</li><li>层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li><li>高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li><li>堂兄弟节点：父节点在<strong>同一层的节点</strong>互为堂兄弟；</li><li>节点的祖先：从根到该节点所经分支上的所有节点；</li><li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li>森林：由m（m&gt;=0）棵互不相交的树的集合称为<strong>森林</strong>。</li></ol> 
<p><strong>树的种类</strong></p> 
<ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li><li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；</li><li>二叉树：每个节点最多含有两个子树的树称为二叉树；</li><li>完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</li><li>满二叉树：所有叶节点都在最底层的完全二叉树；</li><li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li>排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；</li><li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li><li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li></ul> 
<h4><a id="521%09_1642"></a>5.2.1 二叉树的概念</h4> 
<h5><a id="_1644"></a>什么是二叉树</h5> 
<p>二叉树是n（n&gt;=0）个结点的有限集合。</p> 
<ol><li>n = 0 时，二叉树为空；</li><li>n &gt; 0 时，由根节点和两个互不相交的左右子树组成。左右子树也分别是一颗二叉树。</li></ol> 
<h5><a id="2_1651"></a>二叉树与度为2的有序树的区别</h5> 
<table><thead><tr><th align="center">二叉树</th><th align="center">度为2的有序树</th></tr></thead><tbody><tr><td align="center">可以为空</td><td align="center">至少有三个结点</td></tr><tr><td align="center">子结点始终有左右之分</td><td align="center">子结点次序相对</td></tr></tbody></table> 
<h5><a id="_1658"></a>满二叉树</h5> 
<p>一颗高度为h，且含有2h - 1个结点的二叉树称为满二叉树</p> 
<h5><a id="_1662"></a>完全二叉树</h5> 
<p>相对于满二叉树，完全二叉树最后一层可以缺少结点或叶子</p> 
<h5><a id="_1666"></a>二叉排序树</h5> 
<p>对任意结点而言，左子树关键字均小于该结点，右子树关键字均大于该结点</p> 
<h5><a id="_1670"></a>平衡二叉树</h5> 
<p>树上<strong>任意结点</strong>的左右子树的深度之差不超过1</p> 
<h5><a id="_1674"></a>二叉树的性质</h5> 
<ol><li> <p>非空二叉树的叶子结点数等于度为2的结点数 + 1</p> </li><li> <p>非空二叉树第k层至多有2的k - 1 次幂个结点（K &gt;= 1）</p> <p>第一层 1 个结点，二层 2 * 1 = 2个结点，三层 2 * 2 = 4个结点，以此类推</p> </li><li> <p>高度为h的二叉树至多有2的h次方 - 1 个结点（K &gt;= 1）</p> <p>由上一条可得此条结论</p> </li></ol> 
<h4><a id="522%09_1686"></a>5.2.2 二叉树的存储结构</h4> 
<h5><a id="_1688"></a>顺序存储</h5> 
<p>用一组连续的存储单元依次自上而下，自左至右存储完全二叉树的结点元素</p> 
<h5><a id="_1692"></a>链式存储</h5> 
<p>用链表来存放二叉树，二叉树中每个结点用链表的一个链结点来存储。</p> 
<p>链式存储需要一个数据域和一个指针域，指针域存放两个指针，一个指向左几点，一个指向右节点</p> 
<h4><a id="531%09_1698"></a>5.3.1 二叉树的遍历</h4> 
<h5><a id="_1700"></a>并查集</h5> 
<p>一种简单的集合表示。</p> 
<h3><a id="_1703"></a>前言</h3> 
<h5><a id="_1705"></a>仙人指路</h5> 
<p>[第一章](# 第一章)为入门，讲解数据结构是干什么的</p> 
<p>[第二章](# 第二章)到第四章是数据结构基础，主要讲解链表，栈，队列，串等</p> 
<p>[第五章](# 第五章)是二叉树</p> 
<p>[第六章](# 第六章)是图,此章偏难，非考研或算法从业可粗略看</p> 
<p>[第七章](# 第七章)到第八章是查找以及各种排序</p> 
<p>[第九章](# 第九章)为补充，教材中没有的部分概念我随机补充上去</p> 
<h5><a id="_1719"></a>墨尘の话</h5> 
<p>本文内容<strong>主要参考王道考研</strong>，其中21版本咸鱼学长的课尚可，20版本比较枯燥,可选择性学习</p> 
<p>浙大陈越姥姥的课比较精简且侧重于练习，能看懂且时间多的蛋疼可以看这个</p> 
<p>因时间关系,后期比较匆促，本人也就是学着玩玩╮(╯▽╰)╭，可多参考链接自主学习</p> 
<h5><a id="_1727"></a>参考视频</h5> 
<p><a href="https://www.bilibili.com/video/BV1b7411N798" rel="nofollow">2020 王道考研 数据结构 - B站</a></p> 
<p><a href="https://www.bilibili.com/video/BV1JW411i731" rel="nofollow">数据结构-浙江大学 - B站</a></p> 
<h3><a id="_1733"></a>第一章</h3> 
<h3><a id="111__1735"></a>1.1.1 数据机构的基本概念</h3> 
<h4><a id="1__1737"></a>1. 什么是数据结构</h4> 
<p><strong>数据：信息的载体，是描述客观事务属性的数，字符，以及所有能输入到计算机种并被计算机程序识别和处理的符号集合</strong></p> 
<p>数据对象： 具有相通性质的数据元素的集合，是数据的一个子集</p> 
<p>数据元素： 数据的基本单位，通常作为一个整体进行考虑和处理</p> 
<p>数据项： 构成数据元素的不可分割的最小单位</p> 
<p>举例：一群人，就是一个数据对象，每个人就是一个数据元素，他们的手，头等就是数据项</p> 
<p><strong>结构：数据中存在某种关联关系，称为结构</strong></p> 
<p>举例：小明是八年级一班中的学生，成绩为100</p> 
<p>上例中小明和成绩是数据项，一班是数据元素，八年级是数据对象</p> 
<h4><a id="2__1755"></a>2. 数据结构三要素</h4> 
<h5><a id="1__1757"></a>1. 逻辑结构</h5> 
<p><strong>线性结构</strong></p> 
<p>线性结构： 数据元素是一对一的关系，除了第一个元素，所有都有唯一前驱（前面有一个节点）；除了最后一个元素，所有元素都有唯一后继（后面有一个节点）</p> 
<p><strong>非线性结构</strong></p> 
<p>集合： 一组元素属于同一个集合，除此外别无关系</p> 
<p>树形结构： 数据元素之间是一对多的关系</p> 
<p>图状结构： 数据元素之间是多对多的关系</p> 
<p><img src="https://images2.imgbox.com/a4/49/2iqvM8q9_o.png" alt="image-20210326163346644"></p> 
<h5><a id="2__1773"></a>2. 存储结构</h5> 
<p><strong>顺序存储</strong></p> 
<p>顺序存储： 把<strong>逻辑上相邻</strong>的元素存储在<strong>物理位置也相邻</strong>的存储单元中，元素之间的关系靠存储单元的邻接关系体现</p> 
<p><strong>非顺序存储</strong></p> 
<p>链式存储： <strong>逻辑上相邻</strong>的元素在<strong>物理位置上可以不相邻</strong>，借助元素存储地址的指针来表示元素之间的逻辑关系</p> 
<p>索引存储： 在存储元素信息的同时，还建立附加的索引表。索引表中每项称为索引项，索引项一般为（关键字，地址）</p> 
<p>散列存储： 根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p> 
<p>顺序存储便于查找，非顺序查找便于增删</p> 
<p><img src="https://images2.imgbox.com/6f/05/aHDlEEtp_o.png" alt="image-20210326163403699"></p> 
<h5><a id="3__1793"></a>3. 数据的运算</h5> 
<p><img src="https://images2.imgbox.com/28/52/cLMUYb9R_o.png" alt="image-20210326163428469"></p> 
<h4><a id="3__1797"></a>3. 概念</h4> 
<p><img src="https://images2.imgbox.com/0d/46/DVQRfBDV_o.png" alt="image-20210326163444137"></p> 
<h3><a id="121__1801"></a>1.2.1 算法的基本概念</h3> 
<h4><a id="1__1803"></a>1. 什么是算法</h4> 
<p>程序 = 数据结构 + 算法</p> 
<p>数据结构负责将现实世界的问题转化为信息，然后将信息存入计算机</p> 
<p>算法是处理信息的步骤，负责将信息进行处理得到我们想要的结果</p> 
<h4><a id="2__1811"></a>2. 算法的特性</h4> 
<ol><li>有穷性： 有限时间里可以执行完</li><li>可行性： 可以用现有的操作实现算法</li></ol> 
<p><strong>好算法的特性</strong></p> 
<ol><li>正确性：正确解决问题</li><li>可读性：别人也能很清晰的看明白</li><li>健壮性（鲁棒性）： 可以处理异常情况，比如非法数据等</li><li><strong>高效率： 省时间，省内存</strong></li></ol> 
<h4><a id="3__1823"></a>3. 概念</h4> 
<p><img src="https://images2.imgbox.com/db/b2/GiimFsTD_o.png" alt="image-20210326164240364"></p> 
<h3><a id="122__1827"></a>1.2.2 时间复杂度</h3> 
<h4><a id="1__1829"></a>1. 如何评价算法的时间开销</h4> 
<p>1.和机器性能相关，诸如超级计算机 vs 单片机</p> 
<p>2.和编程语言相关，越高级的语言效率越低</p> 
<p>3.和编译程序产生的机器指令相关</p> 
<p>4.有些算法是不能事后统计的</p> 
<p>通常情况机器性能和编程语言无法改变，因此考虑如何优化程序性能即可</p> 
<p><strong>时间开销与问题规模n之间的关系</strong></p> 
<h4><a id="2__1845"></a>2. 如何计算</h4> 
<p>一般指代循环/迭代，循环的次数越多时间复杂度越高（参考下图）</p> 
<p><img src="https://images2.imgbox.com/e1/7d/N7J8dmjP_o.png" alt="image-20210326164348922"></p> 
<h4><a id="3__1851"></a>3. 三种复杂度</h4> 
<p>1.最坏时间复杂度： 考虑最坏的情况</p> 
<p>2.平均时间复杂度： 考虑所有输入情况都处于同等概率</p> 
<p>3.最好时间复杂度： 考虑最好的情况</p> 
<p><strong>评定一个算法的时间复杂度好坏通常要拿最坏情况去考虑</strong></p> 
<h4><a id="4__1861"></a>4. 概念</h4> 
<p><img src="https://images2.imgbox.com/75/a4/LUpl7EeK_o.png" alt="image-20210326164401093"></p> 
<h3><a id="123__1865"></a>1.2.3 空间复杂度</h3> 
<p>通俗理解：每个变量都会在内存中开辟一个新的空间，因此基于空间复杂度优化变量越少越好，递归尤甚</p> 
<p><strong>内存开销与问题规模n之间的关系</strong></p> 
<p>基于现在计算机内存来讲，通常我们只需要考虑时间复杂度，空间复杂度无需作为首选考虑</p> 
<h4><a id="1__1873"></a>1. 概念</h4> 
<p><img src="https://images2.imgbox.com/a2/b7/O0FHHnh5_o.png" alt="image-20210326164503662"></p> 
<h3><a id="_1879"></a>第二章</h3> 
<h4><a id="21%09_1881"></a>2.1 线性表的定义的基本操作</h4> 
<h5><a id="1__1883"></a>1. 线性表的定义</h5> 
<p>线性表是具有<strong>相同</strong>数据类型的n（n &gt;= 0）个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时线性表是一个空表</p> 
<p><img src="https://images2.imgbox.com/12/4f/o3LYPyMQ_o.png" alt="image-20210326164516562"></p> 
<h5><a id="2__1889"></a>2. 线性表的基本操作</h5> 
<pre><code class="prism language-java"><span class="token comment">// 初始化表。构造一个空的线性表L，分配内存空间</span>
<span class="token function">InitList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// 销毁操作。销毁线性表，并释放线性表L所占用的内存空间</span>
<span class="token function">DestroyList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// 插入操作。在表L中第i个位置上插入指定元素e</span>
<span class="token function">ListInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值</span>
<span class="token function">ListDelete</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 按值查找操作。在表L中查找具有给定关键字值的元素。</span>
<span class="token function">LocateElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 按位查找操作。获取表L中第i个位置的元素的值。</span>
<span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 其他常用操作</span>

<span class="token comment">// 求表长。返回线性表L的所有元素值。</span>
<span class="token function">Length</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出操作。按前后顺序输出线性表L的所有元素值。</span>
<span class="token function">PrintList</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 判空操作。若L为空表，则返回true，否则返回false</span>
<span class="token function">Empty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>Tips:</p> 
<p>1.<strong>对数据的操作（分析思路） —— 创销，增删改查（适用于所有数据结构）</strong></p> 
<p>2.java函数的定义 —— &lt;返回值类型&gt; 函数名（&lt;参数1类型&gt; 参数1，&lt;参数2类型&gt; 参数2，…）</p> 
<p>3.实际开发中，可根据实际需求定义其他的基本操作（输出，判空等）</p> 
<p>4.函数名和参数的形式，命名都可改变（Reference: 严蔚敏版《数据结构与算法》）</p> 
<h5><a id="_1929"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/13/22/S5AvvrgT_o.png" alt="image-20210326164531526"></p> 
<h4><a id="221%09_1933"></a>2.2.1 顺序表的定义</h4> 
<h5><a id="1__1935"></a>1. 顺序表的定义</h5> 
<p>用顺序存储的方式实现线性表</p> 
<p>顺序存储：把<strong>逻辑上相邻</strong>的元素存储在<strong>物理位置上也相邻</strong>的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p> 
<h5><a id="2__1941"></a>2. 顺序表的特点</h5> 
<p>​ <strong>优点</strong></p> 
<ol><li> <p>随机访问，既可以在O(1)时间内找到第一个元素</p> </li><li> <p>存储密度高，每个节点只存储数据元素</p> <p><strong>缺点</strong></p> </li><li> <p>拓展容量不方便（采用动态分配时间复杂度较高）</p> </li><li> <p>插入，删除不方便，需要移动大量元素</p> </li></ol> 
<h5><a id="3__1955"></a>3. 概念</h5> 
<p>注：图上所示函数均为c语言中动态分配相关函数，可根据自身情况选择性学习</p> 
<p>代码在2.2.2.2 顺序表的查找一节</p> 
<p><img src="https://images2.imgbox.com/5c/a0/d7ANjiTp_o.png" alt="image-20210326164618599"></p> 
<h4><a id="2221%09_1963"></a>2.2.2.1 顺序表的插入删除</h4> 
<h5><a id="_1965"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/3b/a7/zYQgrlJl_o.png" alt="image-20210326164640102"></p> 
<h4><a id="2222%09_1969"></a>2.2.2.2 顺序表的查找</h4> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 顺序表
 * @author: HouBo
 * @Date: 2020/11/26 17:52
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SqList</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXSIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 最大长度</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 使用静态数组存放数据</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>  <span class="token comment">// 顺序表的当前长度</span>

    <span class="token comment">// 初始化一个顺序表</span>
    <span class="token keyword">void</span> <span class="token function">initList</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        L<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 初始长度为0</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 添加一个数据</span>
    <span class="token keyword">boolean</span> <span class="token function">listInsert</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前i的值是否有效</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> MAXSIZE<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前存储空间是否充盈</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 将第i个元素之后的元素后移</span>
            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 在位置i处放入e</span>
        <span class="token punctuation">}</span>
        L<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 长度+1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除一个数据</span>
    <span class="token keyword">boolean</span> <span class="token function">listDelete</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 当前i的值是否有效</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        e <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 将第i个元素之后的元素后移</span>
            L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 在位置i处放入e</span>
        <span class="token punctuation">}</span>
        L<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 长度-1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 按位查找</span>
    <span class="token keyword">int</span> <span class="token function">getElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按值查找</span>
    <span class="token keyword">int</span> <span class="token function">locateElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此段代码非最优解，仅作练习使用</p> 
<h5><a id="_2039"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/9f/f6/afSVZZc2_o.png" alt="image-20210326164703240"></p> 
<h4><a id="231%09_2043"></a>2.3.1 单链表的定义</h4> 
<h5><a id="1__2045"></a>1. 什么是单链表</h5> 
<p>相对于顺序表，单链表除了存储数据元素外，还需要存储指向下一个节点的指针</p> 
<p><img src="https://images2.imgbox.com/3f/da/h7DFSJAC_o.png" alt="image-20210326164749030"></p> 
<h5><a id="2__2051"></a>2. 单链表和顺序表的不同</h5> 
<table><thead><tr><th align="center"></th><th align="center">顺序表</th><th align="center">单链表</th></tr></thead><tbody><tr><td align="center">优点</td><td align="center">随机存取，存储密度高</td><td align="center">不要求大片连续空间，改变容量方便</td></tr><tr><td align="center">缺点</td><td align="center">要求大片连续空间，改变容量不方便</td><td align="center">不可随机存取，要耗费一定空间存放指针</td></tr></tbody></table> 
<h5><a id="_2058"></a>带头结点和不带头结点的区别</h5> 
<p>创立第一个结点，既为带头结点，反之则为不带</p> 
<p>不带头结点，对第一个数据结点和后续数据结点的处理需要用不用的代码逻辑，空表和非空表的处理同理</p> 
<p><strong>带头结点通常情况下优于不带</strong></p> 
<h5><a id="_2066"></a>概念</h5> 
<p>代码放在2.3.2.3 单链表的建立一节中</p> 
<p><img src="https://images2.imgbox.com/c4/e9/w1GT98oJ_o.png" alt="image-20210326164901618"></p> 
<h4><a id="2321%09_2072"></a>2.3.2.1 单链表的插入删除</h4> 
<p>此章中，p通过代指当前结点，s指新插入的结点, a1指下一个结点, e指新值</p> 
<h5><a id="11__2076"></a>1.1 按位序插入(带头结点)</h5> 
<p>思路：插入结点打断链表，上一个结点挂到它身上（指向它），它挂到下一个结点身上。</p> 
<p><strong>链表插入删除操作和顺序表相比相对复杂，需多多思考。</strong></p> 
<p><img src="https://images2.imgbox.com/a4/31/fYm5sD84_o.png" alt="image-20210326165108584"></p> 
<h5><a id="12__2084"></a>1.2 按位序插入（不带头结点）</h5> 
<p>不带头结点第一个结点需要做特殊处理，创建一个s，将第a1挂到它身上。</p> 
<h5><a id="2__2088"></a>2. 指定结点的后插操作</h5> 
<p>a1挂到s身上，s挂到p身上。</p> 
<h5><a id="3__2092"></a>3. 指定结点的前插操作</h5> 
<p>由于无法直接获取p的上一个结点，因此可采用如下方法实现:</p> 
<p>思路：将p变更为s, s变更为p</p> 
<p>实现：p的值赋给s，新值e赋给p</p> 
<h5><a id="4__2100"></a>4. 按位序删除</h5> 
<p>思路：找到要删除的结点，断开它并释放空间</p> 
<h5><a id="5__2104"></a>5. 指定结点的删除</h5> 
<p>思路：同上</p> 
<p>实现：将p的值和下一个引用都指向下一个，实现删除p的效果</p> 
<p>此处如果p是最后一个结点，将会出现异常</p> 
<p><strong>单链表的局限性：无法逆向检索，不方便</strong></p> 
<h5><a id="6__2114"></a>6. 概念</h5> 
<p><img src="https://images2.imgbox.com/4b/9a/dewQTfKf_o.png" alt="image-20210326165124409"></p> 
<h4><a id="2322%09_2118"></a>2.3.2.2 单链表的查找</h4> 
<h5><a id="_2120"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/90/0b/cIVvENzv_o.png" alt="image-20210326165137520"></p> 
<h4><a id="2323%09_2124"></a>2.3.2.3 单链表的建立</h4> 
<p>思路：遍历所有结点，通过头插或者尾插的方式实现循环建立一个单链表。</p> 
<p><strong>头插法可以实现反转链表，注意这是个重点</strong></p> 
<h5><a id="_2130"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 结点
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HNode</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token function">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">HNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 数据</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token comment">// 下一个结点</span>
    HNode next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 单链表
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HLinkerList</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 链表的头结点</span>
    HNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment">// 初始化一个空链表</span>
    <span class="token keyword">boolean</span> <span class="token function">InitList</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        L<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个头结点,如果不带头结点此处直接赋空</span>
        L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// 头结点之后暂时没有结点</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在第i个位置插入元素e</span>
    <span class="token keyword">boolean</span> <span class="token function">ListInsert</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 以下代码段为不带头结点的操作</span>
<span class="token comment">//        if(i == 1) { // 插入第一个结点的操作与其他结点操作不同</span>
<span class="token comment">//            HNode s = new HNode();</span>
<span class="token comment">//            s.data = e;</span>
<span class="token comment">//            s.next = L.head.next;</span>
<span class="token comment">//            L.head = s; // 头指针指向新结点</span>
<span class="token comment">//        }</span>
<span class="token comment">//        HNode p; // 指针p向前扫描到的结点</span>
<span class="token comment">//        int j = 0; // 当前p指向的是第几个结点，不带的话此处赋1</span>
<span class="token comment">//        p = L.head; // L指向头结点，头结点是第0个结点</span>
<span class="token comment">//        while (p != null &amp;&amp; j &lt; i - 1) { // 循环找到 i - 1 个结点</span>
<span class="token comment">//            p = p.next;</span>
<span class="token comment">//            j++;</span>
<span class="token comment">//        }</span>
        HNode p <span class="token operator">=</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//        if(p == null){ // i值不合法</span>
<span class="token comment">//            return false;</span>
<span class="token comment">//        }</span>
<span class="token comment">//        HNode s = new HNode();</span>
<span class="token comment">//        s.data = e;</span>
<span class="token comment">//        s.next = p.next;</span>
<span class="token comment">//        p.next = s; // 将结点s连到p之后</span>
<span class="token comment">//        return true; // 插入成功</span>

        <span class="token keyword">return</span> <span class="token function">InsertNextNode</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 后插操作：在p结点之后插入元素e</span>
    <span class="token keyword">boolean</span> <span class="token function">InsertNextNode</span><span class="token punctuation">(</span>HNode p<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// 新结点s存储数据e</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 新结点s挂到p身上</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 前插操作：在p结点之前插入元素e</span>
    <span class="token keyword">boolean</span> <span class="token function">InsertPriorNode</span><span class="token punctuation">(</span>HNode p<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 新结点s挂到p身上</span>
        s<span class="token punctuation">.</span>data <span class="token operator">=</span> p<span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token comment">// 将p里面的元素复制到s中</span>
        p<span class="token punctuation">.</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span> <span class="token comment">// p中的元素覆盖为e</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按位序删除</span>
    <span class="token keyword">boolean</span> <span class="token function">ListDelete</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        HNode p; // 指针p向前扫描到的结点</span>
<span class="token comment">//        int j = 0; // 当前p指向的是第几个结点，不带的话此处赋1</span>
<span class="token comment">//        p = L.head; // L指向头结点，头结点是第0个结点</span>
<span class="token comment">//        while (p != null &amp;&amp; j &lt; i - 1) { // 循环找到 i - 1 个结点</span>
<span class="token comment">//            p = p.next;</span>
<span class="token comment">//            j++;</span>
<span class="token comment">//        }</span>
        HNode p <span class="token operator">=</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// i值不合法</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 第i - 1个结点后面已无其他结点</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">//        HNode q = p.next; // 令q指向被删除的结点</span>
<span class="token comment">//        e = q.data; // 用e返回元素的值</span>
<span class="token comment">//        p.next = q.next; // 将q结点从链中断开</span>
<span class="token comment">//        return true; // 删除成功</span>

        <span class="token keyword">return</span> <span class="token function">DeleteNode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除指定结点p</span>
    <span class="token keyword">boolean</span> <span class="token function">DeleteNode</span><span class="token punctuation">(</span>HNode p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 令q指向p的后继结点</span>
        p<span class="token punctuation">.</span>data <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token comment">// 和后继结点交换数据域</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 将q结点从链中断开</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按位查找，返回第i个元素</span>
    HNode <span class="token function">GetElem</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HNode p<span class="token punctuation">;</span> <span class="token comment">// 指针p向前扫描到的结点</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前p指向的是第几个结点，不带的话此处赋1</span>
        p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span> <span class="token comment">// L指向头结点，头结点是第0个结点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 循环找到 i 个结点</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 按值查找</span>
    HNode <span class="token function">LocateElem</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">,</span> <span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        HNode p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">// 从第一个结点开始查找数据域为e的结点</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token comment">// 找到后返回该结点，否则返回null</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 求表的长度</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span>HLinkerList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        HNode p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表第"</span> <span class="token operator">+</span> len <span class="token operator">+</span> <span class="token string">"个数据:"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            len<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>此段代码非最优解，仅作练习使用</p> 
<h4><a id="233%09_2311"></a>2.3.3 双链表</h4> 
<p>下文中，s指代新结点，p指代当前结点，q指代下一个结点</p> 
<h5><a id="1__2315"></a>1. 双链表和单链表的概念</h5> 
<p>单链表：无法逆向检索，有时候不太方便</p> 
<p>双链表：可进可退，存储密度更低</p> 
<p>双链表整体和单链表差距不大，额外新增了一个指向上一个结点的处理</p> 
<h5><a id="2__2323"></a>2. 双链表的插入</h5> 
<p>思路：和单链表同理，额外增加了prior的处理</p> 
<p>① q挂到s身上</p> 
<p>② q的prior指向s</p> 
<p>③ s的prior指向p</p> 
<p>④ s挂到p身上</p> 
<p>如果q不存在，第二步需省略</p> 
<p><img src="https://images2.imgbox.com/25/66/TC9dx5dY_o.png" alt="image-20210326165204033"></p> 
<h5><a id="3__2339"></a>3. 双链表的删除</h5> 
<p>① q的下一个结点挂到p身上</p> 
<p>② q的下一个结点的prior指向p</p> 
<p><img src="https://images2.imgbox.com/84/30/pwMA8vYL_o.png" alt="image-20210326165214894"></p> 
<h5><a id="_2347"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 结点（双链表）
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HDNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token function">HDNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">HDNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 数据</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token comment">// 下一个结点</span>
    HDNode next<span class="token punctuation">;</span>
    <span class="token comment">// 上一个结点</span>
    HDNode prior<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 双链表
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HDLinkedList</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 链表的头结点</span>
    HDNode head <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token comment">// 初始化一个空链表</span>
    <span class="token keyword">boolean</span> <span class="token function">InitList</span><span class="token punctuation">(</span>HDLinkedList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        L<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HDNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配一个头结点,如果不带头结点此处直接赋空</span>
        L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>prior <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// 头结点的prior永远指向空</span>
        L<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment">// 头结点之后暂时没有结点</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在p结点之后插入s结点</span>
    <span class="token keyword">boolean</span> <span class="token function">InsertNextHDNode</span><span class="token punctuation">(</span>HDNode p<span class="token punctuation">,</span> HDNode s<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> s <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 非法参数</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果p后面有结点</span>
            p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        s<span class="token punctuation">.</span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除p结点的后继结点</span>
    <span class="token keyword">boolean</span> <span class="token function">DeleteNextNode</span><span class="token punctuation">(</span>HDNode p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        HDNode q <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 找到p的后继结点q</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// p没有后继</span>
        <span class="token punctuation">}</span>
        p<span class="token punctuation">.</span>next <span class="token operator">=</span> q<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// q结点不是最后一个结点</span>
            q<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 求表的长度</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span>HDLinkedList L<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        HDNode p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表第"</span> <span class="token operator">+</span> len <span class="token operator">+</span> <span class="token string">"个数据:"</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            len<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="_2435"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/e0/7a/4wB4aWwA_o.png" alt="image-20210326165233947"></p> 
<h4><a id="234%09_2439"></a>2.3.4 循环链表</h4> 
<h5><a id="1__2441"></a>1. 循环链表与普通链表的不同</h5> 
<p>循环链表的尾结点的指针指向头结点，而普通链表的尾结点指向空。</p> 
<p>通常我们无法获取之前的结点，除非拿到头结点，循环单链表可以通过遍历结点的方式从而拿到自己想要的结点。</p> 
<p>以前在增加/删除操作时，需要给最后一个结点判空，现在则不需要。</p> 
<h5><a id="2__2449"></a>2. 循环双链表</h5> 
<p>表头的prior指向表尾，表尾的next指向表头。</p> 
<h5><a id="_2453"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/49/73/PEXoN9Yf_o.png" alt="image-20210326165256412"></p> 
<h4><a id="235%09_2457"></a>2.3.5 静态链表</h4> 
<h5><a id="1__2459"></a>1. 什么是静态链表</h5> 
<p>单链表：各个结点在内存中随意散落。</p> 
<p>静态链表：分配一整片连续的内存空间，各个结点集中安置。</p> 
<p><img src="https://images2.imgbox.com/5f/59/IqQ2hUeA_o.png" alt="image-20210326165336687"></p> 
<h5><a id="2__2467"></a>2. 静态链表的概念</h5> 
<p>静态链表就是用数组的方式实现的链表。</p> 
<p><strong>容量固定不可变</strong></p> 
<p>本章内容不是很重要，了解其概念即可。</p> 
<h4><a id="236%09_2475"></a>2.3.6 顺序表和链表的比较</h4> 
<h5><a id="1__2477"></a>1. 线性结构</h5> 
<p>都属于线性结构</p> 
<h5><a id="2__2481"></a>2. 存储结构</h5> 
<table><thead><tr><th align="center"></th><th align="center"><strong>顺序表</strong></th><th align="center"><strong>单链表</strong></th></tr></thead><tbody><tr><td align="center"><strong>优点</strong></td><td align="center">随机存取，存储密度高</td><td align="center">不要求大片连续空间，改变容量方便</td></tr><tr><td align="center"><strong>缺点</strong></td><td align="center">要求大片连续空间，改变容量不方便</td><td align="center">不可随机存取，要耗费一定空间存放指针</td></tr></tbody></table> 
<h5><a id="3__2488"></a>3. 基本操作</h5> 
<table><thead><tr><th align="left">操作</th><th align="left">顺序表</th><th align="left">链表</th></tr></thead><tbody><tr><td align="left"><strong>创</strong></td><td align="left">需要分配大片连续空间。若分配空间过小，则之后不方便扩展；若分配空间过大，则浪费内存资源</td><td align="left">只需分配一个头结点（也可不分配），方便扩展</td></tr><tr><td align="left"><strong>销</strong></td><td align="left">长度赋0即可，本笔记采用java实现，因此无需考虑内存问题，如果使用c实现则需要通过free函数释放内存</td><td align="left">依次删除每个结点</td></tr><tr><td align="left"><strong>增，删</strong></td><td align="left">插入/删除元素都要将后续元素全部后移/前移 时间复杂度O(n),时间开销主要来自移动元素</td><td align="left">插入/删除元素只需修改指针即可 时间复杂度O(n),时间开销主要来自查找元素</td></tr><tr><td align="left"><strong>查</strong></td><td align="left">按位查找：O(1)</td><td align="left">按值查找：O(n)</td></tr></tbody></table> 
<h5><a id="4__2497"></a>4. 概念</h5> 
<p>表长无法预估，需要经常进行增/删操作，可使用链表</p> 
<p>表长可预估，需要经常进行查询操作，可使用顺序表</p> 
<h3><a id="_2503"></a>第三章</h3> 
<h4><a id="311%09_2505"></a>3.1.1 栈的基本概念</h4> 
<h5><a id="1_Stack_2507"></a>1. 栈（Stack）的概念</h5> 
<p>栈是<strong>只允许在一端进行插入或删除</strong>的线性表</p> 
<p>重要术语：栈顶，栈底，空栈</p> 
<p><img src="https://images2.imgbox.com/75/ae/1MBXv5yb_o.png" alt="image-20210326205646609"></p> 
<p>特点：后进先出（Last In First Out）LIFO</p> 
<h5><a id="2__2517"></a>2. 栈的基本操作</h5> 
<pre><code class="prism language-java"><span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化栈。构造一个空栈，分配内存空间。</span>
<span class="token function">DestroyStack</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 销毁栈。销毁并释放栈s所占用的内存空间。</span>

<span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进栈，若栈S未满，则将x加入使之成为新栈顶。</span>
<span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出栈，若栈S非空，则弹出栈顶元素，并用x返回。</span>

<span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读栈顶元素。若栈S非空，则用x返回栈顶元素。</span>

<span class="token comment">// 其他常用操作</span>
<span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断一个栈是否为空</span>
</code></pre> 
<h5><a id="_2532"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/f9/68/RondivFe_o.png" alt="image-20210326205510127"></p> 
<h4><a id="312%09_2536"></a>3.1.2 栈的顺序存储实现</h4> 
<h5><a id="_2538"></a>思路</h5> 
<p>给定一个静态数组，每次操作头或者尾即可</p> 
<p>指针用于操纵当前数据</p> 
<p><img src="https://images2.imgbox.com/4e/1d/qHvCheNQ_o.png" alt="image-20210326210119682"></p> 
<h5><a id="_2546"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 顺序存储实现栈
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HSqStack</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">final</span> <span class="token keyword">int</span> MAXSIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 定义栈中元素的最大个数</span>

    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 静态数组中放栈中元素</span>

    <span class="token keyword">int</span> top<span class="token punctuation">;</span> <span class="token comment">// 栈顶指针</span>

    <span class="token function">HSqStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 初始化栈</span>
    <span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 此处如果指向0，则预示已经有一个参数了，所以初始化指向-1</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断栈空</span>
    <span class="token keyword">boolean</span> <span class="token function">StackEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入栈</span>
    <span class="token keyword">boolean</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span> MAXSIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 栈满</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        top<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 指针上移一位</span>
        data<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 新元素入栈</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出栈</span>
    <span class="token keyword">boolean</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span>  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 空栈</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        x <span class="token operator">=</span> data<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 栈顶元素先出栈</span>
        top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 指针下移</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 读取栈顶元素</span>
    <span class="token keyword">int</span> <span class="token function">GetTop</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span>  <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 空栈</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        x <span class="token operator">=</span> data<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 读取栈顶元素</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_2606"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/7a/86/d6GTpjxk_o.png" alt="image-20210326205743322"></p> 
<h4><a id="313%09_2610"></a>3.1.3 栈的链式存储实现</h4> 
<p>用链表的方式实现栈几乎等同于单链表，此处直接套用单链表即可</p> 
<h4><a id="321%09_2614"></a>3.2.1 队列的基本概念</h4> 
<h5><a id="1__2616"></a>1. 什么是队列</h5> 
<p>栈（Stack）是只允许<strong>在一端进行插入或删除</strong>的线性表</p> 
<p>队列（Queue）是只允许<strong>在一端插入,在另一端删除</strong>的线性表</p> 
<p><img src="https://images2.imgbox.com/ec/d9/TxoQgmaf_o.png" alt="image-20210326210328613"></p> 
<p>队列的特点：先进先出 First In First Out (FIFO)</p> 
<h5><a id="2__2626"></a>2. 队列的基本操作</h5> 
<pre><code class="prism language-java"><span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化队列，构造一个空队列Q</span>
<span class="token function">DestroyQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 销毁队列，销毁并释放队列Q所占用的空间</span>

<span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 入队，若队列Q未满，将x加入，使之成为新的队尾</span>
<span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 出队，若队列Q非空，删除队头元素，并用x返回</span>

<span class="token function">GetHead</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读队头元素，对队列Q非空，则将队头元素赋值给x</span>
<span class="token function">QueueEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断队列是否为空</span>
</code></pre> 
<h5><a id="_2639"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/68/81/UPmDoUPP_o.png" alt="image-20210326210404480"></p> 
<h4><a id="322%09_2643"></a>3.2.2 队列的顺序实现</h4> 
<h5><a id="_2645"></a>要点</h5> 
<p>求队列一共有多少个元素的算法如下：</p> 
<pre><code class="prism language-java"><span class="token comment">// 尾指针 + 长度 - 头指针 % 长度</span>
<span class="token punctuation">(</span>rear <span class="token operator">+</span> MAX_SIZE <span class="token operator">-</span> front<span class="token punctuation">)</span> <span class="token operator">%</span> MAX_SIZE
</code></pre> 
<p>头尾指针均为长度以内任意一个数字，因此想要求差必须先加上最大长度</p> 
<p>尾指针和头指针位置可调换</p> 
<p>概念上不会大于长度，保证代码健全性加上模运算</p> 
<h5><a id="_2660"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 顺序队列
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HSqQueue</span><span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SqQueue</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span> <span class="token comment">// 静态数组存放元素</span>
        <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">// 队头指针和队尾指针</span>

        <span class="token keyword">public</span> <span class="token function">SqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> SqQueue Q<span class="token punctuation">;</span>

    <span class="token comment">// 初始化队列</span>
    <span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        Q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始时，队头队尾全部指向空</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">boolean</span> <span class="token function">queueEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">;</span> <span class="token comment">// 当队头队尾指向一样时，则意味队列为空</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入队</span>
    <span class="token keyword">boolean</span> <span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果队头的指针的下一位指向队尾，则表示队满</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE<span class="token punctuation">;</span> <span class="token comment">// 队尾指针+1取模，保证指针不会超过长度</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出队</span>
    <span class="token keyword">boolean</span> <span class="token function">deQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 队列为空</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE<span class="token punctuation">;</span> <span class="token comment">// 队尾指针+1取模，保证指针不会超过长度</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取队头元素</span>
    <span class="token keyword">int</span> <span class="token function">getHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 队列为空</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> Q<span class="token punctuation">.</span>data<span class="token punctuation">[</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 获取队列长度</span>
    <span class="token keyword">int</span> <span class="token function">queueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">+</span> Q<span class="token punctuation">.</span>MAX_SIZE <span class="token operator">-</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span> <span class="token operator">%</span> Q<span class="token punctuation">.</span>MAX_SIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码不完善，仅作练习使用</p> 
<h5><a id="_2730"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/d0/bc/LiZlrG4E_o.png" alt="image-20210326210438044"></p> 
<h4><a id="323%09_2734"></a>3.2.3 队列的链式实现</h4> 
<h5><a id="_2736"></a>概念</h5> 
<p>链式无需考虑内存</p> 
<h5><a id="_2740"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 链式队列
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HLinkQueue</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> data<span class="token punctuation">;</span>
        LinkNode next<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">LinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">LinkNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">LinkQueue</span><span class="token punctuation">{<!-- --></span>
        LinkNode front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> LinkQueue Q<span class="token punctuation">;</span>

    <span class="token comment">// 初始化队列</span>
    <span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 初始时，front,rear都指向头结点</span>
        Q<span class="token punctuation">.</span>front <span class="token operator">=</span> Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 不带头结点的话front和rear都要指向空</span>
        Q<span class="token punctuation">.</span>front<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> Q<span class="token punctuation">.</span>front <span class="token operator">==</span> Q<span class="token punctuation">.</span>rear<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入队</span>
    <span class="token keyword">boolean</span> <span class="token function">enQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        LinkNode s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment">// 如果不带头结点则front需要进行非空判断，为空则修改表头指针</span>
        Q<span class="token punctuation">.</span>rear<span class="token punctuation">.</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 新结点挂到rear身上</span>
        Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 修改表尾指针</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 出队</span>
    <span class="token keyword">boolean</span> <span class="token function">deQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 空队列</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        LinkNode p <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        Q<span class="token punctuation">.</span>front<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 修改头结点的next指针</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Q<span class="token punctuation">.</span>rear <span class="token operator">==</span> p<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果是最后一个结点</span>
            Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_2804"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/d7/ab/7fkki8m9_o.png" alt="image-20210326210514330"></p> 
<h4><a id="324%09_2808"></a>3.2.4 双端队列</h4> 
<h5><a id="_2810"></a>概念</h5> 
<p>栈：单端插入和删除的线性表</p> 
<p>队列：一端插入，另一端删除的线性表</p> 
<p>双端队列：两端插入，两端删除的线性表</p> 
<p>双端队列包含输入受限和输出受限两种情况，不同情况具有不同局限性，需根据情况选择</p> 
<h5><a id="_2820"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/99/a3/WigC8ohp_o.png" alt="image-20210326212039635"></p> 
<h4><a id="331%09_2824"></a>3.3.1 栈在括号匹配中的应用</h4> 
<p>示例：</p> 
<p>一组括号，求出它们能不能完成匹配</p> 
<p>思路：</p> 
<p>使用栈，将左括号压入，如果遇到右括号就压出，遇到无法匹配的括号或者匹配结束栈里还有值则匹配失败</p> 
<p><img src="https://images2.imgbox.com/8f/ea/hDCP0ala_o.png" alt="image-20210326212212977"></p> 
<h5><a id="_2836"></a>代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 给定一组括号，判断这组括号能否完成匹配
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Brancket</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> String bracketStr <span class="token operator">=</span> <span class="token string">"({}{})"</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">bracketCheck</span><span class="token punctuation">(</span>bracketStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">bracketCheck</span><span class="token punctuation">(</span>String bracketStr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>bracketStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 栈元素</span>
        <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 栈顶指针</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs <span class="token operator">=</span> bracketStr<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'['</span> <span class="token operator">||</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'{'</span> <span class="token operator">||</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 扫描到左括号，入栈</span>
                data<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 扫描到右括号且当前栈空,匹配失败</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">char</span> topElem <span class="token operator">=</span> data<span class="token punctuation">[</span>top<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 栈顶元素出栈</span>
                <span class="token comment">// 进行匹配，如果匹配失败则返回false</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> topElem <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> topElem <span class="token operator">!=</span> <span class="token string">'['</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'}'</span> <span class="token operator">&amp;&amp;</span> topElem <span class="token operator">!=</span> <span class="token string">'{'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> top <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 括号校验完成且栈空则匹配成功</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="332%09_2883"></a>3.3.2 栈在表达式求值中的应用（上）</h4> 
<h5><a id="_2885"></a>三种表达式的不同</h5> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sKR5VxaQ-1618913823563)(https://i.loli.net/2021/02/01/2GOCL9hukZWgNse.png)]</p> 
<p>中缀表达式</p> 
<p>运算符在中间，既为我们常用的数学表达式</p> 
<p>后缀表达式</p> 
<p>运算符在后面，又叫逆波兰表达式（Reverse Polish notation）</p> 
<p>前缀表达式</p> 
<p>运算符在前面，因为是波兰人提出，所以又叫波兰表达式（Polish notation）</p> 
<table><thead><tr><th align="center">中缀表达式</th><th align="center">后缀表达式</th><th align="center">前缀表达式</th></tr></thead><tbody><tr><td align="center">a + b</td><td align="center">ab +</td><td align="center">+ ab</td></tr><tr><td align="center">a + b - c</td><td align="center">a b + c -</td><td align="center">- + ab c</td></tr><tr><td align="center">a + b - c * d</td><td align="center">ab + cd * -</td><td align="center">- + ab * cd</td></tr></tbody></table> 
<p>核心思想还是一个计算区间一块区域，诸如(a + b) - (c * d) = （ab+）(cd*) -</p> 
<h5><a id="_2909"></a>中缀转后缀</h5> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RRhTgc8d-1618913823564)(https://i.loli.net/2021/02/01/t2GmHCKyBF59gvq.png)]</p> 
<p>左优先原则：只要左边的运算符能先计算，就先计算左边的</p> 
<h5><a id="_2915"></a>后缀表达式的手算方法</h5> 
<p>从左往右扫描，每遇到一个运算符，就让运算符前面<strong>最近的两个操作数</strong>执行对应操作，合并为一个操作数</p> 
<p><strong>对于计算机而言，后缀表达式的效率往往要更高</strong></p> 
<h5><a id="_2921"></a>中缀表达式转前缀表达式</h5> 
<p>右优先原则：只要右边的操作符能先计算，就优先计算右边的</p> 
<pre><code>中缀
A + B * (C - D) - E / F
常规计算
- + A * B - C D / E F
右优先
+ A - * B - C D / E F
</code></pre> 
<h5><a id="_2934"></a>后缀表达式的机算方法</h5> 
<p>① 从左到右扫描下一个元素，直到处理完所有元素</p> 
<p>② 若扫描到操作数则入栈</p> 
<p>③ 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果入栈</p> 
<h5><a id="_2942"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/41/64/XNchjDXD_o.png" alt="image-20210326212341082"></p> 
<h4><a id="332%09_2946"></a>3.3.2 栈在表达式求值中的应用（下）</h4> 
<h5><a id="_2948"></a>中缀转后缀</h5> 
<p>① 遇到操作数，直接加入后缀表达式</p> 
<p>② 遇到界限符。遇到 ( 直接入栈，遇到 ) 则依次弹出栈内运算符并加入后缀表达式，直到弹出 ( 为止。注意（ 不加后缀</p> 
<p>③ 遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 ( 或栈空则停止。之后再将当前运算符入栈。</p> 
<h5><a id="_2956"></a>中缀的计算</h5> 
<p>中缀转后缀 + 后缀求值</p> 
<p>① 初始化两个栈，操作数栈和运算符栈</p> 
<p>② 若扫描到操作数，压入操作数栈</p> 
<p>③ 若扫描到运算符或界限符，则按照‘中缀转后缀’相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要在弹出两个操作数栈的栈顶元素并执行相应运算，运算结果在压回操作数栈）</p> 
<h5><a id="_2966"></a>代码</h5> 
<p>因时间原因，此处仅列出中转后和后计算</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Pattern<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 后缀表达式
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PolishNotation</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 中缀表达式</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String notation <span class="token operator">=</span> <span class="token string">"((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1))"</span><span class="token punctuation">;</span>
    <span class="token comment">// 后缀表达式</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String poNotation <span class="token operator">=</span> <span class="token string">"15 7 1 1 + - / 3 * 2 1 1 + + -"</span><span class="token punctuation">;</span>
    <span class="token comment">// 前缀表达式</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> String rpoNotation <span class="token operator">=</span> <span class="token string">"- * / 15 - 7 + 1 1 3 + 2 + 1 1"</span><span class="token punctuation">;</span>
    <span class="token comment">// 10的倍数</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> exactNums <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中计算："</span> <span class="token operator">+</span> <span class="token function">countNum</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中转后："</span> <span class="token operator">+</span> <span class="token function">commTransRpo</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"后计算："</span> <span class="token operator">+</span> <span class="token function">poCount</span><span class="token punctuation">(</span>poNotation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 中缀转后缀
     */</span>
    <span class="token keyword">static</span> String <span class="token function">commTransRpo</span><span class="token punctuation">(</span>String notation<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Stack<span class="token generics function"><span class="token punctuation">&lt;</span>Character<span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> notation<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    j<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                i <span class="token operator">+=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">char</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">while</span><span class="token punctuation">(</span>pop <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pop <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">switch</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>
                        <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>
                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'('</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                    <span class="token keyword">char</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token keyword">if</span><span class="token punctuation">(</span>pop <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">!=</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pop <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token punctuation">}</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>
                        <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>
                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'-'</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                    <span class="token keyword">char</span> pop <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token keyword">if</span><span class="token punctuation">(</span>pop <span class="token operator">!=</span> <span class="token string">'('</span> <span class="token operator">&amp;&amp;</span> pop <span class="token operator">!=</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                                        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pop <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                    <span class="token punctuation">}</span>
                                <span class="token punctuation">}</span>
                            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 后缀计算
     */</span>
    <span class="token keyword">static</span> Integer <span class="token function">poCount</span><span class="token punctuation">(</span>String notation<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        Stack<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> notation<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> count <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token string">""</span> <span class="token operator">+</span> chars<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    j<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                i <span class="token operator">+=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">switch</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> <span class="token string">'-'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> <span class="token string">'*'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token keyword">case</span> <span class="token string">'/'</span><span class="token operator">:</span>
                        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        res <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 求和（中缀）
     */</span>
    <span class="token keyword">static</span> Integer <span class="token function">countNum</span><span class="token punctuation">(</span>String notation<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">poCount</span><span class="token punctuation">(</span><span class="token function">commTransRpo</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 判断一个字符是否为Integer
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isInteger</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"[0-9]*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="333%09_3120"></a>3.3.3 栈在递归中的应用</h4> 
<h5><a id="_3122"></a>什么问题适合用递归算法解决</h5> 
<p>可以把原始问题转换为<strong>属性相同，但规模较小</strong>的问题</p> 
<p><img src="https://images2.imgbox.com/0f/b1/IbQIemqv_o.png" alt="image-20210326212649394"></p> 
<h5><a id="_3128"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/63/f2/Mf1ZxoUk_o.png" alt="image-20210326212752974"></p> 
<h4><a id="334%09_3132"></a>3.3.4 队列的应用</h4> 
<h5><a id="_3134"></a>队列在操作系统中的应用</h5> 
<p>多个进程争抢着使用有限的系统资源时，<strong>FCFS</strong>(First Come First Service, <strong>先来先服务</strong>)是一种常用策略</p> 
<h4><a id="34__3138"></a>3.4 特殊矩阵的压缩存储</h4> 
<p><img src="https://images2.imgbox.com/2a/3b/DaVYRVzA_o.png" alt="image-20210326213308798"></p> 
<h5><a id="_3142"></a>一维数组存储结构</h5> 
<p>各数组元素大小相同，且物理上连续存放</p> 
<pre><code>LOC + i * sizeof(ElemType)
</code></pre> 
<p>除特殊说明，否则数组<strong>下标默认从0开始</strong></p> 
<h5><a id="_3152"></a>二维数组存储结构</h5> 
<pre><code>M行N列的二位数组b[M][N]中，若按行优先存储，则b[i][j]的存储地址
LOC + (i * N + j) * sizeof(elemeType)

M行N列的二位数组b[M][N]中，若按列优先存储，则b[i][j]的存储地址
LOC + (j * M + i) * sizeof(elemeType)
</code></pre> 
<p>思路：无论行列优先，从起始地址遍历到当前元素即可得到存储地址</p> 
<h5><a id="_3164"></a>对称矩阵</h5> 
<p>若n阶<strong>方阵</strong>中任意一个元素a i,j 都有 <strong>a i, j = a j, <strong>,则该矩阵称为</strong>对称矩阵</strong></p> 
<p><img src="https://images2.imgbox.com/ff/c1/ukvwtgRR_o.png" alt="image-20210326213545801"></p> 
<p>策略：只存储主对角线+下三角区</p> 
<p>使用一维数组存储，则取值为:<br> 行优先：先根据i值求出上面有几行，在根据j值求出在当前行的位置</p> 
<p>列优先：同上，将位置调换即可</p> 
<h5><a id="_3177"></a>三角矩阵</h5> 
<p>下三角矩阵：除了主对角线和下三角区，其余都相同</p> 
<p>上三角矩阵：除了主对角线和上三角区，其余都相同</p> 
<p><img src="https://images2.imgbox.com/02/8d/yzdr19nv_o.png" alt="image-20210326213643463"></p> 
<p>存储策略：将中线和三角区按照<strong>行优先</strong>存入，最后一个位置存放常量c</p> 
<h5><a id="_3187"></a>三对角矩阵</h5> 
<p>又称带状矩阵，既中线周围一圈都有值，其余皆为0</p> 
<p><img src="https://images2.imgbox.com/93/d2/xgschVO1_o.png" alt="image-20210326213719998"></p> 
<p>首行和尾行是两个，其余都是三个</p> 
<h5><a id="_3195"></a>稀疏矩阵</h5> 
<p>非零元素远远少于矩阵元素的个数，且<strong>无规则分布</strong></p> 
<p><strong>存储策略一：顺序存储</strong></p> 
<p>三元组 &lt;行，列，值&gt;</p> 
<p><strong>此处行列从1开始</strong></p> 
<p><img src="https://images2.imgbox.com/05/c6/rpnZ9O3n_o.png" alt="image-20210326213938697"></p> 
<p><strong>存储策略二：十字链表法</strong></p> 
<p><img src="https://images2.imgbox.com/9a/59/Qs0StqX8_o.png" alt="image-20210326214019017"></p> 
<p><img src="https://images2.imgbox.com/9c/81/HnhqLkb7_o.png" alt="image-20210326214037617"></p> 
<h5><a id="_3213"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/fa/33/nulVuPmc_o.png" alt="image-20210326214104251"></p> 
<h3><a id="_3217"></a>第四章</h3> 
<h4><a id="421%09_3219"></a>4.2.1 串的定义和基本操作</h4> 
<h5><a id="_3221"></a>串的定义</h5> 
<p>串，既字符串(String)是由零个或多个<strong>字符</strong>组成的有限序列。</p> 
<p>举例：</p> 
<p>S = “Hello World!”<br> T = ‘iPhone 1 Pro Max?’</p> 
<p>子串：串中任意个连续的字符组成的子序列 Eg : ‘iPhone’,'Pro M’是串的子串</p> 
<p>主串：包含子串的串。 Eg : T是子串’iPhone’的主串</p> 
<p>字符在主串中的位置:字符在串中的序号。 Eg:'1’在T中的位置是8</p> 
<p>子串在主串中的位置:子串的第一个字符在主串中的位置 Eg:'11 Pro’在T中的位置是8</p> 
<h5><a id="_3238"></a>操作</h5> 
<pre><code>StrAssign(T, chars); // 赋值操作。将chars的值赋给T
StrCopy(T, S); // 赋值操作。将串S复制给串T
StrEmpty(S); // 判空操作。若S为空串，则返回true，否则返回false
StrLength(S); // 求串长。返回串S的元素个数.
ClearString(S); // 清空操作。将S清为空串
DestoryString(S); // 销毁串。将串S销毁
Concat(T, S1, S2); // 串链接。由T返回由S1和S2连接而成的新串
SubString(Sub, S, pos, len); // 求子串。用Sub返回S中从pos开始到len的子串
Index(S, T); // 定位操作。若主串S中存在与T相同的子串，则返回一个字符的位置，否则返回0
StrCompare(S, T); // 比较操作。若S&gt;T，则返回值&gt;0，S&lt;T则返回值&lt;0,S=T则返回0
</code></pre> 
<h5><a id="_3253"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/cd/a6/2T1qvzqz_o.png" alt="image-20210326214135281"></p> 
<h4><a id="412%09_3257"></a>4.1.2 串的存储结构</h4> 
<h5><a id="_3259"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/60/c2/blbsgYOh_o.png" alt="image-20210326214215168"></p> 
<h4><a id="421%09_3263"></a>4.2.1 串的朴素模式匹配</h4> 
<h5><a id="_3265"></a>思路</h5> 
<p>在<strong>主串</strong>中找到<strong>模式串</strong>相同的<strong>子串</strong></p> 
<p>因该算法思路简单了然，故叫朴素模式匹配</p> 
<table><thead><tr><th align="center">最好时间复杂度</th><th align="center">O（m）</th></tr></thead><tbody><tr><td align="center">常规时间复杂度</td><td align="center">O（n）</td></tr><tr><td align="center">最坏时间复杂度</td><td align="center">O (nm)</td></tr></tbody></table> 
<h5><a id="_3276"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/6b/3a/gzipIaEN_o.png" alt="image-20210326214337675"></p> 
<h4><a id="422%09KMP_3280"></a>4.2.2 KMP算法（上）</h4> 
<h5><a id="KMP_3282"></a>什么是KMP算法</h5> 
<p>朴素模式匹配的优化</p> 
<p>由三个人提出，各取名字中一个字母，因此叫KMP算法</p> 
<h5><a id="_3288"></a>朴素模式匹配的缺点</h5> 
<p>当某些子串与模式串能部分匹配时，<strong>主串的扫描指针i经常回溯</strong>，导致时间开销增加</p> 
<h4><a id="423%09KMP_3292"></a>4.2.3 KMP算法（下）</h4> 
<p>学不会，等我学会了再来补充</p> 
<h4><a id="424%09KMP_3296"></a>4.2.4 KMP算法的进一步</h4> 
<p>同上</p> 
<h3><a id="_3300"></a>第五章</h3> 
<h4><a id="51%09_3302"></a>5.1 树的基本概念</h4> 
<p><img src="https://images2.imgbox.com/70/2d/SEvnFcwv_o.png" alt="image-20210326214542431"></p> 
<h5><a id="_3306"></a>什么是树</h5> 
<p>树是 n (n &gt;= 0) 个结点的有限集合，n = 0 时，称为空树。</p> 
<p>而任意非空树应该满足:</p> 
<p>1.有且仅有一个特定的称为<strong>根</strong>的结点。</p> 
<p>2.当 n &gt; 1时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根节点的<strong>子树</strong>。</p> 
<h5><a id="_3316"></a>基本术语</h5> 
<ol><li>节点的度：一个节点含有的子树的个数称为该节点的<strong>度</strong>；</li><li>树的度：一棵树中，<strong>最大的节点</strong>度称为树的度；</li><li>叶节点或终端节点：度为零的节点；</li><li>非终端节点或分支节点：度不为零的节点；</li><li>父亲节点：若一个节点<strong>含有子节点</strong>，则这个节点称为其子节点的<strong>父节点</strong>；</li><li>孩子节点：一个节点<strong>含有的子树的根节点</strong>称为该节点的<strong>子节点</strong>；</li><li>兄弟节点：具有<strong>相同父节点</strong>的节点互称为<strong>兄弟节点</strong>；</li><li>层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li><li>深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li><li>高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li><li>堂兄弟节点：父节点在<strong>同一层的节点</strong>互为堂兄弟；</li><li>节点的祖先：从根到该节点所经分支上的所有节点；</li><li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li><li>森林：由m（m&gt;=0）棵互不相交的树的集合称为<strong>森林</strong>。</li></ol> 
<p><strong>树的种类</strong></p> 
<ul><li>无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</li><li>有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；</li><li>二叉树：每个节点最多含有两个子树的树称为二叉树；</li><li>完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</li><li>满二叉树：所有叶节点都在最底层的完全二叉树；</li><li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li><li>排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；</li><li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li><li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li></ul> 
<h4><a id="521%09_3345"></a>5.2.1 二叉树的概念</h4> 
<h5><a id="_3347"></a>什么是二叉树</h5> 
<p>二叉树是n（n&gt;=0）个结点的有限集合。</p> 
<ol><li>n = 0 时，二叉树为空；</li><li>n &gt; 0 时，由根节点和两个互不相交的左右子树组成。左右子树也分别是一颗二叉树。</li></ol> 
<h5><a id="2_3354"></a>二叉树与度为2的有序树的区别</h5> 
<table><thead><tr><th align="center">二叉树</th><th align="center">度为2的有序树</th></tr></thead><tbody><tr><td align="center">可以为空</td><td align="center">至少有三个结点</td></tr><tr><td align="center">子结点始终有左右之分</td><td align="center">子结点次序相对</td></tr></tbody></table> 
<h5><a id="_3361"></a>满二叉树</h5> 
<p>一颗高度为h，且含有2h - 1个结点的二叉树称为满二叉树</p> 
<h5><a id="_3365"></a>完全二叉树</h5> 
<p>相对于满二叉树，完全二叉树最后一层可以缺少结点或叶子</p> 
<h5><a id="_3369"></a>二叉排序树</h5> 
<p>对任意结点而言，左子树关键字均小于该结点，右子树关键字均大于该结点</p> 
<h5><a id="_3373"></a>平衡二叉树</h5> 
<p>树上<strong>任意结点</strong>的左右子树的深度之差不超过1</p> 
<h5><a id="_3377"></a>二叉树的性质</h5> 
<ol><li> <p>非空二叉树的叶子结点数等于度为2的结点数 + 1</p> </li><li> <p>非空二叉树第k层至多有2的k - 1 次幂个结点（K &gt;= 1）</p> <p>第一层 1 个结点，二层 2 * 1 = 2个结点，三层 2 * 2 = 4个结点，以此类推</p> </li><li> <p>高度为h的二叉树至多有2的h次方 - 1 个结点（K &gt;= 1）</p> <p>由上一条可得此条结论</p> </li></ol> 
<h4><a id="522%09_3389"></a>5.2.2 二叉树的存储结构</h4> 
<h5><a id="_3391"></a>顺序存储</h5> 
<p>用一组连续的存储单元依次自上而下，自左至右存储完全二叉树的结点元素</p> 
<h5><a id="_3395"></a>链式存储</h5> 
<p>用链表来存放二叉树，二叉树中每个结点用链表的一个链结点来存储。</p> 
<p>链式存储需要一个数据域和一个指针域，指针域存放两个指针，一个指向左几点，一个指向右节点</p> 
<h4><a id="531%09_3401"></a>5.3.1 二叉树的遍历</h4> 
<h5><a id="_3403"></a>并查集</h5> 
<p>一种简单的集合表示。</p> 
<p>通常用树的<strong>双亲表示法</strong>作为并查集的存储结构</p> 
<p>通常用数组元素的下标代表元素名，用根节点的下标代表子集合名，根节点的双亲结点为负数。</p> 
<pre><code>Initial(S)	// 将集合S中的每个元素都初始化为只有一个单元素的子集合
Union(S, Root1, Root2) // 把集合S中的子集合（互不相交）Root2并入子集合Root1
Find(S, x) // 查找集合S中单元素x所在子集合，并返回该子集合的名字
</code></pre> 
<h5><a id="_3417"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/75/71/Ty1AFLwK_o.png" alt="image-20210326214853622"></p> 
<h4><a id="532%09_3421"></a>5.3.2 线索二叉树</h4> 
<h5><a id="_3423"></a>线索二叉树的概念</h5> 
<p><img src="https://images2.imgbox.com/6e/bb/AXmhxry0_o.png" alt="image-20210326215111226"></p> 
<h5><a id="_3427"></a>线索化</h5> 
<p>若无左子树，则将左指针指向其前驱结点</p> 
<p>若无右子树，则将右指针指向其后驱结点</p> 
<h5><a id="_3433"></a>优点</h5> 
<p>将原本的空指针都替换为前驱和后驱，可以加快结点的查询</p> 
<h4><a id="541%09_3437"></a>5.4.1 树的存储结构</h4> 
<h5><a id="_3439"></a>双亲表示法</h5> 
<p>采用一组连续的存储空间来存储每个结点，同时每个结点中增设一个伪指针，指向双亲结点在数组中的位置。根节点的下标为0，其伪指针域为-1。</p> 
<p>多一个指针，指向父节点，没爹则给-1。</p> 
<h5><a id="_3445"></a>孩子表示法</h5> 
<p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表。</p> 
<p>每个结点的所有子结点就是一个单链表。</p> 
<h5><a id="_3451"></a>孩子兄弟表示法</h5> 
<p>以二叉链表作为树的存储结构，又称二叉树表示法。</p> 
<p>左指针指向第一个孩子，右子针指向下一个兄弟。</p> 
<p><img src="https://images2.imgbox.com/a4/b8/bshPnGS2_o.png" alt="image-20210326215259198"></p> 
<h5><a id="_3459"></a>优缺点对比</h5> 
<table><thead><tr><th align="center"></th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">双亲表示法</td><td align="center">寻找双亲效率高</td><td align="center">寻找孩子效率低</td></tr><tr><td align="center">孩子表示法</td><td align="center">寻找孩子效率高</td><td align="center">寻找双亲效率低</td></tr><tr><td align="center">孩子兄弟表示法</td><td align="center">寻找孩子效率高 方便树转换为二叉树</td><td align="center">寻找双亲效率低</td></tr></tbody></table> 
<h4><a id="542543%09_3467"></a>5.4.2~5.4.3 树和森林</h4> 
<h5><a id="_3469"></a>树与二叉树的转换</h5> 
<p>可用上一章的左孩子右兄弟的办法进行转换。</p> 
<h5><a id="_3473"></a>森林与二叉树的转换</h5> 
<p>先转为二叉树，在将每棵二叉树的根依次作为上一棵二叉树的右子树。</p> 
<h5><a id="_3477"></a>树的遍历</h5> 
<p>按照某种方式访问树中的每个结点，且仅访问一次</p> 
<h5><a id="_3481"></a>先根遍历</h5> 
<p>先访问根结点，在按照从左到右的顺序遍历根节点的子树</p> 
<p><strong>树的先根遍历与这棵树对应二叉树的先序遍历相同</strong></p> 
<h5><a id="_3487"></a>后根遍历</h5> 
<p>先按照从左到右的顺序遍历根节点的子树，在访问根结点</p> 
<p><strong>树的后根遍历与这棵树对应二叉树的中序遍历相同</strong></p> 
<h5><a id="_3493"></a>举例</h5> 
<p><img src="https://images2.imgbox.com/1b/5d/IZ3GpP1D_o.png" alt="image-20210326215359802"></p> 
<p>先根遍历：RADEBCFGHK</p> 
<p>后根遍历：DEABGHKFCR</p> 
<h5><a id="_3501"></a>森林的遍历</h5> 
<h5><a id="_3503"></a>先序遍历</h5> 
<ol><li>访问第一棵树的根结点</li><li>先序遍历第一棵树的子树森林</li><li>先序遍历除去第一棵树之后剩余的树构成的子树森林</li></ol> 
<h5><a id="_3509"></a>中序遍历</h5> 
<ol><li>中序遍历第一棵树的根结点的子树森林</li><li>访问第一棵树的根结点</li><li>中序遍历除去第一棵树之后剩余的树构成的子树森林</li></ol> 
<h4><a id="544%09_3515"></a>5.4.4 树的应用并查集</h4> 
<h5><a id="_3517"></a>什么是并查集</h5> 
<p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p> 
<ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul> 
<h6><a id="_3524"></a>实现代码</h6> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 并查集
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fa<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 初始化
     */</span>
    <span class="token keyword">void</span> <span class="token function">initial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 查询
     */</span>
    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> x <span class="token operator">==</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> <span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 合并
     */</span>
    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        fa<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_3562"></a>按秩合并</h5> 
<p>合并时，优先将简单的树往复杂的树上面合，从而达到最小程度影响深度</p> 
<h6><a id="_3566"></a>实现思路</h6> 
<p>重新给定一个数组rank[]记录每个树的深度，开始所有rank设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p> 
<p>注意：按秩合并会带来额外的<strong>空间复杂度</strong></p> 
<p>此概念为优化，此处暂不做深究</p> 
<h5><a id="_3574"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/93647900/" rel="nofollow">算法学习笔记(1):并查集 - 知乎</a></p> 
<h4><a id="551%09_3578"></a>5.5.1 二叉排序树</h4> 
<h5><a id="_3580"></a>什么是二叉排序树</h5> 
<p>二叉排序树(Binary Sort Tree),也称二叉查找树</p> 
<ol><li>左子树所有节点均<strong>小于</strong>根节点</li><li>右子树所有节点均<strong>大于</strong>根节点</li><li>左右子树也是二叉排序树</li></ol> 
<h5><a id="_3588"></a>插入</h5> 
<p>若二叉排序树为空，则直接插入</p> 
<p>若二叉排序树非空，当值小于根节点时插入左子树，当值大于根节点时插入右子树，当值等于根节点则不插入</p> 
<h5><a id="_3594"></a>构造二叉排序树</h5> 
<p>读入元素并建立节点，若二叉树为空则将其作为根节点</p> 
<p>若二叉排序树非空，当值小于根节点时插入左子树，当值大于根节点时插入右子树，当值等于根节点则不插入</p> 
<p>思路和插入一样</p> 
<h5><a id="_3602"></a>删除</h5> 
<ol><li>若被删除节点是叶节点，则直接删除</li><li>若被删除节点z只有一棵子树，则让z的子树指向z的父节点，代替z节点</li><li>若被删除节点z有两颗子树，则让z的右子树最小的节点替换z</li></ol> 
<h4><a id="552%09_3608"></a>5.5.2 平衡二叉树</h4> 
<h5><a id="_3610"></a>什么是平衡二叉树</h5> 
<p>平衡二叉树(AVL)，每个节点的左子树和右子树的高度差最多为1</p> 
<p>AVL是取自作者名</p> 
<h5><a id="_3616"></a>平衡二叉树的判断</h5> 
<ol><li>判断左子树是一颗平衡二叉树</li><li>判断右子树是一颗平衡二叉树</li><li>判断该节点为根的二叉树为平衡二叉树</li></ol> 
<h5><a id="_3622"></a>平衡树的旋转</h5> 
<h5><a id="LL_3624"></a>LL平衡旋转(右旋转)</h5> 
<p>在结点A的左孩子的左子树上插入新节点</p> 
<p>将A的左孩子B代替A，将A节点称为B的右子树根节点，而B的原右子树则作为A的左子树</p> 
<p><img src="https://images2.imgbox.com/d8/a0/EQwQ3kZ6_o.png" alt="image-20210326220051604"></p> 
<p><img src="https://images2.imgbox.com/b2/25/ZrvEMLHQ_o.png" alt="image-20210326220221152"></p> 
<h5><a id="RR_3634"></a>RR平衡旋转(左旋转)</h5> 
<p>在结点A的右孩子的右子树上插入新节点</p> 
<p>将A的右孩子B代替A，将A节点称为B的左子树根节点，而B的原左子树则作为A的右子树</p> 
<p><img src="https://images2.imgbox.com/43/05/5LUEz7yH_o.png" alt="image-20210326220241687"></p> 
<p><img src="https://images2.imgbox.com/a4/64/HVta0fGv_o.png" alt="image-20210326220502554"></p> 
<p>可以对比红黑树的旋转，此处逻辑基本相同</p> 
<h4><a id="553%09_3646"></a>5.5.3 哈夫曼树</h4> 
<h5><a id="_3648"></a>带权路径长度</h5> 
<p>路径长度 路径上所经历<strong>边</strong>的个数</p> 
<p>结点的权 结点被赋予的数值</p> 
<p>树的<strong>带权路径长度 WPL</strong>，树中所有<strong>叶结点</strong>的带权路径长度之和</p> 
<p><img src="https://images2.imgbox.com/56/74/oVmAwHPB_o.png" alt="image-20210326220725139"></p> 
<h5><a id="_3658"></a>什么是哈夫曼树</h5> 
<p>哈夫曼树也称最优二叉树，含有n个<strong>带权叶子结点带权路径长度最小</strong>的二叉树</p> 
<h5><a id="_3662"></a>哈夫曼树的构造算法</h5> 
<ol><li>将n个结点作为n棵仅含有一个根节点的二叉树，构成森林F</li><li>生成一个新节点，从F中找出根节点权值最小的两棵树作为它的左右子树，新节点的权值为两颗子树的权值之和</li><li>从F中删除这两个数，并将新生成的树加入F</li><li>重复2，3步骤，直到F中只有一棵树为止</li></ol> 
<h5><a id="_3669"></a>哈夫曼树的性质</h5> 
<ol><li>每个初始结点都会成为叶节点，双支结点都为新生成的结点</li><li>权值越大离根结点越进，反之则越远</li><li>哈夫曼树中没有结点为度的1（要么没有子结点，要么两个子结点）</li><li>n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1</li></ol> 
<h5><a id="_3676"></a>参考内容</h5> 
<p><a href="https://baijiahao.baidu.com/s?id=1663514710675419737&amp;wfr=spider&amp;for=pc" rel="nofollow">什么是哈夫曼树？ - CSDN</a></p> 
<h3><a id="_3680"></a>第六章</h3> 
<h4><a id="611%09_3682"></a>6.1.1 图的基本概念</h4> 
<h5><a id="_3684"></a>大概念</h5> 
<p><img src="https://images2.imgbox.com/83/35/I7XDkDkA_o.png" alt="image-20210326220906943"></p> 
<table><thead><tr><th align="center">线性表</th><th align="center">一对一</th></tr></thead><tbody><tr><td align="center">树</td><td align="center">一对多</td></tr><tr><td align="center">图</td><td align="center">多对多</td></tr></tbody></table> 
<h5><a id="_3693"></a>什么是图</h5> 
<p>图(Graph)是一种复杂的非线性结构，每个数据之间可任意关联。正是因为任意关联性，导致了图的复杂性。</p> 
<h6><a id="_3697"></a>图的结构</h6> 
<p>顶点(Vertex): 图中的数据元素</p> 
<p>边(Edge): 图中连接顶点的线</p> 
<h5><a id="_3703"></a>无向图</h5> 
<p>一个图所有的边都没有方向，称为无向图</p> 
<p>无序边(v, w) = (w, v)</p> 
<h5><a id="_3709"></a>有向图</h5> 
<p>一个图边有方向性，称为有向图</p> 
<p>有序对&lt;v, w&gt;</p> 
<p><strong>权</strong>：图的边往往需要表示成为某种数值，这个数值便是该边的权。</p> 
<p>除去上面两种还有多种其他概念的图，此处不做深究</p> 
<pre><code class="prism language-java">Graph <span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 建立并返回空图</span>
Graph <span class="token function">InsertVertex</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将V插入G</span>
Graph <span class="token function">InsertEdge</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Edge e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将e插入G</span>
<span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从V出发深度优先遍历G</span>
<span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从V出发广度优先遍历G</span>
<span class="token keyword">void</span> <span class="token function">ShortestPath</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">,</span> <span class="token keyword">int</span> Dist<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算图G中顶点V到任意其他顶点的最短距离</span>
<span class="token keyword">void</span> <span class="token function">MST</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算图G的最小生成树</span>
</code></pre> 
<h5><a id="_3729"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/82057291">图的java实现 - CSDN</a></p> 
<p><a href="https://blog.csdn.net/hehuanchun0311/article/details/80168109">数据结构 – 图 - CSDN</a></p> 
<h4><a id="621%09_3735"></a>6.2.1 邻接矩阵法</h4> 
<h5><a id="_3737"></a>什么是邻接矩阵</h5> 
<p>给定两个数组，一个一维数组存储顶点信息，一个二维数组存储图中的边的信息</p> 
<p>无相图的邻接矩阵是一个对称矩阵</p> 
<p><img src="https://images2.imgbox.com/05/b0/jLAAuDzZ_o.png" alt="image-20210326221134089"></p> 
<h5><a id="_3745"></a>邻接矩阵的优点</h5> 
<ol><li>直观，便于理解</li><li>方面检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有邻接点（有边直接相连的顶点）</li><li>方便计算任一顶点的度（从该点出发的边数为出度，指向该点的边数为入度）</li></ol> 
<ul><li>无向图：对应行列非0元素的个数</li><li>有向图：对应行非0元素的个数是出度，对应列非0元素的个数是入度</li></ul> 
<h5><a id="_3755"></a>邻接矩阵的缺点</h5> 
<ol><li> <p>浪费空间 存稀疏图（点多边少）含有大量无效元素</p> <p>但对于稠密特别是完全图很划算</p> </li><li> <p>浪费时间 统计稀疏图一共又多少边</p> </li></ol> 
<h5><a id="_3763"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/jnu_simba/article/details/8866705">图的存储结构之邻接矩阵 - CSDN</a></p> 
<h4><a id="622%09_3767"></a>6.2.2 邻接表法</h4> 
<h5><a id="_3769"></a>什么是邻接表</h5> 
<p>为了解决邻接矩阵的缺点，邻接表应运而生</p> 
<p>为每一个顶点建立一个单链表存放与他相领的边</p> 
<p><strong>顶点表</strong></p> 
<p>采用<strong>顺序存储</strong>，存放顶点的数据和边表的头指针</p> 
<p><strong>边表（出边表）</strong></p> 
<p>采用<strong>链式存储</strong>，单链表中存放与一个顶点相邻的所有边，一个链表表示一条从该顶点到链表结点顶点的边</p> 
<p><img src="https://images2.imgbox.com/95/c7/ynAXEc9V_o.png" alt="image-20210326221316303"></p> 
<h5><a id="_3785"></a>邻接表的特点</h5> 
<ol><li>更适用于稀疏图</li><li>无向图：结点的度为该结点边表的长度</li><li>有向图：结点的出度为结点边表的长度，入度要遍历整个邻接表</li><li>邻接表不唯一，边表结点的顺序根据算法和输入的不同可能会不同</li></ol> 
<h5><a id="_3792"></a>邻接矩阵和邻接表的比较</h5> 
<table><thead><tr><th align="center"></th><th align="center">邻接矩阵</th><th align="center">邻接表</th></tr></thead><tbody><tr><td align="center">适用性</td><td align="center">稠密图</td><td align="center">稀疏图</td></tr><tr><td align="center">存储方式</td><td align="center">顺序</td><td align="center">顺序+链式</td></tr><tr><td align="center">判断两顶点间是否存在边</td><td align="center">高效</td><td align="center">低效</td></tr><tr><td align="center">找到某顶点相邻的边</td><td align="center">低效</td><td align="center">高效</td></tr></tbody></table> 
<p>上表中最后一条存疑，邻接矩阵是找到该点然后遍历该行列，邻接表是遍历链表，此处效率应无异</p> 
<h4><a id="623%09_3803"></a>6.2.3 十字链表</h4> 
<h5><a id="_3805"></a>什么是十字链表</h5> 
<p><strong>有向图</strong>的一种链式存储结构</p> 
<p><strong>十字链表等于邻接表加逆邻接表</strong></p> 
<p><img src="https://images2.imgbox.com/1f/31/5MkAJdSH_o.png" alt="image-20210326221433931"></p> 
<h4><a id="624%09_3813"></a>6.2.4 邻接多重表</h4> 
<p><strong>无向图</strong>的一种链式存储结构</p> 
<p><img src="https://images2.imgbox.com/04/67/svpkU5zd_o.png" alt="image-20210326221518878"></p> 
<ul><li>mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；</li><li>ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</li><li>ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；</li><li>jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；</li><li>info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；</li></ul> 
<p>vex代表边的前后结点，link代表与其关联的另一条边</p> 
<p>十字链表和邻接多重表概念较为复杂，需多多理解</p> 
<p>十字链表和邻接多重表可通过一条边去查找任意另一条边，此处可见图的优点与复杂</p> 
<h4><a id="625%09_3837"></a>6.2.5 图的基本操作</h4> 
<pre><code class="prism language-java"><span class="token function">Adjacent</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断图是否存在边&lt;x,y&gt;或(x,y)</span>
<span class="token function">Neighbors</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 列出图G中与结点x邻接的边</span>
<span class="token function">InsertVertex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在图G中插入顶点x</span>
<span class="token function">DeleteVerex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在图G中删除顶点x</span>
<span class="token function">AddEdge</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 若边(x,y)或&lt;x,y&gt;不存在，则向图G中添加该边</span>
<span class="token function">RemoveEdge</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 若边(x,y)或&lt;x,y&gt;存在，则向图G中删除该边</span>
<span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求图G中顶点x的第一个邻接点</span>
<span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 若图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点，若y是x的最后一个邻接点则返回-1</span>
<span class="token function">Get_edge_value</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取图G中边(x,y)或&lt;x,y&gt;对应的权值v</span>
<span class="token function">Set_edge_value</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置图G中边(x,y)或&lt;x,y&gt;对应的权值v</span>
</code></pre> 
<h4><a id="631%09_3852"></a>6.3.1 广度优先搜索</h4> 
<p>广度优先搜索(Breadth First Search), BFS</p> 
<p><img src="https://images2.imgbox.com/8e/cb/iNHyYvdK_o.png" alt="image-20210326221822542"></p> 
<p>如上图，入队出队顺序参考数组</p> 
<h5><a id="_3860"></a>伪码</h5> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Vertex V<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    visited<span class="token punctuation">[</span>V<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">Enqueue</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        V <span class="token operator">=</span> <span class="token function">Dequeue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>V 的每个邻接点 W<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>W<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                visited<span class="token punctuation">[</span>W<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token function">Enqueue</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>若有N个顶点，E条边，时间复杂度是</p> 
<ul><li>用邻接表存储图，为O(N+E)</li><li>用邻接矩阵存储图，为[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HPpI7ZHF-1618913823582)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]</li></ul> 
<p>每走一步，都要把周围一圈看一下(队列)</p> 
<h4><a id="632%09_3885"></a>6.3.2 深度优先搜索</h4> 
<p>深度优先搜索(depth First Search), DFS</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Vertex V<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    visited<span class="token punctuation">[</span>V<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>V 的每个邻接点 w<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>W<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">DFS</span><span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>若有N个顶点，E条边，时间复杂度是</p> 
<ul><li>用邻接表存储图，为O(N+E)</li><li>用邻接矩阵存储图，为[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Zxe2hQaI-1618913823583)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]</li></ul> 
<p>一直走到死胡同，然后回到上个路口换个方向接着走(递归+回溯)</p> 
<p>BFS和DFS复杂度大体一致，BFS适合大范围查找，DFS适合目标明确</p> 
<h5><a id="_3911"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/24986203" rel="nofollow">搜索思想——DFS &amp; BFS（基础篇）- 知乎</a></p> 
<h4><a id="641%09_3915"></a>6.4.1 最小生成树</h4> 
<h5><a id="_3917"></a>什么是最小生成树</h5> 
<p>对于<strong>带权无向连通图G</strong> = （V, E）,G的所有生成树当中边的权值之和最小的生成树为G的最小生成树(MST)。</p> 
<p><strong>边和权值同时最小</strong></p> 
<p><img src="https://images2.imgbox.com/ae/be/NziBSTUE_o.png" alt="image-20210326222110189"></p> 
<h5><a id="Prim_3925"></a>Prim算法</h5> 
<p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖所有顶点</p> 
<p><img src="https://images2.imgbox.com/79/14/tWgCVMKB_o.png" alt="image-20210326222715626"></p> 
<ol><li>图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</li><li>在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</li><li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li></ol> 
<p>时间复杂度为O(V平方），适合稠密图</p> 
<h5><a id="Kruskal_3937"></a>Kruskal算法</h5> 
<p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里面</p> 
<p><img src="https://images2.imgbox.com/e3/09/n6nRhlBs_o.png" alt="image-20210326222857242"></p> 
<ol><li>把图中的所有边按代价从小到大排序；</li><li>把图中的n个顶点看成独立的n棵树组成的森林；</li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol> 
<p>时间复杂度为O(ElogE)，适合稀疏图</p> 
<h5><a id="_3950"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/a2392008643/article/details/81781766">最小生成树的两种方法（Kruskal算法和Prim算法）- CSDN</a></p> 
<h4><a id="642%09_3954"></a>6.4.2 最短路径</h4> 
<h5><a id="_3956"></a>最短路径</h5> 
<p>两个顶点之间带权路径长度最短的路径为最短路径</p> 
<h5><a id="Dijkstra_3960"></a>迪杰斯特拉（Dijkstra）算法</h5> 
<p>迪杰斯特拉算法用于解决单源最短路径</p> 
<h5><a id="_3964"></a>什么是迪杰斯特拉算法</h5> 
<p>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径</p> 
<p>核心思路还是贪心算法，仙人指路：[贪心算法](# 9.2 贪心算法)</p> 
<h5><a id="_3970"></a>实现思路</h5> 
<ol><li>通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</li><li>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</li><li>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</li></ol> 
<p><img src="https://images2.imgbox.com/d2/c3/AiEzvVI7_o.png" alt="image-20210326222941265"></p> 
<p>时间复杂度为O(V的平方)</p> 
<p>当出现负权边会影响该算法的判断，比如上图1到2的权改为-3那么0到2的最短就会变更为0 -&gt; 1 -&gt; 2,因此<strong>迪杰斯特拉算法不适用含有负权边的图</strong></p> 
<hr> 
<h5><a id="Floyd_3984"></a>弗洛伊德（Floyd）算法</h5> 
<p>佛洛依德算法用于解决多源路径</p> 
<h5><a id="_3988"></a>什么是弗洛伊德算法</h5> 
<p>最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转…允许经过1~n号所有顶点进行中转，来<strong>不断动态更新任意两点之间的最短路程</strong>。即求从i号顶点到j号顶点只经过前k号点的最短路程。</p> 
<h5><a id="_3992"></a>实现思路</h5> 
<p>**1，**首先构建邻接矩阵Floyd[n+1] [n+1]，假如现在只允许经过1号结点，求任意两点间的最短路程，很显然Floyd[i] [j] = min{Floyd[i] [j], Floyd[i] [1]+Floyd[1] [j]}，代码如下：</p> 
<p>**2，**接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短距离，在已经实现了从i号顶点到j号顶点只经过前1号点的最短路程的前提下，现在再插入第2号结点，来看看能不能更新更短路径，故只需在步骤1求得的Floyd[n+1] [n+1]基础上，进行Floyd[i] [j] = min{Floyd[i] [j], Floyd[i] [2]+Floyd[2] [j]}；…<br> **3，**很显然，需要n次这样的更新，表示依次插入了1号，2号…n号结点，最后求得的Floyd[n+1] [n+1]是从i号顶点到j号顶点只经过前n号点的最短路程。</p> 
<p><img src="https://images2.imgbox.com/b2/1c/wGsMBSmF_o.png" alt="image-20210326223020271"></p> 
<h5><a id="_4001"></a>特点</h5> 
<p>Floyd算法适用于APSP(AllPairsShortestPaths)，是一种<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=83500148&amp;ss_c=ssc.citiao.link" rel="nofollow">动态规划算法</a>，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行|V|次<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=453851&amp;ss_c=ssc.citiao.link" rel="nofollow">Dijkstra算法</a>。</p> 
<p>优点：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单</p> 
<p>缺点：时间复杂度高，不适合计算大量数据</p> 
<h5><a id="_4009"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/40338107" rel="nofollow">通俗易懂理解——dijkstra算法求最短路径 - 知乎</a></p> 
<p><a href="https://blog.csdn.net/ytuyzh/article/details/88617987">最短路径模板+解析——（FLoyd算法） - CSDN</a></p> 
<p><a href="https://blog.csdn.net/qibofang/article/details/51594673">图论（二）：图的四种最短路径算法 - CSDN</a></p> 
<h4><a id="643%09_4017"></a>6.4.3 拓扑排序</h4> 
<h5><a id="_4019"></a>什么是拓扑排序</h5> 
<p><strong>有向无环图</strong> 不存在环的图，简称DAG图</p> 
<p><strong>AOV网</strong> 若用一个DAG图表示一个工程，其顶点表示活动，用有向边&lt;v1, vj&gt;表示活动vi先于活动vj进行的传递关系，则将这种DAG称为<strong>顶点表示活动网络</strong>，简称AOV网</p> 
<p><strong>拓扑排序</strong> 对DAG所有顶点的一种排序，使若存在一条从顶点A到顶点B的路径，在排序中B排在A的后面</p> 
<h5><a id="_4027"></a>举例</h5> 
<p><img src="https://images2.imgbox.com/97/ba/EJtfA9f3_o.png" alt="image-20210326223244292"></p> 
<p>如图，我想学习boot，那么前面都要学，我想学jsp，那么java要学，<strong>无关联的可任意序列排序，有关联的按照顺序走</strong></p> 
<h5><a id="_4033"></a>思路</h5> 
<ol><li>从DAG图中选择一个没有前驱的顶点并输出</li><li>从图中删除该顶点和以它为起点的边</li><li>重复1，2，直到DAG图为空或当前图中不存在无前驱的顶点为止。后者则说明图中有环。</li></ol> 
<h5><a id="_4039"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/bigsai/p/11489260.html" rel="nofollow">拓扑排序详解与实现 - 博客园</a></p> 
<h4><a id="644%09_4043"></a>6.4.4 关键路径</h4> 
<h5><a id="AOE_4045"></a>AOE网</h5> 
<p>在有向带权图中，以顶点表示事件，以有向边表示活动，以边上权值表示完成该活动的开销，则称这种有向图为<strong>用边表示活动的网络</strong>，简称AOE网</p> 
<p><img src="https://images2.imgbox.com/a3/5e/QGY2qyGQ_o.png" alt="image-20210326223508781"></p> 
<h5><a id="_4051"></a>关键路径</h5> 
<p>从原点到汇点最大路径长度的路径称为<strong>关键路径</strong>，关键路径的活动为<strong>关键活动</strong></p> 
<p><strong>事件的最早发生时间 ve[k]</strong></p> 
<p>根据AOE网的性质，只有进入Vk的所有活动&lt;Vj, Vk&gt;都结束，Vk代表的事件才能发生，而活动&lt;Vj, Vk&gt;的最早结束时间为ve[j]+len&lt;Vj, Vk&gt;。所以，计算Vk的最早发生时间的方法为：</p> 
<p>ve[0] = 0</p> 
<p>ve[k] = max(ve[j] + len&lt;Vj, Vk&gt;)</p> 
<p>举例：v2的最早发生时间 = a1 = 3,v5 = a4 + v2 = 6,如果是多条边则取较大值</p> 
<p><strong>事件的最早发生时间 vl[k]</strong></p> 
<p>vl[k]是指在不推迟整个工期的前提下，事件Vk允许的最迟发生时间。根据AOE网的性质，只有顶点Vk代表的事件发生，从Vk出发的活动&lt;Vk, Vj&gt;才能开始，而活动&lt;Vk, Vj&gt;的最晚开始时间为vl[j] - len&lt;Vk, Vj&gt;。</p> 
<p>逆推最早发生时间即可，注意取最小值</p> 
<p><strong>活动的最早发生时间：ee[i]</strong></p> 
<p>ai由有向边&lt;Vk, Vj&gt;，根据AOE网的性质，只有顶点Vk代表的事件发生，活动ai才能开始，即活动ai的最早开始时间等于事件Vk的最早开始时间。</p> 
<p>弧尾 = 最早发生时间</p> 
<p><strong>活动的最迟发生时间：el[i]</strong></p> 
<p>el[i]是指在不推迟真个工期的前提下，活动ai必须开始的最晚时间。若活动ai由有向边&lt;Vk, Vj&gt;表示，则ai的最晚开始时间要保证事件vj的最迟发生时间不拖后。</p> 
<p>弧头 - 开销(边的权重) = 最迟发生时间</p> 
<p><strong>活动ai的差额d(i) = l(i) - e(i)</strong></p> 
<p><img src="https://images2.imgbox.com/b6/7c/0ywuvtaS_o.png" alt="image-20210326223546148"></p> 
<p>关键路径：{a2, a5, a7}</p> 
<p><strong>缩短关键路径活动时间可以加快整个工程，但缩短到一定程度关键路径会改变</strong></p> 
<p><strong>当关键活动不唯一时，只有加快的关键活动或者关键活动组合包括在所有的关键路径上才能缩短工期</strong></p> 
<h5><a id="_4093"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/fu_jian_ping/article/details/88962697">图——关键路径 - CSDN</a></p> 
<h3><a id="_4097"></a>第七章</h3> 
<h4><a id="711%09_4099"></a>7.1.1 查找的基本概念</h4> 
<h5><a id="_4101"></a>大概念</h5> 
<p><img src="https://images2.imgbox.com/a4/ec/aXyBWNvp_o.png" alt="image-20210326223610151"></p> 
<h5><a id="_4105"></a>什么是查找</h5> 
<p>在数据集合中寻找满足某种条件的数据元素的过程</p> 
<p><strong>查找表</strong></p> 
<p>用于查找的数据集合，由同一种数据类型(或记录)的组成，可以是一个数组或链表等数据类型</p> 
<p>操作：</p> 
<ul><li>查询某个特定的数据元素是否在查找表中</li><li>检索满足条件的某个特定的数据元素的各种属性</li><li>插入一个数据元素</li><li>删除一个数据元素</li></ul> 
<h5><a id="_4120"></a>关键字</h5> 
<p>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字查找，查找结果应该是<strong>唯一的</strong></p> 
<h5><a id="_4124"></a>平均查找长度</h5> 
<p>ASL（Average Search Length），即平均查找长度，在查找运算中，由于所费时间在关键字的比较上，所以把平均需要和待查找值比较的关键字次数称为平均查找长度。</p> 
<p>概念如下图</p> 
<p><img src="https://images2.imgbox.com/66/20/JcVRLh7e_o.png" alt="image-20210326223736176"></p> 
<p>其中n为查找表中元素个数，Pi为查找第i个元素的概率，通常假设每个元素查找概率相同，Pi=1/n，Ci是找到第i个元素的比较次数。</p> 
<p>一个算法的ASL越大说明时间性能越差，反之亦然。</p> 
<h5><a id="_4136"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/ygsworld/p/10238729.html" rel="nofollow">关于ASL(平均查找长度)的简单总结 - 博客园</a></p> 
<h4><a id="721%09_4140"></a>7.2.1 顺序查找</h4> 
<h5><a id="_4142"></a>什么是顺序查找</h5> 
<p>主要用于在<strong>线性表</strong>中进行查找</p> 
<p><strong>当无须线性表进行线性查找失败时，需要遍历整个线性表</strong></p> 
<h4><a id="722%09_4148"></a>7.2.2 折半查找</h4> 
<h5><a id="_4150"></a>什么是折半查找</h5> 
<p>也叫二分查找，仅适用于<strong>有序的顺序表</strong></p> 
<h5><a id="_4154"></a>思想</h5> 
<p>首先将给定key与表中间的元素相比较，相等则返回该元素，若不等则如下：</p> 
<ul><li>key小于中间元素，查找前半部分</li><li>key大于中间元素，查找后半部分</li></ul> 
<p>重复以上过程，直到找到结果或查找失败</p> 
<h5><a id="_4163"></a>顺序查找和二分查找的区别</h5> 
<p>顺序查找适用于<strong>顺序存储</strong>和<strong>链式存储</strong>，有序无序皆可</p> 
<p>二分查找只适用于<strong>顺序存储</strong>，且要求序列一定有序</p> 
<h4><a id="723%09_4169"></a>7.2.3 分块查找</h4> 
<h5><a id="_4171"></a>什么是分块查找</h5> 
<p>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适用于快速查找</p> 
<h5><a id="_4175"></a>如何分块</h5> 
<p>将查找表分为若干子块。块内的元素无序，但块间是有序的。</p> 
<p>建立索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。<br> <img src="https://images2.imgbox.com/a8/af/FnHhzDfi_o.png" alt="image-20210326223816592"></p> 
<h4><a id="731%09B_4182"></a>7.3.1 B树</h4> 
<h5><a id="B_4184"></a>什么是B树</h5> 
<p>又称多路平衡查找树，B树中所有结点的<strong>孩子结点数</strong>的最大值称为B数的阶</p> 
<h5><a id="_4188"></a>概念</h5> 
<p>一颗m阶的B树定义如下：</p> 
<ul><li>每个结点最多有m-1个关键字。</li><li>根结点最少可以只有1个关键字。</li><li>非根结点至少有Math.ceil(m/2)-1个关键字。</li><li>每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li></ul> 
<h5><a id="_4198"></a>查找</h5> 
<ol><li>在B树中找结点（磁盘）</li><li>在结点中找关键字（内存）</li></ol> 
<p><img src="https://images2.imgbox.com/01/ef/Qc0YfF30_o.png" alt="image-20210326223914808"></p> 
<h5><a id="_4205"></a>插入</h5> 
<ol><li> <p>定位</p> <p>查找插入该关键字的位置，既<strong>最底层中的某个非叶子结点</strong></p> </li><li> <p>插入</p> <p>若插入后不会破坏B树的定义，则直接插入即可</p> <p>若会破坏B树的定义，则进行分裂操作：</p> <p>分裂：</p> 
  <ol><li>插入后的结点中间位置关键字并入父结点</li><li>左侧结点留在原地，右侧结点放入新结点</li><li>如果父节点关键字数量超出范围，则继续向上分裂，直到符合要求为止、</li></ol> </li></ol> 
<p><strong>常规插入</strong></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lM27DJqU-1618913823590)(C:%5CUsers%5CMOCHEN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210326224746455.png)]</p> 
<p><strong>分裂插入</strong></p> 
<p>插入前</p> 
<p><img src="https://images2.imgbox.com/c6/61/Ysscn2Pq_o.png" alt="image-20210326224125064"></p> 
<p>插入后</p> 
<p><img src="https://images2.imgbox.com/d0/89/hnslzyfR_o.png" alt="image-20210326224201145"></p> 
<h5><a id="_4237"></a>删除</h5> 
<ol><li> <p>直接删除</p> <p>若删除该结点不破坏B树定义，则直接删除</p> </li><li> <p>兄弟借</p> <p>若删除后破坏B树定义，则向兄弟借：</p> 
  <ol><li>将父结点左（右）侧结点拉过来</li><li>将左（右）兄弟拉到父结点</li></ol> </li><li> <p>兄弟不借</p> <p>若左右兄弟都只有一个关键字，那就合并父结点</p> 
  <ol><li>父结点合为兄弟结点</li><li>若条件不满足，重复兄弟借与不借的操作</li></ol> </li><li> <p>终端结点（最后一层非叶子结点）</p> <p>如果删除的是非终端结点，则进行以下操作：</p> 
  <ol><li> <p>替换</p> <p>找到它对应的关键字的终端结点，替换删除即可</p> </li><li> <p>合并</p> <p>如果它下面只有两个结点，直接合并结点然后删除即可</p> </li></ol> </li></ol> 
<p><strong>兄弟借</strong></p> 
<p>借之前</p> 
<p><img src="https://images2.imgbox.com/90/84/TdCO7lQy_o.png" alt="image-20210326225028916"></p> 
<p>借之后</p> 
<p><img src="https://images2.imgbox.com/fc/aa/y5Zo1VBS_o.png" alt="image-20210326225401801"></p> 
<p><strong>兄弟不借</strong></p> 
<p>合并前</p> 
<p><img src="https://images2.imgbox.com/2c/21/3r2vi5zc_o.png" alt="image-20210326225434029"></p> 
<p>合并后</p> 
<p><img src="https://images2.imgbox.com/da/59/zVsJPaIi_o.png" alt="image-20210326225516102"></p> 
<p><strong>终端结点 - 替换</strong></p> 
<p>如下图，33 和 32 替换，然后删除33</p> 
<p><img src="https://images2.imgbox.com/96/fd/v3p7eWqc_o.png" alt="image-20210326225625496"></p> 
<p><strong>终端结点 - 合并</strong></p> 
<p>如下图，合并21和24并指向30，删除23</p> 
<p><img src="https://images2.imgbox.com/11/7c/lYgjHWnx_o.png" alt="image-20210326225809420"></p> 
<h5><a id="B_4301"></a>B树的特点</h5> 
<p>优点：</p> 
<p>Ｂ树出现是因为磁盘ＩＯ。ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。</p> 
<p>常规的二叉树磁盘IO效率很低，比如我找个数需要访问h次，为了减少IO的操作就需要最大程度降低树的高度，将一个瘦长的树变成矮胖的树，因此有了B树</p> 
<p>缺点：</p> 
<p>难</p> 
<h5><a id="B_4313"></a>B树的应用</h5> 
<p>B树常应用于文件系统和部分数据库索引，以及MongoDB</p> 
<h5><a id="_4317"></a>参考内容</h5> 
<p><a href="https://www.jianshu.com/p/a858bb15cbf0" rel="nofollow">B树详解 - 简书</a></p> 
<p><a href="https://blog.csdn.net/kking_edc/article/details/108450652">B树与B+树 - CSDN</a></p> 
<p><a href="https://blog.csdn.net/sinat_36118365/article/details/103648782">漫画 B树 B-树 - CSDN</a></p> 
<h4><a id="732%09B_4325"></a>7.3.2 B+树</h4> 
<h5><a id="_4327"></a>概念</h5> 
<ol><li> <p>根结点至少有两个孩子。</p> </li><li> <p>每个中间节点都至少包含<code>ceil(m / 2)</code>个孩子，最多有m个孩子。</p> </li><li> <p>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。</p> </li><li> <p>所有的叶子结点都位于同一层。</p> </li><li> <p>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p> </li></ol> 
<h5><a id="_4339"></a>图示</h5> 
<p><img src="https://images2.imgbox.com/c2/8a/gLBtlZif_o.png" alt="image-20210326225935387"></p> 
<h5><a id="BB_4343"></a>B树与B+树的区别</h5> 
<ol><li> <p>B+树中，具有n个关键字的结点值含有n棵子树，既每个关键字对应一颗子树</p> <p>B树中，具有n个关键字的结点值含有n棵子树</p> </li><li> <p>B+树中，非叶结点只保存索引，所有信息存放在叶节点中</p> <p>B树中，每个结点保存一个信息</p> </li><li> <p>B+树中，叶结点包含全部关键字，非叶结点中出现的关键字也会出现在叶结点中</p> <p>B树中，叶结点包含的关键字和其他结点不重复</p> </li></ol> 
<h4><a id="741%09_4357"></a>7.4.1 散列表的基本概念</h4> 
<h5><a id="_4359"></a>散列函数</h5> 
<p>一个把从查找表中的关键字映射成该关键字对应的地址的函数</p> 
<h5><a id="_4363"></a>散列表</h5> 
<p>根据关键字而直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系</p> 
<h5><a id="_4367"></a>冲突</h5> 
<p>散列函数可能会把多个不同的关键字映射到同一地址下的情况</p> 
<h4><a id="742744%09_4371"></a>7.4.2~7.4.4 散列函数的构造方法和冲突处理</h4> 
<h5><a id="_4373"></a>要求</h5> 
<ol><li>散列函数的定义域必须包含全部需要存储的关键字，而值域则依赖于散列表的大小和地址范围</li><li>散列函数计算出来的地址应该能等概率，均匀的分布在整个地址空间中，最大程度减少冲突的发生</li><li>散列函数应尽量简单，能在较短时间内计算出任一关键字对应的散列地址</li></ol> 
<h5><a id="_4379"></a>方法</h5> 
<p><strong>直接定址法</strong></p> 
<p>直接取关键字的某个线性函数值为散列地址</p> 
<p>Hash(key) = a * key + b</p> 
<p>其中a,b为常数</p> 
<p><strong>方法简单，不会产生冲突，若关键字分布不连续则会浪费空间</strong></p> 
<p><strong>除留取余法</strong></p> 
<p>假定散列表表长为m，取一个不大于m但最接近或等于m的质数p</p> 
<p>Hash(key) = key % p</p> 
<p><strong>选好p是关键，可以减少冲突</strong></p> 
<p><img src="https://images2.imgbox.com/72/fc/bRlRRWhq_o.png" alt="image-20210326230054737"></p> 
<p><strong>数字分析法</strong></p> 
<p><img src="https://images2.imgbox.com/00/57/6eh6jau0_o.png" alt="image-20210326230121635"></p> 
<p>前八位相同，取后四位</p> 
<p><strong>适用于关键字已知的集合，若更换关键字则需要重新构造散列函数</strong></p> 
<p><strong>平方取中法</strong></p> 
<p>取关键字的平方值的中间几位作为散列地址</p> 
<p><strong>适用于关键字的每位取值不均匀或小于散列地址所需要的位数</strong></p> 
<p><strong>折叠法</strong></p> 
<p>将关键字分割成位数相同的几部分，然后将这几部分相加作为散列地址</p> 
<p><strong>适用于关键字的位数多，而且关键字中的每位上数字分布大致均与</strong></p> 
<h5><a id="_4421"></a>开放定址法</h5> 
<p>是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放</p> 
<p>Hi = (H(key) + di) % m</p> 
<p>i = 0,1,2,…,k(k &lt;= m - 1);</p> 
<p>m为散列表表长</p> 
<p>di为增量序列</p> 
<p><strong>如何计算增量序列</strong></p> 
<p><strong>线性探查法</strong></p> 
<p>既 di = 0,1,2,…,k</p> 
<p><strong>平方探测法</strong></p> 
<p>既 di = 0平方，1平方，-1平方，2平方，-2平方，…,k平方，-k平方，其中k &lt;= m / 2</p> 
<p>避免堆积问题，缺点是不能探测到散列表上的所有单元</p> 
<p><strong>再散列法</strong></p> 
<p>既 di = i * Hash2(key)</p> 
<p><strong>伪随机序列法</strong></p> 
<p>既 di = 伪随机序列</p> 
<p><strong>开放定址法不能随便删除某个元素</strong></p> 
<h5><a id="_4455"></a>拉链法（重点）</h5> 
<p>把所有同义词存放在一个线性链表中，这个线性链表由地址唯一表示，既散列表中每个单元存放该链表头指针</p> 
<p>数组每个成员包括一个指针，指向一个数组</p> 
<p><img src="https://images2.imgbox.com/45/cb/suXfdS5z_o.png" alt="image-20210326230426665"></p> 
<p><strong>拉链法适用于经常进行插入和删除的情况</strong></p> 
<h5><a id="_4465"></a>查找效率</h5> 
<p>散列函数，处理冲突的方法和填装因子</p> 
<p><strong>填装因子</strong></p> 
<p>一般记为阿尔法，表示表的装满程度</p> 
<p><img src="https://images2.imgbox.com/d3/71/Mkxj7LH6_o.png" alt="image-20210326230509448"></p> 
<p><strong>散列表的平均查找长度依赖于散列表的填装因子</strong></p> 
<h5><a id="_4477"></a>散列表的特点</h5> 
<p>和数组以及链表对比：</p> 
<table><thead><tr><th align="center"></th><th align="center">查找</th><th align="center">增删</th></tr></thead><tbody><tr><td align="center">数组</td><td align="center">快</td><td align="center">慢</td></tr><tr><td align="center">链表</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">散列表</td><td align="center">快</td><td align="center">快</td></tr></tbody></table> 
<p><strong>优点</strong></p> 
<p>接近O(1)的时间复杂度，碾压一切渣渣</p> 
<p><strong>缺点</strong></p> 
<p>因为是<strong>基于数组</strong>的，所以填装因子越大性能越低，因此<strong>必须要清楚表中将要存储多少数据</strong></p> 
<h5><a id="_4495"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/af/b3/KAZS1Z8M_o.png" alt="image-20210326230228176"></p> 
<h5><a id="_4499"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/yyyljw/article/details/80903391">哈希表（散列表）原理详解 - CSDN</a></p> 
<h3><a id="_4503"></a>第八章</h3> 
<h4><a id="81%09_4505"></a>8.1 排序的基本概念</h4> 
<h5><a id="_4507"></a>大概念</h5> 
<p><img src="https://images2.imgbox.com/71/32/vb6lLL5p_o.png" alt="image-20210326230653534"></p> 
<h5><a id="_4511"></a>排序</h5> 
<p>重新定义表中的元素，使表中的元素按照关键字递增或递减</p> 
<h5><a id="_4515"></a>排序算法的稳定性</h5> 
<p>排序后两个相同的元素不发生变动，则为稳定，反之则为不稳定</p> 
<p>如下图，淡蓝色小朋友排序后仍在深蓝色小朋友之前，则这个算法就是稳定的</p> 
<p><img src="https://images2.imgbox.com/90/47/u1EhulaZ_o.png" alt="image-20210326230748619"></p> 
<p><strong>稳定性只是算法的性质，无法评定算法的优劣</strong></p> 
<h5><a id="_4525"></a>内部排序与外部排序</h5> 
<p><strong>内部排序</strong></p> 
<p>指在排序期间全部放在内存中排序</p> 
<p><strong>外部排序</strong></p> 
<p>指在排序期间无法全部放在内存中，在排序过程中根据要求不断的在内，外存中移动</p> 
<p>此处仅探讨内部排序</p> 
<p><strong>时空复杂度决定内部排序算法的性能</strong></p> 
<h4><a id="821%09_4539"></a>8.2.1 直接插入排序</h4> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/93/03/M16Cdyzz_o.png" alt="img"></p> 
<h5><a id="_4545"></a>实现思路</h5> 
<ol><li>从第二个参数开始往前比较，如果上个参数比当前参数大则交换位置</li><li>继续对比，直到前面没有比自身更大的数</li><li>重复第二步，直到全部数据排完</li></ol> 
<h5><a id="_4551"></a>实现代码</h5> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 插入排序
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        InsertSort is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">insSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 每次将当前数字与前面所有位数比较，前面大则交换，否则看下一个数字
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrs<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> temp <span class="token punctuation">;</span>
                    temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                    j<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/**
     * 1. 从第二个数字开始遍历，将当前数字放入数组第一位当作哨兵使用
     * 2. 从当前数字往前遍历，只要大于哨兵就往前移一位
     * 3. 将哨兵赋给下一位，完成交换操作
     * 4. 重复以上操作，直到数据完成排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insSortSent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arrs<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 将当前数组扩容一位，保证第一位是哨兵</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> newArrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                newArrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            newArrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 归还结果</span>
        arrs <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此处while可以改成for，for版本代码更简洁，用while更清晰故使用while</p> 
<p>教材代码虽然简洁但是偏难，需多多理解</p> 
<p><img src="https://images2.imgbox.com/a2/80/jraROPqU_o.png" alt="image-20210326230821707"></p> 
<h5><a id="_4619"></a>概念</h5> 
<p>时间复杂度为[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zyBxBs5G-1618913823601)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]，可采用顺序存储和链式存储</p> 
<h5><a id="_4623"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/coding-996/p/12275710.html" rel="nofollow">插入排序 - 沐雨橙风~~ - 博客园</a></p> 
<h4><a id="822%09_4627"></a>8.2.2 折半插入排序</h4> 
<h5><a id="_4629"></a>概念</h5> 
<p>二分查找 + 插入排序</p> 
<p>减少了比较次数，但是元素的移动次数不变。平均时间复杂度为O(n^2)；空间复杂度为O(1)；是稳定的排序算法。</p> 
<h5><a id="_4635"></a>实现代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 折半插入排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bInsSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arrs<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 将当前数组扩容一位，保证第一位是哨兵</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>newArrs<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                newArrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            newArrs<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 归还结果</span>
        arrs <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>同上，此处也可使用非哨兵模式，同步教材代码故使用哨兵模式</p> 
<h5><a id="_4672"></a>时间复杂度下界</h5> 
<p>对于下标i &lt; j, 如果A[i] &gt; A[j], 则称(i, j)是一对<strong>逆序对</strong></p> 
<p>只要后面的数字比当前位数小，就是逆序对，交换元素的排序算法本质就是消除逆序对</p> 
<p>任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为**[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BwUVO1aO-1618913823602)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]**</p> 
<h5><a id="_4680"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/weixin_42245157/article/details/80458542">排序----折半插入排序 - CSDN</a></p> 
<p><a href="https://blog.csdn.net/guoweimelon/article/details/50904206">经典排序算法（4）——折半插入排序算法详解 - CSDN</a></p> 
<h4><a id="823%09_4686"></a>8.2.3 希尔排序</h4> 
<h5><a id="_4688"></a>什么是希尔排序</h5> 
<p>希尔排序是一种改进后的插入排序，也称<strong>缩小增量排序</strong>。</p> 
<p>按照<strong>增量序列</strong>进行插入排序，最后一步增量序列为1</p> 
<p>如下图，第一个按照五个间隔排序，第二次按照三个间隔排序，最后一次按照一个间隔排序，这里的5，3，1就是增量序列</p> 
<p><img src="https://images2.imgbox.com/91/14/wDsuGJn5_o.png" alt="image-20210326231244579"></p> 
<h5><a id="_4698"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 希尔排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dk <span class="token operator">=</span> arrs<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> dk <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> dk <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dk <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> dk <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>i <span class="token operator">-</span> dk<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">;</span> i <span class="token operator">-=</span> dk<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i <span class="token operator">-</span> dk<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>思路很简单，就是插入排序外面套一层增量序列的循环</p> 
<h5><a id="_4721"></a>概念</h5> 
<p>希尔排序的最坏时间复杂度依然是[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Rdwat4wa-1618913823603)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]，但是往往并达不到这种程度</p> 
<p>采用优化的增量序列可以最大程度减少时间复杂度，比如Hibbard等等</p> 
<h5><a id="_4727"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" rel="nofollow">图解排序算法(二)之希尔排序 - 博客园</a></p> 
<h4><a id="831%09_4731"></a>8.3.1 冒泡排序</h4> 
<h5><a id="_4733"></a>什么是冒泡排序</h5> 
<p>类似于冒泡，大的数沉下去，小的数浮上来，所以叫冒泡排序</p> 
<p>每次遍历将最大的数字移到末尾</p> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/e1/dc/bBm2Bp8m_o.gif" alt="img"></p> 
<h5><a id="_4743"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 冒泡排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_4763"></a>概念</h5> 
<p>思路就是比较，交换，该算法过于经典不多描述</p> 
<h5><a id="_4767"></a>参考内容</h5> 
<p><a href="https://www.jianshu.com/p/1458abf81adf" rel="nofollow">排序-冒泡排序 - 简书</a></p> 
<h4><a id="832%09_4771"></a>8.3.2 快速排序</h4> 
<h5><a id="_4773"></a>什么是快速排序</h5> 
<p>快排的性能在所有排序算法里面是最好的，数据规模越大快速排序的性能越优。快排在极端情况下会退化成 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-6SvSbbug-1618913823604)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)] 的算法，因此<strong>假如在提前得知处理数据可能会出现极端情况的前提下</strong>，可以选择使用较为稳定的归并排序。</p> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/8f/a2/PbzLmcdz_o.gif" alt="img"></p> 
<h5><a id="_4781"></a>实现思路</h5> 
<ul><li>选择A中任意一个元素pivot,该元素作为基准</li><li>将小于基准的元素移到左边，大于基准的移到右边</li><li>A被pivot分为两部分，继续对剩下的两部分做同样的处理</li><li>重复以上操作，直到数据排序完成</li></ul> 
<h5><a id="_4788"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 快速排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> high<span class="token punctuation">;</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> i <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token operator">--</span>j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token operator">++</span>i<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token function">quickSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> low<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">quickSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>更标准的写法应该是两个方法，一个拿基准，一个递归排序，此处图简洁不做实现</p> 
<h5><a id="_4819"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/93129029" rel="nofollow">排序–快速排序 - 知乎</a></p> 
<p><a href="https://blog.csdn.net/nrsc272420199/article/details/82587933">快速排序—(面试碰到过好几次) - CSDN</a></p> 
<h4><a id="841%09_4825"></a>8.4.1 直接选择排序</h4> 
<h5><a id="_4827"></a>什么是选择排序</h5> 
<p>每次从无序中选出最小元（最小关键字），将最小元放入有序的后面</p> 
<p>和插入不同，插入是交换有序序列，选择是追加到有序后面</p> 
<p>和冒泡大抵相同，不过<strong>冒泡是每次交换n-1次，选择是交换两次</strong></p> 
<p><img src="https://images2.imgbox.com/c0/41/SWrYER5p_o.png" alt="image-20210326231653930"></p> 
<h5><a id="_4837"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 选择排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 交换</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>一次排序将一个元素放置到最终的位置上</strong></p> 
<h4><a id="842%09_4864"></a>8.4.2 堆排序</h4> 
<h5><a id="_4866"></a>什么是堆排序</h5> 
<p>堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p> 
<h5><a id="_4870"></a>堆</h5> 
<p><strong>堆是具有以下性质的完全二叉树：</strong></p> 
<p><strong>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</strong></p> 
<p><strong>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</strong></p> 
<p>如下图：</p> 
<p><img src="https://images2.imgbox.com/48/ac/ha4zeHle_o.png" alt="image-20210326232204604"></p> 
<p><img src="https://images2.imgbox.com/74/24/CGUTj1ZK_o.png" alt="image-20210326232251795"></p> 
<h5><a id="_4884"></a>实现代码</h5> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 堆排序
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">heapSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 堆排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 构建大顶堆</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arrs<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2. 调整堆结构 + 交换堆顶元素与末尾元素</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> arrs<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 调整大顶堆
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> k <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrs<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> k<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 交换元素
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arrs<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arrs<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_4947"></a>概念</h5> 
<ol><li> <p>将无序序列构建成一个大顶堆（小顶堆同理）</p> 
  <ol><li>将每个子树的最大值调整为父节点</li><li>重复上一步，直到根节点为最大值，堆构建完成</li></ol> </li><li> <p>将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端</p> </li><li> <p>重新调整结构，使其满足堆定义，然后重复第二步，反复执行调整+交换步骤，直到整个序列有序</p> </li></ol> 
<h5><a id="_4957"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" rel="nofollow">图解排序算法(三)之堆排序 - 博客园</a></p> 
<h4><a id="851%09_4961"></a>8.5.1 归并排序</h4> 
<h5><a id="_4963"></a>什么是归并排序</h5> 
<p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略</p> 
<p>分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之</p> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/c2/6b/SiJzw5q4_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/ff/43/1rN9izHL_o.png" alt="image-20210326232336193"></p> 
<h5><a id="_4975"></a>代码实现</h5> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 归并排序
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 归并排序
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左边归并排序，使得左子序列有序</span>
            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右边归并排序，使得右子序列有序</span>
            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将两个有序子数组合并操作</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 合并有序子列
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment">//左序列指针</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//右序列指针</span>
        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//临时数组指针</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//将左边剩余元素填充进temp中</span>
            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//将右序列剩余元素填充进temp中</span>
            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//将temp中的元素全部拷贝到原数组中</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="_5034"></a>思路</h5> 
<p>上面两个图示已经比较明显，此处不做思路总结</p> 
<h5><a id="_5038"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" rel="nofollow">图解排序算法(四)之归并排序 - 博客园</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/124356219" rel="nofollow">【算法】排序算法之归并排序 - 知乎</a></p> 
<h4><a id="852__5044"></a>8.5.2 基数排序</h4> 
<h5><a id="_5046"></a>什么是基数排序</h5> 
<p>不同于以往的排序，基数排序无需进行比较或者交换，他通过<strong>分配和收集</strong>进行排序</p> 
<h5><a id="_5050"></a>思路</h5> 
<p>依照位数进行排序，比如三位数先进行个分位分配，然后十分位，百分位</p> 
<p>可以这么理解，先对最后一位进行排序，然后往前一位，直到第一位，第一位排序完成即可</p> 
<p><img src="https://images2.imgbox.com/d7/af/U5e1TTHR_o.png" alt="image-20210326232509514"></p> 
<p>此章非重点不多做解释，感兴趣可去参考内容了解</p> 
<h5><a id="_5060"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/lemon_tree12138/article/details/51695211">排序算法系列：基数排序 - CSDN</a></p> 
<p><a href="https://www.cnblogs.com/yimeixiaobai1314/p/7932254.html" rel="nofollow">基数排序 顺序实现与链式实现</a></p> 
<h4><a id="86%09_5066"></a>8.6 内部排序算法的比较及应用</h4> 
<p><img src="https://images2.imgbox.com/bc/a4/7uucANh3_o.png" alt="image-20210326232440457"></p> 
<p><img src="https://images2.imgbox.com/69/c2/70A6JAll_o.png" alt="image-20210326232546798"></p> 
<h5><a id="_5072"></a>考虑因素</h5> 
<p>综合考虑：元素数量，元素大小，关键字结构及分布，稳定性，存储结构，辅助空间</p> 
<ol><li>若n较小(n&lt;=50)时，可采用直接插入排序或简单选择排序，若n较大时，则采用快排，堆排或归并排序</li><li>若n很大，关键字位数较小且可分解，采用基数排序</li><li>当文件的n个关键字随机分布，任何借助于比较的排序，至少需要O(nlog2n)的时间</li><li>若初始基本有序，则采用直接插入或冒泡排序</li><li>当记录元素较大，应避免大量的移动的排序算法，尽量次啊用链式存储</li></ol> 
<p><strong>每种排序算法都有它存在的意义，实际应用中应根据实际情况选择使用那种排序</strong></p> 
<h4><a id="871872%09_5084"></a>8.7.1~8.7.2 外部排序的算法</h4> 
<h5><a id="_5086"></a>什么是外部排序</h5> 
<p>对内存中的数据进行排序叫内部排序，内存外的数据排序即为外部排序</p> 
<p>外部排序通常采用<strong>归并排序</strong></p> 
<h5><a id="_5092"></a>举例</h5> 
<p>内存中只能放三个数，现在有十二个数，如何实现排序？</p> 
<p>利用归并排序的思想，先分成四分进行依次排序，然后进行合并</p> 
<p><img src="https://images2.imgbox.com/50/e7/8NZzlGah_o.png" alt="img"></p> 
<p>两两合并子串，得到两个长度为六的子串，然后进行最后一次合并：</p> 
<p><img src="https://images2.imgbox.com/e2/b5/ZWOFTKdu_o.png" alt="img"></p> 
<h5><a id="_5104"></a>时间复杂度</h5> 
<p>外部排序的时间 = 内部排序的时间 + 外存读写时间 + 内部排序归并的时间</p> 
<h4><a id="873%09_5108"></a>8.7.3 失败树</h4> 
<h5><a id="_5110"></a>什么是失败树</h5> 
<p>树形选择排序的一种变体，可视为一颗完全二叉树</p> 
<p>每个叶结点存放各归段在归并过程中参加比较的记录，内部结点用来记忆左右子树中的失败者，胜利者则向上继续比较，直到根节点</p> 
<h4><a id="874%09_5116"></a>8.7.4 置换-选择排序</h4> 
<h5><a id="_5118"></a>思路</h5> 
<p>设初始待排序文件为FI，初始归并段位FO,内存为WA,可容纳w个记录</p> 
<ol><li>从FI中输入w个记录到WA</li><li>从WA中选出最小值，输出到FO</li><li>从FI中重新读入一个值，重复第二步操作</li><li>重复2~3,直到选不出最小值，此处得到第一个归并段</li><li>重复2~4，直到WA为空，得到所有初始归并段</li></ol> 
<h5><a id="_5128"></a>示例</h5> 
<p>如下图所示，先进入三个数，最小值05给出去同事下一个数44进来，然后挑选比05大的第一个数17进来，重复操作知道56，后面没有最小值，此时得到第一个归并段；然后重复上述操作即可</p> 
<p><img src="https://images2.imgbox.com/2f/4d/YHp4n6KL_o.png" alt="image-20210326233222889"></p> 
<h4><a id="875%09_5134"></a>8.7.5 最佳归并树</h4> 
<p>在上一章的基础上，将归并树转化为哈夫曼树，即为最佳归并树</p> 
<p><img src="https://images2.imgbox.com/83/25/X03vf9hr_o.png" alt="image-20210326233305663"></p> 
<p>如上图，该归并树IO次数为2 * WPL = 484</p> 
<p><img src="https://images2.imgbox.com/3e/28/APSXpVKr_o.png" alt="image-20210326233416271"></p> 
<p>该树IO次数位 2 * WPL = 446，所以称为最佳归并树</p> 
<p><strong>当叶子结点不够时，增加权值为0的结点用来构造哈夫曼树</strong></p> 
<h5><a id="_5148"></a>总结</h5> 
<p>可使用多路归并，最优为置换选择</p> 
<h5><a id="_5152"></a>参考内容</h5> 
<p><a href="https://www.sohu.com/a/258751244_818692" rel="nofollow">【漫画】什么是外部排序？ - 搜狐</a></p> 
<p><a href="https://www.cnblogs.com/LUO77/p/5838206.html" rel="nofollow">外部排序&amp;多路归并排序 - 博客园</a></p> 
<h3><a id="___5158"></a>第九章 - 补充</h3> 
<h4><a id="91__5160"></a>9.1 红黑树</h4> 
<h5><a id="_5162"></a>什么是红黑树</h5> 
<p>为了解决<strong>二叉查找树多次单侧插入新节点导致的不平衡</strong>，红黑树应运而生</p> 
<p>红黑树基于二叉查找树实现，它具有以下特点：</p> 
<ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ol> 
<h5><a id="_5174"></a>红黑树的优点</h5> 
<p>正是因为有了上述繁琐的规则限制，才保证了红黑树的自平衡。<strong>红黑树从根到叶子的最长路径不会超过最短路径的2倍。</strong></p> 
<h5><a id="_5178"></a>红黑树的调整</h5> 
<p>当插入或删除节点的时候，有可能会打破规则，这个时候就需要根据情况做出调整，以此来维持规则</p> 
<p>调整有两种方法，<strong>变色</strong>和<strong>旋转</strong>，而旋转又分为<strong>左旋转</strong>和<strong>右旋转</strong></p> 
<h5><a id="_5184"></a>变色</h5> 
<p>变色就是字面意思变色</p> 
<h5><a id="_5188"></a>旋转</h5> 
<h6><a id="_5190"></a>左旋转</h6> 
<p>逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子</p> 
<p>Y变成爹，X变成儿子，代价是左腿给X</p> 
<p><img src="https://images2.imgbox.com/2d/fe/gjKqFjT2_o.png" alt="img"></p> 
<h6><a id="_5198"></a>右旋转</h6> 
<p>顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子</p> 
<p><img src="https://images2.imgbox.com/f4/33/IOaBzAUx_o.png" alt="img"></p> 
<h5><a id="_5204"></a>举例</h5> 
<p><img src="https://images2.imgbox.com/38/e1/EY5zfk1a_o.png" alt="img"></p> 
<p>如上图所示，该情况打破了规则4，解决方案如下：</p> 
<h6><a id="_5210"></a><strong>变色</strong></h6> 
<ol><li>22变为黑色</li><li>25变为红色</li><li>27变为黑色</li></ol> 
<p><img src="https://images2.imgbox.com/68/9a/9u7nxMXj_o.png" alt="img"></p> 
<h6><a id="_5218"></a>旋转</h6> 
<p>此时变色已经无法解决问题了，就需要用到旋转</p> 
<ol start="4"><li>13和17进行左旋转</li><li>13变为红色，17变为黑色</li></ol> 
<p><img src="https://images2.imgbox.com/f5/f8/qmuWQras_o.png" alt="img"></p> 
<p>此时并没有结束，路径(17 -&gt; 8 -&gt; 6 -&gt; NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5，我们继续操作：</p> 
<ol start="6"><li>13和8进行右旋转</li><li>8，15变为红色，13变为黑色</li></ol> 
<p>结果</p> 
<p><img src="https://images2.imgbox.com/84/52/tfiZ2KY5_o.png" alt="img"></p> 
<h5><a id="_5236"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/qq_36610462/article/details/83277524">面试常问：什么是红黑树？- CSDN</a></p> 
<h4><a id="92__5240"></a>9.2 贪心算法</h4> 
<p>顾名思义，贪心算法总是做出<strong>当前看来最好的选择</strong>，也就是说贪心算法<strong>并不从整体最优考虑</strong>，它所作出的选择只是在某种意义上的<strong>局部最优选择</strong>。</p> 
<h5><a id="_5244"></a>思路</h5> 
<ol><li>把问题分解成若干个问题</li><li>求出每个子问题的最优解</li><li>将每个局部最优解合并，得到结果的最优解</li></ol> 
<p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong></p> 
<p>我也不太会，看漫画吧，漫画比较详细</p> 
<h5><a id="_5254"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/76164082" rel="nofollow">漫画：五分钟学会贪心算法 - 知乎</a></p> 
<p><a href="https://www.jianshu.com/p/ab89df9759c8" rel="nofollow">五大常用算法之一：贪心算法 - 简书</a></p> 
<h3><a id="_5260"></a>总结</h3> 
<h5><a id="_5262"></a>后言</h5> 
<p>数据结构更多是一种思想，非算法从业者或考研可不做重点学习</p> 
<p>既然说了是思想，就要明白为什么学这个，期望掌握什么，多思考，多code，才是出路</p> 
<p><strong>墨尘 2021年2月1日</strong><br> 通常用树的<strong>双亲表示法</strong>作为并查集的存储结构</p> 
<p>通常用数组元素的下标代表元素名，用根节点的下标代表子集合名，根节点的双亲结点为负数。</p> 
<pre><code>Initial(S)	// 将集合S中的每个元素都初始化为只有一个单元素的子集合
Union(S, Root1, Root2) // 把集合S中的子集合（互不相交）Root2并入子集合Root1
Find(S, x) // 查找集合S中单元素x所在子集合，并返回该子集合的名字
</code></pre> 
<h5><a id="_5279"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/cd/9a/Qdt5uZqc_o.png" alt="image-20210326214853622"></p> 
<h4><a id="532%09_5283"></a>5.3.2 线索二叉树</h4> 
<h5><a id="_5285"></a>线索二叉树的概念</h5> 
<p><img src="https://images2.imgbox.com/00/51/owKDnBIR_o.png" alt="image-20210326215111226"></p> 
<h5><a id="_5289"></a>线索化</h5> 
<p>若无左子树，则将左指针指向其前驱结点</p> 
<p>若无右子树，则将右指针指向其后驱结点</p> 
<h5><a id="_5295"></a>优点</h5> 
<p>将原本的空指针都替换为前驱和后驱，可以加快结点的查询</p> 
<h4><a id="541%09_5299"></a>5.4.1 树的存储结构</h4> 
<h5><a id="_5301"></a>双亲表示法</h5> 
<p>采用一组连续的存储空间来存储每个结点，同时每个结点中增设一个伪指针，指向双亲结点在数组中的位置。根节点的下标为0，其伪指针域为-1。</p> 
<p>多一个指针，指向父节点，没爹则给-1。</p> 
<h5><a id="_5307"></a>孩子表示法</h5> 
<p>将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表。</p> 
<p>每个结点的所有子结点就是一个单链表。</p> 
<h5><a id="_5313"></a>孩子兄弟表示法</h5> 
<p>以二叉链表作为树的存储结构，又称二叉树表示法。</p> 
<p>左指针指向第一个孩子，右子针指向下一个兄弟。</p> 
<p><img src="https://images2.imgbox.com/3a/30/EzViKOxu_o.png" alt="image-20210326215259198"></p> 
<h5><a id="_5321"></a>优缺点对比</h5> 
<table><thead><tr><th align="center"></th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">双亲表示法</td><td align="center">寻找双亲效率高</td><td align="center">寻找孩子效率低</td></tr><tr><td align="center">孩子表示法</td><td align="center">寻找孩子效率高</td><td align="center">寻找双亲效率低</td></tr><tr><td align="center">孩子兄弟表示法</td><td align="center">寻找孩子效率高 方便树转换为二叉树</td><td align="center">寻找双亲效率低</td></tr></tbody></table> 
<h4><a id="542543%09_5329"></a>5.4.2~5.4.3 树和森林</h4> 
<h5><a id="_5331"></a>树与二叉树的转换</h5> 
<p>可用上一章的左孩子右兄弟的办法进行转换。</p> 
<h5><a id="_5335"></a>森林与二叉树的转换</h5> 
<p>先转为二叉树，在将每棵二叉树的根依次作为上一棵二叉树的右子树。</p> 
<h5><a id="_5339"></a>树的遍历</h5> 
<p>按照某种方式访问树中的每个结点，且仅访问一次</p> 
<h5><a id="_5343"></a>先根遍历</h5> 
<p>先访问根结点，在按照从左到右的顺序遍历根节点的子树</p> 
<p><strong>树的先根遍历与这棵树对应二叉树的先序遍历相同</strong></p> 
<h5><a id="_5349"></a>后根遍历</h5> 
<p>先按照从左到右的顺序遍历根节点的子树，在访问根结点</p> 
<p><strong>树的后根遍历与这棵树对应二叉树的中序遍历相同</strong></p> 
<h5><a id="_5355"></a>举例</h5> 
<p><img src="https://images2.imgbox.com/37/0a/011PVpND_o.png" alt="image-20210326215359802"></p> 
<p>先根遍历：RADEBCFGHK</p> 
<p>后根遍历：DEABGHKFCR</p> 
<h5><a id="_5363"></a>森林的遍历</h5> 
<h5><a id="_5365"></a>先序遍历</h5> 
<ol><li>访问第一棵树的根结点</li><li>先序遍历第一棵树的子树森林</li><li>先序遍历除去第一棵树之后剩余的树构成的子树森林</li></ol> 
<h5><a id="_5371"></a>中序遍历</h5> 
<ol><li>中序遍历第一棵树的根结点的子树森林</li><li>访问第一棵树的根结点</li><li>中序遍历除去第一棵树之后剩余的树构成的子树森林</li></ol> 
<h4><a id="544%09_5377"></a>5.4.4 树的应用并查集</h4> 
<h5><a id="_5379"></a>什么是并查集</h5> 
<p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p> 
<ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul> 
<h6><a id="_5386"></a>实现代码</h6> 
<pre><code class="prism language-java"><span class="token comment">/**
 * @Description: 并查集
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> fa<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 初始化
     */</span>
    <span class="token keyword">void</span> <span class="token function">initial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 查询
     */</span>
    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> x <span class="token operator">==</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">?</span> x <span class="token operator">:</span> <span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 合并
     */</span>
    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        fa<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_5424"></a>按秩合并</h5> 
<p>合并时，优先将简单的树往复杂的树上面合，从而达到最小程度影响深度</p> 
<h6><a id="_5428"></a>实现思路</h6> 
<p>重新给定一个数组rank[]记录每个树的深度，开始所有rank设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p> 
<p>注意：按秩合并会带来额外的<strong>空间复杂度</strong></p> 
<p>此概念为优化，此处暂不做深究</p> 
<h5><a id="_5436"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/93647900/" rel="nofollow">算法学习笔记(1):并查集 - 知乎</a></p> 
<h4><a id="551%09_5440"></a>5.5.1 二叉排序树</h4> 
<h5><a id="_5442"></a>什么是二叉排序树</h5> 
<p>二叉排序树(Binary Sort Tree),也称二叉查找树</p> 
<ol><li>左子树所有节点均<strong>小于</strong>根节点</li><li>右子树所有节点均<strong>大于</strong>根节点</li><li>左右子树也是二叉排序树</li></ol> 
<h5><a id="_5450"></a>插入</h5> 
<p>若二叉排序树为空，则直接插入</p> 
<p>若二叉排序树非空，当值小于根节点时插入左子树，当值大于根节点时插入右子树，当值等于根节点则不插入</p> 
<h5><a id="_5456"></a>构造二叉排序树</h5> 
<p>读入元素并建立节点，若二叉树为空则将其作为根节点</p> 
<p>若二叉排序树非空，当值小于根节点时插入左子树，当值大于根节点时插入右子树，当值等于根节点则不插入</p> 
<p>思路和插入一样</p> 
<h5><a id="_5464"></a>删除</h5> 
<ol><li>若被删除节点是叶节点，则直接删除</li><li>若被删除节点z只有一棵子树，则让z的子树指向z的父节点，代替z节点</li><li>若被删除节点z有两颗子树，则让z的右子树最小的节点替换z</li></ol> 
<h4><a id="552%09_5470"></a>5.5.2 平衡二叉树</h4> 
<h5><a id="_5472"></a>什么是平衡二叉树</h5> 
<p>平衡二叉树(AVL)，每个节点的左子树和右子树的高度差最多为1</p> 
<p>AVL是取自作者名</p> 
<h5><a id="_5478"></a>平衡二叉树的判断</h5> 
<ol><li>判断左子树是一颗平衡二叉树</li><li>判断右子树是一颗平衡二叉树</li><li>判断该节点为根的二叉树为平衡二叉树</li></ol> 
<h5><a id="_5484"></a>平衡树的旋转</h5> 
<h5><a id="LL_5486"></a>LL平衡旋转(右旋转)</h5> 
<p>在结点A的左孩子的左子树上插入新节点</p> 
<p>将A的左孩子B代替A，将A节点称为B的右子树根节点，而B的原右子树则作为A的左子树</p> 
<p><img src="https://images2.imgbox.com/ce/93/gFhAoqNE_o.png" alt="image-20210326220051604"></p> 
<p><img src="https://images2.imgbox.com/f8/56/yhIV2sYN_o.png" alt="image-20210326220221152"></p> 
<h5><a id="RR_5496"></a>RR平衡旋转(左旋转)</h5> 
<p>在结点A的右孩子的右子树上插入新节点</p> 
<p>将A的右孩子B代替A，将A节点称为B的左子树根节点，而B的原左子树则作为A的右子树</p> 
<p><img src="https://images2.imgbox.com/84/95/ofPylmrx_o.png" alt="image-20210326220241687"></p> 
<p><img src="https://images2.imgbox.com/5b/9e/4Nk6IM4M_o.png" alt="image-20210326220502554"></p> 
<p>可以对比红黑树的旋转，此处逻辑基本相同</p> 
<h4><a id="553%09_5508"></a>5.5.3 哈夫曼树</h4> 
<h5><a id="_5510"></a>带权路径长度</h5> 
<p>路径长度 路径上所经历<strong>边</strong>的个数</p> 
<p>结点的权 结点被赋予的数值</p> 
<p>树的<strong>带权路径长度 WPL</strong>，树中所有<strong>叶结点</strong>的带权路径长度之和</p> 
<p><img src="https://images2.imgbox.com/e1/d0/n7C1t5HN_o.png" alt="image-20210326220725139"></p> 
<h5><a id="_5520"></a>什么是哈夫曼树</h5> 
<p>哈夫曼树也称最优二叉树，含有n个<strong>带权叶子结点带权路径长度最小</strong>的二叉树</p> 
<h5><a id="_5524"></a>哈夫曼树的构造算法</h5> 
<ol><li>将n个结点作为n棵仅含有一个根节点的二叉树，构成森林F</li><li>生成一个新节点，从F中找出根节点权值最小的两棵树作为它的左右子树，新节点的权值为两颗子树的权值之和</li><li>从F中删除这两个数，并将新生成的树加入F</li><li>重复2，3步骤，直到F中只有一棵树为止</li></ol> 
<h5><a id="_5531"></a>哈夫曼树的性质</h5> 
<ol><li>每个初始结点都会成为叶节点，双支结点都为新生成的结点</li><li>权值越大离根结点越进，反之则越远</li><li>哈夫曼树中没有结点为度的1（要么没有子结点，要么两个子结点）</li><li>n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1</li></ol> 
<h5><a id="_5538"></a>参考内容</h5> 
<p><a href="https://baijiahao.baidu.com/s?id=1663514710675419737&amp;wfr=spider&amp;for=pc" rel="nofollow">什么是哈夫曼树？ - CSDN</a></p> 
<h3><a id="_5542"></a>第六章</h3> 
<h4><a id="611%09_5544"></a>6.1.1 图的基本概念</h4> 
<h5><a id="_5546"></a>大概念</h5> 
<p><img src="https://images2.imgbox.com/13/5c/mu9uWoPh_o.png" alt="image-20210326220906943"></p> 
<table><thead><tr><th align="center">线性表</th><th align="center">一对一</th></tr></thead><tbody><tr><td align="center">树</td><td align="center">一对多</td></tr><tr><td align="center">图</td><td align="center">多对多</td></tr></tbody></table> 
<h5><a id="_5555"></a>什么是图</h5> 
<p>图(Graph)是一种复杂的非线性结构，每个数据之间可任意关联。正是因为任意关联性，导致了图的复杂性。</p> 
<h6><a id="_5559"></a>图的结构</h6> 
<p>顶点(Vertex): 图中的数据元素</p> 
<p>边(Edge): 图中连接顶点的线</p> 
<h5><a id="_5565"></a>无向图</h5> 
<p>一个图所有的边都没有方向，称为无向图</p> 
<p>无序边(v, w) = (w, v)</p> 
<h5><a id="_5571"></a>有向图</h5> 
<p>一个图边有方向性，称为有向图</p> 
<p>有序对&lt;v, w&gt;</p> 
<p><strong>权</strong>：图的边往往需要表示成为某种数值，这个数值便是该边的权。</p> 
<p>除去上面两种还有多种其他概念的图，此处不做深究</p> 
<pre><code class="prism language-java">Graph <span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 建立并返回空图</span>
Graph <span class="token function">InsertVertex</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将V插入G</span>
Graph <span class="token function">InsertEdge</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Edge e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将e插入G</span>
<span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从V出发深度优先遍历G</span>
<span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从V出发广度优先遍历G</span>
<span class="token keyword">void</span> <span class="token function">ShortestPath</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Vertex V<span class="token punctuation">,</span> <span class="token keyword">int</span> Dist<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算图G中顶点V到任意其他顶点的最短距离</span>
<span class="token keyword">void</span> <span class="token function">MST</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算图G的最小生成树</span>
</code></pre> 
<h5><a id="_5591"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/tiantangdizhibuxiang/article/details/82057291">图的java实现 - CSDN</a></p> 
<p><a href="https://blog.csdn.net/hehuanchun0311/article/details/80168109">数据结构 – 图 - CSDN</a></p> 
<h4><a id="621%09_5597"></a>6.2.1 邻接矩阵法</h4> 
<h5><a id="_5599"></a>什么是邻接矩阵</h5> 
<p>给定两个数组，一个一维数组存储顶点信息，一个二维数组存储图中的边的信息</p> 
<p>无相图的邻接矩阵是一个对称矩阵</p> 
<p><img src="https://images2.imgbox.com/9b/08/tWq88p72_o.png" alt="image-20210326221134089"></p> 
<h5><a id="_5607"></a>邻接矩阵的优点</h5> 
<ol><li>直观，便于理解</li><li>方面检查任意一对顶点间是否存在边</li><li>方便找任一顶点的所有邻接点（有边直接相连的顶点）</li><li>方便计算任一顶点的度（从该点出发的边数为出度，指向该点的边数为入度）</li></ol> 
<ul><li>无向图：对应行列非0元素的个数</li><li>有向图：对应行非0元素的个数是出度，对应列非0元素的个数是入度</li></ul> 
<h5><a id="_5617"></a>邻接矩阵的缺点</h5> 
<ol><li> <p>浪费空间 存稀疏图（点多边少）含有大量无效元素</p> <p>但对于稠密特别是完全图很划算</p> </li><li> <p>浪费时间 统计稀疏图一共又多少边</p> </li></ol> 
<h5><a id="_5625"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/jnu_simba/article/details/8866705">图的存储结构之邻接矩阵 - CSDN</a></p> 
<h4><a id="622%09_5629"></a>6.2.2 邻接表法</h4> 
<h5><a id="_5631"></a>什么是邻接表</h5> 
<p>为了解决邻接矩阵的缺点，邻接表应运而生</p> 
<p>为每一个顶点建立一个单链表存放与他相领的边</p> 
<p><strong>顶点表</strong></p> 
<p>采用<strong>顺序存储</strong>，存放顶点的数据和边表的头指针</p> 
<p><strong>边表（出边表）</strong></p> 
<p>采用<strong>链式存储</strong>，单链表中存放与一个顶点相邻的所有边，一个链表表示一条从该顶点到链表结点顶点的边</p> 
<p><img src="https://images2.imgbox.com/f9/2e/9FL5cBdw_o.png" alt="image-20210326221316303"></p> 
<h5><a id="_5647"></a>邻接表的特点</h5> 
<ol><li>更适用于稀疏图</li><li>无向图：结点的度为该结点边表的长度</li><li>有向图：结点的出度为结点边表的长度，入度要遍历整个邻接表</li><li>邻接表不唯一，边表结点的顺序根据算法和输入的不同可能会不同</li></ol> 
<h5><a id="_5654"></a>邻接矩阵和邻接表的比较</h5> 
<table><thead><tr><th align="center"></th><th align="center">邻接矩阵</th><th align="center">邻接表</th></tr></thead><tbody><tr><td align="center">适用性</td><td align="center">稠密图</td><td align="center">稀疏图</td></tr><tr><td align="center">存储方式</td><td align="center">顺序</td><td align="center">顺序+链式</td></tr><tr><td align="center">判断两顶点间是否存在边</td><td align="center">高效</td><td align="center">低效</td></tr><tr><td align="center">找到某顶点相邻的边</td><td align="center">低效</td><td align="center">高效</td></tr></tbody></table> 
<p>上表中最后一条存疑，邻接矩阵是找到该点然后遍历该行列，邻接表是遍历链表，此处效率应无异</p> 
<h4><a id="623%09_5665"></a>6.2.3 十字链表</h4> 
<h5><a id="_5667"></a>什么是十字链表</h5> 
<p><strong>有向图</strong>的一种链式存储结构</p> 
<p><strong>十字链表等于邻接表加逆邻接表</strong></p> 
<p><img src="https://images2.imgbox.com/0b/b9/rKDJCRjF_o.png" alt="image-20210326221433931"></p> 
<h4><a id="624%09_5675"></a>6.2.4 邻接多重表</h4> 
<p><strong>无向图</strong>的一种链式存储结构</p> 
<p><img src="https://images2.imgbox.com/87/d7/yrr74w1R_o.png" alt="image-20210326221518878"></p> 
<ul><li>mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；</li><li>ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</li><li>ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；</li><li>jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；</li><li>info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权；</li></ul> 
<p>vex代表边的前后结点，link代表与其关联的另一条边</p> 
<p>十字链表和邻接多重表概念较为复杂，需多多理解</p> 
<p>十字链表和邻接多重表可通过一条边去查找任意另一条边，此处可见图的优点与复杂</p> 
<h4><a id="625%09_5699"></a>6.2.5 图的基本操作</h4> 
<pre><code class="prism language-java"><span class="token function">Adjacent</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断图是否存在边&lt;x,y&gt;或(x,y)</span>
<span class="token function">Neighbors</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 列出图G中与结点x邻接的边</span>
<span class="token function">InsertVertex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在图G中插入顶点x</span>
<span class="token function">DeleteVerex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在图G中删除顶点x</span>
<span class="token function">AddEdge</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 若边(x,y)或&lt;x,y&gt;不存在，则向图G中添加该边</span>
<span class="token function">RemoveEdge</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 若边(x,y)或&lt;x,y&gt;存在，则向图G中删除该边</span>
<span class="token function">FirstNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求图G中顶点x的第一个邻接点</span>
<span class="token function">NextNeighbor</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 若图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点，若y是x的最后一个邻接点则返回-1</span>
<span class="token function">Get_edge_value</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取图G中边(x,y)或&lt;x,y&gt;对应的权值v</span>
<span class="token function">Set_edge_value</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置图G中边(x,y)或&lt;x,y&gt;对应的权值v</span>
</code></pre> 
<h4><a id="631%09_5714"></a>6.3.1 广度优先搜索</h4> 
<p>广度优先搜索(Breadth First Search), BFS</p> 
<p><img src="https://images2.imgbox.com/cb/01/2isHRWoi_o.png" alt="image-20210326221822542"></p> 
<p>如上图，入队出队顺序参考数组</p> 
<h5><a id="_5722"></a>伪码</h5> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Vertex V<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    visited<span class="token punctuation">[</span>V<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">Enqueue</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        V <span class="token operator">=</span> <span class="token function">Dequeue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>V 的每个邻接点 W<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>W<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                visited<span class="token punctuation">[</span>W<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token function">Enqueue</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>若有N个顶点，E条边，时间复杂度是</p> 
<ul><li>用邻接表存储图，为O(N+E)</li><li>用邻接矩阵存储图，为[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4gxfuS2z-1618913822548)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]</li></ul> 
<p>每走一步，都要把周围一圈看一下(队列)</p> 
<h4><a id="632%09_5747"></a>6.3.2 深度优先搜索</h4> 
<p>深度优先搜索(depth First Search), DFS</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Vertex V<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    visited<span class="token punctuation">[</span>V<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>V 的每个邻接点 w<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>visited<span class="token punctuation">[</span>W<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">DFS</span><span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>若有N个顶点，E条边，时间复杂度是</p> 
<ul><li>用邻接表存储图，为O(N+E)</li><li>用邻接矩阵存储图，为[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J2LiA7uw-1618913822549)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]</li></ul> 
<p>一直走到死胡同，然后回到上个路口换个方向接着走(递归+回溯)</p> 
<p>BFS和DFS复杂度大体一致，BFS适合大范围查找，DFS适合目标明确</p> 
<h5><a id="_5773"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/24986203" rel="nofollow">搜索思想——DFS &amp; BFS（基础篇）- 知乎</a></p> 
<h4><a id="641%09_5777"></a>6.4.1 最小生成树</h4> 
<h5><a id="_5779"></a>什么是最小生成树</h5> 
<p>对于<strong>带权无向连通图G</strong> = （V, E）,G的所有生成树当中边的权值之和最小的生成树为G的最小生成树(MST)。</p> 
<p><strong>边和权值同时最小</strong></p> 
<p><img src="https://images2.imgbox.com/cc/9b/q5lhWTNv_o.png" alt="image-20210326222110189"></p> 
<h5><a id="Prim_5787"></a>Prim算法</h5> 
<p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖所有顶点</p> 
<p><img src="https://images2.imgbox.com/f7/62/ovSIK1Mx_o.png" alt="image-20210326222715626"></p> 
<ol><li>图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</li><li>在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</li><li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li></ol> 
<p>时间复杂度为O(V平方），适合稠密图</p> 
<h5><a id="Kruskal_5799"></a>Kruskal算法</h5> 
<p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里面</p> 
<p><img src="https://images2.imgbox.com/a3/8d/OESErTZo_o.png" alt="image-20210326222857242"></p> 
<ol><li>把图中的所有边按代价从小到大排序；</li><li>把图中的n个顶点看成独立的n棵树组成的森林；</li><li>按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。</li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol> 
<p>时间复杂度为O(ElogE)，适合稀疏图</p> 
<h5><a id="_5812"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/a2392008643/article/details/81781766">最小生成树的两种方法（Kruskal算法和Prim算法）- CSDN</a></p> 
<h4><a id="642%09_5816"></a>6.4.2 最短路径</h4> 
<h5><a id="_5818"></a>最短路径</h5> 
<p>两个顶点之间带权路径长度最短的路径为最短路径</p> 
<h5><a id="Dijkstra_5822"></a>迪杰斯特拉（Dijkstra）算法</h5> 
<p>迪杰斯特拉算法用于解决单源最短路径</p> 
<h5><a id="_5826"></a>什么是迪杰斯特拉算法</h5> 
<p>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径</p> 
<p>核心思路还是贪心算法，仙人指路：[贪心算法](# 9.2 贪心算法)</p> 
<h5><a id="_5832"></a>实现思路</h5> 
<ol><li>通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</li><li>此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</li><li>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</li></ol> 
<p><img src="https://images2.imgbox.com/d6/10/vSgPFcGx_o.png" alt="image-20210326222941265"></p> 
<p>时间复杂度为O(V的平方)</p> 
<p>当出现负权边会影响该算法的判断，比如上图1到2的权改为-3那么0到2的最短就会变更为0 -&gt; 1 -&gt; 2,因此<strong>迪杰斯特拉算法不适用含有负权边的图</strong></p> 
<hr> 
<h5><a id="Floyd_5846"></a>弗洛伊德（Floyd）算法</h5> 
<p>佛洛依德算法用于解决多源路径</p> 
<h5><a id="_5850"></a>什么是弗洛伊德算法</h5> 
<p>最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转…允许经过1~n号所有顶点进行中转，来<strong>不断动态更新任意两点之间的最短路程</strong>。即求从i号顶点到j号顶点只经过前k号点的最短路程。</p> 
<h5><a id="_5854"></a>实现思路</h5> 
<p>**1，**首先构建邻接矩阵Floyd[n+1] [n+1]，假如现在只允许经过1号结点，求任意两点间的最短路程，很显然Floyd[i] [j] = min{Floyd[i] [j], Floyd[i] [1]+Floyd[1] [j]}，代码如下：</p> 
<p>**2，**接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短距离，在已经实现了从i号顶点到j号顶点只经过前1号点的最短路程的前提下，现在再插入第2号结点，来看看能不能更新更短路径，故只需在步骤1求得的Floyd[n+1] [n+1]基础上，进行Floyd[i] [j] = min{Floyd[i] [j], Floyd[i] [2]+Floyd[2] [j]}；…<br> **3，**很显然，需要n次这样的更新，表示依次插入了1号，2号…n号结点，最后求得的Floyd[n+1] [n+1]是从i号顶点到j号顶点只经过前n号点的最短路程。</p> 
<p><img src="https://images2.imgbox.com/78/54/ilXFm9wN_o.png" alt="image-20210326223020271"></p> 
<h5><a id="_5863"></a>特点</h5> 
<p>Floyd算法适用于APSP(AllPairsShortestPaths)，是一种<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=83500148&amp;ss_c=ssc.citiao.link" rel="nofollow">动态规划算法</a>，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行|V|次<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=453851&amp;ss_c=ssc.citiao.link" rel="nofollow">Dijkstra算法</a>。</p> 
<p>优点：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单</p> 
<p>缺点：时间复杂度高，不适合计算大量数据</p> 
<h5><a id="_5871"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/40338107" rel="nofollow">通俗易懂理解——dijkstra算法求最短路径 - 知乎</a></p> 
<p><a href="https://blog.csdn.net/ytuyzh/article/details/88617987">最短路径模板+解析——（FLoyd算法） - CSDN</a></p> 
<p><a href="https://blog.csdn.net/qibofang/article/details/51594673">图论（二）：图的四种最短路径算法 - CSDN</a></p> 
<h4><a id="643%09_5879"></a>6.4.3 拓扑排序</h4> 
<h5><a id="_5881"></a>什么是拓扑排序</h5> 
<p><strong>有向无环图</strong> 不存在环的图，简称DAG图</p> 
<p><strong>AOV网</strong> 若用一个DAG图表示一个工程，其顶点表示活动，用有向边&lt;v1, vj&gt;表示活动vi先于活动vj进行的传递关系，则将这种DAG称为<strong>顶点表示活动网络</strong>，简称AOV网</p> 
<p><strong>拓扑排序</strong> 对DAG所有顶点的一种排序，使若存在一条从顶点A到顶点B的路径，在排序中B排在A的后面</p> 
<h5><a id="_5889"></a>举例</h5> 
<p><img src="https://images2.imgbox.com/0c/d9/iLModR0h_o.png" alt="image-20210326223244292"></p> 
<p>如图，我想学习boot，那么前面都要学，我想学jsp，那么java要学，<strong>无关联的可任意序列排序，有关联的按照顺序走</strong></p> 
<h5><a id="_5895"></a>思路</h5> 
<ol><li>从DAG图中选择一个没有前驱的顶点并输出</li><li>从图中删除该顶点和以它为起点的边</li><li>重复1，2，直到DAG图为空或当前图中不存在无前驱的顶点为止。后者则说明图中有环。</li></ol> 
<h5><a id="_5901"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/bigsai/p/11489260.html" rel="nofollow">拓扑排序详解与实现 - 博客园</a></p> 
<h4><a id="644%09_5905"></a>6.4.4 关键路径</h4> 
<h5><a id="AOE_5907"></a>AOE网</h5> 
<p>在有向带权图中，以顶点表示事件，以有向边表示活动，以边上权值表示完成该活动的开销，则称这种有向图为<strong>用边表示活动的网络</strong>，简称AOE网</p> 
<p><img src="https://images2.imgbox.com/82/7a/K8izFlxL_o.png" alt="image-20210326223508781"></p> 
<h5><a id="_5913"></a>关键路径</h5> 
<p>从原点到汇点最大路径长度的路径称为<strong>关键路径</strong>，关键路径的活动为<strong>关键活动</strong></p> 
<p><strong>事件的最早发生时间 ve[k]</strong></p> 
<p>根据AOE网的性质，只有进入Vk的所有活动&lt;Vj, Vk&gt;都结束，Vk代表的事件才能发生，而活动&lt;Vj, Vk&gt;的最早结束时间为ve[j]+len&lt;Vj, Vk&gt;。所以，计算Vk的最早发生时间的方法为：</p> 
<p>ve[0] = 0</p> 
<p>ve[k] = max(ve[j] + len&lt;Vj, Vk&gt;)</p> 
<p>举例：v2的最早发生时间 = a1 = 3,v5 = a4 + v2 = 6,如果是多条边则取较大值</p> 
<p><strong>事件的最早发生时间 vl[k]</strong></p> 
<p>vl[k]是指在不推迟整个工期的前提下，事件Vk允许的最迟发生时间。根据AOE网的性质，只有顶点Vk代表的事件发生，从Vk出发的活动&lt;Vk, Vj&gt;才能开始，而活动&lt;Vk, Vj&gt;的最晚开始时间为vl[j] - len&lt;Vk, Vj&gt;。</p> 
<p>逆推最早发生时间即可，注意取最小值</p> 
<p><strong>活动的最早发生时间：ee[i]</strong></p> 
<p>ai由有向边&lt;Vk, Vj&gt;，根据AOE网的性质，只有顶点Vk代表的事件发生，活动ai才能开始，即活动ai的最早开始时间等于事件Vk的最早开始时间。</p> 
<p>弧尾 = 最早发生时间</p> 
<p><strong>活动的最迟发生时间：el[i]</strong></p> 
<p>el[i]是指在不推迟真个工期的前提下，活动ai必须开始的最晚时间。若活动ai由有向边&lt;Vk, Vj&gt;表示，则ai的最晚开始时间要保证事件vj的最迟发生时间不拖后。</p> 
<p>弧头 - 开销(边的权重) = 最迟发生时间</p> 
<p><strong>活动ai的差额d(i) = l(i) - e(i)</strong></p> 
<p><img src="https://images2.imgbox.com/03/09/wf1gNKEV_o.png" alt="image-20210326223546148"></p> 
<p>关键路径：{a2, a5, a7}</p> 
<p><strong>缩短关键路径活动时间可以加快整个工程，但缩短到一定程度关键路径会改变</strong></p> 
<p><strong>当关键活动不唯一时，只有加快的关键活动或者关键活动组合包括在所有的关键路径上才能缩短工期</strong></p> 
<h5><a id="_5955"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/fu_jian_ping/article/details/88962697">图——关键路径 - CSDN</a></p> 
<h3><a id="_5959"></a>第七章</h3> 
<h4><a id="711%09_5961"></a>7.1.1 查找的基本概念</h4> 
<h5><a id="_5963"></a>大概念</h5> 
<p><img src="https://images2.imgbox.com/be/cc/6HwPQWa7_o.png" alt="image-20210326223610151"></p> 
<h5><a id="_5967"></a>什么是查找</h5> 
<p>在数据集合中寻找满足某种条件的数据元素的过程</p> 
<p><strong>查找表</strong></p> 
<p>用于查找的数据集合，由同一种数据类型(或记录)的组成，可以是一个数组或链表等数据类型</p> 
<p>操作：</p> 
<ul><li>查询某个特定的数据元素是否在查找表中</li><li>检索满足条件的某个特定的数据元素的各种属性</li><li>插入一个数据元素</li><li>删除一个数据元素</li></ul> 
<h5><a id="_5982"></a>关键字</h5> 
<p>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字查找，查找结果应该是<strong>唯一的</strong></p> 
<h5><a id="_5986"></a>平均查找长度</h5> 
<p>ASL（Average Search Length），即平均查找长度，在查找运算中，由于所费时间在关键字的比较上，所以把平均需要和待查找值比较的关键字次数称为平均查找长度。</p> 
<p>概念如下图</p> 
<p><img src="https://images2.imgbox.com/7c/31/jve0L7Ex_o.png" alt="image-20210326223736176"></p> 
<p>其中n为查找表中元素个数，Pi为查找第i个元素的概率，通常假设每个元素查找概率相同，Pi=1/n，Ci是找到第i个元素的比较次数。</p> 
<p>一个算法的ASL越大说明时间性能越差，反之亦然。</p> 
<h5><a id="_5998"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/ygsworld/p/10238729.html" rel="nofollow">关于ASL(平均查找长度)的简单总结 - 博客园</a></p> 
<h4><a id="721%09_6002"></a>7.2.1 顺序查找</h4> 
<h5><a id="_6004"></a>什么是顺序查找</h5> 
<p>主要用于在<strong>线性表</strong>中进行查找</p> 
<p><strong>当无须线性表进行线性查找失败时，需要遍历整个线性表</strong></p> 
<h4><a id="722%09_6010"></a>7.2.2 折半查找</h4> 
<h5><a id="_6012"></a>什么是折半查找</h5> 
<p>也叫二分查找，仅适用于<strong>有序的顺序表</strong></p> 
<h5><a id="_6016"></a>思想</h5> 
<p>首先将给定key与表中间的元素相比较，相等则返回该元素，若不等则如下：</p> 
<ul><li>key小于中间元素，查找前半部分</li><li>key大于中间元素，查找后半部分</li></ul> 
<p>重复以上过程，直到找到结果或查找失败</p> 
<h5><a id="_6025"></a>顺序查找和二分查找的区别</h5> 
<p>顺序查找适用于<strong>顺序存储</strong>和<strong>链式存储</strong>，有序无序皆可</p> 
<p>二分查找只适用于<strong>顺序存储</strong>，且要求序列一定有序</p> 
<h4><a id="723%09_6031"></a>7.2.3 分块查找</h4> 
<h5><a id="_6033"></a>什么是分块查找</h5> 
<p>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适用于快速查找</p> 
<h5><a id="_6037"></a>如何分块</h5> 
<p>将查找表分为若干子块。块内的元素无序，但块间是有序的。</p> 
<p>建立索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。<br> <img src="https://images2.imgbox.com/0e/c6/UFh5sILs_o.png" alt="image-20210326223816592"></p> 
<h4><a id="731%09B_6044"></a>7.3.1 B树</h4> 
<h5><a id="B_6046"></a>什么是B树</h5> 
<p>又称多路平衡查找树，B树中所有结点的<strong>孩子结点数</strong>的最大值称为B数的阶</p> 
<h5><a id="_6050"></a>概念</h5> 
<p>一颗m阶的B树定义如下：</p> 
<ul><li>每个结点最多有m-1个关键字。</li><li>根结点最少可以只有1个关键字。</li><li>非根结点至少有Math.ceil(m/2)-1个关键字。</li><li>每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。</li></ul> 
<h5><a id="_6060"></a>查找</h5> 
<ol><li>在B树中找结点（磁盘）</li><li>在结点中找关键字（内存）</li></ol> 
<p><img src="https://images2.imgbox.com/30/1b/hk9gkXrV_o.png" alt="image-20210326223914808"></p> 
<h5><a id="_6067"></a>插入</h5> 
<ol><li> <p>定位</p> <p>查找插入该关键字的位置，既<strong>最底层中的某个非叶子结点</strong></p> </li><li> <p>插入</p> <p>若插入后不会破坏B树的定义，则直接插入即可</p> <p>若会破坏B树的定义，则进行分裂操作：</p> <p>分裂：</p> 
  <ol><li>插入后的结点中间位置关键字并入父结点</li><li>左侧结点留在原地，右侧结点放入新结点</li><li>如果父节点关键字数量超出范围，则继续向上分裂，直到符合要求为止、</li></ol> </li></ol> 
<p><strong>常规插入</strong></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ikqudFA2-1618913822559)(C:%5CUsers%5CMOCHEN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210326224746455.png)]</p> 
<p><strong>分裂插入</strong></p> 
<p>插入前</p> 
<p><img src="https://images2.imgbox.com/7e/93/8MZotgZI_o.png" alt="image-20210326224125064"></p> 
<p>插入后</p> 
<p><img src="https://images2.imgbox.com/3a/ca/nlHtYLNO_o.png" alt="image-20210326224201145"></p> 
<h5><a id="_6099"></a>删除</h5> 
<ol><li> <p>直接删除</p> <p>若删除该结点不破坏B树定义，则直接删除</p> </li><li> <p>兄弟借</p> <p>若删除后破坏B树定义，则向兄弟借：</p> 
  <ol><li>将父结点左（右）侧结点拉过来</li><li>将左（右）兄弟拉到父结点</li></ol> </li><li> <p>兄弟不借</p> <p>若左右兄弟都只有一个关键字，那就合并父结点</p> 
  <ol><li>父结点合为兄弟结点</li><li>若条件不满足，重复兄弟借与不借的操作</li></ol> </li><li> <p>终端结点（最后一层非叶子结点）</p> <p>如果删除的是非终端结点，则进行以下操作：</p> 
  <ol><li> <p>替换</p> <p>找到它对应的关键字的终端结点，替换删除即可</p> </li><li> <p>合并</p> <p>如果它下面只有两个结点，直接合并结点然后删除即可</p> </li></ol> </li></ol> 
<p><strong>兄弟借</strong></p> 
<p>借之前</p> 
<p><img src="https://images2.imgbox.com/dc/e8/OY8hIDvq_o.png" alt="image-20210326225028916"></p> 
<p>借之后</p> 
<p><img src="https://images2.imgbox.com/54/dc/ns2qgLUC_o.png" alt="image-20210326225401801"></p> 
<p><strong>兄弟不借</strong></p> 
<p>合并前</p> 
<p><img src="https://images2.imgbox.com/5d/e8/YiycwXBR_o.png" alt="image-20210326225434029"></p> 
<p>合并后</p> 
<p><img src="https://images2.imgbox.com/02/cf/gqrDhRCt_o.png" alt="image-20210326225516102"></p> 
<p><strong>终端结点 - 替换</strong></p> 
<p>如下图，33 和 32 替换，然后删除33</p> 
<p><img src="https://images2.imgbox.com/4f/a9/P0igRIvG_o.png" alt="image-20210326225625496"></p> 
<p><strong>终端结点 - 合并</strong></p> 
<p>如下图，合并21和24并指向30，删除23</p> 
<p><img src="https://images2.imgbox.com/bf/c2/S1e3ZISt_o.png" alt="image-20210326225809420"></p> 
<h5><a id="B_6163"></a>B树的特点</h5> 
<p>优点：</p> 
<p>Ｂ树出现是因为磁盘ＩＯ。ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。</p> 
<p>常规的二叉树磁盘IO效率很低，比如我找个数需要访问h次，为了减少IO的操作就需要最大程度降低树的高度，将一个瘦长的树变成矮胖的树，因此有了B树</p> 
<p>缺点：</p> 
<p>难</p> 
<h5><a id="B_6175"></a>B树的应用</h5> 
<p>B树常应用于文件系统和部分数据库索引，以及MongoDB</p> 
<h5><a id="_6179"></a>参考内容</h5> 
<p><a href="https://www.jianshu.com/p/a858bb15cbf0" rel="nofollow">B树详解 - 简书</a></p> 
<p><a href="https://blog.csdn.net/kking_edc/article/details/108450652">B树与B+树 - CSDN</a></p> 
<p><a href="https://blog.csdn.net/sinat_36118365/article/details/103648782">漫画 B树 B-树 - CSDN</a></p> 
<h4><a id="732%09B_6187"></a>7.3.2 B+树</h4> 
<h5><a id="_6189"></a>概念</h5> 
<ol><li> <p>根结点至少有两个孩子。</p> </li><li> <p>每个中间节点都至少包含<code>ceil(m / 2)</code>个孩子，最多有m个孩子。</p> </li><li> <p>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。</p> </li><li> <p>所有的叶子结点都位于同一层。</p> </li><li> <p>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p> </li></ol> 
<h5><a id="_6201"></a>图示</h5> 
<p><img src="https://images2.imgbox.com/44/4a/tlByieL2_o.png" alt="image-20210326225935387"></p> 
<h5><a id="BB_6205"></a>B树与B+树的区别</h5> 
<ol><li> <p>B+树中，具有n个关键字的结点值含有n棵子树，既每个关键字对应一颗子树</p> <p>B树中，具有n个关键字的结点值含有n棵子树</p> </li><li> <p>B+树中，非叶结点只保存索引，所有信息存放在叶节点中</p> <p>B树中，每个结点保存一个信息</p> </li><li> <p>B+树中，叶结点包含全部关键字，非叶结点中出现的关键字也会出现在叶结点中</p> <p>B树中，叶结点包含的关键字和其他结点不重复</p> </li></ol> 
<h4><a id="741%09_6219"></a>7.4.1 散列表的基本概念</h4> 
<h5><a id="_6221"></a>散列函数</h5> 
<p>一个把从查找表中的关键字映射成该关键字对应的地址的函数</p> 
<h5><a id="_6225"></a>散列表</h5> 
<p>根据关键字而直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系</p> 
<h5><a id="_6229"></a>冲突</h5> 
<p>散列函数可能会把多个不同的关键字映射到同一地址下的情况</p> 
<h4><a id="742744%09_6233"></a>7.4.2~7.4.4 散列函数的构造方法和冲突处理</h4> 
<h5><a id="_6235"></a>要求</h5> 
<ol><li>散列函数的定义域必须包含全部需要存储的关键字，而值域则依赖于散列表的大小和地址范围</li><li>散列函数计算出来的地址应该能等概率，均匀的分布在整个地址空间中，最大程度减少冲突的发生</li><li>散列函数应尽量简单，能在较短时间内计算出任一关键字对应的散列地址</li></ol> 
<h5><a id="_6241"></a>方法</h5> 
<p><strong>直接定址法</strong></p> 
<p>直接取关键字的某个线性函数值为散列地址</p> 
<p>Hash(key) = a * key + b</p> 
<p>其中a,b为常数</p> 
<p><strong>方法简单，不会产生冲突，若关键字分布不连续则会浪费空间</strong></p> 
<p><strong>除留取余法</strong></p> 
<p>假定散列表表长为m，取一个不大于m但最接近或等于m的质数p</p> 
<p>Hash(key) = key % p</p> 
<p><strong>选好p是关键，可以减少冲突</strong></p> 
<p><img src="https://images2.imgbox.com/b2/3f/AFSO7gqM_o.png" alt="image-20210326230054737"></p> 
<p><strong>数字分析法</strong></p> 
<p><img src="https://images2.imgbox.com/4c/81/5JIJDzzI_o.png" alt="image-20210326230121635"></p> 
<p>前八位相同，取后四位</p> 
<p><strong>适用于关键字已知的集合，若更换关键字则需要重新构造散列函数</strong></p> 
<p><strong>平方取中法</strong></p> 
<p>取关键字的平方值的中间几位作为散列地址</p> 
<p><strong>适用于关键字的每位取值不均匀或小于散列地址所需要的位数</strong></p> 
<p><strong>折叠法</strong></p> 
<p>将关键字分割成位数相同的几部分，然后将这几部分相加作为散列地址</p> 
<p><strong>适用于关键字的位数多，而且关键字中的每位上数字分布大致均与</strong></p> 
<h5><a id="_6283"></a>开放定址法</h5> 
<p>是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放</p> 
<p>Hi = (H(key) + di) % m</p> 
<p>i = 0,1,2,…,k(k &lt;= m - 1);</p> 
<p>m为散列表表长</p> 
<p>di为增量序列</p> 
<p><strong>如何计算增量序列</strong></p> 
<p><strong>线性探查法</strong></p> 
<p>既 di = 0,1,2,…,k</p> 
<p><strong>平方探测法</strong></p> 
<p>既 di = 0平方，1平方，-1平方，2平方，-2平方，…,k平方，-k平方，其中k &lt;= m / 2</p> 
<p>避免堆积问题，缺点是不能探测到散列表上的所有单元</p> 
<p><strong>再散列法</strong></p> 
<p>既 di = i * Hash2(key)</p> 
<p><strong>伪随机序列法</strong></p> 
<p>既 di = 伪随机序列</p> 
<p><strong>开放定址法不能随便删除某个元素</strong></p> 
<h5><a id="_6317"></a>拉链法（重点）</h5> 
<p>把所有同义词存放在一个线性链表中，这个线性链表由地址唯一表示，既散列表中每个单元存放该链表头指针</p> 
<p>数组每个成员包括一个指针，指向一个数组</p> 
<p><img src="https://images2.imgbox.com/84/4f/cqCJCWDw_o.png" alt="image-20210326230426665"></p> 
<p><strong>拉链法适用于经常进行插入和删除的情况</strong></p> 
<h5><a id="_6327"></a>查找效率</h5> 
<p>散列函数，处理冲突的方法和填装因子</p> 
<p><strong>填装因子</strong></p> 
<p>一般记为阿尔法，表示表的装满程度</p> 
<p><img src="https://images2.imgbox.com/34/10/lZhmlEVL_o.png" alt="image-20210326230509448"></p> 
<p><strong>散列表的平均查找长度依赖于散列表的填装因子</strong></p> 
<h5><a id="_6339"></a>散列表的特点</h5> 
<p>和数组以及链表对比：</p> 
<table><thead><tr><th align="center"></th><th align="center">查找</th><th align="center">增删</th></tr></thead><tbody><tr><td align="center">数组</td><td align="center">快</td><td align="center">慢</td></tr><tr><td align="center">链表</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">散列表</td><td align="center">快</td><td align="center">快</td></tr></tbody></table> 
<p><strong>优点</strong></p> 
<p>接近O(1)的时间复杂度，碾压一切渣渣</p> 
<p><strong>缺点</strong></p> 
<p>因为是<strong>基于数组</strong>的，所以填装因子越大性能越低，因此<strong>必须要清楚表中将要存储多少数据</strong></p> 
<h5><a id="_6357"></a>概念</h5> 
<p><img src="https://images2.imgbox.com/9d/31/gxhixwe3_o.png" alt="image-20210326230228176"></p> 
<h5><a id="_6361"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/yyyljw/article/details/80903391">哈希表（散列表）原理详解 - CSDN</a></p> 
<h3><a id="_6365"></a>第八章</h3> 
<h4><a id="81%09_6367"></a>8.1 排序的基本概念</h4> 
<h5><a id="_6369"></a>大概念</h5> 
<p><img src="https://images2.imgbox.com/8f/ee/xZi1Udr8_o.png" alt="image-20210326230653534"></p> 
<h5><a id="_6373"></a>排序</h5> 
<p>重新定义表中的元素，使表中的元素按照关键字递增或递减</p> 
<h5><a id="_6377"></a>排序算法的稳定性</h5> 
<p>排序后两个相同的元素不发生变动，则为稳定，反之则为不稳定</p> 
<p>如下图，淡蓝色小朋友排序后仍在深蓝色小朋友之前，则这个算法就是稳定的</p> 
<p><img src="https://images2.imgbox.com/26/ad/XaboGHXA_o.png" alt="image-20210326230748619"></p> 
<p><strong>稳定性只是算法的性质，无法评定算法的优劣</strong></p> 
<h5><a id="_6387"></a>内部排序与外部排序</h5> 
<p><strong>内部排序</strong></p> 
<p>指在排序期间全部放在内存中排序</p> 
<p><strong>外部排序</strong></p> 
<p>指在排序期间无法全部放在内存中，在排序过程中根据要求不断的在内，外存中移动</p> 
<p>此处仅探讨内部排序</p> 
<p><strong>时空复杂度决定内部排序算法的性能</strong></p> 
<h4><a id="821%09_6401"></a>8.2.1 直接插入排序</h4> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/34/93/cz3DgsmP_o.png" alt="img"></p> 
<h5><a id="_6407"></a>实现思路</h5> 
<ol><li>从第二个参数开始往前比较，如果上个参数比当前参数大则交换位置</li><li>继续对比，直到前面没有比自身更大的数</li><li>重复第二步，直到全部数据排完</li></ol> 
<h5><a id="_6413"></a>实现代码</h5> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 插入排序
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        InsertSort is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">insSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 每次将当前数字与前面所有位数比较，前面大则交换，否则看下一个数字
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrs<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> temp <span class="token punctuation">;</span>
                    temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                    j<span class="token operator">--</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">/**
     * 1. 从第二个数字开始遍历，将当前数字放入数组第一位当作哨兵使用
     * 2. 从当前数字往前遍历，只要大于哨兵就往前移一位
     * 3. 将哨兵赋给下一位，完成交换操作
     * 4. 重复以上操作，直到数据完成排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insSortSent</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arrs<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 将当前数组扩容一位，保证第一位是哨兵</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> newArrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                newArrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            newArrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 归还结果</span>
        arrs <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此处while可以改成for，for版本代码更简洁，用while更清晰故使用while</p> 
<p>教材代码虽然简洁但是偏难，需多多理解</p> 
<p><img src="https://images2.imgbox.com/66/70/BSqagWLh_o.png" alt="image-20210326230821707"></p> 
<h5><a id="_6481"></a>概念</h5> 
<p>时间复杂度为[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pSxbvolo-1618913822579)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]，可采用顺序存储和链式存储</p> 
<h5><a id="_6485"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/coding-996/p/12275710.html" rel="nofollow">插入排序 - 沐雨橙风~~ - 博客园</a></p> 
<h4><a id="822%09_6489"></a>8.2.2 折半插入排序</h4> 
<h5><a id="_6491"></a>概念</h5> 
<p>二分查找 + 插入排序</p> 
<p>减少了比较次数，但是元素的移动次数不变。平均时间复杂度为O(n^2)；空间复杂度为O(1)；是稳定的排序算法。</p> 
<h5><a id="_6497"></a>实现代码</h5> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 折半插入排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bInsSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newArrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arrs<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 将当前数组扩容一位，保证第一位是哨兵</span>
        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>newArrs<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                    low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                newArrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            newArrs<span class="token punctuation">[</span>high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newArrs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 归还结果</span>
        arrs <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>newArrs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newArrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>同上，此处也可使用非哨兵模式，同步教材代码故使用哨兵模式</p> 
<h5><a id="_6534"></a>时间复杂度下界</h5> 
<p>对于下标i &lt; j, 如果A[i] &gt; A[j], 则称(i, j)是一对<strong>逆序对</strong></p> 
<p>只要后面的数字比当前位数小，就是逆序对，交换元素的排序算法本质就是消除逆序对</p> 
<p>任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为**[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PaRXUe8e-1618913822579)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]**</p> 
<h5><a id="_6542"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/weixin_42245157/article/details/80458542">排序----折半插入排序 - CSDN</a></p> 
<p><a href="https://blog.csdn.net/guoweimelon/article/details/50904206">经典排序算法（4）——折半插入排序算法详解 - CSDN</a></p> 
<h4><a id="823%09_6548"></a>8.2.3 希尔排序</h4> 
<h5><a id="_6550"></a>什么是希尔排序</h5> 
<p>希尔排序是一种改进后的插入排序，也称<strong>缩小增量排序</strong>。</p> 
<p>按照<strong>增量序列</strong>进行插入排序，最后一步增量序列为1</p> 
<p>如下图，第一个按照五个间隔排序，第二次按照三个间隔排序，最后一次按照一个间隔排序，这里的5，3，1就是增量序列</p> 
<p><img src="https://images2.imgbox.com/b6/84/ltDaZPJx_o.png" alt="image-20210326231244579"></p> 
<h5><a id="_6560"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 希尔排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dk <span class="token operator">=</span> arrs<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> dk <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> dk <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dk <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> dk <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>i <span class="token operator">-</span> dk<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">;</span> i <span class="token operator">-=</span> dk<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i <span class="token operator">-</span> dk<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>思路很简单，就是插入排序外面套一层增量序列的循环</p> 
<h5><a id="_6583"></a>概念</h5> 
<p>希尔排序的最坏时间复杂度依然是[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3BH3e77n-1618913822581)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)]，但是往往并达不到这种程度</p> 
<p>采用优化的增量序列可以最大程度减少时间复杂度，比如Hibbard等等</p> 
<h5><a id="_6589"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/chengxiao/p/6104371.html" rel="nofollow">图解排序算法(二)之希尔排序 - 博客园</a></p> 
<h4><a id="831%09_6593"></a>8.3.1 冒泡排序</h4> 
<h5><a id="_6595"></a>什么是冒泡排序</h5> 
<p>类似于冒泡，大的数沉下去，小的数浮上来，所以叫冒泡排序</p> 
<p>每次遍历将最大的数字移到末尾</p> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/23/e5/8bNKiHq9_o.gif" alt="img"></p> 
<h5><a id="_6605"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 冒泡排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arrs<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_6625"></a>概念</h5> 
<p>思路就是比较，交换，该算法过于经典不多描述</p> 
<h5><a id="_6629"></a>参考内容</h5> 
<p><a href="https://www.jianshu.com/p/1458abf81adf" rel="nofollow">排序-冒泡排序 - 简书</a></p> 
<h4><a id="832%09_6633"></a>8.3.2 快速排序</h4> 
<h5><a id="_6635"></a>什么是快速排序</h5> 
<p>快排的性能在所有排序算法里面是最好的，数据规模越大快速排序的性能越优。快排在极端情况下会退化成 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-l5TMZRWU-1618913822582)(https://www.zhihu.com/equation?tex=O%28n%5E%7B2%7D%29)] 的算法，因此<strong>假如在提前得知处理数据可能会出现极端情况的前提下</strong>，可以选择使用较为稳定的归并排序。</p> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/52/eb/uJTJKpA1_o.gif" alt="img"></p> 
<h5><a id="_6643"></a>实现思路</h5> 
<ul><li>选择A中任意一个元素pivot,该元素作为基准</li><li>将小于基准的元素移到左边，大于基准的移到右边</li><li>A被pivot分为两部分，继续对剩下的两部分做同样的处理</li><li>重复以上操作，直到数据排序完成</li></ul> 
<h5><a id="_6650"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 快速排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> high<span class="token punctuation">;</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> i <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token operator">--</span>j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token operator">++</span>i<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token function">quickSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> low<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">quickSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>更标准的写法应该是两个方法，一个拿基准，一个递归排序，此处图简洁不做实现</p> 
<h5><a id="_6681"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/93129029" rel="nofollow">排序–快速排序 - 知乎</a></p> 
<p><a href="https://blog.csdn.net/nrsc272420199/article/details/82587933">快速排序—(面试碰到过好几次) - CSDN</a></p> 
<h4><a id="841%09_6687"></a>8.4.1 直接选择排序</h4> 
<h5><a id="_6689"></a>什么是选择排序</h5> 
<p>每次从无序中选出最小元（最小关键字），将最小元放入有序的后面</p> 
<p>和插入不同，插入是交换有序序列，选择是追加到有序后面</p> 
<p>和冒泡大抵相同，不过<strong>冒泡是每次交换n-1次，选择是交换两次</strong></p> 
<p><img src="https://images2.imgbox.com/7a/65/PpqZ8oF0_o.png" alt="image-20210326231653930"></p> 
<h5><a id="_6699"></a>实现代码</h5> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * 选择排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 交换</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arrs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arrs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>一次排序将一个元素放置到最终的位置上</strong></p> 
<h4><a id="842%09_6726"></a>8.4.2 堆排序</h4> 
<h5><a id="_6728"></a>什么是堆排序</h5> 
<p>堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p> 
<h5><a id="_6732"></a>堆</h5> 
<p><strong>堆是具有以下性质的完全二叉树：</strong></p> 
<p><strong>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；</strong></p> 
<p><strong>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</strong></p> 
<p>如下图：</p> 
<p><img src="https://images2.imgbox.com/1d/9f/yvqoZoHs_o.png" alt="image-20210326232204604"></p> 
<p><img src="https://images2.imgbox.com/0c/25/xjMP0h23_o.png" alt="image-20210326232251795"></p> 
<h5><a id="_6746"></a>实现代码</h5> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 堆排序
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">heapSort</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 堆排序
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 构建大顶堆</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arrs<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arrs<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2. 调整堆结构 + 交换堆顶元素与末尾元素</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> arrs<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arrs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 调整大顶堆
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> k <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> arrs<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arrs<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arrs<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> temp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> k<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        arrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 交换元素
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrs<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> arrs<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arrs<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> arrs<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
        arrs<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_6809"></a>概念</h5> 
<ol><li> <p>将无序序列构建成一个大顶堆（小顶堆同理）</p> 
  <ol><li>将每个子树的最大值调整为父节点</li><li>重复上一步，直到根节点为最大值，堆构建完成</li></ol> </li><li> <p>将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端</p> </li><li> <p>重新调整结构，使其满足堆定义，然后重复第二步，反复执行调整+交换步骤，直到整个序列有序</p> </li></ol> 
<h5><a id="_6819"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" rel="nofollow">图解排序算法(三)之堆排序 - 博客园</a></p> 
<h4><a id="851%09_6823"></a>8.5.1 归并排序</h4> 
<h5><a id="_6825"></a>什么是归并排序</h5> 
<p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略</p> 
<p>分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之</p> 
<p><strong>动图演示</strong></p> 
<p><img src="https://images2.imgbox.com/7a/5b/1donGMmG_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/4c/45/q9hKHWTp_o.png" alt="image-20210326232336193"></p> 
<h5><a id="_6837"></a>代码实现</h5> 
<pre><code class="prism language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>

<span class="token comment">/**
 * @Description: 归并排序
 * @Author: MoChen
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 归并排序
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左边归并排序，使得左子序列有序</span>
            <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右边归并排序，使得右子序列有序</span>
            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将两个有序子数组合并操作</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 合并有序子列
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment">//左序列指针</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//右序列指针</span>
        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//临时数组指针</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//将左边剩余元素填充进temp中</span>
            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//将右序列剩余元素填充进temp中</span>
            temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//将temp中的元素全部拷贝到原数组中</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h5><a id="_6896"></a>思路</h5> 
<p>上面两个图示已经比较明显，此处不做思路总结</p> 
<h5><a id="_6900"></a>参考内容</h5> 
<p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" rel="nofollow">图解排序算法(四)之归并排序 - 博客园</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/124356219" rel="nofollow">【算法】排序算法之归并排序 - 知乎</a></p> 
<h4><a id="852__6906"></a>8.5.2 基数排序</h4> 
<h5><a id="_6908"></a>什么是基数排序</h5> 
<p>不同于以往的排序，基数排序无需进行比较或者交换，他通过<strong>分配和收集</strong>进行排序</p> 
<h5><a id="_6912"></a>思路</h5> 
<p>依照位数进行排序，比如三位数先进行个分位分配，然后十分位，百分位</p> 
<p>可以这么理解，先对最后一位进行排序，然后往前一位，直到第一位，第一位排序完成即可</p> 
<p><img src="https://images2.imgbox.com/fc/da/qYUavcux_o.png" alt="image-20210326232509514"></p> 
<p>此章非重点不多做解释，感兴趣可去参考内容了解</p> 
<h5><a id="_6922"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/lemon_tree12138/article/details/51695211">排序算法系列：基数排序 - CSDN</a></p> 
<p><a href="https://www.cnblogs.com/yimeixiaobai1314/p/7932254.html" rel="nofollow">基数排序 顺序实现与链式实现</a></p> 
<h4><a id="86%09_6928"></a>8.6 内部排序算法的比较及应用</h4> 
<p><img src="https://images2.imgbox.com/b5/da/M60DSzUL_o.png" alt="image-20210326232440457"></p> 
<p><img src="https://images2.imgbox.com/8f/52/49w9ZwgW_o.png" alt="image-20210326232546798"></p> 
<h5><a id="_6934"></a>考虑因素</h5> 
<p>综合考虑：元素数量，元素大小，关键字结构及分布，稳定性，存储结构，辅助空间</p> 
<ol><li>若n较小(n&lt;=50)时，可采用直接插入排序或简单选择排序，若n较大时，则采用快排，堆排或归并排序</li><li>若n很大，关键字位数较小且可分解，采用基数排序</li><li>当文件的n个关键字随机分布，任何借助于比较的排序，至少需要O(nlog2n)的时间</li><li>若初始基本有序，则采用直接插入或冒泡排序</li><li>当记录元素较大，应避免大量的移动的排序算法，尽量次啊用链式存储</li></ol> 
<p><strong>每种排序算法都有它存在的意义，实际应用中应根据实际情况选择使用那种排序</strong></p> 
<h4><a id="871872%09_6946"></a>8.7.1~8.7.2 外部排序的算法</h4> 
<h5><a id="_6948"></a>什么是外部排序</h5> 
<p>对内存中的数据进行排序叫内部排序，内存外的数据排序即为外部排序</p> 
<p>外部排序通常采用<strong>归并排序</strong></p> 
<h5><a id="_6954"></a>举例</h5> 
<p>内存中只能放三个数，现在有十二个数，如何实现排序？</p> 
<p>利用归并排序的思想，先分成四分进行依次排序，然后进行合并</p> 
<p><img src="https://images2.imgbox.com/0a/00/TAiUPkRO_o.png" alt="img"></p> 
<p>两两合并子串，得到两个长度为六的子串，然后进行最后一次合并：</p> 
<p><img src="https://images2.imgbox.com/47/76/U69HhPF7_o.png" alt="img"></p> 
<h5><a id="_6966"></a>时间复杂度</h5> 
<p>外部排序的时间 = 内部排序的时间 + 外存读写时间 + 内部排序归并的时间</p> 
<h4><a id="873%09_6970"></a>8.7.3 失败树</h4> 
<h5><a id="_6972"></a>什么是失败树</h5> 
<p>树形选择排序的一种变体，可视为一颗完全二叉树</p> 
<p>每个叶结点存放各归段在归并过程中参加比较的记录，内部结点用来记忆左右子树中的失败者，胜利者则向上继续比较，直到根节点</p> 
<h4><a id="874%09_6978"></a>8.7.4 置换-选择排序</h4> 
<h5><a id="_6980"></a>思路</h5> 
<p>设初始待排序文件为FI，初始归并段位FO,内存为WA,可容纳w个记录</p> 
<ol><li>从FI中输入w个记录到WA</li><li>从WA中选出最小值，输出到FO</li><li>从FI中重新读入一个值，重复第二步操作</li><li>重复2~3,直到选不出最小值，此处得到第一个归并段</li><li>重复2~4，直到WA为空，得到所有初始归并段</li></ol> 
<h5><a id="_6990"></a>示例</h5> 
<p>如下图所示，先进入三个数，最小值05给出去同事下一个数44进来，然后挑选比05大的第一个数17进来，重复操作知道56，后面没有最小值，此时得到第一个归并段；然后重复上述操作即可</p> 
<p><img src="https://images2.imgbox.com/9d/67/9zEORHUN_o.png" alt="image-20210326233222889"></p> 
<h4><a id="875%09_6996"></a>8.7.5 最佳归并树</h4> 
<p>在上一章的基础上，将归并树转化为哈夫曼树，即为最佳归并树</p> 
<p><img src="https://images2.imgbox.com/8e/36/Pw1lWQA7_o.png" alt="image-20210326233305663"></p> 
<p>如上图，该归并树IO次数为2 * WPL = 484</p> 
<p><img src="https://images2.imgbox.com/fa/54/eY7Gm9ng_o.png" alt="image-20210326233416271"></p> 
<p>该树IO次数位 2 * WPL = 446，所以称为最佳归并树</p> 
<p><strong>当叶子结点不够时，增加权值为0的结点用来构造哈夫曼树</strong></p> 
<h5><a id="_7010"></a>总结</h5> 
<p>可使用多路归并，最优为置换选择</p> 
<h5><a id="_7014"></a>参考内容</h5> 
<p><a href="https://www.sohu.com/a/258751244_818692" rel="nofollow">【漫画】什么是外部排序？ - 搜狐</a></p> 
<p><a href="https://www.cnblogs.com/LUO77/p/5838206.html" rel="nofollow">外部排序&amp;多路归并排序 - 博客园</a></p> 
<h3><a id="___7020"></a>第九章 - 补充</h3> 
<h4><a id="91__7022"></a>9.1 红黑树</h4> 
<h5><a id="_7024"></a>什么是红黑树</h5> 
<p>为了解决<strong>二叉查找树多次单侧插入新节点导致的不平衡</strong>，红黑树应运而生</p> 
<p>红黑树基于二叉查找树实现，它具有以下特点：</p> 
<ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ol> 
<h5><a id="_7036"></a>红黑树的优点</h5> 
<p>正是因为有了上述繁琐的规则限制，才保证了红黑树的自平衡。<strong>红黑树从根到叶子的最长路径不会超过最短路径的2倍。</strong></p> 
<h5><a id="_7040"></a>红黑树的调整</h5> 
<p>当插入或删除节点的时候，有可能会打破规则，这个时候就需要根据情况做出调整，以此来维持规则</p> 
<p>调整有两种方法，<strong>变色</strong>和<strong>旋转</strong>，而旋转又分为<strong>左旋转</strong>和<strong>右旋转</strong></p> 
<h5><a id="_7046"></a>变色</h5> 
<p>变色就是字面意思变色</p> 
<h5><a id="_7050"></a>旋转</h5> 
<h6><a id="_7052"></a>左旋转</h6> 
<p>逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子</p> 
<p>Y变成爹，X变成儿子，代价是左腿给X</p> 
<p><img src="https://images2.imgbox.com/14/c6/S7Ieu81T_o.png" alt="img"></p> 
<h6><a id="_7060"></a>右旋转</h6> 
<p>顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子</p> 
<p><img src="https://images2.imgbox.com/3c/74/wDTq38PQ_o.png" alt="img"></p> 
<h5><a id="_7066"></a>举例</h5> 
<p><img src="https://images2.imgbox.com/49/ad/VeElmLVl_o.png" alt="img"></p> 
<p>如上图所示，该情况打破了规则4，解决方案如下：</p> 
<h6><a id="_7072"></a><strong>变色</strong></h6> 
<ol><li>22变为黑色</li><li>25变为红色</li><li>27变为黑色</li></ol> 
<p><img src="https://images2.imgbox.com/c9/b0/xDFBcYl6_o.png" alt="img"></p> 
<h6><a id="_7080"></a>旋转</h6> 
<p>此时变色已经无法解决问题了，就需要用到旋转</p> 
<ol start="4"><li>13和17进行左旋转</li><li>13变为红色，17变为黑色</li></ol> 
<p><img src="https://images2.imgbox.com/21/e9/l1n4Mi67_o.png" alt="img"></p> 
<p>此时并没有结束，路径(17 -&gt; 8 -&gt; 6 -&gt; NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5，我们继续操作：</p> 
<ol start="6"><li>13和8进行右旋转</li><li>8，15变为红色，13变为黑色</li></ol> 
<p>结果</p> 
<p><img src="https://images2.imgbox.com/ac/4a/DzKfmUp1_o.png" alt="img"></p> 
<h5><a id="_7098"></a>参考内容</h5> 
<p><a href="https://blog.csdn.net/qq_36610462/article/details/83277524">面试常问：什么是红黑树？- CSDN</a></p> 
<h4><a id="92__7102"></a>9.2 贪心算法</h4> 
<p>顾名思义，贪心算法总是做出<strong>当前看来最好的选择</strong>，也就是说贪心算法<strong>并不从整体最优考虑</strong>，它所作出的选择只是在某种意义上的<strong>局部最优选择</strong>。</p> 
<h5><a id="_7106"></a>思路</h5> 
<ol><li>把问题分解成若干个问题</li><li>求出每个子问题的最优解</li><li>将每个局部最优解合并，得到结果的最优解</li></ol> 
<p><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong></p> 
<p>我也不太会，看漫画吧，漫画比较详细</p> 
<h5><a id="_7116"></a>参考内容</h5> 
<p><a href="https://zhuanlan.zhihu.com/p/76164082" rel="nofollow">漫画：五分钟学会贪心算法 - 知乎</a></p> 
<p><a href="https://www.jianshu.com/p/ab89df9759c8" rel="nofollow">五大常用算法之一：贪心算法 - 简书</a></p> 
<h3><a id="_7122"></a>总结</h3> 
<h5><a id="_7124"></a>后言</h5> 
<p>数据结构更多是一种思想，非算法从业者或考研可不做重点学习</p> 
<p>既然说了是思想，就要明白为什么学这个，期望掌握什么，多思考，多code，才是出路</p> 
<p><strong>墨尘 2021年2月1日</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2606df1c2fd801e5b47327ca41bf41ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">同源政策（same-origin policy）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e193fe7dfa6a3f59b23d677d96e78fb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python学习第三天_条件分支与循环</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>