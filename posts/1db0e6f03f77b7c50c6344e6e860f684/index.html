<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的Stream流收集器 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的Stream流收集器" />
<meta property="og:description" content="目录
1、归约和汇总
2、分组
3、分区
4、理解收集器接口
Java 中 Stream 流用来帮助处理集合，类似于数据库中的操作。
在 Stream 接口中，有一个抽象方法 collect，你会发现 collect 是一个归约操作（高级规约），就像 reduce 一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。具体的做法可以通过Collector 接口来定义。// collect和reduce都是Stream接口中的汇总方法，collect方法接收一个Collector(收集器)作为参数
收集器(Collector)非常有用，Collector 接口中方法的实现决定了如何对流执行归约操作。//收集器用来定义收集器如何收集数据
一般来说，Collector 会对元素应用一个转换函数，并将结果累积在一个数据结构中，从而产生这一过程的最终输出。
Collectors 实用类提供了很多静态工厂方法，可以方便地创建常见收集器的实例，所以只要拿来用就可以了。最直接和最常用的收集器比如 toList、toSet、toMap 等静态方法。
1、归约和汇总 使用 Collectors 进行规约和汇总，比如统计汇总，查找最大值和最小值，拼接字符串等。
本节示例会使用到如下代码：
public class Dish { private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) { this.name = name; this.vegetarian = vegetarian; this.calories = calories; this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/1db0e6f03f77b7c50c6344e6e860f684/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-22T14:54:16+08:00" />
<meta property="article:modified_time" content="2023-12-22T14:54:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的Stream流收集器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB" rel="nofollow">1、归约和汇总</a></p> 
<p id="2%E3%80%81%E5%88%86%E7%BB%84-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%88%86%E7%BB%84" rel="nofollow">2、分组</a></p> 
<p id="3%E3%80%81%E5%88%86%E5%8C%BA-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%88%86%E5%8C%BA" rel="nofollow">3、分区</a></p> 
<p id="4%E3%80%81%E7%90%86%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E7%90%86%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8%E6%8E%A5%E5%8F%A3" rel="nofollow">4、理解收集器接口</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        <em>Java </em>中 <em>Stream </em>流用来帮助处理集合，类似于数据库中的操作。</p> 
<p>        在 <em>Stream </em>接口中，有一个抽象方法<em> collect</em>，你会发现 <em>collect </em>是一个归约操作（<em>高级规约</em>），就像<em> reduce</em> 一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。具体的做法可以通过<em>Collector </em>接口来定义。<span style="color:#4da8ee;">// collect和reduce都是Stream接口中的汇总方法，collect方法接收一个Collector(收集器)作为参数</span></p> 
<p>        收集器(<em>Collector</em>)非常有用，<em>Collector </em>接口中方法的实现<em><span style="color:#fe2c24;">决定了如何对流执行归约操作</span></em>。<span style="color:#4da8ee;">//收集器用来定义收集器如何收集数据</span></p> 
<p>        一般来说，<em>Collector </em>会对元素应用一个<strong>转换函数</strong>，并将结果累积在一个数据结构中，从而产生这一过程的最终输出。</p> 
<p>        Collectors 实用类提供了很多静态工厂方法，可以方便地创建常见收集器的实例，所以只要拿来用就可以了。最直接和最常用的收集器比如<em><span style="color:#fe2c24;"> toList、toSet、toMap </span></em>等静态方法。</p> 
<h4 id="1%E3%80%81%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB" style="background-color:transparent;">1、归约和汇总</h4> 
<p>        使用 <em>Collectors </em>进行规约和汇总，比如统计汇总，查找最大值和最小值，拼接字符串等。</p> 
<p>        本节示例会使用到如下代码：</p> 
<pre><code>public class Dish {

    private final String name;
    private final boolean vegetarian;
    private final int calories;
    private final Type type;

    public Dish(String name, boolean vegetarian, int calories, Type type) {
        this.name = name;
        this.vegetarian = vegetarian;
        this.calories = calories;
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public int getCalories() {
        return calories;
    }

    public Type getType() {
        return type;
    }

    public enum Type {MEAT, FISH, OTHER}

    @Override
    public String toString() {
        return name;
    }

    public static final List&lt;Dish&gt; menu = Arrays.asList(
            new Dish("pork", false, 800, Type.MEAT), 
            new Dish("beef", false, 700, Type.MEAT), 
            new Dish("chicken", false, 400, Type.MEAT), 
            new Dish("french fries", true, 530, Type.OTHER), 
            new Dish("rice", true, 350, Type.OTHER), 
            new Dish("season fruit", true, 120, Type.OTHER), 
            new Dish("pizza", true, 550, Type.OTHER), 
            new Dish("prawns", false, 400, Type.FISH), 
            new Dish("salmon", false, 450, Type.FISH));
}</code></pre> 
<p>        <em><strong>汇总操作</strong></em>：Collectors 类专门为汇总提供了一些工厂方法，用来满足各种类型的统计需要。</p> 
<pre><code>    public static void main(String[] args) {
        //1、计数
        Long count0 = menu.stream().collect(Collectors.counting());
        long count1 = menu.stream().count();

        //2、汇总和
        Integer summingInt = menu.stream().collect(Collectors.summingInt(Dish::getCalories));

        //3、求平均数
        Double averagingInt = menu.stream().collect(Collectors.averagingInt(Dish::getCalories));

        //4、一次性求：计数量、总和、最大值、最小值、平均值
        IntSummaryStatistics statistics = menu.stream().collect(Collectors.summarizingInt(Dish::getCalories));
        //使用统计后的值
        double average = statistics.getAverage();
        long sum = statistics.getSum();
        int max = statistics.getMax();
        int min = statistics.getMin();
        long count = statistics.getCount();
    }</code></pre> 
<p>        上述示例中，使用<em><span style="color:#fe2c24;"> </span>summarizingInt </em>工方法<em>返回的</em>收集器功能很强大，通过一次 <em>summarizing </em>操作你就可以<em>统计到元素的个数，并得到总和、平均值、最大值和最小值</em>。</p> 
<p>        <em><strong>查找流中的最大值和最小值</strong></em>：<em>Collectors.maxBy </em>和 <em>Collectors.minBy</em>，来计算流中的最大或最小值。这两个收集器接收一个<em> Comparator </em>参数来比较流中的元素。</p> 
<pre><code>    public static void main(String[] args) {
        //比较器
        Comparator&lt;Dish&gt; comparator = Comparator.comparing(Dish::getCalories);
        //收集器
        Optional&lt;Dish&gt; collect = menu.stream().collect(Collectors.maxBy(comparator));
    }</code></pre> 
<p>       <em><strong> 连接字符串</strong></em>：<em>joining</em> 工厂方法返回的收集器会把对流中每一个对象应用 <em>tostring</em> 方法得到的所有字符串连接成一个字符串。如下所示：</p> 
<pre><code>String joining = menu.stream().map(Dish::getName).collect(Collectors.joining(",")); 

//joining:
pork,beef,chicken,french fries,rice,season fruit,pizza,prawns,salmon</code></pre> 
<p>        <em><strong>广义的规约汇总</strong></em>：事实上，<em><span style="color:#fe2c24;">前边所有的收集器，都是一个可以用 reducing 工厂方法定义的归约过程的特殊情况而已</span></em>。<em>Collectors.reducing<span style="color:#fe2c24;"> </span></em>工厂方法是所有这些特殊情况的一般化。如下所示：</p> 
<pre><code>    public static void main(String[] args) {
        //1、计数
        Long count0 = menu.stream().collect(Collectors.counting());
        Integer count1 = menu.stream().map(i -&gt; 1).collect(Collectors.reducing(0, (a, b) -&gt; a + b));

        //2、汇总和
        Integer summingInt = menu.stream().collect(Collectors.summingInt(Dish::getCalories));
        Integer sum = menu.stream().map(Dish::getCalories).collect(Collectors.reducing(0, (a, b) -&gt; a + b));

        //3、求最大值
        Optional&lt;Dish&gt; max0 = menu.stream().collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));
        Optional&lt;Dish&gt; max1 = menu.stream().collect(Collectors.reducing((a, b) -&gt; a.calories &gt; b.calories ? a : b));
    }</code></pre> 
<p>        到此，你可能想知道，<em><strong>Stream接口的 collect 和 reduce 方法有何不同？</strong></em>因为两种方法通常会获得相同的结果。</p> 
<p>        这个区别在于，<em>reduce</em> 方法旨在把两个值结合起来<em>生成一个新值</em>，它是一个不可变的归约。与此相反，<em>collect</em> 方法的设计就是要<em>改变容器</em>，从而累积要输出的结果。<span style="color:#4da8ee;">//语义上的区别</span></p> 
<p>        怎么理解这个区别呢？来看一段滥用 reduce 方法的代码：</p> 
<pre><code>    public static void main(String[] args) {
        Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();

        List&lt;Integer&gt; numbers = stream.reduce(new ArrayList&lt;Integer&gt;(), //1、初始值：List
                (List&lt;Integer&gt; list, Integer e) -&gt; { //2、转换函数:将Integer变为-&gt;List
                    list.add(e);
                    return list;
                },
                (List&lt;Integer&gt; list1, List&lt;Integer&gt; list2) -&gt; {//3、累计函数：多个List合并成一个List
                    list1.addAll(list2);
                    return list1;
                });
        System.out.println(numbers); //[1, 2, 3, 4, 5, 6]
    }</code></pre> 
<p>        上面的代码片段是在滥用 reduce 方法，因为它在原地改变了作为累加器的 List。<span style="color:#4da8ee;">//不能说上边方法错误，但是看起来有点炫技的意思，代码很复杂，做的事情却很少，而且使用并发流时还会存在线程安全问题</span></p> 
<p>        同样的问题，对比下 collect 方法的实现，你会发现非常的简单：</p> 
<pre><code>    public static void main(String[] args) {
        Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
        List&lt;Integer&gt; numbers = stream.collect(Collectors.toList());
    }</code></pre> 
<p>        一般来说，<em><span style="color:#fe2c24;">函数式编程通常会提供了多种方法来执行同一个操作</span></em>。所以，我们需要根据情况选择最佳解决方案。收集器在某种程度上比 Stream 接口上直接提供的方法用起来更复杂，但好处在于它们能提供更高水平的抽象和概括，也更容易重用和自定义。</p> 
<h4 id="2%E3%80%81%E5%88%86%E7%BB%84">2、分组</h4> 
<p>        数据库中一个常见操作是根据一个或多个属性对集合中的项目进行分组。</p> 
<p>       <em><strong> 简单分组</strong></em>：用 <em>Collectors.groupingBy </em>工厂方法返回的收集器就可以轻松地完成这项任务，如下所示：</p> 
<pre><code>public static void main(String[] args) {
        //1、简单分组
        Map&lt;Type, List&lt;Dish&gt;&gt; grouping0 = menu.stream().collect(Collectors.groupingBy(Dish::getType));

        //2、自定义分组条件
        Map&lt;String, List&lt;Dish&gt;&gt; grouping1 = menu.stream().collect(Collectors.groupingBy(r -&gt; {
            if (r.getCalories() &lt;= 400) {
                return "低热量";
            } else if (r.getCalories() &lt;= 700) {
                return "普通";
            } else {
                return "高热量";
            }
        }));
        System.out.println(grouping1);
    }

//1、简单分组
{MEAT=[pork, beef, chicken], OTHER=[french fries, rice, season fruit, pizza], FISH=[prawns, salmon]}
//2、自定义分组条件
{普通=[beef, french fries, pizza, salmon], 低热量=[chicken, rice, season fruit, prawns], 高热量=[pork]}</code></pre> 
<p>        <em><strong>多级分组</strong></em>：Collectors.groupingBy 工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受 Collector 类型的第二个参数。那么要进行多级分组的话，就<em><span style="color:#fe2c24;">可以把一个内层 groupingBy 传递给外层 groupingBy</span></em>，如下所示：</p> 
<pre><code>    public static void main(String[] args) {
        Map&lt;Type, Map&lt;String, List&lt;Dish&gt;&gt;&gt; grouping = menu.stream().collect(
                Collectors.groupingBy(Dish::getType, //一级分类函数
                Collectors.groupingBy(r -&gt; { //二级分类函数
                    if (r.getCalories() &lt;= 400) {
                        return "低热量";
                    } else if (r.getCalories() &lt;= 700) {
                        return "普通";
                    } else {
                        return "高热量";
                    }
                })));
//分组：
{
FISH={普通=[salmon], 低热量=[prawns]}, 
MEAT={普通=[beef], 低热量=[chicken], 高热量=[pork]}, 
OTHER={普通=[french fries, pizza], 低热量=[rice, season fruit]}
}</code></pre> 
<p>        <em><strong>按子组收集数据</strong></em>：上边可以把第二个 groupingBy 收集器传递给外层收集器来实现多级分组。但是，<em><span style="color:#fe2c24;">传递给第一个 groupingBy 的第二个收集器可以是任何类型</span></em>，而不一定是另一个 groupingBy，如下所示：</p> 
<pre><code>    public static void main(String[] args) {
        //1、简单分组
        Map&lt;Type, List&lt;Dish&gt;&gt; groupingBy = menu.stream().collect(Collectors.groupingBy(Dish::getType));

        //2、分组后计数
        Map&lt;Type, Long&gt; collect0 = menu.stream().collect(Collectors.groupingBy(Dish::getType,
                Collectors.counting()));

        //3、分组后获取最大值
        Map&lt;Type, Optional&lt;Dish&gt;&gt; collect1 = menu.stream().collect(Collectors.groupingBy(Dish::getType,
                Collectors.maxBy(Comparator.comparing(Dish::getCalories))));

        //4、分组后获取最大值
        Map&lt;Type, Dish&gt; collect2 = menu.stream().collect(Collectors.groupingBy(Dish::getType,
                Collectors.collectingAndThen(
                        Collectors.maxBy(Comparator.comparing(Dish::getCalories)), Optional::get)));

        //5、分组后按名称倒序排序
        Map&lt;Type, List&lt;Dish&gt;&gt; collect3 = menu.stream().collect(Collectors.groupingBy(Dish::getType,
                Collectors.collectingAndThen(
                        Collectors.toList(),
                        list -&gt; list.stream().sorted(Comparator.comparing(Dish::getName).reversed()).collect(Collectors.toList()))));

        //6、分组后更该返回映射
        Map&lt;Type, Set&lt;String&gt;&gt; collect4 = menu.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.mapping(r -&gt; {
            if (r.getCalories() &lt;= 400) {
                return "低热量";
            } else if (r.getCalories() &lt;= 700) {
                return "普通";
            } else {
                return "高热量";
            }
        }, Collectors.toSet())));
    }

//1、简单分组：{MEAT=[pork, beef, chicken], OTHER=[french fries, rice, season fruit, pizza], FISH=[prawns, salmon]}
//2、分组后计数：{MEAT=3, OTHER=4, FISH=2}
//3、分组后获取最大值：{OTHER=Optional[pizza], FISH=Optional[salmon], MEAT=Optional[pork]}
//4、分组后获取最大值：{OTHER=pizza, FISH=salmon, MEAT=pork}
//5、分组后按名称倒序排序：{MEAT=[pork, chicken, beef], OTHER=[season fruit, rice, pizza, french fries], FISH=[salmon, prawns]}
//6、分组后更该返回映射：OTHER=[普通, 低热量], FISH=[普通, 低热量], MEAT=[普通, 低热量, 高热量]}</code></pre> 
<p>        这里要注意一下，普通的单参数 <em>groupingBy(f)</em>（其中 f 是分类函数）实际上是<em> groupingBy(f,toList()) </em>的简便写法。</p> 
<h4 id="3%E3%80%81%E5%88%86%E5%8C%BA">3、分区</h4> 
<p>        <em><span style="color:#fe2c24;">分区是分组的特殊情况</span></em>，由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。分区函数返回一个布尔值，这意味着得到的<em>分组 Map 的键类型是 Boolean</em>，于是它<em>最多可以分为两组</em>——<em>true</em>是一组，<em>false</em>是一组。</p> 
<pre><code>//1、分区
Map&lt;Boolean, List&lt;Dish&gt;&gt; partitioningBy = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian));

//2、分区后分组
Map&lt;Boolean, Map&lt;Type, List&lt;Dish&gt;&gt;&gt; collect = menu.stream().collect(Collectors.partitioningBy(Dish::isVegetarian, 
                Collectors.groupingBy(Dish::getType)));

//1、分区：{false=[pork, beef, chicken, prawns, salmon], true=[french fries, rice, season fruit, pizza]}
//2、分区后分组：{false={FISH=[prawns, salmon], MEAT=[pork, beef, chicken]}, true={OTHER=[french fries, rice, season fruit, pizza]}}</code></pre> 
<p><span style="color:#4da8ee;">        //分区即是一种特殊的分组，也可以看成是一个保留过滤元素的过滤操作</span></p> 
<h4 id="4%E3%80%81%E7%90%86%E8%A7%A3%E6%94%B6%E9%9B%86%E5%99%A8%E6%8E%A5%E5%8F%A3">4、理解收集器接口</h4> 
<p>        <em>Collector </em>接口包含了一系列方法，为实现具体的归约操作（即收集器）提供了范本。<em>Collector </em>接口中实现的许多收集器，例如 <em>toList </em>或<em> groupingBy</em>，这也意味着我们<em><span style="color:#fe2c24;">可以为 Collector 接口提供自己的实现</span></em>，从而自由地创建自定义归约操作。</p> 
<p>        首先看看 <em>Collector </em>接口的定义，它列出了接口的签名以及声明的五个方法。</p> 
<pre><code>public interface Collector&lt;T, A, R&gt; {
    Supplier&lt;A&gt; supplier();
    BiConsumer&lt;A, T&gt; accumulator();
    BinaryOperator&lt;A&gt; combiner();
    Function&lt;A, R&gt; finisher();
    Set&lt;Characteristics&gt; characteristics();
}</code></pre> 
<ul><li>T 是流中要收集的项目的泛型。</li><li>A 是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</li><li>R 是收集操作得到的对象（通常但并不一定是集合）的类型。</li></ul> 
<p>        分析 <em>Collector </em>接口声明的五个方法，你会发现前四个方法都会返回一个会被 <em>collect </em>方法调用的函数，而第五个方法 <em>characteristics </em>则提供了一系列特征，也就是一个提示列表，告诉 <em>collect </em>方法在执行归约操作的时候可以应用哪些优化。<span style="color:#4da8ee;">//四个操作函数 + 一个特征值列表</span></p> 
<p>       <strong> <em>（1）建立新的结果容器：supplier 方法</em></strong></p> 
<p>        <em>Supplier </em>方法在调用时它会创建一个空的累加器实例，供数据收集过程使用。<em><span style="color:#fe2c24;">在对空流执行操作的时候，这个空的累加器也代表了收集过程的结果</span></em>。<span style="color:#4da8ee;">//所以lambda收集后不会出现Null的情况</span></p> 
<pre><code>    public Supplier&lt;List&lt;T&gt;&gt; supplier() {
        return () -&gt; new ArrayList&lt;T&gt;(); //提供一个集合作为累加器实例
    }</code></pre> 
<p>        <em><strong>（2）将元素添加到结果容器：accumulator 方法</strong></em></p> 
<p>        <em>accumulator </em>方法会返回<em><span style="color:#fe2c24;">执行归约操作的函数</span></em>。该函数将返回 <em>void</em>，因为累加器是原位更新，即函数的执行改变了它的内部状态以体现遍历的元素的效果。比如，把当前元素添加至已经遍历过的元素的列表：<span style="color:#4da8ee;">//定义如何把流中的元素放到累加器中</span></p> 
<pre><code>    public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() {
        return (list, element) -&gt; list.add(element); //定义归约操作
    }</code></pre> 
<p>        <strong><em>（3）对结果容器应用最终转换：finisher方法</em></strong></p> 
<p>        在遍历完流后，<em>finisher </em>方法必须<em><span style="color:#fe2c24;">返回在累积过程的最后要调用的一个函数</span></em>，以便将累加器对象转换为整个集合操作的最终结果。如果累加器对象恰好与预期的最终结果符合，就无需进行转换。<span style="color:#4da8ee;">//累加器的对象类型为T，期待返回的最终对象类型也为T，就无需转换 </span></p> 
<pre><code>    public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() {
        return i -&gt; i;  //无转换，直接返回
    }</code></pre> 
<p>        使用以上三个方法就已经足以对流进行顺序归约，这个逻辑流程如下所示：</p> 
<p class="img-center"><img alt="" height="479" src="https://images2.imgbox.com/e6/a4/mnboVcVh_o.png" width="700"></p> 
<p>        但是为什么还需要另外两个方法呢？答案是<span style="color:#fe2c24;"><em>并行</em></span>。</p> 
<p>        <em><strong>（4）合并两个结果容器：combiner方法</strong></em></p> 
<p>        combiner 方法会返回一个供归约操作使用的函数，它<em><span style="color:#fe2c24;">定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并</span></em>。<span style="color:#4da8ee;">//并行时，对子流进行合并处理</span></p> 
<pre><code>    public BinaryOperator&lt;List&lt;T&gt;&gt; combiner() {
        return (list1, list2) -&gt; {
            list1.addAll(list2);
            return list1;
        };
    }</code></pre> 
<p>        有了 <em>combiner </em>方法，就可以对流进行并行归约了。这个流程就像是这样：</p> 
<p class="img-center"><img alt="" height="746" src="https://images2.imgbox.com/56/d0/66gKj5lE_o.png" width="800"></p> 
<p>        <em><strong>（5）特征值列表：characteristics 方法</strong></em></p> 
<p>        <em>characteristics </em>会返回一个不可变的 characteristics 集合，它<em><span style="color:#fe2c24;">定义了收集器的行为</span></em>——尤其是关于流<em>是否可以并行归约</em>，以及<em>可以使用哪些优化的提示</em>。Characteristics 是一个包含三个特征值的枚举。</p> 
<ul><li><em>UNORDERED</em>——归约结果不受流中项目的遍历和累积顺序的影响。<span style="color:#4da8ee;">//无序</span></li><li><em>CONCURRENT</em>——<em>accumulator </em>函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为 <em>UNORDERED</em>，那它仅在用于无序数据源时才可以并行归约。<span style="color:#4da8ee;">//并行</span></li><li><em>IDENTITY_FINISH</em>——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。</li></ul> 
<pre><code>    public Set&lt;Characteristics&gt; characteristics() {
        return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, CONCURRENT));
    }</code></pre> 
<p>        至此，收集器的 5 个方法我们都分析完了，然后把上述分析过程的代码组装在一起，就成了一个我们自己定义的 <em>ToList </em>收集器了，完整的代码如下所示：</p> 
<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;

import static java.util.stream.Collector.Characteristics.CONCURRENT;
import static java.util.stream.Collector.Characteristics.IDENTITY_FINISH;

public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt; {

    @Override
    public Supplier&lt;List&lt;T&gt;&gt; supplier() {
        return () -&gt; new ArrayList&lt;T&gt;();
    }

    @Override
    public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() {
        return (list, item) -&gt; list.add(item);
    }

    @Override
    public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() {
        return i -&gt; i;
    }

    @Override
    public BinaryOperator&lt;List&lt;T&gt;&gt; combiner() {
        return (list1, list2) -&gt; {
            list1.addAll(list2);
            return list1;
        };
    }

    @Override
    public Set&lt;Characteristics&gt; characteristics() {
        return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, CONCURRENT));
    }
}</code></pre> 
<p>        接下来，我们使用<em>Java</em>提供和收集器和自己写的收集器测验一下：</p> 
<pre><code>    public static void main(String[] args) {
        List&lt;String&gt; collect0 = menu.stream().map(Dish::getName).collect(Collectors.toList());
        List&lt;String&gt; collect1 = menu.stream().map(Dish::getName).collect(new ToListCollector&lt;&gt;());
    }</code></pre> 
<p>        注意，这里我们需要使用 <em>new </em>来实例化我们自定义的收集器。对比执行的结果，你会发现两个函数的结果都是一样的，这是因为我们实现的 <em>ToList </em>收集器，大致上就是 Java 实现<em>ToList </em>收集器的逻辑，下边是  Java 实现<em>ToList </em>收集器的源码：</p> 
<pre><code>    public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() {
        return new CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new,  //供应源
                                    List::add,                          //累加器
                                   (left, right) -&gt; { left.addAll(right); return left; }, //组合器
                                   CH_ID);                              //特征值列表
    }</code></pre> 
<p>       <span style="color:#4da8ee;"> // 上边貌似少了一个 finisher方法，其实这个方法在 CollectorImpl 中给了默认实现，请跟源码</span></p> 
<p>        最后，对于 <em>IDENTITY_FINISH </em>的收集操作，还有一种方法可以得到同样的结果而无需从头实现新的 <em>Collectors</em> 接口。<em>Stream </em>有一个重载的 <span style="color:#fe2c24;"><em>collect 方法可以接受另外三个函数：supplier、accumulator 和 combiner</em></span>，其语义和 <em>Collector </em>接口的相应方法返回的函数完全相同。那么上边的收集操作同样可以写成如下形式：</p> 
<pre><code>ArrayList&lt;String&gt; collect2 = menu.stream().map(Dish::getName).collect(
                ArrayList::new, //供应源
                List::add,      //累加器
                List::addAll);  //组合器</code></pre> 
<p>        第二种形式虽然比前一个<em><span style="color:#fe2c24;">写法更为紧凑和简洁，却不那么易读</span></em>。另外值得注意的是，第二种形式中的 <em>collect </em>方法不能传递任何 <em>characteristics</em>，所以它永远都是一个 <em>IDENTITY_FINISH </em>和 <em>CONCURRENT </em>但并非 <em>UNORDERED</em> 的收集器。</p> 
<p>        至此，全文结束。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11ebfdf02314bacc37195a366a4d2594/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringMVC之注解的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af0b17c493360014f33af2c3ba090d7d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python基础阶段（五）—— 函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>