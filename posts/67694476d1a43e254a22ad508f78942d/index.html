<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动之INPUT设备驱动 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动之INPUT设备驱动" />
<meta property="og:description" content="目录
一、开发环境
二、编写按键input设备的注册与事件上报
2.1 修改设备树文件
1 添加 pinctrl 节点
2、添加 KEY 设备节点
3、检查 PIN 是否被其他外设使用
2.2 驱动程序编写
2.3 测试APP编写
2.4 运行测试
三、Linux内核自带按键input设备驱动
3.1 自带按键驱动程序源码简析
3.2 自带按键驱动程序的使用
3.3 运行测试
上一章已经了解了input子系统的大体框架和input设备的注册以及对应事件的上报流程，现在就写一个简单的input设备驱动实验来更加深入的理解input子系统。
本章将分别采用以下两种方法来进行按键input设备驱动的实验：
1、编写按键input设备的注册与事件上报
2、Linux内核自带按键input设备驱动
一、开发环境 CPU：IMX6ULL
内核版本：Linux-5.19
二、编写按键input设备的注册与事件上报 2.1 修改设备树文件
1 添加 pinctrl 节点
I.MX6U-ALPHA开发板上的 KEY 使用了 UART1_CTS_B这个 PIN，打开 imx6ul-14x14-evk.dtsi ，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_key”的子节点，节点内容如下所示：
pinctrl_key: keygrp { fsl,pins = &lt; MX6UL_PAD_UART1_CTS_B__GPIO1_IO18 0xF080 /* key0 */ &gt;; }; 第 3 行，将 GPIO_IO18 这个 PIN 复用为 GPIO1_IO18。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/67694476d1a43e254a22ad508f78942d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-18T07:50:58+08:00" />
<meta property="article:modified_time" content="2023-09-18T07:50:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动之INPUT设备驱动</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" rel="nofollow">一、开发环境</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E6%8C%89%E9%94%AEinput%E8%AE%BE%E5%A4%87%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E4%BA%8B%E4%BB%B6%E4%B8%8A%E6%8A%A5" rel="nofollow">二、编写按键input设备的注册与事件上报</a></p> 
<p style="margin-left:40px;"><a href="#2.1%20%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6" rel="nofollow">        </a><a href="#2.1%20%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6" rel="nofollow">2.1 修改设备树文件</a></p> 
<p style="margin-left:40px;"><a href="#1%20%E6%B7%BB%E5%8A%A0%20pinctrl%20%E8%8A%82%E7%82%B9" rel="nofollow">        </a>        <a href="#1%20%E6%B7%BB%E5%8A%A0%20pinctrl%20%E8%8A%82%E7%82%B9" rel="nofollow">1 添加 pinctrl 节点</a></p> 
<p style="margin-left:40px;"><a href="#2%E3%80%81%E6%B7%BB%E5%8A%A0%20KEY%20%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9" rel="nofollow">        </a>        <a href="#2%E3%80%81%E6%B7%BB%E5%8A%A0%20KEY%20%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9" rel="nofollow">2、添加 KEY 设备节点</a></p> 
<p style="margin-left:40px;"><a href="#3%E3%80%81%E6%A3%80%E6%9F%A5%20PIN%20%E6%98%AF%E5%90%A6%E8%A2%AB%E5%85%B6%E4%BB%96%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8" rel="nofollow">        </a>        <a href="#3%E3%80%81%E6%A3%80%E6%9F%A5%20PIN%20%E6%98%AF%E5%90%A6%E8%A2%AB%E5%85%B6%E4%BB%96%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8" rel="nofollow">3、检查 PIN 是否被其他外设使用</a></p> 
<p style="margin-left:40px;"><a href="#2.2%20%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99" rel="nofollow">        </a><a href="#2.2%20%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99" rel="nofollow">2.2 驱动程序编写</a></p> 
<p style="margin-left:40px;"><a href="#2.3%20%E6%B5%8B%E8%AF%95APP%E7%BC%96%E5%86%99" rel="nofollow">        </a><a href="#2.3%20%E6%B5%8B%E8%AF%95APP%E7%BC%96%E5%86%99" rel="nofollow">2.3 测试APP编写</a></p> 
<p style="margin-left:40px;"><a href="#2.4%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">        </a><a href="#2.4%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">2.4 运行测试</a></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81Linux%E5%86%85%E6%A0%B8%E8%87%AA%E5%B8%A6%E6%8C%89%E9%94%AEinput%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8" rel="nofollow">三、Linux内核自带按键input设备驱动</a></p> 
<p style="margin-left:40px;"><a href="#3.1%20%E8%87%AA%E5%B8%A6%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90" rel="nofollow">        </a><a href="#3.1%20%E8%87%AA%E5%B8%A6%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90" rel="nofollow">3.1 自带按键驱动程序源码简析</a></p> 
<p style="margin-left:40px;"><a href="#3.2%20%E8%87%AA%E5%B8%A6%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">        </a><a href="#3.2%20%E8%87%AA%E5%B8%A6%E6%8C%89%E9%94%AE%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">3.2 自带按键驱动程序的使用</a></p> 
<p style="margin-left:40px;"><a href="#3.3%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">        </a><a href="#3.3%20%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">3.3 运行测试</a></p> 
<hr> 
<p>        上一章已经了解了input子系统的大体框架和input设备的注册以及对应事件的上报流程，现在就写一个简单的input设备驱动实验来更加深入的理解input子系统。</p> 
<p>        本章将分别采用以下两种方法来进行按键input设备驱动的实验：</p> 
<ul><li> <p>1、编写按键input设备的注册与事件上报</p> </li><li> <p>2、Linux内核自带按键input设备驱动</p> </li></ul> 
<h3>一、开发环境</h3> 
<ul><li> <p>CPU：IMX6ULL</p> </li><li> <p>内核版本：Linux-5.19</p> </li></ul> 
<h3>二、编写按键input设备的注册与事件上报</h3> 
<p>2.1 修改设备树文件</p> 
<p>1 添加 pinctrl 节点</p> 
<p>        I.MX6U-ALPHA开发板上的 KEY 使用了 UART1_CTS_B这个 PIN，打开 imx6ul-14x14-evk.dtsi ，在 iomuxc 节点的 imx6ul-evk 子节点下创建一个名为“pinctrl_key”的子节点，节点内容如下所示：</p> 
<pre><code class="language-objectivec">pinctrl_key: keygrp {
    fsl,pins = &lt;
        MX6UL_PAD_UART1_CTS_B__GPIO1_IO18 0xF080 /* key0 */
    &gt;;
};
</code></pre> 
<p>        第 3 行，将 GPIO_IO18 这个 PIN 复用为 GPIO1_IO18。</p> 
<p>2、添加 KEY 设备节点</p> 
<p>        在根节点“/”下创建 KEY 节点，节点名为“key”，节点内容如下：</p> 
<pre><code class="language-objectivec">key {
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;
    compatible = "imx6ull-key";
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_key&gt;;
    key-gpio = &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;;
    status = "okay";
};
</code></pre> 
<p>        第 6 行， pinctrl-0 属性设置 KEY 所使用的 PIN 对应的 pinctrl 节点。</p> 
<p>        第 7 行， key-gpio 属性指定了 KEY 所使用的 GPIO。</p> 
<p>3、检查 PIN 是否被其他外设使用</p> 
<p>        本次实验中按键使用的 PIN 为 UART1_CTS_B，因此先检查 PIN 为 UART1_CTS_B 这个 PIN 有没有被其他的 pinctrl 节点使用，如果有使用的话就要屏蔽掉，然后再检查 GPIO1_IO18这个 GPIO 有没有被其他外设使用，如果有的话也要屏蔽掉。</p> 
<p>        设备树编写完成以后使用“make dtbs”命令重新编译设备树，然后使用新编译出来的imx6ull-toto.dtb 文件启动 Linux 系统。启动成功以后进入“/proc/device-tree”目录中查看“key”节点是否存在，如果存在的话就说明设备树基本修改成功(具体还要驱动验证)，结果如下所示：</p> 
<pre><code class="language-objectivec">/ # ls /proc/device-tree/
#address-cells      clock-osc           pmu
#size-cells         compatible          regulator-can-3v3
aliases             cpus                regulator-peri-3v3
backlight-display   dts_led             regulator-sd1-vmmc
beep                key                 soc
chosen              memory@80000000     sound-wm8960
clock-cli           model               spi4
clock-di0           name                timer
clock-di1           panel
</code></pre> 
<p>2.2 驱动程序编写</p> 
<p>        设备树准备好以后就可以编写驱动程序了，在 input_key.c 里面输入如下内容：</p> 
<pre><code class="language-objectivec">/*
 * Copyright © toto Co., Ltd. 1998-2029. All rights reserved.
 * @Description: 
 * @Version: 1.0
 * @Autor: Seven
 * @Date: 2023-09-17 13:19:32
 * @LastEditors: Seven
 * @LastEditTime: 2023-09-17 16:57:23
 */
#include &lt;linux/fs.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/of_address.h&gt;
#include &lt;linux/gpio.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/of_irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/timer.h&gt;

#define KEYINPUT_CNT    1           /* 设备数量 */
#define KEYINPUT_NAME   "inputkey"  /* 设备名字 */
#define KEY_VALUE       0x1         /* 按键值 */
#define KEY_INVALID     0xFF        /* 无效的按键值 */
#define KEY_NUM         1           /* 按键数量 */

/* 定义按键中断操作结构体 */
struct irq_keydesc {
    int gpio;           /* 中断使用的gpio */
    int irqnum;         /* 中断号 */
    unsigned char value;/* 按键对应的键值 */
    char name[10];      /* 中断名 */
    irqreturn_t (*handler)(int, void *); /* 中断服务函数 */
};

/* inputkey设备信息 */
struct inputkey_dev {
    dev_t devid;
    struct cdev cdev;
    struct class *class;
    struct device *device;
    struct device_node *dev_nd;
    struct timer_list timer;
    struct irq_keydesc irq_desc[KEY_NUM];
    unsigned char cur_keynum;
    struct input_dev *inputdev;
};

/* 定义 key 输入设备 */
struct inputkey_dev inputdev;

/*
 * @Brief   中断服务函数，开启定时器，
 *          延时10ms用于按键消抖
 * @Param   irq:中断号
 * @Param   dev_id:设备结构
 * @Note    NOne
 * @RetVal  中断执行结果
 */
static irqreturn_t key_handler(int irq, void *dev_id)
{
    struct inputkey_dev *dev = (struct inputkey_dev *)dev_id;

    dev-&gt;cur_keynum = 0;
    // dev-&gt;timer.data = (volatile long)dev_id;
    mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(10));

    return IRQ_RETVAL(IRQ_HANDLED);
}

/*
 * @Brief   定时器服务函数，用于按键消抖，
 *          定时器到再次读取按键值，按键还处于按下则按键有效
 * @Param   t:设备结构体
 * @Note    NOne
 * @RetVal  NOne
 */
void timer_function(struct timer_list *t)
{
    unsigned char value, num;
    struct irq_keydesc *keydesc;
    struct inputkey_dev *dev = from_timer(dev, t, timer);

    num = dev-&gt;cur_keynum;
    keydesc = &amp;dev-&gt;irq_desc[num];
    
    /* 读取IO值 */
    value = gpio_get_value(keydesc-&gt;gpio);
    /* 按键按下 */
    if(value == 0) {
        /* 上报按键值 */
        input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 1);
        input_sync(dev-&gt;inputdev);
    } else { /* 按键松开 */
        input_report_key(dev-&gt;inputdev, keydesc-&gt;value, 0);
        input_sync(dev-&gt;inputdev);
    }
}

/*
 * @Brief   按键IO初始化
 * @Param   None
 * @Note    NOne
 * @RetVal  NOne
 */
static int keyio_init(void)
{
    unsigned char i = 0;
    char name[10];
    int ret = 0;

    inputdev.dev_nd = of_find_node_by_path("/key");
    if (!inputdev.dev_nd) {
        printk(KERN_ERR "key node not found\r");
        return -EINVAL;
    }

    /* 提取GPIO */
    for (i = 0; i &lt; KEY_NUM; i++) {
        inputdev.irq_desc[i].gpio = 
                of_get_named_gpio(inputdev.dev_nd, "key-gpio", i);
        if (inputdev.irq_desc[i].gpio &lt; 0) {
            printk(KERN_ERR "can't get key:%d\n", i);
        }
    }

    /* 初始化key所使用的IO, 并设置中断模式 */
    for (i = 0; i &lt; KEY_NUM; i++) {
        memset(inputdev.irq_desc[i].name, 0, sizeof(name));
        sprintf(inputdev.irq_desc[i].name, "KEY%d", i);
        gpio_request(inputdev.irq_desc[i].gpio, 
                        inputdev.irq_desc[i].name);
        gpio_direction_input(inputdev.irq_desc[i].gpio);
        inputdev.irq_desc[i].irqnum = 
                        irq_of_parse_and_map(inputdev.dev_nd, i);
    }

    /* 申请中断 */
    inputdev.irq_desc[0].handler = key_handler;
    inputdev.irq_desc[0].value = KEY_0;

    for (i = 0; i &lt; KEY_NUM; i++) {
        ret = request_irq(inputdev.irq_desc[i].irqnum,
                        inputdev.irq_desc[i].handler,
                        IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
                        inputdev.irq_desc[i].name, &amp;inputdev);
        if (ret &lt; 0) {
            printk(KERN_ERR "irq %d request failed\n", 
                            inputdev.irq_desc[i].irqnum);
            return -EFAULT;
        }
    }

    /* 6.初始化timer */
    inputdev.timer.expires = jiffies + msecs_to_jiffies(10);
    timer_setup(&amp;inputdev.timer, timer_function, 0);

    /* 申请input_dev */
    inputdev.inputdev = input_allocate_device();
    inputdev.inputdev-&gt;name = KEYINPUT_NAME;

    inputdev.inputdev-&gt;evbit[0] = BIT_MASK(EV_KEY) 
                                | BIT_MASK(EV_REP);
    input_set_capability(inputdev.inputdev, EV_KEY, KEY_0);

    /* 注册input设备*/
    ret = input_register_device(inputdev.inputdev);
    if (ret) {
        printk(KERN_ERR "register input device failed\n");
        return ret;
    }

    return 0;
}

/*
 * @Brief   驱动入口函数
 * @Param   None
 * @Note    NOne
 * @RetVal  NOne
 */
static int __init inputkey_init(void)
{
    keyio_init();

    return 0;
}

/*
 * @Brief   驱动出口函数
 * @Param   None
 * @Note    NOne
 * @RetVal  NOne
 */
static void __exit inputkey_exit(void)
{
    unsigned int i = 0;

    /* 删除定时器 */
    del_timer_sync(&amp;inputdev.timer);

    /* 释放中断 */
    for (i = 0; i &lt; KEY_NUM; i++) {
        free_irq(inputdev.irq_desc[i].irqnum, &amp;inputdev);
    }

    /* 释放IO */
    for (i = 0; i &lt; KEY_NUM; i++) {
        gpio_free(inputdev.irq_desc[i].gpio);
    }

    /* 释放input设备 */
    input_unregister_device(inputdev.inputdev);
    input_free_device(inputdev.inputdev);
}


module_init(inputkey_init);
module_exit(inputkey_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("toto");
</code></pre> 
<p>2.3 测试APP编写</p> 
<p>        input_key_app.c 测试程序具体代码如下：</p> 
<pre><code class="language-objectivec">/*
 * Copyright © toto Co., Ltd. 1998-2029. All rights reserved.
 * @Description: 
 * @Version: 1.0
 * @Autor: Seven
 * @Date: 2023-09-17 16:10:12
 * @LastEditors: Seven
 * @LastEditTime: 2023-09-17 21:12:01
 */
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;linux/input.h&gt;

/* 定义一个input_event变量，存放输入事件信息 */
static struct input_event inputevt;

/*
 * @Brief   main 主程序
 * @Param   argc:
 * @Param   argv:
 * @Note    NOne
 * @RetVal  0-成功;其他-失败
 */
int main(int argc, char *argv[])
{
    int fd, err;
    char *filename;

    if (argc != 2) {
        printf("argc != 3\n");
        return -1;
    }

    filename = argv[1];

    /*打开驱动文件*/
    fd = open(filename, O_RDWR);
    if (fd &lt; 0) {
        printf("open filename:%d failed\n", filename);
        return -1;
    }

    while (1) {
        err = read(fd, &amp;inputevt, sizeof(inputevt));
        if (err &lt;= 0) {
            printf("read inputevt failed\n");
            continue;
        }

        switch (inputevt.type)
        {
        case EV_KEY:
            printf("key %d %s\n", inputevt.code, 
                        inputevt.value ? "down" : "up");
            break;
        case EV_REL:
            break;
        case EV_ABS:
            break;
        case EV_MSC:
            break;
        case EV_SW:
            break;
        default:
            break;
        }
    }

    /*关闭文件*/
    close(fd);

    return 0;
}
</code></pre> 
<p>2.4 运行测试</p> 
<p>        开发板上电，将input_key.ko 和 input_key_app 这两个文件拷贝到 /lib/modules/5.19.0-g794a2f7be62d-dirty/ 目录中，在加载input_key.ko之前，先来看一下/dev/input 目录下都有哪些文件，结果如下所示：</p> 
<pre><code class="language-objectivec">/ # ls -al /dev/input/
total 0
drwxr-xr-x    2 0        0               80 Jan 19 19:30 .
drwxr-xr-x    6 0        0             2880 Jan 19 19:25 ..
crw-rw----    1 0        0          13,  64 Jan  1 00:00 event0
</code></pre> 
<p>        从上面可以看出，当前/dev/input 目录只有 event0 这一个文件。接下来输入如下命令加载 input_key.ko 这个驱动模块。</p> 
<pre><code class="language-objectivec">/ # insmod /lib/modules/5.19.0-g794a2f7be62d-dirty/input_key.ko 
[  310.665956] input_key: loading out-of-tree module taints kernel.
[  310.678432] input: inputkey as /devices/virtual/input/input2
</code></pre> 
<p>        当驱动模块加载成功以后再来看一下/dev/input 目录下有哪些文件，结果如下所示：</p> 
<pre><code class="language-objectivec">/ # ls -al /dev/input/
total 0
drwxr-xr-x    2 0        0               80 Jan 19 19:30 .
drwxr-xr-x    6 0        0             2880 Jan 19 19:25 ..
crw-rw----    1 0        0          13,  64 Jan  1 00:00 event0
crw-------    1 0        0          13,  65 Jan 19 19:30 event1
</code></pre> 
<p>        从上面可以看出，多了一个 event1 文件，因此/dev/input/event1 就是注册的驱动所对应的设备文件。 input_key_app 就是通过读取/dev/input/event1 这个文件来获取输入事件信息的，输入如下测试命令：</p> 
<pre><code class="language-objectivec">./input_key_app /dev/input/event1
</code></pre> 
<p>        然后按下开发板上的 KEY 按键，结果如下所示：</p> 
<pre><code class="language-objectivec">/home/app # ./input_key_app /dev/input/event1
key 11 down
key 11 up
key 11 down
key 11 up
key 11 down
key 11 up
key 11 down
key 11 up
</code></pre> 
<p>        从上面可以看出，当我们按下或者释放开发板上的按键以后都会在终端上输出相应的内容，提示我们哪个按键按下或释放了，在 Linux 内核中 KEY_0 为 11。</p> 
<p>        另外，我们也可以不用 input_key_app 来测试驱动，可以直接使用 hexdump 命令来查看/dev/input/event1 文件内容，输入如下命令：</p> 
<pre><code class="language-objectivec">hexdump /dev/input/event1
</code></pre> 
<p>        然后按下按键，终端输出如下所示信息：</p> 
<pre><code class="language-objectivec">/ # hexdump /dev/input/event1
0000000 079e 0019 8806 0004 0001 000b 0001 0000
0000010 079e 0019 8806 0004 0000 0000 0000 0000
0000020 079e 0019 6be6 0007 0001 000b 0000 0000
0000030 079e 0019 6be6 0007 0000 0000 0000 0000
0000040 079f 0019 2861 0003 0001 000b 0001 0000
0000050 079f 0019 2861 0003 0000 0000 0000 0000
0000060 079f 0019 d5a2 0004 0001 000b 0000 0000
0000070 079f 0019 d5a2 0004 0000 0000 0000 0000
0000080 07a0 0019 69a9 0000 0001 000b 0001 0000
0000090 07a0 0019 69a9 0000 0000 0000 0000 0000
00000a0 07a0 0019 14f8 0002 0001 000b 0000 0000
00000b0 07a0 0019 14f8 0002 0000 0000 0000 0000
</code></pre> 
<p>        上面就是 input_event 类型的原始事件数据值，采用十六进制表示，这些原始数据的含义如下：</p> 
<pre><code class="language-objectivec">/*****************input_event 类型********************/
/* 编号 */    /* tv_sec */    /* tv_usec */    /* type */    /* code */    /* value */

0000000       079e 0019       8806 0004        0001         000b           0001 0000
0000010       079e 0019       8806 0004        0000         0000           0000 0000
0000020       079e 0019       6be6 0007        0001         000b           0000 0000
0000030       079e 0019       6be6 0007        0000         0000           0000 0000
</code></pre> 
<p>        type 为事件类型，查看示例代码 58.1.2.3 可知， EV_KEY 事件值为 1， EV_SYN 事件值为0。因此第 1 行表示 EV_KEY 事件，第 2 行表示 EV_SYN 事件。</p> 
<p>        code 为事件编码，也就是按键号，查看示例代码 58.1.2.4 可以， KEY_0 这个按键编号为 11，对应的十六进制为 0xb，因此第1 行表示 KEY_0 这个按键事件，最后的 value 就是按键值，为 1 表示按下，为 0 的话表示松开。</p> 
<p>综上所述，"hexdump /dev/input/event1" 中的原始事件值含义如下：</p> 
<ul><li> <p>第 1 行，按键(KEY_0)按下事件。</p> </li><li> <p>第 2 行， EV_SYN 同步事件，因为每次上报按键事件以后都要同步的上报一个 EV_SYN 事件。</p> </li><li> <p>第 3 行，按键(KEY_0)松开事件。</p> </li><li> <p>第 4 行， EV_SYN 同步事件，和第 2 行一样。</p> </li></ul> 
<h3>三、Linux内核自带按键input设备驱动</h3> 
<p>3.1 自带按键驱动程序源码简析</p> 
<p>        Linux 内核也自带了 KEY 驱动，如果要使用内核自带的 KEY 驱动的话需要配置 Linux 内核，不过 Linux 内核一般默认已经使能了 KEY 驱动，但是我们还是要检查一下。按照如下路径找到相应的配置选项：</p> 
<pre><code class="language-objectivec">-&gt; Device Drivers
    -&gt; Input device support
        -&gt; Generic input layer (needed for keyboard, mouse, ...) (INPUT [=y])
        -&gt; Keyboards (INPUT_KEYBOARD [=y])
                -&gt;GPIO Buttons
</code></pre> 
<p>选中“GPIO Buttons”选项，将其编译进 Linux 内核中【默认是选中的】，如下图所示：</p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/58/be/9QuzY4gm_o.png" alt="bbab636c0f0b06145393dc015436f532.png"></p> 
<p>        选中以后就会在.config 文件中出现“CONFIG_KEYBOARD_GPIO=y”这一行， Linux 内核就会根据这一行来将 KEY 驱动文件编译进 Linux 内核。</p> 
<p>        Linux 内核自带的 KEY 驱动文件为drivers/input/keyboard/gpio_keys.c， gpio_keys.c 采用了 platform 驱动框架，在 KEY 驱动上使用了 input 子系统实现。在 gpio_keys.c 文件中找到如下所示内容：</p> 
<pre><code class="language-objectivec">static const struct of_device_id gpio_keys_of_match[] = {
    { .compatible = "gpio-keys", },
    { },
};
MODULE_DEVICE_TABLE(of, gpio_keys_of_match);

static int gpio_keys_probe(struct platform_device *pdev)
......
static struct platform_driver gpio_keys_device_driver = {
    .probe      = gpio_keys_probe,
    .shutdown   = gpio_keys_shutdown,
    .driver     = {
        .name   = "gpio-keys",
        .pm = &amp;gpio_keys_pm_ops,
        .of_match_table = gpio_keys_of_match,
        .dev_groups = gpio_keys_groups,
    }
};

static int __init gpio_keys_init(void)
{
    return platform_driver_register(&amp;gpio_keys_device_driver);
}

static void __exit gpio_keys_exit(void)
{
    platform_driver_unregister(&amp;gpio_keys_device_driver);
}

late_initcall(gpio_keys_init);
module_exit(gpio_keys_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Phil Blundell &lt;pb@handhelds.org&gt;");
MODULE_DESCRIPTION("Keyboard driver for GPIOs");
MODULE_ALIAS("platform:gpio-keys");
</code></pre> 
<p>        从上面的代码可以看出，这就是一个标准的 platform 驱动框架，如果要使用设备树来描述 KEY 设备信息的话，设备节点的 compatible 属性值要设置为“gpio-keys”。当设备和驱动匹配以后 gpio_keys_probe 函数就会执行， gpio_keys_probe 函数内容如下：</p> 
<pre><code class="language-objectivec">static int gpio_keys_probe(struct platform_device *pdev)
{
    struct device *dev = &amp;pdev-&gt;dev;
    const struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);
    struct fwnode_handle *child = NULL;
    struct gpio_keys_drvdata *ddata;
    struct input_dev *input;
    int i, error;
    int wakeup = 0;

    if (!pdata) {
        pdata = gpio_keys_get_devtree_pdata(dev);
        if (IS_ERR(pdata))
            return PTR_ERR(pdata);
    }
    ......
    input = devm_input_allocate_device(dev);
    if (!input) {
        dev_err(dev, "failed to allocate input device\n");
        return -ENOMEM;
    }

    ddata-&gt;pdata = pdata;
    ddata-&gt;input = input;
    mutex_init(&amp;ddata-&gt;disable_lock);

    platform_set_drvdata(pdev, ddata);
    input_set_drvdata(input, ddata);

    input-&gt;name = pdata-&gt;name ? : pdev-&gt;name;
    input-&gt;phys = "gpio-keys/input0";
    input-&gt;dev.parent = dev;
    input-&gt;open = gpio_keys_open;
    input-&gt;close = gpio_keys_close;

    input-&gt;id.bustype = BUS_HOST;
    input-&gt;id.vendor = 0x0001;
    input-&gt;id.product = 0x0001;
    input-&gt;id.version = 0x0100;

    input-&gt;keycode = ddata-&gt;keymap;
    input-&gt;keycodesize = sizeof(ddata-&gt;keymap[0]);
    input-&gt;keycodemax = pdata-&gt;nbuttons;

    /* Enable auto repeat feature of Linux input subsystem */
    if (pdata-&gt;rep)
        __set_bit(EV_REP, input-&gt;evbit);

    for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {
        const struct gpio_keys_button *button = &amp;pdata-&gt;buttons[i];

        if (!dev_get_platdata(dev)) {
            child = device_get_next_child_node(dev, child);
            if (!child) {
                dev_err(dev,
                    "missing child device node for entry %d\n",
                    i);
                return -EINVAL;
            }
        }

        error = gpio_keys_setup_key(pdev, input, ddata,
                        button, i, child);
        if (error) {
            fwnode_handle_put(child);
            return error;
        }

        if (button-&gt;wakeup)
            wakeup = 1;
    }

    fwnode_handle_put(child);

    error = input_register_device(input);
    if (error) {
        dev_err(dev, "Unable to register input device, error: %d\n",
            error);
        return error;
    }

    device_init_wakeup(dev, wakeup);

    return 0;
}
</code></pre> 
<p>大致可以总结如下：</p> 
<ul><li> <p>调用 gpio_keys_get_devtree_pdata 函数从设备树中获取到 KEY 相关的设备节点信息。</p> </li><li> <p>调用 devm_input_allocate_device 函数申请 input_dev。</p> </li><li> <p>初始化 input_dev。</p> </li><li> <p>设置 input_dev 事件，这里设置了 EV_REP 事件。</p> </li><li> <p>调用 gpio_keys_setup_key 函数继续设置 KEY，此函数会设置 input_dev 的EV_KEY 事件已经事件码(也就是 KEY 模拟为哪个按键)。</p> </li><li> <p>调用 input_register_device 函数向 Linux 系统注册 input_dev。</p> </li></ul> 
<p>接下来再来看一下 gpio_keys_setup_key 函数，此函数内容如下：</p> 
<pre><code class="language-objectivec">static int gpio_keys_setup_key(struct platform_device *pdev,
                struct input_dev *input,
                struct gpio_keys_drvdata *ddata,
                const struct gpio_keys_button *button,
                int idx,
                struct fwnode_handle *child)
{
    const char *desc = button-&gt;desc ? button-&gt;desc : "gpio_keys";
    struct device *dev = &amp;pdev-&gt;dev;
    struct gpio_button_data *bdata = &amp;ddata-&gt;data[idx];
    irq_handler_t isr;
    unsigned long irqflags;
    int irq;
    int error;

    bdata-&gt;input = input;
    bdata-&gt;button = button;
    spin_lock_init(&amp;bdata-&gt;lock);

    if (child) {
        bdata-&gt;gpiod = devm_fwnode_gpiod_get(dev, child,
                             NULL, GPIOD_IN, desc);
        if (IS_ERR(bdata-&gt;gpiod)) {
            error = PTR_ERR(bdata-&gt;gpiod);
            if (error == -ENOENT) {
                /*
                 * GPIO is optional, we may be dealing with
                 * purely interrupt-driven setup.
                 */
                bdata-&gt;gpiod = NULL;
            } else {
                if (error != -EPROBE_DEFER)
                    dev_err(dev, "failed to get gpio: %d\n",
                        error);
                return error;
            }
        }
    } else if (gpio_is_valid(button-&gt;gpio)) {
        /*
         * Legacy GPIO number, so request the GPIO here and
         * convert it to descriptor.
         */
        unsigned flags = GPIOF_IN;

        if (button-&gt;active_low)
            flags |= GPIOF_ACTIVE_LOW;

        error = devm_gpio_request_one(dev, button-&gt;gpio, flags, desc);
        if (error &lt; 0) {
            dev_err(dev, "Failed to request GPIO %d, error %d\n",
                button-&gt;gpio, error);
            return error;
        }

        bdata-&gt;gpiod = gpio_to_desc(button-&gt;gpio);
        if (!bdata-&gt;gpiod)
            return -EINVAL;
        .......
        INIT_DELAYED_WORK(&amp;bdata-&gt;work, gpio_keys_gpio_work_func);

        hrtimer_init(&amp;bdata-&gt;debounce_timer,
                 CLOCK_REALTIME, HRTIMER_MODE_REL);
        bdata-&gt;debounce_timer.function = gpio_keys_debounce_timer;

        isr = gpio_keys_gpio_isr;
        irqflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
        ......
        bdata-&gt;irq = button-&gt;irq;

        if (button-&gt;type &amp;&amp; button-&gt;type != EV_KEY) {
            dev_err(dev, "Only EV_KEY allowed for IRQ buttons.\n");
            return -EINVAL;
        }

        bdata-&gt;release_delay = button-&gt;debounce_interval;
        hrtimer_init(&amp;bdata-&gt;release_timer,
                 CLOCK_REALTIME, HRTIMER_MODE_REL_HARD);
        bdata-&gt;release_timer.function = gpio_keys_irq_timer;

        isr = gpio_keys_irq_isr;
        irqflags = 0;

        /*
         * For IRQ buttons, there is no interrupt for release.
         * So we don't need to reconfigure the trigger type for wakeup.
         */
    }

    bdata-&gt;code = &amp;ddata-&gt;keymap[idx];
    *bdata-&gt;code = button-&gt;code;
    input_set_capability(input, button-&gt;type ?: EV_KEY, *bdata-&gt;code);
    ......
    return 0;
}
</code></pre> 
<p>        调用 input_set_capability 函数设置 EV_KEY 事件以及 KEY 的按键类型，也就是 KEY 作为哪个按键？我们会在设备树里面设置指定的 KEY 作为哪个按键。</p> 
<p>        一切都准备就绪以后剩下的就是等待按键按下，然后向 Linux 内核上报事件，事件上报是在 gpio_keys_irq_isr 函数中完成的，此函数内容如下：</p> 
<pre><code class="language-objectivec">static irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)
{
    struct gpio_button_data *bdata = dev_id;
    struct input_dev *input = bdata-&gt;input;
    unsigned long flags;

    BUG_ON(irq != bdata-&gt;irq);

    spin_lock_irqsave(&amp;bdata-&gt;lock, flags);

    if (!bdata-&gt;key_pressed) {
        if (bdata-&gt;button-&gt;wakeup)
            pm_wakeup_event(bdata-&gt;input-&gt;dev.parent, 0);

        input_event(input, EV_KEY, *bdata-&gt;code, 1);
        input_sync(input);

        if (!bdata-&gt;release_delay) {
            input_event(input, EV_KEY, *bdata-&gt;code, 0);
            input_sync(input);
            goto out;
        }

        bdata-&gt;key_pressed = true;
    }

    if (bdata-&gt;release_delay)
        hrtimer_start(&amp;bdata-&gt;release_timer,
                  ms_to_ktime(bdata-&gt;release_delay),
                  HRTIMER_MODE_REL_HARD);
out:
    spin_unlock_irqrestore(&amp;bdata-&gt;lock, flags);
    return IRQ_HANDLED;
}
</code></pre> 
<p>        gpio_keys_irq_isr 是按键中断处理函数，调用 "input_event" 向 Linux 系统上报 EV_KEY 事件，表示按键按下。调用 "input_sync" 使用 input_sync 函数向系统上报 EV_REP 同步事件。</p> 
<p>        综上所述， Linux 内核自带的 gpio_keys.c 驱动文件思路和前面编写的 input_key.c 驱动文件基本一致。都是申请和初始化 input_dev，设置事件，向 Linux 内核注册 input_dev。最终在按键中断服务函数或者消抖定时器中断服务函数中上报事件和按键值。</p> 
<p>3.2 自带按键驱动程序的使用</p> 
<p>        要使用 Linux 内核自带的按键驱动程序很简单，只需要根据 Documentation/devicetree/bindings/input/gpio-keys.yaml 这个文件在设备树中添加指定的设备节点即可，节点要求如下：</p> 
<ul><li> <p>①、节点名字为“gpio-keys”。</p> </li><li> <p>②、 gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。</p> </li><li>③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述： 
  <ul><li> <p>gpios： KEY 所连接的 GPIO 信息</p> </li><li> <p>interrupts： KEY 所使用 GPIO 中断信息，不是必须的，可以不写</p> </li><li> <p>label： KEY 名字</p> </li><li> <p>linux,code： KEY 要模拟的按键。</p> </li></ul></li><li> <p>④、如果按键要支持连按的话要加入 autorepeat。</p> </li></ul> 
<p>        打开 imx6ul-14x14-evk.dtsi ，根据上面的要求创建对应的设备节点，设备节点内容如下所示：</p> 
<pre><code class="language-objectivec">gpio-keys {
    compatible = "gpio-keys";
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;0&gt;;
    autorepeat;
    
    key0 {
        labal = "GPIO Key Enter";
        linux,code = &lt;KEY_ENTER&gt;;
        gpios = &lt;&amp;gpio1 18 GPIO_ACTIVE_LOW&gt;;
    };
};
</code></pre> 
<ul><li> <p>autorepeat 表示按键支持连按。</p> </li><li> <p>ALPHA 开发板 KEY 按键信息，名字设置为“GPIO Key Enter”，这里我们将开发板上的 KEY 按键设置为“EKY_ENTER”这个按键键值为28，也就是回车键，效果和键盘上的回车键一样。</p> </li><li> <p>设置 KEY 所使用的 IO 为 GPIO1_IO18，一定要检查一下设备树看看此 GPIO 有没有被用到其他外设上，如果有的话要删除掉相关代码！</p> </li></ul> 
<p>3.3 运行测试</p> 
<p>        重新编译设备树，然后用新编译出来的 设备树dtb 启动 Linux 系统，系统启动以后查看/dev/input 目录，看看都有哪些文件，结果如下所示：</p> 
<pre><code class="language-objectivec">/ # ls -al /dev/input/
total 0
drwxr-xr-x    2 0        0               80 Jan 20 00:34 .
drwxr-xr-x    6 0        0             2880 Jan 20 00:34 ..
crw-rw----    1 0        0          13,  64 Jan  1 00:00 event0
crw-rw----    1 0        0          13,  65 Jan 20 00:34 event1
</code></pre> 
<p>从上面可以看出存在 event1 这个文件，这个文件就是 KEY 对应的设备文件，使用hexdump 命令来查看/dev/input/event1 文件，输入如下命令：</p> 
<pre><code class="language-objectivec">hexdump /dev/input/event1
</code></pre> 
<p>然后按下 ALPHA 开发板上的按键，终端输出如下所示内容：</p> 
<pre><code class="language-objectivec">/ # hexdump /dev/input/event1
0000000 157f 0019 80d4 000d 0001 001c 0001 0000
0000010 157f 0019 80d4 000d 0000 0000 0000 0000
0000020 1580 0019 001c 0001 0001 001c 0000 0000
0000030 1580 0019 001c 0001 0000 0000 0000 0000
0000040 1580 0019 f8a0 000b 0001 001c 0001 0000
0000050 1580 0019 f8a0 000b 0000 0000 0000 0000
0000060 1580 0019 0aef 000f 0001 001c 0000 0000
0000070 1580 0019 0aef 000f 0000 0000 0000 0000
0000080 1581 0019 7e19 0009 0001 001c 0001 0000
0000090 1581 0019 7e19 0009 0000 0000 0000 0000
00000a0 1581 0019 30e4 000c 0001 001c 0000 0000
00000b0 1581 0019 30e4 000c 0000 0000 0000 0000
</code></pre> 
<p>        按下 KEY 按键以后会在终端上输出如上所示的信息，表示 Linux 内核的按键驱动工作正常。至于上述中内容的含义就参照前面2.4节中的介绍，进行分析。</p> 
<hr> 
<p><strong><strong>         关于更多嵌入式C语言、FreeRTOS、RT-Thread、Linux应用编程、linux驱动等相关知识，关注公众号【嵌入式Linux知识共享】，后续精彩内容及时收看了解。</strong></strong></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cbeebffc530fc4c271d1ed5e1716f81/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux驱动之INPUT子系统框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76aff4afbb7b88d1f13fa0d91ee8acae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">stm32之串口/蓝牙控制led灯</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>