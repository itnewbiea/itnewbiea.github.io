<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[零基础算法入门①] 双指针法 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[零基础算法入门①] 双指针法" />
<meta property="og:description" content="🎉前言 学习算法肯定不是一条坦途，正如人生的奋斗之路也是异常曲折的，一个多月的摸爬滚打，也终于让我跨入了算法的大门，希望我这一个多月的一点经验积累能对初入算法之门的同学们，起到一点帮助。然而我的个人总结难免有些偏颇且局限，希望读者不吝赐教。
如果觉得一个人难以坚持，不妨加入万人千题打卡社区。百人打卡，你怎么会甘心懈怠呢？ 万人千题打卡社区https://bbs.csdn.net/forums/hero?category=0
🐱‍💻作者概况: 就读南京邮电大学努力学习的大一小伙
🐱‍🐉联系方式：2879377052（QQ小号）
📚资源分享：《算法竞赛入门经典》 （30天有效） 🐱‍👤LeetCode主页：Leetcode 目录 一、案例分析
二、算法详解
三、算法模板
四、实战演练
五、课后练习
一、案例分析 【案例】调整数组使奇数全部都位于偶数前面
【分析】这个问题当然也有很多种解法，但能否只遍历一次数组就满足题目要求呢？我们可以试试双指针——一种简单却实用的方法。
二、算法详解 &gt;: 什么是双指针法?
双指针法：一般是指的在遍历对象的过程中，不是使用单个指针进行访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。
一般双指针法有两种表现方式：
同向移动：在同向移动时，指针移动有快慢之分。相向移动：在相向移动中，双指针一个指针在开头，另外一个指针在结尾，向中间逼近。 回到本题，我们可以采用相向移动的双指针，不妨分别定义为 left 和 right。我们通过双指针实现下面的功能：left指针左边的都是奇数，right指针右边的都是偶数。来看看下面的代码体悟一下吧，读代码的能力也是很重要的。这里就呈现核心代码。
void move(int* arr , int n) { int* left = arr; int* right = arr &#43; n - 1; while (left &lt; right)//(1) { while (left &lt; right &amp;&amp; *left % 2 == 1)//(2) left&#43;&#43;; while (left &lt; right &amp;&amp; *right % 2 == 0)//(3) right--; if (left &lt; right)//(4) { int tmp = *left; *left = *right; *right = tmp; } left&#43;&#43;; right--; } } （1）左右指针相遇之前说明之间还有数没有被查找过，所以循环继续（2）左指针所指向的数为奇数时，则不需要交换继续查找。注意条件left&lt;right,否则可能越界（3）右指针同理，只是找到奇数时才停止查找（4）当左右指针还没相遇时才需要交换 三、算法模板 void move(int* arr , int n) { int* left = arr; int* right = arr &#43; n - 1; while (left &lt; right) { while (left &lt; right &amp;&amp; XXXX) left&#43;&#43;; while (left &lt; right &amp;&amp; XXXX) right--; if (left &lt; right) { int tmp = *left; *left = *right; *right = tmp; } left&#43;&#43;; right--; } } 四、实战演练 温馨提示：Leetcode是接口型的OJ平台，只要封装一个函数实现对应功能就可以了，不需要主函数。可以尝试先点击蓝色链接写题目，写不出来再看分析。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3463326f97e1f2465f4c4540a4a3908e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-08T21:06:15+08:00" />
<meta property="article:modified_time" content="2021-12-08T21:06:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[零基础算法入门①] 双指针法</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>🎉前言</h2> 
<p>        学习算法肯定不是一条坦途，正如人生的奋斗之路也是异常曲折的，一个多月的摸爬滚打，也终于让我跨入了算法的大门，希望我这一个多月的一点经验积累能对初入算法之门的同学们，起到一点帮助。然而我的个人总结难免有些偏颇且局限，希望读者不吝赐教。</p> 
<p>        如果觉得一个人难以坚持，不妨加入万人千题打卡社区。百人打卡，你怎么会甘心懈怠呢？ <a class="link-info has-card" href="https://bbs.csdn.net/forums/hero?category=0" title="万人千题打卡社区"><span class="link-card-box"><span class="link-title">万人千题打卡社区</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f8/bd/mvqyO3j0_o.png" alt="icon-default.png?t=LA92">https://bbs.csdn.net/forums/hero?category=0</span></span></a></p> 
<blockquote> 
 <p>🐱‍💻作者概况:  就读南京邮电大学努力学习的大一小伙</p> 
 <p>🐱‍🐉联系方式：2879377052（QQ小号）</p> 
 <p>📚资源分享：<a class="link-info" href="https://www.aliyundrive.com/s/smPa827rbva" rel="nofollow" title="《算法竞赛入门经典》 （30天有效）">《算法竞赛入门经典》 （30天有效）</a>     </p> 
 <p>🐱‍👤LeetCode主页：<a class="link-info" href="https://leetcode-cn.com/u/xia-xi-uc/" rel="nofollow" title="Leetcode">Leetcode</a>       </p> 
</blockquote> 
<hr> 
<h2 id="%C2%A0%E4%B8%80%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"></h2> 
<h2 id="main-toc"><strong>目录</strong></h2> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90" rel="nofollow" title="一、案例分析">一、案例分析</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3" rel="nofollow" title="二、算法详解">二、算法详解</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF" rel="nofollow" title="三、算法模板">三、算法模板</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83" rel="nofollow" title="四、实战演练">四、实战演练</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0" rel="nofollow" title="五、课后练习">五、课后练习</a></p> 
<hr id="hr-toc"> 
<h2>一、案例分析</h2> 
<blockquote> 
 <p><strong>【案例】调整数组使奇数全部都位于偶数前面</strong></p> 
</blockquote> 
<p> 【分析】这个问题当然也有很多种解法，但能否只遍历一次数组就满足题目要求呢？我们可以试试双指针——一种简单却实用的方法。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">二、算法详解</h2> 
<p><strong>&gt;: 什么是双指针法?</strong></p> 
<blockquote> 
 <p>双指针法：一般是指的在遍历对象的过程中，不是使用单个指针进行访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。</p> 
 <p>一般双指针法有两种表现方式：</p> 
 <ol><li>同向移动：在同向移动时，指针移动有快慢之分。</li><li>相向移动：在相向移动中，双指针一个指针在开头，另外一个指针在结尾，向中间逼近。</li></ol> 
</blockquote> 
<p>回到本题，我们可以采用相向移动的双指针，不妨分别定义为 left 和 right。我们通过双指针实现下面的功能：left指针左边的都是奇数，right指针右边的都是偶数。来看看下面的代码体悟一下吧，读代码的能力也是很重要的。这里就呈现核心代码。</p> 
<pre><code class="language-cpp">void move(int* arr , int n)
{
	int* left = arr;
	int* right = arr + n - 1;
	while (left &lt; right)//(1)
	{
		while (left &lt; right &amp;&amp; *left % 2 == 1)//(2)
			left++;
		while (left &lt; right &amp;&amp; *right % 2 == 0)//(3)
			right--;
		if (left &lt; right)//(4)
		{
			int tmp = *left;
			*left = *right;
			*right = tmp;
		}
		left++;
		right--;
	}
}

</code></pre> 
<ul><li>（1）左右指针相遇之前说明之间还有数没有被查找过，所以循环继续</li><li>（2）左指针所指向的数为奇数时，则不需要交换继续查找。注意条件left&lt;right,否则可能越界</li><li>（3）右指针同理，只是找到奇数时才停止查找</li><li>（4）当左右指针还没相遇时才需要交换</li></ul> 
<p><img alt="" height="281" src="https://images2.imgbox.com/e4/78/XP9RWSjh_o.gif" width="1122"></p> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"> 三、算法模板</h2> 
<pre><code class="language-cpp">void move(int* arr , int n)
{
	int* left = arr;
	int* right = arr + n - 1;
	while (left &lt; right)
	{
		while (left &lt; right &amp;&amp; XXXX)
			left++;
		while (left &lt; right &amp;&amp; XXXX)
			right--;
		if (left &lt; right)
		{
			int tmp = *left;
			*left = *right;
			*right = tmp;
		}
		left++;
		right--;
	}
}

</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83">四、实战演练</h2> 
<p>温馨提示：Leetcode是接口型的OJ平台，只要封装一个函数实现对应功能就可以了，不需要主函数。可以尝试先点击蓝色链接写题目，写不出来再看分析。</p> 
<hr> 
<p> [实战题①<a href="https://leetcode-cn.com/problems/move-zeroes/" rel="nofollow" title="283. 移动零">283. 移动零</a>       难度值：★☆☆☆☆]             </p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/02/79/eXon9RzK_o.png" width="938"></p> 
<p> 【初步分析】因为要保持相对顺序不变，所以我们使用同向快慢指针，实现慢指针内的都是非0元素。</p> 
<pre><code class="language-cpp">void swap(int*a ,int*b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void moveZeroes(int* nums, int numsSize)
{
    int slow = 0;
    int fast = 0;
    while(fast &lt; numsSize)
    {
        if(nums[fast])
        {
            swap(nums + slow, nums + fast);
            slow++;
        }
        fast++;
    }
}</code></pre> 
<p>【思路剖析】fast走的速度肯定 &gt;= slow，而他们之间的差值是0造成的。所以只要fast不是0就赋值给slow。相当于靠fast去找到所有非0元素，而slow只是起一个接收并偏移的作用。</p> 
<hr> 
<p>[实战题②<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" rel="nofollow" title="977. 有序数组的平方">977. 有序数组的平方</a>   难度值：★★☆☆☆ ]</p> 
<p><img alt="" height="295" src="https://images2.imgbox.com/92/d4/WKCsgGnM_o.png" width="946"></p> 
<p> 【初步分析】我们要利用好原数组非递减排序的特点。既然开平方，那我们要分别关注数组两边的最大值和最小值，用双指针从两边同时切入恰到好处。</p> 
<pre><code class="language-cpp">int* sortedSquares(int* nums, int numsSize, int* returnSize)
{
    *returnSize = numsSize;
    int* ans = (int*)malloc(sizeof(int) * numsSize);
    int p1 = 0;
    int p2 = numsSize - 1;
    int index = numsSize - 1;
    while(p1 &lt;= p2)
    {
        if(nums[p1] * nums[p1] &lt; nums[p2] * nums[p2])
        {
            ans[index--] = nums[p2] * nums[p2];
            p2--;
        }
        else
        {
            ans[index--] = nums[p1] * nums[p1];
            p1++;
        }
    }
    return ans;
}</code></pre> 
<p>【思路剖析】</p> 
<p>我们比较容易知道平方后的最大值肯定落在最左边和最右边，因为我们拿左右指针去比较，倒序插入我们动态开辟的数组中去即可。</p> 
<p>【初学者的疑惑】</p> 
<p><strong>1. 写题目只给我们这样的界面，什么意思？</strong></p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/15/fe/H0HMunoW_o.png" width="1094"></p> 
<blockquote> 
 <p><strong> 【答】函数的参数是Leetcode提供的，也就是说我们要利用其所提供的参数来设计我们的功能。note中告诉我们返回的数组必须动态开辟（后面讲），并且我们不需要写任何库函数，也不用在free。</strong></p> 
</blockquote> 
<p><strong>2. returnSize什么用？</strong></p> 
<blockquote> 
 <p><strong>【答】注意到这里是传址调用，也就是在函数中修改会影响主函数中的returnSize，那它到底什么用呢？函数设计而定对不对，编译器就看最后的结果是否和他预设测试用例匹配。你可以想象成后台把你的数据打印出来再比较，那我们的打印循环是不是需要知道数组的长度，不然打印什么时候会停止。</strong></p> 
</blockquote> 
<p><strong>3.为什么需要动态内存分配？</strong></p> 
<blockquote> 
 <p><strong>【答】普通的数组长度必须是一个常量，且开辟在栈区上，栈上数据的特点是出函数销毁，也就是说虽然函数返回了一个指针，但指针指向的空间已经被销毁。但是动态内存分配所开辟的空间开辟在堆区上，堆区的空间一直到程序结束才被销毁，所以我们必须动态内存分配</strong></p> 
</blockquote> 
<p></p> 
<p><strong>4.怎么动态内存分配？</strong></p> 
<blockquote> 
 <p><strong>【答】这里只做简单的解释，详细请看博主之间的学习笔记 :》 <a class="link-info" href="https://blog.csdn.net/whc18858/article/details/120526465">6000字总结动态内存分配</a></strong></p> 
 <p>我们以代码说所展示的开辟例子来说明： int* ans = (int*)malloc(sizeof(int) * numsSize);</p> 
 <p>ans是我们创建的int*变量，接收malloc的返回值。malloc的返回值取决于你开辟什么，所以我们看括号内的内容，表示开辟numsSize个int大小的空间，因为空间存放的数据是int类型的，所以返回的指针是int*类型，也就决定我们的指针是int*类型的。malloc前的强制类型转换最好加上，因为malloc默认返回的是void*类型的数据。</p> 
 <p>具体不太理解没关系，做题的时候只要懂上面说的照做就行了。</p> 
</blockquote> 
<p><img alt="" height="220" src="https://images2.imgbox.com/a8/64/vj4gIEVm_o.png" width="1200"></p> 
<hr> 
<p> [实战题③<a href="https://leetcode-cn.com/problems/reverse-string/" rel="nofollow" title="344. 反转字符串 ">344. 反转字符串 </a>     难度值：★☆☆☆☆]</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/5a/f6/Q6h09Eqa_o.png" width="946"></p> 
<p> 【初步分析】反转字符串中双指针是比较经典的解法。我们采用相向双指针，交换即可。</p> 
<pre><code class="language-cpp">void reverseString(char* s, int sSize)
{
    int p1 = 0;
    int p2 = sSize - 1;
    while(p1 &lt; p2)
    {
        char tmp = s[p1];
        s[p1] = s[p2];
        s[p2] = tmp;
        p1++;
        p2--;
    }
    return s;
}</code></pre> 
<hr> 
<p>[实战题④<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" rel="nofollow" title="876. 链表的中间结点">876. 链表的中间结点</a>   难度值：★☆☆☆☆]</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/d2/28/yzCp6Yfa_o.png" width="916"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p> 【初步分析】大家可能都接触过数组，但对链表不是很熟悉，其实很简单没有那么玄乎，链表和数组都是最基础的数据结构。我们创建一个结构体变量，结构体中有两个元素，val表示他的值，next表示下一个结点的地址，通过next我们找到了下一个结点，我们通过下一个结点的next找到下下个结点，以此类推，将所有结点通过指针串联起来。</p> 
<div> 
 <pre><code class="hljs language-cpp">  <span class="hljs-comment">//Definition for singly-linked list.</span>
  <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span> 
  {
      <span class="hljs-type">int</span> val;
      <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span> *next;
  };</code></pre> 
</div> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span>* <span class="hljs-built_in">middleNode</span>(<span class="hljs-keyword">struct</span> ListNode* head)
{
    <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span>* fast = head;
    <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span>* slow = head;
    <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast -&gt; next != <span class="hljs-literal">NULL</span>)
    {
        fast = fast -&gt; next -&gt; next;
        slow = slow -&gt; next;
    }
    <span class="hljs-keyword">return</span> slow;
}</code></pre> 
</div> 
<p> 【思路剖析】</p> 
<p>在链表中如何实现快慢指针的效果呢？可以有以下两个思路：</p> 
<ol><li>让快指针每次走多步</li><li>让快指针先走</li></ol> 
<p>在这里我们采用的方法是每次让快指针走两步。我们不妨也来比较一下单指针写法，显然用单指针遍历两次是不可少的。</p> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span>* <span class="hljs-built_in">middleNode</span>(<span class="hljs-keyword">struct</span> ListNode* head)
{
    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">struct</span> <span class="class_ hljs-title">ListNode</span>* p = head;
    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)
    {
        p = p -&gt; next;
        cnt++;
    }
    cnt = cnt / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">while</span>(cnt--)
    {
        head = head -&gt; next;
    }
    <span class="hljs-keyword">return</span> head;
}</code></pre> 
</div> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0"> 五、课后练习</h2> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:700px;"><thead><tr><th style="width:58px;">题目序列</th><th style="width:229px;">题目链接</th><th style="width:83px;">题目难度</th><th style="width:328px;">重点思考</th></tr></thead><tbody><tr><td style="width:58px;">（1）</td><td style="width:229px;"> <p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" rel="nofollow" title="167. 两数之和 II - 输入有序数组">167. 两数之和 II - 输入有序数组</a></p> </td><td style="width:83px;">★★☆☆☆</td><td style="width:328px;">使用相向左右指针，如何实现左右指针的推进</td></tr><tr><td style="width:58px;">（2）</td><td style="width:229px;"> <p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" rel="nofollow" title="557. 反转字符串中的单词 III">557. 反转字符串中的单词 III</a></p> </td><td style="width:83px;">★★☆☆☆</td><td style="width:328px;">如何确定它是一个单词的结束</td></tr><tr><td style="width:58px;">（3）</td><td style="width:229px;"> <p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" rel="nofollow" title="19. 删除链表的倒数第 N 个结点">876. 链表的中间结点</a></p> </td><td style="width:83px;">★★☆☆☆</td><td style="width:328px;">如何使用双指针</td></tr></tbody></table> 
<p><a class="link-info" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/shua-bao-leetcode-shuang-zhi-zhen-fa-xia-c9wq/" rel="nofollow">题（1）参考题解</a></p> 
<p><a class="link-info" href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/shua-bao-leetcode-shuang-zhi-zhen-fa-by-y7gqw/" rel="nofollow">题（2）参考题解</a></p> 
<p><a class="link-info" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shua-bao-leetcode-shuang-zhi-zhen-fa-ya-mk574/" rel="nofollow">题（3）参考题解</a></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2e4ad6309d3495a427ae4d0dc9c0ae0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle进阶篇之查看执行计划</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f9656e9c4b25b3ebed6248e79d1974a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue中引入animate.css</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>