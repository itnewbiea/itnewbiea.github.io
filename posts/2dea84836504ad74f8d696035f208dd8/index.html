<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dockerfile文件详细介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dockerfile文件详细介绍" />
<meta property="og:description" content="一、关于Dockerfile
1.Dockerfile介绍
官网中的介绍： Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image。
Dockerfile 是一个文本文件，里面包含组装新镜像时用到的基础镜像和各种指令。
使用dockerfile 文件来定义镜像，然后运行镜像，启动容器。
2.Dockerfile文件的组成部分
一个dockerfile文件包含以下部分：
基础镜像信息： 使用FROM关键字指定基础镜像信息，FROM是dockerfile文件的第一条指令。维护者信息： 使用MAINTAINER关键字指定，通常可以使用dockerfile文件创建者的名字或者邮件作为维护者的信息。镜像操作指令： 没执行一条镜像操作指令，都会在镜像中添加新的一层。容器启动执行命令： 用户指定在启动容器时需要执行的命令，通过：CMD ENTRYPOINT指定 常见的镜像操作指令：
指令描述FROM# 基础镜像，一切从这里开始构建MAINTAINER镜像是谁写的，姓名&#43;邮箱RUN镜像构建的时候需要运行的命令ADD添加内容： 比如加一个tomcat压缩包WORKDIR镜像的工作目录VOLUME镜像挂载的目录EXPOSE保留暴露的端口CMD指定这个容器启动的时候要运行的命令，只有最后一个会生效，可以被代替ENTRYPOINT指定这个容器启动的时候需要运行的命令，可以追加命令ONBUILD当构建一个被继承DockerFile 的时候就会运行 ONBUILD 的指令。触发指令COPY类似ADD ，将我们的文件拷贝到镜像中ENV构建的时候设置环境变量 3.Dockerfile的执行
在完成dockerfile文件的编写后，执行docker build命令，则会根据dockerfile文件中上下文的内容构建新的docker镜像。
整个构建过程会被递归处理，如果在dockerfile中包含了路径或者URL，都会被递归构建。
二、Docker bulid命令介绍
docker build 命令用于使用 Dockerfile 创建镜像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2dea84836504ad74f8d696035f208dd8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-24T16:50:42+08:00" />
<meta property="article:modified_time" content="2023-07-24T16:50:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dockerfile文件详细介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、关于Dockerfile</p> 
<p>1.Dockerfile介绍</p> 
<p>官网中的介绍： Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image。</p> 
<p>Dockerfile 是一个文本文件，里面包含组装新镜像时用到的基础镜像和各种指令。</p> 
<p>使用dockerfile 文件来定义镜像，然后运行镜像，启动容器。</p> 
<p>2.Dockerfile文件的组成部分</p> 
<p>一个dockerfile文件包含以下部分：</p> 
<ul><li>基础镜像信息： 使用FROM关键字指定基础镜像信息，FROM是dockerfile文件的第一条指令。</li><li>维护者信息： 使用MAINTAINER关键字指定，通常可以使用dockerfile文件创建者的名字或者邮件作为维护者的信息。</li><li>镜像操作指令： 没执行一条镜像操作指令，都会在镜像中添加新的一层。</li><li>容器启动执行命令： 用户指定在启动容器时需要执行的命令，通过：CMD ENTRYPOINT指定</li></ul> 
<p>常见的镜像操作指令：</p> 
<table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>FROM</td><td># 基础镜像，一切从这里开始构建</td></tr><tr><td>MAINTAINER</td><td>镜像是谁写的，姓名+邮箱</td></tr><tr><td>RUN</td><td>镜像构建的时候需要运行的命令</td></tr><tr><td>ADD</td><td>添加内容： 比如加一个tomcat压缩包</td></tr><tr><td>WORKDIR</td><td>镜像的工作目录</td></tr><tr><td>VOLUME</td><td>镜像挂载的目录</td></tr><tr><td>EXPOSE</td><td>保留暴露的端口</td></tr><tr><td>CMD</td><td>指定这个容器启动的时候要运行的命令，只有最后一个会生效，可以被代替</td></tr><tr><td>ENTRYPOINT</td><td>指定这个容器启动的时候需要运行的命令，可以追加命令</td></tr><tr><td>ONBUILD</td><td>当构建一个被继承DockerFile 的时候就会运行 ONBUILD 的指令。触发指令</td></tr><tr><td>COPY</td><td>类似ADD ，将我们的文件拷贝到镜像中</td></tr><tr><td>ENV</td><td>构建的时候设置环境变量</td></tr></tbody></table> 
<p>3.Dockerfile的执行</p> 
<p>在完成dockerfile文件的编写后，执行docker build命令，则会根据dockerfile文件中上下文的内容构建新的docker镜像。</p> 
<p>整个构建过程会被递归处理，如果在dockerfile中包含了路径或者URL，都会被递归构建。</p> 
<p>二、Docker bulid命令介绍</p> 
<p>docker build 命令用于使用 Dockerfile 创建镜像</p> 
<p>语法：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> </td><td> <p><code>docker build [OPTIONS] PATH | URL | -</code></p> </td></tr></tbody></table> 
<p>常用参数：</p> 
<table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>–build-arg=[]</td><td>设置镜像创建时的变量；</td></tr><tr><td>–cpu-shares</td><td>设置 cpu 使用权重；</td></tr><tr><td>–cpu-period</td><td>限制 CPU CFS周期；</td></tr><tr><td>–cpu-quota</td><td>限制 CPU CFS配额；</td></tr><tr><td>–cpuset-cpus</td><td>指定使用的CPU id；</td></tr><tr><td>–cpuset-mems</td><td>指定使用的内存 id；</td></tr><tr><td>–disable-content-trust</td><td>忽略校验，默认开启；</td></tr><tr><td>-f</td><td>指定要使用的Dockerfile路径；</td></tr><tr><td>–force-rm</td><td>设置镜像过程中删除中间容器；</td></tr><tr><td>–isolation</td><td>使用容器隔离技术；</td></tr><tr><td>–label=[]</td><td>设置镜像使用的元数据；</td></tr><tr><td>-m</td><td>设置内存最大值；</td></tr><tr><td>–memory-swap</td><td>设置Swap的最大值为内存+swap，"-1"表示不限swap；</td></tr><tr><td>–no-cache</td><td>创建镜像的过程不使用缓存；</td></tr><tr><td>–pull</td><td>尝试去更新镜像的新版本；</td></tr><tr><td>–quiet, -q</td><td>安静模式，成功后只输出镜像 ID；</td></tr><tr><td>–rm</td><td>设置镜像成功后删除中间容器；</td></tr><tr><td>–shm-size</td><td>设置/dev/shm的大小，默认值是64M；</td></tr><tr><td>–ulimit</td><td>Ulimit配置。</td></tr><tr><td>–squash</td><td>将 Dockerfile 中所有的操作压缩为一层。</td></tr><tr><td>–tag, -t:</td><td>镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</td></tr><tr><td>–network:</td><td>默认 default。在构建期间设置RUN指令的网络模式</td></tr></tbody></table> 
<h3 id="heading-5">三、使用dockerfile构建镜像实战</h3> 
<p> </p> 
<p><strong>编写一个简单的centos镜像</strong></p> 
<p>在本地创建一个文件名为Dockerfile的文件</p> 
<ul><li>代码如下 <pre><code class="hljs">FROM centos:7.9.2009
# 指定基础镜像为 centos
MAINTAINER  mufenggrow mufenggrow@163.com
ENV  MYPATH  /usr/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE  80
 
CMD echo $MYPATH
CMD echo "-----end-----"
CMD /bin/bash</code></pre> <p></p> </li><li>构建并测试<br> 通过命令构建镜像 最后有个 <code>.</code>语法如下：</li><li> <p><code> docker build -f dockerfile 文件名 -t 镜像名:[tag] .</code></p> <p>测试：</p> <p>因为最开始我们创建的文件名叫<code>Dockerfile</code>所以，不需要使用<code>-f </code>参数</p> </li><li> <pre><code class="hljs">[root@mufenggrow ~]# ls
anaconda-ks.cfg  Dockerfile 

[root@mufenggrow ~]# docker build -t mufeng_centos .
</code></pre> <pre><code class="hljs">[root@mufenggrow ~]# docker images
REPOSITORY      TAG        IMAGE ID       CREATED         SIZE
mufeng_centos   latest     5233b48a8b4e   9 seconds ago   667MB
centos          7.9.2009   eeb6ee3f44bd   19 months ago   204MB

</code></pre> </li><li>启动测试，查看是否有ifconfig命令 <pre><code class="hljs">[root@mufenggrow ~]# ls
anaconda-ks.cfg  Dockerfile  initial-setup-ks.cfg  公共  模板  视频  图片  文档  下载  音乐  桌面
[root@mufenggrow ~]# docker run -itd mufeng_centos /bin/bash
0801e25a61e5999b1616d1f0073f39a7e5431e34d983445b3f349b7da6bf3fe6
[root@mufenggrow ~]# docker exec -it 0801e25a /bin/bash
[root@0801e25a61e5 local]# pwd
/usr/local
[root@0801e25a61e5 local]# ifconfig
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 8  bytes 656 (656.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre> <p></p> </li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/09ef18005fd6de103e2d8b3ec1753d5a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Jtti：mysql数据库删除数据怎么恢复</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28c5a5147bd06df6766292ec44159f4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker存储（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>