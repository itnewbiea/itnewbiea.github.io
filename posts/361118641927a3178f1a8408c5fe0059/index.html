<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【netty源码之ChannelHandlerContext】 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【netty源码之ChannelHandlerContext】" />
<meta property="og:description" content="netty源码之ChannelHandlerContext 一、ChannelHandlerContext是什么？二、ChannelHandlerContext的API1、channel()、pipeline()、handler()、alloc()、executor()2、fire类方法3、read()4、write() 三、骨架类AbstractChannelHandlerContext1、alloc()方法2、read()方法3、write方法 四、实现类HeadContext1、read()方法2、write()方法3、channelActive()方法 五、实现类TailContext1、channelRead()方法 六、实现类DefaultChannelHandlerContext 一、ChannelHandlerContext是什么？ ChannelHandlerContext代表了ChannelHandler和ChannelPipline之间的关联，每当有一个ChannelHandler添加到ChannelPipline中时，都会创建一个ChannelHandlerContext。主要功能是管理它所关联的ChannelHandler和在同一个ChannelPipline中的其他ChannelHandler之间的交互。
二、ChannelHandlerContext的API 1、channel()、pipeline()、handler()、alloc()、executor() 返回该ChannelHandlerContext绑定的各种组件。
2、fire类方法 触发对pipeline上下一个ChannelInBoundHandler上的对应方法的调用。
3、read() 将数据从Channel读取到第一个入站缓冲区；如果读取成功则触发一个channelRead事件，并在最后一个消息被读取完成后通知ChannelInBoundHandler的channelReadComplete(ctx)方法。
4、write() 通过该ctx写入消息。
三、骨架类AbstractChannelHandlerContext 在AbstractChannelHandlerContext类中实现了ChannelHandlerContext的绝大多数方法逻辑。
1、alloc()方法 通过pipeline获取channel，再获取到对应的ChannelConfig，调用DefaultChannelConfig的getAllocator()方法。
private volatile ByteBufAllocator allocator = ByteBufAllocator.DEFAULT; ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR; 可以看到，只有android是默认使用unpooled的，其他均使用pooled。
alloc = PooledByteBufAllocator.DEFAULT; public static final PooledByteBufAllocator DEFAULT = new PooledByteBufAllocator(PlatformDependent.directBufferPreferred()); 至此，我们看到默认的分配器是PooledByteBufAllocator。
2、read()方法 首先会寻找下一个出站处理器，然后取其线程调用其read方法。其实普通的ctx在read的时候就是做了一个传递，真正有执行逻辑的就是pipeline的最后一个出站处理器，也就是HeadContext。接第四节第1个方法描述。
3、write方法 注意到，在进行基础检验或者发生异常时，调用了ReferenceCountUtil.release(msg)方法进行内存释放。
接下来就如出一辙了，沿着出站处理器往下传递，直到最后一个HeadContext。
4、file类方法fireChannelRead()方法
找到下一个进站处理器，触发对应方法的调用。
四、实现类HeadContext pipeline中的第一个ctx，既是入站处理器，也是出站处理器。
1、read()方法 调用了unsafe的beginRead方法。
这个unsafe是channel的unsafe。
该方法在AbstractChannel中实现。调用了钩子方法doBeginRead。我们进AbstractNioChannel类继续追踪
最终是给该channel在selector上注册了读事件。
2、write()方法 同样也是调用了unsafe的write方法。
可以看到是把数据写到了出站缓冲区中。
3、channelActive()方法 除了向后传递，还调用了readIfIsAutoRead()方法。
这个方法也很简单，调用了channel的read方法，最终调用了HeadContext的read方法，也就是本节介绍的第1个方法，为该channel注册了读事件。
五、实现类TailContext pipeline中的最后一个ctx，入站处理器链的最后一个节点。
1、channelRead()方法 看到仅仅是调用了DefaultChannelPipline的onUnhandledInboundMessage()方法。
在这个方法中，只是打印了日志，并对内存进行了释放。这就告诉我们，在我们自定义实现的inBoundHandler中，只要我们调用file方法把msg传递下去，netty已经给我们做好了内存回收，不用担心内存泄露问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/361118641927a3178f1a8408c5fe0059/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-07T18:18:16+08:00" />
<meta property="article:modified_time" content="2022-06-07T18:18:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【netty源码之ChannelHandlerContext】</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>netty源码之ChannelHandlerContext</h4> 
 <ul><li><ul><li><a href="#ChannelHandlerContext_1" rel="nofollow">一、ChannelHandlerContext是什么？</a></li><li><a href="#ChannelHandlerContextAPI_4" rel="nofollow">二、ChannelHandlerContext的API</a></li><li><ul><li><a href="#1channelpipelinehandlerallocexecutor_6" rel="nofollow">1、channel()、pipeline()、handler()、alloc()、executor()</a></li><li><a href="#2fire_8" rel="nofollow">2、fire类方法</a></li><li><a href="#3read_10" rel="nofollow">3、read()</a></li><li><a href="#4write_12" rel="nofollow">4、write()</a></li></ul> 
   </li><li><a href="#AbstractChannelHandlerContext_14" rel="nofollow">三、骨架类AbstractChannelHandlerContext</a></li><li><ul><li><a href="#1alloc_16" rel="nofollow">1、alloc()方法</a></li><li><a href="#2read_40" rel="nofollow">2、read()方法</a></li><li><a href="#3write_43" rel="nofollow">3、write方法</a></li></ul> 
   </li><li><a href="#HeadContext_51" rel="nofollow">四、实现类HeadContext</a></li><li><ul><li><a href="#1read_53" rel="nofollow">1、read()方法</a></li><li><a href="#2write_63" rel="nofollow">2、write()方法</a></li><li><a href="#3channelActive_68" rel="nofollow">3、channelActive()方法</a></li></ul> 
   </li><li><a href="#TailContext_73" rel="nofollow">五、实现类TailContext</a></li><li><ul><li><a href="#1channelRead_75" rel="nofollow">1、channelRead()方法</a></li></ul> 
   </li><li><a href="#DefaultChannelHandlerContext_80" rel="nofollow">六、实现类DefaultChannelHandlerContext</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="ChannelHandlerContext_1"></a>一、ChannelHandlerContext是什么？</h3> 
<p>ChannelHandlerContext代表了ChannelHandler和ChannelPipline之间的关联，每当有一个ChannelHandler添加到ChannelPipline中时，都会创建一个ChannelHandlerContext。主要功能是管理它所关联的ChannelHandler和在同一个ChannelPipline中的其他ChannelHandler之间的交互。<br> <img src="https://images2.imgbox.com/46/a7/IBmAz9AH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="ChannelHandlerContextAPI_4"></a>二、ChannelHandlerContext的API</h3> 
<p><img src="https://images2.imgbox.com/87/11/vJLb2jVD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1channelpipelinehandlerallocexecutor_6"></a>1、channel()、pipeline()、handler()、alloc()、executor()</h4> 
<p>返回该ChannelHandlerContext绑定的各种组件。</p> 
<h4><a id="2fire_8"></a>2、fire类方法</h4> 
<p>触发对pipeline上下一个ChannelInBoundHandler上的对应方法的调用。</p> 
<h4><a id="3read_10"></a>3、read()</h4> 
<p>将数据从Channel读取到第一个入站缓冲区；如果读取成功则触发一个channelRead事件，并在最后一个消息被读取完成后通知ChannelInBoundHandler的channelReadComplete(ctx)方法。</p> 
<h4><a id="4write_12"></a>4、write()</h4> 
<p>通过该ctx写入消息。</p> 
<h3><a id="AbstractChannelHandlerContext_14"></a>三、骨架类AbstractChannelHandlerContext</h3> 
<p>在AbstractChannelHandlerContext类中实现了ChannelHandlerContext的绝大多数方法逻辑。</p> 
<h4><a id="1alloc_16"></a>1、alloc()方法</h4> 
<p><img src="https://images2.imgbox.com/70/22/i0b8QeoO_o.png" alt="在这里插入图片描述"><br> 通过pipeline获取channel，再获取到对应的ChannelConfig，调用DefaultChannelConfig的getAllocator()方法。<br> <img src="https://images2.imgbox.com/19/56/0zpAiEq8_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> <span class="token class-name">ByteBufAllocator</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token class-name">ByteBufAllocator</span> DEFAULT <span class="token operator">=</span> <span class="token class-name">ByteBufUtil</span><span class="token punctuation">.</span>DEFAULT_ALLOCATOR<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/75/f0/UOf27ege_o.png" alt="在这里插入图片描述"><br> 可以看到，只有android是默认使用unpooled的，其他均使用pooled。</p> 
<pre><code class="prism language-java">alloc <span class="token operator">=</span> <span class="token class-name">PooledByteBufAllocator</span><span class="token punctuation">.</span>DEFAULT<span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">PooledByteBufAllocator</span> DEFAULT <span class="token operator">=</span>
            <span class="token keyword">new</span> <span class="token class-name">PooledByteBufAllocator</span><span class="token punctuation">(</span><span class="token class-name">PlatformDependent</span><span class="token punctuation">.</span><span class="token function">directBufferPreferred</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>至此，我们看到默认的分配器是PooledByteBufAllocator。</p> 
<h4><a id="2read_40"></a>2、read()方法</h4> 
<p><img src="https://images2.imgbox.com/ef/24/7cse9pEk_o.png" alt="在这里插入图片描述"><br> 首先会寻找下一个出站处理器，然后取其线程调用其read方法。其实普通的ctx在read的时候就是做了一个传递，真正有执行逻辑的就是pipeline的最后一个出站处理器，也就是HeadContext。接第四节第1个方法描述。</p> 
<h4><a id="3write_43"></a>3、write方法</h4> 
<p><img src="https://images2.imgbox.com/d4/7e/mRar8FVN_o.png" alt="在这里插入图片描述"><br> 注意到，在进行基础检验或者发生异常时，调用了ReferenceCountUtil.release(msg)方法进行内存释放。<br> <img src="https://images2.imgbox.com/94/92/ZqMDg91w_o.png" alt="在这里插入图片描述"><br> 接下来就如出一辙了，沿着出站处理器往下传递，直到最后一个HeadContext。<br> 4、file类方法fireChannelRead()方法<br> <img src="https://images2.imgbox.com/32/66/z8TMdjln_o.png" alt="在这里插入图片描述"><br> 找到下一个进站处理器，触发对应方法的调用。</p> 
<h3><a id="HeadContext_51"></a>四、实现类HeadContext</h3> 
<p>pipeline中的第一个ctx，既是入站处理器，也是出站处理器。</p> 
<h4><a id="1read_53"></a>1、read()方法</h4> 
<p><img src="https://images2.imgbox.com/d9/1e/wB9ycEya_o.png" alt="在这里插入图片描述"><br> 调用了unsafe的beginRead方法。<br> <img src="https://images2.imgbox.com/a5/99/cILKnNZP_o.png" alt="在这里插入图片描述"><br> 这个unsafe是channel的unsafe。</p> 
<p><img src="https://images2.imgbox.com/24/45/BPikroTl_o.png" alt="在这里插入图片描述"><br> 该方法在AbstractChannel中实现。调用了钩子方法doBeginRead。我们进AbstractNioChannel类继续追踪<br> <img src="https://images2.imgbox.com/07/1e/rmgCPijd_o.png" alt="在这里插入图片描述"><br> 最终是给该channel在selector上注册了读事件。</p> 
<h4><a id="2write_63"></a>2、write()方法</h4> 
<p><img src="https://images2.imgbox.com/3a/a9/xUVE3O3x_o.png" alt="在这里插入图片描述"><br> 同样也是调用了unsafe的write方法。<br> <img src="https://images2.imgbox.com/e5/60/pGc9TEJy_o.png" alt="在这里插入图片描述"><br> 可以看到是把数据写到了出站缓冲区中。</p> 
<h4><a id="3channelActive_68"></a>3、channelActive()方法</h4> 
<p><img src="https://images2.imgbox.com/c6/19/VasQmheV_o.png" alt="在这里插入图片描述"><br> 除了向后传递，还调用了readIfIsAutoRead()方法。<br> <img src="https://images2.imgbox.com/42/18/EBBNu7Fy_o.png" alt="在这里插入图片描述"><br> 这个方法也很简单，调用了channel的read方法，最终调用了HeadContext的read方法，也就是本节介绍的第1个方法，为该channel注册了读事件。</p> 
<h3><a id="TailContext_73"></a>五、实现类TailContext</h3> 
<p>pipeline中的最后一个ctx，入站处理器链的最后一个节点。</p> 
<h4><a id="1channelRead_75"></a>1、channelRead()方法</h4> 
<p><img src="https://images2.imgbox.com/ab/89/SCSS2RDA_o.png" alt="在这里插入图片描述"><br> 看到仅仅是调用了DefaultChannelPipline的onUnhandledInboundMessage()方法。<br> <img src="https://images2.imgbox.com/23/57/i1lRuVwe_o.png" alt="在这里插入图片描述"><br> 在这个方法中，只是打印了日志，并对内存进行了释放。这就告诉我们，在我们自定义实现的inBoundHandler中，只要我们调用file方法把msg传递下去，netty已经给我们做好了内存回收，不用担心内存泄露问题。</p> 
<h3><a id="DefaultChannelHandlerContext_80"></a>六、实现类DefaultChannelHandlerContext</h3> 
<p><img src="https://images2.imgbox.com/14/9e/5rBwmFSu_o.png" alt="在这里插入图片描述"><br> 可以看到在该类中并没有过多的方法实现，这也就是netty的设计思想，尽量在Abstract类中把该实现的都实现了。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/919f655318f20f833ff8df2ed50aadd3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win10搭建gym运行atari游戏pong</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59f091df4f2df29f21039530dc91cbff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java中事务</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>