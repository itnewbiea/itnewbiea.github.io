<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spark读取数据库(Mysql)的四种方式讲解 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spark读取数据库(Mysql)的四种方式讲解" />
<meta property="og:description" content="目前Spark支持四种方式从数据库中读取数据，这里以Mysql为例进行介绍。
一、不指定查询条件 这个方式链接MySql的函数原型是：
def jdbc(url: String, table: String, properties: Properties): DataFrame 我们只需要提供Driver的url，需要查询的表名，以及连接表相关属性properties。下面是具体例子：
val url = &#34;jdbc:mysql://www.iteblog.com:3306/iteblog?user=iteblog&amp;password=iteblog&#34; val prop = new Properties() val df = sqlContext.read.jdbc(url, &#34;iteblog&#34;, prop ) println(df.count()) println(df.rdd.partitions.size) 我们运行上面的程序，可以看到df.rdd.partitions.size输出结果是1，这个结果的含义是iteblog表的所有数据都是由RDD的一个分区处理的，所以说，如果你这个表很大，很可能会出现OOM
WARN TaskSetManager: Lost task 0.0 in stage 1.0 (TID 14, spark047219): java.lang.OutOfMemoryError: GC overhead limit exceeded at com.mysql.jdbc.MysqlIO.reuseAndReadPacket(MysqlIO.java:3380) 这种方式在数据量大的时候不建议使用。
二、指定数据库字段的范围 这种方式就是通过指定数据库中某个字段的范围，但是遗憾的是，这个字段必须是数字，来看看这个函数的函数原型：
def jdbc( url: String, table: String, columnName: String, lowerBound: Long, upperBound: Long, numPartitions: Int, connectionProperties: Properties): DataFrame 前两个字段的含义和方法一类似。columnName就是需要分区的字段，这个字段在数据库中的类型必须是数字；lowerBound就是分区的下界；upperBound就是分区的上界；numPartitions是分区的个数。同样，我们也来看看如何使用：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/155bfb385c6860474bc7876e49ce13b4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-12-30T09:53:21+08:00" />
<meta property="article:modified_time" content="2015-12-30T09:53:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spark读取数据库(Mysql)的四种方式讲解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>目前Spark支持四种方式从数据库中读取数据，这里以Mysql为例进行介绍。</p> 
<h3 id="一不指定查询条件">一、不指定查询条件</h3> 
<p>这个方式链接MySql的函数原型是：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jdbc</span><span class="hljs-params">(url: String, table: String, properties: Properties)</span>:</span> DataFrame</code></pre> 
<p>　　我们只需要提供Driver的url，需要查询的表名，以及连接表相关属性properties。下面是具体例子：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">val url = <span class="hljs-string">"jdbc:mysql://www.iteblog.com:3306/iteblog?user=iteblog&amp;password=iteblog"</span>
val prop = new Properties()
val df = sqlContext<span class="hljs-preprocessor">.read</span><span class="hljs-preprocessor">.jdbc</span>(url, <span class="hljs-string">"iteblog"</span>, prop )
println(df<span class="hljs-preprocessor">.count</span>())
println(df<span class="hljs-preprocessor">.rdd</span><span class="hljs-preprocessor">.partitions</span><span class="hljs-preprocessor">.size</span>)</code></pre> 
<p>　　我们运行上面的程序，可以看到df.rdd.partitions.size输出结果是1，这个结果的含义是iteblog表的所有数据都是由RDD的一个分区处理的，所以说，如果你这个表很大，很可能会出现OOM</p> 
<pre class="prettyprint"><code class=" hljs avrasm">WARN TaskSetManager: Lost task <span class="hljs-number">0.0</span> <span class="hljs-keyword">in</span> stage <span class="hljs-number">1.0</span> (TID <span class="hljs-number">14</span>, spark047219):
 java<span class="hljs-preprocessor">.lang</span><span class="hljs-preprocessor">.OutOfMemoryError</span>: GC overhead limit exceeded at <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.mysql</span><span class="hljs-preprocessor">.jdbc</span><span class="hljs-preprocessor">.MysqlIO</span><span class="hljs-preprocessor">.reuseAndReadPacket</span>(MysqlIO<span class="hljs-preprocessor">.java</span>:<span class="hljs-number">3380</span>)</code></pre> 
<p>这种方式在数据量大的时候不建议使用。</p> 
<h3 id="二指定数据库字段的范围">二、指定数据库字段的范围</h3> 
<p>　　这种方式就是通过指定数据库中某个字段的范围，但是遗憾的是，这个字段必须是数字，来看看这个函数的函数原型：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jdbc</span><span class="hljs-params">(
    url: String,
    table: String,
    columnName: String,
    lowerBound: Long,
    upperBound: Long,
    numPartitions: Int,
    connectionProperties: Properties)</span>:</span> DataFrame</code></pre> 
<p>　　前两个字段的含义和方法一类似。columnName就是需要分区的字段，这个字段在数据库中的类型必须是数字；lowerBound就是分区的下界；upperBound就是分区的上界；numPartitions是分区的个数。同样，我们也来看看如何使用：</p> 
<pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-keyword">val</span> lowerBound = <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> upperBound = <span class="hljs-number">100000</span>
<span class="hljs-keyword">val</span> numPartitions = <span class="hljs-number">5</span>
<span class="hljs-keyword">val</span> url = <span class="hljs-string">"jdbc:mysql://www.iteblog.com:3306/iteblog?user=iteblog&amp;password=iteblog"</span>
<span class="hljs-keyword">val</span> prop = <span class="hljs-keyword">new</span> Properties()
<span class="hljs-keyword">val</span> df = sqlContext.read.jdbc(url, <span class="hljs-string">"iteblog"</span>, <span class="hljs-string">"id"</span>, lowerBound, upperBound, numPartitions, prop)</code></pre> 
<p>　　这个方法可以将iteblog表的数据分布到RDD的几个分区中，分区的数量由numPartitions参数决定，在理想情况下，每个分区处理相同数量的数据，我们在使用的时候不建议将这个值设置的比较大，因为这可能导致数据库挂掉！但是根据前面介绍，这个函数的缺点就是只能使用整形数据字段作为分区关键字。</p> 
<p>　　这个函数在极端情况下，也就是设置将numPartitions设置为1，其含义和第一种方式一致。</p> 
<h3 id="三根据任意字段进行分区">三、根据任意字段进行分区</h3> 
<p>　　基于前面两种方法的限制，Spark还提供了根据任意字段进行分区的方法，函数原型如下：</p> 
<pre class="prettyprint"><code class=" hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jdbc</span><span class="hljs-params">(
    url: String,
    table: String,
    predicates: Array[String],
    connectionProperties: Properties)</span>:</span> DataFrame</code></pre> 
<p>这个函数相比第一种方式多了predicates参数，我们可以通过这个参数设置分区的依据，来看看例子：</p> 
<p>查看源代码打印帮助</p> 
<pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-keyword">val</span> predicates = Array[String](<span class="hljs-string">"reportDate &lt;= '2014-12-31'"</span>,
    <span class="hljs-string">"reportDate &gt; '2014-12-31' and reportDate &lt;= '2015-12-31'"</span>)
<span class="hljs-keyword">val</span> url = <span class="hljs-string">"jdbc:mysql://www.iteblog.com:3306/iteblog?user=iteblog&amp;password=iteblog"</span>
<span class="hljs-keyword">val</span> prop = <span class="hljs-keyword">new</span> Properties()
<span class="hljs-keyword">val</span> df = sqlContext.read.jdbc(url, <span class="hljs-string">"iteblog"</span>, predicates, prop)</code></pre> 
<p>最后rdd的分区数量就等于predicates.length。</p> 
<h3 id="四通过load获取">四、通过load获取</h3> 
<p>Spark还提供通过load的方式来读取数据。</p> 
<pre class="prettyprint"><code class=" hljs avrasm">sqlContext<span class="hljs-preprocessor">.read</span><span class="hljs-preprocessor">.format</span>(<span class="hljs-string">"jdbc"</span>)<span class="hljs-preprocessor">.options</span>(
  Map(<span class="hljs-string">"url"</span> -&gt; <span class="hljs-string">"jdbc:mysql://www.iteblog.com:3306/iteblog?user=iteblog&amp;password=iteblog"</span>,
    <span class="hljs-string">"dbtable"</span> -&gt; <span class="hljs-string">"iteblog"</span>))<span class="hljs-preprocessor">.load</span>()</code></pre> 
<p>　　options函数支持url、driver、dbtable、partitionColumn、lowerBound、upperBound以及numPartitions选项，细心的同学肯定发现这个和方法二的参数一致。是的，其内部实现原理部分和方法二大体一致。同时load方法还支持json、orc等数据源的读取。</p> 
<p>本博客文章除特别声明，全部都是原创！ <br> 尊重原创，转载请注明： 转载自过往记忆（<a href="http://www.iteblog.com/" rel="nofollow">http://www.iteblog.com/</a>） <br> 本文链接地址: 【Spark读取数据库(Mysql)的四种方式讲解】（<a href="http://www.iteblog.com/archives/1560" rel="nofollow">http://www.iteblog.com/archives/1560</a>）</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4cd7269cadc745fda61486afb4b14883/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bitnami 版 gitlab 修改端口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4f4b857385120f5dc3169f144915fc46/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Caffe学习系列(17)：模型各层特征和过滤器可视化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>