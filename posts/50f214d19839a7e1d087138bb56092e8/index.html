<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>下一代的多语言JVM：GraalVM - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="下一代的多语言JVM：GraalVM" />
<meta property="og:description" content="GraalVM是一款高性能的可嵌入式多语言虚拟机，它能运行不同的编程语言，包括：
基于JVM的语言，比如Java, Scala, Kotlin和Groovy解释型语言，比如JavaScript, Ruby, R和Python配合LLVM一起工作的原生语言，比如C， C&#43;&#43;， Rust和Swift GraalVM能有效地支持多语言应用，你可以在一个进程里同时使用多种编程语言而不会带来明显的性能开销——这样你就可以根据具体问题来选择不同语言的解决方案了。
GraalVM的设计目标是可以在不同的环境中运行程序：在JVM中、或者编译成独立的本地镜像、亦或是将Java及本地代码模块集成为更大型的应用。本文先简单介绍下GraalVM能干什么、如何开始使用它以及有哪些需要特别关注的点。
GraalVM的组件 GraalVM是一个大型项目，它有很多可插拔的组件，这使得它几乎无所不能。随便列举几点，它可以更快地运行Java程序，可以取代Nashorn来运行Node.js程序，可以运行Ruby, Python还有R。它可以把Java程序编译成只有数M大小的可执行的本地镜像，可以在Docker容器中运行，而加载时间只有几毫秒。它可以像数据库执行存储过程那样执行JavaScript代码，却不会像数据库那样要消耗太多资源。
GraalVM是一个开源项目，绝大部分是由Java编写的，不是本地代码（native code）的专家也可以参与这个项目中来。也就是说日常用于Java开发的工具就可以用来开发GraalVM。我们先来简单看下它有哪些组件。
JIT编译器Graal 没有一款优秀的JIT编译器，很难称得上是一款高性能的虚拟机。GraalVM的核心便是Graal编译器。Graal可以当作JIT编译器来使用，也可以用作提前编译的静态编译器。
正如GraalVM中的其它组件一样，Graal也是用Java语言来编写的。常见的编译器优化它都能支持：公共表达式消除（common subexpression elimination）、无用代码消除、常量折叠等等。内联及逃逸分析算法是它的看家本领。Graal是一款积极优化的编译器，它的中间代码（或中间表示，Intermediate representation，IR）所使用的程序依赖图（program dependence graph）和HotSpot虚拟机中C2编译器所用的非常相似，尽管它们两者有着显著的不同。在编译期间，高级操作（比如加载Java字段）的中间代码会被转换为底层操作（比如读取地址&#43;偏移量处的数据）的中间代码。而底层中间代码最终会被翻译为机器代码。除了用于分析JIT编译的标准JVM参数（-XX:&#43;PrintCompilation, XX:&#43;PrintAssembly等）外，GraalVM还发布了一款叫Ideal Graph Visualizer的工具，它可以用来调试及分析依赖图的转换过程。
Truffle GraalVM下一个关键的组件便是Truffle了，它是一款编程语言的实现框架。Truffle提供了一套API，你可以用它来基于源程序的抽象语言树（AST）来开发一门语言的解释器。AST求值是程序执行的相对比较简单的方式，因此实现一个解释器要比开发一个优化的编译器要容易得多。不过Truffle可以使用Graal编译器对这些解释器进行优化，因此它们的峰值性能与传统编译器不相上下，有时甚至还要更好。
Truffle使用了一项叫部分求值（partial evaluation）的技术来编译目标语言的解释器。简单来说，给Truffle一个语言解释器和一段程序，它会为这段给定的程序生成一个定制版的解释器。它会把执行时期收集到的分析及类型信息关联到依赖树的节点上，然后使用这些分析数据来进行优化。Truffle需要运行时的编译器支持部分求值，而Graal很好地满足了这项要求。
Truffle上实现的很多语言的解释器都能给我们带来不少灵感。比如js的引擎，LLVM的bitcode解释器，Ruby解释器，Python解释器，以及R解释器——这还只是GraalVM团队的官方项目。Github上还能找到其它语言的解释器的实现。甚至还有为了演示及教学Truffle单独创建的一门语言，你可以亲自体验下。
Truffle的精华之处在于，运行的时候所有的解释器都通过同样的协议来互相操作不同编程语言中的对象，也就是说，JavaScript, Python, Ruby等不同的编程语言或它们的组合所写出来的程序，从运行时的视角来看是没有任何区别的。运行时可以像正常优化代码那样，去优化用不同语言写出来的多语言程序，语言边界的跨越不存在任何性能开销。这就为所有生态系统下的库和模块都敞开了大门，你只需要选择最合适的语言去解决你要解决的问题就可以了，而不用为了项目所用的某个语言去专门实现一些缺少的模块。
Truffle的另一个好处是它对语言的实现进行了虚拟化，也就是说在运行时看来所有语言都是一样的。这样研发工具也可以是多语言的。比如说你可以用JavaScript的调试器来调试Ruby程序，或者使用VisualVM来分析JavaScript程序的内存使用，就像你在JavaScript，Java语言中使用这些工具一样。
本地镜像 GraalVM还有许多其它组件，比如说SubstrateVM，这是一个Java编写的小型虚拟机，它可以将Java应用编译成本地镜像。GraalVM的本地镜像不依赖于JVM来运行，也不需要加载和初始化Java类——并且启动速度还非常快。Graal编译器在生成镜像的过程中，会分析应用的类信息，并将它们提前编译成机器代码。SubstrateVM提供了所有虚拟机所应有的功能：垃圾回收，线程调度，代码缓存等等。它的代码也可以被Graal提前编译。因此它生成的可执行文件的峰值性能可能不如完全预热后的JIT编译的代码那么高，但是它的执行性能很稳定，运行时的开销也很低，并且启动时间是毫秒级的。在某些生产环境比如云或者无服务的部署中，对于长期运行的程序而言，启动时间要比对峰值性能来得重要。
除此之外，GraalVM还可以嵌入到其它的运行时平台中，对它们进行扩展以便支持多语言。目前实验版的Oracle DB就嵌入了GraalVM，你可以使用JavaScript而不是PL/SQL来编写存储过程。同样的功能也通过MySQL插件的方式提供了，因此你也可以在MySQL中使用GraalVM。这项功能看上去可能很鸡肋，不过它让你可以自由选择熟悉的编程语言或者已有的代码库和模块。
GraalVM初体验 体验GraalVM有很多种方式，这取决于你想付出多大的努力。
你当然可以从源码开始编译GraalVM，正如前面所说的，它是遵循带有类路径异常的GPL2许可（GPL2 with the classpath exception license）的开源项目——和OpenJDK相同的许可协议。不过最简单的方式还是去下载预先编译好的二进制包。
发布版和JDK的功能类似，除此之外还有一个JavaScript引擎、Node.js的实现、LLVM bitcode的解释器，以及本地镜像功能。
先下载一个GraalVM的发布版，将它解压到$GRAALVM_HOME目录下。然后便可以通过GraalVM来运行java了：
&gt; $GRAALVM_HOME/bin/java -version java version &#34;1.8.0_172&#34; Java(TM) SE Runtime Environment (build 1.8.0_172-b11) GraalVM 1.0.0-rc3 (build 25.71-b01-internal-jvmci-0.45, mixed mode) 你也可以运行JavaScript程序——比如这个单行小程序：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/50f214d19839a7e1d087138bb56092e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-16T13:35:22+08:00" />
<meta property="article:modified_time" content="2019-08-16T13:35:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">下一代的多语言JVM：GraalVM</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>GraalVM是一款高性能的可嵌入式多语言虚拟机，它能运行不同的编程语言，包括：</p> 
<ul><li>基于JVM的语言，比如Java, Scala, Kotlin和Groovy</li><li>解释型语言，比如JavaScript, Ruby, R和Python</li><li>配合LLVM一起工作的原生语言，比如C， C++， Rust和Swift</li></ul> 
<p>GraalVM能有效地支持多语言应用，你可以在一个进程里同时使用多种编程语言而不会带来明显的性能开销——这样你就可以根据具体问题来选择不同语言的解决方案了。</p> 
<p>GraalVM的设计目标是可以在不同的环境中运行程序：在JVM中、或者编译成独立的本地镜像、亦或是将Java及本地代码模块集成为更大型的应用。本文先简单介绍下GraalVM能干什么、如何开始使用它以及有哪些需要特别关注的点。</p> 
<h4><a id="GraalVM_12"></a>GraalVM的组件</h4> 
<p>GraalVM是一个大型项目，它有很多可插拔的组件，这使得它几乎无所不能。随便列举几点，它可以更快地运行Java程序，可以取代Nashorn来运行Node.js程序，可以运行Ruby, Python还有R。它可以把Java程序编译成只有数M大小的可执行的本地镜像，可以在Docker容器中运行，而加载时间只有几毫秒。它可以像数据库执行存储过程那样执行JavaScript代码，却不会像数据库那样要消耗太多资源。</p> 
<p>GraalVM是一个<a href="https://github.com/oracle/graal">开源项目</a>，绝大部分是由Java编写的，不是本地代码（native code）的专家也可以参与这个项目中来。也就是说日常用于Java开发的工具就可以用来开发GraalVM。我们先来简单看下它有哪些组件。</p> 
<h5><a id="JITGraal_18"></a>JIT编译器Graal</h5> 
<p>没有一款优秀的JIT编译器，很难称得上是一款高性能的虚拟机。GraalVM的核心便是Graal编译器。Graal可以当作JIT编译器来使用，也可以用作提前编译的静态编译器。</p> 
<p>正如GraalVM中的其它组件一样，Graal也是用Java语言来编写的。常见的编译器优化它都能支持：公共表达式消除（common subexpression elimination）、无用代码消除、常量折叠等等。内联及逃逸分析算法是它的看家本领。Graal是一款积极优化的编译器，它的中间代码（或中间表示，Intermediate representation，IR）所使用的程序依赖图（program dependence graph）和HotSpot虚拟机中C2编译器所用的非常相似，尽管它们两者有着显著的不同。在编译期间，高级操作（比如加载Java字段）的中间代码会被转换为底层操作（比如读取地址+偏移量处的数据）的中间代码。而底层中间代码最终会被翻译为机器代码。除了用于分析JIT编译的标准JVM参数（-XX:+PrintCompilation, XX:+PrintAssembly等）外，GraalVM还发布了一款叫Ideal Graph Visualizer的工具，它可以用来调试及分析依赖图的转换过程。</p> 
<h5><a id="Truffle_24"></a>Truffle</h5> 
<p>GraalVM下一个关键的组件便是Truffle了，它是一款编程语言的实现框架。Truffle提供了一套API，你可以用它来基于源程序的抽象语言树（AST）来开发一门语言的解释器。AST求值是程序执行的相对比较简单的方式，因此实现一个解释器要比开发一个优化的编译器要容易得多。不过Truffle可以使用Graal编译器对这些解释器进行优化，因此它们的峰值性能与传统编译器不相上下，有时甚至还要更好。</p> 
<p>Truffle使用了一项叫部分求值（partial evaluation）的技术来编译目标语言的解释器。简单来说，给Truffle一个语言解释器和一段程序，它会为这段给定的程序生成一个定制版的解释器。它会把执行时期收集到的分析及类型信息关联到依赖树的节点上，然后使用这些分析数据来进行优化。Truffle需要运行时的编译器支持部分求值，而Graal很好地满足了这项要求。</p> 
<p>Truffle上实现的很多语言的解释器都能给我们带来不少灵感。比如<a href="https://github.com/graalvm/graaljs">js的引擎</a>，<a href="https://github.com/graalvm/sulong">LLVM的bitcode解释器</a>，<a href="https://github.com/oracle/truffleruby">Ruby解释器</a>，<a href="https://github.com/graalvm/graalpython">Python解释器</a>，以及<a href="https://github.com/oracle/fastr">R解释器</a>——这还只是GraalVM团队的官方项目。<a href="https://github.com/oracle/graal/blob/master/truffle/docs/Languages.md">Github</a>上还能找到其它语言的解释器的实现。甚至还有为了演示及教学Truffle单独创建的<a href="https://github.com/graalvm/simplelanguage">一门语言</a>，你可以亲自体验下。</p> 
<p>Truffle的精华之处在于，运行的时候所有的解释器都通过同样的协议来互相操作不同编程语言中的对象，也就是说，JavaScript, Python, Ruby等不同的编程语言或它们的组合所写出来的程序，从运行时的视角来看是没有任何区别的。运行时可以像正常优化代码那样，去优化用不同语言写出来的多语言程序，语言边界的跨越不存在任何性能开销。这就为所有生态系统下的库和模块都敞开了大门，你只需要选择最合适的语言去解决你要解决的问题就可以了，而不用为了项目所用的某个语言去专门实现一些缺少的模块。</p> 
<p>Truffle的另一个好处是它对语言的实现进行了虚拟化，也就是说在运行时看来所有语言都是一样的。这样研发工具也可以是多语言的。比如说你可以用JavaScript的调试器来调试Ruby程序，或者使用<a href="https://medium.com/graalvm/debugging-polyglot-node-js-ruby-r-apps-with-graalvm-81b1bb2614db" rel="nofollow">VisualVM来分析JavaScript程序的内存使用</a>，就像你在JavaScript，Java语言中使用这些工具一样。</p> 
<h5><a id="_36"></a>本地镜像</h5> 
<p>GraalVM还有许多其它组件，比如说<a href="https://github.com/oracle/graal/tree/master/substratevm">SubstrateVM</a>，这是一个Java编写的小型虚拟机，它可以将Java应用编译成本地镜像。GraalVM的本地镜像不依赖于JVM来运行，也不需要加载和初始化Java类——并且启动速度还非常快。Graal编译器在生成镜像的过程中，会分析应用的类信息，并将它们提前编译成机器代码。SubstrateVM提供了所有虚拟机所应有的功能：垃圾回收，线程调度，代码缓存等等。它的代码也可以被Graal提前编译。因此它生成的可执行文件的峰值性能可能不如完全预热后的JIT编译的代码那么高，但是它的执行性能很稳定，运行时的开销也很低，并且启动时间是毫秒级的。在某些生产环境比如云或者无服务的部署中，对于长期运行的程序而言，启动时间要比对峰值性能来得重要。</p> 
<p>除此之外，GraalVM还可以嵌入到其它的运行时平台中，对它们进行扩展以便支持多语言。目前<a href="https://oracle.github.io/oracle-db-mle/" rel="nofollow">实验版的Oracle DB</a>就嵌入了GraalVM，你可以使用JavaScript而不是PL/SQL来编写存储过程。同样的功能也通过MySQL插件的方式提供了，因此你也可以在MySQL中使用GraalVM。这项功能看上去可能很鸡肋，不过它让你可以自由选择熟悉的编程语言或者已有的代码库和模块。</p> 
<h4><a id="GraalVM_42"></a>GraalVM初体验</h4> 
<p>体验GraalVM有很多种方式，这取决于你想付出多大的努力。</p> 
<p>你当然可以从源码开始编译GraalVM，正如前面所说的，它是遵循带有类路径异常的GPL2许可（GPL2 with the classpath exception license）的开源项目——和OpenJDK相同的许可协议。不过最简单的方式还是去下载<a href="https://www.graalvm.org/downloads/" rel="nofollow">预先编译好的二进制包</a>。</p> 
<p>发布版和JDK的功能类似，除此之外还有一个JavaScript引擎、Node.js的实现、LLVM bitcode的解释器，以及本地镜像功能。</p> 
<p>先下载一个GraalVM的发布版，将它解压到$GRAALVM_HOME目录下。然后便可以通过GraalVM来运行java了：</p> 
<pre><code>&gt; $GRAALVM_HOME/bin/java -version
java version "1.8.0_172"
Java(TM) SE Runtime Environment (build 1.8.0_172-b11)
GraalVM 1.0.0-rc3 (build 25.71-b01-internal-jvmci-0.45, mixed mode)
</code></pre> 
<p>你也可以运行JavaScript程序——比如这个单行小程序：</p> 
<pre><code>&gt; $GRAALVM_HOME/bin/js -e 'console.log(1+2)'
3
</code></pre> 
<p>还可以在命令行下通过gu工具来安装Ruby, R或Python的试验版：</p> 
<p><code>$GRAALVM_HOME/bin/gu install {ruby|python|r}</code></p> 
<p>注意预编译版本的GraalVM是基于OpenJDK的。因此JDK上能运行的所有程序，GraalVM都能支持。如果你想要公平地比较下它们的性能，先通过-XX:-UseJVMCICompiler参数来关掉GraalVM中的Graal编译器，以便启用OpenJDK所用的HotSpot VM的编译器。</p> 
<p>可以参考下入门指南看看GraalVM都能干些什么，也可以尝试下<a href="https://medium.com/graalvm/graalvm-ten-things-12d9111f307d" rel="nofollow">这篇文章</a>中的实验，或者<a href="https://www.graalvm.org/docs/examples/" rel="nofollow">GraalVM团队收集一些用例</a>。</p> 
<p>如果你手头已经有一个可用于性能测试的项目，并且测量GraalVM性能所有的基础设施也都就绪了，你可以尝试下不同的微基准测试工具（microbenchmarks）。比如<a href="https://github.com/graalvm/graalvm-demos/tree/master/java-simple-stream-benchmark">这个</a>。它是基于Java Microbenchmark Harness（JMH）实现的，后者也是Java微基准测试的标准工具。测量方法会连续执行一个简单的Stream API调用，对流上的数据进行计算，最后对它们进行求和。</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>graalvm<span class="token punctuation">.</span>demos<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>openjdk<span class="token punctuation">.</span>jmh<span class="token punctuation">.</span>annotations<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span>
<span class="token annotation punctuation">@Warmup</span><span class="token punctuation">(</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Measurement</span><span class="token punctuation">(</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@BenchmarkMode</span><span class="token punctuation">(</span>Mode<span class="token punctuation">.</span>AverageTime<span class="token punctuation">)</span>
<span class="token annotation punctuation">@OutputTimeUnit</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Fork</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaSimpleStreamBenchmark</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token annotation punctuation">@Benchmark</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在我本机上，GraalVM的执行性能要比OpenJDK 1.8快上数倍。如果你想试一下，可以克隆下它的仓库。</p> 
<pre><code>git clone https://github.com/graalvm/graalvm-demos
cd graalvm-demos/java-simple-stream-benchmark
</code></pre> 
<p>编译完后可以通过$GRAALVM_HOME/bin/java和正常的OpenJDK来分别运行一下，看看它们执行结果的区别。</p> 
<pre><code>mvn clean install
$GRAALVM_HOME/bin/java -jar target/benchmarks.jar
</code></pre> 
<p>当然这并不是科学的评估性能的方法，正常应该是你自己去测试性能影响。不过这至少说明，某些代码上，GraalVM的执行速度是要远快于HotSpot VM的。</p> 
<h4><a id="GraalVMJava_120"></a>使用GraalVM来集成Java与其它语言</h4> 
<p>多语言是GraalVM最有意思的特性之一了，我们来看下它是如何实现的。</p> 
<p>GraalVM多语言API的核心是Context类。Context代表了全局所有非Java语言（能编译成JVM字节码）的全局运行时状态。你可以根据自己的需要初始化对应的语言，并用它们来编写代码。下面的代码是GraalVM多语言程序的一个简单的例子。这是一段普通的Java代码，它会对JavaScript的字符串求值，里面声明了一个42的值，然后将一个Value对象返回给Java。</p> 
<pre><code class="prism language-java">Context context <span class="token operator">=</span> Context<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Value result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"js"</span><span class="token punctuation">,</span> <span class="token string">"42"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">assert</span> result<span class="token punctuation">.</span><span class="token function">asInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre> 
<p>不同的语言是通过Value来进行对话的。任何Java对象都可以通过Value.asValue(Object value)方法来转化成Value对象，而Value对象也可以通过Value.as(Class targetType)方法来转换成对应的Java对象。具体的转换过程不在本文的讨论范围之内，不过它的<a href="https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Value.html#as-java.lang.Class" rel="nofollow">API</a>已经说的很清楚了：数值转换为数值，字符串转换为String，可执行的值转换成接口，集合转换为集合，等等。下面所有表达式的结果都是true:</p> 
<pre><code class="prism language-java">context<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"js"</span><span class="token punctuation">,</span> <span class="token string">"'foobar'"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"foobar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"js"</span><span class="token punctuation">,</span> <span class="token string">"{foo:'bar'}"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@FunctionalInterface</span> <span class="token keyword">interface</span> <span class="token class-name">IntFunction</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
context<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"js"</span><span class="token punctuation">,</span> <span class="token string">"(function(a){a})"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as</span><span class="token punctuation">(</span>IntFunction<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">;</span>
</code></pre> 
<p>有了Context和Value，你就可以在不同语言的模块间进行数据传递了。</p> 
<p>不过现代的应用程序通常将组件的多语言实现细节通过某种抽象给隐藏起来了。比如，这个Spring Boot web应用的<a href="https://github.com/graalvm/graalvm-demos/tree/master/spring-r">例子</a>，它通过R语言来将CPU的使用数据绘制成SVG图像。</p> 
<p>在这个应用中，GraalVM的多语言Context定义成了Spring的一个Bean：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> Context <span class="token function">getGraalVMContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">return</span> Context<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allowAllAccess</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>R语言编写的函数会接收数据并绘制出图像（数据源在一个资源文件中），这个函数也暴露成了一个Bean。它会接收GraalVM上下文，对R语言中的source求值，将结果转换成Java的Function&lt;Double, String&gt;并返回。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span>
Function<span class="token generics function"><span class="token punctuation">&lt;</span>Double<span class="token punctuation">,</span> String<span class="token punctuation">&gt;</span></span> <span class="token function">getPlotFunction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> Context ctx<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Source source <span class="token operator">=</span>
        Source<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token string">"R"</span><span class="token punctuation">,</span> rSource<span class="token punctuation">.</span><span class="token function">getURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ctx<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>完成之后，R的函数就可以像Java的函数式接口那样使用了。类似的，你也可以把GraalVM支持的其它语言集成到你的应用中。</p> 
<h4><a id="_167"></a>结论</h4> 
<p>本文介绍了GraalVM以及它的组件——Graal编译器，Truffle以及本地镜像工具，以及多语言程序中最重要的API，同时还提供了一份尽可能简单的GraalVM入门指南。</p> 
<p>GraalVM是值得一试的。许多程序在GraalVM上都能执行得更快；它的快速启动也能让很多应用受益；而有的应用可以通过它支持的其它语言实现的模块得到增强，比如Ruby, JavaScript, R和Python等。如果有任何问题或想参与到这个很赞的项目中的话，可以访问<a href="https://github.com/oracle/graal">Github上的项目</a>来了解。</p> 
<p><a href="https://www.oracle.com/technetwork/java/javamagazine/index.html" rel="nofollow">英文原文链接</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e98ce6b2221b8c21b1782f1fb09866c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ansible-playbook创建用户</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3d402020f9ad1c7d58941b163a969b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue cli3.0怎么回退到原来的版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>