<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUC第六讲：二面阿里竟然败在了 volatile 关键字上 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JUC第六讲：二面阿里竟然败在了 volatile 关键字上" />
<meta property="og:description" content="关键字 volatile 详解 相比Sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种解决可见性和有序性问题的方案，本文是JUC第六讲，volatile关键字详解。
文章目录 关键字 volatile 详解1、带着BAT大厂的面试问题去理解volatile2、volatile的作用详解2.1、防重排序2.2、实现可见性2.3、保证原子性：单次读/写1、问题1： i&#43;&#43;为什么不能保证原子性? Action1：volatile不保证原子性问题解决2、问题2： 共享的long和double变量的为什么要用volatile? 2.4、在项目中对volatile的使用？ 3、volatile 的实现原理 (百度面试题)3.1、volatile 可见性实现1、lock 指令2、缓存一致性 3.2、volatile 有序性实现1、volatile 的 happens-before 关系2、volatile 禁止重排序 4、volatile 的应用场景4.1、模式1：状态标志4.2、模式2：一次性安全发布(one-time safe publication)4.3、模式3：独立观察(independent observation)4.4、模式4：volatile bean 模式4.5、模式5：开销较低的读－写锁策略4.6、模式6：双重检查(double-checked) 5、Volatile/Synchronized两者区别（锁的目标：关注互斥性和可见性）6、Volatile 总结 7、参考文章Action1、volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。 1、带着BAT大厂的面试问题去理解volatile 请带着这些问题继续后文，会很大程度上帮助你更好的理解volatile。
volatile关键字的作用是什么?volatile能保证原子性吗? 不能之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?i&#43;&#43;为什么不能保证原子性?volatile是如何实现可见性的? 内存屏障。volatile是如何实现有序性的? happens-before等说下volatile的应用场景? 2、volatile的作用详解 Volatile关键字定义
Java提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。 保证了 Java 内存模型的两个特性：可见性、有序性（禁止指令重排）
1、保证此变量对所有线程的可见性（即当一条线程修改了这个值，新值对于其他所有线程来说是立即得知的） 原理是：每次访问变量时都会进行一次刷新，因此每次访问都是主存中最新的版本
2、禁止指令重排序优化（volatile修饰的变量相当于生成内存屏障，重排列时不能把后面的指令排到屏障之前）
保证有序性 3、不保证原子性
2.1、防重排序 背景：我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。
其源码如下：
public class Singleton { public static volatile Singleton singleton; /** * 构造函数私有，禁止外部实例化 */ private Singleton() {}; public static Singleton getInstance() { if (singleton == null) { synchronized (singleton." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/4aa5416bf87bca7e6f4e01f343779036/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-11T15:09:53+08:00" />
<meta property="article:modified_time" content="2023-10-11T15:09:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUC第六讲：二面阿里竟然败在了 volatile 关键字上</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_volatile__0"></a>关键字 volatile 详解</h2> 
<blockquote> 
 <p>相比Sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种<strong>解决可见性和有序性问题的方案</strong>，本文是JUC第六讲，volatile关键字详解。</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_volatile__0" rel="nofollow">关键字 volatile 详解</a></li><li><ul><li><a href="#1BATvolatile_5" rel="nofollow">1、带着BAT大厂的面试问题去理解volatile</a></li><li><a href="#2volatile_18" rel="nofollow">2、volatile的作用详解</a></li><li><ul><li><a href="#21_32" rel="nofollow">2.1、防重排序</a></li><li><a href="#22_72" rel="nofollow">2.2、实现可见性</a></li><li><a href="#23_120" rel="nofollow">2.3、保证原子性：单次读/写</a></li><li><ul><li><a href="#11_i_124" rel="nofollow">1、问题1： i++为什么不能保证原子性?</a></li></ul> 
   </li></ul> 
   </li><li><a href="#Action1volatile_168" rel="nofollow">Action1：volatile不保证原子性问题解决</a></li><li><ul><li><ul><li><a href="#22_longdoublevolatile_231" rel="nofollow">2、问题2： 共享的long和double变量的为什么要用volatile?</a></li></ul> 
    </li><li><a href="#24volatile_249" rel="nofollow">2.4、在项目中对volatile的使用？</a></li></ul> 
   </li><li><a href="#3volatile___259" rel="nofollow">3、volatile 的实现原理 (百度面试题)</a></li><li><ul><li><a href="#31volatile__261" rel="nofollow">3.1、volatile 可见性实现</a></li><li><ul><li><a href="#1lock__321" rel="nofollow">1、lock 指令</a></li><li><a href="#2_325" rel="nofollow">2、缓存一致性</a></li></ul> 
    </li><li><a href="#32volatile__329" rel="nofollow">3.2、volatile 有序性实现</a></li><li><ul><li><a href="#1volatile__happensbefore__331" rel="nofollow">1、volatile 的 happens-before 关系</a></li><li><a href="#2volatile__365" rel="nofollow">2、volatile 禁止重排序</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4volatile__398" rel="nofollow">4、volatile 的应用场景</a></li><li><ul><li><a href="#411_406" rel="nofollow">4.1、模式1：状态标志</a></li><li><a href="#422onetime_safe_publication_422" rel="nofollow">4.2、模式2：一次性安全发布(one-time safe publication)</a></li><li><a href="#433independent_observation_448" rel="nofollow">4.3、模式3：独立观察(independent observation)</a></li><li><a href="#444volatile_bean__470" rel="nofollow">4.4、模式4：volatile bean 模式</a></li><li><a href="#455_499" rel="nofollow">4.5、模式5：开销较低的读－写锁策略</a></li><li><a href="#466doublechecked_518" rel="nofollow">4.6、模式6：双重检查(double-checked)</a></li></ul> 
   </li><li><a href="#5VolatileSynchronized_560" rel="nofollow">5、Volatile/Synchronized两者区别（锁的目标：关注互斥性和可见性）</a></li><li><ul><li><a href="#6Volatile__576" rel="nofollow">6、Volatile 总结</a></li></ul> 
   </li><li><a href="#7_588" rel="nofollow">7、参考文章</a></li><li><a href="#Action1volatile__594" rel="nofollow">Action1、volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1BATvolatile_5"></a>1、带着BAT大厂的面试问题去理解volatile</h3> 
<p>请带着这些问题继续后文，会很大程度上帮助你更好的理解volatile。</p> 
<ul><li>volatile关键字的作用是什么?</li><li>volatile能保证原子性吗? 不能</li><li>之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?</li><li>i++为什么不能保证原子性?</li><li>volatile是如何实现可见性的? <strong>内存屏障</strong>。</li><li>volatile是如何实现有序性的? happens-before等</li><li>说下volatile的应用场景?</li></ul> 
<h3><a id="2volatile_18"></a>2、volatile的作用详解</h3> 
<p>Volatile关键字定义</p> 
<ul><li><strong>Java提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。</strong></li></ul> 
<p>保证了 Java 内存模型的两个特性：可见性、有序性（禁止指令重排）</p> 
<ul><li> <p>1、<strong>保证此变量对所有线程的可见性</strong>（即当一条线程修改了这个值，新值对于其他所有线程来说是立即得知的） <strong>原理是</strong>：每次访问变量时都会进行一次刷新，因此每次访问都是主存中最新的版本</p> </li><li> <p>2、<strong>禁止指令重排序优化</strong>（volatile修饰的变量相当于生成内存屏障，重排列时不能把后面的指令排到屏障之前）</p> 
  <ul><li>保证有序性</li></ul> </li><li> <p><strong>3、不保证原子性</strong></p> </li></ul> 
<h4><a id="21_32"></a>2.1、防重排序</h4> 
<p><strong>背景</strong>：我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。</p> 
<p>其源码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>
    <span class="token comment">/**
     * 构造函数私有，禁止外部实例化
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p> 
<ul><li>分配内存空间。</li><li>初始化对象。</li><li>将内存空间的地址赋值给对应的引用。</li></ul> 
<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p> 
<ul><li>分配内存空间。</li><li>将内存空间的地址赋值给对应的引用。</li><li>初始化对象</li></ul> 
<p><strong>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果</strong>。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p> 
<h4><a id="22_72"></a>2.2、实现可见性</h4> 
<p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestVolatile</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// Thread-A</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token string">"Thread A"</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" stopped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Thread-main</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" after 1 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行输出如下</p> 
<pre><code class="prism language-bash">Thread<span class="token punctuation">[</span>main,5,main<span class="token punctuation">]</span> after <span class="token number">1</span> seconds

// Thread A一直在loop, 因为Thread A 由于可见性原因看不到Thread Main 已经修改stop的值
</code></pre> 
<p>可以看到 Thread-main 休眠1秒之后，设置 stop = ture，但是Thread A根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop:</p> 
<pre><code class="prism language-bash">Thread<span class="token punctuation">[</span>main,5,main<span class="token punctuation">]</span> after <span class="token number">1</span> seconds
Thread<span class="token punctuation">[</span>Thread A,5,main<span class="token punctuation">]</span> stopped

Process finished with <span class="token builtin class-name">exit</span> code <span class="token number">0</span>
</code></pre> 
<h4><a id="23_120"></a>2.3、保证原子性：单次读/写</h4> 
<p><font color="red"><strong>volatile不能保证完全的原子性</strong>，只能保证单次的读/写操作具有原子性</font>。先从如下两个问题来理解（后文再从内存屏障的角度理解）：</p> 
<h5><a id="11_i_124"></a>1、问题1： i++为什么不能保证原子性?</h5> 
<p>对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p> 
<p>现在我们就通过下列程序来演示一下这个问题：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileTest01</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token class-name">VolatileTest01</span> test01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VolatileTest01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    test01<span class="token punctuation">.</span><span class="token function">addI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      	<span class="token comment">// 等待10秒，保证上面程序执行完成</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test01<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出**，volatile是无法保证原子性的(否则结果应该是1000)**。原因也很简单，i++其实是一个复合操作，包括三步骤：</p> 
<ul><li>读取i的值。</li><li>对i加1。</li><li>将i的值写回内存。</li></ul> 
<p><font color="red">volatile是无法保证这三个操作是具有原子性的，我们可以通过<strong>AtomicInteger或者Synchronized</strong>来保证+1操作的原子性</font>。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。</p> 
<h3><a id="Action1volatile_168"></a>Action1：volatile不保证原子性问题解决</h3> 
<p>可加synchronized解决，但它是重量级同步机制，性能上有所顾虑。</p> 
<p>如何不加synchronized解决number++在多线程下是非线程安全的问题？</p> 
<ul><li> <p>使用AtomicInteger</p> </li><li> <pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">MyData2</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知
     */</span>
		<span class="token keyword">volatile</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token class-name">AtomicInteger</span> number2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPlusPlus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        number<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addPlusPlus2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    		number2<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileAtomicityDemo</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">MyData2</span> myData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyData2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建10个线程，线程里面进行1000次循环</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    myData<span class="token punctuation">.</span><span class="token function">addPlusPlus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    myData<span class="token punctuation">.</span><span class="token function">addPlusPlus2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span>
        <span class="token comment">// 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">activeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// yield表示不执行</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 查看最终的值</span>
        <span class="token comment">// 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 = 20000</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t finally number value: "</span> <span class="token operator">+</span> myData<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t finally number2 value: "</span> <span class="token operator">+</span> myData<span class="token punctuation">.</span>number2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>输出结果为：</p> <pre><code class="prism language-java">main	 <span class="token keyword">finally</span> number value<span class="token operator">:</span> <span class="token number">18766</span>
main	 <span class="token keyword">finally</span> number2 value<span class="token operator">:</span> <span class="token number">20000</span>
</code></pre> </li></ul> 
<h5><a id="22_longdoublevolatile_231"></a>2、问题2： 共享的long和double变量的为什么要用volatile?</h5> 
<p>因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，<strong>鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性</strong>。</p> 
<p>如下是JLS中的解释：</p> 
<blockquote> 
 <p>17.7 Non-Atomic Treatment of double and long</p> 
</blockquote> 
<ul><li>为了Java编程语言内存模型的目的，对非易失性long或double的一次写入被视为两次单独的写入：一次写入32位的一半。这可能导致线程从一次写入中看到64位值的前32位，从另一次写入看到第二个32位的情况；</li><li>易失性long和double的写入和读取始终是原子的；</li><li>对引用的写入和读取始终是原子的，无论它们是作为32位值还是64位值实现的；</li><li>一些实现可能发现将对64位long或double的单个写入动作划分为对相邻32位值的两个写入动作是方便的。为了提高效率，这种行为是特定于实现的；Java虚拟机的实现可以自由地原子地或分两部分执行对long或double的写入；</li><li>鼓励Java虚拟机的实现尽可能避免拆分64位值。鼓励程序员将共享的64位值声明为易失性或正确同步程序，以避免可能出现的复杂情况。</li></ul> 
<p>目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，<strong>因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。</strong></p> 
<h4><a id="24volatile_249"></a>2.4、在项目中对volatile的使用？</h4> 
<p>1、在双重校验获取单例时使用该关键字；</p> 
<p>2、获取apollo配置时，使用volatile；</p> 
<p>3、定义一个标志位，多线程环境下用来跳出循环</p> 
<h3><a id="3volatile___259"></a>3、volatile 的实现原理 (百度面试题)</h3> 
<h4><a id="31volatile__261"></a>3.1、volatile 可见性实现</h4> 
<blockquote> 
 <p>volatile 变量的<strong>内存可见性</strong>是基于内存屏障(Memory Barrier)实现:</p> 
</blockquote> 
<ul><li>内存屏障，又称内存栅栏，是一个 CPU 指令。</li><li>在程序运行时，<font color="red">为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序</font>，插入一条内存屏障会告诉编译器和 CPU：<strong>不管什么指令都不能和这条 Memory Barrier 指令重排序</strong>。</li></ul> 
<p>写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
  0x0000000002951563: and    <span class="token variable">$0xffffffffffffff87</span>,%rdi
  0x0000000002951567: je     0x00000000029515f8
  0x000000000295156d: <span class="token builtin class-name">test</span>   <span class="token variable">$0x7</span>,%rdi
  0x0000000002951574: jne    0x00000000029515bd
  0x0000000002951576: <span class="token builtin class-name">test</span>   <span class="token variable">$0x300</span>,%rdi
  0x000000000295157d: jne    0x000000000295159c
  0x000000000295157f: and    <span class="token variable">$0x37f</span>,%rax
  0x0000000002951586: mov    %rax,%rdi
  0x0000000002951589: or     %r15,%rdi
  0x000000000295158c: lock cmpxchg %rdi,<span class="token punctuation">(</span>%rdx<span class="token punctuation">)</span>  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令
  0x0000000002951591: jne    0x0000000002951a15
  0x0000000002951597: jmpq   0x00000000029515f8
  0x000000000295159c: mov    0x8<span class="token punctuation">(</span>%rdx<span class="token punctuation">)</span>,%edi
  0x000000000295159f: shl    <span class="token variable">$0x3</span>,%rdi
  0x00000000029515a3: mov    0xa8<span class="token punctuation">(</span>%rdi<span class="token punctuation">)</span>,%rdi
  0x00000000029515aa: or     %r15,%rdi
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>
</code></pre> 
<p>lock 前缀的指令在多核处理器下会引发两件事情：</p> 
<ul><li><strong>将当前处理器缓存行的数据写回到系统内存。</strong></li><li><strong>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</strong></li></ul> 
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p> 
<p><strong>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</strong></p> 
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p> 
<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p> 
<p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p> 
<h5><a id="1lock__321"></a>1、lock 指令</h5> 
<p>在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 <strong>这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证</strong>。</p> 
<h5><a id="2_325"></a>2、缓存一致性</h5> 
<p>缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 " 嗅探(snooping)" 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</p> 
<h4><a id="32volatile__329"></a>3.2、volatile 有序性实现</h4> 
<h5><a id="1volatile__happensbefore__331"></a>1、volatile 的 happens-before 关系</h5> 
<p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p> 
<pre><code class="prism language-java"><span class="token comment">//假设线程A执行writer方法，线程B执行reader方法</span>
<span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">// 1 线程A修改共享变量</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 2 线程A写volatile变量</span>
    <span class="token punctuation">}</span> 
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>         <span class="token comment">// 3 线程B读同一个volatile变量</span>
       		<span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">;</span>      <span class="token comment">// 4 线程B读共享变量</span>
       		……
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。</p> 
<ul><li>根据程序次序规则：1 happens-before 2 且 3 happens-before 4。</li><li>根据 volatile 规则：2 happens-before 3。</li><li>根据 happens-before 的传递性规则：1 happens-before 4。</li></ul> 
<p><img src="https://images2.imgbox.com/e8/a7/ymsUVh4n_o.png" alt="img" width="360" height="320"></p> 
<p>因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。</p> 
<h5><a id="2volatile__365"></a>2、volatile 禁止重排序</h5> 
<p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p> 
<p><strong>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong></p> 
<p>JMM 会针对编译器制定 volatile 重排序规则表。</p> 
<p><img src="https://images2.imgbox.com/5b/db/NHQ16lI2_o.png" alt="img"></p> 
<p><strong>“NO” 表示禁止重排序。</strong></p> 
<p>为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p> 
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。</p> 
<ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul> 
<p><font color="red"><strong>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。</strong></font></p> 
<table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序。</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序。</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序。</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/41/7e/DBgK0IkN_o.png" alt="img" width="360" height="250"><br> <img src="https://images2.imgbox.com/3a/ee/zG6vNdWX_o.png" alt="img" width="360" height="250"></p> 
<h3><a id="4volatile__398"></a>4、volatile 的应用场景</h3> 
<p>使用 volatile 必须具备的条件</p> 
<ul><li>1、对变量的写操作不依赖于当前值，或者你能确保只有单个线程更新变量的值；</li><li>2、该变量没有包含在具有其他变量的不变式中。</li><li>3、只有在状态真正独立于程序内其他内容时才能使用 volatile。</li></ul> 
<h4><a id="411_406"></a>4.1、模式1：状态标志</h4> 
<p>使用volatile来修饰状态标记量，使得状态标记量对所有线程是实时可见的，从而保证所有线程都能实时获取到最新的状态标记量，进一步决定是否进行操作。<strong>例如常见的促销活动“秒杀”，可以用volatile来修饰“是否售罄”字段，从而保证在并发下，能正确的处理商品是否售罄</strong>。</p> 
<pre><code class="prism language-java"><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="422onetime_safe_publication_422"></a>4.2、模式2：一次性安全发布(one-time safe publication)</h4> 
<p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BackgroundFloobleLoader</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token class-name">Flooble</span> theFlooble<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initInBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// do lots of stuff</span>
        theFlooble <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Flooble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// this is the only write to theFlooble</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeOtherClass</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
            <span class="token comment">// do some stuff...</span>
            <span class="token comment">// use the Flooble, but only if it is ready</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>floobleLoader<span class="token punctuation">.</span>theFlooble <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
                <span class="token function">doSomething</span><span class="token punctuation">(</span>floobleLoader<span class="token punctuation">.</span>theFlooble<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="433independent_observation_448"></a>4.3、模式3：独立观察(independent observation)</h4> 
<p>安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p> 
<ul><li>即apollo配置</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserManager</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token class-name">String</span> lastUser<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token class-name">String</span> user<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">boolean</span> valid <span class="token operator">=</span> <span class="token function">passwordIsValid</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>valid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">User</span> u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            activeUsers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
            lastUser <span class="token operator">=</span> user<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> valid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="444volatile_bean__470"></a>4.4、模式4：volatile bean 模式</h4> 
<p>在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。<strong>对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性</strong>。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> firstName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> lastName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token class-name">String</span> firstName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token class-name">String</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="455_499"></a>4.5、模式5：开销较低的读－写锁策略</h4> 
<p>volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 <strong>安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性</strong>。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CheesyCounter</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Employs the cheap read-write lock trick</span>
    <span class="token comment">// All mutative operations MUST be done with the 'this' lock held</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">"this"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="466doublechecked_518"></a>4.6、模式6：双重检查(double-checked)</h4> 
<p><strong>双重检测机制实现单例</strong></p> 
<ul><li>普通的双重检测机制在极端情况，由于指令重排序会出现问题，通过使用volatile来修饰instance，禁止指令重排序，从而可以正确的实现单例。</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 私有化构造函数</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token comment">// volatile修饰单例对象</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 对外提供的工厂方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 第一次检测</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>    <span class="token comment">// 同步锁</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 第二次检测</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>具体可见这篇文章：<a href="https://blog.csdn.net/qq_28959087/article/details/121986617">JAVA设计模式第二讲：创建型设计模式</a></li></ul> 
<p><strong>使用建议：</strong></p> 
<ul><li>1、在两个或者更多线程需要访问的成员变量上使用 volatile。当要访问的变量已在 synchronized 代码块中，或者为常量时，没必要使用 volatile；</li><li>2、由于使用 volatile 屏蔽掉了 JVM中必要的代码优化，所以效率上比较低，因此一定在必要时才使用此关键字。</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>1**、无法实现i++原子操作**（解决方案：原子类）使用场景：单线程；</li><li>2、<strong>不具备“互斥性”</strong>：多个线程能同时读写主存，不能保证变量的“原子性”：（i++ 不能作为一个整体，分为3个步骤读-改-写），可以使用CAS算法保证数据原子性</li></ul> 
<h3><a id="5VolatileSynchronized_560"></a>5、Volatile/Synchronized两者区别（锁的目标：关注互斥性和可见性）</h3> 
<p>1、volatile 不会进行加锁操作</p> 
<ul><li>volatile 变量是一种稍弱的同步机制，在访问 volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile变量是一种比synchronized 关键字更轻量级的同步机制。</li></ul> 
<p>2、volatile 变量作用类似于同步变量读写操作</p> 
<ul><li>从内存可见性来说，写入 volatile变量相当于退出同步代码块，而读取 volatile 变量相当于进入同步代码块；</li></ul> 
<p>3、volatile不如 Synchronized安全</p> 
<p>4、volatile仅能实现变量的修改可见性，并不能保证原子性；<strong>synchronized则可以保证变量的修改可见性和原子性</strong>，例如： count++；</p> 
<h4><a id="6Volatile__576"></a>6、Volatile 总结</h4> 
<ul><li>1、每个线程有自己的工作内存，工作内存中的数据并不会实时刷新回主内存，因此在并发情况下，有可能线程A已经修改了成员变量k的值，但是线程B并不能读取到线程A修改后的值，这是因为线程A的工作内存还没有被刷新回主内存，导致线程B无法读取到最新的值。</li><li>2、在工作内存中，每次使用volatile修饰的变量前都必须先从主内存刷新最新的值，这保证了当前线程能看见其他线程对volatile修饰的变量所做的修改后的值。</li><li>3、在工作内存中，每次修改volatile修饰的变量后都必须立刻同步回主内存中，这保证了其他线程可以看到自己对volatile修饰的变量所做的修改。</li><li>4、volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。</li><li>5、volatile保证可见性，不保证原子性，部分保证有序性（仅保证被volatile修饰的变量）。</li><li>6、指令重排序的目的是为了提高性能，指令重排序仅保证在单线程下不会改变最终的执行结果，但无法保证在多线程下的执行结果。</li><li>7、为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止重排序。</li></ul> 
<h3><a id="7_588"></a>7、参考文章</h3> 
<ul><li><a href="https://blog.csdn.net/devotion987/article/details/68486942">volatile的使用及其原理</a></li></ul> 
<h3><a id="Action1volatile__594"></a>Action1、volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</h3> 
<p>如果是 count++ 操作，使用如下类实现：</p> 
<pre><code class="prism language-java"><span class="token class-name">AtomicInteger</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
count<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>如果是 JDK8，推荐使用 LongAdder 对象， 比 AtomicLong 性能更好</strong>（减少乐观锁的重试次数）。</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LongAdder</span> <span class="token constant">BATCH_FIND_BRAND_BY_ID_HIT</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">BATCH_FIND_BRAND_BY_ID_HIT</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8405dcf0edf502ae4bd7fd3eeb9c3d6a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL第一讲：程序员必须精通的MySQL索引规范</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/831f268384ce255cdbd4f7d3701fbe6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">初学vue，想自己找个中长期小型项目练练手，应该做什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>