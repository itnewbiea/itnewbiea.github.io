<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS基础知识汇总 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS基础知识汇总" />
<meta property="og:description" content="01 -《发展史》 浏览器发展史
1995 年，网景公司研发的导航者浏览器。
1995 年 8 月，微软推出 IE1.0 版本。
1995 年 11 月，微软推出 IE2.0 版本。
从 IE3 开始，IE 浏览器作为了 windows 内置浏览器。
1998 年，网景公司被“美国在线”收购。
2008 年，谷歌推出了第一款浏览器 Chrome。
JavaScript 发展史
1995 年，网景公司花了 10 天的时间，研发出了 JavaScript 语言。
2004 年，谷歌推出了 AJAX 技术，JS 逐渐开始受到程序员的重视。
2009 年，谷歌研发出了 Nodejs，JS 就可以在服务端进行开发。
JavaScript 版本
1997 年 6 月，JS 的第一版，取名叫做 ECMAScript 1.0， 简称 ES1.0。
2009 年 12 月， ECMAScript 5.0（简称 ES5）正式发布。
2015 年 6 月，ECMAScript 2015（简称 ES6）正式发布。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6efabb7abc0eb207fbd60d43e4a699f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-03T16:50:37+08:00" />
<meta property="article:modified_time" content="2022-12-03T16:50:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS基础知识汇总</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h2>01 -《发展史》</h2> 
<p>浏览器发展史</p> 
<ul><li> <p>1995 年，网景公司研发的导航者浏览器。</p> </li><li> <p>1995 年 8 月，微软推出 IE1.0 版本。</p> </li><li> <p>1995 年 11 月，微软推出 IE2.0 版本。</p> </li><li> <p>从 IE3 开始，IE 浏览器作为了 windows 内置浏览器。</p> </li><li> <p>1998 年，网景公司被“美国在线”收购。</p> </li><li> <p>2008 年，谷歌推出了第一款浏览器 Chrome。</p> </li></ul> 
<p>JavaScript 发展史</p> 
<p>1995 年，网景公司花了 10 天的时间，研发出了 JavaScript 语言。</p> 
<p>2004 年，谷歌推出了 AJAX 技术，JS 逐渐开始受到程序员的重视。</p> 
<p>2009 年，谷歌研发出了 Nodejs，JS 就可以在服务端进行开发。</p> 
<p>JavaScript 版本</p> 
<p>1997 年 6 月，JS 的第一版，取名叫做 ECMAScript 1.0， 简称 ES1.0。</p> 
<p>2009 年 12 月， ECMAScript 5.0（简称 ES5）正式发布。</p> 
<p>2015 年 6 月，ECMAScript 2015（简称 ES6）正式发布。</p> 
<h2>02 -《准备工作》</h2> 
<p>JavaScript 是一种轻量级的脚本语言，可以嵌入到 HTML 中，由浏览器来解析执行。</p> 
<h4>一、运行 JS 代码</h4> 
<p>每一款浏览器都内置了一个 JS 引擎，用来解析执行 JS 代码。因此，如果要运行 JS 代码，需要先创建一个 HTML 文件。</p> 
<p>在 HTML 中运行 JS 代码的方式有两种：内部 JS 和外部 JS。</p> 
<p>1、内部 JS</p> 
<p>2、外部 JS</p> 
<p>在 HTML 文件以外创建一个 <code>.js</code> 的文件，然后在 HTML 文件中引入。</p> 
<h4>二、格式</h4> 
<p>1、分号</p> 
<p>在 JS 中，每一个代码语句完成后，都应该以英文的 <code>;</code> 作为结束。</p> 
<pre> var a = 1;</pre> 
<p>2、语句</p> 
<p>从语法上来说，一行代码可以写多个语句，例如：</p> 
<pre> var a = 1; var a = 1; var a = 1; var a = 1;</pre> 
<p>但是，实际开发中不建议这样书写代码。通常一个 <code>;</code> 表示当前语句已经结束了，那么就换行再继续写下一行语句。</p> 
<pre> var a = 1; 
 var a = 1; 
 var a = 1; 
 var a = 1;</pre> 
<p>3、语句块</p> 
<p>JS 中可以通过 <code>{}</code> 来设置语句块，<code>{}</code> 中的代码要有一个 <code>Tab</code> 键的缩进。</p> 
<pre> {
     var a = 1;
     {
         var a = 1;
     }
 }</pre> 
<h4>三、注释</h4> 
<p>1、单行注释</p> 
<p>2、多行注释</p> 
<pre> /*
         范围内的都是注释
         范围内的都是注释
         范围内的都是注释
         范围内的都是注释
         范围内的都是注释
 */</pre> 
<h4>四、命名</h4> 
<p>在 JS 中，也会遇到需要我们自己用英文取名字的情况。但是，在 JS 中命名时需要注意以下几点：</p> 
<p>1、严格区分大小写</p> 
<p>同一个字母，大小写分别表示不同的名字：</p> 
<pre> username;
 userName;</pre> 
<p>上述代码是两个不同的名字。</p> 
<p>2、不能以数字开头</p> 
<p>通常，我们可以以字母、<code>_</code> 或者 <code>$</code> 符号作为名字的开头，但是<strong>不能以数字作为开头</strong>：</p> 
<pre> _useranme;
 1username; // 错误</pre> 
<p>3、常用的命名规则</p> 
<ul><li> <p>小驼峰命名法：如果名字是由多个单词组成，除了第一个单词外，后面所有的单词首字母都大写。</p> </li><li> <p>大驼峰命名法：如果名字是由多个单词组成，所有的单词首字母都大写。</p> </li><li> <p>蛇形命名法：如果名字是由多个单词组成，每一个单词之间用 <code>_</code> 连接。</p> </li></ul> 
<pre> userNumber;  // 小驼峰
 UserNumber;   // 大驼峰
 user_number;  //  蛇形命名法</pre> 
<h2>03 -《变量》</h2> 
<p>JS 中的变量，可以理解为是保存数据的容器。</p> 
<p>例如，我有一个密码：123456。</p> 
<p>在 JS 中，需要将该密码数据保存下来，方便后续的使用。而保存的方式，就是通过变量。</p> 
<h4>一、变量的创建</h4> 
<p>变量的创建，官方说法叫做“变量的声明”。</p> 
<p>基础语法：</p> 
<pre>var 自己取的变量名字 = 想要保存的数据;
</pre> 
<p>案例代码：</p> 
<pre>var password = 123456;
</pre> 
<p>在一个 JS 文件中，可以通过 <code>var</code> 创建多个变量，但是建议变量名不要重复，一旦重复，后面的变量名会将前面的变量名覆盖。</p> 
<h4>二、创建时不保存数据</h4> 
<p>创建时不保存数据，指的就是在创建变量时，不通过 <code>=</code> 给这个变量赋值。</p> 
<pre>var password;
</pre> 
<h4>三、输出变量</h4> 
<p>JS 中提供了 <code>console.log()</code> 方法来对数据进行输出：</p> 
<pre>var password = 123456;
console.log(password);
</pre> 
<p>在浏览器的 F12 中的 <code>console</code> 中查看输出结果。</p> 
<h4>四、变量的赋值</h4> 
<p>赋值，指的就是给变量中保存数据。赋值可以分为两种情况：</p> 
<ol><li> <p>创建变量的同时就进行赋值；</p> </li><li> <p>变量创建完成后，后续再赋值；</p> </li></ol> 
<pre>var a;
console.log(a);
a = 100;
console.log(a);
</pre> 
<h2>04 -《数据类型》</h2> 
<h4>一、数据类型的分类</h4> 
<p>在 JS 中，根据数据的种类对数据的类型进行划分为两个大类：</p> 
<ol><li> <p>基础（原始）类型数据</p> </li><li> <p>引用类型数据</p> </li></ol> 
<p>其中，基础类型的数据又分为 7 个小类（截至到 ES10）：</p> 
<ol><li> <p>字符串 <code>string</code></p> </li><li> <p>数字 <code>number</code></p> </li><li> <p>布尔值 <code>boolean</code></p> </li><li> <p>未定义 <code>undefined</code></p> </li><li> <p>空 <code>null</code></p> </li><li> <p>唯一值 <code>symbol</code>（ES6 新增）</p> </li><li> <p>无穷大 <code>bigInt</code>（ES10 新增）</p> </li></ol> 
<p>引用类型的数据只有 1 个小类：对象 <code>object</code>。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1d/4d/V5TyjdDZ_o.png"></p> 
<h4>一、字符串 string</h4> 
<p>字符串，指的是通过双引号或者单引号包裹起来的数据，都属于字符串类型。</p> 
<pre>var str1 = 'hello';
var str2 = "world";
var str3 = "123";
var str4 = "";
var str5 = "我的名字叫'张三'";
</pre> 
<p>注意：在字符串中，单引号可以包双引号，反过来双引号中也可以包裹单引号，但是不能同类型的引号互相包裹。</p> 
<p>字符串中的转义符</p> 
<p>如果我们字符串中出现了同类型引号互相包裹的情况，可以使用转义符 <code>\</code> 对字符串内部的引号进行转义。</p> 
<pre>var str6 = "我的名字叫\"张三\"";
</pre> 
<h4>二、数字 number</h4> 
<p>数字类型，指的是所有的整数和小数（浮点数）。</p> 
<pre>var num1 = 100;
var num2 = 0.1;
var num3 = .1;
</pre> 
<p>NaN</p> 
<p>NaN 是 JS 中的一种特殊值，表示非数字（Not a Number），但是属于 number 类型。</p> 
<p>注意：</p> 
<ol><li> <p>NaN 与任何数据都不相等，包括自己；</p> </li><li> <p>任何涉及到 NaN 的算术运算，得到的结果都是 NaN；</p> </li></ol> 
<h4>三、布尔值 boolean</h4> 
<p>布尔类型下面，只有两个值，就是 <code>true</code> 和 <code>false</code>。</p> 
<pre>var boo1 = true;
var boo2 = false;
</pre> 
<h4>四、未定义 undefined</h4> 
<p>undefined 类型中只有一个值，就是 undefined 本身，表示“未赋值”。</p> 
<h4>五、空 null</h4> 
<p>null 类型中只有一个值，就是 null 本身，表示“空”。</p> 
<p>null 有一个比较特殊的地方在于，当我们使用 <code>typeof</code> 检测 null 的数据类型时，得到的是 <code>object</code>。</p> 
<h4>六、唯一值 symbol</h4> 
<pre>var sym1 = Symbol();
var sym2 = Symbol();
console.log(sym1, sym2);
</pre> 
<h2>05 -《数据类型转换》</h2> 
<p>数据类型转换，分为两种方式：</p> 
<ul><li> <p>强制转换（显式转换）</p> </li><li> <p>自动转换（隐式转换）</p> </li></ul> 
<h4>一、强制转换（显式转换）</h4> 
<p>强制转换，指的就是我们手动的去调用一些方法，来实现数据类型的转换。JS 中提供了以下几种强制转换的方法：</p> 
<ol><li> <p>转换为数字：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code></p> </li><li> <p>转换为字符串：<code>String()</code>、<code>toString()</code></p> </li><li> <p>转换为布尔值：<code>Boolean()</code></p> </li></ol> 
<p>1、转换为数字</p> 
<p>基本用法如下：</p> 
<pre>var str = '100';
var num1 = Number(str);
var num2 = parseInt(str);
var num3 = parseFloat(str);
console.log(num1, num2, num3);
</pre> 
<p>转换规则：</p> 
<ol><li> <p><code>Number()</code> 是对数据进行整体的转换。如果数据整体是一个合法的数字，就直接转换为对应的数字，如果不是一个合法的数字，直接得到 NaN；</p> </li><li> <p><code>parseInt()</code> 是数据从左往右一个一个进行转换，如果是一个合法的数字，就留下来，继续转换下一个数字，直到遇到第一个不合法的数字时，直接结束转换过程。</p> </li><li> <p><code>parseFloat()</code>数据从左往右一个一个进行转换，如果是一个合法的数字或小数点（只有第一个小数点合法），就留下来，继续转换下一个数字，直到遇到第一个不合法的数字时，直接结束转换过程。</p> </li></ol> 
<p>2、转换为字符串</p> 
<p>基本语法如下：</p> 
<pre>var num = 200;
console.log(String(num));
console.log(num.toString());
</pre> 
<p><code>String()</code> 可以将任意数据类型都转换为字符串，<code>toString()</code> 可以将除了 <code>undefined</code> 和 <code>null</code> 以外的其他类型数据，都转换为字符串。</p> 
<p>3、转换为布尔值</p> 
<p>基础语法如下：</p> 
<pre>var a = 1;
var boo = Boolean(a);
console.log(boo);
</pre> 
<p>转换规则：</p> 
<p>除了 0、空字符串、NaN、undefined、null、false 这个六个数据以外，其他的数据转换为布尔值都是 true。</p> 
<p></p> 
<p>拓展：toLocalString()的妙用</p> 
<ol><li> <p>可以直接得到钱的分割效果</p> </li></ol> 
<pre>let num = 1000000
num.toLocaleString()  // '1,000,000'
</pre> 
<p>2.上面方法或许你还要自己再拼接 ¥ 来达到 ¥1,000,000.00 的效果 用以下方法可以直接得到 ¥1,000,000.00 的效果</p> 
<pre>let num = 1000000
num.toLocaleString('zh',{ style: 'currency', currency: 'cny' })  // '¥1,000,000.00'
</pre> 
<ol><li> <p>如果你想要达到 CNY 1,000,000.00 的效果可以这样</p> </li></ol> 
<pre>let num = 1000000
num.toLocaleString('zh',{ style: 'currency', currency: 'cny', currencyDisplay: 'code' })  // 'CNY 1,000,000.00'
</pre> 
<p></p> 
<ol><li> <p>也可以达到这种效果 '1,000,000.00人民币'</p> </li></ol> 
<pre>let num = 1000000
num.toLocaleString('zh',{ style: 'currency', currency: 'cny', currencyDisplay: 'name' })  // '1,000,000.00人民币'
</pre> 
<ol><li> <p>可以转换日期</p> </li></ol> 
<pre>new Date().toLocaleString() // '2022/1/7 下午2:00:05'
</pre> 
<p>6.可以转百分比</p> 
<pre> num.toLocaleString("zh", { style: "percent" }); // 100000000%
</pre> 
<h4>二、自动转换（隐式转换）</h4> 
<p>1、转换为数字</p> 
<p>当数据参与算术运算时，会隐式的转换为数字类型，然后再进行计算。</p> 
<p>因此，当我们获取到一个值，不是数字时，我们可以直接 <code>-0</code> 来将其转换为对应的数字。</p> 
<p>还可以~~数据</p> 
<pre> var b = '2';
 console.log(b - 0);
 console.log(~~b);</pre> 
<p>2、转换为字符串</p> 
<p>当数据进行 <code>+</code> 运算时，一旦参与运算的数据中有一个字符串，那么这些数据都自动拼接成一个整体的字符串，不再做加法运算。</p> 
<pre> var a = 1;
 console.log(a + '');</pre> 
<p>3、转换为布尔值</p> 
<pre> var a = 1;
 console.log(!!a);</pre> 
<h2>06 -《运算符》</h2> 
<p>JS 中提供了一组用来操作数据的运算符。</p> 
<h4>一、字符串拼接符</h4> 
<p><code>+</code> 加号可以用来实现字符串之间的拼接。</p> 
<pre>var str1 = 'hello';
var str2 = 'world';
console.log(str1 + " " + str2);
</pre> 
<h4>二、算术运算符</h4> 
<table><thead><tr><th>算术运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>求和</td></tr><tr><td>-</td><td>求差</td></tr><tr><td>*</td><td>求积</td></tr><tr><td>/</td><td>求商</td></tr><tr><td>%</td><td>求余</td></tr><tr><td>++</td><td>自增 1</td></tr><tr><td>--</td><td>自减 1</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>var num1 = 10;
var num2 = 4;
console.log(num1 + num2);
console.log(num1 - num2);
console.log(num1 * num2);
console.log(num1 / num2);
console.log(num1 % num2);
</pre> 
<p>自增（减）运算符</p> 
<p>自增（减）运算符分为了前置型和后置型。</p> 
<pre>var num = 10;
++num;
num++;
</pre> 
<p>如果在一行代码中，只有 <code>++</code> 或 <code>--</code> 操作，前置和后置的运行结果没有区别。</p> 
<p>如果在一行代码中，有两件事情要做，前置型则先运算再执行其他操作，后置型先执行其他操作再运算。</p> 
<h4>三、比较运算符</h4> 
<table><thead><tr><th>比较运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>===</td><td>（数据值和类型）全等</td></tr><tr><td>!==</td><td>全不等</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>var num1 = 10;
var num2 = '10';
console.log(num1 &gt; num2);
console.log(num1 &lt; num2);
console.log(num1 &gt;= num2);
console.log(num1 &lt;= num2);
console.log(num1 == num2);
console.log(num1 === num2);
console.log(num1 != num2);
console.log(num1 !== num2);
</pre> 
<p>说明：</p> 
<ul><li> <p>好理解的版本：<code>==</code> 只比较值，不比较类型；<code>===</code> 既要比较值也要比较类型；</p> </li><li> <p>真正原理的版本：<code>==</code> 在做比较前，会将类型不一致的数据隐式转换为同一个类型，然后再进行比较。<code>==</code> 和 <code>===</code> 在比较时都要比较值和类型。</p> </li></ul> 
<h4>四、逻辑运算符</h4> 
<table><thead><tr><th>逻辑运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>查找类型为 false 的值（如果不是布尔值，会隐式转换），找到后就留下这个值本身，如果找不到，就留下最后一个值；</td></tr><tr><td>两根竖线</td><td>查找类型为 true 的值（如果不是布尔值，会隐式转换），找到后就留下这个值本身，如果找不到，就留下最后一个值；</td></tr><tr><td>!</td><td>取反（如果不是布尔值，会隐式转换后再取反）</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>var a = 0;
var b = 1;
var c = 2;
console.log(a &amp;&amp; b &amp;&amp; c);
console.log(a || b || c);
console.log(!a);
</pre> 
<h4>五、赋值运算符</h4> 
<table><thead><tr><th>赋值运算符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>将 = 右边的内容赋值给 = 左边</td></tr><tr><td>+=</td><td>“变量名 = 变量名 + 值” 形式可以简写为：“变量名 += 值”</td></tr><tr><td>-=</td><td>“变量名 = 变量名 - 值” 形式可以简写为：“变量名 -= 值”</td></tr><tr><td>*=</td><td>“变量名 = 变量名 <em>值” 形式可以简写为：“变量名</em> = 值”</td></tr><tr><td>/=</td><td>“变量名 = 变量名 / 值” 形式可以简写为：“变量名 /= 值”</td></tr><tr><td>%=</td><td>“变量名 = 变量名 % 值” 形式可以简写为：“变量名 %= 值”</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>var a = 1;
a += 2;
console.log(a);   // 3
</pre> 
<h4>六、三目（元）运算符</h4> 
<p>三目（元）运算符的基础语法如下：</p> 
<pre>判断条件 ? 条件成立时执行 : 条件不成立时执行
</pre> 
<h4>七、特殊运算符 typeof</h4> 
<p><code>typeof</code> 可以用来检测数据的类型。（typeof 一个数组和null得到object）</p> 
<pre>var a = '123';
console.log(typeof a);
</pre> 
<h2>07 -《 输入输出》</h2> 
<h4>一、输入</h4> 
<p>JS 中提供了三个弹窗：</p> 
<ul><li> <p><code>alert()</code>：弹出一个提示窗口；</p> </li><li> <p><code>prompt()</code>：弹出一个输入框；</p> </li><li> <p><code>comfirm()</code>：弹出一个确认框，让用户选择确认或取消；</p> </li></ul> 
<h2>08 -《流程控制语句》</h2> 
<p>JS 中代码的执行顺序可以分为三种：</p> 
<ol><li> <p>顺序执行：代码从上往下依次执行；</p> </li><li> <p>选择执行：通过一些判断条件来控制某一段代码是否执行；</p> </li><li> <p>循环执行：控制某一段代码反复执行；</p> </li></ol> 
<h4>一、条件语句</h4> 
<p>我们可以通过条件语句来实现代码的选择执行。</p> 
<p>JS 中提供了以下几种条件语句：</p> 
<ul><li> <p><code>if</code></p> </li><li> <p><code>else</code></p> </li><li> <p><code>else if</code></p> </li><li> <p><code>switch case</code></p> </li></ul> 
<p>1、if</p> 
<pre>var a = 0;
// 如果 a &gt; 0 时，就执行以下输出语句
if (a &gt; 0) {
    // 当 if 小括号中的结果为 true 时，执行 if 大括号中代码
    console.log('hello');
}
console.log('world');
</pre> 
<p>2、else</p> 
<p>else 必须搭配 if 一起使用。基础语法：</p> 
<pre>if(判断条件) {
    判断条件为 true 时执行
} else {
    判断条件为 false 时执行
}
</pre> 
<p>案例代码：</p> 
<pre>var a = 0;
// 如果 a &gt; 0 时，就执行以下输出语句
if (a &gt;= 0) {
    // 当 if 小括号中的结果为 true 时，执行 if 大括号中代码
    console.log('hello');
} else {
    console.log('world');
}
</pre> 
<p>3、else if</p> 
<p><code>else if</code> 必须搭配 if 一起使用，基础语法如下：</p> 
<pre>if (判断条件一) {
    判断条件一为 true 时执行
} else if (判断条件二) {
    判断条件一为 false 且判断条件二为 true 时执行
} else if (判断条件三) {
    判断条件一二为 false 且判断条件三为 true 时执行
}
</pre> 
<p>案例代码：</p> 
<pre>var a = 0;
if (a &gt; 0) {
    console.log('进入 if');
} else if (a == 0) {
    console.log('进入 else if');
}
</pre> 
<p>4、三者搭配使用</p> 
<pre>var a = 0;
if (a &gt; 0) {
    console.log('进入 if');
} else if (a &lt; 0) {
    console.log('进入 else if');
} else {
    console.log('进入 else');
}
</pre> 
<p>练习：</p> 
<ol><li> <p>版本一：提示用户“输入 1 - 7 之间的任意数字”，如果输入的是 1-5，就提示工作日，否则就提示休息日；</p> </li><li> <p>版本二：提示用户“输入 1 - 7 之间的任意数字”，如果不在 1-7 的范围内，提示用户“输入有误”。如果输入的是 1-5，就提示工作日，否则就提示休息日；</p> </li></ol> 
<p>5、switch case</p> 
<p>基础语法：</p> 
<pre>switch (变量名) {
    case 第一个值:
        当变量名和第一个值全等时执行的代码;
        break;
    case 第二个值:
        当变量名和第二个值全等时执行的代码
    default:
        当变量名和所有 case 的值都不匹配时执行的代码
}
</pre> 
<p>案例代码：</p> 
<pre>var a = 3;
switch (a) {
    case 1:
        console.log('进入到第一个 case');
    case 2:
        console.log('进入到第二个 case');
        break;
    case 3:
        console.log('进入到第三个 case');
    case 4:
        console.log('进入到第四个 case');
    default:
        console.log('进入到 default');
}
</pre> 
<h4>二、循环语句</h4> 
<p>循环语句，就是可以让某一段代码反复执行多次。</p> 
<p>JS 中提供了以下三种循环语句：</p> 
<ol><li> <p><code>while</code></p> </li><li> <p><code>do...while</code></p> </li><li> <p><code>for</code></p> </li></ol> 
<p>1、while</p> 
<p>基础语法：</p> 
<pre>while (循环判断条件) {
    循环判断条件为 true 时执行的代码
}
</pre> 
<p>2、do while</p> 
<p>基础语法：</p> 
<pre>do {
    第一次执行不需要经过条件判断
    从第二次开始，每一次的循环都需要判断条件为 true 时执行
} while (循环判断条件)
</pre> 
<p>3、for</p> 
<p>基础语法：</p> 
<pre>for (创建变量并赋值; 条件判断; 修改变量的值) {
    当条件判断为 true 时执行的代码
}
</pre> 
<p>执行顺序：</p> 
<pre>for (1; 2; 3) {
    4
}
</pre> 
<p>执行顺序：1 - 2（true） - 4 - 3 - 2（true）- 4 - 3 - 243 … - 2（false）</p> 
<p>案例代码：</p> 
<pre>for (var i = 0; i &lt; 5; i++) {
    console.log(i);
}
</pre> 
<p>练习一：</p> 
<ol><li> <p>提示用户输入两个数字</p> </li><li> <p>输出用户输入的两个数字之间所有能够被 7 整除的数字，并且统计总共的数量，一个都没有的话也提示用户没有能整除的数。</p> </li><li> <p>扩展（考虑用户输入的数字大小先后）</p> </li></ol> 
<h4>三、终止循环</h4> 
<p>JS 中提供了两种终止循环的方式：</p> 
<ul><li> <p>break：立即结束离它最近的整个循环</p> </li><li> <p>continue：立即结束它最近的本次循环，立即进入下一次循环</p> </li></ul> 
<h2>09 -《数组基础 》</h2> 
<p>数组 Array，可以用来将多条数据通过 <code>[ ]</code> 包裹起来组成一个整体。</p> 
<p>例如：</p> 
<pre>var arr = [100, 'hello', true, 200];
</pre> 
<p>说明：</p> 
<ul><li> <p>元素（数组项）：数组中的每一条数据，都可以叫做数组的“元素”，也可以叫做“数组项”；</p> </li><li> <p>下标（索引）：数组中的每一条数据在数组中都有一个对应的位置，我们通过数字来表示每一条数据位置。但是要注意，数字从 0 开始取值。这个用来表示位置的数字，我们可以叫做数组的“下标”或者数组的“索引”。</p> </li></ul> 
<h4>一、数组的特点</h4> 
<ul><li> <p>无类型限制：数组中可以保存任意类型的数据；</p> </li><li> <p>无数量限制：数组中可以保存任意数量的数据；</p> </li><li> <p>动态数组：数组创建完成后，后续还可以继续对数组中的元素进行增加、修改、删除等操作；</p> </li></ul> 
<h4>二、数组的创建</h4> 
<p>数组的创建分为两种形式：字面量方式和构造函数方式。</p> 
<p>1、字面量方式</p> 
<pre>var 变量名 = [];
</pre> 
<p>2、构造函数方式</p> 
<pre>var 变量名 = new Array();
</pre> 
<h4>三、数组创建并保存数据</h4> 
<p>在创建数组时，就保存数据到数组中：</p> 
<pre>var 变量名 = [数据一, 数据二...];
var 变量名 = new Array(数据一, 数据二...);
</pre> 
<h4>四、数组的下标（索引）</h4> 
<p>我们可以通过数组的下标，找到数组中对应位置的数据，然后对数据进行增加、删除、修改、查看等操作。</p> 
<p>1、查看</p> 
<pre>var arr = ['a', 'b', 'c'];
console.log(arr[1]);
console.log(arr[2]);
console.log(arr[5]);
</pre> 
<p>2、增加</p> 
<pre>var arr = ['a', 'b', 'c'];
arr[3] = 'd';
arr[5] = 'e';
console.log(arr);
</pre> 
<p>3、修改</p> 
<pre>var arr = ['a', 'b', 'c'];
arr[0] = 'd';
console.log(arr);
</pre> 
<p>4、删除（了解）</p> 
<p>通过 delete 删除的元素，会保留原位置：</p> 
<pre>var arr = ['a', 'b', 'c'];
delete arr[0];
console.log(arr);
</pre> 
<h4>五、数组的长度</h4> 
<p>每一个数组身上，都有一个 <code>length</code> 的属性，用来表示数组的长度（数组中元素的个数）。</p> 
<pre>// 获取数组的长度
var len = arr.length;
console.log(len);
// 修改数组的长度
arr.length = 0;
</pre> 
<h4>六、数组的遍历</h4> 
<p>遍历，指的是依次访问数组中的每一个元素。</p> 
<pre>for(var i = 0; i &lt; 数组名.length; i++) {
    console.log(数组名[i]);
}
</pre> 
<h4>七、多维（二维）数组（了解）</h4> 
<p>数组中的元素也可以是数组，这样形式的数组，我们叫做多维数组。</p> 
<pre>var arr = [
    ['a', 'b'],
    ['c', 'd', 'e']
];
</pre> 
<p>多维数组的遍历，根据数组嵌套的层数，来嵌套 for 循环实现每一个元素的遍历：</p> 
<pre>for(var i = 0; i &lt; 数组名.length; i++) {
    for(var j = 0; j &lt; 数组名[i].length; j++) {
        console.log(数组名[i][j]);
    }
}
</pre> 
<p>练习：</p> 
<ol><li> <p>求出给定数组中所有数字的和、以及所有奇数和、偶数和。（简单）</p> </li><li> <p>在不排序的前提下，找出数组中的最大值和最小值。（中等）</p> </li><li> <p>找出某一个值在数组中第一次出现的下标。（简单）</p> </li><li> <p>找出数组中重复的值（假设只有一组重复的值）。（偏难）</p> </li><li> <p>将数组中的元素按照从小到大的顺序进行排序。（面试题 - 难）</p> </li><li> <p>实现一个多用户版的3次循环登录。例如用户数据如下：</p> <pre>var users = [
    ['zhangsan', '123'],
    ['lisi', '000']
]
</pre> <p>要求：两个账号任意一组都能登录成功。</p> </li></ol> 
<h2>10 -《数组的常见方法（API）》</h2> 
<h4>一、操作方法</h4> 
<table><thead><tr><th>方法</th><th>参数（小括号中的值）</th><th>说明</th><th>是否改变原数组</th><th>返回值</th></tr></thead><tbody><tr><td><code>push()</code></td><td>要添加的数据，可以有多个，每个数据之间用 <code>,</code> 隔开</td><td>向数组末尾添加元素</td><td>是</td><td>数组长度</td></tr><tr><td><code>pop()</code></td><td>无</td><td>删除数组中最后一个元素</td><td>是</td><td>删除的元素</td></tr><tr><td><code>unshift()</code></td><td>要添加的数据，可以有多个，每个数据之间用 <code>,</code> 隔开</td><td>向数组开头添加元素</td><td>是</td><td>数组长度</td></tr><tr><td><code>shift()</code></td><td>无</td><td>删除数组中第一个元素</td><td>是</td><td>删除的元素</td></tr><tr><td><code>splice()</code></td><td>1. 只有一个参数：修改后的长度 2. 两个参数：下标和删除的元素个数 3. 三个及以上：下标、删除元素的个数、新增的元素</td><td>1. 修改数组长度 2. 删除任意位置元素 3. 在任意位置新增元素 4. 修改任意位置元素</td><td>是</td><td>删除的元素</td></tr></tbody></table> 
<p>代码案例：</p> 
<pre>var arr = ['a', 'b', 'c', 'd', 'e'];
console.log('原数组：', arr);
var result = arr.push('a', 'b');
var result = arr.pop();
var result = arr.unshift('hello', 'world', 'e');
var result = arr.shift();
var result = arr.splice(0, 1, 'hello');
console.log('操作后的数组：', arr);
console.log('返回值：', result);
</pre> 
<p>练习：去掉数组中重复的多余元素。</p> 
<h4>二、查询方法</h4> 
<p>数组的查询方法，可以用来查询指定元素在数组中是否存在，以及元素的位置。</p> 
<table><thead><tr><th>方法</th><th>参数（小括号中的值）</th><th>说明</th><th>是否改变原数组</th><th>返回值</th></tr></thead><tbody><tr><td><code>indexOf()</code></td><td>需要查询的元素</td><td>查询元素在数中第一次出现的下标</td><td>否</td><td>下标 没找到则返回 -1</td></tr><tr><td><code>lastIndexOf()</code></td><td>需要查询的元素</td><td>查询元素在数组中最后一次出现的下标</td><td>否</td><td>下标 没找到则返回 -1</td></tr><tr><td><code>includes()</code></td><td>需要查询的元素</td><td>查询元素在数组中是否存在</td><td>否</td><td>布尔值</td></tr></tbody></table> 
<pre>var arr = ['a', 'b', 'c', 'd', 'e', 'b'];
console.log('原数组：', arr);
var result = arr.indexOf('f');
var result = arr.lastIndexOf('b');
var result = arr.includes('b');
console.log('操作后的数组：', arr);
console.log('结果：', result);
</pre> 
<h4>三、排序方法</h4> 
<table><thead><tr><th>方法</th><th>参数（小括号中的值）</th><th>说明</th><th>是否改变原数组</th><th>返回值</th></tr></thead><tbody><tr><td><code>reverse()</code></td><td>无</td><td>反转数组元素的顺序</td><td>是</td><td>倒序后的新数组</td></tr><tr><td><code>sort()</code></td><td><code>function(a, b) { return a - b }</code> <code>function(a, b) { return b - a }</code></td><td>1. <code>a - b</code> 从小到大排序 2. <code>b - a</code> 从大到小排序</td><td>是</td><td>排序后的新数组</td></tr></tbody></table> 
<p>代码案例：</p> 
<pre>var arr = [10, 12, 5, 8, 15, 4, 9, 0];
console.log('原数组：', arr);
var result = arr.reverse();
var result = arr.sort(function(a, b) {
    return b - a;
})
console.log('操作后的数组：', arr);
console.log('结果：', result);
</pre> 
<p>数组包对象的排序的方法</p> 
<p>升序</p> 
<pre>let data = [
                {value: 335, name: '家电'},
                {value: 310, name: '服装'},
                {value: 274, name: '食品'},
                {value: 235, name: '数码'},
                {value: 400, name: '家纺'}
            ]
data.sort(function (a, b) { return a.value - b.value; })      
</pre> 
<p></p> 
<p>降序</p> 
<pre>let data = [
                {value: 335, name: '家电'},
                {value: 310, name: '服装'},
                {value: 274, name: '食品'},
                {value: 235, name: '数码'},
                {value: 400, name: '家纺'}
            ]
data.sort(function (a, b) { return b.value - a.value; })      
</pre> 
<p>结论 可用于数组排查，数组对象排序，echarts柱状图排序等等</p> 
<p></p> 
<h4>四、数组和字符串的转换方法</h4> 
<table><thead><tr><th>方法</th><th>参数（小括号中的值）</th><th>说明</th><th>是否改变原本的值</th><th>返回值</th></tr></thead><tbody><tr><td><code>join()</code></td><td>任意字符串</td><td>将数组元素按照指定字符拼接成一个大字符串（数组转字符串）</td><td>否</td><td>拼接后的字符串</td></tr><tr><td><code>split()</code></td><td>任意字符串</td><td>将字符串按照指定的字符拆分成一个数组</td><td>否</td><td>拆分后的新数组</td></tr></tbody></table> 
<p>说明：<code>split()</code> 不是数组的方法，而是字符串的方法，split()可以接正则。比如：<code>"xiaowang0ok1235" .split(/\d+/)</code></p> 
<pre>// 数字转字符串
var arr = [1, 2, 3, 4];
console.log('原数组：', arr);
var result = arr.join('');
console.log('操作后的数组：', arr);
console.log('结果：', result);
// 字符串转数组
var str = 'hello';
console.log('原字符串：', str);
var result = str.split('e');
console.log('操作后的字符串：', str);
console.log('结果：', result);
</pre> 
<h4>五、数组的合并和截取</h4> 
<table><thead><tr><th>方法</th><th>参数（小括号中的值）</th><th>说明</th><th>是否改变原本的数组</th><th>返回值</th></tr></thead><tbody><tr><td><code>concat()</code></td><td>需要合并的数组或值，多个数据之间用 <code>,</code> 隔开</td><td>可以将多个数组或值合并成一个新的数组</td><td>否</td><td>合并后的新数组</td></tr><tr><td><code>slice()</code></td><td>1. 只有一个参数：开始截取的下标（包含） 2. 两个参数：开始截取的下标（包含）、结束截取的下标（不包含） 说明：可以为负数</td><td>截取数组中的某一个部分</td><td>否</td><td>截取后的新数组</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>var arr1 = ['a', 'b', 'c'];
var arr2 = [4, 5, 6];
var arr3 = [7, 8, 9];
var result = arr1.concat(arr2, arr3, 10);
var sliceResult = result.slice(2, -1);
console.log('原数组：', result);
console.log('结果：', sliceResult);
</pre> 
<h2>11 -《数组的遍历方法》</h2> 
<h4>一、for 循环</h4> 
<pre>var arr = ['a', 'b', 'c', 'd'];
for(var i = 0; i &lt; arr.length; i++) {
    console.log(arr[i]);
}
</pre> 
<p>优化版的 for 循环</p> 
<p>将数组的长度先计算出来，避免每一次循环的时候重复计算数组长度：</p> 
<pre>var arr = ['a', 'b', 'c', 'd'];
for (var i = 0, len = arr.length; i &lt; len; i++) {
    console.log(arr[i]);
}
</pre> 
<h4>二、for of</h4> 
<p>ES6 中新增了 for of 用来遍历数组。</p> 
<p>其中 <code>item</code> 是任意变量名，<code>arr</code> 是要遍历的数组名。</p> 
<pre>var arr = ['a', 'b', 'c', 'd'];
for (var item of arr) {
    console.log(item);
}
</pre> 
<p><code>item</code> 可以接收到数组中的每一条数据。</p> 
<h4>三、数组的循环方法</h4> 
<p>1、forEach()</p> 
<pre>var arr = ['a', 'b', 'c', 'd'];
arr.forEach(function (item, index) {
    console.log(`当前元素${item}，对应的下标${index}`);
})
</pre> 
<p>注意：<code>forEach()</code> 循环中不能使用 <code>break</code> 和 <code>continue</code>。</p> 
<p>2、map()</p> 
<pre>var arr = [10, 20, 30, 40];
var result = arr.map(function (item, index) {
    console.log(`当前元素${item}，对应的下标${index}`);
    return item * 2;
});
var result = arr.map(function (item, index) {
    console.log(`当前元素${item}，对应的下标${index}`);
    if (item &gt; 20) {
        return item * 2;
    } else {
        return item;
    }
});
console.log(result);
</pre> 
<p>说明：</p> 
<ol><li> <p><code>map()</code> 可以正常的遍历数组，获取到数组的元素和下标；</p> </li><li> <p>在 map 的方法中设置 <code>return 新数据</code>，最终这些“新数据”会组成一个新数组。</p> </li></ol> 
<p>注意：</p> 
<ol><li> <p>新数组和原数组的长度一定是一致的；</p> </li><li> <p>新数组中的数据和原数组中的数据可以不一致；</p> </li></ol> 
<p>3、filter()</p> 
<pre>var arr = [10, 20, 30, 40];
var result = arr.filter(function (item, index) {
    console.log(`当前元素${item}，对应的下标${index}`);
    return item &gt; 20;
})
console.log(result);
</pre> 
<p>说明：</p> 
<ol><li> <p><code>filter()</code> 可以正常的遍历数组，获取到数组的元素和下标；</p> </li><li> <p>在 filter 方法中设置 <code>return 筛选条件</code>，最终满足“筛选条件”的 <code>item</code> 会组成一个新数组。</p> </li></ol> 
<p>注意：</p> 
<ol><li> <p>新数组和原数组的长度可以不一致；</p> </li><li> <p>新数组中的数据，一定是来源于原数组且不会发生改变；</p> </li></ol> 
<p>练习：</p> 
<p>1、用 <code>filter</code> 方法实现数组的去重；</p> 
<p>2、给出以下数组（数组中的第一个元素是班级名称，第二个元素是班级中的学生姓名）：</p> 
<pre>var classesData = [
    ['Web01', ['张三', '李四']],
    ['Web02', ['张三']],
    ['Java01', ['张三', '李四', '王五']],
    ['Java02']
]
</pre> 
<p>要求：</p> 
<ul><li> <p>找到所有的班级名称，组成一个新数组 <code>['Web01', 'Web02', 'Java01', 'Java02']</code>；</p> </li><li> <p>找到所有班级名称以及班级学生人数，组成新数组 <code>[['Web01', 2], ['Web02', 1], ['Java01', 3], ['Java02', 0]]</code>；</p> </li></ul> 
<p>3、数组扁平化。将以下二维数组变成一维数组：</p> 
<pre>var arr = ['a', 'b', ['c', 'd'], 'e', ['f']];
// 变成 ['a', 'b', 'c', 'd', 'e', 'f']
</pre> 
<p>4、every() 和 some()</p> 
<p>every() 和 some() 都可以遍历数组，同时，这两个方法执行完成后，会得到一个布尔值。</p> 
<pre>var arr = [10, 20, 30, 40];
var everyResult = arr.every(function (item, index) {
    return item &gt;= 10;
});
var someResult = arr.some(function (item, index) {
    return item &gt; 40;
});
</pre> 
<p>结论：</p> 
<ol><li> <p><code>every()</code>：一假得假；</p> </li><li> <p><code>some()</code>：一真得真；</p> </li></ol> 
<p>5、reduce()</p> 
<pre>var arr = [[10, 20], 30, 40];
var result = arr.reduce(function (item, next) {
    console.log(item, next);
    return item + next;
}, 0)
var result = arr.reduce(function (item, next) {
    // []  10 ---- [10]
    // [10] 20 ---- [10, 20]
    // [10, 20] [30, 40] ---- [10, 20, 30, 40]
    return item.concat(next)
}, [])
console.log(result);
</pre> 
<h4>四、总结</h4> 
<ol><li> <p><code>forEach()</code> 可以遍历得到元素和下标；不能使用 <code>break</code> 和 <code>continue</code>；</p> </li><li> <p><code>map()</code> 可以遍历得到元素和下标；可以得到新数组，且与原数组长度一致，内容可以不一致；</p> </li><li> <p><code>filter()</code> 可以遍历得到元素和下标；可以得到新数组，且与原数组内容一致，长度可以不一致；</p> </li><li> <p><code>some()</code> 可以遍历得到元素和下标；可以得到布尔值，一真得真；</p> </li><li> <p><code>every()</code> 可以遍历得到元素和下标；可以得到布尔值，一假得假；</p> </li><li> <p><code>reduce()</code> 可以遍历得到元素；</p> </li><li> <p><code>find()</code>：自学作业！自己去学习这个方法的使用！</p> </li></ol> 
<h2>12 -《函数》</h2> 
<p>函数的作用，可以将一段代码包裹成一个整体。而我们选择将一段代码包裹成一个整体的目的有两个：</p> 
<ol><li> <p>当代码量庞大且复杂时，我们可以通过函数来将代码拆分成独立的小功能；</p> </li><li> <p>当一段代码需要在不同时间反复使用时，我们通过函数将代码包裹起来，需要使用时直接使用函数即可。</p> </li></ol> 
<h4>一、创建函数</h4> 
<p>JS 中创建函数的方式有两种：声明式函数、函数表达式。</p> 
<p>1、声明式函数</p> 
<p>基础语法：</p> 
<pre>function 函数名 () {
    // 函数内的代码
}
</pre> 
<p>2、函数表达式</p> 
<p>基础语法：</p> 
<pre>var 变量（函数）名 = function () {
    // 函数内的代码
}
</pre> 
<h4>二、调用函数</h4> 
<p>函数创建好后默认不会执行函数内部的代码。需要我们调用函数，才能执行函数内部的代码。</p> 
<p>基础语法：</p> 
<pre>函数名();
</pre> 
<p>同一个函数，可以反复调用多次，每次调用，函数内的代码都会重新全部执行一次。</p> 
<p>案例代码：</p> 
<pre>function foo() {
    console.log('hello');
}
foo();
foo();
foo();
</pre> 
<h4>三、函数的参数</h4> 
<p>当我们创建的一个函数中，在使用时我们希望函数内部的代码有一部分内容是可以发生变化的。那么，这一部分变化的内容，就可以作为函数的参数来进行处理。</p> 
<p>基础语法：</p> 
<pre>function 函数名 (形式参数名1, 形式参数名2) {
    // 函数内容
    // 使用形式参数
}
函数名(实际参数1, 实际参数2);
</pre> 
<p>说明：</p> 
<ol><li> <p>在创建函数时，定义的参数，叫做形式参数，简称“形参”。形参可以看作就是函数内部的变量名；</p> </li><li> <p>在调用函数时，传递的参数，叫做实际参数，简称“实参”。实参可以看作传递给函数内部的数据；</p> </li><li> <p>从语法上来说，形参和实参的个数可以不一致；</p> </li></ol> 
<p>案例代码：</p> 
<pre>function foo(username) {
    console.log('hello ' + username);
}
foo('张三');
foo('李四');
</pre> 
<p>练习：</p> 
<ol><li> <p>封装一个求和的函数。用户任意传入两个数字，求出这两个数之间所有数之和，如果用户只传入一个数，就求出 0 到这个数之间所有整数的和；</p> </li><li> <p>封装一个日期格式化的函数。</p> 
  <ul><li> <p>用户传入一个日期（例如：20220325），我们在函数中将日期处理成 <code>2022年03月25日</code> 的格式。</p> </li><li> <p>用户传入一个日期和一个符号（例如：<code>-</code>），我们在函数中将日期处理成用指定符号拼接的格式，例如 <code>2022-03-25</code>。</p> </li></ul></li></ol> 
<h4>四、作用域</h4> 
<p>作用域，指的就是作用范围。</p> 
<p>当一个函数创建成功时，该函数就自动将函数内部和函数外部划分成了两个区域。函数外部的区域我们称之为“全局作用域”，函数内部的区域我们称之为“局部（函数）作用域”。</p> 
<p>1、全局作用域</p> 
<p>全局作用域，我们可以看作是一个公共区域。意思就是说我们设置在全局作用域中的数据，任何地方都可以使用。</p> 
<pre>var a = 1;
function foo() {
    console.log('函数内部', a);
}
foo();
console.log('函数外部', a);
</pre> 
<p>2、局部作用域</p> 
<p>局部作用域，我们可以看作是一个私有区域。意思就是说我们设置在局部作用域中的数据，只能在当前函数中使用。</p> 
<pre>function foo() {
    var a = 1;
    console.log('函数内部', a);
}
foo();
console.log('函数外部', a);  // 报错：a is not defined
</pre> 
<p>说明：</p> 
<ol><li> <p>全局作用域和局部作用域中的变量名可以重名；</p> </li><li> <p>使用重名的变量时，优先使用当前作用域中的变量；</p> </li></ol> 
<h4>五、函数的返回值</h4> 
<p>函数中，除了可以自己去定义一些函数需要执行的业务代码外，我们还可以通过 <code>return</code> 来将函数内部的数据返回到函数外部。</p> 
<p>函数内部设置返回值的基础语法：</p> 
<pre>function 函数名() {
    // 内部代码
    return 数据值;
}
</pre> 
<p>函数外部接收返回值得基础语法：</p> 
<pre>var 变量名 = 函数名();  // 变量名用来接收返回值
</pre> 
<p>案例代码：</p> 
<pre>function foo() {
    var a = 1;
    return a;
}
var result = foo();
</pre> 
<p>注意事项：</p> 
<ol><li> <p><code>return</code> 执行完成后，会立即结束当前函数；</p> </li><li> <p><code>return</code> 最多只能返回一个值，也可以不返回值；</p> </li><li> <p>如果没有 <code>return</code> 语句或者 <code>return</code> 后面没有值，外部接收到的都是 <code>undefined</code>；</p> </li></ol> 
<h2>13 -《ES6 中的函数》</h2> 
<h4>一、形参的默认值</h4> 
<p>形参的默认值，是当没有传递对应的实参时，才会使用默认值。如果传递了实参，默认值就不会生效。</p> 
<p>基础语法：</p> 
<pre>function 函数名(形参名 = 默认值) {
}
函数名()
</pre> 
<p>案例代码：</p> 
<pre>function foo(x = 0, y = 0) {
    console.log(x + y);
}
foo(1);
</pre> 
<h4>二、rest 参数（不定参数）</h4> 
<p>基础语法：</p> 
<pre>function 函数名(...不定参数名) {
}
函数名()
</pre> 
<p>说明：不定参数可以以数组的形式，接收到所有没有对应形参的实参。</p> 
<p>案例代码：</p> 
<pre>function foo(a, ...b) {
    console.log(b);  // [ 2, 3, 4]
}
foo(1, 2, 3, 4)
</pre> 
<p>注意：</p> 
<ol><li> <p>在使用时，普通形参和不定参数可以同时存在；</p> </li><li> <p>不定参数只能是最后一个参数；</p> </li></ol> 
<h4>三、箭头函数</h4> 
<p>箭头函数，就是用 <code>=&gt;</code> 取代了 <code>function</code> 关键字。</p> 
<p>普通函数的基础语法：</p> 
<pre>var 变量（函数）名 = function () {
    // 函数内的代码
}
</pre> 
<p>更换为箭头函数，去掉 <code>function</code> 关键字，在 <code>()</code> 和 <code>{}</code> 中间加一个 <code>=&gt;</code>：</p> 
<pre>var 变量（函数）名 = () =&gt; {
    // 函数内的代码
}
</pre> 
<p>箭头函数的简写</p> 
<p>箭头函数的简写，主要分为两种情况：</p> 
<p>1）只有一个形参，可以去掉小括号 <code>()</code>；</p> 
<pre>var 函数名 = (形参名) =&gt; {
}
// 简写
var 函数名 = 形参名 =&gt; {
}
</pre> 
<p>2）函数内只有一个 <code>return</code> 语句，可以去掉 <code>return</code> 和函数的大括号 <code>{}</code>；</p> 
<pre>var 函数名 = () =&gt; {
    return 值;
}
// 简写
var 函数名 = () =&gt; 值;
</pre> 
<p>案例代码：</p> 
<pre>// 普通函数
function foo(x, y) {
    return x + y
}
// 箭头函数
var foo = (x, y) =&gt; x + y;
foo(1, 2);
var bar = x =&gt; x * x;     
console.log(bar(3));
</pre> 
<h2>14 -《对象 object》</h2> 
<p>对象，和数组一样，也可以用来将一组数据包裹成一个整体。但是对象的符号是 <code>{}</code>。</p> 
<p>对象和数组的区别在于，数组中每一条数据都有固定的位置，我们需要记住每一条数据所在的位置。 在对象中，数据是无序的，但是对象中每一条数据都是有一个自己的“名字”，称为“键”，而数据本身，称为“值”。对象中，保存的数据，都是以“键值对”的形式进行保存。</p> 
<h4>一、创建对象</h4> 
<p>对象的创建分为两种形式：字面量方式和构造函数方式。</p> 
<p>1、字面量方式</p> 
<pre>var obj = {};
</pre> 
<p>2、构造函数方式</p> 
<pre>var obj = new Object();
</pre> 
<h4>二、对象保存数据</h4> 
<p>基础语法：</p> 
<pre>var obj = {
    键一: 值一,
    键二: 值二,
    // ....
}
</pre> 
<p>注意：</p> 
<ol><li> <p>对象的值可以是任意类型的数据；</p> </li><li> <p>对象的键是字符串类型（引号可以省略不写）</p> </li></ol> 
<p>案例代码：</p> 
<pre>var obj = {
    account: '123',
    password: '456',
    money: 10000
}
console.log(obj);
var users = [
    { account: '1', password: '1', money: 1000 },
    { account: '2', password: '2', money: 2000 },
    { account: '3', password: '3', money: 3000 },
];
</pre> 
<h4>三、对象的属性和方法</h4> 
<p>因为对象中可以保存任意类型的数据，因此，我们根据数据值的类型是不是函数，来将对象中的数据又划分成了两类：</p> 
<ol><li> <p>如果数据值是函数，那么这条数据也可以称为“对象的方法”；</p> </li><li> <p>如果数据值不是函数，那么这条数据也可以称为“对象的属性”；</p> </li></ol> 
<p>例如，我们想要创建一个学生对象，用来保存学生的相关信息。包括：学生的姓名、年龄、性别以及学生的能力学习、吃饭、睡觉等。</p> 
<pre>var student = {
    // 对象的属性
    name: '张三',
    age: 20,
    gender: '男',
    // 对象的方法
    study: function() {
        // ...
    },
    eat: function() {
    },
    sleep: function() {
    }
}
</pre> 
<h4>四、操作对象属性</h4> 
<p>在 JS 中，不管我们要对对象的属性做增删查改中的任意一个操作，都是通过 <code>.</code> 点符号来实现的。</p> 
<p>1、新增对象属性</p> 
<p>基础语法：</p> 
<pre>对象名.属性名（键）= 属性值（值）;
</pre> 
<p>案例代码：</p> 
<pre>var student = {};
student.name = "张三";
student.age = 20;
</pre> 
<p>2、修改对象属性</p> 
<p>基础语法：</p> 
<pre>对象名.属性名（键）= 属性值（值）;
</pre> 
<p>案例代码：</p> 
<pre>var student = {
    gender: '男'
};
student.gender = "女";
</pre> 
<p>说明：一个对象中，不可能出现重复的“键”，如果出现重名的情况，后面的值会覆盖掉前面的值。</p> 
<p>3、查看对象属性</p> 
<pre>var student = {
    gender: '男'
};
student.name = "张三";
student.age = 20;
student.gender = "女";
console.log(student.name);
</pre> 
<p>4、删除对象属性</p> 
<p>基础语法：</p> 
<pre>delete 对象名.属性名;
</pre> 
<p>案例代码：</p> 
<pre>var student = {};
student.name = "张三";
student.age = 20;
student.gender = "女";
delete student.age;
console.log(student);
</pre> 
<p>5、中括号访问对象的属性</p> 
<p>除了用 <code>.</code> 去访问对象的属性外，也可以使用 <code>[]</code> 去访问。</p> 
<p>基础语法：</p> 
<pre>对象名["属性名(键)"]
</pre> 
<p><strong>通常，只有当属性名（键）是一个变量时，我们才使用 <code>[]</code>。</strong></p> 
<p>基础语法：</p> 
<pre>对象名[变量名]
</pre> 
<p>案例代码：</p> 
<pre>var key = "age";
var student = {
    name: '张三',
    [key]: 20
}
student[key] = 30;
console.log(student);
</pre> 
<p>练习：</p> 
<p>1）以下列用户数据实现一个登录。</p> 
<pre>var users = [
    { username: '123', password: '123' },
    { username: '000', password: '000' }
]
</pre> 
<p>2）计算出数组中每一个元素在数组中出现的次数：</p> 
<pre>var arr = ["a", "a", "b", "c", "a", "b"];
</pre> 
<h4>五、操作对象的方法</h4> 
<pre>var student = {
    sayHello: function () {
        console.log('hello');
    }
}
student.sayHello();
student.sayHi = function () {
    console.log('hi');
}
student.sayHi();
</pre> 
<h4>六、对象的简写（ES6）</h4> 
<p>ES6 中针对对象，提供了两种简写形式：</p> 
<p>1）对象的值是一个变量，且变量的单词和对象的键是同一个单词。那么就可以将 <code>: 值</code> 省略。</p> 
<pre>var name = '张三';
var age = 20;
var student = {
    // name: name,
    // age: age
    name,
    age
}
console.log(student);
</pre> 
<p>2）对象的值是一个函数，可以将 <code>: function</code> 省略。</p> 
<pre>var student = {
    // sayHello: function () {
    //     console.log('hello');
    // },
    sayHello() {
        console.log('hello');
    }
}
</pre> 
<h4>七、对象的遍历</h4> 
<p>1、for in</p> 
<pre>var student = {
    name: '张三',
    age: 20
}
for (var key in student) {
    console.log(student[key]);
}
</pre> 
<p>2、Object.keys()</p> 
<pre>var student = {
    name: '张三',
    age: 20
}
Object.keys(student).forEach(key =&gt; {
    console.log(student[key]);
})
</pre> 
<h2>01 -《BOM 和 DOM》</h2> 
<p>JavaScript 的核心是分为三个部分：</p> 
<ol><li> <p>ECMAScript：JavaScript 的语法规范</p> </li><li> <p>BOM</p> </li><li> <p>DOM</p> </li></ol> 
<h4>BOM 和 DOM</h4> 
<p>BOM，是 Browser Object Model 的缩写，翻译成“浏览器对象模型”，BOM 中提供了很多操作浏览器的方法。</p> 
<p>DOM，是 Document Object Model 的缩写，翻译成“文档对象模型”，DOM 中提供了很多操作 HTML 文档的方法。</p> 
<h4>BOM 和 DOM 的关系</h4> 
<p>在 BOM 中，包含了很多的对象：</p> 
<ol><li> <p>window 对象：浏览器窗口对象(用<code>window .open = "../影院1.html"</code>可实现点击事件页面跳转)。</p> </li><li> <p>location 对象：浏览器 URL 地址对象(用<code>location.href = "../影院1.html"</code>可实现点击事件页面跳转)；<code>reload()</code>刷新当前页面。</p> </li><li> <p>screen 对象：屏幕对象</p> </li><li> <p>history 对象：浏览记录对象<code>back()</code>;返回上一个页面；<code>forward()</code>前进下一个页面；<code>go(数字)</code>跳转到指定的页面。</p> </li><li> <p>navigator 对象：浏览器对象</p> </li><li> <p>document 对象：文档对象</p> </li></ol> 
<p>由于 document 对象中包含的内容太多，因此，W3C 组织就将 document 对象单独提取出来，做成了一套规范，取名 DOM。</p> 
<h2>02 -《BOM》</h2> 
<h4>window 对象</h4> 
<p>1、常用属性</p> 
<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><code>innerHeight/innerWidth</code></td><td>视口（文档显示区）宽高</td></tr><tr><td><code>outerHeight/outerWidth</code></td><td>浏览器窗口宽高</td></tr><tr><td><code>screenLeft/screenTop</code></td><td>浏览器左上角到屏幕左上角的距离</td></tr></tbody></table> 
<pre>console.log(window);
console.log('innerHeight', window.innerHeight);
console.log('innerWidth', window.innerWidth);
console.log('outerHeight', window.outerHeight);
console.log('outerWidth', window.outerWidth);
console.log('screenLeft', window.screenLeft);
console.log('screenTop', window.screenTop);
</pre> 
<p>2、常用方法</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>open()</code></td><td>页面路径</td><td>打开一个新窗口</td></tr><tr><td><code>setInterval()</code></td><td>1. 函数 2. 时间（单位：毫秒）</td><td>间隔指定时间循环执行函数(最后执行)</td></tr><tr><td><code>setTimeout()</code></td><td>1. 函数 2. 时间（单位：毫秒）</td><td>延迟指定时间执行函数一次</td></tr><tr><td><code>clearInterval()</code></td><td>需要暂停的 <code>setInterval()</code> 名字</td><td>暂停 <code>setInterval()</code></td></tr><tr><td><code>clearTimeout()</code></td><td>需要暂停的 <code>setTimeout()</code> 名字</td><td>暂停 <code>setTimeout()</code></td></tr></tbody></table> 
<pre>var timer = setTimeout(() =&gt; {
    console.log(1);
}, 1000);
clearTimeout(timer);
var i = 0;
var timer = setInterval(() =&gt; {
    i++;
    if (i === 5) {
        clearInterval(timer);
    }
    console.log(i);
}, 1000);
</pre> 
<p>说明：</p> 
<p><code>setInterval</code> 和 <code>setTimeout</code> 都不会阻塞后面代码的执行。原因在于，这两个时间函数不管写在代码中的任何位置，它们都是最后执行。</p> 
<h2>03 -《元素节点操作》</h2> 
<h4>一、获取元素节点</h4> 
<p>获取元素节点，指的就是通过 JS 获取到页面中的 HTML 标签。</p> 
<table><thead><tr><th>方法名</th><th>参数（字符串）</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>getElementById()</code></td><td>id 属性值</td><td>通过 id 获取元素</td><td>元素节点</td></tr><tr><td><code>getElementsByClassName()</code></td><td>class 属性值</td><td>通过 class 获取元素</td><td>数组（包含匹配的元素节点）</td></tr><tr><td><code>getElementsByTagName()</code></td><td>标签名</td><td>通过标签名获取元素</td><td>数组（包含匹配的元素节点）</td></tr><tr><td><code>querySelector()</code></td><td>CSS 选择器</td><td>通过 CSS 选择器获取到第一个匹配的元素</td><td>元素节点</td></tr><tr><td><code>querySelectorAll()</code></td><td>CSS 选择器</td><td>通过 CSS 选择器获取到所有匹配的元素</td><td>数组（包含匹配的元素节点）</td></tr></tbody></table> 
<pre>&lt;h1 class="hi" id="hello"&gt;你好&lt;/h1&gt;
&lt;h1 class="hi"&gt;你好&lt;/h1&gt;
&lt;h1 class="hi"&gt;你好&lt;/h1&gt;
&lt;script&gt;
    // 1. 通过 id 获取元素
    var node = document.getElementById("hello");
    // 2. 通过 class 获取元素
    var nodes = document.getElementsByClassName("hi");
    // 3. 通过标签名获取元素
    var nodes = document.getElementsByTagName("h1");
    // console.log(nodes[1]);
    // 4. 通过 CSS 选择器获取第一个匹配的元素
    var node = document.querySelector('.hi');
    // console.log(node);
    // 5. 通过 CSS 选择器获取匹配的所有元素
    var nodes = document.querySelectorAll('.hi');
&lt;/script&gt;
</pre> 
<h4>二、创建元素节点</h4> 
<table><thead><tr><th>方法名</th><th>参数（字符串）</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>createElement()</code></td><td>标签名</td><td>创建元素节点</td><td>元素节点</td></tr></tbody></table> 
<pre>var node = document.createElement("h2");
console.log(node);
</pre> 
<p>注意：创建好的节点是保存在内存中的，默认情况下不会在页面中渲染出来。</p> 
<h4>三、添加元素节点</h4> 
<table><thead><tr><th>方法名</th><th>参数（元素节点）</th><th>说明</th></tr></thead><tbody><tr><td><code>父节点.appendChild()</code></td><td>要添加的子元素节点</td><td>往指定父节点的末尾添加一个子节点</td></tr><tr><td><code>父节点.insertBefore()</code></td><td>1. 新的子节点 2. 旧的子节点</td><td>在指定的旧子节点之前添加一个新的子节点</td></tr></tbody></table> 
<h4>四、删除元素节点</h4> 
<table><thead><tr><th>方法名</th><th>参数（元素节点）</th><th>说明</th></tr></thead><tbody><tr><td><code>父节点.removeChild()</code></td><td>要删除的子元素节点</td><td>删除指定的子节点</td></tr></tbody></table> 
<h4>五、元素节点操作的新方法</h4> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>父节点.append()</code></td><td>要添加的子节点</td><td>往指定父节点的末尾添加一个子节点</td></tr><tr><td><code>父节点.prepend()</code></td><td>要添加的子节点</td><td>往指定父节点的开头添加一个子节点</td></tr><tr><td><code>节点.before()</code></td><td>要添加的兄弟节点</td><td>往指定节点的前面添加一个兄弟节点</td></tr><tr><td><code>节点.after()</code></td><td>要添加的兄弟节点</td><td>往指定节点的后面添加一个兄弟节点</td></tr><tr><td><code>节点.remove()</code></td><td>无</td><td>删除指定节点</td></tr><tr><td><code>旧节点.replaceWith()</code></td><td>要替换的新节点</td><td>用新节点替换指定的旧节点</td></tr><tr><td><code>节点.cloneNode()</code></td><td>true/false</td><td>克隆节点【var newBox = box.cloneNode(true)】</td></tr></tbody></table> 
<h4>六、获取关系节点</h4> 
<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><code>子节点.parentElement</code></td><td>获取父节点</td></tr><tr><td><code>父节点.firstElementChild</code></td><td>获取第一个子节点</td></tr><tr><td><code>父节点.lastElementChild</code></td><td>获取最后一个子节点</td></tr><tr><td><code>父节点.children</code></td><td>获取所有的子节点</td></tr><tr><td><code>兄弟节点.previousElementSibling</code></td><td>获取前一个兄弟节点</td></tr><tr><td><code>兄弟节点.nextElementSibling</code></td><td>获取后一个兄弟节点</td></tr></tbody></table> 
<h2>04 -《节点的其他操作》</h2> 
<h4>一、操作元素内容</h4> 
<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><code>元素节点.innerText</code></td><td>获取、新增、修改（删除）指定元素的文本内容</td></tr><tr><td><code>元素节点.innerHTML</code></td><td>获取、新增、修改（删除）指定元素的文本内容</td></tr></tbody></table> 
<p>说明：<code>innerText</code> 和 <code>innerHTML</code> 区别在于，<code>innerHTML</code> 可以解析字符串中的 HTML 标签。</p> 
<h4>二、操作元素（标签）属性</h4> 
<p>元素的属性，指的就是标签身上，除了标签名以外的其他内容，都可以看作是标签的属性。</p> 
<p>通常，标签上的属性以 <code>属性名="属性值"</code> 格式设置的。</p> 
<table><thead><tr><th>方法名</th><th>参数（字符串）</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>元素节点.getAttribute()</code></td><td>属性名</td><td>获取指定属性名的值</td><td>属性值（字符串）</td></tr><tr><td><code>元素节点.setAttribute()</code></td><td>1. 属性名 2. 属性值</td><td>新增/修改指定的属性</td><td></td></tr><tr><td><code>元素节点.removeAttribute()</code></td><td>属性名</td><td>删除指定属性</td><td></td></tr><tr><td><code>元素节点.hasAttribute()</code></td><td>属性名</td><td>判断是否存在指定属性</td><td>布尔值</td></tr></tbody></table> 
<p>点运算符操作属性</p> 
<p>注意：在使用 <code>.</code> 去操作元素的 class 时，需要使用 <code>className</code> 属性。</p> 
<pre>&lt;a href="#" id="link"&gt;连接&lt;/a&gt;
&lt;img src="./logo.png" id="image" alt=""&gt;
&lt;input type="text" id="input"&gt;
&lt;script&gt;
    var link = document.getElementById('link');
    var image = document.getElementById('image');
    var input = document.getElementById('input');
    // console.log(image.getAttribute("src"));
    link.href = "http://www.baidu.com"
    input.type = "button"
    link.className = "active";
&lt;/script&gt;
</pre> 
<h4>三、操作元素样式</h4> 
<p>DOM 中，如果使用 JS 操作样式，一定是在操作内联样式。基础语法如下：</p> 
<pre>元素节点.style.CSS样式名 = "样式值";
</pre> 
<p>案例代码：</p> 
<pre>box.style.width = "100px";
box.style.height = "100px";
box.style.backgroundColor = "pink";
</pre> 
<h4>四、获取元素实际尺寸</h4> 
<p>DOM 中给元素身上提供了两组属性，用来获取元素的实际尺寸：</p> 
<p>1、获取宽（高）度 + 内边距</p> 
<pre>console.log(元素节点.clientWidth, 元素节点.clientHeight);
</pre> 
<p>2、获取宽（高）度 + 内边距 + 边框宽度</p> 
<pre>console.log(元素节点.offsetWidth, 元素节点.offsetHeight);
</pre> 
<h2>05 -《事件基础》</h2> 
<p>DOM 中的事件，实际上指的是给元素节点身上设置事件侦听器。</p> 
<p>例如，我们获取到页面中的一个按钮，然后给按钮身上添加一个单击事件的侦听器 <code>function</code>。后续，一旦当用户单击了这个按钮后，就会执行我们的侦听器 <code>function</code> 的代码。</p> 
<p>参考代码：</p> 
<pre>buttonNode.onclick = function () {
}
</pre> 
<p>上述代码中的 <code>function</code> 不需要我们手动调用，而是当浏览器检测到用户对按钮进行了单击操作，就会自动执行该函数。</p> 
<h4>一、事件三要素</h4> 
<ul><li> <p>事件源：触发事件的元素</p> </li><li> <p>事件类型：例如</p> 
  <ul><li> <p>鼠标单击</p> </li><li> <p>鼠标双击</p> </li><li> <p>键盘按下</p> </li><li> <p>…</p> </li></ul></li><li> <p>事件处理函数：当事件发生时，需要执行的一些额外的操作</p> </li></ul> 
<h4>二、添加事件</h4> 
<p>DOM 中提供了三种方式给元素身上添加事件：</p> 
<ol><li> <p>HTML 标签的事件属性</p> </li><li> <p>DOM0 级标准事件</p> </li><li> <p>DOM2 级事件</p> </li></ol> 
<p>1、HTML 标签的事件属性</p> 
<pre>&lt;!-- 1. 给按钮添加一个单击事件 --&gt;
&lt;button οnclick="buttonClick()"&gt;按钮&lt;/button&gt;
&lt;script&gt;
    function buttonClick() {
        console.log("按钮被点击了");
    }
&lt;/script&gt;
</pre> 
<p>缺点：</p> 
<ol><li> <p>将 HTML 代码和 JS 代码混在一起编写了，不利于项目的后期维护；</p> </li><li> <p>事件的处理函数必须是一个全局的函数；</p> </li></ol> 
<p>2、DOM0 级标准事件</p> 
<pre>&lt;!-- 2. DOM0 级标准事件: 给按钮添加一个单击事件 --&gt;
&lt;button&gt;按钮&lt;/button&gt;
&lt;script&gt;
    var btn = document.querySelector('button');
    btn.onclick = function () {
        console.log("按钮被点击了");
    }
&lt;/script&gt;
</pre> 
<p>优点：</p> 
<ol><li> <p>将 HTML 代码和 JS 代码分离，有利于项目的后期维护；</p> </li><li> <p>兼容 IE 低版本的浏览器；</p> </li></ol> 
<p>缺点：</p> 
<ul><li> <p>不能在同一个元素身上添加多个同类型事件，例如不能在同一个按钮身上添加多个单击事件；</p> </li></ul> 
<p>3、DOM2 事件</p> 
<pre>&lt;button&gt;按钮&lt;/button&gt;
&lt;script&gt;
    var btn = document.querySelector('button');
    btn.addEventListener('click', function () {
        console.log("1. 按钮被点击了");
    });
    btn.addEventListener('click', function () {
        console.log("2. 按钮被点击了");
    });
&lt;/script&gt;
</pre> 
<p>优点：</p> 
<ol><li> <p>将 HTML 代码和 JS 代码分离，有利于项目的后期维护；</p> </li><li> <p>可以在同一个元素身上添加多个同类型事件；</p> </li></ol> 
<p>缺点：</p> 
<ul><li> <p>不支持 IE8 及以下版本的浏览器。</p> </li></ul> 
<h2>06 -《事件类型》</h2> 
<h4>一、鼠标事件</h4> 
<table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>click</td><td>鼠标单击时</td></tr><tr><td>dblclick</td><td>鼠标双击时</td></tr><tr><td>mousedown</td><td>鼠标按下时</td></tr><tr><td>mouseup</td><td>鼠标松开时</td></tr><tr><td>mouseover</td><td>鼠标指针进入元素时</td></tr><tr><td>mouseout</td><td>鼠标指针离开元素时</td></tr><tr><td>mouseenter</td><td>鼠标指针进入元素时*</td></tr><tr><td>mouseleave</td><td>鼠标指针离开元素时*</td></tr><tr><td>mousemove</td><td>鼠标移动时</td></tr></tbody></table> 
<p><code>mouseover</code> 和 <code>mouseout</code> 用来触发鼠标的移入和移出事件，当我们将事件添加到父节点身上时，除了父节点以外，子节点也会触发该事件。</p> 
<p><code>mouseenter</code> 和 <code>mouseleave</code> 用来触发鼠标的移入和移出事件，当我们将事件添加到父节点身上时，就只有父节点能触发该事件。</p> 
<h4>二、键盘事件</h4> 
<table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>keydown</td><td>按键按下时</td></tr><tr><td>keyup</td><td>按键松开时</td></tr><tr><td>keypress</td><td>按住按键时</td></tr></tbody></table> 
<pre>  document.onkeydown = function (e) {
        // 回车提交表单
        // 兼容FF和IE和Opera
        var theEvent = window.event || e;
        var code = theEvent.keyCode || theEvent.which || theEvent.charCode;
        if (code == 13) {
        //   queryInfo();
            console.log("按了回车键");
        }
      };
</pre> 
<p></p> 
<h4>三、表单事件</h4> 
<table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>focus</td><td>输入框获得焦点（点击了输入框，可以开始输入内容了）</td></tr><tr><td>blur</td><td>输入框失去焦点（失焦）</td></tr><tr><td>change</td><td>改变表单元素的内容或状态</td></tr><tr><td>input</td><td>输入框内容发生改变</td></tr></tbody></table> 
<p>说明：</p> 
<ol><li> <p>input 事件在输入框身上，是只要输入框内容发生改变，就会执行 input 事件；</p> </li><li> <p>change 事件在输入框身上，需要输入框内容发生改变，同时输入框要是去焦点，才会执行 change 事件；</p> <h2>事件流</h2> <p>事件流，指的是事件在页面的嵌套节点之间进行传播。</p> <h4>一、事件流的分类</h4> <p>我们把事件流分为三类：</p> 
  <ul><li> <p>冒泡型事件流</p> </li><li> <p>捕获型事件流</p> </li><li> <p>DOM 事件流：同时包含冒泡和捕获</p> </li></ul><p>DOM0 和 DOM2 添加的事件，默认都是冒泡型事件。其中 DOM2 级事件，可以通过 <code>addEventListener</code> 的第三个参数，设置 true，来将事件流切换为捕获型事件。</p> <p>案例代码：</p> <pre>parent.addEventListener('click', function () {
    console.log('点击了最外层的红色');
}, true)
child.addEventListener('click', function () {
    console.log('点击了中间的蓝色');
}, true)
grandson.addEventListener('click', function () {
    console.log('点击了最里层的黑色');
}, true)
</pre> <p></p> </li></ol> 
<h2>07 -《事件对象》</h2> 
<p>所有的事件处理函数，都会自动接收到一个对象，通常用形参 <code>event</code> 或 <code>e</code> 来表示。</p> 
<p>基础语法：</p> 
<pre>元素节点.addEventListener("事件类型", function(e) {
})
</pre> 
<h4>一、事件对象的属性</h4> 
<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>获取用户操作的节点（即触发事件的节点）</td></tr><tr><td>pageX/pageY</td><td>获取鼠标相当于整个页面的坐标(包括被卷去的body部分的长度)</td></tr><tr><td>clientX/clientY</td><td>获取鼠标相当于视口的坐标(当前body可视区域的坐标)</td></tr><tr><td>offsetX/offsetY</td><td>获取鼠标相当于事件源的坐标</td></tr><tr><td>screenX/screenY</td><td>获取鼠标相当于屏幕的坐标</td></tr><tr><td>keyCode</td><td>获取键盘事件中当前按键的按键码</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>child.addEventListener('click', function (event) {
    console.log(event.target);
})
</pre> 
<pre>parent.addEventListener('click', function (event) {
    // 1. 获取鼠标相对于页面的坐标
    console.log('相对于页面', event.pageX, event.pageY);
    // 2. 获取鼠标相对于视口的坐标
    console.log('相对于视口', event.clientX, event.clientY);
    // 3. 获取鼠标相对于屏幕的坐标
    console.log(event.screenX, event.screenY);
    // 4. 获取鼠标相当于触发事件的元素(event.target)的坐标
    console.log(event.offsetX, event.offsetY);
})
</pre> 
<pre>&lt;input type="text" id="myInput"&gt;
&lt;script&gt;
    myInput.addEventListener('keyup', function (event) {
        if (event.keyCode === 13) {
            console.log('用户按下了回车键');
        }
    })
&lt;/script&gt; 
</pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/53/85/Fdxa84vz_o.jpg"></p> 
<h4>二、事件对象的方法</h4> 
<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>stopPropagation()</td><td>阻止事件流的传播</td></tr><tr><td>preventDefault()</td><td>阻止元素的默认行为（标签自带的一些功能，例如 a 标签的跳转，button 按钮的表单提交），锚点</td></tr></tbody></table> 
<pre>parent.addEventListener('click', function () {
    console.log('点击了最外层的红色');
})
child.addEventListener('click', function () {
    console.log('点击了中间的蓝色');
})
grandson.addEventListener('click', function (event) {
    console.log('点击了最里层的黑色');
    event.stopPropagation();
})
</pre> 
<pre>&lt;a id="link" href="http://www.baidu.com"&gt;连接&lt;/a&gt;
&lt;form action=""&gt;
    &lt;button id="btn"&gt;按钮&lt;/button&gt;
&lt;/form&gt;
&lt;script&gt;
    btn.addEventListener('click', function (event) {
        event.preventDefault();
    })
    link.addEventListener('click', function (event) {
        console.log('点击了a标签');
        event.preventDefault();
    })
&lt;/script&gt;
</pre> 
<h2>08 -《事件委托》</h2> 
<p>事件委托，指的是将子节点的事件，添加到（离子节点最近的静态的祖先节点）的身上。底层利用了事件冒泡的原理。</p> 
<p>基础语法：</p> 
<pre>父节点.onclick = function(event) {
    if(通过 event.target 的属性判断是否是指定子节点) {
        真正点击子节点要执行的操作
    }
}
</pre> 
<p>案例代码：</p> 
<pre>&lt;ul id="buttons"&gt;
    &lt;li&gt;&lt;button&gt;按钮1&lt;/button&gt;&lt;/li&gt;
    &lt;li&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;/li&gt;
    &lt;li&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    var buttons = document.getElementById('buttons');
    buttons.onclick = function (event) {
        if (event.target.nodeName === 'BUTTON') {
            console.log('点击成功');
        }
    }
&lt;/script&gt;
</pre> 
<h4>应用场景</h4> 
<ol><li> <p>当我们想要<strong>给动态生成的元素身上添加事件</strong>时，就可以使用事件委托，将事件添加到离它最近的静态父节点身上；</p> </li><li> <p>当我们想要<strong>给多个子元素添加同样的事件</strong>时，就可以使用事件委托，将事件添加到离它最近的静态父节点身上；</p> </li></ol> 
<h2>JS 常用知识汇总</h2> 
<h4>一、保存数据</h4> 
<p>实际开发中，所有需要显示到页面中的去的数据，数据格式基本上都是数组包对象。</p> 
<p>参考学生数据：</p> 
<pre>var studentsData = [
    { id: 1, name: '张三', age: 20 },
    { id: 2, name: '李四', age: 18 },
    { id: 3, name: '王五', age: 22 }
]
</pre> 
<h4>二、操作数据</h4> 
<p>在开发中，对数据的操作，基本上就是新增、修改、删除和渲染这四个操作。</p> 
<p>1、数据渲染</p> 
<p>数据渲染，指的就是根据 JS 中的数据，创建相应的 HTML 标签，然后将数据和标签一起添加到 HTML 页面中。</p> 
<p>常用的数据渲染的方式是 <code>map()</code> 搭配 <code>join()</code>，具体步骤如下：</p> 
<ol><li> <p>用 <code>map()</code> 循环遍历数组，通过 <code>item</code> 去接收到数组中的每一条数据；</p> </li><li> <p>在 <code>map()</code> 中通过 <code>return</code> 将 <code>item</code> 数据和 HTML 标签组合在一起，最终得到一个新数组；</p> </li><li> <p>通过 <code>join()</code> 方法将新数组中的每一条数据拼接成一个大字符串。</p> </li></ol> 
<p>参考将学生数据渲染成 table（完整写法）：</p> 
<pre>// 获取到 tbody 标签
var studentsTbody = document.getElementById("studentsTbody");
render();
function render() {
    var studentsTrArray = studentsData.map(function(item, index) {
        return (
        	`&lt;tr&gt;
        		&lt;td&gt;${item.name}&lt;/td&gt;
        		&lt;td&gt;${item.age}&lt;/td&gt;
        	&lt;/tr&gt;`
        )
    });
    var studentsHTML = studentsTrArray.join("");
    studentsTbody.innerHTML = studentsHTML;
}
</pre> 
<p>箭头函数（不简写）语法：</p> 
<pre>// 获取到 tbody 标签
var studentsTbody = document.getElementById("studentsTbody");
render();
function render() {
    var studentsTrArray = studentsData.map((item, index) =&gt; {
        return (
        	`&lt;tr&gt;
        		&lt;td&gt;${item.name}&lt;/td&gt;
        		&lt;td&gt;${item.age}&lt;/td&gt;
        	&lt;/tr&gt;`
        )
    });
    var studentsHTML = studentsTrArray.join("");
    studentsTbody.innerHTML = studentsHTML;
}
</pre> 
<p>箭头函数（简写）语法：</p> 
<pre>// 获取到 tbody 标签
var studentsTbody = document.getElementById("studentsTbody");
render();
function render() {
    var studentsTrArray = studentsData.map(item =&gt; (
        	`&lt;tr&gt;
        		&lt;td&gt;${item.name}&lt;/td&gt;
        		&lt;td&gt;${item.age}&lt;/td&gt;
        	&lt;/tr&gt;`
        ));
    var studentsHTML = studentsTrArray.join("");
    studentsTbody.innerHTML = studentsHTML;
}
</pre> 
<p>2、新增数据</p> 
<p>新增数据，通常就是往数组中新增一个对象，需要注意的是，<strong>新对象的键必须和数组中的旧对象的键完全保持一致</strong>。</p> 
<p>常用的新增数据的方法就是 <code>push()</code>，具体步骤：</p> 
<ol><li> <p>调用数组的 <code>push()</code> 方法， 然后将新对象传递到小括号中；</p> </li><li> <p>数据修改成功后，需要再次调用 <code>render()</code> 方法用最新的数据来重新渲染页面；</p> </li></ol> 
<p>参考学生数据的新增：</p> 
<pre>var newId = 4;
studentsData.push({
    id: newId++,
    name: '新学生的姓名',
    age: '新学生的年龄'
});
render();
</pre> 
<p>3、删除数据</p> 
<p>删除数据，是通过数据的 <code>id</code>，找到对应的数据，然后将数据从数组中删除。</p> 
<p>常用的删除数组中的数据的方法是 <code>filter()</code>，具体步骤：</p> 
<ol><li> <p>用 <code>filter()</code> 循环遍历数组，通过 <code>item</code> 去接收到数组中的每一条数据；</p> </li><li> <p>在 <code>filter()</code> 中通过 <code>return</code> 来设置筛选条件，最后所有满足条件的 <code>item</code> 会组成一个新数组；</p> </li><li> <p>用 <code>filter()</code> 得到的新数组将原本的旧数组覆盖。</p> </li></ol> 
<p>参考学生数据的删除（完整写法）：(应该还要用到event.target.dataset.id)</p> 
<pre>var studentsArray = studentsData.filter(function(item, index) {
    var id = 要删除的学生的 id;
    return item.id != id;
});
studentsData = studentsArray;
</pre> 
<p>箭头函数（不简写）语法：</p> 
<pre>var studentsArray = studentsData.filter((item, index) =&gt; {
    return item.id != 要删除的学生的 id;
});
studentsData = studentsArray;
</pre> 
<p>箭头函数（简写）语法：</p> 
<pre>var studentsArray = studentsData.filter(item =&gt; item.id != 要删除的学生的 id);
studentsData = studentsArray;
</pre> 
<p>4、修改数据</p> 
<p>修改数据，实际上即使通过 id 找到要修改的数据对象，然后对该对象的属性进行修改。</p> 
<p>修改数据常用的方法是 <code>find()</code>，具体步骤：</p> 
<ol><li> <p>通过 <code>find()</code> 循环遍历数组，通过 <code>item</code> 接收到数组中的每一条数据；</p> </li><li> <p>在 <code>find()</code> 中通过 <code>return</code> 设置查找条件，最终得到的是第一个满足查找条件的 <code>item</code>；</p> </li><li> <p>找到对应的对象后，直接修改对象的属性即可。</p> </li></ol> 
<p>参考学生数据的修改：</p> 
<pre>var studentItem = studentsData.find(function(item, index) {
    return item.id === 要修改的学生的 id;
})
studentItem.name = "马冬梅";
</pre> 
<p>箭头函数（不简写）写法：</p> 
<pre>var studentItem = studentsData.find((item, index) =&gt; {
    return item.id === 要修改的学生的 id;
})
studentItem.name = "马冬梅";
</pre> 
<p>箭头函数（简写）写法：</p> 
<pre>var studentItem = studentsData.find(item =&gt; item.id === 要修改的学生的 id);
studentItem.name = "马冬梅";
</pre> 
<p>购物车案例：</p> 
<pre>// 给 tbody 添加一个点击事件
        list.addEventListener("click", function (event) {
            // 如果用户点击的是删除按钮
            console.log(event.target);

            if (event.target.className === 'deleteBtn') {
                // 通过当前点击的删除按钮，找到对应的数据，删除数组中该条数据
                goodsData = goodsData.filter(item =&gt; item.id != event.target.dataset.id);
                render();
            }
            // 如果用户点击的是数量增加的按钮
            if (event.target.className === 'plusBtn') {
                var goodItem = goodsData.find(item =&gt; item.id == event.target.dataset.id);
                goodItem.count++;
                render();
            }
            // 如果用户点击的是数量减少的按钮
            if (event.target.className === 'minusBtn') {
                var goodItem = goodsData.find(item =&gt; item.id == event.target.dataset.id);
                goodItem.count--;
                if (goodItem.count &lt;= 0) {
                    goodsData = goodsData.filter(item =&gt; item.id != event.target.dataset.id);
                }
                render();
            }
        })

  function render() {
            list.innerHTML = goodsData.map(item =&gt; (
                `
            &lt;tr&gt;
                &lt;td&gt;${item.id}&lt;/td&gt;
                &lt;td&gt;${item.name}&lt;/td&gt;
                &lt;td&gt;${item.price}&lt;/td&gt;
                &lt;td&gt;
                    &lt;button class="minusBtn" data-id="${item.id}"&gt;-&lt;/button&gt;
                    ${item.count}
                    &lt;button class="plusBtn" data-id="${item.id}"&gt;+&lt;/button&gt;
                &lt;/td&gt;
                &lt;td&gt;${item.count * item.price}&lt;/td&gt;
                &lt;td&gt;&lt;button class="deleteBtn" data-id="${item.id}"&gt;删除&lt;/button&gt;&lt;/td&gt;
            &lt;/tr&gt;
            `
            )).join("");
        }
</pre> 
<p></p> 
<p></p> 
<h4>三、事件处理</h4> 
<p>1、添加事件</p> 
<p>基础语法：</p> 
<pre>元素节点.onclick = function (event) {
    
}
</pre> 
<p>其中，<code>onclick</code> 根据实际情况替换成其他数据类型。</p> 
<p>2、事件委托</p> 
<p>事件委托，想要给子节点添加事件，但是<strong>子节点是通过 JS 动态生成</strong>的，这种情况下，就需要找到子节点外层最近的<strong>写在 HTML 中的静态父节点</strong>。将儿子的事件添加到静态父节点身上。</p> 
<p>基础语法：</p> 
<pre>父节点.onclick = function(event) {
    if(event.target.nodeName === "大写的标签名") {
        // 点击事件真正要执行的代码
    }
}
</pre> 
<p>说明：其中 <code>.nodeName</code> 可以替换成标签身上的其他属性，例如 <code>className</code>、<code>type</code> 等。</p> 
<h4>四、自定义属性</h4> 
<p>HTML 标签身上，除了自带的原生属性以外，我们还可以自己给标签添加任意属性。通常来说，为了区分与原生属性与自定义属性，我们会以 <code>data-</code> 来定义自定义属性的名称。</p> 
<p>添加自定义属性的基础语法：</p> 
<pre>&lt;标签名 data-属性名="属性值"&gt;&lt;/标签名&gt;
</pre> 
<p>在 JS 中获取自定义属性值的基础语法：</p> 
<pre>var 属性值 = 元素节点.dataset.属性名;
</pre> 
<p>通常，当我们需要对数组中的某一条数据进行<strong>修改或删除</strong>时，我们会将自定义属性添加在执行（触发）事件的元素节点身上。</p> 
<p>例如，要删除学生，我们可以将学生的 id 添加到删除按钮身上，或者要增加商品的数量，可以将商品的 id 添加到增加的按钮身上....</p> 
<h4>五、时间函数</h4> 
<p>JS 中提供了两个时间函数：</p> 
<ul><li> <p><code>setInterval()</code>：每隔指定的时间都会执行（执行多次）；</p> </li><li> <p><code>setTimeout()</code>：按照指定时间推迟执行（执行一次）；</p> </li></ul> 
<p>基础语法：</p> 
<pre>setInterval(function() {
    
}, 1000)

setInterval(() =&gt; {
    
}, 1000)
</pre> 
<p>我们也可以将第一个参数（函数）单独提取出来：</p> 
<pre>function tiemr() {
    
}

setInterval(tiemr, 1000);
</pre> 
<p>通常，当我们的功能需要在时间函数暂停后又重启，建议将时间函数的第一个参数单独提取出去。</p> 
<pre>function tiemr() {
    console.log("每隔1秒钟输出一次")
}
var intervalId = setInterval(tiemr, 1000);
</pre> 
<p>当用户点击暂停按钮，需要暂停计时器：</p> 
<pre>clearInterval(intervalId);
</pre> 
<p>当用户点击继续按钮，需要重启计时器：</p> 
<pre>intervalId = setInterval(tiemr, 1000);
</pre> 
<p>注意：重启计时器时，不需要再通过 <code>var</code> 去创建一个变量，而是直接对原来的计数器变量进行赋值。</p> 
<h4>六、函数</h4> 
<p>针对我们自己手动创建（封装）的函数，根据写法不同，可以将函数的创建分为声明式和表达式：</p> 
<pre>// 声明式
function 函数名() {
    
}
// 表达式
var 变量名 = function() {
    
}
</pre> 
<p>区别：</p> 
<ol><li> <p>声明式的函数没有创建的顺序要求，可以在创建函数的代码之前，去调用该函数；</p> </li><li> <p>表达式的函数有创建的顺序要求，必须在函数创建完成后，再调用；</p> </li></ol> 
<p>声明式参考代码：</p> 
<pre>render();

function render() {
    
}
</pre> 
<p>表达式参考代码：</p> 
<pre>var render = function() {
    
}

render();
</pre> 
<p></p> 
<h2>10 -《对象的分类》</h2> 
<p>我们将 JavaScript 中的对象分为三类：</p> 
<ul><li> <p>宿主对象</p> </li><li> <p>内置对象</p> </li><li> <p>本地对象</p> </li></ul> 
<h4>宿主对象</h4> 
<p>因为 JS 是需要在浏览器中运行，所以浏览器就是 JS 的宿主。因此宿主对象，指的就是浏览器提供的对象。BOM 和 DOM 中所有的对象都是宿主对象。</p> 
<h4>内置对象和本地对象</h4> 
<p>内置对象和本地对象，指的都是 JS 自带的对象，不是宿主提供的，也不需要我们手动去创建。区别在于：</p> 
<ul><li> <p>本地对象在使用时，需要通过 <code>new</code> 来得到对象。例如：<code>Array</code>、<code>Object</code>、<code>String</code>、<code>Date</code>、<code>RegExp</code>…；</p> </li><li> <p>内置对象在使用时，可以直接使用，不需要再通过 <code>new</code> 来得到对象。例如：<code>Math</code>、<code>JSON</code>…；</p> </li></ul> 
<h2>11 -《字符串的属性和方法》</h2> 
<h4>字符串的属性</h4> 
<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>获取字符串的长度</td></tr></tbody></table> 
<h4>字符串的方法</h4> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>includes()</code></td><td>是否包含的字符</td><td>判断字符串中是否包含指定的字符</td><td>布尔值</td></tr><tr><td><code>split()</code></td><td>分割字符串的字符</td><td>用指定的字符将字符串拆分成一个数组</td><td>数组</td></tr><tr><td><code>indexOf()</code></td><td>查找的字符</td><td>查找指定字符在字符串中第一次出现的位置下标</td><td>下标或 -1</td></tr><tr><td><code>lastIndexOf()</code></td><td>查找的字符</td><td>查找指定字符在字符串中最后一次出现的位置下标</td><td>下标或 -1</td></tr><tr><td><code>substring()</code></td><td>开始和截止的索引</td><td>截取父字符串的某一部分（不包括截止位置的字符）</td><td>截取后的字符串</td></tr></tbody></table> 
<p>参考代码：</p> 
<pre>var str = 'HEllo';
console.log(str.includes("h"));
console.log(str.split('e'));
</pre> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>trim()</code></td><td>无</td><td>去掉字符串的首尾空格</td><td>去掉首尾空格后的字符串</td></tr><tr><td><code>toLowerCase()</code></td><td>无</td><td>将字符串中的字母转换为小写字母</td><td>转换后的字符串</td></tr><tr><td><code>toUpperCase()</code></td><td>无</td><td>将字符串中的字母转换为大写字母</td><td>转换后的字符串</td></tr></tbody></table> 
<p>参考代码：</p> 
<pre>var str = 'HEllo';
console.log(str.trim());
console.log(str.toLowerCase());
console.log(str.toUpperCase());
</pre> 
<h4>字符串的遍历（了解）</h4> 
<pre>var str = 'HEllo';
for (var i = 0; i &lt; str.length; i++) {
    console.log(str[i]);
}
for (var item of str) {
    console.log(item);
}
</pre> 
<h2>12 -《数学对象 Math》</h2> 
<h4>Math 的属性</h4> 
<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><code>PI</code></td><td>获取数学圆周率值</td></tr></tbody></table> 
<h4>Math 的方法</h4> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>min()</code></td><td>多个数字</td><td>求多个数字中的最小值</td></tr><tr><td><code>max()</code></td><td>多个数字</td><td>求多个数字中的最大值</td></tr><tr><td><code>ceil()</code></td><td>数字</td><td>对当前数进行上舍入（向上取整）</td></tr><tr><td><code>floor()</code></td><td>数字</td><td>对当前数进行下舍入（向下取整）</td></tr><tr><td><code>round()</code></td><td>数字</td><td>对当前数进行四舍五入</td></tr><tr><td><code>random()</code></td><td>无</td><td>返回 0 ～ 1 之间的随机数</td></tr><tr><td><code>abs()</code></td><td>数字</td><td>返回绝对值</td></tr></tbody></table> 
<p>代码案例：</p> 
<pre>console.log(Math.max(10, 1, 2, 20, 3, 4, 5));
console.log(Math.min(10, 1, 2, 20, 3, 4, 5));
var num = 10.8;
console.log('ceil', Math.ceil(num));    // 11   11
console.log('floor', Math.floor(num));  // 10   10
console.log('round', Math.round(num));  // 10   11
function getRandom(x, y = 0) {
    var min = Math.min(x, y);
    var max = Math.max(x, y);
    return parseInt(Math.random() * (max - min + 1) + min);
}
console.log(getRandom(10));
</pre> 
<pre>// 产生一个车牌号，如川A3D4Q5（三个随机数字，两个字母，排序也是随机的）
getOneCarNumber(){
            // 产生两个字母。三个数字，随机打乱
            let array = []
            // 产生数字
            for (let index = 0; index &lt; 3; index++) {
                let num = Math.floor(Math.random()*10)
                array.push(num)
            }
            // 产生两个字母
            // ASCII
            for (let index = 0; index &lt; 2; index++) {
                const num = Math.floor(Math.random()*26 + 65)
                // 将这个数字转化位字符串（将65-90的数字转成A-Z的字母）
                const chart = String.fromCharCode(num)
                array.push(chart)
            }
            // 打乱顺序
            array.sort((a,b)=&gt;{
                // sort方法自定义排序，传递一个函数。这个函数 正数 负数 0
                return 0.5-Math.random()  //一半的几率反转顺序
                // return a - b
            })
            return "川A "+array.join("")
        }
</pre> 
<h2>13 -《日期对象 Date》</h2> 
<h4>创建 Date 对象</h4> 
<p>要创建一个日期对象，使用 <code>new</code> 操作符和 <code>Date</code> 构造函数即可。如下所示：</p> 
<pre>var nowDate = new Date();
</pre> 
<p>在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前本地日期和时间。</p> 
<p>也可以通过传参的方式来指定日期：</p> 
<pre>new Date(2006, 0, 12);
</pre> 
<p>上面的创建形式表示 2006 年 1 月 12 日这一天。</p> 
<h4>获取日期的方法</h4> 
<p>通过日期对象，调用以下方法，获取日期和时间：</p> 
<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getFullYear()</td><td>返回 Date 对象“年份”部分的实际数值。</td></tr><tr><td>getMonth()</td><td>返回 Date 对象“月份”部分的数值（0 ～ 11）。</td></tr><tr><td>getDay()</td><td>返回 Date 对象“星期”部分的数值（0 ～ 6）。</td></tr><tr><td>getDate()</td><td>返回 Date 对象“日期”部分的数值（1 ～ 31）。</td></tr><tr><td>getHours()</td><td>返回 Date 对象“小时”部分的数值（0 ～ 23）。</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象“分钟”部分的数值（0 ～ 59）。</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象“秒”部分的数值（0 ～ 59）。</td></tr><tr><td>getMilliSeconds()</td><td>返回 Date 对象“毫秒”部分的数值（0 ～ 999）。</td></tr><tr><td>getTime()</td><td>返回 Date 对象与 UTC 时间 1970 年 1 月 1 日午夜之间相差的毫秒数。</td></tr></tbody></table> 
<pre>var dt = new Date();
var year = dt.getFullYear();
var month = dt.getMonth() + 1;
var date = dt.getDate();
var day = dt.getDay();
var hours = dt.getHours();
var minutes = dt.getMinutes();
var seconds = dt.getSeconds();
</pre> 
<p>得到一个 2022-7-13 17:02:45 格式的时间</p> 
<pre>let yy = new Date().getFullYear();
let mm = new Date().getMonth()+1;
let dd = new Date().getDate();
let hh = new Date().getHours();
let mf = new Date().getMinutes()&lt;10 ? '0'+new Date().getMinutes() : new Date().getMinutes();
let ss = new Date().getSeconds()&lt;10 ? '0'+new Date().getSeconds() : new Date().getSeconds();
let time = yy+'-'+mm+'-'+dd+' '+hh+':'+mf+':'+ss;
</pre> 
<p></p> 
<p></p> 
<h2>14 -《JSON 对象》</h2> 
<p>JSON，全称是 JavaScript Object Notation。</p> 
<h4>JSON 对象和 JS 对象</h4> 
<p>JSON 对象和 JS 对象很类似，但是有区别。</p> 
<p>JSON 对象的代码参考：</p> 
<pre>{
    "name": "张三",
    "age": 20
}
</pre> 
<p>JS 对象的代码参考：</p> 
<pre>var student = {
    name: '张三',
    age: 20,
}
</pre> 
<p>我们将 JSON 对象和 JS 对象的区别做一个汇总：</p> 
<p></p> 
<table><thead><tr><th>区别</th><th>JSON 对象</th><th>JS 对象</th></tr></thead><tbody><tr><td>键</td><td>必须加双引号</td><td>可以加引号，也可以不加</td></tr><tr><td>字符串</td><td>只能使用双引号</td><td>单引号、双引号、反单引号（模板字符串）都可以</td></tr><tr><td>逗号</td><td>最后一条数据末尾不能加逗号</td><td>最后一条数据末尾可以加逗号，也可以不加</td></tr><tr><td>值的类型</td><td>值不能是 undefined 或 function</td><td>值可以是任意类型的数据</td></tr></tbody></table> 
<h4>JSON 对象的方法</h4> 
<p>JSON 对象提供了两个方法：</p> 
<ol><li> <p><code>JSON.stringify()</code>：将 JS 对象转换为 JSON 格式的字符串；也可以把number转为字符串</p> </li><li> <p><code>JSON.parse()</code>：将 JSON 格式的字符串转换为 JS 对象；</p> </li></ol> 
<p>示例代码：</p> 
<pre>var student = {
    name: '张三',
    age: 20,
    gender: "男",
}
// JS 对象转换为 JSON 格式的字符串
var jsonString = JSON.stringify(student);
</pre> 
<pre>var jsonString = '{"name":"张三","age":20,"gender":"男"}';
// JSON 格式的字符串转换为 JS 对象
var student = JSON.parse(jsonString);
</pre> 
<h2>15 -《正则表达式》</h2> 
<p>正则对象，我们通常叫做“正则表达式”。英文全称是 Regular Expression，也可以翻译为“规则表达式”。</p> 
<p>我们可以使用正则表达式来定义一个规则，可以用来对字符串进行验证、查找、替换等操作。</p> 
<h4>一、创建正则</h4> 
<p>正则表达式的创建方式有两种：字面量和构造函数。</p> 
<p>1、字面量方式</p> 
<pre> var regExp = /规则/修饰符;</pre> 
<p>2、构造函数方式</p> 
<pre> var regExp = new RegExp('规则', '修饰符');</pre> 
<p>说明：在创建正则时，“规则”是必填的，“修饰符”是可选的。</p> 
<p>案例代码：</p> 
<pre> var regExp = /a/;</pre> 
<p>上述例子中的正则，表示的意思就是：字符串中需要包含字母 <code>a</code>。</p> 
<h4>二、正则的方法</h4> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td><code>test()</code></td><td>字符串</td><td>判断字符串是否匹配正则表达式</td><td>布尔值</td></tr><tr><td><code>exec()</code></td><td>字符串</td><td>根据正则在字符串中查找对应的值</td><td>数组（包含找到的值）或 null</td></tr><tr><td><code>compile()</code></td><td>字符串</td><td>修改正则的内容</td><td>无</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>var regExp = /eo/;
var str = 'hello eo';
console.log(regExp.test(str));
console.log(regExp.exec(str));
regExp.compile('b');
console.log(regExp.test(str));
</pre> 
<h4>三、正则规则</h4> 
<p>1、方括号表达式</p> 
<table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td><code>/[abc]/</code></td><td>包含 <code>[]</code> 中的任意一个字符</td></tr><tr><td><code>/[^abc]/</code></td><td>包含除了 <code>[]</code> 中以外的其他任意字符</td></tr><tr><td><code>/[0-9]/</code></td><td>包含任意数字</td></tr><tr><td><code>/[a-z]/</code></td><td>包含小写 a - z 之间的任意字母</td></tr><tr><td><code>/[A-Z]/</code></td><td>包含大写 A - Z 之间的任意字母</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>// var regExp = /[eo]/;
// var regExp = /[^a]/;
// var regExp = /[0-9]/;
// var regExp = /[a-z]/;
// var regExp = /[A-Z]/;
var regExp = /[A-Za-z0-9]/;
console.log(regExp.test('100px'));
</pre> 
<p>2、元字符</p> 
<table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td><code>/\w/</code></td><td>包含数字、字母、下划线中的任意字符。等同于 <code>/[0-9a-zA-Z_]/</code>。</td></tr><tr><td><code>/\W/</code></td><td>包含除了数字、字母、下划线以外的其他任意字符。等同于 <code>/[^0-9a-zA-Z_]/</code>。</td></tr><tr><td><code>/\d/</code></td><td>包含任意数字。等同于<code>/[0-9]/</code>。</td></tr><tr><td><code>/\D/</code></td><td>包含除了数字以外的其他任意字符。等同于 <code>/[^0-9]/</code>。</td></tr><tr><td><code>/\s/</code></td><td>包含空白字符（空格）。</td></tr><tr><td><code>/\S/</code></td><td>包含除了空白字符以外的其他字符。</td></tr></tbody></table> 
<p>3、量词</p> 
<table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td><code>/n+/</code></td><td>包含至少一个指定字符，可以理解为 n 连续出现的次数 &gt;= 1。</td></tr><tr><td><code>/n*/</code></td><td>指定字符可有可无，可以理解为 n 连续出现的次数 &gt;= 0。</td></tr><tr><td><code>/n?/</code></td><td>指定字符出现 0 或 1 次，可以理解为 n 出现的次数 = 0 或者 = 1。</td></tr><tr><td><code>/n{x}/</code></td><td>指定字符连续出现 x 次（x 是任意数字）</td></tr><tr><td><code>/n{x,}/</code></td><td>指定字符至少连续出现 x 次（x 是任意数字），可以理解为 n 出现的次数 &gt;= x。</td></tr><tr><td><code>/n{x,y}/</code></td><td>指定字符出现最少 x 次，最多 y 次。可以理解为 n 出现的次数 &gt;= x 并且 &lt;= y。</td></tr></tbody></table> 
<p>4、开始和结束</p> 
<table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>^n</code></td><td>表示以指定字符为开头</td></tr><tr><td><code>n$</code></td><td>表示以指定字符为结尾</td></tr></tbody></table> 
<p>通常来说，只要是对字符串的内容进行验证，都会在正则中加入“开始 <code>^</code>”和“结束 <code>$</code>”。</p> 
<p>示例代码：</p> 
<pre>// 密码中包含数字、字母、下划线，以大写字母开头，6-20位。
var passwordRe = /^[A-Z]\w{5,19}$/;
console.log(passwordRe.test('A123123'));
</pre> 
<p>5、其他符号</p> 
<table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>大体上可以将 <code>.</code> 看作是通配符（实际上不能匹配一些特殊符号，例如换行符 <code>\n</code>、回车符、制表符等）。</td></tr><tr><td>竖线</td><td>表示“或”</td></tr><tr><td><code>()</code></td><td>对规则进行分组</td></tr><tr><td><code>\</code></td><td>转义符</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>var regExp = /^(a|b)$/;
console.log(regExp.test('a'))
</pre> 
<h4>四、修饰符</h4> 
<table><thead><tr><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>不区分大小写。</td></tr><tr><td>g</td><td>对所有字符串进行匹配（而非在找到第一个匹配后停止）。</td></tr><tr><td>m</td><td>多行匹配（即在到达一行文本末位时还会继续查找下一行）。</td></tr></tbody></table> 
<p>其中，<code>g</code> 和 <code>m</code> 仅作了解。</p> 
<p>示例代码：</p> 
<pre>var regExp = /^[a-z]{6,10}$/i;
console.log(regExp.test('ABCDEFG'));  // true
</pre> 
<h2>01 -《本地存储》</h2> 
<p>本地存储，简单来说就是将用户的相关数据保存在浏览器中。</p> 
<p>早期的本地存储采用的方式是 cookie，但是由于 cookie 存储大小有限，所以在 HTML5 中新增了两种本地存储的方式：</p> 
<ul><li> <p>localStorage：永久性的本地存储，只要不手动删除数据，数据会一直保存在浏览器中；</p> </li><li> <p>sessionStorage：会话级的本地存储，只在当前窗口有效，窗口关闭后数据会自动销毁。</p> </li></ul> 
<h4>本地存储的方法</h4> 
<p>localStorage 和 sessionStorage 的方法都是一样的：储存类型为字符串</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>setItem()</code></td><td>1. 数据的键 2. 数据的值</td><td>保存、修改数据</td></tr><tr><td><code>getItem()</code></td><td>需要获取的数据的键</td><td>获取数据</td></tr><tr><td><code>removeItem()</code></td><td>需要删除的数据的键</td><td>删除数据</td></tr><tr><td><code>clear()</code></td><td>无</td><td>清空数据</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>// 保存数据
localStorage.setItem('name', '张三');
localStorage.setItem('age', 20);
// // 修改数据
localStorage.setItem('name', '李四');
// 获取数据
var name = localStorage.getItem('name');
// console.log(name);
// 删除数据
localStorage.removeItem('age');
// 清空数据
localStorage.clear();
</pre> 
<h4>点运算符操作数据</h4> 
<p>由于 localStorage 和 sessionStorage 也是对象，因此我们也可以直接使用 <code>.</code> 点运算符来操作本地存储的数据。</p> 
<pre> // 保存、修改数据
 localStorage.name = "张三";
 sessionStorage.name = "张三";
 // 获取数据
 console.log(localStorage.name);
 console.log(sessionStorage.name);
</pre> 
<p></p> 
<h4>将数据存入本地储存</h4> 
<pre> var users = [
            { account: '123', password: '123' },
            { account: '000', password: '000' },
        ];
        console.log(users);
        localStorage.users = JSON.stringify(users);
        console.log(JSON.parse(localStorage.users));
</pre> 
<p></p> 
<h2>02 -《canvas 画布》</h2> 
<h4>一、准备工作</h4> 
<p>1、创建画布</p> 
<pre>&lt;canvas width="600" height="600"&gt;&lt;/canvas&gt;
</pre> 
<p>注意：</p> 
<ol><li> <p>canvas 的大小不要通过 CSS 来调整，直接在 canvas 元素身上通过属性来设置；</p> </li><li> <p>canvas 的背景颜色或边框可以在 CSS 中自行设置。</p> </li></ol> 
<p>2、创建画笔（创建上下文）</p> 
<pre>var myCanvas = document.getElementById('myCanvas');
var pen = myCanvas.getContext('2d');
</pre> 
<p>画布和画笔创建完成后，就可以开始绘画了。</p> 
<h4>二、绘制矩形</h4> 
<p>canvas 中提供了四种绘制矩形的方法：</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>fillRect()</code></td><td>横坐标、纵坐标、矩形宽度、矩形高度</td><td>绘制有背景颜色的矩形</td></tr><tr><td><code>strokeRect()</code></td><td>横坐标、纵坐标、矩形宽度、矩形高度</td><td>绘制有边框的矩形</td></tr><tr><td><code>rect()</code></td><td>横坐标、纵坐标、矩形宽度、矩形高度</td><td>绘制既没有背景颜色也没有边框的矩形</td></tr><tr><td><code>clearRect()</code></td><td>横坐标、纵坐标、矩形宽度、矩形高度</td><td>擦除矩形区域（类似橡皮擦功能）</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>// 1. 绘制实心矩形
pen.fillRect(0, 0, 100, 100);
// 2. 绘制空心矩形
pen.strokeRect(50, 50, 100, 100);
// 3. 绘制一个即没有背景颜色也没有边框的矩形
pen.rect(150, 150, 100, 100);
// 4. 清除矩形区域（类似橡皮擦）
// pen.clearRect(0, 0, 600, 600); 
</pre> 
<h4>三、填充和描边</h4> 
<p>canvas 中还提供了两个方法，来为图形进行填充和描边。填充指的就是给图形添加背景颜色，描边指的就是给图形添加边框。</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>fill()</code></td><td>无</td><td>给前面所有可以添加背景的图形的添加背景颜色</td></tr><tr><td><code>stroke()</code></td><td>无</td><td>给前面所有可以添加边框的图形的添加边框</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>pen.rect(150, 150, 100, 100);
// 填充和描边（添加背景和添加边框）
pen.fill();
pen.stroke();
</pre> 
<h4>四、绘制路径（画线条）</h4> 
<p>canvas 中绘制路径的方式，是通过确定两个点的坐标，然后通过 <code>stroke()</code> 方法将两个连接起来，实现线条的绘制。</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>moveTo()</code></td><td>横坐标、纵坐标</td><td>设置线条的起点坐标</td></tr><tr><td><code>lineTo()</code></td><td>横坐标、纵坐标</td><td>设置线条下一个点的坐标</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>// 设置线条的起点
pen.moveTo(400, 400);
// 设置线条下一个点的坐标
pen.lineTo(400, 500);
pen.lineTo(500, 500);
// 连接以上所有的点
pen.stroke();
</pre> 
<h4>五、闭合图形</h4> 
<p>当我们使用线条绘制多边形时，最后需要将图形完整的闭合（不建议手动将终点和起点设置在一起实现闭合），canvas 提供了专门的方法来实现多边形的闭合。</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>closePath()</code></td><td>无</td><td>闭合多边形</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>pen.moveTo(300, 300);
pen.lineTo(300, 400);
pen.lineTo(400, 400);
// 闭合图形
pen.closePath();
pen.stroke();
</pre> 
<h4>六、路径初始化</h4> 
<p>由于 <code>fill()</code> 和 <code>stroke()</code> 两个方法都会作用于它们前面所有的图形，这样就导致我们没办法去分别绘制实心和空心的图形。因此我们需要在每次绘制一个新的图形之前，都使用 <code>beginPath()</code> 方法对路径做一个初始化处理，相当于将前一个图形的路径与当前图形的路径做一个隔离，从而让 <code>fill()</code> 和 <code>stroke()</code> 只作用于当前图形。</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>beginPath()</code></td><td>无</td><td>对路径进行初始化处理，将前一个图形路径与当前图形路径隔离</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>// 第一个三角形
pen.moveTo(100, 100);
pen.lineTo(200, 200);
pen.lineTo(200, 100); 
pen.closePath();
// 绘制图形轮廓
pen.stroke();
// 第二个三角形
// 绘制新图形前，清空掉上一个图形中的路径（必须）。
pen.beginPath();
pen.moveTo(200, 200);
pen.lineTo(300, 300);
pen.lineTo(300, 200);
pen.closePath();
// 填充整个图形内部
pen.fill();
</pre> 
<h4>七、绘制圆形</h4> 
<p>canvas 中提供了一个 <code>arc()</code> 方法用来绘制圆形。</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>arc()</code></td><td>圆心横坐标、圆心纵坐标、半径、起始角度、结束角度、是否逆时针（默认 false）</td><td>绘制圆形</td></tr></tbody></table> 
<p>注意：第四、五个参数用来设置开始和结束的角度，需要将实际的角度经过以下计算后传入到 <code>arc</code> 方法中：</p> 
<pre>(Math.PI / 180) * 实际角度
</pre> 
<p>案例代码：</p> 
<pre>// 清空路径容器
pen.beginPath();
// 画圆
pen.arc(100, 100, 50, 0, (Math.PI / 180) * 360);
// 绘制圆的边框
pen.stroke();
</pre> 
<h4>八、设置样式</h4> 
<p>canvas 中提供了以下几种方式来设置样式：</p> 
<table><thead><tr><th>属性名</th><th>可选属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>fillStyle</code></td><td>颜色字符串</td><td>设置图形的填充（背景）颜色。</td></tr><tr><td><code>strokeStyle</code></td><td>颜色字符串</td><td>设置图形的轮廓（边框）颜色。</td></tr><tr><td><code>lineWidth</code></td><td>数字</td><td>设置线条的粗细（属性值必须是正数）。</td></tr><tr><td><code>lineJoin</code></td><td>round（圆角）、bevel（斜角）</td><td>设置线条与线条间交接处的样式。</td></tr><tr><td><code>lineCap</code></td><td>round（圆角）</td><td>设置每一条线段两端的样式。</td></tr></tbody></table> 
<p>注意：所有的样式都是作用于它们后面的图形。</p> 
<p>案例代码：</p> 
<pre>pen.beginPath();
pen.lineWidth = 20;
pen.fillStyle = 'pink';
pen.strokeStyle = 'green';
pen.lineJoin = "round";
pen.lineCap = "round";
// 绘制一个三角形
pen.moveTo(200, 200);
pen.lineTo(300, 300);
pen.lineTo(300, 200);
pen.closePath();
pen.stroke();
pen.fill();
</pre> 
<h4>九、样式初始化</h4> 
<p>由于 canvas 中的所有样式都会作用于后面的所有图形，这样也会导致我们很多图形应用了相同的样式。因此，我们也需要对样式进行处理，来实现每一个图形都使用自己的样式。</p> 
<table><thead><tr><th>方法名</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>save()</code></td><td>无</td><td>将当前样式保存到内存中</td></tr><tr><td><code>restore()</code></td><td>无</td><td>从内容取出上一个保存到样式，并作用于当前样式</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>pen.beginPath();
pen.save();
    pen.fillStyle = "tomato";
    pen.strokeStyle = "orange";
    pen.lineWidth = 20;
    pen.moveTo(400, 400);
    pen.lineTo(400, 500);
    pen.lineTo(500, 500);
    pen.closePath();
    pen.stroke();
    pen.fill();
pen.restore();
</pre> 
<h4>十、转换</h4> 
<table><thead><tr><th>转换方法</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>translate()</code></td><td>1. 左右移动的距离 2. 上下移动的距离</td><td>移动画布的 (0, 0) 点</td></tr><tr><td><code>scale()</code></td><td>1. 横向缩放比例 2. 纵向缩放比例</td><td>对画布内容进行缩放</td></tr><tr><td><code>rotate()</code></td><td>(Math.PI / 180) * 实际旋转角度</td><td>将画布相对于 (0, 0) 点进行旋转</td></tr></tbody></table> 
<p>说明：</p> 
<ol><li> <p>canvas 的转换方法都是作用于后面的图形；</p> </li><li> <p>canvas 的转换方法连续多次调用时，效果会叠加；</p> </li></ol> 
<p>案例代码：</p> 
<pre>// 转换
// translate 位移
pen.translate(100, 100);
// pen.translate(100, 100);
// pen.translate(100, 100);
// scale 缩放
// pen.scale(0.5, 0.5);
// rotate 旋转
pen.rotate(Math.PI / 180 * 45);
pen.rotate(Math.PI / 180 * 45);
pen.fillRect(0, 0, 100, 100);
</pre> 
<h4>总结</h4> 
<p>当我们在绘制图形时，既有样式，又有转换，还有路径以及图形，那么我们建议，大家的代码顺序格式参考如下：</p> 
<pre>pen.beginPath();
pen.save();
    // 转换
    // 设置样式
    // 绘制图形
    // pen.stroke();
    // pen.fill();
pen.restore();
</pre> 
<h2>03 -《拖放》</h2> 
<p>HTML5 中新增了一个拖放功能。默认情况下，只有 <code>img</code> 标签是可拖放元素，其他标签，如果需要变成可拖放元素的话，需要在标签身上添加一个属性 <code>draggable="true"</code>：</p> 
<pre>&lt;div id="box" draggable="true"&gt;&lt;/div&gt;
</pre> 
<h4>拖放事件</h4> 
<p>拖放事件分为两类：</p> 
<ol><li> <p>关于被拖拽元素的事件</p> </li><li> <p>关于投放区元素的事件</p> </li></ol> 
<p>关于被拖拽元素的事件</p> 
<table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>dragstart</td><td>拖拽开始时触发的事件</td></tr><tr><td>drag</td><td>拖拽过程中触发的事件</td></tr><tr><td>dragend</td><td>拖拽结束时触发的事件</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>var box = document.getElementById('box');
box.ondragstart = function () {
    console.log('被拖拽元素：拖拽开始');
}
box.ondrag = function () {
    console.log('被拖拽元素：拖拽进过程中');
}
box.ondragend = function() {
    console.log('被拖拽元素：拖拽结束');
}
</pre> 
<p>关于投放区元素的事件</p> 
<table><thead><tr><th>事件类型</th><th>说明</th></tr></thead><tbody><tr><td>dragenter</td><td>当被拖拽元素进入投放区域时触发的事件（鼠标指针进入投放区）</td></tr><tr><td>dragover</td><td>拖拽元素在投放区域内移动时触发的事件</td></tr><tr><td>dragleave</td><td>当被拖拽元素离开投放区域时触发的事件</td></tr><tr><td>drop</td><td>当被拖拽元素在投放区域投放时触发的事件（当拖拽元素在投放区域中，鼠标松开时触发的事件）</td></tr></tbody></table> 
<p>案例代码：</p> 
<pre>drop.ondragenter = function () {
    console.log('投放区元素：拖拽元素进入投放区');
}
drop.ondragover = function (event) {
    event.preventDefault();
    console.log('投放区元素：拖拽元素在投放区移动');
}
drop.ondragleave = function () {
    console.log('投放区元素：拖拽元素离开投放区');
}
drop.ondrop = function () {
    console.log('投放区元素：在投放区松开拖拽元素');
}
</pre> 
<p>说明：<code>dragover</code> 事件的默认行为会阻止 <code>drop</code> 事件的执行，因此，如果需要使用 <code>drop</code> 事件时，需要在 <code>dragover</code> 事件中组件事件的默认行为。</p> 
<h2>04 -《百度地图》</h2> 
<p>HTML5 中提供了 <code>Geolocation</code> 方法用来获取用户位置。在实际开发中，通常都会引入第三方的地图插件，例如：百度地图、腾讯地图、高德地图等。</p> 
<h4>一、准备工作</h4> 
<p>1、登录账号</p> 
<p>访问百度地图 API 的官网 <code>https://lbsyun.baidu.com/</code>，登录百度账号。</p> 
<p>2、创建应用</p> 
<p>从首页的【控制台】进入到【应用管理】中的【我的应用】，创建当前项目应用，最后自动生成对应的 AK 密钥：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/03/13r8wRfs_o.png"></p> 
<h4>二、基本使用</h4> 
<p>浏览器端使用百度地图的开发文档参考下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/61/a0/wwq7Qve3_o.png"></p> 
<p>我们可以先将文档中的 Hello Word 案例复制下来运行查看效果：</p> 
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no" /&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;title&gt;Hello, World&lt;/title&gt;
    &lt;style type="text/css"&gt;
        html {
            height: 100%
        }
        body {
            height: 100%;
            margin: 0px;
            padding: 0px
        }
        #container {
            height: 100%
        }
    &lt;/style&gt;
    &lt;script src="https://api.map.baidu.com/api?v=1.0&amp;type=webgl&amp;ak=gYFqshTZIiqLFdMByY2KRPQtFhKy7lSz"&gt;
        &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="container"&gt;&lt;/div&gt;
    &lt;script type="text/javascript"&gt;
        var map = new BMapGL.Map("container");  // 创建地图实例     
        var point = new BMapGL.Point(116.404, 39.915); // 创建点坐标      
        map.centerAndZoom(point, 15);  // 初始化地图，设置中心点坐标和地图级别
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre> 
<p>1、定位</p> 
<p>通过浏览器地位到用户所在城市：</p> 
<pre>var map = new BMapGL.Map("container");  // 创建地图实例 
var point = new BMapGL.Point(116.404, 39.915); // 创建点坐标
map.centerAndZoom(point, 15);  // 初始化地图，设置中心点坐标和地图级别
var geolocation = new BMapGL.Geolocation();  // 创建定位实例对象
geolocation.getCurrentPosition(function (r) {   // 获取当前位置
    if (this.getStatus() == BMAP_STATUS_SUCCESS) {
        var mk = new BMapGL.Marker(r.point);  // 创建标记点
        map.addOverlay(mk);     // 将标记点添加到地图上
        map.panTo(r.point);     // 将地图的中心位置移动到指定坐标点
    }
    else {
        alert('failed' + this.getStatus());
    }
});
</pre> 
<p>2、（正）地址解析</p> 
<p>（正）地址解析，指的是可以通过用户给定的中文地址，获取到该地址对应经纬度：</p> 
<pre>var map = new BMapGL.Map("container");  // 创建地图实例 
var point = new BMapGL.Point(116.404, 39.915); // 创建点坐标
map.centerAndZoom(point, 15);  // 初始化地图，设置中心点坐标和地图级别
//创建地址解析器实例
var myGeo = new BMapGL.Geocoder();
// 将地址解析结果显示在地图上，并调整地图视野
myGeo.getPoint('成都市高新区孵化园5号楼', function (point) {
    console.log(point);  // 获取到当前地址对应的经纬度
    if (point) {
        map.centerAndZoom(point, 16);  // 将地图的中心点设置为当前位置
        map.addOverlay(new BMapGL.Marker(point, { title: '成都市高新区孵化园5号楼' }));  // 添加标记点
    } else {
        alert('您选择的地址没有解析到结果！');
    }
}, '北京市')
</pre> 
<p>3、逆地址解析</p> 
<p>逆地址解析，根据给定的经纬度，解析出当前经纬度对应的中文地址。</p> 
<p>我们通过定位方法获取到用户当前的经纬度，然后解析出用户所在位置的中文地址：</p> 
<pre>var map = new BMapGL.Map("container");  // 创建地图实例 
var point = new BMapGL.Point(116.404, 39.915); // 创建点坐标
map.centerAndZoom(point, 15);  // 初始化地图，设置中心点坐标和地图级别
var geolocation = new BMapGL.Geolocation();  // 创建定位实例对象
geolocation.getCurrentPosition(function (r) {   // 获取当前位置
    if (this.getStatus() == BMAP_STATUS_SUCCESS) {
        var mk = new BMapGL.Marker(r.point);  // 创建标记点
        map.addOverlay(mk);     // 将标记点添加到地图上
        map.panTo(r.point);     // 将地图的中心位置移动到指定坐标点
        // 逆地址解析
        // 创建地理编码实例      
        var myGeo = new BMapGL.Geocoder();
        // 根据坐标得到地址描述    
        myGeo.getLocation(r.point, function (result) {
            if (result) {
                alert(result.address);
            }
        });
    }
    else {
        alert('failed' + this.getStatus());
    }
});
</pre> 
<h2>05 -《移动端网页开发》</h2> 
<h4>一、移动端开发</h4> 
<ol><li> <p>移动端网页开发：用户不需要下载其他软件，只要有浏览器就能访问页面；</p> </li><li> <p>原生 APP 开发：用户需要下载安装包，安装成功后才能使用；</p> </li><li> <p>小程序开发：用户需要下载微信，在微信中使用各种小程序；</p> </li></ol> 
<h4>二、视口 viewport</h4> 
<p>浏览器网页的开发，从早期的布局视口、视觉视口，然后发展到现在的理想视口。</p> 
<p>使用理想视口来开发移动端网页，需要在 <code>.html</code> 文件的 `` 标签中添加以下代码：</p> 
<pre>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
</pre> 
<h4>三、尺寸单位</h4> 
<p>移动端开发中，可以选择的尺寸单位有以下几种：</p> 
<table><thead><tr><th>单位</th><th>说明</th></tr></thead><tbody><tr><td>em</td><td>1em 等于元素自身的 font-size 大小（如果自己没有设置 font-size，是会继承父级的 font-size）</td></tr><tr><td>rem</td><td>1rem 等于 html 的 font-size 大小（默认 16px）</td></tr><tr><td>vh</td><td>1vh 等于视口高度的 1%，100vh 等于视口高度</td></tr><tr><td>vw</td><td>1vw 等于视口宽度的 1%，100vw 等于视口宽度</td></tr></tbody></table> 
<p>在开发移动端网页时，布局建议优先考虑弹性布局，尺寸单位优先考虑 <code>rem</code>，如果需要全屏时可以使用 <code>100vh</code> 和 <code>100vw</code>。</p> 
<h2>06 -《jQuery》</h2> 
<p>jQuery，实际上就是一系列节点操作的方法组成的一个 JS 文件，我们把这个 JS 文件称为“库”。</p> 
<h4>一、准备工作</h4> 
<p>1、下载</p> 
<p>由于 jQuery 是一个别人封装好的 JS 库，因此我们如果需要在项目中使用的话，需要先将其源码下载下来，然后在 <code>.html</code> 中引入后使用。</p> 
<p>jQuery 官网：<code>https://jquery.com/</code>。</p> 
<p>如果点击下载连接是直接打开的源码，可以将源码全部复制后，在本地自己新建一个 <code>.js</code> 文件将 jQuery 的源码粘贴进去。</p> 
<p>2、引入</p> 
<p>下载成功后，将 jQuery 的文件添加到项目目录中，然后在 <code>.html</code> 中通过 `` 引入后使用：</p> 
<pre>&lt;body&gt;
    &lt;!-- 页面标签代码 --&gt;
    &lt;!-- 引入 jQuery --&gt;
    &lt;script src="./js/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 自己的 JS 代码
    &lt;/script&gt;
&lt;/body&gt;
</pre> 
<h4>二、jQuery 常用方法</h4> 
<p>jQuery 的方法可以查看 jQuery API 网站：<code>https://jquery.cuishifeng.cn/</code>。</p> 
<p>1、通过选择器获取元素节点</p> 
<p>基础语法如下：</p> 
<pre>$("选择器");
</pre> 
<p>示例代码：</p> 
<pre>&lt;body&gt;
    &lt;div id="box"&gt;&lt;/div&gt;
    &lt;div class="box"&gt;&lt;/div&gt;
    &lt;input type="checkbox"&gt;
    &lt;input type="checkbox" checked&gt;
    &lt;input type="checkbox"&gt;
    &lt;script src="./js/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var boxId = $("#box");
        var boxClass = $(".box");
        var boxes = $("div");
        var checkboxes = $('[type=checkbox]:checked')
    &lt;/script&gt;
&lt;/body&gt;
</pre> 
<p>2、操作元素的属性</p> 
<p>HTML 元素身上的属性可以分为三类：</p> 
<ol><li> <p>普通原生属性：必须有属性名和属性值。例如：<code>href</code>、<code>src</code> 等；</p> </li><li> <p>特殊原生属性：只要有属性名就能使用。例如：<code>checked</code>、<code>selected</code> 等；</p> </li><li> <p>自定义属性：开发者自己在标签身上添加以 <code>data-</code> 为前缀来命名的属性。例如：<code>data-id</code>、<code>data-index</code> 等。</p> </li></ol> 
<p>在 jQuery 中，针对以上三类属性，提供了三种不同的属性操作方法：</p> 
<ol><li> <p>原生普通属性：<code>attr()</code>、<code>removeAttr()</code></p> </li><li> <p>特殊原生属性：<code>prop()</code>、<code>removeProp()</code></p> </li><li> <p>自定义属性：<code>data()</code></p> <p></p> <p>使用<code>.prop()</code>方法来调整元素的属性,把按钮设置成禁用以后,按钮会变灰并且不能点击,代码为<code>$("button").prop("disabled", true);</code></p> <p></p> </li></ol> 
<p>示例代码：</p> 
<pre>var srcValue = $('img').attr('src');  // 获取 img 的 src 属性值
$('img').attr('src', './logo.png');   // 修改或新增 img 的 src 属性值
$('img').attr({                       // 修改或新增 img 的 src 和 title 属性
    src: './logo.png',
    title: '蜗牛学院'
}); 
var checkedValue = $('[type=checkbox]').attr('checked');  // 获取复选框是否被选中
$('[type=checkbox]').attr('checked', true);               // 设置复选框被选中
$('[type=checkbox]').attr({                               // 设置复选框被选中且被禁用
    checked: true,
    disabled: true
});
var dataIdValue = $('button').data('id');   // 获取按钮的 data-id 的属性值
$('button').data('id', 1);                  // 新增或修改按钮的 data-id 的属性
$('button').data({                          // 新增或修改按钮的 data-id 和 data-name 属性
    id: 2,
    name: '张三'
});
</pre> 
<p>说明：使用 jQuery 的 <code>data()</code> 方法添加的自定义属性，在元素身上不会显示出来。</p> 
<p>3、操作元素的 class</p> 
<p>jQuery 中提供了三种方法来操作元素的 class：</p> 
<ul><li> <p>新增一个或多个 class：<code>addClass()</code></p> </li><li> <p>删除一个或多个 class：<code>removeClass()</code></p> </li><li> <p>切换一个或多个 class：<code>toggleClass()</code></p> </li></ul> 
<p>示例代码：</p> 
<pre>$('div').addClass('box container');    // 给 div 添加 box 和 container 两个 class
$('div').removeClass('box container'); // 删除 div 的 box 和 container 两个 class
$('div').removeClass();                // 删除 div 的所有 class 
$('div').toggle('box container');      // 切换 div 的 box 和 container 两个 class
</pre> 
<p>4、操作元素的内容</p> 
<p>jQuery 中提供了三种方法来操作元素的内容：</p> 
<ul><li> <p>操作元素的内容（包括 HTML 标签）：<code>html()</code></p> </li><li> <p>操作元素的文本内容（不解析 HTML 标签）：<code>text()</code></p> </li><li> <p>操作表单元素的值：<code>val()</code></p> </li></ul> 
<p>示例qing'kong 代码：</p> 
<pre>var divHTML = $('div').html();     // 获取 div 中的内容
$('div').html('&lt;p&gt;Hello&lt;/p&gt;');     // 将 div 中的内容修改为一个 p 标签
var divHTML = $('div').text();     // 获取 div 中的文本内容
$('div').text('Hello');            // 将 div 中的内容修改为一个文本 Hello
var inputValue = $('input[type=text]').val();     // 获取输入框的 value 值
$('input[type=text]').val('123');                 // 将输入框的值设置为 123
</pre> 
<p></p> 
<p>5.操作CSS样式</p> 
<pre>$("p").css({ "color": "#ff0011", "background": "blue" });
</pre> 
<h2>项目准备工作</h2> 
<h3>HTML（页面布局）</h3> 
<pre>&lt;body&gt;
    &lt;!-- 头部 --&gt;
    &lt;header&gt;
        &lt;!-- 顶部登录注册按钮 --&gt;
        &lt;div class="header-top"&gt;
            &lt;div class="center-container"&gt;
                &lt;a href="#"&gt;下载 APP&lt;/a&gt;
                &lt;div&gt;
                    &lt;a href="#"&gt;登录&lt;/a&gt;
                    &lt;a href="#"&gt;注册&lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 导航栏 --&gt;
        &lt;div class="header-nav"&gt;
            &lt;div class="center-container"&gt;
                &lt;!-- logo --&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 轮播图 --&gt;
        &lt;div class="header-banner"&gt;
            &lt;div class="center-container"&gt;

            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/header&gt;

    &lt;!-- 主体内容 --&gt;
    &lt;main&gt;
        &lt;div class="center-container"&gt;
            &lt;!-- 下拉列表 --&gt;
            &lt;div&gt;&lt;/div&gt;
            &lt;!-- 电影相关信息 --&gt;
            &lt;div&gt;
                &lt;!-- 电影列表 --&gt;
                &lt;div class="movies-list"&gt;
                    &lt;!-- 正在热映 --&gt;
                    &lt;div&gt;
                        &lt;!-- 标题 --&gt;
                        &lt;div&gt;&lt;/div&gt;
                        &lt;!-- 正在热映的电影列表 --&gt;
                        &lt;div class="moviesList" id="hotMoviesList"&gt;
                            &lt;!-- 每一个电影项 --&gt;
                            &lt;!-- &lt;div class="movie-item"&gt;
                                &lt;img src="./images/img-10.jpg" alt=""&gt;
                                &lt;div class="movie-name"&gt;
                                    &lt;span&gt;怒火重案&lt;/span&gt;
                                    &lt;span&gt;9.0&lt;/span&gt;
                                &lt;/div&gt;
                            &lt;/div&gt; --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;!-- 即将上映 --&gt;
                    &lt;div&gt;
                        &lt;div&gt;&lt;/div&gt;
                        &lt;div class="moviesList" id="comingMoviesList"&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;!-- 电影活动 --&gt;
                &lt;div&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/main&gt;
    &lt;!-- 底部 --&gt;
    &lt;footer&gt;
        &lt;div class="center-container"&gt;
            1212124124124
        &lt;/div&gt;
    &lt;/footer&gt;

    &lt;script src="./utils/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
    &lt;script src="./utils/utils.js"&gt;&lt;/script&gt;
    &lt;script src="./js/getData.js"&gt;&lt;/script&gt;
    &lt;script src="./js/home.js"&gt;&lt;/script&gt;
&lt;/body&gt;
</pre> 
<p></p> 
<h3>CSS</h3> 
<pre>* {
    padding: 0;
    margin: 0;
}

.header-top {
    height: 40px;
    background-color: #f0f0f0;
}

.center-container {
    width: 1200px;
    margin: 0 auto;
    /* outline: 1px solid red; */
}

.header-top .center-container {
    display: flex;
    justify-content: space-between;
    line-height: 40px;
    /* align-items: center; */
}

.header-banner {
    height: 360px;
    background-image: url('../images/banner02.png');
    background-position: center;
}

.movies-list {
    width: 730px;
}

.moviesList {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
}

.movie-item {
    width: 160px;
    border: 1px solid #ddd;
    margin: 20px 0;
}

.movie-item &gt; img {
    width: 160px;
    height: 220px;
}

.movie-item &gt; .movie-name {
    display: flex;
    justify-content: space-between;
    line-height: 40px;
    padding: 0 10px;
}


footer {
    height: 290px;
    background-color: #262426;
}
</pre> 
<h3>JS获取数据库数据</h3> 
<pre>// 数据文件的路径，应该相对于 HTML 文件的位置去进行查找

// 获取所有电影数据
// $.get('./data/movies.json', function (data) {
//     setStorage('movies', data.movies);
// });

// 获取即将上映的数据
// $.get('./data/upcoming.json', function (data) {
//     setStorage('comingMovies', data.slice(0, 8))
// });

// 获取正在热映的数据
$.get('./data/nowplaying-电影.json', function (data) {
    console.log(data); // [] 35
    setStorage('hotMovies', data.slice(0, 8))
})
</pre> 
<h3>JS数据渲染</h3> 
<pre>// 获取正在热映的电影数据
var hotMovies = getStorage('hotMovies');
// 获取即将上映的电影数据
var comingMovies = getStorage('comingMovies');


var hotMoviesHTML = moviesRender(hotMovies);
$('#hotMoviesList').html(hotMoviesHTML);

var comingMoviesHTML = moviesRender(comingMovies);
$('#comingMoviesList').html(comingMoviesHTML);


function moviesRender(movies) {
    var moviesHTML = movies.map(item =&gt; (
        `&lt;div class="movie-item"&gt;
            &lt;img src="./images/img-10.jpg" alt=""&gt;
            &lt;div class="movie-name"&gt;
                &lt;span&gt;${item.title}&lt;/span&gt;
                &lt;span&gt;${item.score || ''}&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;`
    )).join('');
    return moviesHTML;
}

</pre> 
<h3>JS登录和注册</h3> 
<h4>登录</h4> 
<pre>&lt;body&gt;
    &lt;h2&gt;用户登录&lt;/h2&gt;
    &lt;div&gt;
        &lt;input type="text" id="account"&gt;
        &lt;input type="text" id="password"&gt;
        &lt;button id="loginBtn"&gt;登录&lt;/button&gt;
    &lt;/div&gt;

    &lt;script src="../utils/utils.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var accountNode = document.getElementById('account');
        var passwordNode = document.getElementById('password');
        var loginBtn = document.getElementById('loginBtn');

        loginBtn.onclick = function () {
            var account = accountNode.value;
            var password = passwordNode.value;
            // 获取本地存储中已经注册好的用户数据
            var users = getStorage('users');
            // var users = JSON.parse(localStorage.users || '[]');

            var isLogin = users.some(item =&gt; item.account == account &amp;&amp; item.password == password);
            if (isLogin) {
                alert("登录成功");
            } else {
                alert("登录失败");
            }

        }
    &lt;/script&gt;
&lt;/body&gt;
</pre> 
<h4>html密码框不显示,密码框中密码的显示与隐藏切换(JS)</h4> 
<p>目标：</p> 
<p>点击小眼睛后，</p> 
<p>1、密码框变成<a href="https://so.csdn.net/so/search?q=%E6%96%87%E6%9C%AC%E6%A1%86&amp;spm=1001.2101.3001.7020" title="文本框">文本框</a>；</p> 
<p>2、小眼睛图片由闭眼变成睁眼；</p> 
<p>3、再次点击后，又变成闭眼+密码框</p> 
<p>要想实现3，方法1：</p> 
<p>则需要一个变量，来辅助判断当前input的属性，如果flag为0，则在点击后，将input的type属性改为text框，同时，再将flag值重新赋为1.此时，再次点击，又会进行判断，而这次的flag=1，所以，就直接将input的type属性改为了password</p> 
<p>要想实现3，方法2：</p> 
<p>直接对input的type属性进行判断，若为text，则改为password，若为password，则改为text。</p> 
<h4>注册</h4> 
<pre>&lt;body&gt;
    &lt;h2&gt;用户注册&lt;/h2&gt;
    &lt;div&gt;
        &lt;input type="text" id="account"&gt;
        &lt;input type="text" id="password"&gt;
        &lt;button id="registerBtn"&gt;注册&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;script src="../utils/utils.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var accountNode = document.getElementById('account');
        var passwordNode = document.getElementById('password');
        var registerBtn = document.getElementById('registerBtn');

        var users = getStorage('users');

        registerBtn.onclick = function () {
            var account = accountNode.value;
            var password = passwordNode.value;
            users.push({
                account, password
            });
            // localStorage.users = JSON.stringify(users);
            setStorage('users', users);
        }
    &lt;/script&gt;
&lt;/body&gt;
</pre> 
<h2>01 -《let 和 const》</h2> 
<p>ES6 中新增了两种创建变量的方式：let 和 const。</p> 
<h4>一、基础语法</h4> 
<p>let、const 创建变量的基础语法和 var 一致：</p> 
<pre>var name = '张三';
let age = "20";
const gender = "男";
</pre> 
<h4>二、区别</h4> 
<p>虽然 var、let、const 都可以用来创建变量，但是三者也有不一样的地方。</p> 
<p>1、作用域</p> 
<table><thead><tr><th>关键字</th><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td>var</td><td>函数作用域</td><td>通过函数来划分作用区域，函数内的是局部作用域，函数外的是全局作用域。</td></tr><tr><td>let、const</td><td>块级作用域</td><td>通过大括号来划分作用区域，大括号内的是局部作用域，大括号外的是全局作用域。</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>var a = 10;        // 全局变量 a
let b = 10;        // 全局变量 b
const c = 10;      // 全局变量 c
if (true) {
    var d = 20;    // 全局变量 d
    let e = 20;    // 局部变量 e
    const f = 20;  // 局部变量 f
}
function foo() {
    var g = 20;    // 局部变量 g
    var h = 20;    // 局部变量 h
    var i = 20;    // 局部变量 i
}
</pre> 
<p>2、重复声明</p> 
<table><thead><tr><th>关键字</th><th>重复声明</th><th>说明</th></tr></thead><tbody><tr><td>var</td><td>允许</td><td>可以在同一作用域中创建多个同名的变量，但是后面的会覆盖前面的。</td></tr><tr><td>let、const</td><td>不允许</td><td>不可以在同一作用域中创建多个同名的变量</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>var a;            // 可以不给初始值
let b;             // 可以不给初始值
const c = 20;     // 必须给初始值
</pre> 
<p>3、初始赋值</p> 
<table><thead><tr><th>关键字</th><th>初始赋值</th><th>说明</th></tr></thead><tbody><tr><td>var、let</td><td>可以不赋值</td><td>在创建变量时可以不给变量设置初始值</td></tr><tr><td>const</td><td>必须赋值</td><td>在创建变量时必须给变量设置初始值</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>var a;            // 可以不给初始值
let b;             // 可以不给初始值
const c = 20;     // 必须给初始值
</pre> 
<p>4、修改赋值</p> 
<table><thead><tr><th>关键字</th><th>修改赋值</th><th>说明</th></tr></thead><tbody><tr><td>var、let</td><td>可以修改变量的值</td><td>变量创建成功后，后续可以重新修改变量的值</td></tr><tr><td>const</td><td>不可以修改变量的值</td><td>变量创建成功后，后续不可以修改变量的值(只修改值，不修改地址，const检测不到，不会报错，比如数组.push（)。）</td></tr></tbody></table> 
<p>附：由于 const 创建的变量，其实是不可变的量，因此 const 创建的变量也叫做“常量”。</p> 
<p>示例代码：</p> 
<pre>var a = 1;
a = 2;
let b = 1;
b = 2;
cnst c = 1;
c = 2;       // 报错
</pre> 
<p>5、变量提升</p> 
<table><thead><tr><th>关键字</th><th>变量提升</th><th>说明</th></tr></thead><tbody><tr><td>var</td><td>存在</td><td>在代码执行前会将变量的 var 声明提升到当前作用域顶部。</td></tr><tr><td>let、const</td><td>不存在</td><td>不存在变量提升的特性</td></tr></tbody></table> 
<p>示例代码：</p> 
<pre>console.log(a);   // undefined
var a = 1; 
console.log(b);   // 报错
let b = 2;
console.log(c);   // 报错
const c = 3;
</pre> 
<p>6、总结</p> 
<p>我们将 var、let、const 三者之间的区别汇总到下表中：</p> 
<table><thead><tr><th>区别</th><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>作用域</td><td>函数作用域</td><td>块级作用域</td><td>块级作用域</td></tr><tr><td>重复声明</td><td>可以</td><td>不可以</td><td>不可以</td></tr><tr><td>初始赋值</td><td>可以不赋值</td><td>可以不赋值</td><td>必须赋值</td></tr><tr><td>修改赋值</td><td>可以修改</td><td>可以修改</td><td>不可以修改</td></tr><tr><td>变量提升</td><td>存在</td><td>不存在</td><td>不存在</td></tr></tbody></table> 
<p>引申：</p> 
<p>在js中未声明的变量，在非严格模式下,会被隐式视为创建全局变量在严格模式下,这是一个错误.</p> 
<pre> function show() {
            a = 10
            console.log(a); //10
        }
        show()
        console.log(a); //10
</pre> 
<p></p> 
<h2>02 -《变量提升和函数提升》</h2> 
<h4>一、JS 的预解析</h4> 
<p>浏览器之所以能够运行 JS 代码，是因为每一款浏览器中都有一个 JS 引擎，专门负责处理 JS 代码。而 JS 引擎在处理 JS 代码时，分为两个步骤：</p> 
<ol><li> <p>预解析：在代码真正执行之前会先对代码做一些额外的处理；</p> </li><li> <p>执行代码：对处理后的代码，开始从上往下依次执行；</p> </li></ol> 
<p>变量提升和函数提升，就是在预解析阶段对代码做的额外处理。</p> 
<h4>二、变量提升</h4> 
<p>变量提升，在代码预解析阶段，JS 引擎会找到<strong>当前作用域</strong>中所有通过 var 创建的变量，然后将这些<strong>变量的创建</strong>提升到当前作用域的顶部，并且将变量的初始值设置为 undefined。</p> 
<p>例如以下代码：</p> 
<pre>console.log(a);//undefined
var a = 1;
</pre> 
<p>经过预解析处理后，变成了以下形式：</p> 
<pre>var a = undefined;
console.log(a);
a = 1;
</pre> 
<h4>三、函数提升</h4> 
<p>函数提升，在代码预解析阶段，JS 引擎会找到<strong>当前作用域</strong>中所有的声明式函数，然后将这些函数整体全部提升到当前作用域的顶部。</p> 
<p>例如以下代码：</p> 
<pre>foo();
function foo() {
    console.log(1)
}
</pre> 
<p>经过预解析处理后，变成了以下形式：</p> 
<pre>function foo() {
    console.log(1)
}
foo();
</pre> 
<h4>四、总结</h4> 
<p>简单来说，我们只需要记住，var 创建的变量和声明式函数，都存在提升。var 提升的是创建的变量以及初始赋值 undefined，声明式函数提升的是函数整体。</p> 
<h4>五、暂时性死区（扩展）</h4> 
<p>严格意义上来说，let、const 创建的变量不应该说“不提升”，而是有一个新的特性：暂时性死区。</p> 
<p>在变量的处理过程中，分为三个阶段：</p> 
<ol><li> <p>创建变量：通过关键创建变量；</p> </li><li> <p>变量初始化：第一次给变量设置值；</p> </li><li> <p>变量赋值：从第二次开始修改变量的值；</p> </li></ol> 
<p>暂时性死区，指的就是在预解析阶段，变量只有创建过程被提升了，初始化和赋值都没有提升，导致我们在使用变量时出现暂时性死区，报错提示“初始化之前不能访问变量”。</p> 
<p>我们分别从下面三个例子中来理解这个概念。</p> 
<p>1、var 声明的变量</p> 
<p>我们来看看通过 var 声明的变量，整个“创建、初始化和赋值”过程。</p> 
<p>假设有如下代码：</p> 
<pre> console.log(a);
 var a = 1;
</pre> 
<p>JS 引擎会有以下过程：</p> 
<ol><li> <p>找到所有用 var 声明的变量，在环境中<strong>“创建”</strong>这些变量（即变量 a）；</p> </li><li> <p>将这些变量<strong>“初始化”</strong>为 undefined；</p> </li><li> <p>开始执行代码，输出变量 a，得到 undefined；</p> </li><li> <p>a = 1 将 a 变量<strong>“赋值”</strong>为 1；</p> </li></ol> 
<p>也就是说，var 声明的变量会在代码执行之前就“创建变量，并将其初始化为 undefined”。这就解释了为什么在 <code>var a = 1</code> 之前 <code>console.log(a)</code> 会得到 undefined。</p> 
<p>2、function 声明的函数</p> 
<p>接下来看看 function 声明的函数，整个“创建、初始化和赋值”过程。</p> 
<p>假设有如下代码：</p> 
<pre> foo();
 function foo() {
     console.log(2);
 }
</pre> 
<p>JS 引擎会有以下过程：</p> 
<ol><li> <p>找到所有用 function 声明的变量，在环境中“创建”这些变量（即 foo）。</p> </li><li> <p>将这些变量“初始化”并“赋值”为 <code>function () { console.log(2) }</code>。</p> </li><li> <p>开始执行代码 <code>foo()</code>；</p> </li></ol> 
<p>也就是说 function 声明会在代码执行之前就“创建、初始化并赋值”。</p> 
<p>3、let 的提升</p> 
<p>最后我们来看看 let 声明的变量，整个“创建、初始化和赋值”过程。</p> 
<p>假设代码如下：</p> 
<pre> let a = 1;
     a = 2;
</pre> 
<p>JS 引擎会有以下过程：</p> 
<ol><li> <p>找到所有用 let 声明的变量，在环境中“创建”这些变量；</p> </li><li> <p>开始执行代码（注意现在没有初始化）;</p> </li><li> <p>执行 x = 1，将 x “初始化”为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）；</p> </li><li> <p>执行 x = 2，对 x 进行“赋值”；</p> </li></ol> 
<p>因此，如果在 <code>let a</code> 之前访问 <code>a</code> 会出现报错：</p> 
<pre>console.log(a); // Uncaught ReferenceError: a is not defined
 let a = 1;
</pre> 
<p>这是因为，在执行 log 时 a 虽然已经创建了，但还没“初始化”，所以不能使用（也就是所谓的暂时性死区）。</p> 
<p>同样的道理，我们再看以下代码：</p> 
<pre> let a = "global";
 {
     console.log(a); // Uncaught ReferenceError: a is not defined
     let a = 1;
 }
</pre> 
<p>我们发现还是会报同样的错。</p> 
<p>原因有两个：</p> 
<ol><li> <p>全局虽然创建了 a，且在输出前也完成了初始化；但是由于块级作用域中也创建了 a，虽然在输出前没有初始化，但是只要当前作用域已经创建了该变量，使用时就不会再访问其他作用域中的同名变量。</p> </li><li> <p>但是由于执行 log 时 a 虽然“创建”了但是没有“初始化”，所以不能使用（暂时性死区）；</p> </li></ol> 
<p>4、总结</p> 
<p>通过以上三个例子，我们总结一下变量提升和函数提升：</p> 
<ol><li> <p>var 声明的变量，“创建”和“初始化”都会被提升；</p> </li><li> <p>function 创建的函数，“创建”、“初始化”和“赋值”都会被提升；</p> </li><li> <p>let 声明的变量，只有“创建”的过程会被提升，”初始化“和”赋值“都没有提升；</p> </li></ol> 
<p>而对于我们的 JS 引擎来说，执行代码会遵循以下原则：</p> 
<ol><li> <p>如果当前作用域中已经创建了对应的变量，在使用时就不会去其他作用域中查找；</p> </li><li> <p>变量如果只是创建完成但没有初始化的话，是无法使用的（使用时会报错）；</p> </li></ol> 
<h2>03 -《内存空间》</h2> 
<p>在 JS 中，不管是基础数据还是引用数据，只要是数据，都会保存在浏览器的内存空间中。而不同类型的数据，在内存中保存到方式也是不一样的。</p> 
<h4>堆和栈</h4> 
<p>浏览器的内存空间，划分了两块区域，分别叫做“堆”和“栈”。</p> 
<p>所有基础类型的数据，都是保存在“栈”中；所有引用类型的数据，都是保存在“堆”中。</p> 
<p>例如：</p> 
<pre>var a = 1;
var b = 'hello';
var arr = [1, 2, 3];
var obj = { x: 1, y: 2 };
var newArr = arr;
var newObj = obj;
</pre> 
<p>图例解析：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/f5/9nOfvzGN_o.png"></p> 
<h4>结论</h4> 
<ol><li> <p>所有基础类型的数据，数据值都是保存在栈里面的；</p> </li><li> <p>所有引用类型的数据，数据值都是保存在堆里面的；</p> </li><li> <p>所有引用类型的数据，都有一个“引用地址”，指向了数据值在堆里面的位置；</p> </li><li> <p>所有的引用地址，都是保存在栈里面的；</p> </li></ol> 
<h2>04 -《解构赋值》</h2> 
<p>解构赋值，通常都是用在数组或对象中。当我们需要从一组数据中获取到其中某几个数据时，就会考虑使用解构赋值。</p> 
<h4>一、基础语法</h4> 
<p>1、数组的解构赋值</p> 
<p>例如我们有数组中有一组数字：</p> 
<pre>const arr = [10, 20, 30, 40];
</pre> 
<p>现在，我们需要单独的拿到数组中的每一个值，并赋值给不同的变量。传统的处理方式如下：</p> 
<pre>const a = arr[0];
const b = arr[1];
const c = arr[2];
const d = arr[3];
</pre> 
<p>而 ES6 中的解构赋值可以让这个过程变得更加简单：</p> 
<pre>const [a, b, c, d] = arr;
</pre> 
<p><code>=</code> 赋值符右边数组中的数据，会按照下标对应的位置，依次赋值给 <code>=</code> 赋值符左边的数组中的变量。</p> 
<p>如果我们不需要解构全部的值，只需要拿到其中的某几个值，也可以：</p> 
<pre>const [a] = arr;
console.log(a);    // 1
const [, , , d] = arr;
console.log(d);    // 4
</pre> 
<p>2、对象的解构赋值</p> 
<p>例如我们有对象中有一组学生信息数据：</p> 
<pre>const student = { name: '张三', age: 20, gender: '男' };
</pre> 
<p>现在，我们需要单独的拿到对象中的每一个值，并赋值给不同的变量。传统的处理方式如下：</p> 
<pre>const a = student.name;
const b = student.age;
const c = student.gender;
</pre> 
<p>而 ES6 中的解构赋值可以让这个过程变得更加简单：</p> 
<pre>const { name: a, age: b, gender: c }  = student;
</pre> 
<p><code>=</code> 赋值符右边对象中的数据，会按照对应的键名，依次赋值给 <code>=</code> 赋值符左边的对象值中的变量。</p> 
<p>如果我们不需要解构全部的值，只需要拿到其中的某几个值，也可以：</p> 
<pre>const { name: a }  = student;
console.log(a);    // 张三
</pre> 
<p>上面的代码我们还可以继续优化，变量是可以我们自己任意命名的，因此，上面的代码我们也可以改写成：</p> 
<pre>const { name: name, age: age, gender: gender }  = student;
</pre> 
<p>又因为 ES6 中，针对对象的键和值如果是同一个单词时，可以再简写一下，最终变成以下格式：</p> 
<pre>const { name, age, gender } = student;
</pre> 
<h4>二、解构赋值的默认值</h4> 
<p>解构赋值允许通过赋值符 <code>=</code> 给每一个变量设置默认值。这样，当某一个变量没有被赋值时，就可以使用自己的默认值。</p> 
<p>1、数组解构赋值的默认值</p> 
<p>示例代码：</p> 
<pre> // 没有默认值
 var [a, b] = [];
 console.log( a );  // undefined
 console.log( b );  // undefined
 // 有默认值
 var [a = 1, b = 2] = [];
 console.log( a );  // 1
 console.log( b );  // 2
 var [a = 1, b = 2] = [3, 4];
 console.log( a );  // 3
 console.log( b );  // 4
</pre> 
<p>说明：并不是每一个变量都必须给默认值，我们可以根据自己的需求来设置。</p> 
<p>2、对象解构赋值的默认值</p> 
<p>示例代码：</p> 
<pre> // 没有默认值（不简写）
 var { name: name } = {};
 console.log( name ); // undefined
 // 没有默认值（简写）
 var { name } = {};
 console.log( name ); // undefined
 // 有默认值（不简写）
 var { name: name = "张三" } = {};
 console.log( name ); // 张三
 // 有默认值（简写）
 var { name = "张三" } = {};
 console.log( name ); // 张三
 var { name = "张三", age } = { name: "李四", age: 30 };
 console.log( name, age ); // 李四 30
</pre> 
<h4>三、函数参数中的解构赋值</h4> 
<p>因为函数的参数也可以是数组或对象，因此，数组对象的解构赋值也可以用在函数的参数中。</p> 
<p>示例代码：</p> 
<pre> function add([x, y]){
     console.log(x + y);  // 3
 }
 add([1, 2]);
</pre> 
<p>上面代码中，在调用函数 <code>add</code> 时传递了一个数组作为实参，在接收时本来应该用一个形参来接收。但是，我们直接用数组将形参解构了，然后根据解构赋值的规则，用变量 <code>x</code> 和 <code>y</code> 接收到数组中对应的数字 <code>1</code> 和 <code>2</code>。</p> 
<p>参数为对象时也是同样的道理：</p> 
<pre> function add({ x, y }){
     console.log(x + y); // 3
 }
 add({ x: 1, y: 2 });
</pre> 
<p>1、参数解构赋值的默认值</p> 
<p>解构赋值的默认值在函数形参中同样适用。</p> 
<p>参数为数组时：</p> 
<pre> // x、y 没有接收到实际的值，就会使用默认的值
 function add([x = 1, y = 2]){
     console.log(x + y);  // 3
 }
 add([]);  
 // x、y 接收到了实际的值，就不会使用默认的值
 function add([x = 1, y = 2]){
     console.log(x + y);  // 30
 }
 add([10, 20]);
</pre> 
<p>参数为对象时：</p> 
<pre> // x、y 没有接收到实际的值，就会使用默认的值
 function add({ x = 1, y = 2 }){
     console.log(x + y); // 3
 }
 add({});   
 // x、y 接收到了实际的值，就不会使用默认的值
 function add({ x = 1, y = 2 }){
     console.log(x + y); // 30
 }
 add({x: 10, y: 20});
</pre> 
<p>2、实参为空的解构赋值</p> 
<p>如果我们对在形参中对一个数组或对象进行解构赋值，但是，在调用时，并没有传递任何参数。例如：</p> 
<pre> function add([x = 1, y = 2]) {
     console.log(x + y);
 }
 add();
 // 或
 function add({x = 1, y = 2}) {
     console.log(x + y);
 }
 add();
</pre> 
<p>这个时候，程序会报错。</p> 
<p>原因在于我们调用函数时没有传实参，那么形参接收到的其实就是 <code>undefined</code>。而从语法上来说，<code>undefined</code> 是不能解构成一个数组或对象的，因此程序会报错。</p> 
<p>所以，这里我们要考虑两种情况的默认值：</p> 
<ol><li> <p>函数参数的默认值：当没有传递任何实参时，我们默认实参是一个 <code>[]</code> 或 <code>{}</code>；</p> </li><li> <p>解构赋值的默认值：当数组或对象中没有值时，我们根据需求设置变量以及变量默认值；</p> </li></ol> 
<p>示例代码如下：</p> 
<pre> // 函数参数的默认值：设置形参 arr 的默认值是一个 []
 function add(arr = []) {
 }
 add();
 // 对形参 arr 进行解构
 function add([x, y] = []) {
 }
 add();
 // 最终方案：参数的默认值以及解构赋值的默认值
 function add([x = 1, y = 2] = []) {
     console.log(x + y);   // 3
 }
 add();
</pre> 
<p>这样，即使我们调用函数时没有传参，函数也会默认使用空数组 <code>[]</code>，然后再对 <code>[]</code> 进行解构赋值。解构赋值后 x 和 y 也没有接收到值，然后都使用自己的默认值 1 和 2。</p> 
<p>同理，参数为对象时也可以这样处理：</p> 
<pre> function add({ x = 1, y = 2 } = {}) {
     console.log(x + y);
 }
 add();
</pre> 
<h2>05 - 《扩展运算符》</h2> 
<p>扩展运算符，符号是 <code>...</code>。</p> 
<p>扩展运算符的作用，就是通过 <code>...数据</code> 的形式将一组数据全部展开。</p> 
<h4>一、数组的扩展</h4> 
<p>基础语法：</p> 
<pre>const arr = [10, 20, 30];
console.log(...arr);
</pre> 
<p>应用场景</p> 
<p>1、数组的复制</p> 
<p>当我们希望从原数组身上复制一个新的数组出来，要求数据一模一样，但是地址不一样：</p> 
<pre>const arr = [10, 20, 30];
const newArr = [...arr];
</pre> 
<p>2、数组的合并</p> 
<p>当我们需要将多个数组合并成一个新数组，除了数组自带的 <code>concat()</code> 方法外，也可以使用扩展运算符：</p> 
<pre>const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const newArr = [...arr1, ...arr2];
</pre> 
<p>3、数组项的新增</p> 
<p>当我们需要在一个原数组的基础之上，往数组中新增一个或多个元素，同时还要得到的是一个新数组的地址：</p> 
<pre>const arr = [10, 20, 30];
const newArr = [...arr, 40, 50];
</pre> 
<h4>二、对象的扩展</h4> 
<p>应用场景</p> 
<p>1、对象的复制</p> 
<p>当我们希望从原对象身上复制一个新的对象出来，要求数据一模一样，但是地址不一样：</p> 
<pre>const obj = { a: 1, b: 2 };
const newObj = { ...obj };
</pre> 
<p>2、对象的合并</p> 
<p>当我们需要将多个对象合并成一个新对象，也可以使用扩展运算符：</p> 
<pre>const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const newObj = { ...obj1, ...obj2 };
</pre> 
<p>3、对象属性的新增</p> 
<p>当我们需要在一个原对象的基础之上，往对象中新增一个或多个属性，同时还要得到的是一个新对象的地址：</p> 
<pre>const obj = { a: 1, b: 2 };
const newObj = { ...obj, c: 3, d: 4, e: 5 };
</pre> 
<h2>06 -《Set 和 Map》</h2> 
<p>ES6 中新增了两种新的数据结构 —— Set 和 Map。</p> 
<h4>一、Set</h4> 
<p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的，没有重复的值</strong>。</p> 
<p>1、基本用法</p> 
<p><strong>创建 Set</strong></p> 
<p>Set 本身是一个构造函数，调用构造函数用来生成 Set 数据结构。</p> 
<pre> var s = new Set();
 console.log(s);
</pre> 
<p><strong>初始化</strong></p> 
<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行初始化。</p> 
<pre> let s = new Set([1, 2, 3, 4, 4]);
 console.log(s);
</pre> 
<p>通过上面代码运行结果我们可以看到，Set 成员当中如果存在重复的值，会被自动删除掉。</p> 
<p>2、Set 实例的属性和方法</p> 
<p>Set 结构的实例有以下属性和操作方法。</p> 
<p>属性</p> 
<ul><li> <p><code>size</code>：返回 Set 实例的成员总数。</p> </li></ul> 
<pre> let s = new Set([1, 2, 3])
 console.log(s.size);   // 3
</pre> 
<p>方法</p> 
<p>Set 实例的方法分为两大类：操作方法（用于数据操作）和遍历方法（用于遍历数据）。</p> 
<p>操作方法</p> 
<ul><li> <p><code>add(value)</code>：添加数据，并返回新的 Set 结构。</p> </li><li> <p><code>delete(value)</code>：删除数据，返回一个布尔值，表示是否删除成功。</p> </li><li> <p><code>has(value)</code>：查看是否存在某个数据，返回一个布尔值。</p> </li><li> <p><code>clear()</code>：清除所有数据，没有返回值。</p> </li></ul> 
<pre> let set = new Set([1, 2, 3, 4, 4]); 
 // 添加数据 5
 let addSet = set.add(5);
 console.log(addSet);   // Set(5) {1, 2, 3, 4, 5}
 // 删除数据 4
 let delSet = set.delete(4);
 console.log(delSet);   // true
 // 查看是否存在数据 4
 let hasSet = set.has(4);
 console.log(hasSet);   // false
 // 清除所有数据
 set.clear();
 console.log(set);      // Set(0) {}
</pre> 
<p>遍历方法</p> 
<p>Set 提供了三个遍历器生成函数和一个遍历方法。</p> 
<ul><li> <p><code>keys()</code>：返回一个键名的遍历器。</p> </li><li> <p><code>values()</code>：返回一个键值的遍历器。</p> </li><li> <p><code>entries()</code>：返回一个键值对的遍历器。</p> </li><li> <p><code>forEach()</code>：使用回调函数遍历每个成员。</p> </li></ul> 
<pre>let color = new Set(["red", "green", "blue"]);
 for(let item of color.keys()){
     console.log(item);
 }
 // red
 // green
 // blue
 for(let item of color.values()){
     console.log(item);
 }
 // red
 // green
 // blue
 for(let item of color.entries()){
     console.log(item);
 }
 // ["red", "red"]
 // ["green", "green"]
 // ["blue", "blue"]
 color.forEach((item) =&gt; {
     console.log(item)
 })
 // red
 // green
 // blue
</pre> 
<p>说明：</p> 
<p>上例代码中，<code>entries()</code>方法返回的遍历器，同时包括了键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p> 
<p>3、转换为数组</p> 
<p><strong>扩展运算符</strong></p> 
<p>由于扩展运算符<code>...</code>内部的原理也是使用的<code>for-of</code>循环，所以也可以用于操作 Set 结构。</p> 
<p>例如将 Set 结构转换为数组结构：</p> 
<pre> let color = new Set(["red", "green", "blue"]);
 let colorArr = [...color];
</pre> 
<p><strong>数组剔重</strong></p> 
<p>*扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p> 
<pre> let arr = [1, 1, 2, 2, 3, 3];
 let unique = [...new Set(arr)];     // [1, 2, 3]
</pre> 
<h4>二、Map</h4> 
<p>JavaScript 中的对象（Object），本质上是键值对的集合，但是只能用字符串来做键名。这给它的使用带来了很大的限制。</p> 
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p> 
<p>也就是说，Object 结构提供了“字符串 - 值”的对应，Map 结构提供了“值 - 值”的对应，是一种更完善的 JSON 数据结构的实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p> 
<p>1、基本用法</p> 
<p><strong>创建 Map</strong></p> 
<p>Map 本身是一个构造函数，调用构造函数用来生成 Map 数据结构。</p> 
<pre> var m = new Map();
 console.log(m);
</pre> 
<p><strong>初始化</strong></p> 
<p>Map 函数也可以接受一个数组（或类似数组的对象）作为参数，用来进行初始化。但是跟 Set 不同的是，Map 中该数组中的成员是一对对表示键值对的数组。</p> 
<pre> let m = new Map([["name", "zhangsan"], ["age", 20]]);
 console.log(m);
</pre> 
<p>2、Map 实例的属性和方法</p> 
<p>Map 结构的实例有以下属性和方法。</p> 
<p>属性</p> 
<ul><li> <p><code>size</code>：返回 Map 结构的成员总数。</p> </li></ul> 
<pre> let m = new Map([["name", "zhangsan"], ["age", 20]]);
 console.log( m.size );
</pre> 
<p>方法</p> 
<p>Map 实例的方法也分为了两大类：操作方法（用于数据操作）和遍历方法（用于遍历数据）。</p> 
<p>操作方法</p> 
<ul><li> <p><code>set(key, value)</code>：添加或修改数据。设置<code>key</code>所对应的键值，并返d回 Map 结构本身。</p> </li><li> <p><code>get(key)</code>：获取数据。读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p> </li><li> <p><code>has(key)</code>：查看是否存在某个数据，返回一个布尔值。</p> </li><li> <p><code>delete(key)</code>：删除数据。删除成功返回<code>true</code>。</p> </li><li> <p><code>clear()</code>：清除所有数据，没有返回值。</p> </li></ul> 
<pre> let map = new Map([["name", "zhangsan"], ["age", 20]]);
 // 设置 name 的值为 lisi
 map.set("name", "lisi");
 console.log( map );       // Map(2) {"name" =&gt; "lisi", "age" =&gt; 20}
 // 获取 name 对应的值
 let getMap = map.get("name");
 console.log( getMap );    // lisi
 // 查看是否存在 age
 let hasMap = map.has("age");
 console.log( hasMap );    // true
 // 删除 age 键值对
 let delMap = map.delete("age");
 console.log( delMap );    // true
 // 清空所有数据
 map.clear();
 console.log(map);         // Map(0) {}
</pre> 
<p>遍历方法</p> 
<p>Map 提供了三个遍历器生成函数和一个遍历方法。</p> 
<ul><li> <p><code>keys()</code>：返回一个键名的遍历器。</p> </li><li> <p><code>values()</code>：返回一个键值的遍历器。</p> </li><li> <p><code>entries()</code>：返回一个键值对的遍历器。</p> </li><li> <p><code>forEach()</code>：使用回调函数遍历每个成员。</p> </li></ul> 
<pre> let num = new Map([["one", 1], ["two", 2], ["three", 3]]);
 for(let key of num.keys()){
     console.log(key);
 }
 // one
 // two
 // three
 for(let value of num.values()){
     console.log(value);
 }
 // 1
 // 2
 // 3
 for(let item of num.entries()){
     console.log(item[0], item[1]);
 }
 // one 1
 // two 2
 // three 3
 // 将上面代码通过解构改成如下
 for(let [key, value] of num.entries()){
     console.log(key, value);
 }
 // one 1
 // two 2
 // three 3
 num.forEach((value, key) =&gt; {
     console.log(value, key)
 })
 // 1 one
 // 2 two
 // 3 three
</pre> 
<h4>三、与其他数据结构互换</h4> 
<p>1、Map 转为数组</p> 
<p>Map 转为数组最方便的方法，就是使用扩展运算符<code>...</code>。</p> 
<pre> let myMap = new Map();
 myMap
     .set(true, "真")
     .set(false, "假");
 console.log(myMap);   // {true =&gt; "真", false =&gt; "假"}
 let newMap = [...myMap];
 console.log(newMap);  // [[true, "真"], [false, "假"]]
</pre> 
<p>2、数组转为 Map</p> 
<p>将数组传入 Map 构造函数中，就可以转为 Map。</p> 
<pre> let arr = [[true, "真"], [false, "假"]];
 let map = new Map(arr);
 console.log(map);   // {true =&gt; "真", false =&gt; "假"}
</pre> 
<p>3、Map 转为对象</p> 
<p>如果 Map 所有的键都是字符串，它就可以转为对象。</p> 
<pre> function strMapToObj(strMap){
     let obj = {};
     for(let [k, v] of strMap){
         obj[k] = v;
     }
     return obj;
 }
 let myMap = new Map().set("green","绿").set("red","红");
 console.log(myMap);                  // {"green" =&gt; "绿", "red" =&gt; "红"}
 console.log( strMapToObj(myMap) );   // { green: "绿", red: "红" }
</pre> 
<p>4、对象转为 Map</p> 
<pre> function objToStrMap(obj){
     let strMap = new Map();
     for(let item in obj){
         strMap.set( item, obj[item] )
     }
     return strMap;
 }
 let obj = { name: "zhangsan", age: 20 };
 console.log( objToStrMap(obj) );    
 // {"name" =&gt; "zhangsan", "age" =&gt; 20}
</pre> 
<h2>07 -《函数的其他形式》</h2> 
<h4>一、匿名函数</h4> 
<p>匿名函数，就是指的没有函数名的函数。</p> 
<pre>const foo = function () {
}
</pre> 
<h4>二、立即执行函数</h4> 
<p>立即执行函数，简称为“IIFE”。指的就是函数在创建的同时立即就执行了。</p> 
<pre>(function () {
    console.log(1)
})();
</pre> 
<h4>三、回调函数</h4> 
<p>回调函数，指的是将一个函数 A 作为参数，传递给另一个函数 B，那么其中的函数 A，就称之为“回调函数”。</p> 
<pre>setTimeout(function () { }, 1000);
</pre> 
<h4>四、递归函数</h4> 
<p>当一个内部在调用自己，那么该函数就是一个“递归函数”。</p> 
<pre>function foo() {
    console.log(1);
    foo();
}
foo();
</pre> 
<p>注意：在使用递归函数时，需要一些判断条件，来避免出现无限递归。</p> 
<p>练习：将一个多维数组扁平化。</p> 
<pre>const arr = [1, 2, [3, 4], 5, [6, [7, 8]]];
</pre> 
<h2>08 -《执行上下文》</h2> 
<p>执行上下文，指的就是代码的运行环境。</p> 
<h4>一、执行上下文的分类</h4> 
<p>执行上下文分为三类：</p> 
<ol><li> <p>全局上下文：在代码运行之前，会自动产生一个全局上下文；</p> </li><li> <p>局部上下文：在函数被调用时，会产生一个局部上下文；</p> </li><li> <p><code>eval()</code> 上下文：在 <code>eval()</code> 方法被调用时，会产生一个 <code>eval()</code> 上下文（仅作了解）；</p> </li></ol> 
<h4>二、执行上下文栈</h4> 
<p>在代码运行过程中，每一次产生的执行上下文，都会保存到内存的栈空间中，这个保存的过程，我们叫做“压栈”。</p> 
<p>当一个函数调用完成时，该函数对应的执行上下文，会从栈空间中销毁，这个销毁的过程，我们叫做“出栈”。</p> 
<p>执行上下文栈，采用的压栈和出栈的顺序是：先进后出，后进先出。</p> 
<p>对于执行上下文栈来说，只最上面的上下文是处于活动状态的，而只有活动状态的上下文，才能运行其内部的代码。</p> 
<h4>三、总结</h4> 
<ol><li> <p>任何一个程序，都会产生唯一的一个全局上下文；</p> </li><li> <p>任何函数，只要被调用一次，就会产生一个对应的局部上下文，调用多次就产生多个；</p> </li><li> <p>当一个函数调用完成时，对应的上下文会从栈内存中销毁；</p> </li><li> <p>只有处于栈内存顶部的上下文，是活动状态的，其内部的代码才能运行；</p> </li></ol> 
<h2>09 -《变量对象》</h2> 
<p>变量对象，就是用来保存当前上下文中所有的数据。</p> 
<h4>一、上下文和变量对象</h4> 
<p>执行上下文从创建到销毁可以分为三个阶段：</p> 
<ol><li> <p>执行上下文创建：在执行上下文内部创建变量对象、建立作用域链、确定 this 指向；</p> </li><li> <p>代码运行阶段：当执行上下文创建完成后，开始运行内部代码；</p> </li><li> <p>执行上下文销毁：当代码运行完成后，执行上下文从栈中销毁；</p> </li></ol> 
<p>从以上三个步骤中，可以分析出上下文和变量对象之间的关系：</p> 
<ul><li> <p>每一个执行上下文中都会有一个自己的变量对象；</p> </li><li> <p>上下文在创建的同时，它的变量对象也就产生了；</p> </li></ul> 
<h4>二、变量对象的作用</h4> 
<p>变量对象在创建的时候，会依次完成以下三件事情：</p> 
<ol><li> <p>找到当前上下文中所有的参数，将形参和实参以“键值对”的形式保存在变量对象中；</p> </li><li> <p>找到当前上下文中所有的声明式函数，将函数名和函数地址以“键值对”的形式保存在变量对象中；</p> </li><li> <p>找到当前上下文中所有通过 <code>var</code> 声明的变量，将变量名和 <code>undefined</code> 以“键值对”的形式保存在变量对象中；</p> </li></ol> 
<p>以上三件事情完成后，变量对象就创建完成了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3a/c8/ix5PDlkM_o.png"></p> 
<p>说明：如果出现形参名、函数名、变量名重名的情况，正常情况下是变量对象中后面的会覆盖前面的。但是由于 JavaScript 中的函数是一等公民，所以如果变量没有的值的时候，是无法将同名函数给覆盖掉的。</p> 
<h2>10 -《作用域链》</h2> 
<h3>作用域链</h3> 
<p>我们知道，当函数被调用激活时，会开始创建对应的执行上下文。在执行上下文生成的过程中，<strong>变量对象</strong>、<strong>作用域链</strong>、以及<strong><code>this</code></strong>的值会分别被确定。在前面我们已经详细讲解了关于变量对象的分析，所以这里，我们接着来分析作用域链。</p> 
<blockquote> 
 <p>作用域链，实际上是由一系列的<strong>变量对象</strong>组成的。</p> 
 <p>每一个作用域链，它的前端始终是当前代码的执行行上下文的变量量对象，而它的末端也始终是全局上下文的变量对象。</p> 
</blockquote> 
<h4>案例分析</h4> 
<p>但看文字估计还是不太能理解到底什么是作用链，所以我们通过一个例子，结合代码来具体进行分析说明。</p> 
<pre>var food = "巧克力味的屎";
var eat = function(){
    console.log( "吃" + food );//函数在创建的时候，找父级
};
(function(){
    var food = "屎味的巧克力";
    eat();
})();
</pre> 
<p>全局上下文在浏览器器打开的同时产生，eat 上下文和立即执行函数上下文都是在函数调用时才产生。上下文<strong>创建</strong>好的同时，在上下文的内部创建出了了变量量对象和作用域链。</p> 
<p>作用域链中包含的每一个变量量对象，都应该是前一个变量量对象所在函数声明时所在的上下文内的变量量对象。</p> 
<p>也就是说， eat 函数声明时所在的上下文是全局上下文，所以， eat 作用域链中的第二个变量量对象应该是全局上下文中的变量量对象。</p> 
<p>这样，我们 eat 函数在查找 food 变量量时会沿着作用域链最终查找到全局变量对象中去，得到 <code>food="巧克力味的屎"</code> 的结果。</p> 
<h2>11 -《闭包》</h2> 
<p>闭包，实际上指的就是当一个函数执行完成后，由于其他地方需要继续使用该函数内部的数据，导致这个函数的变量对象在该销毁的时候没有销毁，因此，这个函数就变成了一个闭包函数。</p> 
<p>一个函数如果要形成闭包，需要满足以下几个条件：</p> 
<ol><li> <p>函数之间形成嵌套；</p> </li><li> <p>内部函数中在访问外部函数的变量对象；</p> </li><li> <p>内部函数在创建以外的其他区域被调用；</p> </li></ol> 
<p>闭包的优点：</p> 
<ol><li> <p>延长了变量的作用时间；</p> </li><li> <p>扩大了变量的作用范围；</p> </li><li> <p>避免全局变量名的污染（命名冲突）；</p> </li></ol> 
<p>闭包的缺点：</p> 
<ol><li> <p>滥用闭包会造成内存的浪费；</p> </li></ol> 
<p>例子：</p> 
<pre> function foo() {
            let a = 1;
            function bar() {
                console.log(a);
            }
            return bar;
        }

        const bar = foo();
        // bar();

        function outer() {
            bar();
        }
</pre> 
<p></p> 
<h2>12 -《面向对象的概念》</h2> 
<p>面向对象，实际上就是以对象为核心的一种编程方式。</p> 
<h4>一、面向过程</h4> 
<p>面向过程的编程方式，重点会放在项目的过程上。</p> 
<p>例如：ATM 取款机的练习。我们分析它的步骤：</p> 
<ol><li> <p>注册</p> </li><li> <p>登录</p> </li><li> <p>主菜单</p> </li><li> <p>存款</p> </li><li> <p>取款</p> </li><li> <p>…</p> </li></ol> 
<p>当我们把过程分析好后，代码层面，我们会根据每一个步骤都封装成一个函数：</p> 
<pre>function register() { };
function login() {  };
function menu() { };
// ...
</pre> 
<h4>二、面向对象</h4> 
<p>面向对象的编程方式，重点会放在项目的对象上。</p> 
<p>1、对象</p> 
<p>我们可以将任何事物都看作是一个对象，每一个对象都有自己的属性和方法。例如：一个学生对象，他的姓名、年龄、性别等信息，就可以看作是该对象的属性。学生可以学习、走路、吃饭等能力，这些能录就可以看作是学生对象的方法。</p> 
<p>例如：ATM 取款机的练习。我们分析它里面包含的对象：</p> 
<ul><li> <p>ATM 取款机对象：提供了登录、注册、存款、取款、转账等方法；</p> </li><li> <p>用户对象：提供了账号、密码、账户余额等属性；</p> </li></ul> 
<p>模拟面向对象的代码：</p> 
<pre>const user = {
    account: '1',
    password: '1',
    money: 1000
}
const atm = {
    login: function () {
    },
    register() {
    },
    saveMoney() {
    }
}
atm.register();
</pre> 
<h4>面向过程和面向对象的对比</h4> 
<p>面向过程</p> 
<p>●优点: 性能比面向对象高,适合跟硬件联系很紧密的东西,例如单片机就采用的面向过程编程。 ●缺点:没有面向对象易维护、易复用、易扩展</p> 
<p>面向对象</p> 
<p>●优点:易维护、易复用、易扩展,由于面向对象有封装、继承、多态性的特性,可以设计出低耦合的面向对象系统,使系统更加灵活、更加易于维护 ●缺点:性能比面向过程低</p> 
<p>用面向过程的方法写出来的程序是-份蛋炒饭,而用面向对象写出来的程序是-份盖浇饭。</p> 
<h2>13 -《创建类和对象》</h2> 
<h4>一、类</h4> 
<p>类，我们可以理解为“种类”、“分类”。</p> 
<p>类，就是用来管理所有同类型的对象。换句话说，我们可以通过一个类，产生很多个一样的对象。</p> 
<p>所以，类和对象之间的关系：通过一个类可以产生多个相同的对象。</p> 
<p></p> 
<p>引申：</p> 
<p><code>类</code>抽象了对象的公共部分,它泛指某一大类( class ) <code>对象</code>特指某一个,通过类实例化-个具体的对象</p> 
<p>面向对象的思维特点: 1.抽取(抽象)对象共用的属性和行为组织(封装)成一 个<code>类</code>(模板) 2.对类进行实例化,获取类的<code>对象</code></p> 
<p>1、创建类</p> 
<p>在 ES6 之前，JavaScript 中并没有类的概念，因此也没有创建类的代码。所以，在 ES6 之前，都是用函数来模拟类。</p> 
<pre>// 模拟一个“学生类”
function Student() {
}
</pre> 
<p>说明：虽然首字母大写不是必须的，但是所有程序员之间，有一个约定俗成的习惯，就是将这种用来创建对象的函数叫做“构造函数”，实际上就是用来模拟“类”。</p> 
<p>2、产生对象</p> 
<p>直接通过 <code>new</code> 的方式去调用构造函数，就会得到一个对象。</p> 
<p>例如，我们想要通过 <code>Student</code> 类得到学生对象：</p> 
<pre>const s1 = new Student();
const s2 = new Student();
</pre> 
<p>通过 <code>new</code> 的方式去调用构造函数，得到的对象，通常叫做“实例对象”。</p> 
<h4>二、实例对象的属性和方法</h4> 
<p>1、实例对象的属性</p> 
<p><strong>在每一个构造函数中，都有一个 this 关键字，指向了 new 出来的实例对象。</strong></p> 
<pre>function Student(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.major = "WEB前端";
}
const s1 = new Student('张三', 20, '男');
const s2 = new Student('李四', 18, '女');
console.log('s1', s1);
console.log('s2', s2)
;
</pre> 
<p>2、实例对象的方法</p> 
<p>所有实例对象的方法，都设置在构造函数的 <code>prototype</code> 属性上：</p> 
<pre>function Student(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.major = "WEB前端";
}
// 原型
Student.prototype.sayHello = function () {
    console.log('hello');
}
Student.prototype.introduce = function () {
    this.sayHello();
    console.log(`我叫${this.name}，性别${this.gender}，今年${this.age}岁。`);
}
const s1 = new Student('张三', 20, '男');
const s2 = new Student('李四', 18, '女');
</pre> 
<h4>三、ES6 中的类</h4> 
<p>ES6 中，新增了 class 用来创建类。</p> 
<p>类constructor构造函数</p> 
<p><code>constructor()</code>方法是类的构造函数(默认方法) ,<code>用于传递参数返回实例对象</code>,通过new命令生成对象实例时,自动调用该方法。如果没有显示定义类内部会自动给我们创建一 个<code>constructor()</code></p> 
<pre>class Student {
    constructor(name, age, gender) {
        // 属性
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.major = "WEB前端";
    }
    // 方法
    sayHello() {
        console.log('hello');
    }
    introduce() {
        this.sayHello();
        console.log(`我叫${this.name}，性别${this.gender}，今年${this.age}岁。`);
    }
}
const s1 = new Student('张三', 20, '男');
const s2 = new Student('李四', 18, '女');
s1.introduce() ;
s2.introduce() ;
</pre> 
<p>注意点：</p> 
<p>1.在ES6中类没有变量提升,所以必须先定义类,才能通过类实例化对象 2.类里面的共有属性和方法一定要加this使用. 3.类里面的this指向问题.</p> 
<ol><li> <p>constructor 里面的this指向实例对象,方法里面的this指向这个方法的调用者</p> </li></ol> 
<h2>14 -《原型和原型链》</h2> 
<h4>一、原型</h4> 
<p>1、prototype</p> 
<p>JavaScript 中每一个函数身上都有一个 <code>prototype</code> 的属性，称为“原型”。</p> 
<pre>function Person() { }
console.log(Person.prototype);
</pre> 
<p>2、<strong>proto</strong></p> 
<p>JavaScript 中每一个对象身上都有一个 <code>__proto__</code> 的属性，称为“隐式原型”。</p> 
<pre>function Person() {
    
}
const p = new Person();
console.log(p.__proto__);
</pre> 
<p>3、原型和隐式原型</p> 
<p><strong>每一个对象的隐式原型，都指向创建该对象的函数的原型。</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c5/92/dlFynOCQ_o.png"></p> 
<h4>二、原型链</h4> 
<p>由对象的 <code>__proto__</code> 和创建该对象的函数的 <code>prototype</code> 组成的链条，称为“原型链”。</p> 
<p>原型链的作用，当我们访问一个的实例对象身上不存在的属性或方法时，解析器就会沿着原型链，到对应的函数的原型身上去进行查找。</p> 
<p>示例代码：</p> 
<pre>function Person() {
    this.name = "张三";
}
Person.prototype.sayHello = function() {
    console.log('hello');
}
const p = new Person();
console.log(p.name);
p.sayHello();
</pre> 
<p>图示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/20/36/0boQtjx2_o.png"></p> 
<h2>15 -《this 指向汇总》</h2> 
<ul><li> <p>全局的 this：window 对象</p> </li><li> <p>普通函数中 this：window 对象，因为时window调用的函数</p> </li><li> <p>回调函数中的 this：window 对象</p> </li><li> <p>对象方法中的 this：调用该方法的对象</p> </li><li> <p>事件处理函数中的 this：绑定事件的元素节点</p> </li><li> <p>面向对象中的 this：new 出来的实例对象</p> </li><li> <p>箭头函数中的 this：所在上下文中（父级）的 this</p> </li></ul> 
<h4>1、指向 window 对象</h4> 
<pre>// 全局
console.log(this);
// 普通函数
function foo() {
    console.log(this);
}
foo();
// 回调函数
setTimeout(function () {
    console.log(this);
}, 1000)
</pre> 
<h4>2、指向调用方法的对象</h4> 
<pre>// 对象的方法
const student = {
    type: '学生',
    show: function () {
        console.log(this);
    }
}
const teacher = {
    type: '老师'
}
teacher.show = student.show;
student.show();    // student
teacher.show();    // teacher
</pre> 
<h4>3、指向绑定事件的元素</h4> 
<pre>const box = document.getElementById('box');
box.onclick = function (event) {
    // console.log(event.target);
    console.log(this);  // box 节点
}
</pre> 
<h4>4、指向 new 出来的实例对象</h4> 
<pre>function Person() {
    console.log(this);
}
Person.prototype.sayHello = function () {
    console.log(this);
}
new Person();
class Animal {
    constructor() {
        console.log(this);
    }
    sayHello() {
        console.log(this);
    }
}
new Animal();
</pre> 
<h4>5、箭头函数的 this</h4> 
<p>箭头函数中没有 this，因此，如果我们要在箭头函数中使用 this，实际上使用是箭头函数所在上下文（父级）中的 this。</p> 
<p>上下文的划分，是根据函数来的。函数内的就是局部上下文，函数外的就是全局上下文。</p> 
<pre>const student = {
    type: '学生',
    show: () =&gt; {
        console.log(this);
        var foo = () =&gt; {
            console.log(this);
        }
        foo();
    }
}
student.show();
</pre> 
<h4>二、改变 this 指向</h4> 
<p>JS 中提供了三种方法来改变 this 的指向：</p> 
<ul><li> <p>call：改变 this 指向的同时立即执行函数；call 的参数依次传递即可；</p> </li><li> <p>apply：改变 this 指向的同时立即执行函数；apply 的参数需要以数组的形式传递；</p> </li><li> <p>bind：改变 this 指向后返回一个新的函数（不会立即执行该函数）；bind 的参数后续调用时依次传递即可；</p> </li></ul> 
<pre>const student = {
    type: '学生',
    show: function (a, b) {
        console.log(this);
        console.log(a, b);
    }
}
const teacher = {
    type: '老师'
}
// 正常调用
student.show(1, 2);
// call()
student.show.call(teacher, 1, 2);
// apply()
student.show.apply(teacher, [1, 2]);
// bind()
// const show = student.show.bind(teacher);
// show();
student.show.bind(teacher)(1, 2);
</pre> 
<p><code>在实际开发中</code>，大部分时候，如果this不是我们想要的指向，通常我们来说我们都希望它可以指向父级。这种情况下，我们优先考虑使用<code>箭头函数</code>来改变this的指向。</p> 
<h2>16 -《继承》</h2> 
<p>面向对象有大三特性：</p> 
<ol><li> <p>封装：将属性和方法添加到类中，这个过程就可以叫做面向对象的封装；</p> </li><li> <p>继承：子类可以拥有父类身上所有的属性和方法，同时子类还可以拥有自己的属性和方法；</p> </li><li> <p>多态：一个实例对象在不同情形下可以有多种状态；</p> </li></ol> 
<h4>一、ES5 的继承</h4> 
<pre>// 父类
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.sayHello = function () {
    console.log('hello');
}
// 子类
function Student(name, age) {
    // 父类属性的继承
    Person.call(this, name, age);
}
// 父类方法的继承
Student.prototype = new Person();
const child = new Student("张三", 20);
console.log(child);
child.sayHello();
</pre> 
<h4>二、ES6 的继承</h4> 
<pre>// 父类
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayHello() {
        console.log('hello');
    }
}
// 子类
class Student extends Person {
    constructor(name, age) {
        super(name, age);
    }
}
const child = new Student('张三', 20);
console.log(child);
child.sayHello();
</pre> 
<p>扩展：super</p> 
<pre>// 利用super调用父级的consructor
class F{
            constructor(x,y){
                this.x = x
                this.y =y
            }
            sum (){
                console.log(this.x +this.y);
            }
        }
        class S extends F{
            constructor(x,y){
                super(x,y)
            }
        }
        var son = new S(1,2)
        var son1 = new S(11,21)
        son.sum() //3
        son1.sum() //32
</pre> 
<p></p> 
<pre>// 利用super调用父级sum方法
class Father{
            constructor(x,y){
                this.x = x
                this.y = y
            }
            sum (){
                console.log(this.x + this.y);
            }
        }
        class Son extends Father{
            constructor(x,y){
                //  super必须放在最前面
                super(x,y)
                this.x =x
                this.y = y
            }
            deCreate(){
                console.log(this.x -this.y);
            }
        }
        var son = new Son(5,2)
        son.deCreate()
	// 因为Son通过extends和super继承了Father的sum方法，所以可以调用Father的sum
        son.sum()
</pre> 
<p></p> 
<h2>17 -《定义对象属性》</h2> 
<p>除了传统的通过点运算符 <code>.</code> 定义对象属性外，JS 中还提供了一个 <code>Object.defineProperty()</code> 方法来定义对象的属性。</p> 
<h4>一、基础语法</h4> 
<pre>Object.defineProperty(对象, '键名', {
    // ... 其他配置
})
</pre> 
<h4>二、控制数据权限</h4> 
<p>传统的对象的属性，都可以任意进行修改、删除、遍历的操作。而通过 <code>Object.defineProperty()</code> 定义的属性，我们可以自己来控制数据的操作权限。</p> 
<p>例如，我们给 <code>person</code> 对象添加一个 name 属性：</p> 
<pre>const person = { age: 22 };
Object.defineProperty(person, 'name', {
    value: '李四',
});
</pre> 
<p>通过以上方式添加的 name 属性，默认情况下，不能删除、不能修改、不能遍历。</p> 
<p>但是我们可以再设置以下三个属性，来更改 name 的操作权限：</p> 
<pre>const person = { age: 22 };
Object.defineProperty(person, 'name', {
    value: '李四',
    configurable: true,  // 可以删除
    writable: true,  // 可以修改
    enumerable: true,  // 可以遍历
});
</pre> 
<h4>三、检测数据操作</h4> 
<p><code>Object.defineProperty()</code> 还可以给对象的属性添加 get 和 set 方法：</p> 
<pre>const person = { age: 22 }
let age = person.age;
Object.defineProperty(person, 'age', {
    // 只要访问 person.name，就会自动触发 get 方法
    get() {
        return age;
    },
    // 只要修改 person.name，就会自动触发 set 方法
    set(value) {
        // console.log('value', value);
        age = value;
    }
});
// console.log(person.age);  // 22
person.age = 30;
console.log(person.age); // 30
</pre> 
<h2>18 -《深拷贝和浅拷贝》</h2> 
<p>深拷贝和浅拷贝，都只针对引用类型的数据。</p> 
<ul><li> <p>浅拷贝：当一个变量的数据拷贝到另一个变量身上后，只要拷贝后的数据中有任意一条数据的地址没有发生改变，都属于“浅拷贝”；</p> </li><li> <p>深拷贝：当一个变量的数据拷贝到另一个变量身上后，所有数据的地址都发生了改变，就属于“深拷贝”；</p> </li></ul> 
<h4>一、浅拷贝</h4> 
<p>1、扩展运算符</p> 
<pre>const student = { name: '张三', age: { num: 20 } };
// 浅拷贝
const newStudent = {...student};
</pre> 
<p>2、Object.assign()</p> 
<pre>const student = { name: '张三', age: { num: 20 } };
// 浅拷贝
const newStudent = Object.assign({}, student);
// student.name = '李四';
student.age.num = 30;
console.log(newStudent);
</pre> 
<h4>二、深拷贝（面试多）</h4> 
<p>1、JSON 对象的方法</p> 
<pre>const student = { name: '张三', age: { num: 20 } };
// 深拷贝
const newStudent = JSON.parse(JSON.stringify(student));
student.age.num.a = 30;
console.log(newStudent);
</pre> 
<p>2、手写函数实现深拷贝</p> 
<pre>const student = { name: '张三', age: { num: 20 } };
function deepClone(data) {
    if (typeof data === 'object') {
        const newData = {};
        for (const key in data) {
            newData[key] = deepClone(data[key]);
        }
        return newData;
    }
    return data;
}
const newStudent = deepClone(student);
</pre> 
<p>3.借助第三方JS库：jQuery、lodash</p> 
<p>lodash深克隆<code>_.cloneDeep(value)</code></p> 
<p>这个方法类似<a href="https://www.lodashjs.com/docs/lodash.cloneDeep#clone" rel="nofollow" title="_.clone">_.clone</a>，除了它会递归拷贝 <code>value</code>。（注：也叫深拷贝）。</p> 
<p>参数</p> 
<ol><li> <p><code>value</code> <em>(*)</em>: 要深拷贝的值。</p> </li></ol> 
<p>返回</p> 
<p><em>(*)</em>: 返回拷贝后的值。</p> 
<p>例子</p> 
<pre>var objects = [{ 'a': 1 }, { 'b': 2 }];
 
var deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// =&gt; false
</pre> 
<p></p> 
<p>扩展lodash常用api：</p> 
<p>一、数组：</p> 
<p>1.<code>_.chunk(array, [size=1])</code></p> 
<p>将数组（array）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果<code>array</code> 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。</p> 
<p>参数:</p> 
<ol><li> <p><code>array</code> <em>(Array)</em>: 需要处理的数组</p> </li><li> <p><code>[size=1]</code> <em>(number)</em>: 每个数组区块的长度</p> </li></ol> 
<pre>_.chunk(['a', 'b', 'c', 'd'], 2);
// =&gt; [['a', 'b'], ['c', 'd']]
 
_.chunk(['a', 'b', 'c', 'd'], 3);
// =&gt; [['a', 'b', 'c'], ['d']]
</pre> 
<p>2.<code>_.compact(array)</code></p> 
<p>创建一个新数组，包含原数组中所有的非假值元素。例如<code>false</code>, <code>null</code>,<code>0</code>, <code>""</code>, <code>undefined</code>, 和 <code>NaN</code> 都是被认为是“假值”。</p> 
<p>参数:</p> 
<ol><li> <p><code>array</code> <em>(Array)</em>: 待处理的数组</p> </li></ol> 
<pre>_.compact([0, 1, false, 2, '', 3]);
// =&gt; [1, 2, 3]
</pre> 
<p>3.<code>_.concat(array, [values])</code></p> 
<p>创建一个新数组，将<code>array</code>与任何数组 或 值连接在一起。</p> 
<p>参数</p> 
<ol><li> <p><code>array</code> <em>(Array)</em>: 被连接的数组。</p> </li><li> <p><code>[values]</code> <em>(...*)</em>: 连接的值。</p> </li></ol> 
<pre>var array = [1];
var other = _.concat(array, 2, [3], [[4]]);
 
console.log(other);
// =&gt; [1, 2, 3, [4]]
 
console.log(array);
// =&gt; [1]

</pre> 
<p>4.<code>_.difference(array, [values])</code></p> 
<p>创建一个具有唯一<code>array</code>值的数组，每个值不包含在其他给定的数组中。（注：即创建一个新数组，这个数组中的值，为第一个数字（<code>array</code> 参数）排除了给定数组中的值。）该方法使用<a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero" rel="nofollow" title="SameValueZero">SameValueZero</a>做相等比较。结果值的顺序是由第一个数组中的顺序确定。</p> 
<p>参数</p> 
<ol><li> <p><code>array</code> <em>(Array)</em>: 要检查的数组。</p> </li><li> <p><code>[values]</code> <em>(...Array)</em>: 排除的值。</p> </li></ol> 
<pre>_.difference([3, 2, 1], [4, 2]);
// =&gt; [3, 1]
</pre> 
<p>5.<code>_.indexOf(array, value, [fromIndex=0])</code></p> 
<p>使用<a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero" rel="nofollow" title="SameValueZero">SameValueZero</a> 等值比较，返回首次 <code>value</code> 在数组<code>array</code>中被找到的 索引值， 如果 <code>fromIndex</code> 为负值，将从数组<code>array</code>尾端索引进行匹配。</p> 
<p>6.<code>_.join(array, [separator=','])</code></p> 
<p>将 <code>array</code> 中的所有元素转换为由 <code>separator</code> 分隔的字符串。</p> 
<p>7.<code>_.last(array)</code></p> 
<p>获取<code>array</code>中的最后一个元素。</p> 
<p>8.<code>_.remove(array, [predicate=_.identity])</code></p> 
<p>移除数组中<code>predicate</code>（断言）返回为真值的所有元素，并返回移除元素组成的数组。<code>predicate</code>（断言） 会传入3个参数： <em>(value, index, array)</em>。</p> 
<p>9.<code>_.slice(array, [start=0], [end=array.length])</code></p> 
<p>裁剪数组<code>array</code>，从 <code>start</code> 位置开始到<code>end</code>结束，但不包括 <code>end</code> 本身的位置。</p> 
<p>10.<code>_.uniq(array)</code></p> 
<p>创建一个去重后的<code>array</code>数组副本。使用了<a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero" rel="nofollow" title="SameValueZero">SameValueZero</a> 做等值比较。只有第一次出现的元素才会被保留。</p> 
<p>...</p> 
<p>二、对象</p> 
<p>1.<code>_.assign(object, [sources])</code></p> 
<p>分配来源对象的可枚举属性到目标对象上。 来源对象的应用规则是从左到右，随后的下一个对象的属性会覆盖上一个对象的属性。</p> 
<p>2.<code>_.findKey(object, [predicate=_.identity])</code></p> 
<p>这个方法类似<a href="https://www.lodashjs.com/docs/lodash.findKey#find" rel="nofollow" title="_.find">_.find</a> 。 除了它返回最先被 <code>predicate</code> 判断为真值的元素 key，而不是元素本身。</p> 
<p>...</p> 
<h2>19 -《同步和异步》</h2> 
<h4>一、同步和异步的概念</h4> 
<p>在代码中，同步，指的是在同一个时间段内只能做一件事情，如果上一件事情没有做完，下一件事情只能处于等待状态。异步，指的是在同一个时间段内可以同时处理多件事情，如果上一件事情没有做完，不会影响到下一件事情的处理。</p> 
<p>同步和异步的概念，对应到代码中来，同步代码必须从上往下依次执行，上一段代码没有执行完，下一段代码就只能等待。异步代码，可以同时执行多段异步代码，上一段异步代码没有执行完，并不会影响到后面代码的执行。</p> 
<h4>二、JavaScript 中的同步和异步</h4> 
<p>JavaScript 是一门单线程语言。单线程，就意味着 JavaScript 永远都不可能在同一个时间段内同时执行多段代码。</p> 
<p>因此，JavaScript 中的异步，跟传统的异步有一些区别：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e5/ad/oCRpYnxH_o.png"></p> 
<p>JS 引擎会按照代码的书写顺序，从上往下依次执行所有的同步代码，一旦在执行过程中遇到异步代码，会将异步代码添加到任务队列中进行等待（会先启动异步代码，但是会将异步代码的回调函数添加到任务队列中进行等待）。直到所有的同步代码执行完成后，会将任务队列中出结果的异步回调重新放到主线程中来继续执行。</p> 
<h2>20 -《AJAX》</h2> 
<p>AJAX 的全称是“Asynchronous JavaScript and XML”，翻译过来就是“异步的 JS 和 XML”。</p> 
<ul><li> <p>Asynchronous：异步的，表示 AJAX 是一个异步代码，不会阻塞后面代码的执行；</p> </li><li> <p>JavaScript：使用 JavaScript 来实现前端（浏览器）和后端（服务器）的通信；</p> </li><li> <p>XML：XML 是一种数据格式，但是现在慢慢被 JSON 格式的数据替代了；</p> </li></ul> 
<p>AJAX 的核心就是：</p> 
<ul><li> <p>实现前端和后端的异步通信；</p> </li><li> <p>实现前端页面的局部刷新；</p> </li></ul> 
<h4>原生 AJAX 的使用步骤</h4> 
<pre>// 第一步：创建核心对象
const xhr = new XMLHttpRequest();
// 第二步：建立前后端的连接
xhr.open('GET', 'http://nocat.life:3000/students/getStudents');
// 第三步：发送请求
xhr.send();
// 第四步：处理后端返回的结果
// onreadystatechange：当 readystate 的值发生改变时会触发该事件
xhr.onreadystatechange = function () {
    // readyState == 4 表示后端处理完成了
    // status == 200 表示后端处理成功了
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        // responseText 接收到的就是后端传输给前端的数据
        console.log(JSON.parse(xhr.responseText));
    }
}
</pre> 
<h4>jQuery的AJAX</h4> 
<pre>$.ajax({
    type: 'GET',                                         // 请求类型
    url: 'http://nocat.life:3000/students/getStudents',  // 请求资源的路径
    // data: {},                                         // 前端发送给后端的数据
    success(res) {                                       // 请求成功时执行的回调函数
        console.log(res);                                // 后端传输给前端的数据
    }
})
</pre> 
<p></p> 
<p></p> 
<h2>21 -《Promise》**</h2> 
<p>Promise 是 ES6 中新增的一种异步代码解决方案。</p> 
<h4>一、回调地狱</h4> 
<p>由于一些业务需求，导致我们的 AJAX 等异步代码需要嵌套编写，这样就会行为回调函数之间的不断嵌套，从而出现回调地狱的情况。</p> 
<p>因此，ES6 中新增了 Promise，就是为了解决回调地狱的问题。</p> 
<h4>二、基础语法</h4> 
<pre>const p = new Promise((resolve, reject) =&gt; {
    // 异步代码成功 
    // resolve();
    // 异步代码失败
    // reject();
});
</pre> 
<p>1、Promise 的状态</p> 
<p>Promise 对象有三种状态，它们分别是：</p> 
<ul><li> <p>pending: 等待中，或者进行中，表示还没有得到请求结果；</p> </li><li> <p>fulfilled: 已成功，表示得到了我们想要的结果，可以继续往下执行；</p> </li><li> <p>rejected: 已失败，虽然也已经完成，但是由于结果不是我们想要的，因此拒绝继续执行；</p> </li></ul> 
<p>当 Promise 开始执行时，状态默认为“pending”，例如：</p> 
<pre> const p = new Promise((resolve, reject) =&gt; {
 })
 console.log(p);   // Promise {&lt;pending&gt;}
</pre> 
<p>当 resolve 方法被调用时，状态从“pending”变成“fulfilled”，例如：</p> 
<pre> const p = new Promise((resolve, reject) =&gt; {
     resolve();
 })
 console.log(p);   // Promise {&lt;fulfilled&gt;: undefined}
</pre> 
<p>当 reject 方法被调用时，状态从“pending”变成“rejected”，同时抛出报错。例如：</p> 
<pre> const p = new Promise((resolve, reject) =&gt; {
     reject();
 })
 console.log(p);   // Promise {&lt;rejected&gt;: undefined}
</pre> 
<p>注意：Promise 的状态只能从 pending 变成 fulfilled，或者从 pending 变成 rejected 这两种情况。</p> 
<p>2、Promise 的 then 方法</p> 
<p>每一个 Promise 实例对象身上都有一个 <code>then</code> 方法，该方法带有两个参数，分别是：</p> 
<ol><li> <p>resolve 调用时触发的回调函数</p> </li><li> <p>reject 调用时触发的回调函数</p> </li></ol> 
<p>示例代码如下：</p> 
<pre> const p = new Promise((resolve, reject) =&gt; {
     resolve();
     // reject();
 })
 p.then(() =&gt; {
     console.log('成功时触发');
 }, () =&gt; {
     console.log('失败时触发');
 })
</pre> 
<p>3、Promise 中的数据传递</p> 
<p>resolve 方法和 reject 方法在触发对应的回调函数的同时，还可以传递数据到回调函数中。</p> 
<p>示例代码如下：</p> 
<pre> const p = new Promise((resolve, reject) =&gt; {
     resolve(1);
     // reject(2);
 })
 p.then((data) =&gt; {
     console.log('成功时触发', data);
 }, (error) =&gt; {
     console.log('失败时触发', error);
 })
</pre> 
<h4>三、Promise 的其他方法</h4> 
<p>1、catch</p> 
<p>Promise 的 catch 方法，实际上就是 then 方法中第二个回调函数的另一种写法：</p> 
<pre> const p = new Promise((resolve, reject) =&gt; {
     resolve(1);
     // reject(2);
 })
 p.then((data) =&gt; {
     console.log('成功时触发', data);
 }).catch(() =&gt; {
     console.log('失败时触发', error);
 })
</pre> 
<p>2、all</p> 
<p><code>Promise.all()</code> 可以接收一个数组作为参数，数组中保存的是 Promise 的实例对象。</p> 
<pre>const p1 = new Promise((resolve, reject) =&gt; {
    resolve(1);
})
const p2 = new Promise((resolve, reject) =&gt; {
    resolve(2);
})
Promise.all([p1, p2]).then((data) =&gt; {
    console.log(data);
})
</pre> 
<p>以上代码表示，只有当 p1 和 p2 两个实例对象的状态都变为”成功”，才会执行 then 方法中的第一个回调函数。</p> 
<p>示例代码：</p> 
<pre>const a = new Promise((resolve, reject) =&gt; {
    $.ajax({
        url: 'http://nocat.life:3000/test/a',
        success(res) {
            resolve(res);
        }
    })
})
const b = new Promise((resolve, reject) =&gt; {
    $.ajax({
        url: 'http://nocat.life:3000/test/b',
        success(res) {
            resolve(res);
        }
    })
})
Promise.all([a, b]).then((res) =&gt; {
    console.log(res);
})
</pre> 
<p>3、race</p> 
<p><code>Promise.race()</code> 可以接收一个数组作为参数，数组中保存的是 Promise 的实例对象。</p> 
<pre>const p1 = new Promise((resolve, reject) =&gt; {
    resolve(1);
})
const p2 = new Promise((resolve, reject) =&gt; {
    resolve(2);
})
Promise.race([p1, p2]).then((data) =&gt; {
    console.log(data);
})
</pre> 
<p>以上代码表示，只要 p1 和 p2 中任意一个实例对象的状态变为了”成功”，就会执行 then 方法中的第一个回调函数。</p> 
<h2>22 -《async 和 await》*</h2> 
<p>async 和 await，是 ES8 中提供的异步的最终解决方案。</p> 
<h4>一、async</h4> 
<p>async 可以用来定义一个异步函数，async 函数本身并不是一个异步代码，而是这个函数内部可以用来处理异步代码。</p> 
<p>基础语法：</p> 
<pre>async function foo() {
}
foo();
const bar = async function() {
}
bar();
</pre> 
<p>async 函数和普通函数的区别：</p> 
<ol><li> <p>async 函数的返回值永远都是一个 Promise 对象；</p> </li><li> <p>async 函数内部可以使用 await；</p> </li></ol> 
<h4>二、await</h4> 
<p>await 用来等待一个异步处理结果，通常我们会用 await 来接收一个 Promise 对象中 resolve 的结果。</p> 
<p>基础语法：</p> 
<pre>const res = await new Promise((resolve) =&gt; {
    resolve(res);
});
console.log(res);
</pre> 
<p>await 的特点：</p> 
<ul><li> <p><strong>await 只能在 async 函数中使用</strong>。</p> </li><li> <p>await 会阻塞当前 async 函数中后续代码的执行；</p> </li></ul> 
<p>因此，上面的代码，完整的写法应该如下：</p> 
<pre>async function main() {
    const res = await new Promise((resolve) =&gt; {
        resolve(res);
    });
    console.log(res);
}
main();
</pre> 
<h4>三、代码案例</h4> 
<pre>function getTestA() {
    return new Promise((resolve) =&gt; {
        $.ajax({
            url: 'http://nocat.life:3000/test/a',
            success(res) {
                resolve(res);
            }
        })
    })
}
function getTestB() {
    return new Promise((resolve) =&gt; {
        $.ajax({
            url: 'http://nocat.life:3000/test/b',
            success(res) {
                resolve(res);
            }
        })
    })
}
function getTestC() {
    return new Promise((resolve) =&gt; {
        $.ajax({
            url: 'http://nocat.life:3000/test/c',
            success(res) {
                resolve(res);
            }
        })
    })
}
// 返回值是一个 Promise 对象
async function main() {
    const resA = await getTestA();
    console.log(resA);
    const resB = await getTestB();
    console.log(resB);
    const resC = await getTestC();
    console.log(resC);
}
main();
</pre> 
<pre>	//学生数据渲染

 &lt;body&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;学生姓名&lt;/th&gt;
                &lt;th&gt;学生年龄&lt;/th&gt;
                &lt;th&gt;学生性别&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody id="studentsList"&gt;&lt;/tbody&gt;
    &lt;/table&gt;

    &lt;select id="students"&gt;&lt;/select&gt;

    &lt;script src="../utils/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 获取学生数据
        function getStudents() {
            return new Promise((resolve) =&gt; {
                $.ajax({
                    url: 'http://nocat.life:3000/students/getStudents',
                    type: 'GET',
                    success(res) {
                        if (res.code) {
                            resolve(res.data.rows);
                        }
                    }
                })
            })
        }

        // 将学生数据渲染成 table
        function tableRender(studentsData) {
            const studentsHTML = studentsData.map(item =&gt; {
                return (
                    `&lt;tr&gt;
                        &lt;td&gt;${item.name}&lt;/td&gt;    
                        &lt;td&gt;${item.age}&lt;/td&gt;    
                        &lt;td&gt;${item.gender}&lt;/td&gt;    
                    &lt;/tr&gt;`
                )
            }).join('');
            $('#studentsList').html(studentsHTML)
        }

        // 将数据渲染成 select
        function selectRender(studentsData) {
            const studentsHTML = studentsData.map(item =&gt; `&lt;option value=""&gt;${item.name}&lt;/option&gt;`).join('');
            $('#students').html(studentsHTML);
        }


        async function main() {
            const studentsData = await getStudents();
            tableRender(studentsData);
            selectRender(studentsData)
        }
        main();
    &lt;/script&gt;
&lt;/body&gt;
</pre> 
<h2>复习</h2> 
<h4>一、ES6</h4> 
<p>1、let、const</p> 
<pre>let a = 1;
const arr = [1, 2, 3];
arr.push(4);   		  // 正确
arr = [1, 2, 3, 4];   // 报错
</pre> 
<p>注意：const 创建的变量如果值是引用类型的数据，只要数据的地址没有发生改变，const 都不会报错。</p> 
<p>2、模板字符串</p> 
<pre>const name = "张三";
const str = `你好，${name}`;
</pre> 
<p>说明：在 <code>${}</code> 中可以设置任意 JS 表达式。</p> 
<p>如何去分析一段 JS 代码是不是 JS 表达式，就看这段代码执行完成后，会不会得到一个最终的值。</p> 
<pre>// 不可以
if(true) {
    console.log('hello')
}
</pre> 
<pre>const arr = [1, 2, 3];

// 可以
arr.map(function(item, index) {
    return item * 2;
}).join("");
</pre> 
<pre>// 可以
true ? 'hello' : 'world';
</pre> 
<p>3、symbol（了解）</p> 
<p>symbol 可以用来创建一个唯一值。</p> 
<pre>const s1 = Symbol();
const s2 = Symbol();
console.log(s1 === s2);  // false
</pre> 
<p>通常会用 symbol 值来作为对象的键。</p> 
<p>4、函数相关</p> 
<p>1）箭头函数</p> 
<p><strong>基础语法：</strong></p> 
<pre>const foo = function() {
    
}

const foo = () =&gt; {
    
}

arr.map(() =&gt; {
    
})

setTimeout(() =&gt; {}, 1000)
</pre> 
<p><strong>简写：</strong></p> 
<p>箭头函数的简写分为两种情况：</p> 
<ul><li> <p>当只有一个形参时，参数的小括号可以省略不写；</p> </li><li> <p>当函数体内，有且仅有一行 return 语句时，可以将 return 和大括号一起省略；</p> </li></ul> 
<pre>// 省略小括号
const foo = x =&gt; {
    console.log(x);
}
</pre> 
<pre>// 省略 return 和 {}
const foo = (x, y) =&gt; {
    return x + y;
}
// 简写
const foo = (x, y) =&gt; x + y;


// 返回值是一个对象
const foo = (x, y) =&gt; {
    return { name: '张三' };
}
// 简写
const foo = (x, y) =&gt; ({ name: '张三' });


// 返回值内容需要换行
const foo = () =&gt; {
    return (
    	`&lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;`
    )
}
// 简写
const foo = () =&gt; (
    `&lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
     &lt;/tr&gt;`
)
</pre> 
<p><strong>箭头函数中的 this：</strong></p> 
<p>箭头函数中没有 this，如果我们需要在箭头函数中使用 this，实际上使用的是该箭头函数所在父级中的 this。</p> 
<p>因此，如果当我们看到一个代码是在箭头函数中使用 this 时，需要分析两件事：</p> 
<ol><li> <p>该箭头函数所在的父级是谁（箭头函数在哪个函数中创建的，谁就是它的父级）；</p> </li><li> <p>父级的 this 指向谁；</p> </li></ol> 
<p>2）函数形参的默认值</p> 
<pre>function foo(x = 1) {
    console.log(x);  // 1
}
foo();
</pre> 
<p>3）不定参数</p> 
<pre>function foo(a, ...b) {
    console.log(a);   // 1
    console.log(b);   // [2, 3, 4]
}
foo(1, 2, 3, 4)
</pre> 
<p>5、解构赋值</p> 
<p>数组的解构赋值：</p> 
<pre>const arr = [1, 2, 3];
const [a, b, c] = arr;
console.log(a, b, c);
</pre> 
<p>对象的解构赋值：</p> 
<pre>const obj = { a: 1, b: 2, c: 3 };
const { a: a, b: b } = obj;
// 简写
const { a, b } = obj;
</pre> 
<p>6、扩展运算符</p> 
<p>扩展运算符，用来将一条数据展开，我们通常会用于：</p> 
<p>引用类型数据的复制，同时复制后创建一个新的地址：</p> 
<pre>const arr = [1, 2, 3];
const newArr = [...arr];
</pre> 
<p>想要给引用类型的数据中添加内容，同时添加完后创建一个新的地址：</p> 
<pre>let arr = [1, 2, 3];
arr = [...arr, 4];

let obj = { a: 1, b: 2 };
obj = {
    ...obj,
    c: 3
}
</pre> 
<p>7、class 类</p> 
<p>创建类：</p> 
<pre>class Person {
    constructor(name) {
        this.name = name;
    }
    sayHello() {
        console.log('hello')
    }
}
</pre> 
<p>调用类：</p> 
<pre>const zhangsan = new Person('张三');
</pre> 
<p>说明：类内部的 this，指向的是在调用时通过 new 得到的实例对象（上例中的 <code>zhangsan</code>）。</p> 
<p>子类继承父类：</p> 
<pre>class Father {
    // ...
}

class Child extends Father {
    constructor(name) {
        super(name);
    }
}
</pre> 
<p>8、对象的简写</p> 
<p>ES6 中针对对象的属性，有两种简写形式：</p> 
<ol><li> <p>当值是一个变量，且键和值是同一个单词时，可以省略键和冒号 <code>键:</code>；</p> </li><li> <p>当值是一个函数时，可以省略冒号和 function <code>: function</code> ；</p> </li></ol> 
<pre>const name = '张三';
const age = 20;
const student = {
    name: name,
    age: age
}
// 简写
const student = {
    name, 
    age
}


const student = {
    say: function() {
        console.log('hello')
    }
}
// 简写
const student = {
    say() {
        console.log('hello')
    }
}
</pre> 
<p>9、前端模块化</p> 
<p>1）暴露</p> 
<p>暴露一条：</p> 
<pre>export default 一条数据;
</pre> 
<p>暴露多条：</p> 
<pre>export 数据;
export 数据;
// ...
</pre> 
<p>2）引入</p> 
<p>引入 <code>export default</code>：</p> 
<pre>import 任意变量名 from '路径';
</pre> 
<p>引入 <code>export</code>：</p> 
<pre>import { 对应的变量名一, 对应的变量名二 } from '路径';
</pre> 
<p>10、Promise</p> 
<pre>new Promise((resolve, reject) =&gt; {
    // 异步代码
    resolve(数据);
}).then((数据) =&gt; {
    
})
</pre> 
<p>11、async await</p> 
<p>1）async</p> 
<p>async 用来定义一个异步函数：</p> 
<pre>async function foo() {
    return 1;
}
</pre> 
<p>异步函数和普通函数的区别：</p> 
<ol><li> <p>异步函数的返回值永远都是 Promise 对象（如果想要获取到异步函数真正的返回值，需要通过 await 等待 Promise 对象）；</p> </li><li> <p>异步函数内部可以使用 await；</p> </li></ol> 
<p>2）await</p> 
<p>await 用来等待一个 Promise 对象中 resolve 的结果。</p> 
<pre>async function foo() {
    const result = await new Promise((resolve) =&gt; {
        resolve('hello')
    });
    console.log(result);  // hello
}
</pre> 
<p>12、Set、Map（了解）</p> 
<p>Set 实现数组的去重：</p> 
<pre>const arr = [1, 2, 3, 1, 3, 4];

const newArr = [...new Set(arr)];
</pre> 
<p>Set 类似数组，区别在于 Set 中的值不能重复；</p> 
<p>Map 类似对象，区别在于 Map 的键可以是任意类型；</p> 
<h4>二、原理</h4> 
<p>1、变量提升和函数提升</p> 
<p>在代码执行之前，浏览器有一个“预解析”的过程。</p> 
<p>在这个过程中，会找到当前作用域中所有通过 var 声明的变量，然后将变量的声明提升到当前作用域头部，并赋值为 undefined。同时，还会找到所有的声明式函数，然后将整个函数声明提升到当前作用域头部。</p> 
<pre>console.log(a);
console.lg(foo);
foo();

var a = 1;
function foo() {
    console.log('foo');
}
</pre> 
<p>以上代码经过预解析后，可以看作是变成了以下形式：</p> 
<pre>var a = undefined;
function foo() {
    console.log('foo');
}
foo();

console.log(a);
console.log(foo);

a = 1;
</pre> 
<p></p> 
<p>2、基本类型和引用类型</p> 
<p>基本类型的数据值是保存在栈里面，引用类型的数据值是保存在堆里面。但是，引用类型数据的“引用地址”会保存在栈里面。</p> 
<p>所以，在对基本类型和引用类型的数据进行赋值的时候，基本类型是“值传递”，引用类型是“址传递”。</p> 
<p></p> 
<p>3、执行上下文</p> 
<p>执行上下文分为全局上下文和局部函数上下文。</p> 
<p>全局上下文是在浏览器打开页面时产生，而局部函数上下文是在函数<strong>调用</strong>时产生。</p> 
<p>每调用一次函数，都会产生一个对应的局部上下文。</p> 
<p></p> 
<p>4、变量对象</p> 
<p>在创建执行上下文的同时，在上下文内部会产生变量对象。</p> 
<p>变量对象在创建时，会做三件事情：</p> 
<ol><li> <p>找到当前上下文中所有的参数并保存；</p> </li><li> <p>找到当前上下文中所有的声明式函数并保存；</p> </li><li> <p>找到当前上下文中所有通过 var 声明的变量并保存同时赋值为 undefined；</p> </li></ol> 
<p></p> 
<p>5、作用域链</p> 
<p>作用域链的作用，可以理解为：当在自己的作用域找访问一个不存在的数据时，就可以沿着作用域链到父级的作用域中去查找。</p> 
<p>实际上，作用域链真正底层的原理，应该理解为：所有的数据都是保存在每一个执行上下文的变量对象中，因此，当在自己的变量对象中访问一个不存在的数据时，就可以沿着作用域链到父级的变量对象中去查找。</p> 
<p></p> 
<p>6、作用域</p> 
<p>作用域，指的是变量或函数的作用范围。</p> 
<p>作用域也分为了全局作用域和局部作用域，但是，局部作用域是在函数<strong>创建</strong>时就产生了。</p> 
<pre>function foo() {
    var a = 1;
}
console.log(a);
</pre> 
<p></p> 
<p>7、闭包</p> 
<p>概念：当一个函数的变量对象，在函数执行完成后，本来该销毁时，由于其他地方还需要访问该变量对象的数据，导致这个变量对象在应该销毁的时候没有销毁，从而形成了闭包。</p> 
<p>从代码层面上看，闭包形成的条件：</p> 
<ol><li> <p>两个函数之间形成嵌套；</p> </li><li> <p>内部函数在访问外部函数中的数据；</p> </li><li> <p>内部函数在创建该函数以外的其他地方被调用；</p> </li></ol> 
<p>闭包主要作用是延长变量的作用时间，避免全局变量的命名冲突，但是滥用闭包，会造成内存的浪费。</p> 
<p>说说你对闭包的理解？闭包使用场景</p> 
<p>闭包是指有权访问另⼀个函数作⽤域中变量的函数。（创建闭包的最常⻅的⽅式就是在⼀个函数内创建另⼀个函数，创建的函数可以访问到当前函数的局部变量。 ）</p> 
<p>闭包有两个常⽤的⽤途；</p> 
<p>● 闭包的第⼀个⽤途是使我们在函数外部能够访问到函数内部的变量。通过使⽤闭包，可以通过在外部调⽤闭包函数，从⽽在外部访问到函数内部的变量，可以使⽤这种⽅法来创建私有变量。</p> 
<p>● 闭包延伸了变量的作用范围。</p> 
<p>闭包的应⽤：</p> 
<p>1、模仿块级作⽤域。2、保存外部函数的变量。3、封装私有变量</p> 
<p>⽐如，函数 A 内部有⼀个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p> 
<pre>//闭包应用-3秒钟之后，打印所有1i元素的内容
var lis = document . querySelector( ' . nav' ) . querySelectorAll( 'li' );
for (var i = 0; i &lt; lis.length; i++) {
    (function(i) {           //立即执行函数
        setTimeout (function() {
            console . log(lis[i]. innerHTML);
            }, 3000)
        })(i);
    }
</pre> 
<p></p> 
<p>8、原型和原型链</p> 
<p>每一个对象，都有一个 <code>__proto__</code> 属性，指向构造该对象的函数的 <code>prototype</code>。</p> 
<pre>function Person() {
    
}
const p = new Person();
console.log(p.__proto__ === Person.prototype);
</pre> 
<p>原型链就是当我们访问一个实例对象身上不存在的属性或方法时，就可以沿着 <code>__proto__</code> 和 <code>prototype</code> 组成的链条，到对应的原型身上去查找。</p> 
<p></p> 
<p>9、new 关键字</p> 
<p>new 关键字做了哪四件事情：</p> 
<ol><li> <p>创建一个空对象；</p> </li><li> <p>将函数中的 this 指向空对象；</p> </li><li> <p>执行函数中的代码；</p> </li><li> <p>返回这个对象；</p> </li></ol> 
<p></p> 
<p>10、this 指向</p> 
<p>简单来说，this 的指向分为两种情况：</p> 
<ol><li> <p>函数外：全局，this 指向 window；</p> </li><li> <p>函数里：</p> 
  <ol><li> <p>箭头函数：指向箭头函数所在父级的 this；</p> </li><li> <p>非箭头函数：谁调用这个函数，this 就指向谁；</p> </li></ol></li></ol> 
<pre>function foo() {
    console.log(this);  // window
}

foo();

const obj = {
    sayHello() {
        console.log(this);
    }
}
obj.sayHello();  // obj


div.onclick = function() {
    console.log(this);   // div
}

class Person {
    sayHello() {
        console.log(this);
    }
}
const p = new Person();
p.sayHello()   // p
</pre> 
<p></p> 
<p>11、改变 this 指向</p> 
<ul><li> <p>call：在改变 this 指向的同时，会立即执行该函数；所有参数都依次传递即可；</p> </li><li> <p>apply：在改变 this 指向的同时，会立即执行该函数；所有参数都必须放在一个数组中进行传递；</p> </li><li> <p>bind：在改变 this 指向后，返回一个新的函数；调用新函数时正常传递参数即可；</p> </li></ul> 
<p>在实际开发中，大部分时候，如果 this 不是我们想要的指向，通常来说我们都希望它可以指向父级。这种情况下，我们优先考虑使用箭头函数来改变 this 的指向。</p> 
<p></p> 
<p>12、浅拷贝和深拷贝</p> 
<p>浅拷贝和深拷贝都只存在于引用类型中。</p> 
<ul><li> <p>浅拷贝：引用类型的数据在拷贝的过程中，只要有一条数据地址没有发生改变，都属于浅拷贝。</p> </li><li> <p>深拷贝：引用类型的数据在拷贝的过程中，所有引用类型的数据全都创建了新的地址，都属于深拷贝。</p> </li></ul> 
<p>实现浅拷贝的方式有：</p> 
<ul><li> <p>扩展运算符</p> </li><li> <p>Object.()</p> </li></ul> 
<p>实现深拷贝的方式有：</p> 
<ul><li> <p>JSON 对象的两个方法</p> </li><li> <p>手写递归函数</p> </li><li> <p>借助第三方 JS 库：jQuery、lodash</p> </li></ul> 
<p></p> 
<p>13、异步解决方案的发展</p> 
<ol><li> <p>回调函数</p> </li><li> <p>Promise</p> </li><li> <p>Generator</p> </li><li> <p>async await</p> </li></ol> 
<p></p> 
<p>14、AJAX 的工作步骤</p> 
<ol><li> <p>创建核心 XMLHttpRequest 对象</p> </li><li> <p>建立前后端的连接</p> </li><li> <p>发送请求</p> </li><li> <p>接收并处理后端返回的结果</p> </li></ol> 
<p></p> 
<p>15、Promise 三种状态</p> 
<ul><li> <p>等待中（进行中）</p> </li><li> <p>已成功：调用 resolve 方法，状态从“等待中”变为“已成功”；</p> </li><li> <p>已失败：调用 reject 方法，状态从“等待中”变为“已失败”；</p> </li></ul> 
<p></p> 
<h2>01 -《前端模块化》</h2> 
<p>模块化，指的就是将每一个 JS 文件都看作是一个模块。</p> 
<p>默认情况下，如果多个 JS 文件在同一个 HTML 中引入，他们是共享同一个全局作用域。</p> 
<p>从 ES6 开始，JS 里面原生支持模块化开发。每一个 JS 文件都是一个独立的模块，每一个 JS 文件都有一个自己独立的作用域，JS 与 JS 之间，互相不能进行数据的访问。</p> 
<h4>一、模块化</h4> 
<p>1、设置模块</p> 
<pre>&lt;script src="./js/a.js" type="module"&gt;&lt;/script&gt;
&lt;script src="./js/b.js" type="module"&gt;&lt;/script&gt;
</pre> 
<p>也可以引入一个index.js，只在它身上设置type='module'</p> 
<p>2、JS 中引入模块</p> 
<p>模块化的开发中，我们可以在一个 JS 文件中通过 <code>import</code> 引入另一个 JS 文件：</p> 
<pre>import 'JS文件的路径'
</pre> 
<p>注意：同级路径之间必须加 <code>./</code>。</p> 
<h4>二、暴露和引入</h4> 
<p>默认情况下，每一个模块之间是互相独立的，数据都是私有的。但是，我们可以通过暴露的方式，将模块内的数据共享出去，同时，通过引入的方式，获取到其他模块暴露出来的数据。</p> 
<p>1、暴露</p> 
<p>暴露的语法分为两种情况：</p> 
<ol><li> <p>只暴露一条数据：<code>export default 数据</code></p> </li><li> <p>暴露多条数据：<code>export 数据</code></p> </li></ol> 
<pre>const name = "张三";
export default name;
</pre> 
<p>2、引入</p> 
<p>根据暴露方式的不同，我们引入的语法也分为两种：</p> 
<ul><li> <p>引入 export default 暴露的数据：<code>import 任意变量名 from "JS文件路径"</code> <strong>常用</strong></p> </li><li> <p>引入 export 暴露的数据：<code>import { 暴露数据名称 } from 'JS文件的路径'</code></p> </li></ul> 
<pre>import b from './b.js'
console.log(b);

import { name, age, foo } from './b.js';
console.log('name', name);
console.log('age', age);
console.log('foo', foo);
</pre> 
<h4>三、引入(扩展)</h4> 
<p>1、重命名</p> 
<pre>import { name, age as newAge, foo } from './b.js';
const age = 30;
console.log(newAge);
</pre> 
<p>2、合并多条数据</p> 
<p>当我们要引入的模块中通过 <code>export</code> 暴露了很多条数据出来，我们引入时又想把所有暴露的数据全部拿到。这种情况下，如果还是按照暴露名称一一对应的方式来引入的话，就非常的不方便了。</p> 
<p>所以，ES6 的模块化中还提供了一种写法，可以在引入时将 <code>export</code> 暴露的所有数据合并到一个对象中：</p> 
<pre>import * as obj from './b.js'
console.log(obj);
</pre> 
<h2>02 -《webpack 准备工作》</h2> 
<p>webpack，是一个前端资源构建工具。</p> 
<p>webpack 可以实现的功能有：</p> 
<ol><li> <p>代码转换：将浏览器不能识别的代码，转换成浏览器能识别的代码，例如 sass 转换为 css；</p> </li><li> <p>代码合并：将多个分散的文件，根据代码逻辑，合并成一个文件；</p> </li><li> <p>压缩代码：将代码中不必要的注释、空格、换行以及变量名函数名进行处理；</p> </li><li> <p>…</p> </li></ol> 
<h4>一、准备工作</h4> 
<p>1、安装 Node.js</p> 
<p><a href="http://nodejs.cn/download/" rel="nofollow" title="下载 | Node.js 中文网">下载 | Node.js 中文网</a></p> 
<p>点击全部安装包</p> 
<p>根据自己电脑系统选择对应的版本进行安装，可以不安装在 C 盘。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/06/76/s5nUgEIf_o.png"></p> 
<p>win7用12.22.9的版本，</p> 
<p>其他的比较稳定的14，16的比较稳定，一般64位，</p> 
<p>msi结尾是一般电脑，pkg结尾的是苹果电脑。</p> 
<p>安装的时候，除了修改安装盘，其他的都下一步。</p> 
<p>2、npm</p> 
<p>Node.js Package Manager，Node.js 的包管理工具。</p> 
<pre>npm -v
</pre> 
<p>设置 npm 的淘宝镜像：</p> 
<pre>npm config set registry https://registry.npm.taobao.org
</pre> 
<h2>02-01npm优雅的卸载npm包</h2> 
<h2>windows系统切换node版本</h2> 
<p>首先下载nvm 下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" title="Releases · coreybutler/nvm-windows · GitHub">Releases · coreybutler/nvm-windows · GitHub</a> 或者 <a href="https://download.csdn.net/download/xiaofiy/85235297" title="https://download.csdn.net/download/xiaofiy/85235297">https://download.csdn.net/download/xiaofiy/85235297</a> 下载安装过程建议傻瓜式安装，直接安装到c盘</p> 
<p>使用nvm install 14/ nvm install 16 安装14版本和16版本的node（默认会安装最新最稳定版本），完成之后用nvm ls列出所有可管理的node版本，如下图：</p> 
<p>如果安装node失败，可以让同事将他的node文件发你，但是必须放在和nvm路径一样的文件夹里面，否则不能后续切换版本操作 查看nvm路径命令 ： nvm root</p> 
<p>切换使用node时，只需nvm use 版本号，指定当前使用的node版本，（此处以node版本16.14.2为例）。</p> 
<p>Node –v查看当前node版本，如下图所示即成功。</p> 
<p>常用nvm命令如下图所示：</p> 
<p>注意： node14+ : vue2.0项目和vue3.0项目都可以运行 node16+ : vue2.0项目运行失败。vue3.0项目可以运行 npm依赖下载必须使用不同版本（vue2.0项目使用14+，vue3.0项目使用16+），否则下载失败。</p> 
<p></p> 
<h2>03 -《项目初始化》</h2> 
<h4>一、创建项目</h4> 
<p>1、创建项目根目录文件</p> 
<p>我们自己创建一个空文件夹作为项目的根目录。文件名不要出现中文、大写字母，同时不要只用 webpack 命名。</p> 
<p>例如，我们要创建一个电影后台管理系统的项目，我们可以命名为“movies-system”。</p> 
<p>2、项目初始化</p> 
<p>将终端定位到项目根目录的路径，然后执行以下命令对项目进行初始化：</p> 
<pre> npm init -y</pre> 
<p>该命令执行完成后，会自动在项目的根目录中生成一个 <code>package.json</code> 文件，该文件是项目的描述文件。</p> 
<h4>二、下载 webpack</h4> 
<p>npm 中下载依赖包用到的命令都是 <code>npm install 包名称</code>。</p> 
<p>执行以下命令下载 webapck 和 webpack-cli：</p> 
<pre> npm i webpack webpack-cli -D</pre> 
<p>说明：</p> 
<ul><li> <p>下载时需要将终端定位到当前项目的根目录；</p> </li><li> <p>install 可以简写为 i；</p> </li><li> <p>如果一次性要下载多个依赖包，每个依赖包的名称之间用空格隔开；</p> </li><li> <p><code>-D</code> 表示当前下载的依赖包只在开发时使用。</p> </li></ul> 
<h4>三、运行 webpack</h4> 
<p>我们在项目根目录中创建一个 <code>src</code> 的目录，然后再在 <code>src</code> 中创建一个 <code>index.js</code>。</p> 
<p>在终端中执行以下命令（注意终端路径在项目根目录）：</p> 
<pre>npx webpack --mode=development
</pre> 
<p>执行完该命令后，会自动在项目根目录中生成一个 <code>dist</code> 目录，该目录中存放的就是项目代码编译后的新代码。</p> 
<h2>04 -《生产环境和开发环境》</h2> 
<p>在项目的开发过程中，我们会将项目分为开发阶段和生产阶段。因为在两个阶段中项目中用到的一些依赖包是不一样的，所以，我们会在 webpack 中针对两个阶段进行不同的配置。</p> 
<ul><li> <p>开发环境：development，指的是项目在开发过程中需要用的一个配置，为了方便我们开发人员运行调试代码；</p> </li><li> <p>生产环境：production，指的是项目已经开发完成，并且已经经过测试无明显异常，需要发布上线供用户使用；</p> </li></ul> 
<h4>一、创建配置文件</h4> 
<p>考虑到开发环境和生产环境中还是有很多相同的配置，所以，我们还需要用一个公共配置文件来设置两个环境中相同的配置代码。</p> 
<p>在项目根目录中创建以下三个文件：</p> 
<ul><li> <p><code>webpack.base.config.js</code>：两个环境的公共配置；</p> </li><li> <p><code>webpack.dev.config.js</code>：开发环境的配置；</p> </li><li> <p><code>webpack.prod.config.js</code>：生产环境的配置；</p> </li></ul> 
<h4>二、webpack 配置初始模板</h4> 
<p>一个标准的 webpack 的配置文件的初始结构：（只是模板，不用复制）</p> 
<pre>module.exports = {
    mode: "",      // 生产环境、开发环境二选一
    entry: {},     // 配置 webpack 打包的入口文件
    output: {},    // 配置 webpack 打包的出口文件
    module: {},    // 配置代码转换规则
    plugins: [],   // 插件配置
    devServer: {}  // 配置开发服务器
}
</pre> 
<h4>三、合并公共配置</h4> 
<p>公共配置如果需要合并到两个环境中，需要使用插件 webpack-merge。</p> 
<p>下载插件：</p> 
<pre>npm i webpack-merge -D
</pre> 
<p>合并公共配置：（生产环境和开发环境各一个）</p> 
<pre>// 引入公共配置
const base = require('./webpack.base.config.js');
// 用于合并公共配置和当前环境配置
const { merge } = require('webpack-merge');
module.exports = merge(base, {
    // 开发环境自己的配置
    mode: 'development',
})
</pre> 
<pre>// 引入公共配置
const base = require('./webpack.base.config.js');
// 用于合并公共配置和当前环境配置
const { merge } = require('webpack-merge');
module.exports = merge(base, {
    // 生产环境自己的配置
     mode: 'production',
})
</pre> 
<h4>四、配置启动命令</h4> 
<p>因为我们需要在不同情况下启动不同的配置文件，为了方便使用，我们将两个启动命令重新命名。</p> 
<p>1、下载开发服务器</p> 
<pre>npm i webpack-dev-server -D
</pre> 
<p>2、配置开发环境中的服务器</p> 
<pre>module.exports = merge(base, {
    // 开发环境自己的配置
    mode: 'development',
    devServer: {
        port: '8080', // 端口号2000-6W+随便写
         open:'home.html',//打开网页默认为首页。
    }
})
</pre> 
<p></p> 
<p>3、配置启动命令</p> 
<p>找到项目的 <code>package.json</code> 文件：</p> 
<pre>{
    "scripts": {
        "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
        "build": "webpack --config webpack.prod.config.js --mode production",
        "dev": "webpack-dev-server --hot --config webpack.dev.config.js --mode development"
    },
}
</pre> 
<p>其中，<code>webpack.prod.config.js</code> 是我们前面创建好的生产环境的配置文件名。</p> 
<p>配置完成后，我们就可以通过以下命令来运行配置文件了：</p> 
<pre>npm run build
npm run dev
</pre> 
<p>build后将默认dist（或者设置的其他文件夹名）压缩发后端（zip格式）。</p> 
<h2>05 -《webpack 基础配置》</h2> 
<h4>一、入口文件 entry</h4> 
<p>项目中，每一个 <code>.html</code> 中都应该有一个主 <code>.js</code> 文件，这个 JS 文件，就是当前页面的入口文件。</p> 
<p>例如，我们的项目中有登录、注册、首页三个页面，那么对应的就有三个入口文件：</p> 
<p>在<code>src文件夹</code>中创建<code>js文件夹</code>，后再创建home.js、login.js、register.js文件。</p> 
<pre>module.exports = {
    entry: {
        home: './src/js/home.js',
        login: './src/js/login.js',
        register: './src/js/register.js',
    }
}
</pre> 
<h4>二、出口文件 output</h4> 
<p>webpack 对入口文件进行打包编译后，会生成对应的出口文件，我们需要告诉 webpack 出口文件的位置以及名称。</p> 
<pre>//公共配置
const path =require('path');

module.exports = {
    output: {
        // 配置出口文件的保存路径：项目根目录的 dist
        path: path.resolve(__dirname, 'dist'),
        // 出口文件的名称
        filename: 'js/[name].js'
    }
}
</pre> 
<h4>综合起来</h4> 
<p>在<code>src文件夹</code>中创建<code>js文件夹</code>，后再创建home.js、login.js、register.js文件。</p> 
<pre>//公共配置
const path =require('path');

module.exports = {
    entry: {
        home: './src/js/home.js',
        login: './src/js/login.js',
        register: './src/js/register.js',
    },
     output: {
        // 配置出口文件的保存路径：项目根目录的 dist
        path: path.resolve(__dirname, 'dist'),
        // 出口文件的名称
        filename: 'js/[name].js'
    }
}
</pre> 
<h4>三、配置 HTML</h4> 
<p>webpack 默认情况下，只能处理 <code>.js</code> 代码。如果我们要开始编译 HTML 代码，需要下载插件。</p> 
<p>1、下载 html-webpack-plugin</p> 
<pre>npm i html-webpack-plugin -D
</pre> 
<p>2、配置插件</p> 
<p>在src文件夹中创建home.html、login.html、register.html文件</p> 
<pre>const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/home.html',   // 源文件路径
            filename: 'home.html',         // 打包后的文件名
            chunks: ['home']               // 入口文件的名称
        }),
        new HtmlWebpackPlugin({
            template: './src/login.html',   // 源文件路径
            filename: 'login.html',         // 打包后的文件名
            chunks: ['login']               // 入口文件的名称
        }),
        new HtmlWebpackPlugin({
            template: './src/register.html',   // 源文件路径
            filename: 'register.html',         // 打包后的文件名
            chunks: ['register']               // 入口文件的名称
        }),
    ]
}
</pre> 
<p></p> 
<h4>四、复制文件*</h4> 
<p>当我们的项目中，有一些文件代码不需要 webpack 进行处理，只需要直接复制到打包后的目录中即可。那么，也需要进行对应的配置。</p> 
<p>1、下载 copy-webpack-plugin</p> 
<pre>npm i copy-webpack-plugin -D
</pre> 
<p>2、配置插件</p> 
<p>在src文件夹中创建static文件夹，static文件夹创建libs文件夹，将jquery-3.6.0.min.js文件放入libs文件夹中。</p> 
<p>同时，也可以在static文件夹中创建一个css文件夹，用于存放静态的公共样式代码common.css，在需要的页面（home.html）调用css文件，路径为src中的路径。</p> 
<p>最后在home.html文件（有需要的文件）中用&lt;link rel="stylesheet" href="./static/css/common.css"&gt;和 &lt;script src="./static/libs/jquery-3.6.0.min.js"&gt;&lt;/script&gt;引入。</p> 
<pre>const CopyWebpackPlugin = require('copy-webpack-plugin');
module.exports = {
    plugins: [
        // ...
        new CopyWebpackPlugin({
            patterns: [
                { from: './src/static', to: './static' }
            ]
        })
    ]
}
</pre> 
<h4>五、配置 SASS</h4> 
<p>1、下载插件</p> 
<pre>npm i node-sass sass-loader css-loader mini-css-extract-plugin -D
</pre> 
<p>如果下载报错，基本上都是因为 node-sass 的问题，执行以下命令重新下载 node-sass：</p> 
<pre>npm install node-sass --sass-binary-site=https://npm.taobao.org/mirrors/node-sass
</pre> 
<p>2、配置</p> 
<pre>const MiniCssExtractPlugin = require('mini-css-extract-plugin');
module.exports = {
    module: {
        rules: [
            // 配置 SASS
            {
                test: /\.scss$/i,           // 需要编译以 .scss 为结尾的文件
                exclude: /node_modules/,    // 不需要解析 node_modules
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader',
                    'sass-loader'
                ]
            }
        ]
    },
    plugins: [
        //... 
        new MiniCssExtractPlugin({
            filename: 'css/[name].css'
        })
    ]
}
</pre> 
<p>说明：按照我们当前的配置，项目中的 <code>.scss</code> 文件不能放在 <code>static</code> 中。建议在 <code>src</code> 目录中创建一个 <code>sass</code> 目录，用来存放所有页面的 <code>.scss</code> 文件。</p> 
<p>当某一个页面中需要引入 <code>.scss</code> 时（home.html），我们应该找到该页面的入口 JS 文件（home.js），然后在 JS 中通过 <code>import</code> 来引入对应 <code>.scss</code>：</p> 
<pre>import '../sass/home.scss';
</pre> 
<h4>六、配置 source map</h4> 
<p>在开发环境中进行以下配置：可以将报错定位还原。</p> 
<pre>module.exports = {
    devtool: 'inline-source-map'
}
</pre> 
<h2>06 -《webpack 优化配置》</h2> 
<h4>一、删除废除文件</h4> 
<p>1、下载插件</p> 
<pre>npm i clean-webpack-plugin -D
</pre> 
<p>2、配置插件</p> 
<p>在生产环境中进行以下配置：</p> 
<pre>const { CleanWebpackPlugin } = require('clean-webpack-plugin');
module.exports = {
    // ...
    plugins: [
        new CleanWebpackPlugin()
    ]
}
</pre> 
<h4>二、最小化 JS 和 CSS</h4> 
<p>1、下载插件</p> 
<pre>npm i terser-webpack-plugin css-minimizer-webpack-plugin -D
</pre> 
<p>2、配置插件</p> 
<pre>const TerserWebpackPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')
module.exports = {
    //...
    // 生产环境优化
    optimization: {
        minimize: true,
        minimizer: [
            new TerserWebpackPlugin(),
            new CssMinimizerPlugin()
        ]
    }
}
</pre> 
<h2>01 -《Node.js 准备工作》</h2> 
<h4>一、node.js 和 npm 安装</h4> 
<p>之前已经安装</p> 
<h4>二、npm 常用命令</h4> 
<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><strong>npm install 包名称</strong></td><td>下载开发和生产使用的依赖包（记录在 package.json 文件 dependencies 属性中）,新项目直接复制粘贴后输入该命令，自动下载。</td></tr><tr><td>npm uninstall 包名称</td><td>删除依赖包</td></tr><tr><td>npm install 包名称 -D</td><td>下载开发环境使用的依赖包（记录在 package.json 文件 devDependencies 属性中）</td></tr><tr><td>npm install 包名称 -g</td><td>下载全局的依赖包</td></tr><tr><td>npm install 包名称@版本号</td><td>下载指定版本的依赖包</td></tr><tr><td>npm install 包名称一 包名称二 …</td><td>同时下载多个依赖包（包名称之间用空格隔开）</td></tr></tbody></table> 
<h4>三、Nodejs 运行 JS 代码</h4> 
<p>在 Node.js 中，可以直接脱离浏览器，使用 Nodejs 来运行 JS 代码。</p> 
<p>创建任意一个 JS 文件，然后在终端中定位到该 JS 文件所在路径，通过 <code>node 文件名</code> 的命令就可以运行 JS 文件了。</p> 
<p>例如，我们创建一个 <code>a.js</code>：</p> 
<pre>console.log('hello a');
</pre> 
<p>然后在终端中定位到该 <code>a.js</code> 文件所在路径，执行 <code>node a.js</code> 命令，运行 <code>a.js</code>。</p> 
<h4>四、后端模块化</h4> 
<p>后端和前端一样，也要模块化的语法。</p> 
<p>1、暴露</p> 
<p>基础语法：</p> 
<pre>module.exports = {
    属性名一: 数据值一,
    属性名二: 数据值二,
}
</pre> 
<pre>module.exports.属性名一 = 数据值一;
module.exports.属性名二 = 数据值二;
</pre> 
<p>示例代码：</p> 
<pre>const name = "张三";
const age = 20;
module.exports = {
    name, age   // 简写
}
// 或
module.exports.name = name; 
module.exports.age = age;
</pre> 
<p>2、引入</p> 
<p>如果我们只是需要引入一个文件让其执行，不需要获取该文件中的任何数据。那么，直接 <code>require()</code> 该文件即可：</p> 
<pre>require("JS文件的路径");
</pre> 
<p>如果我们既要引入一个 JS 文件，同时还需要获取该 JS 文件中暴露出来的数据。那么 <code>require()</code> 之后还需要用变量来接收数据：</p> 
<pre>const 任意变量名 = require("JS文件的路径");
</pre> 
<p>示例代码：</p> 
<p>例如我们在引入前面例子中的 <code>a.js</code>，如果不需要获取 <code>a.js</code> 的数据：</p> 
<pre>require('./a.js');
</pre> 
<p>如果我们引入 <code>a.js</code> 的同时需要获取 <code>a.js</code> 的数据：</p> 
<pre>const student = require('./a.js'); 
console.log(student); // { name: '张三', age: 20 }
</pre> 
<p>或者直接解构：</p> 
<pre>const { name, age } = require('./a.js'); 
console.log(name, age);   // '张三'  20
</pre> 
<p>C:\Users\Administrator\Desktop\20220427\node-movies&gt; ·<code>cd ..</code>可以实现返回上一级终端</p> 
<p>C:\Users\Administrator\Desktop\20220427&gt; ·<code>cd node-movies</code>可以实现跳转下一级终端</p> 
<h2>02 -《MongoDB 准备工作》</h2> 
<h4>一、安装数据库服务器</h4> 
<h4>二、安装可视化工具</h4> 
<h2>03 -《搭建 Express 服务器项目》</h2> 
<h4>一、创建项目根目录</h4> 
<p>自己手动创建一个空文件夹，作为项目的根目录，例如：<code>movies-system-server</code>。</p> 
<h4>二、创建 Express 项目</h4> 
<p>将终端的路径定位到项目的根目录，然后执行以下命令：</p> 
<pre>npx express-generator
</pre> 
<p>该命令执行完成后，会自动在项目的根目录中生成 Express 服务端项目的基本结构。</p> 
<h4>三、下载项目所有依赖包</h4> 
<p>将终端的路径定位到项目的根目录，执行以下命令，根据 <code>package.json</code> 文件下载项目需要的所有依赖包：</p> 
<pre>npm i
</pre> 
<h4>四、启动项目</h4> 
<p>将终端的路径定位到项目的根目录，执行以下命令启动项目：</p> 
<pre>npm start
</pre> 
<h4>五、访问项目</h4> 
<p>在浏览器中输入 <code>localhost:3000</code> 可以访问到服务器项目的欢迎界面：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/20/92/MlRiyfjD_o.png"></p> 
<h4>六、下载 nodemon 插件</h4> 
<p>每一次 express 项目中的代码发生改变后，都需要重启服务器，来让新的代码生效。所以，我们需要借助 nodemon 插件来帮助我们自动重启服务器。</p> 
<p>1、下载插件</p> 
<pre>npm i nodemon -g
</pre> 
<p>2、更改启动命令</p> 
<p>将项目根目录的 <code>package.json</code> 文件中的 <code>start</code> 属性的值更改为以下命令：</p> 
<pre>{
    "scripts": {
        // "start": "node ./bin/www"   // 旧的
        "start": "nodemon ./bin/www"   // 更改后的
    },
}
</pre> 
<p>注意：nodemon 插件是根据代码是否重新保存来控制服务器是否重启。所以如果设置了“自动保存”代码给功能的话，代码每隔一两秒保存一次，服务器也就会每隔一两秒重启一次。建议使用 nodemon 启动服务器的话，就关闭代码的“自动保存”功能。</p> 
<h2>04 -《Express 连接 MongoDB》</h2> 
<p>Express 的服务器项目如果需要连接 MongoDB 数据库服务器，需要在 Express 中进行配置。这里，我们选择使用 mongoose 插件用来处操作 MongoDB。</p> 
<h4>一、下载 mongoose</h4> 
<p>将终端的路径定位到项目的根目录，然后执行以下命令，下载 mongoose 插件：</p> 
<pre>npm i mongoose
</pre> 
<h4>二、配置连接 MongoDB</h4> 
<p>在项目根目录中创建一个文件夹 <code>dao</code>，该目录中专门用来存放所有关于数据库操作的代码。</p> 
<p>在 <code>dao</code> 的目录中，创建一个 <code>db.js</code> 文件（db 取的是 database 单词中的两个字母），在该文件中配置以下代码来连接 MongoDB：</p> 
<pre>const mongoose = require('mongoose');
// 其中：woniumovies 是我们要连接的数据库的名称（如果数据库不存在，后续会自动创建）
mongoose.connect("mongodb://localhost:27017/woniumovies", () =&gt; {
    console.log('woniumovies 数据库连接成功');
})
</pre> 
<h4>三、执行配置代码</h4> 
<p>服务器的启动，默认会运行 <code>app.js</code> 文件。因此，如果需要运行 <code>db.js</code> 的话，需要在 <code>app.js</code> 中引入 <code>db.js</code>，参考代码如下：</p> 
<pre>// 引入mongoose的配置文件，连接 express 和 mongodb
require('./dao/db.js');
// ... 后续的代码位置
var indexRouter = require('./routes/index');
var usersRouter = require('./routes/users');
</pre> 
<p>查看本地id地址：1.win+r。2.cmd。3. ipconfig命令</p> 
<h4>四、启动服务器</h4> 
<p>最后，配置完成后，重新执行以下命令启动服务器：</p> 
<pre>npm start
</pre> 
<p>启动成功后，我们会在终端中看到类似以下提示：</p> 
<pre>[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./bin/www`
woniumovies 数据库连接成功
</pre> 
<p>到此，Express 连接 MongoDB 数据成功！</p> 
<p>备注：有时mongoDB没有运行，需要我的电脑右键点管理，双击服务，找到mongoDB并运行。</p> 
<h2>05 -《Express 处理前端请求》</h2> 
<h4>一、前端发送 AJAX 请求</h4> 
<p>通常我们的前端项目都搭建在 webpack 的服务器中。所以，前端发送 AJAX 请求，实际就是从 webpack 的服务器中发送一个请求到后端 Express 的服务器。</p> 
<h4>二、后端处理前端的请求</h4> 
<p>后端会根据前端请求的资源，在 Express 项目的 <code>routes</code> 目录中创建对应的 JS 文件。</p> 
<p>1、创建文件</p> 
<p>例如，前端发送了 <code>/movies/getMovies</code> 请求，那么我们在后端需要在 <code>routes</code> 中创建一个 <code>movies.js</code> 文件，然后将 <code>user.js</code> 中的代码复制到该文件中。</p> 
<p>2、设置一级接口</p> 
<p>在 Express 项目的 <code>app.js</code> 中，针对当前请求，进行以下配置：</p> 
<pre>var indexRouter = require('./routes/index');
var usersRouter = require('./routes/users');
const moviesRouter = require('./routes/movies');  // 新增的
app.use('/', indexRouter);
app.use('/users', usersRouter);
app.use('/movies', moviesRouter);   // 新增的
</pre> 
<p>配置完成后，前端发送的 <code>/movies/getMovies</code> 请求，一级接口就会和 <code>app.js</code> 文件中的配置匹配成功。</p> 
<p>3、设置二级接口</p> 
<p>匹配成功后，前端请求进入到对应的 JS 文件中。</p> 
<p>在 <code>movies.js</code> 中继续配置二级接口：</p> 
<pre>var express = require('express');
var router = express.Router();
router.get('/getMovies', function (req, res, next) {
    console.log('进入到后端的 getMovies 了');
    res.send('后端发送给前端的数据');
});
module.exports = router;
</pre> 
<p>当前端请求的<strong>类型、一级接口、二级接口</strong>都和后端匹配成功后，就会执行对应的函数了。</p> 
<h2>06 -《Express 操作 MongoDB》</h2> 
<h4>一、配置数据模型（结构）</h4> 
<p>在通过 mongoose 插件操作 MongoDB 之前，我们需要对要操作的数据格式进行配置。</p> 
<p>在 <code>dao</code> 目录中，再新建一个 <code>models</code> 的目录，用来存放所有项目中数据的数据结构的配置代码。</p> 
<p>例如，我们要配置电影数据的结构，那么我们在 <code>models</code> 目录中，再新建一个 <code>moviesModel.js</code> 文件，用来配置电影数据相关的结构。</p> 
<pre>const { Schema, model } = require('mongoose');
// 定义数据结构
const moviesSchema = new Schema({
    name: String,  // 电影中文名
    eName: String, // 电影英文名
    actors: String, // 演员
    director: String, // 导演
    language: String,  // 语言
    region: String, // 上映地区
    desc: String,  // 简介
    duration: String,  // 时长
})
// 定义数据模型
// 参数说明
// 第一个参数：自己给数据模型取的名字（自己命名）
// 第二个参数：数据结构的变量名
// 第三个参数：MongoDB 服务器中数据集合的名字
module.exports = model('moviesModel', moviesSchema, 'movies');
</pre> 
<p>为了让以上配置代码运行生效，我们在 <code>db.js</code> 中引入所有的数据模型的配置文件，让这些配置在服务器项目一启动时就生效。</p> 
<pre>require('./models/moviesModel.js');
</pre> 
<h4>二、通过模型操作数据</h4> 
<p>考虑到项目中操作数据的代码量比较大，通常我们还会在项目的根目录中创建一个 <code>controllers</code> 文件，该目录中用来存放所有操作数据库的代码。</p> 
<p>例如我们要操作电影数据，在 <code>controllers</code> 目录中，再创建一个 <code>moviesControllers.js</code> 文件，用来处理所有关于电影数据的操作代码：</p> 
<pre>// 引入数据模型
const moviesModel = require('../dao/models/moviesModel');
// 将方法暴露给 routes/movies.js 中调用
module.exports.getMovies = async () =&gt; {
    // 通过数据模型开始获取数据
    const data = await moviesModel.find();
    // 将数据返回给 routes/movies.js 文件中
    return {
        code: 1,
        message: '电影数据获取成功',
        data
    }
}
module.exports.addMovies = () =&gt; {
}
</pre> 
<h4>三、调用 controllers 方法</h4> 
<p>在 <code>routes</code> 中的文件里，我们引入并调用 controllers 中暴露出来的方法：</p> 
<pre>var express = require('express');
var router = express.Router();
// 获取到 moviesControllers.js 中暴露的方法
const { getMovies, addMovies } = require('../controllers/moviesControllers');
router.get('/getMovies', async function (req, res, next) {
    // 开始获取 movies 集合中的电影数据
    const data = await getMovies();
    // 将数据结果返回给前端
    res.send(data);
});
router.post('/addMovies', function (req, res, next) {
});
module.exports = router;
</pre> 
<h4>四、前端发送数据给后端</h4> 
<p>1、前端发送数据</p> 
<p>前端通过 AJAX 发送请求到后端，除了可以用来接收后端返回的数据外，也可以在发送请求的同时发送数据给后端。语法如下：</p> 
<pre>$.ajax({
    url: '资源路径',
    type: '请求类型',            // 获取数据用 GET，新增、修改、删除数据用 POST
    data: {                     // 发送给后端的数据
        数据键一: 数据值一,
        数据键二: 数据值二,
        // ...
    },
    success(res) {
        console.log(res);
    }
})
</pre> 
<p>2、后端接收数据</p> 
<p>Express 后端接收前端数据，是在路径匹配成功时执行的函数的参数 <code>req</code> 中。</p> 
<p>我们以新增电影数据为例，当前端发送了要新增的电影数据到后端后，后端接收数据：</p> 
<pre>const { getMovies, addMovies } = require('../controllers/moviesControllers');
router.post('/addMovies', async function (req, res, next) {
    // 接收前端发送的数据
    const params = req.body;
    // 调用 controllers 中新增电影的方法，并将数据传递到 controllers 中
    const data = await addMovies(params);
    // 将新增成功或失败的结果返回给前端
    res.send(data);
});
</pre> 
<p>说明：前端不管是使用 GET 还是 POST 请求，其实都可以发送数据给后端。发送数据的语法都一样，都是通过 data 进行发送。但是，后端接收的方式不一样。</p> 
<p>如果是 GET 请求，后端需要通过 <code>req.query</code> 来接收，如果是 GET 以外的其他任何请求，后端都通过 <code>req.body</code> 来接收（上例代码中的形式）。</p> 
<h4>五、mongoose 的方法</h4> 
<p>mongoose 中，所有对数据库的操作都是由数据模型提供的。例如我们前面获取电影数据用到的 <code>find()</code> 方法。除了 <code>find()</code> 以外，mongoose 还提供了很多的方法用来操作 MongoDB 数据，这里我们列举几个常用的方法：</p> 
<p>1、获取所有数据</p> 
<pre>const data = await 数据模型.find();
</pre> 
<p>2、按条件查询数据</p> 
<pre>const data = await 数据模型.find({查询键: 查询值});
</pre> 
<p>例如要查询 name 值为“哈利·波特与魔法石”的电影数据：</p> 
<pre>const data = await moviesModel.find({ name: "哈利·波特与魔法石" });
</pre> 
<p>3、新增数据</p> 
<pre>const result = await 数据模型.create({ 新增数据键: 新增数据值 });
</pre> 
<p>例如我们要新增一条 name 值为“星际穿越”的电影数据（新增数据时，可以只传数据模型中的部分数据）：</p> 
<pre>const result = await moviesModel.create({ name: "星际穿越" });
</pre> 
<p>4、按条件删除数据</p> 
<pre>const result = await 数据模型.deleteOne({ 删除数据键: 删除数据值 });
</pre> 
<p>例如我们想要根据“哈利·波特与魔法石”的 _id 将该条电影数据删除：</p> 
<pre>const result = await 数据模型.deleteOne({ _id: '6154072d28f56c648410d7a3' });
</pre> 
<p>5、按条件修改数据</p> 
<pre>const result = await 数据模型.updateOne({ 查询条件键: 查询条件值 }, { 新数据键: 新数据值 });
</pre> 
<p>例如我们想要通过星际穿越的 _id 找到该条数据，并将 name 改为“星际不穿越”：</p> 
<pre>const result = await 数据模型.updateOne({ _id: '6154071228f56c648410d7a2' }, { name: "星际不穿越" });
</pre> 
<p>6、分页获取数据</p> 
<p>mongoose 中提供了 <code>limit()</code> 和 <code>skip()</code> 两个方法来实现分页获取数据。</p> 
<ul><li> <p><code>limit()</code>：设置需要获取的数据条数</p> </li><li> <p><code>skip()</code>：设置跳过的数据条数</p> </li></ul> 
<p>例如，如果我们需要获取电影列表第一页的 3 条数据，参考代码如下：</p> 
<pre>const data = await moviesModel.find().skip(0).limit(3);
</pre> 
<p>因此，如果后端要做分页功能，前端至少需要发送两个参数给后端，分别是（数据名称可自定义）：</p> 
<ul><li> <p><code>currentPage</code>：当前页码</p> </li><li> <p><code>pageSize</code>：每页显示的数据条数</p> </li></ul> 
<p>最后，将这两个参数应用到 <code>limit()</code> 和 <code>skip()</code> 两个方法中：</p> 
<pre>const { currentPage, pageSize } = params;
const data = moviesModel.find().populate('type').skip((currentPage - 1) * pageSize).limit(pageSize);
</pre> 
<p>7、获取数据总条数</p> 
<p>在做分页时，我们通常都只需要获取部分的数据。但是在计算总页数时，我们需要知道列表数据的总条数。mongoose 中提供了专门的方法 <code>countDocuments()</code>来获取数据集合中数据的总条数。</p> 
<p>例如我们获取电影数据的总条数：</p> 
<pre>const total = await moviesModel.countDocuments();
</pre> 
<p>有了总条数和每页显示的条数，就可以自己计算出总页数了：</p> 
<pre>const pages = Math.ceil(total / pageSize);
</pre> 
<h2>07 -《前后端分离项目的启动步骤》</h2> 
<h4>一、启动 Node.js 后端项目</h4> 
<p>终端中定位到项目根目录，执行启动命令：</p> 
<pre>npm start
</pre> 
<p>正常情况下，Node.js 的后端服务器启动成功后，会自动连接到 MongoDB 数据库。</p> 
<p>如果没有提示“数据库连接成功”，就有可能是数据库的服务器没有开启。</p> 
<p>如果提示了“数据库连接成功”，就跳过第二步。</p> 
<h4>二、启动 MongoDB 服务器</h4> 
<p>右键【此电脑】-【管理】-【服务与应用程序】-【服务】-【MongoDB Server】-【启动】</p> 
<h4>三、启动 webpack 前端项目</h4> 
<p>终端中定位到项目根目录，执行启动命令：</p> 
<pre>npm run dev
</pre> 
<h2>08 -《封装网络请求》</h2> 
<p>在实际开发中，会将所有的 AJAX 请求全都封装到一个目录中来进行处理。</p> 
<h4>一、创建 API 目录</h4> 
<p>我们在 src 目录中创建一个 api 目录，用来存放所有数据相关的 AJAX 请求。</p> 
<h4>二、创建 API 文件</h4> 
<p>我们根据数据的类型，把 AJAX 请求再做一个分类。例如：电影数据相关的请求，统一放在一个文件中；用户数据相关的请求，统一放在另一个文件中…</p> 
<p>所以，我们在 API 目录中创建对应的 <code>.js</code> 文件。例如：</p> 
<ul><li> <p><code>moviesAPI.js</code></p> </li><li> <p><code>usersAPI.js</code></p> </li><li> <p>…</p> </li></ul> 
<h4>三、封装 AJAX 请求</h4> 
<p>例如我们在 <code>moviesAPI.js</code> 中用 Promise 封装关于电影数据的请求：</p> 
<pre>// 获取电影数据
export function getMoviesAsync() {
    return new Promise((resolve, reject) =&gt; {
        $.ajax({
            url: '/api/movies/getMovies',
            type: 'GET',
            success(res) {
                resolve(res);
            }
        })
    })
}
// 删除电影数据
export function deleteMoviesAsync(data) {
    return new Promise((resolve, reject) =&gt; {
        $.ajax({
            url: '/api/movies/deleteMovies',
            type: 'POST',
            data,
            success(res) {
                resolve(res);
            }
        })
    })
}
// ...
</pre> 
<p>通过 export 将所有的请求方法暴露出去。后续需要发送请求时，只需要引入该方法并调用即可。</p> 
<h4>四、调用 AJAX 请求</h4> 
<p>例如我们想要发送 AJAX 请求获取电影数据。</p> 
<p>我们在处理电影的 JS 文件 <code>movies.js</code> 中，引入封装好的 API，并调用：</p> 
<pre>import { getMoviesAsync } from '../api/moviesAPI.js'
moviesRender();
async function moviesRender() {
    // 发送请求获取所有的电影数据
    const res = await getMoviesAsync();
    console.log(res);
}
</pre> 
<h4>五、渲染数据</h4> 
<p>在第四步中获取到数据后，我们就可以开始渲染数据了：</p> 
<pre>async function moviesRender() {
    // 发送请求获取所有的电影数据
    const res = await getMoviesAsync();
    // 判断后端是否有成功的获取到数据
    if(res.code) {
        // 渲染所有的电影数据
        render(res.data);
    }
}
function render(moviesData) {
    const moviesHTML = moviesData.map(item =&gt; (
        `&lt;tr&gt;
            &lt;td&gt;${item.name}&lt;/td&gt;
            &lt;td&gt;${item.eName}&lt;/td&gt;
            &lt;td&gt;${item.director}&lt;/td&gt;
            &lt;td&gt;${item.actors}&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;
                &lt;a href="#"&gt;修改&lt;/a&gt;
                &lt;a href="#" class="deleteBtn" data-id="${item._id}"&gt;删除&lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;`
    )).join("");
    $('#moviesTbody').html(moviesHTML);
}
</pre> 
<h2>09 -《新增电影的前后端流程》</h2> 
<p>前后端代码执行流程参考：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/04/d5/hbJujxMG_o.png"></p> 
<p>我们以“新增电影”功能为例。</p> 
<h4>一、前端</h4> 
<p>1、封装“新增电影”的请求</p> 
<p>我们是将项目中所有的 AJAX 请求全都统一在 API 的目录中进行处理，找到该目录中电影的 API 文件，例如：<code>moviesAPI.js</code>。开始通过 Promise 封装 AJAX 请求：</p> 
<pre>// 新增电影数据
export function addMoviesAsync(data) {
    return new Promise((resolve, reject) =&gt; {
        $.ajax({
            url: '/api/movies/addMovies',
            type: 'POST',
            // AJAX 的 data 属性，用来向后端发送数据
            // 当前请求中，具体的 data 值，是外部调用该方法时传递进来的
            data,   
            success(res) {
                resolve(res);
            }
        })
    })
}
</pre> 
<p>2、页面调用 AJAX 请求</p> 
<p>我们在项目的 <code>js</code> 目录中创建了一个 <code>movies.js</code> 文件，专门用来处理管理系统页面中所有关于电影的操作。</p> 
<p>因此我们现在要做“新增电影”的功能，需要在该文件中，给“新增电影”的按钮身上添加一个点击事件，在事件中调用封装好的 AJAX 方法，发送请求。</p> 
<p>参考代码如下：</p> 
<pre>import { addMoviesAsync } from '../api/moviesAPI.js'
// 新增电影
$('#addMoviesBtn').click(async function () {
    // 获取页面中用户输入的电影数据
    const name = $('#addMovieName').val();
    const eName = $('#addMovieEName').val();
    // ... 获取页面中其他数据
    // 调用 AJAX 方法发送请求
    const res = await addMoviesAsync({ name, eName });
    // 输出后端返回的请求结果
    console.log(res);
})
</pre> 
<p>3、测试请求是否成功</p> 
<p>前端页面和功能的代码完成后，我们先不着急写后端，需要先检查一下前端的代码是否有问题。</p> 
<p>根据写好的代码，操作页面，触发事件发送请求。然后依次进行以下检查：</p> 
<p>1）查看后端的终端中是否有当前请求的日志</p> 
<p>正常情况下，我们还没有开始写后端的代码，那么这个时候前端请求发送到后端后，终端的日志中应该会有一个 404 的请求记录。</p> 
<p>参考下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9d/63/XPFyYeQ9_o.png"></p> 
<p>出现类似以上日志，说明前端的请求已经成功的发送到后端。</p> 
<p>如果后端终端中没有对应的请求日志，则说明前端请求可能有问题，我们进行下一步检查。</p> 
<p>2）查看浏览器 F12 控制台的【Network】</p> 
<p>在浏览器的 F12 控制台中查看网络请求，正常情况下，我们能在 Network 中查看到当前页面发送的所有请求。</p> 
<p>参考下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cd/5b/Op7qUzTO_o.png"></p> 
<p>如果请求列表里没有出现我们发送的 AJAX 的接口名称，则说明前端根本没有发送 AJAX 请求。</p> 
<h4>二、后端</h4> 
<p>1、创建 routes 中对应的文件</p> 
<p>在 Express 的后端中，有一个 routes 的目录，专门用来匹配所有前端请求的二级接口。</p> 
<p>通常来说，会在该目录中创建不同的 <code>.js</code> 文件，用来处理不同类型的数据请求。</p> 
<p>例如，我们要处理电影数据，就会在 routes 目录中创建一个 <code>movies.js</code> 文件，专门用来处理所有关于电影数据的请求。</p> 
<p>在该文件中添加以下初始代码：</p> 
<pre>var express = require('express');
var router = express.Router();
// router.get('/', function(req, res, next) {
//     res.send('respond with a resource');
// });
module.exports = router;
</pre> 
<p>2、在 app.js 中配置一级接口</p> 
<p>在 Express 后端项目的 app.js 中，通过以下代码，来引入我们刚刚创建好的 routes 中的文件，同时设置对应的一级接口：</p> 
<pre>// 引入 routes 中的文件
const moviesRouter = require('./routes/movies');
// ....
// 配置一级接口
app.use('/movies', moviesRouter);
</pre> 
<p>3、在 routes 的文件中配置二级接口</p> 
<p>根据当前前端发送的 AJAX 请求的 URL，在后端对应的 routes 的文件中，配置二级接口。</p> 
<p>例如：前端通过 POST 发送了一个“新增电影”的请求，我们需要在 <code>routes/movies.js</code> 中进行以下配置：</p> 
<pre>// 新增电影
router.post('/addMovies', function (req, res, next) {
    console.log('123123123')
});
</pre> 
<p>我们完成这一部分配置后，重新回到前端页面，操作页面发送请求，在后端的终端中查看当前的输出是否有执行。</p> 
<p>如果输出执行了，则表示我们前端的请求成功的进入到后端。</p> 
<p>4、在 routes 中接收前端发送的数据</p> 
<p>如果当前的请求，前端有发送数据给后端，我们需要在后端的 routes 的文件中，接收到前端发送过来的数据。</p> 
<p>后端接收前端数据的方式有两种：</p> 
<ul><li> <p>前端发送 GET 请求：后端通过 <code>req.query</code> 接收参数；</p> </li><li> <p>前端发送除 GET 外的其他请求：后端通过 <code>req.body</code> 接收参数；</p> </li></ul> 
<p>例如，新增电影的请求需要接收前端发送过来的新电影的数据：</p> 
<pre>// 新增电影
router.post('/addMovies', function (req, res, next) {
    const params = req.body;
    console.log(params);
});
</pre> 
<p>正常情况下来说，后端输出 <code>req.body</code>，就可以查看到前端发送过来的数据。</p> 
<p>如果后端输出没有数据，可以在浏览器的 F12 的控制台的【Network】中，找到对应的请求，点击进去，查看请求中是否有【payload】。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ec/03/9CmsjAPP_o.png"></p> 
<p>确认前端发送的数据没问题后，我们就可以继续去处理后端了。</p> 
<p>5、创建 controllers 中对应的文件</p> 
<p>在 Express 的后端中，我们会在项目根目录创建一个 controllers 的目录，专门用来存放所有关于操作 MongoDB 数据库的代码。</p> 
<p>例如，我们要新增电影，需要操作电影数据，因此需要在该目录中创建一个 <code>moviesControllers.js</code> 文件，专门用来处理所有关于电影数据的操作代码。</p> 
<p>6、在 controllers 中暴露方法</p> 
<p>在 <code>moviesControllers.js</code> 文件中创建并暴露一个方法，通过形参 params 来接收 routes 中获取到的前端数据：</p> 
<pre>// 新增电影
// params 用来接收 routes 中传递的参数
module.exports.addMovies = async (params) =&gt; {
    console.log('接收 routes 传递的数据：', params)
}
</pre> 
<p>7、routes 中引入并调用 controllers 的方法</p> 
<p>routes 中需要将接收到的前端数据，发送给 controllers。因此需要引入并调用 controllers 中的方法：</p> 
<pre>const {  addMovies  } = require('../controllers/moviesControllers');
// 新增电影
router.post('/addMovies', function (req, res, next) {
    const params = req.body;
    // 调用 controllers 的方法，并将参数传递给 controllers
    addMovies(params);
});
</pre> 
<p>8、controllers 操作数据库</p> 
<p>controllers 的方法中确认接收到数据后，就可以使用 mongoose 提供的各种方法去操作 MongoDB 数据库了。</p> 
<p>例如，新增电影应该使用 create 方法，并将新增数据组成一个对象作为参数传递给 create：</p> 
<pre>module.exports.addMovies = async (params) =&gt; {
    const result = await moviesModel.create(params);
    console.log(result);
}
</pre> 
<p>数据库操作完成后，通过 async await 接收到数据库返回的结果，并输出查看结果。</p> 
<p>9、返回结果给 routes</p> 
<p>在 controllers 中，对数据库返回的结果进行判断处理，然后通过 return 返回处理结果给 routes：</p> 
<pre>// 新增电影
// params 用来接收 routes 中传递的参数
module.exports.addMovies = async (params) =&gt; {
    const result = await moviesModel.create(params);
    if(result) {
        return {
            code: 1,
            message: '电影数据新增成功'
        }
    }
    return {
        code: 0,
        message: '电影数据新增失败'
    }
}
</pre> 
<p>10、routes 接收结果返回给前端</p> 
<p>最后，routes 中接收到 controllers 中处理好的结果，通过 <code>res.send()</code> 返回给前端。</p> 
<pre>// 新增电影
router.post('/addMovies', async function (req, res, next) {
    const params = req.body;
    // 调用 controllers 的方法，并将参数传递给 controllers
    const result = await addMovies(params);
    res.send(result);
});
</pre> 
<p>最终，前端 AJAX 的 success 中通过形参 res 可以接收到后端返回的结果。</p> 
<p></p> 
<h2>10 -《数据集合的关联》</h2> 
<p>MongoDB 中的数据集合与集合之间是可以通过 _id 来进行关联。</p> 
<p>例如，我们希望将电影集合和分类集合进行关联，就可以给每一条电影数据都添加一个 type 属性，用来保存对应分类的 _id。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8e/85/SWBEMsRk_o.png"></p> 
<h4>一、数据模型配置</h4> 
<p>我们以电影集合为例。电影集合中的每一条电影数据，我们都希望有一个 type 属性，用来记录当前电影所属分类。</p> 
<p>所以，在配置电影集合的数据模型时：</p> 
<pre>const { Schema, model } = require('mongoose');
// 定义数据结构
const moviesSchema = new Schema({
    // ... 其他常规属性
    // 负责去关联“分类”的集合
    type: {
        type: Schema.Types.ObjectId,  // 固定格式
        ref: 'typesModel'  // 需要关联的另一个集合模型名称
    }
}, { versionKey: false })
module.exports = model('moviesModel', moviesSchema, 'movies');
</pre> 
<p>其中，<code>type: Schema.Types.ObjectId</code> 是关联属性的固定格式，用来表示当前属性值的数据类型。<code>ref</code> 的值用来设置需要关联的另一个集合的模型名称。</p> 
<p>模型配置成功后，后续我们再新增电影数据时，除了新增常规的电影数据外，还需要包括当前电影对应的分类的 _id，例如：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ed/17/xZwBoS2F_o.png"></p> 
<h4>二、关联查询</h4> 
<p>我们在查询电影数据时，如果还是只通过 <code>find()</code> 方法查询，会导致我们查询出来的电影数据的 type 属性值只是一串 _id 数字。但是，我们真正需要的是，在查询电影数据时，除了获取到电影的常规属性外，还可以通过电影分类的 _id，查询到对应的分类详细信息。</p> 
<p>因此，我们在做 <code>find()</code> 查询时，需要做一个关联查询：</p> 
<pre>module.exports.getMovies = async () =&gt; {
    // 关联查询
    const data = await moviesModel.find().populate('type');
    return {
        code: 1,
        message: '电影数据获取成功',
        data
    }
}
</pre> 
<p>说明：<code>populate()</code> 方法是 mongoose 中提供的专门用于关联查询的方法。该方法的参数就是当前集合对外做关联的属性键名。</p> 
<p>这样，关联查询到的结果中，电影的 type 属性值就是一个对象，该对象包含的就是当前分类的详细信息。例如：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/ec/uoXkTRuz_o.png"></p> 
<h4>三、后台处理倒序</h4> 
<pre>module.exports.getMovies = async () =&gt; {
    // 关联查询
    const data = await moviesModel.find().populate('type').sort({'score':-1});
    return {
        code: 1,
        message: '电影数据获取成功',
        data
    }
}
</pre> 
<p></p> 
<h2>11 -《图片上传》(头像上传)</h2> 
<h4>一、前端图片预览</h4> 
<p>1、原理</p> 
<p>用户在页面中选择一张图片时，并不确定就一定要保存这张图片。因此，在确定保存之前，用户选择的图片我们都只需要做一个临时的预览就可以了。</p> 
<p>所以我们实现的思路是使用 <code>FileReader</code> 对象的 <code>readAsDataURL()</code> 方法来将图片转换为一个 base64 的字符串，然后直接渲染字符串来实现图片的预览。</p> 
<p>2、代码实现</p> 
<p>在 <code>` 节点身上添加一个</code>change` 事件：</p> 
<pre>$('#addUserAvatar').change(function () {
    // console.log(this.files); // 获取到用户选中的所有的图片信息
    const fileInfo = this.files[0];
    const reader = new FileReader();
    reader.readAsDataURL(fileInfo);
    reader.onload = function (e) {
        // console.log(e.target.result);   // base64 的字符串
        $('#userAvatar').attr('src', e.target.result);
    }
})
</pre> 
<h4>二、图片上传</h4> 
<p>1、原理</p> 
<p>只有当用户点击确认按钮时，我们才可以确定用户要保存当前图片。</p> 
<p>base64 的图片信息只是做一个临时的预览，因为 base64 的字符串太长了，我们并不会将该字符串保存到后端数据库。</p> 
<p>所以，如果用户确认要保存一张图片时，我们要做的事情是：将图片信息通过 AJAX 发给后端服务器，后端服务器根据图片信息复制一张新的图片保存到服务器中，最后只需要将服务器上新图片的路径保存到数据库中即可。</p> 
<p>2、前端代码实现</p> 
<p>1）获取相关数据</p> 
<p>我们以新增用户为例，当点击确认新增时，要获取到用户的基本信息，以及图片信息：</p> 
<pre>// 确认新增
$('#addUserBtn').click(async function () {
    const name = $('#addUserName').val();
    const account = $('#addUserAccount').val();
    const password = $('#addUserPassword').val();
    const gender = $('#addUserGender').val();
    // 图片信息
    const avatar = $('#addUserAvatar')[0].files[0];
})
</pre> 
<p>2）处理数据格式</p> 
<p>由于文件信息要以 FormData 的数据格式发送给后端，因此我们需要将图片 信息连同其他常规数据，一起进行处理：</p> 
<pre>// 确认新增
$('#addUserBtn').click(async function () {
    const name = $('#addUserName').val();
    const account = $('#addUserAccount').val();
    const password = $('#addUserPassword').val();
    const gender = $('#addUserGender').val();
    // 图片信息
    const avatar = $('#addUserAvatar')[0].files[0];
    // 因为后端需要以 FormData 的形式来接收图片数据
    const fd = new FormData();
    fd.append('file', avatar); // 将图片信息添加到 fd 对象身上 ，并取名叫 file
    fd.append('name', name);
    fd.append('account', account);
    fd.append('password', password);
    fd.append('gender', gender);
})
</pre> 
<p>3）发送 AJAX 请求</p> 
<p>数据处理完成后，我们就可以直接将 fd 对象通过 AJAX 的 data 属性发送给后端，但是 AJAX 中还需要额外添加三个属性。</p> 
<p>封装的 AJAX 参考如下：</p> 
<pre>export function addUsersAsync(data) {
    return new Promise((resolve) =&gt; {
        $.ajax({
            url: '/api/users/addUsers',
            type: 'POST',
            // 以下三个属性，主要用来告诉 jQuery 不要处理 data 的数据格式
            processData: false,
            contentType: false,
            cache: false,
            data,
            success(res) {
                resolve(res);
            }
        })
    })
}
</pre> 
<p>最后，确认新增的点击事件中调用 AJAX 方法：</p> 
<pre>// 确认新增
$('#addUserBtn').click(async function () {
    const name = $('#addUserName').val();
    const account = $('#addUserAccount').val();
    const password = $('#addUserPassword').val();
    const gender = $('#addUserGender').val();
    // 图片信息
    const avatar = $('#addUserAvatar')[0].files[0];
    // 因为后端需要以 FormData 的形式来接收图片数据
    const fd = new FormData();
    fd.append('file', avatar); // 将图片信息添加到 fd 对象身上 ，并取名叫 file
    fd.append('name', name);
    fd.append('account', account);
    fd.append('password', password);
    fd.append('gender', gender);
    // 以上处理完成后，所有的数据都添加到了 fd 对象身上
    const res = await addUsersAsync(fd);
})
</pre> 
<p>3、后端代码实现</p> 
<p>1）下载配置图片上传</p> 
<p>后端要根据前端发送的图片信息，开始复制图片。这里我们需要用到一个插件 <code>multer</code>，所以需要现在后端终端中下载该依赖包：</p> 
<pre>npm i multer
</pre> 
<p>下载完成后，在项目根目录中创建一个 <code>utils/fileUpload.js</code> 文件，用来配置图片上传的过程（拷贝我们发送的文件就行了）。</p> 
<p>2）上传图片</p> 
<p>在后端对应的接口文件中，引入并调用封装好的图片上传方法：</p> 
<pre>var express = require('express');
var router = express.Router();
const uploadFiles = require('../utils/fileUpload.js');  // 引入配置好的图片上传方法
router.post('/addUsers', function(req, res, next) {
    // 图片上传（将用户本地的图片复制到当前服务器项目中）
    const upload = uploadFiles();
    upload(req, res, (err) =&gt; {
        if(err) {
            console.log('图片上传失败', err);
        } else {
            console.log('图片上传成功');
        }
    })
});
module.exports = router;
</pre> 
<p>图片上传成功后，会在 Node.js 项目的 public 目录中新增一个 images 目录，同时新增我们上传的图片。</p> 
<p>3）获取数据</p> 
<p>图片上传成功后，我们通过 <code>req.files</code> 获取到上传后的图片信息，以及通过 <code>req.body</code> 获取到其他常规数据：</p> 
<pre>var express = require('express');
var router = express.Router();
const uploadFiles = require('../utils/fileUpload.js');
const { addUsers } = require('../controllers/usersControllers.js')
router.post('/addUsers', function(req, res, next) {
    // 图片上传（将用户本地的图片复制到当前服务器项目中）
    const upload = uploadFiles();
    upload(req, res, async (err) =&gt; {
        if(err) {
            console.log('图片上传失败', err);
        } else {
            // console.log('图片上传成功', req.files);
            // 拼接图片地址
            const avatar = 'http://localhost:3000/images/' + req.files[0].filename;
            // 获取到其他的常规数据
            // console.log(req.body);
            const data = await addUsers({ ...req.body, avatar });
            res.send(data);
        }
    })
});
module.exports = router;
</pre> 
<p>数据处理好后，按照之前的方式，把数据对象传递给 controllers 文件，最后新增到数据库。</p> 
<h2>12 -《身份认证》</h2> 
<p>在实际开发中，实现身份认证主要有两种方式：</p> 
<ul><li> <p>token + localStorage</p> </li><li> <p>session + cookie</p> </li></ul> 
<h4>一、身份认证流程</h4> 
<ol><li> <p>当后端判断用户登录成功后，后端服务器中需要生成一个 token（令牌），返回给前端；</p> </li><li> <p>前端接收到后端返回的 token 后，保存到 localStorage。</p> </li><li> <p>后续在需要权限的页面中，发送的任何 AJAX 请求，都需要携带 token 到后端进行验证；</p> </li></ol> 
<h4>二、后端生成 token</h4> 
<p>Express 的后端项目中，我们需要借助 <code>jsonwebtoken</code> 插件来实现 token 的生成。</p> 
<p>1、下载插件</p> 
<p>在后端项目根目录执行以下命令下载插件：</p> 
<pre>npm i jsonwebtoken
</pre> 
<p>2、引入插件</p> 
<p>在需要生成 token 的 <code>.js</code> 文件中，引入插件：(后台controller中)</p> 
<pre>const jwt = require('jsonwebtoken');
</pre> 
<p>3、生成并返回 token</p> 
<p>判断用户登录成功后，调用 <code>sign()</code> 方法生成 token，并将 token 返回给前端：</p> 
<pre>module.exports.login = async (params) =&gt; {
    const data = await usersModel.find(params);
    if(data.length === 1) {
        // 生成 token
        const token = jwt.sign(
            { user: data[0] },   // 保存的用户信息
            'hello',             // 密钥，任意字符串
            { expiresIn: 10 }    // 设置 token 的有效期，数字默认单位为秒（字符串必须带单位）
        );
        return {
            code: 1,
            message: '登录成功',
            token: 'Bearer ' + token  // 返回 token 到前端
        }
    }
    return {
        code: 0,
        message: '登录失败'
    }
}
</pre> 
<p>4、前端保存 token</p> 
<pre>// 登录
$('#loginBtn').click(async function () {
    const account = $('#account').val();
    const password = $('#password').val();
    const res = await loginAsync({ account, password });
    if (res.code) {
        alert('登录成功');
        localStorage.token = res.token;   // 保存 token
        location.href = './home.html';
    } else {
        alert('登录失败');
    }
})
</pre> 
<h4>三、前端发送 token</h4> 
<p>在需要登录权限的页面中，发送的所有 AJAX 请求都需要将 token 携带在请求头中，然后一并发送到后端进行验证。</p> 
<p>1、统一处理 AJAX</p> 
<p>为了一次性给所有的 AJAX 的请求头都添加上 token，我们在前端项目的 src 目录中创建一个 <code>utils/ajaxUtils.js</code> 文件，专门用来处理所有 AJAX 的请求头：</p> 
<pre>$.ajaxSetup({
    // 统一处理所有的 AJAX 的请求头
    headers: {
        Authorization: localStorage.token
    },
    // 统一处理所有的 AJAX 的错误情况
    error(err) {
        if (err.status === 401) {
             alert('请重新登录')；
            location.href = './login.html';
        }
    }
})
</pre> 
<p>然后在首页的 <code>home.js</code> 中引入该文件：</p> 
<pre>import '../sass/home.scss';
import '../sass/menu.scss';
// 引入 AJAX 的处理文件
import '../utils/ajaxUtils.js';
import './menu.js';
import './movies.js';
import './types.js';
import './cinemas.js';
import './theaters.js';
import './users.js';
</pre> 
<p>2、浏览器查看请求头</p> 
<p>处理完成后，后续首页发送的所有请求，我们都可以在浏览器的 Network 里查看到请求头中的 token：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/df/87/rqQBvyf9_o.png"></p> 
<h4>四、后端验证 token</h4> 
<p>1、下载验证插件</p> 
<pre>npm i express-jwt
</pre> 
<p>2、配置验证</p> 
<p>我们在后端项目根目录中创建一个 <code>utils/jwtAuth.js</code> 文件，然后进行如下配置：</p> 
<pre>const { expressjwt } = require('express-jwt');
module.exports = expressjwt({
    secret: 'hello',  // 密钥（跟生成 token 时的密钥一致）
    algorithms: ['HS256'],   // 设置 JWT 的算法为 HS256（固定）
    // 首先，只要请求头中携带了 token，jwt 都会进行验证，credentialsRequired 主要是针对没有携带 token 的请求。
    // false：如果请求头中没有 token，则不进行任何验证，直接通过；
    // true：如果请求头中没有 token，依然要进行验证，直接不通过；
    credentialsRequired: true
}).unless({
    // 用来设置不需要验证的请求的 URL
    path: [
        '/users/login', 
        '/users/register', 
        // /\/images/
    ]
})
</pre> 
<p>最后，在 <code>app.js</code> 中引入配置文件，并应用配置：</p> 
<pre>const { expressjwt } = require('express-jwt');
module.exports = expressjwt({
    secret: 'hello',  // 密钥（跟生成 token 时的密钥一致）
    algorithms: ['HS256'],   // 设置 JWT 的算法为 HS256（固定）
    // 首先，只要请求头中携带了 token，jwt 都会进行验证，credentialsRequired 主要是针对没有携带 token 的请求。
    // false：如果请求头中没有 token，则不进行任何验证，直接通过；
    // true：如果请求头中没有 token，依然要进行验证，直接不通过；
    credentialsRequired: true
}).unless({
    // 用来设置不需要验证的请求的 URL
    path: [
        '/users/login', 
        '/users/register', 
        // /\/images/
    ]
})
</pre> 
<h4>五、获取用户信息</h4> 
<p>通常在进入系统首页时，都需要显示用户信息。</p> 
<p>所以，我们会在已进入页面时就发送一个 AJAX 请求来获取用户信息。</p> 
<pre>// 在前端usersAPI.js
export function getUserInfoAsync() {
    return new Promise((resolve) =&gt; {
        $.ajax({
            url: '/api/users/getUserInfo',
            success(res) {
                resolve(res);
            }
        })
    })
}
</pre> 
<pre>//  在前端js/home.js文件里面引入init.js 后，前端 js文件中的init.js，
import { getUserInfoAsync } from '../api/usersAPI.js'
getUserInfo();
// 获取用户信息
async function getUserInfo() {
    const res = await getUserInfoAsync();
    if(res.code) {
        $('#username').text(res.data.name);
    }
}
</pre> 
<pre>//home.html中加上
 &lt;header&gt;
 	欢迎你，&lt;p id="username"&gt;&lt;/p&gt;
  &lt;/header&gt;
</pre> 
<p></p> 
<p>后端解码 token</p> 
<pre>const jwt = require('jsonwebtoken');
router.get('/getUserInfo', async function(req, res) {
    // 获取请求头的 token
    const tokenBearer = req.get('Authorization');
    const token = tokenBearer.split(" ")[1];
    // 对 token 解码，获取 token 中的用户信息
    const { user } = jwt.verify(token, 'hello');
    res.send({
        code: 1,
        message: '用户信息获取成功',
        data: user
    })
})
</pre> 
<h2>13 -《RESTful》</h2> 
<p>RESTful，一种前后端接口命名的规范。</p> 
<p>在 RESTful 之前，我们的接口通常是由两部分组成：</p> 
<ul><li> <p>一级接口：表示要请求的资源（数据）名称</p> </li><li> <p>二级接口：表示对资源进行的操作</p> </li></ul> 
<p>在 RESTful 中，要求接口只有一个部分，用来表示要请求的资源（数据）名称。</p> 
<p>例如，所有关于电影的请求，接口都是 <code>/movies</code>。</p> 
<p>但是，我们为了区别对同一个集合数据的不同操作，RESTful 中又引入了两种新的请求类型：PUT、DELETE。</p> 
<h4>一、请求类型</h4> 
<p>RESTful 中，常用的请求类型主要有以下四个：</p> 
<ul><li> <p>GET：获取数据</p> </li><li> <p>POST：新增数据</p> </li><li> <p>PUT：修改数据</p> </li><li> <p>DELETE：删除数据</p> </li></ul> 
<p>例如我们要对电影数据进行 CRUD 操作，接口参考如下：</p> 
<ul><li> <p>获取电影数据：GET /movies</p> </li><li> <p>新增电影数据：POST /movies</p> </li><li> <p>修改电影数据：PUT /movies</p> </li><li> <p>删除电影数据：DELETE /movies</p> </li></ul> 
<pre>$.ajax({
    url: '/movies',
    type: 'DELETE',
    data: { _id: '1' },
    success(res) {
    }
})
</pre> 
<h4>二、请求参数中有 id</h4> 
<p>在 RESTful 中，如果请求的参数中有唯一值 id，我们可以将 id 通过 url 来进行发送。</p> 
<p>例如，我们要根据电影 id 来获取电影：</p> 
<pre>$.ajax({
    url: '/movies/1',
    type: 'GET',
    success(res) {
    }
})
</pre> 
<p>Express 后端在接收参数时，就需要在路径中定义变量名来接收 URL 中的参数：</p> 
<pre>// 根据 _id 获取电影数据
router.get('/:_id', async function(req, res) {
    const params = req.params;   // { _id: 1 }
    // ...
})
</pre> 
<h2>14 -《跨域》</h2> 
<h4>一、域（源）</h4> 
<p>一个域，应该是由三部分组成：</p> 
<ol><li> <p>协议：http/https</p> </li><li> <p>IP：每一台计算机都应该有一个唯一的 IP 地址，例如：localhost、192.168.1.100</p> </li><li> <p>端口：计算机中安装或启动的每一个应用程序，都应该有一个唯一的端口号。例如：3000、8080…</p> </li></ol> 
<p>例如我们课堂项目影院管理系统所在的域是：<code>http://localhost:8080</code>，而影院的后端服务器所在的域是：<code>http://localhost:3000</code>。</p> 
<h4>二、同源策略</h4> 
<p>在浏览器中，处于安全考虑，要求我们只能在相同的域之间进行访问。意思是：在一个页面中发送请求时，当前页面的域的协议、IP、端口，和页面中发送的请求路径的协议、IP、端口，三者必须一致。只要有一个不一样，则为“不同源”，不同源，就属于跨域访问。</p> 
<p>这个就是浏览器的“同源策略”。默认情况下，浏览器不支持跨域访问。</p> 
<h4>三、跨域的概念</h4> 
<p>简单来说，就是当我们从一个域向一个域发送请求，但是两个域之间协议、IP、端口三者有一个不一致，则形成了跨域。</p> 
<h4>四、跨域的解决方案</h4> 
<p>跨域的解决方案分为以下几种：</p> 
<ol><li> <p>通过 webpack 配置开发服务器的 proxy（只能用于开发环境）；</p> </li><li> <p>JSONP：只支持 GET 请求；</p> </li><li> <p>CORS</p> </li><li> <p>代理服务器</p> </li></ol> 
<p>JSONP</p> 
<p>前端发送 AJAX 请求时，添加 <code>dataType</code> 属性：</p> 
<pre>$.ajax({
    url: 'http://localhost:8080/movies',
    type: 'GET',
    dataType: 'jsonp',
    data,
    success(res) {
        resolve(res);
    }
})
</pre> 
<p>后端在返回结果给前端时，<code>res.send()</code> 改为 <code>res.jsonp()</code>。</p> 
<pre>router.get('/', async function (req, res, next) {
    const data = await getMovies(req.query);
    res.jsonp(data);
});
</pre> 
<p>CORS</p> 
<p>在后端中配置以下代码即可：</p> 
<pre>// CORS 配置跨域
var allowCrossDomain = function (req, res, next) {
    // 设置允许跨域访问的请求源（* 表示接受任意域名的请求）   
    res.header("Access-Control-Allow-Origin", "*");
    // 设置允许跨域访问的请求头
    res.header("Access-Control-Allow-Headers", "X-Requested-With,Origin,Content-Type,Accept,Authorization");
    // 设置允许跨域访问的请求类型
    res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
    // 同意 cookie 发送到服务器（如果要发送cookie，Access-Control-Allow-Origin 不能设置为星号）
    res.header('Access-Control-Allow-Credentials', 'true');
    next();
};
app.use(allowCrossDomain); 
// 后续开始配置 token、一级接口等
</pre> 
<h4>五、跨域相关面试题</h4> 
<ol><li> <p>JSONP 的原理。</p> </li></ol> 
<p>因为 script、link、img 等标签天生就支持跨域，JSONP 的原理就是利用 script 来发送跨域请求。</p> 
<h2>15 -《一次完整的 HTTP 事务》</h2> 
<p>当用户在浏览器的地址栏中输入 URL 后，发生了什么事情？</p> 
<ol><li> <p>域名解析：将域名解析成对应的 IP 地址；</p> </li><li> <p>建立连接：通过 TCP 协议进行三次握手，来建立前后端之间的连接；</p> </li><li> <p>前端发送请求</p> </li><li> <p>后端处理请求：将前端请求的数据返回给浏览器；</p> </li><li> <p>断开连接：通过 TCP 协议进行四次挥手，来断开前后端之间的连接；</p> </li><li> <p>浏览器渲染页面</p> </li></ol> 
<h2>16 -《Git 基本使用》</h2> 
<p>Git，版本控制系统。</p> 
<h4>一、工作流程</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/81/74/UIAXFG70_o.png"></p> 
<h4>二、工作步骤</h4> 
<p>1、初始化</p> 
<p>配置账号和邮箱。</p> 
<p>在 Git 终端的任意路径中，执行以下命令：</p> 
<pre>git config --global user.name "xuhao"
git config --global user.email "654240464@qq.com"
</pre> 
<p>2、创建远程仓库</p> 
<p>在码云中注册账号，然后创建远程仓库。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/29/39/vMn0AwTD_o.png"></p> 
<p>成员管理</p> 
<p>远程仓库创建完成后，进入仓库的管理界面，邀请添加项目成员。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6b/7f/fILmPMfD_o.png"></p> 
<p>3、克隆远程仓库</p> 
<p>复制远程仓库地址：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/aa/7d/Te6cm1Uo_o.png"></p> 
<p>然后打开 Git 终端，定位到想要存放项目的目录路径，然后执行以下命令，将远程仓库克隆到本地：</p> 
<pre>git clone https://gitee.com/ihavenocat/snail-test.git
</pre> 
<p>4、配置忽略项</p> 
<p>在仓库根目录中创建一个 <code>.gitignore</code> 文件，在该文件中添加需要忽略的文件或文件夹：</p> 
<pre>node_modules
package-lock.json
</pre> 
<p>5、常规操作流程</p> 
<p>1）将工作区的代码添加到暂存区</p> 
<pre>git add .
</pre> 
<p>2）将暂存区的代码提交到本地仓库</p> 
<pre>git commit -m "提交记录描述"
</pre> 
<p>3）将本地仓库的代码推送到远程仓库</p> 
<pre>git push
</pre> 
<p></p> 
<p>最新：</p> 
<p>1.gitee创建远程仓库</p> 
<p>2.git init</p> 
<p>3.git clone <a href="https://gitee.com/ihavenocat/snail-test.git" rel="nofollow" title="https://gitee.com/ihavenocat/snail-test.git">https://gitee.com/ihavenocat/snail-test.git</a></p> 
<h2>17 -《Git 分支操作》</h2> 
<h4>一、新建子分支</h4> 
<p>通常，我们将远程仓库中的 master （主分支）代码克隆到本地后，就可以在 master 的基础上新建自己的本地子分支。</p> 
<pre>git checkout -b jianglan
</pre> 
<h4>二、切换分支</h4> 
<p>查看可切换的分支</p> 
<pre>git branch
</pre> 
<pre> git branch -a
</pre> 
<p>！！！！注意：在切换分支前，确保当前分支的代码已经进行了 add 和 commit 的操作。</p> 
<pre>git checkout master
</pre> 
<h4>三、合并分支</h4> 
<p>首先，将 Git 终端定位到目标分支。</p> 
<p>例如，我们想要将自己的子分支代码合并到 master，那么我们需要切换到 master 中去：</p> 
<pre>git merge jianglan
</pre> 
<p>通常，当我们将自己子分支的代码合并到主分支后，都需要将本地主分支的代码推送（上传）到远程仓库。</p> 
<p>！！！！但是，我们在团队开发中，<strong>每次推送自己的代码时，先拉取（下载）远程仓库中最新的代码。</strong></p> 
<h4>四、拉取远程仓库最新代码</h4> 
<p>拉取远程代码，都是拉取远程 master 主分支的代码。</p> 
<p>所以我们在拉取时，先将本地的分支切换到 master 中，然后再拉取远程 master 的代码：</p> 
<pre>git pull
</pre> 
<h2>18 -《Git 使用流程》</h2> 
<h4>一、创建远程仓库</h4> 
<p>一个小组创建一个远程仓库就可以。</p> 
<p>1、仓库成员管理</p> 
<p>给小组成员设置仓库权限。</p> 
<h4>二、项目初始化</h4> 
<p>可以先让一个同学将远程仓库克隆到本地，然后在本地仓库创建项目。</p> 
<p>同时将所有可能用到的依赖包都进行下载，最后，配置 <code>.gitignore</code> 忽略文件。</p> 
<p>项目初始完成后，将项目上传到远程仓库的 master：</p> 
<pre>git add .
git commit -m '项目初始化'
git push
</pre> 
<h4>三、克隆远程仓库</h4> 
<p>小组内其他成员开始克隆远程仓库到本地。然后在 VSCode 的终端中执行以下命令，下载项目中所有需要用到的依赖包：</p> 
<pre>npm i
</pre> 
<p>小组内所有成员都新建自己的分支：</p> 
<pre>git checkout -b 自己的子分支名
</pre> 
<h4>四、编写代码</h4> 
<p>建议每隔一段时间在子分支中对自己的代码做一个保存：</p> 
<pre> git add .
 git commit -m '相关功能描述'</pre> 
<h4>五、合并代码</h4> 
<p>当我们一个功能写完了，想要将这个代码共享给组员。</p> 
<p>1、本地合并</p> 
<p>在本地子分支中代码编写完成后，先将本地子分支的代码合并到本地主分支：</p> 
<pre> git checkout master
 git merge 自己的子分支名</pre> 
<p>这一步完成后，本地的 master 中就应该有我们自己的全部代码了。</p> 
<p>注意：合并完成后运行代码查看是否有问题，有问题就解决冲突，然后再 add 和 commit。</p> 
<p>2、拉取远程代码</p> 
<p>在本地 master 中，执行以下命令，拉取远程的 master 代码（拉取组内其他成员的代码）：</p> 
<pre>git pull
</pre> 
<p>！！！注意：拉取完成后，也需要运行代码查看是否有问题，有问题就解决冲突，然后再 add 和 commit。</p> 
<p>3、推送本地代码</p> 
<p>确认本地 master 中，自己的代码和其他组员的代码没有冲突后，执行以下命令将本地合并好的代码，上传到远程仓库：</p> 
<pre>git push
</pre> 
<h4>六、继续编写代码</h4> 
<p>回到自己的本地子分支中：</p> 
<pre>git checkout 自己的子分支名
</pre> 
<p>然后将本地 master 的最新代码合并到本地的子分支中：</p> 
<pre>git merge master
</pre> 
<p>注意：合并完成后运行代码查看是否有问题，有问题就解决冲突，然后再 add 和 commit。</p> 
<p>后续，就重复四、五、六的步骤。</p> 
<h2>18-1项目开发在vscode里面拉取，推送代码</h2> 
<p>1.在gitee上项目里新建一个自己的分支 例如新建一个自己的分支apple</p> 
<p>2.在本地新建文件夹拉取代码 命令：</p> 
<p>拉取自己分支名称下的代码：</p> 
<pre>git clone -b apple gitee地址
</pre> 
<p>默认不加-b命令的话拉取的是master分支下的代码：</p> 
<pre>git clone gitee地址
</pre> 
<p>3.开发过程 拉取完就可以进行代码开发了</p> 
<p>4.提交代码 在Vscode中的左侧菜单栏中的第三个就是git管理工具。 <img alt="在这里插入图片描述" src="https://images2.imgbox.com/46/04/A7wZdNjK_o.png"></p> 
<p>1.将修改过的代码添加到暂存区 git add . 点击+号</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a2/ad/YOvykyWF_o.png"></p> 
<p>2.提交代码到本地仓库 git commit -m ‘提交注释信息’</p> 
<p>图中的消息就是注释信息。填完后选择提交即可。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ce/23/RAL3qsJo_o.png"></p> 
<p>3.提交代码之前拉取别的分支的代码</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/e5/bd/lSgyGuJ2_o.png"></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/28/8f/ml2JkoOU_o.png"></p> 
<p>选择origin之后再选择你想要拉取的分支即可。</p> 
<p>4.推送代码 提交完成后等待一会，在Vscode的底部栏的第二个选项可以看到文件等待上传，点击一下圆圈选择确定即可推送成功。第一个选项代表着当前分支。</p> 
<h2>19-新项目配置前端环境</h2> 
<h3>一、新建文件夹</h3> 
<p>新建文件夹（<code>英文名</code>），用<code>VSCode</code>打开文件夹，在项目<code>根目录</code>中，点击<code>在集成终端中打开</code></p> 
<h3>二.项目初始化</h3> 
<p>输入以下代码，项目初始化</p> 
<pre>npm init -y
</pre> 
<p>在生成的<code>package.json</code>文件中，用以下代码，进行覆盖</p> 
<pre>"scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
    "dev": "webpack-dev-server --hot --config webpack.dev.config.js --mode development",
    "build": "webpack --config webpack.prod.config.js --mode production"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "clean-webpack-plugin": "^4.0.0",
    "copy-webpack-plugin": "^10.2.4",
    "css-loader": "^6.7.1",
    "css-minimizer-webpack-plugin": "^3.4.1",
    "html-webpack-plugin": "^5.5.0",
    "mini-css-extract-plugin": "^2.6.0",
    "node-sass": "^7.0.1",
    "sass-loader": "^12.6.0",
    "terser-webpack-plugin": "^5.3.1",
    "webpack": "^5.72.0",
    "webpack-cli": "^4.9.2",
    "webpack-dev-server": "^4.8.1",
    "webpack-merge": "^5.8.0"
  }
</pre> 
<p>输入以下代码，下载<code>package.json</code>文件中所有的依赖包</p> 
<pre>npm i
</pre> 
<h3>三、创建三个文件</h3> 
<p>根目录中创建<code>webpack.base.config.js</code>文件，输入以下代码</p> 
<pre>// 公共配置
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    entry: {
        home: './src/js/home.js',
        login: './src/js/login.js',
        register: './src/js/register.js',
    },
    output: {
        // 配置出口文件的保存路径：项目根目录的 dist
        path: path.resolve(__dirname, 'dist'),
        // 出口文件的名称
        filename: 'js/[name].js'
    },
    module: {
        rules: [
            // 配置 SASS
            {
                test: /\.scss$/i,           // 需要编译以 .scss 为结尾的文件
                exclude: /node_modules/,    // 不需要解析 node_modules
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader',
                    'sass-loader'
                ]
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/home.html',   // 源文件路径
            filename: 'home.html',         // 打包后的文件名
            chunks: ['home']               // 入口文件的名称（当前 HTML 中需要引入的 JS 文件名）
        }),
        new HtmlWebpackPlugin({
            template: './src/login.html',   // 源文件路径
            filename: 'login.html',         // 打包后的文件名
            chunks: ['login']               // 入口文件的名称
        }),
        new HtmlWebpackPlugin({
            template: './src/register.html',   // 源文件路径
            filename: 'register.html',         // 打包后的文件名
            chunks: ['register']               // 入口文件的名称
        }),
        new CopyWebpackPlugin({
            patterns: [
                { from: './src/static', to: './static' }
            ]
        }),
        new MiniCssExtractPlugin({
            filename: 'css/[name].css'
        })
    ],
    performance: {
        hints: false,
    },
}
</pre> 
<p>根目录中创建<code>webpack.dev.config.js</code>文件，输入以下代码</p> 
<pre>// 开发环境配置

// 引入公共配置
const base = require('./webpack.base.config.js');
// 用于合并公共配置和当前环境配置
const { merge } = require('webpack-merge');

module.exports = merge(base, {
    // 开发环境自己的配置
    mode: 'development',
    devtool: 'inline-source-map',
    // 前端的开发服务器
    devServer: {
        port: '9080', // 端口号
        open: 'home.html',

        // 配置跨域：就是为了让前端的 8080 可以访问后端的 3000
        proxy: {
            // 前端项目中所有以 /api 开头的请求，都会进行以下配置：
            "/api": {
                target: "http://localhost:3000",   // 将请求转发到 3000 的服务器
                pathRewrite: {
                    "^/api": "",                   // 将前端所有以 /api 开头的请求，转发到服务器后，都重写为空
                }
            }
        }
    }
})
</pre> 
<p>根目录中创建<code>webpack.prod.config.js</code>文件，输入以下代码</p> 
<pre>// 生产环境配置

const base = require('./webpack.base.config.js');
const { merge } = require('webpack-merge');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const TerserWebpackPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')

module.exports = merge(base, {
    // 生产环境自己的配置
    mode: 'production',
    plugins: [
        new CleanWebpackPlugin()
    ],
    // 生产环境优化
    optimization: {
        minimize: true,
        minimizer: [
            new TerserWebpackPlugin(),
            new CssMinimizerPlugin()
        ]
    }
})
</pre> 
<p>如果报错，有可能是8080被占用，可改端口号解决。</p> 
<h3>四、创建src文件，开始写代码</h3> 
<h2>20-配置后端环境</h2> 
<h3>一、新建文件夹</h3> 
<p>新建文件夹（<code>英文名</code>），用<code>VSCode</code>打开文件夹，在项目<code>根目录</code>中，点击<code>在集成终端中打开</code></p> 
<h3>二、创建 Express 项目</h3> 
<p>将终端的路径定位到项目的根目录，然后执行以下命令：</p> 
<pre>npx express-generator
</pre> 
<p>该命令执行完成后，会自动在项目的根目录中生成 Express 服务端项目的基本结构。</p> 
<h3>三、下载项目所有依赖包</h3> 
<p>将终端的路径定位到项目的根目录，执行以下命令，根据 <code>package.json</code> 文件下载项目需要的所有依赖包：</p> 
<p>先在<code>package.json</code>文件覆盖以下代码</p> 
<pre> "scripts": {
    "start": "nodemon ./bin/www"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "express": "~4.16.1",
    "express-jwt": "^7.7.0",
    "http-errors": "~1.6.3",
    "jade": "~1.11.0",
    "jsonwebtoken": "^8.5.1",
    "mongoose": "^6.3.1",
    "morgan": "~1.9.1",
    "multer": "^1.4.4"
  }
</pre> 
<pre>npm i
</pre> 
<h3>四、<code>app.js</code>中覆盖以下代码</h3> 
<pre> // 通过 npm 下载的第三方插件，以及 Nodejs 自带的插件，在引入时只需要在 require 中写插件名即可。
 var createError = require('http-errors');
 var express = require('express');
 var path = require('path');
 var cookieParser = require('cookie-parser');
 var logger = require('morgan');
 const jwtAuth = require('./utils/jwtAuth.js');
 ​
 // 引入自己创建的文件时，需要通过相对路径去进行查找（.js 后缀名可以省略不写）
 ​
 // 引入mongoose的配置文件，连接 express 和 mongodb
 require('./dao/db.js');
 ​
 // 需要我们自己根据需求编写的（开始） --------------------------------
 var indexRouter = require('./routes/index');
 var usersRouter = require('./routes/users');
 // 需要我们自己根据需求编写的（结束） --------------------------------
 ​
 ​
 var app = express();
 ​
 // view engine setup
 app.set('views', path.join(__dirname, 'views'));
 app.set('view engine', 'jade');
 ​
 app.use(logger('dev'));
 app.use(express.json());
 app.use(express.urlencoded({ extended: false }));
 app.use(cookieParser());
 app.use(express.static(path.join(__dirname, 'public')));
 ​
 // 需要我们自己根据需求编写的（开始）--------------------------------
 ​
 // 让 token 的验证功能生效
 app.use(jwtAuth);
 ​
 // 配置前后端接口的一级路径
 app.use('/', indexRouter);
 app.use('/users', usersRouter);
 // 需要我们自己根据需求编写的（结束） --------------------------------
 ​
 ​
 // catch 404 and forward to error handler
 app.use(function(req, res, next) {
   next(createError(404));
 });
 ​
 // error handler
 app.use(function(err, req, res, next) {
   // set locals, only providing error in development
   res.locals.message = err.message;
   res.locals.error = req.app.get('env') === 'development' ? err : {};
 ​
   // render the error page
   res.status(err.status || 500);
   res.render('error');
 });
 ​
 ​
 module.exports = app;
 ​</pre> 
<h3>五、添加<code>utils</code>、<code>dao</code>、<code>controllers</code>文件夹</h3> 
<h2>如何查看本机IP地址？</h2> 
<p>查机IP地址法如下：1、点击电脑开—运行——<a href="https://so.csdn.net/so/search?q=cmd&amp;spm=1001.2101.3001.7020" title="cmd">cmd</a></p> 
<p>2、点击确定后就进入了dos界面。</p> 
<p>3、输入查看本机ip地址命令 ipconfig /。</p> 
<p>4、输入查看本机ip地址命令ipconfig /all 显示的就是本机的详细信息。</p> 
<p>5、还有一种通过百度来查看本机ip地址的简单方法，首先打开百度。</p> 
<p>6、在<a href="https://so.csdn.net/so/search?q=%E6%90%9C%E7%B4%A2%E6%A1%86&amp;spm=1001.2101.3001.7020" title="搜索框">搜索框</a>中输入本机ip地址点搜索。</p> 
<p>7、在搜索结果中就可以看到所在网络的ip地址了。 电脑的ip地址怎么查你是查网络IP还是IP网络IP在电脑的浏览器上面输入“IP”就示网络IP电脑IP：点击快带链接小图标——在打开网络共享中心 点击更改适配器设置 点击右键点击本地链接——选择状态点击详情信息可看见电脑IP地址 查找本机IP地址方法：1、打开网络共享中心2、查看本地连接属性3、本地连接状态——常规——详细信息4、详细信息里显示本机IP地址</p> 
<p></p> 
<h2>数据处理</h2> 
<p>一、将1000000变为1,000,000</p> 
<pre> (number+ '').replace(/(\d{1,3})(?=(\d{3})+(?:$|\.))/g,'$1,')
 // number为数字</pre> 
<p>二、保留两位小数</p> 
<pre> number.toFixed(2)
 // number为数字</pre> 
<p>三、获取最近count天的日期</p> 
<pre> /**
  * 获取最近count天的日期
  * @param count 天数
  * @returns {*[]} 两个时间点
  */
 export function getLateDate(count) {
   let time1 = new Date();
   time1.setTime(time1.getTime() - 24 * 60 * 60 * 1000);
   let Y1 = time1.getFullYear();
   let M1 =
     time1.getMonth() + 1 &gt; 9
       ? time1.getMonth() + 1
       : "0" + (time1.getMonth() + 1);
   let D1 = time1.getDate() &gt; 9 ? time1.getDate() : "0" + time1.getDate();
   let timer1 = Y1 + "-" + M1 + "-" + D1; // 当前时间
   let time2 = new Date();
   time2.setTime(time2.getTime() - 24 * 60 * 60 * 1000 * count);
   let Y2 = time2.getFullYear();
   let M2 =
     time2.getMonth() + 1 &gt; 9
       ? time2.getMonth() + 1
       : "0" + (time2.getMonth() + 1);
   let D2 = time2.getDate() &gt; 9 ? time2.getDate() : "0" + time2.getDate();
   let timer2 = Y2 + "-" + M2 + "-" + D2; // 之前的7天或者30天
   return [timer1, timer2];
 }
 ​
 /**
  * 获取最近count天到count+count的日期
  * @param count 天数
  * @returns {*[]} 两个时间点
  */
 export function getLateDateLast(count) {
   let time1 = new Date();
   time1.setTime(time1.getTime() - 24 * 60 * 60 * 1000 * (count+1));
   let Y1 = time1.getFullYear();
   let M1 =
     time1.getMonth() + 1 &gt; 9
       ? time1.getMonth() + 1
       : "0" + (time1.getMonth() + 1);
   let D1 = time1.getDate() &gt; 9 ? time1.getDate() : "0" + time1.getDate();
   let timer1 = Y1 + "-" + M1 + "-" + D1; // 之前的7天或者30天
 ​
   let time2 = new Date();
   time2.setTime(time2.getTime() - 24 * 60 * 60 * 1000 * count*2);
   let Y2 = time2.getFullYear();
   let M2 =
     time2.getMonth() + 1 &gt; 9
       ? time2.getMonth() + 1
       : "0" + (time2.getMonth() + 1);
   let D2 = time2.getDate() &gt; 9 ? time2.getDate() : "0" + time2.getDate();
   let timer2 = Y2 + "-" + M2 + "-" + D2; // 之前的7天或者30天
   return [timer1, timer2];
 }</pre> 
<h2>AES加密+md5加密</h2> 
<p>一、引入srypto-js.js和md5.js文件（文件参考AH-MemberSystem/js/common/crypto-js.js和md5.js）</p> 
<pre>  &lt;script src="./js/common/crypto-js.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
  &lt;script src="js/common/md5.js" type="text/javascript"&gt;&lt;/script&gt;</pre> 
<p>二、定义方法</p> 
<pre> //广电鉴权AES加密base64
 function aesEncryptBase64 (data, key, iv) {
   var key = CryptoJS.enc.Utf8.parse(key);
   var iv = CryptoJS.enc.Utf8.parse(iv);
   var data = CryptoJS.enc.Utf8.parse(data);
   var encrypted = CryptoJS.AES.encrypt(data, key, {
     iv: iv,
     mode: CryptoJS.mode.CBC,
     padding: CryptoJS.pad.Pkcs7
   });
   var oldHexStr = CryptoJS.enc.Hex.parse(encrypted.ciphertext.toString().toUpperCase());
   return CryptoJS.enc.Base64.stringify(oldHexStr);
 }
 ​</pre> 
<p>三、调用方法</p> 
<pre> var aesData = {"transactionID":"00000001202005151022290000006571","platformID":"00000002","opFlag":"3","epgFlag":"1","customerType":"0","userAccount":"test20220423","userToken":"777777yyyy09Mo0242270b4e3f1d1765f82db","contentID":"content000000000000000012354","categoryID":"","serviceID":"","productID":"packageIDa0000000000000000000010,packageIDa0000000000000000000011","timeStamp":"1631929181808","deviceID":"","ip":"","mac":""}
 var aesStr = JSON.stringify(aesData) 
 var aesRes = aesEncryptBase64(aesStr,'ahbcforbytuetech','ahbcforbytuetech')
 var md5Data = hex_md5(aesRes)
  console.log('加密后',aesRes);
  console.log('md5',md5Data);</pre> 
<p>四、对比网站结果</p> 
<p><strong><em>*加密方法*</em></strong></p> 
<h3><strong>1.1</strong> <strong><em>*调用接口参数加密*</em></strong></h3> 
<p>AES加密模式: CBC</p> 
<p>填充:pkcs7padding</p> 
<p>数据块:128位</p> 
<p>密码: ahbcforbytuetech</p> 
<p>偏移量:ahbcforbytuetech</p> 
<p>输出:base64</p> 
<p>字符集:utf8</p> 
<p>AES : <a href="http://tool.chacuo.net/cryptaes" rel="nofollow" title="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a></p> 
<p>MD5 : <a href="https://md5jiami.51240.com/" rel="nofollow" title="MD5在线加密 - MD5加密工具 - MD5在线生成">MD5在线加密 - MD5加密工具 - MD5在线生成</a></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3><strong>1.2</strong> <strong><em>*请求接口示例*</em></strong></h3> 
<p>明文</p> 
<p>{"transactionID":"00000001202005151022290000006571","platformID": "00000002","opFlag":"3","epgFlag":"1","customerType": "0","userAccount":"test20220423","userToken": "777777yyyy09Mo0242270b4e3f1d1765f82db","contentID": "content000000000000000012354","categoryID":"","serviceID": "","productID":"packageIDa0000000000000000000010,packageIDa0000000000000000000011","timeStamp":"1631929181808","deviceID":"","ip": "","mac": ""}</p> 
<p>加密后</p> 
<p>{"ENCRYPT":"37O4WRcP+b8qcfl77XySz6TNBji0ifmc5jSQoOzsnrv1AnQj2xqziiYEWCLTpC87USrMkemeJ4x+n4AMh5E0RDoywBKbzQYKddvaeuY3Nk4B5w7nwqXriEpjLVGDMfJsKl6Cauek85vcnOTNOxjn/ndhRNjH/5myUBE7rzJ0t9Cf4DgGmgulVSqKg/1iiiygPpIt6XwzG1N0JMuVMPU/FgjJ83M8cjFBT9wixd36d1eeMXXQnhpbMytLQudRrcLzFCtkNtftqGUJAHeD+TFBOvi9f0/j2sleus0PF0FQDaULxywK8om6GHXrc0DppfVaFkx5SiaZzFrkC6Lzal0lwIxY/3h1FPJnpxybGYB+pxywOhUFTWBcf9W45p9HjJDDGtylfNBDBOAPgezk+WtqJ2egg8px6CmlNRY1E8/Gx7GngJPxLfQeOXV/nZclopsi/ymnoPH2E87sT+4fDubj6IumewofCF4CYBAQCZNsQOERUf1aAqzd+EZVcuvpKVEAiImWSSviP7biPIGBDIRTqRGQFVVIHuDDm+3bbvfUUed0Trm0jgq3RaWkknO71De3hU6TqYD4N5HG2rH4RsZinWOLsBlZPslpWxqXkWdh9nc=","SUMMARY":"157668573168766865cd94e84e88b92d"}</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59bd1447b9c0e601857a59c6912fd802/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">carla学习笔记(十)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09e86df1d5ec3860949c774637a4927e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BombLab 解题思路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>