<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker Compose Yaml（Yml） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker Compose Yaml（Yml）" />
<meta property="og:description" content="Docker Hub 镜像 一、docker-compose.yaml(yml)模板 Docker Hub mysql 镜像 version: &#34;3.9&#34; # compose版本号 services: db: # 单个服务标识(名字) container_name: mysql # 启动后的容器名称 相当于 --name 指定的名称 image: mysql:8 # 镜像 ports: # 端口映射,前者是宿主机端口，后者是容器端口 - 10000:3306 environment: # 指定启动的环境 MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: realworld #自动创建名为realworld的数据库 # env_file:	# 使用文件进行代替 # - ./mysql.env	# mysql.env文件内容就是MYSQL_ROOT_PASSWORD=root volumes: # 表示目录映射关系（前者是宿主机目录，后者是dockker的db容器内的目录) - ./data:/var/lib/mysql # 容器内的数据持久化到主机当前目录(当前yaml文件所在目录)的data目录下 depends_on: - redis restart: - on-failure # no：是默认的重启策略，在任何情况下都不会重启容器。 # always：容器总是重新启动。 # on-failure：在容器非正常退出时（退出状态非0），才会重启容器。 # unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 command: [ &#39;--character-set-server=utf8&#39;, &#39;--collation-server=utf8_unicode_ci&#39; ] healthcheck: # 健康检查 test: [&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/10b709535e9cf6820431727639ec57fe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-13T18:22:13+08:00" />
<meta property="article:modified_time" content="2023-10-13T18:22:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker Compose Yaml（Yml）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://hub.docker.com/" rel="nofollow" title="Docker Hub">Docker Hub</a> 镜像</h2> 
<h2>一、docker-compose.yaml(yml)模板</h2> 
<h4><a href="https://hub.docker.com/_/mysql" rel="nofollow" title="Docker Hub mysql">Docker Hub mysql</a> 镜像</h4> 
<pre><code class="language-bash">version: "3.9"        # compose版本号
services:
  db:                            # 单个服务标识(名字)
    container_name: mysql        # 启动后的容器名称 相当于 --name 指定的名称
    image: mysql:8               # 镜像
    ports:                       # 端口映射,前者是宿主机端口，后者是容器端口
      - 10000:3306
    environment:                 # 指定启动的环境
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: realworld   #自动创建名为realworld的数据库
    #  env_file:					# 使用文件进行代替
    #  - ./mysql.env				# mysql.env文件内容就是MYSQL_ROOT_PASSWORD=root
    volumes:                        # 表示目录映射关系（前者是宿主机目录，后者是dockker的db容器内的目录)
      - ./data:/var/lib/mysql       # 容器内的数据持久化到主机当前目录(当前yaml文件所在目录)的data目录下
    depends_on:
      - redis
    restart:
      - on-failure    # no：是默认的重启策略，在任何情况下都不会重启容器。
                      # always：容器总是重新启动。
                      # on-failure：在容器非正常退出时（退出状态非0），才会重启容器。
                      # unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器
    command: [
      '--character-set-server=utf8',
      '--collation-server=utf8_unicode_ci'
    ]
    healthcheck:            # 健康检查
      test: ["CMD", "mysqladmin" ,"ping", "--protocol=tcp"]
      timeout: 20s
      interval: 1s
      retries: 20
  
  redis:
    image: redis:latest
    ports:
      - 10010:6379
    healthcheck:
      test: ["CMD", "redis-cli","ping"]
      interval: 20s
      timeout: 1s
      retries: 20
  
  memcached:
    image: memcached
    ports:
      - 10086:11211
    healthcheck:
      test: ["CMD", "echo", "stats", "|",  "nc", "127.0.0.1", "11211"]
      interval: 20s
      timeout: 1s
      retries: 20</code></pre> 
<h4>Mongo镜像</h4> 
<p>mongo默认是没有用户的，可以进行配置</p> 
<p>首先创建宿主机挂载目录（选择性进行配置）</p> 
<pre><code class="language-bash">#mongo数据目录
mkdir /opt/dockerstore/mongo/data
#mongo日志目录
mkdir /opt/dockerstore/mongo/logs
# 创建 mongodb 的配置文件，用于映射 docker 镜像内的配置文件
mkdir /opt/dockerstore/mongo/mongod.conf
</code></pre> 
<h5>1、docker启动</h5> 
<h6> 1）、使用docker启动</h6> 
<pre><code class="language-bash"># 拉取MongoDB最新版本的镜像
docker pull mongo   #执行不执行此条命令，docker run 都会自动拉取镜像
# 由于命令太长，为了方便阅读，采用反斜线（\）换行
docker run --name mymongo -p 27017:27017 \
	-v /app/mongo/data:/data/db \
	-v /app/mongo/logs:/var/log/mongodb \
	-v /app/mongo/mongod.conf:/etc/mongod.conf \
	-d mongo --auth
</code></pre> 
<h6>2）、使用docker compose启动 </h6> 
<pre><code class="language-bash">version: '3.9'

services:
  mongodb:                                # 服务名称为 mongodb，该名称主要用于容器之间服务的 dns 解析
    image: mongo:latest                    # 使用的镜像名称
    restart: always                        # 当 docker 服务启动后，自动启动 mongodb 容器
    container_name: mongodb                # 容器的名称为 mymongo
    ports:
      - "27017:27017"
    environment:
      TZ=Asia/Shanghai                     #将时区设置为Asia/Shanghai
      MONGO_INITDB_DATABASE=demo           #将数据库名设置为demo
      MONGO_INITDB_ROOT_USERNAME: demo     #将用户名设置为demo  
      MONGO_INITDB_ROOT_PASSWORD: 111111   #将密码设置为111111

    volumes:                                # 宿主机硬盘目录映射容器内的路径
      - /opt/dockerstore/mongo/data:/data/db
      #- /opt/dockerstore/mongo/logs:/var/log/mongodb
      #- /root/mongo/mongod.conf:/etc/mongod.conf
    
    # 增加启动参数，--auth，表示连接 mongodb 需要用户名和密码
    #command:
      #- "--auth"
    </code></pre> 
<h5 id="devmenu3">2、创建用户和库</h5> 
<p>首先了解mongo角色权限</p> 
<table><thead><tr><th><strong>role</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>read</td><td>允许用户读取指定数据库</td></tr><tr><td>readWrite</td><td>允许用户读写指定数据库</td></tr><tr><td>dbAdmin</td><td>允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</td></tr><tr><td>userAdmin</td><td>允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</td></tr><tr><td>clusterAdmin</td><td>只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限</td></tr><tr><td>readAnyDatabase</td><td>只在admin数据库中可用，赋予用户所有数据库的读权限</td></tr><tr><td>readWriteAnyDatabase</td><td>只在admin数据库中可用，赋予用户所有数据库的读写权限</td></tr><tr><td>userAdminAnyDatabase</td><td>只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</td></tr><tr><td>dbAdminAnyDatabase</td><td>只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</td></tr><tr><td>root</td><td>只在admin数据库中可用。超级账号，超级权限</td></tr></tbody></table> 
<p>注意：clusterAdmin、readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase、root角色只能用于admin数据库<br> 否则报以下错误（demo是非admin数据库）：</p> 
<blockquote> 
 <p>uncaught exception: Error: couldn’t add user: Could not find roles: userAdminAnyDatabase@rad_app, readWriteAnyDatabase@rad_app</p> 
</blockquote> 
<p>执行命令进入mongo容器</p> 
<pre><code class="language-bash">docker exec -it mongodb /bin/bash
</code></pre> 
<p>进入容器后连接mongo客户端 </p> 
<pre><code class="language-bash">mongo admin
</code></pre> 
<p>进入客户端后创建用户 </p> 
<pre><code class="language-bash">#使用demo库，如果不存在会创建
use demo;
#创建用户并赋予角色权限
db.createUser({user:'demo_user',pwd:'123',roles:[{role:'userAdmin',db:'demo'},"readWrite"]});
</code></pre> 
<p></p> 
<p></p> 
<h4 id="devmenu7">解决方案</h4> 
<ol><li>第一次启动容器，配置文件去除–auth命令</li><li>执行创建用户命令，创建用户和库</li><li>修改配置文件，加上–auth命令</li><li>重新启动容器，执行授权命令后就可操作数据库</li></ol> 
<p></p> 
<p>至此，mongoDB安装并配置完成</p> 
<h4><a class="link-info" href="https://hub.docker.com/r/portainer/portainer-ce" rel="nofollow" title="Docker Hub Portainer镜像">Docker Hub Portainer镜像</a></h4> 
<p>使用portainer_data 卷时，必须先创建才能使用</p> 
<pre><code class="language-bash"># 创建卷portainer_data（卷名自己定）
$ docker volume create portainer_data
portainer_data
# 查询portainer_data卷的详细信息
$ docker volume inspect portainer_data
[
    {
        "CreatedAt": "2022-11-09T15:39:45+08:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/portainer_data/_data",  # 创建portainer_data卷默认所在位置
        "Name": "portainer_data",
        "Options": {},
        "Scope": "local"
    }
]
</code></pre> 
<pre><code class="language-bash">version: "3.9"    # compose版本
services: # 加入服务
  portainer:     # 单个服务标识(名字)
    container_name: portainer      # 启动后的容器名称 相当于 --name 指定的名称
    image: portainer/portainer-ce:latest   # 镜像
    ports:
      - 8000:8000    # 端口映射，前者是宿主机端口，后者是容器端口
      - 9443:9443
    volumes:         # 指定对应的数据卷  前者是宿主机目录，后者是容器目录
      - /var/run/docker.sock:/var/run/docker.sock    # 数据文件挂载
      - /var/lib/docker/volumes/portainer_data:/data     # Portainer Server用于存储其数据库的卷
    restart: always
      </code></pre> 
<p><strong>Docker compose常用命令解释如下：</strong></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:650px;"><caption>
   Docker compose常用命令 
 </caption><thead><tr><th style="text-align:center;vertical-align:middle;">指令</th><th style="text-align:center;">    说明</th></tr></thead><tbody><tr><td style="text-align:center;vertical-align:middle;">up</td><td style="text-align:center;"> <p>          docker compose up -f yml文件名 -d</p> <p>                                                                      #  启动所有的docker compose服务<br>                                                                       #  -f ：表示指定启动的文件名</p> <p>                                                                      #  -d：表示后台启动</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">down</td><td style="text-align:center;"> <p>           docker compose down                       # 停止服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">exec</td><td style="text-align:center;"> <p>           docker compose exec 服务id bash                  # 进入容器</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">ps</td><td style="text-align:center;"> <p>           docker compose ps                            # 查看所有运行的服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">restart</td><td style="text-align:center;"> <p>           docker compose restart 服务id     </p> <p>                                                                      #  重启所有服务 </p> <p>                                                                      #  加上服务id 表示重启单个服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">rm</td><td style="text-align:center;"> <p>           docker compose rm -fv 服务id</p> <p>                                                                      #  删除服务<br>                                                                       #  加服务id 删除单个服务<br>                                                                       #  -fv 强制删除（v 包括数据卷）</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">start</td><td style="text-align:center;"> <p>           docker compose start 服务id                      # 启动服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">stop</td><td style="text-align:center;"> <p>           docker compose stop 服务id                      # 停止服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">top</td><td style="text-align:center;"> <p>           docker compose top 服务id             # 查看容器内运行的进程</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">pause</td><td style="text-align:center;vertical-align:middle;"> <p>           docker compose pause 服务id                   # 暂停服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">unpuase</td><td style="text-align:center;vertical-align:middle;"> <p>           docker-compose unpause 服务id              #  开启服务</p> </td></tr><tr><td style="text-align:center;vertical-align:middle;">logs</td><td style="text-align:center;vertical-align:middle;"> <p>           docker-compose logs 服务id                     #  查看日志</p> </td></tr></tbody></table> 
<p><strong>可以通过 <code class="language-plaintext"><span style="color:#1a439c;">docker compose --help </span></code>从命令行运行来查看命令信息。</strong></p> 
<pre><code class="language-bash">Define and run multi-container applications with Docker.

#使用示例
Usage:
  docker compose [-f &lt;arg&gt;...] [--profile &lt;name&gt;...] [options] [COMMAND] [ARGS...]
  docker compose -h|--help

Options:
  -f, --file FILE             Specify an alternate compose file
                              (default: docker-compose.yml)
  -p, --project-name NAME     Specify an alternate project name
                              (default: directory name)
  --profile NAME              Specify a profile to enable
  --verbose                   Show more output
  --log-level LEVEL           DEPRECATED and not working from 2.0 - Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
  --no-ansi                   Do not print ANSI control characters
  -v, --version               Print version and exit
  -H, --host HOST             Daemon socket to connect to

  --tls                       Use TLS; implied by --tlsverify
  --tlscacert CA_PATH         Trust certs signed only by this CA
  --tlscert CLIENT_CERT_PATH  Path to TLS certificate file
  --tlskey TLS_KEY_PATH       Path to TLS key file
  --tlsverify                 Use TLS and verify the remote
  --skip-hostname-check       Don't check the daemon's hostname against the
                              name specified in the client certificate
  --project-directory PATH    Specify an alternate working directory
                              (default: the path of the Compose file)
  --compatibility             If set, Compose will attempt to convert deploy
                              keys in v3 files to their non-Swarm equivalent

Commands:
  build              Build or rebuild services
  bundle             Generate a Docker bundle from the Compose file
  config             Validate and view the Compose file
  create             Create services
  down               Stop and remove containers, networks, images, and volumes
  events             Receive real time events from containers
  exec               Execute a command in a running container
  help               Get help on a command
  images             List images
  kill               Kill containers
  logs               View output from containers
  pause              Pause services
  port               Print the public port for a port binding
  ps                 List containers
  pull               Pull service images
  push               Push service images
  restart            Restart services
  rm                 Remove stopped containers
  run                Run a one-off command
  scale              Set number of containers for a service
  start              Start services
  stop               Stop services
  top                Display the running processes
  unpause            Unpause services
  up                 Create and start containers
  version            Show the Docker Compose version information</code></pre> 
<blockquote> 
 <p>使用 Docker Compose 二进制文件 ,</p> 
 <pre><code class="language-Go">docker compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre> 
 <p>来构建和管理 Docker 容器中的多个服务。</p> 
</blockquote> 
<p>示例：</p> 
<pre><code class="language-Go">docker compose -f docker-compose.yml -f docker-compose.admin.yml run backup_db</code></pre> 
<div style="margin-left:0;">
  模板完成后，可运行以下命令 
</div> 
<div style="margin-left:0;"> 
 <pre><code class="language-bash">docker compose up -d  #后台启动</code></pre> 
 <p>使用<strong>use mysql;</strong>命令选择数据库后，使用以下命令的其中之一查看用户消息情况</p> 
 <pre><code class="language-bash">$select host,user from user;
$select Host,User,plugin from user;
$select host,user,authentication_string from user\G

eg:
mysql&gt; use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; select Host,User,plugin from user;
+-----------+------------------+-----------------------+
| Host      | User             | plugin                |
+-----------+------------------+-----------------------+
| %         | root             | caching_sha2_password |
| localhost | mysql.infoschema | caching_sha2_password |
| localhost | mysql.session    | caching_sha2_password |
| localhost | mysql.sys        | caching_sha2_password |
| localhost | root             | caching_sha2_password |
+-----------+------------------+-----------------------+
5 rows in set (0.00 sec)
</code></pre> 
 <p><span style="color:#fe2c24;"><strong>注：</strong></span><strong>docker-compose</strong><strong> yaml</strong>文件配置时配置了密码<strong>，</strong>则启动mysql之后，Navicat或<a class="link-info" href="https://github.com/beekeeper-studio/beekeeper-studio" title="beekeeper studio 社区版">beekeeper studio 社区版</a>直接用密码就可以进行远程连接，不需要更改加密方式。如果是从挂起的虚拟机中恢复过来的，则用Navicat远程连接不上，会出现10061或10060错误，<strong>解决办法：重启虚拟机即可连接成功！！！</strong></p> 
 <p><strong>以下命令参考使用</strong></p> 
 <pre><code class="language-bash">1、docker exec -it 容器ID/容器名 bash    #进入mysql的docker容器中
2、mysql -uroot -p      #输入密码进入mysql
3、use mysql;
4、ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';    #将验证方法从auth_socket修改成mysql_native_password，并设置密码，123456 就是密码
5、update user set host = '%' where user = 'root';  #若不允许从远程连接，只能在本地连接。登入mysql后，更改"mysql" 数据库里的 "user" 表里的 "host"项，从"localhost"改称"%" 
6、GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION; #这里表示赋予该用户所有数据库所有表权限（*.*表示所有表，%表示所有IP地址）
7、FLUSH PRIVILEGES;    #刷新权限</code></pre> 
 <h2>二、docker容器命令</h2> 
</div> 
<pre><code class="language-bash">docker exec -it 容器名/容器ID /bin/bash        #进入容器
# 从容器内 退出到自己服务器中 需注意 两个退出命令的区别
#-----直接退出  未添加 -d(持久化运行容器) 时 执行此参数 容器会被关闭  
exit
# 优雅退出 --- 无论是否添加-d 参数 执行此命令容器都不会被关闭
Ctrl + p + q

 
docker start 容器ID/容器名          # 启动容器
docker stop 容器名/容器ID           # 停止之前运行的容器
docker restart 容器ID/容器名        # 重启容器        
docker kill 容器ID/容器名


docker rm -f 容器名/容器ID        # 删除一个容器
docker rm -f 容器名/容器ID 容器名/容器ID 容器名/容器ID       # 删除多个容器 空格隔开要删除的容器名或容器ID
docker rm -f $(docker ps -aq)        # 删除全部容器

#容器文件拷贝 —无论容器是否开启 都可以进行拷贝
# docker cp 容器ID/名称:文件路径  要拷贝到外部的路径   |     要拷贝到外部的路径  容器ID/名称:文件路径
# 从容器内 拷出
docker cp 容器ID/名称: 容器内路径  容器外路径
# 从外部 拷贝文件到容器内
docker  cp 容器外路径 容器ID/名称: 容器内路径

docker load -i 镜像保存文件位置


#可将以下命令写成脚本运行
sudo docker rm -f $(sudo docker ps -aq)
sudo docker network prune
sudo docker volume prune
docker rmi --force `docker images | grep dev-peer | awk '{print $3}'`</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29456e41d520436cff8ff2ad6b4841dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">进阶JAVA篇- BigDecimal 类的常用API（四）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5770dea4a6545f8745e7a9f463d60933/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装docker以及nvidia-container-toolkit</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>