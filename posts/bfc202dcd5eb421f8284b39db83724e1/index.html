<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ros2 基础学习12 分布式通信 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ros2 基础学习12 分布式通信" />
<meta property="og:description" content="智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？
这就是分布式系统，可以实现多计算平台上的任务分配。
分布式通信
什么叫分布式？
之前我们也讲过，在ROS系统中，机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中。
这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。
比如这款机器人系统中，有两个计算平台。
机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用树莓派作为控制器，主要实现传感器驱动和电机控制等功能。
不过视觉处理和应用功能就不适合在树莓派里运行了，我们放在另外一个性能更强的笔记本电脑中。
此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。
两个电脑之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的。
不过ROS系统都已经为我们设计好了，我们只需要在每一个电脑上配置好ROS环境，功能开发上完全不需要做任何变化，实现非常方便。
接下来，我们就带领大家一起来感受下ROS分布式系统的魅力。
分布式网络搭建
除了我使用的笔记本电脑之外，另外一个计算平台我们选择了树莓派，模拟一个放置在机器人上的控制器。
树莓派配置
在开发之前，我们需要先配置好树莓派的环境，网上也有很多资料，大家都可以参考。
装系统
我们先要给树莓派装系统，这里我们选择的是Ubuntu Mate针对树莓派的镜像，下载镜像之后，烧写到树莓派的SD卡中就可以启动系统了。
Ubuntu MATE镜像下载链接：
https://ubuntu-mate.org/download/
安装ROS2
在安装好的Ubuntu Mate系统中，安装ROS2，和电脑端安装的流程一样。
编译代码
将我们课程的代码也下载到树莓派中，进行编译。
远程桌面
如果大家有显示器，可以直接在树莓派上连接键盘鼠标显示器使用，如果使用不方便的话。
也可以在树莓派上配置好远程桌面，就可以通过网络访问树莓派的桌面系统了。
以上步骤的整体流程和电脑端操作基本一致，大家也可以参考如下链接配置树莓派：
https://blog.csdn.net/qq_52785580/article/details/122599728
分布式数据传输
树莓派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？
简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。
Attention
如使用虚拟机，请将虚拟机网络修改为桥接模式
在树莓派端，使用如下命令启动一个发布者节点：
ros2 run demo_nodes_cpp talker #树莓派端 图片
接下来在电脑端，使用如下命令启动一个订阅者节点：
ros2 run demo_nodes_py listener #PC端 神奇的事情就这样发生了，只要两个计算机安装好ROS2，并且处于同一网络中。
他们就可以实现之前讲过的话题、服务、动作等通信了，感觉就像在一个电脑里一样。
不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联。
而是可以分组通信，小组之间是无法实现通信的。
分布式网络分组
没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样。
处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和树莓派端的.bashrc中加入这样一句配置，即可将两者分配到一个小组中：
export ROS_DOMAIN_ID=&amp;lt;your_domain_id&amp;gt; 如果分配的ID不同，则两者无法实现通信。
案例一：小海龟分布式控制
分布式通信网络似乎已经建立成功了，是否真有我们想的这么神奇，我们继续测试之前学习过的一些例程。
先来试试ROS中的经典案例——小海龟。
我们可以在电脑端启动小海龟仿真器，树莓派上启动键盘控制节点，或者反过来也可以，依然可以流畅的控制小海龟运动：
ros2 run turtlesim turtlesim_node # PC端$ ros2 run turtlesim turtle_teleop_key # 树莓派端 案例二：话题分布式通信" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bfc202dcd5eb421f8284b39db83724e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T17:34:59+08:00" />
<meta property="article:modified_time" content="2024-01-02T17:34:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ros2 基础学习12 分布式通信</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>智能机器人的功能繁多，全都放在一个计算机里，经常会遇到计算能力不够、处理出现卡顿等情况，如果可以将这些任务拆解，分配到多个计算机中运行岂不是可以减轻压力？</p> 
</blockquote> 
<p>这就是分布式系统，可以实现多计算平台上的任务分配。</p> 
<p>分布式通信</p> 
<p>什么叫分布式？</p> 
<p>之前我们也讲过，在ROS系统中，机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中。</p> 
<p>这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一。</p> 
<p><img src="https://images2.imgbox.com/ae/b4/EYuAisNd_o.png" alt="图片"></p> 
<p>比如这款机器人系统中，有两个计算平台。</p> 
<p>机器人体积比较小，不适合放一个笔记本电脑在上边，于是采用树莓派作为控制器，主要实现传感器驱动和电机控制等功能。</p> 
<p>不过视觉处理和应用功能就不适合在树莓派里运行了，我们放在另外一个性能更强的笔记本电脑中。</p> 
<p>此外我们还需要在电脑上监控机器人的传感器信息，并且远程控制机器人运动。</p> 
<p>两个电脑之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的。</p> 
<p>不过ROS系统都已经为我们设计好了，我们只需要在每一个电脑上配置好ROS环境，功能开发上完全不需要做任何变化，实现非常方便。</p> 
<p>接下来，我们就带领大家一起来感受下ROS分布式系统的魅力。</p> 
<p>分布式网络搭建</p> 
<p>除了我使用的笔记本电脑之外，另外一个计算平台我们选择了树莓派，模拟一个放置在机器人上的控制器。</p> 
<p>树莓派配置</p> 
<p>在开发之前，我们需要先配置好树莓派的环境，网上也有很多资料，大家都可以参考。</p> 
<p>装系统</p> 
<p>我们先要给树莓派装系统，这里我们选择的是Ubuntu Mate针对树莓派的镜像，下载镜像之后，烧写到树莓派的SD卡中就可以启动系统了。</p> 
<p>Ubuntu MATE镜像下载链接：</p> 
<p>https://ubuntu-mate.org/download/</p> 
<p><img src="https://images2.imgbox.com/6c/ff/oiB1Hxkt_o.png" alt="图片"></p> 
<p>安装ROS2</p> 
<p>在安装好的Ubuntu Mate系统中，安装ROS2，和电脑端安装的流程一样。</p> 
<p><img src="https://images2.imgbox.com/bd/17/GrqbDYVM_o.png" alt="图片"></p> 
<p>编译代码</p> 
<p>将我们课程的代码也下载到树莓派中，进行编译。</p> 
<p><img src="https://images2.imgbox.com/77/10/UlH1vmJG_o.png" alt="图片"></p> 
<p>远程桌面</p> 
<p>如果大家有显示器，可以直接在树莓派上连接键盘鼠标显示器使用，如果使用不方便的话。</p> 
<p>也可以在树莓派上配置好远程桌面，就可以通过网络访问树莓派的桌面系统了。</p> 
<p><img src="https://images2.imgbox.com/cd/7d/7dsldJ3m_o.png" alt="图片"></p> 
<p>以上步骤的整体流程和电脑端操作基本一致，大家也可以参考如下链接配置树莓派：</p> 
<p>https://blog.csdn.net/qq_52785580/article/details/122599728</p> 
<p>分布式数据传输</p> 
<p>树莓派配置完成后，确保已经和你所使用的电脑连接到了同一个局域网络中。接下来我们打通两个计算平台的通信能力。具体需要做什么呢？</p> 
<p>简而言之，什么都不需要做。我们直接用命令行测试一下话题通信的效果。</p> 
<p>Attention</p> 
<p>如使用虚拟机，请将虚拟机网络修改为桥接模式</p> 
<p>在树莓派端，使用如下命令启动一个发布者节点：</p> 
<pre><code class="prism language-cpp">ros2 run demo_nodes_cpp talker  #树莓派端
</code></pre> 
<p>图片</p> 
<p>接下来在电脑端，使用如下命令启动一个订阅者节点：</p> 
<pre><code class="prism language-cpp">ros2 run demo_nodes_py listener #PC端
</code></pre> 
<p><img src="https://images2.imgbox.com/e5/f9/yfwpB8JO_o.png" alt="图片"></p> 
<p>神奇的事情就这样发生了，只要两个计算机安装好ROS2，并且处于同一网络中。</p> 
<p>他们就可以实现之前讲过的话题、服务、动作等通信了，感觉就像在一个电脑里一样。</p> 
<p>不过这也会带来一个问题，如果一个网络中有很多个计算机，我们并不希望他们都可以互通互联。</p> 
<p>而是可以分组通信，小组之间是无法实现通信的。</p> 
<p>分布式网络分组</p> 
<p>没问题，ROS2提供了一个DOMAIN的机制，就类似分组一样。</p> 
<p>处于同一个DOMAIN中的计算机才能通信，我们可以在电脑和树莓派端的.bashrc中加入这样一句配置，即可将两者分配到一个小组中：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">export</span> ROS_DOMAIN_ID<span class="token operator">=</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>your_domain_id<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/88/d2/uTB6pLot_o.png" alt="图片"></p> 
<p>如果分配的ID不同，则两者无法实现通信。</p> 
<p>案例一：小海龟分布式控制</p> 
<p>分布式通信网络似乎已经建立成功了，是否真有我们想的这么神奇，我们继续测试之前学习过的一些例程。</p> 
<p>先来试试ROS中的经典案例——小海龟。</p> 
<p>我们可以在电脑端启动小海龟仿真器，树莓派上启动键盘控制节点，或者反过来也可以，依然可以流畅的控制小海龟运动：</p> 
<pre><code class="prism language-cpp"> ros2 run turtlesim turtlesim_node      # PC端$ ros2 run turtlesim turtle_teleop_key   # 树莓派端
</code></pre> 
<p><img src="https://images2.imgbox.com/08/60/VJLXMVsZ_o.png" alt="图片"></p> 
<p>案例二：话题分布式通信</p> 
<p>我们之前编写的例程是否可以在不修改任何代码的情况下，直接使用呢？</p> 
<p><img src="https://images2.imgbox.com/37/5d/6fOZM5FU_o.png" alt="图片"></p> 
<p>先试试话题通信，树莓派作为发布者，发布Hello World字符串，电脑作为订阅者，订阅Hello World字符串：</p> 
<pre><code class="prism language-cpp">ros2 run learning_topic topic_helloworld_pub  # 树莓派端$ ros2 run learning_topic topic_helloworld_sub  # PC端
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/e5/RFp4wCaB_o.png" alt="图片"></p> 
<p><img src="https://images2.imgbox.com/ca/ed/FGST9ft9_o.png" alt="图片"></p> 
<p>案例三：服务分布式通信</p> 
<p>话题没有问题，服务也不在话下。</p> 
<p><img src="https://images2.imgbox.com/72/15/A6fJQKdu_o.png" alt="图片"></p> 
<p>我们电脑端运行服务器程序，树莓派端运行客户端程序，还是可以顺利实现加法求和功能：</p> 
<pre><code class="prism language-cpp">ros2 run learning_service service_adder_server        # PC端$ ros2 run learning_service service_adder_client <span class="token number">2</span> <span class="token number">3</span>    # 树莓派端
</code></pre> 
<p><img src="https://images2.imgbox.com/e6/ab/SPEePmt1_o.png" alt="图片"></p> 
<p><img src="https://images2.imgbox.com/97/f6/dMC3Jwu7_o.png" alt="图片"></p> 
<p>案例四：机器视觉分布式应用</p> 
<p>以上这些功能还不够复杂？没问题，视觉识别的例程安排上。</p> 
<p><img src="https://images2.imgbox.com/9c/84/FqApQwVu_o.png" alt="图片"></p> 
<p>接下来，我们将使用树莓派连接摄像头，模拟一个小型机器人，可以采集实时图像。</p> 
<p>然后再通过分布式网络，将图像发给电脑端的处理节点，识别图像中的红色物体：</p> 
<pre><code class="prism language-cpp">ros2 run usb_cam usb_cam_node_exe           # 树莓派端$ ros2 run learning_topic topic_webcam_sub    # PC端
</code></pre> 
<p>没有任何问题，视觉识别的效果如下。</p> 
<p><img src="https://images2.imgbox.com/6a/67/jVMj6ttj_o.png" alt="图片"></p> 
<p>好啦，我们在分布式网络中测试了ROS一系列例程，都没有任何问题，在实际的机器人开发中。</p> 
<p>类似的方法会频繁用到，ROS为分布式网络的搭建提供了非常友好的支持，我们几乎不需要任何配置，代码也不需要做任何修改。</p> 
<p>只要使用ROS系统，一切都会变得如此轻松。</p> 
<p>参考链接：</p> 
<p>https://docs.ros.org/en/humble/Concepts/About-Domain-ID.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/952b4d9a48ab6f9aebfda92310830465/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MPC学习笔记】01：MPC简介（Lecture 1_1 Unconstrained MPC）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36527a3c4ccac8eccb1b17b878b865db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">履机乘变，轻舟便楫：源启分布式PaaS深度赋能企业级技术平台建设</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>