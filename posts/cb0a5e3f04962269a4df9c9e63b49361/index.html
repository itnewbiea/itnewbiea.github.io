<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python epoll 并发_Python使用epoll实现高并发服务器 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python epoll 并发_Python使用epoll实现高并发服务器" />
<meta property="og:description" content="一、什么是epoll
我们在 Python多种方式实现并发的Web Server 的最后使用单进程&#43;单线程&#43;非阻塞&#43;长连接实现了一个可并发处理客户端连接的服务器。他的原理可以用以下的图来描述：
解释：
1.HTTP服务器是我们使用 单进程&#43;单线程&#43;非阻塞&#43;长连接实现 的web服务器。
2.在实现的时候，我们创建了一个存放已接受Socket连接的列表，该列表是在应用程序的内存空间中的。如图中深蓝色部分
3.当有3个客户端接入的时候，列表中一共存在3个对应的socket句柄，分别对应三个小黄框。
4.灰色小框代表服务器接收请求的socket。
5.我们在进行无限循环的时候，首先是检查是否有新的客户端接入，相当于检查灰色小框是否有数据到达。然后轮询3个小黄框对应socket是否有数据到达。轮询的效率是很低的。
6.服务器在使用accept和recv时，实际上是委托操作系统帮他检查是否有数据到达，由于这个列表的socket都处于用户内存空间，所以需要将其复制到内核空间。操作系统检查完毕后，如果有数据就返回数据给应用程序，如果没有数据就以异常的方式通知应用程序。而且不光这样，操作系统可能还同时在运行其他的应用程序，这样效率会非常低。
我们再来看epoll的图：
解释：
1.我们可以看到，在结构上，最大的区别在于，存放socket的列表不处于应用程序内部。在epoll中，这个存放socket的列表处于一个特殊的内存空间，这个内存空间是应用程序与内核共享的空间。也就是说，当应用程序委托操作系统检查是否有数据到达时，无需将复制数据给内核空间，操作系统可以直接进行检查。
2.操作系统检查到某个socket有数据到达，使用事件通知的形式，直接告诉应用程序，而不是以轮询的方式。打个比方，一个厨师挨个问50个人饿了没，如果饿了就给他东西吃，这是轮询。而50个人中，谁饿了谁举手，厨师就给吃的，这叫事件通知。很明显，事件通知的效率会特别高。
实现代码：
importsocketimportreimportselectdefhandle_request(new_socket, recv_msg):#从请求中解析出URI
recv_lines =recv_msg.splitlines()#使用正则表达式提取出URI
ret = re.match(r&#34;[^/]&#43;(/[^ ]*)&#34;, recv_lines[0])ifret:#获取URI字符串
file_name = ret.group(1)#如果URI是/，则默认返回index.html的内容
if file_name == &#34;/&#34;:
file_name= &#34;/index.html&#34;
try:#根据请求的URI，读取相应的文件
fp = open(&#34;.&#34; &#43; file_name, &#34;rb&#34;)except:#找不到文件，响应404
response_msg = &#34;HTTP/1.1 404 NOT FOUND\r\n&#34;response_msg&#43;= &#34;\r\n&#34;response_msg&#43;= &#34;
----file not found----&#34;new_socket.send(response_msg.encode(&#34;utf-8&#34;))else: html_content=fp.read()
fp.close()
response_body=html_content#响应正确 200 OK
response_header = &#34;HTTP/1.1 200 OK\r\n&#34;response_header&#43;= &#34;Content-Length:%d\r\n&#34; %len(response_body)
response_header&#43;= &#34;\r\n&#34;response= response_header." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cb0a5e3f04962269a4df9c9e63b49361/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-28T16:34:16+08:00" />
<meta property="article:modified_time" content="2020-11-28T16:34:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python epoll 并发_Python使用epoll实现高并发服务器</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、什么是epoll</p> 
<p>我们在 Python多种方式实现并发的Web Server 的最后使用单进程+单线程+非阻塞+长连接实现了一个可并发处理客户端连接的服务器。他的原理可以用以下的图来描述：</p> 
<p align="center"><img src="https://images2.imgbox.com/70/28/nmi6UBcU_o.png" alt="20191129230003805536.png"></p> 
<p>解释：</p> 
<p>1.HTTP服务器是我们使用 单进程+单线程+非阻塞+长连接实现 的web服务器。</p> 
<p>2.在实现的时候，我们创建了一个存放已接受Socket连接的列表，该列表是在应用程序的内存空间中的。如图中深蓝色部分</p> 
<p>3.当有3个客户端接入的时候，列表中一共存在3个对应的socket句柄，分别对应三个小黄框。</p> 
<p>4.灰色小框代表服务器接收请求的socket。</p> 
<p>5.我们在进行无限循环的时候，首先是检查是否有新的客户端接入，相当于检查灰色小框是否有数据到达。然后轮询3个小黄框对应socket是否有数据到达。轮询的效率是很低的。</p> 
<p>6.服务器在使用accept和recv时，实际上是委托操作系统帮他检查是否有数据到达，由于这个列表的socket都处于用户内存空间，所以需要将其复制到内核空间。操作系统检查完毕后，如果有数据就返回数据给应用程序，如果没有数据就以异常的方式通知应用程序。而且不光这样，操作系统可能还同时在运行其他的应用程序，这样效率会非常低。</p> 
<p>我们再来看epoll的图：</p> 
<p align="center"><img src="https://images2.imgbox.com/5c/66/6kwt3XOV_o.png" alt="20191129230004472553.png"></p> 
<p>解释：</p> 
<p>1.我们可以看到，在结构上，最大的区别在于，存放socket的列表不处于应用程序内部。在epoll中，这个存放socket的列表处于一个特殊的内存空间，这个内存空间是应用程序与内核共享的空间。也就是说，当应用程序委托操作系统检查是否有数据到达时，无需将复制数据给内核空间，操作系统可以直接进行检查。</p> 
<p>2.操作系统检查到某个socket有数据到达，使用事件通知的形式，直接告诉应用程序，而不是以轮询的方式。打个比方，一个厨师挨个问50个人饿了没，如果饿了就给他东西吃，这是轮询。而50个人中，谁饿了谁举手，厨师就给吃的，这叫事件通知。很明显，事件通知的效率会特别高。</p> 
<p>实现代码：</p> 
<p>importsocketimportreimportselectdefhandle_request(new_socket, recv_msg):#从请求中解析出URI</p> 
<p>recv_lines =recv_msg.splitlines()#使用正则表达式提取出URI</p> 
<p>ret = re.match(r"[^/]+(/[^ ]*)", recv_lines[0])ifret:#获取URI字符串</p> 
<p>file_name = ret.group(1)#如果URI是/，则默认返回index.html的内容</p> 
<p>if file_name == "/":</p> 
<p>file_name= "/index.html"</p> 
<p>try:#根据请求的URI，读取相应的文件</p> 
<p>fp = open("." + file_name, "rb")except:#找不到文件，响应404</p> 
<p>response_msg = "HTTP/1.1 404 NOT FOUND\r\n"response_msg+= "\r\n"response_msg+= "</p> 
<h2>----file not found----</h2>"new_socket.send(response_msg.encode("utf-8"))else: 
<p>html_content=fp.read()</p> 
<p>fp.close()</p> 
<p>response_body=html_content#响应正确 200 OK</p> 
<p>response_header = "HTTP/1.1 200 OK\r\n"response_header+= "Content-Length:%d\r\n" %len(response_body)</p> 
<p>response_header+= "\r\n"response= response_header.encode("utf-8") +response_body#返回响应数据</p> 
<p>new_socket.send(response)defmain():#创建TCP SOCKET实例</p> 
<p>tcp_server_socket =socket.socket(socket.AF_INET, socket.SOCK_STREAM)## 设置重用地址</p> 
<p>#tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</p> 
<p>#绑定地址（默认本机IP）和端口</p> 
<p>tcp_server_socket.bind(("", 7890))#监听</p> 
<p>tcp_server_socket.listen(128)#将accept设置为非阻塞,这里设置一次，后面不管调多少次accept都是非阻塞的</p> 
<p>tcp_server_socket.setblocking(False)#创建一个epoll对象</p> 
<p>epl =select.epoll()#将监听套接字对应的fd注册到epoll中,并让其监听有没有数据进来，所以使用EPOLLIN</p> 
<p>epl.register(tcp_server_socket.fileno(), select.EPOLLIN)#定义一个字典，用于存放fd和套接字的对应关系，因为操作系统在事件通知的时候，使用的是fd，而不是套接字，我们需要使用fd来找到对应</p> 
<p>#的套接字，从而可以调用accept和recv</p> 
<p>fd_event_dict =dict()#循环接收客户端连接</p> 
<p>whileTrue:#使用一个列表来接受操作系统的事件通知，poll()是阻塞的，当有数据到达时，poll才会解开阻塞</p> 
<p>fd_event_list =epl.poll()#操作系统的事件通知返回一个列表（可能同时有多个套接字有数据进入），这个列表中的元素都是元组(fd,event)</p> 
<p>for fd, event infd_event_list:#首先判断事件通知中的fd是否对应监听套接字（监听套接字调用accept）</p> 
<p>if fd ==tcp_server_socket.fileno():</p> 
<p>new_socket, client_addr=tcp_server_socket.accept()#监听到一个新的客户端连接，将new_socket也注册到epoll中</p> 
<p>epl.register(new_socket.fileno(), select.EPOLLIN)#并且将这个socket加入fd_event_dict字段，方便以后通过fd来获取套接字</p> 
<p>fd_event_dict[new_socket.fileno()] =new_socketelif event == select.EPOLLIN: #如果不是监听套接字，那么都是客户端对应的套接字</p> 
<p>#接收数据</p> 
<p>recv_data = fd_event_dict[fd].recv(1024).decode("utf-8")#如果有数据</p> 
<p>ifrecv_data:#处理数据</p> 
<p>handle_request(fd_event_dict[fd], recv_data)else: #如果没有数据，则表示客户端断开连接</p> 
<p>#关闭fd对应的socket</p> 
<p>fd_event_dict[fd].close()#从epoll中踢出已经断开的fd</p> 
<p>epl.unregister(fd)#从字典中删除fd对应的记录</p> 
<p>delfd_event_dict[fd]#关闭整个SOCKET</p> 
<p>tcp_server_socket.close()if __name__ == "__main__":</p> 
<p>main()</p> 
<p>解释：</p> 
<p>1.首先创建epoll对象</p> 
<p>2.将监听套接字对应fd注册到epoll，并设置监听数据的IN。</p> 
<p>3.调用poll()函数，如果没有数据到达，则处于阻塞状态，如果有数据到达，则操作系统会返回一个事件通知列表。</p> 
<p>4.遍历列表，如果发现fd是监听套接字对应fd，则使用监听套接字调用accept，并将接收到的新的客户端连接对应socket也注册到epoll中，并将其存放到字典fd_event_dict中（方便后续使用fd获取socket）。</p> 
<p>5.如果不是监听套接字，则直接从fd_event_dict中通过fd获取对应的socket，然后调用recv来接收数据。</p> 
<p>6.如果接收到的数据有内容，则调用请求处理逻辑。</p> 
<p>7.如果接收到的数据为空，则表示客户端主动调用了close，想要断开连接。此时从fd_event_dict中通过fd获取对应socket，然后调用socker.close()来关闭连接。</p> 
<p>8.关闭连接后，将该socket从epoll中剔除，并且从fd_event_dict中删除。</p> 
<p>注意：该代码无法在windows上运行，因为epoll是Linux2.6内核增加的新功能，windows并不支持。</p> 
<p>原文：https://www.cnblogs.com/leokale-zz/p/11960731.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7608167f8fb8b455d1d777050b2c9277/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">钢构cad插件_盘点那些年用过的神级CAD插件，每一款都舍不得卸载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2806adaad0a0c9d1bb75db270cbbdbfc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">函数拟合3</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>