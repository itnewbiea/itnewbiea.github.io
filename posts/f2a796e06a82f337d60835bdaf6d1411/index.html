<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构入门实验】二叉树的建立和遍历完整代码 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构入门实验】二叉树的建立和遍历完整代码" />
<meta property="og:description" content="实验内容： 1 ．二叉树的建立与遍历（验证性实验） 问题描述 建立一棵二叉树，并对其进行遍历（先序、中序和后序），打印输出遍历结果。 基本要求 从键盘接受输入（先序），以二叉链表作为存储结构，建立二叉树（以先序来建立），并采用递归 算法对其进行遍历（先序、中序和后序），将遍历结果打印输出。 测试数据 ABC □□ DE □ G □□ F □□□ （其中 □ 表示空格字符），则输出结果为：先序为 ABCDEGF ，中序为 CBEGDFA ， z 后序为 CGBFDBA 。 实验分析： 实验要求采用的是先序建立二叉树，在此可以使用一个递归的方式去建立，但是由于指针传递的问题，在此使用二级指针，原因的话可以见我写的另一篇文章：
（极易错）链表指针函数传递问题，含线性表入门实验--约瑟夫环问题c语言代码 三个遍历函数也使用递归，比较简单就不多说了，如果是0基础的话可以简单了解一下三种遍历的大致描述：
先序：规则是若二叉树若为空,则空操作返回,否则先访问根结点,然后遍历左子树,然后再遍历右子树
中序：若树为空,则空操作返回,否则从根结点开始,中序遍历根结点的左子树,然后就是访问根结点,最后中序遍历右子树
后序：若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点
代码： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; typedef struct BiTree { char data; struct BiTree *lchild; struct BiTree *rchild; }BiTree,*BiTreePtr; bool CreatBiTree(BiTreePtr *T) { char ch; scanf(&#34;%c&#34;,&amp;ch); if(ch==&#39; &#39;) (*T)=NULL; else { if(!((*T)=(BiTreePtr)malloc(sizeof(BiTree)))) exit(1); (*T)-&gt;data=ch; CreatBiTree(&amp;((*T)-&gt;lchild)); CreatBiTree(&amp;((*T)-&gt;rchild)); } return true; } bool PreOrderTraverse(BiTreePtr T) { if(T) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f2a796e06a82f337d60835bdaf6d1411/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-22T11:21:40+08:00" />
<meta property="article:modified_time" content="2022-05-22T11:21:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构入门实验】二叉树的建立和遍历完整代码</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>实验内容：</h2> 
<div> 
 <span style="color:#000000;">1</span> 
 <span style="color:#000000;">．二叉树的建立与遍历（验证性实验） </span> 
</div> 
<div> 
 <span style="color:#000000;">问题描述 </span> 
</div> 
<div> 
 <span style="color:#000000;">建立一棵二叉树，并对其进行遍历（先序、中序和后序），打印输出遍历结果。 </span> 
</div> 
<div> 
 <span style="color:#000000;">基本要求</span> 
</div> 
<div> 
 <span style="color:#000000;">从键盘接受输入（先序），以二叉链表作为存储结构，建立二叉树（以先序来建立），并采用递归 </span> 
</div> 
<div> 
 <span style="color:#000000;">算法对其进行遍历（先序、中序和后序），将遍历结果打印输出。 </span> 
</div> 
<div> 
 <span style="color:#000000;">测试数据 </span> 
</div> 
<div> 
 <span style="color:#000000;"><em>ABC</em></span> 
 <span style="color:#000000;">□□</span> 
 <span style="color:#000000;"><em>DE</em></span> 
 <span style="color:#000000;">□</span> 
 <span style="color:#000000;"><em>G</em></span> 
 <span style="color:#000000;">□□</span> 
 <span style="color:#000000;"><em>F</em></span> 
 <span style="color:#000000;">□□□</span> 
 <span style="color:#000000;">（其中</span> 
 <span style="color:#000000;">□</span> 
 <span style="color:#000000;">表示空格字符），则输出结果为：先序为</span> 
 <span style="color:#000000;"><em>ABCDEGF</em></span> 
 <span style="color:#000000;">，中序为 </span> 
</div> 
<div> 
 <span style="color:#000000;"><em>CBEGDFA</em></span> 
 <span style="color:#000000;">， </span> 
</div> 
<div> 
 <span style="color:#000000;">z </span> 
</div> 
<div> 
 <span style="color:#000000;">后序为</span> 
 <span style="color:#000000;"><em>CGBFDBA</em></span> 
 <span style="color:#000000;">。</span> 
</div> 
<div></div> 
<h2><span style="color:#000000;">实验分析：</span></h2> 
<p>实验要求采用的是先序建立二叉树，在此可以使用一个递归的方式去建立，但是由于指针传递的问题，在此使用二级指针，原因的话可以见我写的另一篇文章：</p> 
<h2 id="articleContentId"><a class="link-info" href="https://blog.csdn.net/m0_63222058/article/details/124844008?spm=1001.2014.3001.5502" title="（极易错）链表指针函数传递问题，含线性表入门实验--约瑟夫环问题c语言代码">（极易错）链表指针函数传递问题，含线性表入门实验--约瑟夫环问题c语言代码</a></h2> 
<p>三个遍历函数也使用递归，比较简单就不多说了，如果是0基础的话可以简单了解一下三种遍历的大致描述：</p> 
<p>先序：规则是若<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91&amp;spm=1001.2101.3001.7020" title="二叉树">二叉树</a>若为空,则空操作返回,否则先访问根结点,然后遍历左子树,然后再遍历右子树</p> 
<p>中序：若树为空,则空操作返回,否则从根结点开始,中序遍历根结点的左子树,然后就是访问根结点,最后中序遍历右子树</p> 
<p>后序：若树为空,则空操作返回,否则从左到右先叶子后结点的方式遍历访问左右子树,最后是访问根结点</p> 
<p></p> 
<h2>代码：</h2> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
typedef struct BiTree
{
	char data;
	struct BiTree *lchild;
	struct BiTree *rchild;
}BiTree,*BiTreePtr;
bool CreatBiTree(BiTreePtr *T)
{
	char ch;
	scanf("%c",&amp;ch);
	if(ch==' ') (*T)=NULL;
	else
	{
		if(!((*T)=(BiTreePtr)malloc(sizeof(BiTree)))) exit(1);
		(*T)-&gt;data=ch;
		CreatBiTree(&amp;((*T)-&gt;lchild));
		CreatBiTree(&amp;((*T)-&gt;rchild));
	}
	return true;
}
bool PreOrderTraverse(BiTreePtr T)
{
	if(T)
	{
		printf("%c ",T-&gt;data);
		PreOrderTraverse(T-&gt;lchild);
     	PreOrderTraverse(T-&gt;rchild);
	}
	else
	return true;
	return true;
}
bool InOrderTraverse(BiTreePtr T)
{
	if(T)
	{
		InOrderTraverse(T-&gt;lchild);
		printf("%c ",T-&gt;data);
     	InOrderTraverse(T-&gt;rchild);
	}
	else
	return true;
	return true;
}
bool PostOrderTraverse(BiTreePtr T)
{
	if(T)
	{
		PostOrderTraverse(T-&gt;lchild);
     	PostOrderTraverse(T-&gt;rchild);
     	printf("%c ",T-&gt;data);
	}
	else
	return true;
	return true;
}
int main()
{
	BiTreePtr T;
	printf("输入先序创建二叉树序列：");
	CreatBiTree(&amp;T);
	printf("先序遍历序列为：");
	PreOrderTraverse(T);
	printf("\n");
	printf("中序遍历序列为：");
	InOrderTraverse(T);
	printf("\n");
	printf("后序遍历序列为：");
	PostOrderTraverse(T);
	printf("\n");
	return 0;
}</code></pre> 
<h2> 效果</h2> 
<p><img alt="" height="254" src="https://images2.imgbox.com/dd/d9/ay1Kikm9_o.png" width="740"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a427270def2f56f6bad724724a0f58e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;小知识点（一）：基类指针指向派生类对象、派生类指针指向基类对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9a3a1d5f475dc785403a8aa76984c58/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Typora收费了，再找找免费的Markdown编辑器吗？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>