<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>winform桌面程序如何调用后台API的方法（一） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="winform桌面程序如何调用后台API的方法（一）" />
<meta property="og:description" content="提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 目录
前言
一、如何解决？
二、使用步骤
步骤一：构建后台API
步骤二：构建后台API
步骤三：效果展示
三、总结
前言 每当进行winform桌面程序开发时，为了实现项目之间的代码复用，通常会将一些通用的方法封装成动态库（.dll）。但是这样也存在一个问题，假设将方法A方法封装成动态库MyDll后，项目Project1引用了MyDll，可以使用A方法；在项目Project2引用MyDll使用A方法时，发现A方法有bug，并对A方法进行修复。此时，Project1使用的方法A仍然存在bug，需要重新引用最新的MyDll才能修复A的bug。那么，是否有更好的解决方法，在Project2修复完成时，Project1引用的方法A也同步修复呢？
提示：以下是本篇文章正文内容，下面案例可供参考
一、如何解决？ 现在我给大家介绍的，就是如何使用winform调用后台的API
二、使用步骤 步骤一：构建后台API 开发工具：VS2019目标框架：.net core 3.1先在后台写一个简单的方法GetDateTime，用于winform端进行调用。 代码如下（GetDateTime）：
using Agreement.Business.System; using Agreement.Entity.Enum; using Agreement.Entity.Models.AgreementEntity; using log4net; using Microsoft.AspNetCore.Mvc; using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; namespace tokendemo.Controllers { [ApiController] [Route(&#34;[controller]/[action]&#34;)] public class MyTestDemoController : CommServers { private readonly ILog _logger; public MyTestDemoController() { _logger = LogManager.GetLogger(typeof(MyTestDemoController)); } [HttpGet] public async Task&lt;TData&gt; GetDateTime() { string strResult= &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/65c42826b70733a3acfcb6c5a787a96b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-12T16:42:04+08:00" />
<meta property="article:modified_time" content="2023-07-12T16:42:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">winform桌面程序如何调用后台API的方法（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p> 
</blockquote> 
<p></p> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
 <ul><li> <p id="main-toc"><strong>目录</strong></p> <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> <p id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F" rel="nofollow">一、如何解决？</a></p> <p id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4" rel="nofollow">二、使用步骤</a></p> <p id="%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0API-toc" style="margin-left:0px;"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0API" rel="nofollow">步骤一：构建后台API</a></p> <p id="%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0API-toc" style="margin-left:0px;"><a href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0API" rel="nofollow">步骤二：构建后台API</a></p> <p id="%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:0px;"><a href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow">步骤三：效果展示</a></p> <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">三、总结</a></p> 
   <hr id="hr-toc"><p></p> <p></p> <p></p> </li></ul> 
</div> 
<p></p> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<hr> 
<p>        每当进行winform桌面程序开发时，为了实现项目之间的代码复用，通常会将一些通用的方法封装成动态库（.dll）。但是这样也存在一个问题，假设将方法A方法封装成动态库MyDll后，项目Project1引用了MyDll，可以使用A方法；在项目Project2引用MyDll使用A方法时，发现A方法有bug，并对A方法进行修复。此时，Project1使用的方法A仍然存在bug，需要重新引用最新的MyDll才能修复A的bug。那么，是否有更好的解决方法，在Project2修复完成时，Project1引用的方法A也同步修复呢？</p> 
<hr> 
<p><code>提示：以下是本篇文章正文内容，下面案例可供参考</code></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><a id="pandas_16"></a>一、如何解决？</h2> 
<p>        现在我给大家介绍的，就是如何使用winform调用后台的API</p> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><a id="_19"></a>二、使用步骤</h2> 
<h2 id="%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0API"><a id="1_20"></a><strong>步骤一：构建后台API</strong></h2> 
<p></p> 
<ol><li style="text-align:justify;">开发工具：VS2019</li><li style="text-align:justify;">目标框架：.net core 3.1</li><li style="text-align:justify;">先在后台写一个简单的方法<span style="color:#000000;">GetDateTime</span>，用于winform端进行调用。</li></ol> 
<p>代码如下（<span style="color:#000000;">GetDateTime</span>）：</p> 
<pre><code class="language-cs">using Agreement.Business.System;
using Agreement.Entity.Enum;
using Agreement.Entity.Models.AgreementEntity;
using log4net;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace tokendemo.Controllers
{
    [ApiController]
    [Route("[controller]/[action]")]
    public class MyTestDemoController : CommServers
    {
        private readonly ILog _logger;
        public MyTestDemoController()
        {
            _logger = LogManager.GetLogger(typeof(MyTestDemoController));
        }

        [HttpGet]
        public async Task&lt;TData&gt; GetDateTime()
        {
            string strResult= "Beijing Time:" + DateTime.Now.ToString();
            return ReturnObj&lt;bool&gt;(ResultEnum.Sucess, true, strResult);
          
        }


    }
}</code></pre> 
<p style="text-align:justify;"><span style="color:#000000;">4.为了将返回值进行统一，封装一个</span><span style="color:#2b91af;">CommServer</span><span style="color:#2b91af;">s.cs</span><span style="color:#000000;">类，用于赋值返回，需要引用类TData.cs和枚举ResultEnum.cs：</span></p> 
<p style="text-align:justify;">代码如下（<span style="color:#2b91af;">CommServer</span><span style="color:#2b91af;">s.cs</span>）：</p> 
<pre><code class="language-cs">using Agreement.Entity.Enum;
using Agreement.Entity.Models.AgreementEntity;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;


namespace Agreement.Business.System
{
    public class CommServers
    {
        /// &lt;summary&gt;
        /// 构造返回结果
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
        /// &lt;param name="result"&gt;&lt;/param&gt;
        /// &lt;param name="data"&gt;&lt;/param&gt;
        /// &lt;param name="mesage"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public TData&lt;T&gt; ReturnObj&lt;T&gt;(ResultEnum result, T data, string mesage)
        {
            TData&lt;T&gt; obj = new TData&lt;T&gt;();
            obj.Result = result;
            obj.Data = data;
            obj.TotalCount = 1;
            obj.Message = mesage;
            return obj;
        }

    }
}
</code></pre> 
<p style="text-align:justify;"><span style="color:#000000;">5.第（4）点需要引用类TData.cs和枚举ResultEnum.cs</span></p> 
<p style="text-align:justify;">代码如下（<span style="color:#000000;">TData.cs</span>）：</p> 
<pre><code class="language-cs">using Agreement.Entity.Enum;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;


namespace Agreement.Entity.Models.AgreementEntity
{
        public class TData
        {
        /// &lt;summary&gt;
        /// 操作结果，Result为1代表成功，0代表失败，其他的验证返回结果，可根据需要设置
        /// &lt;/summary&gt;
        public ResultEnum Result { get; set; }

            /// &lt;summary&gt;
            /// 提示信息或异常信息
            /// &lt;/summary&gt;
            public string Message { get; set; }

            /// &lt;summary&gt;
            /// 扩展Message
            /// &lt;/summary&gt;
            public string Description { get; set; }
        }

        public class TData&lt;T&gt; : TData
        {
            /// &lt;summary&gt;
            /// 列表的记录数
            /// &lt;/summary&gt;
            public int TotalCount { get; set; }

            /// &lt;summary&gt;
            /// 数据
            /// &lt;/summary&gt;
            public T Data { get; set; }

        }

    
}
</code></pre> 
<p style="text-align:justify;">代码如下（<span style="color:#000000;">ResultEnum.cs</span>）：</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Threading.Tasks;

namespace Agreement.Entity.Enum
{

    /// &lt;summary&gt;
    /// 操作结果，Result为1代表成功，0代表失败，其他的验证返回结果，可根据需要设置
    /// &lt;/summary&gt;
    public enum ResultEnum
    {

        /// &lt;summary&gt;
        /// 成功
        /// &lt;/summary&gt;
        [Description("成功")]
        Sucess = 1,

        /// &lt;summary&gt;
        /// 失败
        /// &lt;/summary&gt;
        [Description("失败")]
        Faill = 0

    }
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">运行后，先在后台测试方法是否可用，如下图：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/37/dc/ISIxxoaL_o.png"></strong></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/0f/17/XTu6iZLy_o.png"></p> 
<p></p> 
<h2 id="%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0API"><strong>步骤二：构建后台API</strong></h2> 
<ol><li style="text-align:justify;">开发工具：VS2019</li><li style="text-align:justify;">目标框架：.net Framework 4.7.2</li><li style="text-align:justify;">先创建一个简单的winform程序，并添加一个简单的测试按钮，如下图：</li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/d1/bx1j068H_o.png"></p> 
<p></p> 
<p style="text-align:justify;">     4. 在项目通过NutGet程序包，添加Newtonsoft.Json，操作步骤如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/87/jkHLRwWV_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/3e/Kph8Qro8_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/d9/kfvWd1Ew_o.png"></p> 
<p>     5. 完成Newtonsoft.Json程序包的安装之后，新建两个类，HttpReuestUtility.cs(将和后台通讯的方法封装到这个类中)和JsonObject.cs(主要将后台的通讯结果进行封装)。</p> 
<p>代码如下（HttpReuestUtility.cs）：</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;

namespace JasonHelp
{
    public class HttpReuestUtility
    {
     
        /// &lt;summary&gt;
        /// 发送jason到服务器
        /// &lt;/summary&gt;
        /// &lt;param name="SendDate"&gt;&lt;/param&gt;
        /// &lt;param name="InterfaceName"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static JsonObject GetResponseData(string SendDate, string InterfaceName)  
        {

            JsonObject reJson = new JsonObject();
            try
            {
                if (SendDate == "")
                {
                    SendDate = "{}";
                }
                byte[] bytes = Encoding.UTF8.GetBytes(SendDate);
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(InterfaceName);
                request.Method = "POST";
                //request.ContentType = "application/x-www-form-urlencoded";
                //request.Accept = "text/plain";
                request.ContentType = "application/json";
                request.Accept = "application/json";
                request.ContentLength = bytes.Length;
                Stream reqstream = request.GetRequestStream();
                reqstream.Write(bytes, 0, bytes.Length);

                //声明一个HttpWebRequest请求  
                request.Timeout = 60000;
                //设置连接超时时间  
                request.Headers.Set("Pragma", "no-cache");
                HttpWebResponse response = (HttpWebResponse)request.GetResponse();
                Stream streamReceive = response.GetResponseStream();
                Encoding encoding = Encoding.UTF8;

               StreamReader streamReader = new StreamReader(streamReceive, encoding);
               string strResult = streamReader.ReadToEnd();
               streamReceive.Dispose();
               streamReader.Dispose();
               JObject JsonResult= JObject.Parse(strResult);
               int isSuccess = JsonResult["result"].Value&lt;int&gt;();
               string Result = JsonResult["message"].Value&lt;string&gt;();
               //JArray jar = JArray.Parse(JsonResult["Data"].ToString());
               reJson.isSuccess = isSuccess;
               reJson.Result = Result;
               reJson.Data = JsonResult["data"];

             
                return reJson;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }




        /// &lt;summary&gt;
        /// 发送jason到服务器
        /// &lt;/summary&gt;
        /// &lt;param name="SendDate"&gt;&lt;/param&gt;
        /// &lt;param name="InterfaceName"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static JsonObject GetResponseDataByGet(string InterfaceName)
        {

            JsonObject reJson = new JsonObject();
            try
            {
               
               // byte[] bytes = Encoding.UTF8.GetBytes(SendDate);
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(InterfaceName);
                request.Method = "GET";

                //request.ContentType = "application/x-www-form-urlencoded";
                //request.Accept = "text/plain";
                //request.ContentType = "application/json";
                //request.Accept = "application/json";
                //request.ContentLength = bytes.Length;
                //Stream reqstream = request.GetRequestStream();
              //  reqstream.Write(bytes, 0, bytes.Length);

                //声明一个HttpWebRequest请求  
                request.Timeout = 60000;
                //设置连接超时时间  
                request.Headers.Set("Pragma", "no-cache");
                HttpWebResponse response = (HttpWebResponse)request.GetResponse();
                Stream streamReceive = response.GetResponseStream();
                Encoding encoding = Encoding.UTF8;

                StreamReader streamReader = new StreamReader(streamReceive, encoding);
                string strResult = streamReader.ReadToEnd();
                streamReceive.Dispose();
                streamReader.Dispose();
                JObject JsonResult = JObject.Parse(strResult);
                int isSuccess = JsonResult["result"].Value&lt;int&gt;();
                string Result = JsonResult["message"].Value&lt;string&gt;();
                //JArray jar = JArray.Parse(JsonResult["Data"].ToString());
                reJson.isSuccess = isSuccess;
                reJson.Result = Result;
                reJson.Data = JsonResult["data"];


                return reJson;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

    }
}
</code></pre> 
<p>代码如下（JsonObject.cs）：</p> 
<pre><code class="language-cs">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json.Linq;

namespace JasonHelp
{
    public class JsonObject
    {

        private int _isSuccess = 0;
        private string _Result = "";
        //private JArray _Data = new JArray();
        public object _Data = new object();
        public JsonObject()
        {
            _isSuccess =0;
            _Result = "";
            _Data = null;
        }


        /// &lt;summary&gt;
        /// 是否成功
        /// &lt;/summary&gt;
        public int isSuccess
        {
            set { _isSuccess = value; }
            get { return _isSuccess; }
        }

        /// &lt;summary&gt;
        ///结果
        /// &lt;/summary&gt;
        public string Result
        {
            set { _Result = value; }
            get { return _Result; }
        }

        /// &lt;summary&gt;
        ///返回数据
        /// &lt;/summary&gt;
        public object Data
        {
            set { _Data = value; }
            get { return _Data; }
        }


    }
}
</code></pre> 
<p>       6. 在新建的测试按钮，添加点击事件。</p> 
<p>代码如下（按钮事件）：</p> 
<pre><code class="language-cs">        /// &lt;summary&gt;
        /// 调用API GetDateTime 按钮事件
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void btnGetTime_Click(object sender, EventArgs e)
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                string strMessage = "";
                JsonObject reJson = new JsonObject();
                //后台地址
                string strInterFace = "http://localhost:3252/MyTestDemo/GetDateTime";
                reJson = HttpReuestUtility.GetResponseDataByGet(strInterFace);
                if (reJson != null)
                {
                    if (reJson.isSuccess == 1)//获取成功
                    {
                        strMessage = reJson.Result.ToString();
                        sb.AppendLine("结论：成功");
                        sb.AppendLine("结果：" + strMessage);
                    }
                    else
                    {
                        strMessage = reJson.Result.ToString();
                        sb.AppendLine("结论：失败");
                        sb.AppendLine("结果：" + strMessage);
                    }

                }
                else
                {
                    strMessage = "和结果判定服务器通讯失败";
                    sb.AppendLine("结论：失败");
                    sb.AppendLine("结果：" + strMessage);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
            finally {
                this.richMessage.Text = sb.ToString();
            }
        }</code></pre> 
<h2 id="%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"><strong>步骤三：效果展示</strong></h2> 
<ol><li style="text-align:justify;"><span style="color:#000000;">先运行后台端服务</span></li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/24/40/6lmWx9Fk_o.png"></p> 
<p><span style="color:#000000;">      2.运行winform桌面程序后，点击调用API。</span></p> 
<p style="text-align:center;"><span style="color:#000000;"><img alt="" src="https://images2.imgbox.com/de/51/3Ac165rv_o.png"></span></p> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8f/b9/UCdCCdAY_o.png"></p> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>三、总结</h2> 
<p>以上就是今天要讲的内容，本文仅仅通过一个简单Demo，介绍了winform桌面程序如何调用后台API接口，方便大家参考使用。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2ef0cc5d200a2192860304e7da67f9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Bootstrap的登录&amp;注册模板（html&#43;css）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4386fb156eb8963fb78d7a25842ca0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数组根据key值排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>