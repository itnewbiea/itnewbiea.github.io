<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅克隆与深克隆理解及使用 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅克隆与深克隆理解及使用" />
<meta property="og:description" content="文章目录 浅克隆与深克隆一.引用赋值二、浅克隆/深克隆2.1 浅克隆2.2 深克隆2.2.1 克隆(clone)2.2.2 序列化(Serialization) 三、实践使用3.1 浅克隆3.1.1 工具类BeanUtils和PropertyUtils进行对象复制3.1.2 指定对象实现克隆3.1.3 数组克隆 3.2 深克隆3.2.1 所有对象都实现克隆3.2.2 序列化3.2.3 Apache Commons工具包3.2.4 通过 JSON 工具类实现深克隆3.2.5 通过构造方法实现深克隆 四、参考 浅克隆与深克隆 一.引用赋值 Student stu1 = new Student(); Student stu2 = stu1; 改变stu1或stu2，对方都会跟着改变，因为是引用同个对象。
二、浅克隆/深克隆 浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。
2.1 浅克隆 在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。
一般步骤：
被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常)， 该接口为标记接口(不含任何方法)覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象。（native为本地方法) 在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址，要变一起变。
简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。
2.2 深克隆 2.2.1 克隆(clone) 如果要用clone()方法实现深克隆，那么对于原型对象的引用类型成员变量，都要实现Clonenable接口。
简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。
2.2.2 序列化(Serialization) 如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用clone方法就会很麻烦。这时我们可以用序列化的方式来实现对象的深克隆。
具体操作是先使对象实现Serializable接口，然后把对象写到一个流里，再从流里读出来，便可以重建对象。
三、实践使用 3.1 浅克隆 3.1.1 工具类BeanUtils和PropertyUtils进行对象复制 除BeanUtils外还有一个名为PropertyUtils的工具类，它也提供copyProperties()方法，作用与BeanUtils的同名方法十分相似，主要的区别在于BeanUtils提供类型转换功能，即发现两个JavaBean的同名属性为不同类型时，在支持的数据类型范围内进行转换，而PropertyUtils不支持这个功能，但是速度会更快一些。在实际开发中，BeanUtils使用更普遍一点，犯错的风险更低一点。
BeanUtils.copyProperties(a, b); // BeanUtils.copyProperties(&#34;转换前的类&#34;, &#34;转换后类&#34;); 是浅拷贝
b中的存在的属性，a中一定要有，但是a中可以有多余的属性；a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；只是调用对象的set方法，并没有将所有属性拷贝。如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。 注意：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/45516027c9630bffe0c744d5fb4e1a2f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-21T15:27:11+08:00" />
<meta property="article:modified_time" content="2022-01-21T15:27:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅克隆与深克隆理解及使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">浅克隆与深克隆</a></li><li><ul><li><a href="#_3" rel="nofollow">一.引用赋值</a></li><li><a href="#_16" rel="nofollow">二、浅克隆/深克隆</a></li><li><ul><li><a href="#21__19" rel="nofollow">2.1 浅克隆</a></li><li><a href="#22__35" rel="nofollow">2.2 深克隆</a></li><li><ul><li><a href="#221_clone_37" rel="nofollow">2.2.1 克隆(clone)</a></li><li><a href="#222_Serialization_45" rel="nofollow">2.2.2 序列化(Serialization)</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_52" rel="nofollow">三、实践使用</a></li><li><ul><li><a href="#31__53" rel="nofollow">3.1 浅克隆</a></li><li><ul><li><a href="#311_BeanUtilsPropertyUtils_55" rel="nofollow">3.1.1 工具类BeanUtils和PropertyUtils进行对象复制</a></li><li><a href="#312__87" rel="nofollow">3.1.2 指定对象实现克隆</a></li><li><a href="#313__90" rel="nofollow">3.1.3 数组克隆</a></li></ul> 
     </li><li><a href="#32__93" rel="nofollow">3.2 深克隆</a></li><li><ul><li><a href="#321__94" rel="nofollow">3.2.1 所有对象都实现克隆</a></li><li><a href="#322__97" rel="nofollow">3.2.2 序列化</a></li><li><a href="#323_Apache_Commons_118" rel="nofollow">3.2.3 Apache Commons工具包</a></li><li><a href="#324__JSON__123" rel="nofollow">3.2.4 通过 JSON 工具类实现深克隆</a></li><li><a href="#325__129" rel="nofollow">3.2.5 通过构造方法实现深克隆</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_137" rel="nofollow">四、参考</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>浅克隆与深克隆</h3> 
<h4><a id="_3"></a>一.引用赋值</h4> 
<pre><code class="prism language-java"><span class="token class-name">Student</span> stu1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Student</span> stu2 <span class="token operator">=</span> stu1<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/87/mtDkpplR_o.png" alt="img"></p> 
<p>改变stu1或stu2，对方都会跟着改变，因为是引用同个对象。</p> 
<h4><a id="_16"></a>二、浅克隆/深克隆</h4> 
<p>浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</p> 
<h5><a id="21__19"></a>2.1 浅克隆</h5> 
<p>在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。</p> 
<p>一般步骤：</p> 
<ol><li>被复制的类需要实现Clonenable接口（不实现的话在调用clone方法会抛出CloneNotSupportedException异常)， 该接口为标记接口(不含任何方法)</li><li>覆盖clone()方法，访问修饰符设为public。方法中调用super.clone()方法得到需要的复制对象。（native为本地方法)</li></ol> 
<p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址，要变一起变。</p> 
<p>简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p> 
<p><img src="https://images2.imgbox.com/66/a7/Lu9TsBqE_o.png" alt="这里写图片描述"></p> 
<h5><a id="22__35"></a>2.2 深克隆</h5> 
<h6><a id="221_clone_37"></a>2.2.1 克隆(clone)</h6> 
<p>如果要用clone()方法实现深克隆，那么对于原型对象的引用类型成员变量，都要实现Clonenable接口。</p> 
<p>简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p> 
<p><img src="https://images2.imgbox.com/4a/e1/NtgXJd2N_o.png" alt="这里写图片描述"></p> 
<h6><a id="222_Serialization_45"></a>2.2.2 序列化(Serialization)</h6> 
<p>如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用clone方法就会很麻烦。这时我们可以用序列化的方式来实现对象的深克隆。</p> 
<p>具体操作是先使对象实现Serializable接口，然后把对象写到一个流里，再从流里读出来，便可以重建对象。</p> 
<h4><a id="_52"></a>三、实践使用</h4> 
<h5><a id="31__53"></a>3.1 浅克隆</h5> 
<h6><a id="311_BeanUtilsPropertyUtils_55"></a>3.1.1 工具类BeanUtils和PropertyUtils进行对象复制</h6> 
<p>除BeanUtils外还有一个名为PropertyUtils的工具类，它也提供copyProperties()方法，作用与BeanUtils的同名方法十分相似，主要的区别在于BeanUtils提供类型转换功能，即发现两个JavaBean的同名属性为不同类型时，在支持的数据类型范围内进行转换，而PropertyUtils不支持这个功能，但是速度会更快一些。在实际开发中，BeanUtils使用更普遍一点，犯错的风险更低一点。</p> 
<pre><code class="prism language-java"><span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// BeanUtils.copyProperties("转换前的类", "转换后类");</span>
</code></pre> 
<p><strong>是浅拷贝</strong></p> 
<ul><li>b中的存在的属性，a中一定要有，但是a中可以有多余的属性；</li><li>a中与b中相同的属性都会被替换，不管是否有值；</li><li>a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；</li><li>Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；只是调用对象的set方法，并没有将所有属性拷贝。</li><li>如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；</li><li>spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。</li></ul> 
<p>注意：</p> 
<p>其实常见的BeanUtils有2个：<br> spring有BeanUtils<br> apache的commons也有BeanUtils。</p> 
<p>区别如下：</p> 
<table><thead><tr><th></th><th>spring的BeanUtils</th><th>commons的BeanUtils</th></tr></thead><tbody><tr><td>方法</td><td>copyProperty和copyProperties</td><td>copyProperties</td></tr><tr><td>参数</td><td>src ，dest</td><td>dest，src</td></tr></tbody></table> 
<p>这两个用哪个都行，但是要注意区别。 因为他们2个的src和dest是正好相反的，要特别留意。</p> 
<h6><a id="312__87"></a>3.1.2 指定对象实现克隆</h6> 
<p>指定对象实现Clonenable接口</p> 
<h6><a id="313__90"></a>3.1.3 数组克隆</h6> 
<p>Arrays.copyOf()</p> 
<h5><a id="32__93"></a>3.2 深克隆</h5> 
<h6><a id="321__94"></a>3.2.1 所有对象都实现克隆</h6> 
<p>注意：每个对象都要实现Clonenable接口并重写Object类中的clone()方法</p> 
<h6><a id="322__97"></a>3.2.2 序列化</h6> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Outer</span> <span class="token function">myclone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Outer</span> outer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span>
	    <span class="token class-name">ByteArrayOutputStream</span> baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token comment">// 将流序列化成对象</span>
	    <span class="token class-name">ByteArrayInputStream</span> bais <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bais<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    outer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Outer</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> outer<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>由于是通过字节流序列化实现的深克隆，因此每个对象必须能被序列化，必须实现 Serializable 接口，标识自己可以被序列化，否则会抛出异常 (java.io.NotSerializableException)。</p> 
<h6><a id="323_Apache_Commons_118"></a>3.2.3 Apache Commons工具包</h6> 
<p>工具包中的：SerializationUtils.clone(T object);</p> 
<p>注意：底层使用的是序列化，因此每个对象都实现Serializable接口即可。通过字节流的方式实现的，只不过这种实现方式是第三方提供了现成的方法，让我们可以直接调用。</p> 
<h6><a id="324__JSON__123"></a>3.2.4 通过 JSON 工具类实现深克隆</h6> 
<pre><code class="prism language-java"><span class="token class-name">People</span> p2 <span class="token operator">=</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">People</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用 JSON 工具类会先把对象转化成字符串，再从字符串转化成新的对象，因为新对象是从字符串转化而来的，因此不会和原型对象有任何的关联，这样就实现了深克隆，其他类似的 JSON 工具类实现方式也是一样的。</p> 
<h6><a id="325__129"></a>3.2.5 通过构造方法实现深克隆</h6> 
<pre><code class="prism language-java"><span class="token comment">// 调用构造函数克隆对象</span>
<span class="token class-name">People</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新 new 一个对象。如果字段过多，比较繁琐，不推荐。</p> 
<h4><a id="_137"></a>四、参考</h4> 
<p><a href="https://blog.csdn.net/jianghao233/article/details/107083448">Java 源码剖析(07)–简述深克隆和浅克隆</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f898e28dbe422db0ec0c17d17b21520b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">setTimeout/setInterval 无法用 this 访问 Vue 实例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54e25df31722b936de425024f3ee62cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql show processlist命令详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>