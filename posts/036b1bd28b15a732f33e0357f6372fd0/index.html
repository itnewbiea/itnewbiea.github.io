<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>redis:从入门到入土:8.RDB和AOF - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="redis:从入门到入土:8.RDB和AOF" />
<meta property="og:description" content="Redis学习 一.RDB持久化1.定义2.执行时机3.RDB原理4.RDB 的优缺点5.小结 二.RDB持久化1.AOF原理2.AOF配置3.AOF文件重写3.1 定义3.2 步骤3.3 问题 4.AOF优缺点5.RDB与AOF对比 三:RDB和AOF混合方式四:数据恢复五:性能与实践六.总结 众所周知,Redis有两种持久化方案: RDB持久化,AOF持久化;
一.RDB持久化 1.定义 RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。即在指定目录下生成一个dump.rdb文件, 当Redis实例故障重启后，从磁盘读取快照文件，恢复数据.快照文件称为RDB文件，默认是保存在当前运行目录。
将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可恢复数据。
2.执行时机 RDB持久化在四种情况下会执行：
执行save命令执行bgsave命令Redis停机时触发RDB条件时 1）save命令
执行下面的命令，可以立即执行一次RDB：
save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。
2）bgsave命令
下面的命令可以异步执行RDB：
这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。
3）停机时
Redis停机时会执行一次save命令，实现RDB持久化。
4）触发RDB条件
Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：
# 900秒内，如果至少有1个key被修改，则执行bgsave ， # 如果是save &#34;&#34; 则表示禁用RDB save 900 1 save 300 10 save 60 10000 RDB的其它配置也可以在redis.conf文件中设置：
# 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱 rdbcompression yes # RDB文件名称 dbfilename dump.rdb # 文件保存的路径目录 dir ./ 3.RDB原理 bgsave开始时会异步fork主进程得到子进程，这个过程对主进程几乎是零阻塞,子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。
异步fork过程中,主进程不会直接操作物理内存,操作虚拟内存,维护一个页表的映射关系,类似map来进行操作,fork 复制页表,实现内存共享;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/036b1bd28b15a732f33e0357f6372fd0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-28T17:22:08+08:00" />
<meta property="article:modified_time" content="2022-12-28T17:22:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">redis:从入门到入土:8.RDB和AOF</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Redis学习</h4> 
 <ul><li><a href="#RDB_6" rel="nofollow">一.RDB持久化</a></li><li><ul><li><a href="#1_7" rel="nofollow">1.定义</a></li><li><a href="#2_11" rel="nofollow">2.执行时机</a></li><li><a href="#3RDB_73" rel="nofollow">3.RDB原理</a></li><li><a href="#4RDB__87" rel="nofollow">4.RDB 的优缺点</a></li><li><a href="#5_101" rel="nofollow">5.小结</a></li></ul> 
  </li><li><a href="#RDB_120" rel="nofollow">二.RDB持久化</a></li><li><ul><li><a href="#1AOF_121" rel="nofollow">1.AOF原理</a></li><li><a href="#2AOF_132" rel="nofollow">2.AOF配置</a></li><li><a href="#3AOF_170" rel="nofollow">3.AOF文件重写</a></li><li><ul><li><a href="#31__171" rel="nofollow">3.1 定义</a></li><li><a href="#32__189" rel="nofollow">3.2 步骤</a></li><li><a href="#33__195" rel="nofollow">3.3 问题</a></li></ul> 
   </li><li><a href="#4AOF_210" rel="nofollow">4.AOF优缺点</a></li><li><a href="#5RDBAOF_223" rel="nofollow">5.RDB与AOF对比</a></li></ul> 
  </li><li><a href="#RDBAOF_227" rel="nofollow">三:RDB和AOF混合方式</a></li><li><a href="#_238" rel="nofollow">四:数据恢复</a></li><li><a href="#_250" rel="nofollow">五:性能与实践</a></li><li><a href="#_265" rel="nofollow">六.总结</a></li></ul> 
</div> 
<p></p> 
<p>众所周知,Redis有两种持久化方案: RDB持久化,AOF持久化;</p> 
<h2><a id="RDB_6"></a>一.RDB持久化</h2> 
<h3><a id="1_7"></a>1.定义</h3> 
<p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。<strong>即在指定目录下生成一个dump.rdb文件</strong>, 当Redis实例故障重启后，从磁盘读取快照文件，恢复数据.快照文件称为RDB文件，默认是保存在当前运行目录。</p> 
<p><strong>将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可恢复数据。</strong></p> 
<h3><a id="2_11"></a>2.执行时机</h3> 
<p>RDB持久化在四种情况下会执行：</p> 
<ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul> 
<p><strong>1）save命令</strong></p> 
<p>执行下面的命令，可以立即执行一次RDB：<br> <img src="https://images2.imgbox.com/05/fa/bXf3jqT1_o.png" alt="在这里插入图片描述"><br> save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p> 
<p><strong>2）bgsave命令</strong></p> 
<p>下面的命令可以异步执行RDB：<br> <img src="https://images2.imgbox.com/b9/3a/sPGFYa3P_o.png" alt="在这里插入图片描述"><br> 这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p> 
<p><strong>3）停机时</strong></p> 
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p> 
<p><strong>4）触发RDB条件</strong></p> 
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p> 
<pre><code class="prism language-properties"># 900秒内，如果至少有1个key被修改，则执行bgsave ，
# 如果是save "" 则表示禁用RDB
save 900 1  
save 300 10  
save 60 10000 
</code></pre> 
<p>RDB的其它配置也可以在redis.conf文件中设置：</p> 
<pre><code class="prism language-properties"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱
rdbcompression yes

# RDB文件名称
dbfilename dump.rdb  

# 文件保存的路径目录
dir ./ 
</code></pre> 
<h3><a id="3RDB_73"></a>3.RDB原理</h3> 
<p>bgsave开始时会异步fork主进程得到子进程，这个过程对主进程几乎是零阻塞,子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p> 
<p>异步fork过程中,主进程不会直接操作物理内存,操作虚拟内存,维护一个页表的映射关系,类似map来进行操作,fork 复制页表,实现内存共享;</p> 
<p>如果主进程需要写操作,会拷贝数据副本,映射关系重新指向;</p> 
<p>fork采用的是copy-on-write [写入时复制] 技术：</p> 
<ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。<br> <img src="https://images2.imgbox.com/8c/b7/l3cylYJQ_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="4RDB__87"></a>4.RDB 的优缺点</h3> 
<p>优点：</p> 
<ul><li>适合大规模的数据恢复。</li><li>如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</li></ul> 
<p>缺点：</p> 
<ul><li>RDB执行时间间隔长,两次RDB之间写入数据由丢失的风险;</li><li>fork子进程、压缩、写出RDB文件都比较耗时;</li><li>备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。<br> 所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</li></ul> 
<h3><a id="5_101"></a>5.小结</h3> 
<p>1.RDB方式bgsave的基本流程？</p> 
<ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul> 
<p>2.RDB会在什么时候执行？save 60 1000代表什么含义？</p> 
<ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul> 
<p>3.RDB的缺点？</p> 
<ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul> 
<h2><a id="RDB_120"></a>二.RDB持久化</h2> 
<h3><a id="1AOF_121"></a>1.AOF原理</h3> 
<p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p> 
<p>Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。</p> 
<p>PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。<br> <img src="https://images2.imgbox.com/21/89/Sqldre00_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2AOF_132"></a>2.AOF配置</h3> 
<p>肯定不能每执行一条写入命令就记录到文件中，那会严重拖垮redis性能！redis存在一个缓冲区，然后把要记录的命令先临时保存在这里，然后再择机写入文件,这个临时缓冲区叫做aof_buf。</p> 
<p><strong>AOF默认是关闭的</strong>，需要修改redis.conf配置文件来开启AOF：</p> 
<pre><code class="prism language-properties"># 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"
</code></pre> 
<p>AOF的命令记录的频率也可以通过redis.conf文件来配：<br> <code>appendfsync always </code><br> 表示每执行一次写命令，立即记录到AOF文件,<strong>即每操作刷盘;</strong></p> 
<p><code>appendfsync everysec </code><br> 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案,<strong>即每秒刷盘</strong></p> 
<p><code>appendfsync no</code><br> 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</p> 
<p><strong>为什么要进行刷盘操作?</strong><br> 操作系统也有个缓存区，写的数据被他缓存起来了，没有写入到文件中去;</p> 
<p><strong>三种策略对比：</strong></p> 
<table><thead><tr><th>项目</th><th>刷盘时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td>同步刷盘</td><td>可靠性高,几乎不丢失数据</td><td>性能影响大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢失一秒数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性较差,可能丢失大量数据</td></tr></tbody></table> 
<h3><a id="3AOF_170"></a>3.AOF文件重写</h3> 
<h4><a id="31__171"></a>3.1 定义</h4> 
<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<strong>bgrewriteaof</strong>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。<br> <img src="https://images2.imgbox.com/79/69/1U3nMfnx_o.png" alt="在这里插入图片描述"></p> 
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p> 
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p> 
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p> 
<pre><code class="prism language-properties"># AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 


</code></pre> 
<h4><a id="32__189"></a>3.2 步骤</h4> 
<ul><li>主线程fork出子进程重写aof日志</li><li>子进程重写日志完成后，主线程追加aof日志缓冲</li><li>替换日志文件</li></ul> 
<h4><a id="33__195"></a>3.3 问题</h4> 
<p><strong>1.AOF重写会阻塞吗？</strong><br> AOF重写过程是由后台进程bgrewriteaof来完成的。<br> 主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。</p> 
<p>然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p> 
<p>所以aof在重写时，在fork进程时是会阻塞住主线程的。</p> 
<p><strong>2.AOF日志何时会重写？</strong><br> 有两个配置项控制AOF重写的触发：</p> 
<p>auto-aof-rewrite-min-size:表示运行AOF重写时文件的最小大小，默认为64MB。</p> 
<p>auto-aof-rewrite-percentage:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。</p> 
<h3><a id="4AOF_210"></a>4.AOF优缺点</h3> 
<p><strong>优点:</strong></p> 
<ul><li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</li><li>由于该机制对日志文件的写入操作采用的是append模式，<strong>因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过<code> redis-check-aof</code> 工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul> 
<p><strong>缺点:</strong></p> 
<ul><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li></ul> 
<h3><a id="5RDBAOF_223"></a>5.RDB与AOF对比</h3> 
<p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。<br> <img src="https://images2.imgbox.com/05/5a/BJNEiBO4_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="RDBAOF_227"></a>三:RDB和AOF混合方式</h2> 
<p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p> 
<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p> 
<p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。<br> <img src="https://images2.imgbox.com/9a/2b/mopsKmcK_o.png" alt="在这里插入图片描述"></p> 
<p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。</p> 
<h2><a id="_238"></a>四:数据恢复</h2> 
<p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br> <img src="https://images2.imgbox.com/7a/c7/V5QrEksO_o.png" alt="在这里插入图片描述"></p> 
<ul><li>redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；</li><li>如果aof存在,那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动;</li><li>若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功;</li><li>如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；</li></ul> 
<p><strong>那么为什么会优先加载AOF呢？</strong><br> 因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p> 
<h2><a id="_250"></a>五:性能与实践</h2> 
<p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p> 
<ul><li>降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；</li><li>控制Redis最大使用内存，防止fork耗时过长；</li><li>使用更牛逼的硬件；</li><li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li></ul> 
<p>在线上我们到底该怎么做？</p> 
<ul><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据;</li><li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li><li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li><li>RDB持久化与AOF持久化可以同时存在，配合使用。</li></ul> 
<h2><a id="_265"></a>六.总结</h2> 
<ul><li>aof 命令集合文件,rdb 数据集合文件</li><li><a href="https://blog.csdn.net/ll594317566/article/details/109215575">故事化的rdb和aof,通俗易懂</a></li><li><a href="https://huaweicloud.csdn.net/63356724d3efff3090b55c2e.html?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-2-122035596-blog-109215575.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-2-122035596-blog-109215575.pc_relevant_vip_default&amp;utm_relevant_index=3" rel="nofollow">redis持久化详解</a></li><li><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=99&amp;spm_id_from=pageDriver&amp;vd_source=aab1f3d87fa217616c0491d70d0658a5" rel="nofollow">黑马yyds</a></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5a8c0364e235e9202460d2f8d7520b3e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">日期正则表达式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fcfa38db056cfbde2761de519c75b763/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue3 antd table表格的增删改查（三）实现删除的数据的行样式修改【后台管理系统 纯前端rowClassName更改行样式】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>