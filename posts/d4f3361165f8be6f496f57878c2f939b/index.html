<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android apk文件的签名问题 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android apk文件的签名问题" />
<meta property="og:description" content="android的APK文件实际上是一个jar文件。jar的意思是瓶、罐，那就意味着jar文件是一个用来存放android应用相关文件的容器。事实上，它也确实如此，它只是一个带或不带压缩的zip文件，当你把.apk后缀改成.zip后，就能对此进行解压了。用java写的不同类型应用都会使用jar来存储它们的文件。jar有一些特殊的结构。
参考：KeyStore文件
1. 编译一个未签名的apk文件 P2PIM % gradlew :app:assembleRelease 我们将在下面的路径找到未签名的apk文件app-release-unsigned.apk：
app/build/outputs/apk/release/app-release-unsigned.apk 2.用.jks对apk进行签名 // --ks 从初始化好的KeyStore加载私钥和证书链，KeyStore的初始化是基于指定的.jks文件的 % ./apksigner sign --ks kyunban.jks --out app-release-signed.apk app-release-unsigned.apk Keystore password for signer #1: 输入.jks的保护密码，就可以完成签名:
% ls app-release-signed.apk apksigner apksigner对给定的apk文件进行签名，它会剥离任何先前存在的签名。
换句话说，当将要进行签名的apk已经签过名了，那么apksigner会把已存在的签名先删除掉，再进行重新签名。
使用一个或多个签名者执行，每个签名者由一个非对称密钥表示
Pair和对应的证书。通常，APK只由一个人签名
签名者。对于每个签名者，需要提供签名者的私钥和
证书。
签名是由一个或多个签名者来完成的，就像一份重要的文件一样，可能是由一个重要的人来签名即可，也可能需要好几个重要的人来共同签名才能有效。在计算机里的签名也是一样的，首先是选择非对称密钥对和相应的证书来完成。私钥是掌握在签名者自己手中，另人是没有的。证书是用来传输对应的公钥。 因为私钥加密的内容只能用其公钥来解密，又因私钥只掌握在签名者自己手中，因此就构成了签名者无法抵赖签名的事实。因此签名者都是要用各自的私钥来进行签名的。
在Android领域，要对apk文件进行签名时，只能用一个签名者的私钥来签名，它不能够联名签名。所以对已签名的apk文件进行重新签名时，它会先把先前的签名剥离掉先，再签名。
所以要对apk签名，签名者必须提供私钥和证书，证书中有私钥对应的公钥。
.jks只是一份存放了相应的私钥、公钥和证书的地方，其实，也可以用类似.jks文件来对apk文件进行签名，apksigner支持的就行，这里列举一些签名的例子：
只用keystore文件kyunban.jks中的私钥进行签名： // 如果不通过--out指定新的文件名，签名的文件也就是app.apk，覆盖掉原先未签名的文件 $ apksigner sign --ks kyunban.jks app.apk 只用keystore文件kyunban.jks中的私钥进行签名，签名的文件不覆盖原来未签名的文件 $ apksigner sign --ks kyunban.jks --in app.apk --out app-signed.apk 通过.pk8文件中的私钥和证书文件中的证书链一起签名，注意这里要求证书文件格式必须是X.509 PEM 或 DER 格式: $ apksigner sign --key release." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d4f3361165f8be6f496f57878c2f939b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T18:01:41+08:00" />
<meta property="article:modified_time" content="2024-01-06T18:01:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android apk文件的签名问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>android的APK文件实际上是一个jar文件。jar的意思是瓶、罐，那就意味着jar文件是一个用来存放android应用相关文件的容器。事实上，它也确实如此，它只是一个带或不带压缩的zip文件，当你把.apk后缀改成.zip后，就能对此进行解压了。用java写的不同类型应用都会使用jar来存储它们的文件。jar有一些特殊的结构。</p> 
<p>参考：<a href="https://blog.csdn.net/weixin_40763897/article/details/135424393">KeyStore文件</a></p> 
<h3><a id="1_apk_3"></a>1. 编译一个未签名的apk文件</h3> 
<pre><code class="prism language-kotlin">P2PIM <span class="token operator">%</span> gradlew <span class="token operator">:</span>app<span class="token operator">:</span>assembleRelease
</code></pre> 
<p>我们将在下面的路径找到未签名的apk文件<strong>app-release-unsigned.apk</strong>：</p> 
<pre><code class="prism language-kotlin">app<span class="token operator">/</span>build<span class="token operator">/</span>outputs<span class="token operator">/</span>apk<span class="token operator">/</span>release<span class="token operator">/</span>app<span class="token operator">-</span>release<span class="token operator">-</span>unsigned<span class="token punctuation">.</span>apk
</code></pre> 
<h3><a id="2jksapk_13"></a>2.用.jks对apk进行签名</h3> 
<pre><code class="prism language-kotlin"><span class="token comment">// --ks 从初始化好的KeyStore加载私钥和证书链，KeyStore的初始化是基于指定的.jks文件的</span>
 <span class="token operator">%</span> <span class="token punctuation">.</span><span class="token operator">/</span>apksigner sign <span class="token operator">--</span>ks kyunban<span class="token punctuation">.</span>jks <span class="token operator">--</span><span class="token keyword">out</span> app<span class="token operator">-</span>release<span class="token operator">-</span>signed<span class="token punctuation">.</span>apk app<span class="token operator">-</span>release<span class="token operator">-</span>unsigned<span class="token punctuation">.</span>apk
Keystore password <span class="token keyword">for</span> signer #<span class="token number">1</span><span class="token operator">:</span> 
</code></pre> 
<p>输入.jks的保护密码，就可以完成签名:</p> 
<pre><code class="prism language-kotlin"> <span class="token operator">%</span> ls
app<span class="token operator">-</span>release<span class="token operator">-</span>signed<span class="token punctuation">.</span>apk 
</code></pre> 
<h3><a id="apksigner_27"></a>apksigner</h3> 
<p>apksigner对给定的apk文件进行签名，它会剥离任何先前存在的签名。<br> 换句话说，当将要进行签名的apk已经签过名了，那么apksigner会把已存在的签名先删除掉，再进行重新签名。</p> 
<p>使用一个或多个签名者执行，每个签名者由一个非对称密钥表示<br> Pair和对应的证书。通常，APK只由一个人签名<br> 签名者。对于每个签名者，需要提供签名者的私钥和<br> 证书。</p> 
<p>签名是由一个或多个签名者来完成的，就像一份重要的文件一样，可能是由一个重要的人来签名即可，也可能需要好几个重要的人来共同签名才能有效。在计算机里的签名也是一样的，首先是选择非对称密钥对和相应的证书来完成。私钥是掌握在签名者自己手中，另人是没有的。证书是用来传输对应的公钥。 因为私钥加密的内容只能用其公钥来解密，又因私钥只掌握在签名者自己手中，因此就构成了签名者无法抵赖签名的事实。因此签名者都是要用各自的私钥来进行签名的。</p> 
<p>在Android领域，要对apk文件进行签名时，只能用一个签名者的私钥来签名，它不能够联名签名。所以对已签名的apk文件进行重新签名时，它会先把先前的签名剥离掉先，再签名。</p> 
<p>所以要对apk签名，签名者必须提供私钥和证书，证书中有私钥对应的公钥。</p> 
<p>.jks只是一份存放了相应的私钥、公钥和证书的地方，其实，也可以用类似.jks文件来对apk文件进行签名，apksigner支持的就行，这里列举一些签名的例子：</p> 
<ol><li>只用keystore文件kyunban.jks中的私钥进行签名：</li></ol> 
<pre><code class="prism language-kotlin"><span class="token comment">// 如果不通过--out指定新的文件名，签名的文件也就是app.apk，覆盖掉原先未签名的文件</span>
$ apksigner sign <span class="token operator">--</span>ks kyunban<span class="token punctuation">.</span>jks app<span class="token punctuation">.</span>apk
</code></pre> 
<ol start="2"><li>只用keystore文件kyunban.jks中的私钥进行签名，签名的文件不覆盖原来未签名的文件</li></ol> 
<pre><code class="prism language-kotlin">$ apksigner sign <span class="token operator">--</span>ks kyunban<span class="token punctuation">.</span>jks <span class="token operator">--</span><span class="token keyword">in</span> app<span class="token punctuation">.</span>apk <span class="token operator">--</span><span class="token keyword">out</span> app<span class="token operator">-</span>signed<span class="token punctuation">.</span>apk
</code></pre> 
<ol start="3"><li>通过.pk8文件中的私钥和证书文件中的证书链一起签名，注意这里要求证书文件格式必须是X.509 PEM 或 DER 格式:</li></ol> 
<pre><code class="prism language-kotlin">$ apksigner sign <span class="token operator">--</span>key release<span class="token punctuation">.</span>pk8 <span class="token operator">--</span>cert release<span class="token punctuation">.</span>x509<span class="token punctuation">.</span>pem app<span class="token punctuation">.</span>apk
</code></pre> 
<ol start="4"><li>用两个私钥对apk文件进行签名</li></ol> 
<pre><code class="prism language-kotlin">$ apksigner sign <span class="token operator">--</span>ks release<span class="token punctuation">.</span>jks <span class="token operator">--</span>next<span class="token operator">-</span>signer <span class="token operator">--</span>ks magic<span class="token punctuation">.</span>jks app<span class="token punctuation">.</span>apk
</code></pre> 
<ol start="5"><li>如果签名时，.jks用的密码字符不是ASCII编码，那么需要通过<code>--pass-encoding</code>指定密码的字符集，这样就可以使用非ASCII编码的密码了。</li></ol> 
<pre><code class="prism language-kotlin">$ apksigner sign <span class="token operator">--</span>ks release<span class="token punctuation">.</span>jks <span class="token operator">--</span>pass<span class="token operator">-</span>encoding ibm437 app<span class="token punctuation">.</span>apk
</code></pre> 
<ol start="6"><li>使用 Java Crypto Architecture (JCA) （Java加密体系）签名apk文件，典型的就是用PKCS #11的提供者来签名，这些提供者的类文件要提前安装好，确保在命令行中能够访问到它们：</li></ol> 
<pre><code class="prism language-kotlin"><span class="token comment">// --provider-class指定签名的提供者</span>
<span class="token comment">// --provider-arg指定参数文件，这些参数是传给--provider-class指定的类的</span>
<span class="token comment">// --ks NONE 不需要keystore文件来提供私钥，这种签名用的是PKCS #11密钥库，即PKCS #11的keystore。</span>
<span class="token comment">// --key-type指定密钥库即keystore使用的类型或算法，没有指定就用默认的。这里用PKCS11算法</span>
$ apksigner sign <span class="token operator">--</span>provider<span class="token operator">-</span><span class="token keyword">class</span> sun<span class="token punctuation">.</span>security<span class="token punctuation">.</span>pkcs11<span class="token punctuation">.</span>SunPKCS11 <span class="token operator">--</span>provider<span class="token operator">-</span>arg token<span class="token punctuation">.</span>cfg <span class="token operator">--</span>ks NONE <span class="token operator">--</span>ks<span class="token operator">-</span>type PKCS11 app<span class="token punctuation">.</span>apk
</code></pre> 
<ol start="7"><li>用轮换签名证书签名apk文件，这个签名方案只在v3中支持。这种签名方式中，签名的历史记录会被使用到。本次签名用到的证书，与上次是不同的。<code>--lineage</code>指定的就是这个历史记录，这是用apksigner的rotate命令创建的。这个命令的作用就是添加一个新的签名证书到SigningCertificateLineage这个对象。如果使用这种方式签名的话，所有的签名者都必须在signing lineage中。估计比较少人用这种，但无疑它更加安全。</li></ol> 
<pre><code class="prism language-kotlin">$ apksigner sign <span class="token operator">--</span>ks release<span class="token punctuation">.</span>jks <span class="token operator">--</span>next<span class="token operator">-</span>signer <span class="token operator">--</span>ks release2<span class="token punctuation">.</span>jks <span class="token operator">--</span>lineage <span class="token operator">/</span>path<span class="token operator">/</span><span class="token keyword">to</span><span class="token operator">/</span>signing<span class="token operator">/</span>history<span class="token operator">/</span>lineage app<span class="token punctuation">.</span>apk
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b28f976f56976d8fcde4c1227eefda71/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">华为面经总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bef8bc995b738226efd428a74f6c5714/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【无标题】finalshell 上传php文件，出现500错误的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>