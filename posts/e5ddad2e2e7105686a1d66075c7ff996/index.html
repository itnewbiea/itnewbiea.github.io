<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>八皇后问题（启发式搜索） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="八皇后问题（启发式搜索）" />
<meta property="og:description" content="八皇后问题是回溯算法的典型案例，在回溯法中，常常是盲目搜索，耗费过多的搜索时间。在本次实验中，使用了启发式搜索，搜索时不是任取一个分支，而是选择最佳的分支往下搜索。
目录
前言：
一、初始化参数：
二、检测某位置是否可以放置皇后
三、某位置放置皇后的调整
四、删除某位置的皇后
五、计算剩余行所剩可以放置皇后位置的个数
六 、呈现最后的矩阵
七、启发式搜索
八、完整代码：
前言： XDU作业：启发式算法解决八皇后问题。
问题描述：问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
一、初始化参数： n：代表皇后的个数，因为规定每行放置一个皇后，所以也可以理解为行数。
checkboard：代表最后呈现出来的矩阵，这里用‘0’表示该位置为空位，既没有放置皇后；用‘1’代表该位置已经放置皇后了。
queen_position: 代表每一行皇后所在改行的列数，因为题目默认是8行，所以设置了8个元素的数组初始值为-1，如果第一行的元素放在第1列，则queen_position[0] = 1。
available_position: 检测该行的某列是否满足可以放置皇后的条件，为三行十五列的矩阵，available_position[0][i]代表i列是否已经放置过皇后了，available_position[1][i]代表该位置的右对角线是否放置过皇后，available_position[2][i]代表该位置左对角线是否放置过皇后。
fx：代表代价。即若该位置皇后后，后面可以放置皇后的位置还有多少个。
answer: 代表该行是否符合可以放置皇后。
二、检测某位置是否可以放置皇后 输入函数的参数为行数和列数。
如果该位置的左对角线，右对角线，及该位置所在的列数都没有放置过皇后，则满足条件。
返回True，则该位置可以放置皇后，返回False，则该位置不满足放置皇后的条件。
#to test the position of [row, col] could be able to place queen or not def queen_admission(row, col): global available_position global queen_position if(available_position[0][col] and available_position[1][row&#43;col] and available_position[2][row-col&#43;n-1]): return True else: return False 三、某位置放置皇后的调整 输入函数的参数为行数和列数。
在该位置放置皇后，则该列的0要置1，左对角线和右对角线的相应的位置都要置1。
并记录该行皇后所在的位置。
#place the queen into [row,col] def place_queen(row, col): global available_position global queen_position queen_position[row] = col available_position[0][col] = 0 available_position[1][row&#43;col] = 0 available_position[2][row-col&#43;n-1] = 0 return None 四、删除某位置的皇后 输入函数的参数为行数和列数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e5ddad2e2e7105686a1d66075c7ff996/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-26T18:49:05+08:00" />
<meta property="article:modified_time" content="2021-10-26T18:49:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">八皇后问题（启发式搜索）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        八皇后问题是回溯算法的典型案例，在回溯法中，常常是盲目搜索，耗费过多的搜索时间。在本次实验中，使用了启发式搜索，搜索时不是任取一个分支，而是选择最佳的分支往下搜索。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow" title="前言：">前言：</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%EF%BC%9A" rel="nofollow" title="一、初始化参数：">一、初始化参数：</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%A3%80%E6%B5%8B%E6%9F%90%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%A3%80%E6%B5%8B%E6%9F%90%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E" rel="nofollow" title="二、检测某位置是否可以放置皇后">二、检测某位置是否可以放置皇后</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E6%9F%90%E4%BD%8D%E7%BD%AE%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E%E7%9A%84%E8%B0%83%E6%95%B4-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E6%9F%90%E4%BD%8D%E7%BD%AE%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E%E7%9A%84%E8%B0%83%E6%95%B4" rel="nofollow" title="三、某位置放置皇后的调整">三、某位置放置皇后的调整</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%88%A0%E9%99%A4%E6%9F%90%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%9A%87%E5%90%8E-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%88%A0%E9%99%A4%E6%9F%90%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%9A%87%E5%90%8E" rel="nofollow" title="四、删除某位置的皇后">四、删除某位置的皇后</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E5%89%A9%E4%BD%99%E8%A1%8C%E6%89%80%E5%89%A9%E5%8F%AF%E4%BB%A5%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%AA%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E5%89%A9%E4%BD%99%E8%A1%8C%E6%89%80%E5%89%A9%E5%8F%AF%E4%BB%A5%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%AA%E6%95%B0" rel="nofollow" title="五、计算剩余行所剩可以放置皇后位置的个数">五、计算剩余行所剩可以放置皇后位置的个数</a></p> 
<p id="%E5%85%AD%20%E3%80%81%E5%91%88%E7%8E%B0%E6%9C%80%E5%90%8E%E7%9A%84%E7%9F%A9%E9%98%B5-toc" style="margin-left:0px;"><a href="#%E5%85%AD%20%E3%80%81%E5%91%88%E7%8E%B0%E6%9C%80%E5%90%8E%E7%9A%84%E7%9F%A9%E9%98%B5" rel="nofollow" title="六 、呈现最后的矩阵">六 、呈现最后的矩阵</a></p> 
<p id="%C2%A0%E4%B8%83%E3%80%81%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%83%E3%80%81%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2" rel="nofollow" title="七、启发式搜索">七、启发式搜索</a></p> 
<p id="%E5%85%AB%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow" title="八、完整代码：">八、完整代码：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>        <strong>XDU作业：启发式算法解决八皇后问题</strong>。</p> 
<p>问题描述：问题表述为：在8×8格的<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B/80888" rel="nofollow" title="国际象棋">国际象棋</a>上摆放8个<a href="https://baike.baidu.com/item/%E7%9A%87%E5%90%8E/15860305" rel="nofollow" title="皇后">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%EF%BC%9A"><a id="pandas_19"></a><br><br> 一、初始化参数：</h2> 
<p><strong>n：</strong>代表皇后的个数，因为规定每行放置一个皇后，所以也可以理解为行数。</p> 
<p><strong>checkboard：</strong>代表最后呈现出来的矩阵，这里用‘0’表示该位置为空位，既没有放置皇后；用‘1’代表该位置已经放置皇后了。</p> 
<p><strong>queen_position:</strong> 代表每一行皇后所在改行的列数，因为题目默认是8行，所以设置了8个元素的数组初始值为-1，如果第一行的元素放在第1列，则<strong>queen_position[0] = 1。</strong></p> 
<p><strong>available_position: </strong>检测该行的某列是否满足可以放置皇后的条件，为三行十五列的矩阵，<strong>available_position[0][i]</strong>代表<strong>i</strong>列是否已经放置过皇后了，<strong>available_position[1][i]</strong>代表该位置的右对角线是否放置过皇后，<strong>available_position[2][i]</strong>代表该位置左对角线是否放置过皇后。</p> 
<p><strong>fx：</strong>代表代价。即若该位置皇后后，后面可以放置皇后的位置还有多少个。</p> 
<p><strong>answer: </strong>代表该行是否符合可以放置皇后。</p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E6%A3%80%E6%B5%8B%E6%9F%90%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E"><a id="_63"></a><br><br> 二、检测某位置是否可以放置皇后</h2> 
<p>输入函数的参数为行数和列数。</p> 
<p>如果该位置的左对角线，右对角线，及该位置所在的列数都没有放置过皇后，则满足条件。</p> 
<p>返回True，则该位置可以放置皇后，返回False，则该位置不满足放置皇后的条件。</p> 
<pre><code class="language-python">#to test the position of [row, col] could be able to place queen or not
def queen_admission(row, col):
    global available_position
    global queen_position
    if(available_position[0][col] and available_position[1][row+col] and available_position[2][row-col+n-1]):
        return True
    else:
        return False</code></pre> 
<hr> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E6%9F%90%E4%BD%8D%E7%BD%AE%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E%E7%9A%84%E8%B0%83%E6%95%B4">三、某位置放置皇后的调整</h2> 
<p>输入函数的参数为行数和列数。</p> 
<p>在该位置放置皇后，则该列的0要置1，左对角线和右对角线的相应的位置都要置1。</p> 
<p>并记录该行皇后所在的位置。</p> 
<pre><code class="language-python">#place the queen into [row,col]
def place_queen(row, col):
    global available_position
    global queen_position
    queen_position[row] = col
    available_position[0][col] = 0
    available_position[1][row+col] = 0
    available_position[2][row-col+n-1] = 0
    return None</code></pre> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E5%88%A0%E9%99%A4%E6%9F%90%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%9A%87%E5%90%8E">四、删除某位置的皇后</h2> 
<p>输入函数的参数为行数和列数。</p> 
<p>与放置皇后的操作相反，将该行皇后的位置置-1，及不确定该行皇后所在的列数。</p> 
<p>依次将该位置所在的列数，左右对角线相应的位置清零。</p> 
<pre><code class="language-python">#delete the queen in [row,col]
def delete_queen(row, col):
    global available_position
    global queen_position
    queen_position[row] = -1
    available_position[0][col] = 1
    available_position[1][row+col] = 1
    available_position[2][row-col+n-1] = 1
    return None</code></pre> 
<hr> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E8%AE%A1%E7%AE%97%E5%89%A9%E4%BD%99%E8%A1%8C%E6%89%80%E5%89%A9%E5%8F%AF%E4%BB%A5%E6%94%BE%E7%BD%AE%E7%9A%87%E5%90%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%B8%AA%E6%95%B0">五、计算剩余行所剩可以放置皇后位置的个数</h2> 
<p>输入函数的参数为行数和列数。</p> 
<p>依次遍历剩余行所有的列数，并判断每个位置是否为可以放置皇后位置的位置，如果满足条件则计数＋1。</p> 
<pre><code class="language-python">#find the available number
def commute_beneficial(row, col):
    global n
    global available_position
    remain_available_number = 0
    place_queen(row, col)
    for i in range(row+1, n):
        for j in range(n):
            if(queen_admission(i, j)):
                remain_available_number += 1
    delete_queen(row, col)
    return remain_available_number</code></pre> 
<hr> 
<h2 id="%E5%85%AD%20%E3%80%81%E5%91%88%E7%8E%B0%E6%9C%80%E5%90%8E%E7%9A%84%E7%9F%A9%E9%98%B5">六 、呈现最后的矩阵</h2> 
<p>取每行皇后所在列数，遍历checkboard并更改其值，最后输出checkboard。</p> 
<pre><code class="language-python">#presentation the checkerboard
def final_show():
    global n
    global queen_position
    global checkerboard

    for i in range(n):
        queen_position[i] = np.argmax(fx[i])
    for i in range(n):
        for j in range(n):
            if j == queen_position[i]:
                checkerboard[i][j] = 1
    print(checkerboard)</code></pre> 
<p>运行结果：</p> 
<p> <img alt="" height="296" src="https://images2.imgbox.com/8d/cf/kX3jRAnL_o.png" width="1200"></p> 
<hr> 
<h2 id="%C2%A0%E4%B8%83%E3%80%81%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2">七、启发式搜索</h2> 
<p>        该算法采用递归的思想，从第一行开始，直到最后一行，每列所取的列数为fx最大的那个列数。如果到某一行发现没有所满足的列数，则返回上一行，取fx次大的列数继续直到cur的值为8。</p> 
<pre><code class="language-python">#启发式搜索
def search(cur):
    global n
    global queen_position
    global checkerboard
    global fx
    global answer

    if(cur == n):
        answer = True
    else:
        flag = False
        for i in range(n):
            if(queen_admission(cur, i)):
                flag = True
                fx[cur][i] = commute_beneficial(cur, i)

        if(flag):
            while(answer == False):
                max = -1
                max_col = -1
                max = np.max(fx[cur])
                max_col = np.argmax(fx[cur])

                if(max == -1):
                    fx[cur-1][queen_position[cur-1]] = -1
                    return
                queen_position[cur] = max_col
                place_queen(cur, max_col)
                search(cur+1)
                delete_queen(cur, max_col)
        else:
            fx[cur-1][queen_position[cur-1]] = -1</code></pre> 
<hr> 
<h2 id="%E5%85%AB%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A">八、完整代码：</h2> 
<p></p> 
<pre><code class="language-python">'''
由于在某一步放置某个皇后时，可能有多个空格可以使用，所以定义启发式函数：

        fx = 剩下未放行中能够用来放皇后的空格数

    如果第i行的皇后放在第j列合法，计算启发式函数的值fx(i,j)。计算出第i行所有空格的fx后，
    将第i个皇后放到第i行中那个与前面i-1个皇后不在同一列或对角线上且fx值最大的空格中（相同时取第一个）。
    如果当前策略无法求解，则回溯至上一步，选择fx值次大的空格放置皇后，依次类推，直至找到一个合法的解。
'''

import numpy as np


n = 8
checkerboard = np.zeros((8, 8), dtype=int)
queen_position = np.zeros(8, dtype=int)-1
available_position = np.ones((3, 15), dtype=int)
fx = np.zeros((n, n), dtype=int) - 1
answer = False

#to test the position of [row, col] could be able to place queen or not
def queen_admission(row, col):
    global available_position
    global queen_position
    if(available_position[0][col] and available_position[1][row+col] and available_position[2][row-col+n-1]):
        return True
    else:
        return False

#place the queen into [row,col]
def place_queen(row, col):
    global available_position
    global queen_position
    queen_position[row] = col
    available_position[0][col] = 0
    available_position[1][row+col] = 0
    available_position[2][row-col+n-1] = 0
    return None

#delete the queen in [row,col]
def delete_queen(row, col):
    global available_position
    global queen_position
    queen_position[row] = -1
    available_position[0][col] = 1
    available_position[1][row+col] = 1
    available_position[2][row-col+n-1] = 1
    return None

#find the available number
def commute_beneficial(row, col):
    global n
    global available_position
    remain_available_number = 0
    place_queen(row, col)
    for i in range(row+1, n):
        for j in range(n):
            if(queen_admission(i, j)):
                remain_available_number += 1
    delete_queen(row, col)
    return remain_available_number


#presentation the checkerboard
def final_show():
    global n
    global queen_position
    global checkerboard

    for i in range(n):
        queen_position[i] = np.argmax(fx[i])
    for i in range(n):
        for j in range(n):
            if j == queen_position[i]:
                checkerboard[i][j] = 1
    print(checkerboard)

#启发式搜索
def search(cur):
    global n
    global queen_position
    global checkerboard
    global fx
    global answer

    if(cur == n):
        answer = True
    else:
        flag = False
        for i in range(n):
            if(queen_admission(cur, i)):
                flag = True
                fx[cur][i] = commute_beneficial(cur, i)

        if(flag):
            while(answer == False):
                max = -1
                max_col = -1
                max = np.max(fx[cur])
                max_col = np.argmax(fx[cur])

                if(max == -1):
                    fx[cur-1][queen_position[cur-1]] = -1
                    return
                queen_position[cur] = max_col
                place_queen(cur, max_col)
                search(cur+1)
                delete_queen(cur, max_col)
        else:
            fx[cur-1][queen_position[cur-1]] = -1


if __name__ == "__main__":

    search(0)
    final_show()</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64dc8cdd58951382e106cdddb9b268d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">STM32定时器编码器模式无法做到抗干扰</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c47e2e7c559ee3a352e90f2536feeec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基因组survey</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>