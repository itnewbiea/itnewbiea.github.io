<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实践|OpenCV4.2使用DNN进行人脸检测一（图片篇） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实践|OpenCV4.2使用DNN进行人脸检测一（图片篇）" />
<meta property="og:description" content="学更好的别人，
做更好的自己。
——《微卡智享》
本文长度为4829字，预计阅读9分钟
OpenCV DNN人脸检测
使用OpenCV进行人脸检测我写过两篇文章《C&#43;&#43; OpenCV之级联分类器--人脸检测》和《Android NDK OpenCV级联方式实时进行人脸检测》，不过这两篇里面用到的检测方式都是HAAR级联检测器，现在OpenCV4里面官方支持的人脸检测方法也已经是基于深度学习的方法进行检测了，所以我们这篇主要就是看OpenCV下用DNN进行人脸检测。
DNN人脸检测
微卡智享
实现DNN的人脸检测，需要先下载模型文件，在OpenCV的\sources\samples\dnn\face_detector目录下，有一个download_weights.py脚本文件，可以通过Pycharm执行下就可以自动下载两种模型：
01
Caffe模型
res10_300x300_ssd_iter_140000_fp16.caffemodel deploy.prototxt 直接的下载地址为：
https://raw.githubusercontent.com/opencv/opencv_3rdparty/dnn_samples_face_detector_20180205_fp16/res10_300x300_ssd_iter_140000_fp16.caffemodel 02
tensorflow模型
opencv_face_detector_uint8.pb opencv_face_detector.pbtxt 直接的下载地址为：
https://raw.githubusercontent.com/opencv/opencv_3rdparty/dnn_samples_face_detector_20180220_uint8/opencv_face_detector_uint8.pb Tips
由于我个人不用Python，所以模型我是自己下载的，这里我也只用了tensorflow的方式，所以就只下了后面的opencv_face_detector_uint8.pb
DNN的核心函数
微卡智享
#核心函数
1readNetFromTensorflow2blobFromImage
3setInput4
forward
01
readNetFrom
根据我们用的模型不同改为不同的函数，后面的参数就是加载模型文件
//Tensorflow cv::dnn::readNetFromTensorflow(_modelbinary, _modeldesc) //Caffe cv::dnn::readNetFromCaffe(_modelbinary, _modeldesc) 02
blobFromImage
Mat cv::dnn::blobFromImage( InputArray image, //输入图像 double scalefactor = 1.0, //图像缩放的比率 const Size &amp; size = Size(), //返回的Mat中数据的尺寸 const Scalar &amp; mean = Scalar(), //关于mean参数，如果之前没有深入研究过深度学习，这个还是不太好理解的。首先给出mean的数值：(104 117 123);数字从什么地方来的呢？这个是在Net训练的时候设定的，可以看到在训练的时候transform_param中设置了mean bool swapRB = false, //是否交换R和B分量 bool crop = false, //裁剪标志，指示是否在调整大小后裁剪图像 int ddepth = CV_32F //图像的数据类型，目前仅支持32F和8U ) 03" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/710d79216f149be939edf21565981a6d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-30T09:00:00+08:00" />
<meta property="article:modified_time" content="2020-03-30T09:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实践|OpenCV4.2使用DNN进行人脸检测一（图片篇）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>学更好的别人，</p> 
 <p>做更好的自己。</p> 
 <p>——《微卡智享》</p> 
 <p>本文长度为4829<strong>字</strong>，预计阅读9<strong>分钟</strong><strong></strong></p> 
 <p>OpenCV DNN人脸检测</p> 
 <p>使用OpenCV进行人脸检测我写过两篇文章《<a href="http://mp.weixin.qq.com/s?__biz=MzA4Nzk0NTU0Nw%3D%3D&amp;chksm=9030f0bca74779aa5bc86cfbd633040c93fc36ed8669dc3f0b52ab2f87e942c0da35f7f98e26&amp;idx=1&amp;mid=2247485592&amp;scene=21&amp;sn=6fd2bad0476e24fe70601431976c264c#wechat_redirect" rel="nofollow">C++ OpenCV之级联分类器--人脸检测</a>》和《<a href="http://mp.weixin.qq.com/s?__biz=MzA4Nzk0NTU0Nw%3D%3D&amp;chksm=9030f577a7477c61af68f957d681b7d82364c4c2d5e6a2717e544349bc52917fc976b906e795&amp;idx=1&amp;mid=2247486803&amp;scene=21&amp;sn=27c82773b9def886199f32ecead694f8#wechat_redirect" rel="nofollow">Android NDK OpenCV级联方式实时进行人脸检测</a>》，不过这两篇里面用到的检测方式都是HAAR级联检测器，现在OpenCV4里面官方支持的人脸检测方法也已经是基于深度学习的方法进行检测了，所以我们这篇主要就是看OpenCV下用DNN进行人脸检测。</p> 
 <p><img src="https://images2.imgbox.com/42/e8/ROzZMVqz_o.png"></p> 
 <p>DNN人脸检测</p> 
 <img src="https://images2.imgbox.com/a9/2a/8w2hR7Bx_o.png"> 
 <p>微卡智享</p> 
 <p>实现DNN的人脸检测，需要先下载模型文件，在OpenCV的\sources\samples\dnn\face_detector目录下，有一个download_weights.py脚本文件，可以通过Pycharm执行下就可以自动下载两种模型：</p> 
 <p style="text-align: center">01</p> 
 <p style="text-align: center"><strong>Caffe模型</strong></p> 
 <pre class="has"><code class="language-css">res10_300x300_ssd_iter_140000_fp16.caffemodel
deploy.prototxt
</code></pre> 
 <p>直接的下载地址为：<br></p> 
 <pre class="has"><code class="language-ruby">https://raw.githubusercontent.com/opencv/opencv_3rdparty/dnn_samples_face_detector_20180205_fp16/res10_300x300_ssd_iter_140000_fp16.caffemodel
</code></pre> 
 <p style="text-align: center">02</p> 
 <p style="text-align: center"><strong>tensorflow模型</strong></p> 
 <pre class="has"><code class="language-css">opencv_face_detector_uint8.pb
opencv_face_detector.pbtxt
</code></pre> 
 <p>直接的下载地址为：<br></p> 
 <pre class="has"><code class="language-ruby">https://raw.githubusercontent.com/opencv/opencv_3rdparty/dnn_samples_face_detector_20180220_uint8/opencv_face_detector_uint8.pb
</code></pre> 
 <p style="text-align: left"><strong>Tips</strong></p> 
 <p>由于我个人不用Python，所以模型我是自己下载的，这里我也只用了tensorflow的方式，所以就只下了后面的opencv_face_detector_uint8.pb</p> 
 <p>DNN的核心函数<br></p> 
 <img src="https://images2.imgbox.com/eb/7f/SUDH9YCe_o.png"> 
 <p>微卡智享</p> 
 <p></p> 
 <table><tbody><tr><th>#</th><th>核心函数<br></th></tr></tbody><tbody><tr><td>1</td><td>readNetFromTensorflow</td></tr><tr><td>2</td><td>blobFromImage<br></td></tr><tr><td>3</td><td>setInput</td></tr><tr><td colspan="1" rowspan="1">4<br></td><td colspan="1" rowspan="1">forward<br></td></tr></tbody></table> 
 <p></p> 
 <p style="text-align: center">01</p> 
 <p style="text-align: center">readNetFrom</p> 
 <p>根据我们用的模型不同改为不同的函数，后面的参数就是加载模型文件</p> 
 <pre class="has"><code class="language-cpp">//Tensorflow
cv::dnn::readNetFromTensorflow(_modelbinary, _modeldesc)


//Caffe
cv::dnn::readNetFromCaffe(_modelbinary, _modeldesc)
</code></pre> 
 <p style="text-align: center">02</p> 
 <p style="text-align: center">blobFromImage</p> 
 <pre class="has"><code class="language-cpp">Mat cv::dnn::blobFromImage(
    InputArray     image,  //输入图像
    double     scalefactor = 1.0,   //图像缩放的比率
    const Size &amp;     size = Size(),  //返回的Mat中数据的尺寸
    const Scalar &amp;     mean = Scalar(),    //关于mean参数，如果之前没有深入研究过深度学习，这个还是不太好理解的。首先给出mean的数值：(104 117 123);数字从什么地方来的呢？这个是在Net训练的时候设定的，可以看到在训练的时候transform_param中设置了mean
    bool     swapRB = false,  //是否交换R和B分量
    bool     crop = false,  //裁剪标志，指示是否在调整大小后裁剪图像
    int     ddepth = CV_32F //图像的数据类型，目前仅支持32F和8U
    )
</code></pre> 
 <p style="text-align: center">03</p> 
 <p style="text-align: center">setInput<br></p> 
 <pre class="has"><code class="language-cpp">void cv::dnn::Net::setInput    (    
    InputArray     blob,  //上 个函数blobFromImage的返回值
    const String &amp;     name = "",  //输入图层的名称
    double     scalefactor = 1.0,  //可选的标准化比例
    const Scalar &amp;     mean = Scalar() //可选的平均减法值
    )
</code></pre> 
 <p style="text-align: center">04</p> 
 <p style="text-align: center">forward</p> 
 <pre class="has"><code class="language-javascript"> Mat forward(const String&amp; outputName = String())
 
 //outputName：需要输出的图层的名称
 //返回：指定图层outputName的第一个输出的blob。默认情况下，为整个网络运行正向传递。注意：返回Mat类型，这是一个4D数，rows and cols can only hold 2 dimensions, so they are not used here, and set to -1
</code></pre> 
 <p>DNN检测封装</p> 
 <img src="https://images2.imgbox.com/b9/cb/b262CADx_o.png"> 
 <p>微卡智享</p> 
 <p>我直接把DNN的检测的封装了一个名称为dnnfacedetect的C++的类出来，可以直接拷贝复用了。</p> 
 <h3>dnnfacedetect.h</h3> 
 <pre class="has"><code class="language-cpp">#pragma once


#include&lt;opencv2/opencv.hpp&gt;
#include&lt;opencv2/dnn/dnn.hpp&gt;


using namespace std;
using namespace cv;


class dnnfacedetect
{
private:
  string _modelbinary, _modeldesc;
  dnn::Net _net;
public:
  //构造函数 传入模型文件
  dnnfacedetect();
  dnnfacedetect(string modelBinary, string modelDesc);


  ~dnnfacedetect();
  //置信阈值
  float confidenceThreshold;
  double inScaleFactor;
  size_t inWidth;
  size_t inHeight;
  Scalar meanVal;


  //初始化DNN网络
  bool initdnnNet();


  //人脸检测
  vector&lt;Mat&gt; detect(Mat frame);
};
</code></pre> 
 <h3>dnnfacedetect.cpp</h3> 
 <pre class="has"><code class="language-cpp">#include "dnnfacedetect.h"




dnnfacedetect::dnnfacedetect()
{
  dnnfacedetect("", "");
}


//构造函数
dnnfacedetect::dnnfacedetect(string modelBinary, string modelDesc)
{
  _modelbinary = modelBinary;
  _modeldesc = modelDesc;


  //初始化置信阈值
  confidenceThreshold = 0.6;
  inScaleFactor = 0.5;
  inWidth = 300;
  inHeight = 300;
  meanVal = Scalar(104.0, 177.0, 123.0);
}


dnnfacedetect::~dnnfacedetect()
{
  _net.~Net();
}


//初始化dnnnet
bool dnnfacedetect::initdnnNet()
{
  _net = dnn::readNetFromTensorflow(_modelbinary, _modeldesc);
  _net.setPreferableBackend(dnn::DNN_BACKEND_OPENCV);
  _net.setPreferableTarget(dnn::DNN_TARGET_CPU);


  return !_net.empty();
}


//人脸检测
vector&lt;Mat&gt; dnnfacedetect::detect(Mat frame)
{
  Mat tmpsrc = frame;
  vector&lt;Mat&gt; dsts = vector&lt;Mat&gt;();
  // 修改通道数
  if (tmpsrc.channels() == 4)
    cvtColor(tmpsrc, tmpsrc, COLOR_BGRA2BGR);
  // 输入数据调整
  Mat inputBlob = dnn::blobFromImage(tmpsrc, inScaleFactor,
    Size(inWidth, inHeight), meanVal, false, false);
  _net.setInput(inputBlob, "data");


  //人脸检测
  Mat detection = _net.forward("detection_out");


  Mat detectionMat(detection.size[2], detection.size[3],
    CV_32F, detection.ptr&lt;float&gt;());


  //检测出的结果进行绘制和存放到dsts中
  for (int i = 0; i &lt; detectionMat.rows; i++) {
    //置值度获取
    float confidence = detectionMat.at&lt;float&gt;(i, 2);
    //如果大于阈值说明检测到人脸
    if (confidence &gt; confidenceThreshold) {
      //计算矩形
      int xLeftBottom = static_cast&lt;int&gt;(detectionMat.at&lt;float&gt;(i, 3) * tmpsrc.cols);
      int yLeftBottom = static_cast&lt;int&gt;(detectionMat.at&lt;float&gt;(i, 4) * tmpsrc.rows);
      int xRightTop = static_cast&lt;int&gt;(detectionMat.at&lt;float&gt;(i, 5) * tmpsrc.cols);
      int yRightTop = static_cast&lt;int&gt;(detectionMat.at&lt;float&gt;(i, 6) * tmpsrc.rows);
      //生成矩形
      Rect rect((int)xLeftBottom, (int)yLeftBottom,
        (int)(xRightTop - xLeftBottom),
        (int)(yRightTop - yLeftBottom));


      //截出图矩形存放到dsts数组中
      Mat tmp = tmpsrc(rect);
      dsts.push_back(tmp);


      //在原图上用红框画出矩形
      rectangle(frame, rect, Scalar(0, 0, 255));
    }
  }


  return dsts;
}


</code></pre> 
 <p style="text-align: left"><strong>Tips</strong><br></p> 
 <p>上面的初始化和检测这块基本都是这个模式，最主要就是几个参数的配置，</p> 
 <p>创建项目</p> 
 <img src="https://images2.imgbox.com/b8/a1/MzwOTRt5_o.png"> 
 <p>微卡智享</p> 
 <p>新建一个C++的项目，配置OpenCV可以看《<a href="http://mp.weixin.qq.com/s?__biz=MzA4Nzk0NTU0Nw%3D%3D&amp;chksm=9030fbb3a74772a5fa7cdad89379d8e1201c87eb4e52c309fbc8b0da18c36da6f85faadae0d1&amp;idx=2&amp;mid=2247484311&amp;scene=21&amp;sn=399cbf1ca714f66d110909d147bfe56a#wechat_redirect" rel="nofollow">VS2017配置OpenCV通用属性</a>》，然后把我们需要用的模型文件和要检测的图片拷贝进去<br></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/12/1c/UtEklbc8_o.png"></p> 
 <p>在main.cpp的调用代码<br></p> 
 <pre class="has"><code class="language-cpp">#include&lt;opencv2/opencv.hpp&gt;
#include&lt;iostream&gt;
#include &lt;direct.h&gt;
#include "dnnfacedetect.h"


using namespace std;
using namespace cv;


int main(int argc, char* argv) {
  //获取程序目录
  char filepath[256];
  _getcwd(filepath, sizeof(filepath));


  cout &lt;&lt; filepath &lt;&lt; endl;
  //定义模型文件
  string ModelBinary = (string)filepath + "/opencv_face_detector_uint8.pb";
  string ModelDesc = (string)filepath + "/opencv_face_detector.pbtxt";


  //图片文件
  string picdesc = (string)filepath + "/lena.jpg";


  cout &lt;&lt; ModelBinary &lt;&lt; endl;
  cout &lt;&lt; ModelDesc &lt;&lt; endl;


  //加载图片
  Mat frame = imread(picdesc);
  imshow("src", frame);


  try
  {
    //初始化
    dnnfacedetect fdetect = dnnfacedetect(ModelBinary, ModelDesc);
    if (!fdetect.initdnnNet())
    {
      cout &lt;&lt; "初始化DNN人脸检测失败！" &lt;&lt; endl;
      return -1;
    }


    if (!frame.empty()) {
      vector&lt;Mat&gt; dst = fdetect.detect(frame);
      if (!dst.empty()) {
        for (int i = 0; i &lt; dst.size(); i++) {
          string title = "dst" + i;
          imshow(title, dst[i]);
        }
        imshow("src2", frame);
      }
    }
  }
  catch (const std::exception &amp; ex)
  {
    cout &lt;&lt; ex.what() &lt;&lt; endl;
  }


  waitKey(0);
  return 0;
}




</code></pre> 
 <p>这样整个代码就完成了，我们来看看运行的效果。<br></p> 
 <p style="text-align: center">实现效果</p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/44/23/Mnfv8eJx_o.png"></p> 
 <p>上图中可以看到，左边的是源图，中间小的就是我们人脸检测出来后截取的图，右图就是在源图的基础上用红框把人脸标识出来的图，这样我们的DNN实现人脸检测就完成了。</p> 
 <p>这篇主要介绍了DNN的人脸检测，并用图片中检测出人脸，下一篇我们在这个基础上来看看视频中实时进行人脸检测的使用</p> 
 <p><img src="https://images2.imgbox.com/4c/ff/md1OocMD_o.png"></p> 
 <p style="text-align: center">完</p> 
 <p><img src="https://images2.imgbox.com/8e/80/pqBiifr7_o.png"></p> 
 <p style="text-align: left">扫描二维码</p> 
 <p style="text-align: left">获取更多精彩</p> 
 <p>微卡智享</p> 
 <p><img src="https://images2.imgbox.com/76/8f/dmOAhP95_o.png"></p> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/e8/22/nL9h7jN3_o.png"></p> 
 <p style="text-align: center"><strong>微信圈子：微卡时光</strong></p> 
 <p style="text-align: center"><strong>学更好的别人，做更好的自己</strong></p> 
 <p style="text-align: left">除了关联本公众相关文章外，还记录了平时自己的一些计划，分享和生活的日常，让你更多的了解博主。</p> 
 <p>「 往期文章 」</p> 
 <p style="text-align: center"><a href="http://mp.weixin.qq.com/s?__biz=MzA4Nzk0NTU0Nw%3D%3D&amp;chksm=9030e8b4a74761a21f53c30a5379f6ce1c1cf5ac093b56d8611d98885ebe321bed3cb4baec9b&amp;idx=1&amp;mid=2247487632&amp;scene=21&amp;sn=ea8191148de27eef11b5b682a5784448#wechat_redirect" rel="nofollow">学习|Android中JetPack中的几个组件简单使用</a><br></p> 
 <p style="text-align: center"><a href="http://mp.weixin.qq.com/s?__biz=MzA4Nzk0NTU0Nw%3D%3D&amp;chksm=9030e8a4a74761b21217e47eeaef30d10e299a307eae6c2180736e0dc92b4fc657ab74582c2c&amp;idx=1&amp;mid=2247487616&amp;scene=21&amp;sn=a15334f9992a580ccf12ec5ab1b32fa2#wechat_redirect" rel="nofollow">Android通讯库VNanoMsg的1.0.2发布</a><br></p> 
 <p style="text-align: center"><a href="http://mp.weixin.qq.com/s?__biz=MzA4Nzk0NTU0Nw%3D%3D&amp;chksm=9030e85ea747614851285d0829b1901c4581c9baf5a985bd95b6e2418c4217c951ffe5eb45ba&amp;idx=1&amp;mid=2247487610&amp;scene=21&amp;sn=7e79fa19f3158153b1b6ade077b47c3a#wechat_redirect" rel="nofollow">学习|C++线程与指针结合的小例子</a><br></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ab701208f2b404330a646381282d155/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数学建模_1：家政服务（1）】(lingo求解)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dca654c5a4c2c1cbbb57d6c4c49c75e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLO v2 详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>