<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ryu代码解读------simple_switch_13.py 解读 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Ryu代码解读------simple_switch_13.py 解读" />
<meta property="og:description" content="simple_switch_13.py实现传统L2-switch功能 传统的简单二层交换机实现的功能 連接到連接埠的 host 之 MAC 位址，並記錄在 MAC 位址表當中。對於已經記錄下來的 MAC 位址，若是收到送往該 MAC 位址的封包，則轉送該封包到相對應的連接埠。對於未指定目標位址的封包，則執行 Flooding 进阶到SDN的OpenFlow交换机实现功能 對於接收到的封包進行修改或針對指定的連接埠進行轉送對於接收到的封包進行轉送到 Controller 的動作(Packet-In)對於接收到來自 Controller 的封包轉送到指定的連接埠(Packet-Out) 这里其实就是涉及到之前学的之前学的交换机接收到数据报有匹配和无匹配流表 的情况下的两种处理数据包形式，不过这里就是简单的mac_to_port的映射表。 如果是已經存在記錄中的 host：使用 Packet-Out 功能轉送至先前所對應的連接埠如果是尚未存在記錄中的 host：使用Packet-Out 功能來達到 Flooding 图片理解 from ryu.base import app_manager from ryu.controller import ofp_event from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER from ryu.controller.handler import set_ev_cls from ryu.ofproto import ofproto_v1_3 from ryu.lib.packet import packet from ryu.lib.packet import ethernet from ryu.lib.packet import ether_types # 继承ryu.base.app_manager.RyuApp # 基类ryu.base.app_manager.RyuAPP是所有开发APP必备继承的类， # 可以理解成开发APP的环境，而且有了它都不用注册，非常方便 class SimpleSwitch13(app_manager." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/aaaf35550fa4857e31be4c66ff07c0cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-10T00:51:58+08:00" />
<meta property="article:modified_time" content="2021-04-10T00:51:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Ryu代码解读------simple_switch_13.py 解读</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="simple_switch_13pyL2switch_0"></a>simple_switch_13.py实现传统L2-switch功能</h2> 
<h3><a id="_1"></a>传统的简单二层交换机实现的功能</h3> 
<ul><li>連接到連接埠的 host 之 MAC 位址，並記錄在 MAC 位址表當中。</li><li>對於已經記錄下來的 MAC 位址，若是收到送往該 MAC 位址的封包，則轉送該封包到相對應的連接埠。</li><li>對於未指定目標位址的封包，則執行 Flooding</li></ul> 
<h3><a id="SDNOpenFlow_7"></a>进阶到SDN的OpenFlow交换机实现功能</h3> 
<ul><li>對於接收到的封包進行修改或針對指定的連接埠進行轉送</li><li>對於接收到的封包進行轉送到 Controller 的動作(Packet-In)</li><li>對於接收到來自 Controller 的封包轉送到指定的連接埠(Packet-Out)</li></ul> 
<pre><code class="prism language-c">这里其实就是涉及到之前学的之前学的交换机接收到数据报有匹配和无匹配流表
的情况下的两种处理数据包形式，不过这里就是简单的mac_to_port的映射表。
</code></pre> 
<ul><li>如果是已經存在記錄中的 host：使用 Packet-Out 功能轉送至先前所對應的連接埠</li><li>如果是尚未存在記錄中的 host：使用Packet-Out 功能來達到 Flooding</li></ul> 
<h3><a id="_21"></a>图片理解</h3> 
<p><img src="https://images2.imgbox.com/e2/f7/atF8gmD4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/01/b8/DJEjSKgl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b6/1f/XGfEQMZQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/eb/0e/XrRq8EAb_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> ryu<span class="token punctuation">.</span>base <span class="token keyword">import</span> app_manager
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>controller <span class="token keyword">import</span> ofp_event
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>controller<span class="token punctuation">.</span>handler <span class="token keyword">import</span> CONFIG_DISPATCHER<span class="token punctuation">,</span> MAIN_DISPATCHER
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>controller<span class="token punctuation">.</span>handler <span class="token keyword">import</span> set_ev_cls
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>ofproto <span class="token keyword">import</span> ofproto_v1_3
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>packet <span class="token keyword">import</span> packet
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>packet <span class="token keyword">import</span> ethernet
<span class="token keyword">from</span> ryu<span class="token punctuation">.</span>lib<span class="token punctuation">.</span>packet <span class="token keyword">import</span> ether_types

<span class="token comment"># 继承ryu.base.app_manager.RyuApp</span>
<span class="token comment"># 基类ryu.base.app_manager.RyuAPP是所有开发APP必备继承的类，</span>
<span class="token comment"># 可以理解成开发APP的环境，而且有了它都不用注册，非常方便</span>

<span class="token keyword">class</span> <span class="token class-name">SimpleSwitch13</span><span class="token punctuation">(</span>app_manager<span class="token punctuation">.</span>RyuApp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    OFP_VERSIONS <span class="token operator">=</span> <span class="token punctuation">[</span>ofproto_v1_3<span class="token punctuation">.</span>OFP_VERSION<span class="token punctuation">]</span>  <span class="token comment"># 指定OpenFlow 1.3版本</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>SimpleSwitch13<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>mac_to_port <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> 
    <span class="token comment"># 定义MAC地址列表，这里的mac_to_port表就是对应的交换机二层通信查询表 </span>
</code></pre> 
<pre><code># set_ev_cls指定事件类别得以接受事件消息和交换机状态作为参数
# set_ev_cls第一个参数表示事件发生时应该调用的函数，第二个参数告诉交换机只有在交换机握手完成之后，才可以被调用。
# ofp_event完成了事件的定义，从而我们可以在函数中注册handler，监听事件，并作出回应
# packet_in_handler方法用于处理packet_in事件。
# @set_ev_cls修饰符用于告知RYU，被修饰的函数应该被调用。
</code></pre> 
<p>其中事件类别名称为ryu.controller.ofp_event.EventOFP+&lt;OpenFlow消息名称&gt;<br> 例如：在 Packet-In 消息的状态下的事件名称为EventOFPPacketIn<br> 对于交换机的状态来说，可指定以下中的一项<br> <img src="https://images2.imgbox.com/75/5f/q3HSwnTT_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python">    @set_ev_cls<span class="token punctuation">(</span>ofp_event<span class="token punctuation">.</span>EventOFPSwitchFeatures<span class="token punctuation">,</span> CONFIG_DISPATCHER<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">switch_features_handler</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ev<span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token comment"># ev.msg 是用来存储对应事件的 OpenFlow 消息类别实体</span>
    	<span class="token comment"># msg.datapath是用来存储OpenFlow交换机ryu.controller.controller.Datapath 类别所对应的实体</span>
        datapath <span class="token operator">=</span> ev<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>datapath  
        ofproto <span class="token operator">=</span> datapath<span class="token punctuation">.</span>ofproto  <span class="token comment"># ofproto表示使用的OpenFlow版本所对应的ryu.ofproto.ofproto_v1_3</span>
        parser <span class="token operator">=</span> datapath<span class="token punctuation">.</span>ofproto_parser  <span class="token comment"># 和ofproto一样，有对应版本ryu.ofproto.ofproto_v1_3_parser,解析协议才能使用</span>
        
		
</code></pre> 
<p>OpenFlow 交換器的握手協議完成之後，新增 Table-miss Flow Entry 到 Flow table 中為接收 Packet-In 訊息做準備。</p> 
<p>具體來說，接收到 Switch features（ Features reply ）訊息後就會新增 Table-miss Flow Entry。</p> 
<pre><code>openflow1.3版本开始就有table-miss flow entry,主要是为了第一次未能匹配流表的流(packet-in)发送给controller
</code></pre> 
<pre><code class="prism language-python">		<span class="token comment"># 下发table-miss流表项，让交换机对于不会处理的数据包通过packet-in消息上交给Ryu控制器！！！</span>
        <span class="token comment"># 匹配数据包</span>
        <span class="token comment"># 若数据包没有 match 任何一个普通 Flow Entry 时，则触发 Packet-In</span>
        match <span class="token operator">=</span> parser<span class="token punctuation">.</span>OFPMatch<span class="token punctuation">(</span><span class="token punctuation">)</span>  
        <span class="token comment"># 通过预留端口ofproto.OFPP_CONTROLLER，将packet-in消息发送给controller，并通过ofproto.OFPCML_NO_BUFFE指明Racket-in消息的原因是table miss</span>
        
        actions <span class="token operator">=</span> <span class="token punctuation">[</span>parser<span class="token punctuation">.</span>OFPActionOutput<span class="token punctuation">(</span>ofproto<span class="token punctuation">.</span>OFPP_CONTROLLER<span class="token punctuation">,</span>
                                          ofproto<span class="token punctuation">.</span>OFPCML_NO_BUFFER<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token comment"># 仔细看发送的调用函数的参数，第一个是端口，第二是bufferid，若不为空，则去指定缓存区去查找流表                                         </span>
        <span class="token comment"># 执行 add_flow() 方法以发送 Flow Mod 消息</span>
        self<span class="token punctuation">.</span>add_flow<span class="token punctuation">(</span>datapath<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> match<span class="token punctuation">,</span> actions<span class="token punctuation">)</span>
        <span class="token comment"># priority = 0 ，优先级最低，为了所有流表都匹配不到的时候，才会发送到controller</span>

    <span class="token keyword">def</span> <span class="token function">add_flow</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> datapath<span class="token punctuation">,</span> priority<span class="token punctuation">,</span> match<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> buffer_id<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    	<span class="token comment"># 新增流表项</span>
        ofproto <span class="token operator">=</span> datapath<span class="token punctuation">.</span>ofproto
        parser <span class="token operator">=</span> datapath<span class="token punctuation">.</span>ofproto_parser
		<span class="token comment"># Apply Actions 是用来设定那些必须立即执行的 action 所使用</span>
        inst <span class="token operator">=</span> <span class="token punctuation">[</span>parser<span class="token punctuation">.</span>OFPInstructionActions<span class="token punctuation">(</span>ofproto<span class="token punctuation">.</span>OFPIT_APPLY_ACTIONS<span class="token punctuation">,</span>
                                             actions<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token comment"># 通过 Flow Mod 消息将 Flow Entry 新增到 Flow table 中</span>
        <span class="token keyword">if</span> buffer_id<span class="token punctuation">:</span>
            mod <span class="token operator">=</span> parser<span class="token punctuation">.</span>OFPFlowMod<span class="token punctuation">(</span>datapath<span class="token operator">=</span>datapath<span class="token punctuation">,</span> buffer_id<span class="token operator">=</span>buffer_id<span class="token punctuation">,</span>
                                    priority<span class="token operator">=</span>priority<span class="token punctuation">,</span> match<span class="token operator">=</span>match<span class="token punctuation">,</span>
                                    instructions<span class="token operator">=</span>inst<span class="token punctuation">)</span>
        <span class="token comment"># 这里作者添加的if语句，表示流表下发缓存区id有无来区分下发,有缓存区id，到对应缓存区下发，无则自动分配，不传参buffer_id</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            mod <span class="token operator">=</span> parser<span class="token punctuation">.</span>OFPFlowMod<span class="token punctuation">(</span>datapath<span class="token operator">=</span>datapath<span class="token punctuation">,</span> priority<span class="token operator">=</span>priority<span class="token punctuation">,</span>
                                    match<span class="token operator">=</span>match<span class="token punctuation">,</span> instructions<span class="token operator">=</span>inst<span class="token punctuation">)</span>
        datapath<span class="token punctuation">.</span>send_msg<span class="token punctuation">(</span>mod<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/43/6d/Hm5QEBU5_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python">
   @set_ev_cls<span class="token punctuation">(</span>ofp_event<span class="token punctuation">.</span>EventOFPPacketIn<span class="token punctuation">,</span> MAIN_DISPATCHER<span class="token punctuation">)</span>
   <span class="token keyword">def</span> <span class="token function">_packet_in_handler</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ev<span class="token punctuation">)</span><span class="token punctuation">:</span>
       <span class="token comment"># If you hit this you might want to increase</span>
       <span class="token comment"># the "miss_send_length" of your switch</span>
       <span class="token keyword">if</span> ev<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>msg_len <span class="token operator">&lt;</span> ev<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>total_len<span class="token punctuation">:</span>
           self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">"packet truncated: only %s of %s bytes"</span><span class="token punctuation">,</span>
                             ev<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>msg_len<span class="token punctuation">,</span> ev<span class="token punctuation">.</span>msg<span class="token punctuation">.</span>total_len<span class="token punctuation">)</span>
        <span class="token comment"># 送往 Controller 的封包可以僅只傳送 header 部分（ Ethernet header ），剩下的則存在緩衝區間中以增加效率。 </span>
        <span class="token comment">#但目前（ 2014年1月 ）Open vSwitch 存在臭蟲的關係，會將所有的封包都傳送，並不會只傳送 header。</span>
       <span class="token comment">#这条logger.debug日志是为了提示送往controller的packet_in包是截取header 部分，这里我是这么理解的，有错误请大家告知</span>
       <span class="token comment"># 为了接收处理未知目的地的数据包，需要执行Packet-In 事件管理</span>
       
       msg <span class="token operator">=</span> ev<span class="token punctuation">.</span>msg  <span class="token comment"># 每一个事件类ev中都有msg成员，用于携带触发事件的数据包</span>
       datapath <span class="token operator">=</span> msg<span class="token punctuation">.</span>datapath  <span class="token comment"># 已经格式化的msg其实就是一个packet_in报文，msg.datapath直接可以获得packet_in报文的datapath结构</span>
       <span class="token comment"># datapath用于描述一个交换网桥，也是和控制器通信的实体单元。</span>
       <span class="token comment"># datapath.send_msg()函数用于发送数据到指定datapath。</span>
       <span class="token comment"># 通过datapath.id可获得dpid数据。</span>
       ofproto <span class="token operator">=</span> datapath<span class="token punctuation">.</span>ofproto  <span class="token comment"># datapath.ofproto对象是一个OpenFlow协议数据结构的对象，成员包含OpenFlow协议的数据结构，如动作类型OFPP_FLOOD</span>
       parser <span class="token operator">=</span> datapath<span class="token punctuation">.</span>ofproto_parser  <span class="token comment"># datapath.ofp_parser则是一个按照OpenFlow解析的数据结构。</span>

   	<span class="token comment"># 更新Mac地址表</span>
       in_port <span class="token operator">=</span> msg<span class="token punctuation">.</span>match<span class="token punctuation">[</span><span class="token string">'in_port'</span><span class="token punctuation">]</span>

       pkt <span class="token operator">=</span> packet<span class="token punctuation">.</span>Packet<span class="token punctuation">(</span>msg<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
       eth <span class="token operator">=</span> pkt<span class="token punctuation">.</span>get_protocols<span class="token punctuation">(</span>ethernet<span class="token punctuation">.</span>ethernet<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 
       <span class="token comment"># pkt.get_protocols 传入的是 协议类 参数</span>
       <span class="token comment"># 得到协议的ethernet.ethernet类实例的协议列表，看源码知道了lib.packet.packet/ethernet</span>

       <span class="token keyword">if</span> eth<span class="token punctuation">.</span>ethertype <span class="token operator">==</span> ether_types<span class="token punctuation">.</span>ETH_TYPE_LLDP<span class="token punctuation">:</span>
           <span class="token comment"># ignore lldp packet</span>
           <span class="token keyword">return</span>
       dst <span class="token operator">=</span> eth<span class="token punctuation">.</span>dst
       src <span class="token operator">=</span> eth<span class="token punctuation">.</span>src

       dpid <span class="token operator">=</span> datapath<span class="token punctuation">.</span><span class="token builtin">id</span>
       self<span class="token punctuation">.</span>mac_to_port<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>dpid<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
       <span class="token comment"># 指定交换机dpid，默认mac_to_port表为空</span>

       self<span class="token punctuation">.</span>logger<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"packet in %s %s %s %s"</span><span class="token punctuation">,</span> dpid<span class="token punctuation">,</span> src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> in_port<span class="token punctuation">)</span>
       <span class="token comment"># 日志记录信息</span>

       <span class="token comment"># learn a mac address to avoid FLOOD next time.</span>
       self<span class="token punctuation">.</span>mac_to_port<span class="token punctuation">[</span>dpid<span class="token punctuation">]</span><span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> in_port

   	<span class="token comment"># 判断转发的数据包的连接端口</span>
   	<span class="token comment"># 目的 MAC 位址若存在于 MAC 地址表，则判断该连接端口号码为输出。</span>
   	<span class="token comment"># 反之若不存在于 MAC 地址表则 OUTPUT action 类别的实体并生成 flooding（ OFPP_FLOOD ）给目的连接端口使用。</span>
       <span class="token keyword">if</span> dst <span class="token keyword">in</span> self<span class="token punctuation">.</span>mac_to_port<span class="token punctuation">[</span>dpid<span class="token punctuation">]</span><span class="token punctuation">:</span>
           out_port <span class="token operator">=</span> self<span class="token punctuation">.</span>mac_to_port<span class="token punctuation">[</span>dpid<span class="token punctuation">]</span><span class="token punctuation">[</span>dst<span class="token punctuation">]</span>
        <span class="token comment"># 有目的地址寻找端口号，否则泛洪</span>
       <span class="token keyword">else</span><span class="token punctuation">:</span>
           out_port <span class="token operator">=</span> ofproto<span class="token punctuation">.</span>OFPP_FLOOD
   	
   		<span class="token comment"># 准备泛洪的packet_out指令给后面的if判断语句最后的else</span>
       actions <span class="token operator">=</span> <span class="token punctuation">[</span>parser<span class="token punctuation">.</span>OFPActionOutput<span class="token punctuation">(</span>out_port<span class="token punctuation">)</span><span class="token punctuation">]</span>

       <span class="token comment"># install a flow to avoid packet_in next time</span>
       <span class="token keyword">if</span> out_port <span class="token operator">!=</span> ofproto<span class="token punctuation">.</span>OFPP_FLOOD<span class="token punctuation">:</span>
           match <span class="token operator">=</span> parser<span class="token punctuation">.</span>OFPMatch<span class="token punctuation">(</span>in_port<span class="token operator">=</span>in_port<span class="token punctuation">,</span> eth_dst<span class="token operator">=</span>dst<span class="token punctuation">,</span> eth_src<span class="token operator">=</span>src<span class="token punctuation">)</span>
           <span class="token comment"># verify if we have a valid buffer_id, if yes avoid to send both</span>
           <span class="token comment"># flow_mod &amp; packet_out</span>
           <span class="token keyword">if</span> msg<span class="token punctuation">.</span>buffer_id <span class="token operator">!=</span> ofproto<span class="token punctuation">.</span>OFP_NO_BUFFER<span class="token punctuation">:</span>
               self<span class="token punctuation">.</span>add_flow<span class="token punctuation">(</span>datapath<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> match<span class="token punctuation">,</span> actions<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>buffer_id<span class="token punctuation">)</span>
               <span class="token keyword">return</span> <span class="token comment"># 不用泛洪退出函数</span>
           <span class="token keyword">else</span><span class="token punctuation">:</span>
               self<span class="token punctuation">.</span>add_flow<span class="token punctuation">(</span>datapath<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> match<span class="token punctuation">,</span> actions<span class="token punctuation">)</span>

   	<span class="token comment"># 在 MAC 地址表中找寻目的 MAC 地址，若是有找到则发送 Packet-Out 讯息，并且转送数据包。</span>
       data <span class="token operator">=</span> <span class="token boolean">None</span>
       <span class="token keyword">if</span> msg<span class="token punctuation">.</span>buffer_id <span class="token operator">==</span> ofproto<span class="token punctuation">.</span>OFP_NO_BUFFER<span class="token punctuation">:</span>
       <span class="token comment"># 表示要泛洪发送Packet-Out，把本身的二进制数据取出来</span>
           data <span class="token operator">=</span> msg<span class="token punctuation">.</span>data
   	<span class="token comment">#需要Flooding 的actions和msg。buffer_id已经准备好了</span>
       out <span class="token operator">=</span> parser<span class="token punctuation">.</span>OFPPacketOut<span class="token punctuation">(</span>datapath<span class="token operator">=</span>datapath<span class="token punctuation">,</span> buffer_id<span class="token operator">=</span>msg<span class="token punctuation">.</span>buffer_id<span class="token punctuation">,</span>
                                 in_port<span class="token operator">=</span>in_port<span class="token punctuation">,</span> actions<span class="token operator">=</span>actions<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>
       datapath<span class="token punctuation">.</span>send_msg<span class="token punctuation">(</span>out<span class="token punctuation">)</span>
</code></pre> 
<p>参考资料：<br> <a href="https://www.sdnlab.com/1785.html" rel="nofollow">RYU入门教程</a><br> <a href="https://osrg.github.io/ryu-book/zh_tw/html/switching_hub.html" rel="nofollow">Ryubook 1.0 說明文件</a><br> <a href="https://blog.csdn.net/weixin_42094589/article/details/104160571">https://blog.csdn.net/weixin_42094589/article/details/104160571</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1819f8ec6ef87b35ae736d811d0cd7b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第一次学习Linux的经验和遇到的问题分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d58bbc72d384ac6458cfbd5aa8b78efc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 可视化冒泡排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>