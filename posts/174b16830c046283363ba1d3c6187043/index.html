<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>毕业设计 :基于深度学习的人脸识别【全网最详细】 - opencv 卷积神经网络 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="毕业设计 :基于深度学习的人脸识别【全网最详细】 - opencv 卷积神经网络" />
<meta property="og:description" content="文章目录 0 简介1 人脸识别 - 常用实现技术1.1 基于几何特征的人脸识别方法1.2 初级神经网络方法。1.3 深度学习方法。 2 人脸识别算法缺陷3 人脸识别流程3.1 相关数据集3.2 对齐3.3 仿射变换3.4 人脸目标检测3.5 人脸特征提取3.5.1 分类模型有哪些3.5.2 度量学习模型——FaceNet为例 3.6 人脸识别（特征分类）3.6.1 欧氏距离3.6.2 余弦距离3.6.3 Joint Bayesian 方法 4 实现过程4.1 自己构建人脸数据集4.1.1 拍照程序 4.2 预处理4.3 人脸特征提取 5 识别效果5.1 人脸检测效果5.2 人脸识别结果 6 最后 0 简介 今天学长向大家介绍一个机器视觉的毕设项目，基于深度学习的人脸识别
:基于深度学习的人脸识别【全网最详细】 - opencv 卷积神经网络
1 人脸识别 - 常用实现技术 人脸识别主要研究的是如何获得高效的特征， 并利进行人脸匹配的计算。 至今为止人脸识别的算法已经很多。
1.1 基于几何特征的人脸识别方法 该方法所考虑的特征相对朴。 所谓的几何特征是指人脸图像上各器官等的相对位置或相对距离所组成的矢量， 具体指利用人工方式标出人脸图像特征点位置， 对标定好的特征点计算相对距离； 将所得的多个距离按照预定顺序组成一个矢量， 该矢量即为几何特征。 Nicholas Roeder 和 Xiaobo Li 对几何特征的提取进行了详细研究， 由于几何特征只是粗略的描述的人脸图像， 因此效果并不如人意。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/174b16830c046283363ba1d3c6187043/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-01T11:23:54+08:00" />
<meta property="article:modified_time" content="2022-11-01T11:23:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">毕业设计 :基于深度学习的人脸识别【全网最详细】 - opencv 卷积神经网络</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#0__2" rel="nofollow">0 简介</a></li><li><a href="#1____12" rel="nofollow">1 人脸识别 - 常用实现技术</a></li><li><ul><li><a href="#11__17" rel="nofollow">1.1 基于几何特征的人脸识别方法</a></li><li><a href="#12__23" rel="nofollow">1.2 初级神经网络方法。</a></li><li><a href="#13__27" rel="nofollow">1.3 深度学习方法。</a></li></ul> 
  </li><li><a href="#2__33" rel="nofollow">2 人脸识别算法缺陷</a></li><li><a href="#3__45" rel="nofollow">3 人脸识别流程</a></li><li><ul><li><a href="#31__47" rel="nofollow">3.1 相关数据集</a></li><li><a href="#32__57" rel="nofollow">3.2 对齐</a></li><li><a href="#33__65" rel="nofollow">3.3 仿射变换</a></li><li><a href="#34__75" rel="nofollow">3.4 人脸目标检测</a></li><li><a href="#35__85" rel="nofollow">3.5 人脸特征提取</a></li><li><ul><li><a href="#351__87" rel="nofollow">3.5.1 分类模型有哪些</a></li><li><a href="#352_FaceNet_95" rel="nofollow">3.5.2 度量学习模型——FaceNet为例</a></li></ul> 
   </li><li><a href="#36__109" rel="nofollow">3.6 人脸识别（特征分类）</a></li><li><ul><li><a href="#361__114" rel="nofollow">3.6.1 欧氏距离</a></li><li><a href="#362__121" rel="nofollow">3.6.2 余弦距离</a></li><li><a href="#363_Joint_Bayesian__126" rel="nofollow">3.6.3 Joint Bayesian 方法</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4__134" rel="nofollow">4 实现过程</a></li><li><ul><li><a href="#41__148" rel="nofollow">4.1 自己构建人脸数据集</a></li><li><ul><li><a href="#411__152" rel="nofollow">4.1.1 拍照程序</a></li></ul> 
   </li><li><a href="#42__183" rel="nofollow">4.2 预处理</a></li><li><a href="#43__219" rel="nofollow">4.3 人脸特征提取</a></li></ul> 
  </li><li><a href="#5__335" rel="nofollow">5 识别效果</a></li><li><ul><li><a href="#51__337" rel="nofollow">5.1 人脸检测效果</a></li><li><a href="#52__342" rel="nofollow">5.2 人脸识别结果</a></li></ul> 
  </li><li><a href="#6__354" rel="nofollow">6 最后</a></li></ul> 
</div> 
<p></p> 
<h2><a id="0__2"></a>0 简介</h2> 
<p>今天学长向大家介绍一个机器视觉的毕设项目，基于深度学习的人脸识别</p> 
<p><strong>:基于深度学习的人脸识别【全网最详细】 - opencv 卷积神经网络</strong></p> 
<p><img src="https://images2.imgbox.com/1e/9c/xRO7N73y_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="1____12"></a>1 人脸识别 - 常用实现技术</h2> 
<p>人脸识别主要研究的是如何获得高效的特征， 并利进行人脸匹配的计算。 至今为止人脸识别的算法已经很多。</p> 
<h3><a id="11__17"></a>1.1 基于几何特征的人脸识别方法</h3> 
<p>该方法所考虑的特征相对朴。 所谓的几何特征是指人脸图像上各器官等的相对位置或相对距离所组成的矢量， 具体指利用人工方式标出人脸图像特征点位置， 对标定好的特征点计算相对距离； 将所得的多个距离按照预定顺序组成一个矢量， 该矢量即为几何特征。 Nicholas Roeder 和 Xiaobo Li 对几何特征的提取进行了详细研究， 由于几何特征只是粗略的描述的人脸图像， 因此效果并不如人意。</p> 
<h3><a id="12__23"></a>1.2 初级神经网络方法。</h3> 
<p>Intrato将无监督/监督混合神经网络应用到人脸识别问题上，该方法比传统的 BP 神经网络提取的特征更有效。 Cottrell 应用级联 BP 神经网络较好的解决了人脸遮挡和光照变化的问题。 W.Shiqian Wu 将 RBF 和 DCT 神经网络应用到人脸识别问题上。 E.Osuna 将支持向量机(SVM)应用到人脸识别问题。 Kung 和Lin 结合神经网络和统计学方法， 提出了基于概率决策的神经网络(PDBNN),此方法也获得了很好的结果， 这些方法都取得了较好的效果。 神经网络方法虽然简化了特征提取的工作， 学习到更加有效的特征， 但是神经网络往往有数目众多的神经元组成，因此训练耗时且难于收敛。</p> 
<h3><a id="13__27"></a>1.3 深度学习方法。</h3> 
<p>其实深度学习早在 20 世纪 90 年代就已经提出， 但是由于当时计算机技术的限制， 深度学习 并没得到很大的重视和发展。 直到 2012 年由 AlexKrizhevsky 提出的 AlexNet 卷积神经网络在 ILSVRC 图像分类竞赛中表示异常突出，从此深度学习尤其是其中的卷积神经网络得到了人们的广泛关注和深入的研究。 除了在香港中文大学的 DeepID 系列， 还有 Google 提出 FaceNet 网络 [25] ， 牛津大学提出的VGG 网络等许多不同的网络， 这些网络都取得了很好的效果。深度学习具有特征自动学习， 泛化能力强和所学特征表现里强等优点， 因此深度学习在人脸识别问题上的应用极大的推动的人脸识别的发展。 但是深度学习也具有所需训练数据巨大、 训练耗时长和难于收敛等缺点。</p> 
<h2><a id="2__33"></a>2 人脸识别算法缺陷</h2> 
<p><strong>(学长在这里推荐大家可以优化这些点，然后作为课题的创新点)</strong></p> 
<p>光照是影响人脸识别的重要原因。 现有的数字图像处理技术都是基于图像的像素值进行计算的， 因此即使是同一个人但由于光照变化引起的像素值的差异使的最终计算结果差异很大， 这极大的影响了人脸识别的性能。姿态是左右人脸识别另一个关键点。 在实际问题中人脸数据的采集往往是一种随意行为， 不能保证每次采集到是正脸。 上一节提到的各种方法往往只能适应一种姿态，对于姿态不同的图像识别问题经常是力不从心。 因此找到一种对姿态变化具有很强的鲁棒性的方法也是非常重要的。</p> 
<p>数据规模庞大也影响人脸识别性能。 在深度学习应用到人脸识别问题之前， 所提出的方法由于受到计算复杂度限制， 往往在小数据集(包含几十人或几百人)性能良好，但是在大规模数据上性能很差。 深度学习由于其具有较强的泛化能力， 因此在较大规模的数据集上表现比传统方法改善了许多。 但是深度学习的泛化能力也是相对而言较强， 其受训练集的影响很大。 目前世界上有超过 60 亿人， 而且每个地区的人面部差异较大， 在获取训练数据集时无法包含所有人， 这会对最终的泛化能力有很大影响，比如训练数据集中包括的全部是西方人(大部分是这种情况)， 训练得到的网络对于东方人的泛化能力就较低， 因此即使利用深度学习也无法区分世界上所有人。</p> 
<p>计算复杂度高对人脸识别也有影响。 计算复杂度往往随着人脸识别任务复杂度的提高和训练数据的增加而急速增加。 利用深度学习进行人脸识别， 随着神经网络规模加深， 参数量也逐渐增大， 也增加计算复杂度。 计算复杂度的增加不仅使训练时间增加， 算法难以收敛， 容易出现过拟合问题， 而且也增加了测试阶段所耗时间， 这不利用算法的实际应用。</p> 
<h2><a id="3__45"></a>3 人脸识别流程</h2> 
<h3><a id="31__47"></a>3.1 相关数据集</h3> 
<p>主要有以下几种数据集，其中仅MultiPIE需要购买，其余的申请即可。</p> 
<p><img src="https://images2.imgbox.com/11/6d/bcou3FxC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="32__57"></a>3.2 对齐</h3> 
<p>通过确定人脸中的标定点（landmark）的位置进行人脸对齐。（找3个点即可，一般找5个点：鼻子、眼睛、嘴角两端）对齐后可以找到一个二维坐标平面，进行下一步仿射变换。</p> 
<p><img src="https://images2.imgbox.com/19/6d/huVAO02T_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="33__65"></a>3.3 仿射变换</h3> 
<p><strong>原理</strong></p> 
<ul><li>二维坐标到二维坐标之间的线性变换</li><li>不共线的三对对应点决定了一个唯一的仿射变换</li></ul> 
<p><img src="https://images2.imgbox.com/50/7b/yUdXyX4c_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5e/a4/Cnu6uSAE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34__75"></a>3.4 人脸目标检测</h3> 
<p><strong>使用神经网络（比如使用的DCNN）进行回归对标定点进行检测。</strong></p> 
<p><img src="https://images2.imgbox.com/f0/af/JB3eWam7_o.png" alt="在这里插入图片描述"></p> 
<p>其中，输入原始画像后，进行4*4卷积后，在进行池化，卷积…最后使用两个全连接得到最终结果。这里面采用了一个级联思想实现CNN组合，级联思想实现细节如下图：</p> 
<p><img src="https://images2.imgbox.com/b9/9d/ZmJetkBc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="35__85"></a>3.5 人脸特征提取</h3> 
<h4><a id="351__87"></a>3.5.1 分类模型有哪些</h4> 
<ul><li>Deepface</li><li>DeepID</li><li>VGG</li><li>ResNet</li><li>FaceNet</li></ul> 
<h4><a id="352_FaceNet_95"></a>3.5.2 度量学习模型——FaceNet为例</h4> 
<p>学长以常用的FaceNet为例，下图是FaceNet的简略示意图，例如，输入三张图片：Anchor、与Anchor不同类的Negative、与Anchor同类的Positive，通过一系列学习后实现同类相近，异类相远。</p> 
<p><img src="https://images2.imgbox.com/65/87/DS1tohoy_o.png" alt="在这里插入图片描述"> 距离计算公式（前半部分为与同类positive之间的距离，后半部分计算与不同类negative的距离。）</p> 
<p><img src="https://images2.imgbox.com/43/f8/l1YW5Ebf_o.png" alt="在这里插入图片描述"><br> 最终实现效果如下图所示，距离&gt;1.1即可认为相互之间为不同人，即使一个人不同角度也可以被识别为同一人。</p> 
<p><img src="https://images2.imgbox.com/eb/9a/FOC9wFeP_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="36__109"></a>3.6 人脸识别（特征分类）</h3> 
<p>人脸识别中的人脸验证问题即是验证两张图片是否来自同一个人。主要有以下三种方法，欧氏距离和余弦距离方法是工业中常用的验证方法，Joint Bayesian方法常用在学术研究中。首先假定两张人脸图片提取的特征向量为量为 xj→ 和 xk→ 。</p> 
<h4><a id="361__114"></a>3.6.1 欧氏距离</h4> 
<p>距离差越大，相似度越小。</p> 
<p><img src="https://images2.imgbox.com/68/65/SAJa5kGI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="362__121"></a>3.6.2 余弦距离</h4> 
<p><img src="https://images2.imgbox.com/52/0e/2n6aV9wt_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="363_Joint_Bayesian__126"></a>3.6.3 Joint Bayesian 方法</h4> 
<p><img src="https://images2.imgbox.com/6b/ae/t1MK6Xkv_o.png" alt="在这里插入图片描述"></p> 
<p>其中，𝑆(∆) 是差异 ∆ 的函数，𝑃(H1)为先验概率，𝑃(Δ|H1) 为似然概率，𝑃($𝐻_1|∆)是后验概率，是人脸相似性的度量。</p> 
<h2><a id="4__134"></a>4 实现过程</h2> 
<p><img src="https://images2.imgbox.com/4a/74/Oodz335Z_o.png" alt="在这里插入图片描述"></p> 
<p>数据集来源网络搜索，我选取了几名大家认识的人物，有Biden、chenglong、mayun、Trump、yangmi、zhaoliying等。每个人物放入3-4张图片，如下图：</p> 
<p><img src="https://images2.imgbox.com/da/63/5MpKIdGh_o.png" alt="在这里插入图片描述"><br> 获得此图像数据集，我们将：</p> 
<ul><li>为数据集中的每个人脸创建 128 维嵌入</li><li>使用这些嵌入来识别图像和视频流中人物的面部</li></ul> 
<h3><a id="41__148"></a>4.1 自己构建人脸数据集</h3> 
<p>或者你有自己的想法，构建一个自己的数据集，可以的话，记得开源给学长（手动狗头）</p> 
<h4><a id="411__152"></a>4.1.1 拍照程序</h4> 
<p>想要识别自己，单有别人的数据集还是不行的，还需要自己人脸的照片才行。这就需要我们收集自己的照片，然后和上面的那个数据集一起来训练模型。在拿着手机自拍的过程中我想到，问什么不写一个程序用电脑的摄像头自拍呢，随便还能研究下怎么用opencv实现拍照的功能。经过一番实验（其实还是费了好长时间），终于写了一个拍照程序。</p> 
<p>程序的功能就是打开电脑摄像头，当P键按下（P是拍照的首字母？还是Photo的首字母？还是Picture的首字母？）的时候，保存当前帧的图像。简单到没朋友（竟然耗费了那么久！）。</p> 
<pre><code class="prism language-python"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            char key <span class="token operator">=</span> waitKey<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cap <span class="token operator">&gt;&gt;</span> frame<span class="token punctuation">;</span>
            imshow<span class="token punctuation">(</span><span class="token string">"frame"</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
            string filename <span class="token operator">=</span> <span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"D:\\pic\\pic%d.jpg"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

            switch <span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">case</span><span class="token string">'p'</span><span class="token punctuation">:</span>
                i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>
                imwrite<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
                imshow<span class="token punctuation">(</span><span class="token string">"photo"</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
                waitKey<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                destroyWindow<span class="token punctuation">(</span><span class="token string">"photo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            default<span class="token punctuation">:</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><strong>然后我们就可以运行程序，不停地按下p键对自己一通狂拍了。</strong></p> 
<h3><a id="42__183"></a>4.2 预处理</h3> 
<p>在得到自己的人脸照片之后，还需要对这些照片进行一些预处理才能拿去训练模型。所谓预处理，其实就是检测并分割出人脸，并改变人脸的大小与下载的数据集中图片大小一致。</p> 
<p>人脸检测在之前的博客中已经做了介绍，这里就不再赘述。详情参考：OpenCV人脸检测（C++/Python)。用ROI分割即可。<br> 检测出人脸之后改变大小使之与ORL人脸数据库人脸大小一致。通过加断点在Locals里面或者是ImageWatch可以看到ORL人脸数据库人脸的大小是92 x 112。</p> 
<p><img src="https://images2.imgbox.com/18/7d/sc125yNY_o.png" alt="在这里插入图片描述"><br> 这里只需要对检测后得到的ROI做一次resize即可。<br> 这两步的代码如下：</p> 
<pre><code class="prism language-python">            std<span class="token punctuation">:</span><span class="token punctuation">:</span>vector<span class="token operator">&lt;</span>Rect<span class="token operator">&gt;</span> faces<span class="token punctuation">;</span>
            Mat img_gray<span class="token punctuation">;</span>

            cvtColor<span class="token punctuation">(</span>img<span class="token punctuation">,</span> img_gray<span class="token punctuation">,</span> COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
            equalizeHist<span class="token punctuation">(</span>img_gray<span class="token punctuation">,</span> img_gray<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token operator">//</span><span class="token operator">-</span><span class="token operator">-</span> Detect faces
            face_cascade<span class="token punctuation">.</span>detectMultiScale<span class="token punctuation">(</span>img_gray<span class="token punctuation">,</span> faces<span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> CV_HAAR_DO_ROUGH_SEARCH<span class="token punctuation">,</span> Size<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> faces<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                Mat faceROI <span class="token operator">=</span> img<span class="token punctuation">(</span>faces<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                Mat MyFace<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>faceROI<span class="token punctuation">.</span>cols <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    resize<span class="token punctuation">(</span>faceROI<span class="token punctuation">,</span> MyFace<span class="token punctuation">,</span> Size<span class="token punctuation">(</span><span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    string  <span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">format</span><span class="token punctuation">(</span><span class="token string">"D:\\MyFaces\\MyFcae%d.jpg"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    imwrite<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> MyFace<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    imshow<span class="token punctuation">(</span><span class="token string">"ii"</span><span class="token punctuation">,</span> MyFace<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="43__219"></a>4.3 人脸特征提取</h3> 
<p>在识别图像和视频中的人脸之前，我们首先需要量化训练集中的人脸。 请记住，我们实际上并不是在这里训练网络——网络已经被训练为在大约 300 万张图像的数据集上创建 128 维嵌入。</p> 
<p>当然可以从头开始训练网络，甚至可以微调现有模型的权重。</p> 
<p>但一般情况，使用预训练网络然后使用它为我们数据集中的 29张人脸中的每一张构建 128 维嵌入更容易。</p> 
<p>然后，在分类过程中，我们可以使用一个简单的 k-NN 模型 + 投票来进行最终的人脸分类。 其他传统的机器学习模型也可以在这里使用。</p> 
<p>新建 encode_faces.py：</p> 
<pre><code class="prism language-python"><span class="token comment"># import the necessary packages</span>
<span class="token keyword">from</span> imutils <span class="token keyword">import</span> paths
<span class="token keyword">import</span> face_recognition
<span class="token keyword">import</span> argparse
<span class="token keyword">import</span> pickle
<span class="token keyword">import</span> cv2
<span class="token keyword">import</span> os
dataset_path<span class="token operator">=</span><span class="token string">'dataset'</span>
encodings_path<span class="token operator">=</span><span class="token string">'encodings.pickle'</span>
detection_method<span class="token operator">=</span><span class="token string">'cnn'</span>
<span class="token comment"># 获取数据集中输入图像的路径</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[INFO] quantifying faces..."</span><span class="token punctuation">)</span>
imagePaths <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>paths<span class="token punctuation">.</span>list_images<span class="token punctuation">(</span>dataset_path<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># 初始化已知编码和已知名称的列表</span>
knownEncodings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
knownNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment"># 遍历图像路径</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> imagePath<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>imagePaths<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 从图片路径中提取人名</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[INFO] processing image {}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                                 <span class="token builtin">len</span><span class="token punctuation">(</span>imagePaths<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    name <span class="token operator">=</span> imagePath<span class="token punctuation">.</span>split<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>sep<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token comment"># 加载输入图像并从 BGR 转换（OpenCV 排序）</span>
    <span class="token comment"># 到 dlib 排序（RGB）</span>
    image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>imagePath<span class="token punctuation">)</span>
    rgb <span class="token operator">=</span> cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>image<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span>
    <span class="token comment"># 检测边界框的 (x, y) 坐标</span>
    <span class="token comment"># 对应输入图像中的每个人脸</span>
    boxes <span class="token operator">=</span> face_recognition<span class="token punctuation">.</span>face_locations<span class="token punctuation">(</span>rgb<span class="token punctuation">,</span> model<span class="token operator">=</span>detection_method<span class="token punctuation">)</span>
    <span class="token comment"># 计算人脸的嵌入</span>
    encodings <span class="token operator">=</span> face_recognition<span class="token punctuation">.</span>face_encodings<span class="token punctuation">(</span>rgb<span class="token punctuation">,</span> boxes<span class="token punctuation">)</span>
    <span class="token comment"># 遍历 encodings</span>
    <span class="token keyword">for</span> encoding <span class="token keyword">in</span> encodings<span class="token punctuation">:</span>
        <span class="token comment"># 将每个编码 + 名称添加到我们的已知名称集中</span>
        <span class="token comment"># 编码</span>
        knownEncodings<span class="token punctuation">.</span>append<span class="token punctuation">(</span>encoding<span class="token punctuation">)</span>
        knownNames<span class="token punctuation">.</span>append<span class="token punctuation">(</span>name<span class="token punctuation">)</span>

</code></pre> 
<p><strong>代码关键点解释</strong></p> 
<ul><li>dataset_path：数据集的路径。</li><li>encodings_path ：我们的人脸编码被写入这个参数指向的文件路径。</li><li>detection_method ：在我们对图像中的人脸进行编码之前，我们首先需要检测它们。 或者两种人脸检测方法包括 hog 或 cnn 。</li></ul> 
<p>现在我们已经定义了我们的参数，让我们获取数据集中文件的路径（以及执行两个初始化）：</p> 
<p>输入数据集目录的路径来构建其中包含的所有图像路径的列表。</p> 
<p>在循环之前分别初始化两个列表 knownEncodings 和 knownNames 。 这两个列表将包含数据集中每个人的面部编码和相应的姓名。 这个循环将循环 19次，对应于我们在数据集中的 19张人脸图像。</p> 
<p>然后，将面部的边界框转换为 128 个数字的列表。这称为将面部编码为向量，而 face_recognition.face_encodings 方法会处理它。 编码和名称附加到适当的列表（knownEncodings 和 knownNames）。然后，将继续对数据集中的所有 19张图像执行此操作。</p> 
<pre><code class="prism language-python"><span class="token comment"># dump the facial encodings + names to disk</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[INFO] serializing encodings..."</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"encodings"</span><span class="token punctuation">:</span> knownEncodings<span class="token punctuation">,</span> <span class="token string">"names"</span><span class="token punctuation">:</span> knownNames<span class="token punctuation">}</span>
f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token string">"encodings"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span>
f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre> 
<p>构造了一个带有两个键的字典—— “encodings” 和 “names” 。 将名称和编码转储到磁盘以备将来调用。</p> 
<pre><code class="prism language-python"><span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> quantifying faces<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">1</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">2</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">3</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">4</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">5</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">6</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">7</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">8</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">9</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">10</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">11</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">12</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">13</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">14</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">15</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">16</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">17</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">18</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> processing image <span class="token number">19</span><span class="token operator">/</span><span class="token number">19</span>
<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> serializing encodings<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

Process finished <span class="token keyword">with</span> exit code <span class="token number">0</span>

</code></pre> 
<p>正如输出中看到的，我们现在有一个名为 encodings.pickle 的文件——该文件包含我们数据集中每个人脸的 128 维人脸嵌入。</p> 
<h2><a id="5__335"></a>5 识别效果</h2> 
<h3><a id="51__337"></a>5.1 人脸检测效果</h3> 
<p><img src="https://images2.imgbox.com/6e/0d/gqGUTBjy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="52__342"></a>5.2 人脸识别结果</h3> 
<p><strong>静态识别</strong><br> <img src="https://images2.imgbox.com/5d/99/s0dSX5yZ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>动态识别</strong></p> 
<p><img src="https://images2.imgbox.com/b9/1f/R1aUWbwq_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="6__354"></a>6 最后</h2>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4512cfdfc5ac5936015d257344be1a58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【问题及解决】win11 vmware创建虚拟机之后电脑和虚拟机都变得特别卡</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fb970548ca989d401c1c4ffafdb4d01/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu18下安装PCL库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>