<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android消息处理之messageQueue - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android消息处理之messageQueue" />
<meta property="og:description" content="http://blog.csdn.net/innost/article/details/47317823
在Andrid 2.3以前，只有Java世界的居民有资格向MessageQueue中添加消息以驱动Java世界的正常运转，但从Android 2.3开始，MessageQueue的核心部分下移至Native层，让Native世界的居民也能利用消息循环来处理他们所在世界的事情。因此现在的MessageQueue心系Native和Java两个世界。
2.3.1 MessageQueue的创建 现在来分析MessageQueue是如何跨界工作的，其代码如下：
[MessageQueue.java--&gt;MessageQueue.MessageQueue()]
MessageQueue() {
nativeInit();//构造函数调用nativeInit，该函数由Native层实现
}
nativeInit()方法的真正实现为android_os_MessageQueue_nativeInit()函数，其代码如下：
[android_os_MessageQueue.cpp--&gt;android_os_MessageQueue_nativeInit()]
static voidandroid_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {
// NativeMessageQueue是MessageQueue在Native层的代表
NativeMessageQueue* nativeMessageQueue = newNativeMessageQueue();
......
// 将这个NativeMessageQueue对象设置到Java层保存
android_os_MessageQueue_setNativeMessageQueue(env,obj,
nativeMessageQueue);
}
nativeInit函数在Native层创建了一个与MessageQueue对应的NativeMessageQueue对象，其构造函数如下：
[android_os_MessageQueue.cpp--&gt;NativeMessageQueue::NativeMessageQueue()]
NativeMessageQueue::NativeMessageQueue() {
/* 代表消息循环的Looper也在Native层中呈现身影了。根据消息驱动的知识，一个线程会有一个
Looper来循环处理消息队列中的消息。下面一行的调用就是取得保存在线程本地存储空间
（Thread Local Storage）中的Looper对象 */
mLooper= Looper::getForThread();
if (mLooper == NULL) {
/* 如为第一次进来，则该线程没有设置本地存储，所以须先创建一个Looper，然后再将其保存到
TLS中，这是很常见的一种以线程为单位的单例模式*/
mLooper = new Looper(false);
Looper::setForThread(mLooper);
}
}
Native的Looper是Native世界中参与消息循环的一位重要角色。虽然它的类名和Java层的Looper类一样，但此二者其实并无任何关系。这一点以后还将详细分析。
2.3.2 提取消息 当一切准备就绪后，Java层的消息循环处理，也就是Looper会在一个循环中提取并处理消息。消息的提取就是调用MessageQueue的next()方法。当消息队列为空时，next就会阻塞。MessageQueue同时支持Java层和Native层的事件，那么其next()方法该怎么实现呢？具体代码如下：
[MessagQueue.java--&gt;MessageQueue.next()]
final Message next() {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/a89f0017ce2dc6912a38b0a2155b9415/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-11T22:22:57+08:00" />
<meta property="article:modified_time" content="2017-08-11T22:22:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android消息处理之messageQueue</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <a target="_blank" href="http://blog.csdn.net/innost/article/details/47317823" rel="noopener noreferrer">http://blog.csdn.net/innost/article/details/47317823</a><br> </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <br> </p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 在Andrid 2.3以前，只有Java世界的居民有资格向MessageQueue中添加消息以驱动Java世界的正常运转，但从Android 2.3开始，MessageQueue的核心部分下移至Native层，让Native世界的居民也能利用消息循环来处理他们所在世界的事情。因此现在的MessageQueue心系Native和Java两个世界。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t19" style="color:rgb(255,153,0)"></a>2.3.1 MessageQueue的创建</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 现在来分析MessageQueue是如何跨界工作的，其代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [MessageQueue.java--&gt;MessageQueue.MessageQueue()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> MessageQueue() {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     nativeInit();//构造函数调用nativeInit，该函数由Native层实现</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> nativeInit()方法的真正实现为android_os_MessageQueue_nativeInit()函数，其代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_os_MessageQueue.cpp--&gt;android_os_MessageQueue_nativeInit()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> static voidandroid_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // NativeMessageQueue是MessageQueue在Native层的代表</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     NativeMessageQueue* nativeMessageQueue = newNativeMessageQueue();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 将这个NativeMessageQueue对象设置到Java层保存</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     android_os_MessageQueue_setNativeMessageQueue(env,obj,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                                                          nativeMessageQueue);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> nativeInit函数在Native层创建了一个与MessageQueue对应的NativeMessageQueue对象，其构造函数如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_os_MessageQueue.cpp--&gt;NativeMessageQueue::NativeMessageQueue()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> NativeMessageQueue::NativeMessageQueue() {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     /* 代表消息循环的Looper也在Native层中呈现身影了。根据消息驱动的知识，一个线程会有一个</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       Looper来循环处理消息队列中的消息。下面一行的调用就是取得保存在线程本地存储空间</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">      （Thread Local Storage）中的Looper对象 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     mLooper= Looper::getForThread();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if (mLooper == NULL) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         /* 如为第一次进来，则该线程没有设置本地存储，所以须先创建一个Looper，然后再将其保存到</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">           TLS中，这是很常见的一种以线程为单位的单例模式*/</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         mLooper = new Looper(false);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         Looper::setForThread(mLooper);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Native的Looper是Native世界中参与消息循环的一位重要角色。虽然它的类名和Java层的Looper类一样，但此二者其实并无任何关系。这一点以后还将详细分析。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t20" style="color:rgb(255,153,0)"></a>2.3.2 提取消息</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 当一切准备就绪后，Java层的消息循环处理，也就是Looper会在一个循环中提取并处理消息。消息的提取就是调用MessageQueue的next()方法。当消息队列为空时，next就会阻塞。MessageQueue同时支持Java层和Native层的事件，那么其next()方法该怎么实现呢？具体代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [MessagQueue.java--&gt;MessageQueue.next()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> final Message next() {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     int pendingIdleHandlerCount = -1;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     int nextPollTimeoutMillis = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     for (;;) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // mPtr保存了NativeMessageQueue的指针，调用nativePollOnce进行等待</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         nativePollOnce(mPtr,nextPollTimeoutMillis);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         synchronized (this) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             final long now = SystemClock.uptimeMillis();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             // mMessages用来存储消息，这里从其中取一个消息进行处理</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             final Message msg = mMessages;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             if (msg != null) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 final long when = msg.when;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 if (now &gt;= when) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                     mBlocked = false;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                     mMessages = msg.next;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                     msg.next = null;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                     msg.markInUse();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                     return msg; // 返回一个Message给Looper进行派发和处理</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                } else {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                     nextPollTimeoutMillis = (int) Math.min(when- now,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                                                   Integer.MAX_VALUE);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             } else {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 nextPollTimeoutMillis = -1;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             /* 处理注册的IdleHandler，当MessageQueue中没有Message时，</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            Looper会调用IdleHandler做一些工作，例如做垃圾回收等  */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            pendingIdleHandlerCount = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             nextPollTimeoutMillis = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 看到这里，可能会有人觉得这个MessageQueue很简单，不就是从以前在Java层的wait变成现在Native层的wait了吗？但是事情本质比表象要复杂得多，来思考下面的情况：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> nativePollOnce()返回后，next()方法将从mMessages中提取一个消息。也就是说，要让nativePollOnce()返回，至少要添加一个消息到消息队列，否则nativePollOnce()不过是做了一次无用功罢了。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 如果nativePollOnce()将在Native层等待，就表明Native层也可以投递Message，但是从Message类的实现代码上看，该类和Native层没有建立任何关系。那么nativePollOnce()在等待什么呢？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 对于上面的问题，相信有些读者心中已有了答案：nativePollOnce()不仅在等待Java层来的Message，实际上还在Native还做了大量的工作。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 下面我们来分析Java层投递Message并触发nativePollOnce工作的正常流程。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t21" style="color:rgb(255,153,0)"></a>1. 在Java层投递Message</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> MessageQueue的enqueueMessage函数完成将一个Message投递到MessageQueue中的工作，其代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [MesssageQueue.java--&gt;MessageQueue.enqueueMessage()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> final boolean enqueueMessage(Message msg, longwhen) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     finalboolean needWake;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    synchronized (this) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(mQuiting) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            return false;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }else if (msg.target == null) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            mQuiting = true;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        msg.when = when;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        Message p = mMessages;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(p == null || when == 0 || when &lt; p.when) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            /* 如果p为空，表明消息队列中没有消息，那么msg将是第一个消息，needWake</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">              需要根据mBlocked的情况考虑是否触发 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             msg.next= p;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            mMessages = msg;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            needWake = mBlocked;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         } else {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            // 如果p不为空，表明消息队列中还有剩余消息，需要将新的msg加到消息尾</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            Message prev = null;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            while (p != null &amp;&amp; p.when &lt;= when) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                prev = p;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                p = p.next;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            msg.next = prev.next;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            prev.next = msg;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            // 因为消息队列之前还剩余有消息，所以这里不用调用nativeWakeup</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            needWake = false;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(needWake) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // 调用nativeWake，以触发nativePollOnce函数结束等待</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        nativeWake(mPtr);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     returntrue;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 上面的代码比较简单，主要功能是：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  将message按执行时间排序，并加入消息队。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  根据情况调用nativeWake函数，以触发nativePollOnce函数，结束等待。</p> 
<div style="font-family:Arial; font-size:14px"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> 建议 虽然代码简单，但是对于那些不熟悉多线程的读者，还是要细细品味一下mBlocked值的作用。我们常说细节体现美，代码也一样，这个小小的mBlocked正是如此。</p> 
</div> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t22" style="color:rgb(255,153,0)"></a>2. nativeWake函数分析</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> nativeWake函数的代码如下所示：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_os_MessageQueue.cpp--&gt;android_os_MessageQueue_nativeWake()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> static voidandroid_os_MessageQueue_nativeWake(JNIEnv* env, jobject obj,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                                                       jint ptr)</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    NativeMessageQueue* nativeMessageQueue = // 取出NativeMessageQueue对象</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                       reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     returnnativeMessageQueue-&gt;wake(); // 调用它的wake函数</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_os_MessageQueue.cpp--&gt;NativeMessageQueue::wake()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void NativeMessageQueue::wake() {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mLooper-&gt;wake(); // 层层调用，现在转到mLooper的wake函数</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Native Looper的wake函数代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::wake()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void Looper::wake() {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     ssize_tnWrite;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     do {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // 向管道的写端写入一个字符</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        nWrite = write(mWakeWritePipeFd, "W", 1);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     } while(nWrite == -1 &amp;&amp; errno == EINTR);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Wake()函数则更为简单，仅仅向管道的写端写入一个字符”W”，这样管道的读端就会因为有数据可读而从等待状态中醒来。</p> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t23" style="color:rgb(255,153,0)"></a>2.3.3 nativePollOnce函数分析</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> nativePollOnce()的实现函数是android_os_MessageQueue_nativePollOnce，代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_os_MessageQueue.cpp--&gt;android_os_MessageQueue_nativePollOnce()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> static voidandroid_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         jintptr, jint timeoutMillis)</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     NativeMessageQueue* nativeMessageQueue =</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                            reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 取出NativeMessageQueue对象，并调用它的pollOnce</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    nativeMessageQueue-&gt;pollOnce(timeoutMillis);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 分析pollOnce函数：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_os_MessageQueue.cpp--&gt;NativeMessageQueue::pollOnece()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void NativeMessageQueue::pollOnce(inttimeoutMillis) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mLooper-&gt;pollOnce(timeoutMillis); // 重任传递到Looper的pollOnce函数</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Looper的pollOnce函数如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::pollOnce()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> inline int pollOnce(int timeoutMillis) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     returnpollOnce(timeoutMillis, NULL, NULL, NULL);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 上面的函数将调用另外一个有4个参数的pollOnce函数，这个函数的原型如下：</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> int pollOnce(int timeoutMillis, int* outFd, int*outEvents, void** outData)</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 其中：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  timeOutMillis参数为超时等待时间。如果为-1，则表示无限等待，直到有事件发生为止。如果值为0，则无需等待立即返回。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  outFd用来存储发生事件的那个文件描述符 。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  outEvents用来存储在该文件描述符1上发生了哪些事件，目前支持可读、可写、错误和中断4个事件。这4个事件其实是从epoll事件转化而来。后面我们会介绍大名鼎鼎的epoll。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  outData用于存储上下文数据，这个上下文数据是由用户在添加监听句柄时传递的，它的作用和pthread_create函数最后一个参数param一样，用来传递用户自定义的数据。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 另外，pollOnce函数的返回值也具有特殊的意义，具体如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  当返回值为ALOOPER_POLL_WAKE时，表示这次返回是由wake函数触发的，也就是管道写端的那次写事件触发的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  返回值为ALOOPER_POLL_TIMEOUT表示等待超时。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  返回值为ALOOPER_POLL_ERROR，表示等待过程中发生错误。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  返回值为ALOOPER_POLL_CALLBACK，表示某个被监听的句柄因某种原因被触发。这时，outFd参数用于存储发生事件的文件句柄，outEvents用于存储所发生的事件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 上面这些知识是和epoll息息相关的。</p> 
<div style="font-family:Arial; font-size:14px"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> 提示 查看Looper的代码会发现，Looper采用了编译选项(即#if和#else)来控制是否使用epoll作为I/O复用的控制中枢。鉴于现在大多数系统都支持epoll，这里仅讨论使用epoll的情况。</p> 
</div> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t24" style="color:rgb(255,153,0)"></a>1. epoll基础知识介绍</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> epoll机制提供了Linux平台上最高效的I/O复用机制，因此有必要介绍一下它的基础知识。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 从调用方法上看，epoll的用法和select/poll非常类似，其主要作用就是I/O复用，即在一个地方等待多个文件句柄的I/O事件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 下面通过一个简单例子来分析epoll的工作流程。</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> /* <strong>① 使用epoll前，需要先通过epoll_create函数创建一个epoll句柄。</strong></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   下面一行代码中的10表示该epoll句柄初次创建时候分配能容纳10个fd相关信息的缓存。</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   对于2.6.8版本以后的内核，该值没有实际作用，这里可以忽略。其实这个值的主要目的是</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   确定分配一块多大的缓存。现在的内核都支持动态拓展这块缓存，所以该值就没有意义了 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> int epollHandle = epoll_create(10);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> /* <strong>② 得到epoll句柄后，下一步就是通过epoll_ctl把需要监听的文件句柄加入到epoll句柄中。</strong></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   除了指定文件句柄本身的fd值外，同时还需要指定在该fd上等待什么事件。epoll支持四类事件，</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   分别是EPOLLIN(句柄可读)、EPOLLOUT(句柄可写),EPOLLERR(句柄错误)、EPOLLHUP(句柄断)。</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   epoll定义了一个结构体struct epoll_event来表达监听句柄的诉求。</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   假设现在有一个监听端的socket句柄listener，要把它加入到epoll句柄中 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> struct epoll_event listenEvent; //先定义一个event</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> /* EPOLLIN表示可读事件,EPOLLOUT表示可写事件，另外还有EPOLLERR,EPOLLHUP表示</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   系统默认会将EPOLLERR加入到事件集合中 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> listenEvent.events = EPOLLIN;// 指定该句柄的可读事件</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> // epoll_event中有一个联合体叫data，用来存储上下文数据，本例的上下文数据就是句柄自己</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> listenEvent.data.fd = listenEvent;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   /* <strong>③</strong> EPOLL_CTL_ADD将监听fd和监听事件加入到epoll句柄的等待队列中；</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     EPOLL_CTL_DEL将监听fd从epoll句柄中移除；</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     EPOLL_CTL_MOD修改监听fd的监听事件，例如本来只等待可读事件，现在需要同时等待</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     可写事件，那么修改listenEvent.events 为EPOLLIN|EPOLLOUT后，再传给epoll句柄*/</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> epoll_ctl(epollHandle,EPOLL_CTL_ADD,listener,&amp;listenEvent);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> /* 当把所有感兴趣的fd都加入到epoll句柄后，就可以开始坐等感兴趣的事情发生了。</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   为了接收所发生的事情，先定义一个epoll_event数组 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> struct epoll_event resultEvents[10];</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> int timeout = -1;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> while(1) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     /* <strong>④ 调用epoll_wait用于等待事件。</strong>其中timeout可以指定一个超时时间，</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">      resultEvents用于接收发生的事件，10为该数组的大小。</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">      epoll_wait函数的返回值有如下含义：</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       nfds大于0表示所监听的句柄上有事件发生；</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       nfds等于0表示等待超时；</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       nfds小于0表示等待过程中发生了错误*/</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     int nfds = epoll_wait(epollHandle,resultEvents, 10, timeout);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(nfds == -1) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // epoll_wait发生了错误</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     } else if(nfds == 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         //发生超时，期间没有发生任何事件</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     } else{<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // ⑤resultEvents用于返回那些发生了事件的信息</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         for(int i = 0; i &lt; nfds; i++) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             struct epoll_event &amp; event =resultEvents[i];</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             if(event &amp; EPOLLIN) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 /* <strong>⑥ 收到可读事件。</strong>到底是哪个文件句柄发生该事件呢？可通过event.data这个联合</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                  体取得 前传递给epoll的上下文数据，该上下文信息可用于判断到底是谁发生了事件 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">               ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             .......//其他处理 </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> epoll整体使用流程如上面代码所示，基本和select/poll类似，不过作为Linux平台最高效的I/O复用机制，这里有些内容供读者参考，</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> epoll的效率为什么会比select高？其中一个原因是调用方法。每次调用select时，都需要把感兴趣的事件复制到内核中，而epoll只在epll_ctl进行加入的时候复制一次。另外，epoll内部用于保存事件的数据结构使用的是红黑树，查找速度很快。而select采用数组保存信息，不但一次能等待的句柄个数有限，并且查找起来速度很慢。当然，在只等待少量文件句柄时，select和epoll效率相差不是很多，但还是推荐使用epoll。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> epoll等待的事件有两种触发条件，一个是水平触发（EPOLLLEVEL），另外一个是边缘触发（EPOLLET,ET为Edge Trigger之意），这两种触发条件的区别非常重要。读者可通过man epoll查阅系统提供的更为详细的epoll机制。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 最后，关于pipe，还想提出一个小问题供读者思考讨论：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 为什么Android中使用pipe作为线程间通讯的方式？对于pipe的写端写入的数据，读端都不感兴趣，只是为了简单的唤醒。POSIX不是也有线程间同步函数吗？为什么要用pipe呢？</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 关于这个问题的答案，可参见邓凡平的一篇博文“随笔之如何实现一个线程池”。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  http://www.cnblogs.com/innost/archive/2011/11/24/2261454.html</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t25" style="color:rgb(255,153,0)"></a>2. pollOnce()函数分析</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 下面分析带4个参数的pollOnce()函数，代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::pollOnce()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> int Looper::pollOnce(int timeoutMillis, int*outFd, int* outEvents,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void** outData) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     intresult = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     for(;;) { // 一个无限循环</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // mResponses是一个Vector，这里首先需要处理response</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        while (mResponseIndex &lt; mResponses.size()) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            ALooper_callbackFunc callback = response.request.callback;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             if (!callback) {// 首先处理那些没有callback的Response</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                int ident = response.request.ident; // ident是这个Response的id</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                int fd = response.request.fd;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                int events = response.events;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                void* data = response.request.data;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (outFd != NULL) *outFd = fd;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (outEvents != NULL) *outEvents = events;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (outData != NULL) *outData = data;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                /* 实际上，对于没有callback的Response，pollOnce只是返回它的</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                  ident，并没有实际做什么处理。因为没有callback，所以系统也不知道如何处理 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                return ident;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(result != 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             if(outFd != NULL) *outFd = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            if (outEvents != NULL) *outEvents = NULL;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             if (outData != NULL) *outData = NULL;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            return result;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // 调用pollInner函数。注意，它在for循环内部</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        result = pollInner(timeoutMillis);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 初看上面的代码，可能会让人有些丈二和尚摸不着头脑。但是把pollInner()函数分析完毕，大家就会明白很多。pollInner()函数非常长，把用于调试和统计的代码去掉，结果如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::pollInner()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> int Looper::pollInner(int timeoutMillis) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        ......//根据Native Message的信息计算此次需要等待的时间</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        timeoutMillis = messageTimeoutMillis;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     intresult = ALOOPER_POLL_WAKE;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mResponses.clear();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mResponseIndex = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #ifdef LOOPER_USES_EPOLL  // 只讨论使用epoll进行I/O复用的方式</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     structepoll_event eventItems[EPOLL_MAX_EVENTS];</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 调用epoll_wait，等待感兴趣的事件或超时发生</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     inteventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                                      timeoutMillis);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #else</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     ......//使用别的方式进行I/O复用</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #endif</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     //从epoll_wait返回，这时候一定发生了什么事情</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mLock.lock();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(eventCount &lt; 0) { //返回值小于零，表示发生错误</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(errno == EINTR) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            goto Done;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         //设置result为ALLOPER_POLL_ERROR,并跳转到Done</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        result = ALOOPER_POLL_ERROR;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         gotoDone;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    //eventCount为零，表示发生超时，因此直接跳转到Done</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(eventCount == 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       result = ALOOPER_POLL_TIMEOUT;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         gotoDone;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #ifdef LOOPER_USES_EPOLL</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 根据epoll的用法，此时的eventCount表示发生事件的个数</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     for (inti = 0; i &lt; eventCount; i++) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         intfd = eventItems[i].data.fd;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        uint32_t epollEvents = eventItems[i].events;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         /* 之前通过pipe函数创建过两个fd，这里根据fd知道是管道读端有可读事件。</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">          读者还记得对nativeWake函数的分析吗？在那里我们向管道写端写了一个”W”字符，这样</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">          就能触发管道读端从epoll_wait函数返回了 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(fd == mWakeReadPipeFd) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            if (epollEvents &amp; EPOLLIN) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 // awoken函数直接读取并清空管道数据，读者可自行研究该函数</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                awoken();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }else {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">           /* mRequests和前面的mResponse相对应，它也是一个KeyedVector，其中存储了</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            fd和对应的Request结构体，该结构体封装了和监控文件句柄相关的一些上下文信息，</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             例如回调函数等。我们在后面的小节会再次介绍该结构体 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            ssize_t requestIndex = mRequests.indexOfKey(fd);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            if (requestIndex &gt;= 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                int events = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                // 将epoll返回的事件转换成上层LOOPER使用的事件</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                // 每处理一个Request，就相应构造一个Response</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                pushResponse(events, mRequests.valueAt(requestIndex));</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            } </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> Done: ;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #else</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">      ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #endif</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 除了处理Request外，还处理Native的Message</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mNextMessageUptime = LLONG_MAX;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     while(mMessageEnvelopes.size() != 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        const MessageEnvelope&amp; messageEnvelope =mMessageEnvelopes.itemAt(0);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(messageEnvelope.uptime &lt;= now) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                Message message = messageEnvelope.message;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                mMessageEnvelopes.removeAt(0);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                mSendingMessage = true;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                mLock.unlock();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                /* 调用Native的handler处理Native的Message</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 从这里也可看出Native Message和Java层的Message没有什么关系 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                handler-&gt;handleMessage(message);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            mLock.lock();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            mSendingMessage = false;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            result = ALOOPER_POLL_CALLBACK;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }else {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">             mNextMessageUptime = messageEnvelope.uptime;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            break;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    mLock.unlock();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 处理那些带回调函数的Response</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     for (size_t i = 0; i &lt; mResponses.size();i++) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        const Response&amp; response = mResponses.itemAt(i);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        ALooper_callbackFunc callback = response.request.callback;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(callback) {// 有了回调函数，就能知道如何处理所发生的事情了</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            int fd = response.request.fd;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            int events = response.events;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            void* data = response.request.data;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            // 调用回调函数处理所发生的事件</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            int callbackResult = callback(fd, events, data);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            if (callbackResult == 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                // callback函数的返回值很重要，如果为0，表明不需要再次监视该文件句柄</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                 removeFd(fd);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            result = ALOOPER_POLL_CALLBACK;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     returnresult;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 看完代码了，是否还有点模糊？那么，回顾一下pollInner函数的几个关键点：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  首先需要计算一下真正需要等待的时间。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  调用epoll_wait函数等待。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  epoll_wait函数返回，这时候可能有三种情况：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> a)      发生错误，则跳转到Done处。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> b)     超时，这时候也跳转到Done处。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> c)      epoll_wait监测到某些文件句柄上有事件发生。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  假设epoll_wait因为文件句柄有事件而返回，此时需要根据文件句柄来分别处理：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> a)      如果是管道读这一端有事情，则认为是控制命令，可以直接读取管道中的数据。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> b)     如果是其他FD发生事件，则根据Request构造Response，并push到Response数组中。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  真正开始处理事件是在有Done标志的位置。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> a)      首先处理Native的Message。调用Native Handler的handleMessage处理该Message。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> b)     处理Response数组中那些带有callback的事件。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 上面的处理流程还是比较清晰的，但还是有个一个拦路虎，那就是mRequests，下面就来清剿这个拦路虎。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t26" style="color:rgb(255,153,0)"></a>3. 添加监控请求</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 添加监控请求其实就是调用epoll_ctl增加文件句柄。下面通过从Native的Activity找到的一个例子来分析mRequests。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [android_app_NativeActivity.cpp--&gt;loadNativeCode_native()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> static jint</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> loadNativeCode_native(JNIEnv* env, jobject clazz,jstring path,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                           jstringfuncName,jobject messageQueue,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                           jstringinternalDataDir, jstring obbDir,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                           jstringexternalDataDir, int sdkVersion,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                           jobject jAssetMgr,jbyteArray savedState)</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     /* 调用Looper的addFd函数。第一个参数表示监听的fd；第二个参数0表示ident；</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       第三个参数表示需要监听的事件，这里为只监听可读事件；第四个参数为回调函数，当该fd发生</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       指定事件时，looper将回调该函数；第五个参数code为回调函数的参数 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     code-&gt;looper-&gt;addFd(code-&gt;mainWorkRead,0,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                           ALOOPER_EVENT_INPUT,mainWorkCallback, code);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">   ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Looper的addFd()代码如下所示：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::addFd()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> int Looper::addFd(int fd, int ident, int events,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                       ALooper_callbackFunccallback, void* data) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if (!callback) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">          /* 判断该Looper是否支持不带回调函数的文件句柄添加。一般不支持，因为没有回调函数</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            Looper也不知道如何处理该文件句柄上发生的事情 */</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">          if(! mAllowNonCallbacks) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            return -1;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">       ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #ifdef LOOPER_USES_EPOLL</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     intepollEvents = 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 将用户的事件转换成epoll使用的值</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(events &amp; ALOOPER_EVENT_INPUT) epollEvents |= EPOLLIN;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if(events &amp; ALOOPER_EVENT_OUTPUT) epollEvents |= EPOLLOUT;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        AutoMutex _l(mLock);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        Request request; // 创建一个Request对象</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        request.fd = fd; // 保存fd</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        request.ident = ident; // 保存id</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        request.callback = callback; //保存callback</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        request.data = data;  // 保存用户自定义数据</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        struct epoll_event eventItem;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        memset(&amp; eventItem, 0, sizeof(epoll_event));</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        eventItem.events = epollEvents;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        eventItem.data.fd = fd;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // 判断该Request是否已经存在，mRequests以fd作为key值</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        ssize_t requestIndex = mRequests.indexOfKey(fd);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(requestIndex &lt; 0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            // 如果是新的文件句柄，则需要为epoll增加该fd</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            // 保存Request到mRequests键值数组</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            mRequests.add(fd, request);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }else {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            // 如果之前加过，那么就修改该监听句柄的一些信息</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp;eventItem);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">           ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            mRequests.replaceValueAt(requestIndex, request);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #else</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     ......</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> #endif</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     return1;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t27" style="color:rgb(255,153,0)"></a>4. 处理监控请求</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 我们发现在pollInner()函数中，当某个监控fd上发生事件后，就会把对应的Request取出来调用。</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> pushResponse(events, mRequests.itemAt(i));</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 此函数如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::pushResponse()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void Looper::pushResponse(int events, constRequest&amp; request) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     Responseresponse;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    response.events = events;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    response.request = request; //其实很简单，就是保存所发生的事情和对应的Request</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     mResponses.push(response);//然后保存到mResponse数组</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 根据前面的知识可知，并不是单独处理Request，而是需要先收集Request，等到Native Message消息处理完之后再做处理。这表明，在处理逻辑上，Native Message的优先级高于监控FD的优先级。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 下面来了解如何添加Native的Message。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t28" style="color:rgb(255,153,0)"></a>5. Native的sendMessage</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> Android 2.2中只有Java层才可以通过sendMessage()往MessageQueue中添加消息，从4.0开始，Native层也支持sendMessage()了。sendMessage()的代码如下：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.cpp--&gt;Looper::sendMessage()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void Looper::sendMessage(constsp&lt;MessageHandler&gt;&amp; handler,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                               constMessage&amp; message) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     //Native的sendMessage函数必须同时传递一个Handler</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     nsecs_tnow = systemTime(SYSTEM_TIME_MONOTONIC);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    sendMessageAtTime(now, handler, message); //调用sendMessageAtTime</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> [Looper.java--&gt;Looper::sendMessageAtTime()]</p> 
<div style="font-family:Arial; font-size:14px; background:rgb(240,247,254)"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> void Looper::sendMessageAtTime(nsecs_t uptime,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                                      constsp&lt;MessageHandler&gt;&amp; handler,</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                                      constMessage&amp; message) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">    size_t i= 0;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        AutoMutex _l(mLock);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">  </p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        size_t messageCount = mMessageEnvelopes.size();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // 按时间排序，将消息插入到正确的位置上</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        while (i &lt; messageCount &amp;&amp;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">                uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            i += 1;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        MessageEnvelope messageEnvelope(uptime, handler, message);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        mMessageEnvelopes.insertAt(messageEnvelope, i, 1);</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         // mSendingMessage和Java层中的那个mBlocked一样，是一个小小的优化措施</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         if(mSendingMessage) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">            return;</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">         }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     // 唤醒epoll_wait，让它处理消息</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     if (i ==0) {<!-- --></p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">        wake();</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px">     }</p> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> }</p> 
</div> 
<h4 style="margin:0px; padding:0px; font-family:Arial"><a target="_blank" name="t29" style="color:rgb(255,153,0)"></a>2.3.4 MessageQueue总结</h4> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 想不到，一个小小的MessageQueue竟然有如此多的内容。在后面分析Android输入系统时，会再次在Native层和MessageQueue碰面，这里仅是为后面的相会打下一定的基础。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 现在将站在一个比具体代码更高的层次来认识一下MessageQueue和它的伙伴们。</p> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t30" style="color:rgb(255,153,0)"></a>1. 消息处理的大家族合照</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> MessageQueue只是消息处理大家族的一员，该家族的成员合照如图2-5所示。</p> 
<p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> </p> 
<p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> <img src="https://images2.imgbox.com/e8/1f/uZfWirdG_o.png" alt="" style="border:none; max-width:100%"><br> </p> 
<p align="center" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 图 2 - 5 消息处理的家族合照</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> 结合前述内容可从图2-5中得到：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  Java层提供了Looper类和MessageQueue类，其中Looper类提供循环处理消息的机制，MessageQueue类提供一个消息队列，以及插入、删除和提取消息的函数接口。另外，Handler也是在Java层常用的与消息处理相关的类。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  MessageQueue内部通过mPtr变量保存一个Native层的NativeMessageQueue对象，mMessages保存来自Java层的Message消息。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  NativeMessageQueue保存一个native的Looper对象，该Looper从ALooper派生，提供pollOnce和addFd等函数。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  Java层有Message类和Handler类，而Native层对应也有Message类和MessageHandler抽象类。在编码时，一般使用的是MessageHandler的派生类WeakMessageHandler类。</p> 
<div style="font-family:Arial; font-size:14px"> 
 <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> 注意 在include/media/stagfright/foundation目录下也定义了一个ALooper类，它是供stagefright使用的类似Java消息循环的一套基础类。这种同名类的产生，估计是两个事先未做交流的Group的人写的。</p> 
</div> 
<h5 style="margin:0px; padding:0px; font-family:Arial; font-size:14px"><a target="_blank" name="t31" style="color:rgb(255,153,0)"></a>2. MessageQueue处理流程总结</h5> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  MessageQueue核心逻辑下移到Native层后，极大地拓展了消息处理的范围，总结一下有以下几点：</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  MessageQueue继续支持来自Java层的Message消息，也就是早期的Message加Handler的处理方式。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  MessageQueue在Native层的代表NativeMessageQueue支持来自Native层的Message，是通过Native的Message和MessageHandler来处理的。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  NativeMessageQueue还处理通过addFd添加的Request。在后面分析输入系统时，还会大量碰到这种方式。</p> 
<p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px"> ·  从处理逻辑上看，先是Native的Message，然后是Native的Request，最后才是Java的Message。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4784f6a10911bac605049381b3e17534/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android加密之文件级加密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f3018664bf396c40ff745b75ba8e5bcd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AccessibilityService有哪些缺陷？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>