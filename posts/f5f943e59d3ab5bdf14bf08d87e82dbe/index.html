<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java多线程学习之七—如何优雅的停止线程（池） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java多线程学习之七—如何优雅的停止线程（池）" />
<meta property="og:description" content="文中内容整理自《Java并发编程实战》
方法一：使用中断标志 使用 cancelled 标志，当标志状态为true的时候，停止线程。
示例：
public class Test0701CancelThread implements Runnable { public static void main(String[] args) { Test0701CancelThread cancelThread = new Test0701CancelThread(); try { cancelThread.aSecondOfPrimes(); } catch (InterruptedException e) { e.printStackTrace(); } } private final List&lt;BigInteger&gt; primes = new ArrayList&lt;&gt;(); private volatile boolean cancelled; @Override public void run() { System.out.println(&#34;执行线程&#34;); BigInteger p = BigInteger.ONE; while (!cancelled) { p = p.nextProbablePrime(); synchronized (this) { primes.add(p); } } } public void cancel() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f5f943e59d3ab5bdf14bf08d87e82dbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-27T10:36:57+08:00" />
<meta property="article:modified_time" content="2021-02-27T10:36:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java多线程学习之七—如何优雅的停止线程（池）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>文中内容整理自《Java并发编程实战》</p> 
<h3><a id="_3"></a>方法一：使用中断标志</h3> 
<p>使用 cancelled 标志，当标志状态为true的时候，停止线程。</p> 
<p>示例：</p> 
<pre><code>public class Test0701CancelThread implements Runnable {

    public static void main(String[] args) {
        Test0701CancelThread cancelThread = new Test0701CancelThread();
        try {
            cancelThread.aSecondOfPrimes();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private final List&lt;BigInteger&gt; primes = new ArrayList&lt;&gt;();

    private volatile boolean cancelled;

    @Override
    public void run() {
        System.out.println("执行线程");
        BigInteger p = BigInteger.ONE;
        while (!cancelled) {
            p = p.nextProbablePrime();
            synchronized (this) {
                primes.add(p);
            }
        }
    }

    public void cancel() {
        System.out.println("取消线程");
        cancelled = true;
    }

    public synchronized List&lt;BigInteger&gt; get() {
        return new ArrayList&lt;&gt;(primes);
    }

    /**
     * 测试方法
     * 素数生成器执行1s之后停止
     *
     * @return
     * @throws InterruptedException
     */
    public List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException {
        Test0701CancelThread cancelThread = new Test0701CancelThread();
        new Thread(cancelThread).start();
        try {
            SECONDS.sleep(1);
        } finally {
            cancelThread.cancel();
        }
        return cancelThread.get();
    }
}

</code></pre> 
<p>问题：</p> 
<p>1、如果调用阻塞方法，可能会导致永远也不会检查取消标志，导致线程不能被终止。</p> 
<h3><a id="_Thread__interrupt__72"></a>方法二：通过 Thread 类的 interrupt() 方法。</h3> 
<p>通过 Thread 类的中断方法 interrupt() 方法，中断线程。这是停止线程的最佳实践，它不会马上停止线程，而会先保留必要的内容，然后安全地停止线程。</p> 
<p>示例：</p> 
<pre><code>public class Test0705CancelThread extends Thread {

    private final BlockingQueue&lt;BigInteger&gt; queue;

    public Test0705CancelThread(BlockingQueue&lt;BigInteger&gt; queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!Thread.currentThread().isInterrupted()) {
                queue.put(p = p.nextProbablePrime());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void cancel() {
        interrupt();
    }
}

</code></pre> 
<p>注意：</p> 
<ol><li>调用 interrupt 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</li><li>如果调用 interrupted() 方法返回的值true，可以通过再次调用 interrupted() 恢复中断。</li><li>通常，中断是实现取消的最合理方式。</li></ol> 
<h3><a id="_Future__112"></a>方法三：通过 Future 来取消线程</h3> 
<p>Future 类，提供的 cancel() 方法，可以停止 Future 任务。</p> 
<p>示例：</p> 
<pre><code>public class Test0710FutureCancelThread {

    private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(5);

    public static void timeRun(final Runnable r, long timeout, TimeUnit unit) {
        Future&lt;?&gt; task = cancelExec.submit(r);
        try {
            task.get();
        } catch (InterruptedException e) {
            // 取消线程
            task.cancel(true);
        } catch (ExecutionException e) {
            // 如果任务已经执行完毕，那么执行取消不会有什么影响
            // 如果任务正在执行，那么将被中断
            task.cancel(true);
        }
    }
}
</code></pre> 
<p>也是取消线程的正确姿势：通过Future来取消线程。当Future.get抛出 InterruptedException或者TimeoutException时，如果你知道不再需要结果，那么就可以调用Future.cancel来取消任务</p> 
<h3><a id="_shutdown__ExecutorService_141"></a>方法四：调用 shutdown() 方法，关闭 ExecutorService</h3> 
<p>线程池的停止，可以调用 ExecutorService 类提供的 shutdown() 方法进行停止。</p> 
<p>示例：</p> 
<pre><code>public class Test0716CloseExecutorService {

    private static final long TIMEOUT = 1000L;
    private static final TimeUnit UNIT = TimeUnit.MILLISECONDS;
    private final ExecutorService exec = Executors.newScheduledThreadPool(5);

    private final PrintWriter writer;

    public Test0716CloseExecutorService(PrintWriter writer) {
        this.writer = writer;
    }

    public void start() {
    }

    public void stop() throws InterruptedException {
        try {
            exec.shutdown();
            // TODO 问：为什么停止线程，需要调用以下语句
            // 这个方法就是调用shutdown() 之后等待任务执行完毕的方法，可以查看源码的注释
            // Blocks until all tasks have completed execution after a shutdown
            // request, or the timeout occurs, or the current thread is
            // interrupted, whichever happens first.
            exec.awaitTermination(TIMEOUT, UNIT);
        } finally {
            writer.close();
        }
    }

    public void log(String msg) {
        try {
            exec.execute(new WriteTask(msg));
        } catch (RejectedExecutionException ignored) {

        }
    }
}
</code></pre> 
<p>核心语句如下：</p> 
<pre><code>// 不接收新任务
exec.shutdown();
// 停止之前提交的任务
exec.awaitTermination(TIMEOUT, UNIT);
</code></pre> 
<h3><a id="_196"></a>方法五：通过毒丸对象，取消生产者-消费者线程</h3> 
<p>在生产者-消费者模式中，通过在队列中增加毒丸对象类停止线程。</p> 
<p>示例：</p> 
<pre><code>public class Test0717PoisonPillCancelThread {

    private static final File POSION = new File("");

    private final IndexerThread consumer = new IndexerThread();

    private final CrawlerThread producer = new CrawlerThread();

    private final BlockingQueue&lt;File&gt; queue;

    private final FileFilter fileFilter;

    private final File root;

    public Test0717PoisonPillCancelThread(BlockingQueue&lt;File&gt; queue, FileFilter fileFilter, File root) {
        this.queue = queue;
        this.fileFilter = fileFilter;
        this.root = root;
    }

    public void start() {
        producer.start();
        consumer.start();
    }

    public void stop() {
        producer.interrupt();
    }

    public void awaitTermination() throws InterruptedException {
        consumer.join();
    }

    /**
     * 消费者
     */
    public class IndexerThread extends Thread {

        @Override
        public void run() {
            try {
                while (true) {
                    File file = queue.take();
                    // 毒丸对象 停止消费者
                    if (file == POSION) {
                        break;
                    } else {
                        indexFile(file);
                    }
                }
            } catch (InterruptedException e) {
                // deal with exception
            } finally {

            }
        }

        private void indexFile(File file) {
        }

        private void crawl(File root) throws InterruptedException {

        }
    }

    /**
     * 生产者
     */
    public class CrawlerThread extends Thread {

        @Override
        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) {
                // deal with exception
            } finally {
                while (true) {
                    try {
                        // 队列中存入毒丸
                        queue.put(POSION);
                        break;
                    } catch (InterruptedException e1) {
                        // deal with exception
                    }
                }
            }
        }

        private void crawl(File root) throws InterruptedException {

        }
    }
}
</code></pre> 
<p>毒丸对象是指放在队列上的对象，其含义是：当得到这个对象时，立即停止。</p> 
<p>只有在生产者和消费者的数量都已知的情况下，才可以使用毒丸对象。有多少个生产者，就需要多少个毒丸对象，这样才能停止所有的生产者服务。</p> 
<p>代码地址：https://github.com/prepared48/Java-learning.git</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c89f888b6cdd62830e1e6c57a97303bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java最新版安装教程_手把手教你安装Eclipse最新版本的详细教程 （非常详细，非常实用）...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e84a442e72ebfae292ae1764a04952d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">海康工业相机功能模块-IO输入输出控制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>