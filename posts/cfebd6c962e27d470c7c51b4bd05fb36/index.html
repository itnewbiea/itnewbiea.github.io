<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>javaweb - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="javaweb" />
<meta property="og:description" content="文件 MIME 类
前端部分技术就不做讲解了
一.基础知识 (一)概述 JavaWeb 是指，所有通过 Java 语言编写可以通过浏览器访问的程序的总称，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。
请求：请求是指客户端给服务器发送数据，叫请求 Request。
相应：响应是指服务器给客户端回传数据，叫响应 Response。
请求响应关系
(二)Web资源分类 web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。
静态资源： html.css.js.txt.mp4 视频 , jpg 图片
动态资源： jsp 页面.Servlet 程
(三)Tomcat 的使用 1.安装 找到你需要用的 Tomcat 版本对应的 zip 压缩包，解压到需要安装的目录即可。
2.目录介绍 bin 专门用来存放 Tomcat 服务器的可执行程序
conf 专门用来存放 Tocmat 服务器的配置文件
lib 专门用来存放 Tomcat 服务器的 jar 包
logs 专门用来存放 Tomcat 服务器运行时输出的日记信息
temp 专门用来存放 Tomcdat 运行时产生的临时数据
webapps 专门用来存放部署的 Web 工程。
work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cfebd6c962e27d470c7c51b4bd05fb36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-06T09:47:52+08:00" />
<meta property="article:modified_time" content="2022-11-06T09:47:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">javaweb</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>文件 MIME 类</p> 
<p>前端部分技术就不做讲解了</p> 
<h2><a id="_6"></a>一.基础知识</h2> 
<h3><a id="_8"></a>(一)概述</h3> 
<p>JavaWeb 是指，所有通过 Java 语言编写可以通过浏览器访问的程序的总称，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。</p> 
<p>请求：请求是指客户端给服务器发送数据，叫请求 Request。</p> 
<p>相应：响应是指服务器给客户端回传数据，叫响应 Response。</p> 
<p><strong>请求响应关系</strong></p> 
<p><img src="https://images2.imgbox.com/43/a0/W2xdDLEW_o.png" alt="image-20220328162544838"></p> 
<h3><a id="Web_20"></a>(二)Web资源分类</h3> 
<p>web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。</p> 
<p><strong>静态资源</strong>： html.css.js.txt.mp4 视频 , jpg 图片</p> 
<p><strong>动态资源</strong>： jsp 页面.Servlet 程</p> 
<h3><a id="Tomcat__28"></a>(三)Tomcat 的使用</h3> 
<h4><a id="1_30"></a>1.安装</h4> 
<p>找到你需要用的 Tomcat 版本对应的 zip 压缩包，解压到需要安装的目录即可。</p> 
<h4><a id="2_34"></a>2.目录介绍</h4> 
<p>bin 专门用来存放 Tomcat 服务器的可执行程序</p> 
<p>conf 专门用来存放 Tocmat 服务器的配置文件</p> 
<p>lib 专门用来存放 Tomcat 服务器的 jar 包</p> 
<p>logs 专门用来存放 Tomcat 服务器运行时输出的日记信息</p> 
<p>temp 专门用来存放 Tomcdat 运行时产生的临时数据</p> 
<p>webapps 专门用来存放部署的 Web 工程。</p> 
<p>work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录</p> 
<h4><a id="3Tomcat_50"></a>3.启动Tomcat服务器</h4> 
<p>找到 Tomcat 目录下的 bin 目录下的 startup.bat 文件，双击，就可以启动 Tomcat 服务器。</p> 
<p>测试Tomcat服务器启动成功？<br> 输入：localhost:8080<br> 出现如下界面，说明启动成功<br> <img src="https://images2.imgbox.com/bc/bd/j8Ha0QiZ_o.png" alt="image-20220328162913979"></p> 
<h4><a id="4Tomcat_59"></a>4.Tomcat的停止</h4> 
<p>找到 Tomcat 的 bin 目录下的 shutdown.bat 双击，就可以停止 Tomcat 服务器。</p> 
<h4><a id="5Tomcat_63"></a>5.如何修改Tomcat端口号</h4> 
<p>找到 Tomcat 目录下的 conf 目录，找到 server.xml 配置文件<br> <img src="https://images2.imgbox.com/2f/c8/aSgqQzkg_o.png" alt="image-20220328163553570"></p> 
<h4><a id="6webTomcat_70"></a>6.将web工程部署到Tomcat中</h4> 
<h5><a id="_72"></a>第一种部署方法</h5> 
<p>1.<strong>只需要把web工程的目录拷贝到Tomcat的webaapps目录下即可。</strong></p> 
<p>例：在 webapps 目录下创建一个 book 工程，将book项目的内容拷贝到下面<br> <img src="https://images2.imgbox.com/f9/99/Juud0lUM_o.png" alt="image-20220328163847017"></p> 
<p>2.访问<br> 访问格式：http:localhost:port/工程名/目录/文件名</p> 
<h5><a id="_84"></a>第二种部署方法</h5> 
<p>1.找到 Tomcat 下的 conf 目录<br> 2.创建\Catalina\localhost\<br> 3.在当前目录下,创建如下的配置文件<br> <img src="https://images2.imgbox.com/a7/c2/vw0IcRfk_o.png" alt="image-20220328164610497"></p> 
<p>abc.xml配置文件内容如下：</p> 
<pre><code>&lt;!-- Context 表示一个工程上下文path 表示工程的访问路径:/abc
docBase 表示你的工程目录在哪里
--&gt;
&lt;Context path="/abc" docBase="E:\book" /&gt;
</code></pre> 
<p>访问这个工程的路径如下:http://ip:port/abc/ 就表示访问 E:\book 目录</p> 
<h4><a id="7ROOT_indexhtml__102"></a>7.ROOT 的工程的访问，以及默认index.html 页面的访问</h4> 
<p>当我们在浏览器地址栏中输入访问地址如下：<br> http://ip:port/ ====&gt;&gt;&gt;&gt; 没有工程名的时候，默认访问的是 ROOT 工程。<br> 我们在Root工程中创建index.html，输入http://ip:port/ ，默认访问index.html<br> 当我们在浏览器地址栏中输入的访问地址如下：<br> http://ip:port/工程名/ ====&gt;&gt;&gt;&gt; 没有资源名，默认访问 index.html 页</p> 
<h2><a id="Servlet_112"></a>二.Servlet</h2> 
<h3><a id="servlet_114"></a>(一)servlet是什么</h3> 
<p>1.Servlet 是 JavaEE 规范之一。规范就是接口。<br> 2.Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序.Filter 过滤器.Listener 监听器。<br> 3.Servlet 是运行在服务器上的一个 java 小程序，<font color="red">它可以接收客户端发送过来的请求，并响应数据给客户端。</font></p> 
<h3><a id="Hello_World_120"></a>(二)Hello World</h3> 
<h4><a id="1_122"></a>1.实现步骤</h4> 
<p>1.实现servlet接口<br> 2.重写service方法<br> 3.配置web.xml文件</p> 
<h4><a id="2_128"></a>2.案例</h4> 
<p>第一步和第二步<br> <img src="https://images2.imgbox.com/be/20/lLzNgeqD_o.png" alt="image-20220328211722741"></p> 
<p>第三步<br> <img src="https://images2.imgbox.com/15/0c/1Iy47b10_o.png" alt="image-20220328211818820"><br> 在上图中</p> 
<pre><code>		&lt;servlet&gt;
				&lt;servelt-name&gt;servlet别名&lt;/servlet-name&gt;
				&lt;servelt-class&gt;全限定类名&lt;/servlet-class&gt;
		&lt;/servlet&gt;
		&lt;servlet-mapping&gt;
				&lt;servlet-name&gt;在上面servlet中起的别名&lt;/servlet-name&gt;
				&lt;url-pattern&gt;/路径名&lt;/url-pattern&gt;
		&lt;/servlet-mapping&gt;
</code></pre> 
<h4><a id="3urlservlet_148"></a>3.url地址到servlet的对应关系图</h4> 
<p><img src="https://images2.imgbox.com/24/59/fFjVAmTj_o.png" alt="image-20220328212823878"></p> 
<h3><a id="servlet_152"></a>(三).servlet生命周期</h3> 
<p>1.执行Servlet构造器方法<br> 2.执行init初始化方法</p> 
<p>在第一.第二步，是在第一次访问的时候创建Servlet程序会调用。</p> 
<p>3.执行service方法</p> 
<p>第三步，每次访问都会调用</p> 
<p>4.执行destroy销毁方法。</p> 
<p>第四步，在web工程停止的时候调用。</p> 
<h3><a id="GET__POST__167"></a>(四)GET 和 POST 请求的分发处理</h3> 
<p>在实现Servlet接口中，在service()方法中，可以获取到请求的方法<br> <img src="https://images2.imgbox.com/3f/80/OmRbwoVO_o.png" alt="image-20221106092551342"></p> 
<p>​ 向上面方法通过判断来写代码的话，每次就很麻烦，所以通过继承HttpServlet重写doGet()和doPost()就可以了。</p> 
<h4><a id="1_176"></a>1.实现步骤</h4> 
<p>通过继承HttpServlet类的方式实现Servlet程序<br> 1.编写一个类继承HttpServlet类<br> 2.根据业务需求重写doGet()或doPost()方法<br> 3.到web.xml中配置Servlet程序中的访问地址</p> 
<h4><a id="2_183"></a>2.案例</h4> 
<p>继承HttpServlet类，并重写doGet()或doPost()方法。</p> 
<p><img src="https://images2.imgbox.com/db/6b/dXeIAgXt_o.png" alt="image-20220328224806145"></p> 
<p>配置web.xml</p> 
<p><img src="https://images2.imgbox.com/52/73/auQVzO4q_o.png" alt="image-20220328224913454"></p> 
<h3><a id="Servlet_193"></a>(五)Servlet类的继承体系</h3> 
<p><img src="https://images2.imgbox.com/1d/46/Dv7N80ay_o.png" alt="image-20220328225113891"></p> 
<h3><a id="ServletConfig_197"></a>(六)ServletConfig类</h3> 
<h4><a id="1_199"></a>1.介绍</h4> 
<p>ServletConfig 类从类名上来看，就知道是 Servlet 程序的配置信息类。</p> 
<p>Servlet 程序和ServletConfig 对象都是由tomcat负责创建，我们负责使用。</p> 
<p>Servlet程序是默认第一次访问时候创建，ServletConfig是每个Servlet程序创建时，就会创建一个对应的ServletConfig对象。</p> 
<h4><a id="2ServletConfig_207"></a>2.ServletConfig类的三大作用</h4> 
<p>1.可以获取Servlet程序的别名servlet-name的值<br> 2.可以获取初始化参数init-param<br> 3.获取ServletContext对象</p> 
<h4><a id="3_213"></a>3.例</h4> 
<p>web.xml配置</p> 
<pre><code>&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;
&lt;servlet&gt;
&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;
&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;
&lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;/servlet-class&gt;
&lt;!--init-param 是初始化参数--&gt;
&lt;init-param&gt;
&lt;!--是参数名--&gt;
&lt;param-name&gt;username&lt;/param-name&gt;
&lt;!--是参数值--&gt;
&lt;param-value&gt;root&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;!--init-param 是初始化参数--&gt;
&lt;init-param&gt;
&lt;!--是参数名--&gt;
&lt;param-name&gt;url&lt;/param-name&gt;
&lt;!--是参数值--&gt;
&lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/servlet&gt;
&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;
&lt;servlet-mapping&gt;
&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;
&lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
&lt;!--
url-pattern 标签配置访问地址 &lt;br/&gt;
/ 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt;
/hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;
--&gt;
&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre> 
<p>servlet代码</p> 
<pre><code>@Override
public void init(ServletConfig servletConfig) throws ServletException {
System.out.println("2 init 初始化方法");
// 1.可以获取 Servlet 程序的别名 servlet-name 的值
System.out.println("HelloServlet 程序的别名是:" + servletConfig.getServletName());
// 2.获取初始化参数 init-param
System.out.println("初始化参数 username 的值是;" + servletConfig.getInitParameter("username"));
System.out.println("初始化参数 url 的值是;" + servletConfig.getInitParameter("url"));
// 3.获取 ServletContext 对象
System.out.println(servletConfig.getServletContext());
}
</code></pre> 
<p>注：重写init(ServletConfig config)方法一定要调用父类init(config)方法。</p> 
<h3><a id="ServletContext__270"></a>(七)ServletContext 类</h3> 
<h4><a id="1_272"></a>1.介绍</h4> 
<p>1.ServletContext 是一个接口，他表示Servlet上下文对象<br> 2.一个web工程，只有一个ServletContext对象实例<br> 3.ServletContext对象是一个域对象<br> 4.ServletContext是在web工程启动时候创建。在web工程停止时候销毁。</p> 
<p>域对象：可以在整个web工程中想Map一样存储数据的对象。</p> 
<h4><a id="2_281"></a>2.作用</h4> 
<p>1.获取 web.xml 中配置的上下文参数 context-param<br> 2.获取当前的工程路径，格式: /工程路径<br> 3.获取工程部署后在服务器硬盘上的绝对路径<br> 4.像 Map 一样存取数据</p> 
<h4><a id="3_288"></a>3.例</h4> 
<p>例1：获取web.xml中配置的上下文参数context-param和路径</p> 
<p>web.xml</p> 
<pre><code>&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;
&lt;context-param&gt;
&lt;param-name&gt;username&lt;/param-name&gt;
&lt;param-value&gt;context&lt;/param-value&gt;
&lt;/context-param&gt;
&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;
&lt;context-param&gt;
&lt;param-name&gt;password&lt;/param-name&gt;
&lt;param-value&gt;root&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre> 
<p>servlet代码</p> 
<pre><code>protected void doGet(HttpServletRequest request, HttpServletResponse response) throws
ServletException, IOException {
// 1.获取 web.xml 中配置的上下文参数 context-param
ServletContext context = getServletConfig().getServletContext();
String username = context.getInitParameter("username");
System.out.println("context-param 参数 username 的值是:" + username);
System.out.println("context-param 参数 password 的值是:" +
context.getInitParameter("password"));
// 2.获取当前的工程路径，格式: /工程路径
System.out.println( "当前工程路径:" + context.getContextPath() );
// 3.获取工程部署后在服务器硬盘上的绝对路径
/**
* / 斜杠被服务器解析地址为:http://ip:port/工程名/ 映射到 IDEA 代码的 web 目录&lt;br/&gt;
*/
System.out.println("工程部署的路径是:" + context.getRealPath("/"));
System.out.println("工程下 css 目录的绝对路径是:" + context.getRealPath("/css"));
System.out.println("工程下 imgs 目录 1.jpg 的绝对路径是:" + context.getRealPath("/imgs/1.jpg"));
}
</code></pre> 
<p>例2：像Map一样存取数据</p> 
<pre><code>public class ContextServlet1 extends HttpServlet {
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws
ServletException, IOException {
// 获取 ServletContext 对象
ServletContext context = getServletContext();
System.out.println(context);
System.out.println("保存之前: Context1 获取 key1 的值是:"+ context.getAttribute("key1"));
context.setAttribute("key1", "value1");
System.out.println("Context1 中获取域数据 key1 的值是:"+ context.getAttribute("key1"));
}
}
ContextServlet2 代码：
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException,
IOException {
ServletContext context = getServletContext();
System.out.println(context);
System.out.println("Context2 中获取域数据 key1 的值是:"+ context.getAttribute("key1"));
}
</code></pre> 
<h3><a id="HTTP_355"></a>(八)HTTP协议</h3> 
<h4><a id="1HTTP_357"></a>1.HTTP协议是什么</h4> 
<p>客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫做HTTP协议。</p> 
<p>HTTP协议总的数据又叫报文。</p> 
<h4><a id="2HTTP_363"></a>2.HTTP请求</h4> 
<p>HTTP请求分为两类：<br> GET请求，<br> POST请求</p> 
<h5><a id="1GET_369"></a>(1)GET请求</h5> 
<p>GET请求包括<strong>请求行</strong>和<strong>请求头</strong></p> 
<p>①请求头：<br> 请求的方式 GET<br> 请求的资源路径<br> 请求的协议和版本号 HTTP/1.1<br> ②请求头：<br> key：value 组成 不同的键值对，表示不同的含义。</p> 
<p><img src="https://images2.imgbox.com/72/54/ZJdCTPT8_o.png" alt="image-20220329173649175"></p> 
<h5><a id="2POST_382"></a>(2)POST请求</h5> 
<p>POST请求包括：请求行.请求头和请求体(请求头和请求体中间有空行)。</p> 
<p>①请求行：<br> 请求的方式 POST<br> 请求的资源路径<br> 请求的协议和版本号 HTTP/1.1</p> 
<p>②请求头：<br> key：value 不同的请求头拥有不同的含义</p> 
<p>③请求体：<br> 发送给服务器的数据<br> <img src="https://images2.imgbox.com/42/e0/lx2eT86J_o.png" alt="image-20220329174021087"></p> 
<h5><a id="3_398"></a>(3)常用请求头说明</h5> 
<p>Accept: 表示客户端可以接收的数据类型<br> Accpet-Languege: 表示客户端可以接收的语言类型<br> User-Agent: 表示客户端浏览器的信息<br> Host： 表示请求时的服务器 ip 和端口号</p> 
<h4><a id="3HTTP_405"></a>3.HTTP响应</h4> 
<p>响应行：<br> 响应的协议和版本号<br> 响应状态码<br> 响应状态描述符<br> 响应头：<br> key：value 不同的响应头，有不同含义<br> 响应体：<br> 回传给客户端的数据</p> 
<p><img src="https://images2.imgbox.com/ed/d9/x2c0MItP_o.png" alt="image-20220329193833233"></p> 
<h4><a id="4MIME__418"></a>4.MIME 类型说明</h4> 
<p>MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是"Multipurpose Internet Mail Extensions" 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小 类型”，并与某一种文件的扩展名相对应。</p> 
<table><thead><tr><th>文件</th><th align="center">MIME 类型</th></tr></thead><tbody><tr><td>超文本标记语言文本</td><td align="center">.html , .htm text/html</td></tr><tr><td>GIF 图形</td><td align="center">.gif image/gif</td></tr><tr><td>RTF 文本</td><td align="center">.rtf application/rtf</td></tr><tr><td>普通文本</td><td align="center">.txt text/plain</td></tr></tbody></table> 
<p>等。</p> 
<h3><a id="HttpServletRequest_431"></a>(九)HttpServletRequest</h3> 
<h4><a id="1_433"></a>1.作用</h4> 
<p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的 信息。</p> 
<h4><a id="2_437"></a>2.常用方法</h4> 
<h4><a id="3_439"></a>3.乱码解决</h4> 
<p>doGet中文乱码 <code>req.setContentType(“text/html;charset=utf-8”)</code></p> 
<p>doPost中文乱码 <code>req.setCharacterEncoding(“utf-8”)</code></p> 
<h4><a id="4_445"></a>4.请求转发</h4> 
<p>请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。</p> 
<p><img src="https://images2.imgbox.com/ae/82/QILqrJeB_o.png" alt="image-20220329200452855"></p> 
<h4><a id="5base_451"></a>5.base标签作用</h4> 
<p>base 标签设置页面相对路径工作时参照的地址 ，href 属性就是参数的地址<br> <code></code></p> 
<h4><a id="6codecode_456"></a>6.<code>/</code>的不同意义</h4> 
<p>/ 斜杠 如果被浏览器解析，得到的地址是：http://ip:port/</p> 
<pre><code>&lt;a href="/"&gt;斜杠&lt;/a&gt;
</code></pre> 
<p>/ 斜杠 如果被服务器解析，得到的地址是：http://ip:port/工程路径</p> 
<pre><code>1.&lt;url-pattern&gt;/servlet1&lt;/url-pattern&gt;
2.servletContext.getRealPath(“/”);
3.request.getRequestDispatcher(“/”);
</code></pre> 
<p>特殊情况：response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到 http://ip:port/</p> 
<h3><a id="HttpServletResponse_476"></a>(十)HttpServletResponse</h3> 
<h4><a id="1_478"></a>1.作用</h4> 
<p>每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置</p> 
<h4><a id="2_482"></a>2.两个输出流说明</h4> 
<p>字节流 getOutputStream(); 常用于下载（传递二进制数据）<br> 字符流 getWriter(); 常用于回传字符串（常用）</p> 
<p>两个流同时只能使用一个。<br> 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。</p> 
<h4><a id="3_490"></a>3.乱码问题解决</h4> 
<p>设置服务器字符集为utf-8： <code>resp.setCharacterEncoding(“utf-8”);</code></p> 
<p>设置服务器字符集为utf-8：<br> 有两种：<br> 第一种：通过响应头进行设置 <code>resp.setHeader(“Content-Type”,"text/html;charset=UTF-8);</code><br> 第二种：同时设置服务器和客户端都是用UTf-8字符集 <code>resp.setContentType(“text/html;charset=UTF-8”);</code></p> 
<h4><a id="4_499"></a>4.请求重定向</h4> 
<p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃）。</p> 
<p><img src="https://images2.imgbox.com/3d/22/Nz1Swtdt_o.png" alt="image-20221106094355253"></p> 
<p>设置请求重定向有两种：<br> 第一种：通过设置状态码和响应头 <code>resp.setStatus(302);</code><br> <code>resp.setHeader(“Location”,“http://localhost:8080”);</code></p> 
<p>​ 第二种(推荐使用)： <code>resp.sendRedirect(“http:localhost:8080”);</code></p> 
<h2><a id="JSP_519"></a>三.JSP</h2> 
<h3><a id="JSP_521"></a>(一).JSP是什么</h3> 
<p>JSP(全称 Java Server Pages)是由 Sun 公司专门为了解决动态生成 HTML 文档的技术。</p> 
<h4><a id="1_527"></a>1.使用原因</h4> 
<p>通过 Servlet 输出简单的 html 页面信息都非常不方便。所以 sun 公司推出一种叫做 jsp 的动态页面技术帮助我们实现对页面的输出繁锁工作。</p> 
<p>注：JSP不是html，所以不能像html一样直接可以通过浏览器访问，JSP本质是一个Servlet，所以蓄意通过Tomcat服务器才能进行访问。</p> 
<h4><a id="2JSP_533"></a>2.JSP运行原理</h4> 
<p>jsp 的本质 ，其实是一个 Servlet程序。</p> 
<p>jsp页面中的html内容被翻译到Servlet程序的service方法中原样输出，这就是我们说jsp是专用来输出html页面的Servlet程序。</p> 
<h3><a id="JSP_539"></a>(二).JSP语法</h3> 
<h4><a id="1jsp_541"></a>1.jsp文件头部声明介绍</h4> 
<p><code>&lt;%@ page language=“java” contentType=“text/html; charset=UTF-8” pageEncoding=“UTF-8” %&gt;</code></p> 
<table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">language</td><td>值只能是 java。 表示翻译的得到的是 java 语言的</td></tr><tr><td align="center">contentType</td><td>设置响应头 contentType 的内容</td></tr><tr><td align="center">pageEncoding</td><td>设置当前 jsp 页面的编码</td></tr><tr><td align="center">import</td><td>给当前 jsp 页面导入需要使用的类包</td></tr><tr><td align="center">autoFlush</td><td>设置是否自动刷新 out 的缓冲区，默认为 true</td></tr><tr><td align="center">buffer</td><td>设置 out 的缓冲区大小。默认为 8KB</td></tr><tr><td align="center">errorPage</td><td>设置当前 jsp 发生错误后，需要跳转到哪个页面去显示错误信息</td></tr><tr><td align="center">isErrorPage</td><td>设置当前 jsp 页面是否是错误页面。是的话，就可以使用 exception 异常对象</td></tr><tr><td align="center">session</td><td>设置当前 jsp 页面是否获取 session 对象,默认为 true</td></tr><tr><td align="center">extends</td><td>给服务器厂商预留的 jsp 默认翻译的 servlet 继承于什么类</td></tr></tbody></table> 
<h4><a id="2jsp_558"></a>2.jsp的三种脚本</h4> 
<h5><a id="1_560"></a>(1)第一种：声明脚本</h5> 
<p>格式：</p> 
<pre><code>&lt;%!					
	java代码
%&gt;
</code></pre> 
<p>作用：<br> ①定义全局变量<br> ②定义static静态代码块<br> ③定义方法<br> ④定义内部类</p> 
<p>可以写在类的内部的代码，都可以通过声明脚本来实现。</p> 
<h5><a id="2_578"></a>(2)第二种：表达式脚本(使用很多)</h5> 
<p>格式：</p> 
<pre><code>&lt;%=
	表达式
%&gt;
</code></pre> 
<p>作用：<br> ①用于向页面输出内容。<br> ②翻译到servlet程序的service方法中，以<code>out.print()</code>打印输出<br> ③<code>out</code>是jsp的一个内置对象，用于生成html的源代码</p> 
<p>注：表达式不要以分号结尾，否则会报错</p> 
<p>表达式脚本可以输出任意类型</p> 
<h5><a id="3_597"></a>(3)第三种：代码脚本(使用最多)</h5> 
<p>格式：</p> 
<pre><code>&lt;%
	java代码
%&gt;
</code></pre> 
<p>作用：<br> ①代码脚本的内容都会被翻译到<code>service()</code>方法中<br> ②所以书写在<code>service()</code>中的代码，都可以书写到脚本代码中</p> 
<h4><a id="3jsp_611"></a>3.jsp中的注释</h4> 
<p>单行注释和多行注释能在翻译后的 java 源代码中看见。</p> 
<p>&lt;%-- jsp 注释 --%&gt;</p> 
<h4><a id="4jsp_619"></a>4.jsp九大内置对象</h4> 
<p>打开编译jsp后的java文件，查看_jspService()方法</p> 
<p>九大内置对象</p> 
<table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>request</td><td>请求对象，可以获取请求信息</td></tr><tr><td>response</td><td>响应对象。可以设置响应信息</td></tr><tr><td>pageContext</td><td>当前页面上下文对象。可以在当前上下文保存属性信息</td></tr><tr><td>session</td><td>会话对象。可以获取会话信息</td></tr><tr><td>exception</td><td>异常对象只有在 jsp 页面的 page 指令中设置 isErrorPage=“true” 的时候才会存在</td></tr><tr><td>application</td><td>ServletContext 对象实例，可以获取整个工程的一些信息</td></tr><tr><td>config</td><td>ServletConfig 对象实例，可以获取 Servlet 的配置信息</td></tr><tr><td>out</td><td>输出流</td></tr><tr><td>page</td><td>表示当前 Servlet 对象实例（无用，用它不如使用 this 对象）</td></tr></tbody></table> 
<p>九大内置对象，都是我们可以在【代码脚本】中或【表达式脚本】中直接使用的对象</p> 
<h4><a id="5jsp_639"></a>5.jsp四大域对象</h4> 
<p>四大域对象经常用来保存数据信息。</p> 
<table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>pageContext</td><td>可以保存数据在同一个 jsp 页面中使</td></tr><tr><td>request</td><td>可以保存数据在同一个 request 对象中使用。经常用于在转发的时候传递数据</td></tr><tr><td>session</td><td>可以保存在一个会话中使用</td></tr><tr><td>application(ServletContext)</td><td>就是 ServletContext 对象</td></tr></tbody></table> 
<h3><a id="jspoutresponsegetWriter_654"></a>(三).jsp中的out输出流和response.getWriter()输出流</h3> 
<h4><a id="1_656"></a>1.实现图</h4> 
<p><img src="https://images2.imgbox.com/22/c5/Vdb6jQV8_o.png" alt="image-20220330190754195"></p> 
<h4><a id="2_660"></a>2.选择</h4> 
<p>jsp经过翻译之后，底层源代码都是油out来进行输出。我们在 jsp 页面中统一使用 out 来进行输出。避免打乱页面输出内容的顺序。</p> 
<p>out.write() 输出字符串没有问题<br> out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出）</p> 
<p>深入源码，浅出结论：在 jsp 页面中，可以统一使用 out.print()来进行输出</p> 
<h3><a id="jsp_671"></a>(四).jsp常用标签</h3> 
<h4><a id="1jsp_673"></a>1.jsp静态包含</h4> 
<p>格式： <code>&lt;%@ include file=“路径” %&gt;</code></p> 
<p>例：<code>&lt;%@ include file=“/include/footer.jsp”%&gt;</code><br> 第一个斜杠<code>/</code>表示为 <code>http://ip:port/工程路径/</code> 映射到代码的web目录</p> 
<p>特点：<br> 1.静态包含**不会翻译被包含的 jsp 页面。**不会被翻译成 <code>servlet</code> 。<br> 2.静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出</p> 
<h4><a id="2jsp_684"></a>2.jsp动态包含</h4> 
<p>格式： <code>&lt;jsp:include page=“路径”&gt;&lt; /jsp:include&gt;</code><br> 例：</p> 
<pre><code>&lt;jsp:include page="/include/footer.jsp"&gt;
	&lt;jsp:param name="username" value="bbj"/&gt;
	&lt;jsp:param name="password" value="root"/&gt;
&lt;/jsp:include&gt;
</code></pre> 
<p>特点：<br> 1.动态包含会把包含的 jsp 页面也翻译成为 java 代码<br> 2.动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。 JspRuntimeLibrary.include(request, response, “/include/footer.jsp”, out, false);<br> 3.动态包含，还可以传递参数。通过request获取。</p> 
<p><strong>动态包含的底层原理</strong>：</p> 
<p><img src="https://images2.imgbox.com/b6/5b/1fr0Wx0k_o.png" alt="image-20220330193219018"></p> 
<h4><a id="3jsp_705"></a>3.jsp标签-转发</h4> 
<p>格式： <code>&lt;jsp:forward page=“”&gt;&lt; / jsp:forward&gt;</code></p> 
<p>例：<code>&lt;jsp:forward page=“/scope2.jsp”&gt;&lt; / jsp:forward&gt;</code></p> 
<p>功能就是请求转发，<code>page</code>是设置请求转发的路径。</p> 
<h2><a id="codeListenercode_713"></a>四.<code>Listener</code>监听器</h2> 
<h3><a id="_715"></a>(一).概述</h3> 
<p>1.Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序.Filter 过滤器.Listener 监听器。</p> 
<p>2.Listener 它是 JavaEE 的规范，就是接口</p> 
<p>3.监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。</p> 
<h3><a id="ServletContextListener__723"></a>(二).ServletContextListener 监听器</h3> 
<h4><a id="1_725"></a>1.介绍</h4> 
<p>监听器有八种。</p> 
<p>ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。</p> 
<p>ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。</p> 
<p>监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反</p> 
<h4><a id="2_735"></a>2.使用步骤</h4> 
<p>1.编写一个类去实现 ServletContextListener<br> 2.实现其两个回调方法<br> 3.到 web.xml 中去配置监听</p> 
<h2><a id="EL_743"></a>五.EL表达式</h2> 
<h3><a id="EL_745"></a>(一).EL表达式是什么</h3> 
<p>EL 表达式的全称是：Expression Language。是表达式语言。</p> 
<p>EL 表达式的什么作用：EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。</p> 
<p>因为 EL 表达式在输出数据的时候，要比 jsp 的表达式脚本要简洁很</p> 
<h4><a id="jsp_753"></a>对比jsp的表达式</h4> 
<pre><code>&lt;body&gt;
&lt;%
	request.setAttribute("key1","值");
%&gt;
表达式脚本输出 key 的值是：
&lt;%=request.getAttribute("key1")==null?"":request.getAttribute("key1")%&gt;&lt;br/&gt;
EL 表达式输出 key 的值是：${key1}
&lt;/body&gt;
</code></pre> 
<p>EL 表达式的格式是：${表达式}<br> EL 表达式在输出 null 值的时候，输出的是空串。jsp 表达式脚本输出 null 值的时候，输出的是 null 字符。</p> 
<h3><a id="EL__769"></a>(二).EL 表达式搜索域数据的顺序</h3> 
<p>EL 表达式主要是在 jsp 页面中输出数据。 主要是输出域对象中的数据。</p> 
<p>搜索顺序：<br> pageContext<br> request<br> session<br> application</p> 
<h3><a id="EL__779"></a>(三).EL 表达式——运算</h3> 
<p>语法：${ 运算表达式 }</p> 
<p><img src="https://images2.imgbox.com/65/44/KAe4F2fQ_o.png" alt="image-20220330195841689"></p> 
<p>还有三元运算.empty运算.</p> 
<p>“.”点运算 和 [] 中括号运算符</p> 
<p>点运算，可以输出 Bean 对象中某个属性的值。<br> []中括号运算，可以输出有序集合中某个元素的值。<br> 并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值。</p> 
<h3><a id="EL11_793"></a>(四).EL表达式的11个隐含对象</h3> 
<p><img src="https://images2.imgbox.com/10/6c/EsVjHiQD_o.png" alt="image-20220330200523926"></p> 
<h2><a id="JSTL__797"></a>六.JSTL 标签库</h2> 
<h3><a id="_799"></a>(一).介绍</h3> 
<p>JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。</p> 
<p>EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁。</p> 
<p><img src="https://images2.imgbox.com/c8/dd/zOykxtYd_o.png" alt="image-20220330201236013"></p> 
<h3><a id="_807"></a>(二).使用</h3> 
<p>在 jsp 标签库中使用 taglib 指令引入标签库</p> 
<p>CORE 标签库<br> <code>&lt;%@ taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt;</code></p> 
<p>相关请搜索CSDN，懒得介绍了，没多大用。</p> 
<h2><a id="_816"></a>七.文件的上传和下载</h2> 
<h3><a id="_818"></a>(一).文件的上传</h3> 
<h4><a id="1_820"></a>1.上传要求</h4> 
<p>1.要有一个form标签，method=post 请求<br> 2.form标签的encType属性值必须为multipart/form-data值<br> 3.在form标签中使用input type=file 添加上传的文件<br> 4.编写服务器代码(Servlet 程序)接收，处理上传的数据。</p> 
<p>encType=multipart/form-data表示提交的数据，以多段(每-一个表单项一个数据段)的形式进行拼接，然后以二进制流的形式发送给服务器</p> 
<h4><a id="2HTTP_829"></a>2.文件上传时发送的HTTP协议内容</h4> 
<p><img src="https://images2.imgbox.com/f8/eb/UC84Yt6m_o.png" alt="image-20220331214147050"></p> 
<h3><a id="_835"></a>(二).文件的下载</h3> 
<p>下载的常用API说明:<br> <code>response.getOutputStream();</code><br> <code>servletContext.getResourceAsStream( ) ;</code><br> <code>servletContext.getMimeType( );</code><br> <code>response.setContentType();</code></p> 
<p>response . setHeader( “Content-Disposition”，" attachment; fileName=1 . jpg");<br> 这个响应头告诉浏览器。这是需要下载的。而attachment表示附件，也就是下载的一一个文件。fileName= 后面，表示下载的文件名。</p> 
<p>附件名乱码解决：<br> URLEncoder编码<br> BASE64编码<br> 每个浏览器使用的编码不同，需要使用对应的编码</p> 
<h2><a id="CookieSession_855"></a>八.Cookie和Session</h2> 
<h3><a id="Cookie_857"></a>(一).Cookie</h3> 
<h4><a id="1Cookie_859"></a>1.什么是Cookie？</h4> 
<p>1.Cookie是服务器通知客户端保存键值对的一种技术。<br> 2.客户端有了Cookie 后，每次请求都发送给服务器。<br> 3.每个Cookie的大小不能超过4kb。</p> 
<h4><a id="2Cookie_865"></a>2.Cookie的创建</h4> 
<p><img src="https://images2.imgbox.com/5f/f4/onpC6dy9_o.png" alt="image-20220331214832210"></p> 
<p>代码：</p> 
<pre><code>protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException,
IOException {
	//1 创建 Cookie 对象
	Cookie cookie = new Cookie("key4", "value4");
	//2 通知客户端保存 Cookie
	resp.addCookie(cookie);
	//1 创建 Cookie 对象
	Cookie cookie1 = new Cookie("key5", "value5");
	//2 通知客户端保存 Cookie
	resp.addCookie(cookie1);
	resp.getWriter().write("Cookie 创建成功");
}
</code></pre> 
<h4><a id="3Cookie_886"></a>3.Cookie的操作</h4> 
<p>服务端获取客户端的Cookie：<code>req.getCookies()</code><br> 等。</p> 
<h4><a id="4Cookie_891"></a>4.浏览器查看Cookie</h4> 
<p>在开发者模式中点击application</p> 
<h4><a id="5Cookie_895"></a>5.Cookie的生命控制</h4> 
<p>Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除）</p> 
<p>setMaxAge()<br> 正数，表示在指定的秒数后过期<br> 负数，表示浏览器一关，Cookie 就会被删除（默认值是-1）<br> 零，表示马上删除 Cooki</p> 
<h4><a id="6Cookie__Path__904"></a>6.Cookie 有效路径 Path 的设置</h4> 
<p>Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 path 属性是通过请求的地址来进行有效的过滤。</p> 
<p>方法：<code>cookie.setPath(String path);</code></p> 
<h3><a id="Session_910"></a>(二).Session</h3> 
<h4><a id="1Session_912"></a>1.什么是Session</h4> 
<p>Session就-一个接 口( HttpSession)<br> Session就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。<br> 每个客户端都有自己的一个Session会话。<br> Session会话中，我们经常用来保存用户登录之后的信息。</p> 
<h4><a id="2SessionSessionId_921"></a>2.如何创建Session.Session的Id和判断是否是为新创建的</h4> 
<p>创建：<code>request.getSession();</code></p> 
<p>判断是否为新：<code>session.isNew();</code></p> 
<p>每个会话都有一个身份证号，也就是ID值，唯一：<code>session.getId();</code></p> 
<h4><a id="3Session_929"></a>3.Session生命周期控制</h4> 
<p>public void setMaxlnactiveInterval(int interval)设 置Session 的超时时间(以秒为单位)，超过指定的时长，Session就会被销毁。<br> 值为正数的时候，设定Session的超时时长。<br> 负数表示永不超时(极少使用)<br> <code>public int getMaxlnactiveInterval()</code>获取Session的超时时间<br> <code>public void invalidate()</code>让当前Session会话马上超时无效。</p> 
<p>Session默认的超时时长为30分钟。<br> 因为Tomcat服务器的配置文件web.xml中默认由以下的配置，标识当前tomcat服务器下的所有Sessin超时配置默认为30分钟。</p> 
<pre><code>&lt;session-config&gt;
	&lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre> 
<h4><a id="4_Session__946"></a>4.浏览器和 Session 之间关联的技术内幕</h4> 
<p><img src="https://images2.imgbox.com/cb/93/AWCFBovZ_o.png" alt="image-20220331220149624"></p> 
<h2><a id="_952"></a>九.过滤器</h2> 
<h3><a id="1Filter__954"></a>1.Filter 什么是过滤器</h3> 
<p>1.Filter过滤器它是JavaWeb的三大组件之一。三大组件分别是: Servlet程序.Listener 监听器.Filter 过滤器<br> 2.Filter过滤器它是JavaEE的规范。也就是接口<br> 3.Filter过滤器它的作用是:拦截请求，过滤响应。</p> 
<p>拦截请求常见的应用场景有:<br> 1.权限检查<br> 2.日记操作<br> 3.事务管理<br> .等等</p> 
<h3><a id="2Filter__966"></a>2.Filter 的工作流程图</h3> 
<p><img src="https://images2.imgbox.com/2a/09/uI6uJkMD_o.png" alt="image-20220331220552458"></p> 
<p>例：</p> 
<pre><code>public class AdminFilter implements Filter {
/**
* doFilter 方法，专门用于拦截请求。可以做权限检查
*/
@Override
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain
filterChain) throws IOException, ServletException {
HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
HttpSession session = httpServletRequest.getSession();
Object user = session.getAttribute("user");
// 如果等于 null，说明还没有登录
if (user == null) {
servletRequest.getRequestDispatcher("/login.jsp").forward(servletRequest,servletResponse);
return;
} else {
// 让程序继续往下访问用户的目标资源
filterChain.doFilter(servletRequest,servletResponse);
}
}
}


web.xml 中的配置：
&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;
&lt;filter&gt;
&lt;!--给 filter 起一个别名--&gt;
&lt;filter-name&gt;AdminFilter&lt;/filter-name&gt;
&lt;!--配置 filter 的全类名--&gt;
&lt;filter-class&gt;com.atguigu.filter.AdminFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;!--filter-mapping 配置 Filter 过滤器的拦截路径--&gt;
&lt;filter-mapping&gt;
&lt;!--filter-name 表示当前的拦截路径给哪个 filter 使用--&gt;
&lt;filter-name&gt;AdminFilter&lt;/filter-name&gt;
&lt;!--url-pattern 配置拦截路径
/ 表示请求地址为：http://ip:port/工程路径/ 映射到 IDEA 的 web 目录
/admin/* 表示请求地址为：http://ip:port/工程路径/admin/*
--&gt;
&lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre> 
<h3><a id="3_1015"></a>3.使用步骤</h3> 
<p>1.编写一个类去实现 Filter 接口<br> 2.实现过滤方法 doFilter()<br> 3.到 web.xml 中去配置 Filter 的拦截路</p> 
<h3><a id="4Filter__1021"></a>4.Filter 的生命周期</h3> 
<p>Filter的生命周期包含几个方法：<br> 1.构造器方法<br> 2.init 初始化方法<br> 第1，2步，在web工程启动的时候执行(Filter 已经创建)<br> 3.doFilter 过滤方法<br> 第3步，每次拦截到请求，就会执行<br> 4.destroy 销毁<br> 第4步，停止web工程的时候，就会执行(停止web工程，也会销毁Filter过滤器)</p> 
<h3><a id="5FilterConfig__1032"></a>5.FilterConfig 类</h3> 
<p>FilterConfig类见名知义，它是Filter过滤器的配置文件类。<br> Tomcat每次创建Filter的时候，也会同时创建一个FilterConfig类，这里包含了Filter 配置文件的配置信息。</p> 
<p>FilterConfig类的作用是获取filter过滤器的配置内容：<br> 1.获取Filter的名称filter-name 的内容<br> 2.获取在Filter中配置的init-param初始化参数<br> 3.获取ServletContext对象</p> 
<h3><a id="6FilterChain__1042"></a>6.FilterChain 过滤器链</h3> 
<p><img src="https://images2.imgbox.com/e2/ef/SZ2LaOpq_o.png" alt="image-20220331223323117"></p> 
<h3><a id="7_1046"></a>7.拦截路径</h3> 
<p>精确匹配：<br> <code>/target.jsp</code><br> 以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp</p> 
<p>目录匹配<br> <code>/admin/*</code><br> 以上配置的路径，表示请求地址必须为：<code>http://ip:port/工程路径/admin/*</code></p> 
<p>后缀名匹配<br> <code>*.html</code><br> 以上配置的路径，表示请求地址必须以.html 结尾才会拦截到</p> 
<h2><a id="ThreadLocal_1060"></a>十.ThreadLocal</h2> 
<p>Threadlocal的作用，它可以解决多线程的数据安全问题。</p> 
<p>ThreadLocal它可以给当前线程关联一一个数据(可以是普通变量，可以是对象，也可以是数组，集合)</p> 
<p>ThreadLocal的特点:<br> 1.ThreadLocal 可以为当前线程关联一个数据。 (它可以像 Map一样存取数据，key 为当前线程)<br> 2.每一个ThreadLocal对象，只能为当前线程关联一个数据， 如果要为当前线程关联多个数据，就需要使用多个ThreadLocal对象实例。<br> 3.每个ThreadLocal对象实例定义的时候，一般都是static 类型<br> 4.ThreadLocal 中保存数据，在线程销毁后。会由JVM虚拟自动释放。<br> destroy 销毁<br> 第4步，停止web工程的时候，就会执行(停止web工程，也会销毁Filter过滤器)</p> 
<h3><a id="5FilterConfig__1074"></a>5.FilterConfig 类</h3> 
<p>FilterConfig类见名知义，它是Filter过滤器的配置文件类。<br> Tomcat每次创建Filter的时候，也会同时创建一个FilterConfig类，这里包含了Filter 配置文件的配置信息。</p> 
<p>FilterConfig类的作用是获取filter过滤器的配置内容：<br> 1.获取Filter的名称filter-name 的内容<br> 2.获取在Filter中配置的init-param初始化参数<br> 3.获取ServletContext对象</p> 
<h3><a id="6FilterChain__1084"></a>6.FilterChain 过滤器链</h3> 
<p>[外链图片转存中…(img-W2mid7tF-1667699178783)]</p> 
<h3><a id="7_1088"></a>7.拦截路径</h3> 
<p>精确匹配：<br> <code>/target.jsp</code><br> 以上配置的路径，表示请求地址必须为：http://ip:port/工程路径/target.jsp</p> 
<p>目录匹配<br> <code>/admin/*</code><br> 以上配置的路径，表示请求地址必须为：<code>http://ip:port/工程路径/admin/*</code></p> 
<p>后缀名匹配<br> <code>*.html</code><br> 以上配置的路径，表示请求地址必须以.html 结尾才会拦截到</p> 
<h2><a id="ThreadLocal_1102"></a>十.ThreadLocal</h2> 
<p>Threadlocal的作用，它可以解决多线程的数据安全问题。</p> 
<p>ThreadLocal它可以给当前线程关联一一个数据(可以是普通变量，可以是对象，也可以是数组，集合)</p> 
<p>ThreadLocal的特点:<br> 1.ThreadLocal 可以为当前线程关联一个数据。 (它可以像 Map一样存取数据，key 为当前线程)<br> 2.每一个ThreadLocal对象，只能为当前线程关联一个数据， 如果要为当前线程关联多个数据，就需要使用多个ThreadLocal对象实例。<br> 3.每个ThreadLocal对象实例定义的时候，一般都是static 类型<br> 4.ThreadLocal 中保存数据，在线程销毁后。会由JVM虚拟自动释放。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5bc02b09a386a55fc250ac0485c8d9b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3.0 特殊语法说明</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/857808c31d56dafb5f23d08013491953/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于简单MLP模型的加州房价预测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>