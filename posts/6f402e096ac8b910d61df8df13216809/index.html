<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么 Spring和IDEA 都不推荐使用@Autowired注解? - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么 Spring和IDEA 都不推荐使用@Autowired注解?" />
<meta property="og:description" content="为什么Idea只对@Autowired警告？
使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解@Autowired后会出现如下警告 Field injection is not recommended (字段注入是不被推荐的) 但是使用@Resource却不会出现此提示
网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下:
构造器注入 ：利用构造方法的参数注入依赖
Setter注入 ：调用Setter的方法注入依赖
字段注入 ：在字段上使用@Autowired/Resource注解
事实上，他们的基本功能都是通过注解实现依赖注入 ，只不过@Autowired是Spring定义的，而@Resource是JSR-250定义的。大致功能基本相同，但是还有一些细节不同：
依赖识别方式 ：@Autowired默认是byType 可以使用@Qualifier指定Name，@Resource默认ByName 如果找不到则ByType
适用对象 ：@Autowired可以对构造器、方法、参数、字段 使用，@Resource只能对方法、字段 使用
提供方 ：@Autowired是Spring 提供的，@Resource是JSR-250 提供的
参考Spring官方文档，建议了如下的使用场景：
构造器注入 ：强依赖性 （即必须使用此依赖），不变性 （各依赖不会经常变动）
Setter注入 ：可选 （没有此依赖也可以工作），可变 （依赖会经常变动）
Field注入 ：大多数情况下尽量少使用 字段注入，一定要使用的话， @Resource相对@Autowired 对IoC容器的耦合更低
不能像构造器那样注入不可变的对象
依赖对外部不可见 ，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖
会导致组件与IoC容器紧耦合 （这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）
导致单元测试也必须使用IoC容器 ，原因同上
依赖过多时不够明显 ，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是违反了单一职责原则
Field注入虽然有很多缺点，但它的好处也不可忽略：那就是太方便了 。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。
那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？ 个人认为 ，就像我们前面提到过的：@Autowired 是Spring 提供的，它是特定IoC提供的特定注解 ，这就导致了应用与框架的强绑定 ，一旦换用了其他的IoC框架，是不能够支持注入 的。
而 @Resource 是JSR-250 提供的，它是Java标准 ，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/6f402e096ac8b910d61df8df13216809/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-05T16:02:44+08:00" />
<meta property="article:modified_time" content="2023-06-05T16:02:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么 Spring和IDEA 都不推荐使用@Autowired注解?</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>为什么Idea只对@Autowired警告？</p> 
<ul><li>使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解<code>@Autowired</code>后会出现如下警告 
  <ul><li> 
    <div> 
     <pre><code class="language-java hljs">Field injection is not <span class="function_ hljs-title">recommended</span> <span class="hljs-params">(字段注入是不被推荐的)</span></code></pre> 
    </div> <p>但是使用<code>@Resource</code>却不会出现此提示</p> <p>网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下:</p> </li><li> <p><strong>构造器注入</strong> ：利用构造方法的参数注入依赖</p> </li><li> <p><strong>Setter注入</strong> ：调用Setter的方法注入依赖</p> </li><li> <p><strong>字段注入</strong> ：在字段上使用<code>@Autowired/Resource</code>注解</p> </li><li> <p>事实上，他们的基本功能都是通过注解实现<strong>依赖注入</strong> ，只不过<code>@Autowired</code>是<code>Spring</code>定义的，而<code>@Resource</code>是<code>JSR-250</code>定义的。大致功能基本相同，但是还有一些细节不同：</p> </li><li> <p><strong>依赖识别方式</strong> ：<code>@Autowired</code>默认是<strong>byType</strong> 可以使用<code>@Qualifier</code>指定Name，<code>@Resource</code><strong>默认ByName</strong> 如果<strong>找不到则ByType</strong></p> </li><li> <p><strong>适用对象</strong> ：<code>@Autowired</code>可以对<strong>构造器、方法、参数、字段</strong> 使用，<code>@Resource</code>只能对<strong>方法、字段</strong> 使用</p> </li><li> <p><strong>提供方</strong> ：<code>@Autowired</code>是<strong>Spring</strong> 提供的，<code>@Resource</code>是<strong>JSR-250</strong> 提供的</p> </li><li> <h4></h4> <p>参考Spring官方文档，建议了如下的使用场景：</p> </li><li> <p><strong>构造器注入</strong> ：<strong>强依赖性</strong> （即必须使用此依赖），<strong>不变性</strong> （各依赖不会经常变动）</p> </li><li> <p><strong>Setter注入</strong> ：<strong>可选</strong> （没有此依赖也可以工作），<strong>可变</strong> （依赖会经常变动）</p> </li><li> <p><strong>Field注入</strong> ：大多数情况下尽量<strong>少使用</strong> 字段注入，一定要使用的话， <strong>@Resource相对@Autowired</strong> 对IoC容器的<strong>耦合更低</strong></p> </li><li> <p><strong>不能像构造器那样注入不可变的对象</strong></p> </li><li> <p><strong>依赖对外部不可见</strong> ，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖</p> </li><li> <p>会导致<strong>组件与IoC容器紧耦合</strong> （这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</p> </li><li> <p>导致<strong>单元测试也必须使用IoC容器</strong> ，原因同上</p> </li><li> <p><strong>依赖过多时不够明显</strong> ，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是<strong>违反了单一职责原则</strong></p> </li><li> <h4></h4> <p>Field注入虽然有很多缺点，但它的好处也不可忽略：那就是<strong>太方便了</strong> 。使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。</p> 
    <div> 
     <pre><code class="language-java hljs">那么问题来了，为什么IDEA只对<span class="hljs-meta">@Autowired</span>警告，却对<span class="hljs-meta">@Resource</span>视而不见呢？</code></pre> 
    </div> <p><strong>个人认为</strong> ，就像我们前面提到过的：<strong>@Autowired</strong> 是<strong>Spring</strong> 提供的，它是<strong>特定IoC提供的特定注解</strong> ，这就导致了应用与框架的<strong>强绑定</strong> ，一旦换用了其他的IoC框架，是<strong>不能够支持注入</strong> 的。</p> <p>而 <strong>@Resource</strong> 是<strong>JSR-250</strong> 提供的，它是<strong>Java标准</strong> ，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p> </li></ul></li></ul>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a27d6265c4af14f875a59d4812886c4b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OVD (Open-Vocabulary Detection)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46c1d81f0a83c7e28d79ed9932f90318/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解Java实现坦克大战小游戏（JavaFX，完整源码&#43;注释说明）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>