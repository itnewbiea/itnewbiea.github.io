<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>u-boot配置与编译、kernel的裁剪添加移植、busybox根文件系统的制作等 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="u-boot配置与编译、kernel的裁剪添加移植、busybox根文件系统的制作等" />
<meta property="og:description" content="目录
1.裸机... 3
1.1裸机烧写系统... 3
1.2裸机启动流程分析... 3
1.2.1 BL0：... 3
1.2.2 BL1：... 4
1.2.3 BL2：... 4
1.3那么裸机怎么启动呢：编写裸机代码，比如说让灯亮... 4
2.uboot基本使用... 5
2.1uboot文件目录介绍... 5
2.2uboot的启动方式... 6
2.3uboot编译烧写... 6
2.4uboot的基本命令... 7
2.5Bootloader 启动的两个阶段... 8
3. linux内核... 8
3.1内核功能：... 8
3.2linux目录介绍... 8
3.3内核编译/烧写过程... 9
4.文件系统... 10
4.1介绍：... 10
4.2 搭建一个文件系统：... 11
5.NFS文件系统服务的搭建... 14
5.1 NFS概念：... 14
5.2工作原理：... 14
5.3 NFS服务的搭建... 14
5.4 NFS服务的测试... 16
6.内核模块化编程... 16
6.1 模块化介绍... 16
6.2 静态编译到内核步骤：比如说写个led的驱动... 16
6.3 动态编译到内核的步骤：." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/f72adc2a3d3a00deb965edea917d02eb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-24T17:05:06+08:00" />
<meta property="article:modified_time" content="2020-09-24T17:05:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">u-boot配置与编译、kernel的裁剪添加移植、busybox根文件系统的制作等</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <p style="margin-left:0cm;"><span style="color:#365f91;"><strong>目录</strong></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267371" rel="nofollow">1.裸机... 3</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267372" rel="nofollow">1.1裸机烧写系统... 3</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267373" rel="nofollow">1.2裸机启动流程分析... 3</a></u></span></p> 
 <p style="margin-left:42pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267374" rel="nofollow">1.2.1 BL0：... 3</a></u></span></p> 
 <p style="margin-left:42pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267375" rel="nofollow">1.2.2 BL1：... 4</a></u></span></p> 
 <p style="margin-left:42pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267376" rel="nofollow">1.2.3 BL2：... 4</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267377" rel="nofollow">1.3那么裸机怎么启动呢：编写裸机代码，比如说让灯亮... 4</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267378" rel="nofollow">2.uboot基本使用... 5</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267379" rel="nofollow">2.1uboot文件目录介绍... 5</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267380" rel="nofollow">2.2uboot的启动方式... 6</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267381" rel="nofollow">2.3uboot编译烧写... 6</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267382" rel="nofollow">2.4uboot的基本命令... 7</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267383" rel="nofollow">2.5Bootloader 启动的两个阶段... 8</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267384" rel="nofollow">3. linux内核... 8</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267385" rel="nofollow">3.1内核功能：... 8</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267386" rel="nofollow">3.2linux目录介绍... 8</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267387" rel="nofollow">3.3内核编译/烧写过程... 9</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267388" rel="nofollow">4.文件系统... 10</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267389" rel="nofollow">4.1介绍：... 10</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267390" rel="nofollow">4.2 搭建一个文件系统：... 11</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267391" rel="nofollow">5.NFS文件系统服务的搭建... 14</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267392" rel="nofollow">5.1 NFS概念：... 14</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267393" rel="nofollow">5.2工作原理：... 14</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267394" rel="nofollow">5.3 NFS服务的搭建... 14</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267395" rel="nofollow">5.4 NFS服务的测试... 16</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267396" rel="nofollow">6.内核模块化编程... 16</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267397" rel="nofollow">6.1 模块化介绍... 16</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267398" rel="nofollow">6.2 静态编译到内核步骤：比如说写个led的驱动... 16</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267399" rel="nofollow">6.3 动态编译到内核的步骤：... 17</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267400" rel="nofollow">6.4 单模块框架：... 17</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267401" rel="nofollow">6.5编写Makefile: 18</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267402" rel="nofollow">6.6多模块：... 18</a></u></span></p> 
 <p style="margin-left:42pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267403" rel="nofollow">6.6.1模块2调用模块1中函数... 18</a></u></span></p> 
 <p style="margin-left:42pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267404" rel="nofollow">6.6.2多个模块编译为1个模块... 18</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267405" rel="nofollow">6.7 向模块传参: 18</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267406" rel="nofollow">7.驱动简介... 20</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267407" rel="nofollow">8.那么，对于杂项设备来说：... 20</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267408" rel="nofollow">8.1注册函数：int misc_register(struct miscdevice *misc); 20</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267409" rel="nofollow">8.2注销函数：int misc_deregister(struct miscdevice *misc) 20</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267410" rel="nofollow">8.3特点：... 21</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267411" rel="nofollow">9.那么，对于早期经典设备来说：... 21</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267412" rel="nofollow">9.1注册函数:int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops) 21</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267413" rel="nofollow">9.2注销函数：static inline void unregister_chrdev(unsigned int major, const char *name) 21</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267414" rel="nofollow">9.3特点：... 22</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267415" rel="nofollow">10.那么，对于linux2.6版本注册来说：... 22</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267416" rel="nofollow">10.1首先，申请设备号：... 22</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267417" rel="nofollow">10.2然后，添加设备：... 23</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267418" rel="nofollow">10.3最后，自动创建设备节点：... 23</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267419" rel="nofollow">10.4前面的一系列的操作完整的完成的设备驱动程序，然后就是注销... 23</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267420" rel="nofollow">11.理解... 24</a></u></span></p> 
 <p style="margin-left:0cm;"><span style="color:#0000ff;"><u><a href="#_Toc51267421" rel="nofollow">附录... 25</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267422" rel="nofollow">整个系统的启动流程图：... 25</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267423" rel="nofollow">u-boot分区结构：... 25</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267424" rel="nofollow">SD卡的详细分区：... 26</a></u></span></p> 
 <p style="margin-left:21pt;"><span style="color:#0000ff;"><u><a href="#_Toc51267425" rel="nofollow">exynos4412的内部存储图：... 26</a></u></span></p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"> </h2> 
 <h2 style="margin-left:0cm;"> </h2> 
 <h2 style="margin-left:0cm;"> </h2> 
 <h2 style="margin-left:0cm;"> </h2> 
 <h2 style="margin-left:0cm;"> </h2> 
</div> 
<p> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267371">1.</a>裸机</strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267372">1.1</a>裸机烧写系统</strong></h3> 
<ol><li>我们是通过SD卡(启动方式)来烧写系统，所以我们首先要给分区</li><li>把操作系统和恶化配置文件给cp到SD卡，然后把配置文件给修改成你想烧写的系统</li><li>把SD插在板子上，选择启动方式为SD卡</li></ol> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267373">1.2</a>裸机启动流程分析</strong></h3> 
<p style="text-align:center;"><img alt="1" src="https://images2.imgbox.com/bf/f2/DVXy33m5_o.png"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">简单地说，</span><span style="color:#000000;">iROM(BL0)</span><span style="color:#000000;">就是先设置程序运行环境</span><span style="color:#000000;"> (</span><span style="color:#000000;">比如关看门狗、关中断、关</span><span style="color:#000000;">MMU </span><span style="color:#000000;">、设置栈</span> <span style="color:#000000;">、设置栈</span> <span style="color:#000000;">、启动</span><span style="color:#000000;"> PLL </span><span style="color:#000000;">等</span><span style="color:#000000;"> )</span><span style="color:#000000;">；然后根据</span><span style="color:#000000;">OM</span><span style="color:#000000;">引脚确定启动设备</span><span style="color:#000000;"> (NAND Flash/SD </span><span style="color:#000000;">卡</span><span style="color:#000000;">/</span><span style="color:#000000;">其他</span><span style="color:#000000;"> )</span><span style="color:#000000;">，把</span><span style="color:#000000;"> BL1 </span><span style="color:#000000;">从里面读出存入</span><span style="color:#000000;">iRAM</span><span style="color:#000000;">；最后启动</span><span style="color:#000000;"> BL1.</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc51267374">1.2.1 BL0</a>：</strong></h4> 
<p style="margin-left:0cm;"><span style="color:#333333;">三星公司固化到SOC内部的ROM（iROM），里面主要是尽可能只做uboot加载，尽可能消除其他的影响（关闭WDT、禁用IRQ、关闭cache等等），接下来就是从外设拷贝加载BL1。</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc51267375">1.2.2 BL1</a>：</strong></h4> 
<p style="margin-left:0cm;"><span style="color:#333333;">没什么特殊功能，特点就是经过加密的，而且BL1由三星公司提供好的，完成对BL2的加载到iRAM运行。要想在开发板上移植运行后续的代码，通过签名的方式实现软件和硬件合法性的匹配</span></p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc51267376">1.2.3 BL2</a>：</strong></h4> 
<p style="margin-left:0cm;"><span style="color:#333333;">由平台研发人员编写，根据SOC外内存硬件不同、工作频率不同，进行初始化设置，完成后续代码加载到初始化后的内存中运行（逻辑代码只占前14k，如果写超了的话，会被裁剪）</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267377">1.3</a>那么裸机怎么启动呢：编写裸机代码，比如说让灯亮</strong></h3> 
<ol><li><span style="color:#333333;">编译：首先呢，需要编写一个脚本，把led.c编译成led.o,然后把led.o链接到BL2的起始地址处(0x0202_3400)生成led.elf，然后在把.led.elf编译生成led.bin二进制文件</span></li><li><span style="color:#333333;">V310-EVT1-mkbl2.c</span><span style="color:#333333;">：/*复制出前14K内容，把前（14＊1024－4）＝14332字节做个和校验（checksum）得到一个4字节的校验码，再把它放到14332字节之后，输出一个新的14K的二进制文件*/</span></li><li><span style="color:#333333;">把V310-EVT1-mkbl2.c编译生成mkbl2，用mkbl2工具把led.bin生成bl2.bin，这里需要的文件有E4412_N.bl1.bin（这个是由三星公司提供的）</span></li><li><span style="color:#333333;">插上SD卡，通过脚本文件把bl2.bin烧写到</span>/dev/sdb中，./fast_fuse.sh /dev/sdb   ../led.bin</li></ol> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267378">2.uboot</a>基本使用</strong></h2> 
<p style="margin-left:0cm;"><span style="color:#000000;"><strong>bootlaoder</strong></span><span style="color:#000000;"><strong>：</strong></span><span style="color:#000000;">bootloader </span><span style="color:#000000;">就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境</span></p> 
<p style="margin-left:0cm;"><strong>uboot</strong>:是bootlaoder的一种，通用版</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267379">2.1uboot</a>文件目录介绍</strong></h3> 
<p style="margin-left:0cm;">fs：支持的文件系统</p> 
<p style="margin-left:0cm;">include：编译需要的头文件</p> 
<p style="margin-left:0cm;">mkconfig：配置的脚本文件</p> 
<p style="margin-left:0cm;">api: 函数接口</p> 
<p style="margin-left:0cm;">arch: 体系架构相关的文件,我们用的一般是：arch/arm/cpu：存放是cpu分类，armv7 /--Cortex-A8/9 系列CPU , 典型代表 Exynos4412</p> 
<p style="margin-left:0cm;">boards.cfg：给定一个名字 得到他对应的CPU架构、CPU、开发板名字(可以找到他对应的arch以及board下面的文件)</p> 
<p style="margin-left:0cm;">board：按照CPU厂家分类，具体内部又以开发板型号分类，我们用到的是board/samsung下的</p> 
<p style="margin-left:0cm;">common：通用的多功能函数实现，如环境，命令，控制台相关的函数实现。</p> 
<p style="margin-left:0cm;">disk：磁盘相关文件</p> 
<p style="margin-left:0cm;">Drivers：各种外设驱动</p> 
<p style="margin-left:0cm;">example：例程代码</p> 
<p style="margin-left:0cm;">fs：支持的文件系统：支持文件系统的文件，u-boot现在支持cramfs、fat、fdos、jffs2、yaffs和registerfs。</p> 
<p style="margin-left:0cm;">Lib：u-boot通用库函数，ARM的公共函数，比如printf</p> 
<p style="margin-left:0cm;">Post：电源管理。电源检测相关函数。如果没有它，例如电脑cpu风扇去掉了，没有该函数，那么容易烧cpu，如果有post函数，可以检测到是否有风扇，如果没有则不启动cpu即保护了cpu。</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267380">2.2uboot</a>的启动方式</strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">自启动模式（ </span><span style="color:#000000;">Boot laoding</span><span style="color:#000000;">）：这种模式下， </span><span style="color:#000000;">bootloader </span><span style="color:#000000;">从目标机上的某个固态存储设备(这里是SD卡上的BL2区域)上将操作系统加载到 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">中运行，整个过程并没有用户的介入。产品发布后， </span><span style="color:#000000;">bootloader </span><span style="color:#000000;">工作在这种模式下。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">交互模式：在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机下载文件（比如内核映像、文件系统映像）到 </span><span style="color:#000000;">RAM </span><span style="color:#000000;">中，可以被 </span><span style="color:#000000;">bootloader </span><span style="color:#000000;">写到目标机上的固态存储介质中，或者直接进入系统的引导。</span></p> 
<p style="margin-left:0cm;">可以利用串口对uboot传递参数，在倒计时结束前按enter即可进行设置。</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267381">2.3uboot</a>编译烧写</strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">（1）把今天资料中uboot_tiny4412-sdk1506.tar.bz2文件夹拷到 /root/workdir</span></p> 
<p style="margin-left:0cm;">       <span style="color:#000000;">（2）解压 tar zxvf uboot_tiny4412-sdk1506.tar.gz </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (3)cd uboot_tiny4412-sdk1506</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (4)make tiny4412_config</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (5)make   </span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (6)cd sd_fuse</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (7)make</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (8)cd tiny4412</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">(9)</span><span style="color:#000000;">插SD卡</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">        (10)./sd_fusing.sh  /dev/sdb</span></p> 
<p style="margin-left:0cm;">测试u-boot</p> 
<p style="margin-left:0cm;">连接好 串口线，连接到电脑，上电，选择SD为启动方式，映射开发板到windows操作系统（通过串口）</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267382">2.4uboot</a>的基本命令</strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">可以通过这些指令对u-boot启动前的配置和查看</span></p> 
<p style="margin-left:0cm;">uboot环境变量的基本配置流程</p> 
<p style="margin-left:0cm;">查看：printenv、print、pri 打印全部环境变量</p> 
<p style="margin-left:0cm;">设置：set、setenv 新增、修改、删除环境变量</p> 
<p style="margin-left:0cm;">保存：save 保存环境变量</p> 
<p style="margin-left:0cm;">重启：reset</p> 
<p style="margin-left:0cm;"><span style="color:#000000;">一些常用的命令：</span></p> 
<p style="margin-left:0cm;">?或者help ：打印支持所有的命令</p> 
<p style="margin-left:0cm;">version：查看版本</p> 
<p style="margin-left:0cm;">? xxx命令 ：打印xxx命令的使用规则（相当于man）</p> 
<p style="margin-left:0cm;">pri/:打印环境变量</p> 
<p style="margin-left:0cm;">set :设置环境变量</p> 
<p style="margin-left:0cm;">ping :测试网络连通性</p> 
<p style="margin-left:0cm;">reset :复位CPU</p> 
<p style="margin-left:0cm;">loady:(使用串口下载代码到内存中)</p> 
<p style="margin-left:0cm;">md: 查看内存数据  比如：md.b 0x02023400 查看0x02023400有多少字节</p> 
<p style="margin-left:0cm;"> cp ：内存拷贝(复制数据从内存到另一个内存cp 0x02043400  0x40000000  0x10)</p> 
<p style="margin-left:0cm;">bdinfo: 查看配置信息</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267383">2.5Bootloader </a>启动的两个阶段</strong></h3> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">1.Bootloader </span></strong><span style="color:#000000;">第一阶段的功能：</span><br><strong><span style="color:#000000;">1) </span></strong><span style="color:#000000;">硬件设备初始化。</span><br><strong><span style="color:#000000;">2) </span></strong><span style="color:#000000;">为加载 </span><strong><span style="color:#000000;">Bootloader </span></strong><span style="color:#000000;">的第二阶段代码准备 </span><strong><span style="color:#000000;">RAM </span></strong><span style="color:#000000;">空间。</span><br><strong><span style="color:#000000;">3) </span></strong><span style="color:#000000;">设置 </span><strong><span style="color:#000000;">CPU </span></strong><span style="color:#000000;">的速度、时钟频率及终端控制寄存器</span><br><strong><span style="color:#000000;">4) </span></strong><span style="color:#000000;">初始化内存控制器</span><br><strong><span style="color:#000000;">5) </span></strong><span style="color:#000000;">复制 </span><strong><span style="color:#000000;">Bootloader </span></strong><span style="color:#000000;">的第二阶段代码到 </span><strong><span style="color:#000000;">RAM </span></strong><span style="color:#000000;">空间中。</span><br><strong><span style="color:#000000;">6) </span></strong><span style="color:#000000;">设置好栈。</span><br><strong><span style="color:#000000;">7) </span></strong><span style="color:#000000;">跳转到第二阶段代码的 </span><strong><span style="color:#000000;">C </span></strong><span style="color:#000000;">入口点</span></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">2.Bootloader </span></strong><span style="color:#000000;">第二阶段的功能：</span><br><strong><span style="color:#000000;">1) </span></strong><span style="color:#000000;">初始化本阶段要使用的硬件设备。</span><br><strong><span style="color:#000000;">2) </span></strong><span style="color:#000000;">检测系统内存映射（ </span><strong><span style="color:#000000;">memory map</span></strong><span style="color:#000000;">）。</span><br><strong><span style="color:#000000;">3) </span></strong><span style="color:#000000;">将内核映像和根文件系统映像从 </span><strong><span style="color:#000000;">FLASH</span></strong><span style="color:#000000;">上读到 </span><strong><span style="color:#000000;">RAM</span></strong><span style="color:#000000;">空间中。</span><br><strong><span style="color:#000000;">4) </span></strong><span style="color:#000000;">为内核设置启动参数。</span><br><strong><span style="color:#000000;">5) </span></strong><span style="color:#000000;">调用内核。</span></p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267384">3. linux</a>内核</strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267385">3.1</a>内核功能：</strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">linux</span><span style="color:#000000;">下一切皆文件，当然linux内核也是，是由3万多个文件组成的内核，这3万多个文件共同完成五大功能：</span></p> 
<ol><li><span style="color:#000000;">进程管理（cpu)  </span></li><li><span style="color:#000000;">内存管理（内存）</span></li><li><span style="color:#000000;">设备管理（驱动）</span></li><li><span style="color:#000000;">网络管理（网络协议tcp/ip）</span></li><li><span style="color:#000000;">文件系统管理（vfs)</span></li></ol> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267386">3.2linux</a>目录介绍</strong></h3> 
<p style="margin-left:0cm;"><span style="color:#000000;">arch:(</span><span style="color:#000000;">分为了三类文件 ，第一类为公用的文件，第二类是具体芯片相关的mach开头的，第三类是系列公共文件plat开头的)目录是架构相关的</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">block:</span><span style="color:#000000;">块设备文件(u盘，硬盘)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">crypto:</span><span style="color:#000000;">目录是一些加密算法相关的c代码</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Documentation:</span><span style="color:#000000;">目录说明文档，是关于linux系统的各个部分的一个详细的说明文档</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">drivers:</span><span style="color:#000000;">目录是重点设备驱动</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">fs:</span><span style="color:#000000;">文件系统实现</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">init:</span><span style="color:#000000;">目录初始化(linux系统c程序的一个入口系统运行起来第一个运行起来的第一个进程就是里边的main.c)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">ipc:</span><span style="color:#000000;">进程间的通信Linux支持多进程通信进程间通信相关的机制都在此目录</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">kernel:</span><span style="color:#000000;">真正的和硬件无关的放在这里(其实kernel分为两部分，一部分是和硬件相关的内容(arch/arm/kernel)，一部分是和硬件无关的内容)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">lib:</span><span style="color:#000000;">跟硬件无关的库函数都放在此目录</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">mm:</span><span style="color:#000000;">内存管理相关的支持文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">net:</span><span style="color:#000000;">各种网络通信协议相关的文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">samples:</span><span style="color:#000000;">示例程序</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">scripts:</span><span style="color:#000000;">存放的都是脚本文件(内核配置会用的)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">security:</span><span style="color:#000000;">系统支撑安全的一些相关代码</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">sound:</span><span style="color:#000000;">声卡驱动</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">tools:</span><span style="color:#000000;">编译内核所需要的一些工具</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">usr:</span><span style="color:#000000;">用户程序</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Kconfig:</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    make menuconfig</span><span style="color:#000000;">是检索所有目录中的Kconfig生成菜单的。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    kconfig:</span><span style="color:#000000;">内核地图</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Kconfig </span><span style="color:#000000;">入口点：顶层目录Kconfig</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">COPYLNG:</span><span style="color:#000000;">是记录版权信息的</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    CREDITS:</span><span style="color:#000000;">光荣板信息(也就是哪些对内核做过贡献)</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    Kbuild:</span><span style="color:#000000;">编译内核的一些相关脚本</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    Kconfig:</span><span style="color:#000000;">内核的菜单建立内核配置菜单的一个相关文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    MAINTAINERS:</span><span style="color:#000000;">记录了内核的每一个部分有哪些人员在维护</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    Makefile:</span><span style="color:#000000;">记录内核文件的依赖关系以及如何编译的哪些需要编译如何连接</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    README:</span><span style="color:#000000;">一些说明信息</span></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267387">3.3</a>内核编译/烧写过程</strong></h3> 
<p style="margin-left:0cm;">1.在顶层目录修改makefile，指定交叉编译工具</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">2.makefile只会编译目录下.config文件内指定的内容，所以我们对内核裁剪只需要修改.config文件就可以了,但是直接修改.config文件非常麻烦，于是就提供了一个图形化菜单给用户使用，在菜单内进行配置，配置完成自动生成.config文件</p> 
<p style="margin-left:0cm;">3.具体配置步骤</p> 
<p style="margin-left:0cm;">make menuconfig  //使用图形化界面修改.config，使用时要把字体调小</p> 
<p style="margin-left:0cm;">如果make menuconfig出现错误就执行如下命令</p> 
<p style="margin-left:0cm;">1.apt-cache search ncurses</p> 
<p style="margin-left:0cm;">2.apt-get install libncurses5-dev</p> 
<p style="margin-left:0cm;">然后进去图形化界面去掉一个内核保护选项（内核的一个保护机制）：</p> 
<p style="margin-left:0cm;">System Type --&gt;</p> 
<p style="margin-left:0cm;">         [ ] Support TrustZone-enabled Trusted Execution Environment</p> 
<p style="margin-left:0cm;">4.可以对内核进行裁剪和添加：</p> 
<p style="margin-left:0cm;"><span style="color:#000000;">裁剪：就是在图形化界面上不选择那个选项，当时就不会编译</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">添加：</span></p> 
<p style="margin-left:0cm;">第一步：写一个驱动代码放在drivers/char/中；</p> 
<p style="margin-left:0cm;">第二步：在kconfig文件中加选项；</p> 
<p style="margin-left:0cm;">第三步：在Makefile中把自己写的加里面；</p> 
<p style="margin-left:0cm;">第四步：进顶层，进入图形化界面，选择刚才添加的驱动；</p> 
<p style="margin-left:0cm;">第五步：这个时候就可以在.config中找到自己添加的驱动程序:文字中的 y 表示选择进内核。 m表示编成模块。 n 表示不选择</p> 
<p style="margin-left:0cm;">5. make  编译内核   编译之后生成的arch/arm/boot 下的zImage</p> 
<p style="margin-left:0cm;">6. make zImage  // 生成内核镜像</p> 
<p style="margin-left:0cm;">7. 烧写</p> 
<p style="margin-left:0cm;">（1）将烧写脚本文件fush_uimage拷贝到  arch/arm/boot(或者直接在arch/arm/boot  目录终端输入 dd iflag=dsync oflag=dsync if=./zImage of=/dev/sdb seek=1057)</p> 
<p style="margin-left:0cm;">（2）执行脚本把镜像文件烧写到SD卡</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267388">4.</a>文件系统</strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267389">4.1</a>介绍：</strong></h3> 
<ol><li><span style="color:#000000;">包括根文件系统和建立于 </span><span style="color:#000000;">FLASH </span><span style="color:#000000;">内存设备之上的文件系统。里</span><br><span style="color:#000000;">面包含了 </span><span style="color:#000000;">LINUX </span><span style="color:#000000;">系统能够运行所必须的应用程序、库等，比如可以</span><br><span style="color:#000000;">给用户提供操作 </span><span style="color:#000000;">LINUX </span><span style="color:#000000;">的控制界面和 </span><span style="color:#000000;">shell </span><span style="color:#000000;">程序、动态连接和程序运</span><br><span style="color:#000000;">行时需要的 </span><span style="color:#000000;">glibc </span><span style="color:#000000;">或 </span><span style="color:#000000;">uClibc </span><span style="color:#000000;">库等。</span></li><li>linux内核运行之后需要挂接一个文件系统，相当于电脑的硬盘，用来存储程序，为了开发方便，所以我们挂接了一个网络文件系统</li></ol> 
<p style="margin-left:0cm;"><span style="color:#000000;">3.</span> <span style="color:#000000;">根文件系统目录结构介绍</span></p> 
<table border="1" cellspacing="0"><tbody><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/bin </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">必备的用户命令，例如 </span><span style="color:#000000;">ls</span><span style="color:#000000;">、 </span><span style="color:#000000;">cp </span><span style="color:#000000;">等</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/sbin </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">必备的系统管理员命令，例如 </span><span style="color:#000000;">ifconfig</span><span style="color:#000000;">、 </span><span style="color:#000000;">reboot </span><span style="color:#000000;">等</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/dev </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">设备文件，例如 </span><span style="color:#000000;">mtdblock0</span><span style="color:#000000;">、 </span><span style="color:#000000;">tty1 </span><span style="color:#000000;">等</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/etc </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">系统配置文件，包括启动文件，例如 </span><span style="color:#000000;">inittab </span><span style="color:#000000;">等</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/lib </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">必要的链接库，例如 </span><span style="color:#000000;">C </span><span style="color:#000000;">链接库、内核模块</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/home </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">普通用户主目录</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/root </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">root </span><span style="color:#000000;">用户主目录</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/usr/bin </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">非必备的用户程序，例如 </span><span style="color:#000000;">find</span><span style="color:#000000;">、 </span><span style="color:#000000;">du </span><span style="color:#000000;">等</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/usr/sbin </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">非必备的管理员程序，例如 </span><span style="color:#000000;">chroot</span><span style="color:#000000;">、 </span><span style="color:#000000;">inetd </span><span style="color:#000000;">等</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/usr/lib </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">库文件</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/var </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">守护程序和工具程序所存放的可变，例如日志文件</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/proc</span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">用来提供内核与进程信息的虚拟文件系统，由内核自动生成目录下的<br> 内容</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/sys</span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">用来提供内核与设备信息的虚拟文件系统，由内核自动生成目录下的<br> 内容</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/mnt </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">文件系统挂接点，用于临时安装文件系统</span></p> </td></tr><tr><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">/tmp </span></p> </td><td style="width:150pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">临时性的文件，重启后将自动清除</span></p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"><br>  </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267390">4.2 </a>搭建一个文件系统：</strong></h3> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><span style="color:#000000;">我们使用的是一个名为</span><strong><span style="color:#000000;">busybox</span></strong><strong><span style="color:#000000;">的工具制作根文件。</span></strong><span style="color:#000000;">BusyBox </span><span style="color:#000000;">是一个集成了一百多个最常用 </span><span style="color:#000000;">linux </span><span style="color:#000000;">命令和工具的软件。</span><span style="color:#000000;">BusyBox </span><span style="color:#000000;">包含了一些简单的工具，例如 </span><span style="color:#000000;">ls</span><span style="color:#000000;">、 </span><span style="color:#000000;">cat </span><span style="color:#000000;">和 </span><span style="color:#000000;">echo </span><span style="color:#000000;">等等，还包含了一些更大、更复杂的工具，例 </span><span style="color:#000000;">grep</span><span style="color:#000000;">、 </span><span style="color:#000000;">find</span><span style="color:#000000;">、</span><span style="color:#000000;">mount </span><span style="color:#000000;">以及 </span><span style="color:#000000;">telnet</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">步骤：</span></p> 
<ol><li><span style="color:#000000;">拷贝 </span><strong><span style="color:#000000;">busybox </span></strong><span style="color:#000000;">源码包到虚拟机个人文件夹</span></li><li><span style="color:#000000;">解压源码包</span></li><li><span style="color:#000000;">进入解压的文件夹 </span><strong><span style="color:#000000;">busybox-1.21.1 </span></strong><span style="color:#000000;">进行安装选项配置  执行</span><span style="color:#ff0000;">make menuconfig</span></li><li><span style="color:#000000;">设置共享库:</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">Busybox Settings ---&gt;<br> Build Options ---&gt;<br>    [*] Build shared libbusybox</span></p> 
<ol><li><span style="color:#000000;">指定交叉编译链（注意 </span><strong><span style="color:#000000;">arm-linux-</span></strong><span style="color:#000000;">后面不要有空格）</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">Busybox Settings ---&gt;<br> Build Options ---&gt;<br>     () Cross Compiler prefix (NEW)</span></p> 
<ol><li><span style="color:#000000;">设置安装路径（路径可以自己指定，就是接下来会安装生成的根文件系统，习惯上目录层次不要太深，方便之后使用）</span></li><li><span style="color:#ff0000;">Busybox Settings ---&gt;<br>   Installation Options ("make install" behavior) ---&gt;<br>       (./install) BusyBox installation prefix(NEW)</span></li><li><span style="color:#000000;">添加模块指令</span><strong><span style="color:#000000;">make menuconfig</span></strong><span style="color:#000000;">à</span> <strong><span style="color:#000000;">Linux Module Utilities</span></strong></li><li><span style="color:#000000;">编译安装</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">#make &amp;&amp; make install</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">安装完成之后就会在刚才配置菜单当中指定的路径下找到生成的根文件系统目录 </span><span style="color:#000000;">rootfs</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">10.</span> <span style="color:#000000;">复制命令的动态库： 由于配置 </span><strong><span style="color:#000000;">busybox </span></strong><span style="color:#000000;">时候采用动态链接方式编译，所以，要把它所依赖的动态库文件复制到安装目录 </span><strong><span style="color:#000000;">rootfs</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">11.</span> <span style="color:#000000;">删除不必要的静态库，在根文件系统 </span><span style="color:#000000;">rootfs/lib </span><span style="color:#000000;">目录执行：</span><br><span style="color:#ff0000;"># rm lib/*.a –f</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">12. </span><span style="color:#000000;">创建其他目录， 生成完整根文件系统目录结构</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">mkdir dev etc/init.d home proc sys root opt tmp var –p</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">13. </span><span style="color:#000000;">创建系统启动必要的设备节点</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    (1)</span> <span style="color:#000000;">/dev/console </span><span style="color:#000000;">控制台</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">    (2)</span> <span style="color:#000000;">/dev/null </span><span style="color:#000000;">万能的垃圾桶</span></p> 
<p style="margin-left:0cm;">    <span style="color:#000000;">在“ 根文件系统”（这里对应 </span><strong><span style="color:#000000;">rootfs</span></strong><span style="color:#000000;">） 创建设备节点</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;"># mknod dev/console c 5 1<br> # mknod dev/null c 1 3</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">14. </span><span style="color:#000000;">构建 </span><strong><span style="color:#000000;">etc </span></strong><span style="color:#000000;">目录下的系统配置文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">1.</span><span style="color:#000000;">创建fstab文件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">作用：这个文件描述系统中各种文件系统的信息。一般而言，应用程序仅读取这个文件，而不</span><br><span style="color:#000000;">对它进行写操作。对它的维护是系统管理员的工作。在这个文件中，每个文件系统用一行来描述，在每一行中，用空格或 </span><span style="color:#000000;">TAB </span><span style="color:#000000;">符号来分隔各个字段，文件中以</span><span style="color:#000000;">#</span><span style="color:#000000;">开头的行是注释信息。</span><span style="color:#000000;">Fstab </span><span style="color:#000000;">文件中的纪录的排序十分重要。因为 </span><span style="color:#000000;">fsck</span><span style="color:#000000;">， </span><span style="color:#000000;">mount </span><span style="color:#000000;">或 </span><span style="color:#000000;">umount </span><span style="color:#000000;">等程序在做它们的工作时会按此顺序进行</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">(1)cp /etc/fstab ./etc</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">(2)</span><span style="color:#000000;">修改 </span><span style="color:#000000;">fstab </span><span style="color:#000000;">文件内容为以下（注意类型顺序和每两个单词之间都是tab键的）</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;"># device mount-point              type       options   dump   fsck      order<br> proc            /proc     proc      defaults        0    0<br> tmpfs     /tmp     tmpfs   defaults       0   0<br> sysfs      /sys      sysfs     defaults  0   0<br> tmpfs    /dev       tmpfs    defaults  0   0</span></p> 
<ol><li><span style="color:#000000;">创建 </span><strong><span style="color:#000000;">inittab </span></strong><span style="color:#000000;">文件</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#ff0000;"># cp /xyd/busybox-1.21.1/examples/inittab ./etc/<br> # vim etc/inittab</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">修改 </span><span style="color:#000000;">inittab </span><span style="color:#000000;">文件内容为以下：</span><br><span style="color:#000000;">::sysinit:/etc/init.d/rcS </span><span style="color:#000000;">启动系统初始化文件</span><span style="color:#000000;">/etc/init.d/rcS</span><br><span style="color:#000000;">console::askfirst:-/bin/sh </span><span style="color:#000000;">在串口终端启动 </span><span style="color:#000000;">askfirst </span><span style="color:#000000;">动作的 </span><span style="color:#000000;">shell</span><br><span style="color:#000000;">::ctrlaltdel:/sbin/reboot </span><span style="color:#000000;">当按下 </span><span style="color:#000000;">Ctrl+Alt+Delete </span><span style="color:#000000;">组合键时， </span><span style="color:#000000;">init </span><span style="color:#000000;">重启执行程</span><br><span style="color:#000000;">序</span><br><span style="color:#000000;">::shutdown:/bin/umount -a –r </span><span style="color:#000000;">关机时运行 </span><span style="color:#000000;">umount </span><span style="color:#000000;">命令卸载所有的文件系统，如</span><br><span style="color:#000000;">果卸载失败，试图以只读方式重新挂载</span></p> 
<ol><li><span style="color:#000000;">创建 </span><strong><span style="color:#000000;">etc/init.d/rcS </span></strong><span style="color:#000000;">文件， 添加内容如下：</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#000000;">Vim </span><strong><span style="color:#000000;">etc/init.d/rcS</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">内容：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">#!/bin/sh </span><span style="color:#000000;">声明 </span><span style="color:#000000;">shell </span><span style="color:#000000;">脚本类型， 使用 </span><span style="color:#000000;">busybox </span><span style="color:#000000;">的 </span><span style="color:#000000;">shell<br> mount –a </span><span style="color:#000000;">将文件 </span><span style="color:#000000;">/etc/fstab </span><span style="color:#000000;">中指明的文件挂载到对应的</span><br><span style="color:#000000;">挂载点</span><br><span style="color:#000000;">mkdir /dev/pts<br> mount -t devpts devpts /dev/pts<br> echo /sbin/mdev &gt; /proc/sys/kernel/hotplug </span><span style="color:#000000;">热插拔事件时产生设备节点的支持</span><br><span style="color:#000000;">mdev -s<br> /bin/hostname XYD</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">然后给</span><span style="color:#000000;">rcS </span><span style="color:#000000;">文件添加执行权限：</span><strong><span style="color:#ff0000;">chmod +x etc/init.d/rcS</span></strong></p> 
<ol><li><span style="color:#000000;">创建 </span><strong><span style="color:#000000;">etc/profile </span></strong><span style="color:#000000;">文件</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#000000;">Vim </span><strong><span style="color:#000000;">etc/profile</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">添加内容：</span></strong></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">USER="`id -un`"<br> LOGNAME=$USER<br> PS1='[\u@\h \W]# '<br> PATH=$PATH<br> HOSTNAME=`/bin/hostname`<br> export USER LOGNAME PS1 PATH</span></p> 
<ol><li><span style="color:#000000;">实现提示符功能还需要两个文件的支持，拷贝虚拟机 </span><span style="color:#000000;">linux </span><span style="color:#000000;">目录的 </span><span style="color:#000000;">etc/ group </span><span style="color:#000000;">和</span><br><span style="color:#000000;">etc/passwd </span><span style="color:#000000;">的文件到根文件系统</span><br><span style="color:#ff0000;"># cp /etc/group /etc/passwd ./etc/<a name="_Toc511200679"></a></span></li></ol> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267391">5.NFS</a>文件系统服务的搭建<a name="_Toc511200677"></a></strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267392">5.1 </a>NFS概念：</strong></h3> 
<p style="margin-left:0cm;">NFS（NetWork Filesystem System）可以用于不同操作系统之间通过网络传输文件，在嵌入式开发领域，NFS可以用于主机与嵌入式设备之前无缝传输文件，由于嵌入式设备的存储空间普遍较为有限，因此也可以用此工具扩展嵌入式设备的存储空间。</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267393">5.2</a>工作原理：</strong></h3> 
<p style="margin-left:0cm;">NFS服务是基于客户机/服务器模式，NFS服务器是提供输出文件（共享文件）的计算机。NFS客户端是访问输出文件的计算机，它可以将输出目录挂载到自己系统中的某个目录中，然后像访问本地文件一样去访问NFS服务器中的输出文件。</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267394">5.3 NFS</a>服务的搭建</strong></h3> 
<ol><li>安装nfs服务：sudo apt-get install nfs-kernel-server  nfs-common</li><li>修改配置文件：</li></ol> 
<p style="margin-left:0cm;">sudo vim /etc/exports</p> 
<p style="margin-left:0cm;">注：“exports”文件用于配置NFS服务器中输出的共享目录</p> 
<p style="margin-left:0cm;">修改内容如下：</p> 
<p style="margin-left:0cm;">/root/rootfs  *(rw,sync,no_root_squash,no_subtree_check)//<strong><span style="color:#ff0000;">中间空格必须是</span><span style="color:#ff0000;">Tab</span></strong><strong><span style="color:#ff0000;">键</span></strong></p> 
<p style="margin-left:0cm;">注：/root/rootfs为<span style="color:#252525;">与</span><span style="color:#252525;">nfs</span><span style="color:#252525;">服务客户端共享的目录，可自行创建，这个路径必须为绝对路径。</span></p> 
<p style="margin-left:0cm;">*：允许所有的网段访问，也可以使用具体的IP</p> 
<p style="margin-left:0cm;">192.168.1.* 指定网段，在该网段中的用户可以挂载</p> 
<p style="margin-left:0cm;">ro : 只读</p> 
<p style="margin-left:0cm;">rw：挂接此目录的客户端对该共享目录具有读写权限</p> 
<p style="margin-left:0cm;">sync：资料同步写入内存和硬盘</p> 
<p style="margin-left:0cm;">no_root_squash：root用户具有对根目录的完全管理访问权限。</p> 
<p style="margin-left:0cm;">no_subtree_check：不检查父目录的权限</p> 
<ol><li>重启nfs服务和rpcbind 服务</li></ol> 
<p style="margin-left:0cm;">                 sudo /etc/init.d/nfs-kernel-server  restart</p> 
<p style="margin-left:0cm;"> sudo /etc/init.d/rpcbind  restart</p> 
<ol><li><span style="color:#000000;">设置 </span><strong><span style="color:#000000;">NFS </span></strong><span style="color:#000000;">开机自动启动：</span><span style="color:#ff0000;">chkconfig nfs on</span></li><li><strong><span style="color:#00b050;">设置虚拟机网络 </span></strong><strong><span style="color:#00b050;">IP</span></strong><strong><span style="color:#00b050;">（注意虚拟机、物理机、开发板 </span></strong><strong><span style="color:#00b050;">linux </span></strong><strong><span style="color:#00b050;">内核的 </span></strong><strong><span style="color:#00b050;">IP </span></strong><strong><span style="color:#00b050;">为同一号段）</span></strong></li></ol> 
<p style="margin-left:0cm;"><span style="color:#ff0000;"># service network restart<br> # ifconfig</span></p> 
<ol><li><span style="color:#000000;">虚拟机网络设置，配置为“桥接”：</span> <span style="color:#000000;">VMware </span><span style="color:#000000;">右下角网络适配器</span><span style="color:#000000;">—</span><span style="color:#000000;">选择“ 设置” </span><span style="color:#000000;">—</span><span style="color:#000000;">更改为“ 桥接模式”</span></li><li><span style="color:#000000;">虚拟机 </span><strong><span style="color:#000000;">VMware </span></strong><span style="color:#000000;">选项卡“编辑” </span><strong><span style="color:#000000;">--</span></strong><span style="color:#000000;">“</span><span style="color:#000000;">虚拟网络编辑器” </span><strong><span style="color:#000000;">--</span></strong><span style="color:#000000;">桥接设置桥接到物理网络</span></li><li><span style="color:#000000;">重启网络</span><br><span style="color:#000000;"># service network restart</span></li><li><span style="color:#000000;">关闭防火墙</span><br><span style="color:#000000;"># service iptables stop</span></li><li><span style="color:#000000;">重启 </span><strong><span style="color:#000000;">NFS </span></strong><span style="color:#000000;">服务</span><br><span style="color:#000000;"># service nfs restart</span></li><li><span style="color:#000000;">挂接不成功时记得查看根文件系统 </span><strong><span style="color:#000000;">etc </span></strong><span style="color:#000000;">目录下的 </span><strong><span style="color:#000000;">rcS</span></strong><span style="color:#000000;">、 </span><strong><span style="color:#000000;">fstab</span></strong><span style="color:#000000;">、 </span><strong><span style="color:#000000;">inittab </span></strong><span style="color:#000000;">等文件是否有执</span><br><span style="color:#000000;">行权限，如果没有，加执行权限</span></li><li><span style="color:#000000;">配置物理机网络连接</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#000000;">windows </span><span style="color:#000000;">打开网络和共享中心</span><span style="color:#000000;">—</span><span style="color:#000000;">更改适配器设置</span><span style="color:#000000;">--</span><span style="color:#000000;">以太网</span><span style="color:#000000;">/</span><span style="color:#000000;">本地连接</span><span style="color:#000000;">--</span><span style="color:#000000;">右击属性</span><span style="color:#000000;">--IPv4</span><br><span style="color:#000000;">将 </span><span style="color:#000000;">IP </span><span style="color:#000000;">设置为虚拟机同一号段，这里是 </span><span style="color:#00b050;">192.168.15.16</span></p> 
<ol><li><span style="color:#000000;">关闭 </span><strong><span style="color:#000000;">windows </span></strong><span style="color:#000000;">防火墙</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#000000;">网络共享中心 </span><span style="color:#000000;">— Windows </span><span style="color:#000000;">防火墙 </span><span style="color:#000000;">— </span><span style="color:#000000;">启用或关闭 </span><span style="color:#000000;">windows </span><span style="color:#000000;">防火墙 </span><span style="color:#000000;">--</span><br><span style="color:#000000;">关闭 </span><span style="color:#000000;">— </span><span style="color:#000000;">确定（在控制面板也可以找到）</span></p> 
<ol><li><span style="color:#000000;">进入 </span><strong><span style="color:#000000;">uboot </span></strong><span style="color:#000000;">修改 </span><strong><span style="color:#000000;">bootargs</span></strong><strong><span style="color:#000000;">：这时打开超级终端后，启动流程就是</span></strong><span style="color:#000000;">uboot--kernel--</span><span style="color:#000000;">根文件系统，但是此时我们需要对uboot进行修改，能够挂载上文件系统</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">#set bootargs 'noinitrd root=/dev/nfs nfsroot=192.168.15.2:/xyd/rootfs ip=192.168.15.5:192.16<br> 8.15.2:192.168.15.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0 lcd=S70'<br> # save<br> # reset</span>  </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267395"></a><a name="_Toc511200680">5.4 NFS</a>服务的测试</strong></h3> 
<ol><li>检查客户端和服务端的网络是否连通（ping命令）</li></ol> 
<p style="margin-left:0cm;">ping  服务主机IP</p> 
<ol><li>查看服务端的共享目录</li></ol> 
<p style="margin-left:0cm;">showmount  -e  服务主机IP</p> 
<ol><li>将与nfs服务客户端共享的目录挂载到本地</li></ol> 
<p style="margin-left:0cm;">mount -t nfs -o nolock 服务主机IP: /root/rootfs  /mnt </p> 
<p style="margin-left:0cm;">注：/mnt 指定将共享目录挂载的路径, -t nfs 指定挂在协议是那台ip地址的主机，mount nfs时，默认选项包括文件锁，依赖于portmap提供的动态端口分配功能，因此需要解锁，因此一般直接在指令中直接加上-o nolock。</p> 
<ol><li>通过访问/mnt即可访问共享目录的内容</li><li>取消挂载</li></ol> 
<p style="margin-left:0cm;">umount  /mnt</p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267396">6.</a>内核模块化编程</strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267397">6.1 </a>模块化介绍    </strong></h3> 
<p style="margin-left:0cm;">在c语言中：按照功能将一个.c文件拆分为多个.c以及.h文件</p> 
<p style="margin-left:0cm;">在单片机的时候：对应每一个外设都有一个.c和.h文件，.c文件写模块的初始化以及功能函数，.h文件对应函数的声明，如果想使用该外设只需包含其头文件即可。</p> 
<p style="margin-left:0cm;">但是在驱动里不同：内核的功能很强大，如果我们想将自己的某一个模块加载到内核，由两种方式:</p> 
<ol><li>修改内核源码重新编译烧写内核(模块功能稳定)—静态编译</li><li>以模块的方式动态加载(调试阶段)，重启后无效—动态编译</li></ol> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267398">6.2 </a>静态编译到内核步骤：比如说写个led的驱动</strong></h3> 
<ol><li>首先在/driver/char下写驱动程序</li><li>在kconfig中添加驱动选项</li><li>在Makefile中添加自己写的驱动程序，等待图形化选择编译</li><li>回到顶层，进入图形化界面，选择刚才添加的驱动</li></ol> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267399">6.3 </a>动态编译到内核的步骤：</strong></h3> 
<ol><li>我们需要把.c文件给编译成.ko文件，然后需要把模块动态的加载到内核中（insmod xx.ko）</li><li>当然动态编译 具有还原性，可以卸载(rmmod xx.ko)</li></ol> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267400">6.4 </a>单模块框架：</strong></h3> 
<p style="margin-left:0cm;">驱动文件：</p> 
<ol><li>头文件：</li></ol> 
<p style="margin-left:0cm;">#include &lt;linux/module.h&gt;//模块相关函数的头文件声明</p> 
<p style="margin-left:0cm;">#include&lt;linux/kernel.h&gt;//printk函数的声明头文件</p> 
<ol><li>加载函数模板: static int __init (函数名) (void)</li><li>卸载函数模板：static void __exit (函数名)(void)</li><li>声明:</li></ol> 
<p style="margin-left:0cm;">module_init -指定加载函数</p> 
<p style="margin-left:0cm;">module_exit -指定卸载函数</p> 
<p style="margin-left:0cm;">MODULE_LICENSE("GPL");//声明开源协议</p> 
<p style="margin-left:0cm;">其他:</p> 
<p style="margin-left:0cm;">MODULE_AUTHOR // 声明作者</p> 
<p style="margin-left:0cm;">MODULE_DESCRIPTION // 对模块简单的描述</p> 
<p style="margin-left:0cm;">MODULE_VERSION // 声明模块的版本</p> 
<p style="margin-left:0cm;">MODULE_ALIAS // 模块的别名</p> 
<p style="margin-left:0cm;">MODULE_DEVICE_TABLE // 告诉用户空间这个模块所支持的设备</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267401">6.5</a>编写Makefile:</strong></h3> 
<p style="margin-left:0cm;">(1)指定自己的内核路径KERN_DIR = /root/linux-3.5</p> 
<p style="margin-left:0cm;">(2)编译文件名obj-m += first_module.o</p> 
<p style="margin-left:0cm;">最后：编译后将.ko文件拷贝到文件系统，执行insmod xxx.ko 、lsmod、rmmod xx.ko</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267402">6.6</a>多模块：</strong></h3> 
<p style="margin-left:0cm;">分为两种（第一种模块2调用模块1中函数）（第二种多个模块编译为1个模块）</p> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc51267403">6.6.1</a>模块2调用模块1中函数</strong></h4> 
<ol><li>模块2 需要声明外部函数</li><li>模块1要声明该函数可以被外部调用 EXPORT_SYMBOL( )</li><li>先加载模块1 再加载模块2</li><li>先卸载模块2 再卸载模块1</li></ol> 
<h4 style="margin-left:0cm;"><strong><a name="_Toc51267404">6.6.2</a>多个模块编译为1个模块</strong></h4> 
<ol><li>如果一个模块只是单纯调用外部函数只需声明即可</li></ol> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267405">6.7 </a>向模块传参:</strong></h3> 
<p style="margin-left:0cm;">介绍：加载模块的时候动态传递参数//  insmod xxx.ko 1 2 3</p> 
<p style="margin-left:0cm;">（1）module_param(par,int,S_IRUGO|S_IWUSR);</p> 
<p style="margin-left:0cm;">（2）module_param(str,charp,S_IRUGO);</p> 
<p style="margin-left:0cm;">（3）module_param_array(arr,int,&amp;num,S_IRUGO);</p> 
<p style="margin-left:0cm;">（1）和（2）传递变量和字符串；（3）是传递数组，这里的第二个参数就是数组的类型，第三个参数是存放传入参数元素数量，使用时候这里要写一个变量的地址</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267406"></a><a name="_Toc5074">7.</a>驱动简介</strong></h2> 
<p style="margin-left:0cm;"><strong><span style="color:#c0504d;">目的</span></strong><span style="color:#ffff00;">：</span>驱动：让硬件可以工作，驱动不会主动执行都是被调用然后做初始化工作让硬件可以工作</p> 
<p style="margin-left:0cm;"><strong><span style="color:#c0504d;">怎么办：</span></strong>为了让硬件在linux下运行，我们采用的办法就是将硬件注册为一个文件节点，供应用层读写操作      </p> 
<p style="margin-left:0cm;"><strong><span style="color:#c0504d;">分类：</span></strong>字符设备；块设备；网络设备。</p> 
<p style="margin-left:0cm;">这里详解字符设备：</p> 
<p style="margin-left:0cm;">1.杂项设备注册</p> 
<p style="margin-left:0cm;">2.早期经典设备注册</p> 
<p style="margin-left:0cm;">3.Linux2.6设备注册</p> 
<p style="margin-left:0cm;">注：对于每一个设备来说，都经历3个过程：</p> 
<p style="margin-left:0cm;">1.设备号（主，次）的审请</p> 
<p style="margin-left:0cm;">2.注册添加设备（设备号与设备绑定）</p> 
<p style="margin-left:0cm;">3.创建设备节点</p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267407"></a><a name="_Toc22543"></a><a name="_Toc32459">8.</a>那么，对于杂项设备来说：</strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267408"></a><a name="_Toc26300"></a><a name="_Toc21606">8.1</a>注册函数：int misc_register(struct miscdevice *misc);</strong></h3> 
<p style="margin-left:0cm;">核心结构体：</p> 
<p style="margin-left:0cm;">struct miscdevice  {<!-- --></p> 
<p style="margin-left:0cm;">         int minor;//次设备号（0-254），取255系统自动分配</p> 
<p style="margin-left:0cm;">         const char *name;//设备节点名，自动生成在/dev/下</p> 
<p style="margin-left:0cm;">         const struct file_operations *fops;//文件操作集</p> 
<p style="margin-left:0cm;">         struct list_head list;</p> 
<p style="margin-left:0cm;">         struct device *parent;</p> 
<p style="margin-left:0cm;">         struct device *this_device;</p> 
<p style="margin-left:0cm;">         const char *nodename;</p> 
<p style="margin-left:0cm;">         umode_t mode;</p> 
<p style="margin-left:0cm;">};</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267409"></a><a name="_Toc10485"></a><a name="_Toc11551">8.2</a>注销函数：int misc_deregister(struct miscdevice *misc)</strong></h3> 
<p style="margin-left:0cm;">int misc_deregister(struct miscdevice *misc)</p> 
<p style="margin-left:0cm;">{<!-- --></p> 
<p style="margin-left:0cm;">         int i = DYNAMIC_MINORS - misc-&gt;minor - 1;</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">         if (WARN_ON(list_empty(&amp;misc-&gt;list)))</p> 
<p style="margin-left:0cm;">                   return -EINVAL;</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">         mutex_lock(&amp;misc_mtx);</p> 
<p style="margin-left:0cm;">         list_del(&amp;misc-&gt;list);</p> 
<p style="margin-left:0cm;">         device_destroy(misc_class, MKDEV(10, misc-&gt;minor));</p> 
<p style="margin-left:0cm;">         if (i &lt; DYNAMIC_MINORS &amp;&amp; i &gt;= 0)</p> 
<p style="margin-left:0cm;">                   clear_bit(i, misc_minors);</p> 
<p style="margin-left:0cm;">         mutex_unlock(&amp;misc_mtx);</p> 
<p style="margin-left:0cm;">         return 0;</p> 
<p style="margin-left:0cm;">可以看出device_destroy就是摧毁设备节点，那个节点取决于传的次设备号，因为主设备号已经确定，设备号和设备节点是对应的。</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267410"></a><a name="_Toc22074">8.3</a>特点：</strong></h3> 
<p style="margin-left:0cm;">1.主设备号指定为10，次设备号取值范围0-254；</p> 
<p style="margin-left:0cm;">2.一个注册函数完成所以步骤，即设备号的申请、设备号和设备的绑定、自动创建设备节点在/dev/下；</p> 
<p style="margin-left:0cm;">3.调用注册函数每次只能申请一个设备号，即我觉得在驱动不同种类的设备时用杂项设备注册发适用</p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267411"></a><a name="_Toc30349">9.</a>那么，对于早期经典设备来说：</strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267412"></a><a name="_Toc20837">9.1</a>注册函数:int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</strong></h3> 
<p style="margin-left:0cm;">major:主设备名0-255</p> 
<p style="margin-left:0cm;">name:设备名，而非设备节点名。在/proc/device下</p> 
<p style="margin-left:0cm;">fops:文件操作集</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267413"></a><a name="_Toc12501">9.2</a>注销函数：static inline void unregister_chrdev(unsigned int major, const char *name)</strong></h3> 
<p style="margin-left:0cm;">major：主设备号，需要打印出来，手动创建设备节点时候需要</p> 
<p style="margin-left:0cm;">name：设备名，而非设备节点名，和注册函数的参数一样</p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267414"></a><a name="_Toc6216">9.3</a>特点：</strong></h3> 
<p style="margin-left:0cm;"><strong>1.</strong><strong>主设备号取值范围为0-255</strong><strong>，取0</strong><strong>系统自动分配，一旦调用注册函数，会自动分配一个当前没有贝使用的主设备号，以及该主设备号下的所以次设备号</strong></p> 
<p style="margin-left:0cm;"><strong>都被申请占用</strong></p> 
<p style="margin-left:0cm;"><strong>2.</strong><strong>一个注册函数完成了申请设备号、设备号与设备绑定，但是没有自动的创建设备节点，需要自己mknod /dev/xxx c </strong><strong>主设备号 </strong><strong>次设备号</strong></p> 
<p style="margin-left:0cm;"><strong>3. </strong><strong>没有使用一个结构体进行封装，没有做一个整体描述</strong></p> 
<p style="margin-left:0cm;"><strong>4. </strong><strong>注销释放的是设备名而非设备节点，因为设备节点是自己手动创建的</strong></p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267415"></a><a name="_Toc3992"></a><a name="_Toc2568">10.</a>那么，对于linux2.6版本注册来说：</strong></h2> 
<p style="margin-left:0cm;">两个核心结构体先摆在这里：</p> 
<p style="margin-left:0cm;">struct cdev {<!-- --></p> 
<p style="margin-left:0cm;">     struct kobject kobj;</p> 
<p style="margin-left:0cm;">         struct module *owner;//指定为THIS_MODULE,表示这个模块</p> 
<p style="margin-left:0cm;">         const struct file_operations *ops;//设备节点管理的文件指针集</p> 
<p style="margin-left:0cm;">         struct list_head list;//链表上下一个设备</p> 
<p style="margin-left:0cm;">         dev_t dev;//完整设备号</p> 
<p style="margin-left:0cm;">         unsigned int count;//申请设备号的数量</p> 
<p style="margin-left:0cm;">};</p> 
<p style="margin-left:0cm;">struct device *device_create(</p> 
<p style="margin-left:0cm;">struct class *cls, // 设备的类 类指针 让那个类来管理</p> 
<p style="margin-left:0cm;">struct device *parent, // NULL</p> 
<p style="margin-left:0cm;">dev_t devt, // 主设备号和次设备号的组合 32 位，主 12 位 次 20 位</p> 
<p style="margin-left:0cm;">void *drvdata, // NULL,设备私有数据</p> 
<p style="margin-left:0cm;">const char *fmt, … /*可以格式化的 fmt:/dev/下的节点名*/</p> 
<p style="margin-left:0cm;">);</p> 
<p style="margin-left:0cm;"><strong><span style="color:#00b050;">申请设备号、注册添加设备</span><span style="color:#00b050;">(</span></strong><strong><span style="color:#00b050;">申请的设备号，和设备号绑定对应</span><span style="color:#00b050;">)</span></strong><strong><span style="color:#00b050;">、创建节点是分开做的，而非一个注册函数解决的。</span></strong></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267416"></a><a name="_Toc9186"></a><a name="_Toc8961">10.1</a>首先，申请设备号：</strong></h3> 
<p style="margin-left:0cm;">那么就需要将主设备号和次设备号整合成32位的，也需要从32位的完整设备号取出主设备号和次设备号，有相关的函数</p> 
<p style="margin-left:0cm;">MKDEV(ma,mi)//已知次设备号合成完整设备号</p> 
<p style="margin-left:0cm;">MpAJOR(dev)//从完整设备号提取主设备号</p> 
<p style="margin-left:0cm;">MINOR(dev)//从完整设备号提取次设备号</p> 
<p style="margin-left:0cm;">动态设备号申请：int alloc_chrdev_region(dev_t  *dev,  unsigned  baseminor,  unsigned count,  const  char *name)</p> 
<p style="margin-left:0cm;">dev:存放分配到的第一个设备(包括主次设备号)的指针，函数成功后会自动分配</p> 
<p style="margin-left:0cm;">baseminor：要分配起始次设备号（次设备号的起始值）</p> 
<p style="margin-left:0cm;">count：连续的次设备号数量</p> 
<p style="margin-left:0cm;">name：设备名，不需要和/dev的设备文件名相同</p> 
<p style="margin-left:0cm;">静态设备号的分配：int register_chrdev_region(dev_t from, unsigned count, const char *name)</p> 
<p style="margin-left:0cm;">from：自己指定的完整设备号</p> 
<p style="margin-left:0cm;">count：连续的次设备号数量</p> 
<p style="margin-left:0cm;">name：设备名，不需要和/dev的设备文件名相同</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267417"></a><a name="_Toc11971"></a><a name="_Toc23085">10.2</a>然后，添加设备：</strong></h3> 
<p style="margin-left:0cm;">添加设备之前需要先核心结构初始化void cdev_init(struct cdev *cdev,const struct file_operations *fops)  </p> 
<p style="margin-left:0cm;">设备注册函数：int cdev_add(struct cdev *p,dev_t dev,unsigned count) </p> 
<p style="margin-left:0cm;">参数p：已经初始化的核心结构指针</p> 
<p style="margin-left:0cm;">参数dev：起始设备号(包含主次设备号)</p> 
<p style="margin-left:0cm;">参数count：连续次设备号的数量</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267418"></a><a name="_Toc21394"></a><a name="_Toc15057">10.3</a>最后，自动创建设备节点：</strong></h3> 
<p style="margin-left:0cm;">首先呢，需要创建class类:class_create(ower,name)</p> 
<p style="margin-left:0cm;">ower:类的所有者，我们一般会写THIS_MODULE代表这个模块</p> 
<p style="margin-left:0cm;">name：类的名字，自己随机取的</p> 
<p style="margin-left:0cm;">然后，创建设备节点：(struct device *device_create(struct class *class,struct device *parent,dev_t devt,void *drvdata,const char *fmt,.....))</p> 
<p style="margin-left:0cm;">class:上面创建类的返回值，是个指针</p> 
<p style="margin-left:0cm;">parent:父设备，一般没有就写NULL</p> 
<p style="margin-left:0cm;">devt：完整的设备名</p> 
<p style="margin-left:0cm;">drvdata:驱动数据，也可以是NULL,一般为NULL</p> 
<p style="margin-left:0cm;">fmt,...可变参数，用来生成/dev/目录下的设备文件名</p> 
<p style="margin-left:0cm;">函数成功返回一个指向节点描述结构体的指针</p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267419"></a><a name="_Toc32447"></a><a name="_Toc8480">10.4</a>前面的一系列的操作完整的完成的设备驱动程序，然后就是注销</strong></h3> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">1.摧毁设备节点 void device_destroy(struct class *class,dev_t  devt)</p> 
<p style="margin-left:0cm;">2.摧毁类 void class_destroy(struct class *cls)</p> 
<p style="margin-left:0cm;">3注销cdev结构空间 void cdev_del(struct cdev *p)  </p> 
<p style="margin-left:0cm;">4释放设备号 void unregister_chrdev_region(dev_t from,  unsigned  int count)</p> 
<p style="margin-left:0cm;"><strong>这个注销的顺序不能随意</strong></p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267420"></a><a name="_Toc12951">11.</a>理解</strong></h2> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">那么我们该如果选择三种注册方式呢？</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">其实，看上去都可以，但是如果选择不当会很复杂，比如说，我想同种类的设备，像多个</span><span style="color:#000000;">usb,</span></strong><strong><span style="color:#000000;">用早期经典注册方式和</span><span style="color:#000000;">linux2.6</span></strong><strong><span style="color:#000000;">注册方式就比较利落些，因为它可以在同一个主设备下开多个次设备，这样我们就可以创建多个设备节点使用同一个设备</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">疑问，设备节点，驱动，硬件设备是如何关联到一起的呢？</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">百度后得知：这是通过设备号实现的，包括主设备号和次设备号。当我们创建一个设备节点时需要指定主设备号和次设备号。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">应用程序通过名称访问设备，而设备号指定了对应的驱动程序和对应的设备。主设备号标识设备对应的驱动程序，次设备号</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">由内核使用，用于确定设备节点所指设备。</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">什么叫做设备节点？</span></strong></p> 
<p style="margin-left:0cm;"><strong><span style="color:#000000;">连接内核与用户层的枢纽，是设备是接到对应哪种接口的哪个</span><span style="color:#000000;">ID </span></strong><strong><span style="color:#000000;">上。</span></strong></p> 
<p style="margin-left:0cm;"> </p> 
<h2 style="margin-left:0cm;"><strong><a name="_Toc51267421">附录</a></strong></h2> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267422">整个系统的启动流程图：</a></strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a5/b3/8Ge8ADYo_o.png"></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267423">u-boot</a>分区结构：</strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/8d/DPEAXKSD_o.png"></p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267424">SD</a>卡的详细分区：</strong></h3> 
<p style="text-align:center;"><img alt="" height="126" src="https://images2.imgbox.com/39/7d/l9q4UJ79_o.png" width="554"></p> 
<p style="margin-left:0cm;"> </p> 
<h3 style="margin-left:0cm;"><strong><a name="_Toc51267425">exynos4412</a>的内部存储图：</strong></h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c2/ef/YNKsvGrH_o.png"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/177fa85907831f00d03f117b2a8fd75e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构(python) —— 【15: NB三人组小结】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1eaced630b83e660c9fd91d222ecf148/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">react中如何修改state值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>