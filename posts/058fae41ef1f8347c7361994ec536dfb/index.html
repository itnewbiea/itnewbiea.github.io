<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机科学与未解决的难题,NP（未解难题）_百度百科 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机科学与未解决的难题,NP（未解难题）_百度百科" />
<meta property="og:description" content="NP的英文全称是Non-deterministic Polynomial的问题，即多项式复杂程度的非确定性问题。
中文名
外文名
NP学 科
理论信息学
收 录
P/NP问题是在理论信息学中计算复杂度理论领域里至今没有解决的问题，它被“克雷数学研究所”(Clay Mathematics Institute, 简称CMI)在千禧年大奖难题中收录。P/NP问题中包含了复杂度类P与NP的关系。1971年史提芬·古克(Stephen A. Cook) 和 Leonid Levin 相对独立的提出了下面的问题，即是否两个复杂度类P和NP是恒等的(P=NP?)。
NPP和NP
编辑
语音
复杂度类P包含所有那些可以由一个确定型图灵机在多项式表达的时间内解决的问题；类NP由所有其肯定解可以在给定正确信息的多项式时间内验证的决定问题组成，或者等效的说，那些解可以在非确定图灵机上在多项式时间内找出的问题的集合。很可能，计算理论最大的未解决问题就是关于这两类的关系的。
在2002年对于100研究者的调查，61人相信答案是否定的，9个相信答案是肯定的，22个不确定，而8个相信该问题可能所接受的公理独立，所以不可能证明或证否。对于正确的解答，有一个1,000,000美元的奖励。
NP-完全问题(或者叫NPC)的集合在这个讨论中有重大作用，它们可以大致的被描述为那些在NP中最不像在P中的。(确切定义细节请参看NP-完全)理论计算机科学家相信P、NP和NPC类之间的关系如图中所示，其中P和NPC类不交。
假设P ≠ NP的复杂度类的图解，如P = NP则三个类相同。本质上，P = NP问题问道：如果是/不是问题的正面答案可以很快验证，其答案是否也可以很快计算？这里有一个给你找点这个问题的感觉的例子。给定一个大数Y，我们可以问Y是否是复合数。例如，我们可能问53308290611是否有非平凡的因子。回答是肯定的，虽然手工找出一个因子很麻烦。从另一个方面讲，如果有人声称答案是“对，因为224737可以整除53308290611&#34;,则我们可以很快用一个除法来验证。验证一个数是除数比首先找出除数来简单得多。用于验证一个正面答案所需的信息也称为证书。所以我们的结论是，给定 正确的证书，问题的正面答案可以很快的(也就是，在多项式时间内)验证，而这就是这个问题属于NP的原因。虽然这个特定的问题，最近被证明为也在P类中(参看下面的关于&#34;质数在P中&#34;的参考)，这一点也不明显，而且有很多类似的问题相信不属于类P。
限制到是/不是问题并没有改变问题；即使我们允许更复杂的答案，最后的问题(是否FP = FNP)是等价的。
NP形式化定义
编辑
语音
更正式一些，一个决定问题是一个取一些字符串为输入并要求输出为是或否的问题。若有一个算法(譬如图灵机，或一个LISP或Pascal的程序并有无限的内存)能够在最多nk步内对一个串长度为n的输入给出正确答案，其中k是某个不依赖于输入串的常数，则我们称该问题可以在多项式时间内解决，并且将它置入类P。直观的讲，我们将P中的问题视为可以较快解决的问题。
假设有一个算法A(w,C)取两个参数，一个串w，也就是我们的决定问题的输入串，而另一个串C是“建议证明”，并且使得A在最多nk步之内产生“是/否”答案(其中n是w的长度而k不依赖于w)。进一步假设
w是一个答案为“是”的例子，当且仅当，存在C使得A(w,C)返回“是”。
则我们称这个问题可以在非决定性多项式时间内解决，且将它放入NP类。我们把算法A作为一个所建议的证明的检验器，它运行足够快。(注意缩写NP代表“Non-deterministic(非确定性)Polynomial(多项式)”而不是代表“Non-Polynomial(非多项式)。
NPNP完全
编辑
语音
要解决P = NP问题，NP完全的概念非常有用。不严格的讲，NP完全问题是NP类中“最难”的问题，也就是说它们是最可能不属于P类的。这是因为任何NP中的问题可以在多项式时间内变换成为任何特定NP完全问题的一个特例。例如，旅行商问题的判定问题版本是NP完全的。所以NP中的任何问题的任何特例可以在多项式时间内机械地转换成旅行商问题的一个特例。所以若旅行商问题被证明为在P内，则P = NP旅行商问题是很多这样的NP完全的问题之一。若任何一个NP完全的问题在P内，则可以推出P = NP。不幸的是，很多重要的问题被证明为NP完全，但没有一个有已知快速的算法。
NP更难问题
编辑
语音
虽然是否P=NP还是未知的，在P之外的问题是已经知道存在的。寻找国际象棋或围棋最佳走法(在n乘n棋盘上)是在指数时间内完成的。因为可以证明P ≠ EXPTIME(指数时间)，这些问题位于P之外，所以需要比多项式时间更多的时间。判定Presburger算术中的命题是否为真的问题更加困难。Fischer和Rabin于1974年证明每个决定Presburger命题的真伪性的算法有最少2^(2^cn))的运行时间，c为某个常数。这里，n是Presburger命题的长度。因此，该命题已知需要比指数时间更多的运行时间。不可判定问题是更加困难的，例如停机问题。它们无法在任何给定时间内解决。
NPP真的容易处理吗
上面所有的讨论假设了P表示“容易”而“不在P中”表示“困难”。这是一个在复杂度理论中常见而且有一定准确性的假设，它在实践中却不总是真的，原因包括如下几点：
它忽略了常数因子。一个需要101000n时间的问题是属于P的(它是线性时间的)，但是事实上完全无法处理。一个需要10-100002n时间的问题不是在P中的(它是指数时间的)，但是对于n 取值直到几千时还是很容易处理的。
它忽略了指数的大小。一个时间复杂度n1000属于P，但是很难对付。已经证明在P中存在需要任意大的指数的问题(参看时间等级定理)。一个时间复杂度2n/1000的问题不属于P，但对与n直到几千还是容易应对的。
它只考虑了最坏情况的复杂度。可能现实世界中的有些问题在多数时候可以在时间n中解决，但是很偶尔你会看到需要时间2n的特例。这个问题可能有一个多项式的平均时间，但最坏情况是指数式的，所以该问题不属于P。
它只考虑确定性解。可能有一个问题你可以很快解决如果你可以接受出现一点误差的可能，但是确保正确的答案会难得多。这个问题不会属于P，虽然事实上它可以很快求解。这实际上是解决属于NP而还不知道是否属于P的问题的一个办法(参看RP， BPP)。
新的诸如量子电脑这样的计算模型，可能可以快速的解决一些尚未知道是否属于P的问题；但是，没有一个它们已知能够解决的问题是NP完全的。不过，必须注意到P和NP问题的定义是采用象图灵机这样的经典计算模型的属于表述的。所以，即使一个量子计算机算法被发现能够有效的解决一个NP完全问题，我们只是有了一个快速解决困难问题的实际方法，而不是数学类P和NP相等的证明。
NP计算机科学家为什么认为P ≠ NP" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/058fae41ef1f8347c7361994ec536dfb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T15:32:58+08:00" />
<meta property="article:modified_time" content="2021-07-08T15:32:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机科学与未解决的难题,NP（未解难题）_百度百科</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>NP的英文全称是Non-deterministic Polynomial的问题，即多项式复杂程度的非确定性问题。</p> 
 <p>中文名</p> 
 <p>外文名</p> 
 <p>NP学    科</p> 
 <p>理论信息学</p> 
 <p>收    录</p> 
 <p>P/NP问题是在理论信息学中计算复杂度理论领域里至今没有解决的问题，它被“克雷数学研究所”(Clay Mathematics Institute, 简称CMI)在千禧年大奖难题中收录。P/NP问题中包含了复杂度类P与NP的关系。1971年史提芬·古克(Stephen A. Cook) 和 Leonid Levin 相对独立的提出了下面的问题，即是否两个复杂度类P和NP是恒等的(P=NP?)。</p> 
 <p>NPP和NP</p> 
 <p>编辑</p> 
 <p>语音</p> 
 <p>复杂度类P包含所有那些可以由一个确定型图灵机在多项式表达的时间内解决的问题；类NP由所有其肯定解可以在给定正确信息的多项式时间内验证的决定问题组成，或者等效的说，那些解可以在非确定图灵机上在多项式时间内找出的问题的集合。很可能，计算理论最大的未解决问题就是关于这两类的关系的。</p> 
 <p>在2002年对于100研究者的调查，61人相信答案是否定的，9个相信答案是肯定的，22个不确定，而8个相信该问题可能所接受的公理独立，所以不可能证明或证否。对于正确的解答，有一个1,000,000美元的奖励。</p> 
 <p>NP-完全问题(或者叫NPC)的集合在这个讨论中有重大作用，它们可以大致的被描述为那些在NP中最不像在P中的。(确切定义细节请参看NP-完全)理论计算机科学家相信P、NP和NPC类之间的关系如图中所示，其中P和NPC类不交。</p> 
 <p>假设P ≠ NP的复杂度类的图解，如P = NP则三个类相同。本质上，P = NP问题问道：如果是/不是问题的正面答案可以很快验证，其答案是否也可以很快计算？这里有一个给你找点这个问题的感觉的例子。给定一个大数Y，我们可以问Y是否是复合数。例如，我们可能问53308290611是否有非平凡的因子。回答是肯定的，虽然手工找出一个因子很麻烦。从另一个方面讲，如果有人声称答案是“对，因为224737可以整除53308290611",则我们可以很快用一个除法来验证。验证一个数是除数比首先找出除数来简单得多。用于验证一个正面答案所需的信息也称为证书。所以我们的结论是，给定 正确的证书，问题的正面答案可以很快的(也就是，在多项式时间内)验证，而这就是这个问题属于NP的原因。虽然这个特定的问题，最近被证明为也在P类中(参看下面的关于"质数在P中"的参考)，这一点也不明显，而且有很多类似的问题相信不属于类P。</p> 
 <p>限制到是/不是问题并没有改变问题；即使我们允许更复杂的答案，最后的问题(是否FP = FNP)是等价的。</p> 
 <p>NP形式化定义</p> 
 <p>编辑</p> 
 <p>语音</p> 
 <p>更正式一些，一个决定问题是一个取一些字符串为输入并要求输出为是或否的问题。若有一个算法(譬如图灵机，或一个LISP或Pascal的程序并有无限的内存)能够在最多nk步内对一个串长度为n的输入给出正确答案，其中k是某个不依赖于输入串的常数，则我们称该问题可以在多项式时间内解决，并且将它置入类P。直观的讲，我们将P中的问题视为可以较快解决的问题。</p> 
 <p>假设有一个算法A(w,C)取两个参数，一个串w，也就是我们的决定问题的输入串，而另一个串C是“建议证明”，并且使得A在最多nk步之内产生“是/否”答案(其中n是w的长度而k不依赖于w)。进一步假设</p> 
 <p>w是一个答案为“是”的例子，当且仅当，存在C使得A(w,C)返回“是”。</p> 
 <p>则我们称这个问题可以在非决定性多项式时间内解决，且将它放入NP类。我们把算法A作为一个所建议的证明的检验器，它运行足够快。(注意缩写NP代表“Non-deterministic(非确定性)Polynomial(多项式)”而不是代表“Non-Polynomial(非多项式)。</p> 
 <p>NPNP完全</p> 
 <p>编辑</p> 
 <p>语音</p> 
 <p>要解决P = NP问题，NP完全的概念非常有用。不严格的讲，NP完全问题是NP类中“最难”的问题，也就是说它们是最可能不属于P类的。这是因为任何NP中的问题可以在多项式时间内变换成为任何特定NP完全问题的一个特例。例如，旅行商问题的判定问题版本是NP完全的。所以NP中的任何问题的任何特例可以在多项式时间内机械地转换成旅行商问题的一个特例。所以若旅行商问题被证明为在P内，则P = NP旅行商问题是很多这样的NP完全的问题之一。若任何一个NP完全的问题在P内，则可以推出P = NP。不幸的是，很多重要的问题被证明为NP完全，但没有一个有已知快速的算法。</p> 
 <p>NP更难问题</p> 
 <p>编辑</p> 
 <p>语音</p> 
 <p>虽然是否P=NP还是未知的，在P之外的问题是已经知道存在的。寻找国际象棋或围棋最佳走法(在n乘n棋盘上)是在指数时间内完成的。因为可以证明P ≠ EXPTIME(指数时间)，这些问题位于P之外，所以需要比多项式时间更多的时间。判定Presburger算术中的命题是否为真的问题更加困难。Fischer和Rabin于1974年证明每个决定Presburger命题的真伪性的算法有最少2^(2^cn))的运行时间，c为某个常数。这里，n是Presburger命题的长度。因此，该命题已知需要比指数时间更多的运行时间。不可判定问题是更加困难的，例如停机问题。它们无法在任何给定时间内解决。</p> 
 <p>NPP真的容易处理吗</p> 
 <p>上面所有的讨论假设了P表示“容易”而“不在P中”表示“困难”。这是一个在复杂度理论中常见而且有一定准确性的假设，它在实践中却不总是真的，原因包括如下几点：</p> 
 <p>它忽略了常数因子。一个需要101000n时间的问题是属于P的(它是线性时间的)，但是事实上完全无法处理。一个需要10-100002n时间的问题不是在P中的(它是指数时间的)，但是对于n 取值直到几千时还是很容易处理的。</p> 
 <p>它忽略了指数的大小。一个时间复杂度n1000属于P，但是很难对付。已经证明在P中存在需要任意大的指数的问题(参看时间等级定理)。一个时间复杂度2n/1000的问题不属于P，但对与n直到几千还是容易应对的。</p> 
 <p>它只考虑了最坏情况的复杂度。可能现实世界中的有些问题在多数时候可以在时间n中解决，但是很偶尔你会看到需要时间2n的特例。这个问题可能有一个多项式的平均时间，但最坏情况是指数式的，所以该问题不属于P。</p> 
 <p>它只考虑确定性解。可能有一个问题你可以很快解决如果你可以接受出现一点误差的可能，但是确保正确的答案会难得多。这个问题不会属于P，虽然事实上它可以很快求解。这实际上是解决属于NP而还不知道是否属于P的问题的一个办法(参看RP， BPP)。</p> 
 <p>新的诸如量子电脑这样的计算模型，可能可以快速的解决一些尚未知道是否属于P的问题；但是，没有一个它们已知能够解决的问题是NP完全的。不过，必须注意到P和NP问题的定义是采用象图灵机这样的经典计算模型的属于表述的。所以，即使一个量子计算机算法被发现能够有效的解决一个NP完全问题，我们只是有了一个快速解决困难问题的实际方法，而不是数学类P和NP相等的证明。</p> 
 <p>NP计算机科学家为什么认为P ≠ NP</p> 
 <p>多数计算机科学家相信P≠NP。该信念的一个关键原因是经过数十年对这些问题的研究，没有人能够发现一个NP完全问题的多项式时间算法。而且，人们早在NP完全的概念出现前就开始寻求这些算法了(Karp的21个NP完全问题，在最早发现的一批中，有所有著名的已经存在的问题)。进一步地，P = NP这样的结果会导出很多惊人的结果，那些结果被相信是不成立的，例如NP = 余NP和P = PH。</p> 
 <p>也有这样论证的：问题较难求解(NP)但容易验证(P)，这和我们日常经验是相符的。</p> 
 <p>从另一方面讲，某些研究者认为我们过于相信P ≠ NP，而应该也去寻找P = NP的证明。例如，2002年中有这样的声明：</p> 
 <p>倾向P≠NP的主要论据是在穷尽搜索的领域完全没有本质进展。也就是说，以我的观点，一个很弱的论据。算法的空间是很大的，而我们只是在开始探索的起点。[ . . . ] 费马最後定理的解决也显示非常简单的[sic]问题可能只有用非常深刻的理论才能解决。</p> 
 <p>— Moshe Vardi，莱斯大学</p> 
 <p>过分依赖某种投机不是规划研究的一个好的导引。我们必须总是尝试每个问题的两个方向。偏见可能导致著名的数学家无法解决答案和他们的预计相反的著名问题，虽然他们发展了所有所需的方法。</p> 
 <p>— Anil Nerode, 康奈尔大学</p> 
 <p>关于证明的难度的结果</p> 
 <p>虽然百万美元的奖金和大量投入巨大却没有实质性结果的研究足以显示该问题是困难的，还有一些形式化的结果证明为什么该问题可能很难解决。</p> 
 <p>最常被引用的结果之一设计神喻。假想你有一个魔法机器可以解决单个问题，例如决定一个给定的数字是否为质数，但可以瞬间解决这个问题。我们的新问题是，若我们被允许任意利用这个机器，是否存在我们可以在多项式时间内验证但无法在多项式时间内解决的问题。结果是，依赖于机器能解决的问题，P = NP和P ≠ NP二者都可以证明。这个结论的后果是，任何可以修改来证明该机器的存在性的结果不能解决问题。不幸的是，几乎所有经典的方法和大部分已知的方法可以这样修改(我们称它们在相对化)。</p> 
 <p>如果这还不算太糟的话，1993年Razborov和Rudich证明的一个结果表明，给定一个特定的可信的假设，在某种意义下“自然”的证明不能解决P = NP问题。[3] 这表明一些似乎最有希望的方法不太可能成功。随着更多这类的定理得到证明，该定理的可能证明有越来越多的陷阱要规避。</p> 
 <p>这实际上也是为什么NP完全问题有用的原因：若有一个多项式时间算法，或者没有一个这样的算法，对于NP完全问题存在，这将用一种相信不被上述结果排除在外的方法来解决P = NP问题。</p> 
 <p>NP多项式时间算法</p> 
 <p>没人知道多项式时间算法对于NP完全问题是否存在。但是如果这样的算法存在，我们已经知道其中的一些了。例如，下面的算法正确的接受了一个NP完全语言，但是没人知道通常它需要多久运行。它是一个多项式时间算法当且仅当P = NP。</p> 
 <p>// 接受NP完全语言的一个算法子集和。</p> 
 <p>//</p> 
 <p>// 这是一个多项式时间算法当且仅当P=NP。</p> 
 <p>//</p> 
 <p>// “多项式时间”表示它在多项式时间内返回“是”，若</p> 
 <p>// 结果是“是”，否则永远运行。</p> 
 <p>//</p> 
 <p>// 输入：S = 一个自然数的有限集</p> 
 <p>// 输出："是" 如果某个S的子集加起来等于0。</p> 
 <p>// 否则，它永远运行没有输出。</p> 
 <p>// 注意: "程序数P" 是你将一个整数P写为二进制，然后</p> 
 <p>// 将位串考虑为一个程序。</p> 
 <p>// 每个可能的程序都可以这样产生，</p> 
 <p>// 虽然多数什么也不做因为有语法错误。</p> 
 <p>//</p> 
 <p>FOR N = 1...infinity</p> 
 <p>FOR P = 1...N</p> 
 <p>以S为输入运行程序数P N步</p> 
 <p>IF 程序输出一个不同的整数的列表</p> 
 <p>AND 所有整数都在S中</p> 
 <p>AND 整数的和为0</p> 
 <p>THEN</p> 
 <p>OUTPUT "是" 并 停机</p> 
 <p>若P = NP，则这是一个接受一个NP完全语言的多项式时间算法。“接受”表示它在多项式时间内给出“是”的答案，但允许在答案是“否”的时候永远运行。</p> 
 <p>可能我们想要“解决”子集和问题，而不是仅仅“接受”子集和语言。这表示我们想要它总是停机并返回一个“是”或“否”的答案。是否存在任何可能在多项式时间内解决这个问题的算法，没有人知道。但是如果这样的算法存在，那么我们已经知道其中的一些了，只要将上面的算法中的IF语句替换成下面的语句：</p> 
 <p>IF 程序输出一个完整的数学证明</p> 
 <p>AND 证明的每一步合法</p> 
 <p>AND 结论是S确实有(或者没有)一个和为0的子集</p> 
 <p>THEN</p> 
 <p>OUTPUT "是" (或者"不是"如果那被证明了)并停机</p> 
 <p>NP逻辑表述</p> 
 <p>编辑</p> 
 <p>语音</p> 
 <p>P=NP问题可以用逻辑命题的特定类的可表达性的术语来重新表述。所有P中的语言可以用一阶逻辑加上最小不动点操作(实际上，这允许了递归函数的定义)来表达。类似地，NP是可以用存在性二阶逻辑来表达—也就是，在关系、函数、和子集上排除了全域量词的二阶逻辑。多项式等级，PH中的语言对应与所有的二阶逻辑。这样，“P是NP的真子集吗”这样的问题可以表述为“是否存在性二阶逻辑能够表达带最小不动点操作的一阶逻辑的所不能表达的语言”。</p> 
 <p>NP花絮</p> 
 <p>编辑</p> 
 <p>语音</p> 
 <p>普林斯顿大学计算机系楼将二进制代码表述的“P=NP?”问题刻进顶楼西面的砖头上。如果证明了P=NP，砖头可以很方便的换成表示“P=NP！”。[4]</p> 
 <p>康奈尔大学的Hubert Chen博士提供了这个玩笑式的P不等于NP的证明：“反证法。设P = NP。令y为一个P = NP的证明。证明y可以用一个合格的计算机科学家在多项式时间内验证，我们认定这样的科学家的存在性为真。但是，因为P = NP，该证明y可以在多项式时间内由这样的科学家发现。但是这样的发现还没有发生(虽然这样的科学家试图发现这样的一个证明)，我们得到矛盾。</p> 
 <p>词条图册</p> 
 <p>更多图册</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a572f75f1c3c4384932b8743c23f9243/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git工具下载项目失败怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08bf813009ab1b941ee0c5b3ecf1da0b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">干货篇 | 当CPU使用率达到100%该怎么办？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>