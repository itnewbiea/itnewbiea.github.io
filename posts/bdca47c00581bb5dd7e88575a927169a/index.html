<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;命名空间&lt;转&gt; - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;命名空间&lt;转&gt;" />
<meta property="og:description" content="熟练掌握C/C&#43;&#43;语言，熟悉Windows开发平台，能熟练运用MFC自主编开发出一些应用程序；
熟练掌握SQL语句，对数据库有很好的认识，能熟练使用SQL Server2000软件；
熟练掌握JAVA语言，熟悉J2ME对手机软件开发一定的基础；
深入理解面向对象的思想，并能熟练应用于具体的程序设计开发中；
熟悉Unix/Linux下C语言的编程以及常用的命令，熟悉汇编语言；
熟悉网络的TCP/IP、UDP等协议，能处理解决电脑系统软件常见的故障； C&#43;&#43; using namespace std 详解
所谓namespace，是指标识符的各种可见范围。C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。
一 ：
&lt;iostream&gt;和&lt;iostream.h&gt;是不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。
后缀为.h的头文件c&#43;&#43;标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c&#43;&#43;标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。
因此，当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c&#43;&#43;实现；当使用&lt;iostream&gt;的时候，该头文件没有定义全局命名空间，必须使用namespacestd；这样才能正确使用cout。
二：
所谓namespace，是指标识符的各种可见范围。
C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。
由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：
1、直接指定标识符。例如std::ostream而不是ostream。完整语句如下：
std::cout &lt;&lt; std::hex&lt;&lt; 3.4&lt;&lt; std::endl;
2、使用using关键字。
using std::cout;
using std::endl;
以上程序可以写成
cout &lt;&lt; std::hex&lt;&lt; 3.4&lt;&lt; endl;
3、最方便的就是使用using namespace std;
例如：
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
using namespace std;
这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写:
cout &lt;&lt; hex&lt;&lt; 3.4&lt;&lt; endl;
因为标准库非常的庞大，所程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C&#43;&#43;代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。
所以就有了&lt;iostream.h&gt;和&lt;iostream&gt;等等这样的头文件，一个是为了兼容以前的C&#43;&#43;代码，一个是为了支持新的标准。
命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加&#34;.h&#34;
using namespace std 的用法
摘自
using namespacestd;用的并不少！ ---------------------------------------------------------------" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bdca47c00581bb5dd7e88575a927169a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-05-05T19:25:00+08:00" />
<meta property="article:modified_time" content="2010-05-05T19:25:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;命名空间&lt;转&gt;</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>熟练掌握C/C++语言，熟悉Windows开发平台，能熟练运用MFC自主编开发出一些应用程序；<br>熟练掌握SQL语句，对数据库有很好的认识，能熟练使用SQL Server2000软件；<br>熟练掌握JAVA语言，熟悉J2ME对手机软件开发一定的基础；<br>深入理解面向对象的思想，并能熟练应用于具体的程序设计开发中；<br>熟悉Unix/Linux下C语言的编程以及常用的命令，熟悉汇编语言；<br>熟悉网络的TCP/IP、UDP等协议，能处理解决电脑系统软件常见的故障； </p> 
 <p> </p> 
 <p>C++ using namespace std 详解<br>　所谓namespace，是指标识符的各种可见范围。C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。<br>一 ：</p> 
 <p>&lt;iostream&gt;和&lt;iostream.h&gt;是不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。</p> 
 <p>后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。</p> 
 <p>因此，当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现；当使用&lt;iostream&gt;的时候，该头文件没有定义全局命名空间，必须使用namespacestd；这样才能正确使用cout。</p> 
 <p>二：</p> 
 <p>所谓namespace，是指标识符的各种可见范围。</p> 
 <p>C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。</p> 
 <p>由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：</p> 
 <p>1、直接指定标识符。例如std::ostream而不是ostream。完整语句如下：</p> 
 <p>std::cout &lt;&lt; std::hex&lt;&lt; 3.4&lt;&lt; std::endl;</p> 
 <p>2、使用using关键字。</p> 
 <p>using std::cout;<br>using std::endl;</p> 
 <p>以上程序可以写成</p> 
 <p>cout &lt;&lt; std::hex&lt;&lt; 3.4&lt;&lt; endl;</p> 
 <p>3、最方便的就是使用using namespace std;</p> 
 <p>例如：</p> 
 <p>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>using namespace std;<br>这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写:</p> 
 <p>cout &lt;&lt; hex&lt;&lt; 3.4&lt;&lt; endl;</p> 
 <p>因为标准库非常的庞大，所程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。</p> 
 <p>        所以就有了&lt;iostream.h&gt;和&lt;iostream&gt;等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。</p> 
 <p>命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加".h"</p> 
 <p> </p> 
 <p> </p> 
 <p>using namespace std 的用法</p> 
 <p>摘自</p> 
 <p>using namespacestd;用的并不少！   <br>---------------------------------------------------------------</p> 
 <p>实际上就是告诉编译器，你类型是什么，在哪能找到。</p> 
 <p>常用的是using namespace std,就是说用C＋＋的标准名字空间。</p> 
 <p>你也可以引用你自己的名字空间。比如说：</p> 
 <p>import "C:\\MyTest\\test.tlb"<br>using namespace CMyTest</p> 
 <p>就可以引用CMyTest内的各个类型名</p> 
 <p>看C++ prime<br>---------------------------------------------------------------</p> 
 <p>声明该文件使用C++标准库吧！<br>比如<br>#include &lt;iostream&gt;<br>using namespace std;<br>void main()<br>{<!-- --><br>   cout&lt;&lt; "hello!"&lt;&lt; endl;<br>}</p> 
 <p>如果不用using namespace std;这句，那么<br>std::cout &lt;&lt; "hello!"&lt;&lt;endl;<br>这是名字空间的问题！具体参看有关书籍吧，新版的C++ 书应该都有介绍的！</p> 
 <p>---------------------------------------------------------------</p> 
 <p>using 指示符！<br>这是个名字空间问题，是标准C++引入的新概念！<br>具体在《C++Primer》第8.6节有详细说明！<br>---------------------------------------------------------------</p> 
 <p>因为标准库非常的庞大，所程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。</p> 
 <p>      所以就有了&lt;iostream.h&gt;和&lt;iostream&gt;等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。<br>---------------------------------------------------------------</p> 
 <p>名字空间，实质上也是为了方便程序在不同平台上正确的运行。<br>---------------------------------------------------------------</p> 
 <p>namespace是为了解决C++中的名字冲突而引入的。<br>什么是名字冲突呢？比如，在文件x.h中有个类MyClass,<br>在文件y.h中也有个类MyClass，而在文件z.cpp中要同时<br>引用x.h和y.h文件。显然，按通常的方法是行不能的，<br>那怎么办呢？引入namespace即可。例如：<br>      在x.h中的内容为<br>// x.h<br>namespace MyNamespace1<br>{<!-- --><br>   class MyClass<br>   {<!-- --><br>   public:<br>      void f();<br>   private:<br>      int m;<br>   }<br>};</p> 
 <p>      在y.h中的内容为<br>// y.h<br>namespace MyNamespace2<br>{<!-- --><br>   class MyClass<br>   {<!-- --><br>   public:<br>      void f();<br>   private:<br>      int m;<br>   }<br>};</p> 
 <p>   然后在z.cpp中引入x.h和y.h<br>// z.cpp<br>#include"x.h"   <br>#include"y.h"   </p> 
 <p>void z::f()<br>{<!-- --><br>   //声明一个文件x.h中类MyClass的实例x<br>   MyNamespace1::MyClass x;<br>    //声明一个文件x.h中类MyClass的实例x<br>   MyNamespace2::MyClass y;</p> 
 <p>   //调用文件x.h中的函数f<br>   x.f();<br>   //调用文件y.h中的函数f<br>   y.f();<br>}<br>      名字空间实质上是一个作用域。<br>      通过上面的一个实例应该知道名字空间的作用了吧</p> 
 <p>尽量不要使用using namespace std;VC++2005使用有感<br>Posted on 2007-11-06 20:28 Samson小天 阅读(1163) 评论(6) 编辑 收藏 网摘 所属分类:C++/C++.net<br>今天用了VISUAL C++写了个小程序(VS2005)，很简单很简单的，但是就是编译不通过<br>出现一个奇怪的问题：错误 1 error C2668: “max”: 对重载函数的调用不明确</p> 
 <p>最初代码如下</p> 
 <p>#include &lt;iostream&gt;<br>using namespace std;</p> 
 <p>template &lt;typename T&gt;<br>T max (T a,T b)<br>{<!-- --><br>return ((a&gt;b)?a:b);<br>}<br>void main()<br>{<!-- --><br>double x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>cout&lt;&lt;"Max number is"&lt;&lt;(max(x,y))&lt;&lt;endl;<br>cin&gt;&gt;x;<br>}</p> 
 <p>   我将这段代码放到VC++ 6.0下竟然通过了，程序运行也正常。这让我百思不得其解。后来终于弄明白了！<br>   其实在std命名空间下还有一个MAX函数，而且实现的功能也是一样的……我昏。利用转到定义功能可以看到微软是怎么写MAX函数的。这里为了不被鄙视就不贴微软的代码了。<br>   明白了为什么出现这个错误我们就改写代码如下：<br>#include &lt;iostream&gt;<br>using std::cin;<br>using std::cout;<br>using std::endl;</p> 
 <p>template &lt;typename T&gt;<br>T max (T a,T b)<br>{<!-- --><br>return ((a&gt;b)?a:b);<br>}<br>int main()<br>{<!-- --><br>double x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>cout&lt;&lt;"Max number is"&lt;&lt;(max(x,y))&lt;&lt;endl;<br>cin&gt;&gt;x;<br>}<br>   这是我比较推荐的做法，因为C++ PRIMER, EFFECTIVE C++上都是用这种方式的，但是谭浩强的书上都是一句usingnamespace std;就搞定，我觉得蛮简洁的就一直用了，没想到带来那么多的问题，以前在友元函数上还碰到莫名的错误呢。<br>   其实还有两个简单的解决方案，那就是把自己定义的函数改成其他的名字，或者直接用微软提供的函数。相信微软提供的效率绝对不会比我们写的低～<br>   好了，就写到这了。希望大家养成良好的编程习惯，^-^</p> 
 <p>很多C++程序员还在使用而不是用更新的标准的库。<br>这两者都有什么不同呢？首先，5年前我们就开始反对把.h符号继续用在标准的头<br>文件中。继续使用过时的规则可不是个好的方法。从功能性的角度来讲，<br>&lt;iostream&gt;包含了一系列模板化的I/O类，相反地&lt;iostream.h&gt;只仅仅是支持字符<br>流。另外，输入输出流的C++标准规范接口在一些微妙的细节上都已改进，因此，<br>&lt;iostream&gt;和&lt;iostream.h&gt;在接口和执行上都是不同的。最后，&lt;iostream&gt;的各组<br>成都是以STL的形式声明的，然而&lt;iostream.h&gt;的各组成都是声明成全局型的。</p> 
 <p>因为这些实质上的不同，你不能在一个程序中混淆使用这两个库。做为一种习<br>惯，在新的代码中一般使用&lt;iostream&gt;，但如果你处理的是过去编写的代码，为了<br>继承可以用继续用&lt;iostream.h&gt;旧保持代码的一致性。</p> 
 <p> </p> 
 <p>///</p> 
 <p>&lt;iostream&gt;表示你使用的是标注命名空间，也就是在程序开始应该有这么一句话<br>using namespace std ;<br>这是遵循c++标准的<br>&lt;iostream.h&gt;<br>则没有遵循c++标准<br><br>&lt;string.h&gt;是旧的C头文件，对应的是基于char*的字符串处理函数；<br>&lt;string&gt;是包装了std的C++头文件，对应的是新的strng类；<br>&lt;cstring&gt;是对应旧的C头文件的std版本。</p> 
 <p><br>在C++语言编写的程序中，变量和函数等的作用范围是有一定限制的。比如，在函数体中定义的一个临时变量就不可以在函数体外使用。为了解决变量和函数等的作用范围，在C++语言中引入了名空间的概念，并增加了关键字namespace和using  <br>         在一个名空间中可以定义一组变量和函数，这些变量和函数的作用范围一致，可以将这些变量和函数称为这个名空间的成员。  <br>         通过名空间，可以在同一个文件中使用相同的变量名或函数名，只要它们属于不同的名空间。另外，名空间可以使得代码操作具有相同名字但属于不同库的变量。而且，名空间也可以提高C语言与C++语言的兼容性。  <br>   <br>下面通过例程说明关键字namespace的用法。  <br>#include  &lt;conio.h&gt;  <br>#include  &lt;iostream.h&gt;  <br>namespace  car  //  名空间的定义  <br>{  <br>     int  model;  <br>     int  length;  <br>     int  width;  <br>}  <br>   <br>namespace  plane  <br>{  <br>     int  model;  <br>     namespace  size  //  名空间的嵌套  <br>     {  <br>         int  length;  <br>         int  width;  <br>     }  <br>}  <br>   <br>namespace  car  //  添加名空间的成员  <br>{  <br>     char  *  name;  <br>}  <br>   <br>namespace  c=car;  //  定义名空间的别名  <br>int  Time;  //  外部变量属于全局名空间  <br>   <br>void  main()  <br>{  <br>     car::length=3;  <br>     //  下面一句错误，故屏蔽掉  <br>     //  width=2;  //  对于非全局变量和当前有效临时变量应该指定名空间  <br>     plane::size::length=70;  <br>     cout&lt;&lt;"the  length  of  plane  is  "&lt;&lt;plane::size::length&lt;&lt;"m."&lt;&lt;endl;  <br>     cout&lt;&lt;"the  length  of  car  is  "&lt;&lt;car::length&lt;&lt;"m."&lt;&lt;endl;  <br>     //  使用名空间的别名  <br>     cout&lt;&lt;"the  length  of  c  is  "&lt;&lt;c::length&lt;&lt;"m."&lt;&lt;endl;  <br>     int  Time=1996;  //  临时变量，应区别于全局变量  <br>     ::Time=1997;  <br>     cout&lt;&lt;"Temp  Time  is  "&lt;&lt;Time&lt;&lt;endl;  <br>     cout&lt;&lt;"Outer  Time  is  "&lt;&lt;::Time&lt;&lt;endl;  <br>     //  使用关键字using  <br>     using  namespace  plane;  <br>     model=202;  <br>     size::length=93;  <br>     cout&lt;&lt;model&lt;&lt;endl;  <br>     cout&lt;&lt;size::length&lt;&lt;endl;  <br>     getch();  <br>}  <br>   <br>运行结果：  <br>the  length  of  plane  is  70m.  <br>the  length  of  car  is  3m.  <br>the  length  of  c  is  3m.  <br>Temp  Time  is  1996  <br>Outer  Time  is  1997  <br>   <br>说明：  <br>&amp;#8226;  从上面可以看出，名空间定义了一组变量和函数，它们具有相同的作用范围。对于不同的  <br>     名空间，可以定义相同的变量名或函数名，在使用的时候，只要在变量名或函数名前区分  <br>     开不同的名空间就可以了。  <br>&amp;#8226;  名空间可以被嵌套定义，使用时要逐级对成员用名空间限定符:  :来引用。  <br>&amp;#8226;  系统默认有一个全局名空间，它包含了所有的外部变量。这个名空间没有名字，引用这个  <br>     名空间里的变量时要使用名空间限定符:  :，前面没有名字。在不使用名空间的情况下，我  <br>     们知道，不可以在不同文件中定义相同名字的外部变量，这是因为它们属于同一个全局名  <br>     空间，名字不可以重复。  <br>&amp;#8226;  可以给名空间取一个别名。一般别名是一个比较短的名字，来简化编程。  <br>&amp;#8226;  在原有定义好的名空间的基础上，随时可以往里增加成员。  <br>   <br>&lt;&lt;using&gt;&gt;  <br>在前面的例程中可以看到，为了使用时的方便，又引入了关键字using。利用using声明可以在引用名空间成员时不必使用名空间限定符::。此外，关键字namespace和using的使用，对函数重载有一定的影响。  <br>   <br>下面通过例程进行具体说明。  <br>#include  &lt;conio.h&gt;  <br>#include  &lt;iostream.h&gt;  <br>namespace  car  //  名空间的定义  <br>{  <br>     void  ShowLength(double  len)  //  参数类型为d  o  u  b  l  e  <br>     {  <br>         cout&lt;&lt;"in  car  namespace:  "&lt;&lt;len&lt;&lt;endl;  <br>     }  <br>}  <br>   <br>namespace  plane  //  名空间的定义  <br>{  <br>     void  ShowLength(int  len)  //  参数类型为i  n  t  <br>     {    <br>         cout&lt;&lt;"in  plane  namespace:  "&lt;&lt;len&lt;&lt;endl;  <br>     }  <br>}  <br>   <br>void  main()  <br>{  <br>     using  namespace  car;  <br>     ShowLength(3);  <br>     ShowLength(3.8);  <br>     using  namespace  plane;  <br>     ShowLength(93);  <br>     ShowLength(93.75);  <br>     getch();  <br>}  <br>   <br>运行结果：  <br>in  car  namespace:  3  <br>in  car  namespace:  3.8  <br>in  plane  namespace:  93  <br>in  car  namespace:  93.75  <br>   <br>说明：  <br>         如果没有名空间的干扰，函数重载时选择规则将是非常简单。只要实参是double类型，则调用的是前面的函数；如果实参是int类型，则调用后面的函数。但是由于名空间的参与，就出现了上面的运行结果。所以在编程的时候一定要注意名空间对函数重载的影响。  <br>   <br>   <br>         应注意：调用函数时，如果实参和形参的数据类型实在没有办法完全匹配，可能会对实参进行适当的数据类型转换。比如，将char类型转换为int类型，或进一步将int类型转换为double类型。这种是将数据类型从简单往复杂转换，一般不会丢失信息。另外一种转换是反过来，将double类型转换为int类型，或进一步将int类型转换为char类型。这种是将数据类型从复杂往简单转换，可能会丢失部分信息。在调用函数的时候，不同的情况下，C++对上述两种转换的优先级是不同的。当引入了名空间后，则参与了上述优先级顺序的分配。</p> 
 <p> </p> 
 <p>全局空间最大的问题在于它本身仅有一个。在大的软件项目中，经常会有不少人把他们定义的名字都放在这个单一的空间中，从而不可避免地导致名字冲突。例如，假设library1.h定义了一些常量，其中包括：</p> 
 <p>const double lib_version = 1.204;<br>类似的，library2.h也定义了：<br>const int lib_version = 3;</p> 
 <p> 如果某个程序想同时包含library1.h和library2.h就会有问题。作为程序员，尽力使自己的程序库不给别人带来这些问题。例如，可预先想一些不大可能造成冲突的某种前缀，加在每个全局符号前。当然得承认，这样组合起来的标识符看起来不是那么令人舒服。</p> 
 <p>  另一个比较好的方法是使用c++namespace。namespace本质上和使用前缀的方法一样，只不过避免了别人总是看到前缀而已。所以，不要这么做：<br>const double sdmbook_version =2.0;     // 在这个程序库中, 每个符号以"sdm"开头<br>                                        // class sdmhandle { ... };<br>sdmhandle&amp;sdmgethandle();            // 为什么函数要这样声明？ <br>而要这么做：<br>namespace sdm {<!-- --><br>  const double book_version = 2.0;<br>  class handle { ... };<br>  handle&amp; gethandle();<br>}</p> 
 <p> 用户于是可以通过三种方法来访问这一名字空间里的符号：将名字空间中的所有符号全部引入到某一用户空间；将部分符号引入到某一用户空间；或通过修饰符显式地一次性使用某个符号：</p> 
 <p>void f1()<br>{<!-- --><br>  using namespacesdm;          // 使得sdm中的所有符号不用加修饰符就可以使用<br>  cout &lt;&lt;book_version;         // 解释为sdm::book_version<br>  ...<br>  handle h =gethandle();       // handle解释为sdm::handle,<br>                                // gethandle解释为sdm::gethandle<br> ...                           <br>}<br>void f2()<br>{<!-- --><br>  usingsdm::book_version;       // 使得仅book_version不用加修饰符就可以使用<br>  cout &lt;&lt;book_version;          // 解释为sdm::book_version<br>  ...<br>  handle h =gethandle();        // 错误! handle和gethandle<br>                                 // 都没有引入到本空间<br> ...                            <br>}<br>void f3()<br>{<!-- --><br>  cout &lt;&lt;sdm::book_version;     // 使得book_version在本语句有效<br> ...                           <br>  double d =book_version;       // 错误! book_version不在本空间<br>  handle h =gethandle();        // 错误! handle和gethandle都没有引入到本空间<br> ...                           </p> 
 <p>}</p> 
 <p> 有些名字空间没有名字。这种没命名的名字空间一般用于限制名字空间内部元素的可见性。<br>  名字空间带来的最大的好处之一在于：潜在的二义不会造成错误。所以，从多个不同的名字空间引入同一个符号名不会造成冲突（假如确实真的从不使用这个符号的话）。例如，除了名字空间sdm外，假如还要用到下面这个名字空间：<br>namespace acmewindowsystem {<!-- --><br>  ...<br>  typedef int handle;<br>  ...<br>}</p> 
 <p> 只要不引用符号handle，使用sdm和acmewindowsystem时就不会有冲突。假如真的要引用，可以明确地指明是哪个名字空间的handle：<br>void f()<br>{<!-- --><br>  using namespacesdm;                // 引入sdm里的所有符号<br>  using namespaceacmewindowsystem;   // 引入acme里的所有符号<br> ...                                 // 自由地引用sdm和acme里除handle之外的其它符号<br>  handleh;                           // 错误! 哪个handle?<br>  sdm::handleh1;                     // 正确, 没有二义<br>  acmewindowsystem::handleh2;        // 也没有二义<br>  ...<br>}</p> 
 <p> 假如用常规的基于头文件的方法来做，只是简单地包含sdm.h和acme.h，这样的话，由于handle有多个定义，编译将不能通过。</p> 
 <p> 名字空间的概念加入到c++标准的时间相对较晚，所以有些人会认为它不太重要，可有可无。但这种想法是错误的，因为c++标准库里几乎所有的东西都存在于名字空间std之中。它有一种直接的影响方式：c++提供了那些没有扩展名的头文件，如&lt;iostream&gt;,&lt;string&gt;等。</p> 
 <p> 由于名字空间的概念引入的时间相对较晚，有些编译器可能不支持。就算是这样，那也没理由污染全局名字空间，因为可以用struct来近似实现namespace。可以这样做：先创建一个结构用以保存全局符号名，然后将这些全局符号名作为静态成员放入结构中：</p> 
 <p>// 用于模拟名字空间的一个结构的定义<br>struct sdm {<!-- --><br>  static const double book_version;<br>  class handle { ... };<br>  static handle&amp;gethandle();<br>};<br>const double sdm::book_version =2.0;     // 静态成员的定义</p> 
 <p>现在，如果有人想访问这些全局符号名，只用简单地在它们前面加上结构名作为前缀：<br>void f()<br>{<!-- --><br>  cout &lt;&lt;sdm::book_version;<br>  ...<br>  sdm::handle h = sdm::gethandle();<br>  ...<br>}</p> 
 <p> 如果全局范围内实际上没有名字冲突，用户就会觉得加修饰符麻烦而多余。幸运的是，还是有办法来让用户选择使用它们或忽略它们。</p> 
 <p> 对于类型名，可以用类型定义（typedef）来显式地去掉空间引用。例如，假设结构s（模拟的名字空间）内有个类型名t，可以这样用typedef来使得t成为s::t的同义词：<br>typedef sdm::handle handle;</p> 
 <p> 对于结构中的每个（静态）对象x，可以提供一个（全局）引用x，并初始化为s::x：<br>const double&amp; book_version = sdm::book_version;</p> 
 <p> 处理函数的方法和处理对象一样，但要注意，即使定义函数的引用是合法的，但代码的维护者会更喜欢使用函数指针：<br>sdm::handle&amp; (* const gethandle)()=     // gethandle是指向sdm::gethandle<br> sdm::gethandle;                        // 的const 指针<br> <br> 注意gethandle是一个常指针。因为当然不想让用户将它指向别的什么东西，而不是sdm::gethandle。<br>如果真想知道怎么定义一个函数的引用，看看下面：<br>sdm::handle&amp; (&amp;gethandle)()=     // gethandle是指向<br> sdm::gethandle;                 // sdm::gethandle的引用</p> 
 <p> 除了初始化的方式外，函数的引用和函数的常指针在行为上完全相同，只是函数指针更易于理解。</p> 
 <p> 有了上面的类型定义和引用，那些不会遭遇全局名字冲突的用户就会使用没有修饰符的类型和对象名；相反，那些有全局名字冲突的用户就会忽略类型和引用的定义，代之以带修饰符的符号名。还要注意的是，不是所有用户都想使用这种简写名，所以要把类型定义和引用放在一个单独的头文件中，不要把它和（模拟namespace的）结构的定义混在一起。</p> 
 <p> struct是namespace的很好的近似，但实际上还是相差很远。它在很多方面很欠缺，其中很明显的一点是对运算符的处理。如果运算符被定义为结构的静态成员，它就只能通过函数调用来使用，而不能象常规的运算符所设计的那样，可以通过自然的语法来使用：<br>// 定义一个模拟名字空间的结构，结构内部包含widgets的类型<br>// 和函数。widgets对象支持operator+进行加法运算<br>struct widgets {<!-- --><br>  class widget { ... };</p> 
 <p>   static const widgetoperator+(const widget&amp; lhs,constwidget&amp; rhs);<br>  ...<br>};<br>// 为上面所述的widge和operator+ 建立全局（无修饰符的）名称<br>typedef widgets::widget widget;</p> 
 <p>const widget (* const operator+)(constwidget&amp;,       // 错误!<br>                                constwidget&amp;);      // operator+不能是指针名<br> <br>widget w1, w2, sum;<br>sum = w1 +w2;                          // 错误! 本空间没有声明<br>                                        // 参数为widgets 的operator+<br>sum = widgets::operator+(w1,w2);       // 合法, 但不是"自然"的语法</p> 
 <p>正因为这些限制，所以一旦编译器支持，就要尽早使用真正的名字空间。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/autocrat/archive/2010/05/05/1727630.html</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0bf8635ee876bb033946d4267fe3c0bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">三种中文分词算法优劣比较</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0cb806c34030bd4144adf8ad384f196/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Win7运行QQ2010提示“应用程序无法启动”，因为应用程序的并行配置不正确</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>