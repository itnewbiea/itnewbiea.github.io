<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM之内存布局 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM之内存布局" />
<meta property="og:description" content="目录
一、引言
二、经典JVM内存布局
1.Heap（堆区）
2.Metaspace（元空间）
3.JVM Stack（虚拟机栈）
4.Native Method Stacks（本地方法栈）
5.Program Counter Register（程序计数寄存器）
三、线程共享角度的内存结构
一、引言 内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略 ，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。
二、经典JVM内存布局 1.Heap（堆区） Heap 是 OOM （Out Of Memory 内存用尽）故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用。通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间。堆的内存空间既可以固定大小，也可以在运行时动态地调整，通过如下参数设定初始值和最大值，比如 －Xms256M -Xmx1024M ，其中－X 表示它是 JVM 运行参数，ms 是 memory start 的简称，mx 是 memory max 的简称，分别代表最小堆容量和最大堆容量。但是在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以在线上生产环境中，JVM 的 Xms 和 Xmx 设置成一样大小，避免在GC（Garbage Collection 垃圾回收）后调整堆大小时带来的额外压力。
堆分成两大块：新生代和老年代。对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。新生代＝ 1 个 Eden 区＋ 2 个Survivor 区。绝大部分对象在 Eden 区生成，当 Eden 区装填满的时候，会触发Young Garbage Collection，即 YGC。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e9d2b1d035b34c88cbe81e3727f6ac43/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-29T09:17:40+08:00" />
<meta property="article:modified_time" content="2019-03-29T09:17:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM之内存布局</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80" rel="nofollow">一、引言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BB%8F%E5%85%B8JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%BB%8F%E5%85%B8JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80" rel="nofollow">二、经典JVM内存布局</a></p> 
<p id="1.Heap%EF%BC%88%E5%A0%86%E5%8C%BA%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.Heap%EF%BC%88%E5%A0%86%E5%8C%BA%EF%BC%89" rel="nofollow">1.Heap（堆区）</a></p> 
<p id="2.Metaspace%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.Metaspace%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89" rel="nofollow">2.Metaspace（元空间）</a></p> 
<p id="3.JVM%20Stack%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.JVM%20Stack%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%89" rel="nofollow">3.JVM Stack（虚拟机栈）</a></p> 
<p id="4.Native%20Method%20Stacks%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.Native%20Method%20Stacks%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%89" rel="nofollow">4.Native Method Stacks（本地方法栈）</a></p> 
<p id="5.Program%20Counter%20Register%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#5.Program%20Counter%20Register%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89" rel="nofollow">5.Program Counter Register（程序计数寄存器）</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%A7%92%E5%BA%A6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%A7%92%E5%BA%A6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84" rel="nofollow">三、线程共享角度的内存结构</a></p> 
<hr id="hr-toc"> 
<h3>一、引言</h3> 
<p style="text-indent:50px;">内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中<strong><span style="color:#f33b45;">内存申请</span></strong>、<strong><span style="color:#f33b45;">分配</span></strong>、<strong><span style="color:#f33b45;">管理</span></strong>的策略 ，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E7%BB%8F%E5%85%B8JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">二、经典JVM内存布局</h3> 
<p style="text-align:center;"><img alt="" class="has" height="467" src="https://images2.imgbox.com/4b/08/XD2EwOAd_o.png" width="850"></p> 
<h4 id="1.Heap%EF%BC%88%E5%A0%86%E5%8C%BA%EF%BC%89" style="text-indent:50px;">1.Heap（堆区）</h4> 
<p style="text-indent:50px;">Heap 是 OOM （Out Of Memory 内存用尽）故障最主要的发源地，它<span style="color:#f33b45;"><strong>存储着几乎所有的实例对象</strong></span>，堆<strong><span style="color:#f33b45;">由垃圾收集器自动回收</span></strong>，<strong><span style="color:#f33b45;">堆区由各子线程共享使用</span></strong>。通常情况下，它<strong>占用的空间是所有内存区域中最大的</strong>，但如果无节制地创建大量对象，也容易消耗完所有的空间。堆的内存空间既可以固定大小，也可以在运行时动态地调整，通过如下参数设定初始值和最大值，比如      －Xms256M -Xmx1024M ，其中－X 表示它是 JVM 运行参数，ms 是 memory start 的简称，mx 是 memory max 的简称，分别代表最小堆容量和最大堆容量。但是在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力，所以<strong>在线上生产环境中</strong>，<strong>JVM 的 Xms 和 Xmx 设置成<span style="color:#f33b45;">一样大小</span></strong>，避免在GC（Garbage Collection 垃圾回收）后调整堆大小时带来的额外压力。</p> 
<p style="text-indent:50px;">堆分成两大块：<strong><span style="color:#f33b45;">新生代</span></strong>和<strong><span style="color:#f33b45;">老年代</span></strong>。对象产生之初在新生代，步入暮年时进入老年代，但是老年代也接纳在新生代无法容纳的超大对象。新生代＝ 1 个 Eden 区＋ 2 个Survivor 区。绝大部分对象在 Eden 区生成，当 Eden 区装填满的时候，会触发Young Garbage Collection，即 YGC。</p> 
<p style="text-indent:50px;">垃圾回收的时候，在 Eden 区实现清除策略，没有被引用的对象则直接回收。依然存活的对象会被移送到 Survivor 区， 这个区真是名副其实的存在。Survivor 区分为 S0 和 S1 两块内存空间，送到哪块空间呢？每次 YGC 的时候，它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除，交换两块空间的使用状态。如果 YGC 要移送的对象大于 Survivor 区容量的上限 ，则直接移交给老年代。假如一些没有进取心的对象以为可以一直在新生代的Survivor 区交换来交换去，那就错了。每个对象都有一个计数器，每次 YGC 都会加 1 。－XX:MaxTenuringThreshold 参数能配置计数器的值到达某个阈值的时候，对象从新生代晋升至老年代。如果该参数配置为 1，那么从新生代的 Eden 区直接移至老年代。默认值是 15 ， 可以在 Survivor 区交换 14 次之后 ， 晋升至老年代。 与上图匹配的对象晋升流程图如下图所示</p> 
<p style="text-align:center;"><img alt="" class="has" height="487" src="https://images2.imgbox.com/2d/23/tDYzGmV4_o.png" width="573"></p> 
<p style="text-indent:50px;"> 上图中，如果 Survivor 区无法放下，或者超大对象的阈值超过上限，则尝试在老年代中进行分配；如果老年代也无法放下，则会触发 Full Garbage Collection，即FGC（全堆范围的垃圾回收）。如果依然无法放下，则抛出 OOM 。<span style="color:#f33b45;"><strong>堆内存出现 OOM 的概率是所有内存耗尽异常中最高的</strong></span>。出错时的堆内信息对解决问题非常有帮助，所以给 JVM 设置运行参数－XX:+HeapDumpOnOutOfMemoryError ，让 JVM 遇到 OOM 异常时能输出堆内信息，特别是对相隔数月才出现的 OOM 异常尤为重要。</p> 
<p style="text-indent:50px;">在不同的 JVM 实现及不同的回收机制中，堆内存的划分方式是不一样的。</p> 
<h4 id="2.Metaspace%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89" style="text-indent:50px;">2.Metaspace（元空间）</h4> 
<p style="text-indent:50px;">上例模型、源码解析和示例代码基本采用 JDK 11 版本，JVM 则为 Hotspot。早在 JDK8 版本中，元空间的前身 Perm 区已经被淘汰。<strong><span style="color:#f33b45;">在 JDK7 及之前的版本中</span></strong>，只有 Hotspot 才有<span style="color:#f33b45;"><strong> Perm 区，译为永久代</strong></span>，它在启动时固定大小，很难进行调优，并且 FGC 时会移动类元信息。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多的类，经常出现致命错误。</p> 
<blockquote> 
 <p style="text-indent:50px;">Exception in thread 'dubbo client x.x connector ' java.lang.OutOfMemoryError : PermGen space</p> 
</blockquote> 
<p style="text-indent:50px;">为了解决该问题，需要设定运行参数 －XX:MaxPermSize= 1280m，如果部署到新机器上，往往会因为 JVM 参数没有修改导致故障再现。不熟悉此应用的人排查问题时往往苦不堪言，除此之外，<strong>永久代在垃圾回收过程中还存在诸多问题</strong>。所以， <strong>JDK8 使用<span style="color:#f33b45;">元空间</span>替换<span style="color:#f33b45;">永久代</span></strong>。在 JDK8 及以上版本中，设定 MaxPermSize 参数， JVM 在启动时并不会报锚，但是会提示 ：</p> 
<blockquote> 
 <p style="text-indent:50px;">Java HotSpot 64Bit Server VM warning:ignoring option MaxPem1Size=2560m; support was removed i11 8.0 。</p> 
</blockquote> 
<p style="text-indent:50px;"><strong>元空间的本质和永久代类似</strong>，<strong>都是对 JVM 规范中方法区的实现</strong>。区别于永久代，<strong><span style="color:#f33b45;">元空间在本地内存中分配</span></strong>。在 JDK8 里， Perm 区中的所有内容中<span style="color:#f33b45;"><strong>字符串常量移至堆内存</strong></span>，其他内容包括<strong><span style="color:#f33b45;">类元信息</span></strong>、<strong><span style="color:#f33b45;">字段</span></strong>、<strong><span style="color:#f33b45;">静态属性</span></strong>、<strong><span style="color:#f33b45;">方法</span></strong>、<strong><span style="color:#f33b45;">常量</span></strong>等都移动<span style="color:#f33b45;"><strong>至元空间内</strong></span>，比如下图中的 Object 类元信息、静态属性 System.out、整型常量 10000000 等。下图中显示在<strong>常量池中的 String</strong>， 其<strong>实际对象是被保存在<span style="color:#f33b45;">堆内存中</span>的</strong>。</p> 
<p style="text-align:center;"><img alt="" class="has" height="155" src="https://images2.imgbox.com/58/48/haDq1cNg_o.png" width="623"></p> 
<h4 id="3.JVM%20Stack%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%89" style="text-indent:50px;">3.JVM Stack（虚拟机栈）</h4> 
<p style="text-indent:50px;">栈（ Stack ）是一个先进后出的数据结构，就像子弹的弹夹，最后压入的子弹先发射，压在底部的子弹最后发射，撞针只能访问位于顶部的那一颗子弹。</p> 
<p style="text-indent:50px;">相对于基于寄存器的运行环境来说，JVM 是基于栈结构的运行环境。栈结构移植性更好，可控性更强。<strong>JVM 中的虚拟机栈是<span style="color:#f33b45;">描述 Java 方法执行的内存区域</span></strong>，它是<strong><span style="color:#e579b6;">线程私有的</span></strong>。<strong>栈中的元素用于支持虚拟机进行方法调用</strong>，<span style="color:#f33b45;"><strong>每个方法从开始调用到执行完成的过程</strong></span>，<strong>就是<span style="color:#f33b45;">栈帧从入栈到出栈的过程</span></strong>。在活动线程中，只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法，栈帧是方法运行的基本结构。在执行引擎运行时，所有指令都只能针对当前栈帧进行操作。而 <span style="color:#f33b45;"><strong>StackOverflowError </strong></span>表示请求的<strong><span style="color:#f33b45;">栈溢出</span></strong>，导致内存耗尽，<strong>通常出现在递归方法中</strong>。 JVM 能够横扫干军 ，虚拟机栈就是它的心腹大将，当前方法的栈帧，都是正在战斗的战场，其中的操作栈是参与战斗的士兵。操作栈的压枝栈与出栈如下所示。</p> 
<p style="text-align:center;"><img alt="" class="has" height="475" src="https://images2.imgbox.com/1c/bf/wv89QLLj_o.png" width="626"></p> 
<p style="text-indent:50px;">虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行的过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。<strong>栈帧在整个 JVM 体系中的地位颇高</strong>，包括<strong><span style="color:#f33b45;">局部变量表</span></strong>、<strong><span style="color:#f33b45;">操作栈</span></strong>、<strong><span style="color:#f33b45;">动态连接</span></strong>、<strong><span style="color:#f33b45;">方法返回地址</span></strong>等。</p> 
<p style="text-indent:50px;">（1）<strong>局部变量表</strong></p> 
<p style="text-indent:50px;">局部变量表是存放方法参数和局部变量的区域。相对于类属性变量的准备阶段和初始化阶段来说，局部变量没有准备阶段，必须显式初始化。如果是<strong>非静态方法</strong>，则在 i<strong>ndex[ 0］位置上存储</strong>的是<strong>方法所属对象的实例引用</strong>，<strong>随后存储的是参数和局部变量</strong>。字节码指令中的 STORE 指令就是将操作栈中计算完成的局部变量写回局部变量表的存储空间内。</p> 
<p style="text-indent:50px;">（2）<strong>操作栈</strong></p> 
<p style="text-indent:50px;">操作栈是一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。 JVM 的执行引擎是基于栈的执行引擎，其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中，下面用一段简单的代码说明操作栈与局部变量表的交互：</p> 
<pre class="has"><code class="language-java">  public int simpleMethod() {
        int x = 13;
        int y = 14;
        int z = x + y;
        return z;
    }</code></pre> 
<pre class="has"><code class="language-java">  public simpleMethod() {
      descriptor: ()I
      flags: ACC_PUBLIC
      Code:
        stack=2, locals=4, args_Size=1  // 最大栈深度为2,局部变量个数为4
            BIPUSH 13    // 常量 13 压入操作栈
            ISTORE_1     // 并保存到局部变量表的slot_1中  (第 1 处)
            
            BIPUSH 14    // 常量 14 压入操作栈,注意是 BIPUSH
            ISTORE_2     // 并保存到局部变量表的 slot_2 中
            
            ILOAD_1      // 把局部变量表的 slot_1 元素 (int x) 压入操作栈
            ILOAD_2      // 把局部变量表的 slot_2 元素 (int y) 压入操作栈
            IADD         // 把上方的两个数都取出来,在 CPU 里加一下,并压回操作栈的栈顶
            ISTORE_3     // 把栈顶的结果存储到局部变量的 slot_3 中
            
            ILOAD_3
            IRETURN      // 返回栈顶元素值 
  }</code></pre> 
<p style="text-indent:50px;"> 第 1 处说明局部变量表就像一个中药柜，里面有很多抽屉，依次编号为 0, 1, 2,3, , n，字节码指令 ISTORE_1就是打开 1号抽屉，把栈顶中的数 13 存进去。栈是一个很深的竖桶，任何时候只能对桶口元素进行操作，所以数据只能在栈顶进行存取。某些指令可以直接在抽屉里进行，比如 iinc 指令，直接对抽屉里的数值进行 +1 操作。程序员面试过程中，常见的 i++和++i 的区别，可以从字节码上对比出来，如下表所示。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td><strong>a = i++</strong></td><td><strong>a = ++i</strong></td></tr><tr><td> <p>0：iload_1</p> <p>1：iinc 1,1</p> <p>4：istore_2</p> </td><td> <p>0：iinc 1,1</p> <p>3：iload_1</p> <p>4：istore_2</p> </td></tr></tbody></table> 
<p style="text-indent:50px;">在上表左列中，iload_1 从局部变量表的第 1 号抽屉里取出一个数，压入栈顶，下一步直接在抽屉里实现 +1 的操作 ， 而这个操作对栈顶元素的值没有影响。所以istore_2 只是把栈顶元素赋值给 a；表格右列，先在第 1 号抽屉里执行 +1 操作 ， 然后通过 iload_1 把第 1 号抽屉里的数压入栈顶， 所以 i_store 2 存人的是 +1 之后的值。这里延伸一个信息， i++并非原子操作。即使通过 volatile 关键字进行修饰，多个线程同时写的话，也会产生数据互相覆盖的问题。 </p> 
<p style="text-indent:50px;">（3）<strong>动态连接</strong></p> 
<p style="text-indent:50px;">每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接。</p> 
<p style="text-indent:50px;">（4）<strong>方法返回地址</strong></p> 
<p style="text-indent:50px;">方法执行时有两种退出情况：第一，正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN 、IRETURN 、 ARETURN 等；第二，异常退出。无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧 ，退出可能有三种方式：</p> 
<p style="text-indent:50px;">•返回值压入上层调用栈帧。</p> 
<p style="text-indent:50px;">•异常信息抛给能够处理的栈帧。</p> 
<p style="text-indent:50px;">•PC 计数器指向方法调用后的下一条指令。</p> 
<h4 id="4.Native%20Method%20Stacks%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%89" style="text-indent:50px;">4.Native Method Stacks（本地方法栈）</h4> 
<p style="text-indent:50px;">本地方法栈（ Native Method Stack ）在 JVM 内存布局中，也是线程对象私有的，但是虚拟机栈 "主内"， 而本地方法栈"主外"。这个"内外"是针对 JVM 来说的，<strong><span style="color:#f33b45;">本地方法栈为 Native 方法（本地方法）服务</span></strong>。线程开始调用本地方法时，<strong>会进入一个不再受 JVM 约束的世界</strong>。本地方法可以<strong>通过 <span style="color:#f33b45;">JNI ( Java Native Interface ）</span></strong>来访问<strong>虚拟机运行时的数据区</strong>，甚至可以调用寄存器，<strong>具有和 JVM 相同的能力和权限</strong>。当大量本地方法出现时，势必会削弱 JVM 对系统的控制力，因为它的出错信息都比较黑盒。对于内存不足的情况，本地方法栈还是会抛出 native heap OutOfMemory。</p> 
<p style="text-indent:50px;">重点说一下 JNI 类本地方法，<strong>最著名的本地方法</strong>应该是<strong><span style="color:#f33b45;"> System.currentTimeMillis()</span></strong>，JNI 使 Java 深度使用操作系统的特性功能，复用非 Java 代码。但是在项目过程中，<strong>如果大量使用其他语言来实现 JNI</strong>，<span style="color:#f33b45;"><strong>就会丧失跨平台特性</strong></span>，威胁到程序运行的稳定性。假如需要与本地代码交互，就可以用中间标准框架进行解耦，这样即使本地方法崩溃也不至于影响到 JVM 的稳定。当然，如果要求极高的执行效率、偏底层的跨进程操作等，可以考虑设计为 JNI 调用方式。</p> 
<h4 id="5.Program%20Counter%20Register%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89" style="text-indent:50px;">5.Program Counter Register（程序计数寄存器）</h4> 
<p style="text-indent:50px;">在程序计数寄存器（ Program Counter Register, PC ）中，Register 的命名源于CPU 的寄存器，CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的现场信息，由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的<strong>一个内核</strong>，<strong>只会执行某个线程中的一条指令</strong>。这样<strong>必然导致经常中断或恢复</strong>，<strong><span style="color:#f33b45;">如何保证分毫无差呢？</span></strong>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行<strong><span style="color:#f33b45;">指令的偏移量</span></strong>和<strong><span style="color:#f33b45;">行号指示器</span></strong>等，线程执行或恢复都要依赖程序计数器。程序计数器在各个线程之间互不影响，此区域也不会发生内存溢出异常 。</p> 
<h3 id="%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%A7%92%E5%BA%A6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">三、线程共享角度的内存结构</h3> 
<p style="text-indent:50px;">从线程共享的角度来看，<span style="color:#f33b45;"><strong>堆</strong></span>和<strong><span style="color:#f33b45;">元空间</span></strong>是<span style="color:#3399ea;"><strong>所有线程共享</strong></span>的，而<span style="color:#f33b45;"><strong>虚拟机栈</strong></span>、<strong><span style="color:#f33b45;">本地方法栈</span></strong>、<strong><span style="color:#f33b45;">程序计数器</span></strong>是<strong><span style="color:#3399ea;">线程内部私有</span></strong>的，从这个角度看下 Java 内存结构，如下图</p> 
<p style="text-align:center;"><img alt="" class="has" height="488" src="https://images2.imgbox.com/a3/b4/ze7UPfhd_o.png" width="830"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/352c9e1fc72a3a367db9cce2346dc0b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推荐一个学shell超级好的网站，写的详细很不错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f6dbada132596e22f24d8d6aa0772c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">StatefulWidget initState()方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>