<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue项目在ie浏览器input输入框刷新不清空_经验 | python 操作浏览器的三种方式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue项目在ie浏览器input输入框刷新不清空_经验 | python 操作浏览器的三种方式" />
<meta property="og:description" content="第一种：selenium导入浏览器驱动，用get方法打开浏览器，例如：
import timefrom selenium import webdriverdef mac(): # browser = webdriver.Chrome() # browser = webdriver.Firefox() browser = webdriver.Ie() browser.implicitly_wait(5) browser.get(&#39;http://www.baidu.com/&#39;) 第二种：通过导入python的标准库webbrowser打开浏览器，例如：
import webbrowserdef mac(): # web.open(‘http://www.baidu.com’,new=0,autoraise=True) # new:0/1/2 0：同一浏览器窗口打开 1：打开浏览器新的窗口，2：打开浏览器窗口新的tab; autoraise=True:窗口自动增长 # web.open_new_tab(‘http://www.baidu.com’) web.open_new(‘http://www.baidu.com’) 第三种：使用Splinter模块模块
一、Splinter 的安装Splinter 的使用必修依靠 Cython、lxml、selenium 这三个软件。所以，安装前请提前安装 Cython、lxml、selenium。
二、Splinter 的使用
这里，我给出自动登录 126 邮箱的案例。难点是要找到页面的账户、密码、登录的页面元素，这里需要查看 126 邮箱登录页面的源码，才能找到相关控件的 id.
例如: 输入密码，密码的文本控件 id 是 pwdInput. 可以使用browser.find_by_id() 方法定位到密码的文本框，接着使用fill() 方法，填写密码。至于模拟点击按钮，也是要先找到按钮控件的 id, 然后使用 click() 方法。
# coding=utf-8import time from splinter import Browserdef splinter(url): browser = Browser() # login 126 email websize browser." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/57032d6b6e764f0af72a867161207896/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-22T16:40:13+08:00" />
<meta property="article:modified_time" content="2020-11-22T16:40:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue项目在ie浏览器input输入框刷新不清空_经验 | python 操作浏览器的三种方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p><strong>第一种：selenium导入浏览器驱动，用get方法打开浏览器</strong>，例如：</p> 
 <pre><code>import timefrom selenium import webdriverdef mac(): # browser = webdriver.Chrome() # browser = webdriver.Firefox() browser = webdriver.Ie() browser.implicitly_wait(5) browser.get('http://www.baidu.com/')</code></pre> 
 <p><strong>第二种：通过导入python的标准库webbrowser打开浏览器</strong>，例如：</p> 
 <pre><code>import webbrowserdef mac(): # web.open(‘http://www.baidu.com’,new=0,autoraise=True) # new:0/1/2 0：同一浏览器窗口打开 1：打开浏览器新的窗口，2：打开浏览器窗口新的tab; autoraise=True:窗口自动增长 # web.open_new_tab(‘http://www.baidu.com’) web.open_new(‘http://www.baidu.com’)</code></pre> 
 <p><strong>第三种：使用Splinter模块模块</strong></p> 
 <p>一、Splinter 的安装<strong>Splinter 的使用必修依靠 Cython、lxml、selenium 这三个软件</strong>。所以，安装前请提前安装 Cython、lxml、selenium。</p> 
 <p>二、Splinter 的使用<br> 这里，我给出自动登录 126 邮箱的案例。难点是要找到页面的账户、密码、登录的页面元素，这里需要查看 126 邮箱登录页面的源码，才能找到相关控件的 id.</p> 
 <p> 例如: 输入密码，密码的文本控件 id 是 pwdInput. 可以使用<strong>browser.find_by_id() 方法定位到密码的文本框</strong>，接着使用<strong>fill() 方法，填写密码</strong>。至于模拟点击按钮，也是要先找到按钮控件的 id, 然后使用 click() 方法。</p> 
 <pre><code># coding=utf-8import time from splinter import Browserdef splinter(url): browser = Browser() # login 126 email websize browser.visit(url) # wait web element loading time.sleep(5) # fill in account and password browser.find_by_id('idInput').fill('xxxxxx') browser.find_by_id('pwdInput').fill('xxxxx') # click the button of login browser.find_by_id('loginBtn').click() time.sleep(8) # close the window of brower browser.quit()if __name__ == '__main__':  websize3 ='http://www.126.com'  splinter(websize3) </code></pre> 
 <p><strong>WebDriver简介</strong></p> 
 <p>selenium 从 2.0 开始集成了 webdriver 的 API，提供了更简单，更简洁的编程接口。selenium webdriver 的目标是提供一个设计良好的面向对象的 API，提供了更好的支持进行 web-app 测试。</p> 
 <p>打开浏览器</p> 
 <p>在 selenium+python 自动化测试(一)–环境搭建中，运行了一个测试脚本，脚本内容如下：</p> 
 <pre><code>from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get("http://www.baidu.com")print(browser.title)browser.find_element_by_id("kw").send_keys("selenium")browser.find_element_by_id("su").click()time.sleep(3)browser.close() </code></pre> 
 <p>webdriver 是一个 Web 应用程序测试自动化工具，用来验证程序是否如预期的那样执行。</p> 
 <p><strong>webdriver.Chrome()：创建一个 Chrome 浏览器的 webdriver 实例</strong></p> 
 <p><strong>browser.get(“http://www.baidu.com“)：打开”http://www.baidu.com”页面</strong></p> 
 <p><strong>browser.find_element_by_id(“kw”).send_keys(“selenium”)：<br>找到 id 为“kw”的元素，在这个页面上为百度首页的搜索框，在其中输入“selenium”</strong></p> 
 <p><strong>browser.find_element_by_id(“su”).click()：找到 id 为“su”的元素并点击，在这个页面上为百度首页的“百度一下”按钮</strong></p> 
 <p><strong>browser.close()：退出浏览器</strong></p> 
 <p>运行脚本的第一步是打开浏览器，使用 webdriver.Chrome() 打开谷歌浏览器，如果要指定其他浏览器，比如要使用 Firefox 或者 IE 浏览器，更换浏览器名称就可以了</p> 
 <p><strong>browser = webdriver.Chrome() // 打开 Chrome 浏览器</strong></p> 
 <p><strong>browser = webdriver.Firefox() // 打开 Firefox 浏览器</strong></p> 
 <p><strong>browser = webdriver.Ie() // 打开 IE 浏览器</strong></p> 
 <p>第二步操作是打开页面，<strong>使用browser.get(url)方法来打开网页链接</strong>，例如脚本中打开百度首页</p> 
 <p><strong>browser.get("http://www.baidu.com")</strong></p> 
 <p>接下来是 **print(browser.title)**，<strong>使用browser.title获取当前页面的title</strong>，title就是在浏览器 tab 上显示的内容，例如百度首页的标题是“百度一下，你就知道”</p> 
 <p>浏览器前进后退</p> 
 <p>在当前页面打开一个新的链接后，如果想回退到前一个页面，<strong>使用如下browser.back()</strong>，相当于点击了浏览器的后退按钮</p> 
 <p>和 back 操作对应的是浏览器<strong>前进操作browser.forward()</strong>，相当于点击了浏览器的前进按钮</p> 
 <p><strong>browser.back() // 回到上一个页面</strong></p> 
 <p><strong>browser.forward() // 切换到下一个页面</strong></p> 
 <p>浏览器运行后，如果页面没有最大化，可以<strong>调用browser.maximize_window()将浏览器最大化</strong>，相当于点击了页面右上角的最大化按钮</p> 
 <p><strong>browser.maximize_window() // 浏览器窗口最大化</strong></p> 
 <p><strong>browser.set_window_size(800, 720) // 设置窗口大小为 800*720</strong></p> 
 <p>浏览器截屏操作，参数是截屏的图片保存路径：</p> 
 <p><strong>browser.get_screenshot_as_file("D:/data/test.png") 屏幕截图保存为</strong>***</p> 
 <p><strong>browser.refresh() // 重新加载页面, 页面刷新</strong></p> 
 <p>在测试脚本运行完后，一般会在最后关闭浏览器，有两种方法关闭浏览器，close()方法用于关闭当前页面，quit()方法关闭所有和当前测试有关的浏览器窗口</p> 
 <p><strong>browser.close() // 关闭当前页面</strong></p> 
 <p><strong>browser.quit() // 关闭所有由当前测试脚本打开的页面</strong></p> 
 <h2 class="csdn_top"> <strong>页面元素定位</strong></h2> 
 <p>要定位页面元素，需要找到页面的源码。</p> 
 <p>IE 浏览器中，打开页面后，在页面上点击鼠标右键，会有“查看源代码”的选项，点击后就会进入页面源码页面，在这里就可以找到页面的所有元素</p> 
 <p>使用 Chrome 浏览器打开页面后，在浏览器的地址栏右侧有一个图标，点击这个图标后，会出现许多菜单项，选择更多工具里的开发者工具，就会出现页面的源码，不同版本的浏览器菜单选项可能不同，但是都会在开发者工具里找到页面的源码</p> 
 <p>Firefox 浏览器打开页面后，在右键菜单里也可以找到“查看页面源代码”的选项。在 Firefox 中，可以使用浏览器自带的插件查看定位元素，在 Firefox 的附加组件里搜索 firebug 进行下载，安装 firebug 组件后会在浏览器的工具栏中多出一个小虫子的图标，点击这个图标就可以打开组件查看页面源码，打开后如下图所示</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/8a/e5/HxX3yFw8_o.png" alt="42fa8873bb02233c7c23e42969a698ac.png"> 
 </div> 
 <p>以百度首页搜索页面为例，看一下 webdriver 定位元素的八种方式</p> 
 <p><strong>使用id定位</strong></p> 
 <p>在页面源码中找到搜索输入框的元素定义</p> 
 <p>可以看到输入框有一个有一个 id 的属性，调用find_element_by_id()根据 id 属性来找到元素，参数为属性的值</p> 
 <p><strong>input_search = browser.find_element_by_id("kw")</strong></p> 
 <p><strong>使用name定位</strong></p> 
 <p>使用find_element_by_name()根据 name 属性找到元素，参数为 name 属性的值</p> 
 <p>搜索框有一个 name=”wd”的属性，使用 name 查找搜索输入框元素</p> 
 <p><strong>input_search = browser.find_element_by_name("wd")</strong></p> 
 <p><strong>使用className定位</strong></p> 
 <p>使用find_element_by_class_name()根据 className 属性找到元素，参数为 className 属性的值</p> 
 <p>搜索框有一个 class=”s_ipt”的属性，使用 className 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_class_name("s_ipt")</strong></p> 
 <p><strong>使用tagName定位</strong></p> 
 <p>使用find_element_by_tag_name()根据 tagName 属性找到元素，参数为元素标签的名称</p> 
 <p>每个页面的元素都有一个 tag，搜索框的标签为 input，有时候一个页面里有许多相同的标签，所以用这种方法找到的元素一般都不准确，除非这个元素使用的标签在这个页面里是唯一的。一般不会使用这种方式来定位元素</p> 
 <p><strong>input_search = browser.find_element_by_class_name("input")</strong></p> 
 <p><strong>使用link_text定位</strong></p> 
 <p>页面上都会有一些文本链接，点击链接后会打开一个新的页面，这些可以点击的链接可以使用find_element_by_link_text来定位，百度首页上方有如下几个元素</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/37/fc/dhNppR2V_o.png" alt="d9b6202e1d5cf950e91f546ee81719bf.png"> 
 </div> 
 <p>例如要定位“新闻”，找到元素的代码，<strong>有一个 href 的属性</strong>，这是点击后打开的页面</p> 
 <p>新闻</p> 
 <p>使用 link_text 查找元素，参数为元素的文本信息</p> 
 <p><strong>news = browser.find_element_by_link_text("新闻")</strong></p> 
 <p><strong>使用partial_link_text定位</strong></p> 
 <p>这种方式类似于 link_text 的定位方式，如果一个元素的文本过长，不需要使用文本的所有信息，可以使用其中的部分文本就可以定位</p> 
 <p><strong>使用 partial_link_text 查找百度首页的“新闻”元素，参数为文本信息，可以使用全部的文本，也可以使用部分文本</strong></p> 
 <p><strong>news = browser.find_element_by_link_text("新闻") // 使用全部文本</strong></p> 
 <p><strong>news = browser.find_element_by_link_text("新") // 使用部分文本</strong></p> 
 <p><strong>使用css selector定位</strong></p> 
 <p>使用 css 属性定位元素有多种方法，可以使用元素的 id、name、className，也可以使用元素的其他属性，如果一个元素没有上述的几种属性或者定位不到时，可以使用 css 来定位</p> 
 <p>还是使用百度搜索框的实例来说明 css 定位的用法</p> 
 <p><strong>css使用元素的id定位</strong></p> 
 <p><strong>css 属性使用 id 定位时，使用 #号表示元素的 id</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector("#kw") // 使用元素的 id 定位</strong></p> 
 <p><strong>css使用元素的class定位</strong></p> 
 <p><strong>css 属性使用 class 定位时，使用. 号表示元素的 class</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector(".s_ipt") // 使用元素的 class 定位</strong></p> 
 <p><strong>css使用元素的tag定位</strong></p> 
 <p><strong>css 属性使用 tagName 定位时，直接使用元素的标签</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector("input") // 使用元素的 tagName 定位</strong></p> 
 <p>css 使用元素的其他属性</p> 
 <p>除了上述 3 种属性，css 属性可以使用元素的其他属性定位，格式如下</p> 
 <p><strong>input_search = browser.find_element_by_css_selector("[maxlength='255']")</strong></p> 
 <p><strong>使用元素的maxlength属性定位</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector("[autocomplete='off']")</strong></p> 
 <p><strong>使用元素的autocomplete属性定位</strong></p> 
 <p><strong>可以在参数中加入元素的标签名称</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector("input#kw")</strong> // 使用元素的 id 定位</p> 
 <p><strong>input_search = browser.find_element_by_css_selector("input.s_ipt")</strong> // 使用元素的 class 定位</p> 
 <p><strong>input_search = browser.find_element_by_css_selector("input[maxlength='255']")</strong> // 使用元素的 maxlength 属性定位</p> 
 <p><strong>input_search = browser.find_element_by_css_selector("input[autocomplete='off']")</strong> // 使用元素的 autocomplete 属性定位</p> 
 <p>css 的层级定位</p> 
 <p>当一个元素使用自身的属性不容易定位时，<strong>可以通过它的父元素来找到它</strong>，如果父元素也不好定位，可以再通过上元素来定位，以此类推，一直找到容易定位的父元素为止，通过层级定位到需要查找的元素</p> 
 <p>通过 Firefox 的 firebug 组件查看百度首页的源码</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/22/96/zK0jfqiD_o.png" alt="809d2ec4b65b850f9f7beb95509622cf.png"> 
 </div> 
 <p><strong>通过层级来定位搜索框</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector("form#form&gt;span:nth-child(1)&gt;input")</strong></p> 
 <p><strong>input_search = browser.find_element_by_css_selector("form.fm&gt;span:nth-child(1)&gt;input")</strong></p> 
 <p>搜索框的父元素为 span 标签，span 的父元素为 form，form 有 id 和 class 属性，可以通过这两个属性来定位，找到 form 元素后，<strong>form 下有多个 span 标签，所以要使用 span:nth-child(1)，表示 form 下的第一个 span 标签</strong>，这种用法很容易理解，表示第几个孩子，最后是 span 下的 input 标签，span 下只有一个 input，所以就可以定位到搜索框</p> 
 <p><strong>css逻辑运算</strong></p> 
 <p>用一个属性来定位元素时，如果有其他元素的属性和此元素重复，可以组合多个属性来功共同定位</p> 
 <p>组合多个属性定位元素定位百度搜索框</p> 
 <p><strong>input_search = browser.find_element_by_css_selector("input[id='kw'][name='wd']")</strong></p> 
 <p>在元素内定义的属性，都可以使用 css 来定位，使用其他几种方式无法定位到元素时，可以使用 css，够强大！</p> 
 <p><strong>使用xpath定位</strong></p> 
 <p>XPath 是一种在 XML 文档中定位元素的语言。因为 HTML 可以看做 XML 的一种实现，所以 selenium 用户可是使用这种强大语言在 web 应用中定位元素。xpath 也可以通过元素的各种属性定位到元素</p> 
 <p>使用元素属性定位</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//*[@id='kw']")</strong> // 通过元素 id 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//*[@name='wd']")</strong> // 通过元素 name 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//*[@class='s_ipt']")</strong> // 通过元素 class 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//*[@maxlength='255']")</strong> // 通过其他属性查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//*[@autocomplete='off']")</strong> // 通过其他属性查找元素</p> 
 <p><strong>前面的 * 号表示查找所有的标签元素，可以替换为标签名称，更准确的定位元素</strong></p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@id='kw']")</strong> // 通过元素 id 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@name='wd']")</strong> // 通过元素 name 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@class='s_ipt']")</strong> // 通过元素 class 查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@maxlength='255']")</strong> // 通过其他属性查找元素</p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@autocomplete='off']")</strong> // 通过其他属性查找元素</p> 
 <p><strong>xpath也可以通过层级来定位</strong>，定位方式</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/1e/25/Q3feR8Fj_o.png" alt="edcb194dd44114cdda02911196492098.png"> 
 </div> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@id='form']//span[1]//input")</strong></p> 
 <p>browser.find_element_by_xpath("//input[@class='fm']//span[1]//input")查找效果和通过 css 的层级定位是相同的，<strong>意思是 form 元素下面的第一个 span 元素的 input 标签子元素xpath的逻辑元素通过and运算符来组合元素属性</strong></p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[@id='kw' and name='wd']")</strong></p> 
 <p>属性匹配<br>xpath 中还有一种更强大的定位方式，<strong>通过模糊匹配元素的属性</strong></p> 
 <p><strong>news = browser.find_element_by_xpath("//a[contains(text(), '新闻')]")</strong></p> 
 <p><strong>查找text中包含"新闻"的元素</strong></p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[contains(@id, 'kw']")</strong></p> 
 <p><strong>查找id中包含"kw"的元素</strong></p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[starts-with(@id, 'k']")</strong></p> 
 <p><strong>查找id以"k"开头的元素</strong></p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[ends-with(@id, 'w']")</strong></p> 
 <p><strong>查找id以"w"结尾的元素</strong></p> 
 <p><strong>input_search = browser.find_element_by_xpath("//input[matchs(@id, 'k*']")</strong></p> 
 <p><strong>利用正则表达式查找元素</strong></p> 
 <p>上面介绍了查找页面元素的八种方法，通过这些方式找到的都是单个元素，如果需要批量查找元素，还有和上面方式对应的八种复数形式</p> 
 <p>find_elements_by_id</p> 
 <p>find_elements_by_name</p> 
 <p>find_elements_by_class_name</p> 
 <p>find_elements_by_tag_name</p> 
 <p>find_elements_by_link_text</p> 
 <p>find_elements_by_partial_link_text</p> 
 <p>find_elements_by_css_selector</p> 
 <p>find_elements_by_xpath</p> 
 <p><strong>这8种方法查找到的是一组元素，返回的是list，可以通过索引来操作元素</strong></p> 
 <p>例如页面上的复选框和单选框，或者页面上有多个属相相同的输入框，这些属性相同的一组元素，可以批量获取，然后过滤出需要操作的元素，选择其中的一个或者多个进行操作</p> 
 <p>通过百度首页搜索“selenium”关键字，会出现许多搜索结果，这些搜索结果具有相同的属性，不同的是属性的值不同，定位这些元素时，可以使用批量定位的方法</p> 
 <p>看下面的代码</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/18/76/q8TVbzfK_o.png" alt="f9c56c7a57e77fede11ad5cc5592365a.png"> 
 </div> 
 <p>这是搜索 selenium 关键字后的页面结果，每一个搜索结果都是可点击的链接，定位这些元素的方法：</p> 
 <p><strong>search_results = browser.find_elements_by_css_selector("h.t&gt;a")</strong></p> 
 <p><strong>search_results[3].click() // 通过索引点击第 4 条搜索结果</strong></p> 
 <p>第二个例子</p> 
 <p><strong>checkbox</strong><br>checkbox1<br>checkbox2<br>checkbox3</p> 
 <p>这个页面上有 3 个复选框，打开后如下图所示：</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/87/a2/Vz0aRNqn_o.png" alt="cc5d051fd3f26c80d2f0e21e57753a51.png"> 
 </div> 
 <p>操作复选框</p> 
 <p>// 查找所有的复选框并点击<strong>checkboxs = browser.find_element_by_xpath('input[@type="checkbox"]')</strong></p> 
 <p>返回一个 list</p> 
 <p>for checkbox in checkboxs:<br>checkbox.click()<br>// 点击最后一个复选框</p> 
 <p>checkboxs[2].click()</p> 
 <p>from selenium import webdriver</p> 
 <p>browser=webdriver.Firefox()</p> 
 <p><strong>browser.get(r’http://www.baidu.com/’)</strong></p> 
 <p>print(‘browser attributes:’)</p> 
 <p>print(dir(browser))</p> 
 <p><strong>elem=browser.find_element_by_id(‘kw’)</strong></p> 
 <p>print(‘WebElement attributes:’)</p> 
 <p><strong>print(dir(elem)</strong>)</p> 
 <p>浏览器属性：</p> 
 <p><strong>driver attributes:</strong></p> 
 <p>[‘NATIVE_EVENTS_ALLOWED’, ‘<strong>class</strong>’, ‘<strong>delattr</strong>’, ‘<strong>dict</strong>’, ‘<strong>doc</strong>’, ‘<strong>format</strong>’, ‘<strong>getattribute</strong>’, ‘<strong>hash</strong>’, ‘<strong>init</strong>’, ‘<strong>module</strong>’, ‘<strong>new</strong>’, ‘<strong>reduce</strong>’, ‘<strong>reduce_ex</strong>’, ‘<strong>repr</strong>’, ‘<strong>setattr</strong>’, ‘<strong>sizeof</strong>’, ‘<strong>str</strong>’, ‘<strong>subclasshook</strong>’, ‘<strong>weakref</strong>’, ‘_file_detector’, ‘_is_remote’, ‘_mobile’, ‘_switch_to’, ‘_unwrap_value’, ‘_wrap_value’, ‘add_cookie’, ‘application_cache’, ‘back’, ‘binary’, ‘capabilities’, ‘close’, ‘command_executor’, ‘create_web_element’, ‘current_url’, ‘current_window_handle’, ‘delete_all_cookies’, ‘delete_cookie’, ‘desired_capabilities’, ‘error_handler’, ‘execute’, ‘execute_async_script’, ‘execute_script’, ‘file_detector’, ‘find_element’, ‘find_element_by_class_name’, ‘find_element_by_css_selector’, ‘find_element_by_id’, ‘find_element_by_link_text’, ‘find_element_by_name’, ‘find_element_by_partial_link_text’, ‘find_element_by_tag_name’, ‘find_element_by_xpath’, ‘find_elements’, ‘find_elements_by_class_name’, ‘find_elements_by_css_selector’, ‘find_elements_by_id’, ‘find_elements_by_link_text’, ‘find_elements_by_name’, ‘find_elements_by_partial_link_text’, ‘find_elements_by_tag_name’, ‘find_elements_by_xpath’, ‘firefox_profile’, ‘forward’, ‘get’, ‘get_cookie’, ‘get_cookies’, ‘get_log’, ‘get_screenshot_as_base64’, ‘get_screenshot_as_file’, ‘get_screenshot_as_png’, ‘get_window_position’, ‘get_window_size’, ‘implicitly_wait’, ‘log_types’, ‘maximize_window’, ‘mobile’, ‘name’, ‘orientation’, ‘page_source’, ‘profile’, ‘quit’, ‘refresh’, ‘save_screenshot’, ‘session_id’, ‘set_page_load_timeout’, ‘set_script_timeout’, ‘set_window_position’, ‘set_window_size’, ‘start_client’, ‘start_session’, ‘stop_client’, ‘switch_to’, ‘switch_to_active_element’, ‘switch_to_alert’, ‘switch_to_default_content’, ‘switch_to_frame’, ‘switch_to_window’, ‘title’, ‘w3c’, ‘window_handles’]<br>调用说明：</p> 
 <p>driver. 属性值</p> 
 <p><strong>变量说明：</strong><br>1.driver.current_url：用于获得当前页面的 URL</p> 
 <p>2.driver.title：用于获取当前页面的标题</p> 
 <p>3.driver.page_source: 用于获取页面 html 源代码</p> 
 <p>4.driver.current_window_handle: 用于获取当前窗口句柄</p> 
 <p>5.driver.window_handles: 用于获取所有窗口句柄 </p> 
 <p><strong>函数说明：</strong></p> 
 <p>1.driver.find_element*(): 定位元素，<br>2.driver.get(url): 浏览器加载 url。<br>实例：driver.get(“http//:www.baidu.com”)<br>3.driver.forward()：浏览器向前(点击向前按钮)。<br>4.driver.back()：浏览器向后(点击向后按钮)。<br>5.driver.refresh()：浏览器刷新(点击刷新按钮)。<br>6.driver.close()：关闭当前窗口，或最后打开的窗口。<br>7.driver.quit(): 关闭所有关联窗口，并且安全关闭 session。</p> 
 <p>8.driver.maximize_window(): 最大化浏览器窗口。<br>9.driver.set_window_size(宽，高)：设置浏览器窗口大小。<br>10.driver.get_window_size()：获取当前窗口的长和宽。<br>11.driver.get_window_position()：获取当前窗口坐标。<br>12.driver.get_screenshot_as_file(filename): 截取当前窗口。</p> 
 <p>实例：<strong>driver.get_screenshot_as_file(‘D:/selenium/image/baidu.jpg’)</strong></p> 
 <p>13.driver.implicitly_wait(秒)：隐式等待，通过一定的时长等待页面上某一元素加载完成。<br>若提前定位到元素，则继续执行。若超过时间未加载出，则抛出 NoSuchElementException 异常。</p> 
 <p>实例：<strong>driver.implicitly_wait(10) #等待 10 秒</strong></p> 
 <p>14.driver.switch_to_frame(id 或 name 属性值)：切换到新表单 (同一窗口)。<strong>若无 id 或属性值，可先通过 xpath 定位到 iframe，再将值传给 switch_to_frame()</strong></p> 
 <p>15.driver.switch_to.parent_content(): 跳出当前一级表单。该方法默认对应于离它最近的 switch_to.frame() 方法。</p> 
 <p>16.driver.switch_to.default_content(): 跳回最外层的页面。<br>17.driver.switch_to_window(窗口句柄)：切换到新窗口。<br>18.driver.switch_to.window(窗口句柄): 切换到新窗口。<br>19.driver.switch_to_alert(): 警告框处理。处理 JavaScript 所生成的 alert,confirm,prompt.</p> 
 <p>20.driver.switch_to.alert(): 警告框处理。<br>21.driver.execute_script(js): 调用 js。</p> 
 <p>22.<strong>driver.get_cookies(): 获取当前会话所有 cookie 信息。</strong></p> 
 <p>23.driver.get_cookie(cookie_name)：返回字典的 key 为“cookie_name”的 cookie 信息。</p> 
 <p>实例：<strong>driver.get_cookie(“NET_SessionId”)</strong></p> 
 <p>24.driver.add_cookie(cookie_dict): 添加 cookie。<strong>“cookie_dict”指字典对象，必须有 name 和 value 值。</strong><br>25.driver.delete_cookie(name,optionsString): 删除 cookie 信息。</p> 
 <p>26.driver.delete_all_cookies(): 删除所有 cookie 信息。 </p> 
 <p><strong>页面元素属性：</strong></p> 
 <p>WebElement attributes:</p> 
 <p>[‘<strong>class</strong>’, ‘<strong>delattr</strong>’, ‘<strong>dict</strong>’, ‘<strong>doc</strong>’, ‘<strong>eq</strong>’, ‘<strong>format</strong>’, ‘<strong>getattribute</strong>’, ‘<strong>hash</strong>’, ‘<strong>init</strong>’, ‘<strong>module</strong>’, ‘<strong>ne</strong>’, ‘<strong>new</strong>’, ‘<strong>reduce</strong>’, ‘<strong>reduce_ex</strong>’, ‘<strong>repr</strong>’, ‘<strong>setattr</strong>’, ‘<strong>sizeof</strong>’, ‘<strong>str</strong>’, ‘<strong>subclasshook</strong>’, ‘<strong>weakref</strong>’, ‘_execute’, ‘_id’, ‘_parent’, ‘_upload’, ‘_w3c’, ‘clear’, ‘click’, ‘find_element’, ‘find_element_by_class_name’, ‘find_element_by_css_selector’, ‘find_element_by_id’, ‘find_element_by_link_text’, ‘find_element_by_name’, ‘find_element_by_partial_link_text’, ‘find_element_by_tag_name’, ‘find_element_by_xpath’, ‘find_elements’, ‘find_elements_by_class_name’, ‘find_elements_by_css_selector’, ‘find_elements_by_id’, ‘find_elements_by_link_text’, ‘find_elements_by_name’, ‘find_elements_by_partial_link_text’, ‘find_elements_by_tag_name’, ‘find_elements_by_xpath’, ‘get_attribute’, ‘id’, ‘is_displayed’, ‘is_enabled’, ‘is_selected’, ‘location’, ‘location_once_scrolled_into_view’, ‘parent’, ‘rect’, ‘screenshot’, ‘screenshot_as_base64’, ‘screenshot_as_png’, ‘send_keys’, ‘size’, ‘submit’, ‘tag_name’, ‘text’, ‘value_of_css_property’]<br>调用说明：<br>driver.find_element*. 属性值<br>或<br>element=driver.find_element*<br>element. 属性值<strong>变量说明：</strong><br>1.element.size: 获取元素的尺寸。<br>2.element.text：获取元素的文本。<br>3.element.tag_name: 获取标签名称。<strong>函数说明：</strong><br>1.element.clear(): 清除文本。<br>2.element.send_keys(value): 输入文字或键盘按键(需导入 Keys 模块)。<br>3.element.click()：单击元素。<br>4.element.get_attribute(name): 获得属性值<br>5.element.is_displayed(): 返回元素结果是否可见(True 或 False)<br>6.element.is_selected(): 返回元素结果是否被选中(True 或 False)<br>7.element.find_element*(): 定位元素，用于二次定位。</p> 
 <p>网页自动化最基本的要求就是要定位到各个元素，然后才能对该元素进行各种操作(输入，点击，清除，提交等)。</p> 
 <p>以百度搜索输入框为例，具体说明各个定位方式的用法：</p> 
 <p>(通过 chrome 浏览器查看元素或者搜狐浏览器的 firebug 查看，即可看到 html 源码)</p> 
 <p>注意点：第三行的元素是灰色的，该元素是不可定位到的，下方会说明。</p> 
 <p>1 <br>2 <br>3 <br>4 <br>5 <br>6 <br>7 <br>8 </p> 
 <p><strong>1. 通过 id 定位元素</strong></p> 
 <p>如果 id 不是动态的，一个页面的 id 是唯一的。最简单的定位方式。</p> 
 <p>使用：<strong>find_element_by_id(“id_vaule”)</strong></p> 
 <p>实例：find_element_by_id(“kw”)</p> 
 <p>注意点：有些 id 值是动态变化的，则不能使用该方法定位。如下：id 就是动态的，每次进入页面，该 id 都会改变</p> 
 <p>邮箱帐号或手机号</p> 
 <p><strong>2. 通过 class_name 定位元素</strong></p> 
 <p>classname 有可能重复哦。 </p> 
 <p>使用：<strong>find_element_by_class_name(“class_name_vaule”)</strong></p> 
 <p>实例：find_element_by_class_name(“s_ipt”)</p> 
 <p> <strong>3. 通过 tag_name 定位元素</strong></p> 
 <p>标签名字最容易重复，不过，当定位一组数据时，可使用。</p> 
 <p>使用：<strong>find_element_by_tag_name(“tag_name_vaule”)</strong></p> 
 <p>实例：find_element_by_tag_name(“input”)</p> 
 <p><strong>注意点：当定位一组元素时：可勾选一组复选框。如下：</strong></p> 
 <p>find_element_by_tag_name(“input”)</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/be/b6/U4FVh1y8_o.png" alt="941d62559d40286fc2f31172ced2d3cf.png"> 
 </div> 
 <p><strong>checkbox</strong><br>checkbox1<br>checkbox2<br>checkbox3<strong>4. 通过 name 定位元素</strong></p> 
 <p>name 有可能会重复哦。 </p> 
 <p>使用：<strong>find_element_by_name(“name_vaule”)</strong></p> 
 <p>实例：find_element_by_name(“wd”)</p> 
 <p><strong>5. 通过 link 文字精确定位元素</strong></p> 
 <p>登录</p> 
 <p>使用：<strong>find_element_by_link_text(“text_vaule”)</strong></p> 
 <p>实例：find_element_by_link_text(“登录”)</p> 
 <p><strong>6. 通过 link 文字模糊定位元素</strong></p> 
 <p>使用：<strong>find_element_by_partial_link_text(“部分 text_vaule”)</strong></p> 
 <p>实例：find_element_by_partial_link_text(“登”)</p> 
 <p><strong>7. 通过 CSS 定位元素</strong></p> 
 <p>CSS(Cascading Style Sheets)是一种语言，它用来描述 HTML 和 XML 文档的表现。CSS 可以较为灵活的选择控件的任意属性，一般情况下会比 XPath 快。且语法也比较简洁。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/50/78/3BhlBGsO_o.png" alt="ab08eda82b1851b3b497da6ccb6ff9ab.png"> 
 </div> 
 <p><br>使用：<strong>find_element_by_css_selector(“CSS”)</strong></p> 
 <p>实例：</p> 
 <p><strong>7.1 通过 id 属性定位元素</strong></p> 
 <p><strong>#号表示通过 id 属性来定位元素</strong></p> 
 <p>find_element_by_css_selector(“#kw”)</p> 
 <p><strong>7.2 通过 class 属性定位元素</strong></p> 
 <p><strong>. 号表示通过 class 属性来定位元素</strong></p> 
 <p>find_element_by_css_selector(“.s_ipt”)</p> 
 <p><strong>7.3 通过标签名定位元素</strong></p> 
 <p>find_element_by_css_selector(“input”)</p> 
 <p><strong>7.4 通过属性定位元素(挺常用的)</strong></p> 
 <p>find_element_by_css_selector(“[name=‘wd’]”)</p> 
 <p>find_element_by_css_selector(“[maxlength=‘255’]”)</p> 
 <p>属性值包含某个值</p> 
 <p><strong>属性值包含 wd：适用于由空格分隔的属性值。</strong></p> 
 <p>find_element_by_css_selector(“[name~=‘wd’]”)</p> 
 <p><strong>7.5 父子定位元素</strong></p> 
 <p>查找有父亲元素的标签名为 span，它的所有标签名叫 input 的子元素</p> 
 <p>**find_element_by_css_selector(“span&gt;input”) **</p> 
 <p><strong>7.6 组合定位元素</strong></p> 
 <p><strong>标签名 #id 属性值：指的是该 input 标签下 id 属性为 kw 的元素</strong></p> 
 <p><strong>find_element_by_css_selector(“input#kw”)</strong></p> 
 <p><strong>标签名.class 属性值：指的是该 input 标签下 class 属性为 s_ipt 的元素</strong></p> 
 <p><strong>find_element_by_css_selector(“input.s_ipt”)</strong></p> 
 <p><strong>标签名 [属性 =’属性值‘]：指的是该 input 标签下 name 属性为 wd 的元素</strong></p> 
 <p><strong>find_element_by_css_selector(“input[name=‘wd’]”)</strong></p> 
 <p><strong>父元素标签名 &gt; 标签名.class 属性值：指的是 span 下的 input 标签下 class 属性为 s_ipt 的元素</strong></p> 
 <p><strong>find_element_by_css_selector(“span&gt;input.s_ipt”)</strong></p> 
 <p> 多个属性组合定位元素(挺常用的)</p> 
 <p>指的是 input 标签下 id 属性为 kw 且 name 属性为 wd 的元素</p> 
 <p>find_element_by_css_selector(<strong>“input.s_ipt[name=‘wd’]”</strong>)</p> 
 <p>指的是 input 标签下 name 属性为 wd 且 maxlength 为 255 的元素</p> 
 <p>find_element_by_css_selector(<strong>“input[name=‘wd’][maxlength='255']”</strong>) </p> 
 <p>8. 通过 XPath 定位元素</p> 
 <p>XPath 是一种 XML 文档中定位元素的语言。该定位方式也是比较常用的定位方式。</p> 
 <p>使用：<strong>find_element_by_xpath(“XPath”)</strong></p> 
 <p><strong>8.1 通过属性定位元素</strong></p> 
 <p><strong>find_element_by_xpath(“// 标签名 [@属性 =‘属性值’]”)</strong></p> 
 <p>id 属性：find_element_by_xpath(<strong>“//input[@id=‘kw’]”</strong>)<br>​<br>class 属性：find_element_by_xpath(<strong>“//input[@class=‘s_ipt’]”</strong>)</p> 
 <p>name 属性：find_element_by_xpath(<strong>“//input[@name=‘wd’]”</strong>)</p> 
 <p>maxlength 属性：find_element_by_xpath(<strong>“//input[@maxlength=‘255’]”</strong>)</p> 
 <p><strong>8.2 通过标签名定位元素</strong></p> 
 <p>指所有 input 标签元素 find_element_by_xpath(<strong>“//input”</strong>)</p> 
 <p><strong>8.3 父子定位元素</strong></p> 
 <p>查找有父亲元素的标签名为 span，它的所有标签名叫 input 的子元素</p> 
 <p>find_element_by_xpath(<strong>“//span/input”</strong>) </p> 
 <p><strong>8.4 根据元素内容定位元素(非常实用)</strong></p> 
 <p>find_element_by_xpath(<strong>“//p[contains(text(),‘京公网’)]”</strong>) </p> 
 <p>京公网安备 11000002000001 号</p> 
 <p>注：contains 的另一种用法</p> 
 <p>//**input[contains(@class,‘s’)] **<strong>说明 class 属性包含 s 的元素</strong>。</p> 
 <p><strong>8.5 组合定位元素</strong></p> 
 <p>// 父元素标签名 / 标签名的属性值：指的是 span 下的 input 标签下 class 属性为 s_ipt 的元素</p> 
 <p>find_element_by_xpath(<strong>“//span/input[@class=‘s_ipt’]”</strong>)</p> 
 <p><strong>多个属性组合定位(挺常用的)</strong></p> 
 <p>指的是 input 标签下 id 属性为 kw 且 name 属性为 wd 的元素</p> 
 <p>find_element_by_xpath(<strong>“//input[@class=‘s_ipt’ and @name=‘wd’]”</strong>)</p> 
 <p>指的是 p 标签下内容包含“京公网”且 id 属性为 jgwab 的元素</p> 
 <p>find_element_by_xpath(<strong>“//p[contains(text(),‘京公网’)and @id=‘jgwab’]”</strong>) </p> 
 <p>比较懒惰的方法：</p> 
 <p>使用搜狐浏览器的 firebug 工具，复制 XPath 路径，不过这种方式对层级要求高，到时候自己再修改下。</p> 
 <p><strong>9. 通过 By 定位元素</strong></p> 
 <p>使用：find_element(定位的类型，具体定位方式)</p> 
 <p>定位的类型包括 By.ID,By.NAME,By.CLASS_NAME,By.TAG_NAME,By.LINK_TEXT,By.PARTIAL_LINK_TEXT,By.XPATH,By.CSS_SELECTOR</p> 
 <p>具体定位方式参考上方 1-8 的说明。</p> 
 <p>实例：<strong>find_element(By.ID,‘kw’)</strong></p> 
 <p><strong>注意：使用 By 定位方式，需先导入 By 类</strong>。</p> 
 <p><strong>from selenium.webdriver.common.by import By</strong><br>10. 具体实例说明</p> 
 <p>下方例子是登陆 126 邮件，然后发送邮件。</p> 
 <p>1 # coding=utf-8<br> 2 '''<br> 3 Created on 2016-7-27<br> 4 @author: Jennifer<br> 5 Project: 发送邮件<br> 6 '''<br> 7 from selenium import webdriver<br> 8 import time<br> 9 <br>10 from test_5_2_public import Login # 由于公共模块文件命名为 test_5_2_public<br>11 driver=webdriver.Firefox()<br>12 <strong>driver.implicitly_wait(30)</strong><br>13 driver.get(r’http://www.126.com/‘) # 字符串加 r，防止转义。<br>14 time.sleep(3)<br>15 <strong>driver.switch_to.frame(‘x-URS-iframe’)</strong><br>16 #调用登录模块<br>17 Login().user_login(driver)<br>18 time.sleep(10)<br>19 #发送邮件<br>20 #点击发件箱<br>21 #_mail_component_61_61 是动态 id，所以不能用于定位<br>22 #driver.find_element_by_css_selector(’#_mail_component_61_61&gt;span.oz0’).click()<br>23 #不能加 u"//span[contains(text(),u’写 信’)]“，否则定位不到。<br>24 #以下定位是查找 span 标签有个文本(text)包含(contains)‘写 信’ 的元素，该定位方法重要<br>25 **driver.find_element_by_xpath(”//span[contains(text(),‘写 信’)]“).click()**<br>26 #填写收件人<br>27 #driver.find_element_by_class_name(‘nui-editableAddr-ipt’).send_keys(r’xxx@doov.com.cn’)<br>28 <strong>driver.find_element_by_class_name(‘nui-editableAddr-ipt’).send_keys(r’xxx@163.com’)</strong><br>29 #填写主题<br>30 #通过 and 连接更多的属性来唯一地标志一个元素<br>31 **driver.find_element_by_xpath(”//input[@class=‘nui-ipt-input’ and @maxlength=‘256’]“).send_keys(u’自动化测试’)**<br>32 #填写正文<br>33 #通过 switch_to_frame() 将当前定位切换到 frame/iframe 表单的内嵌页面中<br>34 driver.switch_to_frame(driver.find_element_by_class_name(‘APP-editor-iframe’))<br>35 #在内嵌页面中定位邮件内容位置<br>36 <strong>emailcontext=driver.find_element_by_class_name(‘nui-scroll’)</strong><br>37 #填写邮件内容<br>38** emailcontext.send_keys(u’这是第一封自动化测试邮件’)**<br>39 #通过 switch_to().default_content() 跳回最外层的页面<br>40 #注：不要写成 switch_to().default_content(), 否则报 AttributeError: SwitchTo instance has no <strong>call</strong> method<br>41 <strong>driver.switch_to.default_content()</strong><br>42 #driver.switch_to.parent_frame()<br>43 #点击发送<br>44 time.sleep(3)<br>45 #有可能存在元素不可见(查看元素是灰色的)，会报 ElementNotVisibleException 错误<br>46 #包含发送二字的元素很多，所以还得再加上其他限制<br>47 #sendemails=driver.find_element_by_xpath(”//span[contains(text(),‘发送’)]“)<br>48 **sendemails=driver.find_element_by_xpath(”//span[contains(text(),‘发送’)and @class=‘nui-btn-text’]")**<br>49 time.sleep(3)<br>50 <br>51 #校验邮件是否发送成功<br>52 try:<br>53 <strong>assert ‘发送成功’ in driver.page_source</strong><br>54 except AssertionError:<br>55 print ‘邮件发送成功’<br>56 else:<br>57 print ‘邮件发送失败’<br>58 <br>59 #调用退出模块 <br>60 Login().user_logout(driver)</p> 
 <p>元素定位说明：<br>1. 代码 22 行，定位不到是因为 id 是动态的，所以需采取其他方式定位元素。</p> 
 <p>2. 代码 25 行，是根据元素内容来定位的，具体用法详看 8.4.</p> 
 <p>3. 代码 28 行，是根据 class 名来定位元素的，由于该值在该页面上是唯一的，所以可以用它来定位。</p> 
 <p>4. 代码 31 行，是使用逻辑运算符 and 连接更多的属性从而唯一的标志一个元素，具体用法详看 8.5.</p> 
 <p>5. 代码 34 行，由于使用内嵌的 iframe 框架，<strong>所以需要先使用 switch_to_frame() 移到该表单上，才能定位该表单上的元素</strong>，非常重要，否则无论怎么定位都会报“NoSuchElementException”，找不到该元素。</p> 
 <p>6. 代码 41 行，跳出 iframe 框架，<strong>当框架内的动作操作完毕后，需要使用 switch_to.default_content 跳出 iframe 框架, 非常重要。</strong></p> 
 <p>7. 代码 47 行，由于内容包括“发送”的元素中包含不可见元素(html 查看元素可以看到此行是灰色的)，这样有可能定位到不可见元素，会报“ElementNotVisibleException”。</p> 
 <p>8. 代码 48 行，是使用逻辑运算符 and 连接更多的属性从而唯一的标志一个元素，具体用法详看 8.5. 这样可以排除掉那个不可见元素。 </p> 
 <p>1.Frame/Iframe 原因定位不到元素：<br>　　这个是最常见的原因，首先要理解下 frame 的实质，<strong>frame 中实际上是嵌入了另一个页面，而 webdriver 每次只能在一个页面识别，因此需要先定位到相应的 frame</strong>，对那个页面里的元素进行定位。<br>​<br>解决方案：<br>​<br>如果 iframe 有 name 或 id 的话，<strong>直接使用 switch_to_frame(“name 值”) 或 switch_to_frame(“id 值”)</strong>。<br>​<br>​如下：<br>driver=webdriver.Firefox()<br>driver.get(r’http://www.126.com/’)<strong>driver.switch_to_frame(‘x-URS-iframe’) # 需先跳转到 iframe 框架</strong><br>username=driver.find_element_by_name(‘email’)<br>username.clear()<br>如果 iframe 没有 name 或 id 的话，则可以通过下面的方式定位：<strong>#先定位到 iframe</strong><strong>elementi= driver.find_element_by_class_name(‘APP-editor-iframe’)</strong><strong>#再将定位对象传给 switch_to_frame() 方法</strong><strong>driver.switch_to_frame(elementi)</strong> <br>如果完成操作后，<br>​<strong>可以通过 switch_to.parent_content()方法跳出当前 iframe，或者还可以通过 switch_to.default_content() 方法跳回最外层的页面。<br>​</strong></p> 
 <p> <br>2.Xpath 描述错误原因：<br>​<br> 由于 Xpath 层级太复杂，容易犯错。但是该定位方式能够有效定位绝大部分的元素，建议掌握。<br>解决方案：<br>​<br>2.1 可以使用 Firefox 的 firePath，复制 xpath 路径。该方式容易因为层级改变而需要重新编写过 xpath 路径，不建议使用，初学者可以先复制路径，然后尝试去修改它。<br>​<br>2.2 提高下写 xpath 的水平。</p> 
 <p> <br>如何检验编写的 Xpath 是否正确？编写好 Xpath 路径，<strong>可以直接复制到搜狐浏览器的 firebug 查看 html 源码，通过 Xpath 搜索</strong>：如下红色框，若无报错，则说明编写的 Xpath 路径没错。<br>​<br>**find_element_by_xpath(“//input[@id=‘kw’]”) **</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/8b/4a/JravnZHT_o.png" alt="9ecf9704435a73dae9b10c7175857353.png"> 
 </div> 
 <p>​</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/3f/fc/6kOJVLlo_o.png" alt="a02ef55c55883bd6c9f568abcb79bbea.png"> 
 </div> 
 <p>​</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/81/2e/WaWdSNVU_o.png" alt="ea8bff522fe72e0f15f010c76ba21da6.png"> 
 </div> 
 <p>​3. 页面还没有加载出来，就对页面上的元素进行的操作：<br> 这种情况一般说来，可以设置等待，等待页面显示之后再操作，这与人手工操作的原理一样：<br>3.1 设置等待时间；缺点是需要设置较长的等待时间，案例多了测试就很慢；<br>3.2 设置等待页面的某个元素出现，比如一个文本、一个输入框都可以，一旦指定的元素出现，就可以做操作。<br>3.3 在调试的过程中可以把页面的 html 代码打印出来，以便分析。<br>​<br>解决方案：<br>导入时间模块。<br>import time<br>time.sleep(3)<br>4. 动态 id 定位不到元素：<br>解决方案：<br>如果发现是动态 id，直接用 xpath 定位或其他方式定位。 </p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/b6/2f/AZTWqRBh_o.png" alt="fd07db943a0a822e2d43e17f5a8b61f1.png"> 
 </div> 
 <p>​</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/93/29/FJNGxIfO_o.png" alt="a13b18b05867b70b2de757529348adec.png"> 
 </div> 
 <p>​​</p> 
 <p>5. 二次定位，如弹出框登录<br>​<br> 如百度登录弹出框登录百度账号，需先定位到百度弹出框，然后再定位到用户名密码登录。</p> 
 <p>#coding=utf-8<br>'''<br>Created on 2016-7-20<br>@author: Jennifer<br>Project: 登录百度账号<br>'''<br>from selenium import webdriver<br>import time</p> 
 <p>driver = webdriver.Firefox()<br>driver.get(“http://www.baidu.com/”)</p> 
 <p>time.sleep(3)</p> 
 <p>#点击登录：有些 name 为 tj_login 的元素为不可见的，点击可见的那个登录按钮即可。<br>#否则会报：ElementNotVisibleException<br>element0=driver.find_elements_by_name(“tj_login”)<br>for ele0 in element0:<br> if ele0.is_displayed():<br> ele0.click()</p> 
 <p>#在登录弹出框，需先定位到登录弹出框<br>#否则会报：NoSuchElementException<br>element1=driver.find_element_by_class_name(“tang-content”)<br>element11=element1.find_element_by_id(“TANGRAM__PSP_8__userName”)<br>element11.clear()<br>element11.send_keys(“登录名”)</p> 
 <p>element2=element1.find_element_by_id(“TANGRAM__PSP_8__password”)<br>element2.clear()<br>element2.send_keys(“密码”)</p> 
 <p>element3=element1.find_element_by_id(“TANGRAM__PSP_8__submit”)<br>element3.click()<br>element3.submit()</p> 
 <p>try:<br> assert “登录名” in driver.page_source<br>except AssertionError:<br> print “登录失败”<br>else:<br> print “登录成功”<br> time.sleep(3)<br>finally:<br> print “测试记录：已测试”<br>driver.close()</p> 
 <p>6. 不可见元素定位</p> 
 <p> 如上百度登录代码，通过名称为 tj_login 查找的登录元素，有些是不可见的，所以加一个循环判断，找到可见元素(is_displayed())点击登录即可。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bbebfa47f7e6fa02bf0659f777132677/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VS Code 使用火狐 FireFox 调试网页</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/387d91bfddd00d5f90a5d3ae7d5b8ffa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">antimalware service executable占用内存过高_Win10系统svchost.exe进程占用内存和网速过高的解决方法...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>