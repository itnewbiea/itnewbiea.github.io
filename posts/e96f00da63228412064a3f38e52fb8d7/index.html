<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用的Java开发工具类 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常用的Java开发工具类" />
<meta property="og:description" content="前言 在java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：轮子。
如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。
今天我决定把一些压箱底的小工具，分享给大家，希望对你有所帮助。
本文会分享17个我们日常工作中一定会用得到的小工具，主要内容如下：
1. Collections 首先出场的是java.util包下的Collections类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。
1.1 排序 在工作中经常有对集合排序的需求。
看看使用Collections工具是如何实现升序和降序的：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Collections.sort(list);//升序 System.out.println(list); Collections.reverse(list);//降序 System.out.println(list); 执行结果：
[1, 2, 3] [3, 2, 1] 1.2 获取最大或最小值 有时候需要找出集合中的最大值或者最小值，这时可以使用Collections的max和min方法。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); Integer max = Collections.max(list);//获取最大值 Integer min = Collections.min(list);//获取最小值 System.out.println(max); System.out.println(min); 执行结果：
3 1 1.3 转换线程安全集合 我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。
换句话说，这些集合在多线程的环境中，添加数据会出现异常。
这时，可以用Collections的synchronizedxxx方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：
List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(1); list.add(3); List&lt;Integer&gt; integers = Collections." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/e96f00da63228412064a3f38e52fb8d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T18:29:27+08:00" />
<meta property="article:modified_time" content="2022-08-30T18:29:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用的Java开发工具类</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>在java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：<code>轮子</code>。</p> 
<p>如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。</p> 
<p>今天我决定把一些压箱底的小工具，分享给大家，希望对你有所帮助。</p> 
<p>本文会分享17个我们日常工作中一定会用得到的小工具，主要内容如下：</p> 
<h3>1. Collections</h3> 
<p>首先出场的是<code>java.util</code>包下的<code>Collections</code>类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。</p> 
<h4>1.1 排序</h4> 
<p>在工作中经常有对集合排序的需求。</p> 
<p>看看使用<code>Collections</code>工具是如何实现升序和降序的：</p> 
<pre><code class="language-java">  List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  list.add(2);
  list.add(1);
  list.add(3);
  Collections.sort(list);//升序
  System.out.println(list);
  Collections.reverse(list);//降序
  System.out.println(list);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">[1, 2, 3]
[3, 2, 1]</code></pre> 
<h4>1.2 获取最大或最小值</h4> 
<p>有时候需要找出集合中的<code>最大值</code>或者<code>最小值</code>，这时可以使用Collections的<code>max</code>和<code>min</code>方法。例如：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);
Integer max = Collections.max(list);//获取最大值
Integer min = Collections.min(list);//获取最小值
System.out.println(max);
System.out.println(min);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">3
1</code></pre> 
<h4>1.3 转换线程安全集合</h4> 
<p>我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。</p> 
<p>换句话说，这些集合在多线程的环境中，添加数据会出现异常。</p> 
<p>这时，可以用Collections的<code>synchronizedxxx</code>方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：</p> 
<pre><code class="language-java">  List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
  list.add(2);
  list.add(1);
  list.add(3);

  List&lt;Integer&gt; integers = Collections.synchronizedList(list);//将ArrayList转换成线程安全集合
  System.out.println(integers);</code></pre> 
<p>它的底层会创建<code>SynchronizedRandomAccessList</code>或者<code>SynchronizedList</code>类，这两个类的很多方法都会用<code>synchronized</code>加锁。</p> 
<h4>1.4 返回空集合</h4> 
<p>有时，我们在判空之后，需要返回空集合，就可以使用<code>emptyList</code>方法，例如：</p> 
<pre><code class="language-java">private List&lt;Integer&gt; fun(List&lt;Integer&gt; list) {
    if (list == null || list.size() == 0) {
        return Collections.emptyList();
    }
    //业务处理
    return list;
}
</code></pre> 
<h4>1.5 二分查找</h4> 
<p><code>binarySearch</code>方法提供了一个非常好用的<code>二分查找</code>功能，只用传入指定集合和需要找到的key即可。例如：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

int i = Collections.binarySearch(list, 3);//二分查找
System.out.println(i );
</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">2</code></pre> 
<h4>1.6 转换成不可修改集合</h4> 
<p>为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的<code>unmodifiablexxx</code>方法就能轻松实现：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

List&lt;Integer&gt; integers = Collections.unmodifiableList(list);
integers.add(4);
System.out.println(integers);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">Exception in thread "main" java.lang.UnsupportedOperationException
	at java.util.Collections$UnmodifiableCollection.add(Collections.java:1055)
	at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:19)</code></pre> 
<p>当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cd/d6/7FWUbn4i_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/22/b0/HulCIQ43_o.png"></p> 
<h3>2. CollectionUtils</h3> 
<p>对集合操作，除了前面说的<code>Collections</code>工具类之后，<code>CollectionUtils</code>工具类也非常常用。</p> 
<p>目前比较主流的是<code>spring</code>的<code>org.springframework.util</code>包下的CollectionUtils工具类。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7a/c1/xm5Q43GT_o.png"></p> 
<p>和<code>apache</code>的<code>org.apache.commons.collections</code>包下的CollectionUtils工具类。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/45/93/O6P1gns1_o.png"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ce/32/uTfockOA_o.png"></p> 
<blockquote> 
 <p>我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。</p> 
</blockquote> 
<p>举个简单的例子，<code>spring</code>的CollectionUtils工具类没有判断集合不为空的方法。而<code>apache</code>的CollectionUtils工具类却有。</p> 
<p>下面我们以<code>apache</code>的CollectionUtils工具类为例，介绍一下常用方法。</p> 
<h4>2.1 集合判空</h4> 
<p>通过CollectionUtils工具类的<code>isEmpty</code>方法可以轻松判断集合是否为空，<code>isNotEmpty</code>方法判断集合不为空。</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

if (CollectionUtils.isEmpty(list)) {
    System.out.println("集合为空");
}

if (CollectionUtils.isNotEmpty(list)) {
    System.out.println("集合不为空");
}</code></pre> 
<h4>2.2 对两个集合进行操作</h4> 
<p>有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(1);
list.add(3);

List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
list2.add(2);
list2.add(4);

//获取并集
Collection&lt;Integer&gt; unionList = CollectionUtils.union(list, list2);
System.out.println(unionList);

//获取交集
Collection&lt;Integer&gt; intersectionList = CollectionUtils.intersection(list, list2);
System.out.println(intersectionList);

//获取交集的补集
Collection&lt;Integer&gt; disjunctionList = CollectionUtils.disjunction(list, list2);
System.out.println(disjunctionList);

//获取差集
Collection&lt;Integer&gt; subtractList = CollectionUtils.subtract(list, list2);
System.out.println(subtractList);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">[1, 2, 3, 4]
[2]
[1, 3, 4]
[1, 3]</code></pre> 
<p>说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。</p> 
<h3>3. Lists</h3> 
<p>如果你引入<code>com.google.guava</code>的pom文件，会获得很多好用的小工具。这里推荐一款<code>com.google.common.collect</code>包下的集合工具：<code>Lists</code>。</p> 
<p>它是在太好用了，让我爱不释手。</p> 
<h4>3.1 创建空集合</h4> 
<p>有时候，我们想创建一个空集合。这时可以用Lists的<code>newArrayList</code>方法，例如：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = Lists.newArrayList();</code></pre> 
<h4>3.2 快速初始化集合</h4> 
<p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">[1, 2, 3]</code></pre> 
<h4>3.3 笛卡尔积</h4> 
<p>如果你想将两个集合做<code>笛卡尔积</code>，Lists的<code>cartesianProduct</code>方法可以帮你实现：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list1 = Lists.newArrayList(1, 2, 3);
List&lt;Integer&gt; list2 = Lists.newArrayList(4,5);
List&lt;List&lt;Integer&gt;&gt; productList = Lists.cartesianProduct(list1,list2);
System.out.println(productList);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]</code></pre> 
<h4>3.4 分页</h4> 
<p>如果你想将一个<code>大集合</code>分成若干个<code>小集合</code>，可以使用Lists的<code>partition</code>方法：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5);
List&lt;List&lt;Integer&gt;&gt; partitionList = Lists.partition(list, 2);
System.out.println(partitionList);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">[[1, 2], [3, 4], [5]]</code></pre> 
<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p> 
<p>这个是我最喜欢的方法之一，经常在项目中使用。</p> 
<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p> 
<h4>3.5 流处理</h4> 
<p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的 <code>transform</code>方法。例如：</p> 
<pre><code class="language-java">List&lt;String&gt; list = Lists.newArrayList("a","b","c");
List&lt;String&gt; transformList = Lists.transform(list, x -&gt; x.toUpperCase());
System.out.println(transformList);</code></pre> 
<p>将小写字母转换成了大写字母。</p> 
<h4>3.6 颠倒顺序</h4> 
<p>Lists的有颠倒顺序的方法<code>reverse</code>。例如：</p> 
<pre><code class="language-java">List&lt;Integer&gt; list = Lists.newArrayList(3, 1, 2);
List&lt;Integer&gt; reverseList = Lists.reverse(list);
System.out.println(reverseList);</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">[2, 1, 3]</code></pre> 
<p>list的原始顺序是312，使用<code>reverse</code>方法颠倒顺序之后，变成了213。</p> 
<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ef/6b/HbF9Z1Sm_o.png"></p> 
<h3>4. Objects</h3> 
<p>在<code>jdk7</code>之后，提供了<code>Objects</code>工具类，我们可以通过它操作对象。</p> 
<h4>4.1 对象判空</h4> 
<p>在java中万事万物皆对象，对象的判空可以说无处不在。Objects的<code>isNull</code>方法判断对象是否为空，而<code>nonNull</code>方法判断对象是否不为空。例如：</p> 
<pre><code class="language-java">Integer integer = new Integer(1);

if (Objects.isNull(integer)) {
    System.out.println("对象为空");
}

if (Objects.nonNull(integer)) {
    System.out.println("对象不为空");
}</code></pre> 
<h4>4.2 对象为空抛异常</h4> 
<p>如果我们想在对象为空时，抛出空指针异常，可以使用Objects的<code>requireNonNull</code>方法。例如：</p> 
<pre><code class="language-java">Integer integer1 = new Integer(128);

Objects.requireNonNull(integer1);
Objects.requireNonNull(integer1, "参数不能为空");
Objects.requireNonNull(integer1, () -&gt; "参数不能为空");</code></pre> 
<h4>4.3 判断两个对象是否相等</h4> 
<p>我们经常需要判断两个对象是否相等，Objects给我们提供了<code>equals</code>方法，能非常方便的实现：</p> 
<pre><code class="language-java">Integer integer1 = new Integer(1);
Integer integer2 = new Integer(1);

System.out.println(Objects.equals(integer1, integer2));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">true</code></pre> 
<p>但使用这个方法有坑，比如例子改成：</p> 
<pre><code class="language-java">Integer integer1 = new Integer(1);
Long integer2 = new Long(1);

System.out.println(Objects.equals(integer1, integer2));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">false</code></pre> 
<p>具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247493176%26idx%3D1%26sn%3Dc445625478a7f8122a6715b64fe6770c%26chksm%3Dc0e83ed0f79fb7c6cf2992d24e98f60fd78ca89525b5a3cc07f79dc801dd8e381b1fce03bf5c%26token%3D1124974571%26lang%3Dzh_CN%23rd" rel="nofollow" title="Objects.equals有坑">Objects.equals有坑</a>》，里面有非常详细的讲解。</p> 
<h4>4.4 获取对象的hashCode</h4> 
<p>如果你想获取某个对象的hashCode，可以使用Objects的<code>hashCode</code>方法。例如：</p> 
<pre><code class="language-java">String str = new String("abc");
System.out.println(Objects.hashCode(str));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">96354</code></pre> 
<p>Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bf/15/CivpEWZY_o.png"></p> 
<h3>5. BooleanUtils</h3> 
<p>在java中布尔值，随处可见。</p> 
<p>如果你使用了布尔的包装类：<code>Boolean</code>，总感觉有点麻烦，因为它有三种值：<code>null</code>、<code>true</code>、<code>false</code>。我们在处理Boolean对象时，需要经常判空。</p> 
<p>头疼！！！</p> 
<p>但如果使用<code>BooleanUtils</code>类处理布尔值，心情一下子就愉悦起来了。</p> 
<h4>5.1 判断true或false</h4> 
<p>如果你想判断某个参数的值是true或false，可以直接使用<code>isTrue</code>或<code>isFalse</code>方法。例如：</p> 
<pre><code class="language-java">Boolean aBoolean = new Boolean(true);
System.out.println(BooleanUtils.isTrue(aBoolean));
System.out.println(BooleanUtils.isFalse(aBoolean));</code></pre> 
<h4>5.2 判断不为true或不为false</h4> 
<p>有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。</p> 
<p>可以使用<code>isNotTrue</code>或<code>isNotFalse</code>方法。例如：</p> 
<pre><code class="language-java">Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = null;
System.out.println(BooleanUtils.isNotTrue(aBoolean));
System.out.println(BooleanUtils.isNotTrue(aBoolean1));
System.out.println(BooleanUtils.isNotFalse(aBoolean));
System.out.println(BooleanUtils.isNotFalse(aBoolean1));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">false
true
true
true</code></pre> 
<h4>5.3 转换成数字</h4> 
<p>如果你想将true转换成数字1，false转换成数字0，可以使用<code>toInteger</code>方法：</p> 
<pre><code class="language-java">Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = new Boolean(false);
System.out.println(BooleanUtils.toInteger(aBoolean));
System.out.println(BooleanUtils.toInteger(aBoolean1));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">1
0</code></pre> 
<h4>5.4 Boolean转换成布尔值</h4> 
<p>我们有时候需要将包装类<code>Boolean</code>对象，转换成原始的<code>boolean</code>对象，可以使用<code>toBoolean</code>方法。例如：</p> 
<pre><code class="language-java">Boolean aBoolean = new Boolean(true);
Boolean aBoolean1 = null;
System.out.println(BooleanUtils.toBoolean(aBoolean));
System.out.println(BooleanUtils.toBoolean(aBoolean1));
System.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, false));</code></pre> 
<p>我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。</p> 
<p>BooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/6d/z9jFEMxK_o.png"></p> 
<h3>6. StringUtils</h3> 
<p><code>字符串</code>（String）在我们的日常工作中，用得非常非常非常多。</p> 
<p>在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。</p> 
<p>如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。</p> 
<p>现在有个好消息是：<code>org.apache.commons.lang3</code>包下的<code>StringUtils</code>工具类，给我们提供了非常丰富的选择。</p> 
<h4>6.1 字符串判空</h4> 
<p>其实空字符串，不只是null一种，还有""，" "，"null"等等，多种情况。</p> 
<p>StringUtils给我们提供了多个判空的静态方法，例如：</p> 
<pre><code class="language-java"> String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "abc";
System.out.println(StringUtils.isEmpty(str1));
System.out.println(StringUtils.isEmpty(str2));
System.out.println(StringUtils.isEmpty(str3));
System.out.println(StringUtils.isEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotEmpty(str1));
System.out.println(StringUtils.isNotEmpty(str2));
System.out.println(StringUtils.isNotEmpty(str3));
System.out.println(StringUtils.isNotEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isBlank(str1));
System.out.println(StringUtils.isBlank(str2));
System.out.println(StringUtils.isBlank(str3));
System.out.println(StringUtils.isBlank(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotBlank(str1));
System.out.println(StringUtils.isNotBlank(str2));
System.out.println(StringUtils.isNotBlank(str3));
System.out.println(StringUtils.isNotBlank(str4));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">true
true
false
false
=====
false
false
true
true
=====
true
true
true
false
=====
false
false
false
true</code></pre> 
<p>示例中的：<code>isEmpty</code>、<code>isNotEmpty</code>、<code>isBlank</code>和<code>isNotBlank</code>，这4个判空方法你们可以根据实际情况使用。</p> 
<blockquote> 
 <p>优先推荐使用<code>isBlank</code>和<code>isNotBlank</code>方法，因为它会把<code>" "</code>也考虑进去。</p> 
</blockquote> 
<h4>6.2 分隔字符串</h4> 
<p>分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。</p> 
<pre><code class="language-java">String str1 = null;
System.out.println(StringUtils.split(str1,","));
System.out.println(str1.split(","));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">null
Exception in thread "main" java.lang.NullPointerException
	at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)</code></pre> 
<p>使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。</p> 
<h4>6.3 判断是否纯数字</h4> 
<p>给定一个字符串，判断它是否为纯数字，可以使用<code>isNumeric</code>方法。例如：</p> 
<pre><code class="language-java">String str1 = "123";
String str2 = "123q";
String str3 = "0.33";
System.out.println(StringUtils.isNumeric(str1));
System.out.println(StringUtils.isNumeric(str2));
System.out.println(StringUtils.isNumeric(str3));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">true
false
false</code></pre> 
<h4>6.4 将集合拼接成字符串</h4> 
<p>有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用<code>join</code>方法。例如：</p> 
<pre><code class="language-java">List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
List&lt;Integer&gt; list2 = Lists.newArrayList(1, 2, 3);
System.out.println(StringUtils.join(list, ","));
System.out.println(StringUtils.join(list2, " "));</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">a,b,c
1 2 3</code></pre> 
<p>当然还有很多实用的方法，我在这里就不一一介绍了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/b9/2MS2Hm40_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1e/b2/KXKM3jlr_o.png"></p> 
<h3>7. Assert</h3> 
<p>很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。</p> 
<p>有没有统一的封装呢?</p> 
<p>其实<code>spring</code>给我们提供了<code>Assert</code>类，它表示<code>断言</code>。</p> 
<h4>7.1 断言参数是否为空</h4> 
<p>断言<code>参数</code>是否空，如果不满足条件，则直接抛异常。</p> 
<pre><code class="language-java">String str = null;
Assert.isNull(str, "str必须为空");
Assert.isNull(str, () -&gt; "str必须为空");
Assert.notNull(str, "str不能为空");</code></pre> 
<p>如果不满足条件就会抛出<code>IllegalArgumentException</code>异常。</p> 
<h4>7.2 断言集合是否为空</h4> 
<p>断言<code>集合</code>是否空，如果不满足条件，则直接抛异常。</p> 
<pre><code class="language-java">List&lt;String&gt; list = null;
Map&lt;String, String&gt; map = null;
Assert.notEmpty(list, "list不能为空");
Assert.notEmpty(list, () -&gt; "list不能为空");
Assert.notEmpty(map, "map不能为空");</code></pre> 
<p>如果不满足条件就会抛出<code>IllegalArgumentException</code>异常。</p> 
<h4>7.3 断言条件是否为空</h4> 
<p>断言是否满足某个<code>条件</code>，如果不满足条件，则直接抛异常。</p> 
<pre><code class="language-java">List&lt;String&gt; list = null;
Assert.isTrue(CollectionUtils.isNotEmpty(list), "list不能为空");
Assert.isTrue(CollectionUtils.isNotEmpty(list), () -&gt; "list不能为空");</code></pre> 
<p>当然Assert类还有一些其他的功能，这里就不多介绍了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f1/11/fh1oHlYb_o.png"></p> 
<h3>8. IOUtils</h3> 
<p><code>IO</code>流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。</p> 
<p>但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在<code>finally</code>代码块中关闭流，不然可能会造成<code>内存溢出</code>。</p> 
<p>有个好消息是：如果你使用<code>org.apache.commons.io</code>包下的<code>IOUtils</code>类，会节省大量的时间。</p> 
<h4>8.1 读取文件</h4> 
<p>如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的<code>toString</code>方法。例如：</p> 
<pre><code class="language-java">String str = IOUtils.toString(new FileInputStream("/temp/a.txt"), StandardCharsets.UTF_8);
System.out.println(str);</code></pre> 
<h4>8.2 写入文件</h4> 
<p>如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的<code>write</code>方法。例如：</p> 
<pre><code class="language-java">String str = "abcde";
IOUtils.write(str, new FileOutputStream("/temp/b.tx"), StandardCharsets.UTF_8);</code></pre> 
<h4>8.3 文件拷贝</h4> 
<p>如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的<code>copy</code>方法。例如：</p> 
<pre><code class="language-java">IOUtils.copy(new FileInputStream("/temp/a.txt"), new FileOutputStream("/temp/b.txt"));</code></pre> 
<h4>8.4 读取文件内容到字节数组</h4> 
<p>如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的<code>toByteArray</code>方法。例如：</p> 
<pre><code class="language-java">byte[] bytes = IOUtils.toByteArray(new FileInputStream("/temp/a.txt"));</code></pre> 
<p>IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2e/cb/3AcGIWpJ_o.png"></p> 
<h3>9. MDC</h3> 
<p><code>MDC</code>是<code>org.slf4j</code>包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p> 
<p>MDC的底层是用了<code>ThreadLocal</code>来保存数据的。</p> 
<p>我们可以用它传递参数。</p> 
<p>例如现在有这样一种场景：我们使用<code>RestTemplate</code>调用远程接口时，有时需要在<code>header</code>中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p> 
<p>这种业务场景就能通过<code>ClientHttpRequestInterceptor</code>接口实现，具体做法如下：</p> 
<p>第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：</p> 
<pre><code class="language-java">public class LogFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        MdcUtil.add(UUID.randomUUID().toString());
        System.out.println("记录请求日志");
        chain.doFilter(request, response);
        System.out.println("记录响应日志");
    }

    @Override
    public void destroy() {
    }
}</code></pre> 
<p>第二步，实现<code>ClientHttpRequestInterceptor</code>接口，MDC中获取当前请求的traceId，然后设置到header中：</p> 
<pre><code class="language-java">public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        request.getHeaders().set("traceId", MdcUtil.get());
        return execution.execute(request, body);
    }
}</code></pre> 
<p>第三步，定义配置类，配置上面定义的<code>RestTemplateInterceptor</code>类：</p> 
<pre><code class="language-java">@Configuration
public class RestTemplateConfiguration {

    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));
        return restTemplate;
    }

    @Bean
    public RestTemplateInterceptor restTemplateInterceptor() {
        return new RestTemplateInterceptor();
    }
}</code></pre> 
<p>其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId</p> 
<pre><code class="language-java">public class MdcUtil {

    private static final String TRACE_ID = "TRACE_ID";

    public static String get() {
        return MDC.get(TRACE_ID);
    }

    public static void add(String value) {
        MDC.put(TRACE_ID, value);
    }
}</code></pre> 
<p>当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。</p> 
<p>能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。</p> 
<p>那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。</p> 
<h3>10. ClassUtils</h3> 
<p>spring的<code>org.springframework.util</code>包下的<code>ClassUtils</code>类，它里面有很多让我们惊喜的功能。</p> 
<p>它里面包含了类和对象相关的很多非常实用的方法。</p> 
<h4>10.1 获取对象的所有接口</h4> 
<p>如果你想获取某个对象的所有接口，可以使用ClassUtils的<code>getAllInterfaces</code>方法。例如：</p> 
<pre><code class="language-java">Class&lt;?&gt;[] allInterfaces = ClassUtils.getAllInterfaces(new User());</code></pre> 
<h4>10.2 获取某个类的包名</h4> 
<p>如果你想获取某个类的包名，可以使用ClassUtils的<code>getPackageName</code>方法。例如：</p> 
<pre><code class="language-java">String packageName = ClassUtils.getPackageName(User.class);
System.out.println(packageName);</code></pre> 
<h4>10.3 判断某个类是否内部类</h4> 
<p>如果你想判断某个类是否内部类，可以使用ClassUtils的<code>isInnerClass</code>方法。例如：</p> 
<pre><code class="language-java">System.out.println(ClassUtils.isInnerClass(User.class));</code></pre> 
<h4>10.4 判断对象是否代理对象</h4> 
<p>如果你想判断对象是否代理对象，可以使用ClassUtils的<code>isCglibProxy</code>方法。例如：</p> 
<pre><code class="language-java">System.out.println(ClassUtils.isCglibProxy(new User()));</code></pre> 
<p>ClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6e/ec/XZqLLzAk_o.png"></p> 
<h3>11. BeanUtils</h3> 
<p>spring给我们提供了一个<code>JavaBean</code>的工具类，它在<code>org.springframework.beans</code>包下面，它的名字叫做：<code>BeanUtils</code>。</p> 
<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p> 
<h4>11.1 拷贝对象的属性</h4> 
<p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的<code>copyProperties</code>方法。例如：</p> 
<pre><code class="language-java">User user1 = new User();
user1.setId(1L);
user1.setName("苏三说技术");
user1.setAddress("成都");

User user2 = new User();
BeanUtils.copyProperties(user1, user2);
System.out.println(user2);</code></pre> 
<h4>11.2 实例化某个类</h4> 
<p>如果你想通过反射实例化一个类的对象，可以使用BeanUtils的<code>instantiateClass</code>方法。例如：</p> 
<pre><code class="language-java">User user = BeanUtils.instantiateClass(User.class);
System.out.println(user);</code></pre> 
<h4>11.3 获取指定类的指定方法</h4> 
<p>如果你想获取某个类的指定方法，可以使用BeanUtils的<code>findDeclaredMethod</code>方法。例如：</p> 
<pre><code class="language-java">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, "getId");
System.out.println(declaredMethod.getName());</code></pre> 
<h4>11.4 获取指定方法的参数</h4> 
<p>如果你想获取某个方法的参数，可以使用BeanUtils的<code>findPropertyForMethod</code>方法。例如：</p> 
<pre><code class="language-java">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, "getId");
PropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);
System.out.println(propertyForMethod.getName());</code></pre> 
<p>如果你对BeanUtils比较感兴趣，可以看看下面内容：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b8/7c/tvruYZZB_o.png"></p> 
<h3>12. ReflectionUtils</h3> 
<p>有时候，我们需要在项目中使用<code>反射</code>功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p> 
<p>好消息是spring给我们提供了一个<code>ReflectionUtils</code>工具，它在<code>org.springframework.util</code>包下面。</p> 
<h4>12.1 获取方法</h4> 
<p>如果你想获取某个类的某个方法，可以使用ReflectionUtils类的<code>findMethod</code>方法。例如：</p> 
<pre><code class="language-java">Method method = ReflectionUtils.findMethod(User.class, "getId");</code></pre> 
<h4>12.2 获取字段</h4> 
<p>如果你想获取某个类的某个字段，可以使用ReflectionUtils类的<code>findField</code>方法。例如：</p> 
<pre><code class="language-java">Field field = ReflectionUtils.findField(User.class, "id");</code></pre> 
<h4>12.3 执行方法</h4> 
<p>如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的<code>invokeMethod</code>方法。例如：</p> 
<pre><code class="language-java"> ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);</code></pre> 
<h4>12.4 判断字段是否常量</h4> 
<p>如果你想判断某个字段是否常量，可以使用ReflectionUtils类的<code>isPublicStaticFinal</code>方法。例如：</p> 
<pre><code class="language-java">Field field = ReflectionUtils.findField(User.class, "id");
System.out.println(ReflectionUtils.isPublicStaticFinal(field));</code></pre> 
<h4>12.5 判断是否equals方法</h4> 
<p>如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的<code>isEqualsMethod</code>方法。例如：</p> 
<pre><code class="language-java">Method method = ReflectionUtils.findMethod(User.class, "getId");
System.out.println(ReflectionUtils.isEqualsMethod(method));</code></pre> 
<p>当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/14/dc/UFGwpMYo_o.png"></p> 
<h3>13. Base64Utils</h3> 
<p>有时候，为了安全考虑，需要将参数只用<code>base64</code>编码。</p> 
<p>这时就能直接使用<code>org.springframework.util</code>包下的<code>Base64Utils</code>工具类。</p> 
<p>它里面包含：<code>encode</code>和<code>decode</code>方法，用于对数据进行加密和解密。例如：</p> 
<pre><code class="language-java">String str = "abc";
String encode = new String(Base64Utils.encode(str.getBytes()));
System.out.println("加密后：" + encode);
try {
    String decode = new String(Base64Utils.decode(encode.getBytes()), "utf8");
    System.out.println("解密后：" + decode);
} catch (UnsupportedEncodingException e) {
    e.printStackTrace();
}</code></pre> 
<p>执行结果：</p> 
<pre><code class="language-java">加密后：YWJj
解密后：abc</code></pre> 
<h3>14. StandardCharsets</h3> 
<p>我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。</p> 
<p>这时就可以直接使用<code>java.nio.charset</code>包下的<code>StandardCharsets</code>类中静态变量。</p> 
<p>例如：</p> 
<pre><code class="language-java">String str = "abc";
String encode = new String(Base64Utils.encode(str.getBytes()));
System.out.println("加密后：" + encode);
String decode = new String(Base64Utils.decode(encode.getBytes())
, StandardCharsets.UTF_8);
System.out.println("解密后：" + decode);
</code></pre> 
<h3>15. DigestUtils</h3> 
<p>有时候，我们需要对数据进行加密处理，比如：md5或sha256。</p> 
<p>可以使用apache的<code>org.apache.commons.codec.digest</code>包下的<code>DigestUtils</code>类。</p> 
<h4>15.1 md5加密</h4> 
<p>如果你想对数据进行md5加密，可以使用DigestUtils的<code>md5Hex</code>方法。例如：</p> 
<pre><code class="language-java">String md5Hex = DigestUtils.md5Hex("苏三说技术");
System.out.println(md5Hex);
</code></pre> 
<h4>15.2 sha256加密</h4> 
<p>如果你想对数据进行sha256加密，可以使用DigestUtils的<code>sha256Hex</code>方法。例如：</p> 
<pre><code class="language-java">String md5Hex = DigestUtils.sha256Hex("苏三说技术");
System.out.println(md5Hex);
</code></pre> 
<p>当然这个工具还有很多其他的加密方法：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/ec/Wjx7KgB6_o.png"></p> 
<h3>16. SerializationUtils</h3> 
<p>有时候，我们需要把数据进行<code>序列化</code>和<code>反序列化</code>处理。</p> 
<p>传统的做法是某个类实现<code>Serializable</code>接口，然后重新它的<code>writeObject</code>和<code>readObject</code>方法。</p> 
<p>但如果使用<code>org.springframework.util</code>包下的<code>SerializationUtils</code>工具类，能更轻松实现序列化和反序列化功能。例如：</p> 
<pre><code class="language-java">Map&lt;String, String&gt; map = Maps.newHashMap();
map.put("a", "1");
map.put("b", "2");
map.put("c", "3");
byte[] serialize = SerializationUtils.serialize(map);
Object deserialize = SerializationUtils.deserialize(serialize);
System.out.println(deserialize);
</code></pre> 
<h3>17. HttpStatus</h3> 
<p>很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。</p> 
<pre><code class="language-java">private int SUCCESS_CODE = 200;
private int ERROR_CODE = 500;
private int NOT_FOUND_CODE = 404;
</code></pre> 
<p>其实<code>org.springframework.http</code>包下的HttpStatus枚举，或者<code>org.apache.http</code>包下的<code>HttpStatus</code>接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a0/d7/hPUbFeqx_o.png"></p> 
<p>好了，今天的内容分享到这里。</p> 
<p>工作当中还有很多好用的小工具，欢迎在下方留言。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b342950f794fcefbecff78e86d954946/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[VUE]报错: Invalid prop: type check failed for prop “value“. Expected String, Number, got Array found</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27a45f9fe696dc76af1a251640f8c2a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">docker高效搭建本地开发环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>