<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三巨头对决：深入了解pnpm、yarn与npm - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三巨头对决：深入了解pnpm、yarn与npm" />
<meta property="og:description" content="欢迎来到我的博客，代码的世界里，每一行都是一个故事 三巨头对决：深入了解pnpm、yarn与npm 前言包管理器简介npm（Node Package Manager）：Yarn：pnpm（Performant Npm）： 2. 性能比较：安装速度：磁盘空间： 3. 特性和优势：依赖管理：私有仓库和安全：社区和生态系统： 使用场景和最佳实践项目适用性：团队协作：迁移策略： 总结： 前言 在JavaScript的世界中，有三个强大的武器帮助开发者管理复杂的项目依赖：pnpm、yarn和npm。它们像是我们的盔甲和剑，保护和加速我们的开发进程。但是，每个工具都有其独特的魔法和力量。让我们开始一场神奇的旅程，探索它们的秘密，找到最适合你的那一个。
包管理器简介 npm（Node Package Manager）： 定义：npm 是 Node.js 的默认包管理器，它是 JavaScript 世界中最大的软件注册处，用户可以从中获取和发布包（package）。特点： 庞大的社区：拥有最大的模块生态系统，几乎所有你能想到的功能，都有相应的包可以使用。易用性：直接集成在 Node.js 安装包中，易于开始使用。脚本支持：支持强大的脚本功能，可以简化很多开发、构建和部署过程。 挑战： 依赖深度：可能会产生庞大的node_modules目录，导致安装速度缓慢和磁盘空间大量占用。版本一致性：不同环境下可能因为依赖版本微小差异导致运行结果不一致。 Yarn： 定义：由 Facebook 开发的包管理工具，旨在解决 npm 的一些问题，提供更快的依赖安装速度和更严格的依赖控制。特点： 速度快：并行安装机制使得速度比 npm 快很多。lockfile：引入yarn.lock文件来锁定依赖的版本，确保不同设备和环境下依赖的一致性。更好的安全性：提供了更多的安全特性和工具来保障包的安全。 挑战： 学习曲线：虽然与npm类似，但有些命令和概念需要用户新学习。兼容性：虽然努力保持与npm的兼容性，但在某些情况下可能会遇到问题。 pnpm（Performant Npm）： 定义：一个更为高效的包管理器，致力于提高性能和减少磁盘空间的占用。特点： 空间效率：通过硬链接和符号链接的方式复用已下载的包，大幅减少node_modules的体积。高性能：并行操作和内容寻址存储机制提高了性能。严格的依赖平面：为每个包提供一个独立的依赖视图，减少包之间的冲突和意外影响。 挑战： 社区支持：虽然在不断增长，但社区和模块生态系统仍然不如npm和yarn那么庞大。兼容性问题：在某些复杂场景下可能会遇到兼容性问题。 了解这三个包管理器的基本特性和差异，可以帮助开发者更好地选择适合自己项目和工作流的工具。在实际使用中，你可能需要根据项目具体需求、团队偏好以及生态系统支持来做出选择。
2. 性能比较： 安装速度： npm： 冷缓存（无缓存数据）：传统上，npm在冷缓存时的安装速度较慢，因为它需要从远程仓库下载所有依赖项。热缓存（已有缓存数据）：npm v5及以上版本引入了package-lock.json，在热缓存情况下可以加快重新安装速度，但仍然可能不如yarn和pnpm快。 Yarn： 冷缓存：Yarn在首次安装时使用并行下载，性能通常优于npm。热缓存：Yarn的yarn.lock文件确保了依赖版本的一致性，同时缓存机制也加快了再次安装的速度。 pnpm： 冷缓存：pnpm通过使用硬链接和符号链接的方式来复用已下载的包，即使在冷缓存下也能有很好的表现。热缓存：由于其独特的存储方式，pnpm在热缓存情况下可以非常迅速地完成依赖安装。 磁盘空间： npm：传统上会为每个项目单独存储依赖项，这意味着相同的包在不同项目中会重复下载和存储，占用更多磁盘空间。Yarn：Yarn也为每个项目存储依赖项，但通过更好的缓存管理和yarn.lock文件来优化存储。它不会像npm那样减少磁盘空间使用，但提供了更一致的依赖管理。pnpm： 硬链接和符号链接：pnpm创建了一个中央存储，所有下载的包都存储在这里，并通过硬链接和符号链接在项目中使用。这意味着一个包无论被多少项目使用，都只存储一份实体，极大地节省了磁盘空间。严格的依赖平面：pnpm为每个包提供独立的依赖视图，减少了不必要的包冗余。 3. 特性和优势： 依赖管理： lockfile： 概念：lockfile是一个特定格式的文件，它精确记录了项目依赖的每个包的版本号。这确保了不同的开发环境和部署环境使用完全相同的依赖，从而避免了“在我机器上运行正常”这类问题。npm：使用package-lock.json来锁定依赖版本。Yarn：引入了yarn.lock文件，提供了更快的安装速度和更一致的依赖解析。pnpm：使用shrinkwrap.yaml作为其lock文件，与npm和Yarn的锁文件类似，但结构和算法有所不同，旨在提供更严格的依赖管理。 私有仓库和安全： 私有仓库：私有仓库允许团队存储和管理内部的、私有的包，而不是公开到全球的npm仓库。 npm：可以通过npm Enterprise或其他第三方服务如Nexus、Artifactory来搭建私有仓库。Yarn：支持私有npm仓库，并且可以很容易地与这些仓库一起使用。pnpm：同样支持私有仓库，可以与任何兼容npm的私有仓库一起工作。 安全特性： npm：提供了npm audit来分析和修复安全漏洞。Yarn：提供了yarn audit，并在Yarn 2中引入了插件系统，可以增加额外的安全检查。pnpm：虽然没有内置的安全审计命令，但可以通过第三方工具或与npm、Yarn的安全功能配合使用。 社区和生态系统： npm： 社区：作为最早的包管理器，拥有最大的用户基础和社区支持。模块数量：提供了数百万个包，是目前最大的JavaScript包注册处。 Yarn： 社区：由Facebook背书，并且受到了许多大公司和开发者的支持。模块数量：由于与npm注册处兼容，用户也可以访问所有npm提供的包。 pnpm： 社区：社区相对较小，但正在快速增长，并且受到了一些大型项目和公司的支持。模块数量：与npm和Yarn一样，可以访问所有npm注册处的包。 使用场景和最佳实践 项目适用性： 小型项目： npm：由于其广泛的支持和简单性，对于小型项目来说是一个很好的选择。Yarn：对于希望提高安装速度和确保依赖一致性的小型项目也是合适的。pnpm：对于磁盘空间有限的小型项目，pnpm的空间优化特性非常有用。 大型/复杂项目： Yarn：Yarn的workspaces特性使得管理多包项目变得简单，非常适合大型项目和单体仓库。pnpm：凭借其高效的性能和严格的依赖隔离，非常适合大型和高度模块化的项目。 微服务： Yarn/Pnpm：都支持工作区的概念，有助于在单个仓库中管理多个服务。 团队协作： 确保一致性：无论选择哪个包管理器，都应在团队内部达成一致，确保所有成员都使用相同的工具和版本，避免依赖不一致问题。文档和规范：创建明确的文档和规范，指导团队成员如何正确使用包管理器和lockfile。持续集成/持续部署(CI/CD)：在CI/CD流程中集成包管理器，确保自动化过程中的依赖安装与开发环境保持一致。 迁移策略： 评估原因：在迁移前，明确迁移的动机和目标，例如是否为了提高安装速度、减少磁盘空间占用或改善依赖管理。备份当前状态：在进行任何迁移步骤之前，备份当前项目的状态，包括node_modules文件夹和现有的lock文件。逐步迁移：在小规模或分支上测试新的包管理器，观察是否有任何问题或不兼容之处。更新文档：一旦迁移完成，更新项目文档，包括README和开发者指南，确保团队成员了解如何使用新的包管理器。团队培训：对团队成员进行新工具的培训，特别是如果工具带来了工作流的重大变化。 总结： 每个包管理器都有其适用的场景和特定的优势。选择最适合的工具需要考虑项目的大小、复杂度、团队协作需求以及迁移的可行性。最佳实践包括确保团队内部一致性、文档和规范的清晰以及在迁移过程中的细致规划和测试。通过明智的选择和规范的使用，可以最大化包管理器的效益，提高项目的开发效率和稳定性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/5ac855e60b15058d4ec8963cd71960da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T13:42:20+08:00" />
<meta property="article:modified_time" content="2023-12-29T13:42:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三巨头对决：深入了解pnpm、yarn与npm</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font color="red" size="5"></font></p> 
<center> 
 <font color="BA55D3" size="5"><strong>欢迎来到我的博客，代码的世界里，每一行都是一个故事</strong></font> 
</center> 
<br> 
<a href="https://todoitbo.fun" rel="nofollow"><br> <img src="https://images2.imgbox.com/df/40/ScRhvZ1h_o.gif" alt="在这里插入图片描述"><br> </a> 
<p></p> 
<p></p> 
<div class="toc"> 
 <h4>三巨头对决：深入了解pnpm、yarn与npm</h4> 
 <ul><li><ul><li><a href="#_6" rel="nofollow">前言</a></li><li><a href="#_10" rel="nofollow">包管理器简介</a></li><li><ul><li><a href="#npmNode_Package_Manager_12" rel="nofollow">npm（Node Package Manager）：</a></li><li><a href="#Yarn_23" rel="nofollow">Yarn：</a></li><li><a href="#pnpmPerformant_Npm_34" rel="nofollow">pnpm（Performant Npm）：</a></li></ul> 
   </li><li><a href="#2__47" rel="nofollow">2. 性能比较：</a></li><li><ul><li><a href="#_49" rel="nofollow">安装速度：</a></li><li><a href="#_61" rel="nofollow">磁盘空间：</a></li></ul> 
   </li><li><a href="#3__69" rel="nofollow">3. 特性和优势：</a></li><li><ul><li><a href="#_71" rel="nofollow">依赖管理：</a></li><li><a href="#_79" rel="nofollow">私有仓库和安全：</a></li><li><a href="#_90" rel="nofollow">社区和生态系统：</a></li></ul> 
   </li><li><a href="#_102" rel="nofollow">使用场景和最佳实践</a></li><li><ul><li><a href="#_104" rel="nofollow">项目适用性：</a></li><li><a href="#_116" rel="nofollow">团队协作：</a></li><li><a href="#_122" rel="nofollow">迁移策略：</a></li></ul> 
   </li><li><a href="#_130" rel="nofollow">总结：</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_6"></a>前言</h3> 
<p>在JavaScript的世界中，有三个强大的武器帮助开发者管理复杂的项目依赖：pnpm、yarn和npm。它们像是我们的盔甲和剑，保护和加速我们的开发进程。但是，每个工具都有其独特的魔法和力量。让我们开始一场神奇的旅程，探索它们的秘密，找到最适合你的那一个。</p> 
<h3><a id="_10"></a>包管理器简介</h3> 
<h4><a id="npmNode_Package_Manager_12"></a>npm（Node Package Manager）：</h4> 
<ul><li><strong>定义</strong>：<code>npm</code> 是 Node.js 的默认包管理器，它是 JavaScript 世界中最大的软件注册处，用户可以从中获取和发布包（package）。</li><li><strong>特点</strong>： 
  <ul><li><strong>庞大的社区</strong>：拥有最大的模块生态系统，几乎所有你能想到的功能，都有相应的包可以使用。</li><li><strong>易用性</strong>：直接集成在 Node.js 安装包中，易于开始使用。</li><li><strong>脚本支持</strong>：支持强大的脚本功能，可以简化很多开发、构建和部署过程。</li></ul> </li><li><strong>挑战</strong>： 
  <ul><li><strong>依赖深度</strong>：可能会产生庞大的<code>node_modules</code>目录，导致安装速度缓慢和磁盘空间大量占用。</li><li><strong>版本一致性</strong>：不同环境下可能因为依赖版本微小差异导致运行结果不一致。</li></ul> </li></ul> 
<h4><a id="Yarn_23"></a>Yarn：</h4> 
<ul><li><strong>定义</strong>：由 Facebook 开发的包管理工具，旨在解决 npm 的一些问题，提供更快的依赖安装速度和更严格的依赖控制。</li><li><strong>特点</strong>： 
  <ul><li><strong>速度快</strong>：并行安装机制使得速度比 npm 快很多。</li><li><strong>lockfile</strong>：引入<code>yarn.lock</code>文件来锁定依赖的版本，确保不同设备和环境下依赖的一致性。</li><li><strong>更好的安全性</strong>：提供了更多的安全特性和工具来保障包的安全。</li></ul> </li><li><strong>挑战</strong>： 
  <ul><li><strong>学习曲线</strong>：虽然与npm类似，但有些命令和概念需要用户新学习。</li><li><strong>兼容性</strong>：虽然努力保持与npm的兼容性，但在某些情况下可能会遇到问题。</li></ul> </li></ul> 
<h4><a id="pnpmPerformant_Npm_34"></a>pnpm（Performant Npm）：</h4> 
<ul><li><strong>定义</strong>：一个更为高效的包管理器，致力于提高性能和减少磁盘空间的占用。</li><li><strong>特点</strong>： 
  <ul><li><strong>空间效率</strong>：通过硬链接和符号链接的方式复用已下载的包，大幅减少<code>node_modules</code>的体积。</li><li><strong>高性能</strong>：并行操作和内容寻址存储机制提高了性能。</li><li><strong>严格的依赖平面</strong>：为每个包提供一个独立的依赖视图，减少包之间的冲突和意外影响。</li></ul> </li><li><strong>挑战</strong>： 
  <ul><li><strong>社区支持</strong>：虽然在不断增长，但社区和模块生态系统仍然不如npm和yarn那么庞大。</li><li><strong>兼容性问题</strong>：在某些复杂场景下可能会遇到兼容性问题。</li></ul> </li></ul> 
<p>了解这三个包管理器的基本特性和差异，可以帮助开发者更好地选择适合自己项目和工作流的工具。在实际使用中，你可能需要根据项目具体需求、团队偏好以及生态系统支持来做出选择。</p> 
<h3><a id="2__47"></a>2. 性能比较：</h3> 
<h4><a id="_49"></a>安装速度：</h4> 
<ul><li><strong>npm</strong>： 
  <ul><li><strong>冷缓存</strong>（无缓存数据）：传统上，npm在冷缓存时的安装速度较慢，因为它需要从远程仓库下载所有依赖项。</li><li><strong>热缓存</strong>（已有缓存数据）：npm v5及以上版本引入了<code>package-lock.json</code>，在热缓存情况下可以加快重新安装速度，但仍然可能不如yarn和pnpm快。</li></ul> </li><li><strong>Yarn</strong>： 
  <ul><li><strong>冷缓存</strong>：Yarn在首次安装时使用并行下载，性能通常优于npm。</li><li><strong>热缓存</strong>：Yarn的<code>yarn.lock</code>文件确保了依赖版本的一致性，同时缓存机制也加快了再次安装的速度。</li></ul> </li><li><strong>pnpm</strong>： 
  <ul><li><strong>冷缓存</strong>：pnpm通过使用硬链接和符号链接的方式来复用已下载的包，即使在冷缓存下也能有很好的表现。</li><li><strong>热缓存</strong>：由于其独特的存储方式，pnpm在热缓存情况下可以非常迅速地完成依赖安装。</li></ul> </li></ul> 
<h4><a id="_61"></a>磁盘空间：</h4> 
<ul><li><strong>npm</strong>：传统上会为每个项目单独存储依赖项，这意味着相同的包在不同项目中会重复下载和存储，占用更多磁盘空间。</li><li><strong>Yarn</strong>：Yarn也为每个项目存储依赖项，但通过更好的缓存管理和<code>yarn.lock</code>文件来优化存储。它不会像npm那样减少磁盘空间使用，但提供了更一致的依赖管理。</li><li><strong>pnpm</strong>： 
  <ul><li><strong>硬链接和符号链接</strong>：pnpm创建了一个中央存储，所有下载的包都存储在这里，并通过硬链接和符号链接在项目中使用。这意味着一个包无论被多少项目使用，都只存储一份实体，极大地节省了磁盘空间。</li><li><strong>严格的依赖平面</strong>：pnpm为每个包提供独立的依赖视图，减少了不必要的包冗余。</li></ul> </li></ul> 
<h3><a id="3__69"></a>3. 特性和优势：</h3> 
<h4><a id="_71"></a>依赖管理：</h4> 
<ul><li><strong>lockfile</strong>： 
  <ul><li><strong>概念</strong>：<code>lockfile</code>是一个特定格式的文件，它精确记录了项目依赖的每个包的版本号。这确保了不同的开发环境和部署环境使用完全相同的依赖，从而避免了“在我机器上运行正常”这类问题。</li><li><strong>npm</strong>：使用<code>package-lock.json</code>来锁定依赖版本。</li><li><strong>Yarn</strong>：引入了<code>yarn.lock</code>文件，提供了更快的安装速度和更一致的依赖解析。</li><li><strong>pnpm</strong>：使用<code>shrinkwrap.yaml</code>作为其lock文件，与npm和Yarn的锁文件类似，但结构和算法有所不同，旨在提供更严格的依赖管理。</li></ul> </li></ul> 
<h4><a id="_79"></a>私有仓库和安全：</h4> 
<ul><li><strong>私有仓库</strong>：私有仓库允许团队存储和管理内部的、私有的包，而不是公开到全球的npm仓库。 
  <ul><li><strong>npm</strong>：可以通过npm Enterprise或其他第三方服务如Nexus、Artifactory来搭建私有仓库。</li><li><strong>Yarn</strong>：支持私有npm仓库，并且可以很容易地与这些仓库一起使用。</li><li><strong>pnpm</strong>：同样支持私有仓库，可以与任何兼容npm的私有仓库一起工作。</li></ul> </li><li><strong>安全特性</strong>： 
  <ul><li><strong>npm</strong>：提供了<code>npm audit</code>来分析和修复安全漏洞。</li><li><strong>Yarn</strong>：提供了<code>yarn audit</code>，并在<code>Yarn 2</code>中引入了插件系统，可以增加额外的安全检查。</li><li><strong>pnpm</strong>：虽然没有内置的安全审计命令，但可以通过第三方工具或与npm、Yarn的安全功能配合使用。</li></ul> </li></ul> 
<h4><a id="_90"></a>社区和生态系统：</h4> 
<ul><li><strong>npm</strong>： 
  <ul><li><strong>社区</strong>：作为最早的包管理器，拥有最大的用户基础和社区支持。</li><li><strong>模块数量</strong>：提供了数百万个包，是目前最大的JavaScript包注册处。</li></ul> </li><li><strong>Yarn</strong>： 
  <ul><li><strong>社区</strong>：由Facebook背书，并且受到了许多大公司和开发者的支持。</li><li><strong>模块数量</strong>：由于与npm注册处兼容，用户也可以访问所有npm提供的包。</li></ul> </li><li><strong>pnpm</strong>： 
  <ul><li><strong>社区</strong>：社区相对较小，但正在快速增长，并且受到了一些大型项目和公司的支持。</li><li><strong>模块数量</strong>：与npm和Yarn一样，可以访问所有npm注册处的包。</li></ul> </li></ul> 
<h3><a id="_102"></a>使用场景和最佳实践</h3> 
<h4><a id="_104"></a>项目适用性：</h4> 
<ul><li><strong>小型项目</strong>： 
  <ul><li><strong>npm</strong>：由于其广泛的支持和简单性，对于小型项目来说是一个很好的选择。</li><li><strong>Yarn</strong>：对于希望提高安装速度和确保依赖一致性的小型项目也是合适的。</li><li><strong>pnpm</strong>：对于磁盘空间有限的小型项目，pnpm的空间优化特性非常有用。</li></ul> </li><li><strong>大型/复杂项目</strong>： 
  <ul><li><strong>Yarn</strong>：Yarn的<code>workspaces</code>特性使得管理多包项目变得简单，非常适合大型项目和单体仓库。</li><li><strong>pnpm</strong>：凭借其高效的性能和严格的依赖隔离，非常适合大型和高度模块化的项目。</li></ul> </li><li><strong>微服务</strong>： 
  <ul><li><strong>Yarn/Pnpm</strong>：都支持工作区的概念，有助于在单个仓库中管理多个服务。</li></ul> </li></ul> 
<h4><a id="_116"></a>团队协作：</h4> 
<ul><li><strong>确保一致性</strong>：无论选择哪个包管理器，都应在团队内部达成一致，确保所有成员都使用相同的工具和版本，避免依赖不一致问题。</li><li><strong>文档和规范</strong>：创建明确的文档和规范，指导团队成员如何正确使用包管理器和<code>lockfile</code>。</li><li><strong>持续集成/持续部署(CI/CD)</strong>：在CI/CD流程中集成包管理器，确保自动化过程中的依赖安装与开发环境保持一致。</li></ul> 
<h4><a id="_122"></a>迁移策略：</h4> 
<ul><li><strong>评估原因</strong>：在迁移前，明确迁移的动机和目标，例如是否为了提高安装速度、减少磁盘空间占用或改善依赖管理。</li><li><strong>备份当前状态</strong>：在进行任何迁移步骤之前，备份当前项目的状态，包括<code>node_modules</code>文件夹和现有的lock文件。</li><li><strong>逐步迁移</strong>：在小规模或分支上测试新的包管理器，观察是否有任何问题或不兼容之处。</li><li><strong>更新文档</strong>：一旦迁移完成，更新项目文档，包括README和开发者指南，确保团队成员了解如何使用新的包管理器。</li><li><strong>团队培训</strong>：对团队成员进行新工具的培训，特别是如果工具带来了工作流的重大变化。</li></ul> 
<h3><a id="_130"></a>总结：</h3> 
<p>每个包管理器都有其适用的场景和特定的优势。选择最适合的工具需要考虑项目的大小、复杂度、团队协作需求以及迁移的可行性。最佳实践包括确保团队内部一致性、文档和规范的清晰以及在迁移过程中的细致规划和测试。通过明智的选择和规范的使用，可以最大化包管理器的效益，提高项目的开发效率和稳定性。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a52eae013bd977f24d6edddc39439b44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker学习笔记05-TCP远程连接与docker compose简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/644136e568352e633a32d0d5afdfd556/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">接口测试工具：Postman的高级用法！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>