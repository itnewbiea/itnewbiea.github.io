<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>制作一个RISC-V的操作系统四-嵌入式开发介绍 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="制作一个RISC-V的操作系统四-嵌入式开发介绍" />
<meta property="og:description" content="文章目录 什么是嵌入式开发交叉编译查看一些GCC文件夹 调试器GDB相关语法命令 模拟器QEMUQEMU的安装和使用项目构造工具MakeMakeFile的构成make的运行 练习4-1练习4-2练习4-3 什么是嵌入式开发 程序跑到开发板上，或者说运行到硬件上
交叉编译 简单理解交叉编译来说就是生成的程序不在本机上运行，而在与本机架构不同的计算机上运行
build：生成编译程序的计算机
host：运行build计算机生成的编译程序的计算机
target：就是编译结果运行的地方
查看一些GCC文件夹 -&gt;是符号链接
调试器GDB GDB调试包括2个程序：gdb程序和被调试程序。根据这2个程序是否运行在同一台电脑中，可以把GDB的调试模型分为2种:
本地调试：调试程序和被调试程序运行在同一台电脑中
gdb 运行起来后，它会先fork一个子进程，被调试的程序会运行在这个单独的子进程中，gdb这个程序也会单独运行在一个独立的进程里。然后这两个进程通过独特的ptrace系统调用建立连接。
远程调试：调试程序运行在一台电脑中，被调试程序运行在另一台电脑中
在目标机会有一个gdbserver的服务，gdb会与gdbserver交互，由gdbserver代理我们的调试过程，被调试的程序是运行在目标机上的，而调试是在本机上的。两台机器通过网络连接
相关语法命令 p &lt;变量名称&gt; Print的简写，显示指定变量（临时变量或全局变量）的值。 s 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数。相当于其它调试器中的“Step Into (单步跟踪进入)”。 这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 si si命令类似于s命令，但针对汇编指令。 n 执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over (单步跟踪)”。 这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。 ni ni命令类似于n命令，但针对汇编指令。 c Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。 l List的简写，列出当前位置之后的10行代码；list line_number: 列出line_number之后的十行代码。 模拟器QEMU 此时是模拟用户层的环境（类似操作系统） llk运行在用户层
qemu-riscv32 ./llk #在qemu提供的环境上运行llk 开发操作系统时要模拟系统级别的层次（类似硬件层次）
QEMU的安装和使用 项目构造工具Make 以自动化的方式编译程序
-f指定makefile文件
MakeFile的构成 .DEFAULT_GOAL的特殊变量，可用于告知如果在命令行中未指定目标，(就是只make时候) 应该构建哪个目标（或目标）。否则，Make会简单地使它遇到的第一个目标。
.PHONY:伪目标。伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。 PHONY定义伪目标的命令一定会被执行
对于到下图中就是clean的里面的命令不管clean是否存在，都会执行
$(SRCS_ASM:.S=.o) 就是将SRCS_ASH变量里面的.S都替换为.o make的运行 差不多就是一步步套娃
练习4-1 熟悉交叉编译概念，使⽤ riscv gcc 编译代码并使⽤ binutils ⼯具对⽣成的⽬标文件和可执⾏文件（ELF 格式）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/7baf85033e9ea7eb7d801345292b1cab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-06T15:45:44+08:00" />
<meta property="article:modified_time" content="2023-12-06T15:45:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">制作一个RISC-V的操作系统四-嵌入式开发介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">什么是嵌入式开发</a></li><li><a href="#_5" rel="nofollow">交叉编译</a></li><li><ul><li><a href="#GCC_12" rel="nofollow">查看一些GCC文件夹</a></li></ul> 
  </li><li><a href="#GDB_18" rel="nofollow">调试器GDB</a></li><li><ul><li><a href="#_27" rel="nofollow">相关语法命令</a></li></ul> 
  </li><li><a href="#QEMU_56" rel="nofollow">模拟器QEMU</a></li><li><a href="#QEMU_63" rel="nofollow">QEMU的安装和使用</a></li><li><a href="#Make_66" rel="nofollow">项目构造工具Make</a></li><li><ul><li><a href="#MakeFile_70" rel="nofollow">MakeFile的构成</a></li><li><a href="#make_82" rel="nofollow">make的运行</a></li></ul> 
  </li><li><a href="#41_88" rel="nofollow">练习4-1</a></li><li><a href="#42_113" rel="nofollow">练习4-2</a></li><li><a href="#43_118" rel="nofollow">练习4-3</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>什么是嵌入式开发</h2> 
<p>程序跑到开发板上，或者说运行到硬件上</p> 
<p><img src="https://images2.imgbox.com/c3/b8/aEN6p8e6_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_5"></a>交叉编译</h2> 
<p>简单理解交叉编译来说就是生成的程序不在本机上运行，而在与本机架构不同的计算机上运行<br> build：生成编译程序的计算机<br> host：运行build计算机生成的编译程序的计算机<br> target：就是编译结果运行的地方<br> <img src="https://images2.imgbox.com/f7/0e/bIGdLxXp_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="GCC_12"></a>查看一些GCC文件夹</h3> 
<p><img src="https://images2.imgbox.com/60/26/A9sgLs6b_o.png" alt="在这里插入图片描述"><br> -&gt;是符号链接<br> <img src="https://images2.imgbox.com/9d/a5/oqWfTavG_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/e4/4d/xAtNqJkU_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="GDB_18"></a>调试器GDB</h2> 
<p>GDB调试包括2个程序：gdb程序和被调试程序。根据这2个程序是否运行在同一台电脑中，可以把GDB的调试模型分为2种:<br> 本地调试：调试程序和被调试程序运行在同一台电脑中<br> gdb 运行起来后，它会先fork一个子进程，被调试的程序会运行在这个单独的子进程中，gdb这个程序也会单独运行在一个独立的进程里。然后这两个进程通过独特的ptrace系统调用建立连接。</p> 
<p>远程调试：调试程序运行在一台电脑中，被调试程序运行在另一台电脑中<br> 在目标机会有一个gdbserver的服务，gdb会与gdbserver交互，由gdbserver代理我们的调试过程，被调试的程序是运行在目标机上的，而调试是在本机上的。两台机器通过网络连接</p> 
<p><img src="https://images2.imgbox.com/ff/f1/7WPGLPjq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_27"></a>相关语法命令</h3> 
<p><img src="https://images2.imgbox.com/a4/50/etmNahK9_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">p <span class="token operator">&lt;</span>变量名称<span class="token operator">&gt;</span>
Print的简写，显示指定变量（临时变量或全局变量）的值。

s
执行一行源程序代码，如果此行代码中有函数调用，则进入该函数。相当于其它调试器中的“Step Into <span class="token punctuation">(</span>单步跟踪进入<span class="token punctuation">)</span>”。
这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。

si
si命令类似于s命令，但针对汇编指令。

n
执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over <span class="token punctuation">(</span>单步跟踪<span class="token punctuation">)</span>”。
这个命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）。

ni
ni命令类似于n命令，但针对汇编指令。

c
Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。

l
List的简写，列出当前位置之后的10行代码；list line_number: 列出line_number之后的十行代码。

</code></pre> 
<h2><a id="QEMU_56"></a>模拟器QEMU</h2> 
<p><img src="https://images2.imgbox.com/40/cc/dhOi70Wh_o.png" alt="在这里插入图片描述"><br> 此时是模拟用户层的环境（类似操作系统） llk运行在用户层</p> 
<pre><code class="prism language-bash">qemu-riscv32 ./llk  <span class="token comment">#在qemu提供的环境上运行llk</span>
</code></pre> 
<p>开发操作系统时要模拟系统级别的层次（类似硬件层次）</p> 
<h2><a id="QEMU_63"></a>QEMU的安装和使用</h2> 
<p><img src="https://images2.imgbox.com/53/2e/4adHfauN_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Make_66"></a>项目构造工具Make</h2> 
<p>以自动化的方式编译程序<br> -f指定makefile文件<br> <img src="https://images2.imgbox.com/ea/28/pwaLDRdW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="MakeFile_70"></a>MakeFile的构成</h3> 
<p><img src="https://images2.imgbox.com/64/b3/5kV4AR8p_o.png" alt="在这里插入图片描述"><br> .DEFAULT_GOAL的特殊变量，可用于告知如果在命令行中未指定目标，(就是只make时候) 应该构建哪个目标（或目标）。否则，Make会简单地使它遇到的第一个目标。<br> .PHONY:伪目标。伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。 PHONY定义伪目标的命令一定会被执行<br> 对于到下图中就是clean的里面的命令不管clean是否存在，都会执行</p> 
<p><img src="https://images2.imgbox.com/41/e5/Xrl4Avd0_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token variable"><span class="token variable">$(</span>SRCS_ASM:.S<span class="token operator">=</span>.o<span class="token variable">)</span></span> 就是将SRCS_ASH变量里面的.S都替换为.o
</code></pre> 
<h3><a id="make_82"></a>make的运行</h3> 
<p>差不多就是一步步套娃<br> <img src="https://images2.imgbox.com/d2/92/CLb6sLrj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="41_88"></a>练习4-1</h2> 
<p>熟悉交叉编译概念，使⽤ riscv gcc 编译代码并使⽤ binutils ⼯具对⽣成的⽬标文件和可执⾏文件（ELF 格式）<br> 进⾏分析。具体要求如下：</p> 
<ul><li>编写⼀个简单的打印 “hello world！” 的程序源文件：hello.c</li><li>对源文件进⾏编译，⽣成针对⽀持 rv32ima 指令集架构处理器的⽬标文件 hello.o</li><li>查看 hello.o 的文件的文件头信息。</li><li>查看 hello.o 的 Section header table。</li><li>对 hello.o 反汇编，并查看 hello.c 的 C 程序源码和机器指令的对应关系。</li></ul> 
<p>-march=rv32ima：指定生成后的32位可执行文件可以运行在支持 i 整数指令集 m 乘除法指令集 a 原子操作指令集</p> 
<p>-mabi=ilp32:一个长整数时多少位</p> 
<pre><code class="prism language-bash">riscv64-unknown-elf-gcc <span class="token parameter variable">-march</span><span class="token operator">=</span>rv32ima <span class="token parameter variable">-mabi</span><span class="token operator">=</span>ilp32 llk.c <span class="token parameter variable">-o</span> llk
</code></pre> 
<pre><code class="prism language-bash"><span class="token function">file</span> llk
</code></pre> 
<pre><code class="prism language-bash">qemu-riscv32 ./llk  <span class="token comment">#在qemu提供的环境上运行llk</span>
</code></pre> 
<h2><a id="42_113"></a>练习4-2</h2> 
<p>基于 练习 4-1 继续熟悉 qemu/gdb 等⼯具的使⽤，具体要求如下：</p> 
<ul><li>将 hello.c 编译成可调式版本的可执⾏程序 a.out</li><li>先执⾏ qemu-riscv32 运⾏ a.out。</li><li>使⽤ qemu-riscv32 和 gdb 调试 a.out。</li></ul> 
<h2><a id="43_118"></a>练习4-3</h2> 
<ul><li>⾃学 Makefile 的语法，理解在 riscv-operating-system-mooc 仓库的根⽬录下执⾏ make 会发⽣什么。</li></ul> 
<pre><code class="prism language-bash">SECTIONS <span class="token operator">=</span> <span class="token punctuation">\</span>
	code/asm <span class="token punctuation">\</span>
	code/os <span class="token punctuation">\</span>

.DEFAULT_GOAL :<span class="token operator">=</span> all
all <span class="token builtin class-name">:</span>
	@echo <span class="token string">"begin compile ALL exercises for assembly samples ......................."</span>
	<span class="token keyword">for</span> <span class="token for-or-select variable">dir</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span>SECTIONS<span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> <span class="token variable">$$</span><span class="token function">dir</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token string">"<span class="token variable">$$</span>?"</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
	@echo <span class="token string">"compile ALL exercises finished successfully! ......"</span>

.PHONY <span class="token builtin class-name">:</span> clean
clean:
	<span class="token keyword">for</span> <span class="token for-or-select variable">dir</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span>SECTIONS<span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> <span class="token parameter variable">-C</span> <span class="token variable">$$</span><span class="token function">dir</span> clean <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token string">"<span class="token variable">$$</span>?"</span><span class="token punctuation">;</span> <span class="token keyword">done</span>

.PHONY <span class="token builtin class-name">:</span> slides
slides:
	<span class="token function">rm</span> <span class="token parameter variable">-f</span> ./slides/*.pdf
	soffice <span class="token parameter variable">--headless</span> --convert-to pdf:writer_pdf_Export <span class="token parameter variable">--outdir</span> ./slides ./docs/ppts/*.pptx


</code></pre> 
<ul><li>\表示换行。只有执行对应的Makefile命令的shell语句时才会进入shell环境，每行命令独立，每行都是单独的shell，所以上一行定义的shell变量并不适用于下一行。当然如果是使用了\来合并行就可以摆脱这个限制了。就是使之成为一条指令，或者是一个shell执行的。图中SECTIONS后的/可以理解就是把下面的和上面的练成一行。不然make执行时，每行都是一个单独的shell执行，这样SECTIONS就没有成功赋值。加了的话shell就执行三行，就可以成功赋值了</li><li>for in ; do ; done循环语句 在makefile中的shell变量要用2个$号表示变量名称, 对应表示dir</li><li>make -C 目录 表示进入目录后执行make</li><li>||表示前面部分指令执行失败后执行后面的指令</li></ul> 
<p>所以大概整个make就是进入code/asm 和code/os目录执行make，然后/code/asm 下对应的makefile又是进入各个文件执行make，/code/os也一样</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8498104ae154dd80e956a8293ecdb9d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 网络爬虫</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5877df4be3d9f2a8b29696d848bf9fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">学会python如何利用业余时间赚外快？分享几个接单途径</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>