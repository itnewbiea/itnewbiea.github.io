<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python pygame(GUI编程)模块最完整教程（8） - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python pygame(GUI编程)模块最完整教程（8）" />
<meta property="og:description" content="上一篇文章：
Python pygame(GUI编程)模块最完整教程（7）_Python-ZZY的博客-CSDN博客
总目录：
README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com
23 进阶声音操作 参考资料：
https://pyga.me/docs/ref/sndarray.html
https://pyga.me/docs/ref/midi.html
MIDI格式 - 简书
23.1 通过MIDI输出声音 pygame.midi模块操作MIDI（乐器数字接口）。各种电子乐器与计算机通过MIDI进行交互。管理MIDI输入，可以从一些MIDI输入设备获取信息；将MIDI输出，则可以模拟某种乐器播放音符。
和pg.camera一样，midi不会自动导入到pygame中，所以需要额外的导入和初始化。
import pygame as pg from pygame import midi pg.init() midi.init() 下面的程序演示了如何通过midi播放从低到高的音阶（相邻音符之间相差一个半音）。
import pygame as pg from pygame import midi pg.init() midi.init() port = midi.get_default_output_id() # 获取默认的MIDI输出 midi_out = midi.Output(port) # 速度范围0 - 127，速度127时音符持续时间最长 velocity = 100 # 声调最高音符名为127 max_note = 127 try: for note in range(0, max_note &#43; 1): print(note) midi_out." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/73063970a2b5b128745779eba956063c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T09:47:43+08:00" />
<meta property="article:modified_time" content="2023-08-16T09:47:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python pygame(GUI编程)模块最完整教程（8）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一篇文章：</p> 
<p><a href="https://blog.csdn.net/qq_48979387/article/details/130784914" title="Python pygame(GUI编程)模块最完整教程（7）_Python-ZZY的博客-CSDN博客">Python pygame(GUI编程)模块最完整教程（7）_Python-ZZY的博客-CSDN博客</a></p> 
<p>总目录：</p> 
<p><a href="https://gitee.com/python_zzy/pygame-articles-csdn/blob/master/README.md" rel="nofollow" title="README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com">README.md · Python-ZZY/Python-Pygame最完整教程 - Gitee.com</a></p> 
<h2>23 进阶声音操作</h2> 
<p>参考资料：</p> 
<p><a href="https://pyga.me/docs/ref/sndarray.html" rel="nofollow" title="https://pyga.me/docs/ref/sndarray.html">https://pyga.me/docs/ref/sndarray.html</a></p> 
<p><a href="https://pyga.me/docs/ref/midi.html" rel="nofollow" title="https://pyga.me/docs/ref/midi.html">https://pyga.me/docs/ref/midi.html</a></p> 
<p><a href="https://www.jianshu.com/p/6c495b51a40c" rel="nofollow" title="MIDI格式 - 简书">MIDI格式 - 简书</a></p> 
<h3>23.1 通过MIDI输出声音</h3> 
<p class="img-center"><img alt="" height="339" src="https://images2.imgbox.com/a1/a4/Bib8U9fA_o.jpg" width="600"></p> 
<p>pygame.midi模块操作MIDI（乐器数字接口）。各种电子乐器与计算机通过MIDI进行交互。管理MIDI输入，可以从一些MIDI输入设备获取信息；将MIDI输出，则可以模拟某种乐器播放音符。</p> 
<p>和pg.camera一样，midi不会自动导入到pygame中，所以需要额外的导入和初始化。</p> 
<pre><code class="language-python">import pygame as pg
from pygame import midi

pg.init()
midi.init()</code></pre> 
<p>下面的程序演示了如何通过midi播放从低到高的音阶（相邻音符之间相差一个半音）。</p> 
<pre><code class="language-python">import pygame as pg
from pygame import midi

pg.init()
midi.init()

port = midi.get_default_output_id() # 获取默认的MIDI输出
midi_out = midi.Output(port)

# 速度范围0 - 127，速度127时音符持续时间最长
velocity = 100

# 声调最高音符名为127
max_note = 127

try:
    for note in range(0, max_note + 1):
    
        print(note)
        midi_out.note_on(note, velocity) # 按下音符

        # 音符播放是非阻塞的，不会等一个音符播完再执行下面的代码
    
        pg.time.wait(800) # 等待一段时间后再执行代码
        midi_out.note_off(note) # 释放音符

finally: # 退出midi
    del midi_out
    midi.quit()</code></pre> 
<p>上面的代码首先通过get_default_output_id方法获取默认的MIDI设备，然后创建了一个Output对象，用于管理MIDI的输出。然后通过Output.note_on按下音符，等待800ms后释放音符。 </p> 
<p>最后通过finally代码块，无论是否出现异常都要退出midi。不显式退出虽然不太可能出现问题，但是官方建议最好还是加上finally来确保midi退出。</p> 
<p>note_on方法可接受3个参数。第一个是音符编码，范围是0-127，相邻音符之间相差一个半音，数字越大音调越高，可参考<a href="https://wenku.baidu.com/view/d49f66ec25fff705cc1755270722192e453658ab.html" rel="nofollow" title="MIDI音符代码表">MIDI音符代码表</a>。第二个参数表示音符的响度（不知道为什么官方用速度来表示），范围同样是0-127，数字越大声音响度越大。第三个参数channel可选，表示播放的声道。与note_on相对，还有note_off方法用于释放音符，参数与之相同。</p> 
<h3>23.2 模拟乐器音色</h3> 
<p>pg.midi.Output对象还有一个方法set_instrument，可以将音符音色设置为不同乐器的音色。默认的音色是钢琴。</p> 
<p>设置音色需要指定音色编码，所有编码可参考<a href="https://blog.csdn.net/ruyulin/article/details/84103186" title="MIDI 128种音色码表">MIDI 128种音色码表</a>。音色编码的范围仍为0-127。</p> 
<pre><code class="language-python">pg.midi.Output.set_instrument(instrument_id, channel=0) -&gt; None</code></pre> 
<p>下面的示例将所有音色的声音都播放了一遍。</p> 
<pre><code class="language-python">import pygame as pg
from pygame import midi

pg.init()
midi.init()

port = midi.get_default_output_id() # 获取默认的MIDI输出
midi_out = midi.Output(port)

velocity = 100

max_instrument = 72

try:
    for instrument in range(70, max_instrument + 1):
    
        print(instrument)
        midi_out.set_instrument(instrument) # 设置音色
        midi_out.note_on(80, velocity) # 按下音符
    
        pg.time.wait(800)
        midi_out.note_off(80) # 释放音符

finally:
    del midi_out
    midi.quit()</code></pre> 
<h3><strong><span style="color:#a5a5a5;">23.3 写入原始MIDI信息数据</span></strong></h3> 
<p>midi.Output.write用于写入较多的MIDI数据，来控制音符的播放。</p> 
<pre><code class="language-python">Output.write(data) -&gt; None</code></pre> 
<p>data必须是一个列表，其中包含多个小列表，每个列表都代表一个MIDI事件（为便于理解以下称作“操作”）。操作列表由信息列表、时间戳组成。信息列表一般是3个值或1个值，第一个值表示状态位，后面的值表示数据位（可选，默认为0）。例如下面这个data列表：</p> 
<pre><code class="language-python">port = midi.get_default_output_id()
midi_out = midi.Output(port, latency=1) # 设置延迟为1

program_change = 192
note_on = 144
note_off = 128

data = [
    [[program_change, 40, 0], 0],
    [[note_on, 80, 127], 0],
    [[note_off, 80, 127], 1000],
    ]

midi_out.write(data)</code></pre> 
<p>这个data列表包含3个MIDI操作，改变程序（也就是乐器音色），按下音符，松开音符。时间戳表示触发这个操作的时间。比如这个data就表示：在时间为0ms的时候，改变音色，按下音调为80，强度为127的音符；在时间为1000ms时（注意：不是距离上次操作经过了1000ms），松开音调为80，强度为127的音符。</p> 
<p>需要注意的是：使用write的时候一般要把Output类的latency参数设为一个大于0的值。latency表示延迟，即写入数据之前会有一段延迟的时间，单位是ms。如果不设置延迟，那么时间戳是无效的，所有操作都会同时进行（个人觉得这个设置不太好）。因为我不需要太多延迟，所以将它设为1即可。如果延迟设为2000，则在write中的操作处理之前会延迟2000ms。延迟时间不会算进时间戳。</p> 
<p>正如上面所说，每个操作包含操作信息，时间戳组成，那么前面的操作信息又代表什么呢？参见这篇文章：<a href="https://blog.csdn.net/cornrn/article/details/127984696" title="常见MIDI信息的状态位和数据位含义表">常见MIDI信息的状态位和数据位含义表</a>。状态位的代码决定了后面数据位的含义。比如状态位144，就表示在频道1上按下音符；后面的数据位分别表示音符代码、响度代码。状态位128，则表示在频道1上释放音符；后面的数据位分别表示音符代码、响度代码。状态位192，则表示在频道1上改变音色；后面的数据位只有一个，表示乐器音色代码，由于只需要一个数据位，所以最后的数据位留空为0即可。</p> 
<p>此外，还需要注意data列表是有顺序的，操作必须按照时间戳从小到大排列，不然有些操作无法正确执行。例如：</p> 
<pre><code class="language-python">data = [
    [[program_change, 70, 0], 0],
    
    [[note_on, 80, 127], 0],
    [[note_on, 100, 127], 1000],
    
    [[note_off, 80, 127], 2000],
    [[note_off, 100, 127], 2000],
    ] 
'上面是正确的排列 (0 &lt;= 1000 &lt;= 2000 &lt;= 2000)'

data = [
    [[program_change, 70, 0], 0],
    
    [[note_on, 80, 127], 0],
    [[note_off, 80, 127], 2000],
    
    [[note_on, 100, 127], 1000],
    [[note_off, 100, 127], 2000],
    ] 
'上面是错误的排列，时间戳没有从小到大排列'
'(0 &lt;= 2000 !&lt; 1000 &lt;= 2000)'
'如果使用这种方法排列将执行不到[[note_on, 100, 127], 1000]这一段'</code></pre> 
<p>按照上面正确的代码播放，将达到这样的效果：首先改变音色，播放80音符；过1秒后播放100音符；再过1秒后同时结束两个音符的播放。 </p> 
<h3>23.4 midi模块索引 - 乐器数字接口</h3> 
<p><strong>事件</strong>：midi在输入和输出时会分别产生MIDIIN和MIDIOUT两个事件。</p> 
<p><strong>init() -&gt; None, quit() -&gt; None</strong></p> 
<p>初始化/退出midi。</p> 
<p><strong>Input(device_id) -&gt; None</strong></p> 
<p><strong>Input(device_id, buffer_size) -&gt; None</strong></p> 
<p>创建一个midi输入对象，device_id是输入设备的标识符，buffer_id是可缓冲的输入事件数量。</p> 
<p><strong>Input.close() -&gt; None</strong></p> 
<p>尝试关闭midi输入（在Windows系统上可能出现问题）。</p> 
<p><strong>Input.poll() -&gt; bool</strong></p> 
<p>判断是否有midi的输入数据</p> 
<p><strong>Input.read(num_events) -&gt; midi_event_list</strong></p> 
<p>读取并返回未被处理的midi输入事件，num_events代表事件的数量。</p> 
<p><strong>Output(device_id) -&gt; None</strong></p> 
<p><strong>Output(device_id, latency=0) -&gt; None</strong></p> 
<p><strong>Output(device_id, buffer_size=256) -&gt; None</strong></p> 
<p><strong>Output(device_id, latency, buffer_size) -&gt; None</strong></p> 
<p>创建midi输出对象。buffer_size是输出事件的缓冲数量，latency是输出的延迟时间。</p> 
<p><strong>Output.abort() -&gt; None</strong></p> 
<p>中止midi传输（可能导致数据还没发完时就终止了）</p> 
<p><strong>Output.close() -&gt; None</strong></p> 
<p>关闭midi输出对象（Windows上可能有问题）</p> 
<p><strong>Output.note_off(note, velocity=None, channel=0) -&gt; None</strong></p> 
<p>松开音符，note是音符编码，velocity是速度，channel是频道。</p> 
<p><strong>Output.note_on(note, velocity, channel=0) -&gt; None</strong></p> 
<p>按下音符，note是音符编码，velocity是速度，channel是频道。</p> 
<p><strong>Output.set_instrument(instrument_id, channel=0) -&gt; None</strong></p> 
<p>设置乐器音色</p> 
<p><strong>Output.pitch_bend(value=0, channel=0) -&gt; None</strong></p> 
<p>微调midi输出时的音高。value为正数表示升高，负数表示降低，范围是-8192到+8191，每4096代表一个半音。例如：-8192表示降低两个半音（即一个全音），4096表示升高一个半音。</p> 
<p><strong>Output.write(data) -&gt; None</strong></p> 
<p>写入多个MIDI操作</p> 
<p><strong>Output.write_short(status) -&gt; None</strong></p> 
<p><strong>Output.write_short(status, data1=0, data2=0) -&gt; None</strong></p> 
<p>写入单个的MIDI操作，status是状态位，data1, data2分别是两个数据位。不考虑时间戳。</p> 
<p><strong>Output.write_sys_ex(when, msg) -&gt; None</strong></p> 
<p>写入全是系统信息的MIDI操作。</p> 
<pre><code class="language-python">midi_output.write_sys_ex(0, '\xF0\x7D\x10\x11\x12\x13\xF7')

# 相当于：

midi_output.write_sys_ex(pg.midi.time(), # midi计时器的时间
                         [0xF0, 0x7D, 0x10, 0x11, 0x12, 0x13, 0xF7])</code></pre> 
<p><strong>get_default_input_id() -&gt; default_id</strong></p> 
<p>获取默认的MIDI输入设备</p> 
<p><strong>get_default_output_id() -&gt; default_id</strong></p> 
<p>获取默认的MIDI输出设备</p> 
<p><strong>get_device_info(an_id) -&gt; (interf, name, input, output, opened)</strong></p> 
<p><strong>get_device_info(an_id) -&gt; None</strong></p> 
<p>获取给定设备ID的信息。返回值一般是元组，ID超出范围会返回None。元组中各个值的含义：interf表示描述设备接口的字符串（例如"ALSA"），name表示设备名称（例如"Midi Through Port-0"），input表示该设备是否为输入设备（1或0），output表示该设备是否为输出设备（1或0），opened表示该设备是否为开启状态。</p> 
<p><strong>midis2events(midi_events, device_id) -&gt; [Event, ...]</strong></p> 
<p>将MIDI事件转换为pygame事件。midi_events也就是传递给Output.write的data参数中的每个操作列表。</p> 
<p><strong>time() -&gt; time</strong></p> 
<p>返回midi计时器得到的时间（从midi.init开始算）</p> 
<p><strong>frequency_to_midi(midi_note) -&gt; midi_note</strong></p> 
<p>将频率转换为MIDI音符代码（会圆整到最接近的那个音符）</p> 
<p><strong>midi_to_ansi_note(midi_note) -&gt; ansi_note</strong></p> 
<p>将MIDI音符代码转换为ansi音符格式的字符串</p> 
<p><strong>MidiException(errno) -&gt; None</strong></p> 
<p>MIDI异常。当MIDI设备找不到，或者其他原因时可能报错。</p> 
<h3>23.5 sndarray模块索引 - Sound与numpy数组</h3> 
<p>pg.sndarray用于pg.mixer.Sound和numpy数组之间的转换，和pg.surfarray一样依赖于numpy库。</p> 
<p>声音数据是由每秒数千个样本组成的，每个样本都是在特定时刻的波的振幅。例如，在22khz格式中，阵列的单元号5是5/22000秒后的波的振幅。</p> 
<p><strong>array(Sound) -&gt; array</strong></p> 
<p>将声音对象复制并转换为numpy数组，更改数组不会改变声音对象本身。</p> 
<p><strong>samples(Sound) -&gt; array</strong></p> 
<p>将声音对象之间转换为numpy数组，更改数组将改变声音对象本身。</p> 
<p><strong>make_sound(array) -&gt; Sound</strong></p> 
<p>将声音样本数组转换为Sound对象。</p> 
<h2>24 pygame探索</h2> 
<p>参考资料：<a href="https://pyga.me/docs/ref/pygame.html" rel="nofollow" title="pygame — pygame-ce v2.4.0 documentation">pygame — pygame-ce v2.4.0 documentation</a></p> 
<h3>24.1 pygame主模块索引</h3> 
<p>pygame主模块里面并没有什么特别重要的内容，因为学习pygame的时候，读者已经了解了主模块中常用的函数，接下来将整理一些函数的用法。</p> 
<p>以下是pygame主模块中唯一可能用到的4个东西（剩下的都没什么用）。</p> 
<p><strong>init() -&gt; (numpass, numfail)</strong></p> 
<p>初始化pygame所有子模块，并返回初始化成功的数量和失败的数量。</p> 
<p>其实在pygame的每个子模块中都有init和quit方法，用于初始化和退出单个的子模块。pygame功能很多，有时候并不用于单纯的编写游戏，有时候也会用于播放音乐等等。如果只需要使用pygame.mixer模块，就无需初始化整个的pygame，只需要调用pygame.mixer.init()而非pygame.init()。</p> 
<p><strong>quit() -&gt; None</strong></p> 
<p>退出pygame，与init方法相反。这个方法会关闭pygame窗口。调用pg.quit方法并不会退出整个python程序，只会退出pygame。有时候有必要在退出时顺便调用sys.exit来确保python程序完全退出。</p> 
<p><strong>register_quit(callable) -&gt; None</strong></p> 
<p>注册一个函数。当调用pygame.quit时，会调用它。</p> 
<p><strong>error</strong></p> 
<p>pygame.error继承于Exception，表示一些pygame相关的异常。可用于异常捕获。</p> 
<h3>24.2 环境变量</h3> 
<p>部分pygame的行为可以通过环境变量来控制，即操作os.environ。例如：</p> 
<div> 
 <pre><code class="language-python">import os
os.environ["环境变量名"] = "环境变量值"</code></pre> 
</div> 
<p>下面是一些可能用到的pygame相关环境变量及用法。</p> 
<p><strong>PM_RECOMMENDED_INPUT_DEVICE</strong></p> 
<p>设置默认的MIDI输入设备</p> 
<p><strong>PM_RECOMMENDED_OUTPUT_DEVICE</strong></p> 
<p>设置默认的MIDI输出设备</p> 
<p><strong>PYGAME_DISPLAY</strong></p> 
<p>pygame的显示索引（即pg.display.set_mode的display参数），默认为"0"</p> 
<p><strong>PYGAME_FORCE_SCALE</strong></p> 
<p>强制set_mode使用缩放显示模式，是"default"或"photo"。如果设置了“photo”，则缩放使用最慢但质量最高的各向异性缩放算法(如果可用)。必须在调用pygame.display.set_mode()之前设置</p> 
<p><strong>PYGAME_BLEND_ALPHA_SDL2</strong></p> 
<p>这使得pygame对所有alpha混合使用SDL2 blitter。SDL2绘制器有时比默认的要快，但使用不同的公式，因此最终颜色可能不同。必须在调用pygame.init()初始化所有导入的pygame模块之前设置。</p> 
<p><span style="color:#fe2c24;"><strong>PYGAME_HIDE_SUPPORT_PROMPT</strong></span></p> 
<p>是否隐藏pygame启动时打印的那一段提示，设置为"1"表示隐藏。</p> 
<p><strong>PYGAME_CAMERA</strong></p> 
<p>设置摄像机的后端，如"opencv"。必须在pg.camera初始化之前调用。</p> 
<p><span style="color:#fe2c24;"><strong>SDL_IME_SHOW_UI</strong></span></p> 
<p>是否显示输入候选框。必须在pg.display.set_mode前面调用</p> 
<p><strong>SDL_VIDEO_CENTERED</strong></p> 
<p>是否将窗口设在屏幕中央。必须在pg.display.set_mode前面调用</p> 
<p><strong>SDL_VIDEO_WINDOW_POS</strong></p> 
<p>设置pygame窗口的位置（左上角），格式为"x, y"。必须在pg.display.set_mode前面调用</p> 
<p><strong>SDL_VIDEO_ALLOW_SCREENSAVER</strong></p> 
<p>默认情况下，pygame运行时会禁用屏保，如果设为"1"则表示允许显示屏幕保护系统。</p> 
<p><strong>SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS</strong></p> 
<p>默认情况下，当窗口不在焦点中时，游戏手柄这样的设备不会更新。然而，使用这个环境变量，即使窗口在后台，也有可能获得操纵杆更新。必须在调用pygame.init()之前设置。</p> 
<h3>24.3 _sdl2</h3> 
<p>pygame._sdl2模块中包含了一些实验性的SDL2功能，可能在未来有更改。_sdl2中还包含一些子模块。_sdl2不会被自动导入到pygame里面。</p> 
<p>_sdl2包含以下几个模块：</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td><strong>模块名</strong></td><td><strong>描述</strong></td></tr><tr><td>controller</td><td>操作控制器（如游戏手柄）</td></tr><tr><td>touch</td><td>触屏输入</td></tr><tr><td>window</td><td>pygame多窗口创建</td></tr><tr><td>video</td><td>包括图像、纹理等</td></tr></tbody></table> 
<h2>下一篇文章</h2> 
<p>制作中（可能要等很久）……</p> 
<p>预告：作者计划在完成一个大项目后发布easy_pygame游戏引擎。该引擎包含一些特色功能：</p> 
<ul><li>静态和动态的多状态精灵</li><li>动作系统（比如：淡入淡出、移动、缩放、旋转、振动）</li><li>图文混排渲染</li><li>异步场景类（使用状态机控制，便于pygbag打包）；可支持动作系统的场景类</li><li>完美碰撞检测函数</li><li>存档功能（进行了一定的md5加密，但是容易被python用户破解）</li><li>多背景音乐管理</li><li>相对位置转换成绝对位置后再获取文件路径，同时支持pyinstaller的资源内置</li><li>封装了缓存算法的图片载入</li><li>帧序列处理（包括单张图片上多帧、多图片）</li><li>pg.time.get_ticks()的时间计算优化</li><li>如有必要，可能还会添加一些基本的UI组件模型，以及一些游戏拓展库和一些便捷打包工具</li></ul> 
<p>由于该游戏引擎缺乏调试，可能会有很多的bug。以后若有建议请提出。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74ee653ab62c148bf54797de595e3da2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BootStrap V5：现代化前端开发的必备工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4dc8615a9eca1bfd18f515898932091/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">爆肝完成对比！cfa一级2024年考纲分析（附最新教材和课后题下载链接）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>