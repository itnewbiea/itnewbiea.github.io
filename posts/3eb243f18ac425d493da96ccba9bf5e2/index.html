<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【优化求解】基于粒子群算法求解多目标优化问题matlab源码 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【优化求解】基于粒子群算法求解多目标优化问题matlab源码" />
<meta property="og:description" content="【优化求解】基于粒子群算法求解多目标优化问题matlab源码 1 算法介绍 1.1 关于速度和位置 粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。
鸟被抽象为没有质量和体积的微粒(点)，并延伸到N维空间，粒子i在N维空间的位置表示为矢量Xi＝(x1，x2，…，xN)，飞行速度表示为矢量Vi＝(v1，v2，…，vN)。每个粒子都有一个由目标函数决定的适应值(fitness value)，并且知道自己到目前为止发现的最好位置(pbest)和现在的位置Xi。这个可以看作是粒子自己的飞行经验。除此之外，每个粒子还知道到目前为止整个群体中所有粒子发现的最好位置(gbest)(gbest是pbest中的最好值)，这个可以看作是粒子同伴的经验。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。
2.2 速度和位置的更新 PSO初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次的迭代中，粒子通过跟踪两个“极值”(pbest，gbest)来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。
对于公式(1)：
公式(1)的第①部分称为【记忆项】，表示上次速度大小和方向的影响；
公式(1)的第②部分称为【自身认知项】，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；
公式(1)的第③部分称为【群体认知项】，是一个从当前点指向种群最好点的矢量，反映了粒子间的协同合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。
以上面两个公式为基础，再来看一个公式：
公式(2)和 公式(3)被视为标准PSO算法。
1.3 标准PSO算法的流程 1）初始化一群微粒(群体规模为N)，包括随机位置和速度；
2）评价每个微粒的适应度；
3）对每个微粒，将其适应值与其经过的最好位置pbest作比较，如果较好，则将其作为当前的最好位置pbest；
4）对每个微粒，将其适应值与其经过的最好位置gbest作比较，如果较好，则将其作为当前的最好位置gbest；
5）根据公式(2)、(3)调整微粒速度和位置；
6）未达到结束条件则转第2）步。
迭代终止条件根据具体问题一般选为最大迭代次数Gk或(和)微粒群迄今为止搜索到的最优位置满足预定最小适应阈值。
## 4.2 PSO流程图解
2 部分代码 clc; clear; close all; ​ %% 问题定义，这里可以删除 ​ TestProblem=1; % Set to 1, 2, or 3 ​ switch TestProblem case 1 CostFunction=@(x) MyCost1(x); nVar=50; VarMin=0; VarMax=1; case 2 CostFunction=@(x) MyCost2(x); nVar=3; VarMin=-5; VarMax=5; case 3 CostFunction=@(x) MyCost3(x); nVar=2; VarMin=0; VarMax=1; end ​ VarSize=[1 nVar]; ​ VelMax=(VarMax-VarMin)/10; ​ %% MOPSO 设置 nPop=500; % Population Size ​ nRep=100; % Repository Size ​ MaxIt=500; % Maximum Number of Iterations ​ phi1=2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/3eb243f18ac425d493da96ccba9bf5e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-22T00:24:55+08:00" />
<meta property="article:modified_time" content="2021-09-22T00:24:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【优化求解】基于粒子群算法求解多目标优化问题matlab源码</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>【优化求解】基于粒子群算法求解多目标优化问题matlab源码</h4> 
<h3>1 算法介绍</h3> 
<h4>1.1 关于速度和位置</h4> 
<p>粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。</p> 
<p>鸟被抽象为没有质量和体积的微粒(点)，并延伸到N维空间，粒子i在N维空间的位置表示为矢量Xi＝(x1，x2，…，xN)，飞行速度表示为矢量Vi＝(v1，v2，…，vN)。每个粒子都有一个由目标函数决定的适应值(fitness value)，并且知道自己到目前为止发现的最好位置(pbest)和现在的位置Xi。这个可以看作是粒子自己的飞行经验。除此之外，每个粒子还知道到目前为止整个群体中所有粒子发现的最好位置(gbest)(gbest是pbest中的最好值)，这个可以看作是粒子同伴的经验。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。</p> 
<h4>2.2 速度和位置的更新</h4> 
<p>PSO初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次的迭代中，粒子通过跟踪两个“极值”(pbest，gbest)来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。</p> 
<p style="text-align:center;"><img alt="img" src="https://images2.imgbox.com/4d/ae/C6C7o8cI_o.png"></p> 
<p>对于公式(1)：</p> 
<p>公式(1)的第①部分称为【记忆项】，表示上次速度大小和方向的影响；</p> 
<p>公式(1)的第②部分称为【自身认知项】，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；</p> 
<p>公式(1)的第③部分称为【群体认知项】，是一个从当前点指向种群最好点的矢量，反映了粒子间的协同合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。</p> 
<p>以上面两个公式为基础，再来看一个公式：</p> 
<p style="text-align:center;"><img alt="img" src="https://images2.imgbox.com/35/64/2JeYaJa2_o.png"></p> 
<p><strong>公式(2)和 公式(3)被视为标准PSO算法。</strong></p> 
<h4>1.3 标准PSO算法的流程</h4> 
<p>1）初始化一群微粒(群体规模为N)，包括随机位置和速度；</p> 
<p>2）评价每个微粒的适应度；</p> 
<p>3）对每个微粒，将其适应值与其经过的最好位置pbest作比较，如果较好，则将其作为当前的最好位置pbest；</p> 
<p>4）对每个微粒，将其适应值与其经过的最好位置gbest作比较，如果较好，则将其作为当前的最好位置gbest；</p> 
<p>5）根据公式(2)、(3)调整微粒速度和位置；</p> 
<p>6）未达到结束条件则转第2）步。</p> 
<p>迭代终止条件根据具体问题一般选为最大迭代次数Gk或(和)微粒群迄今为止搜索到的最优位置满足预定最小适应阈值。</p> 
<p>## 4.2 PSO流程图解</p> 
<p style="text-align:center;"><img alt="img" src="https://images2.imgbox.com/05/83/7iK1aiDS_o.gif"></p> 
<h3>2 部分代码</h3> 
<h3></h3> 
<pre>clc;
clear;
close all;
​
%% 问题定义，这里可以删除
​
TestProblem=1;   % Set to 1, 2, or 3
​
switch TestProblem
    case 1
        CostFunction=@(x) MyCost1(x);
        nVar=50;
        VarMin=0;
        VarMax=1;
        
    case 2
        CostFunction=@(x) MyCost2(x);
        nVar=3;
        VarMin=-5;
        VarMax=5;
        
    case 3
        CostFunction=@(x) MyCost3(x);
        nVar=2;
        VarMin=0;
        VarMax=1;
end
​
VarSize=[1 nVar];
​
VelMax=(VarMax-VarMin)/10;
​
%% MOPSO 设置
nPop=500;   % Population Size
​
nRep=100;   % Repository Size
​
MaxIt=500;  % Maximum Number of Iterations
​
phi1=2.05;%学习因子
phi2=2.05;
phi=phi1+phi2;
chi=2/(phi-2+sqrt(phi^2-4*phi));
​
w=chi;              % Inertia Weight
wdamp=1;            % Inertia Weight Damping Ratio
c1=chi*phi1;        % Personal Learning Coefficient
c2=chi*phi2;        % Global Learning Coefficient
​
alpha=0.1;  % Grid Inflation Parameter
​
nGrid=10;   % Number of Grids per each Dimension
​
beta=4;     % Leader Selection Pressure Parameter
​
gamma=2;    % Extra (to be deleted) Repository Member Selection Pressure
​
%% 初始化
​
particle=CreateEmptyParticle(nPop);
​
for i=1:nPop
    particle(i).Velocity=0;
    particle(i).Position=unifrnd(VarMin,VarMax,VarSize); %unifrnd在[VarMin,VarMax]区间模拟VarSize的数组
    % 初始化了自变量X的位置
    particle(i).Cost=CostFunction(particle(i).Position); % 求解目标函数
    particle(i).Best.Position=particle(i).Position;
    particle(i).Best.Cost=particle(i).Cost;
end
​
particle=DetermineDomination(particle);
​
rep=GetNonDominatedParticles(particle);
​
rep_costs=GetCosts(rep);
G=CreateHypercubes(rep_costs,nGrid,alpha);
​
for i=1:numel(rep)
    [rep(i).GridIndex rep(i).GridSubIndex]=GetGridIndex(rep(i),G);
end
    
%% MOPSO 主循环
​
for it=1:MaxIt
    for i=1:nPop
        rep_h=SelectLeader(rep,beta);
​
        particle(i).Velocity=w*particle(i).Velocity ...
                             +c1*rand*(particle(i).Best.Position - particle(i).Position) ...
                             +c2*rand*(rep_h.Position -  particle(i).Position);
​
        particle(i).Velocity=min(max(particle(i).Velocity,-VelMax),+VelMax);
​
        particle(i).Position=particle(i).Position + particle(i).Velocity;
    
        flag=(particle(i).Position&lt;VarMin | particle(i).Position&gt;VarMax);    %非劣检查:flag
        particle(i).Velocity(flag)=-particle(i).Velocity(flag);
        
        particle(i).Position=min(max(particle(i).Position,VarMin),VarMax);
​
        particle(i).Cost=CostFunction(particle(i).Position);
​
        if Dominates(particle(i),particle(i).Best)
            particle(i).Best.Position=particle(i).Position;
            particle(i).Best.Cost=particle(i).Cost;
            
        elseif ~Dominates(particle(i).Best,particle(i))
            if rand&lt;0.5
                particle(i).Best.Position=particle(i).Position; 
                particle(i).Best.Cost=particle(i).Cost;
            end
        end
​
    end
    
    particle=DetermineDomination(particle);
    nd_particle=GetNonDominatedParticles(particle);
    
    rep=[rep
         nd_particle];
    
    rep=DetermineDomination(rep);
    rep=GetNonDominatedParticles(rep);
    
    for i=1:numel(rep)
        [rep(i).GridIndex rep(i).GridSubIndex]=GetGridIndex(rep(i),G);
    end
    
    if numel(rep)&gt;nRep
        EXTRA=numel(rep)-nRep;
        rep=DeleteFromRep(rep,EXTRA,gamma);
        
        rep_costs=GetCosts(rep);
        G=CreateHypercubes(rep_costs,nGrid,alpha);
        
    end
   
%     disp(['Iteration ' num2str(it) ': Number of Repository Particles = ' num2str(numel(rep))]);
    
    w=w*wdamp;
end
​
%% 结果
​
costs=GetCosts(particle);
rep_costs=GetCosts(rep);
​
figure;
​
plot(costs(1,:),costs(2,:),'b.');
hold on;
plot(rep_costs(1,:),rep_costs(2,:),'rx');
legend('Main Population','Repository');
​</pre> 
<p></p> 
<h3>3 仿真结果</h3> 
<p><img alt="" height="628" src="https://images2.imgbox.com/04/60/84BiEzaC_o.png" width="702"></p> 
<p> </p> 
<h3>4 参考文献</h3> 
<p>[1]王越, 吕光宏. 改进的粒子群求解多目标优化算法[J]. 计算机技术与发展, 2014, 000(002):42-45.</p> 
<h3>5 代码下载</h3>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5294df24a6e0f8932237837b74d333b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux图形栈(0)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5a64f60c0ee9d8e1fae0a8dacb447ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CTFshow刷题日记-WEB-反序列化篇(上，254-263)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>