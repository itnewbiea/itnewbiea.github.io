<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv[c&#43;&#43;] findContours()轮廓特征分析大全(求面积、周长、几何矩、质心、凸包、最小外接矩形、最小外接三角形、最小外接椭圆等)---后续完善总结版本 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencv[c&#43;&#43;] findContours()轮廓特征分析大全(求面积、周长、几何矩、质心、凸包、最小外接矩形、最小外接三角形、最小外接椭圆等)---后续完善总结版本" />
<meta property="og:description" content="目录
一，轮廓的发现与绘制
二，轮廓分析（二值图像分析)
🧡计算轮廓面积 : 💛计算轮廓周长：
💚计算几何矩与中心距: moments(）
💙轮廓的外接矩形：
💜最小外接圆/拟合圆：minEnclosingCircle(）
🤎拟合椭圆：fitEllipse(） 🖤拟合直线：fitLine(）
🤍轮廓的凸包：convexHull(）
🧡多边形逼近-逼近真实形状：approxPolyDP(）
💛检测点是否在轮廓内pointPolygonTest(）
一，轮廓的发现与绘制 在OpenCV里面利用findContours()函数和drawContours()函数实现这一功能。
findContours()函数 void findContours( InputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point() ) 参数一： image，输入图像、八位单通道的，背景为黑色的二值图像。（一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像）
参数二：contours，输出轮廓图像。是一个向量，向量的每个元素都是一个轮廓。因此，这个向量的每个元素仍是一个向量。即：
vector&lt;vector&lt;Point&gt; &gt; contours; 参数三：hierarchy，输出各个轮廓的继承关系。hierarchy也是一个向量，长度和contours相等，每个元素和contours的元素对应。hierarchy的每个元素是一个包含四个整型数的向量。即：
vector&lt;Vec4i&gt; hierarchy; 参数四：mode，检测轮廓的方法。有四种方法：
RETR_EXTERNAL：只检测外轮廓。忽略轮廓内部的洞。RETR_LIST：检测所有轮廓，但不建立继承(包含)关系。RETR_TREE：检测所有轮廓，并且建立所有的继承(包含)关系。RETR_CCOMP：检测所有轮廓，但是仅仅建立两层包含关系。 参数五：method，每个轮廓的编码信息。也有四种（常用前两种）
CHAIN_APPROX_NONE：把轮廓上所有的点存储。CHAIN_APPROX_SIMPLE：只存储轮廓上的拐点。CHAIN_APPROX_TC89_L1，CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法 参数六： Point，偏移量。默认为0
注意：该函数将白色区域当作前景物体。所以findContours()函数是黑色背景下找白色轮廓。（重要！！！）
drawContours()函数 drawContours( InputOutputArray binImg, // 输出图像 OutputArrayOfArrays contours,// 全部发现的轮廓对象 Int contourIdx// 轮廓索引号，-1表示绘制所有轮廓 const Scalar &amp; color,// 绘制时候颜色 int thickness,// 绘制线宽，-1表示填充轮廓内部 int lineType,// 线的类型LINE_8 InputArray hierarchy,// 拓扑结构图 int maxlevel,// 最大层数， 0只绘制当前的，1表示绘制绘制当前及其内嵌的轮廓 Point offset = Point()// 轮廓位移，可选 ） 二，轮廓分析（二值图像分析) 在得到图像的轮廓以后，我们就可以进行轮廓分析。经过轮廓分析我们可以得到轮廓各种有用的属性信息、常见的如下：　🧡计算轮廓面积 : contourArea(contour， oriented = False) //计算轮廓的面积 参数说明：contour为输入的单个轮廓值;oriented:轮廓方向，默认值false。 如果为true，该函数返回一个带符号的面积，其正负取决于轮廓的方向(顺时针还是逆时针)。 如果是默认值false，则面积以绝对值的形式返回." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/0faf969e2e129d30bf1fe1811e1a0596/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T10:24:20+08:00" />
<meta property="article:modified_time" content="2023-08-14T10:24:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv[c&#43;&#43;] findContours()轮廓特征分析大全(求面积、周长、几何矩、质心、凸包、最小外接矩形、最小外接三角形、最小外接椭圆等)---后续完善总结版本</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E8%BD%AE%E5%BB%93%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%8E%E7%BB%98%E5%88%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E8%BD%AE%E5%BB%93%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%8E%E7%BB%98%E5%88%B6" rel="nofollow">一，轮廓的发现与绘制</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E8%BD%AE%E5%BB%93%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90)-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E8%BD%AE%E5%BB%93%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90%29" rel="nofollow">二，轮廓分析（二值图像分析)</a></p> 
<p id="%F0%9F%A7%A1%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E9%9D%A2%E7%A7%AF%20%3A%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A1%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E9%9D%A2%E7%A7%AF%20%3A%C2%A0" rel="nofollow">🧡计算轮廓面积 : </a></p> 
<p id="%F0%9F%92%9B%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E5%91%A8%E9%95%BF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%F0%9F%92%9B%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E5%91%A8%E9%95%BF%EF%BC%9A" rel="nofollow">💛计算轮廓周长：</a></p> 
<p id="%F0%9F%92%9A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9F%A9%E4%B8%8E%E4%B8%AD%E5%BF%83%E8%B7%9D%3A%C2%A0moments(%EF%BC%89-toc" style="margin-left:40px;"><a href="#%F0%9F%92%9A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9F%A9%E4%B8%8E%E4%B8%AD%E5%BF%83%E8%B7%9D%3A%C2%A0moments%28%EF%BC%89" rel="nofollow">💚计算几何矩与中心距: moments(）</a></p> 
<p id="%F0%9F%92%99%E8%BD%AE%E5%BB%93%E7%9A%84%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%F0%9F%92%99%E8%BD%AE%E5%BB%93%E7%9A%84%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2%EF%BC%9A" rel="nofollow">💙轮廓的外接矩形：</a></p> 
<p id="%F0%9F%92%9C%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E5%9C%86%2F%E6%8B%9F%E5%90%88%E5%9C%86%EF%BC%9AminEnclosingCircle(%EF%BC%89-toc" style="margin-left:40px;"><a href="#%F0%9F%92%9C%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E5%9C%86%2F%E6%8B%9F%E5%90%88%E5%9C%86%EF%BC%9AminEnclosingCircle%28%EF%BC%89" rel="nofollow">💜最小外接圆/拟合圆：minEnclosingCircle(）</a></p> 
<p id="%F0%9F%A4%8E%E6%8B%9F%E5%90%88%E6%A4%AD%E5%9C%86%EF%BC%9AfitEllipse(%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%F0%9F%A4%8E%E6%8B%9F%E5%90%88%E6%A4%AD%E5%9C%86%EF%BC%9AfitEllipse%28%EF%BC%89%C2%A0" rel="nofollow">🤎拟合椭圆：fitEllipse(） </a></p> 
<p id="%F0%9F%96%A4%E6%8B%9F%E5%90%88%E7%9B%B4%E7%BA%BF%EF%BC%9AfitLine(%EF%BC%89-toc" style="margin-left:40px;"><a href="#%F0%9F%96%A4%E6%8B%9F%E5%90%88%E7%9B%B4%E7%BA%BF%EF%BC%9AfitLine%28%EF%BC%89" rel="nofollow">🖤拟合直线：fitLine(）</a></p> 
<p id="%F0%9F%A4%8D%E8%BD%AE%E5%BB%93%E7%9A%84%E5%87%B8%E5%8C%85%EF%BC%9AconvexHull(%EF%BC%89-toc" style="margin-left:40px;"><a href="#%F0%9F%A4%8D%E8%BD%AE%E5%BB%93%E7%9A%84%E5%87%B8%E5%8C%85%EF%BC%9AconvexHull%28%EF%BC%89" rel="nofollow">🤍轮廓的凸包：convexHull(）</a></p> 
<p id="%F0%9F%A7%A1%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%80%BC%E8%BF%91-%E9%80%BC%E8%BF%91%E7%9C%9F%E5%AE%9E%E5%BD%A2%E7%8A%B6%EF%BC%9AapproxPolyDP(%EF%BC%89-toc" style="margin-left:40px;"><a href="#%F0%9F%A7%A1%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%80%BC%E8%BF%91-%E9%80%BC%E8%BF%91%E7%9C%9F%E5%AE%9E%E5%BD%A2%E7%8A%B6%EF%BC%9AapproxPolyDP%28%EF%BC%89" rel="nofollow">🧡多边形逼近-逼近真实形状：approxPolyDP(）</a></p> 
<p id="%F0%9F%92%9B%E6%A3%80%E6%B5%8B%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E8%BD%AE%E5%BB%93%E5%86%85pointPolygonTest(%EF%BC%89-toc" style="margin-left:40px;"><a href="#%F0%9F%92%9B%E6%A3%80%E6%B5%8B%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E8%BD%AE%E5%BB%93%E5%86%85pointPolygonTest%28%EF%BC%89" rel="nofollow">💛检测点是否在轮廓内pointPolygonTest(）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E4%B8%80%EF%BC%8C%E8%BD%AE%E5%BB%93%E7%9A%84%E5%8F%91%E7%8E%B0%E4%B8%8E%E7%BB%98%E5%88%B6"><strong>一，轮廓的发现与绘制</strong></h2> 
<hr> 
<p> 在OpenCV里面利用findContours()函数和drawContours()函数实现这一功能。</p> 
<ul><li>findContours()函数</li></ul> 
<blockquote> 
 <pre><strong>void findContours(
InputArray          image,
OutputArrayOfArrays contours,
OutputArray         hierarchy,
int                 mode,
int                 method,
Point               offset = Point()
                  )</strong></pre> 
</blockquote> 
<p>参数一： image，输入图像、八位单通道的，背景为黑色的二值图像。（一般是经过Canny、拉普拉斯等边缘检测算子处理过的二值图像）</p> 
<p>参数二：contours，输出轮廓图像。是一个向量，向量的每个元素都是一个轮廓。因此，这个向量的每个元素仍是一个向量。即：</p> 
<pre>           vector&lt;vector&lt;Point&gt; &gt; contours;</pre> 
<p>参数三：hierarchy，输出各个轮廓的继承关系。hierarchy也是一个向量，长度和contours相等，每个元素和contours的元素对应。hierarchy的每个元素是一个包含四个整型数的向量。即：</p> 
<pre>           vector&lt;Vec4i&gt; hierarchy;</pre> 
<p>参数四：mode，检测轮廓的方法。有四种方法：</p> 
<ol><li>RETR_EXTERNAL：只检测外轮廓。忽略轮廓内部的洞。</li><li>RETR_LIST：检测所有轮廓，但不建立继承(包含)关系。</li><li>RETR_TREE：检测所有轮廓，并且建立所有的继承(包含)关系。</li><li>RETR_CCOMP：检测所有轮廓，但是仅仅建立两层包含关系。</li></ol> 
<p>参数五：method，每个轮廓的编码信息。也有四种（常用前两种）</p> 
<ol><li>CHAIN_APPROX_NONE：把轮廓上所有的点存储。</li><li>CHAIN_APPROX_SIMPLE：只存储轮廓上的拐点。</li><li>CHAIN_APPROX_TC89_L1，CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法</li></ol> 
<p>参数六： Point，偏移量。默认为0</p> 
<p><strong>注意：该函数将白色区域当作前景物体。所以findContours()函数是黑色背景下找白色轮廓。（重要！！！）</strong></p> 
<ul><li>drawContours()函数</li></ul> 
<pre>drawContours(
      InputOutputArray  binImg, // 输出图像
      OutputArrayOfArrays  contours,//  全部发现的轮廓对象
      Int contourIdx// 轮廓索引号，-1表示绘制所有轮廓
      const Scalar &amp; color,// 绘制时候颜色
      int  thickness,// 绘制线宽，-1表示填充轮廓内部
      int  lineType,// 线的类型LINE_8
      InputArray hierarchy,// 拓扑结构图
      int maxlevel,// 最大层数， 0只绘制当前的，1表示绘制绘制当前及其内嵌的轮廓
      Point offset = Point()// 轮廓位移，可选
            ）</pre> 
<hr> 
<h2 id="%E4%BA%8C%EF%BC%8C%E8%BD%AE%E5%BB%93%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E5%80%BC%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90)"><strong>二，轮廓分析（二值图像分析)</strong></h2> 
<hr> 
<p> 在得到图像的轮廓以后，我们就可以进行轮廓分析。经过轮廓分析我们可以得到轮廓各种有用的属性信息、常见的如下：　</p> 
<ul><li> <h3 id="%F0%9F%A7%A1%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E9%9D%A2%E7%A7%AF%20%3A%C2%A0"><strong>🧡计算轮廓面积 : </strong></h3> </li></ul> 
<pre><code class="language-cpp">contourArea(contour， oriented = False)  //计算轮廓的面积</code></pre> 
<pre>参数说明：contour为输入的单个轮廓值;oriented:轮廓方向，默认值false。
如果为true，该函数返回一个带符号的面积，其正负取决于轮廓的方向(顺时针还是逆时针)。
如果是默认值false，则面积以绝对值的形式返回.
根据这个特性可以根据面积的符号来确定轮廓的位置。</pre> 
<ul><li> <h3 id="%F0%9F%92%9B%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E5%91%A8%E9%95%BF%EF%BC%9A"><strong>💛计算轮廓周长：</strong></h3> </li></ul> 
<pre><code class="language-cpp">arcLength(contour， closed)   //  计算轮廓的周长</code></pre> 
<pre>参数说明：contour为输入的单个轮廓值,closed表示轮廓是否封闭（true为封闭，false为不封闭）</pre> 
<ul><li> <h3 id="%F0%9F%92%9A%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%9F%A9%E4%B8%8E%E4%B8%AD%E5%BF%83%E8%B7%9D%3A%C2%A0moments(%EF%BC%89"><strong>💚计算几何矩与中心距: moments(）</strong></h3> </li></ul> 
<pre><code class="language-cpp"> Moments m = moments(contours[t]); //获取轮廓的距
//计算轮廓质心
    double cx = m.m10 / m.m00;
    double cy = m.m01 / m.m00;</code></pre> 
<ul><li> <h3 id="%F0%9F%92%99%E8%BD%AE%E5%BB%93%E7%9A%84%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2%EF%BC%9A"><strong>💙轮廓的外接矩形：</strong></h3> </li></ul> 
<p>轮廓的外接矩形有两种，如下图，绿色的叫外接矩形boundingRect(），表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩形minAreaRect()，考虑了旋转</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a0/7a/onpJNuU0_o.png"></p> 
<p>1️⃣外接矩形Rect boundingRect(InputArray points）</p> 
<p>输入参数points可以一系列点的集合，对轮廓来说就是该轮廓的点集 返回结果是一个正矩形，包含以下信息：</p> 
<ul><li>矩形左上角的坐标（rect.x，rect.y）</li><li>矩形的宽和高（rect.width，rect.height）</li></ul> 
<pre><code class="language-cpp">Rect  rect = boundingRect(Mat(contours[i]));//获取轮廓外接正矩形
rectangle(src, rect, (0, 0, 255), 2, 8, 0);</code></pre> 
<p>2️⃣最小外接矩形minAreaRect()</p> 
<p>输入参数points可以一系列点的集合，对轮廓来说就是该轮廓的点集 返回结果是一个旋转矩形，包含下面的信息：</p> 
<ul><li>旋转矩形的中心坐标（rect.center）</li><li>旋转矩形的宽和高（rect.size.width，rect.size.height）</li><li>旋转矩形的角度（rect.angle）</li></ul> 
<pre><code class="language-cpp">RotatedRect rect = minAreaRect(contours[i]);//获取轮廓最小外接矩形
Point2f P[4];
rect.points(P);//获取四顶点坐标
for (int j = 0; j &lt;= 3; j++)
{
    line(src, P[j], P[(j + 1) % 4], Scalar(0,0,255), 1);//依次连线
}</code></pre> 
<ul><li> <h3 id="%F0%9F%92%9C%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E5%9C%86%2F%E6%8B%9F%E5%90%88%E5%9C%86%EF%BC%9AminEnclosingCircle(%EF%BC%89"><strong>💜最小外接圆/拟合圆：minEnclosingCircle(）</strong></h3> </li></ul> 
<pre>void minEnclosingCircle(InputArray points, Point2f&amp; center, float&amp; radius);
points，输入的二维点集，可以是 vector 或 Mat 类型。
center，圆的输出圆心。
radius，圆的输出半径。
 
例如：
</pre> 
<pre><code class="language-cpp">findContours(bin_img, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);
    //寻找包裹轮廓的最小圆
    vector&lt;Point2f&gt;centers(contours.size());//圆心个数
    vector&lt;float&gt;radius(contours.size());//半径个数
    for (int i = 0; i &lt; contours.size(); i++) 
    {
        //寻找并绘制最小圆
        minEnclosingCircle(contours[i], centers[i], radius[i]);
        circle(src, centers[i], radius[i], scalar(0,0,255), 2);
    }</code></pre> 
<ul><li> <h3 id="%F0%9F%A4%8E%E6%8B%9F%E5%90%88%E6%A4%AD%E5%9C%86%EF%BC%9AfitEllipse(%EF%BC%89%C2%A0"><strong>🤎拟合椭圆：fitEllipse(）</strong> </h3> </li></ul> 
<pre><code class="language-cpp">RotatedRect fitEllipse(InputArray points);
//唯一一个参数是输入的二维点集，可以是 vector 或 Mat 类型。
// 轮廓发现与绘制
vector&lt;vector&lt;Point&gt;&gt; contours;
findContours(binary, contours,  RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());
for (size_t t = 0; t &lt; contours.size(); t++)
 {
// 拟合椭圆
RotatedRect rrt = fitEllipse(contours[t]);
ellipse(src, rrt, Scalar(0, 0, 255), 2, 8);
}
imshow("contours", src);</code></pre> 
<ul><li> <h3 id="%F0%9F%96%A4%E6%8B%9F%E5%90%88%E7%9B%B4%E7%BA%BF%EF%BC%9AfitLine(%EF%BC%89"><strong>🖤拟合直线：fitLine(）</strong></h3> </li></ul> 
<p>OpenCV中直线拟合正是基于最小二乘法实现的。其函数将计算出的直线信息存放在 line 中，（为Vec4f 类型）。line[0]、line[1] 存放的是直线的方向向量，float cosθ = oneline[0]；float sinθ = oneline[1]。line[2]、line[3] 存放的是直线上一个点的坐标。</p> 
<p>实现直线拟合的API如下：</p> 
<pre>void   fitLine(
    InputArray points,  //输入待拟合的二维点的数组或vector
    OutputArray line,   //输出直线,Vec4f (2d)或Vec6f (3d)的vector
    int distType,          //距离类型
    double param,      //距离参数(一般设为0）
    double reps,        //径向的精度参数（一般设为0.01）
    double aeps        //角度精度参数（一般设为0.01）
              )</pre> 
<pre><strong>distType（距离类型）有六种参数：（DIST_L2就是最小二乘法）</strong></pre> 
<blockquote> 
 <p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/f2/rf58jd7R_o.png"></p> 
</blockquote> 
<p><strong>opencv实现：</strong></p> 
<pre><code class="language-cpp">    Mat src = imread("直线拟合.png");
    imshow("原图片", src);
    // 去噪声与二值化
    Mat dst, gray, binary;
    Canny(src, binary, 80, 160, 3, false);
    imshow("canny二值化", binary);
    Mat k = getStructuringElement(MORPH_RECT, Size(3, 3), Point(-1, -1));
    dilate(binary, binary, k);
    // 轮廓发现与绘制
    vector&lt;vector&lt;Point&gt;&gt; contours;
    findContours(binary, contours,  RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());
    for (size_t t = 0; t &lt; contours.size(); t++) {
        // 最大外接轮廓
        Rect rect = boundingRect(contours[t]);
        int m = max(rect.width, rect.height);
        if (m &lt; 30) continue;
        // 直线拟合
        Vec4f oneline;
        fitLine(contours[t], oneline, DIST_L1, 0, 0.01, 0.01);
        float cosθ = oneline[0];
        float sinθ = oneline[1];
        float x0 = oneline[2];
        float y0 = oneline[3];

        // 直线参数斜率k与截矩b
        float k = sinθ / cosθ; //求tanθ，也就是斜率
        float b = y0 - k * x0;

        float x = 0;
        float y = k * x + b;
        line(src, Point(x0, y0), Point(x, y), Scalar(0, 0, 255), 2, 8, 0);
    }
    imshow("结果", src);</code></pre> 
<ul><li><img alt="" height="310" src="https://images2.imgbox.com/ec/53/un8IhkNc_o.png" width="629"></li><li><li> <h3 id="%F0%9F%A4%8D%E8%BD%AE%E5%BB%93%E7%9A%84%E5%87%B8%E5%8C%85%EF%BC%9AconvexHull(%EF%BC%89"><strong>🤍轮廓的凸包：convexHull(）</strong></h3> </li></ul> 
<p>凸包（Convex Hull）是一个计算几何（图形学）中常见的概念。简单来说，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边形，它是能包含点集中所有点的。</p> 
<p>理解物体形状或轮廓的一种比较有用的方法便是计算一个物体的凸包，然后计算其凸缺陷（convexity defects）。</p> 
<pre>convexHull (   InputArray  points,         /输入的二维点集，Mat类型数据即可
               OutputArray     hull,       //输出参数，用于输出找到的凸包
               bool   clockwise = false,   //操作方向，为True时，输出的凸包为顺时针方向，否则为逆时针方向
               bool  returnPoints = true   //凸包的返回形式，默认值为true，此时返回点坐标的形式，否则返回对应点的索引值
            )</pre> 
<p> <strong><strong>opencv实现：</strong></strong></p> 
<pre><code class="language-cpp">    Mat src = imread("D:/opencv练习图片/凸包检测.jpg");
    imshow("原图片", src);
    // 二值化
    Mat dst, gray, binary;
    cvtColor(src, gray, COLOR_BGR2GRAY);
    threshold(gray, binary, 0, 255, THRESH_BINARY | THRESH_OTSU);
    // 形态学去除干扰
    Mat k = getStructuringElement(MORPH_RECT, Size(3, 3), Point(-1, -1));
    morphologyEx(binary, binary, MORPH_OPEN, k);
    imshow("binary", binary);
    // 轮廓发现与绘制
    vector&lt;vector&lt;Point&gt;&gt; contours;
    findContours(binary, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());
    for (size_t t = 0; t &lt; contours.size(); t++) {
        vector&lt;Point&gt; hull;
        convexHull(contours[t], hull);//凸包检测
        bool isHull = isContourConvex(contours[t]);//判断轮廓是否为凸包
        printf("test convex of the contours %s", isHull ? "Y" : "N");
        int len = hull.size();
        //绘制凸包
        for (int i = 0; i &lt; hull.size(); i++) {
            circle(src, hull[i], 4, Scalar(255, 0, 0), 2, 8, 0);//点
            line(src, hull[i%len], hull[(i + 1) % len], Scalar(0, 0, 255), 2, 8, 0);//线
        }
    }
    imshow("凸包检测", src);</code></pre> 
<p> <img alt="" height="234" src="https://images2.imgbox.com/6b/c3/nEnpioEF_o.png" width="399"></p> 
<p></p> 
<ul><li> <h3 id="%F0%9F%A7%A1%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%80%BC%E8%BF%91-%E9%80%BC%E8%BF%91%E7%9C%9F%E5%AE%9E%E5%BD%A2%E7%8A%B6%EF%BC%9AapproxPolyDP(%EF%BC%89"><strong>🧡多边形逼近-逼近真实形状：approxPolyDP(）</strong></h3> </li></ul> 
<blockquote> 
 <p>轮廓的多边形逼近指的是：使用多边形来近似表示一个轮廓。 多边形逼近的目的是为了减少轮廓的顶点数目。 多边形逼近的结果依然是一个轮廓，只是这个轮廓相对要粗旷一些。 </p> 
 <pre>void approxPolyDP(        InputArray curve,        //输入曲线，一般是由图像的轮廓点组成的点集
                          OutputArray approxCurve, //表示输出的逼近后多边形的点集（类型与输入曲线的类型相同）
                          double epsilon,          //轮廓逼近的顶点距离真实轮廓曲线的最大距离，该值越小表示越逼近真实轮廓
                          bool closed              //表示输出的多边形是否封闭
                  )</pre> 
</blockquote> 
<p> <strong>opencv实现：</strong></p> 
<pre><code class="language-cpp">Mat src = imread("D:/opencv练习图片/多边形逼近.png");
    Mat dstImage_3(src.size(), CV_8UC3, Scalar(0));
    Mat dstImage_6(src.size(), CV_8UC3, Scalar(0));
    Mat dstImage_10(src.size(), CV_8UC3, Scalar(0));
    imshow("原图片", src);
    // 二值化
    Mat dst, gray, binary;
    cvtColor(src, gray, COLOR_BGR2GRAY);
    threshold(gray, binary, 0, 255, THRESH_BINARY_INV | THRESH_OTSU);
    // 形态学去除干扰
    Mat k = getStructuringElement(MORPH_RECT, Size(3, 3), Point(-1, -1));
    morphologyEx(binary, binary, MORPH_OPEN, k);
    imshow("binary", binary);
    // 轮廓发现与绘制
    vector&lt;vector&lt;Point&gt;&gt; contours;
    findContours(binary, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE, Point());
    vector&lt;vector&lt;Point&gt;&gt; contours_poly(contours.size());
    for (int i = 0; i &lt; contours.size(); i++)
    {
        //epsilon==3
        approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
        drawContours(dstImage_3, contours_poly, i, Scalar(230,130,255), 1, LINE_AA);
        //epsilon==6
        approxPolyDP(Mat(contours[i]), contours_poly[i], 6, true);
        drawContours(dstImage_6, contours_poly, i, Scalar(255,255,160), 1, LINE_AA);
        //epsilon==10
        approxPolyDP(Mat(contours[i]), contours_poly[i], 10, true);
        drawContours(dstImage_10, contours_poly, i, Scalar(175, 255, 255), 1, LINE_AA);

    }
    imshow("epsilon=3", dstImage_3);
    imshow("epsilon=6", dstImage_6);
    imshow("epsilon=10", dstImage_10);</code></pre> 
<ul><li> <h3 id="%F0%9F%92%9B%E6%A3%80%E6%B5%8B%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E8%BD%AE%E5%BB%93%E5%86%85pointPolygonTest(%EF%BC%89"><strong>💛检测点是否在轮廓内pointPolygonTest(）</strong></h3> </li></ul> 
<p>OpenCV中实现这个功能的API叫做点多边形测试，它可以准确的得到一个点距离多边形的距离，如果点是轮廓点或者属于轮廓多边形上的点，距离是零，如果是多边形内部的点是是正数，如果是负数返回表示点是外部。</p> 
<p>利用这个特性，我们可以<strong>巧妙的获取轮廓最大内接圆的半径：</strong></p> 
<p>当这个点在轮廓内部（与轮廓距离为正数），其返回的距离是最大值的时候，这个距离就是轮廓的最大内接圆的半径，该点就是最大内接圆的圆心。这样我们就巧妙的获得了圆心的位置与半径，剩下的工作就很容易了完成，绘制一个圆而已，一行代码就可以搞定。</p> 
<blockquote> 
 <pre>double pointPolygonTest(
    InputArray contour,         //输入轮廓点集合
    Point2f pt,                 //输入图像上任一点
    bool measureDist MeasureDist//如果是True，则返回每个点到轮廓的距离，如果是False则返回+1，0，-1三个值，其中+1表示点在轮廓内部，0表示点在轮廓上，-1表示点在轮廓外
                        ) </pre> 
</blockquote> 
<p><strong> opencv实现：（绘制轮廓的最大内接圆和最小外接圆）</strong></p> 
<pre><code class="language-cpp">    Mat src = imread("图像最大内接圆.png");
    imshow("原图片", src);
    // 二值化
    Mat dst, gray, binary;
    cvtColor(src, gray, COLOR_BGR2GRAY);
    threshold(gray, binary, 0, 255, THRESH_BINARY | THRESH_OTSU);
    imshow("binary", binary);
    // 轮廓发现与绘制
    vector&lt;vector&lt;Point&gt;&gt; contours;
    findContours(binary, contours, RETR_LIST, CHAIN_APPROX_NONE);
    Mat  dist =Mat::zeros(src.size(), CV_32F);//定义一个Mat对象，存放原图中每个点到该轮廓的距离，为浮点型数据
    int dist1 = 0;
    int maxdist = 0;
    Point center;
    //寻找最大内接圆参数
         //遍历每个点，计算该点到轮廓距离
        for (int row = 0; row &lt; dist.rows; row++)
        {
            for (int col = 0; col &lt; dist.cols; col++)
            {
                //通过点多边形检测计算获得点到轮廓距离，并存放至dist中
                dist1 = pointPolygonTest(contours[0], Point(col, row), true);

                if (dist1 &gt; maxdist)
                {
                    maxdist = dist1;//找出dist1中的最大值
                    center = Point(col, row);//获取最大值的坐标
                }
            }
        }    

    //寻找最小外接圆参数
    vector&lt;Point2f&gt;centers(contours.size());//圆心个数
    vector&lt;float&gt;radius(contours.size());//半径个数
    minEnclosingCircle(contours[1], centers[1], radius[1]);
    //绘制最小外接圆
    circle(src, centers[1], radius[1], Scalar(0, 0, 255), 2);    
    //绘制最大的内接圆
    circle(src, center, maxdist, Scalar(0, 255, 0), 1, LINE_8, 0);    
    imshow("src", src);</code></pre> 
<p><img alt="" height="205" src="https://images2.imgbox.com/4b/a5/wqb0Grsa_o.png" width="395"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb2a8a875888f9bab7ef3c6e5afe46c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JSON看这个</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b8190e420698d2cfbe0dda9701afca7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">BUUCTF_Web题目题解记录1</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>