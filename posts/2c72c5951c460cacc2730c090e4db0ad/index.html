<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>3种 Springboot 全局时间格式化方式，别再写重复代码了 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="3种 Springboot 全局时间格式化方式，别再写重复代码了" />
<meta property="og:description" content="时间格式化在项目中使用频率是非常高的，当我们的 API 接口返回结果，需要对其中某一个 date 字段属性进行特殊的格式化处理，通常会用到 SimpleDateFormat 工具处理。
SimpleDateFormat dateFormat = new SimpleDateFormat(&#34;yyyy-MM-dd&#34;); Date stationTime = dateFormat.parse(dateFormat.format(PayEndTime())); 可一旦处理的地方较多，不仅 CV 操作频繁，还产生很多重复臃肿的代码，而此时如果能将时间格式统一配置，就可以省下更多时间专注于业务开发了。
可能很多人觉得统一格式化时间很简单啊，像下边这样配置一下就行了，但事实上这种方式只对 date 类型生效。
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss spring.jackson.time-zone=GMT&#43;8 而很多项目中用到的时间和日期API 比较混乱， java.util.Date 、 java.util.Calendar 和 java.time LocalDateTime 都存在，所以全局时间格式化必须要同时兼容性新旧 API。
看看配置全局时间格式化前，接口返回时间字段的格式。
@Data public class OrderDTO { private LocalDateTime createTime; private Date updateTime; } 很明显不符合页面上的显示要求（有人抬杠为啥不让前端解析时间，我只能说睡服代码比说服人容易得多~）
未做任何配置的结果 一、@JsonFormat 注解 @JsonFormat 注解方式严格意义上不能叫全局时间格式化，应该叫部分格式化，因为@JsonFormat 注解需要用在实体类的时间字段上，而只有使用相应的实体类，对应的字段才能进行格式化。
@Data public class OrderDTO { @JsonFormat(locale = &#34;zh&#34;, timezone = &#34;GMT&#43;8&#34;, pattern = &#34;yyyy-MM-dd&#34;) private LocalDateTime createTime; @JsonFormat(locale = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/2c72c5951c460cacc2730c090e4db0ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-08T11:23:00+08:00" />
<meta property="article:modified_time" content="2020-09-08T11:23:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">3种 Springboot 全局时间格式化方式，别再写重复代码了</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>时间格式化在项目中使用频率是非常高的，当我们的 <code>API</code> 接口返回结果，需要对其中某一个 <code>date</code> 字段属性进行特殊的格式化处理，通常会用到 <code>SimpleDateFormat</code> 工具处理。</p> 
 <pre class="has"><code class="language-go">SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
Date stationTime = dateFormat.parse(dateFormat.format(PayEndTime()));
</code></pre> 
 <p>可一旦处理的地方较多，不仅 <code>CV</code> 操作频繁，还产生很多重复臃肿的代码，而此时如果能将时间格式统一配置，就可以省下更多时间专注于业务开发了。</p> 
 <p>可能很多人觉得统一格式化时间很简单啊，像下边这样配置一下就行了，但事实上这种方式只对 <code>date</code> 类型生效。</p> 
 <pre class="has"><code class="language-go">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
</code></pre> 
 <p>而很多项目中用到的时间和日期<code>API</code> 比较混乱， <code>java.util.Date</code> 、 <code>java.util.Calendar</code> 和 <code>java.time LocalDateTime</code> 都存在，所以全局时间格式化必须要同时兼容性新旧 <code>API</code>。</p> 
 <hr> 
 <p>看看配置全局时间格式化前，接口返回时间字段的格式。</p> 
 <pre class="has"><code class="language-go">@Data
public class OrderDTO {

    private LocalDateTime createTime;

    private Date updateTime;
}

</code></pre> 
 <p>很明显不符合页面上的显示要求（有人抬杠为啥不让前端解析时间，我只能说睡服代码比说服人容易得多~）</p> 
 <img src="https://images2.imgbox.com/af/50/IRD05uhb_o.png"> 
 <figcaption>
   未做任何配置的结果 
 </figcaption> 
 <h3>一、@JsonFormat 注解</h3> 
 <p><code>@JsonFormat</code> 注解方式严格意义上不能叫全局时间格式化，应该叫部分格式化，因为<code>@JsonFormat</code> 注解需要用在实体类的时间字段上，而只有使用相应的实体类，对应的字段才能进行格式化。</p> 
 <pre class="has"><code class="language-go">@Data
public class OrderDTO {

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd")
    private LocalDateTime createTime;

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    private Date updateTime;
}
</code></pre> 
 <p>字段加上 <code>@JsonFormat</code> 注解后，<code>LocalDateTime</code> 和 <code>Date</code> 时间格式化成功。</p> 
 <img src="https://images2.imgbox.com/ef/77/LXdXrnDR_o.png"> 
 <figcaption>
   @JsonFormat 注解格式化 
 </figcaption> 
 <h3>二、@JsonComponent 注解（推荐）</h3> 
 <p>这是我个人比较推荐的一种方式，前边看到使用 <code>@JsonFormat</code> 注解并不能完全做到全局时间格式化，所以接下来我们使用 <code>@JsonComponent</code> 注解自定义一个全局格式化类，分别对 <code>Date</code> 和 <code>LocalDate</code> 类型做格式化处理。</p> 
 <pre class="has"><code class="language-go">
@JsonComponent
public class DateFormatConfig {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    /**
     * @author xiaofu
     * @description date 类型全局时间格式化
     * @date 2020/8/31 18:22
     */
    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilder() {

        return builder -&gt; {
            TimeZone tz = TimeZone.getTimeZone("UTC");
            DateFormat df = new SimpleDateFormat(pattern);
            df.setTimeZone(tz);
            builder.failOnEmptyBeans(false)
                    .failOnUnknownProperties(false)
                    .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
                    .dateFormat(df);
        };
    }

    /**
     * @author xiaofu
     * @description LocalDate 类型全局时间格式化
     * @date 2020/8/31 18:22
     */
    @Bean
    public LocalDateTimeSerializer localDateTimeDeserializer() {
        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));
    }

    @Bean
    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() {
        return builder -&gt; builder.serializerByType(LocalDateTime.class, localDateTimeDeserializer());
    }
}
</code></pre> 
 <p>看到 <code>Date</code> 和 <code>LocalDate</code> 两种时间类型格式化成功，此种方式有效。</p> 
 <img src="https://images2.imgbox.com/21/32/LxGZyiWB_o.png"> 
 <figcaption>
   @JsonComponent 注解处理格式化 
 </figcaption> 
 <p>但还有个问题，实际开发中如果我有个字段不想用全局格式化设置的时间样式，想自定义格式怎么办？</p> 
 <p>那就需要和 <code>@JsonFormat</code> 注解配合使用了。</p> 
 <pre class="has"><code class="language-go">@Data
public class OrderDTO {

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd")
    private LocalDateTime createTime;

    @JsonFormat(locale = "zh", timezone = "GMT+8", pattern = "yyyy-MM-dd")
    private Date updateTime;
}
</code></pre> 
 <p>从结果上我们看到 <code>@JsonFormat</code> 注解的优先级比较高，会以 <code>@JsonFormat</code> 注解的时间格式为主。</p> 
 <img src="https://images2.imgbox.com/71/b7/DQVbNrHj_o.png"> 
 <h3>三、@Configuration 注解</h3> 
 <p>这种全局配置的实现方式与上边的效果是一样的。</p> 
 <blockquote> 
  “ 
  <p>注意：在使用此种配置后，字段手动配置<code>@JsonFormat</code> 注解将不再生效。</p> 
  ” 
 </blockquote> 
 <pre class="has"><code class="language-go">
@Configuration
public class DateFormatConfig2 {

    @Value("${spring.jackson.date-format:yyyy-MM-dd HH:mm:ss}")
    private String pattern;

    public static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    @Bean
    @Primary
    public ObjectMapper serializingObjectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();
        JavaTimeModule javaTimeModule = new JavaTimeModule();
        javaTimeModule.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer());
        javaTimeModule.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer());
        objectMapper.registerModule(javaTimeModule);
        return objectMapper;
    }

    /**
     * @author xiaofu
     * @description Date 时间类型装换
     * @date 2020/9/1 17:25
     */
    @Component
    public class DateSerializer extends JsonSerializer&lt;Date&gt; {
        @Override
        public void serialize(Date date, JsonGenerator gen, SerializerProvider provider) throws IOException {
            String formattedDate = dateFormat.format(date);
            gen.writeString(formattedDate);
        }
    }

    /**
     * @author xiaofu
     * @description Date 时间类型装换
     * @date 2020/9/1 17:25
     */
    @Component
    public class DateDeserializer extends JsonDeserializer&lt;Date&gt; {

        @Override
        public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {
            try {
                return dateFormat.parse(jsonParser.getValueAsString());
            } catch (ParseException e) {
                throw new RuntimeException("Could not parse date", e);
            }
        }
    }

    /**
     * @author xiaofu
     * @description LocalDate 时间类型装换
     * @date 2020/9/1 17:25
     */
    public class LocalDateTimeSerializer extends JsonSerializer&lt;LocalDateTime&gt; {
        @Override
        public void serialize(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString(value.format(DateTimeFormatter.ofPattern(pattern)));
        }
    }

    /**
     * @author xiaofu
     * @description LocalDate 时间类型装换
     * @date 2020/9/1 17:25
     */
    public class LocalDateTimeDeserializer extends JsonDeserializer&lt;LocalDateTime&gt; {
        @Override
        public LocalDateTime deserialize(JsonParser p, DeserializationContext deserializationContext) throws IOException {
            return LocalDateTime.parse(p.getValueAsString(), DateTimeFormatter.ofPattern(pattern));
        }
    }
}
</code></pre> 
 <img src="https://images2.imgbox.com/3c/19/FylqbfRr_o.png"> 
 <h3>总结</h3> 
 <p>分享了一个简单却又很实用的 <code>Springboot</code> 开发技巧，其实所谓的开发效率，不过是一个又一个开发技巧堆砌而来，聪明的程序员总是能用最少的代码完成任务。</p> 
 <pre class="has"><code class="language-php">特别推荐一个分享架构+算法的优质内容，还没关注的小伙伴，可以长按关注一下：


</code></pre> 
 <p style="text-align: center"><img src="https://images2.imgbox.com/79/92/H0ZsURUH_o.png"></p> 
 <pre class="has"><code class="language-php">长按订阅更多精彩▼

如有收获，点个在看，诚挚感谢
</code></pre> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9f0c9c012e27346f0683af3610c22ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Element Ui 修改MessageBox内容（图片&#43;文字）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96635a4d07bb03fac54fa2bce65f345b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">校验List集合中的对象属性问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>