<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux下web系统性能测试工具,Web Service性能测试工具比较 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux下web系统性能测试工具,Web Service性能测试工具比较" />
<meta property="og:description" content="背景
希望选择一款Web Service性能测试工具，能真实模拟大量用户访问网站时的请求，从而获取服务器当前的请求处理能力(请求数/秒)。 以微信服务器为例，每个用户用独立的登录token，做各种操作，比如刷消息、发消息、看朋友圈等。
希望该性能测试工具符合如下要求：
测试脚本能力，最好是Python/Ruby等最常用的
每个并发实例能使用不同参数
CLI启动测试，这对自动化测试很重要
Session支持，也就是第一个请求的响应，能用于后续请求的参数。
单个结点的并发数量高。
分布式支持，不受限于单个结点的计算能力。
性能测试工具选手：
Gatling
Gatling是一款基于Scala 开发的高性能服务器性能测试工具，它主要用于对服务器进行负载等测试，并分析和测量服务器的各种性能指标。Gatling主要用于测量基于HTTP的服务器，比如Web应用程序，RESTful服务等，除此之外它拥有以下特点：
支持Akka Actors 和 Async IO，从而能达到很高的性能
支持实时生成Html动态轻量报表，从而使报表更易阅读和进行数据分析
支持DSL脚本，从而使测试脚本更易开发与维护
支持录制并生成测试脚本，从而可以方便的生成测试脚本
支持导入HAR(Http Archive)并生成测试脚本
支持Maven，Eclipse，IntelliJ等，以便于开发
支持Jenkins，以便于进行持续集成
支持插件，从而可以扩展其功能，比如可以扩展对其他协议的支持
开源免费
object Search {
val feeder = csv(&#34;search.csv&#34;).random // 1, 2
val search = exec(http(&#34;Home&#34;)
.get(&#34;/&#34;))
.pause(1)
.feed(feeder) // 3
.exec(http(&#34;Search&#34;)
.get(&#34;/computers?f=${searchCriterion}&#34;) // 4
.check(css(&#34;a:contains(&#39;${searchComputerName}&#39;)&#34;, &#34;href&#34;).saveAs(&#34;computerURL&#34;))) // 5
.pause(1)
.exec(http(&#34;Select&#34;)
.get(&#34;${computerURL}&#34;)) // 6
.pause(1)
}
统计图：
nGrinder
官网很卡，真的很卡...zzz...
http://naver.github.io/ngrinder/
nGrinder是一个基于 Grinder 开发的一个非常易于管理和使用的性能测试系统。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/8c3cdefc51ed972ed2b372b1635b2469/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-05T22:35:01+08:00" />
<meta property="article:modified_time" content="2021-05-05T22:35:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux下web系统性能测试工具,Web Service性能测试工具比较</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>背景</p> 
 <p>希望选择一款Web Service性能测试工具，能真实模拟大量用户访问网站时的请求，从而获取服务器当前的请求处理能力(请求数/秒)。 以微信服务器为例，每个用户用独立的登录token，做各种操作，比如刷消息、发消息、看朋友圈等。</p> 
 <p>希望该性能测试工具符合如下要求：</p> 
 <p>测试脚本能力，最好是Python/Ruby等最常用的</p> 
 <p>每个并发实例能使用不同参数</p> 
 <p>CLI启动测试，这对自动化测试很重要</p> 
 <p>Session支持，也就是第一个请求的响应，能用于后续请求的参数。</p> 
 <p>单个结点的并发数量高。</p> 
 <p>分布式支持，不受限于单个结点的计算能力。</p> 
 <p>性能测试工具选手：</p> 
 <p>Gatling</p> 
 <p>Gatling是一款基于Scala 开发的高性能服务器性能测试工具，它主要用于对服务器进行负载等测试，并分析和测量服务器的各种性能指标。Gatling主要用于测量基于HTTP的服务器，比如Web应用程序，RESTful服务等，除此之外它拥有以下特点：</p> 
 <p>支持Akka Actors 和 Async IO，从而能达到很高的性能</p> 
 <p>支持实时生成Html动态轻量报表，从而使报表更易阅读和进行数据分析</p> 
 <p>支持DSL脚本，从而使测试脚本更易开发与维护</p> 
 <p>支持录制并生成测试脚本，从而可以方便的生成测试脚本</p> 
 <p>支持导入HAR(Http Archive)并生成测试脚本</p> 
 <p>支持Maven，Eclipse，IntelliJ等，以便于开发</p> 
 <p>支持Jenkins，以便于进行持续集成</p> 
 <p>支持插件，从而可以扩展其功能，比如可以扩展对其他协议的支持</p> 
 <p>开源免费</p> 
 <p>object Search {<!-- --></p> 
 <p>val feeder = csv("search.csv").random // 1, 2</p> 
 <p>val search = exec(http("Home")</p> 
 <p>.get("/"))</p> 
 <p>.pause(1)</p> 
 <p>.feed(feeder) // 3</p> 
 <p>.exec(http("Search")</p> 
 <p>.get("/computers?f=${searchCriterion}") // 4</p> 
 <p>.check(css("a:contains('${searchComputerName}')", "href").saveAs("computerURL"))) // 5</p> 
 <p>.pause(1)</p> 
 <p>.exec(http("Select")</p> 
 <p>.get("${computerURL}")) // 6</p> 
 <p>.pause(1)</p> 
 <p>}</p> 
 <p>统计图：</p> 
 <p align="center"><img src="https://images2.imgbox.com/12/b9/WVCuS2kW_o.png" alt="e4704626f3aca032bd54041c2c75a243.png"></p> 
 <p>nGrinder</p> 
 <p>官网很卡，真的很卡...zzz...</p> 
 <p>http://naver.github.io/ngrinder/</p> 
 <p>nGrinder是一个基于 Grinder 开发的一个非常易于管理和使用的性能测试系统。</p> 
 <p>它 是由一个controller和连接它的多个agent组成，用户可以通过web界面管理和控制测试，以及查看测试报告，controller会把测试分 发到一个或多个agent去执行。用户可以设置使用多个进程和线程来并发的执行该脚本，而且在同一线程中，来重复不断的执行测试脚本，来模拟很多并发用 户。</p> 
 <p>nGrinder的测试是基于一个python的测试脚本，用户按照一定规则编写测试脚本以后，controller会将脚本以及需要的其他 文件分发到agent，用Jython执行。并在执行过程中收集运行情况、响应时间、测试目标服务器的运行情况等。并保存这些数据生成运行报告，以供以后 查看。</p> 
 <p>nGrinder的一大特点就是非常容易使用，安装也非常容易，可以做到开箱即用，测试用户也可以很容易就开始测试任务。当然，如果想执行一些比较复杂场景的性能测试，就需要测试人员对python有一定认识。</p> 
 <p>#</p> 
 <p># testRandomise.py</p> 
 <p>#</p> 
 <p>import random</p> 
 <p>import string</p> 
 <p>class TestRandomise:</p> 
 <p>def __init__(self, filename):</p> 
 <p>self._users = []</p> 
 <p>infile = open(filename, "r")</p> 
 <p>for line in infile.readlines():</p> 
 <p>self._users.append(string.split((line),','))</p> 
 <p>infile.close()</p> 
 <p>def getUserInfo(self):</p> 
 <p>"Pick a random (user, password) from the list."</p> 
 <p>return random.choice(self._users)</p> 
 <p>#</p> 
 <p># Test script. Originally recorded by the TCPProxy.</p> 
 <p>#</p> 
 <p>from testRandomise import TestRandomise</p> 
 <p>tre = TestRandomise("users.txt")</p> 
 <p>class TestRunner:</p> 
 <p>def __call__(self):</p> 
 <p># Get user for this run.</p> 
 <p>(user, passwd) = tre.getUserInfo()</p> 
 <p># ...</p> 
 <p># Use the user details to log in.</p> 
 <p>tests[2002].POST('https://host:443/securityservlet',</p> 
 <p>( NVPair('functionname', 'Login'),</p> 
 <p>NVPair('pagename', 'Login'),</p> 
 <p>NVPair('ms_emailAddress', user),</p> 
 <p>NVPair('ms_password', passwd), ))</p> 
 <p>统计图：</p> 
 <p align="center"><img src="https://images2.imgbox.com/0b/de/InINNsa0_o.png" alt="788bd95a610b36d023b5d20f95a60fc6.png"></p> 
 <p>Locust</p> 
 <p>Locust 是一个开源负载测试工具。使用 Python 代码定义用户行为，也可以仿真百万个用户。</p> 
 <p>Locust 是非常简单易用，分布式，用户负载测试工具。Locust 主要为网站或者其他系统进行负载测试，能测试出一个系统可以并发处理多少用户。</p> 
 <p>Locust 是完全基于时间的，因此单个机器支持几千个并发用户。相比其他许多事件驱动的应用，Locust 不使用回调，而是使用轻量级的处理方式 gevent。</p> 
 <p>from locust import HttpLocust, TaskSet</p> 
 <p>def login(l):</p> 
 <p>l.client.post("/login", {"username":"ellen_key", "password":"education"})</p> 
 <p>def index(l):</p> 
 <p>l.client.get("/")</p> 
 <p>def profile(l):</p> 
 <p>l.client.get("/profile")</p> 
 <p>class UserBehavior(TaskSet):</p> 
 <p>tasks = {index:2, profile:1}</p> 
 <p>def on_start(self):</p> 
 <p>login(self)</p> 
 <p>class WebsiteUser(HttpLocust):</p> 
 <p>task_set = UserBehavior</p> 
 <p>min_wait=5000</p> 
 <p>max_wait=9000</p> 
 <p>统计图：</p> 
 <p align="center"><img src="https://images2.imgbox.com/a7/1c/K943P00l_o.png" alt="faf1845ffd69e60caddd355cbf5318b5.png"></p> 
 <p>其他未参与比较的工具</p> 
 <p>因为没有脚本能力或CLI，所以未加入比较</p> 
 <p>JMeter</p> 
 <p>ApacheBench(ab)</p> 
 <p>Tsung</p> 
 <p>Locust作者对JMeter和Tsung发的牢骚：</p> 
 <p>我们研究了现有的解决方案，都不符合要求。比如Apache JMeter和Tsung。</p> 
 <p>JMeter基于UI操作，容易上手，但基本上不具备编程能力。其次JMeter基于线程，要模拟数千用户几乎不可能。</p> 
 <p>Tsung基于Erlang，能模拟上千用户并易于扩展，但它基于XML的DSL，描述场景能力弱，且需要大量的数据处理才知道测试结果。</p> 
 <p>比较</p> 
 <p>比较科目x工具矩阵</p> 
 <p>比较科目</p> 
 <p>Gatling</p> 
 <p>nGrinder</p> 
 <p>Locust</p> 
 <p>并发机制</p> 
 <p>Akka Actor</p> 
 <p>Java线程</p> 
 <p>Python gevent</p> 
 <p>单结点并发数量</p> 
 <p>待实验</p> 
 <p>待实验(官网数字：3000)</p> 
 <p>待实验</p> 
 <p>分布式支持</p> 
 <p>N</p> 
 <p>agent-controller</p> 
 <p>master-slave</p> 
 <p>录制脚本</p> 
 <p>Http Proxy</p> 
 <p>TCProxy</p> 
 <p>N</p> 
 <p>测试脚本DSL</p> 
 <p>scala dsl</p> 
 <p>Jython/Groovy</p> 
 <p>Python</p> 
 <p>Session支持</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>CLI启动测试</p> 
 <p>gatling.sh</p> 
 <p>Y</p> 
 <p>N (需要在浏览器从点击启动测试)</p> 
 <p>性能测试结果统计</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>监控被测试服务器</p> 
 <p>N</p> 
 <p>Y</p> 
 <p>N</p> 
 <p>每个实例不同参数</p> 
 <p>★★★★★ 参数文件</p> 
 <p>★★★☆☆ 资源文件和线程Id</p> 
 <p>★★☆☆☆ 变通办法：每个并发实例依次从参数文件中读取</p> 
 <p>结论</p> 
 <p>很明显，首选的全能选手就是Gatling，Akka Actor的并发模型就是来自于并发语言的鼻祖Erlang。</p> 
 <p>如果想自己扩展性能测试工具，那么Locust这个小而精的工具可以考虑。</p> 
 <p>nGrinder工具是韩国版微信Line开源的，并且专门开设了中文论坛，由韩国工程师回答中国开发者。但有两个问题,一是官网太卡，其二示例都是片段不完整。</p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2eae684dbd5e15fea01bbe14f97b90a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ajax请求步骤和封装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a563090eca30451cb03175e7c2a6f419/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python3爬虫——贴吧实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>