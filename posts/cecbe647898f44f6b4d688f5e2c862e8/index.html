<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C语言] [游戏] 三子棋 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[C语言] [游戏] 三子棋" />
<meta property="og:description" content="游戏简介&gt;&gt;&gt; 三子棋的游戏如下图，游戏规则是 两个玩家分别在 3x3 的棋盘上下棋，只要有一个玩家下的3个棋子先连成一条了直线，那么他就获胜。如果棋盘满了还没有分出胜负那么就定为平局。
接下来我们使用C语言写一个玩家与电脑PK的三子棋游戏。
注意： 我们在写一些重要的代码时，最好把自定义函数的声明、定义以及整个程序的实现，分别放在不同的文件里面。这样写不仅会让你的逻辑更清晰、更容易调试代码还便于后续对整个代码的保密操作。
关于三子棋代码，我按照上文分为 game.h \ game.c \ test.c 三个文件，分别写自定义函数的声明、定义以及整个程序的实现。然后记得一边写一边测试，这样有错误的话改起来不费力。
三子棋代码的实现思路&gt;&gt;&gt; 先来分析一下三子棋游戏的组成成分和动作：游戏开始和结束的提示、棋盘、两种棋子、玩家下棋、判断输赢和电脑下棋。
游戏开始和结束的提示&gt;&gt;&gt; 游戏的第一步一般都是让玩家选择“开始游戏”或者“退出游戏”，因为有人可能只是手滑而点进了这个游戏。还得注意为了方便以后写代码不繁琐且逻辑清晰，我们尽量都自定义函数来实现这些需要重复的操作，包括接下来的各种功能。 所以这里需要写一个函数 menu 让玩家选择是否开始游戏。
//像这样自定义一个功能单一的函数menu只负责打印选项单 void menu() { printf(&#34;********************\n&#34;); printf(&#34;****** 1.play ******\n&#34;); printf(&#34;****** 0.exit ******\n&#34;); printf(&#34;********************\n&#34;); } //当玩家选择1后开始游戏，进入 game函数 void test() { int a = 0; do { menu(); scanf(&#34;%d&#34;, &amp;a); if (1 == a) { game(); break; } else { printf(&#34;输入错误，请重新输入：\n&#34;); } } while (a); printf(&#34;退出游戏。\n&#34;); } //当玩家不想玩后选择0，即结束游戏 这里使用 do while 循环是因为一开始就先要让玩家判断是否开始游戏，如果玩家输入错误需要重新输入（先执行一次，后判断是否循环），所以输入这个操作也要放在循环里。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/cecbe647898f44f6b4d688f5e2c862e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-22T22:04:59+08:00" />
<meta property="article:modified_time" content="2022-03-22T22:04:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C语言] [游戏] 三子棋</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>游戏简介&gt;&gt;&gt;</h2> 
<p>        三子棋的游戏如下图，游戏规则是 两个玩家分别在 3x3 的棋盘上下棋，只要有一个玩家下的3个棋子先连成一条了直线，那么他就<strong>获胜</strong>。如果棋盘满了还没有分出胜负那么就定为<strong>平局</strong>。</p> 
<p>        接下来我们使用C语言写一个玩家与电脑PK的三子棋游戏。</p> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/05/0f/dNuFLS1A_o.png" width="450"></p> 
<p><strong>        注意：</strong> 我们在写一些重要的代码时，最好把自定义函数的声明、定义以及整个程序的实现，<strong>分别放在不同的文件里面</strong>。这样写不仅会让你的逻辑更清晰、更容易调试代码还便于后续对整个代码的保密操作。</p> 
<p>        关于三子棋代码，我按照上文分为<strong> game.h \ game.c \ test.c</strong> 三个文件，分别写自定义函数的声明、定义以及整个程序的实现。然后记得一边写一边测试，这样有错误的话改起来不费力。</p> 
<p></p> 
<h2>三子棋代码的实现思路&gt;&gt;&gt;</h2> 
<p>        先来分析一下三子棋游戏的组成成分和动作：游戏开始和结束的提示、棋盘、两种棋子、<strong>玩家下棋</strong>、判断输赢和电脑下棋。</p> 
<p></p> 
<h3>游戏开始和结束的提示&gt;&gt;&gt;</h3> 
<p>        游戏的<strong>第一步</strong>一般都是让玩家选择“开始游戏”或者“退出游戏”，因为有人可能只是手滑而点进了这个游戏。还得注意为了方便以后写代码不繁琐且逻辑清晰，<strong>我们尽量都自定义函数来实现这些需要重复的操作</strong>，包括接下来的各种功能。 <strong>所以这里需要写一个函数 menu 让玩家选择是否开始游戏</strong>。</p> 
<pre><code>//像这样自定义一个功能单一的函数menu只负责打印选项单

void menu()
{
	printf("********************\n");
	printf("****** 1.play ******\n");
	printf("****** 0.exit ******\n");
	printf("********************\n");
}</code></pre> 
<pre><code>//当玩家选择1后开始游戏，进入 game函数

void test()
{
	int a = 0;
	do
	{
		menu();
		scanf("%d", &amp;a);
		if (1 == a)
		{
			game();
			break;
		}
		else
		{
			printf("输入错误，请重新输入：\n");
		}
	} while (a);
	printf("退出游戏。\n");
}

//当玩家不想玩后选择0，即结束游戏</code></pre> 
<p>         这里使用 <strong>do while</strong> 循环是因为一开始就先要让玩家判断是否开始游戏，如果玩家输入错误需要重新输入<strong>（先执行一次，后判断是否循环）</strong>，所以输入这个操作也要放在循环里。</p> 
<p>        把menu函数也放在这个循环中，等一局游戏结束后再次出现menu选项的具体数值方便玩家继续选择。</p> 
<p>        先把最开始的逻辑写好（是否开始）。如果玩家选择了1.开始游戏，将进入<strong> game 函数</strong>，我将三子棋游戏的相关函数<strong>都在这个函数调用</strong>。</p> 
<p></p> 
<h3>棋盘、两种棋子&gt;&gt;&gt;</h3> 
<p>        根据我们对游戏的了解，开始前要打印一次设计好的棋盘，上面没有棋子。后续每次下棋后都要<strong>同时打印棋盘和棋子</strong>。</p> 
<p>       下棋的数据都要存储起来并对应到棋子上。让玩家下棋的方法可以试试<strong>让玩家输入行数和列数</strong>  这个操作就像输入二维数组的行和列，而且直观上对应着棋盘我们也可能会想到使用二维数组来实现，<strong>二维数组的行和列刚好对应了棋盘的行和列</strong>。所以刚开始要把这个二维数组初始化为全空格（这样比较简洁），后面下棋时在赋值（棋子）。我选择了 * 作为玩家棋子， #　作为电脑棋子。</p> 
<p>        玩家看到的棋盘应该是由一些<strong>分隔的线</strong>和<strong>能够下棋的空位置</strong>（上文的<strong>二维数组）</strong>组成。这些线方便玩家看出棋盘的行列，二维数组要存放棋子。也可以理解为<strong>分隔线是视觉上的棋盘，二维数组才是真的棋盘（放置棋子）</strong>。所以它们是一体，设计函数时得注意。</p> 
<p>        让二维数组刚开始看起来是<strong>能够下棋的空位置</strong>，需要把每个元素都初始化为 ‘  ’（空格）。</p> 
<pre><code>
//初始化下棋的位置为全空格
void chessboard(char board[ROW][COL],int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		for (j = 0; j &lt; col; j++)
			board[i][j] = ' ';
	}
	
}

//打印棋盘
void print_chessboard(char board[ROW][COL],int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		for (j = 0; j &lt; col; j++)
		{
			//注意|比空格的数量少一
				printf(" %c ", board[i][j]);
				if (j &lt; row - 1)
					printf("|");
		}
		printf("\n");
		//打印分割每一行的---
		if (i &lt; row - 1)
		{
			for (j = 0; j &lt; col; j++)
			{
				printf("---");
				if (j &lt; col - 1)
					printf("|");
			}
		printf("\n");
		}
		
	}
	
}</code></pre> 
<p>        我们传递三个参数是因为：函数都需要对棋盘进行操作，所以有第一个参数。而棋盘的行数和列数或许会改变而且二维数组和函数里的循环需要这两个变量 ，很重要，于是也需要这些参数。  至于循环里的i、j变量对于我们操作棋盘只起到辅助作用，使用的时候在定义就好，而且尽<strong>量减少不必要的参数，否则参数过多不好记忆</strong>。</p> 
<p>        <strong>函数的返回类型是 void </strong>是因为我们直接对char board[ROW][COL] 这个二维数组操作了，既传址调用（<strong>char a[ ] 本质上是 char *a 类型</strong>），不需要返回值。</p> 
<p>        在这里我使用了#define 定义标识符常量。因为如果将来你想要扩大棋盘，直接修改这里会很方便。</p> 
<p>        （ 我们要注意代码的灵活性、可重用性等，所以在设计代码时就得对这些进行思考，尽量把能想到的、可能出错的问题都在代码的设计之除想好。这样写出来的代码才是好的代码。）</p> 
<pre><code>#define ROW 3
#define COL 3</code></pre> 
<p></p> 
<h3> 玩家下棋&gt;&gt;&gt;</h3> 
<p>        先提示玩家下棋、输入行数和列数，然后打印出玩家下好棋后的棋盘。在之前我们把这个二维数组的每个元素都赋值为 ‘  ’，这时候只要<strong>把选中的‘  ’改为棋子</strong>，再次调用上文写好的打印棋盘的函数。</p> 
<p>        但值得注意的是<strong>“ 把选中的‘  ’改为棋子 ”</strong> ,我们都知道没有棋子的位置才可以下棋。所以在每次 <strong>下棋 </strong>这个动作开始之前都要让电脑判断 这个位置是否可以下棋。我们得把玩家想成<strong>很会手滑的小白</strong>（doge）。</p> 
<p>        当玩家下棋时，他输入的应该是直接看到的1/2/3行，而数组是通过下标访问的，实际的电脑操作是应该把玩家输入的坐标减一。还要<strong>注意数组不可以越界访问</strong>，应该对手滑小白玩家输入的行数和列数进行判断，在1~3范围内才可以给他下棋，否则请提示他请重新输入。</p> 
<pre><code>//玩家下棋
void  player_move(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	
	while (1)
	{
		printf("请按顺序输入将要下棋的位置的行数和列数：\n");

 //得给个提示，告诉玩家可以开始下棋了。这样游戏体验感才好。

		scanf("%d%d", &amp;x, &amp;y);

		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{

			//没有棋子才可以下棋

			if (board[x - 1][y - 1] == ' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
			{
				printf("该坐标被占用，请重新输入\n");
			}
		}
		else
		{
			printf("坐标输入错误，请重新输入\n");
		}
	}
}</code></pre> 
<p></p> 
<h3>判断输赢&gt;&gt;&gt;</h3> 
<p>        下棋后一共会出现四种结果：玩家赢、电脑赢、平局和继续。写函数时对应这四种情况分别返回 ‘ * ’、'#'、‘Q’、‘C’ 。</p> 
<p>        在每次下棋后都应该做一次判断。</p> 
<p>       <strong> 先判断输赢</strong>，这里得对每种可能赢的结果都要判断！没赢才关心平局，<strong>不平局才继续</strong>。</p> 
<pre><code>char is_win(char board[ROW][COL], int row, int col)
{
	int i = 0;
	//判断行
	for (i = 0; i &lt; row; i++)
	{
		if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != ' ')
		{
			return board[i][1];
		}
	}

	//判断列
	for (i = 0; i &lt; col; i++)
	{
		if (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != ' ')
		{
			return board[1][i];
		}
	}

	//对角线
	if (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != ' ')
	{
		return board[1][1];
	}
	if (board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0] &amp;&amp; board[1][1] != ' ')
	{
		return board[1][1];
	}

}</code></pre> 
<p> 如果<strong>赢了那么返回棋子</strong>，通过判断是哪种棋子就知道是谁赢。所以这里的函数设计不用分别对玩家和电脑进行判断，代码不冗余。</p> 
<pre><code>//判断棋盘是否满了，没赢就满是平局
static int if_full(char board[ROW][COL], int row, int col)
{
	//这个函数只为 is_win 服务，所以可以限制他的使用范围只在本文件中

	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{		
		for (j = 0; j &lt; col; j++)
		{
			if (board[i][j] == ' ')
			{
				return 0;//没满
			}
		}
	}
	return 1;//满了
}


char is_win(char board[ROW][COL], int row, int col)
{
	int i = 0;
	//判断行
	for (i = 0; i &lt; row; i++)
	{
		if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != ' ')
		{
			return board[i][1];
		}
	}

	//判断列
	for (i = 0; i &lt; col; i++)
	{
		if (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != ' ')
		{
			return board[1][i];
		}
	}

	//对角线
	if (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != ' ')
	{
		return board[1][1];
	}
	if (board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0] &amp;&amp; board[1][1] != ' ')
	{
		return board[1][1];
	}

	//这里的return是按我们分析的判断顺序执行的，
	//如果上面输赢判断出来了那么该函数会直接跳出去的
	 
	//判断平局
	if (if_full(board, row, col) == 1)
	{
		return 'Q';
	}

	//继续
	return 'C';
}</code></pre> 
<p>        判断平局这个函数只为下面这个函数服务，我们可以用 static 修饰它，让它只能在这个文件中使用，不暴露它。这种行为也是对代码的一种保护。</p> 
<p></p> 
<h3>电脑下棋&gt;&gt;&gt;</h3> 
<p>        电脑下棋和玩家差不多，电脑直接下棋不用给提示。电脑是随机下棋，这里需要使用<strong>随机数</strong>。（关于这个函数先不在这里细讲了，不然篇幅太大，我先鸽一下......）</p> 
<pre><code>//电脑下棋
void  computer_move(char board[ROW][COL], int row, int col)
{	
	int x = 0;
	int y = 0;

	while (1)
	{
		 x = rand() % row;//row=3时x的结果范围: 0~2
		 y = rand() % col;

		 if ( x&gt;=0 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= col &amp;&amp; board[x][y] == ' ')
		 {
			 board[x][y] = '#';
			 break;
		 }

	}
}
</code></pre> 
<p></p> 
<h2>总代码&gt;&gt;&gt;</h2> 
<p>        先来这个game函数的逻辑。如果下棋后没有 “ 继续 ” 命令，那么将跳出循环输出结果。</p> 
<pre><code>void game()
{
	char ch = 0;
	//创建二维数组存放下棋数据
	char board[ROW][COL] = { 0 };
	//初始化棋盘
	chessboard(board, ROW, COL);
	//打印棋盘
	print_chessboard(board, ROW, COL);
	//随机数
	srand((unsigned int)time(NULL));
	
	while (1)
	{
		printf("  玩家下棋 \n");
		//玩家下棋（接着打印下棋结果）
		player_move(board, ROW, COL);
		print_chessboard(board, ROW, COL);

		//判断输赢		
		if ((ch = is_win(board, ROW, COL)) != 'C')
			break;

		//电脑下棋（接着打印下棋结果）
		printf("  电脑下棋 \n");
		Sleep(1000);//让玩家的有点感觉，不要太慌
		computer_move(board, ROW, COL);
		print_chessboard(board, ROW, COL);

		//判断输赢
		if ((ch = is_win(board, ROW, COL)) != 'C')
			break;
	}

	if ('*' == ch)
		printf("玩家赢。\n ");
	if ('#' == ch)
		printf("电脑赢。\n ");
	if ('Q' == ch)
		printf("平局。\n ");

}</code></pre> 
<p>        注意中间使用了 <strong>Sleep 函数</strong>，使程序休息，单位毫秒（1000毫秒=1秒）。该函数的头文件是windows.h  。Sleep函数是windows环境下的一个头文件，所以只能在windows环境下使用。使用时直接在需要休息的地方写（S 开头是大写的） Sleep（1000）； // 表示程序休息1秒。（感觉上达到状态进行中的效果）</p> 
<p>      <strong>  下面附上整个代码: （注意有三个文件）</strong></p> 
<pre><code>// game.h

#define _CRT_SECURE_NO_WARNINGS 1
#define ROW 3
#define COL 3
#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;windows.h&gt;

//注意三子棋游戏实现的逻辑
//相关自定义函数的声明

//打印 功能选项单
void menu();
//初始化棋盘
void chessboard(char board[ROW][COL], int row, int col);
//打印棋盘 
void print_chessboard(char board[ROW][COL], int row, int col);

void game();

//玩家下棋（
void  player_move(char board[ROW][COL], int row, int col);

//判断输赢
char is_win(char board[ROW][COL], int row, int col);

//电脑下棋
void  computer_move(char board[ROW][COL], int row, int col);
		
</code></pre> 
<pre><code>// game.c

#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include"game.h"
//三子棋游戏的相关函数定义如下
void menu()
{
	printf("********************\n");
	printf("****** 1.play ******\n");
	printf("****** 0.exit ******\n");
	printf("********************\n");
}

//初始化棋盘
void chessboard(char board[ROW][COL],int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		for (j = 0; j &lt; col; j++)
			board[i][j] = ' ';
	}
	
}

//打印棋盘
void print_chessboard(char board[ROW][COL],int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{
		for (j = 0; j &lt; col; j++)
		{
			//注意|比空格的数量少一
				printf(" %c ", board[i][j]);
				if (j &lt; row - 1)
					printf("|");
		}
		printf("\n");
		//打印分割每一行的---
		if (i &lt; row - 1)
		{
			for (j = 0; j &lt; col; j++)
			{
				printf("---");
				if (j &lt; col - 1)
					printf("|");
			}
		printf("\n");
		}
		
	}
	
}

//玩家下棋
void  player_move(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	
	while (1)
	{
		printf("请按顺序输入将要下棋的位置的行数和列数：\n");//得给个提示，告诉玩家可以开始下棋了
		scanf("%d%d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			//没有棋子才可以下棋
			if (board[x - 1][y - 1] == ' ')
			{
				board[x - 1][y - 1] = '*';
				break;
			}
			else
			{
				printf("该坐标被占用，请重新输入\n");
			}
		}
		else
		{
			printf("坐标输入错误，请重新输入\n");
		}
	}
}

//电脑下棋
void  computer_move(char board[ROW][COL], int row, int col)
{	
	int x = 0;
	int y = 0;

	while (1)
	{
		 x = rand() % row;//row=3时x的结果范围: 0~2
		 y = rand() % col;

		 if ( x&gt;=0 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= col &amp;&amp; board[x][y] == ' ')
		 {
			 board[x][y] = '#';
			 break;
		 }

	}
}

//判断输赢 //这里思考下判断顺序，先判断谁是否赢了？没赢就看是否平局？没有平局才可以继续下棋

//判断棋盘是否满了，没赢就满是平局
static int if_full(char board[ROW][COL], int row, int col)
{
	//这个函数只为 is_win 服务，所以可以限制他的使用范围只在本文件中
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; row; i++)
	{		
		for (j = 0; j &lt; col; j++)
		{
			if (board[i][j] == ' ')
			{
				return 0;//没满
			}
		}
	}
	return 1;//满了
}

char is_win(char board[ROW][COL], int row, int col)
{
	int i = 0;
	//判断行
	for (i = 0; i &lt; row; i++)
	{
		if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != ' ')
		{
			return board[i][1];
		}
	}

	//判断列
	for (i = 0; i &lt; col; i++)
	{
		if (board[0][i] == board[1][i] &amp;&amp; board[1][i] == board[2][i] &amp;&amp; board[1][i] != ' ')
		{
			return board[1][i];
		}
	}

	//对角线
	if (board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2] &amp;&amp; board[1][1] != ' ')
	{
		return board[1][1];
	}
	if (board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0] &amp;&amp; board[1][1] != ' ')
	{
		return board[1][1];
	}

	//这里的return是按我们分析的判断顺序执行的，
	//如果上面输赢判断出来了那么该函数会直接跳出去的
	 
	//判断平局
	if (if_full(board, row, col) == 1)
	{
		return 'Q';
	}

	//继续
	return 'C';
}
</code></pre> 
<pre><code>// test.c

#define _CRT_SECURE_NO_WARNINGS 1
#include"game.h"

//测试三子棋游戏
void test()
{
	int a = 0;
	do
	{
		menu();
		scanf("%d", &amp;a);
		if (1 == a)
		{
			game();
			break;
		}
		else
		{
			printf("输入错误，请重新输入：\n");
		}
	} while (a);
	printf("退出游戏。\n");
}
void game()
{
	char ch = 0;
	//创建二维数组存放下棋数据
	char board[ROW][COL] = { 0 };
	//初始化棋盘
	chessboard(board, ROW, COL);
	//打印棋盘
	print_chessboard(board, ROW, COL);
	//随机数
	srand((unsigned int)time(NULL));
	
	while (1)
	{
		printf("  玩家下棋 \n");
		//玩家下棋（接着打印下棋结果）
		player_move(board, ROW, COL);
		print_chessboard(board, ROW, COL);

		//判断输赢		
		if ((ch = is_win(board, ROW, COL)) != 'C')
			break;

		//电脑下棋（接着打印下棋结果）
		printf("  电脑下棋 \n");
		Sleep(1000);//让玩家的有点感觉，不要太慌
		computer_move(board, ROW, COL);
		print_chessboard(board, ROW, COL);

		//判断输赢
		if ((ch = is_win(board, ROW, COL)) != 'C')
			break;
	}

	if ('*' == ch)
		printf("玩家赢。\n ");
	if ('#' == ch)
		printf("电脑赢。\n ");
	if ('Q' == ch)
		printf("平局。\n ");

}

int main()
{
	test();
	return 0;
}</code></pre> 
<h3>最终效果图&gt;&gt;&gt;</h3> 
<p style="text-align:center;"><img alt="" height="883" src="https://images2.imgbox.com/5d/f7/43F9VcKE_o.png" width="451"></p> 
<p style="text-align:center;"><img alt="" height="676" src="https://images2.imgbox.com/bb/67/yrM4p2G7_o.png" width="509"></p> 
<p></p> 
<h2> 写完的思考&gt;&gt;&gt;</h2> 
<p>       使用 C语言这个面向过程的程序设计语言，就是要把过程细化细化在细化。把相同的操作可以一起做，稍有差别的操作记得用 if 语句写判断是否执行的条件，不同的操作需要仔细的分开来写，慢慢、细致的写好每一步，因为<strong>每一步都很重要</strong>。 (如上文打印棋盘的那段代码)</p> 
<p>        在写之前需要好好想一想可以会出现的<strong>各种情况</strong>，如上文写道的很会手滑的小白玩家的离谱操作。这时候得注意着数组下标越界，输入的数据不在适用范围，输入错误等这些情况并细致写好。 还要注意代码的灵活性、可重用性等。（如上文玩家下棋的那段代码）</p> 
<p></p> 
<h2>最重要的话&gt;&gt;&gt;</h2> 
<p></p> 
<p>           不理解的记得私信我哦 ^ ^。</p> 
<p>        （直接评论区留言也可以^ ^）</p> 
<p>        </p> 
<p>       </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b01e4b4d724a4ab24f6e0126e24a023/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio patch使用 git patch使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/302a0704a341b6821069c530c1430c92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【python】conda配置python项目环境（Conda常用命令）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>