<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hive中orderBy，sortBy，distribute by，cluster by，group by - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hive中orderBy，sortBy，distribute by，cluster by，group by" />
<meta property="og:description" content="文章目录 1.总结2.order by3.sort by4.distribute by5.distribute by &#43; sort by6.Cluster by7.group by 和distribute by的区别 1.总结 order by：全局有序，但是会导致执行时间长或者任务集中。sort by：局部有序，对每个reduce进行排序distribute by：控制在map端如何拆分数据给reduce端的。划分map的数据流，使相同key传入一个reduce 一般来说distribute by 和sort by会放在一起使用，统计每个种类的topn
cluster by：distribute by &#43; sort by（前提是列相同） 但是使用cluster by会抛弃sort by的并行性，可以实现输出文件的全局有序性
group by：对检索结果的保留行进行单纯分组，一般总爱和聚合函数一块用 group by把相同key的数据聚集到一起，后续必须是聚合操作。而distribute by仅仅是对map的数据流进行划分控制。
2.order by 首先我们要明白Hive的本质是将HiveSQL转成MapReduce来执行分布式计算的，和普通单机程序不同的一个特点就是最终的数据会产生多个子文件，每个reducer节点都会处理partition给自己的那份数据产生结果文件，这导致了在Hadoop环境下很难对数据进行全局排序。
所以如果在Hadoop上进行order by全排序，会导致所有的数据集中在一台reducer节点上，然后进行排序，这样很可能会超过单个节点的磁盘和内存存储能力导致任务失败。
因此OrderBy会导致全局排序，使用order by会引发全局排序
select * from baidu_click order by click desc;
3.sort by sort by则指的是局部排序，它将会在每个reduce中进行局部排序。但是无法保证全局有序。
4.distribute by distribute by 的作用是保证相同的key的键值对会发送到一个Reduce中
一般来说distribute by 会和 sort by一起使用
5.distribute by &#43; sort by 使用distribute和sort进行分组排序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/acab22a92860f2ad23da6937efe367ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-22T10:14:10+08:00" />
<meta property="article:modified_time" content="2021-05-22T10:14:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hive中orderBy，sortBy，distribute by，cluster by，group by</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_2" rel="nofollow">1.总结</a></li><li><a href="#2order_by_16" rel="nofollow">2.order by</a></li><li><a href="#3sort_by_28" rel="nofollow">3.sort by</a></li><li><a href="#4distribute_by_32" rel="nofollow">4.distribute by</a></li><li><a href="#5distribute_by__sort_by_39" rel="nofollow">5.distribute by + sort by</a></li><li><a href="#6Cluster_by_56" rel="nofollow">6.Cluster by</a></li><li><a href="#7group_by_distribute_by_81" rel="nofollow">7.group by 和distribute by的区别</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_2"></a>1.总结</h2> 
<ol><li>order by：全局有序，但是会导致执行时间长或者任务集中。</li><li>sort by：局部有序，对每个reduce进行排序</li><li>distribute by：控制在map端如何拆分数据给reduce端的。划分map的数据流，使相同key传入一个reduce</li></ol> 
<blockquote> 
 <p>一般来说distribute by 和sort by会放在一起使用，统计每个种类的topn</p> 
</blockquote> 
<ol start="4"><li>cluster by：distribute by + sort by（前提是列相同）</li></ol> 
<blockquote> 
 <p>但是使用cluster by会抛弃sort by的并行性，可以实现输出文件的全局有序性</p> 
</blockquote> 
<ol start="5"><li>group by：对检索结果的保留行进行单纯分组，一般总爱和聚合函数一块用</li></ol> 
<blockquote> 
 <p>group by把相同key的数据聚集到一起，后续必须是聚合操作。而distribute by仅仅是对map的数据流进行划分控制。</p> 
</blockquote> 
<h2><a id="2order_by_16"></a>2.order by</h2> 
<p>首先我们要明白Hive的本质是将HiveSQL转成MapReduce来执行分布式计算的，和普通单机程序不同的一个特点就是最终的数据会产生多个子文件，每个reducer节点都会处理partition给自己的那份数据产生结果文件，这导致了在Hadoop环境下很难对数据进行全局排序。</p> 
<p>所以如果在Hadoop上进行order by全排序，会导致所有的数据集中在一台reducer节点上，然后进行排序，这样很可能会超过单个节点的磁盘和内存存储能力导致任务失败。</p> 
<p>因此OrderBy会导致全局排序，使用order by会引发全局排序</p> 
<blockquote> 
 <p>select * from baidu_click order by click desc;</p> 
</blockquote> 
<h2><a id="3sort_by_28"></a>3.sort by</h2> 
<p>sort by则指的是局部排序，它将会在每个reduce中进行局部排序。但是无法保证全局有序。<br> <img src="https://images2.imgbox.com/1c/b5/XoG96a79_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4distribute_by_32"></a>4.distribute by</h2> 
<p><img src="https://images2.imgbox.com/18/e8/qb7GZCBn_o.png" alt="在这里插入图片描述"><br> distribute by 的作用是保证相同的key的键值对会发送到一个Reduce中</p> 
<p>一般来说distribute by 会和 sort by一起使用</p> 
<h2><a id="5distribute_by__sort_by_39"></a>5.distribute by + sort by</h2> 
<p>使用distribute和sort进行分组排序</p> 
<blockquote> 
 <p>select * from baidu_click distribute by product_line sort by click desc;</p> 
</blockquote> 
<p>distribute by + sort by可以保证不重叠的局部有序，被distribute by设定的字段为KEY，数据会被HASH分发到不同的reducer机器上，然后sort by会对同一个reducer机器上的每组数据进行局部排序。</p> 
<p><img src="https://images2.imgbox.com/76/b7/h9Rj2DKk_o.png" alt="在这里插入图片描述"><br> distribute by + sort by的结果是按组有序而全局无序的，输入数据经过了以下两个步骤的处理：</p> 
<ol><li> <p>根据KEY字段被HASH，相同组的数据被分发到相同的reducer节点；</p> </li><li> <p>对每个组内部做排序</p> </li></ol> 
<h2><a id="6Cluster_by_56"></a>6.Cluster by</h2> 
<p>Cluster by其实就是distribute by + sort by的简写</p> 
<p><strong>那么这两者有什么区别？</strong></p> 
<p>因为distribute by 指定的列可能和sort by指定的列不同，数量也可能不同：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_orders distribute <span class="token keyword">by</span> name sort <span class="token keyword">by</span> money <span class="token keyword">desc</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/93/35/mDHzfLMi_o.png" alt="在这里插入图片描述"></p> 
<p>当distribute by 指定的列 和 sort by指定的列相同时，就可以直接使用Cluster by</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_orders cluster <span class="token keyword">by</span> money <span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/02/87/j8ITuRQ5_o.png" alt="在这里插入图片描述"></p> 
<p>因此，cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</p> 
<p>其次，如果使用了cluster by 或者distribute by + sort by（列相同），会剥夺sort by的并行行，这样的输出的文件同样是全局有序的。</p> 
<h2><a id="7group_by_distribute_by_81"></a>7.group by 和distribute by的区别</h2> 
<p>group by是对检索结果的保留行进行单纯分组，一般总爱和聚合函数一块用例如AVG（），COUNT（），max（），main（）等一块用。</p> 
<p>distribute by是控制在map端如何拆分数据给reduce端的。hive会根据distribute by后面列，对应reduce的个数进行分发，默认是采用hash算法。sort by为每个reduce产生一个排序文件。在有些情况下，你需要控制某个特定行应该到哪个reducer，这通常是为了进行后续的聚集操作。distribute by刚好可以做这件事。因此，distribute by经常和sort by配合使用。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68d581cb9e617b1a3cca38c61cc5037c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言结构体成员赋值失败,objective-c - C语言在使用中遇到了一个结构体赋值失败的问题？...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43eb10d0032a42122b792efa059b8681/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">强化学习八、策略梯度</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>