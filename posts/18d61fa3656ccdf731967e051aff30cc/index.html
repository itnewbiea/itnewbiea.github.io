<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ORACLE中RECORD、VARRAY、TABLE的使用具体解释 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ORACLE中RECORD、VARRAY、TABLE的使用具体解释" />
<meta property="og:description" content="转自文章：https://www.cnblogs.com/jzssuanfa/p/6749465.html 1 说明 1.1 RECORD
定义记录数据类型。
它类似于C语言中的结构数据类型(STRUCTURE)。PL/SQL提供了将几个相关的、分离的、基本数据类型的变量组成一个总体的方法，即RECORD复合数据类型。在使用记录数据类型变量时，须要在声明部分先定义记录的组成、记录的变量，然后在运行部分引用该记录变量本身或当中的成员。
定义记录数据类型的语法例如以下：
TYPE RECORD_NAME IS RECORD(
V1 DATA_TYPE1 [NOT NULL][:=DEFAULT_VALUE],
V2 DATA_TYPE2 [NOT NULL][:=DEFAULT_VALUE],
VN DATA_TYPEN [NOT NULL][:=DEFAULT_VALUE]);
1.2 VARRAY
数组是具有同样数据类型的一组成员的集合。每一个成员都有一个唯一的下标，它取决于成员在数组中的位置。在PL/SQL中，数组数据类型是VARRAY（variable array。就可以变数组）。
定义VARRAY数据类型的语法例如以下：
TYPE VARRAY_NAMEIS VARRAY(SIZE) OF ELEMENT_TYPE [NOT NULL];
当中，varray_name是VARRAY数据类型的名称。size是正整数。表示能够容纳的成员的最大数量，每一个成员的数据类型是element_typeo默认时。成员能够取空值，否则须要使用NOT NULL加以限制。
1.3 TABLE
定义记录表（或索引表）数据类型。它与记录类型相似，但它是对记录类型的扩展。它能够处理多行记录，类似于C语言中的二维数组，使得能够在PL/SQL中模仿数据库中的表。
定义记录表类型的语法例如以下：
TYPE TABLE NAME IS TABLE OF ELEMENT_TYPE [NOT NULL]
INDEX BY [BINARY_INTEGER|PLS_INTEGER|VARRAY2];
keywordINDEX BY表示创建一个主键索引，以便引用记录表变量中的特定行。
BINARY_INTEGER的说明
如语句：TYPE NUMBERS IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;其作用是,加了”INDEX BYBINARY_INTEGER ”后。NUMBERS类型的下标就是自增长，NUMBERS类型在插入元素时，不须要初始化，不须要每次EXTEND添加一个空间。
而假设没有这句话“INDEXBY BINARY_INTEGER”，那就得要显示对初始化，且每插入一个元素到NUMBERS类型的TABLE中时，都须要先EXTEND。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/18d61fa3656ccdf731967e051aff30cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-13T10:40:43+08:00" />
<meta property="article:modified_time" content="2019-12-13T10:40:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ORACLE中RECORD、VARRAY、TABLE的使用具体解释</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>转自文章：<a href="https://www.cnblogs.com/jzssuanfa/p/6749465.html" rel="nofollow">https://www.cnblogs.com/jzssuanfa/p/6749465.html</a></h4> 
<h4>1     说明</h4> 
<p>1.1       RECORD</p> 
<p>定义记录数据类型。</p> 
<p>它类似于C语言中的结构数据类型(STRUCTURE)。PL/SQL提供了将几个相关的、分离的、基本数据类型的变量组成一个总体的方法，即RECORD复合数据类型。在使用记录数据类型变量时，须要在声明部分先定义记录的组成、记录的变量，然后在运行部分引用该记录变量本身或当中的成员。</p> 
<p> </p> 
<p>    定义记录数据类型的语法例如以下：</p> 
<p>TYPE RECORD_NAME IS RECORD(</p> 
<p>V1  DATA_TYPE1 [NOT NULL][:=DEFAULT_VALUE],</p> 
<p>V2  DATA_TYPE2 [NOT NULL][:=DEFAULT_VALUE],</p> 
<p>VN  DATA_TYPEN [NOT NULL][:=DEFAULT_VALUE]);</p> 
<p>1.2       VARRAY</p> 
<p>数组是具有同样数据类型的一组成员的集合。每一个成员都有一个唯一的下标，它取决于成员在数组中的位置。在PL/SQL中，数组数据类型是VARRAY（variable array。就可以变数组）。</p> 
<p>定义VARRAY数据类型的语法例如以下：</p> 
<p>TYPE VARRAY_NAMEIS VARRAY(SIZE) OF ELEMENT_TYPE [NOT NULL];</p> 
<p>当中，varray_name是VARRAY数据类型的名称。size是正整数。表示能够容纳的成员的最大数量，每一个成员的数据类型是element_typeo默认时。成员能够取空值，否则须要使用NOT NULL加以限制。</p> 
<p> </p> 
<p>1.3       TABLE</p> 
<p>定义记录表（或索引表）数据类型。它与记录类型相似，但它是对记录类型的扩展。它能够处理多行记录，类似于C语言中的二维数组，使得能够在PL/SQL中模仿数据库中的表。</p> 
<p>定义记录表类型的语法例如以下：</p> 
<p>TYPE TABLE NAME IS TABLE OF ELEMENT_TYPE [NOT NULL]</p> 
<p>INDEX BY [BINARY_INTEGER|PLS_INTEGER|VARRAY2];</p> 
<p>keywordINDEX BY表示创建一个主键索引，以便引用记录表变量中的特定行。</p> 
<p>BINARY_INTEGER的说明</p> 
<p>如语句：TYPE NUMBERS  IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;其作用是,加了”INDEX BYBINARY_INTEGER ”后。NUMBERS类型的下标就是自增长，NUMBERS类型在插入元素时，不须要初始化，不须要每次EXTEND添加一个空间。</p> 
<p>而假设没有这句话“INDEXBY BINARY_INTEGER”，那就得要显示对初始化，且每插入一个元素到NUMBERS类型的TABLE中时，都须要先EXTEND。</p> 
<p> </p> 
<p> </p> 
<h4>2     举例</h4> 
<p>2.1       创建表结构以及数据准备</p> 
<p> </p> 
<pre>--组织机构结构表
CREATE TABLE SF_ORG
(
ORG_ID INT NOT NULL, --组织机构主键ID
ORG_NAME VARCHAR2(50),--组织机构名称
PARENT_ID INT--组织机构的父级
)

--一级组织机构
INSERT INTO SF_ORG(ORG_ID, ORG_NAME, PARENT_ID) VALUES(1, '一级部门1',0);

--二级部门

INSERT INTO SF_ORG(ORG_ID, ORG_NAME, PARENT_ID) VALUES(2, '二级部门2',1);
INSERT INTO SF_ORG(ORG_ID, ORG_NAME, PARENT_ID) VALUES(3, '二级部门3',1);
INSERT INTO SF_ORG(ORG_ID, ORG_NAME, PARENT_ID) VALUES(4, '二级部门4',1);
</pre> 
<p> </p> 
<p> </p> 
<p>2.2       RECORD的使用举例</p> 
<p>先定义一个仅仅与SF_ORG表中某几个列的数据类型同样的记录数据类型TYPE_ORG_RECORD，然后声明一个该数据类型的记录变量V_ORG_RECORD，最后用替换变量&amp;ORG_ID接受输入的雇员编码，查询并显示该雇员的这几列中的信息。</p> 
<p>注意，在使用RECORD数据类型的变量时要用“.”运算符指定记录变量名限定词。</p> 
<p>    一个记录类型的变量仅仅能保存从数据库中查询出的一行记录，假设查询出了多行记录。就会出现错误。</p> 
<p> </p> 
<pre>DECLARE 
  TYPE TYPE_ORG_RECORD IS RECORD(
  V_ORG_NAME SF_ORG.ORG_NAME%TYPE,
  V_PARENT_ID SF_ORG.PARENT_ID%TYPE);
  V_ORG_RECORD TYPE_ORG_RECORD;
BEGIN
  SELECT ORG_NAME,PARENT_ID INTO V_ORG_RECORD
  FROM SF_ORG SO
  WHERE SO.ORG_ID=&amp;ORG_ID;
  DBMS_OUTPUT.PUT_LINE('部门名称：' || V_ORG_RECORD.V_ORG_NAME);
  DBMS_OUTPUT.PUT_LINE('上级部门编码：' || TO_CHAR(V_ORG_RECORD.V_PARENT_ID));
END;
</pre> 
<p> </p> 
<p> </p> 
<p>2.3       VARRAY的使用举例</p> 
<p>先定义一个能保存5个VARCHAR2(25)数据类型的成员的VARRAY数据类型ORG_VARRAY_TYPE，然后声明一个该数据类型的VARRAY变量V_ORG_VARRAY，最后用与ORG_VARRAY_TYPE数据类型同名的构造函数语法给V_ORG_VARRAY变量赋予初值并显示赋值结果。</p> 
<p> </p> 
<p>注意。在引用数组中的成员时．须要在一对括号里使用顺序下标，下标从1開始而不是从0開始。</p> 
<p> </p> 
<pre>DECLARE 
  TYPE ORG_VARRAY_TYPE IS VARRAY(5) OF VARCHAR2(25);
  V_ORG_VARRAY ORG_VARRAY_TYPE;
BEGIN
  V_ORG_VARRAY := ORG_VARRAY_TYPE('1','2','3','4','5');
  DBMS_OUTPUT.PUT_LINE('输出1：' || V_ORG_VARRAY(1) || '、'|| V_ORG_VARRAY(2) || '、'|| V_ORG_VARRAY(3) || '、'|| V_ORG_VARRAY(4));
  DBMS_OUTPUT.PUT_LINE('输出2：' || V_ORG_VARRAY(5));
  V_ORG_VARRAY(5) := '5001';
  DBMS_OUTPUT.PUT_LINE('输出3：' || V_ORG_VARRAY(5));
END;
</pre> 
<p> </p> 
<p> </p> 
<p>2.4       TABLE使用举例</p> 
<p>2.4.1      存储单列多行</p> 
<p>这个和VARRAY类似。可是赋值方式略微有点不同，不能使用同名的构造函数进行赋值。详细的例如以下：</p> 
<p> </p> 
<pre>DECLARE 
  TYPE ORG_TABLE_TYPE IS TABLE OF VARCHAR2(25)
  INDEX BY BINARY_INTEGER;
  V_ORG_TABLE ORG_TABLE_TYPE;
BEGIN
  V_ORG_TABLE(1) := '1';
  V_ORG_TABLE(2) := '2';
  V_ORG_TABLE(3) := '3';
  V_ORG_TABLE(4) := '4';
  V_ORG_TABLE(5) := '5';
  DBMS_OUTPUT.PUT_LINE('输出1：' || V_ORG_TABLE(1) || '、'|| V_ORG_TABLE(2) || '、'|| V_ORG_TABLE(3) || '、'|| V_ORG_TABLE(4));
  DBMS_OUTPUT.PUT_LINE('输出2：' || V_ORG_TABLE(5));
END;
</pre> 
<p> </p> 
<p> </p> 
<p>2.4.2      存储多列多行和ROWTYPE结合使用</p> 
<p>採用bulkcollect能够将查询结果一次性地载入到collections中。而不是通过cursor一条一条地处理。</p> 
<p> </p> 
<pre>DECLARE 
   TYPE T_TYPE IS TABLE OF SF_ORG%ROWTYPE;
   V_TYPE  T_TYPE;
 BEGIN
    SELECT ORG_ID,ORG_NAME,PARENT_ID BULK COLLECT INTO V_TYPE
    FROM SF_ORG
    WHERE SF_ORG.ORG_ID &lt;= 3;

    FOR V_INDEX IN V_TYPE.FIRST .. V_TYPE.LAST LOOP
        DBMS_OUTPUT.PUT_LINE(V_TYPE(V_INDEX).C1 || ' ' || V_TYPE(V_INDEX).C2);
    END LOOP;
 END;
</pre> 
<p> </p> 
<p> </p> 
<p>2.4.3      存储多列多行和RECORD结合使用</p> 
<p>採用bulkcollect能够将查询结果一次性地载入到collections中。</p> 
<p>而不是通过cursor一条一条地处理。</p> 
<p> </p> 
<pre>DECLARE 
   TYPE TEST_EMP IS RECORD
   (
    C1 SF_ORG.ORG_NAME%TYPE,
    C2 SF_ORG.PARENT_ID%TYPE
   );   
   TYPE T_TYPE IS TABLE OF TEST_EMP;
   V_TYPE  T_TYPE;
 BEGIN
    SELECT ORG_NAME,  PARENT_ID BULK COLLECT INTO V_TYPE
    FROM SF_ORG
    WHERE SF_ORG.ORG_ID &lt;= 3;

    FOR V_INDEX IN V_TYPE.FIRST .. V_TYPE.LAST LOOP
        DBMS_OUTPUT.PUT_LINE(V_TYPE(V_INDEX).C1 || ' ' || V_TYPE(V_INDEX).C2);
    END LOOP;
 END;</pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8261798c5bd125734b102147ac68c395/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">90后程序员程广坤教你零基础自学编程，用这6种方法就够了！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba29d4b6742f551f2facaf738fbed8fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">.NET Reactor 使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>