<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《Java 基础篇》之终止线程的几种方式 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《Java 基础篇》之终止线程的几种方式" />
<meta property="og:description" content="目录
一、正常运行结束
二、使用退出标志退出线程
三、interrupt[ɪntəˈrʌpt]方法结束线程
四、stop()方法终止线程（不安全）
五、线程相关
5.1 sleep()和wait()区别
5.2 start()和run()的区别
5.3 Java后台线程(守护线程
一、正常运行结束 所谓正常运行结束，就是程序正常运行结束，线程自动结束
public class ThreadTest extends Thread { public void run() { //do something } } 二、使用退出标志退出线程 一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。他们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志位true或false来控制while循环是否退出，下面放代码：
public class ThreadTest extends Thread { public volatile boolean exit = false; public void run() { while (!exit){ //do something } } } 三、interrupt[ɪntəˈrʌpt]方法结束线程 使用interrupt()方法来中断线程是分两种情况的：
线程处于阻塞状态：如使用了sleep()，同步锁的wait()，socket中的receiver()，accept()等方法时，会使线程处于阻塞状态。当调用线程interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出此异常，通过代码可以捕获此异常，然后跳出循环状态，从而让我们有机会结束这个线程的执行。并不是只要调用interrupt()方法，线程就会结束，实际上是不正确的，一定要先捕获InterruptException异常之后通过break来跳出循环，才能正常结束run()方法。线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会为true，和使用自定义的标志来控制循环是一样的道理 public class ThreadTest extends Thread { public void run() { while(!isInterrupted()) { try { Thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/27bbdf9ac020c6186d26a2c5220c1d59/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T19:00:18+08:00" />
<meta property="article:modified_time" content="2023-06-11T19:00:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《Java 基础篇》之终止线程的几种方式</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9D%9F" rel="nofollow">一、正常运行结束</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E9%80%80%E5%87%BA%E6%A0%87%E5%BF%97%E9%80%80%E5%87%BA%E7%BA%BF%E7%A8%8B" rel="nofollow">二、使用退出标志退出线程</a></p> 
<p style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81interrupt%5B%C9%AAnt%C9%99%CB%88r%CA%8Cpt%5D%E6%96%B9%E6%B3%95%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B" rel="nofollow">三、interrupt[ɪntəˈrʌpt]方法结束线程</a></p> 
<p style="margin-left:40px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81stop%28%29%E6%96%B9%E6%B3%95%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89" rel="nofollow"> 四、stop()方法终止线程（不安全）</a></p> 
<p style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3" rel="nofollow">五、线程相关</a></p> 
<p style="margin-left:80px;"><a href="#%C2%A05.1%20sleep%28%29%E5%92%8Cwait%28%29%E5%8C%BA%E5%88%AB" rel="nofollow"> 5.1 sleep()和wait()区别</a></p> 
<p style="margin-left:80px;"><a href="#5.2%20start%28%29%E5%92%8Crun%28%29%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">5.2 start()和run()的区别</a></p> 
<p style="margin-left:80px;"><a href="#5.3%20Java%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%28%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%29" rel="nofollow">5.3 Java后台线程(守护线程</a></p> 
<h3><code>一、正常运行结束</code></h3> 
<p>所谓正常运行结束，就是程序正常运行结束，线程自动结束</p> 
<pre><code>public class ThreadTest extends Thread {  
	public void run() {  
		//do something  
	} 
} 
</code></pre> 
<h3><code>二、使用退出标志退出线程</code></h3> 
<p><code>一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。他们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志位true或false来控制while循环是否退出，下面放代码：</code></p> 
<pre><code>public class ThreadTest extends Thread {  
	public volatile boolean exit = false;  
	public void run() {  
		while (!exit){  
			//do something  
		}  
	} 
} 
</code></pre> 
<h3><code>三、interrupt[</code>ɪntəˈrʌpt<code>]方法结束线程</code></h3> 
<blockquote> 
 <p> </p> 
 <p><code>使用interrupt()方法来中断线程是分两种情况的：</code></p> 
 <ul><li><code>线程处于阻塞状态：如使用了sleep()，同步锁的wait()，socket中的receiver()，accept()等方法时，会使线程处于阻塞状态。当调用线程interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出此异常，通过代码可以捕获此异常，然后跳出循环状态，从而让我们有机会结束这个线程的执行。并不是只要调用interrupt()方法，线程就会结束，实际上是不正确的，一定要先捕获InterruptException异常之后通过break来跳出循环，才能正常结束run()方法。</code></li><li><code>线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会为true，和使用自定义的标志来控制循环是一样的道理</code></li></ul> 
</blockquote> 
<pre><code>public class ThreadTest extends Thread {
	public void run() {
		while(!isInterrupted()) {
			try {
				Thread.sleep(5*1000);
			} catch(InterruptedException e) {
				e.printStackTrace();
                //捕获到异常之后，执行break跳出循环
				break;
			}
		}
	}
}
</code></pre> 
<h3> <code>四、stop()方法终止线程（不安全）</code></h3> 
<blockquote> 
 <p> </p> 
 <p><code>我们可以直接使用thread.stop()来强行终止线程，但是stop()方法是很危险的，就想突然关闭电源一样。这样子可能机会产生不可预料的结果，不安全主要是：</code></p> 
 <ul><li><code>thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有的锁突然释放，那么被保护的数据就可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop()方法来终止线程</code></li></ul> 
</blockquote> 
<h3><code>五、线程相关</code></h3> 
<p><code>线程池原理详解深入浅出学习文档</code></p> 
<p><a href="https://blog.csdn.net/huangtenglong/article/details/127746453?spm=1001.2014.3001.5502" title="多线程和线程池工作原理解析深入浅出_new thread和线程池_九块六的博客-CSDN博客">多线程和线程池工作原理解析深入浅出_new thread和线程池_九块六的博客-CSDN博客</a></p> 
<h4> <code>5.1 sleep()和wait()区别</code></h4> 
<blockquote> 
 <ul><li><code>对于sleep()方法，我们首先要知道该方法是属于Thread类中的，而wait()方法，则是属于Object类中的。</code></li><li><code>sleep()方法导致了程序暂停执行指定的时间，让出CPU给其他线程，但是它依然处于监控状态，当指定时间到了又会自动恢复运行状态。</code></li><li><code>调用sleep()方法的过程中，线程不会释放对象锁。</code></li><li><code>调用wait()方法的时候，线程会释放对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态</code></li></ul> 
</blockquote> 
<h4><code>5.2 start()和run()的区别</code></h4> 
<blockquote> 
 <ul><li> <p><code>start()方法来启动线程，真正实现了多线程运行。这时无需等待run()方法体代码执行完毕，可以继续执行下面的代码。</code></p> </li><li> <p><code>通过调用Thread类的start（）方法来启动一个线程，此时线程是处于就绪状态，并没有运行。</code></p> </li><li> <p><code>方法run()称为线程体，它包含了要执行的这个线程的内容，次线程终止。然后CPU在调度其他线程</code></p> </li></ul> 
</blockquote> 
<h4><code>5.3 Java后台线程(守护线程)</code></h4> 
<blockquote> 
 <ul><li> <p><code>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。</code></p> </li><li> <p><code>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</code></p> </li><li> <p><code>设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的setDaemon方法。</code></p> </li><li> <p><code>在Daemon线程中产生的新线程也是Daemon的。</code></p> </li><li> <p><code>守护线程则是JVM级别的，以Tomcat 为例，如果你在Web 应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。也就是说，即使你停止了Web应用，这个线程依旧是活跃的。</code></p> </li><li> <p><code>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</code></p> </li><li> <p><code>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出</code></p> </li></ul> 
</blockquote> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b8e13ff4feeeee29ae4535127f857e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL错误代码：1045</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d802b7df691bcea21b2e1df348e1da4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习应用篇-计算机视觉-OCR光学字符识别[7]：OCR综述、常用CRNN识别方法、DBNet、CTPN检测方法等、评估指标、应用场景</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>