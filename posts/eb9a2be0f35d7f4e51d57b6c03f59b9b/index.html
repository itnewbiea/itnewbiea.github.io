<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Unity]透明材质 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[Unity]透明材质" />
<meta property="og:description" content="学习目标： Unity Shader的渲染渲染顺序中的透明材质
学习内容： 1、透明度测试
2、透明度混合
3、渲染队列
4、透明模型
缘由：一般渲染的话会根据深度缓冲来确定渲染顺序的，但是由于透明材质需要关闭深度写入，因为透明材质会混合队列中其他材质的颜色，不能用普通材质的方法来渲染，1和2分别讲两种实现透明的方式
1、透明度测试 比较极端的测试，如果片元的透明度不满足某个阈值，那么会被直接舍弃，否则会跟不透明片元一样进行深度测试、深度写入等，不考虑关闭深度写入的问题，结果只会是完全透明或者不透明
2、透明度混合 该方法可得到真正的半透明效果，核心理念是与将自身的透明度与已经存在颜色缓冲中的颜色进行混合，该方法要点是要记住如果是以 透明-&gt;不透明 物体的顺序进行渲染，那就先渲染不透明物体，再将颜色缓冲中的颜色与透明片元进行混合，如果反过来，是不透明-&gt;透明的话那么就不会渲染透明片元，所以渲染队列十分重要。
3、渲染队列 渲染队列可以理解为多个火车车厢，分别为多个组，会根据队列索引号来渲染，每个队列都有特定功能 我们上面讲过因为不能使用深度环存因此，渲染顺序十分重要，就有了渲染队列
4、透明模型 本项目为书籍自带的模型，实际效果如下
透明的部分为贴图特定的颜色分布，上面展示的是使用透明度测试的方法制作的，显示出来的两种极端要么完全消失，要么可见。
代码如下
// Upgrade NOTE: replaced &#39;_Object2World&#39; with &#39;unity_ObjectToWorld&#39; // Upgrade NOTE: replaced &#39;mul(UNITY_MATRIX_MVP,*)&#39; with &#39;UnityObjectToClipPos(*)&#39; Shader &#34;Unity Shaders Book/Chapter 8/Alpha Test&#34; { Properties { _Color (&#34;Color Tint&#34;, Color) = (1, 1, 1, 1) _MainTex (&#34;Main Tex&#34;, 2D) = &#34;white&#34; {} _Cutoff (&#34;Alpha Cutoff&#34;, Range(0, 1)) = 0.5 } SubShader { Tags {&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/eb9a2be0f35d7f4e51d57b6c03f59b9b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-16T18:03:06+08:00" />
<meta property="article:modified_time" content="2022-12-16T18:03:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Unity]透明材质</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a>学习目标：</h2> 
<p>Unity Shader的渲染渲染顺序中的透明材质</p> 
<hr> 
<h2><a id="_10"></a>学习内容：</h2> 
<p>1、透明度测试</p> 
<p>2、透明度混合</p> 
<p>3、渲染队列</p> 
<p>4、透明模型</p> 
<hr> 
<p>缘由：一般渲染的话会根据深度缓冲来确定渲染顺序的，但是由于透明材质<span style="color:#fe2c24;"><strong>需要关闭深度写入</strong></span>，因为透明材质会混合队列中其他材质的颜色，不能用普通材质的方法来渲染，1和2分别讲两种实现透明的方式</p> 
<h3>1、透明度测试</h3> 
<p>        比较极端的测试，如果片元的透明度不满足某个阈值，那么会被直接舍弃，否则会跟不透明片元一样进行深度测试、深度写入等，不考虑关闭深度写入的问题，结果只会是完全透明或者不透明</p> 
<h3>2、透明度混合</h3> 
<p>        该方法可得到真正的半透明效果，核心理念是与将自身的透明度<strong><span style="color:#fe2c24;">与已经存在颜色缓冲中的颜色进行混合</span></strong><span style="color:#0d0016;">，该方法要点是要记住如果是以  透明-&gt;不透明  物体的顺序进行渲染，那就先渲染不透明物体，再将颜色缓冲中的颜色与透明片元进行混合，如果反过来，是不透明-&gt;透明的话那么就不会渲染透明片元，所以渲染队列十分重要。</span></p> 
<h3>3、渲染队列</h3> 
<p>        渲染队列可以理解为多个火车车厢，分别为多个组，会根据队列索引号来渲染，每个队列都有特定功能 </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/52/ce/FDgGCW9o_o.jpg" width="1200"></p> 
<p>我们上面讲过因为不能使用深度环存因此，渲染顺序十分重要，就有了渲染队列</p> 
<h3>4、透明模型</h3> 
<p>        本项目为书籍自带的模型，实际效果如下</p> 
<p><img alt="" height="809" src="https://images2.imgbox.com/3c/09/Z4ivtifm_o.png" width="1200"></p> 
<p>        透明的部分为贴图特定的颜色分布，上面展示的是使用透明度测试的方法制作的，显示出来的两种极端要么完全消失，要么可见。</p> 
<p>        代码如下</p> 
<pre><code class="hljs">// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'
// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Unity Shaders Book/Chapter 8/Alpha Test" {
	Properties {
		_Color ("Color Tint", Color) = (1, 1, 1, 1)
		_MainTex ("Main Tex", 2D) = "white" {}
		_Cutoff ("Alpha Cutoff", Range(0, 1)) = 0.5
	}
	SubShader {
		Tags {"Queue"="AlphaTest" "IgnoreProjector"="True" "RenderType"="TransparentCutout"}//渲染队列名为AlphaTest，忽略投影器影响，规划到TransparentCutout这个组
		
		Pass {
			Tags { "LightMode"="ForwardBase" }//渲染模式是用前向渲染-&gt;还有一种叫延迟渲染
			
			CGPROGRAM
			
			#pragma vertex vert//顶点着色器
			#pragma fragment frag//片元着色器
			
			#include "Lighting.cginc"//添加内置变量
			
			fixed4 _Color;
			sampler2D _MainTex;
			float4 _MainTex_ST;
			fixed _Cutoff;
			
			struct a2v {//顶点着色器输入结构
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 texcoord : TEXCOORD0;
			};
			
			struct v2f {//顶点着色器输出结构
				float4 pos : SV_POSITION;
				float3 worldNormal : TEXCOORD0;
				float3 worldPos : TEXCOORD1;
				float2 uv : TEXCOORD2;
			};
			
			v2f vert(a2v v) {//顶点着色器
				v2f o;//顺序分别为切线空间、世界空间、世界坐标、纹理坐标进行变换最后返回
				o.pos = UnityObjectToClipPos(v.vertex);
				
				o.worldNormal = UnityObjectToWorldNormal(v.normal);
				
				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
				
				o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
				
				return o;
			}
			
			fixed4 frag(v2f i) : SV_Target {
				fixed3 worldNormal = normalize(i.worldNormal);
				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
				
				fixed4 texColor = tex2D(_MainTex, i.uv);//获取贴图坐标
				
				// Alpha test
				clip (texColor.a - _Cutoff);//如果不为负数则采用该片元，意义在于texColor为目标材质，Cutoff为材质参数，如果低于则表明为为透明材质
				// Equal to 
//				if ((texColor.a - _Cutoff) &lt; 0.0) {
//					discard;//意义跟clip一样剔除掉该片元
//				}
				//计算环境光和漫反射将其计算后输出
				fixed3 albedo = texColor.rgb * _Color.rgb;
				
				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
				
				fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));
				
				return fixed4(ambient + diffuse, 1.0);
			}
			
			ENDCG
		}
	} 
	FallBack "Transparent/Cutout/VertexLit"
}
</code></pre> 
<p> 另一种方法透明度混合，核心理念是要与颜色缓冲中的颜色混合得出透明片元的颜色，结果如下，透明则选择了整个材质</p> 
<p><img alt="" height="579" src="https://images2.imgbox.com/5d/51/zOjMjTqQ_o.png" width="1200"></p> 
<p>代码如下</p> 
<pre><code class="hljs">// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'
// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Unity Shaders Book/Chapter 8/Alpha Blend" {
	Properties {
		_Color ("Color Tint", Color) = (1, 1, 1, 1)
		_MainTex ("Main Tex", 2D) = "white" {}
		_AlphaScale ("Alpha Scale", Range(0, 1)) = 1
	}
	SubShader {
		Tags {"Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent"}
		
		Pass {
			Tags { "LightMode"="ForwardBase" }

			ZWrite Off
			Blend SrcAlpha OneMinusSrcAlpha
			
			CGPROGRAM
			
			#pragma vertex vert
			#pragma fragment frag
			
			#include "Lighting.cginc"
			
			fixed4 _Color;
			sampler2D _MainTex;
			float4 _MainTex_ST;
			fixed _AlphaScale;
			
			struct a2v {
				float4 vertex : POSITION;
				float3 normal : NORMAL;
				float4 texcoord : TEXCOORD0;
			};
			
			struct v2f {
				float4 pos : SV_POSITION;
				float3 worldNormal : TEXCOORD0;
				float3 worldPos : TEXCOORD1;
				float2 uv : TEXCOORD2;
			};
			
			v2f vert(a2v v) {
				v2f o;
				o.pos = UnityObjectToClipPos(v.vertex);
				
				o.worldNormal = UnityObjectToWorldNormal(v.normal);
				
				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
				
				o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
				
				return o;
			}
			
			fixed4 frag(v2f i) : SV_Target {
				fixed3 worldNormal = normalize(i.worldNormal);
				fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
				
				fixed4 texColor = tex2D(_MainTex, i.uv);
				
				fixed3 albedo = texColor.rgb * _Color.rgb;
				
				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
				
				fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));
				
				return fixed4(ambient + diffuse, texColor.a * _AlphaScale);
			}
			
			ENDCG
		}
	} 
	FallBack "Transparent/VertexLit"
}
</code></pre> 
<p> </p> 
<h2><a id="_22"></a></h2> 
<hr> 
<h2><a id="_34"></a>总结：</h2> 
<p>        想要实现透明有两种方法，分别为透明度测试和透明度混合、核心表达出来的是1、如果不是透明就不显示 2、先渲染后面不透明物体再将颜色缓冲区中的数据混合得出透明物体的颜色，总体两者都需要注意渲染顺序</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd287a9abdce5280915ea19962d63f01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大数据技术Hadoop&#43;Spark】Hive数据仓库架构、优缺点、数据模型介绍（图文解释 超详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67ebd576b3de866d6bdf8d52eec2f3ca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于大数据spark&#43;hadoop的图书可视化分析系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>