<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>qsort — c语言中自带的排序函数(附带void*、回调函数知识点 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="qsort — c语言中自带的排序函数(附带void*、回调函数知识点" />
<meta property="og:description" content="因为总是忘记有qsort这个函数，导致遇到需要排序的题的时候，总是要写着类似的代码，所以特此单独把qsort拿出来单独整理一遍，让自己能够熟练掌握，也以免之后忘记了qsort可以拿自己的文章看。
目录
一、论冒泡排序和qsort
1、qsort 是什么？
2、qsort在程序中使用
1.关于cmp函数的一些规定 2、介绍一个指针类型 void*类型
3、模拟qsort
二、回调函数
三、在最后
一、论冒泡排序和qsort 冒泡排序的核心思想：相邻元素两两比较
写一个冒泡排序函数：
#include&lt;stdio.h&gt; void bubble_sort(int arr[], int sz);//函数声明 int main() { //先创建一个数组 int arr[] = { 4,8,9,3,5,2,1,7 }; //通过sizeof求元素个数 int sz = sizeof(arr) / sizeof(arr[0]); //把数组排成升序 bubble_sort(arr, sz); //打印数组内容 int i = 0; for (i = 0; i &lt; sz; i&#43;&#43;) { printf(&#34;%d &#34;, arr[i]); } return 0; } //这个函数只能排整型数组 void bubble_sort(int arr[], int sz) { int i = 0; while (sz) { int flag = 0; for (i = 0; i &lt; sz - 1; i&#43;&#43;) { if (arr[i] &gt; arr[i &#43; 1])//元素两两比较 { int tmp = arr[i]; arr[i] = arr[i &#43; 1]; arr[i &#43; 1] = tmp; flag = 1; } } sz--; if (flag == 0) { break;//如果数组内容一开始就是按规则有序排列的，可以进行判断优化 } } } 请注意：这样的冒泡排序有一个弊端只能排序整型数据，因为在最开始函数定义的时候已经把参数写死了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/896d7f0315df434c23e46d2bb77c5e83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-19T22:08:02+08:00" />
<meta property="article:modified_time" content="2022-07-19T22:08:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">qsort — c语言中自带的排序函数(附带void*、回调函数知识点</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#494949;">       因为总是忘记有qsort这个函数，导致遇到需要排序的题的时候，总是要写着类似的代码，所以特此单独把qsort拿出来单独整理一遍，让自己能够熟练掌握，也以免之后忘记了qsort可以拿自己的文章看。</span></p> 
</blockquote> 
<p></p> 
<p id="main-toc"><span style="color:#494949;"><strong>目录</strong></span></p> 
<p id="%E4%B8%80%E3%80%81%E8%AE%BA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8Cqsort-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%AE%BA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8Cqsort" rel="nofollow"><span style="color:#494949;">一、论冒泡排序和qsort</span></a></p> 
<p id="%E4%B8%80%E3%80%81qsort%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81qsort%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow"><span style="color:#494949;">1、qsort 是什么？</span></a></p> 
<p id="2%E3%80%81qsort%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2%E3%80%81qsort%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8" rel="nofollow"><span style="color:#494949;">2、qsort在程序中使用</span></a></p> 
<p id="1.%E5%85%B3%E4%BA%8Ecmp%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%AE%9A%C2%A0-toc" style="margin-left:80px;"><a href="#1.%E5%85%B3%E4%BA%8Ecmp%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%AE%9A%C2%A0" rel="nofollow"><span style="color:#494949;">1.关于cmp函数的一些规定 </span></a></p> 
<p id="'%20%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%20void*%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#'%20rel="><span style="color:#494949;">2、介绍一个指针类型 void*类型</span></a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F-toc" style="margin-left:0px;"><span style="color:#494949;">         </span><a href="#3%E3%80%81%E6%A8%A1%E6%8B%9Fqsort" rel="nofollow"><span style="color:#494949;">3、模拟qsort</span></a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" rel="nofollow"><span style="color:#494949;">二、回调函数</span></a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow"><span style="color:#494949;">三、在最后</span></a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E8%AE%BA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8Cqsort"><span style="color:#494949;">一、论冒泡排序和qsort</span></h2> 
<p></p> 
<p><span style="color:#494949;"><strong>       冒泡排序的核心思想：</strong>相邻元素两两比较</span></p> 
<p><span style="color:#494949;">　　写一个冒泡排序函数：</span></p> 
<pre><code class="language-cpp">
#include&lt;stdio.h&gt;

void bubble_sort(int arr[], int sz);//函数声明

int  main()
{
	//先创建一个数组
	int arr[] = { 4,8,9,3,5,2,1,7 };

	//通过sizeof求元素个数
	int sz = sizeof(arr) / sizeof(arr[0]);

	//把数组排成升序
	bubble_sort(arr, sz);

	//打印数组内容
	int i = 0;
	for (i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}

//这个函数只能排整型数组
void bubble_sort(int arr[], int sz)
{
	int i = 0;

	while (sz)
	{
		int flag = 0;
		for (i = 0; i &lt; sz - 1; i++)
		{
			if (arr[i] &gt; arr[i + 1])//元素两两比较
			{
				int tmp = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = tmp;
				flag = 1;
			}
		}
		sz--;
		if (flag == 0)
		{
			break;//如果数组内容一开始就是按规则有序排列的，可以进行判断优化
		}
	}
}</code></pre> 
<p><span style="color:#494949;">       请注意：这样的冒泡排序有一个<strong>弊端</strong>只能排序整型数据，因为在最开始函数定义的时候已经把参数写死了。</span></p> 
<p><span style="color:#494949;">       下面开始介绍一个库函数<strong>qsort</strong></span></p> 
<hr> 
<h2><a id="_45"></a></h2> 
<h4></h4> 
<h3 id="%E4%B8%80%E3%80%81qsort%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span style="color:#494949;">1、qsort 是什么？</span></h3> 
<p></p> 
<p><span style="color:#494949;">　　qsort是一个使用<strong>快速排序的思想</strong>实现的一个<strong>排序函数。</strong></span></p> 
<p><span style="color:#494949;">　　并且qsort 可以<strong>排序任意类型的数据。</strong></span></p> 
<p><span style="color:#494949;">下面是关于qsort函数参数的介绍：</span></p> 
<pre><code class="language-cpp">
void qsort(void* base, size_t num, size_t size,
	int (*cmp)(const void* e1, const void* e2));
//
//void* base 你要排序的数据的起始位置
//size_t num 待排序的数据元素的个数
//size_t size 待排序的数据元素的大小(单位是字节)
//int (*cmp)(const void* e1, const void* e2)) 
   //函数指针-比较函数 cmp就是一个比较函数的地址,也就是这个比较函数的函数指针
   //e1指向了你要比较的第一个元素  e2指向了你要比较的第二个元素
   //e1 e2 是你要比较的两个元素的地址

</code></pre> 
<p id=""><a id="_19"></a></p> 
<hr> 
<h4></h4> 
<p></p> 
<h3 id="2%E3%80%81qsort%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8"><span style="color:#494949;">2、qsort在程序中使用</span></h3> 
<p><span style="color:#494949;">　　 写一个程序使用一下：</span></p> 
<pre><code class="language-cpp">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int cmp_int(const void* e1, const void* e2);

int  main()
{
	//先创建一个数组
	int arr[] = { 4,8,9,3,5,2,1,7 };

	//通过sizeof求元素个数
	int sz = sizeof(arr) / sizeof(arr[0]);

	qsort(arr, sz, sizeof(arr[0]), cmp_int);

	//打印数组内容
	int i = 0;
	for (i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}

//比较两个整型元素
//这样排序默认是升序排列
//
int cmp_int (const void*e1,const void*e2)
{	
	return (* (int*)e1 - *(int*)e2);//所以比较的时候要强制类型转换一下
}</code></pre> 
<p></p> 
<hr> 
<h4></h4> 
<p></p> 
<h4 id="1.%E5%85%B3%E4%BA%8Ecmp%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%AE%9A%C2%A0"><span style="color:#494949;">1.关于cmp函数的一些规定 </span></h4> 
<p></p> 
<p><span style="color:#494949;">       注意其对于函数参数所传递的<strong>void*指针的解应用</strong>需要进行<strong>强制类型转换,</strong>比较什么类型的数据，就强制类型转换成什么类型，随后进行比较。</span></p> 
<p><span style="color:#494949;"><strong>       注意返回值规定</strong>：<br>                //e1指向的元素 &gt; e2指向的元素 返回值 &gt;0<br>                //e1指向的元素 = e2指向的元素 返回值 =0<br>                //e1指向的元素 &lt; e2指向的元素 返回值 &lt;0</span></p> 
<p></p> 
<p><span style="color:#494949;"><strong>　　默认</strong>这样传递返回值，<strong>是升序排列。</strong></span></p> 
<pre><code class="language-cs">//这样排序默认是升序排列
//
int cmp_int (const void*e1,const void*e2)
{	
	return (* (int*)e1 - *(int*)e2);//所以比较的时候要强制类型转换一下
}
//注意规定：
	//e1指向的元素 &gt; e2指向的元素 返回值 &gt;0
	//e1指向的元素 = e2指向的元素 返回值 =0
	//e1指向的元素 &lt; e2指向的元素 返回值 &lt;0

</code></pre> 
<p></p> 
<p><span style="color:#494949;">　　如果想要变成<strong>降序排列</strong></span></p> 
<p><span style="color:#494949;">　　可以改变e1 e2相减位置，或者直接整体加负号<strong>使其逻辑相反</strong>即可。</span></p> 
<pre><code class="language-cpp">//如果想改成降序排列
//可以改变e1 e2相减位置，或者直接整体加负号使其逻辑相反即可

int cmp_int(const void* e1, const void* e2)
{
	return -(*(int*)e1 - *(int*)e2);
}</code></pre> 
<p></p> 
<p><span style="color:#494949;">插入一个知识点：</span></p> 
<hr> 
<h4></h4> 
<p></p> 
<h4 id="'%20%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%20void*%E7%B1%BB%E5%9E%8B"><span style="color:#494949;">2、介绍一个指针类型 void*类型</span></h4> 
<p></p> 
<p><span style="color:#494949;"><strong>　　论void*的包容性：</strong></span></p> 
<blockquote> 
 <p><span style="color:#494949;">       void*的指针是<strong>无具体类型</strong>的指针，<strong>可以接受任意类型的地址。</strong>是不<strong>能直接进行解应用</strong>操作的，也<strong>不能进行+ -整数</strong>的操作。</span></p> 
 <p></p> 
 <p><span style="color:#494949;">       注意在使用指针指向的内容的时候，要对其<strong>强制类型转换</strong>再解引用。  </span></p> 
</blockquote> 
<h2 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F"><a id="1_20"></a></h2> 
<hr> 
<h4></h4> 
<h3 id="3%E3%80%81%E6%A8%A1%E6%8B%9Fqsort"><span style="color:#494949;">3、模拟qsort</span></h3> 
<p></p> 
<p><span style="color:#494949;">　　注意在my_qsrt中向cmp传参时的强制类型转换：       </span></p> 
<blockquote> 
 <p><span style="color:#494949;">　　　　在这<strong>里传参比较的时候不能直接传递void*类型</strong>的 arr,<strong>void*类型的数据不能加减操作。</strong></span></p> 
 <p></p> 
 <p><span style="color:#494949;">　　　　将void*类型强制转换成<strong>最小类型char*类型，</strong>后续<strong>根据len进行步长的加减。</strong></span></p> 
 <p><br><span style="color:#494949;">　　　　根据cmp返回参数规定，以及qsort默认排列升序，所以是 &gt;0。</span></p> 
</blockquote> 
<pre><code class="language-cpp">//模拟qsort

#include&lt;stdio.h&gt;

void my_qsort(void* arr, int sz, int len, int cmp(void* e1, void* e2));
int cmp_int(const void* e1, const void* e2);

int main()
{
	int arr[] = { 1,2,5,4,7,8,6,3,9 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	my_qsort(arr, sz, sizeof(arr[0]), cmp_int);
	for (int i = 0; i &lt; sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return;
}

int cmp_int (const void*e1,const void*e2)
{	
	return (* (int*)e1 - *(int*)e2);
}

void my_qsort(void* arr, int sz, int len, int cmp(const void* e1, const void* e2))
{
	int i = 0;
	while (sz)
	{
		int flag = 0;
		for (i = 0; i &lt; sz - 1; i++)
		{
			//注意这里传参比较的时候不能直接传递arr,void*类型的数据不能加减操作
			//将void*类型强制转换成最小类型char*类型，后续根据len进行步长的加减
			//根据cmp返回参数规定，以及qsort默认排列升序，所以是 &gt;0
			if (cmp((char*)arr + len * i, (char*)arr + len * (i + 1) )&gt; 0)
			{
				int tmp = *((char*)arr + len * i);
				*((char*)arr + len * i) = *((char*)arr + len * (i + 1));
				*((char*)arr + len * (i + 1)) = tmp;
				flag = 1;
			}
		}
		sz--;
		if (flag == 0)
		{
			break;
		}
	}
}
</code></pre> 
<hr> 
<h2></h2> 
<h2 id="%E4%BA%8C%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span style="color:#494949;">二、回调函数</span></h2> 
<p></p> 
<blockquote> 
 <p><span style="color:#494949;"><strong>       回调函数</strong>就是<strong>一个通过函数指针调用的函数。</strong>如果你把<strong>函数的指针（地址）作为参数传递给另一个 函数，当这个指针被用来调用其所指向的函数时，</strong>我们就说这是<strong>回调函数。</strong></span></p> 
 <p></p> 
 <p><span style="color:#494949;"><strong>        ！注意：</strong>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。<strong>（就比如在使用qsort函数的时候调用的cmp函数</strong></span></p> 
</blockquote> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><span style="color:#494949;">三、在最后</span></h2> 
<p></p> 
<blockquote> 
 <p><span style="color:#494949;">       第一次写完一个正式的关于知识点的博客，vpurple表示自己很开心哈哈哈，这次费的时间还挺长的，还是对这个编辑器运用不熟练www，不过在写这个博客的时候又重新复习了一遍，真的希望要把它记在心里呜呜呜</span></p> 
 <p></p> 
 <p><span style="color:#494949;">      反思一下其实我对于c语言后半部分的知识点基本功都不太扎实，还是要趁着暑假期间把它们全都顺一遍，坚持日更！！！flag反正是立在这里了www绝对不会打脸的！！！</span></p> 
 <p></p> 
 <p><span style="color:#494949;">       还有在最后祝我早日对于qsort函数使用烂熟于心，还有void*和回调函数这些知识点，全都记住！！！</span></p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d475282cd9c2670afc9c6f40d9e952b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Typora1以后版本卡顿解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8fb390118f2cdcc4be86276f0e758fc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL和Navicat的安装与配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>