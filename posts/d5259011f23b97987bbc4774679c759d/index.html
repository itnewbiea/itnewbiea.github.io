<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面相对象 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面相对象" />
<meta property="og:description" content="面向对象 表格结构和类结构：“表格思维”就是一种典型的面向对象思维。
“表格思维”就是一种典型的面向对象思维。在面向对象编程中，下面三句话大家记住：
表结构对应：类结构一行数据对应：一个对象表中所有数据对应：这个类的所有对象
面向对象：对应面向对象就分别称为面向对象分析（OOA）、面向对象设计（OOD）和面向对象编程（OOP）。面向对象(Oriented-Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。
“将相关数据和相关方法封装到一个独立的实体”，于是“对象”产生了。
 对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。
 在内存上，对象就是一个内存块，存放了相关的数据集合！
对象的本质就一种数据的组织方式！
面向过程：
面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 面向对象和面向过程：  都是解决问题的思维方式，都是代码组织的方式。
 面向过程是一种“执行者思维”，解决简单问题可以使用面向过程。
 面向对象是一种“设计者思维”，解决复杂、需要协作的问题可以使用面向对象。
 面向对象离不开面向过程：
 宏观上：通过面向对象进行整体设计
 微观上：执行和处理数据，仍然是面向过程。。
对象和类： 类就是对象的抽象。
类：我们叫做class。 对象：我们叫做Object,instance(实例)
 类可以看成一类对象的模板，对象可以看成该类的一个具体实例。
类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。
对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。
属性（field 成员变量）
属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。
在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。
[修饰符] 属性类型 属性名 = [默认值] ;
方法
方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。
[修饰符] 方法返回值类型 方法名(形参列表) {
// n条语句
}
构造方法(构造器 constructor) 构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。
[修饰符] 类名(形参列表){
//n条语句
}
 构造器通过new关键字调用！！
 构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。
 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！
 构造器的方法名必须和类名一致！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/d5259011f23b97987bbc4774679c759d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-02T08:28:05+08:00" />
<meta property="article:modified_time" content="2019-09-02T08:28:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面相对象</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>面向对象</h3> 
<p>表格结构和类结构：“表格思维”就是一种典型的面向对象思维。<br> “表格思维”就是一种典型的面向对象思维。在面向对象编程中，下面三句话大家记住：</p> 
<ol><li>表结构对应：类结构</li><li>一行数据对应：一个对象</li><li>表中所有数据对应：这个类的所有对象<br> 面向对象：对应面向对象就分别称为面向对象分析（OOA）、面向对象设计（OOD）和面向对象编程（OOP）。面向对象(Oriented-Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。<br> “将相关数据和相关方法封装到一个独立的实体”，于是“对象”产生了。<br>  对象说白了也是一种数据结构(对数据的管理模式)，将数据和数据的行为放到了一起。<br>  在内存上，对象就是一个内存块，存放了相关的数据集合！<br> 对象的本质就一种数据的组织方式！<br> 面向过程：<br> 面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。</li></ol> 
<h3><a id="_15"></a>面向对象和面向过程：</h3> 
<p> 都是解决问题的思维方式，都是代码组织的方式。<br>  面向过程是一种“执行者思维”，解决简单问题可以使用面向过程。<br>  面向对象是一种“设计者思维”，解决复杂、需要协作的问题可以使用面向对象。<br>  面向对象离不开面向过程：<br>  宏观上：通过面向对象进行整体设计<br>  微观上：执行和处理数据，仍然是面向过程。。</p> 
<h3><a id="_24"></a>对象和类：</h3> 
<p>类就是对象的抽象。<br> 类：我们叫做class。 对象：我们叫做Object,instance(实例)<br>  类可以看成一类对象的模板，对象可以看成该类的一个具体实例。<br> 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。<br> 对于一个类来说，一般有三种常见的成员：属性field、方法method、构造器constructor。<br> 属性（field 成员变量）<br> 属性用于定义该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。<br> 在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。</p> 
<p>[修饰符] 属性类型 属性名 = [默认值] ;<br> 方法<br> 方法用于定义该类或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，整个程序由一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。<br> [修饰符] 方法返回值类型 方法名(形参列表) {<!-- --><br> // n条语句<br> }</p> 
<h3><a id="_constructor_42"></a>构造方法(构造器 constructor)</h3> 
<p>构造器也叫构造方法(constructor)，用于对象的初始化。构造器是一个创建对象时被自动调用的特殊方法，目的是对象的初始化。构造器的名称应与类的名称一致。Java通过new关键字来调用构造器，从而返回该类的实例，是一种特殊的方法。<br> [修饰符] 类名(形参列表){<!-- --><br> //n条语句<br> }<br>  构造器通过new关键字调用！！<br>  构造器虽然有返回值，但是不能定义返回值类型(返回值的类型肯定是本类)，不能在构造器里使用return返回某个值。<br>  如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！<br>  构造器的方法名必须和类名一致！</p> 
<p> 构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回了该类对象，但这个对象并不是完全由构造器负责创建的。创建一个对象分为如下四步：<br>  1. 分配对象空间，并将对象成员变量初始化为0或空<br>  2. 执行属性值的显示初始化<br>  3. 执行构造方法<br>  4. 返回对象的地址给相关的变量</p> 
<h3><a id="_61"></a>构造方法的重载</h3> 
<p>如果方法构造中形参名与属性名相同时，需要使用this关键字区分属性与形参。如示例4-6所示：<br> this.id 表示属性id；id表示形参id</p> 
<h3><a id="2_66"></a>面向对象2</h3> 
<h3><a id="_68"></a>一、面向对象的内存分析：</h3> 
<pre><code>	线程的内存区域，（1.程序计数器2.java虚拟机栈3.本地方法栈）
	堆
	方法区（jdk7以前，jdk7开始，jdk8以后/  运行时常量池（字面量和符号引用））
	直接内存——堆外内存
</code></pre> 
<p>（一、）内存分析过程：1.java虚拟机的内存分为三个区域：虚拟机栈stack、堆heap、方法区method area。2. 虚拟机栈的特点（12345）、堆的特点（123）3.方法区特点：（1234）4.内存分配图：1.画图2.结论:1.2.<br> （二、）参数传值机制<br> 1.基本数据类型参数的传值<br> 2.引用类型参数的传值</p> 
<h3><a id="_79"></a>二、垃圾回收机制</h3> 
<p>内存管理：对堆的管理。1.分配2.释放<br> 垃圾回收的过程：1.发现2.回收<br> 垃圾回收相关算法：1.引用计数法：1.1方式1.2优缺点。2.引用可达法（根搜索算法）2.1方式<br> 通用的分代垃圾回收机制：1事实2.年轻代2.1年老代2.2永久代————minor GC \Major GC \ Full GC<br> JVE调优和Full GC的调优：原因：1234<br> 开发中容易造成内存泄漏的操作：经常会造成系统的崩溃。造成内存泄露的场景：1.<br> 其他注意事项：123</p> 
<h3><a id="thisstatic_89"></a>三、this、static关键字:</h3> 
<p>1.对象创建的过程1. 2.1234<br> 2.this的本质<br> 3.This最常用的方法：123<br> Static关键字：1.意义2.特点1234<br> 使用：运行分配图<br> 静态初始化块：1.规则2.执行顺序1.2.</p> 
<h3><a id="_98"></a>四、包机制</h3> 
<p>目的：<br> 方式：<br> Package使用的要点：1.2.<br> 注意事项：1.2.<br> Jdk中主要的包<br> 导入类import：目的：注意要点：<br> 静态导入：作用：</p> 
<h3><a id="_108"></a>一节：继承</h3> 
<p>作用：1.扩展2.建模<br> 继承的实现：<br> 更加容易实现类的扩展。<br> extends的意思是“扩展”。子类是父类的扩展<br> 如果新定义一个Student类，发现已经有Person类包含了我们需要的属性和方法，那么Student类只需要继承Person类即可拥有Person类的属性和方法。<br> Instanceof运算符：<br> instanceof是二元运算符，左边是对象，右边是类；当对象是右面类或子类所创建对象时，返回true；否则，返回false。<br> 继承的使用要点：12345</p> 
<h3><a id="override_119"></a>一、方法的重写override：</h3> 
<p>1.作用：子类通过重写父类的方法，可以用自身的行为替换父类的行为。方法的重写是实现多态的必要条件。<br> 2.方法重写三个要点：123</p> 
<h3><a id="final_124"></a>二、final关键字</h3> 
<p>final关键字的作用：<br> 1.修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值。<br> final int MAX_SPEED = 120;<br> 2.修饰方法：该方法不可被子类重写。但是可以被重载！<br> final void study(){}<br> 3.修饰类: 修饰的类不能被继承。比如：Math、String等。<br> final class A {}<br> 四、继承和组合：<br> 还有一种方式，也可以方便的实现“代码复用”，那就是：“组合”。<br> “组合”不同于继承，更加灵活。<br> “组合”的核心就是“将父类对象作为子类的属性”，然后，“子类通过调用这个属性来获得父类的属性和方法”。<br> 组合比较灵活。继承只能有一个父类，但是组合可以有多个属性。<br> 继承除了代码复用、也能方便我们对事务建模。所以，对于“is -a”关系建议使用继承，“has-a”关系建议使用组合。</p> 
<h3><a id="Object_140"></a>Object类详解</h3> 
<p>Object类基本特性：Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。<br> 一、ToString方法：Object类中定义有public String toString()方法，其返回值是 String 类型。<br> Object类中toString方法的源码为：<br> public String toString() {<!-- --><br> return getClass().getName() + “@” + Integer.toHexString(hashCode());<br> }<br> 重写toString（）方法：</p> 
<h3><a id="equals_150"></a>二、==和equals方法：</h3> 
<p>1.<mark>:“</mark>”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。<br> 2.Object类中定义有：public boolean equals(Object obj)方法，提供定义“对象内容相等”的逻辑。<br> 3.Object 的 equals 方法默认就是比较两个对象的hashcode，是同一个对象的引用时返回 true 否则返回 false。但是，我们可以根据我们自己的要求重写equals方法。</p> 
<h3><a id="Super_156"></a>三、Super关键字：</h3> 
<p>1.super“可以看做”是直接父类对象的引用<br> 2.使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。<br> 3.在一个类中，若是构造方法的第一行代码没有显式的调用super(…)或者this(…);那么Java默认都会调用super(),含义是调用父类的无参数构造方法。这里的super()可以省略</p> 
<h3><a id="_162"></a>四、继承树追溯</h3> 
<p> 1.属性方法查找顺序<br>  查找当前类中有没有属性h<br>  依次上溯每个父类，查看每个父类中是否有h，直到Object<br>  如果没找到，则出现编译错误。<br>  上面步骤，只要找到h变量，则这个过程终止。</p> 
<p>2.构造方法调用顺序：构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止</p> 
<h3><a id="encapsulation_172"></a>封装(encapsulation)</h3> 
<p>封装的作用和含义<br> 封装的实现—使用访问控制符<br> 封装的使用细节：<br> 类的属性的处理:<br>  一般使用private访问权限。<br>  提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作（注意：boolean变量的get方法是is开头!）。<br>  一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。</p> 
<h3><a id="_182"></a>多态</h3> 
<p>多态概念和实现<br> 多态的要点：</p> 
<ol><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</li></ol> 
<p>即父类引用做方法的形参，实参可以是任意的子类对象，可以通过不同的子类对象实现不同的行为方式。但是多态也有弊端，就是无法调用子类特有的功能</p> 
<h3><a id="casting_193"></a>对象的转型(casting)</h3> 
<p>父类引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。<br> 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型！<br> 在向下转型过程中，必须将引用变量转成真实的子类类型(运行时类型）否则会出现类型转换异常ClassCastException。</p> 
<h3><a id="_200"></a>抽象类和接口</h3> 
<p>抽象方法<br> 抽象类<br> 抽象类的使用要点:12345</p> 
<h3><a id="_206"></a>接口</h3> 
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。<br> 接口的作用<br> 定义接口：<br> 使用接口：<br> 接口要点：</p> 
<p>接口中定义静态方法和默认方法：</p> 
<p>默认方法：，允许给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做默认方法（也称为扩展方法）<br> 默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是。作为替代方式，接口可以提供默认方法的实现，所有这个接口的实现类都会通过继承得到这个方法。</p> 
<p>静态方法：</p> 
<p>JAVA8以后，我们也可以在接口中直接定义静态方法的实现。这个静态方法直接从属于接口（接口也是类，一种特殊的类），可以通过接口名调用。</p> 
<p>如果子类中定义了相同名字的静态方法，直接从属于子类。可以通过子类名直接调用。</p> 
<p>接口的多继承<br> 接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切</p> 
<p>面向接口编程<br> 面向接口编程(AOP Aspect Object programming)是面向对象编程的一部分。</p> 
<h3><a id="String_231"></a>字符串String类详解</h3> 
<p>String基础</p> 
<p> String基础：String类又称作不可变字符序列。<br>  String位于java.lang包中，Java程序默认导入java.lang包下的所有类。<br>  Java字符串就是Unicode字符序列，例如字符串“Java”就是4个Unicode字符’J’、’a’、’v’、’a’组成的。<br>  Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。</p> 
<p>String类的简单使用<br> 字符串连接<br> "+"连接符<br> String类和常量池<br> 常量池一下三种：</p> 
<ol><li>全局字符串常量池（String Pool）</li><li>class文件常量池（Class Constant Pool）</li><li>运行时常量池（Runtime Constant Pool）</li></ol> 
<p>String类常用的方法<br> 字符串相等的判断：<br>  equals方法用来检测两个字符串内容是否相等。如果字符串s和t内容相等，则s.equals(t)返回true，否则返回false。<br>  要测试两个字符串除了大小写区别外是否是相等的，需要使用equalsIgnoreCase方法。<br>  判断字符串是否相等不要使用"=="。</p> 
<h3><a id="_258"></a>内部类</h3> 
<p>概念：，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。<br> 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类（我们以前接触的类）只能使用public和default修饰。<br> 内部类的作用：<br>  内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。<br>  内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。<br>  接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。<br>  内部类的使用场合：<br>  由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。<br>  使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。</p> 
<p>内部类的分类<br> 在Java中内部类主要分为成员内部类（非静态内部类、静态内部类）、匿名内部类、局部内部类。<br> i. 成员内部类（可以使用private、default、protected、public任意进行修饰。 类文件：外部类$内部类.class）：1.非静态内部类（外部类里使用非静态内部类和平时使用其他类没什么不同）、、、、\\成员变量访问要点：123\内部类的访问：12<br> ii. <br> b) <br> 2.静态内部类,使用要点：1.2.\\ 静态内部类的访问</p> 
<p> 匿名内部类：适合那种只需要使用一次的类。</p> 
<p> 局部内部类：</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5f1fc8a37d5816f8cefcba611bafbac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RestTemplate使用JSON发送Post请求</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1df5da7e140d720a548295d2cd2fc00d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt：正确判断文件、文件夹是否存在的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>