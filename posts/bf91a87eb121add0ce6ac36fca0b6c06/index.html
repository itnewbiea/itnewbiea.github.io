<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第十七节 DRM 图形显示框架 - IT学习者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第十七节 DRM 图形显示框架" />
<meta property="og:description" content="以往我们在Linux 上为显示设备开发驱动时，通常使用的是FrameBuffer 的驱动框架，在Frame-Buffer 驱动框架下，我们能够快速开发出可供简单使用的显示驱动。但是随着芯片显示外设的性能逐渐增强及GPU 的引入，FrameBuffer 框架看起来似乎就有些落伍了，最直接的体现，就是在传统的框架下，对于许多芯片显示外设的新特性如：显示覆盖（菜单层级）、GPU 加速、硬件光标等功能并不能得到很好得支持，并且FrameBuffer 框架将底层的显存通过用户空间/dev/fb 接口，暴露给了用户空间，这很容易导致不同的应用程序在操作显存时，产生访问冲突，而且这种方式看起来似乎不是那么安全。
在这背景下，就需要一个现代的图形显示框架来解决这些问题，那么DRM（Direct Rendering Manager，直接图形管理器）诞生。
框架简述 那么DRM 图形显示框架是怎么解决FrameBuffer 框架遇到的困境呢？DRM 将现代显示领域中会涉及的一些操作进行分层并使这些模块独立，如过上层应用想操作显存、显示效果抑或是GPU，都必须在一些框架的约束下进行，我们可以来了解一下。
我们可以从用户空间、内核空间的两个角度去了解DRM 框架：
用户空间（libdrm driver）：
Libdrm（DRM 框架在用户空间的Lib） 内核空间（DRM driver）：
KMS（Kernel Mode Setting，内核显示模式设置）GEM（Graphic Execution Manager，图形执行管理器） Libdrm DRM 框架在用户空间提供的Lib，用户或应用程序在用户空间调用libdrm 提供的库函数，即可访问到显示的资源，并对显示资源进行管理和使用。
这样通过libdrm 对显示资源进行统一访问，libdrm 将命令传递到内核最终由DRM 驱动接管各应用的请求并处理，可以有效避免访问冲突。
KMS（Kernel Mode Setting） KMS 属于DRM 框架下的一个大模块，主要负责两个功能：显示参数及显示控制。这两个基本功能可以说是显示驱动必须基本的能力，在DRM 框架下，为了将这两部分适配得符合现代显示设备逻辑，又分出了几部分子模块配合框架。
Planes 基本的显示控制单位，每个图像拥有一个Planes，Planes 的属性控制着图像的显示区域、图像翻转、色彩混合方式等，最终图像经过Planes 并通过CRTC 组件，得到多个图像的混合显示或单独显示的等等功能。
CRTC CRTC 的工作，就是负责把要显示图像，转化为底层硬件层面上的具体时序要求，还负责着帧切换、电源控制、色彩调整等等。
Encoder Encoder 的工作则是负责电源管理、视频输出格式封装（比如要将视频输出到HDMI 接口、MIPI接口等）。
Connector Connector 连接器负责硬件设备的接入、屏参获取等。
上述的这些组件，最终完成了一个完整的DRM 显示控制过程，如下图所示：
参考资料Kernel Mode Setting (KMS) .
GEM（generic DRM memory-management） 顾名思义，GEM 负责对DRM 使用的内存（如显存）进行管理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://itnewbiea.github.io/posts/bf91a87eb121add0ce6ac36fca0b6c06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-18T10:40:50+08:00" />
<meta property="article:modified_time" content="2023-02-18T10:40:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="IT学习者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">IT学习者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第十七节 DRM 图形显示框架</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>以往我们在Linux 上为显示设备开发驱动时，通常使用的是FrameBuffer 的驱动框架，在Frame-Buffer 驱动框架下，我们能够快速开发出可供简单使用的显示驱动。但是随着芯片显示外设的性能逐渐增强及GPU 的引入，FrameBuffer 框架看起来似乎就有些落伍了，最直接的体现，就是在传统的框架下，对于许多芯片显示外设的新特性如：显示覆盖（菜单层级）、GPU 加速、硬件光标等功能并不能得到很好得支持，并且FrameBuffer 框架将底层的显存通过用户空间/dev/fb 接口，暴露给了用户空间，这很容易导致不同的应用程序在操作显存时，产生访问冲突，而且这种方式看起来似乎不是那么安全。</p> 
<p>在这背景下，就需要一个现代的图形显示框架来解决这些问题，那么DRM（Direct Rendering Manager，直接图形管理器）诞生。</p> 
<h2><a id="_4"></a>框架简述</h2> 
<p>那么DRM 图形显示框架是怎么解决FrameBuffer 框架遇到的困境呢？DRM 将现代显示领域中会涉及的一些操作进行分层并使这些模块独立，如过上层应用想操作显存、显示效果抑或是GPU，都必须在一些框架的约束下进行，我们可以来了解一下。</p> 
<p>我们可以从用户空间、内核空间的两个角度去了解DRM 框架：</p> 
<p>用户空间（libdrm driver）：</p> 
<ul><li>Libdrm（DRM 框架在用户空间的Lib）</li></ul> 
<p>内核空间（DRM driver）：</p> 
<ul><li>KMS（Kernel Mode Setting，内核显示模式设置）</li><li>GEM（Graphic Execution Manager，图形执行管理器）</li></ul> 
<p><img src="https://images2.imgbox.com/2e/93/LcZrBmhZ_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Libdrm_21"></a>Libdrm</h3> 
<p>DRM 框架在用户空间提供的Lib，用户或应用程序在用户空间调用libdrm 提供的库函数，即可访问到显示的资源，并对显示资源进行管理和使用。</p> 
<p>这样通过libdrm 对显示资源进行统一访问，libdrm 将命令传递到内核最终由DRM 驱动接管各应用的请求并处理，可以有效避免访问冲突。</p> 
<h3><a id="KMSKernel_Mode_Setting_27"></a>KMS（Kernel Mode Setting）</h3> 
<p>KMS 属于DRM 框架下的一个大模块，主要负责两个功能：显示参数及显示控制。这两个基本功能可以说是显示驱动必须基本的能力，在DRM 框架下，为了将这两部分适配得符合现代显示设备逻辑，又分出了几部分子模块配合框架。</p> 
<h4><a id="Planes_31"></a>Planes</h4> 
<p>基本的显示控制单位，每个图像拥有一个Planes，Planes 的属性控制着图像的显示区域、图像翻转、色彩混合方式等，最终图像经过Planes 并通过CRTC 组件，得到多个图像的混合显示或单独显示的等等功能。</p> 
<h4><a id="CRTC_35"></a>CRTC</h4> 
<p>CRTC 的工作，就是负责把要显示图像，转化为底层硬件层面上的具体时序要求，还负责着帧切换、电源控制、色彩调整等等。</p> 
<h4><a id="Encoder_39"></a>Encoder</h4> 
<p>Encoder 的工作则是负责电源管理、视频输出格式封装（比如要将视频输出到HDMI 接口、MIPI接口等）。</p> 
<h4><a id="Connector_43"></a>Connector</h4> 
<p>Connector 连接器负责硬件设备的接入、屏参获取等。</p> 
<p>上述的这些组件，最终完成了一个完整的DRM 显示控制过程，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/e7/52/izU7A5Ch_o.png" alt="在这里插入图片描述"></p> 
<p>参考资料Kernel Mode Setting (KMS) .</p> 
<h3><a id="GEMgeneric_DRM_memorymanagement_54"></a>GEM（generic DRM memory-management）</h3> 
<p>顾名思义，GEM 负责对DRM 使用的内存（如显存）进行管理。</p> 
<p>GEM 框架提供的功能包括：</p> 
<ul><li>内存分配和释放</li><li>命令执行</li><li>执行命令时的管理</li></ul> 
<p>参考资料The Graphics Execution Manager (GEM) .</p> 
<h2><a id="_65"></a>驱动简述</h2> 
<p>我们通过简单讲解了DRM 驱动的框架，简单地带领大家认识了DRM 框架下对显示功能的实现方法。实际的代码细节远比上述给大家介绍的内容复杂得多，给大家讲解框架组件功能只是起到一个抛砖引玉的作用，如果对代码细节感兴趣的同学，可以在目录drivers/gpu/drm 中，查看具体的驱动实现。</p> 
<p>在实际的使用中，我这里将DRM 的驱动实现分为了两个部分，主机驱动和设备驱动。主机驱动指的是片上的负责显示功能的外设驱动，如MP157 上的LTDC 外设、DSI 外设的驱动，这些一般由芯片厂商如ST、NXP 等来负责实现，完成一个DRM-Host，主机驱动代码一般位于drivers/gpu/drm/xxx/ 目录下，这里xxx 代指芯片厂商如ST、NXP。</p> 
<p>一般我们要做的，就是现实一个设备驱动，比如针对某款LCD 显示屏，将其参数（LCD Timing、Size⋯）、显示方式（DSI、HDMI⋯）等通过设备驱动，和主机驱动关联起来。</p> 
<p>在内核的DRM 驱动目录中，给出了许多设备驱动的示例，详见目录：drivers/gpu/drm/panel.</p> 
<p>一个简单的DRM 框架显示设备驱动例子可以参考drivers/gpu/drm/panel/panel-simple.c .</p> 
<h2><a id="_77"></a>设备树插件描述</h2> 
<p>MP157 开发板支持两种接口的LCD 显示屏：RGB（MIPI DPI）、MIPI DSI，由于显示原理不同，所以分别对应着两款设备树插件，使用的也是不同的设备驱动，但是其驱动框架仍是DRM。</p> 
<hr> 
<p>重要: 两种接口RGB、DSI 屏幕不可同时使用！</p> 
<hr> 
<p>既然作为显示设备，那么设备树上描述的属性必然是和显示屏相关的内容，比如：屏幕的displaytiming、ddc 读取显示器EDID 结构等，详见及参考内核Documentation/devicetree/bindings/display/panel 目录下的各种dt-bingdings，如：</p> 
<ul><li>通用的bingdings 文档：<br> Documentation/devicetree/bindings/display/panel/panel-common.txt<br> Documentation/devicetree/bindings/display/panel/panel-dpi.txt<br> Documentation/devicetree/bindings/display/panel/panel-dsi-cm.txt</li><li>各种实例显示设备的bingdings 文档。</li></ul> 
<p>各种的bingdings 文档，可以帮助你快速了解一个设备树里描述的属性内容，及如何去写一个对应的设备树节点。</p> 
<p>这里再补充一些知识，MIPI 联盟提出了许多显示规范，有：DBI（Display Bus Interface 带控制器及显存的并行接口显示模块）、DPI（Display Pixel Interface 不带控制器或显存的并行接口显示模块）、DSI（Display Serial Interface 高速串行接口）、DCS(Display Command Set 用显示命令集操作的显示模块）。我们常说的RGB 接口屏幕，也就是不带控制器及显存的并行接口屏幕，DBI 的代表则有80 接口MCU 屏，至于DSI 则是串行接口屏幕了，手机中常用的就是DSI 接口屏幕。</p> 
<p>参考资料：MIPI Specifications .</p> 
<h3><a id="RGBLCD__100"></a>RGB-LCD 设备树插件</h3> 
<p>设备树插件的源码非常长，此处不便展示，源码位于如下目录：</p> 
<pre><code class="prism language-c">arch<span class="token operator">/</span>arm<span class="token operator">/</span>boot<span class="token operator">/</span>dts<span class="token operator">/</span>overlays<span class="token operator">/</span>stm<span class="token operator">-</span>fire<span class="token operator">-</span>lcd<span class="token operator">-</span>overlay<span class="token punctuation">.</span>dts
</code></pre> 
<p>其驱动目录对应为：</p> 
<pre><code class="prism language-c">drivers<span class="token operator">/</span>gpu<span class="token operator">/</span>drm<span class="token operator">/</span>panel<span class="token operator">/</span>panel<span class="token operator">-</span>simple<span class="token punctuation">.</span>c
</code></pre> 
<h3><a id="DSILCD__114"></a>DSI-LCD 设备树插件</h3> 
<p>源码位于如下目录：</p> 
<pre><code class="prism language-c">arch<span class="token operator">/</span>arm<span class="token operator">/</span>boot<span class="token operator">/</span>dts<span class="token operator">/</span>overlays<span class="token operator">/</span>stm<span class="token operator">-</span>fire<span class="token operator">-</span>mipi<span class="token operator">-</span>overlay<span class="token punctuation">.</span>dts
</code></pre> 
<p>其驱动目录对应为：</p> 
<pre><code class="prism language-c">drivers<span class="token operator">/</span>gpu<span class="token operator">/</span>drm<span class="token operator">/</span>panel<span class="token operator">/</span>panel<span class="token operator">-</span>himax<span class="token operator">-</span>hx8394<span class="token punctuation">.</span>c
</code></pre> 
<h2><a id="_128"></a>实验准备</h2> 
<p>下面我们就以野火的4.3 寸RGB 屏幕为例，为大家测试在DRM 驱动框架下的驱动效果，我们进行屏幕的测试。</p> 
<h3><a id="_132"></a>添加设备树插件</h3> 
<p>方法参考如下：</p> 
<p><img src="https://images2.imgbox.com/4b/82/1pLzAOPo_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>重要: 如果使用DSI 屏幕，请将stm-fire-lcd.dtbo 及stm-fire-mipi.dtbo 设备树插件同时打开。若使用RGB 屏幕，则只将stm-fire-lcd.dtbo 打开。</p> 
<hr> 
<p>以野火的4.3 寸RGB 屏幕为例，操作如下：</p> 
<p><img src="https://images2.imgbox.com/8f/b3/NNNBH5yL_o.png" alt="在这里插入图片描述"></p> 
<p>如需调整屏幕参数，请使用fire-config 工具调整，参考：</p> 
<p>《fire-config 修改液晶参数》</p> 
<p>如若运行代码时出现“Device or resource busy”或者运行代码卡死等等现象，请按上述情况检查并按上述步骤操作。</p> 
<p>如出现Permission denied 或类似字样，请注意用户权限，大部分操作硬件外设的功能，几乎都需要root 用户权限，简单的解决方案是在执行语句前加入sudo 或以root 用户运行程序。</p> 
<h3><a id="libdrm__155"></a>libdrm 测试程序</h3> 
<p>野火MP157 开发板中，DRM 驱动默认被配置为编译进内核，驱动加载后，会在/dev/dri/ 目录下创建显示设备的节点，我们的应用程序就是通过open 这些节点，调用libdrm 的API 去进行LCD 控制和显示的。</p> 
<p>如下图，我们的RGB 显示屏即为/dev/dri/card0 节点.</p> 
<p><img src="https://images2.imgbox.com/54/f8/uUxjsK9l_o.png" alt="在这里插入图片描述"></p> 
<p>编写一个libdrm 的测试程序较为复杂，这里我们使用libdrm 官方的测试工具来进行测试，我们可以在这里下载源码并进行交叉编译出测试工具，以供在开发板上使用：libdrm .</p> 
<p>新版的libdrm 使用meson+ninja 的构建方式，而不是老版的autotools，没有基础的同学构建新版libdrm 会比较痛苦。建议直接使用我们给大家编译好的测试程序，测试程序位于\linux_driver\framework_drm\modetest。</p> 
<p>对libdrm 测试程序感兴趣的同学，可以下载libdrm 源码解压，在其目录/libdrm-2.4.105/tests/下，查看modetest.c 文件，此为测试程序源码。</p> 
<h2><a id="_169"></a>实验操作</h2> 
<p>将上述的modetest 测试程序上传至开发板中，并使用chmod 添加执行权限。</p> 
<p>运行modetest 程序，点击图片可放大：</p> 
<p><img src="https://images2.imgbox.com/ed/b2/BLrloUGI_o.png" alt="在这里插入图片描述"></p> 
<p>待程序检测执行完毕，会列举出开发板上的DRM 框架下的显示设备。</p> 
<p>其中一些字样如Encoders、Connectors、CRTCs 经过前面的介绍，大家都应该有了一点印象。</p> 
<p>DRM 框架下的显示过程如下图示：</p> 
<p><img src="https://images2.imgbox.com/ac/e5/DR3Sf5aC_o.png" alt="在这里插入图片描述"></p> 
<p>我们要做的，就是找出前面终端中打印的RGB 屏幕对应的connectors、CRTCs 的ID：</p> 
<p><img src="https://images2.imgbox.com/ef/9c/NUPSI5eF_o.png" alt="在这里插入图片描述"></p> 
<p>图中状态为connected 的connectorsID 为31，并且从name 中可以看出为DPI 接口的屏幕，正是我们的RGB 屏。CRTCs 对象中，唯一个id 为34 的CRTC，参数也为我们的RGB 屏幕参数。</p> 
<p>则我们可以执行如下命令进行测试：</p> 
<pre><code class="prism language-c"><span class="token punctuation">.</span><span class="token operator">/</span>modetest <span class="token operator">-</span>M stm <span class="token operator">-</span>s <span class="token number">31</span>@<span class="token number">34</span><span class="token operator">:</span><span class="token number">480</span>x272
</code></pre> 
<p>其中31、34 分别为我们屏幕的Connectors ID、CRTCs ID，实验现象如图示：</p> 
<p><img src="https://images2.imgbox.com/88/24/nf6d1y7A_o.png" alt="在这里插入图片描述"></p> 
<p>在终端中按下回车键退出测试。</p> 
<p>关于测试的更多相关内容，可以参考linux DRM/KMS 测试工具modetest .</p> 
<p>文章末尾补充小知识，虽说DRM 功能符合现代显示设备的需求，但是仍有众多的老设备及软件需要Framebuffer 的支持。所以在DRM 框架下，有部分代码用于实现在DRM 框架下，去模拟FB设备。</p> 
<p>在ST 提供的显示驱动代码中，也有模拟FB 设备的相关代码，参见drivers/gpu/drm/stm/drv.c 文件，最终效果就是设备目录下，出现熟悉的身影/dev/fb0 。</p> 
<p>我们可以通过传统测试FrameBuffer 设备的方式，使用如下命令来测试它：</p> 
<pre><code class="prism language-c"># 会得到类似花屏的效果
cat <span class="token operator">/</span>dev<span class="token operator">/</span>random <span class="token operator">&gt;</span> <span class="token operator">/</span>dev<span class="token operator">/</span>fb0
</code></pre> 
<p>相关新闻可以查看Generic-FBDEV-Emulation .</p> 
<hr> 
<p>参考资料：嵌入式Linux 驱动开发实战指南-基于STM32MP1 系列</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74628cf233fcaea7913ce1e68c8f411d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于SpringBoot解决前后端分离项目跨域的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ec55189bbac93f4b5d528140a93f52c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最全：2023年华为认证HCIA&#43;HCIP题库合集（含答案解析）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 IT学习者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<script src="https://itnewbiea.github.io/js/foot.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>